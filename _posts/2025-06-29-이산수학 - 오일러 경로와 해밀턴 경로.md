---
layout: post
title: 이산수학 - 오일러 경로와 해밀턴 경로
date: 2025-06-29 20:20:23 +0900
category: 이산수학
---
# 오일러 경로와 해밀턴 경로

## 용어와 큰 그림

- **오일러(Eulerian)**: **간선**을 한 번씩 모두 방문(정점은 중복 가능).
  - *경로(path)*: 시작≠끝 가능
  - *회로(circuit/trail)*: 시작=끝
- **해밀턴(Hamiltonian)**: **정점**을 한 번씩 모두 방문(간선은 중복 X).
  - *경로*: 시작≠끝 가능
  - *회로(사이클)*: 시작=끝

---

## 오일러 경로 (Eulerian Path)

### 정의

- **오일러 경로**: 그래프의 모든 간선을 정확히 한 번씩 방문하는 경로.
- **오일러 회로**: 오일러 경로이면서 시작=끝.

### 무방향 그래프의 존재 조건 (필요충분)

연결(간선이 있는 정점들의 부분 그래프가 연결)이고,

- **모든 정점 차수가 짝수**이면 **오일러 회로** 존재.
- **홀수 차수 정점이 정확히 2개**면 **오일러 경로(비회로)** 존재.
- 그 외에는 존재하지 않음.

**증명 스케치(핵심 아이디어)**
- (충분성) Hierholzer 알고리즘으로 항상 구성 가능.
- (필요성) 간선을 지나면 각 정점에서 “들어온 횟수 = 나간 횟수”가 되므로, 시작/끝을 제외하면 짝수 차수여야 함. 시작·끝이 다르면 두 정점만 홀수. (핸드셰이킹 정리 사용: 홀수 차수 정점의 개수는 짝수)

### 방향 그래프의 존재 조건 (필요충분)

간선이 있는 정점들이 **기저 무방향 그래프에서 약연결**이고,

- **회로**: 모든 정점에서 $$\text{outdeg}(v)=\text{indeg}(v)$$.
- **경로**:
  - 어떤 정점 \(s\)는 $$\text{outdeg}(s)=\text{indeg}(s)+1$$ (시작),
  - 어떤 정점 \(t\)는 $$\text{indeg}(t)=\text{outdeg}(t)+1$$ (끝),
  - 나머지는 모두 $$\text{outdeg}=\text{indeg}$$.

또한 **0차수 정점을 제외한 부분**이 “적절히” 연결(모든 간선이 하나의 도달성 구성 안에 존재)이어야 함.

### 구성 알고리즘 — **Hierholzer** (무/유향, 멀티그래프 OK)

- 아이디어: 임의의 정점에서 출발 → **막다른 곳**에 이를 때까지 간선을 따라가며 **사용한 간선은 제거** → 막다른 점에서 이전 스택으로 돌아와 미사용 간선이 남은 곳에서 이어붙이는 방식.
- 시간복잡도: **$$O(V+E)$$** (각 간선은 정확히 한 번 제거/추가됨).
- **Fleury**는 다리(bridge)를 피하며 고르는 방식으로 $$O(E^2)$$까지 느릴 수 있어 실전에서는 **Hierholzer**를 권장.

#### 안전 구현 포인트

- **멀티간선** 지원을 위해 `Counter`(또는 map)로 인접 목록 관리 → 제거 시 양방향 감소.
- **시작점 선택**: 홀수 차수가 2개면 그 중 하나, 아니면 임의의(간선 보유) 정점.
- 그래프가 **분리**되어 있지 않은지(간선이 있는 정점군이 1개 성분인지) 확인.

#### 구현 포인트

- 각 정점의 **이터레이터**로 out-edge를 소모.
- 시작점 규칙(상단 조건)에 맞춰 선택.

---

## 해밀턴 경로 (Hamiltonian Path)

### 정의

- **해밀턴 경로**: 모든 정점을 정확히 한 번씩 방문.
- **해밀턴 회로**: 시작=끝으로 모든 정점 1회씩.

### 난이도/복잡도

- 존재 여부 판정이 **NP-완전**(일반 그래프).
- 최적화(TSP)는 **NP-난해**.

### 알려진 **충분조건**(필요조건 아님)

- **Dirac 정리**: \(n\ge 3\)이고 모든 정점 차수 \(\deg(v)\ge n/2\) 이면 **해밀턴 사이클** 존재.
- **Ore 정리**: 서로 인접하지 않은 임의의 두 정점 \(u,v\)에 대해 \(\deg(u)+\deg(v)\ge n\)이면 해밀턴 사이클 존재.
- **Bondy–Chvátal closure**: 클로저를 완전그래프로 만들 수 있으면 해밀턴. (고급)

> 실전에서는 **충분조건 검사** + **백트래킹/DP/휴리스틱** 혼합.

### 구성/체크 방법

- **백트래킹 + 가지치기**: 소규모/특정 구조에서 실용.
- **비트마스크 DP (Held–Karp 스타일)**: 존재판정/경로복원 **$$O(n^2 2^n)$$**.
- 휴리스틱: DFS 변형, 최근접-이웃, 2-opt(회로), 그래프 특성 기반 규칙 등.

---

## 파이썬 구현 (검증 포함)

### 오일러 — 무방향 (멀티간선 안전)

```python
from collections import defaultdict, Counter, deque

def is_connected_on_nonisolated_undirected(adj):
    """간선이 있는 정점들의 부분그래프가 연결인지 확인."""
    nodes = [u for u, nb in adj.items() if sum(nb.values()) > 0]
    if not nodes:  # 간선이 전혀 없다면 '연결'로 간주(빈 경로/단일정점)
        return True
    seen=set(); q=deque([nodes[0]]); seen.add(nodes[0])
    while q:
        u=q.popleft()
        for v,cnt in adj[u].items():
            if cnt>0 and v not in seen:
                seen.add(v); q.append(v)
    return len(seen)==len(nodes)

def eulerian_status_undirected(edges, n=None):
    """
    edges: [(u,v), ...] 무방향 멀티간선 허용.
    return: ("circuit"|"path"|"none", start_candidates, degree)
    """
    if n is None:
        n = 1+max([max(u,v) for u,v in edges] or [0])
    adj = defaultdict(Counter)
    deg = [0]*n
    for u,v in edges:
        if u==v:  # 루프: 차수 +2 (무방향)
            adj[u][v]+=1
            deg[u]+=2
        else:
            adj[u][v]+=1; adj[v][u]+=1
            deg[u]+=1; deg[v]+=1
    if not is_connected_on_nonisolated_undirected(adj):
        return "none", [], deg
    odd = [i for i,d in enumerate(deg) if d%2==1]
    if len(odd)==0:
        # 회로: 간선 가진 아무 정점이나 시작
        starts = [i for i,d in enumerate(deg) if d>0] or [0]
        return "circuit", starts, deg
    elif len(odd)==2:
        return "path", odd, deg
    else:
        return "none", [], deg

def hierholzer_undirected(edges, n=None):
    """
    오일러 경로/회로를 구성. 없으면 None.
    멀티간선·루프 지원.
    """
    status, starts, deg = eulerian_status_undirected(edges, n)
    if status=="none":
        return None
    if n is None:
        n = 1+max([max(u,v) for u,v in edges] or [0])
    adj = defaultdict(Counter)
    for u,v in edges:
        adj[u][v]+=1
        if u!=v: adj[v][u]+=1  # 루프는 한쪽만 기록해도 Counter로 처리됨
        else:    adj[u][u]+=0  # 표현 일관성
    start = starts[0]
    # 스택 기반 Hierholzer
    stack = [start]
    path = []
    while stack:
        u = stack[-1]
        if not adj[u]:
            path.append(stack.pop())
            continue
        # 남은 간선 하나 집기
        v, cnt = next(iter(adj[u].items()))
        # 간선 제거 (양방향)
        adj[u][v]-=1
        if adj[u][v]==0: del adj[u][v]
        if u!=v:
            adj[v][u]-=1
            if adj[v][u]==0: del adj[v][u]
        else:
            # 루프 하나 제거 시 u-u 한 번만 감소했으므로 추가 감소 불필요
            pass
        stack.append(v)
    # path는 정점열. 간선 수+1 길이여야 함
    if len(path) != len(edges)+1:
        return None
    return path[::-1]
```

**검증 예시**

```python
# 사각 사이클: 0-1-2-3-0  (모든 차수=2 → 회로)

edges = [(0,1),(1,2),(2,3),(3,0)]
print(eulerian_status_undirected(edges))  # ('circuit', [0,1,2,3], [2,2,2,2])
print(hierholzer_undirected(edges))       # 예: [0,1,2,3,0]

# “경로만” 가능한 예: 0-1-2 (홀수 차수 정점=2개)

edges = [(0,1),(1,2)]
print(eulerian_status_undirected(edges))  # ('path', [0,2], [1,2,1])
print(hierholzer_undirected(edges))       # 예: [0,1,2]
```

### 오일러 — 방향 그래프

```python
from collections import defaultdict

def eulerian_status_directed(edges, n=None):
    """
    edges: [(u,v), ...] (유향)
    return: ("circuit"|"path"|"none", start_candidates, indeg, outdeg)
    """
    if n is None:
        n = 1+max([max(u,v) for u,v in edges] or [0])
    outdeg=[0]*n; indeg=[0]*n
    adj = defaultdict(list)
    undirected = defaultdict(set)
    for u,v in edges:
        adj[u].append(v)
        outdeg[u]+=1; indeg[v]+=1
        undirected[u].add(v); undirected[v].add(u)
    # 0차수 제외 부분이 약연결인지
    nodes = [i for i in range(n) if outdeg[i]+indeg[i]>0]
    if nodes:
        seen=set([nodes[0]])
        from collections import deque
        q=deque([nodes[0]])
        while q:
            u=q.popleft()
            for w in undirected[u]:
                if w not in seen:
                    seen.add(w); q.append(w)
        if len(seen)!=len(nodes):
            return "none", [], indeg, outdeg
    start=end=None
    for v in range(n):
        if outdeg[v]==indeg[v]: continue
        if outdeg[v]==indeg[v]+1:
            if start is None: start=v
            else: return "none", [], indeg, outdeg
        elif indeg[v]==outdeg[v]+1:
            if end is None: end=v
            else: return "none", [], indeg, outdeg
        else:
            return "none", [], indeg, outdeg
    if start is None and end is None:
        starts = nodes or [0]
        return "circuit", starts, indeg, outdeg
    if start is not None and end is not None:
        return "path", [start], indeg, outdeg
    return "none", [], indeg, outdeg

def hierholzer_directed(edges, n=None):
    status, starts, indeg, outdeg = eulerian_status_directed(edges, n)
    if status=="none":
        return None
    if n is None:
        n = 1+max([max(u,v) for u,v in edges] or [0])
    adj = defaultdict(list)
    for u,v in edges:
        adj[u].append(v)
    # 각 정점별 이터레이터 인덱스
    it = {u:0 for u in range(n)}
    start = starts[0] if starts else 0
    stack=[start]; path=[]
    while stack:
        u=stack[-1]
        if it[u] < len(adj[u]):
            v = adj[u][it[u]]; it[u]+=1
            stack.append(v)
        else:
            path.append(stack.pop())
    if len(path)!=len(edges)+1:
        return None
    return path[::-1]
```

**검증 예시**

```python
# 유향 회로 예: 0→1→2→0

edges = [(0,1),(1,2),(2,0)]
print(eulerian_status_directed(edges)[0])  # 'circuit'
print(hierholzer_directed(edges))          # 예: [0,1,2,0]

# 유향 경로 예: 0→1, 1→2 (시작 out=1, end in=1)

edges = [(0,1),(1,2)]
print(eulerian_status_directed(edges)[0])  # 'path'
print(hierholzer_directed(edges))          # [0,1,2]
```

---

### 해밀턴 — 백트래킹(작은 n), 비트마스크 DP(중간 n)

#### 백트래킹 + 기본 가지치기

```python
def hamiltonian_path_backtrack(g, start=None):
    """
    g: dict[u] -> iterable of neighbors (무/유향 모두 사용 가능)
    start: None이면 모든 정점을 시도
    반환: 정점열 or None
    """
    nodes=list(g.keys())
    N=len(nodes); idx={v:i for i,v in enumerate(nodes)}
    # 인접을 set으로 최적화
    nbr = {u:set(vs) for u,vs in g.items()}
    def dfs(path, seen):
        if len(path)==N: return path
        u=path[-1]
        # 간단 가지치기: (선택적으로) 남은 정점이 전혀 이어질 수 없는 경우 등 체크 가능
        for v in nbr[u]:
            if v not in seen:
                seen.add(v)
                res=dfs(path+[v], seen)
                if res: return res
                seen.remove(v)
        return None
    starts = [start] if start is not None else nodes
    for s in starts:
        res = dfs([s], {s})
        if res: return res
    return None
```

#### 비트마스크 DP — 존재 판정 및 경로 복원 $$O(n^2 2^n)$$

```python
def hamiltonian_path_dp(g):
    """
    g: dict[u] -> iterable of neighbors (무/유향)
    return: (exists, path or None)
    """
    nodes=list(g.keys()); n=len(nodes); id_of={v:i for i,v in enumerate(nodes)}
    adj=[0]*n
    for u,vs in g.items():
        m=0
        for v in vs:
            m |= 1<<id_of[v]
        adj[id_of[u]]=m
    # dp[mask][v] = 이전 정점 인덱스 (경로 존재시)
    # 파이썬 메모리 고려: dict로 희소 저장
    from collections import defaultdict
    dp=[defaultdict(lambda: -1) for _ in range(1<<n)]
    for i in range(n):
        dp[1<<i][i] = -2  # 시작 표식
    for mask in range(1<<n):
        for v in list(dp[mask].keys()):
            if dp[mask][v]==-1: continue
            # v 다음으로 갈 수 있는 후보
            can = adj[v] & (~mask)
            while can:
                u = (can & -can).bit_length()-1
                can &= can-1
                dp[mask | (1<<u)][u] = v
    FULL = (1<<n)-1
    for end in range(n):
        if dp[FULL][end] != -1:
            # 복원
            path=[]; mask=FULL; v=end
            while dp[mask][v] != -2:
                path.append(nodes[v])
                pv = dp[mask][v]; mask ^= (1<<v); v=pv
            path.append(nodes[v])
            path.reverse()
            return True, path
    return False, None
```

**검증 예시**

```python
# 선형 4정점: 0-1-2-3 (무방향으로 가정)

g = {0:[1], 1:[0,2], 2:[1,3], 3:[2]}
print(hamiltonian_path_backtrack(g))   # 예: [0,1,2,3]
print(hamiltonian_path_dp(g))          # (True, [0,1,2,3]) 또는 대칭 경로
```

---

## 추가 이론/현업 연결

### 오일러리안 그래프와 관련 문제

- **중국 우편 배달 문제(Chinese Postman / Route Inspection)**
  모든 간선을 최소 비용으로 “적어도 한 번” 커버하는 **최단 회로** 찾기.
  - 무방향: 홀수 차수 정점들을 **최소 가중치 완전매칭**으로 짝지어 간선 복제 → 오일러 회로.
  - 도시 도로청소/제설, 드론/로봇 경로에 실무적으로 매우 유용.
- **검증**: 경로 결과의 길이는 **간선 수 + 추가 복제 간선 수**.

### 해밀토니안과 TSP

- **TSP**는 모든 정점을 1번씩 방문하고 **총 비용 최소**인 회로.
- 해밀턴 경로 존재 여부는 **제약 만족형**(비용 무시)이고, TSP는 **최적화형**.
- 비트마스크 DP(Held–Karp)는 TSP에선 $$O(n^2 2^n)$$로 **최단 비용** 계산, 여기서는 **존재** 판정/복원에 같은 복잡도 구조 사용.

### 대표적 그래프에서의 성질

- **트리**: 오일러 경로는 “리프(차수 1) 2개일 때만 경로, 0개면(=없음) 회로 불가”, 해밀턴 경로는 일반적으로 **존재하지 않을 수 있음**(별그래프 등).
- **하이퍼큐브 \(Q_d\)**: 해밀턴 사이클 존재(Gray code).
- **격자 그래프**: 경계/홀에 따라 오일러/해밀턴 존재성 달라짐.

---

## 자주 하는 실수 & 체크리스트

- **오일러 연결성**: “정점 전체 연결”이 아니라 **간선이 있는 정점들만** 모아서 연결인지 판단.
- **무방향 멀티간선**: 제거 시 **양방향** 카운터를 같이 줄일 것. 루프는 차수 +2.
- **방향 오일러**: **in=out**(회로) / 시작·끝 **±1 조건**(경로) + **약연결(0차 제외)**.
- **해밀턴**: 필요충분 조건 **없음**(일반 그래프). 충분조건(Dirac/Ore)은 말 그대로 “충분”일 뿐.
- **백트래킹 폭발**: n이 조금만 커져도 시간 폭증 → 비트마스크 DP 또는 문제 구조(평면성, 차수하한, 클로저) 활용.
- **검증 함수**: 찾은 경로가 정말 조건을 만족하는지 **독립 검증** 권장.

---

## 결과 검증 유틸 (간단)

```python
from collections import Counter

def verify_euler_path(edges, path, directed=False):
    if not path or len(path)<2: return len(edges)==0
    # 간선 멀티셋 생성
    if directed:
        bag = Counter(edges)
    else:
        bag = Counter(tuple(sorted(e)) for e in edges)
    for a,b in zip(path, path[1:]):
        e = (a,b) if directed else tuple(sorted((a,b)))
        if bag[e]==0: return False
        bag[e]-=1
    return sum(bag.values())==0

def verify_hamilton_path(g, path, cycle=False):
    if not path: return False
    nodes=set(g.keys())
    if cycle:
        if len(path)!=len(nodes)+1 or path[0]!=path[-1]:
            return False
        seq = path[:-1]
    else:
        if len(path)!=len(nodes): return False
        seq = path
    if len(set(seq))!=len(nodes): return False
    for u,v in zip(path, path[1:]):
        if v not in set(g[u]): return False
    return True
```

---

## 작은 워크숍: “케이스 → 판단 → 구성 → 검증”

```python
# 오일러(무방향)

edges = [(0,1),(1,2),(2,0),(2,3),(3,0)]  # 오일러 회로 조건? 모든 차수 짝수인가?
print(eulerian_status_undirected(edges))      # 상태 확인
p = hierholzer_undirected(edges)
print("Euler path:", p, "valid?", verify_euler_path(edges, p, directed=False))

# 오일러(방향)

dedges = [(0,1),(1,2),(2,0),(0,3),(3,0)]     # in/out 균형 확인
print(eulerian_status_directed(dedges)[0])
pd = hierholzer_directed(dedges)
print("Euler path directed:", pd, "valid?", verify_euler_path(dedges, pd, directed=True))

# 해밀턴(백트래킹 & DP)

g = {0:[1,2], 1:[0,2,3], 2:[0,1,3], 3:[1,2]}  # 4정점 거의 완전
hb = hamiltonian_path_backtrack(g)
print("Hamilton(backtrack):", hb, verify_hamilton_path(g, hb))
hdp = hamiltonian_path_dp(g)
print("Hamilton(DP):", hdp)
```

---

## 응용 미니 가이드

| 문제 | 모델 | 권장 접근 |
|---|---|---|
| **도로/청소/검침·배송** 모든 길(간선) 커버 | 오일러/중국우편배달 | 오일러 조건 확인→아니면 홀수정점 매칭으로 보정→Hierholzer |
| **모든 지점(정점) 1회 방문** 여행 최적 경로 | 해밀턴/TSP | 존재만: 백트래킹/DP; 최적화: Held–Karp/메타휴리스틱 |
| **퍼즐** (코닉스 플로어, 일필휘지, 나이트 투어) | 오일러/해밀턴 | 그래프 변환 후 위 알고리즘 적용 |
| **PCB/회로 검증** 커버리지 | 오일러 vs 해밀턴 | 간선 커버 vs 정점 커버 요구에 맞춰 선택 |

---

## 한 화면 요약

- **오일러(간선1회)**
  - 무방향: 연결 + {홀수차수=0→회로, 2→경로}.
  - 방향: 약연결 + {전정점 in=out → 회로; 시작 out=in+1, 끝 in=out+1}.
  - **구성**: **Hierholzer $$O(V+E)$$**, 멀티간선 OK.

- **해밀턴(정점1회)**
  - 일반 조건 **어렵다(NP-완전)**. Dirac/Ore는 **충분조건**.
  - **구성/판정**: 백트래킹(작은 n), **비트마스크 DP $$O(n^2 2^n)$$**(중간 n).

- **현업**:
  - 간선 커버 비용 최소화 → **중국우편배달**(홀수 정점 매칭).
  - 정점 방문 최적화 → **TSP**(Held–Karp/휴리스틱).
