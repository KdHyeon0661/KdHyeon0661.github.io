---
layout: post
title: 이산수학 - 오일러 경로와 해밀턴 경로
date: 2025-06-29 20:20:23 +0900
category: 이산수학
---
# 🧭 오일러 경로와 해밀턴 경로

그래프 이론에서 오일러 경로와 해밀턴 경로는 **정점을 방문할지**, **간선을 방문할지**에 따라 그 의미가 다릅니다.  
두 개념 모두 **그래프의 순회 성질**과 밀접한 관련이 있으며, 다양한 응용(회로 설계, 배달 경로 최적화, 퍼즐 등)에 사용됩니다.

---

## 📌 오일러 경로 (Eulerian Path)

### ✅ 정의

**오일러 경로**는 **모든 간선을 정확히 한 번씩 방문**하는 경로입니다.  
**오일러 회로(Eulerian Circuit)**는 오일러 경로이면서 시작점과 끝점이 같은 경우입니다.

---

### 📐 오일러 경로 존재 조건 (무방향 그래프 기준)

- 연결 그래프일 것
- **홀수 차수의 정점이 0개 또는 2개**

| 조건 | 경로 형태 |
|------|------------|
| 모든 정점 차수가 짝수 | 오일러 회로 존재 |
| 홀수 차수 정점이 2개 | 오일러 경로는 존재 (단, 회로는 아님) |
| 그 외 | 없음 |

#### 예시:

- 그래프: A—B—C—D—A  
- 간선 수 = 4  
- 모든 정점 차수 = 2 → 오일러 회로 가능

---

### 🔄 방향 그래프의 조건

- **모든 정점에서**: in-degree = out-degree → 오일러 회로 존재  
- **오일러 경로 조건**:
  - 시작점: out-degree = in-degree + 1
  - 끝점: in-degree = out-degree + 1
  - 나머지 정점: in-degree = out-degree

---

### 🧭 오일러 경로 알고리즘 (Hierholzer's Algorithm)

- DFS 기반으로 경로를 구성
- 시간복잡도: \( O(V + E) \)

---

## 🧭 해밀턴 경로 (Hamiltonian Path)

### ✅ 정의

**해밀턴 경로**는 **모든 정점을 정확히 한 번씩 방문**하는 경로입니다.  
**해밀턴 회로(Hamiltonian Cycle)**는 시작점과 끝점이 같은 경우입니다.

---

### 📐 해밀턴 경로의 특징

- 오일러 경로와 달리 **간선 수와 무관**
- 일반적으로 **존재 조건이 명확하게 결정되지 않음**
- **NP-완전 문제**로 분류 → 해밀턴 경로의 존재 여부 판단은 어렵다

---

### 🔎 충분 조건 (Dirac's Theorem)

그래프 \( G \)가 \( n \geq 3 \)개의 정점을 가지고,  
모든 정점 \( v \)에 대해 차수 \( \deg(v) \geq n/2 \) 이면  
→ 해밀턴 회로가 존재한다.

하지만 이 조건은 **충분조건**이지 **필요조건**은 아님

---

### 🧮 예시

- 그래프: 정점 A–B–C–D  
- 간선: (A–B), (B–C), (C–D)  
- 정점 수 = 4  
- 경로: A–B–C–D → 해밀턴 경로 존재  
- D–A 간선이 없으므로 회로는 아님

---

## 🆚 오일러 vs 해밀턴 비교

| 비교 항목 | 오일러 경로 | 해밀턴 경로 |
|------------|--------------|----------------|
| 정의 | 모든 **간선** 한 번씩 방문 | 모든 **정점** 한 번씩 방문 |
| 필요조건 | 정점 차수 조건 | 명확한 필요조건 없음 (NP-완전) |
| 알고리즘 | 효율적 (Hierholzer) | 탐색 중심 (백트래킹 등) |
| 난이도 | 상대적으로 쉬움 | 어렵고 계산 복잡 |
| 응용 예 | 드론 배달 경로, 도로 청소 | 여행 계획, 순회 세일즈맨 문제 |

---

## 🧪 알고리즘적 접근

### 오일러 경로 - Hierholzer 알고리즘

```python
def find_eulerian_path(graph):
    stack = []
    path = []
    current = start_node  # 시작 노드 (홀수 차수인 정점)
    while stack or graph[current]:
        if not graph[current]:
            path.append(current)
            current = stack.pop()
        else:
            stack.append(current)
            next_node = graph[current].pop()
            graph[next_node].remove(current)
            current = next_node
    path.append(current)
    return path[::-1]
```

### 해밀턴 경로 - 백트래킹 (단순 구현)

```python
def hamiltonian_path(graph, path, visited):
    if len(path) == len(graph):
        return path
    current = path[-1]
    for neighbor in graph[current]:
        if neighbor not in visited:
            visited.add(neighbor)
            result = hamiltonian_path(graph, path + [neighbor], visited)
            if result:
                return result
            visited.remove(neighbor)
    return None
```

---

## 📚 실제 응용

| 응용 분야 | 오일러 | 해밀턴 |
|-----------|--------|---------|
| 회로 설계 | ✔️ (PCB 순서 등) | ✔️ (회로 커버리지) |
| 물류 최적화 | ✔️ (간선 중심) | ✔️ (세일즈맨 문제) |
| 퍼즐 게임 | ✔️ (코닉스 플로어) | ✔️ (나이트 투어) |
| 그래프 탐색 문제 | ✔️ (연결성 검증) | ✔️ (최단 방문 경로) |