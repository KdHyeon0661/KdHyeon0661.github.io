---
layout: post
title: DB 심화 - 트랜잭션의 동시성 제어
date: 2025-10-19 17:25:23 +0900
category: DB 심화
---
# 트랜잭션의 **동시성 제어(Concurrency Control)** — 트랜잭션/ACID 기초부터 격리수준·락·MVCC·이상 현상·알고리즘(2PL/OCC/타임스탬프)까지 (Oracle 중심, 범용 DB 비교)

> 목표
> - **트랜잭션**과 **ACID**를 핵심부터 정확히 정의
> - **동시성 제어**가 무엇이며 왜 필요한지, 실패 시 어떤 **이상(Anomaly)** 이 생기는지 체계적으로 설명
> - **격리 수준**(Read Uncommitted/Committed/Repeatable Read/Serializable), **MVCC/Undo**, **락(S/X/의도락/다중 그레인)**, **2PL/Strict/Rigorous**, **타임스탬프 순서**, **낙관적 동시성 제어(OCC)** 를 예제와 함께 이해
> - **Oracle** 기준의 동작 특성(문장 수준 읽기 일관성, RC/Serializable, SELECT FOR UPDATE, ITL/Undo 등)과 **InnoDB/PG**의 대비점(Next-Key, Snapshot Isolation)을 짚어 실무 감각을 갖춤

---

## 트랜잭션(Transaction)과 ACID

### 트랜잭션이란?

- 애플리케이션 관점의 **논리적 작업 단위**. **BEGIN → 여러 SQL → COMMIT/ROLLBACK** 로 묶여 **전부 성공하거나(Commit) 전부 취소**(Rollback)됨.
- 데이터베이스는 **트랜잭션 경계**를 기준으로 **로그(redo/undo)** 를 관리하여 **장애 시 복구**와 **일관성**을 보장.

### ACID

- **Atomicity(원자성)**: 전부 아니면 전무. 일부만 반영 금지.
- **Consistency(일관성)**: 트랜잭션 전후로 **제약식/불변식**을 유지(키 제약, 체크 제약, 회계 등식 등).
- **Isolation(격리성)**: 동시에 실행 중인 다른 트랜잭션으로부터 **논리적으로 독립**. *(완전한 직렬화가 이상적이지만 비용이 커 현실적 수준을 택함)*
- **Durability(내구성)**: 커밋된 변경은 **영구히 보존**(크래시 이후에도 redo로 복구).

> 수식 감각(개념):
> $$ \text{DB State}_{k+1} = T_k(\text{DB State}_k) \quad \text{s.t.}\ \forall k,\ \text{Constraints}(\text{DB State}_k)=\text{true} $$

---

## 동시성 제어(Concurrency Control)가 왜 필요한가?

**목표:** **처리량↑**(여러 트랜잭션 동시 실행)과 **정확성**(ACID, 특히 **Isolation**)의 균형.

**없을 때 발생하는 이상(대표)**
- **Dirty Read**: 커밋되지 않은 데이터를 다른 트랜잭션이 읽음.
- **Non-Repeatable Read**: 같은 행을 두 번 읽을 때 값이 바뀜.
- **Phantom Read**: 같은 조건으로 두 번 조회 시 **행 수**가 바뀜(새/삭제된 행).
- **Lost Update**: 서로의 변경을 덮어써 **먼저 쓴 값이 사라짐**.
- **Write Skew**: 서로 다른 행을 갱신했는데 **전역 제약**을 깸(스냅샷 계열에서 빈발).

---

## 격리 수준(Isolation Levels) — ANSI와 제품별 매핑

| ANSI/개념 | Dirty Read | Non-Repeatable | Phantom | 특징 |
|---|---:|---:|---:|---|
| Read Uncommitted | 가능 | 가능 | 가능 | 대부분의 상용 RDBMS에서 디폴트로 쓰지 않음 |
| **Read Committed (RC)** | 불가 | **가능** | **가능** | Oracle **디폴트**. **문장 수준** 스냅샷 유지 |
| Repeatable Read (RR) | 불가 | 불가 | **가능(제품차)** | InnoDB는 **Next-Key 잠금**으로 팬텀까지 방지(사실상 Serializable에 가까움) |
| **Serializable** | 불가 | 불가 | 불가 | 완전 직렬화 **시도**. Oracle은 Snapshot 기반 + 충돌 시 **ORA-08177** |

**Oracle 특이점**
- **Read Committed**: 모든 SELECT는 **문장 시작 시점 스냅샷**(SCN)으로 CR(Consistent Read) → 중간에 들어온 커밋은 보이지 않음.
- **Serializable**: 트랜잭션 전체 스냅샷. 경쟁 갱신 감지 시 **ORA-08177(can’t serialize)** 로 실패.
- **SELECT FOR UPDATE**: **현재 버전(Current)** + **행 잠금** 취득(갱신 예정 대상 보호).

---

## 락(잠금)과 MVCC의 큰 그림

### 락(Lock)

- **S(공유)/X(배타)**, **의도락(IS/IX/SIX)**, **테이블/페이지/행** 등 **다중 그레인**으로 사용.
- **2PL(2-Phase Locking)**: **획득↑**만 하다가 커밋/롤백 순간에 **일괄 해제↓**.
  - **Strict 2PL**: 변경(X)락은 **커밋까지 유지** → **복구 용이**(Undo 필요성↓).
  - **Rigorous 2PL**: S/X **모두** 커밋까지 유지 → 가장 보수적.

### MVCC (Multi-Version Concurrency Control)

- **Undo/버전 체인**을 이용해 **읽기와 쓰기 분리를 완화**.
- **읽기**는 **과거 버전(CR)** 을 읽어 락 충돌 감소, **쓰기**는 **현재 버전**을 변경.
- Oracle: **Undo 기반 CR**, 문장/트랜잭션 스냅샷.
- PostgreSQL: 튜플 버전 플래그(XMIN/XMAX) 기반.
- InnoDB: Undo Log + Read View.

---

## 스케줄과 직렬가능성(Serializability)

### 충돌 직렬가능성(Conflict Serializability)

- **충돌하는 연산**(같은 아이템에 대한 RW/WR/WW)이 **같은 순서**를 유지하면 직렬과 동등.
- **선행 그래프(Precedence Graph)** 가 **사이클 없음(acyclic)** → **충돌 직렬가능**.

> 간단 예시(의사 수식):
> $$ \text{If}\ \forall (T_i,T_j),\ R_i(X)\ \&\ W_j(X) \Rightarrow \text{order}(T_i,T_j)\ \text{consistent} \Rightarrow \text{serializable} $$

### 뷰 직렬가능성(View)

- 초기/최종 읽기-쓰기 관계가 동일하면 직렬과 동등. (현업에선 **충돌 기준**을 주로 씀)

---

## 핵심 알고리즘 — 2PL / 타임스탬프 순서 / OCC

### 2PL(2-Phase Locking)

- **성질**: 충돌 직렬가능 스케줄 보장(Strict/Rigorous는 회복성 강화).
- **단점**: 교착(Deadlock) 가능 → **탐지**(Wait-For Graph) 또는 **회피**(타임아웃/순서화).

**데드락 미니 데모**
```sql
-- 세션 A
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- (커밋 지연)
-- 다음 줄에서 세션 B가 id=2를 먼저 잡으면 교착 가능
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- 세션 B
UPDATE accounts SET balance = balance - 50 WHERE id = 2;
UPDATE accounts SET balance = balance + 50 WHERE id = 1;
-- -> 한쪽이 ORA-00060 (deadlock detected)
```

**해결팁**: **항상 같은 순서**로 잠금, **짧은 트랜잭션**, **락 범위 최소화**.

### 타임스탬프 순서(Time-Stamp Ordering, TSO)

- 각 트랜잭션에 **TS** 부여. 읽기/쓰기 시 **객체의 RTS/WTS** 와 비교해 **질서 위반**이면 **롤백/재시도**.
- **교착 없음**(대신 **Abortion** 증가 가능), **낙관적 워크로드**에 유리.

간단 의사코드:
```text
On Read(X) by Ti with TS(Ti):
  if WTS(X) > TS(Ti) then abort Ti  -- too old
  else RTS(X) := max(RTS(X), TS(Ti)); return version ≤ TS(Ti)

On Write(X) by Ti:
  if RTS(X) > TS(Ti) or WTS(X) > TS(Ti) then abort Ti
  else WTS(X) := TS(Ti); write new version
```

### 낙관적 동시성 제어(OCC)

- **읽기 단계(Read)** → **검증(Validate)** → **쓰기 단계(Write)**.
- 검증 시 **충돌**(다른 트랜잭션이 겹치는 데이터 변경) 발견되면 **롤백**.
- **읽기 많은 워크로드·짧은 트랜잭션**에 적합. 분산/마이크로서비스에서 자주 선택.

의사코드(검증 규칙의 한 형태):
```text
Validate(Ti):
  for each Tj in Active with TS(Tj) < TS(Ti):
    if (WriteSet(Tj) ∩ ReadSet(Ti)) ≠ ∅ then abort Ti   -- read-write conflict
    if (WriteSet(Tj) ∩ WriteSet(Ti)) ≠ ∅ then abort one -- write-write conflict
  else commit Ti
```

---

## 제품별 구현 비교(Oracle 중심)

| 항목 | Oracle | PostgreSQL | InnoDB(MySQL) |
|---|---|---|---|
| 디폴트 격리 | **Read Committed**(문장 스냅샷) | Read Committed | Repeatable Read |
| Serializable | Snapshot + 충돌 시 **ORA-08177** | True Serializable | RR≈Serializable(Next-Key) |
| 읽기 일관성 | Undo 기반 **CR 블록** | 튜플 버전(XMIN/XMAX) | Undo + Read View |
| 팬텀 방지 | RC: 허용 / Serial: 충돌 시 실패 | RR: 팬텀 | Next-Key로 **팬텀 차단** |
| 현재 읽기 | `FOR UPDATE` / DML | `FOR UPDATE` | `FOR UPDATE` |
| 행 잠금 | TX enqueue (row-level) | tuple-level lock | record/gap/next-key |
| 데드락 | 감지(자동 kill) | 감지 | 감지 |

---

## 이상(Anomalies) — 예제와 방지책

### Dirty Read (Oracle RC에선 발생하지 않음)

- **설명**: T1의 미커밋 값을 T2가 읽음 → T1 롤백시 T2는 유령값.
- **방지**: RC 이상. Oracle은 기본적으로 **Undo 기반 읽기**로 **불허**.

### Non-Repeatable Read (RC에서 가능)

```sql
-- 세션 A (RC)
SELECT balance FROM accounts WHERE id=1;  -- 100

-- 세션 B
UPDATE accounts SET balance=200 WHERE id=1; COMMIT;

-- 세션 A (다시)
SELECT balance FROM accounts WHERE id=1;  -- Oracle RC는 "문장" 단위 스냅샷.
-- 같은 문장 내에서는 변하지 않지만, "다음 문장"에서는 200이 보임 → Non-Repeatable Read 가능
```
- **방지**: RR/Serializable 또는 **SELECT FOR UPDATE** 등 **현재 읽기 + 잠금**.

### Phantom Read (Oracle RC에서 가능)

```sql
-- 세션 A
SELECT COUNT(*) FROM orders WHERE amt > 100;  -- 42

-- 세션 B
INSERT INTO orders(id, amt) VALUES(10001, 9999); COMMIT;

-- 세션 A (다음 문장)
SELECT COUNT(*) FROM orders WHERE amt > 100;  -- 43 (팬텀)
```
- **방지**: Serializable(Oracle에선 충돌 시 실패) 또는 **범위 락**(InnoDB Next-Key).

### Lost Update (RC에서 가능, 방지 필요)

```sql
-- 초기: val=0
-- 세션 A
SELECT val FROM t WHERE id=1;  -- 0
-- 세션 B
UPDATE t SET val = val + 10 WHERE id=1; COMMIT;
-- 세션 A (옛 값 기준)
UPDATE t SET val = 0 + 1 WHERE id=1; COMMIT;  -- 10 유실 → 1
```
- **방지**: `SELECT ... FOR UPDATE`, **버전 컬럼**(낙관적 잠금), CAS(Compare-And-Set) 패턴.

### Write Skew (Snapshot/Serializable 계열에서 전형)

- 두 트랜잭션이 **서로 다른 행**을 바꾸지만 **전역 제약** 위반을 초래.
- **방지**: **DB 제약**으로 전역 조건 강제, **락 테이블**, 애플리케이션 재시도.

---

## Oracle 실무 예제 — RC/Serializable/SELECT FOR UPDATE

### 준비

```sql
DROP TABLE accounts PURGE;
CREATE TABLE accounts(id NUMBER PRIMARY KEY, balance NUMBER NOT NULL);
INSERT INTO accounts VALUES(1, 100);
INSERT INTO accounts VALUES(2, 200);
COMMIT;
```

### RC에서의 Lost Update 가능성

```sql
-- A (RC)
SELECT balance FROM accounts WHERE id=1;  -- 100

-- B
UPDATE accounts SET balance=150 WHERE id=1; COMMIT;

-- A
UPDATE accounts SET balance=balance+1 WHERE id=1;  -- 사실상 100+1=101 의도
COMMIT;
-- 최종: 151이 아닌 101이 될 수 있음(비즈니스 요구에 따라 '유실'로 간주)
```

**해결(둘 중 하나)**
- **현재 잠금**:
```sql
-- A
SELECT balance FROM accounts WHERE id=1 FOR UPDATE;  -- current + row lock
UPDATE accounts SET balance=balance+1 WHERE id=1;
COMMIT;
```
- **낙관적 잠금(버전 컬럼)**:
```sql
ALTER TABLE accounts ADD ver NUMBER DEFAULT 0;

-- A
SELECT balance, ver FROM accounts WHERE id=1;  -- 100, 5
UPDATE accounts SET balance=balance+1, ver=ver+1
 WHERE id=1 AND ver=5;   -- 영향행 0이면 재시도
COMMIT;
```

### Serializable의 충돌(ORA-08177)

```sql
-- 세션 A
ALTER SESSION SET ISOLATION_LEVEL = SERIALIZABLE;
SELECT balance FROM accounts WHERE id=1;  -- 스냅샷: 100

-- 세션 B (RC)
UPDATE accounts SET balance=999 WHERE id=1; COMMIT;

-- 세션 A
UPDATE accounts SET balance=balance+1 WHERE id=1;
-- ORA-08177: can't serialize access for this transaction
ROLLBACK;
```
**설명**: A는 **트랜잭션 전체** 일관성을 요구. 중간의 외부 커밋과 **충돌** → **실패/재시도**.

---

## 락과 인덱스/범위 — Next-Key, Gap, Predicate

- **행 락만**으로는 **팬텀**을 막기 어려움(새 행 추가는 차단 못함).
- InnoDB는 **Next-Key(Record + Gap) Lock**으로 **범위 잠금** → 팬텀 차단.
- Oracle은 **Serializable 충돌 감지**로 해결(“보이면 실패”). 범위 잠금이 필요하면 **FOR UPDATE OF … NOWAIT/SKIP LOCKED** + **인덱스 조건 설계** 등의 패턴 활용.

---

## 래치/뮤텍스 vs 트랜잭션 락 — 레이어 구분

- **래치/뮤텍스**: **SGA 내부 구조체** 보호(초단기 직렬화). 대기 이벤트: `latch: …`, `cursor: mutex …`.
- **엔큐/행락(TX/TM)**: **사용자 데이터**를 보호하는 **트랜잭션 락**으로 **격리**를 구현.
- **버퍼 핀/캐시 버퍼 체인**: 메모리 버퍼 프레임 보호(락과 별층).
> **혼동 금물**: 성능/대기 분석 시 **어떤 레이어의 충돌인지** 먼저 식별해야 올바른 처방이 가능.

---

## 로그·복구와 ACID의 연결(간단)

- **WAL(Write-Ahead Logging)**: **데이터파일** 쓰기 전에 **Redo Log**에 **선기록**.
- **Commit**: LGWR가 커밋 레코드 **동기 플러시** → **Durability**.
- **Crash Recovery**: Redo 재적용(+Undo)으로 **일관성 회복**.
- **Strict 2PL**은 커밋 시점까지 X락 유지 → **Undo-리두 상호작용 단순화**.

---

## 실무 체크리스트 — 어떤 전략을 택할까?

1. **업무 특성 파악**
   - 읽기 많은가? 쓰기 많은가? **충돌 빈도**는? **재시도 비용** 허용?
2. **격리 수준 선택**
   - 기본은 **RC**. **금융/재고**처럼 **유실/팬텀**이 치명적이면 **Serializable/Next-Key** 또는 **FOR UPDATE**.
3. **갱신 패턴 설계**
   - **항상 같은 순서로** 여러 행/자원을 잠금 → 교착 감소
   - **짧은 트랜잭션** & **작은 범위** 잠금
4. **낙관/비관 선택**
   - **낙관(OCC/버전 컬럼)**: 충돌 빈도 낮고 재시도 용이
   - **비관(락 기반)**: 충돌 비용이 매우 큼, 강한 정합성 필요
5. **인덱스/범위 전략**
   - 팬텀 방지가 필요하면 **인덱스 설계**로 범위를 명확히 & 제품별 **범위 잠금 메커니즘** 활용
6. **오라클 전용 팁**
   - **SELECT FOR UPDATE**로 Lost Update 방지
   - **RC의 문장 스냅샷** 이해(같은 문장 내 일관성)
   - **Serializable 충돌(ORA-08177)** 은 **정상 시그널** → **재시도 로직**
   - **Undo/ITL**(동시 갱신 핫블록) 관리: **INITRANS/PCTFREE**, 키 분산, 파티셔닝

---

## 요약

- **트랜잭션**은 ACID를 통해 신뢰 가능한 상태 전이를 보장하고, **동시성 제어**는 이를 **여러 트랜잭션 동시 실행**에서도 유지하는 기술.
- **락 기반**(2PL/Strict)과 **MVCC**(Undo/버전) 두 축으로 격리 달성.
- **격리 수준**에 따라 허용/차단되는 **이상**이 다르며, 제품별 구현 차이가 큼.
- **Oracle**은 **RC(문장 스냅샷)** 를 기본으로, **Serializable**에선 **충돌 시 실패** 전략, **갱신 보호**는 `SELECT FOR UPDATE`/락 설계로 달성.
- 설계의 핵심은 **비즈니스가 요구하는 정합성**을 만족하는 최소 비용의 조합을 고르는 것: **격리 수준 + 잠금/낙관 전략 + 인덱스/범위 + 재시도 정책**.

> 한 줄 결론:
> **동시성 제어**는 “**얼마나 함께 달릴 수 있는가** vs **얼마나 정확히 달려야 하는가**”의 기술이다.
> 정답은 업무 제약 안에서 **격리·락·MVCC·재시도**를 섞어 **가장 싸게 ACID를 지키는 설계**다.
