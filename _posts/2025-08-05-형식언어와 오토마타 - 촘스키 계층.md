---
layout: post
title: 형식언어와 오토마타 - 촘스키 계층
date: 2025-08-05 20:20:23 +0900
category: 형식언어와 오토마타
---
# 촘스키 계층(Chomsky Hierarchy)

**요약 한 줄**
- **정규(REG)** ⊊ **문맥자유(CFL)** ⊊ **문맥인식(CSL)** ⊊ **재귀적 열거 가능(RE)**
- 각 단계는 대응 **오토마타**(FA / PDA / LBA / TM)와 **정확히 동치**이며, 위로 갈수록 **표현력↑**·**자동판정 가능성↓**.

\[
\boxed{ \text{Type-3 REG} \subsetneq \text{Type-2 CFL} \subsetneq \text{Type-1 CSL} \subsetneq \text{Type-0 RE} }
\]

---

## 0. 큰 그림(지도)

- **언어**의 “위치”는 **문법 제약** ↔ **오토마타 능력** ↔ **결정/폐포 성질**로 동시에 파악한다.
- 실전에서는 먼저 **정규성**(FA 가능?)을 확인 → 아니면 **CFL**(PDA/CFG 가능?) → 그래도 아니면 **CSL**(선형 공간) → 최후의 보루 **RE**(TM).

---

## 1. 네 단계의 **형식적 정의와 모델 동치**

### (Type-3) 정규 언어 **REG**

- **문법 제약**: 우선형(또는 좌선형) 정규 문법.
  - 우선형 예: \(A \to aB \mid a \mid \varepsilon\) (단, \(\varepsilon\)는 보통 시작기호에만 허용)
- **등가 모델**: **DFA/NFA/정규식** (표현력 동등).
- **대표 폐포**: 합·교·보수·연접·Kleene★·역순·호모/역호모 모두 **닫힘**.
- **결정 성질**: 멤버십/동치/포함/보편성/공백성 **모두 결정 가능**.

**예시 1 — 부분문자열 `ab`를 포함하는 모든 이진 문자열**
- **정규식**: `(0|1)*ab(0|1)*`
- **NFA 스케치**: `q0 -(a)-> q1 -(b)-> q2(accept)` + 기타 문자 루프

```text
DFA 설계 팁
- '마지막 글자가 a인가?' 상태 표시로 2상태 + sink 구성
```

**예시 2 — 끝이 a로 끝나는 a,b-문자열**
```bnf
# 우선형 정규 문법
S -> a S | b S | a
```

---

### (Type-2) 문맥 자유 언어 **CFL**

- **문법 제약**: 좌변이 단일 비단말 \(A\)인 규칙만 허용: \(A \to \alpha\).
- **등가 모델**: **PDA**(푸시다운 오토마타).
- **정규형**: **CNF**(Chomsky), **GNF**(Greibach).
- **대표 폐포**: 합/연접/★/역순/정규와의 교집합/역호모 **닫힘**. (교·보수는 일반적으로 **닫힘 아님**)
- **결정 성질**: 멤버십 **다항시간**(CYK \(O(n^3)\), Earley 평균 양호), 공백성/유한성 **결정 가능**, 동치/포함/보편성/모호성 **결정 불가능**.

**예시 3 — \(L=\{a^n b^n \mid n\ge 0\}\)**
```bnf
S -> a S b | ε
```
- **PDA 직관**: a를 읽을 때 스택 push, b를 읽을 때 pop, 끝에 스택 비면 accept.

**예시 4 — 균형 괄호**
```bnf
S -> S S | ( S ) | [ S ] | ε
```
- **모호성 제거 팁**: 우선순위/결합성은 GNF·우결합 형태로 조정.

**CNF 변환 절차(요약)**
1. \(\varepsilon\)-규칙/단위규칙 제거
2. 우변의 길이를 2로 제한(\(A\to BC\) 또는 \(A\to a\))
3. 단말만 갖는 규칙 분리(\(A\to a\) 전용 비단말 도입)

---

### (Type-1) 문맥 인식 언어 **CSL**

- **문법 제약**: **비축약**(noncontracting) 리라이트 또는 문맥형:
  \[
  \alpha A \beta \Rightarrow \alpha \gamma \beta \quad(|\gamma|\ge 1)
  \]
- **정규형**: **Kuroda Normal Form**
  \[
  AB \to CD,\quad A \to BC,\quad A \to B,\quad A \to a
  \]
- **등가 모델**: **LBA(선형 한정 오토마타)** = \(\mathrm{NSPACE}(O(n))\).
- **대표 폐포**: 합·교·보수·연접·★·역순·역호모·(λ-자유)호모 **닫힘**.
- **결정 성질**: 멤버십(기계 입력) **NSPACE(n)-완**, 문법 입력 멤버십 **PSPACE-완**. 공백성/보편성/동치/포함 **일반적으로 결정보류(불가능)**.

**예시 5 — \(a^n b^n c^n\) (CFL 아님, CSL 예)**
- **LBA 설계 패턴**: *마킹 + 교대 스윕*
  1) 가장 왼쪽 미사용 a를 Ā로 표시
  2) 오른쪽으로 진행하며 가장 왼쪽 미사용 b를 \(\overline{b}\), 이어 가장 왼쪽 미사용 c를 \(\overline{c}\)
  3) 좌측으로 돌아가 다음 a를 찾음
  4) 더 이상 표시할 a가 없고 미표시 b/c가 남지 않으면 수용
- **CSG 스케치(직관)**: Kuroda 규칙군으로 Ā·\(\overline{b}\)·\(\overline{c}\) 전파·검증을 지역적으로 구현.

---

### (Type-0) 재귀적 열거 가능 언어 **RE**

- **문법 제약**: 없음(무제한/phrase-structure).
- **등가 모델**: **튜링 기계(TM)**.
- **하위 구분**: **재귀적(Recursive)** ⊊ **RE**(반결정 가능).
- **대표**:
  - \(A_{TM}=\{\langle M\rangle\#w\mid M(w)\text{ 수용}\}\) — **RE**, **결정 불가능**
  - PCP-YES — **RE**, **결정 불가능**

> **Rice 정리**: TM이 계산하는 **의미**의 비자명 속성은 **모두 결정 불가능**.
> (정규/문맥자유/유한성/보편성/동치성 등)

---

## 2. 포함 관계가 **엄격(strict)** 임을 보이는 표준 증개요

\[
\text{REG} \subsetneq \text{CFL} \subsetneq \text{CSL} \subsetneq \text{RE}
\]

- **REG ⊊ CFL**: \(a^n b^n\)은 **정규 펌핑 정리**로 반증(정규 아님), CFG/PDA로 가능.
- **CFL ⊊ CSL**: \(a^n b^n c^n\)은 **CFL 펌핑 정리/Ogden 보조정리**로 반증(비CFL), LBA/CSG로 가능.
- **CSL ⊊ RE**: RE 중엔 **LBA 공간**으로는 인식 불가한 언어 다수(예: \(A_{TM}\), 정지 문제류).
- **RE ⊊ 모든 언어**: non-RE 존재(예: \(\overline{A_{TM}}\), \(ALL_{TM}\) 등 \(\Pi^0_2\)-완).

---

## 3. 폐포(Closure) **한 눈 표**

| 연산 | REG | CFL | CSL | RE |
|---|---|---|---|---|
| 합 \(\cup\) | ✅ | ✅ | ✅ | ✅ |
| 교 \(\cap\) | ✅ | ❌ *(단, REG와의 교는 ✅)* | ✅ | ✅ |
| 보수 \(\overline{L}\) | ✅ | ❌ *(DCFL은 ✅)* | ✅ *(Immerman–Szelepcsényi)* | ❌ *(일반)* |
| 연접 \(\cdot\) | ✅ | ✅ | ✅ | ✅ |
| Kleene ★ | ✅ | ✅ | ✅ | ✅ |
| 역순 \(L^R\) | ✅ | ✅ | ✅ | ✅ |
| 정규와의 교 | — | ✅ | ✅ | ✅ |
| 호모 \(h(L)\) | ✅ | ✅ | (λ-자유는 ✅) | ✅ |
| 역호모 \(h^{-1}(L)\) | ✅ | ✅ | ✅ | ✅ |

**핵심 포인트**
- **CFL**은 **보수/교**에 닫혀 있지 않음(표준 반례: \(\{a^i b^j c^k \mid i=j \text{ or } j=k\}\) 등).
- **CSL**은 **보수 닫힘**(\(\mathrm{NSPACE}(n)=\mathrm{coNSPACE}(n)\)).
- **RE**는 **보수 닫힘 아님**(RE∩coRE=Recursive).

---

## 4. 결정 성질(Decidability) **요약 표**

| 성질 / 계층 | REG | CFL | CSL(LBA/CSG) | RE(Type-0) |
|---|---|---|---|---|
| 멤버십 \(w\in L\) | 선형시간 | \(O(n^3)\) / Earley·LR | LBA: **NSPACE(n)-완**, CSG: **PSPACE-완** | 일반 **반결정**(RE) |
| 공백성 \(L=\varnothing\) | ✅ | ✅ | ❌(일반) | ❌ |
| 동치 \(L_1=L_2\) | ✅ | ❌ | ❌ | ❌ |
| 포함 \(L_1\subseteq L_2\) | ✅ | ❌ | ❌ | ❌ |
| 보편성 \(L=\Sigma^*\) | ✅ | ❌ | ❌ | ❌ |

> ✅=결정 가능, ❌=일반적으로 결정 불가능(감소·Rice 정리로).

---

## 5. **진단 플레이북** — 주어진 언어의 “층” 판정 절차

**Step 1. 정규성 후보**
- DFA/NFA로 상태를 **유한**하게 설계할 수 있나?
- **Myhill–Nerode**로 **상호 구별 가능한 무한 동치류**가 생기면 **정규 아님**.

**Step 2. CFL 후보**
- **스택 1개**로 충분한가? (균형/중첩/한 방향 카운팅)
- **CFL 펌핑 정리**·**Ogden 보조정리**로 반증 시도.
- **정규와의 교집합 테스트**: 의심 언어 \(L\)과 적절한 REG \(R\)의 교 \(L\cap R\)가 비CFL이면 \(L\)도 비CFL.

**Step 3. CSL 후보**
- **동시 다중 카운팅**, **복제 \(ww\)**, **장거리 동기화**가 필요한가?
- LBA(선형 공간) 설계가 자연스러운가? → CSL 유력.

**Step 4. RE/비RE 경계**
- **프로그램 의미**나 **정지** 속성이 섞이면 RE/비RE 안내판(Rice, HALT 감수).
- RE이되 결정 불가능인지(반결정) 확인.

---

## 6. **작업 예제** — 같은 언어를 여러 모형으로

### 6.1 REG 예: “짝수 개의 1을 포함하는 이진 문자열”

- **DFA(2상태)**: \(q_{even}\leftrightarrow q_{odd}\) (입력 1에서 토글, 0에서 정지)
- **정규식**: \((0|11)^*(1(0|11)^*1(0|11)^*)^*\)
- **정규 문법(우선형)**:
```bnf
S -> 0 S | 11 S | ε
```

### 6.2 CFL 예: 산술식(+, *, 괄호, id)

- **CFG (우선순위/결합성 반영)**:
```bnf
E -> E + T | T
T -> T * F | F
F -> ( E ) | id
```
- **LL(1)/LR 파서**를 위한 변환: 좌재귀 제거, 좌팩토링 등.

- **CYK 멤버십 의사코드**(CNF 가정):
```text
CYK(w, G):
  # w = a1 ... an, G in CNF
  for i=1..n:
    P[i,i] := { A | A -> ai in G }
  for ℓ=2..n:
    for i=1..n-ℓ+1:
      j := i+ℓ-1
      P[i,j] := ∅
      for k=i..j-1:
        for each A -> B C in G:
          if (B in P[i,k]) and (C in P[k+1,j]): add A to P[i,j]
  return (S in P[1,n])
```

### 6.3 CSL 예: \(L=\{a^n b^n c^n\}\)

- **LBA 설계(마킹 루틴 요약)**:
```text
loop:
  # 1) 왼쪽부터 미사용 a 하나 찾기 → Ā로 마킹
  if no more a: goto verify_rest
  # 2) 그 오른쪽으로 진행하며 미사용 b 하나 → ḃ, 이어 미사용 c 하나 → ċ
  # 3) 좌측 끝으로 돌아가 loop 반복
verify_rest:
  input에 미사용 b나 c 남으면 reject else accept
```
- **왜 PDA로는 불가?**
  스택 하나로는 **동시에 두 카운터(b, c)** 를 맞출 수 없음 → Ogden 보조정리로 반증 가능.

### 6.4 RE 예: \(A_{TM}\)

- **반결정 인식기**:
```text
ATM_Recognizer(<M>#w):
  simulate M(w) step-by-step
  if M(w) accepts: ACCEPT  # else run forever
```
- **결정 불가능**: 정지 문제로 귀류, Rice 정리.

---

## 7. **정규형/변환** 설계 레시피

### 7.1 CFG → CNF

1. 새 시작기호 \(S_0\to S\)
2. \(\varepsilon\)-규칙 제거(단, \(S_0\to \varepsilon\) 예외)
3. 단위규칙 \(A\to B\) 제거
4. 혼합 우변 분해: \(A\to aB \Rightarrow A\to U_a B, U_a\to a\)
5. 긴 우변 쪼개기: \(A\to BCD \Rightarrow A\to X D, X\to B C\)

### 7.2 정규식 → NFA → DFA (subset construction)

- \(\varepsilon\)-NFA Thompson 구성 → \(\varepsilon\)-closure 기반 DFA 변환 → (옵션) Hopcroft로 최소화.

### 7.3 CSG 정규화(Kuroda)

- 패턴 \(AB\to CD, A\to BC, A\to B, A\to a\)만 남도록 보조기호·마커 삽입
- **국소치환화**로 LBA 모델링이 쉬워짐.

---

## 8. **폐포/비폐포**를 가르는 전형적 반례·팩트

- **CFL 교집합 비닫힘**:
  \(L_1=\{a^i b^i c^j\}\), \(L_2=\{a^i b^j c^j\}\) (둘 다 CFL)
  \(\Rightarrow L_1\cap L_2=\{a^n b^n c^n\}\) (CSL, 비CFL)

- **CFL 보수 비닫힘**:
  \(L=\{a^n b^n\}\)는 CFL, \(\overline{L}\)는 비CFL(직접 증명 또는 교집합 반례 유도).

- **CSL 보수 닫힘**:
  Immerman–Szelepcsényi: \( \mathrm{NSPACE}(s)\!=\!\mathrm{coNSPACE}(s) \) for \(s\ge \log n\).

- **RE 보수 비닫힘**:
  \(A_{TM}\)은 RE이지만 재귀적 아님 ⇒ 보수 \(\overline{A_{TM}}\)는 RE가 될 수 없음.

---

## 9. **모호성(ambiguity)**과 계층

- **REG**: 본질적 모호성 개념이 의미 없음(FA는 결정적 수용).
- **CFL**: 어떤 언어는 **본질적으로 모호**(어떤 CFG로도 모호성 제거 불가).
  - 실전: 파서 설계에서 **우선순위·결합성**을 문법에 인코딩하거나 **GLR**로 다의성 수용.

**예 — 산술식 비모호 문법(좌결합, * > +)**
```bnf
E  -> E + T | T
T  -> T * F | F
F  -> ( E ) | id
```
- 파서 제너레이터(yacc/bison)는 위 문법에 우선순위/결합성 선언으로 충돌을 해소하기도 함.

---

## 10. **현업 연결**: 파서·검증·형식 명세

- **정규**: 로그 필터, 토큰화(lexer), 간단 패턴 매칭, 네트워크 프로토콜의 프레이밍.
- **CFL**: 프로그래밍 언어 구문, 수식 파서, JSON/CSV(제약 하) 등.
- **CSL**: 제한된 정적분석(선형 공간 마킹/검증), 다중 동기화 필요 구조.
- **RE**: 일반 프로그램 의미, 정지/등가성/보편성 — **완전 자동 판정 불가**(Rice).

---

## 11. **실전 분류 연습**(풀어서 제시)

### 연습 A — \(L=\{ w\in\{a,b\}^* \mid \#a(w)=\#b(w) \}\)

- 정규? **아님** (Myhill–Nerode로 무한 상호구별류; 직관적으로 unbounded counting)
- CFL? **맞다**. 스택 하나로 a를 +1, b를 -1처럼 맞출 수 있나?
  - 단, 위치 자유 전체 문자열에서 \(\#a=\#b\)는 **CFL 아님**이 잘못 알려지곤 한다.
  - 정답: **CFL이다.** PDA가 왼→오른쪽으로 읽으며 a면 push, b면 pop, **음수 아래로 내려가면 실패**, 끝에 스택 0이면 accept.
  - 반례로 알려진 것은 보통 **순서까지 동기화**(예: \(a^n b^m\)류)와 혼동.

**CFG 스케치**
```bnf
S -> a S b S | b S a S | ε
```
- 위는 \(\#a=\#b\)를 생성하되 순서를 자유롭게 섞는 패턴. (간결한 등가 구성 다수 존재)

### 연습 B — \(L=\{ ww \mid w\in\{0,1\}^* \}\)

- 정규? **아님** (Myhill–Nerode로 각 접두어 길이 구별 필요)
- CFL? **아님** (CFL 펌핑/오그덴 보조정리)
- CSL? **맞다**. LBA로 첫 절반을 마킹하며 두 번째 절반과 동일성 검사.

### 연습 C — \(L=\{ a^i b^j c^k \mid i=j \text{ or } j=k\}\)

- 각각의 부분은 CFL이지만 **전체 보수**는 비CFL → CFL의 **보수 비닫힘** 직관 예.

---

## 12. **코드/구성 스니펫 모음**

### 12.1 Myhill–Nerode **동치류** 체크(스케치)

- 두 문자열 \(x,y\)가 **구별**되려면 어떤 \(z\)에 대해 \(xz\in L, yz\notin L\) (또는 반대).
- REG면 동치류 **유한 개**. 무한히 필요해 보이면 정규 아님.

```text
Sketch for L = { a^n b^n }:
- prefixes a^i (i ≥ 0)를 서로 구별시키는 z = b^i 로 분리 ⇒ 무한 동치류 ⇒ 비정규
```

### 12.2 PDA 설계 패턴 — 균형 검사

```text
State: q
Stack alphabet: Z0(바닥), A
Transitions:
- on 'a': push A
- on 'b': pop A (if empty -> reject)
- end: accept iff stack == Z0
```

### 12.3 LBA 마킹 패턴 — \(a^n b^n c^n\)

```text
repeat:
  scan left-to-right to find first 'a' (unmarked)
    if none: goto CHECK_TAIL
    mark it 'Ā'
    continue scanning to mark first unmarked 'b' -> 'ḃ'
    continue scanning to mark first unmarked 'c' -> 'ċ'
    move head back to leftmost; repeat
CHECK_TAIL:
  if any unmarked b or c remain: REJECT
  else: ACCEPT
```

### 12.4 CYK 테이블(간단 시각화)

- 문자열 `aabb`에 대해 CNF 문법으로 \(P[i,j]\) 채우기:
```
i\j | 1   2   3   4
----+----------------
 1  | {A} {B} {...} ...
 2  |     {A} {...} ...
 3  |         {...} ...
 4  |             {...}
```

---

## 13. **DLBA vs NLBA** (열린 문제)

- 질문: \(\mathrm{DSPACE}(n) \stackrel{?}{=} \mathrm{NSPACE}(n)\)
- 현재: **미해결**. Savitch: \(\mathrm{NSPACE}(n)\subseteq \mathrm{DSPACE}(n^2)\).
- 의미: CSL(=NLBA)와 “DLBA 언어”의 **표현력 동치 여부** 미정.

---

## 14. **FAQ**

- **Q. CFL이 정규와의 교집합에 닫힌 이유?**
  **PDA×DFA 제품**을 만들면 됨. DFA는 상수-메모리 관찰자 역할.

- **Q. CFG 모호성은 항상 나쁜가?**
  자연어·IDE의 코드 완성에서는 **GLR**처럼 다의성 유지 후 선택이 실전적.

- **Q. RE인데 왜 보수에 닫히지 않나?**
  RE∩coRE=Recursive. 만일 RE가 보수 닫힘이면 RE=Recursive가 되어 HALT와 모순.

---

## 15. **한 페이지 요약**

- **정의**
  REG ↔ 정규문법/FA, CFL ↔ CFG/PDA, CSL ↔ CSG/LBA, RE ↔ TM
- **포함**
  \[
  \text{REG} \subsetneq \text{CFL} \subsetneq \text{CSL} \subsetneq \text{RE}
  \]
- **폐포**
  REG 거의 모두 닫힘 / CFL은 **교·보수 X** / CSL은 **보수 O** / RE는 **보수 X**
- **결정 성질**
  REG 대부분 결정 / CFL 일부 결정(멤버십, 공백성) / CSL 멤버십 어렵고 전역 속성 대개 불가 / RE 전반적으로 반결정
- **실전**
  가능한 낮은 계층에 문제를 놓고(정규→CFL→CSL), 남는 부분은 **근사**·**제약**으로 처리.

---

## 부록 A) **BNF 스니펫 모음**

```bnf
# A. REG: (a|b)*ab(a|b)*
S -> A | a S | b S | ε
A -> a B
B -> b

# B. CFL: { a^n b^n | n ≥ 0 }
S -> a S b | ε

# C. CFL: Balanced parentheses
S -> S S | ( S ) | [ S ] | ε

# D. CFL (산술식, + < * < 괄호)
E -> E + T | T
T -> T * F | F
F -> ( E ) | id

# E. CFL: { ww^R | w ∈ {a,b}* } (회문)
S -> a S a | b S b | a | b | ε

# F. CSL 스케치: a^n b^n c^n  (직관적 보조기호; Kuroda NF로 정규화 가능)
S -> A
A -> a A B | ε
B -> b B C | ε
C -> c C | ε
# (위는 아이디어 스케치이며 실제 CSG 구성은 마킹/검증 규칙군으로 지역화 필요)

# G. Type-0(RE) 스케치: TM 계산 이력 생성(개념)
S -> # C0 # C1 # ... # Ct #
# 각 (Ci -> Ci+1) 전이의 지역 패턴을 허용하는 재작성 규칙군
```

---

## 부록 B) **증명 스케치 레모**

### B.1 정규 펌핑 정리로 \(a^n b^n\) 비정규

- 가정: REG, 펌핑 길이 \(p\). \(s=a^p b^p = x y z\), \(|xy|\le p\), \(|y|\ge 1\).
- \(y\)는 전부 a. \(i=0\) 펌핑하면 \(a^{p-|y|} b^p\in L\)이어야 하나 모순.

### B.2 CFL 펌핑 정리로 \(a^n b^n c^n\) 비CFL

- 펌핑 길이 \(p\). \(s=a^p b^p c^p\).
- \(v,y\)가 포함되는 위치 케이스 분석 → 어느 쪽이든 한 구간만 늘거나 줄어 동기화 깨짐.

### B.3 Ogden 보조정리(강화형) 활용

- 특정 위치를 “표시(marked)”하여 더 강력한 반증. \(ww\)·복제류 반증에 유리.

---

## 부록 C) **미니 케이스 스터디** — JSON 파서 분해

- **토큰화(lexer)**: 정규(숫자/문자열/구분자) → 정규식/FA 처리
- **구문(PDA)**: 중첩 괄호와 목록 → CFG/PDA
- **의미검사**: 키 중복, 타입 호환 등은 CFG 밖(제약 논리 혹은 후처리)

```bnf
Value -> String | Number | Object | Array | true | false | null
Object -> { Members } | { }
Members -> Pair | Pair , Members
Pair -> String : Value
Array -> [ Elements ] | [ ]
Elements -> Value | Value , Elements
```

---

### 마무리

촘스키 계층은 “**언어의 구조적 힘**”을 계량화해 준다.
현업에서는 **가능한 낮은 층**에서 문제를 설계하고, 불가피한 상위 성질은 **제약·근사**로 우회한다.
정규/문맥자유 **패턴 라이브러리**를 확충해 두면, 대부분의 파싱/검증은 **결정 가능한 영역**에서 깔끔히 풀린다.
