---
layout: post
title: 미적분 - 테일러 급수의 응용
date: 2025-07-22 21:20:23 +0900
category: 미적분
---
# 테일러 급수의 응용

## 1. 왜 테일러 급수인가

복잡한 함수를 국소적으로 **다항식**으로 바꿔 계산을 단순화한다. 적은 연산으로 근사값, 민감도(도함수), 곡률(이차 도함수)을 동시에 얻을 수 있다.

- 국소 근사: 중심 $$a$$ 주변에서
$$
f(x)\approx f(a)+f'(a)(x-a)+\frac{f''(a)}{2!}(x-a)^2+\cdots
$$
- 오차 제어: 나머지항 상계로 **필요 차수**를 정량적으로 선택.

---

## 2. 함수 근사: 정밀도와 차수 선택

### 2.1 대표 예시와 오차 상계

#### 예시 A: $$e^x$$ 맥클로린(중심 0), 5차까지
$$
P_5(x)=1+x+\frac{x^2}{2}+\frac{x^3}{6}+\frac{x^4}{24}+\frac{x^5}{120}
$$
라그랑주 나머지
$$
|R_5(x)|=\left|\frac{e^{c}}{6!}x^6\right|\le \frac{e^{|x|}}{720}|x|^6
$$
구간 $$|x|\le 0.5$$ 에서 최대오차
$$
|R_5|\le \frac{e^{0.5}}{720}\cdot 0.5^6\approx 9.3\times 10^{-5}
$$

#### 예시 B: $$\ln(1+x)$$, 교대수렴 오차
$$
\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\cdots\quad(-1<x\le 1)
$$
단조 교대급수이므로 부분합 오차
$$
\left|\ln(1+x)-\sum_{k=1}^{n}(-1)^{k+1}\frac{x^k}{k}\right|\le \frac{|x|^{n+1}}{n+1}
$$
예) $$x=0.3$$, 오차 $$\le 0.3^{n+1}/(n+1)$$

### 2.2 근사 대상별 전략

- 지수·삼각류: 수렴반경이 넓어 맥클로린이 범용적.
- 로그·분수형: **범위 축소**(예: $$x=\mathrm{frexp}$$로 정규화) 후 전개.
- 다항식 변환 가능형: $$\sqrt{1+u}$$, $$1/(1-u)$$ 등 **표준 급수** 조합.

### 2.3 자동 차수 선택(라그랑주 상계 기반)

다음 함수는 $$|f^{(n+1)}(t)|\le M$$, 구간 길이 $$h=|x-a|$$ 일 때 요구오차 $$\varepsilon$$ 를 만족하는 최소 차수를 찾는다.

```python
import math

def degree_for_tolerance(M, h, eps, n_max=50):
    # |R_n| <= M * h^{n+1} / (n+1)!
    fact = 1.0
    power = h
    for n in range(0, n_max+1):
        # 준비: 다음 단계에서 (n+1)!와 h^{n+1}가 필요
        # 현재 n에 대해 다음 항 상계
        fact *= (n+1)
        power *= h
        bound = M * power / fact
        if bound <= eps:
            return n
    return None  # n_max로도 부족
```

예) $$e^x$$, $$|x|\le 1$$ 에서 $$M=e$$, $$h=1$$, $$\varepsilon=10^{-6}$$ 입력 시 결과는 대략 9 또는 10 차.

---

## 3. 수치 해석: 값·도함수·곡률을 한번에

### 3.1 사인 근사와 범위 축소

작은 범위에서
$$
\sin x\approx x-\frac{x^3}{6}+\frac{x^5}{120}
$$
오차 상계
$$
|R_5(x)|\le \frac{|x|^7}{7!}
$$
실무에서는 **범위 축소**(예: $$x\leftarrow \mathrm{remainder}(x,2\pi)$$, 대칭성 사용) 후 5~7차로 충분한 정밀도를 얻는다.

```python
import math

def sin_taylor_small(x):
    x2 = x*x
    return x*(1 - x2/6 + x2*x2/120)

def sin_approx(x):
    # 범위 축소
    pi2 = 2*math.pi
    x = (x + math.pi) % pi2 - math.pi
    # 대칭성
    sign = 1.0
    if x < 0:
        sign = -1.0
        x = -x
    # 작은 범위(<=pi/2)만 남음
    if x > math.pi/2:
        x = math.pi - x
    return sign * sin_taylor_small(x)
```

### 3.2 $$\sqrt{1+u}$$ 근사

$$
\sqrt{1+u}=1+\frac{1}{2}u-\frac{1}{8}u^2+\frac{1}{16}u^3-\frac{5}{128}u^4+\cdots\quad(|u|<1)
$$

```python
def sqrt1p_taylor(u):
    # 4차
    return 1 + 0.5*u - 0.125*u*u + 0.0625*u*u*u - (5/128.0)*u*u*u*u
```

범위를 $$x=\sqrt{m\cdot 2^k}$$ 로 분해(정규화)하면 구현이 견고해진다.

### 3.3 호너 평가로 수치 안정성 향상

```python
def horner(coeffs, t):
    # coeffs: [c0, c1, ..., cn] for sum c_k * t^k
    acc = 0.0
    for c in reversed(coeffs):
        acc = acc * t + c
    return acc
```

---

## 4. 미분방정식: 계수 비교와 피카르 반복

### 4.1 초기값 문제 $$y'=y,\ y(0)=1$$

계수 비교로
$$
y(x)=\sum_{n=0}^{\infty}\frac{x^n}{n!}=e^x
$$
부분합 오차는 $$e^{|x|}\frac{|x|^{n+1}}{(n+1)!}$$ 상계.

### 4.2 비선형 예: $$y'=y^2,\ y(0)=1$$

$$
y(x)=\sum_{n=0}^{\infty}a_n x^n,\quad y'= \sum_{n\ge 0}(n+1)a_{n+1}x^n,\quad y^2=\sum_{n\ge 0}\Big(\sum_{k=0}^{n}a_k a_{n-k}\Big) x^n
$$
계수방정식
$$
(n+1)a_{n+1}=\sum_{k=0}^{n}a_k a_{n-k},\quad a_0=1
$$
앞몇항: $$a_1=1,\ a_2=1,\ a_3=\tfrac{1}{3},\ a_4=0,\ a_5=-\tfrac{1}{45},\ \dots$$
해의 닫힌형은 $$y(x)=\frac{1}{1-x}$$ (수렴반경 1). 테일러 계수는 실제로 $$a_n=1$$ 이 아니라, 위 점화식으로부터 **부분합은** $$1/(1-x)$$ 에 수렴함을 확인한다(점화 유도 시 오차가 없도록 전체 계수 열을 계산해야 한다).

코드로 계수 생성:

```python
import math

def taylor_yprime_y2(n_terms=10):
    a = [0.0]*(n_terms+1)
    a[0] = 1.0
    for n in range(0, n_terms):
        s = 0.0
        for k in range(0, n+1):
            s += a[k]*a[n-k]
        a[n+1] = s/(n+1)
    return a  # a_n 목록

coeffs = taylor_yprime_y2(8)
# 평가: sum a_n x^n
def eval_poly(a, x):
    return sum(a[n]*(x**n) for n in range(len(a)))
```

### 4.3 가변계수 선형: $$y'=xy,\ y(0)=1$$

계수 비교로
$$
(n+1)a_{n+1}=a_{n-1}\quad(n\ge 1),\quad a_0=1,\ a_1=0
$$
짝수차만 살아남아
$$
y(x)=1+\frac{x^2}{2!}+\frac{x^4}{2\cdot 4}+\cdots=\exp\!\Big(\frac{x^2}{2}\Big)
$$

---

## 5. 최적화: 2차 테일러 모델과 뉴턴법

### 5.1 2차 테일러 모델

점 $$x_k$$ 에서
$$
m_k(p)=f(x_k)+\nabla f(x_k)^{\top}p+\frac12 p^{\top} \nabla^2 f(x_k)\, p
$$
뉴턴 스텝은
$$
\nabla^2 f(x_k)\, p_k=-\nabla f(x_k)
$$

### 5.2 예시: 스칼라 함수

$$
f(x)=x^4-3x^2+2
$$
$$
f'(x)=4x^3-6x,\quad f''(x)=12x^2-6
$$

```python
def newton_scalar(x0, maxit=20):
    x = x0
    for _ in range(maxit):
        g = 4*x**3 - 6*x
        H = 12*x**2 - 6
        if abs(H) < 1e-12: break
        x = x - g/H
    return x

root = newton_scalar(1.5)  # 극값점
```

뉴턴법은 2차 모델(테일러 2차) 최소점으로 이동한다. 비볼록 구간에서는 신중한 초기화와 라인서치, 신뢰영역이 필요하다.

---

## 6. 물리·공학 모델링

### 6.1 작은각 근사(진자)

$$
\sin\theta\approx \theta-\frac{\theta^3}{6}
$$
단진자 운동방정식
$$
\theta''+\frac{g}{\ell}\sin\theta=0
$$
작은 각에서
$$
\theta''+\frac{g}{\ell}\theta\approx 0\Rightarrow T\approx 2\pi\sqrt{\frac{\ell}{g}}
$$
주기 보정은 고차항 포함 시 계산 가능.

### 6.2 상대론적 감마 계수

$$
\gamma=\frac{1}{\sqrt{1-(v/c)^2}}
=\left(1-\beta^2\right)^{-1/2},\ \beta=\frac{v}{c}
$$
이항 전개
$$
\gamma\approx 1+\frac12\beta^2+\frac{3}{8}\beta^4+\cdots\quad(|\beta|<1)
$$
저속 영역에서 운동에너지 근사로 이어진다.

### 6.3 평형점 근처 포텐셜

평형점 $$x_0$$ 에서
$$
V(x)\approx V(x_0)+\frac12 V''(x_0)(x-x_0)^2
$$
선형계화로 **조화진동자** 모델 획득(정상모드 분석의 출발점).

---

## 7. 행렬지수와 신호·제어

선형시불변 시스템 $$\dot{x}=Ax$$ 의 해는
$$
x(t)=e^{At}x(0),\quad e^{At}=\sum_{k=0}^{\infty}\frac{(At)^k}{k!}
$$
노름 상계로 나머지항 제어:
$$
\left\|R_n(t)\right\|\le \sum_{k=n+1}^{\infty}\frac{\|A\|^k|t|^k}{k!}
$$
작은 $$|t|$$ 구간을 잘게 나눠(스케일-스퀘어 전략) 테일러 절단으로 근사 가능.

```python
import numpy as np

def expm_taylor(A, t, n=12):
    I = np.eye(A.shape[0])
    M = I.copy()
    term = I.copy()
    for k in range(1, n+1):
        term = term @ (A*t)/k
        M = M + term
    return M

# 예: 회전행렬 생성 A=[[0,-1],[1,0]], e^{At}는 회전
A = np.array([[0.0,-1.0],[1.0,0.0]])
E = expm_taylor(A, t=0.2, n=12)
```

---

## 8. 컴퓨터 그래픽·실시간 시스템

- 비용 큰 연산(log, exp, sin, cos, pow)을 **범위 축소 + 낮은 차수 테일러**로 대체.
- 파이프라인 예: 입력 정규화 → 세그먼트별 다항식 계수 선택(LUT) → 호너 평가.
- 감마 보정, 톤매핑 중 log/exp 근사에 효과적.
- 정확도 요구가 높으면 구간을 더 잘게 나누거나 차수를 올리고, 경계에서 연속성(C¹) 확보.

---

## 9. 오차 관리 체계

### 9.1 라그랑주 상계

$$
|R_n(x)|\le \frac{M}{(n+1)!}|x-a|^{n+1},\quad
M\ge \max_{t\in[a,x]}|f^{(n+1)}(t)|
$$

### 9.2 교대급수 상계(단조 감소)

$$
|R_n|\le \text{다음 항의 절댓값}
$$

### 9.3 자동 선택 파이프라인

1) 목표 구간과 오차 $$\varepsilon$$ 설정.
2) 상계형 선택(라그랑주 또는 교대).
3) 상계 계산으로 최소 차수 산정.
4) 구현은 호너 평가.
5) 벤치마크로 검증, 필요시 분할구간·차수 조정.

오차 상계 함수:

```python
from math import factorial

def lagrange_bound(M, h, n):
    return M * (h**(n+1)) / factorial(n+1)
```

---

## 10. 패데 근사(보완 전략)

테일러 대신 유리함수
$$
P_m(x)/Q_n(x)
$$
로 근사하면 **극점 근처**나 넓은 구간에서 유리한 경우가 많다. 테일러 계수로 선형 방정식을 풀어 계수 결정 가능.

간단한 패데 생성기(선형계 풀이):

```python
import numpy as np

def pade_from_taylor(a, m, n):
    """
    a: 테일러 계수 a[0..m+n] (x=0)
    반환: p(0..m), q(0..n) with q[0]=1
    """
    # 구성: sum_{k=0}^{m} p_k x^k  ≈ (sum_{k=0}^{m+n} a_k x^k) * (sum_{j=0}^{n} q_j x^j)
    # 계수 비교로 q_j( j>=1 )를 먼저 구하고, 이후 p_k 계산
    # 선형계 A q_tail = b
    A = np.zeros((n, n))
    b = np.zeros(n)
    for row in range(n):
        # a_{m+row+1} + sum_{j=1}^{n} a_{m+row+1-j} q_j = 0  형태
        b[row] = -a[m+row+1]
        for col in range(n):
            j = col+1
            A[row, col] = a[m+row+1-j]
    q_tail = np.linalg.solve(A, b) if n>0 else np.array([])
    q = np.concatenate(([1.0], q_tail))
    # p_k 계산
    p = np.zeros(m+1)
    for k in range(m+1):
        s = 0.0
        for j in range(min(k, n)+1):
            s += a[k-j]*q[j]
        p[k] = s
    return p, q
```

예) $$e^x$$ 의 테일러 계수를 넣어 [2/2] 패데를 만들면 넓은 구간에서 테일러 4차보다 안정적인 근사를 얻는다.

---

## 11. 종합 예제: 자동 차수 선택 + 평가 + 오차 확인

목표: $$\ln(1+x)$$, $$x\in[0,0.6]$$, 최대오차 $$10^{-5}$$

전략: 교대급수 오차 ≤ 다음 항.

```python
def ln1p_series_coeffs(N):
    # x - x^2/2 + x^3/3 - ... + (-1)^{n+1} x^n/n
    return [0.0] + [ ((-1)**(n+1))/n for n in range(1, N+1) ]  # c0=0 포함

def degree_ln1p_for_eps(xmax=0.6, eps=1e-5, nmax=100):
    # 다음 항 <= eps  -> xmax^{n+1}/(n+1) <= eps
    import math
    for n in range(1, nmax):
        if (xmax**(n+1))/(n+1) <= eps:
            return n
    return None

deg = degree_ln1p_for_eps()
coeffs = ln1p_series_coeffs(deg)
# 평가: sum_{n=1..deg} c_n x^n
def eval_ln1p_taylor(x, c):
    s = 0.0
    xn = x
    for n in range(1, len(c)):
        s += c[n] * xn
        xn *= x
    return s
```

이제 $$\deg$$ 차 다항식으로 $$[0,0.6]$$ 전 범위를 만족한다.

---

## 12. 주의·한계

- 해석적이지 않은 함수(모든 도함수 존재하나 급수가 원함수에 수렴하지 않는 경우)가 있다. 대표 예:
  $$f(x)=\begin{cases}e^{-1/x^2},& x\ne 0\\ 0,& x=0\end{cases}$$
  0에서의 테일러 계수는 모두 0이지만, $$x\ne 0$$ 에서 $$f(x)>0$$.
- 경계점에서의 거동은 별도 판정 필요(수렴반경의 원).
- 넓은 구간·극점 근처: 테일러만으로는 효율이 떨어질 수 있어 패데·체비셰프 다항 등과 혼용.

---

## 13. 연습문제

1) $$\sin x$$ 를 중심 0에서 7차까지 전개하고, $$|x|\le 0.4$$ 에서 오차 상계를 계산하라.
2) $$y'=xy,\ y(0)=1$$ 의 8차 테일러 다항식을 계수비교로 구하고, 실제 해 $$\exp(x^2/2)$$ 와의 오차를 $$x=0.6$$ 에서 수치로 확인하라.
3) $$\ln(1+x)$$ 를 $$x_0=0.5$$ 중심으로 4차까지 전개하고, $$[0.3,0.7]$$ 구간에서의 최대 오차를 라그랑주 상계로 추정하라.
4) 행렬지수 $$e^{At}$$ 를 10차로 절단한 근사와, 스케일-스퀘어 전략(절반 시간씩 두 번 적용)의 오차 차이를 비교하라(예: $$A=\bigl[\begin{smallmatrix}0&-1\\1&0\end{smallmatrix}\bigr]$$, $$t=0.4$$).

---

## 14. 요약 표

| 주제 | 핵심 포인트 | 실전 팁 |
|---|---|---|
| 함수 근사 | 국소 다항식으로 대체 | 범위 축소 + 호너 평가 |
| 오차 설계 | 라그랑주·교대 상계 | 자동 차수 선택으로 목표 오차 보장 |
| ODE | 계수 비교·피카르 반복 | 선형·비선형 모두 적용 가능 |
| 최적화 | 2차 테일러 모델 | 뉴턴/신뢰영역의 이론적 기반 |
| 물리·공학 | 작은 파라미터 전개 | 유효 구간 명시(작은각, 저속 등) |
| 실시간 | LUT+다항식 | 경계 연속성 확보(C¹) |

---

## 15. 결론

테일러 급수는 단지 “전개식”이 아니라, **오차를 수식으로 설계**해 목표 정확도를 보장하는 실전 도구다. 범위 축소, 상계기반 차수 선택, 호너 평가, 필요 시 패데 보완까지 결합하면, 함수 근사·미분방정식·최적화·시뮬레이션 전반에서 **빠르고 통제 가능한** 계산 파이프라인을 구축할 수 있다.
