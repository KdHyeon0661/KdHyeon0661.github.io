---
layout: post
title: 미적분 - 테일러 급수의 응용
date: 2025-07-22 21:20:23 +0900
category: 미적분
---
# 테일러 급수의 응용

> **핵심 요약**  
> 테일러 급수는 “복잡한 함수 ↔ 다항식”을 연결합니다.  
> 실전에서는 **전개점 선택**, **수렴반경/오차 관리**, **범위 축소(range reduction)**, **호너(Horner) 평가**가 잘 설계된 근사기의 4대 축입니다.  
> 아래는 함수 근사, ODE, 물리·공학, 최적화, 구현 팁, 코드 검증까지 **끝장 정리**입니다.

---

## 1) 함수 근사 (수치 계산의 기본기)

### 1.1 정의와 로컬 근사
어떤 \(f\)가 \(a\)에서 충분히 미분 가능하면
$$
f(x)\approx P_n(x)=\sum_{k=0}^n \frac{f^{(k)}(a)}{k!}(x-a)^k,\qquad
R_n(x)=\frac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1}.
$$
- \(R_n\): **라그랑주 나머지항**. 오차 상계를 정량화할 수 있기 때문에, **필요 차수 \(n\)**를 역으로 구할 수 있습니다.

### 1.2 전개점(센터) 선택
- **원칙**: \(|x-a|\)가 작도록 \(a\)를 고르면 적은 차수로도 높은 정확도.
- **범위 축소**: \(\sin x\)라면 \(x\mapsto \operatorname{remainder}(x,\pi)\), \(\exp x\)라면 \(x=k\ln 2 + r\)로 분해 후 \(\exp r\)만 근사하고 \(2^k\)를 곱합니다.

### 1.3 오차로 차수 선택 — 실전 예시
**목표**: \(|x|\le 0.5\)에서 \(e^x\)를 \(\varepsilon=10^{-8}\) 오차로 근사.  
\(|f^{(n+1)}(c)|\le e^{0.5}<1.65\)이므로
$$
|R_n(x)|\le \frac{e^{0.5}\,|x|^{n+1}}{(n+1)!}\le \varepsilon.
$$
팩토리얼 성장이 크므로 대략 \(n\approx 12\sim 14\)면 충분(아래 코드로 정밀 탐색).

---

## 2) 대표 함수 근사 레시피

### 2.1 지수·삼각·로그(맥클로린)
- \(e^x=\sum_{n\ge0}\frac{x^n}{n!}\) (전 구간 수렴, \(R=\infty\))  
- \(\sin x=\sum_{n\ge0}(-1)^n\frac{x^{2n+1}}{(2n+1)!}\), \(\cos x=\sum_{n\ge0}(-1)^n\frac{x^{2n}}{(2n)!}\)  
- \(\ln(1+x)=\sum_{n\ge1}(-1)^{n+1}\frac{x^n}{n}\) (\(|x|<1\), \(x> -1\)).  
  \(\,x\in(0,1)\)에서 **교대급수** → \(|R_n|\le\) **다음 항** \(=\dfrac{x^{n+1}}{n+1}\).

### 2.2 루트/역수/이항식
- \(\sqrt{1+x}=(1+x)^{1/2}=\sum_{n\ge0}\binom{1/2}{n}x^n,\ |x|<1\)  
- \(\dfrac{1}{1-x}=\sum_{n\ge0}x^n,\ |x|<1\)

> **TIP**: 임베디드/그래픽스에서 \(\sqrt{1+x}\), \(\sin x\), \(\log x\)는 범위 축소 + 저차 다항식 + 호너 평가로 매우 빠르게 구현합니다.

---

## 3) 미분방정식(ODE) — 테일러 방법

### 3.1 초기값 문제의 테일러 방법
\(y' = f(x,y),\ y(x_0)=y_0\).  
해를 \(x_0\)에서 전개:
$$
y(x)=y_0 + y'(x_0)\Delta + \frac{y''(x_0)}{2!}\Delta^2 + \frac{y^{(3)}(x_0)}{3!}\Delta^3+\cdots,\ \Delta=x-x_0,
$$
여기서 고계 도함수는 연쇄법칙으로 \(f\)와 \(\partial f/\partial x,\partial f/\partial y,\ldots\)로 표현합니다.

### 3.2 예제: \(y' = y - x^2,\ y(0)=1\)
- \(y'(0)=1-0=1\)  
- \(y''=y'-2x\Rightarrow y''(0)=1\)  
- \(y^{(3)}=y''-2= -1\)  
- \(y^{(4)}=y^{(3)}= -1\) (계산 계속 가능)

따라서
$$
y(x)\approx 1 + 1\cdot x + \frac{1}{2}x^2 - \frac{1}{6}x^3 - \frac{1}{24}x^4 + \cdots
$$
이 다항식은 작은 \(x\)에서 정밀한 근사(코드로 수치 비교 가능).

---

## 4) 물리·공학 응용

### 4.1 단진자(소각 근사)
비선형 방정식 \( \theta'' + \frac{g}{L}\sin\theta = 0\).  
소각 \(|\theta|\ll 1\)이면 \(\sin\theta\approx \theta - \theta^3/6\).  
- **주기**의 근사(완전타원적분의 급수 전개):
$$
T \approx 2\pi\sqrt{\frac{L}{g}}
\left(1 + \frac{\theta_0^2}{16} + \frac{11\,\theta_0^4}{3072} + \cdots\right),
$$
\(\theta_0\)가 10° 내외면 2항만으로도 매우 정확.

### 4.2 상대론적 에너지의 저속 근사
\(\gamma=\frac{1}{\sqrt{1-\beta^2}},\ \beta=\frac{v}{c}\).  
\(\gamma \approx 1 + \frac{1}{2}\beta^2 + \frac{3}{8}\beta^4+\cdots\).  
운동에너지 \(K=(\gamma-1)mc^2\approx \frac{1}{2}mv^2 + \frac{3}{8}m\frac{v^4}{c^2}+\cdots\).

### 4.3 RF/신호처리: 작은 위상 근사
복소 회전 \(e^{j\phi}\approx 1 + j\phi - \frac{\phi^2}{2}\) (작은 \(|\phi|\))  
→ IQ 믹서/PLL 분석, 미세 위상잡음 모델링에 유용.

---

## 5) 최적화(머신러닝 포함)

### 5.1 뉴턴 방법은 2차 테일러
스칼라 \(f:\mathbb{R}\to\mathbb{R}\)에서
$$
f(x)\approx f(x_k) + f'(x_k)(x-x_k) + \tfrac{1}{2}f''(x_k)(x-x_k)^2.
$$
극소를 만족하는 1차조건 \(f'(x)=0\)의 선형화 해로
$$
x_{k+1}=x_k - \frac{f'(x_k)}{f''(x_k)}.
$$
다변수에서는 \(x_{k+1}=x_k - H^{-1}\nabla f\) (헤시안 \(H\)).  
**BFGS** 등은 \(H^{-1}\)를 업데이트하는 준뉴턴(메모리 절약).

### 5.2 가우스-뉴턴(최소제곱)
잔차 \(\,r(x)\)의 2차 근사(테일러)로 \(\|r\|_2^2\)를 근사 → 선형 최소제곱으로 반복.

---

## 6) 구현 팁 — 빠르고 안전한 근사기 만들기

1) **범위 축소**: \(\exp x = 2^k \exp r\) (여기서 \(r\in[-\tfrac{\ln 2}{2},\tfrac{\ln 2}{2}]\)).  
2) **호너(Horner) 평가**:  
   다항 \(a_0+a_1 t+\cdots + a_n t^n\)는  
   \( (((a_n t + a_{n-1})t + \cdots) t + a_0) \)로 평가 → 곱셈/덧셈 최소화, 수치 안정성 ↑.  
3) **교대급수 오차 규칙**: \(\ln(1+x),\ \arctan x\) 등은 **다음 항 ≤ 오차**.  
4) **특이점 거리 = 수렴반경**(복소해석 관점)으로 전개점 선택을 가이드.  
5) **Padé 근사**(유리함수)는 같은 차수에서 더 넓은 영역/더 낮은 오차를 주는 경우가 많음(특히 \(\exp, \log\)).

---

## 7) Worked Example — \(\sin x\)를 \([-\pi/4,\ \pi/4]\)에서 \(<10^{-6}\)로

- 전개: \(\sin x = x - \frac{x^3}{6} + \frac{x^5}{120} - \frac{x^7}{5040} + \cdots\)  
- 최대 \(|x|=\pi/4\approx 0.7854\).  
- 교대 구조이므로 오차는 **다음 항**의 절대값 이하.  
  5차까지 쓰면 **다음 항**은 \(\dfrac{|x|^7}{5040}\approx \dfrac{0.7854^7}{5040}\approx 1.1\times 10^{-4}\) (부족).  
  7차까지 쓰면 **다음 항** \(\dfrac{|x|^9}{362880}\approx 1.7\times 10^{-7}\) → **충분히** \(<10^{-6}\).

**호너형 평가식(의사코드)**  
```
t = x*x
p = -1.0/362880.0      # -1/9!
p = p*t +  1.0/5040.0  # +1/7!
p = p*t + -1.0/120.0   # -1/5!
p = p*t +  1.0/6.0     # +1/3!
return x + x*(t*p)     # x + x*t*(1/3! - t/5! + t^2/7! - t^3/9!)
```
- 곱셈/덧셈이 최소화되고 **분기 없음**.

---

## 8) 수렴반경과 경계의 함정

- \(C^\infty\)라도 **비해석적**이면 테일러 급수가 원함수와 **불일치**할 수 있습니다.  
  대표 반례:  
  $$
  f(x)=\begin{cases}
  e^{-1/x^2},& x\ne 0\\
  0,& x=0
  \end{cases}
  \quad\Rightarrow\quad
  f^{(n)}(0)=0\ \forall n \;\text{(급수는 0)}\ \ne f(x)\ (x\ne 0).
  $$
- \(\ln(1+x)\)는 \(|x|\to 1\)에서 **매우 많은 항** 필요(특이점 \(x=-1\)까지의 거리가 1).

---

## 9) 실전 계산 코드 (SymPy/Numpy)

> *참고: 아래 코드는 예제용입니다. 실행 환경에 맞게 SymPy/Numpy 설치 후 사용하세요.*

### 9.1 전개/오차 탐색 도우미
```python
import sympy as sp
x = sp.Symbol('x')

def taylor_poly(f, a, n):
    P = 0
    for k in range(n+1):
        P += sp.diff(f, x, k).subs(x, a) / sp.factorial(k) * (x - a)**k
    return sp.simplify(P)

# 예) e^x 맥클로린 10차
f = sp.exp(x)
P10 = taylor_poly(f, 0, 10)
print("P10:", sp.expand(P10))

# 최대 오차 스캔 (|x| <= 0.5)
err = sp.lambdify(x, sp.Abs(f - P10), "numpy")
import numpy as np
xs = np.linspace(-0.5, 0.5, 2001)
print("max error on [-0.5,0.5]:", float(np.max(err(xs))))
```

### 9.2 \(\ln(1+x)\)에서 목표 오차로 최소 차수 찾기 (교대 오차)
```python
import math

def n_for_log1p(x, eps=1e-6):
    """ |R_n| <= x^{n+1}/(n+1) < eps 를 만족하는 최소 n (0<x<1) """
    assert 0 < x < 1
    n = 1
    while True:
        if (x**(n+1))/(n+1) < eps:
            return n
        n += 1

for x0 in (0.1, 0.5, 0.9):
    print(x0, n_for_log1p(x0, 1e-6))
```

### 9.3 ODE 테일러 근사 검증: \(y' = y - x^2,\ y(0)=1\)
```python
# 심볼릭로 4차 근사 다항식 만들고 수치 비교
y_series = 1 + x + x**2/2 - x**3/6 - x**4/24  # 위에서 유도한 근사
rhs = sp.simplify(sp.diff(y_series, x) - (y_series - x**2))
print("잔차(잔여 미분 방정식 위배):", sp.expand(rhs))  # 고차항으로만 남아야 정상
```

### 9.4 호너 평가(NumPy)로 빠른 다항 근사
```python
import numpy as np

def sin_approx_opt(x):
    t = x*x
    p = -1.0/362880.0
    p = p*t +  1.0/5040.0
    p = p*t + -1.0/120.0
    p = p*t +  1.0/6.0
    return x + x*(t*p)

xx = np.linspace(-np.pi/4, np.pi/4, 100000)
err_max = np.max(np.abs(np.sin(xx) - sin_approx_opt(xx)))
print("max |error| on [-pi/4, pi/4]:", err_max)
```

---

## 10) 미니 프로젝트: \(\exp\) 근사 커널 설계

**목표**: \(|x|\le 0.5\)에서 \(|\exp(x)-P_n(x)|<10^{-8}\)  
1) 범위 축소 없이 직접: 위 9.1 코드로 \(n\) 탐색(대략 12~14)  
2) **범위 축소**: \(x=k\ln 2 + r,\ r\in[-\ln 2/2, \ln 2/2]\).  
   - \(\exp(x)=2^k\exp(r)\), \(r\)만 6~8차 다항식으로 근사 가능  
   - 전체 범위에서 더 낮은 차수로 동일 오차 달성 → **속도/정확도 동시 개선**

---

## 11) 체크리스트

- [ ] 전개점 \(a\): 사용 구간 중앙 or 바이어스 최소점  
- [ ] 오차 상계: 라그랑주 or 교대 규칙으로 **항수 산정**  
- [ ] 범위 축소: 삼각/지수/로그 필수 테크닉  
- [ ] 평가: **호너**로 곱셈 최소화, 분기 회피  
- [ ] 수렴반경: **가까운 특이점**(복소 포함)을 항상 의식  
- [ ] 필요시 **Padé**(유리 근사) 고려 — 특히 \(\exp, \log\)

---

## 12) 한눈 요약

| 주제 | 핵심 |
|---|---|
| 함수 근사 | 다항식으로 대체하여 연산 단순화/가속 |
| ODE | 테일러 방법으로 초기값 근방 해의 다항 전개 |
| 물리 | 소각(진자), 저속(상대론), 작은 위상(신호) 근사 |
| 최적화 | 2차 테일러 → 뉴턴/준뉴턴의 이론적 토대 |
| 구현 | 범위 축소 + 호너 + 교대 오차 규칙 |
| 위험 | 해석성 부족, 경계\(|x|\approx R\)에서 느린 수렴 |

---

### 마무리
테일러 급수의 진짜 힘은 **오차를 설계 가능**하게 만들고, **실제 시스템 제약(속도·정확도·메모리)** 하에서 **최적의 근사 전략**을 세울 수 있게 해준다는 점입니다.