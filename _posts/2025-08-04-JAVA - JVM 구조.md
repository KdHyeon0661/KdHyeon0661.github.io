---
layout: post
title: Java - JVM 구조
date: 2025-08-04 20:20:23 +0900
category: Java
---
# JVM 구조 — Heap, Stack, Method Area, Code Cache, Class Loader, Execution Engine

## 한눈에 보는 JVM 구성도

```
+-----------------------------------------------------------------------------------+
|                                  Java Virtual Machine                             |
|                                                                                   |
|  [Class Loader Subsystem]  -> Loading / Linking(Verify, Prepare, Resolve) / Init  |
|                                                                                   |
|  [Runtime Data Areas]                                                           +-+|
|  - Heap (Young: Eden/S0/S1, Old)  <--- GC 대상                                   | |
|  - Method Area / Metaspace        <--- 클래스 메타, 상수풀, 코드 메타             | |
|  - Code Cache (JIT Native Code)   <--- C1/C2 컴파일 산출물                        | |
|  - Java Stacks (per-thread)       <--- Frame: local vars, operand stack           | |
|  - PC Registers (per-thread)      <--- 현재 바이트코드 지시자                     | |
|  - Native Method Stacks           <--- JNI, 네이티브 호출                          | |
|                                                                                   | |
|  [Execution Engine]                                                               | |
|  - Interpreter               - JIT Compiler (C1/C2, Tiered)                       | |
|  - Deoptimizer               - GC Threads                                         | |
|                                                                                   +-+
|  [Native Interface / Libraries] (JNI, JVM TI, OS Threads, Signals, Safepoints)     |
+-----------------------------------------------------------------------------------+
```

---

## — 총정리

아래 표는 **개념적 위치**와 **HotSpot 구현 관점**을 구분해 오해를 줄입니다.

| 영역 | 역할(개념) | HotSpot 실제 저장/구현 포인트 | 튜닝/오류 |
|---|---|---|---|
| **Heap** | 객체/배열 저장, GC 대상 | Young(Eden/S0/S1), Old; TLAB 할당 | `-Xms/-Xmx`, OOM: Java heap space |
| **Method Area / Metaspace** | 클래스 메타데이터, 상수풀, 메서드/필드 정보, 일부 런타임 구조 | Java 8+ Metaspace(네이티브 메모리), Java 7- PermGen | `-XX:MaxMetaspaceSize`, OOM: Metaspace |
| **Code Cache** | JIT로 생성된 네이티브 코드 저장 | Segmented Code Cache(Non-Profiled, Profiled, Non-Method 등) | `-XX:ReservedCodeCacheSize`, CodeCacheFull |
| **Java Stack (thread별)** | 프레임(지역변수/오퍼랜드 스택/리턴주소) | 메서드 호출마다 Push/Pop | `-Xss`, StackOverflowError |
| **PC Register (thread별)** | 현재 실행 바이트코드 오프셋 | 네이티브 실행 중에는 미정의(명세) | - |
| **Native Method Stack** | JNI 호출 스택 | C/C++ 프레임 | 플랫폼 종속 |

> **주의(정확성)**: 교재에서 “static 필드가 Method Area에 저장”이라 서술되기도 하지만, **HotSpot 구현**에서는 static 필드 값은 해당 클래스를 나타내는 **`java.lang.Class` 미러 객체(힙)** 에 들어갑니다(메타는 Metaspace). 문서를 쓸 때 **개념 vs 구현**을 항상 분리해서 기술하세요.

---

## Heap 상세 — Young/Old, TLAB, 압축 참조, 객체 레이아웃

### 세대(Generation)와 수집 개요

```
Heap
+-------------------+------------------------------+
|      Young        |             Old              |
|  Eden |  S0 | S1  |         Tenured              |
+-------------------+------------------------------+
  ^  새 객체 대부분     ^ 오래 살아 남으면 승격(promote)
```

- **Minor GC**: Eden 가득 → 살아있는 객체를 S0/S1로 복사(evacuate)
- **Tenuring / Promotion**: 생존 횟수가 문턱(tenuring threshold)을 넘으면 Old로 이동
- **Major/Mixed/Full GC**: Old 정리(알고리즘에 따라 다름, G1은 Mixed)

### TLAB(Thread-Local Allocation Buffer)

- 스레드별로 Eden의 일부를 **TLAB**으로 예약 → 동기화 없이 초고속 할당(포인터 bump)
- 실패 시 slow path(글로벌 할당), 큰 객체는 TLAB 우회(Direct to Eden/Old, G1은 Humongous Region)

### 객체 메모리 레이아웃(HotSpot 64-bit, 기본 가정)

- **헤더**: Mark Word(8B) + Klass Pointer(4B, **Compressed OOPs** 시) + Padding
- **데이터**: 필드(정렬/패딩 포함)
- **정렬**: 8바이트 정렬

$$
\text{ObjectSize} \approx \text{Header} + \text{Fields} + \text{Padding},\ \text{align to 8B}
$$

**예**: `class Node { int a; long b; Object ref; }`
- Header(12B with compressed klass) → 정렬로 16B 간주
- Fields: `int a(4) + pad(4) + long b(8) + ref(4) + pad(4)` = 24B
- 총합 ≈ 16 + 24 = 40 → 8B 정렬 → **40** (이미 8의 배수)
※ JDK, 옵션(CompressedOops/CompressedClassPointers)과 플랫폼에 따라 달라질 수 있습니다.

### Compressed OOPs & Class Pointers

- 64-bit JVM에서 참조를 32비트로 압축(shift 기반) → 메모리 절감과 캐시 효율
- 보통 **Heap ≤ 32GB**에서 자동 활성화(버전에 따라 다름)

---

## Method Area / Metaspace / Constant Pool

- **Metaspace(Java 8+)**: 네이티브 메모리 사용. 동적 확장되나 상한 없으면 무제한 성장 → 반드시 **상한 설정 검토**
  - `-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m` (시작/최대)
- **Runtime Constant Pool**: 리터럴/심볼, `invokedynamic`, `MethodHandle` 정보 포함
- **동적 클래스 생성 많은 서비스**(프록시, 바이트코드 조작, 리로드)는 **클래스 언로드 불가 상황**(ClassLoader 누수)로 OOM: Metaspace 유발 가능

---

## Code Cache — JIT 산출물 저장소

- **Tiered Compilation**: C1(빠른), C2(고성능) 병행
- Code Cache가 꽉 차면 **컴파일 중단 → 성능 저하**
- 기본 크기 확인/조정:
```bash
-XX:ReservedCodeCacheSize=240m
-XX:+PrintCodeCache
```

---

## Java Stack, Frame, PC Register

### Frame 구성

- **Local Variables**: 파라미터/지역 변수 저장
- **Operand Stack**: 바이트코드 연산 스택
- **Frame Data**: 동적 링크, 리턴주소

### 스택 크기 & 오류

- `-Xss512k` ~ `-Xss2m`(플랫폼 종속)
- **무한 재귀 → StackOverflowError**
- 프레임 크기가 큰 메서드(거대 배열, 많은 로컬)도 주의

---

## 클래스 로더 서브시스템 — 위임 모델과 라이프사이클

### 모델

```
AppLoader -> Platform(Ext) -> Bootstrap
      ^                     (최상위)
```

- 보안/일관성을 위해 **상위 로더에 먼저 위임**
- Java 9+: `PlatformClassLoader`(확장)와 `AppClassLoader`(시스템) 구분

### 클래스 라이프사이클

1) **Loading** → 바이트코드 읽기
2) **Linking**
   - Verify (형식/타입 안전)
   - Prepare (static default 값 준비)
   - Resolve (심볼릭 링크 해석; 지연 가능)
3) **Initialization** → `static {}` 실행, 상수 초기화

---

## 실행 엔진 — 인터프리터, JIT, Deoptimization, Escape Analysis

- **Interpreter**: 빠른 시작, 프로파일 수집
- **JIT(Tiered)**: 핫스팟 메서드 네이티브화(인라이닝, 루프 최적화, 벡터화)
- **Deoptimization**: 가정 깨지면 인터프리터로 “되돌림”(OSR 등)
- **Escape Analysis** → **스칼라 분해**/**스택 할당**/**락 제거**(동기화 제거)

**확인 예제(JIT/Compilation 로그)**
JDK 11+:
```bash
-XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation -XX:LogFile=jit.xml
```
JDK 9+ JFR로 컴파일 이벤트 확인을 권장.

---

## — 매우 중요한 실행 제어

- 대부분의 GC/리로케이션/리디파이닝은 **Safepoint**에서 수행
- Safepoint 도달 지연(특히 **긴 루프에 메서드 호출/분기 부재** 시) → **STW 길어짐**
- 루프에 **`Thread.onSpinWait()` / `Blackhole.consumeCPU()`** 등으로 컴파일러가 Safepoint 체크 넣을 기회를 주는 패턴 고려(상황별)

---

## 진단/관찰 도구 — 실무 세트

### 명령행 도구

```bash
# 스레드 덤프

jstack <pid> > thread.txt

# 힙 덤프 (라이브만)

jmap -dump:live,format=b,file=heap.hprof <pid>

# 실시간 통계(GC, 클래스, 컴파일러 등)

jstat -gc <pid> 1000
jstat -class <pid> 1000
jstat -compiler <pid> 1000

# 만능(jcmd)

jcmd <pid> VM.flags
jcmd <pid> GC.heap_info
jcmd <pid> GC.run
jcmd <pid> JFR.start settings=profile filename=recording.jfr
```

### GUI/서비스

- **JFR(Java Flight Recorder)** + **JMC(Java Mission Control)**: 프로덕션 저오버헤드 프로파일
- **VisualVM/JConsole**: 로컬/원격 모니터링

---

## 실전 예제 모음

### 힙 OOM 재현

```java
// HeapOOM.java
import java.util.*;
public class HeapOOM {
    public static void main(String[] args) {
        List<byte[]> list = new ArrayList<>();
        while (true) {
            list.add(new byte[1024 * 1024]); // 1MB씩 누수
        }
    }
}
```

실행:
```bash
java -Xms64m -Xmx64m HeapOOM
# java.lang.OutOfMemoryError: Java heap space

```

### Metaspace OOM(동적 클래스 로딩 누수)

```java
// MetaLeak.java (예시용: 실제 바이트코드 프록시/리로드 라이브러리로 재현 권장)
import java.net.*;
import java.lang.reflect.*;
public class MetaLeak {
    public static void main(String[] args) throws Exception {
        int i = 0;
        while (true) {
            URLClassLoader loader = new URLClassLoader(new URL[]{new URL("file:./")}, null);
            Class<?> c = Class.forName("java.lang.String", true, loader); // 예: 다른 클래스 로딩
            // loader를 강참조로 보관하면 언로드 불가 → 누적 (데모 개념)
            if ((++i % 1000) == 0) System.out.println("loaded " + i);
        }
    }
}
```

실행(상한 작게):
```bash
java -XX:MaxMetaspaceSize=32m MetaLeak
# java.lang.OutOfMemoryError: Metaspace

```
> 실제로는 **사용자 정의 클래스**를 지속 생성/보관하여 재현하세요. 위 코드는 개념을 위한 의사 예시입니다.

### StackOverflow 재현

```java
// SOF.java
public class SOF {
    static void recur() { recur(); }
    public static void main(String[] args) { recur(); }
}
```

실행(스택 작게):
```bash
java -Xss128k SOF
# Exception in thread "main" java.lang.StackOverflowError

```

### CodeCache 포화 관찰

```bash
java -XX:+PrintCodeCache -XX:ReservedCodeCacheSize=64m -jar your-app.jar
# CodeCache 뷰/경고 확인

```

---

## 문자열 상수풀, interning, deduplication

- **String Table(상수풀)**: 리터럴은 클래스 로딩 시 intern
- `String.intern()`은 풀에 존재하면 동일 참조 반환
- **G1**의 `-XX:+UseStringDeduplication`은 동일한 **내용**의 힙 문자열을 dedup(참조 공유) → 메모리 절감(오버헤드와 트레이드오프)

---

## 핵심 — 가시성과 재배치

- **volatile**: 가시성/순서 보장(원자적은 아님, long/double 64bit도 원자성 보장)
- **happens-before**: 락 언락 → 락 획득, volatile write → volatile read 등
- **안전한 공개(safe publication)**:
  - final 필드 불변 객체
  - `volatile` 참조로 게시
  - 스레드 시작 전 구성 완료
  - 동기화 보호 하에 공유
- **불변/함수형 스타일**은 JMM 문제를 근본적으로 줄임

---

## 네이티브/오프힙 — DirectByteBuffer, JNI, NIO

- **DirectByteBuffer**: 오프힙(네이티브) 메모리를 래핑 → GC 부하 감소/IO 성능 향상
- 주의: 할당/해제 비용, 누수 위험(참조 살아있으면 해제 지연). `Cleaner`/명시 해제 패턴 고려
- JNI 호출은 비용이 큼 → 경계 최소화/배치 전송

---

## 모듈/클래스로더/리로딩 — 클래스 언로드 조건

- **언로드 3요건**(HotSpot 일반 규칙):
  1) 클래스 로더가 도달 불가(더 이상 참조 없음)
  2) 해당 로더로 로드된 모든 클래스도 도달 불가
  3) 클래스/로더에 연결된 메타 구조도 도달 불가
- 프록시/스크립팅/리로더는 **ClassLoader 누수** 주의(정적 컬렉션 보관 금지)

---

## 튜닝 체크리스트 — 현장용

- [ ] `-Xms == -Xmx`(서버)로 확장 비용 제거, `AlwaysPreTouch`로 페이지 폴트 완화
- [ ] GC 선택: **G1(기본)** / 처리량: **Parallel** / 초저지연: **ZGC**
- [ ] Metaspace 상한 설정(동적 클래스 많은 서비스)
- [ ] Code Cache 사이즈 확인(컴파일 중단 방지)
- [ ] 스택 크기 점검(깊은 재귀/큰 프레임)
- [ ] JFR + GC 로그 기본 활성화, 대시보드 연동(Pause, Live Bytes, Promotion, Humongous)
- [ ] 클래스 로더/ThreadLocal/캐시 만료 정책 검토 → 누수 방지
- [ ] 대형 객체/Humongous 패턴 완화(청크/풀링)
- [ ] Escape Analysis에 우호적인 코드(불변/로컬화)
- [ ] Safepoint 친화 루프(분기/호출 제공)

---

## 미세 이슈 모음(간략)

- **Biased Locking**: 최신 LTS에서 제거/비활성 추세(성능 영향 축소). 최신 JDK 노트 확인
- **압축 클래스 포인터(CompressedClassPointers)**: Metaspace 구조 최적화
- **Card Table / Remembered Set(G1)**: 교차 세대 참조 추적 비용 → 쓰기 배리어(write barrier)로 감당
- **OS/NUMA**: 대용량 힙은 NUMA 정책/바인딩이 체감 성능에 영향

---

## 요약 표(재정리)

| 분류 | 요점 | 실무 포인트 |
|---|---|---|
| Heap | 객체/배열, GC 대상 | `-Xms/-Xmx`, 세대/승격/라이브바이트 관찰 |
| Metaspace | 클래스 메타 | 동적 클래스 많으면 상한 설정, 언로드/누수 점검 |
| Code Cache | JIT 네이티브 | 포화 시 컴파일 중단; 사이즈/세그먼트 로그 |
| Stack | 프레임 저장 | `-Xss`; 재귀/큰 로컬로 SOF 가능 |
| PC Reg | 실행 위치 | 네이티브 중 미정의 |
| 실행 엔진 | 인터프리터/JIT/Deopt | Tiered, Escape Analysis, 인라이닝 |
| GC/안전지점 | 일시정지 지점 | 루프 safepoint, STW 원인 파악 |
| 진단 | jcmd/jfr/jstat 등 | 기본 로깅/프로파일 상시화 |

---

## 부록: 실무 스니펫

### 런타임 메모리/GC 상태를 프로그래매틱하게 확인

```java
// RuntimeStats.java
import java.lang.management.*;
import java.util.*;

public class RuntimeStats {
    public static void main(String[] args) throws Exception {
        MemoryMXBean mem = ManagementFactory.getMemoryMXBean();
        System.out.println("Heap: " + mem.getHeapMemoryUsage());
        System.out.println("Non-Heap: " + mem.getNonHeapMemoryUsage());

        for (GarbageCollectorMXBean gc : ManagementFactory.getGarbageCollectorMXBeans()) {
            System.out.printf("GC=%s, count=%d, time(ms)=%d%n",
                gc.getName(), gc.getCollectionCount(), gc.getCollectionTime());
        }

        for (MemoryPoolMXBean pool : ManagementFactory.getMemoryPoolMXBeans()) {
            System.out.printf("Pool=%s, type=%s, usage=%s%n",
                pool.getName(), pool.getType(), pool.getUsage());
        }
    }
}
```

### 상수풀/인터닝 관찰

```java
// InternDemo.java
public class InternDemo {
    public static void main(String[] args) {
        String a = "hello";
        String b = new String("hello");
        System.out.println(a == b);            // false
        System.out.println(a == b.intern());   // true
    }
}
```

---

## 간단 수식 모음(메모리/성능 직감용)

1) **객체 크기 근사**
$$
\text{Size} \approx \text{Header} + \sum \text{Fields} + \text{Padding},\ \text{align to }8\text{B}
$$

2) **Pause 근사(복사형 young 수집)**
$$
T_{\text{pause}} \approx \frac{B_{\text{live}}}{\text{copy\_throughput}} + \text{overheads}
$$

3) **스택 프레임 예산**
$$
\text{MaxDepth} \approx \frac{Xss}{\text{AverageFrameSize}}
$$

---

## 결론

- JVM은 **Heap/Metaspace/Code Cache/Stacks**로 분화된 메모리와 **클래스 로더/실행 엔진/GC**로 구성된 **정교한 런타임**입니다.
- **문제 해결의 핵심**은 “**어느 영역에서 무엇이, 왜**”를 묻는 습관: **힙/메타/코드캐시/스택**을 구분하고, **로그/JFR**로 근거를 수집하세요.
- **기본값(G1, Tiered JIT)**으로 시작하되, 워크로드에 맞게 **GC/메모리/클래스로더/코드 패턴**을 함께 다듬어야 **지속 가능한 성능/안정성**을 얻습니다.
