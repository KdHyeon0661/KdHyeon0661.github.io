---
layout: post
title: Java - JVM 구조
date: 2025-08-04 20:20:23 +0900
category: Java
---
# JVM 구조 — Heap, Stack, Method Area 등 (자세 정리)

Java Virtual Machine(JVM)은 자바 바이트코드를 실행하기 위한 런타임 환경입니다. JVM의 내부 구조(런타임 데이터 영역, 클래스 로더, 실행 엔진, 가비지 컬렉터 등)를 이해하면 메모리 문제 디버깅과 성능 튜닝, 동시성 버그 해결에 큰 도움이 됩니다. 아래에 주요 컴포넌트를 구조적으로 정리했습니다.

---

## 1. 전체 개요 (한눈에)
- **클래스 로더 서브시스템**: 클래스(.class) 파일을 로드하고 링크·초기화한다.  
- **런타임 메모리 영역 (Runtime Data Areas)**:
  - **Method Area (메서드 영역 / Metaspace)** — 클래스/메서드 메타데이터, 상수풀, static 변수 등
  - **Heap (힙)** — 모든 객체 인스턴스와 배열(가비지 수집의 주 대상)
  - **Java Stack (스택)** — 각 스레드별로 존재, 프레임(지역 변수·연산 스택 등)
  - **PC Register (프로그램 카운터)** — 각 스레드의 현재 실행 바이트코드 주소
  - **Native Method Stack** — JNI 등 네이티브 호출용 스택
- **실행 엔진(Execution Engine)**: 인터프리터, JIT 컴파일러, GC 스레드, Native Interface
- **가비지 컬렉터(GC)**: 힙 관리를 담당 — 여러 알고리즘(G1, Parallel, ZGC 등)

---

## 2. 클래스 로더 서브시스템 & 클래스 생명주기
- **Bootstrap ClassLoader** (JVM 내장, 부트스트랩): JDK 핵심 클래스 로드 (`rt.jar` 등).  
- **Extension ClassLoader** (또는 Platform ClassLoader): 확장 라이브러리 로드.  
- **Application (System) ClassLoader**: `-classpath`/`CLASSPATH`의 애플리케이션 클래스 로드.

### 클래스 로드 라이프사이클
1. **Loading**: 바이트코드(.class)를 읽어 메모리에 로드.  
2. **Linking**:
   - **Verification**: 바이트코드 구조·타입 체크.
   - **Preparation**: static 변수에 기본값 할당(primitive → 0, 참조 → null).
   - **Resolution**: 심볼릭 레퍼런스 해석을 실제 레퍼런스로 변환(지연 해석 가능).
3. **Initialization**: static 초기화 블록과 static 변수의 실제 초기화 수행.

> **Method Area / Metaspace**: 클래스 메타데이터(메서드 바이트코드, 상수풀, 필드·메서드 정보)를 저장. Java 8 이전에는 PermGen, Java 8 이후에는 Metaspace(네이티브 메모리)로 변경됨.

---

## 3. 런타임 데이터 영역(메모리) 상세

### 3.1 Heap (힙)
- **목적**: 객체 인스턴스와 배열 저장. 가비지 컬렉션의 대상.
- **구조 (일반적으로)**:
  - **Young Generation (Young Gen)**: Eden + Survivor(From/To)  
    - 대부분의 객체가 여기서 생성되고, 단기간에 사라짐. `Minor GC`가 발생.
  - **Old / Tenured Generation**: 장기간 살아남은 객체들이 승격(promote)되어 저장. `Major/Full GC`가 발생.
- **GC 동작요약**:
  - 새 객체는 Eden에 할당.
  - Eden이 가득하면 Minor GC(주로 복사 알고리즘) 발생 → 살아남은 객체는 Survivor로, 오래 살아남으면 Old로 승격.
  - Major/Full GC는 Old를 정리(보통 더 비용 큼).
- **가비지 컬렉터 종류(간략)**:
  - **Serial GC**: 단일 스레드, 간단(작은 애플리케이션).
  - **Parallel (Throughput) GC**: 다중 스레드 마킹/스윕, 처리량 우선.
  - **CMS (Concurrent Mark Sweep)**: 낮은 Pause(과거), 현재는 deprecated/대체.
  - **G1 (Garbage-First)**: 영역(Region) 기반, 예측 가능한 짧은 pause, 현대 JVM 기본(일부 버전).
  - **ZGC, Shenandoah**: 초저지연(저응답) 가비지 컬렉터, 큰 힙과 낮은 pause 목표.
- **특징/튜닝 포인트**:
  - `-Xms`, `-Xmx`로 힙 크기 고정 또는 제한.
  - `-XX:+UseG1GC`, `-XX:+UseZGC` 등 GC 선택.
  - Eden/Survivor 크기, NewRatio, MaxTenuringThreshold 등 조정 가능.

---

### 3.2 Method Area (메서드 영역) / Metaspace
- **내용**: 클래스 메타데이터, 상수 풀, static 변수, 메서드 바이트코드 등.
- **PermGen vs Metaspace**:
  - Java 7 이전: PermGen (고정 크기, OutOfMemoryError: PermGen space 가능).
  - Java 8+: Metaspace — 네이티브 메모리 사용(기본적으로 동적으로 확장), `-XX:MaxMetaspaceSize`로 제한 가능.
- **문제 사례**: 동적 클래스 생성(예: 프록시/바이트코드 생성 라이브러리)으로 Metaspace 증식 시 OOM 발생.

---

### 3.3 Java Stack (스택) — 스레드별
- **구성**: 스레드가 생성될 때마다 스택이 생성되며, 스택은 **프레임(Frame)**의 연속으로 구성.
- **프레임(Frame)**: 각 메서드 호출마다 하나의 프레임이 생성되고 다음 정보를 포함:
  - **local variables** (지역변수 배열) — primitive와 객체 레퍼런스(참조) 저장
  - **operand stack** — 연산 시 사용되는 임시 스택
  - **frame data** (동적 링크, 반환 주소 등)
- **특징**:
  - 각 스레드에 독립적(스레드 안전).
  - **스택 오버플로우( StackOverflowError )**: 무한 재귀 등으로 스택이 초과되면 발생.
  - 스택 크기 조정: `-Xss` (예: `-Xss1m`).
- **할당 규칙(간단)**:
  - 지역 primitive는 스택(프레임.local) 저장.
  - 객체는 힙에 생성되고 스택에는 객체의 레퍼런스만 저장.

---

### 3.4 PC Register (프로그램 카운터 레지스터)
- 각 스레드마다 하나씩 존재. 현재 실행 중인 JVM 명령(바이트코드)의 주소를 가짐. 스레드가 다른 메서드를 호출하면 PC 레지스터 값 변경.

---

### 3.5 Native Method Stack
- 네이티브 코드(C/C++ via JNI)를 호출할 때 사용하는 스택. 플랫폼/VM 구현에 따라 Java Stack과 통합되기도 함.

---

## 4. 실행 엔진(Execution Engine)
- **인터프리터(Interpreter)**: 바이트코드를 한 줄씩 해석해 실행 — 스타트업 빠름.
- **JIT 컴파일러(Just-In-Time)**:
  - HotSpot은 **Tiered Compilation**(C1(빠른 컴파일)/C2(고성능 컴파일))을 사용.
  - 런타임에 자주 호출되는 메서드를 네이티브 코드로 컴파일(인라인, 루프 최적화 등).
  - **Escape Analysis** → 스택 할당(Scalar Replacement) 가능 → 객체 할당 비용 절감.
- **Runtime Optimizations**: 메서드 인라이닝, 루프 최적화, 락 엘리미네이션(락 제거) 등.
- **GC 스레드**와 기타 런타임 스레드가 내부적으로 동작.

---

## 5. 객체(인스턴스)의 메모리 레이아웃(힙 관점)
- **객체 헤더(Object Header)** (플랫폼/VM에 따라 달라짐):
  - **Mark Word**: 동기화 정보(락 상태), 해시코드, GC 정보 등
  - **Class Pointer (Klass pointer)**: 객체의 타입 정보를 가리킴 (Method Area/Metaspace의 메타데이터 참조)
- **인스턴스 필드**: 선언 순서 및 패딩(정렬)으로 배치됨(primitive 우선권 등).
- **배열 객체**: 헤더 + 길이 정보 + 데이터
- **참조 압축(Compressed OOPs)**: 64-bit JVM에서 참조를 32-bit로 압축하여 메모리 절감(기본 활성화 조건 있음).

---

## 6. 대표적인 에러 및 원인
- `java.lang.OutOfMemoryError: Java heap space`  
  → 힙 부족 (객체 지속 증가, 메모리 누수).
- `java.lang.OutOfMemoryError: Metaspace`  
  → Metaspace(클래스 메타데이터) 초과 (동적 클래스 생성/메모리 누수).
- `java.lang.StackOverflowError`  
  → 스택(재귀 등) 초과.
- `GC overhead limit exceeded`  
  → GC가 너무 많은 시간을 소비하면서 실제로 메모리 확보가 거의 안될 때(JVM이 경고 목적으로 발생).

---

## 7. 진단 도구 & 로그
- **jmap**: 힙 덤프 생성/메모리 통계. (`jmap -dump:live,format=b,file=heap.hprof <pid>`)
- **jstack**: 스레드 덤프(Stack trace) 확인.
- **jstat**: GC/메모리/클래스 로딩 통계.
- **jcmd**: 다양한 JVM 명령 실행(현대적 통합 도구).
- **jinfo**: JVM 옵션 확인.
- **VisualVM, JConsole, Java Mission Control (JMC)**: GUI 기반 모니터링/진단.
- **GC 로그**:
  - Java 8 이전: `-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log`
  - Java 9+ (플랫폼별 차이): `-Xlog:gc*:file=gc.log:time,level,tags`  
  → GC 파라미터/로그 확인으로 GC 원인 분석 가능.

---

## 8. GC 알고리즘 요약(최신 주요 컬렉션)
- **Serial GC**: 단일 스레드, 간단/예측 가능(작은 앱).
- **Parallel GC**: 멀티스레드 마킹/스윕, 높은 처리량.
- **G1 GC (Garbage-First)**:
  - 힙을 **Region**으로 분할(대략 몇 MB 단위).
  - 젊은/오래된 영역을 동적으로 할당.
  - **Young GC**와 **Mixed GC**(young + 일부 old)로 동작.
  - 목표: 응답 시간 제한을 맞추면서 처리량 제공.
- **ZGC / Shenandoah**: 매우 짧은 pause(실수에 가까운 짧음), 큰 힙 최적화(수백 GB까지).
- **CMS**: 과거 낮은 pause 목적(현재는 대체됨).

---

## 9. 튜닝 팁 & 실무 권장 사항
- **메모리 할당 정책**:
  - `-Xms` = 초기 힙, `-Xmx` = 최대 힙. 같은 값으로 고정하면 힙 확장 비용 감소.
- **스택**: 스택 오버플로우 우려 시 `-Xss` 증가.
- **Metaspace**: `-XX:MetaspaceSize`, `-XX:MaxMetaspaceSize`로 조정.
- **GC 선택**:
  - 낮은 지연(응답시간)이 중요하면 **G1** 또는 **ZGC/Shenandoah** 고려.
  - 처리량(TPS) 우선이면 **Parallel GC**.
- **JIT/Tiered**: 프로덕션에서는 tiered compilation이 기본이며 성능 개선에 도움.
- **애플리케이션 설계**:
  - 객체 생성량을 줄이기(재사용, 객체 풀링 불필요 남용 주의).
  - 긴 수명 객체(캐시)와 단명 객체 구분.
- **모니터링/알림**: GC 로그와 메트릭(Heap usage, pause time)을 지속적으로 수집.

---

## 10. 간단 예제 — 어디에 할당되는가?
```java
public class MemoryExample {
    private static String staticStr = "static"; // Method Area (클래스 로드 시)
    
    public void method() {
        int localPrimitive = 10;            // 스택 (frame.local variables)
        String s = new String("hello");     // 힙 (객체), 스택에는 레퍼런스 s
        Object[] arr = new Object[1000];    // 힙 (배열 객체)
        // 배열 내부의 각 요소가 객체를 참조하면 그 객체도 힙에 존재
    }
}
```
- `staticStr`: 클래스 메타데이터(Method Area/Metaspace)와 상수풀에 영향.
- `localPrimitive`: 스택 프레임의 로컬 변수.
- `new String("hello")`: 힙(인스턴스) — 문자열 상수풀("hello")는 별도의 영역(상수풀)에 존재할 수 있음.

---

## 11. 추가 고급 주제(짧게 언급)
- **Escape Analysis**: 객체가 메서드 밖으로 빠져나가지 않으면 스택에 할당하거나 스칼라로 분해 가능(Heap 할당 회피).
- **Compressed OOPs**: 64-bit JVM에서 레퍼런스 압축으로 메모리 절감.
- **TLAB (Thread-Local Allocation Buffer)**: 각 스레드가 빠른 객체 할당을 위해 힙의 일부분을 로컬로 사용.
- **Promotion Failure, Fragmentation**: Old 영역의 단편화로 인해 OOM 발생 가능(tenuring 및 힙 구성에 영향).

---

## 12. 결론 (요약)
- JVM은 복잡한 런타임 메모리 구조(Heap, Method Area/Metaspace, Stack 등)와 다양한 GC/실행 엔진을 통해 안전하고 효율적으로 자바 프로그램을 실행한다.
- 성능 문제나 메모리 문제를 해결하려면 **어느 메모리 영역에서 무엇이 문제인지**(Heap vs Metaspace vs Stack)를 정확히 진단하는 것이 우선이며, 적절한 GC 설정·히프 튜닝·코드 최적화(객체 생성 패턴 등)를 병행해야 한다.
- 진단 툴(jmap/jstack/jstat/jcmd/VisualVM/JFR) 및 GC 로그를 활용해 근본 원인을 찾는 습관을 들이자.
