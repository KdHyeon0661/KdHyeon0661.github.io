---
layout: post
title: Spring - 스프링 클라우드 개요
date: 2025-10-21 15:25:23 +0900
category: Spring
---
# 스프링 클라우드 개요 — Config·디스커버리·게이트웨이·보안·토글·릴리즈(Blue/Green/Canary)

> 목표: **Spring Cloud** 핵심 컴포넌트(분산 설정, 서비스 디스커버리, API 게이트웨이)를 실전 예제와 함께 정리하고, **게이트웨이 보안 패턴**, **분산 설정/피처 토글**, **배포 전략(Blue/Green/Canary)**을 운영 시나리오로 연결한다.
> 기준: Spring Boot 3.3+, Spring Cloud 2024.x(“Leyton”) 계열, Java 21.

---

## A. 분산 설정(Spring Cloud Config) — 중앙화/핫 리프레시

### A-1. Config Server (Git 백엔드)

**의존성**
```kotlin
// config-server/build.gradle.kts
plugins { id("org.springframework.boot") version "3.3.3"; id("io.spring.dependency-management") version "1.1.6" }
dependencies { implementation("org.springframework.cloud:spring-cloud-config-server") }
```

**부트스트랩**
```java
@EnableConfigServer
@SpringBootApplication
public class ConfigServerApp {
  public static void main(String[] args){ SpringApplication.run(ConfigServerApp.class, args); }
}
```

**설정**
```yaml
# config-server/src/main/resources/application.yml

server.port: 8888
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/acme/config-repo   # 사내용 저장소 권장
          search-paths: '{application}'              # /{app}/application[-profile].yml
          clone-on-start: true
management.endpoints.web.exposure.include: health,info
```

**구성 저장소 구조(예)**
```
config-repo/
├─ acme-gateway/
│  ├─ application.yml
│  ├─ application-prod.yml
├─ acme-order/
│  ├─ application.yml
│  ├─ application-dev.yml
└─ shared/
   └─ messages_ko.properties
```

### A-2. 클라이언트(App)에서 가져오기 (Spring Boot 3 방식)

`bootstrap.yml` 대신 **Config Import** 사용:
```yaml
# apps/acme-order/src/main/resources/application.yml

spring:
  application.name: acme-order
  config.import: "optional:configserver:http://config-server:8888"
```

### A-3. 동적 리프레시(핫 업데이트)

- **@RefreshScope**: 해당 빈의 `Environment` 변경을 반영.
- **Spring Cloud Bus**(RabbitMQ/Kafka)로 **모든 인스턴스**에 갱신 신호 브로드캐스트.

```kotlin
// 클라이언트 의존성
implementation("org.springframework.cloud:spring-cloud-starter-bus-amqp") // 또는 -bus-kafka
```

```yaml
# 클라이언트

management.endpoints.web.exposure.include: health,info,refresh,busrefresh
```

```java
@RefreshScope
@ConfigurationProperties(prefix = "banner")
public record BannerProps(String title, String color) {}
```

> 운영 팁
> - **민감정보는 Config Server에 두지 말 것**(Vault/Secret Manager 사용).
> - 일부 속성(예: 데이터소스 풀 크기)은 런타임 변경 시 **연결 재생성**이 필요 → 무중단을 위해 **롤링 배포** 병행.

---

## B. 서비스 디스커버리 — Eureka / Consul

### B-1. Eureka (Self-Hosted, 클라이언트 사이드 로드밸런싱)

**서버**
```kotlin
// eureka-server/build.gradle.kts
implementation("org.springframework.cloud:spring-cloud-starter-netflix-eureka-server")
```
```java
@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApp { public static void main(String[] a){ SpringApplication.run(EurekaServerApp.class, a); } }
```
```yaml
server.port: 8761
eureka:
  client:
    register-with-eureka: false
    fetch-registry: false
```

**클라이언트(서비스)**
```kotlin
implementation("org.springframework.cloud:spring-cloud-starter-netflix-eureka-client")
implementation("org.springframework.cloud:spring-cloud-starter-loadbalancer") // 필수
```
```yaml
spring.application.name: acme-order
eureka.client.service-url.defaultZone: http://eureka:8761/eureka
```

**LoadBalancer 사용**
```java
@Service
@RequiredArgsConstructor
class UpstreamClient {
  private final RestClient.Builder builder;

  public String callInventory() {
    RestClient lbClient = builder.baseUrl("http://acme-inventory") // 논리명
      .requestFactory(LoadBalancerClientRequestFactory::new)        // 또는 Boot 자동 구성 사용
      .build();
    return lbClient.get().retrieve().body(String.class);
  }
}
```

> 포인트
> - Ribbon은 폐기 → **Spring Cloud LoadBalancer** 사용.
> - Eureka 메타데이터에 **zone/weight**를 넣어 트래픽 분산 정책 확장 가능.

### B-2. Consul (KV + Health 체크 + DNS)

```kotlin
implementation("org.springframework.cloud:spring-cloud-starter-consul-discovery")
implementation("org.springframework.cloud:spring-cloud-starter-consul-config")
```
```yaml
spring:
  cloud:
    consul:
      host: consul
      port: 8500
      discovery:
        register: true
        health-check-path: /actuator/health
    config:
      prefix: config
      default-context: application
      format: yaml
```
- **Consul KV**로 설정도 중앙화 가능(간단 과제엔 Config Server 없이 Consul만으로도 OK).
- 서비스 메시(Istio/Linkerd)를 쓰면 **디스커버리/로드밸런서**를 메시에 위임하기도 한다.

---

## C. API 게이트웨이 — Spring Cloud Gateway(리액티브)

### C-1. 핵심 개념

- **라우트(Route)** = **조건(Predicate)** + **필터(Filter)** + **목적지(URI)**.
- **필터 체인**으로 **인증/인가/로깅/레이트리밋/헤더가공** 구현.
- **리액티브(Netty)** 기반 → 경량 고성능.

**의존성**
```kotlin
implementation("org.springframework.cloud:spring-cloud-starter-gateway")
implementation("org.springframework.boot:spring-boot-starter-actuator")
implementation("org.springframework.boot:spring-boot-starter-oauth2-resource-server")
implementation("org.springframework.data:spring-data-redis-reactive") // 레이트리밋 등
```

### C-2. 라우트 예시(YAML)

```yaml
spring:
  cloud:
    gateway:
      default-filters:
        - RemoveRequestHeader=Cookie
        - DedupeResponseHeader=Access-Control-Allow-Origin Access-Control-Allow-Credentials
      routes:
        - id: order
          uri: http://acme-order
          predicates:
            - Path=/api/orders/**
          filters:
            - StripPrefix=1
            - RequestRateLimiter={
                "redis-rate-limiter.replenishRate": 50,
                "redis-rate-limiter.burstCapacity": 100,
                "key-resolver": "#{@ipKeyResolver}"
              }
            - TokenRelay
        - id: inventory-canary
          uri: http://acme-inventory
          predicates:
            - Path=/api/inventory/**
            - Header=X-Canary, true
          filters:
            - StripPrefix=1
        - id: inventory-stable
          uri: http://acme-inventory
          predicates:
            - Path=/api/inventory/**
          filters:
            - StripPrefix=1
            - RewritePath=/api/inventory/(?<path>.*), /$\\{path}
```

**KeyResolver (IP 기준 레이트리밋)**
```java
@Bean
KeyResolver ipKeyResolver() {
  return exchange -> Mono.just(exchange.getRequest().getHeaders().getFirst("X-Forwarded-For"))
      .switchIfEmpty(Mono.justOrEmpty(exchange.getRequest().getRemoteAddress())
      .map(addr -> addr.getAddress().getHostAddress()))
      .defaultIfEmpty("unknown");
}
```

### C-3. 보안: JWT/OAuth2, CORS, 헤더 위임(TokenRelay)

**리소스 서버(JWT)**
```java
@EnableWebFluxSecurity
@Configuration
class SecurityConfig {
  @Bean
  SecurityWebFilterChain chain(ServerHttpSecurity http) {
    return http
      .csrf(ServerHttpSecurity.CsrfSpec::disable)
      .authorizeExchange(ex -> ex
        .pathMatchers("/_health", "/actuator/**").permitAll()
        .pathMatchers(HttpMethod.OPTIONS, "/**").permitAll() // CORS 프리플라이트
        .anyExchange().authenticated())
      .oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::jwt)
      .build();
  }
}
```

**Token Relay**
- 게이트웨이가 **인바운드 토큰**을 **다운스트림 서비스**로 전달(Authorization 헤더 유지).
- 다운스트림도 `spring-boot-starter-oauth2-resource-server`로 검증.

**CORS (게이트웨이 레벨)**
```yaml
spring:
  cloud:
    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOrigins: "https://app.example.com"
            allowedMethods: [GET,POST,PUT,DELETE,OPTIONS]
            allowedHeaders: "*"
            allowCredentials: true
            maxAge: 3600
```

### C-4. 감시/제어: 요청 로깅, GEO/IP, WAF 연계

- **Netty access log** 또는 **필터**로 요약 로그(메서드, 경로, 상태, ms, traceId).
- **GeoIP**/IP 차단 리스트 필터 적용.
- 고급 보안은 **WAF/Cloud Armor/WAF Rules**로 전단에서 차단 → 게이트웨이는 **AuthN/Z·라우팅** 집중.

---

## D. API 게이트웨이 패턴(모음)

1) **BFF(Backends for Frontends)**: 모바일/웹 별 라우트·조합 최적화.
2) **Aggregator**: 여러 서비스 호출을 게이트웨이에서 팬아웃/머지(간단 집계, 과도하면 “덤프 서비스”가 됨 → 경계 주의).
3) **Strangler Fig**: 레거시 점진 교체. 경로/도메인 단위로 신·구 백엔드를 **게이트웨이에서 스위칭**.
4) **Rate Limit & Throttle**: 사용자·테넌트·API 키 기준 제한(위 KeyResolver 변경).
5) **Blue/Green/Canary 라우팅**: 헤더/쿠키/가중치 기반(아래 F 섹션).
6) **Request/Response Transform**: 헤더/경로/바디 변환(간단 변환까지만, 무거운 변환은 서비스로).

---

## E. 분산 설정·피처 토글 — 깃/컨피그서버·토글 프레임워크

### E-1. Config Server로 기능 토글(경량)

```yaml
# config-repo/acme-order/application.yml

features:
  checkout-v2: false
  image-webp: true
```
```java
@RefreshScope
@ConfigurationProperties(prefix="features")
public record FeatureFlags(boolean checkoutV2, boolean imageWebp) {}
```
서비스에서:
```java
@Service
@RequiredArgsConstructor
class CheckoutService {
  private final FeatureFlags flags;
  public Receipt checkout(...) {
    if (flags.checkoutV2()) return v2(...);
    return v1(...);
  }
}
```
> **장점**: 간단/중앙화. **단점**: 사용자·세션 단위/실험군 A/B는 어려움.

### E-2. Togglz/Unleash(강화)

```kotlin
implementation("org.togglz:togglz-spring-boot-starter:3.4.0")
```
```java
@FeatureEnum
public enum F { CHECKOUT_V2, IMAGE_WEBP }
```
```java
if (FeatureContext.getFeature(F.CHECKOUT_V2).isActive()) { /* v2 */ }
```
- 전략: **Gradual rollout**(퍼센트), 사용자 속성 기반, **고객 그룹**.

### E-3. K8s ConfigMap/Secret를 이용한 분산 설정

- Boot 3에서는 `spring.config.import=kubernetes:`로 K8s ConfigMap/Secret을 PropertySource로 가져오는 **Spring Cloud Kubernetes** 사용 가능.
- 단순 환경 이동·빠른 롤백에 유리(배포와 함께 교체).

---

## F. 릴리즈 전략 — Blue/Green/Canary(게이트웨이·클라이언트·플랫폼)

### F-1. Blue/Green (게이트웨이 경로/헤더 스위치)

두 버전(Blue=안정, Green=신규)을 **동시에 띄우고** 트래픽을 **일괄 스위치**.

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: order-blue
          uri: http://acme-order-blue
          predicates: [ Path=/api/orders/** ]
          filters: [ StripPrefix=1 ]
        - id: order-green
          uri: http://acme-order-green
          predicates:
            - Path=/api/orders/**
            - Header=X-Release, green    # 운영자/정합성 검증 동안 소수만 전송
          filters: [ StripPrefix=1 ]
```
- 검증 완료 시 **DNS/게이트웨이 라우트**를 Green으로 스위치 → Blue는 대기(롤백 쉬움).

### F-2. Canary (가중치/사용자 일부)

**가중치 라우팅**(Spring Cloud Gateway 플러그인 또는 서비스 메시/Istio 권장):
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: inv-v1
          uri: http://inventory-v1
          predicates: [ Path=/api/inventory/**, Weight=inventory, 95 ]
        - id: inv-v2
          uri: http://inventory-v2
          predicates: [ Path=/api/inventory/**, Weight=inventory, 5 ]
```
- 5% → 25% → 50% → 100% 단계적 증가.
- **Headers 기반(베타 사용자)** canary도 병행(`Header=X-Beta, true`).

### F-3. Client-side Canary (LoadBalancer + 인스턴스 메타)

- 인스턴스에 `metadata.canary=true` 부여, **Hint**로 LB를 선택:
```java
@Service
@RequiredArgsConstructor
class CanaryCaller {
  private final LoadBalancerClientFactory f;
  public Response call(boolean canary) {
    var lb = f.getInstance("acme-inventory", ReactorLoadBalancer.class);
    var req = Request.create(new DefaultRequestContext(canary ? "canary" : "stable"));
    // 커스텀 ServiceInstanceListSupplier가 힌트에 맞는 인스턴스만 선택
    return doCall(lb.choose(req));
  }
}
```

### F-4. 플랫폼 측(쿠버네티스/서비스 메시)

- **K8s Deployments** 2개(blue/green) + **Service** 단일.
- **Istio/NGINX Ingress**로 **가중치/헤더** 기반 라우팅.
- **Argo Rollouts**로 Canary 단계/실험/자동 롤백.

> 운영 체크
> - **DB 마이그**는 **앞/뒤 호환 스키마**(expand → contract)로 배포와 분리.
> - Canary 도중 **메트릭 게이트**(에러율, p95 latency) 도달 시 자동 롤백.
> - 게이트웨이·서버 모두 **traceId**로 상관관계 추적.

---

## G. 엔드투엔드 보안 패턴(게이트웨이 중심)

1) **인증**: 게이트웨이에서 **OIDC 로그인**(Auth Code) → 프런트엔드 세션/토큰, 백엔드용 **Token Relay**.
2) **인가**: 경로/메서드/스코프 기반(`hasAuthority('SCOPE_order:read')`).
3) **테넌시**: 헤더로 **tenant-id** 전파 + 다운스트림에서 검증, 데이터 분리.
4) **레이트 리밋**: IP/사용자/테넌트별 키. Redis 단일 클러스터로 중앙 관리.
5) **mTLS(내부 트래픽)**: 게이트웨이↔서비스, 서비스↔서비스에 상호 TLS(서비스 메시 권장).
6) **CSP/보안 헤더**: 정적 리소스/다운로드 응답에 일괄 삽입.
7) **DLP/PII 마스킹**: 게이트웨이 로깅/미러링 시 민감 필드 제거.

---

## H. 관측성 — 메트릭/로그/트레이싱(게이트웨이·서비스)

- **게이트웨이**: route별 **RPS/에러율/지연**(p50/p95/p99), 레이트리밋 거부수, 요청 크기.
- **서비스**: **LoadBalancer 선택 결과**, 인스턴스별 성공률/지연.
- **추적**: 게이트웨이에서 **traceparent(B3/W3C)** 헤더 생성/전파, 다운스트림에서 MDC에 traceId 넣어 로그 상관.
- **릴리즈 지표**: Canary 중 **대조군(v1) vs 실험군(v2)** 지연/에러 비교 대시보드.

---

## I. 실전 템플릿 — “게이트웨이·디스커버리·컨피그·보안” 1장 요약

1) **Config Server**에서 공통 설정/토글 관리 → **@RefreshScope** + **Bus**로 핫 리프레시.
2) **Eureka/Consul**로 서비스 등록, **Spring Cloud LoadBalancer**로 클라이언트 측 분산.
3) **Gateway**로 라우팅/보안/레이트리밋/토큰 릴레이/CORS 표준화.
4) **JWT/OAuth2 리소스 서버**로 다운스트림 인증·인가 일관화.
5) **Feature Toggle**은 Config 토글(간단) + Togglz/Unleash(고급).
6) **릴리즈 전략**: Blue/Green(스위치 빠름) + Canary(가중치/헤더).
7) **관측성**: route/서비스별 메트릭과 분산 추적으로 “문제 지점”을 즉시 핀포인트.

---

## J. 트러블슈팅·운영 체크리스트

- [ ] Config Import 순서/권한 오류? → `config.import`를 **최상단**에, 클라이언트 네트워크/인증 확인.
- [ ] 리프레시 후 빈 재생성 실패? → **@RefreshScope 범위** 점검, 순환참조 피하기.
- [ ] Eureka 등록 누락/헬스 체크 실패? → `management.endpoint.health.probes.enabled=true`, `eureka.instance.prefer-ip-address`.
- [ ] Gateway 502/504? → 상류 타임아웃/커넥션 풀/`connect-timeout`/`response-timeout` 설정.
- [ ] TokenRelay 미전달? → 인바운드에 `Authorization: Bearer ...` 존재 확인, WebFlux Security 체인 순서.
- [ ] 레이트리밋 키 폭주/버그? → KeyResolver 로그·샘플링, Redis TTL/메모리 모니터.
- [ ] Canary 편향? → LB 가중치/헤더 조건 겹침 점검, 세션 고정(Sticky) 여부 확인.
- [ ] 롤백 빠르게? → Blue 유지·DB 스키마 **양방향 호환** 유지, 핫 토글로 기능 차단.

---

## K. 한 페이지 요약

- **분산 설정**은 Config Server(or Consul/K8s)로 중앙화하고 **@RefreshScope + Bus**로 빠르게 반영한다.
- **디스커버리 + LoadBalancer**로 서비스 주소 의존을 제거하고, **Gateway**에서 라우팅/보안/제한을 일관 처리한다.
- **API 게이트웨이 보안**은 JWT/OIDC, 레이트리밋, CORS, mTLS를 조합해 **제로 트러스트**에 가깝게 설계한다.
- **피처 토글**로 기능 플래그를 제어하고, **Blue/Green/Canary**로 안전하게 배포한다.
- 전 구간에 **관측성(메트릭/로그/트레이싱)**을 심어 바뀌는 설정·배포가 **즉시 보이는 시스템**을 만든다.
