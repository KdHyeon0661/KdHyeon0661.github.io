---
layout: post
title: 컴퓨터시스템 - 파일 읽기와 쓰기
date: 2025-08-30 23:20:23 +0900
category: 컴퓨터시스템
---
# 파일 **읽기와 쓰기** — UNIX/Linux 심층 가이드

> 포커스: `read`/`write`의 기본부터 **부분 읽기/쓰기(Short I/O)**, **블로킹 vs 비차단**,  
> **pread/pwrite(오프셋 고정)**, **readv/writev(Scatter/Gather)**, **mmap**과의 비교,  
> **내구성(fsync)**, **성능(버퍼링, readahead, O_DIRECT)**, **경쟁·원자성**,  
> **안전한 패턴과 견고한 래퍼 함수**까지.

---

## 0) 큰 그림: FD ↔ 커널 ↔ 저장장치

- 애플리케이션은 **파일 디스크립터(FD)** 로 `read`/`write`를 호출합니다.
- 커널은 **페이지 캐시**와 **파일 오프셋**을 관리하며, 필요 시 디스크 I/O를 발행합니다.
- **반드시 기억할 것**: `read`/`write`는 **요청한 바이트 수만큼 처리**하지 **않을 수 있습니다** → 루프/재시도 필요.

---

## 1) 기본 API와 반환값 의미

### 1.1 `read`
```c
#include <unistd.h>
ssize_t n = read(int fd, void *buf, size_t count);
```
- **반환값**
  - `> 0`: 읽은 바이트 수(요청보다 **작을 수 있음**)
  - `0`: EOF(일반 파일), 반대편 종료(파이프/소켓)
  - `-1`: 오류 (`errno` 확인; `EINTR`, `EAGAIN` 등)

### 1.2 `write`
```c
#include <unistd.h>
ssize_t n = write(int fd, const void *buf, size_t count);
```
- **반환값**
  - `>= 0`: 실제로 기록한 바이트 수(요청보다 **작을 수 있음**)
  - `-1`: 오류 (`EINTR`, `EAGAIN`, `ENOSPC`, `EDQUOT` 등)

> **Short I/O(부분 I/O)** 는 정상 상황입니다. 네트워크/파이프/비차단 FD는 물론, 파일도 상황에 따라 부분 쓰기가 발생할 수 있습니다.

---

## 2) 견고한 래퍼: “정확히 N바이트 읽기/쓰기”

```c
// N바이트를 채우거나(EOF면 덜 채울 수도 있음) 오류 시 -1
ssize_t readn(int fd, void *buf, size_t n) {
    size_t left = n; char *p = buf;
    while (left > 0) {
        ssize_t r = read(fd, p, left);
        if (r > 0) { left -= r; p += r; }
        else if (r == 0) break;                    // EOF
        else if (errno == EINTR) continue;         // 시그널 → 재시도
        else if (errno == EAGAIN || errno == EWOULDBLOCK) break; // 비차단
        else return -1;
    }
    return n - left;
}

ssize_t writen(int fd, const void *buf, size_t n) {
    size_t left = n; const char *p = buf;
    while (left > 0) {
        ssize_t w = write(fd, p, left);
        if (w > 0) { left -= w; p += w; }
        else if (w < 0 && errno == EINTR) continue;
        else if (w < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
        else return -1;
    }
    return n;
}
```

---

## 3) 파일 오프셋과 위치 지정 I/O

### 3.1 암묵적 오프셋
- 일반 `read`/`write`는 커널이 유지하는 **파일 오프셋**을 사용, 호출 후 자동 증가.

### 3.2 위치 지정 I/O — `pread`/`pwrite`
```c
#include <unistd.h>
ssize_t pread (int fd, void *buf, size_t n, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t n, off_t offset);
```
- **장점**: **오프셋을 바꾸지 않음** → 다중 스레드/프로세스가 같은 FD로 동시에 I/O 가능.
- **랜덤 접근**(DB/스토리지 엔진)에서 필수 도구.

> 대용량 파일을 다룰 때는 64비트 오프셋을 보장하도록 `-D_FILE_OFFSET_BITS=64` 컴파일 플래그를 권장.

---

## 4) Scatter/Gather I/O — `readv`/`writev`

여러 버퍼를 한 번에 읽고/쓰는 **벡터화 I/O**:

```c
#include <sys/uio.h>
ssize_t readv (int fd, struct iovec *iov, int iovcnt);
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
```

예: 헤더+바디를 한 번에 기록
```c
struct iovec iov[2] = {
    { .iov_base = header, .iov_len = hlen },
    { .iov_base = body,   .iov_len = blen },
};
ssize_t n = writev(fd, iov, 2);
```

---

## 5) 블로킹 vs 비차단 I/O

- `O_NONBLOCK` 플래그로 **바로 반환**하도록 만들 수 있음.
- 읽기/쓰기 호출 시 데이터가 없거나 버퍼가 가득 차면 `EAGAIN/EWOULDBLOCK`.
- 일반적으로 **`select`/`poll`/`epoll`** 과 조합해 준비된 FD만 I/O 수행.

```c
int fd = fcntl(sock, F_GETFL);
fcntl(sock, F_SETFL, fd | O_NONBLOCK);
```

---

## 6) 텍스트 vs 바이너리, 표준 I/O와의 관계

### 6.1 UNIX는 텍스트/바이너리 구분 없음
- 개행 변환 없음(Windows는 다름). 인코딩/개행 규칙은 **응용 레벨** 문제.

### 6.2 `stdio`(fread/fwrite/printf)와 혼용 주의
- `FILE*` 버퍼링과 `write`를 **같은 FD에서 섞어 쓰면** 순서가 엉킬 수 있습니다.
- 한쪽만 쓰거나, 반드시 `fflush(fp); fsync(fileno(fp));` 로 동기화.

### 6.3 버퍼링 제어
```c
setvbuf(fp, NULL, _IONBF/*무버퍼*/|_IOLBF/*라인*/|_IOFBF/*풀*/, 0);
```

---

## 7) 내구성(영속성) — `fsync`/`fdatasync`/원자적 갱신

- `write` 성공 ≠ **디스크에 안전히 기록됨**. 전원 장애 시 유실 가능.
- **안전 갱신 패턴**:
  1) 임시 파일에 모두 쓰기 → `fsync(tmpfd)`  
  2) `rename(tmp, dst)` (**동일 파일시스템에서 원자적**)  
  3) `fsync(dirfd)` 로 디렉터리 엔트리까지 보존.
- `O_SYNC/O_DSYNC`는 각 write를 동기화하지만 성능 비용 큼. 보통은 **버스트 쓰기 + fsync**가 효율적.
- NFS/네트워크 FS에서는 동기화 의미가 다를 수 있으니 주의.

---

## 8) 경쟁·원자성·잠금

- **정규 파일**에 대한 쓰기는 **원자성이 보장되지 않습니다**(표준 관점).  
  `O_APPEND`는 **오프셋 갱신을 원자적으로** 보장하지만, 다중 작성자 간 **레코드 경계**를 보장하진 않습니다.  
  → **로그**는 “한 줄을 한 번의 `write`”로 기록 + 필요 시 **파일 잠금(Advisory Lock)**:
  - `flock(fd, LOCK_EX)` 또는 `fcntl(fd, F_SETLK)`.

- **파이프/소켓**: `PIPE_BUF`(보통 4096) 이하 쓰기는 **원자적**으로 기록.

---

## 9) 성능: 버퍼 크기, readahead, Direct I/O

### 9.1 버퍼 크기
- 4KB~1MB 사이에서 워크로드/FS에 맞춰 실험. 너무 작으면 syscall 오버헤드, 너무 크면 페이지 캐시 오염.

### 9.2 예상 접근 힌트 — `posix_fadvise`
```c
posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL); // 순차
posix_fadvise(fd, 0, 0, POSIX_FADV_RANDOM);     // 랜덤
posix_fadvise(fd, off, len, POSIX_FADV_DONTNEED); // 캐시에서 버리기
```

### 9.3 Direct I/O — `O_DIRECT`
- 페이지 캐시 우회(일부 DB/스토리지 엔진). **정렬 제약**:
  - 버퍼 **주소/크기/오프셋**이 디스크 블록 크기(보통 512B/4KB)로 정렬되어야 함.
```c
void *buf; posix_memalign(&buf, 4096, 4096); // 4KB 정렬 버퍼
int fd = open("file", O_RDONLY|O_DIRECT);
ssize_t n = pread(fd, buf, 4096, 0);
```

---

## 10) 고급 복사 경로: 커널-내 복사

- **`sendfile`**: 파일 → 소켓 (제로카피)
- **`splice`/`tee`**: 파이프를 경유한 커널 내 데이터 전달
- **`copy_file_range`**: 파일 ↔ 파일 직접 복사(오프로드/클론 최적화 가능)

```c
#include <sys/sendfile.h>
sendfile(sock, filefd, &offset, len);
```

---

## 11) `mmap` vs `read/write`

| 항목 | `read/write` | `mmap` |
|---|---|---|
| 접근 모델 | 명시적 복사/시스템콜 | **페이지 폴트 기반** 메모리 접근 |
| 장점 | 제어·이식성·단순 | 임의 접근, 공유, 코드 간결 |
| 단점 | syscall 오버헤드 | SIGBUS/권한 주의, TLB/페이지 폴트 비용 |
| 쓰기 동기화 | `write`/`fsync` | dirty page → `msync`/`munmap` |

- 대용량 랜덤 읽기는 `mmap`이 편하지만, **오류 처리/동기화**가 더 까다로울 수 있습니다.

---

## 12) 라인/텍스트 I/O 팁

- 긴 줄을 안전하게: **POSIX `getline`** 사용
```c
#include <stdio.h>
ssize_t len; char *line = NULL; size_t cap = 0;
while ((len = getline(&line, &cap, fp)) != -1) { /* ... */ }
free(line);
```
- 인코딩/유니코드는 라이브러리(ICU 등)로 처리. UNIX는 개행/인코딩 자동 변환을 하지 않습니다.

---

## 13) 안전한 읽기/쓰기 실전 패턴

### 13.1 파일 전체 읽기(문자열)
```c
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

char* slurp(const char *path, size_t *out_len) {
    int fd = open(path, O_RDONLY | O_CLOEXEC);
    if (fd < 0) return NULL;
    struct stat st; if (fstat(fd, &st) < 0) { close(fd); return NULL; }
    size_t n = st.st_size;
    char *buf = malloc(n + 1);
    if (!buf) { close(fd); return NULL; }
    ssize_t r = readn(fd, buf, n);
    if (r < 0) { free(buf); close(fd); return NULL; }
    buf[r] = '\0';
    if (out_len) *out_len = r;
    close(fd);
    return buf;
}
```

### 13.2 안전한 파일 덮어쓰기(원자적 교체 + 내구성)
```c
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

int replace_atomic(const char *dir, const char *tmp, const char *dst,
                   const void *data, size_t n)
{
    int dfd = open(dir, O_RDONLY | O_DIRECTORY | O_CLOEXEC);
    if (dfd < 0) return -1;

    int tfd = openat(dfd, tmp, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 0644);
    if (tfd < 0) { close(dfd); return -1; }

    if (writen(tfd, data, n) != (ssize_t)n) { close(tfd); close(dfd); return -1; }
    if (fsync(tfd) < 0) { close(tfd); close(dfd); return -1; }
    if (close(tfd) < 0) { close(dfd); return -1; }

    if (renameat(dfd, tmp, dfd, dst) < 0) { close(dfd); return -1; }
    if (fsync(dfd) < 0) { close(dfd); return -1; }
    return close(dfd);
}
```

### 13.3 다중 스레드에서 안전한 랜덤 I/O
- 하나의 FD를 공유하되 **`pread`/`pwrite`** 로 각자 오프셋을 사용.
- 또는 스레드별 FD 복제(`open`/`dup`) 후 독립 사용.

---

## 14) 오류 처리 모범 사례

- 모든 I/O는 **반환값 검사** + `errno` 로 분기.
- `EINTR` 는 **재시도**, `EAGAIN/EWOULDBLOCK` 은 준비 대기 후 재시도.
- `write` 는 **부분 쓰기**를 루프 처리.  
- `close` 반환도 확인(지연된 쓰기 오류가 여기서 보고될 수 있음).  
- 경로 보안: 읽기/쓰기 대상이 외부 입력이면 **`openat` + `O_NOFOLLOW`** 로 심링크 레이스 방지.

---

## 15) 플랫폼/파일시스템 고려

- **대용량 파일**: 64비트 오프셋 활성화(`-D_FILE_OFFSET_BITS=64`).
- **네트워크 FS**: 캐시 일관성/내구성 의미가 로컬 FS와 다를 수 있음.
- **저널링 FS**: `rename` 원자성은 보장되지만, **디렉터리 `fsync`** 까지 해야 전원 장애에도 안전.

---

## 16) 체크리스트

- [ ] 부분 읽기/쓰기 처리(루프)  
- [ ] 비차단이면 `EAGAIN` 경로 준비 (`select/poll/epoll`)  
- [ ] 다중 작성자: `O_APPEND` + “한 레코드=한 번의 write” 또는 잠금  
- [ ] 내구성 필요: `fsync(파일)` + `fsync(디렉터리)`  
- [ ] 랜덤 I/O/동시성: `pread/pwrite`  
- [ ] 성능: 적절한 버퍼, `posix_fadvise`, 필요 시 `O_DIRECT`(정렬 충족)  
- [ ] `stdio`와 혼용 시 명확한 동기화(또는 한쪽만 사용)

---

## 17) 한 줄 결론
파일 읽기/쓰기는 **부분 I/O와 오프셋, 캐시/동기화, 경쟁/원자성**을 이해하면 견고해집니다.  
안전한 래퍼와 내구성 패턴(임시→`fsync`→`rename`)을 툴킷으로 삼아, 워크로드에 맞춘 버퍼링/힌트로 **성능과 신뢰성**을 동시에 잡으세요.