---
layout: post
title: 파이썬 - 내장함수
date: 2024-08-10 19:20:23 +0900
category: Python
---
# 파이썬 내장 함수

## 0. 입·출력 (I/O)

### `print(*objects, sep=' ', end='\n', file=None, flush=False)`
```python
print("A", "B", 10)                         # A B 10
print("A", "B", sep=" | ", end=".\n")       # A | B.
with open("out.log", "a", encoding="utf-8") as f:
    print("log line", file=f, flush=True)   # 파일로 출력 + 즉시 flush
```
- **팁**: 대량 로그는 `flush=True` 남발 시 성능 저하. 호출 간격/버퍼 정책 고려.

### `input(prompt=None)`  (항상 **문자열** 반환)
```python
age = int(input("나이? "))     # 공백/개행 제외한 문자열 → int 변환
print(type(age))               # <class 'int'>
```

### `format(value, format_spec)`  (내장 `format()` vs 문자열 `.format()` vs f-string)
```python
n = 1234.567
print(format(n, ",.2f"))       # 1,234.57   (형식 미니언어)
print("{:,.2f}".format(n))     # 동일
print(f"{n:,.2f}")             # 동일
```
- **형식 미니언어**: 정렬 `:<, :>, :^`, 채움문자, 부호 `+`/`-`, 진법 `b/o/x`, 퍼센트 `%`, 날짜/시간은 `datetime.strftime` 사용.
- **권장**: 새 코드에선 **f-string**이 가장 간결하고 빠릅니다.

---

## 1. 반복/순회 · 이터러블

### `len(x)`
```python
print(len("hello"))        # 5
print(len([1,2,3]))        # 3
```
- 사용자 정의 객체는 `__len__`로 길이를 구현.

### `range(stop)` / `range(start, stop[, step])`  (메모리 친화적 시퀀스)
```python
for i in range(3):               # 0,1,2
    print(i)
print(list(range(1, 10, 3)))     # [1, 4, 7]
```
- 실제 리스트가 아닌 **게으른 시퀀스**(start/step/len·색인 가능).

### `enumerate(iterable, start=0)`
```python
colors = ["red", "blue"]
for idx, color in enumerate(colors, start=1):
    print(idx, color)
# 1 red
# 2 blue
```

### `zip(*iterables)`  (가장 짧은 이터러블까지만)
```python
names  = ["Tom", "Jane", "Han"]
scores = [90, 85]
for n, s in zip(names, scores):
    print(n, s)  # Tom 90 / Jane 85
```
- 길이 맞추려면: `itertools.zip_longest(iterables, fillvalue=...)` 사용.

### `reversed(x)`
```python
for ch in reversed("abc"):
    print(ch)  # c b a
```
- **조건**: 시퀀스(길이/색인 가능) 또는 `__reversed__` 구현한 객체.

### `sorted(iterable, *, key=None, reverse=False)`  (항상 **새 리스트** 반환)
```python
nums = [3, 1, 2]
print(sorted(nums))                           # [1, 2, 3]
print(sorted(nums, reverse=True))             # [3, 2, 1]
words = ["hi", "hello", "a"]
print(sorted(words, key=len))                 # ['a', 'hi', 'hello']
```
- **안정 정렬(stable)**: 같은 키면 기존 순서 유지 → 다단 정렬 시 유용.
- **리스트 제자리 정렬**: `list.sort(key=..., reverse=...)` (반환값 `None`).

---

## 2. 수치 · 산술

### `sum(iterable, /, start=0)`
```python
nums = [1, 5, 3]
print(sum(nums))                 # 9
print(sum(nums, 10))             # 19 (초깃값 10부터 누적)
```
- **문자열 연결에는 사용 금지**: `sum(["a","b"], "")`는 느림 → `"".join(...)`.
- **부동소수 누적 오차**: 정밀이 중요하면 `math.fsum()` 사용.

### `max(iterable, *[, key])` / `min(...)`
```python
pairs = [{"n":"a","v":7}, {"n":"b","v":9}]
print(max(pairs, key=lambda x: x["v"]))  # {'n': 'b', 'v': 9}
```
- 빈 이터러블이면 `ValueError`. (Py3.10+ `default=...` 인자 지원 X → 직접 처리)

### `abs(x)` / `round(number, ndigits=0)`
```python
print(abs(-7))                    # 7
print(abs(3+4j))                  # 5.0 (복소수 크기)
print(round(3.14159, 2))          # 3.14
print(round(25, -1))              # 30 (십의 자리 반올림)
```
- **`round`는 “은행가 반올림”(ties to even)**: `round(2.5)=2`, `round(3.5)=4`.
- “항상 .5 올림”이 필요하면 `decimal`의 `ROUND_HALF_UP` 사용.

### `pow(base, exp[, mod])`
```python
print(pow(2, 10))                 # 1024
print(pow(2, 10, 1000))           # 24  (모듈러 거듭제곱, 매우 빠름)
```
- 큰 수 모듈러 연산은 `pow(a, b, m)`가 **가장 효율적**.

### `divmod(a, b)`  → `(a // b, a % b)`
```python
q, r = divmod(10, 3)
print(q, r)                       # 3 1
```
- 정수/부동소수 모두 지원(부동소수는 정밀 오차 감안).

---

## 3. 조건/논리/검사

### `all(iterable)` / `any(iterable)`
```python
print(all([True, True, False]))        # False
print(any(x > 10 for x in [1, 5, 11])) # True (게으른 평가: 11 발견 시 즉시 True)
```
- **게으름**: 제너레이터에서 **짧게** 끝나 성능상 유리.

### `bool(x)`  (진릿값 변환)
```python
print(bool(""))      # False
print(bool("0"))     # True  (빈 문자열만 False)
print(bool([]), bool({}), bool(0), bool(0.0), bool(None))  # 전부 False
```

### `isinstance(obj, classinfo)` / `callable(obj)`
```python
print(isinstance(5, int))                # True
print(isinstance(True, int))             # True (bool은 int의 서브클래스)
print(callable(print))                   # True
class C:
    def __call__(self): pass
print(callable(C()))                     # True (호출 가능한 객체)
```
- `isinstance(x, (A, B))` 처럼 **튜플**로 다중 검사 가능.

---

## 4. 타입 변환/진법/문자코드

### `int(x=0, base=10)` / `float(x)` / `str(x)`
```python
print(int("10"))                          # 10
print(int("ff", 16))                      # 255
print(float("inf"), float("nan"))         # inf nan
print(str(123))                           # '123'
```

### `chr(i)` / `ord(c)`  (유니코드)
```python
print(chr(65), chr(0xAC00))               # 'A' '가'
print(ord("A"), ord("가"))                # 65 44032
```

### `bin(x)` / `oct(x)` / `hex(x)`  (문자열 접두어 포함)
```python
print(bin(10), oct(10), hex(10))          # 0b1010 0o12 0xa
print(format(10, "b"), format(10, "x"))   # '1010' 'a' (접두어 없이)
```

---

## 5. 고차 함수 (맵/필터/정렬 키)

### `map(func, *iterables)` / `filter(func, iterable)`
```python
nums = ["1", "2", "3"]
print(list(map(int, nums)))               # [1, 2, 3]

even = filter(lambda x: x % 2 == 0, [1,2,3,4])
print(list(even))                         # [2, 4]
```
- **게으른 이터레이터** 반환. 한 번 소진하면 재사용 불가.
- 가독성/속도는 종종 **리스트 컴프리헨션**이 더 좋음:
  ```python
  [int(x) for x in nums]
  [x for x in nums if pred(x)]
  ```

### `sorted(..., key=...)` (키 함수로 정렬)
```python
words = ["hi", "hello", "a"]
print(sorted(words, key=len))              # ['a', 'hi', 'hello']
```

### `eval(expr[, globals[, locals]])`  **(보안 주의)**
```python
expr = "3 + 5 * (2 - 1)"
print(eval(expr))                          # 8
```
- **절대** 외부 입력 문자열을 `eval`에 넘기지 마세요(코드 실행 취약점).
- 안전한 리터럴 파싱은 `ast.literal_eval` 사용:
  ```python
  import ast
  print(ast.literal_eval("[1, 2, 3]"))    # [1, 2, 3]
  ```

### `id(obj)` / `hash(obj)`
```python
a = 100
print(id(a))                               # 구현 종속(주소 유사한 고유값)
print(hash("abc"))                         # 불변 객체에 해시 존재
```
- **주의**: `id`는 디버깅용. 해시는 불변성 기반(가변 객체는 기본 해시 없음).

---

## 6. 메타/리플렉션 · 네임스페이스

### `dir([object])`
```python
print(dir([1,2,3]))                       # 리스트가 가진 속성/메서드 나열
```

### `help(obj)`
```python
help(str)                                 # 문자열 타입 도움말
help(print)                               # 함수 시그니처/설명
```

### `globals()` / `locals()`  (딕셔너리)
```python
x = 10
print('x' in globals())                   # True (모듈 전역)
def foo():
    y = 20
    print('y' in locals())                # True (지역)
foo()
```
- **주의**: 함수 내부에서 `locals()` 수정은 **보장되지 않음**(읽기 전용처럼 사용).

### `getattr(obj, name[, default])` / `setattr(obj, name, value)` / `hasattr(obj, name)` / `delattr(obj, name)`
```python
class Person: name = "Tom"
p = Person()

print(getattr(p, "name"))                 # Tom
print(hasattr(p, "name"))                 # True
setattr(p, "age", 20)
print(p.age)                              # 20
delattr(p, "name")
print(hasattr(p, "name"))                 # False
```
- `getattr`은 **기본값**을 주면 속성 없을 때 예외 대신 기본값 반환.

---

## 7. 컬렉션/이터러블 생성·검사 관련 자주 쓰는 추가 빌트인

> (초안에는 없었지만 실무에서 매우 자주 써서 보강합니다.)

### `list()`, `tuple()`, `set()`, `dict()`  (타입 변환/생성)
```python
print(list("abc"))                         # ['a','b','c']
print(tuple([1,2]))                        # (1,2)
print(set([1,1,2]))                        # {1,2}
print(dict([("a",1), ("b",2)]))            # {'a':1,'b':2}
```

### `any()`/`all()` + 제너레이터 패턴
```python
nums = [1, 3, 5, 8, 9]
print(any(n % 2 == 0 for n in nums))       # True (8 발견 시 종료)
print(all(n < 10 for n in nums))           # True
```

### `sorted()`의 **다단 정렬** (안정 정렬 활용)
```python
people = [
  {"name":"Ann","age":30},
  {"name":"Bob","age":20},
  {"name":"Ace","age":20},
]
# 1차: name 오름차순 → 2차: age 오름차순 (안정 특성 이용)
people = sorted(people, key=lambda x: x["name"])
people = sorted(people, key=lambda x: x["age"])
print(people)
# age 20이면서 name이 Ace, Bob 순서 유지됨
```

---

## 8. 문자열 포맷 심화 (`format`, `str.format`, f-string)

```python
n = 255
print(f"{n:#x}")             # 0xff (접두어 포함 16진수)
print(f"{n:08b}")            # 11111111 (비트폭 8, 0채움)
print(f"{1234.5:,.1f}")      # 1,234.5 (천단위 콤마)
print(f"{-5:+d}")            # -5 (부호 표시)
print(f"{'hi':^8}")          # '  hi   ' (가운데 정렬)
```

**미니언어 핵심**
- 정렬/채움: `:<`, `:>`, `:^` + 채움문자
- 폭/정밀도: `:10.2f` → 폭 10, 소수 2자리
- 진법/형식: `:b`, `:o`, `:x`, `:X`, `:e`, `:g`, `%`

---

## 9. 디버깅 팁: `repr()` vs `str()`, `ascii()`
```python
s = "가\nA"
print(str(s))         # 사람이 읽기 좋은 형태 (개행 반영)
print(repr(s))        # 디버그 친화(이스케이프 표시): "'가\\nA'"
print(ascii("가"))    # 비ASCII는 \u 이스케이프: '\uac00'
```

---

## 10. 보안/안전 체크리스트

- **`eval` 금지**(외부 입력): `ast.literal_eval` 대체.
- 파일 경로/권한은 `pathlib`·`os.open(mode=0o600)` 등으로 안전하게.
- 해시 의존 로직은 **불변 객체**만 키로 사용(dict/set).
- **부동소수 반올림/합산** 정확성: `round`의 **은행가 반올림**, 합산은 `math.fsum`.

---

## 11. 고급: 내장 함수와 “게으른 평가” 성능 패턴

- `map`/`filter`/`zip`/`reversed`/`range`/`enumerate`는 **결과를 즉시 생성하지 않음**(이터레이터).
  → 대용량 스트림 파이프라인에서 **메모리 절약**.
- 필요 시 한 번만 소비됨에 주의: 이미 `list(...)`로 감싸 값화하면 재사용 가능.

```python
pairs = zip(range(10_000_000), range(10_000_000))
# 메모리 거의 증가 없이 순회 가능
count = 0
for a, b in pairs:
    if a + b > 10:
        break
    count += 1
print(count)
```

---

## 12. 종합 예제: 내장함수로 “CSV → 집계 → 정렬 → 보고서 문자열” 만들기

```python
from pathlib import Path

def parse_csv_line(line: str):
    # name,score 형태
    name, score = line.strip().split(",")
    return name, int(score)

# 1. 파일 읽기 + 2) 파싱(map) + 3) 필터(filter) + 4) 집계(sum) + 5) 정렬(sorted)
def build_report(csv_path: str) -> str:
    path = Path(csv_path)
    if not path.exists():
        return "파일 없음"

    with path.open("r", encoding="utf-8", newline="") as f:
        rows = map(parse_csv_line, f)                 # 게으른 파이프라인
        rows = filter(lambda r: r[1] >= 60, rows)     # 60점 미만 제외
        # 이름별 합산
        scores = {}
        for name, sc in rows:
            scores[name] = scores.get(name, 0) + sc

    # 6) 정렬: 합계 내림차순, 이름 오름차순(안정 정렬 2번 활용)
    items = list(scores.items())
    items = sorted(items, key=lambda x: x[0])         # 이름 오름차순 2차 기준
    items = sorted(items, key=lambda x: x[1], reverse=True)  # 합계 내림차순 1차 기준

    # 7) 문자열 생성: f-string/format 미니언어
    lines = [f"{'이름':<10}{'합계':>10}"]
    lines += [f"{name:<10}{total:>10,d}" for name, total in items]
    return "\n".join(lines)

print(build_report("scores.csv"))
```

---

## 13. “한눈에” 요약 테이블

| 범주 | 대표 내장함수 | 포인트 |
|---|---|---|
| 입출력 | `print`, `input`, `format` | `print`의 `sep/end/flush`, `format` 미니언어 |
| 순회 | `len`, `range`, `enumerate`, `zip`, `reversed`, `sorted` | **게으름/안정정렬/키 함수** |
| 수치 | `sum`, `max/min`, `abs`, `round`, `pow`, `divmod` | `round` 은행가 반올림, `pow(..., mod)` |
| 논리 | `all/any`, `bool`, `isinstance`, `callable` | 제너레이터 **짧게 끝남** |
| 변환 | `int/float/str`, `chr/ord`, `bin/oct/hex` | `int(x, base)`, `format(..., 'x')` |
| 메타 | `dir`, `help`, `globals/locals`, `getattr/setattr/hasattr/delattr` | 리플렉션과 네임스페이스 |
| 주의 | `eval` | 반드시 **금지**(외부 입력). 필요 시 `ast.literal_eval` |

---

## 14. 흔한 함정 · 모범 사례

1. **문자열 + `sum`**: 느림 → `''.join(iterable)` 사용.
2. `sorted`/`list.sort` 혼동: `sorted`는 **새 리스트 반환**, `list.sort`는 **제자리**(반환값 `None`).
3. `round` 기대 불일치: `.5`는 **짝수 쪽**으로. 다른 정책 필요하면 `decimal`.
4. `any/all`에 리스트로 감싸 불필요한 메모리 사용: `any(pred(x) for x in xs)` 형태 권장.
5. `eval` 남용 → 보안 취약. 꼭 필요하면 **신중한 globals/locals 샌드박스**, 그래도 가급적 `ast.literal_eval`.
6. `id`/`hash` 의미 오해: 구현 세부(주소 유사), 해시는 불변 키에만 의존.
7. `zip` 길이 불일치: 뒷부분 사라짐. 필요 시 `itertools.zip_longest`.
8. `isinstance(True, int)` → `True`: bool은 int의 서브클래스라는 사실 염두.
9. `reversed`는 이터레이터 반환. 필요 시 `list(reversed(seq))`로 실체화.
10. **성능**: 작은 변환은 컴프리헨션이 `map/filter`보다 가독성·속도에서 유리한 경우가 많음.

---

### 참고
- 각 내장 함수의 정확한 시그니처와 세부 동작은 `help(함수)`로 즉시 확인 가능:
```python
help(sorted)
help(format)
help(round)
```
