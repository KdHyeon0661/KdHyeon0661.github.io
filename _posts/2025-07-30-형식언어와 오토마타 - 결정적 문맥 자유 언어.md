---
layout: post
title: 형식언어와 오토마타 - 결정적 문맥 자유 언어
date: 2025-07-30 14:20:23 +0900
category: 형식언어와 오토마타
---
# 결정적 문맥-자유 언어(DCFL)의 문법(grammar)

> 핵심 메시지  
> - **DCFL = LR(1) 언어** (표준 끝표식 `$` 가정)  
> - 모든 **LL(k)** 언어 ⊆ **LR(1)** = **DCFL**  
> - “결정적”은 **파싱 과정에서 매 순간 선택이 유일**하다는 뜻(lookahead가 고정된 범위 내에서).

---

## 0) 표기 & 준비
- 입력 알파벳: $\Sigma$, 비터미널: $V$, 시작기호: $S$
- CFG: $G=(V,\Sigma,R,S)$, 생산(규칙) $A\to \alpha$
- 빈문자열: $\varepsilon$, 끝표식: `$`  
- FIRST/FOLLOW는 표준 정의를 따름

---

## 1) DCFL와 DPDA (언어 관점 복습)

### 1.1 DCFL 정의
언어 $L\subseteq \Sigma^*$ 가 **결정적 문맥-자유 언어(DCFL)** 라는 것은  
어떤 **결정적 푸시다운 오토마타(DPDA)** 가 $L$을 인식한다는 뜻.

### 1.2 DPDA 결정성(전형적 제약)
모든 상태 $q$와 스택top $X$에 대해
1) **입력소비 전이** $\delta(q,a,X)$ (a∈$\Sigma\cup\{$`$`$\}$) **와**  
   **$\varepsilon$-전이** $\delta(q,\varepsilon,X)$가 **동시에** 정의되면 안 됨  
2) 같은 $(q,a,X)$ 조합에 **여러 개 전이** 금지

> ⇒ 실행 중 **각 구성에서 전이는 0개 또는 1개**. (0개면 멈춤: 수용/거절)

### 1.3 끝표식 `$` (prefix 문제 회피)
입력 뒤에 `$`를 붙이고 “`$`에서만 accept” 하도록 정의하면  
접두사 모호로 인한 애매함이 사라져 **DPDA와 LR(1) 파서의 수용 조건이 정렬**된다.

---

## 2) “결정적 문법”의 의미: 결정적 파싱 가능성

문법 자체에 ‘결정성’ 속성을 직접 부여한다기보다,
**그 문법으로부터 결정적 파서(LL 또는 LR)를 만들 수 있는가**로 본다.

### 2.1 LL(k) 문법 (Top-down, 예측 파싱)
- $A\to \alpha_1 \mid \cdots \mid \alpha_m$ 에 대해, **lookahead $k$ 글자**만으로 어떤 생산을 선택할지 **항상 유일**하면 LL(k).
- 특히 **LL(1)** 조건(요지)
  $$
  \text{FIRST}(\alpha_i)\cap \text{FIRST}(\alpha_j)=\varnothing\ (i\ne j),\quad
  \varepsilon\in\text{FIRST}(\alpha)\Rightarrow
  \text{FIRST}(\alpha)\cap \text{FOLLOW}(A)=\varnothing.
  $$

> **LL(k) ⊊ LR(1)** → 모든 **LL(k) 언어는 DCFL**

### 2.2 LR 계열 (Bottom-up, shift-reduce)
- **LR(1)**: lookahead 1로 ACTION/GOTO 테이블에 **충돌 없음**  
- **SLR(1), LALR(1)**: LR(1)의 근사(실무에서 흔함).  
- **고전 정리**:
  $$
  \boxed{\ \text{LR(1) 언어} = \text{DCFL}\ }
  $$
  (표준 `$` 가정)  
  ⇒ 어떤 언어가 DCFL ⇔ **어떤 LR(1) 문법이 존재**

---

## 3) 포함 관계 지도(요약)

$$
\text{REG} \ \subsetneq\  \text{LL(1)} \ \subseteq\ \text{LL}(k) \ \subsetneq\ \text{LR(1)} = \text{DCFL} \ \subsetneq\ \text{U-CFL} \ \subsetneq\ \text{CFL}
$$

- **U-CFL**(Unambiguous CFL): **비모호**한 CFL 전체  
  - 예: 팰린드롬 $\{ww^R\}$ 은 **비모호(CFG 존재)**지만 **결정적 아님** → **DCFL이 아님**
  - 이유: 가운데 경계를 **결정적으로** 알 수 없어서 DPDA/LR(1) 으로 유일행동 불가

---

## 4) 문법을 “결정화”하는 설계 테크닉

1) **모호성 제거**: 우선순위, 결합법칙, 괄호화  
2) **좌재귀/우재귀 선택**: LL은 좌재귀 제거, LR은 좌재귀 허용  
3) **공통접두사 팩터링**: `A → αβ | αγ` → `A → αB, B → β | γ`  
4) **FIRST/FOLLOW 충돌 해소**(LL 목표 시)  
5) **끝표식 `$` 도입**: LR(1)/DPDA 일치 보장

---

## 5) 예시 문법과 결정성 점검

### 5.1 $L_1=\{a^n b^n \mid n\ge 0\}$ — LL(1), LR(1) (⇒ DCFL)
$$
S \to a S b \ \mid\ \varepsilon
$$
- LL(1): FIRST/ FOLLOW 충돌 없음 → 예측 파싱 가능  
- LR(1): 작은 아이템셋으로도 충돌 없이 테이블 생성됨

### 5.2 산술식(좌결합, `*` > `+`) — 전형적 LALR(1)
```bnf
E -> E + T | T
T -> T * F | F
F -> ( E ) | id
```
- 좌결합·우선순위를 문법 형태로 내장 → **비모호화**  
- 보통 LALR(1)로 안정 파싱(= DCFL)

### 5.3 반례 감각: 팰린드롬(짝·홀 포함)
- $\{ww^R\}$ 은 CFL이지만 **DCFL이 아님**  
  → 중간점 선택(“이제부터 reduce”)이 결정적으로 불가능

---

## 6) LR(1) 파서 = DPDA (핵심 대응)

- **스택 기호**: LR 상태(아이템 집합)  
- **shift a**: 상태 $s$에서 ACTION[s,a]=shift $t$ → **$t$ push**, 입력 전진  
- **reduce $A\to \beta$**: $|\beta|$개 pop → top=s' → **GOTO[s',A]** push  
- **accept**: `$`에서 accept

> 이 LR 스택 기계는 곧 **결정적 PDA**. 반대로 DPDA→LR(1) 구성도 가능 → **LR(1)=DCFL**

---

## 7) DCFL의 폐포·결정가능성(실무에 필요한 만큼)

- **보수(Complement)**: 닫힘(YES) — `$` 규약 하 DPDA 반전
- **정규와의 교집합**: 닫힘(YES) — DPDA×DFA 제품도 결정적
- **DCFL ∪ DCFL, DCFL ∩ DCFL**: 일반적으로 **닫힘 아님**
- **연접/스타**: 일반적으로 **닫힘 아님**
- **소속성**: LR/LL 파싱으로 **선형 시간 $O(n)$** (테이블 구축 후)
- **동치/포함**: 일반 CFG는 미결정문제가 많지만, **결정적**의 경우 이론상 결정 가능(복잡도 큼, 실무적 의미는 제한)

---

## 8) 실습 A — **LL(1) 예측 파서** 테이블 생성 & 파싱 (Python)

> 목표: (1) FIRST/FOLLOW 계산, (2) LL(1) 테이블 구성, (3) 문자열 파싱  
> 입력 포맷을 단순화해 **학습/검증용**으로 제공

```python
# -*- coding: utf-8 -*-
# LL(1) FIRST/FOLLOW & Parse Table & Predictive Parsing (교육용)
from collections import defaultdict, deque

EPS = 'ε'
END = '$'

class Grammar:
    def __init__(self, start, prods):
        """
        prods: dict[str, list[list[str]]]
          예) {'S': [['a','S','b'], [EPS]]}
        """
        self.start = start
        self.prods = prods
        self.nonterms = list(prods.keys())
        self.terms = sorted({t for rhs in prods.values() for alt in rhs
                             for t in alt if t not in prods and t != EPS} | {END})

    def is_nonterm(self, X): return X in self.prods

def compute_FIRST(g: Grammar):
    FIRST = {A: set() for A in g.nonterms}
    # 터미널 FIRST(자체)
    for t in g.terms:
        FIRST[t] = {t}

    changed = True
    while changed:
        changed = False
        for A, rhss in g.prods.items():
            for alpha in rhss:
                # alpha = X1 X2 ... Xk
                nullable_prefix = True
                for X in alpha:
                    for a in FIRST[X] if g.is_nonterm(X) else {X}:
                        if a != EPS and a not in FIRST[A]:
                            FIRST[A].add(a); changed = True
                    if (g.is_nonterm(X) and EPS not in FIRST[X]) or (not g.is_nonterm(X) and X != EPS):
                        nullable_prefix = False
                        break
                if nullable_prefix and EPS not in FIRST[A]:
                    FIRST[A].add(EPS); changed = True
    return FIRST

def compute_FOLLOW(g: Grammar, FIRST):
    FOLLOW = {A: set() for A in g.nonterms}
    FOLLOW[g.start].add(END)
    changed = True
    while changed:
        changed = False
        for A, rhss in g.prods.items():
            for alpha in rhss:
                trailer = FOLLOW[A].copy()
                for X in reversed(alpha):
                    if g.is_nonterm(X):
                        old = len(FOLLOW[X])
                        FOLLOW[X] |= trailer
                        if EPS in FIRST[X]:
                            trailer |= {a for a in FIRST[X] if a != EPS}
                        else:
                            trailer = {a for a in FIRST[X] if a != EPS}
                        if len(FOLLOW[X]) != old:
                            changed = True
                    else:
                        if X != EPS:
                            trailer = {X}
                        else:
                            # ε는 입력을 소비하지 않음 → trailer 유지
                            pass
    return FOLLOW

def build_ll1_table(g: Grammar, FIRST, FOLLOW):
    table = defaultdict(dict)  # table[A][a] = production (list)
    conflicts = []
    for A, rhss in g.prods.items():
        for alpha in rhss:
            # FIRST(alpha)
            F = set()
            nullable = True
            for X in alpha:
                sx = FIRST[X] if g.is_nonterm(X) else ({X} if X != EPS else {EPS})
                F |= {a for a in sx if a != EPS}
                if (g.is_nonterm(X) and EPS not in sx) or (not g.is_nonterm(X) and X != EPS):
                    nullable = False; break
            if nullable: F |= FOLLOW[A]
            for a in F:
                if a in table[A]:
                    conflicts.append((A, a, table[A][a], alpha))
                else:
                    table[A][a] = alpha
    return table, conflicts

def ll1_parse(g: Grammar, table, tokens):
    stack = [END, g.start]
    i = 0
    tokens = tokens + [END]
    steps = []
    while stack:
        X = stack.pop()
        a = tokens[i]
        steps.append((list(stack), X, a))
        if X == a == END:
            return True, steps
        if X in g.prods:  # nonterminal
            if a in table[X]:
                rhs = table[X][a]
                for sym in reversed(rhs):
                    if sym != EPS:
                        stack.append(sym)
            else:
                return False, steps
        else:  # terminal
            if X == a:
                i += 1
            else:
                return False, steps
    return False, steps

# === 예제 1: L = { a^n b^n } ===
G = Grammar('S', {'S': [['a','S','b'], [EPS]]})
FIRST = compute_FIRST(G)
FOLLOW = compute_FOLLOW(G, FIRST)
table, conflicts = build_ll1_table(G, FIRST, FOLLOW)
print("FIRST:", FIRST); print("FOLLOW:", FOLLOW)
print("conflicts:", conflicts)  # 없으면 LL(1)
ok, trace = ll1_parse(G, table, list("aabb"))
print("aabb:", ok)
```

- 이 코드는 **LL(1) 가능 여부**(conflicts 유무)와 **실제 파싱**을 보여준다.
- `S→aSb | ε` 문법은 **conflicts 없음**(LL(1) OK), `aabb`는 수용 True.

---

## 9) 실습 B — **SLR(1) 미니 생성기** (LR(0) 아이템 + FOLLOW) & 파싱

> LR(1)을 완전하게 구현하면 코드가 길어지므로, **학습용으로 SLR(1)** 을 제시  
> (대다수 교육용 문법은 SLR 또는 LALR에 잘 들어맞음)

```python
# -*- coding: utf-8 -*-
# SLR(1) 미니: LR(0) 아이템, GOTO, ACTION/GOTO 테이블, 충돌 검출, 간단 파싱
from collections import defaultdict, deque
from typing import List, Tuple, Dict, Set, FrozenSet

END = '$'
EPS = 'ε'

class LRGrammar:
    def __init__(self, start, prods):  # prods: dict[str, list[list[str]]]
        self.orig_start = start
        self.start = start + "'"
        # 증강: S'→S
        self.prods = {self.start: [[start]]}
        for A, rhss in prods.items():
            self.prods[A] = [list(rhs) for rhs in rhss]
        self.nonterms = list(self.prods.keys())
        self.terms = sorted({t for A in self.prods for rhs in self.prods[A] for t in rhs
                             if t not in self.prods and t != EPS} | {END})

    def is_nonterm(self, X): return X in self.prods

def FIRST_sets(g: LRGrammar):
    FIRST = {A: set() for A in g.nonterms}
    for t in g.terms:
        FIRST[t] = {t}
    # ε는 LR 테이블 용도에선 크게 필요 없으나 일반성 유지
    FIRST[EPS] = {EPS}
    changed = True
    while changed:
        changed = False
        for A, rhss in g.prods.items():
            for alpha in rhss:
                nullable = True
                for X in alpha:
                    sx = FIRST[X] if X in FIRST else {X}
                    for a in sx:
                        if a != EPS and a not in FIRST[A]:
                            FIRST[A].add(a); changed = True
                    if EPS not in sx:
                        nullable = False; break
                if nullable and EPS not in FIRST[A]:
                    FIRST[A].add(EPS); changed = True
    return FIRST

def FOLLOW_sets(g: LRGrammar, FIRST):
    FOLLOW = {A: set() for A in g.nonterms}
    FOLLOW[g.start].add(END)
    changed = True
    while changed:
        changed = False
        for A, rhss in g.prods.items():
            for alpha in rhss:
                trailer = FOLLOW[A].copy()
                for X in reversed(alpha):
                    if g.is_nonterm(X):
                        old = len(FOLLOW[X])
                        FOLLOW[X] |= trailer
                        if EPS in FIRST[X]:
                            trailer |= {a for a in FIRST[X] if a != EPS}
                        else:
                            trailer = {a for a in FIRST[X] if a != EPS}
                        if len(FOLLOW[X]) != old:
                            changed = True
                    else:
                        if X != EPS:
                            trailer = {X}
    return FOLLOW

def items_closure(g: LRGrammar, I: Set[Tuple[str, Tuple[str,...], int]]):
    # 아이템: (A, beta, dot) where beta is tuple (rhs), dot index
    changed = True
    I = set(I)
    while changed:
        changed = False
        for (A, beta, dot) in list(I):
            if dot < len(beta):
                X = beta[dot]
                if g.is_nonterm(X):
                    for gamma in g.prods[X]:
                        it = (X, tuple(gamma), 0)
                        if it not in I:
                            I.add(it); changed = True
    return frozenset(I)

def goto(g: LRGrammar, I, X):
    J = set()
    for (A, beta, dot) in I:
        if dot < len(beta) and beta[dot] == X:
            J.add((A, beta, dot+1))
    return items_closure(g, J) if J else frozenset()

def build_canonical_sets(g: LRGrammar):
    C = []
    start_item = items_closure(g, {(g.start, tuple(g.prods[g.start][0]), 0)})
    C.append(start_item)
    trans = []  # (i, X, j)
    changed = True
    while changed:
        changed = False
        for i, I in list(enumerate(C)):
            for X in g.terms + [A for A in g.nonterms if A != g.start]:
                J = goto(g, I, X)
                if J:
                    if J not in C:
                        C.append(J); changed = True
                    j = C.index(J)
                    trans.append((i, X, j))
    return C, trans

def build_SLR_table(g: LRGrammar):
    FIRST = FIRST_sets(g)
    FOLLOW = FOLLOW_sets(g, FIRST)
    C, trans = build_canonical_sets(g)

    # 맵: (state, sym) -> next
    GOTO = defaultdict(dict)
    for i, X, j in trans:
        if g.is_nonterm(X):
            GOTO[i][X] = j

    ACTION = defaultdict(dict)  # (state, term) -> ('shift', j) or ('reduce', A, rhs) or ('accept',)
    conflicts = []

    # shift
    shift_edges = [(i, X, j) for (i, X, j) in trans if X in g.terms]
    for i, a, j in shift_edges:
        if a in ACTION[i]:
            conflicts.append(('SR/RR?', i, a, ACTION[i][a], ('shift', j)))
        ACTION[i][a] = ('shift', j)

    # reduce / accept
    for i, I in enumerate(C):
        for (A, beta, dot) in I:
            if dot == len(beta):
                if A == g.start:
                    ACTION[i][END] = ('accept',)
                    continue
                # reduce A->beta on FOLLOW(A)
                for a in FOLLOW[A]:
                    if a in ACTION[i]:
                        conflicts.append(('conflict', i, a, ACTION[i][a], ('reduce', A, list(beta))))
                    ACTION[i][a] = ('reduce', A, list(beta))

    return ACTION, GOTO, C, conflicts

def slr_parse(g: LRGrammar, ACTION, GOTO, w: List[str]):
    stack = [0]
    i = 0; w = w + [END]
    steps = []
    while True:
        s = stack[-1]
        a = w[i]
        act = ACTION[s].get(a)
        steps.append((list(stack), a, act))
        if act is None:
            return False, steps
        if act[0] == 'shift':
            stack.append(act[1]); i += 1
        elif act[0] == 'reduce':
            A, beta = act[1], act[2]
            for _ in beta:
                stack.pop()
            s2 = stack[-1]
            if A not in GOTO[s2]:
                return False, steps
            stack.append(GOTO[s2][A])
        elif act[0] == 'accept':
            return True, steps

# === 예제: E→E+T|T; T→T*F|F; F→(E)|id ===
prods = {
    'E': [['E','+','T'], ['T']],
    'T': [['T','*','F'], ['F']],
    'F': [['(','E',')'], ['id']]
}
G = LRGrammar('E', prods)
ACTION, GOTO, C, conflicts = build_SLR_table(G)
print("conflicts:", conflicts)  # 보통 없음 또는 해석 가능한 수준
ok, trace = slr_parse(G, ACTION, GOTO, ['id','+','id','*','id'])
print("parse:", ok)
```

- **충돌(conflicts)** 이 없으면 **SLR(1)** 로 결정적 파싱 가능(⇒ DCFL).  
- 위 산술식 문법은 보통 SLR/LALR(1)에서 **충돌 없이** 동작한다.

---

## 10) 사례 연구 — 문법 리팩토링으로 “결정성” 만들기

### 10.1 모호 문법 → 비모호 LR(1)
모호:
```bnf
E -> E + E | E * E | ( E ) | id
```
비모호(LALR(1) 보편형):
```bnf
E -> E + T | T
T -> T * F | F
F -> ( E ) | id
```
- **우선순위**: `*` > `+`, **좌결합** → 파스 트리 유일화  
- LR 테이블 충돌 제거 → **DCFL** 로 귀속

### 10.2 LL(1)을 목표로 하는 팩터링
공통 접두사로 충돌이 날 때:
```bnf
A -> α β | α γ
```
팩터링:
```bnf
A -> α B
B -> β | γ
```
- FIRST 충돌 감소 → **LL(1)** 달성 가능성↑

---

## 11) 실패 사례 감각(DCFL이 아닌 전형)

1) **팰린드롬** $\{ww^R\}$  
   - 가운데 경계에 대한 결정적 신호가 부족 → DPDA/LR(1)에서 유일행동 불가

2) **두 스택이 필요한 패턴**(균형+대칭/다중상관)  
   - 예: $\{a^n b^n c^n\}$ 은 **CFL조차 아님**(PDA 불가, 2-스택 필요)

---

## 12) 실무 팁(컴파일러/파서 생성기 관점)

- **목표 파서**에 따라 문법을 다듬자
  - ANTLR(LL 계열): **좌재귀 제거**, 팩터링, 명시적 우선순위/결합법칙
  - bison/yacc(LR 계열): **좌재귀 허용**, 우선순위/결합 규칙으로 충돌 해소
- **끝표식 `$`**: 파일 끝 토큰(EOF)을 **명시** → DPDA/LR accept 일치
- **단위/ε 규칙 정리 & CNF/GNF**: 분석/검증/도구화가 쉬워짐
- **테스트 전략**: 짧은 반례(lookahead 경계), 엣지케이스(빈, 단일토큰), 긴 중첩

---

## 13) 한 페이지 정리(치트시트)

- **정의**: DCFL = **DPDA**로 인식되는 CFL = **LR(1)** 언어  
- **포함**: LL(k) ⊆ LR(1)=DCFL ⊊ U-CFL ⊊ CFL  
- **결정성**: 매 순간 선택이 유일(lookahead 한정)  
- **폐포**: 보수/정규와의 교집합 ○, 합/교집합(서로 DCFL) ×, 연접/스타 ×  
- **검증**:  
  - LL(1): FIRST/FOLLOW & 테이블 충돌 유무  
  - LR: 아이템셋 & ACTION/GOTO 충돌 유무  
- **설계**: 모호성 제거(우선순위·결합), 접두사 팩터링, 끝표식

---

## 14) 퀵 체크(연습문제 스타일)

1) 아래 문법이 LL(1)인가? 아니면 LR(1)이지만 LL(1)은 아닌가?
```bnf
S -> id = E
E -> E + T | T
T -> T * F | F
F -> ( E ) | id
```
- 해설 포인트: 할당 부분은 LL(1) 무난, 표현식은 보통 LL(1)로 만들기 까다롭지만 LR(1)/LALR(1)로 안정.

2) 팩터링으로 LL(1) 만들기:
```bnf
Stmt -> if ( E ) Stmt else Stmt | if ( E ) Stmt
```
- 전형적 “dangling else” → LL(1)로는 애매(lookahead 부족)  
  - 해결: **else 결합 규칙**(가까운 if에 결합) & 문법 재구성(우선순위 규칙/AST 단계) or LR(1) 사용

---

## 15) 마무리

- **문법의 결정성**은 **파서가 순간순간 유일하게 움직일 수 있느냐**로 환원된다.  
- **LL/LR 조건**을 만족하면 **결정적 파서**(곧 **DPDA**)가 존재하며, 언어는 **DCFL**.  
- 실무에서는 **LALR(1)/LR(1)** 또는 **LL(*)** 도구를 쓰되,  
  **모호성 제거·팩터링·끝표식** 같은 문법 습관이 “결정성”을 보장한다.