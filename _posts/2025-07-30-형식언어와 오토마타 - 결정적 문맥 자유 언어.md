---
layout: post
title: 형식언어와 오토마타 - 결정적 문맥 자유 언어
date: 2025-07-30 14:20:23 +0900
category: 형식언어와 오토마타
---
# 결정적 문맥-자유 언어(DCFL)에 대한 **문법**

이 글은 **결정적 문맥-자유 언어(Deterministic Context-Free Languages, DCFL)** 를 **문법(grammar)**의 관점에서 정리한다.  
핵심은 **결정적 푸시다운 오토마타(DPDA)** 와 **결정적 파싱이 가능한 문법(LR/LL류)** 사이의 일치다.  

---

## 1) 배경: DCFL과 DPDA

### 정의(언어 관점)
언어 \(L \subseteq \Sigma^*\) 가 **결정적 문맥-자유** 라는 것은,
**어떤 결정적 푸시다운 오토마타(DPDA)** 가 \(L\)을 인식한다는 뜻이다.

DPDA의 결정성(표준 형식):
- 같은 상태 \(q\)·스택맨틀 \(X\)에서
  - 어떤 **입력 소비 전이** \( \delta(q,a,X) \) (a∈Σ∪\(\$\) 끝표식)와
  - **ε-전이** \( \delta(q,\varepsilon,X) \)
  가 **동시에** 정의될 수 없다.
- 또한 동일 조건에서 **둘 이상의** 입력 소비 전이가 정의될 수 없다.
- 종종 **오른쪽 끝표식** \(\$\) 를 붙여 접두사 문제를 피한다(아래 §2.3).

결과적으로 **모든 순간**에 **0개 또는 1개**의 전이만 가능해야 한다.  
(0개면 정지: 수용/거절 중 하나로 멈춤.)

---

## 2) “결정적 문법”이란? — 파서 관점의 문법류

문법 자체에 “결정성”을 직접 부여하기보다는  
**그 문법으로부터 결정적으로 파싱 가능한지**(= 어떤 결정적 파서가 존재하는지)로 본다.

### 2.1 LL(k) 문법 (top-down, 예측 파싱)
- 한 비단말의 여러 생산 \(A\to \alpha_1 \mid \alpha_2 \mid \cdots\) 에 대해
  **앞으로 볼 \(k\)글자(lookahead)** 만으로 **어느 생산을 쓸지**를 항상 결정할 수 있으면 LL(k).
- 특히 **LL(1)**: 각 비단말 A에 대해
  \[
  \text{FIRST}(\alpha_i) \cap \text{FIRST}(\alpha_j)=\varnothing\ (i\ne j),
  \]
  그리고 \(\varepsilon\) 규칙이 있으면 \(\text{FIRST}(\alpha)\cap\text{FOLLOW}(A)=\varnothing\) 등.
- LL(k) 언어 ⊊ LR(1) 언어(=DCFL). 즉 **모든 LL(k) 언어는 DCFL**.

### 2.2 LR(k)·SLR(1)·LALR(1) 문법 (bottom-up, shift-reduce)
- **LR(1)**: 1글자 lookahead로 **shift/reduce·reduce/reduce** 충돌 없이 파싱 테이블을 만들 수 있으면 LR(1).
- **SLR(1), LALR(1)** 는 LR(1)의 보수적 근사(덜 엄격)로, 실무 컴파일러에서 널리 사용.
- **정리(고전)**:  
  \[
  \boxed{\ \textbf{LR(1) 언어} \;=\; \textbf{DCFL}\ }
  \]
  (입력 뒤에 끝표식 \(\$\) 를 붙인 표준 형식에서.)  
  ⇒ 어떤 언어가 DCFL ⇔ 어떤 **LR(1) 문법**이 존재.

### 2.3 접두사 성질(prefix property)와 끝표식 \(\$\)
- DPDA에서 **빈 스택 수용**과 **최종 상태 수용**이 일반적으로 일치하지 않는다.  
  그러나 입력에 **\(\$\)** 를 붙이고 “\(\$\) 를 만나야만 수용”으로 정의하면  
  접두사 모호성이 제거되어 양 방식이 사실상 일치한다.  
- LR(1) 파서의 **accept** 동작도 이 \(\$\) 관례를 전제로 한다.

---

## 3) 포함 관계(요약)

\[
\text{REG} \ \subsetneq\  \text{LL(1)} \ \subseteq\ \text{LL}(k) \ \subsetneq\ \text{LR(1)} \;=\; \text{DCFL} \ \subsetneq\ \text{U-CFL} \ \subsetneq\ \text{CFL}
\]

- **U-CFL**: 비모호(CFG가 어느 하나는 비모호)인 CFL들의 모임.  
  DCFL ⊊ U-CFL (예: 팰린드롬 \(\{ww^R\}\) 은 **비모호**지만 **결정적 아님** — 중간점을 결정적으로 알 수 없음).

---

## 4) 결정적 문법의 특징(직관)

- **모호성 금지**: 같은 문자열의 두 유도 트리 × (결정적 파서는 항상 유일한 행동).
- **국소 결정 가능성**: 유한한 lookahead 만으로 다음 동작(LL은 선택, LR은 shift/reduce)이 정해진다.
- **스택 동작의 결정성**: LR 파서는 곧 **DPDA** — 스택에 쌓는 것은 “상태”이며,  
  reduce 길이만큼 pop 하고 GOTO로 push 하는 구조(= DPDA의 추상화).

---

## 5) 예시 문법

### 5.1 \( L_1=\{a^n b^n \mid n\ge 0\} \) — LL(1)·LR(1) (따라서 DCFL)
\[
S \;\to\; a S b \;\mid\; \varepsilon
\]
- **LL(1) 체크**:  
  FIRST(\(aSb\))=\(\{a\}\), FIRST(\(\varepsilon\))=\(\{\varepsilon\}\),  
  FOLLOW(\(S\))=\(\{b,\$\}\) ⇒ 충돌 없음.
- **LR(1)** 테이블도 충돌 없이 생성됨(생략).

### 5.2 산술식(좌결합, 표준 우선순위) — LALR(1) 예
```bnf
E -> E + T | T
T -> T * F | F
F -> ( E ) | id
```
- 좌재귀·우선순위·결합법칙을 통해 모호성 제거 → 일반적으로 **LALR(1)** (따라서 DCFL).

> 반례 감각: 팰린드롬 \( \{ ww^R \mid w\in\{a,b\}^* \} \) 은 **CFL**이지만 **DCFL 아님**(결정적으로 중심을 알 수 없음).

---

## 6) LR(1) 파서 = DPDA (구성 개요)

### 6.1 LR(1) 파서의 스택을 DPDA 스택으로
- **스택 기호**: LR 상태(아이템 집합)들.
- **입력**: \(\Sigma\$\) (끝표식 추가).
- **동작**:
  - `shift a`: 스택 top = s 이고 ACTION[s,a]=shift t ⇒ **push t**, 입력 한 칸 전진.
  - `reduce A→β`: |β| 만큼 pop ⇒ 남은 top = s' ⇒ **push GOTO[s',A]**.
  - `accept` on \(\$\): 수용.

이것이 그대로 **결정적 PDA** 의 전이로 구현된다.  
반대로 DPDA에서 LR(1) 문법을 구성할 수도 있어(깊은 정리) **LR(1)=DCFL** 이 성립.

---

## 7) 결정적 문법/언어의 **폐포와 결정가능성**(필요한 만큼만)

- **보수(Complement)**: DCFL **닫힘(Yes)** — DPDA의 전이/수용 조건을 반전(끝표식 관례).
- **정규와의 교집합**: **닫힘(Yes)** — DPDA×DFA 제품도 결정적.
- **합집합/교집합(서로 DCFL끼리)**: 일반적으로 **닫히지 않음**.
- **연접/스타**: 일반적으로 **닫히지 않음**.
- **소속성 판정**: LR/LL 파싱으로 **선형시간 \(O(n)\)** (테이블 준비 후).
- **공백성/유한성**: CFG와 같은 절차로 **결정 가능**.
- **동치·포함**: 일반 CFG에선 **결정 불가능**,  
  **결정적**의 경우 **Sénizergues 정리**로 *이론적으로* 결정 가능(실용 복잡도는 매우 큼).

---

## 8) LL(1) 예측 파서·LR(1) 시프트-리듀스 파서(의사코드)

### 8.1 LL(1) (테이블 `TABLE[A, a]` 준비됨 가정)
```text
stack := [ $, S ]
i := 1
while top(stack) ≠ $:
  X := top(stack)
  a := lookahead(i)
  if X ∈ Σ ∪ {$}:
     if X == a: pop(); i++
     else: reject
  else:  # X is nonterminal
     prod := TABLE[X, a]  # unique by LL(1)
     if prod == none: reject
     pop(); push(rhs(prod) in reverse)
accept if a == $ and stack == [$]
```

### 8.2 LR(1) (ACTION, GOTO 준비됨 가정)
```text
stack := [0]   # state 0
i := 1
loop:
  s := top(stack)
  a := lookahead(i)
  act := ACTION[s, a]
  case act of
    shift t:   push(t); i++
    reduce A→β: pop |β| symbols; s' := top(stack); push(GOTO[s',A])
    accept:    return ACCEPT
    error:     return REJECT
```
(이 LR 스택 기계가 곧 DPDA다.)

---

## 9) 자주 쓰는 “결정화” 테크닉(문법을 DCFL 쪽으로 다듬기)

1. **모호성 제거**: 우선순위·결합법칙·괄호화로 파스 트리 유일화.  
2. **좌재귀 vs 우재귀**: LL은 좌재귀 제거, LR은 좌재귀를 잘 처리 — 목표 파서에 맞춘 변형.  
3. **FIRST/FOLLOW 충돌 해소**: LL(1)을 노리면 분기들의 FIRST가 겹치지 않도록 팩터링.  
4. **공통 접두사 팩터링**: `A→αβ | αγ` → `A→αB, B→β|γ`.  
5. **끝표식 \(\$\)**: LR(1) 구축 시 반드시 붙여 결정성 보장.

---

## 10) 한 페이지 요약

- **정의**: DCFL = **DPDA** 로 인식되는 언어.  
- **문법 관점**: \(\boxed{\text{DCFL} = \text{LR(1) 언어}}\).  
  LL(k) ⊆ DCFL, LALR/SLR 같은 실무 문법도 대체로 DCFL.  
- **예**: \(a^n b^n\), 균형 괄호, 표준 산술식(우선순위·결합법칙 반영).  
- **비예**: 팰린드롬 \(\{ww^R\}\) — 비결정적 선택이 필요.  
- **장점**: 결정적 파싱(보통 \(O(n)\)), 구현 용이(컴파일러).  
- **주의**: DCFL은 합·교집합(서로 DCFL끼리) 등에 닫혀 있지 않음.