---
layout: post
title: Elixir - 1.6 이후 추가·개선된 핵심 기능들
date: 2025-11-23 23:30:23 +0900
category: Elixir
---
# Elixir 1.6 이후 추가·개선된 핵심 기능들 (Logger · Release · Config · Sort · Range · Pipeline · Scripting)

## C.0 왜 “1.6 이후의 개선”이 실무에 크게 작동하는가

Elixir 1.6 이후에 추가된 기능들은, 하나하나가 작은 문법/도구 개선처럼 보이지만, 합쳐지면 “프로덕션 시스템을 Elixir스럽게 운영하고 확장하는 방식”을 바꾼다.

- **C.1 Logger 개선**은 “관찰성(Observability)”의 수준을 끌어올렸다.
  풍부한 메타데이터와 구조화 로그를 **오버헤드 없이** 남길 수 있고, 빌드에서 로그 호출 자체를 제거할 수 있다.

- **C.2 Release (Mix Release)** 는 “배포의 표준화”를 만들었다.
  OTP/BEAM의 장점을 유지한 채, 외부 도구 없이도 **독립 실행 번들**을 만들어 운영할 수 있다.

- **C.3 Config API 개선**은 실행 환경이 많아지는 현실(Dev/Test/Staging/Prod/CI/Local/Notebook 등)에서
  “컴파일 타임 vs 런타임” 설정 경계를 명확히 **강제**한다.

- **C.4 정렬 개선**, **C.5 Range 개선**, **C.6 then/tap**, **C.7 Mix.install** 은
  개발자 경험(DX)과 코드 가독성/안전성을 한 단계 끌어올린다.

결국 이 부록의 목적은 “기능 목록 나열”이 아니라
**실제로 시스템을 만들 때 어떤 사고 방식과 패턴이 강화되었는지**를 잡는 것이다.

---

## C.1 로거 개선 (≈ 1.7)

요점
- **컴파일 타임 purge** 조건과 **메타데이터** 운용이 개선되어 **오버헤드 없이** 풍부한 로그를 남기기 쉬워졌다.
- **포맷터 커스터마이징**이 유연해져 JSON/구조화 로그로 운영 관측성을 높일 수 있다.

### C.1.1 Logger의 기본 구조 — “로그 호출 → 이벤트 → 포맷 → 백엔드”

Logger를 이해하려면 흐름을 먼저 잡는 게 좋다.

```
Logger.info/2 같은 호출
        |
        V
(Logger 이벤트 생성)
        |
        V
각 백엔드(console/file/syslog/OTLP 등)에 전달
        |
        V
백엔드별 formatter가 메시지/메타데이터를 문자열(iodata)로 변환
        |
        V
출력 / 전송 / 저장
```

이 구조에서 1.7 이후의 개선은 크게 두 축이다.

1) “**로그 호출이 불필요하면 아예 바이트코드에서 지워라**(compile_time_purge_level)”
2) “**로그 호출이 필요하면 메타데이터를 붙여 풍부하게 남겨라**”

즉, **불필요한 건 0 비용**, **필요한 건 풍부하게**가 기본 철학이다.

---

### C.1.2 메타데이터와 포맷터

```elixir
# config/config.exs

import Config

config :logger,
  level: :info,
  truncate: :infinity,
  backends: [:console],
  # metadata 키를 명시해야 포맷에서 보인다
  metadata: [:request_id, :user_id, :mfa, :pid]

config :logger, :console,
  format: "$time $metadata[$level] $message\n"
```

```elixir
defmodule C1.LogDemo do
  require Logger

  def run do
    Logger.metadata(request_id: "rq-123", user_id: 42)
    Logger.info("start job")
    Logger.debug("won't print at :info level")
  end
end
```

핵심 포인트:

- `Logger.metadata/1`는 **프로세스 로컬(Process Dictionary 기반)** 이다.
  즉, 메타데이터는 “현재 프로세스에서만 자동으로 붙는다.”

- `metadata: [...]` 설정이 있어야 `$metadata`에 표시된다.
  (키를 ‘허용 리스트’로 생각하면 된다)

#### (A) 웹 요청 단위 메타데이터 패턴

```elixir
defmodule Web.RequestLogger do
  require Logger

  def with_request_meta(req_id, user_id, fun) do
    Logger.metadata(request_id: req_id, user_id: user_id)
    fun.()
  after
    # 요청이 끝나면 meta 제거(누수 방지)
    Logger.reset_metadata()
  end
end
```

- 요청/작업 단위로 메타데이터를 설정하고
- 반드시 끝에서 reset 해 주면 “다음 작업에 섞이는” 사고를 방지한다.

#### (B) Task/Async에서 메타데이터 전파

메타데이터는 프로세스 로컬이므로 Task를 쓰면 다음 문제가 생긴다.

- 부모 프로세스에서 메타데이터를 심었는데
- 자식 프로세스(Task)는 메타를 모른다.

해결 패턴:

```elixir
defmodule C1.TaskMeta do
  require Logger

  def async(fun) do
    parent_md = Logger.metadata()
    Task.async(fn ->
      Logger.metadata(parent_md)
      fun.()
    end)
  end
end
```

- `Logger.metadata()`로 현재 메타를 복사
- Task 시작과 함께 다시 심어준다

이 패턴은 “로그 추적 단절”을 막는 실전 필수 기법이다.

---

### C.1.3 JSON/구조화 로그 예시(간단)

```elixir
defmodule C1.JSONFormatter do
  @behaviour :logger_formatter

  def format(level, msg, ts, md) do
    map = %{
      level: level,
      message: IO.iodata_to_binary(msg),
      time: format_ts(ts),
      metadata: Map.new(md)
    }

    [Jason.encode!(map), ?\n]
  end

  defp format_ts({{y,m,d},{hh,mm,ss,ms}}) do
    :io_lib.format(
      "~4..0B-~2..0B-~2..0BT~2..0B:~2..0B:~2..0B.~3..0BZ",
      [y,m,d,hh,mm,ss,ms]
    )
    |> IO.iodata_to_binary()
  end
end
```

구조화 로그를 쓰는 실전 이유:

- 텍스트 로그는 사람이 보기엔 편해도,
  운영에서 “필터/집계/알람”을 만들기 어렵다.
- JSON은 로그 수집기(예: ELK/Datadog/OpenTelemetry Collector 등)가
  “필드 단위”로 접근할 수 있어 **관찰성을 자동화**하기 좋다.

#### (A) JSON 포맷터 등록 패턴

```elixir
# config/prod.exs

import Config

config :logger, :console,
  format: {C1.JSONFormatter, :format}
```

- `format:`에 `{Module, fun}`을 넣는 패턴으로 커스텀 포맷터 연결 가능.

#### (B) 메타데이터 스키마를 관리하라

구조화 로그는 “키가 마구 늘어나면” 오히려 운영이 어려워진다.
따라서 도메인 기준으로 **스키마를 최소화**하는 게 중요하다.

예: 웹 계층에서 최소 스키마

- `request_id`
- `user_id`
- `service`
- `route`
- `status`
- `duration_ms`

작업 계층에서 최소 스키마

- `job_id`
- `job_kind`
- `attempt`
- `duration_ms`
- `result`

---

### C.1.4 컴파일 타임 purge

```elixir
# config/prod.exs

import Config

config :logger,
  level: :info,
  compile_time_purge_level: :info
```

- `compile_time_purge_level` 이상(여기서는 `:info` 이상)만 남기고
  그 이하(`:debug`, `:trace`) 호출은 **바이트코드에서 삭제**된다.

#### purge가 주는 실전 효과

1) 실행 중 레벨 비교 비용 자체가 사라진다.
2) “심지어 로그 문자열 구성 비용”도 사라진다.

```elixir
Logger.debug(fn ->
  # 이 비용 큰 계산도 purge면 통째로 소멸
  heavy_payload() |> Jason.encode!()
end)
```

- `Logger.debug/1`의 lazy-fn은 **실행 레벨이 낮으면 평가되지 않음**
- purge까지 걸리면 호출 자체가 제거됨

즉 **“디버그 로그를 마음껏 심어도 prod에서는 0 비용”** 이 되는 셈이다.

#### purge의 주의점

- prod에서 로그가 지워졌다는 건
  그 코드가 **존재하지 않는 것과 같아진다**는 뜻.
- 따라서 “민감 정보 출력”, “실수로 의존한 부수효과”가 없어야 한다.

실전 규칙:

- 로그는 **순수 부수효과**여야 한다.
- 로그 내부에서 비즈니스 상태를 바꾸는 코드가 있으면 안 된다.

---

### C.1.5 동적 레벨 변경과 운영 패턴

런타임 레벨을 바꿔야 하는 상황이 빈번하다.

- 장애 조사 시 잠깐 `:debug`를 올리고 싶을 때
- 특정 모듈만 더 자세히 보고 싶을 때

패턴 1) 전체 레벨 올리기

```elixir
Logger.configure(level: :debug)
```

패턴 2) 특정 도메인에만 추가 디버그 키를 달기

```elixir
Logger.metadata(domain: :billing)
Logger.debug("charging start")
```

그러면 운영에서 “domain == billing”만 골라서 봐도 된다.

---

## C.2 릴리스 기능 추가 (≈ 1.9)

**Elixir 1.9**부터 표준으로 **Mix Release** 제공.
외부 도구 없이 **독립 실행 번들** 생성이 가능하다.

### C.2.1 왜 Release가 Elixir의 배포 방식을 바꿨나?

Release가 없던 시대:

- Distillery 같은 외부 도구
- OTP 버전/ERTS 포함 여부를 직접 설계
- 운영 런북을 팀마다 다르게 가짐

Release 이후:

- 표준 방식으로 **ERTS + 앱 + 설정 + 실행 스크립트**를 묶는다.
- 운영이 “Erlang/Elixir를 모르는 인프라팀”에도 전파 가능해짐.

---

### C.2.2 최소 설정과 빌드

```elixir
# mix.exs (프로젝트 최상단)

def project do
  [
    app: :my_app,
    version: "0.1.0",
    start_permanent: Mix.env() == :prod,
    releases: [
      my_app: [
        include_executables_for: [:unix],
        applications: [my_app: :permanent]
      ]
    ]
  ]
end
```

```bash
MIX_ENV=prod mix release
_build/prod/rel/my_app/bin/my_app start
_build/prod/rel/my_app/bin/my_app rpc "IO.puts(:erlang.system_info(:otp_release))"
```

- `release`는 `_build/prod/rel/<name>` 아래에 생성된다.
- 실행 스크립트 `bin/my_app`가 포함된다.

---

### C.2.3 runtime 설정과 secrets

**컴파일 타임 설정**과 **런타임 설정**을 나누는 게 Release의 핵심이다.

```elixir
# config/runtime.exs

import Config

if config_env() == :prod do
  db_url = System.fetch_env!("DATABASE_URL")

  config :my_app, Repo,
    url: db_url,
    pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10")
end
```

- Release는 **노드 부팅 시 runtime.exs를 실행**한다.
- 따라서
  - URL
  - 비밀
  - 포트
  - pool size
  같은 **환경 의존값**을 안전히 주입할 수 있다.

---

### C.2.4 운영 커맨드와 런북

Release 스크립트는 운영에서 다음처럼 쓰인다.

```bash
bin/my_app start
bin/my_app stop
bin/my_app restart
bin/my_app status

bin/my_app remote   # 원격 IEx attach
bin/my_app rpc "MyApp.Health.check()"
bin/my_app eval "IO.puts(:ok)"
```

실전 팁:

- `rpc`는 “노드에 붙지 않고도” 상태를 뽑을 수 있어
  헬스체크/운영 스크립트에 적합하다.
- `remote`는 장애 조사 시 “현재 살아있는 노드 상태”를 직접 탐색 가능하다.

---

### C.2.5 Release 단계(steps)와 커스터마이징

Release 빌드는 내부적으로 “단계(steps)”를 거친다.

- assemble → tar → (custom steps 가능)

```elixir
releases: [
  my_app: [
    steps: [:assemble, :tar]
  ]
]
```

실무에서는

- 빌드 산출물에 추가 파일을 넣거나
- 특정 beam을 strip 하거나
- 운영용 스크립트를 끼워 넣는

커스터마이징을 steps로 관리하기도 한다.

---

## C.3 설정 API 개선 (≈ 1.9, 1.11)

핵심 변화
- 1.9: **컴파일/런타임 설정 분리**
- 1.11: **새 Config API** 도입 — `Mix.Config` 대신 `Config` 사용, `import Config`

### C.3.1 새 Config API로 마이그레이션

```elixir
# (이전) use Mix.Config   →   (이후) import Config

import Config

config :my_app, :feature_flag, true
import_config "#{config_env()}.exs"
```

마이그레이션 핵심:

- config 파일은 “단순 스크립트”처럼 읽자.
- `config_env()`는 빌드/실행 현재 환경을 의미한다.

---

### C.3.2 컴파일 타임 vs 런타임 분리

정확한 구분 기준:

- **컴파일 타임**
  - 매크로(`use`, `import`, `require`)가 코드 생성에 쓰는 값
  - 의존 모듈의 존재/옵션
  - compile_env를 통해 인라인될 값

- **런타임**
  - 환경변수/서비스 주소/키
  - 배포 환경에 따라 바뀌는 값
  - 캐시 TTL, pool size, 포트 등

#### 실전 필수 API

```elixir
Application.compile_env(:my_app, :flag, false)
Application.get_env(:my_app, :flag, false)
Application.fetch_env!(:my_app, :flag)
```

- `compile_env`는 **컴파일 때 인라인될 수 있음**
  → 런타임에 바뀌어도 반영되지 않는다.
- `get_env/fetch_env!`는 런타임 조회.

따라서 규칙:

> “환경마다 달라질 수 있는 값”은 compile_env를 쓰면 안 된다.

---

### C.3.3 환경별 설정이 꼬이는 대표 사고

사고 사례:

1) `config/config.exs`에 DB URL을 넣음
2) Release 빌드
3) 운영에서 URL을 바꿨는데 반영이 안 됨

원인:

- 컴파일 타임에 고정된 값이 Release에 박힘
- runtime.exs가 아니기 때문

해결:

- 데이터소스/비밀/네트워크 종속값은 **무조건 runtime.exs로**

---

## C.4 정렬 기능 개선 (≈ 1.10)

정렬은 “단순 알고리즘 문제” 같지만, 실무에서는

- 다중 키
- nil 포함
- 안정성
- 비교 비용

때문에 복잡해진다.
1.10 이후의 정렬 개선은 대부분 **“표현을 더 직관적으로”** 바꾸는 데 초점이 있다.

### C.4.1 `Enum.sort_by/3` — 변환자 + 정렬자

```elixir
people = [
  %{name: "Kim",  age: 33, score: 90},
  %{name: "Park", age: 33, score: 95},
  %{name: "Lee",  age: 28, score: 88}
]

# 나이 오름차순, 점수 내림차순

Enum.sort_by(people, fn p -> {p.age, -p.score} end)
```

이 패턴의 의미:

- `sort_by`는 먼저 변환자(mapper)로 키를 만들고
- 그 키를 기준으로 sort 한다.

즉, “Schwartzian transform(키 먼저 계산)”을 디폴트로 해 주기 때문에
비교 비용이 줄어든다.

### C.4.2 커스텀 비교자

```elixir
Enum.sort_by(people, &{&1.age, &1.score}, fn {a1, s1}, {a2, s2} ->
  case a1 <=> a2 do
    :lt -> true
    :gt -> false
    :eq -> s1 >= s2
  end
end)
```

실전에서 비교자를 직접 쓰는 이유:

- “동률 처리 규칙”이 도메인에 달려 있을 때
- nil/특수값 정렬 규칙을 커스터마이즈할 때

### C.4.3 nil 포함 정렬 패턴

```elixir
xs = [%{v: 3}, %{v: nil}, %{v: 1}]

Enum.sort_by(xs, fn %{v: v} ->
  case v do
    nil -> {1, 0}   # nil은 뒤로
    n   -> {0, n}
  end
end)
# [%{v: 1}, %{v: 3}, %{v: nil}]

```

- “키를 튜플로 만들고 첫 번째 요소로 우선순위”를 주는 패턴이 단단하다.

### C.4.4 안정 정렬과 비용 모델

Elixir의 정렬은 안정적이다.
대략 비용은

$$
T \approx O(n \log n)\cdot(t_{\text{compare}} + t_{\text{mapper}})
$$

- 비교 비용이 크면 `sort_by`로 키를 미리 계산해 줄이는 게 이득이다.
- 대량 데이터에서 “키 계산이 매우 비싸면”
  변환 결과를 캐싱하는 것도 고려 가능하다.

---

## C.5 범위 타입 개선 (≈ 1.12)

Range는 “지연 열거 가능한 압축 표현”이다.

### C.5.1 정수 Range 꿀패턴

```elixir
Enum.to_list(5..1)       # [5,4,3,2,1]

3 in 1..5                 # true
Enum.slice(1..10, 3, 4)   # [4,5,6,7]

range = 1..1_000_000
range |> Stream.drop(999_990) |> Enum.take(5)
```

핵심:

- Range는 “값을 다 만들지 않고도” 열거할 수 있다.
- 대량 반복에서 **메모리와 GC 비용을 줄인다.**

### C.5.2 Range를 도메인 모델로 쓰는 패턴

예: 할인 구간 규칙

```elixir
defmodule C5.Discount do
  @spec rate(pos_integer()) :: non_neg_integer()
  def rate(price) do
    cond do
      price in 1..9_999   -> 0
      price in 10_000..49_999 -> 3
      price in 50_000..99_999 -> 7
      true -> 10
    end
  end
end
```

- 숫자 구간을 Range로 모델링하면 규칙이 “문장처럼 읽힌다.”

### C.5.3 날짜 Range

```elixir
r = Date.range(~D[2025-01-28], ~D[2025-02-02])
Enum.to_list(r)
```

실전에서 날짜 Range는

- 예약 기간
- SLA 기간
- 리포트 구간

같은 “달력 기반 도메인”에서 자주 등장한다.

교집합 체크 유틸:

```elixir
defmodule C5.DateRanges do
  def overlaps?(r1, r2), do: not Range.disjoint?(r1, r2)
end
```

---

## C.6 파이프라이닝 강화 (≈ 1.12)

`then/2`, `tap/2` 추가의 의미는 단순 문법 sugar가 아니다.
“파이프로 표현하기 애매했던 계산/계측을 파이프 안으로 끌고 오는 공식 도구”가 생겼다는 뜻이다.

### C.6.1 `then/2`

```elixir
"  Kim  "
|> String.trim()
|> then(&String.upcase/1)
|> then(fn up -> "Hello, " <> up end)
```

- 중간 값을 **람다 인자로** 받아 새 값을 만든다.
- 파이프 형태 유지 + 다중 인자 계산의 자연스러운 삽입이 가능.

#### 실전 예: 키가 두 개 필요한 상황

```elixir
user
|> then(fn u -> {u.id, u.plan} end)
|> then(fn {id, plan} -> Billing.charge(id, plan) end)
```

### C.6.2 `tap/2`

```elixir
1..5
|> Enum.map(& &1 * 2)
|> tap(&IO.inspect(&1, label: "after map"))
|> Enum.sum()
```

- **값을 그대로 흘려보내면서 부수효과만 수행**한다.
- 디버그/로깅/Telemetry 계측이 파이프 안에서 자연스러워진다.

#### 실전 예: Telemetry 계측

```elixir
data
|> tap(fn _ -> :telemetry.execute([:svc, :step1], %{count: 1}, %{}) end)
|> step1()
|> tap(fn _ -> :telemetry.execute([:svc, :step2], %{count: 1}, %{}) end)
|> step2()
```

- 계측 때문에 파이프를 깨뜨리지 않아도 된다.

---

## C.7 스크립팅 개선 (≈ 1.12)

**`Mix.install/2`** 로 스크립트 파일에서도 **의존성을 즉시 설치/사용** 가능해졌다.

### C.7.1 즉석 스크립트

```elixir
# script.exs

Mix.install([
  {:req, "~> 0.5"},
  {:jason, "~> 1.4"}
])

resp = Req.get!("https://httpbin.org/json").body
IO.puts(Jason.encode!(resp, pretty: true))
```

```bash
elixir script.exs
```

- “프로젝트 만들기 → mix.exs 편집 → deps.get” 없이
  바로 의존성을 쓴다.

### C.7.2 팀 운영 스크립트 패턴

예: 운영 진단 스크립트

```elixir
# diag.exs

Mix.install([{:jason, "~> 1.4"}])

defmodule Diag do
  def info do
    %{
      otp: :erlang.system_info(:otp_release),
      schedulers: :erlang.system_info(:schedulers_online),
      memory: :erlang.memory()
    }
  end
end

Diag.info()
|> Jason.encode!(pretty: true)
|> IO.puts()
```

- 운영에서 “노드 밖에서 BEAM을 재현하는” 도구로도 쓸 수 있다.
- 진단/배치/ETL/원오프 자동화가 Elixir로 훨씬 쉬워졌다.

---

## C.8 종합 예제 — Logger + then/tap + Mix.install로 “일일 리포트”

```elixir
# report.exs

Mix.install([
  {:req, "~> 0.5"},
  {:jason, "~> 1.4"}
])

require Logger
Logger.configure(truncate: :infinity, metadata: [:job, :count])
Logger.metadata(job: "daily_report")

"  https://httpbin.org/json  "
|> String.trim()
|> then(&Req.get!/1)
|> tap(&Logger.info("fetched: #{&1.status}"))
|> Map.fetch!(:body)
|> then(&Jason.encode!(&1, pretty: true))
|> tap(&Logger.metadata(count: byte_size(&1)))
|> tap(fn _ ->
  Logger.info("bytes=#{Logger.metadata()[:count]}")
end)
|> IO.puts()
```

이 예제 하나에 C.1, C.6, C.7의 실전 가치가 모두 들어간다.

- 스크립트 대화형 의존성 설치
- 파이프라인에 `then/tap`으로 데이터 흐름과 계측을 자연스럽게 삽입
- 구조적 메타데이터 로깅

---

## C.9 마이그레이션 체크리스트 (요약)

- Logger
  - `metadata` 키를 엄격히 관리(민감정보 금지)
  - `compile_time_purge_level` 로 prod 오버헤드 제거
  - 구조화 포맷(JSON 등) 도입
  - Task/프로세스에서 메타데이터 전파 패턴 확보
- Release
  - `mix release` 표준화
  - `runtime.exs`로 런타임 값 분리
  - `start/stop/restart/rpc/remote` 런북 작성
- Config
  - `import Config`로 이행
  - `compile_env` vs `get_env` 경계 재점검
- Sort/Range/Pipeline/Scripting
  - `Enum.sort_by/3` + 튜플 키 패턴 표준화
  - Range를 도메인 규칙에 적극 모델링
  - `then/2`, `tap/2`로 파이프라인 가독성/관측성 개선
  - 원오프/진단/ETL 스크립트에 `Mix.install/2` 채택

---

## C.10 마무리

Elixir 1.6 이후의 변화는 “개발자 문법의 편의”보다 더 큰 축을 가진다.

- Logger/Release/Config는 **운영·배포·관찰성**을 Elixir 표준으로 정리했고,
- Sort/Range/then·tap/Mix.install는 **코드 표현력과 DX**를 높였다.

이 부록은 “기능을 외우는 문서”가 아니라
**Elixir로 시스템을 만들 때 어떤 표준 패턴이 자연스럽게 되었는가**를 보여주는 실전 지침이다.

위의 예제와 체크리스트를 기준으로
레포지토리의 설정/로깅/배포/파이프라인을 한 번만 정리해도
시스템의 유지보수성과 운영 품질이 확연히 달라질 것이다.
