---
layout: post
title: TCPIP - TCP
date: 2025-08-29 23:25:23 +0900
category: TCPIP
---
# 9. TCP
**(🔰 3-way 핸드셰이크/종료·상태 다이어그램, 🔰 신뢰성: 재전송·슬라이딩 윈도우·흐름제어, ⚙️ 혼잡제어: Reno/NewReno·CUBIC·SACK·윈도우 스케일, ⚙️ Nagle·Delayed ACK·Keepalive·TIME_WAIT·MSL, 🚀 BBR 개념·MPTCP 개요·고성능/저지연 튜닝)**

> TCP는 “**바이트 스트림을 신뢰성 있게, 순서대로, Congestion Friendly 하게**” 전달하는 전송계층입니다.  
> 이 글은 **핸드셰이크→신뢰성→혼잡/흐름제어→세부 메커니즘→현대 확장(BBR/MPTCP)→튜닝** 순으로, **현장 예제·수식(MathJax)·체크리스트** 중심으로 정리합니다. 코드/명령은 ``` 로 표기합니다.

---

## 9.1 3-way 핸드셰이크 & 종료, 상태 다이어그램 (🔰)

### 9.1.1 연결 성립 (SYN → SYN/ACK → ACK)
```
클라이언트                                  서버
-----------                                  -----------
SEQ=x  SYN  ------------------------------->  LISTEN → SYN_RCVD
            <-------------------------------  SEQ=y, ACK=x+1  SYN/ACK
ACK=y+1 ----------------------------------->  ESTABLISHED
ESTABLISHED
```
- **초기 순번(ISN)**: 무작위/시간기반(보안·중복 방지).  
- **SYN 큐/백로그**: 대기 중인 반개방(half-open) 연결 보관. **SYN flood** 방어에 **SYN cookies** 등 사용.

### 9.1.2 종료(4-way 종료 기본)
```
클 → 서:  FIN, ACK    (클로즈)
서 → 클:  ACK (Half-close: 읽기만 가능)
서 → 클:  FIN, ACK
클 → 서:  ACK → TIME_WAIT (2*MSL 유지)
```
- **Half-close**: 한쪽 쓰기 종료 후 읽기는 가능(스트림 특성).  
- **TIME_WAIT(종료 대기)**: **지연된 중복 세그먼트가 이후 연결에 섞이지 않도록** 2*MSL 유지.

### 9.1.3 상태 다이어그램(요약)
```
CLOSED
  | active open(SYN)
SYN_SENT  <—(SYN)—  LISTEN
  |(SYN/ACK)           |(ACK)
ESTABLISHED  —(FIN)—> FIN_WAIT_1 —(ACK)—> FIN_WAIT_2
  |(FIN수신)           <—(FIN)—   CLOSE_WAIT —(FIN)→ LAST_ACK
  |(ACK)                               ^(ACK)
  v                                     |
TIME_WAIT <—(ACK)—  CLOSING  —(ACK)—>   CLOSED
```
- **비정상 종료**: `RST`로 즉시 닫기(에러/프로토콜 위반/포트 닫힘).

---

## 9.2 TCP 신뢰성: 재전송, 슬라이딩 윈도우, 흐름제어 (🔰)

### 9.2.1 바이트 스트림 & 시퀀스/ACK
- TCP는 **바이트 단위** 시퀀스 번호. ACK는 “**다음에 기대하는 바이트 번호**”(누적 ACK).  
- 수신자는 **수신 버퍼**가 허용하는 만큼만 광고(`rwnd`, receive window).

### 9.2.2 슬라이딩 윈도우(송신 윈도우)
- 송신 가능한 바이트 범위:  
  \[
  \text{snd\_una} \le \text{seq} < \text{snd\_una} + \min(\text{cwnd},\, \text{rwnd})
  \]
  - **cwnd**: 혼잡 윈도우(네트워크 상태).  
  - **rwnd**: 수신자 버퍼 기반 흐름제어(수신 여유).

### 9.2.3 재전송 & 손실 검출
- **RTO 기반 재전송**: 타이머 만료 시 재전송(지연변동 크면 RTO↑).  
- **Fast Retransmit**: **중복 ACK 3개** 수신 시(홀 검출) RTO 기다리지 않고 즉시 재전송.  
- **SACK**(선택적 확인)이 있으면 “**누락 구간만**” 재전송(§9.4.2).

### 9.2.4 RTT/RTO 추정(표준 근사)
- **Jacobson/Karels** 추정:
  \[
  \begin{aligned}
  \text{SRTT} &\leftarrow (1-\alpha)\cdot\text{SRTT} + \alpha\cdot \text{RTT}_{\text{sample}} \\
  \text{RTTVAR} &\leftarrow (1-\beta)\cdot\text{RTTVAR} + \beta\cdot |\text{RTT}_{\text{sample}}-\text{SRTT}| \\
  \text{RTO} &= \text{SRTT} + \max(G,\, K \cdot \text{RTTVAR})
  \end{aligned}
  \]
  - 통상 \(\alpha=1/8,\ \beta=1/4,\ K=4\).

### 9.2.5 흐름제어(rwnd)
- 수신자는 **윈도우 광고**로 송신자의 전송량을 제한.  
- **윈도우 고갈(0-window)** → 송신자는 **persist probe**로 창 재개 확인.

---

## 9.3 혼잡제어: Reno/NewReno, CUBIC (⚙️)

### 9.3.1 공통 원리
- **Slow Start**: \(\text{cwnd}\)를 매 RTT **2배** 증가(패킷/바이트 단위).  
- **Congestion Avoidance**: 선형 증가(대개 RTT당 **+1 MSS**).  
- **Loss** 발생 시: **감소**(Reno는 \(\text{cwnd}\to\frac{1}{2}\) 등), **ssthresh** 설정.

### 9.3.2 Reno / NewReno
- **Reno**: dupACK 기반 **Fast Retransmit/Recovery**.  
- **NewReno**: Fast Recovery 중 **여러 손실**을 더 잘 처리(Partial ACK).

### 9.3.3 CUBIC(현대 리눅스 기본)
- RTT 독립적 성장을 목표로 **시간 기반 3차 함수**:
  \[
  W(t) = C\,(t-K)^3 + W_{\max}
  \]
  - \(W_{\max}\): 마지막 손실 직전 윈도우, \(K\): \(W_{\max}\)로 복귀하는 시간.  
- 작은 RTT/큰 RTT 흐름 간 **공정성 개선**(Reno 대비).  
- 실무: WAN·DC 모두에서 **기본값으로 안정적**, ECN·RACK/TLP와 궁합良.

---

## 9.4 SACK, 윈도우 스케일, 대역폭-지연곱(BDP) (⚙️)

### 9.4.1 윈도우 스케일(Window Scale)
- TCP 헤더 윈도우 필드는 **16비트**(최대 65,535바이트).  
- **WSopt**로 \(\text{rwnd}_{\text{effective}} = \text{win} \times 2^{\text{scale}}\).  
- **BDP**가 큰 고속/장거리 링크에서 필수:
  \[
  \text{BDP} = \text{Bandwidth} \times \text{RTT}
  \]
  - 예: 1 Gbps, RTT 100 ms → \( \approx 12.5\ \text{MB} \) 창 필요.

### 9.4.2 SACK(Selective Acknowledgment)
- 수신자가 **수신된 구간 범위**(SACK block)를 알려줌 → 송신자는 **hole만** 재전송.  
- **DSACK**으로 **중복 전송 감지**, 재주문/스푸리어스 손실 판단에 도움.  
- 현대 스택: **RACK**(송신시간 기반 손실 탐지) + **TLP**(Tail Loss Probe)로 꼬리 손실 신속 탐지.

---

## 9.5 Nagle, Delayed ACK, Keepalive, TIME_WAIT, MSL (⚙️)

### 9.5.1 Nagle Algorithm
- **작은 세그먼트**(tinygram) 폭주 억제: “**미확인 데이터가 있으면** 새 소량 데이터는 **ACK 도착까지 묶어서** 보냄”.  
- **저지연 상호작용**(RPC/게임/SSH 키보드)에서는 **TCP_NODELAY**로 끄기도 함.  
- **Delayed ACK**와 **상호작용** 시 레이턴시 악화 가능(양쪽이 서로 기다리기).

### 9.5.2 Delayed ACK
- 수신자가 ACK를 **소폭 지연**(수 ms~40ms)해 **ACK 수를 절감**.  
- **Nagle+DelayedACK** 조합 → 왕복 추가 지연 유발(작은 write 다발).  
- 해결: **TCP_NODELAY**, **Coalescing**, **sendmsg()에서 묶기**, 어플 설계.

### 9.5.3 Keepalive
- 유휴 연결 생존 확인(기본 수 시간). 방화벽/NAT 환경에서는 너무 길어 **연결 소실**.  
- 앱 레벨 **Heartbeat**(수십 초~수분)가 현실적. OS의 `tcp_keepalive_*` 조정 가능.

### 9.5.4 TIME_WAIT & MSL
- **TIME_WAIT = 2 × MSL**. **지연 중복 세그먼트**가 차기 연결에 섞이는 것 방지.  
- MSL(최대 세그먼트 수명)은 구현 상수(전통 2분). **운영체제별 다름**.  
- TIME_WAIT 소켓이 많아도 **문제는 아님**(커널이 효율 처리).  
- 포트 재사용 이슈 시: **SO_REUSEADDR/REUSEPORT**(의미와 위험 이해 필수), **`tcp_tw_reuse`**(OS별 정책 확인).

---

## 9.6 혼잡제어 심화: ECN, CUBIC vs Reno, RACK/TLP (⚙️)

### 9.6.1 ECN(Explicit Congestion Notification)
- 라우터가 드롭 대신 **CE(혼잡경험) 마킹** → 수신자 **ECE** 알림 → 송신자 **CWR**로 반응.  
- 드롭 없이 혼잡 신호 획득 → **지연/손실 감소**. 네트워크 전반 지원 필요.

### 9.6.2 RACK/TLP
- **RACK**: 시퀀스 대신 **송신 시간** 기반 손실 판단 → 재주문에 강함.  
- **TLP**: 꼬리 손실 가설로 **마지막 데이터 재전송/프루브** → RTO 진입 전 복구.

---

## 9.7 BBR 개념(🚀)

### 9.7.1 핵심 아이디어
- “손실→혼잡” 가정 대신, **경로 대역폭(BtlBw)**와 **최소 RTT(RTprop)**를 추정.  
- 목표 전송률:
  \[
  \text{Rate} \approx \text{BtlBw}, \quad 
  \text{cwnd} \approx \text{BtlBw}\times\text{RTprop}\times \text{gain}
  \]
- **Pacing** 필수(간격 송신). **버퍼블로트** 환경에서 낮은 지연 달성.

### 9.7.2 모드
- **Startup**(증가), **Drain**(큐 배수), **ProbeBW**(주기적 탐색), **ProbeRTT**(최소 RTT 측정).  
- **BBR v2**: 공정성/혼잡지표(ECN/손실) 반응 강화.

### 9.7.3 적용 메모
- 데이터센터/와이드에 유리. **AQM(CoDel/FQ)**, **fq qdisc**와 궁합良.  
- TSO/GSO/신뢰성 옵션과 **pacing rate** 일치 필요(커널/NIC 오프로드 상호작용 확인).

---

## 9.8 MPTCP 개요(멀티패스 TCP) (🚀)

### 9.8.1 무엇을 푸나
- 하나의 논리 연결을 **여러 하위 경로(서브플로우)**에 분산/이중화(예: Wi-Fi+LTE 동시).  
- **핵심 옵션**: MP_CAPABLE, MP_JOIN, DSS(Data Sequence Signal).  
- **스케줄러**: 라운드로빈, 최소RTT, **중요 패킷 이중송신** 등.

### 9.8.2 이점/주의
- **장점**: 장애/핸드오버 시 끊김↓, **대역폭 통합**.  
- **주의**: NAT/방화벽·프록시 상호운용, 중간 박스가 옵션 스트립 가능. 서버·클라 양단 지원 필요.

---

## 9.9 고성능/저지연 튜닝 포인트 (🚀)

### 9.9.1 MTU/MSS/PMTUD
- **오버레이/태그** 고려해 **MSS 클램핑**(예: 1452/1432).  
- **ICMP Frag Needed/Too Big** 허용, **PLPMTUD** 고려.

### 9.9.2 큐/버퍼블로트·페이싱
- **fq/fq_codel** 큐디스크, **ECN** 활성화.  
- **Pacing**(CUBIC/BBR 모두 유익): burst 억제, 지연/손실↓.

### 9.9.3 윈도우/오토튜닝
- **tcp_rmem/tcp_wmem**(리눅스) 오토튜닝 상한 ↑, 큰 BDP에 맞춤.  
- **Window Scale·SACK·Timestamps** 활성화(기본 ON 권장).

### 9.9.4 Nagle/ACK 전략
- 레이턴시 민감한 앱: **TCP_NODELAY**, **send() 묶기**, **quickack**(상황에 맞게).  
- 반대로 대용량 스트리밍: Nagle 유지로 효율↑(앱 write 패턴 중요).

### 9.9.5 오프로드/제로카피
- **TSO/GSO/GRO/LRO** 점검(과도하면 지연↑, 적절하면 CPU↓).  
- **sendfile/splice/MSG_ZEROCOPY/io_uring**로 **카피/컨텍스트 스위치** 최소화.

### 9.9.6 보호/안정
- **SYN cookies**(피크 방어), **backlog** 적정화.  
- **tcp_tw_reuse/recycle**(OS 정책 숙지), **SO_REUSEPORT**로 **멀티워커 스케일**.  
- **RACK/TLP/ECN** 켜고, **CUBIC/BBR** 선택(A/B로 서비스별 검증).

---

## 9.10 예제 & 관찰(현장)

### 9.10.1 `ss`/`netstat`로 상태 보기
```bash
ss -tin     # ESTAB, cwnd/rwnd, rto, rtt, bbr 상태(커널에 따라)
ss -s       # 전체 소켓 통계
```

### 9.10.2 iperf3로 CC 비교
```bash
iperf3 -c <host> -t 30                     # 기본(CUBIC)
iperf3 -c <host> -t 30 -C bbr --pacing-timer 1000
```
- **지표**: 스루풋, P95 지연, 재전송률, 큐 길이(스위치/aqm), ECN 마킹율.

### 9.10.3 netem으로 손실/지연 재현
```bash
sudo tc qdisc add dev eth0 root fq_codel
sudo tc qdisc change dev eth0 root netem delay 50ms 5ms loss 1%
# 복구
sudo tc qdisc del dev eth0 root
```

### 9.10.4 tcpdump 스니퍼
```bash
tcpdump -nnvvvi eth0 'tcp[tcpflags] & (tcp-syn|tcp-fin|tcp-rst) != 0'
tcpdump -nnvi eth0 'tcp and host <peer>'  # SACK/TSecr 관찰
```

---

## 9.11 수식/감각 메모

### 9.11.1 처리량 근사
\[
\text{Throughput} \approx \frac{\text{cwnd}}{\text{RTT}}
\quad (\text{바이트/초, cwnd는 바이트})
\]

### 9.11.2 AIMD (Additive-Increase/Multiplicative-Decrease)
\[
\text{cwnd} \leftarrow 
\begin{cases}
\text{cwnd} + \frac{\text{MSS}^2}{\text{cwnd}} & \text{(ACK마다, RTT당 +1 MSS)}\\[4pt]
\beta \cdot \text{cwnd} & \text{(손실 시, }\beta\approx 0.5\text{)}
\end{cases}
\]

### 9.11.3 BDP/버퍼
\[
\text{필요 창} \ge \text{BDP} = \text{BW}\times\text{RTT}
\Rightarrow \text{rwnd/cwnd/버퍼} \ge \text{BDP}
\]

---

## 9.12 트러블슈팅 체크리스트

### 9.12.1 연결/종료
```text
- SYN 보냄? SYN/ACK 수신? (방화벽/백로그/SYN cookies)
- FIN/ACK 순서/상태 전이 정상? TIME_WAIT 대량은 정상 범주?
- RST 빈발: 포트 닫힘/타임아웃/프로토콜 위반/미스매치
```

### 9.12.2 성능/지연
```text
- BDP 대비 윈도우/버퍼 부족? (윈도우 스케일/오토튜닝)
- 재전송률/듀플ACK↑: 손실/리오더링? (RACK/TLP, AQM/ECN)
- Tinygram: Nagle/Delayed ACK 상호작용? (NODELAY/코알레싱)
- PMTUD/ICMP 차단? (큰 응답만 끊김)
```

### 9.12.3 서버/OS
```text
- 큐디스크(fq/fq_codel), pacing on, ECN
- tcp_sack/timestamps on, rack/tlp on(커널 옵션)
- rmem/wmem, somaxconn/backlog, reuseport
```

---

## 9.13 베스트 프랙티스(요약 카드)

- **핸드셰이크/종료**: 3-way/4-way, TIME_WAIT 이해. SYN cookies 준비.  
- **신뢰성**: SACK/RACK/TLP로 빠른 복구. RTT/RTO 추정 안정.  
- **혼잡**: CUBIC 기본, ECN/AQM로 지연↓. BBR는 서비스 특성에 맞춰 A/B.  
- **윈도우/BDP**: Window Scale 필수, 오토튜닝 상한↑.  
- **작은 패킷 지연**: Nagle↔DelayedACK 상호작용 주의, 필요시 NODELAY.  
- **MTU/MSS**: 오버레이 고려 MSS 클램핑, PMTUD/ICMP 허용.  
- **큐/페이싱**: fq(_codel)+pacing, 버퍼블로트 억제.  
- **현대 기능**: MPTCP로 다중 경로/이중화, zero-copy로 CPU↓.

---

## 9.14 한 장 요약(포스터)

- **TCP = 신뢰·순서·혼잡친화**. 슬라이딩 윈도우로 ACK 기반 제어.  
- **Reno/NewReno→CUBIC**(기본), **SACK/RACK/TLP**로 빠른 손실 복구.  
- **ECN/AQM**과 **Pacing**으로 낮은 지연. **BBR**는 대역폭·RTT 기반 제어.  
- **MPTCP**로 경로 이중화/합산.  
- **튜닝 키워드**: BDP/윈도우 스케일, MSS/PMTUD, Nagle/ACK, 큐/페이싱, 오토튜닝/제로카피.

---

### 부록 A — 리눅스 주요 sysctl(예시)
```bash
# 혼잡제어/큐/ECN
sysctl -w net.ipv4.tcp_congestion_control=cubic          # or bbr
sysctl -w net.ipv4.tcp_ecn=1
tc qdisc replace dev eth0 root fq                         # pacing-friendly

# 윈도우/버퍼 오토튜닝 상한 (값은 환경에 맞게)
sysctl -w net.ipv4.tcp_rmem="4096 87380 134217728"
sysctl -w net.ipv4.tcp_wmem="4096 65536 134217728"
sysctl -w net.core.rmem_max=134217728
sysctl -w net.core.wmem_max=134217728

# SACK/Timestamps/RACK/TLP (커널에 따라 기본 ON)
sysctl -w net.ipv4.tcp_sack=1
sysctl -w net.ipv4.tcp_timestamps=1
sysctl -w net.ipv4.tcp_recovery=1      # RACK
sysctl -w net.ipv4.tcp_early_retrans=1 # TLP 유사 기능

# TIME_WAIT/백로그
sysctl -w net.ipv4.tcp_max_syn_backlog=4096
sysctl -w net.core.somaxconn=4096
```

### 부록 B — 앱 설계 체크리스트
```text
[전송] write() 코알레싱 / NODELAY 필요성 / sendfile·zerocopy
[복구] SACK 가정, 타임아웃과 재시도 정책 앱 측에서 중복 처리
[프로토콜] 메시지 경계(프레이밍) / 길이 프리픽스 / 헤더·바디 설계
[측정] RTT/재전송률/ACK 지연/큐 지표/ECN 비율/초당 스팬
```

### 부록 C — 관찰 템플릿
```text
[환경] RTT, 대역폭, BDP, MTU, 큐 정책(AQM/ECN), NAT/방화벽
[증상] 낮은 스루풋/지연 증가/짧은 메시지 지연/꼬리 손실
[가설] 윈도우 부족/버퍼블로트/PMTUD/ACK 전략/Nagle/손실/리오더링
[근거] ss -tin, tcpdump SACK/TS/ECN, 큐 길이, 재전송/TLP 트리거
[조치] 윈도우/버퍼↑, fq(_codel)+pacing, ECN, MSS 클램핑, NODELAY, RACK/TLP
[후속] A/B (CUBIC vs BBR), 지표 대시보드, 런북 업데이트
```