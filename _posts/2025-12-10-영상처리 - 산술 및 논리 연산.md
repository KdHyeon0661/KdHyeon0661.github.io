---
layout: post
title: 영상처리 - 산술 및 논리 연산 (C#)
date: 2025-12-10 20:30:23 +0900
category: 영상처리
---
# 산술 및 논리 연산: 영상 처리의 기본 연산 체계

## 산술 연산의 개요와 중요성

산술 연산은 **두 영상 간 픽셀 값의 수치적 결합**을 통해 다양한 영상 처리 작업을 수행하는 기본 기술이다. 이 연산들은 다음과 같은 주요 용도로 사용된다:
- **차이 강조**: 시간적 변화, 움직임 검출
- **평균화**: 노이즈 감소, 다중 노출 합성
- **마스킹**: 특정 영역 추출 또는 제거
- **융합**: 다중 영상 정보 통합

모든 산술 연산은 동일한 크기의 두 영상 $$f(x,y), g(x,y)$$를 입력으로 하며, 픽셀 단위로 독립적으로 적용된다.

---

## 기본 산술 연산의 수학적 모델

### 일반화된 산술 연산 모델

$$
h(x,y) = \alpha \cdot f(x,y) + \beta \cdot g(x,y) + \gamma
$$

여기서:
- $$\alpha, \beta$$: 가중치 계수
- $$\gamma$$: 오프셋 값
- 결과는 반드시 $$[0, L-1]$$ 범위로 클램핑됨 (8비트 영상의 경우 $$L=256$$)

---

## 영상 간 덧셈 (Addition)

### 수학적 정의 및 특성

$$
h(x,y) = f(x,y) + g(x,y)
$$

**물리적 의미**: 
- 두 영상의 신호 에너지 합산
- 노이즈 평균화 효과 (다중 노출 합성)
- 중첩 효과 생성

### 고수준 API 설계

```csharp
public interface IImageArithmetic
{
    /// <summary>
    /// 두 영상의 픽셀 단위 덧셈 수행
    /// </summary>
    /// <param name="a">첫 번째 입력 영상</param>
    /// <param name="b">두 번째 입력 영상</param>
    /// <param name="useAverage">평균화 사용 여부</param>
    /// <returns>결과 영상</returns>
    MyImage Add(MyImage a, MyImage b, bool useAverage = false);
    
    /// <summary>
    /// 가중치를 적용한 영상 덧셈
    /// </summary>
    MyImage WeightedAdd(MyImage a, MyImage b, double weightA, double weightB);
}
```

### 구현 상세: 다중 전략 패턴

```csharp
public class ImageArithmeticProcessor : IImageArithmetic
{
    // 기본 덧셈 구현
    public MyImage Add(MyImage a, MyImage b, bool useAverage = false)
    {
        ValidateInputs(a, b);
        
        MyImage dst = new MyImage(a.Width, a.Height);
        int size = a.Width * a.Height;
        
        if (useAverage)
        {
            // 평균화 모드: 오버플로우 방지
            for (int i = 0; i < size; i++)
            {
                int sum = a.Buffer[i] + b.Buffer[i];
                dst.Buffer[i] = (byte)(sum / 2);
            }
        }
        else
        {
            // 직접 합산 모드 (클램핑 적용)
            for (int i = 0; i < size; i++)
            {
                int sum = a.Buffer[i] + b.Buffer[i];
                dst.Buffer[i] = Clamp(sum);
            }
        }
        
        return dst;
    }
    
    // 가중치 적용 덧셈
    public MyImage WeightedAdd(MyImage a, MyImage b, double weightA, double weightB)
    {
        ValidateInputs(a, b);
        
        MyImage dst = new MyImage(a.Width, a.Height);
        int size = a.Width * a.Height;
        
        for (int i = 0; i < size; i++)
        {
            double value = a.Buffer[i] * weightA + b.Buffer[i] * weightB;
            dst.Buffer[i] = Clamp((int)Math.Round(value));
        }
        
        return dst;
    }
    
    // 영상 결합을 위한 다양한 전략
    public enum BlendMode { Add, Screen, LinearDodge }
    
    public MyImage Blend(MyImage a, MyImage b, BlendMode mode)
    {
        ValidateInputs(a, b);
        
        MyImage dst = new MyImage(a.Width, a.Height);
        int size = a.Width * a.Height;
        
        for (int i = 0; i < size; i++)
        {
            double va = a.Buffer[i] / 255.0;
            double vb = b.Buffer[i] / 255.0;
            double result = 0;
            
            switch (mode)
            {
                case BlendMode.Add:
                    result = va + vb;
                    break;
                case BlendMode.Screen:
                    result = 1 - (1 - va) * (1 - vb);
                    break;
                case BlendMode.LinearDodge:
                    result = Math.Min(va + vb, 1.0);
                    break;
            }
            
            dst.Buffer[i] = (byte)(result * 255);
        }
        
        return dst;
    }
}
```

### 성능 최적화: SIMD 및 병렬 처리

```csharp
public unsafe MyImage AddOptimized(MyImage a, MyImage b)
{
    ValidateInputs(a, b);
    
    MyImage dst = new MyImage(a.Width, a.Height);
    int size = a.Width * a.Height;
    
    // SIMD 사용 가능 여부 확인
    if (Vector.IsHardwareAccelerated && size >= Vector<byte>.Count)
    {
        ProcessWithSIMD(a, b, dst);
    }
    else
    {
        // 병렬 처리 적용
        Parallel.For(0, size, i =>
        {
            int sum = a.Buffer[i] + b.Buffer[i];
            dst.Buffer[i] = Clamp(sum);
        });
    }
    
    return dst;
}

private unsafe void ProcessWithSIMD(MyImage a, MyImage b, MyImage dst)
{
    int size = a.Width * a.Height;
    fixed (byte* pA = a.Buffer, pB = b.Buffer, pDst = dst.Buffer)
    {
        int i = 0;
        int vectorSize = Vector<byte>.Count;
        
        for (; i <= size - vectorSize; i += vectorSize)
        {
            var vecA = new Vector<byte>(pA + i);
            var vecB = new Vector<byte>(pB + i);
            
            // 벡터화된 덧셈 (16비트로 확장하여 오버플로우 처리)
            var vecA16 = Vector.Widen(vecA);
            var vecB16 = Vector.Widen(vecB);
            var sumLow = vecA16.Item1 + vecB16.Item1;
            var sumHigh = vecA16.Item2 + vecB16.Item2;
            
            // 클램핑 및 저장
            var resultLow = Vector.Narrow(Vector.Min(sumLow, new Vector<ushort>(255)), new Vector<ushort>(0));
            var resultHigh = Vector.Narrow(Vector.Min(sumHigh, new Vector<ushort>(255)), new Vector<ushort>(0));
            
            // 결과 저장
            var result = Vector.Narrow(resultLow, resultHigh);
            result.CopyTo(pDst + i);
        }
        
        // 나머지 처리
        for (; i < size; i++)
        {
            pDst[i] = Clamp(pA[i] + pB[i]);
        }
    }
}
```

---

## 영상 간 뺄셈 (Subtraction)

### 수학적 정의 및 응용

$$
h(x,y) = |f(x,y) - g(x,y)|
$$

**주요 응용 분야**:
1. **움직임 검출**: 연속 프레임 간 차이 분석
2. **배경 제거**: 배경 모델과의 차이 계산
3. **변화 탐지**: 시계열 영상 분석
4. **에지 검출**: 영상 간 경계 강조

### 구현: 고급 차분 알고리즘

```csharp
public class ImageSubtraction
{
    // 기본 차분 연산
    public MyImage Subtract(MyImage a, MyImage b, bool absolute = true)
    {
        ValidateInputs(a, b);
        
        MyImage dst = new MyImage(a.Width, a.Height);
        int size = a.Width * a.Height;
        
        for (int i = 0; i < size; i++)
        {
            int diff = a.Buffer[i] - b.Buffer[i];
            if (absolute) diff = Math.Abs(diff);
            dst.Buffer[i] = Clamp(diff);
        }
        
        return dst;
    }
    
    // 임계값 적용 차분 (노이즈 제거)
    public MyImage ThresholdSubtract(
        MyImage a, 
        MyImage b, 
        byte threshold,
        bool binaryOutput = false)
    {
        ValidateInputs(a, b);
        
        MyImage dst = new MyImage(a.Width, a.Height);
        int size = a.Width * a.Height;
        
        for (int i = 0; i < size; i++)
        {
            int diff = Math.Abs(a.Buffer[i] - b.Buffer[i]);
            
            if (binaryOutput)
            {
                // 이진화 출력: 임계값 이상이면 255, 아니면 0
                dst.Buffer[i] = (diff >= threshold) ? (byte)255 : (byte)0;
            }
            else
            {
                // 스케일된 출력: 차이 값을 0-255로 정규화
                if (diff >= threshold)
                {
                    // 차이를 강조하여 표시
                    int scaled = 128 + diff / 2;
                    dst.Buffer[i] = Clamp(scaled);
                }
                else
                {
                    // 임계값 미만은 배경으로 처리
                    dst.Buffer[i] = 0;
                }
            }
        }
        
        return dst;
    }
    
    // 배경 제거 알고리즘
    public MyImage BackgroundSubtraction(
        MyImage currentFrame,
        MyImage backgroundModel,
        byte learningRate = 10)
    {
        ValidateInputs(currentFrame, backgroundModel);
        
        MyImage foreground = new MyImage(currentFrame.Width, currentFrame.Height);
        MyImage updatedBackground = new MyImage(backgroundModel.Width, backgroundModel.Height);
        
        int size = currentFrame.Width * currentFrame.Height;
        
        for (int i = 0; i < size; i++)
        {
            byte current = currentFrame.Buffer[i];
            byte background = backgroundModel.Buffer[i];
            
            // 배경 차이 계산
            int diff = Math.Abs(current - background);
            
            // 전경/배경 분리
            if (diff > 30)  // 임계값
            {
                foreground.Buffer[i] = current;  // 전경
            }
            else
            {
                foreground.Buffer[i] = 0;  // 배경
                
                // 배경 모델 업데이트 (적응형 배경 모델링)
                // B(t+1) = (1-α)B(t) + αI(t)
                int updated = background + (current - background) * learningRate / 255;
                updatedBackground.Buffer[i] = Clamp(updated);
            }
        }
        
        return foreground;
    }
}
```

### 차분 연산의 시각화 파이프라인

```
프레임 N-1 ───┐
              ├─→ 차분 연산 ──→ 차이 영상 ──→ 임계값 처리 ──→ 이진 마스크
프레임 N   ───┘
                      │
                      ↓
                변화 영역 검출
                      │
                      ↓
                움직임 분석/추적
```

---

## 영상 평균화 (Averaging)

### 수학적 정의 및 노이즈 감소 이론

$$
h(x,y) = \frac{1}{N} \sum_{i=1}^{N} f_i(x,y)
$$

**노이즈 감소 원리**:
- 가우시안 노이즈의 경우 평균화로 표준편차가 $$1/\sqrt{N}$$로 감소
- 독립적인 노이즈 성분은 상쇄됨

### 구현: 다중 프레임 평균화

```csharp
public class ImageAveraging
{
    // 다중 영상 평균화
    public MyImage AverageImages(List<MyImage> images)
    {
        if (images == null || images.Count == 0)
            throw new ArgumentException("입력 영상 목록이 비어있습니다.");
        
        // 기준 영상 크기
        int width = images[0].Width;
        int height = images[0].Height;
        
        // 누적 합 배열 (32비트 정수로 오버플로우 방지)
        int[] accumulator = new int[width * height];
        
        // 모든 영상 누적
        foreach (var image in images)
        {
            ValidateSize(image, width, height);
            
            for (int i = 0; i < accumulator.Length; i++)
            {
                accumulator[i] += image.Buffer[i];
            }
        }
        
        // 평균 계산
        MyImage result = new MyImage(width, height);
        int count = images.Count;
        
        for (int i = 0; i < accumulator.Length; i++)
        {
            result.Buffer[i] = (byte)(accumulator[i] / count);
        }
        
        return result;
    }
    
    // 점진적 평균화 (실시간 처리용)
    public class IncrementalAverager
    {
        private long[] _sum;
        private int _count;
        private readonly int _width, _height;
        
        public IncrementalAverager(int width, int height)
        {
            _width = width;
            _height = height;
            _sum = new long[width * height];
            _count = 0;
        }
        
        public void AddFrame(MyImage frame)
        {
            ValidateSize(frame, _width, _height);
            
            for (int i = 0; i < _sum.Length; i++)
            {
                _sum[i] += frame.Buffer[i];
            }
            
            _count++;
        }
        
        public MyImage GetAverage()
        {
            if (_count == 0)
                return new MyImage(_width, _height);
            
            MyImage result = new MyImage(_width, _height);
            
            for (int i = 0; i < _sum.Length; i++)
            {
                result.Buffer[i] = (byte)(_sum[i] / _count);
            }
            
            return result;
        }
        
        public void Reset()
        {
            Array.Clear(_sum, 0, _sum.Length);
            _count = 0;
        }
    }
    
    // 가중 이동 평균 (최근 프레임 강조)
    public MyImage WeightedMovingAverage(
        MyImage currentAverage,
        MyImage newFrame,
        double alpha = 0.1)
    {
        ValidateInputs(currentAverage, newFrame);
        
        MyImage result = new MyImage(currentAverage.Width, currentAverage.Height);
        int size = currentAverage.Width * currentAverage.Height;
        
        // EMA: Avg(t) = α * Frame(t) + (1-α) * Avg(t-1)
        for (int i = 0; i < size; i++)
        {
            double avg = currentAverage.Buffer[i];
            double frame = newFrame.Buffer[i];
            double newAvg = alpha * frame + (1 - alpha) * avg;
            
            result.Buffer[i] = (byte)Math.Round(newAvg);
        }
        
        return result;
    }
}
```

---

## 영상 차이의 고급 응용

### 변화 검출 시스템

```csharp
public class ChangeDetectionSystem
{
    public class DetectionResult
    {
        public MyImage DifferenceMap { get; set; }
        public MyImage BinaryMask { get; set; }
        public double ChangePercentage { get; set; }
        public List<Rectangle> ChangedRegions { get; set; }
    }
    
    public DetectionResult DetectChanges(
        MyImage previousFrame,
        MyImage currentFrame,
        byte threshold = 30,
        int minRegionSize = 100)
    {
        ValidateInputs(previousFrame, currentFrame);
        
        // 1. 차이 영상 계산
        MyImage difference = new MyImage(previousFrame.Width, previousFrame.Height);
        MyImage binaryMask = new MyImage(previousFrame.Width, previousFrame.Height);
        
        int totalPixels = previousFrame.Width * previousFrame.Height;
        int changedPixels = 0;
        
        for (int i = 0; i < totalPixels; i++)
        {
            int diff = Math.Abs(previousFrame.Buffer[i] - currentFrame.Buffer[i]);
            difference.Buffer[i] = Clamp(diff);
            
            // 이진 마스크 생성
            if (diff > threshold)
            {
                binaryMask.Buffer[i] = 255;
                changedPixels++;
            }
            else
            {
                binaryMask.Buffer[i] = 0;
            }
        }
        
        // 2. 변화 영역 군집화
        var regions = FindConnectedRegions(binaryMask, minRegionSize);
        
        // 3. 결과 생성
        return new DetectionResult
        {
            DifferenceMap = difference,
            BinaryMask = binaryMask,
            ChangePercentage = (double)changedPixels / totalPixels * 100,
            ChangedRegions = regions
        };
    }
    
    private List<Rectangle> FindConnectedRegions(
        MyImage binaryMask, 
        int minSize)
    {
        // 연결 요소 분석 구현
        // (BFS/DFS를 사용한 영역 군집화)
        var regions = new List<Rectangle>();
        
        // TODO: 실제 연결 요소 분석 구현
        // 간단한 구현 예시:
        bool[,] visited = new bool[binaryMask.Width, binaryMask.Height];
        
        for (int y = 0; y < binaryMask.Height; y++)
        {
            for (int x = 0; x < binaryMask.Width; x++)
            {
                if (binaryMask.Buffer[y * binaryMask.Width + x] > 0 && !visited[x, y])
                {
                    var region = FloodFill(binaryMask, x, y, visited);
                    if (region.Width * region.Height >= minSize)
                    {
                        regions.Add(region);
                    }
                }
            }
        }
        
        return regions;
    }
    
    private Rectangle FloodFill(MyImage mask, int startX, int startY, bool[,] visited)
    {
        // 간단한 플러드 필 구현
        // 실제 구현은 큐를 사용한 BFS로 작성
        int minX = startX, maxX = startX;
        int minY = startY, maxY = startY;
        int pixelCount = 0;
        
        // ... 플러드 필 알고리즘 구현 ...
        
        return new Rectangle(minX, minY, maxX - minX + 1, maxY - minY + 1);
    }
}
```

---

## 클램핑(Saturate) 처리의 고급 기법

### 다양한 클램핑 전략

```csharp
public static class ClampingStrategies
{
    // 기본 클램핑
    public static byte ClampBasic(int value)
    {
        if (value < 0) return 0;
        if (value > 255) return 255;
        return (byte)value;
    }
    
    // 선형 스케일링 클램핑
    public static byte ClampWithScaling(int value, int minInput, int maxInput)
    {
        if (minInput == maxInput) return 0;
        
        // 선형 매핑: [minInput, maxInput] -> [0, 255]
        double scaled = (value - minInput) * 255.0 / (maxInput - minInput);
        return ClampBasic((int)Math.Round(scaled));
    }
    
    // 감마 보정 클램핑
    public static byte ClampWithGamma(int value, double gamma = 2.2)
    {
        double normalized = value / 255.0;
        double corrected = Math.Pow(normalized, gamma);
        return (byte)(corrected * 255);
    }
    
    // S자형 곡선 클램핑 (소프트 클램핑)
    public static byte ClampSigmoid(int value, double steepness = 5.0)
    {
        double x = value / 255.0 * 2 - 1;  // [-1, 1] 범위로 정규화
        double sigmoid = 1.0 / (1.0 + Math.Exp(-steepness * x));
        return (byte)(sigmoid * 255);
    }
    
    // 적응형 클램핑 (히스토그램 기반)
    public static byte[] CreateAdaptiveClampingLUT(int[] histogram, double clipPercentage = 1.0)
    {
        byte[] lut = new byte[256];
        int totalPixels = histogram.Sum();
        int clipPixels = (int)(totalPixels * clipPercentage / 100.0 / 2);
        
        // 하한값 찾기
        int count = 0;
        int low = 0;
        for (int i = 0; i < 256; i++)
        {
            count += histogram[i];
            if (count > clipPixels)
            {
                low = i;
                break;
            }
        }
        
        // 상한값 찾기
        count = 0;
        int high = 255;
        for (int i = 255; i >= 0; i--)
        {
            count += histogram[i];
            if (count > clipPixels)
            {
                high = i;
                break;
            }
        }
        
        // LUT 생성
        if (high <= low)
        {
            // 모든 값을 중간값으로 매핑
            byte middle = 128;
            for (int i = 0; i < 256; i++) lut[i] = middle;
        }
        else
        {
            // 선형 매핑
            double scale = 255.0 / (high - low);
            for (int i = 0; i < 256; i++)
            {
                int mapped;
                if (i <= low) mapped = 0;
                else if (i >= high) mapped = 255;
                else mapped = (int)((i - low) * scale);
                
                lut[i] = (byte)Math.Clamp(mapped, 0, 255);
            }
        }
        
        return lut;
    }
}
```

---

## 비트 평면 분할 (Bit Plane Slicing)의 고급 기법

### 비트 평면의 이론적 의미

8비트 영상은 8개의 이진 평면으로 구성되며, 각 평면은 다른 정보를 담고 있다:

```
비트 위치 | 정보 내용 | 시각적 중요도
----------|-----------|-------------
b7 (MSB)  | 대략적 명암 구조 | 매우 높음
b6        | 주요 에지 정보 | 높음
b5        | 세부 텍스처 | 중간
b4        | 미세 텍스처 | 낮음
b3        | 노이즈/세부사항 | 매우 낮음
b2        | 무작위 패턴 | 거의 없음
b1        | 임의 노이즈 | 없음
b0 (LSB)  | 최소 비트 정보 | 무시 가능
```

### 구현: 고급 비트 평면 처리

```csharp
public class BitPlaneAnalyzer
{
    // 모든 비트 평면 추출
    public MyImage[] ExtractAllBitPlanes(MyImage src)
    {
        MyImage[] planes = new MyImage[8];
        
        for (int bit = 0; bit < 8; bit++)
        {
            planes[bit] = ExtractBitPlane(src, bit, true);
        }
        
        return planes;
    }
    
    // 특정 비트 평면 추출
    public MyImage ExtractBitPlane(
        MyImage src, 
        int bitPosition, 
        bool normalize = true)
    {
        if (bitPosition < 0 || bitPosition > 7)
            throw new ArgumentOutOfRangeException(nameof(bitPosition));
        
        MyImage plane = new MyImage(src.Width, src.Height);
        int size = src.Width * src.Height;
        
        byte multiplier = normalize ? (byte)255 : (byte)1;
        
        for (int i = 0; i < size; i++)
        {
            byte value = (byte)((src.Buffer[i] >> bitPosition) & 1);
            plane.Buffer[i] = (byte)(value * multiplier);
        }
        
        return plane;
    }
    
    // 비트 평면 재구성 (비트 제거 효과 시뮬레이션)
    public MyImage ReconstructFromBitPlanes(
        MyImage[] planes, 
        bool[] usePlane)
    {
        if (planes.Length != 8 || usePlane.Length != 8)
            throw new ArgumentException("8개 평면이 필요합니다.");
        
        MyImage reconstructed = new MyImage(planes[0].Width, planes[0].Height);
        int size = reconstructed.Width * reconstructed.Height;
        
        for (int i = 0; i < size; i++)
        {
            byte value = 0;
            
            for (int bit = 0; bit < 8; bit++)
            {
                if (usePlane[bit])
                {
                    // 평면 값 추출 (정규화된 경우 255, 아닌 경우 1)
                    byte planeValue = planes[bit].Buffer[i];
                    if (planeValue > 0)  // 0 또는 255 (정규화된 경우)
                    {
                        value |= (byte)(1 << bit);
                    }
                }
            }
            
            reconstructed.Buffer[i] = value;
        }
        
        return reconstructed;
    }
    
    // 비트 평면 중요도 분석
    public double[] AnalyzeBitPlaneImportance(MyImage src)
    {
        double[] importance = new double[8];
        int size = src.Width * src.Height;
        
        // 각 비트 평면의 정보량 계산
        for (int bit = 0; bit < 8; bit++)
        {
            MyImage plane = ExtractBitPlane(src, bit, false);
            
            // 엔트로피 계산 (정보량 측정)
            double entropy = CalculateEntropy(plane);
            importance[bit] = entropy;
        }
        
        // 중요도 정규화
        double max = importance.Max();
        if (max > 0)
        {
            for (int i = 0; i < 8; i++)
            {
                importance[i] /= max;
            }
        }
        
        return importance;
    }
    
    private double CalculateEntropy(MyImage binaryImage)
    {
        int ones = 0;
        int size = binaryImage.Width * binaryImage.Height;
        
        for (int i = 0; i < size; i++)
        {
            if (binaryImage.Buffer[i] > 0) ones++;
        }
        
        double p1 = (double)ones / size;
        double p0 = 1 - p1;
        
        // 이진 엔트로피 계산
        if (p0 == 0 || p1 == 0) return 0;
        
        return -p0 * Math.Log(p0, 2) - p1 * Math.Log(p1, 2);
    }
    
    // 비트 평면 시각화
    public MyImage CreateBitPlaneVisualization(MyImage src)
    {
        // 2x4 그리드로 비트 평면 배치
        int gridCols = 4;
        int gridRows = 2;
        int planeWidth = src.Width / gridCols;
        int planeHeight = src.Height / gridRows;
        
        MyImage visualization = new MyImage(src.Width, src.Height);
        
        for (int bit = 0; bit < 8; bit++)
        {
            MyImage plane = ExtractBitPlane(src, bit, true);
            
            int col = bit % gridCols;
            int row = bit / gridCols;
            int offsetX = col * planeWidth;
            int offsetY = row * planeHeight;
            
            // 평면을 그리드 위치에 복사
            for (int y = 0; y < planeHeight && y < plane.Height; y++)
            {
                for (int x = 0; x < planeWidth && x < plane.Width; x++)
                {
                    int srcIndex = y * plane.Width + x;
                    int dstIndex = (offsetY + y) * visualization.Width + (offsetX + x);
                    visualization.Buffer[dstIndex] = plane.Buffer[srcIndex];
                }
            }
            
            // 비트 번호 표시 (간단한 텍스트 오버레이)
            DrawBitLabel(visualization, offsetX, offsetY, $"Bit {bit}");
        }
        
        return visualization;
    }
    
    private void DrawBitLabel(MyImage image, int x, int y, string label)
    {
        // 간단한 텍스트 렌더링 (예시)
        // 실제 구현은 폰트 렌더링 시스템 필요
        byte[] labelBytes = System.Text.Encoding.ASCII.GetBytes(label);
        
        for (int i = 0; i < labelBytes.Length && i < 10; i++)
        {
            int px = x + i * 6;
            int py = y + 5;
            
            if (px < image.Width && py < image.Height)
            {
                image.Buffer[py * image.Width + px] = 255;  // 흰색 픽셀
            }
        }
    }
}
```

### 비트 평면 응용: 영상 압축 및 워터마킹

```csharp
public class BitPlaneApplications
{
    // LSB 스테가노그래피 (정보 은닉)
    public MyImage EmbedMessage(MyImage cover, byte[] message, int startBit = 0)
    {
        MyImage stegoImage = new MyImage(cover.Width, cover.Height);
        Array.Copy(cover.Buffer, stegoImage.Buffer, cover.Buffer.Length);
        
        int messageIndex = 0;
        int bitIndex = 0;
        
        for (int i = 0; i < cover.Buffer.Length && messageIndex < message.Length; i++)
        {
            // 현재 메시지 비트 추출
            if (bitIndex == 0)
            {
                if (messageIndex >= message.Length) break;
            }
            
            byte currentBit = (byte)((message[messageIndex] >> bitIndex) & 1);
            
            // LSB 수정
            byte pixel = stegoImage.Buffer[i];
            pixel = (byte)((pixel & 0xFE) | currentBit);  // LSB 교체
            
            stegoImage.Buffer[i] = pixel;
            
            // 비트 인덱스 업데이트
            bitIndex++;
            if (bitIndex >= 8)
            {
                bitIndex = 0;
                messageIndex++;
            }
        }
        
        return stegoImage;
    }
    
    // 비트 평면 기반 압축 (손실 압축 시뮬레이션)
    public MyImage CompressByRemovingBitPlanes(
        MyImage src, 
        int planesToKeep)
    {
        MyImage compressed = new MyImage(src.Width, src.Height);
        
        // 상위 planesToKeep개 비트 평면만 유지
        int mask = 0;
        for (int i = 7; i > 7 - planesToKeep; i--)
        {
            mask |= (1 << i);
        }
        
        for (int i = 0; i < src.Buffer.Length; i++)
        {
            compressed.Buffer[i] = (byte)(src.Buffer[i] & mask);
        }
        
        return compressed;
    }
}
```

---

## 논리 연산 (Logical Operations)의 심화 분석

### 논리 연산의 수학적 기초

논리 연산은 불린 대수(Boolean Algebra)에 기반하며, 픽셀 값을 이진 비트열로 해석하여 작동한다.

**기본 연산 규칙**:
- AND (∧): 두 비트 모두 1일 때만 1
- OR (∨): 두 비트 중 하나 이상이 1일 때 1
- XOR (⊕): 두 비트가 다를 때 1
- NOT (¬): 비트 반전

### 고급 논리 연산 구현

```csharp
public class LogicalOperations
{
    // 기본 논리 연산 클래스
    public class BinaryLogicalOperation
    {
        public delegate byte LogicFunction(byte a, byte b);
        
        private readonly LogicFunction _function;
        
        public BinaryLogicalOperation(LogicFunction function)
        {
            _function = function;
        }
        
        public MyImage Apply(MyImage a, MyImage b)
        {
            ValidateInputs(a, b);
            
            MyImage dst = new MyImage(a.Width, a.Height);
            int size = a.Width * a.Height;
            
            for (int i = 0; i < size; i++)
            {
                dst.Buffer[i] = _function(a.Buffer[i], b.Buffer[i]);
            }
            
            return dst;
        }
    }
    
    // 사전 정의된 연산들
    public static class Operations
    {
        // AND 연산
        public static MyImage And(MyImage a, MyImage b)
        {
            return new BinaryLogicalOperation((x, y) => (byte)(x & y)).Apply(a, b);
        }
        
        // OR 연산
        public static MyImage Or(MyImage a, MyImage b)
        {
            return new BinaryLogicalOperation((x, y) => (byte)(x | y)).Apply(a, b);
        }
        
        // XOR 연산 (차이 강조)
        public static MyImage Xor(MyImage a, MyImage b)
        {
            return new BinaryLogicalOperation((x, y) => (byte)(x ^ y)).Apply(a, b);
        }
        
        // NOT 연산 (단항 연산)
        public static MyImage Not(MyImage src)
        {
            MyImage dst = new MyImage(src.Width, src.Height);
            
            for (int i = 0; i < src.Buffer.Length; i++)
            {
                dst.Buffer[i] = (byte)~src.Buffer[i];
            }
            
            return dst;
        }
        
        // NAND 연산
        public static MyImage Nand(MyImage a, MyImage b)
        {
            return Not(And(a, b));
        }
        
        // NOR 연산
        public static MyImage Nor(MyImage a, MyImage b)
        {
            return Not(Or(a, b));
        }
        
        // XNOR 연산 (유사성 강조)
        public static MyImage Xnor(MyImage a, MyImage b)
        {
            return Not(Xor(a, b));
        }
    }
    
    // 영상 마스킹 고급 기법
    public class AdvancedMasking
    {
        // ROI(Region of Interest) 추출
        public MyImage ExtractROI(MyImage src, MyImage mask)
        {
            ValidateInputs(src, mask);
            
            MyImage result = new MyImage(src.Width, src.Height);
            
            for (int i = 0; i < src.Buffer.Length; i++)
            {
                // 마스크가 0이 아닌 픽셀만 유지
                if (mask.Buffer[i] > 0)
                {
                    result.Buffer[i] = src.Buffer[i];
                }
                // 마스크가 0인 픽셀은 투명하게 (여기서는 0)
            }
            
            return result;
        }
        
        // 알파 블렌딩을 위한 마스크 처리
        public MyImage ApplyAlphaMask(MyImage src, MyImage alphaMask)
        {
            ValidateInputs(src, alphaMask);
            
            MyImage result = new MyImage(src.Width, src.Height);
            
            for (int i = 0; i < src.Buffer.Length; i++)
            {
                double alpha = alphaMask.Buffer[i] / 255.0;
                result.Buffer[i] = (byte)(src.Buffer[i] * alpha);
            }
            
            return result;
        }
        
        // 다중 마스크 결합
        public MyImage CombineMasks(params MyImage[] masks)
        {
            if (masks == null || masks.Length == 0)
                throw new ArgumentException("마스크가 없습니다.");
            
            MyImage combined = new MyImage(masks[0].Width, masks[0].Height);
            
            // OR 연산으로 모든 마스크 결합
            foreach (var mask in masks)
            {
                ValidateSize(mask, combined.Width, combined.Height);
                
                for (int i = 0; i < combined.Buffer.Length; i++)
                {
                    if (mask.Buffer[i] > 0)
                    {
                        combined.Buffer[i] = 255;
                    }
                }
            }
            
            return combined;
        }
        
        // 마스크 경계 부드럽게 만들기 (안티앨리어싱)
        public MyImage SmoothMask(MyImage binaryMask, int radius = 2)
        {
            MyImage smoothed = new MyImage(binaryMask.Width, binaryMask.Height);
            
            // 가우시안 블러 유사 효과
            for (int y = 0; y < binaryMask.Height; y++)
            {
                for (int x = 0; x < binaryMask.Width; x++)
                {
                    int sum = 0;
                    int count = 0;
                    
                    // 주변 픽셀 평균
                    for (int dy = -radius; dy <= radius; dy++)
                    {
                        for (int dx = -radius; dx <= radius; dx++)
                        {
                            int nx = x + dx;
                            int ny = y + dy;
                            
                            if (nx >= 0 && nx < binaryMask.Width && 
                                ny >= 0 && ny < binaryMask.Height)
                            {
                                sum += binaryMask.Buffer[ny * binaryMask.Width + nx];
                                count++;
                            }
                        }
                    }
                    
                    smoothed.Buffer[y * binaryMask.Width + x] = 
                        (byte)(sum / count);
                }
            }
            
            return smoothed;
        }
    }
}
```

### 논리 연산 응용: 영상 합성 시스템

```csharp
public class ImageCompositingSystem
{
    // 크로마 키 합성 (그린 스크린)
    public MyImage ChromaKeyComposition(
        MyImage foreground,     // 그린 스크린 배경 영상
        MyImage background,     // 배경 영상
        Color keyColor,         // 제거할 색상 (보통 녹색)
        int tolerance = 40)     // 색상 허용 오차
    {
        ValidateInputs(foreground, background);
        
        MyImage result = new MyImage(foreground.Width, foreground.Height);
        
        for (int i = 0; i < foreground.Buffer.Length; i++)
        {
            // 실제로는 RGB 영상 처리 필요 (여기서는 그레이스케일 예시)
            byte fgValue = foreground.Buffer[i];
            byte bgValue = background.Buffer[i];
            
            // 크로마 키 색상과의 차이 계산
            // (실제 구현은 RGB 색상 공간에서 거리 계산)
            int diff = Math.Abs(fgValue - keyColor.R);
            
            if (diff <= tolerance)
            {
                // 키 색상 범위: 배경 사용
                result.Buffer[i] = bgValue;
            }
            else
            {
                // 키 색상 아님: 전경 사용
                result.Buffer[i] = fgValue;
            }
        }
        
        return result;
    }
    
    // 그림자 효과 추가
    public MyImage AddShadow(
        MyImage objectImage,    // 객체 영상
        MyImage shadowMask,     // 그림자 마스크
        byte shadowIntensity = 100)
    {
        ValidateInputs(objectImage, shadowMask);
        
        MyImage result = new MyImage(objectImage.Width, objectImage.Height);
        
        for (int i = 0; i < objectImage.Buffer.Length; i++)
        {
            byte objValue = objectImage.Buffer[i];
            byte shadowValue = shadowMask.Buffer[i];
            
            // 그림자 마스크에 따라 밝기 감소
            if (shadowValue > 0)
            {
                double factor = shadowValue / 255.0;
                int shadowed = objValue - (int)(shadowIntensity * factor);
                result.Buffer[i] = Clamp(shadowed);
            }
            else
            {
                result.Buffer[i] = objValue;
            }
        }
        
        return result;
    }
    
    // 다중 레이어 합성
    public MyImage CompositeLayers(List<ImageLayer> layers)
    {
        if (layers == null || layers.Count == 0)
            return new MyImage(1, 1);
        
        MyImage result = new MyImage(layers[0].Image.Width, layers[0].Image.Height);
        
        // 배경부터 시작
        var backgroundLayer = layers.FirstOrDefault(l => l.IsBackground);
        if (backgroundLayer != null)
        {
            Array.Copy(backgroundLayer.Image.Buffer, result.Buffer, result.Buffer.Length);
        }
        
        // 다른 레이어들 합성 (알파 블렌딩)
        foreach (var layer in layers.Where(l => !l.IsBackground).OrderBy(l => l.ZIndex))
        {
            result = BlendLayer(result, layer);
        }
        
        return result;
    }
    
    private MyImage BlendLayer(MyImage baseImage, ImageLayer layer)
    {
        MyImage result = new MyImage(baseImage.Width, baseImage.Height);
        
        for (int i = 0; i < baseImage.Buffer.Length; i++)
        {
            double baseAlpha = 1.0;
            double layerAlpha = layer.Alpha;
            
            // 레이어 마스크 적용
            if (layer.Mask != null && i < layer.Mask.Buffer.Length)
            {
                layerAlpha *= layer.Mask.Buffer[i] / 255.0;
            }
            
            // 알파 블렌딩: C = α·F + (1-α)·B
            double blended = layer.Image.Buffer[i] * layerAlpha + 
                            baseImage.Buffer[i] * (1 - layerAlpha);
            
            result.Buffer[i] = (byte)Math.Clamp(blended, 0, 255);
        }
        
        return result;
    }
}

public class ImageLayer
{
    public MyImage Image { get; set; }
    public MyImage Mask { get; set; }
    public double Alpha { get; set; } = 1.0;
    public int ZIndex { get; set; }
    public bool IsBackground { get; set; }
}
```

---

## 연산별 용도 비교 및 선택 가이드

### 산술 연산 비교 표

| 연산 | 수학적 표현 | 주요 용도 | 장점 | 단점 | 성능 |
|------|------------|-----------|------|------|------|
| **덧셈** | h = f + g | 노이즈 감소, 다중 노출 합성 | 정보 통합 효과 좋음 | 오버플로우 발생 가능 | ⭐⭐⭐⭐⭐ |
| **뺄셈** | h = \|f - g\| | 변화 검출, 배경 제거 | 변화 영역 명확히 식별 | 노이즈 민감 | ⭐⭐⭐⭐ |
| **평균** | h = (f+g)/2 | 노이즈 감소, 부드러운 전환 | 오버플로우 방지 | 대비 감소 | ⭐⭐⭐⭐⭐ |
| **가중합** | h = αf + βg | 영상 융합, 알파 블렌딩 | 유연한 제어 가능 | 계수 설정 복잡 | ⭐⭐⭐⭐ |
| **차분** | h = diff(f,g) | 움직임 검출, 에지 검출 | 변화량 정량화 가능 | 임계값 설정 필요 | ⭐⭐⭐⭐ |

### 논리 연산 비교 표

| 연산 | 기호 | 주요 용도 | 진리표 (A,B) | 시각적 효과 |
|------|------|-----------|-------------|------------|
| **AND** | & | 마스킹, ROI 추출 | (0,0)→0, (0,1)→0, (1,0)→0, (1,1)→1 | 공통 영역 강조 |
| **OR** | \| | 영상 결합, 마스크 병합 | (0,0)→0, (0,1)→1, (1,0)→1, (1,1)→1 | 전체 영역 포함 |
| **XOR** | ^ | 차이 검출, 패턴 생성 | (0,0)→0, (0,1)→1, (1,0)→1, (1,1)→0 | 상이한 영역 강조 |
| **NOT** | ~ | 반전, 마스크 반전 | 0→1, 1→0 | 명암 반전 |
| **NAND** | ~& | 조건부 마스킹 | AND의 반전 | AND 제외 영역 |
| **XNOR** | ~^ | 유사성 검출 | XOR의 반전 | 동일 영역 강조 |

### 비트 평면 응용 표

| 응용 분야 | 사용 비트 평면 | 목적 | 효과 |
|-----------|----------------|------|------|
| **손실 압축** | 상위 4-6개 평면 | 데이터 양 감소 | 품질 80-95% 유지 |
| **정보 은닉** | LSB (b0) | 스테가노그래피 | 시각적 변화 미미 |
| **에지 검출** | b6-b7 | 경계선 추출 | 주요 에지 강조 |
| **텍스처 분석** | b4-b5 | 표면 패턴 분석 | 미세 패턴 분리 |
| **노이즈 제거** | b0-b2 제거 | 임펄스 노이즈 제거 | 화질 향상 |

### 연산 선택 의사 결정 트리

```
영상 처리 목적?
├── 변화 검출
│   ├── 정밀 변화: 차분 연산 → 임계값 처리
│   ├── 움직임 검출: 연속 뺄셈 → 군집화
│   └── 미세 변화: 가중 뺄셈 → 증폭
├── 노이즈 감소
│   ├── 정지 영상: 다중 평균화
│   ├── 동영상: 이동 평균
│   └── 임펄스 노이즈: 중앙값 + 평균
├── 영상 합성
│   ├── 자연스러운 합성: 알파 블렌딩
│   ├── 마스킹 합성: AND + 알파
│   └── 특수 효과: XOR + 감마 보정
├── 정보 추출
│   ├── 구조 분석: 비트 평면 분해
│   ├── 영역 분리: 논리 연산 + 모폴로지
│   └── 특징 강조: 비트 평면 재결합
└── 화질 향상
    ├── 동적 범위 확장: 히스토그램 + 산술 연산
    ├── 대비 향상: 감마 보정 + 스트레칭
    └── 선명도 향상: 차분 + 가중 합
```

---

## 성능 최적화 및 구현 고려사항

### 메모리 접근 패턴 최적화

```csharp
public class MemoryOptimizedProcessor
{
    // 캐시 친화적인 메모리 접근
    public void ProcessRowMajor(MyImage image, Action<byte> processPixel)
    {
        int width = image.Width;
        int height = image.Height;
        
        // 행 우선 접근 (캐시 효율적)
        for (int y = 0; y < height; y++)
        {
            int rowOffset = y * width;
            for (int x = 0; x < width; x++)
            {
                processPixel(image.Buffer[rowOffset + x]);
            }
        }
    }
    
    // 블록 처리로 캐시 활용도 향상
    public void ProcessByBlocks(MyImage image, int blockSize = 64)
    {
        int width = image.Width;
        int height = image.Height;
        
        for (int blockY = 0; blockY < height; blockY += blockSize)
        {
            for (int blockX = 0; blockX < width; blockX += blockSize)
            {
                // 블록 내부 처리
                int endY = Math.Min(blockY + blockSize, height);
                int endX = Math.Min(blockX + blockSize, width);
                
                for (int y = blockY; y < endY; y++)
                {
                    int rowOffset = y * width;
                    for (int x = blockX; x < endX; x++)
                    {
                        // 픽셀 처리
                        byte pixel = image.Buffer[rowOffset + x];
                        // 처리 로직
                    }
                }
            }
        }
    }
}
```

### 다중 스레드 병렬 처리 전략

```csharp
public class ParallelImageProcessor
{
    // 행 기반 병렬 처리
    public void ProcessRowsInParallel(MyImage image, Action<int, byte[]> rowProcessor)
    {
        int height = image.Height;
        int width = image.Width;
        
        Parallel.For(0, height, y =>
        {
            byte[] row = new byte[width];
            Array.Copy(image.Buffer, y * width, row, 0, width);
            rowProcessor(y, row);
            Array.Copy(row, 0, image.Buffer, y * width, width);
        });
    }
    
    // 작업 분할 전략
    public enum PartitionStrategy
    {
        ByRows,         // 행 단위 분할
        ByColumns,      // 열 단위 분할
        ByBlocks,       // 블록 단위 분할
        Dynamic         // 동적 분할
    }
    
    public void ProcessWithStrategy(
        MyImage image, 
        PartitionStrategy strategy,
        Action<Rectangle, MyImage> blockProcessor)
    {
        int numThreads = Environment.ProcessorCount;
        
        switch (strategy)
        {
            case PartitionStrategy.ByRows:
                // 행 기반 분할
                int rowsPerThread = (image.Height + numThreads - 1) / numThreads;
                Parallel.For(0, numThreads, t =>
                {
                    int startY = t * rowsPerThread;
                    int endY = Math.Min(startY + rowsPerThread, image.Height);
                    if (startY < endY)
                    {
                        var rect = new Rectangle(0, startY, image.Width, endY - startY);
                        blockProcessor(rect, image);
                    }
                });
                break;
                
            case PartitionStrategy.Dynamic:
                // 동적 부하 분산
                var partitioner = Partitioner.Create(0, image.Height);
                Parallel.ForEach(partitioner, range =>
                {
                    for (int y = range.Item1; y < range.Item2; y++)
                    {
                        // 행 처리
                    }
                });
                break;
        }
    }
}
```

---

## 실제 응용 사례 및 통합 예제

### 보안 시스템: 침입 감지

```csharp
public class IntrusionDetectionSystem
{
    private MyImage _backgroundModel;
    private ChangeDetectionSystem _detector;
    
    public IntrusionDetectionSystem(MyImage initialBackground)
    {
        _backgroundModel = initialBackground;
        _detector = new ChangeDetectionSystem();
    }
    
    public DetectionResult ProcessFrame(MyImage currentFrame)
    {
        // 1. 배경 차분
        var changeResult = _detector.DetectChanges(_backgroundModel, currentFrame);
        
        // 2. 침입 판단 (변화 영역 크기 기준)
        bool intrusionDetected = false;
        if (changeResult.ChangePercentage > 5.0)  // 5% 이상 변화
        {
            intrusionDetected = true;
            
            // 3. 침입 영역 분석
            AnalyzeIntrusionRegions(changeResult.ChangedRegions);
            
            // 4. 배경 모델 업데이트 (침입 영역 제외)
            UpdateBackgroundModel(currentFrame, changeResult.BinaryMask);
        }
        
        return new DetectionResult
        {
            IntrusionDetected = intrusionDetected,
            ChangedRegions = changeResult.ChangedRegions,
            AlertLevel = CalculateAlertLevel(changeResult)
        };
    }
    
    private void UpdateBackgroundModel(MyImage currentFrame, MyImage changeMask)
    {
        // 변화 없는 영역만 배경 모델 업데이트
        for (int i = 0; i < _backgroundModel.Buffer.Length; i++)
        {
            if (changeMask.Buffer[i] == 0)  // 변화 없음
            {
                // 적응형 업데이트: B(t+1) = 0.95*B(t) + 0.05*I(t)
                double newValue = _backgroundModel.Buffer[i] * 0.95 + 
                                  currentFrame.Buffer[i] * 0.05;
                _backgroundModel.Buffer[i] = (byte)newValue;
            }
        }
    }
}
```

### 의료 영상 분석: 시계열 변화 추적

```csharp
public class MedicalImageAnalyzer
{
    public class TumorChangeAnalysis
    {
        public double VolumeChange { get; set; }
        public double DensityChange { get; set; }
        public List<Point> BoundaryChanges { get; set; }
        public MyImage DifferenceMap { get; set; }
    }
    
    public TumorChangeAnalysis AnalyzeTumorProgression(
        MyImage baselineScan,
        MyImage followupScan,
        MyImage tumorMask)
    {
        // 1. 종양 영역 추출
        MyImage baselineTumor = ExtractRegion(baselineScan, tumorMask);
        MyImage followupTumor = ExtractRegion(followupScan, tumorMask);
        
        // 2. 차이 분석
        MyImage difference = new ImageArithmeticProcessor()
            .Subtract(followupTumor, baselineTumor, false);
        
        // 3. 변화량 정량화
        double volumeChange = CalculateVolumeChange(baselineTumor, followupTumor);
        double densityChange = CalculateDensityChange(baselineTumor, followupTumor);
        
        // 4. 경계 변화 분석
        var boundaryChanges = AnalyzeBoundaryChanges(baselineTumor, followupTumor);
        
        return new TumorChangeAnalysis
        {
            VolumeChange = volumeChange,
            DensityChange = densityChange,
            BoundaryChanges = boundaryChanges,
            DifferenceMap = difference
        };
    }
    
    private MyImage ExtractRegion(MyImage image, MyImage mask)
    {
        MyImage region = new MyImage(image.Width, image.Height);
        
        for (int i = 0; i < image.Buffer.Length; i++)
        {
            region.Buffer[i] = (mask.Buffer[i] > 0) ? image.Buffer[i] : (byte)0;
        }
        
        return region;
    }
}
```

---

## 결론 및 정리

### 핵심 원칙 요약

1. **산술 연산의 기초**: 모든 연산은 픽셀 값의 수치적 결합이며, 적절한 클램핑이 필수적
2. **비트 평면의 힘**: 영상을 8개 이진 평면으로 분해하면 다양한 정보 추출 가능
3. **논리 연산의 활용**: 마스킹, 영역 추출, 차이 검출에 강력한 도구
4. **성능과 정확성의 균형**: 알고리즘 선택 시 처리 속도와 정밀도 고려 필요

### 구현 체크리스트

- [ ] 입력 영상 크기 검증
- [ ] 메모리 접근 패턴 최적화
- [ ] 오버플로우/언더플로우 처리
- [ ] 다중 스레드 지원
- [ ] SIMD 명령어 활용
- [ ] 에러 처리 및 예외 관리
- [ ] 단위 테스트 작성

### 미래 발전 방향

1. **AI 기반 연산 선택**: 상황에 맞는 최적 연산 자동 선택
2. **하드웨어 가속**: GPU, FPGA를 활용한 실시간 처리
3. **양자 영상 처리**: 양자 컴퓨팅을 활용한 병렬 연산
4. **3D/4D 영상 확장**: 입체적, 시계열 데이터 처리

이 장을 통해 **영상 간 연산과 비트 기반 해석 기법**의 완전한 체계를 마련하였다. 이러한 기초 연산들은 더 복잡한 영상 처리 알고리즘의 구성 요소로 활용되며, 실제 응용 시스템의 핵심을 이룬다. 올바른 연산 선택과 효율적인 구현은 성공적인 영상 처리 시스템의 관건이다.