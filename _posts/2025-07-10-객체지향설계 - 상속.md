---
layout: post
title: 객체지향설계 - 상속
date: 2025-07-10 21:20:23 +0900
category: 객체지향설계
---
# 상속(Inheritance)

## 1. 상속이란 무엇인가?

> 상속(Inheritance)은 기존 클래스의 속성과 동작을 새로운 클래스가 물려받아 **재사용**하거나 **확장**할 수 있게 하는 메커니즘이다.

상속을 통해 **중복 제거**, **일반화 추출**, **다형성 기반 설계**가 가능해진다.

```java
// 부모 클래스
public class Animal {
    public void speak() { System.out.println("동물이 소리를 냅니다."); }
}

// 자식 클래스
public class Dog extends Animal {
    @Override
    public void speak() { System.out.println("멍멍!"); }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog(); // 업캐스팅
        a.speak();            // 동적 바인딩 → 멍멍!
    }
}
```

---

## 2. 기본 개념

- **Superclass/Base Class**: 공통 속성·동작을 정의
- **Subclass/Derived Class**: 부모의 기능 상속 + 필요 시 재정의/확장
- **오버라이딩(Overriding)**: 상위의 메서드를 하위가 재정의
- **다형성(Polymorphism)**: 상위 타입 참조로 하위 구현을 다룰 수 있음

언어별 문법 요약:

```csharp
// C# — virtual/override/sealed
public class Animal { public virtual void Speak() => Console.WriteLine("..."); }
public class Dog : Animal { public override void Speak() => Console.WriteLine("멍멍"); }
public sealed class Shiba : Dog {} // 더 이상 상속 금지
```

```cpp
// C++ — virtual, override, final
struct Animal { virtual void speak() { std::cout << "...\n"; } virtual ~Animal() = default; };
struct Dog : Animal { void speak() override { std::cout << "멍멍\n"; } };
```

```python
# Python — 동적, 다중 상속 가능
class Animal:
    def speak(self): print("...")

class Dog(Animal):
    def speak(self): print("멍멍")
```

---

## 3. 상속의 종류

### 3.1 단일 상속 (Single Inheritance)
- 하나의 부모만 상속
- Java/C#은 클래스 단일 상속 + 인터페이스 다중 구현

### 3.2 다중 상속 (Multiple Inheritance)
- 두 개 이상 부모로부터 상속(C++/Python)
- **다이아몬드 문제**와 **모호성**이 핵심 이슈

```cpp
// C++ — 다이아몬드와 가상 상속
struct A { int x; };
struct B : virtual A {};
struct C : virtual A {};
struct D : B, C { void f(){ x = 1; } }; // A가 하나로 공유됨(virtual)
```

### 3.3 인터페이스 다중 구현
- Java: `class Duck implements Flyable, Swimmable { ... }`
- 행위 합성을 위한 안전한 다형성 축

```java
public interface Flyable { void fly(); }
public interface Swimmable { void swim(); }
public class Duck implements Flyable, Swimmable {
    public void fly() { System.out.println("오리가 날아요"); }
    public void swim() { System.out.println("오리가 헤엄쳐요"); }
}
```

---

## 4. 상속의 장점

| 장점 | 설명 |
|---|---|
| 코드 재사용 | 공통 로직 상위에 모아 중복 제거 |
| 기능 확장 | 기존 코드를 수정하지 않고 하위에서 확장 |
| 계층화 | 도메인의 일반화/특수화 구조를 반영 |
| 다형성 | 상위 타입 API로 다양한 하위 구현을 대체 가능 |

단, 장점은 올바른 모델링과 계약 준수(LSP) 하에서만 성립한다.

---

## 5. 메서드 오버라이딩과 언어 규칙

- **시그니처 일치**: 이름·매개변수·반환타입(언어별 공변 허용 차이)
- **가시성**: Java는 같은 수준 혹은 더 넓게만 가능
- **주석**: `@Override`(Java)/`override`(C#·C++)로 실수 방지
- **가상 디스패치**: C++은 `virtual` 필수, Java/C#은 기본 가상(단 C#은 기본은 비가상, `virtual` 필요)

```java
class Parent { Number value(){ return 1; } }
class Child extends Parent { @Override Integer value(){ return 1; } } // 공변 반환 허용
```

---

## 6. super, 생성자, 초기화 순서

- 하위 생성자는 **반드시 상위 생성자**를 호출
- 초기화 순서: 상위 → 하위, 필드 → 생성자

```java
class Parent {
    Parent(String name){ System.out.println("부모: " + name); }
}
class Child extends Parent {
    Child() { super("홍길동"); System.out.println("자식 생성"); }
}
```

`super.method()`로 상위 구현을 호출해 **공통 규약**을 지키거나, **훅(hook) 방식**으로 일부만 확장 가능.

---

## 7. is-a 관계와 LSP(리스코프 치환 원칙)

상속은 **is-a** 관계가 성립해야 하며, LSP를 만족해야 한다.

> LSP: 상위 타입 객체가 사용되는 모든 자리에서 **하위 타입으로 대체**해도, 프로그램의 **정확성(계약/불변식)**이 유지되어야 한다.

수식 표기(개념적):

$$
\forall \; \text{S extends T},\ \text{client}(t: T)\ \text{는}\ \text{client}(s: S)\ \text{와 동등한 계약을 보장}
$$

### 7.1 사각형-정사각형 역설

```java
class Rectangle {
    protected int w, h;
    public void setWidth(int w){ this.w = w; }
    public void setHeight(int h){ this.h = h; }
    public int area(){ return w * h; }
}
class Square extends Rectangle {
    @Override public void setWidth(int w){ this.w = this.h = w; }
    @Override public void setHeight(int h){ this.w = this.h = h; }
}
```

테스트:

```java
Rectangle r = new Square();
r.setWidth(4);
r.setHeight(5);
assert r.area() == 20; // 실패: 25가 됨
```

- `Rectangle` 계약(독립적으로 `w`, `h` 설정)이 **Square**에 의해 깨짐 → LSP 위반
- 해결: 공통 상위로 `Quadrilateral`을 두거나, **상속 대신 합성/캡슐화**로 모델링

---

## 8. 상속의 위험과 안티패턴

### 8.1 Fragile Base Class Problem
- 상위 클래스 변경이 하위에 **예상치 못한 파급효과**
- 상위의 `private` → `protected` 노출은 결합도 증가
- 해결: **합성 우선**, 상위는 **불변식/계약**을 명확히, **템플릿 메서드 패턴**으로 확장 포인트를 제한

```java
abstract class DataExporter {
    public final void export(){ // 변경 불가 골격
        read(); transform(); write();
    }
    protected abstract void read();
    protected void transform(){ /* 기본 구현 */ }
    protected abstract void write();
}
```

### 8.2 Yo-Yo Problem
- 깊은 상속 트리로 인해 이해/추적 난이도 폭증 → 얕은 계층 유지

### 8.3 Anemic Base Class
- 상속을 코드 재사용 수단으로만 사용, 도메인 의미가 없는 상위 도출

---

## 9. 상속 vs 구성(Composition)

| 항목 | 상속 | 구성(합성) |
|---|---|---|
| 관계 | is-a | has-a |
| 결합도 | 높음(강결합) | 낮음(느슨한 결합) |
| 재사용 | 상위 전체를 물려받음 | 필요한 기능만 주입/위임 |
| 교체 용이성 | 낮음 | 높음(전략 교체) |

합성 예시(전략 패턴):

```java
interface PricingStrategy { int price(int base); }
class Regular implements PricingStrategy { public int price(int b){ return b; } }
class Discount implements PricingStrategy { public int price(int b){ return (int)(b*0.9); } }

class Order {
    private PricingStrategy strategy;
    public Order(PricingStrategy strategy){ this.strategy = strategy; }
    public int finalPrice(int base){ return strategy.price(base); }
}
```

---

## 10. 다중 상속과 충돌 해결

### 10.1 C++ 다중 상속
- **다이아몬드**: 공통 기반 A가 중복 → `virtual` 상속으로 공유
- **모호성**: 같은 시그니처 두 기반에서 올 때 **스코프 한정**으로 명시

```cpp
struct A { virtual void f(); };
struct B : virtual A { void f() override; };
struct C : virtual A { void f() override; };
struct D : B, C { void f() override { B::f(); C::f(); } };
```

### 10.2 Java 인터페이스 default 메서드 충돌

```java
interface A { default void f(){ System.out.println("A"); } }
interface B { default void f(){ System.out.println("B"); } }
class C implements A, B {
    @Override public void f(){ A.super.f(); } // 명시적 선택
}
```

---

## 11. sealed/abstract/final로 계층을 관리

- **abstract**: 직접 인스턴스화 금지, 골격 제공
- **final**(Java)/`sealed`(C#)/`final`(C++): 더 이상 상속/오버라이드 금지
- **sealed class**(Java 17+): 허용된 하위만 지정

```java
public sealed abstract class Shape permits Circle, Rectangle {}
public final class Circle extends Shape {}
public non-sealed class Rectangle extends Shape {} // 이후 자유 상속 허용
```

---

## 12. equals/hashCode/toString와 상속

- `equals` 대칭성·추이성·일관성을 **하위 타입까지** 유지해야 함
- `getClass()` vs `instanceof` 전략 선택에 따라 **대칭성 위반** 가능

```java
class Point {
    final int x,y;
    @Override public boolean equals(Object o){
        if (this==o) return true;
        if (!(o instanceof Point p)) return false; // instanceof 방식
        return x==p.x && y==p.y;
    }
    @Override public int hashCode(){ return java.util.Objects.hash(x,y); }
}
class ColorPoint extends Point {
    final String color;
    // equals 확장 시 대칭성·추이성 이슈 ※ 합성 권장
}
```

- 컬러 포함 비교를 강제하면 `Point`와의 **대칭성**이 깨질 수 있음 → **상속 대신 합성**을 고려

---

## 13. clone/직렬화와 상속

- Java `Cloneable`은 역사적 한계가 큼 → **복사 생성자/팩토리** 권장
- 직렬화 시 상/하위 호환성과 역직렬화 생성자 호출 순서에 유의

---

## 14. 성능/메모리 관점

- 가상 호출은 인라이닝 제약이 있으나 JIT가 대부분 최적화
- C++는 vtable 포인터가 객체 크기에 영향, 소멸자 `virtual` 누락 시 **자원 누수 위험**
- Hot path에서 오버라이딩 비용이 민감하면 **합성+전략**을 통한 **static dispatch**(C++ CRTP 등) 고려

```cpp
// CRTP — 정적 다형성으로 가상 호출 제거
template <typename Derived>
struct Drawable {
    void draw(){ static_cast<Derived*>(this)->drawImpl(); }
};
struct Button : Drawable<Button> { void drawImpl(){ /* ... */ } };
```

---

## 15. 템플릿 메서드 vs 전략: 상속 대안 비교

| 문제 | 템플릿 메서드(상속) | 전략(합성) |
|---|---|---|
| 공통 골격 + 일부 가변 | 골격 고정, 훅만 오버라이드 | 인터페이스로 알고리즘 전환 |
| 런타임 교체 | 어려움 | 용이 |
| 계층 복잡도 | 증가 | 낮음 |
| 성능 | 가상 호출 | 간접 호출(유사) |

---

## 16. 실전 시나리오

### 16.1 UI 컴포넌트 계층

```text
Component
 ├─ Button
 ├─ TextField
 └─ Checkbox
```

- 공통 렌더/레이아웃/이벤트를 상위에 두고, 각 컴포넌트가 오버라이드
- 렌더러/테마는 **전략/데코레이터**로 합성해 교체 가능성을 높인다

### 16.2 파일 시스템(Composite + 상속)

```java
abstract class FsNode {
    final String name;
    FsNode(String name){ this.name = name; }
    abstract long size();
}
class FileNode extends FsNode { private final byte[] data; long size(){ return data.length; } }
class DirNode extends FsNode {
    private final java.util.List<FsNode> children = new java.util.ArrayList<>();
    long size(){ return children.stream().mapToLong(FsNode::size).sum(); }
}
```

- 추상 상위 + 구체 하위로 자연스러운 is-a 관계
- 합성(디렉터리 내부의 노드 집합)이 핵심

### 16.3 결제 처리(인터페이스 다형성)

```java
interface Payment { void pay(int amount); }
class CardPayment implements Payment { public void pay(int a){ /* ... */ } }
class PaypalPayment implements Payment { public void pay(int a){ /* ... */ } }

class Checkout {
    private Payment payment;
    public Checkout(Payment p){ this.payment = p; }
    public void confirm(int amount){ payment.pay(amount); }
}
```

- 상속보다 **역할 기반 인터페이스**가 적합

---

## 17. 테스트 전략: 계약 기반 테스트

- **상위 타입 계약 테스트**를 정의하고, **모든 하위가 이를 통과**해야 한다.

```java
// 계약 테스트 예: AnimalContract
public abstract class AnimalContract<T extends Animal> {
    protected abstract T newSubject();
    @org.junit.jupiter.api.Test void speaks(){ newSubject().speak(); } // 예: 예외 없이 동작
}
// Dog, Cat 각각이 AnimalContract를 상속해 테스트를 상속 실행
```

- LSP 관점: 상위 API에 대한 **사전/사후/불변식**을 테스트로 고정

---

## 18. 수학적 관점: 전제/사후/불변식과 LSP

상위 타입 T의 메서드 계약:

$$
\text{Pre}_T \Rightarrow \text{Post}_T
$$

하위 타입 S의 재정의는:

$$
\text{Pre}_S \subseteq \text{Pre}_T,\quad \text{Post}_T \subseteq \text{Post}_S
$$

- 즉, **전제조건을 강화하지 말고**, **사후조건을 약화하지 말라**. 이를 어기면 LSP 위반.

---

## 19. 리팩토링: 상속을 합성으로 전환

기계적 단계:
1. 하위에서 상위 동작 사용 부분을 **위임 메서드**로 추출
2. 상위의 상태·동작을 **협력 객체**로 옮기고 필드로 보유
3. 상속 제거, 테스트로 회귀 방지

예시:

```java
// Before
class AuthController extends BaseController {
    @Override protected void render(){ /* ... */ super.render(); }
}

// After (합성)
class Renderer { void render(){ /* ... */ } }
class AuthController {
    private final Renderer renderer;
    AuthController(Renderer r){ this.renderer = r; }
    void render(){ renderer.render(); }
}
```

---

## 20. 체크리스트

- 상속 관계가 **자연어 is-a**로 타당한가?
- 상위 계약을 **하위가 강화하지 않았는가**(전제 강화 금지)?
- 상태 불변식이 **모든 하위**에서 유지되는가?
- 테스트는 **상위 계약 테스트**를 공유하는가?
- 대안으로 **합성**이 더 단순하지 않은가?
- 계층은 **얕고 명확**한가(2~3단계 이내)?
- `final`/`sealed`/`abstract`로 **의도된 확장 범위**가 명시되어 있는가?

---

## 21. 참고 구현 모음

### 21.1 super와 부분 확장

```java
class Animal { public void eat(){ System.out.println("동물이 먹습니다"); } }
class Tiger extends Animal {
    @Override public void eat(){
        super.eat();
        System.out.println("호랑이가 고기를 먹습니다");
    }
}
```

### 21.2 오버로딩 vs 오버라이딩 구분

```java
class Over {
    void f(int x){ System.out.println("int"); }       // 오버로딩1
    void f(String s){ System.out.println("String"); } // 오버로딩2
}
class Base { void g(){ System.out.println("Base"); } }
class Sub extends Base { @Override void g(){ System.out.println("Sub"); } } // 오버라이딩
```

### 21.3 C# sealed/virtual

```csharp
public class Base { public virtual void F() { } }
public class Sub : Base { public sealed override void F() { } } // 여기서 더 이상 오버라이드 불가
```

### 21.4 C++ slicing 방지, 가상 소멸자

```cpp
struct Base { virtual ~Base() = default; virtual void f(); };
struct Sub : Base { void f() override; };
void g(Base b);   // 복사로 슬라이싱 위험 → 참조/포인터 사용
void g(Base& b);  // 안전
```

---

## 22. 요약

| 항목 | 핵심 요지 |
|---|---|
| 개념 | 상속은 재사용과 확장을 위한 메커니즘이며, 다형성의 기반이다. |
| 전제 | is-a와 LSP가 성립해야 하며, 상위 계약을 하위가 보존해야 한다. |
| 위험 | fragile base class, 깊은 계층, 잘못된 일반화, equals/clone/직렬화 함정 |
| 대안 | 합성·전략·위임으로 유연한 구조를 우선 고려한다. |
| 도구 | sealed/abstract/final로 확장 범위를 통제하고, 계약 테스트로 검증한다. |

---

## 23. 부록: 원문 예제 보강

### 23.1 Dog/Cat 오버라이딩 예제(확장된 계약)

```java
abstract class Animal {
    // 계약: speak는 예외를 던지지 않고, 1줄 이상의 소리를 출력한다.
    public abstract String speak();
}
class Dog extends Animal {
    @Override public String speak(){ return "멍멍!"; }
}
class Cat extends Animal {
    @Override public String speak(){ return "야옹!"; }
}
```

### 23.2 구성(합성) 예시(엔진을 가진 자동차)

```java
class Engine { void start(){ System.out.println("엔진 시동"); } }
class Car {
    private final Engine engine;
    Car(Engine engine){ this.engine = engine; }
    void drive(){ engine.start(); System.out.println("차가 출발합니다"); }
}
```

### 23.3 잘못된 상속 예: Square/Rectangle 수정 방안

```java
interface Resizable { void resize(int w, int h); }
final class Rectangle implements Resizable { /* ... */ }
final class Square implements Resizable {
    @Override public void resize(int w, int h){ int s = Math.min(w,h); /* 한 변만 조정 */ }
}
```

- 공통 상위는 행위 계약(크기 조절 가능)을 제공하고, 개별 구현이 **각자의 불변식**을 지키며 구현한다. 상속 대신 **역할 인터페이스**로 치환.

---

## 24. 마무리

상속은 **의미론적 is-a**와 **계약 보존**을 전제로 사용할 때 가장 강력하다. 설계를 시작할 때 상속을 기본값으로 두지 말고, 먼저 **합성·위임**으로 문제를 풀 수 있는지 검토하라. 상속을 쓴다면 **얕고 명확한 계층**, **sealed/final로 확장 통제**, **상위 계약 테스트 공유**로 위험을 관리하라. 그렇게 할 때 상속은 재사용과 확장의 **열쇠**가 된다.
