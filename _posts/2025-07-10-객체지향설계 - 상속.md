---
layout: post
title: 객체지향설계 - 상속
date: 2025-07-10 21:20:23 +0900
category: 객체지향설계
---
# 상속(Inheritance): 객체 지향 설계의 재사용과 확장의 열쇠

## 1. 상속이란 무엇인가?

> **상속(Inheritance)**은 객체 지향 설계에서 **기존 클래스의 속성과 동작을 새로운 클래스가 물려받아 재사용하거나 확장할 수 있게 하는 메커니즘**입니다.

상속을 통해 **중복 코드를 제거하고**, **공통 기능을 일반화**하며, 시스템을 더 **유연하고 확장 가능**하게 만들 수 있습니다.

---

## 2. 기본 개념

- **부모 클래스 (Superclass / Base class)**: 공통 속성과 메서드를 정의하는 일반 클래스
- **자식 클래스 (Subclass / Derived class)**: 부모의 기능을 **상속**받고 **필요에 따라 확장/변경**

```java
// 부모 클래스
public class Animal {
    public void speak() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

// 자식 클래스
public class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("멍멍!");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.speak();  // 출력: 멍멍!
    }
}
```

---

## 3. 상속의 종류

### ✅ 단일 상속 (Single Inheritance)
- 하나의 부모로부터만 상속
- Java, C# 등 대부분의 언어는 단일 상속을 기본으로 제공

### ✅ 다중 상속 (Multiple Inheritance)
- 두 개 이상의 부모 클래스로부터 상속
- C++은 다중 상속을 지원하지만, Java는 **클래스 다중 상속은 금지**
- 대신 **인터페이스 다중 구현**을 통해 우회

```java
public interface Flyable {
    void fly();
}

public interface Swimmable {
    void swim();
}

public class Duck implements Flyable, Swimmable {
    public void fly() { System.out.println("오리가 날아요"); }
    public void swim() { System.out.println("오리가 헤엄쳐요"); }
}
```

---

## 4. 상속의 장점

| 장점 | 설명 |
|------|------|
| ✅ 코드 재사용 | 중복 제거, 생산성 향상 |
| ✅ 기능 확장 | 기존 코드를 수정하지 않고 새로운 동작 추가 |
| ✅ 계층 구조 | 도메인 모델을 계층적(계보적)으로 표현 가능 |
| ✅ 다형성과 연계 | 상속은 다형성을 위한 기반이 됨 |

---

## 5. 메서드 오버라이딩 (Overriding)

상속받은 메서드를 자식 클래스에서 **재정의(override)**하면,  
자식 클래스의 동작이 우선하게 됩니다.

```java
public class Cat extends Animal {
    @Override
    public void speak() {
        System.out.println("야옹!");
    }
}
```

- `@Override` 어노테이션을 붙이면 컴파일러가 재정의 여부를 확인해줍니다.
- 부모 메서드와 **시그니처가 정확히 일치**해야 오버라이딩이 됩니다.

---

## 6. super 키워드

부모 클래스의 멤버에 접근하거나, 생성자를 호출할 때 사용됩니다.

```java
public class Animal {
    public void eat() {
        System.out.println("동물이 먹습니다.");
    }
}

public class Tiger extends Animal {
    public void eat() {
        super.eat();  // 부모의 eat 호출
        System.out.println("호랑이가 고기를 먹습니다.");
    }
}
```

```java
public class Parent {
    public Parent(String name) {
        System.out.println("부모 생성자 호출: " + name);
    }
}

public class Child extends Parent {
    public Child() {
        super("홍길동");  // 부모 생성자 호출
    }
}
```

---

## 7. 상속과 is-a 관계

상속은 논리적으로 **"is-a 관계"**를 만족해야 합니다.

- `Dog is an Animal` ✅
- `Car is a Vehicle` ✅
- `Square is a Rectangle` ❌ (넓이 계산이나 성질이 다름)

> ❗ 잘못된 상속 관계는 시스템을 취약하게 만듭니다.  
> 의미론적 관계를 반드시 고려해야 합니다.

---

## 8. 상속의 주의점

### ❌ 무분별한 상속의 위험
- 깊은 상속 구조는 **복잡도 증가**, **유지보수 악화**
- 상속보다 **구성(Composition)**을 우선 고려

### ❌ 부모 클래스의 변경이 자식에 영향을 줌
- 부모 클래스의 수정이 하위 클래스에 **파급 효과**를 줄 수 있음

### ✅ 규칙
- **단일 책임 원칙(SRP)**을 지키며 상속을 적용
- 상속은 “확장”보다는 “일반화”를 위한 도구로 사용
- 상속보다는 **인터페이스나 전략 패턴(Strategy Pattern)**을 고려

---

## 9. 상속 vs 구성 (Composition)

| 비교 항목 | 상속(Inheritance) | 구성(Composition) |
|-----------|------------------|------------------|
| 관계 | is-a | has-a |
| 유연성 | 낮음 (강결합) | 높음 (느슨한 결합) |
| 재사용 | 부모 기능 자동 상속 | 필요한 기능만 조합 |
| 변경 영향 | 부모 변경 → 자식 영향 | 내부 객체 교체로 해결 |

```java
// 구성 예시: has-a 관계
public class Engine {
    public void start() {
        System.out.println("엔진 시동");
    }
}

public class Car {
    private Engine engine = new Engine();

    public void drive() {
        engine.start();
        System.out.println("차가 출발합니다");
    }
}
```

---

## 10. 상속이 잘 사용된 예시: UI 컴포넌트 계층

```plaintext
Component
 ├── Button
 ├── TextField
 └── Checkbox
```

- 공통된 그리기 로직을 `Component`에 정의하고,  
  각 UI 요소가 상속받아 구현을 재정의하는 구조

---

## ✅ 요약

| 항목 | 요약 설명 |
|------|------------|
| 개념 | 기존 클래스를 기반으로 새로운 클래스를 정의하는 구조 |
| 장점 | 코드 재사용, 기능 확장, 다형성 구현 |
| 단점 | 결합도 증가, 잘못된 계층 설계 시 유지보수 어려움 |
| 대안 | 구성(Composition)을 우선 고려 |
| 핵심 원칙 | is-a 관계, SRP, LSP, 느슨한 결합 유도 |

---

## 🔚 마무리

**상속은 강력하지만, 남용하면 해로울 수 있는 양날의 검입니다.**  
잘 설계된 상속 구조는 코드를 간결하고 확장 가능하게 만들지만,  
잘못된 상속은 오히려 코드 이해를 어렵게 만들고 유지보수를 어렵게 만듭니다.

> 💡 **상속을 쓸 것인가? 구성을 쓸 것인가?**  
> → 항상 도메인 모델과 책임의 관점에서 판단하세요.