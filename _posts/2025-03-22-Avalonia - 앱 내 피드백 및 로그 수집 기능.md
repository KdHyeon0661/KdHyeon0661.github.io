---
layout: post
title: Avalonia - 앱 내 피드백 및 로그 수집 기능
date: 2025-03-22 20:20:23 +0900
category: Avalonia
---
# 앱 내 피드백 및 로그 수집 기능 (Avalonia)

## 0. 목표와 전체 아키텍처

| 목표 | 내용 |
|---|---|
| 피드백 수집 | 앱 내 창에서 텍스트·분류·연락처·스크린샷(선택) 수집 |
| 로깅 | Serilog 구조적 로그(파일 롤링), 사용자가 전송 선택 시 첨부 |
| 전송 | REST API(권장)로 멀티파트 업로드, 오프라인 큐 + 재시도 |
| 보호 | 동의(Consent), 민감정보 자동 마스킹/필터, 전송 전 사용자 확인 |
| 진단 | 앱/OS/버전/언어/해상도/메모리 등 메타 수집(선택) |
| 운영 | 로그 레벨·보존 정책·전송 엔드포인트 환경별 설정(dev/prod) |

### 폴더 개요(예시)

```
MyApp/
├─ Views/FeedbackWindow.axaml
├─ ViewModels/FeedbackViewModel.cs
├─ Services/Logging/SerilogBootstrap.cs
├─ Services/Feedback/IFeedbackService.cs
├─ Services/Feedback/FeedbackService.cs
├─ Services/Feedback/IScreenshotService.cs
├─ Services/Feedback/ScreenshotService.cs
├─ Services/Feedback/IRedactor.cs
├─ Services/Feedback/Redactor.cs
├─ Services/Feedback/IUploadQueue.cs
├─ Services/Feedback/UploadQueue.cs
├─ Models/FeedbackPayload.cs
├─ appsettings.json
├─ appsettings.dev.json
└─ appsettings.prod.json
```

---

## 1. UI — 피드백 창(확장판)

### 1.1 XAML

```xml
<!-- Views/FeedbackWindow.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="MyApp.Views.FeedbackWindow"
        Title="피드백 보내기" Width="560" Height="520"
        CanResize="False">
  <Grid RowDefinitions="Auto,*,Auto" Margin="18">
    <!-- 헤더/동의 -->
    <StackPanel Spacing="8">
      <TextBlock Text="의견을 작성해주세요:" FontSize="16" FontWeight="Bold"/>
      <TextBlock Text="발생한 문제, 재현 방법, 기대 동작을 자세히 적어주세요."/>
      <CheckBox Content="개인정보 및 민감 정보가 포함되지 않았음을 확인합니다."
                IsChecked="{Binding ConsentChecked, Mode=TwoWay}"/>
    </StackPanel>

    <!-- 본문 -->
    <Grid Grid.Row="1" RowDefinitions="Auto,Auto,*,Auto,Auto,Auto" ColumnDefinitions="*,Auto" Margin="0,12,0,12">
      <TextBlock Text="분류" Grid.Row="0"/>
      <ComboBox Grid.Row="0" Grid.Column="1" Width="180" SelectedItem="{Binding Category}">
        <ComboBoxItem Content="버그"/>
        <ComboBoxItem Content="제안"/>
        <ComboBoxItem Content="기타"/>
      </ComboBox>

      <TextBlock Text="연락처(선택)" Grid.Row="1"/>
      <TextBox Grid.Row="1" Grid.Column="1" Width="180" Text="{Binding Contact, Mode=TwoWay}"/>

      <TextBox Grid.Row="2" Grid.ColumnSpan="2" AcceptsReturn="True" Height="200"
               Watermark="상세 내용을 입력하세요 (텍스트만)"
               Text="{Binding FeedbackText, Mode=TwoWay}"/>

      <CheckBox Grid.Row="3" Content="최근 로그 포함" IsChecked="{Binding IncludeLog}"/>
      <CheckBox Grid.Row="4" Content="현재 창 스크린샷 포함" IsChecked="{Binding IncludeScreenshot}"/>

      <StackPanel Grid.Row="5" Orientation="Horizontal" Spacing="8">
        <TextBlock Text="개인정보 필터링: "/>
        <ToggleSwitch IsChecked="{Binding RedactionEnabled}" OnContent="ON" OffContent="OFF"/>
      </StackPanel>
    </Grid>

    <!-- 풋터 -->
    <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Spacing="10">
      <Button Content="미리보기" Command="{Binding PreviewCommand}"/>
      <Button Content="보내기" Command="{Binding SubmitCommand}" IsEnabled="{Binding CanSubmit}"/>
      <Button Content="닫기" Command="{Binding CloseCommand}"/>
    </StackPanel>
  </Grid>
</Window>
```

### 1.2 ViewModel

```csharp
// ViewModels/FeedbackViewModel.cs
using ReactiveUI;
using System.Reactive;
using System.Reactive.Linq;

public sealed class FeedbackViewModel : ReactiveObject
{
    private readonly IFeedbackService _service;
    private readonly IScreenshotService _screenshot;
    private readonly IRedactor _redactor;

    public string FeedbackText { get => _feedbackText; set => this.RaiseAndSetIfChanged(ref _feedbackText, value); }
    public string? Category { get => _category; set => this.RaiseAndSetIfChanged(ref _category, value); }
    public string? Contact { get => _contact; set => this.RaiseAndSetIfChanged(ref _contact, value); }
    public bool IncludeLog { get => _includeLog; set => this.RaiseAndSetIfChanged(ref _includeLog, value); }
    public bool IncludeScreenshot { get => _includeScreenshot; set => this.RaiseAndSetIfChanged(ref _includeScreenshot, value); }
    public bool RedactionEnabled { get => _redactionEnabled; set => this.RaiseAndSetIfChanged(ref _redactionEnabled, value); }
    public bool ConsentChecked { get => _consentChecked; set => this.RaiseAndSetIfChanged(ref _consentChecked, value); }

    public bool CanSubmit => !string.IsNullOrWhiteSpace(FeedbackText) && ConsentChecked;

    public ReactiveCommand<Unit, Unit> SubmitCommand { get; }
    public ReactiveCommand<Unit, Unit> PreviewCommand { get; }
    public ReactiveCommand<Unit, Unit> CloseCommand { get; }

    private string _feedbackText = "";
    private string? _category = "버그";
    private string? _contact;
    private bool _includeLog = true;
    private bool _includeScreenshot = false;
    private bool _redactionEnabled = true;
    private bool _consentChecked = false;

    public FeedbackViewModel(IFeedbackService service, IScreenshotService screenshot, IRedactor redactor)
    {
        _service = service;
        _screenshot = screenshot;
        _redactor = redactor;

        var canSubmitObs = this.WhenAnyValue(x => x.FeedbackText, x => x.ConsentChecked,
            (text, ok) => !string.IsNullOrWhiteSpace(text) && ok);

        SubmitCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            var text = RedactionEnabled ? _redactor.Redact(FeedbackText) : FeedbackText;
            byte[]? screenshotBytes = null;

            if (IncludeScreenshot)
                screenshotBytes = await _screenshot.CapturePrimaryWindowPngAsync();

            await _service.SendAsync(new FeedbackRequest
            {
                Category = Category ?? "기타",
                Message = text,
                Contact = Contact,
                AttachLog = IncludeLog,
                ScreenshotPng = screenshotBytes
            });

            // 사용자 알림은 앱의 NotificationService 등으로 표시
        }, canSubmitObs);

        PreviewCommand = ReactiveCommand.Create(() =>
        {
            // 간단히 텍스트 미리보기 또는 전송 페이로드 덤프 창 표시
        });

        CloseCommand = ReactiveCommand.Create(() =>
        {
            // 창 닫기 — Window.Close()는 View에서 Command 바인딩 등으로 처리
        });
    }
}
```

---

## 2. 로깅 — Serilog 부트스트랩

### 2.1 패키지

```bash
dotnet add package Serilog
dotnet add package Serilog.Sinks.File
dotnet add package Serilog.Sinks.Async
dotnet add package Serilog.Enrichers.Environment
dotnet add package Serilog.Enrichers.Process
dotnet add package Serilog.Enrichers.Thread
dotnet add package Serilog.Formatting.Compact
```

### 2.2 초기화

```csharp
// Services/Logging/SerilogBootstrap.cs
using Serilog;
using Serilog.Events;

public static class SerilogBootstrap
{
    public static ILogger CreateLogger(string logDir, string appName, string environment, LogEventLevel level)
    {
        Directory.CreateDirectory(logDir);

        return new LoggerConfiguration()
            .MinimumLevel.Is(level)
            .Enrich.WithProcessId()
            .Enrich.WithThreadId()
            .Enrich.WithEnvironmentUserName()
            .Enrich.WithMachineName()
            .Enrich.WithProperty("App", appName)
            .Enrich.WithProperty("Env", environment)
            .WriteTo.Async(a => a.File(
                path: Path.Combine(logDir, "app-.log"),
                rollingInterval: RollingInterval.Day,
                retainedFileCountLimit: 14, // 보존 14일
                shared: false,
                buffered: true,
                formatProvider: null))
            .WriteTo.Async(a => a.File(
                formatter: new Serilog.Formatting.Compact.CompactJsonFormatter(),
                path: Path.Combine(logDir, "app-json-.log"),
                rollingInterval: RollingInterval.Day,
                retainedFileCountLimit: 14))
            .CreateLogger();
    }
}
```

> 포맷: 텍스트 + Compact JSON 병행 기록 → 수집/분석 파이프라인에 유리.

### 2.3 사용

```csharp
Log.Information("앱 시작");
try
{
    // ...
}
catch (Exception ex)
{
    Log.Fatal(ex, "치명적 예외");
    throw;
}
finally
{
    Log.CloseAndFlush();
}
```

---

## 3. 민감정보 마스킹/필터(전송 전 Redaction)

### 3.1 인터페이스/구현

```csharp
// Services/Feedback/IRedactor.cs
public interface IRedactor
{
    string Redact(string input);
    Stream Redact(Stream input); // 필요 시
}
```

```csharp
// Services/Feedback/Redactor.cs
using System.Text.RegularExpressions;

public sealed class Redactor : IRedactor
{
    // 예시: 이메일/전화/토큰/쿠키 간단 마스킹
    private static readonly Regex Email = new(@"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}", RegexOptions.Compiled);
    private static readonly Regex Phone = new(@"\b(01[016789]-?\d{3,4}-?\d{4})\b", RegexOptions.Compiled);
    private static readonly Regex Token = new(@"\b(eyJ[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+)\b", RegexOptions.Compiled);

    public string Redact(string input)
    {
        if (string.IsNullOrEmpty(input)) return input;
        var s = Email.Replace(input, "***@***");
        s = Phone.Replace(s, "010-****-****");
        s = Token.Replace(s, "***.***.***");
        return s;
    }

    public Stream Redact(Stream input)
    {
        using var sr = new StreamReader(input, leaveOpen: true);
        var text = sr.ReadToEnd();
        input.Position = 0;
        var red = Redact(text);
        return new MemoryStream(System.Text.Encoding.UTF8.GetBytes(red));
    }
}
```

> 로그 파일 전체를 전송 전 선제 마스킹하려면, 업로드 직전 스트림을 `Redact(Stream)`으로 감싼다.

---

## 4. 스크린샷 첨부

```csharp
// Services/Feedback/IScreenshotService.cs
public interface IScreenshotService
{
    Task<byte[]?> CapturePrimaryWindowPngAsync();
}
```

```csharp
// Services/Feedback/ScreenshotService.cs
using Avalonia;
using Avalonia.Controls;
using Avalonia.Media.Imaging;
using Avalonia.Platform;

public sealed class ScreenshotService : IScreenshotService
{
    private readonly Window _mainWindow;
    public ScreenshotService(Window mainWindow) => _mainWindow = mainWindow;

    public async Task<byte[]?> CapturePrimaryWindowPngAsync()
    {
        var pixelSize = new PixelSize((int)_mainWindow.Bounds.Width, (int)_mainWindow.Bounds.Height);
        var dpi = new Vector(96, 96);
        using var rtb = new RenderTargetBitmap(pixelSize, dpi);
        _mainWindow.Render(rtb);
        await using var ms = new MemoryStream();
        rtb.Save(ms);
        return ms.ToArray();
    }
}
```

> 민감 정보가 UI에 표시될 수 있으므로, 스크린샷 포함은 **옵션 + 경고문** 제공 권장.

---

## 5. 피드백 전송 서비스 — 멀티파트 + 오프라인 큐

### 5.1 모델

```csharp
// Models/FeedbackPayload.cs
public sealed class FeedbackRequest
{
    public string Category { get; init; } = "기타";
    public string Message { get; init; } = "";
    public string? Contact { get; init; }
    public bool AttachLog { get; init; }
    public byte[]? ScreenshotPng { get; init; }
}
```

### 5.2 인터페이스

```csharp
// Services/Feedback/IFeedbackService.cs
public interface IFeedbackService
{
    Task SendAsync(FeedbackRequest request, CancellationToken ct = default);
}
```

### 5.3 오프라인 큐

```csharp
// Services/Feedback/IUploadQueue.cs
public interface IUploadQueue
{
    Task EnqueueAsync(FeedbackRequest request, CancellationToken ct = default);
    Task DrainAsync(CancellationToken ct = default); // 네트워크 가능할 때 재시도
}
```

```csharp
// Services/Feedback/UploadQueue.cs
using System.Text.Json;

public sealed class UploadQueue : IUploadQueue
{
    private readonly string _queueDir;

    public UploadQueue(string appDataDir)
    {
        _queueDir = Path.Combine(appDataDir, "feedback-queue");
        Directory.CreateDirectory(_queueDir);
    }

    public async Task EnqueueAsync(FeedbackRequest request, CancellationToken ct = default)
    {
        var id = $"{DateTime.UtcNow:yyyyMMddHHmmssfff}-{Guid.NewGuid():N}.json";
        var path = Path.Combine(_queueDir, id);
        await File.WriteAllTextAsync(path, JsonSerializer.Serialize(request), ct);
    }

    public async Task DrainAsync(CancellationToken ct = default)
    {
        foreach (var f in Directory.GetFiles(_queueDir, "*.json").OrderBy(x => x))
        {
            // 실제 Drain은 FeedbackService가 호출 시 처리하는 편이 깔끔
            await Task.CompletedTask;
        }
    }

    public IEnumerable<string> Enumerate() => Directory.GetFiles(_queueDir, "*.json");
    public void Remove(string path) { try { File.Delete(path); } catch { } }
}
```

### 5.4 구현(전송 + 백오프 + 로그 첨부)

```csharp
// Services/Feedback/FeedbackService.cs
using Serilog;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;

public sealed class FeedbackService : IFeedbackService
{
    private readonly HttpClient _http;
    private readonly IUploadQueue _queue;
    private readonly IRedactor _redactor;
    private readonly string _logDir;
    private readonly string _endpoint;

    public FeedbackService(HttpClient http, IUploadQueue queue, IRedactor redactor, string logDir, string endpoint)
    {
        _http = http;
        _queue = queue;
        _redactor = redactor;
        _logDir = logDir;
        _endpoint = endpoint.TrimEnd('/');
    }

    public async Task SendAsync(FeedbackRequest request, CancellationToken ct = default)
    {
        // 즉시 시도 → 실패 시 큐 저장
        var ok = await TryPostAsync(request, ct);
        if (ok) return;

        await _queue.EnqueueAsync(request, ct);
        Log.Warning("피드백을 오프라인 큐에 저장했습니다.");

        _ = Task.Run(() => DrainQueueWithBackoffAsync(ct));
    }

    private async Task<bool> TryPostAsync(FeedbackRequest req, CancellationToken ct)
    {
        try
        {
            using var form = new MultipartFormDataContent();

            var meta = CollectMeta();
            form.Add(new StringContent(req.Category), "category");
            form.Add(new StringContent(req.Message), "message");
            if (!string.IsNullOrWhiteSpace(req.Contact))
                form.Add(new StringContent(_redactor.Redact(req.Contact)), "contact");

            form.Add(new StringContent(JsonSerializer.Serialize(meta), Encoding.UTF8, "application/json"), "meta");

            if (req.AttachLog)
            {
                var latest = Directory.GetFiles(_logDir, "app-*.log")
                                      .OrderByDescending(f => f).FirstOrDefault();
                if (latest is not null)
                {
                    await using var fs = File.OpenRead(latest);
                    using var red = _redactor.Redact(fs);
                    var content = new StreamContent(red);
                    content.Headers.ContentType = new MediaTypeHeaderValue("text/plain");
                    form.Add(content, "logFile", Path.GetFileName(latest));
                }
            }

            if (req.ScreenshotPng is not null)
            {
                var sc = new ByteArrayContent(req.ScreenshotPng);
                sc.Headers.ContentType = new MediaTypeHeaderValue("image/png");
                form.Add(sc, "screenshot", "screenshot.png");
            }

            var resp = await _http.PostAsync($"{_endpoint}/feedback", form, ct);
            if (!resp.IsSuccessStatusCode)
            {
                Log.Warning("피드백 전송 실패: {Status}", resp.StatusCode);
                return false;
            }

            Log.Information("피드백 전송 성공");
            return true;
        }
        catch (Exception ex)
        {
            Log.Error(ex, "피드백 전송 예외");
            return false;
        }
    }

    private async Task DrainQueueWithBackoffAsync(CancellationToken ct)
    {
        var delay = TimeSpan.FromSeconds(5);
        var max = TimeSpan.FromMinutes(5);

        while (!ct.IsCancellationRequested)
        {
            var any = false;

            foreach (var path in (_queue as UploadQueue)!.Enumerate())
            {
                try
                {
                    var json = await File.ReadAllTextAsync(path, ct);
                    var req = JsonSerializer.Deserialize<FeedbackRequest>(json);
                    if (req is null) { (_queue as UploadQueue)!.Remove(path); continue; }

                    if (await TryPostAsync(req, ct))
                    {
                        (_queue as UploadQueue)!.Remove(path);
                        any = true;
                    }
                }
                catch (Exception ex)
                {
                    Log.Error(ex, "큐 Drain 처리 중 오류");
                }
            }

            if (!any)
            {
                await Task.Delay(delay, ct);
                delay = TimeSpan.FromMilliseconds(Math.Min(delay.TotalMilliseconds * 2, max.TotalMilliseconds));
            }
            else
            {
                delay = TimeSpan.FromSeconds(5);
            }
        }
    }

    private static object CollectMeta()
    {
        // 앱/OS/로캘/해상도/메모리 등 (예시)
        return new
        {
            appVersion = typeof(FeedbackService).Assembly.GetName().Version?.ToString(),
            os = Environment.OSVersion.VersionString,
            arch = RuntimeInformation.ProcessArchitecture.ToString(),
            culture = System.Globalization.CultureInfo.CurrentUICulture.Name,
            timestampUtc = DateTime.UtcNow
        };
    }
}
```

> 실패 시 큐에 보관 → 백오프(지수 증가)로 재전송.  
> 로그는 전송 전 스트림 마스킹을 적용.

---

## 6. 전송 포맷/서버 측(예시)

### 6.1 요청(Multipart)

- `category: text/plain`
- `message: text/plain`
- `contact: text/plain (optional)`
- `meta: application/json`
- `logFile: text/plain (optional)`
- `screenshot: image/png (optional)`

### 6.2 서버(간단 예: ASP.NET Core)

```csharp
[ApiController]
[Route("feedback")]
public class FeedbackController : ControllerBase
{
    [HttpPost]
    [RequestSizeLimit(20_000_000)] // 20MB
    public async Task<IActionResult> Post([FromForm] FeedbackForm form)
    {
        // 저장/알림/이슈 트래커 연계(Jira/GitHub Issues) 등
        return Ok(new { ok = true });
    }
}

public sealed class FeedbackForm
{
    public string Category { get; set; } = "";
    public string Message { get; set; } = "";
    public string? Contact { get; set; }
    public string? Meta { get; set; }

    public IFormFile? LogFile { get; set; }
    public IFormFile? Screenshot { get; set; }
}
```

> 서버는 별도의 **PII 검증/차단**을 반드시 수행. 저장 정책(보존 기간·암호화·접근 권한) 수립.

---

## 7. 전역 예외/크래시 수집(동의 기반)

```csharp
AppDomain.CurrentDomain.UnhandledException += async (s, e) =>
{
    var ex = e.ExceptionObject as Exception;
    Log.Fatal(ex, "UnhandledException");

    // 동의 기반: 사용자에게 전송 여부 확인
    // 확인 시 FeedbackService.SendAsync(new FeedbackRequest { ... })
};

TaskScheduler.UnobservedTaskException += (s, e) =>
{
    Log.Error(e.Exception, "UnobservedTaskException");
    e.SetObserved();
};
```

---

## 8. 설정(appsettings.*)과 DI

### 8.1 appsettings.dev.json / prod.json (예)

```json
{
  "Logging": {
    "Level": "Debug",
    "Dir": "logs"
  },
  "Feedback": {
    "Endpoint": "https://api-dev.example.com",
    "MaxQueueSize": 100
  }
}
```

```json
{
  "Logging": {
    "Level": "Information",
    "Dir": "logs"
  },
  "Feedback": {
    "Endpoint": "https://api.example.com",
    "MaxQueueSize": 100
  }
}
```

### 8.2 DI 등록

```csharp
// Program.cs (요지)
var env = Environment.GetEnvironmentVariable("DOTNET_ENVIRONMENT") ?? "prod";
var config = new ConfigurationBuilder()
    .SetBasePath(AppContext.BaseDirectory)
    .AddJsonFile("appsettings.json", optional:false, reloadOnChange:true)
    .AddJsonFile($"appsettings.{env}.json", optional:true, reloadOnChange:true)
    .Build();

var logDir = config["Logging:Dir"] ?? "logs";
var level = Enum.Parse<Serilog.Events.LogEventLevel>(config["Logging:Level"] ?? "Information", true);
Log.Logger = SerilogBootstrap.CreateLogger(logDir, "MyApp", env, level);

var services = new ServiceCollection();
services.AddSingleton<IRedactor, Redactor>();
services.AddSingleton<IUploadQueue>(sp =>
    new UploadQueue(AppContext.BaseDirectory));
services.AddHttpClient<IFeedbackService, FeedbackService>(client =>
{
    // 타임아웃/헤더/프록시 등 설정
    client.Timeout = TimeSpan.FromSeconds(30);
})
.ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler
{
    AutomaticDecompression = System.Net.DecompressionMethods.All
});
services.AddSingleton<IScreenshotService>(sp =>
{
    // MainWindow 인스턴스를 주입하는 패턴 사용(등록 시점 주의)
    var window = (Application.Current!.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)!.MainWindow;
    return new ScreenshotService(window!);
});
```

---

## 9. UX/프라이버시 가이드

| 항목 | 권장 |
|---|---|
| 동의 문구 | “전송 시 최근 로그와 선택 항목이 서버로 업로드됩니다. 개인정보는 제거되며, 정책에 따라 보관/폐기됩니다.” |
| 스크린샷 경고 | 민감 데이터 포함 가능성 경고 후 첨부 옵션 제공 |
| 로그 레벨 | 기본 `Information` / 개발은 `Debug`. UI에서 레벨별 내보내기(선택) |
| 전송 확인 | 전송 전 미리보기/요약 확인 |
| 결과 | “감사합니다. 접수 번호: #1234” 등 회신용 토큰 제공 |
| 비연결 | 오프라인 시 큐에 저장되며, 연결 시 자동 전송 안내 |

---

## 10. 테스트 전략

- ViewModel:  
  - `ConsentChecked=false` → Submit 비활성  
  - RedactionEnabled=true → 이메일/토큰 마스킹 검증  
  - IncludeScreenshot=true → 바이트 첨부 여부
- FeedbackService:  
  - 성공/실패/시간초과/5xx/네트워크 끊김  
  - 큐 저장 → Drain 백오프
- Redactor:  
  - 케이스별 정규식 커버리지(국내 전화·국제 전화·JWT·쿠키)
- 로깅:  
  - 파일 생성/롤링/보존 정책  
  - JSON 포맷 파싱 가능성
- 성능/용량:  
  - 최대 첨부 크기(스크린샷+로그) 제한  
  - 업로드 타임아웃/재시도 횟수

---

## 11. 운영 팁

- 로그 보존 7~30일, 크기 제한(예: 10MB/파일, 총 200MB)
- 전송 레이트 리미트(서버 429 → 클라이언트 백오프)
- 피드백 범주→이슈 트래커 자동 생성/라벨링
- 릴리즈 노트에 “피드백 방법” 섹션 포함
- 업데이트 후(릴리즈 채널 전환 등) 첫 실행 시 “최근 변경에 대한 의견” 모달 제공(선택)

---

## 12. 간단한 대안/옵션

| 항목 | 대안 |
|---|---|
| 중앙화 로그 | Sentry/Seq/Elastic Stack(서버 운영) |
| 이메일 | MailKit로 SMTP 전송(소규모 앱) |
| 클라우드 스토리지 | S3/Blob에 업로드 후 URL만 API에 전달 |
| UI 캡처 | 영역 지정 캡처(사용자 선택) |

---

## 결론

- Avalonia에서 **앱 내 피드백**은 XAML/VM 조합으로 간단히 구성되지만, 실무에서는 **구조적 로깅 + 개인정보 마스킹 + 오프라인 큐 + 백오프 재시도 + 메타 수집 + 동의 UX**가 필수다.
- 본 문서의 설계를 따르면 **개발/운영/보안 요구**를 균형 있게 충족하며, 환경(appsettings.*) 분리로 다양한 배포 채널에서도 안정적으로 운용할 수 있다.