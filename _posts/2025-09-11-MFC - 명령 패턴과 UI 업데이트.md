---
layout: post
title: MFC - 명령 패턴과 UI 업데이트
date: 2025-09-11 22:25:23 +0900
category: MFC
---
# 명령 패턴과 UI 업데이트(ON_UPDATE_COMMAND_UI)의 궁합

이 글은 **MFC의 명령 라우팅**과 **`ON_UPDATE_COMMAND_UI`** 메커니즘을, 전통적인 **Command 패턴**과 결합하여
- **Enable/Disable / Check / Radio / Text** 동기화,
- **Undo/Redo** 가능한 작업,
- **긴 작업(Async)과 상태 전이**,
- **SDI/MDI/대화상자 기반** UI까지

일관되게 설계하는 방법을 **예제와 함께** 정리합니다.

---

## 0. 핵심 요약 (TL;DR)

- **Command 패턴**: 실행(`execute()`), 취소(`undo()`), 가능 여부(`canExecute()`)를 캡슐화.  
- **MFC 라우팅**: `WM_COMMAND` → **활성 View → Frame → Document → App** 순서로 핸들러를 탐색.  
- **UI 동기화**: `ON_UPDATE_COMMAND_UI(ID_…, OnUpdate…)`에서 **현재 컨텍스트**로 Enable/Check/Radio/텍스트를 갱신.  
- **베이스라인**:  
  - `ICommand` 인터페이스 + `CommandManager`(Undo/Redo, Enable 질의)  
  - 각 명령의 **상태 로직**을 `canExecute()`에 집중  
  - `OnUpdate…`에서 해당 명령을 **조회**해 UI에 반영  
  - 실행은 `On…`에서 `cmd->execute()` 호출  
- **긴 작업**: `BusyGuard` / `AsyncCommand`로 **중복 실행 차단 + 진행/취소** 모델  
- **대화상자**: `UpdateDialogControls(this, FALSE)`로 Idle에 강제 트리거

---

## 1. 전통 Command 패턴과 MFC 명령 라우팅 매핑

### 1-1. 최소 인터페이스
```cpp
struct ICommand {
    virtual ~ICommand() = default;
    virtual bool canExecute() const = 0;      // 현재 컨텍스트에서 실행 가능?
    virtual void execute() = 0;               // 수행
    virtual bool canUndo() const { return false; }
    virtual void undo() {}                    // 되돌리기
    virtual UINT id() const = 0;              // 바인딩된 명령 ID(MFC 리소스 ID)
};
```

### 1-2. 라우팅 상에서의 위치
- **데이터에 의존**하는 명령(삽입/삭제/포맷 변경)은 **문서/뷰 상태**가 필요 →  
  명령 객체를 **뷰/문서**에 붙여두고 **활성 뷰 기준**으로 `canExecute()` 판단.

---

## 2. 명령 관리자와 Undo/Redo 스택

```cpp
class CommandManager {
public:
    bool busy() const noexcept { return m_busy; }          // 긴 작업 중?
    void setBusy(bool b) { m_busy = b; }

    void execute(std::shared_ptr<ICommand> cmd) {
        if (!cmd->canExecute() || m_busy) return;
        cmd->execute();
        if (cmd->canUndo()) {
            m_undo.push(cmd);
            while (!m_redo.empty()) m_redo.pop(); // 새로운 분기
        }
    }
    bool canUndo() const { return !m_undo.empty() && m_undo.top()->canUndo(); }
    bool canRedo() const { return !m_redo.empty(); }
    void undo() {
        if (!canUndo()) return;
        auto c = m_undo.top(); m_undo.pop();
        c->undo();
        m_redo.push(c);
    }
    void redo() {
        if (!canRedo()) return;
        auto c = m_redo.top(); m_redo.pop();
        c->execute();
        if (c->canUndo()) m_undo.push(c);
    }
private:
    bool m_busy = false;
    std::stack<std::shared_ptr<ICommand>> m_undo, m_redo;
};
```

- 프레임/뷰/문서 중 하나에 `CommandManager`를 **멤버로 보관** (보통 **문서**에 두면 데이터 단위로 Undo/Redo가 직관적).

---

## 3. 간단 명령 구현 예 — 텍스트 편집

### 3-1. 문서 모델
```cpp
class CMyDoc : public CDocument {
public:
    CString m_text;
    CommandManager m_cmds;
    // …
};
```

### 3-2. InsertTextCommand
```cpp
class InsertTextCommand : public ICommand {
    CMyDoc* m_doc{};
    CString m_what;
    int m_pos{};
public:
    InsertTextCommand(CMyDoc* doc, CString what, int pos)
        : m_doc(doc), m_what(std::move(what)), m_pos(pos) {}
    UINT id() const override { return ID_EDIT_INSERT; }
    bool canExecute() const override {
        return m_doc && m_pos >= 0 && m_pos <= m_doc->m_text.GetLength();
    }
    void execute() override {
        m_doc->m_text.Insert(m_pos, m_what);
        m_doc->SetModifiedFlag(TRUE);
        m_doc->UpdateAllViews(nullptr, 0, nullptr);
    }
    bool canUndo() const override { return true; }
    void undo() override {
        m_doc->m_text.Delete(m_pos, m_what.GetLength());
        m_doc->SetModifiedFlag(TRUE);
        m_doc->UpdateAllViews(nullptr, 0, nullptr);
    }
};
```

### 3-3. 핸들러/업데이트
```cpp
// View 클래스 메시지 맵
BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_COMMAND(ID_EDIT_INSERT, &CMyView::OnEditInsert)
    ON_UPDATE_COMMAND_UI(ID_EDIT_INSERT, &CMyView::OnUpdateEditInsert)

    ON_COMMAND(ID_EDIT_UNDO, &CMyView::OnEditUndo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, &CMyView::OnUpdateEditUndo)
END_MESSAGE_MAP()

void CMyView::OnEditInsert() {
    auto* doc = GetDocument();
    auto cmd = std::make_shared<InsertTextCommand>(doc, _T("Hello"), doc->m_text.GetLength());
    doc->m_cmds.execute(cmd);
}

void CMyView::OnUpdateEditInsert(CCmdUI* pUI) {
    auto* doc = GetDocument();
    auto cmd = InsertTextCommand(doc, _T("x"), doc->m_text.GetLength());
    pUI->Enable(cmd.canExecute());
}

void CMyView::OnEditUndo() {
    GetDocument()->m_cmds.undo();
}
void CMyView::OnUpdateEditUndo(CCmdUI* pUI) {
    pUI->Enable(GetDocument()->m_cmds.canUndo());
}
```

> 포인트  
> - **업데이트 핸들러**에서 **명령 객체의 canExecute()**를 호출해 **Enable 상태**를 결정.  
> - 실행 핸들러는 `execute()`만 호출 → **UI 로직과 비즈니스 로직 분리**.

---

## 4. Check/Radio/Text 업데이트

### 4-1. 체크 가능한 토글 명령
```cpp
class ToggleBoldCommand : public ICommand {
    CMyDoc* m_doc{};
public:
    ToggleBoldCommand(CMyDoc* doc) : m_doc(doc) {}
    UINT id() const override { return ID_FMT_BOLD; }
    bool canExecute() const override { return m_doc != nullptr; }
    void execute() override {
        m_doc->m_bold = !m_doc->m_bold;
        m_doc->UpdateAllViews(nullptr);
        m_doc->SetModifiedFlag(TRUE);
    }
    bool isChecked() const { return m_doc && m_doc->m_bold; }
};
```

### 4-2. UI 반영
```cpp
ON_COMMAND(ID_FMT_BOLD, &CMyView::OnFmtBold)
ON_UPDATE_COMMAND_UI(ID_FMT_BOLD, &CMyView::OnUpdateFmtBold)

void CMyView::OnFmtBold() {
    GetDocument()->m_cmds.execute(std::make_shared<ToggleBoldCommand>(GetDocument()));
}
void CMyView::OnUpdateFmtBold(CCmdUI* pUI) {
    ToggleBoldCommand probe(GetDocument());
    pUI->Enable(probe.canExecute());
    pUI->SetCheck(probe.isChecked() ? 1 : 0);
}
```

### 4-3. 라디오 그룹
```cpp
enum class Align { Left, Center, Right };

class AlignCommand : public ICommand {
    CMyDoc* m_doc{};
    Align m_to{};
public:
    AlignCommand(CMyDoc* doc, Align to) : m_doc(doc), m_to(to) {}
    UINT id() const override {
        switch (m_to) {
            case Align::Left:   return ID_ALIGN_LEFT;
            case Align::Center: return ID_ALIGN_CENTER;
            case Align::Right:  return ID_ALIGN_RIGHT;
        } return 0;
    }
    bool canExecute() const override { return m_doc != nullptr; }
    void execute() override { m_doc->m_align = m_to; m_doc->UpdateAllViews(nullptr); }
    bool isCurrent() const { return m_doc && m_doc->m_align == m_to; }
};
// 업데이트 공통 함수
void UpdateAlignUI(CCmdUI* pUI, CMyDoc* doc, Align thisOne) {
    AlignCommand probe(doc, thisOne);
    pUI->Enable(probe.canExecute());
    pUI->SetRadio(probe.isCurrent());
}
```

```cpp
ON_UPDATE_COMMAND_UI(ID_ALIGN_LEFT,   &CMyView::OnUpdateAlignLeft)
ON_UPDATE_COMMAND_UI(ID_ALIGN_CENTER, &CMyView::OnUpdateAlignCenter)
ON_UPDATE_COMMAND_UI(ID_ALIGN_RIGHT,  &CMyView::OnUpdateAlignRight)

void CMyView::OnUpdateAlignLeft(CCmdUI* pUI)   { UpdateAlignUI(pUI, GetDocument(), Align::Left); }
void CMyView::OnUpdateAlignCenter(CCmdUI* pUI) { UpdateAlignUI(pUI, GetDocument(), Align::Center); }
void CMyView::OnUpdateAlignRight(CCmdUI* pUI)  { UpdateAlignUI(pUI, GetDocument(), Align::Right); }
```

### 4-4. 동적 텍스트(버튼 제목 변경)
```cpp
ON_UPDATE_COMMAND_UI(ID_RUN, &CMyView::OnUpdateRunCaption)
void CMyView::OnUpdateRunCaption(CCmdUI* pUI) {
    auto* doc = GetDocument();
    pUI->Enable(!doc->m_cmds.busy());
    pUI->SetText(doc->m_cmds.busy() ? _T("취소") : _T("실행"));
}
```

---

## 5. 긴 작업(Async)과 Busy 상태, 취소

### 5-1. BusyGuard
```cpp
struct BusyGuard {
    CommandManager& mgr;
    explicit BusyGuard(CommandManager& m) : mgr(m) { mgr.setBusy(true); }
    ~BusyGuard() { mgr.setBusy(false); }
};
```

### 5-2. AsyncCommand 예제 (작업 스레드 + 취소)
```cpp
class ExportCommand : public ICommand {
    CMyDoc* m_doc{};
    std::atomic_bool m_cancel{false};
    std::thread m_worker;
public:
    ExportCommand(CMyDoc* doc) : m_doc(doc) {}
    UINT id() const override { return ID_FILE_EXPORT; }
    bool canExecute() const override { return m_doc != nullptr && !m_doc->m_cmds.busy(); }
    void execute() override {
        BusyGuard busy(m_doc->m_cmds);
        m_cancel.store(false);
        m_worker = std::thread([this]{
            // 긴 작업: 주기적으로 m_cancel 확인
            for (int i=0;i<100 && !m_cancel.load();++i) {
                // … chunk 처리 …
                ::Sleep(10);
            }
            // 완료/취소 후 UI 갱신
            AfxGetApp()->PostThreadMessageW(WM_APP+1, 0, 0);
        });
        m_worker.detach();
    }
    void cancel() { m_cancel.store(true); }
};
```

### 5-3. UI와 연결
```cpp
ON_COMMAND(ID_FILE_EXPORT, &CMyView::OnExport)
ON_UPDATE_COMMAND_UI(ID_FILE_EXPORT, &CMyView::OnUpdateExport)

void CMyView::OnExport() {
    auto* doc = GetDocument();
    doc->m_cmds.execute(std::make_shared<ExportCommand>(doc));
}
void CMyView::OnUpdateExport(CCmdUI* pUI) {
    pUI->Enable(!GetDocument()->m_cmds.busy());
}
```

> 팁  
> - 작업 중에는 **관련 명령을 Disable**하고, **취소 명령**만 Enable.  
> - 진행률/취소 버튼은 **별도 명령**으로 노출하면 `ON_UPDATE_COMMAND_UI`로 자연스럽게 토글 가능.

---

## 6. 권한/선택/상태 기반 Enable 로직

### 6-1. 선택이 있어야 가능한 명령
```cpp
class DeleteSelectionCommand : public ICommand {
    CMyDoc* m_doc{};
public:
    DeleteSelectionCommand(CMyDoc* d) : m_doc(d) {}
    UINT id() const override { return ID_EDIT_DELETE; }
    bool canExecute() const override { return m_doc && m_doc->HasSelection(); }
    void execute() override { m_doc->DeleteSelection(); m_doc->UpdateAllViews(nullptr); }
};
```

### 6-2. 권한(읽기 전용)
```cpp
class SaveCommand : public ICommand {
    CMyDoc* m_doc{};
public:
    SaveCommand(CMyDoc* d): m_doc(d) {}
    UINT id() const override { return ID_FILE_SAVE; }
    bool canExecute() const override { return m_doc && !m_doc->IsReadOnly() && m_doc->IsModified(); }
    void execute() override { m_doc->DoFileSave(); }
};
```

> 원칙: **보기(View) 로직**은 명령에 넣지 말고, **데이터/권한 판단**은 문서/모델로 위임.

---

## 7. SDI/MDI/대화상자별 차이와 패턴

### 7-1. SDI
- 활성 뷰 1개 → 단순. `GetDocument()` 기준으로 명령 판단.

### 7-2. MDI
- **활성 Child View**가 기준. 다른 문서의 상태가 UI에 섞이지 않도록 **항상 활성 뷰/문서**를 참조.
- 메뉴 병합 시 `ON_UPDATE_COMMAND_UI`도 해당 Child의 핸들러가 호출됨.

```cpp
auto* active = static_cast<CMyView*>(GetMainFrame()->GetActiveView());
if (active) active->OnUpdate…(pUI);
```

### 7-3. 대화상자 기반
- `ON_UPDATE_COMMAND_UI`는 자동 호출되지 않음 → **Idle 루프에서** `UpdateDialogControls(this, FALSE)` 호출.
- 또는 **상태 변화 시** 한 번만 호출하여 과도한 비용 방지.

```cpp
BOOL CMainDlg::PreTranslateMessage(MSG* pMsg) {
    UpdateDialogControls(this, FALSE); // 또는 타이머에서 주기 호출
    return CDialogEx::PreTranslateMessage(pMsg);
}
```

---

## 8. 메뉴/툴바/리본과 동기화 (shallow vs deep)

- **같은 명령 ID**를 메뉴와 툴바(리본)에 모두 바인딩하면 **하나의 Update 핸들러**로 동시 제어.  
- 텍스트/아이콘만 다른 항목은 **동일 Enable/Check** 상태를 공유.

---

## 9. CommandFactory & 중앙 등록(규모가 커질 때)

```cpp
class CommandRegistry {
public:
    using Creator = std::function<std::shared_ptr<ICommand>()>;
    void reg(UINT id, Creator c) { m_map[id] = std::move(c); }
    std::shared_ptr<ICommand> make(UINT id) const {
        if (auto it = m_map.find(id); it != m_map.end()) return it->second();
        return {};
    }
private:
    std::unordered_map<UINT, Creator> m_map;
};
```

- 초기화 코드에서:
```cpp
reg.reg(ID_EDIT_INSERT, [doc]{ return std::make_shared<InsertTextCommand>(doc, _T("Hello"), doc->m_text.GetLength()); });
reg.reg(ID_FMT_BOLD,   [doc]{ return std::make_shared<ToggleBoldCommand>(doc); });
```

- 핸들러/업데이트:
```cpp
void CMyView::OnCommandGeneric(UINT id) {
    if (auto cmd = m_registry.make(id)) GetDocument()->m_cmds.execute(cmd);
}
void CMyView::OnUpdateCommandGeneric(CCmdUI* pUI) {
    if (auto cmd = m_registry.make(pUI->m_nID)) {
        pUI->Enable(cmd->canExecute());
        // 필요 시 체크/라디오/텍스트도 인터페이스 확장해 반영
    } else {
        pUI->Enable(FALSE);
    }
}
```

> 대규모 앱에서 **핸들러 보일러플레이트 감소** + **명령 추가/제거의 국소화**.

---

## 10. 단축키/가속기와 명령 패턴

- 가속기는 **명령 ID**를 트리거합니다.  
- Command 패턴을 쓰면 **마우스/메뉴/단축키**가 모두 **같은 로직**으로 수렴.

---

## 11. 상태 캐싱과 성능

- `ON_UPDATE_COMMAND_UI`는 **자주 호출**됩니다(Idle마다).  
- `canExecute()`가 비싸면 **캐싱**: 상태 변경 이벤트에서만 invalidate.

```cpp
struct CommandStateCache {
    bool insertEnabled{};
    bool boldChecked{};
    // invalidate & recompute on document changes
};
```

---

## 12. 테스트 전략

- `ICommand` 단위 테스트: `canExecute/execute/undo` 검증  
- `CommandManager` 시나리오: execute→undo→redo 순서/상태  
- UI 업데이트: `CCmdUI`를 **테스트 더블**로 대체해 Enable/Check 결과 검증

```cpp
struct FakeCmdUI : CCmdUI {
    BOOL enabled = FALSE; int checked = 0; CString text;
    void Enable(BOOL bOn) override { enabled = bOn; }
    void SetCheck(int nCheck) override { checked = nCheck; }
    void SetText(LPCTSTR lpszText) override { text = lpszText; }
};
```

---

## 13. 흔한 문제 & 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| 버튼이 항상 회색 | Update 핸들러가 잘못된 문서/뷰 참조 | **활성 뷰/문서** 기준으로 참조 |
| Undo가 안 됨 | execute 후 스택에 push 누락 | `canUndo()` true면 **undo 스택 push** |
| 긴 작업 중 반복 실행 | Busy 상태 미관리 | `BusyGuard`로 **중복 차단** |
| Dialog에서 업데이트 안 됨 | Idle 트리거 없음 | `UpdateDialogControls(this, FALSE)` 호출 |
| 라디오 체크 이상 | 그룹별 SetRadio 사용 안함 | 각 항목에서 `SetRadio(true/false)` |

---

## 14. 확장 아이디어

- **MacroCommand**: 여러 명령 묶어 하나처럼 실행/취소
- **TransactionCommand**: 실패 시 전체 롤백(강한 예외 보장)
- **ParameterizedCommand**: 파라미터 바인딩(예: InsertText의 텍스트를 실행 시점에 입력)
- **Record/Replay**: 명령 시퀀스 로깅/재실행(테스트/매크로)

---

## 15. 보일러플레이트: 공통 베이스 + 헬퍼

```cpp
// 기본 베이스: 체크/라디오/텍스트를 위한 선택적 인터페이스
struct IUiHints {
    virtual bool uiChecked() const { return false; }
    virtual bool uiRadio()  const { return false; }
    virtual CString uiText() const { return _T(""); }
};

template<class CmdT>
void UpdateUIFromCommand(CCmdUI* pUI, CmdT&& makeCmd) {
    auto cmd = makeCmd();
    pUI->Enable(cmd->canExecute());
    if constexpr (std::is_base_of_v<IUiHints, typename std::remove_reference_t<decltype(*cmd)>>) {
        if (!cmd->uiText().IsEmpty()) pUI->SetText(cmd->uiText());
        pUI->SetCheck(cmd->uiChecked() ? 1 : 0);
        if (cmd->uiRadio()) pUI->SetRadio(TRUE);
    }
}
```

사용:
```cpp
void CMyView::OnUpdateFmtBold(CCmdUI* pUI) {
    UpdateUIFromCommand(pUI, [this]{ return std::make_shared<ToggleBoldCommand>(GetDocument()); });
}
```

---

## 16. 체크리스트

- [ ] 명령별 `canExecute()`가 **단일 진실 소스**  
- [ ] `ON_UPDATE_COMMAND_UI`에서 **canExecute/checked/radio/text** 반영  
- [ ] 긴 작업 중 `BusyGuard`로 **중복 실행 차단**  
- [ ] Undo/Redo 스택 정책(분기 파기/합치기) 정의  
- [ ] SDI/MDI/대화상자 **활성 문맥** 기준  
- [ ] Dialog는 **`UpdateDialogControls`** 호출  
- [ ] 상태 캐싱으로 **빈번한 업데이트 비용** 절감  
- [ ] 가속기/툴바/메뉴 **같은 ID**로 일원화  
- [ ] 테스트 더블로 UI 업데이트 검증  
- [ ] 에러/예외/취소 경로에 **일관된 로깅** 추가

---

### 마무리

**Command 패턴**은 “무엇을 할 수 있는가(Enable) → 실행 → 되돌리기”를 **객체**로 모듈화합니다.  
MFC의 **명령 라우팅 + `ON_UPDATE_COMMAND_UI`**는 해당 객체의 상태를 **UI 전체와 자동 동기화**할 수 있는 훌륭한 훅을 제공합니다.
