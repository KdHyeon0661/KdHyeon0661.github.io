---
layout: post
title: 이산수학 - 회로의 최소화
date: 2025-07-03 22:20:23 +0900
category: 이산수학
---
# 회로의 최소화 (Minimization of Boolean Circuits)

## 왜 최소화가 중요한가?

- **비용 절감**: 게이트/셀 수 감소 → 면적 축소
- **성능 향상**: 논리 깊이 감소 → 임계경로 지연 감소(클록 향상)
- **전력 절감**: 스위칭 활동·부하 감소
- **신뢰성**: Hazards(글리치) 감소, 팬아웃/부하 관리 용이
- **테크 매핑 용이**: NAND/NOR only, 표준셀, FPGA LUT 등 제약에 맞춘 변환을 단순화

---

## 최소화의 대상과 메트릭

- **게이트 수**(cell count), **리터럴 수**(literals), **논리 깊이**(levels), **팬인/팬아웃**, **스위칭 활동**
- **지연 모델**: 게이트 고유 지연 + 배선 지연(+팬아웃·부하)
- **파워 모델(대략)**: 동적 $$P \propto \alpha C V^2 f$$ (활성도·부하·전압·주파수), 정적 누설

---

## 부울 대수로 간소화 (기초 공식·테크닉)

> **핵심 법칙(발췌)**
> $$\begin{aligned}
&\text{멱등: }A + A = A,\quad A\cdot A = A\\
&\text{항등: }A+0=A,\quad A\cdot 1 = A\\
&\text{여원: }A+\overline{A}=1,\quad A\cdot \overline{A}=0\\
&\text{결합/교환: }(A+B)+C = A+(B+C),\ A+B=B+A,\ \dots\\
&\text{분배: }A(B+C)=AB+AC,\quad A+BC=(A+B)(A+C)\\
&\text{드 모르간: }\overline{A+B}=\overline{A}\cdot \overline{B},\ \overline{AB}=\overline{A}+\overline{B}\\
&\text{흡수: }A+AB = A,\quad A(A+B)=A\\
&\text{컨센서스: }AB + \overline{A}C + BC = AB + \overline{A}C
\end{aligned}$$

### 예 2.1) 즉시 단순화

$$
F = A\cdot B + A\cdot \overline{B} = A(B+\overline{B}) = A
$$

### 예 2.2) 공통팩터 인수분해(다-레벨화)

$$
F = AB + AC \Rightarrow A(B+C)
$$
- SOP 두 항(AND 2개 + OR 1개) → AND 1 + OR 1 (게이트/리터럴 감소, 깊이 재배치)

---

## 정규형과 두-레벨 최소화

### 용어

- **Minterm**: 모든 변수의 보수/비보수 포함 AND 항
- **SOP**(Sum of Products): Minterm들의 OR
- **POS**(Product of Sums): Maxterm들의 AND
- 모든 부울함수는 **SOP/POS**로 표현 가능

### Don’t-Care (X) 적극 활용

- 설계 제약상 **절대 발생하지 않는 입력** 혹은 **무시 가능한 출력**은 X로 표기 → **큰 그룹** 형성에 사용 → 최소화 강화

---

## 카르노 맵(K-Map): 2~4(6)변수 시각 최소화

> 그레이 코드(인접 칸 한 비트 차) 기반으로 **1의 군집(1,2,4,8,...)**을 최대화

### 3-변수 예 (문제에서 제시한 유형과 유사)

진리표(1의 위치만 나열):
$$m(1,3,4,5,6,7) \quad \text{(변수: }A,B,C)$$

K-Map(AB 행, C 열):

| AB \ C | 0 | 1 |
|--|--|--|
| 00 | 0 | 1 |
| 01 | 1 | 1 |
| 11 | 0 | 0 |
| 10 | 0 | 1 |

- 그룹화:
  - 열 \(C=1\) 세 칸(사실 4개 가능 시 wrap 활용) → 항 **\(C\)**
  - 행 \(B=1\) 의 두 칸 묶음 → 항 **\(B\)**
- **최소식**:
  $$F = B + C$$

> **검증**: 원래 SOP보다 게이트/리터럴 대폭 감소(OR 1개, 입력은 \(B,C\)).

### Don’t-Care 예 (4-변수)

- 1: \(m(1,3,7,15)\), X: \(d(5,13)\) → X를 포함해 4개/8개 군집을 만들면 리터럴 제거가 급증.

---

## 퀘인-맥클러스키(Quine-McCluskey, QMC): 5~8변수 소형 해법

- **체계적/기계적** 두-레벨 최소화(정확), NP-난해로 **변수가 커지면 비현실적**
- 단계:
  1) 1의 개수별로 minterm 그룹핑
  2) 한 비트 차이 묶음 → **프라임 임플리컨트(PI)** 도출
  3) **PI 차트**로 **필수(essential) PI** 채택 + 나머지 커버 최소화

### 파이썬 구현 (SOP + Don’t-Care 지원, 소규모용)

```python
from itertools import combinations

def bits(n, w): return format(n, f'0{w}b')

def combine(a, b):
    # a,b: 문자열 ('0','1','-'), 한 자리 차이면 '-'로 병합
    diff = 0; out=[]
    for x,y in zip(a,b):
        if x==y: out.append(x)
        elif x!=y and x!='-' and y!='-':
            diff += 1; out.append('-')
        else:
            return None
    return ''.join(out) if diff==1 else None

def covers(term, m):
    # term: like '1-0-'; m: int
    b = bits(m, len(term))
    return all(t==b_i or t=='-' for t,b_i in zip(term, b))

def qm_minimize(num_vars, ones, dcs=None):
    if dcs is None: dcs=[]
    implicants = [bits(m, num_vars) for m in sorted(ones + dcs)]
    groups = {}
    for s in implicants:
        groups.setdefault(s.count('1'), set()).add(s)

    # Step1: combine iteratively
    used=set()
    P=set()
    while groups:
        new_groups={}
        keys=sorted(groups.keys())
        marked=set()
        for i in range(len(keys)-1):
            for a in groups[keys[i]]:
                for b in groups[keys[i+1]]:
                    c = combine(a,b)
                    if c:
                        new_groups.setdefault(c.count('1'), set()).add(c)
                        marked.add(a); marked.add(b)
        # collect unmarked as prime implicants
        for k,vs in groups.items():
            for v in vs:
                if v not in marked:
                    P.add(v)
        groups={}
        # normalize dedup
        tmp=set()
        for k,vs in new_groups.items():
            for v in vs: tmp.add(v)
        if tmp:
            groups={}
            for v in tmp:
                groups.setdefault(v.count('1'), set()).add(v)

    # Step2: prime implicant chart
    # essential first
    cover = {m:[] for m in ones}
    for p in P:
        for m in ones:
            if covers(p, m):
                cover[m].append(p)
    essential=set()
    selected=set()
    for m, lst in cover.items():
        if len(lst)==1:
            essential.add(lst[0])
    selected |= essential

    # cover remaining mins using greedy
    uncovered=set(m for m in ones if not any(covers(p,m) for p in selected))
    while uncovered:
        # choose PI covering most uncovered mins
        best=None; best_cov=set()
        for p in P:
            cov=set(m for m in uncovered if covers(p,m))
            if len(cov)>len(best_cov):
                best=p; best_cov=cov
        selected.add(best)
        uncovered -= best_cov

    return sorted(selected)
```

#### 결과를 부울식으로 변환

{% raw %}
```python
def term_to_expr(term, vars):
    # vars: ['A','B','C',...]
    out=[]
    for t,v in zip(term, vars):
        if t=='1': out.append(v)
        elif t=='0': out.append(f"\\overline{{{v}}}")
    if not out: return '1'
    return ' \\cdot '.join(out)

def implicants_to_SOP(terms, vars):
    return ' + '.join(term_to_expr(t, vars) for t in terms)
```
{% endraw %}

#### 검증 (진리표 동치성)

```python
def eval_term(term, val):
    for i,t in enumerate(term):
        b = (val>> (len(term)-1-i)) & 1
        if t=='1' and b!=1: return 0
        if t=='0' and b!=0: return 0
    return 1

def eval_SOP(terms, val):
    return 1 if any(eval_term(t,val) for t in terms) else 0

def equivalent(num_vars, ones, dcs, terms):
    for v in range(1<<num_vars):
        desired = 1 if v in ones else (0 if v not in (dcs or []) else None)
        if desired is None:
            continue
        got = eval_SOP(terms, v)
        if got!=desired:
            return False, v
    return True, None
```

##### 사용 예

```python
# 예: 3변수, ones = 1,3,4,5,6,7  (-> 이론 최소 F=B+C)

num_vars=3; ones=[1,3,4,5,6,7]; dcs=[]
pis = qm_minimize(num_vars, ones, dcs)
print("PIs:", pis)
print("SOP:", implicants_to_SOP(pis, ['A','B','C']))
print("EQ:", equivalent(num_vars, ones, dcs, pis))
```

---

## 다-레벨 최소화: 팩토링·공유·분해

두-레벨(완전 SOP/POS) 최적은 **게이트 수는 최소**여도 **깊이(지연)**가 길 수 있음.
**다-레벨**은 **인수분해**, **공통 부분식 공유**, **샤논 분해**로 리터럴·깊이를 함께 줄임.

### 인수분해(Algebraic/Boolean factoring)

- **Algebraic**: 분배/흡수 기반 공통팩터 추출
  예) $$F=AB+AC+AD = A(B+C+D)$$
- **Boolean**: 보수/컨센서스까지 활용한 더 강한 분해

### 공통 부분식 공유(Multi-output 공유)

- 다출력 회로에서 **공통 곱항/부분식**을 **한 번만 구현**하고 여러 출력이 공유 → 총 게이트 대폭 감소
- 예) 2비트 덧셈기에서 캐리·합 모두가 **\(A\oplus B\)**, **\(AB\)** 를 공유

### Shannon 분해(변수 분해)

$$
f = x\cdot f_{x=1} + \overline{x}\cdot f_{x=0}
$$
- BDD/의사결정트리와 연결, **선택기 구조**로 매핑 쉬움
- **특정 변수로 분해**하면 배선/팬아웃 균형화에 유리

---

## Hazard(글리치)와 안전 최소화

- **Static-1 hazard**: 이론상 1이어야 하는 구간 전이에서 **잠깐 0**으로 떨어짐
- **Static-0 hazard**: 반대
- 원인: **다중 경로 지연 불균형**
- **대책**: K-Map에서 인접 1들의 **중첩 커버**(컨센서스 항 추가)
  - 예) $$F=AB + \overline{A}C$$ 는 입력 변환에서 glitch 가능 → **\(BC\)**(컨센서스) 추가로 제거:
    $$F=AB + \overline{A}C + BC$$
- **순차회로/레지스터** 앞단은 글리치 내성이 있으나, **비동기/게이트 제어신호**는 반드시 무해화

---

## 테크놀로지 매핑

### NAND/NOR Only

- 드 모르간으로 변환하여 **NAND2/NOR2** 셀만으로 구현 가능
- **NOT**: NAND(A,A) 또는 NOR(A,A)
- 예) **SOP → NAND-NAND** 2-단 구조:
  - 1단: 각 곱항을 NAND( = \(\overline{\text{product}}\))
  - 2단: 이 출력들의 NAND = **OR** 구현

### 표준셀(ASIC) vs LUT(FPGA)

- **ASIC**: 논리식을 라이브러리 셀에 매핑(ABC 등) → **지연/면적 트레이드오프**
- **FPGA**: **k-LUT**(k입력까지 임의 함수)로 분해 → 게이트 수보다 **LUT 수/깊이**가 핵심
  - XOR류는 LUT에 싸게, 긴 AND-OR는 LUT 폭을 초과하면 **분할** 필요

### 팬인/팬아웃 제약

- 큰 팬인 OR/AND는 실제 셀에서는 분할 필요 → **균형 트리**로 구성해 지연 완화
- 팬아웃이 크면 **버퍼 트리** 삽입

---

## 사례 연구

### 다수결(3-입력 Majority)

- 정의: 입력 중 **2개 이상 1 → 1**
$$
F = AB + BC + CA
$$
- K-Map으로도 쉽게 도출
- **Hazard-Free** 필요 시 중첩 커버 체크(세 항이 충분히 중첩되어 정적 hazard 거의 없음)

### 7-세그먼트(일부) 간소화

- 입력(BCD 4비트) → 출력 a,b,c,d,e,f,g
- **Don’t-Care**: 10~15(미사용 BCD) → K-Map에서 큰 그룹 형성 → 항 급감
- 다출력에서 **공통 부분식 공유**로 게이트 대폭 절감

### 패리티(Parity)

- 홀수/짝수 판별
- 두-레벨 SOP 최소화로는 항이 지수적으로 증가, **XOR 체인**이 최선
- 매핑: XOR → (NAND/NOR/AND/OR) 혼합 또는 LUT 한 개(입력폭 제한 내)

---

## 실전 예제: 진리표 → 최소화 → 검증 → Verilog/NAND 매핑

### 문제

다음 진리표를 최소화하라 (3변수 \(A,B,C\)):

| A | B | C | F |
|---|---|---|---|
| 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 1 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 |
| 1 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 |

- 1의 minterm: \(m(1,2,3,5,6,7)\)

**K-Map 해**:
- 열 \(C=1\) 묶음 → \(C\)
- 행 \(B=1\) 묶음 → \(B\)
- **최소**: $$F = B + C$$

**QMC로 확인**
```python
num_vars=3; ones=[1,2,3,5,6,7]; dcs=[]
pis = qm_minimize(num_vars, ones, dcs)
print("PIs:", pis)  # 예: ['-1-', '--1'] 등 (B, C 대응)
print("SOP:", implicants_to_SOP(pis, ['A','B','C']))
print("EQ:", equivalent(num_vars, ones, dcs, pis))  # (True, None)
```

### Verilog(가상)

```verilog
module F_min(input A, input B, input C, output F);
  assign F = B | C;
endmodule
```

### NAND-only 매핑 스케치

- OR = NAND(NOT B, NOT C)
- NOT X = NAND(X,X)
```verilog
module F_min_nand(input A, input B, input C, output F);
  wire nB, nC;
  assign nB = ~(B & B);  // NAND(B,B)
  assign nC = ~(C & C);
  assign F  = ~(nB & nC); // NAND(nB,nC) = B OR C
endmodule
```

---

## 다출력 최소화(공유) 미니 예제

두 출력:
$$
\begin{aligned}
F_1 &= AB + AC = A(B+C)\\
F_2 &= AB + \overline{A}C
\end{aligned}
$$

- 공통 부분식 \(P= B+C\), \(Q=AB\) 등 정의해서 공유:
```verilog
wire p = B | C;
wire q = A & B;
assign F1 = A & p;         // A(B+C)
assign F2 = q | (~A & C);  // AB + A' C
```
- **게이트 공유**로 총합 최소화, 경로 균형도 용이

---

## 검증(동치성/회귀) 체크리스트

- **동치성**: 진리표 전 탐색(작은 n), BDD/ SAT 등(큰 n)
- **무의미 입력(X) 처리**: X는 동치성 비교에서 **스킵**
- **타이밍**: 임계경로(최대 지연) 계산, 팬아웃/부하 확인
- **Hazard**: 비동기 신호 경로에 컨센서스 항 추가 여부 점검

---

## 도구·흐름 개요

- **수작업**: K-Map(≤4~6변수)
- **정확 최소화**: Quine-McCluskey(소규모), ILP/SAT(연구용)
- **실무형 휴리스틱**: **Espresso**(대규모 two-level), **ABC**(다-레벨 factoring/리밸런싱/매핑), **Yosys**(오픈 합성)
- **FPGA**: Technology mapping to LUT(k) + P&R에서 지연 최적화

---

## 연습 문제

1) K-Map으로 다음 4-변수 SOP를 최소화하고 Hazard-free가 되도록 컨센서스 항을 제시하라.
2) Don’t-Care를 추가했을 때와 아닐 때의 최소식 차이를 비교하라.
3) QMC로 5-변수 함수(ones 10~12개)를 최소화하고, 동치성 함수를 작성해 검증하라.
4) 다출력 함수에서 공통 부분식을 최대 공유하도록 다-레벨 인수분해를 실행하라.
5) SOP를 NAND-NAND 2-단 구조로 매핑하고, 팬인 제한(최대 3)을 만족하도록 트리로 분해하라.

---

## 핵심 요약

- **두-레벨 최소화**: K-Map(작은 n) → QMC/Espresso(큰 n)
- **다-레벨 최소화**: 인수분해·공유·Shannon 분해로 **깊이/리터럴** 동시 절감
- **Don’t-Care** 적극 활용, **Hazard**는 컨센서스 항으로 방지
- **테크 매핑**: NAND/NOR only, 표준셀, FPGA LUT 제약 고려
- **검증**: 진리표/BDD/SAT로 동치성 확인 + 타이밍/전력 체크
