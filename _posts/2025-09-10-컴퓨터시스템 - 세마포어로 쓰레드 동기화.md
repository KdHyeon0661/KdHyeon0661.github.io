---
layout: post
title: 컴퓨터시스템 - 세마포어로 쓰레드 동기화
date: 2025-09-10 21:20:23 +0900
category: 컴퓨터시스템
---
# 세마포어로 쓰레드 동기화하기 (POSIX `sem_t` 중심, CS:APP 스타일 심화)

> 형식: 전체는 `~~~markdown`으로 감싸고, **코드/명령은 모두 ```**로 표기합니다.  
> 목표: **세마포어의 원리 → API 사용법(unnamed/named) → 대표 패턴(유한 버퍼, 배리어, 제한자, RW 잠금 등) → 안정성(취소‧데드록‧기아) → 성능/디버깅 포인트**를 체계적으로 이해합니다.

---

## 0) 세마포어란?

- **세마포어(semaphore)**는 정수 카운트를 가진 동기화 프리미티브입니다.  
  - `P()` ≈ **wait/down**: 카운트가 0이면 **대기**, 0보다 크면 **1 감소**하고 통과  
  - `V()` ≈ **post/up**: 카운트 **1 증가**, 대기 중인 쓰레드가 있으면 **깨움**
- 쓰임새:
  - **상호배제(Mutex)**: 이진 세마포어(0/1)로 임계구역 보호
  - **자원 카운팅**: 버퍼 슬롯, 연결 풀 등 **N개 자원** 제한
  - **주고받기(Hand-off)**, **생산자–소비자**, **배리어 대용**, **속도 제한**

> 세마포어는 **상태를 기억**합니다(신호가 먼저 와도 카운트에 누적). 반면 조건변수는 **상태(불변식) + 뮤텍스** 모델이며, 신호만으로는 충분하지 않습니다.

---

## 1) POSIX 세마포어 API 지도

### 1.1 unnamed 세마포어(`sem_t`)
- 헤더: `<semaphore.h>`
- 주요 함수:
  - `int sem_init(sem_t *sem, int pshared, unsigned int value);`
    - `pshared=0` → **쓰레드 간** (같은 프로세스)  
    - `pshared=1` → **프로세스 간**(공유메모리 필요)
  - `int sem_wait(sem_t *sem);`  — 0보다 크면 1 감소, 0이면 **블록**
  - `int sem_trywait(sem_t *sem);` — 비블록, 즉시 실패(EAGAIN)
  - `int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);` — **절대시간**
  - `int sem_post(sem_t *sem);` — 카운트 1 증가 & 대기 쓰레드 깨움
  - `int sem_destroy(sem_t *sem);`
  - `int sem_getvalue(sem_t *sem, int *sval);` — **주의: 경합 중 정확성 보장 X**

### 1.2 named 세마포어(프로세스 간, 파일시스템 네임스페이스)
- `sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);`
- `int sem_close(sem_t *sem);`
- `int sem_unlink(const char *name);`
- 장점: **프로세스 간 동기화**가 쉬움. 단, 파일시스템 네임 관리와 권한 주의.

### 1.3 신경 써야 할 점
- `sem_wait`/`sem_timedwait`는 **취소 가능 지점**(쓰레드 취소 시 정리 필요)
- `sem_timedwait`의 `timespec`은 **절대시간**(대개 `CLOCK_REALTIME`) — 시간 변경 영향을 받지 않게 하려면 `clock_gettime(CLOCK_REALTIME, …)`/또는 구현 확장 사용

---

## 2) 이진 세마포어로 **뮤텍스 대체** (가능하지만 권장X)

> 실무에서 상호배제는 **`pthread_mutex_t`**가 더 적합(우선순위 상속, 에러체크, 디버깅 친화). 세마포어는 **카운팅/제약**에 강함.

```c
#include <semaphore.h>
#include <pthread.h>

sem_t bin; // 0/1

void critical(){
  sem_wait(&bin);
  /* 임계구역 */
  sem_post(&bin);
}
int main(){
  sem_init(&bin, 0, 1);
  /* ... */
  sem_destroy(&bin);
}
```

---

## 3) 대표 패턴 ①: **유한 버퍼(생산자–소비자)**

버퍼 크기 `N`일 때, **빈 슬롯** 카운터 `slots=N`, **아이템 수** 카운터 `items=0`, 그리고 **큐 수정용** 이진 세마포어 `mutex=1`.

```c
#include <semaphore.h>
#include <pthread.h>

#define N 16
int q[N], in=0, out=0;
sem_t slots, items, mutex;

void put(int x){
  sem_wait(&slots);       // 빈 슬롯 확보
  sem_wait(&mutex);       // 큐 수정 보호
  q[in]=x; in=(in+1)%N;
  sem_post(&mutex);
  sem_post(&items);       // 아이템 증가 (소비자 깨움)
}
int get(void){
  int x;
  sem_wait(&items);       // 아이템 기다림
  sem_wait(&mutex);
  x=q[out]; out=(out+1)%N;
  sem_post(&mutex);
  sem_post(&slots);       // 빈 슬롯 회복
  return x;
}
int main(){
  sem_init(&slots,0,N);
  sem_init(&items,0,0);
  sem_init(&mutex,0,1);
  /* 생산자/소비자 스레드 생성 */
}
```

**특징**  
- `slots/items`가 **자원 카운트**를 정확히 표현  
- `mutex`는 **큐 배열 접근**만 보호 → 경합 최소화

---

## 4) 대표 패턴 ②: **배리어(Barrier) 대용**

P개 스레드가 같은 지점에서 **모두 도착**해야 다음 단계 진행.  
세마포어 2개로 **문 닫기/열기**를 번갈아 구현(2-페이즈 배리어).

```c
#include <semaphore.h>
#include <pthread.h>

int arrived = 0, P;
sem_t m, turnstile1, turnstile2;

void barrier_init(int p){
  P = p;
  sem_init(&m,0,1);
  sem_init(&turnstile1,0,0);
  sem_init(&turnstile2,0,1);
}
void phase1(){
  sem_wait(&m);
  arrived++;
  if (arrived==P) { sem_wait(&turnstile2); /* close 2 */ for(int i=0;i<P;i++) sem_post(&turnstile1); }
  sem_post(&m);
  sem_wait(&turnstile1); // 통과
}
void phase2(){
  sem_wait(&m);
  arrived--;
  if (arrived==0) { sem_wait(&turnstile1); /* close 1 */ for(int i=0;i<P;i++) sem_post(&turnstile2); }
  sem_post(&m);
  sem_wait(&turnstile2);
}
```

> 실무에선 `pthread_barrier_t`를 쓰는 게 단순하지만, 세마포어로도 동일한 개념 구현 가능.

---

## 5) 대표 패턴 ③: **동시 실행 수 제한(세마포어 = 토큰 버킷)**

예: 최대 8개의 병렬 작업만 허용.

```c
sem_t permits; // 초기값 = 8

void* worker(void*){
  sem_wait(&permits);           // 토큰 획득
  /* 네트워크/디스크 작업 등 */
  sem_post(&permits);           // 토큰 반환
  return NULL;
}
int main(){
  sem_init(&permits, 0, 8);
  /* 많은 스레드 생성해도 동시 수행은 8개로 제한 */
}
```

---

## 6) 대표 패턴 ④: **Readers–Writers** (기본 레시피 with semaphores)

읽기 다수/쓰기 단일. 간단 버전(공정성 완전 보장은 아님):

```c
sem_t roomEmpty;   // 1: 방(데이터)에 쓰기/읽기 독점권
sem_t turnstile;   // 1: writer에게 공평성 보장(간단)
sem_t m;           // readerCount 보호
int readerCount=0;

void reader_enter(){
  sem_wait(&turnstile);
  sem_post(&turnstile);
  sem_wait(&m);
  if (++readerCount == 1) sem_wait(&roomEmpty); // 첫 리더가 방 잠금
  sem_post(&m);
}
void reader_exit(){
  sem_wait(&m);
  if (--readerCount == 0) sem_post(&roomEmpty);
  sem_post(&m);
}
void writer_enter(){
  sem_wait(&turnstile);
  sem_wait(&roomEmpty);   // 독점
}
void writer_exit(){
  sem_post(&roomEmpty);
  sem_post(&turnstile);
}
```

> 공정성/기아 방지는 구현 세부(큐잉/FIFO 정책/OS 스케줄러)에 따라 달라질 수 있습니다. 실무에선 **`pthread_rwlock_t`** 고려.

---

## 7) 설계 원칙 & 주의점

1) **세마포어 순서 규약**  
   - 여러 세마포어를 연쇄적으로 기다릴 때 **항상 같은 순서**로 `sem_wait`(교착 방지).

2) **취소 안전(Cancellation Safety)**  
   - `sem_wait`는 **취소 가능 지점**. 중간에 취소되면 **획득한 세마포어를 반드시 반납**해야 함.  
   - 패턴: **정리 핸들러**로 `sem_post` 보장
     ```c
     void cleanup(void* s){ sem_post((sem_t*)s); }
     pthread_cleanup_push(cleanup, &mutex_sem);
     sem_wait(&mutex_sem);
     /* ... */
     pthread_cleanup_pop(1); // 1 → cleanup 호출
     ```

3) **스핀 vs 블록**  
   - `sem_trywait`로 바쁜 대기(spin) 전략을 섞을 수 있으나, **CPU 낭비**에 유의. 일반적으로 **블록**이 적합.

4) **`sem_getvalue` 오해 금지**  
   - **동시에** 값이 바뀔 수 있어 **디버깅용 참고** 외 의미가 크지 않음.

5) **기아(Starvation)**  
   - 특정 스레드가 오래 깨어나지 못할 수 있음. 필요한 경우 **FIFO 세마포어**(플랫폼 종속) 또는 상위 레벨 공정 로직 추가.

6) **우선순위 역전**  
   - 세마포어 자체는 해결책이 아님. 우선순위 상속은 **뮤텍스**에서 제공되는 경우가 많음.

7) **프로세스 간 사용**  
   - `sem_init(pshared=1)` + **공유 메모리**에 `sem_t` 배치, 또는 **named 세마포어** 사용.  
   - 충돌/크래시 복구 시 **상태 회복** 전략 필수(이상 상태에서 카운트 불일치 가능).

---

## 8) 타임아웃/에러 처리 템플릿

```c
#include <errno.h>
#include <time.h>

int sem_wait_abs(sem_t* s, long ms){
  struct timespec ts;
  clock_gettime(CLOCK_REALTIME, &ts);
  ts.tv_sec  += ms/1000;
  ts.tv_nsec += (ms%1000)*1000000L;
  if (ts.tv_nsec >= 1000000000L) { ts.tv_sec++; ts.tv_nsec -= 1000000000L; }
  for (;;) {
    if (sem_timedwait(s, &ts) == 0) return 0;
    if (errno == EINTR) continue;
    if (errno == ETIMEDOUT) return ETIMEDOUT;
    return errno;
  }
}
```

---

## 9) 디버깅·관찰·테스트

- **경합 시각화**: 긴 대기 시간이 어디인지 로그에 **스레드 ID + 타임스탬프** 기록
- **TSan(Clang/GCC `-fsanitize=thread`)**: 세마포어 사용 자체는 레이스를 제거하지 않습니다. **공유 데이터 접근 경로**를 TSan으로 검증.
- **죽은락(데드록) 탐지**: 락 순서 규약 문서화, 장시간 대기 시 스택덤프(신호로 `backtrace`) 출력.

---

## 10) 실전 예제 모음

### 10.1 스레드 풀: **세마포어로 작업 수 신호**

작업 큐에 push하면 `items`를 `post`, 워커는 `wait` 후 pop.

```c
#include <semaphore.h>
#include <pthread.h>
#include <stdlib.h>

typedef void (*job_fn)(void*);
typedef struct node { job_fn fn; void* arg; struct node* next; } node_t;

typedef struct {
  sem_t items;            // 큐에 아이템 수
  pthread_mutex_t m;
  node_t* head;
  int stop, n;
  pthread_t* th;
} pool_t;

void enqueue(pool_t* p, job_fn fn, void* arg){
  node_t* n = malloc(sizeof *n); n->fn=fn; n->arg=arg;
  pthread_mutex_lock(&p->m);
  n->next = p->head; p->head = n;
  pthread_mutex_unlock(&p->m);
  sem_post(&p->items);
}
void* worker(void* vp){
  pool_t* p = vp;
  for(;;){
    if (p->stop) break;
    if (sem_wait(&p->items) != 0) continue; // EINTR 재시도 단순화
    pthread_mutex_lock(&p->m);
    node_t* n = p->head; if (!n){ pthread_mutex_unlock(&p->m); continue; }
    p->head = n->next;
    pthread_mutex_unlock(&p->m);
    n->fn(n->arg); free(n);
  }
  return NULL;
}
void pool_init(pool_t* p, int n){
  sem_init(&p->items,0,0);
  pthread_mutex_init(&p->m,NULL);
  p->head=NULL; p->stop=0; p->n=n; p->th=calloc(n,sizeof*p->th);
  for(int i=0;i<n;i++) pthread_create(&p->th[i],NULL,worker,p);
}
```

### 10.2 속도 제한(레이트 리미터): **주기적으로 토큰 충전**
```c
// 주기적으로 sem_post()를 N회 호출해 요청 처리 속도 제한
```
- 타이머 스레드가 주기마다 `sem_post(&permits)`을 여러 번 호출 → 소비 스레드가 자연스럽게 제한됨.

### 10.3 파이프라인 단계 간 **핸드오프**
```c
// stage1 -> stage2 : stage2_ready 세마포어로 작업 전달 시점 제어
```

---

## 11) 세마포어 vs 다른 동기화와의 비교

| 기준 | 세마포어 | 뮤텍스 | 조건변수 | RW락 |
|---|---|---|---|---|
| 상호배제 | 이진 세마포어로 가능(권장 X) | 핵심 목적 | (자체 X, 상태 대기용) | 쓰기 단일/읽기 다중 |
| 카운팅 | **핵심 강점** | 불가 | 불가 | 불가 |
| 공정성 | 보장 없음(구현 따라 상이) | 구현 의존 | 구현 의존 | 구현 의존 |
| 우선순위 상속 | 일반적으로 없음 | **있을 수 있음** | N/A | 구현 의존 |
| 취소 안전 | 직접 관리 필요 | 상대적으로 수월 | 뮤텍스와 쌍 | 구현 의존 |

---

## 12) 체크리스트(현업용 요약)

- [ ] 자원/상태를 **카운팅 모델**로 표현할 수 있으면 세마포어가 적합  
- [ ] `sem_wait` ↔ `sem_post` **쌍 보장**(취소/에러 경로 포함)  
- [ ] 여러 세마포어 **획득 순서 고정**(교착 방지)  
- [ ] **기아 방지**(필요 시 추가 공정 로직)  
- [ ] `sem_timedwait`로 **타임아웃**과 **이상징후 로깅**  
- [ ] 프로세스 간이면 `pshared=1` 또는 **named 세마포어**  
- [ ] `sem_getvalue`는 **디버그용 참고**로만  
- [ ] 상호배제는 가급적 **뮤텍스/조건변수** 우선, 세마포어는 **카운팅/제약**에 집중

---

## 13) 한 줄 결론

세마포어는 **“N개의 자원”을 수학적으로 표현**하는 가장 직관적인 동기화 도구입니다.  
**유한 버퍼, 동시 실행 제한, 핸드오프, 간단한 배리어, RW 패턴**까지 폭넓게 적용되지만,  
**취소 안전·순서 규약·기아 방지**를 함께 설계해야 **견고하고 예측 가능한** 동시성 시스템을 만들 수 있습니다.