---
layout: post
title: 컴퓨터시스템 - 세마포어로 쓰레드 동기화
date: 2025-09-10 21:20:23 +0900
category: 컴퓨터시스템
---
# 세마포어로 쓰레드 동기화하기

## 0) 세마포어란? (개념·직관)

- **세마포어(semaphore)**: 비음이 아닌 정수 카운터를 가진 동기화 원자물.
  - `P()` = **wait/down** = `sem_wait`: 값이 **0이면 블록**, **>0이면 1 감소**하고 통과
  - `V()` = **post/up**  = `sem_post`: 값 **+1**, 대기 중 스레드가 있으면 **깨움**
- 용도:
  - **카운팅 제약**: 버퍼 슬롯/연결 풀/동시 실행 허용량처럼 **N개** 자원 제한
  - **핸드오프/교대**: 단계 사이 baton 전달(이진 세마포어)
  - **생산자–소비자**, **배리어**, **속도 제한(레이트 리미팅)**

> **세마포어는 “상태를 기억”**합니다. 신호가 먼저 와도 카운트에 누적.  
> 반면 **조건변수**는 “불변식 + 뮤텍스” 모델로, 신호 자체만으로는 충분치 않습니다.

---

## 1) POSIX 세마포어 API 한눈에

### 1.1 Unnamed 세마포어 (`sem_t`)
```c
#include <semaphore.h>
// 생성/파괴
int sem_init(sem_t *sem, int pshared, unsigned int value); // pshared=0: 스레드 간, 1: 프로세스 간(공유메모리 필요)
int sem_destroy(sem_t *sem);

// 기다림/획득
int sem_wait(sem_t *sem);                 // 취소 가능 지점
int sem_trywait(sem_t *sem);              // 즉시 실패 시 errno=EAGAIN
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); // 절대시간 기반

// 반납(신호)
int sem_post(sem_t *sem);

// (디버깅용) 현재값 조회 — 경합 중 정확 보장 X
int sem_getvalue(sem_t *sem, int *sval);
```

> **타임아웃 주의**: `sem_timedwait`는 **절대시간**(`CLOCK_REALTIME`)을 쓴 구현이 일반적.  
> 시스템 시간이 바뀌면 영향. GNU 확장인 `sem_clockwait(sem, CLOCK_MONOTONIC, ...)`가 있으면 더 안전.

### 1.2 Named 세마포어 (프로세스 간, 파일시스템 네임스페이스)
```c
sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);
int    sem_close(sem_t *sem);
int    sem_unlink(const char *name);
```
- 이름은 보통 `"/mysem"`처럼 **슬래시로 시작**.
- 여러 프로세스에서 열어 **프로세스 간 동기화**에 사용.

### 1.3 신경 쓸 점 (요약)
- `sem_wait/sem_timedwait`는 **취소 가능 지점** → 정리 핸들러로 반납 보장(§5.4)
- `SEM_VALUE_MAX` 초과 초기화/증가 금지 (플랫폼 상수)
- **이식성**: 일부 시스템은 unnamed + pshared 지원이 약함(프로세스 간엔 **named** 권장). macOS는 named를 권장.

---

## 2) 세마포어 vs 다른 동기화 (역할 구분)

| 질문 | 세마포어 | 뮤텍스 | 조건변수 | RW락 |
|---|---|---|---|---|
| **카운팅 제약**(N개 자원) | **최고의 선택** | 불가 | 불가 | 불가 |
| 상호배제(임계구역) | 가능(이진) but **비권장** | **정석** | (자체 X) | 쓰기 단일/읽기 다수 |
| 공정성/우선순위 상속 | 구현 의존(대개 없음) | (있을 수 있음) | 구현 의존 | 구현 의존 |
| 취소 안전성 | 직접 보장 필요 | 비교적 쉬움 | 뮤텍스 쌍 | 구현 의존 |

> 임계구역 보호는 **뮤텍스**가 더 풍부(우선순위 상속, 디버그 지원).  
> 세마포어는 **카운트 모델**에 강합니다.

---

## 3) 대표 패턴 ①: **유한 버퍼 (생산자–소비자)**

버퍼 크기 `N`.  
- `slots=N`(빈칸), `items=0`(채움), `mutex=1`(큐 수정 보호).
```c
#include <semaphore.h>
#include <pthread.h>
#define N 16
int q[N], in=0, out=0;
sem_t slots, items, mutex;

void put(int x){
  sem_wait(&slots);            // 빈 슬롯 확보
  sem_wait(&mutex);            // 큐 수정 보호
  q[in]=x; in=(in+1)%N;
  sem_post(&mutex);
  sem_post(&items);            // 소비자 깨움
}
int get(void){
  int x;
  sem_wait(&items);            // 아이템 대기
  sem_wait(&mutex);
  x=q[out]; out=(out+1)%N;
  sem_post(&mutex);
  sem_post(&slots);            // 슬롯 복구
  return x;
}
int main(){
  sem_init(&slots,0,N);
  sem_init(&items,0,0);
  sem_init(&mutex,0,1);
  /* 생산자/소비자 스레드 생성 … */
}
```
**장점**: 큐 배열 접근만 잠그므로 경합이 낮음.  
**주의**: 종료/플러시 로직(포이즌 펠릿 등) 설계(§10.1 참조).

---

## 4) 대표 패턴 ②: **동시 실행 수 제한(레이트 리미팅/토큰 버킷)**

최대 8개만 동시에 수행:
```c
sem_t permits; // 초기값 8
void* worker(void*){
  sem_wait(&permits);     // 토큰 획득
  /* … 작업 … */
  sem_post(&permits);     // 토큰 반환
  return NULL;
}
int main(){ sem_init(&permits,0,8); /* … */ }
```
**응용**: 타이머 스레드가 주기마다 `sem_post(&permits)`를 **r회** 호출 → 초당 r개 처리로 속도 제한.

---

## 5) 대표 패턴 ③: **배리어(Barrier) — 두 번들 문(2-phase)**

P개 스레드가 한 지점에 모두 모여야 다음 단계로:
```c
#include <semaphore.h>
#include <pthread.h>

int arrived=0, P;
sem_t m, turn1, turn2; // turn1/turn2가 문 역할

void barrier_init(int p){
  P=p;
  sem_init(&m,0,1);
  sem_init(&turn1,0,0);  // 닫힘
  sem_init(&turn2,0,1);  // 열림
}
void barrier_wait(){
  // phase 1: 모두 들어올 때까지 turn1 열기
  sem_wait(&m);
  if (++arrived==P){ sem_wait(&turn2); for(int i=0;i<P;i++) sem_post(&turn1); }
  sem_post(&m);
  sem_wait(&turn1);

  // phase 2: 모두 빠져나갈 때까지 turn2 열기
  sem_wait(&m);
  if (--arrived==0){ sem_wait(&turn1); for(int i=0;i<P;i++) sem_post(&turn2); }
  sem_post(&m);
  sem_wait(&turn2);
}
```
> `pthread_barrier_t`가 있으면 그게 더 단순. 미제공 플랫폼(macOS 등)에서는 위 패턴이 대안.

---

## 6) 대표 패턴 ④: **Readers–Writers (세마포어 버전, 간단)**

읽기 다수/쓰기 단일. 간결하지만 엄밀한 공정성은 플랫폼 의존.
```c
sem_t roomEmpty; // 1: 자원 독점권
sem_t turnstile; // writer에게 공평성 부여(간단)
sem_t m;         // readerCount 보호
int   readerCount=0;

void reader_enter(){
  sem_wait(&turnstile); sem_post(&turnstile);
  sem_wait(&m);
  if (++readerCount==1) sem_wait(&roomEmpty);
  sem_post(&m);
}
void reader_exit(){
  sem_wait(&m);
  if (--readerCount==0) sem_post(&roomEmpty);
  sem_post(&m);
}
void writer_enter(){ sem_wait(&turnstile); sem_wait(&roomEmpty); }
void writer_exit() { sem_post(&roomEmpty); sem_post(&turnstile); }
```
> **실무**: 공정성/성능을 둘 다 챙기려면 **`pthread_rwlock_t`** 고려.

---

## 7) “세마포어로 뮤텍스 대체?” — 가능하지만 비권장

```c
sem_t bin;
void critical(){
  sem_wait(&bin);
  /* 임계구역 */
  sem_post(&bin);
}
int main(){ sem_init(&bin,0,1); /* … */ }
```
- 상호배제는 **뮤텍스**가 진단/우선순위 상속/디버그 면에서 우수.  
- 세마포어는 **카운팅/제약**에 집중.

---

## 8) 타임아웃 & 에러 처리 템플릿

### 8.1 절대시간 기반 타임아웃(이식형)
```c
#include <errno.h>
#include <time.h>
int sem_wait_abs_ms(sem_t* s, long ms){
  struct timespec ts;
  clock_gettime(CLOCK_REALTIME, &ts);
  ts.tv_sec  += ms/1000;
  ts.tv_nsec += (ms%1000)*1000000L;
  if (ts.tv_nsec >= 1000000000L){ ts.tv_sec++; ts.tv_nsec-=1000000000L; }
  for(;;){
    if (sem_timedwait(s, &ts)==0) return 0;
    if (errno==EINTR) continue;
    if (errno==ETIMEDOUT) return ETIMEDOUT;
    return errno;
  }
}
```
> **모노토닉** 기준이 필요하면 GNU 확장인 `sem_clockwait(…, CLOCK_MONOTONIC, …)`를 사용(가능한 환경에서).

---

## 9) 안정성(정확성·운영) 이슈와 대처

### 9.1 교착상태(Deadlock) — **획득 순서** 규약
- 다수 세마포어를 연쇄로 기다릴 땐 **항상 같은 순서**로 `sem_wait`(A→B→C).
- 회피: `trywait + backoff`, 타임아웃 도입, 락 계층화.

### 9.2 기아(Starvation)·공정성
- 세마포어의 깨어남 순서는 **플랫폼·스케줄러 의존**.  
- 필요 시 **큐잉**(상위 레벨에서 대기열) 또는 **turnstile** 보강.

### 9.3 취소 안전성 (Cancellation Safety)
- `sem_wait`는 **취소 가능 지점**. 획득 후 취소되면 **반납 보장** 필요.
```c
void cleanup(void* p){ sem_post((sem_t*)p); }

void safe_crit(sem_t* s){
  sem_wait(s);                             // 취소 지점
  pthread_cleanup_push(cleanup, s);        // 이후 취소 시 sem_post 보장
  /* 임계 구역 … (취소 가능 지점 호출 지양) */
  pthread_cleanup_pop(1);                  // 1 → cleanup 호출(= sem_post)
}
```
> 일반적으로 `sem_wait` 직후 다음 문장들은 **취소 지점이 아니다**(표준 함수가 아니면).  
> 따라서 `cleanup_push`를 바로 이어서 호출하면 경합 없음.

### 9.4 신호·fork와의 상호작용
- **async-signal-safe**: `sem_post`는 안전한 것으로 규정(대부분 구현). `sem_wait`는 아님.
- 멀티스레드 프로세스에서 `fork()` 후 자식은 **한 스레드**만 존재 → 동기화 상태가 깨질 수 있으니, 가능하면 **`posix_spawn()`** 사용.

### 9.5 프로세스 간 세마포어
- `sem_init(pshared=1)`일 때는 **공유 메모리**에 `sem_t`를 할당해야 함.
- **named 세마포어**(`sem_open`)는 다중 프로세스에 간편. 크래시 복구 시 **초기 카운트/오너십**을 재설정.

---

## 10) 디버깅·관찰·테스트

- **로그**: 대기/획득/반납 시점에 **스레드 ID + 타임스탬프** 출력.
- **TSan**(`-fsanitize=thread`): 세마포어만 썼다고 레이스가 자동 제거되진 않음. **공유 데이터 경로**를 검증.
- **데드락 감지**: 비정상 장기 대기 시 **스택덤프**(신호 핸들러로 `backtrace`) 수집.
- **`sem_getvalue` 주의**: 경합 중 의미 불명확 → **디버그 참고** 외 의존 금지.
- **성능 관찰**: `perf`, eBPF(bpftrace)로 **컨텍스트 스위치/슬립 지표** 확인.

---

## 11) 실전 묶음 레시피

### 11.1 스레드 풀 — 세마포어로 “작업 수” 신호
```c
#include <semaphore.h>
#include <pthread.h>
#include <stdlib.h>

typedef void (*job_fn)(void*);
typedef struct node { job_fn fn; void* arg; struct node* next; } node_t;

typedef struct {
  sem_t items;               // 큐에 쌓인 작업 수
  pthread_mutex_t m;
  node_t* head;
  int stop, n;
  pthread_t* th;
} pool_t;

static node_t* pop_locked(pool_t* p){
  node_t* n = p->head;
  if (n) p->head = n->next;
  return n;
}

void enqueue(pool_t* p, job_fn fn, void* arg){
  node_t* n = malloc(sizeof *n);
  n->fn=fn; n->arg=arg;
  pthread_mutex_lock(&p->m);
  n->next = p->head; p->head = n;
  pthread_mutex_unlock(&p->m);
  sem_post(&p->items);       // 워커 하나 깨우기
}
static void* worker(void* vp){
  pool_t* p = vp;
  for(;;){
    if (p->stop) break;
    if (sem_wait(&p->items)!=0) continue; // EINTR 재시도 단순화
    pthread_mutex_lock(&p->m);
    node_t* n = pop_locked(p);
    pthread_mutex_unlock(&p->m);
    if (!n) continue;        // 스퍼리어스
    n->fn(n->arg); free(n);
  }
  return NULL;
}
void pool_init(pool_t* p, int n){
  sem_init(&p->items,0,0);
  pthread_mutex_init(&p->m,NULL);
  p->head=NULL; p->stop=0; p->n=n; p->th=calloc(n,sizeof*p->th);
  for(int i=0;i<n;i++) pthread_create(&p->th[i],NULL,worker,p);
}
void pool_stop(pool_t* p){
  p->stop=1;
  for(int i=0;i<p->n;i++) sem_post(&p->items); // 워커 깨워 종료
  for(int i=0;i<p->n;i++) pthread_join(p->th[i],NULL);
  pthread_mutex_destroy(&p->m);
  sem_destroy(&p->items);
}
```

### 11.2 레이트 리미터 — 주기 충전
```c
// 타이머 스레드: 매 10ms에 5회 post → 초당 500 op 허용
void* refill(void* vp){
  sem_t* permits = vp;
  struct timespec ts = {.tv_sec=0,.tv_nsec=10*1000*1000};
  for(;;){
    for(int i=0;i<5;i++) sem_post(permits);
    nanosleep(&ts,NULL);
  }
}
```

### 11.3 Rendezvous(두 스레드 동시 교차점)
```c
sem_t aArrived, bArrived;
void A(){
  /* … */
  sem_post(&aArrived);
  sem_wait(&bArrived);
  /* A와 B가 여기서 만남 */
}
void B(){
  /* … */
  sem_post(&bArrived);
  sem_wait(&aArrived);
}
```

---

## 12) 성능 최적화 포인트

1) **블록 vs 스핀**: 아주 짧은 대기라면 `sem_trywait` + 짧은 `sched_yield/nanosleep` 혼합 고려. 일반적으로는 **블록**이 정확하고 싸다.  
2) **킹핫 경로에 세마포어 남발 금지**: 핫 루프에는 세마포어 대신 **per-thread 로컬 + reduction**(락 없음).  
3) **OS 힌트**: 뮤텍스에는 `PTHREAD_MUTEX_ADAPTIVE_NP` 같은 적응형 스핀 속성이 있지만, 세마포어에는 표준 스핀 속성이 없다 → 상위 레벨 설계로 대체.  
4) **컨텐션 분할**: 하나의 세마포어 대신 **샤딩(버킷별 세마포어)**.  
5) **NUMA/캐시 지역성**: 세마포어로 병렬도를 조절하더라도, 데이터 배치가 병목이면 효과가 미미. **first-touch, 코어 고정** 병행.

---

## 13) 이식성·플랫폼 팁

- **리눅스**: `sem_wait`는 커널 진입 전 사용자 공간에서 빠른 경로 시도 후 필요 시 잠김(내부적으로 futex 사용 가능).  
- **macOS**: 전통적으로 **named 세마포어**를 권장. 프로세스 간은 named 사용이 단순.  
- **Windows**: Win32 **Semaphore** 객체가 유사 개념. `WaitForSingleObject`/`ReleaseSemaphore`.  
- **모노토닉 타임아웃**: 표준 `sem_timedwait`는 `CLOCK_REALTIME` 기준이 일반적 → **시계 변경 영향**. 가능하면 GNU `sem_clockwait` 사용.

---

## 14) 보안·신뢰성 주의

- **FD/리소스 누수와 결합**: 세마포어로 동시 실행 제한 시, 작업 내 예외 경로에서 **반납 누락**이 전체 처리량을 죽인다 → **RAII/cleanup** 필수.  
- **named 세마포어 권한**: `sem_open` 시 **모드/umask** 설정 주의.  
- **크래시 복구**: 프로세스 크래시 후 named 세마포어의 카운트가 **논리적 의미**와 어긋날 수 있음 → **초기화/유효성 체크 루틴** 포함.

---

## 15) 테스트 스크립트(간단 벤치/검증 스켈레톤)

```c
// bench_sem.c : 여러 P, 큐 길이, 작업 시간(슬립) 파라미터를 바꿔 throughput/latency 측정
// gcc -O3 -pthread bench_sem.c -o bench
// ./bench  (각 시나리오 자동 실행 + csv 출력)
```
- **워밍업 → 측정 → 요약** 루틴과 함께 **큐 길이/동시수/작업 시간 분포**를 매트릭스로 훑어라.
- 내부 스레딩을 쓰는 라이브러리(OpenBLAS 등)가 있다면, **NUM_THREADS=1** 등으로 비활성.

---

## 16) 체크리스트 (현업·리뷰용)

- [ ] 카운팅 모델이 맞는가? (N개 자원, 동시 수 제한) → 세마포어 적합  
- [ ] `sem_wait` ↔ `sem_post` **쌍 보장**(취소/에러 경로 포함: cleanup)  
- [ ] 다중 세마포어 **획득 순서 고정**(교착 방지)  
- [ ] 타임아웃/로깅으로 **장기 대기 탐지**  
- [ ] 기아 방지(필요 시 turnstile/큐잉)  
- [ ] 프로세스 간이면 `pshared=1` + 공유메모리, 또는 **named** 사용  
- [ ] `sem_getvalue`에 의존하지 않는다(디버그 참고만)  
- [ ] 핫 패스에서는 **세마포어 빈도 최소화**, 구조적 최적화(per-thread, reduction, 샤딩)  
- [ ] TSan/스트레스 테스트로 **정확성 + 경합** 동시에 검증

---

## 17) 한 줄 결론

세마포어는 **“N개의 자원”**을 모델링하는 가장 직관적 토대입니다.  
**유한 버퍼, 동시 실행 제한, 배리어, 핸드오프, 단순 RW 패턴**까지 넓게 쓰되,  
**취소 안전·순서 규약·기아 방지·타임아웃 관찰**을 함께 설계하면  
실전에서도 **견고하고 예측 가능**한 동시성 시스템을 만들 수 있습니다.