---
layout: post
title: 암호학 - 웹 취약 실습
date: 2025-10-17 21:30:23 +0900
category: 암호학
---
# 웹 취약 실습: JWT `alg=none`, 키 혼동(Key-Confusion), Padding Oracle PoC (⚠️윤리·보안중심 랩)

> 이 랩은 **교육·방어 목적 전용**입니다. 모든 코드는 **로컬에서 본인이 띄운 취약 서버**에만 사용하세요.  
> 제3자 서비스·시스템을 대상으로 한 무단 테스트/공격은 불법입니다.  
> 실서비스에서는 11·12·13·17·18장에서 정리한 **안전 레시피(AEAD, 키관리, 오류 균일화)**만 사용하세요.

---

## 0. 준비물 & 공통 규칙

- Python 3.10+ (표준 라이브러리만 사용. 웹 서버는 `http.server`/`wsgiref` 기반)
- 실행은 `localhost` 전용. **방화벽 외부 공개 금지**
- 모든 “공격” 단계는 **자체 취약 서버** 대상. (실제 공격 절차는 **의도적으로 생략·축약**)

---

## 1. JWT 취약: `alg=none` 우회

### 1.1 개념
- JWT = `base64url(header).base64url(payload).base64url(signature)`  
- 안전한 검증은 **서버가 미리 합의한 알고리즘(화이트리스트)** 로 서명/검증하고, **`alg` 헤더**를 **신뢰하지 않음**.  
- 취약한 구현: 토큰의 `header.alg`가 **검증 로직을 바꾸도록** 허용 → `alg=none` 수용 시 **서명 우회**.

### 1.2 취약 서버(학습용) — 잘못된 검증기
```python
# vuln_jwt_none.py  (학습용 취약 예시: 절대 실서비스 금지)
import base64, json
from wsgiref.simple_server import make_server

SECRET = b"dev-secret"  # (데모) HMAC 키. none모드에도 영향을 주면 안 되지만…

def b64url_decode(b):
    b += b"=" * (-len(b) % 4);  return base64.urlsafe_b64decode(b)

def parse_jwt(tok:str):
    h_b, p_b, s_b = tok.split(".")
    header  = json.loads(b64url_decode(h_b.encode()))
    payload = json.loads(b64url_decode(p_b.encode()))
    sig     = b64url_decode(s_b.encode())
    return header, payload, sig, h_b, p_b, s_b

def verify_vulnerable(tok:str) -> bool:
    # ❌ 취약: 헤더의 alg를 신뢰
    header, payload, sig, h_b, p_b, s_b = parse_jwt(tok)
    alg = header.get("alg", "none")
    if alg == "none":
        # ❌ 서명 스킵: signature="" 이면 true
        return s_b == ""
    elif alg == "HS256":
        import hmac, hashlib
        mac = hmac.new(SECRET, (h_b+"."+p_b).encode(), hashlib.sha256).digest()
        return hmac.compare_digest(mac, sig)
    else:
        return False

def app(environ, start_response):
    if environ["PATH_INFO"] != "/":
        start_response("404 Not Found",[("Content-Type","text/plain")]); return [b"not found"]
    auth = environ.get("HTTP_AUTHORIZATION","")
    ok=False; payload={}
    if auth.startswith("Bearer "):
        tok = auth.split(" ",1)[1].strip()
        try:
            hdr,payload,_,_,_,_ = parse_jwt(tok)
            ok = verify_vulnerable(tok)
        except Exception as e:
            start_response("400 Bad Request",[("Content-Type","text/plain")]); return [f"bad token: {e}".encode()]
    if ok:
        start_response("200 OK",[("Content-Type","application/json")])
        return [json.dumps({"ok":True,"payload":payload}).encode()]
    else:
        start_response("401 Unauthorized",[("Content-Type","text/plain")]); return [b"unauthorized"]

if __name__ == "__main__":
    httpd = make_server("127.0.0.1", 8081, app)
    print("VULN server on http://127.0.0.1:8081  (alg=none accepted)")
    httpd.serve_forever()
```

### 1.3 로컬 실습(우회 토큰 만들기)
```python
# make_none_token.py  (교육용: 로컬 vuln 서버만)
import base64, json
def b64url(b): return base64.urlsafe_b64encode(b).rstrip(b"=").decode()
header  = {"alg":"none","typ":"JWT"}
payload = {"sub":"admin","role":"admin","iat":1234567890}
h = b64url(json.dumps(header,separators=(",",":")).encode())
p = b64url(json.dumps(payload,separators=(",",":")).encode())
tok = f"{h}.{p}."   # 서명부 비움
print(tok)
# curl -s -H "Authorization: Bearer <tok>" http://127.0.0.1:8081/
```

> **방어법**
> - 서버 코드에 **알고리즘 고정/화이트리스트**: 예) “RS256만 허용, HS256/none 거부”.  
> - **라이브러리 기본값 검증**을 사용 (`algorithms=['RS256']` 같은 인자).  
> - **서명 없는 JWS 거부** / JWE인 경우에도 수신자·alg를 **엄격 고정**.

### 1.4 안전 검증기(수정판)
```python
# safe_jwt_verify.py (화이트리스트 + 'none' 금지)
import base64, json, hmac, hashlib
SECRET = b"dev-secret"
ALLOWED = {"HS256"}

def b64url_decode(b):
    b += b"=" * (-len(b) % 4);  return base64.urlsafe_b64decode(b)

def verify_safe(tok:str) -> dict:
    parts = tok.split(".")
    if len(parts)!=3: raise ValueError("format")
    h_b, p_b, s_b = parts
    header  = json.loads(b64url_decode(h_b.encode()))
    payload = json.loads(b64url_decode(p_b.encode()))
    sig     = b64url_decode(s_b.encode()) if s_b else b""
    alg = header.get("alg", None)
    if alg not in ALLOWED: raise ValueError("alg not allowed")
    if alg == "HS256":
        mac = hmac.new(SECRET, (h_b+"."+p_b).encode(), hashlib.sha256).digest()
        if not hmac.compare_digest(mac, sig): raise ValueError("bad sig")
    return payload
```

---

## 2. JWT 키 혼동(Key-Confusion) 실습

### 2.1 개념
- 서버가 원래 **비대칭(예: RS256)** 을 사용할 의도였는데, 토큰의 `alg`를 신뢰해 **대칭(HS256)** 으로 바꾸고,  
  **공개키(PEM)** 문자열을 **HMAC 비밀키처럼** 사용하면, 공격자가 **공개키를 알고** 임의 토큰을 만들 수 있음.
- 변형: `kid` 헤더를 통한 **키 조회 경로 오용**(디렉터리 트래버설/인젝션)도 다수 보고됨.

### 2.2 취약 검증기(학습용)
```python
# vuln_key_confusion.py (학습용 취약: RS256/HS256 혼용 + 공개키를 HMAC키로)
import base64, json, hmac, hashlib
from wsgiref.simple_server import make_server

# (데모) 서버는 RS256용 공개키를 이렇게 들고 있다고 가정 (실제로는 로컬 파일/비밀금고)
PUBLIC_KEY_PEM = b"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqh...snip...\n-----END PUBLIC KEY-----\n"

def b64url_decode(b):
    b += b"=" * (-len(b) % 4);  return base64.urlsafe_b64decode(b)

def verify_vulnerable(tok:str)->bool:
    h_b, p_b, s_b = tok.split(".")
    header  = json.loads(b64url_decode(h_b.encode()))
    sig     = b64url_decode(s_b.encode()) if s_b else b""
    alg = header.get("alg","RS256")
    if alg == "RS256":
        # (데모) 실제 RSA 검증은 생략. 취약점은 아래 분기.
        return False  # 이 줄은 데모 단순화용
    elif alg == "HS256":
        # ❌ 키 혼동: 공개키를 그대로 HMAC 키로 사용
        mac = hmac.new(PUBLIC_KEY_PEM, (h_b+"."+p_b).encode(), hashlib.sha256).digest()
        return hmac.compare_digest(mac, sig)
    return False

def app(environ, start_response):
    tok = environ.get("HTTP_AUTHORIZATION","").split(" ",1)[-1].strip()
    ok=False
    try:
        ok = verify_vulnerable(tok)
    except: pass
    if ok:
        start_response("200 OK",[("Content-Type","text/plain")]); return [b"OK"]
    else:
        start_response("401 Unauthorized",[("Content-Type","text/plain")]); return [b"unauthorized"]

if __name__=="__main__":
    print("VULN key-confusion server :8082")
    make_server("127.0.0.1", 8082, app).serve_forever()
```

### 2.3 (설명 전용) 로컬 위조 토큰 개념
> **중요**: 아래는 **원리 설명**만 제공합니다. 실제 위조 스크립트는 제공하지 않습니다.  
> 취약 서버가 `alg=HS256`을 받아들이고 HMAC 키로 **공개키 PEM 바이트**를 쓰면,  
> 공격자는 PEM을 HMAC 키로 넣어 **`HMAC_SHA256(header.payload)`** 를 계산해 **임의 페이로드**를 서명할 수 있습니다.

**방어법**
- **알고리즘 고정**: 서버 설정/코드에서 `algorithms=['RS256']` 등 고정.  
- **키 스토리지 분리**: HMAC 비밀키와 공개키는 **형식·저장·로드 경로**가 완전히 다름.  
- **`kid` 검증**: `kid` 값은 **화이트리스트/매핑**으로만 조회. 파일경로/SQL 결합 금지.  
- **JWT 라이브러리 최신**: 잘 알려진 키 혼동 방어가 기본값인 구현 사용.

---

## 3. CBC Padding Oracle (PoC: 로컬 취약 서버 + 관찰·차단 중심)

### 3.1 개념
- CBC 복호: `P_i = D_k(C_i) ⊕ C_{i-1}` (PKCS#7 패딩)  
- 취약 서버가 “패딩 오류”와 “MAC/인증 오류”를 **구분된 에러/타이밍**으로 돌려주면,  
  공격자는 바이트 단위로 `P`를 유추(복호/위조) — **Padding Oracle**.
- 역사적 사례: TLS 1.0~1.2 CBC 모드에서의 **패딩 오라클/타이밍(Lucky13)**.  
  해결: **AEAD(GCM/ChaCha20-Poly1305)**, **오류 메시지 균일화**, **상수시간 처리**.

### 3.2 로컬 취약 서버(학습용)
```python
# vuln_padding_oracle.py  (교육용: 취약 동작을 명시적으로 보여주되 공격 자동화 코드는 제공하지 않음)
from wsgiref.simple_server import make_server
from Crypto.Cipher import AES  # pycryptodome 필요. 설치가 어려우면 AES 부분을 의사코드로 대체 가능
from Crypto.Random import get_random_bytes
import os, base64, time

KEY = get_random_bytes(16)
IV  = get_random_bytes(16)

def pkcs7_unpad(data: bytes, bs=16):
    if not data or len(data)%bs: raise ValueError("bad_len")
    pad = data[-1]
    if pad==0 or pad>bs: raise ValueError("bad_pad")
    if data[-pad:] != bytes([pad])*pad: raise ValueError("bad_pad")
    return data[:-pad]

def decrypt_then_check(ct_b64: str):
    ct = base64.b64decode(ct_b64)
    iv, c = ct[:16], ct[16:]
    cipher = AES.new(KEY, AES.MODE_CBC, iv=iv)
    p = cipher.decrypt(c)
    # ❌ 취약: 패딩 오류와 MAC 오류를 구분하여 반환 + 시간차 존재
    try:
        p = pkcs7_unpad(p, 16)
    except ValueError:
        time.sleep(0.005)  # 타이밍 오라클 (작은 지연도 누적 측정 가능)
        return False, "BAD_PADDING"
    # (데모) "정상" 토큰은 접미사 b'|MAC=OK' 라고 가정
    if not p.endswith(b"|MAC=OK"):
        return False, "BAD_MAC"
    return True, "OK"

def app(env, start_response):
    if env["PATH_INFO"] != "/check":
        start_response("404 Not Found",[("Content-Type","text/plain")]); return [b"not found"]
    try:
        q = env.get("QUERY_STRING","")
        token = dict(x.split("=") for x in q.split("&") if "=" in x).get("t","")
        ok, why = decrypt_then_check(token)
        status = "200 OK" if ok else "400 Bad Request"
        start_response(status,[("Content-Type","text/plain")])
        return [why.encode()]
    except Exception as e:
        start_response("400 Bad Request",[("Content-Type","text/plain")]); return [f"bad:{e}".encode()]

if __name__=="__main__":
    print("VULN padding-oracle server :8083  (errors: BAD_PADDING vs BAD_MAC)")
    make_server("127.0.0.1", 8083, app).serve_forever()
```

> 이 서버는 `/check?t=<base64(iv||cipher)>` 요청에 대해  
> - 패딩 오류 → `"BAD_PADDING"` (지연 포함)  
> - 패딩 통과·MAC 실패 → `"BAD_MAC"`  
> 로 구분 응답합니다. 이 **차이 자체가 취약점**입니다.

### 3.3 (설명) 공격 원리 스케치 — 왜 위험한가?
- CBC 구조에서 특정 바이트를 바꾸면, 다음 블록 복호 출력과 패딩값의 일치 여부가 **한 비트 정보**를 줍니다.  
- 이를 이용해 마지막 바이트부터 차례로 **평문 바이트를 유추**할 수 있습니다.  
- 실제 자동화 PoC는 **여러 요청을 보내며** 응답 구분/시간 차이를 **통계적으로** 모아 복호합니다.  
  (본 문서에서는 **악용 가능한 자동화 코드는 제공하지 않습니다**.)

### 3.4 방어: 안전 서버(오류 균일화 + AEAD)
```python
# safe_padding_server.py  (권장: AEAD 사용)
from wsgiref.simple_server import make_server
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os, base64

KEY = AESGCM.generate_key(bit_length=128)

def app(env, start_response):
    if env["PATH_INFO"] != "/check":
        start_response("404 Not Found",[("Content-Type","text/plain")]); return [b"not found"]
    q = env.get("QUERY_STRING","")
    token = dict(x.split("=") for x in q.split("&") if "=" in x).get("t","")
    # AEAD: [nonce|cipher||tag] 구조 가정 (데모)
    try:
        raw = base64.b64decode(token)
        nonce, ct = raw[:12], raw[12:]           # 12B nonce
        pt = AESGCM(KEY).decrypt(nonce, ct, b"") # 실패시 동일 오류
        # (동일한 에러 메시지) — 실패 원인 구분 없음
        start_response("200 OK",[("Content-Type","text/plain")]); return [b"OK"]
    except Exception:
        start_response("400 Bad Request",[("Content-Type","text/plain")]); return [b"INVALID"]
if __name__=="__main__":
    print("SAFE AEAD server :8084  (uniform error)")
    make_server("127.0.0.1", 8084, app).serve_forever()
```

**핵심 수칙**
- **AEAD(GCM/ChaCha20-Poly1305)** 사용: “패딩+MAC 분리” 대신 **원자적 인증암호**.  
- **오류 균일화**: 패딩/인증/포맷 오류를 **동일 메시지/동일 지연**으로 처리.  
- **상수시간 비교**: 인증 태그 검증·패딩 체크는 데이터와 상관없이 균일한 경로/시간.

---

## 4. 종합 미니 과제(CTF 스타일 · 로컬 전용)

> **과제는 로컬 취약 서버 대상으로만 수행**하세요.  
> 공격 자동화 코드는 **의도적으로 생략/축약**되어 있습니다. 원리 이해와 방어 설정이 목표입니다.

### CHAL-1 (JWT `alg=none`)
- `vuln_jwt_none.py` 서버로 요청 시 **401**.  
- `make_none_token.py`로 토큰 생성 → `Authorization: Bearer <token>` 헤더로 요청.  
- 관찰: **200 OK** → 취약.  
- **수정**: `safe_jwt_verify.py` 검증기로 교체/연동 → 동일 토큰 **거부**되는지 확인.

### CHAL-2 (키 혼동)
- `vuln_key_confusion.py` 서버를 띄우고, 헤더의 `alg` 분기를 관찰(코드 읽기).  
- 안전 설계안 작성:  
  1) `algorithms=['RS256']` 고정  
  2) JWK/JWKS에서 **키 유형(`kty`)·용도(`use`, `key_ops`)** 검증  
  3) `kid` → **화이트리스트 매핑**(파일/경로 불가)  
- (선택) 라이브러리(Tink/Jose)로 **서버-사이드 고정 검증기** 샘플 구성.

### CHAL-3 (Padding Oracle)
- `vuln_padding_oracle.py` 서버로 **임의 토큰**을 바꿔 보내며 응답 `"BAD_PADDING"` vs `"BAD_MAC"` 빈도를 관찰.  
- 동일 요청 수(예: 각각 100회)에서 **응답 분포·지연 평균**을 비교해 **오라클성**을 정량화(그래프는 선택).  
- **수정**: `safe_padding_server.py`로 교체 → 응답/지연 **균일성** 확인.

---

## 5. 체크리스트 — 바로 적용

### JWT
- [ ] **알고리즘 고정**(서버 설정/코드): `none`·예상외 alg **거부**  
- [ ] **라이브러리 검증 사용**: “서명 필수”·“수신자/iss/aud/exp/nbf 검증”  
- [ ] **키 혼동 방지**: `kty`/`alg`/`use` 일치 확인, 공개키를 HMAC키로 사용 **금지**  
- [ ] **`kid` 안전 조회**: 화이트리스트 키-매핑, 파일/SQL 결합 금지, 경로/인젝션 필터  
- [ ] **토큰 저장수명 최소화**: 짧은 exp, 회수/블랙리스트 전략, 세션 바인딩

### Padding Oracle
- [ ] **AEAD만 사용**(AES-GCM/ChaCha20-Poly1305), CBC 사용 시 **Encrypt-then-MAC** + **오류 균일화**  
- [ ] **에러 메시지/코드 통일**: “INVALID TOKEN” 단일 응답, 지연도 균일  
- [ ] **타이밍 완화**: 상수시간 처리, 지연 랜덤화(필요시), rate limit/락아웃  
- [ ] **로깅**: 원인 구분은 서버 내부 코드/지표에만, 외부 응답은 단일화

---

## 6. 자주 하는 실수 & 실무 주의

1) **JWT 파서만 호출**하고 “검증기”를 안 부름 → `alg=none` 우회  
2) `algorithms="*"` 같은 느슨한 설정 → 키 혼동·다운그레이드  
3) `kid`를 **파일명/URL**로 곧장 붙여 로딩 → 경로 조작/SSRF  
4) CBC 복호 후 **패딩→즉시 오류** 반환 → 오라클  
5) 오류마다 **상세 JSON 메시지**(“패딩 실패”, “태그 불일치”) → 오라클/정보누출

---

## 7. 리뷰 질문

1) JWT `alg=none` 우회가 가능하려면 서버 검증 로직에 어떤 **구체 전제**가 필요한가?  
2) 키 혼동 취약이 **공개키 알고리즘을 대칭키로** 잘못 다루게 되는 내부 원인은 무엇이며, 이를 코드·구성 레벨에서 어떻게 **이중 차단**할 수 있는가?  
3) Padding Oracle이 **패딩과 MAC 오류의 구분**을 어떻게 악용하는지, CBC 식으로 설명하라.  
4) AEAD가 Padding Oracle을 **원천 차단**하는 이유와, 남아있는 실무상 주의점(예: **오류 균일화**)은?  
5) `kid`의 안전 처리 방법을 **키 수명주기(생성→배포→회전→폐기)**와 엮어 설명하라.

---

## 8. 요약 카드

- **JWT**: `alg=none`·키 혼동은 **헤더 신뢰/알고리즘 다운그레이드**에서 발생 → **알고리즘 고정·키형식 검증·kid 화이트리스트**.  
- **Padding Oracle**: CBC+PKCS#7에서 **에러 차이/타이밍**이 정보가 됨 → **AEAD** + **오류·타이밍 균일화**.  
- 모든 실습은 **로컬 취약 서버 한정**. 실서비스는 **표준 라이브러리 기본값**과 **최소 권한·로깅 균일화**로 방어.
