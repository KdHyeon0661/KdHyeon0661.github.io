---
layout: post
title: 이산수학 - 재귀 알고리즘
date: 2025-06-03 21:20:23 +0900
category: 이산수학
---
# 🔁 재귀 알고리즘 (Recursive Algorithm)

## 📌 개요

**재귀(recursion)**란, 어떤 함수가 **자기 자신을 호출하여 문제를 해결하는 방식**을 의미합니다.  
**재귀 알고리즘**은 큰 문제를 더 작은 동일한 문제로 나누고, 이를 재귀적으로 해결하여 전체 문제를 해결합니다.

> "큰 문제 → 더 작은 문제 → 기본 문제까지 나눔 → 그 결과를 모아 해결"

---

## 🔍 재귀 알고리즘의 구성 요소

재귀 함수는 항상 두 가지 구성 요소를 갖습니다.

1. **기저 조건(Base Case)**  
   - 재귀 호출을 멈추는 조건 (종료 조건)
2. **재귀 호출(Recursive Call)**  
   - 현재 문제를 더 작은 문제로 나누어 자기 자신을 호출

---

## 🧪 예제 1: 팩토리얼 계산

\[
n! = \begin{cases}
1 & \text{if } n = 0 \\
n \cdot (n-1)! & \text{if } n > 0
\end{cases}
\]

```python
def factorial(n):
    if n == 0:            # base case
        return 1
    return n * factorial(n - 1)  # recursive call
```

---

## 🧪 예제 2: 피보나치 수열

\[
F_n = \begin{cases}
0 & n = 0 \\
1 & n = 1 \\
F_{n-1} + F_{n-2} & n \geq 2
\end{cases}
\]

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)
```

⚠️ 이 구현은 **중복 호출이 많아 비효율적**  
→ 메모이제이션(memoization) 또는 반복문으로 개선 가능

---

## 🔁 재귀 호출의 작동 원리

재귀 함수 호출 시, 호출 스택(call stack)에 함수 상태가 저장됩니다.  
→ 이후 재귀가 종료되면 역순으로 반환되어 연산이 이뤄짐

### 📊 호출 순서 예시 (factorial(3))

```
factorial(3)
→ 3 * factorial(2)
   → 2 * factorial(1)
      → 1 * factorial(0)
         → return 1
      → return 1
   → return 2
→ return 6
```

---

## 📌 재귀 vs 반복

| 항목 | 재귀 | 반복 |
|------|------|------|
| 선언 방식 | 함수 자기 호출 | 루프(while, for 등) |
| 종료 방식 | base case | 조건식 |
| 장점 | 코드 간결, 수학적 모델과 유사 | 성능 우수, 메모리 절약 |
| 단점 | 성능 저하 가능성, Stack Overflow 위험 | 구현이 복잡할 수 있음 |

---

## 🧠 언제 재귀를 사용할까?

재귀가 유리한 상황:

- 트리(Tree) 구조 탐색  
- 분할 정복 알고리즘 (예: Merge Sort, Quick Sort)  
- 백트래킹 (Backtracking: N-Queens, 미로 찾기 등)  
- 재귀적 수학 구조 (피보나치, 계승 등)

---

## 🔧 실무에서 주의할 점

### 🔸 Stack Overflow

- 너무 깊은 재귀 호출은 **스택 오버플로우** 발생 위험
- Python 기본 최대 재귀 깊이: 약 1000 → `sys.setrecursionlimit()`으로 조정 가능

### 🔸 성능 저하

- 중복 호출 많을 경우 **DP / 메모이제이션** 고려
- 예: naive 피보나치는 O(2ⁿ), 메모이제이션 적용하면 O(n)

---

## 🧪 예제 3: 이진 트리 순회

```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = self.right = None

def inorder(node):
    if node:
        inorder(node.left)
        print(node.val)
        inorder(node.right)
```

→ 구조가 **트리처럼 재귀적으로 정의**된 자료구조일 때 자연스럽게 재귀가 어울림

---

## 📦 고급 패턴: 꼬리 재귀(Tail Recursion)

> 마지막 연산이 재귀 호출인 경우 → 컴파일러가 반복문으로 최적화 가능

```python
def tail_sum(n, acc=0):
    if n == 0:
        return acc
    return tail_sum(n-1, acc + n)
```

⚠️ Python은 꼬리 재귀 최적화를 제공하지 않음  
→ Scala, Scheme, OCaml 등에서 유용

---

## ✅ 요약 정리

| 항목 | 설명 |
|------|------|
| 재귀 정의 | 자기 자신을 호출하는 방식으로 문제를 해결 |
| 구성 | 기저 조건 + 재귀 호출 |
| 대표 예제 | 팩토리얼, 피보나치, 트리 순회 |
| 장점 | 코드 간결, 수학적 표현과 유사 |
| 단점 | 성능 저하 가능성, Stack Overflow 위험 |
| 실무 팁 | 반복으로 대체, DP로 최적화, 깊이 제한 설정 필요 |