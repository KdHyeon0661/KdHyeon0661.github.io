---
layout: post
title: 이산수학 - 재귀 알고리즘
date: 2025-06-03 21:20:23 +0900
category: 이산수학
---
# 재귀 알고리즘 (Recursive Algorithm)

## 1. 재귀란 무엇인가? — 문제 쪼개기의 언어

**재귀(recursion)**는 “문제의 해를 **더 작은 같은 형태의 문제**로 환원”해 얻는 방식입니다.

- 큰 문제 ⟶ (동형의) 작은 문제들 ⟶ **기저(base) 문제**까지 내려감 ⟶ 답 **합성**
- 함수가 **자기 자신을 호출**하며, **진전(progress) 척도**가 반드시 감소해야 **종료**합니다.

### 핵심 2요소
1. **기저 조건(Base Case)**: 더 이상 쪼갤 수 없을 때 즉시 답을 반환.
2. **재귀 단계(Recursive Case)**: 문제를 더 작은 하위 문제로 분할하고, 그 답을 **결합**.

> 재귀는 **정의 자체가 재귀적인 구조**(리스트·트리·그래프·분할정복)에 특히 자연스럽습니다.

---

## 2. 올바른 재귀의 해부학

### 2.1 기저 조건 체크리스트
- **존재**: 최소 1개는 있어야 함.
- **도달 가능성**: 입력이 점차 기저로 **수렴**하는가?
- **완전성**: 모든 입력이 언젠가 기저에 **닿는가**?

### 2.2 진전(측도) 설계
입력 크기 $$n$$, 혹은 (깊이, 남은 용량, 인덱스, 부분합 등) **자연수 값 측도**가
호출마다 **엄격히 감소**해야 합니다. (순서화 원리/강한 귀납법과 맞물림)

### 2.3 결합(Combine) 단계
하위 문제의 해들을 **연산(+, min/max, 병합, 선택, 연결)**으로 합쳐 최종 해를 만듭니다.

---

## 3. 정확성: 귀납으로 증명하는 법

재귀의 정확성은 **수학적(강한) 귀납법**으로 깔끔히 보입니다.

- **기저 단계**: 기저에서 올바름.
- **귀납 단계**: 모든 더 작은 입력에서 올바르다면, 현재 입력에서도 올바름(정의·결합에 의해).

### 예) 팩토리얼의 재귀 정의
$$
n! =
\begin{cases}
1 & (n=0)\\
n\cdot (n-1)! & (n\ge 1)
\end{cases}
$$

**정확성 스케치**:
- 기저(0) 성립.
- $$k! = k\cdot (k-1)!$$이 참이라면, $$(k+1)!=(k+1)\cdot k!$$로 귀납적 성립.

---

## 4. 복잡도 분석: 점화식과 재귀 트리

재귀는 보통 **점화식**으로 시간/공간을 분석합니다.

### 4.1 공통 점화식
- **이중 분할**: $$T(n)=2T(n/2)+f(n)$$ ⟶ 예: 병합 정렬 $$T(n)=2T(n/2)+\Theta(n) = \Theta(n\log n)$$
- **선형 축소**: $$T(n)=T(n-1)+c = \Theta(n)$$
- **피보나치형**: $$T(n)=T(n-1)+T(n-2)+c = \Theta(\varphi^n)$$ (지수적)

### 4.2 재귀 트리/마스터 정리
- **재귀 트리**로 각 레벨 비용을 합산해 **총합**을 구함.
- **마스터 정리**(분할정복에 자주 적용):
  $$T(n)=aT(n/b)+f(n)$$
  - $$f(n)=O(n^{\log_b a-\epsilon})\Rightarrow T(n)=\Theta(n^{\log_b a})$$
  - $$f(n)=\Theta(n^{\log_b a}\log^k n)\Rightarrow T(n)=\Theta(n^{\log_b a}\log^{k+1} n)$$
  - $$f(n)=\Omega(n^{\log_b a+\epsilon})$$ & 정규성 조건 ⟶ $$T(n)=\Theta(f(n))$$

### 4.3 공간 복잡도
- **호출 스택 깊이** = 최대 재귀 **깊이**.
- 예: 이진 분할 깊이 $$\Theta(\log n)$$, 선형 축소 $$\Theta(n)$$.

---

## 5. 코딩 패턴 6가지

### 패턴 A. 단일 축소(인덱스/크기 감소)
```python
def rec(i):            # i는 남은 일/인덱스
    if i == 0: return base_value
    return combine(rec(i-1), i)
```

### 패턴 B. 이진 분할(분할정복)
```python
def solve(l, r):
    if l == r: return base_of(arr[l])
    mid = (l + r) // 2
    L = solve(l, mid)
    R = solve(mid+1, r)
    return merge(L, R)
```

### 패턴 C. 가지치기 백트래킹
```python
def backtrack(state):
    if is_goal(state):
        collect(state); return
    for choice in candidates(state):
        if not promising(state, choice):   # 가지치기
            continue
        apply(state, choice)
        backtrack(state)
        undo(state, choice)
```

### 패턴 D. 메모이제이션(Top-Down DP)
```python
from functools import lru_cache

@lru_cache(maxsize=None)
def f(args):
    if base(args): return base_value
    return combine(*(f(sub) for sub in subproblems(args)))
```

### 패턴 E. 구조적 재귀(리스트/트리)
```python
def sum_list(node):
    if node is None:
        return 0
    return node.val + sum_list(node.next)
```

### 패턴 F. 꼬리 재귀(누산기)
```python
def tail_sum(n, acc=0):
    if n == 0: return acc
    return tail_sum(n-1, acc + n)  # Python은 TCO 미지원
```

---

## 6. 필수 예제 모음 (Python)

### 6.1 팩토리얼
```python
def factorial(n):
    if n < 0:
        raise ValueError("n must be >= 0")
    if n == 0:
        return 1
    return n * factorial(n-1)
```
- 시간: $$\Theta(n)$$, 공간(스택): $$\Theta(n)$$.

### 6.2 거듭제곱(분할정복, 제곱 분할)
$$
a^n=
\begin{cases}
1 & (n=0)\\
(a^{n/2})^2 & (n \text{ even})\\
a\cdot (a^{\lfloor n/2\rfloor})^2 & (n \text{ odd})
\end{cases}
$$
```python
def power(a, n):
    if n == 0: return 1
    half = power(a, n//2)
    sq = half * half
    return sq if n % 2 == 0 else a * sq
```
- 시간: $$\Theta(\log n)$$, 공간: $$\Theta(\log n)$$.

### 6.3 유클리드 호제법(GCD)
```python
def gcd(a, b):
    if b == 0: return abs(a)
    return gcd(b, a % b)
```
- 평균적으로 매우 빠름(로그 시간대).

### 6.4 이진 탐색(재귀)
```python
def bsearch(a, x, lo=0, hi=None):
    if hi is None: hi = len(a) - 1
    if lo > hi: return -1
    mid = (lo + hi) // 2
    if a[mid] == x: return mid
    if a[mid] < x: return bsearch(a, x, mid+1, hi)
    return bsearch(a, x, lo, mid-1)
```
- 시간: $$\Theta(\log n)$$.

### 6.5 병합 정렬(Merge Sort)
```python
def merge_sort(a):
    n = len(a)
    if n <= 1: return a[:]
    mid = n // 2
    L = merge_sort(a[:mid])
    R = merge_sort(a[mid:])
    # 병합
    i=j=0; out=[]
    while i < len(L) and j < len(R):
        if L[i] <= R[j]:
            out.append(L[i]); i+=1
        else:
            out.append(R[j]); j+=1
    out.extend(L[i:]); out.extend(R[j:])
    return out
```
- 시간: $$\Theta(n\log n)$$, 공간: $$\Theta(n)$$.

### 6.6 퀵 정렬(평균 효율, 최악 회피 요령)
```python
def quick_sort(a):
    if len(a) <= 1: return a[:]
    pivot = a[len(a)//2]  # 랜덤/미디안-of-3 권장
    less = [v for v in a if v <  pivot]
    eq   = [v for v in a if v == pivot]
    more = [v for v in a if v >  pivot]
    return quick_sort(less) + eq + quick_sort(more)
```
- 평균: $$\Theta(n\log n)$$, 최악: $$\Theta(n^2)$$.
- **무작위 피벗**으로 최악 확률 감소.

### 6.7 피보나치: Naive vs 메모이제이션 vs 바텀업
```python
# Naive: 지수적
def fib_naive(n):
    if n <= 1: return n
    return fib_naive(n-1) + fib_naive(n-2)

# Memoization
from functools import lru_cache
@lru_cache(None)
def fib_memo(n):
    if n <= 1: return n
    return fib_memo(n-1) + fib_memo(n-2)

# Bottom-up (반복)
def fib_iter(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a+b
    return a
```
- Naive: $$\Theta(\varphi^n)$$, Memo/Iter: $$\Theta(n)$$.

### 6.8 부분집합(파워셋) 생성 — 백트래킹
```python
def subsets(nums):
    res, path = [], []
    def dfs(i):
        if i == len(nums):
            res.append(path[:]); return
        # 포함
        path.append(nums[i])
        dfs(i+1)
        path.pop()
        # 미포함
        dfs(i+1)
    dfs(0)
    return res
```
- 출력 크기 $$2^n$$ ⟶ 시간도 $$\Theta(2^n)$$.

### 6.9 순열 생성 — (중복 원소 처리 포함)
```python
# 모든 순열 (중복 원소 없다 가정)
def permutations(nums):
    res, used, path = [], [False]*len(nums), []
    def backtrack():
        if len(path) == len(nums):
            res.append(path[:]); return
        for i,v in enumerate(nums):
            if used[i]: continue
            used[i] = True; path.append(v)
            backtrack()
            path.pop(); used[i] = False
    backtrack()
    return res

# 중복 허용 입력의 "중복 제거" 버전
from collections import Counter
def unique_permutations(nums):
    cnt = Counter(nums); res, path = [], []
    def dfs():
        if len(path) == len(nums):
            res.append(path[:]); return
        for v in list(cnt.keys()):
            if cnt[v] == 0: continue
            cnt[v] -= 1; path.append(v)
            dfs()
            path.pop(); cnt[v] += 1
    dfs(); return res
```

### 6.10 N-Queens — 백트래킹 + 가지치기
```python
def n_queens(n):
    cols, d1, d2 = set(), set(), set()      # 열, diag r-c, diag r+c
    board = [-1]*n
    ans = []

    def dfs(r):
        if r == n:
            ans.append(board[:]); return
        for c in range(n):
            if c in cols or (r-c) in d1 or (r+c) in d2:
                continue
            cols.add(c); d1.add(r-c); d2.add(r+c); board[r] = c
            dfs(r+1)
            cols.remove(c); d1.remove(r-c); d2.remove(r+c); board[r] = -1

    dfs(0); return ans
```
- 시간 복잡도는 지수적, **강력한 가지치기**가 관건.

### 6.11 그래프 DFS (재귀) — 사이클/깊이 주의
```python
def dfs_graph(adj, s):
    seen = set()
    def dfs(u):
        seen.add(u)
        for v in adj[u]:
            if v not in seen:
                dfs(v)
    dfs(s)
    return seen
```
- 깊은 그래프는 **재귀 한도**(파이썬 기본 ≈1000) 초과 위험 → **스택 사용** 반복으로 변환 권장.

---

## 7. 재귀 → 반복으로 변환(성능·안정성)

### 7.1 명시적 스택으로 흉내
```python
def inorder_iter(root):
    st, cur, out = [], root, []
    while cur or st:
        while cur:
            st.append(cur); cur = cur.left
        cur = st.pop()
        out.append(cur.val)
        cur = cur.right
    return out
```

### 7.2 꼬리 재귀 ↔ 누산기 반복
```python
def tail_sum_iter(n):
    acc = 0
    while n > 0:
        acc += n; n -= 1
    return acc
```

> Python은 **꼬리 재귀 최적화(TCO)**가 없어, **반복 변환이 실무 안전**.

---

## 8. 메모이제이션 & 탑다운 DP

**중복 부분문제**가 있는 재귀는 **캐시**로 폭발을 막습니다.

```python
from functools import lru_cache

@lru_cache(None)
def paths(r, c):
    if r == 0 or c == 0: return 1
    return paths(r-1, c) + paths(r, c-1)
```

- 격자 경로 수: $$\binom{r+c}{r}$$, 위 코드는 $$\Theta(rc)$$로 수렴.

---

## 9. 백트래킹: 탐색·제약·가지치기의 기술

- **상태**: (부분해, 남은 선택, 제약)
- **promising**(유망성 판정)으로 **상한/하한/가능성**을 빠르게 필터
- **정렬/휴리스틱**(예: MRV—제약 만족 문제)로 분기 팽창 억제

### 예) 부분집합 합(Subset Sum) — 정렬+상한 가지치기
```python
def subset_sum(nums, target):
    nums.sort(reverse=True)
    res, path = [], []
    def dfs(i, s):
        if s == target:
            res.append(path[:]); return
        if s > target or i == len(nums):
            return
        # 상한 가지치기: 남은 최대 합으로도 target 불가하면 중단
        # (여기선 단순히 s>target만 사용)
        path.append(nums[i]); dfs(i+1, s+nums[i]); path.pop()
        dfs(i+1, s)
    dfs(0, 0); return res
```

---

## 10. 재귀 디버깅·안정화 체크리스트

1. **기저가 먼저**: 코드 첫 줄 근처에 배치(가독성+안전).
2. **진전 보장**: 호출 매개값이 **엄격히 줄어드는지** 눈으로 확인.
3. **부작용 롤백**: `apply` 후 반드시 `undo` (백트래킹).
4. **방문표시**: 그래프/트리에서 사이클 방지.
5. **출력 크기 의식**: 생성형(순열/부분집합)은 출력이 지수 ⟶ 시간/메모리 기대치 설정.
6. **추적 프린트**(깊이 들여쓰기)로 흐름 관찰:
```python
def trace_rec(n, depth=0):
    print("  " * depth + f"enter n={n}")
    if n == 0:
        print("  " * depth + "base"); return
    trace_rec(n-1, depth+1)
    print("  " * depth + f"leave n={n}")
```
7. **재귀 한도**: 필요시
```python
import sys; sys.setrecursionlimit(10**6)  # 신중히!
```

---

## 11. 성능 최적화 포인트

- **메모이제이션**(Top-Down) 또는 **바텀업 DP**로 중복 제거.
- **분할정복**에서 **큰 상수 비용**(리스트 복사 등) 줄이기 → 인덱스 기반.
- **퀵 정렬**: **무작위 피벗/median-of-3**, **tail-call elimination**(한쪽 반복).
- **백트래킹**: 가지치기(상한/하한/제약 사전검사), **순서 휴리스틱**.
- **파이썬 팁**: 함수 호출 오버헤드 큼 ⟶ **핫패스 반복화** 고려.

---

## 12. 종료성(termination) 보장 — 측도와 순서화 원리

**자연수 값을 갖는 측도** $$\mu(\text{입력})\in\mathbb{N}$$를 정의해
호출마다 $$\mu$$가 **엄격히 감소**하면,
자연수의 **순서화 원리**로 **반드시 종료**합니다.

- 예: `dfs(i)`에서 `i`가 감소, `solve(l,r)`에서 `r-l`이 감소 등.

---

## 13. 재귀와 수학적 구조: 구조적 재귀·상호 재귀

### 13.1 구조적 재귀(트리)
```python
def height(root):
    if not root: return 0
    return 1 + max(height(root.left), height(root.right))
```

### 13.2 상호 재귀(mutual recursion)
```python
def is_even(n):
    if n == 0: return True
    return is_odd(n-1)

def is_odd(n):
    if n == 0: return False
    return is_even(n-1)
```
- 깊은 상호 재귀는 반복으로 합치는 게 안전.

---

## 14. 사례 분석: 재귀적 정렬 2종

### 14.1 병합 정렬 복잡도
$$
T(n)=2T(n/2)+\Theta(n)\Rightarrow \Theta(n\log n),\ \ \text{스택 깊이 } \Theta(\log n)
$$

### 14.2 퀵 정렬 최악 회피
- **랜덤 피벗**으로 입력 패턴 독립.
- 재귀를 **작은 쪽**만 호출, 큰 쪽은 **반복** 처리(스택 깊이 $$\Theta(\log n)$$ 기대).

---

## 15. 실전 미니 프로젝트: 미로 경로 찾기(DFS 백트래킹)

```python
# 0: 길, 1: 벽. 시작(sx,sy) -> 목표(gx,gy) 경로 찾기
def maze_path(grid, sx, sy, gx, gy):
    R, C = len(grid), len(grid[0])
    seen = [[False]*C for _ in range(R)]
    path = []

    def dfs(x, y):
        if not (0 <= x < R and 0 <= y < C): return False
        if grid[x][y] == 1 or seen[x][y]: return False
        seen[x][y] = True; path.append((x, y))
        if (x, y) == (gx, gy): return True
        for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
            if dfs(x+dx, y+dy): return True
        path.pop(); return False

    return path if dfs(sx, sy) else None
```

- **정확성**: “한 번 방문한 칸은 재방문하지 않는다(사이클 제거)” 가정 아래, 깊이 우선 탐색은 목표에 닿으면 **한 경로**를 반환.
- **복잡도**: $$O(RC)$$.

---

## 16. FAQ — 흔한 함정

- **기저 조건 누락/도달 불가** ⟶ 무한 재귀.
- **부작용 롤백 누락**(백트래킹) ⟶ 경로 오염.
- **전역 캐시 키 불완전**(메모이제이션) ⟶ 잘못된 재사용.
- **그래프 DFS에서 방문 표시 미흡** ⟶ 폭발/루프.
- **대량 출력 생성**(순열·부분집합) 요구 ⟶ **시간·메모리 예산** 먼저 계산.

---

## 17. 연습 문제(핵심 아이디어만 스케치)

1) **카탈란 수** 재귀:
$$
C_n=\sum_{i=0}^{n-1} C_i C_{n-1-i},\ \ C_0=1
$$
메모이제이션으로 $$\Theta(n^2)$$.

2) **최대 부분합**(Kadane는 반복이지만) — **분할정복**으로
좌/우/또는 **중간을 가로지르는 최대**를 병합.

3) **K번째 순열**: 백트래킹 대신 **팩토리얼 진법**으로 반복 계산(재귀도 가능).

4) **LCS(최장 공통 부분수열)**:
$$
\text{LCS}(i,j)=
\begin{cases}
0 & \text{if } i=0 \text{ or } j=0\\
1+\text{LCS}(i-1,j-1) & \text{if } s_i=t_j\\
\max(\text{LCS}(i-1,j), \text{LCS}(i,j-1)) & \text{otherwise}
\end{cases}
$$
⟶ 메모이제이션/바텀업으로 $$\Theta(nm)$$.

---

## 18. 치트시트 요약

- **설계**: (기저, 진전 측도, 결합) 3요소로 점검.
- **정확성**: 귀납(또는 강한 귀납)으로 증명.
- **시간**: 점화식/재귀트리/마스터 정리로 분석.
- **최적화**: 메모이제이션·가지치기·반복 변환·무작위화.
- **파이썬 실전**: `@lru_cache`, `sys.setrecursionlimit`, 명시적 스택, 슬라이싱 비용 주의.

---

## 19. 부록: 성능 비교 스니펫(간단 테스트)

```python
import time
def bench(fn, *args, repeat=5):
    best = float('inf')
    for _ in range(repeat):
        t0 = time.perf_counter()
        fn(*args)
        best = min(best, time.perf_counter() - t0)
    return best

# 예: fib_naive vs fib_memo vs fib_iter (n=35)
if __name__ == "__main__":
    print("naive:", bench(fib_naive, 30))
    print("memo :", bench(fib_memo, 30))
    print("iter :", bench(fib_iter, 30))
```

> 결과: naive는 급격히 느리고, memo/iter는 선형대.

---

## 마무리

재귀는 **표현력**과 **해결력**이 뛰어난 도구입니다.
하지만 “기저·진전·결합” 3요소를 철저히 점검하고, **복잡도**와 **메모리**를 현실적으로 설계해야 합니다.
필요 시 **메모이제이션/반복 변환/가지치기**로 안정성과 성능을 보강하세요.
