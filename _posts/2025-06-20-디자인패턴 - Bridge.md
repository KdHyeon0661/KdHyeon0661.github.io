---
layout: post
title: 디자인패턴 - Bridge
date: 2025-06-20 19:20:23 +0900
category: 디자인패턴
---
# Bridge(브리지 패턴)

## 정의

**브리지 패턴(Bridge Pattern)**은 **추상화(abstraction)**와 **구현(implementation)**을 분리하여 **서로 독립적으로 확장**할 수 있게 하는 **구조 패턴**이다.
상속(ISA) 대신 합성(HAS-A)을 사용해 **기능 계층(추상화)** 과 **구현 계층** 을 느슨하게 연결(bridge)한다.

> “상속 대신 위임(composition)”
> “계층 구조가 2차원으로 확장 가능”

---

## 의도 (Intent)

- 추상화와 구현의 **결합을 끊어** 서로 **독립적으로 진화**하게 한다.
- 기능×구현 **조합 폭발**을 줄인다.
- **런타임 교체**(DI/플러그인)와 **테스트 대체**(Mock 구현)를 자연스럽게 한다.

---

## 왜 ‘Bridge’인가 — 조합 폭발의 수학적 직관

기능 유형이 \(M\)개, 구현 유형이 \(N\)개 있을 때,
상속으로만 조합하면 필요한 클래스 수는 **\(M \times N\)** 이다.

브리지로 **기능(Abstraction)과 구현(Implementor)** 을 분리하면,
필요 클래스 수는 **\(M + N\)** 으로 감소한다.

\[
\text{Without Bridge: } \mathcal{O}(M \cdot N)
\quad\Rightarrow\quad
\text{With Bridge: } \mathcal{O}(M + N)
\]

---

## 구조 (UML) — 제공 그림 유지 + 주석

```
        ┌────────────────────────┐
        │     Abstraction        │◄────────────┐      (클라이언트가 보는 API)
        └────────────────────────┘             │
                   ▲                           │
                   │                           │ uses(위임)
        ┌────────────────────────┐             │
        │ RefinedAbstraction     │────────────►│
        └────────────────────────┘             ▼
                                     ┌────────────────────┐
                                     │ Implementor        │◄──────┐ (구현 인터페이스)
                                     └────────────────────┘       │
                                              ▲                   │
                                              │                   │
                                  ┌────────────────────┐  ┌────────────────────┐
                                  │ ConcreteImplA      │  │ ConcreteImplB      │
                                  └────────────────────┘  └────────────────────┘
```

- **Abstraction**: 외부에 노출되는 기능 계층(합성으로 구현을 소유)
- **Implementor**: 구현 계층의 계약(인터페이스)
- **RefinedAbstraction**: 기능 확장 클래스(여러 개 가능)
- **ConcreteImplementor**: 실제 구현(플랫폼/장치/프로토콜)

> **네이밍 팁**: 도메인에 맞게 `Abstraction→Remote`, `Implementor→Device` 등 의미 있는 이름으로 바꾸는 것이 좋다.

---

## 적용 판단 체크리스트

- 기능×구현 **조합**이 많아질 전망인가? (예: 기기 종류 × 제어 방식, 포맷 × 출력장치)
- 구현을 **런타임에 교체**하거나 **테스트 대역**(Mock/Stub)으로 쉽게 바꾸고 싶은가?
- 외부 플랫폼·드라이버·프로토콜 등 **변하기 쉬운 경계**가 있는가?

---

## 구현 예시 1 — Python: 리모컨(추상) × 기기(구현)

> 사용자가 준 예시를 **살리되**, **toggle** 동작을 제대로 구현하고(상태 보유), **고급 리모컨 기능**(음소거/볼륨)을 추가한다.

```python
from abc import ABC, abstractmethod

# 구현 인터페이스 (Implementor)
class Device(ABC):
    @abstractmethod
    def is_on(self) -> bool: ...
    @abstractmethod
    def turn_on(self) -> None: ...
    @abstractmethod
    def turn_off(self) -> None: ...
    @abstractmethod
    def volume(self) -> int: ...
    @abstractmethod
    def set_volume(self, v: int) -> None: ...

# 구체 구현 (ConcreteImplementor)
class TV(Device):
    def __init__(self):
        self._on = False
        self._vol = 10
    def is_on(self): return self._on
    def turn_on(self): self._on = True; print("TV 켬")
    def turn_off(self): self._on = False; print("TV 끔")
    def volume(self): return self._vol
    def set_volume(self, v): self._vol = max(0, min(100, v)); print(f"TV 볼륨={self._vol}")

class Radio(Device):
    def __init__(self):
        self._on = False
        self._vol = 5
    def is_on(self): return self._on
    def turn_on(self): self._on = True; print("라디오 켬")
    def turn_off(self): self._on = False; print("라디오 끔")
    def volume(self): return self._vol
    def set_volume(self, v): self._vol = max(0, min(100, v)); print(f"라디오 볼륨={self._vol}")

# 추상화 계층 (Abstraction)
class RemoteControl:
    def __init__(self, device: Device):
        self.device = device
    def toggle_power(self):
        print("[리모컨] 전원 토글")
        if self.device.is_on():
            self.device.turn_off()
        else:
            self.device.turn_on()

# 세부 추상화 (RefinedAbstraction)
class AdvancedRemoteControl(RemoteControl):
    def volume_up(self, step=1):
        self.device.set_volume(self.device.volume() + step)
    def volume_down(self, step=1):
        self.device.set_volume(self.device.volume() - step)
    def mute(self):
        print("[리모컨] 음소거")
        self.device.set_volume(0)

# 사용
r1 = RemoteControl(TV())
r1.toggle_power(); r1.toggle_power()

r2 = AdvancedRemoteControl(Radio())
r2.toggle_power()
r2.volume_up(3)
r2.mute()
```

특징
- 기능(리모컨)과 구현(기기)을 **교차 조합** 가능: `RemoteControl(TV)`, `AdvancedRemoteControl(Radio)` …
- **런타임 교체**: `r2.device = TV()` 처럼 구현을 바꿔도 추상 계층 API는 동일.

---

## 구현 예시 2 — C#: Shape(추상) × Renderer(구현)

> 그래픽 도메인: 사각형/원(추상) × SVG/Canvas/DirectX(구현). DI로 주입.

```csharp
public interface IRenderer  // Implementor
{
    void Line(int x1, int y1, int x2, int y2);
    void Circle(int cx, int cy, int r);
}

public sealed class SvgRenderer : IRenderer
{
    public void Line(int x1, int y1, int x2, int y2) =>
        Console.WriteLine($"<line x1='{x1}' y1='{y1}' x2='{x2}' y2='{y2}'/>");
    public void Circle(int cx, int cy, int r) =>
        Console.WriteLine($"<circle cx='{cx}' cy='{cy}' r='{r}'/>");
}

public abstract class Shape  // Abstraction
{
    protected readonly IRenderer R;
    protected Shape(IRenderer r) => R = r;
    public abstract void Draw();
}

public sealed class Rectangle : Shape // RefinedAbstraction
{
    private readonly int x, y, w, h;
    public Rectangle(IRenderer r, int x, int y, int w, int h) : base(r)
        => (this.x, this.y, this.w, this.h) = (x, y, w, h);
    public override void Draw()
    {
        R.Line(x, y, x+w, y);
        R.Line(x+w, y, x+w, y+h);
        R.Line(x+w, y+h, x, y+h);
        R.Line(x, y+h, x, y);
    }
}

public sealed class CircleShape : Shape
{
    private readonly int cx, cy, r;
    public CircleShape(IRenderer r, int cx, int cy, int r) : base(r)
        => (this.cx, this.cy, this.r) = (cx, cy, r);
    public override void Draw() => R.Circle(cx, cy, r);
}

// 사용
var svg = new SvgRenderer();
Shape rect = new Rectangle(svg, 10, 10, 50, 20);
rect.Draw();
```

특징
- `Shape` 계층을 추가해도(삼각형/다각형) **Renderer는 그대로**, 반대로 **Renderer 교체**(Canvas/DirectX)도 독립적.

---

## 구현 예시 3 — Java: ReportExporter(추상) × Output(구현)

> 리포트 생성기: “무엇을 출력할지(추상)”와 “어디로/어떻게 출력할지(구현)” 분리.

```java
interface Output {                 // Implementor
  void write(String content);
}

final class HtmlOutput implements Output {
  public void write(String c) { System.out.println("<html>"+c+"</html>"); }
}
final class MarkdownOutput implements Output {
  public void write(String c) { System.out.println("# " + c); }
}

abstract class ReportExporter {    // Abstraction
  protected final Output out;
  protected ReportExporter(Output out) { this.out = out; }
  public abstract void export(String title, String body);
}

final class SimpleExporter extends ReportExporter { // RefinedAbstraction
  public SimpleExporter(Output out) { super(out); }
  public void export(String title, String body) {
    out.write(title + "\n" + body);
  }
}

final class FancyExporter extends ReportExporter {
  public FancyExporter(Output out) { super(out); }
  public void export(String title, String body) {
    out.write("[TITLE] " + title + "\n[CONTENT]\n" + body);
  }
}

// 사용
ReportExporter e = new FancyExporter(new HtmlOutput());
e.export("Design Patterns", "Bridge decouples abstraction from implementation.");
```

---

## 설계 가이드 & 실무 팁

1) **경계 먼저**: 구현이 바뀔 가능성이 높은 경계(플랫폼/장치/드라이버)를 **Implementor**로 둔다.
2) **이름 바꾸기**: Abstraction/Implementor는 도메인 이름으로(예: `Remote`/`Device`, `Exporter`/`Output`).
3) **DI 컨테이너**: 구현 교체(테스트 대역/환경별 빈) 자동화.
4) **다차원 브리지**: 필요하면 브리지를 **여러 축**으로(예: 기능 × 기기 × 프로토콜). 이때는 브리지+전략/어댑터 조합 고려.
5) **계약 테스트**: Implementor 인터페이스에 대한 **공통 테스트 스위트**를 운용해 상호교체성 보장.

---

## 함정과 안티패턴

- **미니-브리지**: 추상/구현을 쪼갰지만 실제로 구현이 1가지뿐 → 불필요 복잡도.
- **데이터 새어나감**: Abstraction이 구현의 내부 세부를 노출하면 DIP 위배.
- **계층 남용**: 브리지 위에 데코레이터/프록시가 과도하게 얹히면 호출 경로 과다 → 조립 정책을 코드가 아닌 **구성(설정/DI)** 으로 관리.
- **Adapter와 혼동**: 어댑터는 **기존 인터페이스를 맞추는 변환기**, 브리지는 **독립 진화 구조**.

---

## 장점 요약

- 기능×구현 **독립 확장**(2차원 계층)
- **조합 폭발 억제**: \(M \times N \rightarrow M+N\)
- **런타임 교체/테스트 대역** 주입 쉬움
- 상속보다 **유연**(합성 기반)

## 단점 요약

- 계층 분리로 **초기 복잡도/클래스 수 증가**
- 작은 문제엔 **과설계**가 될 수 있음
- 경계 식별·계약 정의에 **설계 역량 요구**

---

## 사용 사례 (원문 유지 + 보강)

| 사용 사례               | 설명 |
|------------------------|------|
| 다양한 디바이스 제어    | TV/Radio/Projector(구현) × Remote/AdvancedRemote(추상) |
| UI 스킨/테마 시스템     | 컴포넌트(추상) × 스킨 렌더러(구현) |
| 파일/리포트 변환        | Exporter(추상) × Output(PDF/HTML/MD) 구현 |
| 그래픽 API 추상화       | Shape/UI(추상) × OpenGL/DirectX/Vulkan(구현) |
| 데이터 저장/전송        | Repository(추상) × Storage/Transport(구현: SQL/NoSQL/S3/gRPC) |

---

## Bridge vs Adapter vs Strategy (원문 표 확장)

| 패턴       | 목적 | 구성 요소 | 언제 사용? | 핵심 차이 |
|------------|------|-----------|------------|-----------|
| **Bridge**   | 추상/구현 분리 | 2계층(기능×구현) | 조합 폭발 억제, 독립 확장 | **새로운 구조 설계** |
| **Adapter**  | 인터페이스 호환 | 중간 변환기 | 레거시/서드파티 재사용 | **기존 것 연결** |
| **Strategy** | 알고리즘 교체 | 컨텍스트×전략 | 알고리즘·정책 런타임 교체 | **행위 축 교체** |

> 자주 쓰는 조합: **Bridge + Strategy**(구현 내부 알고리즘을 전략으로), **Bridge + Adapter**(외부 라이브러리 구현을 어댑터로 감싸 Implementor에 넣기).

---

## 테스트 전략

- **Implementor 계약 테스트**: 동일 스위트로 `TV`, `Radio`, `DummyDevice` 전부 검증.
- **Abstraction 단위 테스트**: 가짜 구현(Mock)으로 상태/호출 순서 검증.
- **통합 테스트**: 실제 구현×여러 추상 조합 smoke 테스트.
- **성능 가드**: 브리지+데코레이터/프록시 체인 지연 상한치 모니터링.

Python PyTest 예

```python
class Dummy(Device):
    def __init__(self): self._on=False; self._vol=0
    def is_on(self): return self._on
    def turn_on(self): self._on=True
    def turn_off(self): self._on=False
    def volume(self): return self._vol
    def set_volume(self, v): self._vol=v

def test_toggle():
    d=Dummy(); r=RemoteControl(d)
    r.toggle_power(); assert d.is_on()
    r.toggle_power(); assert not d.is_on()

def test_advanced_volume():
    d=Dummy(); r=AdvancedRemoteControl(d)
    r.volume_up(5); assert d.volume()==5
    r.mute(); assert d.volume()==0
```

---

##  성능/복잡도 관점

- **호출 오버헤드**: 브리지는 간접 호출 1단 추가. I/O 바운드 경로에선 무시 가능하나, **핫패스**에서 체인(데코레이터/프록시) 과다 시 주의.
- **조합 복잡도**:
  \[
  \text{Classes}:\ M\times N \to M+N,\quad
  \text{Maintenance}:\ O(M+N)
  \]
- **빌드/배포**: 구현 교체를 설정/DI로 돌려 **재배포 없이** 전략 변경 가능.

---

## 🔧 리팩토링 절차 — 상속 조합 폭발 → 브리지

**냄새**
- `RemoteForTV`, `RemoteForRadio`, `AdvancedRemoteForTV` … 같은 **상속 조합 클래스** 증가
- 다른 플랫폼 추가마다 **모든 파생** 재생성

**절차**
1) 공통 API를 **Abstraction**으로 추출(클라이언트 관점).
2) 변하기 쉬운 축을 **Implementor 인터페이스**로 명세.
3) 기존 하위 클래스를 **Abstraction or Implementor** 어느 쪽에 속할지 이관.
4) 생성자/DI로 구현 의존성 주입.
5) 테스트: Implementor **계약 테스트** 도입, Abstraction은 **Mock**으로 검증.
6) 조합 클래스를 제거하고 **M+N 구조**로 단순화.

---

## 패턴 조합 레시피

- **Bridge + Factory**: 구현체 생성을 팩토리로 캡슐화해 환경별/플랫폼별 선택 자동화.
- **Bridge + Adapter**: 외부 라이브러리를 Implementor로 쓰되, 인터페이스를 어댑터로 맞춤.
- **Bridge + Composite**: 트리(Composite)에서 각 노드의 렌더러/스토리지 구현을 브리지로 분리.
- **Bridge + Decorator**: 구현단에 캐싱/로깅을 데코레이터로 동적 부착.

---

## 마무리

브리지는 **도메인 기능**과 **플랫폼/장치/프로토콜 구현**을 분리해 **독립 확장**을 가능하게 한다.
조합 폭발을 **\(M\times N \rightarrow M+N\)** 으로 환원하고, **런타임 교체**, **테스트 용이성**, **장기 유지보수성**을 확보한다.
단, **작은 문제엔 과설계**가 될 수 있으므로, **변화 축이 최소 2개 이상**이고 **조합 수가 커질 때** 적용하라.
