---
layout: post
title: 디자인패턴 - Bridge
date: 2025-06-20 19:20:23 +0900
category: 디자인패턴
---
# Bridge (브리지 패턴)

## ✅ 정의

**브리지 패턴(Bridge Pattern)**은 **추상화(abstraction)**와 **구현(implementation)**을 분리하여, **각각 독립적으로 확장**할 수 있도록 하는 **구조 패턴(Structural Pattern)**입니다.

즉, 상속을 사용하는 대신 **객체 구성을 통해 기능과 구현을 분리**하여, 다형성과 조합의 유연성을 동시에 확보합니다.

> "상속 대신 위임(composition)"  
> "계층 구조가 2차원으로 확장 가능"

---

## 🎯 의도 (Intent)

- 추상화와 구현의 계층 구조를 분리한다.
- 두 계층을 **독립적으로 확장 가능**하게 한다.
- 클래스 수가 폭발적으로 늘어나는 문제(조합 폭발)를 줄인다.

---

## 📦 구조 (UML)

```
        ┌────────────────────────┐
        │     Abstraction        │◄────────────┐
        └────────────────────────┘             │
                   ▲                           │
                   │                           │
        ┌────────────────────────┐   uses      │
        │ RefinedAbstraction     │────────────►│
        └────────────────────────┘             ▼
                                     ┌────────────────────┐
                                     │ Implementor        │◄──────┐
                                     └────────────────────┘       │
                                              ▲                   │
                                              │                   │
                                  ┌────────────────────┐  ┌────────────────────┐
                                  │ ConcreteImplA       │  │ ConcreteImplB       │
                                  └────────────────────┘  └────────────────────┘
```

- `Abstraction`: 클라이언트에게 노출되는 인터페이스 (위임을 통해 구현을 호출)
- `Implementor`: 실제 기능 구현을 위한 인터페이스
- `RefinedAbstraction`: `Abstraction`을 확장한 실제 클래스
- `ConcreteImplementor`: 실제 기능을 수행하는 구현 클래스

---

## 🧑‍💻 구현 예시 (Python)

```python
# 구현 인터페이스
class Device:
    def turn_on(self): pass
    def turn_off(self): pass

# 구체 구현
class TV(Device):
    def turn_on(self):
        print("TV 켬")

    def turn_off(self):
        print("TV 끔")

class Radio(Device):
    def turn_on(self):
        print("라디오 켬")

    def turn_off(self):
        print("라디오 끔")

# 추상화 계층
class RemoteControl:
    def __init__(self, device: Device):
        self.device = device

    def toggle_power(self):
        print("[리모컨으로 전원 전환]")
        self.device.turn_on()

# 세부 추상화
class AdvancedRemoteControl(RemoteControl):
    def mute(self):
        print("[리모컨으로 음소거 실행]")

# 사용 예
remote = RemoteControl(TV())
remote.toggle_power()
# 출력:
# [리모컨으로 전원 전환]
# TV 켬

adv_remote = AdvancedRemoteControl(Radio())
adv_remote.toggle_power()
adv_remote.mute()
# 출력:
# [리모컨으로 전원 전환]
# 라디오 켬
# [리모컨으로 음소거 실행]
```

---

## ✅ 장점

- **추상화와 구현을 독립적으로 확장**할 수 있음 (2차원 계층 구조)
- 코드 중복 없이 **기능 조합이 자유로움**
- 런타임에 구현체를 교체하거나 변경 가능
- 상속보다 유연한 구조 (위임 기반)

---

## ⚠️ 단점

- 구조가 다소 복잡해짐 (클래스 수 증가)
- 모든 경우에 필요한 것은 아님 (단순한 경우에는 과도한 설계)
- 추상화와 구현 사이의 명확한 분리가 어려울 수도 있음

---

## 📌 사용 사례

| 사용 사례               | 설명 |
|------------------------|------|
| 다양한 디바이스 제어    | TV, Radio 등 다양한 기기를 리모컨으로 제어 |
| UI 스킨 시스템         | 윈도우/리눅스/다크모드 등 다양한 테마 분리 |
| 파일 변환 시스템       | 다양한 포맷(input) + 다양한 출력 형식(output) |
| 그래픽 API 추상화      | OpenGL ↔ DirectX ↔ Vulkan 등의 렌더링 구현 분리 |
| 리포트 생성기           | PDF, HTML, Markdown 출력 포맷에 대한 공통 인터페이스 추상화 |

---

## 🧠 Bridge vs Adapter vs Strategy

| 패턴       | 목적 | 구성 요소 | 언제 사용? |
|------------|------|-----------|-------------|
| **Bridge**   | 추상화와 구현 분리 | 2개의 계층 | 기능 × 구현 조합을 분리 |
| **Adapter**  | 인터페이스 호환 | 중간 계층 | 기존 클래스 재사용 시 |
| **Strategy** | 알고리즘 변경 | 알고리즘 교체 가능 | 알고리즘 교체 유연하게 할 때 |

---

## 🧠 마무리

**브리지 패턴**은 "추상화와 구현을 분리"하여 독립적으로 변화와 확장이 가능하도록 하는 강력한 구조 패턴입니다.  
기능의 수와 구현 방식이 많아질수록, 상속의 조합 폭발을 방지하고 구조를 깔끔하게 유지할 수 있는 해결책이 됩니다.

하지만, 단순한 구조에서는 오히려 불필요한 복잡성을 초래할 수 있으므로,  
**다형적 조합이 필요한 복잡한 시스템에서만 적용**하는 것이 가장 이상적입니다.