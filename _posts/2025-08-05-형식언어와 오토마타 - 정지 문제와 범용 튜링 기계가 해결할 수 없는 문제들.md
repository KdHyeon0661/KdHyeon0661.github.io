---
layout: post
title: 형식언어와 오토마타 - 정지 문제와 범용 튜링 기계로도 해결할 수 없는 문제들
date: 2025-08-05 14:20:23 +0900
category: 형식언어와 오토마타
---
# 범용 튜링 기계(UTM)로도 **해결할 수 없는 문제들**

**핵심 요지**

- 어떤 **단일 알고리즘(범용 튜링 기계, UTM)** 으로도 **모든** 계산 문제를 Yes/No로 판단할 수 없다.  
- 대표가 **정지 문제(HALT)**, 여기서 수많은 문제가 **감소(reduction)** 로 **결정 불가능(undecidable)** 임이 따라온다.  
- 많은 문제는 “예면 언젠가 잡히는” 수준으로만 풀린다(= **반결정 가능**/**재귀적 열거 가능**, RE).

---

## 0) 빠른 지형도

$$
\textbf{Recursive(결정 가능)} \;\subsetneq\; \textbf{RE(반결정 가능)} \;\subsetneq\; \mathcal{P}(\Sigma^*)
$$

- **Recursive**: 모든 입력에서 정지(Yes/No).  
- **RE**: “예(수용)”이면 언젠가 정지; “아니오”는 무한 루프 가능.  
- $$\text{RE} \cap \text{coRE} = \text{Recursive}.$$

---

## 1) 정지 문제(HALT) — 원형의 불가능성

### 1.1 정의
$$
\textsf{HALT}=\{\langle M\rangle\#w\mid \text{TM }M\text{이 }w\text{에서 유한 시간 내 정지}\}.
$$

### 1.2 대각선/귀류 스케치
가정: 정지 결정기 \(H\) 존재.

```text
D(x):
  if H(x, x) == halt: loop forever
  else:               halt
```

- \(D(\langle D\rangle)\)를 생각하면 모순 → 그런 \(H\)는 없음.  
- 결론: **정지 문제는 결정 불가능**. 단, “정지한다”는 **증거(실제 정지)** 가 있으면 잡히므로 **RE**.

### 1.3 RE·coRE 대비
- \(\textsf{HALT}\)는 **RE-완전**. 보수 \(\overline{\textsf{HALT}}\)는 **co-RE**(결정 불가능).

---

## 2) RE/REC 분류와 도베일링(dovetailing)

- 고전 등식:
  $$
  L \text{와 } \overline{L} \text{가 모두 RE} \iff L \text{는 Recursive.}
  $$

```text
# 양쪽 RE면 '결정' 가능: 둘을 교대로 조금씩 실행
Decide(w):
  for t = 1,2,3,...:
    simulate M_yes(w) for t steps; if accept: return YES
    simulate M_no (w) for t steps; if accept: return NO
```

---

## 3) 리스(Rice) 정리 — “프로그램 의미” 일반 불가능성

> **진술**: 튜링 기계가 계산하는 **함수/언어의 의미에 대한 비자명한 속성**은 모두 **결정 불가능**.

즉, 코드 모양이 아니라 **의미**에만 의존하는 속성 \(P\)가 “어떤 기계는 만족하고 어떤 기계는 불만족”이면  
\(\{\langle M\rangle\mid P(f_M)\}\) 은 결정 불가능.

**즉시 사례**

- **동일성** \(L(M_1)=L(M_2)\)? — 결정 불가능.  
- **공백성** \(L(M)=\varnothing\)? — 결정 불가능(더 구체적으로 **co-RE-완전**).  
- **정규성/CFL성 여부**, **유한성/무한성** — 전부 결정 불가능(보통 \(\Sigma^0_2/\Pi^0_2\)).

> 단일 입력 \(w_0\)에 대한 멤버십 “\(w_0\in L(M)\)?” 은 바로 **\(A_{TM}\)** 로 떨어져 **RE-완전**.

---

## 4) 정지 문제를 넘어: **UTM으로도 못 푸는 대표들**

### 4.1 Busy Beaver \(\Sigma(n)\), \(S(n)\) — **비계산 함수**
- \(n\)상태 TM이 정지할 때까지 남기는 최대 ‘1’의 개수(또는 시간).  
- \(\Sigma(n)\)·\(S(n)\) 은 **어떤 계산 가능 함수보다 빠르게 성장**, **비계산**.  
  증개요: 만약 계산 가능했다면 그 값을 이용해 정지 여부를 결정할 수 있어 HALT와 모순.

### 4.2 Kolmogorov 복잡도 \(K(x)\) — **계산 불가능**
- \(K(x)\): \(x\)를 출력하는 **최단 프로그램 길이**.  
- \(\{x\mid K(x)\ge n\}\) 은 **결정 불가능**(“이보다 더 압축 불가”는 일반에선 판정 불가).  
- 직관: “최단”을 알아내면 전체 프로그램 공간을 앞질러 모순(베리 역설풍).

### 4.3 Chaitin의 \(\Omega\) — **계산 불가능·무작위**
- 무작위적 정지확률 \(\Omega\)의 이진 전개는 **알고리즘적으로 무작위**.  
- 유한 길이 이상의 접두어를 일반적 형식계로는 **증명 불가**(고정 상수 한계 존재).

### 4.4 형식언어·오토마타 쪽
- **PCP(해 존재?)** — **RE**, **결정 불가능**(HALT \(\le_m\) PCP).  
- **CFG 모호성/보편성/동일성/포함성** — **결정 불가능**(반면 CFG **멤버십/공백성/유한성**은 **결정 가능**).  
- **정규 언어 동치/포함성**은 결정 가능하나, **TM 언어**로 올라가면 전부 불가능.

### 4.5 타일링·수학 쪽
- **Wang 타일링(도미노 문제)**: 평면을 무한히 타일링 가능? — **결정 불가능**.  
- **Hilbert 10번째**: 정수해 존재 판정 — **결정 불가능**(Matiyasevich–DPRM).  
- **유한 제시 군의 단어 문제** — **결정 불가능**(Novikov–Boone).

> 메시지: **모형만 달라도**(타일·문법·방정식·군) **핵심 난점**은 HALT와 같은 **근본적 한계**에서 온다.

---

## 5) RE·co-RE·상위 계층 **분류 표**

| 문제 | 분류 | 요지 |
|---|---|---|
| \(\textsf{HALT}(\langle M\rangle,w)\) | **RE-완전** | 정지 여부 |
| \(\textsf{A\_TM}(\langle M\rangle,w)\) | **RE-완전** | 수용 여부 |
| \(\overline{\textsf{HALT}}\) | **co-RE** | “결코 안 멈춤” |
| \(\textsf{E\_TM}:\ L(M)=\varnothing\) | **co-RE-완전** | 언어 공백 |
| \(\textsf{ALL\_TM}:\ L(M)=\Sigma^*\) | 보통 **\(\Pi^0_2\)-완전** | 보편성 |
| \(EQ_{TM}\) | **\(\Pi^0_2\)-완전** | 언어 동일 |
| \(INF_{TM}\)/\(FIN_{TM}\) | \(\Pi^0_2/\Sigma^0_2\)-완전 | 무한/유한 |
| **PCP-YES** | **RE-완전** | 해 존재 |
| **Wang 타일링** | 결정 불가능 | 평면 타일 |

---

## 6) **감소(reduction) 레시피** — 실전 템플릿

### 6.1 “스위치 머신” 가젯 (멤버십 → 보편/공백 등)

```text
# 입력 x = <M>#w 에 대해 f(x) = <N> 생성
N(y):
  simulate M(w)
  if M(w) accepts:
     accept          # L(N) = Σ*   (보편/비공백 보장)
  else:
     loop forever    # L(N) = ∅    (공백 보장)
```

- 그러면 \(\langle M\rangle\#w\in A_{TM} \iff \langle N\rangle\in NE_{TM}\) (또는 \(ALL_{TM}\)).  
- 같은 틀로 \(A_{TM}\le_m EQ_{TM}\): \(N_2\)를 “항상 수용”으로 두면 \(M(w)\) 수용 ⇔ \(L(N_1)=L(N_2)\).

### 6.2 “계산 이력”/“국소 검사” 가젯 (PCP·CFG·타일)
- 구분자(`#`)로 **행 경계**, 문자 일치/전이 검사 **타일/규칙**으로 **합법적 계산**만 통과.  
- 시작/종료 **강제**로 올바른 첫/끝 행만 허용 → HALT/수용과 동치.

---

## 7) 예제 코드(의사코드) — 반결정/열거·감소

### 7.1 HALT의 **반결정기(RE 인식기)**

```text
Recognize_HALT(<M>#w):
  simulate M(w) step-by-step
  if M(w) halts: ACCEPT
  # else: possibly loop forever
```

### 7.2 RE **열거기** (도베일링)

```text
Enumerate_ATM():
  for s = 1,2,3,...:
    for all pairs (<M>, w) with |<M>#w| ≤ s:
       simulate M(w) for s steps
       if acceptance observed: output <M>#w
```

### 7.3 \(A_{TM}\Rightarrow NE_{TM}\) **many-one 감소**

```text
Reduce_Membership_to_Nonemptiness(<M>#w):
  construct N that ignores its input and simulates M(w)
  if M(w) accepts, N accepts all inputs; else N loops on all
  return <N>  # <M>#w ∈ A_TM  ⇔  <N> ∈ NE_TM
```

### 7.4 CFG **보편성**으로의 스케치 감소

```text
Reduce_ATM_to_CFG_Universality(<M>#w):
  build G_bad that generates exactly "malformed computation tables" of M on w
  # if M(w) accepts, every string is either malformed or the unique valid table -> Σ*
  # else, the valid table isn't generated -> not Σ*
  return <G_bad>
```

---

## 8) 실무 감각: “왜 완전 자동 검증기가 불가능한가”

- “**항상 정지**/**항상 범위 안전**/**항상 race-free**” 같은 **전역 의미 속성**의 **일반 판정기**는  
  리스 정리와 정지 문제로 **존재할 수 없음**.  
- 현실 해법:  
  - **제한된 언어/모델**(정규, CFL, 제한된 루프, 선형형식)로 **문제 재정의**,  
  - **보수적 근사**(오경보/미탐 허용),  
  - **시간 제한/휴리스틱**.  
- 반면 “**예**이면 언젠가 찾는 증거 기반(증명 탐색/모형 검사)**”는 RE에 해당 — **부분적** 자동화가 가능.

---

## 9) 자주 하는 질문(FAQ)

- **Q. “충분히 오래 돌리면 다 보지 않나?”**  
  A. **아님**. 어떤 입력은 **영원히** 안 끝날 수 있다(정지 문제 핵심). 끝나는지 미리 일반 판정 불가.

- **Q. RE와 NP의 ‘증거’ 개념 차이는?**  
  A. NP는 **다항시간 검증**(시간 제한), RE는 **시간 제한 없음**(정지만 하면 됨).

- **Q. “보수”가 항상 비슷한가?**  
  A. $$\text{RE}$$는 **보수에 닫혀 있지 않음**. $$\text{RE}\cap\text{coRE}=\text{Recursive}$$.

---

## 10) 한 페이지 요약

- **정지 문제(HALT)**: **결정 불가능**, **RE-완전**.  
- **Rice 정리**: “프로그램 의미의 비자명 속성” → **결정 불가능**.  
- **그 너머**: Busy Beaver, Kolmogorov \(K\), Chaitin \(\Omega\) → **비계산**/**결정 불가능**.  
- **형식언어/타일/수론**: PCP, CFG 보편/동일/모호성, Wang 타일링, Hilbert 10 — **결정 불가능**.  
- **레시피**: (1) HALT/\(A_{TM}\)에서 출발, (2) 스위치 머신/국소 검사 가젯, (3) many-one 감소로 양방향 논리 확보.  
- **실무 메시지**: 완전 자동 판단 불가의 벽은 **정지 문제/리스 정리**에서 온다.  
  **제한/근사/증거 중심** 설계로 **부분적 자동화**를 달성하자.

---

### 연습 과제(권장)

1) \(A_{TM}\le_m ALL_{TM}\) 을 위 **스위치 머신** 패턴으로 직접 구성해 보라.  
2) “\(INF_{TM}\)”가 \(\Pi^0_2\)-완전임을 \(\forall\exists\) 양화 구조로 설명해 보라.  
3) Busy Beaver가 계산 가능하다고 가정했을 때 HALT가 결정 가능해지는 논리를 **코드 수준**으로 정리해 보라.