---
layout: post
title: MFC - 국제화 심화
date: 2025-09-22 16:25:23 +0900
category: MFC
---
# 국제화 심화(IME/TSF) 완전 가이드  
**조합 중 텍스트(한/중/일) 처리 · BiDi/그라페믹 클러스터 · 유니코드 정규화 · 파일 경로(UTF-16 vs UTF-8) 전략**

> 대상: Win32/MFC 기반 커스텀 에디트/뷰/코드에디터/IME 민감 UI.  
> 목표: **조합 중(Composition)** 입력을 잃지 않고 표기/커서/선택을 정확히 유지, **BiDi/클러스터** 단위로 이동/삭제, **정규화/경로 인코딩**을 일관되게 다루기.

---

## 0) 큰 그림: 무엇을 반드시 해야 하나

1) **조합 중 텍스트**(IME/TSF)  
   - `WM_IME_COMPOSITION`/`IMM32` 또는 **TSF** 이벤트에서 **미완성 문자열**을 별도 레이어로 표시(밑줄/물결/역상).  
   - 조합 커서(Composition caret)와 확정 커서를 분리, **확정 전에는 본문 문자열을 바꾸지 않음**.  
   - 후보창은 IME가 그리므로 **우리 앱은 위치 힌트(캐럿 rect)** 만 정확히 제공.

2) **그라페믹 클러스터(문자 사용자 인식 단위)**  
   - 유니코드 1 code point ≠ 1 글자. (한글 조합자/조합형, 이모지 ZWJ 시퀀스, 결합 부호 등)  
   - 좌우 이동/Backspace/Delete/선택은 **클러스터 경계**로 처리.  
   - DirectWrite/Uniscribe/ICU를 활용해 경계 계산.

3) **BiDi(양방향)**  
   - 논리 순서로 저장, **레이아웃 엔진(DirectWrite)** 에게 시각 순서를 맡김.  
   - 커서 HitTest·라인 브레이크·왼/오 이동을 **시각 순서 규칙**에 맞게 위임/보정.

4) **정규화/경로 인코딩**  
   - 내부 문자열 비교/검색/색인에는 **정규화(NFC) 기준** 권장.  
   - 파일 경로는 Win32 네이티브가 **UTF-16**. 저장 포맷/네트워크/설정은 **UTF-8**가 편리.  
   - 비교·정렬·케이스폴딩은 Windows API(예: `CompareStringOrdinal`) 사용.

---

## 1) IME/TSF 구조 빠르게 이해하기

| 요소 | 설명 | 어디서 처리? |
|---|---|---|
| **IMM32(전통 IME)** | `WM_IME_*` 메시지/`ImmGetContext` 계열 | 간단, 빠른 통합 |
| **TSF(Text Services Framework)** | `ITfThreadMgr`/`ITfContext`/`ITf*Sink` | 세밀, 현대적, 앱이 텍스트 저장소(Text Store) 제공 |
| **조합 문자열** | 미확정(IME 내부 조합 중) | 확정 전엔 문서에 삽입 금지, 오버레이로 그림 |
| **읽기 문자열(Reading String)** | 일본어 카나/중국어 표음 등 | UI 참고(보통 그리지 않아도 됨) |
| **재변환(Reconversion)** | 선택 영역을 다시 IME로 넣어 후보 재생성 | `WM_IME_REQUEST(IMR_RECONVERTSTRING)` 또는 TSF 명령 |
| **후보창** | IME가 그리는 팝업 | 캐럿 좌표 전달(문서 좌표→스크린) |

---

## 2) IMM32(전통 IME) 기본기 — 커스텀 에디트에 조합 표시

### 2.1 메시지 흐름 요약
- `WM_IME_STARTCOMPOSITION` → 조합 시작  
- `WM_IME_COMPOSITION` → `GCS_COMPSTR`/`GCS_RESULTSTR` 등 확인  
- `WM_IME_ENDCOMPOSITION` → 조합 종료 정리

### 2.2 최소 골격
```cpp
// 멤버: 조합 중 문자열과 속성
std::wstring g_comp;          // 조합 문자열
std::vector<BYTE> g_compAttr; // ATTR_INPUT/ATTR_TARGET_CONVERTED 등
int g_compCursor = 0;         // 조합 내부 캐럿(UTF-16 code unit index)

// 조합 상태: On/Off
bool g_inComp = false;

LRESULT OnImeStartComposition(HWND h) {
    g_inComp = true;
    g_comp.clear(); g_compAttr.clear(); g_compCursor = 0;
    InvalidateRect(h, nullptr, FALSE); // 오버레이 갱신
    return 0;
}

static std::wstring GetImeString(HIMC hImc, DWORD type) {
    LONG len = ImmGetCompositionStringW(hImc, type, nullptr, 0);
    if (len <= 0) return L"";
    std::wstring s; s.resize((len/sizeof(wchar_t)));
    ImmGetCompositionStringW(hImc, type, &s[0], len);
    return s;
}

LRESULT OnImeComposition(HWND h, LPARAM lParam) {
    HIMC hImc = ImmGetContext(h);
    if (!hImc) return 0;

    if (lParam & GCS_RESULTSTR) {
        // 확정 문자열 수신 -> 문서에 실제 삽입
        auto result = GetImeString(hImc, GCS_RESULTSTR);
        InsertTextAtCaret(result);      // 문서 모델 업데이트
        g_inComp = false; g_comp.clear(); g_compAttr.clear(); g_compCursor = 0;
        CaretMoveByGrapheme(result.size()); // 필요 시 이동
        InvalidateRect(h, nullptr, FALSE);
    }
    if (lParam & GCS_COMPSTR) {
        g_comp      = GetImeString(hImc, GCS_COMPSTR);
        // 속성(밑줄/타겟 변환)
        LONG alen = ImmGetCompositionStringW(hImc, GCS_COMPATTR, nullptr, 0);
        g_compAttr.resize(std::max<LONG>(0, alen));
        if (alen > 0) ImmGetCompositionStringW(hImc, GCS_COMPATTR, g_compAttr.data(), alen);
        // 조합 캐럿
        LONG cur = ImmGetCompositionStringW(hImc, GCS_CURSORPOS, nullptr, 0);
        g_compCursor = (cur >= 0) ? (int)cur : 0;

        // 우리 뷰를 다시 그림: 본문 + 오버레이(조합 문자열 밑줄)
        InvalidateRect(h, nullptr, FALSE);
    }

    ImmReleaseContext(h, hImc);
    return 0;
}

LRESULT OnImeEndComposition(HWND h) {
    g_inComp = false;
    g_comp.clear(); g_compAttr.clear(); g_compCursor = 0;
    InvalidateRect(h, nullptr, FALSE);
    return 0;
}
```

### 2.3 그리기(조합 문자열 오버레이)
- 본문 텍스트는 그대로 유지. 커서 위치에 **조합 문자열을 덮어 씀**.  
- 속성 `g_compAttr` 는 보통 **밑줄 스타일**(입력 중, 변환 대상)을 구분.

```cpp
void PaintCompositionOverlay(HDC hdc, const POINT& caretPt) {
    if (!g_inComp || g_comp.empty()) return;

    // caretPt: 조합 시작 위치의 화면/클라이언트 좌표(문서 레이아웃에서 계산)
    // 1) 조합 텍스트를 그린 뒤
    TextOutW(hdc, caretPt.x, caretPt.y, g_comp.c_str(), (int)g_comp.size());

    // 2) 밑줄(속성에 따라 스타일)
    SIZE sz{};
    GetTextExtentPoint32W(hdc, g_comp.c_str(), (int)g_comp.size(), &sz);
    int y = caretPt.y + sz.cy - 2;
    MoveToEx(hdc, caretPt.x, y, nullptr);
    LineTo(hdc, caretPt.x + sz.cx, y);
}
```

> **중요**: **조합 중에는 문서 모델을 변형하지 말고**, 오버레이만 바꿔라. 확정(`GCS_RESULTSTR`)이 왔을 때만 문서에 반영.

### 2.4 후보창 위치 힌트
```cpp
void UpdateImeCompositionWindow(HWND h, const RECT& caretRect) {
    HIMC hImc = ImmGetContext(h);
    if (!hImc) return;
    COMPOSITIONFORM cf{};
    cf.dwStyle = CFS_FORCE_POSITION;
    cf.ptCurrentPos = { caretRect.left, caretRect.bottom };
    ImmSetCompositionWindow(hImc, &cf);

    CANDIDATEFORM cand{};
    cand.dwIndex = 0;
    cand.dwStyle = CFS_CANDIDATEPOS;
    cand.ptCurrentPos = { caretRect.left, caretRect.bottom };
    ImmSetCandidateWindow(hImc, &cand);

    ImmReleaseContext(h, hImc);
}
```

---

## 3) TSF(Text Services Framework) — 현대적(권장) 접근

### 3.1 핵심 개념
- **애플리케이션**은 **텍스트 스토어**(문자열/선택/속성 범위 제공자) 역할.  
- **텍스트 서비스**(IME/키보드/교정)가 **Composition**을 **범위 기반**으로 생성/수정.  
- 앱은 `ITfThreadMgr`/`ITfDocumentMgr`/`ITfContext` 를 생성, `ITfContextOwnerCompositionSink` 등 **Sink** 등록.

### 3.2 최소 초기화
```cpp
#include <msctf.h>
#pragma comment(lib, "msctf.lib")

ComPtr<ITfThreadMgr>   g_tm;
TfClientId             g_clientId = TF_CLIENTID_NULL;
ComPtr<ITfDocumentMgr> g_docMgr;
ComPtr<ITfContext>     g_context;

bool TsfInit(HWND hwnd) {
    if (FAILED(CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED))) return false;
    if (FAILED(CoCreateInstance(CLSID_TF_ThreadMgr, nullptr, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&g_tm)))) return false;
    if (FAILED(g_tm->Activate(&g_clientId))) return false;

    g_tm->CreateDocumentMgr(&g_docMgr);
    // 문서 컨텍스트 생성(단순 텍스트 저장소 구현은 TSF Text Store(Advanced) 필요)
    DWORD editCookie = 0;
    g_docMgr->CreateContext(g_clientId, 0, (IUnknown*)/*ITfContextOwner*/nullptr, &g_context, &editCookie);
    g_docMgr->Push(g_context.Get());

    // hwnd와 TSF를 연결(AssociateFocus)
    ComPtr<ITfDocumentMgr> prev;
    g_tm->AssociateFocus(hwnd, g_docMgr.Get(), &prev);

    return true;
}
```

> **실전**: TSF를 완전 구현하려면 **Text Store(ITfTextStoreACP/Anchor)** 를 구현해 **문자열/선택/뷰/히트테스트** 를 제공하는 형태가 가장 강력합니다(코드량 多).  
> 커스텀 에디트가 복잡(문서/레이아웃 엔진 보유)이면 **TSF Text Store** 구현을 권장.

### 3.3 Composition 수신(개요)
- `ITfContextOwnerCompositionSink::OnStartComposition` / `OnUpdateComposition` / `OnEndComposition`  
- 범위(`ITfRange`) 단위로 조합 상태가 들어오며, **디스플레이 속성**(`ITfDisplayAttributeMgr`)로 밑줄/색 지정 가능.

```cpp
// 의사코드: Sink 구현 골격
class MyCompSink : public ITfContextOwnerCompositionSink {
  // AddRef/Release/QI ...
  STDMETHODIMP OnStartComposition(ITfCompositionView* view, BOOL* ok) {
    *ok = TRUE; g_inComp = true; return S_OK;
  }
  STDMETHODIMP OnUpdateComposition(ITfCompositionView* view, ITfRange* rangeNew) {
    // rangeNew를 ACPS/Anchor로 가져와 현재 조합 문자열/범위 업데이트
    // 디스플레이 속성 조회 → 오버레이 스타일 적용
    return S_OK;
  }
  STDMETHODIMP OnEndComposition(ITfCompositionView* view) {
    g_inComp = false; return S_OK;
  }
};
```

> **장점**: IMM32보다 **세밀**하고 **IME별 차이**가 작음. 특히 **읽기 문자열/재변환/언어 모델**과의 호환이 좋습니다.

---

## 4) 재변환(Reconversion) & 재변환 가능한지 질의

### 4.1 IMM32 — `WM_IME_REQUEST / IMR_RECONVERTSTRING`
- 선택 영역 텍스트를 **원문으로 IME에 다시 공급**하면, IME가 **다시 후보를 제시**.

```cpp
// 선택 텍스트를 ReconvertString 구조로 빌드
static LPARAM BuildReconvertString(const std::wstring& text, std::vector<BYTE>& buf) {
    size_t bytes = sizeof(RECONVERTSTRING) + (text.size()+1)*sizeof(wchar_t);
    buf.resize(bytes);
    auto prs = (RECONVERTSTRING*)buf.data();
    prs->dwSize = (DWORD)bytes;
    prs->dwVersion = 0;
    prs->dwStrLen = (DWORD)text.size();
    prs->dwStrOffset = sizeof(RECONVERTSTRING);
    prs->dwCompStrLen = prs->dwStrLen;  // 전체를 조합 영역으로
    prs->dwCompStrOffset = prs->dwStrOffset;
    prs->dwTargetStrLen = prs->dwStrLen;
    prs->dwTargetStrOffset = prs->dwStrOffset;
    memcpy(buf.data()+prs->dwStrOffset, text.c_str(), (text.size()+1)*sizeof(wchar_t));
    return (LPARAM)prs;
}

LRESULT OnImeRequest(HWND h, WPARAM w, LPARAM l) {
    if (w == IMR_RECONVERTSTRING) {
        auto sel = GetSelectedText(); // 선택 문자열
        static std::vector<BYTE> tmp;
        LPARAM p = BuildReconvertString(sel, tmp);
        if (l == 0) return ((RECONVERTSTRING*)p)->dwSize; // 길이 질의
        memcpy((void*)l, (void*)p, ((RECONVERTSTRING*)p)->dwSize);
        return 1;
    }
    return 0;
}
```

- `ImmSetCompositionStringW(hImc, SCS_QUERYRECONVERTSTRING/ SCS_SETRECONVERTSTRING, …)` 를 사용해도 됨.

### 4.2 TSF — `ITfFnReconversion`  
- 텍스트 서비스가 **함수 제공자**로 재변환을 수행. 앱은 Text Store 범위만 잘 제공하면 됨.

---

## 5) 그라페믹 클러스터(문자 경계) — 이동/삭제/선택의 기본 단위

> **왜 필요?**  
> - 한글: 초/중/종성 합성, 일부는 **단일 code point**(가/각), 일부는 **조합자 시퀀스**.  
> - 이모지: `👨‍👩‍👧‍👦`(가족) 처럼 **여러 code point + ZWJ** 로 **한 글자처럼 보임**.  
> - 결합 부호(모음 악센트, 스킨톤 수정자 등).

### 5.1 전략
- **DirectWrite**: `IDWriteTextLayout::GetClusterMetrics` 또는 `HitTestTextPosition`/`HitTestPoint` 를 통해 **가시적 클러스터 경계**를 받음.  
- **ICU**: UAX #29 Grapheme Break.  
- **Uniscribe**(레거시): `ScriptBreak` + shaping 결과로 경계 유추.

### 5.2 DirectWrite 예 — 커서 좌/우 이동
```cpp
struct Cursor {
    UINT32 textPos = 0; // UTF-16 code unit index
};

// 시각 경계 기반 다음/이전 클러스터로 이동
UINT32 MoveRightByCluster(IDWriteTextLayout* layout, UINT32 pos) {
    // pos 위치를 화면으로 hit test → 다음 클러스터의 시작 위치 계산
    BOOL trailing = FALSE;
    FLOAT x=0, y=0;
    DWRITE_HIT_TEST_METRICS m{};
    layout->HitTestTextPosition(pos, /*isTrailingHit*/FALSE, &x, &y, &m);
    // 현재 클러스터 끝으로
    UINT32 next = m.textPosition + m.length;
    return next;
}

UINT32 MoveLeftByCluster(IDWriteTextLayout* layout, UINT32 pos) {
    // pos 한 글자 앞을 hit test하여 그 클러스터의 시작으로
    if (pos == 0) return 0;
    BOOL trailing = FALSE;
    FLOAT x=0, y=0;
    DWRITE_HIT_TEST_METRICS m{};
    layout->HitTestTextPosition(pos-1, /*isTrailingHit*/TRUE, &x, &y, &m);
    return m.textPosition;
}
```

### 5.3 삭제(Backspace/Delete)
- **Backspace**: `pos = MoveLeftByCluster(pos)` 으로 얻은 이전 경계~현재 `pos` 절단.  
- **Delete**: 현재 `pos`~`MoveRightByCluster(pos)` 절단.  
- 이렇게 하면 **이모지/합성문자/결합부호**를 **깨지 않고** 지운다.

---

## 6) BiDi(양방향) — 커서/선택/그리기

### 6.1 원칙
- **문서 저장은 논리 순서**.  
- **표시는 DirectWrite**에 맡겨 **비주얼/라인 순서** 계산.  
- 커서 이동은 **시각 순서** 기준(사용자 기대). 문자 단위 이동은 5장(클러스터)와 결합.

### 6.2 HitTest를 신뢰하라
- 좌↔우 이동 시, **현재 glyph run의 방향**(LTR/RTL)에 따라 **왼쪽 이동 = 이전 시각 위치**로 매핑.  
- `IDWriteTextLayout::HitTestTextPosition` 에서 반환하는 `isInside`/`metrics` 로 **행/열 전환** 구현.

```cpp
UINT32 VisualMoveLeft(IDWriteTextLayout* layout, UINT32 pos) {
    // 시각적으로 왼쪽: 현재 런의 방향에 따라 prev/next 클러스터
    // 간단 구현: pos-1에 trailing hit → 해당 클러스터 시작 반환
    return MoveLeftByCluster(layout, pos);
}
UINT32 VisualMoveRight(IDWriteTextLayout* layout, UINT32 pos) {
    return MoveRightByCluster(layout, pos);
}
```

> **선택 확장**: Shift+Arrow는 **이동 후 새 pos** 와 **anchor** 로 범위 구성. BiDi에서도 일관.

---

## 7) 유니코드 정규화(Normalization) — 비교/검색/저장 규칙

### 7.1 배경
- 유니코드 문자 하나가 **정규화 형태**에 따라 **서로 다른 코드 시퀀스**로 표현.  
  - 예) “é” = U+00E9(NFC) = “e” + U+0301(NFD).  
- 비교/색인/검색에서 **서로 같은 글자**로 취급하려면 **정규화** 필요.

### 7.2 Windows API: `NormalizeString`
```cpp
std::wstring NormalizeNFC(const std::wstring& s) {
    int len = NormalizeString(NormalizationC, s.c_str(), (int)s.size(), nullptr, 0);
    if (len <= 0) return s;
    std::wstring out; out.resize(len);
    NormalizeString(NormalizationC, s.c_str(), (int)s.size(), &out[0], len);
    // NormalizeString은 null-terminated 필요 없음. size 그대로 사용.
    return out;
}
```

- 형태: `NormalizationC(NFC)`, `NormalizationD(NFD)`, `NormalizationKC`, `NormalizationKD`.  
- **일반 텍스트** 비교/검색엔 **NFC** 권장(가장 널리 사용).

### 7.3 비교/정렬
- **이진 비교 금지**.  
- 케이스/악센트 무시 비교가 필요하면 `CompareStringOrdinal` 또는 `CompareStringEx` 사용.

```cpp
int OrdinalInsensitiveEqual(const std::wstring& a, const std::wstring& b) {
    return CompareStringOrdinal(a.c_str(), (int)a.size(), b.c_str(), (int)b.size(), TRUE) == CSTR_EQUAL;
}
```

> **주의**: 문화권 의존 비교는 `CompareStringEx(LOCALE_NAME_USER_DEFAULT, LINGUISTIC_*)` 고려.  
> 파일 시스템·키·ID 등 **문화 중립** 비교는 `CompareStringOrdinal` 로 고정.

---

## 8) 파일 경로/인코딩 전략 — UTF-16 ↔ UTF-8

### 8.1 Windows 경로는 UTF-16
- Win32 기본 API는 **UTF-16(Wide)**. (예: `CreateFileW`, `FindFirstFileW`)  
- **UTF-8 경로**를 쓰고 싶다면 **변환** 필요.  
- 앱 외부 파일 형식/네트워크/설정은 **UTF-8**이 상호운용에 유리.

### 8.2 변환 유틸
```cpp
std::string ToUtf8(const std::wstring& w) {
    if (w.empty()) return {};
    int n = WideCharToMultiByte(CP_UTF8, 0, w.c_str(), (int)w.size(), nullptr, 0, nullptr, nullptr);
    std::string s; s.resize(n);
    WideCharToMultiByte(CP_UTF8, 0, w.c_str(), (int)w.size(), &s[0], n, nullptr, nullptr);
    return s;
}
std::wstring ToUtf16(const std::string& u8) {
    if (u8.empty()) return {};
    int n = MultiByteToWideChar(CP_UTF8, 0, u8.c_str(), (int)u8.size(), nullptr, 0);
    std::wstring w; w.resize(n);
    MultiByteToWideChar(CP_UTF8, 0, u8.c_str(), (int)u8.size(), &w[0], n);
    return w;
}
```

### 8.3 저장 포맷 권장
- **문서/텍스트/설정(JSON/YAML)**: **UTF-8**(BOM 없이) 권장. (일부 에디터 호환 위해 BOM 허용 가능)  
- **파일명 비교/색인**: 입력 받은 경로를 **NFC**로 정규화해 **키**로 사용. 실제 디스크 이름은 **원본 유지**(사용자 의도).

### 8.4 긴 경로
- `\\?\` 접두어 또는 매니페스트 **longPathAware** 활성화.  
- 항상 **Wide API** (`CreateFileW` 등) 사용.

---

## 9) 키/메시지 상호작용 — IME와 충돌 없이 키 처리

- **금지**: IME 조합 키를 `PreTranslateMessage`에서 가로채서 버리기.  
  - `VK_PROCESSKEY`/IME 변환 키는 **DefWindowProc** 로 흘려보내라.  
- **Dead Key**(악센트 조합)도 **조합 과정**이므로 문자 변환은 **`WM_CHAR`만 신뢰**.

```cpp
BOOL PreTranslateMessage(MSG* p) override {
    if (p->message == WM_KEYDOWN && p->wParam == VK_PROCESSKEY)
        return FALSE; // IME에 맡김
    return CDialogEx::PreTranslateMessage(p);
}
```

---

## 10) 클립보드/드래그 — 조합 중 상태와의 상호작용

- **조합 중에는 Cut/Copy/Drag 시작을 금지**. 사용자 경험 혼란 방지.  
- 조합을 **강제 확정**한 뒤 처리하거나, **메뉴/단축키 비활성화**(`ON_UPDATE_COMMAND_UI`)로 안내.

---

## 11) DPI/렌더링 — 조합 커서 위치 정확도

- 조합 오버레이/후보창 위치는 **픽셀 정확**해야 함.  
- 문서 좌표 → 뷰 스케일/스크롤 → **클라이언트 좌표** → `ClientToScreen` 으로 변환 후 IME API 호출.  
- 더블버퍼/반전/서브픽셀 렌더링 중에도 **캐럿 rect** 는 **실좌표**로 계산.

---

## 12) 실전: DirectWrite 기반 커스텀 에디트 미니 샘플(요약)

```cpp
// 핵심만: 텍스트는 논리 버퍼, 레이아웃은 DWrite, 조합은 오버레이
class DWriteEdit {
    std::wstring _text;
    UINT32       _caret = 0; // UTF-16 index
    bool         _inComp = false;
    std::wstring _comp;
    UINT32       _compCaret = 0;

    ComPtr<IDWriteFactory> _dwf;
    ComPtr<IDWriteTextFormat> _fmt;

public:
    void OnChar(wchar_t ch) {
        if (_inComp) return; // 조합 중 문자확정은 WM_IME에서 받음
        InsertAtCaret(std::wstring(1, ch));
    }
    void OnImeStart() { _inComp = true; _comp.clear(); _compCaret = 0; }
    void OnImeComp(const std::wstring& comp, int caret) { _comp = comp; _compCaret = (UINT32)caret; Invalidate(); }
    void OnImeResult(const std::wstring& result) { InsertAtCaret(result); _inComp = false; _comp.clear(); Invalidate(); }

    void Paint(HDC hdc) {
        // 1) 본문(DWrite TextLayout) 그리기
        // 2) 캐럿 그림
        // 3) 조합 문자열 오버레이: _caret 위치에 _comp를 추가로 그리기 + 밑줄
    }

    void InsertAtCaret(const std::wstring& s) {
        _text.insert(_caret, s);
        _caret += (UINT32)s.size(); // 클러스터 고려시 MoveRightByCluster로 이동
    }
};
```

---

## 13) 테스트 체크리스트

- [ ] 한글: 2벌식/3벌식, `ㄱ+ㅏ=가` 조합, 받침/겹받침, 중간 삭제  
- [ ] 일본어: 히라→가타 변환, 재변환, 반각/전각  
- [ ] 중국어: 병음/주음, 후보 다량 전환, 문장 단위 변환  
- [ ] 영어 Dead Key(프랑스어 레이아웃): 악센트 입력  
- [ ] 이모지: 스킨톤/ZWJ 가족/국기(리전 합성) 삭제/이동  
- [ ] BiDi: 아랍어/히브리어 + 숫자/영문 혼재, 왼/오 이동, 줄바꿈  
- [ ] 조합 중 상태에서: 저장/복사/인쇄/포커스 이동/Alt+Tab/윈도 이동  
- [ ] DPI 150/200%, 다중 모니터 다른 DPI, 후보창 위치 정확성  
- [ ] 정규화: “é” NFC/NFD 검색/비교 일치

---

## 14) 흔한 문제와 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| 조합 중 글자가 본문에 중복 삽입 | `GCS_COMPSTR`를 본문에 반영 | **오버레이만** 그리고, `GCS_RESULTSTR` 에서만 본문에 삽입 |
| Backspace가 이모지 반쪽만 지움 | code unit 단위 삭제 | **클러스터 경계**로 이동 후 범위 삭제 |
| 후보창이 엉뚱한 곳에 뜸 | 캐럿 좌표를 스크린 좌표로 안 넘김 | 문서→뷰→클라→스크린 변환 후 `ImmSetCandidateWindow` |
| BiDi에서 커서가 왼/오 뒤죽박죽 | 논리/시각 혼동 | **HitTest 기반** 이동, 시각 순서 규칙 준수 |
| NFC/NFD 다름으로 검색 실패 | 정규화 미적용 | 비교/색인 전에 **NormalizeString(NFC)** 적용 |

---

## 15) 보너스: 성능 팁

- 조합 오버레이는 **문자 폭/밑줄**만 갱신 → **부분 무효화**(InvalidateRect 좁게).  
- 레이아웃은 **결과 문자열 확정 시**에만 재생성, 조합 중에는 **측정 최소화**.  
- 클러스터 경계 계산은 **TextLayout 캐시** 또는 **ICU BreakIterator** 재사용.

---

## 16) 결론

- **조합 중 텍스트는 “그림”만, 확정 때 “삽입”** — 이것만 지켜도 80점.  
- **클러스터/BiDi** 는 DirectWrite/ICU에 **과감히 위임**하고, HitTest/ClusterMetrics로 커서/선택을 구현.  
- **정규화/경로 인코딩** 규칙을 프로젝트 초기에 고정: *내부 NFC, 외부 UTF-8, Win32 경로는 UTF-16*.  
- 위 원칙을 토대로 MFC/Win32에서도 **현대적 국제화 품질**을 달성할 수 있다. 필요하면 **TSF Text Store** 완전 구현으로 확장하세요. ✨

---
### 부록 A. 상수/링크(짧은 메모)
- IMM32: `WM_IME_*`, `GCS_COMPSTR`, `GCS_RESULTSTR`, `ImmGetCompositionString`, `ImmSetCandidateWindow`  
- TSF: `ITfThreadMgr`, `ITfDocumentMgr`, `ITfContext`, `ITf*Sink`, `ITfFnReconversion`, `ITfDisplayAttributeMgr`  
- DirectWrite: `IDWriteTextLayout::HitTestTextPosition/Point`, `GetClusterMetrics`  
- 정규화: `NormalizeString(NormalizationC)`, 비교: `CompareStringOrdinal`  
- 경로: Wide API, `\\?\`, `WideCharToMultiByte(CP_UTF8)` / `MultiByteToWideChar(CP_UTF8)`