---
layout: post
title: Spring - 캐시 & 성능 최적화
date: 2025-10-16 22:25:23 +0900
category: Spring
---
# 16. 캐시 & 성능 최적화 — Spring Cache·Redis, 2차 캐시/쿼리 최적화, 배치 크기·페치 전략, 커넥션 풀(Hikari)·GC·스레드 풀

> 목표: **한 번 더 빠르게, 비용은 더 적게, 장애는 더 드물게.**  
> 관점: (A) 애플리케이션 캐시 — Spring Cache + Redis, (B) JPA/Hibernate 최적화 — 1차/2차/쿼리 캐시 & 페치 전략, (C) 데이터 쓰기/읽기 **배치화**, (D) 인프라 레이어 — **HikariCP/GC/스레드풀** 튜닝, (E) **측정→가설→실험→검증** 사이클.

전제: Spring Boot 3.3+, Java 21, Postgres(or MySQL), Redis 7+, Micrometer/Prometheus, Actuator, JPA/Hibernate.

---

## A. Spring Cache 추상화 & Redis 적용

### A-1. 언제 캐시를 쓰는가? (캐시 적합성 3원칙)
1) **비용이 큰 I/O/연산**(DB·외부 API·복잡 계산)  
2) **읽기 빈도 ≫ 쓰기 빈도**, 단기 불일치 허용  
3) **키 정의가 명확**하고, **무효화 전략**을 설계할 수 있을 때

> “DB 인덱스·쿼리 최적화가 먼저, 캐시는 나중에.”  
> 캐시는 **정확성 대신 성능**을 산다. **무효화 실패**가 가장 큰 리스크다.

### A-2. 의존성 & 기본 설정
```kotlin
dependencies {
  implementation("org.springframework.boot:spring-boot-starter-cache")
  implementation("org.springframework.boot:spring-boot-starter-data-redis")
  implementation("com.fasterxml.jackson.module:jackson-module-blackbird") // 직렬화 최적화(선택)
}
```
```yaml
spring:
  cache:
    type: redis
  data:
    redis:
      host: localhost
      port: 6379
      client-type: lettuce       # 기본
      lettuce:
        pool:
          enabled: true
          max-active: 64
          max-idle: 16
          min-idle: 4
      timeout: 2000ms
```

### A-3. CacheManager·Key·TTL (운영 관점)
```java
@Configuration
@EnableCaching
public class CacheConfig {

  @Bean
  public RedisCacheConfiguration redisCacheConfiguration(ObjectMapper om) {
    var valueSerializer = new GenericJackson2JsonRedisSerializer(om);
    return RedisCacheConfiguration.defaultCacheConfig()
        .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer))
        .disableCachingNullValues()
        .entryTtl(Duration.ofMinutes(10)) // 디폴트 TTL
        .prefixCacheNameWith("ms:");      // 캐시 네임스페이스
  }

  @Bean
  public CacheManager cacheManager(RedisConnectionFactory cf, RedisCacheConfiguration cfg) {
    Map<String, RedisCacheConfiguration> perCache = new HashMap<>();
    perCache.put("productById", cfg.entryTtl(Duration.ofMinutes(30)));
    perCache.put("hotCatalog", cfg.entryTtl(Duration.ofSeconds(30)));
    perCache.put("userProfile", cfg.entryTtl(Duration.ofHours(6)));
    return RedisCacheManager.builder(cf)
        .cacheDefaults(cfg)
        .withInitialCacheConfigurations(perCache)
        .transactionAware()
        .build();
  }

  @Bean
  public KeyGenerator methodParamKey() {
    return (target, method, params) -> method.getName() + ":" + Arrays.deepToString(params);
  }
}
```

- **캐시 네이밍**: `서비스:도메인:메서드`(예: `shop:product:getById`)로 명시.  
- **TTL 레벨링**: **사용자별/권한별** 캐시는 짧게, 공용/정적은 길게.  
- **Null 캐싱 금지**: 기본 off. 필요하면 초단 TTL(수 밀리초~수 초)로 **캐시 스탬피드** 방지.

### A-4. 애너테이션 패턴 (Cache-Aside)
```java
@Service
@RequiredArgsConstructor
public class ProductQuery {

  @Cacheable(value = "productById", key = "#id", unless = "#result == null")
  public ProductView get(String id) {       // 미스 → DB → 캐시 적재
    return repo.findById(id).map(ProductView::of).orElse(null);
  }

  @Caching(evict = {
    @CacheEvict(value="productById", key="#id"),
    @CacheEvict(value="hotCatalog", allEntries=true)   // 목록 캐시 파기
  })
  @Transactional
  public void updateName(String id, String name) {
    var p = repo.getById(id); p.rename(name);
  }
}
```

- **`@CachePut`**: 쓰기 후 캐시 갱신이 필요한 경우.  
- **`@Caching`**: **쓰기→조회 캐시 파기** 조합. 목록 캐시는 보통 **전체 파기**가 안전.

### A-5. 캐시 스탬피드/스로틀
- **확률적 조기 만료(soft TTL)**: 남은 TTL의 p%에서 조기 재검증.  
- **분산락**: 핫키 최초 미스 시 **1명만** 재계산, 다른 요청은 기다리기/스테일 허용.  
- **레이트 리밋**: 미스 초과 호출 제한.

```java
@Component
@RequiredArgsConstructor
public class CacheStampedeGuard {
  private final StringRedisTemplate rt;

  public <T> T singleFlight(String key, Duration ttl, Supplier<T> loader) {
    String lockKey = "lock:" + key;
    Boolean ok = rt.opsForValue().setIfAbsent(lockKey, "1", Duration.ofSeconds(5));
    if (Boolean.TRUE.equals(ok)) {
      try { return loader.get(); }
      finally { rt.delete(lockKey); }
    }
    // 잠금자가 채우는 동안 스테일 허용 or 백오프
    try { Thread.sleep(50); } catch (InterruptedException ignored) {}
    return null; // 호출 측에서 재시도/스테일 응답
  }
}
```

### A-6. 직렬화 포맷 & 크기
- 기본 `JSON`(가시성/호환). 성능이 매우 중요한 경로는 **Smile/CBOR** 또는 **Kryo/SMILE** 같은 바이너리 고려.  
- **대형 값(>50KB)**: 캐시보단 **오브젝트 스토리지**에 저장하고 **짧은 메타 캐시**.

### A-7. Redis 운영 (단일/클러스터/센티널)
- **클러스터**: 핫키 분산 위해 키 해시태그 `{}` 사용(멀티키 연산은 같은 슬롯 필요).  
- **만료 정책**: `volatile-lru` 권장(만료 있는 키만 LRU).  
- **MONITOR 금지**(운영 CPU 폭발), 대신 **SLOWLOG**/latency graph.  
- **레플리카 지연** 주의: 강한 일관 필요시 **master-only read** 또는 **WAIT**.

---

## B. 1차/2차 캐시, 쿼리 최적화

### B-1. 1차 캐시(영속성 컨텍스트)
- 트랜잭션 내 같은 엔티티 **한 번만 SELECT**.  
- **주의**: 긴 트랜잭션/대량 엔티티 로딩은 1차 캐시가 **메모리 폭증** 유발 → batch 처리(청크)·`clear()`.

### B-2. 2차 캐시(Second-Level) — 언제?
- **거의 변하지 않는 엔티티**(코드 테이블, 카탈로그),  
- **ID로 자주 조회**, **관계가 단순**할 때 효과적.

#### 설정(예: Ehcache/Redis 2LC)
```kotlin
implementation("org.hibernate.orm:hibernate-jcache")
implementation("org.ehcache:ehcache") // or redis 2lc provider
```
```yaml
spring:
  jpa:
    properties:
      hibernate:
        cache.use_second_level_cache: true
        cache.use_query_cache: true
        cache.region.factory_class: jcache
        javax.cache.provider: org.ehcache.jsr107.EhcacheCachingProvider
```
- **Region별 TTL**로 스테일 최소화.  
- **Query Cache**는 파라미터/스칼라 쿼리 중심, 결과 집합 캐시. **변경 전파가 어렵다** → 신중히.

> 2LC는 **쓰기 빈번**·**관계 복잡** 도메인에서는 이득이 적거나 역효과.  
> “핫 조회 + 거의 불변”에만 켠다.

### B-3. N+1 탐지 & 제거
- **증상**: `SELECT * FROM order` 뒤 `SELECT * FROM order_line where order_id=?`가 N번.  
- 해결:
  1) **`fetch join`**(필요 컬렉션/단일 연관만)  
  2) **엔티티 그래프**(`@NamedEntityGraph`)  
  3) **DTO 프로젝션**(정확히 필요한 필드만)  
  4) **배치 페치**(`hibernate.default_batch_fetch_size: 100`) — 연관 로딩 시 IN절로 묶음

```yaml
spring.jpa.properties.hibernate.default_batch_fetch_size: 100
```
```java
@EntityGraph(attributePaths = {"lines"})
List<Order> findTop100ByCustomerId(String cid);
```
```java
@Query("select new com.acme.api.OrderDto(o.id, o.total, c.name) " +
       "from Order o join o.customer c where o.id=:id")
OrderDto findView(@Param("id") String id);
```

### B-4. 프로젝션 우선전략
- **읽기 API**는 **엔티티가 아닌 DTO**로 직접 조회.  
- 이점: 불필요한 지연로딩·프록시 제거, **직렬화 비용↓**.

### B-5. 인덱스/쿼리 계획
- 쿼리 작성 시 WHERE에 쓰는 열 **인덱스**.  
- 조인 방향/순서, 카디널리티 확인(실행계획).  
- 부분 인덱스(조건부), **커버링 인덱스**(필드 포함)로 랜덤 I/O 축소.

---

## C. 쓰기/읽기 **배치화** & 페치 전략

### C-1. Hibernate JDBC Batch(쓰기)
```yaml
spring.jpa.properties:
  hibernate.jdbc.batch_size: 100        # INSERT/UPDATE 묶음
  hibernate.order_inserts: true
  hibernate.order_updates: true
  hibernate.jdbc.batch_versioned_data: true
```
- 엔티티 `@GeneratedValue(strategy = IDENTITY)`는 **배치 비효율**(DB가 PK 직후 반환) → **SEQUENCE**나 **애플리케이션 키**를 고려.  
- **flush/clear 주기**: 대량 처리 시 `batch`마다 `flush(); clear();`.

```java
for (int i=0; i<items.size(); i++) {
  em.persist(items.get(i));
  if (i%100==0) { em.flush(); em.clear(); }
}
```

### C-2. 읽기 대량 처리(스트리밍/청크)
- **스크롤/스트림**(Hibernate ScrollableResults, Spring Data `Stream<T>`).  
- 트랜잭션 read-only + 페치 사이즈 지정(드라이버).

```java
@QueryHints(@QueryHint(name = org.hibernate.jpa.HibernateHints.HINT_FETCH_SIZE, value = "500"))
@Query("select o from Order o where o.createdAt >= :from")
Stream<Order> streamFrom(@Param("from") Instant from);
```

### C-3. 페치 전략 가이드
- 연관 기본: **LAZY**.  
- **즉시(EAGER)**는 DTO 경로에서 **직접 조인**으로 대체.  
- 컬렉션 **fetch join 남발 금지**(중복·카디널리티 폭발) → **페이징 불가** 문제.

---

## D. 커넥션 풀(HikariCP) 튜닝

### D-1. 핵심 파라미터
```yaml
spring.datasource.hikari:
  maximum-pool-size: 40         # CPU/쿼리패턴/DB 커넥션 한도로 결정
  minimum-idle: 8
  connection-timeout: 2000      # ms: 커넥션 빌려오기 대기 한도
  validation-timeout: 1000
  idle-timeout: 30000
  max-lifetime: 1800000         # 30m < DB wait_timeout
  keepalive-time: 0             # 연결 유지 필요시 30s~ (DB/네트워크 상황)
  leak-detection-threshold: 60000
```

#### 사이징 경험칙
- **웹 동시 처리 스레드 수** ≤ **DB 풀** ≤ **DB 허용 연결**  
- CPU 코어·쿼리 지연을 고려한 대략치:  
  `maxPool ≈ (웹스레드 × 평균 동시 DB 호울드 비율)`  
  보수적으로 시작(예: 20~40) → 대시보드로 튜닝

**지표**
- `hikaricp_connections_active / hikaricp_connections_max`(>0.9 경고)  
- `hikaricp_connections_timeout_total`(타임아웃 발생)  
- DB side wait/lock

### D-2. 커넥션 릴리즈 & 트랜잭션 경계
- **트랜잭션 = 커넥션 점유** → 경계 최소화.  
- 외부 API 호출/파일 I/O **트랜잭션 밖**으로 이동.

---

## E. GC & JVM 튜닝 (Java 21)

### E-1. GC 선택
- **G1GC(기본)**: 안정/범용  
- **ZGC**: 저지연(대용량 힙, p99 pause 수 ms) — 힙이 크고 지연 민감할 때

### E-2. 추천 플래그(컨테이너)
```
-XX:+UseG1GC
-XX:MaxRAMPercentage=70
-XX:InitialRAMPercentage=25
-XX:+AlwaysActAsServerClassMachine
-XX:+UseStringDeduplication
-Dfile.encoding=UTF-8
-Duser.timezone=Asia/Seoul
```
**관측**
- `jvm.gc.pause`(p95/99), `jvm.memory.used{area="heap"}`  
- Old Gen 상승 + GC pause 증가는 **메모리 핫스팟**(캐시 과대/대형 객체/버퍼 누수) 신호

### E-3. 힙 덤프/분석
```
jcmd <pid> GC.heap_info
jcmd <pid> GC.heap_dump /tmp/heap.hprof
```
- 대형 컬렉션·캐시·버퍼 식별 → 캐시 한도/TTL/에비션 재설계.

---

## F. 스레드 풀(톰캣·@Async·스케줄러)

### F-1. 톰캣(NIO) 스레드
```yaml
server.tomcat.threads.max: 200
server.tomcat.threads.min-spare: 20
server.tomcat.mbeanregistry.enabled: true
```
- DB 풀과 **균형**: DB가 20이면 톰캣 400은 과도.  
- 메트릭: `tomcat_threads_busy / tomcat_threads_config_max`.

### F-2. @Async 전용 풀(업무별 분리)
```java
@Configuration
public class ExecutorConfig {
  @Bean("ioPool")
  public ThreadPoolTaskExecutor ioPool() {
    var ex = new ThreadPoolTaskExecutor();
    ex.setCorePoolSize(32); ex.setMaxPoolSize(64);
    ex.setQueueCapacity(1000);
    ex.setThreadNamePrefix("io-");
    ex.initialize(); return ex;
  }
}
```
- **업무별 풀**로 **폭주 격리**(PDF 변환·외부 API 등).  
- 큐 무한대 금지; `RejectedExecutionHandler` 정책 검토.

### F-3. 스케줄러
- **크론/고정 지연** 작업은 **전용 스케줄 풀**.  
- 장시간 배치 → 스케줄러 풀 고갈 방지.

---

## G. 측정-실험-검증 사이클 (SRE 루틴)

### G-1. 기본 대시보드(필수)
- API: QPS, p50/p95/p99, 에러율  
- DB: Hikari active/max, timeout, 슬로우 쿼리  
- 캐시: Redis ops/sec, hit ratio, latency, evicted keys  
- JVM: heap/oldgen, GC pause  
- 스레드: tomcat busy, executor queue size

### G-2. 부하(k6) 스모크(2~5분)
- 목표: p95<400ms, 에러율<1%  
- 시나리오: “핫 조회 + 캐시 미스/히트”, “대량 쓰기 배치”, “PG/외부 API 지연”

### G-3. 튜닝 순서 제안
1) **쿼리/인덱스/프로젝션** →  
2) **배치 크기/페치 전략**(N+1 제거) →  
3) **Spring Cache/Redis** 도입 →  
4) **Hikari/스레드풀** 균형 →  
5) **GC/힙** →  
6) **아키텍처 변경**(CQRS/비동기/파티셔닝)

---

## H. 실전 레시피 모음

### H-1. “상품상세” 핫경로 캐시
- 키: `productById:{id}` / TTL 30분  
- 쓰기: `updateProduct()`에서 `@CacheEvict` & 목록 캐시 전체 파기  
- 지표: 캐시 히트율(> 90%), Redis p95 < 2ms

### H-2. “주문목록” 읽기 최적화
- 엔티티 대신 **DTO 프로젝션** + **커버링 인덱스**  
- 페이지네이션 시 `keyset pagination` 고려(특히 무한 스크롤)

### H-3. “문의/공지” 거의 불변 2LC
- `@Cacheable` + **2차 캐시 region** TTL 길게  
- 배포 시 전체 무효화(버전 prefix) 또는 이벤트 기반

### H-4. “정산 배치” 대량 쓰기
- `hibernate.jdbc.batch_size: 100`  
- `flush/clear` 주기 100~500  
- IDENTITY → SEQUENCE로 변경 검토  
- **에러가 섞여도** 나머지 진행: Spring Batch `faultTolerant().skip(...)`

---

## I. 체크리스트(운영용)

**캐시**
- [ ] 캐시 대상/TTL/무효화 규칙 문서화  
- [ ] 핫키/스탬피드 보호(락/조기만료)  
- [ ] Redis 모니터링(SLOWLOG, evicted_keys)

**JPA**
- [ ] N+1 테스트(샘플 시나리오) 자동화  
- [ ] DTO 프로젝션 우선, fetch join 절제  
- [ ] `default_batch_fetch_size` 설정

**배치**
- [ ] `hibernate.jdbc.batch_size` & `order_inserts/updates`  
- [ ] 대량 처리 flush/clear 청크 크기 결정  
- [ ] 인덱스/제약 영향 시간대 고려

**풀/GC**
- [ ] Hikari active/max < 0.9, timeout=0  
- [ ] 톰캣 busy/max < 0.8  
- [ ] GC pause p95 예산 내(예: <200ms)

**측정**
- [ ] SLO 대시보드(p95/에러율)  
- [ ] k6 스모크 CI 포함  
- [ ] 변경 전/후 비교 로그(개선 로그)

---

## J. 트러블슈팅 FAQ

**Q1. 캐시가 있는데도 느려요.**  
- 히트율 낮음 → TTL·키 설계 재검토(사용자별 키 폭증?)  
- Redis 네트워크/CPU → 파이프라이닝/연결 풀·멀티인스턴스  
- 캐시 값 과대 → 압축/분할·요약(메타만 캐시)

**Q2. N+1 제거했는데 페이지가 깨져요.**  
- `fetch join` + 페이징은 위험(중복/row 폭발) → DTO 쿼리 + DISTINCT or keyset

**Q3. Hikari timeout 발생.**  
- DB 오래 걸리는 쿼리/락 확인(슬로우로그/pg_stat_activity)  
- 톰캣 과대 → 풀 균형 재조정  
- 트랜잭션 경계 축소

**Q4. GC가 자주 멈춰요.**  
- 대형 객체(수 MB) 빈번 생성 → 버퍼 재사용 / 스트리밍  
- 캐시 과대(힙 압박) → TTL/용량 제한

---

## K. 한 장 요약

- **읽기 최적화**는 **DTO+인덱스**가 1순위, 그 다음이 **캐시**다.  
- **쓰기 최적화**는 **JDBC 배치**와 **flush/clear**가 핵심.  
- **N+1**은 `fetch join`·엔티티 그래프·`default_batch_fetch_size`로 제거하되, **페이징+컬렉션** 조합을 경계.  
- **Hikari/톰캣**은 서로 **균형**이 중요, **트랜잭션 경계**를 짧게.  
- **GC/힙**은 지표로 판단하고 과한 튜닝보다 **메모리 핫스팟 제거**가 우선.  
- 모든 변경은 **대시보드와 부하 스모크**로 **수치로 검증**한다.