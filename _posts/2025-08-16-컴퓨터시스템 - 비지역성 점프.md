---
layout: post
title: 컴퓨터시스템 - 비지역성 점프
date: 2025-08-16 18:20:23 +0900
category: 컴퓨터시스템
---
# 비지역성 점프(Nonlocal Jump) — `setjmp`/`longjmp`·`sigsetjmp`/`siglongjmp`의 원리, 안전한 패턴, 성능·이식성·신호 연계

## 1. 개요 — “호출 스택을 건너뛰어 되돌아간다”

- **비지역성 점프(Nonlocal Jump)**: 현재 함수의 정적 스코프를 벗어나 **호출자(혹은 상위 콜 스택)** 위치로 **즉시 이동**.
- C 표준 인터페이스:
  ```c
  #include <setjmp.h>
  int  setjmp(jmp_buf env);          // 매크로일 수 있음
  void longjmp(jmp_buf env, int val);
  ```
  - `setjmp(env)`: **현재 실행 환경(레지스터 집합, 스택 포인터, 복귀 주소 등)** 을 `env`에 저장하고 **0**을 반환.
  - `longjmp(env, val)`: 저장된 환경으로 복귀. `setjmp`가 **다시** 반환되며 그 값은 **(val==0? 1 : val)** 이 된다.

> **핵심 직관**
> `setjmp`는 “**복귀 지점**을 스냅샷으로 저장”, `longjmp`는 그 지점으로 “**스택/레지스터 상태를 롤백**”한다.

---

## 2. 작동 원리 — 무엇을 저장/복원하나?

- `jmp_buf`는 **구현 의존의 불투명 타입**(아키텍처/라이브러리마다 다름). 보통 다음을 포함:
  - **SP**(스택 포인터), **PC**(프로그램 카운터, 복귀 주소), **callee-saved 레지스터** 묶음
  - (POSIX의 `sigsetjmp(env, savesigs)`: `savesigs!=0`이면 **시그널 마스크**까지 저장)
- `longjmp`는 해당 레지스터와 스택 포인터를 **그때 시점**으로 되돌리고, 제어를 `setjmp` “다음 문장”으로 점프시킨다.
- **스택 프레임**은 물리적으로 “실행”을 통해 사라지지 않지만, **SP 복원**으로 사실상 **버려진 상태**가 된다(스택 언와인딩 코드가 실행되지 않음).

> **중요**: `setjmp`를 호출한 **함수의 활성 수명(스택 프레임)** 이 끝난 후(= 그 함수가 이미 반환된 뒤) 해당 `env`로 `longjmp` 하는 것은 **정의되지 않은 동작(UB)** 이다.

---

## 3. 지역 변수와 최적화 — 왜 `volatile`이 필요한가?

- C 표준은 다음을 보장한다:
  - `longjmp` 이후 `setjmp` 호출 스코프에 있던 **`volatile`로 선언된 자동 변수**와 **수정되지 않은 자동 변수**는 **정의된 값**을 가진다.
  - `volatile`이 아니고, `setjmp` 이후 **값이 변경된 자동 변수**의 값은 **정의되지 않음(Indeterminate)**.
- 이유: 컴파일러는 `setjmp` 이후 지역 변수를 **레지스터에 보관**하거나 **재배치/삭제**할 수 있기 때문이다.

### 예 — 잘못된 코드(UB) vs 올바른 코드
```c
#include <setjmp.h>
#include <stdio.h>

jmp_buf env;
void f(void){
    int x = 0;                 // ← volatile 아님
    if (setjmp(env) == 0) {
        x = 123;               // setjmp 이후 변경
        /* ... 깊은 호출들 ... */
        longjmp(env, 1);       // 복귀
    } else {
        printf("%d\n", x);     // UB: x 값이 불명
    }
}
```
```c
#include <setjmp.h>
#include <stdio.h>

jmp_buf env;
void g(void){
    volatile int x = 0;        // ← volatile로 정의
    if (setjmp(env) == 0) {
        x = 123;
        /* ... */
        longjmp(env, 1);
    } else {
        printf("%d\n", x);     // 123이 보장
    }
}
```

> **규칙**: `setjmp`와 `longjmp` 사이에서 **읽을 지역 자동 변수**는 `volatile`로 선언하거나, 값을 다시 계산/로드하라.

---

## 4. 리소스와 언와인딩 — 파일/락/메모리의 정리는 누가?

- `longjmp`는 **정상적인 스코프 종료 코드**(예: `return` 경로, `goto cleanup`, `__attribute__((cleanup))`, C++의 소멸자)를 **건너뛰고** 돌아온다.
  → **파일 미닫힘, 락 해제, 힙 메모리 free 등 “정리 코드”가 실행되지 않을 수 있음**.
- **대응 전략**(C에서 예외/RAII가 없음을 보완):
  1) **집중 정리 지점** 패턴: 모든 함수가 실패 시 **한 곳으로 `goto`** 하여 정리(비지역 점프 **이전**에 호출)
  2) **핸들 관리 구조체** + **전역/스태틱 정리 함수**: `longjmp` 직후 상위에서 정리 루틴을 **명시적 호출**
  3) **락/FD 가드 매크로** 대신, **unlock/free** 를 **longjmp 전**에 보장(또는 longjmp 금지 구간)

> **GCC `__attribute__((cleanup))` 주의**: 이 cleanup 훅은 **longjmp로는 호출되지 않는다**(명세적으로 비지역 점프에 의해 스코프가 종료되는 경우 호출 보장 X).

---

## 5. 신호와 함께 쓰기 — `sigsetjmp`/`siglongjmp`

POSIX는 신호 마스크까지 저장/복원 가능한 인터페이스를 제공한다:
```c
#include <setjmp.h>
int  sigsetjmp(sigjmp_buf env, int savesigs);
void siglongjmp(sigjmp_buf env, int val);
```
- `savesigs!=0` → `sigsetjmp`가 **현재 스레드의 시그널 마스크**까지 저장, `siglongjmp`가 복원
- **신호 처리기에서의 점프**는 아래 조건을 만족해야 안전:
  - 점프 대상 `sigsetjmp`는 **같은 스레드**에서 설정
  - 핸들러에서는 **async-signal-safe 함수만** 사용 (POSIX 목록; `write`, `_exit` 등. **`printf`는 금지**)

### 안전한 타임아웃(알람) 예제
```c
#define _POSIX_C_SOURCE 200809L
#include <signal.h>
#include <setjmp.h>
#include <unistd.h>
#include <errno.h>

static sigjmp_buf env;

static void on_alarm(int signo){
    (void)signo;
    siglongjmp(env, 1);   // async-signal-safe
}

int do_work_with_timeout(unsigned seconds){
    struct sigaction sa = {0};
    sa.sa_handler = on_alarm;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;       // 재시작 가능한 호출은 자동 재시작
    sigaction(SIGALRM, &sa, NULL);

    if (sigsetjmp(env, /*savesigs=*/1) == 0) {
        alarm(seconds);
        /* 차단/블로킹 I/O 또는 긴 계산 ... */
        pause();                    // 데모용: 신호 대기
        alarm(0);
        return 0;
    } else {
        alarm(0);
        errno = ETIMEDOUT;
        return -1;                  // 타임아웃 경로
    }
}
```
> 기존에 흔히 보이는 **핸들러에서 `printf`** 는 **안전하지 않다**. 반드시 `write(2)` 같은 **async-signal-safe** 함수만 쓰자.

---

## 6. 실전 패턴 ① — “예외 비슷하게” 에러 탈출

### 간단 템플릿
```c
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    jmp_buf env;
    int     err;
} TryCtx;

#define TRY(ctx)     if (((ctx).err = setjmp((ctx).env)) == 0)
#define THROW(ctx,e) do { (ctx).err = (e); longjmp((ctx).env, (e)); } while(0)
#define CATCH(ctx)   else
#define ERRNO(ctx)   ((ctx).err)

int may_fail(int x){
    if (x==0) return 7;
    return -1; // 실패로 가정
}

int main(void){
    TryCtx ctx = { .err = 0 };
    TRY(ctx) {
        int v = may_fail(1);
        if (v < 0) THROW(ctx, 1234);
        printf("ok: %d\n", v);
    } CATCH(ctx) {
        printf("caught err=%d\n", ERRNO(ctx));
        // 필요하면 여기서 정리
    }
}
```
**주의**: 이 방식은 **정리 코드 우회**의 위험을 내재한다. **정리 로직을 CATCH 블록** 또는 `THROW` 전에 항상 수행/보장해야 한다.

---

## 7. 실전 패턴 ② — 파서/인터프리터의 빠른 실패 탈출

깊은 재귀/중첩 함수에서 에러 시 **상위 루프**로 즉시 탈출하는 데 유용.

```c
typedef struct {
    const char* p; // 입력 포인터
    jmp_buf env;
} Parser;

static void expect(Parser* ps, char ch){
    if (*ps->p != ch) longjmp(ps->env, 1);
    ++ps->p;
}

int parse_expr(Parser* ps){
    if (setjmp(ps->env) != 0) {
        // 에러 복구 지점
        return -1;
    }
    // 예: '(' expr ')'
    expect(ps, '(');
    // ... expr ...
    expect(ps, ')');
    return 0;
}
```

---

## 8. 스레드·FFI·플랫폼 이식성

- **스레드**: `longjmp`는 **같은 스레드 내부**의 `setjmp` 환경으로만 점프해야 한다. **서로 다른 스레드로 점프는 UB**.
- **Windows/MSVC**:
  - `setjmp`/`longjmp` 제공. `setjmp`가 **신호 마스크를 다루지 않음**(POSIX `sigsetjmp`와 다름).
  - `__try/__except`(SEH)는 **OS 예외 프레임워크**로, C의 `setjmp/longjmp`와는 별개.
- **복사 금지**: `jmp_buf`/`sigjmp_buf`는 **불투명**. **memcpy/값 복사나 다른 저장 형태로 이동**은 이식성 보장 없음.
- **ucontext 계열**(`getcontext`/`makecontext`/`swapcontext`)은 **POSIX에서 비권장/폐기 예정**. 코루틴/스케줄링 목적이면 **`ucontext` 대신 현대 라이브러리(예: Boost.Context, user-level threads)** 를 고려.

---

## 9. 성능 관점 — “빠를까?”

- **`setjmp` 비용**: 레지스터/스택 포인터 저장 → 작지만 무시할 수는 없음(핫패스에서 남용 금지).
- **`longjmp` 비용**: TLB/캐시 관점에서 **스택 프레임 대량 건너뜀** → 보통 **예외적 경로**로 한정하면 영향 미미.
- **장점**: C++ 예외보다 구현이 단순하고, tlab/unwind 테이블이 필요 없다.
  **단점**: **정리/언와인딩 미실행**으로 **자원 누수·교착** 위험.

---

## 10. 안전 가이드 — 체크리스트

- [ ] `longjmp` **대상 스코프가 유효**한가? (해당 함수가 아직 반환 전)
- [ ] 읽을 지역 자동 변수는 **`volatile`** 로 선언했는가?
- [ ] **리소스 정리**는 `longjmp` **전** 또는 **복귀 직후** 반드시 수행되는가?
- [ ] 신호 핸들러 사용 시 **`sigsetjmp/siglongjmp`** 를 쓰고 **async-signal-safe** 규칙을 지키는가?
- [ ] **락/뮤텍스**를 잡은 상태에서 `longjmp` 하지 않는가? (잠글→해제 쌍 보장 필요)
- [ ] **스레드 경계/FFI 경계**를 건너 `longjmp` 하지 않는가?
- [ ] `longjmp(env, 0)`은 **1로 변환**됨을 이해하고 있는가?

---

## 11. 신호·스택 오버플로우·대체 스택(`sigaltstack`) 응용 메모

- **스택 오버플로우(SIGSEGV)** 상황에서 **핸들러→`siglongjmp`** 로 복귀하고 싶다면,
  - 핸들러 자체는 **대체 시그널 스택**(`sigaltstack`)에 올려야 **핸들러 실행 스택 공간**을 확보 가능.
  - 그러나 **오염된 스택**으로 돌아가 계속 실행하는 것은 위험. 일반적으로 **진단 후 종료**가 권장.

---

## 12. 예제 모음 — 올바른/부적절 사례 비교

### 12.1 간단 에러 탈출 (정리 보장 포함)
```c
#include <setjmp.h>
#include <stdio.h>

typedef struct { FILE* fp; jmp_buf env; } Ctx;

int work(Ctx* c){
    c->fp = fopen("data.bin","rb");
    if(!c->fp) return -1;
    if (setjmp(c->env) == 0) {
        // ... 읽기 중 오류 발생 가정 ...
        longjmp(c->env, 123);
    } else {
        // 복귀 후 정리 지점
        if (c->fp) { fclose(c->fp); c->fp=NULL; }
        return -1;
    }
}

int main(void){
    Ctx c = {0};
    int r = work(&c);
    // 여기서 추가 정리/로깅도 가능
    return r;
}
```

### 12.2 **나쁜** 예 — 락/리소스를 쥔 채 점프
```c
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
jmp_buf env;
void bad(void){
    pthread_mutex_lock(&m);
    // ... 임계구역 ...
    longjmp(env, 1);            // 잠금 해제 안 됨 → 교착 위험
    pthread_mutex_unlock(&m);
}
```
**대응**: `longjmp` 전에 반드시 **unlock**(또는 임계구역 밖에서만 점프).
pthread의 **cleanup 핸들러**(`pthread_cleanup_push/pop`)는 **스레드 취소**용이며, **longjmp에는 호출되지 않음**.

### 12.3 신호 마스크 복원(타임아웃 루프)
```c
#define _POSIX_C_SOURCE 200809L
#include <signal.h>
#include <setjmp.h>
#include <unistd.h>
#include <stdio.h>

static sigjmp_buf env;
static void handler(int signo){ (void)signo; siglongjmp(env, 1); }

int main(void){
    struct sigaction sa = { .sa_handler = handler };
    sigemptyset(&sa.sa_mask);
    sigaction(SIGALRM, &sa, NULL);

    for (int i=0;i<3;i++) {
        if (sigsetjmp(env, 1) == 0) {
            alarm(1);
            pause();
            alarm(0);
            puts("no timeout");
        } else {
            alarm(0);
            puts("timeout!");
        }
    }
}
```

---

## 13. C++과의 경계 — 예외/RAII vs `longjmp`

- C++ 코드 경로에서 `longjmp`는 **스택 언와인딩(소멸자 호출)** 을 **건너뛴다** → RAII가 깨짐.
  **규칙**: C++에서는 `throw`/`catch`를 쓰고, `longjmp` 사용은 **C API 경계**(FFI)에서만 제한적으로.
- 혼용 시:
  - `extern "C"`로 C API 경계 명확화
  - C++ 쪽에서 **모든 자원을 RAII로 관리**하고, C 쪽에서 **`longjmp` 하지 않도록** 설계(또는 **단일 진입점**으로만 점프)

---

## 14. 플랫폼 차이(요약)

| 항목 | POSIX(glibc 등) | Windows/MSVC |
|---|---|---|
| 신호 마스크 저장 | `sigsetjmp(env,1)` 지원 | 없음(`setjmp`는 마스크 비관리) |
| 비동기 안전 | 핸들러→`siglongjmp` + async-signal-safe 준수 | Win32 신호 모델 상이 |
| 구조적 예외 | 별도(없음) | SEH: `__try/__except` |
| 이식성 권장 | `sigsetjmp/siglongjmp` 사용 | 순수 C라면 `setjmp/longjmp`만 |

---

## 15. 요약 — 안전 사용의 7원칙

1. **같은 스레드·유효 스코프**로만 점프하라.
2. `longjmp` 후 읽을 **자동 변수는 `volatile`** 로.
3. **정리 로직을 우회하지 말라**: 점프 전 또는 복귀 직후 반드시 정리.
4. **락/FD/메모리**를 쥔 채 점프 금지.
5. 신호와 함께라면 **`sigsetjmp/siglongjmp` + async-signal-safe**.
6. C++ 경로에서는 **예외/RAII** 를 쓰고 `longjmp`는 **C 경계 국한**.
7. `jmp_buf`를 **복사·이동**하지 말고, **오래 보관**하지 말라(스코프 생명 보장).

---

## 16. 한 줄 결론

`setjmp`/`longjmp`는 C에서 **가벼운 “비상탈출 장치”** 다.
하지만 **스택 언와인딩이 없다**는 사실을 잊으면 **자원 누수·교착·UB** 로 곧장 연결된다.
**스코프 유효성·`volatile`·정리 보장·신호 안전**의 네 축만 지키면,
파서·타임아웃·깊은 실패 경로에서 **깨끗하고 빠른 탈출**을 구현할 수 있다.
