---
layout: post
title: 파이썬 심화 - 클래스와 객체 (4)
date: 2025-11-30 18:25:23 +0900
category: 파이썬 심화
---
# 클래스와 객체 (4)

## 데이터 모델과 타입 시스템 구현

파이썬의 데이터 모델은 객체가 어떻게 동작하는지를 정의하는 일련의 프로토콜입니다. 특수 메서드(던더 메서드)를 구현함으로써 우리만의 타입 시스템을 만들 수 있습니다.

### 기본 특수 메서드 구현

```python
def data_model_fundamentals():
    """데이터 모델의 기본 특수 메서드 구현"""
    
    print("=== 데이터 모델 기본 구현 ===")
    
    # 1. 기본적인 수학 연산자 구현
    class Vector2D:
        """2차원 벡터 클래스 - 기본 연산자 구현"""
        
        def __init__(self, x, y):
            self.x = x
            self.y = y
        
        # 문자열 표현
        def __repr__(self):
            return f"Vector2D({self.x}, {self.y})"
        
        def __str__(self):
            return f"({self.x}, {self.y})"
        
        # 산술 연산자
        def __add__(self, other):
            """덧셈 연산자 +"""
            if isinstance(other, Vector2D):
                return Vector2D(self.x + other.x, self.y + other.y)
            elif isinstance(other, (int, float)):
                return Vector2D(self.x + other, self.y + other)
            return NotImplemented
        
        def __sub__(self, other):
            """뺄셈 연산자 -"""
            if isinstance(other, Vector2D):
                return Vector2D(self.x - other.x, self.y - other.y)
            elif isinstance(other, (int, float)):
                return Vector2D(self.x - other, self.y - other)
            return NotImplemented
        
        def __mul__(self, other):
            """곱셈 연산자 * (스칼라 곱)"""
            if isinstance(other, (int, float)):
                return Vector2D(self.x * other, self.y * other)
            return NotImplemented
        
        def __rmul__(self, other):
            """오른쪽 곱셈 연산자"""
            return self.__mul__(other)
        
        def __truediv__(self, other):
            """나눗셈 연산자 /"""
            if isinstance(other, (int, float)):
                return Vector2D(self.x / other, self.y / other)
            return NotImplemented
        
        # 비교 연산자
        def __eq__(self, other):
            """등가 연산자 =="""
            if isinstance(other, Vector2D):
                return self.x == other.x and self.y == other.y
            return False
        
        def __abs__(self):
            """절대값 (벡터의 크기)"""
            import math
            return math.sqrt(self.x**2 + self.y**2)
        
        # 단항 연산자
        def __neg__(self):
            """단항 음수 연산자 -"""
            return Vector2D(-self.x, -self.y)
        
        def __pos__(self):
            """단항 양수 연산자 +"""
            return Vector2D(+self.x, +self.y)
        
        # 내장 함수 지원
        def __bool__(self):
            """bool() 함수 지원 (0 벡터는 False)"""
            return self.x != 0 or self.y != 0
        
        def __len__(self):
            """len() 함수 지원 (항상 2)"""
            return 2
        
        # 해시 가능하게 만들기
        def __hash__(self):
            return hash((self.x, self.y))
    
    print("1. 기본 연산자 구현:")
    
    v1 = Vector2D(3, 4)
    v2 = Vector2D(1, 2)
    
    print(f"  v1 = {v1}, v2 = {v2}")
    print(f"  v1 + v2 = {v1 + v2}")
    print(f"  v1 - v2 = {v1 - v2}")
    print(f"  v1 * 2 = {v1 * 2}")
    print(f"  3 * v1 = {3 * v1}")  # __rmul__ 호출
    print(f"  v1 / 2 = {v1 / 2}")
    print(f"  v1 == v2: {v1 == v2}")
    print(f"  -v1 = {-v1}")
    print(f"  abs(v1) = {abs(v1)}")
    print(f"  bool(v1): {bool(v1)}")
    print(f"  len(v1): {len(v1)}")
    
    # 2. 복합 대입 연산자
    class Accumulator:
        """복합 대입 연산자 구현 예제"""
        
        def __init__(self, value=0):
            self.value = value
        
        def __iadd__(self, other):
            """+= 연산자"""
            if isinstance(other, (int, float)):
                self.value += other
            elif isinstance(other, Accumulator):
                self.value += other.value
            else:
                raise TypeError(f"지원하지 않는 타입: {type(other)}")
            return self
        
        def __isub__(self, other):
            """-= 연산자"""
            if isinstance(other, (int, float)):
                self.value -= other
            elif isinstance(other, Accumulator):
                self.value -= other.value
            else:
                raise TypeError(f"지원하지 않는 타입: {type(other)}")
            return self
        
        def __imul__(self, other):
            """*= 연산자"""
            if isinstance(other, (int, float)):
                self.value *= other
            else:
                raise TypeError(f"지원하지 않는 타입: {type(other)}")
            return self
        
        def __str__(self):
            return f"Accumulator({self.value})"
    
    print("\n2. 복합 대입 연산자:")
    
    acc = Accumulator(10)
    print(f"  초기값: {acc}")
    
    acc += 5
    print(f"  += 5 후: {acc}")
    
    acc -= 3
    print(f"  -= 3 후: {acc}")
    
    acc *= 2
    print(f"  *= 2 후: {acc}")
    
    # 3. 호출 가능 객체 만들기
    class Polynomial:
        """다항식 클래스 - 호출 가능하게 구현"""
        
        def __init__(self, *coefficients):
            """계수들은 낮은 차수부터 높은 차수 순으로"""
            self.coefficients = coefficients
        
        def __call__(self, x):
            """함수처럼 호출 가능"""
            result = 0
            for power, coeff in enumerate(self.coefficients):
                result += coeff * (x ** power)
            return result
        
        def __repr__(self):
            terms = []
            for power, coeff in enumerate(self.coefficients):
                if coeff != 0:
                    if power == 0:
                        terms.append(str(coeff))
                    elif power == 1:
                        terms.append(f"{coeff}x")
                    else:
                        terms.append(f"{coeff}x^{power}")
            
            if not terms:
                return "0"
            
            return " + ".join(terms)
        
        def derivative(self):
            """도함수 계산"""
            if len(self.coefficients) <= 1:
                return Polynomial(0)
            
            new_coeffs = []
            for power, coeff in enumerate(self.coefficients[1:], 1):
                new_coeffs.append(coeff * power)
            
            return Polynomial(*new_coeffs)
    
    print("\n3. 호출 가능 객체:")
    
    p = Polynomial(2, -3, 1)  # x² - 3x + 2
    print(f"  다항식: {p}")
    print(f"  p(0) = {p(0)}")
    print(f"  p(1) = {p(1)}")
    print(f"  p(2) = {p(2)}")
    
    p_prime = p.derivative()
    print(f"  도함수: {p_prime}")
    print(f"  p'(1) = {p_prime(1)}")
    
    # 4. 컨텍스트 관리 프로토콜
    class Timer:
        """실행 시간 측정 컨텍스트 관리자"""
        
        def __init__(self, name="작업"):
            self.name = name
            self.start_time = None
            self.end_time = None
        
        def __enter__(self):
            self.start_time = time.time()
            print(f"  [{self.name}] 시작")
            return self
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            self.end_time = time.time()
            elapsed = self.end_time - self.start_time
            print(f"  [{self.name}] 종료 - 소요시간: {elapsed:.4f}초")
            
            if exc_type is not None:
                print(f"  예외 발생: {exc_type.__name__}")
        
        def elapsed(self):
            if self.start_time and self.end_time:
                return self.end_time - self.start_time
            elif self.start_time:
                return time.time() - self.start_time
            return 0.0
    
    print("\n4. 컨텍스트 관리자:")
    
    with Timer("데이터 처리") as timer:
        time.sleep(0.1)
        print("  데이터 처리 중...")
    
    print(f"  실제 소요시간: {timer.elapsed():.4f}초")

data_model_fundamentals()
```

### 고급 타입 시스템 구현

```python
def advanced_type_system():
    """고급 타입 시스템 구현"""
    
    print("\n=== 고급 타입 시스템 ===")
    
    # 1. 디스크립터 프로토콜을 이용한 타입 검사
    class TypedAttribute:
        """타입 검사 디스크립터"""
        
        def __init__(self, name, expected_type):
            self.name = name
            self.expected_type = expected_type
            self.private_name = f"_{name}"
        
        def __get__(self, instance, owner):
            if instance is None:
                return self
            return getattr(instance, self.private_name, None)
        
        def __set__(self, instance, value):
            if not isinstance(value, self.expected_type):
                raise TypeError(
                    f"'{self.name}'는 {self.expected_type.__name__} 타입이어야 합니다. "
                    f"받은 타입: {type(value).__name__}"
                )
            setattr(instance, self.private_name, value)
        
        def __delete__(self, instance):
            delattr(instance, self.private_name)
    
    class ValidatedAttribute(TypedAttribute):
        """타입 검사와 값 검증 디스크립터"""
        
        def __init__(self, name, expected_type, validator=None):
            super().__init__(name, expected_type)
            self.validator = validator
        
        def __set__(self, instance, value):
            # 타입 검사
            super().__set__(instance, value)
            
            # 값 검증
            if self.validator and not self.validator(value):
                raise ValueError(f"'{self.name}'의 값이 유효하지 않습니다: {value}")
    
    class Person:
        """타입 검사가 적용된 Person 클래스"""
        
        name = TypedAttribute("name", str)
        age = ValidatedAttribute("age", int, lambda x: 0 <= x <= 150)
        height = ValidatedAttribute("height", float, lambda x: x > 0)
        
        def __init__(self, name, age, height):
            self.name = name
            self.age = age
            self.height = height
        
        def __repr__(self):
            return f"Person(name={self.name!r}, age={self.age}, height={self.height})"
    
    print("1. 디스크립터 기반 타입 시스템:")
    
    try:
        person = Person("김철수", 30, 175.5)
        print(f"  유효한 데이터: {person}")
    except (TypeError, ValueError) as e:
        print(f"  오류: {e}")
    
    try:
        person2 = Person("이영희", -5, 160.0)  # 나이 유효성 실패
    except ValueError as e:
        print(f"  값 검증 실패: {e}")
    
    try:
        person3 = Person("박지원", 25, "180")  # 타입 오류
    except TypeError as e:
        print(f"  타입 검증 실패: {e}")
    
    # 2. 프로토콜 기반 타입 시스템
    from typing import Protocol, runtime_checkable
    
    @runtime_checkable
    class Drawable(Protocol):
        """그릴 수 있는 객체 프로토콜"""
        
        def draw(self) -> str:
            """객체를 그림으로 표현"""
            ...
        
        def area(self) -> float:
            """면적 계산"""
            ...
    
    @runtime_checkable
    class Scalable(Protocol):
        """크기 조절 가능한 객체 프로토콜"""
        
        def scale(self, factor: float) -> None:
            """크기 조절"""
            ...
    
    class Circle:
        """원 클래스 - Drawable과 Scalable 프로토콜 구현"""
        
        def __init__(self, radius: float):
            self.radius = radius
        
        def draw(self) -> str:
            return f"⚫ (반지름: {self.radius})"
        
        def area(self) -> float:
            import math
            return math.pi * self.radius ** 2
        
        def scale(self, factor: float) -> None:
            self.radius *= factor
        
        def __repr__(self):
            return f"Circle(radius={self.radius})"
    
    class Rectangle:
        """사각형 클래스 - Drawable 프로토콜만 구현"""
        
        def __init__(self, width: float, height: float):
            self.width = width
            self.height = height
        
        def draw(self) -> str:
            return f"▭ ({self.width}×{self.height})"
        
        def area(self) -> float:
            return self.width * self.height
        
        def __repr__(self):
            return f"Rectangle({self.width}, {self.height})"
    
    def process_shapes(shapes):
        """다양한 도형 처리"""
        print("  도형 처리:")
        for shape in shapes:
            print(f"    - {shape.draw()}")
            print(f"      면적: {shape.area():.2f}")
            
            # Scalable 프로토콜 확인
            if isinstance(shape, Scalable):
                print(f"      크기 조절 가능")
                shape.scale(1.5)
                print(f"      조절 후: {shape.draw()}")
            print()
    
    print("\n2. 프로토콜 기반 타입 시스템:")
    
    shapes = [
        Circle(5),
        Rectangle(4, 6),
        Circle(3)
    ]
    
    # 런타임 프로토콜 확인
    for shape in shapes:
        print(f"  {type(shape).__name__}:")
        print(f"    Drawable? {isinstance(shape, Drawable)}")
        print(f"    Scalable? {isinstance(shape, Scalable)}")
    
    process_shapes(shapes)
    
    # 3. 메타클래스를 이용한 타입 시스템
    print("\n3. 메타클래스 기반 타입 시스템:")
    
    class TypeCheckedMeta(type):
        """타입 검사 메타클래스"""
        
        def __new__(mcs, name, bases, namespace):
            # 클래스 생성 시 타입 힌트 기반 검증 코드 생성
            annotations = namespace.get('__annotations__', {})
            
            # 각 타입 힌트에 대해 디스크립터 추가
            for attr_name, attr_type in annotations.items():
                if attr_name in namespace:  # 이미 값이 있는 경우
                    value = namespace[attr_name]
                    if not isinstance(value, attr_type):
                        raise TypeError(
                            f"클래스 변수 '{attr_name}'의 타입이 일치하지 않습니다. "
                            f"기대: {attr_type.__name__}, 실제: {type(value).__name__}"
                        )
                else:
                    # 디스크립터 추가
                    namespace[attr_name] = TypedAttribute(attr_name, attr_type)
            
            return super().__new__(mcs, name, bases, namespace)
    
    class Product(metaclass=TypeCheckedMeta):
        """타입 검사 메타클래스를 사용하는 제품 클래스"""
        
        # 타입 힌트
        name: str
        price: float
        quantity: int
        
        def __init__(self, name: str, price: float, quantity: int):
            self.name = name
            self.price = price
            self.quantity = quantity
        
        def total_value(self) -> float:
            return self.price * self.quantity
        
        def __repr__(self):
            return f"Product(name={self.name!r}, price={self.price}, quantity={self.quantity})"
    
    try:
        product = Product("노트북", 1299.99, 10)
        print(f"  제품 생성 성공: {product}")
        print(f"  총 가치: ${product.total_value():.2f}")
    except TypeError as e:
        print(f"  타입 오류: {e}")
    
    # 잘못된 타입 시도
    try:
        product2 = Product("스마트폰", "999.99", 5)  # price가 문자열
    except TypeError as e:
        print(f"  타입 검사 실패: {e}")
    
    # 4. 완전한 타입 시스템 구현 예제
    print("\n4. 완전한 타입 시스템 구현:")
    
    class UnitSystem:
        """단위 시스템 기반 타입"""
        
        def __init__(self, base_unit):
            self.base_unit = base_unit
            self._registry = {}
        
        def register(self, unit_class):
            """단위 클래스 등록"""
            self._registry[unit_class.__name__] = unit_class
            return unit_class
        
        def create_converter(self, from_unit, to_unit):
            """단위 변환기 생성"""
            class UnitConverter:
                def __init__(self, value):
                    self.value = value
                
                def __getattr__(self, target_unit):
                    if target_unit in self._registry:
                        # 변환 로직
                        return self._registry[target_unit].from_base(
                            self._registry[from_unit].to_base(self.value)
                        )
                    raise AttributeError(f"알 수 없는 단위: {target_unit}")
            
            return UnitConverter
    
    class Meter:
        """미터 단위"""
        
        @classmethod
        def to_base(cls, value):
            return value
        
        @classmethod
        def from_base(cls, value):
            return value
        
        symbol = "m"
    
    class Kilometer:
        """킬로미터 단위"""
        
        @classmethod
        def to_base(cls, value):
            return value * 1000
        
        @classmethod
        def from_base(cls, value):
            return value / 1000
        
        symbol = "km"
    
    class Centimeter:
        """센티미터 단위"""
        
        @classmethod
        def to_base(cls, value):
            return value / 100
        
        @classmethod
        def from_base(cls, value):
            return value * 100
        
        symbol = "cm"
    
    # 단위 시스템 설정
    length_system = UnitSystem("meter")
    length_system.register(Meter)
    length_system.register(Kilometer)
    length_system.register(Centimeter)
    
    # 단위 변환기 사용
    Converter = length_system.create_converter("Meter", "Kilometer")
    
    distance = Converter(1000)  # 1000 미터
    print(f"  1000미터 = {distance.Kilometer:.2f}킬로미터")
    print(f"  1000미터 = {distance.Centimeter:.0f}센티미터")

advanced_type_system()
```

## 커스텀 컨테이너 구현

파이썬의 내장 컨테이너(list, dict, set 등)처럼 동작하는 사용자 정의 컨테이너를 구현할 수 있습니다.

### 기본 컨테이너 프로토콜

```python
def custom_container_implementation():
    """커스텀 컨테이너 구현"""
    
    print("\n=== 커스텀 컨테이너 구현 ===")
    
    # 1. 시퀀스 프로토콜 구현 (리스트 같은 컨테이너)
    class SortedList:
        """자동 정렬되는 리스트"""
        
        def __init__(self, iterable=None):
            self._data = []
            if iterable:
                self._data = sorted(iterable)
        
        def __len__(self):
            """len() 지원"""
            return len(self._data)
        
        def __getitem__(self, index):
            """인덱싱 지원"""
            if isinstance(index, slice):
                return SortedList(self._data[index])
            return self._data[index]
        
        def __setitem__(self, index, value):
            """항목 설정"""
            self._data[index] = value
            self._data.sort()
        
        def __delitem__(self, index):
            """항목 삭제"""
            del self._data[index]
        
        def __contains__(self, item):
            """in 연산자 지원"""
            return item in self._data
        
        def __iter__(self):
            """이터레이션 지원"""
            return iter(self._data)
        
        def __reversed__(self):
            """reversed() 지원"""
            return reversed(self._data)
        
        def __add__(self, other):
            """+ 연산자 지원"""
            if isinstance(other, SortedList):
                return SortedList(self._data + other._data)
            elif isinstance(other, (list, tuple)):
                return SortedList(self._data + list(other))
            return NotImplemented
        
        def __iadd__(self, other):
            """+= 연산자 지원"""
            if isinstance(other, SortedList):
                self._data.extend(other._data)
            elif isinstance(other, (list, tuple)):
                self._data.extend(other)
            else:
                return NotImplemented
            self._data.sort()
            return self
        
        def append(self, item):
            """항목 추가"""
            self._data.append(item)
            self._data.sort()
        
        def extend(self, iterable):
            """여러 항목 추가"""
            self._data.extend(iterable)
            self._data.sort()
        
        def insert(self, index, item):
            """항목 삽입"""
            self._data.insert(index, item)
            self._data.sort()
        
        def remove(self, item):
            """항목 제거"""
            self._data.remove(item)
        
        def pop(self, index=-1):
            """항목 꺼내기"""
            return self._data.pop(index)
        
        def clear(self):
            """모든 항목 제거"""
            self._data.clear()
        
        def index(self, item, start=0, end=None):
            """항목 위치 찾기"""
            if end is None:
                end = len(self._data)
            return self._data.index(item, start, end)
        
        def count(self, item):
            """항목 개수 세기"""
            return self._data.count(item)
        
        def __repr__(self):
            return f"SortedList({self._data})"
    
    print("1. 정렬 리스트 구현:")
    
    slist = SortedList([5, 1, 3, 2, 4])
    print(f"  초기값: {slist}")
    
    slist.append(0)
    print(f"  0 추가 후: {slist}")
    
    slist += [6, 7]
    print(f"  [6,7] 추가 후: {slist}")
    
    print(f"  길이: {len(slist)}")
    print(f"  첫 번째 항목: {slist[0]}")
    print(f"  마지막 항목: {slist[-1]}")
    print(f"  슬라이싱: {slist[1:4]}")
    print(f"  3이 있는가? {3 in slist}")
    print(f"  반복:")
    for item in slist[:3]:
        print(f"    - {item}")
    
    # 2. 매핑 프로토콜 구현 (딕셔너리 같은 컨테이너)
    class CaseInsensitiveDict:
        """대소문자를 구분하지 않는 딕셔너리"""
        
        def __init__(self, initial_dict=None):
            self._data = {}
            if initial_dict:
                for key, value in initial_dict.items():
                    self._normalized_key(key)[value] = value
        
        def _normalized_key(self, key):
            """키 정규화"""
            if isinstance(key, str):
                return key.lower()
            return key
        
        def __len__(self):
            return len(self._data)
        
        def __getitem__(self, key):
            normalized = self._normalized_key(key)
            return self._data[normalized]
        
        def __setitem__(self, key, value):
            normalized = self._normalized_key(key)
            self._data[normalized] = value
        
        def __delitem__(self, key):
            normalized = self._normalized_key(key)
            del self._data[normalized]
        
        def __contains__(self, key):
            normalized = self._normalized_key(key)
            return normalized in self._data
        
        def __iter__(self):
            return iter(self._data)
        
        def keys(self):
            """키 목록"""
            return self._data.keys()
        
        def values(self):
            """값 목록"""
            return self._data.values()
        
        def items(self):
            """(키, 값) 쌍 목록"""
            return self._data.items()
        
        def get(self, key, default=None):
            """안전한 값 조회"""
            normalized = self._normalized_key(key)
            return self._data.get(normalized, default)
        
        def pop(self, key, default=None):
            """항목 제거 및 반환"""
            normalized = self._normalized_key(key)
            return self._data.pop(normalized, default)
        
        def update(self, other_dict):
            """다른 딕셔너리로 업데이트"""
            for key, value in other_dict.items():
                self[key] = value
        
        def clear(self):
            """모든 항목 제거"""
            self._data.clear()
        
        def __repr__(self):
            return f"CaseInsensitiveDict({self._data})"
    
    print("\n2. 대소문자 구분 없는 딕셔너리:")
    
    cidict = CaseInsensitiveDict({"Name": "John", "Age": 30})
    print(f"  초기값: {cidict}")
    
    cidict["NAME"] = "Jane"  # 기존 키 덮어쓰기
    print(f"  NAME 설정 후: {cidict}")
    
    print(f"  name 조회: {cidict['name']}")
    print(f"  Name 조회: {cidict['Name']}")
    print(f"  NAME 조회: {cidict['NAME']}")
    
    print(f"  키 목록: {list(cidict.keys())}")
    print(f"  값 목록: {list(cidict.values())}")
    
    # 3. 셋 프로토콜 구현
    class OrderedSet:
        """순서가 유지되는 집합"""
        
        def __init__(self, iterable=None):
            self._data = []
            self._set = set()
            if iterable:
                for item in iterable:
                    self.add(item)
        
        def __len__(self):
            return len(self._data)
        
        def __contains__(self, item):
            return item in self._set
        
        def __iter__(self):
            return iter(self._data)
        
        def __reversed__(self):
            return reversed(self._data)
        
        def add(self, item):
            """항목 추가"""
            if item not in self._set:
                self._data.append(item)
                self._set.add(item)
        
        def discard(self, item):
            """항목 제거 (없어도 오류 안남)"""
            if item in self._set:
                self._data.remove(item)
                self._set.discard(item)
        
        def remove(self, item):
            """항목 제거 (없으면 오류)"""
            self._data.remove(item)
            self._set.remove(item)
        
        def pop(self):
            """마지막 항목 제거 및 반환"""
            item = self._data.pop()
            self._set.remove(item)
            return item
        
        def clear(self):
            """모든 항목 제거"""
            self._data.clear()
            self._set.clear()
        
        def update(self, iterable):
            """여러 항목 추가"""
            for item in iterable:
                self.add(item)
        
        # 집합 연산
        def __or__(self, other):
            """합집합 |"""
            result = OrderedSet(self)
            result.update(other)
            return result
        
        def __and__(self, other):
            """교집합 &"""
            result = OrderedSet()
            for item in self:
                if item in other:
                    result.add(item)
            return result
        
        def __sub__(self, other):
            """차집합 -"""
            result = OrderedSet()
            for item in self:
                if item not in other:
                    result.add(item)
            return result
        
        def __xor__(self, other):
            """대칭차집합 ^"""
            return (self | other) - (self & other)
        
        def __eq__(self, other):
            """집합 동등성 (순서 무관)"""
            if not isinstance(other, (OrderedSet, set)):
                return False
            return self._set == set(other)
        
        def __le__(self, other):
            """부분집합 ⊆"""
            return self._set <= set(other)
        
        def __lt__(self, other):
            """진부분집합 ⊂"""
            return self._set < set(other)
        
        def __ge__(self, other):
            """상위집합 ⊇"""
            return self._set >= set(other)
        
        def __gt__(self, other):
            """진상위집합 ⊃"""
            return self._set > set(other)
        
        def __repr__(self):
            return f"OrderedSet({self._data})"
    
    print("\n3. 순서가 유지되는 집합:")
    
    oset1 = OrderedSet([3, 1, 4, 1, 5, 9])
    oset2 = OrderedSet([1, 2, 3, 4, 5])
    
    print(f"  oset1: {oset1}")
    print(f"  oset2: {oset2}")
    
    print(f"  합집합: {oset1 | oset2}")
    print(f"  교집합: {oset1 & oset2}")
    print(f"  차집합: {oset1 - oset2}")
    print(f"  대칭차집합: {oset1 ^ oset2}")
    
    print(f"  oset1 ⊆ oset2: {oset1 <= oset2}")
    print(f"  oset1 == oset2: {oset1 == oset2}")
    
    # 순서 유지 확인
    print(f"  순서 유지:")
    for item in oset1:
        print(f"    - {item}")
    
    # 4. 복합 컨테이너 구현
    print("\n4. 복합 컨테이너 - 그래프 구조:")
    
    class Graph:
        """그래프 데이터 구조"""
        
        def __init__(self):
            self._adjacency_list = {}
        
        def __len__(self):
            """정점 개수"""
            return len(self._adjacency_list)
        
        def __contains__(self, vertex):
            """정점 존재 여부"""
            return vertex in self._adjacency_list
        
        def __iter__(self):
            """정점 순회"""
            return iter(self._adjacency_list)
        
        def __getitem__(self, vertex):
            """정점의 이웃 조회"""
            return self._adjacency_list.get(vertex, set())
        
        def add_vertex(self, vertex):
            """정점 추가"""
            if vertex not in self._adjacency_list:
                self._adjacency_list[vertex] = set()
        
        def add_edge(self, vertex1, vertex2, weight=1):
            """간선 추가"""
            self.add_vertex(vertex1)
            self.add_vertex(vertex2)
            self._adjacency_list[vertex1].add((vertex2, weight))
            self._adjacency_list[vertex2].add((vertex1, weight))  # 무방향 그래프
        
        def remove_vertex(self, vertex):
            """정점 제거"""
            if vertex in self._adjacency_list:
                # 다른 정점에서의 참조 제거
                for neighbor, _ in self._adjacency_list[vertex]:
                    self._adjacency_list[neighbor] = {
                        (n, w) for n, w in self._adjacency_list[neighbor]
                        if n != vertex
                    }
                del self._adjacency_list[vertex]
        
        def remove_edge(self, vertex1, vertex2):
            """간선 제거"""
            if vertex1 in self._adjacency_list and vertex2 in self._adjacency_list:
                self._adjacency_list[vertex1] = {
                    (n, w) for n, w in self._adjacency_list[vertex1]
                    if n != vertex2
                }
                self._adjacency_list[vertex2] = {
                    (n, w) for n, w in self._adjacency_list[vertex2]
                    if n != vertex1
                }
        
        def neighbors(self, vertex):
            """이웃 정점 조회"""
            return {n for n, _ in self._adjacency_list.get(vertex, set())}
        
        def edges(self):
            """모든 간선 조회"""
            edges = set()
            for vertex, neighbors in self._adjacency_list.items():
                for neighbor, weight in neighbors:
                    # 중복 제거 (무방향 그래프)
                    edge = tuple(sorted((vertex, neighbor)))
                    edges.add((edge[0], edge[1], weight))
            return edges
        
        def degree(self, vertex):
            """정점의 차수"""
            return len(self._adjacency_list.get(vertex, set()))
        
        def __repr__(self):
            return f"Graph({len(self)} vertices, {len(self.edges())} edges)"
    
    graph = Graph()
    graph.add_edge("A", "B", 4)
    graph.add_edge("A", "C", 2)
    graph.add_edge("B", "C", 1)
    graph.add_edge("B", "D", 5)
    graph.add_edge("C", "D", 8)
    graph.add_edge("C", "E", 10)
    graph.add_edge("D", "E", 2)
    
    print(f"  그래프: {graph}")
    print(f"  정점들: {list(graph)}")
    print(f"  A의 이웃: {list(graph['A'])}")
    print(f"  A의 차수: {graph.degree('A')}")
    
    print(f"  모든 간선:")
    for v1, v2, weight in graph.edges():
        print(f"    {v1} --{weight}-- {v2}")
    
    # DFS 탐색
    def dfs(graph, start):
        """깊이 우선 탐색"""
        visited = set()
        stack = [start]
        
        while stack:
            vertex = stack.pop()
            if vertex not in visited:
                visited.add(vertex)
                stack.extend(reversed(list(graph.neighbors(vertex) - visited)))
        
        return visited
    
    print(f"  DFS(A에서 시작): {dfs(graph, 'A')}")

custom_container_implementation()
```

### 고급 컨테이너 패턴

```python
def advanced_container_patterns():
    """고급 컨테이너 패턴"""
    
    print("\n=== 고급 컨테이너 패턴 ===")
    
    # 1. 지연 평가(Lazy Evaluation) 컨테이너
    class LazySequence:
        """지연 평가 시퀀스"""
        
        def __init__(self, generator_func, *args, **kwargs):
            self.generator_func = generator_func
            self.args = args
            self.kwargs = kwargs
            self._cache = []
            self._generator = None
            self._exhausted = False
        
        def _ensure_generator(self):
            """제너레이터 초기화"""
            if self._generator is None:
                self._generator = self.generator_func(*self.args, **self.kwargs)
        
        def __iter__(self):
            """이터레이터"""
            self._ensure_generator()
            
            # 캐시된 항목 yield
            for item in self._cache:
                yield item
            
            # 제너레이터에서 나머지 항목 yield
            for item in self._generator:
                self._cache.append(item)
                yield item
            
            self._exhausted = True
        
        def __getitem__(self, index):
            """인덱싱 지원"""
            if isinstance(index, slice):
                # 슬라이스는 리스트로 변환
                return list(self)[index]
            
            # 음수 인덱스 처리
            if index < 0:
                # 모든 항목을 메모리에 로드해야 함
                items = list(self)
                return items[index]
            
            # 캐시에 없는 항목은 제너레이터에서 가져옴
            while len(self._cache) <= index:
                self._ensure_generator()
                try:
                    item = next(self._generator)
                    self._cache.append(item)
                except StopIteration:
                    self._exhausted = True
                    raise IndexError(f"인덱스 {index}가 시퀀스 범위를 벗어났습니다")
            
            return self._cache[index]
        
        def __len__(self):
            """길이 (전체 시퀀스 평가 필요)"""
            if not self._exhausted:
                # 모든 항목 평가
                list(self)
            return len(self._cache)
        
        def __repr__(self):
            return f"LazySequence({self.generator_func.__name__})"
    
    def fibonacci_sequence(n=None):
        """피보나치 수열 생성기"""
        a, b = 0, 1
        count = 0
        while n is None or count < n:
            yield a
            a, b = b, a + b
            count += 1
    
    print("1. 지연 평가 시퀀스:")
    
    lazy_fib = LazySequence(fibonacci_sequence, 10)
    print(f"  피보나치 수열 (처음 5개): {[lazy_fib[i] for i in range(5)]}")
    print(f"  캐시 상태: {lazy_fib._cache}")
    
    # 추가 접근 시 캐시 사용
    print(f"  인덱스 7: {lazy_fib[7]}")
    print(f"  캐시 상태: {lazy_fib._cache}")
    
    print(f"  전체 시퀀스:")
    for i, val in enumerate(lazy_fib):
        print(f"    F{i} = {val}")
    
    # 2. 트랜잭셔널 컨테이너
    class TransactionalList:
        """트랜잭션을 지원하는 리스트"""
        
        def __init__(self, initial_data=None):
            self._data = list(initial_data) if initial_data else []
            self._transaction_stack = []
            self._in_transaction = False
        
        def begin_transaction(self):
            """트랜잭션 시작"""
            self._transaction_stack.append({
                'data': self._data.copy(),
                'operations': []
            })
            self._in_transaction = True
        
        def commit(self):
            """트랜잭션 커밋"""
            if not self._transaction_stack:
                raise RuntimeError("활성화된 트랜잭션이 없습니다")
            
            self._transaction_stack.pop()
            self._in_transaction = bool(self._transaction_stack)
        
        def rollback(self):
            """트랜잭션 롤백"""
            if not self._transaction_stack:
                raise RuntimeError("활성화된 트랜잭션이 없습니다")
            
            transaction = self._transaction_stack[-1]
            self._data = transaction['data'].copy()
            self._transaction_stack.pop()
            self._in_transaction = bool(self._transaction_stack)
        
        def __len__(self):
            return len(self._data)
        
        def __getitem__(self, index):
            return self._data[index]
        
        def __setitem__(self, index, value):
            old_value = self._data[index] if index < len(self._data) else None
            self._data[index] = value
            
            if self._in_transaction:
                self._transaction_stack[-1]['operations'].append(
                    ('setitem', index, old_value, value)
                )
        
        def __delitem__(self, index):
            old_value = self._data[index]
            del self._data[index]
            
            if self._in_transaction:
                self._transaction_stack[-1]['operations'].append(
                    ('delitem', index, old_value)
                )
        
        def append(self, value):
            self._data.append(value)
            
            if self._in_transaction:
                self._transaction_stack[-1]['operations'].append(
                    ('append', len(self._data) - 1, value)
                )
        
        def extend(self, iterable):
            start_len = len(self._data)
            self._data.extend(iterable)
            
            if self._in_transaction:
                for i, value in enumerate(iterable, start_len):
                    self._transaction_stack[-1]['operations'].append(
                        ('append', i, value)
                    )
        
        def pop(self, index=-1):
            old_value = self._data[index]
            self._data.pop(index)
            
            if self._in_transaction:
                self._transaction_stack[-1]['operations'].append(
                    ('pop', index, old_value)
                )
            
            return old_value
        
        def clear(self):
            old_data = self._data.copy()
            self._data.clear()
            
            if self._in_transaction:
                self._transaction_stack[-1]['operations'].append(
                    ('clear', old_data)
                )
        
        def __repr__(self):
            status = "트랜잭션 중" if self._in_transaction else "일반"
            return f"TransactionalList({self._data}, 상태={status})"
    
    print("\n2. 트랜잭셔널 리스트:")
    
    tlist = TransactionalList([1, 2, 3])
    print(f"  초기값: {tlist}")
    
    tlist.begin_transaction()
    print(f"  트랜잭션 시작 후: {tlist}")
    
    tlist.append(4)
    tlist[0] = 10
    print(f"  항목 추가/수정 후: {tlist}")
    
    tlist.rollback()
    print(f"  롤백 후: {tlist}")
    
    tlist.begin_transaction()
    tlist.append(5)
    tlist.append(6)
    tlist.commit()
    print(f"  커밋 후: {tlist}")
    
    # 3. 옵저버 패턴 컨테이너
    class ObservableList:
        """변경 사항을 관찰할 수 있는 리스트"""
        
        def __init__(self, initial_data=None):
            self._data = list(initial_data) if initial_data else []
            self._observers = []
        
        def add_observer(self, observer):
            """옵저버 추가"""
            if observer not in self._observers:
                self._observers.append(observer)
        
        def remove_observer(self, observer):
            """옵저버 제거"""
            if observer in self._observers:
                self._observers.remove(observer)
        
        def _notify_observers(self, action, **kwargs):
            """옵저버에게 알림"""
            for observer in self._observers:
                observer(action, **kwargs)
        
        def __len__(self):
            return len(self._data)
        
        def __getitem__(self, index):
            return self._data[index]
        
        def __setitem__(self, index, value):
            old_value = self._data[index]
            self._data[index] = value
            
            self._notify_observers(
                'setitem',
                index=index,
                old_value=old_value,
                new_value=value
            )
        
        def __delitem__(self, index):
            old_value = self._data[index]
            del self._data[index]
            
            self._notify_observers(
                'delitem',
                index=index,
                old_value=old_value
            )
        
        def append(self, value):
            index = len(self._data)
            self._data.append(value)
            
            self._notify_observers(
                'append',
                index=index,
                value=value
            )
        
        def extend(self, iterable):
            start_len = len(self._data)
            self._data.extend(iterable)
            
            for i, value in enumerate(iterable, start_len):
                self._notify_observers(
                    'append',
                    index=i,
                    value=value
                )
        
        def insert(self, index, value):
            self._data.insert(index, value)
            
            self._notify_observers(
                'insert',
                index=index,
                value=value
            )
        
        def pop(self, index=-1):
            old_value = self._data[index]
            self._data.pop(index)
            
            self._notify_observers(
                'pop',
                index=index,
                old_value=old_value
            )
            
            return old_value
        
        def remove(self, value):
            index = self._data.index(value)
            self._data.remove(value)
            
            self._notify_observers(
                'remove',
                index=index,
                value=value
            )
        
        def clear(self):
            old_data = self._data.copy()
            self._data.clear()
            
            self._notify_observers(
                'clear',
                old_data=old_data
            )
        
        def __repr__(self):
            return f"ObservableList({self._data})"
    
    print("\n3. 옵저버 패턴 리스트:")
    
    class ListLogger:
        """리스트 변경 사항 로깅"""
        
        def __call__(self, action, **kwargs):
            print(f"    [로그] {action}: {kwargs}")
    
    olist = ObservableList([1, 2, 3])
    logger = ListLogger()
    olist.add_observer(logger)
    
    print(f"  초기값: {olist}")
    olist.append(4)
    olist[0] = 10
    olist.pop()
    olist.clear()
    
    # 4. 멀티맵 (하나의 키에 여러 값)
    print("\n4. 멀티맵 구현:")
    
    class MultiMap:
        """하나의 키에 여러 값을 저장하는 맵"""
        
        def __init__(self):
            self._data = {}
        
        def __len__(self):
            """키의 개수"""
            return len(self._data)
        
        def __contains__(self, key):
            return key in self._data
        
        def __getitem__(self, key):
            """키의 모든 값 반환"""
            return self._data.get(key, [])
        
        def add(self, key, value):
            """키에 값 추가"""
            if key not in self._data:
                self._data[key] = []
            self._data[key].append(value)
        
        def remove(self, key, value=None):
            """값 제거"""
            if key not in self._data:
                raise KeyError(f"키 없음: {key}")
            
            if value is None:
                # 키 전체 제거
                del self._data[key]
            else:
                # 특정 값만 제거
                if value in self._data[key]:
                    self._data[key].remove(value)
                    if not self._data[key]:  # 빈 리스트 제거
                        del self._data[key]
                else:
                    raise ValueError(f"값 없음: {value}")
        
        def get_all(self, key):
            """키의 모든 값"""
            return self._data.get(key, [])
        
        def get_first(self, key):
            """키의 첫 번째 값"""
            values = self._data.get(key, [])
            return values[0] if values else None
        
        def get_last(self, key):
            """키의 마지막 값"""
            values = self._data.get(key, [])
            return values[-1] if values else None
        
        def keys(self):
            """모든 키"""
            return self._data.keys()
        
        def values(self):
            """모든 값 (평탄화)"""
            result = []
            for values in self._data.values():
                result.extend(values)
            return result
        
        def items(self):
            """(키, 값) 쌍"""
            result = []
            for key, values in self._data.items():
                for value in values:
                    result.append((key, value))
            return result
        
        def clear(self):
            """모든 항목 제거"""
            self._data.clear()
        
        def __repr__(self):
            return f"MultiMap({self._data})"
    
    multimap = MultiMap()
    multimap.add("fruit", "apple")
    multimap.add("fruit", "banana")
    multimap.add("fruit", "orange")
    multimap.add("vegetable", "carrot")
    multimap.add("vegetable", "broccoli")
    
    print(f"  멀티맵: {multimap}")
    print(f"  fruit의 모든 값: {multimap.get_all('fruit')}")
    print(f"  첫 번째 fruit: {multimap.get_first('fruit')}")
    print(f"  모든 키: {list(multimap.keys())}")
    
    print(f"  모든 항목:")
    for key, value in multimap.items():
        print(f"    {key}: {value}")

advanced_container_patterns()
```

## 속성 접근 델리게이팅

객체의 속성 접근을 다른 객체에게 위임(delegate)하는 것은 코드 재사용과 관심사 분리에 유용한 패턴입니다.

### 기본적인 속성 델리게이션

```python
def attribute_delegation_basics():
    """속성 접근 델리게이션 기본"""
    
    print("=== 속성 접근 델리게이션 ===")
    
    # 1. __getattr__을 이용한 델리게이션
    class Delegator:
        """다른 객체에 속성 접근을 위임하는 클래스"""
        
        def __init__(self, delegate):
            self.delegate = delegate
        
        def __getattr__(self, name):
            """정의되지 않은 속성에 접근 시 호출됨"""
            print(f"  Delegator.__getattr__ 호출: '{name}'")
            return getattr(self.delegate, name)
        
        def custom_method(self):
            """자체 메서드"""
            return "Delegator의 메서드"
    
    class Delegate:
        """위임받는 클래스"""
        
        def __init__(self, value):
            self.value = value
        
        def delegate_method(self):
            return f"Delegate 메서드 호출: {self.value}"
        
        def another_method(self):
            return "다른 메서드"
    
    print("1. __getattr__을 이용한 델리게이션:")
    
    delegate = Delegate(42)
    delegator = Delegator(delegate)
    
    # Delegator에 정의된 메서드
    print(f"  custom_method: {delegator.custom_method()}")
    
    # Delegate로 위임되는 메서드
    print(f"  delegate_method: {delegator.delegate_method()}")
    print(f"  another_method: {delegator.another_method()}")
    
    # 속성 접근도 위임
    print(f"  value 속성: {delegator.value}")
    
    # 2. __getattribute__를 이용한 완전한 제어
    class SafeDelegator:
        """안전한 속성 접근 제어"""
        
        def __init__(self, delegate, allowed_attrs=None):
            self.delegate = delegate
            self.allowed_attrs = allowed_attrs or []
            self._internal_value = "내부 값"
        
        def __getattribute__(self, name):
            """모든 속성 접근 시 호출됨"""
            # 직접 접근 허용 목록
            direct_access = ['delegate', 'allowed_attrs', '_internal_value']
            
            if name in direct_access:
                # 직접 속성 접근
                return object.__getattribute__(self, name)
            
            if name in self.allowed_attrs:
                # 위임 허용된 속성
                print(f"  SafeDelegator: '{name}' 위임 허용")
                delegate = object.__getattribute__(self, 'delegate')
                return getattr(delegate, name)
            else:
                # 거부된 속성
                raise AttributeError(
                    f"'{type(self).__name__}' 객체에는 '{name}' 속성이 없거나 "
                    f"접근이 허용되지 않았습니다"
                )
        
        def safe_method(self):
            return "안전한 메서드"
    
    print("\n2. __getattribute__를 이용한 제어:")
    
    class DataSource:
        def public_data(self):
            return "공개 데이터"
        
        def private_data(self):
            return "비공개 데이터"
        
        def sensitive_info(self):
            return "민감 정보"
    
    data_source = DataSource()
    safe_delegator = SafeDelegator(data_source, ['public_data'])
    
    print(f"  safe_method: {safe_delegator.safe_method()}")
    print(f"  public_data: {safe_delegator.public_data()}")
    
    try:
        print(f"  private_data: {safe_delegator.private_data()}")
    except AttributeError as e:
        print(f"  접근 거부: {e}")
    
    # 3. __setattr__과 __delattr__ 델리게이션
    class FullDelegator:
        """속성 설정과 삭제도 위임"""
        
        def __init__(self, delegate):
            # __setattr__을 사용하기 때문에 object.__setattr__을 사용해야 함
            object.__setattr__(self, 'delegate', delegate)
        
        def __getattr__(self, name):
            print(f"  __getattr__: '{name}'")
            return getattr(self.delegate, name)
        
        def __setattr__(self, name, value):
            """속성 설정"""
            print(f"  __setattr__: '{name}' = {value}")
            
            if name == 'delegate':
                # delegate 속성은 직접 설정
                object.__setattr__(self, name, value)
            else:
                # 다른 속성은 위임 객체에 설정
                setattr(self.delegate, name, value)
        
        def __delattr__(self, name):
            """속성 삭제"""
            print(f"  __delattr__: '{name}'")
            
            if name == 'delegate':
                raise AttributeError("delegate 속성은 삭제할 수 없습니다")
            
            delattr(self.delegate, name)
    
    print("\n3. 완전한 속성 델리게이션:")
    
    class Config:
        def __init__(self):
            self.setting1 = "기본값1"
            self.setting2 = "기본값2"
    
    config = Config()
    delegator = FullDelegator(config)
    
    # 속성 읽기
    print(f"  setting1: {delegator.setting1}")
    
    # 속성 설정
    delegator.setting1 = "새로운 값"
    print(f"  변경 후 setting1: {delegator.setting1}")
    
    # 속성 삭제
    del delegator.setting2
    try:
        print(f"  삭제 후 setting2: {delegator.setting2}")
    except AttributeError as e:
        print(f"  속성 삭제됨: {e}")

attribute_delegation_basics()
```

### 고급 델리게이션 패턴

```python
def advanced_delegation_patterns():
    """고급 델리게이션 패턴"""
    
    print("\n=== 고급 델리게이션 패턴 ===")
    
    # 1. 다중 델리게이션
    class MultiDelegator:
        """여러 객체에 속성을 위임"""
        
        def __init__(self, *delegates):
            self._delegates = list(delegates)
            self._direct_attrs = {}  # 직접 속성 저장
        
        def __getattr__(self, name):
            """여러 위임 객체에서 속성 찾기"""
            # 직접 속성 먼저 확인
            if name in self._direct_attrs:
                return self._direct_attrs[name]
            
            # 각 위임 객체에서 순서대로 찾기
            for delegate in self._delegates:
                try:
                    return getattr(delegate, name)
                except AttributeError:
                    continue
            
            raise AttributeError(f"'{type(self).__name__}' 객체에 '{name}' 속성이 없습니다")
        
        def __setattr__(self, name, value):
            """속성 설정"""
            if name.startswith('_'):
                # 내부 속성
                object.__setattr__(self, name, value)
            elif any(hasattr(d, name) for d in self._delegates):
                # 위임 객체에 있는 속성은 첫 번째 위임 객체에 설정
                for delegate in self._delegates:
                    if hasattr(delegate, name):
                        setattr(delegate, name, value)
                        break
            else:
                # 새로운 속성은 직접 저장
                self._direct_attrs[name] = value
        
        def add_delegate(self, delegate):
            """위임 객체 추가"""
            self._delegates.append(delegate)
        
        def remove_delegate(self, delegate):
            """위임 객체 제거"""
            if delegate in self._delegates:
                self._delegates.remove(delegate)
    
    print("1. 다중 델리게이션:")
    
    class Database:
        def query(self, sql):
            return f"데이터베이스 쿼리: {sql}"
        
        def connect(self):
            return "데이터베이스 연결됨"
    
    class Cache:
        def get(self, key):
            return f"캐시에서 {key} 조회"
        
        def set(self, key, value):
            return f"캐시에 {key}={value} 저장"
    
    class Logger:
        def log(self, message):
            return f"로그: {message}"
    
    db = Database()
    cache = Cache()
    logger = Logger()
    
    multi_delegator = MultiDelegator(db, cache, logger)
    
    print(f"  데이터베이스 메서드: {multi_delegator.query('SELECT * FROM users')}")
    print(f"  캐시 메서드: {multi_delegator.get('user:123')}")
    print(f"  로거 메서드: {multi_delegator.log('시스템 시작')}")
    
    # 새로운 속성 설정
    multi_delegator.custom_value = "사용자 정의 값"
    print(f"  직접 속성: {multi_delegator.custom_value}")
    
    # 2. 조건부 델리게이션
    class ConditionalDelegator:
        """조건에 따라 다른 객체에 위임"""
        
        def __init__(self):
            self._delegates = {}
            self._default_delegate = None
        
        def register_delegate(self, condition, delegate):
            """조건별 위임 객체 등록"""
            self._delegates[condition] = delegate
        
        def set_default_delegate(self, delegate):
            """기본 위임 객체 설정"""
            self._default_delegate = delegate
        
        def __getattr__(self, name):
            """조건에 맞는 위임 객체 찾기"""
            # 호출 컨텍스트 분석 (간단한 예제)
            import inspect
            
            # 호출 스택 분석
            stack = inspect.stack()
            caller_info = stack[1]  # 호출자 정보
            
            # 파일명이나 함수명 기반으로 조건 판단
            caller_filename = caller_info.filename
            caller_function = caller_info.function
            
            print(f"  호출 컨텍스트: 파일={caller_filename}, 함수={caller_function}")
            
            # 조건에 맞는 위임 객체 찾기
            for condition, delegate in self._delegates.items():
                if condition in caller_filename or condition in caller_function:
                    print(f"  조건 '{condition}'에 맞는 위임 객체 사용")
                    return getattr(delegate, name)
            
            # 기본 위임 객체
            if self._default_delegate:
                print(f"  기본 위임 객체 사용")
                return getattr(self._default_delegate, name)
            
            raise AttributeError(f"'{name}' 속성을 찾을 수 없습니다")
    
    print("\n2. 조건부 델리게이션:")
    
    class DevelopmentService:
        def process(self):
            return "개발 환경 처리"
    
    class ProductionService:
        def process(self):
            return "운영 환경 처리"
    
    class TestingService:
        def process(self):
            return "테스트 환경 처리"
    
    # 조건부 델리게이터 설정
    delegator = ConditionalDelegator()
    delegator.register_delegate("dev", DevelopmentService())
    delegator.register_delegate("prod", ProductionService())
    delegator.register_delegate("test", TestingService())
    
    # 다양한 컨텍스트에서 호출 (시뮬레이션)
    def dev_function():
        return delegator.process()
    
    def prod_function():
        return delegator.process()
    
    # 실제 실행 시 파일명과 함수명을 기반으로 조건 판단
    print("  주의: 이 예제는 실제 호출 컨텍스트에 의존하므로 여기서는 시뮬레이션합니다")
    
    # 3. 프록시 패턴 구현
    print("\n3. 프록시 패턴 구현:")
    
    class Subject:
        """실제 주체 인터페이스"""
        
        def request(self, data):
            raise NotImplementedError
        
        def sensitive_operation(self, credential):
            raise NotImplementedError
    
    class RealSubject(Subject):
        """실제 주체"""
        
        def request(self, data):
            return f"실제 처리: {data}"
        
        def sensitive_operation(self, credential):
            if credential == "secret":
                return "민감한 작업 수행 완료"
            else:
                raise PermissionError("인증 실패")
        
        def internal_method(self):
            return "내부 메서드"
    
    class ProtectionProxy(Subject):
        """보호 프록시"""
        
        def __init__(self, real_subject, credential):
            self._real_subject = real_subject
            self._credential = credential
            self._access_log = []
        
        def request(self, data):
            """일반 요청은 허용"""
            self._log_access("request", data)
            return self._real_subject.request(data)
        
        def sensitive_operation(self, credential):
            """인증 확인 후 위임"""
            if credential == self._credential:
                self._log_access("sensitive_operation", "승인됨")
                return self._real_subject.sensitive_operation(credential)
            else:
                self._log_access("sensitive_operation", "거부됨")
                raise PermissionError("인증 실패")
        
        def _log_access(self, operation, details):
            """접근 로깅"""
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            self._access_log.append(f"{timestamp}: {operation} - {details}")
        
        def get_access_log(self):
            """접근 로그 조회"""
            return self._access_log
    
    class LoggingProxy(Subject):
        """로깅 프록시"""
        
        def __init__(self, real_subject):
            self._real_subject = real_subject
            self._logger = []
        
        def __getattr__(self, name):
            """모든 메서드 호출 로깅"""
            attr = getattr(self._real_subject, name)
            
            if callable(attr):
                def logged_method(*args, **kwargs):
                    import datetime
                    timestamp = datetime.datetime.now().strftime("%H:%M:%S")
                    log_entry = f"{timestamp}: {name}{args}"
                    self._logger.append(log_entry)
                    print(f"  [로그] {log_entry}")
                    
                    try:
                        result = attr(*args, **kwargs)
                        self._logger.append(f"{timestamp}: {name} -> {result}")
                        return result
                    except Exception as e:
                        self._logger.append(f"{timestamp}: {name} -> 예외: {e}")
                        raise
                
                return logged_method
            
            return attr
        
        def get_logs(self):
            """로그 조회"""
            return self._logger
    
    # 프록시 사용 예제
    real = RealSubject()
    protection_proxy = ProtectionProxy(real, "secret")
    logging_proxy = LoggingProxy(protection_proxy)
    
    print(f"  일반 요청: {logging_proxy.request('테스트 데이터')}")
    
    try:
        print(f"  인증 실패 시도: {logging_proxy.sensitive_operation('wrong')}")
    except PermissionError as e:
        print(f"  인증 실패: {e}")
    
    print(f"  인증 성공 시도: {logging_proxy.sensitive_operation('secret')}")
    
    print(f"  접근 로그:")
    for log in protection_proxy.get_access_log():
        print(f"    {log}")
    
    # 4. 컴포지트 패턴과 델리게이션
    print("\n4. 컴포지트 패턴과 델리게이션:")
    
    class UIComponent:
        """UI 컴포넌트 베이스 클래스"""
        
        def __init__(self, name):
            self.name = name
            self._children = []
        
        def add(self, component):
            """자식 컴포넌트 추가"""
            self._children.append(component)
        
        def remove(self, component):
            """자식 컴포넌트 제거"""
            self._children.remove(component)
        
        def render(self):
            """렌더링"""
            raise NotImplementedError
        
        def __getattr__(self, name):
            """자식 컴포넌트에 메서드 위임"""
            # 공통 메서드를 모든 자식에게 적용
            if name in ['show', 'hide', 'enable', 'disable']:
                def apply_to_all(*args, **kwargs):
                    results = []
                    for child in self._children:
                        method = getattr(child, name, None)
                        if callable(method):
                            results.append(method(*args, **kwargs))
                    return results
                
                return apply_to_all
            
            raise AttributeError(f"'{type(self).__name__}' 객체에 '{name}' 속성이 없습니다")
    
    class Button(UIComponent):
        def __init__(self, name, text):
            super().__init__(name)
            self.text = text
            self.visible = True
            self.enabled = True
        
        def render(self):
            status = "활성화" if self.enabled else "비활성화"
            return f"[버튼: {self.text}] ({status})"
        
        def show(self):
            self.visible = True
            return f"{self.name} 표시됨"
        
        def hide(self):
            self.visible = False
            return f"{self.name} 숨겨짐"
        
        def enable(self):
            self.enabled = True
            return f"{self.name} 활성화됨"
        
        def disable(self):
            self.enabled = False
            return f"{self.name} 비활성화됨"
    
    class Panel(UIComponent):
        def __init__(self, name):
            super().__init__(name)
            self.visible = True
        
        def render(self):
            child_renders = []
            for child in self._children:
                child_renders.append(child.render())
            return f"패널 '{self.name}':\n  " + "\n  ".join(child_renders)
        
        def show(self):
            self.visible = True
            results = [f"{self.name} 표시됨"]
            results.extend(super().__getattr__('show')())
            return results
        
        def hide(self):
            self.visible = False
            results = [f"{self.name} 숨겨짐"]
            results.extend(super().__getattr__('hide')())
            return results
    
    # UI 컴포넌트 계층 구조 생성
    main_panel = Panel("메인 패널")
    
    button1 = Button("btn1", "저장")
    button2 = Button("btn2", "취소")
    
    sub_panel = Panel("서브 패널")
    button3 = Button("btn3", "확인")
    
    sub_panel.add(button3)
    main_panel.add(button1)
    main_panel.add(button2)
    main_panel.add(sub_panel)
    
    print(f"  UI 계층 구조 렌더링:")
    print(f"  {main_panel.render()}")
    
    print(f"\n  모든 버튼 비활성화:")
    results = main_panel.disable()
    for result in results:
        print(f"    {result}")
    
    print(f"\n  렌더링 상태:")
    print(f"  {main_panel.render()}")

advanced_delegation_patterns()
```

### 실전: 데이터베이스 ORM 스타일의 델리게이션

```python
def practical_orm_style_delegation():
    """실전: ORM 스타일의 델리게이션"""
    
    print("\n=== 실전: ORM 스타일 델리게이션 ===")
    
    # 1. 액티브 레코드 패턴 구현
    class Field:
        """데이터베이스 필드 추상화"""
        
        def __init__(self, field_type, default=None, nullable=True):
            self.field_type = field_type
            self.default = default
            self.nullable = nullable
            self.name = None  # 메타클래스에서 설정됨
        
        def validate(self, value):
            """값 검증"""
            if value is None:
                if not self.nullable:
                    raise ValueError(f"{self.name} 필드는 NULL일 수 없습니다")
                return True
            
            if not isinstance(value, self.field_type):
                raise TypeError(
                    f"{self.name} 필드는 {self.field_type.__name__} 타입이어야 합니다. "
                    f"받은 타입: {type(value).__name__}"
                )
            
            return True
    
    class IntegerField(Field):
        def __init__(self, default=0, nullable=True):
            super().__init__(int, default, nullable)
    
    class StringField(Field):
        def __init__(self, default="", max_length=255, nullable=True):
            super().__init__(str, default, nullable)
            self.max_length = max_length
        
        def validate(self, value):
            super().validate(value)
            
            if value is not None and len(value) > self.max_length:
                raise ValueError(
                    f"{self.name} 필드는 최대 {self.max_length}자까지 가능합니다. "
                    f"현재 길이: {len(value)}"
                )
            
            return True
    
    class DateTimeField(Field):
        def __init__(self, default=None, nullable=True):
            from datetime import datetime
            super().__init__(datetime, default, nullable)
    
    class ModelMeta(type):
        """모델 메타클래스 - 필드 정보 수집"""
        
        def __new__(mcs, name, bases, namespace):
            # 필드 정보 수집
            fields = {}
            for key, value in namespace.items():
                if isinstance(value, Field):
                    value.name = key
                    fields[key] = value
            
            # 필드 정보를 클래스 속성으로 저장
            namespace['_fields'] = fields
            
            return super().__new__(mcs, name, bases, namespace)
    
    class QuerySet:
        """데이터베이스 쿼리 집합 (시뮬레이션)"""
        
        def __init__(self, model_class):
            self.model_class = model_class
            self._filters = []
            self._data = []  # 메모리 저장소 (실제로는 DB 연결)
        
        def filter(self, **kwargs):
            """필터 조건 추가"""
            self._filters.append(kwargs)
            return self
        
        def all(self):
            """모든 객체 반환"""
            results = []
            for data in self._data:
                # 필터 적용
                matches = True
                for filter_dict in self._filters:
                    for key, value in filter_dict.items():
                        if data.get(key) != value:
                            matches = False
                            break
                    if not matches:
                        break
                
                if matches:
                    instance = self.model_class(**data)
                    results.append(instance)
            
            return results
        
        def first(self):
            """첫 번째 객체 반환"""
            all_results = self.all()
            return all_results[0] if all_results else None
        
        def count(self):
            """객체 개수 반환"""
            return len(self.all())
        
        def save(self, instance):
            """객체 저장"""
            data = instance._data.copy()
            self._data.append(data)
            return instance
    
    class BaseModel(metaclass=ModelMeta):
        """모델 베이스 클래스"""
        
        def __init__(self, **kwargs):
            self._data = {}
            self._is_new = True  # 새 객체인지 여부
            
            # 필드 기본값 설정
            for field_name, field in self._fields.items():
                self._data[field_name] = field.default
            
            # 초기값 설정
            for key, value in kwargs.items():
                setattr(self, key, value)
        
        def __setattr__(self, name, value):
            """속성 설정 시 검증"""
            if name.startswith('_'):
                # 내부 속성
                object.__setattr__(self, name, value)
            elif name in self._fields:
                # 필드 값 설정 (검증 포함)
                field = self._fields[name]
                field.validate(value)
                self._data[name] = value
            else:
                raise AttributeError(f"{type(self).__name__}에는 '{name}' 속성이 없습니다")
        
        def __getattr__(self, name):
            """속성 접근"""
            if name in self._data:
                return self._data[name]
            
            if name in self._fields:
                return self._fields[name].default
            
            raise AttributeError(f"{type(self).__name__}에는 '{name}' 속성이 없습니다")
        
        def save(self):
            """객체 저장"""
            # 모든 필드 검증
            for field_name, field in self._fields.items():
                value = self._data.get(field_name)
                field.validate(value)
            
            # 실제 저장 로직 (시뮬레이션)
            if self._is_new:
                self.id = len(self.objects._data) + 1
                self.objects.save(self)
                self._is_new = False
                print(f"  새 객체 저장: {self}")
            else:
                print(f"  객체 업데이트: {self}")
            
            return self
        
        def delete(self):
            """객체 삭제"""
            # 실제 삭제 로직 (시뮬레이션)
            print(f"  객체 삭제: {self}")
        
        def __repr__(self):
            fields_repr = []
            for field_name in self._fields.keys():
                value = self._data.get(field_name)
                fields_repr.append(f"{field_name}={value!r}")
            
            return f"{type(self).__name__}({', '.join(fields_repr)})"
        
        @classmethod
        def objects(cls):
            """쿼리셋 반환"""
            if not hasattr(cls, '_queryset'):
                cls._queryset = QuerySet(cls)
            return cls._queryset
    
    # 모델 정의
    class User(BaseModel):
        id = IntegerField()
        username = StringField(max_length=50)
        email = StringField(max_length=100)
        age = IntegerField(nullable=True)
        created_at = DateTimeField()
    
    class Product(BaseModel):
        id = IntegerField()
        name = StringField(max_length=100)
        price = IntegerField()
        in_stock = IntegerField(default=0)
    
    print("1. 액티브 레코드 패턴:")
    
    # 사용자 생성
    from datetime import datetime
    
    user1 = User(
        username="john_doe",
        email="john@example.com",
        age=30,
        created_at=datetime.now()
    )
    
    print(f"  사용자 객체 생성: {user1}")
    
    # 속성 접근
    print(f"  username: {user1.username}")
    print(f"  email: {user1.email}")
    
    # 저장
    user1.save()
    
    # 추가 사용자
    user2 = User(
        username="jane_smith",
        email="jane@example.com",
        age=25,
        created_at=datetime.now()
    ).save()
    
    # 쿼리
    print(f"\n  모든 사용자: {User.objects().all()}")
    print(f"  사용자 수: {User.objects().count()}")
    
    # 필터링
    print(f"  john_doe 찾기: {User.objects().filter(username='john_doe').first()}")
    
    # 2. 관계 델리게이션
    print("\n2. 관계 델리게이션:")
    
    class RelatedManager:
        """관계 관리자"""
        
        def __init__(self, source_instance, target_model, foreign_key):
            self.source_instance = source_instance
            self.target_model = target_model
            self.foreign_key = foreign_key
        
        def all(self):
            """관련된 모든 객체 반환"""
            return self.target_model.objects().filter(
                **{self.foreign_key: self.source_instance.id}
            ).all()
        
        def count(self):
            """관련 객체 개수"""
            return len(self.all())
        
        def add(self, target_instance):
            """관계 추가"""
            setattr(target_instance, self.foreign_key, self.source_instance.id)
            target_instance.save()
        
        def remove(self, target_instance):
            """관계 제거"""
            setattr(target_instance, self.foreign_key, None)
            target_instance.save()
    
    class Order(BaseModel):
        id = IntegerField()
        user_id = IntegerField()
        total_amount = IntegerField()
        order_date = DateTimeField()
        
        @property
        def user(self):
            """주문자 참조"""
            return User.objects().filter(id=self.user_id).first()
        
        @property
        def items(self):
            """주문 항목들"""
            return RelatedManager(self, OrderItem, 'order_id')
    
    class OrderItem(BaseModel):
        id = IntegerField()
        order_id = IntegerField()
        product_id = IntegerField()
        quantity = IntegerField()
        price = IntegerField()
        
        @property
        def product(self):
            """제품 참조"""
            return Product.objects().filter(id=self.product_id).first()
        
        @property
        def order(self):
            """주문 참조"""
            return Order.objects().filter(id=self.order_id).first()
    
    # 데이터 설정
    product1 = Product(name="노트북", price=1500000, in_stock=10).save()
    product2 = Product(name="스마트폰", price=800000, in_stock=20).save()
    
    order = Order(
        user_id=user1.id,
        total_amount=2300000,
        order_date=datetime.now()
    ).save()
    
    order_item1 = OrderItem(
        order_id=order.id,
        product_id=product1.id,
        quantity=1,
        price=1500000
    ).save()
    
    order_item2 = OrderItem(
        order_id=order.id,
        product_id=product2.id,
        quantity=1,
        price=800000
    ).save()
    
    print(f"  주문 정보:")
    print(f"    주문자: {order.user.username}")
    print(f"    총 금액: ₩{order.total_amount:,}")
    print(f"    주문 항목:")
    for item in order.items.all():
        print(f"      - {item.product.name}: {item.quantity}개 × ₩{item.price:,}")
    
    # 3. 지연 로딩 델리게이션
    print("\n3. 지연 로딩 델리게이션:")
    
    class LazyLoader:
        """지연 로딩을 위한 프록시"""
        
        def __init__(self, loader_func):
            self.loader_func = loader_func
            self._value = None
            self._loaded = False
        
        def __getattr__(self, name):
            """속성 접근 시 실제 객체 로드"""
            self._ensure_loaded()
            return getattr(self._value, name)
        
        def __call__(self, *args, **kwargs):
            """호출 시 실제 객체 로드"""
            self._ensure_loaded()
            return self._value(*args, **kwargs)
        
        def _ensure_loaded(self):
            """실제 객체 로드"""
            if not self._loaded:
                print(f"  [지연 로딩] 객체 로드 중...")
                self._value = self.loader_func()
                self._loaded = True
        
        def is_loaded(self):
            """로드 여부 확인"""
            return self._loaded
        
        @property
        def value(self):
            """실제 값 접근"""
            self._ensure_loaded()
            return self._value
    
    class HeavyResource:
        """무거운 리소스 (로드에 시간이 걸림)"""
        
        def __init__(self, resource_id):
            self.resource_id = resource_id
            print(f"    HeavyResource(id={resource_id}) 생성 중...")
            time.sleep(0.1)  # 무거운 초기화 시뮬레이션
        
        def process(self):
            return f"리소스 {self.resource_id} 처리 완료"
        
        def get_info(self):
            return f"리소스 정보: ID={self.resource_id}"
    
    class ResourceManager:
        """리소스 관리자"""
        
        def __init__(self):
            self._resources = {}
        
        def get_resource(self, resource_id):
            """리소스 가져오기 (지연 로딩)"""
            if resource_id not in self._resources:
                # 지연 로더 생성
                loader = lambda: HeavyResource(resource_id)
                self._resources[resource_id] = LazyLoader(loader)
            
            return self._resources[resource_id]
    
    manager = ResourceManager()
    
    print(f"  리소스 관리자 생성됨")
    
    # 리소스 가져오기 (아직 생성되지 않음)
    resource1 = manager.get_resource(1)
    print(f"  리소스1 가져옴 (로드됨? {resource1.is_loaded()})")
    
    # 실제 사용 시 로드됨
    print(f"  리소스1 처리: {resource1.process()}")
    print(f"  리소스1 로드됨? {resource1.is_loaded()}")
    
    # 같은 리소스 재사용
    resource1_again = manager.get_resource(1)
    print(f"  같은 리소스 재사용 (로드됨? {resource1_again.is_loaded()})")

practical_orm_style_delegation()
```

## 결론

파이썬의 데이터 모델은 객체의 동작을 정의하는 강력한 프로토콜을 제공합니다. 특수 메서드(던더 메서드)를 구현함으로써 우리만의 타입 시스템을 만들 수 있습니다. 산술 연산자, 비교 연산자, 컨테이너 프로토콜 등을 지원하는 클래스를 구현하면 자연스럽게 파이썬 생태계에 통합되는 객체를 만들 수 있습니다.

커스텀 컨테이너 구현은 파이썬의 내장 컨테이너가 제공하지 않는 특수한 기능이 필요할 때 매우 유용합니다. 시퀀스, 매핑, 집합 프로토콜을 구현하거나 완전히 새로운 컨테이너 패턴을 만들 수 있습니다. 지연 평가, 트랜잭셔널, 옵저버 패턴 등 다양한 고급 패턴을 컨테이너에 적용할 수 있습니다.

속성 접근 델리게이션은 코드 재사용과 관심사 분리를 위한 강력한 패턴입니다. `__getattr__`, `__getattribute__`, `__setattr__`, `__delattr__` 메서드를 활용하면 속성 접근을 완전히 제어할 수 있습니다. 프록시 패턴, 컴포지트 패턴, ORM 스타일의 액티브 레코드 패턴 등 실전에서 자주 사용되는 패턴들을 델리게이션을 통해 구현할 수 있습니다.

이러한 기술들을 결합하면 강력하고 유연한 파이썬 애플리케이션을 구축할 수 있습니다. 데이터 모델 프로토콜을 이해하고 적절히 활용하면 파이썬의 동적 특성을 최대한 활용하면서도 견고한 타입 시스템을 가진 코드를 작성할 수 있습니다. 컨테이너와 델리게이션 패턴은 복잡한 문제를 간결하고 우아하게 해결하는 데 도움이 됩니다.