---
layout: post
title: HTML - 반응형 이미지
date: 2025-04-23 21:20:23 +0900
category: HTML
---
# HTML 반응형 이미지 완벽 가이드 (`<picture>`, `srcset`, `sizes`)

## 핵심 개념 요약

- **해상도 전환(Resolution switching)**: 같은 이미지의 **여러 크기**를 준비하고, 브라우저가 **적절한 크기**를 고르게 한다. (`srcset` + `sizes`)
- **아트 디렉션(Art direction)**: 상황(브레이크포인트)에 따라 **다른 구도/자르기**의 이미지를 사용한다. (`<picture>` + `<source media>`)
- **포맷 전환(Type switching)**: 브라우저가 지원하면 **AVIF/WebP** 같은 **고효율 포맷**을 우선 사용하고, 미지원일 때 JPG/PNG로 폴백. (`<source type>`)
- **픽셀 밀도 대응(DPR)**: Retina 등 **2x/3x** 화면을 위해 더 고밀도 자원을 제공한다. (`1x`, `2x` 밀도 기술자)
- **성능 최적화**: `loading="lazy"`, `decoding="async"`, `fetchpriority`, `preload`, 이미지 압축·캐싱·CDN, CLS 방지(너비/높이 지정).

---

## `srcset` + `sizes`로 해상도 전환

### 기본 문법 (너비 기술자: `w`)

```html
<img
  src="photo-800.jpg"
  srcset="
    photo-480.jpg 480w,
    photo-800.jpg 800w,
    photo-1200.jpg 1200w,
    photo-1600.jpg 1600w"
  sizes="(max-width: 600px) 100vw, 50vw"
  alt="가을 산 풍경">
```

- `srcset`의 각 후보는 **픽셀 너비**를 의미하는 `w` 기술자를 가진다.
- `sizes`는 **레이아웃 상 실제 표시될 CSS 폭**을 **브라우저에 알려주는 힌트**다.
  위 예시는 “뷰포트 ≤ 600px이면 이미지가 100vw(화면 너비의 100%), 그 외에는 50vw로 표시된다”는 뜻.
- 브라우저는 `sizes`로 예상 표시폭을 구해 **가장 근접한 실제 이미지 파일**을 선택한다.

### 밀도 기술자: `x` (DPR 전용)

```html
<img
  src="logo@1x.png"
  srcset="
    logo@1x.png 1x,
    logo@2x.png 2x,
    logo@3x.png 3x"
  alt="서비스 로고">
```

- **같은 레이아웃 폭**에서 **화면 밀도(DPR)**에 따라 더 높은 해상도의 이미지를 고른다.
- UI 아이콘·로고처럼 **항상 고정 크기로 표시되는 이미지**에 적합.

### 선택 알고리즘 직관: 어떤 파일을 고를까?

- 브라우저는 `sizes`(또는 `x` 기술자)를 바탕으로 **필요한 소스의 픽셀 수**를 계산한다.
- 단순화해 말하면, 다음과 같은 값이 커질수록 더 큰 소스가 필요하다.

$$
\text{요구 픽셀 폭} \approx \text{표시폭(CSS px)} \times \text{디바이스 픽셀 비율(DPR)}
$$

- 예: 표시폭이 500px이고 DPR=2라면 **약 1000px**짜리 소스를 고른다.

---

## `sizes` 작성 요령

### 가장 흔한 패턴

```html
<img
  src="default.jpg"
  srcset="
    photo-480.jpg 480w,
    photo-768.jpg 768w,
    photo-1200.jpg 1200w"
  sizes="(max-width: 600px) 100vw, 50vw"
  alt="계곡 전경">
```

- **모바일(≤600px)**: 카드가 그리드 1열 → 이미지가 뷰포트 전체 폭 → `100vw`
- **데스크톱(>600px)**: 카드가 2열 → 한 카드 너비가 화면의 절반 → `50vw`

### 컨테이너 기준으로 더 정확하게

실제 레이아웃이 **컨테이너 폭**에 의해 결정된다면, CSS와 맞춰 쓰자.

```html
<style>
  .content { max-width: 960px; margin: 0 auto; }
  .post-image { width: 66.666%; } /* 2/3 열 차지 */
</style>

<div class="content">
  <img
    class="post-image"
    src="hero-1280.jpg"
    srcset="
      hero-640.jpg 640w,
      hero-960.jpg 960w,
      hero-1280.jpg 1280w,
      hero-1600.jpg 1600w"
    sizes="(max-width: 960px) 100vw, 640px"
    alt="절벽 위 들꽃">
</div>
```

- 960px 이하에서는 레이아웃이 줄어들어 이미지가 **화면 전체**를 차지 → `100vw`
- 그 이상에서는 컨테이너가 960px로 고정되고 이미지가 2/3 → **약 640px**로 고정 → `640px`

---

## `<picture>`로 아트 디렉션 + 포맷 전환

### 구도(자르기) 전환: 브레이크포인트마다 다른 이미지

```html
<picture>
  <!-- 데스크톱: 넓은 가로 구도 -->
  <source media="(min-width: 1024px)" srcset="banner-wide-1600.jpg">
  <!-- 태블릿: 보통 가로 구도 -->
  <source media="(min-width: 600px)" srcset="banner-regular-1200.jpg">
  <!-- 모바일: 세로 스택일 때 피사체가 잘리지 않도록 중앙 크롭 -->
  <img src="banner-mobile-800.jpg" alt="가을 축제 배너">
</picture>
```

- 뷰포트에 따라 **서로 다른 구도**의 이미지를 쓰는 것이 **아트 디렉션**이다.
- `srcset`과 달리, `<picture>`의 `<source>`는 **조건 분기**다. **맨 위에서부터** 매칭되는 첫 `<source>`가 채택된다.

### 포맷 전환(AVIF/WebP → JPEG 폴백)

```html
<picture>
  <source type="image/avif" srcset="photo-1200.avif 1200w, photo-800.avif 800w" sizes="(max-width: 600px) 100vw, 50vw">
  <source type="image/webp" srcset="photo-1200.webp 1200w, photo-800.webp 800w" sizes="(max-width: 600px) 100vw, 50vw">
  <img src="photo-1200.jpg"
       srcset="photo-800.jpg 800w, photo-1200.jpg 1200w"
       sizes="(max-width: 600px) 100vw, 50vw"
       alt="해안 절벽">
</picture>
```

- 브라우저가 **AVIF**를 지원하면 AVIF, 아니면 **WebP**, 마지막으로 **JPG**를 사용.
- 각 `<source>`에도 `srcset`/`sizes`를 줄 수 있어 **포맷 + 해상도 전환**을 동시에 처리 가능.

---

## 레이아웃 시프트(CLS) 방지 — 폭·높이 지정

이미지 로딩 중 크기가 변하면 **누적 레이아웃 시프트(CLS)**가 발생한다. 방지책:

```html
<!-- width/height (원본 픽셀 크기)를 지정 -->
<img
  src="photo-1200.jpg"
  width="1200" height="800"
  style="max-width: 100%; height: auto;"
  alt="해변 노을">
```

- `width`/`height` 값을 명시하면 브라우저가 **intrinsic aspect ratio**를 파악해 **자리를 먼저 확보**한다.
- CSS로 `max-width:100%`, `height:auto`를 주면 반응형으로 축소되면서 **종횡비 유지**.

`aspect-ratio`를 이용할 수도 있다.

```html
<img
  src="photo-1200.jpg"
  style="aspect-ratio: 3 / 2; width: 100%; height: auto;"
  alt="초원">
```

---

## 성능 속성: `loading`, `decoding`, `fetchpriority`, `referrerpolicy`

```html
<!-- 뷰포트 밖의 이미지를 지연 로딩 -->
<img src="gallery-1.jpg" loading="lazy" alt="갤러리">

<!-- 디코딩을 비동기로 위임 -->
<img src="hero.jpg" decoding="async" alt="히어로 이미지">

<!-- LCP 후보(Above-the-fold)는 우선 로드 -->
<img src="hero.webp" fetchpriority="high" alt="히어로 배너">

<!-- 리퍼러 정책(개인정보/캐시정책)을 제어 -->
<img src="cdn/img.jpg" referrerpolicy="no-referrer" alt="썸네일">
```

- `loading="lazy"`: 뷰포트 진입 시 로드(대부분의 브라우저 지원).
- 중요한 LCP 이미지(접속 직후 화면에 보이는 가장 큰 컨텐츠)는 `fetchpriority="high"`로 힌트 제공.
- `decoding="async"`: 파싱 차단 없이 디코딩 위임.

**힌트**: LCP 이미지는 **가능하면 `<link rel="preload" as="image">`**도 고려.

```html
<link rel="preload" as="image" href="/hero.avif" imagesrcset="/hero-1200.avif 1200w, /hero-800.avif 800w" imagesizes="100vw" type="image/avif">
```

---

## CSS 배경 이미지도 반응형 — `image-set()`과 미디어쿼리

배경 이미지에 **밀도 대응**:

```css
.hero {
  background-image: image-set(
    url("/hero@1x.webp") 1x,
    url("/hero@2x.webp") 2x
  );
  background-size: cover;
}
```

포맷·브레이크포인트 전환:

```css
.hero {
  background-image: url("/hero-fallback.jpg");
  background-size: cover;
}
@supports (background: url("") type("image/avif")) {
  .hero { background-image: url("/hero.avif"); }
}
@media (min-width: 1024px) {
  .hero { background-image: url("/hero-desktop.avif"); }
}
```

> 접근성이 필요한 **의미 있는 콘텐츠 이미지**는 `background-image`가 아닌 **`<img>`**로 제공하고, **대체 텍스트**를 작성하세요.

---

## 접근성: `alt`, `figure/figcaption`, 장식 이미지

```html
<figure>
  <img src="waterfall-1200.jpg"
       srcset="waterfall-800.jpg 800w, waterfall-1200.jpg 1200w"
       sizes="(max-width: 600px) 100vw, 50vw"
       alt="절벽을 타고 흘러내리는 폭포">
  <figcaption>폭포 전경 — 여름철 하이킹 코스</figcaption>
</figure>
```

- 의미 있는 이미지에는 **명확한 `alt` 대체 텍스트**를 제공.
- 순수 장식(의미 없음)일 경우 `alt=""`로 스크린리더에서 무시하게 한다.

---

## 실전 예제: 카드 그리드(모바일 1열 → 데스크톱 3열)

### HTML

```html
<section class="grid">
  <article class="card">
    <img
      src="/img/p1-800.jpg"
      srcset="/img/p1-480.jpg 480w, /img/p1-800.jpg 800w, /img/p1-1200.jpg 1200w"
      sizes="(max-width: 640px) 100vw, (max-width: 1024px) 33vw, 33vw"
      width="1200" height="800"
      loading="lazy" decoding="async"
      alt="산책로 풍경">
    <h3>산책로</h3>
  </article>

  <!-- ... 동일 패턴 반복 ... -->

</section>
```

### CSS

```css
.grid {
  display: grid;
  gap: 16px;
  grid-template-columns: 1fr;
  padding: 16px;
}
@media (min-width: 640px) {
  .grid { grid-template-columns: repeat(2, 1fr); }
}
@media (min-width: 1024px) {
  .grid { grid-template-columns: repeat(3, 1fr); }
}
.card img { width: 100%; height: auto; display: block; }
```

- `sizes`는 그리드 열 수와 **일치**하도록 작성: 1열 `100vw`, 2열 `50vw` 근사, 3열 `33vw` 근사.

---

## 실전 예제: 아트 디렉션 + 포맷 전환 + 해상도 전환

```html
<picture>
  <!-- 데스크톱: 가로 구도, AVIF 우선 -->
  <source
    type="image/avif"
    media="(min-width: 1024px)"
    srcset="/hero-wide-1600.avif 1600w, /hero-wide-1200.avif 1200w"
    sizes="100vw">
  <source
    type="image/webp"
    media="(min-width: 1024px)"
    srcset="/hero-wide-1600.webp 1600w, /hero-wide-1200.webp 1200w"
    sizes="100vw">

  <!-- 태블릿: 보통 구도 -->
  <source
    type="image/avif"
    media="(min-width: 640px)"
    srcset="/hero-regular-1200.avif 1200w, /hero-regular-800.avif 800w"
    sizes="100vw">
  <source
    type="image/webp"
    media="(min-width: 640px)"
    srcset="/hero-regular-1200.webp 1200w, /hero-regular-800.webp 800w"
    sizes="100vw">

  <!-- 모바일 기본: 중앙 크롭 JPG 폴백 -->
  <img
    src="/hero-mobile-800.jpg"
    srcset="/hero-mobile-480.jpg 480w, /hero-mobile-800.jpg 800w"
    sizes="100vw"
    width="800" height="1000"
    alt="도시 야경 전경">
</picture>
```

---

## 브레이크포인트·자원 생성 전략

### 실무 추천 폭 세트(예시)

- 360, 480, 640, 768, 960, 1200, 1600, 2000(px)
  사이트 디자인·트래픽·이미지 용도에 따라 조정.

### 자동화 파이프라인(이미지 빌드)

- **원본 → 다중 크기/포맷** 변환(AVIF, WebP, JPG)
  예: Sharp/Imagemin/ImageMagick, CI/CD 스크립트, Headless CMS의 트랜스폼 기능, CDN(Cloudinary/Imgix/Akamai Image Manager) 등.
- 템플릿에서 `srcset`/`sizes`/`<picture>` 코드를 **자동 생성**.
- 캐시 정책: `Cache-Control: public, max-age=31536000, immutable` + **파일명에 해시**.

---

## 이미지 품질·용량 최적화 팁

- 사진: **AVIF**(최우선) → **WebP** → JPG 폴백.
- 그래픽/아이콘: **SVG**(가능하면 벡터), 아니면 PNG/WebP.
- JPEG: **프로그레시브** 인코딩 고려, 품질 70~85 범위 튜닝.
- AVIF/WebP: **색상 밴딩 확인**, 텍스트·선명 엣지에 적절한 품질 조정.
- 메타데이터 제거(용량 절감), 컬러 프로파일 관리(sRGB).

---

## 프리로드/프리커넥트로 LCP 향상

**가장 중요한 히어로 이미지**에는 프리로드:

```html
<link
  rel="preload"
  as="image"
  href="/hero-1200.avif"
  imagesrcset="/hero-800.avif 800w, /hero-1200.avif 1200w, /hero-1600.avif 1600w"
  imagesizes="100vw"
  type="image/avif">
```

이미지를 **서빙하는 외부 도메인**이라면 DNS/연결 선행:

```html
<link rel="preconnect" href="https://cdn.example.com" crossorigin>
```

---

## 흔한 실수와 해결책

| 문제 | 원인 | 해결 |
|---|---|---|
| 큰 이미지가 모바일에서도 내려받힘 | `sizes` 미작성/부정확 | 실제 레이아웃에 맞춰 `sizes` 정확히 작성 |
| 흐릿함 | DPR 고려 안 함 | `w` 후보 폭을 더 세분화, 또는 `x` 기술자로 2x/3x 제공 |
| CLS 발생 | 크기 미지정 | `width`/`height` 또는 `aspect-ratio` 지정 |
| 고효율 포맷인데도 용량 큼 | 과도한 품질 | 품질 낮추고 시각적 차이 검토(AVIF/WebP 재인코딩) |
| LCP 느림 | 프리로드 없음 | `rel=preload` + `fetchpriority="high"` 사용 |
| ALT 누락 | 접근성 저하 | 의미 있는 이미지에는 구체적인 `alt` 작성 |

---

## 디버깅: 어떤 후보가 선택됐는지 확인

- DevTools → Network 탭에서 실제로 받은 이미지의 **크기/타입** 확인
- Rendering 탭의 Emulate CSS Media, DPR 변경 테스트
- Lighthouse/PageSpeed로 **LCP/CLS** 체크

---

## 종합 예제: 기사 본문 + 썸네일 리스트 + 히어로

```html
<!-- 문서 헤드: 히어로 이미지 프리로드 -->
<link
  rel="preload"
  as="image"
  href="/images/hero-1600.avif"
  imagesrcset="/images/hero-1200.avif 1200w, /images/hero-1600.avif 1600w, /images/hero-2000.avif 2000w"
  imagesizes="100vw"
  type="image/avif">

<header class="hero">
  <picture>
    <source type="image/avif" srcset="/images/hero-1200.avif 1200w, /images/hero-1600.avif 1600w, /images/hero-2000.avif 2000w" sizes="100vw">
    <source type="image/webp" srcset="/images/hero-1200.webp 1200w, /images/hero-1600.webp 1600w, /images/hero-2000.webp 2000w" sizes="100vw">
    <img
      src="/images/hero-1600.jpg"
      srcset="/images/hero-1200.jpg 1200w, /images/hero-1600.jpg 1600w, /images/hero-2000.jpg 2000w"
      sizes="100vw"
      width="2000" height="1100"
      fetchpriority="high" decoding="async"
      alt="안개 낀 호수의 일출 전경">
  </picture>
</header>

<main class="content">
  <article class="post">
    <figure>
      <img
        src="/images/post-1200.jpg"
        srcset="/images/post-800.jpg 800w, /images/post-1200.jpg 1200w"
        sizes="(max-width: 768px) 100vw, 800px"
        width="1200" height="800"
        decoding="async"
        alt="산 능선을 따라 걷는 하이커">
      <figcaption>초가을 등산로</figcaption>
    </figure>
    <p>본문 내용...</p>
  </article>

  <aside class="thumbs">
    <img
      src="/images/thumb-320.jpg"
      srcset="/images/thumb-160.jpg 160w, /images/thumb-320.jpg 320w, /images/thumb-480.jpg 480w"
      sizes="(max-width: 600px) 33vw, 160px"
      width="320" height="200"
      loading="lazy" decoding="async"
      alt="작은 썸네일 1">
    <!-- 반복 ... -->
  </aside>
</main>

<style>
  .hero img { width: 100%; height: auto; display: block; }
  .content { max-width: 960px; margin: 0 auto; padding: 16px; }
  .thumbs img { margin-right: 8px; }
</style>
```

---

## 수학적 관점(요약)

브라우저는 대략 다음을 만족하는 후보를 고른다.

$$
\text{선택 후보의 실제 픽셀 폭} \approx \text{예상 표시 폭} \times \text{DPR}
$$

`예상 표시 폭`은 `sizes`로부터 얻는다. 실제 알고리즘은 각 브라우저 구현에 따라 세부 차이가 있지만, **핵심은 DPR과 표시 폭**이다.

---

## 체크리스트

- [ ] 중요한 이미지의 **폭/높이** 또는 **aspect-ratio** 지정(CLS 방지)
- [ ] **`srcset` + `sizes`**로 해상도 전환 구성
- [ ] **`<picture>`**로 아트 디렉션/포맷 전환
- [ ] **AVIF/WebP** 우선 + 합리적인 폴백
- [ ] LCP 후보는 **preload** + `fetchpriority="high"`
- [ ] 비가시 영역은 **`loading="lazy"`**
- [ ] DevTools·Lighthouse로 후보 선택/성능 검증
- [ ] 빌드/CI로 **자동 변환**·캐시 정책 일원화

---

## 참고 도구

- 이미지 변환: Sharp, Squoosh, ImageMagick, libvips
- 자동화/CDN: Cloudinary, Imgix, Akamai Image Manager
- 검증: Lighthouse, WebPageTest, PageSpeed Insights
- 브레이크포인트 생성: Responsive Image Breakpoints Generator

---

## 결론

- **`srcset` + `sizes`**로 브라우저가 **필요한 자원만** 고르게 하고,
- **`<picture>`**로 **아트 디렉션**과 **포맷 전환**을 처리하며,
- **폭/높이 명시**와 **레이지 로딩/프리로드**로 **CLS/LCP**를 개선하라.
- 자동화 파이프라인과 템플릿화를 도입해 **지속 가능한 운영**을 구축하면, 화면·밀도·네트워크가 달라도 **항상 최적의 경험**을 제공할 수 있다.
