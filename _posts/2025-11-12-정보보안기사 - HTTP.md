---
layout: post
title: 정보보안기사 - HTTP
date: 2025-11-12 16:25:23 +0900
category: 정보보안기사
---
# 완전 정리 (HTTP/1.0·1.1·2·3, 요청/응답 해부, 메서드/상태, 헤더/협상, 본문/전송, 커넥션/성능, 캐싱/조건부/Range, 압축, 인증, 쿠키, CORS, 프록시, 보안 이슈, 실습 코드/명령어)

## 개요 — “문서 전송 프로토콜에서 ‘웹 플랫폼의 공용 운반층’으로”

HTTP는 **요청–응답(Request–Response)** 모델의 애플리케이션 계층 프로토콜이다. 초기에는 문서를 가져오는 단순 규약이었지만, 오늘날에는 **API, 미디어 스트리밍, SPA/모바일, 마이크로서비스**까지 아우르는 **웹의 공용 운반층** 역할을 한다.
핵심은 다음과 같다:

- **버전별 진화**: 1.0(비지속) → 1.1(지속 연결/파이프라이닝/Host) → 2(프레이밍·멀티플렉싱·HPACK) → 3(QUIC/UDP·0-RTT·QPACK)
- **문법**: 시작줄(start-line) + 헤더(headers) + 빈 줄 + 본문(body)
- **의미론**: 메서드/상태/헤더의 조합으로 **의미**를 표현(안전성·멱등성·캐시 가능성)
- **운영/보안**: 캐싱·압축·TLS·인증·쿠키·CORS·프록시, 그리고 **스머글링/캐시 포이즈닝/CSRF/XSS** 같은 이슈

---

## HTTP 버전 한눈에

| 항목 | HTTP/1.0 | HTTP/1.1 | HTTP/2 | HTTP/3 |
|---|---|---|---|---|
| 연결 | 기본 **비지속**, `Connection: keep-alive` 확장 | 기본 **지속** | **하나의 TCP** 위 **멀티플렉싱(프레임/스트림)** | **QUIC(UDP)** 위 멀티플렉싱 |
| 식별 | `Host` 헤더 없음(가정) | `Host` **필수** | 바이너리 프레이밍, 헤더 압축 **HPACK** | **QPACK**, 0-RTT(재연 공격 주의) |
| 성능 | HOL 블로킹 심각 | 파이프라이닝(실전 거의 비활성), HOL 여전 | HOL 완화(스트림 단위), 서버푸시(사양상 비권장) | 커넥션 마이그레이션, 지연/손실에 강함 |
| 암호화 | 별도(TLS) | 별도(TLS) | **대개 TLS**(ALPN) | **필수 TLS(QUIC 내장)** |

> 오늘날의 기본은 **HTTPS(= HTTP + TLS)** 이며, HTTP/2·HTTP/3는 **ALPN**으로 협상된다.

---

## 요청/응답 메시지 해부

### 요청(Request)

```
GET /articles/123?lang=ko HTTP/1.1
Host: example.com
User-Agent: curl/8.7.1
Accept: text/html,application/xhtml+xml;q=0.9,*/*;q=0.8
Accept-Language: ko-KR,ko;q=0.9
If-None-Match: "v2-5c7f"
Connection: keep-alive

(본문 없음: GET)
```

### 응답(Response)

```
HTTP/1.1 200 OK
Date: Tue, 11 Nov 2025 01:30:00 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 5120
ETag: "v2-5c7f"
Cache-Control: public, max-age=600
Vary: Accept-Language

<html>...본문...</html>
```

- **시작줄**: 요청은 `메서드 SP 경로 SP 버전`, 응답은 `버전 SP 상태코드 SP 이유구문`
- **헤더**: 표준/확장 키-값, 다수 가능
- **본문**: 메서드·상태·헤더에 따라 유무/인코딩/길이가 달라진다

---

## 메서드 의미론(안전/멱등/캐시)

| 메서드 | 의미 | 안전(Safe) | 멱등(Idempotent) | 캐시 가능 |
|---|---|---|---|---|
| **GET** | 표현 조회 | ○ | ○ | ○(조건 있음) |
| **HEAD** | 헤더만 조회 | ○ | ○ | ○ |
| **POST** | 리소스 처리(생성/동작) | × | × | △(응답 캐시 가능하나 드묾) |
| **PUT** | 전체 대체(업서트) | × | ○ | △ |
| **PATCH** | 부분 수정 | × | ×(일반적) | △ |
| **DELETE** | 삭제 | × | ○ | △ |
| **OPTIONS** | 통신 가능성 탐색 | ○ | ○ | △ |
| **TRACE** | 루프백(보안상 비활성 권고) | ○ | ○ | × |
| **CONNECT** | 터널 설정(프록시) | × | × | × |

> **안전**: 서버 상태를 바꾸지 않음(이상적으로). **멱등**: 동일 요청을 여러 번 보내도 결과 동일(부수 효과 반복 없음).

---

## 상태 코드 체계

| 범주 | 의미 | 예 |
|---|---|---|
| **1xx** | 정보 | 100 Continue, 103 Early Hints |
| **2xx** | 성공 | 200 OK, 201 Created, 204 No Content |
| **3xx** | 리다이렉션 | 301/308 영구, 302/303/307 일시 |
| **4xx** | 클라이언트 오류 | 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 429 Too Many Requests |
| **5xx** | 서버 오류 | 500 Internal, 502 Bad Gateway, 503 Service Unavailable, 504 Gateway Timeout |

실무 팁:
- **201 Created**는 `Location` 헤더로 새 리소스 URI 제공
- **308 Permanent Redirect**는 **메서드 보존**, 301은 **일부 클라가 메서드 변경** 가능
- **429**와 `Retry-After`는 레이트 리밋과 함께 사용

---

## 대표 헤더 — 분류와 핵심

| 분류 | 대표 헤더 | 설명 |
|---|---|---|
| 요청 협상 | `Accept`, `Accept-Language`, `Accept-Encoding` | 컨텐츠/언어/압축 협상 |
| 캐시 | `Cache-Control`, `ETag`, `If-None-Match`, `If-Modified-Since`, `Vary`, `Age`, `Expires`, `Last-Modified` | 신선도/검증·변형 |
| 보안 | `Strict-Transport-Security`, `Content-Security-Policy`, `X-Content-Type-Options`, `Referrer-Policy`, `Permissions-Policy` | HTTPS 강제, XSS/스니핑 방지 등 |
| 인증 | `Authorization`, `WWW-Authenticate`, `Proxy-Authenticate` | Basic/Bearer/Negotiate 등 |
| 쿠키 | `Cookie`, `Set-Cookie` | 세션/설정 전달 |
| 네트워크 | `Connection`, `Transfer-Encoding`, `Content-Length`, `Host`, `TE`, `Trailer`, `Upgrade`, `Alt-Svc` | 연결/전송/대체 서비스 |
| 프록시/추적 | `Via`, `Forwarded`, `X-Forwarded-For/Proto/Host` | 경유지/원본 식별 |

---

## 콘텐츠 협상(Content Negotiation)

서버는 요청의 `Accept-*`를 참고하여 **최적 표현**을 선택하고, 응답에 `Vary`로 **선택 기준**을 명시한다.

```
GET /doc HTTP/1.1
Host: example.com
Accept: text/html, application/json;q=0.8
Accept-Language: ko-KR, en;q=0.8
```

응답(HTML 선택):
```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Vary: Accept, Accept-Language
```

**실습 포인트**: `Vary`가 누락되면 캐시가 **다른 언어/형식**을 잘못 제공(캐시 포이즈닝/오동작).

---

## 메시지 본문/전송: Content-Length vs Chunked, 멀티파트

### 고정 길이

- `Content-Length: N` 바이트로 본문 길이 고정

### 전송

- 길이를 모를 때/스트리밍: `Transfer-Encoding: chunked`
```
HTTP/1.1 200 OK
Transfer-Encoding: chunked

4\r\n
Wiki\r\n
5\r\n
pedia\r\n
0\r\n
\r\n
```

### 멀티파트(파일 업로드)

```
POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----xyz

------xyz
Content-Disposition: form-data; name="file"; filename="a.txt"
Content-Type: text/plain

...bytes...
------xyz--
```

---

## 연결 관리와 성능: Keep-Alive, 파이프라이닝, HTTP/2/3

- **HTTP/1.1**: 기본 **지속 연결**, 그러나 동일 TCP에서 **순차 처리**로 **HOL 블로킹** 발생. 파이프라이닝은 대개 비활성.
- **HTTP/2**: 하나의 TCP 연결에서 **스트림 단위 멀티플렉싱**, 헤더 압축 **HPACK**. **서버 푸시**는 현재 비권장.
- **HTTP/3(QUIC)**: **UDP 기반**, 스트림 독립 전송, **손실에도 전체 HOL 최소화**, **연결 ID**로 IP 변경에도 연결 지속, 0-RTT 재개(재연 공격 주의).

**간이 다이어그램 — H2 멀티플렉싱**
```
[클라이언트]====(TCP/TLS 하나)====[서버]
  스트림1: GET /a  ┐
  스트림3: GET /c  ├── 프레임 단위 교차 전송
  스트림5: GET /e  ┘
```

---

## 캐싱 완전정복(신선도·검증·재검증)

### 신선도(Heuristic/명시)

- `Cache-Control: public, max-age=600` → 600초 동안 **신선**
- `s-maxage`는 **공유 캐시**(프록시) 전용
- `immutable`은 리로딩 시 재검증 생략 힌트

### 조건부 요청(검증자)

- 강한 검증자 **`ETag`** / 약한 검증자 `W/"tag"`
- 시간 검증 **`Last-Modified` + `If-Modified-Since`**
- 클라이언트가 `If-None-Match` 또는 `If-Modified-Since`를 보내면 서버는 같을 시 **304 Not Modified**

### 근사(개념)

응답의 신선도 판단에서 **현재 연령** \(A\)는 대략:
\[
A \approx \text{Age} + (t_{\text{now}} - t_{\text{response\_received}})
\]
보다 정밀하게는 RFC의 여러 항(전송 지연/Date)을 고려하지만 실무 직관은 **Age + 네트워크 체류시간**.

### 실습 — `ETag` 및 재검증 플로우

1) 첫 GET → 200 + `ETag: "v2"` + `Cache-Control: max-age=600`
2) 10분 내 재요청 → 캐시 히트(서버 미접속)
3) 만료 후 재요청 → `If-None-Match: "v2"` → 서버가 변경 없음이면 304

---

## Range 요청(부분 전송)

대용량 파일 재개/병렬 다운로드 지원:

```
GET /video.mp4 HTTP/1.1
Range: bytes=1000-1999
```

응답:
```
HTTP/1.1 206 Partial Content
Content-Range: bytes 1000-1999/734003200
Content-Length: 1000
```

---

## 압축/콘텐츠 인코딩

- 요청: `Accept-Encoding: gzip, br`
- 응답: `Content-Encoding: br` (Brotli), `gzip`, `deflate`

**주의**: **이중 압축**(중복 인코딩) 금지, 파일형식(예: PNG/MP4) 재압축 무의미.
`Vary: Accept-Encoding`을 잊지 말 것.

---

## 인증(Authentication)

### Basic

```
Authorization: Basic base64(username:password)
WWW-Authenticate: Basic realm="admin"
```
- TLS 필수(평문 노출 위험)

### Bearer (예: JWT)

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
WWW-Authenticate: Bearer realm="api", error="invalid_token"
```
- 토큰 수명/회수/스코프 관리

### Mutual TLS(클라이언트 인증서)

- 양방향 인증, 게이트웨이/API 보안 고강도

---

## 쿠키/세션

`Set-Cookie` 속성:

- `Secure`(HTTPS에서만), `HttpOnly`(JS 접근 차단), `SameSite=Lax/Strict/None`
- 수명: `Expires` 또는 `Max-Age`
- 도메인/경로 범위: `Domain`, `Path`

예:
```
Set-Cookie: sid=abc123; Path=/; Secure; HttpOnly; SameSite=Lax
```

---

## CORS(교차 출처 리소스 공유)

### 단순 요청 vs 프리플라이트(OPTIONS)

프리플라이트 예:
```
OPTIONS /api HTTP/1.1
Origin: https://app.example
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Content-Type, Authorization
```

응답:
```
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://app.example
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 600
```

- `Access-Control-Allow-Credentials: true` 사용 시 **정확한 Origin** 에코 필요 (`*` 불가).

---

## 프록시/게이트웨이/리버스 프록시

- **Forward Proxy**: 클라이언트 대리(캐싱/정책)
- **Reverse Proxy**: 서버 앞단(로드밸런싱/캐시/보안) — NGINX/Envoy/HAProxy
- **CONNECT 터널**: `CONNECT host:443 HTTP/1.1` → TLS 터널

원본 식별 헤더:
- 표준 `Forwarded: for=203.0.113.5; proto=https; host=example.com`
- 널리 쓰는 `X-Forwarded-For`, `X-Forwarded-Proto`, `X-Forwarded-Host`

---

## 보안 이슈(실무 집중)

### 요청 스머글링(Request Smuggling)

- 전형: **CL.TE/TE.CL** 불일치, 중개자-백엔드의 파싱 차이 악용
- 완화: 프록시/백엔드 **파서 일치**, `Transfer-Encoding` 엄격 처리, 불명확 메시지 **거부**

### 캐시 포이즈닝

- `Vary` 누락/잘못된 인덱싱/헤더 혼동으로 **다른 사용자에게 변조된 응답** 제공
- 완화: `Vary` 정확화, 캐시 키 구성 검토, 위험 헤더 제거

### CSRF/XSS/혼합 콘텐츠

- CSRF: **SameSite 쿠키**, CSRF 토큰, `Origin/Referer` 검증
- XSS: **CSP**, 출력 인코딩, `X-Content-Type-Options: nosniff`
- 혼합 콘텐츠: HSTS + 모든 리소스 HTTPS

### HSTS

```
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```
- 브라우저가 **HTTP 요청 자체를 차단/업그레이드**

---

## 실습 코드 — Flask(파이썬): 협상/캐싱/조건부/Range

```python
# app.py

from flask import Flask, request, make_response, send_file, abort
from datetime import datetime, timezone
import hashlib, os

app = Flask(__name__)

DOC = {
    "ko": "<h1>문서</h1><p>한국어</p>",
    "en": "<h1>Document</h1><p>English</p>"
}
ETAG = '"v2-5c7f"'
LAST_MOD = datetime(2025, 11, 1, 0, 0, 0, tzinfo=timezone.utc)

def pick_lang(accept):
    # 간이 파서: ko 우선
    return "ko" if accept and "ko" in accept else "en"

@app.route("/doc")
def doc():
    lang = pick_lang(request.headers.get("Accept-Language", "en"))
    body = DOC[lang]
    # 조건부 요청 처리
    inm = request.headers.get("If-None-Match")
    ims = request.headers.get("If-Modified-Since")
    if inm == ETAG:
        resp = make_response("", 304)
        resp.headers["ETag"] = ETAG
        resp.headers["Vary"] = "Accept-Language"
        return resp
    if ims:
        try:
            ims_dt = datetime.strptime(ims, "%a, %d %b %Y %H:%M:%S %Z")
            if ims_dt >= LAST_MOD:
                resp = make_response("", 304)
                resp.headers["ETag"] = ETAG
                resp.headers["Vary"] = "Accept-Language"
                return resp
        except Exception:
            pass
    resp = make_response(body)
    resp.headers["Content-Type"] = "text/html; charset=utf-8"
    resp.headers["Cache-Control"] = "public, max-age=600, immutable"
    resp.headers["ETag"] = ETAG
    resp.headers["Last-Modified"] = LAST_MOD.strftime("%a, %d %b %Y %H:%M:%S GMT")
    resp.headers["Vary"] = "Accept-Language"
    return resp

@app.route("/file")
def file_range():
    # 단순 Range 처리(데모용), 실제로는 send_file(range_support=True) 사용 권장
    path = "big.bin"
    if not os.path.exists(path):
        with open(path, "wb") as f:
            f.write(os.urandom(2_000_000))
    size = os.path.getsize(path)
    rng = request.headers.get("Range")
    if not rng:
        return send_file(path, mimetype="application/octet-stream")
    try:
        # Range: bytes=start-end
        units, spec = rng.split("=")
        if units != "bytes":
            abort(416)
        start_str, end_str = spec.split("-")
        start = int(start_str) if start_str else 0
        end = int(end_str) if end_str else size - 1
        if start > end or end >= size:
            abort(416)
        length = end - start + 1
        with open(path, "rb") as f:
            f.seek(start)
            data = f.read(length)
        resp = make_response(data, 206)
        resp.headers["Content-Type"] = "application/octet-stream"
        resp.headers["Content-Range"] = f"bytes {start}-{end}/{size}"
        resp.headers["Content-Length"] = str(length)
        return resp
    except Exception:
        abort(416)

if __name__ == "__main__":
    app.run("0.0.0.0", 8080, debug=True)
```

테스트:
```bash
# 협상 + 캐시

curl -H "Accept-Language: ko" -i http://127.0.0.1:8080/doc
# 재검증(If-None-Match)

curl -H 'If-None-Match: "v2-5c7f"' -i http://127.0.0.1:8080/doc
# Range

curl -H "Range: bytes=0-99" -i http://127.0.0.1:8080/file
```

---

## 실습 코드 — Node.js(Express): CORS, HSTS, 압축

```javascript
// server.js
const express = require("express");
const compression = require("compression");
const helmet = require("helmet");
const app = express();

app.use(helmet({
  contentSecurityPolicy: false, // 예시 간소화
  crossOriginOpenerPolicy: { policy: "same-origin" }
}));
app.use((req, res, next) => {
  // HSTS (실서비스는 reverse proxy에서 설정 권장)
  res.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload");
  next();
});
app.use(compression()); // gzip/deflate, 브라우저와 협상

// CORS (정밀 설정 필요)
app.use((req, res, next) => {
  const origin = req.headers.origin;
  if (origin === "https://app.example") {
    res.setHeader("Access-Control-Allow-Origin", origin);
    res.setHeader("Vary", "Origin");
    res.setHeader("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
    res.setHeader("Access-Control-Allow-Credentials", "true");
    if (req.method === "OPTIONS") return res.sendStatus(204);
  }
  next();
});

app.get("/api", (req, res) => {
  res.json({ ok: true, ts: Date.now() });
});

app.listen(8443, () => console.log("HTTP demo on 8443 (behind TLS proxy)"));
```

---

## NGINX 리버스 프록시 — H2/H3, HSTS, 캐시 키/변형

```nginx
# /etc/nginx/nginx.conf (일부)

http {
  # HTTP/2, HTTP/3(QUIC) 지원(빌드/패키지 의존)
  # listen 443 ssl http2;  # H2
  # listen 443 quic reuseport;  # H3

  server {
    listen 443 ssl http2;
    server_name example.com;

    ssl_certificate     /etc/ssl/cert.pem;
    ssl_certificate_key /etc/ssl/key.pem;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    add_header X-Content-Type-Options "nosniff" always;

    # 캐시 변형: 언어/인코딩별
    proxy_cache_key "$scheme$proxy_host$request_uri$accept_language$accept_encoding";
    proxy_set_header Accept-Language $http_accept_language;
    proxy_set_header Accept-Encoding $http_accept_encoding;

    location / {
      proxy_pass http://127.0.0.1:8080;
      proxy_http_version 1.1;
      proxy_set_header Connection "";
    }
  }
}
```

---

## 성능·TLS·HTTP/2·HTTP/3 팁

- **TLS**: 세션 재개/OCSP 스테이플링/최신 스위트, ALPN으로 H2/H3 협상
- **H2**: **우선순위 조정**(서버/클라 구현 상이), **리소스 합치기 필요↓**, 서버푸시는 대체로 비권장
- **H3**: 연결 마이그레이션/손실 회복, **0-RTT 재연 공격 가능성** → **안전한 재요청(멱등)**에만 허용

---

## 진단/디버깅 도구

```bash
# 원시 교환 보기

curl -v https://example.com/
# 헤더만

curl -I https://example.com/
# H2 강제

curl --http2 -I https://example.com/
# H3 강제(빌드/OS 의존)

curl --http3 -I https://example.com/
# 압축/콘텐츠

curl -H "Accept-Encoding: br,gzip" -I https://example.com/
# 캐시 검증

curl -H 'If-None-Match: "v2-5c7f"' -I https://example.com/doc
```

브라우저: DevTools **Network** 탭에서 **proto(h2/h3)**, **content-encoding**, **cache** 칼럼 확인.

---

## 체크리스트(운영/개발)

- [ ] **HTTPS 기본화**(리디렉션 + HSTS)
- [ ] 적절한 **캐시 정책**: `Cache-Control`, `ETag/Last-Modified`, `Vary`
- [ ] **압축** 활성 + `Vary: Accept-Encoding`
- [ ] **CORS** 최소 원칙/정확한 `Origin` 에코(자격증명 시)
- [ ] **보안 헤더**: CSP, HSTS, XCTO, Referrer-Policy, Permissions-Policy
- [ ] **요청 스머글링 방지**: 파서 일치, TE/CL 엄격 검증
- [ ] **쿠키 보안**: `Secure`, `HttpOnly`, `SameSite`
- [ ] **로그/관측**: 접근/에러/지표(레이트·지연·오류율), 추적 ID
- [ ] **HTTP/2·3**: 이점/함정 이해(푸시 비권장, 0-RTT 재연)
- [ ] **프록시/캐시**: `Forwarded`/`X-Forwarded-*` 정합, 캐시 키 정의

---

## 미니 연습 문제(실기 스타일)

1. **조건부 요청 구성**: ETag `"v5"`가 있는 `/doc`에 대해, 클라이언트가 리밸리데이션을 시도하도록 `curl` 헤더 1줄을 작성하라.
   _예상 답_: `-H 'If-None-Match: "v5"'`

2. **Vary 누락 버그**: `Accept-Language`에 따라 다른 HTML을 주는 엔드포인트가 `Vary: Accept-Language`를 보내지 않았다. 캐시 레이어에서 어떤 문제가 생기며, 어떻게 고칠까?
   _요지_: 한국어 응답이 영어 사용자에게 캐시로 제공될 수 있음 → `Vary: Accept-Language` 설정.

3. **Range 응답**: 1GiB 파일에서 첫 1MiB를 받는 `curl` 명령을 쓰고, 서버가 주어야 할 핵심 헤더 2개를 쓰라.
   _예시_: `curl -H 'Range: bytes=0-1048575' -I URL` / 헤더: `206`, `Content-Range`, `Content-Length`.

4. **CORS와 자격 증명**: 쿠키를 동반한 CORS 요청을 허용하려면 `Access-Control-Allow-Origin`과 어떤 헤더를 추가로 보내야 하는가?
   _답_: `Access-Control-Allow-Credentials: true`(와 함께 `*`가 아닌 정확한 Origin).

5. **스머글링 방어**: CL.TE 불일치로 인한 스머글링을 막기 위해 게이트웨이와 백엔드에서 각각 무엇을 점검/설정해야 하나?
   _요지_: 동일 파싱 규칙, 중복/모호한 `Content-Length/Transfer-Encoding` 거부, 표준 구현 업데이트.

---

## 덤: 지연·캐시 히트 직관(간단 수식)

### 왕복 지연(RTT)와 핸드셰이크 비용 직관

HTTP/1.1 + TLS 1.2 초연결에서 초기 요청까지 대략 \( \approx 2\sim3 \) RTT가 필요.
HTTP/2 재사용/HTTP/3 0-RTT 재개 시 **RTT 비용 절감**으로 체감 성능 개선.

### 캐시 히트율 근사

\[
H \approx 1 - e^{-\lambda T}
\]
- \( \lambda \): 특정 리소스 요청률(1/s), \(T\): TTL(s)
TTL을 늘리면 히트율이 증가하나, **전파/정합성**과 **보안 핫픽스 반영**에 유의.

---

## 요약

- HTTP는 **요청–응답**, **헤더·본문**의 조합으로 의미를 표현하고, 버전 업을 통해 **HOL 완화, 헤더 압축, 전송 신뢰성**을 개선해 왔다.
- 실무 핵심은 **캐시/조건부/Range**로 **대역폭과 지연 최적화**, **압축/협상**으로 **전송 효율**, **TLS/H2/H3**로 **보안·성능** 동시 달성이다.
- 보안 면에서 **스머글링/캐시 포이즈닝/CSRF/CORS 오구성**에 주의하고, **HSTS/CSP/쿠키 속성**을 정확히 적용하라.
- 본 문서의 **Flask/Express/NGINX 예제**와 **curl 실습**을 그대로 따라해 **동작·헤더·캐시**를 눈으로 확인하면 HTTP의 “행동”이 체득된다.
