---
layout: post
title: DB 심화 - 아우터 조인
date: 2025-11-10 21:25:23 +0900
category: DB 심화
---
# Outer Join 총정리 — Outer NL / Outer SMJ / Outer HJ / Full Outer, 의미 보존·변환·튜닝까지

모든 예제는 **Oracle** 기준이며, 실행 후에는 반드시 **실측 플랜**을 확인하세요.

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS +NOTE'
       ));
```

> 메모  
> - `+PREDICATE`로 **ON/WHERE에서 어떤 조건이 어디에 적용됐는지** 확인.  
> - `+MEMSTATS`로 **PGA/TEMP 스필 여부** 확인.  
> - `+NOTE`로 **Outer→Inner 변환, Join Elimination, Predicate Move-Around** 같은 CQT 흔적 확인. :contentReference[oaicite:0]{index=0}  

---

## 0. 실습 환경 준비

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET workarea_size_policy = AUTO;   -- hash/sort 메모리 자동
-- 필요 시 버전 고정(테스트용)
-- ALTER SESSION SET optimizer_features_enable = '19.1.0';
```

---

## 1. 실습 스키마 (고객–주문–배송)

> - **CUST**: 모든 고객 (보존측 후보)  
> - **ORD** : 일부 고객만 주문  
> - **SHP** : 일부 주문만 배송  

```sql
DROP TABLE SHP PURGE;
DROP TABLE ORD PURGE;
DROP TABLE CUST PURGE;

CREATE TABLE CUST(
  CUST_ID  NUMBER       PRIMARY KEY,
  NAME     VARCHAR2(30) NOT NULL,
  TIER     VARCHAR2(8)  NOT NULL,
  REGION   VARCHAR2(8)  NOT NULL
);

CREATE TABLE ORD(
  ORDER_ID NUMBER       PRIMARY KEY,
  CUST_ID  NUMBER       NOT NULL,
  ORDER_DT DATE         NOT NULL,
  STATUS   VARCHAR2(8)  NOT NULL
);

CREATE TABLE SHP(
  ORDER_ID NUMBER       NOT NULL,
  SHIP_DT  DATE,
  CARRIER  VARCHAR2(12),
  CONSTRAINT PK_SHP PRIMARY KEY (ORDER_ID)
);

CREATE INDEX IX_ORD_CUST ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_SHP_ORD  ON SHP(ORDER_ID);

BEGIN
  FOR c IN 1..20 LOOP
    INSERT INTO CUST VALUES(
      c,
      'CUST_'||TO_CHAR(c,'FM00'),
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
                    WHEN 2 THEN 'SILVER' ELSE 'GEN' END,
      CASE MOD(c,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END
    );
  END LOOP;

  -- 주문: 일부 고객만 주문 (1..12만)
  FOR o IN 1..50 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,12)+1,
      DATE '2024-01-01' + MOD(o,120),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  -- 배송: 일부 주문만 배송 (짝수 주문만)
  FOR s IN 2..50 BY 2 LOOP
    INSERT INTO SHP VALUES(
      s,
      DATE '2024-02-01' + MOD(s,90),
      CASE MOD(s,3) WHEN 0 THEN 'UPS' WHEN 1 THEN 'DHL' ELSE 'FEDEX' END
    );
  END LOOP;

  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SHP' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## 2. Outer Join의 논리: “NULL 공급 측”과 의미 보존

### 2.1 용어

- **Preserved side (보존측)**: 결과에서 **항상 유지되는 쪽**  
- **Null-supplying side (NULL 공급측)**: 매칭이 없을 때 **NULL로 채워지는 쪽**  
- LEFT OUTER의 preserved side는 **왼쪽**, RIGHT OUTER는 **오른쪽**, FULL OUTER는 **양쪽**. :contentReference[oaicite:1]{index=1}  

### 2.2 관계대수 관점(직관 식)

LEFT OUTER JOIN은 “INNER 결과 + 왼쪽에서 매칭 없는 행을 NULL로 보강”입니다.

$$
R\ \text{LEFT OUTER JOIN}\ S
= (R \Join S)\ \cup\ (R\setminus \pi_R(R\Join S))\times \{\text{NULL rows of }S\}
$$

이 식 때문에 “**어느 쪽을 보존하냐**”가 메소드/조인 순서/프레디킷 배치의 모든 기준이 됩니다.

---

## 3. ON vs WHERE: Outer Join 성능/의미를 갈라놓는 1순위 규칙

Outer Join에서 **WHERE절은 조인 이후 필터**, ON절은 **조인 조건 자체**입니다.  
특히 **NULL 공급측 컬럼에 대한 WHERE 필터는 NULL 행을 제거**해 조인이 **사실상 INNER로 바뀌는** 것이 핵심 함정입니다. :contentReference[oaicite:2]{index=2}  

### 3.1 “Null-rejecting predicate”가 INNER화를 만든다

- **Null-rejecting predicate**: NULL이 들어오면 FALSE/UNKNOWN이 되는 조건  
  - 예: `s.carrier='DHL'`, `s.ship_dt >= ...`, `s.col IS NOT NULL`, `s.col > 0`

```sql
-- 의도: 배송 없는 주문도 보여달라(LEFT OUTER)
-- 실제: WHERE에서 null-rejecting → 배송 없는 주문 제거 → INNER화
SELECT o.order_id, s.carrier
FROM   ORD o
LEFT JOIN SHP s ON s.order_id = o.order_id
WHERE  s.carrier = 'DHL';           -- ❌
```

```sql
-- 보존 유지: null-rejecting을 ON으로 이동
SELECT o.order_id, s.carrier
FROM   ORD o
LEFT JOIN SHP s
       ON s.order_id = o.order_id
      AND s.carrier  = 'DHL';       -- ✅
```

### 3.2 “의도적 INNER화”가 필요할 때

가끔은 **보존 의미를 없애고 싶다**면 WHERE에 둬도 됩니다.  
이때는 **CBO가 Outer→Inner 변환을 수행**할 수 있으며 `+NOTE`에 흔적이 남습니다. :contentReference[oaicite:3]{index=3}  

---

## 4. Oracle CBO가 Outer Join에 대해 수행하는 주요 변환(CQT)

Outer Join은 **의미 보존 제약 때문에 변환/푸시다운이 제한**됩니다.  
CBO는 **가능한 범위에서만** 다음을 수행합니다.

1) **Outer → Inner 변환**  
   - null-supplying side에 null-rejecting predicate가 상위에 있으면 의미적으로 INNER와 동일해져 변환.  
2) **Predicate Move-Around / Pushdown 제한**  
   - preserved side의 필터는 아래로 잘 내려가지만, null-supplying side 필터는 조심스럽게만 이동.  
3) **Join Elimination(조인 제거)**  
   - FK/UK로 preserved side만 필요하면 null-supplying table을 제거 가능.  
4) **Join Order 제약**  
   - Outer Join은 보존측이 유지돼야 하므로 **완전 자유로운 재배치가 불가**.  

이 제약이 **Outer NL/SMJ/HJ 각각의 “드라이빙(보존측) 배치” 원칙**으로 이어집니다.

---

## 5. Outer Nested Loops Join (NESTED LOOPS OUTER)

### 5.1 메커니즘

- **Outer(보존) 입력을 드라이빙**(outer row source)  
- 각 outer row마다 inner( NULL 공급측 )을 **인덱스로 lookup**  
- 매칭이 없으면 inner 컬럼을 NULL로 만들어 출력.

즉, NL OUTER는 “**보존측을 빠르게 뽑아야 이긴다**”가 모든 전제입니다.  
`USE_NL` 계열 힌트가 NL 메소드를 강제하며, 대상 테이블을 inner로 삼는 의미입니다. :contentReference[oaicite:4]{index=4}  

### 5.2 언제 최적인가?

- **Top-N/부분범위/화면 조회**  
- **조기 종료(Stopkey)**가 성능을 좌우  
- NULL 공급측에 **강한 인덱스 lookup**이 가능한 경우  

### 5.3 예제 1 — VIP 고객의 최근 주문 10건, 배송 없으면 표시

```sql
SELECT /*+
          ORDERED
          LEADING(c o s)
          USE_NL(o) USE_NL(s)
          INDEX(o IX_ORD_CUST)
       */
       c.cust_id, c.name, o.order_id, o.order_dt,
       COALESCE(s.carrier, 'NO_SHIPMENT') AS carrier
FROM   CUST c
LEFT  JOIN ORD o
       ON o.cust_id = c.cust_id
LEFT  JOIN SHP s
       ON s.order_id = o.order_id
WHERE  c.tier = 'VIP'
ORDER  BY o.order_dt DESC NULLS LAST, o.order_id DESC NULLS LAST
FETCH FIRST 10 ROWS ONLY;
```

**관측 포인트**

- 플랜에 `NESTED LOOPS OUTER`가 보이는지  
- `STOPKEY`/`COUNT STOPKEY` 같은 조기 종료 연산이 들어오는지  
- `Buffers`가 **Top-N에 비례해 매우 작게 유지**되는지  

### 5.4 예제 2 — “0건 고객 포함” 여부 확인용 NL OUTER

```sql
SELECT /*+ LEADING(c o) USE_NL(o) */
       c.cust_id, c.name, o.order_id
FROM   CUST c
LEFT  JOIN ORD o
       ON o.cust_id = c.cust_id
WHERE  c.region = 'EMEA'
ORDER  BY c.cust_id;
```

- `o.order_id`가 NULL인 행이 **“주문 없는 고객”**.
- NL OUTER로 보면 **존재 확인**을 매우 싸게 할 수 있음.

### 5.5 NL OUTER의 대표적 실패 패턴

1) **보존측이 크고 필터가 약함** → outer rows 폭증 → inner lookup 폭증  
2) inner 쪽 인덱스가 약하거나 CF가 높아 랜덤 I/O가 비쌈  
3) Top-N이 아닌 배치형 쿼리에 NL을 강제  

**증상**  
- `A-Rows`가 커지고 `Buffers`가 outer rows에 비례해 급증  
- Elapsed가 outer rows에 선형 증가

---

## 6. Outer Sort-Merge Join (MERGE JOIN OUTER)

### 6.1 메커니즘

- 양 입력을 **조인 키 순으로 정렬**(또는 이미 정렬된 스트림)  
- **머지 스캔**하면서 매칭/보존을 수행  
- null-supplying side는 매칭 실패 시 NULL을 공급.

`USE_MERGE` 힌트가 SMJ를 강제합니다. :contentReference[oaicite:5]{index=5}  

### 6.2 언제 최적인가?

- **대량 데이터**라도 정렬 비용이 감당 가능할 때  
- **비등치 OUTER**(기간/범위 매핑)  
- 한쪽이 **인덱스 정렬을 그대로 활용**할 수 있을 때  

### 6.3 예제 1 — LEFT OUTER + SMJ 기본

```sql
SELECT /*+
          ORDERED
          LEADING(o s)
          USE_MERGE(s)
       */
       o.order_id, o.order_dt, s.ship_dt, s.carrier
FROM   ORD o
LEFT  JOIN SHP s
       ON s.order_id = o.order_id
WHERE  o.order_dt >= DATE '2024-02-01';
```

**관측 포인트**

- 플랜에 `MERGE JOIN OUTER` + `SORT JOIN`  
- `+MEMSTATS`에 **TempSpc 증가**가 있는지 (정렬 스필)  
- 인덱스로 정렬이 대체됐는지(`INDEX FULL SCAN` + `SORT` 제거)

### 6.4 예제 2 — 비등치 OUTER(기간/순서 매핑)

“주문일 이후의 첫 배송(없으면 NULL)” 같은 패턴은 ON절에 비등치 조건을 둔 OUTER SMJ가 자연스럽습니다.

```sql
SELECT /*+ USE_MERGE(s) */
       o.order_id, o.order_dt, s.ship_dt, s.carrier
FROM   ORD o
LEFT  JOIN SHP s
       ON s.order_id = o.order_id
      AND s.ship_dt >= o.order_dt        -- 비등치 조건은 ON
WHERE  o.order_dt >= DATE '2024-02-01';
```

- 비등치가 WHERE로 내려가면 INNER화 위험.
- SMJ OUTER는 이렇게 **비등치 + 보존**을 가장 안정적으로 구현하는 편입니다.

### 6.5 SMJ OUTER의 대표적 실패 패턴

1) 양쪽 모두 정렬이 필요하고 입력이 큼 → TEMP 과다  
2) 실제로는 Top-N/부분범위인데 SMJ를 강제 → 조기 종료 이점 상실  
3) 조인 키 분포 스큐로 정렬/머지 효율 저하  

---

## 7. Outer Hash Join (HASH JOIN OUTER)

### 7.1 메커니즘

Hash Join OUTER는 기본 Hash Join의 빌드/프로브 구조에 **보존 의미**만 추가됩니다.

- **Build**: 상대적으로 작은 입력을 PGA에 해시 테이블로 구성  
- **Probe**: 큰 입력을 스캔하며 매칭  
- 매칭 실패 시, preserved side 행은 출력되고 다른 쪽은 NULL

Oracle 튜닝 가이드에 Hash Outer Join의 전형적 플랜이 설명돼 있습니다. :contentReference[oaicite:6]{index=6}  

### 7.2 언제 최적인가?

- **대량 스캔/집계형 LEFT/RIGHT OUTER**  
- 인덱스 NL이 의미 없고 조기 종료가 필요 없는 배치/리포트  
- 병렬/스타 조인에서 Bloom Filter와 결합될 때  

### 7.3 빌드/프로브 제어

- `USE_HASH(t)` 로 해시 조인을 유도  
- `SWAP_JOIN_INPUTS(t)` 로 특정 해시 조인의 빌드/프로브를 교체 가능. :contentReference[oaicite:7]{index=7}  

> 실무 원칙  
> - **빌드 입력은 최대한 작게**(필터/집계/프루닝).  
> - 스필이 나면 `TempSpc` 상승.  
> - 외부조인에서도 원칙은 동일.

### 7.4 예제 — “0건 고객 포함, 고객별 주문수”

```sql
WITH O_SUM AS (
  SELECT /*+ MATERIALIZE */
         o.cust_id, COUNT(*) cnt
  FROM   ORD o
  WHERE  o.order_dt >= DATE '2024-02-01'
  GROUP  BY o.cust_id
)
SELECT /*+
          ORDERED
          LEADING(c os)
          USE_HASH(os)
          NO_USE_NL(os) NO_USE_MERGE(os)
       */
       c.cust_id, c.name, NVL(os.cnt,0) AS orders_since_feb
FROM   CUST c
LEFT  JOIN O_SUM os
       ON os.cust_id = c.cust_id
WHERE  c.region = 'APAC';
```

**관측 포인트**

- `HASH JOIN OUTER`  
- `TempSpc`가 0이면 **원패스**, 증가하면 **하이브리드/멀티패스 스필**  
- 빌드가 O_SUM(작은 집계)으로 잡혔는지

### 7.5 HJ OUTER의 대표적 실패 패턴

1) 빌드가 커져 스필 → TEMP I/O 병목  
2) 조인 키 스큐 → 특정 버킷 과밀(Probe가 길게 늘어짐)  
3) 사실은 Top-N/부분범위인데 HJ OUTER를 강제 → 불리  

---

## 8. Full Outer Join

### 8.1 의미

- 양쪽 모두 보존  
- 매칭 없으면 상대측 컬럼이 NULL  

### 8.2 메소드

Oracle은 상황에 따라

- `MERGE JOIN FULL OUTER`  
- `HASH JOIN FULL OUTER`  

를 선택합니다. (입력 규모/정렬/메모리/통계에 좌우)

### 8.3 기본 예제

```sql
SELECT /*+ USE_HASH(o) */
       c.cust_id, c.name, o.order_id, o.order_dt
FROM   CUST c
FULL  OUTER JOIN ORD o
       ON o.cust_id = c.cust_id;
```

**WHERE 필터 주의**

```sql
-- FULL OUTER의 보존을 WHERE가 깨뜨릴 수 있다.
SELECT c.cust_id, c.name, o.order_id
FROM   CUST c
FULL OUTER JOIN ORD o ON o.cust_id = c.cust_id
WHERE  c.region='EMEA' OR o.status='PAID';  -- NULL 행 제거 가능성
```

- 이런 조건의 상당수는 ON절로 옮기는 게 안전하다.
- `+PREDICATE`로 실제 적용 위치를 반드시 확인.

### 8.4 재작성: FULL OUTER = LEFT OUTER ∪ RIGHT ANTI

관계대수적으로 FULL OUTER는 다음으로 분해 가능합니다.

$$
R\ \text{FULL OUTER JOIN}\ S
\equiv
(R\ \text{LEFT JOIN}\ S)
\ \cup\
(S\ \text{LEFT ANTI JOIN}\ R)
$$

```sql
WITH L AS (
  SELECT c.cust_id, c.name, o.order_id, o.order_dt
  FROM   CUST c
  LEFT  JOIN ORD o ON o.cust_id = c.cust_id
),
RA AS (
  SELECT NULL AS cust_id, NULL AS name, o.order_id, o.order_dt
  FROM   ORD o
  WHERE  NOT EXISTS (
          SELECT 1
          FROM   CUST c
          WHERE  c.cust_id = o.cust_id
        )
)
SELECT * FROM L
UNION ALL
SELECT * FROM RA;
```

- Oracle이 내부적으로 유사한 변환을 수행하는 경우도 있으니 `+NOTE`를 확인.

---

## 9. ANSI OUTER vs 구식 `(+)`

- ANSI 조인(`LEFT/RIGHT/FULL OUTER JOIN`)이 **표현력·가독성·변환 안정성**에서 압도적으로 유리합니다.
- `(+)`는
  - 복수 OUTER 혼합에서 의미가 불명확해지고  
  - 프레디킷 배치 오류로 INNER화 사고가 잦습니다.  
가능하면 **완전 배제**하세요.

---

## 10. 최신(23ai/21c 계열)에서의 OUTER Join 관련 변화 포인트

최근 릴리스에서는 **벡터화/인메모리 조인 프레임워크가 OUTER/FULL까지 확장**되면서,
대용량 분석 워크로드에서 Hash/Hybrid OUTER가 더 빨라질 수 있습니다.  
따라서 “예전보다 HJ OUTER가 더 잘 선택되거나 더 효율적으로 동작”하는 케이스가 증가하는 추세입니다. :contentReference[oaicite:8]{index=8}  

> 실무적으로는  
> - 통계 정확도(히스토그램/확장통계)  
> - PGA/TEMP 정책  
> - 병렬/인메모리 옵션  
> 에 따라 OUTER 메소드 선택이 더 민감해졌다고 보면 됩니다.

---

## 11. 성능/튜닝 체크리스트(현업용)

1) **의도 재확인**  
   - preserved side가 어디인가?  
   - 결과에서 NULL이 나와야 하는가?

2) **프레디킷 위치**  
   - NULL 공급측의 null-rejecting predicate는 **ON절**로. :contentReference[oaicite:9]{index=9}  
   - WHERE는 “조인 후 필터”임을 항상 의식.

3) **메소드 선택**  
   - **NL OUTER**: Top-N/부분범위, 조기 종료, inner 인덱스 lookup 강함  
   - **SMJ OUTER**: 대량/정렬 기반, 비등치 OUTER  
   - **HJ OUTER**: 대량 스캔/집계, 인덱스 의미 없음, 병렬/스타

4) **조인 순서**  
   - 보존측이 **드라이빙**되도록(특히 NL).  
   - HJ/SMJ도 “빌드/정렬 부담이 작아지는 방향”으로 순서를 고려.

5) **메모리/스필 확인**  
   - `+MEMSTATS`에서 TempSpc  
   - 스필이 보이면 빌드 축소/조인 순서 변경/집계 선행 고려.

6) **통계/분포**  
   - Outer Join은 변환이 제한적이므로 **카디널리티 오판이 더 치명적**.  
   - 스큐 컬럼 히스토그램/확장 통계로 보정.

7) **플랜 안정화**  
   - 필요한 최소 힌트만: `LEADING/ORDERED + USE_*_OUTER`  
   - 반복 회귀가 있으면 Baseline/Profile/Patch 고려.

---

## 12. 트러블슈팅 패턴 모음

### 12.1 LEFT OUTER가 INNER처럼 나온다

- WHERE에 null-rejecting predicate가 있음.
- 해결: **ON절 이동** + `+PREDICATE` 확인.

### 12.2 NL OUTER가 느리다

- 보존측(outer rows)이 큼/필터 약함.
- inner 인덱스 CF가 높아 랜덤 I/O 비쌈.
- 해결:  
  1) 보존측 필터 강화/순서 조정  
  2) HJ/SMJ로 전환 실험  
  3) inner 인덱스/물리 정렬 개선

### 12.3 HJ OUTER가 TEMP를 많이 쓴다

- 빌드가 커서 스필.
- 해결:  
  1) 빌드 입력 축소(집계/프루닝)  
  2) `SWAP_JOIN_INPUTS`로 빌드 교체  
  3) PGA 정책/동시성 점검

### 12.4 FULL OUTER에서 WHERE 추가 후 행이 사라진다

- WHERE가 NULL 행을 제거.
- 해결: 필터를 ON으로 옮기거나 CASE/NVL로 의미 보존.

---

## 13. 실습용 “메소드별 비교 세트”

### 13.1 동일 논리, NL OUTER vs HASH OUTER

```sql
-- NL OUTER 선호: Top-N
SELECT /*+ LEADING(c o) USE_NL(o) */
       c.cust_id, o.order_id
FROM   CUST c
LEFT JOIN ORD o ON o.cust_id = c.cust_id
WHERE  c.tier='VIP'
FETCH FIRST 5 ROWS ONLY;

-- HASH OUTER 선호: 대량 집계
SELECT /*+ LEADING(c o) USE_HASH(o) */
       c.tier, COUNT(o.order_id)
FROM   CUST c
LEFT JOIN ORD o ON o.cust_id = c.cust_id
GROUP  BY c.tier;
```

### 13.2 SMJ OUTER 강제 확인

```sql
SELECT /*+ LEADING(o s) USE_MERGE(s) */
       o.order_id, s.ship_dt
FROM   ORD o
LEFT JOIN SHP s ON s.order_id = o.order_id;
```

---

## 14. 요약

- OUTER 조인의 본질은 **preserved side를 유지하고 null-supplying side를 NULL로 채우는 의미 보존**이다.  
- **ON vs WHERE**가 의미/성능의 1순위 분기점이며, NULL 공급측 조건을 WHERE에 두면 **암묵적 INNER화**가 발생한다. :contentReference[oaicite:10]{index=10}  
- **NL OUTER**는 Top-N/부분범위/조기 종료에,  
  **SMJ OUTER**는 대량/정렬/비등치 OUTER에,  
  **HJ OUTER**는 대량 스캔/집계에 강하다. :contentReference[oaicite:11]{index=11}  
- FULL OUTER는 LEFT + RIGHT ANTI로 분해 가능한 구조이며, WHERE 필터가 보존 의미를 깨지 않는지 항상 점검해야 한다.  
- 결론적으로, OUTER 조인의 성능 튜닝은  
  **(1) 의미 보존 확인 → (2) 프레디킷 배치 교정 → (3) 메소드/순서/메모리 실측 비교**  
  이 3단계가 정석이다.

--- 

### 마지막 확인 스니펫

```sql
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
    'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +NOTE'
  )
);

SELECT sql_id, child_number, id, operation, options, object_name
FROM   v$sql_plan
WHERE  operation LIKE '%JOIN%' AND options LIKE '%OUTER%'
ORDER  BY sql_id, child_number, id;
```