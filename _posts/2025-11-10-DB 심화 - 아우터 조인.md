---
layout: post
title: DB 심화 - 아우터 조인
date: 2025-11-10 21:25:23 +0900
category: DB 심화
---
# 아우터 조인(Outer Join) 총정리 (Oracle 기준)

**— Outer NL Join · Outer Sort-Merge Join · Outer Hash Join · Full Outer Join**
모든 예제는 바로 실행 가능한 **DDL/데이터/SQL**을 포함합니다. 실행 후에는
`DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')`
로 실제 실행 통계를 확인하세요.

> 핵심 요약
> - **아우터 조인 = NULL 공급 측(null-supplying side)을 보존**하는 조인.
> - **LEFT OUTER**: 왼쪽을 **반드시 보존**(오른쪽 매칭 없으면 오른쪽 컬럼 NULL).
> - **RIGHT OUTER**: 오른쪽 보존.
> - **FULL OUTER**: 양쪽 보존(양쪽 매칭 없으면 상대 컬럼 NULL).
> - 메소드에 따라 장단점이 다름:
>   **NL OUTER**(조기 종료/부분범위에 강함), **SMJ OUTER**(비등치·정렬 기반에 강함), **HASH OUTER**(대량 스캔/집계에 강함).
> - **가장 흔한 실수**: 보존 측을 NULL로 만들 수 있는 **필터를 WHERE에 작성**해 아우터를 **암묵적으로 INNER로 바꿔버리는** 것.
>   → **조건은 ON 절에**, 필요 시 `NVL/COALESCE` 또는 **CASE**로 처리.

---

## 실습 환경 준비

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;       -- DBMS_XPLAN ALLSTATS LAST
ALTER SESSION SET workarea_size_policy = AUTO;  -- 정렬/해시 워크에어리어 자동
```

---

# 실습 스키마 (고객–주문–배송)

- **고객(CUST)**: 모든 고객
- **주문(ORD)**: 일부 고객만 보유
- **배송(SHP)**: 일부 주문만 배송 완료

```sql
-- 초기화
DROP TABLE SHP PURGE;
DROP TABLE ORD PURGE;
DROP TABLE CUST PURGE;

-- 고객
CREATE TABLE CUST(
  CUST_ID  NUMBER       PRIMARY KEY,
  NAME     VARCHAR2(30) NOT NULL,
  TIER     VARCHAR2(8)  NOT NULL,
  REGION   VARCHAR2(8)  NOT NULL
);

-- 주문
CREATE TABLE ORD(
  ORDER_ID NUMBER       PRIMARY KEY,
  CUST_ID  NUMBER       NOT NULL,
  ORDER_DT DATE         NOT NULL,
  STATUS   VARCHAR2(8)  NOT NULL
);

-- 배송
CREATE TABLE SHP(
  ORDER_ID NUMBER       NOT NULL,
  SHIP_DT  DATE,
  CARRIER  VARCHAR2(12),
  CONSTRAINT PK_SHP PRIMARY KEY (ORDER_ID)
);

-- 인덱스
CREATE INDEX IX_ORD_CUST ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_SHP_ORD  ON SHP(ORDER_ID);

-- 샘플 데이터
BEGIN
  FOR c IN 1..20 LOOP
    INSERT INTO CUST VALUES(
      c,
      'CUST_'||TO_CHAR(c,'FM00'),
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER' ELSE 'GEN' END,
      CASE MOD(c,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END
    );
  END LOOP;

  -- 주문: 일부 고객만 주문 (1..12)
  FOR o IN 1..50 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,12)+1,
      DATE '2024-01-01' + MOD(o,120),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  -- 배송: 일부 주문만 배송 (짝수 주문만 배송)
  FOR s IN 2..50 BY 2 LOOP
    INSERT INTO SHP VALUES(
      s,
      DATE '2024-02-01' + MOD(s,90),
      CASE MOD(s,3) WHEN 0 THEN 'UPS' WHEN 1 THEN 'DHL' ELSE 'FEDEX' END
    );
  END LOOP;

  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SHP' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# OUTER 조인의 논리와 **predicate 배치 원칙**

## 아우터 조인 정의

- **LEFT OUTER**: `A LEFT JOIN B ON ...`
  A의 각 행을 **무조건 반환**. B에 매칭 없으면 B의 컬럼은 **NULL로 채워** 반환.
- **RIGHT OUTER**: 반대.
- **FULL OUTER**: 양쪽을 모두 보존.

## **ON vs WHERE** (가장 중요한 규칙)

- **보존 측(non-null-supplying side가 아닌, null-supplying side의 반대) 조건**과 **조인 조건**은 **ON** 절에 둔다.
- **NULL이 될 수 있는(보존 대상이 아닌) 쪽에 대한 필터**를 **WHERE에 두면 INNER처럼** 되어 **보존 효과 상실**.

### 실수 예 (틀린 패턴)

```sql
-- '배송 완료 주문 포함, 배송 없는 주문도 보여달라' (LEFT JOIN이 의도)
-- 그러나 WHERE에 SHP.CARRIER = 'DHL'을 두면 배송 없는 행(NULL)이 탈락 → 사실상 INNER
SELECT o.order_id, s.carrier
FROM   ORD o
LEFT JOIN SHP s
       ON s.order_id = o.order_id
WHERE  s.carrier = 'DHL';   -- ❌ LEFT의 의미가 사라짐(배송 없는 주문 제외)
```

### 올바른 패턴

```sql
-- 필터를 ON에 두고, WHERE에서는 보존측을 훼손하지 않는다
SELECT o.order_id, s.carrier
FROM   ORD o
LEFT JOIN SHP s
       ON s.order_id = o.order_id
      AND s.carrier  = 'DHL';  -- ✅ 배송이 있으면 DHL만, 없으면 NULL(보존)
```

> **TIP**: 반환부에서 `NVL/COALESCE`로 표현을 정리한다.
> `COALESCE(s.carrier, 'NO_SHIPMENT') AS carrier`

---

# **Outer Nested Loops Join (NESTED LOOPS OUTER)**

## 언제 유리한가?

- **화면 조회/Top-N/부분범위**: 드라이빙(보존)측을 **인덱스로 빠르게 뽑고**, 상대측을 **인덱스 Lookup**(없으면 NULL).
- **조기 종료**가 중요할수록 NL OUTER가 강함.

## 예제: “VIP 고객의 최근 주문과(없으면 NULL) 배송사 표시”

- **LEFT OUTER**: 고객→주문→배송 순으로 보존.

```sql
-- VIP 고객 10명만 보고 싶은 화면 조회(부분범위)
SELECT /*+
          ORDERED
          LEADING(c o s)
          USE_NL(o) USE_NL(s)
          INDEX(o ix_ord_cust)      -- (cust_id, order_dt)로 최신순 스캔
       */
       c.cust_id, c.name, o.order_id, o.order_dt,
       COALESCE(s.carrier, 'NO_SHIPMENT') AS carrier
FROM   CUST c
LEFT  JOIN ORD  o
       ON o.cust_id = c.cust_id
LEFT  JOIN SHP  s
       ON s.order_id = o.order_id
WHERE  c.tier = 'VIP'
ORDER  BY o.order_dt DESC NULLS LAST, o.order_id DESC NULLS LAST
FETCH FIRST 10 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS'));
```

**포인트**
- 드라이빙 테이블 = **CUST(VIP)** → **작게 시작**.
- 오른쪽(ORD, SHP)은 **NL Lookup**. 없으면 **NULL**을 채움.
- 정렬 인덱스 활용으로 **Stopkey(10)** 조기 종료.

## 실수/주의

- RIGHT OUTER/NL을 쓸 때 드라이빙을 **오른쪽**으로 잡지 않으면 **보존 보장 실패**(플랜 상 NL OUTER가 아닌 다른 형태로 변환될 수 있음).
- **보존 측을 외부(Outer)로** NL 드라이빙해야 논리 보존이 쉽다(일반적 가이드).

---

# **Outer Sort-Merge Join (MERGE JOIN OUTER)**

## 언제 유리한가?

- **대량** + **정렬 기반** 처리에 안정적.
- **비등치/기간 매핑**에도 자연스럽게 적용 가능(LEFT/RIGHT OUTER + BETWEEN/<= 등).
- 정렬을 **인덱스로 대체**하거나 **이미 정렬된 스트림**이면 더 효율적.

## 예제: “주문일과 가장 가까운 배송(또는 미배송) 매핑”

- 배송이 존재하지 않으면 NULL. (데모는 단순 등치 LEFT OUTER로 제시)

```sql
-- LEFT OUTER + SMJ 강제
SELECT /*+
          ORDERED
          LEADING(o s)
          USE_MERGE(s)
          FULL(o) FULL(s)   -- 데모용, 실제는 플랜에 따라 다름
       */
       o.order_id, o.order_dt, s.ship_dt, s.carrier
FROM   ORD o
LEFT  JOIN SHP s
       ON s.order_id = o.order_id
WHERE  o.order_dt >= DATE '2024-02-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```

**포인트**
- 플랜에 `MERGE JOIN OUTER`와 `SORT JOIN`이 보이면 정상.
- **정렬 비용**은 `+MEMSTATS`의 Temp/PGA에서 확인.
- 인덱스로 정렬 대체 가능하면 한쪽 `SORT JOIN`을 줄일 수 있음(예: `INDEX_ASC(o ...)`).

## 비등치 OUTER (기간 포함 가능)

```sql
-- '주문일 기준, 그 날짜 이후 첫 배송 기록(없으면 NULL)' 같은 패턴은
-- 범위 조인 + OUTER로 모델링 가능(업무 정의에 따라 로직 조정)
SELECT /*+ USE_MERGE(s) */
       o.order_id, o.order_dt, s.ship_dt, s.carrier
FROM   ORD o
LEFT  JOIN SHP s
       ON s.order_id = o.order_id            -- 등치
      AND s.ship_dt >= o.order_dt            -- 비등치 필터를 ON에 배치(보존 유지)
WHERE  o.order_dt >= DATE '2024-02-01';
```

---

# **Outer Hash Join (HASH JOIN OUTER)**

## 언제 유리한가?

- **대량 스캔/집계형** LEFT/RIGHT OUTER.
- 인덱스 의미가 작고, **조기 종료 필요가 적은** 배치/리포트 성격.

## 예제: “부서별 고객 수와 주문 수를 한 번에(주문 없는 고객도 포함)”

- 여기선 CUST(왼쪽) 보존 + ORD(오른쪽) 집계.

```sql
WITH O_SUM AS (
  SELECT /*+ MATERIALIZE */ o.cust_id, COUNT(*) cnt
  FROM   ORD o
  WHERE  o.order_dt >= DATE '2024-02-01'
  GROUP  BY o.cust_id
)
SELECT /*+
          ORDERED
          LEADING(c os)
          USE_HASH(os) NO_USE_NL(os) NO_USE_MERGE(os)
       */
       c.cust_id, c.name, NVL(os.cnt,0) AS orders_since_feb
FROM   CUST c
LEFT  JOIN O_SUM os
       ON os.cust_id = c.cust_id
WHERE  c.region = 'APAC';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```

**포인트**
- `HASH JOIN OUTER`가 선택되면 **빌드/프로브**의 크기를 보고 `TempSpc`(스필) 여부 확인.
- **빌드 입력 축소**(예: 집계/필터/프루닝)로 **원패스** 가능성을 높인다.
- OUTER에서도 `SWAP_JOIN_INPUTS`로 **빌드 입력**을 조정 가능.

---

# **FULL OUTER JOIN**

- 양쪽 모두 보존. 매칭 없으면 상대 컬럼 NULL.
- 구현 메소드: **MERGE JOIN FULL OUTER** 또는 **HASH JOIN FULL OUTER**(데이터/버전/옵티마이저 판단)에 따라.

## 기본 예제

```sql
SELECT /*+ USE_MERGE(o) */
       c.cust_id, c.name, o.order_id, o.order_dt
FROM   CUST c
FULL  OUTER JOIN ORD  o
       ON o.cust_id = c.cust_id
WHERE  c.region = 'EMEA' OR o.status = 'PAID';  -- 주의: WHERE에서 보존 측 탈락 유의

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE'));
```

> **WHERE 절 주의**
> `FULL OUTER`에서도 WHERE 필터는 **NULL 행을 제거**할 수 있다.
> 보존 의도를 유지하려면 가능한 한 **필터는 ON 절**로 옮기고,
> 결과 해석용 필터는 `CASE WHEN` 또는 `NVL`/`COALESCE` 후에 적용을 검토.

## REWRITE: FULL OUTER = LEFT OUTER **UNION ALL** RIGHT ANTI

**개념 식**
$$
R \ \text{FULL OUTER JOIN}\ S \ \equiv\ (R \ \text{LEFT JOIN}\ S)\ \cup\ (S\ \text{ANTIJOIN}\ R)
$$

```sql
-- (1) LEFT
WITH L AS (
  SELECT c.cust_id, c.name, o.order_id, o.order_dt
  FROM   CUST c
  LEFT  JOIN ORD  o
         ON o.cust_id = c.cust_id
),
-- (2) RIGHT ANTI (오른쪽에서 왼쪽에 매칭 없는 행만)
RA AS (
  SELECT NULL AS cust_id, NULL AS name, o.order_id, o.order_dt
  FROM   ORD o
  WHERE  NOT EXISTS (
          SELECT 1 FROM CUST c WHERE c.cust_id = o.cust_id
        )
)
SELECT * FROM L
UNION ALL
SELECT * FROM RA;
```

- 옵티마이저가 내부적으로 유사한 재작성/변환을 수행하기도 한다(버전/상황에 따라 다름).

---

# ANSI 조인 vs Oracle 구문 `(+)`

- **권장**: ANSI `LEFT/RIGHT/FULL OUTER JOIN`.
- 구식 `(+)` 구문은 **표현력/제약**이 많고, 여러 OUTER 혼합 시 **혼란**을 초래.
- 혼합 사용은 피하라(특히 조건 배치 오류로 INNER화되는 사고 다발).

---

# 성능/튜닝 체크리스트

1) **의도 확인**: 보존 측은? NULL 공급은 어느 쪽?
2) **predicate 위치**:
   - 보존 유지할 조건은 **ON** 절에.
   - 필터가 결과를 **INNER화**하지 않는지 확인.
3) **메소드 선택**:
   - **NL OUTER**: **부분범위/Top-N/조기 종료** · 보존측 인덱스/순차 스캔 유리.
   - **SMJ OUTER**: **대량/정렬 기반**, **비등치**에도 자연. 정렬 비용/PGA·TEMP 점검.
   - **HASH OUTER**: **대량 스캔**, 빌드 입력 축소(집계/프루닝)로 스필 방지.
4) **조인 순서**: 보존측을 **드라이빙**(특히 NL) → I/O 최소화.
5) **통계/히스토그램**: 카디널리티 추정 오차로 잘못된 순서/메소드 선택 방지.
6) **플랜 안정화**: `LEADING/ORDERED/USE_*`(예: `USE_HASH_OUTER`, `USE_MERGE_OUTER`, `USE_NL_OUTER`)로 의도 반영.
7) **검증**: `DBMS_XPLAN ... +PREDICATE +IOSTATS +MEMSTATS`로 실제 **Read/Temp/Elapsed** 비교.

---

# 케이스 스터디

## “배송 없는 주문도 포함해서 최근 20건”

- **LEFT OUTER + NL** (조기 종료)

```sql
SELECT /*+
          ORDERED
          LEADING(o s)
          USE_NL(s)
          INDEX(o ix_ord_cust)
       */
       o.order_id, o.order_dt, COALESCE(s.carrier,'NO_SHIP') carrier
FROM   ORD o
LEFT  JOIN SHP s
       ON s.order_id = o.order_id
WHERE  o.cust_id = 3
ORDER  BY o.order_dt DESC
FETCH FIRST 20 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +IOSTATS'));
```

- 정렬 흡수 + Stopkey → **최소 I/O**.

## “APAC 고객의 주문 수(0건 고객 포함)”

- **LEFT OUTER + HASH** (대량 집계)

```sql
WITH O_SUM AS (
  SELECT /*+ MATERIALIZE */ o.cust_id, COUNT(*) cnt
  FROM   ORD o
  GROUP  BY o.cust_id
)
SELECT /*+
          ORDERED
          LEADING(c os)
          USE_HASH(os)
       */
       c.cust_id, c.name, NVL(os.cnt,0) AS orders
FROM   CUST c
LEFT  JOIN O_SUM os
       ON os.cust_id = c.cust_id
WHERE  c.region = 'APAC';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```

- `TempSpc`와 `Buffers`로 **해시 빌드/스필** 체크.

## “모든 고객과 모든 주문을 한 번에 보여주기”

- **FULL OUTER**(SMJ 또는 HASH)

```sql
SELECT /*+ USE_HASH(o) */
       c.cust_id, c.name, o.order_id, o.order_dt
FROM   CUST c
FULL  OUTER JOIN ORD o
       ON o.cust_id = c.cust_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +MEMSTATS'));
```

- WHERE 절에 `c.region = ...` 같은 조건을 추가할 때는
  **보존 의도**가 깨지지 않도록 **ON으로 이동** 가능성 검토.

---

# 자주 하는 질문(FAQ)

### Q1. LEFT OUTER에서 오른쪽 컬럼에 `WHERE s.carrier='DHL'`을 쓰면 왜 행이 줄죠?

- WHERE 필터 때문에 **NULL 행이 제거**되어 사실상 **INNER**처럼 동작.
  → `ON s.order_id = o.order_id AND s.carrier='DHL'` 로 옮기세요.

### Q2. OUTER에서 `COUNT(*)` vs `COUNT(col)` 차이는?

- `COUNT(*)`는 보존측 행을 **항상 세고**, `COUNT(col)`은 **NULL이면 0**.
  → “배송 없는 주문도 포함” 집계면 `COUNT(s.carrier)`가 0으로 나오는 것이 의도일 수 있음.

### Q3. 성능이 안 나올 때 우선 보볼 것?

1) **조인 순서**(보존측 드라이빙?)
2) **메소드**(NL/SMJ/HJ) · 정렬/해시 **워크에어리어/Temp**
3) **인덱스/프루닝**(드라이빙/Lookup/정렬 대체)
4) **predicate 위치**(ON/WHERE)
5) `DBMS_XPLAN +IOSTATS +MEMSTATS`로 수치 확인

---

# 요약

- OUTER 조인은 **보존 측 NULL 공급**이 핵심.
- **NL OUTER**: **Top-N/부분범위**와 **존재 확인** 시 최적.
- **SMJ OUTER**: **대량/정렬/비등치**에서 안정.
- **HASH OUTER**: **대량 스캔/집계**에 강함(빌드 축소로 스필 방지).
- **predicate는 ON 절**에 배치해 보존 의미를 유지하고,
  항상 **실측 플랜/통계**로 선택을 검증하라.

---

### (부록) 확인 스니펫

```sql
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS')
);

-- 최근 OUTER 노드들만
SELECT sql_id, child_number, id, operation, options, object_name
FROM   v$sql_plan
WHERE  operation LIKE '%JOIN%' AND options LIKE '%OUTER%';
```
