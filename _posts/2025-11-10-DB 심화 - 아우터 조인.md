---
layout: post
title: DB 심화 - 아우터 조인
date: 2025-11-10 21:25:23 +0900
category: DB 심화
---
# Outer Join 심층 분석: 의미 보존, 최적화, 성능 튜닝까지

Outer Join은 데이터베이스 쿼리에서 필수적인 조인 유형 중 하나로, 데이터 간의 관계를 보존하면서 연결하는 강력한 기능을 제공합니다. 이 문서에서는 Outer Join의 핵심 개념부터 다양한 조인 메소드(NL, SMJ, HJ)의 특성, 성능 최적화 기법까지 실습 중심으로 다룹니다.

## 실습 환경 설정 및 기본 개념

### 환경 설정
```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET workarea_size_policy = AUTO;
```

### 실행 계획 분석 템플릿
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL,
  'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS +NOTE'
));
```

## 실습 데이터 모델 구성

고객-주문-배송 시스템을 모델링한 간단한 스키마를 구성합니다:

```sql
-- 테이블 생성
DROP TABLE SHP PURGE;
DROP TABLE ORD PURGE;
DROP TABLE CUST PURGE;

CREATE TABLE CUST(
  CUST_ID  NUMBER       PRIMARY KEY,
  NAME     VARCHAR2(30) NOT NULL,
  TIER     VARCHAR2(8)  NOT NULL,
  REGION   VARCHAR2(8)  NOT NULL
);

CREATE TABLE ORD(
  ORDER_ID NUMBER       PRIMARY KEY,
  CUST_ID  NUMBER       NOT NULL,
  ORDER_DT DATE         NOT NULL,
  STATUS   VARCHAR2(8)  NOT NULL
);

CREATE TABLE SHP(
  ORDER_ID NUMBER       NOT NULL,
  SHIP_DT  DATE,
  CARRIER  VARCHAR2(12),
  CONSTRAINT PK_SHP PRIMARY KEY (ORDER_ID)
);

-- 인덱스 생성
CREATE INDEX IX_ORD_CUST ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_SHP_ORD  ON SHP(ORDER_ID);

-- 샘플 데이터 입력
BEGIN
  -- 20명의 고객
  FOR c IN 1..20 LOOP
    INSERT INTO CUST VALUES(
      c, 'CUST_'||TO_CHAR(c,'FM00'),
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' 
                    WHEN 2 THEN 'SILVER' ELSE 'GEN' END,
      CASE MOD(c,3) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' ELSE 'AMER' END
    );
  END LOOP;

  -- 50건의 주문 (고객 1-12번만 주문)
  FOR o IN 1..50 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,12)+1,
      DATE '2024-01-01' + MOD(o,120),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' 
                    WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  -- 짝수 주문만 배송 처리
  FOR s IN 2..50 BY 2 LOOP
    INSERT INTO SHP VALUES(
      s, DATE '2024-02-01' + MOD(s,90),
      CASE MOD(s,3) WHEN 0 THEN 'UPS' WHEN 1 THEN 'DHL' ELSE 'FEDEX' END
    );
  END LOOP;
  COMMIT;
END;
/

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD', cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SHP', cascade=>TRUE);
END;
/
```

## Outer Join의 기본 개념

### 보존측(Preserved Side)과 NULL 공급측(Null-Supplying Side)

Outer Join의 핵심 개념은 두 가지 측면으로 이해할 수 있습니다:

1. **보존측(Preserved Side)**: 결과 집합에서 항상 모든 행이 유지되는 측면
   - LEFT OUTER JOIN: 왼쪽 테이블이 보존측
   - RIGHT OUTER JOIN: 오른쪽 테이블이 보존측
   - FULL OUTER JOIN: 양쪽 테이블 모두 보존측

2. **NULL 공급측(Null-Supplying Side)**: 매칭되는 행이 없을 때 NULL 값을 제공하는 측면

### ON 절과 WHERE 절의 차이점

Outer Join에서 ON 절과 WHERE 절은 완전히 다른 역할을 수행합니다:

```sql
-- 잘못된 예: WHERE 절에서 NULL 공급측 조건 필터링
SELECT o.order_id, s.carrier
FROM   ORD o
LEFT JOIN SHP s ON s.order_id = o.order_id
WHERE  s.carrier = 'DHL';  -- 배송이 없는 주문이 결과에서 제거됨

-- 올바른 예: ON 절에 조건 포함
SELECT o.order_id, s.carrier
FROM   ORD o
LEFT JOIN SHP s 
       ON s.order_id = o.order_id
      AND s.carrier  = 'DHL';  -- 모든 주문이 결과에 포함됨
```

**NULL 반대 조건(Null-Rejecting Predicate)**이 WHERE 절에 있으면 Outer Join이 암묵적으로 Inner Join으로 변환됩니다. 이는 다음과 같은 조건에서 발생합니다:
- 컬럼과 리터럴의 직접 비교 (`s.carrier = 'DHL'`)
- NULL이 아닌지 확인 (`s.ship_dt IS NOT NULL`)
- 수치 비교 (`s.amount > 100`)

## 다양한 Outer Join 메소드 분석

### Outer Nested Loops Join

Outer Nested Loops Join은 보존측의 각 행에 대해 NULL 공급측을 반복적으로 조회하는 방식입니다. 이 방식은 다음과 같은 특징을 가집니다:

**적합한 상황:**
- 작은 결과 집합 처리 (Top-N, 페이징)
- 조기 종료(Stopkey) 최적화 가능한 경우
- NULL 공급측에 효율적인 인덱스가 있는 경우

**예제: VIP 고객의 최근 주문 조회**
```sql
SELECT /*+ LEADING(c o s) USE_NL(o) USE_NL(s) INDEX(o IX_ORD_CUST) */
       c.cust_id, c.name, o.order_id, o.order_dt,
       COALESCE(s.carrier, 'NO_SHIPMENT') AS carrier
FROM   CUST c
LEFT  JOIN ORD o ON o.cust_id = c.cust_id
LEFT  JOIN SHP s ON s.order_id = o.order_id
WHERE  c.tier = 'VIP'
ORDER  BY o.order_dt DESC NULLS LAST, o.order_id DESC NULLS LAST
FETCH FIRST 10 ROWS ONLY;
```

이 쿼리의 실행 계획에서 확인해야 할 주요 사항:
- `NESTED LOOPS OUTER` 연산자 존재 여부
- `STOPKEY` 또는 `COUNT STOPKEY` 조기 종료 최적화 적용 여부
- `Buffers` 값이 작게 유지되는지

**성능 문제 발생 패턴:**
- 보존측 행 수가 너무 많을 때
- NULL 공급측 인덱스 효율성이 낮을 때
- 대량 배치 처리에 적용할 때

### Outer Sort-Merge Join

Outer Sort-Merge Join은 양쪽 입력을 정렬한 후 병합하는 방식으로, 다음과 같은 특징을 가집니다:

**적합한 상황:**
- 대량 데이터 처리
- 비등치 조건이 포함된 Outer Join
- 이미 정렬된 입력 활용 가능한 경우

**예제: 주문과 배송 정보 병합**
```sql
SELECT /*+ LEADING(o s) USE_MERGE(s) */
       o.order_id, o.order_dt, s.ship_dt, s.carrier
FROM   ORD o
LEFT  JOIN SHP s ON s.order_id = o.order_id
WHERE  o.order_dt >= DATE '2024-02-01';
```

**비등치 Outer Join 예제:**
```sql
-- 주문일 이후의 첫 배송 정보 연결
SELECT /*+ USE_MERGE(s) */
       o.order_id, o.order_dt, s.ship_dt, s.carrier
FROM   ORD o
LEFT  JOIN SHP s 
       ON s.order_id = o.order_id
      AND s.ship_dt >= o.order_dt  -- 비등치 조건
WHERE  o.order_dt >= DATE '2024-02-01';
```

**성능 고려사항:**
- 정렬 작업으로 인한 TEMP 공간 사용
- 입력 데이터 크기에 따른 정렬 비용 증가
- Top-N 처리에 비효율적

### Outer Hash Join

Outer Hash Join은 작은 입력(Build)을 해시 테이블로 구성하고 큰 입력(Probe)을 스캔하는 방식입니다:

**적합한 상황:**
- 대량 데이터 스캔 및 집계
- 인덱스 기반 조인이 비효율적일 때
- 병렬 처리 환경

**예제: 고객별 주문 수 집계**
```sql
WITH O_SUM AS (
  SELECT cust_id, COUNT(*) cnt
  FROM   ORD 
  WHERE  order_dt >= DATE '2024-02-01'
  GROUP  BY cust_id
)
SELECT /*+ LEADING(c os) USE_HASH(os) */
       c.cust_id, c.name, NVL(os.cnt,0) AS orders_since_feb
FROM   CUST c
LEFT  JOIN O_SUM os ON os.cust_id = c.cust_id
WHERE  c.region = 'APAC';
```

**빌드/프로브 제어:**
```sql
-- SWAP_JOIN_INPUTS 힌트로 빌드 방향 변경
SELECT /*+ USE_HASH(s) SWAP_JOIN_INPUTS(s) */
       o.order_id, s.carrier
FROM   ORD o
LEFT  JOIN SHP s ON s.order_id = o.order_id;
```

**성능 문제 패턴:**
- 빌드 입력이 너무 커서 메모리 초과 발생
- 해시 버킷 불균형으로 인한 성능 저하
- TEMP 공간 사용량 증가

## Full Outer Join의 이해와 활용

Full Outer Join은 양쪽 테이블의 모든 행을 보존하는 조인 방식입니다:

**기본 예제:**
```sql
SELECT c.cust_id, c.name, o.order_id, o.order_dt
FROM   CUST c
FULL OUTER JOIN ORD o ON o.cust_id = c.cust_id;
```

**FULL OUTER JOIN의 내부 동작:**
관계대수적으로 Full Outer Join은 다음과 같이 분해될 수 있습니다:
```
FULL OUTER JOIN = LEFT OUTER JOIN ∪ RIGHT ANTI JOIN
```

**WHERE 절 사용 시 주의사항:**
```sql
-- 잘못된 예: WHERE 절이 NULL 행을 제거할 수 있음
SELECT c.cust_id, c.name, o.order_id
FROM   CUST c
FULL OUTER JOIN ORD o ON o.cust_id = c.cust_id
WHERE  c.region='EMEA' OR o.status='PAID';

-- 올바른 예: CASE 표현식으로 의미 보존
SELECT c.cust_id, c.name, o.order_id,
       CASE WHEN c.region='EMEA' OR o.status='PAID' THEN 'Y' ELSE 'N' END as flag
FROM   CUST c
FULL OUTER JOIN ORD o ON o.cust_id = c.cust_id;
```

## ANSI 조인 vs 전통적 (+) 표기법

ANSI 조인 구문은 가독성과 유지보수성 측면에서 전통적인 (+) 표기법보다 우수합니다:

**ANSI 조인의 장점:**
1. **명확한 의미 전달**: 조인 유형이 명시적으로 표현됨
2. **복잡한 조인 지원**: 여러 Outer Join을 혼합하여 사용 가능
3. **오류 감소**: ON 절과 WHERE 절 구분이 명확함

**예제 비교:**
```sql
-- ANSI 구문 (권장)
SELECT c.cust_id, o.order_id
FROM   CUST c
LEFT  JOIN ORD o ON o.cust_id = c.cust_id
LEFT  JOIN SHP s ON s.order_id = o.order_id;

-- 전통적 (+) 구문 (비권장)
SELECT c.cust_id, o.order_id
FROM   CUST c, ORD o, SHP s
WHERE  o.cust_id(+) = c.cust_id
AND    s.order_id(+) = o.order_id;
```

## 성능 최적화를 위한 실전 기법

### 1. 조인 메소드 선택 가이드라인

| 상황 | 추천 메소드 | 이유 |
|------|-------------|------|
| Top-N/페이징 | NL OUTER | 조기 종료 최적화, 작은 결과 집합 |
| 대량 데이터 집계 | HJ OUTER | 메모리 기반 처리, 병렬 처리 효율 |
| 비등치 조건 조인 | SMJ OUTER | 범위 기반 매칭에 적합 |
| 인덱스 활용 가능 | NL OUTER | 랜덤 액세스 효율성 |

### 2. 인덱스 설계 전략

Outer Join 성능을 위한 인덱스 설계 원칙:
```sql
-- NULL 공급측의 조인 키 인덱스
CREATE INDEX idx_ship_order ON SHP(order_id);

-- 보존측의 필터링 조건 인덱스  
CREATE INDEX idx_cust_region ON CUST(region, tier);

-- 복합 조인 조건 인덱스
CREATE INDEX idx_ord_cust_dt ON ORD(cust_id, order_dt);
```

### 3. 통계 관리의 중요성

Outer Join은 카디널리티 추정 오류의 영향을 크게 받습니다:

```sql
-- 히스토그램 생성
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER, 'CUST', 
    method_opt => 'FOR COLUMNS SIZE 254 REGION, TIER'
  );
END;
/

-- 확장 통계 (상관 관계 있는 컬럼들)
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(
    USER, 'CUST', '(REGION, TIER)'
  );
END;
/
```

### 4. 메모리 및 TEMP 공간 최적화

```sql
-- PGA 사용량 모니터링
SELECT name, value/1024/1024 as MB
FROM v$mystat s
JOIN v$statname n ON n.statistic# = s.statistic#
WHERE n.name LIKE '%pga%';

-- 정렬 관련 통계
SELECT name, value
FROM v$mystat s  
JOIN v$statname n ON n.statistic# = s.statistic#
WHERE n.name IN ('sorts (memory)', 'sorts (disk)',
                 'workarea executions - optimal',
                 'workarea executions - onepass',
                 'workarea executions - multipass');
```

## 일반적인 문제 및 해결 방안

### 문제 1: Outer Join이 Inner Join처럼 동작함

**증상**: 예상보다 결과 행 수가 적음
**원인**: WHERE 절에 NULL 반대 조건 사용
**해결**: 조건을 ON 절로 이동

### 문제 2: NL Outer Join 성능 저하

**증상**: 대량 데이터에서 실행 시간 급증
**원인**: 보존측 행 수가 너무 많거나 NULL 공급측 인덱스 비효율
**해결**: 
- 보존측 필터링 강화
- Hash Join이나 Sort-Merge Join으로 전환
- NULL 공급측 인덱스 개선

### 문제 3: Hash Outer Join의 메모리 오버플로우

**증상**: TEMP 공간 사용량 급증
**원인**: 빌드 입력이 너무 큼
**해결**:
- 빌드 입력 축소 (필터링, 집계 선행)
- `SWAP_JOIN_INPUTS`로 빌드 방향 변경
- PGA 크기 조정

## 실습: 다양한 접근법 비교

### 동일 논리의 다른 구현 방식 비교

```sql
-- 케이스 1: NL OUTER (Top-N에 적합)
SELECT /*+ LEADING(c o) USE_NL(o) */
       c.cust_id, o.order_id
FROM   CUST c
LEFT JOIN ORD o ON o.cust_id = c.cust_id
WHERE  c.tier='VIP'
FETCH FIRST 5 ROWS ONLY;

-- 케이스 2: HASH OUTER (집계에 적합)  
SELECT /*+ LEADING(c o) USE_HASH(o) */
       c.tier, COUNT(o.order_id) as order_count
FROM   CUST c
LEFT JOIN ORD o ON o.cust_id = c.cust_id
GROUP BY c.tier;

-- 케이스 3: SMJ OUTER (비등치 조인에 적합)
SELECT /*+ LEADING(o s) USE_MERGE(s) */
       o.order_id, s.ship_dt
FROM   ORD o
LEFT JOIN SHP s ON s.order_id = o.order_id;
```

### 실행 계획 분석 스크립트

```sql
-- 현재 세션의 최근 SQL 실행 계획
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
    'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +NOTE'
  )
);

-- Outer Join 사용 쿼리 모니터링
SELECT sql_id, child_number, 
       SUBSTR(sql_text, 1, 50) as sql_text,
       executions, buffer_gets, disk_reads,
       elapsed_time/1000000 as elapsed_sec
FROM v$sql
WHERE sql_text LIKE '%OUTER JOIN%'
   OR sql_text LIKE '%(+)%'
ORDER BY last_active_time DESC;
```

## 현대 Oracle 버전의 Outer Join 최적화

최신 Oracle 버전(19c 이상)에서는 Outer Join 성능이 여러 측면에서 개선되었습니다:

1. **벡터화 처리**: 대량 데이터 처리 성능 향상
2. **인메모리 옵션**: 자주 사용되는 조인 결과 캐싱
3. **자동 인덱스 생성**: 빈번한 Outer Join 패턴 감지 및 인덱스 생성
4. **실시간 통계**: 실행 중 통계 정보 갱신

```sql
-- 인메모리 옵션 활용 예
ALTER TABLE CUST INMEMORY;
ALTER TABLE ORD INMEMORY;

-- 자동 인덱스 생성 모니터링
SELECT * FROM dba_auto_indexes;
```

## 결론

Outer Join은 데이터 관계를 보존하면서 연결하는 강력한 도구이지만, 올바른 사용과 성능 최적화를 위해서는 깊은 이해가 필요합니다. 효과적인 Outer Join 사용을 위한 핵심 원칙을 정리하면 다음과 같습니다:

**1. 의미 보존이 최우선**: Outer Join의 본질은 데이터 관계의 보존입니다. ON 절과 WHERE 절의 적절한 사용으로 의도한 의미를 정확히 구현해야 합니다.

**2. 상황에 맞는 조인 메소드 선택**: 각 조인 메소드(NL, SMJ, HJ)는 고유한 장단점을 가집니다. 데이터 크기, 인덱스 구성, 결과 집합 특성을 고려하여 최적의 메소드를 선택해야 합니다.

**3. 통계 정보의 정확성**: Outer Join 성능은 카디널리티 추정에 크게 의존합니다. 정확한 통계 정보와 적절한 히스토그램이 필수적입니다.

**4. 지속적인 모니터링과 최적화**: 실행 계획 분석, 성능 측정, 문제 패턴 인식을 통해 지속적으로 성능을 개선해야 합니다.

**5. 현대적 기능 활용**: 최신 Oracle 버전의 벡터화 처리, 인메모리 옵션, 자동 최적화 기능을 적극 활용하세요.

Outer Join은 단순한 기술적 기능을 넘어 비즈니스 요구사항을 정확히 반영하는 도구입니다. 데이터의 완전성과 관계성을 유지하면서도 성능을 최적화하는 균형 있는 접근이 성공적인 데이터 처리의 핵심입니다.