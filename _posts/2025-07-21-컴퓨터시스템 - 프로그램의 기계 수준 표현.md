---
layout: post
title: 컴퓨터시스템 - 프로그램의 기계 수준 표현
date: 2025-07-21 18:20:23 +0900
category: 컴퓨터시스템
---
# 🧠 프로그램의 기계 수준 표현 : 역사적 관점에서의 이해

컴퓨터 시스템은 시간이 지나며 하드웨어와 소프트웨어가 함께 진화해 왔고, 그 과정에서 **프로그램이 기계에서 어떻게 표현되고 실행되는지**에 대한 접근 방식도 발전해 왔습니다. 이 장에서는 이러한 흐름을 **역사적 관점**에서 조명하며, 오늘날 우리가 사용하는 **기계 수준 표현(machine-level representation)**이 어떻게 자리 잡았는지 살펴봅니다.

---

## 📌 1. 기계어와 어셈블리의 탄생

### 🔹 순수 기계어
초기의 컴퓨터(예: ENIAC, UNIVAC)는 사람이 직접 **이진수(binary)**로 된 기계어 명령어를 작성하여 프로그램을 구성해야 했습니다.

```plaintext
11001010 00000101
```

이러한 방식은 사람이 읽고 쓰기에는 너무 어렵고 실수가 많았습니다. 이에 따라 보다 읽기 쉬운 **어셈블리어**가 등장했습니다.

---

## 📌 2. 어셈블리어 (Assembly Language)

어셈블리어는 기계어 명령어를 사람이 이해하기 쉽게 **기호(symbolic names)**로 바꾼 언어입니다. 어셈블러(assembler)라는 프로그램이 이 코드를 다시 **기계어로 번역**해 줍니다.

```assembly
movl $5, %eax   # eax 레지스터에 5를 저장
```

이 시점부터 우리는 프로그램을 하드웨어에 맞게 **정확하게 제어**하면서도, 사람이 이해하기 쉬운 형태로 작성할 수 있게 되었습니다.

---

## 📌 3. 고급 언어와 컴파일러의 등장

### 🔹 FORTRAN, C의 등장
어셈블리어는 여전히 **하드웨어 종속성**이 강하고 유지보수가 어렵다는 단점이 있었습니다. 이 문제를 해결하고자 등장한 것이 **고급 언어(high-level language)**입니다. 대표적인 초기 언어가 **FORTRAN**, **C** 등이 있습니다.

고급 언어는 보다 **사람 중심의 표현**을 가능하게 했고, **컴파일러(compiler)**는 이 코드를 다시 **기계어로 번역**해 줍니다.

```c
int a = 5;
```

➡️ 컴파일러 ➡️ 어셈블리 ➡️ 기계어

---

## 📌 4. 하드웨어 아키텍처와 기계 수준 표현

기계 수준 표현은 **하드웨어 아키텍처(ISA, Instruction Set Architecture)**에 의해 결정됩니다. 가장 대표적인 예가 **x86**, **ARM**, **RISC-V**입니다.

### 🔹 x86 아키텍처 예시

```assembly
movl $0x4, %eax   # 시스템 콜 번호
movl $0x1, %ebx   # 파일 디스크립터
int $0x80         # 인터럽트 실행
```

### 🔹 중요한 개념
- **ISA**: 하드웨어가 이해하는 명령어 집합
- **ABI (Application Binary Interface)**: 프로그램이 OS와 상호작용하는 규약

이러한 ISA는 **기계 수준에서의 프로그램 표현**을 구체적으로 정의합니다. 즉, 어떤 명령어가 어떤 동작을 하며, 메모리 구조나 레지스터가 어떻게 동작하는지 결정합니다.

---

## 📌 5. C 언어와 시스템 수준 프로그래밍

C 언어는 **고급 언어와 저급 제어의 중간 수준**을 지향하며, 운영체제와 시스템 프로그래밍에 매우 적합합니다. 실제로 유닉스, 리눅스 커널도 대부분 C로 작성되어 있으며, 컴파일 시 C는 매우 정교한 어셈블리 코드로 변환됩니다.

```c
int sum(int x, int y) {
    return x + y;
}
```

➡️ 어셈블리 코드:
```assembly
sum:
    movl 8(%ebp), %eax
    addl 12(%ebp), %eax
    ret
```

---

## 📌 6. 현대 시스템에서의 기계 수준 표현

오늘날의 시스템은 다음과 같은 흐름을 따릅니다:

```plaintext
C 코드 → 컴파일러 → 어셈블리 코드 → 어셈블러 → 기계어 → 링커/로더 → 실행
```

### 🔹 중간 산물
- `.c` : C 소스 코드
- `.s` : 어셈블리 코드
- `.o` : 목적 파일 (기계어)
- 실행 파일 (`a.out`, ELF, PE 등)

이러한 각 단계를 거치며, **고수준의 추상적 표현**은 점차 **하드웨어가 이해할 수 있는 이진 표현**으로 변환됩니다.

---

## 📌 7. 요약: 왜 기계 수준 표현을 이해해야 하는가?

| 이유 | 설명 |
|------|------|
| 성능 최적화 | 코드가 실제 하드웨어에서 어떻게 실행되는지를 이해하면 성능을 개선할 수 있음 |
| 디버깅 | 어셈블리 코드나 메모리 구조를 알아야 시스템 오류나 버그를 해결할 수 있음 |
| 보안 | 버퍼 오버플로우와 같은 보안 취약점은 기계 수준에서 발생 |
| 시스템 이해 | 운영체제, 컴파일러, 하드웨어와의 관계를 정확히 이해 가능 |

---

## ✅ 결론

기계 수준 표현은 단지 낮은 수준의 프로그래밍을 의미하지 않습니다. 오히려 **시스템을 깊이 이해하기 위한 핵심 통로**입니다.