---
layout: post
title: 컴퓨터시스템 - 프로그램의 기계 수준 표현
date: 2025-07-21 18:20:23 +0900
category: 컴퓨터시스템
---
# 프로그램의 기계 수준 표현

## 1. 기계어와 어셈블리의 탄생

### 1.1 순수 기계어(수동 이진)
초기 전자식 컴퓨터(ENIAC, UNIVAC 등)에서는 사람이 **바이너리 비트열**로 직접 프로그램을 작성했다.

```text
11001010 00000101
```

- **문제점**: 사람이 읽기 어렵고 오류가 빈발, 하드웨어 변경 시 프로그램 이식 불가.

### 1.2 어셈블리어의 등장
기계어 **비트패턴 ↔ 기호적 니모닉**을 1:1 매핑:

```asm
MOV R0, #5    ; 즉시값 5를 R0에
ADD R1, R0
JNZ LOOP
```

- **어셈블러**가 니모닉과 심볼을 해결해 **절대/상대 주소**의 기계어로 변환.
- **매크로 어셈블러**(Macro) → 어셈블리 단계에서 템플릿·상수·조건부 조립 지원.

---

## 2. 고급 언어와 컴파일러의 탄생 — “사람 중심 표현”과 이식성

### 2.1 FORTRAN, ALGOL, C
- **FORTRAN**: 과학 계산을 고수준 수식으로 표현 → 최적화 컴파일러의 시초.
- **C**: 저수준 제어(포인터, 비트연산)와 고수준 구조(함수, 추상화)를 절충.
- **결과**: 하드웨어마다 다른 어셈블리를 사람이 쓰지 않아도 됨. **컴파일러가 ISA 종속성**을 흡수.

```c
int sum(int x, int y) { return x + y; }
```

컴파일러 파이프라인(개념):

```
C 소스 → (프런트엔드: 파싱/AST/타입체크)
      → (IR/중간표현: SSA 등, 최적화)
      → (백엔드: 레지스터 할당/선형스캔, 선택)
      → 어셈블리 → 어셈블러 → 기계어(오브젝트)
```

---

## 3. ISA와 ABI — “무엇을 실행할 수 있나”를 규정하는 두 축

### 3.1 ISA(Instruction Set Architecture)
- **x86**: 가변 길이 명령, 풍부한 주소지정 모드(CISC), 역사적 호환성 중시.
- **ARM/AArch64**: 정형적 인코딩, 조건부 실행(ARMv7), `csel`류 조건 선택(AArch64).
- **RISC-V**: 완전 오픈 ISA, 32/64/128비트 변종, 확장(벡터/압축/C/D/F/Q) 모듈식.

#### x86-64 예(리눅스 시스템 콜; 현대는 `syscall`)
```asm
mov     rax, 1        ; SYS_write
mov     rdi, 1        ; fd = stdout
mov     rsi, msg      ; buf
mov     rdx, len      ; count
syscall
```

#### AArch64 예(리눅스; `svc #0`)
```asm
mov     x8, #64       ; SYS_write
mov     x0, #1        ; fd
mov     x1, msg       ; buf
mov     x2, len       ; count
svc     #0
```

### 3.2 ABI(Application Binary Interface)
- **호출 규약**(Calling Convention), **오브젝트 포맷**(ELF/PE/Mach-O), **시스템 콜 번호/규약**, **라이브러리 이진 호환** 등.
- AMD64 SysV vs Windows x64(주요 차이):
  - 정수 인자: **SysV**: `rdi, rsi, rdx, rcx, r8, r9` / **Win64**: `rcx, rdx, r8, r9`
  - **red zone**: SysV만 128B(인터럽트 불가 전제), Win64 없음
  - Callee-saved: SysV(`rbx, rbp, r12~r15`), Win64(`rbx, rbp, rdi, rsi, r12~r15`, XMM는 일부 규칙)

---

## 4. “C → 어셈블리 → 기계어 → 링킹 → 로딩” 전 과정 살펴보기

### 4.1 단일 함수의 변환 예
```c
int max(int a, int b) { return (a > b) ? a : b; }
```

**x86-64 SysV** (대표 형태):
```asm
max:
    mov     eax, edi        ; r = a
    cmp     edi, esi
    cmovl   eax, esi        ; if (a < b) r=b
    ret
```

- 컴파일러는 분기 예측 실패를 피하려 **조건이동(cmov)** 사용을 선호.

### 4.2 오브젝트 파일(예: ELF)과 섹션
빌드 산출물:

- `.text` : 코드(기계어)
- `.rodata` : 상수/리터럴
- `.data` : 초기화된 전역
- `.bss` : 0으로 초기화 전역(실제 파일 공간은 차지 안 함)
- 심볼테이블, 재배치 정보 `.rela.*`, 디버그 정보(DWARF) 등

도식:
```
ELF Object (.o)
 ├─ .text
 ├─ .rodata
 ├─ .data
 ├─ .bss
 ├─ .rela.text/.rela.plt ...
 └─ .symtab/.strtab/.debug_*
```

### 4.3 링크(정적/동적)
- **정적 링크**: 라이브러리 아카이브(`.a`)에서 필요한 오브젝트를 가져와 **하나의 실행 파일**에 병합.
- **동적 링크**: 실행 시점에 **공유 객체(.so/.dll)** 를 로더가 매핑·재배치.

#### ELF의 PLT/GOT(간접 호출) 개요
```
call printf@PLT
PLT 스텁 → GOT 엔트리 → (초회) ld.so가 심볼 해결 → GOT 갱신
(이후) PLT가 곧바로 실제 함수로 점프(지연 바인딩)
```

### 4.4 로더(운영체제)의 역할
- 실행 파일 헤더(ELF/PE)의 **프로그램 헤더**를 읽어 **로드 가능한 세그먼트**를 가상 주소 공간에 매핑.
- `.text`는 RX(실행/읽기), `.data`는 RW 등 **권한** 설정.
- **ASLR**: 베이스 주소 무작위화. PIE(Position Independent Executable)와 결합해 주소 랜덤화 강화.
- **재배치**: PIE/PIC에서는 실제 로드 주소에 따라 참조 수정(ELF의 `R_*` 재배치 타입 적용).

---

## 5. 명령어 인코딩과 주소지정 — “바이트로 어떻게 담기나”

### 5.1 x86: 가변 길이·다양한 모드
- 프리픽스(0~4B) + 오퍼코드(1~3B) + ModR/M + SIB + 디스플 + 즉시값
- 예: `mov eax, 1` 의 기계어 바이트는 아키텍처·옵코드에 따라 다양.

### 5.2 RISC(ARM/RISC-V): 고정 길이 지향
- 대부분 4바이트(압축命令 C 확장 시 2바이트 포함).
- 디코드가 단순, 파이프라인 설계가 용이.

#### RISC-V 단순 예(개념)
```asm
addi a0, zero, 5   ; a0 = 5
addi a1, zero, 7   ; a1 = 7
add  a0, a0, a1    ; a0 = a0 + a1
ret
```

---

## 6. 호출 규약과 스택 프레임 — 함수 호출의 기계적 의의

### 6.1 일반적 프로로그/에필로그(x86-64 SysV)
```asm
push    rbp
mov     rbp, rsp
sub     rsp, N          ; 로컬 변수 영역
...                     ; 본문
leave                   ; mov rsp, rbp; pop rbp
ret
```

- **스택 정렬**: SysV는 호출 시 `rsp % 16 == 8` 유지(리턴 주소로 8B 소비되므로 함수 진입 시 16 정렬 필요).
- **callee-saved 레지스터**는 보존/복구 의무.

### 6.2 varargs와 레지스터/스택 인자 혼합
- `printf(const char *fmt, ...)` 처럼 **가변 인자**는 호출 규약에서 **어떤 인자를 레지스터/스택에 두었는지** 명확히 정의, 호출자/피호출자 합의가 필요.

---

## 7. 정적·동적 라이브러리, PIC/PIE, ASLR, RELRO, Canary

| 기법 | 목적 | 핵심 |
|---|---|---|
| **PIC/PIE** | 위치 독립 코드 | 절대주소 회피; GOT/PC상대 참조 |
| **ASLR** | 공격 난이도 상승 | 코드/힙/스택/라이브러리 매핑 주소 랜덤 |
| **RELRO** | GOT 보호 | `partial/ full RELRO`로 GOT 쓰기 차단(초기 바인딩 후) |
| **Stack Canary** | 스택 오버플로 탐지 | 리턴 직전 카나리 검증 |
| **NX/DEP** | 실행 금지 | 데이터 영역 실행 금지(X) |

**현대 컴파일 기본값**은 대개 `-fPIE -pie`, `-fstack-protector-strong`, `-Wl,-z,relro,-z,now`, `-fno-plt` 등을 포함하는 방향으로 진화.

---

## 8. 마이크로아키텍처: 디코드→µop→실행 — “기계어 밑의 기계어”

- **디코드 프런트엔드**: x86 가변 길이를 µop로 분해(디코드/µop 캐시).
- **리네이밍**: 아키텍처 레지스터 → 물리 레지스터, **의존성 해소**.
- **OOO 실행**: 준비된 µop부터 실행, **재정렬 버퍼(ROB)** 로 커밋 순서 유지.
- **브랜치 예측**: BTB/BPU로 분기 목표/결과 예측. 실패 시 플러시 비용↑.
- **마이크로-펑션**: CISC 복합 명령(예: `REP MOVSB`)은 내부적으로 대량 µop 혹은 **전용 엔진**으로 처리.

> 실무 메시지: 성능은 **명령어 자체** 뿐 아니라 **분기 패턴, 메모리 접근, 레이턴시/대역폭**에 지배된다.

---

## 9. 중간 표현(IR), SSA, LTO, JIT — “오늘날의 컴파일은 다단계 최적화”

- **SSA(Static Single Assignment)**: 각 변수 1회 대입 가정 → 데이터흐름 최적화 용이.
- **GIMPLE/LLVM IR**: 프런트엔드 독립 최적화의 무대.
- **LTO(Link Time Optimization)**: 링크 시점 **전체 프로그램**을 보며 인라이닝/제거.
- **JIT(Just-In-Time)**: 런타임 프로파일을 바탕으로 재컴파일/가변 최적화(자바 HotSpot, .NET RyuJIT, JS 엔진 등).

```text
C → LLVM IR(opt) → Machine IR(isel) → ASM → OBJ
          ↑ LTO/PGO(프로파일 유도 최적화)
```

---

## 10. 예제: 작은 프로그램이 ELF로 실행되기까지

### 10.1 C 코드
```c
#include <stdio.h>

static int square(int x) { return x*x; }

int main(void) {
    int s = square(7);
    printf("s=%d\n", s);
    return 0;
}
```

### 10.2 개략적 빌드 산출
- `square` 는 같은 번역단위이므로 **정적 바인딩**(내부 심볼) → 다른 오브젝트에서 참조 불가.
- `printf` 는 **외부 심볼** → 동적 링크 대상.

### 10.3 실행 시퀀스(ELF/Linux)
1. 커널이 ELF 헤더를 검사, **동적 로더**(예: `/lib64/ld-linux-x86-64.so.2`)를 맵핑.
2. 로더가 프로그램의 **PT_LOAD 세그먼트**들을 매핑(RX/RW).
3. 필요 `.so`(예: `libc.so.6`)를 탐색/맵핑 → **심볼 해석**/재배치.
4. `init_array`(C++ 전역 생성자 등) 호출 후 `main` 진입.
5. `printf@PLT` 호출 → (첫 호출 시) **지연 바인딩**으로 실제 주소를 GOT에 채우고 점프.
6. 종료 시 `fini_array` 호출.

### 10.4 공용 심볼과 인터포지션
- ELF는 동일 심볼이 다수 정의될 때 **해석 순서/버전**에 따라 선택(인터포지션).
- `LD_PRELOAD` 로 사용자 정의 `malloc` 을 삽입 가능(성능 계측/후킹에 활용, 보안상 고려 필요).

---

## 11. 운영체제 인터페이스 — 트랩, 인터럽트, 예외, 시스템 콜

- **트랩(소프트웨어 인터럽트)**: 유저모드→커널모드 전환(권한 상승).
- x86-32: `int 0x80`, x86-64: `syscall`, AArch64: `svc #imm`.
- **시스템 콜 ABI**: 어떤 레지스터로 인자/번호를 전달할지 표준화.

예(리눅스 x86-64, `write(1, buf, len)`):
```asm
mov rax, 1     ; SYS_write
mov rdi, 1
mov rsi, buf
mov rdx, len
syscall
```

---

## 12. 디버그/분석 도구 — “이해는 도구로부터”

- **어셈블리 보기**: `gcc -S`, `clang -S`, `objdump -d`, `llvm-objdump -dr`.
- **ELF 구조**: `readelf -a`, `eu-readelf`, `nm`, `objdump -h`.
- **심볼/주소**: `addr2line`, `nm -D`, `ldd`.
- **IR**: `clang -emit-llvm -S foo.c -o foo.ll`.
- **프로파일링**: `perf`, `pmu-tools`, `gprof`, `callgrind`, `perf record|report`.

---

## 13. 보안과 기계 수준 표현 — 취약점은 기계 경계에서 생긴다

- **버퍼 오버플로**: 스택 프레임의 리턴 주소/저장 레지스터 덮개 → **ROP** Gadgets 악용.
- **형식 문자열**: `printf(user)` 같은 실수는 임의 읽기/쓰기.
- **RELRO/NX/ASLR/Canary/CFI**: 링크/로딩/실행 계층에서 방어.
- **W^X** 원칙: 동일 페이지에 쓰기와 실행을 동시에 허용하지 않기.

---

## 14. 역사적 전환점(타임라인 하이라이트)

```
1950s: 기계어/어셈블리 → 초기 컴파일러(FORTRAN)
1970s: C/UNIX → 포터블 시스템 프로그래밍의 표준
1980s: RISC 운동(단순 인코딩/파이프라인), ELF(유닉스 계열 보편 포맷)
1990s: 동적 링크 확산(.so/.dll), OOO, 분기 예측 고도화
2000s: x86-64 전환, SSE/AVX, JIT VM(HotSpot/.NET) 대중화
2010s: AArch64 모바일/서버 확산, PIE/ASLR 기본, LTO/PGO
2020s: RISC-V 상용화, 대규모 LTO, SVE/AVX-512, 보안 하드닝 기본값 강화
```

---

## 15. 실전 체크리스트 — 시스템을 “기계 수준”으로 읽기

1. **ISA/ABI**: 호출 규약/레지스터 보존 규칙/스택 정렬을 안다.  
2. **오브젝트/ELF**: 섹션·재배치·PLT/GOT·PIE 동작을 이해한다.  
3. **로더**: 동적 해석 순서, 심볼 인터포지션, `LD_PRELOAD`의 의미를 안다.  
4. **마이크로아키텍처**: 분기 예측·메모리 계층·µop 분해가 성능에 미치는 영향을 감안한다.  
5. **IR/LTO/JIT**: 최적화가 어떤 가정에서 동작하는지(별칭, 미정의 동작) 파악한다.  
6. **보안**: NX/ASLR/RELRO/Canary/CFI 등 실행 모델 차원의 방어를 고려한다.  
7. **도구**: `objdump/readelf/llvm-objdump/perf`로 결과를 **직접 확인**한다.

---

## 16. 부록: 간단한 케이스 스터디 3선

### 16.1 `printf` 호출의 실제(ELF/PLT)
```c
#include <stdio.h>
int main(){ puts("hi"); }
```

개념적 디스어셈(일부):
```asm
call    puts@PLT        ; PLT 엔트리로 점프
; PLT 엔트리:
jmp     QWORD PTR [rip+off_to_GOT]   ; GOT[puts]로 간접 점프
; 초회 호출 시 로더가 GOT[puts]에 실제 libc puts 주소를 채움
```

### 16.2 `-O0` vs `-O2`의 차이
- `-O0`: 프롤로그/에필로그 과다, 레지스터 활용 낮음, 분기 많음.
- `-O2`: 인라이닝/루프 최적화/레지스터 할당, **cmov**/벡터화 적극 사용.

### 16.3 PIE와 절대주소 금지
- **PIE**: 코드/데이터를 **PC 상대**로 참조. 절대 주소 상수 금지.
- 장점: **ASLR** 영향 최대화(실행 파일 자체도 무작위 베이스).

---

## 17. 연습 과제

1) `int add(int, int)` 를 각각 **x86-64 SysV**/ **Win64** 호출 규약으로 수동 어셈블리 작성.  
2) 작은 C 프로그램을 `-fno-plt -Wl,-z,now` 로 빌드하고 `objdump -d` 로 PLT 호출 변화 관찰.  
3) `clang -emit-llvm -S` 로 IR을 보고, **GEP(getelementptr)**와 **SSA**를 이해.  
4) 동일 코드의 `-O0/-O2` 차이를 `perf stat` 으로 측정(분기 실패/IPC/캐시 미스).  
5) `LD_PRELOAD` 를 이용해 `malloc/free` 후킹, 심볼 해석 순서 실험.

---

## 결론

“프로그램의 기계 수준 표현”은 **하드웨어 명령어 바이트**만이 아니다.  
그 위·아래로 이어진 **컴파일러의 IR/최적화**, **오브젝트/링커/로더의 형식과 규약(ABI)**,  
그리고 **마이크로아키텍처의 실제 실행 모델(µop/분기 예측/메모리 계층)** 까지를 묶어 이해해야 비로소 **성능·디버깅·보안**을 한 덩어리로 다룰 수 있다.

역사는 **표현의 인간화(고급언어)** 와 **실행의 자동화(컴파일/링킹/로딩)** 를 발전시켜 왔다.  
오늘의 개발자는 이 스택을 **수직으로 관통**하여 읽을 때, 코드가 **왜 그렇게 빨라지거나 느려지는지**,  
왜 어떤 취약점이 생기고 어떻게 방어되는지, **근본적인 답**을 얻을 수 있다.