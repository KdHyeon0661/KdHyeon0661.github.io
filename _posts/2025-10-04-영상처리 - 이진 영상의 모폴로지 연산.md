---
layout: post
title: 영상처리 - 이진 영상의 모폴로지 연산
date: 2025-10-04 20:25:23 +0900
category: 영상처리
---
# 이진 영상의 모폴로지 연산

## 1. 모폴로지를 위한 기본 정의

### 1.1 구조 요소(Structuring Element; SE)
모폴로지 연산은 **구조 요소** \(B\) 를 사용하여 집합 \(A\) (전경 픽셀의 집합)에 대하여 기하학적 연산을 수행합니다.  
좌표 원점이 \(B\) 의 **앵커(anchor)** 로 간주됩니다(보통 중심).

- **예: 3×3 정사각 SE**
\[
B=\{(-1,-1), (0,-1), (1,-1), (-1,0), (0,0), (1,0), (-1,1), (0,1), (1,1)\}
\]

### 1.2 이진 영상 ↔ 집합
밝기 255를 **전경**(집합 포함), 0을 **배경**(집합 제외)으로 해석합니다.
\[
(x,y)\in A \iff I(x,y)=255
\]

---

## 2. 이진 영상의 **침식**과 **팽창**

### 2.1 침식(Erosion) \(A\ominus B\)
“전경을 **줄이는**” 연산.  
\[
A\ominus B=\{z\mid B\_z\subseteq A\}
\]
즉, 앵커를 \(z\) 에 놓았을 때 \(B\) 의 모든 점이 \(A\) 안에 들어가야 \(z\) 가 전경.

- **효과**: 얇아짐, 작은 돌기/노이즈 제거, 구멍 커짐.

### 2.2 팽창(Dilation) \(A\oplus B\)
“전경을 **늘리는**” 연산.  
\[
A\oplus B=\{z\mid (\hat{B})\_z\cap A\neq \emptyset\}
\]
(이진 구현 관점: 앵커 주위 **하나라도 전경**이면 전경으로 설정)  
- **효과**: 두꺼워짐, 작은 구멍 메움, 끊어진 부분 연결 경향.

---

## 3. 이진 영상의 **열기**와 **닫기**

### 3.1 열기(Opening) \(A\circ B\)
\[
A\circ B=(A\ominus B)\oplus B
\]
- **효과**: **소금 잡음** 제거·가늘어진 돌기 제거(형태 보존력 우수), 객체의 외형을 부드럽게.

### 3.2 닫기(Closing) \(A\bullet B\)
\[
A\bullet B=(A\oplus B)\ominus B
\]
- **효과**: **작은 구멍/틈** 메움, 끊어진 윤곽 연결에 유리.

---

## 4. 구현 — 구조 요소 생성 + 침식/팽창/열기/닫기/경계

아래 코드는 **반복 사용 가능한 모듈**입니다. (필요 시 13.1/13.2의 변환 루틴을 재사용해도 좋습니다.)

```cpp
// Morphology.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <cmath>
#include <algorithm>
#include <string>
#include "IppDib.h"
#include "IppImage.h"

// ---------- 공통 유틸 ----------
inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }
inline int clampi(int v,int lo,int hi){ return v<lo?lo:(v>hi?hi:v); }

// BGRA32 → 8비트 이진(0/255). (비이진 입력은 “0이면 배경, 그 외 전부 전경”으로 강제)
inline void DibToBinary8(const IppDib& dib, IppImage<uint8_t>& bin){
    bin.create(dib.width(), dib.height());
    for (int y=0; y<dib.height(); ++y){
        const uint8_t* s=(const uint8_t*)dib.bits() + (size_t)y*dib.stride();
        uint8_t* d=bin.row(y);
        for (int x=0; x<dib.width(); ++x){
            uint8_t v = (s[x*4+0] | s[x*4+1] | s[x*4+2]) ? 255 : 0;
            d[x]=v;
        }
    }
}
inline IppDib Binary8ToDib(const IppImage<uint8_t>& g){
    IppDib d; d.create(g.width(), g.height(), 32);
    for (int y=0; y<g.height(); ++y){
        const uint8_t* s=g.row(y); uint8_t* dd=(uint8_t*)d.bits() + (size_t)y*d.stride();
        for (int x=0; x<g.width(); ++x){ dd[x*4+0]=dd[x*4+1]=dd[x*4+2]=s[x]; dd[x*4+3]=255; }
    }
    return d;
}

// ---------- 구조 요소 ----------
enum class SE_Shape { Square, Disk, Diamond, Cross };

struct StructuringElement {
    SE_Shape shape=SE_Shape::Square;
    int radius=1;           // Square: half-size, Disk: 픽셀 반지름, Diamond: L1, Cross: L1 십자
    std::vector<int> dx, dy; // 앵커 기준 오프셋 목록( (0,0) 포함 )
};

inline StructuringElement MakeSE(SE_Shape shape, int radius){
    radius = std::max(0, radius);
    StructuringElement se; se.shape=shape; se.radius=radius;
    if (radius==0){ se.dx={0}; se.dy={0}; return se; }

    auto push=[&](int x,int y){ se.dx.push_back(x); se.dy.push_back(y); };

    switch(shape){
    case SE_Shape::Square:
        for (int j=-radius;j<=radius;++j)
            for (int i=-radius;i<=radius;++i) push(i,j);
        break;
    case SE_Shape::Disk: {
        int r2=radius*radius;
        for (int j=-radius;j<=radius;++j)
            for (int i=-radius;i<=radius;++i)
                if (i*i + j*j <= r2) push(i,j);
        break;
    }
    case SE_Shape::Diamond: // L1 ball
        for (int j=-radius;j<=radius;++j)
            for (int i=-radius;i<=radius;++i)
                if (std::abs(i) + std::abs(j) <= radius) push(i,j);
        break;
    case SE_Shape::Cross:
        for (int k=-radius;k<=radius;++k){ push(k,0); if (k!=0) push(0,k); }
        break;
    }
    return se;
}

// ---------- 침식 / 팽창 (외부는 0으로 가정; 바깥은 배경) ----------
inline void Erode(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst, const StructuringElement& se){
    const int W=src.width(), H=src.height(); dst.create(W,H);
    for (int y=0;y<H;++y){
        const uint8_t* srow=src.row(y); uint8_t* drow=dst.row(y);
        for (int x=0;x<W;++x){
            uint8_t ok=255;
            for (size_t k=0;k<se.dx.size();++k){
                int xx=x+se.dx[k], yy=y+se.dy[k];
                if ((unsigned)xx>=(unsigned)W || (unsigned)yy>=(unsigned)H || src.row(yy)[xx]==0){ ok=0; break; }
            }
            drow[x]=ok;
        }
    }
}
inline void Dilate(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst, const StructuringElement& se){
    const int W=src.width(), H=src.height(); dst.create(W,H);
    for (int y=0;y<H;++y){
        uint8_t* drow=dst.row(y); std::fill(drow,drow+W,0);
    }
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            if (src.row(y)[x]==0) continue;
            for (size_t k=0;k<se.dx.size();++k){
                int xx=x+se.dx[k], yy=y+se.dy[k];
                if ((unsigned)xx<(unsigned)W && (unsigned)yy<(unsigned)H) dst.row(yy)[xx]=255;
            }
        }
    }
}

// ---------- 열기 / 닫기 / 반복 ----------
inline void Open(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst, const StructuringElement& se, int iters=1){
    IppImage<uint8_t> tmp1=src, tmp2; 
    for (int i=0;i<iters;++i){ IppImage<uint8_t> t; Erode(tmp1,t,se); tmp1.swap(t); }
    for (int i=0;i<iters;++i){ IppImage<uint8_t> t; Dilate(tmp1,t,se); tmp1.swap(t); }
    dst.swap(tmp1);
}
inline void Close(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst, const StructuringElement& se, int iters=1){
    IppImage<uint8_t> tmp1=src, tmp2;
    for (int i=0;i<iters;++i){ IppImage<uint8_t> t; Dilate(tmp1,t,se); tmp1.swap(t); }
    for (int i=0;i<iters;++i){ IppImage<uint8_t> t; Erode(tmp1,t,se); tmp1.swap(t); }
    dst.swap(tmp1);
}
inline void ErodeN(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst, const StructuringElement& se, int n){
    IppImage<uint8_t> cur=src,tmp;
    for(int i=0;i<n;++i){ Erode(cur,tmp,se); cur.swap(tmp); }
    dst.swap(cur);
}
inline void DilateN(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst, const StructuringElement& se, int n){
    IppImage<uint8_t> cur=src,tmp;
    for(int i=0;i<n;++i){ Dilate(cur,tmp,se); cur.swap(tmp); }
    dst.swap(cur);
}

// ---------- 모폴로지 경계/그래디언트 ----------
inline void MorphInnerBoundary(const IppImage<uint8_t>& src, IppImage<uint8_t>& boundary, const StructuringElement& se){
    IppImage<uint8_t> er; Erode(src, er, se);
    boundary.create(src.width(), src.height());
    for(int y=0;y<src.height();++y){
        const uint8_t* s=src.row(y); const uint8_t* e=er.row(y); uint8_t* d=boundary.row(y);
        for(int x=0;x<src.width();++x) d[x] = (s[x] && !e[x])? 255 : 0; // A - (A⊖B)
    }
}
inline void MorphOuterBoundary(const IppImage<uint8_t>& src, IppImage<uint8_t>& boundary, const StructuringElement& se){
    IppImage<uint8_t> di; Dilate(src, di, se);
    boundary.create(src.width(), src.height());
    for(int y=0;y<src.height();++y){
        const uint8_t* s=src.row(y); const uint8_t* a=di.row(y); uint8_t* d=boundary.row(y);
        for(int x=0;x<src.width();++x) d[x] = (a[x] && !s[x])? 255 : 0; // (A⊕B) - A
    }
}
inline void MorphGradient(const IppImage<uint8_t>& src, IppImage<uint8_t>& grad, const StructuringElement& se){
    IppImage<uint8_t> er, di; Erode(src, er, se); Dilate(src, di, se);
    grad.create(src.width(), src.height());
    for(int y=0;y<src.height();++y){
        const uint8_t* a=di.row(y); const uint8_t* b=er.row(y); uint8_t* d=grad.row(y);
        for(int x=0;x<src.width();++x) d[x] = (a[x] && !b[x])? 255 : 0; // (A⊕B) - (A⊖B)
    }
}

// ---------- 고수준 API (DIB 입출력) ----------
enum class MorphOp { Erode, Dilate, Open, Close, InnerBoundary, OuterBoundary, Gradient };

struct MorphOptions {
    MorphOp op = MorphOp::Open;
    SE_Shape shape = SE_Shape::Disk;
    int radius = 1;
    int iterations = 1;    // Erode/Dilate/Open/Close 반복
};

inline bool RunMorphology(const IppDib& in, IppDib& out, const MorphOptions& opt){
    if (!in) return false;
    IppImage<uint8_t> bin; DibToBinary8(in, bin);
    StructuringElement se = MakeSE(opt.shape, opt.radius);

    IppImage<uint8_t> dst;
    switch(opt.op){
    case MorphOp::Erode:        ErodeN(bin,dst,se,opt.iterations); break;
    case MorphOp::Dilate:       DilateN(bin,dst,se,opt.iterations); break;
    case MorphOp::Open:         Open(bin,dst,se,opt.iterations);    break;
    case MorphOp::Close:        Close(bin,dst,se,opt.iterations);   break;
    case MorphOp::InnerBoundary:MorphInnerBoundary(bin,dst,se);     break;
    case MorphOp::OuterBoundary:MorphOuterBoundary(bin,dst,se);     break;
    case MorphOp::Gradient:     MorphGradient(bin,dst,se);          break;
    }
    out = Binary8ToDib(dst);
    return true;
}
```

> 구현 메모  
> - **경계 조건**: 영상 바깥은 **배경(0)** 으로 가정(산업 표준).  
> - **반복(iterations)**: 반경을 키우는 효과(특히 Square/Cross). Disk/Diamond도 반복하면 유사하게 커짐.  
> - **성능**: Square는 수평/수직 누적합으로 **선형 시간 최적화** 가능하지만, 가독성 위해 직관적 구현을 제시했습니다.

---

## 5. **모폴로지** 대화 상자 & 메뉴

### 5.1 리소스 ID

```cpp
// resource.h (추가)
#define ID_MENU_MORPHOLOGY             87010

#define IDD_MORPHOLOGY_DLG             4400
#define IDC_RAD_MORP_ERODE             4401
#define IDC_RAD_MORP_DILATE            4402
#define IDC_RAD_MORP_OPEN              4403
#define IDC_RAD_MORP_CLOSE             4404
#define IDC_RAD_MORP_INB               4405
#define IDC_RAD_MORP_OUTB              4406
#define IDC_RAD_MORP_GRAD              4407

#define IDC_CMB_MORP_SHAPE             4410
#define IDC_EDIT_MORP_RADIUS           4411
#define IDC_EDIT_MORP_ITERS            4412
#define IDC_CHK_MORP_NEWWIN            4413
#define IDC_STC_MORP_SUMMARY           4414
```

### 5.2 RC

```rc
// ImageTool.rc (추가)
POPUP "&Binary"
BEGIN
    MENUITEM "Morphology...\tCtrl+M", ID_MENU_MORPHOLOGY
END

IDD_MORPHOLOGY_DLG DIALOGEX 0,0, 300, 176
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Binary Morphology"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Operation", -1, 12, 8, 132, 94
    AUTORADIOBUTTON "Erode",            IDC_RAD_MORP_ERODE, 22, 22, 60, 10, WS_TABSTOP
    AUTORADIOBUTTON "Dilate",           IDC_RAD_MORP_DILATE,22, 36, 60, 10
    AUTORADIOBUTTON "Open",             IDC_RAD_MORP_OPEN,  22, 50, 60, 10
    AUTORADIOBUTTON "Close",            IDC_RAD_MORP_CLOSE, 22, 64, 60, 10
    AUTORADIOBUTTON "Inner boundary",   IDC_RAD_MORP_INB,   22, 78, 100, 10
    AUTORADIOBUTTON "Outer boundary",   IDC_RAD_MORP_OUTB,  22, 92, 100, 10
    AUTORADIOBUTTON "Morph. gradient",  IDC_RAD_MORP_GRAD,  22, 106,100, 10

    LTEXT "SE shape:", -1, 160, 18, 50, 10
    COMBOBOX IDC_CMB_MORP_SHAPE, 220, 16, 72, 70, CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "Radius:",   -1, 160, 40, 40, 10
    EDITTEXT IDC_EDIT_MORP_RADIUS, 220, 38, 34, 14, ES_NUMBER
    LTEXT "Iterations:",-1, 160, 58, 50, 10
    EDITTEXT IDC_EDIT_MORP_ITERS,  220, 56, 34, 14, ES_NUMBER

    AUTOCHECKBOX "Open in new window", IDC_CHK_MORP_NEWWIN, 160, 78, 120, 12

    LTEXT "Summary:", -1, 12, 128, 50, 10
    LTEXT "", IDC_STC_MORP_SUMMARY, 62, 128, 230, 28

    DEFPUSHBUTTON "Run", IDOK,  176, 144, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 226, 144, 44, 16
END
```

### 5.3 대화 상자 코드 & 메뉴 핸들러

```cpp
// MorphologyDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "Morphology.hpp"

// 앱 공용(앞 장과 동일 스타일)
HWND CreateDocWindowFromDib(const IppDib& dib, const std::wstring& title);

class MorphologyDlg {
public:
    MorphologyDlg(HWND owner, IppDib& target) : owner_(owner), target_(target) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);

    MorphOptions ReadOptions(HWND h) const;

private:
    HWND owner_{};
    IppDib& target_;
};
```

```cpp
// MorphologyDlg.cpp
#include "MorphologyDlg.h"

INT_PTR MorphologyDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_MORPHOLOGY_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK MorphologyDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((MorphologyDlg*)l)->OnInit(h); }
    auto* self=(MorphologyDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
INT_PTR MorphologyDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_MORP_ERODE, IDC_RAD_MORP_GRAD, IDC_RAD_MORP_OPEN);
    SendDlgItemMessageW(h, IDC_CMB_MORP_SHAPE, CB_ADDSTRING, 0, (LPARAM)L"Square");
    SendDlgItemMessageW(h, IDC_CMB_MORP_SHAPE, CB_ADDSTRING, 0, (LPARAM)L"Disk");
    SendDlgItemMessageW(h, IDC_CMB_MORP_SHAPE, CB_ADDSTRING, 0, (LPARAM)L"Diamond");
    SendDlgItemMessageW(h, IDC_CMB_MORP_SHAPE, CB_ADDSTRING, 0, (LPARAM)L"Cross");
    SendDlgItemMessageW(h, IDC_CMB_MORP_SHAPE, CB_SETCURSEL, 1, 0); // Disk
    SetDlgItemInt(h, IDC_EDIT_MORP_RADIUS, 1, FALSE);
    SetDlgItemInt(h, IDC_EDIT_MORP_ITERS,  1, FALSE);
    CheckDlgButton(h, IDC_CHK_MORP_NEWWIN, BST_CHECKED);
    SetDlgItemTextW(h, IDC_STC_MORP_SUMMARY, L"(ready)");
    return TRUE;
}
MorphOptions MorphologyDlg::ReadOptions(HWND h) const{
    MorphOptions opt;
    if (IsDlgButtonChecked(h, IDC_RAD_MORP_ERODE)==BST_CHECKED) opt.op=MorphOp::Erode;
    else if (IsDlgButtonChecked(h, IDC_RAD_MORP_DILATE)==BST_CHECKED) opt.op=MorphOp::Dilate;
    else if (IsDlgButtonChecked(h, IDC_RAD_MORP_OPEN)==BST_CHECKED) opt.op=MorphOp::Open;
    else if (IsDlgButtonChecked(h, IDC_RAD_MORP_CLOSE)==BST_CHECKED) opt.op=MorphOp::Close;
    else if (IsDlgButtonChecked(h, IDC_RAD_MORP_INB)==BST_CHECKED) opt.op=MorphOp::InnerBoundary;
    else if (IsDlgButtonChecked(h, IDC_RAD_MORP_OUTB)==BST_CHECKED) opt.op=MorphOp::OuterBoundary;
    else opt.op=MorphOp::Gradient;

    int idx=(int)SendDlgItemMessageW(h, IDC_CMB_MORP_SHAPE, CB_GETCURSEL, 0, 0);
    opt.shape = (idx==0)? SE_Shape::Square : (idx==1)? SE_Shape::Disk : (idx==2)? SE_Shape::Diamond : SE_Shape::Cross;

    BOOL ok=FALSE;
    int r=GetDlgItemInt(h, IDC_EDIT_MORP_RADIUS, &ok, FALSE); opt.radius= ok? std::max(0,r):1;
    int it=GetDlgItemInt(h, IDC_EDIT_MORP_ITERS,  &ok, FALSE); opt.iterations= ok? std::max(1,it):1;
    return opt;
}
INT_PTR MorphologyDlg::OnCommand(HWND h, WPARAM w){
    switch(LOWORD(w)){
    case IDOK: {
        MorphOptions opt=ReadOptions(h);
        IppDib out;
        if (!RunMorphology(target_, out, opt)){
            MessageBoxW(h, L"실행 실패: 입력 영상을 확인하세요.", L"Morphology", MB_ICONERROR);
            return TRUE;
        }
        wchar_t sum[128];
        wsprintfW(sum, L"%ls, shape=%d, r=%d, it=%d",
            (opt.op==MorphOp::Erode?L"Erode": opt.op==MorphOp::Dilate?L"Dilate":
             opt.op==MorphOp::Open?L"Open":  opt.op==MorphOp::Close?L"Close":
             opt.op==MorphOp::InnerBoundary?L"InnerB": opt.op==MorphOp::OuterBoundary?L"OuterB": L"Gradient"),
            (int)opt.shape, opt.radius, opt.iterations);
        SetDlgItemTextW(h, IDC_STC_MORP_SUMMARY, sum);

        if (IsDlgButtonChecked(h, IDC_CHK_MORP_NEWWIN)==BST_CHECKED){
            CreateDocWindowFromDib(out, L"Morphology");
        }else{
            target_ = out; InvalidateRect(owner_, nullptr, FALSE);
        }
        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

```cpp
// main_multiwin.cpp (발췌)
#include "MorphologyDlg.h"

// ...
case ID_MENU_MORPHOLOGY:
    if (st && st->dib){
        MorphologyDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            UpdateStatusBasic(hWnd, st); // 상태바: op, r, it 등
        }
    }
    return 0;
```

---

## 6. 모폴로지 기법을 응용한 **외곽선 검출**

> 이진 영상에서의 “외곽선”은 전경 경계 픽셀 집합으로 간단히 정의할 수 있습니다.

### 6.1 수식
- **내부 경계(Inner boundary)**  
\[
\partial A\_{\text{in}} = A - (A\ominus B)
\]
- **외부 경계(Outer boundary)**  
\[
\partial A\_{\text{out}} = (A\oplus B) - A
\]
- **모폴로지 그래디언트**  
\[
G = (A\oplus B) - (A\ominus B)
\]
> \(B\) 는 보통 작은 구조 요소(예: Disk \(r=1\), Square \(3\times3\)).

### 6.2 구현 (이미 `Morphology.hpp` 에 포함)
- `MorphInnerBoundary`, `MorphOuterBoundary`, `MorphGradient` 가 각각 위 정의를 코드화.  
- **표시**: 결과가 이진 경계 맵(0/255)이므로 그냥 화면에 렌더링하거나, 색 오버레이가 필요하면 13.3장의 `DrawPolyline…` 대신 **픽셀 단위**로 컬러 오버레이를 해도 됩니다.

---

## 7. 예제 & 실전 시나리오

### 예제 A) **문서 스캔의 점 노이즈 제거**
- **상황**: 흰 배경 위 작은 검은 점(소금)들이 곳곳에 존재.  
- **동작**: `Binary → Morphology…` → **Open**, `SE=Disk`, `radius=1`, `iterations=1`, 새 창 출력.  
- **결과**: 작은 점들이 사라지고 글자 골격은 보존.

### 예제 B) **활자 끊김 연결**
- **상황**: 얇은 획이 끊겨 OCR 인식률 저하.  
- **동작**: `Dilate` (Square, r=1, it=1) → 얇은 간극 메움 → 이후 `Erode`(동일 SE)로 두께 복원(=Close).  
- **결과**: **닫기(Closing)** 로 작은 틈이 메워져 연결성 향상.

### 예제 C) **모폴로지 경계(Inner boundary)로 외곽선 추출**
- **상황**: 이진화된 부품 영상에서 윤곽선만 필요.  
- **동작**: `Inner boundary` (Disk r=1) → 결과를 빨간색 오버레이로 합성(선택).  
- **결과**: 얇은 단일 픽셀 경계 맵 확보(후속 길이 측정에 활용).

### 예제 D) **양품/불량 검사: 작은 구멍 메우기**
- **상황**: 도장 표면에 미세한 핀홀.  
- **동작**: `Close` (Disk r=1~2) 후 레이블링(13.2)로 **남은 작은 구멍만 카운트**.  
- **결과**: 의미있는 결함만 추출.

---

## 8. 정확성·성능·확장 팁

- **SE 선택**:  
  - **Disk**: 회전 대칭 → 가장 “자연스러운” 형태 보존.  
  - **Square**: 빠르고 구현 간단(분리 가능).  
  - **Diamond**: L1 거리 기반(격자 친화).  
  - **Cross**: 얇은 선에 집중(상하좌우 접촉만).
- **반지름 vs 반복**: 반지름을 크게 하느니 **반복**을 늘리는 편이 성능/품질 절충에 유리한 경우가 많습니다.  
- **경계 조건**: 본 코드는 외부를 **0(배경)** 으로 가정. 반사/복제 경계가 필요하면 별도 분기.  
- **고속화**:  
  - Square \( (2r+1)\times(2r+1) \) 는 1D **최댓값/최솟값 슬라이딩 윈도우**(H–B 알고리즘)로 \(\mathcal{O}(WH)\) 가능.  
  - 비트마스크/비트블록(64bit) 최적화로 Dilate/Erode를 수십 배 가속 가능.

---

## 9. 간단 자가 테스트

```cpp
// test_morphology.cpp
#include <cassert>
#include "IppDib.h"
#include "Morphology.hpp"

int main(){
    // 64x48: 작은 점 노이즈 + 사각형 객체
    IppDib dib; dib.create(64,48,32);
    // 배경 0
    for (int y=0;y<48;++y){
        uint8_t* d=(uint8_t*)dib.bits()+y*dib.stride();
        for(int x=0;x<64;++x){ d[x*4+0]=d[x*4+1]=d[x*4+2]=0; d[x*4+3]=255; }
    }
    auto set=[&](int x,int y){ uint8_t* p=(uint8_t*)dib.bits()+y*dib.stride()+x*4; p[0]=p[1]=p[2]=255; };
    // 사각형
    for(int y=12;y<=36;++y) for(int x=18;x<=46;++x) set(x,y);
    // 점 잡음 20개
    for(int i=0;i<20;++i){ int x= (i*7)%64, y=(i*11)%48; set(x,y); }

    MorphOptions opt; opt.op=MorphOp::Open; opt.shape=SE_Shape::Disk; opt.radius=1; opt.iterations=1;
    IppDib out;
    bool ok = RunMorphology(dib, out, opt); assert(ok);

    // 경계(Inner boundary)도 테스트
    opt.op=MorphOp::InnerBoundary; ok = RunMorphology(out, out, opt); assert(ok);
    return 0;
}
```

---

## 10. 요약
- 모폴로지는 **구조 요소(SE)** 를 기준으로 전경을 **줄이거나(침식)** **늘리는(팽창)** 연산이며,  
  조합으로 **열기(노이즈 제거)** 와 **닫기(구멍 메움)** 를 얻습니다.  
- 제공 코드로 Square/Disk/Diamond/Cross SE 생성부터 **침식/팽창/열기/닫기**, 그리고  
  **내/외부 경계·모폴로지 그래디언트** 까지 한 번에 구현 가능합니다.
- “Morphology…” 대화 상자에서 **연산/SE/반지름/반복**을 선택해 즉시 실전에 적용하세요.