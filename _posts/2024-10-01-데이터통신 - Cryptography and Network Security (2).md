---
layout: post
title: 데이터 통신 - Cryptography and Network Security (2)
date: 2024-10-01 21:20:23 +0900
category: DataCommunication
---
# 31.3 Other Aspects of Security — 무결성, 인증, 전자서명, 엔티티 인증, 키 관리

이전 절에서 **기밀성(confidentiality)** 을 다뤘다면, 이 절은 그 위에 서 있는 나머지 기둥들을 다루는 부분이다.

- **메시지 무결성(Message Integrity)**: “바뀌지 않았는가?”
- **메시지 인증(Message Authentication)**: “누가 보냈는가 + 중간에 바뀌지 않았는가?”
- **전자 서명(Digital Signature)**: “공개적으로 검증 가능한 서명으로, 위조/부인의 여지를 줄이는가?”
- **엔티티 인증(Entity Authentication)**: “접속해 온 **주체(사람/서비스/장비)** 가 누구인가?”
- **키 관리(Key Management)**: 위의 모든 보안을 **지탱하는 열쇠 관리 체계**

아래에서는 각 개념을 **네트워크 프로토콜(TLS, IPsec, SSH 등)** 과 연결해서 설명하고, 실제 서비스/코드 예제를 통해 감을 잡도록 한다.  
알고리즘과 키 길이에 대해서는 미국 NIST, 캐나다 사이버보안 센터 등 북미·유럽 자료 기준의 최신 권고를 반영한다.:contentReference[oaicite:0]{index=0}

---

## 1. Message Integrity — “내용이 바뀌지 않았는가?”

### 1.1 개념

**무결성(Integrity)** 은 메시지가 전송·저장되는 동안 **의도치 않은 오류나 악의적인 변경 없이 그대로 유지**되었음을 보장하는 성질이다.

- 예:  
  - SW 업데이트 파일이 다운로드 도중 손상되었는지 점검  
  - 은행 송금 요청 “10,000 → 100,000” 으로 바뀌지 않았는지 확인  
  - 로그가 사후에 조작되었는지 감지

여기서 중요한 점:

1. **무결성 ≠ 기밀성**  
   - 무결성은 **내용을 볼 수 있는지**는 신경 쓰지 않고,  
   - “**원본 그대로인가**”만 관심을 가진다.
2. **오류 검출 코드(CRC 등)** 와 **암호학적 무결성**은 다르다.
   - CRC는 주로 **우발적 오류(노이즈)** 검출용. 의도적인 위조에는 약하다.
   - **암호학적 해시/코드**는 공격자가 일부러 바꾸려 할 때도 안전하도록 설계.

실제 네트워크 프로토콜에서 무결성은 보통 다음 두 도구로 구현된다.

- **Cryptographic Hash Function**: SHA-256, SHA-384, SHA-512 등:contentReference[oaicite:1]{index=1}
- **Message Authentication Code(MAC)**: HMAC-SHA-256 등:contentReference[oaicite:2]{index=2}  

현대 실무에서는 **“해시만” 으로 무결성을 보장했다고 하지 않고**, 거의 항상 **MAC이나 전자서명**을 사용한다.

---

### 1.2 단순 해시와 그 한계

가장 순진한 방식:

> “메시지 m을 보내면서 SHA-256(m)을 같이 보내자. 수신자는 다시 해시해서 같은지만 확인하면 된다.”

문제점:

- 공격자 Eve가 m을 다른 m′로 바꾸고,
- **해시도 다시 계산해서** SHA-256(m′)을 보내버릴 수 있다.
- 수신자는 “해시 값도 일치하네?” 하고 속게 된다.

즉, **누구나 해시를 계산할 수 있다**는 것은 곧,  
**누구나 위조 메시지에도 올바른 해시를 붙일 수 있다**는 뜻이다.

그래서 해시 함수만으로는 **무결성 + “누가 보냈는가”** 를 함께 보장할 수 없다.

---

### 1.3 HMAC을 이용한 무결성과 인증

이를 해결하기 위한 표준 구조가 **HMAC(Hash-based Message Authentication Code)** 이다.:contentReference[oaicite:3]{index=3}

- 송신자와 수신자는 **비밀 키 K** 를 공유한다.
- MAC 값은 다음과 같이 계산한다.

$$
\mathrm{HMAC}_K(m) = H\Big((K \oplus \text{opad}) \parallel H\big((K \oplus \text{ipad}) \parallel m\big) \Big)
$$

- 여기서:
  - $$H$$: SHA-256, SHA-384 등의 암호학적 해시 함수
  - opad, ipad: 고정된 패딩 상수
  - $$\parallel$$: 바이트 연결(concatenation)
  - $$\oplus$$: XOR

핵심 포인트:

- **키 K를 모르면** 올바른 MAC 값을 만들 수 없다.
- 따라서 MAC을 검증했다는 것은
  1. 메시지가 중간에 바뀌지 않았고(무결성),
  2. K를 알고 있는 누군가(합법적인 송신자)에게서 왔음을 의미(메시지 인증).

---

### 1.4 HMAC 실제 예제 — 웹 API 요청 보호

예를 들어, 내부 마이크로서비스 간 요청에 다음과 같이 HMAC을 붙일 수 있다.

1. 공통 비밀 키 K를 배포 (예: KMS, Vault 등으로 관리).
2. 각 요청에 대해:
   - `timestamp`, `nonce`, `body` 를 이어 붙여 HMAC-SHA-256 계산.
   - HTTP 헤더에 `X-Signature: <hex HMAC>` 로 첨부.
3. 수신 측은:
   - 타임스탬프/논스 허용 범위 체크(재전송 방지),
   - 동일한 방식으로 HMAC 재계산 후 비교.

예시 흐름(의사코드):

```python
import hmac, hashlib, time, os

SECRET_KEY = b"...공유된_비밀키..."

def sign_request(body_bytes: bytes) -> dict:
    ts = str(int(time.time())).encode()
    nonce = os.urandom(16)  # 16-byte 랜덤
    to_mac = ts + b"|" + nonce + b"|" + body_bytes
    mac = hmac.new(SECRET_KEY, to_mac, hashlib.sha256).hexdigest()
    return {
        "X-Timestamp": ts.decode(),
        "X-Nonce": nonce.hex(),
        "X-Signature": mac,
    }
```

수신 측은 같은 방식으로 `X-Timestamp`, `X-Nonce`, `body`를 조합해서 HMAC을 다시 계산해 비교하면 된다. 공격자가 메시지를 바꾸려면 **SECRET_KEY** 를 알아야 한다.

---

### 1.5 무결성 vs 오류 검출 코드(CRC)

네트워크 계층에서는 전통적으로 **CRC-32, CRC-16** 같은 **에러 검출 코드**를 사용한다.

- CRC의 목적: **전송 중 비트 플립(노이즈)** 등 “우연한 오류”를 높은 확률로 잡아내기 위함.
- MAC/HMAC의 목적: **악의적 공격자**가 일부러 패킷을 변조할 때도 검출되게 하기 위함.

따라서 현대 프로토콜(TLS, IPsec, SSH 등)에서는 단순 CRC 대신 **HMAC-SHA-256**, **AEAD(AES-GCM 등)** 을 사용하여 **무결성 + 진위**를 함께 보장한다.:contentReference[oaicite:4]{index=4}

---

## 2. Message Authentication — “누가 보냈는가?”

### 2.1 정의와 목표

**메시지 인증(Message Authentication)** 은
> “이 메시지가 **특정 송신자** 에 의해 생성되었고, 도중에 변경되지 않았음을 검증” 하는 것

을 의미한다.

여기서 “송신자”는:

- 사용자(사람)
- 서버/서비스
- IoT 기기

가 될 수 있다.

메시지 인증을 달성하는 방식은 크게 두 가지:

1. **대칭키 기반 MAC (HMAC 등)**
2. **비대칭키 기반 전자 서명(Digital Signature)**

둘 다 무결성을 제공하지만, **검증 가능한 주체 범위**가 다르다.

---

### 2.2 MAC 기반 메시지 인증의 특징

MAC (특히 HMAC)의 특징:

- **송신자와 수신자 모두 같은 비밀 키 K를 공유**한다.
- 검증에 실패하면
  - “메시지가 위조/변조되었다”
  - 또는 “잘못된 키를 사용했다”
  - 정도만 알 수 있다.
- 그러나 **누가 위조했는지**까지는 분리해서 알 수 없다.
  - 송신자와 수신자가 모두 키를 알고 있으면,
  - 둘 중 누구나 그 MAC을 만들 수 있으므로,
  - 나중에 “이 MAC을 누가 만들었는지” 법적 책임을 따지기 어렵다.
- 따라서 MAC은 **“조직 내부 서비스 간”** 메시지 인증에 잘 맞다.
  - 마이크로서비스 API
  - 서버↔서버 간 RPC
  - VPN 내부 트래픽(IPsec AH/ESP 등)

---

### 2.3 디지털 서명 기반 메시지 인증과의 차이

**디지털 서명**은 아래에서 자세히 다루지만, MAC과 대비하면:

| 항목 | MAC(HMAC 등) | 디지털 서명(RSA/ECDSA/EdDSA 등) |
|------|---------------|----------------------------------|
| 키 종류 | 대칭(같은 키) | 비대칭(개인키/공개키) |
| 키 보유자 | 송신자+수신자(공유) | 개인키: 송신자만, 공개키: 누구나 |
| 검증 주체 | 키를 아는 모든 사람 | 누구나 |
| 법적 책임(부인 방지) | 애매함 | 상대적으로 강함 |
| 사용 예 | 내부 API, VPN, 메시지 큐 | TLS 인증서, 코드 서명, 전자계약 |

즉, **메시지 인증 = MAC or 서명**이지만, **누구에게 어떤 신뢰를 줄 것인지** 에 따라 선택이 달라진다.

---

### 2.4 재전송 공격과 메시지 인증

메시지 무결성과 인증만으로는 **재전송 공격(replay)** 을 막을 수 없다.

- 공격자가 정상 메시지를 캡처했다가, 나중에 그대로 다시 보내면
- 무결성·인증 모두 “OK”가 되어버린다.

그래서 대부분의 프로토콜은 다음과 같은 **재전송 방지 요소**를 같이 쓴다.

- **Nonce/Sequence Number**: 각 메시지에 단조 증가 번호 또는 랜덤 nonce 포함
- **Timestamp**: “몇 초 이내의 요청만 유효”로 제한
- **세션 키**: 세션마다 다른 키 사용

예: TLS 1.3에서는 핸드셰이크로 생성한 **세션 키** 아래에서, 모든 애플리케이션 데이터에 대해 **시퀀스 번호와 함께 AEAD 암호(AES-GCM 등)** 를 사용해 재전송 공격을 막는다.:contentReference[oaicite:5]{index=5}

---

## 3. Digital Signature — 전자 서명

### 3.1 전자 서명의 목적

전자 서명은 다음을 보장하려는 메커니즘이다.

1. **무결성**: 서명 대상 데이터가 변조되지 않았는가?
2. **인증**: 서명한 **주체(개인·서버)** 는 누구인가?
3. **부인 방지(Non-repudiation)**: 나중에 “내가 한 서명이 아니다”라고 주장하기 어렵게 만들기.

디지털 서명은 법적 효력을 담보하기 위해, PKI, 절차, 로그, 정책까지 포함한 **전체 시스템**이 필요하지만,  
네트워크/암호 관점에서는 다음 두 요소가 핵심이다.

- **개인키(Private Key)**: 서명에만 쓰고 철저히 숨겨야 함.
- **공개키(Public Key)**: 누구에게나 공개. 검증용.

---

### 3.2 서명 알고리즘과 현대 권고

대표적인 서명 알고리즘:

- **RSA 서명** (RSASSA-PSS 등)
- **DSA** (과거 많이 사용, 현재는 거의 사용하지 않음)
- **ECDSA (Elliptic Curve DSA)** — P-256, P-384 등
- **EdDSA (Ed25519, Ed448)** — 현대적인 타원곡선 서명 방식:contentReference[oaicite:6]{index=6}

현재(2025년 기준) 미국 NIST 및 서구권 가이드라인에서 권고하는 수준:

- **RSA**: 최소 2048비트, 장기 사용은 3072비트 이상 고려
- **ECDSA / EdDSA**:
  - P-256, P-384, Ed25519 등
  - RSA 3072비트에 상당하는 보안 강도를 훨씬 짧은 키로 제공

또한 RSA 서명에서는 **PSS 패딩(RSASSA-PSS)** 가 TLS 1.3 등에서 요구되는 현대적 방식이다.:contentReference[oaicite:7]{index=7}

---

### 3.3 RSA 서명 구조(간단한 수식)

RSA 키는 세 수로 구성된다.

- 공개키: $$(n, e)$$
- 개인키: $$(n, d)$$

**서명(Sign)**:

1. 메시지 $$m$$에 대해 해시 $$h = H(m)$$ 를 계산.
2. 개인키로 서명 값 $$s$$ 를 계산:
   $$
   s = h^d \bmod n
   $$

**검증(Verify)**:

1. 서명 $$s$$ 와 메시지 $$m$$ 을 받아 해시 $$h = H(m)$$ 계산.
2. 공개키로 $$v = s^e \bmod n$$ 를 구한다.
3. $$v$$ 가 $$h$$ 와 일치하면 서명 유효.

실제 표준에서는 **패딩(PSS)**, **해시 선택** 등 여러 안전장치를 추가한다.  
수학적으로는 “개인키로 한 연산을 공개키로 되돌릴 수 있다”는 점이 핵심이다.

---

### 3.4 실제 예제 — 소프트웨어 업데이트 서명

시나리오:

- 리눅스 배포판에서 패키지(.rpm, .deb)를 배포한다.
- 공격자가 미러 서버를 해킹해 악성 패키지를 올릴 수 있다.
- 사용자들은 “이 패키지가 진짜 배포자 것이 맞는지” 확인해야 한다.

절차:

1. 배포자는 **개인키/공개키** 쌍을 생성하고, 공개키는 배포판에 내장한다.
2. 패키지를 빌드할 때 메시지 해시(SHA-256)를 구하고 개인키로 서명.
3. 패키지 파일과 서명 파일(.sig)을 함께 배포.
4. 사용자는 패키지를 설치하기 전에:
   - 내장된 공개키로 서명 검증.
   - 검증 실패 시 설치 거부.

이런 구조는:

- **APT, YUM, Homebrew** 등 대부분의 패키지 관리자가 사용.
- 네트워크 상에서 패키지가 가로채여 바뀌더라도, **서명 검증에서 차단**된다.

---

### 3.5 네트워크 상의 디지털 서명 용례

- **TLS 서버 인증서**
  - 인증기관(CA)이 서버 공개키에 대해 **CA 개인키로 서명**한 인증서를 발행.
  - 클라이언트는 CA의 공개키(루트/중간 CA)를 이용해 서버 인증서 검증.
- **S/MIME, OpenPGP**
  - 이메일에 전자서명을 붙여 송신자 인증 및 무결성 보장.
- **JWT(JWS) 토큰**
  - 서버가 개인키로 토큰에 서명, 다른 서비스는 공개키로 검증.

---

## 4. Entity Authentication — “접속한 주체가 누구인가?”

### 4.1 개념

**엔티티(entity)** 는 **사용자, 디바이스, 서버, 서비스** 등 네트워크에 참여하는 “주체”다.  
**엔티티 인증(Entity Authentication)** 은 이 주체의 **정체를 검증하는 과정**이다.

NIST SP 800-63-4는 이를 **디지털 아이덴티티**의 핵심 요소로 정의하며,  
인증 수준(Authenticator Assurance Level)을 단계적으로 제시한다.:contentReference[oaicite:8]{index=8}

---

### 4.2 인증 요소와 다중 요소 인증(MFA)

인증 요소는 보통 세 가지 범주:

1. **지식(knowledge)**: 사용자가 “아는 것”
   - 비밀번호, PIN, 패턴 등
2. **소지(possession)**: 사용자가 “가지고 있는 것”
   - OTP 토큰, 스마트폰 앱, 보안키(FIDO2, U2F), 스마트카드
3. **고유 특성(inherence)**: 사용자의 “신체/행동적 특징”
   - 지문, 얼굴, 홍채, 음성, 타이핑 패턴 등

**다중 요소 인증(Multi-factor Authentication)** 은  
이 중 **서로 다른 종류의 요소 두 개 이상**을 결합하는 것:

- 비밀번호(지식) + 스마트폰 OTP(소지)
- 비밀번호(지식) + FIDO2 보안키(소지)
- 스마트카드(소지) + PIN(지식)

---

### 4.3 프로토콜 관점: 챌린지-리스폰스

엔티티 인증은 네트워크 프로토콜 수준에서 보통 **챌린지-리스폰스** 패턴으로 구현된다.

간단 예:

1. 서버가 난수 **challenge C** 를 클라이언트에게 전송.
2. 클라이언트는 자신의 비밀(비밀번호, 키)을 이용해 C와 함께 **응답 R** 을 계산.
3. 서버는 **저장된 비밀** 또는 **공개키/인증정보**로 R이 올바른지 검증.

대칭키 방식 예(단순화):

- 서버와 클라이언트가 미리 공유한 비밀 키 K를 가정.
- 서버 → 클라이언트: 난수 C
- 클라이언트: R = HMAC(K, C)
- 서버: 같은 방식으로 HMAC(K, C)를 계산해 비교

공개키 방식 예:

- 서버는 클라이언트의 **공개키** 를 알고 있다.
- 서버 → 클라이언트: C
- 클라이언트: 개인키로 C에 서명한 값 S를 전송
- 서버: 공개키로 서명을 검증

---

### 4.4 상호 인증(Mutual Authentication)

단순 로그인처럼 “클라이언트만 인증되는” 경우도 있지만,  
TLS 같은 프로토콜에서는 **서버와 클라이언트가 서로를 인증**할 수 있다.

- **TLS 1.3**
  - 기본은 서버 인증(서버 인증서).
  - 추가로 클라이언트 인증서(클라이언트 cert + 개인키)로 **상호 인증** 구성 가능.:contentReference[oaicite:9]{index=9}
- **EAP-TLS** (Wi-Fi 엔터프라이즈)
  - 802.1X 기반 네트워크 접속에서, 양쪽의 인증서를 확인하여 상호 인증 달성.

---

### 4.5 실무 예제 — 회사 VPN 접속

1. 사용자는 **사내 계정**과 **FIDO2 보안키**를 가진다.
2. VPN 게이트웨이는:
   - TLS 서버 인증서로 자신을 인증.
   - 클라이언트에게 **사용자 인증** 및 보안키 기반 **강한 2FA** 요청.
3. 사용자는 브라우저/클라이언트를 통해:
   - ID/비밀번호 입력(지식),
   - 보안키를 터치(소지).
4. 서버는 두 요소를 검증해 **엔티티(직원)** 를 인증하고 VPN 터널을 열어준다.

---

## 5. Key Management — 키 수명주기와 운영

### 5.1 왜 키 관리가 더 중요해졌는가

현대 암호 알고리즘(AES, SHA-2, 현대 서명 알고리즘)은 **알고리즘 자체는 충분히 강력**하다.:contentReference[oaicite:10]{index=10}

대부분의 보안 사고는 알고리즘이 깨져서라기보다:

- 키가 **유출**되었거나 (GitHub에 노출, 디스크 평문 저장)
- 키가 **오랫동안 재사용**되었거나
- 키 접근 권한 관리가 허술했기 때문에 발생한다.

그래서 미국 NIST SP 800-57 등은 **키 관리**를 별도 문서로 다루며, 키의 **수명주기(Lifecycle)** 전 과정을 정의한다.:contentReference[oaicite:11]{index=11}

---

### 5.2 키 수명주기

1. **키 생성(Key Generation)**
   - 고품질 난수(하드웨어 RNG, OS CSPRNG)를 사용.
   - 키 길이:
     - AES: 128/192/256비트 (보통 128 또는 256)
     - RSA: 2048비트 이상
     - ECC: P-256, P-384 등

2. **키 배포(Key Distribution)**
   - 대칭키: 보통 **키 교환 프로토콜(DH/ECDH)** 이나 **키 전달 메커니즘**으로 공유.
   - 비대칭키: 공개키는 인증서(PKI)로 배포.

3. **키 사용(Key Use)**
   - 암호 알고리즘 및 모드에 맞게 사용.
   - “한 키로 너무 많은 데이터”를 암호화하지 않도록 제한(키 사용량 제한).

4. **키 회전(Key Rotation / Renewal)**
   - 일정 기간 또는 사용량이 지나면 새 키로 교체.
   - 세션 키는 짧은 수명(분~시간), 장기 키는 수개월~수년.

5. **키 폐기(Key Destruction)**
   - 더 이상 필요 없으면 안전하게 삭제(메모리 및 저장장치).
   - HSM/TPM 등에서는 “키 삭제 명령”으로 키 슬롯을 직접 파기.

---

### 5.3 키 종류와 역할

#### 5.3.1 대칭키(Symmetric Key)

- AES, ChaCha20 등에서 사용하는 키.
- **같은 키**로 암호화와 복호화를 수행.
- 용도:
  - 데이터 기밀성(암호화)
  - 메시지 인증(HMAC)

NIST는 일반적인 보안 요구 수준에서는 **AES-128** 이상, 고보안 환경에서는 **AES-256** 사용을 권고한다.:contentReference[oaicite:12]{index=12}

#### 5.3.2 비대칭키(Asymmetric Key)

- RSA, ECDH, ECDSA, EdDSA 등에서 사용.
- **개인키(Secret)** + **공개키(Public)** 쌍.
- 용도:
  - 키 교환(DH/ECDH)
  - 디지털 서명(RSA/ECDSA/EdDSA)

#### 5.3.3 세션 키(Session Key) vs 장기 키(Long-term Key)

- **세션 키**
  - 특정 연결/세션에만 사용 (예: TLS 연결 하나).
  - 짧은 시간만 유지 후 폐기(Perfect Forward Secrecy를 위해 중요).
- **장기 키**
  - 서버 인증서 키, 루트 CA 키 등.
  - 오랜 기간 유지되지만 여전히 유효기간 관리 필요.

TLS 1.3은 기본적으로 **에페메럴(Ephemeral) ECDH 키 교환**으로 세션 키를 생성해, 세션이 끝나면 해당 키를 버린다.:contentReference[oaicite:13]{index=13}

---

### 5.4 키 교환과 KDF(Key Derivation Function)

네트워크에서 대칭 세션 키를 직접 교환하지 않고, 보통 다음 구조를 따른다.

1. **Diffie–Hellman(DH/ECDH)** 으로 양측이 공유하는 **비밀 값 g^{ab}** 을 계산.
2. 이 값을 바로 쓰지 않고 **KDF** 를 적용:
   - HKDF(HMAC-based KDF) 등:contentReference[oaicite:14]{index=14}
3. KDF를 통해 여러 용도의 키로 분리:
   - $$K_{\text{enc}}$$: 암호화용
   - $$K_{\text{mac}}$$: 무결성용
   - $$K_{\text{iv}}$$: 초기화 벡터용 등

수식 예 (단순화):

$$
\text{PRK} = \mathrm{HMAC}_{\text{salt}}(\text{IKM})
$$

$$
\text{OKM} = \mathrm{HMAC}_{\text{PRK}}(\text{info} \parallel 1)
$$

여기서 IKM는 입력 키 재료(예: DH 공유비밀), OKM는 최종 파생 키.

---

### 5.5 키 저장 및 보호

키를 어디에 저장할 것인가도 중요하다.

- **소프트웨어 저장**
  - 애플리케이션 설정 파일, 데이터베이스 등.
  - OS 제공 암호화 저장소(Windows DPAPI, macOS Keychain, Linux KMS 등)와 함께 사용할 것.
- **하드웨어 저장**
  - HSM(Hardware Security Module)
  - TPM(Trusted Platform Module)
  - 스마트카드, 보안 토큰
- **클라우드 키 관리 서비스(KMS)**
  - AWS KMS, GCP KMS, Azure Key Vault 등.
  - 키는 클라우드 HSM 내부에 존재하고, API를 통해서만 암·복호화/서명 수행.

실무에서 흔한 패턴:

- 애플리케이션은 **데이터 암호화용 데이터 키(Data Key)** 를 사용.
- 이 데이터 키는 다시 **마스터 키** 로 암호화해 저장(**키 래핑, key wrapping**).
- 마스터 키는 KMS/HSM에 존재.

---

### 5.6 예제 — TLS에서의 키 관리 흐름

TLS 1.3을 예로 들면:

1. 클라이언트와 서버는 각자 **에페메럴 ECDH 키 쌍**을 생성.
2. 서로의 공개키를 교환해 **공유 비밀** 을 계산.
3. HKDF로 **세션 키** (클라이언트→서버, 서버→클라이언트 방향 별도)를 파생.
4. 세션이 종료되면 세션 키를 폐기.
5. 서버의 장기 인증키(인증서 키)는 별도로 안전하게 보관(HSM 등).

이렇게 하면:

- 세션 키가 나중에 유출되더라도, 다른 세션에는 영향을 주지 않는다.
- 심지어 장기 키가 나중에 유출되어도, 과거 세션의 내용을 복호화하기 어려운 **전방 비밀성(Forward Secrecy)** 이 확보된다.

---

## 정리

이 절에서 다룬 내용은 모두 “기밀성” 위에 덧쌓는 보안의 나머지 축들이다.

- **Message Integrity**: 데이터가 중간에 바뀌지 않았는지 (HMAC, AEAD).
- **Message Authentication**: 누가 보냈는지까지 확인 (MAC or Digital Signature).
- **Digital Signature**: 공개키 기반으로 누구나 검증 가능한 서명, 부인 방지에 유리.
- **Entity Authentication**: 실제로 통신하는 “사람/서버/장비”가 누구인지 검증 (MFA, 인증서, FIDO 등).
- **Key Management**: 키의 생성–배포–사용–회전–폐기 전 과정을 안전하게 설계.

실제 네트워크 시스템(TLS, IPsec, SSH, VPN, 웹 애플리케이션, IoT 등)을 설계할 때는  
**어떤 보안 목표를 달성해야 하는지** 먼저 명확히 한 뒤,  
여기서 설명한 **무결성·인증·서명·엔티티 인증·키 관리**를 조합해 설계해야 한다.