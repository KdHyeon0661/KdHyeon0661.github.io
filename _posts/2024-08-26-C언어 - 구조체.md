---
layout: post
title: C - 구조체
date: 2024-08-26 19:20:23 +0900
category: C
---
# 구조체(struct)와 사용자 정의 자료형

## 워밍업: 핵심 예제 한 화면

```c
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>   // offsetof
#include <string.h>
#include <stdlib.h>

// 1) 구조체 + 지정 초기화자 + 패딩 관찰
typedef struct {
    char  name[20];
    int   age;        // 정렬 때문에 패딩이 섞일 수 있음
    float height;
} Person;

// 2) 안전 비교(패딩 무시), 얕은/깊은 복사
int person_equal(const Person *a, const Person *b) {
    return a && b &&
           strcmp(a->name, b->name) == 0 &&
           a->age == b->age && a->height == b->height;
}

// 3) 태그드 유니언: enum + union
typedef enum { T_INT, T_FLOAT, T_STR } ValueTag;

typedef struct {
    ValueTag tag;
    union {
        int   i;
        float f;
        struct { char *p; size_t n; } s; // 동적 문자열
    } as;
} Value;

void value_free(Value *v){
    if (!v) return;
    if (v->tag == T_STR) { free(v->as.s.p); v->as.s.p=NULL; v->as.s.n=0; }
}

int main(void){
    Person p = { .name="Alice", .age=25, .height=165.3f };
    printf("sizeof(Person)=%zu, age@%zu, height@%zu\n",
           sizeof(Person),
           offsetof(Person, age),
           offsetof(Person, height));

    Value v1 = { .tag=T_INT,   .as.i=42 };
    Value v2 = { .tag=T_STR,   .as.s.p=strdup("hello"), .as.s.n=5 };
    Value v3 = { .tag=T_FLOAT, .as.f=3.14f };

    printf("%s\n", person_equal(&p,&p) ? "same" : "diff");
    value_free(&v1);
    value_free(&v2);
    value_free(&v3);
    return 0;
}
```

---

## 구조체(struct) — 정의, 선언, 초기화

```c
struct Person {
    char  name[20];
    int   age;
    float height;
};

struct Person p1;                 // 선언
strcpy(p1.name, "Alice");
p1.age = 25;
p1.height = 165.3f;

// 지정 초기화자(C99)
struct Person p2 = { .name = "Bob", .height = 172.5f, .age = 30 };

// 위치 기반 초기화
struct Person p3 = { "Eve", 28, 170.0f };
```

### `typedef`로 간편 별칭

```c
typedef struct Person Person;     // 기존 태그 재활용
typedef struct {                  // 익명 구조체에 별칭
    char name[20];
    int  age;
} Student;

Student s1 = { "John", 21 };
```

### 중첩 구조체/합성

```c
typedef struct {
    int y, m, d;
} Date;

typedef struct {
    char name[20];
    Date birth;          // 합성
} User;

User u = { "Kim", {1997, 5, 12} };
```

---

## 메모리 레이아웃 — 패딩과 정렬, `sizeof/offsetof`

- 각 멤버는 **자신의 정렬 요건**(예: `int`는 4바이트 정렬)을 만족하도록 **패딩**이 삽입될 수 있습니다.
- 구조체 전체 크기는 **가장 큰 멤버의 정렬 배수**가 되도록 패딩 끝이 추가될 수 있습니다.

```c
#include <stdio.h>
#include <stddef.h>

typedef struct {
    char  c;     // 1
    int   x;     // 4 정렬 → c 뒤에 3바이트 패딩 가능
    short s;     // 2 정렬 → 끝 패딩 가능
} Layout;

int main(void){
    printf("sizeof(Layout)=%zu\n", sizeof(Layout));
    printf("offsetof(c)=%zu, offsetof(x)=%zu, offsetof(s)=%zu\n",
           offsetof(Layout,c), offsetof(Layout,x), offsetof(Layout,s));
}
```

> **멤버 순서**는 크기에 큰 영향을 줍니다(패딩 최소화 목적).
> 이식성을 위해 **직접적인 바이너리 직렬화(파일로 통짜 write)** 는 지양하세요.

---

## 구조체 배열과 SoA/ AoS

- **AoS**(Array of Structs): `Person arr[N];`
  - 직관적, 개별 객체 단위 접근에 유리.
- **SoA**(Struct of Arrays): `struct { int age[N]; float h[N]; ... }`
  - **열 기반 처리/벡터화/캐시 효율**에 유리(대규모 데이터 처리).

> 상황에 따라 자료 배치를 설계하세요.

---

## 구조체의 대입/복사/비교 — 얕은 vs 깊은

- **대입/리턴/값 전달**은 **바이트 단위 얕은 복사**가 수행됩니다.
- 포인터 멤버가 있다면, 포인터 값만 복사(가리키는 대상은 공유).
- 구조체 비교에 **`memcmp` 사용 금지**: 패딩/미정값 때문에 잘못된 결과!

```c
typedef struct {
    char *name;     // 동적
    int   age;
} P;

int P_equal(const P *a, const P *b){
    if(!a||!b) return 0;
    if(a->age != b->age) return 0;
    if( (a->name==NULL) != (b->name==NULL) ) return 0;
    return a->name ? strcmp(a->name,b->name)==0 : 1;
}

// 깊은 복사/해제
int P_clone(P *dst, const P *src){
    if(!dst||!src) return -1;
    dst->age = src->age;
    if(src->name){
        dst->name = strdup(src->name);
        if(!dst->name) return -1;
    } else dst->name=NULL;
    return 0;
}
void P_free(P *p){
    if(!p) return;
    free(p->name); p->name=NULL;
}
```

---

## 함수 인자로 구조체 — 값/포인터, `const` 계약

```c
void printPerson(struct Person p);          // 값 전달(복사)
void printPersonC(const struct Person *p);  // 읽기 전용 포인터(권장)
void modifyAge(struct Person *p);           // 수정 허용
```

- 큰 구조체는 **포인터**가 유리.
- **인터페이스 계약**: 읽기 전용이면 `const` 포인터로 명시.

---

## 비트필드(Bit-Field) — 공간 절약 vs 이식성

```c
typedef struct {
    unsigned mode : 3;   // 0..7
    unsigned flag : 1;   // 0/1
    unsigned code : 12;  // 0..4095
} Header;
```

- 장점: 플래그/작은 정수로 **공간 절약**.
- 주의:
  - **비트 순서/패킹/정렬/서명**은 구현 의존 → **바이너리 프로토콜에 부적합**.
  - 정밀 제어가 필요하면 **마스크/시프트**로 직접 구현 권장.

```c
#define MODE_MASK 0x7u
#define MODE(val)  ((val) & MODE_MASK)

```

---

## 가변 배열 멤버(Flexible Array Member, C99)

동적 길이의 마지막 멤버를 **크기 미지정 배열**로 선언:

```c
typedef struct {
    size_t n;
    int    data[];   // FAM: 반드시 마지막 멤버
} IVec;

IVec *ivec_new(size_t n){
    IVec *v = malloc(sizeof *v + n * sizeof v->data[0]);
    if(!v) return NULL;
    v->n = n;
    return v;
}
```

- 장점: **헤더 + 데이터 연속 배치** → 캐시 효율/할당 1회.
- 제약: 중간에 다른 멤버를 둘 수 없음. **마지막에만** 사용.

---

## `typedef` 스타일 가이드

- **공개 API**: `typedef struct Foo Foo;` + `struct Foo { ... }`를 `.c`로 감추고, `.h`에는 `typedef struct Foo Foo;` 만 노출 → **opaque 타입**(캡슐화).
- 지역 내부 유틸: `typedef` 생략 가능.
- 접두사로 네임스페이스: `db_conn`, `img_rect` 등.

---

## 공용체(union) — 메모리 공유와 태그드 유니언

### 기본

```c
union Data {
    int   i;
    float f;
    char  str[20];
};

union Data d;
d.i = 10;
d.f = 3.14f;         // 같은 공간이 겹치므로 d.i는 의미 상실
```

- **모든 멤버가 같은 주소**를 공유 → 한 시점에 **하나만 유효**.

### 안전한 패턴: **태그드 유니언(tagged union)**

```c
typedef enum { V_INT, V_FLOAT, V_STR } VTag;

typedef struct {
    VTag tag;
    union {
        int   i;
        float f;
        struct { char *p; size_t n; } s;
    } as;
} Var;

void var_free(Var *v){
    if(!v) return;
    if(v->tag==V_STR){ free(v->as.s.p); v->as.s.p=NULL; v->as.s.n=0; }
}
```

- **tag 값**으로 현재 유효 멤버를 기록 → 안전한 스위치.

```c
void var_print(const Var *v){
    switch(v->tag){
        case V_INT:  printf("%d\n", v->as.i); break;
        case V_FLOAT:printf("%f\n", v->as.f); break;
        case V_STR:  printf("%.*s\n", (int)v->as.s.n, v->as.s.p); break;
    }
}
```

> C 표준의 “**공통 초기 시퀀스**” 규정 등 특수 케이스가 있으나, 일반적으론 **태그드 유니언**으로 관리하는 것이 안전합니다.

---

## 열거형(enum) — 가독성, 범위 검증, 플래그

```c
enum Weekday { MON, TUE, WED, THU, FRI }; // 0부터 순차 증가
enum Status  { OK=200, ERROR=500 };       // 임의 값 지정 가능
```

- **스위치**에서 누락 방지: `default` 활용 / 컴파일러 경고 플래그.
- **플래그(비트필드) enum**: 조합 가능한 옵션에 적합.

```c
typedef enum {
    F_NONE   = 0,
    F_READ   = 1u<<0,
    F_WRITE  = 1u<<1,
    F_APPEND = 1u<<2
} OpenFlags;

OpenFlags f = F_READ | F_APPEND;
if (f & F_READ)  { /* ... */ }
if (f & F_WRITE) { /* ... */ } // false
```

> 플래그는 **중복 값 없음, 2의 거듭제곱**을 권장.

---

## 직렬화/파일 저장의 함정 — 패딩·엔디안·정렬

**그대로 쓰기 금지**:
```c
// 금지(비이식성): fwrite(&p, sizeof p, 1, fp);
```

문제:
- **패딩**: 구현/정렬에 따라 끼어든 바이트.
- **엔디안**: 플랫폼마다 바이트 순서 다름.
- **정렬/크기**: `int`/`long` 크기가 다를 수 있음.

### 안전한 방법(텍스트 또는 명시적 바이너리)

- 텍스트:
  ```c
  fprintf(fp, "%s %d %.2f\n", p.name, p.age, p.height);
  ```
- 바이너리: **필드 단위로** 고정 폭/순서로 encode.
  ```c
  #include <arpa/inet.h> // htonl 등 (POSIX)
  uint32_t age_be = htonl((uint32_t)p.age);
  fwrite(p.name, 1, 20, fp);
  fwrite(&age_be, 4, 1, fp);
  // float은 IEEE754 가정이 필요 → 정수로 memcpy 후 엔디안 처리
  ```

---

## 예제 모음

### 구조체 포인터 접근 — `.` vs `->`

```c
struct Person p = {"Eve", 28, 170.0f};
struct Person *ptr = &p;

printf("%s\n", ptr->name);   // -> 사용
printf("%d\n",  (*ptr).age); // 동일 의미
```

### 구조체 배열

```c
struct Person people[3] = {
    {"A",20,160.0f},{"B",22,175.2f},{"C",19,168.7f}
};
for (int i=0;i<3;i++) printf("%s %d\n", people[i].name, people[i].age);
```

### 함수로 전달 — 값 복사 vs 포인터

```c
void printPerson(struct Person p) { printf("%s(%d)\n", p.name, p.age); }
void modifyAge(struct Person *p)  { p->age += 1; }
```

### 비트필드 + 플래그 enum 매핑

```c
typedef enum { P_X=1<<0, P_Y=1<<1, P_Z=1<<2 } AxisFlags;

typedef struct {
    unsigned x:1, y:1, z:1;
} AxisBits;

AxisFlags to_flags(AxisBits b){
    AxisFlags f = 0;
    if(b.x) f |= P_X;
    if(b.y) f |= P_Y;
    if(b.z) f |= P_Z;
    return f;
}
```

### FAM으로 문자열 버퍼 만들기

```c
typedef struct {
    size_t n;
    char   s[];
} SBuf;

SBuf *sbuf_new(const char *src){
    size_t n = strlen(src);
    SBuf *b = malloc(sizeof *b + n + 1);
    if(!b) return NULL;
    b->n = n;
    memcpy(b->s, src, n+1);
    return b;
}
```

---

## Opaque 타입(정보 은닉)

**matrix.h**
```c
#ifndef MATRIX_H
#define MATRIX_H
#include <stddef.h>

typedef struct matrix matrix;      // 내부 레이아웃 감춤
matrix *matrix_new(size_t r, size_t c);
void     matrix_free(matrix *);
int      matrix_set(matrix *, size_t r, size_t c, double v);
int      matrix_get(const matrix *, size_t r, size_t c, double *out);
#endif

```

**matrix.c**
```c
#include "matrix.h"
#include <stdlib.h>

struct matrix { size_t r,c; double *a; }; // 여기서만 공개
/* ... 구현 생략 ... */
```

장점:
- 헤더 변경 없이 내부 교체 가능(ABI 안정성).
- 잘못된 직접 접근 방지.

---

## 지정 초기화자/복합 리터럴(Compound Literal)

```c
typedef struct { int x,y; } Pt;

Pt p1 = { .x=10, .y=20 };          // 지정 초기화자
Pt p2 = (Pt){ .y=7, .x=3 };        // 복합 리터럴(표현식에서도 사용)
```

---

## 정렬 지정/패킹 — 이식성 주의

- 컴파일러 확장(`__attribute__((packed))`, `#pragma pack`)은 **이식성 저하**.
- 하드웨어/네트워크 프로토콜 등 **정렬이 정해진 환경**에서만 제한적으로.

---

## 계산 정리(패딩 상한 감각)

구조체의 이론적 최소 크기 하한은
$$
\mathrm{min\_size} \ge \sum_i \mathrm{sizeof}(f_i)
$$
실제 크기는 정렬 제약으로
$$
\mathrm{sizeof}(S) \equiv 0 \pmod{A}
$$
가장 큰 멤버 정렬 $$A$$ 의 배수가 되도록 **패딩**이 추가됩니다.

---

## 체크리스트

- [ ] **패딩/정렬** 이해: 멤버 순서로 크기 최적화.
- [ ] **얕은/깊은 복사** 구분: 포인터 멤버에 대한 소유권/복제 정책 명시.
- [ ] **비교**: `memcmp` 금지(패딩). **필드 기반 비교** 구현.
- [ ] **직렬화**: 통짜 쓰기 금지. **필드별/엔디안/버전 관리**.
- [ ] **비트필드**: 이식성 주의, 프로토콜엔 비추천.
- [ ] **FAM**: 헤더+데이터 연속 배치로 성능 ↑, 마지막 멤버 규칙.
- [ ] **태그드 유니언**: 반드시 enum 태그로 유효 멤버 관리.
- [ ] **opaque 타입**: 캡슐화로 ABI/안전성 확보.
- [ ] **API 계약**: `const`/in/out/owning 문서화.

---

## 요약

| 주제 | 한 줄 핵심 |
|---|---|
| struct | 서로 다른 타입을 하나의 논리 단위로 묶음 |
| 패딩/정렬 | `sizeof/offsetof`로 확인, 멤버 순서가 크기와 성능에 영향 |
| 복사/비교 | 대입=얕은 복사, 비교는 필드 기준으로 구현 |
| typedef | 가독성·캡슐화, 공개 API는 opaque 패턴 권장 |
| union | 메모리 공유. **태그드 유니언**으로 안전하게 |
| enum | 의미 있는 상수, 플래그는 비트 마스크(2^k) |
| FAM | 가변 길이 데이터를 구조체 끝에 연속 배치 |
| 직렬화 | 패딩/엔디안 때문에 필드 단위로 encode/decode |
