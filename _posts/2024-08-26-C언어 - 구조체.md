---
layout: post
title: C - 구조체
date: 2024-08-26 19:20:23 +0900
category: C
---
# 구조체(struct)와 사용자 정의 자료형

## 핵심 예제 한 화면

```c
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>   // offsetof
#include <string.h>
#include <stdlib.h>

// 1) 기본 구조체 정의
typedef struct {
    char  name[20];
    int   age;        // 패딩이 발생할 수 있음
    float height;
} Person;

// 2) 안전한 비교 함수 (패딩 무시)
int person_equal(const Person *a, const Person *b) {
    return a && b &&
           strcmp(a->name, b->name) == 0 &&
           a->age == b->age && a->height == b->height;
}

// 3) 태그드 유니언 (안전한 공용체 사용)
typedef enum { T_INT, T_FLOAT, T_STR } ValueTag;

typedef struct {
    ValueTag tag;
    union {
        int   i;
        float f;
        struct { char *p; size_t n; } s; // 동적 문자열
    } as;
} Value;

void value_free(Value *v){
    if (!v) return;
    if (v->tag == T_STR) { 
        free(v->as.s.p); 
        v->as.s.p = NULL; 
        v->as.s.n = 0; 
    }
}

int main(void){
    Person p = { .name = "Alice", .age = 25, .height = 165.3f };
    printf("sizeof(Person)=%zu, age@%zu, height@%zu\n",
           sizeof(Person),
           offsetof(Person, age),
           offsetof(Person, height));

    Value v1 = { .tag = T_INT,   .as.i = 42 };
    Value v2 = { .tag = T_STR,   .as.s.p = strdup("hello"), .as.s.n = 5 };
    Value v3 = { .tag = T_FLOAT, .as.f = 3.14f };

    printf("%s\n", person_equal(&p, &p) ? "same" : "diff");
    value_free(&v1);
    value_free(&v2);
    value_free(&v3);
    return 0;
}
```

---

## 구조체: 정의부터 사용까지

구조체는 서로 다른 타입의 데이터를 하나의 논리적 단위로 묶을 수 있는 C 언어의 강력한 기능입니다. 여러 관련 데이터를 함께 관리할 때 코드의 가독성과 유지보수성을 크게 향상시킵니다.

```c
// 구조체 정의
struct Person {
    char  name[20];
    int   age;
    float height;
};

// 구조체 변수 선언 및 사용
struct Person p1;
strcpy(p1.name, "Alice");
p1.age = 25;
p1.height = 165.3f;
```

C99부터 도입된 **지정 초기화자**를 사용하면 더 명확하게 초기화할 수 있습니다. 멤버의 순서를 지키지 않아도 되며, 특정 멤버만 초기화할 수 있습니다.

```c
struct Person p2 = { .name = "Bob", .height = 172.5f, .age = 30 };

// 위치 기반 초기화 (C89 스타일)
struct Person p3 = { "Eve", 28, 170.0f };
```

### `typedef`로 간편한 별칭 만들기

`typedef`를 사용하면 `struct` 키워드를 반복해서 쓰지 않아도 됩니다. 코드를 더 간결하게 만들어줍니다.

```c
typedef struct Person Person;     // 기존 구조체에 별칭 부여
typedef struct {                  // 익명 구조체에 바로 별칭 부여
    char name[20];
    int  age;
} Student;

Student s1 = { "John", 21 };
```

### 구조체 안의 구조체: 중첩과 합성

구조체는 다른 구조체를 멤버로 포함할 수 있습니다. 이를 통해 더 복잡한 데이터 모델을 구성할 수 있습니다.

```c
typedef struct {
    int year, month, day;
} Date;

typedef struct {
    char name[20];
    Date birth_date;          // 다른 구조체를 멤버로 포함
} User;

User u = { "Kim", {1997, 5, 12} };
printf("%s는 %d년 %d월 %d일생입니다.\n", 
       u.name, u.birth_date.year, u.birth_date.month, u.birth_date.day);
```

---

## 구조체의 메모리 레이아웃: 패딩과 정렬

구조체의 메모리 배치는 직관적이지 않을 수 있습니다. 컴파일러는 성능 최적화를 위해 **정렬(alignment)** 요구사항을 만족시키기 위해 **패딩(padding)** 바이트를 삽입합니다.

각 데이터 타입은 특정 바이트 경계에서 시작해야 하는 정렬 요구사항이 있습니다. 예를 들어, 많은 시스템에서 `int`는 4바이트 경계에서 시작해야 합니다. 컴파일러는 이 요구사항을 만족시키기 위해 필요한 곳에 패딩 바이트를 추가합니다.

```c
#include <stdio.h>
#include <stddef.h>  // offsetof 매크로

typedef struct {
    char  c;     // 1바이트
    int   x;     // 4바이트 (정렬 필요)
    short s;     // 2바이트
} Layout;

int main(void) {
    printf("sizeof(Layout) = %zu 바이트\n", sizeof(Layout));
    printf("c의 위치: %zu, x의 위치: %zu, s의 위치: %zu\n",
           offsetof(Layout, c), offsetof(Layout, x), offsetof(Layout, s));
    return 0;
}
```

이 코드의 출력은 시스템에 따라 다를 수 있지만, 일반적으로 다음과 같은 결과를 볼 수 있습니다:
- `c`는 0번지에서 시작
- `x`는 4번지에서 시작 (c와 x 사이에 3바이트 패딩)
- `s`는 8번지에서 시작
- 구조체 전체 크기는 12바이트 (마지막에 2바이트 패딩)

**메모리 최적화 팁**: 패딩을 최소화하려면 큰 데이터 타입을 먼저 배치하고, 작은 데이터 타입을 그룹화하여 배치하세요.

```c
// 비효율적
struct Inefficient {
    char a;
    int b;
    char c;
    int d;
};  // 많은 패딩 발생

// 효율적
struct Efficient {
    int b;
    int d;
    char a;
    char c;
};  // 패딩 최소화
```

> **중요**: 구조체를 파일에 저장하거나 네트워크로 전송할 때는 패딩 문제를 고려해야 합니다. 구조체를 통째로 읽고 쓰면 시스템 간 호환성이 보장되지 않습니다.

---

## 구조체 배열과 데이터 레이아웃 전략

구조체를 배열로 사용할 때는 두 가지 주요 레이아웃 전략을 고려할 수 있습니다.

### 1. AoS (Array of Structs) - 구조체의 배열
```c
Person people[100];  // 각 요소가 완전한 Person 구조체
```
**장점**: 직관적이며, 개별 객체 단위로 접근하기 쉽습니다.
**단점**: 특정 필드만 처리할 때 캐시 효율이 떨어질 수 있습니다.

### 2. SoA (Struct of Arrays) - 배열의 구조체
```c
struct {
    char names[100][20];
    int ages[100];
    float heights[100];
} population;
```
**장점**: 동일한 필드가 연속적으로 배치되어 벡터화 처리와 캐시 효율에 유리합니다.
**단점**: 개별 객체 단위 접근이 번거롭습니다.

**선택 기준**:
- 개별 객체를 자주 접근하면 **AoS**
- 특정 필드만 대량 처리하면 **SoA**
- SIMD 연산이나 고성능 계산에는 **SoA**가 일반적으로 더 효율적

---

## 구조체의 복사, 비교, 전달

### 대입과 복사: 얕은 복사의 함정
구조체 변수를 다른 구조체 변수에 대입하면 **얕은 복사(shallow copy)** 가 일어납니다. 모든 멤버가 바이트 단위로 복사되지만, 포인터 멤버의 경우 포인터 값만 복사되고 가리키는 데이터는 공유됩니다.

```c
typedef struct {
    char *name;     // 동적 할당 문자열
    int   age;
} Person;

Person p1 = { strdup("Alice"), 25 };
Person p2 = p1;     // 얕은 복사 - p1.name과 p2.name은 같은 메모리를 가리킴

// 문제: p1.name을 free하면 p2.name은 dangling pointer가 됨
free(p1.name);
// p2.name은 이제 유효하지 않은 메모리를 가리킴 (위험!)
```

### 깊은 복사 구현
포인터 멤버가 있는 구조체를 올바르게 복사하려면 깊은 복사(deep copy)를 구현해야 합니다.

```c
int person_clone(Person *dest, const Person *src) {
    if (!dest || !src) return -1;
    
    dest->age = src->age;
    
    if (src->name) {
        dest->name = strdup(src->name);  // 새 메모리 할당
        if (!dest->name) return -1;      // 메모리 부족 체크
    } else {
        dest->name = NULL;
    }
    
    return 0;
}

void person_free(Person *p) {
    if (!p) return;
    free(p->name);  // 동적 할당된 메모리 해제
    p->name = NULL; // dangling pointer 방지
}
```

### 구조체 비교: memcmp()의 위험성
`memcmp()`로 구조체를 비교하면 패딩 바이트의 불확실한 값 때문에 잘못된 결과가 나올 수 있습니다. 항상 멤버별로 비교하는 함수를 구현하세요.

```c
// 잘못된 방법 - 사용하지 마세요!
if (memcmp(&p1, &p2, sizeof(Person)) == 0) { /* ... */ }

// 올바른 방법
int person_equal(const Person *a, const Person *b) {
    if (!a || !b) return 0;
    if (a->age != b->age) return 0;
    
    // 문자열 비교 (NULL 안전)
    if ((a->name == NULL) != (b->name == NULL)) return 0;
    if (a->name && b->name && strcmp(a->name, b->name) != 0) return 0;
    
    return 1;
}
```

### 함수 매개변수로의 전달: 값 vs 포인터
구조체를 함수에 전달할 때는 크기와 목적에 따라 전달 방식을 선택해야 합니다.

```c
// 값에 의한 전달 (복사 발생)
void print_person_by_value(Person p) {
    printf("%s, %d세\n", p.name, p.age);
}

// 포인터에 의한 전달 (효율적)
void print_person_by_pointer(const Person *p) {
    printf("%s, %d세\n", p->name, p->age);
}

// 포인터에 의한 전달 (수정 가능)
void birthday(Person *p) {
    p->age += 1;
}
```

**가이드라인**:
- 작은 구조체(보통 16바이트 이하)는 값으로 전달해도 무방
- 큰 구조체나 수정이 필요한 경우 포인터로 전달
- 읽기 전용 접근은 `const` 포인터 사용으로 의도 명시

---

## 비트 필드: 메모리 절약의 양날의 검

비트 필드는 구조체 내에서 개별 비트 단위로 멤버를 정의할 수 있게 해줍니다. 이는 플래그나 작은 범위의 값을 저장할 때 메모리를 절약할 수 있습니다.

```c
typedef struct {
    unsigned mode  : 3;   // 0..7 (3비트)
    unsigned flag  : 1;   // 0 또는 1 (1비트)
    unsigned code  : 12;  // 0..4095 (12비트)
} Header;

Header h = {2, 1, 2048};
printf("모드: %u, 플래그: %u, 코드: %u\n", h.mode, h.flag, h.code);
```

**주의사항**:
1. **이식성 문제**: 비트 필드의 배치 순서(LSB 첫째 vs MSB 첫째)는 컴파일러와 플랫폼에 따라 다릅니다.
2. **성능 오버헤드**: 비트 필드 접근에는 마스킹과 시프트 연산이 필요해 일반 정수 접근보다 느릴 수 있습니다.
3. **주소 취득 불가**: 비트 필드 멤버의 주소(`&` 연산자)를 얻을 수 없습니다.

**대안**: 비트 마스크를 사용한 명시적 구현
```c
#define MODE_MASK   0x7u    // 하위 3비트
#define FLAG_MASK   0x8u    // 4번째 비트
#define CODE_MASK   0xFFF0u // 상위 12비트 (4-15비트)

unsigned int header = 0;

// 값 설정
header = (2 & MODE_MASK) | (1 << 3) | ((2048 << 4) & CODE_MASK);

// 값 읽기
unsigned int mode = header & MODE_MASK;
unsigned int flag = (header >> 3) & 1;
unsigned int code = (header >> 4) & 0xFFF;
```

---

## 가변 배열 멤버(Flexible Array Member): 유연한 크기의 구조체

C99부터 도입된 FAM은 구조체의 마지막 멤버로 크기를 지정하지 않은 배열을 선언할 수 있게 해줍니다. 이를 통해 헤더와 데이터를 하나의 연속된 메모리 블록에 저장할 수 있습니다.

```c
typedef struct {
    size_t length;
    int    data[];   // FAM: 크기를 지정하지 않은 배열 (반드시 마지막 멤버)
} IntVector;

IntVector *intvector_create(size_t n) {
    IntVector *vec = malloc(sizeof(IntVector) + n * sizeof(int));
    if (!vec) return NULL;
    
    vec->length = n;
    // data 배열은 이미 할당된 메모리의 일부로 사용 가능
    for (size_t i = 0; i < n; i++) {
        vec->data[i] = 0;
    }
    return vec;
}

void intvector_free(IntVector *vec) {
    free(vec);  // 한 번의 free로 전체 해제
}
```

**FAM의 장점**:
1. **단일 할당/해제**: 헤더와 데이터가 연속적으로 배치되어 메모리 관리가 간단합니다.
2. **캐시 효율성**: 관련 데이터가 메모리상에 가까이 위치합니다.
3. **할당자 오버헤드 감소**: 여러 번의 `malloc` 호출을 피할 수 있습니다.

**제한사항**:
- 반드시 구조체의 **마지막 멤버**여야 합니다.
- FAM을 가진 구조체는 배열의 요소가 될 수 없습니다.
- `sizeof` 연산자는 FAM의 크기를 포함하지 않습니다.

---

## 공용체(Union): 메모리 공유의 기술

공용체는 모든 멤버가 같은 메모리 공간을 공유하는 특별한 자료형입니다. 한 번에 하나의 멤버만 유효하게 사용할 수 있습니다.

```c
union Data {
    int   i;
    float f;
    char  str[20];
};

union Data data;
data.i = 10;          // 정수로 사용
printf("%d\n", data.i);

data.f = 3.14f;       // 실수로 사용 (이제 data.i는 의미 없음)
printf("%f\n", data.f);
```

### 태그드 유니언(Tagged Union): 안전한 공용체 사용법

공용체만 사용하면 현재 어떤 멤버가 유효한지 알 수 없어 위험합니다. 태그드 유니언은 열거형과 공용체를 결합해 이 문제를 해결합니다.

```c
typedef enum { VALUE_INT, VALUE_FLOAT, VALUE_STRING } ValueType;

typedef struct {
    ValueType type;  // 현재 유효한 멤버를 표시하는 태그
    union {
        int   i;
        float f;
        char  *str;  // 동적 문자열
    } data;
} TaggedValue;

void print_value(const TaggedValue *v) {
    switch (v->type) {
        case VALUE_INT:
            printf("정수: %d\n", v->data.i);
            break;
        case VALUE_FLOAT:
            printf("실수: %f\n", v->data.f);
            break;
        case VALUE_STRING:
            printf("문자열: %s\n", v->data.str);
            break;
    }
}

void free_value(TaggedValue *v) {
    if (v->type == VALUE_STRING) {
        free(v->data.str);
        v->data.str = NULL;
    }
}
```

**태그드 유니언의 장점**:
1. **타입 안전성**: 현재 어떤 멤버가 유효한지 명확히 알 수 있습니다.
2. **유연성**: 여러 타입의 값을 하나의 변수로 처리할 수 있습니다.
3. **메모리 효율성**: 필요한 만큼의 메모리만 사용합니다.

---

## 열거형(Enum): 의미 있는 상수

열거형은 관련 있는 정수 상수들을 이름으로 정의할 수 있게 해줍니다. 코드의 가독성을 크게 향상시킵니다.

```c
// 기본 열거형
enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY };
enum Weekday today = WEDNESDAY;

// 명시적 값 지정
enum HTTPStatus { OK = 200, CREATED = 201, BAD_REQUEST = 400, NOT_FOUND = 404 };
```

### 플래그로 사용하는 열거형

열거형을 비트 플래그로 사용하면 여러 옵션을 조합할 수 있습니다.

```c
typedef enum {
    PERMISSION_NONE    = 0,
    PERMISSION_READ    = 1 << 0,  // 1 (0001)
    PERMISSION_WRITE   = 1 << 1,  // 2 (0010)
    PERMISSION_EXECUTE = 1 << 2,  // 4 (0100)
    PERMISSION_ALL     = PERMISSION_READ | PERMISSION_WRITE | PERMISSION_EXECUTE
} FilePermissions;

FilePermissions my_perms = PERMISSION_READ | PERMISSION_WRITE;

// 플래그 검사
if (my_perms & PERMISSION_READ) {
    printf("읽기 권한 있음\n");
}

// 플래그 추가
my_perms |= PERMISSION_EXECUTE;

// 플래그 제거
my_perms &= ~PERMISSION_WRITE;
```

**플래그 열거형 사용 팁**:

1. 각 값은 2의 거듭제곱으로 정의해 조합 시 충돌이 없도록 합니다.
2. `0` 값은 "아무 플래그도 없음"을 의미하게 합니다.
3. 모든 플래그의 조합을 나타내는 `ALL` 값을 제공하면 편리합니다.

---

## 구조체 직렬화: 파일 저장과 네트워크 전송

구조체를 파일에 저장하거나 네트워크로 전송할 때는 여러 가지 주의사항이 있습니다.

### **잘못된 방법 (사용하지 마세요!)**

```c
Person p = {"Alice", 25, 165.3f};
fwrite(&p, sizeof(p), 1, file);  // 위험!
```

이 방법의 문제점:
1. **패딩 바이트**: 구조체 내부의 패딩 바이트가 포함되어 시스템 간 호환성이 없습니다.
2. **엔디안(Endianness)**: CPU 아키텍처에 따라 바이트 순서가 다를 수 있습니다.
3. **타입 크기**: `int`나 `long`의 크기가 시스템에 따라 다를 수 있습니다.

### **안전한 직렬화 방법**

#### 방법 1: 텍스트 형식 (가장 이식성 좋음)

```c
// 저장
fprintf(file, "%s %d %.2f\n", p.name, p.age, p.height);

// 읽기
fscanf(file, "%19s %d %f", p.name, &p.age, &p.height);
```

#### 방법 2: 바이너리 형식 (엔디안 처리)

```c
#include <arpa/inet.h>  // htonl, ntohl (POSIX)

// 저장
uint32_t age_net = htonl((uint32_t)p.age);  // 호스트 → 네트워크 바이트 순서
fwrite(p.name, 1, sizeof(p.name), file);
fwrite(&age_net, sizeof(age_net), 1, file);

// 실수 처리 (IEEE 754 가정)
uint32_t height_bits;
memcpy(&height_bits, &p.height, sizeof(height_bits));
height_bits = htonl(height_bits);
fwrite(&height_bits, sizeof(height_bits), 1, file);

// 읽기
uint32_t age_net;
fread(&age_net, sizeof(age_net), 1, file);
p.age = (int)ntohl(age_net);  // 네트워크 → 호스트 바이트 순서
```

#### 방법 3: 명시적 직렬화 함수

```c
typedef struct {
    uint8_t name[20];
    uint32_t age;
    float height;
} __attribute__((packed)) PackedPerson;  // 패딩 제거 (컴파일러 확장)

// 저장
void person_serialize(const Person *p, FILE *file) {
    PackedPerson packed;
    strncpy((char*)packed.name, p->name, sizeof(packed.name));
    packed.age = htonl((uint32_t)p->age);
    packed.height = p->height;  // float 엔디안 처리 필요
    fwrite(&packed, sizeof(packed), 1, file);
}
```

**직렬화 가이드라인**:

1. **텍스트 형식**을 사용하면 이식성이 가장 좋습니다.
2. **바이너리 형식**이 필요하면 엔디안 변환을 반드시 수행하세요.
3. **버전 관리**: 직렬화 형식이 변경될 가능성을 고려해 버전 번호를 포함하세요.
4. **검증**: 직렬화/역직렬화 후 데이터 무결성을 검증하세요.

---

## 불투명 타입(Opaque Type): 정보 은닉과 캡슐화

불투명 타입은 C에서 객체 지향적인 캡슐화를 구현하는 방법입니다. 헤더 파일에서는 구조체의 내부를 노출하지 않고, 오직 포인터 타입만 선언합니다.

### **matrix.h** (공개 헤더)

```c
#ifndef MATRIX_H
#define MATRIX_H

// 불투명 타입 선언 - 내부 구조는 외부에서 알 수 없음
typedef struct matrix matrix;

// 공개 API
matrix* matrix_create(int rows, int cols);
void matrix_destroy(matrix* m);
double matrix_get(const matrix* m, int row, int col);
void matrix_set(matrix* m, int row, int col, double value);
void matrix_print(const matrix* m);

#endif
```

### **matrix.c** (구현 파일)

```c
#include "matrix.h"
#include <stdlib.h>
#include <stdio.h>

// 실제 구조체 정의 (외부에서 접근 불가)
struct matrix {
    int rows;
    int cols;
    double* data;
};

matrix* matrix_create(int rows, int cols) {
    matrix* m = malloc(sizeof(matrix));
    if (!m) return NULL;
    
    m->rows = rows;
    m->cols = cols;
    m->data = malloc(rows * cols * sizeof(double));
    
    if (!m->data) {
        free(m);
        return NULL;
    }
    
    return m;
}

// 나머지 구현...
```

**불투명 타입의 장점**:

1. **정보 은닉**: 내부 구현을 변경해도 헤더 파일과 사용자 코드를 수정할 필요가 없습니다.
2. **ABI 안정성**: 라이브러리 업데이트 시 바이너리 호환성을 유지하기 쉽습니다.
3. **에러 방지**: 사용자가 내부 멤버에 직접 접근해 발생하는 실수를 방지합니다.

---

## 고급 기능과 모범 사례

### 복합 리터럴(Compound Literals)

C99부터 도입된 복합 리터럴은 구조체 리터럴을 표현식으로 사용할 수 있게 해줍니다.

```c
typedef struct { int x, y; } Point;

// 함수 호출 시 직접 구조체 생성
draw_point((Point){10, 20});

// 배열 초기화
Point points[] = {
    (Point){.x=1, .y=2},  // 지정 초기화자와 함께 사용
    (Point){3, 4},
    (Point){.y=6, .x=5}   // 순서 변경 가능
};
```

### 정렬 지정 (컴파일러 확장)

특정 상황(하드웨어 접근, 네트워크 프로토콜)에서 정렬을 명시적으로 지정해야 할 때가 있습니다.

```c
// GCC/Clang
struct __attribute__((packed)) NetworkPacket {
    uint8_t type;
    uint32_t sequence;
    uint16_t checksum;
};  // 패딩 없이 압축

// MSVC
#pragma pack(push, 1)
struct NetworkPacket {
    uint8_t type;
    uint32_t sequence;
    uint16_t checksum;
};
#pragma pack(pop)
```

**주의**: 컴파일러 확장을 사용하면 이식성이 저하됩니다. 꼭 필요한 경우에만 사용하세요.

### 구조체와 동적 메모리의 통합

복잡한 데이터 구조를 구현할 때는 구조체와 동적 메모리를 함께 사용합니다.

```c
typedef struct {
    char* title;
    char* author;
    int year;
    double price;
} Book;

typedef struct {
    Book* books;          // 동적 배열
    size_t count;         // 현재 책 수
    size_t capacity;      // 할당된 용량
} Library;

Library* library_create(void) {
    Library* lib = malloc(sizeof(Library));
    if (!lib) return NULL;
    
    lib->capacity = 10;
    lib->count = 0;
    lib->books = malloc(lib->capacity * sizeof(Book));
    
    if (!lib->books) {
        free(lib);
        return NULL;
    }
    
    return lib;
}

// 나머지 구현 (책 추가, 검색, 정리 등)...
```

---

## 요약: 구조체와 사용자 정의 타입의 핵심

| 개념 | 핵심 포인트 |
|------|-------------|
| **구조체 정의** | `struct` 키워드로 관련 데이터를 하나로 묶음. `typedef`로 간결한 별칭 생성 |
| **메모리 레이아웃** | 정렬 요구사항으로 인한 패딩 발생. `sizeof`와 `offsetof`로 확인 가능 |
| **복사와 비교** | 대입은 얕은 복사. 포인터 멤버가 있으면 깊은 복사 필요. `memcmp`로 비교 금지 |
| **데이터 배치** | AoS vs SoA: 객체 단위 접근 vs 필드 단위 벡터화 처리 |
| **비트 필드** | 메모리 절약 가능 but 이식성 주의. 필요한 경우 비트 마스크로 대체 |
| **FAM** | 가변 길이 데이터를 구조체 끝에 연속 배치. 단일 할당/해제로 효율적 |
| **태그드 유니언** | 공용체의 안전한 사용법. 열거형 태그로 현재 유효 멤버 표시 |
| **열거형** | 의미 있는 상수 정의. 비트 플래그로 사용 가능 |
| **직렬화** | 패딩과 엔디안 문제로 구조체 통째 저장 금지. 필드별 직렬화 구현 |
| **불투명 타입** | `.h`에서 내부 구조 숨기고 포인터 타입만 노출. 캡슐화와 ABI 안정성 확보 |

---

## 결론

구조체는 C 언어에서 복잡한 데이터를 조직화하는 기본 도구입니다. 단순히 여러 변수를 묶는 것을 넘어, 메모리 레이아웃, 복사 의미론, 직렬화 등 다양한 측면을 이해하고 활용해야 안정적이고 효율적인 프로그램을 작성할 수 있습니다.

**메모리 효율성**: 구조체의 메모리 레이아웃은 정렬 요구사항에 따라 패딩이 삽입됩니다. `sizeof`와 `offsetof`를 활용해 실제 크기를 확인하고, 멤버 순서를 조정해 메모리 낭비를 최소화할 수 있습니다. 성능이 중요한 경우 AoS(Array of Structures)와 SoA(Structure of Arrays) 중 적절한 데이터 배치 전략을 선택해야 합니다.

**안전한 복사와 비교**: 구조체의 대입 연산은 얕은 복사를 수행하므로, 포인터 멤버가 있는 경우 깊은 복사 함수를 별도로 구현해야 합니다. 패딩 영역의 쓰레기 값 때문에 `memcmp`로 구조체를 비교하는 것은 위험하므로, 멤버별 비교 함수를 작성하는 것이 안전합니다.

**고급 패턴 활용**: FAM(Flexible Array Member)은 가변 길이 데이터를 효율적으로 관리할 수 있게 하고, 태그드 유니언은 공용체를 타입 안전하게 사용할 수 있는 방법을 제공합니다. 비트 필드는 메모리를 절약할 수 있지만 이식성 문제가 있으므로, 중요한 경우 비트 마스크를 고려해야 합니다.

**함수 인터페이스 설계**: 큰 구조체는 값으로 전달하지 말고 포인터로 전달하되, 읽기 전용인 경우 `const` 포인터를 사용해 의도를 명확히 해야 합니다. 라이브러리 설계 시에는 불투명 타입을 활용해 내부 구조를 숨기고 캡슐화와 ABI 안정성을 확보할 수 있습니다.

**직렬화 주의사항**: 구조체를 파일이나 네트워크로 전송할 때 패딩과 엔디안 문제를 반드시 고려해야 합니다. 구조체를 통째로 저장하는 대신 필드별로 직렬화하는 함수를 구현하는 것이 이식성과 호환성을 보장하는 올바른 방법입니다.

이러한 원칙들을 숙지하고 상황에 맞는 디자인 패턴을 적용하면, 코드의 가독성, 안정성, 유지보수성을 크게 향상시킬 수 있습니다.