---
layout: post
title: 영상처리 - 영상 새로 만들기 기능
date: 2025-09-18 17:25:23 +0900
category: 영상처리
---
# **영상 새로 만들기** 기능 구현

## 0) 최종 UX

- 메뉴 **File → New… (Ctrl+N)** 를 누르면 **“새 영상 만들기”** 대화 상자 표시
- 항목: **Width / Height**, **모드(Grayscale or Color)**, **그레이 값**(0–255) 또는 **RGB 색상 선택**
- [확인] 시 즉시 새 영상 생성 → **창 크기를 영상 크기에 맞게** 조정 → **영상 외부는 빗금** 유지
- [취소] 시 아무 변화 없이 닫기

---

## 1) 새 대화 상자를 만드는 순서 (개요)

1. **리소스 추가**: Dialog 리소스 템플릿과 컨트롤 ID 정의(`resource.h`, `.rc`)  
2. **디자인**: 정적 텍스트, 에디트(폭/높이/그레이), 라디오(Gray/Color), 버튼(색 선택), 미리보기 Static  
3. **대화 상자 클래스**: `NewImageDialog` (Win32 래퍼) — 값 읽기/검증/ChooseColor 처리  
4. **멤버 변수**: `NewImageArgs { int width,height; enum Mode; BYTE gray; COLORREF rgb; }`  
5. **표시/연결**: 메뉴 **ID_FILE_NEW** 핸들러에서 `NewImageDialog::Run()` 호출 → 결과로 비트맵 생성

---

## 2) 리소스 & ID 정의

### 2.1 `resource.h`

```cpp
#pragma once

// Dialogs
#define IDD_NEWIMAGE                101

// Controls (New Image)
#define IDC_EDIT_WIDTH              1001
#define IDC_EDIT_HEIGHT             1002
#define IDC_RAD_GRAY                1003
#define IDC_RAD_COLOR               1004
#define IDC_EDIT_GRAY               1005
#define IDC_BTN_PICKCOLOR           1006
#define IDC_STATIC_COLORPREV        1007

// Menu/Command
#define IDR_MAINMENU                200
#define ID_FILE_NEW                 40001
#define ID_FILE_OPEN                40002
#define ID_FILE_SAVEAS              40003
```

### 2.2 `.rc` (리소스 스크립트 — Dialog & Menu)

> Visual Studio 리소스 편집기에서 만들어도 되지만, 여기서는 텍스트로 보여줍니다.

```rc
#include "resource.h"
#include <windows.h>

IDD_NEWIMAGE DIALOGEX 0, 0, 230, 150
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "New Image"
FONT 9, "Segoe UI"
BEGIN
    LTEXT       "Width (px):",   -1,                10, 12,  60, 10
    EDITTEXT    IDC_EDIT_WIDTH,                      75, 10,  60, 14, ES_NUMBER | WS_TABSTOP
    LTEXT       "Height (px):",  -1,                10, 32,  60, 10
    EDITTEXT    IDC_EDIT_HEIGHT,                     75, 30,  60, 14, ES_NUMBER | WS_TABSTOP

    GROUPBOX    "Mode",          -1,                10, 50,  130, 55
    CONTROL     "Grayscale",     IDC_RAD_GRAY,  "Button", BS_AUTORADIOBUTTON | WS_TABSTOP, 18, 63, 65, 11
    LTEXT       "Gray (0-255):", -1,                18, 80,  65, 10
    EDITTEXT    IDC_EDIT_GRAY,                       88, 78,  40, 14, ES_NUMBER | WS_TABSTOP

    CONTROL     "Color (RGB)",   IDC_RAD_COLOR, "Button", BS_AUTORADIOBUTTON | WS_TABSTOP, 18, 96, 80, 11
    PUSHBUTTON  "Pick…",         IDC_BTN_PICKCOLOR,                      100, 95, 40, 14, WS_TABSTOP
    LTEXT       "Preview:",      -1,                                   150, 12,  60, 10
    CONTROL     "",              IDC_STATIC_COLORPREV, "Static", SS_BLACKFRAME, 150, 24, 60, 60

    DEFPUSHBUTTON "OK",          IDOK,                                  80, 120,  60, 14
    PUSHBUTTON    "Cancel",      IDCANCEL,                              145,120,  60, 14
END

// Main Menu (일부만 예시)
IDR_MAINMENU MENU
BEGIN
    POPUP "&File"
    BEGIN
        MENUITEM "&New...\tCtrl+N",  ID_FILE_NEW
        MENUITEM "&Open...\tCtrl+O", ID_FILE_OPEN
        MENUITEM "Save &As...\tCtrl+S", ID_FILE_SAVEAS
        MENUITEM SEPARATOR
        MENUITEM "E&xit",            0xF060   // SC_CLOSE
    END
END
```

> **팁**  
> - `SS_BLACKFRAME`로 미리보기 Static을 테두리 상자로 만들고, 내부는 우리가 직접 색으로 채웁니다.  
> - 라디오 버튼은 **같은 그룹 내 연속**이어야 상호배타로 동작합니다.

---

## 3) 대화 상자 클래스 & 멤버 변수

### 3.1 파라미터 구조체

```cpp
// NewImageDialog.h (또는 main_win.cpp 상단)

struct NewImageArgs {
    enum class Mode { Gray, Color } mode = Mode::Gray;
    int      width  = 640;
    int      height = 480;
    BYTE     gray   = 128;       // 0..255
    COLORREF rgb    = RGB(128,128,128); // BGR order for Win32 COLORREF
};
```

### 3.2 대화 상자 래퍼 클래스

- `DialogBoxParamW` 로 모달 표시  
- `GWLP_USERDATA`로 `this` 포인터 보관  
- 입력값 검증(범위/메모리 크기 제한)  
- **Color Pick**: `ChooseColorW` 사용  
- **미리보기**: `WM_PAINT`에서 STATIC 영역 내부를 선택한 색으로 채움

```cpp
// NewImageDialog.h

#pragma once
#include <windows.h>
#include <commdlg.h>
#include <string>
#include "resource.h"

class NewImageDialog {
public:
    explicit NewImageDialog(NewImageArgs& args) : args_(args) {}
    INT_PTR DoModal(HWND parent);

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);
    INT_PTR OnPaint(HWND h);
    void    UpdateUI(HWND h);
    bool    ReadInputs(HWND h);
    void    PickColor(HWND h);

private:
    NewImageArgs& args_;
    HWND hDlg_ = nullptr;
};
```

```cpp
// NewImageDialog.cpp

#include "NewImageDialog.h"

INT_PTR NewImageDialog::DoModal(HWND parent) {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_NEWIMAGE),
                           parent, DlgProc, (LPARAM)this);
}

INT_PTR CALLBACK NewImageDialog::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m == WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self = reinterpret_cast<NewImageDialog*>(l);
        self->hDlg_ = h;
        return self->OnInit(h);
    }
    auto* self = reinterpret_cast<NewImageDialog*>(GetWindowLongPtrW(h, GWLP_USERDATA));
    if (!self) return FALSE;

    switch (m) {
    case WM_COMMAND: return self->OnCommand(h, w, l);
    case WM_PAINT:   return self->OnPaint(h);
    default:         return FALSE;
    }
}

INT_PTR NewImageDialog::OnInit(HWND h) {
    // 기본값 채우기
    SetDlgItemInt(h, IDC_EDIT_WIDTH,  args_.width,  FALSE);
    SetDlgItemInt(h, IDC_EDIT_HEIGHT, args_.height, FALSE);
    SetDlgItemInt(h, IDC_EDIT_GRAY,   args_.gray,   FALSE);

    CheckRadioButton(h, IDC_RAD_GRAY, IDC_RAD_COLOR,
        args_.mode==NewImageArgs::Mode::Gray ? IDC_RAD_GRAY : IDC_RAD_COLOR);

    UpdateUI(h);

    // 부모 중심으로 배치
    RECT rcPar{}, rc{}; HWND p = GetParent(h);
    if (p) {
        GetWindowRect(p, &rcPar); GetWindowRect(h, &rc);
        int x = rcPar.left + ((rcPar.right-rcPar.left) - (rc.right-rc.left))/2;
        int y = rcPar.top  + ((rcPar.bottom-rcPar.top) - (rc.bottom-rc.top))/2;
        SetWindowPos(h, nullptr, x, y, 0,0, SWP_NOSIZE|SWP_NOZORDER);
    }
    return TRUE;
}

void NewImageDialog::UpdateUI(HWND h) {
    BOOL isGray = (IsDlgButtonChecked(h, IDC_RAD_GRAY) == BST_CHECKED);
    EnableWindow(GetDlgItem(h, IDC_EDIT_GRAY),      isGray);
    EnableWindow(GetDlgItem(h, IDC_BTN_PICKCOLOR),  !isGray);
    // 미리보기는 Color 모드에서만 의미 있으나, Gray도 같은 값으로 칠해 미리 보기 제공
    InvalidateRect(h, nullptr, FALSE);
}

bool NewImageDialog::ReadInputs(HWND h) {
    BOOL okW=FALSE, okH=FALSE, okG=TRUE;
    UINT w = GetDlgItemInt(h, IDC_EDIT_WIDTH,  &okW, FALSE);
    UINT hgt=GetDlgItemInt(h, IDC_EDIT_HEIGHT, &okH, FALSE);
    UINT g = GetDlgItemInt(h, IDC_EDIT_GRAY,   &okG, FALSE);

    if (!okW || !okH || w==0 || hgt==0) {
        MessageBoxW(h, L"Width/Height를 올바르게 입력하세요.", L"Invalid Input", MB_ICONWARNING);
        return false;
    }
    if (w > 20000 || hgt > 20000) {
        MessageBoxW(h, L"이미지 크기가 너무 큽니다 (최대 20000px).", L"Too Large", MB_ICONWARNING);
        return false;
    }
    // 메모리 상한(예: 512MB)
    const unsigned long long bytes = (unsigned long long)w * (unsigned long long)hgt * 4ull;
    if (bytes > 512ull*1024*1024) {
        MessageBoxW(h, L"메모리 제한(512MB)을 초과합니다.", L"Too Large", MB_ICONWARNING);
        return false;
    }

    bool isGray = (IsDlgButtonChecked(h, IDC_RAD_GRAY) == BST_CHECKED);
    if (!okG) g = 0;
    if (g > 255) g = 255;

    args_.width  = (int)w;
    args_.height = (int)hgt;
    args_.gray   = (BYTE)g;
    args_.mode   = isGray ? NewImageArgs::Mode::Gray : NewImageArgs::Mode::Color;
    return true;
}

void NewImageDialog::PickColor(HWND h) {
    CHOOSECOLORW cc{ sizeof(cc) };
    COLORREF cust[16] = {};
    cc.hwndOwner = h;
    cc.rgbResult = args_.rgb;
    cc.lpCustColors = cust;
    cc.Flags = CC_FULLOPEN | CC_RGBINIT;
    if (ChooseColorW(&cc)) {
        args_.rgb = cc.rgbResult;
        InvalidateRect(h, nullptr, FALSE);
    }
}

INT_PTR NewImageDialog::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)) {
    case IDC_RAD_GRAY:
    case IDC_RAD_COLOR:
        UpdateUI(h);
        return TRUE;
    case IDC_BTN_PICKCOLOR:
        PickColor(h);
        return TRUE;
    case IDOK:
        if (ReadInputs(h)) EndDialog(h, IDOK);
        return TRUE;
    case IDCANCEL:
        EndDialog(h, IDCANCEL);
        return TRUE;
    default:
        return FALSE;
    }
}

INT_PTR NewImageDialog::OnPaint(HWND h) {
    PAINTSTRUCT ps; HDC dc = BeginPaint(h, &ps);
    RECT rcPrev; GetWindowRect(GetDlgItem(h, IDC_STATIC_COLORPREV), &rcPrev);
    POINT pt { rcPrev.left, rcPrev.top };
    ScreenToClient(h, &pt);
    OffsetRect(&rcPrev, pt.x - rcPrev.left, pt.y - rcPrev.top);

    // Gray 모드면 gray값으로, Color 모드면 rgb로 칠함
    BOOL isGray = (IsDlgButtonChecked(h, IDC_RAD_GRAY) == BST_CHECKED);
    COLORREF c = isGray ? RGB(args_.gray, args_.gray, args_.gray) : args_.rgb;

    HBRUSH br = CreateSolidBrush(c);
    FillRect(dc, &rcPrev, br);
    DeleteObject(br);

    // 테두리
    FrameRect(dc, &rcPrev, (HBRUSH)GetStockObject(BLACK_BRUSH));
    EndPaint(h, &ps);
    return TRUE;
}
```

---

## 4) 메인에 연결: **File → New… (Ctrl+N)**

- 메뉴/가속기(선택)는 기존 `.rc`에 포함  
- `main_win.cpp` 의 `WndProc` → `WM_COMMAND` 에서 `ID_FILE_NEW` 처리

```cpp
// main_win.cpp (일부)
// g_dib : IppDib (이전 장과 동일), PADDING/ResizeWindowToClient도 동일 가정
#include "NewImageDialog.h"

// 새 영상 생성 유틸
static void CreateNewImageAndShow(HWND hWnd) {
    NewImageArgs args; // 기본 640x480, Gray=128
    NewImageDialog dlg(args);
    if (dlg.DoModal(hWnd) != IDOK) return;

    // 내부 DIBSECTION(BGRA32 Top-Down) 생성
    if (!g_dib.create(GetDC(hWnd), args.width, args.height, true)) {
        MessageBoxW(hWnd, L"DIBSECTION 생성 실패", L"Error", MB_ICONERROR);
        return;
    }

    // 채우기: Gray or Color
    for (int y=0; y<g_dib.height(); ++y) {
        auto* row = (uint8_t*)g_dib.bits() + (size_t)y * g_dib.stride();
        if (args.mode == NewImageArgs::Mode::Gray) {
            for (int x=0; x<g_dib.width(); ++x) {
                uint8_t* p=&row[x*4];
                p[0]=args.gray; p[1]=args.gray; p[2]=args.gray; p[3]=255;
            }
        } else {
            BYTE r = GetRValue(args.rgb), g = GetGValue(args.rgb), b = GetBValue(args.rgb);
            for (int x=0; x<g_dib.width(); ++x) {
                uint8_t* p=&row[x*4];
                p[0]=b; p[1]=g; p[2]=r; p[3]=255;
            }
        }
    }

    // 파일 경로 초기화(새 문서)
    g_openPath.clear();

    // 창 크기를 영상 크기에 맞춤 (여백 포함)
    const int clientW = g_dib.width()  + PADDING*2;
    const int clientH = g_dib.height() + PADDING*2;
    ResizeWindowToClient(hWnd, clientW, clientH);

    InvalidateRect(hWnd, nullptr, FALSE);
}

// WndProc 에서 추가
case WM_COMMAND:
    switch (LOWORD(wParam)) {
    case ID_FILE_NEW:
        CreateNewImageAndShow(h);
        return 0;
    // ... 기존 Open/Save 등 ...
    }
    break;
```

---

## 5) “대화 상자 컨트롤 → 멤버 변수” 핵심

- **Width/Height/Gray**: `GetDlgItemInt` / `SetDlgItemInt`  
- **Mode(Gray/Color)**: `IsDlgButtonChecked` + `CheckRadioButton`  
- **Color**: `CHOOSECOLORW` → `args.rgb` 저장  
- **Preview**: 대화 상자 `WM_PAINT`에서 **해당 Static의 클라이언트 좌표**를 계산해 칠함

> MFC라면 `DDX_Control/DDX_Text` 로 멤버 변수 바인딩을 걸고, `CColorDialog` 를 사용하면 됩니다. (본 글은 Win32 방식을 보여줍니다.)

---

## 6) 입력 검증(Validation) 포인트

- 폭/높이: >0, 너무 크지 않게(예시: **20000px** 제한)  
- 메모리 추정: `width * height * 4` (BGRA32) → **512MB 상한** 같은 안전한 가드  
- Gray: 0–255 클램프  
- Color: `COLORREF` 는 내부가 **0x00BBGGRR** 이므로 쓸 때는 `GetRValue/GetGValue/GetBValue` 사용

---

## 7) 실행 흐름(정리)

1. **사용자**: File → New… (Ctrl+N)  
2. **앱**: `NewImageDialog::DoModal` → Width/Height/Mode/Gray/Color 입력  
3. **OK**: 값 검증 통과 → `g_dib.create(w,h)` → 선택한 값으로 채우기  
4. **UI**: 창 클라이언트 = **영상 + 2×패딩** 으로 리사이즈 → `InvalidateRect`  
5. **그리기**: `OnPaint` → **영상 바깥 영역 빗금** → (패딩,패딩) 위치에 1:1 출력

---

## 8) 트러블슈팅

- **미리보기 박스가 칠해지지 않음**  
  → `GetWindowRect(Static)` 후 **`ScreenToClient`** 로 변환했는지 확인  
- **라디오 전환 시 컨트롤 비활성화가 안 됨**  
  → `UpdateUI()`에서 `EnableWindow` 호출, `CheckRadioButton` 그룹 범위 확인  
- **크기 입력이 허용 범위를 넘어가 앱이 뻗음**  
  → **메모리 상한**과 **곱셈 오버플로**(64-bit 계산) 확인  
- **색이 뒤바뀜**  
  → `COLORREF` 는 BGR(Win32) → 픽셀 저장 시 **B,G,R** 순으로 써야 함

---

## 9) (선택) 가속기(Accelerator) 추가

`.rc`에 가속기 테이블을 추가하면 Ctrl+N, Ctrl+O, Ctrl+S 가 메뉴 없이도 동작합니다. (메뉴에는 이미 텍스트로 표시)

```rc
IDR_ACCEL ACCELERATORS
BEGIN
    "N",  ID_FILE_NEW,   VIRTKEY, CONTROL
    "O",  ID_FILE_OPEN,  VIRTKEY, CONTROL
    "S",  ID_FILE_SAVEAS,VIRTKEY, CONTROL
END
```

메시지 루프에서 `TranslateAccelerator` 호출(없어도 메뉴 단축키는 작동).

---

## 10) 마무리

- **새 대화 상자**를 통해 **영상 크기/모드/배경**을 유연하게 지정  
- **검증/미리보기**로 안전하고 즉각적인 피드백  
- 생성 후 **창 크기 자동 맞춤** & **바깥 영역 빗금** 일관 유지  
- 기반이 되는 `IppDib` 의 Top-Down BGRA32 설계 덕분에 구현이 간결