---
layout: post
title: C++ - STL (3)
date: 2024-09-14 19:20:23 +0900
category: Cpp
---
# STL 3 — 연관 컨테이너: `map`, `set`, `unordered_map`

## 큰 그림

- **정렬 연관 컨테이너**: `map`, `set`, `multimap`, `multiset`
  - 내부: **균형 이진 검색 트리**(대부분 **Red–Black Tree**)
  - 키 **정렬 유지**, 순회는 **정렬 순서**
  - 평균/최악 **탐색/삽입/삭제**: $$O(\log n)$$
- **비정렬(해시) 연관 컨테이너**: `unordered_map`, `unordered_set`, …
  - 내부: **해시 테이블**(버킷 + 체이닝/오픈어드레싱; 표준은 체이닝 기반이 흔함)
  - 평균 **탐색/삽입/삭제**: $$O(1)$$, 최악 $$O(n)$$
  - **순서 없음**, **부하율(load factor)**과 **rehash**가 성능 좌우

---

## `map` — 정렬된 Key→Value (기본 비교자: `std::less<Key>`)

### 핵심 성질

- 키 **정렬 유지**: 이터레이션 시 항상 오름차순(커스텀 비교 가능).
- **중복 키 불가**(`insert` 실패 시 반환으로 알림). 중복이 필요하면 `multimap`.
- **반복자 안정성**: 삽입/삭제 시에도 **다른 원소의 반복자/포인터/참조는 유효** (지워진 원소만 무효).
- **노드 기반**이므로 원소 주소가 안정적 → 레퍼런스를 오래 들고 쓰기 용이.

### 기본 사용 & API

```cpp
#include <map>
#include <string>
#include <iostream>

using namespace std;

int main() {
    map<string, int> scores;  // 기본 비교자 std::less<string> (사전순)

    // 1) 연산자 [] : 존재하지 않으면 "디폴트 생성" 후 참조 반환 (주의!)
    scores["Tom"]  = 90;   // {Tom:90}
    scores["Jane"] = 85;   // {Jane:85, Tom:90}

    // 2) at : 존재하지 않으면 예외
    try {
        cout << scores.at("Tom") << "\n"; // 90
        // cout << scores.at("Mike");     // out_of_range
    } catch(const out_of_range&) {}

    // 3) 안전 삽입(insert/try_emplace/insert_or_assign)
    auto [it, inserted] = scores.insert({"Jane", 88});  // Jane 이미 있음 → inserted=false
    scores.insert_or_assign("Jane", 88);                 // 있으면 갱신, 없으면 삽입
    scores.try_emplace("Alice", 77); // 값 생성/이동 비용을 지연 (키만 보고 결정)

    // 4) 조회(find / count / contains)
    if (auto it = scores.find("Tom"); it != scores.end()) {
        cout << it->first << ":" << it->second << "\n"; // Tom:90
    }
#if __cpp_lib_map_try_emplace && __cpp_lib_erase_if
#endif
#if __cpp_lib_generic_associative_lookup // C++14 heterogeneous lookup
#endif

    // 5) 범위 검색(lower_bound/upper_bound/equal_range)
    auto lb = scores.lower_bound("J");  // "J" 이상 첫 원소
    auto ub = scores.upper_bound("K");  // "K" 초과 첫 원소
    for (auto it = lb; it != ub; ++it) {
        cout << it->first << " ";       // [J..K) 구간 출력
    }
}
```

### `operator[]` vs `at()` vs 삽입 계열

| API | 존재하지 않는 키 접근 시 | 용도 |
|---|---|---|
| `operator[]` | **디폴트 생성 후 참조 반환**(맵에 **추가됨**) | 빈 값 허용 시 읽기/쓰기 |
| `at()` | **예외**(`out_of_range`) | 읽기 시 안전한 접근 |
| `insert` | 이미 있으면 **삽입 실패** | 중복 방지 |
| `insert_or_assign` | 있으면 **덮어씀** | 편리한 upsert |
| `try_emplace` | 생성/이동 비용 **지연**, 키만 평가 | 성능 민감한 upsert |

> 읽기 코드에서 실수로 `operator[]`를 쓰면 **뜻밖의 키 추가**가 발생할 수 있음. **읽기 전용은 `find`/`at`/`contains`** 추천.

### 정렬 기준 커스터마이징

```cpp
struct CaseInsensitive {
    bool operator()(const std::string& a, const std::string& b) const {
        auto tolow = [](unsigned char c){ return std::tolower(c); };
        size_t n = min(a.size(), b.size());
        for (size_t i=0; i<n; ++i) {
            int da = tolow(a[i]), db = tolow(b[i]);
            if (da != db) return da < db;
        }
        return a.size() < b.size(); // tie-breaker
    }
};

map<string, int, CaseInsensitive> dict;
```

> 비교자는 **엄격 약순서(strict weak ordering)** 를 만족해야 한다.

### 이종(heterogeneous) 조회 — **비용↓, 임시 생성 없음**

- **전제**: 비교자가 **투명 비교자**(C++14)여야 한다 → `std::less<>` 사용 시 자동 지원.
- 효과: `std::string` 키의 `map<string,int>` 에서 **`string_view`로 바로 검색** 가능.

```cpp
#include <map>
#include <string>
#include <string_view>
#include <iostream>

int main(){
    std::map<std::string, int, std::less<>> m; // 투명 비교자
    m.emplace("Tom", 90);

    std::string_view key = "Tom";
    auto it = m.find(key); // string_view로 바로 검색, 임시 string 생성 X
    if (it != m.end()) std::cout << it->second << "\n";
}
```

### 노드 조작(C++17) — `extract/merge`로 **키 수정/컨테이너간 이동**

{% raw %}
```cpp
std::map<std::string, int> a{{"one",1}}, b{{"two",2}};

// a의 "one" 노드를 꺼내 키를 수정해 다시 삽입
if (auto nh = a.extract("one")) {
    nh.key() = "uno";      // 키 수정 가능 (평소엔 금지)
    b.insert(std::move(nh)); // b에 노드 이동 (할당/복사 없음)
}

// 서로 다른 map 사이 병합(중복 키는 남는 쪽에 stay)
std::map<std::string,int> c{{"x",1},{"y",2}}, d{{"y",20},{"z",3}};
c.merge(d); // c: x=1,y=2,z=3  d: y=20만 남을 수 있음(삽입 실패 노드)
```
{% endraw %}

---

## `set` — 정렬된 “고유” 집합

- 값 그 자체가 키 (중복 없음). 중복 허용은 `multiset`.
- 나머지 성질은 `map`과 동일(트리 기반, $$O(\log n)$$, 반복자 안정성).

```cpp
#include <set>
#include <iostream>

using namespace std;

int main(){
    set<int> s = {1,3,5};
    s.insert(2);           // {1,2,3,5}
    s.erase(3);            // {1,2,5}
    cout << s.count(2) << "\n"; // 1
    // 구간 삭제: [low, high)
    auto low = s.lower_bound(2), high = s.upper_bound(10);
    s.erase(low, high);
}
```

### `set`에서 “조건 제거” — C++20 `erase_if`

```cpp
#include <set>
#include <iostream>
#include <algorithm>

int main(){
    std::set<int> s{1,2,3,4,5,6};
    // 짝수만 삭제
    std::erase_if(s, [](int x){ return x%2==0; }); // C++20
    for (int x: s) std::cout << x << ' '; // 1 3 5
}
```

---

## `unordered_map` — 해시 기반, 평균 O(1)

### 핵심 성질

- **순서 없음**(순회 순서 정의 X).
- 평균 **탐색/삽입/삭제**: $$O(1)$$. **최악**: $$O(n)$$ (해시 충돌/공격적 입력).
- **버킷 수와 부하율**이 성능 결정. 재해시(rehash) 시 **반복자/포인터/참조 무효화**.
- 키는 **해시 가능**해야 함(`std::hash<Key>` 특수화 또는 커스텀 해시 제공).

### 기본 사용 & 성능 팁

```cpp
#include <unordered_map>
#include <string>
#include <iostream>

using namespace std;

int main(){
    unordered_map<string,int> um;
    um.reserve(1024);                // 성능 핵심: 버킷 미리 확보
    um.max_load_factor(0.7f);        // 부하율 제어(기본 ~1.0인 구현이 흔함)

    um["apple"]  = 100;              // []: 없으면 디폴트 생성
    um["banana"] = 80;

    if (auto it = um.find("apple"); it != um.end())
        cout << it->second << "\n";

    // rehash: 원하는 버킷 수로 강제 재구성
    um.rehash(4096);

    // 전체 순회 (순서 보장 없음)
    for (auto&& [k,v] : um) cout << k << ":" << v << "\n";
}
```

> **팁**: 대량 삽입 전 `reserve(n)`(또는 `rehash`로 충분한 버킷) → **재해시 감소** → 반복자 안정성↑/성능↑

### 반복자 무효화 규칙

| 작업 | 무효화 |
|---|---|
| `erase`로 지운 원소 | 그 원소의 반복자만 무효 |
| **rehash/reserve** | **모든** 반복자/포인터/참조 무효화 |
| 삽입 | 재해시가 발생하면 **전부 무효화** 가능 |

### 커스텀 해시/동등 비교

```cpp
#include <unordered_map>
#include <string>
#include <cctype>

struct ihash {
    size_t operator()(const std::string& s) const noexcept {
        std::size_t h = 1469598103934665603ull; // FNV-1a 예시
        for (unsigned char c : s) {
            unsigned char lc = std::tolower(c);
            h ^= lc; h *= 1099511628211ull;
        }
        return h;
    }
};
struct iequal {
    bool operator()(const std::string& a, const std::string& b) const noexcept {
        if (a.size()!=b.size()) return false;
        for (size_t i=0;i<a.size();++i)
            if (std::tolower((unsigned char)a[i]) != std::tolower((unsigned char)b[i]))
                return false;
        return true;
    }
};

int main(){
    std::unordered_map<std::string,int, ihash, iequal> um;
    um["Hello"] = 1;
    std::cout << um.count("hello") << "\n"; // 1 (대소문자 무시)
}
```

### **이종(heterogeneous) 조회** in 해시 (C++20)

- C++20부터 `unordered_*`에서도 **투명 해시/동등비교**로 이종 조회 가능.
- 해시/동등비교에 `is_transparent` 멤버를 제공해야 함.

```cpp
#include <unordered_map>
#include <string>
#include <string_view>

struct str_hash {
    using is_transparent = void; // 이종 지원 신호
    size_t operator()(std::string_view sv) const noexcept {
        return std::hash<std::string_view>{}(sv);
    }
};
struct str_eq {
    using is_transparent = void;
    bool operator()(std::string_view a, std::string_view b) const noexcept { return a==b; }
    bool operator()(std::string_view a, const std::string& b) const noexcept { return a==b; }
    bool operator()(const std::string& a, std::string_view b) const noexcept { return a==b; }
};

int main(){
    std::unordered_map<std::string, int, str_hash, str_eq> um;
    um.emplace("Tom", 90);
    std::string_view key = "Tom";
    auto it = um.find(key); // string_view로 바로 검색
}
```

---

## 공통 패턴 & 제거/삽입 레시피

### 안전한 삭제 루프 (`map`/`set`/`unordered_map` 공통)

```cpp
for (auto it = m.begin(); it != m.end(); ) {
    if (/*삭제조건*/) it = m.erase(it); // C++11: erase가 다음 반복자 반환
    else ++it;
}
```

### `insert_or_assign` vs `try_emplace` (C++17)

```cpp
std::map<std::string, std::string> M;

// 키만 보고 결정: 값 생성을 늦춤(불필요한 임시/이동 방지)
M.try_emplace("k", 10, 'x');   // 값 타입이 string이면 string(10,'x') 직접 생성
M.insert_or_assign("k", "new"); // 있으면 덮어씀
```

### 범위 삭제/검색 (정렬 컨테이너)

```cpp
// [low, high) 구간만 지우기
auto low = M.lower_bound("A");
auto high = M.lower_bound("K"); // K 미만
M.erase(low, high);

// 특정 키 구간 (multimap/multiset)
auto [first, last] = M.equal_range("key"); // 동일 키 구간
```

---

## 복잡도 & 수학 요약

- 정렬 연관 컨테이너(트리):
  - $$T_{\text{find/insert/erase}} = O(\log n)$$
  - 순회: $$O(n)$$ (정렬 순서)
- 비정렬 연관 컨테이너(해시):
  - 평균 $$O(1)$$, 최악 $$O(n)$$
  - 부하율 $$\alpha = \frac{\text{size}}{\text{bucket\_count}}$$
    - **목표**: $$\alpha \approx 0.5 \sim 1.0$$ (구현별 다름).
    - `reserve(n)` 호출 시 내부적으로 적절한 `bucket_count`로 **rehash**.

---

## 반복자 무효화 총정리

| 컨테이너 | 삽입 | 삭제 | 재해시/재배치 |
|---|---|---|---|
| `map`/`set` | 다른 원소 반복자 **유지** | 지운 원소만 무효 | 없음 |
| `unordered_map` | 재해시 없으면 대체로 유지, **재해시 발생 시 전부 무효** | 지운 원소만 무효 | **전부 무효** |

---

## 예외 안전/메모리/성능 관점

- **트리(map/set)**: 노드 단위 할당(오버헤드↑), 반복자 안정성↑, 정렬/범위 질의 강점.
- **해시(unordered_map)**: 큰 키 수에서 빠름. **`reserve`/`max_load_factor`** 관리가 성능 핵심.
- 예외 안전: 표준 컨테이너는 최소 **기본 보장**을 제공. 값 타입이 **noexcept 이동**을 제공하면 재배치/rehash 시 강한 보장 달성 쉬움.

---

## 실전 시나리오

### 단어 카운트 — 이종 조회 최적화

```cpp
#include <bits/stdc++.h>

using namespace std;

struct sv_hash {
    using is_transparent = void;
    size_t operator()(string_view sv) const noexcept {
        return hash<string_view>{}(sv);
    }
};
struct sv_eq {
    using is_transparent = void;
    bool operator()(string_view a, string_view b) const noexcept { return a==b; }
};

int main(){
    ios::sync_with_stdio(false); cin.tie(nullptr);

    unordered_map<string, int, sv_hash, sv_eq> freq;
    freq.reserve(1<<20);
    string w;
    while (cin >> w) {
        // string_view로 조회 → 임시 string 생성 없이 find/insert
        auto it = freq.find(string_view(w));
        if (it == freq.end()) freq.emplace(w, 1);
        else ++it->second;
    }
    // 상위 10개 출력 (벡터에 이동 후 nth_element)
    vector<pair<string,int>> vec(freq.begin(), freq.end());
    int K = 10;
    if ((int)vec.size() > K) {
        nth_element(vec.begin(), vec.begin()+K, vec.end(),
                    [](auto& a, auto& b){ return a.second > b.second; });
        vec.resize(K);
    }
    sort(vec.begin(), vec.end(), [](auto& a, auto& b){ return a.second > b.second; });
    for (auto& [k,v] : vec) cout << k << " " << v << "\n";
}
```

### 범위 질의 — 정렬 맵의 강점

```cpp
// 시간대별 누적 값: [t0, t1) 범위 합
long long range_sum(const map<int,long long>& m, int t0, int t1){
    long long sum = 0;
    for (auto it = m.lower_bound(t0); it != m.end() && it->first < t1; ++it)
        sum += it->second;
    return sum;
}
```

### 키 수정이 필요할 때 — `extract`로 안전하게

{% raw %}
```cpp
map<string,int> M{{"id-0001", 1}};
auto nh = M.extract("id-0001");
if (nh) {
    nh.key() = "id-1";
    M.insert(std::move(nh));
}
```
{% endraw %}

---

## 체크리스트 (요약)

1) **정렬 필요/범위 질의** → `map`/`set`
2) **순서 무관·대량 검색** → `unordered_map` (반드시 **`reserve`**/`max_load_factor` 튜닝)
3) **읽기 시** `operator[]` **금지**(의도치 않은 삽입). `find`/`at`/`contains` 사용
4) **업서트**: `insert_or_assign` / **비용 최소화**: `try_emplace`
5) **이종 조회**: 정렬 컨테이너는 `std::less<>`, 해시는 **투명 해시/동등비교** 준비
6) **반복자 무효화**: 트리는 안정, 해시는 `rehash` 시 전부 무효
7) **키 수정** 필요 시 `extract/merge`(C++17) 활용 — 평소에는 **금지**(정렬 불변식/해시 불변식 깨짐)

---

## 연습 과제

1) 로그에서 `[user_id]`→카운트: `unordered_map<string,int>`로 구현, `reserve`/`max_load_factor` 변화에 따른 성능 측정.
2) `map<string,int>`에 대해 `string_view` 이종 조회/범위 삭제/`try_emplace`/`insert_or_assign` 조합 연습.
3) 대소문자 무시 키를 위한 커스텀 **비교자**(`map`)와 **해시/동등비교**(`unordered_map`) 버전 각각 구현.
4) `multimap`으로 같은 타임스탬프 여러 이벤트를 저장, `equal_range`로 조회하는 기능 작성.
5) JSON-like 경로 `"a.b.c"`를 키로 쓰는 `unordered_map`을 만들고, 투명 해시/동등비교로 `string_view` 조회 최적화.

---

## 부록: 간단 비교표

| 항목 | `map` | `set` | `unordered_map` |
|---|---|---|---|
| 내부 | 균형 BST | 균형 BST | 해시 테이블 |
| 정렬 | 예 | 예 | 아니오 |
| 평균 탐색 | $$O(\log n)$$ | $$O(\log n)$$ | $$O(1)$$ |
| 최악 탐색 | $$O(\log n)$$ | $$O(\log n)$$ | $$O(n)$$ |
| 반복자 안정성 | **높음** (삭제한 원소만 무효) | **높음** | **rehash 시 전부 무효** |
| 범위 질의 | **강함** | **강함** | 약함 |
| 메모리/지역성 | 노드 기반(오버헤드↑) | 노드 기반 | 버킷 기반 |
