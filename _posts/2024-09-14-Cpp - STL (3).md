---
layout: post
title: C++ - STL (3)
date: 2024-09-14 19:20:23 +0900
category: Cpp
---
# STL 3 — 연관 컨테이너: map과 unordered_map의 깊은 이해

## 서론: 트리와 해시, 두 가지 철학의 대립

STL의 연관 컨테이너는 '키를 통해 값을 빠르게 찾는' 문제를 해결하는 두 가지 근본적으로 다른 접근법을 제공합니다. 하나는 **정렬과 질서**를 중시하는 이진 탐색 트리 기반의 `map`/`set` 계열이고, 다른 하나는 **속도와 무질서**를 선택한 해시 테이블 기반의 `unordered_map`/`unordered_set` 계열입니다. 이 둘의 선택은 단순한 성능 비교를 넘어서, 데이터의 특성과 요구사항에 대한 철학적 선택이 됩니다.

---

## 제1부: map과 set — 질서 속의 효율

### 내부 구조: 레드-블랙 트리의 우아함

`map`과 `set`은 대부분의 구현에서 **레드-블랙 트리**라는 자가 균형 이진 탐색 트리를 사용합니다. 이 자료구조는 삽입, 삭제, 탐색 모두 O(log n)의 시간 복잡도를 보장하면서도 트리의 높이를 균형 있게 유지합니다. 각 노드는 키-값 쌍(`map`) 또는 키 자체(`set`)를 저장하며, 부모와 자식 노드에 대한 포인터를 유지합니다.

### 핵심 특성과 장단점

**장점:**
- **정렬된 순서 유지**: 이터레이션 시 키의 오름차순(또는 지정한 비교 기준)으로 접근 가능
- **예측 가능한 성능**: 항상 O(log n)으로, 입력 데이터에 민감하지 않음
- **강력한 반복자 안정성**: 노드 삭제 시 다른 모든 노드의 반복자가 유효함
- **범위 질의 최적화**: `lower_bound()`, `upper_bound()`로 효율적인 범위 검색 가능

**단점:**
- **노드 기반의 메모리 오버헤드**: 각 요소마다 여러 포인터를 저장
- **캐시 지역성 부족**: 메모리가 흩어져 있어 캐시 미스가 빈번
- **상대적으로 느린 상수 시간**: O(log n)은 해시의 O(1)보다 느릴 수 있음

### 실전 활용 패턴

```cpp
// 사용자 정의 비교자를 통한 정렬 기준 변경
struct CaseInsensitiveCompare {
    bool operator()(const std::string& a, const std::string& b) const {
        return std::lexicographical_compare(
            a.begin(), a.end(), b.begin(), b.end(),
            [](char c1, char c2) { return std::tolower(c1) < std::tolower(c2); }
        );
    }
};

std::map<std::string, int, CaseInsensitiveCompare> scores;
scores["Alice"] = 95;
scores["alice"] = 90;  // "Alice"와 같은 키로 취급됨
```

### 투명 비교자(C++14): 이종 타입 검색의 혁명

```cpp
// std::less<>를 사용하면 다양한 타입으로 검색 가능
std::map<std::string, int, std::less<>> transparent_map;
transparent_map.emplace("hello", 42);

// string_view로 검색 - 불필요한 string 생성 방지
std::string_view key = "hello";
auto it = transparent_map.find(key);

// C 스타일 문자열로도 검색 가능
auto it2 = transparent_map.find("hello");
```

### 노드 핸들(C++17): 새로운 가능성

C++17에서 도입된 노드 핸들은 `map`과 `set`의 사용 방식을 근본적으로 바꿨습니다:

```cpp
std::map<std::string, int> source = {{"old_key", 100}};
std::map<std::string, int> target;

// 노드 추출
auto node = source.extract("old_key");
if (!node.empty()) {
    // 추출한 노드의 키 수정
    node.key() = "new_key";
    // 다른 map에 삽입 - 메모리 재할당 없음
    target.insert(std::move(node));
}
```

---

## 제2부: unordered_map과 unordered_set — 속도를 위한 무질서

### 내부 구조: 해시 테이블의 힘

`unordered_map`은 **체이닝 방식의 해시 테이블**을 일반적으로 사용합니다. 각 버킷은 연결 리스트를 가지고 있으며, 해시 충돌이 발생하면 같은 버킷의 리스트에 요소를 추가합니다.

### 부하율과 재해시: 성능의 열쇠

해시 테이블의 성능은 **부하율(load factor)**에 의해 결정됩니다:

```
부하율 = 요소 수 / 버킷 수
```

부하율이 너무 높으면(일반적으로 1.0 이상) 충돌이 빈번해지고 성능이 저하됩니다. `unordered_map`은 부하율이 `max_load_factor()`를 초과하면 자동으로 **재해시**를 수행합니다:

```cpp
std::unordered_map<std::string, int> word_count;

// 성능 최적화의 핵심: 미리 버킷 수 예약
word_count.reserve(10000);  // 대략 10000개 요소 저장 예상

// 부하율 임계값 조정
word_count.max_load_factor(0.75);  // 부하율이 0.75를 넘으면 재해시

// 재해시 강제 수행
word_count.rehash(20000);  // 버킷 수를 20000개로 강제 설정
```

### 커스텀 해시 함수: 사용자 정의 타입을 위한

```cpp
struct Point {
    int x, y;
    
    // 동등 비교 연산자 (필수)
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }
};

// 해시 함수 특수화
namespace std {
    template<>
    struct hash<Point> {
        size_t operator()(const Point& p) const noexcept {
            // 간단하면서도 효과적인 해시 조합
            size_t h1 = hash<int>{}(p.x);
            size_t h2 = hash<int>{}(p.y);
            return h1 ^ (h2 << 1);  // 또는 더 정교한 조합 사용
        }
    };
}

// 이제 Point를 키로 사용 가능
std::unordered_map<Point, std::string> point_names;
```

### 투명 해시(C++20): unordered_map의 진화

C++20부터 `unordered_map`도 투명 비교를 지원합니다:

```cpp
struct StringHash {
    using is_transparent = void;  // 투명 해시 선언
    
    size_t operator()(std::string_view sv) const {
        return std::hash<std::string_view>{}(sv);
    }
    
    size_t operator()(const std::string& s) const {
        return std::hash<std::string>{}(s);
    }
};

struct StringEqual {
    using is_transparent = void;  // 투명 동등 비교 선언
    
    bool operator()(std::string_view a, std::string_view b) const {
        return a == b;
    }
    
    bool operator()(const std::string& a, std::string_view b) const {
        return a == b;
    }
};

std::unordered_map<std::string, int, StringHash, StringEqual> map;
map.emplace("hello", 42);

// 다양한 타입으로 검색 가능
std::string_view sv = "hello";
auto it = map.find(sv);  // string_view로 검색
```

---

## 제3부: 실전 선택 가이드 — map vs unordered_map

### 언제 map을 선택해야 하는가?

1. **데이터가 정렬된 상태로 유지되어야 할 때**
   - 범위 검색(`lower_bound`, `upper_bound`)이 필요할 때
   - 순서대로 출력하거나 처리해야 할 때

2. **성능 예측성이 중요할 때**
   - 최악의 경우에도 O(log n)이 보장되어야 할 때
   - 서비스 수준 협약(SLA)이 엄격한 경우

3. **반복자 안정성이 중요한 경우**
   - 요소 삭제 후에도 다른 요소에 대한 참조/반복자가 유효해야 할 때
   - 장기간 참조를 보관해야 하는 경우

4. **메모리 단편화를 피해야 할 때**
   - 연속 메모리 할당 실패를 우려하는 임베디드 시스템

### 언제 unordered_map을 선택해야 하는가?

1. **최대의 검색 성능이 필요할 때**
   - 대규모 데이터셋에서 평균 O(1) 검색이 필요할 때
   - 캐시 최적화가 중요한 고성능 애플리케이션

2. **데이터 정렬이 필요없을 때**
   - 순서가 전혀 중요하지 않은 데이터
   - 존재 여부만 중요한 집합 연산

3. **메모리 사용량을 최적화할 수 있을 때**
   - 적절한 `reserve()`와 `max_load_factor()` 튜닝이 가능할 때
   - 해시 함수가 잘 분포시킬 수 있을 때

### 성능 비교: 실제 시나리오

```cpp
// 100만 개의 랜덤 정수를 저장하고 검색하는 테스트
void benchmark_search() {
    constexpr size_t N = 1'000'000;
    std::vector<int> keys(N);
    std::iota(keys.begin(), keys.end(), 0);
    std::shuffle(keys.begin(), keys.end(), std::mt19937{});
    
    // map 테스트
    std::map<int, int> m;
    auto start = std::chrono::high_resolution_clock::now();
    for (int key : keys) m[key] = key;
    auto mid = std::chrono::high_resolution_clock::now();
    for (int key : keys) volatile auto _ = m.find(key);
    auto end = std::chrono::high_resolution_clock::now();
    
    // unordered_map 테스트 (적절한 reserve 적용)
    std::unordered_map<int, int> um;
    um.reserve(N);
    um.max_load_factor(0.75);
    // ... 동일한 테스트 수행
}
```

**일반적인 결과:**
- 삽입: `unordered_map`이 `reserve()`를 적절히 사용하면 2-3배 빠름
- 검색: `unordered_map`이 최대 10배까지 빠를 수 있음
- 메모리: `unordered_map`이 일반적으로 더 적은 메모리 사용 (잘 튜닝된 경우)

---

## 제4부: 고급 패턴과 최적화 기법

### 멀티맵과 멀티셋: 중복 키의 세계

```cpp
std::multimap<std::string, int> student_scores;
student_scores.emplace("Alice", 85);
student_scores.emplace("Alice", 92);  // 같은 키로 다른 값 저장 가능

// 특정 키의 모든 값 조회
auto [begin, end] = student_scores.equal_range("Alice");
for (auto it = begin; it != end; ++it) {
    std::cout << it->second << "\n";
}
```

### LRU 캐시 구현: map과 list의 조합

```cpp
template<typename Key, typename Value>
class LRUCache {
private:
    size_t capacity_;
    std::list<std::pair<Key, Value>> items_;
    std::unordered_map<Key, typename std::list<std::pair<Key, Value>>::iterator> cache_;
    
public:
    LRUCache(size_t capacity) : capacity_(capacity) {}
    
    Value* get(const Key& key) {
        auto it = cache_.find(key);
        if (it == cache_.end()) return nullptr;
        
        // 사용한 항목을 앞으로 이동 (MRU)
        items_.splice(items_.begin(), items_, it->second);
        return &(it->second->second);
    }
    
    void put(const Key& key, const Value& value) {
        auto it = cache_.find(key);
        if (it != cache_.end()) {
            // 이미 존재하면 업데이트하고 앞으로 이동
            items_.splice(items_.begin(), items_, it->second);
            it->second->second = value;
            return;
        }
        
        if (items_.size() == capacity_) {
            // LRU 항목 제거
            auto last = items_.end();
            --last;
            cache_.erase(last->first);
            items_.pop_back();
        }
        
        // 새 항목 추가
        items_.emplace_front(key, value);
        cache_[key] = items_.begin();
    }
};
```

### 병합과 분할: 대규모 데이터 처리

```cpp
// 여러 map 병합 (C++17)
std::map<int, std::string> map1 = {{1, "a"}, {2, "b"}};
std::map<int, std::string> map2 = {{2, "B"}, {3, "c"}};

// 노드 단위 병합 (메모리 효율적)
map1.merge(map2);
// map1: {1:"a", 2:"b", 3:"c"}
// map2: {2:"B"} (충돌로 병합되지 않은 요소)

// 범위 기반 분할
std::map<int, std::string> source = {{1,"a"}, {2,"b"}, {3,"c"}, {4,"d"}};
std::map<int, std::string> lower, upper;

// 3 미만은 lower, 3 이상은 upper로 분할
auto split_pos = source.lower_bound(3);
lower.insert(source.begin(), split_pos);
upper.insert(split_pos, source.end());
```

---

## 결론: 지혜로운 선택을 위한 원칙

연관 컨테이너 선택은 단순한 성능 비교를 넘어서는 설계 결정입니다. 다음 원칙을 기억하세요:

1. **기본 규칙**: 데이터 크기가 작거나(수백 개 이하), 정렬이 필요하거나, 최악의 경우 성능이 중요한 경우에는 `map`을 선택하세요.

2. **속도 우선**: 대규모 데이터셋(수천 개 이상)에서 최대 성능이 필요하고, 순서가 중요하지 않으며, 적절한 해시 함수를 제공할 수 있다면 `unordered_map`을 선택하세요.

3. **튜닝의 중요성**: `unordered_map`은 기본 설정으로는 최적의 성능을 내지 못합니다. `reserve()`, `max_load_factor()`, 커스텀 해시 함수의 적절한 조합이 필요합니다.

4. **안정성 vs 속도**: `map`의 반복자 안정성과 예측 가능한 성능은 많은 시스템에서 `unordered_map`의 잠재적인 성능 이점보다 가치 있을 수 있습니다.

5. **측정, 측정, 측정**: 이론적 복잡도는 출발점일 뿐입니다. 실제 데이터와 실제 하드웨어에서의 성능 측정이 가장 확실한 가이드입니다.

최종적으로, 가장 좋은 컨테이너는 여러분의 특정 사용 사례, 데이터 특성, 성능 요구사항을 가장 잘 이해하고 있는 여러분이 선택한 것입니다. STL이 제공하는 이 두 가지 도구는 각각의 장점을 가지고 있으며, 현명한 개발자는 상황에 맞게 올바른 도구를 선택할 줄 알아야 합니다.