---
layout: post
title: C - 메모리 구조와 변수 저장 위치
date: 2024-08-30 19:20:23 +0900
category: C
---
# 메모리 구조와 변수 저장 위치

## 0. 한 화면 요약

```
가상 주소 공간(개념적)

+-----------------------------+ 높은 주소
| 커널 공간 (OS)              |
+-----------------------------+
| 공유 라이브러리 / mmap 영역 |
+-----------------------------+
| 힙 (malloc/calloc/realloc)  |  ↑ 확장
+-----------------------------+
| BSS (zeroinit 전역/static)  |
+-----------------------------+
| 데이터 (init 전역/static)   |
+-----------------------------+
| .rodata (상수/문자열 리터럴)|
+-----------------------------+
| 코드(.text)                 |
+-----------------------------+ 낮은 주소
                              |
                              ↓ 스택(함수 프레임) — 아래로 성장(플랫폼마다 다름)
```

> 실제 배치는 OS/ABI마다 다르고 **ASLR**로 매 실행마다 주소가 달라집니다.

---

## 1. 5대 영역 다시 보기

| 영역 | 대표 내용 | 수명(저장 기간) | 특징 |
|---|---|---|---|
| 코드(.text) | 기계어 명령 | 프로그램 전체 | 보통 **읽기 전용**, self-modifying 불가 |
| .rodata | 문자열 리터럴, `const`(일부 구현) | 프로그램 전체 | 읽기 전용. 쓰기 시 **UB** |
| 데이터(.data) | 초기값 있는 전역/정적 | 프로그램 전체 | 시작 시 초기값 복사 |
| BSS(.bss) | 0-초기화 전역/정적 | 프로그램 전체 | **제로 초기화**로 채워짐 |
| 힙 | 동적 할당 | `malloc`~`free` | 크기 가변, 누수/이중free 주의 |
| 스택 | 지역/매개변수/리턴주소 | 함수 진입~복귀 | 자동 해제, **오버플로우 위험** |

---

## 2. 수명·스코프·링키지의 3축

- **저장 기간(수명; Storage duration)**  
  - 자동(`auto`): 블록 진입/이탈 동안(스택).  
  - 정적(`static`/전역): 프로그램 전 기간(.data/.bss/.rodata).  
  - 동적: `malloc`~`free`(힙).  
  - 스레드 로컬: `_Thread_local` or `__thread`.

- **스코프(가시성; Scope)**: 이름이 **보이는 범위**(블록/파일/프로그램).

- **링키지(Linkage)**: 다른 번역 단위에서 **같은 이름을 동일 개체로 연결**?
  - 외부(기본 전역/함수), 내부(`static` 전역), 없음(블록 안 변수/매크로 파라미터 등).

정리 표:

| 선언 형태 | 저장 기간 | 스코프 | 링키지 |
|---|---|---|---|
| 블록내 `int x;` | 자동 | 블록 | 없음 |
| `static int s;`(블록 내부) | 정적 | 블록 | 없음 |
| 파일 스코프 `int g;` | 정적 | 파일 이후 | **외부** |
| 파일 스코프 `static int t;` | 정적 | 파일 이후 | **내부** |
| `_Thread_local int u;` | 스레드 | 파일 이후 | 외부(기본) |

---

## 3. 코드로 영역을 **직접 관찰**해 보기

> 주소값을 비교해 영역 감각을 키웁니다. (실행마다 주소/순서는 달라질 수 있음)

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int g_init = 42;          // .data
int g_bss;                // .bss (제로 초기화)
const char *g_str = "RODATA"; // 포인터 자체는 .data, 리터럴은 .rodata

static int s_internal;    // .bss (내부 링키지)

void foo(int param) {
    int local = 123;      // 스택
    static int s = 7;     // .data (정적 저장 기간)
    printf("param@%p local@%p static@%p\n", (void*)&param, (void*)&local, (void*)&s);
}

int main(void){
    int main_local = 0;   // 스택
    char *heap = malloc(16); // 힙
    strcpy(heap, "hi");

    printf(".text(foo)         = %p\n", (void*)&foo);
    printf(".rodata(\"lit\")    = %p\n", (void*)"LITERAL");
    printf(".data(g_init)      = %p\n", (void*)&g_init);
    printf(".bss(g_bss)        = %p\n", (void*)&g_bss);
    printf("heap               = %p\n", (void*)heap);
    printf("stack(main_local)  = %p\n", (void*)&main_local);

    foo(10);
    free(heap);
    return 0;
}
```

**해설**
- 문자열 리터럴을 **수정하면 UB**: `((char*)"X")[0]='Y'` → 크래시 가능.
- `static` 지역은 **한 번만 초기화**되고 그 이후 값 유지(.data/.bss).

---

## 4. 스택(Stack) — 프레임과 성장 방향

### 4.1 스택 프레임 개념
함수 호출 시 보통 다음이 프레임에 적재됩니다:
- 리턴 주소
- 저장된 레지스터(프롤로그/에필로그에 저장/복원)
- 지역 변수/임시
- 정렬용 패딩

### 4.2 스택 성장 방향 확인(참고용 코드)

```c
#include <stdio.h>
void a(int *base, int depth){
    int x = depth;
    printf("depth=%d addr=%p delta=%td\n", depth, (void*)&x, (ptrdiff_t)((char*)&x - (char*)base));
    if (depth < 5) a(base, depth+1);
}
int main(void){
    int base = 0;
    a(&base, 0);
}
```

> 많은 플랫폼에서 **스택은 아래로 감소**하지만 **절대 가정하지 마세요**.

### 4.3 스택 오버플로우
- 원인: **무한/깊은 재귀**, 큰 배열(예: `int big[1<<26];`).
- 방지: 재귀 제한, 큰 버퍼는 **힙으로**.

---

## 5. 힙(Heap) — 동적 관리의 힘과 함정

### 5.1 수명은 **프로그래머가 결정**
```c
char *p = malloc(100);
if (!p) { /* out of memory */ }
/* 사용 */
free(p);
p = NULL; // 댕글링 방지
```

### 5.2 대표 버그
- **누수(Leak)**: `malloc` 후 `free` 누락.  
- **이중 해제(Double free)**: 같은 포인터를 두 번 `free` → 취약점.  
- **Use-After-Free(UAF)**: `free` 후 계속 사용 → RCE까지 이어질 수 있음.  
- **경계 초과(Out-of-bounds)**: `p[i]` 범위 벗어남.

### 5.3 안전 패턴
```c
void *tmp = realloc(p, new_size);
if (!tmp) {
    /* 실패 시 p는 여전히 유효 — 롤백 가능 */
} else {
    p = tmp;
}
```

---

## 6. 데이터(.data) / BSS(.bss) / .rodata — 정적 저장 기간

```c
int     g1 = 1;      // .data
int     g2;          // .bss (자동으로 0)
static  int s;       // .bss (파일 내부)
const char *k = "abc"; // 포인터=.data, 문자열=.rodata
```

- **BSS**는 파일 크기를 늘리지 않으며, 로더가 **제로 페이지**로 매핑.
- **.rodata**는 보통 **실행 시 쓰기 금지** → 에러로 안전성↑.

---

## 7. 정렬(Alignment)과 패딩(Padding)

CPU는 **정렬된 주소**를 선호/강제할 수 있습니다. 구조체는 멤버 정렬 때문에 **패딩 바이트**가 끼어들 수 있습니다.

```c
#include <stdio.h>
#include <stddef.h>

struct S {
    char c;     // 1
    int  i;     // 4 (정렬 때문에 c 뒤에 패딩 3바이트 가능)
    short h;    // 2
};

int main(void){
    printf("sizeof(S)=%zu\n", sizeof(struct S));
    printf("offset c=%zu i=%zu h=%zu\n",
        offsetof(struct S,c), offsetof(struct S,i), offsetof(struct S,h));
}
```

- **필드 순서**를 바꿔 패딩을 줄일 수 있음.
- `#pragma pack`/`__attribute__((packed))`는 **ABI/성능 손상** 주의 — 외부 프로토콜 바이너리 매칭 등 정말 필요할 때만.

---

## 8. 문자열 리터럴과 `const`

```c
char *p = "HELLO";  // 리터럴은 .rodata (읽기 전용). p[0]='h' ⇒ UB
const char *q = "HELLO"; // q를 통해서도 수정 금지
```

- `const`는 **타입 안전**을 강화합니다.  
- 다만 `const`가 곧 .rodata에 간다고 단정할 수는 없고, **리터럴 자체**는 보통 .rodata입니다.

---

## 9. TLS(Thread-Local Storage)

스레드별 독립 저장 영역. C11:

```c
_Thread_local int tls_counter = 0;

void bump(void){ tls_counter++; }
```

- GCC/Clang/MSC 확장: `__thread` 또는 `__declspec(thread)` (플랫폼 의존).  
- 사용처: errno 대체, 스레드별 통계 등.

---

## 10. 호출 규약·스택 프레임(개념)

플랫폼/ABI에 따라 인자 전달은 **레지스터 + 스택** 혼합, 반환값은 **레지스터**.  
프롤로그/에필로그에서 프레임 포인터/비휘발 레지스터 저장 복원.

> 세부 사항은 **ABI 문서**를 따르되, **재진입성/순수 함수/스택-힙 경계**만 잘 지켜도 실무 대부분을 커버합니다.

---

## 11. 가상 메모리·ASLR·보호 비트

- **가상 메모리**: 각 프로세스에 독립된 주소 공간. 페이지 단위 매핑.  
- **ASLR**: 스택/힙/라이브러리/코드 베이스 주소를 무작위화 → 익스플로잇 난이도↑.  
- **NX/DEP**: 데이터 영역 실행 금지. 코드 주입 방지.  
- **결론**: **UB(정의되지 않은 동작)** 을 밟으면 환경에 따라 우연히 “동작”할 수 있어도, 다른 환경에선 터집니다.

---

## 12. 대표 **안전/불안전** 예제 모음

### 12.1 **스택 버퍼 오버런(불안전)**
```c
void bad(void){
    char buf[8];
    gets(buf);      // 금지(API 자체가 위험) — fgets 사용
}
```

### 12.2 **안전한 입력**
```c
void good(void){
    char buf[8];
    if (fgets(buf, sizeof buf, stdin)) {
        /* 처리: 개행 제거 등 */
    }
}
```

### 12.3 **문자열 리터럴 수정(UB)**
```c
void ub(void){
    char *p = "hi";
    // p[0] = 'H'; // 크래시 가능
}
```

### 12.4 **댕글링 포인터 방지**
```c
char *p = malloc(10);
/* ... */
free(p);
p = NULL; // 이후 NULL 체크로 접근 차단
```

### 12.5 **이중 해제 방지 패턴**
```c
void safe_free(void **pp){
    if (pp && *pp) { free(*pp); *pp = NULL; }
}
```

---

## 13. 수식으로 보는 정렬 제약(직관)

정렬 단위를 $$A$$라 하면, 필드 $$x$$의 시작 주소 $$\mathrm{addr}(x)$$는
$$
\mathrm{addr}(x) \equiv 0 \pmod{A}
$$
가 되도록 패딩이 삽입될 수 있습니다.  
구조체 전체 크기는 **최대 정렬 단위의 배수**로 반올림됩니다.

---

## 14. “어디에 저장되나?” 빠른 판별표

| 코드 | 어디? | 메모 |
|---|---|---|
| `int x;`(블록) | **스택** | 자동 저장 기간 |
| `static int x;`(블록) | **.bss/.data** | 값 유지 |
| `int g=1;`(파일 스코프) | **.data** | 초기화 복사 |
| `int g;`(파일 스코프) | **.bss** | 제로 초기화 |
| `char *s="hi";` | 포인터=.data, 리터럴=.rodata | 리터럴 수정 금지 |
| `malloc(…)` | **힙** | `free` 필수 |

---

## 15. 작은 실험: 스택 vs 힙 성능 감각

- 스택: **고정 크기**, 함수 진입/복귀에 따라 **매우 빠름**.  
- 힙: **가변/프래그멘테이션 관리 비용**으로 상대적으로 느림.  
- 경험 법칙: **작고 수명이 짧은 버퍼 → 스택**, **크고 가변/수명 복잡 → 힙**.

---

## 16. 체크리스트

- [ ] 큰 배열은 스택 대신 **힙**(또는 정적)으로.  
- [ ] 모든 `malloc`에는 **정확히 한 번의 `free`**.  
- [ ] `realloc`은 **임시 포인터**로(실패 시 원본 보존).  
- [ ] 문자열 리터럴 **쓰기 금지**.  
- [ ] 구조체 **정렬/패딩** 이해하고 바이너리 직렬화 시 필드별 처리.  
- [ ] 전역 상태는 최소화하고 필요 시 **`static` 내부 링크**로 은닉.  
- [ ] `_Thread_local`로 스레드별 상태 분리(필요할 때만).  
- [ ] 입력은 **길이 제한**(`fgets`, `scanf("%Ns")`) 필수.  
- [ ] ASLR/DEP 가정하고 **UB 회피**.  
- [ ] 디버깅/검증: 주소 인쇄, 경계 검증, 런타임 도구(주소/누수 검사 등) 활용.

---

## 17. 연습: 주소대 비교로 영역 감 잡기

```c
#include <stdio.h>
#include <stdlib.h>

int G;             // .bss
int H = 1;         // .data

int main(void){
    int  a = 0;                // stack
    int *p = malloc(sizeof *p);// heap
    const char *s = "seg";     // .rodata
    printf("&G=%p &H=%p &a=%p p=%p s=%p\n",
           (void*)&G,(void*)&H,(void*)&a,(void*)p,(void*)s);
    free(p);
}
```

> **의도**: 각 영역의 “상대적 위치” 감각을 익히되 **절대적 규칙은 아님**.

---

## 18. 마무리 요약

| 주제 | 핵심 |
|---|---|
| 5대 영역 | .text/.rodata/.data/.bss/힙/스택 역할 구분 |
| 수명/스코프/링키지 | 저장 기간·가시성·연결 개념을 **분리**해 이해 |
| 스택 | 빠르지만 한정·프레임 기반, 큰 버퍼 지양 |
| 힙 | 유연하나 관리 비용·버그 위험(누수/UAF/이중해제) |
| 정렬/패딩 | 구조체 크기/오프셋에 영향, 직렬화 시 주의 |
| TLS | 스레드별 상태 — `_Thread_local` |
| 보안 | ASLR/DEP 환경 가정, UB 제거 |
| 실전 | 포인터 인쇄로 감각, 안전 입력·해제 패턴 습관화 |