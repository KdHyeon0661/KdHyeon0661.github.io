---
layout: post
title: 파이썬 - 리스트
date: 2024-07-30 19:20:23 +0900
category: Python
---
# 파이썬 리스트(List)

파이썬에서 **리스트(List)**는 **순서가 있는 변경 가능한 컬렉션**입니다.
서로 다른 타입의 값을 한 컨테이너에 담을 수 있고, **0부터 시작하는 인덱스**로 요소에 접근합니다.

---

## 리스트 생성

대괄호 `[]` 또는 내장 생성자 `list()`를 사용합니다.

```python
# 빈 리스트

empty_list = []
empty_list2 = list()

# 정수형 리스트

numbers = [1, 2, 3, 4, 5]

# 혼합 타입

mixed = [1, "hello", 3.14, True, None]

# 이중(중첩) 리스트

double = [[1, 2], [3, 4]]

# 시퀀스/이터러블로부터

from_iter = list(range(5))   # [0, 1, 2, 3, 4]
from_str  = list("abc")      # ['a', 'b', 'c']

# “반복”으로 초기값 채우기(주의: 얕은 복사)

row = [0] * 5                 # [0, 0, 0, 0, 0]
matrix_bad = [[0] * 3] * 4    # 내부 리스트가 ‘같은 객체’를 4회 참조(함정!)
```

> **주의(중요 함정)**
> `[[0] * 3] * 4`는 내부 리스트가 **모두 같은 객체**를 가리킵니다. 한 곳을 바꾸면 전부 바뀝니다.
> 안전한 방법은 **내포(list comprehension)**을 쓰는 것입니다.

```python
matrix_ok = [[0] * 3 for _ in range(4)]
matrix_ok[0][0] = 1
print(matrix_ok)  # [[1, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
```

---

## 요소 접근/수정/추가/삭제

### (1) 요소 접근

```python
numbers = [10, 20, 30, 40]
print(numbers[0])   # 10
print(numbers[-1])  # 40 (역인덱스)
```

### (2) 요소 수정(가변)

```python
numbers[1] = 25
print(numbers)  # [10, 25, 30, 40]
```

### (3) 추가/삭제

```python
numbers = [10, 25, 30, 40]

# 끝에 추가

numbers.append(50)            # [10, 25, 30, 40, 50]

# 임의 위치에 삽입

numbers.insert(2, 15)         # [10, 25, 15, 30, 40, 50]

# 끝에서 꺼내기(스택 pop)

last = numbers.pop()          # 50,  -> [10, 25, 15, 30, 40]

# 인덱스로 꺼내기

val = numbers.pop(2)          # 15,  -> [10, 25, 30, 40]

# 값으로 삭제(첫 일치만)

numbers.remove(25)            # [10, 30, 40]
# numbers.remove(999)         # ValueError (없으면 예외)

```

> **패턴**
> - **스택**: `append` + `pop()`
> - **큐**: `collections.deque` 권장(리스트는 `pop(0)`이 O(n)이라 비효율)

---

## 슬라이싱(Slicing)

문법: `lst[start:stop:step]` — `stop`은 **미포함**입니다.

```python
lst = [10, 20, 30, 40, 50]
print(lst[1:4])     # [20, 30, 40]
print(lst[:3])      # [10, 20, 30]
print(lst[3:])      # [40, 50]
print(lst[::2])     # [10, 30, 50]
print(lst[::-1])    # [50, 40, 30, 20, 10]
```

### (보강) 슬라이스 대입(범위 치환)

```python
nums = [1, 2, 3, 4, 5]
nums[1:3] = ['a', 'b']     # [1, 'a', 'b', 4, 5]
nums[:0] = [0, 0]          # 앞에 삽입 → [0, 0, 1, 'a', 'b', 4, 5]
nums[3:5] = []             # 구간 삭제 → [0, 0, 1, 4, 5]
```

> **슬라이스**는 복사 시 자주 씁니다: `copy = lst[:]` (얕은 복사)

---

## 길이/결합/반복/멤버십

```python
lst = [1, 2, 3]
print(len(lst))         # 3

print([1, 2] + [3, 4])  # [1, 2, 3, 4]
print([1, 2] * 3)       # [1, 2, 1, 2, 1, 2]

print(2 in lst)         # True
print(9 not in lst)     # True
```

> `+`는 새 리스트를 만듭니다(원본 불변). **제자리 결합**은 `extend()`를 사용하세요.

---

## 복사: 얕은 복사 vs 깊은 복사

리스트는 **가변**이라 참조 공유로 인한 사이드 이펙트를 조심해야 합니다.

### (1) 얕은 복사(Shallow Copy)

```python
import copy

original = [[1, 2], [3, 4]]
a = original[:]             # 또는 list(original) / original.copy()
b = copy.copy(original)

original[0][0] = 100
print(original)  # [[100, 2], [3, 4]]
print(a)         # [[100, 2], [3, 4]]  ← 내부 리스트는 공유됨
print(b)         # [[100, 2], [3, 4]]
```

### (2) 깊은 복사(Deep Copy)

```python
import copy

original = [[1, 2], [3, 4]]
deep_copy = copy.deepcopy(original)

original[0][0] = 100
print(original)   # [[100, 2], [3, 4]]
print(deep_copy)  # [[1, 2], [3, 4]]
```

---

## 리스트 메서드 총정리(+ 예제)

| 메서드/연산 | 설명 | 시간복잡도(평균) | 예시 |
|---|---|---|---|
| `append(x)` | 뒤에 추가 | amortized **O(1)** | `lst.append(10)` |
| `extend(it)` | 이터러블 뒤에 덧붙임 | O(k) | `lst.extend([20, 30])` |
| `insert(i,x)` | 위치 삽입 | O(n) | `lst.insert(1, 'hello')` |
| `remove(x)` | 첫 일치 삭제 | O(n) | `lst.remove(10)` |
| `pop([i])` | 요소 제거+반환 | 끝 O(1), 중간 O(n) | `lst.pop()` |
| `clear()` | 전부 삭제 | O(n) | `lst.clear()` |
| `index(x[,s,e])` | 첫 위치 | O(n) | `lst.index(99)` |
| `count(x)` | 개수 | O(n) | `lst.count(10)` |
| `sort(key, reverse)` | 정렬(Timsort) | O(n log n) | `lst.sort()` |
| `reverse()` | 역순 배치 | O(n) | `lst.reverse()` |
| `copy()` | 얕은 복사 | O(n) | `lst2 = lst.copy()` |
| `del` | 요소/구간 삭제 | O(n) | `del lst[2:5]` |

### 예제 묶음

```python
lst = [5, 3, 8, 6, 3]
lst.append(10)                 # [5, 3, 8, 6, 3, 10]
lst.extend([20, 30])           # [5, 3, 8, 6, 3, 10, 20, 30]
lst.insert(2, 99)              # [5, 3, 99, 8, 6, 3, 10, 20, 30]
lst.remove(3)                  # [5, 99, 8, 6, 3, 10, 20, 30]
p = lst.pop(4)                 # p=3, [5, 99, 8, 6, 10, 20, 30]
print(lst.index(99))           # 1
lst.sort()                     # [5, 6, 8, 10, 20, 30, 99]
lst.reverse()                  # [99, 30, 20, 10, 8, 6, 5]
print(lst.count(10))           # 1
lst.clear()                    # []
```

---

## 정렬(오름/내림, key, 안정성, 사용자 정의)

파이썬 정렬은 **Timsort**(안정정렬) 기반입니다. **안정성** 덕분에 다중 기준을 순차 적용하기 쉽습니다.

```python
data = [
    {"name": "kim", "age": 30},
    {"name": "lee", "age": 25},
    {"name": "park", "age": 25},
]

# 단일 기준

data.sort(key=lambda x: x["age"])  # age 오름차순

# 다중 기준(튜플 키)

data.sort(key=lambda x: (x["age"], x["name"]))  # age → name

# 내림차순

data.sort(key=lambda x: x["age"], reverse=True)
```

### (보강) 정렬은 “제자리” vs `sorted()`(새 리스트)

```python
nums = [3,1,2]
a = sorted(nums)         # [1,2,3], 원본 보존
nums.sort()              # 원본 자체가 [1,2,3]
```

---

## 리스트 내포(List Comprehension)

간결하고 빠른 생성/변환 문법입니다.

```python
# 기본

squares = [x*x for x in range(6)]                 # [0,1,4,9,16,25]

# 필터 포함

evens   = [x for x in range(10) if x % 2 == 0]    # [0,2,4,6,8]

# 중첩 루프

pairs   = [(i,j) for i in range(2) for j in range(3)]  # [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]

# 조건 표현식

labels  = ["even" if x%2==0 else "odd" for x in range(5)]
```

> **메모리 고려**: 아주 큰 시퀀스는 **제너레이터 표현식**(`(...)`)으로 지연 평가를 쓰세요.

---

## 순회/언패킹/유틸 패턴

```python
# 기본 순회

for x in [10, 20, 30]:
    ...

# 인덱스와 함께

for i, x in enumerate(['a', 'b', 'c'], start=1):
    print(i, x)   # 1 a / 2 b / 3 c

# 여러 리스트 병렬 순회

names = ["kim", "lee", "park"]
ages  = [30, 25, 28]
for n, a in zip(names, ages):
    print(n, a)

# 스타(*) 언패킹

head, *mid, tail = [1,2,3,4,5]   # head=1, mid=[2,3,4], tail=5
```

---

## 스택/큐/덱/우선순위 큐

### (1) 스택(LIFO): 리스트로 충분

```python
stack = []
stack.append(1)
stack.append(2)
print(stack.pop())   # 2
```

### (2) 큐(FIFO): `deque` 권장

```python
from collections import deque

q = deque()
q.append(1)       # 오른쪽 삽입
q.append(2)
print(q.popleft())# 왼쪽 꺼내기 (O(1))
```

### (3) 우선순위 큐: `heapq`

```python
import heapq

hq = []
heapq.heappush(hq, (2, "taskB"))
heapq.heappush(hq, (1, "taskA"))
heapq.heappush(hq, (3, "taskC"))
print(heapq.heappop(hq))   # (1, 'taskA')
```

---

## 정렬/탐색 보조: `bisect` (이진 탐색)

정렬된 리스트에서 **삽입 위치**를 O(log n)으로 찾습니다.

```python
import bisect

arr = [10, 20, 30, 40]
i = bisect.bisect_left(arr, 25)   # 25의 삽입 위치(왼쪽 편향)
arr.insert(i, 25)                 # [10, 20, 25, 30, 40]
```

---

## 리스트 vs 다른 시퀀스

| 타입 | 가변 | 해시 가능 | 용도 |
|---|---|---|---|
| `list` | O | X | 일반 가변 시퀀스, 다양한 조작 |
| `tuple` | X | (요소 모두 불변이면) O | 불변 시퀀스, 딕셔너리 키/집합 요소 |
| `array('i')` 등 | O | X | 동일 타입 대량 수치(메모리 효율) |
| `deque` | O | X | 양끝 삽입/삭제 빠른 큐/덱 |
| `str` | X | O | 텍스트 시퀀스(불변) |

> **대량 수치/벡터화**는 `numpy.ndarray`가 성능/연산 면에서 더 적합합니다.

---

## 동일성 vs 동등성, 정체성과 복사

```python
a = [1, 2]; b = [1, 2]
print(a == b)    # True  (내용 동등)
print(a is b)    # False (다른 객체)

c = a
print(c is a)    # True  (같은 객체 참조)
```

---

## 성능·메모리 팁

- `append`는 **amortized O(1)** (리스트 과할당 전략)
- 중간 삽입/삭제(`insert`, `pop(0)`)는 **O(n)** → **덱** 고려
- 큰 문자열 누적은 리스트에 `append` 후 `"".join(list)`
- 메모리 확인: `sys.getsizeof` (요소 자체의 크기는 포함하지 않음)

```python
import sys
xs = [1,2,3]
print(sys.getsizeof(xs))   # 플랫폼/버전에 따라 다름
```

---

## 예외/엣지 케이스

```python
lst = [1, 2, 3]
# print(lst[10])          # IndexError
# lst.remove(999)         # ValueError

print([].pop() if [] else "empty")  # pop 호출 전 비어있는지 체크
```

---

## “가변 기본 인자” 함정과 방어

함수 정의에서 기본값으로 빈 리스트 `[]`를 쓰면 **한 번만 생성되어 공유**됩니다.

```python
def bad(x, acc=[]):
    acc.append(x)
    return acc

print(bad(1))  # [1]
print(bad(2))  # [1, 2]  ← 이전 호출과 누적됨 (버그 소지)
```

**해결**: `None`을 기본값으로 받고 내부에서 새 리스트 생성

```python
def good(x, acc=None):
    acc = [] if acc is None else acc
    acc.append(x)
    return acc
```

---

## 사례로 배우는 정렬/집계/변환

### (1) 레코드 정렬 + Top-N 추출

```python
people = [
    ("kim", 30),
    ("lee", 25),
    ("park", 40),
    ("choi", 30),
]

# 나이 내림 → 이름 오름

people.sort(key=lambda x: (-x[1], x[0]))
top2 = people[:2]
print(top2)  # [('park', 40), ('choi', 30)]
```

### (2) 그룹핑: 정렬+슬라이싱 or `itertools.groupby`

```python
from itertools import groupby

rows = [
    ("A", 1),
    ("A", 2),
    ("B", 1),
    ("B", 3),
    ("B", 3),
]
rows.sort(key=lambda x: x[0])       # groupby는 인접 동일 키 전제
for k, grp in groupby(rows, key=lambda x: x[0]):
    values = [v for _, v in grp]
    print(k, values)
```

### (3) 평탄화(flatten)와 조건 변환

```python
nested = [[1, 2], [3, 4, 5]]
flat = [x for row in nested for x in row]          # [1,2,3,4,5]
evens = [x*10 for x in flat if x % 2 == 0]         # [20, 40]
```

---

## 테스트/디버깅에 유용한 패턴

```python
# 방어적 복사로 외부 사이드이펙트 차단

def process(seq):
    seq = list(seq)   # 이터러블을 리스트로 복사 후 안전하게 조작
    seq.sort()
    return seq

# 안전한 삭제(필터링) — remove 루프 대신 내포 사용

xs = [1, 2, 3, 2, 4]
xs = [x for x in xs if x != 2]   # [1, 3, 4]
```

---

## 요약 체크리스트

- **가변** 컨테이너: 중간 삽입/삭제가 잦으면 **deque**도 고려
- **복사**: `lst[:]`, `list(lst)`, `lst.copy()`는 **얕은 복사**, 중첩 구조는 `deepcopy`
- **초기화 함정**: `[[0]*m]*n` 금지 → 내포 사용
- **정렬**: `key`와 `reverse`로 제어, 필요 시 다중 기준 튜플 키
- **성능**: 누적 문자열은 `join`, 큐는 `deque`, 우선순위는 `heapq`, 이진 탐색은 `bisect`
- **가변 기본 인자 금지**: `None` 패턴으로 방어

---

## “실전 스니펫” 모음

```python
# 안전한 2D 리스트 생성

rows, cols = 4, 3
grid = [[0 for _ in range(cols)] for _ in range(rows)]

# 빈값 제거/정제

raw = [" a ", "", None, "b", "  "]
clean = [s.strip() for s in raw if s and s.strip()]

# 고유 보존(처음 등장 순서 유지)

seen = set()
uniq = [x for x in [3,1,2,3,2,1] if not (x in seen or seen.add(x))]

# 가장 많이 나온 값 n개

from collections import Counter
top3 = Counter(["a","b","a","c","a","b"]).most_common(3)

# 정렬된 리스트 삽입(중복 허용)

import bisect
arr = [10, 20, 30]
bisect.insort(arr, 25)     # [10, 20, 25, 30]

# 슬라이스로 대량 치환/삭제

xs = list(range(10))
xs[3:7] = ["X"]            # [0,1,2,'X',7,8,9]
xs[::2] = [0]*len(xs[::2]) # 짝수 인덱스만 0으로

# 2차원 전치(transpose)

mat = [[1,2,3],[4,5,6]]
transpose = [list(col) for col in zip(*mat)]  # [[1,4],[2,5],[3,6]]
```

---

# 마무리

- 리스트는 파이썬 컬렉션의 **기본 중의 기본**으로, **슬라이싱/내포/정렬/메서드 조합**만 숙달해도 대부분 문제를 깔끔히 해결할 수 있습니다.
- 중첩 구조, 성능 요구, 안정적 정렬/탐색이 필요하면 **`deepcopy`/`deque`/`heapq`/`bisect`/`itertools`** 등 표준 라이브러리를 함께 사용하세요.
- 본 글의 구조(# 제목 → ## 세부)를 유지한 채, 같은 깊이로 **딕셔너리/세트/튜플**도 확장 가능합니다.
