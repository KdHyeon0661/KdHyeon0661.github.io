---
layout: post
title: 파이썬 - 리스트
date: 2024-07-30 19:20:23 +0900
category: Python
---
# 파이썬 리스트(List)

파이썬에서 **리스트(List)**는 순서가 있고 변경 가능한 가장 기본적이며 강력한 컬렉션 자료형입니다. 서로 다른 타입의 데이터를 하나의 컨테이너에 담을 수 있으며, **0부터 시작하는 인덱스**를 통해 각 요소에 접근하고 조작할 수 있습니다. 리스트의 가변성(Mutability)과 풍부한 내장 메서드는 데이터 처리의 핵심 도구로 자리잡고 있습니다.

---

## 리스트 생성

리스트는 대괄호 `[]`를 사용하거나 내장 함수 `list()`를 호출하여 생성합니다.

```python
# 빈 리스트 생성
empty_list = []
empty_list2 = list()

# 요소를 가진 리스트
numbers = [1, 2, 3, 4, 5]

# 다양한 데이터 타입을 포함하는 리스트
mixed = [1, "hello", 3.14, True, None]

# 리스트 안에 리스트 (2차원 구조)
matrix = [[1, 2], [3, 4]]

# 시퀀스나 이터러블 객체로부터 리스트 생성
from_range = list(range(5))   # [0, 1, 2, 3, 4]
from_string = list("abc")     # ['a', 'b', 'c']
```

리스트를 초기화할 때 반복 연산자(`*`)를 사용할 수 있으나, 중첩된 구조에서는 주의가 필요합니다.

```python
# 단일 레벨 리스트는 문제없음
row = [0] * 5  # [0, 0, 0, 0, 0]

# 함정: 2차원 리스트를 이 방식으로 생성하면 내부 리스트들이 모두 동일한 객체를 참조합니다.
matrix_problem = [[0] * 3] * 4
matrix_problem[0][0] = 1
print(matrix_problem)  # [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] (모두 변경됨)

# 해결책: 리스트 내포(List Comprehension)을 사용하여 독립적인 객체를 생성합니다.
matrix_solution = [[0] * 3 for _ in range(4)]
matrix_solution[0][0] = 1
print(matrix_solution)  # [[1, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
```

---

## 요소 접근 및 조작

### 인덱싱과 수정

인덱스를 사용해 특정 위치의 요소에 접근하거나 새로운 값을 할당할 수 있습니다. 음수 인덱스는 리스트의 끝에서부터 역방향으로 계산합니다.

```python
fruits = ['apple', 'banana', 'cherry', 'date']

print(fruits[0])   # 'apple'
print(fruits[-1])  # 'date' (마지막 요소)

fruits[1] = 'blueberry'  # 요소 수정
print(fruits)  # ['apple', 'blueberry', 'cherry', 'date']
```

### 요소 추가 및 삭제

리스트의 끝에 요소를 추가하거나, 특정 위치에 삽입, 값을 기준으로 삭제하는 등 다양한 메서드를 제공합니다.

```python
# 끝에 요소 추가
fruits.append('elderberry')  # ['apple', 'blueberry', 'cherry', 'date', 'elderberry']

# 특정 인덱스에 요소 삽입
fruits.insert(2, 'cantaloupe')  # ['apple', 'blueberry', 'cantaloupe', 'cherry', 'date', 'elderberry']

# 값으로 첫 번째 일치하는 요소 삭제
fruits.remove('date')  # ['apple', 'blueberry', 'cantaloupe', 'cherry', 'elderberry']

# 인덱스로 요소를 제거하고 반환 (기본값: 마지막 요소)
popped_item = fruits.pop()  # 'elderberry' 반환, fruits는 ['apple', 'blueberry', 'cantaloupe', 'cherry']
popped_middle = fruits.pop(1) # 'blueberry' 반환, fruits는 ['apple', 'cantaloupe', 'cherry']

# 모든 요소 삭제
fruits.clear()  # []
```

> **자료구조 활용 패턴**
> - **스택(Stack, LIFO)**: `append()`로 삽입, `pop()`으로 제거.
> - **큐(Queue, FIFO)**: 리스트의 `pop(0)`은 효율이 낮으므로(`O(n)`), `collections.deque` 사용을 권장합니다.

---

## 슬라이싱(Slicing)

리스트의 일부분을 추출하거나 대체할 수 있는 강력한 기능입니다. `리스트[시작:끝:간격]` 형식을 사용하며, `끝` 인덱스는 포함되지 않습니다.

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[2:5])   # [2, 3, 4]
print(numbers[:3])    # [0, 1, 2] (시작 생략 시 0)
print(numbers[6:])    # [6, 7, 8, 9] (끝 생략 시 마지막까지)
print(numbers[::2])   # [0, 2, 4, 6, 8] (간격 2)
print(numbers[::-1])  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] (역순)
```

### 슬라이스를 이용한 대량 수정

슬라이스 범위에 새로운 리스트를 할당하여 한 번에 여러 요소를 교체, 삽입, 삭제할 수 있습니다.

```python
nums = [1, 2, 3, 4, 5]
nums[1:4] = ['a', 'b', 'c']  # 범위 치환 -> [1, 'a', 'b', 'c', 5]
nums[2:4] = []               # 범위 삭제 -> [1, 'a', 5]
nums[:0] = [-1, 0]           # 맨 앞에 삽입 -> [-1, 0, 1, 'a', 5]
```

슬라이싱은 항상 **새로운 리스트 객체**를 반환하므로, 리스트의 얕은 복사본을 만들 때 유용하게 사용됩니다. `copied_list = original_list[:]`

---

## 리스트 연산과 정보 확인

```python
a = [1, 2, 3]
b = [4, 5]

# 결합 (새 리스트 생성)
combined = a + b  # [1, 2, 3, 4, 5]

# 반복
repeated = a * 2  # [1, 2, 3, 1, 2, 3]

# 길이 확인
print(len(a))  # 3

# 멤버십 테스트
print(2 in a)   # True
print(10 in a)  # False
```

> `+` 연산자는 원본 리스트를 변경하지 않고 새로운 리스트를 생성합니다. 기존 리스트에 다른 이터러블의 모든 요소를 추가하려면 `extend()` 메서드를 사용하세요.

---

## 복사의 깊이: 얕은 복사 vs 깊은 복사

리스트가 가변 객체이므로, 단순 대입(`=`)은 객체 참조를 복사할 뿐입니다. 실제 데이터의 복사본이 필요할 때는 복사 방식을 이해해야 합니다.

```python
import copy

original = [[1, 2], [3, 4]]

# 얕은 복사: 최상위 리스트만 새로 생성, 내부 객체는 참조를 공유
shallow_copy = original[:]  # 또는 list(original), original.copy()
original[0][0] = 99
print(shallow_copy)  # [[99, 2], [3, 4]] (내부 리스트는 함께 변경됨)

# 깊은 복사: 모든 중첩된 객체까지 재귀적으로 새로 생성
original_deep = [[1, 2], [3, 4]]
deep_copy = copy.deepcopy(original_deep)
original_deep[0][0] = 99
print(deep_copy)  # [[1, 2], [3, 4]] (완전히 독립적)
```

---

## 리스트 메서드 종합

리스트는 데이터를 관리하는 데 필요한 다양한 메서드를 제공합니다. 각 메서드의 시간 복잡성을 고려하여 효율적인 코드를 작성하는 것이 중요합니다.

| 메서드 | 설명 | 시간 복잡도 |
| :--- | :--- | :--- |
| `append(x)` | 리스트 끝에 요소 `x`를 추가 | 분할 상환 O(1) |
| `extend(iterable)` | 이터러블의 모든 요소를 리스트 끝에 추가 | O(k) (k: 이터러블 길이) |
| `insert(i, x)` | 인덱스 `i` 위치에 요소 `x`를 삽입 | O(n) |
| `remove(x)` | 값이 `x`와 같은 첫 번째 요소를 제거 | O(n) |
| `pop([i])` | 인덱스 `i`의 요소를 제거하고 반환 (기본값: 마지막) | 끝: O(1), 중간: O(n) |
| `clear()` | 리스트의 모든 요소를 제거 | O(n) |
| `index(x[, start[, end]])` | 값이 `x`인 첫 번째 요소의 인덱스를 반환 | O(n) |
| `count(x)` | 값이 `x`인 요소의 개수를 반환 | O(n) |
| `sort(key=None, reverse=False)` | 리스트를 제자리에서 정렬 | O(n log n) |
| `reverse()` | 리스트 요소의 순서를 제자리에서 역순으로 바꿈 | O(n) |
| `copy()` | 리스트의 얕은 복사본을 반환 | O(n) |

```python
# 메서드 사용 예시
data = [5, 2, 8, 2, 1]
data.append(9)           # [5, 2, 8, 2, 1, 9]
data.insert(1, 0)        # [5, 0, 2, 8, 2, 1, 9]
data.remove(2)           # [5, 0, 8, 2, 1, 9] (첫 번째 2 제거)
popped = data.pop(3)     # popped = 2, data는 [5, 0, 8, 1, 9]
idx = data.index(8)      # idx = 2
cnt = data.count(5)      # cnt = 1
data.sort()              # [0, 1, 5, 8, 9]
data.reverse()           # [9, 8, 5, 1, 0]
```

---

## 리스트 정렬

파이썬의 정렬 알고리즘인 **Timsort**는 안정 정렬(Stable Sort)이며 효율적입니다. `sort()` 메서드는 리스트 자체를 변경하고, `sorted()` 내장 함수는 정렬된 새 리스트를 반환합니다.

```python
# 기본 정렬 (오름차순)
numbers = [3, 1, 4, 1, 5]
numbers.sort()
print(numbers)  # [1, 1, 3, 4, 5]

# 내림차순 정렬
numbers.sort(reverse=True)
print(numbers)  # [5, 4, 3, 1, 1]

# key 함수를 이용한 정렬: 문자열 길이 기준
words = ['banana', 'pie', 'apple', 'kiwi']
words.sort(key=len)
print(words)  # ['pie', 'kiwi', 'apple', 'banana']

# 다중 기준 정렬: 나이 내림차순, 이름 오름차순
people = [('Alice', 30), ('Bob', 25), ('Charlie', 30)]
people.sort(key=lambda x: (-x[1], x[0]))
print(people)  # [('Alice', 30), ('Charlie', 30), ('Bob', 25)]
```

---

## 리스트 내포(List Comprehension)

리스트 내포는 기존 시퀀스를 변환하거나 필터링하여 새로운 리스트를 생성하는 간결하고 가독성 높은 구문입니다. `for` 루프와 `if` 조건을 조합할 수 있습니다.

```python
# 0부터 9까지의 제곱 리스트
squares = [x**2 for x in range(10)]
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 조건 필터링: 짝수만 선택
evens = [x for x in range(10) if x % 2 == 0]
# [0, 2, 4, 6, 8]

# 중첩 루프: 모든 조합 생성
pairs = [(x, y) for x in [1, 2] for y in ['a', 'b']]
# [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]

# 조건부 표현식 사용
labels = ['짝수' if x % 2 == 0 else '홀수' for x in range(5)]
# ['짝수', '홀수', '짝수', '홀수', '짝수']
```

> **성능 고려사항**: 리스트 내포는 일반 `for` 루프보다 빠른 경우가 많지만, 매우 큰 데이터셋을 다룰 때는 모든 결과를 한 번에 메모리에 저장합니다. 제너레이터 표현식(`(x for x in iterable)`)은 지연 평가(Lazy Evaluation)를 통해 메모리 사용을 최적화할 수 있습니다.

---

## 유용한 순회 및 변환 패턴

리스트와 함께 자주 사용되는 파이썬의 내장 함수와 관용구입니다.

```python
# 인덱스와 값을 함께 얻기: enumerate
fruits = ['apple', 'banana', 'cherry']
for index, fruit in enumerate(fruits, start=1):
    print(f"{index}: {fruit}")

# 여러 리스트를 병렬로 순회하기: zip
names = ['Alice', 'Bob', 'Charlie']
scores = [85, 92, 78]
for name, score in zip(names, scores):
    print(f"{name}의 점수는 {score}점입니다.")

# 시퀀스 언패킹(Unpacking)
first, *middle, last = [10, 20, 30, 40, 50]
print(first)   # 10
print(middle)  # [20, 30, 40]
print(last)    # 50
```

---

## 리스트와 다른 자료구조

데이터의 특성과 연산에 따라 리스트 대신 다른 자료구조를 고려해야 할 수 있습니다.

- **`tuple`**: 불변(Immutable) 시퀀스. 딕셔너리의 키나 집합의 요소로 사용 가능합니다.
- **`collections.deque`**: 양방향 큐. 리스트보다 양 끝에서의 삽입/삭제가 빠릅니다(`O(1)`).
- **`array.array`**: 동일한 기본 자료형(C 타입)의 데이터를 효율적으로 저장합니다(메모리/성능 최적화).
- **`numpy.ndarray`**: 대규모 수치 데이터 배열과 고성능 연산에 사용됩니다.
- **`heapq` 모듈**: 리스트를 힙(Heap)으로 사용하여 우선순위 큐를 구현합니다.

---

## 실전 프로그래밍 패턴과 주의사항

### 1. 가변 기본 인자 함정
함수 정의에서 기본 인자로 빈 리스트 `[]`를 사용하면, 이 리스트는 함수가 정의될 때 한 번만 생성되고 이후 모든 호출에서 **동일한 객체**가 공유됩니다.

```python
def add_to_log(message, log=[]):  # 위험한 방식
    log.append(message)
    return log

print(add_to_log("첫 번째"))  # ['첫 번째']
print(add_to_log("두 번째"))  # ['첫 번째', '두 번째'] (의도치 않은 누적)

# 안전한 방식: None을 기본값으로 설정하고 함수 내에서 새 리스트 생성
def add_to_log_safe(message, log=None):
    if log is None:
        log = []
    log.append(message)
    return log
```

### 2. 효율적인 데이터 처리
- **문자열 조합**: 많은 문자열을 결합할 때는 리스트에 `append()` 후 `str.join()`을 사용하는 것이 `+` 연산 반복보다 훨씬 효율적입니다.
- **`bisect` 모듈 활용**: 정렬된 리스트에서 이진 탐색을 통해 삽입 위치를 찾거나 요소를 삽입할 수 있습니다(`O(log n)`).
- **`collections.Counter`**: 리스트 내 요소의 빈도수를 쉽게 계산할 수 있습니다.

### 3. 데이터 변환과 정제

```python
# 평탄화(Flatten): 2차원 리스트를 1차원으로
nested = [[1, 2], [3, 4, 5], [6]]
flat = [item for sublist in nested for item in sublist]  # [1, 2, 3, 4, 5, 6]

# 조건에 맞는 요소만 선택하며 변환
numbers = [1, 2, 3, 4, 5, 6]
doubled_evens = [x*2 for x in numbers if x % 2 == 0]  # [4, 8, 12]

# 순서를 유지하며 중복 제거
def remove_duplicates_preserve_order(seq):
    seen = set()
    return [x for x in seq if not (x in seen or seen.add(x))]
```

---

## 마무리

파이썬 리스트는 그 유연성과 풍부한 기능으로 데이터 처리의 핵심 도구입니다. 슬라이싱, 내포, 다양한 메서드를 조합하면 복잡한 데이터 변환 작업도 간결하게 표현할 수 있습니다. 그러나 가변성으로 인한 참조 공유 문제, 중첩 리스트 초기화 함정, 가변 기본 인자 등의 주의사항을 이해하는 것이 중요합니다.

대규모 데이터나 특정 연산(양 끝 삽입/삭제, 우선순위 큐, 이진 탐색)이 필요할 때는 `deque`, `heapq`, `bisect` 같은 표준 라이브러리 모듈을 함께 사용하는 것이 효과적입니다. 리스트의 기본기를 탄탄히 다지는 것은 파이썬으로 데이터를 자유자재로 다루는 첫걸음이 될 것입니다.