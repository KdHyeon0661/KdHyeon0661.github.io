---
layout: post
title: 컴퓨터시스템 - I/O 재지정
date: 2025-09-05 18:20:23 +0900
category: 컴퓨터시스템
---
# I/O 재지정(REDIRECTION) — 셸과 커널 관점의 완전 가이드

> 목표: **표준 입출력/에러 스트림**을 **파일·파이프·다른 FD**로 바꾸는 법을  
> 셸 문법(`>`, `2>`, `|`, `<<`, `<<<`, `n>&m`…)과 **시스템콜(dup2, exec)** 두 층위에서 정확히 이해하기.

---

## 0) 큰 그림

- 유닉스 프로세스는 시작 시 보통 다음 **파일 디스크립터(FD)** 3개를 갖습니다.
  - `0`: **표준 입력**(stdin)  
  - `1`: **표준 출력**(stdout)  
  - `2`: **표준 오류**(stderr)
- **I/O 재지정**은 셸이 **자식 프로세스**를 실행하기 **직전**, 해당 FD들을 **파일/파이프/소켓/다른 FD**로 **연결(dup)** 해주는 작업입니다.
- 파이프라인(`|`)은 **한 프로세스의 stdout → 다음 프로세스의 stdin**으로 연결하는 특수한 재지정입니다.

---

## 1) 셸 리다이렉션 연산자 요약( Bash/Zsh 기준 )

| 문법 | 의미 | 비고 |
|---|---|---|
| `cmd > file` | stdout을 `file`로 **덮어쓰기** | `O_TRUNC` 효과 |
| `cmd >> file` | stdout을 `file`로 **추가(append)** | 로그에 흔함 |
| `cmd < file` | stdin을 `file`에서 읽기 |  |
| `cmd 2> err.log` | **stderr**만 파일로 | `1>`은 stdout |
| `cmd > out 2> err` | stdout/ stderr를 **서로 다른** 파일로 |  |
| `cmd > all 2>&1` | stderr을 **stdout이 가리키는 곳**으로 **합치기** | 순서 중요(§4) |
| `cmd &> all` | Bash 약식: stdout+stderr 합치기 | `> all 2>&1`과 유사 |
| `n>file`, `n<file` | **임의 FD `n`** 리다이렉션 | 예: `3>tmp` |
| `n>&m` | FD **n을 m로 복제(dup)** | 예: `2>&1` |
| `n>&-` | **FD 닫기** | 예: `exec 3>&-` |
| `cmd1 \| cmd2` | 파이프: `cmd1`의 stdout → `cmd2`의 stdin |  |
| `cmd <<< "text"` | **Here-string**: `"text"`를 stdin으로 | Bash 확장 |
| `cmd <<EOF … EOF` | **Here-doc**: 인라인 블록을 stdin으로 | `<<-`는 탭 제거 |
| `>(cmd)` / `<(cmd)` | **프로세스 치환**: 파이프/Named FIFO로 간접 연결 | Bash/Zsh |

> POSIX 셸에선 `&>`/`<<<`/`<( )`는 미표준입니다(Bash/Zsh/Ksh에서만).

---

## 2) 표준 예제

### 2.1 출력/에러 분리·합치기
```bash
# stdout은 out.log로, stderr는 err.log로
prog >out.log 2>err.log

# stdout과 stderr를 같은 파일로(순서 중요!)
prog >all.log 2>&1
# 또는 (bash)
prog &> all.log
```

### 2.2 입력 재지정
```bash
# 키보드 대신 파일에서 입력
sort < names.txt
```

### 2.3 파이프·라인
```bash
# prog 출력 → grep → wc
prog | grep 'ERROR' | wc -l
```

### 2.4 Here-doc / Here-string
```bash
# Here-doc
cat <<'EOF' > script.sh
#!/usr/bin/env bash
echo "hello"
EOF
chmod +x script.sh

# Here-string(Bash)
grep foo <<< "one two foo three"
```

### 2.5 임의 FD 사용(고급)
```bash
# FD 3으로 파일 열고, 명령어 안에서 사용
exec 3> log.txt      # 셸 자체의 FD 3을 log.txt에 연결
echo "hi" >&3        # FD 3으로 쓰기
exec 3>&-            # 닫기

# FD 이동: stderr(2)를 stdout(1)이 가리키는 곳으로
exec 2>&1
```

---

## 3) 파이프라인과 오류 전파

- 파이프라인에서 기본 종료 상태는 **마지막 명령어의 종료 코드**입니다.
- Bash의 `set -o pipefail`을 켜면 **파이프라인 내 어느 명령이라도 실패하면** 그 실패 코드가 전파됩니다.
```bash
set -o pipefail
cmd1 | cmd2 | cmd3
echo $?   # 셋 중 실패 코드
```

---

## 4) **리다이렉션 순서**는 결과를 바꾼다 (중요)

```bash
# (A) stderr을 stdout이 향하는 곳으로 합치기
cmd > all.log 2>&1   # OK: 먼저 stdout을 all.log로, 이후 stderr을 "새로운" stdout에 연결

# (B) 순서 반대로: 의도와 다르게 동작할 수 있음
cmd 2>&1 > all.log   # 먼저 stderr=stdout(터미널), 그 다음 stdout만 all.log로 → stderr는 여전히 터미널로
```

**규칙**: `2>&1`은 **그 시점의 stdout**을 복제합니다.  
원하는 결과는 보통 **`>file 2>&1`** 순서입니다.

---

## 5) 안전한 덮어쓰기 방지( noclobber )

```bash
set -o noclobber      # 기존 파일 덮어쓰기 금지
cmd > file            # 파일이 있으면 실패
cmd >| file           # 강제로 덮어쓰기(override)
```

---

## 6) 특수 파일과 리다이렉션

- `/dev/null` : 블랙홀(쓰기 버림/읽기 EOF)  
  ```bash
  cmd > /dev/null 2>&1
  ```
- `/dev/stdin`, `/dev/stdout`, `/dev/stderr` : 각 표준 스트림의 가상 파일  
- `/dev/fd/N` : 현재 프로세스의 FD `N`을 경로로 노출

---

## 7) **프로세스 치환**(Process Substitution) — 파이프의 일반화 (Bash/Zsh)

```bash
# diff 두 명령의 출력을 파일처럼 비교
diff <(sort a.txt) <(sort b.txt)

# >(cmd): stdout을 cmd의 stdin으로 보냄
tar cz src | tee >(gpg --symmetric > src.tar.gz.gpg) > src.tar.gz
```

- 구현은 대개 **named pipe** 또는 `/proc/self/fd` 링크로 이루어집니다.

---

## 8) 프로그램 내부(C)에서의 리다이렉션

### 8.1 `dup2`로 stdout/stderr 리다이렉션
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main(void) {
    int fd = open("out.log", O_WRONLY|O_CREAT|O_TRUNC, 0644);
    if (fd < 0) { perror("open"); return 1; }

    if (dup2(fd, STDOUT_FILENO) < 0) { perror("dup2"); return 1; } // stdout → out.log
    if (dup2(fd, STDERR_FILENO) < 0) { perror("dup2"); return 1; } // stderr → out.log
    close(fd); // FD 중복 이후 원본 닫기(중요)

    printf("hello stdout\n");
    fprintf(stderr, "hello stderr\n");
    return 0;
}
```

### 8.2 `exec` 전 리다이렉션(전형적 패턴)
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main(void){
    int fd = open("prog.out", O_WRONLY|O_CREAT|O_TRUNC, 0644);
    if (fd < 0) { perror("open"); return 1; }
    if (dup2(fd, STDOUT_FILENO) < 0) { perror("dup2"); return 1; }
    close(fd);
    execlp("prog", "prog", "arg1", NULL); // 자식 프로세스로 교체, stdout은 이미 파일로 연결됨
    perror("execlp");
    return 1;
}
```

### 8.3 `posix_spawn`로 파일 액션 지정
```c
#include <spawn.h>
#include <fcntl.h>
extern char **environ;

int run_redirected(void){
    posix_spawn_file_actions_t fa;
    posix_spawn_file_actions_init(&fa);

    int fd = open("log.txt", O_WRONLY|O_CREAT|O_TRUNC, 0644);
    posix_spawn_file_actions_adddup2(&fa, fd, STDOUT_FILENO);
    posix_spawn_file_actions_adddup2(&fa, fd, STDERR_FILENO);
    posix_spawn_file_actions_addclose(&fa, fd);

    pid_t pid;
    int rc = posix_spawnp(&pid, "prog", &fa, NULL, (char*[]){"prog", NULL}, environ);
    posix_spawn_file_actions_destroy(&fa);
    return rc;
}
```

> **원리**: 리다이렉션은 결국 **`dup/dup2/dup3`** 로 FD 그래프를 바꾼 뒤, `execve`로 새 프로그램을 실행하는 것입니다.

---

## 9) FD 레벨 트릭

```bash
# n번 FD를 파일에 연결
exec 5> trace.log
# 명령 일부만 FD 5로 출력
echo "phase1" >&5

# FD를 서로 바꾸기(스왑)
exec 3>&1 1>&2 2>&3 3>&-
# 이제 stdout↔stderr가 뒤바뀜

# 특정 명령에서만 stderr 닫기
somecmd 2>&-
```

---

## 10) `tee`로 출력 분기

```bash
# 화면에 보이면서 파일에 저장
prog | tee out.log

# stderr까지 포함하려면
prog 2>&1 | tee all.log
```

- `tee -a` 로 append, `-p` 로 파이프 쓰기 오류를 stderr에 보고.

---

## 11) 보안·신뢰성 관점 팁

- **파일 덮어쓰기**: 민감 파일을 `>`로 덮어쓰기 전 `set -o noclobber` 고려, 또는 안전한 임시파일 → `rename` 패턴(데이터 영속성은 `fsync` 동반).
- **심볼릭 링크 레이스**: 스크립트 내부에서 외부 경로를 다룰 때 `mkstemp`/`openat` 기반 처리를 고려.
- **FD 유출 방지**: 서버/도구는 `O_CLOEXEC`로 **exec 시 FD 자동 닫힘** 보장.
- **파이프 실패 전파**: `set -o pipefail`로 조기 실패 감지.

---

## 12) 흔한 함정 체크리스트

- [ ] `2>&1` **순서**를 올바르게 썼는가? (`>file 2>&1`)  
- [ ] `readdir_r`처럼 **폐기된 인터페이스**를 쓰지 않는가? (리다이렉션과 직접 관련은 없지만 스크립트 내 흔한 함정)  
- [ ] `tee` 사용 시 **버퍼링 지연**에 주의했는가? (line-buffering 고려)  
- [ ] Here-doc에서 **인덴트 보정** 필요하면 `<<-`를 썼는가?  
- [ ] 비표준 기능( `&>`, `<<<`, `<( )` )의 **셸 의존성**을 문서화했는가?  

---

## 13) 요약

- 리다이렉션은 **FD 0/1/2를 다른 대상에 dup** 하는 것.  
- 셸 문법은 편의 제공일 뿐, 핵심은 **`dup2` + `exec`**.  
- **순서**, **파이프 실패 전파(pipefail)**, **덮어쓰기 안전(noclobber)**, **FD 관리(CLOEXEC)** 를 지키면  
  스크립트와 시스템 프로그래밍 모두에서 **예측 가능하고 견고한 I/O 흐름**을 만들 수 있습니다.