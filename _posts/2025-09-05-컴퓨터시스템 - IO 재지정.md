---
layout: post
title: 컴퓨터시스템 - I/O 재지정
date: 2025-09-05 18:20:23 +0900
category: 컴퓨터시스템
---
# I/O 재지정(REDIRECTION)

## 큰 그림 — “셸이 FD를 바꾼 뒤, 프로그램을 `exec`”

- 프로세스 시작 시 일반적으로 FD **0/1/2 = stdin/stdout/stderr** 가 열려 있다.
- 셸은 **자식 실행 직전**에:
  1) **파일·파이프·소켓** 등을 `open/pipe/socketpair`로 열고,
  2) **`dup2`/`dup3`** 로 **0/1/2**(또는 임의 FD)를 **그 대상**으로 갈아끼운 뒤,
  3) **`execve`** 로 프로그램을 교체한다.
- 파이프라인 `A | B`는 **A의 1번 FD → 파이프 쓰기단**, **B의 0번 FD ← 파이프 읽기단** 으로 연결하는 특수한 재지정.

```
         +--------------------+            +--------------------+
stdout 1 |        A           | ========>  |         B          | stdin 0
         +--------------------+   pipe     +--------------------+
```

---

## 셸 리다이렉션 표(Bash/Zsh 기준, POSIX 표준 여부 표기)

| 문법 | 의미 | 표준 |
|---|---|---|
| `cmd > file` | stdout을 `file`로 **덮어쓰기** (`O_TRUNC`) | 예 |
| `cmd >> file` | stdout을 `file`에 **추가(append)** (`O_APPEND`) | 예 |
| `cmd < file` | stdin을 `file`에서 읽기 | 예 |
| `cmd 2> err.log` | stderr만 파일로 | 예 |
| `cmd > out 2> err` | stdout/ stderr를 **서로 다른** 파일로 | 예 |
| `cmd > all 2>&1` | stderr을 **그 시점의 stdout** 목적지로 합치기 | 예 |
| `cmd &> all` | stdout+stderr를 한 파일로 (bash 축약) | 비표준 |
| `n>file`, `n<file` | **임의 FD `n`** 리다이렉션 | 예 |
| `n>&m`, `n<&m` | **FD 복제(dup)** — `n`을 `m`으로 | 예 |
| `n>&-`, `n<&-` | **FD 닫기** | 예 |
| `cmd1 \| cmd2` | 파이프: `cmd1` stdout → `cmd2` stdin | 예 |
| `cmd <<EOF ... EOF` | **Here-doc**: 블록을 stdin으로 공급 | 예 |
| `cmd <<-'EOF'` | 탭 인덴트 제거 Here-doc | 비표준 확장 |
| `cmd <<< "txt"` | **Here-string**: 한 줄 문자열을 stdin | 비표준 |
| `<(cmd)`, `>(cmd)` | **프로세스 치환**: 명령 결과를 파일처럼 | 비표준 |
| `exec >file 2>&1` | **셸 자체의** FD를 영속적으로 변경 | 예 |
| `exec {fd}>file` | **FD 변수를 할당**(bash 4+) | 비표준 |

> **주의**: Dash/BusyBox 등 **POSIX sh** 에서는 `&>`/`<<<`/`<( )`/`>( )`/`exec {fd}` 가 없다.

---

## 핵심 법칙 — “**`2>&1`은 그 **시점의** stdout을 복제한다**”

```bash
# OK: stderr을 "파일로 바뀐 stdout"에 합치기

cmd > all.log 2>&1

# NG: 순서 바꾸면 stderr는 여전히 터미널로 갈 수 있다

cmd 2>&1 > all.log
```

**규칙**: `2>&1` 의 의미는 “**2번 FD 를 지금 시점의 1번 FD로 dup**” 이다.
따라서 **항상 원하는 대상(파일/파이프)로 stdout을 먼저 바꾸고** stderr를 합쳐라.

---

## 표준 예제 (기본)

### 출력/오류 분리·합치기

```bash
# 분리

prog >out.log 2>err.log

# 합치기(순서 중요)

prog >all.log 2>&1
# 또는 (bash)

prog &> all.log
```

### 입력 재지정

```bash
sort < names.txt
```

### 파이프라인

```bash
prog | grep 'ERROR' | wc -l
```

### Here-doc / Here-string

```bash
# Here-doc: 따옴표로 감싸면 변수/치환을 "그대로" 유지

cat <<'EOF' > script.sh
#!/usr/bin/env bash

echo "$USER: literal, no expansion"
EOF
chmod +x script.sh

# Here-string (bash)

grep foo <<< "one two foo three"
```

---

## 고급 셸 패턴 — FD를 도구처럼 쓰기

### 임의 FD 열고 닫기

```bash
exec 3>log.txt          # 셸의 FD 3을 log.txt로
echo "hello" >&3
exec 3>&-               # 닫기
```

### stdout↔stderr 스왑

```bash
exec 3>&1 1>&2 2>&3 3>&-   # 이후 stdout은 기존 stderr로, stderr는 기존 stdout으로
```

### 셸 전체의 stdout/stderr를 파일로 (영역적용)

```bash
# 백업

exec 3>&1 4>&2
# 적용

exec > run.log 2>&1
# ... 많은 명령 ...
# 복원

exec 1>&3 2>&4
exec 3>&- 4>&-
```

### FD 변수(bash 4+)

```bash
exec {LOGFD}> run.log      # LOGFD에 사용된 번호가 저장됨
printf 'msg\n' >&$LOGFD
exec {LOGFD}>&-            # 닫기
```

### 프로세스 치환으로 분기 로깅

```bash
# stdout/stderr를 서로 다른 tee로 보낸 뒤, 원래 스트림 의미를 유지

cmd > >(tee out.log) 2> >(tee err.log >&2)
```

### `tee` 로 화면+파일 동시 출력

```bash
prog 2>&1 | tee all.log
# append

prog 2>&1 | tee -a all.log
```

---

## 파이프라인의 종료 코드와 `pipefail`

- 기본: **마지막 명령**의 종료 코드만 반영.
- `set -o pipefail` 켜면 **중간 실패도 전파**.

```bash
set -o pipefail
cmd1 | cmd2 | cmd3
echo $?  # 세 명령 중 첫 실패의 코드(또는 정책적 조합)
```

보조 옵션: bash `shopt -s lastpipe` (비대화 모드에서 마지막 파이프 명령을 현재 셸에서 실행) — 환경변수/FD 보존 등에 유용.

---

## 덮어쓰기 안전 — `noclobber` / `>|`

```bash
set -o noclobber   # 기존 파일 '>' 덮어쓰기 금지
cmd > file         # 있으면 실패
cmd >| file        # 강제 덮어쓰기 (FD 지정은 `2>| err.log` 등)
```

---

## 특수 경로와 리다이렉션

- `/dev/null` : 블랙홀(쓰기 버림/읽기 EOF)
  ```bash
  cmd > /dev/null 2>&1
  ```
- `/dev/stdin`, `/dev/stdout`, `/dev/stderr` : 표준 스트림
- `/dev/fd/N` : 현재 프로세스의 FD `N`에 대한 경로
- (bash 확장) `/dev/tcp/HOST/PORT`, `/dev/udp/...` : 간단한 네트워크 연결
  ```bash
  exec 3<>/dev/tcp/example.com/80
  printf 'GET / HTTP/1.0\r\n\r\n' >&3
  cat <&3
  exec 3>&-
  ```

---

## 버퍼링과 파이프 — `stdbuf` / `unbuffer`

파이프 뒤에 연결되면 많은 프로그램이 **블록 버퍼링**으로 전환되어 출력이 지연될 수 있다.

```bash
# 라인 버퍼링 강제 (GNU coreutils stdbuf)

stdbuf -oL -eL prog | tee out.log
```

또는 `python -u` (unbuffered) 등 프로그램 자체 옵션을 활용.

---

## C로 보는 리다이렉션 — `dup2/dup3`와 `exec`

### stdout/stderr을 파일로 돌리기

```c
// redirect_stdio.c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int fd = open("out.log", O_WRONLY|O_CREAT|O_TRUNC, 0644);
    if (fd < 0) { perror("open"); return 1; }

    if (dup2(fd, STDOUT_FILENO) < 0) { perror("dup2 stdout"); return 1; }
    if (dup2(fd, STDERR_FILENO) < 0) { perror("dup2 stderr"); return 1; }
    close(fd); // 중요: 중복 후 원본 닫기

    printf("hello stdout\n");
    fprintf(stderr, "hello stderr\n");
    return 0;
}
```

### `exec` 전 리다이렉션 패턴

```c
// exec_redirect.c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

int main(void){
    int fd = open("prog.out", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0644);
    if (fd < 0) { perror("open"); return 1; }

    if (dup2(fd, STDOUT_FILENO) < 0) { perror("dup2"); return 1; }
    // stderr은 그대로 두고 싶다면 생략
    close(fd); // CLOEXEC라도 중복했으면 닫아주는 게 깔끔

    execlp("prog", "prog", "arg1", (char*)NULL);
    perror("execlp");
    return 1;
}
```

### 파이프라인 `A | B` 직접 구현

```c
// pipeline.c : A의 stdout → B의 stdin
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>

int main(void){
    int p[2];
    if (pipe(p) < 0) { perror("pipe"); exit(1); }

    pid_t a = fork();
    if (a == 0) {
        // child A: stdout → p[1]
        close(p[0]);
        if (dup2(p[1], STDOUT_FILENO) < 0) { perror("dup2 A"); _exit(127); }
        close(p[1]);
        execlp("progA", "progA", (char*)NULL);
        perror("execlp A"); _exit(127);
    }

    pid_t b = fork();
    if (b == 0) {
        // child B: stdin ← p[0]
        close(p[1]);
        if (dup2(p[0], STDIN_FILENO) < 0) { perror("dup2 B"); _exit(127); }
        close(p[0]);
        execlp("progB", "progB", (char*)NULL);
        perror("execlp B"); _exit(127);
    }

    close(p[0]); close(p[1]);
    int st; waitpid(a, &st, 0); waitpid(b, &st, 0);
    return 0;
}
```

### `posix_spawn` 로 파일 액션 지정

```c
// spawn_redirect.c
#include <spawn.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

extern char **environ;

int main(void){
    posix_spawn_file_actions_t fa;
    posix_spawn_file_actions_init(&fa);

    int fd = open("log.txt", O_WRONLY|O_CREAT|O_TRUNC, 0644);
    if (fd < 0) { perror("open"); return 1; }

    posix_spawn_file_actions_adddup2(&fa, fd, STDOUT_FILENO);
    posix_spawn_file_actions_adddup2(&fa, fd, STDERR_FILENO);
    posix_spawn_file_actions_addclose(&fa, fd);

    pid_t pid;
    char *argv[] = {"prog", NULL};
    int rc = posix_spawnp(&pid, "prog", &fa, NULL, argv, environ);
    posix_spawn_file_actions_destroy(&fa);

    if (rc != 0) { errno = rc; perror("posix_spawnp"); return 1; }
    waitpid(pid, NULL, 0);
    return 0;
}
```

> **안전 팁**: FD 유출 방지를 위해 **`O_CLOEXEC` or `FD_CLOEXEC`** 를 적극 사용.
> 리다이렉션용으로 중복(`dup2`)한 FD는 **즉시 원본을 닫아** 불필요한 참조를 제거.

---

## Here-doc 디테일

- 구분자에 **작은따옴표**: 변수/명령 치환을 **무효화**.
- `<<-` : **탭**으로 들여쓴 구문을 자동 제거(스페이스는 제거 안 함).

```bash
cat <<-EOF > cfg
	# 탭으로만 들여쓰면 제거됨
	key=value
EOF
```

---

## 프로세스 치환 `<(cmd)`, `>(cmd)` (Bash/Zsh)

- `<(cmd)` : `cmd`의 **stdout** 을 **읽기 가능 경로**로 노출 → 보통 `/proc/self/fd/…` 또는 FIFO
- `>(cmd)` : 현재 stdout을 **cmd의 stdin** 으로 보냄

```bash
# 두 명령의 정렬 결과를 파일처럼 diff

diff <(sort a.txt) <(sort b.txt)

# 압축본을 만들며 동시에 암호화

tar cz src | tee >(gpg --symmetric > src.tar.gz.gpg) > src.tar.gz
```

---

## 코프로세스(bash) — 양방향 파이프

```bash
coproc BC { bc -ql; }
echo "2^10" >&"${BC[1]}"
read -r ans <&"${BC[0]}"
echo "ans = $ans"
# 종료

exec {BC[1]}>&- {BC[0]}<&-
```

---

## 보안·신뢰성 — 파일·경로 핸들링

리다이렉션 **대상 파일을 외부 입력으로 받는** 스크립트는 **경로 레이스(TOCTTOU)**, **심링크 공격** 위험.

- **임시 파일**: `mkstemp` 사용
- **안전 갱신**: 임시→`fsync`→`rename` (+ **부모 디렉터리 `fsync`**)
- **심링크 차단**: 가능하면 C/C++ 래퍼로 `openat(dfd, name, O_NOFOLLOW|O_CLOEXEC|O_CREAT|O_EXCL, 0600)` 사용

```c
// 안전한 새파일 생성 (요약)
int dfd = open("/safe", O_RDONLY|O_DIRECTORY|O_CLOEXEC);
int fd  = openat(dfd, "out", O_WRONLY|O_CREAT|O_EXCL|O_NOFOLLOW|O_CLOEXEC, 0600);
```

---

## 커널 관점의 I/O 재지정 fast path

- **`dup2(old, new)`**: `new`가 열려있으면 **먼저 닫고**, `old`를 **복제**하여 `new`에 연결.
- **`dup3(old, new, O_CLOEXEC)`**: 동일 + CLOEXEC 플래그.
- **`pipe()`**: 읽기/쓰기 FD 한 쌍 생성 → 셸은 각 자식(파이프 단계)에서 **필요 없는 쪽을 닫는다**(EPIPE/파이프 고아 방지).
- **`execve`**: `FD_CLOEXEC` 가 **설정되지 않은** FD는 **그대로 상속**.
  → 서버/도구는 **CLOEXEC 기본화**가 중요(불필요한 소켓/파일 유출 방지).

---

## 경쟁·원자성·PIPE_BUF

- **정규 파일**: `O_APPEND`는 **오프셋 갱신을 원자적으로** 보장(레코드 경계 보장은 별개).
  다중 작성자 로깅은 **한 레코드를 한 번의 `write`** 로 쓰는 패턴 권장.
- **파이프/FIFO**: `PIPE_BUF`(보통 4096) **이하의 쓰기**는 원자적 — 메시지 잘림 없음.
  그보다 크면 **분할**되어 인터리브될 수 있다.
- **SIGPIPE**: 파이프 **읽기측이 닫히면** 쓰는 쪽은 `SIGPIPE`(또는 `EPIPE`) — 스크립트에서는 보통 무시하지 않음.
  C에서는 적절히 처리(`signal(SIGPIPE, SIG_IGN)` 또는 `MSG_NOSIGNAL`/`SO_NOSIGPIPE`).

---

## 디버깅 — 실제로 무슨 FD가 열렸나

```bash
# 현재 쉘의 FD 나열

ls -l /proc/$$/fd

# 셸이 하는 일을 시스템콜 레벨로 보기

strace -f -e trace=desc,execve bash -c 'prog >out 2>&1 | wc -l'
```

---

## 견고한 스크립트 템플릿

```bash
#!/usr/bin/env bash

set -Eeuo pipefail
# -E: trap ERR in functions, -e: first error exits, -u: unset vars = error, pipefail: pipeline error propagate

# 로그로 표준 출력/오류 분기

exec 3> >(ts '[%Y-%m-%d %H:%M:%S]' >app.out) \
     4> >(ts '[%Y-%m-%d %H:%M:%S]' >app.err)
exec > >(tee /dev/fd/3) 2> >(tee /dev/fd/4 >&2)

cleanup() { exec 3>&- 4>&-; }
trap cleanup EXIT

echo "start"
# ...

echo "warn" >&2
```

> `ts` 는 moreutils 의 타임스탬프 필터 예시. 없으면 제거.

---

## 함수·블록 스코프 — 그룹 `{ ...; }` vs 서브셸 `( ... )`

- `{ ...; }` : **현재 셸**에서 실행 → **FD 변경이 유지**.
- `( ... )` : **하위 서브셸**에서 실행 → **FD/환경 변경이 부모에 영향 없음**.

```bash
{ exec 3>log; echo A >&3; }   # 3번 FD는 블록 내에서만 열리고, 블록 끝에도 열려있음(현재 셸이므로 닫지 않으면 누수)
( exec 3>log; echo B >&3 )    # 서브셸 끝나면 3번 FD 자동 닫힘
```

---

## 이름있는 파이프(FIFO)와 리다이렉션

```bash
mkfifo /tmp/q
# 생산자

{ echo 1; echo 2; } > /tmp/q &
# 소비자

while read -r line; do echo "got: $line"; done < /tmp/q
rm /tmp/q
```

FIFO는 **프로세스 간 결합을 느슨하게** 하면서 셸 리다이렉션 문법을 쓸 수 있다.

---

## 내구성 요약 — 리다이렉션은 “경로”일 뿐, 데이터 안전은 별도

- `> file` 은 **열기+트렁케이트**일 뿐 **디스크 내구성 보장 X**.
- 내구성이 필요하면 **임시→`fsync`→`rename` + 부모 디렉터리 `fsync`** 패턴 사용(파일시스템/저널 정책 고려).

---

## 체크리스트

- [ ] `2>&1` **순서** 올바른가? (`>file 2>&1`)
- [ ] 파이프라인 실패 전파가 필요한가? → `set -o pipefail`
- [ ] 출력 지연 문제? → `stdbuf -oL -eL` 또는 프로그램 옵션
- [ ] 민감 파일 덮어쓰기 방지? → `set -o noclobber` / `>|` 명시
- [ ] 외부 경로를 대상으로 로그/결과 쓰기? → **임시+`fsync`+`rename`**
- [ ] FD 유출 방지? → `O_CLOEXEC` / `FD_CLOEXEC`
- [ ] POSIX 호환 필요? → 비표준(`&>`, `<<<`, `<( )`, `>( )`, `exec {fd}`) 회피

---

## 한 줄 결론

리다이렉션은 **셸이 `dup2` 로 FD 그래프를 바꾸고 `exec` 로 프로그램을 교체**하는 단순한 기계다.
그러나 **순서 의존성**, **파이프 실패 전파**, **버퍼링**, **FD 유출/내구성/보안**까지 챙겨야 **예측 가능하고 견고한 I/O**가 된다.
이 문서의 **패턴/코드 스니펫/체크리스트**를 그대로 적용하면, 스크립트와 시스템 프로그래밍 모두에서 **실전 품질**을 확보할 수 있다.
