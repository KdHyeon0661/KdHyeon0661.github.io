---
layout: post
title: 소켓프로그래밍 - 논블로킹 I/O와 멀티플렉싱
date: 2025-09-14 23:25:23 +0900
category: 소켓프로그래밍
---
# 논블로킹 I/O와 멀티플렉싱 — `select/poll`부터 상태 머신, 미니 에코 서버까지

## 1. 왜 논블로킹 I/O인가? — 문제의 배경

### 1.1 단순 블로킹 서버의 세계

가장 단순한 에코 서버는 다음과 같이 작성할 수 있다.

```cpp
// blocking_echo.cpp (개념용, 예외처리/에러체크 축약)
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstring>
#include <iostream>

int main() {
    int lfd = ::socket(AF_INET, SOCK_STREAM, 0);

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    addr.sin_port = htons(9000);

    int yes = 1;
    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
    ::bind(lfd, (sockaddr*)&addr, sizeof(addr));
    ::listen(lfd, 128);

    for (;;) {
        sockaddr_in cli{}; socklen_t len = sizeof(cli);
        int cfd = ::accept(lfd, (sockaddr*)&cli, &len);   // 블로킹

        char buf[4096];
        for (;;) {
            ssize_t n = ::recv(cfd, buf, sizeof(buf), 0); // 블로킹
            if (n > 0) {
                ::send(cfd, buf, n, 0);                   // 블로킹
            } else if (n == 0) {
                break; // 연결 종료
            } else {
                break; // 에러 등
            }
        }
        ::close(cfd);
    }
}
```

특징:

- `accept`, `recv`, `send` 모두 **블로킹**이다.
- 한 클라이언트가 데이터를 늦게 보내거나, `send` 쪽에서 막히면:
  - 이 루프는 그 클라이언트에 **붙잡혀** 버리고,  
    다른 클라이언트는 기다려야 한다.
- 해결책:
  - **각 연결당 스레드 1개** 를 쓰거나,
  - `fork` / 프로세스를 쓴다.

둘 다 **소규모**(수십~수백 연결)에서는 충분히 쓸 수 있지만:

- 스레드/프로세스 수가 커지면 **컨텍스트 스위치 오버헤드**,
- **메모리**(스택) 사용량 증가,
- 동기화 비용 증가 등이 치명적이 된다.

### 1.2 동시 접속이 많아졌을 때의 병목들

1. **헤드 오브 라인(Head-of-line) 블로킹**  
   - 하나의 연결에서 `recv` 가 블로킹된 상태면,  
     **같은 스레드에서** 처리해야 할 다른 연결이 모두 대기한다.

2. **스레드 폭발(Thread explosion)**  
   - “연결 하나당 스레드 하나” 모델에서  
     10,000 연결이면 이론상 10,000 스레드가 필요하다.
   - 현대 OS가 컨텍스트 스위칭을 최적화했어도,  
     이런 규모에서 성능은 급격히 악화된다.

3. **타임아웃/백프레셔 설계의 어려움**  
   - 블로킹 모델에서는  
     “어느 연결에서 얼마나 오래 기다리는지”  
     세밀한 제어를 하기가 힘들다.

> 결론: **많은 연결을 동시에 관리**해야 하는 서버에서는  
> **논블로킹 + 멀티플렉싱** 모델이 필수적인 기법이다.

---

## 2. 블로킹 vs 논블로킹 — 시스템 콜 수준에서 보기

### 2.1 소켓의 블로킹 모드

- 모든 새 소켓은 **기본적으로 블로킹**이다.
- 블로킹 모드에서:
  - `accept`: 새로운 연결이 없으면 **대기**.
  - `connect`: 연결이 완료될 때까지(또는 오류/타임아웃) **대기**.
  - `recv`: 읽을 데이터가 오지 않았으면 **대기**.
  - `send`: 커널 송신 버퍼에 공간이 없으면 **대기**.

### 2.2 논블로킹 모드로 전환

논블로킹 모드에서는 “지금 할 수 없으면” **즉시** 반환하고,
`errno` 를 `EAGAIN`(혹은 `EWOULDBLOCK`)으로 설정한다.

```cpp
#include <fcntl.h>
#include <system_error>

int set_nonblock(int fd) {
    int flags = ::fcntl(fd, F_GETFL, 0);
    if (flags == -1) return -1;
    if (::fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) return -1;
    return 0;
}
```

- 논블로킹 `recv`:
  - 받을 것이 없으면 `-1` 을 반환하고, `errno == EAGAIN`.
- 논블로킹 `send`:
  - 송신 버퍼가 꽉 차 있으면 `-1`, `errno == EAGAIN`.

즉:

> “**지금은** 할 수 없으니, 나중에 다시 시도하라”  
> → **언제** 다시 시도할지는 **이벤트 멀티플렉서**(select/poll/epoll 등)가 알려준다.

---

## 3. 준비상태(ready) 기반 멀티플렉싱의 개념

### 3.1 멀티플렉서의 역할 요약

추상적으로 보면, 멀티플렉서는 OS에게 이렇게 말하는 것이다.

> “이 fd 목록을 보고 있다가  
>  **읽을 수 있거나, 쓸 수 있거나, 에러가 났을 때**  
>  나를 깨워줘.”

표현을 좀 바꾸면:

```text
while (true) {
    ready_fds = wait_until_any_fd_is_ready(fd_set, events, timeout);
    for (fd in ready_fds) {
        // 준비된 fd만 작업 수행
    }
}
```

- 여기서 `wait_until_any_fd_is_ready` 에 해당하는 것이  
  `select`, `poll`, `epoll_wait`, `kqueue` 등이다.

### 3.2 Ready의 의미 (레벨 트리거 기준)

정확히는 다음과 같이 해석할 수 있다(레벨 트리거):

- **읽기 준비(POLLIN / read-ready)**  
  - `recv(fd, ...)` 를 호출하면
    - **블로킹 없이** 최소 1바이트 이상 읽을 수 있음을 보장.
- **쓰기 준비(POLLOUT / write-ready)**  
  - `send(fd, ...)` 를 호출하면
    - **블로킹 없이** 최소 1바이트 이상 쓸 수 있음을 보장.
- **에러(POLLERR 등)**  
  - 소켓 에러 상태. 에러 코드를 `getsockopt` 또는
    `recv/send` 결과로 확인 후 정리해야 한다.

레벨 트리거에서는:

> 조건이 **참인 동안 계속해서** 이벤트가 발생한다.  
> 예: “읽을 것이 남아 있는 동안 계속 POLLIN”.

이 때문에, 레벨 트리거에서는 **“드레인(drain)” 패턴**이 중요하다.

- 읽기:
  - `recv` 를 **더 이상 읽을 것이 없을 때(EAGAIN)** 까지 반복.
- 쓰기:
  - `send` 를 **더 이상 쓸 수 없을 때(EAGAIN)** 까지 반복.

---

## 4. `select` / `poll` — 인터페이스와 한계

### 4.1 `select`의 개념과 한계

`select`는 오래된(하지만 여전히 존재하는) API다.

```c
int select(int nfds,
           fd_set *readfds,
           fd_set *writefds,
           fd_set *exceptfds,
           struct timeval *timeout);
```

특징:

- fd 집합을 `fd_set` 비트마스크로 표현.
- `nfds` 이하의 fd 만 감시(FD_SETSIZE 제한, 보통 1024).
- 각 호출마다:
  - fd_set을 **복사해서** 커널에 전달,
  - 반환된 fd_set을 **전체 스캔** 해야 한다.

규모가 커질수록:

- **복사 비용 + 스캔 비용** 이 큰 부담이 된다.
- fd 수를 수천~수만으로 올리기 어렵다.

### 4.2 `poll` 의 인터페이스

`poll` 는 `select`의 여러 제약을 완화한 API다.

```c
struct pollfd {
    int   fd;        // 감시할 fd
    short events;    // 관심 이벤트 (입력: POLLIN | POLLOUT | ...)
    short revents;   // 실제 발생 이벤트 (출력)
};

int poll(struct pollfd fds[], nfds_t nfds, int timeout_ms);
```

특징:

- **가변 길이 배열**로 fd 를 표현.
- `FD_SETSIZE` 제한이 없다.
- 반환 후에는 `revents` 필드를 보고  
  준비된 fd 를 찾는다.

단점(한계):

- 여전히 **O(N)** 이다.
  - 매 호출마다 전체 배열을 커널에 전달.
  - 결과를 받을 때도 배열 전체를 스캔해야 한다.
- 수십~수백 개 수준까지는 충분히 쓸 만하지만,  
  수만 개 단위에서는 **epoll/kqueue** 등이 선호된다.

### 4.3 레벨 트리거 vs 엣지 트리거

- `select` / `poll` : **레벨 트리거**.
  - 상태가 “준비됨”인 동안 계속 이벤트.
- `epoll` / `kqueue` : 기본은 레벨이지만
  - **엣지 트리거(ET)** 옵션을 제공.
  - ET는 “상태 변화”가 있을 때만 이벤트를 준다.

이 글에서는:

- **레벨 트리거**(poll) 에 집중해서  
  개념을 **완전히 익힌 뒤**,
- 다음 단계에서 ET / epoll 로 확장하는 것을 목표로 한다.

---

## 5. 논블로킹 + 상태 머신 — 왜 필요한가?

### 5.1 부분 I/O와 “다음에 할 일 기억하기”

논블로킹 모드에서는 한 번의 `recv`, `send` 가:

- **부분만** 처리할 수 있고,
- **아무것도 처리하지 못한 채** `EAGAIN` 으로 돌아올 수 있다.

예:

```cpp
ssize_t n = ::send(fd, buf + offset, remaining, 0);
if (n > 0) {
    offset += n;
    remaining -= n;
} else if (n < 0 && errno == EAGAIN) {
    // 지금은 못 보냄 → 나중에 다시 시도
}
```

그래서 각 연결마다

- **현재 어떤 단계인지** (예: 길이 헤더 읽는 중 / 바디 읽는 중 / 쓰는 중),
- **버퍼를 어디까지 처리했는지** (offset, 남은 바이트 수)

를 기억해야 한다. 이게 곧 **상태 머신**(state machine) 이다.

### 5.2 길이-프리픽스 프레이밍 예

TCP는 **바이트 스트림**이다. 메시지 경계를 스스로 알 수 없다.

그래서 흔히 다음과 같은 **프레이밍 규칙**을 만든다.

- **헤더**: 4바이트, “메시지 길이” (network byte order, big-endian)
- **바디**: 길이만큼의 바이트

프로토콜 흐름:

1. 클라이언트 → 서버:
   - 4B 길이 + 데이터 N바이트
2. 서버:
   - 먼저 길이 4B를 모두 읽고(READ_LEN),
   - 그 길이만큼 바디를 읽고(READ_BODY),
   - 처리 후 응답을 준비(WRITE_BODY).

이를 상태 머신으로 표현하면:

```text
          +-----------+
          | READ_LEN  |
          +-----------+
                |
     4바이트 다 읽으면
                v
          +-----------+
          | READ_BODY |
          +-----------+
                |
    len 바이트 다 읽으면
                v
          +------------+
          | WRITE_BODY |
          +------------+
                |
   길이+바디 다 쓰면
                v
          (다시 READ_LEN)
```

각 단계마다:

- 소켓이 `POLLIN`/`POLLOUT` 준비가 될 때마다
- 가능한 만큼 `recv`/`send` 를 호출하고
- 상태/offset을 갱신한다.

---

## 6. `poll` 기반 논블로킹 서버 설계

이제 **전체 구조**를 다시 정리해 보자.

```text
                        +------------------------+
                        |   main event loop      |
                        |  (poll + 상태 머신)    |
                        +------------------------+
                           ^                 ^
                           |                 |
                    [listen fd]         [client fds ...]
                      POLLIN               POLLIN/POLLOUT
                        |                       |
                accept 가능한가?         각 연결마다
                                         - READ_LEN
                                         - READ_BODY
                                         - WRITE_BODY
```

### 6.1 설계 원칙 정리

1. **모든 소켓을 논블로킹**으로 설정  
   - listen fd, client fd 모두.

2. `pollfd` 배열에:
   - 첫 번째 항목: listen fd, `events = POLLIN`
   - 이후 항목: 각 클라이언트 fd, `events = POLLIN` (+ 필요 시 POLLOUT)

3. 루프 구조:

```cpp
for (;;) {
    poll(pfds, ...);

    // 1) listen fd 에서 POLLIN → 가능한 만큼 accept
    // 2) 각 client fd 에서
    //    - POLLIN: recv 드레인 + 상태 업데이트
    //    - POLLOUT: send 드레인 + 상태 업데이트
    //    - 에러/종료: fd 정리
}
```

4. 각 client fd 에 대해:

- `Conn` 구조체에
  - 상태(State),
  - 길이 헤더 진행률,
  - 바디 진행률,
  - 송신 버퍼(outgoing 데이터)를 보관.

5. 자원 공격 방지:

- 프레임 최대 길이 `CAP` 을 둔다.
- 너무 큰 길이가 오면 연결을 끊는다.

---

## 7. 전체 코드 1 — 보조 유틸리티/해결 함수

이제 실제 C++23 코드 전체를 보자.
(필요 최소한의 에러 체크/로그를 포함한다.)

### 7.1 유틸리티: 에러 코드, 논블로킹 설정, 주소 문자열 변환

```cpp
// poll_echo.cpp — poll + nonblocking + length-prefix echo (C++23)
// 빌드: g++ -std=c++23 -O2 -Wall poll_echo.cpp -o poll_echo
// 사용: ./poll_echo [bind_host] [port]
//   예) ./poll_echo :: 9000
//       ./poll_echo 0.0.0.0 9000

#include <array>
#include <cerrno>
#include <cstdint>
#include <cstring>
#include <expected>
#include <map>
#include <print>
#include <span>
#include <string>
#include <string_view>
#include <system_error>
#include <unordered_map>
#include <utility>
#include <vector>

#include <arpa/inet.h>
#include <fcntl.h>
#include <netdb.h>
#include <poll.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

static std::error_code last_errno() {
    return {errno, std::generic_category()};
}

static int set_nonblock(int fd) {
    int fl = ::fcntl(fd, F_GETFL, 0);
    if (fl == -1) return -1;
    if (::fcntl(fd, F_SETFL, fl | O_NONBLOCK) == -1) return -1;
    return 0;
}

struct addr_list {
    addrinfo* head{};
    ~addr_list() { if (head) ::freeaddrinfo(head); }
};

// host, service → addrinfo 목록
static std::expected<addr_list, std::error_code>
resolve(std::string_view host,
        std::string_view service,
        int family,
        int socktype,
        int flags)
{
    addrinfo hints{};
    hints.ai_family   = family;
    hints.ai_socktype = socktype;
    hints.ai_flags    = flags;

    addrinfo* res = nullptr;
    int rc = ::getaddrinfo(
        host.empty() ? nullptr : std::string(host).c_str(),
        std::string(service).c_str(),
        &hints,
        &res
    );
    if (rc != 0) {
        // getaddrinfo 자체 에러코드를 OS 에러코드로 단순 매핑
        return std::unexpected(std::make_error_code(std::errc::invalid_argument));
    }

    addr_list L;
    L.head = res;
    return L;
}

static std::string sa_to_string(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{};
    char serv[NI_MAXSERV]{};
    int rc = ::getnameinfo(sa, salen,
                           host, sizeof(host),
                           serv, sizeof(serv),
                           NI_NUMERICHOST | NI_NUMERICSERV);
    if (rc == 0) return std::string(host) + ":" + std::string(serv);
    return "(unknown)";
}
```

### 7.2 리슨 소켓 생성 함수

IPv4/IPv6를 모두 지원하는 `make_listen` 함수:

```cpp
static std::expected<int, std::error_code>
make_listen(std::string_view bind_host,
            std::string_view port,
            int backlog = 512)
{
    auto R = resolve(bind_host, port,
                     AF_UNSPEC, SOCK_STREAM,
                     AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV);
    if (!R) return std::unexpected(R.error());

    for (auto* ai = R->head; ai; ai = ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;

        int yes = 1;
        ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        if (ai->ai_family == AF_INET6) {
            int v6only = 0; // v4-mapped 허용
            ::setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
        }

        if (::bind(s, ai->ai_addr, ai->ai_addrlen) == 0 &&
            ::listen(s, backlog) == 0)
        {
            if (set_nonblock(s) != 0) {
                ::close(s);
                continue;
            }
            std::print("[listen] {}\n", sa_to_string(ai->ai_addr, ai->ai_addrlen));
            return s;
        }

        ::close(s);
    }

    return std::unexpected(std::make_error_code(std::errc::address_not_available));
}
```

---

## 8. 전체 코드 2 — per-connection 상태 머신 정의

이제 각 연결에 대한 상태를 정의한다.

### 8.1 연결 상태 구조체

```cpp
struct Conn {
    enum class State {
        READ_LEN,   // 길이 헤더(4B) 읽는 중
        READ_BODY,  // 본문 읽는 중
        WRITE_BODY  // 에코 응답 쓰는 중
    };

    State state = State::READ_LEN;

    // 길이 헤더용
    std::array<std::byte, 4> len_buf{};   // 4바이트 헤더 임시 저장
    std::size_t len_bytes_read = 0;       // len_buf 진행률
    uint32_t body_len = 0;                // host byte order

    // 바디/송신 버퍼
    std::vector<std::byte> in_body;
    std::size_t body_bytes_read = 0;

    std::vector<std::byte> out_buf;
    std::size_t out_bytes_sent = 0;

    std::string peer;

    explicit Conn(std::string p) : peer(std::move(p)) {}
};
```

여기서 중요한 점:

- 길이 헤더와 바디, 송신 버퍼를 모두 분리해서 관리.
- 이전 초안에서는 `static thread_local` 버퍼를 사용해서  
  여러 연결이 공유하게 되는 **버그 가능성**이 있었는데,  
  여기서는 **각 Conn 내부에만 버퍼를 둬서** 해결했다.

---

## 9. 전체 코드 3 — 메인 루프 (`poll` 사용)

이제 `main` 함수와 `poll` 루프를 작성한다.

### 9.1 메인 루프 뼈대

```cpp
int main(int argc, char** argv) {
    std::string bind_host = (argc > 1 ? argv[1] : "");
    std::string port      = (argc > 2 ? argv[2] : "9000");

    auto L = make_listen(bind_host, port);
    if (!L) {
        std::print(stderr, "listen failed: {}\n", L.error().message());
        return 1;
    }
    int lfd = *L;

    std::vector<pollfd> pfds;
    pfds.push_back(pollfd{.fd = lfd, .events = POLLIN, .revents = 0});

    std::unordered_map<int, Conn> conns;

    auto add_client = [&](int cfd, const sockaddr* sa, socklen_t slen) {
        set_nonblock(cfd);
        std::string p = sa_to_string(sa, slen);
        conns.emplace(cfd, Conn{p});
        pfds.push_back(pollfd{.fd = cfd, .events = POLLIN, .revents = 0});
        std::print("[accept] fd={} peer={}\n", cfd, p);
    };

    auto remove_fd = [&](int fd) {
        ::close(fd);
        conns.erase(fd);
        for (std::size_t i = 0; i < pfds.size(); ++i) {
            if (pfds[i].fd == fd) {
                pfds.erase(pfds.begin() + i);
                break;
            }
        }
    };

    auto want_writable = [&](int fd, bool on) {
        for (auto& p : pfds) {
            if (p.fd == fd) {
                if (on) p.events |= POLLOUT;
                else    p.events &= ~POLLOUT;
                break;
            }
        }
    };

    const std::size_t CAP = 1 << 20; // 최대 프레임 1MiB

    for (;;) {
        int rc = ::poll(pfds.data(), pfds.size(), /*timeout_ms*/ 10000);
        if (rc < 0) {
            if (errno == EINTR) continue;
            std::print(stderr, "poll: {}\n", std::strerror(errno));
            break;
        }
        if (rc == 0) {
            // 10초 동안 이벤트 없음 — 필요하면 여기서 타임아웃 관리
            continue;
        }

        // 결과 순회
        for (std::size_t i = 0; i < pfds.size(); ++i) {
            auto& p = pfds[i];
            if (p.revents == 0) continue;

            if (p.fd == lfd) {
                // 리슨 소켓 처리
                if (p.revents & POLLIN) {
                    for (;;) {
                        sockaddr_storage ss{};
                        socklen_t slen = sizeof(ss);
                        int cfd = ::accept(lfd, (sockaddr*)&ss, &slen);
                        if (cfd >= 0) {
                            add_client(cfd, (sockaddr*)&ss, slen);
                            continue;
                        }
                        if (errno == EAGAIN || errno == EWOULDBLOCK) break;
                        if (errno == EINTR) continue;
                        std::print(stderr, "accept: {}\n", std::strerror(errno));
                        break;
                    }
                }
                if (p.revents & (POLLERR | POLLHUP | POLLNVAL)) {
                    std::print(stderr, "[listen-err] revents={}\n", p.revents);
                }
                continue; // 다음 pollfd
            }

            int cfd = p.fd;
            bool closed = false;

            // 에러/종료 우선 처리
            if (p.revents & (POLLERR | POLLHUP | POLLNVAL)) {
                remove_fd(cfd);
                closed = true;
            }
            if (closed) continue;

            auto it = conns.find(cfd);
            if (it == conns.end()) continue;
            Conn& C = it->second;

            // 1) 읽기 처리
            if (p.revents & POLLIN) {
                bool again = true;
                while (again) {
                    again = false;

                    if (C.state == Conn::State::READ_LEN) {
                        // 길이 헤더 4B 읽기
                        std::size_t need = 4 - C.len_bytes_read;
                        std::byte* dst = C.len_buf.data() + C.len_bytes_read;

                        ssize_t n = ::recv(cfd, dst, need, 0);
                        if (n > 0) {
                            C.len_bytes_read += static_cast<std::size_t>(n);
                            if (C.len_bytes_read == 4) {
                                uint32_t be_len{};
                                std::memcpy(&be_len, C.len_buf.data(), 4);
                                C.body_len = ntohl(be_len);
                                if (C.body_len > CAP) {
                                    std::print(stderr, "[{}] frame too large: {}\n",
                                               C.peer, C.body_len);
                                    remove_fd(cfd);
                                    closed = true;
                                    break;
                                }
                                C.in_body.assign(C.body_len, std::byte{0});
                                C.body_bytes_read = 0;
                                C.state = Conn::State::READ_BODY;
                            } else {
                                // 아직 4B 미만 → 남은 데이터가 있을 수도 있으니 한번 더 시도
                                again = true;
                            }
                        } else if (n == 0) {
                            remove_fd(cfd);
                            closed = true;
                            break;
                        } else {
                            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                                // 아직 더 이상 없음
                            } else if (errno == EINTR) {
                                again = true;
                            } else {
                                std::print(stderr, "recv len [{}]: {}\n",
                                           C.peer, std::strerror(errno));
                                remove_fd(cfd);
                                closed = true;
                                break;
                            }
                        }
                    }

                    if (closed) break;

                    if (C.state == Conn::State::READ_BODY) {
                        std::size_t need = C.body_len - C.body_bytes_read;
                        std::byte* dst = C.in_body.data() + C.body_bytes_read;

                        ssize_t n = ::recv(cfd, dst, need, 0);
                        if (n > 0) {
                            C.body_bytes_read += static_cast<std::size_t>(n);
                            if (C.body_bytes_read == C.body_len) {
                                // 에코 응답 준비
                                C.out_buf.clear();
                                C.out_buf.reserve(4 + C.body_len);

                                uint32_t be = htonl(C.body_len);
                                std::array<std::byte, 4> hdr{};
                                std::memcpy(hdr.data(), &be, 4);

                                C.out_buf.insert(C.out_buf.end(),
                                                 hdr.begin(), hdr.end());
                                C.out_buf.insert(C.out_buf.end(),
                                                 C.in_body.begin(), C.in_body.end());

                                C.out_bytes_sent = 0;
                                C.state = Conn::State::WRITE_BODY;
                                want_writable(cfd, true); // POLLOUT 관심 on
                            } else {
                                // 아직 바디 남음 → 즉시 다시 시도해 볼 수 있음
                                again = true;
                            }
                        } else if (n == 0) {
                            remove_fd(cfd);
                            closed = true;
                            break;
                        } else {
                            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                                // 읽을 것 없음
                            } else if (errno == EINTR) {
                                again = true;
                            } else {
                                std::print(stderr, "recv body [{}]: {}\n",
                                           C.peer, std::strerror(errno));
                                remove_fd(cfd);
                                closed = true;
                                break;
                            }
                        }
                    } // READ_BODY
                } // while(again)
            } // POLLIN

            if (closed) continue;

            // 2) 쓰기 처리
            if (p.revents & POLLOUT) {
                if (C.state == Conn::State::WRITE_BODY) {
                    std::size_t remain = C.out_buf.size() - C.out_bytes_sent;
                    const std::byte* src =
                        C.out_buf.data() + C.out_bytes_sent;

                    ssize_t n = ::send(cfd, src, remain, 0);
                    if (n > 0) {
                        C.out_bytes_sent += static_cast<std::size_t>(n);
                        if (C.out_bytes_sent == C.out_buf.size()) {
                            // 한 프레임 전송 완료 → 다음 프레임 준비
                            C.in_body.clear();
                            C.out_buf.clear();
                            C.len_bytes_read = 0;
                            C.body_len = 0;
                            C.body_bytes_read = 0;
                            C.state = Conn::State::READ_LEN;
                            want_writable(cfd, false); // POLLOUT 해제
                        }
                    } else if (n == 0) {
                        // 진전 없음(드묾) → 다음 POLLOUT까지 대기
                    } else {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) {
                            // 다음 POLLOUT까지 대기
                        } else if (errno == EINTR) {
                            // 다시 시도 기회가 생길 수 있음
                        } else {
                            std::print(stderr, "send [{}]: {}\n",
                                       C.peer, std::strerror(errno));
                            remove_fd(cfd);
                        }
                    }
                } else {
                    // 쓸 게 없는데 POLLOUT가 켜져 있었음 → 안전하게 해제
                    want_writable(cfd, false);
                }
            } // POLLOUT

        } // for(pfds)
    } // for(;;)

    ::close(lfd);
    return 0;
}
```

---

## 10. 코드 해설 — 중요한 포인트 정리

### 10.1 리슨 소켓 처리

- `pfds[0]` 는 항상 리슨 fd.
- `p.revents & POLLIN` 이면:
  - `accept` 를 **EAGAIN 나올 때까지** 반복한다.
  - 레벨 트리거에서 “드레인” 패턴의 전형적인 예.

```cpp
for (;;) {
    int cfd = ::accept(lfd, ...);
    if (cfd >= 0) {
        add_client(...);
        continue;
    }
    if (errno == EAGAIN || errno == EWOULDBLOCK) break;
    if (errno == EINTR) continue;
    // 그 외 에러는 로그 후 break
}
```

### 10.2 클라이언트 소켓: 에러/종료 우선 처리

- `POLLERR`, `POLLHUP`, `POLLNVAL` 는  
  대부분 더 이상 쓸 수 없는 소켓이므로,  
  **곧바로 정리(remove_fd)** 한다.
- 그렇지 않으면 같은 fd 가 계속 `poll` 결과에 남아서  
  **busy loop** 를 일으킬 수 있다.

### 10.3 READ_LEN 상태

- 총 4바이트 길이 헤더를 `len_buf` 에 채운다.
- recv 후:

```cpp
C.len_bytes_read += n;
if (C.len_bytes_read == 4) {
    // 길이 완성 → 바디 준비
}
```

- 4바이트를 다 못 채웠다면:
  - 수신 버퍼에 더 데이터가 있을 수도 있으니 `again = true` 로  
    루프 한 번 더 돌면서 READ_LEN 을 이어서 시도.
  - `EAGAIN` 이 나왔다면, 그때는 루프를 빠져나와서  
    다음 `poll` 이 올 때까지 기다린다.

### 10.4 READ_BODY 상태

- `C.body_len` 만큼 `in_body` 를 채운다.
- `recv` 결과에 따라:

  - `n > 0`: 진행률 증가.  
    다 채웠다면 에코 응답 준비로 넘어간다.
  - `n == 0`: 상대가 종료 → 연결 정리.
  - `n < 0`:
    - `EAGAIN` → 데이터가 없음.
    - `EINTR` → 즉시 재시도 가능.
    - 기타 → 에러로 간주하고 정리.

### 10.5 WRITE_BODY 상태

- `C.out_buf` 전체(= 길이 4B + 바디)를
  - `C.out_bytes_sent` 오프셋부터
  - `send` 로 가능한 만큼 보낸다.

- 완료 조건:
  - `C.out_bytes_sent == C.out_buf.size()` 이면
    - 한 프레임 전송 완료,
    - 상태를 `READ_LEN` 으로 되돌리고,
    - `POLLOUT` 관심을 꺼준다.

### 10.6 백프레셔(Backpressure)와 POLLOUT 토글

- 송신 버퍼가 꽉 차서 `send` 가 `EAGAIN` 이 나왔다면:
  - POLLOUT 이벤트를 통해 **“다시 보낼 수 있을 때”** 알려달라고 요청한다.
- 이 코드에서는:
  - 에코를 준비하는 시점에 `want_writable(cfd, true)` 로 POLLOUT를 등록.
  - 전송을 모두 마친 시점에 `want_writable(cfd, false)` 로 POLLOUT를 해제.

> 레벨 트리거에서 POLLOUT 을 **계속 켜 두면**  
> “보낼 수 있는 상태인 동안 계속 깨어나게” 되므로  
> 불필요한 깨움을 만드는 안 좋은 패턴이다.  
> **필요할 때만 켜고, 다 보내면 즉시 끄는 것**이 중요하다.

---

## 11. 클라이언트 테스트 예시 코드

서버가 제대로 동작하는지 테스트하기 위해
간단한 길이-프리픽스 클라이언트를 만들어 보자.

```cpp
// echo_client.cpp — blocking client, length-prefix 프로토콜
// 빌드: g++ -std=c++23 -O2 echo_client.cpp -o echo_client

#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>

#include <cstring>
#include <iostream>
#include <string>
#include <vector>

int main(int argc, char** argv) {
    if (argc < 4) {
        std::cerr << "usage: " << argv[0]
                  << " <host> <port> <message>\n";
        return 1;
    }
    const char* host = argv[1];
    const char* port = argv[2];
    std::string msg  = argv[3];

    addrinfo hints{}, *res = nullptr;
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_ADDRCONFIG;
    if (::getaddrinfo(host, port, &hints, &res) != 0) {
        std::perror("getaddrinfo");
        return 1;
    }

    int s = -1;
    for (auto* ai = res; ai; ai = ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen) == 0) break;
        ::close(s); s = -1;
    }
    if (s < 0) {
        std::cerr << "connect failed\n";
        return 1;
    }
    ::freeaddrinfo(res);

    // 길이 헤더 + 바디 전송
    uint32_t len = msg.size();
    uint32_t be  = htonl(len);
    std::vector<char> buf(4 + len);
    std::memcpy(buf.data(), &be, 4);
    std::memcpy(buf.data() + 4, msg.data(), len);

    // sendall
    std::size_t sent = 0;
    while (sent < buf.size()) {
        ssize_t n = ::send(s, buf.data() + sent, buf.size() - sent, 0);
        if (n > 0) sent += static_cast<std::size_t>(n);
        else if (n < 0 && errno == EINTR) continue;
        else { std::perror("send"); ::close(s); return 1; }
    }

    // 응답: 길이 4B + 바디 읽기
    char hdr[4];
    std::size_t hdr_read = 0;
    while (hdr_read < 4) {
        ssize_t n = ::recv(s, hdr + hdr_read, 4 - hdr_read, 0);
        if (n > 0) hdr_read += static_cast<std::size_t>(n);
        else if (n == 0) { std::cerr << "server closed\n"; ::close(s); return 1; }
        else if (errno == EINTR) continue;
        else { std::perror("recv hdr"); ::close(s); return 1; }
    }
    uint32_t be_len{};
    std::memcpy(&be_len, hdr, 4);
    uint32_t resp_len = ntohl(be_len);

    std::vector<char> resp(resp_len);
    std::size_t resp_read = 0;
    while (resp_read < resp_len) {
        ssize_t n = ::recv(s, resp.data() + resp_read, resp_len - resp_read, 0);
        if (n > 0) resp_read += static_cast<std::size_t>(n);
        else if (n == 0) { std::cerr << "server closed\n"; ::close(s); return 1; }
        else if (errno == EINTR) continue;
        else { std::perror("recv body"); ::close(s); return 1; }
    }

    std::cout << "echo: " << std::string(resp.begin(), resp.end()) << "\n";
    ::close(s);
    return 0;
}
```

테스트 방법:

```bash
# 서버
./poll_echo :: 9000

# 클라이언트
./echo_client 127.0.0.1 9000 "hello, world"
./echo_client 127.0.0.1 9000 "$(python - << 'EOF'
print("a" * 100000)
EOF
)"
```

---

## 12. `poll` 루프에서 자주 나오는 함정과 대비책

1. **POLLIN인데 `recv` 가 EAGAIN**  
   - 이론상 드물지만, 경쟁 조건이나 다른 스레드/프로세스와의 상호작용으로  
     발생할 수 있다.
   - **정상 상황**으로 받아들여야 하며,  
     그 fd 에 대해서는 더 이상 읽지 않고 다음 이벤트를 기다리면 된다.

2. **POLLOUT을 항상 켜 두는 문제**  
   - 레벨 트리거에서 POLLOUT은 “보낼 수 있는 동안 계속 깨우기” 이므로,  
     쓸 데이터가 없는데도 POLLOUT 이 켜져 있으면 불필요한 깨어남이 많아진다.
   - 쓰기 큐에 데이터가 있을 때만 POLLOUT을 활성화하고,  
     큐를 비우면 **반드시 비활성화** 해야 한다.

3. **부분 쓰기를 무시하는 문제**  
   - `send` 는 한번에 전체를 보내지 못할 수 있다.
   - 항상 “얼마나 보냈는지”를 추적하고,  
     남은 바이트를 다음 POLLOUT 이벤트에서 처리해야 한다.

4. **에러 이벤트를 무시하는 문제**  
   - `POLLERR`, `POLLHUP`, `POLLNVAL` 을 무시하면  
     해당 fd가 계속 ready로 남아 busy loop를 유발한다.
   - 보이면 곧바로 **fd를 제거**하는 것이 안전하다.

5. **프레임 크기 제한 없어서 메모리 고갈**  
   - 악의적 클라이언트가 “매우 큰 길이”를 보내면  
     그 크기만큼 버퍼를 할당하게 되어 OOM 위험이 있다.
   - 반드시 **CAP(최대 프레임 크기)** 를 두어야 한다.

---

## 13. 레벨 트리거 사고방식 정리

레벨 트리거(예: poll)의 본질은 다음 한 줄로 요약된다.

> “조건이 **참인 동안** 계속 깨운다.”

이에 대응하는 패턴:

- **읽기**:
  - 해당 fd에 POLLIN 이벤트가 온다면
    - 수신 버퍼가 비울 때까지(= EAGAIN 나올 때까지)  
      `recv` 를 반복하는 **드레인(drain)** 패턴.
- **쓰기**:
  - 쓰기 큐에 데이터가 있고, fd에 POLLOUT 이벤트가 온다면
    - 송신 버퍼가 더 이상 받지 않을 때까지(= EAGAIN 나올 때까지)  
      `send` 를 반복하는 드레인 패턴.

그러나:

- 항상 “드레인” 을 끝까지 할 필요는 없다.
- 예: 큰 데이터를 나누어 보내면서 일정량만 전송하고  
  나머지는 다음 이벤트로 넘기는 전략도 가능하다.
- 중요한 건:
  - **부분 I/O가 기본값**이라는 것,
  - “다음에 어디까지 했는지”를 **상태/오프셋으로 기억**해야 한다는 것이다.

---

## 14. 확장 아이디어 — epoll, 타임아웃, 멀티스레딩

이 장의 목표는 **논블로킹 + poll + 상태 머신** 을  
“완전히 손에 익히는 것”이지만,  
실제 큰 서버에서는 더 나아가야 한다.

### 14.1 `poll` → `epoll` / `kqueue`

- 연결 수가 수천~수만 이상으로 많아지면:
  - `poll` 의 **O(N)** 특성이 부담이 된다.
- 리눅스:
  - **`epoll`** 을 사용해
    - fd 등록/해제는 드물게,
    - 이벤트 발생은 커널이 소량의 fd 목록만을 반환.
- BSD / macOS:
  - **`kqueue`** 를 사용.

API 형태는 다르지만, 핵심 사고방식은 동일하다.

> “준비된 fd 목록만 커널이 골라 준다”  
> → 그 fd 들에 대해 상태 머신을 돌린다.

### 14.2 타임아웃/슬로 클라이언트 처리

- 각 연결마다
  - “마지막으로 읽거나 쓴 시각”,
  - “최대 허용 유휴 시간”
을 저장해 두고,

- `poll` 의 타임아웃이 끝나고 돌아오는 시점에
  - “너무 오래 조용했던 연결”,
  - “지나치게 오래 데이터를 보내지 않는 연결” 을 끊는 정책을 적용할 수 있다.

구현 예:

- `Conn` 구조체에 `last_active` (std::chrono::steady_clock::time_point)를 추가.
- 각 `recv`/`send` 성공 시점에 갱신.
- `poll` 타임아웃이 끝난 후 루프 시작 지점에서
  - conns 를 순회하며 시간이 오래된 연결을 끊는다.

### 14.3 멀티스레딩과 이벤트 루프

- **단일 스레드** 이벤트 루프는 구조가 단순하다.
- CPU 코어가 많다면:
  - “**accept 전용 스레드** + **N개 worker 스레드(각각 이벤트 루프)”  
    혹은
  - “**N개 이벤트 루프**가 `SO_REUSEPORT` 로 같은 포트에 바인드”
- 하지만 이때도 각 이벤트 루프 내부는
  - 지금까지 설명한 **논블로킹 + 상태 머신** 패턴 그대로 유지된다.

---

## 15. 요약 체크리스트

마지막으로, 이 장에서 짚은 핵심을 다시 체크리스트로 정리한다.

- [ ] 블로킹 vs 논블로킹의 차이를  
      시스템 콜(`accept/recv/send`) 반환 패턴(EAGAIN 등) 관점에서 이해했다.
- [ ] `poll` 의 인터페이스와 레벨 트리거 의미를 이해했다.
- [ ] 각 연결을 상태 머신(READ_LEN → READ_BODY → WRITE_BODY → …) 으로 모델링했다.
- [ ] 길이-프리픽스 프레이밍의 필요성과 구현 방식을 이해했다.
- [ ] 논블로킹 소켓에서 부분 I/O를 처리하는 offset/진행률 관리 코드를 작성할 수 있다.
- [ ] POLLOUT 을 필요할 때만 켰다가, 큐를 비우면 끄는 패턴을 이해했다.
- [ ] CAP(최대 프레임 크기) 로 자원 공격을 방어하는 방법을 이해했다.
- [ ] `poll` 기반 에코 서버 전체 코드를 읽고, 수정/실험할 수 있다.
- [ ] 이 구조를 epoll/kqueue, 타임아웃, 멀티스레딩으로 자연스럽게 확장할 수 있다.

---

## 16. 마무리

논블로킹 멀티플렉싱은 처음 보면 복잡해 보이지만,  
핵심 개념은 의외로 단순하다.

> “준비된 것만 건드리고,  
>  준비되지 않았다면 즉시 돌아온다.  
>  그리고 상태를 기억한 채  
>  다음 기회를 기다린다.”

이 글에서 구현한 `poll` 기반 길이-프리픽스 에코 서버는  
그 핵심을 그대로 담은 **최소 단위 골격**이다.

여기에:

- 소켓 옵션 튜닝(`TCP_NODELAY`, 버퍼 크기, keepalive),
- 타임아웃 관리,
- TLS,
- 멀티 스레딩/프로세스

등을 하나씩 얹어 나가면,  
실전에서 쓰이는 서버의 구조를 직접 설계하고 구현할 수 있다.