---
layout: post
title: 소켓프로그래밍 - 논블로킹 I/O와 멀티플렉싱
date: 2025-09-14 23:25:23 +0900
category: 소켓프로그래밍
---
## 9. 논블로킹 I/O와 멀티플렉싱

> 목표: **블로킹 vs 논블로킹**의 차이를 정확히 이해하고, **준비상태(ready) 기반 멀티플렉싱**의 사고방식을 익힌다.  
> `select/poll`의 기본 개념·한계를 짚고, **상태 머신으로 연결 I/O를 모델링**하는 방법을 학습한 뒤,  
> 마지막에 **`poll` 기반 미니 에코 서버(레벨 트리거)** 를 C++23로 직접 구현한다.  

---

### 9.1 블로킹 vs 논블로킹 — 제약·장점

#### 9.1.1 블로킹(Blocking)
- `accept`, `connect`, `recv`, `send` 같은 시스템 콜이 **즉시 진행 가능하지 않으면** 호출 스레드가 **대기(블록)**.
- **장점**  
  - 코드가 간결하고 이해하기 쉽다(동기 제어 흐름).  
  - 작은 동시성(수~수십 연결)에서는 **개발 비용 대비 충분히 빠름**.  
- **제약/단점**  
  - 대량 동시 연결에서 **스레드 폭발** 혹은 **헤드-오브-라인(한 소켓 대기 때문에 전체 대기)** 발생.  
  - 타임아웃, 백프레셔 전파, 부분 입출력 처리 등 **정교한 제어가 어려움**.  

#### 9.1.2 논블로킹(Non-blocking)
- 소켓을 **논블로킹 모드**로 바꾸면, 지금 당장 수행 불가한 `accept/recv/send`는 **즉시 반환**하며 `EAGAIN`/`EWOULDBLOCK`을 준다.
- `select/poll/epoll/kqueue/io_uring` 등 **이벤트 멀티플렉서**가 “어떤 디스크립터에 **지금** 읽기/쓰기/에러 이벤트가 준비되었는지” 알려준다.
- **장점**  
  - **단일(혹은 소수) 스레드**로 **수천~수만 연결**도 처리 가능(커널과의 상호작용 최적화가 전제).  
  - **타임아웃/백프레셔**를 세밀하게 설계 가능.  
- **제약/단점**  
  - **상태 머신**/버퍼/경계조건 처리 등 **구현 복잡도↑**.  
  - 멀티플렉서 별 **정확한 의미**(레벨/엣지 트리거, 준비상태 의미) 이해 필요.  

> 직관: 블로킹은 “**한 소켓과 대화**”할 때 편하고, 논블로킹은 “**많은 소켓을 동시에 곁눈질**”할 때 강하다.

---

### 9.2 `select`/`poll`의 개념과 한계

#### 9.2.1 공통 아이디어 — **준비상태(Ready) 대기**
- 커널에 “**이들 fd에 읽기/쓰기/에러 이벤트가 준비되면 깨워줘**”를 등록 → 호출 스레드는 **대기**.  
- 깨우면, “**준비된 fd 집합**”만 스캔하여 **함수 호출(작업) 수행**.

#### 9.2.2 `select`
- fd 집합을 **비트마스크**로 주고받는다.  
- **한계**:  
  - **fd 최대값 제한(FD_SETSIZE)** (플랫폼별 기본 1024 등).  
  - 큰 fd 집합에서 매 호출마다 **전체 비트마스크 복사** 오버헤드.  
  - 준비된 fd를 얻기 위해 **전수 스캔** 필요.  
- 학습/호환성 용으로 의미는 있지만, **현대 리눅스**에선 `poll`/`epoll`이 실전 기본.

#### 9.2.3 `poll`
- **가변 길이 배열**(`struct pollfd[]`)에 `(fd, events)` 등록 → 반환 시 `revents`에 결과를 채워준다.
- **장점**: `select`의 FD_SETSIZE 한계 없음.  
- **한계**:  
  - **매번 배열 전체**를 커널로 넘겨주고, 되돌려받은 뒤 **전수 스캔**.  
  - 수천~수만 fd 수준에서 **O(N)** 비용이 눈에 띈다.  
- 더 큰 규모에선 `epoll`/`kqueue`가 선호되지만, **개념 학습과 작은 서버**에는 `poll`이 훌륭한 레벨-트리거 입문용.

#### 9.2.4 준비상태(Ready)의 의미 — **레벨 트리거(Level-triggered)**
- 레벨 트리거(기본): **조건이 참인 동안 계속 깨어남**.  
  - `POLLIN`: **읽을 것이 남아있는 동안** 계속 알려줌.  
  - `POLLOUT`: **보낼 수 있는 버퍼 여유가 있는 동안** 계속 알려줌.  
- 엣지 트리거(예: `epoll`의 ET): **상태 변화가 있을 때 한 번만** 알려줌 → 이후 **버퍼를 모두 비워내거나 채울 때까지** 읽기/쓰기 **드레인**이 중요.  
- 이 장은 **레벨 트리거**에 집중(ET는 다음 장에서 다루면 좋다).

---

### 9.3 상태 머신으로 연결 I/O를 모델링하기

#### 9.3.1 왜 상태 머신인가?
- 논블로킹에서는 한 번의 `recv/send`가 **부분 처리**만 하고 **EAGAIN**으로 돌아올 수 있다.  
- “**다음에 할 일**”을 기억해야 한다:
  - 예: `READ_LEN(4B)` → `READ_BODY(NB)` → `WRITE_ECHO(NB)` → `DONE`  
- 각 연결(fd)마다 **현재 상태**와 **진행률**을 저장하는 **구조체**를 둔다.

#### 9.3.2 최소 상태 머신(길이-프리픽스 프레이밍 예)
- 상태:
  - `READ_LEN`: 4바이트를 모을 때까지 반복 `recv`  
  - `READ_BODY`: `len`만큼 `recv`  
  - `WRITE_BODY`: 받은 것을 다시 `send`(부분 쓰기면 나머지 보관)  
- 이벤트 처리 순서(레벨 트리거):
  - `POLLIN`: **가능한 만큼** 읽고 진행률 갱신.  
  - `POLLOUT`(필요할 때만 등록): **가능한 만큼** 쓰고 진행률 갱신, 모두 썼으면 `POLLOUT` 관심 해제.  
- 에러/종료:
  - `POLLHUP`/`POLLERR`/`POLLNVAL` → 정리  
  - `recv==0` → 상대가 닫음 → 정리  
  - 프레이밍 중간 종료 → 프로토콜 오류로 정리  

---

### 9.4 실습: `poll` 기반 미니 에코 서버(레벨 트리거)

> 목표: **단일 스레드** + **논블로킹** + **레벨 트리거**로  
> IPv4/IPv6 리슨 → 다중 클라이언트를 처리하는 **길이-프리픽스(4B) 에코 서버** 구현.  
> C++23, 리눅스/POSIX 기준.

#### 9.4.1 설계 요소
- **논블로킹**: 리슨 소켓과 클라이언트 소켓에 `O_NONBLOCK` 설정.  
- **멀티플렉서**: `poll` 사용.  
- **접속 수락**: 리슨 fd에 `POLLIN`이 오면 **가능한 만큼** `accept` 반복.  
- **I/O 상태 머신**: per-connection 구조체에 `READ_LEN/READ_BODY/WRITE_BODY` 등 기록.  
- **버퍼**:  
  - 수신: `len`을 알기 전까지 임시 `hdr(4B)` 버퍼, 이후 `body` 버퍼.  
  - 송신: 에코할 데이터를 `out` 버퍼에 보관하고 `POLLOUT` 관심 등록.  
- **백프레셔**: `send`가 막히면(`EAGAIN`) → `POLLOUT`으로 다음 기회를 기다린다.  
- **정리**: 예외/종료 이벤트에서 fd를 닫고, `pollfd` 목록에서 제거.

#### 9.4.2 전체 코드

```cpp
// poll_echo.cpp — poll + nonblocking + length-prefix echo (C++23)
// 빌드: g++ -std=c++23 -O2 -Wall poll_echo.cpp -o poll_echo
// 사용: ./poll_echo [bind_host] [port]
//   예) ./poll_echo :: 9000   또는   ./poll_echo 0.0.0.0 9000

#include <array>
#include <cerrno>
#include <cstdint>
#include <cstring>
#include <expected>
#include <map>
#include <print>
#include <span>
#include <string>
#include <string_view>
#include <system_error>
#include <unordered_map>
#include <utility>
#include <vector>

#include <arpa/inet.h>
#include <fcntl.h>
#include <netdb.h>
#include <poll.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

static std::error_code last_errno() { return {errno, std::generic_category()}; }

static int set_nonblock(int fd) {
    int fl = ::fcntl(fd, F_GETFL, 0);
    if (fl == -1) return -1;
    return ::fcntl(fd, F_SETFL, fl | O_NONBLOCK);
}

struct unique_fd {
    int fd{-1};
    unique_fd() = default;
    explicit unique_fd(int f): fd(f) {}
    unique_fd(const unique_fd&) = delete;
    unique_fd& operator=(const unique_fd&) = delete;
    unique_fd(unique_fd&& o) noexcept : fd(std::exchange(o.fd, -1)) {}
    unique_fd& operator=(unique_fd&& o) noexcept {
        if (this != &o) { if (fd!=-1) ::close(fd); fd = std::exchange(o.fd, -1); }
        return *this;
    }
    ~unique_fd(){ if (fd!=-1) ::close(fd); }
    int get() const noexcept { return fd; }
    explicit operator bool() const noexcept { return fd!=-1; }
    int release() noexcept { int t=fd; fd=-1; return t; }
};

struct addr_list {
    addrinfo* head{};
    ~addr_list(){ if (head) ::freeaddrinfo(head); }
};

static std::expected<addr_list, std::error_code>
resolve(std::string_view host, std::string_view service, int family, int socktype, int flags) {
    addrinfo hints{}; hints.ai_family=family; hints.ai_socktype=socktype; hints.ai_flags=flags;
    addrinfo* res=nullptr;
    int rc = ::getaddrinfo(host.empty()?nullptr:std::string(host).c_str(),
                           std::string(service).c_str(), &hints, &res);
    if (rc!=0) return std::unexpected(std::make_error_code(std::errc::invalid_argument));
    addr_list L; L.head = res; return L;
}

static std::string sa_to_string(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{}, serv[NI_MAXSERV]{};
    if (::getnameinfo(sa, salen, host, sizeof(host), serv, sizeof(serv),
                      NI_NUMERICHOST|NI_NUMERICSERV)==0)
        return std::string(host)+":"+serv;
    return "(unknown)";
}

static std::expected<int, std::error_code>
make_listen(std::string_view bind_host, std::string_view port, int backlog=512) {
    auto R = resolve(bind_host, port, AF_UNSPEC, SOCK_STREAM,
                     AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV);
    if (!R) return std::unexpected(R.error());
    for (auto* ai=R->head; ai; ai=ai->ai_next) {
        int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        int yes=1;
        ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        if (ai->ai_family==AF_INET6) {
            int v6only=0; ::setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
        }
        if (::bind(s, ai->ai_addr, ai->ai_addrlen)==0 && ::listen(s, backlog)==0) {
            if (set_nonblock(s)!=0) { ::close(s); continue; }
            std::print("[listen] {}\n", sa_to_string(ai->ai_addr, ai->ai_addrlen));
            return s;
        }
        ::close(s);
    }
    return std::unexpected(std::make_error_code(std::errc::address_not_available));
}

// === per-connection state machine ===
struct Conn {
    enum class State { READ_LEN, READ_BODY, WRITE_BODY };

    State state = State::READ_LEN;
    uint32_t be_len{0};
    uint32_t len{0};
    std::size_t have_len_bytes{0};
    std::size_t have_body_bytes{0};

    std::vector<std::byte> in_body;   // to receive
    std::vector<std::byte> out_body;  // to send (echo)
    std::string peer;

    explicit Conn(std::string p): peer(std::move(p)) {}
};

int main(int argc, char** argv) {
    std::string bind_host = (argc>1 ? argv[1] : "");
    std::string port      = (argc>2 ? argv[2] : "9000");

    auto L = make_listen(bind_host, port);
    if (!L) { std::print(stderr, "listen failed: {}\n", L.error().message()); return 1; }
    int lfd = *L;

    // poll set
    std::vector<pollfd> pfds;
    pfds.push_back(pollfd{.fd=lfd, .events=POLLIN, .revents=0});

    // fd -> Conn
    std::unordered_map<int, Conn> conns;

    auto add_client = [&](int cfd, const sockaddr* sa, socklen_t slen) {
        set_nonblock(cfd);
        std::string p = sa_to_string(sa, slen);
        conns.emplace(cfd, Conn{p});
        pfds.push_back(pollfd{.fd=cfd, .events=POLLIN, .revents=0});
        std::print("[accept] fd={} peer={}\n", cfd, p);
    };

    auto remove_fd = [&](int fd) {
        ::close(fd);
        conns.erase(fd);
        // erase from pfds
        for (size_t i=0;i<pfds.size();++i) {
            if (pfds[i].fd == fd) {
                pfds.erase(pfds.begin()+i);
                break;
            }
        }
    };

    auto want_writable = [&](int fd, bool on) {
        for (auto& p: pfds) if (p.fd==fd) {
            if (on) p.events |= POLLOUT; else p.events &= ~POLLOUT;
            break;
        }
    };

    const std::size_t CAP = 1<<20; // 1MiB per-frame cap

    for (;;) {
        int rc = ::poll(pfds.data(), pfds.size(), /*timeout ms*/ 10000);
        if (rc < 0) {
            if (errno == EINTR) continue;
            std::print(stderr, "poll: {}\n", std::strerror(errno));
            break;
        }
        if (rc == 0) {
            // 타임아웃: 주기적 유지보수/타임아웃 처리 지점으로도 사용 가능
            continue;
        }

        // poll 결과 순회 시 주의:
        // - 리스너부터 처리 → 가능한 만큼 accept
        // - 각 클라 fd에서 POLLIN/POLLOUT/에러 플래그 확인
        for (size_t i=0; i<pfds.size(); ++i) {
            auto& p = pfds[i];
            if (p.revents == 0) continue;

            if (p.fd == lfd) {
                // 리슨 소켓 이벤트: 가능한 만큼 accept (레벨 트리거)
                if (p.revents & POLLIN) {
                    for(;;){
                        sockaddr_storage ss{}; socklen_t slen=sizeof(ss);
                        int cfd = ::accept(lfd, (sockaddr*)&ss, &slen);
                        if (cfd >= 0) { add_client(cfd, (sockaddr*)&ss, slen); continue; }
                        if (errno==EAGAIN || errno==EWOULDBLOCK) break;
                        if (errno==EINTR) continue;
                        std::print(stderr, "accept: {}\n", std::strerror(errno));
                        break;
                    }
                }
                if (p.revents & (POLLERR|POLLHUP|POLLNVAL)) {
                    std::print(stderr, "[listen-err] {}\n", p.revents);
                }
                continue;
            }

            // 클라이언트 소켓
            int cfd = p.fd;
            bool closed = false;

            if (p.revents & (POLLERR|POLLHUP|POLLNVAL)) {
                // 에러/종료 → 정리
                remove_fd(cfd);
                closed = true;
            }
            if (closed) continue;

            auto it = conns.find(cfd);
            if (it == conns.end()) continue;
            Conn& C = it->second;

            // 1) 읽기 가능: state에 따라 consume
            if (p.revents & POLLIN) {
                bool again = true;
                while (again) {
                    again = false;

                    if (C.state == Conn::State::READ_LEN) {
                        // 4B 완성할 때까지 읽기
                        uint8_t* dst = reinterpret_cast<uint8_t*>(&C.be_len) + C.have_len_bytes;
                        ssize_t n = ::recv(cfd, dst, 4 - C.have_len_bytes, 0);
                        if (n > 0) {
                            C.have_len_bytes += static_cast<std::size_t>(n);
                            if (C.have_len_bytes == 4) {
                                C.len = ntohl(C.be_len);
                                if (C.len > CAP) {
                                    std::print(stderr, "[{}] frame too large: {}\n", C.peer, C.len);
                                    remove_fd(cfd); closed=true; break;
                                }
                                C.in_body.assign(C.len, std::byte{0});
                                C.have_body_bytes = 0;
                                C.state = Conn::State::READ_BODY;
                            } else {
                                // 아직 모자람 → 다음 POLLIN을 기다리거나, 수신 버퍼에 남아있다면 곧바로 다시 recv 시도
                                again = true; // 수신 버퍼가 크면 연속 진행
                            }
                        } else if (n == 0) {
                            // peer closed
                            remove_fd(cfd); closed=true; break;
                        } else {
                            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                                // 더 이상 읽을 게 없음
                            } else if (errno == EINTR) {
                                again = true;
                            } else {
                                std::print(stderr, "recv len [{}]: {}\n", C.peer, std::strerror(errno));
                                remove_fd(cfd); closed=true; break;
                            }
                        }
                    }

                    if (!closed && C.state == Conn::State::READ_BODY) {
                        std::byte* dst = C.in_body.data() + C.have_body_bytes;
                        ssize_t need = static_cast<ssize_t>(C.len - C.have_body_bytes);
                        ssize_t n = ::recv(cfd, dst, need, 0);
                        if (n > 0) {
                            C.have_body_bytes += static_cast<std::size_t>(n);
                            if (C.have_body_bytes == C.len) {
                                // echo 준비: out_body에 그대로 복사
                                C.out_body = C.in_body;
                                C.state = Conn::State::WRITE_BODY;
                                // 쓰기 관심 등록
                                want_writable(cfd, true);
                                // 다음은 쓰기 단계에서 진행
                            } else {
                                again = true; // 더 받을 수 있으면 계속
                            }
                        } else if (n == 0) {
                            remove_fd(cfd); closed=true; break;
                        } else {
                            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                                // 더 이상 없음
                            } else if (errno == EINTR) {
                                again = true;
                            } else {
                                std::print(stderr, "recv body [{}]: {}\n", C.peer, std::strerror(errno));
                                remove_fd(cfd); closed=true; break;
                            }
                        }
                    }
                } // while(again)
            } // POLLIN

            if (closed) continue;

            // 2) 쓰기 가능
            if (p.revents & POLLOUT) {
                if (C.state == Conn::State::WRITE_BODY) {
                    // 먼저 4B 길이 헤더 전송 → 그다음 바디
                    // out_body 기준으로 4B+payload를 한 덩어리로 보내되 부분 쓰기 고려
                    static thread_local std::vector<std::byte> outbuf;
                    // outbuf를 매번 구성하면 비효율이지만, 단순화를 위해 1회 구성 → 모두 보낼 때까지 유지
                    if (outbuf.empty()) {
                        uint32_t be = htonl(static_cast<uint32_t>(C.out_body.size()));
                        outbuf.resize(4 + C.out_body.size());
                        std::memcpy(outbuf.data(), &be, 4);
                        std::memcpy(outbuf.data()+4, C.out_body.data(), C.out_body.size());
                        C.have_len_bytes = 0; // 재활용: out 진행률로 사용
                    }

                    std::size_t sent = static_cast<std::size_t>(C.have_len_bytes);
                    std::size_t remain = outbuf.size() - sent;
                    ssize_t n = ::send(cfd, outbuf.data()+sent, remain, 0);
                    if (n > 0) {
                        C.have_len_bytes += static_cast<std::size_t>(n);
                        if (C.have_len_bytes == outbuf.size()) {
                            // 한 프레임 완성 → 다음 프레임을 위해 상태 리셋
                            outbuf.clear();
                            C.in_body.clear();
                            C.out_body.clear();
                            C.have_len_bytes = 0;
                            C.have_body_bytes = 0;
                            C.state = Conn::State::READ_LEN;
                            // 쓰기 관심 해제
                            want_writable(cfd, false);
                        }
                    } else if (n == 0) {
                        // 드물지만 진전 없음 → 다음 기회
                    } else {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) {
                            // 다음 POLLOUT을 기다림
                        } else if (errno == EINTR) {
                            // 재시도 기회
                        } else {
                            std::print(stderr, "send [{}]: {}\n", C.peer, std::strerror(errno));
                            outbuf.clear();
                            remove_fd(cfd);
                        }
                    }
                } else {
                    // POLLOUT은 필요 없으니 해제(레벨 트리거에서 불필요한 깨움 방지)
                    want_writable(cfd, false);
                }
            } // POLLOUT
        } // for pfds
    } // for(;;)

    ::close(lfd);
    return 0;
}
```

##### 포인트 정리
- **논블로킹 설정**: `set_nonblock` 로 리슨/클라 모두 설정.  
- **레벨 트리거**: `POLLIN` 시 **가능한 만큼** 연속 `accept/recv` 를 시도(루프).  
- **부분 입출력**: `have_len_bytes`/`have_body_bytes` 등으로 **진행률**을 추적.  
- **`POLLOUT` 관심은 필요할 때만** 켠다(쓰기 버퍼가 남았을 때). 다 보냈다면 **반드시 해제**.  
- **종료 이벤트 처리**: `POLLERR|POLLHUP|POLLNVAL` → 정리. `recv==0`(FIN) → 정리.  
- **프레이밍**: 길이-프리픽스 4바이트 + body. **CAP**(1MiB)로 자원 공격 방지.  

> 심화: outbuf를 `Conn` 안에 두고 **다프레임 지원**, `std::deque` 로 큐잉, `sendmsg(iovec)` 로 헤더+바디를 **한 번에** 보내는 최적화 등을 적용 가능.

---

### 9.5 `poll` 루프에서 흔한 함정과 대처

1) **POLLIN인데 `recv`가 EAGAIN**  
   - 흔치 않지만 경쟁 조건이나 소켓 옵션/다른 스레드 개입으로 가능. **정상**으로 취급하고 **다음 이벤트**를 기다리자.  
2) **`POLLOUT`을 계속 켜둠**  
   - 레벨 트리거에선 보내기 가능하면 **항상 깨어난다** → 필요할 때만 켜고, 다 보내면 **즉시 해제**.  
3) **부분 쓰기 무시**  
   - `send`는 항상 **부분적으로**만 성공할 수 있다. **진행률 추적**을 반드시 하자.  
4) **에러 이벤트 무시**  
   - `POLLERR/POLLHUP/POLLNVAL`은 **즉시 정리**. 안 그러면 fd가 루프에 남아 CPU 스핀 유발.  
5) **대형 프레임 무제한**  
   - 반드시 **CAP**(최대 프레임) 정책으로 방어.  

---

### 9.6 준비상태/레벨 트리거 사고방식 요약

- “**준비되면 깨워줘**”가 멀티플렉싱의 핵심.  
- **레벨 트리거**에서는 준비 조건이 계속 참이면 **반복해서** 이벤트가 온다 → **드레인(drain)** 패턴으로 “될 때까지 읽거나/쓸 수 있을 때까지 쓴다”.  
- **엣지 트리거**(다음 장 권장): 상태가 변할 때만 한 번 알림 → 이벤트 하나에서 **버퍼를 텅 빌 때까지** 읽고, **버퍼를 꽉 채울 때까지** 쓰는 습관이 필수.

---

### 9.7 단계별 확장 아이디어

- `poll` → **`epoll`(Linux) / `kqueue`(BSD/macOS)** 로 교체(성능·스케일).  
- **타임아웃 휠**/우선순위 큐로 **연결별 데드라인** 관리(유휴 종료, 슬로클라 백프레셔).  
- **Zero-copy**: `sendfile`, `splice`, `copy_file_range`(용도에 따라).  
- **TLS**: 논블로킹 소켓 위에 TLS를 올리면 **상태 머신이 한 겹 더** 생긴다(핸드셰이크/재시도).  
- **Backpressure 전달**: 상위 레이어(비즈니스 로직)에도 **출력 큐 길이**를 피드백해 생산 속도를 조절.

---

### 9.8 체크리스트

- [ ] 모든 소켓을 **논블로킹**으로.  
- [ ] `POLLIN`에서 **드레인**: 가능한 만큼 `accept/recv`.  
- [ ] `POLLOUT`은 **필요할 때만 등록**, 다 보내면 해제.  
- [ ] **부분 I/O** 진행률 추적(상태 머신).  
- [ ] **CAP**(최대 프레임)으로 자원 공격 방지.  
- [ ] 에러/종료 이벤트를 **즉시 정리**.  
- [ ] (규모↑) `epoll`/`kqueue`로 이행.

---

### 9.9 마무리

논블로킹 멀티플렉싱은 **복잡해 보이지만** 핵심은 단순하다:  
**“준비된 것만 건드리고, 안 되면 즉시 돌아오며, 다음 기회를 기다린다.”**  
이 장의 `poll` 기반 에코 서버는 **레벨 트리거**의 감각을 몸에 익히는 최소 단위다.  
여기서 **에러/타임아웃/큐잉/백프레셔**를 조금씩 확장하면, **실전 서버**의 골격이 된다.  
다음 단계로 `epoll(ET)`/타임아웃 관리/멀티스레딩(accept 전용 스레드 + 워커)로 발전시켜 보자.
