---
layout: post
title: 암호학 - 프로토콜 실습
date: 2025-10-17 20:30:23 +0900
category: 암호학
---
# 프로토콜 실습: 미니 TLS 핸드셰이크 트레이스 · 인증서 체인 분석 (⚙️랩)

> 목표
> 1) **TLS 1.3 핸드셰이크**를 “바이트-레벨로” 추적하고, **HKDF 파생 경로**(early → handshake → application secrets)와 **Finished** 검증까지 손으로 재현한다.
> 2) **인증서 체인**(Root → Intermediate → Leaf)을 직접 만들어 보고, **경로검증 로직**(BasicConstraints/KeyUsage/EKU/NameConstraints/AIA/OCSP/CRL/CT)을 체크리스트로 점검한다.
> 모든 코드는 **교육용**이며, 실서비스는 신뢰 스택(예: OpenSSL/boringssl/rustls)과 OS 인증 저장소를 사용하세요.

---

## 0. 준비물

- Python 3.10+ (추가 패키지 없이도 실습 가능; 인증서 파트는 OpenSSL CLI 권장)
- Wireshark(선택) — 로컬 `curl https://example.com` 캡처 후 필터 `tls` 또는 `tcp.port == 443`
- OpenSSL 3.x (인증서 생성/검증)

---

## 1. 미니 TLS 1.3 핸드셰이크 트레이스 (X25519 + AES-128-GCM 가정)

### 1.1 “핵심 흐름” 요약 (서버 인증 / 1-RTT)

```
ClientHello
  - legacy_version=0x0303, random[32], cipher_suites=[TLS_AES_128_GCM_SHA256,...]
  - extensions: supported_versions(1.3), key_share(X25519: X_c), sni, alpn, signature_algs, supported_groups, psk? (없음)

ServerHello
  - selected_version=1.3, selected_cipher=TLS_AES_128_GCM_SHA256
  - key_share(X25519: X_s)
(여기까지의 transcript로 handshake secrets 파생 시작)
EncryptedExtensions
Certificate
CertificateVerify
Finished
(서버 방향 application traffic key가 준비됨)

(클라이언트)
Finished
(양방향 application traffic key 준비, 이후 HTTP/2/H3 등 전송)
```

핵심 파생:
- `early_secret = HKDF-Extract(zeros, PSK or 0)`
- `handshake_secret = HKDF-Extract(DH(X_c, X_s), HKDF-Expand-Label(early_secret, "derived", "", HashLen))`
- `client/server_handshake_traffic_secret = HKDF-Expand-Label(handshake_secret, "c hs traffic"/"s hs traffic", Hash(Handshake Context), HashLen)`
- `finished_key = HKDF-Expand-Label(handshake_traffic_secret, "finished", "", HashLen)`
- `master_secret = HKDF-Extract(zeros, HKDF-Expand-Label(handshake_secret,"derived","",HashLen))`
- `app_traffic_secret_{0} = HKDF-Expand-Label(master_secret, "c ap traffic"/"s ap traffic", Hash(Full Handshake), HashLen)`

여기서 Hash=SHA-256 (암호스위트에 종속), AEAD=AES-128-GCM.

---

### 1.2 핸드셰이크 트레이스 — 미니 바이트 스케치

> 실제 바이너리와 완전히 동일하지는 않지만, **필드를 직관적으로** 보이게 구성했다. Wireshark로 실제 캡처와 비교하자.

```
ClientHello:
  01 | 0303 | rnd(32)=C1... | session_id="" | suites=1301,1302,1303 | comp=00
  ext:
    supported_versions: 0x0304(=1.3)
    supported_groups: x25519, secp256r1
    signature_algorithms: rsa_pss_rsae_sha256, ecdsa_secp256r1_sha256
    key_share: X25519, key = 32B: X_c
    server_name: "lab.local"
    alpn: "h2","http/1.1"

ServerHello:
  02 | 0303 | rnd(32)=S1... | session_id="" | suite=1301(TLS_AES_128_GCM_SHA256)
  ext:
    supported_versions: 0x0304
    key_share: X25519, key = 32B: X_s
(여기서부터 record 레벨이 Handshake traffic key로 암호화)

EncryptedExtensions:
  alpn: "h2"
  sni: accepted
Certificate:
  chain: [Leaf cert, Intermediate CA] (DER 각각)
CertificateVerify:
  algo: rsa_pss_rsae_sha256 (예), Sig = Sign(sk_server, Transcript-Hash-context)
Finished:
  verify_data = HMAC(finished_key_s, Hash(transcript))
(Client Finished 이후 애플리케이션 데이터 시작)
```

---

### 1.3 파이썬으로 **HKDF-Expand-Label**/비밀 파생/Finished 검증 재현

아래 코드는 “수업용”으로 TLS 1.3 레이블 포맷을 단순화했다.
실제 Label 구조: `HkdfLabel = length(2B) | "tls13 " + label | context_len(1B) | context`.
우리는 이 구조를 그대로 만든다.

```python
import hmac, hashlib, struct

def hkdf_extract(salt: bytes, ikm: bytes, hashmod=hashlib.sha256) -> bytes:
    if salt is None: salt = b"\x00"*hashmod().digest_size
    return hmac.new(salt, ikm, hashmod).digest()

def hkdf_expand(prk: bytes, info: bytes, length: int, hashmod=hashlib.sha256) -> bytes:
    out = b""; t = b""; counter = 1
    while len(out) < length:
        t = hmac.new(prk, t + info + bytes([counter]), hashmod).digest()
        out += t; counter += 1
    return out[:length]

def hkdf_expand_label(secret: bytes, label: str, context: bytes, length: int, hashmod=hashlib.sha256) -> bytes:
    full_label = b"tls13 " + label.encode()
    hkdf_label = struct.pack("!H", length) + bytes([len(full_label)]) + full_label + bytes([len(context)]) + context
    return hkdf_expand(secret, hkdf_label, length, hashmod)

# 가짜 transcript hash를 만들어 보자 (실습: 실제 Handshake 바이트를 해시해 대체해도 됨)
def th(data_parts, hashmod=hashlib.sha256):
    h = hashmod()
    for d in data_parts:
        h.update(d)
    return h.digest()

# 1. 초기값
zeros = b"\x00"*32  # SHA-256
Hash = hashlib.sha256

# 2. (데모) ECDH 공유비밀:
# 실제로는 X25519 수행 결과 32B `shared`가 나온다.
# 여기서는 임의 바이트(32B)를 써서 흐름만 재현.
shared = bytes.fromhex("10"*32)  # 임의 상수 (실전은 X25519 결과)

# 3. transcript들 (데모용 바이트)
CH = b"ClientHello(...)"
SH = b"ServerHello(...)"
EE = b"EncryptedExtensions(...)"
CRT= b"Certificate(...)"
CV = b"CertificateVerify(...)"

# 4. 파생
early_secret = hkdf_extract(zeros, b"\x00"*0, Hash)                 # PSK 없음 가정
derived_secret = hkdf_expand_label(early_secret, "derived", b"", 32, Hash)
handshake_secret = hkdf_extract(derived_secret, shared, Hash)

th1 = th([CH, SH], Hash)
c_hs = hkdf_expand_label(handshake_secret, "c hs traffic", th1, 32, Hash)
s_hs = hkdf_expand_label(handshake_secret, "s hs traffic", th1, 32, Hash)
c_hs_key = hkdf_expand_label(c_hs, "key", b"", 16, Hash)            # AES-128-GCM
c_hs_iv  = hkdf_expand_label(c_hs, "iv",  b"", 12, Hash)
s_hs_key = hkdf_expand_label(s_hs, "key", b"", 16, Hash)
s_hs_iv  = hkdf_expand_label(s_hs, "iv",  b"", 12, Hash)

# 서버 Finished 전 transcript
th2 = th([CH, SH, EE, CRT, CV], Hash)
s_finished_key = hkdf_expand_label(s_hs, "finished", b"", 32, Hash)
server_verify_data = hmac.new(s_finished_key, th2, Hash).digest()

# 클라 Finished 시점 transcript
th3 = th([CH, SH, EE, CRT, CV, b"Finished(server)"], Hash)
c_finished_key = hkdf_expand_label(c_hs, "finished", b"", 32, Hash)
client_verify_data = hmac.new(c_finished_key, th3, Hash).digest()

# 애플리케이션 시크릿
derived2 = hkdf_expand_label(handshake_secret, "derived", b"", 32, Hash)
master_secret = hkdf_extract(derived2, b"\x00"*0, Hash)
th_full = th([CH, SH, EE, CRT, CV, b"Finished(server)", b"Finished(client)"], Hash)
c_ap = hkdf_expand_label(master_secret, "c ap traffic", th_full, 32, Hash)
s_ap = hkdf_expand_label(master_secret, "s ap traffic", th_full, 32, Hash)
```

위 파생으로 얻은 `*_key/*_iv`로 **AES-128-GCM**을 구성하면, 실제 TLS 레코드 계층 암복호를 재현할 수 있다(교육용).
(실습 팁: `cryptography.hazmat.primitives.ciphers.aead.AESGCM`으로 테스트 해보자. AAD는 TLS 레코드 헤더.)

---

### 1.4 Finished 검증 랩

- 서버가 보낸 `Finished.verify_data`를 우리가 계산한 `server_verify_data`와 비교해 검증한다.
- 여기서 불일치가 발생하면 **중간자/위변조** 또는 **키 불일치**를 의미한다.

```python
# 서버 Finished 수신 가정: recv_verify_data
recv_verify_data = server_verify_data  # 데모: 동일로 둠
assert hmac.compare_digest(recv_verify_data, server_verify_data)
print("[Finished] server verify_data OK")
```

---

### 1.5 0-RTT(초기데이터) 위험 간단 이해

- PSK/세션재개 기반의 **0-RTT 데이터**는 **재전송 공격**(replay)을 막기 어렵다.
- 서버는 `anti-replay window`/토큰/시간 제한으로 완화하지만, **멱등/재실행 안전 요청**(GET 등)에만 허용하는 게 안전하다.
- 본 랩은 **0-RTT 비활성** 가정.

---

## 2. 인증서 체인 분석 랩

“루트(신뢰 앵커)” → “중간 CA” → “서버 리프” 체인을 직접 만들고, OpenSSL로 필드를 점검하고 **검증 실패 사례**를 재현한다.

### 2.1 키·루트CA 생성

```bash
# Root CA 키/자체서명(개발/실습용)
openssl genrsa -out root.key 4096
openssl req -x509 -new -key root.key -sha256 -days 3650 -out root.crt -subj "/CN=Lab Root CA"
# 기본 constraints 확장 포함을 추천: -addext "basicConstraints=critical,CA:true,pathlen:1"
```

### 2.2 중간CA 발급

```bash
# 중간 키/CSR
openssl genrsa -out inter.key 4096
openssl req -new -key inter.key -out inter.csr -subj "/CN=Lab Intermediate CA"
# 루트가 중간에 서명
openssl x509 -req -in inter.csr -CA root.crt -CAkey root.key -CAcreateserial \
  -out inter.crt -days 1825 -sha256 \
  -extfile <(printf "basicConstraints=critical,CA:true,pathlen:0\nkeyUsage=critical,keyCertSign,cRLSign\nauthorityKeyIdentifier=keyid,issuer\nsubjectKeyIdentifier=hash\n")
```

### 2.3 서버(리프) 발급 (SAN 포함)

```bash
# 서버 키/CSR
openssl genrsa -out leaf.key 2048
openssl req -new -key leaf.key -out leaf.csr -subj "/CN=lab.local"
# SAN 확장 포함 (현대 검증은 SAN 기준)
cat > leaf.ext <<EOF
basicConstraints=critical,CA:false
keyUsage=critical,digitalSignature,keyEncipherment
extendedKeyUsage=serverAuth
subjectAltName=DNS:lab.local,DNS:www.lab.local
authorityKeyIdentifier=keyid,issuer
subjectKeyIdentifier=hash
EOF

openssl x509 -req -in leaf.csr -CA inter.crt -CAkey inter.key -out leaf.crt -days 397 -sha256 -extfile leaf.ext
```

### 2.4 체인 파일과 검증

```bash
# 체인 번들(서버가 보통 이렇게 보냄: Leaf + Intermediate)
cat leaf.crt inter.crt > chain.pem

# 검증 (루트를 신뢰 앵커로)
openssl verify -CAfile root.crt chain.pem
# OK가 떠야 한다.

# 텍스트로 보기
openssl x509 -in leaf.crt -noout -text | sed -n '1,120p'
openssl x509 -in inter.crt -noout -text | sed -n '1,160p'
```

**체크리스트(필드)**
- **basicConstraints**: 리프는 `CA:false`, 중간은 `CA:true`(+ pathlen).
- **keyUsage**: 리프는 `digitalSignature (+keyEncipherment/RSA)`, 중간은 `keyCertSign,cRLSign`.
- **EKU(extendedKeyUsage)**: 리프에 `serverAuth` 필수(클라이언트 인증이면 `clientAuth`).
- **SAN**: 접속 도메인과 **정확 매칭**(와일드카드면 규칙 확인).
- **AKI/SKI**: 체인 연결 단서가 맞는지.
- **Validity**: 리프 기한은 오늘 포함 범위. **클록 스큐** 고려.
- **SignatureAlgorithm**: 현대는 `sha256WithRSAEncryption` or ECDSA-SHA256 이상.
- **Public Key**: RSA ≥2048, 또는 ECDSA(P-256/384), Ed25519.

### 2.5 AIA/OCSP/CRL/CT 스테이플링

- **AIA(Authority Info Access)**: 중간/루트의 발급자 정보를 얻는 URL(OCSP, Issuers).
- **OCSP**: 서버가 **OCSP staple**을 보낼 수 있다. 클라이언트는 **신선도/서명** 확인(Stapling 실패 시 OCSP 요청 or 소프트-페일).
- **CRL**: 대형 배포에서는 부담. 대부분 OCSP 선호.
- **CT(SCT)**: 공개 로그에 서명 증거(SCT) 포함. 현대 브라우저는 “CT 정책”을 요구(공개 CA 발급시).
- 실습 루트/중간은 사설이므로 CT/OCSP는 생략 가능.

### 2.6 실패 사례 재현

1) **SAN 누락/불일치**
   - `leaf.ext`에서 `subjectAltName`을 빼거나, 접속 도메인과 다르게 두고 `curl --resolve lab.local:443:127.0.0.1 https://lab.local` 시도 → **호스트명 검증 실패**.

2) **EKU 부적절**
   - 리프에서 `serverAuth` 제거 → 대부분 클라이언트가 거부.

3) **중간 cert 미동봉(사슬 깨짐)**
   - `chain.pem`에서 `inter.crt` 제거 → 일부 클라가 **경로구축 실패**.

4) **유효기간/시간대 문제**
   - `-days`를 과거/미래로 바꿔 발급 → **not yet valid** / **expired** 오류.

5) **CA:false로 중간 발급**
   - `basicConstraints=CA:false`로 중간 발급 → 체인 검증 실패(발급 권한 없음).

---

## 3. Wireshark로 실제 트랜스크립트 확인

1) 터미널 A: `sudo tcpdump -i lo0 -w tls.pcapng tcp port 443` (macOS 예; Linux는 인터페이스명 확인)
2) 터미널 B: 로컬 리버스 프록시나 Nginx에 `leaf.key/leaf.crt` 설정 후 `curl https://lab.local` (hosts에 `127.0.0.1 lab.local` 추가)
3) Wireshark에서 `tls.pcapng` 열고 **TLS → Handshake** 트리 펼쳐 `ClientHello/ServerHello/Extensions` 확인.
4) `TLSv1.3 Record` 선택 시, **Key Log File**로 디코딩도 가능(클라에서 `SSLKEYLOGFILE` 사용, 실습 환경에서만).

---

## 4. (심화) Finished 재현 검증 · 레코드 암복호 데모

아래는 **교육용** 레코드 암복호 예시(실 TLS 헤더/AAD 형식과 정확히 일치하진 않음).
핵심은 **AEAD(key, iv, AAD, plaintext)**로 **암호문+태그**를 만들고, 같은 키/IV/AAD로 복호가 성공해야 한다는 점.

```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

def aead_enc(key, iv, aad, pt):
    return AESGCM(key).encrypt(iv, pt, aad)

def aead_dec(key, iv, aad, ct):
    return AESGCM(key).decrypt(iv, ct, aad)

# 예시: 서버 핸드셰이크 키로 EE 레코드를 보호한다 가정
aad = b"tls13-record-header-demo"  # 실제는 ContentType+LegacyVersion+Length 등
ct = aead_enc(s_hs_key, s_hs_iv, aad, b"EncryptedExtensions(...)")
pt = aead_dec(s_hs_key, s_hs_iv, aad, ct)
assert pt == b"EncryptedExtensions(...)"  # 성공해야 함
print("[AEAD] handshake record enc/dec OK")
```

---

## 5. 미니 CTF 과제

### CHAL-1: Finished 검증
- 제공: `CH, SH, EE, CRT, CV`의 SHA-256 해시(또는 원문), `s_hs`(서버 핸드셰이크 시크릿).
- 목표: `server_finished_key` 파생 → `verify_data` 계산 → 제출값과 비교.
- 채점: HMAC 결과 일치.

### CHAL-2: 잘못된 체인 고치기
- 제공: `leaf.crt`(SAN 불일치), `inter.crt`, `root.crt`
- 목표: SAN을 올바르게 설정해 리프 재발급(자체 루트 체인) → `openssl verify -CAfile root.crt chain.pem` 성공 스크린샷 제출.

### CHAL-3: 경로 구축 실패 원인 찾기
- 제공: 실패 로그와 세 cert 텍스트.
- 목표: 실패 원인 2가지를 지적(예: EKU 미설정, AKI/SKI 불일치, pathlen 위반 등)하고 수정 ext 제안.

---

## 6. 실무 체크리스트 (TLS/체인)

- [ ] **TLS 1.3 강제**, 0-RTT는 **멱등 요청에 한정**
- [ ] **현대 스위트**: TLS_AES_128_GCM_SHA256 / TLS_AES_256_GCM_SHA384 / TLS_CHACHA20_POLY1305_SHA256
- [ ] **서버 인증서**: SAN 필수, EKU=serverAuth, RSA≥2048 또는 ECDSA(P-256), 유효기간/CT 정책 준수
- [ ] **체인 번들**에 중간 포함, AIA/OCSP 스테이플링 가능하면 활성
- [ ] **키/암호 스토어**: HSM/KMS/권한분리(12장), 자동 갱신/만료 알림
- [ ] **보안 헤더**: HSTS, `ssl_early_data off`(0-RTT 제한), ALPN 명시
- [ ] **로깅 균일화**: 핸드셰이크 실패 사유를 **추상화된 코드**로 기록(정보 노출 최소화)

---

## 7. 트러블슈팅 빈출

- **“host name mismatch”**: SAN 누락/오타. CSR 생성 시부터 SAN 포함.
- **“self-signed certificate”**: 루트가 신뢰 저장소에 없음 / 체인 미동봉.
- **“no application protocol”**: ALPN 불일치(클라 h2, 서버 http/1.1만).
- **“wrong signature type”**: 서명알고리즘/EKU/KeyUsage 불일치.
- **TLS 1.2로 다운그레이드**: 중간 장비/라이브러리 제한. 서버/클라 양쪽 정책 확인.

---

## 8. 리뷰 질문

1) TLS 1.3에서 `handshake_secret`이 생기는 정확한 시점과 입력은?
2) `Finished.verify_data` 계산식(키/입력 해시)을 문장으로 설명하라.
3) SAN과 CN의 역할 차이와 현대 브라우저의 매칭 규칙은?
4) 중간 CA의 `pathlen`이 0일 때 의미는? 왜 리프 발급엔 영향 없나?
5) OCSP Stapling이 실패할 때, 대부분의 클라이언트는 어떻게 동작하나(소프트/하드 페일)?
6) 0-RTT 재전송이 초래할 수 있는 비즈니스 리스크 두 가지를 들고, 서버-측 완화책을 제시하라.

---

## 9. 마무리

이 랩을 통해 TLS 1.3의 **키 파생 경로와 Finished 검증**을 코드로 재현했고,
인증서 체인의 **필수 확장과 경로 검증**을 CLI로 확인했다.
실서비스에선 **표준 스택 기본값**을 존중하되, 오늘 만든 **체크리스트**로 설정/갱신/감사 품질을 꾸준히 유지하자.
