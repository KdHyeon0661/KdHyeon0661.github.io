---
layout: post
title: Svelte - 상태 관리
date: 2025-09-28 18:25:23 +0900
category: Svelte
---
# 3. 상태 관리
**스토어(writable/readable/derived/get·`$store` 문법) · 전역 vs 지역 상태/컴포넌트 경계 · URL/QueryString 동기화 패턴 · (Svelte 5) Runes 맛보기: `$state`, `$derived`**

> 이 장은 Svelte 앱에서 **예측 가능한 상태 흐름**을 만드는 방법을 “스토어”를 중심으로 정리한다.
> - **기초**: `writable`/`readable`/`derived`와 `get`·`$store` 문법
> - **설계**: 전역/지역 상태의 경계, 컴포넌트·라우트 레벨 분리
> - **라우팅 연동**: URL QueryString ↔ 상태 동기화 (SvelteKit)
> - **Svelte 5**: Runes(`$state`, `$derived`)로 지역 상태를 더 깔끔하게

---

## 3.1 스토어(Store) 기본기 — “반응 가능한 값 컨테이너”

Svelte의 스토어는 **반응형 값**을 담는 아주 얇은 컨테이너다.
핵심은 다음 3가지 인터페이스:

- **`writable`**: 읽기/쓰기 모두 가능한 스토어
- **`readable`**: 외부에서 **읽기만 가능한** 스토어(쓰기 제어)
- **`derived`**: 다른 스토어로부터 **파생**되는 스토어

스토어는 최소한 다음 메서드를 가진다:

- **`subscribe(run: (value) => void) => () => void`**: 구독/해지
- **`set(value)`**: 값 설정 (`writable` 전용)
- **`update(fn)`**: 이전 값을 받아 새 값을 계산 (`writable` 전용)

그리고 컴포넌트 안에서는 **템플릿·스크립트** 어디에서든 `$store` 문법으로 **구독 + 자동 해지**를 제공한다.

---

### 3.1.1 `writable` — 읽고·쓰기 가능한 상태

```svelte
<!-- src/lib/stores/counter.ts -->
<script lang="ts">
  import { writable } from 'svelte/store';

  // 카운터 스토어
  export const count = writable(0);
</script>
```

```svelte
<!-- src/routes/+page.svelte -->
<script lang="ts">
  import { count } from '$lib/stores/counter';

  // $count를 쓰는 순간: 컴포넌트가 구독을 시작하고 파괴 시 자동 해지
  function inc() { count.update(n => n + 1); }
  function reset() { count.set(0); }
</script>

<h1>Count: {$count}</h1>
<button on:click={inc}>+1</button>
<button on:click={reset}>reset</button>
```

- **`$count`**: `$` 접두사를 붙이면 **템플릿/스크립트**에서 현재 값을 바로 쓸 수 있다(자동 구독).
- **주의**: `$store`는 **컴포넌트 스코프**에서만 사용 가능(모듈 스코프 X).

---

### 3.1.2 `readable` — 외부에선 읽기만

```svelte
<!-- src/lib/stores/time.ts -->
<script lang="ts">
  import { readable } from 'svelte/store';

  // 1초마다 업데이트되는 현재 시간 (읽기 전용)
  export const now = readable<Date>(new Date(), (set) => {
    const id = setInterval(() => set(new Date()), 1000);
    return () => clearInterval(id); // 구독자 0명 시 정리
  });
</script>
```

```svelte
<!-- 사용 -->
<script lang="ts">
  import { now } from '$lib/stores/time';
</script>

<p>Now: {$now.toLocaleTimeString()}</p>
```

- `readable`는 **생성 시 콜백**을 받아 **lazy**하게 동작한다(최초 구독에 실행).
- **정리 함수**를 반환하면 구독자가 없어질 때 자동 종료.

---

### 3.1.3 `derived` — 파생 스토어

```svelte
<!-- src/lib/stores/cart.ts -->
<script lang="ts">
  import { writable, derived, type Readable } from 'svelte/store';

  export type Item = { id: string; name: string; price: number; qty: number };

  export const cart = writable<Item[]>([]);
  export const total: Readable<number> = derived(cart, ($cart) =>
    $cart.reduce((sum, it) => sum + it.price * it.qty, 0)
  );
</script>
```

```svelte
<script lang="ts">
  import { cart, total } from '$lib/stores/cart';

  function add() {
    cart.update(items => [...items, { id: crypto.randomUUID(), name: 'Book', price: 12, qty: 1 }]);
  }
</script>

<button on:click={add}>Add</button>
<p>Total: {$total}</p>
```

- `derived(입력스토어들, 파생함수)`는 입력 값이 변하면 자동으로 파생 값을 갱신한다.
- 파생 함수는 **부작용을 가지지 않는** 순수 계산이 이상적.

---

### 3.1.4 `get(store)` — 구독 없이 **바로 꺼내기**

```ts
import { get } from 'svelte/store';
import { cart } from '$lib/stores/cart';

function snapshotCart() {
  const value = get(cart); // 현재값 스냅샷 (구독하지 않음)
  console.log(value);
}
```

- **주의**: `get`은 **반응적이지 않다**. 이후 변경을 자동으로 추적하지 않는다.
- 주로 이벤트 핸들러, 서버 호출 직전의 스냅샷 취득 등에 사용.

---

### 3.1.5 **커스텀 스토어** — 공용 API를 감싼다

```ts
// src/lib/stores/auth.ts
import { writable } from 'svelte/store';

type User = { id: string; name: string } | null;

function createAuth() {
  const { subscribe, set, update } = writable<User>(null);

  return {
    subscribe,
    login(name: string) {
      // 실제로는 서버 요청…
      set({ id: crypto.randomUUID(), name });
    },
    logout() {
      set(null);
    },
    rename(newName: string) {
      update(u => (u ? { ...u, name: newName } : u));
    }
  };
}

export const auth = createAuth();
```

```svelte
<script lang="ts">
  import { auth } from '$lib/stores/auth';
  let name = '';
</script>

{#if $auth}
  <p>Welcome, {$auth.name}</p>
  <button on:click={() => auth.logout()}>Logout</button>
{:else}
  <input bind:value={name} placeholder="Your name" />
  <button on:click={() => auth.login(name)}>Login</button>
{/if}
```

- 커스텀 스토어는 **내부 변경 규칙**을 은닉하고 **작은 API**로 노출한다(테스트/교체 용이).

---

## 3.2 `$store` 문법 — “자동 구독/자동 해지”

- 컴포넌트의 `<script>` **인스턴스 스코프**나 템플릿에서 `$store`를 사용하면,
  Svelte가 `subscribe` → 언마운트 시 해지까지 **자동**으로 처리한다.
- 장점: **보일러플레이트 최소화**, 오류/누수 방지

#### 3.2.1 `$store`를 스크립트에서 쓰는 예

```svelte
<script lang="ts">
  import { total } from '$lib/stores/cart';
  // 스크립트에서도 바로 사용할 수 있음
  $: freeShip = $total >= 50;
</script>

<p>Total: {$total} → {freeShip ? 'Free shipping' : 'Shipping not free'}</p>
```

- `$:` 반응 구문과 결합해 **파생 상태**를 자연스럽게 만든다.

---

## 3.3 전역 상태 vs 지역 상태 — “경계와 소유권”

### 3.3.1 원칙

- **지역 상태(Local)**: **한 컴포넌트/한 라우트**에서만 의미를 가지는 값
  → **컴포넌트 변수**(혹은 Svelte 5의 `$state`)로 충분
- **전역 상태(Global)**: **여러 곳**에서 공유되어야 하고 **페이지 이동 간 유지**가 필요
  → **스토어**(또는 SvelteKit + 서버/쿠키)를 고려

> **경계(Ownership)**: “이 상태를 **누가 소유**하고, 누가 **읽기만** 해야 하는가?”
> - 소유자는 `set`/`update` 권한, 나머지는 `subscribe`만
> - `readable`로 쓰기 경로를 통제하면 안정성이 올라간다.

### 3.3.2 예: 검색 패널 설계 — 지역 vs 전역

- **지역**: 검색 인풋 값, 펼침/접힘 상태, 임시 필터
  → 해당 페이지 컴포넌트 내부 변수
- **전역**: 로그인 사용자, 장바구니, 언어 설정, 테마, 최근 본 항목
  → 전역 스토어로 관리

```svelte
<!-- src/routes/products/+page.svelte -->
<script>
  // 지역 상태로 충분
  let q = '';
  let openFilter = false;

  // 서버로 전송할 최종 파라미터만 store/URL과 동기화(아래 3.5절)
</script>

<input bind:value={q} placeholder="Search..." />
<button on:click={() => openFilter = !openFilter}>Filters</button>
{#if openFilter}
  <!-- ... -->
{/if}
```

---

### 3.3.3 계층(트리) 경로 설계 팁

- **하향식 데이터(Parent → Child)**: **props**/슬롯로 전달
  필요 시 자식도 읽을 수 있게 **컨텍스트 API** `setContext/getContext`(고급)
- **상향식 이벤트(Child → Parent)**: `createEventDispatcher`로 이벤트 발행
- **형제 간**: 공동 부모로 올려서 내려주거나, **스토어**로 분리

> “최소 권한 원칙”: 쓰기가 필요한 곳만 `writable`에 접근, 나머지는 `readable`로.

---

## 3.4 상태 모듈 패턴 — “도메인마다 store를 쪼갠다”

도메인 별로 “작고 응집력 있는 모듈”을 만든다.

```
src/lib/stores/
  auth.ts        로그인/세션
  cart.ts        장바구니
  ui.ts          테마/패널 열림
  notification.ts 토스트/알림 큐
```

### 3.4.1 UI 플래그 모음 (토글들)

```ts
// src/lib/stores/ui.ts
import { writable } from 'svelte/store';

export const theme = writable<'light'|'dark'>('light');
export const sidebarOpen = writable(false);

export const ui = {
  theme,
  sidebarOpen,
  toggleTheme() { theme.update(t => (t === 'light' ? 'dark' : 'light')); },
  openSidebar() { sidebarOpen.set(true); },
  closeSidebar() { sidebarOpen.set(false); }
};
```

```svelte
<script lang="ts">
  import { ui } from '$lib/stores/ui';
</script>

<button on:click={() => ui.toggleTheme()}>
  Theme: {$ui.theme}
</button>
```

- 단일 `ui` 오브젝트로 묶어 IDE 탐색성이 좋아진다.

---

## 3.5 URL/QueryString과 상태 동기화 (SvelteKit)

> URL은 “**앱 상태의 주소**”다. 검색 조건/페이지네이션/정렬처럼 **공유/북마크**가 필요한 상태는 **URL에 싣는 게 정석**이다.

### 3.5.1 읽기: `load`에서 Query 읽기

```ts
// src/routes/items/+page.ts
import type { PageLoad } from './$types';

export const load: PageLoad = ({ url, fetch }) => {
  const q = url.searchParams.get('q') ?? '';
  const page = Number(url.searchParams.get('page') ?? '1');

  // 서버 데이터 요청(예시)
  const dataPromise = fetch(`/api/items?q=${encodeURIComponent(q)}&page=${page}`)
    .then(r => r.json());

  return { q, page, data: dataPromise };
};
```

```svelte
<!-- src/routes/items/+page.svelte -->
<script lang="ts">
  export let data: { q: string; page: number; data: Promise<any> };
</script>

<h1>Search: {data.q} / Page: {data.page}</h1>

{#await data.data}
  <p>Loading…</p>
{:then items}
  <ul>{#each items as it}<li>{it.name}</li>{/each}</ul>
{:catch e}
  <p style="color:red">{e.message}</p>
{/await}
```

- `load`는 **SSR + 클라이언트 전환** 모두에서 동작 가능.
- URL → `load` → 페이지 컴포넌트로 **초기 상태 주입**.

---

### 3.5.2 쓰기: UI 이벤트 → URL 업데이트

페이지 전환 없이 **QueryString만 갱신**하려면 `goto`로 동일 경로에 다른 URL을 쓴다.

```ts
// src/lib/url.ts
import { goto } from '$app/navigation';
import { page } from '$app/stores';
import { get } from 'svelte/store';

export function setQuery(params: Record<string, string | undefined>) {
  const url = new URL(get(page).url);
  Object.entries(params).forEach(([k, v]) => {
    if (v == null || v === '') url.searchParams.delete(k);
    else url.searchParams.set(k, String(v));
  });
  // history: 'replace'로 뒤로가기 기록 오염 방지 (필요 시)
  goto(url, { replaceState: true, keepfocus: true, noscroll: true });
}
```

```svelte
<!-- src/routes/items/+page.svelte -->
<script lang="ts">
  import { setQuery } from '$lib/url';
  export let data: { q: string; page: number; data: Promise<any> };

  let q = data.q;

  function search() {
    setQuery({ q, page: '1' }); // q 바꾸면 page는 1로 리셋
  }
  function toPage(n: number) {
    setQuery({ q, page: String(n) });
  }
</script>

<input bind:value={q} placeholder="Query"/>
<button on:click={search}>Search</button>

<nav>
  <button on:click={() => toPage(Math.max(1, data.page - 1))}>Prev</button>
  <button on:click={() => toPage(data.page + 1)}>Next</button>
</nav>
```

- `goto(url, { replaceState: true })`를 쓰면 **뒤로가기 기록을 보존**하면서 Query만 바꿀 수 있다.
- URL이 바뀌면 **페이지의 `load`가 재실행**되어 데이터 캐싱/프리로드 전략과 연결된다.

---

### 3.5.3 상태 ↔ URL을 **양방향**으로 엄격히 묶기

- 페이지 마운트 시: URL → 로컬 상태 **초기화**
- 사용자 조작 시: 로컬 상태 → URL **반영**
- URL 변경(뒤/앞으로가기 등): `page` 스토어 구독으로 **로컬 상태 갱신**

```svelte
<script lang="ts">
  import { page } from '$app/stores';
  import { setQuery } from '$lib/url';
  import { onDestroy } from 'svelte';

  let q = '';
  const un = page.subscribe(($page) => {
    q = $page.url.searchParams.get('q') ?? '';
  });
  onDestroy(un);

  function updateQ(v: string) {
    q = v;
    setQuery({ q: v }); // 양방향
  }
</script>

<input value={q} on:input={(e) => updateQ(e.currentTarget.value)} />
```

- 이 패턴으로 **주소창과 상태가 항상 일치**한다(협업/디버깅 쉬움).

---

### 3.5.4 다중 필터의 직렬화/역직렬화

```ts
// src/lib/query.ts
export type Filters = {
  q?: string;
  tags?: string[];  // ['red','blue']
  sort?: 'name'|'price';
  page?: number;
};

export function readFilters(url: URL): Filters {
  const tags = url.searchParams.getAll('tag'); // ?tag=red&tag=blue
  return {
    q: url.searchParams.get('q') ?? undefined,
    tags: tags.length ? tags : undefined,
    sort: (url.searchParams.get('sort') as Filters['sort']) ?? undefined,
    page: Number(url.searchParams.get('page') ?? '1')
  };
}

export function writeFilters(url: URL, f: Filters) {
  url.searchParams.delete('tag');
  if (f.q) url.searchParams.set('q', f.q);
  if (f.tags) f.tags.forEach(t => url.searchParams.append('tag', t));
  if (f.sort) url.searchParams.set('sort', f.sort);
  if (f.page) url.searchParams.set('page', String(f.page));
}
```

- 배열 파라미터는 `append`/`getAll`로 다룬다.
- “상태의 주소성(shareability)”이 곧 **사용자 경험/협업 생산성**이다.

---

## 3.6 SSR/CSR와 스토어 — “어디서 값을 만들고 쓸까?”

- **SSR 단계**에서는 브라우저 API가 없다. 서버에서 필요한 데이터만 **초기 상태**로 준비한다(`load`/`+page.server.ts`).
- **클라이언트 전용** 스토어(예: `window` 의존)는 `onMount` 이후 초기화하거나 스토어의 생성 시점이 **첫 구독 때** 실행되도록 설계한다(`readable`의 start 콜백, 커스텀 스토어 내부에서 lazy 초기화).

```ts
// src/lib/stores/viewport.ts
import { readable } from 'svelte/store';

export const viewport = readable<{w:number;h:number}>({ w: 0, h: 0 }, (set) => {
  if (typeof window === 'undefined') return; // SSR 가드
  const on = () => set({ w: window.innerWidth, h: window.innerHeight });
  on();
  window.addEventListener('resize', on);
  return () => window.removeEventListener('resize', on);
});
```

---

## 3.7 성능/안정성 팁

1) **작게 쪼갠 스토어**: 거대한 한 스토어 대신 **여러 작은 스토어**로 나누면 불필요한 재렌더가 줄고 의존이 명확해진다.
2) **파생은 순수하게**: `derived` 내 네트워크/부작용 금지 — **계산만**.
3) **최소 구독**: 상위 레이아웃에서 거대한 스토어를 전부 구독하면 모든 페이지가 갱신됨. 필요한 곳에서만 구독.
4) **메모리/정리**: `readable`의 start 콜백에서 리스너를 등록했다면 반드시 정리 함수를 반환.

---

## 3.8 고급: 스토어와 폼/액션/유효성 검증

간단한 폼 상태를 스토어로 모델링하면 유효성·제출 로직이 명확해진다.

```ts
// src/lib/stores/form.ts
import { writable, derived } from 'svelte/store';

export const email = writable('');
export const pwd = writable('');

export const valid = derived([email, pwd], ([$e, $p]) =>
  $e.includes('@') && $p.length >= 8
);
```

```svelte
<script lang="ts">
  import { email, pwd, valid } from '$lib/stores/form';
  import { get } from 'svelte/store';

  async function submit() {
    if (!get(valid)) return alert('Invalid');
    // 서버 전송…
  }
</script>

<input bind:value={$email} placeholder="email" />
<input type="password" bind:value={$pwd} placeholder="password" />
<button disabled={!$valid} on:click={submit}>Submit</button>
```

- `get(valid)`로 **스냅샷** 후 조건부 전송.

---

## 3.9 (Svelte 5) **Runes** 맛보기 — `$state`, `$derived`, `$effect`

> v5에서는 **컴포넌트 지역 상태**를 더 명확히 다루도록 “룬(Runes)”을 도입했다.
> - **`$state(initial)`**: 상태 선언(깊은 반응성)
> - **`$derived(expr)`**: 파생 값
> - **`$effect(fn)`**: 부작용(마운트 후 실행, 의존 변경 시 재실행)

### 3.9.1 `$state` — 깊은(Deep) 반응성

```svelte
<script>
  let cart = $state([{ id: 1, name: 'Book', price: 12, qty: 1 }]);

  function add() {
    cart.push({ id: Date.now(), name: 'Pen', price: 3, qty: 1 });
  }
  function inc(id) {
    const it = cart.find(i => i.id === id);
    if (it) it.qty++;
  }

  let total = $derived(cart.reduce((s, i) => s + i.price * i.qty, 0));
</script>

<button on:click={add}>Add</button>
<ul>
  {#each cart as it (it.id)}
    <li>
      {it.name} x {it.qty}
      <button on:click={() => inc(it.id)}>+</button>
    </li>
  {/each}
</ul>
<p>Total: {total}</p>
```

- `$state`는 **중첩 변경**(예: `it.qty++`)도 추적한다.
- v4에서 필요하던 “새 참조로 재할당” 보일러를 줄여준다.

### 3.9.2 `$derived` — 파생 값 분리

```svelte
<script>
  let q = $state('');
  let trimmed = $derived(q.trim());
</script>

<input bind:value={q} />
<p>Trimmed: {trimmed}</p>
```

- `$derived` 내부는 **부작용 없이** 계산만.

### 3.9.3 `$effect` — 부작용 시점

```svelte
<script>
  let q = $state('');

  $effect(() => {
    console.log('query changed:', q);
    // fetch/observe 등 DOM 업데이트 이후 타이밍
  });
</script>

<input bind:value={q} />
```

- SSR에서는 실행되지 않는다(브라우저에서만).

> **스토어 vs Runes**:
> - **지역 상태**(한 컴포넌트/한 라우트): **Runes**(간단/명시적)
> - **전역/공유 상태**: **스토어**(파일 모듈로 관리, 어디서나 구독)

---

## 3.10 종합 실습 — “검색·필터·페이지네이션: 상태 ↔ URL ↔ 서버 데이터”

### 3.10.1 Query 직렬화 유틸

```ts
// src/lib/query.ts
export type Query = {
  q?: string;
  tags?: string[];
  sort?: 'name'|'price'|'recent';
  page?: number;
};

export function readQuery(url: URL): Query {
  const q = url.searchParams.get('q') ?? undefined;
  const sort = (url.searchParams.get('sort') as Query['sort']) ?? 'recent';
  const page = Number(url.searchParams.get('page') ?? '1');
  const tags = url.searchParams.getAll('tag');
  return { q, sort, page, tags: tags.length ? tags : undefined };
}

export function writeQuery(url: URL, query: Query) {
  url.searchParams.delete('tag');
  if (query.q) url.searchParams.set('q', query.q); else url.searchParams.delete('q');
  if (query.sort) url.searchParams.set('sort', query.sort);
  if (query.page) url.searchParams.set('page', String(query.page));
  if (query.tags) query.tags.forEach(t => url.searchParams.append('tag', t));
}
```

### 3.10.2 `load` — URL → 초기 상태

```ts
// src/routes/search/+page.ts
import type { PageLoad } from './$types';
import { readQuery } from '$lib/query';

export const load: PageLoad = async ({ url, fetch }) => {
  const q = readQuery(url);
  const res = await fetch(`/api/search?` + url.searchParams.toString());
  const items = await res.json();
  return { q, items };
};
```

### 3.10.3 페이지 — UI → URL (replaceState) → 자동 재로드

```svelte
<!-- src/routes/search/+page.svelte -->
<script lang="ts">
  import { goto } from '$app/navigation';
  import { page } from '$app/stores';
  import { readQuery, writeQuery, type Query } from '$lib/query';

  export let data: { q: Query; items: any[] };

  let q = structuredClone(data.q); // 편집용 지역 상태

  function apply() {
    const url = new URL($page.url);
    writeQuery(url, q);
    goto(url, { replaceState: true, keepfocus: true, noscroll: true });
  }

  function toggleTag(tag: string) {
    const set = new Set(q.tags ?? []);
    set.has(tag) ? set.delete(tag) : set.add(tag);
    q.tags = [...set];
  }
</script>

<input bind:value={q.q} placeholder="Search..." />
<select bind:value={q.sort}>
  <option value="recent">Recent</option>
  <option value="name">Name</option>
  <option value="price">Price</option>
</select>

<div>
  {#each ['red','green','blue'] as t}
    <label>
      <input type="checkbox"
             checked={q.tags?.includes(t)}
             on:change={() => toggleTag(t)} />
      {t}
    </label>
  {/each}
</div>

<button on:click={apply}>Apply</button>

<ul>
  {#each data.items as it}
    <li>{it.name} - {it.price}</li>
  {/each}
</ul>
```

- `apply()`가 URL을 바꾸면 **`+page.ts`의 `load`가 재실행** → `data.items` 갱신
- Query를 **한 곳(URL)** 에서 진실원천으로 유지 → 새로고침/공유/뒤로가기 강함

---

## 3.11 흔한 함정 & 체크리스트

1) **모든 걸 전역 스토어로** → 복잡도 증가/불필요한 구독
   - 지역 상태는 **컴포넌트 변수**(또는 Runes)로, 공유가 필요할 때만 스토어.

2) **derived에서 부작용** → 예측 불가
   - 파생은 **순수 계산**만. 네트워크/로깅은 액션/라이프사이클에서.

3) **get() 남용** → 반응성 깨짐
   - 스냅샷만 필요할 때 한정 사용. UI 갱신은 `$store`로.

4) **URL 동기화 누락** → 뒤/앞으로가기·북마크 불가
   - 공유 가능한 상태는 **URL에 실어라**(특히 검색/필터/정렬/페이지).

5) **SSR에서 window 접근** → 크래시
   - 스토어 생성 시 SSR 가드 또는 `onMount`에서 초기화.

6) **구독 해지 잊음** → 누수
   - `$store`를 쓰면 자동 해지. 직접 `subscribe`하면 **반드시 unsubscriber 호출**.

---

## 3.12 요약

- 스토어는 **작게 쪼개고** 역할을 선명하게
- `$store` 문법으로 구독 보일러 제거, `get()`은 스냅샷용
- 전역 vs 지역: 공유/주소성/수명에 따라 **소유권**을 엄격히
- URL은 상태의 주소 — **Query 동기화**로 UX·협업·디버깅 향상
- Svelte 5 Runes로 **지역 상태**를 더 깔끔하게, 전역은 여전히 **스토어**가 적합

---

### 부록 A. 스토어 유틸 모음

```ts
// src/lib/stores/persist.ts
import { writable, type Writable } from 'svelte/store';

export function persist<T>(key: string, initial: T): Writable<T> {
  const store = writable<T>(initial, (set) => {
    if (typeof localStorage === 'undefined') return;
    const raw = localStorage.getItem(key);
    if (raw != null) set(JSON.parse(raw));
  });
  store.subscribe((v) => {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem(key, JSON.stringify(v));
    }
  });
  return store;
}
```

```ts
// 사용
import { persist } from '$lib/stores/persist';
export const theme = persist<'light'|'dark'>('theme', 'light');
```

- 간단한 **로컬 퍼시스턴스**가 필요할 때.

---

### 부록 B. 이벤트 버스(간단 토스트)

```ts
// src/lib/stores/toast.ts
import { readable } from 'svelte/store';

type Toast = { id: string; text: string; kind?: 'info'|'error' };

let push!: (t: Toast) => void;
export const toasts = readable<Toast[]>([], (set) => {
  let list: Toast[] = [];
  push = (t) => {
    list = [...list, t];
    set(list);
    setTimeout(() => {
      list = list.filter(x => x.id !== t.id);
      set(list);
    }, 2000);
  };
  return () => { /* noop */ };
});

export function toast(text: string, kind: Toast['kind'] = 'info') {
  push({ id: crypto.randomUUID(), text, kind });
}
```

```svelte
<!-- src/lib/components/ToastHost.svelte -->
<script>
  import { toasts } from '$lib/stores/toast';
</script>

<div class="host">
  {#each $toasts as t (t.id)}
    <div class="toast {t.kind}">{t.text}</div>
  {/each}
</div>

<style>
  .host { position: fixed; right: 1rem; bottom: 1rem; display: grid; gap: .4rem; }
  .toast { background: #222; color: #fff; padding: .5rem .8rem; border-radius: .4rem; }
  .toast.error { background: #b22; }
</style>
```

```svelte
<!-- 어디서든 -->
<script>
  import { toast } from '$lib/stores/toast';
</script>

<button on:click={() => toast('Saved!')}>Toast</button>
```

- 스토어를 통해 **어디서나 발행**하고, `ToastHost`는 **한 번만** 렌더.

---

### 부록 C. v4 스타일 ↔ v5 Runes 혼용 시 주의
- 기존 `writable` 스토어는 그대로 사용 가능.
- 컴포넌트 **지역 상태**는 `$state`로 단순화 가능.
- 전역 스토어에 `$state`를 직접 쓰기보단, **스토어 API**로 외부 노출이 더 명확.

---

## 체크리스트

- [ ] `writable`/`readable`/`derived` 동작 이해
- [ ] `$store`와 `get()`의 차이 숙지
- [ ] 전역/지역 상태 경계 명확화(소유권/공유/주소성)
- [ ] URL Query 동기화 유틸 작성(배열/페이지/정렬 포함)
- [ ] SSR 가드/정리 함수로 누수· 크래시 방지
- [ ] (v5) `$state`/`$derived`/`$effect`의 역할 구분
