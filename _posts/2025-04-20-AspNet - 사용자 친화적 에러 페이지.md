---
layout: post
title: AspNet - 사용자 친화적 에러 페이지
date: 2025-04-10 19:20:23 +0900
category: AspNet
---
# ASP.NET Core 사용자 친화적 에러 페이지 만들기

## 큰 그림 — 예외 vs 상태 코드, 그리고 콘텐츠 협상

- **예외(Exception)**: 런타임 오류(500 계열).
  - 개발: `UseDeveloperExceptionPage()`
  - 운영: `UseExceptionHandler("/Error")`(HTML), 또는 **ProblemDetails(JSON)** 미들웨어
- **상태 코드(Status Code)**: 라우팅 실패/권한 문제 등(404/403 등).
  - `UseStatusCodePagesWith(ReExecute|Redirects|Format)`로 페이지/JSON/텍스트 선택
- **콘텐츠 협상(Content Negotiation)**:
  - **브라우저**엔 HTML 에러 페이지
  - **API 클라이언트**엔 RFC7807 **ProblemDetails(JSON)**
  → 수용 언어/Accept 헤더, 엔드포인트 분기, 필터로 동시 지원

---

## Program.cs — 환경별 파이프라인 + HTML/JSON 동시 처리

### 기본 뼈대

```csharp
var builder = WebApplication.CreateBuilder(args);

// MVC/Razor/API 모두를 위한 기본 구성
builder.Services.AddControllersWithViews();
builder.Services.AddRazorPages();

// ProblemDetails(ASP.NET Core 8+) 혹은 커스텀 미들웨어
builder.Services.AddProblemDetails(options =>
{
    // 예외 → 표준 ProblemDetails로 매핑하는 정책(기본 매핑 + 확장)
    options.CustomizeProblemDetails = ctx =>
    {
        var traceId = ctx.HttpContext.TraceIdentifier;
        ctx.ProblemDetails.Extensions["traceId"] = traceId;
        // 민감 내용은 넣지 말 것
    };
});

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage(); // 상세 에러
}
else
{
    // 1) 예외(500 계열)
    app.UseExceptionHandler("/Error"); // HTML 전용 핸들(브라우저)
    // 병행으로 API용 ProblemDetails 자동 응답을 원하면 아래 활성화
    app.UseExceptionHandler(); // ProblemDetails 미들웨어(accept: application/json)
    app.UseHsts();
}

// 2) 상태 코드(404/403 등) — HTML로 재실행
app.UseStatusCodePagesWithReExecute("/StatusCode/{0}");

// 정적 파일/라우팅/인증/권한
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();

// 엔드포인트
app.MapControllers();
app.MapRazorPages();

app.Run();
```

> 팁
> - `app.UseExceptionHandler("/Error")`는 **HTML**용 Razor/MVC로 연결.
> - `app.UseExceptionHandler()`(매개변수 없음)는 **ProblemDetails** 미들웨어를 활성화(ASP.NET Core 8+)하여 **JSON** 오류 응답을 자동 처리.
> - 두 개를 병행할 때는 **콘텐츠 협상**이 중요(브라우저-HTML, API-JSON).

---

## Razor Pages — 500/404/403 전용 페이지 설계

### — `Pages/Error.cshtml`

```razor
@page
@model ErrorModel
@{
    ViewData["Title"] = "문제가 발생했습니다";
    Layout = "_Layout";
}

<section class="error error-500">
  <h1>문제가 발생했습니다.</h1>
  <p>요청을 처리하는 중 오류가 발생했습니다. 잠시 후 다시 시도해 주세요.</p>

  @if (!string.IsNullOrWhiteSpace(Model.RequestId))
  {
      <p>요청 ID: <code>@Model.RequestId</code></p>
  }

  <div class="actions">
      <a class="btn" href="/">홈으로 돌아가기</a>
      <a class="btn" href="/search">검색</a>
      <a class="btn" href="/support">문의하기</a>
  </div>
</section>
```

`Pages/Error.cshtml.cs`:

```csharp
using Microsoft.AspNetCore.Diagnostics;

public class ErrorModel : PageModel
{
    public string? RequestId { get; private set; }
    public string? Path { get; private set; }

    public void OnGet()
    {
        RequestId = HttpContext.TraceIdentifier; // 로깅 상관관계 ID
        var feature = HttpContext.Features.Get<IExceptionHandlerPathFeature>();
        Path = feature?.Path;
        // feature?.Error 로깅 가능(절대 사용자에게 세부 노출 금지)
    }
}
```

### — `Pages/StatusCode.cshtml`

```razor
@page "{code:int}"
@model StatusCodeModel
@{
    Layout = "_Layout";
    var code = Model.Code;
}

<section class="error">
  <h1>에러 코드: @code</h1>

  @if (code == 404)
  {
      <p>요청하신 페이지를 찾을 수 없습니다.</p>
      <ul>
          <li>주소를 다시 확인해 주세요.</li>
          <li>검색을 이용해 원하는 페이지를 찾을 수 있어요.</li>
      </ul>
  }
  else if (code == 403)
  {
      <p>접근 권한이 없습니다.</p>
      <p>권한이 필요한 페이지라면 관리자에게 문의하세요.</p>
  }
  else
  {
      <p>문제가 발생했습니다. 잠시 후 다시 시도해 주세요.</p>
  }

  <div class="actions">
      <a class="btn" href="/">홈으로</a>
      <a class="btn" href="/search">검색</a>
  </div>
</section>
```

`Pages/StatusCode.cshtml.cs`:

```csharp
public class StatusCodeModel : PageModel
{
    public int Code { get; private set; }

    public void OnGet(int code) => Code = code;
}
```

---

## MVC 방식 — 전용 컨트롤러/뷰

```csharp
public sealed class ErrorController : Controller
{
    [Route("Error")]
    public IActionResult Error()
    {
        var feature = HttpContext.Features.Get<IExceptionHandlerPathFeature>();
        ViewData["RequestId"] = HttpContext.TraceIdentifier;
        ViewData["Path"] = feature?.Path;
        return View(); // Views/Error/Error.cshtml
    }

    [Route("StatusCode/{code:int}")]
    public IActionResult Status(int code)
    {
        Response.StatusCode = code; // 그대로 유지
        ViewData["Code"] = code;
        return View("StatusCode"); // Views/Error/StatusCode.cshtml
    }
}
```

`Views/Error/Error.cshtml`:

```html
@{
    ViewData["Title"] = "서버 오류";
    var requestId = (string?)ViewData["RequestId"];
}
<h1>500 - 내부 서버 오류</h1>
<p>요청 처리 중 문제가 발생했습니다.</p>
@if (!string.IsNullOrWhiteSpace(requestId))
{
    <p>요청 ID: <code>@requestId</code></p>
}
<a href="/">홈으로 돌아가기</a>
```

`Views/Error/StatusCode.cshtml`:

```html
@{
    var code = (int?)ViewData["Code"] ?? 0;
}
<h1>오류 코드: @code</h1>
@if (code == 404)
{
    <p>페이지를 찾을 수 없습니다.</p>
}
else if (code == 403)
{
    <p>접근 권한이 없습니다.</p>
}
<a href="/">홈</a>
```

---

## 표준화

### 전역 ProblemDetails(ASP.NET Core 8+)

위 Program.cs의 `AddProblemDetails()` + `UseExceptionHandler()`로 자동화.
컨트롤러 액션에선 `Problem(...)`, `ValidationProblem(...)`으로 일관화.

```csharp
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    [HttpGet("{id:int}")]
    public IActionResult Get(int id)
    {
        if (id <= 0)
            return Problem(statusCode: 400, title: "잘못된 요청", detail: "id는 양수여야 합니다.");

        // ...
        return Ok(new { id, name = "Alice" });
    }
}
```

**검증 실패** 자동 400: `[ApiController]`가 활성화되면 모델 유효성 실패 시 RFC7807 형식으로 자동 응답(단, 커스터마이즈 가능).

### HTML/JSON 동시 지원 전략

- **HTML 경로**: `/Error` / `/StatusCode/{code}` (브라우저)
- **API 경로**: `UseExceptionHandler()` ProblemDetails(accept: `application/json`)
- **동일 경로**에서 Accept 헤더 기반 분기(필터/미들웨어)도 가능

---

## 사용자 친화적 UX 요소 — 체크리스트

- **명확한 메시지**: 사용자 탓 아니라고 안심, 다음 행동 제시
- **빠른 탈출**: “홈으로”, “검색”, “이전 페이지” 버튼
- **브랜드/레이아웃 유지**: `_Layout` 공유, 헤더/푸터/네비 포함
- **접근성**: 의미있는 `<h1>`, 적절한 색 대비, 포커스 트랩 금지, ARIA 속성
- **다국어**: `IStringLocalizer`/Resource 기반 메시지
- **슬림 리소스**: 에러 페이지 자체가 무거우면 2차 실패
- **문의 채널**: 피드백/이메일/지원 링크
- **추적 코드 노출**: RequestId/traceId는 **기술지원용**(민감 데이터 금지)

---

## 보안/성능/캐싱/머리글

- **보안**: 상세 스택 트레이스는 **개발 환경**에만. 운영은 일반 메시지.
- **헤더 강화**:
  - `X-Content-Type-Options: nosniff`
  - `Content-Security-Policy`(가능하면 엄격)
  - `Referrer-Policy`
- **캐싱**: 에러 응답은 보통 캐싱 금지
  ```csharp
  Response.Headers.CacheControl = "no-store, no-cache";
  ```
- **HTTPS/HSTS**: 운영에서 활성화
- **정적 파일 오류**: `UseStaticFiles()`는 실패 시 예외 처리가 안 된다 → 라우팅으로 대체 메시지 제공

---

## + 프록시(Nginx/IIS)에서의 에러

- **SPA 라우팅**: 404는 프론트 라우터에서 처리 필요 → 서버 404 페이지 대신 SPA 엔트리로 리라이트하고, SPA에서 **사용자 친화 404** 렌더링
- **프록시**: Nginx/IIS의 502/504 등은 **프록시 에러 페이지**가 뜬다 → 프록시 수준 커스텀 오류 페이지 구성(브랜드 일체감 유지)

---

## 커스텀 미들웨어로 고급 제어(선택)

- **Correlation ID** 삽입 → 로깅/문제 추적
- **API/HTML 분기**: `Accept` 헤더 기준으로 JSON/HTML 응답 선택
- **특정 예외 → 특정 상태 코드 매핑**

```csharp
public sealed class ApiAwareExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ApiAwareExceptionMiddleware> _logger;

    public ApiAwareExceptionMiddleware(RequestDelegate next, ILogger<ApiAwareExceptionMiddleware> logger)
    {
        _next = next; _logger = logger;
    }

    public async Task InvokeAsync(HttpContext ctx)
    {
        try
        {
            await _next(ctx);
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(ex, "Unauthorized");
            if (IsApiRequest(ctx))
            {
                ctx.Response.StatusCode = StatusCodes.Status401Unauthorized;
                await ctx.Response.WriteAsJsonAsync(new
                {
                    type = "about:blank",
                    title = "인증 필요",
                    status = 401,
                    traceId = ctx.TraceIdentifier
                });
            }
            else
            {
                ctx.Response.Redirect("/StatusCode/401");
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled");
            if (IsApiRequest(ctx))
            {
                ctx.Response.StatusCode = StatusCodes.Status500InternalServerError;
                await ctx.Response.WriteAsJsonAsync(new
                {
                    type = "about:blank",
                    title = "서버 오류",
                    status = 500,
                    traceId = ctx.TraceIdentifier
                });
            }
            else
            {
                ctx.Response.Redirect("/Error");
            }
        }
    }

    private static bool IsApiRequest(HttpContext ctx)
    {
        var accept = ctx.Request.Headers.Accept.ToString();
        return accept.Contains("application/json", StringComparison.OrdinalIgnoreCase)
            || ctx.Request.Path.StartsWithSegments("/api");
    }
}
```

등록:

```csharp
app.UseMiddleware<ApiAwareExceptionMiddleware>();
```

> 주의: 전역 예외 미들웨어는 **순서**가 중요. `UseExceptionHandler`와의 중복 처리 설계를 신중히.

---

## 디자인 템플릿(간단 레이아웃 + 공용 Partials)

`Views/Shared/_Layout.cshtml` 혹은 `Pages/Shared/_Layout.cshtml`에 **공통 UI** 배치:

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>@ViewData["Title"] - MyApp</title>
  <link rel="stylesheet" href="~/css/site.css" />
</head>
<body>
  <header>
    <a href="/" class="brand">MyApp</a>
    <nav>
      <a href="/products">상품</a>
      <a href="/support">지원</a>
    </nav>
  </header>

  <main role="main" class="container">
    @RenderBody()
  </main>

  <footer>
    <p>&copy; @DateTime.Now.Year MyApp</p>
  </footer>

  @RenderSection("Scripts", required: false)
</body>
</html>
```

에러 페이지들은 이 레이아웃을 **그대로** 사용하여 브랜드 일관성을 유지한다.

---

## 상태 코드 페이지 전략 — ReExecute vs Redirects vs Text

```csharp
// 가장 많이 쓰는 방식: 내부 재실행(원래 경로 보존, 서버 내부 라우팅)
app.UseStatusCodePagesWithReExecute("/StatusCode/{0}");

// 외부 리디렉션(클라이언트에 302 등 노출, URL 변경)
app.UseStatusCodePagesWithRedirects("/StatusCode/{0}");

// 간단 텍스트(개발 임시)
app.UseStatusCodePages("text/plain", "Status code page, status code: {0}");
```

> **ReExecute**는 **원래 URL을 유지**하고 서버 내부에서 핸들러를 재실행하므로, SEO/분석 측면에서 유리(사용자는 URL이 바뀌지 않음).

---

## 관측성 — 로깅, 추적, APM

- `ILogger`로 **경로**, **상태 코드**, **RequestId** 기록
- 분산 추적(OpenTelemetry, Application Insights)을 붙이면 `traceId`/`spanId` 연계
- 에러 페이지에서 **RequestId만** 사용자에게 보여주고, 상세는 **로그**에서 확인

```csharp
public class ErrorModel : PageModel
{
    private readonly ILogger<ErrorModel> _logger;
    public string? RequestId { get; private set; }

    public ErrorModel(ILogger<ErrorModel> logger) => _logger = logger;

    public void OnGet()
    {
        RequestId = HttpContext.TraceIdentifier;
        _logger.LogError("Error page shown. TraceId={TraceId}, Path={Path}",
            RequestId, HttpContext.Request.Path);
    }
}
```

---

## 테스트 — 통합 테스트로 에러 경로 검증

`Microsoft.AspNetCore.Mvc.Testing` 활용:

```csharp
public class ErrorPagesFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.UseEnvironment("Production"); // 운영 파이프라인 확인
    }
}

public class ErrorPagesTests : IClassFixture<ErrorPagesFactory>
{
    private readonly HttpClient _client;
    public ErrorPagesTests(ErrorPagesFactory f) => _client = f.CreateClient();

    [Fact]
    public async Task NotFound_Should_Render_Status_Page()
    {
        var res = await _client.GetAsync("/not-exists");
        Assert.Equal(HttpStatusCode.NotFound, res.StatusCode);
        var html = await res.Content.ReadAsStringAsync();
        Assert.Contains("페이지를 찾을 수 없습니다", html);
    }

    [Fact]
    public async Task Api_Error_Should_Return_ProblemDetails()
    {
        var req = new HttpRequestMessage(HttpMethod.Get, "/api/users/-1");
        req.Headers.Accept.ParseAdd("application/json");
        var res = await _client.SendAsync(req);

        Assert.Equal(HttpStatusCode.BadRequest, res.StatusCode);
        var json = await res.Content.ReadAsStringAsync();
        Assert.Contains("\"title\":\"잘못된 요청\"", json);
        Assert.Contains("\"status\":400", json);
    }
}
```

---

## 운영 체크리스트

- [ ] 개발: `UseDeveloperExceptionPage()`만 노출
- [ ] 운영: `UseExceptionHandler("/Error")` + `UseExceptionHandler()`(ProblemDetails)
- [ ] 상태 코드: `UseStatusCodePagesWithReExecute("/StatusCode/{0}")`
- [ ] 에러 페이지 레이아웃 재사용(브랜드/네비 유지)
- [ ] RequestId/traceId 표시 + 로깅 연계
- [ ] 민감 정보 노출 금지(스택/연결문자 등)
- [ ] 보안 헤더/CSP/HSTS
- [ ] SPA/프록시 에러 페이지 일관성 유지
- [ ] 통합 테스트로 404/403/500 케이스 검증
- [ ] 모니터링/알림(APM/로그 수집) 연결

---

## 자주 겪는 함정과 해결

| 문제 | 원인 | 해결 |
|---|---|---|
| “에러 페이지 안 뜸” | 응답이 이미 시작됨 | 오류 발생 전 미들웨어에서 헤더/바디 쓰지 않기 |
| “API인데 HTML 반환” | Accept 헤더 무시 | JSON/HTML **분기** 로직(미들웨어/필터) 적용 |
| “정적 파일 404 UX 없음” | StaticFiles 미들웨어 특성 | 정적 자원 경로 재검토 또는 SPA 라우터로 위임 |
| “프록시 에러 화면” | Nginx/IIS 레벨 오류 | 프록시의 error_page 구성으로 브랜드 페이지 사용 |
| “민감 정보 노출” | 개발용 페이지 노출 | 환경/배포 파이프라인에서 `Development` 금지, HSTS |

---

## 최소 구현 템플릿(요약)

```csharp
// Program.cs
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/Error"); // HTML
    app.UseExceptionHandler();         // JSON ProblemDetails
    app.UseHsts();
}

app.UseStatusCodePagesWithReExecute("/StatusCode/{0}");
```

`Pages/Error.cshtml` & `Pages/StatusCode.cshtml`에 **사용자 친화적** 카피·링크·레이아웃 적용.

---

## 결론

- 에러는 **경험**이다.
- **콘텐츠 협상**으로 HTML/JSON을 올바르게 분기하고,
- **사용자 친화 카피/행동 동선**, **브랜드 일관성**, **관측성(로그/traceId)**, **보안 헤더**까지 챙기면
**프로덕션급 에러 처리**가 완성된다.
