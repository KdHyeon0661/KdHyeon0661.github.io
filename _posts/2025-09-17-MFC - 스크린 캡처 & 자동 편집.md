---
layout: post
title: MFC - 스크린 캡처 & 자동 편집
date: 2025-09-17 21:25:23 +0900
category: MFC
---
# “스크린 캡처 & 자동 편집” — 사각형 선택, 블러/리사이즈, (가짜가 아닌) 실전형 클라우드 업로드 UX  
_MFC/Win32 + GDI/GDI+ + (선택) WinHTTP · 레이어드 오버레이 · 다중 모니터 · DPI 대응_

> 목표: **PrintScreen보다 더 빠르고 유용한** 캡처 도구.  
> 핵심: ① 반투명 오버레이에서 **사각형 영역 선택** → ② **자동 편집 파이프라인**(블러, 리사이즈, 테두리/그림자) → ③ **저장/클립보드/업로드**(진행/복구 UX 포함).  
> 본문은 **설계 → 코드 스니펫 → 운영/안전 팁** 순으로, 생략 없이 담았습니다.

---

## 0. 완성 UX 한 장 요약

- **Ctrl+Shift+S** → 화면 전체 위에 **반투명 오버레이**  
- 마우스로 **드래그** → 사각형 선택(ESC 취소, Enter/더블클릭 확정, Space로 이동 모드)  
- **그리드/돋보기·좌표 표시**(옵션)  
- 확정 시:  
  1) 원본에서 **해당 영역** BitBlt 캡처  
  2) **자동 편집**: 둥근 테두리, 그림자(선택), **민감영역 블러**(사전 규칙 or 단축키 B)  
  3) 규칙 기반 **리사이즈**(예: 긴 변 1400px) + PNG/JPEG 저장  
  4) **클립보드 복사**, 또는 **백그라운드 업로드**(진행표시 + 자동 링크 복사)  
- 실패/중단에도 **임시 파일** 보존, 재전송 버튼 제공

---

## 1. 프로젝트 뼈대

- **MFC Dialog** 기반 권장(핫키/트레이/환경설정까지 확장 용이)
- 서브 윈도우:
  - **OverlayWnd**: 전 화면 반투명, 마우스로 선택/그리기
  - **Editor**(선택): 즉석 블러/모자이크/펜
  - **Uploader**: WinHTTP 백그라운드 업로드 + 재시도
- **GDI+ 초기화**(앱 라이프타임)

```cpp
// Gdiplus init (전역 객체 한 번)
#include <gdiplus.h>
#pragma comment(lib,"gdiplus.lib")
class CGdiplusInit {
    ULONG_PTR token{};
public:
    CGdiplusInit(){ Gdiplus::GdiplusStartupInput in; Gdiplus::GdiplusStartup(&token,&in,nullptr); }
    ~CGdiplusInit(){ if(token) Gdiplus::GdiplusShutdown(token); }
} _g_gdip;
```

---

## 2. 오버레이 윈도우(선택 영역 UI)

### 2-1. 스타일과 생성

- **레이어드(WS_EX_LAYERED)** 대신, 여기서는 **반투명 반가림 + XOR 드로잉** 안정성 위해 **반투명 비사용 + 전체 반투명 채색**을 권장  
- 반드시 **WS_EX_TOOLWINDOW**(Alt+Tab 제외), **WS_EX_TOPMOST**, **DWM 프레임 없음**

```cpp
// OverlayWnd.h
class COverlayWnd : public CWnd {
public:
    BOOL CreateOverlay(); // 가상 스크린(모든 모니터) 크기로 생성
    CRect m_rcSelect{};
    bool  m_drag=false, m_move=false;
    CPoint m_anchor{};
protected:
    afx_msg int OnCreate(LPCREATESTRUCT);
    afx_msg void OnPaint();
    afx_msg BOOL OnEraseBkgnd(CDC*);
    afx_msg void OnLButtonDown(UINT,CPoint);
    afx_msg void OnLButtonUp(UINT,CPoint);
    afx_msg void OnMouseMove(UINT,CPoint);
    afx_msg BOOL OnKeyDown(UINT,UINT,UINT);
    DECLARE_MESSAGE_MAP()
};
```

```cpp
// OverlayWnd.cpp
BOOL COverlayWnd::CreateOverlay() {
    CRect vr; // virtual screen
    vr.left   = GetSystemMetrics(SM_XVIRTUALSCREEN);
    vr.top    = GetSystemMetrics(SM_YVIRTUALSCREEN);
    vr.right  = vr.left + GetSystemMetrics(SM_CXVIRTUALSCREEN);
    vr.bottom = vr.top  + GetSystemMetrics(SM_CYVIRTUALSCREEN);

    LPCTSTR cls = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW, ::LoadCursor(NULL, IDC_CROSS), (HBRUSH)GetStockObject(NULL_BRUSH), NULL);
    return CreateEx(WS_EX_TOPMOST|WS_EX_TOOLWINDOW, cls, L"Overlay", WS_POPUP, vr, NULL, 0);
}
```

### 2-2. 그리기: 어둡게 덮고, 선택 영역만 투명하게

```cpp
BEGIN_MESSAGE_MAP(COverlayWnd, CWnd)
    ON_WM_CREATE()
    ON_WM_PAINT()
    ON_WM_ERASEBKGND()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_KEYDOWN()
END_MESSAGE_MAP()

int COverlayWnd::OnCreate(LPCREATESTRUCT cs) {
    ShowWindow(SW_SHOW); SetCapture(); // 즉시 활성화
    return 0;
}
BOOL COverlayWnd::OnEraseBkgnd(CDC*) { return TRUE; }

void COverlayWnd::OnPaint() {
    CPaintDC dc(this);
    CRect rc; GetClientRect(&rc);

    // 반투명 오버레이 느낌(불투명한 Brush로 덮고, 선택영역은 Frame만)
    dc.FillSolidRect(rc, RGB(0,0,0));
    BLENDFUNCTION bf{AC_SRC_OVER,0,128,0}; // 반투명처럼 보이는 밝기 조정용 X
    // 간단화: 진짜 알파가 아닌 단순 어둡게(검정 50%) 표현: 아래처럼 반투명 못하지만 충분히 어둡게.
    dc.FillSolidRect(rc, RGB(0,0,0)); // 이미 위에서 덮었으므로 생략 가능

    if (!m_rcSelect.IsRectEmpty()) {
        // 선택 영역: 밝게 테두리 + 교차선
        CPen pen(PS_SOLID, 2, RGB(0,122,204));
        CBrush* oldBr = (CBrush*)dc.SelectStockObject(NULL_BRUSH);
        CPen* oldPen = dc.SelectObject(&pen);
        dc.Rectangle(&m_rcSelect);
        // 그리드(옵션)
        auto midx=(m_rcSelect.left+m_rcSelect.right)/2;
        auto midy=(m_rcSelect.top+m_rcSelect.bottom)/2;
        dc.MoveTo(midx, m_rcSelect.top); dc.LineTo(midx, m_rcSelect.bottom);
        dc.MoveTo(m_rcSelect.left, midy); dc.LineTo(m_rcSelect.right, midy);
        dc.SelectObject(oldPen); dc.SelectObject(oldBr);
    }

    // 좌표/크기 디스플레이
    if (!m_rcSelect.IsRectEmpty()) {
        CStringW info; info.Format(L"%d x %d", m_rcSelect.Width(), m_rcSelect.Height());
        CRect tip = m_rcSelect; tip.bottom = tip.top - 20; tip.top -= 40;
        dc.SetBkMode(TRANSPARENT);
        dc.SetTextColor(RGB(255,255,255));
        dc.DrawText(info, &tip, DT_CENTER|DT_VCENTER|DT_SINGLELINE);
    }
}
```

### 2-3. 입력: 드래그·이동·키보드(ESC/Enter/Space)

```cpp
void COverlayWnd::OnLButtonDown(UINT, CPoint pt) {
    if (!m_rcSelect.IsRectEmpty() && m_rcSelect.PtInRect(pt)) {
        m_move = true; m_anchor = pt;
    } else {
        m_drag = true; m_anchor = pt;
        m_rcSelect.SetRect(pt.x, pt.y, pt.x, pt.y);
    }
    Invalidate(FALSE);
}
void COverlayWnd::OnMouseMove(UINT, CPoint pt) {
    if (m_drag) {
        m_rcSelect.right  = pt.x;
        m_rcSelect.bottom = pt.y;
        m_rcSelect.NormalizeRect();
        Invalidate(FALSE);
    } else if (m_move) {
        CPoint d = pt - m_anchor; m_anchor = pt;
        m_rcSelect.OffsetRect(d);
        Invalidate(FALSE);
    }
}
void COverlayWnd::OnLButtonUp(UINT, CPoint) { m_drag=false; m_move=false; ReleaseCapture(); SetCapture(); }

BOOL COverlayWnd::OnKeyDown(UINT vk, UINT, UINT) {
    if (vk==VK_ESCAPE) { m_rcSelect.SetRectEmpty(); ShowWindow(SW_HIDE); PostMessage(WM_CLOSE); return TRUE; }
    if (vk==VK_RETURN) { // 확정
        GetParent()->PostMessage(WM_APP+100, 0, 0); // 부모에게 캡처 수행 요청
        ShowWindow(SW_HIDE);
        return TRUE;
    }
    if (vk==VK_SPACE) { m_move=!m_move; return TRUE; }
    return FALSE;
}
```

---

## 3. 실제 캡처(다중 모니터·DPI)

- **가상 스크린** DC(`GetDC(NULL)`)로 **전체 비트맵** 캡처 후, 선택 영역만 **Crop**  
- DPI 영향: 좌표는 픽셀 기준(Per-Monitor-V2 환경에서 이미 픽셀 단위).  
- 모니터별 캡처 정확성이 중요하다면 `EnumDisplayMonitors` + 개별 BitBlt 후 합성도 가능.

```cpp
// CaptureUtil.h
inline HBITMAP CaptureRectToHBITMAP(const CRect& rc) {
    HDC hdcScreen = GetDC(NULL);
    HDC mem = CreateCompatibleDC(hdcScreen);
    HBITMAP hbmp = CreateCompatibleBitmap(hdcScreen, rc.Width(), rc.Height());
    HGDIOBJ old = SelectObject(mem, hbmp);
    BitBlt(mem, 0,0, rc.Width(), rc.Height(), hdcScreen, rc.left, rc.top, SRCCOPY|CAPTUREBLT);
    SelectObject(mem, old);
    DeleteDC(mem); ReleaseDC(NULL, hdcScreen);
    return hbmp;
}
```

- `CAPTUREBLT`로 **반투명/WS_EX_LAYERED** 윈도우까지 포함(드라이버/환경에 따라 일부 제한)

---

## 4. GDI+ Bitmap 변환 & 자동 편집 파이프라인

### 4-1. HBITMAP → GDI+ Bitmap

```cpp
inline std::unique_ptr<Gdiplus::Bitmap> MakeBitmap(HBITMAP hbm) {
    using namespace Gdiplus;
    return std::unique_ptr<Bitmap>(Bitmap::FromHBITMAP(hbm, NULL));
}
```

### 4-2. 테두리/둥근 모서리 + 그림자(옵션)

- 간단 구현: **캔버스 확장** → 배경에 **그림자 비트맵**(가우시안 블러된 마스크) → 본문을 위에 그리기  
- 실전에서는 **Drop Shadow**를 9-패치 형태로 캐싱해 재사용 권장

```cpp
std::unique_ptr<Gdiplus::Bitmap> AddPaddingAndBorder(Gdiplus::Bitmap* src, int pad=12, int radius=6, int border=1) {
    using namespace Gdiplus;
    const int W = src->GetWidth(), H = src->GetHeight();
    std::unique_ptr<Bitmap> dst(new Bitmap(W+pad*2, H+pad*2, PixelFormat32bppPARGB));
    Graphics g(dst.get());
    g.Clear(Color(0,0,0,0));
    g.SetSmoothingMode(SmoothingModeHighQuality);
    // 둥근 영역
    GraphicsPath path;
    auto addRound = [&](Rect r, int rds) {
        path.Reset();
        path.AddArc(r.X, r.Y, rds*2, rds*2, 180, 90);
        path.AddArc(r.GetRight()-rds*2, r.Y, rds*2, rds*2, 270, 90);
        path.AddArc(r.GetRight()-rds*2, r.GetBottom()-rds*2, rds*2, rds*2, 0, 90);
        path.AddArc(r.X, r.GetBottom()-rds*2, rds*2, rds*2, 90, 90);
        path.CloseFigure();
    };
    addRound(Rect(0,0,W+pad*2,H+pad*2), radius+pad/2); // 바깥 그림자용

    // (간단 그림자) 약한 외곽선
    Pen sh(Color(32,0,0,0), (Gdiplus::REAL)pad/2);
    g.DrawPath(&sh, &path);

    // 본문
    addRound(Rect(pad, pad, W, H), radius);
    g.SetClip(&path);
    g.DrawImage(src, pad, pad, W, H);
    g.ResetClip();

    // 보더
    if (border>0) {
        Pen pen(Color(160,220,220,220), (Gdiplus::REAL)border);
        g.DrawPath(&pen, &path);
    }
    return dst;
}
```

### 4-3. 민감영역 블러

- **GDI+ 1.1**의 `Gdiplus::Blur` 효과(Windows 7+) 사용(헤더 `gdipluseffects.h`)  
- 선택영역마다 블러 적용(여러 박스를 지원). 반대로 **모자이크**는 간단한 **샘플링 축소 후 확대**로 구현 가능.

```cpp
#include <gdipluseffects.h>
#pragma comment(lib, "gdiplus.lib")

bool ApplyGaussianBlur(Gdiplus::Bitmap* bmp, const Gdiplus::Rect& r, float radius=8.0f) {
    using namespace Gdiplus;
    // 부분 영역만 복사 → 블러 → 되붙이기 (이미지 전체에 효과 적용 시 성능 저하)
    Bitmap sub(r.Width, r.Height, PixelFormat32bppPARGB);
    {
        Graphics g(&sub);
        g.DrawImage(bmp, Rect(0,0,r.Width,r.Height), r.X,r.Y,r.Width,r.Height, UnitPixel);
    }
    BlurParams params{ radius, TRUE };
    Blur blur; if (blur.SetParameters(&params) != Ok) return false;

    if (sub.ApplyEffect(&blur, NULL) != Ok) return false;
    {
        Graphics g(bmp);
        g.DrawImage(&sub, r);
    }
    return true;
}
```

> **모자이크(픽셀화)**  
> `GetThumbnailImage()` 또는 `DrawImage`에서 **작게 줄였다가** 다시 크게 그리는 방식(NearestNeighbor)으로 구현하면 간단.

### 4-4. 리사이즈 규칙

- **긴 변 기준**: 1400px (블로그/이슈 공유에 적당)  
- 확대는 기본 비권장(이미지 품질 저하), 필요 시 HQBicubic

```cpp
std::unique_ptr<Gdiplus::Bitmap> ResizeLongSide(Gdiplus::Bitmap* src, int longSide=1400) {
    using namespace Gdiplus;
    int W = src->GetWidth(), H = src->GetHeight();
    int L = max(W,H);
    if (L <= longSide) return std::unique_ptr<Bitmap>((Bitmap*)src->Clone(0,0,W,H,PixelFormat32bppPARGB));
    double s = (double)longSide / L;
    int nw = (int)std::round(W*s), nh = (int)std::round(H*s);
    std::unique_ptr<Bitmap> dst(new Bitmap(nw, nh, PixelFormat32bppPARGB));
    Graphics g(dst.get());
    g.SetInterpolationMode(InterpolationModeHighQualityBicubic);
    g.DrawImage(src, Rect(0,0,nw,nh), 0,0,W,H, UnitPixel);
    return dst;
}
```

---

## 5. 저장 & 클립보드 & 임시파일

### 5-1. PNG/JPEG 저장(품질)

```cpp
// encoder CLSID 찾기
inline bool GetEncoderClsid(const wchar_t* mime, CLSID* pClsid) {
    using namespace Gdiplus;
    UINT n=0, size=0; GetImageEncodersSize(&n,&size);
    if (!size) return false; std::vector<BYTE> buf(size);
    ImageCodecInfo* ici = (ImageCodecInfo*)buf.data(); GetImageEncoders(n,size,ici);
    for (UINT i=0;i<n;++i){ if (wcscmp(ici[i].MimeType,mime)==0){ *pClsid=ici[i].Clsid; return true; } }
    return false;
}
bool SavePng(Gdiplus::Bitmap* bmp, const std::wstring& path) {
    CLSID id{}; if (!GetEncoderClsid(L"image/png",&id)) return false;
    return bmp->Save(path.c_str(), &id, nullptr) == Gdiplus::Ok;
}
bool SaveJpeg(Gdiplus::Bitmap* bmp, const std::wstring& path, ULONG quality=90) {
    CLSID id{}; if (!GetEncoderClsid(L"image/jpeg",&id)) return false;
    Gdiplus::EncoderParameters ep; ep.Count=1;
    ep.Parameter[0].Guid = Gdiplus::EncoderQuality;
    ep.Parameter[0].Type = Gdiplus::EncoderParameterValueTypeLong;
    ep.Parameter[0].NumberOfValues = 1;
    ep.Parameter[0].Value = &quality;
    return bmp->Save(path.c_str(), &id, &ep) == Gdiplus::Ok;
}
```

### 5-2. 임시 경로 & 원자적 저장

```cpp
std::wstring MakeTempPngPath() {
    wchar_t dir[MAX_PATH]; GetTempPathW(MAX_PATH, dir);
    SYSTEMTIME st; GetLocalTime(&st);
    wchar_t name[64]; swprintf_s(name, L"cap_%04d%02d%02d_%02d%02d%02d.png",
        st.wYear,st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond);
    return std::wstring(dir) + name;
}
bool SaveAtomic(Gdiplus::Bitmap* bmp, const std::wstring& path) {
    auto tmp = path + L".tmp";
    if (!SavePng(bmp, tmp)) return false;
    return !!MoveFileExW(tmp.c_str(), path.c_str(), MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH);
}
```

### 5-3. 클립보드에 이미지/파일경로 넣기

- 이미지: DIB/BMP로 넣는 것이 가장 호환  
- 링크(업로드 후): CF_UNICODETEXT URL

```cpp
bool CopyFilePathToClipboard(const std::wstring& path) {
    if (!OpenClipboard(NULL)) return false;
    EmptyClipboard();
    size_t bytes = (path.size()+1)*sizeof(wchar_t);
    HGLOBAL h = GlobalAlloc(GMEM_MOVEABLE, bytes);
    memcpy(GlobalLock(h), path.c_str(), bytes);
    GlobalUnlock(h);
    SetClipboardData(CF_UNICODETEXT, h);
    CloseClipboard(); return true;
}
```

---

## 6. 업로드 UX — WinHTTP 백그라운드 + 진행표시 + 자동 링크 복사

> 실제 업로드 서버가 없을 수 있어, 아래는 **멀티파트 업로드 예시**(임의 URL).  
> 실패/재시도/취소/프록시 고려(간결 버전).

### 6-1. 업로드 스레드

```cpp
#include <winhttp.h>
#pragma comment(lib,"winhttp.lib")

struct UploadTask {
    std::wstring url; // L"https://example.com/upload"
    std::wstring filePath;
    HWND hNotify{}; // 진행/완료 통지용
};

DWORD WINAPI UploadThread(LPVOID p) {
    auto t = (UploadTask*)p;
    // URL 파싱
    URL_COMPONENTS uc{}; uc.dwStructSize=sizeof(uc);
    wchar_t host[256], path[1024];
    uc.lpszHostName=host; uc.dwHostNameLength=_countof(host);
    uc.lpszUrlPath=path; uc.dwUrlPathLength=_countof(path);
    WinHttpCrackUrl(t->url.c_str(), 0, 0, &uc);
    HINTERNET h = WinHttpOpen(L"CapUploader/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, 0,0,0);
    bool ok=false;
    if (h) {
        HINTERNET c=WinHttpConnect(h, host, uc.nPort, 0);
        if (c) {
            bool secure = (uc.nScheme==INTERNET_SCHEME_HTTPS);
            HINTERNET r=WinHttpOpenRequest(c, L"POST", path, NULL, WINHTTP_NO_REFERER,
                                            WINHTTP_DEFAULT_ACCEPT_TYPES, secure?WINHTTP_FLAG_SECURE:0);
            if (r) {
                // 간단 멀티파트 본문 구성
                std::string boundary = "----CapBoundary7d3e2b";
                std::string head = "--"+boundary+"\r\nContent-Disposition: form-data; name=\"file\"; filename=\"capture.png\"\r\nContent-Type: image/png\r\n\r\n";
                std::string tail = "\r\n--"+boundary+"--\r\n";

                // 파일 읽기
                HANDLE hf = CreateFileW(t->filePath.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr);
                if (hf!=INVALID_HANDLE_VALUE) {
                    LARGE_INTEGER li; GetFileSizeEx(hf,&li);
                    DWORD bodyLen = (DWORD)(head.size()+li.QuadPart+tail.size());
                    std::wstring hdr = L"Content-Type: multipart/form-data; boundary=" + std::wstring(boundary.begin(), boundary.end());

                    WinHttpAddRequestHeaders(r, hdr.c_str(), (DWORD)-1, WINHTTP_ADDREQ_FLAG_ADD|WINHTTP_ADDREQ_FLAG_REPLACE);

                    if (WinHttpSendRequest(r, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, bodyLen, 0)) {
                        // 보냄
                        DWORD w=0;
                        WinHttpWriteData(r, head.data(), (DWORD)head.size(), &w);

                        const DWORD CH=64*1024; BYTE buf[CH];
                        for(;;){
                            DWORD rd=0; if (!ReadFile(hf, buf, CH, &rd, nullptr) || rd==0) break;
                            WinHttpWriteData(r, buf, rd, &w);
                            // 진행 알림
                            PostMessage(t->hNotify, WM_APP+200, (WPARAM)rd, (LPARAM)li.QuadPart);
                        }
                        CloseHandle(hf);
                        WinHttpWriteData(r, tail.data(), (DWORD)tail.size(), &w);
                        WinHttpReceiveResponse(r, nullptr);
                        ok=true;
                    }
                    WinHttpCloseHandle(r);
                }
            }
            WinHttpCloseHandle(c);
        }
        WinHttpCloseHandle(h);
    }
    PostMessage(t->hNotify, WM_APP+201, ok, 0); // 완료
    delete t; return 0;
}
```

### 6-2. UI 통합

- 업로드 시작 → 프로그레스(불확정이라도) → 완료시 **URL 텍스트**를 **클립보드 복사**  
- 실패 → “재시도” 버튼

---

## 7. 전체 “캡처→편집→저장/업로드” 플로우 (핵심 시퀀스)

```
[Hotkey] → CreateOverlay (최상위 표시)
    ↓
[사용자 드래그] → m_rcSelect 확정(Enter)
    ↓
CaptureRectToHBITMAP(m_rcSelect)
    ↓
GDI+ Bitmap 변환
    ↓
(옵션) 자동 편집:
  - AddPaddingAndBorder → ApplyGaussianBlur(지정 영역들) → ResizeLongSide
    ↓
저장(원자적) → TempPath .png
    ↓
클립보드: 파일경로 or 이미지 자체
    ↓
(선택) 업로드 시작:
  - WinHTTP 스레드 → 진행 UI → 완료 URL 복사
```

---

## 8. 핫키/트레이/설정(요약)

- 전역 단축키: `RegisterHotKey(hWnd, 1, MOD_CONTROL|MOD_SHIFT, 'S');`
- 트레이로 “캡처”, “환경설정”, “최근 업로드 링크” 제공
- 설정 JSON:
  - **긴 변 픽셀**, **PNG/JPEG 품질**, **자동 그림자/테두리**, **기본 업로드 on/off**, **업로드 URL**, **마스킹(정규식) 규칙**  
  - **대상 경로**(데스크톱/문서/커스텀)

---

## 9. 신뢰성/안전/성능 팁

1) **오버레이가 캡처에 찍히지 않게**: 오버레이는 확정 직전 **숨김** → 즉시 BitBlt → 다시 복구(여유 1 frame도 안 보이게)  
2) **DPI 전환**: Per-Monitor-V2에서 모니터 이동 시 `WM_DPICHANGED` 수신 → 오버레이 다시 생성 권장  
3) **CAPTUREBLT 실패**: 일부 앱(보안/DRM)은 캡처 차단 → “캡처 불가 영역” 안내  
4) **블러 속도**: 큰 영역은 블러 비용 큼 → **모자이크**를 기본, 블러는 **작은 영역**만  
5) **업로드 실패 복구**: 임시 파일을 **최근 N개 목록**으로 보관 → “다시 업로드”  
6) **원자 저장**: `.tmp` → `MoveFileEx(...REPLACE...)`  
7) **단축키 충돌**: 등록 실패 시 사용자 조합 변경 UX 제공

---

## 10. 통합 예제(요약, 핵심 파트만)

```cpp
// CMainDlg::OnHotkeyCapture
void CMainDlg::OnHotkeyCapture() {
    if (!m_overlay.m_hWnd) m_overlay.CreateOverlay();
    else { m_overlay.ShowWindow(SW_SHOW); SetForegroundWindow(m_overlay); }
}

// 선택 확정 알림 핸들러
afx_msg LRESULT CMainDlg::OnOverlayDone(WPARAM, LPARAM) {
    CRect r = m_overlay.m_rcSelect; if (r.IsRectEmpty()) return 0;
    m_overlay.ShowWindow(SW_HIDE); // 오버레이 숨김 후 바로 캡처
    HBITMAP hb = CaptureRectToHBITMAP(r);
    auto bmp = MakeBitmap(hb); DeleteObject(hb);
    if (!bmp) return 0;

    // 자동 편집
    auto withBorder = AddPaddingAndBorder(bmp.get(), 12, 6, 1);
    auto resized    = ResizeLongSide(withBorder.get(), 1400);

    // (옵션) 블러 구역이 있다면 반복 적용
    // ApplyGaussianBlur(resized.get(), Rect(...), 8.0f);

    auto path = MakeTempPngPath();
    SaveAtomic(resized.get(), path);

    // 업로드 옵션
    if (m_autoUpload) {
        auto t = new UploadTask; t->url = m_uploadUrl; t->filePath = path; t->hNotify = m_hWnd;
        CreateThread(nullptr,0,UploadThread,t,0,nullptr);
        SetStatus(L"업로드 시작: " + path);
    } else {
        CopyFilePathToClipboard(path);
        SetStatus(L"파일 저장 & 경로 복사됨: " + path);
    }
    return 0;
}
```

---

## 11. 테스트 체크리스트

- [ ] 다중 모니터(왼쪽 음수 좌표 포함)에서 정확한 캡처  
- [ ] 고DPI(125/150/200%)에서 선택 크기와 결과 픽셀 매칭  
- [ ] 오버레이 숨김 후 캡처(오버레이가 찍히지 않음)  
- [ ] 블러/모자이크 성능(FullHD/4K)  
- [ ] 긴 변 리사이즈 정확성, PNG/JPEG 품질  
- [ ] 업로드 진행/실패/재시도, 링크 자동 복사  
- [ ] 임시 파일 롤링(최근 N개 보관)  
- [ ] 단축키 충돌 시 안내/변경

---

## 12. 확장 아이디어

- **화살표/사각형/텍스트 어노테이션**(레이어, Undo/Redo)  
- **자동 마스킹 규칙**: 숫자 16자리/이메일/주민번호 등 정규식 → 즉시 모자이크  
- **GIF/MP4 녹화**(비디오 캡처로 확장, Desktop Duplication API/FFmpeg)  
- **팀 공유**: 사내 S3/Blob 업로드 + 만료/권한 제어  
- **OCR**: 선택 영역 → 텍스트 추출(Windows OCR API)

---

## 13. 문제 해결

- **PrintScreen 류 앱과 충돌**: 핫키 경쟁 → 사용자 설정으로 변경  
- **일부 UWP 앱 캡처 불가**: OS 정책. 대체 경로(Desktop Duplication API) 검토  
- **알파/반투명 테마**: DWM 효과가 캡처에 반영되지 않으면 `CAPTUREBLT` 체크  
- **업로드 SSL 실패**: WinHTTP 옵션/루트 인증서 이슈 → `WINHTTP_OPTION_SECURITY_FLAGS` 조정

---

## 14. 마무리

캡처 도구의 본질은 **빠른 선택 → 유용한 자동 편집 → 즉시 공유**입니다.  
여기 제시한 구조(오버레이·BitBlt·GDI+ 편집·원자 저장·백그라운드 업로드)는 가볍고도 견고합니다.

- **사용자는** 2~3번의 키/클릭으로 결과를 얻고,  
- **개발자는** DPI·멀티모니터·안전 저장·네트워크 실패까지 한 번에 대비할 수 있습니다.
