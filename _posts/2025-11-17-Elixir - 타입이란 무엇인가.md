---
layout: post
title: Elixir - 타입이란 무엇인가
date: 2025-11-17 17:25:23 +0900
category: Elixir
---
# 9장 — 엘릭서 타입 시스템, 타입스펙, Dialyzer 완전 정리

## 엘릭서에서 타입이란

### 런타임 타입 vs 타입 명세(Typespec)

엘릭서는 **동적 타입 언어**다. 실행 시점에 값이 실제 타입을 가지며,
정적 타입 언어처럼 “컴파일이 막히는” 타입 오류는 없다.

그러나 동시에, 엘릭서는 **정적 타입 문서·검사 도구**를 제공한다.

- **런타임 관점**
  - 값은 항상 실제 타입을 가진다.
  - `is_integer/1`, `is_map/1`, `is_list/1` 같은 **가드(guard)** 로 분기할 수 있다.
  - 패턴 매칭/가드로 "타입 비슷한 것"을 검사한다.

- **개발/검사 관점**
  - `@type`, `@opaque`, `@typep` 으로 **사용자 정의 타입**을 선언한다.
  - `@spec` 으로 함수의 **입력/출력 타입 계약**을 설명한다.
  - Dialyzer가 전체 코드를 분석해 **계약과 실제 코드 흐름이 어긋나는 지점**을 경고한다.
    (정적 타입 언어처럼 완전히 사운드한 시스템은 아니고, **success typing** 방식이다.)

정리하면:

- **실행**은 동적(자유롭다).
- **계약/설계**는 정적(타입 명세와 분석 도구로 보조).

간단한 예:

```elixir
defmodule Calc do
  @typedoc "자연수(0 포함)"
  @type nat :: non_neg_integer()

  @doc "두 자연수의 합"
  @spec add(nat, nat) :: nat
  def add(a, b)
      when is_integer(a) and a >= 0 and
           is_integer(b) and b >= 0 do
    a + b
  end
end
```

포인트:

- `@type nat :: non_neg_integer()`
  → “이 프로젝트에서 `nat` 이라는 개념은 non_neg_integer()다”라는 이름을 붙인다.
- `@spec add(nat, nat) :: nat`
  → `add/2`가 “자연수 두 개를 받아 자연수 하나를 돌려준다”고 문서화. Dialyzer는 이 계약 위반 가능성을 분석할 수 있다.
- `when is_integer(a) and a >= 0 ...`
  → 런타임에서 **가드**로 실제 값을 필터링한다.
    (이 가드 정보도 Dialyzer 분석에 쓰인다.)

실제 개발에서는 다음 같이 사용하게 된다.

- 핵심 도메인 타입과 API에는 **꼭 @spec, @type**을 붙인다.
- Dialyzer를 CI에 넣어, 타입 계약을 깨는 변경을 자동으로 잡는다.
- 가드/패턴 매칭으로 런타임에서 값을 **정제(refinement)** 한다.

---

### 엘릭서/얼랭 타입 우주 한눈에

대표적인 **원시/합성 타입**들을 표로 정리하면 다음과 같다.

| 분류 | 타입/예시 | 가드/설명 |
|---|---|---|
| 숫자 | `integer()`, `float()`, `non_neg_integer()` | `is_integer/1`, `is_float/1` |
| 불리언 | `boolean()` (`true | false`) | `is_boolean/1` |
| 아톰 | `atom()` (`:ok`, `:error`, `:user`) | `is_atom/1` |
| 리스트 | `list(T)`, `nonempty_list(T)`, `charlist()` | 연결 리스트, 머리/꼬리 패턴 매칭 |
| 튜플 | `{T1, T2, ...}`, `tuple()` | 고정 길이, 위치 기반 |
| 맵 | `%{K => V}`, `%{required(K) => V, optional(K2) => V2}` | 키/값 딕셔너리 |
| 구조체 | `%Module{...}` | 맵의 특수형, 필드 고정, 모듈 네임스페이스 |
| 바이너리/비트스트링 | `binary()`, `bitstring()`, `<<_::size>>` | 문자열은 UTF-8 바이너리 |
| 함수 | `(A -> B)` | `is_function/1,2` |
| PID/Ref/Port | `pid()`, `reference()`, `port()` | 프로세스, 참조, 포트(외부 리소스) |
| 유니온/리터럴 | `A | B`, `:ok | {:error, term()}` | 합 타입 표현 |
| 최상/최하 | `term()`, `none()` | 모든 값 / 도달 불가 |
| 기타 자주 쓰는 별칭 | `iodata()`, `iolist()`, `keyword(T)` | 문자열 생성, 옵션 리스트 등 |

중요 포인트 몇 가지:

1. **문자열과 charlist 구분**

   - `"abc"` : `String.t()` = UTF-8 `binary()`
   - `'abc'` : `charlist()` = `[97, 98, 99]` (정수 리스트)

   ```elixir
   is_binary("abc")   # true
   is_list('abc')     # true
   ```

2. **리스트**

   ```elixir
   [1, 2, 3]         # list(integer())
   [h | t] = [1, 2]  # h = 1, t = [2]
   ```

3. **맵**

   ```elixir
   m = %{id: 1, "name" => "Kim"}
   is_map(m)         # true
   ```

4. **PID/Ref/Port**

   - `self()` : 현재 프로세스의 `pid()`
   - `make_ref()` : 유일한 `reference()`
   - Port : 외부(파일, TCP 소켓 등)와의 연결 핸들

엘릭서에서 “타입을 안다”는 것은 이 우주를 머리에 넣어두고,
주어진 문제를 이 조합으로 표현할 수 있느냐의 문제라고 봐도 좋다.

---

### 타입 합성 규칙: 유니온·제품·맵 스펙

엘릭서 타입스펙은 **유니온(union)**, **제품(product, 튜플/리스트)**,
**맵/구조체 스펙**을 조합해서 꽤 표현력이 풍부한 타입을 만들 수 있다.

#### 유니온 타입

성공/실패 패턴:

```elixir
@type result(a, e) :: {:ok, a} | {:error, e}
```

이 타입은 수학적으로 대충 다음과 같이 볼 수 있다.

$$
\mathrm{result}(A, E)
= \{ {:ok, a} \mid a \in A \} \cup \{ {:error, e} \mid e \in E \}
$$

실전 예:

```elixir
@spec parse(String.t()) :: result(map(), :invalid | :missing)
def parse(bin) when is_binary(bin) do
  cond do
    bin == ""      -> {:error, :missing}
    String.contains?(bin, "=") -> {:ok, %{}}
    true           -> {:error, :invalid}
  end
end
```

#### 제품 타입(튜플/리스트)

```elixir
@type pair(a, b) :: {a, b}
@type kv(k, v)   :: {k, v}
@type string_list :: [String.t()]
```

튜플은 데카르트 곱:

$$
A \times B = \{ (a, b) \mid a \in A,\ b \in B \}
$$

리스트는 “0개 이상의 원소”의 순서 있는 모음.

#### 맵 타입 — required / optional 키

맵 타입에서 키의 필수/선택 여부를 지정할 수 있다.

```elixir
@type user_map :: %{
  required(:id)    => pos_integer(),
  required(:email) => String.t(),
  optional(:name)  => String.t(),
  optional(:meta)  => map()
}
```

- 필수 키 누락은 Dialyzer가 잡아낼 수 있는 중요한 계약이다.
- 선택 키는 있어도 되고 없어도 되며, 있을 경우 타입을 맞춰야 한다.

이렇게 명시해두면 나중에 코드를 읽는 사람도
“이 맵이 어떤 구조인지”를 한눈에 파악할 수 있다.

---

### 가드와 패턴 매칭은 “런타임 정제(Refinement)”

패턴 매칭과 가드는 **실제 값을 검사**한다.
이 정보는 개발자 관점에서는 “타입을 더 좁힌다”고 볼 수 있다.

예:

```elixir
def head([h | _]), do: {:ok, h}
def head([]),       do: :error
```

- 첫 절은 “nonempty_list()를 받은 경우”를 처리한다.
- 둘째 절은 “empty list” 처리.

이 함수에 대한 타입은 보통:

```elixir
@spec head(list(a)) :: {:ok, a} | :error
```

처럼 쓴다. Dialyzer는 패턴 정보를 이용해
“이 호출 경로에서는 `head/1`이 :error를 절대 반환할 수 없다” 같은 사실도 추론한다.

또 다른 예:

```elixir
def only_positive(xs) when is_list(xs) do
  Enum.filter(xs, fn x -> is_integer(x) and x > 0 end)
end
```

- 필터 이후 리스트에는 “양의 정수만 있다”는 의도가 명확하지만,
  Dialyzer가 완전하게 추론해주지는 못할 수 있다.
- 이럴 때는 타입 명세를 **너무 공격적으로 좁히지 말고**
  현실적인 수준으로 잡는 것이 좋다.

정리하면:

- **패턴/가드** : 런타임에 실제 값을 필터링한다 → “정제된” 타입처럼 행동.
- **@spec/@type** : 설계자·사용자·도구에게 “이 함수는 이런 값들을 받는다/돌려준다”를 알려주는 **계약**.

---

### @type / @opaque / @typep — 공개/캡슐화/모듈 내부

엘릭서 타입 선언에는 세 가지가 있다.

1. `@type`   : 공개 타입 별칭 (외부에서 구조를 알아도 된다)
2. `@opaque` : 공개 타입이지만 **내부 구조는 숨김** (추상 타입)
3. `@typep`  : 모듈 내부 전용 타입 별칭 (private)

예제:

```elixir
defmodule Money do
  @opaque t :: %__MODULE__{amount: integer(), currency: atom()}
  defstruct [:amount, :currency]

  @spec new(integer(), atom()) :: t
  def new(amount, cur)
      when is_integer(amount) and is_atom(cur) do
    %__MODULE__{amount: amount, currency: cur}
  end

  @spec amount(t) :: integer()
  def amount(%__MODULE__{amount: a}), do: a

  @spec currency(t) :: atom()
  def currency(%__MODULE__{currency: c}), do: c
end
```

- 외부에는 `Money.t()` 라는 타입이 보인다.
- 하지만 `@opaque` 덕분에 “내부가 구조체이고 필드가 이렇게 생겼다”는 사실은
  Dialyzer 관점에서 감춰진다.
  외부 모듈이 패턴 매칭으로 내부 필드를 직접 건드리면 경고가 날 수 있다.

이렇게 하면:

- Money의 내부 표현을 나중에 **맵 → 레코드 → 구조체 → 다른 것**으로 바꿔도,
  외부 코드는 크게 영향 받지 않는다.
- `@opaque` 타입은 사실상 **추상 데이터 타입(ADT)** 처럼 동작한다.

`@typep` 는 모듈 내부에만 쓰는 타입 별칭이다.

```elixir
@typep cents :: non_neg_integer()
```

외부에는 공개할 필요가 없지만, 내부에서 타입 표기를 간결하게 하고 싶을 때 사용한다.

---

### 함수 타입, 다형성, 타입 변수

엘릭서 타입스펙은 **다형성(polymorphism)** 을 타입 변수로 표현할 수 있다.
(컴파일러가 제네릭을 강제하는 것은 아니고, **문서적 의미**에 가깝다.)

```elixir
@spec my_map(list(a), (a -> b)) :: list(b) when a: var, b: var
def my_map([h | t], f), do: [f.(h) | my_map(t, f)]
def my_map([], _),      do: []
```

- `a`, `b` 는 타입 변수다.
- “아무 타입 a 리스트와 a→b 함수가 들어오면, b 리스트를 돌려준다”는 의미.
- Dialyzer가 이 정보를 이용해 함수를 호출하는 쪽을 분석할 수 있다.

실제 프로젝트에서는 `when a: var, b: var` 같은 부분을 생략하고,
그냥 다음처럼 쓰는 경우가 많다.

```elixir
@spec my_map(list(a), (a -> b)) :: list(b)
```

단순한 예제: 제네릭 Stack

```elixir
defmodule Stack do
  @type t(a) :: [a]

  @spec new() :: t(a)
  def new, do: []

  @spec push(t(a), a) :: t(a)
  def push(stack, x), do: [x | stack]

  @spec pop(t(a)) :: {:ok, a, t(a)} | :empty
  def pop([h | t]), do: {:ok, h, t}
  def pop([]),      do: :empty
end
```

- `Stack.t(a)` 는 “원소 타입이 a인 스택”이라는 의미다.
- 실제로 Stack 구현은 그냥 리스트지만, 타입으로 의미를 표현할 수 있다.

---

### 자주 쓰는 내장 타입 별칭 정리

프로젝트 전반에서 자주 쓰이는 개념에는
**타입 별칭**을 일관되게 정의해 두는 것이 좋다.

```elixir
@type id        :: pos_integer()
@type name      :: String.t()
@type email     :: String.t()
@type json      :: map()  # 엄밀히는 더 좁힐 수 있지만 실용적으로 사용
@type endpoint  :: String.t()
@type timeout   :: non_neg_integer()

@type headers ::
        %{optional(String.t()) => String.t()}
        | keyword(String.t())

@type ok(a)     :: {:ok, a}
@type err()     :: {:error, term()}
@type result(a) :: ok(a) | err()
```

이렇게 모듈 하나에 `Types` 나 `Domain.Types` 등의 이름으로 모아 두면:

- 문서가 통일된다.
- 코드 리뷰할 때 “이 함수는 result(a)를 돌려준다” 같은 문장이 의미 있게 읽힌다.
- Dialyzer 경고도 읽기 편해진다.

---

### 문자열 vs 차리스트, 바이너리/비트스트링

엘릭서를 쓸 때 가장 많이 헷갈리는 것 중 하나가 **문자열/charlist/바이너리 구분**이다.

```elixir
iex> is_binary("한글")
true

iex> is_list('한')
true

iex> byte_size("한")
3

iex> String.length("한")
1
```

- `"한글"` : UTF-8 인코딩된 `binary()` (문자열)
- `'한'`   : `[54620]` 같은 정수 리스트 (charlist)

Typespec 쪽에서는:

- `String.t()` = UTF-8 `binary()`
- `charlist()` = `list(char())` = `list(0..0x10FFFF)`

바이너리 매칭 예:

```elixir
<<a::utf8, rest::binary>> = "가나"

a     # 44032
rest  # "나"
```

이 패턴은 네트워크 프로토콜 파싱, 파일 포맷 파싱 등에 매우 자주 쓰인다.

간단한 바이너리 기반 프로토콜 예:

```elixir
defmodule Wire do
  @type u8 :: 0..255
  @type packet :: %{type: u8, len: u8, payload: binary()}

  @spec parse(binary()) :: {:ok, packet} | {:error, :short}
  def parse(<<type::unsigned-integer-size(8),
              len::unsigned-integer-size(8),
              payload::binary-size(len), _rest::binary>>) do
    {:ok, %{type: type, len: len, payload: payload}}
  end

  def parse(_), do: {:error, :short}
end
```

- 타입 스펙과 비트 매칭이 합쳐지면 **프로토콜 명세서**가 코드로 옮겨진 느낌을 줄 수 있다.

---

### 맵/구조체의 타입과 패턴매칭 협력

앞에서 구조체를 따로 다뤘지만,
여기서는 타입스펙 관점에서 다시 보자.

```elixir
defmodule User do
  @type id :: pos_integer()
  @enforce_keys [:id, :email]
  defstruct [:id, :email, name: nil]

  @type t :: %__MODULE__{
          id: id,
          email: String.t(),
          name: String.t() | nil
        }
end
```

JSON에서 User를 파싱하는 함수:

```elixir
@spec load_user(map()) :: {:ok, User.t()} | {:error, term()}
def load_user(%{"id" => id, "email" => e})
    when is_integer(id) and id > 0 and is_binary(e) do
  {:ok, %User{id: id, email: e}}
end

def load_user(_), do: {:error, :bad}
```

- 타입 관점에서:
  - 입력: 문자열 키를 가진 맵 (`map()` 이지만 실제로는 JSON 형태)
  - 출력: `{:ok, User.t()}` 또는 `{:error, reason}`
- 패턴 매칭/가드로 런타임에서 입력을 정제한다.
- `User.t()` 정의 덕분에, 이 함수의 의미가 문서적으로 명확하다.

맵 타입만으로도 비슷한 일을 할 수 있다.

```elixir
@type user_map_in :: %{
  required("id") => integer(),
  required("email") => String.t(),
  optional(String.t()) => term()
}

@spec load_user(user_map_in) :: {:ok, User.t()} | {:error, term()}
```

이렇게 타입을 써두면, JSON 스키마 문서를 코드에 직접 옮겨놓은 셈이 된다.

---

### Dialyzer: 성공 타이핑과 경고 해석

Dialyzer는 다음 철학을 가진 도구다.

- “사용 중인 코드에서 **틀렸을 가능성이 높은 부분**을 찾는다.”
- “거짓 양성을 최소화한다.” (거의 확실한 버그만 경고)

즉, 정적 타입 언어 컴파일러처럼
“이건 타입 안 맞으니까 컴파일 안 해”가 아니라,

- “이 코드는 이 계약에 따르면 **실행 중에 실패할 것 같다**” 정도에 해당하는 부분만 찍어준다.

전형적인 경고와 교정 패턴:

#### no match of right hand side value / no_return 관련

```elixir
@spec head(nonempty_list(a)) :: a
def head([h | _]), do: h
```

- 만약 다른 코드에서 `head([])`가 호출될 가능성이 있다면, Dialyzer는 이를 경고할 수 있다.
- 교정:
  - 정말 nonempty_list만 들어오도록 보장할 수 있다면, 호출부를 고친다.
  - 그렇지 않다면 `head([])` 절을 추가하고 스펙을 넓히거나, `{:ok, h} | :error` 같은 타입으로 바꾼다.

#### incompatible types in assignment

```elixir
@spec only_pos(list(integer())) :: list(pos_integer())
def only_pos(xs), do: Enum.filter(xs, &(&1 > 0))
```

Dialyzer 입장에서는:

- `Enum.filter/2` 는 “입력 리스트와 같은 타입의 리스트를 돌려준다”고 정리되어 있다.
- `&(&1 > 0)` 가 정말로 모든 음수를 제거한다는 사실을 강하게 추론하지 않는다.

그래서 “결과가 pos_integer() 리스트라고 보기 어렵다”고 경고할 수 있다.

교정 방법:

- 결과 스펙을 `list(integer())` 수준으로 넉넉하게 잡는다.
- 혹은:

```elixir
def only_pos(xs) do
  for x <- xs, is_integer(x), x > 0, do: x
end
```

처럼 직접 comprehension을 써서 더 정제된 정보가 전달되도록 한다.

#### contract not fulfilled

```elixir
@spec add_timeout(%{required(:timeout) => non_neg_integer()}) :: non_neg_integer()
def add_timeout(m), do: m.timeout + 1
```

- 점 표기는 구조체 전용이다. `%{}` 맵에 `m.timeout` 접근은 컴파일 에러가 난다.
- 스펙과 구현이 불일치하는 전형적인 예.

교정:

```elixir
def add_timeout(m) do
  m.timeout + 1
end

# 를

def add_timeout(%{timeout: t}) when is_integer(t) and t >= 0 do
  t + 1
end
```

처럼 패턴 매칭을 쓰거나,

```elixir
def add_timeout(m) do
  Map.fetch!(m, :timeout) + 1
end
```

로 바꾼다.

#### Dialyzer를 어떻게 사용할 것인가

보통:

1. `mix.exs` 에 Dialyzer 설정을 추가한다.
2. PLT(분석 베이스)를 한 번 구축한다.
3. CI에서 `mix dialyzer` 를 정기적으로 돌린다.
4. “경고를 모두 없애는” 수준까지 관리하는 게 이상적이다.

실제 업무에서는:

- 새 코드에는 항상 `@spec`을 붙이고,
- Dialyzer 경고는 “우리의 타입 계약과 실제 코드가 어긋나는 신호”로 본다.
- 필요하면 계약(스펙)과 구현 중 어느 쪽이 잘못됐는지 결정해서 맞춘다.

---

### 프로토콜과 타입 멀티메서드

엘릭서의 **프로토콜(protocol)** 은 “타입에 따른 디스패치”를 제공하는 멀티메서드다.

기본 예:

```elixir
defprotocol ToJSON do
  @spec to_json(t) :: map() when t: var
  def to_json(term)
end

defimpl ToJSON, for: User do
  def to_json(%User{id: id, email: e}), do: %{id: id, email: e}
end

defimpl ToJSON, for: Map do
  def to_json(m), do: m
end
```

- `ToJSON.to_json/1` 을 호출할 때, 값의 타입(User인지 Map인지 등)에 따라 다른 구현이 선택된다.
- 타입스펙 측면에서는 “입력 타입이 t이고, 출력은 map()이다”고 명시되어 있다.

이 패턴을 쓰면:

- 도메인 객체(User, Order, Invoice 등)에 대해 각각 JSON 변환, 로깅, 직렬화 등 공통 작업을 정의할 수 있다.
- 새 도메인 타입이 추가되면 해당 타입에 대한 `defimpl` 을 추가하는 것만으로 확장할 수 있다.

---

### sum-type 패턴: 태그드 튜플

엘릭서에는 Haskell/OCaml의 **sum type(알제브라 합 타입)** 키워드가 없다.
대신 **태그드 튜플**이 사실상 표준 패턴이다.

예: 파서 결과 타입

```elixir
@type parse_ok   :: {:ok, map()}
@type parse_err  :: {:error, :invalid | :missing}
@type parse_res  :: parse_ok | parse_err

@spec parse(String.t()) :: parse_res
def parse(bin) when is_binary(bin) do
  cond do
    bin == "" -> {:error, :missing}
    String.contains?(bin, "=") -> {:ok, %{}}
    true -> {:error, :invalid}
  end
end
```

사용자는 `case` 로 분기한다.

```elixir
case parse("a=b") do
  {:ok, m}           -> do_something(m)
  {:error, :missing} -> handle_missing()
  {:error, :invalid} -> handle_invalid()
end
```

태그드 튜플 패턴의 장점:

- 변형 목록을 타입으로 명시할 수 있다.
- 호출부에서 어떤 케이스들을 핸들링해야 하는지 명확해진다.
- 나중에 변형이 추가되면(예: `{:error, :timeout}`), 타입과 패턴 매칭에서 모두 드러난다.

---

### no_return/none — 종료/예외 함수

어떤 함수는 정상적으로는 절대 되돌아오지 않는다.

- 프로세스를 종료시키는 함수
- 무한 루프
- 예외를 바로 던지는 함수

이런 함수는 타입스펙에 `no_return()` 을 쓴다.

```elixir
@spec die(String.t()) :: no_return()
def die(msg), do: raise ArgumentError, msg
```

또 다른 예:

```elixir
@spec loop() :: no_return()
def loop do
  receive do
    :stop -> exit(:normal)
    msg   -> handle(msg); loop()
  end
end
```

이 정보는:

- Dialyzer가 제어 흐름을 분석하는 데 도움이 된다.
- “여기서 예외가 나면 아래 코드는 실행되지 않는다”는 사실을 도구가 이해하도록 한다.

---

### 성능/메모리 관점의 타입 선택

타입은 단지 “형식”이 아니라 **메모리/시간 모델**과도 연결된다.

몇 가지 대표적인 복잡도 메모:

$$
\begin{aligned}
&\text{Map get/put} \approx O(1) \\
&\text{MapSet union/intersection/difference} \approx O(n) \\
&\text{리스트 길이} \; \text{length(xs)} \approx O(n) \\
&\text{맵 머지} \; \text{Map.merge(a,b)} \approx O(n) \\
&\text{바이너리 단순 연결} \; (b_1 \diamond \dots \diamond b_n) \approx O(n^2) \\
&\text{iodata 누적 후 iolist_to_binary} \approx O(n)
\end{aligned}
$$

타입 선택과 성능의 연결 예:

#### 문자열 생성 — iodata()

```elixir
# 나쁜 예: 큰 문자열을 반복해서 이어붙임

report =
  Enum.reduce(rows, "", fn row, acc ->
    acc <> "#{row.id}: #{row.val}\n"
  end)

# 좋은 예: iodata를 모았다가 한 번에 바이너리로

report =
  rows
  |> Enum.reduce([], fn row, acc ->
    [acc, [row.id, ?:, row.val, ?\n]]
  end)
  |> :erlang.iolist_to_binary()
```

타입스펙:

```elixir
@spec build_report(list(%{id: term(), val: term()})) :: iodata()
```

으로 써두면, “이 함수는 iodata를 돌려준다 → 마지막에 `IO.iodata_to_binary/1` 같은 것으로 변환해 쓰라”고 문서화할 수 있다.

#### 집합 연산 — MapSet

태그/권한/추천 시스템에서 태그를 단순 리스트로만 관리하면:

- 중복 제거, 포함 여부 확인 등이 점점 비싸진다.
- 논리 연산(합/교/차)을 표현하기 어렵다.

`MapSet.t()` 를 사용하면:

```elixir
@type tags :: MapSet.t(atom)

@spec has_any?(tags, tags) :: boolean()
def has_any?(a, b), do: not MapSet.disjoint?(a, b)
```

처럼 깔끔한 API를 만들 수 있다.

#### 맵 구조 머지

설정/옵션 머지는 `deep_merge/2` 패턴과 함께
**정책**을 타입으로 기록해두는 것이 좋다.

```elixir
@type policy ::
        :keep_left    # 왼쪽 값 유지
      | :keep_right   # 오른쪽 값 덮어쓰기
      | :concat_list  # 리스트는 이어붙이기
      | :merge_map    # 맵은 재귀 머지
```

이후 `deep_merge/3` 에서 이 정책을 인자로 받아 동작하게 할 수 있다.

---

### 실전 미니 가이드: “타입이 문서이자 테스트다”

이제 실제 코드 설계 흐름에 타입을 녹이는 패턴을 보자.

#### API 경계: 외부(JSON) → 내부(Struct)

```elixir
defmodule Domain do
  defmodule User do
    @type id :: pos_integer()
    @enforce_keys [:id, :email]
    defstruct [:id, :email, name: nil]

    @type t :: %__MODULE__{
            id: id,
            email: String.t(),
            name: String.t() | nil
          }
  end

  @type incoming ::
          %{
            required("id") => integer(),
            required("email") => String.t(),
            optional(String.t()) => term()
          }

  @spec to_user(incoming) :: {:ok, User.t()} | {:error, term()}
  def to_user(%{"id" => id, "email" => e})
      when is_integer(id) and id > 0 and is_binary(e) do
    {:ok, %User{id: id, email: e}}
  end

  def to_user(_), do: {:error, :bad_request}
end
```

- 타입이 **API 스키마 문서** 역할을 한다.
- Dialyzer는 “id가 음수일 수 있다”거나, “email이 nil일 수 있다”는 경로를 찾아내 경고한다.

#### 파이프라인 반환 타입을 유니온으로 고정

```elixir
@type ok(a) :: {:ok, a}
@type err() :: {:error, term()}
@type res(a) :: ok(a) | err(a)

@spec run(String.t()) :: res(nonempty_list(String.t()))
def run(path) do
  with true <- File.exists?(path) or {:error, :enoent},
       {:ok, bin} <- File.read(path),
       xs when is_list(xs) <- String.split(bin, "\n", trim: true),
       true <- xs != [] or {:error, :empty} do
    {:ok, xs}
  else
    {:error, _} = e -> e
    false           -> {:error, :enoent}
  end
end
```

- `with` 안팎의 모든 단계가 `res(a)` 형태를 유지한다.
- 호출부에서는 단순히:

```elixir
case run("file.txt") do
  {:ok, lines}     -> ...
  {:error, reason} -> ...
end
```

만 처리하면 된다.

#### 바이너리 프로토콜 파서: 타입으로 스스로 설명

앞에서 본 `Wire.parse/1` 예제가 여기에 해당한다.

- `@type packet` 정의 + 비트 매칭 구조 = 사실상 “와이어 프로토콜 명세서”.

---

### 체크리스트 — 우리 팀의 타입 습관

팀/프로젝트 차원에서 다음 체크리스트를 두고 보는 것이 도움이 된다.

- [ ] **핵심 공개 함수**에는 반드시 `@spec`을 붙이는가?
- [ ] 자주 쓰는 도메인 개념(사용자 ID, 이메일, JSON, 결과 타입 등)에 대해 **@type 별칭**을 정의했는가?
- [ ] 구조체 타입은 가능한 경우 **@opaque** 로 캡슐화했는가?
- [ ] 외부와의 경계(JSON, 파일, 네트워크)에서 **태그드 튜플 결과 타입**을 표준화했는가?
- [ ] `String.t()` / `charlist()` / `binary()` 를 명확히 구분하고 있는가?
- [ ] 대량 문자열 생성 시 **iodata()** 를 사용하도록 가이드했는가?
- [ ] Dialyzer를 CI에 통합하고, “경고를 모두 제거하는” 정책을 유지하고 있는가?
- [ ] 타입스펙이 테스트/문서와 함께 유지·갱신되고 있는가?

---

### 흔한 함정 → 교정

1) 문자열/차리스트 혼동
   - 증상: 얼랭 라이브러리 호출 시 인코딩 깨짐, 타입 기대 불일치
   - 교정:
     - 외부 얼랭 API가 무엇을 기대하는지(`charlist()` vs `String.t()`) 명확히 파악.
     - 경계에서 `to_charlist/1`, `to_string/1` 으로 명시적 변환.

2) 맵 점 표기 오용
   - 증상: 컴파일 에러 혹은 잘못된 가정.
   - 교정:
     - **구조체**에서만 `%{struct | key: val}`, `struct.key` 사용.
     - 일반 맵은 항상 `Map.get/3`, 패턴 매칭 `%{key: v}` 사용.

3) @spec 과장/부정확
   - 증상: Dialyzer 경고가 많아져 무시하게 됨 → 신뢰도 하락.
   - 교정:
     - 처음에는 조금 넉넉한 타입으로 시작.
     - 구현이 안정되면 점차 타입을 좁혀 나가기.
     - 테스트/리뷰를 통해 타입과 실제 동작이 맞는지 상시 검증.

4) 임의 문자열 → 아톰 변환
   - 증상: 아톰 테이블 메모리 누수 가능성.
   - 교정:
     - 외부 입력은 문자열로 유지.
     - 필요한 경우에만 화이트리스트 or `String.to_existing_atom/1` 사용.

5) 유니온 반환 불일관
   - 증상: 어떤 함수는 `{:ok, v}`, 어떤 함수는 그냥 `v` 반환, 어떤 함수는 예외 던짐 → 호출부가 복잡해짐.
   - 교정:
     - 모듈/레이어 단위로 결과 타입 정책을 통일한다.
     - 예: 도메인 서비스 레이어는 항상 `{:ok, v} | {:error, reason}` 형태.

---

### 연습 문제

연습 문제는 “타입 시스템 감각”을 몸으로 익히는 데 도움이 된다.

1) **카운터 구조체**
   - `@opaque counter :: %Counter{n: non_neg_integer()}` 구조체를 만들고,
     `new/0`, `inc/1`, `get/1` 함수를 작성하라. 각 함수에 `@spec`을 붙여라.
   - Dialyzer가 `n` 이 음수가 되는 경로를 잡지 못하게, 가드/패턴으로 방어하라.

2) **JSON → 바이너리 페이로드 파서**
   - `%{"type" => u8, "data" => base64}` 형태 JSON을 받아 **바이너리 페이로드**로 변환하는 `parse/1` 을 작성하라.
   - 성공 시 `{:ok, %{type: u8, payload: binary()}}`, 실패 시 `{:error, reason}` 을 반환하는 타입을 정의하라.

3) **deep_merge/3 정책 타입화**
   - `@type policy :: :left | :right | :concat_list | :merge_map` 를 정의하고,
     이 정책에 따라 맵/리스트/기타 타입을 머지하는 `deep_merge(a, b, policy)` 를 작성하라.

4) **가시성 규칙 타입 정교화**
   - `visible?(user_tags, rule)` 함수의 타입을 `MapSet.t(atom)` 중심으로 좁혀라.
   - `rule` 타입을 `%{optional(:any) => [atom], optional(:all) => [atom], optional(:none) => [atom]}` 형태로 정의하라.

5) **파일 스트리밍 + nonempty_list**
   - `File.stream!(path)` 결과를 받아 `nonempty_list(String.t())` 를 반환하는 `read_nonempty/1` 을 작성하라.
   - 파일이 비어 있으면 `{:error, :empty}`, 그렇지 않으면 `{:ok, lines}` 를 반환하는 타입을 명세하고 구현하라.

---

### 마무리

- 엘릭서의 타입 시스템은 “강제”보다는 **설계와 소통의 언어**에 가깝다.
- 런타임은 동적이지만, `@type/@spec`과 Dialyzer를 통해:
  - **도메인 개념을 이름 붙이고**
  - **코드의 계약을 문서화하고**
  - **위험한 경로를 자동으로 찾아내는** 수준까지 올라갈 수 있다.
- 패턴 매칭/가드, 구조체, 맵 스펙, 바이너리 매칭, 프로토콜, 태그드 튜플은
  모두 “타입적 사고”와 잘 어울리는 도구다.

결국 목표는 하나다.

> **코드가 곧 설계 문서이자 테스트**가 되도록,
> 타입을 적절히 활용하는 습관을 만드는 것.

이 장에서 정리한 패턴들을 실제 프로젝트의 도메인에 하나씩 적용해보면,
엘릭서 코드가 훨씬 더 **읽기 쉽고, 안전하고, 유지보수하기 좋은 모양**으로 변해가는 것을 체감할 수 있을 것이다.
