---
layout: post
title: Spring - 보안·운영 심화
date: 2025-10-26 15:25:23 +0900
category: Spring
---
# 보안·운영 심화 (확장편) — 시크릿/Vault·KMS·감사표준·스캔 게이트, 컴플라이언스·DLP, 백업·DR, 테스트 심화, FinOps, a11y/i18n 품질, 카오스/게임데이

> 목표: 26장에서 다 못 담은 **보안·운영 심화 영역**을 “실전에서 바로 붙여 쓸 수 있는” 설정/코드/파이프라인으로 보완한다.
> 기준: Spring Boot 3.3+, Java 21, K8s, GitHub Actions, Postgres, S3 호환 오브젝트 스토리지, HashiCorp Vault 또는 클라우드 매니지드 시크릿(SSM/Secrets Manager).

---

## A. 시크릿 관리 & 로테이션 — Vault / Parameter Store / Secrets Manager

### A-1. 원칙

- **평문 시크릿 금지**(레포/이미지/레이어/환경변수).
- **짧은 수명**(DB/클라우드 자격증명), **자동 로테이션**(시간·사건 기반), **사용 최소권한(least privilege)**.
- 주입은 **사이드카/CSI/에이전트** 또는 **앱 기동시 fetch** + **핫 리로드**.

### A-2. Vault 통합 (Spring Cloud Vault)

의존:
```kotlin
implementation("org.springframework.cloud:spring-cloud-starter-vault-config")
```
설정:
```yaml
spring:
  cloud:
    vault:
      uri: http://vault:8200
      scheme: http
      authentication: kubernetes           # K8s 인증
      kubernetes:
        role: api-role
      generic:
        enabled: true
        backend: secret
        default-context: app/api           # secret/data/app/api
  config:
    import: vault://
```
예: `secret/data/app/api` (KV v2)
```json
{ "SPRING_DATASOURCE_PASSWORD": "..." }
```

**DB 동적 크리덴셜(Vault DB 엔진)**
- 테넌트/롤 기반 TTL 예: `postgres/roles/app`(TTL 1h, max_ttl 24h)
- 앱은 `spring.datasource.username/password`를 Vault에서 주입(1시간마다 자동 갱신).

**핫 로드(Actuator Refresh)**
```yaml
management.endpoints.web.exposure.include: refresh,health,info
```
> 운영 팁: 롱-러닝 커넥션이 많은 서비스는 **갱신 간극** 동안 커넥션 풀 재구성이 필요. 배치/저활성 시간대에 롤링.

### A-3. AWS Parameter Store / Secrets Manager

- **SSM Parameter Store**: 구성값(평문/암호화), 버전 관리 쉬움, 무료/저가.
- **Secrets Manager**: 로테이션 람다/내장 통합(예: RDS) 지원.

예: SSM 파라미터 참조(애플리케이션 기동시)
```bash
aws ssm get-parameter --name /prod/db/password --with-decryption
```
Spring 외부화:
```yaml
db:
  password: ${SSM:/prod/db/password}
```

### A-4. 시크릿 로테이션 전략

- **DB 사용자 분리**: `app_user`(동적) / `migration_user`(고정·엄격 보호).
- **키 회전 주기**: 인적 접근 키(90일), 서비스 계정(30~60일), DB 동적(1~24h).
- **무중단 회전**:
  1) 새 버전 발행 →
  2) 앱 **중복 설정 수용**(Secret A+B) →
  3) 롤링 배포로 새 키 적용 →
  4) 구키 폐기.

로테이션 실패 방지 가드:
- 실패 시 **옛 키 일정 시간 유지**(grace).
- 키/자격증명 **사용 지표**(마지막 사용 시각, 실패율) 모니터링.

---

## B. KMS & Envelope 암호화

### B-1. 개념

- **KMS(CMK)**로 데이터 키(Data Key)를 생성/암호화(envelope).
- 앱은 **평문 데이터 키**로 페이로드 암/복호, 데이터 키는 **암호화 형태로 저장**.

### B-2. 구현 (예: AWS KMS + Tink)

의존:
```kotlin
implementation("com.google.crypto.tink:tink:1.13.0")
```
키 관리(부트 기동):
```java
// KMS로 래핑된 키셋 로딩
KeysetHandle handle = KeysetHandle.read(JsonKeysetReader.withFile(new File("/etc/keys/app.aead.json")),
    new AwsKmsClient().withDefaultCredentials().getAead("aws-kms://arn:aws:kms:ap-northeast-2:...:key/CMK_ID"));
Aead aead = handle.getPrimitive(Aead.class);
```
암복호화:
```java
byte[] ct = aead.encrypt(plain, "context-order".getBytes(UTF_8));
byte[] pt = aead.decrypt(ct, "context-order".getBytes(UTF_8));
```
> **Aad(부가데이터)**로 행 문맥(예: orderId)을 고정 → 오용 방지.
> 저장(예: DB 열 암호화) 시 **IV/Nonce** 관리 자동(Tink 내부). 백업/로그 DLP와 연계.

---

## C. 감사 로그 / 액세스 로그 — 표준 스키마 & 샘플

### C-1. 필드 규약(ECS + 커스텀)

공통 필드:
- `timestamp`, `level`, `service.name`, `env`, `trace.id`, `span.id`,
- `http.method`, `http.url`, `http.status`, `http.user_agent`, `network.client.ip`,
- `user.id`, `user.roles`, `tenant.id`,
- `pii.masked`(true/false), `event.type`(access|audit|security), `event.action`, `event.outcome`, `resource.type/id`.

### C-2. 액세스 로그(JSON)

logback-spring.xml (발췌):
```xml
<appender name="JSON" class="ch.qos.logback.core.rolling.RollingFileAppender">
  <file>/var/log/app/access.json</file>
  <encoder class="net.logstash.logback.encoder.LogstashEncoder">
    <customFields>{"service.name":"mini-shop","env":"prod"}</customFields>
  </encoder>
</appender>
```

필터에서 MDC 주입:
```java
MDC.put("trace.id", traceId());
MDC.put("tenant.id", tenant());
MDC.put("user.id", currentUserIdOrAnon());
```

### 이벤트 표준

```json
{
  "timestamp":"2025-10-23T05:35:12Z",
  "event":{"type":"audit","action":"order.refund","outcome":"success"},
  "user":{"id":"U123","roles":["ROLE_ADMIN"]},
  "resource":{"type":"Order","id":"O987"},
  "tenant":{"id":"acme"},
  "trace":{"id":"2f7c9c1b3b12e6a1"},
  "meta":{"amount":12000},
  "pii":{"masked":true}
}
```
- **PII**는 **마스킹 후 기록**(이메일/전화 등) — 원문 금지.
- **불변 저장소**(WORM/Object Lock)에 **감사 로그 사본** 보관(보존 정책 연계).

---

## D. 취약점 스캔 파이프라인 — 정책 게이트로 “막히게” 만들기

### D-1. 의존성(Dependabot/OWASP/Snyk 중 택1+)

- **Dependabot**: PR 자동 생성 → CI에서 **정책**(허용 CVSS) 확인.
- **OWASP Dependency-Check** or **Gradle Versions**로 보고서 생성.
- 조직 규모↑면 **Snyk**/**Whitesource**(라이선스/정책) 병행.

Actions 예:
```yaml
- name: Dependency Check
  uses: dependency-check/Dependency-Check_Action@v3.0.4
  with:
    format: "JSON"
    out: "dep"
- name: Fail on High/Critical
  run: |
    jq '.dependencies[].vulnerabilities[] | select(.severity=="HIGH" or .severity=="CRITICAL")' dep/dependency-check-report.json | grep . && exit 1 || true
```

### D-2. 컨테이너 이미지 스캔 (Trivy)

{% raw %}
```yaml
- name: Trivy Image Scan
  uses: aquasecurity/trivy-action@0.24.0
  with:
    image-ref: ghcr.io/org/app:${{ github.sha }}
    format: sarif
    output: trivy.sarif
    severity: HIGH,CRITICAL
    exit-code: 1
- name: Upload SARIF
  uses: github/codeql-action/upload-sarif@v3
  with: { sarif_file: trivy.sarif }
```
{% endraw %}

**허용목록(with expiry)**:
```yaml
- name: Allowlist with expiry
  run: |
    jq '. | map(select(.VulnerabilityID=="CVE-XXXX" and .Expires > now)) | length' allow.json
```

### D-3. 정책 요약

- **차단 임계**: Critical=0, High<=N(예: 3, 30일 내 fix required).
- **베이스 이미지 고정**(distroless, LTS), **리빌드 주기**(주 1회).
- **서명/검증**: cosign sign/verify + AdmissionPolicy(서명된 것만 배포).

---

## E. 규정·컴플라이언스 & 데이터 보호

> 법률 자문은 아님. 실무 체크리스트 관점.

### E-1. PII 분류 & 데이터 맵

- 레벨링: `PUBLIC` / `INTERNAL` / `CONFIDENTIAL` / `RESTRICTED(PII/민감)`.
- **데이터 맵**(시스템→테이블→열→수명→암호화→접근 주체) 유지.
- **ROPA**(처리 활동 기록), **DPIA**(영향평가) 필요 시 수행.

### E-2. 마스킹/가명처리

- **로그/감사/이벤트**: 이메일, 전화, 주소 → 마스킹(***).
- **애널리틱스**: 식별자 해시(pepper+salt 관리).
- **UI View**: 부분 노출(010-****-1234).

### E-3. 보존·삭제 주기(retention)

- 비즈니스/법 규정 기반 보존 매트릭스 작성(예: 주문 5년, 결제 5년, 로그 6개월).
- **스케줄 삭제**(Soft→Hard), 백업/아카이브 동시 삭제 요청 경로 정의.

### E-4. GDPR/PIPA 대응 골자

- **데이터 주체 권리**: 열람/정정/삭제/이동 내 API/콘솔.
- **국외 이전**: 위치/보안조치 문서화, 표준계약조항 준수.
- **침해 통지**: 탐지→평가→72h 통지 플로우.

### E-5. DLP(백업/로그 포함)

- **S3 버킷 정책**: 퍼블릭 차단, TLS 요구, SSE-KMS, 버전닝, Object-Lock(보존).
- **로그 레드랙션**: Ingestion 단계에서 PII 패턴 제거.
- **백업 스냅샷 암호화**(KMS), 키 접근 감사.

---

## F. 백업·DR·복구 훈련

### F-1. RPO/RTO 정의

- **RPO**(데이터 손실 허용): 예 15분 → **WAL 아카이브** 간격/모니터 강화.
- **RTO**(복구 시간): 예 30분 → 자동 스크립트/런북 마련.

### F-2. Postgres PITR

`postgresql.conf`:
```
archive_mode = on
archive_command = 'aws s3 cp %p s3://backups-bucket/wal/%f'
```
주간 **베이스 백업** + WAL 지속 업로드.

복구(런북 요약):
1) 베이스백업 복원
2) `recovery.conf`(복구 시각 지정)
3) WAL 재생
4) 앱 ReadOnly 가드 → 헬스 확인 후 트래픽 전환

### F-3. 오브젝트 스토리지 백업

- 버전닝 ON, 크로스리전 복제(CRR), 라이프사이클(IA/Glacier).
- **무결성 검증**: 주기적 샘플 복원 + 해시 비교.

### F-4. 복구 드릴(분기 1회)

- Stage에 **실제 백업으로 복원** → 통합 테스트 스모크 → **보고서**(걸린 시간, 실패 포인트, 개선).

---

## G. 테스트 전략 심화

### G-1. 컨트랙트 테스트

- **소비자 주도(Consumer-Driven)**: Pact 또는 Spring Cloud Contract.
- **흐름**: 소비자가 계약 정의 → 프로바이더가 검증 → 배포 게이트.

Spring Cloud Contract 예:
```kotlin
testImplementation("org.springframework.cloud:spring-cloud-starter-contract-verifier")
```
`contracts/order/get_order.groovy`
```groovy
Contract.make {
  request { method 'GET'; urlPath('/api/orders/123') }
  response {
    status OK()
    body([
      success: true,
      data: [ id: $(regex(/[A-Z0-9]{10}/)) ]
    ])
  }
}
```
프로바이더 CI에서 `./gradlew contractVerifier` → 실패 시 배포 불가.

### G-2. 시각적 회귀(E2E)

- Playwright + **Visual Comparisons** 또는 Percy.
- 머지 전 스냅샷 비교 → **UI 깨짐 방지**.

### G-3. 퍼포먼스 예산(페이지·API)

- Web: Lighthouse CI → **TTI/CLS/LCP** 예산.
- API: k6 smoke(2m) + 임계(p95, 오류율) → 실패 시 CI 빨간불.

Lighthouse CI (Actions):
```yaml
- uses: treosh/lighthouse-ci-action@v11
  with:
    urls: https://app.example.com/
    budgetPath: ./lighthouse/budget.json
```

---

## H. 비용/용량 관리(FinOps)

### H-1. 태깅 & 비용 대시보드

- 리소스에 **팀/서비스/환경 태그**: `team=checkout, service=api, env=prod`.
- 클라우드 **비용 익스포트** → BigQuery/S3 → Grafana or Looker Studio 대시.

### H-2. 리소스 가드레일

- K8s **ResourceQuota** / **LimitRange**:
```yaml
apiVersion: v1
kind: LimitRange
metadata: { name: app-defaults, namespace: prod }
spec:
  limits:
  - type: Container
    default: { cpu: "1000m", memory: "1Gi" }
    defaultRequest: { cpu: "200m", memory: "512Mi" }
```
- HPA: 과소/과대 프로비저닝 탐지(사용률 <20% 24h → 다운사이즈 제안).

### H-3. 비용 회귀 알람

- 전주 대비 **일일 비용 +20%** 이상 → 알람.
- S3/데이터 전송 급증 탐지(Top-N 리소스).

---

## 품질

### I-1. a11y 파이프라인

- **axe** CLI / **Lighthouse** a11y 스코어 임계(예: ≥ 90).
- aria-label/role, 대비, 키보드 내비게이션 자동 체크.

### I-2. i18n 누락 탐지

- 빌드 시 **메시지 키 스캐너**(unused/missing).
- **Pseudo-loc**(문자 늘리기)로 레이아웃 깨짐 확인.
- 타임존/통화 표시 테스트(스냅샷).

테스트 예:
```ts
expect(formatMoney(Money.of(12000, 'KRW'), 'en-US')).toBe('₩12,000');
expect(formatMoney(Money.of(12000, 'KRW'), 'ko-KR')).toBe('12,000원');
```

---

## J. 카오스/게임데이 자동화

### J-1. 시나리오(주간 잡 권장)

- **스레드풀 포화**: 부하 + 외부 늦은 응답 → 서킷/레이트리밋 동작 검증.
- **DB 락**: 대규모 업데이트+읽기 동시 → 타임아웃/재시도/알람 확인.
- **외부 API 장애**: Toxiproxy/Chaos Mesh로 500/지연/패킷 손실.

### J-2. GitHub Actions 스케줄 예

```yaml
name: Chaos Weekly
on:
  schedule: [{ cron: "0 3 * * 1" }]   # 매주 월 03:00 KST
jobs:
  chaos-threadpool:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - name: Inject latency via toxiproxy
        run: ./scripts/chaos/latency.sh 300ms
      - name: k6 stress
        run: k6 run scripts/load/k6-orders.js
      - name: Assert SLO
        run: ./scripts/assert_slo.sh --p95 400 --error 1
```

### J-3. SLO 검증 스크립트(개념)

```bash
#!/usr/bin/env bash

P95=$(curl -s "$PROM/api/v1/query?query=$P95_EXPR" | jq -r '.data.result[0].value[1]')
ERR=$(curl -s "$PROM/api/v1/query?query=$ERR_EXPR" | jq -r '.data.result[0].value[1]')
(( ${P95%.*} < $1 )) && (( ${ERR%.*} < $2 )) || exit 1
```

---

## K. 한 페이지 요약 (Actionable)

1) **시크릿**: Vault/SSM로 **짧은 수명 + 자동 회전**. 앱은 **핫 리로드** 수용.
2) **암호화**: KMS + Envelope(Tink)로 **열/파일** 보호. Aad로 오용 방지.
3) **감사/액세스**: **표준 스키마** + PII 마스킹 + WORM 보존.
4) **스캔 게이트**: Dep/Trivy + **정책 임계**로 PR/배포 **차단**.
5) **컴플라이언스**: 데이터 맵·보존주기·권리행사 API·DLP.
6) **백업/DR**: PITR+CRR, **복구 드릴**을 분기마다. RPO/RTO 수치화.
7) **테스트 심화**: 컨트랙트/시각적/퍼포먼스 예산을 **CI에 내장**.
8) **FinOps**: 태깅·쿼터·비용 알람으로 **리소스 낭비** 차단.
9) **a11y/i18n**: 자동 점검 + pseudo-loc/시간·통화 스냅샷.
10) **카오스**: 주간 시나리오로 **SLO 검증**을 자동화.
