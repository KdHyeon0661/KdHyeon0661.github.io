---
layout: post
title: 객체지향설계 - 리팩토링
date: 2025-07-25 20:20:23 +0900
category: 객체지향설계
---
# 리팩토링을 통한 설계 개선 (Refactoring for Design Improvement)

## 1. 리팩토링이 왜 중요한가

- **설계 부채(Technical Debt) 감축**: 잦은 요구 변경 속에서도 코드 품질을 유지.
- **변경 비용 감소**: 영향 범위가 작아져 안전한 릴리스가 가능.
- **가독성/온보딩 개선**: 새 팀원도 빠르게 기여 가능.
- **버그/회귀 감소**: 테스트 가능성이 올라가 품질이 상승.
- **성능·확장성 토대**: 병목을 드러내고 구조적으로 해결할 발판 제공.

---

## 2. 리팩토링의 기본 원칙

1. **동작 불변(Behavior-Preserving)**: 외부 관찰 결과(공개 계약, API, 도메인 규칙)는 바뀌지 않는다.
2. **작게·자주·원자적**: 한 번에 하나의 의도(Extract Method 등)만 수행한다.
3. **자동화 테스트 전제**: 안전망 없이 리팩토링하지 않는다.
4. **지표/회귀 검사**: 성능·기능 회귀를 모니터링한다.
5. **커뮤니케이션**: 공개 계약 변경은 버저닝·공지·마이그레이션 가이드 동반.

---

## 3. 안전한 리팩토링 준비(Pre-flight)

- **테스트 베이스라인 확보**
  - 단위/통합/계약/스냅샷/엔드투엔드 구성.
- **목표·범위 정의**
  - 예: “중복 제거”, “God Class 분해”, “ORM 의존 제거”.
- **작은 커밋, 명시적 메시지**
  - 예: `refactor(order): extract PricingPolicy from OrderService`.
- **CI 파이프라인**
  - 모든 브랜치에 테스트·정적 분석·보안 스캔 자동화.
- **브랜치 전략/토글**
  - `feature/refactor-*`와 **Feature Flag**를 병행.

---

## 4. 리팩토링 절차(실전 루프)

1) **코드 냄새 식별 → 우선순위화**
2) **Pre-test 실행**(현재 상태 보존 확인)
3) **단일 리팩토링 적용**(예: Extract Class)
4) **테스트 전부 실행 & 코드 리뷰**
5) **반복**(다음 냄새/다음 컴포넌트)

---

## 5. 코드 냄새 → 리팩토링 처방 매핑

| 냄새 | 증상 | 대표 처방 |
|---|---|---|
| 긴 메서드 | 100+ LOC, 복잡 분기 | **Extract Method**, **Introduce Explaining Variable**, **Decompose Conditional** |
| 긴 클래스(God Object) | 다수의 책임 혼재 | **Extract Class**, **Extract Module**, **Move Method/Field** |
| 중복 코드 | 유사 로직 반복 | **Extract Method**, **Template Method**, **Strategy** |
| 거대한 조건문 | if/switch 가지 폭증 | **Replace Conditional with Polymorphism/Strategy**, **State** |
| 과다 파라미터 | 6개 이상 인자 | **Introduce Parameter Object**, **Preserve Whole Object** |
| Feature Envy | 타 클래스 필드에 과도 접근 | **Move Method**, **Change Bidirectional Association to Unidirectional** |
| 데이터 클래스 | 게터/세터만 존재 | **Encapsulate Record**, **Introduce Invariants**, **Make Immutable** |
| 기본형 집착 | Money/Date를 원시 타입으로 | **Introduce Value Object** |
| Shotgun Surgery | 변경이 다수 파일로 전파 | **Facade**, **Module화**, **Eventing** |
| Message Chains | a.getB().getC()… | **Hide Delegate**, **Encapsulate Navigation** |
| 임시 필드 남용 | 중간 상태 저장 | **Replace Temp with Query**, **Extract Class** |

---

## 6. 예제 1 — 긴 메서드 분해(Extract Method, Decompose Conditional)

```java
// Before
public void processOrder(Order o) {
    if (o == null || o.items().isEmpty()) throw new IllegalArgumentException();
    double total = 0;
    for (Item i : o.items()) total += i.price() * i.qty();
    if (o.coupon() != null) total *= 0.9;
    if (o.vip()) total *= 0.95;
    repository.save(o, total);
    mailer.send(o.customerEmail(), total);
}

// After
public void processOrder(Order o) {
    validate(o);
    double total = priced(o);
    persist(o, total);
    notify(o, total);
}
private void validate(Order o) { requireNonNull(o); if (o.items().isEmpty()) throw new IllegalArgumentException(); }
private double priced(Order o) { return applyVip(applyCoupon(sum(o))); }
private double sum(Order o) { return o.items().stream().mapToDouble(i -> i.price() * i.qty()).sum(); }
private double applyCoupon(double total) { return o.coupon() != null ? total * 0.9 : total; }
private double applyVip(double total) { return o.vip() ? total * 0.95 : total; }
```

---

## 7. 예제 2 — 정책 다형화(Replace Conditional with Strategy)

```java
// Before: 조건문으로 정책 분기
double price(Order o) {
    if (Season.isWinter()) return winterPrice(o);
    if (Season.isSummer()) return summerPrice(o);
    return regularPrice(o);
}

// After: Strategy
public interface PricingPolicy { Money priceOf(Order o); }
public final class WinterPolicy implements PricingPolicy { public Money priceOf(Order o) { ... } }
public final class SummerPolicy implements PricingPolicy { public Money priceOf(Order o) { ... } }
public final class RegularPolicy implements PricingPolicy { public Money priceOf(Order o) { ... } }

public final class PriceCalculator {
    private final Map<Season, PricingPolicy> policies;
    public Money price(Order o, Season s) { return policies.getOrDefault(s, new RegularPolicy()).priceOf(o); }
}
```

---

## 8. 예제 3 — 값 객체 도입(Primitive Obsession → Introduce Value Object)

```csharp
// Before
public decimal Transfer(string fromId, string toId, decimal amount, string currency) { ... }

// After
public sealed record Money(decimal Amount, string Currency) {
    public Money Add(Money o){ RequireSame(o); return this with { Amount = Amount + o.Amount }; }
    public Money Sub(Money o){ RequireSame(o); return this with { Amount = Amount - o.Amount }; }
    private void RequireSame(Money o){ if (Currency != o.Currency) throw new ArgumentException("currency mismatch"); }
}
public Money Transfer(AccountId from, AccountId to, Money amount) { ... }
```

효과: 통화 불일치 방지, **불변성/검증**을 타입에 내재화.

---

## 9. 예제 4 — 합성으로 전환(Replace Inheritance with Composition)

```python
# Before
class XmlLogger(FileLogger):  # 상속으로 기능 누적
    def log(self, level, msg): ...

# After
class Logger:
    def __init__(self, sink): self.sink = sink
    def log(self, level, msg): self.sink.write(format(level, msg))

class FileSink: ...
class StdoutSink: ...
class RotatingFileSink: ...
# 런타임 조합으로 유연성↑
```

---

## 10. 예제 5 — Repository 포트 도입(의존 역전 + 테스트 용이성)

```java
// application port
public interface OrderRepository {
    Optional<Order> find(String no);
    void save(Order o);
}

// infrastructure adapter (JPA)
@Repository
public class JpaOrderRepository implements OrderRepository { ... }

// service (테스트에서는 InMemoryRepo로 대체 가능)
public class OrderService {
    private final OrderRepository repo;
    public OrderService(OrderRepository repo) { this.repo = repo; }
}
```

---

## 11. 테스트 전략(리팩토링의 안전망)

### 11.1 테스트 계층화

| 레벨 | 목적 | 비고 |
|---|---|---|
| 단위(Unit) | 엔티티/VO·정책 검증 | 빠름, 외부 의존 無 |
| 애플리케이션(Unit) | 유스케이스, 포트 목 | 트랜잭션 경계 검증 |
| 계약(Contract) | 포트/어댑터 상호작용 | 프로바이더/컨슈머 테스트 |
| 통합(Integration) | DB/브로커/외부 API | Testcontainers 권장 |
| E2E/수용 | 요구-행동 일치 | Gherkin/BDD |

### 11.2 예: JUnit + PIT(뮤테이션 테스트)

```java
@ParameterizedTest
@CsvSource({"10000,false,10000","10000,true,9000"})
void coupon_applies_only_when_present(int subtotal, boolean hasCoupon, int expected){
    var o = new Order(...).subtotal(subtotal).coupon(hasCoupon);
    assertEquals(expected, priced(o).intValue());
}
```

**Mutation Score**가 낮으면 테스트 보완 후 리팩토링.

---

## 12. 품질·복잡도 지표(정량 관리)

- **사이클로매틱 복잡도**
  $$ M = E - N + 2P $$
  낮을수록 테스트 쉬움.
- **유지보수성 지수(MI)**(한 예)
  $$ MI = \max\left(0, 171 - 5.2\ln(V) - 0.23M - 16.2\ln(LOC)\right) $$
  여기서 \(V\)는 Halstead Volume.
- **중복율(Duplication)**, **결합도/응집도 프록시(모듈 간 의존 그래프)**, **Mutation Score**, **커버리지**.

변화 전/후 지표를 CI에 게시해 리팩토링 성과를 가시화한다.

---

## 13. 대규모 리팩토링 전략

### 13.1 Strangler Fig Pattern
- 레거시의 특정 엔드포인트/도메인 기능을 **프록시/라우터** 뒤에 숨기고, 새 구현으로 점진 대체.

### 13.2 Branch by Abstraction
- 추상 인터페이스(포트)를 도입 → 레거시/신규 구현 병행 → 플래그로 스위칭 → 구 레이어 제거.

### 13.3 Feature Flags / Canaries
- 새로운 경로를 **소수 트래픽**에만 적용 → 모니터링 후 점진 확장.

### 13.4 바운디드 컨텍스트 단위(DDD)
- 컨텍스트 경계를 기준으로 팀·리포지토리·릴리스 단위를 분리.

---

## 14. 데이터베이스·스키마 리팩토링

- **마이그레이션 도구**: Flyway/Liquibase로 DDL을 버전관리.
- **Backward-Compatible 변경**
  - Additive-first: 컬럼 추가 → 애플리케이션 수정 → 컬럼 필수화/제거.
- **읽기-쓰기 분리/Blue-Green**: Migration 중 가용성 유지.
- **데이터 백필(Backfill) 잡**: 대량 변환은 배치/큐 처리.

마이그레이션 스크립트 예:

```sql
-- V2025_11_01__add_order_total.sql
ALTER TABLE orders ADD COLUMN total_cents BIGINT;
UPDATE orders SET total_cents = (SELECT SUM(price_cents*qty) FROM order_lines WHERE order_id=orders.id);
```

---

## 15. 퍼블릭 API 리팩토링

- **SemVer / Deprecation Plan**
  - v1 유지 + v2 추가 → Deprecation 헤더/문서 → 전환 기간 후 제거.
- **API 게이트웨이/어댑터**로 구/신 스키마 동시 지원.
- **계약 테스트**로 파괴적 변경 방지.

OpenAPI 예시(스키마 확장, 필수→선택):

```yaml
components:
  schemas:
    Order:
      type: object
      properties:
        id: { type: string }
        total: { type: integer, format: int64, description: "deprecated: use monetaryTotal" }
        monetaryTotal: { $ref: '#/components/schemas/Money' }
```

---

## 16. 프런트엔드 리팩토링(간단 지침)

- **상태 분리**: 서버 상태와 클라이언트 상태 분리(Query 라이브러리 활용).
- **프레젠테이션/컨테이너 분리**, **컴포넌트 분해(Extract Component)**.
- **스토리북/시각 회귀 테스트**로 UI 회귀 방지.
- **성능**: 메모이제이션·코드 스플리팅·지연 로딩 도입.

---

## 17. 도구·워크플로우

| 카테고리 | 도구 |
|---|---|
| IDE 리팩토링 | IntelliJ IDEA, Eclipse, VS, Rider |
| 정적 분석 | SonarQube, PMD, Checkstyle, ESLint |
| 테스트 | JUnit5, pytest, NUnit, jqwik/Hypothesis |
| 뮤테이션 | PIT(자바), Stryker(.NET/JS), mutmut(파이썬) |
| CI/CD | GitHub Actions, Jenkins, GitLab CI |
| 마이그레이션 | Flyway, Liquibase |
| 컨테이너 통합 | Testcontainers |

**Git 제안 커밋 템플릿**
`type(scope): short summary`
`refactor(order): extract PricingPolicy and move fee calculation to VO`

---

## 18. 리팩토링 카타 — 계산기 리디자인(요약)

### Before
- `BillingService`가 할인·세금·배송비·로깅·영속을 모두 담당.

### After
- **정책 객체**: `DiscountPolicy`, `TaxPolicy`, `ShippingPolicy`
- **계산 파이프라인**(함수형 합성/데코레이터)
- **포트/어댑터**: `ReceiptRepository`, `AuditSink`
- **테스트**: 각 정책 단위 테스트 + 파이프라인 속성 기반 테스트

```java
UnaryOperator<Money> pipe = discount::apply
    .andThen(tax::apply)
    .andThen(shipping::apply);
Money total = pipe.apply(subtotal);
```

---

## 19. 위험·의사결정 매트릭스(Refactor vs Rewrite)

| 질문 | Refactor 선호 | Rewrite 선호 |
|---|---|---|
| 테스트 유무 | 충분한 테스트 | 전무하고 추가가 불가 |
| 도메인 지식 축적 | 코드에 내재 | 분산/문서화 미흡 |
| 시간/리스크 | 점진적 허용 | 대규모 투자 가능 |
| 외부 제약 | API/규제 안정 필요 | 큰 버전 점프 허용 |

---

## 20. 체크리스트(요약)

- [ ] 리팩토링 전 테스트가 **녹색**인가?
- [ ] 변경이 **원자적**이고 커밋 메시지로 의도가 드러나는가?
- [ ] 도메인 규칙이 **엔티티/VO/도메인 서비스**로 귀속되었는가?
- [ ] **포트/어댑터** 경계가 명확한가(의존 역전)?
- [ ] **중복/조건 복잡도**가 줄었는가?
- [ ] **Mutation Score/복잡도/중복율** 등 지표가 개선되었는가?
- [ ] 스키마/API 변경은 **Backward-Compatible** 한가?
- [ ] 롤백/토글/모니터링 계획이 있는가?

---

## 21. 부록 A — 수식/지표 해설

- **사이클로매틱 복잡도**
  $$ M = E - N + 2P $$
  \(E\): 엣지, \(N\): 노드, \(P\): 연결 컴포넌트 수.
  분기가 늘수록 \(M\)이 증가 → 테스트 케이스 최소 개수 하한.

- **유지보수성 지수(MI)**
  $$ MI = \max\left(0, 171 - 5.2\ln(V) - 0.23M - 16.2\ln(LOC)\right) $$
  \(V\): Halstead Volume. 수치가 높을수록 유지보수 용이.

---

## 22. 부록 B — IDE 리팩토링 순서 예(IntelliJ)

1) `Rename` → 의도 표현 네이밍
2) `Extract Method` → 긴 메서드 분해
3) `Introduce Parameter Object` → 파라미터 단순화
4) `Extract Interface` → 포트 정의
5) `Move Class/Method` → 정보 전문가 원칙 적용
6) `Inline`/`Pull Members Up/Down` → 상속·합성 재정렬

---

## 23. 결론

리팩토링은 **결과물이 아닌 과정**이다.
테스트로 안전망을 두고, 작은 단계로, 지표로 검증하며, 포트/어댑터·DDD 경계를 따라 책임을 제자리로 돌려놓을 때, 코드베이스는 **변화 친화적 구조**로 성숙한다.
본 가이드의 **처방 매핑·예제·체크리스트**를 팀의 공통 레시피로 정착시켜, 기능 개발과 리팩토링을 **동전의 양면**으로 운영하라.
