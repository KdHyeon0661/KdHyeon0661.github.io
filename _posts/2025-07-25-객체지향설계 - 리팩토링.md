---
layout: post
title: 객체지향설계 - 리팩토링
date: 2025-07-25 20:20:23 +0900
category: 객체지향설계
---
# 리팩토링을 통한 설계 개선 (Refactoring for Design Improvement)

리팩토링은 **기능 변경 없이 코드의 내부 구조를 개선**해 가독성·유지보수성·확장성을 높이는 활동입니다. 설계를 처음부터 완벽하게 만들기 어렵기 때문에, 리팩토링을 통해 점진적으로 좋은 설계를 만들어 가는 것이 실무의 정석입니다. 이 글은 목적·원칙·절차·구체 기법(코드 예제 포함)·도구·안전 수칙·대규모 시스템 전략까지 실무에 바로 적용 가능한 가이드를 제공합니다.

---

## 왜 리팩토링이 중요한가?

- 설계 부채(technical debt) 축적 방지  
- 변경 요구가 왔을 때 빠르고 안전하게 대응 가능  
- 코드 이해도 향상 → 신규 개발자 온보딩 속도 개선  
- 버그 감소 및 테스트 용이성 향상  
- 성능/확장성 개선(필요 시)으로 이어질 수 있음

---

## 리팩토링의 기본 원칙

1. **동작을 바꾸지 않는다**(behavior-preserving).  
2. **작게, 자주, 원자적으로** 수행한다 — 되돌리기 쉽도록 변경 범위를 작게 유지.  
3. **자동화된 테스트가 전제**되어야 한다.  
4. **리팩토링 전후로 성능·기능 회귀 검사**를 반드시 수행.  
5. **이해관계자와 커뮤니케이션**: API/라이브러리 공개계약을 바꾸는 리팩토링은 별도 절차 필요.

---

## 안전한 리팩토링을 위한 준비 단계

1. **테스트 확보**  
   - 유닛/통합/계약 테스트로 핵심 동작 보장.  
2. **리팩토링 계획 수립**  
   - 목표(코드 냄새 제거, 모듈 분리 등)와 범위 정의.  
3. **작은 단위 커밋**과 의미 있는 커밋 메시지  
   - 예: `REF: Extract ReportGenerator from ReportManager`  
4. **CI 파이프라인 확인** — 모든 테스트가 자동으로 돌도록 설정.  
5. **백업/브랜치 전략** — feature/rd/refactor 브랜치 사용.

---

## 리팩토링 과정(실전 가이드)

1. **코드 냄새(Problem）찾기**: 긴 메서드, 중복 코드, 긴 클래스(God Object), 대형 조건문, 많은 파라미터 등.  
2. **우선순위**: 변경 위험도와 효과(유지보수성·재사용성) 기준으로 정렬.  
3. **테스트 실행 (pre-check)**: 현재 테스트가 모두 성공하는지 확인.  
4. **작은 단계로 리팩토링**: 하나의 리팩토링(예: Extract Method)만 적용.  
5. **테스트 실행 & 리팩토링 반복**: 변경 후 테스트 실행.  
6. **리뷰 & 문서화**: 설계 의도·API 변화 기록.  
7. **병합 및 배포**: 점진적 롤아웃(대형 변경은 feature flag 적용).

---

## 자주 쓰는 리팩토링 패턴 (설명 + 예제)

### 1) Extract Method — 긴 메서드 분해
**목적**: 가독성 향상, 재사용성 확보.

```java
// Before
public void processOrder(Order o) {
    // validation
    if (o == null || o.items.isEmpty()) throw new IllegalArgumentException();
    // calculate totals
    double total = 0;
    for (Item i : o.items) total += i.price * i.qty;
    // apply discounts
    if (o.coupon != null) total *= 0.9;
    // persist and notify...
}

// After
public void processOrder(Order o) {
    validateOrder(o);
    double total = calculateTotal(o);
    total = applyDiscounts(o, total);
    persistOrder(o);
    notifyCustomer(o);
}

private void validateOrder(Order o) { ... }
private double calculateTotal(Order o) { ... }
private double applyDiscounts(Order o, double total) { ... }
```

---

### 2) Extract Class — 책임 분리 (God Object 개선)
**목적**: 단일 책임 원칙(SRP) 적용.

```java
// Before (ReportManager가 너무 많은 책임)
class ReportManager {
    void generateReport() { /* gather data, format PDF, save file, email */ }
}

// After
class ReportGenerator { String generate(Data d) { ... } }
class FileSaver { void save(String filename, byte[] content) { ... } }
class EmailSender { void send(String addr, String subject, byte[] content) { ... } }
class ReportManager {
    private ReportGenerator generator;
    private FileSaver saver;
    private EmailSender mailer;
    void process() {
        var report = generator.generate(...);
        saver.save(...);
        mailer.send(...);
    }
}
```

---

### 3) Replace Conditional with Polymorphism / Strategy
**목적**: 복잡한 조건문을 다형성으로 대체해 확장성 확보.

```java
// Before: 긴 switch/if
double calculateFee(Payment p) {
    if (p.type == CARD) return cardFee(p);
    if (p.type == CASH) return cashFee(p);
    // ...
}

// After: Strategy
interface PaymentFeeStrategy { double fee(Payment p); }
class CardFeeStrategy implements PaymentFeeStrategy { ... }
class CashFeeStrategy implements PaymentFeeStrategy { ... }

class FeeCalculator {
    Map<PaymentType, PaymentFeeStrategy> strategies;
    double calculateFee(Payment p) { return strategies.get(p.type).fee(p); }
}
```

---

### 4) Introduce Parameter Object / Replace Long Parameter List
**목적**: 많은 파라미터를 객체로 묶어 의미 명확화.

```java
// Before
void createUser(String name, String email, String address, String phone, boolean subscribed) { ... }

// After
class UserCreateSpec { String name; String email; String address; String phone; boolean subscribed; }
void createUser(UserCreateSpec spec) { ... }
```

---

### 5) Move Method / Move Field
**목적**: 정보 전문가(Information Expert) 원칙 적용 — 해당 데이터를 가장 많이 아는 클래스에 책임을 둠.

---

### 6) Replace Inheritance with Composition
**목적**: 다형성 오용, LSP 위반 회피 — 합성 우선.

```java
// Before
class Square extends Rectangle { ... } // 문제가 될 수 있음

// After
class Rectangle { ... }
class Square {
    private Rectangle rect;
    // delegate to rect
}
```

---

### 7) Encapsulate Field / Make Immutable
**목적**: 불변성으로 동시성/테스트 안정성 확보.

---

### 8) Introduce Facade
**목적**: 복잡한 서브시스템을 단순한 인터페이스로 숨김.

---

## 대규모 시스템에서의 리팩토링 전략

### 1) Strangler Fig Pattern (점진적 대체)
- 레거시 기능을 새 모듈로 하나씩 대체 → 전체를 한 번에 바꾸지 않음.

### 2) Branch by Abstraction
- 추상화 계층을 먼저 도입한 뒤 구현 교체 → 다운타임 최소화.

### 3) Feature Flags / Toggles
- 리팩토링된 구현을 켜고 끌 수 있게 해 점진 배포 수행.

### 4) Bounded Context 단위로 분해 (DDD와 연계)
- 바운디드 컨텍스트를 기준으로 리팩토링 범위를 정하고 독립적으로 개선.

---

## 코드 품질 지표와 모니터링

- **중복도(Duplication)**: 낮을수록 좋음.  
- **결합도(Coupling)**: 낮을수록 모듈 독립성↑.  
- **응집도(Cohesion)**: 높을수록 좋음.  
- **사이클로매틱 복잡도(Cyclomatic Complexity)**: 낮을수록 테스트 쉬움.  
- **코드 커버리지**: 100%가 목표는 아니지만 핵심 로직은 높은 커버리지 필요.  
- 도구: **SonarQube, CodeClimate, ESLint, PMD, Checkstyle** 등.

---

## 리팩토링 도구와 워크플로우

- IDE 내장 리팩토링: **IntelliJ IDEA, Eclipse, Visual Studio, Rider** (Extract Method, Rename, Move Class 등)  
- 정적 분석: **SonarQube, PMD, FindBugs/SpotBugs**  
- 자동 리팩토링 도구: 일부 언어용 리팩터링 도구(예: `refactor` 라이브러리)  
- VCS + CI: **git** 브랜치 전략, 작은 커밋, CI 자동 테스트 필수

---

## 안전 수칙 & 체크리스트 (리팩토링 전/후)

- [ ] 모든 기존 테스트가 통과하는가?  
- [ ] 변경 범위가 작고 원자적인가(커밋 단위)?  
- [ ] 추가된 테스트(필요 시)가 있어 기능을 충분히 커버하는가?  
- [ ] 성능에 민감한 부분을 수리팩토링한 경우 벤치마크 수행했는가?  
- [ ] API/라이브러리 공개계약을 변경하면 소비자에게 공지·버전 관리(semver)했는가?  
- [ ] 배포 후 롤백·토글 계획이 준비되어 있는가?  
- [ ] 코드 리뷰를 통해 설계 의도를 공유했는가?

---

## 흔한 실수와 회피법

- **테스트 없는 리팩토링** → 되돌리기 어려움. 항상 테스트 먼저.  
- **과도한 리팩토링(Over-refactor)** → YAGNI 위반, 복잡성 증가.  
- **한 번에 대규모 변경** → 버그·리스크 증가. 작게 쪼개기.  
- **성능 고려 미흡** → 프로파일링 후 리팩토링.  
- **문서·이슈 미비** → 다른 팀원 혼란 초래. 변경 의도와 이유 기록.

---

## 예: 현실적 리팩토링 시나리오 (요약)

- 문제: `OrderService`에 비즈니스/영속/알림 로직이 모두 혼재 → God Service.  
- 접근:
  1. 테스트로 현재 동작 캡처.  
  2. `Extract Class`: `OrderGenerator`, `OrderRepository`, `NotificationService`로 분리.  
  3. `Introduce Interface` + DI: `OrderRepository` 인터페이스 도입, 인메모리/DB 구현 분리.  
  4. 반복적 리팩토링 & 테스트.  
- 결과: 책임 명확화, 테스트 용이성 향상, 인프라 교체가 쉬워짐.

---

## 마무리 — 실천 팁

- 리팩토링은 **목적(유지보수성/확장성)**을 잊지 말고 수행하라.  
- 작은 성공을 쌓아라 — 매일 1~2곳만 정리해도 코드베이스가 빠르게 좋아진다.  
- 팀 규칙(커밋 메시지, 코드 리뷰, 테스트 기준)을 정해 일관성 있게 실행하라.  
- 필요하면 리팩토링 전용 스프린트(혹은 기술 부채 처리 시간)를 주기적으로 운영하라.
