---
layout: post
title: 소켓프로그래밍 - 코드 템플릿/유틸 모음
date: 2025-09-26 18:25:23 +0900
category: 소켓프로그래밍
---
## 20. 코드 템플릿/유틸 모음

> 이 장은 앞선 모든 실습에서 **그대로 복붙**해 재사용할 수 있는 C++23 네트워킹 유틸 모음집이다.
> 타깃은 **리눅스/POSIX**(glibc, musl 등)이며, 일부는 Windows 대체 구현 힌트를 함께 적었다.
> 구성:
> 1) **RAII `unique_fd`** — 파일 디스크립터(소켓 포함) 안전 래퍼
> 2) **안전한 `send_all/recv_exact`** — 블로킹 I/O의 부분 입출력/시그널(EINTR) 대응
> 3) **길이-프리픽스 프레이머** — 32비트 BE 길이 + payload 인코더/스트리밍 파서
> 4) **주소 문자열 변환** — `sockaddr` ↔ `host:port` 문자열, IPv6 브라켓/스코프 처리
> 5) **타임아웃 도우미** — deadline 기반 `wait_readable/writable`, 타임드 `send/recv`
> 6) **보너스** — 자주 쓰는 소켓 옵션/툴 함수 모음

---

### 20.1 헤더 단일 파일: `net_utils.hpp`

> 이 파일 하나만 프로젝트에 넣고 `#include "net_utils.hpp"`로 사용하면 된다.
> C++23을 가정했고, GCC/Clang 모두에서 빌드된다.

```cpp
// net_utils.hpp — C++23 POSIX 네트워킹 유틸 모음
#pragma once
// ======= 공통 STL =======
#include <array>
#include <bit>
#include <cassert>
#include <cerrno>
#include <cstdint>
#include <cstring>
#include <expected>
#include <functional>
#include <optional>
#include <print>
#include <span>
#include <string>
#include <string_view>
#include <system_error>
#include <utility>
#include <vector>
#include <chrono>
#include <charconv>

// ======= POSIX headers =======
#include <arpa/inet.h>
#include <fcntl.h>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <poll.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>

// ===============================================================
// 20.1.1 RAII unique_fd — 파일 디스크립터 안전 래퍼
// ===============================================================
struct fd_closer {
  void operator()(int fd) const noexcept { if (fd >= 0) ::close(fd); }
};

class unique_fd {
  int fd_ {-1};
public:
  // 생성
  constexpr unique_fd() noexcept = default;
  explicit constexpr unique_fd(int fd) noexcept : fd_(fd) {}

  // 이동만 허용
  unique_fd(const unique_fd&) = delete;
  unique_fd& operator=(const unique_fd&) = delete;

  unique_fd(unique_fd&& other) noexcept : fd_(other.release()) {}
  unique_fd& operator=(unique_fd&& other) noexcept {
    if (this != &other) reset(other.release());
    return *this;
  }

  // 파괴
  ~unique_fd() { reset(); }

  // 자원 조작
  [[nodiscard]] int get() const noexcept { return fd_; }
  [[nodiscard]] explicit operator bool() const noexcept { return fd_ >= 0; }
  [[nodiscard]] int release() noexcept { int x = fd_; fd_ = -1; return x; }
  void reset(int newfd = -1) noexcept {
    if (fd_ >= 0) ::close(fd_);
    fd_ = newfd;
  }
  void swap(unique_fd& other) noexcept { std::swap(fd_, other.fd_); }

  // 편의
  [[nodiscard]] int duplicate() const noexcept {
    if (fd_ < 0) return -1;
    return ::fcntl(fd_, F_DUPFD_CLOEXEC, 0);
  }
};

// 헬퍼: 소켓 만들기 with CLOEXEC/NONBLOCK 플래그 (에러 시 error_code)
inline std::expected<unique_fd, std::error_code>
make_socket(int family, int type, int proto, bool nonblock=true, bool cloexec=true) {
  int flags = 0;
#ifdef SOCK_NONBLOCK
  if (nonblock) type |= SOCK_NONBLOCK;
#endif
#ifdef SOCK_CLOEXEC
  if (cloexec)  type |= SOCK_CLOEXEC;
#endif
  int s = ::socket(family, type, proto);
  if (s < 0) return std::unexpected(std::error_code(errno, std::generic_category()));

  unique_fd u{s};
#ifndef SOCK_NONBLOCK
  if (nonblock) {
    int fl = ::fcntl(u.get(), F_GETFL, 0);
    if (fl < 0 || ::fcntl(u.get(), F_SETFL, fl | O_NONBLOCK) < 0)
      return std::unexpected(std::error_code(errno, std::generic_category()));
  }
#endif
#ifndef SOCK_CLOEXEC
  if (cloexec) {
    int fl = ::fcntl(u.get(), F_GETFD, 0);
    if (fl < 0 || ::fcntl(u.get(), F_SETFD, fl | FD_CLOEXEC) < 0)
      return std::unexpected(std::error_code(errno, std::generic_category()));
  }
#endif
  return u;
}

// ===============================================================
// 20.1.2 안전한 send_all / recv_exact (블로킹 변형)
//   - EINTR, 부분 입출력 처리
//   - EAGAIN/EWOULDBLOCK은 "지금 안 됨"으로 반환(논블로킹 fd 고려)
// ===============================================================
inline std::error_code send_all(int fd, std::span<const std::byte> buf, int flags=0) {
  size_t off = 0;
  while (off < buf.size()) {
    ssize_t n = ::send(fd, buf.data() + off, buf.size() - off, flags);
    if (n > 0) { off += static_cast<size_t>(n); continue; }
    if (n == 0) continue; // 드묾
    if (errno == EINTR) continue;
    if (errno == EAGAIN || errno == EWOULDBLOCK) return {errno, std::generic_category()};
    return {errno, std::generic_category()};
  }
  return {};
}

// 정확히 n 바이트를 받는다. EOF(상대 종료)는 connection_reset로 통일.
inline std::error_code recv_exact(int fd, std::span<std::byte> dst, int flags=0) {
  size_t off = 0;
  while (off < dst.size()) {
    ssize_t n = ::recv(fd, dst.data() + off, dst.size() - off, flags);
    if (n > 0) { off += static_cast<size_t>(n); continue; }
    if (n == 0) return std::make_error_code(std::errc::connection_reset); // peer closed
    if (errno == EINTR) continue;
    if (errno == EAGAIN || errno == EWOULDBLOCK) return {errno, std::generic_category()};
    return {errno, std::generic_category()};
  }
  return {};
}

// ===============================================================
// 20.1.3 길이-프리픽스 프레이머 (u32 big-endian length + payload)
//   - send_frame: writev로 헤더/바디 묶어 송신
//   - FrameParser: 스트리밍 파서(조각 입력 → 완성 프레임 콜백)
// ===============================================================
struct Frame {
  // payload를 소유(교육용 간결화). 운영에선 링버퍼/슬랩 재사용 권장.
  std::vector<std::byte> payload;
};

inline std::array<std::byte, 4> be32(uint32_t x) {
  uint32_t be = htonl(x);
  std::array<std::byte, 4> a{};
  std::memcpy(a.data(), &be, 4);
  return a;
}

inline std::expected<void, std::error_code>
send_frame(int fd, std::span<const std::byte> payload) {
  auto hdr = be32(static_cast<uint32_t>(payload.size()));
  iovec v[2];
  v[0].iov_base = const_cast<std::byte*>(hdr.data());
  v[0].iov_len  = 4;
  v[1].iov_base = const_cast<std::byte*>(payload.data());
  v[1].iov_len  = payload.size();

  // writev는 부분 쓰기가 가능 → 루프
  size_t total = 4 + payload.size();
  size_t sent  = 0;
  while (sent < total) {
    // 현재 오프셋 기준 iovec 재계산
    iovec cur[2];
    if (sent < 4) {
      cur[0].iov_base = (char*)hdr.data() + sent;
      cur[0].iov_len  = 4 - sent;
      cur[1] = v[1];
    } else {
      cur[0] = v[1];
      cur[0].iov_base = (char*)payload.data() + (sent - 4);
      cur[0].iov_len  = total - sent;
    }
    ssize_t n = ::writev(fd, cur, (sent<4 ? 2 : 1));
    if (n > 0) { sent += static_cast<size_t>(n); continue; }
    if (n == 0) continue;
    if (errno == EINTR) continue;
    if (errno == EAGAIN || errno == EWOULDBLOCK) return std::unexpected(std::error_code(errno, std::generic_category()));
    return std::unexpected(std::error_code(errno, std::generic_category()));
  }
  return {};
}

class FrameParser {
  // 내부 상태: 헤더 4B → 바디 N
  std::vector<std::byte> buf_;
  size_t parse_off_ {0};
  std::optional<uint32_t> need_; // 바디 길이
  size_t cap_ {1u<<20}; // 최대 허용(DoS 방어)
public:
  void set_cap(size_t cap) { cap_ = cap; }

  // feed: 수신 조각을 추가하고, 완성 프레임을 콜백으로 전달
  template<class Fn>
  void feed(std::span<const std::byte> chunk, Fn&& on_frame) {
    // 버퍼 뒤에 붙인다
    size_t old = buf_.size();
    buf_.resize(old + chunk.size());
    std::memcpy(buf_.data() + old, chunk.data(), chunk.size());

    // 가능한 만큼 파싱
    for (;;) {
      if (!need_) {
        if (buf_.size() - parse_off_ < 4) break; // 헤더 부족
        uint32_t be;
        std::memcpy(&be, buf_.data() + parse_off_, 4);
        uint32_t n = ntohl(be);
        if (n > cap_) {
          // 정책 위반 → 버퍼 폐기 및 예외적 처리(여기선 전체 리셋)
          buf_.clear(); parse_off_ = 0; need_.reset();
          // 운영에서는 에러 리턴/연결 종료를 권장
          return;
        }
        need_ = n;
        parse_off_ += 4;
      }
      if (need_) {
        uint32_t n = *need_;
        if (buf_.size() - parse_off_ < n) break; // 본문 부족
        Frame fr{};
        fr.payload.resize(n);
        if (n) std::memcpy(fr.payload.data(), buf_.data() + parse_off_, n);
        parse_off_ += n;
        need_.reset();
        on_frame(std::move(fr));
      }
      // 버퍼 슬라이스 소비 최적화
      if (parse_off_ > 0 && parse_off_ == buf_.size()) {
        buf_.clear(); parse_off_ = 0;
      } else if (parse_off_ > 0 && parse_off_ > (buf_.size()/2)) {
        // 절반 넘게 소비했으면 compaction
        std::vector<std::byte> tmp(buf_.begin() + parse_off_, buf_.end());
        buf_.swap(tmp);
        parse_off_ = 0;
      }
    }
  }
};

// ===============================================================
// 20.1.4 주소 문자열 변환/해석
//   - sockaddr → "host:port" (IPv6 브라켓)
//   - "host:port"/"[v6%scope]:port" 파싱 → getaddrinfo
//   - IPv4-mapped(::ffff:a.b.c.d) 미려하게 처리
// ===============================================================
inline std::string sockaddr_to_string(const sockaddr* sa, socklen_t sl) {
  char h[NI_MAXHOST]{}, s[NI_MAXSERV]{};
  int rc = ::getnameinfo(sa, sl, h, sizeof(h), s, sizeof(s),
                         NI_NUMERICHOST | NI_NUMERICSERV);
  if (rc != 0) return "(unknown)";
  // v4-mapped 사람이 보기 좋게
  std::string host = h;
  if (host.rfind("::ffff:", 0) == 0) host.erase(0, 7);
  if (sa->sa_family == AF_INET6) {
    return "[" + host + "]:" + s;
  }
  return host + ":" + s;
}

// "host:port" 혹은 "[v6%scope]:port" → {host, port} 추출
struct HostPort { std::string host, port; };

inline std::optional<HostPort> parse_hostport(std::string_view in) {
  if (in.empty()) return std::nullopt;
  if (in.front() == '[') {
    auto rb = in.find(']');
    if (rb == std::string_view::npos) return std::nullopt;
    std::string host(in.substr(1, rb-1)); // 안에 %scope 포함 가능
    std::string port = "0";
    if (rb + 1 < in.size() && in[rb+1]==':') port.assign(in.substr(rb+2));
    return HostPort{host, port};
  } else {
    // 뒤쪽 콜론 하나를 포트 구분자로 본다(IPv6가 아니므로)
    auto pos = in.rfind(':');
    if (pos == std::string_view::npos) return HostPort{std::string(in), "0"};
    return HostPort{std::string(in.substr(0,pos)), std::string(in.substr(pos+1))};
  }
}

// 주소 해석: AF_UNSPEC + AI_ADDRCONFIG, 서비스는 숫자 문자열 기대
inline std::vector<std::pair<sockaddr_storage, socklen_t>>
resolve_all_numeric(std::string_view host, std::string_view serv, int socktype=SOCK_STREAM) {
  addrinfo hints{}, *res=nullptr;
  hints.ai_family   = AF_UNSPEC;
  hints.ai_socktype = socktype;
  hints.ai_flags    = AI_ADDRCONFIG | AI_NUMERICSERV; // 포트는 숫자
  std::vector<std::pair<sockaddr_storage, socklen_t>> out;
  if (::getaddrinfo(host.empty()?nullptr:std::string(host).c_str(),
                    std::string(serv).c_str(),
                    &hints, &res) != 0) return out;
  for (auto* ai=res; ai; ai=ai->ai_next) {
    if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6) continue;
    sockaddr_storage ss{};
    std::memcpy(&ss, ai->ai_addr, ai->ai_addrlen);
    out.emplace_back(ss, static_cast<socklen_t>(ai->ai_addrlen));
  }
  ::freeaddrinfo(res);
  return out;
}

// ===============================================================
// 20.1.5 타임아웃 도우미
//   - Deadline 기반 wait_readable/writable (poll 사용)
//   - timed_send_all / timed_recv_exact
// ===============================================================
struct Deadline {
  using clock = std::chrono::steady_clock;
  clock::time_point tp;
  static Deadline after(std::chrono::milliseconds ms) {
    return Deadline{clock::now() + ms};
  }
  [[nodiscard]] int to_timeout_ms() const {
    auto now = clock::now();
    if (tp <= now) return 0;
    auto d = std::chrono::duration_cast<std::chrono::milliseconds>(tp - now);
    if (d.count() > INT32_MAX) return INT32_MAX;
    return static_cast<int>(d.count());
  }
  [[nodiscard]] bool expired() const { return clock::now() >= tp; }
};

inline std::expected<void, std::error_code>
wait_writable(int fd, Deadline dl) {
  struct pollfd p{ .fd=fd, .events=POLLOUT, .revents=0 };
  int rc = ::poll(&p, 1, dl.to_timeout_ms());
  if (rc > 0 && (p.revents & (POLLOUT|POLLERR|POLLHUP))) return {};
  if (rc == 0) return std::unexpected(std::make_error_code(std::errc::timed_out));
  return std::unexpected(std::error_code(errno, std::generic_category()));
}

inline std::expected<void, std::error_code>
wait_readable(int fd, Deadline dl) {
  struct pollfd p{ .fd=fd, .events=POLLIN, .revents=0 };
  int rc = ::poll(&p, 1, dl.to_timeout_ms());
  if (rc > 0 && (p.revents & (POLLIN|POLLERR|POLLHUP))) return {};
  if (rc == 0) return std::unexpected(std::make_error_code(std::errc::timed_out));
  return std::unexpected(std::error_code(errno, std::generic_category()));
}

// 타임드 송신/수신: EAGAIN이면 poll로 대기 후 재시도
inline std::expected<void, std::error_code>
timed_send_all(int fd, std::span<const std::byte> buf, Deadline dl, int flags=0) {
  size_t off = 0;
  while (off < buf.size()) {
    ssize_t n = ::send(fd, buf.data()+off, buf.size()-off, flags);
    if (n > 0) { off += static_cast<size_t>(n); continue; }
    if (n == 0) continue;
    if (errno == EINTR) continue;
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
      if (auto r = wait_writable(fd, dl); !r) return std::unexpected(r.error());
      continue;
    }
    return std::unexpected(std::error_code(errno, std::generic_category()));
  }
  return {};
}

inline std::expected<void, std::error_code>
timed_recv_exact(int fd, std::span<std::byte> dst, Deadline dl, int flags=0) {
  size_t off = 0;
  while (off < dst.size()) {
    ssize_t n = ::recv(fd, dst.data()+off, dst.size()-off, flags);
    if (n > 0) { off += static_cast<size_t>(n); continue; }
    if (n == 0) return std::unexpected(std::make_error_code(std::errc::connection_reset));
    if (errno == EINTR) continue;
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
      if (auto r = wait_readable(fd, dl); !r) return std::unexpected(r.error());
      continue;
    }
    return std::unexpected(std::error_code(errno, std::generic_category()));
  }
  return {};
}

// 타임드 프레임 송수신 (길이-프리픽스)
inline std::expected<void, std::error_code>
timed_send_frame(int fd, std::span<const std::byte> payload, Deadline dl) {
  auto hdr = be32(static_cast<uint32_t>(payload.size()));
  iovec v[2];
  v[0].iov_base = const_cast<std::byte*>(hdr.data());
  v[0].iov_len  = 4;
  v[1].iov_base = const_cast<std::byte*>(payload.data());
  v[1].iov_len  = payload.size();

  size_t total = 4 + payload.size();
  size_t sent  = 0;
  while (sent < total) {
    iovec cur[2];
    if (sent < 4) {
      cur[0].iov_base = (char*)hdr.data() + sent;
      cur[0].iov_len  = 4 - sent;
      cur[1] = v[1];
    } else {
      cur[0] = v[1];
      cur[0].iov_base = (char*)payload.data() + (sent - 4);
      cur[0].iov_len  = total - sent;
    }
    ssize_t n = ::writev(fd, cur, (sent<4?2:1));
    if (n > 0) { sent += (size_t)n; continue; }
    if (n == 0) continue;
    if (errno == EINTR) continue;
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
      if (auto r = wait_writable(fd, dl); !r) return std::unexpected(r.error());
      continue;
    }
    return std::unexpected(std::error_code(errno, std::generic_category()));
  }
  return {};
}

inline std::expected<std::vector<std::byte>, std::error_code>
timed_recv_frame(int fd, Deadline dl, size_t cap=(1u<<20)) {
  // 헤더 4바이트
  std::array<std::byte,4> hb{};
  if (auto r = timed_recv_exact(fd, hb, dl); !r) return std::unexpected(r.error());
  uint32_t be; std::memcpy(&be, hb.data(), 4);
  uint32_t len = ntohl(be);
  if (len > cap) return std::unexpected(std::make_error_code(std::errc::message_size));
  std::vector<std::byte> payload(len);
  if (len) {
    if (auto r = timed_recv_exact(fd, payload, dl); !r) return std::unexpected(r.error());
  }
  return payload;
}

// ===============================================================
// 20.1.6 보너스: 흔한 소켓 옵션/유틸 모음
// ===============================================================
inline void set_tcp_nodelay(int fd, bool on) {
  int v = on ? 1 : 0; ::setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &v, sizeof(v));
}
inline void set_reuseaddr(int fd, bool on) {
  int v = on ? 1 : 0; ::setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &v, sizeof(v));
}
inline void set_rcvbuf(int fd, int bytes) {
  ::setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &bytes, sizeof(bytes));
}
inline void set_sndbuf(int fd, int bytes) {
  ::setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &bytes, sizeof(bytes));
}
inline void set_keepalive_basic(int fd, bool on) {
  int v = on ? 1 : 0; ::setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &v, sizeof(v));
}
// 리눅스 세부 keepalive (초 단위)
inline void set_keepalive_tuning_linux(int fd, int idle, int intvl, int cnt) {
#ifdef TCP_KEEPIDLE
  ::setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(idle));
#endif
#ifdef TCP_KEEPINTVL
  ::setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &intvl, sizeof(intvl));
#endif
#ifdef TCP_KEEPCNT
  ::setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &cnt, sizeof(cnt));
#endif
}
inline void set_blocking(int fd, bool blocking) {
  int fl = ::fcntl(fd, F_GETFL, 0);
  if (fl < 0) return;
  if (blocking) fl &= ~O_NONBLOCK; else fl |= O_NONBLOCK;
  ::fcntl(fd, F_SETFL, fl);
}

// 간단 연결 다이얼러(블로킹 시맨틱; 논블로킹 옵션은 set_blocking으로 전환)
inline std::expected<unique_fd, std::error_code>
dial_first(std::string_view host, std::string_view port, int socktype=SOCK_STREAM) {
  auto addrs = resolve_all_numeric(host, port, socktype);
  std::error_code last{};
  for (auto& [ss, sl] : addrs) {
    auto s = make_socket(ss.ss_family, socktype, 0, /*nonblock*/false);
    if (!s) { last = s.error(); continue; }
    if (::connect(s->get(), (sockaddr*)&ss, sl) == 0) return std::move(*s);
    last = {errno, std::generic_category()};
  }
  return std::unexpected(last ? last : std::make_error_code(std::errc::host_unreachable));
}

```

---

### 20.2 사용 예 — 30줄짜리 “프레임 에코 클라이언트/서버”

> 아래 두 파일은 `net_utils.hpp`만 포함한다.
> `server`는 길이-프리픽스 프레임을 그대로 에코, `client`는 1초 타임아웃으로 한 프레임을 왕복한다.

#### 20.2.1 프레임 에코 서버 (블로킹 1-스레드, 교육용)

```cpp
// frame_echo_server.cpp
#include "net_utils.hpp"

int main(int argc, char** argv) {
  const char* host = (argc>1? argv[1] : "0.0.0.0");
  const char* port = (argc>2? argv[2] : "9000");

  // 바인드/리스닝
  addrinfo hints{}, *res=nullptr;
  hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV;
  if (getaddrinfo(host[0]?host:nullptr, port, &hints, &res)!=0) { std::print(stderr,"gai fail\n"); return 1; }
  unique_fd lfd{-1};
  for (auto* ai=res; ai; ai=ai->ai_next) {
    auto s = make_socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol, false);
    if (!s) continue;
    set_reuseaddr(s->get(), true);
    if (::bind(s->get(), ai->ai_addr, ai->ai_addrlen)==0 && ::listen(s->get(), 1024)==0) { lfd = std::move(*s); break; }
  }
  freeaddrinfo(res);
  if (!lfd) { std::print(stderr,"listen fail\n"); return 1; }
  std::print("[frame-echo] listen {}:{}\n", host, port);

  for (;;) {
    sockaddr_storage ss{}; socklen_t sl=sizeof(ss);
    int c = ::accept(lfd.get(), (sockaddr*)&ss, &sl);
    if (c < 0) { if (errno==EINTR) continue; perror("accept"); break; }
    unique_fd cfd{c};
    std::print("[conn] {}\n", sockaddr_to_string((sockaddr*)&ss, sl));

    FrameParser fp; fp.set_cap(1<<20);
    for (;;) {
      std::byte buf[8192];
      ssize_t n = ::recv(cfd.get(), buf, sizeof(buf), 0);
      if (n > 0) {
        fp.feed({buf, (size_t)n}, [&](Frame fr){
          (void)send_frame(cfd.get(), fr.payload); // 그대로 에코
        });
        continue;
      }
      if (n == 0) { std::print("[close]\n"); break; }
      if (errno==EINTR) continue;
      perror("recv"); break;
    }
  }
}
```

#### 20.2.2 프레임 에코 클라이언트 (1초 타임드 왕복)

```cpp
// frame_echo_client.cpp
#include "net_utils.hpp"

int main(int argc, char** argv) {
  if (argc < 3) { std::print(stderr, "usage: {} <host> <port> [data]\n", argv[0]); return 1; }
  auto sock = dial_first(argv[1], argv[2]);
  if (!sock) { std::print(stderr, "connect: {}\n", sock.error().message()); return 1; }
  set_tcp_nodelay(sock->get(), true);

  std::string s = (argc>3? argv[3] : "hello");
  std::vector<std::byte> payload(s.size());
  std::memcpy(payload.data(), s.data(), s.size());

  Deadline dl = Deadline::after(std::chrono::seconds(1));
  if (auto r = timed_send_frame(sock->get(), payload, dl); !r) {
    std::print(stderr, "send_frame: {}\n", r.error().message());
    return 1;
  }

  auto resp = timed_recv_frame(sock->get(), dl);
  if (!resp) {
    std::print(stderr, "recv_frame: {}\n", resp.error().message());
    return 1;
  }
  std::string out((char*)resp->data(), resp->size());
  std::print("[echo] {}\n", out);
}
```

**빌드/실행(리눅스):**
```bash
g++ -std=c++23 -O2 frame_echo_server.cpp -o server
g++ -std=c++23 -O2 frame_echo_client.cpp -o client

./server 0.0.0.0 9000 &
./client 127.0.0.1 9000 "abc123"
```

---

### 20.3 설계 노트 & 확장 아이디어

#### 20.3.1 `unique_fd` 확장
- **Windows 대체**: `unique_socket`을 별도로 두고 `closesocket` 호출. 공통 인터페이스가 필요하면 템플릿+커스텀 deleter를 쓰자.
- **소유권 주석**: 멤버로 보유 시 `[[no_unique_address]] fd_closer`를 넣어 크기를 줄일 수 있다(여기선 단순화).

#### 20.3.2 `send_all/recv_exact` 정책
- 논블로킹 파일디스크립터에서 `EAGAIN` 반환을 그대로 돌려 **상위 레이어**가 멀티플렉싱으로 이어가도록 했다.
  블로킹만 쓰는 앱이라면 `EAGAIN`에 대해 **재시도**해도 무방.

#### 20.3.3 프레이머
- 본 예제는 **u32 BE 길이** 고정. 15장에서 다룬 **헤더+CRC** 또는 **TLV**로 바로 바꿀 수 있다.
- `FrameParser::cap_`은 DoS 방어의 **최소치**다. 운영에서는 **레코드 최대치**(예: 1MiB), **연결당 버퍼 상한**, **압축폭주 방어** 등을 추가하라.

#### 20.3.4 타임아웃 도우미
- `poll` 기반 간단 구현. 고성능 서버에서는 **epoll**에 **타이머 휠**을 붙여 다수의 데드라인을 관리하라.
- `timed_*`는 **절대시한(deadline)** 기준으로 설계했다. 함수 내부에서 대기 후 재시도하므로, 총 소요시간이 **시한을 넘지 않도록** 구현되어 있다.

#### 20.3.5 주소 유틸
- `parse_hostport`는 가장 흔한 `"host:port"`, `"[v6%scope]:port"`만 다룬다. URI 스킴까지 다루려면 별도 파서가 필요하다.
- 링크-로컬 IPv6(`fe80::/64`)의 `%ifname`(scope)는 문자열에 그대로 적으면 `getaddrinfo`가 처리해 준다(플랫폼 따라 차이).
  확실히 하려면 `sin6_scope_id = if_nametoindex("eth0")` 수동 설정.

---

### 20.4 체크리스트(요약)

- [ ] 소켓/FD는 **RAII로 소유** (`unique_fd`)
- [ ] 블로킹 I/O 루프에 **EINTR/부분 I/O** 핸들링
- [ ] 스트림 위 **길이-프리픽스** 프레이밍(DoS cap 포함)
- [ ] `sockaddr` ↔ 문자열 변환(IPv6 브라켓, v4-mapped 정리)
- [ ] **deadline 기반** 타임드 `send/recv` + `wait_readable/writable`
- [ ] 자주 쓰는 옵션: `TCP_NODELAY`, `SO_REUSEADDR`, keepalive 튜닝

---

### 20.5 부록: 단위 테스트 스케치(간단)

```cpp
// net_utils_test.cpp (아이디어 스케치 수준)
#include "net_utils.hpp"
#include <cassert>

int main() {
  // be32
  auto a = be32(0x11223344);
  uint32_t r; std::memcpy(&r, a.data(), 4);
  assert(ntohl(r) == 0x11223344);

  // parse_hostport
  auto hp1 = parse_hostport("127.0.0.1:80");   assert(hp1 && hp1->host=="127.0.0.1" && hp1->port=="80");
  auto hp2 = parse_hostport("[::1]:9000");     assert(hp2 && hp2->host=="::1"        && hp2->port=="9000");
  auto hp3 = parse_hostport("example.com:0");  assert(hp3 && hp3->port=="0");

  // FrameParser
  FrameParser fp; int cnt=0; size_t total=0;
  auto mk = [](std::string s){ std::vector<std::byte> v(4+s.size()); uint32_t be=htonl((uint32_t)s.size()); std::memcpy(v.data(),&be,4); std::memcpy(v.data()+4,s.data(),s.size()); return v; };
  auto f1 = mk("ab"), f2 = mk("cdef"), f3 = mk("");
  auto cat = [&](auto& v){ std::vector<std::byte> o; o.insert(o.end(), v.begin(), v.end()); return o; };
  auto all = cat(f1); all.insert(all.end(), f2.begin(), f2.end()); all.insert(all.end(), f3.begin(), f3.end());
  // 조각내기
  fp.feed({all.data(), 3}, [&](Frame fr){ cnt++; total+=fr.payload.size(); });
  fp.feed({all.data()+3, all.size()-3}, [&](Frame fr){ cnt++; total+=fr.payload.size(); });
  assert(cnt==3 && total==(2+4+0));

  std::print("[ok] basic tests passed\n");
}
```

**빌드:**
```bash
g++ -std=c++23 -O2 net_utils_test.cpp -o test && ./test
```
