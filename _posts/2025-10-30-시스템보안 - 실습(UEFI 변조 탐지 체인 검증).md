---
layout: post
title: 시스템보안 - 실습(UEFI 변조 탐지 체인 검증)
date: 2025-10-30 21:30:23 +0900
category: 시스템보안
---
# 실습: UEFI 변조 탐지 체인 검증(가상랩)

## 큰 그림(아키텍처)

```
[OVMF(UEFI 펌웨어)] --검증--> [shim] --검증--> [Boot Manager/GRUB] --검증--> [커널] --검증--> [initramfs]
                    --측정--> TPM PCR0~7/11 ← 이벤트 로그(개체 해시, 순서, 메타)
                                         ↓
                                   [원격 검증자(Attester)]
                                         ↓
                             [정책: 허용/차단/격리/증적 보관]
```

- **Secure Boot(Verified Boot)**: 각 단계 실행 전 **서명 검증**(UEFI db/dbx, SBAT).
- **Measured Boot**: 각 단계의 해시를 **TPM PCR**에 **Extend**(누적)하고 **Event Log**로 남김.
- **원격 검증(attestation)**: TPM **Quote**(PCR + TPM 키 서명)로 “그때 실제로 무엇이 부팅되었는가”를 **증명** 후 정책 판단.

---

## 가상랩 준비(QEMU + OVMF + swtpm)

### (A) 필요 컴포넌트 설치(리눅스 호스트)

```bash
sudo apt-get update
sudo apt-get install -y qemu-system-x86 ovmf swtpm tpm2-tools \
                        seabios qemu-utils virt-manager
```

### (B) OVMF(UEFI 펌웨어) 바이너리 확인

- 일반적으로 `/usr/share/OVMF/OVMF_CODE.fd`, `OVMF_VARS.fd` 경로 제공.
- **주의**: `OVMF_VARS.fd`는 각 VM별 **사본**을 만들어 사용(여기에 PK/KEK/db/dbx 상태 저장).

```bash
mkdir -p ~/vm/uefi-lab
cp /usr/share/OVMF/OVMF_VARS.fd ~/vm/uefi-lab/OVMF_VARS_lab.fd
```

### (C) swtpm(소프트웨어 TPM) 인스턴스

```bash
mkdir -p ~/vm/uefi-lab/tpm0
swtpm socket --tpmstate dir=~/vm/uefi-lab/tpm0 \
  --tpm2 --server type=tcp,port=2321 --ctrl type=tcp,port=2322 --flags not-need-init &
```

### (D) VM 부팅(예: Ubuntu ISO)

```bash
qemu-system-x86_64 \
  -machine q35,accel=kvm \
  -m 4096 -smp 4 \
  -drive if=pflash,format=raw,readonly=on,file=/usr/share/OVMF/OVMF_CODE.fd \
  -drive if=pflash,format=raw,file=~/vm/uefi-lab/OVMF_VARS_lab.fd \
  -device virtio-net-pci,netdev=n0 \
  -netdev user,id=n0 \
  -device virtio-scsi-pci,id=scsi0 \
  -drive file=~/vm/uefi-lab/disk.qcow2,if=none,id=d0,format=qcow2 \
  -device scsi-hd,drive=d0 \
  -cdrom ~/Downloads/ubuntu-24.04-live-server-amd64.iso \
  -chardev socket,id=chrtpm,path=localhost:2321,server=off \
  -tpmdev emulator,id=tpm0,chardev=chrtpm \
  -device tpm-tis,tpmdev=tpm0
```

> 최초 설치 후 ISO 제거·재부팅. 동일 방식으로 Windows ISO도 가능(라이선스 준수).

---

## Secure Boot 상태 점검(게스트 OS 내부)

### (A) Linux 게스트

```bash
mokutil --sb-state
# → SecureBoot enabled/disabled

```
- 커널/모듈 서명 상태 확인:
```bash
sbverify --list /boot/vmlinuz-$(uname -r)  # sbverify 설치 필요
modinfo -F signer $(modprobe -n -v virtio_net | awk '{print $NF}')
```

### (B) Windows 게스트(PowerShell 관리자)

```powershell
Confirm-SecureBootUEFI
Get-Tpm
tpmtool getdeviceinformation
```

---

## Measured Boot(측정) 확인 및 이벤트 로그 수집

### (A) Linux: TPM 이벤트 로그/ PCR 덤프

```bash
# 이벤트 로그(배포판별 경로 상이):

sudo cat /sys/kernel/security/tpm0/binary_bios_measurements > /var/tmp/evlog.bin

# PCR 값(0..23 중 측정에 주로 쓰는 0~7, 11)

tpm2_pcrread sha1:0,1,2,3,4,5,6,7,11 sha256:0,1,2,3,4,5,6,7,11
```

**간단 파서(교육용)**
```python
# parse_evlog_head.py (형식 전체 파서는 tpm2_eventlog 참고)

p = "/var/tmp/evlog.bin"
data = open(p,'rb').read(64)
print("[+] First 64 bytes:", data.hex()[:128])
print("[i] Use 'tpm2_eventlog' for full decode: tpm2_eventlog /sys/kernel/security/tpm0/binary_bios_measurements")
```

### (B) Windows: 이벤트 로그 & PCR

```powershell
# PCR 읽기는 tpm2-tools for Windows 또는 상용/오픈소스 측정도구 사용
# 이벤트로그 채널: Microsoft-Windows-TPM-WMI/Operational 등

wevtutil qe Microsoft-Windows-TPM-WMI/Operational /f:text /c:10
```

---

## 변조 시나리오(“안전한” 재현을 위한 개념 실험)

> 공격 절차 제공 금지. 여기서는 **변조 탐지 체인을 시험**하기 위해 “허용 목록에서 제외된 파일/버전”을 **의도적으로 로드 시도**하여 **차단/측정 변화**를 관찰하는 **방어형** 실험을 소개합니다.

### (A) Linux에서 서명되지 않은 모듈 로드 시도(차단 확인)

```bash
# Secure Boot enforcement 활성(배포판 옵션에 따라 다름)

sudo modprobe unsigned_dummy 2>&1 | tee /var/tmp/unsigned_test.log
# 기대: "Required key not available" 등 오류 → Secure Boot 정책 정상

```

### (B) shim/GRUB 취약 버전 차단(dbx/SBAT) 검증(개념)

- **목표**: dbx 최신화 후 **취약 shim 버전** 실행이 **부팅 단계에서 차단**되는지 확인.
- 가상랩에서는 배포판 제공 **dbx 업데이트**를 적용한 뒤, 의도적으로 **오래된 shim가 포함된 ISO** 부팅 시도를 통해 차단/경고 관찰(단, 상용/배포판 라이선스 범위 내에서).

---

## 원격 검증(Attestation) – TPM Quote + 정책 판단

### (A) Linux 게스트에서 Quote 생성(데모)

```bash
# AK(Attestation Key) 생성 및 인증서 발급(간소화)

tpm2_createak --ek-context ek.ctx --ak-context ak.ctx --ak-public ak.pub --key-alg rsa --hash-alg sha256 --signing-alg rsassa
# nonce 준비

echo -n "nonce123456" > nonce.bin
# PCR 0,2,7,11 포함 Quote

tpm2_quote --key-context ak.ctx --pcr-list sha256:0,2,7,11 --message quote.msg --signature quote.sig --qualification nonce.bin
# PCR 값도 저장

tpm2_pcrread sha256:0,2,7,11 > pcrs.txt
```

### (B) 원격 검증자(서버) 개념 코드(Python)

```python
# attester_verify.py (교육용 스텁: 실제에선 인증서 체인, AK 바인딩, nonce 검증 필요)

import hashlib, json, base64

def verify_quote(signature_path, message_path, pcrs_path, expected_policy):
    sig = open(signature_path,'rb').read()
    msg = open(message_path,'rb').read()
    pcrs = open(pcrs_path,'r').read()
    # 실제 검증: TPM2TSS 라이브러리로 AK 공개키/서명 검증 + nonce 일치 + msg 구조 파싱
    # 여기선 데모로 PCR 텍스트 해시만 비교
    h = hashlib.sha256(pcrs.encode()).hexdigest()
    decision = "allow" if h in expected_policy.get("allow_hashes", []) else "deny"
    return {"decision": decision, "pcr_hash": h, "sig_len": len(sig), "msg_len": len(msg)}

if __name__=="__main__":
    policy = {"allow_hashes": ["<사전 승인된 PCR 텍스트 해시>"]}
    print(verify_quote("quote.sig","quote.msg","pcrs.txt", policy))
```

> 실제 서비스에서는 **AK 인증서 검증**, **Quote 구조 파싱**, **nonce 일치** 검증이 필수입니다. `tpm2-tools`, `go-tpm`, `python-tss` 등 사용 권장.

---

## 자동 비교: “내 베이스라인 vs 현재 측정”

### (A) 베이스라인 캡처

```bash
tpm2_pcrread sha256:0,2,4,7,11 > /var/tmp/pcr-baseline.txt
sha256sum /boot/vmlinuz-$(uname -r) /boot/efi/EFI/ubuntu/shimx64.efi /boot/efi/EFI/ubuntu/grubx64.efi > /var/tmp/binaries-baseline.sha256
```

### (B) 점검 스크립트(Python)

```python
# check_boot_integrity.py

import subprocess, hashlib, sys, shlex, os

BASE_PCR = "/var/tmp/pcr-baseline.txt"
BASE_BIN = "/var/tmp/binaries-baseline.sha256"

def read_cmd(cmd):
    return subprocess.check_output(shlex.split(cmd), text=True)

def digest_file(p):
    h = hashlib.sha256()
    with open(p,'rb') as f:
        while True:
            b = f.read(1<<20)
            if not b: break
            h.update(b)
    return h.hexdigest()

def check():
    # PCR 비교(간이)
    cur_pcr = read_cmd("tpm2_pcrread sha256:0,2,4,7,11")
    base_pcr = open(BASE_PCR,'r').read()
    pcr_ok = (cur_pcr.strip() == base_pcr.strip())

    # 바이너리 해시 비교
    paths = []
    for p in [f"/boot/vmlinuz-{os.uname().release}",
              "/boot/efi/EFI/ubuntu/shimx64.efi",
              "/boot/efi/EFI/ubuntu/grubx64.efi"]:
        if os.path.exists(p): paths.append(p)
    cur = { p: digest_file(p) for p in paths }
    base = {}
    if os.path.exists(BASE_BIN):
        for line in open(BASE_BIN):
            h, p = line.strip().split()
            base[p] = h

    bin_ok = True
    drift = []
    for p,h in cur.items():
        if p not in base or base[p] != h:
            bin_ok = False
            drift.append((p, h, base.get(p)))

    return {"pcr_ok": pcr_ok, "bin_ok": bin_ok, "drift": drift, "cur_pcr": cur_pcr}

if __name__=="__main__":
    r = check()
    print(r)
    if not (r["pcr_ok"] and r["bin_ok"]):
        sys.exit(2)
```

> 운영에서는 **베이스라인 승인/무결성 보관**과 **변경 승인 프로세스**(커널 업데이트, dbx 갱신 등)를 연결합니다.

---

## 실패/이상 케이스 대응

- **Secure Boot Off**: 부팅 중단 또는 **격리 VLAN**.
- **PCR 불일치**: 최신 패치로 인한 정상 변화인지 **Change Ticket** 매칭 → 아니면 **조사/격리**.
- **dbx 미갱신**: 즉시 dbx 업데이트 롤아웃.
- **TPM Quote 실패**: AK 재발급/드라이버 확인, swtpm/하드웨어 TPM 혼입 여부 점검.

---

# 방어: 부트 측정/무결성, 디바이스 제어 정책

## 부트 무결성 운영 전략

### (A) 정책 원칙

1) **Secure Boot 강제**: 전 단말 필수, **CSM(레거시 BIOS) 비활성화**.
2) **dbx 최신화 & SBAT 적용**: 취약 부트로더/컴포넌트 차단.
3) **Measured Boot 수집/검증**: PCR/이벤트로그를 EDR/SIEM로 집계 → **정책 게이트**.
4) **변경 관리**: 커널/부트로더 업데이트 시 **승인 + 베이스라인 자동 갱신**.
5) **부팅 매체 제한**: USB/PXE 부팅 차단(필요 시 일시 허용, 감사).

### (B) Windows: Exploit Protection + WDAC/Smart App Control(개념)

- **Exploit Protection**: 시스템 전역 DEP/ASLR/CFG/CET 강화(템플릿 배포).
- **WDAC**: 커널/드라이버/앱 실행 화이트리스트(서명·경로·해시 정책).
- **Defender Application Guard**: 브라우저/문서 샌드박스.

### (C) Linux: IMA/EVM(선택), 커널 모듈 서명 강제

- IMA 정책으로 **실행/읽기/모듈 로드**에 대한 **측정/평가/Appraisal** 적용.
- 배포판 제공 **module.sig_enforce=1**로 미서명 모듈 차단.

**IMA 정책 예(개념)**
```text
# /etc/ima/ima-policy (간단 예시, 배포판별 상이)

measure func=BPRM_CHECK
appraise func=KEXEC_KERNEL_CHECK appraise_type=imasig
appraise func=MODULE_CHECK appraise_type=imasig
```

---

## 디바이스 제어(USB/HID/외부매체) 정책

### (A) 리눅스: USBGuard/udev

**USBGuard 규칙 예시**
```bash
sudo usbguard generate-policy > /etc/usbguard/rules.conf
# 규칙 편집: 필요 장치만 allow, 나머지는 block
# 예) 특정 키보드 허용, 대용량저장장치 전부 차단
# allow id 046d:c31c name "Trusted Keyboard" with-interface { 03:*:* }
# block with-interface { 08:*:* }  # Mass Storage

sudo systemctl enable --now usbguard
```

**udev로 Mass Storage 차단**
```bash
# /etc/udev/rules.d/99-usbblock.rules

SUBSYSTEMS=="usb", ATTR{bInterfaceClass}=="08", ACTION=="add", ATTR{authorized}="0"
```

### (B) Windows: GPO/레지스트리 기반 장치 설치 제한

**PowerShell**
```powershell
# 장치 설치 제한 활성화(허용목록 외 차단)

$pol = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DeviceInstall\Restrictions"
New-Item -Path $pol -Force | Out-Null
New-ItemProperty -Path $pol -Name "DenyUnspecified" -Value 1 -PropertyType DWord -Force | Out-Null

# 허용 장치 ID 추가

$allowId = "USB\VID_046D&PID_C31C" # 예: 특정 키보드
New-Item -Path "$pol\AllowDeviceIDs" -Force | Out-Null
New-ItemProperty -Path "$pol\AllowDeviceIDs" -Name "1" -Value $allowId -PropertyType String -Force | Out-Null
```

> 대규모 환경은 **Intune/GPO**로 템플릿화, 파일럿 후 전사 확대.

### (C) 행위 기반 보강(입력 속도/패턴, 네트워크 NIC 생성)

- HID 입력 **비인간적 속도** 탐지 후 세션 잠금/알림.
- RNDIS/NCM **USB NIC 생성 이벤트** → 방화벽 프로파일 전환/차단.

**Windows WMI Watcher(요약 C#)**
```csharp
var q = new WqlEventQuery("SELECT * FROM __InstanceCreationEvent WITHIN 2 WHERE TargetInstance ISA 'Win32_NetworkAdapter' AND TargetInstance.AdapterTypeId=0");
```

---

## 부트/디바이스 정책을 SIEM로 연결(탐지·대응)

- **수집**:
  - Secure Boot 상태, dbx 버전, TPM PCR/Quote 결과, IMA Appraisal 실패, USB 삽입·차단 이벤트, 드라이버 로드 실패.
- **상관분석 룰**:
  - “Secure Boot Off + 미서명 드라이버 로드 시도” → **High**
  - “USB HID 신규 삽입 직후 쉘/스크립트 실행” → **High**
  - “PCR 불일치 + 커널 버전 드리프트 티켓 無” → **Critical**

---

## 운영 체크리스트

**부트 무결성**
- [ ] Secure Boot ON, CSM OFF
- [ ] dbx 최신화, SBAT 적용
- [ ] TPM Measured Boot 수집, 원격 Quote 검증
- [ ] 베이스라인 승인/갱신 프로세스(커널·shim·grub)
- [ ] USB/PXE 부팅 금지(예외는 만료일)

**커널/드라이버**
- [ ] 모듈 서명 강제(module.sig_enforce=1)
- [ ] Windows WDAC/드라이버 서명 정책
- [ ] Exploit Protection 템플릿 배포

**디바이스 제어**
- [ ] USBGuard(리눅스) 허용 목록
- [ ] Windows 장치 설치 제한(허용 ID만), RNDIS 차단
- [ ] SIEM로 삽입/차단/패턴 이벤트 수집

**IR/감사**
- [ ] PCR 불일치/Quote 실패 → 자동 티켓 + 격리
- [ ] dbx/펌웨어 업데이트 이력 관리
- [ ] USB 예외 승인 만료·재검토

---

## “끝에서 끝까지” 운영 리허설(미니 플레이북)

1) **베이스라인 확정**: 패치 후 PCR/바이너리 해시 저장·서명.
2) **정책 배포**: Secure Boot 강제, dbx 업데이트, USB 정책 롤아웃.
3) **감시 룰**: SIEM 규칙 활성화(상관분석 포함).
4) **테스트**:
   - 미서명 모듈 로드 시도 → 차단/로그 확인.
   - 의도적 PCR 변화(정상 업데이트) → 티켓 승인 → 베이스라인 자동 갱신.
   - 허용되지 않은 USB → 즉시 차단/경보.
5) **사고 훈련**: Secure Boot Off 감지 → 원인 분석(펌웨어 설정/공격/오류) → 시정 조치.

---

# 부록: 스크립트/정책 스니펫 모음

### A) Linux IMA 키 배포(개념)

```bash
# IMA용 X.509 공개키 커널 키링 등록

keyctl padd asymmetric ".ima" %:.ima < ima_pubkey.der
# Appraisal 정책에서 해당 키로 서명된 파일만 허용

```

### B) Sysmon(Windows) — 이동식 미디어/드라이버 감시(발췌)

```xml
<Sysmon schemaversion="4.90">
  <EventFiltering>
    <DriverLoad onmatch="include">
      <Signature condition="is">Unsigned</Signature>
    </DriverLoad>
    <FileCreate onmatch="include">
      <TargetFilename condition="contains">\Removable</TargetFilename>
    </FileCreate>
  </EventFiltering>
</Sysmon>
```

### C) dbx 업데이트 자동 점검(리눅스)

```bash
fwupdmgr get-updates | grep -i dbx -A2
fwupdmgr update
```

---

# 결론

- **UEFI Secure Boot + dbx + Measured Boot(Attestation)**는 **부팅 단계부터의 신뢰**와 **사후 증명**을 동시에 제공합니다.
- **베이스라인-정책-검증-로깅**이 연결된 자동화가 있어야 **변조/미승인 변경**을 즉시 탐지하고 차단할 수 있습니다.
- **디바이스 제어(USB/HID/네트워킹)**는 허용 목록 + 행위 감시 + 물리/관리 통제로 다층 방어를 구성해야 합니다.
- 본 장의 스크립트/정책 스니펫을 **파일럿 → 점진 배포**로 도입해, **업데이트/예외/IR**까지 닫힌 루프를 완성하세요.
