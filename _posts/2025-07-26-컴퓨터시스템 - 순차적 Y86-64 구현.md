---
layout: post
title: 컴퓨터시스템 - 순차적 Y86-64 구현
date: 2025-07-26 21:20:23 +0900
category: 컴퓨터시스템
---
# 순차적 Y86-64 구현 (Sequential Y86-64 Implementation)

## 0. 큰그림 — SEQ가 가르쳐 주는 것

- **한 번에 한 명령**: Fetch→Decode→Execute→Memory→Write-back→PC Update를 **동일 클록**의 조합 논리로 처리하고, **엣지에서 상태 갱신**.
- **학습 핵심**: (1) 명령 포맷 해석, (2) src/dst/aluA/aluB/alufun 선택, (3) CC(ZF,SF,OF) 갱신, (4) 메모리 주소·데이터, (5) 분기/호출의 PC 갱신.
- **검증 포인트**: 바이트 길이, 레지스터 소스/목적지, CC 갱신 조건, load/store 주소, ret/call PC 계산.

---

## 1. 프로세서 상태(State)와 에러 모델

- **PC** (Program Counter, 64b): 다음에 가져올 명령의 주소.
- **레지스터 파일**: 15개( `%rax..%r14` ), id=0..E, + `RNONE=0xF`(없음). 각 64b.
- **CC**: `ZF, SF, OF` (Zero/Sign/Overflow).
- **imem**: 명령 바이트 메모리(read-only).
- **dmem**: 데이터 메모리(read/write), 바이트 주소, **리틀 엔디안**.
- **Stat**: `AOK`(정상), `HLT`(halt), `ADR`(주소 오류), `INS`(잘못된 명령).

> 클록 상승에서 PC, 레지스터, CC, Stat, dmem이 갱신됨.

---

## 2. 명령 형식과 길이

첫 바이트: `[icode:4][ifun:4]` (+ 필요시 reg 바이트/8바이트 즉치값).

| icode | 이름 | ifun | 형식 | 길이(바이트) |
|---:|---|---|---|---:|
| 0x0 | `halt` | 0 | — | 1 |
| 0x1 | `nop` | 0 | — | 1 |
| 0x2 | `rrmovq`/`cmovXX` | 0..6 | +reg | 2 |
| 0x3 | `irmovq` | 0 | +reg +valC | 10 |
| 0x4 | `rmmovq` | 0 | +reg +valC | 10 |
| 0x5 | `mrmovq` | 0 | +reg +valC | 10 |
| 0x6 | `OPq` | 0:add,1:sub,2:and,3:xor | +reg | 2 |
| 0x7 | `jXX` | 0..6 | +valC | 9 |
| 0x8 | `call` | 0 | +valC | 9 |
| 0x9 | `ret` | 0 | — | 1 |
| 0xA | `pushq` | 0 | +reg | 2 |
| 0xB | `popq` | 0 | +reg | 2 |

reg 바이트는 `[rA:4][rB:4]`. `RNONE=0xF`는 필드 없음 의미.

---

## 3. 단계별 논리 (F/D/E/M/W/P)

### 3.1 Fetch
- `imem[PC]`에서 `icode, ifun` 읽기.
- `need_regids`, `need_valC`에 따라 reg 바이트 및 8바이트 `valC` 추가 인출.
- `valP = PC + instr_len`.
- **에러**: `imem_error ⇒ icode=INOP, ifun=FNONE` 취급 + `Stat=ADR`.

### 3.2 Decode
- `rA, rB`에서 **srcA, srcB** 결정, 레지스터 파일 읽기:
  - `valA = R[srcA]` (필요시)
  - `valB = R[srcB]` (필요시)

### 3.3 Execute
- **aluA/aluB** 선택으로 **valE** 계산 (주소/스택조정/산술).
- `alufun`: `IOPQ`면 ifun, 아니면 `ALUADD`.
- `set_cc`: **OPq에서만** `ZF,SF,OF` 갱신.

### 3.4 Memory
- store: `dmem[valE] ← valA` 등.
- load:  `valM ← dmem[...]`.
- **에러**: `dmem_error ⇒ Stat=ADR`.

### 3.5 Write-back
- `dstE ← valE` (조건적)
- `dstM ← valM` (조건적)

### 3.6 PC Update
- `jXX` & `Cnd` ⇒ `PC ← valC`
- `call` ⇒ `PC ← valC`
- `ret` ⇒ `PC ← valM` (스택에서 pop한 복귀주소)
- 그 외 ⇒ `PC ← valP`

---

## 4. 디코드 규칙표 (src/dst)

아래는 **정석 매핑**(CS:APP 표와 동일 의미)을 코드처럼 정리한 것.

```text
# srcA
srcA =
  rA    if icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ }
  RSP   if icode in { IPOPQ, IRET }
  RNONE otherwise

# srcB
srcB =
  rB    if icode in { IOPQ, IRMMOVQ, IMRMOVQ }
  RSP   if icode in { IPUSHQ, IPOPQ, ICALL, IRET }
  RNONE otherwise

# dstE
dstE =
  rB    if icode == IRRMOVQ && Cnd      # cmovXX 조건 성립(ifun 0이면 무조건 true → rrmovq)
  rB    if icode in { IIRMOVQ, IOPQ }   # 즉치/ALU 결과 목적지
  RSP   if icode in { IPUSHQ, IPOPQ, ICALL, IRET }  # 스택 포인터 갱신
  RNONE otherwise

# dstM
dstM =
  rA    if icode in { IMRMOVQ, IPOPQ }  # load 계열, pop은 메모리→regA
  RNONE otherwise
```

> 포인트: **dstM은 load 결과의 목적지**, **dstE는 ALU 결과의 목적지**(또는 RSP 갱신).

---

## 5. ALU 입력과 연산 선택

```text
aluA =
  valA  if icode in { IRRMOVQ, IOPQ }
  valC  if icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ }
  -8    if icode in { ICALL, IPUSHQ }
  +8    if icode in { IRET, IPOPQ }
  0     otherwise

aluB =
  valB  if icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ }
  0     otherwise

alufun =
  if icode == IOPQ then ifun else ALUADD
```

- `valE = alu(aluA, aluB, alufun)`
- `set_cc = (icode == IOPQ)`.

---

## 6. 조건 코드(CC)와 분기/이동

- `ZF` = (valE == 0), `SF` = MSB(valE), `OF` = signed overflow.
- **조건 판정** (signed):

| ifun | cmov/jXX | 판정식 |
|---:|---|---|
| 0 | (rrmovq/jmp) | true |
| 1 | le | `(SF ^ OF) | ZF` |
| 2 | l  | `SF ^ OF` |
| 3 | e  | `ZF` |
| 4 | ne | `!ZF` |
| 5 | ge | `!(SF ^ OF)` |
| 6 | g  | `!(SF ^ OF) & !ZF` |

- `Cnd`를 이용해 **cmovXX**는 `dstE`를 조건부로 활성화, **jXX**는 `newPC`를 선택.

---

## 7. 메모리 제어선 (read/write/addr/data)

- **mem_read**  = `icode in { IMRMOVQ, IPOPQ, IRET }`
- **mem_write** = `icode in { IRMMOVQ, IPUSHQ, ICALL }`

- **mem_addr**:
  - `valE` if `icode in { IRMMOVQ, IMRMOVQ, ICALL, IPUSHQ }`  (eff.addr)
  - `valA` if `icode in { IPOPQ, IRET }`                      (old RSP)

- **mem_wdata**:
  - `valA` if `icode in { IRMMOVQ, IPUSHQ }`
  - `valP` if `icode == ICALL`                                (복귀 주소 저장)

- **mem_rdata**:
  - 명령어별로 `valM`에 수신하여 Write-back에서 사용.

---

## 8. HCL 스니펫 (SEQ 제어 핵심)

> 문법은 교재 HCL 스타일로, 조합 선택을 `[...]`로 나타낸다.

### 8.1 Fetch/Decode 준비

```hcl
bool need_regids = icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ };
bool need_valC   = icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL };

int rA = [ need_regids : imem_byte2[7:4]; 1 : RNONE ];
int rB = [ need_regids : imem_byte2[3:0]; 1 : RNONE ];

int valC = [ need_valC : imem_valC; 1 : 0 ];   # 8B little-endian 확장
int valP = PC + (1 + (need_regids?1:0) + (need_valC?8:0));
```

### 8.2 src/dst

```hcl
int srcA = [
  icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ } : rA;
  icode in { IPOPQ, IRET } : RSP;
  1 : RNONE;
];

int srcB = [
  icode in { IOPQ, IRMMOVQ, IMRMOVQ } : rB;
  icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RSP;
  1 : RNONE;
];

int dstE = [
  icode == IRRMOVQ && Cnd : rB;
  icode in { IIRMOVQ, IOPQ } : rB;
  icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RSP;
  1 : RNONE;
];

int dstM = [
  icode in { IMRMOVQ, IPOPQ } : rA;
  1 : RNONE;
];
```

### 8.3 Execute/CC

```hcl
int aluA = [
  icode in { IRRMOVQ, IOPQ } : valA;
  icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : valC;
  icode in { ICALL, IPUSHQ } : -8;
  icode in { IRET, IPOPQ } : 8;
  1 : 0;
];

int aluB = [
  icode in { IRMMOVQ, IMRMOVQ, IOPQ } : valB;
  icode in { ICALL, IPUSHQ, IRET, IPOPQ } : valB;
  1 : 0;
];

int alufun = [ icode == IOPQ : ifun; 1 : ALUADD ];
bool set_cc = (icode == IOPQ);
```

### 8.4 Memory/PC

```hcl
bool mem_read  = icode in { IMRMOVQ, IPOPQ, IRET };
bool mem_write = icode in { IRMMOVQ, IPUSHQ, ICALL };

int mem_addr = [
  icode in { IRMMOVQ, IMRMOVQ, ICALL, IPUSHQ } : valE;
  icode in { IPOPQ, IRET } : valA;
];

int mem_wdata = [
  icode == IRMMOVQ : valA;
  icode == IPUSHQ  : valA;
  icode == ICALL   : valP;
];

int newPC = [
  icode == IJXX  && Cnd : valC;
  icode == ICALL        : valC;
  icode == IRET         : valM;
  1 : valP;
];
```

---

## 9. 명령별 단계 트레이스 (주소·레지스터 값 가정)

전제: `%rbp=0x100`, `%rsp=0x800`, `%rax=8`, `%rbx=4`.

### 9.1 `irmovq $0x10, %rax`
바이트: `30 f0 10 00 00 00 00 00 00 00`

- F: `icode=IIRMOVQ, rA=F, rB=0, valC=0x10, valP=PC+10`
- D: `srcA=RNONE, srcB=RNONE`
- E: `aluA=valC(0x10), aluB=0 → valE=0x10`
- M: —
- W: `dstE=%rax ← 0x10`
- P: `PC ← valP`

### 9.2 `addq %rbx, %rax` (`OPq add`, `60 30`)
- F: `icode=IOPQ, ifun=0, rA=3, rB=0, valP+=2`
- D: `valA=R[%rbx]=4, valB=R[%rax]=16`
- E: `aluA=4, aluB=16, add → valE=20, set_cc`
- M: —
- W: `%rax ← 20`
- P: `PC ← valP`

### 9.3 `rmmovq %rax, 8(%rbp)` (`40 05 08 00 ...`)
- F: `icode=IRMMOVQ, rA=0, rB=5, valC=8, valP+=10`
- D: `valA=R[%rax]=20, valB=R[%rbp]=0x100`
- E: `valE=valB+valC=0x108`
- M: `M8[0x108] ← 20`
- W: —
- P: `PC ← valP`

### 9.4 `mrmovq 8(%rbp), %rcx` (`50 15 08 00 ...`)
- F: `icode=IMRMOVQ, rA=1, rB=5, valC=8, valP+=10`
- D: `valB=R[%rbp]=0x100`
- E: `valE=0x108`
- M: `valM = M8[0x108] = 20`
- W: `%rcx ← valM (20)`
- P: `PC ← valP`

### 9.5 스택: `pushq %rcx` / `popq %rdx`
- pushq (`A0 1F`):
  - D: `valA=R[%rcx]=20, valB=R[%rsp]=0x800`
  - E: `valE=0x800-8=0x7F8`
  - M: `M8[0x7F8] ← 20`
  - W: `%rsp ← 0x7F8`
- popq (`B0 F2`):
  - D: `valA=R[%rsp]=0x7F8, valB=0x7F8`
  - E: `valE=0x800`
  - M: `valM=M8[0x7F8]=20`
  - W: `%rdx ← 20`, `%rsp ← 0x800`

### 9.6 `call foo` / `ret`
- call:
  - D: `valB=R[%rsp]`
  - E: `valE=RSP-8`
  - M: `M8[valE] ← valP` (복귀 주소 저장)
  - W: `%rsp ← valE`
  - P: `PC ← valC` (타깃)
- ret:
  - D: `valA=R[%rsp], valB=R[%rsp]`
  - E: `valE=valB+8` (`RSP+8`)
  - M: `valM=M8[valA]` (복귀 주소 로드)
  - W: `%rsp ← valE`
  - P: `PC ← valM`

---

## 10. 예외와 상태(Stat) 전이

- `halt` → `Stat=HLT`, 실행 정지.
- `imem_error | dmem_error` → `Stat=ADR`.
- 잘못된 `(icode, ifun)` 조합 → `Stat=INS`.
- 정상 → 항상 `AOK` 유지.

> 시뮬레이터는 한 사이클 말미에 `Stat` 확인 후 동작 결정.

---

## 11. 구현체 스켈레톤(시뮬레이터 의사코드)

```c
struct State {
  uint64_t PC, R[15], ZF,SF,OF;  // CC bits
  Stat stat;                     // AOK/HLT/ADR/INS
  Mem imem, dmem;
};

void step(State *S){
  // 1) Fetch
  byte b0 = imem_read(S->PC, &ok);
  if(!ok){ S->stat=ADR; return; }
  icode = b0>>4; ifun = b0 & 0xF;
  bool need_regids = in(icode, {IRRMOVQ,IOPQ,IPUSHQ,IPOPQ,IIRMOVQ,IRMMOVQ,IMRMOVQ});
  bool need_valC   = in(icode, {IIRMOVQ,IRMMOVQ,IMRMOVQ,IJXX,ICALL});
  byte rb=0; if(need_regids) rb = imem_read(S->PC+1,&ok);
  rA = need_regids ? (rb>>4) : RNONE;
  rB = need_regids ? (rb&0xF) : RNONE;
  uint64_t valC=0; if(need_valC) valC = imem_read64(S->PC+1+(need_regids?1:0), &ok);
  if(!ok){ S->stat=ADR; return; }
  uint64_t valP = S->PC + 1 + (need_regids?1:0) + (need_valC?8:0);

  // 2) Decode (srcA/srcB)
  regid srcA = RNONE, srcB = RNONE;
  // ... (표에 따라 설정)
  uint64_t valA = (srcA!=RNONE)? S->R[srcA]:0;
  uint64_t valB = (srcB!=RNONE)? S->R[srcB]:0;

  // 3) Execute
  int64_t aluA = sel_aluA(...), aluB = sel_aluB(...);
  int alufun = sel_alufun(...);
  uint64_t valE; bool ZF,SF,OF;
  alu(aluA, aluB, alufun, &valE, &ZF,&SF,&OF);
  bool set_cc = (icode==IOPQ);
  if(set_cc){ S->ZF=ZF; S->SF=SF; S->OF=OF; }

  bool Cnd = cond(ifun, S->ZF,S->SF,S->OF);  // cmov/jXX용

  // 4) Memory
  bool mem_read, mem_write; uint64_t mem_addr, mem_wdata;
  // ... (표에 따라 설정)
  uint64_t valM=0;
  if(mem_read){ valM = dmem_read64(mem_addr, &ok); if(!ok){ S->stat=ADR; return; } }
  if(mem_write){ if(!dmem_write64(mem_addr, mem_wdata)){ S->stat=ADR; return; } }

  // 5) Write-back
  regid dstE, dstM;  // (표에 따라 설정, cmovXX는 Cnd로 gate)
  if(dstE!=RNONE) S->R[dstE] = valE;
  if(dstM!=RNONE) S->R[dstM] = valM;

  // 6) PC
  uint64_t newPC = sel_newPC(icode, Cnd, valC, valM, valP);
  S->PC = newPC;

  // Stat (halt)
  if(icode==IHALT){ S->stat=HLT; }
}
```

---

## 12. 단위 테스트 벡터(예시 .ys → 기대 상태)

```asm
# sum2: %rax=8, %rbx=4 → %rax=12, 메모리/스택 확인
  .pos 0
  irmovq $8, %rax
  irmovq $4, %rbx
  addq   %rbx, %rax
  halt
```

**검증 항목**
- 각 스텝 후 `(PC, R, CC)` 확인
- `instr_len` 규칙 검증
- OPq 이외의 명령이 CC를 **변경하지 않는지** 검증
- load/store 주소/데이터 일치
- call/ret에서 `valP` ↔ `mem_wdata`(복귀주소) 검증

---

## 13. 흔한 실수 체크리스트

1. **dstM 오배선**: `mrmovq/popq`만 `dstM=rA`.
2. **cmovXX 게이팅**: `dstE=rB`는 **Cnd가 true일 때만**. (ifun=0인 rrmovq는 항상 true)
3. **CC 갱신 남발**: OPq 외에 CC 갱신하면 분기판정이 오염.
4. **mem_addr 선택**: `pop/ret`은 `valA(old RSP)`, 나머지 load/store는 `valE`.
5. **call의 mem_wdata**: 반드시 `valP`(복귀주소) 저장.
6. **valP 계산**: 길이 1/2/9/10 바이트 정확히.
7. **ret의 PC**: `newPC=valM`.
8. **에러 전파**: imem/dmem 오류 시 즉시 `ADR`로 정지.

---

## 14. 파이프라인과의 대비(요약)

- **SEQ**: 단순/명확. 한 명령이 조합 경로 전부를 통과 → 긴 critical path ⇒ 낮은 클록.
- **PIPE**: 각 단계 분할로 클록을 짧게, **여러 명령을 겹침**. 대신 hazard(데이터/제어/구조) 처리 필요(포워딩, 스톨, 분기해소).

---

## 15. 연습문제

1) `cmovl`(ifun=2)과 `jge`(ifun=5)의 Cnd 논리를 CC로부터 유도하고, 음/양/제로 경계 테스트 케이스를 작성하라.
2) `pushq`→`call`→`ret`→`popq` 시나리오에서 RSP/메모리/PC의 값 변화를 파형처럼 그려라.
3) `mrmovq`와 `rmmovq`의 메모리 주소 계산(`valE`)과 read/write 타이밍 차이를 HCL 신호로 설명하라.
4) `negq`를 `OPq sub` 변형으로 구현하려면 ifun과 aluA/aluB 선택을 어떻게 해야 하는가?

---

## 16. 부록 A — 미니 어셈블리/바이트 인코딩 예

```text
irmovq $0x10, %rax  : 30 f0 10 00 00 00 00 00 00 00
addq   %rbx, %rax   : 60 30
rmmovq %rax, 8(%rbp): 40 05 08 00 00 00 00 00 00 00
mrmovq 8(%rbp), %rcx: 50 15 08 00 00 00 00 00 00 00
pushq  %rcx         : a0 1f
popq   %rdx         : b0 f2
call   0x400        : 80 00 04 00 00 00 00 00 00
ret                 : 90
halt                : 00
```

---

## 17. 부록 B — 수식 팁(조건·주소·PC)

- 조건 판정(예):
$$
\begin{aligned}
\text{less} &: (SF \oplus OF) \\
\text{le}   &: (SF \oplus OF) \lor ZF \\
\text{ge}   &: \lnot(SF \oplus OF) \\
\text{g}    &: \lnot(SF \oplus OF) \land \lnot ZF
\end{aligned}
$$

- 유효 주소:
$$
\text{EA} = \text{valE} = \text{alu}(\text{valB}, \text{valC}, +)
$$

- PC 갱신:
$$
\text{PC}_{next} =
\begin{cases}
\text{valC}, & \text{if } icode \in \{IJXX\}\land Cnd \ \text{or } icode=ICALL \\
\text{valM}, & \text{if } icode=IRET \\
\text{valP}, & \text{otherwise}
\end{cases}
$$

---

## 18. 마무리 — 구현 순서 제안

1. **Fetch/길이/valP**부터 정확히.
2. **src/dst/aluA/aluB/alufun** 표를 코드화(스위치/테이블).
3. **메모리 경로**(addr/data/read/write) 고정.
4. **OPq의 CC**만 갱신하도록 게이트.
5. **PC 업데이트** 분기/호출/복귀 케이스 검증.
6. **Stat/예외** 처리.
7. 명령군별 유닛 테스트 → 종합 트레이스.

이 구성과 표준 HCL 스니펫을 그대로 옮기면, SEQ는 **투명한 가시성**과 **안정적인 학습경험**을 제공한다. 여기서 확장해 PIPE 구현으로 건너갈 때도 **신호 의미와 데이터 흐름**을 그대로 재사용할 수 있어 이득이 크다.
