---
layout: post
title: 컴퓨터시스템 - 순차적 Y86-64 구현
date: 2025-07-26 21:20:23 +0900
category: 컴퓨터시스템
---
# 순차적 Y86-64 구현 (Sequential Y86-64 Implementation) — 자세한 정리

> 목적: CS:APP 스타일의 **순차적(sequential)** Y86-64 프로세서(단일-프로그램-흐름, 비-파이프라인) 구현을 **실무적·교수용 관점**에서 단계별로 설명합니다.  
> 핵심 내용: 상태(State), 데이터 경로(Datapath), 제어(Control), HCL(하드웨어 제어 언어)로 표현된 제어 로직, 명령어별 순서(Fetch → Decode → Execute → Memory → Write-back → PC update), 레지스터/메모리 인터페이스, 예제 트레이스, 예외 처리와 디버깅 팁까지 포함합니다.  
> (이 자료는 CS:APP의 SEQ 설계 및 실습 자료를 따릅니다.)

---

## 개요 — 왜 순차적 구현인가?

순차적(SEQ) Y86-64 구현은 **한 명령어를 한 번의 전체 수행 과정으로 처리**하는 단순한 CPU 설계입니다. 각 명령은 일련의 단계(페치, 디코드, 실행, 메모리, 쓰기)를 거치며, 각 단계의 조합 논리와 저장 요소(레지스터, 메모리, PC, CC)가 상태를 갱신합니다.  
이 설계는 교육용으로 적합: 파이프라인/슈퍼스칼라 같은 고급 기능 없이도 명령어의 각 단계가 데이터 경로와 제어 신호에 어떻게 연결되는지 명확히 볼 수 있습니다.

---

## 1. 프로세서 상태 (State)

SEQ Y86-64 프로세서가 갖는 상태요소는 다음과 같습니다:

- **PC (Program Counter)**: 다음에 페치할 명령어 주소 (word)  
- **레지스터 파일(Register File)**: 15개(0x0..0xE) + RNONE(0xF) 식별자, 각 64-bit 레지스터  
- **Condition Codes (CC)**: ZF, SF, OF (Zero, Sign, Overflow) — ALU 연산 결과를 위한 3개 비트  
- **Instruction Memory (imem)**: 명령어를 바이트 단위로 보관 (리드 전용)  
- **Data Memory (dmem)**: 데이터 읽기/쓰기용 메모리 (바이트 어드레싱, 리틀 엔디안)  
- **상태 플래그(Stat)**: AOK / HLT / ADR / INS 같은 시뮬레이터 상태 코드(예: 주소 오류, invalid instr).

> 이 상태들은 클럭의 상승 엣지(또는 시뮬레이터의 한 '사이클')에서 적절히 업데이트됩니다.

---

## 2. 명령어 실행의 6단계(SEQ 모델의 논리적 분해)

SEQ 모델에서는 **논리적으로** 다음 단계들이 수행됩니다(물론 실제 하드웨어에서는 일부가 같은 클록 사이클 내 조합 논리로 병합될 수 있음).

1. **Fetch (페치)**  
   - imem[PC] 로부터 첫 바이트(icode/ifun) 읽음  
   - 필요 시 다음 바이트(레지스터 ID), 8바이트 상수(valC)도 읽음  
   - valP = PC + instruction_length (다음 명령의 주소)
   - imem 접근 실패 → imem_error 처리

2. **Decode (디코드 / 레지스터 읽기)**  
   - 명령 형식에 따라 rA, rB를 추출  
   - srcA, srcB 결정 (명령마다 다름)  
   - 레지스터 파일에서 관련 레지스터들(R[srcA], R[srcB]) 읽어 valA, valB로 준비

3. **Execute (ALU 연산)**  
   - ALU 입력(aluA, aluB)을 선택 (valA, valB, valC, ±8 등)  
   - ALU 연산(ADD/SUB/AND/XOR 등) 수행 → valE  
   - OPq 계열이면 조건 코드(CC) 업데이트용 newCC 계산

4. **Memory (메모리 접근)**  
   - 필요하면 dmem[valE]에 쓰기(예: rmmovq, pushq, call)  
   - 필요하면 M8[valE]로부터 읽기(예: mrmovq, popq, ret) → valM  
   - 메모리 접근 실패 → dmem_error 처리

5. **Write Back (레지스터 쓰기)**  
   - dstE (ALU 결과 저장 대상) 에 valE 쓰기 (조건부)  
   - dstM (메모리에서 읽은 값 저장 대상) 에 valM 쓰기

6. **PC Update (PC 갱신)**  
   - 명령형에 따라 PC := valP (기본) 또는 PC := valC (call/jxx taken 등) 또는 PC := valM (ret/popped return addr)  
   - 조건부 점프는 `Cnd` 신호(조건 플래그 계산 결과)에 따라 결정

> 위 단계의 **계산에 필요한 값들**은 다음과 같습니다: `icode`, `ifun`, `rA`, `rB`, `valC`, `valP`, `valA`, `valB`, `valE`, `valM`, `srcA`, `srcB`, `dstE`, `dstM`, `Cnd`, `newPC`. 이 표준 분해는 CS:APP의 SEQ 설계에 따라 정형화되어 있습니다.

---

## 3. 명령 포맷과 필드

Y86-64 명령은 다음과 같은 필드 조합으로 구성됩니다:

- 첫 바이트: `[icode:4][ifun:4]`  
- 선택적 레지스터 바이트: `[rA:4][rB:4]` (일부 명령만)  
- 선택적 상수(ValC): 8바이트 (리틀 엔디안)  

대표 명령어와 형식(요약):

| 명령 | icode | 형식 |
|------|-------|------|
| halt | 0x0 | 1 byte |
| nop | 0x1 | 1 byte |
| rrmovq/cmovXX | 0x2 | 1 + reg byte |
| irmovq | 0x3 | 1 + reg byte + 8-byte V |
| rmmovq | 0x4 | 1 + reg byte + 8-byte D |
| mrmovq | 0x5 | 1 + reg byte + 8-byte D |
| OPq | 0x6 | 1 + reg byte |
| jXX | 0x7 | 1 + 8-byte Dest |
| call | 0x8 | 1 + 8-byte Dest |
| ret | 0x9 | 1 byte |
| pushq | 0xA | 1 + reg byte |
| popq | 0xB | 1 + reg byte |

(자세한 인코딩과 레지스터 id는 Y86-64 명세 참고).

---

## 4. 레지스터 접근 규칙 (src/dst 매핑)

각 명령어는 **읽을 레지스터(srcA, srcB)** 와 **쓸 레지스터(dstE, dstM)** 를 갖습니다. SEQ 설계에서 표준적으로 사용하는 매핑(책·슬라이드에 수록된 표)을 그대로 제시합니다:

### srcA 결정 규칙
```text
srcA = 
  rA   if icode in {IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ}
  RSP  if icode in {IPOPQ, IRET}
  RNONE otherwise
```

### srcB 결정 규칙
```text
srcB =
  rB   if icode in {IOPQ, IRMMOVQ, IMRMOVQ}
  RSP  if icode in {IPUSHQ, IPOPQ, ICALL, IRET}
  RNONE otherwise
```

### dstE 결정 규칙
```text
dstE =
  rB   if icode in {IRRMOVQ && Cnd, IIRMOVQ, IOPQ}
  RSP  if icode in {IPUSHQ, IPOPQ, ICALL, IRET}
  RNONE otherwise
```

### dstM 결정 규칙
```text
dstM =
  rA   if icode == IPOPQ
  rA?  no — actually pop writes M->regA, so dstM = rA when instruction is mrmovq? 
```

(보다 표준적으로 책에서는 `dstM = rA if icode == IPOPQ or ???` 대신 아래의 *정리된 표*를 확인하세요:)

> 표(간단 정리 — CS:APP 참조):
- `mrmovq D(rB), rA` : srcA = rA? (no) / srcB = rB / dstM = rA  
- `pushq rA` : srcA = rA / srcB = RSP / dstE = RSP (decrement)  
- `popq rA` : srcA = RSP / srcB = RSP / dstM = rA (valM from memory) / dstE = RSP (increment)  
- `call Dest` : srcB = RSP / dstE = RSP (push return addr) / PC <- Dest  
- `ret` : srcA = RSP / dstE = RSP / valM from memory gives new PC (pop return addr)  

(위 매핑은 CS:APP의 표를 그대로 요약한 것으로, 구현시 정확한 케이스별 매핑을 확인해야 합니다.)

> **주의:** dstM은 *메모리에서 읽은 값을 레지스터에 쓸 때* 사용되는 대상(예: `mrmovq`, `popq`)이고, dstE는 *ALU 결과(valE)를 레지스터에 쓸 때* 사용되는 대상(예: `rrmovq`, `irmovq`, `OPq`, 그리고 RSP 업데이트). 정확한 케이스 표는 책/슬라이드의 `dstE/dstM/srcA/srcB` 표를 참조하세요.

---

## 5. ALU 입력 선정(aluA/aluB) 및 alufun

ALU 입력(aluA, aluB)은 명령어에 따라 달라집니다(예: 주소 계산, 스택 포인터 조정, 산술 연산):

### aluA 규칙 (일반)
```text
aluA =
  valA   if icode in {IRRMOVQ, IOPQ}
  valC   if icode in {IIRMOVQ, IRMMOVQ, IMRMOVQ}
  -8     if icode in {ICALL, IPUSHQ}
  +8     if icode in {IRET, IPOPQ}
  0      otherwise
```

### aluB 규칙 (일반)
```text
aluB =
  valB   if icode in {IRRMOVQ, IOPQ, IRMMOVQ, IMRMOVQ, ICALL, IPUSHQ, IRET, IPOPQ}
  0      otherwise
```

### alufun 규칙
```text
alufun = if icode == IOPQ then ifun else ALUADD
```

- `ALUADD`는 기본적으로 더하기 (주소 계산 또는 RSP 조정)  
- `IOPQ` 일 때 `ifun` 값 (add/sub/and/xor)을 수행

ALU 수행 후 `valE` 계산(예: `valB + valA` 또는 `valB + valC` 등) 및 OPq에서는 CC (ZF, SF, OF)를 업데이트합니다.

---

## 6. 조건 판정(Cnd) — cmov / jXX 처리를 위한 플래그 해석

ALU가 OPq를 수행하면 CC를 갱신합니다. 조건 분기와 조건 이동은 아래와 같은 불리언 논리에 따라 결정됩니다(대표적):

- `ZF` (Zero Flag) = (valE == 0)  
- `SF` (Sign Flag) = MSB(valE)  
- `OF` (Overflow Flag) = 산술 오버플로우 발생 여부

일반적인 조건들:

- `je` / `cmove`: `ZF == 1`  
- `jne` / `cmovne`: `ZF == 0`  
- `jl` / `cmovl`: `SF ^ OF`  
- `jle` / `cmovle`: `(SF ^ OF) | ZF`  
- `jg` / `cmovg`: `!(SF ^ OF) & !ZF`  
- `jge` / `cmovge`: `!(SF ^ OF)`

(위 표는 signed 비교 기준임. unsigned 비교는 별도 CF 기반 판정이 필요하지만 Y86-64 간단 모델에서는 위의 signed 조건들을 주로 사용합니다.)

---

## 7. 메모리 동작(Addr/Data/size)과 예외 처리

- 메모리 접근은 8바이트 단위(`M8[valE]`)로 수행됩니다(64-bit 값). 주소는 바이트 단위.  
- **Instruction memory**는 명령어 인출을 위해 *최대 10바이트*(opcode+reg+8바이트 immediate)까지 읽혀야 합니다(또한 인출 중 imem_error가 발생하면 INOP 처리).
- **Data memory**는 읽기/쓰기 시 dmem_error(주소 오류) 체크 필요.  
- 시뮬레이터 수준에서는 상태 코드(Stat)로 `AOK`, `HLT`, `ADR`, `INS` 등을 사용하여 비정상 종료 원인을 전달합니다.

---

## 8. HCL(하드웨어 제어 언어)로 표현한 제어 로직 (예시)

아래는 CS:APP에서 제공하는 SEQ 제어 로직의 **대표적 HCL 스니펫**을 간단히 재구성한 예시입니다. (교육 목적 — 실제 구현시 더 엄밀한 문법 필요)

### Fetch 제어 (imem 분해)
```hcl
# icode, ifun 결정 (imem에서 읽음)
int icode = [
  imem_error : INOP;
  1 : imem_icode;
];

int ifun = [
  imem_error : FNONE;
  1 : imem_ifun;
];

bool need_regids = icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ };
bool need_valC   = icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL };
```

### Decode: src/dst 결정 (HCL 스타일)
```hcl
int srcA = [
  icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ } : rA;
  icode in { IPOPQ, IRET } : RSP;
  1 : RNONE;
];

int srcB = [
  icode in { IOPQ, IRMMOVQ, IMRMOVQ } : rB;
  icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RSP;
  1 : RNONE;
];

int dstE = [
  icode in { IRRMOVQ } && Cnd : rB;
  icode in { IIRMOVQ, IOPQ } : rB;
  icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RSP;
  1 : RNONE;
];

int dstM = [
  icode in { IMRMOVQ, IPOPQ } : rA;
  1 : RNONE;
];
```

### Execute: ALU 입력 선택 / alufun / set CC
```hcl
int aluA = [
  icode in { IRRMOVQ, IOPQ } : valA;
  icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : valC;
  icode in { ICALL, IPUSHQ } : -8;
  icode in { IRET, IPOPQ } : 8;
  1 : 0;
];

int aluB = [
  icode in { IRMMOVQ, IMRMOVQ, IOPQ } : valB;
  icode in { ICALL, IPUSHQ, IRET, IPOPQ } : valB;
  1 : 0;
];

int alufun = [
  icode == IOPQ : ifun;
  1 : ALUADD;
];

bool set_cc = (icode == IOPQ);  # OPq 명령만 CC 업데이트
```

### PC Update
```hcl
int newPC = [
  icode == IJXX && Cnd : valC;
  icode == ICALL : valC;
  icode == IRET : valM;
  1 : valP;
];
```

> 위 HCL 조각들은 SEQ 설계에서 제어 흐름을 기술하기 위한 핵심입니다. 실제 HCL 파일(교재 제공)은 이 논리를 더 완전하게 포함합니다.

---

## 9. 명령어별 실행 트레이스(구체적 예제)

아래는 몇 가지 대표 명령어에 대해 **각 단계별로 무엇이 계산되는지**를 차근차근 보여드리는 트레이스입니다. 예제로 레지스터/메모리 초기값을 가정합니다.

> 전제: 레지스터 id: %rax=0, %rcx=1, %rdx=2, %rbx=3, %rsp=4, %rbp=5, ...  
> 메모리/레지스터 값들은 예시이며, `valP`는 인스트럭션 크기만큼 PC를 증가시킵니다.

### 예제 A — `irmovq $0x10, %rax`
인코딩(바이트): `30 f0 10 00 00 00 00 00 00 00` (1 + reg byte + 8-byte imm)

- **Fetch**: 읽음 → icode=IIRMOVQ(3), ifun=0, rA=F, rB=0, valC=0x10, valP = PC + 10  
- **Decode**: srcA=RNONE, srcB=RNONE, 읽을 레지스터 없음, valA = -, valB = -  
- **Execute**: aluA = valC (0x10), aluB = 0 → valE = 0 + valC = 0x10  
- **Memory**: no mem access  
- **Write Back**: dstE = rB (%rax) ← valE (0x10)  
- **PC Update**: PC ← valP

결과: `%rax`에 0x10 저장.

---

### 예제 B — `addq %rbx, %rax` (OPq add)
인코딩(바이트): `60 30` (first byte 0x60, reg byte (regA=rbx=3, regB=rax=0))

- **Fetch**: icode=IOPQ(6), ifun=add(0), rA=3, rB=0, valP = PC + 2  
- **Decode**: srcA=rA(%rbx), srcB=rB(%rax); valA = R[%rbx]; valB = R[%rax]  
- **Execute**: aluA = valA, aluB = valB → valE = valB + valA; set_cc = true (update CC)  
- **Memory**: none  
- **Write Back**: dstE = rB (%rax) ← valE  
- **PC Update**: PC ← valP

결과: `%rax`에 `%rax + %rbx` 저장, CC 업데이트.

---

### 예제 C — `rmmovq %rax, 8(%rbp)` (store)
인코딩 예: `40 05 08 00 00 00 00 00 00 00` (regA=rax=0, regB=rbp=5, D=8)

- **Fetch**: icode=IRMMOVQ(4), rA=0, rB=5, valC=8, valP = PC+10  
- **Decode**: srcA = rA(%rax) → valA = R[%rax]; srcB = rB(%rbp) → valB = R[%rbp]  
- **Execute**: aluA = valC (8); aluB = valB → valE = valB + 8 (effective address)  
- **Memory**: M8[valE] ← valA (store R[%rax] into mem)  
- **Write Back**: none  
- **PC Update**: PC ← valP

결과: 메모리 주소 `R[%rbp] + 8`에 `%rax` 값 저장.

---

### 예제 D — `mrmovq 8(%rbp), %rcx` (load)
인코딩 예: `50 15 08 00 00 00 00 00 00 00` (regA=rcx=1, regB=rbp=5, D=8)

- **Fetch**: icode=IMRMOVQ(5), rA=1, rB=5, valC=8, valP = PC+10  
- **Decode**: valB = R[%rbp]  
- **Execute**: valE = valB + valC (effective addr)  
- **Memory**: valM = M8[valE] (read)  
- **Write Back**: dstM = rA (%rcx) ← valM  
- **PC Update**: PC ← valP

결과: `%rcx`에 메모리 값 로드.

---

### 예제 E — `pushq %rax` / `popq %rbx` (스택)
인코딩: `pushq` → `A0 0F`? (regA=rax -> regbyte = rA<<4 | 0xF); `popq` → `B0 F3`? (regA = dest? 실제 인코딩 주의)

**pushq %rax**:
- Fetch: icode=IPUSHQ, rA=0, rB=F, valP = PC+2  
- Decode: srcA = rA(%rax) → valA = R[%rax]; srcB = RSP → valB = R[%rsp]  
- Execute: valE = valB + (-8) (aluB=valB, aluA=-8)  
- Memory: M8[valE] ← valA (store)  
- Write Back: dstE = RSP ← valE (update R[%rsp])  
- PC ← valP

**popq %rbx**:
- Fetch: icode=IPOPQ, rA=rbx, rB=F, valP = PC+2  
- Decode: srcA = RSP → valA = R[%rsp]; srcB = RSP → valB = R[%rsp]  
- Execute: valE = valB + 8 (increment)  
- Memory: valM = M8[valA] (read from old top)  
- Write Back: dstM = rA (%rbx) ← valM; dstE = RSP ← valE  
- PC ← valP

> 스택 동작은 ALU가 RSP 조정(±8) → 메모리 write/read → RSP 업데이트 → (pop일 경우) valM을 reg에 기록하는 순서입니다.

---

## 10. 예외와 상태(Stat) 처리

순차적 설계에서는 다음과 같은 예외/상태를 고려해야 합니다:

- **HLT (halt)**: `halt` 명령 실행 시 상태를 HLT로 변경하고, 시뮬레이터는 멈춤  
- **ADR (address error)**: imem 또는 dmem 접근 시 잘못된 주소/에러 발생하면 ADR로 상태 설정  
- **INS (invalid instruction)**: 잘못된 icode/ifun 조합을 만났을 때 INS로 상태 설정  
- **AOK**: 정상 실행

시뮬레이터(예: y86sim)는 상태를 체크하고, 에러 발생 시 적절히 디스어셈블/디버깅 정보를 출력합니다.

---

## 11. 설계·구현 팁 / 디버깅 요령

- **바이트 길이 규칙 암기**: imrmovq/rmmovq/mrmovq/irmovq은 10바이트, jxx/call은 9바이트, other reg ops 2바이트, halt/nop/ret 1바이트. 이 규칙으로 `valP` 계산을 검증하세요. 
- **인스트럭션 필드 추출 단계별 검증**: Fetch에서 `icode/ifun`, `need_regids`, `need_valC`, `valP` 등이 올바른지 확인(특히 misaligned/imem errors)
- **레지스터 src/dst 맵핑 표를 코드로 구현**: 디코더에서 `srcA/srcB/dstE/dstM` 매핑을 중앙 집중화하면 디버깅이 수월합니다.  
- **CC 업데이트 정책 주의**: 오직 OPq 명령만 `set_cc`가 true여야 합니다. 다른 명령의 경우 CC를 변경하면 안 됩니다.
- **메모리 접근 경로 확인**: store와 load의 effective address 계산(aluB + aluA) 및 실제 메모리 read/write 시점(Execute 후 Memory 단계)을 분명히 하세요.  
- **유닛 테스트**: 각 명령어 유형별(산술, 메모리, 제어, 스택, 호출/복귀) 단위 테스트 벡터를 만들어 레지스터/메모리/PC/CC를 검증하세요. (CS:APP의 simguide에는 테스트/트레이스 유틸리티가 제공됩니다).

---

## 12. SEQ vs PIPE (간단 비교)

- **SEQ (Sequential)**: 구현이 단순하고 이해하기 쉬움. 모든 명령의 단계가 순차적으로 수행되어 한 사이클(혹은 시뮬레이터의 한 '단계')마다 명령을 완료. 그러나 실제 하드웨어에서 모든 것을 하나의 클록 턴에 넣으면 길어져 속도가 느려질 수 있음.  
- **PIPE (Pipelined)**: 각 단계가 병렬화되어 여러 명령이 동시에 진행 가능 → IPC(throughput) 증가. 그러나 구조적/데이터/제어적 hazard 처리가 필요(분기 정렬, 포워딩, 스톨 등). CS:APP은 SEQ → PIPE로 확장하며 교육합니다.

---

## 13. 도구(어셈블러/시뮬레이터)와 실습

- **yas**: Y86 어셈블러 (asm → .yo 바이너리)  
- **y86sim**: 시뮬레이터(SEQ, SEQ+, PIPE 등 모드로 실행 가능) — 레지스터/메모리/PC/CC 트레이스 기능 제공  
- **yis**: 간단한 디스어셈블러/디버거 도구 등  
- sim 가이드에는 간단한 예제와 테스트 파일이 포함되어 있으며, SEQ 구현을 디버깅하는 데 유용한 옵션들이 있습니다.

---

## 14. 마무리: 설계 시 핵심 체크리스트

1. **필드 인출(Fetch)**: `icode/ifun`, `need_regids`, `need_valC`, `valP`가 올바른지 확인  
2. **디코드(Decode)**: `srcA/srcB` 결정, 레지스터 파일에서 올바른 값을 읽었는지 확인  
3. **실행(Execute)**: ALU 입력/연산 종류(alufun)가 올바른지 확인, OPq이면 `set_cc` 적용  
4. **메모리(Memory)**: 주소(valE) 계산 정확성, read/write 시점 확인, 메모리 에러 체크  
5. **쓰기(Write-back)**: `dstE/dstM` 각각에 적절히 쓰였는지 확인  
6. **PC 갱신**: `Cnd`에 따른 분기 여부/ret/call 처리 확인  
7. **예외 처리**: imem/dmem error, invalid instr → Stat 설정 및 안전 정지