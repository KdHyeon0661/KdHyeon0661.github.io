---
layout: post
title: Spring - 검증·예외·로깅 표준화
date: 2025-10-16 17:25:23 +0900
category: Spring
---
# 검증·예외·로깅 표준화

> 목표: **Bean Validation(그룹·커스텀)**을 체계적으로 적용하고, **글로벌 예외 응답 규격**을 통일하며, **로깅(Logback)·MDC/트레이싱ID**를 일관되게 운영한다.
> 환경 가정: Spring Boot 3.3+, Spring MVC, Jakarta Validation(Bean Validation 3.0), Logback, Micrometer Tracing(OpenTelemetry/Brave 중 택1).

---

## A. Bean Validation 표준 — 그룹, 컨테이너, 커스텀 제약

### A-1. 기본 원칙

- **경계에서 검증**: Controller DTO / Config 바인딩 / Service 메서드 파라미터.
- **그룹으로 시나리오 분리**: 생성(Create) vs 수정(Update) vs 검색(Search).
- **국제화**: `messages.properties`에서 메시지 키 관리.
- **불변 DTO**(record) 권장 + **중첩 객체**도 함께 검증(`@Valid`).

```java
// 공통 그룹
public interface OnCreate {}
public interface OnUpdate {}
public interface OnSearch {}
```

### A-2. 요청 DTO 예시(그룹·컨테이너·포맷)

```java
public record CreateOrderRequest(
  @NotNull(groups = OnCreate.class) Long memberId,
  @NotEmpty(groups = OnCreate.class) List<@Valid Line> lines,
  @Valid Address shipping
) {
  public record Line(
    @NotNull(groups = OnCreate.class) Long productId,
    @Positive(groups = {OnCreate.class, OnUpdate.class}) int qty
  ) {}
}

public record Address(
  @NotBlank String city,
  @NotBlank String street,
  @Pattern(regexp = "^[0-9]{5}$", message = "{zip.invalid}") String zip
) {}
```

컨테이너 요소에 바로 제약(위 `List<@Valid Line>`, `@Positive` 참고).

### A-3. 컨트롤러에서 그룹 적용

```java
@RestController
@RequestMapping("/api/orders")
class OrderController {
  private final OrderService service;
  OrderController(OrderService service){ this.service = service; }

  @PostMapping
  @ResponseStatus(HttpStatus.CREATED)
  public OrderView create(@Validated(OnCreate.class) @RequestBody CreateOrderRequest req) {
    return service.create(req);
  }

  @PatchMapping("/{id}")
  public OrderView changeQty(@PathVariable long id,
                             @Validated(OnUpdate.class) @RequestBody CreateOrderRequest.Line line) {
    return service.changeQty(id, line);
  }
}
```

### A-4. 서비스 메서드 검증(메서드 레벨)

```java
@Service
@Validated // 클래스에 걸면 내부 public 메서드 파라미터/리턴 검증
class OrderService {

  public OrderView create(@Valid CreateOrderRequest req) { /* ... */ return null; }

  public OrderView changeQty(long id, @Valid CreateOrderRequest.Line line) { /* ... */ return null; }

  public List<@NotBlank String> findTags(@NotNull Long id) { /* 리턴 컬렉션 요소 검증 */ return List.of("a"); }
}
```

> **주의**: self-invocation(자기 자신 호출)은 AOP 프록시가 적용되지 않음 → 외부에서 호출되는 경로로 두거나, 구성 나누기.

### A-5. 클래스/교차필드 제약(예: 시작 ≤ 종료)
#### 커스텀 애노테이션

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = {PeriodValidator.class})
public @interface ValidPeriod {
  String message() default "{period.invalid}";
  Class<?>[] groups() default {};
  Class<? extends Payload>[] payload() default {};
  String start(); // 시작 필드명
  String end();   // 종료 필드명
}
```
#### 검증기

```java
public class PeriodValidator implements ConstraintValidator<ValidPeriod, Object> {
  private String startField;
  private String endField;

  @Override public void initialize(ValidPeriod anno) {
    this.startField = anno.start(); this.endField = anno.end();
  }
  @Override public boolean isValid(Object value, ConstraintValidatorContext ctx) {
    try {
      var s = (LocalDate) PropertyUtils.getProperty(value, startField);
      var e = (LocalDate) PropertyUtils.getProperty(value, endField);
      if (s == null || e == null) return true;
      if (!s.isAfter(e)) return true;
      ctx.disableDefaultConstraintViolation();
      ctx.buildConstraintViolationWithTemplate("{period.invalid}")
         .addPropertyNode(endField).addConstraintViolation();
      return false;
    } catch (Exception ex) { return false; }
  }
}
```
#### 사용

```java
@ValidPeriod(start="from", end="to", message="{search.period.invalid}")
public record OrderSearch(
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate from,
  @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate to,
  @Min(0) int page,
  @Min(1) @Max(100) int size
) {}
```

### A-6. 커스텀 제약(도메인 룰: 이메일 중복 금지)

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueEmailValidator.class)
public @interface UniqueEmail {
  String message() default "{email.duplicate}";
  Class<?>[] groups() default {};
  Class<? extends Payload>[] payload() default {};
}

@Component
@RequiredArgsConstructor
class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {
  private final MemberRepository repo;
  @Override public boolean isValid(String email, ConstraintValidatorContext ctx) {
    if (email == null || email.isBlank()) return true;
    return !repo.existsByEmail(email);
  }
}

public record MemberCreate(
  @Email @NotBlank @UniqueEmail String email,
  @NotBlank String name) {}
```

### A-7. 메시지 국제화

`src/main/resources/messages.properties`
```
zip.invalid=Zip must be 5 digits
period.invalid=End must be on or after start
search.period.invalid=Invalid search period
email.duplicate=Email already exists
```
`messages_ko.properties`
```
zip.invalid=우편번호는 5자리 숫자여야 합니다
period.invalid=종료일은 시작일보다 빠를 수 없습니다
search.period.invalid=검색 기간이 올바르지 않습니다
email.duplicate=이미 사용 중인 이메일입니다
```

### A-8. 설정 바인딩 검증(`@ConfigurationProperties`)

```java
@ConfigurationProperties(prefix="app.upload")
@Validated
public record UploadProps(
  @Max(100) int maxParallel,
  @DurationMin(seconds=1) Duration connectTimeout,
  @NotBlank String bucket
) {}
@Configuration @EnableConfigurationProperties(UploadProps.class) class AppConfig {}
```

---

## B. 글로벌 예외 응답 규격화 — Problem+JSON, 에러코드, 매핑

### B-1. 표준 모델(RFC 7807 유사)

```java
public enum ErrorCode {
  VALIDATION_FAILED("E400001"),
  MALFORMED_JSON("E400002"),
  TYPE_MISMATCH("E400003"),
  NOT_FOUND("E404001"),
  CONFLICT("E409001"),
  ACCESS_DENIED("E403001"),
  INTERNAL("E500000"),
  DB_INTEGRITY("E409002");
  public final String code;
  ErrorCode(String code){ this.code = code; }
}

public record ApiProblem(
  String type, String title, int status, String code,
  String detail, String instance, Map<String,Object> errors, String traceId) {

  public static ApiProblem of(HttpStatus s, ErrorCode c, String title, String detail,
                              Map<String,Object> errors, String instance, String traceId) {
    return new ApiProblem("about:blank", title, s.value(), c.code, detail, instance,
      errors == null ? Map.of() : errors, traceId);
  }
}
```

### B-2. Spring 예외 → 표준 응답 매핑

핵심 처리 대상:
- `MethodArgumentNotValidException`(바디 검증)
- `BindException`(폼/쿼리 바인딩 검증)
- `ConstraintViolationException`(메서드레벨 검증)
- `HttpMessageNotReadableException`(JSON 파싱)
- `MethodArgumentTypeMismatchException`(타입 변환)
- `MissingServletRequestParameterException`/`MissingServletRequestPartException`
- `NoHandlerFoundException`(404, `spring.mvc.throw-exception-if-no-handler-found=true` 필요)
- `DataIntegrityViolationException`(DB 유니크/외래키)
- `AccessDeniedException`(403)
- `Exception`(기타)

```java
@RestControllerAdvice
class GlobalExceptionHandler {

  private String traceId() { return MDC.get("traceId"); }

  @ExceptionHandler(MethodArgumentNotValidException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  ApiProblem bodyValidation(MethodArgumentNotValidException ex, HttpServletRequest req) {
    var fields = ex.getBindingResult().getFieldErrors().stream()
      .collect(Collectors.groupingBy(FieldError::getField,
        Collectors.mapping(DefaultMessageSourceResolvable::getDefaultMessage, Collectors.toList())));
    return ApiProblem.of(HttpStatus.BAD_REQUEST, ErrorCode.VALIDATION_FAILED, "Validation failed",
      "Request body validation failed", Map.of("fields", fields), req.getRequestURI(), traceId());
  }

  @ExceptionHandler(ConstraintViolationException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  ApiProblem paramValidation(ConstraintViolationException ex, HttpServletRequest req) {
    var errors = ex.getConstraintViolations().stream()
      .collect(Collectors.groupingBy(v -> v.getPropertyPath().toString(),
         Collectors.mapping(ConstraintViolation::getMessage, Collectors.toList())));
    return ApiProblem.of(HttpStatus.BAD_REQUEST, ErrorCode.VALIDATION_FAILED, "Validation failed",
      "Parameter validation failed", Map.of("violations", errors), req.getRequestURI(), traceId());
  }

  @ExceptionHandler(HttpMessageNotReadableException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  ApiProblem badJson(HttpMessageNotReadableException ex, HttpServletRequest req) {
    var cause = Optional.ofNullable(ex.getMostSpecificCause()).map(Throwable::getMessage).orElse("Invalid JSON");
    return ApiProblem.of(HttpStatus.BAD_REQUEST, ErrorCode.MALFORMED_JSON, "Malformed JSON", cause, Map.of(), req.getRequestURI(), traceId());
  }

  @ExceptionHandler(MethodArgumentTypeMismatchException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  ApiProblem typeMismatch(MethodArgumentTypeMismatchException ex, HttpServletRequest req) {
    var info = Map.of("name", ex.getName(), "requiredType", Optional.ofNullable(ex.getRequiredType()).map(Class::getSimpleName).orElse("?"));
    return ApiProblem.of(HttpStatus.BAD_REQUEST, ErrorCode.TYPE_MISMATCH, "Type mismatch",
      ex.getMessage(), info, req.getRequestURI(), traceId());
  }

  @ExceptionHandler(NoHandlerFoundException.class)
  @ResponseStatus(HttpStatus.NOT_FOUND)
  ApiProblem notFound(NoHandlerFoundException ex, HttpServletRequest req) {
    return ApiProblem.of(HttpStatus.NOT_FOUND, ErrorCode.NOT_FOUND, "Not Found", "No handler for " + ex.getRequestURL(),
      Map.of(), req.getRequestURI(), traceId());
  }

  @ExceptionHandler(DataIntegrityViolationException.class)
  @ResponseStatus(HttpStatus.CONFLICT)
  ApiProblem db(DataIntegrityViolationException ex, HttpServletRequest req) {
    return ApiProblem.of(HttpStatus.CONFLICT, ErrorCode.DB_INTEGRITY, "DB integrity violation",
      "Constraint violation or duplicate key", Map.of(), req.getRequestURI(), traceId());
  }

  @ExceptionHandler(AccessDeniedException.class)
  @ResponseStatus(HttpStatus.FORBIDDEN)
  ApiProblem forbidden(AccessDeniedException ex, HttpServletRequest req) {
    return ApiProblem.of(HttpStatus.FORBIDDEN, ErrorCode.ACCESS_DENIED, "Forbidden",
      ex.getMessage(), Map.of(), req.getRequestURI(), traceId());
  }

  @ExceptionHandler(Exception.class)
  @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
  ApiProblem any(Exception ex, HttpServletRequest req) {
    return ApiProblem.of(HttpStatus.INTERNAL_SERVER_ERROR, ErrorCode.INTERNAL, "Internal error",
      "Unexpected error", Map.of(), req.getRequestURI(), traceId());
  }
}
```

`application.yml` (404를 예외로 받기)
```yaml
spring:
  mvc:
    throw-exception-if-no-handler-found: true
  web:
    resources:
      add-mappings: false
```

### B-3. 에러 응답 예시

```json
{
  "type": "about:blank",
  "title": "Validation failed",
  "status": 400,
  "code": "E400001",
  "detail": "Request body validation failed",
  "instance": "/api/orders",
  "errors": {
    "fields": {
      "lines[0].qty": ["must be greater than 0"]
    }
  },
  "traceId": "2f5b9de5a88437d1"
}
```

> **원칙**: 내부 스택트레이스/SQL/비밀번호 등 민감정보를 절대 노출하지 않는다. 추적은 **traceId**로.

---

## C. 로깅 표준 — Logback 구성, JSON 로그, 마스킹, MDC/트레이싱

### C-1. 왜 구조화(JSON) 로그인가

- 파싱 없이 **키-값**으로 바로 검색/통계(ELK/OpenSearch/Cloud Logging).
- **traceId/spanId/userId** 등을 명시적으로 필드화.

### C-2. 의존성(선택) — JSON 인코더

```kotlin
dependencies {
  implementation("net.logstash.logback:logstash-logback-encoder:7.4") // 안정 버전 확인
}
```

### C-3. `logback-spring.xml` (콘솔 + 파일 + 비동기)

```xml
<configuration scan="true">
  <springProperty scope="context" name="APP" source="spring.application.name"/>
  <property name="LOG_DIR" value="./logs"/>

  <!-- 마스킹용 정규식 (이메일/카드/토큰의 예) -->
  <turboFilter class="ch.qos.logback.classic.turbo.ReconfigureOnChangeFilter"/>
  <conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter"/>
  <conversionRule conversionWord="wex" converterClass="net.logstash.logback.stacktrace.ThrowableHandlingConverter"/>

  <!-- JSON 패턴 -->
  <appender name="JSON" class="ch.qos.logback.core.ConsoleAppender">
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
      <customFields>{"app":"${APP:-app}","env":"${ENV:-local}"}</customFields>
      <fieldNames>
        <message>message</message>
        <level>level</level>
        <timestamp>time</timestamp>
        <stackTrace>stack</stackTrace>
      </fieldNames>
    </encoder>
  </appender>

  <!-- 파일 + 롤링 -->
  <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>${LOG_DIR}/app.log</file>
    <encoder>
      <pattern>%d{yyyy-MM-dd'T'HH:mm:ss.SSSZ} %-5level [%thread] %logger{36} - %msg%n</pattern>
    </encoder>
    <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
      <fileNamePattern>${LOG_DIR}/app.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>
      <maxHistory>14</maxHistory>
      <maxFileSize>50MB</maxFileSize>
      <totalSizeCap>5GB</totalSizeCap>
    </rollingPolicy>
  </appender>

  <!-- 비동기 -->
  <appender name="ASYNC_JSON" class="ch.qos.logback.classic.AsyncAppender">
    <queueSize>2048</queueSize>
    <discardingThreshold>0</discardingThreshold>
    <appender-ref ref="JSON"/>
  </appender>

  <logger name="org.hibernate.SQL" level="WARN"/>
  <logger name="org.springframework" level="INFO"/>

  <root level="INFO">
    <appender-ref ref="ASYNC_JSON"/>
    <appender-ref ref="FILE"/>
  </root>
</configuration>
```

> 운영에선 **AsyncAppender**로 지연 최소화, 로그 드롭 모니터링 필요. SQL은 개발/테스트에서만 DEBUG.

### C-4. 민감정보 마스킹(필터)

- **로그 남기기 전에** 값을 마스킹: 요청 DTO toString 금지, 로거에 직접 구조화하여 민감필드 제거.
- logstash-encoder의 `maskingPatterns`(7.x) 또는 **커스텀 Appender/Filter**로 처리.

간단 패턴 예(encoder 옵션 대신 코드 레벨):
```java
class Masking {
  static String email(String s){
    if (s == null || !s.contains("@")) return s;
    var parts = s.split("@");
    return parts[0].replaceAll(".(?=.{2})", "*") + "@" + parts[1];
  }
}
```

### C-5. 요청/응답 최소 로깅 + MDC

#### 요청ID/사용자ID 주입 Interceptor

```java
@Component
public class MdcInterceptor implements HandlerInterceptor {
  @Override public boolean preHandle(HttpServletRequest req, HttpServletResponse res, Object handler) {
    String rid = Optional.ofNullable(req.getHeader("X-Request-Id"))
      .filter(s -> !s.isBlank())
      .orElse(UUID.randomUUID().toString().replace("-", "").substring(0,16));
    MDC.put("traceId", rid);
    MDC.put("method", req.getMethod());
    MDC.put("path", req.getRequestURI());
    // 사용자ID는 인증 성공 후 SecurityContext에서 꺼내서 넣기(필터/인터셉터 후반부)
    return true;
  }
  @Override public void afterCompletion(HttpServletRequest req, HttpServletResponse res, Object handler, Exception ex) {
    MDC.clear();
  }
}

@Configuration
class WebMvcConfig implements WebMvcConfigurer {
  @Override public void addInterceptors(InterceptorRegistry r) { r.addInterceptor(new MdcInterceptor()); }
}
```

#### 컨트롤러 로깅(핵심 메타만)

```java
@Slf4j
@RestController
class HealthController {
  @GetMapping("/_health")
  Map<String,Object> health(HttpServletRequest req) {
    log.info("health check ok path={} method={} ua={}",
      req.getRequestURI(), req.getMethod(), Optional.ofNullable(req.getHeader("User-Agent")).orElse("-"));
    return Map.of("status","UP");
  }
}
```

> **원칙**: 본문(body) 로깅은 **기본 금지**(PII/대용량). 필요 시 **샘플링**/마스킹/사이즈 제한.

### C-6. Trace/Span 연동(Micrometer Tracing)

의존성(둘 중 하나)
```kotlin
// Brave(경량)
implementation("io.micrometer:micrometer-tracing-bridge-brave")
// OpenTelemetry
implementation("io.opentelemetry:opentelemetry-sdk")
implementation("io.opentelemetry:opentelemetry-exporter-otlp")
implementation("io.micrometer:micrometer-tracing-bridge-otel")
```
기본적으로 Spring Boot 3는 `traceId`/`spanId`를 MDC에 넣어준다. Logback JSON에 자동 포함되도록 인코더가 지원.

### C-7. 하위/상위 서비스 간 상관관계 전파

- **수신**: `traceparent`/`X-B3-TraceId` 등 헤더를 Micrometer가 자동 인식.
- **송신**: `RestTemplate`/`WebClient`에 **Tracing filter** 자동 구성.
- 본인 커스텀 헤더(`X-Request-Id`)를 병행하고 싶으면 Gateway에서 양방향 변환.

### C-8. 로깅 가이드라인(팀 기준)

- 레벨: **ERROR**(사용자 영향 오류), **WARN**(복구 가능/비정상), **INFO**(비즈니스 이력/중요 상태), **DEBUG**(개발), **TRACE**(세부).
- **키-값** 로깅: `log.info("order_created orderId={} user={}", id, user)`
- **지연 메시지**는 매개변수형 사용, if-guard 불필요: `log.debug("expensive {}", () -> calc())` 패턴은 Lombok 미지원 → 직접 if 사용.
- PII/비밀 키, 토큰은 **절대 로그 금지**(또는 마스킹).
- 예외는 한 번만 전체 스택으로 로깅(중복 금지).

---

## D. 검증·예외·로깅 “끝에서 끝까지” 미니 조합

### D-1. 흐름

1) 클라이언트가 잘못된 JSON 전송 → `HttpMessageNotReadableException`
2) 전역 핸들러가 **E400002**로 매핑 + `traceId` 포함 응답
3) 서버는 `ERROR` 레벨로 요약 로그 + `traceId`, 원인 메시지
4) 클라이언트가 `traceId`로 고객센터에 전달 → 로그/트레이싱에서 추적

### D-2. 샘플 오류 로그(JSON)

```json
{
  "time":"2025-10-22T09:54:33.341+0900",
  "level":"ERROR",
  "message":"malformed json",
  "logger":"com.example.GlobalExceptionHandler",
  "stack":"com.fasterxml.jackson.core.JsonParseException: Unexpected character ...",
  "traceId":"2f5b9de5a88437d1",
  "path":"/api/orders",
  "method":"POST"
}
```

---

## E. 테스트 — 검증/예외/로깅

### E-1. 검증 실패 테스트

```java
@WebMvcTest(controllers = OrderController.class)
@Import({GlobalExceptionHandler.class})
class ValidationTest {
  @Autowired MockMvc mvc;
  @Autowired ObjectMapper om;

  @Test
  void create_validation_error() throws Exception {
    var req = Map.of("memberId", 1, "lines", List.of(Map.of("productId", 10, "qty", 0)));
    mvc.perform(post("/api/orders").contentType(MediaType.APPLICATION_JSON).content(om.writeValueAsString(req)))
      .andExpect(status().isBadRequest())
      .andExpect(jsonPath("$.code").value("E400001"))
      .andExpect(jsonPath("$.errors.fields['lines[0].qty']").exists());
  }
}
```

### E-2. 메서드 레벨 검증 테스트

```java
@SpringBootTest
class MethodValidationTest {
  @Autowired OrderService svc;

  @Test
  void return_element_validation() {
    assertThatThrownBy(() -> svc.findTags(null)).isInstanceOf(ConstraintViolationException.class);
  }
}
```

---

## F. 운영 체크리스트(요약)

- **Bean Validation**
  - [ ] 그룹으로 시나리오 분리(Create/Update/Search)
  - [ ] 컨테이너 요소/리턴 값 검증 활성
  - [ ] 커스텀 제약: 클래스/필드/교차필드, 저장소 의존 시 읽기 전용
  - [ ] i18n 메시지 키 일원화(`messages*.properties`)

- **예외 응답**
  - [ ] RFC7807 스타일 + **에러코드** + **traceId**
  - [ ] Spring/Web/DB/Security 예외 매핑 표 준비
  - [ ] 404를 예외로 받는 설정(`throw-exception-if-no-handler-found`)
  - [ ] 민감정보 제거, 사용자 메시지 간결화

- **로깅**
  - [ ] JSON 구조화 + AsyncAppender + 롤링 정책
  - [ ] MDC(traceId, userId, path, method) 주입
  - [ ] 본문 로깅 금지(필요 시 샘플링·마스킹·사이즈 제한)
  - [ ] Trace/Span 연동으로 분산 추적
  - [ ] 민감정보 마스킹 및 보안 가이드 배포

---

## G. 한 페이지 요약

- **검증**은 경계에서, **그룹/커스텀/컨테이너**까지 적극 활용해 “잘못된 입력은 들어오지 못하게” 막는다.
- **예외 응답**은 RFC7807 유사 구조 + **에러코드/traceId**로 통일, 프런트/운영과 언어를 맞춘다.
- **로깅**은 JSON 구조화 + MDC(traceId)로 **관측성**을 확보하고, 마스킹·레벨링·비동기 처리로 **보안/성능**을 지킨다.
