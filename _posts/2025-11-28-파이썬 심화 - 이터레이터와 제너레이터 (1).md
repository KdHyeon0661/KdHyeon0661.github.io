---
layout: post
title: 파이썬 심화 - 이터레이터와 제너레이터 (1)
date: 2025-11-28 14:25:23 +0900
category: 파이썬 심화
---
# 이터레이터와 제너레이터 (1)

## 이터레이터 수동 제어와 소비

### 기본 이터레이터 소비
```python
# 기본적인 이터레이션
numbers = [1, 2, 3, 4, 5]
iterator = iter(numbers)  # 이터레이터 객체 생성

print(next(iterator))  # 1
print(next(iterator))  # 2
print(next(iterator))  # 3

# 남은 요소 모두 소비
for num in iterator:
    print(f"남은 요소: {num}")
# 출력: 남은 요소: 4
#       남은 요소: 5

# StopIteration 예외 처리
iterator = iter([1, 2])
try:
    print(next(iterator))  # 1
    print(next(iterator))  # 2
    print(next(iterator))  # StopIteration 발생
except StopIteration:
    print("이터레이터 종료")

# 파일 이터레이터 수동 제어
with open('example.txt', 'w', encoding='utf-8') as f:
    f.write("첫 번째 줄\n두 번째 줄\n세 번째 줄")

with open('example.txt', 'r', encoding='utf-8') as f:
    file_iter = iter(f.readline, '')  # 빈 문자열까지 읽기
    
    # 특정 조건에서만 소비
    first_line = next(file_iter, None)
    if first_line and "첫 번째" in first_line:
        print(f"조건 일치: {first_line.strip()}")
    
    # 나머지 라인 처리
    for line in file_iter:
        print(f"나머지: {line.strip()}")
```

### 델리게이션 순환 (Delegating Iteration)
```python
# 컨테이너 클래스에서 이터레이션 델리게이션
class Node:
    def __init__(self, value):
        self.value = value
        self.children = []
    
    def add_child(self, node):
        self.children.append(node)
    
    def __iter__(self):
        """자식 노드들의 이터레이터 반환"""
        return iter(self.children)
    
    def depth_first(self):
        """깊이 우선 탐색"""
        yield self.value
        for child in self.children:
            yield from child.depth_first()
    
    def breadth_first(self):
        """너비 우선 탐색"""
        from collections import deque
        queue = deque([self])
        
        while queue:
            current = queue.popleft()
            yield current.value
            queue.extend(current.children)

# 트리 구조 생성
root = Node("Root")
child1 = Node("Child1")
child2 = Node("Child2")
grandchild1 = Node("Grandchild1")
grandchild2 = Node("Grandchild2")

root.add_child(child1)
root.add_child(child2)
child1.add_child(grandchild1)
child2.add_child(grandchild2)

# 델리게이션된 이터레이션
print("자식 노드들:")
for child in root:  # __iter__ 메서드 호출
    print(f"  - {child.value}")

# 깊이 우선 탐색
print("\n깊이 우선 탐색:")
for node_value in root.depth_first():
    print(f"  - {node_value}")

# 너비 우선 탐색
print("\n너비 우선 탐색:")
for node_value in root.breadth_first():
    print(f"  - {node_value}")
```

## 제너레이터를 활용한 새로운 순환 패턴

### 사용자 정의 이터레이션 패턴
```python
# 슬라이딩 윈도우 제너레이터
def sliding_window(iterable, size):
    """주어진 크기의 슬라이딩 윈도우 생성"""
    from collections import deque
    from itertools import islice
    
    iterator = iter(iterable)
    window = deque(islice(iterator, size), maxlen=size)
    
    if len(window) == size:
        yield tuple(window)
    
    for item in iterator:
        window.append(item)
        yield tuple(window)

# 슬라이딩 윈도우 활용
data = [1, 2, 3, 4, 5, 6, 7]
print("슬라이딩 윈도우 (크기 3):")
for window in sliding_window(data, 3):
    print(f"  {window}")

# 배치 처리 제너레이터
def batch_generator(iterable, batch_size):
    """데이터를 배치로 나누는 제너레이터"""
    batch = []
    for item in iterable:
        batch.append(item)
        if len(batch) == batch_size:
            yield batch
            batch = []
    if batch:
        yield batch

# 배치 처리 예제
print("\n배치 처리 (크기 4):")
numbers = list(range(1, 11))
for batch in batch_generator(numbers, 4):
    print(f"  배치: {batch}")

# 피보나치 수열 제너레이터
def fibonacci_generator(limit=None):
    """피보나치 수열 생성기"""
    a, b = 0, 1
    count = 0
    
    while limit is None or count < limit:
        yield a
        a, b = b, a + b
        count += 1

# 무한 시퀀스 생성
print("\n피보나치 수열 (첫 10개):")
fib_gen = fibonacci_generator(10)
for i, num in enumerate(fib_gen, 1):
    print(f"  F{i}: {num}")

# 조건부 필터링 제너레이터
def filtered_enumerate(iterable, condition):
    """조건을 만족하는 요소만 인덱스와 함께 반환"""
    for index, value in enumerate(iterable):
        if condition(value):
            yield index, value

# 필터링 예제
numbers = [10, 25, 3, 45, 8, 12, 30]
print("\n20보다 큰 수:")
for idx, num in filtered_enumerate(numbers, lambda x: x > 20):
    print(f"  인덱스 {idx}: {num}")
```

## 이터레이터 프로토콜 구현

### 커스텀 이터레이터 클래스
```python
class CountDownIterator:
    """카운트다운 이터레이터"""
    def __init__(self, start):
        self.current = start
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        value = self.current
        self.current -= 1
        return value

# 카운트다운 사용
print("카운트다운:")
for num in CountDownIterator(5):
    print(f"  {num}")

# 체커보드 이터레이터
class CheckerboardIterator:
    """체커보드 패턴 이터레이터"""
    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols
        self.row = 0
        self.col = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.row >= self.rows:
            raise StopIteration
        
        # 체커보드 패턴 계산 (행+열이 짝수면 'X', 홀수면 'O')
        value = 'X' if (self.row + self.col) % 2 == 0 else 'O'
        
        # 위치 업데이트
        self.col += 1
        if self.col >= self.cols:
            self.col = 0
            self.row += 1
        
        return (self.row - 1, self.col, value)

print("\n체커보드 (3x3):")
checkerboard = CheckerboardIterator(3, 3)
for row, col, value in checkerboard:
    print(f"  ({row}, {col}): {value}")

# 상태 저장 이터레이터
class PrimeIterator:
    """소수 생성 이터레이터"""
    def __init__(self, max_value=None):
        self.max_value = max_value
        self.primes_found = []
        self.current = 2
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.max_value and self.current > self.max_value:
            raise StopIteration
        
        while True:
            if self.is_prime(self.current):
                prime = self.current
                self.primes_found.append(prime)
                self.current += 1
                return prime
            self.current += 1
    
    def is_prime(self, n):
        """소수 판별"""
        if n < 2:
            return False
        for prime in self.primes_found:
            if prime * prime > n:
                break
            if n % prime == 0:
                return False
        return True

print("\n소수 생성 (100까지):")
prime_iter = PrimeIterator(100)
for prime in prime_iter:
    print(f"  {prime}", end=" ")
    if prime > 50:  # 50 이후로는 조금만 출력
        print("...")
        break
```

## 역방향 순환

### 다양한 역방향 이터레이션 기법
```python
# reversed() 함수 활용
numbers = [1, 2, 3, 4, 5]
print("기본 reversed():")
for num in reversed(numbers):
    print(f"  {num}")

# 슬라이싱을 통한 역순
print("\n슬라이싱 역순:")
for num in numbers[::-1]:
    print(f"  {num}")

# enumerate와 reversed 결합
items = ['apple', 'banana', 'cherry', 'date']
print("\n역방향 enumerate:")
for i, item in enumerate(reversed(items)):
    print(f"  인덱스 {i}: {item}")

# 커스텀 역방향 이터레이터
class BidirectionalList:
    """양방향 순환 가능 리스트"""
    def __init__(self, items):
        self.items = list(items)
    
    def __iter__(self):
        return iter(self.items)
    
    def __reversed__(self):
        """역방향 이터레이터"""
        class ReverseIterator:
            def __init__(self, items):
                self.items = items
                self.index = len(items)
            
            def __iter__(self):
                return self
            
            def __next__(self):
                self.index -= 1
                if self.index < 0:
                    raise StopIteration
                return self.items[self.index]
        
        return ReverseIterator(self.items)
    
    def reverse_iter(self):
        """제너레이터를 이용한 역방향 순환"""
        for i in range(len(self.items)-1, -1, -1):
            yield self.items[i]

# 양방향 리스트 사용
bidirectional = BidirectionalList(['A', 'B', 'C', 'D'])

print("\n정방향 순환:")
for item in bidirectional:
    print(f"  {item}")

print("\n역방향 순환 (__reversed__):")
for item in reversed(bidirectional):
    print(f"  {item}")

print("\n역방향 순환 (제너레이터):")
for item in bidirectional.reverse_iter():
    print(f"  {item}")

# 파일 역방향 읽기
def read_file_reversed(filename, buf_size=8192):
    """파일을 역방향으로 읽는 제너레이터"""
    with open(filename, 'rb') as f:
        f.seek(0, 2)  # 파일 끝으로 이동
        pointer = f.tell()
        
        buffer = b''
        while pointer > 0:
            # 읽을 크기 계산
            read_size = min(buf_size, pointer)
            pointer -= read_size
            f.seek(pointer)
            
            # 데이터 읽기
            chunk = f.read(read_size)
            buffer = chunk + buffer
            
            # 줄 분리
            lines = buffer.split(b'\n')
            buffer = lines.pop(0)  # 첫 번째 조각은 완전한 줄이 아닐 수 있음
            
            # 완전한 줄들 역순으로 반환
            for line in reversed(lines):
                yield line.decode('utf-8').rstrip('\r\n')
        
        if buffer:
            yield buffer.decode('utf-8').rstrip('\r\n')

# 파일 역방향 읽기 예제
with open('example.txt', 'w', encoding='utf-8') as f:
    f.write("Line 1\nLine 2\nLine 3\nLine 4\nLine 5")

print("\n파일 역방향 읽기:")
for line in read_file_reversed('example.txt'):
    print(f"  {line}")
```

## 추가 상태를 가진 제너레이터 함수

### 상태 유지 제너레이터
```python
# 평균 계산 상태 유지 제너레이터
def running_average():
    """실행 평균을 계산하는 상태 유지 제너레이터"""
    total = 0
    count = 0
    
    while True:
        value = yield  # 값 수신
        if value is None:
            break
        
        total += value
        count += 1
        average = total / count
        yield average  # 평균 반환

# 실행 평균 사용
print("실행 평균:")
avg_gen = running_average()
next(avg_gen)  # 제너레이터 초기화

numbers = [10, 20, 30, 40, 50]
for num in numbers:
    average = avg_gen.send(num)  # 값 전송하고 결과 받기
    print(f"  숫자: {num}, 평균: {average}")
    next(avg_gen)  # 다음 yield 준비

avg_gen.close()  # 제너레이터 종료

# 상태 머신 제너레이터
def state_machine():
    """상태 머신 제너레이터"""
    state = 'IDLE'
    data = []
    
    while True:
        command = yield state
        
        if command == 'start':
            state = 'RUNNING'
            data = []
        elif command == 'add':
            if state == 'RUNNING':
                value = yield 'VALUE_REQUESTED'
                data.append(value)
                state = 'RUNNING'
            else:
                state = 'ERROR'
        elif command == 'stop':
            if state == 'RUNNING':
                state = 'STOPPED'
                yield f"Result: {sum(data)}"
            else:
                state = 'ERROR'
        elif command == 'reset':
            state = 'IDLE'
            data = []

print("\n상태 머신:")
sm = state_machine()
next(sm)  # 초기화

print(f"  상태: {sm.send('start')}")
print(f"  상태: {sm.send('add')}")
print(f"  상태: {sm.send(10)}")  # 값 전송
print(f"  상태: {sm.send('add')}")
print(f"  상태: {sm.send(20)}")  # 값 전송
result = sm.send('stop')
print(f"  결과: {result}")

# 코루틴으로서의 제너레이터
def coroutine_example():
    """코루틴 패턴 제너레이터"""
    print("코루틴 시작")
    
    try:
        while True:
            received = yield
            print(f"  수신: {received}")
            
            if isinstance(received, int):
                doubled = received * 2
                print(f"  처리: {received} → {doubled}")
            elif isinstance(received, str):
                upper = received.upper()
                print(f"  처리: {received} → {upper}")
            elif received == 'EXIT':
                break
    finally:
        print("코루틴 종료")

print("\n코루틴 예제:")
coro = coroutine_example()
next(coro)  # 코루틴 시작

coro.send(10)
coro.send("hello")
coro.send(25)
coro.send("world")

# 제너레이터 종료
try:
    coro.send('EXIT')
except StopIteration:
    pass

# 파이프라인 패턴
def producer(data):
    """데이터 생산자"""
    for item in data:
        yield item

def transformer(iterable, transform_func):
    """데이터 변환기"""
    for item in iterable:
        yield transform_func(item)

def consumer(iterable):
    """데이터 소비자"""
    result = []
    for item in iterable:
        result.append(item)
    return result

# 파이프라인 구성
print("\n제너레이터 파이프라인:")
data = [1, 2, 3, 4, 5]

# 파이프라인: 생산 → 변환 → 소비
pipeline = transformer(producer(data), lambda x: x * 2)
final_result = consumer(pipeline)

print(f"  원본: {data}")
print(f"  결과: {final_result}")

# 복잡한 상태 관리 예제
class SensorSimulator:
    """센서 시뮬레이터"""
    def __init__(self, sensor_id):
        self.sensor_id = sensor_id
        self.readings = []
        self.average = 0
        self.is_active = True
    
    def reading_generator(self):
        """센서 데이터 생성기"""
        import random
        import time
        
        while self.is_active:
            # 센서 값 생성 (노이즈 포함)
            base_value = 50 + random.uniform(-10, 10)
            noise = random.uniform(-5, 5)
            reading = base_value + noise
            
            # 상태 업데이트
            self.readings.append(reading)
            self.average = sum(self.readings[-10:]) / min(len(self.readings), 10)
            
            # 패킷 생성
            packet = {
                'sensor_id': self.sensor_id,
                'timestamp': time.time(),
                'value': reading,
                'average': self.average,
                'readings_count': len(self.readings)
            }
            
            command = yield packet
            
            # 명령어 처리
            if command == 'reset':
                self.readings.clear()
                self.average = 0
            elif command == 'stop':
                self.is_active = False
            
            # 간격 유지
            time.sleep(0.5)

print("\n센서 시뮬레이터:")
sensor = SensorSimulator('SENSOR_001')
gen = sensor.reading_generator()
next(gen)  # 초기화

# 몇 개의 데이터 읽기
for i in range(5):
    packet = gen.send(None)  # 명령 없이 다음 값 요청
    print(f"  패킷 {i+1}: 값={packet['value']:.2f}, 평균={packet['average']:.2f}")

# 리셋 명령
print("  --- 리셋 명령 ---")
packet = gen.send('reset')
print(f"  리셋 후: 값={packet['value']:.2f}, 평균={packet['average']:.2f}")

# 종료
gen.send('stop')
```

## 결론

이터레이터와 제너레이터는 Python에서 데이터 처리를 위한 강력한 추상화 도구입니다. 기본적인 `for` 루프를 넘어서 수동으로 이터레이터를 제어하면 메모리 효율성과 유연성을 크게 향상시킬 수 있습니다. `next()` 함수와 `StopIteration` 예외 처리를 이해하면 복잡한 이터레이션 흐름을 정밀하게 제어할 수 있습니다.

델리게이션 순환은 객체 지향 디자인에서 특히 유용하며, 컨테이너 객체가 내부 컬렉션의 이터레이션을 외부에 노출하는 깔끔한 방법을 제공합니다. `__iter__()` 메서드를 구현하면 사용자 정의 객체도 Python의 이터레이션 프로토콜에 완벽히 통합될 수 있습니다.

제너레이터는 이터레이터를 생성하는 간결하고 효율적인 방법으로, `yield` 키워드를 사용하여 상태를 보존하면서 값을 점진적으로 생성할 수 있습니다. 이를 통해 무한 시퀀스, 지연 평가(lazy evaluation), 복잡한 데이터 변환 파이프라인 등을 우아하게 구현할 수 있습니다.

역방향 순환은 `reversed()` 함수와 슬라이싱으로 간단히 처리할 수 있지만, `__reversed__()` 특별 메서드를 구현하면 사용자 정의 객체에 대한 역방향 이터레이션도 지원할 수 있습니다. 파일 같은 대용량 데이터를 역방향으로 읽는 것과 같은 특수한 경우에는 별도의 로직이 필요합니다.

추가 상태를 가진 제너레이터는 코루틴(coroutine) 패턴의 기초가 되며, `send()` 메서드를 통해 제너레이터와 양방향 통신이 가능합니다. 이는 상태 머신, 데이터 처리 파이프라인, 이벤트 드리븐 아키텍처 등에 활용될 수 있습니다.

이터레이터와 제너레이터의 올바른 이해와 활용은 Python으로 효율적이고 우아한 코드를 작성하는 데 필수적입니다. 이들은 대용량 데이터 처리, 메모리 효율성, 코드 가독성 측면에서 전통적인 반복문과 리스트 기반 접근법을 크게 개선할 수 있습니다. 실제 프로젝트에서는 이러한 개념들을 조합하여 복잡한 데이터 처리 작업을 간소화하고 성능을 최적화할 수 있습니다.