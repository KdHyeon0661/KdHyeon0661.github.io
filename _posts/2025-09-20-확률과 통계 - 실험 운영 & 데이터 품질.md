---
layout: post
title: 확률과 통계 - 실험 운영 & 데이터 품질
date: 2025-09-20 21:25:23 +0900
category: 확률과 통계
---
# 17) 실험 운영 & 데이터 품질 ― SRM·간섭·클러스터 설계

> **목표**
> - **SRM(Sample Ratio Mismatch)**: 정의·감지(카이제곱/순차감시), 원인 트러블슈팅(로그·배정·필터), **대응법**(중단/재랜덤화/표준화).
> - **간섭(Interference)**: SUTVA 위반 유형(노출·네트워크·캐시·경쟁), **스필오버 모델**, **두 단계(randomization)·포화(saturation)** 설계.
> - **클러스터/지오/스위치백**: 클러스터 무작위화, **설계효과**와 **ICC**, **표본/파워** 계산, **분석법**(클러스터-강건 SE/혼합모형/무작위화 추론).
> - **데이터 품질**: 배정·노출·자격(eligibility) 로그 스키마, 식별자·세션·봇·지연·중복 처리, QA 체크리스트/대시보드.
> - **함정**: 클라이언트 배정·캐시, 샤딩/해시 충돌, 필터 후 SRM, 세그먼트 SRM, 시간 자기상관, 지리적 스필오버, 다중팔/다중지표의 알파 관리.

---

## 0) Hook — “실험이 틀어지면 통계는 무의미하다”
- **SRM 한 번**이면 p값·CI는 **무의미**하다. 원인을 찾아 **실험을 고치고** 다시 시작해야 한다.
- **간섭**이 있으면 A/B 차이는 **순수한 효과**가 아니다. **클러스터/포화 설계**가 필요하다.
- **클러스터 설계효과**를 무시하면 파워 계산이 **과도하게 낙관적**이 된다.

---

## 1) SRM(Sample Ratio Mismatch)

### 1.1 정의
- 배정 비율(예: A:B = 50:50) 대비 **실제 표본 비율이 유의하게 다름**.
- 다중팔/층화에서도 동일(예: 1:1:1, 또는 각 스트라텀에서 60:40).

### 1.2 검정(단순 2팔)
- 기대 카운트 $$E_A=pn,\ E_B=(1-p)n$$, 관측 $$O_A,O_B$$.
- **카이제곱**:
  $$
  \chi^2=\frac{(O_A-E_A)^2}{E_A}+\frac{(O_B-E_B)^2}{E_B}\ \sim\ \chi^2_{(1)}.
  $$
- **다중팔 K**:
  $$
  \chi^2=\sum_{k=1}^K \frac{(O_k - E_k)^2}{E_k},\quad E_k=p_k n\ \sim\ \chi^2_{(K-1)}.
  $$

> **알람 기준(실무 관행)**  
> - 대규모 트래픽: **p < 10^{-4}** 즉시 중단 점검  
> - 소규모: p < 10^{-3} 권고  
> → **연속 모니터링**이면 보수화(Bonferroni 또는 mSPRT형 SRM 감시)

### 1.3 세그먼트 SRM
- 전체는 정상인데 **특정 세그먼트**(국가/디바이스/앱버전)에서 SRM 발생 → **분배 파이프라인/필터** 문제 신호.
- **모든 주요 스트라텀**에서 SRM 검정 테이블 운용.

### 1.4 원인 분류(체크리스트)
1) **배정 단계**
   - 클라이언트 배정(오프라인/오류/캐시)  
   - 해시/샤딩 **버전** 상이(서버·클라 불일치)  
   - 해시 **솔트/네임스페이스** 충돌  
   - **시간대별** 배정(런치/롤백), **재배정** 누락
2) **자격(Eligibility) 필터**
   - 배정 전에 필터 vs **배정 후 필터**(주의!)  
   - 지표 산출시 **추가 필터**(봇·신규)로 **팔별 누락률 차이**
3) **노출(Exposure) 파이프라인**
   - 배정은 됐으나 **노출 실패**(네트워크/캐시), 팔별 다름  
   - **클라이언트 로깅 실패**(앱버전별)  
   - **중복/리플레이**(이벤트 재전송)
4) **식별자**
   - **쿠키 재발급/리셋** 편향  
   - 멀티디바이스 매칭 실패(특정 팔 기능이 로그인 유도)
5) **쿼리/ETL**
   - **조인 조건**으로 팔 누락(내부 조인 vs 외부 조인)  
   - **타임존**/윈도 경계  
   - **지연**이 긴 지표를 **윈도 초기에 0**으로 채움

> **원칙**: **배정**은 **서버·불변·결정적**, **자격**은 **배정 이후**에 기록, **노출**은 **정확히 1회** 기록.

### 1.5 대응
- **즉시 중단** + 원인 파악  
- **클라 배정** → **서버 배정**으로 전환  
- **배정 로그와 노출 로그** **양방향 검증**(교차 체크)  
- **자격 필터**를 사전·사후로 분할 기록(eligibility_pre/eligibility_post)  
- **SRM 재모니터링** 후 재시작

---

## 2) 간섭(Interference) ― SUTVA 위반

### 2.1 유형
- **노출 스필오버**: 피드/랭킹 알고리즘 변경이 **전체 트래픽 분포**를 바꿈(피드 혼잡).  
- **네트워크**: 소셜/메시지/추천에서 **친구의 처리**가 내 결과에 영향.  
- **리소스 경쟁**: 서버 캐시/쿼터/광고 슬롯 **공유**로 팔 간 상호영향.  
- **지오/근접**: 동일 지역 사용자 간 **간접 효과**(바이럴/가격/재고).

### 2.2 노출 모델(Exposure mapping)
- 개인의 **노출**을 $$Z_i=(T_i, G_i(T_{-i}))$$ 로 쪼갠다.  
  - $$T_i$$: 나의 처리  
  - $$G_i(T_{-i})$$: 이웃의 처리 요약(예: 이웃 중 처리 비율)
- **부분 간섭(Partial Interference)**: **클러스터 내부**에서만 간섭, **클러스터 간 독립** 가정.

### 2.3 두 단계 랜덤화(포화 설계; Saturation/Two-stage)
1) **클러스터**를 **포화도** 수준 \(s\in\{0, s_1, s_2,\dots\}\)에 할당(예: 0%, 50%, 100%).  
2) 클러스터 내부에서 해당 비율로 **개인 배정**.

- **직접효과**: 동일 포화도에서 \(T_i=1\) vs \(0\) 비교  
- **간접효과(스필오버)**: 포화도 수준 간 비교(예: 0% vs 50%)  
- **총효과**: 0% vs 100%

> **장점**: **스필오버 추정 가능**, **정책적**(처리 확산율 결정)에 유용.

### 2.4 스위치백(Time-based cluster; Switchback/Interleaving)
- 클러스터=**시간 슬롯**(분/시간/일). 슬롯 단위로 A/B를 **교차 배정**.  
- **피드/검색·랭킹**처럼 **시스템 레벨 간섭**에서 효과적.  
- **자기상관**(AR)으로 **분산↑** → 분석에 **HAC/Newey–West** 또는 **클러스터-강건(SE by slot)** 필요.

### 2.5 네트워크 클러스터링
- 사용자 그래프에서 **커뮤니티 탐지**(Louvain 등)로 **클러스터** 생성.  
- **사이징**: 너무 크면 파워 ↓, 너무 작으면 간섭 잔존. **간섭 반경**·**엣지 밀도** 기준 튜닝.  
- 클러스터 **균형**(크기·특성) 위해 **재랜덤화**(§4.2) 도입.

---

## 3) 클러스터 무작위화 설계

### 3.1 설계효과(DE)와 ICC
- 클러스터 평균 크기 \(m\), **ICC**(intra-cluster corr.)를 \(\rho\)라 하면
  $$
  \text{DE} = 1 + (m-1)\rho.
  $$
- 유효 표본 크기 \(n_{\text{eff}} = n/\text{DE}\).  
- 표본·파워 계산은 **모수(as-if 독립)** 대신 **DE**를 고려.

### 3.2 균형화/층화/재랜덤화
- **층화**(지역/규모/활동성)로 **between-cluster** 변동 통제.  
- **재랜덤화(Morgan–Rubin)**: 사전 공변량 불균형 지표 \(B\)가 임계 이하일 때만 배정 **채택**.
  - 예: 각 클러스터의 과거 KPI 평균 차 **마할라노비스 거리**  
  - **보고**에 **채택 기준** 명시(선정 바이어스 방지)

### 3.3 파워/표본 크기(평균 차; 정규 근사)
- 클러스터 수 \(G_A,G_B\), 클러스터당 평균 크기 \(m_A,m_B\).  
- 개별 분산 \(\sigma^2\), ICC \(\rho\) → 클러스터 평균의 분산:
  $$
  \mathrm{Var}(\bar Y_g)=\frac{\sigma^2}{m_g}\cdot\text{DE}=\frac{\sigma^2}{m_g}\big(1+(m_g-1)\rho\big).
  $$
- 두 집단 평균 차 분산:
  $$
  \mathrm{Var}(\bar Y_B - \bar Y_A)=\frac{\sigma^2}{m_B}\text{DE}_B\frac{1}{G_B}+\frac{\sigma^2}{m_A}\text{DE}_A\frac{1}{G_A}.
  $$
- MDE(양측, 유의수준 \(\alpha\), 파워 \(1-\beta\)):
  $$
  \text{MDE} = (z_{1-\alpha/2}+z_{1-\beta})\sqrt{\mathrm{Var}(\bar Y_B - \bar Y_A)}.
  $$

> **실무 팁**  
> - **클러스터 수**가 **파워의 핵심**(큰 클러스터 수, 작은 클러스터 크기).  
> - 가능하면 **많은 소클러스터**로 설계, 분석에서 **클러스터-강건 SE**.

### 3.4 지오(Geo) 실험
- **지역(시/도)** 클러스터를 무작위화. **인구/트래픽**을 균형화(층화·가중).  
- 외부 마케팅/시즌성 차이가 큼 → **동일 기간 매칭** + **차분(DiD)** 보조.

---

## 4) 분석: 클러스터·스위치백

### 4.1 클러스터-강건 표준오차(CRVE)
- 회귀: $$Y_{ig} = \alpha + \tau T_{g} + \gamma^\top Z_{ig} + u_{ig}.$$
- **집단지정**: 클러스터 \(g\) 수준으로 **샌드위치 SE**.
- 보고: \(\hat\tau\), **CRVE CI**, **클러스터 수** 명시(작으면 t-보정).

### 4.2 혼합모형(GLMM)
- 랜덤 절편: $$Y_{ig} = \alpha + \tau T_{g} + b_g + \varepsilon_{ig},\quad b_g\sim N(0,\sigma_b^2).$$
- **해석**은 유사, 소수 클러스터에서는 **RE 추정**이 안정적일 수 있다.

### 4.3 무작위화 추론(Randomization Inference)
- 클러스터 레이블을 **재할당**(처리/대조 스왑)해 **귀무 분포** 생성 → p값 계산.  
- 클러스터 수가 **작을 때** 강력.

### 4.4 스위치백 분석
- 시간 슬롯 \(t\) 단위 패널:
  $$
  Y_t = \alpha + \tau T_t + \phi Y_{t-1} + \text{dow/hod} + \varepsilon_t,
  $$
  또는 **집단화**하여 **슬롯-강건 SE**/**HAC(Newey–West)**.
- **교대 주기**(예: 15분 교대) ≥ **시스템 메모리 길이**(캐시/피드백 효과)로 설계.

---

## 5) 데이터 품질: 로그 스키마 & QA

### 5.1 최소 로그 스키마(테이블)

**(1) 배정(Assignment)**
- `exp_id`, `user_id`, `variant`, `assign_ts`, `salt/hash_version`, `eligibility_pre`
- **원칙**: **서버에서**, **한 번**, **불변**. 클라 배정 금지.

**(2) 노출(Exposure)**
- `exp_id`, `user_id`, `variant`, `exposed_ts`, `surface`(피드/배너/푸시)
- **중복 방지**: idempotent 키(`user_id+exp_id+date`)

**(3) 자격(Eligibility) 사후**
- `eligibility_post`, `reason`(필터 사유: 앱버전, 국가, 제한 등)

**(4) 이벤트/지표(Fact)**
- 전환/클릭/세션/매출: `user_id`, `event_ts`, `value`, `surface`, `context`

**(5) 식별자 매핑**
- `device_id`, `cookie_id`, `login_id` ↔ `user_id`(스냅샷)

### 5.2 파이프라인 체크(자동)
- **SRM**(전체·스트라텀), **이중배정율**(< 0.01%)  
- **노출율 차이**(팔별): \(|p_A-p_B|\) 알람  
- **지연**: 주요 지표 **도착 분포**(p50/p95 지연 시간)  
- **중복·리플레이**율, **봇**(초고빈도/블랙리스트) 비율  
- **타임존/윈도** 경계 이벤트 검사(UTC 정규화)

### 5.3 봇/비정상 탐지(라이트)
- 헤더/UA/속도 기반 규칙 + **세션당 이벤트 상한**  
- 실험 대상에서 **봇 제외**(사전) + 산출 시 **봇 필터 지표 병기**  
- **주의**: 팔별 봇 비율 차 → **SRM false** 신호 유발 가능

---

## 6) 예제 시나리오

### 6.1 SRM 감지 & 원인 추적
- 목표 50:50인데 D+1 **p=1e-12** SRM.
- **탐색**: OS=Android에선 정상, iOS만 A:60/B:40 → iOS 앱 **클라 배정 코드 잔존**.  
- **조치**: 서버 배정 강제, **iOS 제외** 후 재시작(새 `exp_id`), 보고서에 사건 기록.

### 6.2 간섭 의심: 추천 피드 재랭킹
- 증상: 전체 A/B 차 미미, 트래픽 급증 시간대에 변형 간 분포가 뒤섞임.  
- **해결**: **스위치백**(15분 교대), **피크 시간대 별도 층화**, HAC SE로 분석 → **+0.6% 클릭율** 유의.

### 6.3 네트워크 스필오버: 친구 초대
- **두 단계 설계**: 클러스터=친구 커뮤니티, 포화도 {0, 50, 100}%.  
- **추정**: 직접효과 +0.9pp, 간접효과 +0.3pp, 총효과 +1.2pp.  
- **정책**: 포화도 50% 이상이 **최적**(한계 편익/비용 고려).

---

## 7) SQL/Python 스니펫

### 7.1 SRM 쿼리(SQL)
```sql
-- 전체 SRM
SELECT variant, COUNT(DISTINCT user_id) AS n
FROM assignment
WHERE exp_id = :exp
  AND assign_ts >= :start AND assign_ts < :end
GROUP BY 1;

-- 세그먼트 SRM
SELECT device, variant, COUNT(DISTINCT user_id) AS n
FROM assignment
WHERE exp_id = :exp
GROUP BY 1,2;
```

### 7.2 Python SRM 검정
```python
import numpy as np, scipy.stats as st

def srm_pvalue(counts, expected_props=None):
    counts = np.asarray(counts, dtype=float)
    n = counts.sum()
    K = len(counts)
    if expected_props is None:
        expected_props = np.ones(K) / K
    expected = expected_props * n
    chi2 = ((counts - expected)**2 / expected).sum()
    p = 1 - st.chi2.cdf(chi2, df=K-1)
    return chi2, p

# 예: A,B, 기대 0.5:0.5
chi2, p = srm_pvalue([51000, 49000])
print(chi2, p)
```

### 7.3 클러스터 설계효과·MDE 계산(평균 차)
```python
import numpy as np
from math import sqrt
def mde_cluster(sigma, mA, mB, rho, GA, GB, alpha=0.05, power=0.8):
    from scipy.stats import norm
    z1 = norm.ppf(1-alpha/2); z2 = norm.ppf(power)
    DE_A = 1 + (mA-1)*rho
    DE_B = 1 + (mB-1)*rho
    var = sigma**2 * (DE_A/(mA*GA) + DE_B/(mB*GB))
    return (z1+z2)*sqrt(var)

print("MDE:", mde_cluster(sigma=1.0, mA=1000, mB=1000, rho=0.01, GA=20, GB=20))
```

### 7.4 스위치백 HAC(Newey–West) 예시(statsmodels)
```python
import statsmodels.api as sm
import pandas as pd
# df: columns = ['y','T','dow_*, hod_*'] by timeslot
X = sm.add_constant(df[['T'] + [c for c in df.columns if c.startswith('dow_') or c.startswith('hod_')]])
ols = sm.OLS(df['y'], X).fit(cov_type='HAC', cov_kwds={'maxlags': 4})  # 래그는 도메인에 맞게
print(ols.summary())
```

---

## 8) 운영 규정(템플릿)

- **프리레지**(사전등록):  
  - **목표 지표/가드레일**, **배정/자격 정의**, **간섭 가정/설계**(클러스터/스위치백 여부), **SRM 알람 임계**.  
- **모니터링**:  
  - 매일 09:00 **SRM(전체·스트라텀)**, **노출율 차**, **지연 도착 분포**, **봇 비율**.  
  - 간섭 가설이면 **스위치백** 또는 **지오/클러스터**로 강등.  
- **중단 규칙**:  
  - SRM p < \(10^{-4}\): **즉시 중단** & 원인 보고(24h).  
  - 가드레일 악화 mSPRT 경계 통과: **즉시 중단**.  
- **해석/보고**:  
  - 클러스터/스위치백이면 **CRVE/HAC**로 CI 산출, **클러스터 수** 명시.  
  - **세그먼트 SRM** 결과와 **원인/조치** 부록 첨부.

---

## 9) 자주 묻는 질문(FAQ)

**Q1. SRM이 나왔는데 효과는 좋아 보입니다. 그냥 진행해도 될까요?**  
A. **아니요.** SRM은 **무작위화 실패** 신호로, 효과 추정의 **편향** 가능성이 큽니다. **원인 해결 후 재시작**이 원칙입니다.

**Q2. 간섭이 있을지 확신이 없습니다.**  
A. **사전 테스트**로 피드/검색 같은 시스템은 **스위치백 파일럿**을 먼저 돌려보세요. 간섭 징후(시간 교대에 민감, 시스템 리소스 공유)가 있으면 클러스터 설계로 전환.

**Q3. ICC는 어떻게 추정하나요?**  
A. 과거 유사 실험/사전 데이터로 **클러스터별 분산분해**(ANOVA/혼합모형)로 \(\hat\rho\)를 추정하고 보수적으로 올려 잡아 파워 계산.

**Q4. 클러스터가 너무 적습니다(예: 지오 8개). 분석은?**  
A. **무작위화 추론** 또는 **t-보정**을 동반한 **클러스터 평균 회귀**(집단-수준)로 단순화하세요. 회귀 공변량은 **사전** 요약만.

**Q5. 포화 설계에서 얼마의 포화도를 써야 하나요?**  
A. 보통 {0, 50, 100}%가 해석이 명확합니다. 네트워크 강도가 약하면 0 vs 100만으로도 충분합니다.

---

## 10) 체크리스트(출시 전·중·후)

**출시 전**
- [ ] 서버 **배정**(솔트/버전 고정), **자격 사전플래그** 기록
- [ ] 지표 정의/윈도/타임존 동결, 딜레이 분포 파악
- [ ] 간섭 위험 평가(피드/검색/추천/지오) → 필요시 **클러스터/스위치백**
- [ ] 파워 계산(ICC/DE 반영), 클러스터 수 결정
- [ ] 프리레지: SRM 알람 기준, 중단 규칙, 분석법(CRVE/HAC/RI)

**진행 중**
- [ ] **SRM**(전체·세그먼트) & **노출율 차** 알람
- [ ] 지표 지연/봇/중복 모니터링
- [ ] 간섭 설계면 슬롯/클러스터 배정 **지키기**(재배정 금지)
- [ ] 가드레일 mSPRT 감시

**종료 후**
- [ ] 분석: **CRVE/HAC/RI**, 클러스터 수·ICC 보고
- [ ] **세그먼트 SRM** 재점검(후행 필터 영향)
- [ ] 사건/알람 타임라인 부록(근거 기록)
- [ ] 재현 노트북/SQL 스냅샷 아카이브

---

## 11) 부록 ― 수학/개념

### 11.1 SRM 연속 감시의 보수화
- 시간 \(t=1,\dots,T\)에서 같은 표본에 대해 반복 SRM → **최대 통계량**의 분포가 바뀜.  
- 간단 대안: **Bonferroni**(α/T), 또는 **알파-스펜딩**으로 SRM도 관리.  
- 대규모에서는 **p < 10^{-4}** 등 **강한 기준** 사용.

### 11.2 스위치백의 자기상관 효과
- AR(1) 근사에서 유효 관측수 \(n_{\text{eff}} \approx n\frac{1-\phi}{1+\phi}\).  
- 라그 구조 추정 후 **HAC**로 교정.

### 11.3 재랜덤화의 기대 이득
- 공변량 불균형 \(B\) 임계 하에서만 채택하면, **분산 감소**(CUPED 유사) ↔ **p-값 계산**은 **채택 규칙**을 고려해야(보수적 p 또는 RI 권장).

---

## 12) TL;DR
- **SRM**은 **즉시 중단** 사안. **배정/자격/노출/ETL**을 차례로 점검하고 **서버 배정·불변 로그** 원칙을 지켜라.
- **간섭**이 의심되면 **클러스터/포화/스위치백**으로 설계를 바꾸고, 분석은 **CRVE/HAC/무작위화 추론**을 사용하라.
- **클러스터 설계**는 **ICC·DE**가 핵심. **클러스터 수를 늘리고** 균형화를 통해 **파워**를 확보하라.
- **데이터 품질**은 스키마·지연·봇·중복·타임존의 **기본기**에서 시작한다. **자동 SRM/노출율/지연 대시보드**를 운영하라.
