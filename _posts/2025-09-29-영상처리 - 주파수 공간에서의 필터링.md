---
layout: post
title: 영상처리 - 주파수 공간에서의 필터링
date: 2025-09-29 18:25:23 +0900
category: 영상처리
---
# 주파수 공간에서의 필터링

## 1) 주파수 필터링의 기본

### 1.1 주파수 축, DC 중앙 정렬
2D DFT/FFT 결과 \(F(u,v)\) 에서 **DC(0,0)** 성분은 원래 좌상단에 있으나,  
입력에 \((-1)^{x+y}\) 를 곱하거나 시각화 시 사분면 교환을 하면 **중앙**으로 옵니다.  
본 장에서는 10.3절과 동일하게 **입력 센터링**을 사용하므로,  
마스크 \(H(u,v)\) 는 **중앙(DC)** 을 기준으로 반경을 계산합니다.

\[
D(u,v) = \sqrt{(u-u_c)^2 + (v-v_c)^2},\qquad u_c=\frac{W}{2},\ v_c=\frac{H}{2}.
\]

> 실무 팁: 마스크는 “**센터링된 주파수 좌표**” 기준으로 설계해야 직관적입니다.

### 1.2 이상적(ideal) 저·고역 통과
- **저역통과(LPF)**: 반경 \(D_0\) 이내 통과, 밖은 차단  
\[
H_\text{ideal-LP}(u,v)=
\begin{cases}
1, & D(u,v)\le D_0\\
0, & \text{otherwise}
\end{cases}
\]
- **고역통과(HPF)**: \(H_\text{ideal-HP}=1-H_\text{ideal-LP}\)

> 장점: 경계가 명확, 구현 간단  
> 단점: 공간영역에서 **심한 링잉(깁스 현상)**

### 1.3 가우시안 저·고역 통과
- **가우시안 저역**
\[
H_\text{gauss-LP}(u,v) = \exp\!\left(-\frac{D(u,v)^2}{2\sigma^2}\right)
\]
- **가우시안 고역**: \(H_\text{gauss-HP}=1-H_\text{gauss-LP}\)

> 장점: 부드럽고 링잉이 적음, 미분 가능  
> 파라미터: \(\sigma\) (단위: “주파수 픽셀” 반경).  
> \(-3\,\mathrm{dB}\) 컷오프 반경을 \(D_0\) 로 쓰고 싶다면 \(\sigma = \frac{D_0}{\sqrt{2\ln 2}}\).

---

## 2) 마스크 생성과 FFT 파이프라인 연계

아래 유틸은 **패딩 후 크기(PW×PH)** 를 받아, **센터 기준** 원형 마스크를 생성합니다.  
그 다음 10.3절의 `FFT_Filter_And_IFFT()`로 **정방 FFT → 마스크 곱 → 역FFT** 를 한 번에 수행합니다.

```cpp
// frequency_filters.hpp
#pragma once
#include <vector>
#include <cmath>
#include <cstdint>
#include "fft_filter.hpp"   // FFT_Filter_And_IFFT (10.3절)
#include "fft1d.hpp"        // next_pow2

// -----------------------------
// 공통: 반경 계산 도우미
// -----------------------------
inline double radius_at(int x, int y, int W, int H) {
    const double cx = 0.5 * W;
    const double cy = 0.5 * H;
    const double dx = (double)x - cx;
    const double dy = (double)y - cy;
    return std::sqrt(dx*dx + dy*dy);
}

// -----------------------------
// Ideal masks
// -----------------------------
inline void mask_ideal_lowpass(std::vector<double>& M, int W, int H, double D0) {
    M.assign((size_t)W*H, 0.0);
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            double r = radius_at(x,y,W,H);
            M[(size_t)y*W + x] = (r <= D0) ? 1.0 : 0.0;
        }
    }
}
inline void mask_ideal_highpass(std::vector<double>& M, int W, int H, double D0) {
    mask_ideal_lowpass(M, W, H, D0);
    for (double& v : M) v = 1.0 - v;
}

// -----------------------------
// Gaussian masks
// -----------------------------
inline void mask_gaussian_lowpass(std::vector<double>& M, int W, int H, double sigma) {
    const double denom = 2.0 * sigma * sigma + 1e-12;
    M.assign((size_t)W*H, 0.0);
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            double r = radius_at(x,y,W,H);
            M[(size_t)y*W + x] = std::exp(-(r*r)/denom);
        }
    }
}
inline void mask_gaussian_highpass(std::vector<double>& M, int W, int H, double sigma) {
    mask_gaussian_lowpass(M, W, H, sigma);
    for (double& v : M) v = 1.0 - v;
}

// -----------------------------
// 한 번에 적용하는 래퍼
// -----------------------------
enum class FreqFamily { Ideal, Gaussian };
enum class PassType  { LowPass, HighPass };

struct FreqFilterOptions {
    FreqFamily family     = FreqFamily::Gaussian;
    PassType   pass       = PassType::LowPass;
    double     cutoff     = 40.0;   // Ideal: 반경 D0, Gaussian: sigma(또는 사용자가 D0를 넣고 변환해도 됨)
    bool       useHann    = true;
    bool       centering  = true;
    bool       padPow2    = true;
};

inline bool ApplyFrequencyFilter(const IppDib& in, IppDib& out, const FreqFilterOptions& opt) {
    // 패딩 크기를 먼저 결정 (10.3절과 동일 규약)
    int W = in.width(), H = in.height();
    const int PW = opt.padPow2 ? (int)next_pow2((size_t)W) : W;
    const int PH = opt.padPow2 ? (int)next_pow2((size_t)H) : H;

    // 마스크 생성
    std::vector<double> M;
    if (opt.family == FreqFamily::Ideal) {
        if (opt.pass == PassType::LowPass) mask_ideal_lowpass(M, PW, PH, opt.cutoff);
        else                               mask_ideal_highpass(M, PW, PH, opt.cutoff);
    } else { // Gaussian
        if (opt.pass == PassType::LowPass) mask_gaussian_lowpass(M, PW, PH, opt.cutoff);
        else                               mask_gaussian_highpass(M, PW, PH, opt.cutoff);
    }

    // FFT → 마스크 곱 → IFFT (10.3절 제공)
    return FFT_Filter_And_IFFT(in, out, opt.useHann, opt.centering, opt.padPow2, M);
}
```

> 파라미터 가이드  
> - **Ideal** `cutoff=D0`(px). 너무 작으면 심한 블러, 너무 크면 차이 미미.  
> - **Gaussian** `cutoff=σ`(px). \(-3\,\mathrm{dB}\) 컷오프를 \(D_0\) 로 쓰고 싶다면 입력값을 \(\sigma=\tfrac{D_0}{\sqrt{2\ln 2}}\) 로 환산.

---

## 3) UI — **주파수 필터링 대화 상자**

필요 옵션:  
- **필터 계열**: Ideal / Gaussian  
- **통과 유형**: Low-pass / High-pass  
- **Cutoff**(px): Ideal은 반경 \(D_0\), Gaussian은 \(\sigma\)  
- **사전처리**: Hann, Centering, Pad to 2^n

### 3.1 리소스 ID

```cpp
// resource.h (추가)
#define IDD_FREQFILT_DLG              3300
#define IDC_RAD_FF_IDEAL              3301
#define IDC_RAD_FF_GAUSS              3302
#define IDC_RAD_FF_LP                 3303
#define IDC_RAD_FF_HP                 3304
#define IDC_EDIT_FF_CUTOFF            3305
#define IDC_CHK_FF_HANN               3306
#define IDC_CHK_FF_CENTER             3307
#define IDC_CHK_FF_PAD2               3308

// 메뉴
#define ID_MENU_FREQ_FILTER           72000
```

### 3.2 RC

```rc
// ImageTool.rc (추가)
IDD_FREQFILT_DLG DIALOGEX 0,0, 240, 148
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Frequency-Domain Filtering"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Family", -1, 10, 10, 108, 36
    AUTORADIOBUTTON "Ideal",    IDC_RAD_FF_IDEAL, 18, 22, 40, 10, WS_TABSTOP
    AUTORADIOBUTTON "Gaussian", IDC_RAD_FF_GAUSS, 62, 22, 52, 10

    GROUPBOX "Pass Type", -1, 126, 10, 104, 36
    AUTORADIOBUTTON "Low-pass",  IDC_RAD_FF_LP, 134, 22, 46, 10, WS_TABSTOP
    AUTORADIOBUTTON "High-pass", IDC_RAD_FF_HP, 184, 22, 50, 10

    LTEXT "Cutoff (px / σ):", -1, 14, 54, 76, 10
    EDITTEXT IDC_EDIT_FF_CUTOFF, 92, 52, 40, 14, ES_NUMBER

    AUTOCHECKBOX "Hann window",          IDC_CHK_FF_HANN,   14, 72, 84, 12
    AUTOCHECKBOX "Centering (-1)^(x+y)", IDC_CHK_FF_CENTER, 14, 86, 120, 12
    AUTOCHECKBOX "Pad to power-of-two",  IDC_CHK_FF_PAD2,   14, 100, 110, 12

    DEFPUSHBUTTON "OK", IDOK,  128, 116, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 178, 116, 44, 16
END

// 메뉴 (추가)
POPUP "&Frequency"
BEGIN
    MENUITEM "Frequency Filtering...\tCtrl+Shift+F", ID_MENU_FREQ_FILTER
END

IDR_ACCEL ACCELERATORS
BEGIN
    "F", ID_MENU_FREQ_FILTER, VIRTKEY, CONTROL, SHIFT
END
```

### 3.3 대화 상자 코드

```cpp
// FreqFilterDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "frequency_filters.hpp"

class FreqFilterDlg {
public:
    FreqFilterDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    int  ReadInt (HWND h, int id, int def) const;
    bool IsChecked(HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }

private:
    HWND owner_=nullptr;
    IppDib& dib_;
};
```

```cpp
// FreqFilterDlg.cpp
#include "FreqFilterDlg.h"

INT_PTR FreqFilterDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_FREQFILT_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK FreqFilterDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(FreqFilterDlg*)l; return self->OnInit(h); }
    auto* self=(FreqFilterDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w,l);
    return FALSE;
}
INT_PTR FreqFilterDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_FF_IDEAL, IDC_RAD_FF_GAUSS, IDC_RAD_FF_GAUSS);
    CheckRadioButton(h, IDC_RAD_FF_LP, IDC_RAD_FF_HP, IDC_RAD_FF_LP);
    SetDlgItemInt(h, IDC_EDIT_FF_CUTOFF, 40, FALSE);
    CheckDlgButton(h, IDC_CHK_FF_HANN,   BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_FF_CENTER, BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_FF_PAD2,   BST_CHECKED);
    return TRUE;
}
int FreqFilterDlg::ReadInt(HWND h, int id, int def) const{
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    return ok? v : def;
}
INT_PTR FreqFilterDlg::OnCommand(HWND h, WPARAM w, LPARAM){
    switch (LOWORD(w)){
    case IDOK: {
        FreqFilterOptions opt;
        opt.family = (IsDlgButtonChecked(h, IDC_RAD_FF_IDEAL)==BST_CHECKED)
                     ? FreqFamily::Ideal : FreqFamily::Gaussian;
        opt.pass   = (IsDlgButtonChecked(h, IDC_RAD_FF_LP)==BST_CHECKED)
                     ? PassType::LowPass : PassType::HighPass;
        opt.cutoff   = (double)ReadInt(h, IDC_EDIT_FF_CUTOFF, 40);
        opt.useHann  = IsChecked(h, IDC_CHK_FF_HANN);
        opt.centering= IsChecked(h, IDC_CHK_FF_CENTER);
        opt.padPow2  = IsChecked(h, IDC_CHK_FF_PAD2);

        IppDib out;
        if (ApplyFrequencyFilter(dib_, out, opt)) {
            dib_ = out; // 결과를 현재 문서로 교체 (원한다면 새 창으로도 가능)
        }
        EndDialog(h, IDOK);
        return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

### 3.4 메뉴/메시지 처리

```cpp
// main_multiwin.cpp (발췌)
#include "FreqFilterDlg.h"

// ...
case ID_MENU_FREQ_FILTER:
    if (st && st->dib){
        FreqFilterDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 4) 예제 & 상황

### 예제 A) **사진 부드럽게** (가우시안 저역)
- **상황**: 고주파 노이즈로 거칠어 보이는 야간 사진  
- **동작**: *Frequency → Frequency Filtering…*  
  - Family=Gaussian, Pass=Low-pass, σ(또는 Cutoff)=**30**  
  - Hann=ON, Center=ON, Pad2=ON  
- **결과**: 노이즈가 줄고 부드러워짐.  
- **노트**: 너무 큰 σ는 디테일을 잃게 함. σ를 20~50 범위에서 탐색.

### 예제 B) **엣지 강조** (가우시안 고역 + 합성)
- **상황**: 살짝 흐릿한 문서 스캔  
- **동작**: Gaussian High-pass(σ=5~10) → 결과를 원본과 **가중 합성**  
  \[
  g = f + \alpha \cdot \text{HP}(f),\quad \alpha\approx 0.3\sim 0.7
  \]
  (본 장 UI는 HP 결과만 내지만, 애플리케이션 레벨에서 간단히 합성 가능)  
- **결과**: 얇은 획과 문자 에지가 또렷.

### 예제 C) **줄무늬 제거** (Ideal Low-pass 대체)
- **상황**: 스캐너의 고주파 줄무늬(스트라이프)  
- **동작**: Ideal High-pass는 링잉이 크므로 **Notch**(10.3절) 권장.  
  단, 간단 테스트용으로 **Ideal Low-pass**(D0=40)도 효과를 비교.

### 예제 D) **모아레 억제**
- **상황**: 인쇄물 사진에 모아레(고주파 간섭 무늬)  
- **동작**: Gaussian Low-pass(σ=20~40) → IFFT 복원  
- **결과**: 모아레 감소, 전체가 다소 부드러워질 수 있음 → σ 미세 조정.

---

## 5) 구현/품질 팁

- **센터링 규약**: 입력에서 \((-1)^{x+y}\) 를 곱했으면, 마스크는 **중앙을 DC** 로 보고 설계해야 합니다.  
  `FFT_Filter_And_IFFT` 는 역FFT 후 공간에서 다시 \((-1)^{x+y}\) 를 곱해 원상복귀합니다.

- **Ideal vs Gaussian**:  
  - Ideal: 경계가 날카로워 공간 영역에서 **링잉** (overshoot/undershoot) 발생.  
  - Gaussian: 부드러운 롤오프, 링잉이 적음(권장).

- **패딩(Pad2)**: FFT 효율 향상 + **격자 촘촘화**로 마스크 테두리 배치가 더 자연스러움.

- **정규화**: 역FFT 후 0~255 매핑 시, 영상 대비가 달라질 수 있습니다(10.3절 코드에서 min/max 정규화).

- **성능**: 큰 영상은 행/열 FFT를 **멀티스레드**로 병렬화하면 선형에 가깝게 가속.  
  마스크 곱은 메모리 대역폭 지배 → 선형 순회로 구현(현재 코드 OK).

---

## 6) 수학 메모

- **필터 적용**:  
\[
G(u,v)=H(u,v)\,F(u,v),\quad g(x,y)=\mathcal{F}^{-1}\{G(u,v)\}.
\]

- **Ideal HPF** 의 공간 응답은 sinc 계열의 **고주파강조** 커널 → 강한 링잉.  
- **Gaussian LPF** 는 자기 자신의 푸리에 변환이 Gaussian → 부드러운 양상 유지.

---

## 7) 단위 테스트(스니펫)

```cpp
// test_freq_filters.cpp
#include <cassert>
#include "frequency_filters.hpp"

// 단위 크기/대칭성 간단 점검
int main(){
    int W=256, H=256; std::vector<double> M;

    mask_ideal_lowpass(M,W,H,40);
    // 중심값은 1, 충분히 먼 곳은 0
    assert(M[(H/2)*W + (W/2)] == 1.0);
    assert(M[0] == 0.0);

    mask_gaussian_lowpass(M,W,H,20.0);
    double c = M[(H/2)*W + (W/2)];
    assert(c > 0.999); // 중심에서 거의 1
    double far = M[0];
    assert(far < 1e-3); // 구석에서 거의 0

    // HPF는 1-LPF
    std::vector<double> Mhp;
    mask_ideal_highpass(Mhp,W,H,40);
    assert(Mhp[(H/2)*W + (W/2)] == 0.0);

    return 0;
}
```

---

## 8) 요약
- **Ideal/ Gaussian** 저·고역 통과 마스크를 **센터링된 좌표**로 생성.  
- 10.3절의 **FFT 파이프라인**에 마스크를 곱해 **역FFT 복원**.  
- UI(대화 상자/메뉴)로 쉽게 적용·비교 가능.  
- 고주파 억제(스무딩), 엣지강조, 모아레/줄무늬 억제 등 실전 문제에 즉시 활용!