---
layout: post
title: 논리회로설계 - 순서논리의 VHDL (1)
date: 2025-09-13 14:25:23 +0900
category: 논리회로설계
---
# 순서논리의 VHDL — **프로세스로 플립플롭 모델화**, **레지스터/카운터 모델화**, **조합논리 모델화 (Synthesizable)**

> 표기: 클럭 `clk`, 리셋 `rst`(동기 unless noted), `CE`=Clock Enable, \(\overline{X}\)=NOT, \(\oplus\)=XOR.  
> 라이브러리는 **반드시** `ieee.std_logic_1164`, 산술은 `ieee.numeric_std`(권장. `std_logic_arith` 지양).

---

## 0) 공통 전제 & 코딩 규칙

- **동기식** 설계: 상태 업데이트는 `if rising_edge(clk) then ... end if;` 안에서만.  
- **리셋**: 가능하면 **동기 리셋**. 비동기 입력은 **2단 동기화** 후 사용.  
- **조합 프로세스**는 반드시 `process(all)` 또는 **완전 감도 리스트** 사용 + **기본값**으로 래치 방지.  
- **형 변환**: 산술에는 `unsigned/signed` 사용, 포트는 `std_logic(_vector)` 유지, 내부에서 변환.

공용 패키지 스니펫(필요 시 복붙):
```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
```

---

## 1) VHDL **프로세스**를 이용한 플립플롭 모델화

### 1.1 D 플립플롭 (동기 리셋 + CE)

```vhdl
library ieee; use ieee.std_logic_1164.all;
entity dff_ce is
  port (clk: in std_logic; rst: in std_logic; ce: in std_logic;
        d  : in std_logic;  q : out std_logic);
end;
architecture rtl of dff_ce is
  signal r: std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        r <= '0';
      elsif ce='1' then
        r <= d;
      end if;
    end if;
  end process;
  q <= r;
end;
```

- **메모**: 게이티드 클럭 대신 **CE** 사용. 합성기들이 클럭 트리 최적화에 유리.

### 1.2 DFF (비동기 리셋/프리셋, FPGA/ASIC 공통)

```vhdl
entity dff_async is
  port (clk: in std_logic; arstn: in std_logic; -- active-low async reset
        d: in std_logic; q: out std_logic);
end;
architecture rtl of dff_async is
  signal r: std_logic := '0';
begin
  process(clk, arstn) begin
    if arstn='0' then
      r <= '0';
    elsif rising_edge(clk) then
      r <= d;
    end if;
  end process;
  q <= r;
end;
```

> **비동기 리셋 해제**는 메타안정 방지를 위해 **클럭 동기**(예: 2FF)로 처리하는 것이 안전.

### 1.3 T 플립플롭 (토글 FF)

\[
Q^+ = Q \oplus T \cdot CE
\]

```vhdl
entity tff is
  port (clk,rst,ce,t: in std_logic; q: out std_logic);
end;
architecture rtl of tff is
  signal r: std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r<='0';
      elsif ce='1' then r <= r xor t;
      end if;
    end if;
  end process;
  q <= r;
end;
```

### 1.4 JK 플립플롭 (교과서식, 동기)

\[
Q^+ = J\overline{Q} + \overline{K}Q
\]

```vhdl
entity jkff is
  port (clk,rst,ce,J,K: in std_logic; q: out std_logic);
end;
architecture rtl of jkff is
  signal r: std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r<='0';
      elsif ce='1' then
        r <= (J and (not r)) or ((not K) and r);
      end if;
    end if;
  end process;
  q <= r;
end;
```

### 1.5 SR 플립플롭(동기, 금지상태 방지)

```vhdl
entity srff is
  port (clk,rst,ce,S,R: in std_logic; q: out std_logic);
end;
architecture rtl of srff is
  signal r: std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r<='0';
      elsif ce='1' then
        case S&R is
          when "10" => r <= '1';
          when "01" => r <= '0';
          when "00" => r <= r;
          when others => r <= r; -- "11" 금지: 유지(혹은 어서션)
        end case;
      end if;
    end if;
  end process;
  q <= r;
end;
```

### 1.6 에지 검출기 (동기, 2FF 동기화 포함)

```vhdl
entity edge_det is
  port (clk,rst: in std_logic; a_async: in std_logic;
        rise_pulse, fall_pulse: out std_logic);
end;
architecture rtl of edge_det is
  signal a_d1,a_d2: std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then a_d1<='0'; a_d2<='0';
      else            a_d1<=a_async; a_d2<=a_d1;
      end if;
    end if;
  end process;
  rise_pulse <= (not a_d2) and a_d1;
  fall_pulse <= a_d2 and (not a_d1);
end;
```

### 1.7 2단 동기화기(메타안정 완화)

```vhdl
entity sync2 is
  port (clk,rst: in std_logic; din_async: in std_logic; dout_sync: out std_logic);
end;
architecture rtl of sync2 is
  signal d1,d2: std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then d1<='0'; d2<='0';
      else            d1<=din_async; d2<=d1;
      end if;
    end if;
  end process;
  dout_sync <= d2;
end;
```

---

## 2) **레지스터**와 **카운터** 모델화

### 2.1 범용 N비트 레지스터 (Load/CE/Reset)

```vhdl
entity reg_n is
  generic (N: positive := 8);
  port (clk,rst,ce,ld: in std_logic;
        d: in std_logic_vector(N-1 downto 0);
        q: out std_logic_vector(N-1 downto 0));
end;
architecture rtl of reg_n is
  signal r: std_logic_vector(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0');
      elsif ce='1' then
        if ld='1' then r <= d; end if;
      end if;
    end if;
  end process;
  q <= r;
end;
```

### 2.2 시프트 레지스터 (SIPO, PISO, 양방향)

- **SIPO**(Serial-In Parallel-Out, 우시프트):

```vhdl
entity sipo is
  generic (N: positive := 8);
  port (clk,rst,ce: in std_logic; si: in std_logic; q: out std_logic_vector(N-1 downto 0));
end;
architecture rtl of sipo is
  signal r: std_logic_vector(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0');
      elsif ce='1' then r <= r(N-2 downto 0) & si;
      end if;
    end if;
  end process;
  q <= r;
end;
```

- **PISO**(Parallel-In Serial-Out):

```vhdl
entity piso is
  generic (N: positive := 8);
  port (clk,rst,load,ce: in std_logic;
        din: in std_logic_vector(N-1 downto 0);
        so: out std_logic);
end;
architecture rtl of piso is
  signal r: std_logic_vector(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0');
      elsif load='1' then r <= din;
      elsif ce='1' then r <= '0' & r(N-1 downto 1); -- 좌시프트
      end if;
    end if;
  end process;
  so <= r(0);
end;
```

- **양방향 시프트 + 회전/삽입 옵션**: `dir`, `rot`, `fill` 제어 추가 가능.

### 2.3 이진 업 카운터 (unsigned)

```vhdl
entity cnt_up is
  generic (N: positive := 16);
  port (clk,rst,ce: in std_logic; q: out std_logic_vector(N-1 downto 0));
end;
architecture rtl of cnt_up is
  signal r: unsigned(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0');
      elsif ce='1' then r <= r + 1;
      end if;
    end if;
  end process;
  q <= std_logic_vector(r);
end;
```

### 2.4 업/다운 카운터 + 터미널 카운트(TC)

```vhdl
entity cnt_ud_tc is
  generic (N: positive := 8);
  port (clk,rst,ce,up: in std_logic;
       q: out std_logic_vector(N-1 downto 0); tc: out std_logic);
end;
architecture rtl of cnt_ud_tc is
  signal r: unsigned(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0');
      elsif ce='1' then
        if up='1' then r <= r + 1; else r <= r - 1; end if;
      end if;
    end if;
  end process;
  q  <= std_logic_vector(r);
  tc <= '1' when (up='1' and r=to_unsigned(2**N-1,N)) or
                 (up='0' and r=to_unsigned(0,N)) else '0';
end;
```

### 2.5 Mod–N 카운터 (임의 N, 자연수)

```vhdl
entity cnt_mod is
  generic (N: natural := 10); -- 0..N-1
  port (clk,rst,ce: in std_logic; q: out natural range 0 to N-1);
end;
architecture rtl of cnt_mod is
  signal r: natural range 0 to N-1 := 0;
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= 0;
      elsif ce='1' then
        if r=N-1 then r<=0; else r<=r+1; end if;
      end if;
    end if;
  end process;
  q <= r;
end;
```

> 자연수 타입은 일부 합성기 제한 존재. 문제가 있으면 `unsigned` 기반으로 작성 후 비교.

### 2.6 그레이 카운터 (해밍거리 1)

\[
G = B \oplus (B \gg 1)
\]

```vhdl
entity cnt_gray is
  generic (N: positive := 4);
  port (clk,rst,ce: in std_logic; g: out std_logic_vector(N-1 downto 0));
end;
architecture rtl of cnt_gray is
  signal b: unsigned(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then b <= (others=>'0');
      elsif ce='1' then b <= b + 1;
      end if;
    end if;
  end process;
  g <= std_logic_vector( b xor (b srl 1) );
end;
```

### 2.7 BCD(10진) 카운터 + 캐리

```vhdl
entity cnt_bcd is
  port (clk,rst,ce: in std_logic;
        bcd: out std_logic_vector(3 downto 0); carry: out std_logic);
end;
architecture rtl of cnt_bcd is
  signal d: unsigned(3 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then d <= (others=>'0'); carry<='0';
      elsif ce='1' then
        if d=9 then d<= (others=>'0'); carry<='1';
        else d<= d+1; carry<='0';
        end if;
      end if;
    end if;
  end process;
  bcd <= std_logic_vector(d);
end;
```

### 2.8 링/존슨 카운터 & LFSR

- **링 카운터(원-핫 순환)**

```vhdl
entity ring_cnt is
  generic (N: positive := 4);
  port (clk,rst,ce: in std_logic; q: out std_logic_vector(N-1 downto 0));
end;
architecture rtl of ring_cnt is
  signal r: std_logic_vector(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0'); r(0)<='1';
      elsif ce='1' then r <= r(N-2 downto 0) & r(N-1);
      end if;
    end if;
  end process;
  q <= r;
end;
```

- **존슨(Twisted Ring)**

```vhdl
-- 마지막 비트의 보수를 밀어 넣음
r <= r(N-2 downto 0) & (not r(N-1));
```

- **LFSR(Galois, 최대길이 예: 8비트 taps x^8+x^6+x^5+x^4+1)**

```vhdl
entity lfsr8 is
  port (clk,rst,ce: in std_logic; q: out std_logic_vector(7 downto 0));
end;
architecture rtl of lfsr8 is
  signal r: std_logic_vector(7 downto 0) := x"01"; -- seed!=0
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= x"01";
      elsif ce='1' then
        r(0) <= r(7);
        r(1) <= r(0) xor r(7);  -- tap6
        r(2) <= r(1) xor r(7);  -- tap5
        r(3) <= r(2) xor r(7);  -- tap4
        r(4) <= r(3);
        r(5) <= r(4);
        r(6) <= r(5);
        r(7) <= r(6);
      end if;
    end if;
  end process;
  q <= r;
end;
```

---

## 3) **조합논리** 모델화 (프로세스/동시문)

### 3.1 코딩 패턴(추천)

- **동시문**: 간단식/디코더/멀티플렉서
  ```vhdl
  y <= (a and b) or (c and d);
  with sel select
    y <= a when "00",
         b when "01",
         c when "10",
         d when others;
  ```
- **조합 프로세스**: `process(all)` + **기본값**으로 래치 방지
  ```vhdl
  process(all) is
  begin
    next_y <= (others=>'0'); -- 기본값
    if en='1' then
      if a>b then next_y <= a; else next_y <= b; end if;
    end if;
  end process;
  ```

### 3.2 우선순위 인코더 (8→3, valid 포함, **if-elsif**로 priority)

```vhdl
entity prio_enc8 is
  port (d: in std_logic_vector(7 downto 0);
        y: out std_logic_vector(2 downto 0); v: out std_logic);
end;
architecture rtl of prio_enc8 is
begin
  process(all) begin
    y <= "000"; v<='0';
    if    d(7)='1' then y<="111"; v<='1';
    elsif d(6)='1' then y<="110"; v<='1';
    elsif d(5)='1' then y<="101"; v<='1';
    elsif d(4)='1' then y<="100"; v<='1';
    elsif d(3)='1' then y<="011"; v<='1';
    elsif d(2)='1' then y<="010"; v<='1';
    elsif d(1)='1' then y<="001"; v<='1';
    elsif d(0)='1' then y<="000"; v<='1';
    end if;
  end process;
end;
```

### 3.3 평행(case) 디코더 (3→8, **완전 커버**)

```vhdl
entity dec3to8 is
  port (a: in std_logic_vector(2 downto 0);
        y: out std_logic_vector(7 downto 0));
end;
architecture rtl of dec3to8 is
begin
  process(all) begin
    y <= (others=>'0');
    case a is
      when "000" => y(0)<='1';
      when "001" => y(1)<='1';
      when "010" => y(2)<='1';
      when "011" => y(3)<='1';
      when "100" => y(4)<='1';
      when "101" => y(5)<='1';
      when "106" | "111" => y(6)<= '1'; -- 오타 예시 방지: 실제론 "110","111"
      when others => null;
    end case;
  end process;
end;
```
> **주의**: 위처럼 **오타**가 합성 전 탐지되도록 Lint 사용. (위 라인은 예시이므로 실제 코딩 시 정확히 표기하세요.)

### 3.4 멀티플렉서 (when-else)

```vhdl
y <= d0 when sel="00" else
     d1 when sel="01" else
     d2 when sel="10" else
     d3;
```

### 3.5 ALU 예제 (열거형 연산 코드 + 플래그)

```vhdl
entity alu is
  generic (N: positive := 8);
  port (a,b: in  std_logic_vector(N-1 downto 0);
        op : in  std_logic_vector(2 downto 0); -- 000:add,001:sub,010:and,011:or,100:xor,101:sll1,110:srl1,111:cmp
        y  : out std_logic_vector(N-1 downto 0);
        zf,nf,cf,vf: out std_logic);
end;
architecture rtl of alu is
  signal au, bu, yu: unsigned(N-1 downto 0);
  signal tmp: unsigned(N downto 0);
begin
  au <= unsigned(a); bu <= unsigned(b);
  process(all) begin
    yu <= (others=>'0'); cf<='0'; vf<='0';
    case op is
      when "000" => tmp <= ('0' & au) + ('0' & bu); yu <= tmp(N-1 downto 0); cf <= tmp(N); vf <= (au(N-1) xor bu(N-1)) xor (au(N-1) xor yu(N-1)); -- 부호 오버플로우(부호수면 signed로 별도)
      when "001" => tmp <= ('0' & au) - ('0' & bu); yu <= tmp(N-1 downto 0); cf <= tmp(N); vf <= (au(N-1) xor bu(N-1)) xor (au(N-1) xor yu(N-1));
      when "010" => yu <= au and bu;
      when "011" => yu <= au or  bu;
      when "100" => yu <= au xor bu;
      when "101" => yu <= au sll 1; cf <= a(N-1);
      when "110" => yu <= au srl 1; cf <= a(0);
      when others=> -- compare: y=0, zf=1 if a==b, nf=(a<b)
        yu <= (others=>'0');
        zf <= '1' when au=bu else '0';
        nf <= '1' when au<bu else '0';
    end case;
    y  <= std_logic_vector(yu);
    zf <= '1' when yu=(others=>'0') else '0';
    nf <= yu(N-1);
  end;
end;
```

> **참고**: 부호 연산은 `signed` 캐스팅 후 오버플로우/부호비트 기준으로 별도 계산.

### 3.6 FSM의 조합 블록(전형 패턴: 2-프로세스)

```vhdl
-- 1) 조합: ns,y 계산
process(all) begin
  ns <= s; y <= '0';
  case s is
    when IDLE =>
      if start='1' then ns<=LOAD; end if;
    when LOAD =>
      ns <= RUN;
    when RUN  =>
      if done='1' then ns<=DONE; end if;
    when DONE =>
      y <= '1'; ns<=IDLE;
  end case;
end
-- 2) 순차: 상태 레지스터
process(clk) begin
  if rising_edge(clk) then
    if rst='1' then s<=IDLE; else s<=ns; end if;
  end if;
end
```

> **Mealy 출력**은 글리치 방지를 위해 `y`를 **등록**(레지스터)하는 3-프로세스 패턴도 흔함.

---

## 4) 테스트벤치(TB) 스니펫 (간단 검증)

### 4.1 DFF/카운터 검증 TB

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity tb is end;
architecture sim of tb is
  signal clk: std_logic:='0'; signal rst: std_logic:='1';
  signal ce: std_logic:='0'; signal q: std_logic_vector(7 downto 0);
begin
  clk <= not clk after 5 ns; -- 100MHz
  process begin wait for 40 ns; rst<='0'; ce<='1'; wait; end process;

  uut: entity work.cnt_up
    generic map (N=>8)
    port map (clk=>clk, rst=>rst, ce=>ce, q=>q);

  -- 간단 체크
  process begin
    wait until rst='0';
    wait for 10*10 ns; -- 10클럭
    assert q = std_logic_vector(to_unsigned(10,8))
      report "Count mismatch" severity error;
    wait;
  end process;
end;
```

---

## 5) 합성 가능/불가 **퀵가이드**

- **가능**: `if/case`, `+ - *`(합성기 지원 범위), 시프트(`sll/srl`), 비교, with-select/when-else, generate, 배열 인덱스(정적/합성가능).  
- **주의**: 가변 길이 루프, 동적 인덱스의 과도한 사용(리소스 폭증).  
- **불가/지양**: `wait`(TB 제외), `after` 지연, 파일 I/O, 텍스트IO(일부 합성 불가), 공유변수(특별용도 제외).

---

## 6) 실무 팁 & 체크리스트

- [ ] **numeric_std**만 사용(타 패키지 혼용 금지).  
- [ ] 모든 비동기 입력은 **2FF 동기화**.  
- [ ] 조합 프로세스에 **기본값** 제공 → 래치 추론 방지.  
- [ ] 상태코드는 합성기 속성(`enum_encoding`)으로 **명시 가능**.  
- [ ] 타이밍: \(t_{CQ}+t_{comb}+t_{SU}\le T_{clk}\). 경로 길면 **파이프라인**.  
- [ ] **Clock Enable** 적극 활용(게이티드 클럭 금지).  
- [ ] Mealy 출력은 **등록**(글리치/CDC 안전).  
- [ ] Lint/STA 리포트 확인: 래치, 혼합 클럭, CDC 경고 해결.

---

### 마무리 요약

- **프로세스 기반 플립플롭**: D/T/JK/SR 모두 `rising_edge(clk)` 내부에서 모델링, 리셋/CE 옵션화.  
- **레지스터/카운터**: 범용 N비트, 시프트(PISO/SIPO), 업/다운, Mod–N, 그레이, BCD, 링/존슨, LFSR까지 **패턴화**.  
- **조합논리**: `with-select/when-else/case`를 용도에 맞게 사용, **기본값/완전커버**로 래치 방지.  
- **테스트벤치**: 클럭/리셋 구동, 간단 어서션으로 기능 확인.  
- **안전/타이밍**: 동기 설계 원칙, CE, 파이프라인, numeric_std로 **깔끔하고 합성친화적** 코드를 유지.
