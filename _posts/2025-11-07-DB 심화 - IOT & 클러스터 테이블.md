---
layout: post
title: DB 심화 - IOT & 클러스터 테이블
date: 2025-11-07 19:25:23 +0900
category: DB 심화
---
# IOT & 클러스터 테이블 활용 완전정리

> 목표: 힙(Heap) 테이블 대비 **랜덤 I/O를 최소화**하고 **PK 기반 조회/조인**을 빠르게 만드는 **IOT/클러스터**의 물리 구조와 설계·운영 노하우를 예제와 함께 정리합니다.

---

## 0. 배경: Heap vs IOT vs Cluster — “블록에 ‘어떻게’ 저장할 것인가?”

- **Heap 테이블**: **삽입 순서** 중심으로 블록에 행을 저장.  
  - 장점: 범용·유연, DML 적응력 높음.  
  - 단점: PK 조회는 `PK(인덱스) → ROWID로 테이블 랜덤 점프` 필요 → **랜덤 I/O** 누적.

- **IOT (Index-Organized Table)**: **PK 정렬 순서의 B-tree**가 **곧 테이블**.  
  - PK로 찾을 때 **인덱스만 읽고 끝** (대부분 **TABLE BY ROWID 없음**).  
  - 장점: PK lookup/범위 스캔/Top-N/Key-set 페이징에 **강력**. 저장공간 절약(중복 PK인덱스 불필요).  
  - 단점: **두껍고 자주 바뀌는 행**(UPDATE로 길이 변동) → **행 이동/분할** 부담. **Secondary Index**는 **논리 ROWID**(PK) 저장 → 유지비 증가.

- **Cluster 테이블(인덱스/해시)**: **클러스터 키**가 같은 **여러 테이블 행**을 **같은 블록 인근**에 배치.  
  - 장점: **동일 키 조인**이나 **동일 키의 다중 행 조회** 시 **랜덤 I/O 대폭 절감**.  
  - 단점: 설계 난도/사이징, DML 동시성/공간 파편 관리 필요.

---

# 1. IOT란?

### 1.1 정의 & 물리 구조
- `ORGANIZATION INDEX`로 생성되는 **B-tree**이며, **Leaf 블록에 행 데이터가 함께 저장**됨.  
- 별도의 힙 세그먼트가 없고, **PK 인덱스 = 테이블 본체**.  
- **Secondary Index**는 **물리 ROWID** 대신 **논리 ROWID(=IOT의 PK 값)**를 가리킴.

### 1.2 “왜 빠른가?”
- PK 탐색: `Root → Branch → Leaf`에서 **행을 곧바로 획득** → **테이블 BY ROWID 단계 없음**.  
- PK 범위 스캔/정렬 일치: **Stopkey**로 앞부분 블록 **몇 개만** 읽고 종료.  
- **PK 인덱스 별도 보유 불필요** → 공간 절약, 캐시 효율↑.

---

# 2. IOT: 언제 사용할 것인가?

### 2.1 적합한 워크로드
1) **PK 기반 조회/RANGE가 대부분**  
   - 예: 계정별 타임라인, 시계열 PK, IoT(사물) 시계열, PK 조인 키 위주 시스템.
2) **행이 얇고(=컬럼 수·길이 작고)** **수정보단 읽기 위주**  
   - UPDATE로 크기 변동이 적을수록 유리.
3) **정렬/Top-N/Key-set 페이징**을 **PK로** 수행  
   - ORDER BY가 PK 또는 PK prefix와 일치.

### 2.2 비권장/주의
- **행이 두껍고 자주 UPDATE**(길이 변경) → Leaf 분할/행 이동 비용↑.  
- **비PK 조건이 주 조회 경로** → Secondary Index 경유 + 논리 ROWID 변환 비용.  
- **폭넓은 Full Scan** 위주 DW성 집계 → IOT가 꼭 유리하진 않음(히트패턴/압축/스토리지 따라 다름).

---

# 3. IOT 실전: 생성/조회/계획 관찰

## 3.1 기본 IOT 생성
```sql
DROP TABLE iot_demo PURGE;

CREATE TABLE iot_demo (
  cust_id     NUMBER       NOT NULL,
  order_dt    DATE         NOT NULL,
  order_id    NUMBER       NOT NULL,
  amount      NUMBER(12,2) NOT NULL,
  status      VARCHAR2(8)  NOT NULL,
  note        VARCHAR2(200),
  CONSTRAINT pk_iot_demo PRIMARY KEY (cust_id, order_dt, order_id)
) ORGANIZATION INDEX
  TABLESPACE users
  PCTFREE 10
  INITRANS 2;
```
- **PK가 곧 저장 키**(정렬). 힙 테이블 없음.  
- (Heap이라면 PK 인덱스를 또 만들었겠지만) IOT는 **그 자체가 PK 인덱스**.

## 3.2 데이터 & 통계
```sql
BEGIN
  FOR c IN 1..10000 LOOP
    FOR d IN 0..9 LOOP
      INSERT INTO iot_demo
      SELECT c, DATE '2024-01-01'+d, level, ROUND(DBMS_RANDOM.VALUE(1,9999),2),
             CASE MOD(level,5) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID'
                               WHEN 2 THEN 'SHIP' WHEN 3 THEN 'DONE' ELSE 'CANC' END,
             CASE WHEN MOD(level,97)=0 THEN 'gift' END
      FROM dual CONNECT BY level <= 20;
    END LOOP;
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'IOT_DEMO', method_opt=>'for all columns size skewonly');
END;
/
```

## 3.3 PK 기반 조회: “테이블 랜덤 점프 없음”
```sql
ALTER SESSION SET statistics_level=ALL;

SELECT /* PK RANGE + Stopkey */
       order_id, amount, status
FROM   iot_demo
WHERE  cust_id = :cid
AND    order_dt BETWEEN :from_dt AND :to_dt
ORDER  BY order_dt, order_id
FETCH FIRST 50 ROWS ONLY;

-- 계획(예상 핵심): INDEX RANGE SCAN (IOT) + Stopkey
-- 일반 Heap과 달리 TABLE ACCESS BY INDEX ROWID 단계가 나타나지 않거나 최소/없음
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS'));
```

> **체감 포인트**: 같은 질의를 Heap에서 수행하면 `PK 인덱스 → ROWID`로 **힙 랜덤 I/O**가 발생.  
> IOT에선 **인덱스만**으로 충분하여 **db file sequential read**가 확 줄거나 사라집니다.

---

# 4. Secondary Index on IOT: 논리 ROWID(=PK) 저장

IOT에 보조 인덱스를 만들면, 해당 인덱스는 **물리 ROWID** 대신 **논리 ROWID(PK)**를 저장합니다.  
즉, 보조 인덱스로 찾은 뒤 **PK 탐색을 한 번 더** 거쳐 행을 가져옵니다.

```sql
-- status에 보조 인덱스
CREATE INDEX iot_demo_status_ix ON iot_demo(status);

-- status로 조회
SELECT /* via secondary index */
       cust_id, order_dt, order_id, amount
FROM   iot_demo
WHERE  status = 'PAID'
AND    cust_id = :cid
ORDER  BY order_dt, order_id
FETCH FIRST 10 ROWS ONLY;

-- 계획 관찰: SECONDARY INDEX RANGE SCAN → KEY(=PK) 탐색 재방문
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

> **메시지**  
> - Secondary Index 경유 시 **추가 탐색(논리 ROWID→PK lookup)** 비용이 듭니다.  
> - 비PK 중심 질의가 많다면 **Heap+BTREE**가 더 단순/유리할 수 있습니다.  
> - 혹은 **보조 인덱스 커버링**(SELECT-LIST 포함)으로 PK 재탐색을 줄이기도 합니다(공간·쓰기 비용↑).

---

# 5. IOT의 OVERFLOW: 두꺼운 행을 위한 탈출구

### 5.1 개념
- Leaf 블록에 **행 전체**를 담기 어려울 때 **일부만**(키와 앞부분) 저장하고 **나머지를 OVERFLOW 세그먼트**에 둠.  
- **PCTTHRESHOLD**로 Leaf에 남길 **최대 바이트 비율**을 설정, `INCLUDING column`으로 **자르기 기준** 지정.

### 5.2 예제: OVERFLOW 설계
```sql
DROP TABLE iot_over PURGE;

CREATE TABLE iot_over (
  k1 NUMBER NOT NULL,
  k2 DATE   NOT NULL,
  payload CLOB,          -- 길고 자주 변하는 컬럼
  s1  VARCHAR2(50),
  s2  VARCHAR2(100),
  CONSTRAINT pk_iot_over PRIMARY KEY (k1, k2)
)
ORGANIZATION INDEX
PCTTHRESHOLD 20                 -- Leaf에 최대 20%까지만 보관(대략적 기준)
INCLUDING s1                    -- s1까지는 Leaf에, 이후(=s2, payload)는 OVERFLOW로
OVERFLOW TABLESPACE users;      -- OVERFLOW 세그먼트 지정
```

**설명 포인트**
- `INCLUDING s1`: 키 + `s1`까지 **Leaf에 상주**. `s2`, `payload`는 OVERFLOW로.  
- **장점**: Leaf가 너무 커지지 않아 **B-tree 균형/캐시 효율** 유지.  
- **단점**: OVERFLOW 접근 시 **추가 I/O**(Leaf → Overflow) 필요. UPDATE로 **길이 변동**이 잦으면 여전히 비용↑.

### 5.3 튜닝 가이드
- **자주 조회하는 컬럼**은 `INCLUDING`으로 Leaf에 남겨 **PK 범위 스캔만으로 응답**.  
- **큰 LOB/Text**는 **OVERFLOW**로 분리하여 B-tree 비대화 방지.  
- **PCTTHRESHOLD**는 **실측**으로 조정(캐시 히트/Leaf 분할/Overflow 접근 비율을 균형화).

---

# 6. Partitioned IOT: 파티셔닝과의 궁합

### 6.1 언제 고려?
- 데이터가 **시간/범위로 거대**하고 **파티션 단위로 관리**(로드/아카이브)해야 할 때.  
- **로컬 보조 인덱스**로 파티션 별 관리/리빌드가 쉬워짐.  
- RAC/서비스 로컬리티와 함께 파티션별 **워크로드 분산** 가능.

### 6.2 주의점
- IOT는 **PK 정렬**이 본체이므로 **파티션 키는 PK prefix에 포함**되어야 자연스러움.  
- 파티션 간 **키 범위가 겹치지 않게** 설계(예: `cust_id` + `order_dt RANGE`).

### 6.3 예제: Range Partitioned IOT
```sql
DROP TABLE iot_part PURGE;

CREATE TABLE iot_part (
  cust_id   NUMBER NOT NULL,
  order_dt  DATE   NOT NULL,
  order_id  NUMBER NOT NULL,
  amount    NUMBER(12,2),
  status    VARCHAR2(8),
  CONSTRAINT pk_iot_part PRIMARY KEY (cust_id, order_dt, order_id)
)
ORGANIZATION INDEX
PARTITION BY RANGE (order_dt)
(
  PARTITION p2024q1 VALUES LESS THAN (DATE '2024-04-01'),
  PARTITION p2024q2 VALUES LESS THAN (DATE '2024-07-01'),
  PARTITION p2024q3 VALUES LESS THAN (DATE '2024-10-01'),
  PARTITION pmax   VALUES LESS THAN (MAXVALUE)
);

-- (옵션) 로컬 보조 인덱스
CREATE INDEX iot_part_status_ix ON iot_part(status) LOCAL;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'IOT_PART', cascade=>TRUE);
END;
/
```

**효과**
- `WHERE order_dt BETWEEN :a AND :b` → **Partition Pruning**으로 범위 좁힘.  
- 보조 인덱스 LOCAL → 파티션 단위 Rebuild, Exchange, Drop이 간단.

### 6.4 Partitioned IOT + OVERFLOW
```sql
DROP TABLE iot_part_over PURGE;

CREATE TABLE iot_part_over (
  k1  NUMBER NOT NULL,
  dt  DATE   NOT NULL,
  id  NUMBER NOT NULL,
  txt CLOB,
  s   VARCHAR2(100),
  CONSTRAINT pk_iot_part_over PRIMARY KEY (k1, dt, id)
)
ORGANIZATION INDEX
PCTTHRESHOLD 25 INCLUDING s
OVERFLOW
PARTITION BY RANGE (dt)
(
  PARTITION p2024h1 VALUES LESS THAN (DATE '2024-07-01'),
  PARTITION pmax    VALUES LESS THAN (MAXVALUE)
);
```

- 각 파티션마다 **본체(IOT)**와 **OVERFLOW** 세그먼트가 관리.  
- 파티션 제거/아카이브가 **연쇄적으로 간편**.

---

# 7. IOT 운영상 체크리스트

- [ ] **PK 설계**: 조회/정렬 패턴과 **정렬키 일치**(prefix 범위 스캔/Top-N).  
- [ ] **행 폭/변동성**: UPDATE로 길이 변하면 **리밸런스 비용**; 필요 시 **OVERFLOW**.  
- [ ] **보조 인덱스 남용 금지**: 논리 ROWID 재탐색 비용; 대신 **커버링 보조 인덱스**로 왕복 감소(Trade-off).  
- [ ] **파티셔닝**: 범위/로컬 인덱스로 관리성/Pruning/분산 향상.  
- [ ] **통계/계획 검증**: `ALLSTATS LAST`로 **TABLE BY ROWID 부재**·Buffers·Reads 확인.  
- [ ] **재구성 전략**: 대용량 업데이트 후 **MOVE**/CTAS로 재정렬 고려(다운타임/온라인 옵션 검토).

---

# 8. 클러스터 테이블: 인덱스/해시

## 8.1 개념 요약
- **인덱스 클러스터(Index Cluster)**  
  - **클러스터 키**에 대해 **클러스터 인덱스**를 만들고, 그 키를 공유하는 **여러 테이블의 행을 같은 블록**에 저장.  
  - **동일 키 조인**(예: 고객+주문, 게시판 글+댓글)에 **랜덤 I/O 극소화**.  
- **해시 클러스터(Hash Cluster)**  
  - **해시 함수**로 키→블록 위치 직접 계산(**인덱스 불필요**).  
  - **정확한 키=값 조회**가 매우 빠름. 범위/정렬에는 부적합. **HASHKEYS/SIZE** 튜닝 필요.

## 8.2 인덱스 클러스터 예제: 고객+주문
```sql
-- 1) 클러스터 정의(클러스터 키: cust_id)
DROP CLUSTER c_cust PURGE;
CREATE CLUSTER c_cust (cust_id NUMBER)
SIZE 8192
TABLESPACE users;

-- 2) 클러스터 인덱스 (cust_id)
CREATE INDEX c_cust_idx ON CLUSTER c_cust;

-- 3) 클러스터에 테이블 생성
DROP TABLE c_customers PURGE;
DROP TABLE c_orders PURGE;

CREATE TABLE c_customers (
  cust_id   NUMBER PRIMARY KEY,
  name      VARCHAR2(50),
  grade     VARCHAR2(10)
) CLUSTER c_cust(cust_id);

CREATE TABLE c_orders (
  cust_id   NUMBER NOT NULL,
  order_id  NUMBER PRIMARY KEY,
  order_dt  DATE   NOT NULL,
  amount    NUMBER(12,2),
  status    VARCHAR2(8),
  CONSTRAINT fk_c_orders_cust FOREIGN KEY (cust_id) REFERENCES c_customers(cust_id)
) CLUSTER c_cust(cust_id);

-- 4) 데이터/통계
BEGIN
  FOR c IN 1..10000 LOOP
    INSERT INTO c_customers VALUES (c, 'name'||c, CASE MOD(c,5) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER' WHEN 3 THEN 'BRONZE' ELSE 'BASIC' END);
    FOR k IN 1..5 LOOP
      INSERT INTO c_orders VALUES (c, c*100+k, SYSDATE - MOD(k,30), ROUND(DBMS_RANDOM.VALUE(10,9999),2), 'PAID');
    END LOOP;
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'C_CUSTOMERS', cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER,'C_ORDERS',    cascade=>TRUE);
END;
/

-- 5) 동일 cust_id 조인: 같은 블록에 모여 랜덤 I/O ↓
ALTER SESSION SET statistics_level=ALL;

SELECT /* CLUSTER EQ JOIN */
       c.cust_id, c.name, o.order_id, o.amount
FROM   c_customers c
JOIN   c_orders    o
ON     o.cust_id = c.cust_id
WHERE  c.cust_id = :cid;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

**효과 포인트**  
- 같은 `cust_id`의 **두 테이블 행이 근접** → **조인 시 블록 재사용↑, 랜덤 I/O↓**.  
- 반복 EQ lookup/조인이 많은 **OLTP형 키-그룹 데이터**에 매우 유리.

**주의**  
- **클러스터 크기(SIZE)**가 작거나 데이터 분포가 변하면 **블록 오버플로**/파편화.  
- 설계 초기에 **키당 평균 행수/행 길이**를 근거로 사이징. 변동 크면 재구성이 필요.

## 8.3 해시 클러스터 예제: 빠른 Equals Lookup
```sql
-- 1) 해시 클러스터(고정 해시 버킷 수)
DROP CLUSTER hc_user PURGE;
CREATE CLUSTER hc_user (user_id NUMBER)
  SIZE 8192
  HASHKEYS 500000;  -- 예상 키 개수 근사치
-- (해시 클러스터는 별도 인덱스 생략 가능: 해시로 바로 블록 찾기)

-- 2) 클러스터 테이블
DROP TABLE hc_profile PURGE;
CREATE TABLE hc_profile (
  user_id NUMBER PRIMARY KEY,
  name    VARCHAR2(50),
  email   VARCHAR2(100),
  tier    VARCHAR2(10)
) CLUSTER hc_user(user_id);

-- 3) 데이터/통계
BEGIN
  FOR u IN 1..300000 LOOP
    INSERT INTO hc_profile VALUES (u, 'u'||u, 'u'||u||'@mail.com', 'BASIC');
  END LOOP;
  COMMIT;
END;
/
BEGIN DBMS_STATS.GATHER_TABLE_STATS(USER,'HC_PROFILE',cascade=>TRUE); END;
/

-- 4) Equals Lookup (범위/정렬 아님!)
ALTER SESSION SET statistics_level=ALL;

SELECT /* HASH CLUSTER POINT LOOKUP */
       name, email, tier
FROM   hc_profile
WHERE  user_id = :uid;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

**효과 포인트**  
- **키=값** 조회는 해시로 **즉시 블록 접근** → **매우 빠름**.  
- 반면 **범위 조건/정렬**에는 부적합. **HASHKEYS/SIZE** 오류 시 **충돌**·오버플로 증가.

---

# 9. IOT vs Cluster: 선택 가이드

| 시나리오 | 권장 구조 | 이유 |
|---|---|---|
| **PK 기반 단건/범위 조회**가 압도적 | **IOT** | PK가 저장키 → 인덱스만으로 처리, Stopkey/Key-set 최강 |
| **동일 키 조인**(2+ 테이블) 반복 | **인덱스 클러스터** | 같은 키의 다테이블 레코드가 **같은 블록**에 모임 |
| **정확한 키=값 단건 조회**가 매우 잦음 | **해시 클러스터** | 인덱스 없이 해시로 블록 직행(포인트 조회 최강) |
| **비PK 조건 다양**·보조 인덱스 위주 | **Heap(+BTREE)** | IOT 보조 인덱스는 논리 ROWID 재탐색 비용 |
| **넓고 자주 바뀌는 행** | **Heap / IOT+OVERFLOW** | IOT는 길이 변동에 민감, 필요 시 OVERFLOW로 분리 |
| **시간 파티션 관리** | **Partitioned IOT/Heap/Cluster** | 파티션 Pruning/관리성 기준으로 선택 |

---

# 10. 운영 튜닝/유지보수 팁

- **IOT**
  - **PCTTHRESHOLD/INCLUDING**으로 Leaf 크기 제어 → 자주 쓰는 컬럼은 **Leaf**, 큰/가끔 쓰는 컬럼은 **OVERFLOW**.  
  - **보조 인덱스 수 최소화**: 논리 ROWID 재탐색 비용·유지비. 꼭 필요하면 **커버링 보조 인덱스**로 왕복 줄이기.  
  - **파티셔닝**: 범위/로컬 인덱스로 관리성·Pruning/서비스 분산 향상.  
  - **대량 UPDATE/DELETE 후**: **MOVE/CTAS**로 재정렬 검토.

- **Cluster**
  - **키 분포/행 폭/평균 건수** 기반으로 **SIZE**(클러스터 블록 크기) 결정.  
  - 인덱스 클러스터는 **클러스터 인덱스**가 병목이면 **버퍼 핫블록**, 해시 클러스터는 **HASHKEYS 조정**/재구성 필요.  
  - 스키마 변경 난이도 고려(처음에 잘 잡는 게 핵심).

---

# 11. 검증 스크립트 템플릿 (계획/통계/세그먼트)

```sql
-- 1) 최근 실행 SQL 실제 수행 통계
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +OUTLINE'));

-- 2) 세그먼트/인덱스 현황
SELECT segment_name, segment_type, bytes/1024/1024 MB
FROM   user_segments
WHERE  segment_name IN ('IOT_DEMO','IOT_DEMO_STATUS_IX',
                        'IOT_PART','IOT_PART_OVER', 'C_CUST','C_CUST_IDX',
                        'HC_USER','HC_PROFILE');

-- 3) IOT 보조 인덱스 → 논리 ROWID(=PK) 여부 확인
SELECT index_name, index_type, table_name, uniqueness
FROM   user_indexes
WHERE  table_name IN ('IOT_DEMO','IOT_PART','IOT_OVER','IOT_PART_OVER');

-- 4) 파티션 프루닝/로컬 인덱스 상태
SELECT index_name, partitioned, locality
FROM   user_indexes
WHERE  table_name = 'IOT_PART';
```

---

## 마무리 요약

- **IOT**는 “**PK 인덱스 자체가 테이블**”이므로 **PK 기반** 단건/범위/Top-N/Key-set에서 **최강의 I/O 패턴**을 보입니다.  
- **OVERFLOW**로 Leaf를 가볍게, **INCLUDING/PCTTHRESHOLD**로 자주 쓰는 컬럼만 **Leaf에 남겨** 캐시 효율을 끌어올리세요.  
- **Partitioned IOT**는 시간/범위 데이터의 운영(Pruning/아카이브/분산)에 유리합니다.  
- **Cluster**(인덱스/해시)는 “**같은 키**의 **여러 테이블/다수 행**을 **한 블록 근처**에 모아” **랜덤 I/O를 구조적으로 제거**합니다.  
- 단, **업데이트/행 폭/비PK 패턴**이 많은 경우엔 Heap(+적절한 인덱스)가 더 실용적일 수 있습니다.

핵심은 **자주 쓰는 접근 경로**를 기준으로 **물리 구조를 “그 액세스 패턴의 모양”에 맞게** 선택하는 것 —  
그러면 **랜덤 I/O**는 줄고, **응답시간**은 간결해집니다.