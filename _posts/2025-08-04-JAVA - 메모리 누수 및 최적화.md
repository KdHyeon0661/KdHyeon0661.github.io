---
layout: post
title: Java - 메모리 누수 및 최적화
date: 2025-08-04 23:20:23 +0900
category: Java
---
# 메모리 누수(Memory Leak) 및 최적화(Optimization) — 자세 정리

Java는 가비지 컬렉션(GC)이 있으므로 `free`를 직접 하지 않아도 되지만, **참조를 계속 보유하면 객체가 수거되지 않아 메모리 누수가 발생**합니다. 이 문서에서는 누수의 원인, 진단 방법, 코드 레벨에서의 해결책, 메모리 최적화 기법, 실무 권장사항까지 단계별로 자세히 다룹니다.

---

## 요약 (한줄)
- **메모리 누수** = 더 이상 필요하지 않은 객체가 루트로부터 참조되어 GC가 회수하지 못하는 상태.  
- **해결 순서**: 재현 → 로그/모니터링 → 힙 덤프 생성 → 분석(주로 MAT) → 원인 코드 수정 → 검증 → 운영 모니터링.

---

## 1. 메모리 누수란? (Java 관점)
- GC가 자동으로 메모리를 해제하지만 **객체가 살아있다고(참조되고 있다고) 판단되면 회수하지 않음**.
- 즉, 기대와 달리 객체의 **Retained Set(유지 집합)** 이 비정상적으로 크면 누수.
- 누수의 증상: 점진적 Heap 사용 증가 → 더 잦은 GC → Full GC → `OutOfMemoryError: Java heap space`.

---

## 2. 흔한 누수 원인(패턴) — 실무에서 자주 보는 사례

1. **Static 컬렉션에 항목을 계속 쌓음**
   - `static Map` / `List` 등에 제거 로직이 없을 때.
2. **캐시 관리 실패**
   - 무제한 캐시(예: HashMap) 사용. 만료/최대 크기 미설정.
3. **리스너/콜백를 등록하고 제거하지 않음**
   - GUI, 이벤트 시스템, 프레임워크 콜백 등.
4. **ThreadLocal을 제거하지 않음**
   - 스레드 풀에서 ThreadLocal을 사용하고 `remove()` 안 하면 재사용되는 스레드가 값 참조.
5. **비정상적인 살아있는 쓰레드(스레드 누수)**
   - 종료하지 않는 스레드가 클래스/객체를 잡아둠(특히 웹앱의 ClassLoader 누수).
6. **외부 네이티브 리소스 누수 (JNI, DirectByteBuffer)**
   - native 메모리 누수는 힙이 아니라 네이티브 영역에서 발생.
7. **익명 내부 클래스 / 람다가 외부 객체를 묵시적으로 캡처**
   - 오래 사는 객체가 내부의 짧은 객체를 잡아둠.
8. **클래스 로더 누수 (웹 앱 재배포 시 많이 발생)**
   - 글로벌 리소스(스레드, Timer, JDBC 드라이버 등)가 언로드되지 않음.

---

## 3. 진단 도구 & 기본 명령

- **jmap (HotSpot)**  
  - 힙 덤프 생성:
    ```bash
    jmap -dump:live,format=b,file=heap.hprof <pid>
    ```
  - 힙 통계:
    ```bash
    jmap -histo:live <pid>
    ```

- **jcmd** (현대적 대체)
  - 힙 덤프:
    ```bash
    jcmd <pid> GC.heap_dump /tmp/heap.hprof
    ```
  - GC 실행/정보:
    ```bash
    jcmd <pid> GC.run
    jcmd <pid> GC.class_histogram
    ```

- **jstat** (GC 통계)
  ```bash
  jstat -gcutil <pid> 1000
  ```

- **jstack** (스레드 덤프)
  ```bash
  jstack -l <pid> > threads.txt
  ```

- GUI / 상용 도구:
  - VisualVM, Java Mission Control (JMC), YourKit, JProfiler, Eclipse MAT (Memory Analyzer Tool)
  - **MAT**의 *Leak Suspects* 리포트는 매우 유용

- 프로덕션 팁:
  - JVM 옵션: `-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heap.hprof`
  - GC 로그 활성화: (JDK 8 예)
    ```text
    -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/var/log/gc.log
    ```

---

## 4. 힙 덤프 분석 절차 (권장 워크플로우)

1. **메모리 증상 재현** — 메모리 사용률이 높은 시점에서 힙 덤프 수집.
2. **MAT(또는 VisualVM) 로드** — `.hprof` 파일 열기.
3. **Dominator Tree 확인** — 어떤 객체가 많은 메모리를 '유지(retain)'하는지 파악.
4. **Leak Suspects 레포트** — MAT 자동 분석 결과 확인.
5. **Path to GC Roots 추적** — 왜 객체가 살아있는지(어떤 루트가 참조하는지) 확인.
6. **원인 식별 후 코드 수정** — 예: 캐시 정책 변경, listener 제거, ThreadLocal 제거 등.
7. **재검증** — 변경 후 동일 워크로드로 재실행, 모니터링.

---

## 5. 코드 레벨 누수 사례와 해결책 (예제 포함)

### 5.1 Static 컬렉션 누수 (문제)
```java
public class Registry {
    public static final List<User> USERS = new ArrayList<>();
    // 계속 add만 하고 remove가 없음 → 누수
}
```

**해결**: 필요 시 명확한 제거, 최대 크기 제한, 또는 WeakReference 사용.
```java
// 1) bounded list (예: circular buffer or limited queue)
private static final int MAX = 10000;
public static void add(User u) {
    synchronized(USERS) {
        if (USERS.size() >= MAX) {
            USERS.remove(0);
        }
        USERS.add(u);
    }
}
```
또는
```java
// 2) WeakHashMap (키가 약참조이면 key가 가비지 되면 엔트리 제거)
Map<Listener, Boolean> listeners = Collections.synchronizedMap(new WeakHashMap<>());
```

---

### 5.2 Listener 누수 (문제)
```java
button.addActionListener(this); // 등록만 하고 제거를 안함
```
**해결**: 컴포넌트/객체 종료 시 `removeActionListener` 호출하거나 약참조 사용.

```java
// 약참조로 래핑 (예: WeakReference 기반 구조)
class WeakListener {
    private final WeakReference<ActionListener> ref;
    // dispatch 시 ref.get()이 null인지 체크하고 null이면 deregister
}
```

---

### 5.3 캐시 누수 (문제)
```java
Map<Key, Value> cache = new HashMap<>(); // 무제한 성장
```
**해결**: Guava Cache 또는 `LinkedHashMap` 기반 LRU, 만료정책 사용.

```java
// LinkedHashMap 기반 LRU
private final Map<K,V> lru = new LinkedHashMap<K,V>(16,0.75f,true) {
    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
        return size() > MAX_ENTRIES;
    }
};
```

또는 Guava:
```java
Cache<Key, Value> cache = CacheBuilder.newBuilder()
    .maximumSize(10000)
    .expireAfterAccess(10, TimeUnit.MINUTES)
    .build();
```

---

### 5.4 ThreadLocal 누수 (문제)
- 스레드 풀된 쓰레드에서 ThreadLocal을 사용하고 `remove()`를 호출하지 않으면 다음 작업에도 값이 남아 있음.

```java
static ThreadLocal<Connection> TL = new ThreadLocal<>();
TL.set(conn);
// ... 사용 후
// TL.remove(); // 없으면 누수
```

**해결**: 사용 후 `remove()` 호출 또는 try-finally에서 제거.
```java
try {
    TL.set(conn);
    // 작업
} finally {
    TL.remove();
}
```

---

### 5.5 Unclosed Resource (IO, JDBC) 누수
- 스트림, `ResultSet`, `Statement`, `Connection` 등을 닫지 않으면 native 리소스/handles 누수.

**권장**: `try-with-resources`
```java
try (Connection c = ds.getConnection();
     PreparedStatement ps = c.prepareStatement(sql);
     ResultSet rs = ps.executeQuery()) {
    // 처리
}
```

---

### 5.6 ClassLoader 누수 (웹앱 재배포 문제)
- 웹앱이 생성한 `Thread`, `Timer`, `JDBC Driver` 등이 정리되지 않으면 클래스 로더가 GC 되지 않음 → Metaspace 누수.

**해결**:
- 웹앱 초기화/종료( `contextDestroyed` )에서 모든 스레드/타이머 중지, 드라이버 deregister 처리.
- 프레임워크 권장 패턴 사용.

---

## 6. 메모리 최적화 기법 (코드/아키텍처 수준)

### 6.1 측정 우선 (원칙)
- **측정(프로파일링) → 병목 식별 → 최적화**. Premature optimization 금지.

### 6.2 객체 할당 줄이기
- 불필요한 임시 객체(특히 짧은 루프 내) 줄임: 문자열 연결 시 `StringBuilder`, 반복적 박싱을 피함.
- 가능한 primitive 배열 사용 (`int[]` vs `List<Integer>`).
- 컬렉션 초기 용량 지정: `new ArrayList<>(expectedSize)`로 리사이징 비용 방지.
- `String` 재사용: 빈번한 문자열 합성 최소화. `String.intern()`은 신중히(메모리/동기화 고려).

### 6.3 적절한 자료구조 선택
- `ArrayList` vs `LinkedList`: 대부분 `ArrayList`가 빠르고 메모리 효율적.
- Map의 경우 키/값 타입에 따라 `HashMap`, `ConcurrentHashMap`, `Trove/fastutil`(primitive 특화) 고려.
- `CopyOnWriteArrayList`는 읽기 많고 쓰기 적은 경우에만.

### 6.4 캐시 전략
- **SoftReference** vs **WeakReference**:
  - `SoftReference`는 메모리 부족 시 GC 대상 → 캐시 용도(메모리 압박시 자동 정리).
  - `WeakReference`는 참조가 없으면 바로 수거 → 주로 맵 키 약참조에 사용(WeakHashMap).
- 권장: 검증된 캐시 라이브러리 사용 (Guava Cache, Caffeine).

### 6.5 문자열 처리 최적화
- `StringBuilder`/`StringBuffer` 사용.
- `substring()`의 과거 동작(Java 6~7에서 전체 문자열을 참조하던 문제는 최신 JDK에서 해결).
- 파일 입출력은 문자 인코딩 명시, 버퍼 사용.

### 6.6 Off-heap / Native 메모리
- `ByteBuffer.allocateDirect()` 등 오프힙 사용(네이티브 메모리) — GC 부담 감소 가능하지만 네이티브 누수 위험 주의.
- 대용량 캐시(수 GB 이상)에는 off-heap, 외부 시스템 Redis/Memcached 권장.

### 6.7 객체 재사용(Object Pool)은 신중히
- 풀링은 오히려 오버헤드/복잡성을 증가시킬 수 있음. 재사용 이득은 **비싼 생성 비용**인 경우에만 고려.

### 6.8 Escape Analysis & JIT 활용
- 최신 JVM은 **Escape Analysis**로 객체를 스택 할당 또는 스칼라로 분해해 할당 비용을 줄임. 코드를 단순하게 유지하면 JIT 최적화 혜택을 많이 받음.

---

## 7. JVM/GC 레벨 최적화 팁

- 적절한 힙 크기 설정: `-Xms`/`-Xmx`. 너무 작은 힙은 과도한 GC, 너무 큰 힙은 긴 Full GC(또는 긴 heap scan).
- GC 알고리즘 선택: 워크로드(지연 요구/처리량/힙 크기)에 맞춰 G1, ZGC 등 선택.
- `-XX:+UseCompressedOops` (64-bit JVM에서 기본적으로 활성) — 레퍼런스 압축으로 메모리 절감.
- `-XX:MaxGCPauseMillis` (G1)로 pause 목표 설정 후 테스트.
- 프로파일링용 옵션: `-XX:+UnlockDiagnosticVMOptions -XX:+PrintSafepointStatistics` 등.

---

## 8. 모니터링 & 알림(운영 관점)

- **지표(메트릭)**:
  - Heap Used, Heap Committed, Eden/Old usage, GC Pause Time, GC Count, Promotion Rate.
- **도구**:
  - Prometheus JMX exporter + Grafana 대시보드
  - JFR(Flight Recorder) + JMC 분석
  - APM (NewRelic, AppDynamics, Datadog) — 힙/GC 모니터링
- **알림 룰**:
  - Heap used > 80% 지속, GC pause > threshold, OOM 이벤트 발생 시 경보.

---

## 9. 점검 체크리스트 (문제 발견 시 빠른 대응)

1. 재현 가능한가? (부하·시간·특정 API)  
2. GC 로그 확인: Minor/Full 빈도, pause 패턴.  
3. jmap/jcmd로 힙 덤프 수집(사용률이 높은 시점).  
4. MAT로 Dominator Tree, Leak Suspects 분석.  
5. Path to GC Roots로 누수 원인 식별.  
6. 코드 수정(예: remove listener, clear caches, ThreadLocal.remove()).  
7. 성능 테스트/부하 테스트로 검증.  
8. 프로덕션 모니터링으로 재발 감시.

---

## 10. 결론 / 권장사항

- **측정 → 원인 분석 → 수정 → 검증**의 순서를 지키세요.  
- 누수는 보통 *논리적 실수*에서 시작됩니다(참조를 제거하지 않음). 툴(MAT 등)을 활용하면 원인 식별이 훨씬 쉬워집니다.  
- 최적화는 **목표(지연/처리량/메모리 한계)**에 따라 달라집니다. 무작정 줄이기보다는 **가치가 있는 곳**에 투자하세요.  
- 라이브러리(Guava, Caffeine), 프레임워크 권장 패턴, JDK 최신 GC 기능(ZGC 등)을 활용하면 많은 문제를 예방·해결할 수 있습니다.
