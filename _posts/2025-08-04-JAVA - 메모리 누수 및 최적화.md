---
layout: post
title: Java - 메모리 누수 및 최적화
date: 2025-08-04 23:20:23 +0900
category: Java
---
# 메모리 누수(Memory Leak) & 메모리 최적화(Optimization)

## 한줄 요약 & 큰 그림

- **메모리 누수**: 필요 없는 객체가 **루트에서 여전히 참조**되어 GC가 회수하지 못하는 상태.
- **문제 해결 루프**: 재현 → 로그/메트릭 확인 → **힙 덤프 수집** → **MAT 분석** → 원인 코드 수정 → 부하 재검증 → **운영 모니터링**.

```
[증상 감지] → [데이터 수집] → [원인 규명] → [수정·튜닝] → [검증] → [모니터링 지속]
```

---

## 메모리 누수 정의와 증상

### Reachability & Retained Set

- 객체가 **GC Root**(스레드 스택, 정적 변수, JNI 등)로부터 **도달 가능(reachable)** 하면 **살아있다**고 간주되어 수거되지 않습니다.
- 어떤 객체 집합 \(S\)가 제거되면 함께 사라지는 메모리 총량을 **Retained Size**라고 합니다.

$$
\text{Retained}(X) \;=\; \sum_{o \in \text{Objects dominated by } X} \text{ShallowSize}(o)
$$

> **핵심**: 누수는 보통 **루트에서 이어지는 참조 고리**가 의도치 않게 남아 발생합니다.

### 전형적 증상

- 힙 사용량이 **계단형으로 증가**(Minor GC 후에도 하강 폭이 점점 작아짐)
- **Full GC 빈도 상승** → `OutOfMemoryError: Java heap space`
- 처리량/지연시간 악화, `GC overhead limit exceeded`

---

## 누수 **원인 패턴 12종** (문제 ↔ 수정)

> 각 패턴은 “문제 코드 → 원인 → 수정 코드/대안” 순으로 제시합니다.

### `static` 컬렉션 무제한 성장

```java
// 문제
public class Registry {
    public static final List<User> USERS = new ArrayList<>();
    public static void add(User u) { USERS.add(u); } // 제거/한도 없음
}
```
- **원인**: 전역 수명 = 앱 종료까지 보관 → 수거 불가
- **수정**: **상한선/만료** 부여 또는 약참조 활용
```java
// 상한선(LRU 유사)
private static final int MAX = 10_000;
public static synchronized void add(User u) {
    if (USERS.size() >= MAX) USERS.remove(0);
    USERS.add(u);
}
```
또는
```java
// WeakHashMap: 키에 약참조 사용(키가 더 이상 강참조되지 않으면 엔트리 제거)
Map<Listener, Boolean> listeners = Collections.synchronizedMap(new WeakHashMap<>());
```

### 캐시 누수

```java
// 문제 — 무제한 HashMap 캐시
Map<Key, Value> cache = new HashMap<>();
```
- **수정**: 만료/용량 제한이 있는 캐시
```java
// LinkedHashMap 기반 LRU
Map<K,V> lru = new LinkedHashMap<K,V>(16, 0.75f, true) {
  protected boolean removeEldestEntry(Map.Entry<K,V> eldest) { return size() > 50_000; }
};
```
또는 **검증된 라이브러리**(예: Caffeine/Guava)의 `maximumSize/expireAfter*`.

### 이벤트 리스너/콜백 해제 누락

```java
// 문제
button.addActionListener(this); // 제거 없음
```
- **수정**: 생명주기 종료 시 제거 또는 약참조 래핑
```java
@Override public void close() { button.removeActionListener(this); } // AutoCloseable로 보장
```

### `ThreadLocal` 정리 누락(특히 스레드풀)

```java
// 문제
static final ThreadLocal<Formatter> TL = new ThreadLocal<>();
void use() { TL.set(new Formatter()); /*...*/ } // remove 없음
```
- **수정**
```java
try { TL.set(fmt); /*...*/ }
finally { TL.remove(); } // 필수
```

### 스레드/타이머 누수

```java
// 문제 — 데몬 아님, 종료 신호 없음
new Timer().scheduleAtFixedRate(task, 0, 1000);
```
- **수정**: 취소/종료 구현, `ScheduledExecutorService` + `shutdown()`
```java
ScheduledExecutorService ses = Executors.newSingleThreadScheduledExecutor();
ScheduledFuture<?> f = ses.scheduleAtFixedRate(task, 0, 1, TimeUnit.SECONDS);
// ...
f.cancel(true);
ses.shutdown();
```

### 클래스로더 누수(웹앱 재배포)

- **원인**: 웹앱이 만든 **스레드/Timer/JDBC Driver/ShutdownHook** 등이 전역에 남아 **앱 클래스로더를 붙잡음**
- **수정**: `ServletContextListener#contextDestroyed`에서 전부 **해제/deregister**

```java
public void contextDestroyed(ServletContextEvent e) {
  // 드라이버 해제 예
  Enumeration<Driver> drivers = DriverManager.getDrivers();
  while (drivers.hasMoreElements()) {
    Driver d = drivers.nextElement();
    if (d.getClass().getClassLoader() == thisAppClassLoader) {
      DriverManager.deregisterDriver(d);
    }
  }
  // 스레드/타이머/WatchService/Executor 등 전부 shutdown
}
```

### 익명 내부 클래스/람다의 **암묵적 캡처**

```java
// 문제 — 긴 수명 객체가 짧은 수명 컨텍스트를 캡처
service.onEvent(evt -> this.bigGraph.doSomething(evt)); // this 캡처
```
- **수정**: 필요한 값만 명시 캡처, 또는 **약참조** 사용/구독 해제
```java
BigGraph g = this.bigGraph;
service.onEvent(evt -> g.doSomething(evt));
```

### `WeakHashMap` 오용

```java
// 문제 — 값이 키를 강하게 참조하면(키→값→키 순환) 수거 안 됨
Map<Key, Value> map = new WeakHashMap<>();
map.put(key, new Value(key));
```
- **수정**: 값이 키를 잡지 않게 설계하거나 `WeakReference<Key>`로 래핑된 필드 사용 금지

### I/O/JDBC/네이티브 리소스 미반납

```java
// 문제
Connection c = ds.getConnection(); ResultSet rs = c.createStatement().executeQuery(sql);
// close 누락
```
- **수정**: `try-with-resources`
```java
try (Connection c = ds.getConnection();
     PreparedStatement ps = c.prepareStatement(sql);
     ResultSet rs = ps.executeQuery()) {
  // ...
}
```

### `DirectByteBuffer`/JNI 네이티브 누수

- **원인**: 오프힙은 GC 대상이 아니거나 지연 회수. `-XX:MaxDirectMemorySize` 한도 초과/OOME
- **수정**: 명시 `cleaner`(프레임워크가 제공 시), 사용량 상한/풀 관리, **종료 시 해제**

### 로깅/수집기 대기열 무한 적재

- **원인**: 비동기 로거/메트릭 큐에 역압(backpressure) 없이 put만
- **수정**: **bounded 큐** + 드롭/샘플링 정책

### `equals/hashCode` 오류로 Map 키 중복 폭증

- **원인**: 불변 요구사항 위반/해시 품질 저하 → 해시맵이 과도 성장
- **수정**: **불변 키**, 정확한 `equals/hashCode`, 필요시 `record` 활용

---

## 진단 도구 & 워크플로우

### 필수 CLI

```bash
# 힙 덤프 (JDK 9+)

jcmd <pid> GC.heap_dump /tmp/heap.hprof

# 클래스 히스토그램/GC 트리거

jcmd <pid> GC.class_histogram
jcmd <pid> GC.run

# 힙 덤프 (JDK 8-)

jmap -dump:live,format=b,file=/tmp/heap.hprof <pid>

# GC 통계

jstat -gcutil <pid> 1000   # 1초 간격
# 스레드 덤프

jstack -l <pid> > threads.txt
```

### GC 로그 활성화

- **JDK 8**:
```
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/var/log/gc.log
```
- **JDK 9+**:
```
-Xlog:gc*:file=/var/log/gc.log:time,level,tags
```

### JFR(Java Flight Recorder) — 할당 핫스팟 파악(JDK 11+)

```bash
jcmd <pid> JFR.start name=leak settings=profile duration=5m filename=/tmp/leak.jfr
jcmd <pid> JFR.stop  name=leak
```
- **Allocation in new TLAB/outside TLAB** 이벤트로 **누가 많이 할당하는지** 추적

### MAT/YourKit/JProfiler/VisualVM

- MAT의 **Leak Suspects** / **Dominator Tree** / **Path to GC Roots**가 핵심

---

## 힙 덤프 분석 실무 절차

1) **증상 시점 힙 덤프** 수집(가능하면 2~3개 간격 수집 → **증분 비교**)
2) MAT로 열고 **Leak Suspects Report** 확인
3) **Dominator Tree**에서 대용량 **도미네이터**(상위 유지자) 식별
4) 대상 노드 우클릭 → **Path to GC Roots** → 어떤 루트가 붙잡는지 확인
5) **OQL**(Object Query Language)로 패턴 탐지
   - 예: 특정 패키지 인스턴스 집계
```
// OQL 예 — 특정 타입별 개수·Shallow 합계
SELECT toString(obj.getClass()), SUM(heapSize(obj)), COUNT(*)
FROM INSTANCEOF com.example.cache.*
GROUP BY toString(obj.getClass())
```
6) **원인 코드 라인** 추적(필드/스택트레이스 보조 정보)
7) 코드 수정 → 재현 테스트 → 새 힙 덤프로 개선 확인

> **팁**: 동일 워크로드로 **전/후 힙 덤프 비교** 시 Retained Size가 줄었는지 관찰하세요.

---

## 특수/고급 주제

### `ThreadLocal` & InheritableThreadLocal

- 스레드풀 재사용 때문에 값이 **다음 작업으로 새어 나감** → `remove()` 필수
- **InheritableThreadLocal**은 자식 스레드로 값 전파 → 예기치 않은 보유 주의

### 클래스로더 & TCCL

- 일부 프레임워크는 **Thread Context ClassLoader(TCCL)** 를 전역/static에 보관
- 종료 시 **null**로 돌려놓거나 프레임워크 권장 **정리 훅** 호출

### Direct 메모리/네이티브

- `ByteBuffer.allocateDirect()` 사용량 상한: `-XX:MaxDirectMemorySize=512m` 등
- 네이티브 라이브러리는 **자체 해제** API 노출 시 반드시 호출

### Finalizer/Cleaner 주의

- `finalize()`는 **지연/예측 불가/성능 저하** → 사용 금지
- `java.lang.ref.Cleaner`(JDK 9+)도 **마지막 안전장치**일 뿐, **명시적 close()** 가 우선

---

## 코드 레벨 최적화

### “측정 → 최적화” 원칙

- **프로파일링 없이 추측 금지**. JFR/YourKit/MAT/GC 로그로 **근거**를 확보

### 할당 줄이기(Hot Path)

- 루프 내 **임시 객체** 최소화, `StringBuilder` 사용
- 컬렉션 **초기 용량** 지정: `new ArrayList<>(expected)`
- **원시형 특화** 컬렉션(fastutil, HPPC 등)로 **박싱 제거**
- **배열 우선**: `int[]`가 `List<Integer>`보다 메모리/캐시 친화적

### String/문자 처리

- 빈번한 연결 → `StringBuilder`
- 중복 상수는 공통화, 큰 JSON 가공은 **스트리밍 파서** 사용
- JDK 9+는 Compact String(UTF-16 ↔ LATIN-1)로 메모리 절감

### 자료구조 선택

| 요구 | 권장 |
|---|---|
| 순차 추가/랜덤 접근 | `ArrayList` |
| 높은 동시성 키/값 | `ConcurrentHashMap` |
| 정렬 맵 | `TreeMap`/`ConcurrentSkipListMap` |
| 읽기 매우 많고 쓰기 드묾 | `CopyOnWriteArrayList` (주의: 쓰기 비용 큼) |

### 캐시 전략

- **Caffeine/Guava**: 최대 크기 + 접근/작성 기반 만료 + 참조 강도 선택
- `SoftReference` 캐시는 GC 타이밍 의존 → **핫패스 캐시로는 비권장**(예측 불가)

### 불변/함수형 패턴

- **불변 객체**(record/Builder)로 **공유 안전성↑**
- **순수 함수** 위주로 설계 → 숨은 상태 보유 감소

### 객체 풀링은 신중히

- DB 커넥션/스레드 등 비싼 자원은 풀링
- 일반 도메인 객체는 **JIT/EA** 덕에 풀링 이득 적음 → 오히려 복잡도/누수 위험↑

---

## JVM/GC 튜닝 포인트

### 힙/메타스페이스/Direct

```
-Xms4g -Xmx4g                   # 힙 고정으로 리사이즈 비용 제거
-XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=1g
-XX:MaxDirectMemorySize=1g
```

### GC 선택(대략 가이드)

- **일반 서버/대용량**: G1(기본) → 목표 지연 `-XX:MaxGCPauseMillis=200`
- **초저지연/대형 힙**: ZGC/Shenandoah(빌드 지원 확인)
- **처리량 중시 배치**: Parallel GC

### 측정 항목

- Young/Mixed/Full **Pause**와 **빈도**, **Promotion Rate**, **Card Table/Remembered Set 비용**
- Old/Metaspace 사용률 **우상향 여부**

---

## 운영 모니터링/알림

### 지표

- Heap Used/Committed, Eden/Survivor/Old, **Pause p95/p99**, Full GC Count
- Allocation Rate(바이트/초), Promotion Rate, Finalizer/Cleaner Queue 길이
- **Direct 메모리 사용량**, OS 레벨 RSS, **GC 스레드 수/CPU 사용률**

### 권장 알림 임계값(초안)

- Heap Used **> 80%** 10분 지속
- Full GC **연속 3회 이상** 또는 **주기 1분 미만**
- Pause p99 **> SLA**(예: 500ms) N분 지속
- `OutOfMemoryError` / `GC overhead limit exceeded` 즉시 경보

---

## 체크리스트 & 레시피

### 누수 대응 체크리스트

- [ ] 재현 시나리오 확보(트래픽/시간/기능)
- [ ] GC 로그/JFR/히스토그램 스냅샷 저장
- [ ] **힙 덤프** 수집(최소 1회, 가능하면 2~3회)
- [ ] MAT: Leak Suspects, Dominator Tree 상위 Top-N 확인
- [ ] Path to GC Roots로 루트 체인 단절 포인트 파악
- [ ] 코드 수정(리스너 해제, ThreadLocal.remove, 캐시 정책)
- [ ] 동일 부하 재검증/회귀 테스트
- [ ] 운영 대시보드/경보 룰 갱신

### “누수 재현기” 간단 예제

```java
// 의도적 누수 재현(테스트 환경 전용)
public class Leaker {
  private static final List<byte[]> BAG = new ArrayList<>();
  public static void main(String[] args) throws Exception {
    for (int i = 0; ; i++) {
      BAG.add(new byte[1_000_000]); // 1MB
      if (i % 50 == 0) Thread.sleep(100);
    }
  }
}
```

### LRU 캐시 스니펫(LinkedHashMap)

```java
public class LruCache<K,V> extends LinkedHashMap<K,V> {
  private final int max;
  public LruCache(int max) { super(16, 0.75f, true); this.max = max; }
  @Override protected boolean removeEldestEntry(Map.Entry<K,V> e) { return size() > max; }
}
```

### ThreadLocal 안전 패턴

```java
static final ThreadLocal<DateFormat> TL = ThreadLocal.withInitial(
  () -> new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
);
String fmt(Date d) {
  try { return TL.get().format(d); }
  finally { TL.remove(); } // 스레드풀 환경에서 권장
}
```

### try-with-resources(중첩 자원)

```java
try (Connection c = ds.getConnection();
     PreparedStatement ps = c.prepareStatement(sql);
     ResultSet rs = ps.executeQuery()) {
  while (rs.next()) { /* ... */ }
}
```

### JFR로 할당 핫스팟 찍기(운영 무중단)

```bash
jcmd <pid> JFR.start name=alloc settings=profile duration=2m filename=/tmp/alloc.jfr
jcmd <pid> JFR.stop  name=alloc
```

---

## 부록 A) 객체 크기 개념(빠른 감각)

- 객체 헤더(마크워드+클래스 포인터) + 필드 + **8바이트 정렬 패딩**
- 64-bit + CompressedOops에서 참조는 **4바이트**
- `ArrayList`는 내부 `Object[]` 별도 할당 → 요소/용량/리사이징 고려
- **원시형 배열**은 가장 Compact, 박싱 컬렉션은 오버헤드 큼

---

## 결론

- 자바에서도 **논리적 참조가 남아있으면** 누수입니다. 핵심은 **루트에서의 경로 차단**.
- **도구(MAT/JFR/GC 로그)** 로 **근거를 확보**하고, 코드/구조/정책(캐시·리스너·ThreadLocal·네이티브)을 **체계적으로 정리**하면 대부분의 누수는 빠르게 해결됩니다.
- 최적화는 **가치 기반**으로: **핫패스 할당 감소**, **적절한 자료구조**, **예측 가능한 캐시**, **현대 GC의 강점(G1/ZGC) 활용**.
- 마지막으로, **측정 → 수정 → 재검증 → 모니터링** 루프를 자동화하여 **재발을 방지**하세요.
