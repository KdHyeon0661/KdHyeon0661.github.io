---
layout: post
title: 논리회로설계 - 레지스터·카운터 심화
date: 2025-09-08 16:25:23 +0900
category: 논리회로설계
---
# 레지스터·카운터 심화 — **임의 순서 카운터**, **S–R/ J–K 플립플롭으로 설계**, **플립플롭 입력식 유도 요약**

> 표기: \(Q_i\)=현재 상태 비트 \(i\), \(Q_i^+\)=다음 상태 비트, \(\overline{X}\)=NOT \(X\), \(\oplus\)=XOR.  
> 플립플롭(FF)은 에지-트리거 D/JK/T/SR 중 어떤 것이든 사용할 수 있으나, **방법론**은 동일합니다:  
> **(1) 상태 정의 → (2) 전이표/다이어그램 → (3) FF 타입 선택 → (4) 여기사표(Excitation)로 입력식 유도 → (5) 간략화(K-map/대수) → (6) 잠금(lockout)/자기시동(self-start) 검토.**

---

## 1) **임의 순서 카운터(Arbitrary-Sequence Counter)**

### 1.1 개념
- 미리 정한 **임의의 순서**(예: \(S: s_0\to s_3\to s_5\to s_2\to s_7\to s_1\to \cdots\))로 상태를 순환하는 카운터.  
- **용도**: 테스트 패턴 발생기, 주소 재매핑, 의도적 EMI 분산, 사용자 인터페이스 패턴 등.

### 1.2 설계 절차(일반)
1) **상태 리스트/다이어그램**: 필요한 상태수 \(|S|\)와 순서 지정.  
2) **상태 인코딩**:  
   - **이진**(\(\lceil\log_2|S|\rceil\) 비트),  
   - **그레이**(인접 전이 1비트만 변동 → 글리치·EMI 유리),  
   - **원-핫**(상태수개 FF; 속도↑, 면적↑),  
   - **존슨/링/LFSR**(특수형: §1.5).  
3) **다음 상태 논리** \(Q^+=f(Q,\,\text{입력})\) 유도(보통 입력 없음).  
4) **FF 타입 선택**(D/JK/T/SR).  
5) **여기사표**로 각 FF의 입력식 도출(§3).  
6) **간략화**(K-map/대수) & **불법 상태 처리**(self-start/lockout 회피).

### 1.3 예제 A — 3비트 **임의 순서**(입력 없음)
- **순서**: \(000 \to 011 \to 101 \to 010 \to 111 \to 001 \to 100 \to 110 \to 000\) (8상태 순환)  
- **다음 상태 표**:

| 현재 \(Q_2Q_1Q_0\) | 다음 \(Q_2^+Q_1^+Q_0^+\) |
|:--:|:--:|
| 000 | 011 |
| 011 | 101 |
| 101 | 010 |
| 010 | 111 |
| 111 | 001 |
| 001 | 100 |
| 100 | 110 |
| 110 | 000 |

- **D-FF로 간단히**: \(D_i = Q_i^+\). 이 표를 그대로 K-map에 옮겨 **SOP**를 구하면 끝.  
- **JK/T/SR로** 구현할 경우, §3의 **여기사표 변환**을 사용해 입력식 \(J_i,K_i\) 또는 \(T_i\)/\(S_i,R_i\)를 얻는다(아래 §2.3에서 실제로 해봅니다).

### 1.4 불법 상태 & 자기시동(Self-Starting)
- **불법 상태**: 인코딩 공간 중 사용 안 하는 코드(예: 3비트에서 5상태만 쓰면 3개는 불법).  
- **잠금(lockout)** 방지: 불법 상태에서 **어떤 경로로도** 유효 루프로 **복귀**하도록 다음 상태를 **강제**.  
  - 원칙: **“모든 상태로부터 루프에 진입”** → self-start.  
  - 방법: 불법 상태셀(K-map)에 **don’t-care**가 아닌 **복귀 값**을 기입해 최소식에 반영.

### 1.5 특수한 임의 순서 — **LFSR, 링/존슨**
- **링(Ring)**: 원-핫 상태가 순환(주기 \(n\)). 디코딩이 쉬워 FSM/스캔에 유리.  
- **존슨(Johnson, Twisted Ring)**: 보수 피드백으로 주기 \(2n\).  
- **LFSR**(선형 귀환 쉬프트 레지스터):  
  - \(Q^+ = (A\cdot Q)\) 형태, 탭 다항식으로 결정.  
  - **최대길이**(m-sequence)면 주기 \(2^n-1\) (*all-zero*는 **잠금 상태** → 초기화 필요).  
  - 빠르고 자원 적음, 분포 균일. **self-start**하려면 all-zero에서 벗어나게 **비동기 프리셋** 혹은 **zero-trap escape** 로직 추가.

---

## 2) **S–R/ J–K 플립플롭**을 사용한 카운터 설계

### 2.1 왜 D 대신 SR/JK를 쓰나?
- 기술 셀 라이브러리가 **JK/SR FF**를 기본 제공하거나, 기존 보드/TTL(74xx) 부품 호환을 위해.  
- **논리 깊이** 또는 **게이트 수**가 JK/SR 직구현에서 더 작아질 때.

### 2.2 여기사표(Excitation Table) 복습
- **D FF** (정의): \(D = Q^+\).
- **T FF**:
  \[
  T=\begin{cases}
  1,& Q\neq Q^+\\
  0,& Q=Q^+
  \end{cases}
  \quad\Rightarrow\quad T = Q \oplus Q^+.
  \]
- **JK FF**:

| \(Q\) | \(Q^+\) | \(J\) | \(K\) |
|:--:|:--:|:--:|:--:|
| 0 | 0 | 0 | X |
| 0 | 1 | 1 | X |
| 1 | 0 | X | 1 |
| 1 | 1 | X | 0 |

  ⇒ **요약식**: \(\boxed{J = \overline{Q}\,Q^+,\;\; K = Q\,\overline{Q^+}}\).

- **SR FF**(활성 High, 금지 \(S=R=1\)):

| \(Q\) | \(Q^+\) | \(S\) | \(R\) |
|:--:|:--:|:--:|:--:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 0 | 0 |

  ⇒ **요약식**: \(\boxed{S = \overline{Q}\,Q^+,\;\; R = Q\,\overline{Q^+}}\).

> JK와 SR은 **같은 형태**이나, JK는 \((1,1)\)이 허용(토글), SR은 **금지**. 카운터에 SR을 쓸 때는 전이에서 \((1,1)\)이 발생하지 않도록 **반드시** 확인.

---

### 2.3 예제 B — §1.3의 임의순서를 **J–K FF**로 구현

- 상태 비트 \(Q_2Q_1Q_0\). 표에서 각 비트의 \(Q_i^+\)를 읽어 **\(J_i,K_i\)**를 구한다:

\[
J_i = \overline{Q_i}\,Q_i^+, \qquad K_i = Q_i\,\overline{Q_i^+}
\]

- **표 작성(일부만 전개; 나머지는 같은 방식)**

| \(Q_2Q_1Q_0\) | \(Q_2^+\) | \(J_2\) | \(K_2\) | \(Q_1^+\) | \(J_1\) | \(K_1\) | \(Q_0^+\) | \(J_0\) | \(K_0\) |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
| 000 | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0 |
| 011 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |
| 101 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 |
| 010 | 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 0 |
| 111 | 0 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |
| 001 | 1 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 |
| 100 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 |
| 110 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 1 |

- **K-map 간략화**: 각 \(J_i\), \(K_i\)의 1이 되는 셀을 최소 커버. 예시 결과(한 가지 해):

\[
\begin{aligned}
J_2 &= \overline{Q_2}\,\overline{Q_1}\,\overline{Q_0} \;+\; \overline{Q_2}\,Q_1\,Q_0 \;+\; \overline{Q_2}\,Q_1\,\overline{Q_0} \\[2pt]
K_2 &= Q_2\,\overline{Q_1}\,Q_0 \;+\; Q_2\,Q_1\,\overline{Q_0} \;+\; Q_2\,Q_1\,Q_0 \\[6pt]
J_1 &= \overline{Q_1}\,\overline{Q_0} \;+\; \overline{Q_2}\,Q_1\,\overline{Q_0} \;+\; Q_2\,\overline{Q_1}\,Q_0 \\[2pt]
K_1 &= Q_1\,\overline{Q_0} \;+\; \overline{Q_2}\,\overline{Q_1}\,Q_0 \;+\; Q_2\,Q_1\,\overline{Q_0} \\[6pt]
J_0 &= \overline{Q_0}\,(\overline{Q_2}\,\overline{Q_1} + Q_2\,\overline{Q_1} + \overline{Q_2}\,Q_1) \\[2pt]
K_0 &= Q_0\,(\overline{Q_2}\,Q_1 + Q_2\,\overline{Q_1} + Q_2\,Q_1)
\end{aligned}
\]
> 위 식은 한 예시일 뿐이며, **don’t-care**(없다면 \(-\))를 활용하거나 공통인수를 묶어 **게이트 수/팬인**을 더 줄일 수 있습니다.  
> *실무 팁*: 임의 순서라도 **그레이/원-핫 인코딩**을 사용하면 각 \(J/K\)가 매우 단순해지는 경우가 많음.

---

### 2.4 예제 C — **S–R FF**로 모듈러-5 카운터(이진 인코딩)
- 사용 상태: \(000\to001\to010\to011\to100\to000\). 불법: 101,110,111.  
- **\(S_i=\overline{Q_i}Q_i^+\), \(R_i=Q_i\overline{Q_i^+}\)** 로 표에서 채우고,  
  불법 상태 3개는 **복귀(예: 000)**를 지정해 **self-start**(락아웃 방지).  
- 간략화 후 예시:
\[
\begin{aligned}
S_0 &= \overline{Q_0}\,(\overline{Q_2}\,\overline{Q_1} + \overline{Q_2}\,Q_1) = \overline{Q_0}\,\overline{Q_2}\\
R_0 &= Q_0\,(Q_2 + Q_1)\\[4pt]
S_1 &= \overline{Q_1}\,Q_0\\
R_1 &= Q_1\,\overline{Q_0}\\[4pt]
S_2 &= \overline{Q_2}\,Q_1\,Q_0\\
R_2 &= Q_2\,(\overline{Q_1} + \overline{Q_0})
\end{aligned}
\]
> SR은 **금지(S=R=1)**가 발생하지 않는지 끝까지 점검하세요(전 이행마다 해당 비트가 **동시에 0→1, 1→0** 요구되지 않도록 설계되어야 함).

---

## 3) **플립플롭 입력식 유도 — 요약 레시피**

### 3.1 상태표 → FF 입력으로
1) **상태표 작성**: 행=현재 상태 \(Q\) (+ 외부 입력 \(X\) 들), 열=다음 상태 \(Q^+\).  
2) **FF 타입별 테이블 채우기**  
   - **D**: \(D_i \leftarrow Q_i^+\).  
   - **T**: \(T_i \leftarrow Q_i \oplus Q_i^+\).  
   - **JK**: \(J_i \leftarrow \overline{Q_i}\,Q_i^+,\;\;K_i \leftarrow Q_i\,\overline{Q_i^+}\).  
   - **SR**: \(S_i \leftarrow \overline{Q_i}\,Q_i^+,\;\;R_i \leftarrow Q_i\,\overline{Q_i^+}\).  
3) **불법 상태 처리**:  
   - **self-start** 원하면, 불법 상태의 \(Q^+\)를 **유효 루프의 특정 상태**로 지정.  
   - 또는 합성에서 **don’t-care**로 두고, 별도 **감시/리셋 회로**로 복구.  
4) **K-map/대수 간략화**:  
   - 축: \(Q\) 비트들(+ 입력 \(X\)).  
   - 값: 위 2단계에서 구한 \(D_i/T_i/J_i/K_i/S_i/R_i\).  
   - **don’t-care** 적극 활용(불법 상태, 사용 안 하는 입력 조합).  
5) **구조화**: NAND/NOR 전용, 팬인 제한, 다중 출력 공유 등을 고려해 인수화 및 균형 트리 구성.  
6) **검증**: 기능 시뮬 + self-start/lockout 점검(모든 상태에서 루프로 귀결되는지), 타이밍(경로 균형).

### 3.2 한 줄 공식(암기용)
\[
\boxed{
\begin{aligned}
&\text{D: } D_i = Q_i^+ \\
&\text{T: } T_i = Q_i \oplus Q_i^+ \\
&\text{JK: } J_i = \overline{Q_i}\,Q_i^+,\;\; K_i = Q_i\,\overline{Q_i^+} \\
&\text{SR: } S_i = \overline{Q_i}\,Q_i^+,\;\; R_i = Q_i\,\overline{Q_i^+}
\end{aligned}}
\]

### 3.3 입력변수가 있을 때(예: 업/다운 제어 \(U/D\))
- **상태표**에 \(U/D\) 축을 추가 → \(Q^+ = f(Q, U/D)\).  
- 위 동일 절차로 \(D/T/J/K/S/R\)을 \(Q\)와 \(U/D\)의 **함수**로 간략화.  
- 예: 동기 업/다운 카운터의 **T식**  
  \[
  T_i = (U/D)\cdot\!\!\prod_{k=0}^{i-1} Q_k + \overline{(U/D)}\cdot\!\!\prod_{k=0}^{i-1} \overline{Q_k}
  \]

---

## 4) 구현 팁 & 체크리스트

1. **D FF vs JK/SR**:  
   - 논리 유도는 D가 가장 단순(그냥 \(Q^+\)).  
   - **셀 제약**이나 **게이트 수** 관점에서 JK/T/SR이 이득일 때만 선택.  
2. **SR 사용 시 금지 상태**(S=R=1) 미발생 검토(전 상태별로).  
3. **lockout/self-start**: 불법 상태 → 루프 진입 보장(상태표/그래프에서 **모든 노드**가 루프에 연결되는지 확인).  
4. **그레이/원-핫 인코딩**: 전이당 비트 변동을 줄여 **해저드/전력**을 낮추고, \(J/K/T\)식 간단화 가능.  
5. **K-map**: 임의 순서에서는 인접성이 깨기 쉬움 → **상태 인코딩**을 바꾸면 식이 급격히 단순해질 수 있음.  
6. **시뮬레이션**: 무작위 초기 상태로 시작시 **루프에 수렴**하는지(자기시동) 어서션으로 확인.  
7. **리셋**: LFSR/존슨/특수 루프는 초기 **프리셋** 필수(all-zero 락아웃 방지).  
8. **타이밍**: JK/T는 입력이 **에지 근처**에서 글리치 없이 안정되도록 조합 경로 **균형화**.

---

## 5) VHDL 스니펫 — 임의순서(D) vs JK 구동

### 5.1 D-FF 기반(가장 간단, 권장)
```vhdl
-- 예제 A의 3비트 임의 순서
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity cnt_custom_d is
  port (clk, rst, ce: in std_logic; q: out std_logic_vector(2 downto 0));
end;
architecture rtl of cnt_custom_d is
  signal r : std_logic_vector(2 downto 0) := "000";
  function next_of(s: std_logic_vector(2 downto 0)) return std_logic_vector is
  begin
    case s is
      when "000" => return "011";
      when "011" => return "101";
      when "101" => return "010";
      when "010" => return "111";
      when "111" => return "001";
      when "001" => return "100";
      when "100" => return "110";
      when others=> return "000"; -- self-start
    end case;
  end;
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= "000";
      elsif ce='1' then r <= next_of(r);
      end if;
    end if;
  end process;
  q <= r;
end;
```

### 5.2 JK-FF 기반(셀 제약 있을 때)
```vhdl
-- JK 입력은 J_i = ~Q_i & Q_i_next, K_i = Q_i & ~Q_i_next
library ieee; use ieee.std_logic_1164.all;
entity cnt_custom_jk is
  port (clk, rst, ce: in std_logic; q: out std_logic_vector(2 downto 0));
end;
architecture rtl of cnt_custom_jk is
  signal r, n : std_logic_vector(2 downto 0) := "000";
  signal J,K  : std_logic_vector(2 downto 0);
begin
  -- next state same as above
  with r select
    n <= "011" when "000",
         "101" when "011",
         "010" when "101",
         "111" when "010",
         "001" when "111",
         "100" when "001",
         "110" when "100",
         "000" when others; -- self-start

  J <= (not r) and n;
  K <= r and (not n);

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= "000";
      elsif ce='1' then
        -- 이상적 JK FF의 동작을 RTL로 근사 (D=J*~Q + ~K*Q)
        for i in 0 to 2 loop
          r(i) <= (J(i) and (not r(i))) or ((not K(i)) and r(i));
        end loop;
      end if;
    end if;
  end process;
  q <= r;
end;
```
> 실제 셀 매핑에서는 위의 조합식이 **JK 포트**로 매핑되며, 합성기는 해당 라이브러리의 JK FF 프리미티브를 인식합니다.

---

### 포켓 요약
- **임의 순서 카운터**: 상태 정의→인코딩→상태표→FF 타입 선택→여기사표→간략화→self-start 검토.  
- **JK/SR 사용 설계**: \(\;J=\overline{Q}Q^+,\;K=Q\overline{Q^+}\;\) / \(\;S=\overline{Q}Q^+,\;R=Q\overline{Q^+}\;\)를 **직접** 채워 K-map 간략화.  
- **유도 공식**(암기):  
  \(\;D=Q^+,\; T=Q\oplus Q^+,\; J=\overline{Q}Q^+,\; K=Q\overline{Q^+},\; S=\overline{Q}Q^+,\; R=Q\overline{Q^+}\;\).  
- **lockout 방지**: 불법 상태의 \(Q^+\)를 유효 루프로 **강제**(self-start).  
- **인코딩 선택**(그레이/원-핫/존슨/LFSR)이 **식 복잡도와 해저드**를 좌우한다.