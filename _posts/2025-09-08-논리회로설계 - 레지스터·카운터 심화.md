---
layout: post
title: 논리회로설계 - 레지스터·카운터 심화
date: 2025-09-08 16:25:23 +0900
category: 논리회로설계
---
# 레지스터·카운터 심화 — **임의 순서 카운터**, **S–R/J–K 플립플롭 설계**, **플립플롭 입력식 유도 요약**

> 표기: \(Q_i\)=현재 상태 비트 \(i\), \(Q_i^+\)=다음 상태 비트, \(\overline{X}\)=NOT \(X\), \(\oplus\)=XOR.
> 기본 가정: 동기식 클록, 에지 트리거 FF(D/JK/T/SR), 조합 논리는 합성 가능한 형태로 기술.
> 목표: “상태 정의→전이표→FF 타입 선택→여기사표로 입력 유도→간략화→self-start/lockout 검토”를 **끝까지** 실무 수준으로 구현한다.

---

## 준비: 상태 인코딩과 타이밍 전제

- **인코딩 선택**이 곧 복잡도: 이진(최소 비트), 그레이(전이당 1비트), 원-핫(상태수=FF수, 디코딩 용이), 링/존슨/LFSR(특수 순서).
- **타이밍 경계**
  \[
  t_{CQ}+t_{\text{comb}}+t_{SU}\le T_{CLK},\qquad t_H\le t_{\min\text{ path}}
  \]
  JK/SR/T는 **입력 안정 창**(setup/hold)이 넓도록 조합 깊이를 얕게.

---

## 카운터

### 절차(전형)

1. **상태열** \(S=(s_0\to s_1\to\cdots\to s_{k-1}\to s_0)\) 확정.
2. **인코딩** 선택(이진/그레이/원-핫/특수).
3. **전이표** 작성: 행=현재 \(Q\), 열=다음 \(Q^+\).
4. **FF 타입** 선택(D/JK/T/SR).
5. **여기사표**로 입력식 도출(§3).
6. **K-map/대수**로 간략화.
7. **불법 상태 처리**(self-start/lockout 방지).

### 예제 A — 3비트 임의 순서(입력 없음)

- 순서(8상태 순환):
  \(000 \to 011 \to 101 \to 010 \to 111 \to 001 \to 100 \to 110 \to 000\)

| 현재 \(Q_2Q_1Q_0\) | 다음 \(Q_2^+Q_1^+Q_0^+\) |
|:--:|:--:|
| 000 | 011 |
| 011 | 101 |
| 101 | 010 |
| 010 | 111 |
| 111 | 001 |
| 001 | 100 |
| 100 | 110 |
| 110 | 000 |

- **D-FF**면 가장 단순: \(D_i=Q_i^+\). K-map으로 각 \(D_i\)를 SOP/POS로 최소화하면 끝.
- **JK/T/SR**로도 가능(§2, §3 공식 그대로 적용).

#### 인코딩 선택 비교(요약)

| 인코딩 | FF 개수 | 전이당 비트 변화 | 디코딩 난이도 | 장점 | 단점/주의 |
|---|---:|---:|---|---|---|
| 이진(Binary) | ⌈log₂|S|⌉ | 보통 다비트 | 중간 | FF 적음, 면적↓ | 전이 복잡→해저드/논리 깊이↑ |
| 그레이(Gray) | ⌈log₂|S|⌉ | **1비트** | 중간 | 글리치/EMI 유리 | 임의 순서에 맞추려면 재배열 필요 |
| 원-핫(One-Hot) | \|S\| | 2비트 | **매우 쉬움** | 고속, 논리 단순 | FF 많음, 면적/전력↑ |
| 링(Ring) | n | 1비트(순환) | 쉬움 | 구현 간단, 디코딩 쉬움 | 주기=n, 초기화 필요 |
| 존슨(Johnson) | n | 1비트(순환) | 쉬움 | 주기=2n, 패턴 균일 | 초기화/위상 관리 필요 |
| LFSR | n | 1비트 | 쉬움 | 자원↓, 주기 김 | all-zero 락아웃, 초기 프리셋 필요 |

#### D-FF 기반 구현(VHDL)

```vhdl
library ieee; use ieee.std_logic_1164.all;
entity cnt_custom_d is
  port (clk, rst, ce: in std_logic; q: out std_logic_vector(2 downto 0));
end;
architecture rtl of cnt_custom_d is
  signal r: std_logic_vector(2 downto 0) := "000";
  function next_of(s: std_logic_vector(2 downto 0)) return std_logic_vector is
  begin
    case s is
      when "000" => return "011";
      when "011" => return "101";
      when "101" => return "010";
      when "010" => return "111";
      when "111" => return "001";
      when "001" => return "100";
      when "100" => return "110";
      when others=> return "000"; -- self-start (불법 상태 복귀)
    end case;
  end;
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= "000";
      elsif ce='1' then r <= next_of(r);
      end if;
    end if;
  end process;
  q <= r;
end;
```

#### SystemVerilog 테스트벤치(무작위 초기화 + 수렴 확인)

```systemverilog
module tb;
  logic clk=0, rst=1, ce=0; logic [2:0] q;
  cnt_custom_d U(.clk(clk),.rst(rst),.ce(ce),.q(q));
  always #5 clk = ~clk;

  // 수렴 어서션: 임의 초기값에서 16클록 내 루프 집합 V로 수렴
  function bit in_cycle (logic [2:0] s);
    case (s)
      3'b000,3'b011,3'b101,3'b010,3'b111,3'b001,3'b100,3'b110: in_cycle=1;
      default: in_cycle=0;
    endcase
  endfunction
  property p_self_start;
    @(posedge clk) disable iff (rst) ce |-> ##[1:16] in_cycle(q);
  endproperty
  assert property (p_self_start);

  initial begin
    repeat(2) @(posedge clk);
    rst=0; ce=1;
    repeat(40) @(posedge clk);
    $finish;
  end
endmodule
```

> **Self-start**: `others` 분기를 유효 루프의 안전 상태(예: `000`)로 강제해 lockout 방지.

---

## S–R / J–K 플립플롭으로 설계

### 요약

| 타입 | 관계식 | 메모 |
|---|---|---|
| **D** | \(D=Q^+\) | 가장 단순 |
| **T** | \(T = Q \oplus Q^+\) | 토글이면 1 |
| **JK** | \(J=\overline{Q}\,Q^+,\;\;K=Q\,\overline{Q^+}\) | \(J=K=1\)이면 토글 |
| **SR** | \(S=\overline{Q}\,Q^+,\;\;R=Q\,\overline{Q^+}\) | \(S=R=1\) **금지** |

> JK와 SR의 수식은 동일 형태지만 **허용 영역**이 다르다. SR은 설계 전이 전체에서 \(S=R=1\)이 **절대** 나오지 않도록 확인.

---

#### 플립플롭 여기사/구동 공식 표

| FF 유형 | 구동/여기사 공식(비트 i) | 메모 |
|---|---|---|
| D | \(D_i = Q_i^+\) | 최단 경로, 유도 간단 |
| T | \(T_i = Q_i \oplus Q_i^+\) | 토글이면 1 |
| JK | \(J_i=\overline{Q_i}Q_i^+,\;K_i=Q_i\overline{Q_i^+}\) | \(J=K=1\) 토글 |
| SR | \(S_i=\overline{Q_i}Q_i^+,\;R_i=Q_i\overline{Q_i^+}\) | \(S=R=1\) 금지 |

---

### 예제 B — 예제 A를 **JK-FF**로 구현

- 각 비트 \(i\)에 대해
  \[
  J_i=\overline{Q_i}Q_i^+,\qquad K_i=Q_i\overline{Q_i^+}
  \]
- 전이표에서 \(Q_i, Q_i^+\)를 읽어 1/0/X 채우고 **K-map 최소화**. (아래는 한 가지 가능한 결과)

\[
\begin{aligned}
J_2 &= \overline{Q_2}\,(\overline{Q_1}\,\overline{Q_0} + Q_1\,Q_0 + Q_1\,\overline{Q_0}) \\
K_2 &= Q_2\,(\overline{Q_1}\,Q_0 + Q_1\,\overline{Q_0} + Q_1\,Q_0) \\[4pt]
J_1 &= \overline{Q_1}\,\overline{Q_0} + \overline{Q_2}\,Q_1\,\overline{Q_0} + Q_2\,\overline{Q_1}\,Q_0 \\
K_1 &= Q_1\,\overline{Q_0} + \overline{Q_2}\,\overline{Q_1}\,Q_0 + Q_2\,Q_1\,\overline{Q_0} \\[4pt]
J_0 &= \overline{Q_0}\,(\overline{Q_2}\,\overline{Q_1} + Q_2\,\overline{Q_1} + \overline{Q_2}\,Q_1) \\
K_0 &= Q_0\,(\overline{Q_2}\,Q_1 + Q_2\,\overline{Q_1} + Q_2\,Q_1)
\end{aligned}
\]

- **VHDL(합성용, JK 프리미티브가 있는 셀 라이브러리 가정)**

```vhdl
-- 논리: J = ~Q & Qnext, K = Q & ~Qnext
library ieee; use ieee.std_logic_1164.all;
entity cnt_custom_jk is
  port (clk, rst, ce: in std_logic; q: out std_logic_vector(2 downto 0));
end;
architecture rtl of cnt_custom_jk is
  signal r, n: std_logic_vector(2 downto 0) := "000";
  signal J,K : std_logic_vector(2 downto 0);
begin
  with r select
    n <= "011" when "000",
         "101" when "011",
         "010" when "101",
         "111" when "010",
         "001" when "111",
         "100" when "001",
         "110" when "100",
         "000" when others; -- self-start

  J <= (not r) and n;
  K <= r and (not n);

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= "000";
      elsif ce='1' then
        for i in 0 to 2 loop
          -- 이상적 JK 모델의 등가식: D = J*~Q + ~K*Q
          r(i) <= (J(i) and (not r(i))) or ((not K(i)) and r(i));
        end loop;
      end if;
    end if;
  end process;
  q <= r;
end;
```

> **실무 팁**: 임의 순서라도 **원-핫/그레이 인코딩**으로 바꾸면 \(J/K\)식이 급격히 단순해지는 경우가 많다(팬인↓, 지연↓).

#### 예제 A의 JK-입력 도출 표(핵심 행만 발췌)

| \(Q_2Q_1Q_0\) | \(Q_2^+\) | \(J_2\) | \(K_2\) | \(Q_1^+\) | \(J_1\) | \(K_1\) | \(Q_0^+\) | \(J_0\) | \(K_0\) |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
| 000 | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0 |
| 011 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |
| 101 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 |
| 010 | 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 0 |
| … | … | … | … | … | … | … | … | … | … |

> 전체 행은 본문 절차대로 채우고 **K-map**으로 각 \(J_i, K_i\)를 최소화하세요.

---

### 카운터

- 사용 상태: \(000\to001\to010\to011\to100\to000\).
- 불법: 101, 110, 111 → **self-start** 위해 \(Q^+=000\)으로 강제.
- \(S_i=\overline{Q_i}Q_i^+,\;R_i=Q_i\overline{Q_i^+}\) 채워 K-map 최소화.

가능한 결과(금지 \(S=R=1\) 미발생 확인됨):

\[
\begin{aligned}
S_0 &= \overline{Q_0}\,\overline{Q_2} ,\qquad
R_0 = Q_0\,(Q_2 + Q_1) \\[2pt]
S_1 &= \overline{Q_1}\,Q_0 ,\qquad
R_1 = Q_1\,\overline{Q_0} \\[2pt]
S_2 &= \overline{Q_2}\,Q_1\,Q_0 ,\qquad
R_2 = Q_2\,(\overline{Q_1} + \overline{Q_0})
\end{aligned}
\]

- **VHDL 스켈레톤**(SR FF 프리미티브가 없는 경우 등가식으로 D를 합성)

```vhdl
-- SR 이상적 모델의 등가 D: D = S + (~R & Q)
library ieee; use ieee.std_logic_1164.all;
entity cnt_mod5_sr is
  port (clk, rst, ce: in std_logic; q: out std_logic_vector(2 downto 0));
end;
architecture rtl of cnt_mod5_sr is
  signal Q: std_logic_vector(2 downto 0) := "000";
  signal S,R: std_logic_vector(2 downto 0);
  signal D: std_logic_vector(2 downto 0);
begin
  -- S/R 논리(위 식 사용) — 실무에선 K-map으로 직접 유도
  S(0) <= (not Q(0)) and (not Q(2));
  R(0) <= Q(0) and (Q(2) or Q(1));

  S(1) <= (not Q(1)) and Q(0);
  R(1) <= Q(1) and (not Q(0));

  S(2) <= (not Q(2)) and Q(1) and Q(0);
  R(2) <= Q(2) and ((not Q(1)) or (not Q(0)));

  D <= S or ((not R) and Q); -- SR→D 등가

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then Q <= "000";
      elsif ce='1' then Q <= D;
      end if;
    end if;
  end process;
  q <= Q;
end;
```

> SR은 반드시 **전 전이**에서 \(S=R=1\)이 나오지 않는지 끝까지 체크. 필요시 상위 논리에서 게이팅하여 금지 영역을 없앤다.

---

### 상태/다음 상태 및 S/R 요약

| 현재 | 다음 | \(S_2\) | \(R_2\) | \(S_1\) | \(R_1\) | \(S_0\) | \(R_0\) |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
| 000 | 001 | 0 | 0 | 0 | 0 | 1 | 0 |
| 001 | 010 | 0 | 0 | 1 | 0 | 0 | 1 |
| 010 | 011 | 0 | 0 | 0 | 0 | 1 | 0 |
| 011 | 100 | 1 | 0 | 0 | 1 | 0 | 1 |
| 100 | 000 | 0 | 1 | 0 | 0 | 0 | 0 |
| **101** | **000** | *복귀* | *복귀* | *복귀* | *복귀* | *복귀* | *복귀* |
| **110** | **000** | *복귀* | *복귀* | *복귀* | *복귀* | *복귀* | *복귀* |
| **111** | **000** | *복귀* | *복귀* | *복귀* | *복귀* | *복귀* | *복귀* |

> 위 표로부터 최소화하면 본문 식과 동일:
> \(S_0=\overline{Q_0}\overline{Q_2},\;R_0=Q_0(Q_2+Q_1)\), … 등.

---

## 플립플롭 입력식 유도 — 한 장 레시피

### 상태표 → 입력식(절차)

1) **상태표** 작성(필요시 입력 \(X\) 포함).
2) **타입별 규칙**으로 각 비트 \(i\)에 대해 표를 채운다.
   - D: \(D_i\leftarrow Q_i^+\)
   - T: \(T_i\leftarrow Q_i\oplus Q_i^+\)
   - JK: \(J_i\leftarrow\overline{Q_i}Q_i^+,\;K_i\leftarrow Q_i\overline{Q_i^+}\)
   - SR: \(S_i\leftarrow\overline{Q_i}Q_i^+,\;R_i\leftarrow Q_i\overline{Q_i^+}\)
3) **불법 상태**는 self-start 원칙에 따라 \(Q^+\)를 지정(또는 DC로 두고 별도 복구 회로).
4) **K-map/대수** 최소화(팬인/팬아웃/셀 제약 반영).
5) **구조 매핑**(NAND-NAND/NOR-NOR, 카리체인/공유식) → 타이밍 균형.
6) **검증**: 기능/타이밍 시뮬, self-start/lockout, 초기화 전략.

### 암기 공식

\[
\boxed{
\begin{aligned}
& D_i = Q_i^+,\qquad T_i = Q_i \oplus Q_i^+ \\
& J_i = \overline{Q_i}\,Q_i^+,\quad K_i = Q_i\,\overline{Q_i^+} \\
& S_i = \overline{Q_i}\,Q_i^+,\quad R_i = Q_i\,\overline{Q_i^+}
\end{aligned}}
\]

### 입력 제어가 있을 때(예: 업/다운 \(U/D\))

\[
T_i = (U/D)\cdot\!\!\prod_{k=0}^{i-1} Q_k \;+\; \overline{(U/D)}\cdot\!\!\prod_{k=0}^{i-1} \overline{Q_k}
\]

또는 D-기반이면
\[
Q^+ = Q + (U/D?+1:-1)\pmod{2^n}\ \ \Rightarrow\ \ D=Q^+
\]

---

## 특수 순서: 링/존슨/LFSR

### 링/존슨

- **링(1-hot)**: 하나의 1이 순환(주기 \(n\)), 디코딩 간단, 면적↑.
- **존슨**: \(\overline{Q_{MSB}}\)를 LSB로 주입(주기 \(2n\)), 반대 위상 패턴이 연속.

### LFSR(최대길이 m-sequence 예: 4비트, \(x^4+x+1\))

- **Fibonacci(외부 피드백)**

```vhdl
-- taps: [4,1] => new = q3 xor q0
library ieee; use ieee.std_logic_1164.all;
entity lfsr4 is
  port (clk, rst, ce: in std_logic; q: out std_logic_vector(3 downto 0));
end;
architecture rtl of lfsr4 is
  signal r: std_logic_vector(3 downto 0) := "0001"; -- all-zero 금지
  signal fb: std_logic;
begin
  fb <= r(3) xor r(0);
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= "0001"; -- zero-trap escape
      elsif ce='1' then r <= fb & r(3 downto 1);
      end if;
    end if;
  end process;
  q <= r;
end;
```

- **주의**: all-zero는 **락아웃**. 초기 프리셋 또는 zero-trap 탈출 논리를 둔다.

---

## 검증/시험: self-start·lockout·타이밍

### Self-start/lockout

- **정의**: 어떤 초기 상태에서도 유효 루프로 **유입**되어야 함.
- **체크**: 전 상태 그래프에 **흡수 집합**(유효 루프)을 만들고, 모든 노드에서 그 집합으로의 경로 존재 여부를 어서션.

```systemverilog
// 3비트 전 상태 그래프에서 8개 유효 코드 집합 V
function automatic bit in_V (logic [2:0] s);
  case (s) inside {3'b000,3'b011,3'b101,3'b010,3'b111,3'b001,3'b100,3'b110}: in_V=1; default: in_V=0;
  endcase
endfunction
// 임의 초기에서 8클록 내 V에 진입
property p_reach_V;
  @(posedge clk) disable iff (rst) ce |-> ##[1:8] in_V(q);
endproperty
assert property (p_reach_V);
```

### 타이밍/해저드

- JK/SR은 입력식이 **에지 근처**에서 안정되도록 조합 깊이를 맞추고, 가능하면 **2단 구조**(NAND-NAND/NOR-NOR) 및 **합의항**으로 글리치 억제.
- 종단 디코드/TC는 **레지스터** 후 사용(펄스 폭 보장).

### Self-Start / Lockout 처리 전략

| 전략 | 방법 | 장점 | 주의 |
|---|---|---|---|
| 상태표 강제 복귀 | 불법 상태의 \(Q^+\)를 안전 상태로 지정 | 간단, 포멀 검증 용이 | 최소화가 바뀔 수 있음 |
| 파워온 프리셋 | 리셋 시 특정 합법 상태로 세팅 | 빠른 수렴 | 리셋 트리/글리치 주의 |
| 워치독/트랩 | 불법 코드 감지→강제 리셋 | 런타임 보호 | 감지 논리 비용 |
| LFSR zero-trap 회피 | all-zero 감지→1주입 | LFSR 필수 | 타이밍 삽입 최소화 |

---

## 베스트 프랙티스 & 체크리스트

1. **인코딩부터 전략적으로**: 임의 순서라도 그레이/원-핫으로 전환하면 \(J/K/T\) 단순화.
2. **SR 금지 상태** 없음 보장(설계+검증).
3. **Self-start**: 불법 상태의 \(Q^+\)를 명시적으로 루프 유입 상태로.
4. **합성 친화**: `numeric_std`(VHDL), 전용 carry chain(가산기 기반 카운터), 팬인 제한 준수.
5. **타이밍**: \(t_{CQ}+t_{\text{comb}}+t_{SU}\) 경로를 짧게, 동일 신호 재수렴 경로는 지연 균형.
6. **전력/EMI**: 그레이/존슨/LFSR 등 **전이 제어** 패턴 활용(전력 토글/EMI 저감).
7. **검증**: 기능+타이밍(SDF), 무작위 초기화, self-start/lockout 어서션, 토글/상태 커버리지.

---

## 연습문제(풀이 원하면 요청)

1) **임의 순서(5상태) 이진 인코딩 + JK-FF**: 전이표→\(J/K\) 표→K-map 최소화→합성 코드. 불법 상태는 `000`으로 복귀.
2) **SR-FF 모듈러-6**: 상태 \(000\to001\to010\to011\to100\to101\to000\). \(S/R\)식 유도, \(S=R=1\) 미발생 증명.
3) **그레이 인코딩 임의 순서**: 4상태를 그레이 코드로 재배열해 \(T\) 입력만으로 구현(T=1이면 토글).
4) **LFSR zero-trap 회피**: 5비트 \(x^5+x^2+1\) LFSR에 zero-trap escape 로직을 동기식으로 설계(비동기 금지).
5) **Self-start 포멀 검증**: 모든 3비트 코드에서 4클록 이내 유효 루프 집합으로 진입하는 SVA 작성.

---

## 포켓 요약

- **임의 순서 카운터**: 상태열→인코딩→전이표→여기사표(D/JK/T/SR)→K-map 최소화→**self-start**.
- **여기사 표준식**:
  \[
  D=Q^+,\quad T=Q\oplus Q^+,\quad J=\overline{Q}Q^+,\quad K=Q\overline{Q^+},\quad S=\overline{Q}Q^+,\quad R=Q\overline{Q^+}.
  \]
- **SR/JK 주의**: SR 금지, JK 토글 타이밍.
- **특수 순서**: 링/존슨/LFSR로 간단·고속한 순서 생성, LFSR은 zero-trap 대응.
- **검증**: 무작위 초기화, self-start/lockout 어서션, 타이밍/해저드 점검, TC 레지스터링.

## 검증 항목 매핑(요약)

| 항목 | 목적 | 방법/도구 | 합격 기준(예시) |
|---|---|---|---|
| 기능 커버리지 | 모든 전이 실행 | Directed + Random TB | 전이 커버 ≥ 100% |
| Self-start | 불법 상태 탈출 | SVA Reachability | N클록 내 루프 유입 |
| 타이밍 여유 | \(t_{CQ}+t_{comb}+t_{SU}\) | STA/게이트시뮬 | Slack ≥ 0 |
| 해저드 검토 | 글리치 억제 | 게이트시뮬(관성/수송) | 펄스폭 ≥ 필터 한계 |
| TC 펄스 질 | 모듈러 디코드 안정 | TC 레지스터링 | 최소 폭 ≥ 1clk |
