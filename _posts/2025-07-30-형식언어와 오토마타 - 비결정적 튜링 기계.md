---
layout: post
title: 형식언어와 오토마타 - 비결정적 튜링 기계
date: 2025-07-30 22:20:23 +0900
category: 형식언어와 오토마타
---
# 비결정적 튜링 기계(Nondeterministic Turing Machine, **NTM**)

> **한 줄 요약**
> - **정의**: 한 구성에서 **여러 전이 후보**를 허용하고, “**어떤 한 경로라도 수용**하면 수용”으로 본다(존재적 수용).
> - **계산 가능성**: **DTM과 동일**(무엇을 계산할 수 있는가의 경계는 같다). DTM은 **BFS/도베일링**으로 NTM을 모사 가능.
> - **복잡도**: 시간에서는 **NTIME, NP** 등 차이가 본질(효율). 공간에서는 **Savitch**로 ND=Det 제곱 이내(**NPSPACE=PSPACE**, **NL=coNL**).
> - **설계 패턴**: **Guess-and-Check(증인 추측 후 검증)**, **경로 추적**(REACHABILITY), **분기-백트래킹**의 이상화.

---

## 형식적 **정의**와 계산 나무

정규(단일 테이프) NTM은 7-튜플로 준다:
$$
M=(Q,\Sigma,\Gamma,\delta,q_0,q_{\mathrm{acc}},q_{\mathrm{rej}}),
$$
여기서
- \(Q\): 유한 상태 집합, \(q_0\in Q\).
- \(\Sigma\): 입력 알파벳(\(\sqcup\notin\Sigma\)).
- \(\Gamma\supseteq\Sigma\): 테이프 알파벳(\(\sqcup\in\Gamma\)).
- \(\delta: (Q\setminus\{q_{\mathrm{acc}},q_{\mathrm{rej}}\})\times \Gamma \to \mathcal{P}\big(Q\times \Gamma \times \{L,R,S\}\big)\).
  → **여러** 전이의 **유한 집합**을 반환(비결정성).
- \(q_{\mathrm{acc}},q_{\mathrm{rej}}\): 수용/거절 정지 상태.

**구성(configuration)**은 \((q,\,t,\,h)\) (현재 상태, 테이프 내용, 헤드 위치).
한 구성에서 \(\delta\)가 내놓은 모든 전이를 **가지(branch)** 로 펼치면 **계산 나무**가 된다.

### **수용 의미**

입력 \(w\)에서
- **어떤 한 경로**라도 \(q_{\mathrm{acc}}\)로 정지하면 **수용(accept)**,
- **모든 경로**가 \(q_{\mathrm{acc}}\)에 도달 못하면 **거절(reject)** 로 본다.
  (일부 가지가 **무한 루프**여도, 한 가지라도 수용이면 전체는 수용.)

> 비결정성은 **난수**가 아니다. “**옳은 선택을 즉시 잡아내는**” 논리적 이상화(존재적 선택)로 이해한다.

---

## **승인기(recognizer)** vs **결정기(decider)**

- **인식기(RE)**:
  \(L(M)=\{\,w\mid\exists\) 수용 경로\(\}\).
  \(w\notin L(M)\)이면 모든 경로가 거절이거나 일부가 무한 루프일 수 있어 **정지 보장 X**.
- **결정기(REC)**: 모든 입력에서 **모든 경로가 유한 시간에 정지**.
  \(\exists\) 수용 경로 ↔ 수용, 없으면 거절.

요점: 인식은 “수용 쪽만 정지 보장”, 결정은 “양쪽 모두 정지 보장”.

---

## **DTM과의 계산 가능성 동치성**

**정리**: NTM이 인식/결정할 수 있는 **언어의 범위**는 DTM과 **동일**.
즉, **계산 가능성(what)** 관점에서 **ND = D**.

### ✨ 3.1 DTM의 NTM **모사** — BFS/도베일링

**아이디어**: 계산 나무를 **레벨 순회(BFS)** 로 전개하면,
길이 \(t\)의 수용 경로가 있으면 **유한 시간 내 발견**된다.

**의사코드**
```text
simulate_NTM(M, w):
  Q0 := { start configuration on w }        # 레벨 0
  for t = 0,1,2,...:
    if any conf in Qt is accepting:
        return ACCEPT
    Qt+1 := ⋃_{conf∈Qt} OneStep(conf)       # 모든 한-단계 후속 구성
    # 구성 중복은 canonical encoding으로 해시 제거(선택)
```

- **인식기 모사**: 수용 경로 있으면 언젠가 ACCEPT, 없으면 영원히 확장(=RE 의미와 합치).
- **결정기 모사**: NTM이 **모든 가지에서 정지**한다면, BFS는 **유한 단계 내 결론**(수용 또는 모든 구성 소진 → 거절).

> **결론**: 계산 가능성 경계(RE/REC)는 **비결정성과 무관**. 차이는 **효율(시간/공간)**.

---

## **시간·공간 복잡도** 개관

### 와 **NP**

- \( \mathrm{NTIME}(t(n))\): 길이 \(n\) 입력에서 **최대 \(t(n)\)** 단계 안에 **어떤 가지**라도 수용 → 수용.
- 대표 부류 **NP**:
$$
\mathrm{NP} := \bigcup_{k\ge 1}\mathrm{NTIME}(n^k).
$$

**동치 특성(증인/검증기)**:
$$
L\in \mathrm{NP}\iff \exists\ \text{다항시간 DTM }V \ \text{s.t.}\
x\in L \Leftrightarrow \exists y,\ |y|\le \mathrm{poly}(|x|),\ V(x,y)=1.
$$
- NTM은 “**증인 \(y\)를 추측**(한 가지에서)” → DTM 검증 \(V\) 실행(다항).

**모사 오버헤드**: \(t(n)\)-시간 NTM을 DTM이 보통 \(c^{t(n)}\) (지수) 시간에 모사.
⇒ \( \mathrm{P} \subseteq \mathrm{NP} \subseteq \mathrm{EXPTIME}\). (**P vs NP**: 미해결)

### 와 **Savitch**

- \( \mathrm{NSPACE}(s(n))\): 어떤 가지가 **최대 \(s(n)\)** 공간 사용.
- **Savitch 정리**:
$$
\mathrm{NSPACE}(s(n)) \subseteq \mathrm{DSPACE}\big(s(n)^2\big)\quad (s(n)\ge \log n).
$$
- 귀결: **NPSPACE = PSPACE**.
- **Immerman–Szelepcsényi**: \(s(n)\ge\log n\)이면 **NSPACE(s) = coNSPACE(s)**. 특히 **NL=coNL**.

> 시간에서는 ND가 잠재적으로 더 강해 보이지만(NP vs P),
> 공간에서는 **차이가 사라짐**(제곱 이내) — 중요한 대비.

---

## **설계 패턴**과 직관

### Guess-and-Check (증인 추측 후 검증)

- **SAT**: 해 \(y\) (변수 배정)를 추측 → CNF 만족 여부를 결정적으로 검증(다항).
- **해밀토니안 경로**: 정점 순열 \(y\) 추측 → 인접성 검사.

### 비결정적 경로 추적(그래프)

- **s→t 경로 존재(REACHABILITY)**: 현재 정점만 기억(로그 공간)하며 **이웃을 추측**해 진행.
  길이 ≤ \(n\) 제약으로 무한 루프 방지 ⇒ **NL**.

### 백트래킹 vs NTM

- 현실 백트래킹은 **모든 분기**를 결정적으로 **차례로 탐색**(시간 = 가지 수의 합).
- NTM 시간은 **분기 깊이**에 해당(“옳은 가지를 즉시 탑승” 가정).

---

## **예시 문제**와 NTM 스케치

### 3-SAT (NP-완전)

- 입력: CNF \(F\) (변수 \(x_1,\dots,x_n\)).
- NTM:
  1) 길이 \(n\)의 비트열 \(y\)를 **추측**.
  2) \(F(y)\) 평가가 참이면 수용, 아니면 거절.
- 시간: **NTM**은 \(O(n+m)\), **DTM** 모사 시 보통 지수.

### 해밀토니안 경로 (NP-완전)

- 입력: 그래프 \(G=(V,E)\), 시작/끝 자유.
- NTM:
  1) \(V\)의 순열 \(v_1,\dots,v_n\) **추측**.
  2) 모든 \(i\)에 대해 \((v_i,v_{i+1})\in E\)인지 검사 → 모두 OK면 수용.

### s–t 경로 존재 (NL-완전)

- 입력: 유향 그래프 \(G\), 정점 \(s,t\).
- NTM: 현재 정점 \(v\)만 (로그 공간) 저장.
  - 최대 \(n\)번 반복: \(v=t\)면 수용, 이웃 \(u\)를 **추측** 후 \(v\leftarrow u\).
  - 실패 시 거절.

---

## **코드 예제** — “비결정성의 BFS 모사기(도베일링)”

> 튜링 테이프까지 구현하지 않고, **상태공간을 생성하는 비결정 함수**를 받아
> **DTM이 BFS로 NTM을 모사**하는 **교육용** 코드입니다.
> (실전 TM 시뮬레이터에 비해 간결하지만, 핵심 아이디어—**레벨별 탐색**—를 그대로 보여줍니다.)

### 공통 BFS 엔진

```python
# 모사기

from collections import deque

def bfs_nondet(start, is_accept, expand, max_nodes=1_000_000):
    """
    start: 시작 상태(해시 가능)
    is_accept(state) -> bool: 수용 판정
    expand(state) -> iterable[next_states]: 한 단계 비결정 분기
    max_nodes: 안전 가드(무한 탐색 방지)
    """
    Q = deque([start])
    seen = set([start])
    nodes = 0
    while Q:
        nodes += 1
        if nodes > max_nodes:
            return False, nodes  # TIMEOUT 비유
        s = Q.popleft()
        if is_accept(s):
            return True, nodes
        for ns in expand(s):
            if ns not in seen:
                seen.add(ns)
                Q.append(ns)
    return False, nodes
```

### 예제 A — 3-SAT (증인 추측을 “분기”로 구현)

```python
# 3sat_bfs_example.py
# F는 절마다 3리터럴의 튜플: 예 [(+1,-2,+3), ...] ; 변수 인덱스 ±i로 표기

def eval_cnf(assign, F):
    # assign: 길이 n의 불리언 리스트/튜플 (index: 1..n 사용, 0 dummy)
    for (a,b,c) in F:
        def lit(v):
            if v > 0:  return assign[v]
            else:      return not assign[-v]
        if not (lit(a) or lit(b) or lit(c)):
            return False
    return True

def sat_ntm_state(F, n):
    # 상태 = (i, partial_assignment_as_tuple) ; i=다음 변수 인덱스
    start = (1, tuple([None]*(n+1)))  # index 1..n 사용, None=미정

    def is_accept(state):
        i, asg = state
        if i <= n: return False
        # 모든 변수 정해졌다면 평가
        # None 제거: 평가용으로 True/False만 남김
        return eval_cnf(asg, F)

    def expand(state):
        i, asg = state
        if i > n:
            return []
        # 비결정 분기: xi=False, xi=True
        a0 = list(asg); a0[i] = False
        a1 = list(asg); a1[i] = True
        return [(i+1, tuple(a0)), (i+1, tuple(a1))]

    return start, is_accept, expand

# 사용 예

if __name__ == "__main__":
    F = [(+1, -2, +3), (-1, +2, +3), (+1, +2, -3)]  # 작은 3-CNF
    n = 3
    start, is_acc, exp = sat_ntm_state(F, n)
    ok, explored = bfs_nondet(start, is_acc, exp, max_nodes=1_000_000)
    print("SAT?" , ok, " explored:", explored)
```

- **설명**: NTM의 “추측”을 **분기 생성자** `expand` 로 모델링.
  BFS는 레벨별로 모든 부분 배정을 확장 → **증인 존재 시 유한 시간 내 발견**.

### (길이 ≤ n 한정)

```python
# st_reach_bfs_example.py

def reach_ntm_state(adj, s, t):
    # 상태 = (v, steps_left)
    n = len(adj)
    start = (s, n)  # 최대 n번 이동 허용

    def is_accept(state):
        v, k = state
        return v == t

    def expand(state):
        v, k = state
        if k == 0:
            return []
        return [ (u, k-1) for u in adj[v] ]  # 비결정적으로 이웃 선택

    return start, is_accept, expand
```
- **메모리**: 상태는 \((v,k)\)로 **O(\(\log n\))** 비트면 충분(이상화).
- **BFS**는 DTM의 **공간·시간 트레이드오프**를 보여주는 간단 도구.

> 위 두 예제는 “**DTM이 NTM을 BFS로 모사**”한다는 **핵심 구조**를 직접 확인하게 해준다.

---

## 이론 포인트 — 정리/성질 모음

### 포함/불포함(대표)

- \( \mathrm{P} \subseteq \mathrm{NP} \subseteq \mathrm{PSPACE} \subseteq \mathrm{EXPTIME} \).
- \( \mathrm{NPSPACE}=\mathrm{PSPACE} \) (Savitch).
- \( \mathrm{NL}=\mathrm{coNL} \) (Immerman–Szelepcsényi).

### NP의 대체적 정의

- **비결정적 시간** vs **증인+검증기** 정의는 **동치**.
- **NP-완전성**: 다항시간 **Karp 환원**으로 서로 변환(예: SAT, 3-SAT, Hamiltonian Path, Clique 등).

### 닫힘성(간명 버전)

- **NP**: 합집합/연접/스타 등에는 닫힘(증인 합성으로 보임). **보수**는 미해결(NP=coNP?).
- **NSPACE(s)** (\(s\ge\log n\)): **보수에 닫힘** (coNSPACE와 동일).

---

## 실전 설계 팁 & 흔한 함정

1. **무한 루프 가지**: DFS 모사는 **한 가지**에 갇힐 수 있다 → **BFS/도베일링** 필수.
2. **증인 길이**: NP에서 증인은 **다항 길이**여야 한다(그 이상이면 정의 불일치).
3. **ND vs 확률**: 비결정적 “존재적 선택” ≠ 난수; BPP류와 구별.
4. **공간 모형**: 로그 공간 NTM 설계 시 **상태 변수만** 들고 가는 사고가 중요(그래프 경로 등).
5. **자원 가드**: 실험용 모사기엔 **max_steps / max_nodes** 가드로 실수 방지.

---

## (부록) 형식적 세부 — 구성/관계식

### 구성의 정식화

- 구성 \(C=(q,\,uav,\,|u|)\): 테이프를 \(u a v\)로 보고, 헤드는 \(a\) 위.
- 한 단계 관계 \(C \vdash C'\) 정의: \(\delta(q,a)\ni(q',b,D)\)이면
  테이프의 해당 칸을 \(b\)로 바꾸고 헤드를 \(D\)로 이동한 구성 \(C'\)로.

### 존재적 수용의 논리식

- \(w\in L(M) \iff \exists\) 경로 \(C_0\Rightarrow C_1\Rightarrow\cdots\Rightarrow C_t\) with \(C_t\) **accepting**.

### BFS 모사의 정지 보장(인식기)

- 수용 경로 길이가 \(t\)이면, 레벨 \(t\)에서 반드시 발견(유한 정지).
- 수용 경로가 없으면 계속 확장(=RE 인식 의미와 부합).

---

## 요약 정리

- **정의**: NTM은 한 상태/기호에서 **여러 전이**를 허용, **어떤 경로라도 수용이면 수용**.
- **계산 가능성**: **DTM과 동일**(ND=D). DTM은 **BFS/도베일링**으로 모사.
- **시간/공간**: 시간에서는 **NP** 등 ND의 잠재적 이점(효율) 핵심; 공간에서는 **Savitch**, **NL=coNL**로 동치.
- **패턴**: **Guess-and-Check**, **경로 추적**으로 설계.
- **코드**: 간단 BFS 모사기로 **3-SAT**/**s–t 경로** 예시 확인 가능.

---

## 🧠 연습 문제(선택)

1. 위 3-SAT 예제에서, 변수 4개, 절 4개짜리 CNF를 만들어 **BFS 모사 결과**(explored 노드 수)를 비교하라.
2. `reach_ntm_state`에서 **최대 길이 \(k\)** 를 인자로 넣어 경로 길이 제한을 조절해보라.
3. **클리크(Clique)** 문제의 NTM 스케치를 작성하고, BFS 모사기를 맞춰보라(증인은 정점 집합).
