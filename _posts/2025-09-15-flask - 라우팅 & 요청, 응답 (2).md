---
layout: post
title: flask - 라우팅 & 요청, 응답 (2)
date: 2025-09-15 23:25:23 +0900
category: flask
---
# 라우팅 & 요청/응답 (2)

> 이 장은 **Response 객체, 스트리밍 응답, 파일 전송, 조건부 요청(ETag/Last-Modified) & 캐시 헤더, URL 빌딩(`url_for`), 블루프린트 기반 네임스페이스 설계**를 “운영 환경에서 바로 쓰는” 수준으로 다룬다.
> 모든 코드는 ``` 로 감싸고, 수식이 있으면 반드시 $$...$$로 표기한다(본 장은 수식이 거의 없음).

---

## Flask Response 이해: 무엇을 반환할 수 있나?

Flask view는 다음 중 하나를 반환할 수 있다.

1) **`str`/`bytes`/`dict`/`list`** → Flask가 `Response`로 변환
2) **(`response`, `status`)** 또는 **(`response`, `status`, `headers`)**
3) **`flask.Response`** 직접 생성
4) **`jsonify(...)`** → JSON `Response`
5) **`redirect(...)`**, **`send_file(...)`**, **`stream_with_context(...)`** 등 헬퍼

### 기본 응답 패턴

```python
from flask import Blueprint, jsonify, make_response, Response

bp = Blueprint("resp", __name__)

@bp.get("/basic-1")
def basic_1():
    return "OK"  # text/plain; charset=utf-8

@bp.get("/basic-2")
def basic_2():
    return {"ok": True, "version": 1}  # Flask 2.x+: JSON 직렬화

@bp.get("/basic-3")
def basic_3():
    return "Accepted", 202

@bp.get("/basic-4")
def basic_4():
    headers = {"X-App": "my-service"}
    return {"ok": True}, 200, headers

@bp.get("/basic-5")
def basic_5():
    # Response 직접 생성: 세밀 제어
    resp = Response(b"binary", status=200, mimetype="application/octet-stream")
    resp.headers["X-Trace-Id"] = "abc-123"
    return resp

@bp.get("/basic-6")
def basic_6():
    # make_response: 어떤 반환값이든 Response로 래핑
    resp = make_response({"message": "created"}, 201)
    resp.headers["Location"] = "/items/123"
    return resp
```

### JSON 응답

```python
from flask import jsonify

@bp.get("/as-json")
def as_json():
    # jsonify는 Content-Type: application/json; charset=utf-8
    # dict/리스트/키워드 인자 → 안전한 JSON 인코딩
    return jsonify(ok=True, items=[1, 2, 3])
```

> **Tip**: 대용량 JSON은 **압축(Gzip/Brotli)** + **ETag/캐시**와 함께 사용.

---

## 스트리밍 응답(대용량/지연 생성/실시간)

스트리밍은 **메모리를 아끼고** 사용자에게 **빠른 최초 바이트**를 제공한다.

### 제너레이터 기반 스트리밍

```python
from flask import stream_with_context, Response, current_app
import time

@bp.get("/stream/gen")
def stream_gen():
    def generate():
        yield "start\n"
        for i in range(5):
            time.sleep(0.5)
            yield f"chunk {i}\n"
        yield "end\n"

    # stream_with_context: 요청 컨텍스트를 스트리머에 전달
    gen = stream_with_context(generate())
    return Response(gen, mimetype="text/plain")
```

- **주의(프록시/서버)**: Nginx/Cloudflare 등이 버퍼링할 수 있다. `X-Accel-Buffering: no`(Nginx) 헤더나 SSE(Sendfile 비활성) 등 별도 설정 필요.

### CSV 큰 파일 즉시 스트리밍

```python
import csv
from io import StringIO
from flask import Response

@bp.get("/export.csv")
def export_csv():
    def row_stream():
        # 헤더
        yield "id,name\n"
        # 실제로는 DB cursor/iterable에서 pull
        for i in range(1, 100_001):
            # 최소한의 가공만 하고 바로 내보냄
            yield f"{i},User {i}\n"

    return Response(
        row_stream(),
        mimetype="text/csv",
        headers={"Content-Disposition": "attachment; filename=export.csv"}
    )
```

> **반복자/제너레이터**는 **메모리 사용량이 일정**하다.

### 서버-센트 이벤트(SSE) (실시간 푸시)

```python
@bp.get("/events")
def sse():
    def event_stream():
        # SSE 프로토콜: "data: ..." 라인, 빈 줄로 이벤트 구분
        yield "retry: 1000\n"
        yield "event: hello\n"
        yield "data: world\n\n"
    resp = Response(stream_with_context(event_stream()), mimetype="text/event-stream")
    # Nginx 버퍼링 방지
    resp.headers["X-Accel-Buffering"] = "no"
    return resp
```

> 브라우저 JS: `const es = new EventSource('/events')`.

---

## 파일 전송: `send_file` / `send_from_directory`

### 기본 사용

```python
from flask import send_file, send_from_directory
from pathlib import Path

DATA_DIR = Path("/data/files")

@bp.get("/files/<path:filename>")
def download(filename):
    # 디렉터리 안전성 확보: 허용 경로 하위만
    return send_from_directory(
        DATA_DIR, filename,
        as_attachment=True,
        download_name=filename,  # Flask 2.0+: RFC5987 안전 처리
        conditional=True         # ETag/Last-Modified 기반 304 처리
    )

@bp.get("/reports/pdf")
def report_pdf():
    path = DATA_DIR / "report.pdf"
    return send_file(
        path,
        mimetype="application/pdf",
        as_attachment=False,
        conditional=True
    )
```

- `conditional=True` → **If-None-Match/If-Modified-Since**를 자동 처리(304 응답).
- `as_attachment=True` + `download_name` → 다운로드 대화상자 트리거.

### 대용량 파일과 리버스 프록시(X-Accel-Redirect)

애플리케이션이 직접 파일을 읽어 보내면 **CPU/IO**가 낭비된다. Nginx에 **오프로드**하자.

```python
@bp.get("/nginx-download/<path:filename>")
def nginx_accel(filename):
    # 내부 전용 경로로 Nginx에 위임
    resp = make_response("", 200)
    resp.headers["X-Accel-Redirect"] = f"/protected/{filename}"
    # Content-Type/Disposition은 앱에서 세팅
    resp.headers["Content-Type"] = "application/octet-stream"
    resp.headers["Content-Disposition"] = f'attachment; filename="{filename}"'
    return resp
```

Nginx 설정(예시):

```
location /protected/ {
    internal;
    alias /data/files/;
}
```

> 이런 패턴은 **대용량/고동시 다운로드**에서 성능 차이를 크게 만든다.

### 범위 요청(HTTP Range) — 부분 다운로드/시크바

Flask는 `request.range`를 제공한다. 간단한 **Partial Content(206)** 구현 예:

```python
from flask import request, abort

@bp.get("/video/<path:name>")
def video(name):
    file_path = DATA_DIR / name
    if not file_path.exists():
        abort(404)
    file_size = file_path.stat().st_size
    range_header = request.headers.get("Range")

    # 단일 범위만 처리(멀티 범위는 복잡)
    if range_header:
        # 예: "bytes=0-1023"
        units, _, rng = range_header.partition("=")
        if units != "bytes":
            abort(416)
        start_s, _, end_s = rng.partition("-")
        start = int(start_s) if start_s else 0
        end = int(end_s) if end_s else file_size - 1
        if start > end or end >= file_size:
            abort(416)

        length = end - start + 1
        with open(file_path, "rb") as f:
            f.seek(start)
            data = f.read(length)
        resp = Response(
            data, 206,
            mimetype="video/mp4",
            headers={
                "Content-Range": f"bytes {start}-{end}/{file_size}",
                "Accept-Ranges": "bytes",
                "Content-Length": str(length)
            },
        )
        return resp

    # Range 헤더 없으면 전체 전송
    return send_file(file_path, mimetype="video/mp4", conditional=True)
```

> 프로덕션에선 **웹 서버(Nginx/CloudFront)**의 Range 지원을 활용하는 편이 안전/고성능.

---

## 조건부 요청 & 캐시: ETag, Last-Modified, Cache-Control, Vary

### 왜 필요한가?

- **ETag/Last-Modified**로 클라이언트/프록시가 캐시를 재검증 → **304 Not Modified** 반환
- **Cache-Control**로 브라우저/프록시 캐시 정책 제어
- **Vary**로 콘텐츠 협상 헤더(예: `Accept-Encoding`, `Accept-Language`)에 따라 캐시 키 분리

### ETag 수동 설정

```python
import hashlib
from flask import request

@bp.get("/items/<int:item_id>")
def item(item_id):
    # 실제로는 DB에서 row 가져오기
    payload = {"id": item_id, "name": f"Item {item_id}", "ver": 3}
    body = jsonify(payload).get_data()  # bytes
    etag = hashlib.sha256(body).hexdigest()

    # If-None-Match 검사
    inm = request.headers.get("If-None-Match")
    if inm and etag in inm:
        # 변경 없음
        return "", 304, {"ETag": etag, "Cache-Control": "public, max-age=60"}

    return (
        body, 200,
        {
            "Content-Type": "application/json; charset=utf-8",
            "ETag": etag,
            "Cache-Control": "public, max-age=60"
        }
    )
```

- 실무에선 **컨텐츠 버전/updated_at**을 해시 입력에 포함하여 **불필요한 계산 줄임**.

### Last-Modified & If-Modified-Since

```python
from datetime import datetime, timezone
from werkzeug.http import http_date, parse_date

@bp.get("/docs/<int:doc_id>")
def doc(doc_id):
    # 예: DB의 updated_at
    updated_at = datetime(2025, 10, 1, 12, 0, tzinfo=timezone.utc)
    ims = request.headers.get("If-Modified-Since")
    if ims:
        dt = parse_date(ims)
        # 같거나 이후면 변경 없음
        if dt and updated_at <= dt.replace(tzinfo=timezone.utc):
            return "", 304, {
                "Last-Modified": http_date(updated_at),
                "Cache-Control": "public, max-age=120"
            }

    return (
        {"id": doc_id, "content": "..."}, 200,
        {
            "Last-Modified": http_date(updated_at),
            "Cache-Control": "public, max-age=120"
        }
    )
```

> `send_file(..., conditional=True)`를 사용하면 파일의 ETag/Last-Modified 처리를 **자동**으로 지원한다.

### 캐시 정책 설계

- **정적 파일**: `Cache-Control: public, max-age=31536000, immutable` + **버전 해시**(파일명/쿼리)
- **동적 JSON**: 짧은 TTL + ETag/Last-Modified 재검증
- **민감 데이터**: `Cache-Control: no-store`
- **압축**: Nginx에서 Gzip/Brotli, `Vary: Accept-Encoding`

```python
@bp.get("/cache-demo")
def cache_demo():
    resp = jsonify(ok=True)
    resp.headers["Cache-Control"] = "public, max-age=60"
    resp.headers["Vary"] = "Accept-Encoding"
    return resp
```

---

## 응답 헤더/쿠키/파일명 국제화(간단 모음)

### 파일명 RFC5987(예: 한글) — `download_name` 사용

```python
@bp.get("/i18n-file")
def i18n_file():
    # from Flask 2.0+, send_file의 download_name이 Content-Disposition 인코딩을 안전 처리
    return send_file(
        DATA_DIR / "보고서.pdf",
        as_attachment=True,
        download_name="보고서_2025Q4.pdf",
        conditional=True
    )
```

### 쿠키 설정(요약)

```python
from flask import make_response

@bp.get("/set-cookie")
def set_cookie():
    resp = make_response({"ok": True})
    resp.set_cookie(
        "sid", "s-1",
        max_age=3600,
        httponly=True, secure=True, samesite="Lax", path="/"
    )
    return resp
```

---

## URL 빌딩: `url_for` 완전 공략

`url_for(endpoint, **values)`는 **라우트에 결합된 엔드포인트 이름**으로 URL을 역방향 생성한다.

### 기본/쿼리 파라미터

```python
from flask import url_for

@bp.get("/build")
def build():
    # 엔드포인트는 기본적으로 "블루프린트명.함수명"
    user_url = url_for("resp.user_detail", user_id=7)
    # 쿼리는 키워드 인자가 경로 변수 외일 때 자동으로 붙음
    q_url = url_for("resp.search", q="flask", page=2)
    return {"user_url": user_url, "q_url": q_url}

@bp.get("/users/<int:user_id>")
def user_detail(user_id): ...
@bp.get("/search")
def search(): ...
```

### 외부(절대) URL / 스킴

```python
@bp.get("/abs")
def abs_url():
    # _external=True → 스킴/호스트 포함 절대 URL
    # _scheme="https"로 강제 가능(프록시/X-Forwarded-* 설정 필요)
    return {
        "self": url_for("resp.abs_url", _external=True),
        "doc": url_for("resp.doc", doc_id=10, _external=True, _scheme="https")
    }
```

> **프록시 뒤**에서 절대 URL이 올바르려면 Nginx가 `X-Forwarded-Proto` 등을 세팅하고 Flask가 이를 신뢰하도록 ProxyFix 또는 동등 설정 필요.

### URL 버전닝(네임스페이스로 분리)

- **버전별 블루프린트**: `/api/v1`, `/api/v2`
- 엔드포인트 충돌 없이 **명시적 네임스페이스** 유지

```python
from flask import Blueprint

api_v1 = Blueprint("api_v1", __name__, url_prefix="/api/v1")
api_v2 = Blueprint("api_v2", __name__, url_prefix="/api/v2")

@api_v1.get("/items/<int:id>")
def v1_item(id): ...
@api_v2.get("/items/<int:id>")
def v2_item(id): ...

@bp.get("/links")
def links():
    return {
        "v1": url_for("api_v1.v1_item", id=1, _external=True),
        "v2": url_for("api_v2.v2_item", id=1, _external=True),
    }
```

---

## 블루프린트 기반 네임스페이스 설계(폴더 구조/관례)

### 권장 구조

```
app/
├─ __init__.py           # create_app
├─ config.py
├─ extensions.py
├─ blueprints/
│  ├─ __init__.py
│  ├─ site/              # 웹 페이지(HTML 템플릿)
│  │  ├─ __init__.py     # site_bp = Blueprint("site", __name__)
│  │  ├─ views.py
│  │  └─ templates/...
│  ├─ api/
│  │  ├─ __init__.py     # api_bp = Blueprint("api", __name__, url_prefix="/api")
│  │  ├─ v1/
│  │  │  ├─ __init__.py  # api_v1 = Blueprint("api_v1", __name__, url_prefix="/api/v1")
│  │  │  ├─ resources.py
│  │  │  └─ schemas.py
│  │  └─ v2/...
│  └─ assets/
│     ├─ __init__.py     # 정적 파일/업로드/다운로드 관련
│     └─ files.py
└─ templates/
```

- **도메인 별 블루프린트**(site/api/assets …)
- **버전 별 하위 블루프린트**(api/v1, api/v2)
- 엔드포인트 이름은 `블루프린트명.함수명`으로 충돌 방지

### 블루프린트별 정적/템플릿 분리(선택)

```python
site_bp = Blueprint(
    "site", __name__,
    template_folder="templates",
    static_folder="static",
    static_url_path="/site-static"
)
```

템플릿에서:

{% raw %}
```html
<link rel="stylesheet" href="{{ url_for('site.static', filename='css/site.css') }}">
```
{% endraw %}

### 공통 전/후 훅을 블루프린트에만 적용

```python
@api_v1.before_request
def api_guard():
    # 토큰 검사, 레이트 리미트 등
    ...

@api_v1.after_request
def api_headers(resp):
    resp.headers["X-API-Version"] = "v1"
    return resp
```

---

## 실전: 페이징 API + 링크 헤더 + 캐시/조건부

**목표**:
- `/api/v1/items?page=N&size=S`
- `Link` 헤더로 prev/next
- `Cache-Control` + `ETag`로 재검증
- `url_for`로 URL 생성

```python
from flask import request, jsonify, url_for
import hashlib

@api_v1.get("/items")
def list_items():
    page = request.args.get("page", 1, type=int)
    size = request.args.get("size", 20, type=int)
    # 실제로는 DB에서 page/size만큼 조회
    items = [{"id": i, "name": f"Item {i}"} for i in range((page-1)*size+1, page*size+1)]

    body = jsonify(items=items, page=page, size=size).get_data()
    etag = hashlib.md5(body).hexdigest()

    # 조건부 요청 처리
    inm = request.headers.get("If-None-Match")
    if inm and etag in inm:
        resp = make_response("", 304)
    else:
        resp = make_response(body, 200)
        resp.headers["Content-Type"] = "application/json; charset=utf-8"

    # 링크 헤더 구성
    def page_url(p):
        return url_for("api_v1.list_items", page=p, size=size, _external=True)

    links = []
    if page > 1:
        links.append(f'<{page_url(page-1)}>; rel="prev"')
    # 예시로 next는 항상 있다고 가정(실전은 total/has_next 계산)
    links.append(f'<{page_url(page+1)}>; rel="next"')
    resp.headers["Link"] = ", ".join(links)

    # 캐시
    resp.headers["Cache-Control"] = "public, max-age=30"
    resp.headers["ETag"] = etag
    resp.headers["Vary"] = "Accept-Encoding"
    return resp
```

> **운영 팁**: total count가 큰 경우, 카운트 쿼리를 매 요청 실행하지 말고 **최신성 희생/캐시** 또는 **Keyset Pagination**을 검토.

---

## 테스트 스니펫(응답/스트리밍/파일/캐시)

```python
def test_json_and_headers(client):
    r = client.get("/as-json")
    assert r.status_code == 200
    assert r.is_json
    assert "application/json" in r.headers["Content-Type"]

def test_streaming(client):
    r = client.get("/stream/gen")
    # 스트리밍은 direct passthrough라 테스트 환경에선 전부 모을 수도 있음
    assert r.status_code == 200
    assert b"start" in r.data

def test_send_file_304(client, monkeypatch, tmp_path):
    p = tmp_path / "a.txt"
    p.write_text("hello")
    # 첫 요청: 200
    r1 = client.get("/files/a.txt")
    assert r1.status_code == 200
    etag = r1.headers.get("ETag")
    # 두 번째: If-None-Match로 304
    r2 = client.get("/files/a.txt", headers={"If-None-Match": etag})
    assert r2.status_code == 304

def test_url_for_links(client):
    r = client.get("/build")
    data = r.get_json()
    assert "/users/" in data["user_url"]
    assert "/search" in data["q_url"]
```

---

## 운영 체크리스트

- [ ] 대용량 응답은 **스트리밍/압축** + 프록시 버퍼 전략 문서화
- [ ] 파일 전송은 가능하면 **리버스 프록시(X-Accel-Redirect/CloudFront)**로 오프로드
- [ ] 정적/다운로드는 **ETag/Last-Modified/Cache-Control**로 재검증 설계
- [ ] 동적 JSON은 **짧은 TTL + ETag** (DB 부하 완화)
- [ ] **Range** 지원 필요한 엔드포인트는 웹 서버 기능을 활용하거나 206 구현
- [ ] `url_for`로 **하드코딩 URL 제거**, 프록시 환경에서 절대 URL 정확성 검증
- [ ] 블루프린트 네임스페이스(버전/도메인)로 엔드포인트 충돌 방지
- [ ] `Vary` 헤더 관리(언어/인코딩/인증 헤더 등)로 **캐시 키 오염 방지**
- [ ] 응답 헤더/쿠키 보안 속성(HTTPS, HttpOnly, SameSite) 준수
- [ ] cURL/부하테스트 스크립트로 **재현 가능한 검증 루틴** 유지

---

## 흔한 안티패턴

- **send_file로 대용량 직접 전송**: 대규모 트래픽에서 병목 → **프록시 오프로드**
- **캐시 비활성/과도한 no-store**: 비용 증가/슬로우 → 재검증(304) 적극 활용
- **ETag를 무작위 값으로 매 요청 생성**: 항상 미스 → 해시/버전 기반으로 **안정성** 확보
- **URL 하드코딩**: 배포/프록시 변경 시 대량 수정 → `url_for` 습관화
- **모든 응답을 JSON으로 강제**: 파일/스트리밍/다운로드 케이스 고려 누락
- **SSE를 프록시 기본 설정대로**: 버퍼링되어 실시간성 붕괴 → 버퍼링 off 헤더/설정 필요

---

## 마무리

이 섹션에서는 **Response 생성 패턴 → 스트리밍(제너레이터/SSE) → 파일 전송(send_file/send_from_directory, X-Accel-Redirect, Range) → 조건부/캐시(ETag/Last-Modified/Cache-Control/Vary) → url_for로 URL 빌딩 → 블루프린트 네임스페이스/버전 전략**의 흐름을 실전 위주로 정리했다.
