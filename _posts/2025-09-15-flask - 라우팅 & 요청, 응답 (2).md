---
layout: post
title: flask - 라우팅 & 요청, 응답 (2)
date: 2025-09-15 23:25:23 +0900
category: flask
---
# 라우팅 & 요청/응답 (2)

## Flask Response 이해: 무엇을 반환할 수 있나?

Flask view 함수는 다양한 형태의 값을 반환할 수 있으며, Flask는 이를 적절한 HTTP 응답으로 자동 변환합니다.

1) **`str`/`bytes`/`dict`/`list`** → Flask가 자동으로 `Response` 객체로 변환
2) **(`response`, `status`)** 또는 **(`response`, `status`, `headers`)** 형식의 튜플
3) **`flask.Response`** 객체 직접 생성
4) **`jsonify(...)`** → JSON 형식의 `Response`
5) **`redirect(...)`**, **`send_file(...)`**, **`stream_with_context(...)`** 등의 헬퍼 함수

### 기본 응답 패턴

```python
from flask import Blueprint, jsonify, make_response, Response

bp = Blueprint("resp", __name__)

@bp.get("/basic-1")
def basic_1():
    return "OK"  # text/plain; charset=utf-8

@bp.get("/basic-2")
def basic_2():
    return {"ok": True, "version": 1}  # Flask 2.x+: 자동 JSON 직렬화

@bp.get("/basic-3")
def basic_3():
    return "Accepted", 202

@bp.get("/basic-4")
def basic_4():
    headers = {"X-App": "my-service"}
    return {"ok": True}, 200, headers

@bp.get("/basic-5")
def basic_5():
    # Response 객체 직접 생성: 세밀한 제어 가능
    resp = Response(b"binary", status=200, mimetype="application/octet-stream")
    resp.headers["X-Trace-Id"] = "abc-123"
    return resp

@bp.get("/basic-6")
def basic_6():
    # make_response: 어떤 반환값이든 Response 객체로 래핑
    resp = make_response({"message": "created"}, 201)
    resp.headers["Location"] = "/items/123"
    return resp
```

### JSON 응답

```python
from flask import jsonify

@bp.get("/as-json")
def as_json():
    # jsonify는 자동으로 Content-Type: application/json; charset=utf-8 설정
    # dict, 리스트, 키워드 인자 모두 안전한 JSON 인코딩 처리
    return jsonify(ok=True, items=[1, 2, 3])
```

> **팁**: 대용량 JSON 응답은 **압축(Gzip/Brotli)**과 **ETag/캐시** 전략을 함께 고려하세요.

---

## 스트리밍 응답: 대용량 데이터, 지연 생성, 실시간 푸시

스트리밍 응답은 **메모리 효율성**을 높이고 사용자에게 **빠른 최초 바이트(Time to First Byte)**를 제공합니다.

### 제너레이터 기반 스트리밍

```python
from flask import stream_with_context, Response, current_app
import time

@bp.get("/stream/gen")
def stream_gen():
    def generate():
        yield "start\n"
        for i in range(5):
            time.sleep(0.5)
            yield f"chunk {i}\n"
        yield "end\n"

    # stream_with_context: 요청 컨텍스트를 스트리머 함수에 전달
    gen = stream_with_context(generate())
    return Response(gen, mimetype="text/plain")
```

- **주의사항**: Nginx나 Cloudflare 같은 프록시/서버는 기본적으로 버퍼링할 수 있습니다. 실시간성을 보장하려면 `X-Accel-Buffering: no`(Nginx) 헤더 설정이나 SSE(Sendfile 비활성화) 등 별도 설정이 필요합니다.

### 대용량 CSV 파일 스트리밍

```python
import csv
from io import StringIO
from flask import Response

@bp.get("/export.csv")
def export_csv():
    def row_stream():
        # 헤더
        yield "id,name\n"
        # 실제 구현에서는 DB cursor나 iterable에서 데이터를 가져옴
        for i in range(1, 100_001):
            # 최소한의 가공만 하고 바로 내보냄
            yield f"{i},User {i}\n"

    return Response(
        row_stream(),
        mimetype="text/csv",
        headers={"Content-Disposition": "attachment; filename=export.csv"}
    )
```

> **제너레이터/반복자**를 사용하면 **메모리 사용량이 데이터 크기와 관계없이 일정**하게 유지됩니다.

### 실시간 푸시(Server-Sent Events)

```python
@bp.get("/events")
def sse():
    def event_stream():
        # SSE 프로토콜: "data: ..." 형식의 라인, 빈 줄로 이벤트 구분
        yield "retry: 1000\n"
        yield "event: hello\n"
        yield "data: world\n\n"
    resp = Response(stream_with_context(event_stream()), mimetype="text/event-stream")
    # Nginx 버퍼링 방지
    resp.headers["X-Accel-Buffering"] = "no"
    return resp
```

> 브라우저 JavaScript에서 사용: `const es = new EventSource('/events')`

---

## 파일 전송: `send_file`과 `send_from_directory`

### 기본 사용법

```python
from flask import send_file, send_from_directory
from pathlib import Path

DATA_DIR = Path("/data/files")

@bp.get("/files/<path:filename>")
def download(filename):
    # 디렉터리 안전성 확보: 허용된 경로 하위만 접근 가능
    return send_from_directory(
        DATA_DIR, filename,
        as_attachment=True,
        download_name=filename,  # Flask 2.0+: RFC5987 준수 안전 처리
        conditional=True         # ETag/Last-Modified 기반 304 응답 자동 처리
    )

@bp.get("/reports/pdf")
def report_pdf():
    path = DATA_DIR / "report.pdf"
    return send_file(
        path,
        mimetype="application/pdf",
        as_attachment=False,
        conditional=True
    )
```

- `conditional=True` → **If-None-Match/If-Modified-Since** 헤더를 자동으로 처리하여 304 응답 가능
- `as_attachment=True` + `download_name` → 파일 다운로드 대화상자 트리거

### 대용량 파일과 리버스 프록시(X-Accel-Redirect)

애플리케이션이 직접 대용량 파일을 읽어 전송하면 **CPU/IO 리소스가 낭비**됩니다. 이를 Nginx에 **오프로드**하는 것이 효율적입니다.

```python
@bp.get("/nginx-download/<path:filename>")
def nginx_accel(filename):
    # 내부 전용 경로로 Nginx에 파일 전송 위임
    resp = make_response("", 200)
    resp.headers["X-Accel-Redirect"] = f"/protected/{filename}"
    # Content-Type/Content-Disposition은 애플리케이션에서 설정
    resp.headers["Content-Type"] = "application/octet-stream"
    resp.headers["Content-Disposition"] = f'attachment; filename="{filename}"'
    return resp
```

Nginx 설정 예시:

```
location /protected/ {
    internal;
    alias /data/files/;
}
```

> 이 패턴은 **대용량 파일 고동시성 다운로드** 시나리오에서 성능 차이를 극적으로 만들 수 있습니다.

### 부분 다운로드(Range 요청) 구현

Flask는 `request.range`를 제공합니다. 간단한 **Partial Content(206)** 응답 구현 예시:

```python
from flask import request, abort

@bp.get("/video/<path:name>")
def video(name):
    file_path = DATA_DIR / name
    if not file_path.exists():
        abort(404)
    file_size = file_path.stat().st_size
    range_header = request.headers.get("Range")

    # 단일 범위만 처리(멀티 범위는 구현이 복잡함)
    if range_header:
        # 예: "bytes=0-1023"
        units, _, rng = range_header.partition("=")
        if units != "bytes":
            abort(416)
        start_s, _, end_s = rng.partition("-")
        start = int(start_s) if start_s else 0
        end = int(end_s) if end_s else file_size - 1
        if start > end or end >= file_size:
            abort(416)

        length = end - start + 1
        with open(file_path, "rb") as f:
            f.seek(start)
            data = f.read(length)
        resp = Response(
            data, 206,
            mimetype="video/mp4",
            headers={
                "Content-Range": f"bytes {start}-{end}/{file_size}",
                "Accept-Ranges": "bytes",
                "Content-Length": str(length)
            },
        )
        return resp

    # Range 헤더 없으면 전체 파일 전송
    return send_file(file_path, mimetype="video/mp4", conditional=True)
```

> 프로덕션 환경에서는 **웹 서버(Nginx/CloudFront)의 Range 지원 기능**을 활용하는 편이 안전하고 고성능입니다.

---

## 조건부 요청과 캐싱: ETag, Last-Modified, Cache-Control, Vary

### 왜 필요한가?

- **ETag/Last-Modified**로 클라이언트/프록시가 캐시 재검증 → **304 Not Modified** 응답으로 대역폭 절약
- **Cache-Control**로 브라우저/프록시 캐시 정책 제어
- **Vary**로 콘텐츠 협상 헤더(예: `Accept-Encoding`, `Accept-Language`)에 따라 캐시 키 분리

### ETag 수동 설정

```python
import hashlib
from flask import request

@bp.get("/items/<int:item_id>")
def item(item_id):
    # 실제 구현에서는 DB에서 데이터 조회
    payload = {"id": item_id, "name": f"Item {item_id}", "ver": 3}
    body = jsonify(payload).get_data()  # bytes로 변환
    etag = hashlib.sha256(body).hexdigest()

    # If-None-Match 헤더 검사
    inm = request.headers.get("If-None-Match")
    if inm and etag in inm:
        # 콘텐츠 변경 없음
        return "", 304, {"ETag": etag, "Cache-Control": "public, max-age=60"}

    return (
        body, 200,
        {
            "Content-Type": "application/json; charset=utf-8",
            "ETag": etag,
            "Cache-Control": "public, max-age=60"
        }
    )
```

- 실무에서는 **콘텐츠 버전이나 updated_at 타임스탬프**를 해시 입력에 포함시켜 **불필요한 계산을 줄이는** 것이 좋습니다.

### Last-Modified와 If-Modified-Since

```python
from datetime import datetime, timezone
from werkzeug.http import http_date, parse_date

@bp.get("/docs/<int:doc_id>")
def doc(doc_id):
    # 예시: DB의 updated_at 값
    updated_at = datetime(2025, 10, 1, 12, 0, tzinfo=timezone.utc)
    ims = request.headers.get("If-Modified-Since")
    if ims:
        dt = parse_date(ims)
        # 변경 시각이 같거나 이후면 변경 없음
        if dt and updated_at <= dt.replace(tzinfo=timezone.utc):
            return "", 304, {
                "Last-Modified": http_date(updated_at),
                "Cache-Control": "public, max-age=120"
            }

    return (
        {"id": doc_id, "content": "..."}, 200,
        {
            "Last-Modified": http_date(updated_at),
            "Cache-Control": "public, max-age=120"
        }
    )
```

> `send_file(..., conditional=True)`를 사용하면 파일의 ETag/Last-Modified 처리를 **자동**으로 지원합니다.

### 캐시 정책 설계 가이드라인

- **정적 파일**: `Cache-Control: public, max-age=31536000, immutable` + **버전 해시**(파일명/쿼리 파라미터)
- **동적 JSON API**: 짧은 TTL + ETag/Last-Modified 재검증
- **민감한 데이터**: `Cache-Control: no-store`
- **압축 응답**: Nginx에서 Gzip/Brotli 처리, `Vary: Accept-Encoding` 헤더 추가

```python
@bp.get("/cache-demo")
def cache_demo():
    resp = jsonify(ok=True)
    resp.headers["Cache-Control"] = "public, max-age=60"
    resp.headers["Vary"] = "Accept-Encoding"
    return resp
```

---

## 응답 헤더, 쿠키, 파일명 국제화 요약

### 다운로드 파일명 처리

```python
@bp.get("/i18n-file")
def i18n_file():
    # Flask 2.0+부터 send_file의 download_name이 Content-Disposition 인코딩을 안전하게 처리
    return send_file(
        DATA_DIR / "보고서.pdf",
        as_attachment=True,
        download_name="보고서_2025Q4.pdf",
        conditional=True
    )
```

### 쿠키 설정

```python
from flask import make_response

@bp.get("/set-cookie")
def set_cookie():
    resp = make_response({"ok": True})
    resp.set_cookie(
        "sid", "s-1",
        max_age=3600,
        httponly=True, secure=True, samesite="Lax", path="/"
    )
    return resp
```

---

## URL 빌딩: `url_for` 완벽 가이드

`url_for(endpoint, **values)`는 **라우트에 등록된 엔드포인트 이름**으로 URL을 역방향 생성합니다.

### 기본 사용과 쿼리 파라미터

```python
from flask import url_for

@bp.get("/build")
def build():
    # 엔드포인트는 기본적으로 "블루프린트명.함수명"
    user_url = url_for("resp.user_detail", user_id=7)
    # 쿼리 파라미터는 경로 변수가 아닌 키워드 인자로 전달 시 자동 추가
    q_url = url_for("resp.search", q="flask", page=2)
    return {"user_url": user_url, "q_url": q_url}

@bp.get("/users/<int:user_id>")
def user_detail(user_id): ...
@bp.get("/search")
def search(): ...
```

### 절대 URL과 스킴 지정

```python
@bp.get("/abs")
def abs_url():
    # _external=True → 스킴과 호스트를 포함한 절대 URL 생성
    # _scheme="https"로 강제 지정 가능(프록시/X-Forwarded-* 설정 필요)
    return {
        "self": url_for("resp.abs_url", _external=True),
        "doc": url_for("resp.doc", doc_id=10, _external=True, _scheme="https")
    }
```

> **프록시 환경**에서 절대 URL이 올바르게 생성되려면 Nginx가 `X-Forwarded-Proto` 등을 설정하고, Flask가 이를 신뢰하도록 ProxyFix 미들웨어 또는 동등한 설정이 필요합니다.

### URL 버전닝을 위한 네임스페이스 분리

- **버전별 블루프린트**: `/api/v1`, `/api/v2`로 분리
- 엔드포인트 충돌 없이 **명시적 네임스페이스** 유지

```python
from flask import Blueprint

api_v1 = Blueprint("api_v1", __name__, url_prefix="/api/v1")
api_v2 = Blueprint("api_v2", __name__, url_prefix="/api/v2")

@api_v1.get("/items/<int:id>")
def v1_item(id): ...
@api_v2.get("/items/<int:id>")
def v2_item(id): ...

@bp.get("/links")
def links():
    return {
        "v1": url_for("api_v1.v1_item", id=1, _external=True),
        "v2": url_for("api_v2.v2_item", id=1, _external=True),
    }
```

---

## 블루프린트 기반 네임스페이스 설계와 폴더 구조

### 권장 프로젝트 구조

```
app/
├─ __init__.py           # create_app 팩토리 함수
├─ config.py
├─ extensions.py
├─ blueprints/
│  ├─ __init__.py
│  ├─ site/              # 웹 페이지(HTML 템플릿)
│  │  ├─ __init__.py     # site_bp = Blueprint("site", __name__)
│  │  ├─ views.py
│  │  └─ templates/...
│  ├─ api/
│  │  ├─ __init__.py     # api_bp = Blueprint("api", __name__, url_prefix="/api")
│  │  ├─ v1/
│  │  │  ├─ __init__.py  # api_v1 = Blueprint("api_v1", __name__, url_prefix="/api/v1")
│  │  │  ├─ resources.py
│  │  │  └─ schemas.py
│  │  └─ v2/...
│  └─ assets/
│     ├─ __init__.py     # 정적 파일/업로드/다운로드 관련
│     └─ files.py
└─ templates/
```

- **도메인별 블루프린트**(site, api, assets 등)
- **버전별 하위 블루프린트**(api/v1, api/v2)
- 엔드포인트 이름은 `블루프린트명.함수명` 형식으로 충돌 방지

### 블루프린트별 정적 파일과 템플릿 분리

```python
site_bp = Blueprint(
    "site", __name__,
    template_folder="templates",
    static_folder="static",
    static_url_path="/site-static"
)
```

템플릿에서 사용:

{% raw %}
```html
<link rel="stylesheet" href="{{ url_for('site.static', filename='css/site.css') }}">
```
{% endraw %}

### 블루프린트별 전후 훅 적용

```python
@api_v1.before_request
def api_guard():
    # 토큰 검증, 레이트 리미트 등 공통 인증/인가 로직
    ...

@api_v1.after_request
def api_headers(resp):
    resp.headers["X-API-Version"] = "v1"
    return resp
```

---

## 실전 예제: 페이징 API + 링크 헤더 + 캐시/조건부 요청

**구현 목표**:
- `/api/v1/items?page=N&size=S` 형태의 페이징 API
- `Link` 헤더로 이전/다음 페이지 네비게이션 제공
- `Cache-Control` + `ETag`로 효율적인 캐시 재검증
- `url_for`를 활용한 안전한 URL 생성

```python
from flask import request, jsonify, url_for, make_response
import hashlib

@api_v1.get("/items")
def list_items():
    page = request.args.get("page", 1, type=int)
    size = request.args.get("size", 20, type=int)
    # 실제 구현에서는 DB에서 page/size만큼 조회
    items = [{"id": i, "name": f"Item {i}"} for i in range((page-1)*size+1, page*size+1)]

    body = jsonify(items=items, page=page, size=size).get_data()
    etag = hashlib.md5(body).hexdigest()

    # 조건부 요청 처리
    inm = request.headers.get("If-None-Match")
    if inm and etag in inm:
        resp = make_response("", 304)
    else:
        resp = make_response(body, 200)
        resp.headers["Content-Type"] = "application/json; charset=utf-8"

    # 링크 헤더 구성 (HATEOAS)
    def page_url(p):
        return url_for("api_v1.list_items", page=p, size=size, _external=True)

    links = []
    if page > 1:
        links.append(f'<{page_url(page-1)}>; rel="prev"')
    # 예시로 next는 항상 있다고 가정(실전에서는 total/has_next 계산 필요)
    links.append(f'<{page_url(page+1)}>; rel="next"')
    resp.headers["Link"] = ", ".join(links)

    # 캐시 헤더 설정
    resp.headers["Cache-Control"] = "public, max-age=30"
    resp.headers["ETag"] = etag
    resp.headers["Vary"] = "Accept-Encoding"
    return resp
```

> **운영 팁**: total count가 매우 큰 경우, 매 요청마다 count 쿼리를 실행하지 말고 **캐시된 카운트**를 사용하거나 **Keyset Pagination** 방식을 검토하세요.

---

## 테스트 코드 예시

```python
def test_json_and_headers(client):
    r = client.get("/as-json")
    assert r.status_code == 200
    assert r.is_json
    assert "application/json" in r.headers["Content-Type"]

def test_streaming(client):
    r = client.get("/stream/gen")
    # 스트리밍 응답은 직접 전송되므로 테스트 환경에서는 전체 데이터를 모을 수 있음
    assert r.status_code == 200
    assert b"start" in r.data

def test_send_file_304(client, monkeypatch, tmp_path):
    p = tmp_path / "a.txt"
    p.write_text("hello")
    # 첫 번째 요청: 200 응답
    r1 = client.get("/files/a.txt")
    assert r1.status_code == 200
    etag = r1.headers.get("ETag")
    # 두 번째 요청: If-None-Match 헤더로 304 응답
    r2 = client.get("/files/a.txt", headers={"If-None-Match": etag})
    assert r2.status_code == 304

def test_url_for_links(client):
    r = client.get("/build")
    data = r.get_json()
    assert "/users/" in data["user_url"]
    assert "/search" in data["q_url"]
```

---

## 결론

이번 섹션에서는 Flask의 응답 처리 메커니즘을 깊이 있게 다루었습니다. 기본적인 Response 생성부터 시작하여, 대용량 데이터 처리를 위한 스트리밍 응답, 효율적인 파일 전송 전략, 캐싱과 조건부 요청을 통한 성능 최적화까지 실전에 바로 적용할 수 있는 패턴들을 살펴보았습니다.

특히 `url_for`를 활용한 안전한 URL 생성과 블루프린트 기반의 모듈화 아키텍처는 확장 가능한 애플리케이션을 구축하는 데 필수적입니다. 각 기술을 단독으로 사용하는 것보다, 스트리밍과 캐싱을 조합하거나 파일 전송에 조건부 요청을 적용하는 식으로 통합적으로 접근할 때 진정한 성능 향상을 기대할 수 있습니다.

실제 프로덕션 환경에서는 이러한 기술들이 프록시 서버(Nginx, CloudFront)와 어떻게 상호작용하는지 이해하는 것이 중요합니다. 적절한 헤더 설정과 서버 구성이 결합될 때 비로소 최적의 사용자 경험과 시스템 성능을 달성할 수 있습니다.