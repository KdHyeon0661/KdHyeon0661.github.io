---
layout: post
title: Linux - 하드웨어 인터페이스 제어
date: 2024-12-06 19:20:23 +0900
category: Linux
---
# USB, 블루투스, 전원관리

## 전체 아키텍처 개요

리눅스 시스템의 하드웨어 관리는 여러 계층으로 구성된 아키텍처를 통해 이루어집니다:

- **커널**: 드라이버가 장치를 감지하면 **uevent**(add/remove/change) 발생
- **systemd-udevd**: uevent 수신 → **/dev 노드 생성/권한/링크/룰 실행**
- **BlueZ**: 커널 btusb(hci) 위에서 동작하는 **블루투스 스택**
- **upowerd**: 커널/드라이버로부터 전원 정보 수집 → **D-Bus API** 제공
- **acpid**: ACPI 이벤트(버튼/뚜껑/슬립 등)를 **스크립트와 매핑**
- **systemd-logind**: 전원 키/뚜껑 정책(로그아웃, 슬립 등) 기본 처리. **acpid와 병행 시 우선순위/정책 충돌** 주의
- **전력관리 툴**: TLP/powertop/auto-suspend/CPU governor/ASPM/ALPM → 실사용 전력 최적화

---

## udev — 장치 이벤트 감지/자동화 심화

### 핵심 개념

- **룰 파일 위치**:
  - 배포판 기본: `/usr/lib/udev/rules.d/*.rules`
  - 관리자 추가/덮어쓰기: `/etc/udev/rules.d/*.rules` (번호가 클수록 나중 적용)
- **매치 키**: `ACTION`, `KERNEL`, `SUBSYSTEM`, `DRIVER`, `ATTR{}`, `ATTRS{}`, `ENV{}` 등
- **할당 키**: `NAME`, `SYMLINK`, `OWNER`, `GROUP`, `MODE`, `TAG+=`, `ENV{}` set, `RUN+=` 등
- **컨텍스트**: RUN 스크립트는 **root 권한 + 매우 제한된 환경변수**로 실행. **PATH 가정 금지**, 절대경로 사용

### 장치 탐색/디버그

```bash
# 장치 트리/속성 보기
udevadm info -a -p $(udevadm info -q path -n /dev/sdb)

# 실시간 이벤트 모니터(환경변수 포함)
udevadm monitor --udev --kernel --property

# 특정 장치에 규칙 테스트(실행은 안 하고 규칙 평가만)
sudo udevadm test /sys/block/sdb
```

### 룰 작성 패턴

```udev
# /etc/udev/rules.d/70-myusb-label.rules

ACTION=="add", SUBSYSTEM=="block", KERNEL=="sd?1", \
  ENV{ID_FS_UUID}=="1A2B-3C4D", ENV{ID_FS_TYPE}=="vfat", \
  SYMLINK+="backup_usb", MODE="0660", GROUP="backup", \
  ENV{MY_BACKUP}="1", RUN+="/usr/local/sbin/usb-backup.sh %E{ID_FS_UUID}"
```

- `KERNEL=="sd?1"`: 파티션1만 대상
- `ENV{ID_FS_UUID}`: udev가 파싱한 파일시스템 UUID
- `SYMLINK`: `/dev/backup_usb` 생성(동시에 `/dev/sdX1` 존재)
- `RUN`에 **절대경로** + 인자 전달은 `%E{VAR}` 형태로

> **안전 수칙**:
> - `RUN+=` 스크립트는 **짧게 유지**(mount/rsync 같은 무거운 작업은 systemd 서비스로 넘기기 권장)
> - 장시간 실행 필요 시 `ENV{SYSTEMD_WANTS}="my@%E{ID_FS_UUID}.service"` 패턴으로 **systemd**에 위임

### udev → systemd 연계(권장)

**룰**:
```udev
# /etc/udev/rules.d/80-backup-wants.rules

ACTION=="add", SUBSYSTEM=="block", ENV{ID_FS_UUID}=="dead-beef-1234", \
  ENV{SYSTEMD_WANTS}="usb-backup@%E{ID_FS_UUID}.service"
```

**템플릿 서비스**:
```ini
# /etc/systemd/system/usb-backup@.service

[Unit]
Description=USB backup for UUID %i
Requires=dev-disk-by\x2duuid-%i.device
After=dev-disk-by\x2duuid-%i.device

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/usb-backup.sh %i

[Install]
WantedBy=multi-user.target
```

- 장치 의존성을 systemd가 보장하여 **중복 실행/경합** 감소

### 대표 시나리오 3선

**(1) 특정 USB-UART(예: CH340/CP210x) 포트에 고정 심볼릭링크 부여**
```udev
# /etc/udev/rules.d/99-serial.rules

SUBSYSTEM=="tty", ATTRS{idVendor}=="1a86", ATTRS{idProduct}=="7523", \
  SYMLINK+="tty.sensors", MODE="0660", GROUP="dialout"
```
→ 언제나 `/dev/tty.sensors` 로 접근 가능

**(2) USB 카메라(영상 캡처) 권한/그룹 부여**
```udev
# /etc/udev/rules.d/60-camera.rules

SUBSYSTEM=="video4linux", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="0825", \
  GROUP="video", MODE="0660"
```

**(3) USB 삽입 → 자동 마운트 + 백업**
- udisks2 호출(비루트 마운트 가능) or `SYSTEMD_WANTS`로 서비스에 위임
```bash
# /usr/local/sbin/usb-backup.sh
#!/usr/bin/env bash

set -euo pipefail
uuid="${1:?uuid required}"
mnt="/mnt/usb-${uuid}"
mkdir -p "$mnt"
mount -o nosuid,nodev,noexec,uid=1000,gid=1000 "/dev/disk/by-uuid/$uuid" "$mnt"
rsync -a --delete /home/user/Documents/ "$mnt/backup/Documents/"
umount "$mnt"
```
> 마운트 옵션에 **nosuid,nodev,noexec**로 공격면 축소

### 룰 우선순위/충돌

- 파일명 앞 숫자(예 `60-*.rules`)로 대략 순서 결정
- 동일 키 할당의 **덮어쓰기/추가(`+=`)** 동작 주의
- 배포판 기본 룰을 그대로 편집하지 말고 `/etc/udev/rules.d` 에 **오버라이드** 작성

---

## 블루투스 — BlueZ, bluetoothctl, 오디오 프로파일(A2DP/HFP)

### 필수 도구

```bash
sudo apt install -y bluez bluez-tools # Debian/Ubuntu
# 서비스
sudo systemctl enable --now bluetooth
```

### rfkill/어댑터 상태

```bash
rfkill list        # soft/hard block?
sudo rfkill unblock bluetooth
bluetoothctl show  # 어댑터 정보, Powered/Discoverable/Pairable 등
```

### 페어링/신뢰/연결 절차(bluetoothctl)

```text
bluetoothctl
[bluetooth]# power on
[bluetooth]# agent on
[bluetooth]# default-agent
[bluetooth]# scan on                # 기기 MAC 파악
[bluetooth]# pair XX:XX:XX:XX:XX:XX
[bluetooth]# trust XX:XX:XX:XX:XX:XX
[bluetooth]# connect XX:XX:XX:XX:XX:XX
[bluetooth]# info XX:XX:...         # 서비스/프로파일 확인
```

- 오디오: **A2DP**(고음질, 출력 전용), **HSP/HFP**(마이크 포함, 통화용)
- PulseAudio/PipeWire 환경에서 **프로파일 전환** 필요할 수 있음(사운드 설정 GUI 또는 `pactl`, `wpctl`)

### 자동 연결 스크립트(간단)

```bash
#!/usr/bin/env bash

dev="XX:XX:XX:XX:XX:XX"
bluetoothctl <<EOF
power on
connect $dev
EOF
```

### 문제 해결 팁

- dmesg에서 btusb 에러 확인: `dmesg | grep -i bt`
- 펌웨어 필요 사례: `/lib/firmware/` 확인(배포판 패키지 설치)
- **오디오 지연**: PipeWire/PulseAudio 버퍼/프로파일 조정
- **다중 페어링 충돌**: 기존 페어링 삭제 후 재페어링(`remove <MAC>`)

---

## upower — 배터리/어댑터 상태, D-Bus 연동

### 기본 사용

```bash
upower -e                         # 디바이스 나열
upower -i /org/freedesktop/UPower/devices/battery_BAT0
upower -d                         # 전체 덤프
upower --monitor                  # 변경 이벤트 실시간
```

출력 핵심: `state`(charging/discharging), `percentage`, `time to empty/full`, `energy`, `energy-full-design`, `cycle count` 등

### D-Bus로 직접 질의(예: busctl)

```bash
# 디바이스 찾기
busctl tree org.freedesktop.UPower
busctl get-property org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower OnBattery
```

### 배터리 잔량/ETA 계산(원리)

- upower가 내부적으로 **전력(W)**과 **에너지(Wh)**를 통해 시간 예측
  남은 시간 \(T\) (시간) 근사:
$$
T \approx \frac{E_{\text{remain}}}{P_{\text{avg}}}
$$
- 사용자가 직접 측정 시, 샘플 윈도우의 평균 전력으로 추정

### 예: 20% 이하 알림(데스크탑)

```bash
#!/usr/bin/env bash

bat=$(upower -e | grep battery | head -n1)
pct=$(upower -i "$bat" | awk '/percentage/ {gsub("%","",$2); print $2}')
state=$(upower -i "$bat" | awk -F: '/state/ {gsub(/ /,"",$2); print $2}')
if [[ "$state" == "discharging" && "$pct" -le 20 ]]; then
  notify-send "배터리 경고" "잔량 ${pct}% (충전 필요)"
fi
```

---

## acpid — 전원/버튼/뚜껑/슬립 이벤트 처리

### 설치/기본

```bash
sudo apt install -y acpid
sudo systemctl enable --now acpid
tail -f /var/log/acpid
```

### 이벤트 파일

- 디렉터리: `/etc/acpi/events/`
- **형식**:
```ini
# /etc/acpi/events/powerbtn
event=button/power
action=/etc/acpi/powerbtn.sh
```

```bash
#!/usr/bin/env bash
# /etc/acpi/powerbtn.sh
logger "ACPI power button pressed -> graceful shutdown"
systemctl poweroff
```

**뚜껑 닫힘 예시**:
```ini
# /etc/acpi/events/lid
event=button/lid.*
action=/etc/acpi/lid.sh
```

```bash
#!/usr/bin/env bash

state=$(awk '{print $2}' /proc/acpi/button/lid/*/state 2>/dev/null | head -n1)
if [[ "$state" == "closed" ]]; then
  logger "LID closed -> suspend"
  systemctl suspend
fi
```

> **logind와 정책 충돌 주의**: `logind.conf` 의 `HandleLidSwitch`, `HandlePowerKey`가 우선 처리할 수 있음
> 원하는 정책만 남기고 나머지는 `ignore`로 설정:
```ini
# /etc/systemd/logind.conf
HandlePowerKey=ignore
HandleLidSwitch=ignore
```
```bash
sudo systemctl restart systemd-logind
```

---

## 전력 최적화 — USB AutoSuspend, CPU governor, PCIe ASPM, SATA ALPM, TLP/powertop

### USB AutoSuspend

```bash
# 장치별 현재 상태
for f in /sys/bus/usb/devices/*/power/control; do echo "$f: $(cat $f)"; done

# 특정 장치 절전 활성화(on 또는 auto)
echo auto | sudo tee /sys/bus/usb/devices/1-2/power/control
```
- **주의**: 일부 입력장치(마우스/키보드) autosuspend 시 **깨어나지 않는 문제** → 화이트리스트로 제외

### CPU 주파수/거버너

```bash
sudo apt install -y linux-tools-common linux-tools-$(uname -r)
cpupower frequency-info
sudo cpupower frequency-set -g powersave
```
- 거버너: `performance` / `powersave` / `schedutil` 등
- **서버**는 성능 우선, **노트북**은 배터리 상황에 맞춰 동적 조정

### PCIe ASPM, SATA ALPM

- 커널 부팅 파라미터: `pcie_aspm=force`(하드웨어 지원 확인 필요)
- SATA Link Power Management(ALPM): `/sys/class/scsi_host/host*/link_power_management_policy`(`min_power`, `med_power_with_dipm`, `max_performance`)
```bash
echo med_power_with_dipm | sudo tee /sys/class/scsi_host/host0/link_power_management_policy
```
> 특정 SSD/HBA와의 **호환성** 반드시 검증(데이터 무결성 우선)

### powertop / TLP

```bash
sudo apt install -y powertop tlp
sudo powertop --auto-tune            # 즉시 절전 추천 적용(일시적)
sudo systemctl enable --now tlp
sudo tlp-stat -s                      # 상태 요약
```
- **TLP**: `/etc/tlp.conf` 에서 **AC/배터리별 정책**(USB autosuspend, wifi pwr, cpu governor, disk apm 등) 세밀 제어
- powertop의 자동튜닝은 **재부팅 시 초기화**되므로 상시적용은 TLP에 반영 권장

---

## 슬립(suspend)/하이버네이트(hibernate)/하이브리드

### 개념

- **Suspend to RAM (S3/s2idle)**: 메모리를 유지, 빠른 복귀. 배터리 소모 적당
- **Hibernate (S4)**: 메모리 내용을 스왑(디스크)에 저장 후 전원 차단 → 배터리 거의 소모 X
- **Hybrid**: RAM 유지 + 디스크 백업. 정전에도 안전, 복귀는 빠름

### 설정/실행

```bash
# 일회성
systemctl suspend
systemctl hibernate
systemctl hybrid-sleep
```
- 하이버네이트는 **스왑 크기** ≥ **RAM 사용량** 필요 + 커널 파라미터 `resume=` 설정 필요
  예: `/etc/default/grub` 의 `GRUB_CMDLINE_LINUX="resume=UUID=<swap-uuid>"` → `update-grub`

### s2idle vs deep(근래의 노트북)

- `/sys/power/mem_sleep` 확인:
```bash
cat /sys/power/mem_sleep
# [s2idle] deep
```
- `deep`가 더 저전력이나, 하드웨어/드라이버 호환성 따라 깨움 이슈 있을 수 있음 → 배포/BIOS 업데이트 확인

---

## 하드웨어 이벤트 통합 워크플로우 — 예제 프로젝트

### 요구사항

- **USB 특정 스틱** 삽입 시 **암호화 볼륨(LUKS)** 자동 해제 → `/backup`에 마운트 → rsync 백업
- 배터리 15% 이하이고 방전 중이면 **백업 중단** 후 경고
- 전원 버튼은 **하이브리드 슬립**으로 동작

### 구성

**udev 룰**(장치 인식 → systemd 서비스 호출):
```udev
# /etc/udev/rules.d/80-backup-stick.rules

ACTION=="add", SUBSYSTEM=="block", ENV{ID_FS_UUID}=="ABCD-1234", \
  ENV{SYSTEMD_WANTS}="backup-stick@%E{ID_FS_UUID}.service"
```

**systemd 템플릿 서비스**(암호해제/백업):
```ini
# /etc/systemd/system/backup-stick@.service

[Unit]
Description=Backup stick workflow for %i
After=systemd-udevd.service

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/backup-stick.sh %i
TimeoutSec=0

[Install]
WantedBy=multi-user.target
```

**백업 스크립트**:
```bash
#!/usr/bin/env bash
# /usr/local/sbin/backup-stick.sh

set -euo pipefail
uuid="${1:?}"
mapper="backup-${uuid}"
dev="/dev/disk/by-uuid/${uuid}"
mnt="/backup"

# 배터리 체크(방전+15%이하면 종료)
bat=$(upower -e | grep battery | head -n1 || true)
if [[ -n "$bat" ]]; then
  pct=$(upower -i "$bat" | awk '/percentage/ {gsub("%","",$2); print $2}')
  state=$(upower -i "$bat" | awk -F: '/state/ {gsub(/ /,"",$2); print $2}')
  if [[ "$state" == "discharging" && "${pct:-100}" -le 15 ]]; then
    logger "Battery low(${pct}%), abort backup"
    exit 0
  fi
fi

# LUKS 해제(키파일 또는 키에이전트 사용)
cryptsetup open "$dev" "$mapper" --key-file /root/backup.key
mkdir -p "$mnt"
mount -o nosuid,nodev,noexec "/dev/mapper/$mapper" "$mnt"

# rsync
rsync -a --delete /home/user/ "$mnt/home.user/"
sync

umount "$mnt"
cryptsetup close "$mapper"
logger "USB backup done"
```

**acpid 전원 버튼**:
```ini
# /etc/acpi/events/powerbtn
event=button/power
action=/etc/acpi/powerbtn.sh
```

```bash
#!/usr/bin/env bash
logger "power button -> hybrid sleep"
systemctl hybrid-sleep
```

**logind 정책 충돌 회피**:
```ini
# /etc/systemd/logind.conf
HandlePowerKey=ignore
```
```bash
sudo systemctl restart systemd-logind
```

---

## 빠른 참고 명령 모음

```bash
# udev
udevadm info /dev/sdb
udevadm monitor --udev --kernel --property
sudo udevadm control --reload-rules && sudo udevadm trigger

# 블루투스
rfkill list
bluetoothctl power on; bluetoothctl scan on
bluetoothctl pair/connect/trust <MAC>

# 전원/배터리
upower -e
upower -i /org/freedesktop/UPower/devices/battery_BAT0
upower --monitor

# ACPI 이벤트
sudo systemctl status acpid
tail -f /var/log/acpid

# 전력 튜닝
sudo powertop --auto-tune
sudo tlp start; sudo tlp-stat -s
cpupower frequency-info
```

---

## 부록: 수식으로 보는 배터리 예측(간단 모델)

샘플링 윈도우에서 평균 전력 \(P_{\text{avg}}\)(W)과 현재 잔여 에너지 \(E_{\text{remain}}\)(Wh) 를 추정하면,
예상 잔여 시간 \(T\)(시간)는
$$
T \approx \frac{E_{\text{remain}}}{P_{\text{avg}}}.
$$

전력 측정이 잡음이 크면 **지터 감소를 위해 지수이동평균(EMA)** 로 \(P_{\text{avg}}\) 를 갱신:
$$
P_{\text{avg}}^{(t)} = \alpha \, P_{\text{inst}}^{(t)} + (1-\alpha) \, P_{\text{avg}}^{(t-1)}, \quad 0<\alpha\le 1.
$$

---

## 결론

리눅스 시스템에서 USB, 블루투스, 전원 관리는 다양한 계층의 도구와 서비스가 협력하는 복잡한 생태계입니다. 효과적인 관리를 위해 다음 원칙들을 기억하세요:

**시스템 아키텍처 이해**:
- 각 구성 요소(udev, BlueZ, upower, acpid, systemd-logind)의 역할과 상호작용을 명확히 이해
- 특히 acpid와 systemd-logind 사이의 정책 충돌을 인식하고 적절히 조정

**udev를 통한 체계적인 자동화**:
- 장치 이벤트 감지와 처리를 udev 규칙으로 표준화
- 장시간 작업은 systemd 서비스로 위임하여 안정성 확보
- 마운트 옵션에 보안 고려사항(nosuid,nodev,noexec) 포함

**블루투스 통합 관리**:
- rfkill을 통한 블록 상태 관리 숙지
- 다양한 오디오 프로파일(A2DP/HFP)의 특성 이해
- 펌웨어와 드라이버 호환성 확인

**전원 관리 최적화**:
- upower를 통한 배터리 상태 모니터링 및 알림 시스템 구축
- USB AutoSuspend, CPU 거버너, ASPM/ALPM을 활용한 전력 절감
- TLP/powertop와 같은 자동화 도구로 지속적인 최적화

**슬립/하이버네이트 전략**:
- 사용 패턴과 하드웨어 호환성에 맞는 절전 모드 선택
- 하이버네이트를 위한 스왑 공간과 커널 설정 준비
- s2idle vs deep sleep 모드의 장단점 이해

**안전성과 보안 고려사항**:
- USB 장치 마운트 시 보안 옵션 적용
- 블루투스 불필요한 Discoverable 모드 비활성화
- 배터리 임계값 기반 자동 조치 구현

이러한 구성 요소들을 체계적으로 이해하고 통합하면, 하드웨어 자동화부터 전력 효율 최적화까지 종합적인 시스템 관리가 가능해집니다. 각 환경의 특수한 요구사항에 맞게 도구와 설정을 조정하고, 지속적인 모니터링과 튜닝을 통해 최적의 사용자 경험과 시스템 안정성을 달성할 수 있습니다.