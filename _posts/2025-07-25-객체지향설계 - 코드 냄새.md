---
layout: post
title: 객체지향설계 - 코드 냄새
date: 2025-07-25 21:20:23 +0900
category: 객체지향설계
---
# 코드 냄새(Code Smell)

## 0. 개요 — 코드 냄새란?

**코드 냄새(Code Smell)** 는 당장은 버그가 아니어도 **유지보수·확장·성능·보안**에 악영향을 줄 **잠재적 위험 신호**다.  
냄새는 “문제의 증상”이며, 치료법은 **리팩토링**이다. 정적 분석기가 일부 포착하지만, **맥락**과 **경험**이 결정적이다.

---

## 1. 왜 중요한가 — 비용 곡선과 회귀 위험

- 냄새가 누적되면 **변경 비용**이 비선형적으로 증가한다.  
- 리팩토링 없이 기능만 추가하면 **회귀 버그**·**지연된 장애**로 비용이 폭증한다.  
- “냄새→테스트→리팩토링” 루프는 **지속적 설계 개선**의 핵심 루틴이다.

---

## 2. 분류 체계(확장)

| 범주 | 대표 냄새 | 핵심 위험 | 1차 처방 |
|---|---|---|---|
| **코드** | 긴 메서드, 거대한 클래스, 중복 코드, 긴 매개변수 목록, 조건문 폭발, 임시 필드, 메시지 체인, 불필요한 주석, 매직 넘버 | 가독성↓, 결합도↑ | Extract/Move/Introduce Object, Polymorphism |
| **설계** | 갓 클래스, Shotgun Surgery, Divergent Change, Inappropriate Intimacy, Refused Bequest, Speculative Generality | 변경 충격↑, LSP/SRP 위반 | 경계 재설계, 합성 우선, 역할 분리 |
| **아키텍처** | Big Ball of Mud, 분산 모놀리스, 프레임워크 누수, 서비스 로케이터 | 독립 배포 불가, 테스트성↓ | 레이어링, 포트/어댑터, DI |
| **데이터/DB** | N+1, SELECT *, EAV 남용, 카디널리티 폭발 | 성능/일관성 문제 | 페치 전략, 스키마 정규화, DTO |
| **테스트** | 플래키, 슬리핑 테스트, 취약 테스트, 과도 목 | 거짓 양성/음성 | 계약/BDD, 가짜 클록, 통합테스트 보강 |
| **보안** | 하드코딩 비밀, 자체 암호, PII 로그 | 유출/규제 리스크 | 시크릿 매니저, 검증 라이브러리, 마스킹 |
| **프론트/UI** | 거대 컴포넌트, Prop Drilling, 상태 남용, 인라인 스타일 남발 | 성능/재사용성↓ | 분할, 컨텍스트/상태 아키텍처 정리 |

---

## 3. 대표 냄새 18선 — 징후·원인·처방·예제

### 3.1 긴 메서드(Long Method)
- **징후**: 수십~수백 줄, 조건·루프 중첩.
- **원인**: 여러 책임 혼재.
- **처방**: **Extract Method**, 의미 있는 이름으로 단계 나누기, **Introduce Parameter Object**.

```java
// Before
void processOrder(Order o){
  if(o==null || o.items().isEmpty()) throw new IllegalArgumentException();
  long total=0; for(var i: o.items()) total += i.price()*i.qty();
  if(o.coupon()!=null) total = Math.round(total*0.9);
  repo.save(o.withTotal(total)); mail.send(o.customer(), total);
}

// After
void processOrder(Order o){
  validate(o);
  long total = applyDiscounts(calculateTotal(o), o);
  persistAndNotify(o, total);
}
```

---

### 3.2 거대한 클래스(God/Large Class)
- **징후**: 다수의 필드/메서드, 비즈니스·인프라 로직 혼재.
- **처방**: **Extract Class**, **Facade**, 책임 재배치.

```java
class ReportFacade {
  private final DataFetcher fetcher; private final Calculator calc;
  private final PdfRenderer pdf; private final Mailer mail;
  void run(){ var d=fetcher.fetch(); var r=calc.run(d); var b=pdf.render(r); mail.send(b); }
}
```

---

### 3.3 중복 코드(Duplicate Code)
- **징후**: 비슷한 로직 다수.
- **처방**: **Extract Method/Template Method**, 공통 유틸 또는 전략화.

---

### 3.4 긴 매개변수 리스트(Long Parameter List)
- **징후**: 5개 이상 인자, 불리언 플래그 다수.
- **처방**: **Parameter Object**, **Builder**.

```csharp
// Before
CreateUser(name, email, address, phone, subscribed, marketingOptIn);

// After
var spec = new UserCreateSpec(name, email, address, phone)
              .WithSubscriptions(subscribed, marketingOptIn);
CreateUser(spec);
```

---

### 3.5 조건문 폭발(Complex Conditional / Repeated Switch)
- **징후**: 중첩 if/switch, 제품군별 분기 반복.
- **처방**: **Strategy/State/Polymorphism**, 룰 엔진.

```java
interface FeePolicy{ long apply(long cents); }
class VipFee implements FeePolicy { public long apply(long c){ return Math.round(c*0.95); } }
class FeeCalculator { Map<Tier,FeePolicy> map; long fee(long c,Tier t){ return map.get(t).apply(c);} }
```

---

### 3.6 임시 필드(Temporary Field)
- **징후**: 특정 조건에서만 쓰이는 필드.
- **처방**: **Extract Class**로 수명·검증 일치시키기.

---

### 3.7 메시지 체인(Message Chain) / 중개자 남용(Middle Man)
- **징후**: `a.b().c().d()` 체인 의존.
- **처방**: **Hide Delegate**, 필요한 값을 직접 제공하는 API 추가.

```javascript
// Before
const city = user.getProfile().getAddress().getCity();
// After
const city = user.getCity();
```

---

### 3.8 데이터 클래스(Data Class) / 기본형 집착(Primitive Obsession)
- **징후**: 게터/세터만, 규칙이 외부에 산재. 금액/기간을 숫자로 처리.
- **처방**: **Value Object**로 불변·규칙 캡슐화.

```java
public record Money(long cents, String currency){
  public Money add(Money o){ requireSame(o); return new Money(cents+o.cents, currency);}
  private void requireSame(Money o){ if(!currency.equals(o.currency)) throw new IllegalArgumentException();}
}
```

---

### 3.9 전역 상태(Global State) / 싱글톤 남용
- **징후**: 테스트가 순서 의존, 숨은 의존 다수.
- **처방**: **DI(생성자 주입)**, 명시적 전달, 스코프 관리.

```kotlin
// Before
object GlobalConfig { var endpoint = "http://..."; }
// After (DI)
class Client(private val endpoint: URI) { /* ... */ }
```

---

### 3.10 불필요/과다 주석(Excessive Comments)
- **징후**: “왜”보다 “무엇” 설명, 오래된 주석.
- **처방**: **자기 설명적 코드**, 의도-노력 비대칭인 곳만 주석.

---

### 3.11 Shotgun Surgery / Divergent Change
- **징후**: 작은 변경이 다수 파일을 건드림(Shotgun), 한 클래스가 다양한 이유로 자주 바뀜(Divergent).
- **처방**: **모듈 경계 재설계**, 이벤트 분해, SRP 준수.

---

### 3.12 Inappropriate Intimacy / Feature Envy
- **징후**: 다른 객체 내부를 과도히 참조.
- **처방**: **Move Method**, 책임 소유자 쪽으로 이동.

---

### 3.13 Lazy Class / Speculative Generality
- **징후**: 하는 일 없음/미래 대비 추상만 가득.
- **처방**: **Inline Class**, 불필요 추상 제거(YAGNI).

---

### 3.14 매직 넘버/문자열
- **처방**: **상수/타입** 도입, Enum/VO 사용.

---

### 3.15 죽은 코드(Dead Code)
- **처방**: 제거 + 커버리지/사용 추적 확증.

---

## 4. 데이터·DB 냄새 (실전)

### 4.1 N+1 쿼리
- **징후**: 루프 내 동일 Select.
- **처방**: Fetch Join/Batch, CQRS.

```java
@Query("select distinct o from Order o join fetch o.lines")
List<Order> findAllWithLines();
```

### 4.2 SELECT *
- **처방**: 명시 컬럼, 전송량 절감용 DTO.

```sql
SELECT id, placed_at, total_cents FROM orders WHERE id = ?;
```

### 4.3 EAV 남용
- **처방**: 명시 스키마, 제약/인덱스, JSON 칼럼도 스키마와 함께.

---

## 5. 프론트엔드/UI 냄새

### 5.1 거대 컴포넌트 / Prop Drilling
- **처방**: 컨테이너/프레젠테이션 분리, 컨텍스트/상태 라이브러리, 커스텀 훅.

```tsx
// React: 거대 컴포넌트 분해
function OrdersPage(){ const vm = useOrdersVM(); return <OrdersView vm={vm}/>; }
function OrdersView({vm}:{vm:VM}){ /* 렌더 전담 */ }
```

### 5.2 인라인 스타일 남발/렌더 폭탄
- **처방**: 스타일 시스템, memoization, key·리스트 최적화.

---

## 6. 측정·진단 — 수학적 지표와 자동화

### 6.1 사이클로매틱 복잡도
$$
M = E - N + 2P
$$
- 분기(조건) 수와 비례. 테스트 최소 케이스 하한을 뜻한다.  
- 기준(가이드): 10 내외 경고, 20↑ 리팩토링 후보.

### 6.2 유지보수성 지수(MI)
$$
MI = \max\!\left(0, 171 - 5.2\ln(V) - 0.23M - 16.2\ln(LOC)\right)
$$
- 낮을수록 경고. LOC·복잡도·Halstead 결합 지표.

### 6.3 자동화 도구
- **정적 분석**: SonarQube, PMD/Checkstyle, ESLint, Pylint, Detekt/Ktlint.  
- **복잡도/중복**: CPD, plato.  
- **Mutation Testing**: PIT, Stryker — 테스트 취약점 탐지.  
- **APM/쿼리 프로파일러**: N+1, 핫스팟 포착.

---

## 7. 냄새 → 리팩토링 처방 매핑표

| 냄새 | 1차 | 2차 |
|---|---|---|
| 긴 메서드 | Extract Method | Introduce Parameter Object |
| 거대한 클래스 | Extract Class | Facade, 모듈화 |
| 조건문 폭발 | Strategy/State | Rule Engine |
| 데이터 클래스/기본형 집착 | Value Object | Validation 내재화 |
| 메시지 체인 | Hide Delegate | Facade |
| Shotgun Surgery | Bounded Context 재설계 | 이벤트/사가 분해 |
| 전역 상태 | DI/생성자 주입 | 순수 함수화 |
| SELECT * | 명시 컬럼 | DTO/Projection |
| N+1 | Fetch Join/Batch | 캐시, CQRS |

---

## 8. 실전 사례

### 8.1 백엔드: “분산 모놀리스” 조짐 완화
- **징후**: 서비스 6개가 하나의 DB 스키마 공유, 동기 RPC 체인.
- **개선**:
  1) 컨텍스트 매핑(DDD)으로 경계 재정의  
  2) 각 서비스 **독립 스키마**·읽기 모델 분리  
  3) **비동기 이벤트** + 사후 일관성(Saga)  
  4) **계약 테스트**로 독립 배포 보장

### 8.2 프론트: 거대 컴포넌트 → 훅/뷰 분리
- **전략**: ViewModel 훅(`useXxxVM`) 도입, 렌더 전담 컴포넌트 분리, 비동기 상태는 React Query 등으로 위임.

### 8.3 SQL: N+1 제거
- **전략**: 한 번에 조인/배치 로딩 + 페이지네이션 시 Projection으로 대역폭 최적화.

---

## 9. 리팩토링 워크플로우(팀용)

1) **냄새 지정**: 이슈로 가시화(“REF: 긴 메서드 제거(CheckoutService)”).  
2) **경계 설정**: 기능 무변경 원칙, 영향 범위 표기.  
3) **테스트 확보**: 단위/계약/스냅샷.  
4) **작고 원자적 커밋**: 한 번에 한 리팩토링.  
5) **품질 게이트**: 정적 분석 + mutation score 임계.  
6) **리뷰**: 의도·대안·잔여 냄새 기록(ADR).  
7) **관찰**: 배포 후 메트릭/로그/트레이스 점검.

---

## 10. 도구·설정 스니펫

### 10.1 SonarQube(Java Maven 예)
```xml
<properties>
  <sonar.java.coveragePlugin>jacoco</sonar.java.coveragePlugin>
  <sonar.coverage.exclusions>**/*Dto.java, **/*Config.java</sonar.coverage.exclusions>
</properties>
```

### 10.2 ESLint(React)
```json
{
  "extends": ["eslint:recommended","plugin:react/recommended"],
  "rules": {
    "complexity": ["warn", 10],
    "max-lines-per-function": ["warn", 80],
    "no-magic-numbers": ["warn", { "ignore": [0,1] }]
  }
}
```

### 10.3 PIT Mutation(Gradle)
```groovy
pitest {
  targetClasses = ['com.example.*']
  mutationThreshold = 60
}
```

---

## 11. 자주 묻는 질문(FAQ)

- **냄새=나쁜 코드?** 아닙니다. **경고 신호**이며, 맥락과 우선순위로 판단.  
- **언제 고치나?** 기능 작업 직전/직후, 핫스팟 우선.  
- **성능과 상충?** 리팩토링은 보통 성능을 해치지 않는다. 성능 이슈는 **프로파일링 후** 필요 지점에 최적화.

---

## 12. 점검 체크리스트(팀 리뷰용)

- [ ] 긴 메서드(>80줄), 복잡도(>10) 경고 없음  
- [ ] 중복 코드 제거(CPD 기준)  
- [ ] 전역/싱글톤 의존 제거, DI 적용  
- [ ] 도메인 객체가 프레임워크 타입에 의존하지 않음  
- [ ] 조건문 폭발 구간에 전략/다형성 도입  
- [ ] DB 접근: N+1/SELECT * 없음, 인덱스/카디널리티 검토  
- [ ] 프론트: 거대 컴포넌트 분해, 상태/데이터 훅 분리  
- [ ] 테스트: 플래키 제거, 가짜 클록 사용, mutation score 기준 충족  
- [ ] 보안: 비밀 하드코딩/PII 로그 없음  
- [ ] ADR로 경계/의사결정 기록

---

## 13. 결론

코드 냄새는 **설계 부채의 조기 경보**다.  
냄새를 **측정 지표**와 **정적 분석**, **리뷰 규약**, **리팩토링 루틴**으로 상시 관리하라.  
핵심은 **맥락 기반 우선순위**와 **작고 안전한 변경**이다.  
오늘은 **핫스팟 한 곳**만 정리해도, 내일의 유지보수 비용이 크게 줄어든다.

---
### 부록 A. 미니 처방 모음(언어별)

#### Java — 조건 → 다형성
```java
sealed interface Tax permits Basic, Luxury { long apply(long cents); }
final class Basic implements Tax { public long apply(long c){ return Math.round(c*1.1); } }
final class Luxury implements Tax { public long apply(long c){ return Math.round(c*1.2); } }
```

#### Python — 매직 넘버 제거
```python
EARLY_BIRD_RATE = 0.7
def price(base, is_early):
    return base * (EARLY_BIRD_RATE if is_early else 1.0)
```

#### JavaScript — 메시지 체인 숨기기
```javascript
class User {
  #profile; get city(){ return this.#profile?.address?.city ?? null; }
}
```

#### SQL — Projection + Pagination
```sql
SELECT id, placed_at, total_cents
FROM orders
WHERE customer_id = :cid
ORDER BY placed_at DESC
LIMIT :limit OFFSET :offset;
```