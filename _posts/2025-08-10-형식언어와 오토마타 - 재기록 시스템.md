---
layout: post
title: 형식언어와 오토마타 - 재기록 시스템
date: 2025-08-10 18:20:23 +0900
category: 형식언어와 오토마타
---
# 재기록(Rewriting) 시스템 고급 가이드  
**행렬 문법(Matrix Grammars)** · **Markov(마르코프) 알고리즘** · **L-시스템(Lindenmayer Systems)**

형식언어와 계산이 만나는 핵심 축 중 하나가 **재기록(rewriting)** 입니다. 재기록 규칙을 어떻게, 어떤 **일괄성(배치/행렬)** 또는 **전역성(병렬)** 으로 적용하느냐에 따라 **표현력**과 **결정성**이 크게 달라집니다. 여기서는 세 가지 대표 체계를 한 자리에 정리합니다. (수식은 MathJax, 규칙·예시는 코드블록으로 표기합니다.)

---

## 1) 행렬 문법(Matrix Grammars)

### 1.1 정의(일반형)
행렬 문법은 재작성 규칙을 **행렬(matrix)** 로 묶어 **순서 있는 묶음 전체**를 한 번의 유도 단계에서 **모두 적용**하도록 강제한 문법입니다.

- 알파벳을 터미널 \(T\), 비터미널 \(N\), 시작기호 \(S\)라 하고, 일반 재작성 규칙 \(\alpha \to \beta\) (\(\alpha\)는 비터미널을 포함)들의 유한 집합을 생각합니다.
- **행렬**은 규칙들의 **유한 수열** \([p_1,\dots,p_k]\) 입니다.
- 한 단계 유도는 현 문장형태 \(w\)에 대해, 행렬 내부의 규칙을 **주어진 순서대로** 각각 **한 번씩** 적용하여
  \[
    w \Rightarrow w' \quad\text{(via }[p_1,\dots,p_k]\text{)}
  \]
  를 만드는 것입니다. (각 규칙은 현재 문장형태 내 **임의의 한 위치**의 좌변 발생에 적용)

> 요점: “규칙 하나씩”이 아니라 “**묶음 전체**”의 적용이 **한 단계**입니다. 이렇게 하면 여러 부분 구조의 **동기화된 변화**를 표현하기 쉬워집니다.

### 1.2 (선택) **appearance checking(출현 검사)**
행렬 내부의 어떤 규칙 좌변이 **현재 문장형태에 나타나지 않아도** 그 규칙을 “**통과**”한 것으로 간주하고 나머지 규칙들을 계속 적용할 수 있게 허용하는 확장입니다.  
이 한 가지 옵션이 표현력을 크게 올립니다.

- **AC 없음**: 좌변이 없으면 그 행렬은 **적용 불가**.
- **AC 있음**: 좌변이 없으면 그 규칙은 **no-op**으로 처리하고 행렬 적용을 계속.

### 1.3 예시 — \( \{a^n b^n c^n \mid n\ge 1\} \) 생성
아래 행렬 문법은 서로 다른 블록의 길이를 **동시에** 늘려 같은 수를 맞춥니다.

```text
N = {S, A, B, C}
T = {a, b, c}
Matrices M:
  M0: [ S -> A B C ]                      # 시작 전개
  M1: [ A -> a A ,  B -> b B ,  C -> c C ]# 세 블록 동시 증가
  M2: [ A -> a   ,  B -> b   ,  C -> c   ]# 종결(비터미널 제거)
```

유도 예:
```
S ⇒(M0) A B C
  ⇒(M1) a A b B c C
  ⇒(M1) a a A b b B c c C
  ⇒⋯⇒   a^k A b^k B c^k C
  ⇒(M2) a^{k+1} b^{k+1} c^{k+1}
```
따라서 \(n\ge 1\)의 모든 \(a^n b^n c^n\)을 생성합니다(문맥자유는 만들기 어려운 대표 언어).

### 1.4 표현력과 성질(요지)
- **표현력(AC 유무)**  
  - **AC 있음**: **재귀적으로 열거 가능한 언어(RE)** 전체를 생성(튜링 완전).  
  - **AC 없음**: **문맥자유**보다 강하고, 전형적으로 **문맥의존(CSL)** 안에 포함되는 폭넓은 계열(세부 변형에 따라 경계가 다름).
- **설계 감각**: “여러 카운트를 **동일한 행렬**로 묶어 동시에 1씩 증가/감소” 같은 '**동기화**'를 표현하기 좋습니다.
- **폐포**: 대체로 합/연접/Kleene★, 정규 연산과의 상호작용에 강함(구체 폐포는 변형별로 다름).
- **판정 문제**:  
  - (AC 有) 멤버십은 **반결정만 가능**(RE), 많은 전역 성질은 **결정 불가능**.  
  - (AC 無) 멤버십은 **결정 가능**(대체로 CSL 영역)이나 복잡도는 높을 수 있음.

---

## 2) Markov(마르코프) **정규 알고리즘**(Normal Algorithms)

### 2.1 정의(순차 재기록, 우선순위·좌측우선)
Markov 알고리즘은 **선형 순서**를 가진 치환 규칙 목록으로 문자열을 순차 재작성합니다.

- 알파벳 \(\Sigma\), 규칙의 **순서 있는 목록** \(R = (r_1, r_2, \dots, r_m)\).
- 규칙의 형태
  - **비종결**: \(\ell \to r\)
  - **종결**: \(\ell \to\!\!.\ r\)  (점이 붙으면 이 규칙을 적용한 **직후 정지**)
- 한 단계:
  1) 목록의 **처음부터** 내려오며, 현재 단어에 **적용 가능한 첫 규칙** \(r_i\)를 찾는다.
  2) 현재 단어의 **좌측에서 가장 왼쪽(leftmost)** 발생을 \(r_i\)로 치환한다.
  3) \(r_i\)가 종결 규칙이면 **정지**, 아니면 다음 단계를 반복.
- 아무 규칙도 적용 불가가 되면(종결 규칙 없이) **정지**.

> 이 전략(규칙 우선순위 + 좌측우선 치환) 덕분에 **결정적**이고, “문자열 치환으로 하는 튜링 계산”을 명료하게 모델링합니다.

### 2.2 계산 모델로서의 위상
- **표현력**: **부분 μ-재귀 함수 ↔ 튜링 계산 가능**과 동등.  
  따라서 **언어 인식/변환** 모두에서 일반 계산 모델과 같은 힘을 가집니다.
- **언어 인식**: 입력을 `yes`/`no` 등의 표시로 **수렴**시키도록 규칙을 짜면 판정기로 쓸 수 있습니다(수렴하지 않으면 '모름').

### 2.3 예시 — **단항 덧셈** \(a^n\#a^m \mapsto a^{n+m}\)
왼편 블록의 \(a\)들을 하나씩 `#` 오른쪽으로 넘기고, 마지막에 `#`를 제거합니다.

```text
1) a#  -> #a       # 왼쪽 a를 오른쪽으로 이동
2) #   ->. ε       # #를 지우고 정지(종결 규칙)
```

예: `aaa#aaaa  ⇒  aa#a aaa  ⇒  a#aa a aa  ⇒  #aaaaaaa  ⇒(2) aaaaaaa`  
최종 출력은 \(a^{3+4}\).

> 이처럼 Markov 알고리즘은 **순차 치환**만으로도 덧셈/곱셈/모형 계산 등 다양한 변환을 안정적으로 구현합니다.

---

## 3) L-시스템(Lindenmayer Systems): **병렬 재기록**의 정석

### 3.1 기본 0L/D0L 정의(동시 적용)
L-시스템은 모든 기호에 대한 **재기록을 동시에(parallel)** 수행합니다.

- \(G=(V, \omega, P)\)
  - **어휘** \(V\): 재기록 대상 기호 집합(일반 문자 + 그래픽 명령 등)
  - **시작 문자열**(axiom) \(\omega \in V^*\)
  - **규칙** \(P: V \to V^*\) (각 기호의 치환 문자열)
- 유도: \(w_0=\omega\), \(w_{k+1}\) 는 \(w_k\)의 모든 기호를 **동시에** 규칙으로 치환한 것.
- **D0L(결정적 0L)**: 각 기호에 대해 규칙이 **하나**씩.
- **Stochastic 0L**: 확률이 부여된 다중 규칙 중 하나를 선택.
- **Bracketed/Parametric L-system**: `[ ]`, `+/-` 등 그래픽 명령·실수 파라미터를 도입하여 식물 모델링에 활용.

> **핵심 차이**: 문맥자유 CFG/PDA는 **순차** 재기록, L-시스템은 **병렬** 재기록. 같은 규칙이어도 결과와 표현력이 달라집니다.

### 3.2 예시

#### (a) Fibonacci 단어(D0L)
```text
V = {A,B},  ω = A
P: A -> AB
   B -> A
# 유도: A ⇒ AB ⇒ ABA ⇒ ABAAB ⇒ …
```

#### (b) Koch 곡선(그래픽; bracketed 아님, 터틀 명령)
```text
V = {F, +, -}
ω = F
P: F -> F+F--F+F
# 각 단계에서 선분 F를 패턴으로 교체, +/−는 회전 명령
```

#### (c) 간단한 가지치기(Bracketed L-system; 터틀)
```text
V = {F, [, ], +, -}
ω = F
P: F -> F[+F]F[-F]F
# [ : 스택 push(분기 시작), ] : pop(분기 종료), +/− : 좌/우 회전
```

### 3.3 ET0L: **테이블** 도입으로 표현력 상승
- 여러 **테이블(규칙 집합)** \(\tau_1,\dots,\tau_k\) 을 두고 각 단계에서 하나의 테이블을 골라 **그 테이블의 규칙만** 병렬 적용.  
- **ET0L 언어**는 CFL을 **엄Strict히 포함**하며, 전형적으로 **문맥의존(CSL)** 의 **진부분집합**(CFL과 CSL 사이)입니다.  
  (Indexed 언어와는 **상호 비교 불가**한 고전 결과도 알려져 있습니다.)

### 3.4 성질·응용
- **폐포**: 합/연접/Kleene★/정규와의 교차 등에 폭넓게 닫혀 있음(특히 ET0L).  
- **응용**: 생물 성장 모델, 프랙탈/문양 생성, 셰이더·프로시저럴 모델링 등.  
- **멤버십/평가**: 병렬 전개는 구현이 단순(반복 치환)하지만, **언어 이론적 속성**(동치/포함 등)은 어려울 수 있습니다.

---

## 4) 세 체계 **요약 비교**

| 축 | 행렬 문법 | Markov 알고리즘 | L-시스템 |
|---|---|---|---|
| 적용 방식 | **행렬(순서열) 전체**를 한 번에(순차 내 동기화) | **우선순위·좌측우선** 단일 치환(완전 순차) | **모든 기호 병렬 치환** |
| 설계 포인트 | 여러 카운트/구조의 **동기화** | 문자열 변환·판정의 **결정적 시뮬** | 성장/반복 패턴의 **전역 동시 전개** |
| 전형 표현력 | (AC 無) CFL ⊊ ML ⊆ CSL / (AC 有) = **RE** | = **튜링**(부분 재귀) | D0L ⊊ … ⊊ **ET0L** ⊂ CSL (전형) |
| 대표 예시 | \(a^n b^n c^n\) 등 동기 증가 | 단항 덧셈/정규화·판정 | Fibonacci, Koch, 분기 식물 |
| 판정 문제 | (AC 有) 다수 **결정 불가** | 다수 **결정 불가** | 언어 속성 난이도 높음(모형에 따라 상이) |

> 용어: **ML**(Matrix Languages), **CSL**(Context-Sensitive), **RE**(Recursively Enumerable).  
> 경계는 변형(appearance checking, finite index, table 등)에 따라 달라집니다.

---

## 5) 설계 팁(감소·표현 레시피)

- **행렬 문법**: “증가/감소를 **동시에**” 묶는 행렬을 설계하고, 마지막에 **종결 행렬**로 비터미널을 제거하세요. 구분자(`#`)를 적극 활용.  
- **Markov**: **가장 먼저 적용되는 규칙**이 무엇인지 항상 추적(우선순위 충돌 주의). `→.` 종결 규칙으로 결과를 명확히 닫으세요.  
- **L-시스템**: 병렬 치환이 만들어 낼 **전체 패턴**을 상상하고 규칙을 짜세요(로컬 규칙이 **전역** 구조를 정합니다). ET0L이 필요하면 단계별로 **테이블** 전환을 설계.

---

## 6) 한 페이지 정리
- **행렬 문법**은 “여러 규칙을 한 번에” 적용해 **동기화된 유도**를 만든다. AC를 허용하면 **튜링 완전**.  
- **Markov 알고리즘**은 **우선순위+좌측우선**의 순차 치환으로 **일반 계산**을 표현한다.  
- **L-시스템**은 **병렬** 치환으로 성장·분기 패턴을 간단히 모델링하며, **ET0L**로 강한 표현력(여전히 CSL 내부)을 갖는다.
