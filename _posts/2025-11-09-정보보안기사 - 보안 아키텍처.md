---
layout: post
title: 정보보안기사 - 보안 아키텍처
date: 2025-11-09 15:25:23 +0900
category: 정보보안기사
---
# 보안 아키텍처 — Segmentation, Bastion, DMZ, SASE/ZTNA 개요

## 0) 큰그림(Architecture at a glance)

```
           [ 사용자/기기 ]──(ZTNA/SASE POP)──[ Reverse Proxy/WAF ]──[ DMZ ]
                 │                                     │               │
(집/지점/모바일)─┘                                     │               ├─[ API GW ]
                                                      │               ├─[ Web/App LB ]
                                                      ▼               └─[ Mail/FTP(필요시) ]
                                          [ Bastion / PAM ]───┐
                                                      │       ├──(JIT) 관리 세션
                                                      │       └──세션 기록/명령 감시
                                                      ▼
         [ Macro-Segmentation (Zones/VRF/VLAN)]  ┌─────────코어─────────┐
            Untrust ─ DMZ ─ App ─ DB ─ Mgmt ─ Dev ─ User ─ IoT/OT(별도) …
             │         │      │     │      │      │        │
         (FW/L3 ACL)  (WAF) (mTLS) (NAC) (IdP/MDM) (EDR)  (전용 FW/게이트웨이)
```

- **핵심 원칙**: “**허용은 최소, 거부는 기본**(default deny)”, “**ID·컨텍스트 기반** 접근”, “**검증→적용→관찰**의 점진적 배포”.
- **중첩 방어**: L3/L4 방화벽 + L7 프록시/WAF + 마이크로세그먼트(Host/K8s) + ZTNA.

---

# 1) Segmentation — Macro / Micro

## 1.1 왜 하는가 (Blast Radius 수식 직관)
- 서비스 n개, 각 서비스가 평균적으로 k개의 다른 서비스에 접근한다고 가정하면, **잠재 연결 그래프**의 간선수는 대략 $$E \approx n \cdot k$$.  
- **마이크로세그먼트**로 허용 그래프를 k'로 줄이면 $$\Delta E \approx n \cdot (k - k')$$ 만큼 **공격 이동면(동서 트래픽)**이 감소.

## 1.2 Macro-Segmentation
- **Zones(보안 등급)**: `Untrust / DMZ / App / DB / Mgmt / User / Dev / IoT/OT`.  
- **경계**: VRF/VLAN/Subnet + L3 방화벽/라우터 ACL.  
- **정책**: “Zone→Zone” 매트릭스로 설계(예: `User→DB` 직접 금지, `User→App`만 허용).

### 예) Linux nftables로 Zone 매트릭스(간단)
```bash
# 테이블/셋 정의
nft add table inet zfw
nft add set inet zfw allowed { type ipv4_addr . ipv4_addr ; flags interval; }
# 정책 체인
nft add chain inet zfw forward { type filter hook forward priority 0; policy drop; }
# 허용 쌍 등록: (src,dst) 대역 단위
nft add element inet zfw allowed { 10.10.10.0/24 . 10.20.0.0/16, 10.30.0.0/16 . 10.40.0.0/16 }
# 룰: 허용 매핑에만 L3 통과
nft add rule inet zfw forward ip saddr . ip daddr @allowed counter accept
# 로깅+드롭
nft add rule inet zfw forward ct state established,related accept
nft add rule inet zfw forward limit rate 10/second counter log prefix "ZFW_DROP " drop
```

### 예) AWS VPC (SG + NACL) — App↔DB 최소허용
```hcl
# Terraform 발췌: SG로 L4 최소 허용
resource "aws_security_group" "app_sg" {
  name   = "app-sg"
  vpc_id = aws_vpc.main.id
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    security_groups = [aws_security_group.ztna_proxy.id] # ZTNA/프록시만 허용
  }
  egress { from_port = 0 to_port = 0 protocol = "-1" cidr_blocks = ["10.20.0.0/16"] } # DB 서브넷만
}
resource "aws_security_group" "db_sg" {
  name   = "db-sg"
  vpc_id = aws_vpc.main.id
  ingress { from_port=5432 to_port=5432 protocol="tcp" security_groups=[aws_security_group.app_sg.id] }
  egress  { from_port=0 to_port=0 protocol="-1" cidr_blocks=["10.0.0.0/8"] }
}
```

## 1.3 Micro-Segmentation
- **호스트 기반**: OS 방화벽(Windows Defender Firewall, ufw/nftables), EDR 제어.  
- **가상화/SDN**: NSX/ACI(분산 FW), **Kubernetes NetworkPolicy/Service Mesh**.  
- **정책 단위**: “서비스→서비스/포트/메서드/ID”.

### 예) Kubernetes — 기본 거부 + App→DB만 허용
```yaml
# 1) 네임스페이스 기본 거부
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata: { name: default-deny, namespace: prod }
spec:
  podSelector: {}
  policyTypes: ["Ingress","Egress"]

---
# 2) app-labs가 db-labs:5432로만 나가게
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata: { name: app-egress-db, namespace: prod }
spec:
  podSelector: { matchLabels: { app: webapp } }
  policyTypes: ["Egress"]
  egress:
    - to:
        - namespaceSelector: { matchLabels: { role: db } }
          podSelector: { matchLabels: { tier: postgres } }
      ports: [{ protocol: TCP, port: 5432 }]
```

### 예) Service Mesh (Istio) — mTLS + 메서드 제한
```yaml
apiVersion: security.istio.io/v1
kind: PeerAuthentication
metadata: { name: mesh-mtls }
spec: { mtls: { mode: STRICT } }

---
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata: { name: orders-only-post, namespace: prod }
spec:
  selector: { matchLabels: { app: orders } }
  rules:
  - from:
    - source:
        principals: ["spiffe://cluster.local/ns/prod/sa/web-sa"]
    to:
    - operation:
        methods: ["POST"]
        paths: ["/orders/*"]
```

> **권장**: **Micro(Workload) 정책**은 **IaC(GitOps)** 로 버전 관리하고, **프리프로덕션**에서 카나리 테스트.

---

# 2) Bastion (점프서버) — 관리면 보호

## 2.1 원칙
- **인바운드 관리 포트(22/3389)** 인터넷 **직결 금지**.  
- **JIT(Just-in-Time)** + **MFA** + **세션 녹화/감사** + **명령 제한**.  
- **ProxyJump/Session Manager** 로 내부로만 연결. 배스천은 **짧은 수명/불변(Immutable)**.

## 2.2 OpenSSH 구성(강화)
```conf
# /etc/ssh/sshd_config
Protocol 2
AddressFamily inet
ListenAddress 0.0.0.0
Port 22
PasswordAuthentication no
PubkeyAuthentication yes
KbdInteractiveAuthentication no
PermitRootLogin no
ChallengeResponseAuthentication no
AuthenticationMethods publickey,keyboard-interactive:pam   # (MFA 연동 시)
AllowUsers admin@corp
AllowTcpForwarding local
X11Forwarding no
ClientAliveInterval 300
ClientAliveCountMax 2
ForceCommand /usr/local/bin/recorded-shell  # 세션 기록 강제
```

### 세션 녹화(ttyrec/script) 강제(샘플)
```bash
# /usr/local/bin/recorded-shell
#!/usr/bin/env bash
LOGDIR=/var/log/ssh-sessions
mkdir -p "$LOGDIR"
FN="$LOGDIR/$(date +%F_%T)_${USER}_$$.typescr"
exec script -q -f -c "/bin/bash" "$FN"    # 모든 입력/출력 기록
```

### 클라이언트에서 ProxyJump
```ssh
# ~/.ssh/config
Host bastion
  HostName bastion.corp.example
  User admin
  IdentityFile ~/.ssh/id_ed25519

Host db1
  HostName 10.40.1.10
  User postgres
  ProxyJump bastion
```
```bash
ssh db1           # bastion 통해 자동 점프
```

## 2.3 AWS SSM Session Manager(인바운드 0)
- **개방 포트 없이** EC2 접속.  
- IAM 정책으로 **JIT 허가**, 세션 로깅(S3/CloudWatch).

```json
// IAM Policy fragment: SSM session start allow (role/user)
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": [
      "ssm:StartSession","ssm:TerminateSession","ssm:ResumeSession",
      "ssm:DescribeSessions","ssm:GetConnectionStatus"
    ],
    "Resource": ["arn:aws:ec2:region:acct:instance/*","arn:aws:ssm:region:acct:session/*"]
  }]
}
```

> **권장**: 가능하면 **SSM/Bastion 관리면 전용 VPC/서브넷** 배치, **인터넷 NAT 없음**.

## 2.4 PAM/권한상승
- `sudo`는 **역할 기반** 최소 권한, `requiretty`, **명령 화이트리스트**.  
- **비상(Break-glass)** 계정은 **금고**에 보관(긴급 룰북 포함, 정기 교체·점검).

---

# 3) DMZ — 외부 노출 자산의 완충지대

## 3.1 패턴
- **양팔형(Two-Arm) LB**: (인터넷↔DMZ) / (DMZ↔내부) 각각 인터페이스.  
- **One-Arm + SNAT**: 라우팅 단순, 로깅 주의.  
- **Re-Proxy/WAF**: DMZ에 **Reverse Proxy/WAF** 배치, 내부 App은 **비공개**.

## 3.2 핵심 정책
- **인바운드**: 인터넷→DMZ **필요 포트만**(443 등), **PMF/WAF 규칙**.  
- **동서**: DMZ→App **화이트리스트**, App→DB **전용 포트**.  
- **아웃바운드**: DMZ→인터넷 **필요 최소(Egress)** + **프록시** 경유.

### 예) DMZ 엣지 NGINX(WAF 연동 전 단계)
```nginx
# /etc/nginx/nginx.conf (요약)
load_module modules/ngx_http_modsecurity_module.so;
http {
  modsecurity on;
  modsecurity_rules_file /etc/nginx/modsec/main.conf;

  server {
    listen 443 ssl http2;
    server_name app.example.com;
    ssl_certificate /etc/nginx/cert.pem;
    ssl_certificate_key /etc/nginx/key.pem;

    # L7 Rate-limit (간단 DDOS 억제)
    limit_req_zone $binary_remote_addr zone=req:10m rate=5r/s;

    location /api/ {
      limit_req zone=req burst=20 nodelay;
      proxy_pass http://app.internal.svc:8080;
      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $remote_addr;
    }
  }
}
```

### 예) DMZ 방화벽(Zone 정책 개념)
```
Untrust → DMZ : 443/tcp to WAF VIP only
DMZ → App    : 8080/tcp to App ASG only
App → DB     : 5432/tcp to DB cluster only
DMZ → Internet (egress) : CRL/OCSP/DNS/NTP only via Forward Proxy
```

> **로그**: WAF/Reverse Proxy/Edge FW **중앙 수집**, 상관분석(URI·Source·ASN).

---

# 4) SASE / ZTNA — 네트워크가 아닌 **아이덴티티**를 신뢰

## 4.1 SASE 구성요소
- **SD-WAN** + **SWG(보안 웹 게이트웨이)** + **CASB** + **FWaaS** + **ZTNA** + **DLP** 를 클라우드 POP로 결합.  
- 사용자/지점 트래픽 → **가장 가까운 POP** → **정책/검사** → **SaaS/인터넷/사내앱**.

## 4.2 ZTNA 핵심
- **사용자·기기·위치·시간·리스크** 기반 **앱 단위** 접근.  
- **mTLS/JWT/OIDC**로 손상된 네트워크에서도 **명시적 검증**.  
- **수명 짧은 토큰/권한**, **연속 평가(Continuous)**.

### 예) Envoy + JWT 검증(앱 단위 정책)
```yaml
# envoy.yaml (발췌) - /orders/* 는 aud=orders-api, role=sales 만 허용
static_resources:
  listeners:
  - name: https
    address: { socket_address: { address: 0.0.0.0, port_value: 443 } }
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          route_config:
            virtual_hosts:
            - name: app
              domains: ["orders.example.com"]
              routes:
              - match: { prefix: "/orders" }
                route: { cluster: orders }
          http_filters:
          - name: envoy.filters.http.jwt_authn
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
              providers:
                oidc:
                  issuer: "https://idp.example.com"
                  audiences: ["orders-api"]
                  remote_jwks: { http_uri: { uri: "https://idp.example.com/jwks.json", cluster: idp } }
              rules:
              - match: { prefix: "/orders" }
                requires:
                  requires_all:
                    requirements:
                    - provider_name: "oidc"
                    - require_any:
                        requirements:
                        - metadata:
                            filter: envoy.filters.http.jwt_authn
                            path: [ { key: "payload" }, { key: "role" } ]
                            value: { string_match: { exact: "sales" } }
          - name: envoy.filters.http.router
```

### 예) ZTNA 정책(의사 YAML)
```yaml
policy:
  - name: "admin-ssh-jit"
    subjects: [user.group: "ops"]
    device_posture: [edr_ok: true, disk_encrypted: true]
    resources: ["ssh://i-*.corp.internal:22"]
    conditions:
      time: ["09:00-19:00 Asia/Seoul"]
      location: ["KR","JP"]
    actions:
      grant: "2h"          # 세션 한도
      record_session: true
```

> **전환 전략**: VPN을 즉시 제거하지 말고, **ZTNA 병행** → **앱 단위로 점진 전환**.

---

# 5) 레퍼런스 아키텍처 3종

## 5.1 SMB(50~300 사용자)
- **SASE/ZTNA** 우선 도입(원격·지점), **클라우드 WAF** + 간결한 **DMZ**.  
- VPC: `Public(ELB/WAF)` / `Private(App)` / `Data(DB)` / `Mgmt(Bastion/SSM)` 서브넷.  
- K8s 도입 시 **NetworkPolicy 기본거부**, mTLS.

## 5.2 엔터프라이즈(>1000)
- **Anycast WAF/ZTNA POP** + 온프레 **NGFW/IPS** 이중화.  
- **NSX/ACI** 분산 방화벽으로 **Micro-Seg** 표준화.  
- **PAM/Bastion** 중앙화, 세션 기록 **의무화**.

## 5.3 클라우드 네이티브
- GitOps(IaC)로 **SG/NP/ALB/WAF**를 코드화.  
- 서비스 메시로 **ID 기반 정책** 통일.  
- **eBPF 관측(Hubble 등)** 로 정책 검증 자동화.

---

# 6) 단계별 적용 로드맵

1) **현황 가시화**: 플로우/IPFIX, 앱 인벤토리, 통신 매트릭스 추출.  
2) **Zone 매트릭스 초안**: 우선순위 높은 경로만 허용(나머지 모니터).  
3) **Bastion/SSM** 도입 → 관리면 차단.  
4) **DMZ 재정렬**: 리버스 프록시/WAF 앞세우고 Egress 최소화.  
5) **K8s/Workload** 기본거부 + mTLS.  
6) **ZTNA 파일럿**: 1~2개 앱부터 “앱 단위 접근” 전환.  
7) **관찰/피드백**: FP/성능/운영성 데이터로 정책 고도화.

---

# 7) 운영·검증 체크리스트

- [ ] Zone→Zone 정책은 **화이트리스트**로만 작성.  
- [ ] Bastion는 **MFA/JIT/세션기록** 필수, **인터넷 직결 관리포트 금지**.  
- [ ] DMZ는 **WAF/Reverse Proxy** + **Egress 최소**.  
- [ ] K8s는 **NetworkPolicy 기본거부**, **mTLS** 켜기.  
- [ ] IaC(Git/Terraform/Kustomize)로 **변경 이력화**, PR 리뷰/테스트 필수.  
- [ ] **로그 중앙화**: FW/WAF/Bastion/RADIUS/ZTNA.  
- [ ] **비상 롤백**: 정책 이전 스냅샷/버전 **즉시 복구** 가능.  
- [ ] **주기 점검**: 계정/키/증명서 만료, 미사용 룰 제거, **드리프트 탐지**.

---

# 8) 실전 예제 묶음

## 8.1 Linux Zone FW — 포트 매트릭스
```bash
# 변수
USER_NET=10.10.0.0/16
APP_NET=10.20.0.0/16
DB_NET=10.30.0.0/16
DMZ_NET=10.50.0.0/24

# 체인
nft add table inet corp
nft add chain inet corp fwd { type filter hook forward priority 0; policy drop; }

# Established
nft add rule inet corp fwd ct state established,related accept

# 허용: USER->APP:443
nft add rule inet corp fwd ip saddr $USER_NET ip daddr $APP_NET tcp dport 443 accept
# 허용: APP->DB:5432
nft add rule inet corp fwd ip saddr $APP_NET  ip daddr $DB_NET  tcp dport 5432 accept
# 허용: DMZ->APP:8080
nft add rule inet corp fwd ip saddr $DMZ_NET ip daddr $APP_NET tcp dport 8080 accept

# 기본 로깅+드롭
nft add rule inet corp fwd limit rate 20/second log prefix "CORP_DROP " group 5
nft add rule inet corp fwd drop
```

## 8.2 Azure NSG(요약 JSON) — DMZ 인바운드만
```json
{
  "properties": {
    "securityRules": [{
      "name": "Allow-HTTPS-to-WAF",
      "properties": {
        "priority": 100,
        "direction": "Inbound",
        "access": "Allow",
        "protocol": "Tcp",
        "sourceAddressPrefix": "*",
        "sourcePortRange": "*",
        "destinationAddressPrefix": "10.50.0.10",
        "destinationPortRange": "443"
      }
    },{
      "name": "Deny-All-In",
      "properties": { "priority": 4096, "direction": "Inbound", "access": "Deny", "protocol": "*", "sourceAddressPrefix": "*", "sourcePortRange": "*", "destinationAddressPrefix": "*", "destinationPortRange": "*" }
    }]
  }
}
```

## 8.3 K8s — 네임스페이스 격리 + egress DNS/NTP만
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata: { name: egress-only-dns-ntp, namespace: prod }
spec:
  podSelector: {}
  policyTypes: ["Egress"]
  egress:
    - to: [{ ipBlock: { cidr: "10.53.0.10/32" } }]  # DNS
      ports: [{ protocol: UDP, port: 53 }]
    - to: [{ ipBlock: { cidr: "10.53.0.20/32" } }]  # NTP
      ports: [{ protocol: UDP, port: 123 }]
```

## 8.4 RADIUS를 통한 Mgmt VLAN 동적 할당(FreeRADIUS)
```conf
# users
netops Cleartext-Password := "S3cur3!"
  Tunnel-Type := VLAN,
  Tunnel-Medium-Type := IEEE-802,
  Tunnel-Private-Group-Id := "99"
```

---

# 9) 관찰·테스트(증거 기반)

## 9.1 연결 테스트(내부에서 내부)
```bash
# 허용된 경로만 성공해야 한다
nc -vz app.service.internal 443
nc -vz db.service.internal 5432
# 차단 확인
nc -vz db.service.internal 22  # 실패가 정상
```

## 9.2 K8s 네트워크 테스트(netshoot)
```bash
kubectl run -it tester --rm --image=nicolaka/netshoot -- bash
curl -s -o /dev/null -w "%{http_code}\n" https://orders.svc.cluster.local
nc -vz postgres.db.svc 5432
```

## 9.3 ZTNA 헤더/토큰 확인
```bash
curl -i https://orders.example.com/orders/123 -H "Authorization: Bearer <JWT>"
# 응답 헤더/로그에서 aud/role 검증 결과 확인
```

---

# 10) 트러블슈팅 & 롤백

- **정상 트래픽이 막힘**  
  - 최근 커밋/릴리즈의 **정책 변경** 확인(IaC diff).  
  - FW/K8s **기본거부** + 예외 규칙 누락? 서비스 디스커버리 네임/IP 드리프트?  
  - **롤백**: 직전 버전으로 빠른 복귀, 영향 범위 축소 후 재분석.

- **배스천 지연·세션 끊김**  
  - 감시/녹화에 의한 I/O 병목? CloudWatch/S3 쓰기 지연?  
  - SSM/프록시 경로의 MTU/MSS, NACL/SG 재검토.

- **DMZ WAF 오탐**  
  - 룰 ID 식별 → `DetectionOnly`로 일시 전환 → FP 케이스 화이트리스트(경로/메서드/헤더 스코프).  
  - 지표: 차단률, 4xx/5xx 급증, 레이턴시.

- **ZTNA 로그인 실패**  
  - IdP 시간/클레임/오디언스(aud), JWK 캐시 만료 확인.  
  - 기기 상태(Posture) 실패 → EDR/암호화 요건 충족 확인.

---

# 11) 보안·컴플라이언스 포인트

- **감사추적**: Bastion 세션·sudo 명령·WAF 결정·FW 히트 카운트 **중앙 보관/서명**.  
- **개인정보/비식별**: 프록시/DLP·로그 마스킹, 보존 주기/접근권한 최소화.  
- **변경관리**: RFC/티켓 → PR 리뷰 → 스테이징 → 점진 배포(링/카나리) → 포스트모템.

---

# 12) 미니 과제(실습)

### A) Zone 매트릭스로 L3 허용 최소화 (20점)
- (10) `User→App:443`, `App→DB:5432` 외 **모두 차단** 구현(nft/ACL/SG)  
- (5) 허용/차단 케이스 캡처(스크린샷/로그)  
- (5) Active 모니터링 대시보드 스냅샷

### B) Bastion 세션 녹화 & JIT (20점)
- (10) OpenSSH `ForceCommand` 녹화 스크립트 동작  
- (5) JIT: 특정 시간만 접근 허용(SSM or FW 자동화)  
- (5) 세션 로그 해시/보관

### C) DMZ WAF + ZTNA 연계 (20점)
- (10) `/orders/*` JWT `aud=orders-api` 필수  
- (5) Rate-limit 5r/s 적용  
- (5) 오탐 케이스 조정(`DetectionOnly`→차단)

---

## 마무리

- **Segmentation**: Zone→Zone 매트릭스로 **거부가 기본**, Micro는 **ID·서비스 단위**로 정교화.  
- **Bastion**: **MFA/JIT/세션기록**을 표준화하고, **인바운드 관리 포트 노출 금지**.  
- **DMZ**: 인터넷 노출 자산을 **Reverse Proxy/WAF**로 전면 보호하고, **Egress 최소화**.  
- **SASE/ZTNA**: **사용자·기기·컨텍스트**를 중심으로 **앱 단위** 접근을 강제, VPN 의존을 줄입니다.  
- 모든 정책은 **IaC/GitOps**로 추적 가능해야 하며, **관찰성(로그/지표)** 없이는 개선이 불가합니다.