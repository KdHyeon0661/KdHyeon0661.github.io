---
layout: post
title: Java - 추상 클래스 vs 인터페이스
date: 2025-07-19 17:20:23 +0900
category: Java
---
# 추상 클래스 vs 인터페이스

## 0. 한눈에 보는 차이점 요약

| 항목 | 추상 클래스 (`abstract class`) | 인터페이스 (`interface`) |
|---|---|---|
| 상속/구현 | **단일 상속** (`extends`) | **다중 구현** (`implements`) 가능 |
| 멤버 | **필드(상태)**, 생성자, `protected` 멤버 가질 수 있음 | **상수만** (`public static final`) 필드, 인스턴스 필드 불가 |
| 메서드 구현 | 추상 + 일반 메서드 혼재 가능 | **추상 메서드** + `default`/`static`(Java 8+) + `private`(Java 9+) |
| 인스턴스화 | 불가(서브클래싱 필요) | 불가(구현 클래스 필요) |
| 공통 로직 공유 | **상태 + 보호된 유틸리티**로 공유에 강함 | **상태 없음**, 기본 동작은 `default`로 공유 |
| API 진화(호환성) | 메서드 추가 → **하위 클래스 수정 필요** 가능성 큼 | 메서드 추가 시 **`default` 제공**으로 **호환성↑** |
| 목적/역할 | **베이스 스켈레톤** + 공통 상태/동작 제공 | **규약(Contract)** 정의, **유연한 교체성** 제공 |

> **실무 원칙(요약)**  
> - “**여러 구현을 느슨히 교체**”가 핵심이면 **인터페이스 우선**.  
> - “**공유 상태/보호 유틸**”이 필요하면 **추상 클래스**가 적합.  
> - 장기 API 진화/호환성이 중요하면 **인터페이스 + default**가 유리.

---

## 1. 추상 클래스 (Abstract Class)

### 1.1 기본 문법과 특징
```java
public abstract class Animal {
    protected final String name;

    protected Animal(String name) { // 생성자 가능
        this.name = name;
    }

    public abstract void sound();   // 추상 메서드
    public void breathe() {         // 일반(구현) 메서드
        System.out.println(name + "가 숨을 쉰다");
    }
}
```
- **상태(필드)**, **생성자**, **접근 제어자**(`protected` 등) 활용 가능.
- 템플릿 메서드 패턴 등, **공통 로직 + 확장 지점** 제공에 유리.

### 1.2 템플릿 메서드 패턴(공통 알고리즘 + 후크)
```java
public abstract class FileExporter {
    // 템플릿
    public final void export(String path) {
        byte[] data = render();
        write(path, data);
        postExport(path);
    }
    protected abstract byte[] render();
    protected void write(String path, byte[] data) { /* 공통 IO */ }
    protected void postExport(String path) { /* 선택 훅 */ }
}

public class PdfExporter extends FileExporter {
    @Override protected byte[] render() { /* PDF 렌더링 */ return new byte[0]; }
}
```
- 공통 알고리즘은 상위에서 **고정**, 세부만 하위에서 **오버라이드**.

### 1.3 상태 공유/보호 유틸
```java
public abstract class BaseRepository {
    protected final javax.sql.DataSource ds;
    protected BaseRepository(javax.sql.DataSource ds) { this.ds = ds; }

    protected java.sql.Connection conn() throws java.sql.SQLException {
        return ds.getConnection();
    }
}
```
- **보호된(protected)** 유틸로 하위에만 공개(캡슐화 + 재사용).

---

## 2. 인터페이스 (Interface)

### 2.1 기본 문법과 특징
```java
public interface Payment {
    boolean pay(int amount); // public abstract 생략
}
```
- **인스턴스 필드 불가** (모든 필드는 `public static final`, 즉 상수).
- Java 8+: `default`/`static` 메서드, Java 9+: `private` 메서드 지원.

### 2.2 default / static / private 메서드
```java
public interface Retryable {
    int DEFAULT_RETRY = 3; // 상수

    boolean tryOnce();

    default boolean tryWithRetry() { // 기본 구현 공유
        int n = DEFAULT_RETRY;
        while (n-- > 0) if (tryOnce()) return true;
        return false;
    }

    static void log(String m) { System.out.println("[R] " + m); } // 유틸
    private void helper() { /* Java9+ 내부 공통 로직 */ }
}
```
- `default`는 **상태 없이**(필드 없음) **동작 템플릿** 제공.
- **다중 구현**으로 **교체/확장에 매우 유리**.

### 2.3 함수형 인터페이스(람다와 결합)
```java
@FunctionalInterface
public interface Converter<S, T> {
    T convert(S source);
    // 추상 메서드 1개 → 람다로 구현 가능
}

Converter<String, Integer> c = s -> Integer.parseInt(s);
```

---

## 3. 다중 상속/다중 구현과 충돌 해결

### 3.1 인터페이스 다이아몬드(default 충돌)
```java
interface A { default void hello() { System.out.println("A"); } }
interface B { default void hello() { System.out.println("B"); } }

class C implements A, B {
    @Override public void hello() {
        A.hello(); // 컴파일 오류
        // 해결: 명시적 수퍼 호출
        A.super.hello(); // OK
        // 또는 B.super.hello();
    }
}
```
- **동일 시그니처의 `default`** 가 충돌하면 **구현 클래스에서 반드시 명시적으로 해결**.

### 3.2 클래스 vs 인터페이스 충돌
- **클래스의 메서드가 인터페이스 default** 보다 **우선**.  
  (클래스가 제공하는 구현이 있으면 그것을 사용)

---

## 4. 선택 기준 — 의사결정 트리 & 체크리스트

### 4.1 의사결정 트리(텍스트 도식)
```
여러 구현 교체/확장(플러그인·테스트 더블)이 핵심인가?
 ├─ 예 → 인터페이스
 │    └─ 기본 로직 공유가 꼭 필요? → default로 제공
 │
 └─ 아니오 → 공통 상태/보호 유틸/생성자 로직 공유 필요한가?
      ├─ 예 → 추상 클래스
      └─ 아니오 → 단순 유틸은 정적 유틸 클래스로도 충분
```

### 4.2 체크리스트
- [ ] **다중 구현**이 필요/유리한가? → 인터페이스
- [ ] 공통 **상태/생성자/보호 유틸**이 필요한가? → 추상 클래스
- [ ] 장기적 **API 진화/호환성**이 핵심인가? → 인터페이스 + `default`
- [ ] **테스트 더블/모킹**을 빈번히 쓰는가? → 인터페이스 우선
- [ ] 런타임에 구현을 바꿔 끼우는가? → 전략(인터페이스)

---

## 5. API 진화와 호환성(실무 핵심)

### 5.1 인터페이스에 메서드 추가
- **기존 구현체**가 많을 때 **바이너리 호환**을 지키려면 **`default` 구현**을 제공:
```java
public interface Cache {
    Object get(String key);
    default void clear() { /* noop (호환용 기본 동작) */ }
}
```

### 5.2 추상 클래스에 메서드 추가
- 하위 클래스가 **컴파일 오류** 발생 가능 → **템플릿의 선택 훅**을 미리 준비(빈 구현):
```java
public abstract class Base {
    protected void onEvent() {} // 미리 빈 훅
}
```

### 5.3 “상수 인터페이스” 안티패턴
```java
public interface Constants { int A=1; int B=2; } // ❌ 지양
```
- 상수는 **유틸 클래스의 `public static final`** 혹은 **열거형(enum)** 으로.

---

## 6. 실전 예제 1 — 스토리지 SPI(인터페이스) + 베이스(추상 클래스)

### 6.1 인터페이스 규약
```java
public interface Storage {
    void put(String key, byte[] data);
    byte[] get(String key);
    default boolean exists(String key) { return get(key) != null; }
}
```

### 6.2 공통 IO/검증을 담은 추상 베이스
```java
public abstract class AbstractStorage implements Storage {
    protected void validateKey(String key) {
        if (key == null || key.isBlank()) throw new IllegalArgumentException("key");
    }
    @Override public void put(String key, byte[] data) {
        validateKey(key);
        doPut(key, java.util.Objects.requireNonNull(data));
    }
    @Override public byte[] get(String key) {
        validateKey(key);
        return doGet(key);
    }
    protected abstract void doPut(String key, byte[] data);
    protected abstract byte[] doGet(String key);
}
```

### 6.3 구현: 로컬/메모리/S3 등
```java
public class InMemoryStorage extends AbstractStorage {
    private final java.util.Map<String, byte[]> map = new java.util.concurrent.ConcurrentHashMap<>();
    @Override protected void doPut(String key, byte[] data) { map.put(key, data); }
    @Override protected byte[] doGet(String key) { return map.get(key); }
}
```

- **규약은 인터페이스**, **공통 로직은 추상 클래스**로 분리 → **교체성 + 재사용** 동시 확보.

---

## 7. 실전 예제 2 — 결제 전략(인터페이스) vs 템플릿(추상 클래스)

```java
public interface Payment {
    Receipt pay(int amount);
}

public abstract class AbstractPayment implements Payment {
    @Override public final Receipt pay(int amount) {
        preCheck(amount);                 // 공통 전처리
        Receipt r = doPay(amount);        // 변하는 부분
        postLog(r);                       // 공통 후처리
        return r;
    }
    protected void preCheck(int amount) { if (amount <= 0) throw new IllegalArgumentException(); }
    protected void postLog(Receipt r) { /* 로그 */ }
    protected abstract Receipt doPay(int amount);
}

public class CardPayment extends AbstractPayment {
    @Override protected Receipt doPay(int amount) { /* 카드 로직 */ return new Receipt("CARD", amount); }
}

public class KakaoPay implements Payment {  // 템플릿이 필요 없다면 바로 인터페이스만
    @Override public Receipt pay(int amount) { /* 카카오 로직 */ return new Receipt("KAKAO", amount); }
}

public record Receipt(String method, int amount) {}
```
- **둘 다 쓸 수 있음**: 템플릿이 필요한 구현은 추상 클래스 상속, 단순 구현은 인터페이스만.

---

## 8. sealed 클래스/인터페이스 (Java 17+)

```java
public sealed interface Expr permits Num, Add {}
public record Num(int v) implements Expr {}
public record Add(Expr l, Expr r) implements Expr {}

static int eval(Expr e) {
    return switch (e) {
        case Num n -> n.v();
        case Add a -> eval(a.l()) + eval(a.r());
    };
}
```
- **허용된 하위 타입만** 구현 가능 → **모델 폐쇄**와 `switch` **완전성 검사**로 안정↑.  
- 추상 클래스/인터페이스 **양쪽 모두 sealed** 가능.

---

## 9. 성능·설계 관점 메모
- **인스턴스 메서드 다형성 호출**은 JIT가 상황에 따라 **인라이닝/역가상화(devirtualization)** 가능.  
  - `final`/`sealed`로 **가능성↑**.  
- 인터페이스/추상 클래스 간 **성능 차이는 미미**(설계가 우선).  
- 과도한 상속 트리/복잡한 계층은 JIT 최적화를 방해할 수 있으므로 **단순하게 유지**.

---

## 10. 테스트 전략

- **인터페이스 우선 설계** → **목(Mock)/페이크(Fake)** 주입 쉬움.
```java
class FakeStorage implements Storage {
    private final java.util.Map<String, byte[]> m = new java.util.HashMap<>();
    public void put(String k, byte[] d) { m.put(k, d); }
    public byte[] get(String k) { return m.get(k); }
}
```
- 추상 클래스는 **상위의 공통 로직** 단위 테스트, 구현 클래스는 **협력 테스트**로 분리.

---

## 11. 흔한 함정과 예방

| 함정 | 왜 문제인가 | 대안 |
|---|---|---|
| “상수 인터페이스” | 구현도 아닌데 타입 오염 | 유틸 클래스/enum 사용 |
| 인터페이스에 너무 많은 메서드 | 구현 부담·결합↑ | 인터페이스 **분리**(ISP) |
| 추상 클래스 남용 | 상속 고착·복잡도↑ | 합성/전략으로 대체 검토 |
| default 남발 | 모호한 규약·다이아몬드 충돌 | 최소화, 충돌 시 **명시적 해결** |
| API 진화 시 추상 클래스에 메서드 추가 | 하위 클래스 전면 수정 | 인터페이스 + `default` 우선 |

---

## 12. 종합 예제 — “알림” 모듈 설계 (혼용)

```java
public interface Notifier {
    void send(String to, String msg);
    default void broadcast(java.util.List<String> recipients, String msg) {
        for (String r : recipients) send(r, msg);
    }
}

public abstract class BaseNotifier implements Notifier {
    protected final String serviceName;
    protected BaseNotifier(String serviceName){ this.serviceName = serviceName; }

    protected void audit(String to, String msg) { /* 공통 감사 로깅 */ }

    @Override public final void send(String to, String msg) {
        validate(to, msg);
        doSend(to, msg);
        audit(to, msg);
    }
    protected void validate(String to, String msg) {
        if (to == null || to.isBlank() || msg == null) throw new IllegalArgumentException();
    }
    protected abstract void doSend(String to, String msg);
}

public class EmailNotifier extends BaseNotifier {
    public EmailNotifier(){ super("EMAIL"); }
    @Override protected void doSend(String to, String msg) { /* SMTP */ }
}

public class SlackNotifier implements Notifier { // 템플릿 없이 가볍게
    @Override public void send(String to, String msg) { /* Webhook */ }
}
```
- **계약(Notifier)** 은 인터페이스로,  
- **공통 감사/검증**은 추상 베이스로 제공,  
- 가벼운 구현은 인터페이스만 구현.

---

## 13. 시각 요약

```
[Interface: 규약/교체성]
      ↑ implements (다중)
+-----------------------+
|  Concrete Impl A      |
+-----------------------+
|  Concrete Impl B      |
+-----------------------+

[Abstract Base: 공통상태/템플릿]
           ↑ extends (단일)
+---------------------------+
| Concrete Subclass         |
+---------------------------+
```

---

## 14. 마무리 요약

- **인터페이스**: 규약 정의·교체성·테스트 용이·API 진화( `default` )에 유리  
- **추상 클래스**: 공통 **상태/생성자/보호 유틸**·템플릿 제공에 유리  
- **혼용**: “규약은 인터페이스”, “공통 로직은 추상 베이스”로 분리하면 가장 실전적

---

## 15. 연습 과제

1) `Storage` 인터페이스에 `delete(String key)` 추가 후, **`default` 구현**으로 호환성 지키기.  
2) 결제 모듈에서 `AbstractPayment` 를 제거하고 **전략 인터페이스 + 공통 헬퍼 유틸**로 치환해보기(구성 vs 상속 비교).  
3) `sealed interface Expr` 로 표현식을 정의하고, `switch` 패턴 매칭으로 안정적 평가기 구현.