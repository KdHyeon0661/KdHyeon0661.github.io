---
layout: post
title: C - 동적 메모리 할당
date: 2024-08-25 19:20:23 +0900
category: C
---
# 동적 메모리 할당 (`malloc`, `free`)

## 한 화면 요약 (필수 10줄)

```c
// 1) 크기 계산 시 오버플로 방지
size_t n, sz;
if (n && SIZE_MAX / sizeof(int) < n) { /* overflow */ }

// 2) malloc → NULL 체크 → 사용 → free → NULL 대입
int *p = malloc(n * sizeof *p);
if (!p) { /* OOM 처리 */ }
free(p); p = NULL;

// 3) realloc은 임시 포인터로 (실패 안전)
int *tmp = realloc(p, new_bytes);
if (!tmp) { /* p는 여전히 유효 → 누수/데이터 보존 */ }
else p = tmp;

// 4) calloc은 0으로 초기화됨(바이트 단위)
int *z = calloc(n, sizeof *z);

// 5) free(NULL)는 no-op, 중복 free는 UB(절대 금지)
```

---

## 왜 동적 메모리인가?

- **실행 중 크기가 결정되는 자료구조**(입력 크기, 네트워크 수신 길이 등)에 필수.
- **장점**: 유연성, 큰 데이터(스택 제한 회피), 모듈화(소유권 분리).
- **코스트**: 할당기 호출 오버헤드, **단편화(fragmentation)**, **에러 처리 복잡성**.

---

## `malloc(size_t size)`

```c
void *malloc(size_t size);
```

- **힙(heap)** 에서 `size` 바이트를 **초기화 없이** 확보.
- 성공: 블록 시작 주소(`void*`), 실패: `NULL`.
- 반환 포인터는 **적어도 `max_align_t` 정렬**을 충족(일반 객체에 충분).

```c
#include <stdlib.h>
#include <stdio.h>

int *arr = malloc(5 * sizeof *arr); // 캐스팅 불필요: C에서는 void* → T* 암시 변환
if (!arr) { perror("malloc"); return 1; } // 실패 확인
/* ... 사용 ... */
free(arr); arr = NULL;
```

> **초기화되지 않음**: 읽기 전에 반드시 값을 채우거나 `memset`/`calloc` 사용.

### 정수 오버플로 방지 (중요)

메모리 총량 $$B = n \times \text{sizeof}(T)$$ 계산 시,
$$
n > \left\lfloor \frac{\text{SIZE\_MAX}}{\text{sizeof}(T)} \right\rfloor
$$
이면 **오버플로**가 발생합니다(작은 값으로 wrap, 과소할당 → 버퍼 오버런 위험).

```c
size_t n = user_input();
if (n && SIZE_MAX / sizeof *arr < n) { /* overflow */ return -1; }
arr = malloc(n * sizeof *arr);
```

---

## `free(void *ptr)`

```c
void free(void *ptr);
```

- `malloc`/`calloc`/`realloc`로 얻은 블록을 **반환**.
- 규칙:
  - **같은 포인터를 두 번 `free`하지 않는다**(이중 해제 = UB).
  - **`free(NULL)`는 안전**(no-op).
  - **해제 후 즉시 `NULL` 대입** → UAF(Use-After-Free) 예방.

```c
free(arr);
arr = NULL; // 습관화
```

- **혼합 금지**: 다른 할당기/라이브러리에서 받은 포인터를 표준 `free`로 해제하면 UB.

---

## `calloc(count, size)` — 0으로 초기화

```c
void *calloc(size_t count, size_t size);
```

- `count*size` 바이트 **할당 + 0으로 초기화**(바이트 단위).
- **오버플로 자동 체크**를 구현체가 수행하는 경우가 많아 **안전성↑**.

```c
int *z = calloc(5, sizeof *z); // 모두 0
if (!z) { /* OOM */ }
/* ... */
free(z);
```

> 0 초기화는 **비트 0**을 의미. 포인터 필드, `float` 값 등도 “0 비트”로 맞춰짐(표준이 허용하는 일반 표현). 비트필드/패딩은 가정하지 말 것.

---

## `realloc(ptr, new_size)` — 크기 조정

```c
void *realloc(void *ptr, size_t new_size);
```

- 의미:
  - `ptr == NULL`이면 `malloc(new_size)`와 동일.
  - `new_size == 0`이면 `free(ptr)`와 유사(일부 구현은 `NULL` 또는 유효 포인터 반환 — **반드시 매뉴얼 확인**).
  - **확장 시**: 새 영역으로 **이동할 수 있음**(원 포인터 무효).
  - **내용은 `min(old,new)` 바이트 범위에서 유지**.

### 실패 안전 패턴

```c
int *p = malloc(old_bytes);
if (!p) { /* ... */ }
/* ... 작업 ... */
int *tmp = realloc(p, new_bytes);
if (!tmp) {
    // 실패: p는 여전히 유효(데이터 보존). 누수 없음.
    /* 복구/축소/로그 등 */
} else {
    p = tmp; // 성공: 새로운 블록(주소가 바뀌었을 수 있음)
}
```

> **절대** `p = realloc(p, new);` 한 줄로 쓰지 마세요 — 실패 시 원 포인터를 잃어 **누수** 발생.

### 축소, 확장, 제자리 이동

- **축소**: 같은 주소일 수도, 다를 수도. 프로그램은 **주소 변경 가능성**을 항상 고려.
- **확장**: 여유 공간이 충분하면 **제자리 확장**. 아니면 **새 블록으로 이동**.

---

## 사용자 입력 기반 동적 배열 — 안전 템플릿

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

static int read_size(size_t *out) {
    long long v;
    if (scanf("%lld", &v) != 1) return 0;
    if (v < 0 || v > (long long)SIZE_MAX) return 0;
    *out = (size_t)v; return 1;
}

int main(void) {
    size_t n;
    printf("배열 크기를 입력하세요: ");
    if (!read_size(&n)) { fputs("invalid size\n", stderr); return 1; }

    if (n && SIZE_MAX / sizeof(int) < n) { fputs("overflow\n", stderr); return 1; }

    int *arr = malloc(n * sizeof *arr);
    if (!arr) { perror("malloc"); return 1; }

    for (size_t i=0; i<n; ++i) arr[i] = (int)(i+1);
    for (size_t i=0; i<n; ++i) printf("%d ", arr[i]);
    puts("");

    free(arr); arr = NULL;
    return 0;
}
```

> 입력 파싱은 `scanf`보다 `fgets`+`strtoull` 조합이 안전한 경우가 많습니다.

---

## — `realloc` 성장 전략

```c
#include <stdlib.h>
#include <string.h>

typedef struct { int *data; size_t len, cap; } ivec;

static int ivec_init(ivec *v) { v->data=NULL; v->len=v->cap=0; return 0; }

static int ivec_grow(ivec *v, size_t need) {
    if (need <= v->cap) return 0;
    size_t ncap = v->cap ? v->cap : 1;
    while (ncap < need) ncap <<= 1;               // 2배성장
    if (ncap > SIZE_MAX / sizeof *v->data) return -1;
    int *tmp = realloc(v->data, ncap * sizeof *tmp);
    if (!tmp) return -1;
    v->data = tmp; v->cap = ncap; return 0;
}

static int ivec_push(ivec *v, int x) {
    if (ivec_grow(v, v->len+1)) return -1;
    v->data[v->len++] = x; return 0;
}

static void ivec_free(ivec *v) { free(v->data); v->data=NULL; v->len=v->cap=0; }
```

핵심:
- **지수 성장을 통한 할당 횟수 감소**.
- **오버플로 체크**.
- `realloc` 실패 안전(`tmp` 사용).

---

## `calloc` vs `malloc+memset` 성능/의미

- 일부 시스템에서 `calloc`은 **커밋 지연(zero pages)** 으로 빠를 수 있음.
- 의미적 차이: **항상 0 초기화 보장** → 로직 명확성·취약점 예방.

---

## 동적 2D 배열 — “연속 블록 + 포인터 테이블” 권장

연속 블록 장점: 캐시 친화, 단일 I/O, `memcpy` 가능.

```c
int **make_2d(int r, int c) {
    if (r<=0 || c<=0) return NULL;
    int **row = malloc((size_t)r * sizeof *row);
    int  *blk = malloc((size_t)r * c * sizeof *blk);
    if (!row || !blk) { free(row); free(blk); return NULL; }
    for (int i=0; i<r; ++i) row[i] = blk + (size_t)i * c;
    return row; // 해제: free(row[0]); free(row);
}
```

해제:
```c
void free_2d(int **a) {
    if (!a) return;
    free(a[0]); // 연속 블록
    free(a);
}
```

> 각 행을 따로 `malloc`하는 방식은 **단편화/오버헤드**를 키울 수 있음.

---

## 문자열/가변 버퍼 — 안전 연결과 자동 확장

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct { char *s; size_t len, cap; } sbuf;

static int sbuf_grow(sbuf *b, size_t add) {
    size_t need = b->len + add + 1; // +1 for '\0'
    if (need <= b->cap) return 0;
    size_t ncap = b->cap ? b->cap : 16;
    while (ncap < need) ncap <<= 1;
    char *tmp = realloc(b->s, ncap);
    if (!tmp) return -1;
    b->s = tmp; b->cap = ncap; return 0;
}

static int sbuf_cat(sbuf *b, const char *src) {
    size_t add = strlen(src);
    if (sbuf_grow(b, add)) return -1;
    memcpy(b->s + b->len, src, add+1); // '\0' 포함 복사
    b->len += add; return 0;
}

static void sbuf_free(sbuf *b) { free(b->s); b->s=NULL; b->len=b->cap=0; }
```

---

## 정렬/특수 할당: `aligned_alloc`, `posix_memalign`

- **큰 벡터/SIMD/디바이스 DMA**용으로 정렬이 필요한 경우 사용.
- 표준 C11:
  ```c
  void *aligned_alloc(size_t alignment, size_t size); // size는 alignment의 배수
  ```
- POSIX:
  ```c
  int posix_memalign(void **memptr, size_t alignment, size_t size);
  ```

해제는 **일반 `free`**.

---

## 소유권(ownership)과 API 설계

- **생성자는 소유권을 반환**하고, **파괴자는 반납**.
- 함수 인터페이스에서 **누가 `free`하는지 문서화**.
- 이중 포인터로 **소유 이전**을 명확히:

```c
int make_buf(size_t n, unsigned char **out) {
    if (!out || !n) return -1;
    if (n > SIZE_MAX/sizeof **out) return -1;
    unsigned char *p = malloc(n * sizeof **out);
    if (!p) return -1;
    *out = p; return 0; // 호출자 소유
}
```

---

## 실패/해제 규약 — `goto cleanup` 패턴

```c
int f(void) {
    void *a=NULL, *b=NULL;
    a = malloc(128); if(!a) goto FAIL;
    b = malloc(256); if(!b) goto FAIL;
    /* ... */
    free(b); free(a); return 0;
FAIL:
    free(b); free(a); return -1;
}
```

- 중간 어디서 실패해도 **한 곳에서 정리** → 누수/이중 해제 방지.

---

## 메모리 진단 습관

- 컴파일 경고 최대로: `-Wall -Wextra -Wpedantic` 또는 `/W4`.
- 런타임 도구(플랫폼에 따라): UAF, OOB, 누수 탐지.
- 작은 모듈부터 **유닛 테스트**로 할당/해제 균형 검증.

---

## 보안/안전 체크리스트

- [ ] 모든 `malloc/calloc/realloc`의 **반환값 검사**.
- [ ] **오버플로 검사**(곱셈/합산 전).
- [ ] `realloc`은 **임시 포인터** 사용(실패 안전).
- [ ] **경계 검사**: 인덱스/길이/남은 공간.
- [ ] **해제 후 NULL** 대입, 중복 free 방지.
- [ ] **free(NULL) 허용** 활용.
- [ ] **소유권 명시**: 누가 `free`?
- [ ] **정렬 요구**가 있으면 전용 API 사용.
- [ ] **섞어 쓰지 않기**: 다른 라이브러리에서 받은 포인터를 임의로 free하지 않기.
- [ ] **초기화**: 민감 데이터는 사용 후 `memset_s` 등으로 지우는 정책 고려.

---

## 수식으로 보는 크기/오버플로

총 바이트 수:
$$
B = n \times \mathrm{sizeof}(T)
$$

안전 조건:
$$
n \le \left\lfloor \frac{\mathrm{SIZE\_MAX}}{\mathrm{sizeof}(T)} \right\rfloor
$$

`realloc` 성장 비용(대략):
$$
\text{할당 호출 수} = O(\log n), \quad \text{총 복사 비용} = O(n)
$$

---

## FAQ

**Q1. `realloc(ptr, 0)`는 쓰면 안 되나요?**
A. 구현마다 다릅니다. 어떤 곳은 `NULL`, 어떤 곳은 특수 포인터를 반환할 수 있습니다. **호환성 측면에서 `free(ptr)`을 명시적으로 호출**하세요.

**Q2. `calloc`이 항상 `malloc+memset`보다 빠른가요?**
A. 아닙니다. 구현/패턴/페이지 동작에 따라 다릅니다. 의미(0 초기화)가 코드 의도와 맞을 때 선택하세요.

**Q3. 동적 2D에서 `int **a`로 각 행을 개별 `malloc`해도 되나요?**
A. 가능합니다. 다만 **단편화/할당기 오버헤드/캐시 효율**이 나빠질 수 있습니다. 가능하면 **연속 블록 + 포인터 테이블**을 고려하세요.

**Q4. `free` 후 바로 같은 포인터를 다시 `malloc`해서 재사용해도 되나요?**
A. 가능합니다. 그러나 **해제 후 포인터를 즉시 `NULL`로 바꾸고**, 새로운 결과를 다시 대입하는 습관이 UAF 방지에 유익합니다.

---

## 종합 예제: 안전한 입력 → 동적 누적 → 크기 확장 → 정렬/출력 → 정리

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct { int *a; size_t len, cap; } vec;

static int vec_init(vec *v){ v->a=NULL; v->len=v->cap=0; return 0; }

static int vec_grow(vec *v, size_t need){
    if (need <= v->cap) return 0;
    size_t ncap = v->cap ? v->cap : 8;
    while (ncap < need) ncap <<= 1;
    if (ncap > SIZE_MAX / sizeof *v->a) return -1;
    int *tmp = realloc(v->a, ncap * sizeof *tmp);
    if (!tmp) return -1;
    v->a = tmp; v->cap = ncap; return 0;
}

static int vec_push(vec *v, int x){
    if (vec_grow(v, v->len+1)) return -1;
    v->a[v->len++] = x; return 0;
}

static int cmp_int(const void *x, const void *y){
    int a = *(const int*)x, b = *(const int*)y;
    return (a>b) - (a<b);
}

static void vec_free(vec *v){ free(v->a); v->a=NULL; v->len=v->cap=0; }

int main(void){
    vec v; vec_init(&v);

    int x;
    while (scanf("%d", &x) == 1) {
        if (vec_push(&v, x)) { fputs("OOM\n", stderr); vec_free(&v); return 1; }
    }

    qsort(v.a, v.len, sizeof *v.a, cmp_int);
    for (size_t i=0; i<v.len; ++i) printf("%d ", v.a[i]);
    puts("");

    vec_free(&v);
    return 0;
}
```

---

## 요약

| 항목 | 핵심 |
|---|---|
| `malloc` | 초기화 없음, **오버플로 체크** 후 호출 |
| `calloc` | 0 초기화, 곱 연산 **안전성↑** |
| `realloc` | **임시 포인터**로 실패 안전, 주소 변경 고려 |
| `free` | 해제 후 `NULL`, **이중 해제 금지**, `free(NULL)` 허용 |
| 크기 계산 | $$n \le \left\lfloor \frac{\mathrm{SIZE\_MAX}}{\mathrm{sizeof}(T)} \right\rfloor$$ |
| 2D | **연속 블록 + 포인터 테이블** 권장 |
| API | 소유권/수명 명시, `goto cleanup` 정리 |
| 진단 | 경고 최대로, 런타임 메모리 도구, 단위 테스트 |
