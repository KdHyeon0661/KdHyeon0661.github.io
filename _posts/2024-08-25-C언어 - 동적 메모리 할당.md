---
layout: post
title: C - 동적 메모리 할당
date: 2024-08-25 19:20:23 +0900
category: C
---
# 동적 메모리 할당 (`malloc`, `free`)

## 핵심 요약 (10줄)

```c
// 1) 크기 계산 시 오버플로우를 반드시 방지하세요.
size_t n;
if (n && SIZE_MAX / sizeof(int) < n) { /* 오버플로우 처리 */ }

// 2) 할당, 검사, 사용, 해제의 기본 흐름을 지키세요.
int *p = malloc(n * sizeof *p);
if (!p) { /* 메모리 부족 처리 */ }
free(p);
p = NULL; // Use-After-Free 방지

// 3) realloc은 실패 시 원본 데이터를 보존해야 합니다.
int *tmp = realloc(p, new_size);
if (!tmp) { /* p는 그대로 유효함 */ }
else { p = tmp; }

// 4) calloc은 할당과 동시에 0으로 초기화합니다.
int *z = calloc(n, sizeof *z);

// 5) free(NULL)은 안전하나, 중복 해제는 치명적 오류입니다.
```

---

## 동적 메모리 할당이 필요한 이유

프로그램 실행 중에야 비로소 크기가 결정되는 데이터를 다루려면 동적 메모리 할당이 필수적입니다. 사용자 입력, 파일 크기, 네트워크 패킷 등은 미리 예측하기 어렵기 때문이죠.

**장점**은 뚜렷합니다. 필요한 만큼만 힙(Heap) 영역에서 유연하게 메모리를 할당받을 수 있어, 스택의 제한된 크기 문제를 피하고, 데이터의 소유권과 수명을 명확히 관리할 수 있습니다.

하지만 **대가**도 따릅니다. 할당과 해제라는 런타임 오버헤드가 발생하고, 메모리 단편화가 생길 수 있으며, 에러 처리를 철저히 해야 하는 부담이 늘어납니다.

---

## `malloc`: 초기화되지 않은 메모리 할당

```c
void *malloc(size_t size);
```
`malloc` 함수는 요청한 `size` 바이트만큼의 메모리 블록을 힙에서 할당합니다. 성공하면 해당 블록의 시작 주소(`void*`)를, 실패하면 `NULL`을 반환합니다. 반드시 기억해야 할 점은, 이 함수가 **메모리의 내용을 초기화하지 않는다**는 것입니다. 쓰레기 값이 그대로 있을 수 있으니, 사용 전 반드시 값을 채워야 합니다.

```c
#include <stdlib.h>
#include <stdio.h>

int *arr = malloc(5 * sizeof(*arr)); // 형변환은 C에서 불필요합니다.
if (!arr) {
    perror("malloc 실패");
    return 1;
}
// arr 사용...
free(arr);
arr = NULL;
```

### 정수 오버플로우: 조용한 위험

`malloc(n * sizeof(int))`와 같은 계산에서 `n`이 너무 크면, `n * sizeof(int)`의 결과가 `size_t` 범위를 넘어 '작은 값'으로 돌아가는(wrap-around) 오버플로우가 발생할 수 있습니다. 이는 예상보다 훨씬 작은 메모리가 할당되어 버퍼 오버런으로 이어질 수 있는 심각한 보안 결함입니다.

```c
size_t n = 사용자_입력값();
// 오버플로우 방지: 계산 전에 나눗셈으로 검사합니다.
if (n && SIZE_MAX / sizeof(*arr) < n) {
    // 처리할 수 없는 크기입니다.
    return -1;
}
arr = malloc(n * sizeof(*arr));
```

---

## `free`: 할당된 메모리 반환

```c
void free(void *ptr);
```
`free`는 `malloc`, `calloc`, `realloc`으로 얻은 메모리를 시스템에 돌려주는 함수입니다. 간단해 보이지만, 잘못 사용하면 프로그램을 불안정하게 만드는 주범이 됩니다.

**반드시 지켜야 할 규칙**:
1.  **이중 해제(Double Free) 금지**: 이미 `free`한 포인터를 다시 `free`하면 미정의 동작(Undefined Behavior)을 일으킵니다.
2.  **`free(NULL)`은 안전합니다**: 아무 작업도 수행하지 않으므로, 포인터 초기화나 에러 처리 시 유용하게 쓸 수 있습니다.
3.  **해제 후 널 포인터 할당**: `free(p); p = NULL;` 습관을 들이면, 이미 해제된 메모리를 실수로 접근하는 Use-After-Free 버그를 방지하는 데 도움이 됩니다.

```c
free(arr);
arr = NULL; // 이 지점 이후로 arr에 접근하면 명확한 오류를 발견할 수 있습니다.
```

**주의**: 한 라이브러리(예: 특정 그래픽 라이브러리)에서 할당받은 포인터를 표준 C 라이브러리의 `free`로 해제하면 안 됩니다. 반드시 해당 라이브러리에서 제공하는 해제 함수를 사용해야 합니다.

---

## `calloc`: 0으로 초기화된 메모리 할당

```c
void *calloc(size_t count, size_t size);
```
`calloc`은 `count * size` 바이트를 할당하고, 그 내용을 **모든 비트를 0으로 설정**합니다. 이는 숫자 타입으로는 `0`, 포인터 타입으로는 `NULL`에 해당하는 값으로 초기화됨을 의미합니다.

```c
int *zero_array = calloc(5, sizeof(*zero_array)); // 모든 요소가 0인 배열
if (!zero_array) { /* 메모리 부족 처리 */ }
```
`calloc`의 큰 장점은 두 인자를 분리하여 받기 때문에, 내부적으로 `count * size`의 오버플로우를 검사하는 구현이 많아 **`malloc`에 비해 상대적으로 안전하다**는 점입니다. 물론, 표준이 이를 강제하는 것은 아니므로, 매우 큰 값을 다룰 때는 여전히 주의가 필요합니다.

> **`0`의 의미**: `calloc`이 보장하는 것은 '모든 비트가 0'입니다. 이 표현이 `float` 0.0이나 `NULL` 포인터의 내부 표현과 일치한다는 것은 일반적으로 보장되지만, 이식성이 극단적으로 중요한 코드라면 언어 표준을 다시 확인하세요.

---

## `realloc`: 메모리 블록 크기 조정

```c
void *realloc(void *ptr, size_t new_size);
```
기존 메모리 블록의 크기를 `new_size` 바이트로 조정합니다. 이 함수의 동작은 다음과 같이 이해해야 합니다.

*   **`ptr`이 `NULL`일 때**: `malloc(new_size)`와 동일하게 작동합니다.
*   **`new_size`가 0일 때**: 동작이 구현에 따라 다릅니다. 어떤 시스템은 `free(ptr)`처럼 동작하고 `NULL`을 반환하며, 어떤 시스템은 크기가 0인 유효한 포인터를 반환하기도 합니다. **이식성을 고려한다면 `realloc(ptr, 0)` 대신 명시적으로 `free(ptr)`를 호출하는 것이 가장 안전합니다.**
*   **크기 조정 시**: 필요한 경우 메모리 블록을 **새로운 위치로 이동시킬 수 있습니다**. 이때 기존 데이터는 새로운 크기(`new_size`)와 기존 크기 중 작은 값만큼 보존됩니다. 블록이 이동하면, **기존 `ptr`은 더 이상 유효하지 않게 됩니다**.

### 안전한 `realloc` 사용 패턴
`realloc`이 실패하면 `NULL`을 반환하지만, 이때 **원본 포인터(`ptr`)는 여전히 유효한 상태로 남아 있습니다**. 따라서 아래와 같은 패턴으로 사용해야 합니다.

```c
int *p = malloc(100 * sizeof(*p));
// ... p를 사용 ...

int *temp = realloc(p, 200 * sizeof(*p)); // 임시 포인터에 결과 저장
if (!temp) {
    // 확장 실패! 하지만 p는 아직 100개의 원본 데이터를 가지고 있음.
    // 여기서 다른 복구 로직을 수행할 수 있습니다.
    // free(p); // 필요에 따라 원본을 유지하거나 해제합니다.
    return -1;
} else {
    // 확장 성공. 원본 p는 temp로 대체되었으며, 더 이상 접근하면 안 됩니다.
    p = temp;
}
```

**절대 다음과 같이 작성하지 마세요!**
```c
p = realloc(p, new_size); // realloc 실패 시 p에 NULL이 들어가 원본 데이터를 잃고 메모리 누수가 발생합니다.
```

---

## 실전 예제: 사용자 입력을 받아 동적 배열 만들기

이제 배운 개념들을 종합해, 사용자로부터 크기를 입력받아 동적 배열을 생성하고 관리하는 안전한 프로그램을 만들어보겠습니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

// 안전하게 size_t 범위의 정수를 읽는 도우미 함수
static int read_size(size_t *out) {
    long long input;
    if (scanf("%lld", &input) != 1) return 0; // 읽기 실패
    if (input < 0 || input > (long long)SIZE_MAX) return 0; // 범위 초과
    *out = (size_t)input;
    return 1;
}

int main(void) {
    size_t n;

    printf("생성할 배열의 크기를 입력하세요: ");
    if (!read_size(&n)) {
        fputs("유효하지 않은 크기입니다.\n", stderr);
        return 1;
    }

    // 1. 오버플로우 검사
    if (n && SIZE_MAX / sizeof(int) < n) {
        fputs("요청한 크기가 너무 큽니다.\n", stderr);
        return 1;
    }

    // 2. 메모리 할당 및 검사
    int *arr = malloc(n * sizeof(*arr));
    if (!arr) {
        perror("메모리 할당 실패");
        return 1;
    }

    // 3. 메모리 사용 (여기서는 단순히 인덱스+1 값으로 채움)
    for (size_t i = 0; i < n; ++i) {
        arr[i] = (int)(i + 1);
    }

    // 4. 결과 출력
    printf("생성된 배열: ");
    for (size_t i = 0; i < n; ++i) {
        printf("%d ", arr[i]);
    }
    puts("");

    // 5. 메모리 해제 및 정리
    free(arr);
    arr = NULL;

    return 0;
}
```
> **참고**: 프로덕션 코드에서는 `scanf` 대신 `fgets`로 한 줄을 읽고 `strtoull` 같은 함수로 파싱하는 것이 훨씬 더 안전하고 유연합니다.

---

## 고급 패턴: 동적 배열(벡터) 구현

`realloc`을 활용해 필요에 따라 자동으로 크기가 늘어나는 동적 배열을 구현하는 것은 매우 일반적인 디자인 패턴입니다. 효율성을 위해 크기를 **2배씩 늘리는(지수 성장)** 방식을 주로 사용합니다.

```c
#include <stdlib.h>

typedef struct {
    int *data;      // 실제 데이터 배열
    size_t length;  // 현재 저장된 요소 개수
    size_t capacity;// 할당된 메모리가 담을 수 있는 총 요소 개수
} IntVector;

// 벡터 초기화
static int iv_init(IntVector *v) {
    v->data = NULL;
    v->length = 0;
    v->capacity = 0;
    return 0;
}

// 벡터 용량 확보 (내부 함수)
static int iv_ensure_capacity(IntVector *v, size_t needed) {
    if (needed <= v->capacity) return 0; // 이미 충분함

    // 지수 성장 전략: 1, 2, 4, 8, 16...
    size_t new_cap = (v->capacity == 0) ? 1 : v->capacity;
    while (new_cap < needed) {
        new_cap <<= 1; // 2배
        // 오버플로우 체크
        if (new_cap > SIZE_MAX / sizeof(*v->data)) return -1;
    }

    int *temp = realloc(v->data, new_cap * sizeof(*temp));
    if (!temp) return -1; // 재할당 실패

    v->data = temp;
    v->capacity = new_cap;
    return 0;
}

// 벡터 끝에 요소 추가
static int iv_push_back(IntVector *v, int value) {
    if (iv_ensure_capacity(v, v->length + 1)) return -1;
    v->data[v->length] = value;
    v->length++;
    return 0;
}

// 벡터 메모리 해제
static void iv_destroy(IntVector *v) {
    free(v->data);
    v->data = NULL;
    v->length = v->capacity = 0;
}
```
이 패턴의 핵심은 `realloc` 호출 횟수를 `O(log n)`으로 줄여 성능을 향상시키는 동시에, 임시 포인터(`temp`)를 사용해 재할당 실패 시에도 원본 데이터를 안전하게 보존하는 데 있습니다.

---

## 2차원 동적 배열: 효율적인 설계

2차원 배열을 동적으로 만들 때, 각 행을 독립적으로 `malloc`하는 방법도 있지만, 이는 메모리 조각화를 유발하고 캐시 효율이 떨어질 수 있습니다. 대신, **모든 데이터를 하나의 연속된 블록에 저장하고, 행 포인터 배열만 따로 관리**하는 방식이 권장됩니다.

```c
int** create_2d_array(int rows, int cols) {
    if (rows <= 0 || cols <= 0) return NULL;

    // 1. 행 포인터 배열 할당
    int **row_ptrs = malloc((size_t)rows * sizeof(*row_ptrs));
    // 2. 모든 데이터를 담을 연속된 메모리 블록 할당
    int *data_block = malloc((size_t)rows * cols * sizeof(*data_block));

    if (!row_ptrs || !data_block) {
        free(row_ptrs);
        free(data_block);
        return NULL;
    }

    // 3. 각 행 포인터가 데이터 블록의 올바른 위치를 가리키도록 설정
    for (int i = 0; i < rows; ++i) {
        row_ptrs[i] = data_block + (size_t)i * cols;
    }

    return row_ptrs; // 사용자는 int**처럼 사용하면 됨
}

// 해제는 두 단계로 이루어집니다.
void free_2d_array(int **arr) {
    if (!arr) return;
    free(arr[0]); // 먼저 연속된 데이터 블록을 해제
    free(arr);    // 그 다음 행 포인터 배열을 해제
}
```
이 방식의 장점은 `memcpy` 한 번으로 전체 데이터를 복사할 수 있고, 메모리 접근 패턴이 예측 가능해 캐시 성능이 좋으며, 할당/해제 오버헤드가 작다는 점입니다.

---

## 결론

동적 메모리 관리는 C 프로그래밍의 자유이자 책임입니다. 안전하고 견고한 코드를 작성하기 위해서는 다음 원칙들을 반드시 지켜야 합니다.

**할당 시 안전성 확보**: 모든 할당 함수(`malloc`, `calloc`, `realloc`)의 반환값을 `NULL`인지 반드시 검사하고, 할당 크기 계산 시에는 정수 오버플로우를 방지하기 위해 `SIZE_MAX`로 나누어 검사해야 합니다. `realloc`을 사용할 때는 임시 포인터에 결과를 받아 실패를 안전하게 처리하는 것이 중요합니다.

**해제 시 주의사항**: 메모리를 해제(`free`)한 후에는 즉시 포인터에 `NULL`을 대입해 dangling pointer를 방지해야 합니다. 동일한 포인터를 두 번 해제하는 이중 해제(double free) 오류는 심각한 보안 취약점으로 이어질 수 있으므로 각별히 주의해야 합니다.

**메모리 접근 규칙**: 할당된 메모리 블록의 범위를 벗어나는 접근은 정의되지 않은 동작을 유발합니다. 배열 인덱스와 포인터 연산 시 항상 경계를 확인해야 합니다.

**소유권 관리**: 함수나 모듈 간에 메모리 소유권을 명확히 정의하고 문서화하는 것이 필수적입니다. 누가 메모리를 할당하고 누가 해제하는지 명확한 규칙이 없으면 메모리 누수나 이중 해제가 발생하기 쉽습니다. 특히 외부 라이브러리에서 할당받은 메모리는 반드시 해당 라이브러리가 제공하는 해제 함수를 사용해야 합니다.

이러한 원칙들을 습관화하면 메모리 관련 버그를 크게 줄일 수 있으며, Valgrind나 AddressSanitizer 같은 도구를 활용하면 런타임에 메모리 오류를 조기에 발견할 수 있습니다.