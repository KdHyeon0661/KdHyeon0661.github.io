---
layout: post
title: Elixir - 프로세스, 부하, 종료
date: 2025-11-20 15:25:23 +0900
category: Elixir
---
# 프로세스, 부하, 종료 — BEAM 동시성 설계 완전 정리

## 간단한 프로세스

### 스폰과 메시지 패싱의 최소 단위

가장 작은 예부터 다시 보자.

```elixir
parent = self()

pid =
  spawn(fn ->
    receive do
      {:hello, from} ->
        send(from, {:reply, "world"})
    after
      1_000 ->
        exit(:timeout)
    end
  end)

send(pid, {:hello, parent})

reply =
  receive do
    {:reply, msg} -> msg
  after
    2_000 -> :no_reply
  end

reply  # "world"
```

여기서 일어나는 일:

1. `self/0`
   - 현재 실행 중인 프로세스의 PID를 반환한다.
   - IEx에서 `self()`를 찍어보면 `<0.123.0>` 같은 형태가 나온다.

2. `spawn/1`
   - **완전히 독립적인 프로세스**를 생성한다.
   - 생성된 프로세스는 `parent`와 스택/힙/레지스터를 공유하지 않는다.
   - 운영체제의 “프로세스”가 아니라 BEAM(가상 머신)의 경량 프로세스다.

3. 자식 프로세스의 `receive`:

   ```elixir
   receive do
     {:hello, from} ->
       send(from, {:reply, "world"})
   after
     1_000 ->
       exit(:timeout)
   end
   ```

   - **메일박스**(메시지 큐)를 앞에서부터 훑어가며
     `{:hello, from}` 패턴에 맞는 메시지를 찾는다.
   - 없으면 최대 1초까지 기다리고, 그동안에도 **다른 프로세스들**은 스케줄러에 의해 실행된다.
   - 1초 안에 매칭되는 메시지가 오지 않으면 `exit(:timeout)` 으로 종료.

4. 부모 프로세스는 `send/2`로 메시지를 보낸다.

   ```elixir
   send(pid, {:hello, parent})
   ```

   - `send/2`는 항상 **비블로킹**이다. 송신자는 바로 다음 코드로 진행한다.
   - 실패(존재하지 않는 PID) 시에도 예외를 내지 않고, 그냥 `{:badarg, ...}` 형태의 경고를 로그로 남길 뿐이다.

5. 부모의 `receive`:

   ```elixir
   reply =
     receive do
       {:reply, msg} -> msg
     after
       2_000 -> :no_reply
     end
   ```

   - 자식에게서 오는 `{:reply, "world"}` 를 기다리되,
     2초 안에 안 오면 `:no_reply` 로 간주한다.
   - 이렇게 하면, **상대가 죽었거나 네트워크가 끊겨도** 영원히 블로킹되지 않는다.

#### `receive`의 동작을 한 번 더 해부하기

`receive` 는 다음과 같이 동작한다고 생각해도 된다:

1. 자신의 메일박스를 가장 오래된 메시지부터 순서대로 훑는다.
2. **각 메시지에** 대해 `case` 처럼 패턴 매칭을 적용한다.
3. **처음으로 매칭에 성공한 메시지**를 소비(큐에서 제거)하고 해당 분기를 실행한다.
4. 아무 메시지도 매칭되지 않으면:
   - `after`가 없으면 **무한정 대기**.
   - `after t -> ...`가 있으면 최대 `t` 밀리초 대기하다가 타임아웃 분기로 이동.

여기서 중요한 점:

- 메일박스 자체는 FIFO지만, **패턴 매칭 + 선택적 수신** 때문에
  실질적으로는 “논리적 우선순위 큐”처럼 동작할 수 있다(15.2.6에서 함정 설명).

#### `after` 패턴의 활용

`after`는 단순한 타임아웃 이상으로 쓸 수 있다.

```elixir
# 논블로킹 "있으면 받고, 없으면 넘어가기"

receive do
  msg -> {:got, msg}
after
  0 -> :none
end
```

- **0ms 타임아웃**은 “지금 당장 메일박스에 있는 것만 보고, 없으면 바로 넘어감”을 의미한다.
- 이벤트 루프나 폴링을 구현할 때 자주 사용된다.

또는 “하트비트”처럼 주기적인 작업:

```elixir
def loop(state) do
  receive do
    {:update, new_state} ->
      loop(new_state)
  after
    5_000 ->
      ping_remote(state)
      loop(state)
  end
end
```

- 메일박스를 비우는 와중에도 일정 주기로 **외부 서비스에 ping**을 보내는 구조.

---

### 실전 예: 타임아웃 있는 간단 RPC 흉내

`spawn + send + receive` 로 RPC에 가까운 것을 만들 수도 있다.

```elixir
defmodule Rpc do
  def call(fun, timeout \\ 5_000) when is_function(fun, 0) do
    parent = self()

    pid =
      spawn(fn ->
        result =
          try do
            {:ok, fun.()}
          rescue
            e -> {:error, e}
          end

        send(parent, {:rpc_reply, self(), result})
      end)

    receive do
      {:rpc_reply, ^pid, result} -> result
    after
      timeout ->
        {:error, :timeout}
    end
  end
end

iex> Rpc.call(fn -> 1 + 2 end)
{:ok, 3}

iex> Rpc.call(fn -> raise "boom" end)
{:error, %RuntimeError{message: "boom"}}
```

- `^pid`로 **응답을 구분**하므로, 동시에 여러 RPC를 날려도 헷갈리지 않는다.
- 실제 프로덕션에서는 대부분 `GenServer.call/3` 을 쓰지만,
  내부가 어떻게 돌아가는지 이해하는 데 좋은 연습이다.

---

### 이름 붙이기·등록

임의로 생성한 PID는 외우기 어렵다. 이름을 붙여 보자.

```elixir
defmodule SimpleEcho do
  def start do
    pid = spawn(fn -> loop() end)
    Process.register(pid, :simple_echo)
    pid
  end

  def echo(msg) do
    send(:simple_echo, {:echo, self(), msg})

    receive do
      {:echo_reply, msg} -> msg
    after
      1_000 -> :timeout
    end
  end

  defp loop do
    receive do
      {:echo, from, msg} ->
        send(from, {:echo_reply, msg})
        loop()
    end
  end
end

SimpleEcho.start()
SimpleEcho.echo("hello")
# => "hello"

```

- `Process.register/2`
  - 이 노드에서 **전역 이름 공간**을 공유한다.
  - 같은 이름에 두 프로세스를 등록하면 `ArgumentError` 또는 기존 등록 해제 등 혼란이 생길 수 있다.
- 전역 등록은 간단하지만:
  - **충돌 처리**를 직접 해야 하고,
  - 다중 노드(+분산) 환경에서는 더 복잡해진다.

실무에서는 보통:

- `GenServer.start_link/3` 의 `name:` 옵션,
- `Registry`(샤딩 가능한 이름 레지스트리),
- `:via` 이름 등록(예: `{:via, Registry, {MyReg, key}}`)

같은 패턴을 사용한다. 이건 “프로세스” 장이 아니라 OTP/GenServer 쪽 주제지만,
여기서도 **단일 노드에서 최소한의 이름 붙이기** 개념을 이해해두면 좋다.

---

### 루프와 메일박스 패턴

가장 흔한 패턴은 **꼬리 재귀 루프 + 상태**이다.

```elixir
defmodule Counter do
  def start(initial \\ 0) do
    spawn_link(__MODULE__, :loop, [initial])
  end

  def loop(n) do
    receive do
      {:inc, from} ->
        new = n + 1
        send(from, {:ok, new})
        loop(new)

      {:get, from} ->
        send(from, {:ok, n})
        loop(n)

      :stop ->
        :ok
    end
  end
end

pid = Counter.start()
send(pid, {:inc, self()})
receive do {:ok, n} -> n end  # 1
send(pid, {:get, self()})
receive do {:ok, n} -> n end  # 1
send(pid, :stop)
```

포인트:

- **상태(`n`)는 함수 인수로 전달**된다.
  - 공유 변수, 전역 변수 없이도 안전하게 상태를 유지한다.
- `loop/1` 호출은 **꼬리 재귀**이므로,
  BEAM이 내부적으로 “while 루프”처럼 최적화한다.

이 패턴이 바로 `GenServer` 의 내부 구조이기도 하다.

---

### GenServer로 같은 걸 더 안전하게

위 Counter를 GenServer로 다시 써 보자.

```elixir
defmodule CounterServer do
  use GenServer

  # API
  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, 0, opts)
  end

  def inc(pid), do: GenServer.call(pid, :inc)
  def get(pid), do: GenServer.call(pid, :get)

  # 콜백
  @impl true
  def init(initial) do
    {:ok, initial}
  end

  @impl true
  def handle_call(:inc, _from, n) do
    new = n + 1
    {:reply, new, new}
  end

  @impl true
  def handle_call(:get, _from, n) do
    {:reply, n, n}
  end
end

{:ok, pid} = CounterServer.start_link()
CounterServer.inc(pid)  # 1
CounterServer.get(pid)  # 1
```

GenServer의 장점:

1. **call/cast/정보 메시지(handle_info)** 를 위한 **표준 인터페이스** 제공.
2. **타임아웃**(idle timeout, call timeout) 처리가 기본 탑재.
3. **Supervisor와의 결합**이 자연스럽다.
4. `:sys.get_state/1`, `:sys.trace/2` 등 **운영 도구**를 쓸 수 있다.

간단한 에코 서버 예제(기존 내용):

```elixir
defmodule EchoServer do
  use GenServer

  def start_link(opts \\ []), do: GenServer.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok), do: {:ok, %{}}

  @impl true
  def handle_call({:echo, msg}, _from, state), do: {:reply, msg, state}

  @impl true
  def handle_cast({:notify, msg}, state) do
    IO.puts("notify: #{msg}")
    {:noreply, state}
  end
end

{:ok, pid} = EchoServer.start_link()
GenServer.call(pid, {:echo, "ping"})      # 동기
GenServer.cast(pid, {:notify, "hello"})   # 비동기
```

- `call` 은 **요청-응답** 패턴(역압, 오류 전파에 좋다).
- `cast` 는 응답이 필요 없는 작업에 사용한다.
  - 하지만 과도하게 쓰면 메일박스 폭주 위험이 있다(15.2에서 다시).

---

### Task — 일회성 작업

`Task` 는 “프로세스를 직접 spawn하는 대신, **반환을 기다리기 편한 래퍼**”라고 보면 된다.

```elixir
t = Task.async(fn -> :math.sqrt(144) end)
Task.await(t, 500)  # 12.0
```

흐름:

1. `Task.async/1`
   - 링크된 프로세스를 하나 만들고, 내부에서 `fun.()` 을 실행한다.
   - 결과/예외는 호출자에게 메시지로 돌아온다.
2. `Task.await/2`
   - 해당 결과가 올 때까지 기다리고, **타임아웃**되면 `Task.shutdown/2` 로 강제 종료.

#### Task와 GenServer 조합

예: HTTP 요청을 백그라운드에서 실행하고, 완료되면 콜백하는 패턴.

```elixir
defmodule HttpClient do
  use GenServer

  def start_link(opts \\ []), do: GenServer.start_link(__MODULE__, :ok, opts)

  def get(pid, url) do
    GenServer.cast(pid, {:get, self(), url})
  end

  @impl true
  def handle_cast({:get, from, url}, state) do
    Task.start(fn ->
      res = do_get(url)
      send(from, {:http_result, url, res})
    end)

    {:noreply, state}
  end

  defp do_get(url) do
    # 실제 HTTP 클라이언트 호출
    {:ok, "body: " <> url}
  end
end

{:ok, client} = HttpClient.start_link()
HttpClient.get(client, "http://example.com")

receive do
  {:http_result, url, res} -> {url, res}
after
  1_000 -> :timeout
end
```

- GenServer는 요청을 받고, 실제 비싼 작업은 Task로 넘겨 **자신은 빨리 돌아온다**.
- 클라이언트는 본인 PID를 함께 보내고, 결과 메시지를 기다린다.

#### `Task.async_stream/3` 기본 구조

기본 사용은 다음과 같다(15.2에서 부하 관점으로 깊게 다시 다룬다).

```elixir
files = Path.wildcard("data/*.json")

files
|> Task.async_stream(&process_file/1,
     max_concurrency: System.schedulers_online() * 2,
     timeout: 10_000)
|> Enum.to_list()
```

- 각 입력에 대해 Task를 만들지만, **동시 실행 수를 제한**할 수 있다.
- `timeout` 으로 너무 오래 걸리는 작업을 끊고,
  `on_timeout: :kill_task` 옵션으로 Task 프로세스를 **실제로 종료**하게 할 수 있다.

---

## 프로세스 부하

> “빠르다”보다 더 중요한 건 **안정적으로 빨라지는 것**.
> 부하는 **레덕션, 스케줄러, 메일박스 길이**로 관찰·제어한다.

### 레덕션과 스케줄러 개요

- **레덕션(reduction)**
  - BEAM이 **프로세스에 할당하는 작업량 단위**.
  - 함수 호출/패턴 매칭 등 몇 개의 기본 연산을 묶어서 1 레덕션으로 생각한다.
- **스케줄러**
  - OS 스레드와 1:1로 매핑되는 BEAM의 실행 단위다.
  - 일반적으로 CPU 코어 수와 비슷한 수의 스케줄러가 있다.

직관적인 수식으로 표현하면:

$$
\text{총 처리량} \approx
\frac{\sum \text{레덕션}}{\text{단위 시간}}
$$

메일박스 관점에서는:

$$
\text{평균 대기 시간} \propto
\frac{\text{메일박스 길이}}{\text{처리량}}
$$

- 메일박스가 길어질수록 **처리되기까지의 대기 시간**이 길어진다.
- 처리량(단위 시간당 레덕션)이 일정하다고 가정하면,
  메일박스 길이를 줄이는 것이 곧 지연 줄이기다.

---

### 부하 측정 스니펫

간단히 현재 VM 상태를 보는 함수들을 정리해 보자.

```elixir
:erlang.system_info(:schedulers_online)      # 온라인 스케줄러 수
:erlang.statistics(:reductions)              # {reductions, since_start}
Process.info(self(), [:message_queue_len, :reductions])
```

- `:schedulers_online`
  - “이 VM에서 실제로 일하는 스케줄러 수”를 알려준다.
- `:statistics(:reductions)`
  - 시작 이후 누적 레덕션 수를 알려준다.
  - 시간차를 두고 두 번 읽으면, 그 사이에 몇 레덕션이 수행되었는지 계산할 수 있다.
- `Process.info/2`
  - 특정 프로세스에 대한 정보를 반환한다.
  - `:message_queue_len`
    - 현재 메일박스에 쌓인 메시지 수.
  - `:reductions`
    - 해당 프로세스가 지금까지 쓴 레덕션 수.
    - 간단히 “얼마나 CPU를 사용했는지” 감을 보는 지표.

실전에서는 이 지표들을 Telemetry나 Prometheus로 내보내서
**대시보드/알람**을 구성하는 경우가 많다.

---

### 폭풍 테스트(스파이크)로 병목 찾기

단일 수신자 병목을 체험하는 간단한 실험:

```elixir
defmodule Storm do
  def run(n \\ 100_000) do
    parent = self()

    Enum.each(1..n, fn i ->
      spawn(fn -> send(parent, {:done, i}) end)
    end)

    gather(n, 0)
  end

  defp gather(0, acc), do: acc

  defp gather(n, acc) do
    receive do
      {:done, _i} ->
        gather(n - 1, acc + 1)
    after
      5_000 ->
        {:timeout, n}
    end
  end
end

Storm.run(200_000)
```

- 20만 개의 프로세스가 부모에게 한 번씩 메시지를 보낸다.
- `gather/2` 가 이 모든 메시지를 처리하기 전에 타임아웃이 날 수도 있다.

이때 IEx에서:

```elixir
Process.info(self(), :message_queue_len)
```

을 찍어 보면:

- “내 메일박스에 얼마나 많은 메시지가 쌓여 있는지” 를 숫자로 확인할 수 있다.
- 이 실험은 “한 프로세스가 모든 요청을 받아 처리하는 구조”가
  큰 부하에서 **얼마나 빨리 병목이 되는지**를 보여준다.

#### 개선 아이디어(샤딩과 배치)

- **샤딩**: 여러 수신자를 만들어, 해시나 round-robin으로 요청을 분산.
- **배치 처리**: 한 번 `receive` 할 때 메시지를 여러 개 모아서 한꺼번에 처리.

이 아이디어는 아래에서 더 자세히 다룬다.

---

### 배치 수신 패턴

일반적인 배치 수신 패턴을 더 자세히 써 보자.

```elixir
defmodule BatchSink do
  def start(batch_size \\ 100), do: spawn_link(__MODULE__, :loop, [batch_size, []])

  def send_item(pid, item), do: send(pid, {:item, item})

  def loop(batch_size, acc) do
    receive do
      {:item, x} ->
        new = [x | acc]

        if length(new) >= batch_size do
          flush(Enum.reverse(new))
          loop(batch_size, [])
        else
          loop(batch_size, new)
        end
    after
      200 ->
        if acc != [] do
          flush(Enum.reverse(acc))
        end

        loop(batch_size, [])
    end
  end

  defp flush(items) do
    # 예: DB에 한 번에 INSERT
    # Repo.insert_all(..., items)
    :ok
  end
end
```

특징:

1. **개수 기준 배치**
   - 메시지가 빠르게 들어오면, `length(new) >= batch_size` 조건으로 인한 배치가 발생한다.
2. **시간 기준 배치**
   - 일정 시간(200ms) 동안 메시지가 안 들어오면, 그동안 모인 것을 바로 flush.

이 패턴은 다음 문제들을 동시에 해결해 준다.

- DB/디스크/외부 API 호출 횟수 줄이기
- 락 경합 줄이기
- “작업이 너무 분절적으로 실행되는 문제” 완화

주의:

- `length/1` 는 리스트 길이를 매번 계산하므로 O(n) 이다.
  실제 구현에서는 길이를 상태에 같이 들고 다니는 것이 좋다.

```elixir
def loop(batch_size, acc, len) do
  # ...
end
```

---

### 역압(backpressure)과 차단식 호출

역압의 직관적인 수식:

$$
\text{생산 속도} \le \text{소비 속도}
$$

이 조건을 유지해야 시스템이 안정된다. 그렇지 않으면:

- 메일박스/큐가 계속 증가,
- 처리 지연 증가,
- 결국 메모리/시간 초과로 실패.

#### `GenServer.call/3` = 자연스러운 역압

`call`은 서버가 응답을 줄 때까지 **호출자를 블로킹**한다.

```elixir
def handle_call({:work, job}, _from, state) do
  result = do_expensive(job)
  {:reply, result, state}
end
```

- 호출자는 `GenServer.call/3` 이 끝날 때까지 **더 많은 작업을 보내지 못한다**.
- 이것은 자연스럽게 “생산 속도 ≤ 소비 속도” 조건을 강제한다.

#### `cast`/`send`는 역압이 없다

```elixir
Enum.each(1..1_000_000, fn i ->
  GenServer.cast(pid, {:work, i})
end)
```

- 100만 개의 메시지를 순식간에 보내도, `cast` 자체는 거의 시간 안 걸리고 끝난다.
- 서버 입장에서는 메일박스에 **100만 개의 메시지**가 들어온 셈이다.

따라서:

- **응답이 필요 없는 작업이라도**,
  일정 규모 이상이면 **역압을 인위적으로 설계**해야 한다.

#### 단순 “큐 한도” 전략

```elixir
defmodule BoundedServer do
  use GenServer
  @max_q 1_000

  def start_link(opts \\ []), do: GenServer.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok), do: {:ok, %{}}

  def cast_work(pid, job), do: GenServer.cast(pid, {:work, job})

  @impl true
  def handle_cast({:work, job}, state) do
    {:message_queue_len, q} = Process.info(self(), :message_queue_len)

    cond do
      q > @max_q ->
        # 드롭/로그/알람
        require Logger
        Logger.warn("dropping job due to high queue: #{inspect(job)}")
        {:noreply, state}

      true ->
        do_work(job)
        {:noreply, state}
    end
  end

  defp do_work(job) do
    # 실제 작업
    :ok = job
  end
end
```

전략 선택은 도메인에 따라 다르다:

- **드롭**: “최신 데이터만 중요하고 중간 것은 버려도 된다”는 타입의 서비스.
- **거부(에러 응답)**: 클라이언트에 “지금 바쁘다, 나중에 다시” 를 알려 재시도하게 하는 서비스.
- **조절(슬로우 스타트)**: 서버 상태에 따라 클라이언트가 속도를 점진적으로 조정.

보다 정교한 역압이 필요하면:

- `GenStage`, `Broadway` 같은 프레임워크에서 **요청-응답 기반 역압**을 자동으로 처리해 준다.

---

### 선택적 수신의 함정(Selective Receive)

엘릭서/Erlang의 강력한 기능 중 하나가 **선택적 수신**이다.

```elixir
receive do
  {:priority, m} -> handle(m)
after
  0 -> :ok
end
```

- 메일박스에 `{:priority, _}` 메시지가 하나라도 있으면 **그것만 먼저 소비**한다.
- 나머지 메시지는 계속 메일박스 안에 남는다.

문제는:

- 우선순위 메시지가 자주 오면,
  일반 메시지는 **영원히 처리되지 않을 수도 있다.**

#### 공정성 확보 패턴

1. **일반 메시지도 주기적으로 처리**:

   ```elixir
   def loop do
     receive do
       {:priority, msg} ->
         handle_priority(msg)
         loop()
     after
       0 ->
         receive do
           msg -> handle_normal(msg)
         after
           0 -> :ok
         end

         loop()
     end
   end
   ```

2. **우선순위 큐 자체를 별도의 프로세스/자료구조로 구현**
   - 모든 메시지를 일단 수신한 뒤,
     내부 상태에서 우선순위를 재조정하는 방식.

실전에서는 선택적 수신을 너무 복잡하게 쓰지 않는 것이 좋고,
대부분의 경우 **GenServer + 패턴 매칭 + 가드** 조합으로도 충분히 해결된다.

---

### 폭넓은 병렬화: `Task.async_stream`

기본 구조는 이미 봤지만, 옵션을 좀 더 구체적으로 보자.

```elixir
urls
|> Task.async_stream(&fetch/1,
     max_concurrency: System.schedulers_online() * 2,
     timeout: 5_000,
     on_timeout: :kill_task,
     ordered: false)
|> Enum.to_list()
```

- `max_concurrency`
  - 동시에 몇 개의 Task를 돌릴지.
  - CPU 바운드면 대략 **스케줄러 수 ± 약간**, I/O 바운드면 그보다 더 크게 잡는다.
- `timeout`
  - 개별 Task가 이 시간 이상 걸리면 타임아웃으로 간주.
- `on_timeout: :kill_task`
  - 타임아웃된 Task 프로세스를 실제로 `exit(:kill)` 로 종료.
- `ordered: false`
  - 결과를 **완료 순서대로** 받는다.
  - `true`면 입력 순서와 동일한 순서로 결과를 준다.

반환 값은 `{:ok, v}` 또는 `{:exit, reason}` 등의 튜플이다.

```elixir
urls
|> Task.async_stream(&fetch/1, max_concurrency: 10, timeout: 5_000)
|> Enum.split_with(fn
  {:ok, _} -> true
  _ -> false
end)
```

이런 식으로 성공/실패를 분리해서 처리할 수도 있다.

---

### 워커 풀(간단 구현)

주어진 예제를 조금 더 읽기 좋게 정리해 보자.

{% raw %}
```elixir
defmodule Pool do
  use GenServer

  def start_link(size), do: GenServer.start_link(__MODULE__, size, name: __MODULE__)

  def init(size) do
    workers = for _ <- 1..size, do: start_worker()
    {:ok, %{idle: workers, busy: %{}, q: :queue.new()}}
  end

  defp start_worker, do: spawn_link(__MODULE__, :worker_loop, [])

  def submit(fun) when is_function(fun, 0) do
    GenServer.call(__MODULE__, {:submit, fun}, 10_000)
  end

  # idle 워커가 있을 때
  def handle_call({:submit, fun}, from, %{idle: [w | rest]} = st) do
    send(w, {:run, self(), from, fun})
    {:noreply, %{st | idle: rest, busy: Map.put(st.busy, w, from)}}
  end

  # 워커가 모두 바쁠 때: 큐에 쌓기
  def handle_call({:submit, fun}, from, st) do
    {:noreply, %{st | q: :queue.in({from, fun}, st.q)}}
  end

  def handle_info({:done, w, result}, st) do
    {from, busy2} = Map.pop(st.busy, w)
    if from, do: GenServer.reply(from, {:ok, result})

    case :queue.out(st.q) do
      {{:value, {from2, fun2}}, q2} ->
        send(w, {:run, self(), from2, fun2})
        {:noreply, %{st | q: q2, busy: Map.put(busy2, w, from2)}}

      {:empty, _} ->
        {:noreply, %{st | idle: [w | st.idle], busy: busy2}}
    end
  end

  def worker_loop do
    receive do
      {:run, mgr, from, fun} ->
        res =
          try do
            fun.()
          rescue
            e -> {:error, e}
          end

        send(mgr, {:done, self(), res})
        worker_loop()
    end
  end
end
```
{% endraw %}

- `submit/1` 은 **동기 호출**이므로, 클라이언트 입장에서는 **역압이 자동으로 걸린다**.
- 워커 수는 `start_link/1` 의 인자로 결정.

실제 서비스에서는 대개:

- `DynamicSupervisor` + `GenServer`/`Task` 조합,
- 또는 라이브러리(Exq, Oban 등)를 사용해 풀/큐를 구성한다.

여기서는 “프로세스로 풀을 만드는 기본 패턴”을 이해하는 것이 중요하다.

---

### 메모리/복사 비용 감각

- BEAM은 **큰 바이너리(대략 64바이트 이상)** 를 힙 밖에 저장하고,
  참조를 여러 프로세스가 공유할 수 있게 최적화하고 있다.
- 하지만 메시징 시, 구조체/맵/리스트 등은 **복사**가 발생한다.
- 특히 **서브바이너리**를 오래 들고 있으면,
  더 큰 원본 바이너리가 같이 살아남아 메모리를 잡아먹을 수 있다.

예:

```elixir
big = File.read!("huge.bin")
sub = binary_part(big, 0, 10)

# sub를 프로세스 상태에 오래 보관하면, 실제로는 big 전체가 GC되지 못할 수 있다.

```

개선:

- 필요하면 `:binary.copy(sub)`로 **독립된 작은 바이너리**를 만든다.
- 큰 바이너리는 **짧은 시간** 동안만 보관하고, 가능한 빨리 처리/해제한다.

---

## 프로세스가 종료될 때

> 종료는 “에러”만이 아니다. 정상 종료도 종료다.
> **종류/전파/관찰/정리**를 구분하자.

### 종료 종류 요약

BEAM에서 “종료”는 몇 가지 형태가 있다.

- **정상 종료**
  - 함수가 끝나거나 `exit(:normal)` 호출.
- **비정상 종료**
  - `exit(:reason)` (예: `:timeout`, `:badarg`)
  - 예외(`raise`) → 내부적으로는 `exit({:error, ...})` 형태로 보기도 한다.
- **강제 종료**
  - `Process.exit(pid, :kill)`
  - 이 경우, 대상 프로세스는 **어떠한 cleanup도 수행할 수 없다.**
- **호출자 관점의 종료**
  - 예: `GenServer.call/3` 타임아웃.
  - 서버가 살아 있어도, 호출자는 **실패**로 간주한다.

---

### 링크(link)와 전파

```elixir
parent = self()

child =
  spawn_link(fn ->
    raise "boom"
  end)

# child가 크래시하면, parent도 링크로 인해 EXIT 신호를 받고 같이 죽는다.

```

링크 특징:

- 링크된 두 프로세스 중 하나가 비정상 종료하면,
  **EXIT 신호**가 상대에게 전달된다.
- 상대 프로세스가 `:trap_exit`를 설정하지 않았다면,
  **같이 종료**된다.

이 메커니즘을 활용해 만든 것이 바로 **Supervisor**다.

- Supervisor는 자식 프로세스들과 링크를 맺고,
- 자식이 비정상 종료하면 **EXIT 신호**를 받아,
- **재시작 정책**에 따라 다시 띄운다.

---

### — 일방 관찰

모니터는 링크와 달리 **일방적**이다.

```elixir
pid = spawn(fn ->
  :timer.sleep(10)
  :ok
end)

ref = Process.monitor(pid)

receive do
  {:DOWN, ^ref, :process, ^pid, reason} ->
    reason  # :normal
end
```

특징:

- 관찰자는 피관찰자에 영향을 주지 않는다.
- 피관찰자가 종료되면, 관찰자 메일박스로 `{:DOWN, ref, :process, pid, reason}` 메시지가 온다.
- 모니터는 보통:
  - **외부 서비스와의 어댑터 프로세스**,
  - **작업 워커**의 생명주기를 추적하는 데 사용된다.

---

### 종료 신호를 메시지로 받기(trap_exit)

링크는 기본적으로 “같이 죽기”지만, `:trap_exit`를 통해 **EXIT 신호를 메시지로 전환**할 수 있다.

```elixir
defmodule Trapper do
  def start do
    spawn(fn ->
      Process.flag(:trap_exit, true)
      pid = spawn_link(fn -> raise "boom" end)
      loop()
    end)
  end

  defp loop do
    receive do
      {:EXIT, from, reason} ->
        IO.puts("child #{inspect(from)} exited: #{inspect(reason)}")
        loop()
    end
  end
end

Trapper.start()
```

이 경우:

- 자식이 예외로 종료되어도, 부모는 죽지 않고 `{:EXIT, pid, reason}` 메시지를 받는다.
- “수동 Supervisor”처럼 동작할 수 있지만,
  **슈퍼비전 트리를 이용하는 것이 훨씬 나은 기본 전략**이다.

주의:

- **모든 프로세스**에 `:trap_exit`를 남발하면,
  원래 죽어야 할 프로세스가 죽지 않아 **일관성 문제**를 일으킬 수 있다.
- 일반적으로는 **GenServer + Supervisor 조합에 맡기고**,
  `trap_exit`는 특수한 상황(예: 포트/외부 프로세스 관리)에서만 사용한다.

---

### GenServer 종료 생명주기

예제를 다시 보자.

```elixir
defmodule S do
  use GenServer

  def start_link(opts), do: GenServer.start_link(__MODULE__, :ok, opts)

  @impl true
  def init(:ok) do
    {:ok, %{file: File.open!("log.txt", [:append])}}
  end

  @impl true
  def handle_cast(:boom, st) do
    raise "boom"
  end

  @impl true
  def terminate(reason, %{file: io}) do
    IO.binwrite(io, "terminating: #{inspect(reason)}\n")
    File.close(io)
    :ok
  end
end
```

- `terminate/2` 호출 시점:
  - **정상 종료**(`GenServer.stop/3`, `:normal`),
  - **슈퍼바이저에 의한 종료**(`:shutdown`),
  - **타임아웃** 등 여러 케이스.
- `:kill` 로 강제 종료된 경우에는 `terminate/2` 가 호출되지 않는다.

실전 패턴:

- **파일/소켓/포트** 등 외부 리소스는
  - 가능하면 `try/after` 블록에서 닫고,
  - 그래도 혹시 남을 경우 `terminate/2` 에서 **마지막 방어선**으로 닫는다.
- 내부 상태만 가진 순수 서버는 `terminate/2` 없이도 상관없다.

---

### 관례

OTP에서는 종료 이유를 아래처럼 관례적으로 사용한다.

- `:normal`
  - 정상 종료. Supervisor는 보통 재시작하지 않는다.
- `{:shutdown, term}`
  - 의도된 종료. Supervisor도 **재시작하지 않는 게 일반적**이다.
- `:shutdown`
  - Supervisor가 자식을 **정상적으로 종료시키려고** 보낸 이유.
- 예외/오류(`:badarg`, `:function_clause`, …)
  - 비정상 종료. Supervisor 재시작 대상.

Supervision 전략에 따라:

- `restart: :permanent`
  - 종료 이유와 상관없이 항상 재시작.
- `restart: :transient`
  - 정상 종료/`{:shutdown, _}` 이면 재시작 안 함. 그 외는 재시작.
- `restart: :temporary`
  - 절대 재시작하지 않는다.

---

### Supervisor 전략과 재시작

기본적인 Supervisor 설정:

```elixir
children = [
  {EchoServer, name: EchoServer},
  {S, name: S}
]

Supervisor.start_link(children, strategy: :one_for_one)
```

전략들:

- `:one_for_one`
  - 자식 하나가 죽으면 **그 자식만** 재시작.
- `:one_for_all`
  - 자식 하나가 죽으면 **모든 자식**을 죽이고, 다시 전부 재시작.
  - 강하게 결합된 그룹에 유용.
- `:rest_for_one`
  - 실패한 프로세스 **이후에 시작된 자식들**만 재시작.
- `:simple_one_for_one`
  - 옛날 방식의 “동일 타입 자식 여러 개” 패턴.
  - 최신 엘릭서에서는 보통 `DynamicSupervisor`를 사용한다.

부가 설정:

```elixir
Supervisor.start_link(children,
  strategy: :one_for_one,
  max_restarts: 3,
  max_seconds: 5
)
```

- 5초 동안 3번 이상 크래시하면, Supervisor 자신도 내려가며 상위 Supervisor가 처리.

---

### 다운스트림에 “종료를 알리기” — 프로토콜 설계

프로세스가 종료되면 **PID 기반 통신**은 당연히 끊긴다.
하지만 클라이언트가 이 사실을 **도메인 레벨에서 이해**해야 할 때도 있다.

```elixir
defmodule Server do
  def loop(clients) do
    receive do
      {:register, pid} ->
        loop([pid | clients])

      :shutdown ->
        Enum.each(clients, fn pid ->
          send(pid, {:server_stopping, :maintenance})
        end)

        exit({:shutdown, :maintenance})
    end
  end
end
```

- 단순히 프로세스를 종료하는 대신,
  먼저 클라이언트에게 `{:server_stopping, reason}` 메시지를 보내 **정리할 시간**을 준다.
- 클라이언트는 이 메시지를 받아:
  - 재시도할지,
  - 대체 서버에 붙을지,
  - 사용자에게 공지를 띄울지 결정할 수 있다.

---

### 종료/정리 패턴 체크리스트

정리용 체크리스트를 확장해 보자.

- [ ] **파일/소켓/포트**
  - `try/after` 로 닫고, `terminate/2` 에서 한 번 더 안전장치.
- [ ] **Task/워커 취소**
  - `Task.shutdown/2` 로 그레이스풀하게 멈추기.
- [ ] **모니터로 외부 프로세스 추적**
  - 피어/외부 서비스의 다운을 `{:DOWN, ...}` 메세지로 감지,
    재시도/페일오버/알람 처리.
- [ ] **슈퍼비전 트리 설계**
  - 어떤 자식은 `:transient`, 어떤 자식은 `:permanent`
  - subtree를 분리하여 실패 격리.
- [ ] **종료 로그/텔레메트리**
  - 종료 이유, 재시작 횟수, 다운 시간 등을 모니터링 시스템에 전달.

---

## 실전 미니 프로젝트: “병렬 변환 + 역압 + 종료 정리”

요구사항:

- 대량 URL 리스트에 대해 **동시성 제한** 내에서 요청.
- 성공/실패 구분, 타임아웃/오류는 로깅.
- 결과를 파일에 기록하되, 서버 종료 시 **파일 핸들을 깔끔하게 정리**.

### 구현

```elixir
defmodule Crawler do
  use GenServer
  require Logger

  def start_link(path) do
    GenServer.start_link(__MODULE__, path, name: __MODULE__)
  end

  @impl true
  def init(path) do
    {:ok, io} = File.open(path, [:write])
    {:ok, %{io: io}}
  end

  # 외부 API: 역압을 위해 동기 호출
  def crawl(urls), do: GenServer.call(__MODULE__, {:crawl, urls}, 60_000)

  @impl true
  def handle_call({:crawl, urls}, _from, %{io: io} = st) do
    fun = fn url ->
      case fetch(url) do
        {:ok, body} ->
          IO.write(io, url <> "," <> Integer.to_string(byte_size(body)) <> "\n")
          :ok

        {:error, reason} ->
          Logger.warn("fail #{url}: #{inspect(reason)}")
          :error
      end
    end

    urls
    |> Task.async_stream(
      fun,
      max_concurrency: System.schedulers_online() * 2,
      timeout: 5_000,
      on_timeout: :kill_task
    )
    |> Stream.run()

    {:reply, :ok, st}
  end

  defp fetch(url) do
    # 예시: 실제 HTTP 대신 가짜 작업
    if :rand.uniform() < 0.9 do
      Process.sleep(:rand.uniform(30))
      {:ok, :crypto.strong_rand_bytes(100 + :rand.uniform(900))}
    else
      {:error, :timeout}
    end
  end

  @impl true
  def terminate(reason, %{io: io}) do
    Logger.info("crawler terminating: #{inspect(reason)}")
    File.close(io)
    :ok
  end
end

{:ok, _} = Crawler.start_link("sizes.csv")
:ok = Crawler.crawl(for i <- 1..10_000, do: "http://example/#{i}")
```

포인트:

- `crawl/1` 은 **동기**라 호출자가 끝날 때까지 기다린다 → 역압.
- 내부에서는 `Task.async_stream/3` 으로 병렬 처리하되,
  `max_concurrency` 로 동시성 한도, `timeout`/`on_timeout` 으로 느린 작업을 제거.
- `terminate/2` 에서 파일 핸들을 닫아, **종료 시 리소스 누수 방지**.

---

## 흔한 함정 → 교정

1) **무한 `send`로 메일박스 폭주**
   - 증상: `:message_queue_len`이 수만/수십만으로 상승, 메모리 폭증.
   - 교정: `GenServer.call/3`로 역압, 배치 처리, 큐 한도/드롭/거부 정책.

2) **선택적 수신 과다 사용**
   - 증상: 특정 메시지만 계속 소비되고 나머지는 쌓이기만 함.
   - 교정: 공정 수신, 주기적인 전체 수신, 우선순위 큐를 별도 구조로 분리.

3) **파일/소켓 리소스 누수**
   - 증상: FD 고갈, OS 에러(`EMFILE`).
   - 교정: `try/after` + `terminate/2`, 잘못된 예외 경로에서도 항상 닫도록 설계.

4) **링크/모니터 혼동**
   - 증상: 원하지 않는 프로세스까지 함께 죽거나, 죽은 줄도 모르는 피어.
   - 교정: 서로 “운명공동체”여야 할 관계에는 링크,
     단방향 관찰이 필요한 곳에는 모니터를 사용.

5) **Task 무제한 병렬**
   - 증상: 스케줄러 thrash, 높은 레이턴시, 타임아웃 증가.
   - 교정: `Task.async_stream` 의 `max_concurrency` 적극 활용,
     필요하다면 워커 풀/큐를 사용해 부하를 평탄화.

---

## 연습 문제

1) **샤딩 수신자**
   - `n` 개의 수신자 프로세스를 만들고,
     `:erlang.phash2(key, n)` 으로 라우팅하는 샤딩 구조를 만들어 보라.
   - 작업량/지연 시간 측정으로 단일 수신자 구조와 비교해 보라.

2) **배치-쓰기 튜닝**
   - 배치 크기/타임아웃을 변수화하고,
     실제 DB/파일 쓰기 시간과 TPS를 측정해 보라.
   - `Benchee`를 사용해 다양한 파라미터 값에서의 성능 곡선을 그려 볼 것.

3) **모니터 기반 재시도**
   - 외부 워커 프로세스를 모니터하고,
     `{:DOWN, ...}` 메시지를 받았을 때 지수 백오프로 재시도하는 패턴을 작성하라.
   - 최대 재시도 횟수를 넘기면 알람을 올리거나 Supervisor에게 맡겨라.

4) **종료 시나리오 테이블 테스트**
   - 정상 종료, 예외, `GenServer.stop/3`, `Process.exit(pid, :kill)` 등
     다양한 종료 시나리오에 대해 `terminate/2` 호출 여부와 로그 출력을 테스트로 검증하라.

5) **메일박스 헬스체크**
   - 주기적으로 자신의 `:message_queue_len` 을 Telemetry 이벤트로 내보내고,
     일정 임계치를 넘으면 경고 로그를 남기거나 알람을 발행하는 모듈을 작성하라.

---

## 마무리

- **프로세스**는 BEAM의 가장 작은 격리 단위다.
  - `spawn/receive/send` 로 직접 다룰 수 있고,
  - `GenServer/Task/Supervisor` 로 추상화할 수 있다.
- **부하 관리**는 레덕션/스케줄러/메일박스 길이로 관찰하고,
  **배치/역압/워커 풀/샤딩/타임아웃**으로 제어해야 한다.
- **종료**는 정상/비정상/강제/의도적 종료의 스펙트럼이 있다.
  - `link/monitor`, `terminate/2`, Supervisor 전략을 적절히 조합해
    “잘 죽고 잘 일어나는” 시스템을 설계해야 한다.

이 장의 내용을 익숙하게 사용하게 되면,
엘릭서/OTP에서 **단일 노드 동시성은 물론, 분산 시스템과 장애 복구 설계**에 이르기까지
탄탄한 기반을 갖추게 된다.
