---
layout: post
title: 영상처리 - 허프 변환을 이용한 직선 검출
date: 2025-09-29 21:25:23 +0900
category: 영상처리
---
# 허프 변환을 이용한 직선 검출

## 1) 허프 변환을 이용한 직선 검출 방법

### 1.1 직선의 파라메트릭 표현 (ρ–θ)
직선 \(L\) 을 영상 좌표계에서  
\[
\rho = x\cos\theta + y\sin\theta,\qquad \theta \in [0,\pi)
\]
로 표현합니다. 여기서 \(\rho\) 는 원점에서 직선까지의 부호 있는 거리, \(\theta\) 는 법선의 각도입니다.

- 영상 크기를 \(W\times H\) 라 할 때 \(|\rho|\le R\), \(R=\sqrt{W^2+H^2}\).
- \(\theta\) 를 균일 간격 \(\Delta\theta\) 로, \(\rho\) 를 \(\Delta\rho\) 로 양자화하여 **누산기** \(A[\theta\_i,\rho\_j]\) 에 투표합니다.

### 1.2 기본 알고리즘
1) 엣지 픽셀 \((x,y)\) 를 전부 순회  
2) 모든 \(\theta\_i\) 에 대해 \(\rho = x\cos\theta\_i + y\sin\theta\_i\) 계산  
3) \(\rho\) 를 인덱스 \(j\) 로 변환 후 \(A[i,j]++\)  
4) 누산기에서 **피크**(투표 수가 임계 이상)를 찾으면 해당 \((\theta,\rho)\) 가 직선

### 1.3 최적화 아이디어
- \(\cos\theta, \sin\theta\) 를 미리 계산한 **LUT** 사용  
- 엣지 영상의 **0이 아닌 픽셀**만 순회(희소)  
- 가능하면 **그래디언트 방향**(Canny의 \(\theta\)) 근처의 \(\theta\) 만 투표(선택 기능)  
- 허프 공간에서 **NMS(비최대 억제)** 로 중복 피크 제거

---

## 2) 구현 설계

### 2.1 파라미터
- \(\Delta\theta\) (deg): 0.5° ~ 2° 권장, 기본 **1°**  
- \(\Delta\rho\) (px): 1~2 px 권장, 기본 **1 px**  
- 임계 투표 수: 영상 대각선 길이에 비례(경험적으로 **0.3~0.6 × min(W,H)**)  
- 허프 NMS 윈도우: \(\theta\) 축 **±2~3** bin, \(\rho\) 축 **±2~3** bin

### 2.2 출력
- **무한 직선**을 영상 경계 사각형과 교차시켜 **가시 선분**으로 그리기  
- 선택: **최장 엣지 연결선분**으로 정제(확장 가능—간단 버전 포함)

---

## 3) 코드 — LUT 기반 허프 변환 핵심

```cpp
// HoughLines.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <cmath>
#include <algorithm>
#include <utility>
#include <limits>
#include "IppDib.h"
#include "Canny.hpp" // 11.2절 - 선택적 사용

struct HoughOptions {
    double thetaStepDeg = 1.0;    // Δθ (deg)
    double rhoStep      = 1.0;    // Δρ (px)
    int    voteThresh   = 80;     // 누산 임계(피크 최소 투표)
    int    nmsThetaWin  = 3;      // 허프 공간 NMS 윈도우(θ)
    int    nmsRhoWin    = 3;      // 허프 공간 NMS 윈도우(ρ)
    int    maxLines     = 20;     // 최대 직선 개수
    bool   useCanny     = true;   // 내부적으로 Canny 수행?
    // Canny 옵션(간단)
    double cannySigma   = 1.2;
    int    cannyLow     = 50;
    int    cannyHigh    = 120;
};

struct HoughLine {
    double theta; // rad, [0, π)
    double rho;   // px,  [-R, R]
    int    votes; // 피크 높이
};

// -----------------------------
// 보조 유틸: 엣지 바이너리 얻기
// -----------------------------
inline void DibToGray8(const IppDib& src, std::vector<uint8_t>& Y, int& W, int& H)
{
    W=src.width(); H=src.height();
    Y.assign((size_t)W*H, 0);
    for (int y=0;y<H;++y){
        const uint8_t* s=(const uint8_t*)src.bits()+(size_t)y*src.stride();
        for (int x=0;x<W;++x){
            int B=s[x*4+0], G=s[x*4+1], R=s[x*4+2];
            int y8=(114*B + 587*G + 299*R + 500)/1000;
            Y[(size_t)y*W+x]=(uint8_t)std::clamp(y8,0,255);
        }
    }
}

inline void GetEdgesBinary(const IppDib& src, const HoughOptions& opt,
                           std::vector<uint8_t>& E, int& W, int& H)
{
    if (opt.useCanny){
        CannyOptions co; co.sigma=opt.cannySigma; co.low=opt.cannyLow; co.high=opt.cannyHigh;
        co.out = CannyOut::Edges;
        IppDib edges; CannyEdge(src, edges, co);
        W=edges.width(); H=edges.height();
        E.assign((size_t)W*H,0);
        for (int y=0;y<H;++y){
            const uint8_t* s=(const uint8_t*)edges.bits()+(size_t)y*edges.stride();
            for (int x=0;x<W;++x){
                E[(size_t)y*W+x] = s[x*4]; // 0 또는 255
            }
        }
    } else {
        // 그레이 임계(간단): Otsu 필요시 확장
        std::vector<uint8_t> Y; DibToGray8(src, Y, W, H);
        // 평균 기반
        long long sum=0; for (auto v:Y) sum+=v;
        int thr = (int)(sum / std::max(1,(int)Y.size()));
        E.resize(Y.size());
        for (size_t i=0;i<Y.size();++i) E[i] = (Y[i]>=thr? 255:0);
    }
}

// -----------------------------
// 핵심: LUT 기반 허프 변환
// -----------------------------
inline void HoughVote_LUT(const std::vector<uint8_t>& E, int W, int H,
                          const HoughOptions& opt,
                          std::vector<int>& Acc, int& nTheta, int& nRho,
                          std::vector<double>& cosT, std::vector<double>& sinT,
                          double& rhoMin)
{
    const double thetaStep = opt.thetaStepDeg * M_PI / 180.0;
    nTheta = (int)std::floor(M_PI / thetaStep + 0.5);
    if (nTheta<1) nTheta=1;

    double R = std::hypot((double)W, (double)H);
    nRho  = (int)std::floor((2.0*R)/opt.rhoStep + 1.0);
    rhoMin = -R;

    // LUT
    cosT.resize(nTheta); sinT.resize(nTheta);
    for (int i=0;i<nTheta;++i){
        double t = i*thetaStep;
        cosT[i]=std::cos(t); sinT[i]=std::sin(t);
    }

    Acc.assign((size_t)nTheta*nRho, 0);

    auto at=[&](int ti,int ri)->int&{ return Acc[(size_t)ti*nRho + ri]; };

    // 희소 투표: 엣지 픽셀만 순회
    for (int y=0;y<H;++y){
        const uint8_t* row = &E[(size_t)y*W];
        for (int x=0;x<W;++x){
            if (!row[x]) continue; // edge!=0 만 투표
            for (int ti=0; ti<nTheta; ++ti){
                double rho = x*cosT[ti] + y*sinT[ti];
                int ri = (int)std::floor((rho - rhoMin)/opt.rhoStep + 0.5);
                if ((unsigned)ri < (unsigned)nRho) at(ti,ri)++;
            }
        }
    }
}

// -----------------------------
// 허프 공간 NMS & 피크 추출
// -----------------------------
inline std::vector<HoughLine> HoughPeaks(const std::vector<int>& Acc, int nTheta, int nRho,
                                         const HoughOptions& opt,
                                         const std::vector<double>& cosT,
                                         const std::vector<double>& sinT,
                                         double rhoMin)
{
    auto A=[&](int ti,int ri)->int{ return Acc[(size_t)ti*nRho + ri]; };
    std::vector<HoughLine> peaks;
    for (int ti=0;ti<nTheta;++ti){
        for (int ri=0;ri<nRho;++ri){
            int v = A(ti,ri);
            if (v < opt.voteThresh) continue;

            bool isMax=true;
            for (int dt=-opt.nmsThetaWin; dt<=opt.nmsThetaWin && isMax; ++dt){
                int tj = (ti+dt + nTheta)%nTheta; // θ는 원형
                for (int dr=-opt.nmsRhoWin; dr<=opt.nmsRhoWin; ++dr){
                    if (dt==0 && dr==0) continue;
                    int rj = ri+dr;
                    if ((unsigned)rj>=(unsigned)nRho) continue;
                    if (A(tj,rj) > v){ isMax=false; break; }
                }
            }
            if (!isMax) continue;

            double theta = std::atan2(sinT[ti], cosT[ti]); // = ti*Δθ
            if (theta<0) theta+=M_PI;
            double rho   = rhoMin + ri*opt.rhoStep;
            peaks.push_back({theta, rho, v});
        }
    }
    // votes 내림차순
    std::sort(peaks.begin(), peaks.end(), [](auto& a, auto& b){ return a.votes>b.votes; });
    if ((int)peaks.size() > opt.maxLines) peaks.resize(opt.maxLines);
    return peaks;
}

// -----------------------------
// 직선(ρ,θ)을 영상 경계로 클리핑하여 두 점 반환
// -----------------------------
struct Pt { double x,y; };
inline bool ClipRhoThetaToSegment(double rho, double theta, int W,int H, Pt& p1, Pt& p2)
{
    // 경계선과의 교점 계산: x=0, x=W-1, y=0, y=H-1 와의 교차
    std::vector<Pt> cand;

    auto addIfInside=[&](double x, double y){
        if (x>=-0.5 && x< W-0.5 && y>=-0.5 && y< H-0.5) cand.push_back({x,y});
    };

    double c=std::cos(theta), s=std::sin(theta);
    // y = (rho - x*c)/s   (s≈0 주의)
    // x = (rho - y*s)/c   (c≈0 주의)
    if (std::fabs(s)>1e-9){
        addIfInside(0.0,       (rho - 0.0*c)/s);
        addIfInside(W-1.0,     (rho - (W-1.0)*c)/s);
    }
    if (std::fabs(c)>1e-9){
        addIfInside((rho - 0.0*s)/c,       0.0);
        addIfInside((rho - (H-1.0)*s)/c,   H-1.0);
    }

    // 중복/정렬
    if (cand.size()<2) return false;
    // 유니크(근접 포인트 합치기)
    auto eq=[&](const Pt&a,const Pt&b){ return std::hypot(a.x-b.x,a.y-b.y) < 1e-3; };
    std::vector<Pt> uniq; for (auto& q:cand){
        bool dup=false; for (auto& u:uniq){ if (eq(q,u)){ dup=true; break; } }
        if (!dup) uniq.push_back(q);
    }
    if (uniq.size()<2) return false;
    // 가장 멀리 떨어진 두 점 선택(안정)
    double best=-1; Pt A{},B{};
    for (size_t i=0;i<uniq.size();++i) for (size_t j=i+1;j<uniq.size();++j){
        double d=std::hypot(uniq[i].x-uniq[j].x, uniq[i].y-uniq[j].y);
        if (d>best){ best=d; A=uniq[i]; B=uniq[j]; }
    }
    p1=A; p2=B; return true;
}

// -----------------------------
// 선 그리기(Bresenham, 1px, 지정 색)
// -----------------------------
inline void DrawLine(IppDib& dst, Pt a, Pt b, uint8_t r, uint8_t g, uint8_t bgr)
{
    auto roundi=[&](double v)->int{ return (int)std::lround(v); };
    int x0=roundi(a.x), y0=roundi(a.y);
    int x1=roundi(b.x), y1=roundi(b.y);

    int dx=std::abs(x1-x0), sx=x0<x1?1:-1;
    int dy=-std::abs(y1-y0), sy=y0<y1?1:-1;
    int err=dx+dy, e2;

    auto put=[&](int x,int y){
        if ((unsigned)x>=(unsigned)dst.width() || (unsigned)y>=(unsigned)dst.height()) return;
        uint8_t* p=(uint8_t*)dst.bits()+(size_t)y*dst.stride()+x*4;
        p[0]=bgr; p[1]=g; p[2]=r; p[3]=255;
    };
    while (true){
        put(x0,y0);
        if (x0==x1 && y0==y1) break;
        e2 = 2*err;
        if (e2>=dy){ err+=dy; x0+=sx; }
        if (e2<=dx){ err+=dx; y0+=sy; }
    }
}

// -----------------------------
// 공개 API: 허프 수행 + 라인 그리기
// -----------------------------
inline bool HoughDetectLines(const IppDib& input, IppDib& output,
                             const HoughOptions& opt,
                             std::vector<HoughLine>* outLines=nullptr)
{
    if (!input) return false;

    // 1) 엣지 이진화
    std::vector<uint8_t> E; int W,H;
    GetEdgesBinary(input, opt, E, W, H);

    // 2) 허프 투표(LUT)
    std::vector<int> Acc; int nTheta=0, nRho=0;
    std::vector<double> cosT, sinT; double rhoMin=0;
    HoughVote_LUT(E, W,H, opt, Acc, nTheta, nRho, cosT, sinT, rhoMin);

    // 3) 피크 추출(NMS)
    auto peaks = HoughPeaks(Acc, nTheta, nRho, opt, cosT, sinT, rhoMin);

    if (outLines) *outLines = peaks;

    // 4) 원본 복사 후 선 그리기
    output = input; // 깊은 복사(프로젝트의 IppDib 대입 연산자 가정)
    for (auto& h : peaks){
        Pt p1{}, p2{};
        if (ClipRhoThetaToSegment(h.rho, h.theta, W,H, p1,p2)){
            // 빨간색 1px
            DrawLine(output, p1,p2, /*r=*/255, /*g=*/16, /*b=*/16);
        }
    }
    return true;
}
```

---

## 4) (선택) **확장** — 확률적 허프(PHough) 스타일의 빠른 추출

> 아래는 **선택 기능**으로, 많은 엣지에서 임의 샘플이나 그래디언트 방향 제한으로 투표량을 줄이는 간단 확장입니다.  
> 본문 기본 함수는 표준 허프이며, 필요시 이 아이디어로 고속화할 수 있습니다.

- **방향 제한**: 엣지 픽셀의 그래디언트 각 \(\theta\_g\) 를 이미 알고 있다면, \(\theta\) 투표를 \(\theta\_g \pm \delta\) 범위로 제한(예: \(\delta=10°\)).  
- **랜덤 서브샘플링**: 엣지의 20~50%만 투표.

---

## 5) UI — 허프 변환 대화 상자 & 메뉴

### 5.1 리소스 ID

```cpp
// resource.h (추가)
#define IDD_HOUGH_DLG                3600
#define IDC_EDIT_HOUGH_THETA         3601
#define IDC_EDIT_HOUGH_RHO           3602
#define IDC_EDIT_HOUGH_THRESH        3603
#define IDC_EDIT_HOUGH_NMST          3604
#define IDC_EDIT_HOUGH_NMSR          3605
#define IDC_EDIT_HOUGH_MAXL          3606
#define IDC_CHK_HOUGH_CANNY          3607
#define IDC_EDIT_HOUGH_CANNY_SIGMA   3608
#define IDC_EDIT_HOUGH_CANNY_LOW     3609
#define IDC_EDIT_HOUGH_CANNY_HIGH    3610

// 메뉴
#define ID_MENU_HOUGH_LINES          75000
```

### 5.2 RC(대화 상자/메뉴)

```rc
// ImageTool.rc (추가)
IDD_HOUGH_DLG DIALOGEX 0,0, 260, 196
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Hough Lines"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Theta step (deg):", -1, 14, 14, 84, 10
    EDITTEXT IDC_EDIT_HOUGH_THETA, 104, 12, 36, 14, ES_AUTOHSCROLL
    LTEXT "Rho step (px):", -1, 150, 14, 62, 10
    EDITTEXT IDC_EDIT_HOUGH_RHO, 214, 12, 30, 14, ES_AUTOHSCROLL

    LTEXT "Vote thresh:", -1, 14, 34, 84, 10
    EDITTEXT IDC_EDIT_HOUGH_THRESH, 104, 32, 36, 14, ES_NUMBER
    LTEXT "NMS (θ,ρ):", -1, 150, 34, 62, 10
    EDITTEXT IDC_EDIT_HOUGH_NMST, 214, 32, 14, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_HOUGH_NMSR, 230, 32, 14, 14, ES_NUMBER

    LTEXT "Max lines:", -1, 14, 54, 84, 10
    EDITTEXT IDC_EDIT_HOUGH_MAXL, 104, 52, 36, 14, ES_NUMBER

    AUTOCHECKBOX "Use Canny", IDC_CHK_HOUGH_CANNY, 14, 74, 64, 12
    LTEXT "σ:", -1, 88, 74, 10, 10
    EDITTEXT IDC_EDIT_HOUGH_CANNY_SIGMA, 100, 72, 30, 14, ES_AUTOHSCROLL
    LTEXT "Low:", -1, 134, 74, 16, 10
    EDITTEXT IDC_EDIT_HOUGH_CANNY_LOW, 152, 72, 30, 14, ES_NUMBER
    LTEXT "High:", -1, 186, 74, 18, 10
    EDITTEXT IDC_EDIT_HOUGH_CANNY_HIGH, 206, 72, 38, 14, ES_NUMBER

    DEFPUSHBUTTON "OK", IDOK,  130, 154, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 180, 154, 44, 16
END

// 메뉴 & 가속키
POPUP "&Spatial"
BEGIN
    MENUITEM "Hough Lines...\tCtrl+H", ID_MENU_HOUGH_LINES
END

IDR_ACCEL ACCELERATORS
BEGIN
    "H", ID_MENU_HOUGH_LINES, VIRTKEY, CONTROL
END
```

### 5.3 대화 상자 코드 & 메뉴 핸들러

```cpp
// HoughDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "HoughLines.hpp"

class HoughDlg {
public:
    HoughDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM, LPARAM);

    double ReadDouble(HWND h, int id, double def) const;
    int    ReadInt   (HWND h, int id, int def) const;
    bool   IsChecked (HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }

private:
    HWND owner_{};
    IppDib& dib_;
};
```

```cpp
// HoughDlg.cpp
#include "HoughDlg.h"

INT_PTR HoughDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_HOUGH_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK HoughDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(HoughDlg*)l; return self->OnInit(h); }
    auto* self=(HoughDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w,l);
    return FALSE;
}
INT_PTR HoughDlg::OnInit(HWND h){
    SetDlgItemTextW(h, IDC_EDIT_HOUGH_THETA, L"1.0");
    SetDlgItemTextW(h, IDC_EDIT_HOUGH_RHO,   L"1.0");
    SetDlgItemInt  (h, IDC_EDIT_HOUGH_THRESH, 90, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_HOUGH_NMST,    3, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_HOUGH_NMSR,    3, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_HOUGH_MAXL,   12, FALSE);
    CheckDlgButton (h, IDC_CHK_HOUGH_CANNY, BST_CHECKED);
    SetDlgItemTextW(h, IDC_EDIT_HOUGH_CANNY_SIGMA, L"1.2");
    SetDlgItemInt  (h, IDC_EDIT_HOUGH_CANNY_LOW,    50, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_HOUGH_CANNY_HIGH,  120, FALSE);
    return TRUE;
}
double HoughDlg::ReadDouble(HWND h, int id, double def) const{
    wchar_t buf[64]; if (!GetDlgItemTextW(h, id, buf, 63)) return def;
    try { return std::stod(std::wstring(buf)); } catch(...) { return def; }
}
int HoughDlg::ReadInt(HWND h, int id, int def) const{
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE); return ok? v : def;
}
INT_PTR HoughDlg::OnCommand(HWND h, WPARAM w, LPARAM){
    switch(LOWORD(w)){
    case IDOK: {
        HoughOptions opt;
        opt.thetaStepDeg = ReadDouble(h, IDC_EDIT_HOUGH_THETA, 1.0);
        opt.rhoStep      = ReadDouble(h, IDC_EDIT_HOUGH_RHO,   1.0);
        opt.voteThresh   = ReadInt   (h, IDC_EDIT_HOUGH_THRESH, 90);
        opt.nmsThetaWin  = ReadInt   (h, IDC_EDIT_HOUGH_NMST,   3);
        opt.nmsRhoWin    = ReadInt   (h, IDC_EDIT_HOUGH_NMSR,   3);
        opt.maxLines     = ReadInt   (h, IDC_EDIT_HOUGH_MAXL,  12);
        opt.useCanny     = IsChecked (h, IDC_CHK_HOUGH_CANNY);
        opt.cannySigma   = ReadDouble(h, IDC_EDIT_HOUGH_CANNY_SIGMA, 1.2);
        opt.cannyLow     = ReadInt   (h, IDC_EDIT_HOUGH_CANNY_LOW,   50);
        opt.cannyHigh    = ReadInt   (h, IDC_EDIT_HOUGH_CANNY_HIGH, 120);

        IppDib out; std::vector<HoughLine> lines;
        if (HoughDetectLines(dib_, out, opt, &lines)){
            dib_ = out;
        }
        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

```cpp
// main_multiwin.cpp (발췌)
#include "HoughDlg.h"

// ...
case ID_MENU_HOUGH_LINES:
    if (st && st->dib){
        HoughDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 6) 수학 팁: 누산기 크기와 임계 설정

- \(\theta\) bin 수: \(N_\theta \approx \left\lfloor \dfrac{\pi}{\Delta\theta} \right\rfloor\)  
- \(\rho\) bin 수: \(N_\rho \approx \left\lfloor \dfrac{2R}{\Delta\rho} \right\rfloor+1\), \(R=\sqrt{W^2+H^2}\)  
- 메모리: \(N_\theta\times N_\rho \times 4\) 바이트(int). 예) \(W=1280,H=720,\Delta\theta=1^\circ,\Delta\rho=1\) → \(~(180×~1473)≈265k\) 셀, 약 1.0MB.  
- 임계(경험): \( \text{voteThresh} \approx 0.4\times \min(W,H) \) 부근에서 시작해 조정.

---

## 7) 예제 & 상황

### 예제 A) **문서 기울기 보정(데스큐)**
- **상황**: 스캔한 문서가 약간 기울어져 있음  
- **동작**: `Spatial → Hough Lines…`  
  - θ step=1°, ρ step=1, vote=100, NMS=(3,3), Max=8, Use Canny(σ=1.2, 50/120)  
- **결과**: 상하 여백과 텍스트 줄 직선 검출 → 가장 강한 수평(또는 수직) 직선의 θ로 기울기 추정 → 9.3절 회전으로 보정.

### 예제 B) **차선 후보 검출(전방 카메라)**
- **상황**: 도로 차선(거의 수렴하는 두 직선)  
- **동작**: θ step=1°, ρ step=2, vote=120, Max=6  
- **결과**: 좌우 차선 직선 검출 → ROI(하단 영역)만 엣지/허프로 제한하면 정확도↑.

### 예제 C) **수평선/지평선 탐지(수평 안정화)**
- **상황**: 드론 영상에서 지평선  
- **동작**: θ step=0.5°, vote=150, Max=3  
- **결과**: 가장 강한 거의 수평 직선의 θ로 롤 보정.

### 예제 D) **격자 패턴에서 주방향 검출**
- **상황**: 건축 이미지의 격자 구조  
- **동작**: θ step=1°, vote=90, Max=10  
- **결과**: 상호 직교(≈90°) 두 방향의 피크가 우세 → 구조적 분석.

---

## 8) 성능/정확도/확장 팁

- **LUT 재사용**: 동일한 영상 크기/파라미터로 반복 실행 시 \(\cos,\sin\) 테이블은 캐시(정적)  
- **방향 제한(고급)**: Canny의 방향을 활용해 \(\theta\) 후보를 \(\theta\_g\pm \delta\) 로 좁히면 **수십 배** 가속  
- **NMS 윈도우**: 너무 작으면 중복선, 너무 크면 근접 평행선 소거  
- **선분화(고급)**: 무한 직선 대신 **확률적 허프(PHT)** 나 **누산기 역추적**으로 최장 연속 엣지 구간을 선분으로 반환  
- **후처리**: 근접 \((\rho,\theta)\) 피크 **병합**(평균)으로 중복 제거  
- **색상 오버레이**: 결과 선을 붉은색(255,16,16)으로 그려 시각적 구분 유지

---

## 9) 간단 테스트 스니펫

```cpp
// test_hough.cpp
#include <cassert>
#include "HoughLines.hpp"

int main(){
    // 1) 인공 수평선 생성
    const int W=256,H=128;
    IppDib img; img.create(W,H,32);
    // 배경 검정
    for (int y=0;y<H;++y){
        uint8_t* d=(uint8_t*)img.bits()+(size_t)y*img.stride();
        for (int x=0;x<W;++x) d[x*4+0]=d[x*4+1]=d[x*4+2]=0, d[x*4+3]=255;
    }
    // y=64 위치에 하얀 수평선
    {
        int y=64;
        uint8_t* d=(uint8_t*)img.bits()+(size_t)y*img.stride();
        for (int x=0;x<W;++x) d[x*4+0]=d[x*4+1]=d[x*4+2]=255;
    }

    HoughOptions opt; opt.useCanny=false; // 이미 이진에 가까움
    opt.thetaStepDeg=1.0; opt.rhoStep=1.0; opt.voteThresh=60; opt.maxLines=5;

    IppDib out; std::vector<HoughLine> lines;
    bool ok = HoughDetectLines(img, out, opt, &lines); assert(ok);
    assert(!lines.empty());

    // 가장 강한 선의 θ가 약 90°(수평선의 법선) 근처인지 확인
    double thetaDeg = lines[0].theta * 180.0 / M_PI;
    assert(thetaDeg>80 && thetaDeg<100);
    return 0;
}
```

---

## 10) 요약
- 허프 변환은 직선을 **(ρ,θ)** 로 변환하여 **누산기 피크**로 검출합니다.  
- **LUT 기반**으로 \(\cos,\sin\) 을 캐시해 고속 투표, **허프 NMS** 로 중복 제거.  
- 결과는 영상 경계에 **클리핑된 선분**으로 시각화.  
- UI(대화 상자/메뉴)로 θ/ρ 스텝, 임계, NMS, 최대 개수, 그리고 **Canny 전처리**를 손쉽게 조절.  
- 서브샘플링·방향 제한·선분화 등으로 **실시간 수준**까지 확장 가능합니다.