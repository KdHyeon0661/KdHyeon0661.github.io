---
layout: post
title: 데이터 통신 - Digital Transmission (3)
date: 2024-07-19 19:20:23 +0900
category: DataCommunication
---
# Block Coding & 4.1.4 Scrambling — 확장본

## 들어가며 — 왜 Block Coding·Scrambling을 쓰는가

라인 코딩만으로는 **런 길이 제한/동기화(CDR)/DC 균형/제어 심볼** 같은 요구를 모두 만족시키기 어렵습니다.
그래서 **Block Coding(블록코딩)** 과 **Scrambling(스크램블링)** 을 결합해 다음을 달성합니다.

- **동기 안정성(CDR)**: 전이가 충분히 나오도록 **런 길이를 제한**.
- **DC 균형**: 평균 레벨을 0에 가깝게 유지해 **트랜스/커패시터 결합 링크** 통과.
- **제어 심볼**: 프레임 경계, 아이들, 정렬, 오류 신호 등을 **특수 코드 그룹**으로 제공.
- **오류 검출**: 불가능한 패턴(violation)이나 여분 코드를 이용해 **1비트 이상의 오류 감지**.
- **대역/효율의 절충**: 오버헤드(예: 4B/5B=+25%, 8b/10b=+25%)를 감수하고 **링크 신뢰성** 확보.

> 표기: 비트율 \(N\) (bps), 신호율 \(S\) (baud), 레벨 수 \(L\), 심볼당 비트수 \(r=\log_2 L\).
> 대역 근사: \(B \propto S\) (펄스/필터/채널에 따라 상수 달라짐).

---

## Block Coding — mB/nB 기본 개념

- **정의**: 원 데이터의 **m비트 블록**을 **n비트 블록**으로 치환(\(m<n\))하여
  **런 길이 제한**, **전이 보장**, **제어 심볼**, **DC 특성 제어** 등을 달성.
- **단계**: division(분해) → substitution(치환) → combination(결합).
- **예**: `0000` 처럼 전이가 부족한 블록을 `00100` 같은 **전이 포함 패턴**으로 매핑.
- **오버헤드**: \(n>m\) ⇒ **전송 효율↓** / **필요 대역폭↑**.
  예) 4B/5B면 비트율 100 Mbps를 **라인 심볼율 125 MBd**로 보냄.
- **여분 코드 활용**: \(2^n-2^m\)개의 **유효하지 않은/특수 코드**를
  **오류 검출/프레임 제어/아이들/컴마(정렬)** 등에 사용.
- **DC 균형**: 블록 내 `1`과 `0`의 개수를 **균형**(또는 누적 편차 관리)하도록 설계.

수식 감각(효율, 라인 레이트):
\[
\text{효율} = \frac{m}{n},\qquad
\text{라인비트율} = \frac{n}{m}\,N,\qquad
S \approx \alpha \cdot \text{라인비트율}
\]
여기서 \(\alpha\)는 라인 코딩(NRZ-I/MLT-3 등)에 따른 상수(대략 0.5~1).

---

## 4B/5B — NRZ-I와 찰떡궁합

### 설계 목표

- **NRZ-I**는 대역 효율이 좋지만, **긴 `0` 런에서 전이가 사라져 CDR 취약**.
  → 4B/5B는 **전이가 나오도록** 4비트를 5비트로 바꿔 **런 길이를 제한**.
- 일반 제약(대표적 구현 가이드):
  - 5비트 블록 **내부에 최소 한 번 전이**가 나도록 설계.
  - **연속 `0` 3개 이상 금지** (런 길이 제한).
  - 전체적으로 `0/1` 비 균형이 크지 않게 테이블 구성(완전한 DC balance 보장은 아님).
- **결합**: (4B/5B) → **NRZ-I** → 물리 전송.
  (10/100 Mb급 FDDI, 100BASE-TX/FX 등에서 사용)

### 대표 매핑(예시)

> 주의: 표는 표준 구현의 한 예시이며, 실제 표준 문서의 테이블을 확인해야 합니다.

| 4b | 5b 코드 | 비고 |
|---|---|---|
| 0000 | 11110 | 전이 보장, 런 제한 |
| 0001 | 01001 |  |
| 0010 | 10100 |  |
| 0011 | 10101 |  |
| 0100 | 01010 |  |
| 0101 | 01011 |  |
| 0110 | 01110 |  |
| 0111 | 01111 |  |
| 1000 | 10010 |  |
| 1001 | 10011 |  |
| 1010 | 10110 |  |
| 1011 | 10111 |  |
| 1100 | 11010 |  |
| 1101 | 11011 |  |
| 1110 | 11100 |  |
| 1111 | 11101 |  |

- **특수 코드(예)**: `11111`, `00000`, `00100` 등은 **아이들/정렬/에러** 목적에 할당 가능.
- **효율/속도**: 효율 \(=4/5=80\%\). 100 Mbps 비트열 → **125 MBd** 라인비트율.

### 4B/5B + NRZ-I 파이프라인

1) **입력 비트열**을 4비트씩 슬라이스.
2) **테이블 치환**으로 5비트 코드열 생산.
3) **NRZ-I 인코딩**(비트 시작 **전이=’1’**)으로 물리 파형 생성.
4) 링크 상에서 전송.

### 간단 인코더/디코더(예시 코드)

```python
# 4B/5B 예시 매핑(대표 구현의 한 예; 실제 표준 표와 다를 수 있음)

MAP_4B5B = {
    "0000":"11110","0001":"01001","0010":"10100","0011":"10101",
    "0100":"01010","0101":"01011","0110":"01110","0111":"01111",
    "1000":"10010","1001":"10011","1010":"10110","1011":"10111",
    "1100":"11010","1101":"11011","1110":"11100","1111":"11101"
}
INV_5B4B = {v:k for k,v in MAP_4B5B.items()}

def encode_4b5b(bitstr):
    assert len(bitstr) % 4 == 0
    out = []
    for i in range(0, len(bitstr), 4):
        out.append(MAP_4B5B[bitstr[i:i+4]])
    return ''.join(out)

def decode_5b4b(code5):
    assert len(code5) % 5 == 0
    out = []
    for i in range(0, len(code5), 5):
        block = code5[i:i+5]
        if block not in INV_5B4B:
            raise ValueError(f"Invalid 5B block (control/illegal): {block}")
        out.append(INV_5B4B[block])
    return ''.join(out)
```

---

## 8b/10b — DC 균형과 제어 심볼의 제왕

### 핵심 아이디어

- **8비트 → 10비트**(오버헤드 25%).
- 두 단계 매핑: **5b/6b + 3b/4b** (부분-부분으로 변환).
- **DC Balance(러닝 디스패리티, RD)**: 누적된 `1/0` 불균형을 추적해 **양(+)·음(−) 코드**를 **교대 선택**.
- **런 길이 제한/전이 보장**: **최대 연속 동일 비트 5개** 정도로 제한.
- **제어 심볼**: K-코드(예: **K28.5**)를 도입해 **컴마(정렬)**, 프레임 구분, 아이들 등 제공.
- **오류 검출**: 불가능한 조합/잘못된 RD 전환으로 **1비트 이상 오류** 일부 검출 가능.

### 러닝 디스패리티(RD)

- 블록마다 `1`과 `0`의 개수 차이(디스패리티)를 관리.
  \[
  \text{disp}(blk) = \#1 - \#0
  \]
- 송신기는 누적 RD를 기억하고, 같은 8비트 입력에 대해 **양/음 버전** 중 하나를 선택해 **누적 RD를 0 근방**으로 유지.
- 결과: **DC 균형**, 스펙트럼에서 0 Hz 성분 최소화.

### 8b/10b 파이프라인(개념)

1) 8비트 입력 → **5b/6b 변환**(양/음 버전 존재).
2) 남은 3비트 → **3b/4b 변환**(양/음 버전 존재).
3) 현재 **누적 RD**를 참조해 **양/음 코드를 선택**.
4) **제어 필요 시 K-코드(예: K28.5)** 삽입.
5) **라인 코딩**(보통 NRZ 계열) 후 전송.

### 간단 러닝 디스패리티 흐름(예시 코드)

> 실제 8b/10b 테이블은 길고 복잡하므로, 아래는 **RD 선택 로직 스켈레톤** 예시입니다.

```python
# 테이블: 실제 표준 테이블과 다릅니다!
# 실제 사용시 반드시 표준 테이블(5b/6b, 3b/4b, K코드 포함)을 적용하세요.

FAKE_5B6B = {  # 데이터 일부만 가정
    ("00000","+"): "100111", ("00000","-"): "011000",
    # ...
}
FAKE_3B4B = {
    ("000","+"): "1011", ("000","-"): "0100",
    # ...
}

def disparity(bits):
    # 1개수 - 0개수
    return bits.count('1') - bits.count('0')

def encode_8b10b(byte_bits, rd='+'):
    # byte_bits: length 8 string
    b5, b3 = byte_bits[:5], byte_bits[5:]
    # 1) 5b/6b with RD choice
    c6 = FAKE_5B6B[(b5, rd)]
    rd = '+' if (rd=='+' and disparity(c6)<=0) or (rd=='-' and disparity(c6)<0) else '-'  # 개념적 전환
    # 2) 3b/4b with updated RD
    c4 = FAKE_3B4B[(b3, rd)]
    rd_total = disparity(c6 + c4)
    # RD 업데이트 규칙은 표준에 맞게 더 정교함
    new_rd = '+' if rd_total >= 0 else '-'
    code10 = c6 + c4
    return code10, new_rd
```

### 8b/10b 장단점

- **장점**
  - **DC 균형** 탁월(러닝 디스패리티).
  - **전이 보장/런 제한** → CDR 우수.
  - **K-코드(제어)** 로 프레임/정렬 등 **프로토콜 운용에 매우 편리**.
  - 일부 **오류 검출** 가능(불법 조합/RD 위반).
- **단점**
  - **오버헤드 25%**: 라인 레이트 상승, 대역폭↑.
  - 테이블·RD 로직으로 **복잡도↑**.

---

## Scrambling — 비트 통계 평탄화·런 분해·CDR 개선

### 개념

- 입력 비트를 **가역적 필터(예: LFSR 기반)** 로 섞어 **전이 확률을 균일화**.
- **장점**: 추가 비트 없이 **런 감소**, **EMI/스펙트럼 평탄화**, **CDR 안정화**.
- **주의**: 스크램블만으로 **DC 완전 제거** 보장은 아님(평균적으로 개선).
- **복원**: 수신측은 **동일 LFSR**로 **디스크램블링**(가역).

### 선형 스크램블러(예시: LFSR)

- 원리: \(\text{out}(k) = \text{in}(k) \oplus f(\text{state})\)
- 한 예(다항식 \(x^7 + x^4 + 1\)):
  ```python
  def lfsr_scramble(bits, taps=(7,4), seed=0b1111111):
      state = seed & 0x7f  # 7비트
      out=[]
      for b in bits:
          fb = ((state>>(taps[0]-1)) ^ (state>>(taps[1]-1))) & 1
          sbit = fb ^ int(b)         # 입력 XOR
          out.append('1' if sbit else '0')
          state = ((state<<1)&0x7e) | fb
      return ''.join(out)
  ```
- 실제 표준은 **다항식/초기값/삽입 위치** 등이 정해져 있으며, **동기 유지**도 고려.

---

## B8ZS & HDB3 — AMI의 긴 `0` 문제를 깨부수기

### 배경

- **AMI(Alternate Mark Inversion)**: `1`이 나올 때 **+/−** 교번, `0`은 **0V** → 평균 0, **DC 억제**.
- **문제**: **긴 `0` 런**에서 **전이가 없어** CDR 실패.
- **해법**: **특정 길이의 `0` 시퀀스**가 나오면 **규정된 “위반 패턴(violation)”**으로 **치환**.
  수신측은 **불가능한 패턴**을 보고 “아, 저건 **치환이구나**” 하고 **원래 `0`들**로 복원.

### — 8개의 `0` 치환

- 규칙(개념): **`00000000`** 등장 시 **`000VB0VB`** (혹은 부호 반전 버전)로 치환.
  - `B`: bipolar pulse(직전 부호 규칙 유지)
  - `V`: **violation pulse**(부호 규칙 위반)
- **직전 유효 펄스의 부호**에 따라 **패턴의 부호**를 결정(일관된 설계 규칙 존재).
- 효과: **전이 삽입**으로 CDR 회복, 평균 0 유지.

#### B8ZS 개념적 알고리즘(의사코드)

```python
def b8zs_substitute(ami_levels):
    """
    ami_levels: AMI 부호화된 레벨 시퀀스 [+V, -V, 0, ...]
    8개의 0을 발견하면 000VB0VB (부호 규칙에 맞춘 부호 버전)으로 치환.
    """
    out = []
    i = 0
    last_pulse = -1  # 직전 ±V 표식(+1/-1), 시작 가정
    V = 1.0
    while i < len(ami_levels):
        # 8개의 0 탐색
        if i+8 <= len(ami_levels) and all(x==0.0 for x in ami_levels[i:i+8]):
            # 직전 부호(last_pulse)에 따라 V/B 배치 부호 결정
            # 간단 버전: (+)를 +V, (-)를 -V로, 위반(V)은 규칙을 일부러 어김
            # 여기서는 개념만 보이도록 예시 부호를 넣음:
            if last_pulse > 0:
                pattern = [0,0,0, +V, 0, -V, +V, -V]  # 000VB0VB 예시
                last_pulse = -1
            else:
                pattern = [0,0,0, -V, 0, +V, -V, +V]
                last_pulse = +1
            out.extend(pattern)
            i += 8
        else:
            x = ami_levels[i]
            out.append(x)
            if x != 0.0:
                last_pulse = +1 if x>0 else -1
            i += 1
    return out
```
> 실제 표준은 **정확한 부호 선택 규칙**을 포함합니다. 위 의사코드는 **개념 전달용**입니다.

### — 4개의 `0` 치환 + DC 균형 고려

- 규칙(개념): **`0000`**이 등장할 때마다 **`B00V`** 또는 **`000V`**로 치환.
- **선택 기준**: 치환 전까지의 **비영(±) 펄스 개수(=부호 합)**가
  - **짝수**이면: **`B00V`**
  - **홀수**이면: **`000V`**
  → 이렇게 해서 **부호(±) 총합이 항상 균형**(짝수)이 되도록 관리 → **DC 억제** 강화.
- 효과: **최대 연속 `0` 길이가 3으로 제한** → CDR 강력, DC 균형 우수.

#### HDB3 개념적 알고리즘(의사코드)

```python
def hdb3_substitute(ami_levels):
    """
    ami_levels: AMI 부호화 레벨 시퀀스.
    4개의 0을 'B00V' 또는 '000V'로 치환하여 전이와 DC 균형 확보.
    """
    out=[]
    i=0
    V=1.0
    last_pulse = -1  # 최근 ±V (부호)
    nonzero_count = 0  # 최근 치환 이후 비영 펄스 수

    while i < len(ami_levels):
        if i+4 <= len(ami_levels) and all(x==0.0 for x in ami_levels[i:i+4]):
            # 치환 결정: nonzero_count 짝/홀에 따라 선택
            if nonzero_count % 2 == 0:
                # B00V: B는 규칙적 ±V, V는 violation
                # 간단히 last_pulse 반대 부호를 B로, V는 last_pulse 동일 부호로 예시
                b_pulse = +V if last_pulse<0 else -V
                v_pulse = -b_pulse           # 위반으로 반대? (개념 예시)
                pattern = [b_pulse, 0.0, 0.0, v_pulse]
                last_pulse = +1 if v_pulse>0 else -1
                nonzero_count += 2
            else:
                # 000V
                v_pulse = +V if last_pulse<0 else -V
                pattern = [0.0, 0.0, 0.0, v_pulse]
                last_pulse = +1 if v_pulse>0 else -1
                nonzero_count += 1
            out.extend(pattern)
            i += 4
        else:
            x = ami_levels[i]
            out.append(x)
            if x != 0.0:
                last_pulse = +1 if x>0 else -1
                nonzero_count += 1
            i += 1
    return out
```
> 실제 HDB3는 **정확한 부호 배치 규칙**이 있습니다. 위 의사코드는 **개념**을 설명하기 위함입니다.

---

## — 언제 무엇을 택하나

| 기법 | 동기화(CDR) | DC 균형 | 제어 심볼 | 오버헤드 | 복잡도 | 대표 적용 |
|---|---|---|---|---|---|---|
| 4B/5B | 강 (런 제한) | 부분 | 일부(여분코드) | 25% | 낮음 | FDDI, 100BASE-TX/FX(4B/5B+NRZ-I) |
| 8b/10b | 매우 강 | 매우 우수(RD) | **강력(K-code)** | 25% | 중~높음 | 초기 고속 직렬 링크, FC, 일부 GbE PHY |
| 스크램블 | 중(통계적) | 통계적 | 없음 | 0% | 낮음 | SONET/SDH, xDSL, 여러 PHY 보조 |
| AMI+B8ZS | 강(8연속 0 차단) | 우수 | 없음 | 0% | 낮음 | T1 |
| AMI+HDB3 | **매우 강(4연속 0 차단)** | **우수(짝/홀 제약)** | 없음 | 0% | 낮음 | E1 |

> 현실에선 **복합**: 예) **4B/5B + NRZ-I + (필요시) 스크램블** / **8b/10b 단독** / **AMI + HDB3** 등.

---

## 계산 예제 — 라인 속도/대역/전이

### 4B/5B 라인 레이트

- 비트율 \(N=100\ \text{Mbps}\).
  \[
  \text{라인비트율} = \frac{5}{4}N = 125\ \text{Mb/s}
  \]
- NRZ-I로 파형화 시, 대역 근사 \(B \propto S \approx \alpha\cdot 125\ \text{MBd}\).

### 8b/10b 라인 레이트

- 비트율 \(N=2.5\ \text{Gbps}\).
  \[
  \text{라인비트율} = \frac{10}{8}N = 3.125\ \text{Gb/s}
  \]
- RD 제어로 DC~저주파 성분 억제, CDR 여유↑.

### 스크램블의 전이 확률

- 랜덤 비트 가정 시, 스크램블 후 인접 비트 불일치 확률 \(\approx 0.5\).
  → PLL 입력에 **꾸준한 에지** 제공.

---

## 미니 랩 — 파이프라인 묶어서 보기

### 4B/5B + NRZ-I 송수신

```python
def nrzi_wave(bits, V=1.0):
    level=-V; out=[]
    for b in bits:
        if b=='1': level = +V if level==-V else -V
        out.append(level)
    return out

src = "1101001110001111"         # 예시
code5 = encode_4b5b(src)         # 4B/5B 치환
wave  = nrzi_wave(code5)         # NRZ-I 파형 생성
rec5  = ''.join('1' if (wave[i]!=wave[i-1] if i>0 else wave[i]!=-1.0) else '0'
                for i in range(len(wave)))  # 개념적 NRZI 판독
dec   = decode_5b4b(rec5)        # 5B->4B 복원
assert dec == src
```
> 실제 수신부는 **샘플링/클럭복원/판정** 등 아날로그·디지털 연속 처리를 거칩니다. 위 코드는 **개념** 확인용.

### AMI + HDB3 송신 개념 흐름

1) 데이터 → **AMI 인코딩**(1에서 ± 교번, 0은 0V)
2) 시퀀스 스캔하며 `0000` → **B00V/000V** 치환
3) 전송

---

## 자주 받는 질문(FAQ)

### Q1. 4B/5B가 DC를 완전히 없애주나요?

- **아니요.** 4B/5B는 **런 제한과 전이 보장**이 핵심 목표입니다. DC는 **테이블 설계**로 어느 정도 완화되지만, **8b/10b** 같은 **RD 제어**만큼 강력하지 않습니다.

### Q2. 스크램블만 쓰면 충분한가요?

- **케이스에 따라 다릅니다.** 스크램블은 **통계적** 개선(전이/EMI 완화)에는 훌륭하지만, **제어 심볼**이나 **강한 DC 균형**이 필요하면 **블록코딩/8b10b** 등을 병행합니다.

### Q3. B8ZS와 HDB3의 차이는?

- **치환 트리거 길이**(8 vs 4)와 **부호 균형 유지 규칙**. HDB3는 매 치환에서 **짝/홀 준수**로 DC를 더 엄격히 제어.

### Q4. 8b/10b가 느린가요?

- **라인 레이트가 1.25배** 필요(오버헤드 25%). 대신 **동기/정렬/DC/제어**가 막강합니다. 고속 직렬 링크에서 오랫동안 표준처럼 쓰였고, 이후엔 **64b/66b** 등으로 오버헤드를 줄이는 방향으로 진화했습니다.

---

## 핵심 요약

- **4B/5B**: **NRZ-I**와 결합해 **전이 보장/런 제한**. 효율 80%, 100→125 Mb 라인.
- **8b/10b**: **러닝 디스패리티**로 **DC 균형**, **K-코드**로 제어/정렬, **오버헤드 25%**.
- **스크램블**: **추가 비트 없이** 전이/스펙트럼 평탄화, CDR/EMI 개선(통계적).
- **B8ZS/HDB3**: **AMI의 긴 0 런** 해결. **전이 삽입**과(특히 HDB3는 **짝/홀 규칙**으로 DC도 견고).
- **실전**: 요구사항(대역/SNR/EMI/제어/복잡도/비용/BER)에 따라 **복합 적용**이 일반적.
