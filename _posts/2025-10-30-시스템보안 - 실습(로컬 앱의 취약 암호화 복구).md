---
layout: post
title: 시스템보안 - 실습(로컬 앱의 취약 암호화 복구)
date: 2025-10-30 19:30:23 +0900
category: 시스템보안
---
# 실습: 로컬 앱의 취약 암호화 복구(교육용 샘플)

## 시나리오 개요

- **대상(교육용 앱)**: `vaultlite.exe` (또는 `vaultlite.py`) — 사용자 메모를 암호화 저장.
- **의도적 취약점**:
  1) **하드코딩 키/상수**(바이너리 안에 문자열/정수로 박힘)
  2) **ECB/CTR nonce 재사용**, **고정 salt/IV**
  3) **XOR “포장”** / Base64 혼용
  4) **약한 KDF**(단순 SHA-1 1회) / **취약 RNG**(time seeding)
- **목표**:
  - 정적/동적 관찰로 포맷/키 유추 → **평문 복구**
  - 동일 취약을 **안전 구현**으로 교체하고, 테스트로 회귀 방지

> 아래 코드는 모두 **의도적 취약**을 포함한 **로컬 교육용**입니다.

---

## 취약 앱(의도적 버그 포함)

### (A) 암호화 모듈 — _취약 버전_

```python
# vaultlite_weak.py (교육용: 절대 실전에 사용 금지)

import os, time, base64, struct, hashlib
from Crypto.Cipher import AES

HARDCODED_KEY = b"SuperSecretKey!!"      # 16바이트 고정 키 (❌ 하드코딩)
HARDCODED_SALT = b"NaClNaCl"             # 8바이트 고정 salt (❌ 고정)
MAGIC = b"VL1\0"                          # 파일 식별자
RNG_SEED = int(time.time()) & 0xFFFFFFFF  # (❌) time 기반 RNG

def weak_kdf(password: bytes) -> bytes:
    # (❌) 단순 SHA-1 1회 → 20바이트. AES-128에선 첫 16바이트 사용
    return hashlib.sha1(HARDCODED_SALT + password).digest()[:16]

def bad_rand(n: int) -> bytes:
    # (❌) 선형합동 의사난수 (예시)
    a, c, m = 1103515245, 12345, 2**31
    x = RNG_SEED
    out = bytearray()
    for _ in range(n):
        x = (a*x + c) % m
        out.append(x & 0xFF)
    return bytes(out)

def encrypt_note(password: str, note: str) -> bytes:
    key = weak_kdf(password.encode())
    iv  = bad_rand(16)                    # (❌) 예측 가능 IV
    # (❌) AES-CTR: nonce(=IV) 재사용 위험(앱 재시작 전까지 동일)
    c = AES.new(key, AES.MODE_CTR, nonce=iv[:8], initial_value=int.from_bytes(iv[8:], 'big'))
    # (❌) XOR “보안 강화”라며 1차 변환 (알맹이 무의미)
    xored = bytes([b ^ HARDCODED_KEY[i % len(HARDCODED_KEY)] for i,b in enumerate(note.encode())])
    ct = c.encrypt(xored)
    # 파일: MAGIC | IV(16) | len | ct | base64(ct) (중복 저장 – 힌트 유출)
    blob = MAGIC + iv + struct.pack(">I", len(ct)) + ct + base64.b64encode(ct)
    return blob

def decrypt_note(password: str, blob: bytes) -> str:
    assert blob[:4] == MAGIC
    iv = blob[4:20]
    L  = struct.unpack(">I", blob[20:24])[0]
    ct = blob[24:24+L]
    key = weak_kdf(password.encode())
    c = AES.new(key, AES.MODE_CTR, nonce=iv[:8], initial_value=int.from_bytes(iv[8:], 'big'))
    xored = c.decrypt(ct)
    note = bytes([b ^ HARDCODED_KEY[i % len(HARDCODED_KEY)] for i,b in enumerate(xored)]).decode(errors="replace")
    return note
```

### (B) 샘플 생성

```python
# make_sample.py

from vaultlite_weak import encrypt_note
open("secret.vl1","wb").write(encrypt_note("hunter2","payroll: alice=5000, bob=4900"))
```

---

## 리버스/분석 포인트(취약 복구 로드맵)

1) **매직**(VL1\0) → 파일 포맷 식별
2) **헤더**: [MAGIC|IV(16)|len(4)|ct|b64(ct)] → **IV와 암호문 중복** 존재
3) **CTR + 약한 KDF + 고정 salt + time RNG** → _nonce 재사용/예측 가능_
4) **HARDCODED_KEY** → 바이너리/스크립트에 존재 (문자열, 고정 길이 16)

**공격 관점(교육용)**
- 같은 IV(=nonce 조합)로 **여러 메모** 암호화 시 **keystream 공유** → `c1 ⊕ c2 = xored1 ⊕ xored2`
- `HARDCODED_KEY`를 모르면?
  - 그래도 `xored = note ⊕ HK`이므로 `c1 ⊕ c2 = (p1⊕HK) ⊕ (p2⊕HK) = p1 ⊕ p2`.
  - **한쪽 평문 추측 가능(“payroll: ” 등)**이면 다른 쪽 복구.

---

## 교육용 복구 스크립트

### (A) 포맷 파서 + CTR nonce/IV 추출

```python
# analyse_vl1.py

import struct, base64, sys
MAGIC = b"VL1\0"

def parse(blob: bytes):
    assert blob[:4] == MAGIC
    iv = blob[4:20]
    L  = struct.unpack(">I", blob[20:24])[0]
    ct = blob[24:24+L]
    b64 = base64.b64encode(ct)
    return iv, ct, b64

if __name__=="__main__":
    iv,ct,b64 = parse(open(sys.argv[1],'rb').read())
    print("IV:", iv.hex(), "CT len:", len(ct), "b64(head):", b64[:24])
```

### (B) **nonce 재사용** 케이스: 두 파일 XOR로 평문 관계 복구

```python
# xor_pair.py

import sys
a = open(sys.argv[1],'rb').read()
b = open(sys.argv[2],'rb').read()

def cut(blob):
    return blob[24:24+int.from_bytes(blob[20:24],'big')]  # CT 구간
cta = cut(a); ctb = cut(b)
m = bytes([x^y for x,y in zip(cta, ctb)])
open("xor_ct.bin","wb").write(m)
print("XOR len:", len(m))
```

- `xor_ct.bin = xoredA ⊕ xoredB = (pA⊕HK) ⊕ (pB⊕HK) = pA ⊕ pB`
- A의 일부 평문을 아는 경우(“payroll: ”), B 평문 구간 복구 가능:

```python
# known_plain.py

import sys
m = open("xor_ct.bin","rb").read()
known = b"payroll: "
offset = 0  # 맞춰가며 시도
segment = bytes([m[i+offset]^known[i] for i in range(len(known))])
print("Recovered other segment:", segment)
```

> **교훈**: CTR/GCM 등 스트림형은 **nonce(=IV)** **재사용 금지**. 재사용 시 **평문 관계**가 그대로 노출됩니다.

### (C) 하드코딩 키 탐색(정적 관찰) — 문자열/상수 추출

- 파이썬 스크립트라면 파일에서 `HARDCODED_KEY` 확인.
- 네이티브 바이너리라면 `strings`/IDA/Ghidra로 16바이트 반복 패턴, XOR 루프 인근 확인.

**짧은 Python 검출(교육용)**
```python
# find_key_guess.py

import re
data = open("vaultlite_weak.py","rb").read()
m = re.search(rb"HARDCODED_KEY\s*=\s*b\"([^\"]+)\"", data)
if m: print("HK:", m.group(1))
```

> 안전 설계에서는 **키가 바이너리에 존재하지 않도록**(OS Keychain/KMS 호출) 해야 합니다.

---

## 안전 구현으로 교체(수정 버전)

### (A) 설계 변경 요약

- **AEAD**: AES-GCM 또는 ChaCha20-Poly1305
- **Nonce**: 96비트 랜덤, **절대 재사용 금지** (파일에 함께 저장)
- **KDF**: **PBKDF2/Argon2**(salt 랜덤), 충분한 **iter/memory**
- **XOR 포장 제거**, **중복 저장 제거**, **버전 필드 추가**
- **키 보관**: OS Keychain/KMS(14.4에서 자세히)

### (B) 수정 코드 — _안전 버전_

```python
# vaultlite_safe.py

import os, struct
from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Random import get_random_bytes

MAGIC = b"VL2\0"
VER   = 1

def kdf(password: bytes, salt: bytes) -> bytes:
    # PBKDF2-HMAC-SHA256, 200k iter (환경에 맞게 조정)
    return PBKDF2(password, salt, dkLen=32, count=200_000)

def encrypt_note(password: str, note: str) -> bytes:
    salt  = get_random_bytes(16)
    key   = kdf(password.encode(), salt)
    nonce = get_random_bytes(12)
    aead  = AES.new(key, AES.MODE_GCM, nonce=nonce, mac_len=16)
    aad   = MAGIC + struct.pack(">I", VER) + salt + nonce
    aead.update(aad)
    ct, tag = aead.encrypt_and_digest(note.encode('utf-8'))
    # MAGIC | VER | salt(16) | nonce(12) | tag(16) | len | ct
    return MAGIC + struct.pack(">I", VER) + salt + nonce + tag + struct.pack(">I", len(ct)) + ct

def decrypt_note(password: str, blob: bytes) -> str:
    assert blob[:4]==MAGIC
    ver = struct.unpack(">I", blob[4:8])[0]
    assert ver==1
    salt  = blob[8:24]
    nonce = blob[24:36]
    tag   = blob[36:52]
    L     = struct.unpack(">I", blob[52:56])[0]
    ct    = blob[56:56+L]
    key   = kdf(password.encode(), salt)
    aead  = AES.new(key, AES.MODE_GCM, nonce=nonce, mac_len=16)
    aad   = blob[:36]  # MAGIC|VER|salt|nonce
    aead.update(aad)
    try:
        pt = aead.decrypt_and_verify(ct, tag)
    except ValueError:
        raise RuntimeError("decryption failed")
    return pt.decode('utf-8', errors="strict")
```

**테스트(회귀 방지)**
```python
# test_vaultlite.py

from vaultlite_safe import encrypt_note, decrypt_note
def test_roundtrip():
    blob = encrypt_note("p@ssw0rd","hello world")
    assert decrypt_note("p@ssw0rd", blob)=="hello world"
```

---

## 추가 취약 패턴 & 복구 아이디어(교육용)

- **ECB 사용** → 블록 패턴 노출. 시그니처 이미지/반복 데이터로 식별 용이
- **고정 salt + 단순 해시** → 사전 대입 가능(특히 짧은 비번)
- **Base64로만 “보안”** → **가역**이므로 숨김 효과 없음
- **오류 차이**(패딩/태그/길이 에러) → **오라클화** 가능 → 레이트리밋/동형 오류 메시지 필요(14.4 참조)

---

# 방어: HSM/KMS, OS Keychain, 레이트리밋/락아웃

## 큰 그림

- **비밀의 수명 & 위치**를 바꿉니다:
  - 애플리케이션 프로세스 **밖**(HSM/KMS/OS Keychain)에 키를 저장
  - 앱은 **토큰/권한으로 _요청할 때만_** 키를 사용
  - **AEAD + 고유 nonce** + **강한 KDF**
  - 오라클/대입 공격은 **레이트리밋/락아웃**과 **동형 오류 처리**로 차단

---

## HSM/KMS로 **엔벨로프 암호화**

> 데이터 키는 **KMS가 생성**. 앱은 **래핑된 키**와 **암호문**만 저장 → 평문 키는 메모리에 잠깐.

### (A) AWS KMS (의사 코드)

```python
# kms_envelope.py (개념 예시)

import boto3
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

kms = boto3.client('kms', region_name='ap-northeast-2')
CMK_ID = "arn:aws:kms:ap-northeast-2:123456789012:key/..."

def encrypt_with_kms(plaintext: bytes):
    # 1) 데이터키 생성 (평문/래핑 둘 다 반환)
    resp = kms.generate_data_key(KeyId=CMK_ID, KeySpec='AES_256')
    data_key_plain = resp['Plaintext']
    data_key_wrapped = resp['CiphertextBlob']

    # 2) 로컬 AEAD
    nonce = get_random_bytes(12)
    aead = AES.new(data_key_plain, AES.MODE_GCM, nonce=nonce)
    ct, tag = aead.encrypt_and_digest(plaintext)

    # 3) 평문 데이터키는 즉시 지움
    # (파이썬은 실메모리 지우기 어렵지만, 스코프 최소화/수명 짧게)
    return {
        "wrapped_key": data_key_wrapped,
        "nonce": nonce,
        "tag": tag,
        "ciphertext": ct
    }

def decrypt_with_kms(bundle):
    # 1) 데이터키 복호
    resp = kms.decrypt(CiphertextBlob=bundle["wrapped_key"])
    data_key = resp['Plaintext']
    # 2) 로컬 AEAD 복호
    aead = AES.new(data_key, AES.MODE_GCM, nonce=bundle["nonce"])
    return aead.decrypt_and_verify(bundle["ciphertext"], bundle["tag"])
```

**장점**
- 키는 **KMS 경유**로만 사용(감사·권한 제어)
- 키 회전은 **KMS 정책**으로 일원화
- 앱 저장소에는 **래핑키/nonce/tag/암호문**만 남음

---

## OS Keychain 활용

### (A) Windows DPAPI (CryptProtectData) — Python ctypes 예시

```python
# dpapi_store.py (Windows 전용)

import ctypes, ctypes.wintypes as wt, base64

class DATA_BLOB(ctypes.Structure):
    _fields_ = [("cbData", wt.DWORD), ("pbData", wt.LPBYTE)]

CryptProtectData   = ctypes.windll.crypt32.CryptProtectData
CryptUnprotectData = ctypes.windll.crypt32.CryptUnprotectData

def _blob_from_bytes(b: bytes):
    return DATA_BLOB(len(b), ctypes.cast(ctypes.create_string_buffer(b), wt.LPBYTE))

def dpapi_protect(data: bytes) -> bytes:
    inb = _blob_from_bytes(data); outb = DATA_BLOB()
    if not CryptProtectData(ctypes.byref(inb), None, None, None, None, 0, ctypes.byref(outb)):
        raise OSError("CryptProtectData failed")
    res = ctypes.string_at(outb.pbData, outb.cbData)
    ctypes.windll.kernel32.LocalFree(outb.pbData)
    return res

def dpapi_unprotect(blob: bytes) -> bytes:
    inb = _blob_from_bytes(blob); outb = DATA_BLOB()
    if not CryptUnprotectData(ctypes.byref(inb), None, None, None, None, 0, ctypes.byref(outb)):
        raise OSError("CryptUnprotectData failed")
    res = ctypes.string_at(outb.pbData, outb.cbData)
    ctypes.windll.kernel32.LocalFree(outb.pbData)
    return res

# 사용 예: 민감 설정/래핑키를 DPAPI로 보호해 로컬에 저장

wrapped = dpapi_protect(b"my sensitive material")
open("secret.bin","wb").write(wrapped)
assert dpapi_unprotect(open("secret.bin","rb").read()) == b"my sensitive material"
```

- DPAPI는 **사용자/시스템 바인딩**으로, 덤프만으로는 다른 시스템에서 복호하기 어려움.
- 앱이 직접 키를 저장하지 않고 DPAPI로 **보호해서 보관**.

### (B) macOS Keychain (CLI `security`) — 개념

```bash
# 저장

security add-generic-password -a "vaultlite" -s "com.example.vaultlite.key" -w "supersecret" -U
# 조회

security find-generic-password -a "vaultlite" -s "com.example.vaultlite.key" -w
```
- 실제 앱에서는 Swift/ObjC Keychain API 사용(공개키/개인키 저장/액세스 제어/TCC).

### (C) Linux/프리폼 — libsecret/gnome-keyring (개념)

- Python: `secretstorage` / `keyring` 라이브러리로 데스크톱 키링 연동.

> **원칙**: 앱 바이너리/설정 파일에 **평문 키 없음**. OS Keychain/HSM/KMS를 사용하고, 필요 시에만 꺼내 쓰기.

---

## 레이트리밋/락아웃(오라클·대입 차단)

### (A) 토큰 버킷(로컬 API/해킹 관문 차단) — Python Flask 예

```python
# rate_limit.py

import time
from flask import Flask, request, abort
app = Flask(__name__)

BUCKETS = {}  # { key: (tokens, last_ts) }
RATE = 5      # 초당 보충량
BURST = 10    # 최대 토큰

def allow(key):
    now = time.time()
    tokens, last = BUCKETS.get(key, (BURST, now))
    # 보충
    tokens = min(BURST, tokens + (now - last) * RATE)
    if tokens < 1:
        BUCKETS[key] = (tokens, now)
        return False
    BUCKETS[key] = (tokens - 1, now)
    return True

@app.before_request
def guard():
    key = request.remote_addr
    if not allow(key):
        abort(429)

@app.route("/decrypt", methods=["POST"])
def decrypt_oracle():
    # (방어) — 실패 사유/시간 동형 처리 + 리밋
    time.sleep(0.02)  # 미세 균질화(선택)
    # ... 실제 서비스는 AEAD 태그 실패도 같은 오류 메시지 반환
    return {"ok": False}, 400

# app.run()

```

### (B) 로그인 락아웃(지능형) — 의사 코드

- **지수 백오프** + **디바이스/지역 기반**: 실패 5회/분 → 5분 락, 이후 30분, 24h
- **CAPTCHA**/2FA **단계 상승**(리스크 시그널: 신규 디바이스/프록시 ASN/토르 네트워크)
- **동형 오류 메시지**: 사용자명/비번/패딩/태그/포맷 오류 모두 “인증 실패”

### (C) .NET (Minimal API) — Rate Limiting 미들웨어

```csharp
// Program.cs (.NET 8)
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRateLimiter(options =>
{
    options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(ctx =>
    {
        var ip = ctx.Connection.RemoteIpAddress?.ToString() ?? "unknown";
        return RateLimitPartition.GetTokenBucketLimiter(ip, _ => new TokenBucketRateLimiterOptions
        {
            TokenLimit = 20,
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
            QueueLimit = 0,
            ReplenishmentPeriod = TimeSpan.FromSeconds(1),
            TokensPerPeriod = 5,
            AutoReplenishment = true
        });
    });
});
var app = builder.Build();
app.UseRateLimiter();
app.MapPost("/decrypt", () => Results.BadRequest(new { ok=false })); // 동형 실패
app.Run();
```

---

## 오류 처리의 **동형화**(오라클 제거)

- **하나의 실패 경로**만 노출: “decryption failed”
- **시간 차** 최소화: 검증 순서 고정(EtM/AEAD: _항상_ 태그 먼저 검증)
- **로그**에는 **상세 원인**을 남기되, **클라이언트 메시지**는 동일하게

**예 (Python)**
```python
def decrypt_aead(key, nonce, ct, tag, aad=b""):
    try:
        from Crypto.Cipher import AES
        c = AES.new(key, AES.MODE_GCM, nonce=nonce)
        c.update(aad)
        pt = c.decrypt_and_verify(ct, tag)
        return pt
    except Exception:
        # 절대 이유 구분하지 않음
        raise RuntimeError("decryption failed")
```

---

## 운영 체크리스트

**키/비밀**
- [ ] 키는 **KMS/HSM/Keychain**에만 저장(바이너리/리포지토리/이미지 금지)
- [ ] **키 회전**(주기/사고 시 즉시) · **버전(kid)** 관리
- [ ] **Envelope**로 데이터 키 사용, 평문 키 **메모리 수명 최소화**

**암호**
- [ ] **AEAD** 기본, **고유 nonce** 보장(랜덤 96비트 or 안전 카운터)
- [ ] **KDF**: Argon2/PBKDF2(salt 랜덤, 충분한 cost)
- [ ] CBC/CTR 사용 시 **IV/nonce 재사용 금지**, 실패는 **동형 응답**

**앱/오라클**
- [ ] **레이트리밋**(IP/사용자/장치), **지수 백오프**, **락아웃**
- [ ] **CAPTCHA/2FA**(리스크 상승 시)
- [ ] **오류 메시지/타이밍 동형화**, 로깅은 내부 전용

**감사/비밀 검출**
- [ ] pre-commit/CI **secret scanner**(gitleaks 등)
- [ ] 크래시/로그에 비밀 포함 금지(토큰 마스킹)
- [ ] 백업/덤프 **암호화** + 접근 통제

---

## “취약 → 안전” 전환 플레이북

1) **키 위치 파악**: 코드/설정/이미지/CI 변수/런타임
2) **외부화**: KMS/HSM/Keychain로 이동, 앱은 **참조만**
3) **암호 모듈 교체**: AEAD + 안전 KDF + 고유 nonce
4) **에러·레이트리밋**: 동형 오류/속도 제한/락아웃
5) **회귀 테스트**: 안전 구현 유닛 테스트 + 비밀 검출 CI
6) **키 회전/사고 대응** 문서화 & 연습(게임데이)

---

# 결론

- 로컬 앱의 **취약 암호화**는 소스/바이너리에 남은 **하드코딩 키**, **nonce/IV 재사용**, **약한 KDF/RNG**, **오류 차이**에서 자주 발생합니다.
- 방어의 핵심은 **키를 앱 밖으로**(HSM/KMS/Keychain), **AEAD + 고유 nonce**, **강한 KDF**, **동형 오류 + 레이트리밋/락아웃**입니다.
- 위 실습 코드를 통해 취약의 “복구가 얼마나 쉬운지”를 체감하고, 체크리스트·샘플 코드를 바로 **프로젝트 하드닝**에 적용하세요.
