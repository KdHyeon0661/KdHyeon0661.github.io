---
layout: post
title: MFC - OLE 기본
date: 2025-09-06 20:25:23 +0900
category: MFC
---
# OLE 기본: 드래그&드롭, 클립보드, 임베딩/링킹 개념  
(MFC/Win32 실전 가이드 + 코드 예제 다수)

이 글은 **Windows OLE(개체 연결·삽입)**의 핵심인 **데이터 전송(Drag&Drop/Clipboard)**과 **복합 문서(임베딩/링킹)**의 개념·흐름·MFC 구현 패턴을 한 번에 정리합니다.  
모든 코드는 ```로 감싸 두었고, **MFC/Win32 C++17, Unicode, x64**를 전제합니다.

> 핵심 요약  
> - **데이터 전송**: *Data Source* ↔ *Data Object* ↔ *Drop Source/Target* ↔ *형식(Format)* ↔ *효과(DROPEFFECT)*  
> - **클립보드**: 동일한 *Data Object* 모델. 다중 포맷/지연 렌더링(Delayed Rendering) 가능  
> - **임베딩/링킹**: OLE 컨테이너/서버, **스토리지(IStorage/IStream)**, **모니커(링크)**, **In-place 활성화**  

---

## 0) 큰 그림: OLE 데이터 전송 & 복합 문서

### 0-1. 공통 개념(Drag&Drop/Clipboard)
- **Data Object**: 실제 데이터 보관/제공 (`IDataObject`, MFC: `COleDataSource`(제공), `COleDataObject`(소비))  
- **Format**: 데이터 형식(`FORMATETC`) – 예: `CF_UNICODETEXT`, `CF_HDROP`, `CF_DIB`, 커스텀 Registered 포맷  
- **Storage Medium**: 데이터 전달 컨테이너(`STGMEDIUM`) – `TYMED_HGLOBAL/IStream/GDI` 등  
- **DROPEFFECT**: 효과 표시/정책(`COPY/MOVE/LINK/NONE`) – 키 상태(CTRL/SHIFT/ALT)와 대상 정책으로 결정

### 0-2. 복합 문서(임베딩/링킹)
- **임베딩(Embedding)**: 개체 데이터가 **문서 내부**에 저장(문서가 원본을 품음)  
- **링킹(Linking)**: 문서는 **외부 개체**를 참조(원본 파일 경로/모니커를 통해 갱신)  
- **In-place 활성화**: 컨테이너 창 안에서 **서버 UI가 직접 작동**(메뉴/툴바 병합)  
- **스토리지 모델**: `IStorage/IStream`(OLE compound file) / MFC는 `COleDocument` 직렬화와 연결

---

## 1) 드래그&드롭(Drag&Drop) — 원리→MFC 클래스→예제

### 1-1. 역할과 인터페이스
- **Drag Source**: 끌기 시작한 쪽 (`IDropSource`, MFC: `COleDropSource`)  
- **Data Object**: 끌리는 데이터 (`IDataObject`, MFC: `COleDataSource`)  
- **Drop Target**: 놓이는 표면 (`IDropTarget`, MFC: `COleDropTarget`)  
- OS가 **`DoDragDrop` 루프**를 돌며 `DragEnter/Over/Leave/Drop`을 호출, `DROPEFFECT`로 피드백/정책 결정

### 1-2. 효과(DROPEFFECT)와 키 상태 매핑
- 기본 규칙(관례):  
  - **CTRL** = `COPY`  
  - **SHIFT** = `MOVE`  
  - **CTRL+SHIFT** = `LINK`  
  - 대상이 허용하지 않으면 **NONE**
- 드롭 대상은 `DROPEFFECT`를 반환하여 커서/배지로 사용자에게 피드백

#### 헬퍼(키 상태→효과)
```cpp
DWORD EffectFromKeyState(DWORD grfKeyState, DWORD allowed) {
    bool ctrl  = (grfKeyState & MK_CONTROL) != 0;
    bool shift = (grfKeyState & MK_SHIFT)   != 0;
    if (ctrl && shift)   return (allowed & DROPEFFECT_LINK) ? DROPEFFECT_LINK : DROPEFFECT_NONE;
    if (ctrl)            return (allowed & DROPEFFECT_COPY) ? DROPEFFECT_COPY : DROPEFFECT_NONE;
    if (shift)           return (allowed & DROPEFFECT_MOVE) ? DROPEFFECT_MOVE : DROPEFFECT_NONE;
    // 기본 정책: MOVE 우선, 아니면 COPY, 아니면 LINK
    if (allowed & DROPEFFECT_MOVE) return DROPEFFECT_MOVE;
    if (allowed & DROPEFFECT_COPY) return DROPEFFECT_COPY;
    if (allowed & DROPEFFECT_LINK) return DROPEFFECT_LINK;
    return DROPEFFECT_NONE;
}
```

---

### 1-3. **Drop Target** 구현 (수신자)

#### ① 대상 뷰/창에 `COleDropTarget` 등록
```cpp
class CMyView : public CView {
    COleDropTarget m_dropTarget;
    BOOL m_bAllowFiles = TRUE;
public:
    BOOL PreCreateWindow(CREATESTRUCT& cs) override { return CView::PreCreateWindow(cs); }
    int OnCreate(LPCREATESTRUCT cs) {
        if (CView::OnCreate(cs) == -1) return -1;
        m_dropTarget.Register(this); // ★ Enables OLE drop
        return 0;
    }
    DECLARE_MESSAGE_MAP()
};
BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_WM_CREATE()
END_MESSAGE_MAP()
```

#### ② OLE 오버라이드(드롭 허용/효과 결정/데이터 추출)
MFC에서는 `COleDropTarget`을 상속해 별도 클래스로 더 엄밀하게 구현할 수도 있지만, **간단히** `CView`에 **`OnDrop`/`OnDragEnter`/`OnDragOver`**를 구현해도 됩니다(메서드 시그니처는 `COleDropTarget`의 콜백을 프록시하여 호출).

```cpp
DROPEFFECT CMyView::OnDragEnter(COleDataObject* pDataObj, DWORD grfKeyState, CPoint pt) {
    DWORD allowed = DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK;
    if (pDataObj->IsDataAvailable(CF_UNICODETEXT) || pDataObj->IsDataAvailable(CF_HDROP))
        return EffectFromKeyState(grfKeyState, allowed);
    return DROPEFFECT_NONE;
}

DROPEFFECT CMyView::OnDragOver(COleDataObject* pDataObj, DWORD grfKeyState, CPoint pt) {
    return OnDragEnter(pDataObj, grfKeyState, pt); // 동일 정책
}

BOOL CMyView::OnDrop(COleDataObject* pDataObj, DROPEFFECT dropEffect, CPoint pt) {
    if (pDataObj->IsDataAvailable(CF_HDROP)) {
        HGLOBAL h = pDataObj->GetGlobalData(CF_HDROP);
        if (h) {
            HDROP drop = (HDROP)GlobalLock(h);
            if (drop) {
                UINT n = DragQueryFile(drop, 0xFFFFFFFF, nullptr, 0);
                for (UINT i=0;i<n;++i) {
                    CString path;
                    UINT cch = DragQueryFile(drop, i, nullptr, 0) + 1;
                    DragQueryFile(drop, i, path.GetBufferSetLength(cch), cch);
                    path.ReleaseBuffer();
                    // 파일 열기/불러오기
                    OpenOrImport(path, dropEffect == DROPEFFECT_MOVE /*move hint*/);
                }
                GlobalUnlock(h);
            }
        }
        return TRUE;
    }
    if (pDataObj->IsDataAvailable(CF_UNICODETEXT)) {
        HGLOBAL h = pDataObj->GetGlobalData(CF_UNICODETEXT);
        if (h) {
            LPCWSTR s = (LPCWSTR)GlobalLock(h);
            if (s) {
                HandleTextInsert(s);
                GlobalUnlock(h);
            }
        }
        return TRUE;
    }
    return FALSE;
}
```

> 팁  
> - 드롭 시 **여러 포맷**(텍스트/파일/이미지)을 순서대로 검사해 **최적 포맷**을 선택  
> - `DROPEFFECT_MOVE`이면 **원본 쪽 삭제**를 **소스가** 수행(대상은 힌트만 사용)

---

### 1-4. **Drag Source** 구현 (제공자)

#### ① 데이터 구성: `COleDataSource`
```cpp
void CMyView::BeginDragSelectedText(const CString& text) {
    class MyDataSource : public COleDataSource {
    public:
        CString m_text;
        MyDataSource(const CString& s) : m_text(s) {}
        BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal) override {
            if (lpFormatEtc->cfFormat == CF_UNICODETEXT) {
                size_t bytes = (m_text.GetLength()+1) * sizeof(wchar_t);
                HGLOBAL h = GlobalAlloc(GMEM_MOVEABLE, bytes);
                if (!h) return FALSE;
                void* p = GlobalLock(h);
                memcpy(p, (LPCWSTR)m_text, bytes);
                GlobalUnlock(h);
                *phGlobal = h;
                return TRUE;
            }
            return COleDataSource::OnRenderGlobalData(lpFormatEtc, phGlobal);
        }
    };

    auto pSrc = std::make_unique<MyDataSource>(text);
    // 지연 렌더링 등록: 드래그가 진짜 데이터 요청할 때 OnRenderGlobalData가 호출됨
    FORMATETC fmt = { (CLIPFORMAT)CF_UNICODETEXT, nullptr, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    pSrc->DelayRenderData(CF_UNICODETEXT, &fmt);

    COleDropSource dropSource; // QueryContinueDrag/GiveFeedback 기본 구현
    DWORD allowed = DROPEFFECT_COPY | DROPEFFECT_MOVE;
    DROPEFFECT eff = pSrc->DoDragDrop(allowed, &dropSource);
    if (eff == DROPEFFECT_MOVE) {
        // 원본에서 삭제
        DeleteSelectedText();
    }
}
```

#### ② 다중 포맷 제공 (텍스트 + 파일 목록 + 커스텀 포맷)
```cpp
COleDataSource src;
// 즉시 렌더링(간단)
HGLOBAL hTxt = ::GlobalAlloc(GMEM_MOVEABLE, (textLen+1)*sizeof(wchar_t));
/* ...복사... */
src.CacheGlobalData(CF_UNICODETEXT, hTxt);

// 파일 드롭(파일 경로 N개 → CF_HDROP)
HGLOBAL hDrop = CreateHDropFromPaths(paths);
src.CacheGlobalData(CF_HDROP, hDrop);

// 커스텀 포맷(Registered)
UINT CF_MYTYPE = ::RegisterClipboardFormat(L"MyApp.CustomItem");
HGLOBAL hCustom = CreateCustomBlob(binary);
src.CacheGlobalData(CF_MYTYPE, hCustom);

COleDropSource ds;
src.DoDragDrop(DROPEFFECT_COPY|DROPEFFECT_MOVE, &ds);
```

---

### 1-5. “가상 파일” 드래그(다운로더·클라우드 앱에서 흔함)

**개념**: 실제 파일이 아직 디스크에 없을 때, **탐색기**로 “파일처럼” 드래그.  
**포맷**:  
- **`CFSTR_FILEDESCRIPTORW`**: 파일 메타(이름/사이즈/타임스탬프 …) 배열  
- **`CFSTR_FILECONTENTS`**: 각 파일 내용을 **요청 시 스트림으로 공급**  
- (옵션) `CFSTR_PERFORMEDDROPEFFECT`/`CFSTR_PASTESUCCEEDED` 피드백

```cpp
// 1) FILEDESCRIPTOR 배열 구성
std::vector<FILEDESCRIPTORW> desc = BuildDescriptors(items);
HGLOBAL hDesc = GlobalAlloc(GMEM_MOVEABLE, sizeof(FILEGROUPDESCRIPTORW) + sizeof(FILEDESCRIPTORW)*(desc.size()-1));
auto pGroup = (FILEGROUPDESCRIPTORW*)GlobalLock(hDesc);
pGroup->cItems = (UINT)desc.size();
for (size_t i=0;i<desc.size();++i) pGroup->fgd[i] = desc[i];
GlobalUnlock(hDesc);

// 2) FILECONTENTS: 각각 IStream 제공 (CreateStreamOnHGlobal or custom IStream)
class VirtualFileDataObject : public COleDataSource {
public:
    std::vector<CComPtr<IStream>> streams; // 각 파일 스트림
    BOOL OnRenderData(LPFORMATETC fetc, LPSTGMEDIUM stg) override {
        if (fetc->cfFormat == RegisterClipboardFormat(CFSTR_FILECONTENTS)) {
            int idx = (int)fetc->lindex; // 요청된 파일 인덱스
            stg->tymed = TYMED_ISTREAM;
            stg->pstmr = streams[idx].Detach(); // AddRef 핸드오프
            stg->pUnkForRelease = nullptr;
            return TRUE;
        }
        return COleDataSource::OnRenderData(fetc, stg);
    }
};

// 3) 등록
VirtualFileDataObject src;
src.CacheGlobalData(RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW), hDesc);
// FILECONTENTS는 DelayRenderData로 다중 인덱스 지원
FORMATETC fetc{}; fetc.cfFormat = RegisterClipboardFormat(CFSTR_FILECONTENTS);
fetc.tymed = TYMED_ISTREAM; fetc.dwAspect = DVASPECT_CONTENT;
fetc.lindex = -1; // 여러 개를 지원하는 의미
src.DelayRenderData(fetc.cfFormat, &fetc);

COleDropSource ds;
src.DoDragDrop(DROPEFFECT_COPY, &ds);
```

> 탐색기가 요청하는 순서대로 `OnRenderData`가 호출되어 **스트림**을 넘겨주면, 탐색기가 실제 파일로 **복사**합니다.

---

## 2) 클립보드(Clipboard) — Cut/Copy/Paste 패턴

### 2-1. 복사(Copy): `COleDataSource::SetClipboard`
```cpp
void CMyView::CopySelectionToClipboard() {
    CString sel = GetSelectedText();
    COleDataSource src;

    size_t bytes = (sel.GetLength()+1)*sizeof(wchar_t);
    HGLOBAL h = GlobalAlloc(GMEM_MOVEABLE, bytes);
    void* p = GlobalLock(h); memcpy(p, sel.GetString(), bytes); GlobalUnlock(h);

    src.CacheGlobalData(CF_UNICODETEXT, h);

    // 커스텀 포맷 병행(예: 내부 객체)
    UINT CF_MY = RegisterClipboardFormat(L"MyApp.CustomItem");
    HGLOBAL hCustom = SerializeSelectionToHGlobal();
    src.CacheGlobalData(CF_MY, hCustom);

    src.SetClipboard(); // 이제 시스템 클립보드에 소유권 이전
}
```

### 2-2. 붙여넣기(Paste): `COleDataObject::AttachClipboard`
```cpp
void CMyView::OnEditPaste() {
    COleDataObject obj;
    if (!obj.AttachClipboard()) return;

    if (obj.IsDataAvailable(CF_UNICODETEXT)) {
        HGLOBAL h = obj.GetGlobalData(CF_UNICODETEXT);
        if (h) {
            LPCWSTR s = (LPCWSTR)GlobalLock(h);
            InsertTextAtCaret(s);
            GlobalUnlock(h);
        }
        return;
    }
    UINT CF_MY = RegisterClipboardFormat(L"MyApp.CustomItem");
    if (obj.IsDataAvailable(CF_MY)) {
        HGLOBAL h = obj.GetGlobalData(CF_MY);
        if (h) { ImportCustom(h); }
        return;
    }
    AfxMessageBox(L"붙여넣기 가능한 형식이 없습니다.");
}
```

### 2-3. 잘라내기(Cut) = Copy + Delete
- **클립보드 성공 후에만** 원본 삭제(실패 시 데이터 보존)

---

## 3) 데이터 형식(Formats) — 무엇을 언제 쓰나

| 분류 | 형식 | 용도/비고 |
|---|---|---|
| 텍스트 | `CF_UNICODETEXT` (권장), `CF_TEXT` | 유니코드 기본. 줄바꿈 `\r\n` |
| 파일 | `CF_HDROP` | 파일 경로들(탐색기/에디터) |
| 비트맵 | `CF_DIB`/`CF_DIBV5`/`CF_BITMAP` | 장치 독립 비트맵 권장 |
| 벡터 | `CF_ENHMETAFILE` | 도면/차트 등 |
| OLE | `CF_EMBEDDEDOBJECT`, `CF_LINKSOURCE` | 임베딩/링킹용 |
| 커스텀 | `RegisterClipboardFormat(L"Name")` | 앱 내부 교환 |

> 실무: **다중 포맷**을 함께 제공하면 상호 운용성이 올라갑니다(예: **텍스트 + HTML** 둘 다 제공).

---

## 4) 임베딩(Embedding) & 링킹(Linking) — 복합 문서

MFC는 **컨테이너/서버** 양쪽을 쉽게 만들 수 있도록 클래스 세트를 제공합니다.

### 4-1. 컨테이너 측(MFC)
- **문서**: `COleDocument` (또는 `CRichEditDoc`)  
- **뷰**: `COleIPFrameWnd`/`COleResizeBar`로 In-place UI 지원  
- **개체 래퍼**: `COleClientItem` – 컨테이너 문서 안에 삽입된 OLE 개체를 나타냄

#### (A) 개체 삽입(Insert Object 대화상자)
```cpp
void CMyView::OnInsertObject() {
    COleInsertDialog dlg;
    if (dlg.DoModal() != IDOK) return;

    CMyDoc* pDoc = GetDocument();
    auto pItem = new CMyClientItem(pDoc); // COleClientItem 파생
    if (dlg.GetSelectionType() == COleInsertDialog::createNewItem) {
        // 새 OLE 개체 생성(예: Excel.Sheet)
        if (!pItem->CreateNewItem(dlg.GetClassID())) { delete pItem; return; }
    } else {
        // 파일로부터 만들기(링크 or 임베딩)
        if (!pItem->CreateFromFile(dlg.GetPathName(), dlg.GetDisplayAsIcon())) { delete pItem; return; }
        if (dlg.GetLink()) pItem->SetLink(TRUE);
    }
    pItem->DoVerb(OLEIVERB_SHOW, this); // In-place 활성 또는 UI 표시
    pDoc->UpdateAllViews(nullptr);
    pDoc->SetModifiedFlag(TRUE);
}
```

#### (B) 붙여넣기 특수(Paste Special)
```cpp
void CMyView::OnEditPasteSpecial() {
    COlePasteSpecialDialog dlg;
    if (dlg.DoModal() != IDOK) return;

    CMyDoc* pDoc = GetDocument();
    auto pItem = new CMyClientItem(pDoc);
    if (!pItem->CreateFromData(dlg.m_ps.hMetaPict ? dlg.m_ps.lpSrcDataObj : nullptr)) { delete pItem; return; }
    if (dlg.m_ps.dwAspect == DVASPECT_ICON) pItem->SetIconic(TRUE);
    pItem->DoVerb(OLEIVERB_SHOW, this);
    pDoc->UpdateAllViews(nullptr);
}
```

### 4-2. 서버 측(MFC)
- **문서**: `COleServerDoc` or `COleLinkingDoc`  
- **항목**: `COleServerItem` – 외부 컨테이너가 삽입/링크하는 **서버 아이템**을 정의  
- **등록**: `COleTemplateServer`로 COM/OLE 클래스 등록(ProgID/CLSID)

#### (A) 서버 문서 직렬화/표시
```cpp
class CDrawServerDoc : public COleServerDoc {
public:
    CObArray m_shapes;
    void Serialize(CArchive& ar) override {
        if (ar.IsStoring()) {
            ar << (INT)m_shapes.GetSize();
            // ...저장...
        } else {
            INT n; ar >> n;
            // ...로드...
        }
    }
};

class CDrawServerItem : public COleServerItem {
public:
    CDrawServerItem(CDrawServerDoc* pDoc) : COleServerItem(pDoc, TRUE) {}
    BOOL OnDraw(CDC* pDC, CSize& rSize) override {
        // 서버 아이템을 EMF 등으로 그려 컨테이너에 전달
        pDC->Rectangle(0,0, rSize.cx, rSize.cy);
        return TRUE;
    }
};
```

#### (B) 서버 등록(애플리케이션 초기화)
```cpp
BOOL CMyApp::InitInstance() {
    AfxOleInit(); // ★ OLE 초기화
    CSingleDocTemplate* pDocTemplate =
        new CSingleDocTemplate(IDR_MAINFRAME,
            RUNTIME_CLASS(CDrawServerDoc),
            RUNTIME_CLASS(CMainFrame),
            RUNTIME_CLASS(CDrawView));
    AddDocTemplate(pDocTemplate);

    // 서버 클래스 등록
    COleTemplateServer::RegisterAll(); // 또는 AfxOleRegisterServerClass(...)
    // ...
    return TRUE;
}
```

> 서버 앱은 컨테이너에서 “Insert Object → From File/From List”로 호출되며, **In-place** 활성 시 메뉴/툴바 병합이 일어납니다.

### 4-3. 임베딩 vs 링킹 운영상 차이
| 항목 | 임베딩 | 링킹 |
|---|---|---|
| 저장 위치 | 컨테이너 문서 내부 | 외부 원본 파일 |
| 용량 | 컨테이너가 커짐 | 가벼움 |
| 갱신 | 문서 자체 보관 | **원본 변경 시 갱신** 필요(자동/수동) |
| 이식성 | 문서만 복사하면 됨 | 원본 파일 동반 필요 |
| 보안 | 개체 코드 실행 위험(매크로 등) | 유사 |

> 보안 측면: **신뢰되지 않은 OLE 개체의 자동 실행 금지**. Previews/자동 실헹은 사용자 동의 필요.

---

## 5) In-place Activation(서버 UI 병합) 핵심

- 컨테이너는 `COleIPFrameWnd`/`COleResizeBar`를 사용, 서버 활성화 시 **메뉴/툴바 병합**  
- 서버는 `IOleInPlaceActiveObject` 구현(프레임워크 제공), 키보드 포커스/명령 라우팅 연결  
- **상태 전환**: *deactivated ↔ UIActive ↔ InPlaceActive*  
- 컨테이너/서버 모두 **명령 라우팅**과 **Update UI**가 자연스럽게 이루어지도록 MFC가 대부분 처리

---

## 6) 고급: 자동 스크롤/드래그 이미지/스프링 로딩

### 6-1. 자동 스크롤(긴 캔버스에서 드래그 중 가장자리 접근)
- `OnDragOver`에서 포인터가 뷰 외곽 근처면 `SetTimer`로 **자동 스크롤** 트리거  
- `OnDragLeave/OnDrop`에서 타이머 해제

```cpp
DROPEFFECT CMyView::OnDragOver(COleDataObject* obj, DWORD ks, CPoint pt) {
    CRect rc; GetClientRect(&rc);
    int margin = 24;
    if (pt.y < rc.top + margin)  StartAutoScroll(-1);
    else if (pt.y > rc.bottom - margin) StartAutoScroll(+1);
    else StopAutoScroll();
    return DROPEFFECT_COPY;
}
```

### 6-2. 드래그 이미지(반투명 미리보기)
- Shell `IDragSourceHelper` 사용(필요 시) → 레거시 앱에서도 **시각적 품질** 향상

### 6-3. 스프링 로딩(트리/폴더 자동 펼침)
- `OnDragOver`에서 일정 시간 같은 노드에 머무르면 **펼치기**(타이머 기반)

---

## 7) 보안/호환/안전

- **임베딩 개체**가 **코드/매크로**를 포함할 수 있음 → 미리보기/자동 실행 금지, “신뢰” UI  
- **64비트/유니코드**: `CF_UNICODETEXT` 기본, 포인터/핸들 크기 주의  
- **리소스 해제**: HGLOBAL/펜/브러시/EMF/스트림 Release 책임 명확화  
- **대용량 데이터**: `TYMED_ISTREAM` 선호(스트리밍) / `HGLOBAL`은 너무 크면 부담  
- **지연 렌더링**: 실제로 필요한 포맷만 **요청 시 생성** → 성능/메모리 절약

---

## 8) 디버깅/문제 해결

- **클립보드 뷰어**(clipspy 등)로 포맷 확인  
- **Drag/Drop 검사**: `IsDataAvailable` 목록을 로그로 출력  
- **레지스트리 등록 문제**: `AfxOleRegisterServerClass`, ProgID/CLSID 충돌 확인  
- **In-place 병합 문제**: 프레임/메뉴 리소스 ID 중복/라우팅 경로 점검  
- **COM 초기화**: `AfxOleInit()` / 스레드 아파트 모델(Single-Threaded vs MTA) 호환성

---

## 9) 미니 예제 모음(복붙용)

### 9-1. 파일 경로들에서 `CF_HDROP` 만들기
```cpp
HGLOBAL CreateHDropFromPaths(const std::vector<CString>& paths) {
    SIZE_T bytes = sizeof(DROPFILES);
    for (auto& s : paths) bytes += (s.GetLength()+1) * sizeof(wchar_t);
    bytes += sizeof(wchar_t); // double-NUL

    HGLOBAL h = GlobalAlloc(GMEM_MOVEABLE, bytes);
    if (!h) return nullptr;

    BYTE* p = (BYTE*)GlobalLock(h);
    auto df = (DROPFILES*)p; ZeroMemory(df, sizeof(*df));
    df->pFiles = sizeof(DROPFILES);
    df->fWide = TRUE;

    wchar_t* buf = (wchar_t*)(p + sizeof(DROPFILES));
    for (auto& s : paths) { wcscpy(buf, s); buf += s.GetLength()+1; }
    *buf = L'\0';
    GlobalUnlock(h);
    return h;
}
```

### 9-2. 커스텀 구조체를 `HGLOBAL`로 직렬화
```cpp
#pragma pack(push,1)
struct MyBlob { int id; double value; wchar_t name[64]; };
#pragma pack(pop)

HGLOBAL SerializeBlob(const MyBlob& b) {
    HGLOBAL h = GlobalAlloc(GMEM_MOVEABLE, sizeof(b));
    void* p = GlobalLock(h); memcpy(p, &b, sizeof(b)); GlobalUnlock(h);
    return h;
}
```

### 9-3. `COleClientItem` 파생 – 삽입 후 바로 보여주기
```cpp
class CMyClientItem : public COleClientItem {
public:
    CMyClientItem(COleDocument* pDoc) : COleClientItem(pDoc) {}
    void InsertNewExcelSheet() {
        if (CreateNewItem(CLSIDFromString(L"Excel.Sheet"))) {
            DoVerb(OLEIVERB_SHOW); // In-place 활성
        }
    }
};
```

---

## 10) 체크리스트(요약)

**Drag & Drop**
- [ ] `COleDropTarget::Register` 호출  
- [ ] `IsDataAvailable`로 **다중 포맷** 지원  
- [ ] `DROPEFFECT` 정책 + 키 상태 매핑  
- [ ] 가상 파일: `FILEDESCRIPTOR/FILECONTENTS` 스트림 제공

**Clipboard**
- [ ] `COleDataSource::SetClipboard`로 다중 포맷 제공  
- [ ] 붙여넣기: `COleDataObject::AttachClipboard` + 우선순위 포맷 선택  
- [ ] Cut은 Copy 성공 후 삭제

**Embedding/Linking**
- [ ] `AfxOleInit`  
- [ ] 컨테이너: `COleDocument` + `COleClientItem` + 삽입/붙여넣기 특수  
- [ ] 서버: `COleServerDoc/Item` + OnDraw/Serialize + 등록  
- [ ] In-place 활성: 메뉴/툴바 병합 점검

**품질/보안**
- [ ] 유니코드/스트리밍(TYMED_ISTREAM) 선호  
- [ ] 대량 데이터는 **지연 렌더링**  
- [ ] 미신뢰 개체 자동 실행 금지

---

### 마무리

OLE는 **데이터 전송 모델**(Drag&Drop/Clipboard)과 **복합 문서 모델**(임베딩/링킹)로 구성된 거대한 생태계지만,  
MFC의 `COleDataSource/COleDataObject/COleDropSource/COleDropTarget`, 그리고 `COleDocument/COleClientItem/COleServerItem`을 알면 **실전 구현**이 크게 단순해집니다.
