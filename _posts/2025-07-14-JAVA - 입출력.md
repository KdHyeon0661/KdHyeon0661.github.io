---
layout: post
title: Java - 입출력
date: 2025-07-14 17:20:23 +0900
category: Java
---
# Java의 입출력 (Scanner, BufferedReader)

## 개요: 언제 무엇을 쓰나

| 상황/요구 | 추천 조합 | 이유 |
|---|---|---|
| 학습/간단 콘솔 입력 | `Scanner` | API 직관적, 타입별 파서 제공 |
| 알고리즘 문제/대용량(수십만~수백만 토큰) | `BufferedReader` + `StringTokenizer` | 파싱 오버헤드↓, 스루풋↑ |
| 극한 속도(초당 수천만 토큰) | 커스텀 FastScanner(바이트 파서) | 정규식/박싱 제거, 분기 최소화 |
| 파일 줄 처리/UTF-8 확정 | `BufferedReader(new InputStreamReader(FIS, UTF_8))` | 인코딩 명시, 줄 단위 가공 |
| 스트림 파이프라인 | `Files.lines(Path, UTF_8)` | 람다/스트림과 자연스러운 결합 |
| 출력도 빠르게 | `BufferedWriter` or `PrintWriter` | 출력 버퍼링으로 왕복 비용↓ |

> **원칙**: 입력이 많아질수록 “**정규식/박싱/메서드 호출 수**”를 줄이는 방향이 유리합니다.

---

## `Scanner` — 쉽고 직관적인 토큰 기반 입력

### 특징

- `java.util.Scanner` (Java 5+), **토큰 단위** 파싱.
- 기본 **구분자(delimiter)는 공백류 정규식 `\p{javaWhitespace}+`**.
- `int/double/boolean/BigInteger/BigDecimal` 등 **타입별 파서 제공**.
- 내부적으로 버퍼링하지만, **정규식·로케일 처리 비용**으로 인해 `BufferedReader`보다 **일반적으로 느림**.

### 기본 예제

```java
import java.util.*;

public class ScannerExample {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            System.out.print("이름을 입력하세요: ");
            String name = sc.nextLine();

            System.out.print("나이를 입력하세요: ");
            int age = sc.nextInt();

            System.out.println("이름: " + name);
            System.out.println("나이: " + age);
        }
    }
}
```

### 주요 메서드 표

| 메서드 | 의미 |
|---|---|
| `next()` | 구분자 전까지 문자열 |
| `nextLine()` | 줄 전체 입력(개행 제외) |
| `nextInt()`, `nextDouble()` | 해당 타입으로 파싱(로케일 영향) |
| `hasNext()`, `hasNextInt()` | 다음 토큰 존재/형식 확인 |
| `useDelimiter(Pattern/String)` | 구분자 변경 |
| `useLocale(Locale)` | 소수점 기호 등 로케일 설정 |
| `close()` | 내부 스트림 종료(주의: `System.in`도 닫힘) |

### 흔한 함정: `nextInt()` 뒤 `nextLine()`

```java
try (Scanner sc = new Scanner(System.in)) {
    int n = sc.nextInt(); // 숫자 읽고 개행은 남아있음
    sc.nextLine();        // 남은 개행 소비
    String s = sc.nextLine(); // 이제 정상
}
```

### 구분자/로케일/유효성

```java
Scanner sc = new Scanner(System.in)
    .useDelimiter("\\s*,\\s*") // 쉼표(,) 구분
    .useLocale(Locale.US);     // 소수점 . 사용

while (sc.hasNextDouble()) {
    double v = sc.nextDouble();
    // ...
}
```

### EOF까지 읽기

```java
try (Scanner sc = new Scanner(System.in)) {
    while (sc.hasNext()) {
        System.out.println(sc.next());
    }
}
```

---

## `BufferedReader` — 빠른 줄 입력 & 직접 파싱

### 특징

- `java.io.BufferedReader`, **문자 스트림**.
- **`readLine()`** 로 줄 단위 수신 → **직접 파싱 필요**.
- `IOException` 처리 필요, **속도 매우 빠름**(정규식/로케일 비용 없음).

### 기본 예제

```java
import java.io.*;

public class BufferedReaderExample {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        System.out.print("이름을 입력하세요: ");
        String name = br.readLine();

        System.out.print("나이를 입력하세요: ");
        int age = Integer.parseInt(br.readLine());

        System.out.println("이름: " + name);
        System.out.println("나이: " + age);
    }
}
```

### 문자열 파싱 3종 패턴

```java
// 1) StringTokenizer: 공백/구분자 다수 처리에 빠름
StringTokenizer st = new StringTokenizer(br.readLine());
int a = Integer.parseInt(st.nextToken());
int b = Integer.parseInt(st.nextToken());

// 2) split(regex): 편리하지만 정규식 비용↑, 대용량엔 비권장
String[] toks = br.readLine().trim().split("\\s+");

// 3) 수동 파싱: 인덱스/문자 검사로 직접 잘라내기(가장 빠름)
String s = br.readLine();
int i = 0, n = s.length();
int sign = 1, val = 0;
if (s.charAt(i) == '-') { sign = -1; i++; }
while (i < n && Character.isDigit(s.charAt(i))) { val = val*10 + (s.charAt(i)-'0'); i++; }
val *= sign;
```

### 여러 숫자 한 줄에서

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
int a = Integer.parseInt(st.nextToken());
int b = Integer.parseInt(st.nextToken());
System.out.println("합: " + (a + b));
```

---

## 속도와 메모리 — 요령/패턴

| 조합 | 상대 속도(체감) | 특징 |
|---|---|---|
| `Scanner` | 느림 | 정규식/로케일/오토박싱 비용 |
| `BufferedReader` + `StringTokenizer` | 빠름 | 실전 표준(BOJ 등) |
| **커스텀 FastScanner**(바이트 파서) | 매우 빠름 | 정규식/박싱 제거, 분기 최소화 |
| NIO `ByteBuffer` + `CharsetDecoder` | 빠름~매우 빠름 | 고급, 구현 복잡도↑ |

> **대략 가이드**: 단순 토큰 파싱에서 **`BufferedReader + StringTokenizer`는 `Scanner` 대비 2~10배** 빠른 경우가 흔합니다(환경·입력 분포에 따라 상이).

### 합계 예제: N개 정수 합

```java
// Scanner (직관)
long sum = 0;
try (java.util.Scanner sc = new java.util.Scanner(System.in)) {
    int n = sc.nextInt();
    for (int i = 0; i < n; i++) sum += sc.nextLong();
}
System.out.println(sum);
```

```java
// BufferedReader + StringTokenizer (표준)
import java.io.*;
import java.util.*;
class SumFast {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    long sum = 0;
    StringTokenizer st;
    while (n > 0) {
      st = new StringTokenizer(br.readLine());
      while (st.hasMoreTokens() && n > 0) {
        sum += Long.parseLong(st.nextToken());
        n--;
      }
    }
    System.out.println(sum);
  }
}
```

> 시간 복잡도는 **$$O(N)$$**(토큰 수 N). 상수 계수는 파서 선택에 크게 좌우됩니다.

---

## 인코딩·개행·BOM

### 인코딩 지정

- OS/터미널 기본 인코딩과 다를 수 있음 → **명시**가 안전.
```java
BufferedReader br = new BufferedReader(
    new InputStreamReader(System.in, java.nio.charset.StandardCharsets.UTF_8));
```

### 처리

- `readLine()`은 `\r\n`, `\n` 모두 인식(개행은 결과에 포함되지 않음).
- `Scanner.nextLine()`도 유사하지만, **이전 숫자 입력의 잔여 개행**에 주의.

### UTF-8 BOM

- 파일 첫 문자에 `\uFEFF`(BOM)가 남을 수 있음 → 첫 줄 처리 시 제거:
```java
String line = br.readLine();
if (line != null && !line.isEmpty() && line.charAt(0) == '\uFEFF')
    line = line.substring(1);
```

---

## NIO/채널/바이트버퍼(고급)

### ByteBuffer + CharsetDecoder

```java
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;

public class NioRead {
    public static void main(String[] args) throws Exception {
        ReadableByteChannel ch = Channels.newChannel(System.in);
        ByteBuffer buf = ByteBuffer.allocateDirect(1 << 16);
        CharsetDecoder dec = StandardCharsets.UTF_8.newDecoder();
        StringBuilder sb = new StringBuilder();

        while (ch.read(buf) != -1) {
            buf.flip();
            CharBuffer cb = CharBuffer.allocate(buf.remaining());
            dec.decode(buf, cb, false);
            cb.flip();
            sb.append(cb);
            buf.compact();
        }
        // sb에 누적된 전체 텍스트
        System.out.println(sb.length());
    }
}
```
- 직접 파서 구현 시 **최고 성능** 가능하나, **복잡도** 상승.

### 파일 라인 스트림

```java
try (var lines = java.nio.file.Files.lines(
        java.nio.file.Path.of("input.txt"), java.nio.charset.StandardCharsets.UTF_8)) {
    long count = lines.filter(s -> !s.isBlank()).count();
    System.out.println(count);
}
```

---

## 출력 짝궁: `BufferedWriter` / `PrintWriter`

### 빠른 출력

```java
import java.io.*;
public class FastOut {
    public static void main(String[] args) throws Exception {
        var out = new BufferedWriter(new OutputStreamWriter(System.out));
        out.write("Hello\n");
        out.write(Integer.toString(123));
        out.newLine();
        out.flush(); // 최종 flush 잊지 말 것
    }
}
```

### 포맷팅이 필요하면 `PrintWriter`

```java
try (PrintWriter pw = new PrintWriter(new BufferedWriter(
        new OutputStreamWriter(System.out, java.nio.charset.StandardCharsets.UTF_8)))) {
    pw.printf("x=%d y=%.2f%n", 7, 3.14159);
}
```

---

## 안전 수칙 & 함정 모음

| 주제 | 실수/증상 | 해결 |
|---|---|---|
| `Scanner` 숫자 뒤 `nextLine()` | 빈 문자열 | 숫자 후 `nextLine()`로 개행 소비 |
| `Scanner` 속도 | 대용량에서 느림 | `BufferedReader + StringTokenizer` 또는 커스텀 파서 |
| 인코딩 | 한글 깨짐 | `InputStreamReader(..., UTF_8)` 명시 |
| `System.console()` | IDE에서 `null` | 콘솔 실행 or `Scanner/BufferedReader` 사용 |
| 여러 래퍼로 `System.in` 감싸기 | 이중 닫힘/데드락 가능 | **하나의 체인만** 구성, 마지막에만 닫기 |
| `split()` 남발 | 정규식 비용↑, GC↑ | `StringTokenizer` 또는 수동 파싱 |
| 혼합 입출력 버퍼링 | 출력 지연 | `flush()` 호출 습관화 |
| EOF 루프 | 무한 대기 | `readLine()`이 `null`(EOF)인지 체크 |
| 예외 | `NumberFormatException` | **트림/검증** 후 파싱, `try-catch` |

---

## 실전 예제 모음

### 폼 입력: `Scanner` 기본

```java
import java.util.*;
public class Form {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            System.out.print("이름: ");
            String name = sc.nextLine();
            System.out.print("나이: ");
            int age = sc.nextInt(); sc.nextLine();
            System.out.print("취미(쉼표 구분): ");
            sc.useDelimiter("\\s*,\\s*|\n");
            String h1 = sc.next();
            String h2 = sc.next();
            System.out.println(name + "/" + age + " - " + h1 + "," + h2);
        }
    }
}
```

### 빠른 합계: `BufferedReader` + `StringTokenizer`

```java
import java.io.*;
import java.util.*;
public class FastSum {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        long s = 0;
        while (n > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            while (st.hasMoreTokens() && n > 0) {
                s += Long.parseLong(st.nextToken());
                n--;
            }
        }
        System.out.println(s);
    }
}
```

### EOF까지 줄 세기(파일 파이프/온라인 저지)

```java
import java.io.*;
public class CountLines {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        long cnt = 0; String line;
        while ((line = br.readLine()) != null) { if (!line.isBlank()) cnt++; }
        System.out.println(cnt);
    }
}
```

### CSV 라인 파싱(수동)

```java
// 따옴표 미처리 간단 버전(실전 CSV는 라이브러리 권장)
String line = br.readLine();
int i = 0, start = 0;
java.util.List<String> cols = new java.util.ArrayList<>();
while (i <= line.length()) {
    if (i == line.length() || line.charAt(i) == ',') {
        cols.add(line.substring(start, i).trim());
        start = i + 1;
    }
    i++;
}
```

### 커스텀 초고속 FastScanner (바이트 파서)

```java
import java.io.*;
public class FastScanner {
    private final InputStream in;
    private final byte[] buffer = new byte[1 << 16];
    private int ptr = 0, len = 0;
    public FastScanner(InputStream is) { this.in = is; }

    private int read() throws IOException {
        if (ptr >= len) {
            len = in.read(buffer); ptr = 0;
            if (len <= 0) return -1;
        }
        return buffer[ptr++];
    }
    private int skip() throws IOException {
        int c; while ((c = read()) != -1 && c <= ' ') {}
        return c;
    }
    public String next() throws IOException {
        int c = skip(); if (c == -1) return null;
        StringBuilder sb = new StringBuilder();
        do { sb.append((char)c); c = read(); } while (c > ' ');
        return sb.toString();
    }
    public int nextInt() throws IOException {
        int c = skip(), sgn = 1, val = 0;
        if (c == '-') { sgn = -1; c = read(); }
        while (c > ' ') { val = val * 10 + (c - '0'); c = read(); }
        return val * sgn;
    }
    public long nextLong() throws IOException {
        int c = skip(), sgn = 1; long val = 0;
        if (c == '-') { sgn = -1; c = read(); }
        while (c > ' ') { val = val * 10 + (c - '0'); c = read(); }
        return val * sgn;
    }
    public static void main(String[] args) throws Exception {
        FastScanner fs = new FastScanner(System.in);
        int n = fs.nextInt(); long s = 0;
        for (int i = 0; i < n; i++) s += fs.nextLong();
        System.out.println(s);
    }
}
```

### UTF-8 인코딩 명시 & 한글 안전

```java
var br = new BufferedReader(new InputStreamReader(System.in, java.nio.charset.StandardCharsets.UTF_8));
String name = br.readLine();
System.out.println(name);
```

### 파일에서 읽고, 버퍼로 쓰기

```java
import java.io.*;
import java.nio.charset.StandardCharsets;
public class Copy {
    public static void main(String[] args) throws Exception {
        try (var br = new BufferedReader(new InputStreamReader(new FileInputStream("in.txt"), StandardCharsets.UTF_8));
             var bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("out.txt"), StandardCharsets.UTF_8))) {
            String line;
            while ((line = br.readLine()) != null) {
                bw.write(line);
                bw.newLine();
            }
        }
    }
}
```

---

## 요약 표

| 항목 | `Scanner` | `BufferedReader` + `StringTokenizer` |
|---|---|---|
| 사용성 | 직관적 | 직접 파싱 필요(조합 쉬움) |
| 속도 | 느림(정규식/로케일) | 빠름(정규식 없음) |
| 타입 파싱 | 내장 | `parseXXX` 호출 |
| 예외 | 런타임 위주 | `IOException` 처리 필요 |
| 대용량 적합성 | 낮음 | 높음 |

---

## 체크리스트

- [ ] 대용량/시간 제한 환경에서는 **`BufferedReader + StringTokenizer`** 또는 **바이트 FastScanner**
- [ ] **인코딩 명시(UTF-8)**로 한글/특수문자 안전
- [ ] `Scanner` 사용 시 **숫자 뒤 `nextLine()` 개행 소비**
- [ ] **하나의 입력 체인**만 구성(`System.in` 래퍼 중복/이중 close 금지)
- [ ] 출력은 **`BufferedWriter`/`PrintWriter`**로 버퍼링, **`flush()`** 습관화
- [ ] `split()` 남발 지양(정규식 비용/GC), **토크나이저/수동 파싱** 고려
- [ ] EOF 조건(`readLine() == null`)을 명확히 처리

---

## 한 줄 결론

> **간단**하면 `Scanner`, **빡세면** `BufferedReader + StringTokenizer`, **극한**이면 **바이트 파서**.
> 인코딩과 버퍼링, 개행·EOF·예외를 정확히 다루면, **빠르고 튼튼한** 콘솔/파일 입력 시스템을 만들 수 있습니다.
