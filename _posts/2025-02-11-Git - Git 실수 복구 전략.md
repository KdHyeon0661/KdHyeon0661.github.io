---
layout: post
title: Git - Git 실수 복구 전략
date: 2025-02-11 21:20:23 +0900
category: Git
---
# Git 실수 복구 전략 총정리 (reflog, fsck, lost-found, stash, rebase, force-push 대응까지)

## 0) 무엇을 어떻게 복구할 수 있나 — 핵심 개념 5분 요약

- Git의 **모든 데이터는 객체(Object)** 로 저장된다: commit, tree, blob, tag (SHA-1/SHA-256 해시).
- **브랜치/태그는 ‘참조(Ref)’** 이며, 단순히 특정 커밋을 **가리키는 포인터**다.
- **`reflog`는 참조(HEAD/브랜치)가 가리키던 과거 위치의 로그**다. 포인터가 어디로 이동했는지의 이력.
- **객체는 참조가 끊겨도 즉시 사라지지 않음**: **dangling object(고아 객체)** 로 남고, **gc(garbage-collect)** 가 돌 때까지는 복구 가능.
- 복구 순서의 대원칙  
  1) **`git reflog`** 로 “예전 위치”를 찾는다 → **reset/checkout -b** 로 복귀/구조화  
  2) 참조 이력이 없으면 **`git fsck --lost-found`** 로 고아 커밋을 찾는다 → 체크아웃/브랜치화  
  3) 파일 단위라면 **`git log --all -- <path>`** 로 과거 커밋에서 꺼낸다.  
  4) 원격/협업 문제면 **팀원/원격 서버의 참조/캐시**를 활용하여 롤백한다.

---

## 1) Git 내부 구조 짧게 이해하기 — 왜 복구가 가능한가

### 1.1 객체 저장소와 참조
- **commit**: 부모/작성자/메시지/루트 트리(tree) 해시를 가진다.
- **tree**: 디렉토리 스냅샷(파일명→blob, 디렉토리→tree).
- **blob**: 파일 내용.
- **ref(참조)**: `refs/heads/main`, `refs/tags/v1.0` 등. 특정 commit 해시를 문자열로 저장한 파일.

### 1.2 HEAD, 브랜치, detached HEAD
- `HEAD` 는 일반적으로 **브랜치 이름(심볼릭 ref)** 을 가리킨다. 예: `ref: refs/heads/main`
- 특정 커밋을 직접 체크아웃하면 **detached HEAD**. 이때 만든 커밋은 브랜치에 연결되지 않으므로 **잃기 쉬움** → 즉시 브랜치로 승격 필요:  
  ```bash
  git switch -c savepoint
  ```

### 1.3 reflog의 의미와 보존
- **reflog**: “이 참조가 과거에 어떤 커밋을 가리켰는가”의 로그.  
- 기본 보존: 보통 90일(환경에 따라 다름). GC가 돌면 더 오래된 dangling object 제거 가능.
- 즉, **정기적으로 GC가 돈 뒤 오래된 실수는 복구 한계**가 있다.

---

## 2) 실수 유형별 즉시 대응 표(확장판)

| 실수 | 증상 | 1차 조치 | 2차 조치 | 한계/주의 |
|---|---|---|---|---|
| `reset --hard` | 커밋과 작업 내용이 사라짐 | `git reflog` → `git reset --hard HEAD@{n}` | `git fsck --lost-found` → `dangling commit`로 복구 | GC 후 오래된 객체는 소멸 가능 |
| 브랜치 삭제 (`-D`) | 브랜치 사라짐 | `git reflog` 에서 마지막 커밋 해시 찾기 → `git checkout -b` | 팀원의 로컬/원격에서 ref 확인 | 삭제 직후 재생성 습관 |
| 파일 삭제·커밋 | 파일 증발 | `git log -- <path>` → 특정 시점 `git checkout <hash> -- <path>` | `git show <hash>:<path> > file` | 바이너리/대용량 시 주의 |
| stash 실수(`pop` 충돌) | stash 유실처럼 보임 | 일단 충돌 해결 시도 → 실패 시 `git fsck --lost-found` 탐색 | `.git/lost-found/other` 블롭 수동 복원 | pop 대신 **apply** 습관 |
| rebase 중 혼선 | rebase 루프/충돌 반복 | `git rebase --abort` → `reflog`로 안전 회귀 | `git rerere.enabled=true`로 패턴 학습 | 공유 브랜치 rebase 금지 |
| force-push 덮어씀 | 원격 이력 말소 | 팀원에게 **이전 HEAD** 요청 → `--force-with-lease` 재푸시 | 원격 reflog(설정/호스팅별 상이) | 보호 브랜치 정책 권장 |

---

## 3) `git reflog` — 복구의 1순위 도구

### 3.1 사용법과 출력
```bash
git reflog
```
출력 예:
```
a3c22fb HEAD@{0}: reset: moving to HEAD~1
7b9d3f2 HEAD@{1}: commit: 로그인 기능 추가
adf23f1 HEAD@{2}: commit: 뷰 수정
```
- `HEAD@{n}` 은 **n 스텝 전**에 HEAD가 가리키던 커밋.

### 3.2 즉시 복구
```bash
# 가장 최근 이전 상태로 되돌리기
git reset --hard HEAD@{1}

# 안전 복구(새 브랜치)
git checkout -b rescue HEAD@{2}
```

### 3.3 특정 브랜치 reflog
```bash
git reflog show main
git reflog show feature/login
```
- 브랜치별로 포인터 이동 이력을 추적하여 개별 복구가 가능.

### 3.4 reflog 보존/만료 튜닝(참고)
- `gc.reflogExpire`, `gc.reflogExpireUnreachable` 로 보존 기간 조정 가능(레포 단위/전역).
- 장기 보존이 필요하면 백업/미러 레포 운영 고려.

---

## 4) `git fsck --lost-found` — dangling(고아) 커밋/객체 찾기

### 4.1 개념
- 참조가 끊긴 커밋/블롭은 **dangling** 으로 남는다.
- garbage collection 이전이라면 **내용은 그대로** 이므로 복구 가능.

### 4.2 사용
```bash
git fsck --lost-found
```
예:
```
dangling commit 2e4f9a1d...
dangling blob   e1c1aa5b...
```

### 4.3 커밋 복구
```bash
# 내용 확인
git show 2e4f9a1d

# 브랜치 승격
git checkout -b recovered-branch 2e4f9a1d
```

### 4.4 blob(파일) 복구
```bash
# 파일 내용 확인
git show e1c1aa5b > restored.txt

# 혹은 과거 커밋에서 특정 경로를 바로 꺼내기
git show <commit>:path/to/file > file
```

---

## 5) stash 사고 복구 — 내부 동작과 실전 패턴

### 5.1 원리
- `git stash` 는 내부적으로 **커밋 1~2개**(작업 트리/스테이징 상태)를 `refs/stash` 에 쌓는다.
- `stash pop` 은 적용+삭제, `stash apply` 는 적용만.  
  → **pop 대신 apply** 를 쓰면 유실 리스크가 줄어든다.

### 5.2 사고 시 체크리스트
1) 충돌이 났다면 **해결을 시도**. 실패 시 중단하지 말고 상태를 기록:
```bash
git status
git diff
```
2) stash 목록 확인:
```bash
git stash list
```
3) 정말 목록이 비면:
```bash
git fsck --lost-found   # dangling commit/blob 탐색
# 출력된 dangling commit 들을 하나씩 확인
git show <dangling-commit>
```
4) `.git/lost-found/other` 에서 blob 추출:
```bash
# 레포 루트 기준
cd .git/lost-found/other
# 후보 파일을 하나씩 열어 실제 stash 내용인지 확인 후 복사
```

### 5.3 stash 안전 운영 팁
- 늘 `git stash apply` 사용 후 성공하면 `git stash drop` 으로 수동 삭제.
- 커다란 변경을 stash 대신 **토픽 브랜치**로 커밋(임시 커밋 메시지)하여 안전성 확보.

---

## 6) 브랜치 삭제 복구 — reflog와 팀 동료의 로컬이 최고의 백업

### 6.1 로컬 브랜치 삭제 즉시 복구
```bash
git reflog
# 예) f9c2a01 이 마지막 커밋
git checkout -b feature/login f9c2a01
```

### 6.2 원격 브랜치 제거 사고
- 이미 원격 브랜치를 삭제했다면, **팀 동료 로컬** 또는 **CI/미러 레포** 에 그 브랜치가 남아 있을 가능성이 높다.
- 동료 로컬에서:
```bash
git log <deleted-branch> --oneline   # 과거 HEAD 확인
git push origin <commit>:refs/heads/<deleted-branch>
```
- 원격 호스팅(예: GitHub)에서 **브랜치 보호/필수 리뷰** 등을 적극 사용해 **오작동 예방**.

---

## 7) rebase 중단/혼선 복구 — abort, continue, reflog, rerere

### 7.1 표준 루틴
```bash
# 충돌 해결 → add → 계속
git rebase --continue

# 현재 커밋 건너뛰기
git rebase --skip

# 전체 중단
git rebase --abort
```

### 7.2 완전 초기화
- 무엇이든 꼬였으면 **`reflog` 보고 시작 전으로**:
```bash
git reflog
git reset --hard HEAD@{n}
```

### 7.3 반복 충돌 최적화: rerere
```bash
git config --global rerere.enabled true
```
- 같은 패턴의 충돌이 재발하면 **자동으로 과거 해결을 재적용**(검토 후 커밋).

---

## 8) force-push(강제 푸시) 사고 — 팀 레벨 롤백 전략

### 8.1 원인
- 로컬에서 `rebase` 로 커밋 재작성 후 **`git push -f`** 로 원격을 덮어씀.
- 또는 잘못된 reset/rebase 결과를 그대로 강제 푸시.

### 8.2 안전한 푸시 습관
```bash
git push --force-with-lease
```
- 원격 최신과 내 로컬 기대치가 다르면 거절 → **동료 커밋 보호**.

### 8.3 롤백 전략
- 바로 직전에 존재했던 **원격 HEAD** 를 찾는다.  
  1) 팀원의 로컬에서 **강제 푸시 이전의 HEAD** 커밋 해시를 조회  
  2) 해당 커밋을 원격의 브랜치로 **강제 복구**:
    ```bash
    git push origin <old-commit>:refs/heads/main
    ```
- 브랜치 보호 규칙(Require PR/Linear history/Status checks/Restrict push)으로 **실수 자체를 사전에 차단**.

---

## 9) 파일 단위 복구 — 특정 파일만 되살리기

### 9.1 과거 커밋에서 꺼내오기
```bash
# 파일의 과거 이력 확인
git log --all -- <path>

# 특정 커밋에서 파일 복원(워킹 트리에만 반영)
git checkout <commit> -- <path>

# 또는 파일로 추출
git show <commit>:<path> > restored-file
```

### 9.2 삭제된 파일 탐색
```bash
git log --diff-filter=D --summary -- <path>   # 삭제 시점 찾기
```

---

## 10) 자동화 스니펫/alias 모음

### 10.1 빠른 reflog 복구 헬퍼
```bash
# ~/.gitconfig
[alias]
  oops = !"git --no-pager reflog --date=local && echo '힌트: git reset --hard HEAD@{N} 또는 git checkout -b rescue HEAD@{N}'"
```

### 10.2 최근 삭제 브랜치 후보 찾기
```bash
[alias]
  findgone = "!git for-each-ref --format='%(refname:short) %(objectname:short) %(committerdate:relative)' --sort=-committerdate refs/original/ refs/rewritten/"
```

### 10.3 잦은 충돌 환경 최적화
```bash
git config --global rerere.enabled true
git config --global merge.tool meld   # 선호 도구로 교체
```

---

## 11) 재현 가능한 복구 랩(로컬 실습 스크립트)

### 11.1 `reset --hard` 실수 → reflog로 복구
```bash
rm -rf lab-reset && mkdir lab-reset && cd lab-reset
git init
git config user.name "lab" && git config user.email "lab@example.com"

echo "v1" > f.txt
git add . && git commit -m "v1"
echo "v2" >> f.txt
git commit -am "v2"
echo "v3" >> f.txt
git commit -am "v3"

git log --oneline

# 실수: v3를 날림
git reset --hard HEAD~1
git log --oneline

# 복구: v3가 있던 위치 찾기
git reflog
# 예: HEAD@{1} 이 reset 전을 가리킨다면
git reset --hard HEAD@{1}   # 또는 새 브랜치로 checkout -b
```

### 11.2 브랜치 삭제 → reflog로 복구
```bash
rm -rf lab-branch && mkdir lab-branch && cd lab-branch
git init
git config user.name "lab" && git config user.email "lab@example.com"
git checkout -b feature/login

echo "login" > app.txt
git add . && git commit -m "feat: login"
git checkout -   # 이전 브랜치로(main 또는 master)
git branch -D feature/login  # 실수로 삭제

# 복구
git reflog
# feature/login 이 마지막으로 가리키던 커밋 해시 확인 후
git checkout -b feature/login <hash>
```

### 11.3 stash pop 사고 → fsck로 복원 시도
```bash
rm -rf lab-stash && mkdir lab-stash && cd lab-stash
git init
git config user.name "lab" && git config user.email "lab@example.com"

echo "base" > a.txt
git add . && git commit -m "base"

echo "work" >> a.txt
git stash   # stash@{0}

# 나쁜 습관: pop 사용
git stash pop   # 충돌 유도 상황이라고 가정
# 실패/유실처럼 보임

git fsck --lost-found
# dangling commit/blob 들을 하나씩 `git show` 로 열어 확인하고 복구
```

### 11.4 rebase 꼬임 → abort/continue + reflog 회귀
```bash
rm -rf lab-rebase && mkdir lab-rebase && cd lab-rebase
git init
git config user.name "lab" && git config user.email "lab@example.com"
git branch -M main

echo "base" > app.txt
git add . && git commit -m "base"

git checkout -b feature
echo "f1" >> app.txt
git commit -am "f1"
echo "f2" >> app.txt
git commit -am "f2"

git checkout main
echo "m1" >> app.txt
git commit -am "m1"

git checkout feature
git rebase main   # 충돌 가정
# 해결 실패 시:
git rebase --abort
# 또는 reflog로 재설정:
git reflog
git reset --hard HEAD@{2}
```

### 11.5 force-push 롤백 시나리오(협업)
- 시뮬레이션 개요:
  1) 동료 A가 `main` 에 커밋 후 푸시
  2) 나(B)가 로컬에서 reset/rebase 후 **force push** 로 덮어씀
  3) A의 로컬에서 이전 커밋 해시를 가지고 **원격 복구**:
     ```bash
     git push origin <old-commit>:refs/heads/main
     ```
- 실제 팀/레포로는 테스트 금지. **샌드박스/패치 브랜치**로만 실습.

---

## 12) 예방 전략 — 사고 전에 안전망을 깔자

- **`reset --hard` 전** 에는 반드시
  ```bash
  git stash
  # 또는
  git switch -c backup/$(date +%F-%H%M)
  ```
- 강제 푸시는
  ```bash
  git push --force-with-lease
  ```
- 복잡한 rebase 전
  ```bash
  git log --oneline --graph --decorate --all
  git branch backup/$(date +%F-%H%M)
  ```
- 보호 브랜치/PR 워크플로우/리뷰/CI/서명 정책으로 **조직적 안전장치** 구축.

---

## 13) 명령 치트시트(요약)

```bash
# 1) reflog 기반 복구
git reflog
git reset --hard HEAD@{N}
git checkout -b rescue HEAD@{N}

# 2) lost-found 기반 복구
git fsck --lost-found
git show <dangling-commit>
git checkout -b recovered <dangling-commit>
git show <dangling-blob> > restored.bin

# 3) 파일 단위 복구
git log --all -- <path>
git checkout <commit> -- <path>
git show <commit>:<path> > file

# 4) rebase 사고 처리
git rebase --continue | --skip | --abort
git config --global rerere.enabled true

# 5) stash 안전 운용
git stash apply    # 우선 적용 후
git stash drop     # 성공 시 삭제

# 6) force-push 안전
git push --force-with-lease
```

---

## 14) 결론

- **reflog** 는 복구의 출발점이며, **dangling object** 는 gc 이전까지 강력한 세이프티넷이다.  
- 파일 단위 복구/브랜치 복구/force-push 롤백/stash 복구 모두 **일관된 원리**(참조와 객체의 분리, 로그/캐시의 활용)로 해결 가능하다.  
- 사고를 줄이는 가장 확실한 방법은 **백업 브랜치/보호 브랜치/PR/CI/서명 정책**과 **습관화된 안전 푸시/적용-삭제 흐름**이다.

---

## 참고
- Git Reflog: https://git-scm.com/docs/git-reflog  
- Git fsck: https://git-scm.com/docs/git-fsck  
- Pro Git, Undoing Things: https://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified