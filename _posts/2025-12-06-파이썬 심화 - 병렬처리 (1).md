---
layout: post
title: 파이썬 심화 - 병렬처리 (1)
date: 2025-12-06 15:30:23 +0900
category: 파이썬 심화
---
# 병렬처리 (1)

## 스레드 시작과 정지: 안전한 생명주기 관리

파이썬에서 스레드는 `threading` 모듈을 통해 생성되고 관리됩니다. GIL(Global Interpreter Lock)의 존재로 인해 CPU 바운드 작업에는 제한이 있지만, I/O 바운드 작업이나 동시성 처리는 효과적으로 다룰 수 있습니다.

### 기본 스레드 생성과 실행

```python
import threading
import time
import logging
from typing import Optional, Callable, Any
from datetime import datetime
from enum import Enum

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(threadName)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class ThreadStatus(Enum):
    """스레드 상태를 정의하는 열거형"""
    CREATED = "created"
    STARTED = "started"
    RUNNING = "running"
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"

class ManagedThread(threading.Thread):
    """
    안전하게 관리되는 스레드 클래스
    
    시작, 정지, 상태 추적 기능을 내장
    """
    
    def __init__(self, 
                 name: Optional[str] = None,
                 target: Optional[Callable] = None,
                 args: tuple = (),
                 kwargs: Optional[dict] = None,
                 daemon: bool = False):
        """
        관리형 스레드 초기화
        
        Args:
            name: 스레드 이름 (None이면 자동 생성)
            target: 실행할 함수
            args: 함수에 전달할 인자 튜플
            kwargs: 함수에 전달할 키워드 인자 딕셔너리
            daemon: 데몬 스레드 여부
        """
        if name is None:
            name = f"Thread-{threading.get_ident()}-{datetime.now().timestamp()}"
        
        super().__init__(
            name=name,
            target=target,
            args=args,
            kwargs=kwargs if kwargs else {},
            daemon=daemon
        )
        
        self._status = ThreadStatus.CREATED
        self._stop_event = threading.Event()
        self._pause_event = threading.Event()
        self._pause_event.set()  # 초기 상태는 실행 중
        self._error_info: Optional[Exception] = None
        self._start_time: Optional[float] = None
        self._end_time: Optional[float] = None
        
        logger.info(f"스레드 '{self.name}' 생성됨 (상태: {self._status.value})")
    
    def run(self):
        """
        스레드 실행 메인 루프
        
        내부적으로 오류 처리와 상태 관리를 포함
        """
        self._status = ThreadStatus.STARTED
        self._start_time = time.time()
        
        logger.info(f"스레드 '{self.name}' 시작됨")
        
        try:
            # 타겟 함수 실행 전 상태 설정
            self._status = ThreadStatus.RUNNING
            
            # 사용자 정의 타겟 함수가 있는 경우 실행
            if self._target:
                # 정지 이벤트 체크를 위한 래퍼 함수
                def wrapped_target():
                    # 일시 정지 상태 확인
                    self._pause_event.wait()
                    
                    # 정지 요청이 있었는지 확인
                    if self._stop_event.is_set():
                        return None
                    
                    # 실제 타겟 함수 실행
                    return self._target(*self._args, **self._kwargs)
                
                result = wrapped_target()
                
                # 정지 이벤트가 설정되지 않았다면 완료된 것
                if not self._stop_event.is_set():
                    logger.info(f"스레드 '{self.name}' 정상 완료")
                    self._status = ThreadStatus.STOPPED
            
            else:
                # 사용자 정의 run 메서드가 없는 경우 기본 루프 실행
                while not self._stop_event.is_set():
                    # 일시 정지 상태 확인
                    self._pause_event.wait()
                    
                    # 정지 요청이 있으면 루프 종료
                    if self._stop_event.is_set():
                        break
                    
                    # 실제 작업 수행 (하위 클래스에서 오버라이드)
                    self._do_work()
                    
                    # CPU 점유를 방지하기 위한 작은 대기
                    time.sleep(0.01)
        
        except Exception as e:
            # 오류 발생 시 상태 기록
            self._status = ThreadStatus.ERROR
            self._error_info = e
            logger.error(f"스레드 '{self.name}' 실행 중 오류: {e}", exc_info=True)
        
        finally:
            # 종료 시간 기록
            self._end_time = time.time()
            
            if self._status != ThreadStatus.ERROR:
                self._status = ThreadStatus.STOPPED
            
            logger.info(f"스레드 '{self.name}' 종료됨 (상태: {self._status.value}, "
                       f"실행 시간: {self.get_execution_time():.2f}초)")
    
    def _do_work(self):
        """
        실제 작업 수행 메서드 (하위 클래스에서 오버라이드)
        
        타겟 함수가 없을 때 기본으로 실행되는 메서드
        """
        # 기본 구현: 아무 작업도 하지 않음
        pass
    
    def safe_start(self):
        """
        안전하게 스레드 시작
        
        이미 실행 중인 스레드를 다시 시작하지 않도록 보호
        """
        if self._status in [ThreadStatus.STARTED, ThreadStatus.RUNNING]:
            logger.warning(f"스레드 '{self.name}'가 이미 실행 중입니다.")
            return False
        
        if self._status == ThreadStatus.STOPPED:
            logger.warning(f"스레드 '{self.name}'는 이미 종료되어 재시작할 수 없습니다.")
            return False
        
        try:
            super().start()
            return True
        except RuntimeError as e:
            logger.error(f"스레드 '{self.name}' 시작 실패: {e}")
            self._status = ThreadStatus.ERROR
            self._error_info = e
            return False
    
    def safe_stop(self, timeout: Optional[float] = 5.0) -> bool:
        """
        안전하게 스레드 정지
        
        Args:
            timeout: 종료 대기 시간 (초), None이면 무한대기
        
        Returns:
            정지 성공 여부
        """
        if self._status in [ThreadStatus.CREATED, ThreadStatus.STOPPED]:
            logger.info(f"스레드 '{self.name}'는 이미 정지 상태입니다.")
            return True
        
        logger.info(f"스레드 '{self.name}' 정지 요청 (타임아웃: {timeout}초)")
        self._status = ThreadStatus.STOPPING
        
        # 정지 이벤트 설정
        self._stop_event.set()
        
        # 일시 정지 해제 (정지를 위해)
        self._pause_event.set()
        
        # 스레드가 자체적으로 종료되도록 대기
        if timeout is not None:
            self.join(timeout=timeout)
            
            # 타임아웃 후에도 살아있는지 확인
            if self.is_alive():
                logger.warning(f"스레드 '{self.name}'가 타임아웃 내에 종료되지 않았습니다.")
                return False
        
        return True
    
    def pause(self):
        """스레드 일시 정지"""
        if self._status == ThreadStatus.RUNNING:
            self._pause_event.clear()
            logger.info(f"스레드 '{self.name}' 일시 정지됨")
    
    def resume(self):
        """스레드 재개"""
        if self._status == ThreadStatus.RUNNING and not self._pause_event.is_set():
            self._pause_event.set()
            logger.info(f"스레드 '{self.name}' 재개됨")
    
    def get_status(self) -> ThreadStatus:
        """현재 스레드 상태 반환"""
        return self._status
    
    def is_running(self) -> bool:
        """스레드가 실행 중인지 확인"""
        return self._status == ThreadStatus.RUNNING and self.is_alive()
    
    def is_stopped(self) -> bool:
        """스레드가 정지되었는지 확인"""
        return self._status == ThreadStatus.STOPPED or not self.is_alive()
    
    def get_execution_time(self) -> Optional[float]:
        """실행 시간 반환 (초)"""
        if self._start_time is None:
            return None
        
        if self._end_time is None:
            return time.time() - self._start_time
        else:
            return self._end_time - self._start_time
    
    def get_error_info(self) -> Optional[Exception]:
        """오류 정보 반환"""
        return self._error_info

# 작업자 스레드 예시 클래스
class WorkerThread(ManagedThread):
    """
    실제 작업을 수행하는 워커 스레드 예시
    """
    
    def __init__(self, worker_id: int, work_items: list):
        super().__init__(name=f"Worker-{worker_id}")
        self.worker_id = worker_id
        self.work_items = work_items
        self.processed_count = 0
        self.results = []
    
    def _do_work(self):
        """실제 작업 수행"""
        if self.processed_count < len(self.work_items):
            item = self.work_items[self.processed_count]
            
            # 작업 시뮬레이션
            time.sleep(0.5)  # 작업 시간 시뮬레이션
            
            result = f"Worker-{self.worker_id} processed: {item}"
            self.results.append(result)
            self.processed_count += 1
            
            logger.debug(f"Worker-{self.worker_id}: {item} 처리 완료")
        else:
            # 모든 작업 완료
            logger.info(f"Worker-{self.worker_id}: 모든 작업 완료")
            self._stop_event.set()

# 스레드 풀 관리자
class ThreadPoolManager:
    """
    여러 스레드를 관리하는 스레드 풀
    """
    
    def __init__(self, max_workers: int = 4):
        self.max_workers = max_workers
        self.threads: list[ManagedThread] = []
        self.active_workers = 0
        self.lock = threading.RLock()  # 재진입 가능한 Lock
        
        logger.info(f"스레드 풀 생성 (최대 워커: {max_workers})")
    
    def submit(self, target: Callable, *args, **kwargs) -> Optional[ManagedThread]:
        """
        작업을 스레드에 제출
        
        Args:
            target: 실행할 함수
            *args, **kwargs: 함수 인자
        
        Returns:
            생성된 스레드 객체 또는 None
        """
        with self.lock:
            if self.active_workers >= self.max_workers:
                logger.warning("스레드 풀이 가득 찼습니다.")
                return None
            
            # 새 스레드 생성
            thread = ManagedThread(
                name=f"PoolWorker-{len(self.threads)}",
                target=target,
                args=args,
                kwargs=kwargs
            )
            
            self.threads.append(thread)
            self.active_workers += 1
            
            # 스레드 시작
            if thread.safe_start():
                logger.info(f"작업 제출됨: {thread.name}")
                return thread
            else:
                self.threads.remove(thread)
                self.active_workers -= 1
                return None
    
    def stop_all(self, timeout: float = 5.0) -> bool:
        """
        모든 스레드 정지
        
        Args:
            timeout: 각 스레드별 정지 대기 시간
        
        Returns:
            모든 스레드 정지 성공 여부
        """
        all_stopped = True
        
        logger.info(f"모든 스레드 정지 시작 (총 {len(self.threads)}개)")
        
        for thread in self.threads[:]:  # 복사본으로 순회
            if thread.is_alive():
                stopped = thread.safe_stop(timeout)
                if not stopped:
                    all_stopped = False
                    logger.warning(f"스레드 {thread.name} 정지 실패")
        
        # 정지된 스레드 제거
        self.threads = [t for t in self.threads if t.is_alive()]
        self.active_workers = len(self.threads)
        
        logger.info(f"스레드 정지 완료 (남은 스레드: {self.active_workers}개)")
        return all_stopped
    
    def get_thread_info(self) -> list[dict]:
        """모든 스레드 정보 반환"""
        info = []
        
        for thread in self.threads:
            info.append({
                'name': thread.name,
                'status': thread.get_status().value,
                'alive': thread.is_alive(),
                'execution_time': thread.get_execution_time(),
                'error': str(thread.get_error_info()) if thread.get_error_info() else None
            })
        
        return info
    
    def wait_for_completion(self, timeout: Optional[float] = None) -> bool:
        """
        모든 스레드 완료 대기
        
        Args:
            timeout: 최대 대기 시간
        
        Returns:
            모든 스레드가 완료되었는지 여부
        """
        start_time = time.time()
        
        while True:
            # 살아있는 스레드 수 확인
            alive_count = sum(1 for t in self.threads if t.is_alive())
            
            if alive_count == 0:
                logger.info("모든 스레드 작업 완료")
                return True
            
            # 타임아웃 체크
            if timeout is not None and (time.time() - start_time) > timeout:
                logger.warning(f"타임아웃: {alive_count}개의 스레드가 아직 실행 중")
                return False
            
            # 잠시 대기
            time.sleep(0.1)

# 데모: 스레드 시작과 정지
def demonstrate_thread_lifecycle():
    """
    스레드 생명주기 관리 데모
    """
    print("=" * 60)
    print("스레드 생명주기 관리 데모")
    print("=" * 60)
    
    def long_running_task(task_id: int, duration: int = 10):
        """장기 실행 작업 시뮬레이션"""
        logger.info(f"작업 {task_id} 시작 (예상 시간: {duration}초)")
        
        for i in range(duration):
            if threading.current_thread().stop_requested:
                logger.info(f"작업 {task_id} 정지 요청 수신")
                break
            
            logger.info(f"작업 {task_id}: {i+1}/{duration} 진행 중...")
            time.sleep(1)
        
        logger.info(f"작업 {task_id} 완료")
        return f"Task-{task_id}-Result"
    
    # 관리형 스레드 생성
    print("\n1. 관리형 스레드 생성 및 시작:")
    thread1 = ManagedThread(
        name="테스트-스레드-1",
        target=long_running_task,
        args=(1, 5)
    )
    
    # 속성 추가 (ManagedThread에서 사용하는 내부 속성과 충돌하지 않도록)
    thread1.stop_requested = False
    
    # 스레드 시작
    if thread1.safe_start():
        print(f"  스레드 '{thread1.name}' 시작됨")
    
    # 상태 확인
    print(f"\n2. 스레드 상태 확인:")
    print(f"  실행 중인가? {thread1.is_running()}")
    print(f"  살아있는가? {thread1.is_alive()}")
    print(f"  상태: {thread1.get_status().value}")
    
    # 잠시 실행되도록 대기
    time.sleep(2)
    
    print(f"\n3. 2초 후 상태 확인:")
    print(f"  실행 중인가? {thread1.is_running()}")
    print(f"  실행 시간: {thread1.get_execution_time():.2f}초")
    
    # 스레드 정지
    print(f"\n4. 스레드 정지 시도:")
    if thread1.safe_stop(timeout=2):
        print(f"  스레드 정지 성공")
    else:
        print(f"  스레드 정지 실패")
    
    # 최종 상태
    print(f"\n5. 최종 상태:")
    print(f"  실행 중인가? {thread1.is_running()}")
    print(f"  정지되었는가? {thread1.is_stopped()}")
    print(f"  전체 실행 시간: {thread1.get_execution_time():.2f}초")
    
    print(f"\n6. 스레드 풀 데모:")
    pool = ThreadPoolManager(max_workers=3)
    
    # 여러 작업 제출
    for i in range(5):
        thread = pool.submit(long_running_task, i+10, 3)
        if thread:
            thread.stop_requested = False
    
    # 상태 모니터링
    for _ in range(3):
        time.sleep(1)
        info = pool.get_thread_info()
        active = sum(1 for t in info if t['alive'])
        print(f"  활성 스레드: {active}/{pool.max_workers}")
    
    # 모든 스레드 정지
    pool.stop_all(timeout=3)

if __name__ == "__main__":
    demonstrate_thread_lifecycle()
```

## 스레드가 시작했는지 판단하기: 상태 모니터링 기술

스레드의 실행 상태를 정확히 판단하는 것은 안정적인 멀티스레드 애플리케이션을 구축하는 데 필수적입니다.

### 상태 모니터링 시스템 구현

```python
import threading
import time
import psutil
import os
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from concurrent.futures import Future, ThreadPoolExecutor
import queue

@dataclass
class ThreadMetrics:
    """스레드 성능 메트릭스를 저장하는 데이터 클래스"""
    thread_name: str
    cpu_percent: float = 0.0
    memory_mb: float = 0.0
    io_counters: Optional[tuple] = None
    context_switches: Optional[int] = None
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> dict:
        """딕셔너리로 변환"""
        return {
            'thread_name': self.thread_name,
            'cpu_percent': self.cpu_percent,
            'memory_mb': self.memory_mb,
            'timestamp': self.timestamp.isoformat()
        }

class ThreadMonitor:
    """
    스레드 상태와 성능을 모니터링하는 클래스
    """
    
    def __init__(self, update_interval: float = 1.0):
        """
        스레드 모니터 초기화
        
        Args:
            update_interval: 모니터링 업데이트 간격 (초)
        """
        self.update_interval = update_interval
        self.monitored_threads: Dict[str, threading.Thread] = {}
        self.thread_metrics: Dict[str, List[ThreadMetrics]] = {}
        self.monitoring_thread: Optional[threading.Thread] = None
        self.stop_monitoring = threading.Event()
        self.lock = threading.RLock()
        
        # 프로세스 정보
        self.process = psutil.Process(os.getpid())
        
        logger.info(f"스레드 모니터 초기화 (업데이트 간격: {update_interval}초)")
    
    def add_thread(self, thread: threading.Thread):
        """
        모니터링할 스레드 추가
        
        Args:
            thread: 모니터링할 스레드 객체
        """
        with self.lock:
            if thread.name not in self.monitored_threads:
                self.monitored_threads[thread.name] = thread
                self.thread_metrics[thread.name] = []
                logger.info(f"스레드 '{thread.name}' 모니터링 목록에 추가됨")
    
    def remove_thread(self, thread_name: str):
        """모니터링에서 스레드 제거"""
        with self.lock:
            if thread_name in self.monitored_threads:
                del self.monitored_threads[thread_name]
                logger.info(f"스레드 '{thread.name}' 모니터링에서 제거됨")
    
    def start_monitoring(self):
        """모니터링 시작"""
        if self.monitoring_thread and self.monitoring_thread.is_alive():
            logger.warning("모니터링이 이미 실행 중입니다.")
            return
        
        self.stop_monitoring.clear()
        self.monitoring_thread = threading.Thread(
            target=self._monitoring_loop,
            name="ThreadMonitor",
            daemon=True
        )
        self.monitoring_thread.start()
        logger.info("스레드 모니터링 시작됨")
    
    def stop_monitoring(self):
        """모니터링 중지"""
        self.stop_monitoring.set()
        
        if self.monitoring_thread:
            self.monitoring_thread.join(timeout=2)
            logger.info("스레드 모니터링 중지됨")
    
    def _monitoring_loop(self):
        """모니터링 메인 루프"""
        while not self.stop_monitoring.is_set():
            try:
                self._collect_metrics()
            except Exception as e:
                logger.error(f"메트릭스 수집 중 오류: {e}")
            
            # 지정된 간격 대기
            time.sleep(self.update_interval)
    
    def _collect_metrics(self):
        """모니터링 중인 스레드들의 메트릭스 수집"""
        with self.lock:
            current_time = datetime.now()
            
            # 각 스레드의 상태 확인
            for thread_name, thread in list(self.monitored_threads.items()):
                try:
                    # CPU 사용률 (전체 프로세스 기준, 스레드별 정확한 측정은 OS에 따라 다름)
                    cpu_percent = self.process.cpu_percent(interval=None)
                    
                    # 메모리 사용량
                    memory_info = self.process.memory_info()
                    memory_mb = memory_info.rss / (1024 * 1024)  # MB로 변환
                    
                    # 메트릭스 저장
                    metrics = ThreadMetrics(
                        thread_name=thread_name,
                        cpu_percent=cpu_percent,
                        memory_mb=memory_mb,
                        timestamp=current_time
                    )
                    
                    self.thread_metrics[thread_name].append(metrics)
                    
                    # 오래된 데이터 정리 (1시간 이상)
                    cutoff_time = current_time - timedelta(hours=1)
                    self.thread_metrics[thread_name] = [
                        m for m in self.thread_metrics[thread_name]
                        if m.timestamp > cutoff_time
                    ]
                    
                except (psutil.NoSuchProcess, KeyError):
                    # 스레드가 종료된 경우
                    self.remove_thread(thread_name)
    
    def get_thread_status(self, thread_name: str) -> Dict[str, any]:
        """
        특정 스레드의 상세 상태 반환
        
        Returns:
            스레드 상태 정보 딕셔너리
        """
        with self.lock:
            if thread_name not in self.monitored_threads:
                return {'error': '스레드를 찾을 수 없습니다.'}
            
            thread = self.monitored_threads[thread_name]
            
            # 기본 상태 정보
            status = {
                'name': thread.name,
                'ident': thread.ident,
                'alive': thread.is_alive(),
                'daemon': thread.daemon,
                'native_id': thread.native_id if hasattr(thread, 'native_id') else None
            }
            
            # 성능 메트릭스 추가 (가장 최근 것)
            if self.thread_metrics.get(thread_name):
                latest_metrics = self.thread_metrics[thread_name][-1]
                status.update(latest_metrics.to_dict())
            
            # 실행 시간 계산
            if hasattr(thread, 'get_execution_time'):
                exec_time = thread.get_execution_time()
                if exec_time:
                    status['execution_time'] = exec_time
            
            return status
    
    def get_all_threads_status(self) -> List[Dict[str, any]]:
        """모든 모니터링 중인 스레드 상태 반환"""
        with self.lock:
            status_list = []
            
            for thread_name in self.monitored_threads:
                status = self.get_thread_status(thread_name)
                status_list.append(status)
            
            return status_list
    
    def detect_deadlock(self, timeout: float = 5.0) -> Optional[List[str]]:
        """
        잠재적인 데드락 감지 (간단한 구현)
        
        Args:
            timeout: 잠금 대기 타임아웃
        
        Returns:
            데드락 가능성이 있는 스레드 목록 또는 None
        """
        deadlock_candidates = []
        
        with self.lock:
            for thread_name, thread in self.monitored_threads.items():
                if not thread.is_alive():
                    continue
                
                # 스레드가 특정 시간 이상 동일한 상태인지 확인
                # 실제 데드락 감지는 더 복잡한 로직 필요
                metrics = self.thread_metrics.get(thread_name, [])
                
                if len(metrics) >= 3:
                    # 최근 3개 메트릭스 비교
                    recent_times = [m.timestamp for m in metrics[-3:]]
                    time_diffs = [(recent_times[i+1] - recent_times[i]).total_seconds() 
                                for i in range(len(recent_times)-1)]
                    
                    # 모두 비슷한 시간 간격이고 CPU 사용률이 0에 가까운 경우
                    recent_cpu = [m.cpu_percent for m in metrics[-3:]]
                    
                    if (max(time_diffs) - min(time_diffs) < 0.1 and 
                        all(cpu < 1.0 for cpu in recent_cpu)):
                        deadlock_candidates.append(thread_name)
        
        return deadlock_candidates if deadlock_candidates else None

# 고급 상태 체크 데코레이터
def with_thread_validation(max_execution_time: Optional[float] = None):
    """
    스레드 실행을 검증하는 데코레이터
    
    Args:
        max_execution_time: 최대 실행 시간 (초), 초과시 경고
    """
    def decorator(func: Callable):
        def wrapper(*args, **kwargs):
            thread_name = threading.current_thread().name
            start_time = time.time()
            
            logger.info(f"스레드 '{thread_name}': 함수 {func.__name__} 실행 시작")
            
            try:
                result = func(*args, **kwargs)
                
                execution_time = time.time() - start_time
                logger.info(f"스레드 '{thread_name}': 함수 {func.__name__} 실행 완료 "
                           f"(소요시간: {execution_time:.2f}초)")
                
                # 최대 실행 시간 검사
                if max_execution_time and execution_time > max_execution_time:
                    logger.warning(f"스레드 '{thread_name}': 함수 {func.__name__}가 "
                                 f"예상 시간({max_execution_time}초)을 초과했습니다.")
                
                return result
                
            except Exception as e:
                execution_time = time.time() - start_time
                logger.error(f"스레드 '{thread_name}': 함수 {func.__name__} 실행 중 오류 "
                           f"(소요시간: {execution_time:.2f}초): {e}")
                raise
        
        return wrapper
    return decorator

# 상태 감시 스레드 예시
class WatchdogThread(threading.Thread):
    """
    다른 스레드들의 건강 상태를 감시하는 워치독 스레드
    """
    
    def __init__(self, 
                 target_threads: List[threading.Thread],
                 check_interval: float = 2.0,
                 max_no_progress_time: float = 30.0):
        super().__init__(name="Watchdog", daemon=True)
        
        self.target_threads = target_threads
        self.check_interval = check_interval
        self.max_no_progress_time = max_no_progress_time
        self.thread_progress: Dict[str, Dict] = {}
        self.stop_requested = threading.Event()
        
        # 각 스레드의 진행 상황 추적 초기화
        for thread in target_threads:
            self.thread_progress[thread.name] = {
                'last_check': time.time(),
                'last_state': None,
                'stuck_count': 0
            }
    
    def run(self):
        """워치독 메인 루프"""
        logger.info(f"워치독 스레드 시작 (감시 대상: {len(self.target_threads)}개 스레드)")
        
        while not self.stop_requested.is_set():
            self._check_threads()
            time.sleep(self.check_interval)
        
        logger.info("워치독 스레드 종료")
    
    def _check_threads(self):
        """대상 스레드들 상태 확인"""
        for thread in self.target_threads[:]:  # 복사본으로 순회
            if not thread.is_alive():
                logger.warning(f"스레드 '{thread.name}'가 비정상적으로 종료되었습니다.")
                self.target_threads.remove(thread)
                continue
            
            # 진행 상황 체크 (실제 구현에서는 진행률 메트릭스 필요)
            thread_info = self.thread_progress[thread.name]
            current_time = time.time()
            
            # 너무 오래 같은 상태인지 확인
            if current_time - thread_info['last_check'] > self.max_no_progress_time:
                thread_info['stuck_count'] += 1
                logger.warning(f"스레드 '{thread.name}'가 {self.max_no_progress_time}초 동안 "
                             f"진전이 없습니다. (경고 #{thread_info['stuck_count']})")
            
            thread_info['last_check'] = current_time
    
    def stop(self):
        """워치독 스레드 정지"""
        self.stop_requested.set()

# 데모: 스레드 상태 모니터링
def demonstrate_thread_monitoring():
    """
    스레드 상태 모니터링 데모
    """
    print("=" * 60)
    print("스레드 상태 모니터링 시스템")
    print("=" * 60)
    
    # 모니터 생성
    monitor = ThreadMonitor(update_interval=0.5)
    
    # 테스트 스레드들 생성
    def worker_task(worker_id: int, iterations: int = 10):
        """작업자 태스크"""
        for i in range(iterations):
            logger.info(f"Worker-{worker_id}: 작업 {i+1}/{iterations}")
            time.sleep(0.3)
        
        logger.info(f"Worker-{worker_id}: 작업 완료")
        return worker_id
    
    threads = []
    
    print("\n1. 스레드 생성 및 모니터링 시작:")
    
    # 3개의 작업자 스레드 생성
    for i in range(3):
        thread = threading.Thread(
            target=worker_task,
            args=(i, 5),
            name=f"Worker-{i}",
            daemon=True
        )
        threads.append(thread)
        
        # 모니터링에 추가
        monitor.add_thread(thread)
    
    # 모니터링 시작
    monitor.start_monitoring()
    
    # 스레드들 시작
    for thread in threads:
        thread.start()
        print(f"  스레드 '{thread.name}' 시작됨")
    
    print("\n2. 실시간 상태 모니터링 (3초간):")
    
    # 3초간 상태 모니터링
    for i in range(6):
        time.sleep(0.5)
        
        # 상태 정보 출력
        status_list = monitor.get_all_threads_status()
        alive_count = sum(1 for s in status_list if s['alive'])
        print(f"  시간 {i*0.5:.1f}초: 활성 스레드 {alive_count}/{len(threads)}개")
        
        # 첫 번째 스레드의 상세 정보
        if status_list:
            first_status = status_list[0]
            print(f"    '{first_status['name']}': CPU {first_status.get('cpu_percent', 0):.1f}%, "
                  f"메모리 {first_status.get('memory_mb', 0):.1f}MB")
    
    print("\n3. 개별 스레드 상세 상태:")
    
    # 각 스레드의 상세 상태 출력
    for i, thread in enumerate(threads):
        status = monitor.get_thread_status(thread.name)
        
        print(f"\n  스레드 {i+1}: {thread.name}")
        print(f"    활성 상태: {status['alive']}")
        print(f"    스레드 ID: {status['ident']}")
        
        if 'cpu_percent' in status:
            print(f"    CPU 사용률: {status['cpu_percent']:.1f}%")
        
        if 'execution_time' in status:
            print(f"    실행 시간: {status['execution_time']:.2f}초")
    
    print("\n4. 워치독 스레드 데모:")
    
    # 워치독 스레드 생성 및 시작
    watchdog = WatchdogThread(threads, check_interval=1.0, max_no_progress_time=2.0)
    watchdog.start()
    
    # 잠시 대기 후 워치독 정지
    time.sleep(2)
    watchdog.stop()
    
    # 모니터링 정지
    monitor.stop_monitoring()
    
    print("\n5. 최종 리포트:")
    final_status = monitor.get_all_threads_status()
    
    for status in final_status:
        name = status['name']
        alive = "활성" if status['alive'] else "비활성"
        
        print(f"  {name}: {alive} 상태")
    
    # 스레드 정리 대기
    for thread in threads:
        thread.join(timeout=1)
    
    print("\n모든 데모 완료")

# 데코레이터 사용 예시
@with_thread_validation(max_execution_time=3.0)
def monitored_task(task_id: int, duration: float):
    """모니터링되는 테스트 작업"""
    logger.info(f"모니터링 작업 {task_id} 시작 (지속시간: {duration}초)")
    time.sleep(duration)
    
    if task_id == 2:  # 작업 2는 의도적으로 지연
        time.sleep(4)
    
    logger.info(f"모니터링 작업 {task_id} 완료")
    return f"Task-{task_id}-Done"

def demonstrate_decorator_monitoring():
    """데코레이터를 이용한 스레드 모니터링 데모"""
    print("\n" + "=" * 60)
    print("데코레이터 기반 스레드 모니터링")
    print("=" * 60)
    
    with ThreadPoolExecutor(max_workers=3) as executor:
        futures = []
        
        # 여러 작업 제출
        for i in range(4):
            future = executor.submit(monitored_task, i, 2.0)
            futures.append(future)
        
        # 결과 수집
        for i, future in enumerate(futures):
            try:
                result = future.result(timeout=5)
                print(f"  작업 {i}: 성공 - {result}")
            except Exception as e:
                print(f"  작업 {i}: 실패 - {e}")

if __name__ == "__main__":
    demonstrate_thread_monitoring()
    demonstrate_decorator_monitoring()
```

## 스레드 간 통신: 데이터 교환과 동기화

스레드 간 안전한 데이터 교환은 멀티스레드 프로그래밍의 핵심이며, 동기화 메커니즘 없이는 데이터 경쟁 조건과 일관성 문제가 발생할 수 있습니다.

### 스레드 안전 통신 시스템 구현

```python
import threading
import time
import queue
import json
import pickle
from typing import Any, Optional, Dict, List, Callable
from dataclasses import dataclass, asdict
from enum import Enum
from collections import defaultdict
import uuid

class MessageType(Enum):
    """메시지 타입 열거형"""
    DATA = "data"
    COMMAND = "command"
    STATUS = "status"
    ERROR = "error"
    HEARTBEAT = "heartbeat"

@dataclass
class ThreadMessage:
    """스레드 간 전송 메시지"""
    message_id: str
    sender: str
    receiver: str
    message_type: MessageType
    payload: Any
    timestamp: float
    priority: int = 0  # 0: 낮음, 1: 보통, 2: 높음
    
    def to_dict(self) -> Dict[str, Any]:
        """딕셔너리로 변환"""
        return {
            'message_id': self.message_id,
            'sender': self.sender,
            'receiver': self.receiver,
            'message_type': self.message_type.value,
            'payload': self.payload,
            'timestamp': self.timestamp,
            'priority': self.priority
        }
    
    def serialize(self) -> bytes:
        """바이트 직렬화"""
        return pickle.dumps(self.to_dict())
    
    @classmethod
    def deserialize(cls, data: bytes) -> 'ThreadMessage':
        """바이트 역직렬화"""
        obj = pickle.loads(data)
        return cls(
            message_id=obj['message_id'],
            sender=obj['sender'],
            receiver=obj['receiver'],
            message_type=MessageType(obj['message_type']),
            payload=obj['payload'],
            timestamp=obj['timestamp'],
            priority=obj['priority']
        )

class ThreadSafeQueue:
    """
    스레드 안전 큐 확장 클래스
    
    우선순위, 타임아웃, 이벤트 알림 기능 추가
    """
    
    def __init__(self, maxsize: int = 0):
        """
        스레드 안전 큐 초기화
        
        Args:
            maxsize: 최대 크기 (0이면 무제한)
        """
        self.queue = queue.PriorityQueue(maxsize=maxsize)
        self.put_event = threading.Event()
        self.get_event = threading.Event()
        self.lock = threading.RLock()
        self.stats = {
            'puts': 0,
            'gets': 0,
            'timeouts': 0,
            'errors': 0
        }
    
    def put(self, item: Any, priority: int = 0, block: bool = True, timeout: Optional[float] = None):
        """
        아이템 추가 (우선순위 지원)
        
        Args:
            item: 추가할 아이템
            priority: 우선순위 (높을수록 우선)
            block: 블로킹 여부
            timeout: 타임아웃 (초)
        """
        try:
            # 우선순위 큐는 작은 값이 먼저 나오므로 우선순위를 음수로 변환
            self.queue.put((-priority, time.time(), item), block, timeout)
            
            with self.lock:
                self.stats['puts'] += 1
            
            # 대기 중인 소비자에게 알림
            self.put_event.set()
            self.put_event.clear()  # 즉시 초기화
            
            return True
        except queue.Full:
            with self.lock:
                self.stats['errors'] += 1
            return False
    
    def get(self, block: bool = True, timeout: Optional[float] = None) -> Optional[Any]:
        """
        아이템 가져오기
        
        Args:
            block: 블로킹 여부
            timeout: 타임아웃 (초)
        
        Returns:
            아이템 또는 None (타임아웃 시)
        """
        try:
            priority, timestamp, item = self.queue.get(block, timeout)
            
            with self.lock:
                self.stats['gets'] += 1
            
            # 생산자에게 큐에 공간이 생겼음을 알림
            if self.queue.qsize() < self.queue.maxsize or self.queue.maxsize == 0:
                self.get_event.set()
                self.get_event.clear()
            
            return item
        except queue.Empty:
            with self.lock:
                self.stats['timeouts'] += 1
            return None
    
    def qsize(self) -> int:
        """현재 큐 크기 반환"""
        return self.queue.qsize()
    
    def empty(self) -> bool:
        """큐가 비었는지 확인"""
        return self.queue.empty()
    
    def full(self) -> bool:
        """큐가 가득 찼는지 확인"""
        return self.queue.full()
    
    def wait_for_item(self, timeout: Optional[float] = None) -> bool:
        """
        아이템이 들어올 때까지 대기
        
        Returns:
            아이템 존재 여부
        """
        return self.put_event.wait(timeout)
    
    def wait_for_space(self, timeout: Optional[float] = None) -> bool:
        """
        큐에 공간이 생길 때까지 대기
        
        Returns:
            공간 존재 여부
        """
        return self.get_event.wait(timeout)
    
    def get_stats(self) -> Dict[str, int]:
        """통계 정보 반환"""
        with self.lock:
            stats = self.stats.copy()
            stats['current_size'] = self.qsize()
            return stats
    
    def clear(self):
        """큐 비우기"""
        while not self.queue.empty():
            try:
                self.queue.get_nowait()
            except queue.Empty:
                break

class MessageBroker:
    """
    스레드 간 메시지 브로커
    
    다대다 통신 패턴 지원
    """
    
    def __init__(self):
        """
        메시지 브로커 초기화
        """
        self.queues: Dict[str, ThreadSafeQueue] = {}
        self.subscriptions: Dict[str, List[str]] = defaultdict(list)
        self.routing_table: Dict[str, Callable] = {}
        self.lock = threading.RLock()
        self.running = False
        self.broker_thread: Optional[threading.Thread] = None
        
        # 메시지 통계
        self.message_stats = {
            'sent': 0,
            'delivered': 0,
            'failed': 0,
            'routed': 0
        }
        
        logger.info("메시지 브로커 초기화됨")
    
    def register_thread(self, thread_name: str, queue_size: int = 100):
        """
        스레드 등록 (고유한 큐 생성)
        
        Args:
            thread_name: 스레드 이름
            queue_size: 메시지 큐 크기
        """
        with self.lock:
            if thread_name not in self.queues:
                self.queues[thread_name] = ThreadSafeQueue(maxsize=queue_size)
                logger.info(f"스레드 '{thread_name}'가 브로커에 등록됨")
                return True
            else:
                logger.warning(f"스레드 '{thread_name}'는 이미 등록되어 있습니다.")
                return False
    
    def unregister_thread(self, thread_name: str):
        """스레드 등록 해제"""
        with self.lock:
            if thread_name in self.queues:
                del self.queues[thread_name]
                
                # 구독 정보 정리
                for topic, subscribers in self.subscriptions.items():
                    if thread_name in subscribers:
                        subscribers.remove(thread_name)
                
                logger.info(f"스레드 '{thread_name}'가 브로커에서 제거됨")
    
    def subscribe(self, thread_name: str, topic: str):
        """
        토픽 구독
        
        Args:
            thread_name: 구독할 스레드 이름
            topic: 구독할 토픽
        """
        with self.lock:
            if thread_name not in self.queues:
                logger.error(f"구독 실패: 스레드 '{thread_name}'가 등록되지 않았습니다.")
                return False
            
            if thread_name not in self.subscriptions[topic]:
                self.subscriptions[topic].append(thread_name)
                logger.info(f"스레드 '{thread_name}'가 토픽 '{topic}' 구독 시작")
                return True
        
        return False
    
    def unsubscribe(self, thread_name: str, topic: str):
        """토픽 구독 해제"""
        with self.lock:
            if topic in self.subscriptions and thread_name in self.subscriptions[topic]:
                self.subscriptions[topic].remove(thread_name)
                logger.info(f"스레드 '{thread_name}'가 토픽 '{topic}' 구독 해제")
                return True
        
        return False
    
    def send_message(self, 
                    sender: str, 
                    receiver: str, 
                    payload: Any,
                    message_type: MessageType = MessageType.DATA,
                    priority: int = 0) -> str:
        """
        직접 메시지 전송
        
        Args:
            sender: 발신자 스레드 이름
            receiver: 수신자 스레드 이름
            payload: 메시지 내용
            message_type: 메시지 타입
            priority: 우선순위
        
        Returns:
            메시지 ID
        """
        message_id = str(uuid.uuid4())
        message = ThreadMessage(
            message_id=message_id,
            sender=sender,
            receiver=receiver,
            message_type=message_type,
            payload=payload,
            timestamp=time.time(),
            priority=priority
        )
        
        with self.lock:
            if receiver in self.queues:
                if self.queues[receiver].put(message, priority=priority):
                    self.message_stats['sent'] += 1
                    logger.debug(f"메시지 전송: {sender} -> {receiver} (ID: {message_id})")
                    return message_id
                else:
                    self.message_stats['failed'] += 1
                    logger.error(f"메시지 전송 실패: {sender} -> {receiver} (큐 가득 참)")
                    return ""
            else:
                logger.error(f"메시지 전송 실패: 수신자 '{receiver}'를 찾을 수 없습니다.")
                self.message_stats['failed'] += 1
                return ""
    
    def publish(self, sender: str, topic: str, payload: Any, priority: int = 0) -> List[str]:
        """
        토픽 발행 (구독자 모두에게 전송)
        
        Args:
            sender: 발신자
            topic: 토픽
            payload: 메시지 내용
            priority: 우선순위
        
        Returns:
            성공적으로 전송된 메시지 ID 목록
        """
        message_ids = []
        
        with self.lock:
            if topic in self.subscriptions:
                subscribers = self.subscriptions[topic].copy()
                
                for subscriber in subscribers:
                    message_id = self.send_message(
                        sender, 
                        subscriber, 
                        payload, 
                        MessageType.DATA, 
                        priority
                    )
                    
                    if message_id:
                        message_ids.append(message_id)
                        self.message_stats['routed'] += 1
        
        return message_ids
    
    def receive_message(self, 
                       thread_name: str, 
                       block: bool = True, 
                       timeout: Optional[float] = None) -> Optional[ThreadMessage]:
        """
        메시지 수신
        
        Args:
            thread_name: 수신할 스레드 이름
            block: 블로킹 여부
            timeout: 타임아웃 (초)
        
        Returns:
            수신된 메시지 또는 None
        """
        with self.lock:
            if thread_name not in self.queues:
                logger.error(f"메시지 수신 실패: 스레드 '{thread_name}'가 등록되지 않았습니다.")
                return None
            
            queue = self.queues[thread_name]
            message = queue.get(block, timeout)
            
            if message:
                self.message_stats['delivered'] += 1
            
            return message
    
    def start_broker(self):
        """브로커 서비스 시작"""
        if self.running:
            logger.warning("브로커가 이미 실행 중입니다.")
            return
        
        self.running = True
        self.broker_thread = threading.Thread(
            target=self._broker_loop,
            name="MessageBroker",
            daemon=True
        )
        self.broker_thread.start()
        logger.info("메시지 브로커 서비스 시작됨")
    
    def stop_broker(self):
        """브로커 서비스 중지"""
        self.running = False
        
        if self.broker_thread:
            self.broker_thread.join(timeout=2)
            logger.info("메시지 브로커 서비스 중지됨")
    
    def _broker_loop(self):
        """브로커 메인 처리 루프"""
        while self.running:
            # 브로커 관리 작업 수행
            # (예: 데드레터 큐 처리, 통계 수집, 상태 모니터링)
            
            time.sleep(1)  # CPU 점유 방지
    
    def get_stats(self) -> Dict[str, Any]:
        """브로커 통계 정보 반환"""
        with self.lock:
            stats = {
                'message_stats': self.message_stats.copy(),
                'registered_threads': len(self.queues),
                'active_subscriptions': sum(len(subs) for subs in self.subscriptions.values()),
                'queue_sizes': {name: q.qsize() for name, q in self.queues.items()}
            }
            
            # 개별 큐 통계 추가
            queue_stats = {}
            for name, q in self.queues.items():
                queue_stats[name] = q.get_stats()
            
            stats['queue_stats'] = queue_stats
            
            return stats

# 공유 자원 관리자
class SharedResourceManager:
    """
    스레드 간 공유 자원 안전 관리
    """
    
    def __init__(self):
        self.resources: Dict[str, Any] = {}
        self.locks: Dict[str, threading.RLock] = {}
        self.conditions: Dict[str, threading.Condition] = {}
        self.semaphores: Dict[str, threading.Semaphore] = {}
    
    def register_resource(self, name: str, initial_value: Any = None):
        """
        공유 자원 등록
        
        Args:
            name: 자원 이름
            initial_value: 초기값
        """
        if name not in self.resources:
            self.resources[name] = initial_value
            self.locks[name] = threading.RLock()
            self.conditions[name] = threading.Condition(self.locks[name])
            logger.info(f"공유 자원 '{name}' 등록됨")
    
    def get(self, name: str, timeout: Optional[float] = None) -> Optional[Any]:
        """
        자원 값 가져오기 (락 획득)
        
        Args:
            name: 자원 이름
            timeout: 락 획득 타임아웃
        
        Returns:
            자원 값 또는 None
        """
        if name not in self.locks:
            logger.error(f"자원 '{name}'가 등록되지 않았습니다.")
            return None
        
        lock = self.locks[name]
        
        if lock.acquire(timeout=timeout):
            try:
                return self.resources[name]
            finally:
                lock.release()
        
        return None
    
    def set(self, name: str, value: Any, timeout: Optional[float] = None) -> bool:
        """
        자원 값 설정 (락 획득)
        
        Args:
            name: 자원 이름
            value: 설정할 값
            timeout: 락 획득 타임아웃
        
        Returns:
            설정 성공 여부
        """
        if name not in self.locks:
            logger.error(f"자원 '{name}'가 등록되지 않았습니다.")
            return False
        
        lock = self.locks[name]
        
        if lock.acquire(timeout=timeout):
            try:
                self.resources[name] = value
                return True
            finally:
                lock.release()
        
        return False
    
    def update(self, name: str, update_func: Callable, timeout: Optional[float] = None) -> bool:
        """
        자원 값 업데이트 (원자적 연산)
        
        Args:
            name: 자원 이름
            update_func: 업데이트 함수 (현재 값을 받아 새 값 반환)
            timeout: 락 획득 타임아웃
        
        Returns:
            업데이트 성공 여부
        """
        if name not in self.locks:
            logger.error(f"자원 '{name}'가 등록되지 않았습니다.")
            return False
        
        lock = self.locks[name]
        
        if lock.acquire(timeout=timeout):
            try:
                current = self.resources[name]
                self.resources[name] = update_func(current)
                return True
            finally:
                lock.release()
        
        return False
    
    def wait_for_condition(self, 
                          name: str, 
                          condition_func: Callable,
                          timeout: Optional[float] = None) -> bool:
        """
        조건 만족 대기
        
        Args:
            name: 자원 이름
            condition_func: 조건 함수 (자원 값 받아 bool 반환)
            timeout: 대기 타임아웃
        
        Returns:
            조건 만족 여부
        """
        if name not in self.conditions:
            logger.error(f"자원 '{name}'가 등록되지 않았습니다.")
            return False
        
        condition = self.conditions[name]
        
        with condition:
            if timeout:
                # 타임아웃이 있는 조건 대기
                result = condition.wait_for(
                    lambda: condition_func(self.resources[name]), 
                    timeout
                )
                return result
            else:
                # 무한 대기
                while not condition_func(self.resources[name]):
                    condition.wait()
                return True
    
    def notify_all(self, name: str):
        """
        모든 대기 중인 스레드에 알림
        """
        if name in self.conditions:
            with self.conditions[name]:
                self.conditions[name].notify_all()
            logger.debug(f"자원 '{name}': 모든 대기 스레드에 알림")

# 데모: 스레드 간 통신
def demonstrate_thread_communication():
    """
    스레드 간 통신 시스템 데모
    """
    print("=" * 60)
    print("스레드 간 통신 시스템 데모")
    print("=" * 60)
    
    # 메시지 브로커 생성
    broker = MessageBroker()
    broker.start_broker()
    
    # 공유 자원 관리자 생성
    resource_manager = SharedResourceManager()
    resource_manager.register_resource("counter", 0)
    resource_manager.register_resource("data_store", [])
    
    # 생산자 스레드 함수
    def producer_thread(thread_name: str, item_count: int):
        """생산자 스레드"""
        broker.register_thread(thread_name)
        
        logger.info(f"생산자 '{thread_name}' 시작 (생산 항목: {item_count}개)")
        
        for i in range(item_count):
            # 메시지 생성
            message = f"Item-{i}-from-{thread_name}"
            
            # 브로커를 통해 메시지 전송
            message_id = broker.send_message(
                sender=thread_name,
                receiver="consumer",
                payload=message,
                priority=1 if i % 3 == 0 else 0  # 3번째마다 높은 우선순위
            )
            
            if message_id:
                logger.debug(f"생산자 '{thread_name}': 메시지 전송 - {message}")
            
            # 공유 자원 업데이트
            resource_manager.update(
                "counter",
                lambda x: x + 1,
                timeout=1.0
            )
            
            time.sleep(0.1)  # 생산 속도 제한
        
        logger.info(f"생산자 '{thread_name}' 완료")
        broker.send_message(
            thread_name,
            "consumer",
            f"{thread_name} 완료",
            MessageType.STATUS
        )
    
    # 소비자 스레드 함수
    def consumer_thread(thread_name: str):
        """소비자 스레드"""
        broker.register_thread(thread_name)
        
        # 토픽 구독
        broker.subscribe(thread_name, "broadcast")
        
        logger.info(f"소비자 '{thread_name}' 시작")
        
        received_count = 0
        running = True
        
        while running:
            # 메시지 수신 (최대 1초 대기)
            message = broker.receive_message(thread_name, timeout=1.0)
            
            if message:
                received_count += 1
                
                logger.info(f"소비자 '{thread_name}': 메시지 수신 "
                           f"({message.sender} -> {message.receiver}): "
                           f"{message.payload}")
                
                # 상태 메시지 처리
                if message.message_type == MessageType.STATUS:
                    if "완료" in str(message.payload):
                        logger.info(f"소비자 '{thread_name}': "
                                   f"생산자 {message.sender} 작업 완료 알림 수신")
                
                # 공유 자원에 데이터 저장
                resource_manager.update(
                    "data_store",
                    lambda store: store + [{
                        'from': message.sender,
                        'message': message.payload,
                        'time': time.time()
                    }],
                    timeout=1.0
                )
            
            # 종료 조건 확인 (예: 특정 개수 이상 수신)
            if received_count >= 15:
                running = False
        
        logger.info(f"소비자 '{thread_name}' 종료 (총 수신: {received_count}개)")
    
    # 브로드캐스트 스레드 함수
    def broadcaster_thread(thread_name: str):
        """브로드캐스트 스레드"""
        broker.register_thread(thread_name)
        
        logger.info(f"브로드캐스트 '{thread_name}' 시작")
        
        for i in range(5):
            # 토픽 발행
            message = f"Broadcast-Message-{i}"
            message_ids = broker.publish(
                sender=thread_name,
                topic="broadcast",
                payload=message
            )
            
            logger.info(f"브로드캐스트 '{thread_name}': "
                       f"토픽 발행 '{message}' -> {len(message_ids)}명 구독자")
            
            time.sleep(0.5)
        
        logger.info(f"브로드캐스트 '{thread_name}' 완료")
    
    print("\n1. 스레드들 생성 및 등록:")
    
    # 스레드들 생성
    threads = []
    
    # 소비자 스레드
    consumer = threading.Thread(
        target=consumer_thread,
        args=("consumer",),
        name="consumer",
        daemon=True
    )
    threads.append(consumer)
    
    # 생산자 스레드들
    for i in range(3):
        producer = threading.Thread(
            target=producer_thread,
            args=(f"producer-{i}", 5),
            name=f"producer-{i}",
            daemon=True
        )
        threads.append(producer)
    
    # 브로드캐스트 스레드
    broadcaster = threading.Thread(
        target=broadcaster_thread,
        args=("broadcaster",),
        name="broadcaster",
        daemon=True
    )
    threads.append(broadcaster)
    
    print(f"  총 {len(threads)}개의 스레드 생성됨")
    
    print("\n2. 스레드들 시작:")
    
    # 모든 스레드 시작
    for thread in threads:
        thread.start()
        print(f"  스레드 '{thread.name}' 시작됨")
    
    print("\n3. 통신 진행 상황 모니터링:")
    
    # 5초간 통신 모니터링
    for i in range(10):
        time.sleep(0.5)
        
        # 브로커 통계 출력
        stats = broker.get_stats()
        sent = stats['message_stats']['sent']
        delivered = stats['message_stats']['delivered']
        
        # 공유 자원 상태 확인
        counter = resource_manager.get("counter", timeout=0.1)
        data_store_size = len(resource_manager.get("data_store", timeout=0.1) or [])
        
        print(f"  시간 {i*0.5:.1f}초: "
              f"전송 {sent}개, 수신 {delivered}개, "
              f"카운터 {counter}, 데이터 {data_store_size}개")
    
    print("\n4. 스레드 종료 대기:")
    
    # 스레드들 종료 대기 (제한 시간)
    for thread in threads:
        thread.join(timeout=2)
        if thread.is_alive():
            print(f"  스레드 '{thread.name}': 타임아웃 후 강제 종료")
        else:
            print(f"  스레드 '{thread.name}': 정상 종료")
    
    print("\n5. 최종 통계:")
    
    # 최종 통계 출력
    final_stats = broker.get_stats()
    
    print(f"  총 메시지 전송: {final_stats['message_stats']['sent']}")
    print(f"  총 메시지 수신: {final_stats['message_stats']['delivered']}")
    print(f"  메시지 전송 실패: {final_stats['message_stats']['failed']}")
    print(f"  라우팅된 메시지: {final_stats['message_stats']['routed']}")
    
    print(f"  등록된 스레드 수: {final_stats['registered_threads']}")
    print(f"  활성 구독 수: {final_stats['active_subscriptions']}")
    
    # 공유 자원 최종 상태
    final_counter = resource_manager.get("counter", timeout=0.1)
    final_data = resource_manager.get("data_store", timeout=0.1)
    
    print(f"\n  공유 카운터 최종값: {final_counter}")
    print(f"  저장된 데이터 개수: {len(final_data) if final_data else 0}")
    
    # 브로커 정지
    broker.stop_broker()
    
    print("\n통신 데모 완료")

# 조건 변수와 이벤트를 활용한 고급 동기화
def demonstrate_advanced_synchronization():
    """
    고급 동기화 메커니즘 데모
    """
    print("\n" + "=" * 60)
    print("고급 동기화 메커니즘")
    print("=" * 60)
    
    class TaskCoordinator:
        """작업 조정자 (생산자-소비자 패턴)"""
        
        def __init__(self, buffer_size: int = 5):
            self.buffer = []
            self.buffer_size = buffer_size
            self.lock = threading.RLock()
            self.not_empty = threading.Condition(self.lock)
            self.not_full = threading.Condition(self.lock)
            self.producers_done = 0
            self.total_producers = 0
        
        def add_producer(self):
            """생산자 등록"""
            with self.lock:
                self.total_producers += 1
        
        def producer_done(self):
            """생산자 완료 알림"""
            with self.lock:
                self.producers_done += 1
                self.not_empty.notify_all()  # 대기 중인 소비자 깨우기
        
        def put(self, item):
            """아이템 추가 (버퍼가 가득 차면 대기)"""
            with self.not_full:
                while len(self.buffer) >= self.buffer_size:
                    self.not_full.wait()
                
                self.buffer.append(item)
                print(f"  생산자: 아이템 '{item}' 추가 (버퍼: {len(self.buffer)}/{self.buffer_size})")
                
                # 대기 중인 소비자 알림
                self.not_empty.notify()
        
        def get(self) -> Optional[Any]:
            """아이템 가져오기 (버퍼가 비면 대기)"""
            with self.not_empty:
                while len(self.buffer) == 0:
                    # 모든 생산자가 완료되었는지 확인
                    if self.producers_done >= self.total_producers:
                        return None
                    self.not_empty.wait()
                
                item = self.buffer.pop(0)
                print(f"  소비자: 아이템 '{item}' 가져옴 (버퍼: {len(self.buffer)}/{self.buffer_size})")
                
                # 대기 중인 생산자 알림
                self.not_full.notify()
                
                return item
    
    # 조정자 생성
    coordinator = TaskCoordinator(buffer_size=3)
    
    # 생산자 함수
    def producer(coordinator: TaskCoordinator, producer_id: int, items: list):
        """생산자 스레드"""
        coordinator.add_producer()
        
        for item in items:
            coordinator.put(f"P{producer_id}-{item}")
            time.sleep(0.1)  # 생산 시간 시뮬레이션
        
        coordinator.producer_done()
        print(f"생산자 {producer_id}: 완료")
    
    # 소비자 함수
    def consumer(coordinator: TaskCoordinator, consumer_id: int):
        """소비자 스레드"""
        consumed = []
        
        while True:
            item = coordinator.get()
            
            if item is None:
                break
            
            consumed.append(item)
            time.sleep(0.15)  # 소비 시간 시뮬레이션
        
        print(f"소비자 {consumer_id}: {len(consumed)}개 아이템 소비 완료")
        return consumed
    
    print("\n1. 생산자-소비자 패턴 시작:")
    
    # 스레드 생성
    producer_threads = []
    
    # 3개의 생산자
    for i in range(3):
        thread = threading.Thread(
            target=producer,
            args=(coordinator, i, [f"Item{j}" for j in range(3)]),
            name=f"Producer-{i}",
            daemon=True
        )
        producer_threads.append(thread)
    
    # 2개의 소비자
    consumer_threads = []
    
    for i in range(2):
        thread = threading.Thread(
            target=consumer,
            args=(coordinator, i),
            name=f"Consumer-{i}",
            daemon=True
        )
        consumer_threads.append(thread)
    
    print(f"  생산자: {len(producer_threads)}개, 소비자: {len(consumer_threads)}개")
    
    print("\n2. 스레드 실행:")
    
    # 소비자 먼저 시작
    for thread in consumer_threads:
        thread.start()
    
    # 생산자 시작
    for thread in producer_threads:
        thread.start()
    
    print("\n3. 진행 상황:")
    
    # 진행 상황 모니터링
    for i in range(5):
        time.sleep(0.5)
        
        with coordinator.lock:
            buffer_size = len(coordinator.buffer)
        
        print(f"  시간 {i*0.5:.1f}초: 버퍼 {buffer_size}/{coordinator.buffer_size}")
    
    print("\n4. 종료 대기:")
    
    # 생산자 종료 대기
    for thread in producer_threads:
        thread.join(timeout=1)
    
    # 소비자 종료 대기
    for thread in consumer_threads:
        thread.join(timeout=1)
    
    print("\n동기화 데모 완료")

if __name__ == "__main__":
    demonstrate_thread_communication()
    demonstrate_advanced_synchronization()
```

## 결론

파이썬의 스레드 프로그래밍은 `threading` 모듈을 중심으로 GIL의 제약 내에서 효과적인 동시성 처리를 가능하게 합니다. 스레드의 안전한 시작과 정지, 정확한 상태 판단, 효율적인 스레드 간 통신은 견고한 멀티스레드 애플리케이션을 구축하기 위한 필수 요소입니다.

**스레드 시작과 정지**에서는 `ManagedThread` 클래스를 통해 생명주기 관리를 체계화할 수 있습니다. 안전한 시작(`safe_start`)과 정지(`safe_stop`) 메커니즘, 상태 추적(`ThreadStatus`), 오류 처리, 실행 시간 모니터링 등의 기능을 포함시켜 스레드 관리를 강화했습니다. 스레드 풀 패턴을 구현한 `ThreadPoolManager`는 리소스 관리를 효율적으로 해줍니다.

**스레드 상태 판단**은 단순히 `is_alive()` 메서드 이상의 정교한 접근이 필요합니다. `ThreadMonitor` 클래스는 CPU/메모리 사용률, 실행 시간, 데드락 감지 등의 고급 메트릭스를 제공합니다. 데코레이터 패턴(`@with_thread_validation`)을 활용하면 함수 수준에서 실행 시간 제한과 오류 처리를 일관되게 적용할 수 있습니다. 워치독 스레드는 다른 스레드들의 건강 상태를 지속적으로 감시하는 패턴을 보여줍니다.

**스레드 간 통신**은 데이터 무결성과 동기화를 보장해야 합니다. `ThreadSafeQueue`는 우선순위 큐와 이벤트 알림 기능을 추가한 안전한 큐 구현입니다. `MessageBroker` 패턴은 중앙 집중식 메시징 시스템으로 토픽 기반 발행-구독 모델을 지원합니다. `SharedResourceManager`는 공유 자원에 대한 동기화된 접근을 제공하며, 조건 변수를 활용한 고급 대기 메커니즘을 포함합니다.

실전 적용 시 고려해야 할 핵심 사항:

1. **GIL 이해**: CPU 바운드 작업에는 멀티프로세싱(`multiprocessing`) 고려
2. **데드락 방지**: 락 획득 순서 통일, 타임아웃 설정, 데드락 감지 구현
3. **리소스 관리**: 스레드 풀 사용, 메모리 누수 방지, 적절한 정리(cleanup)
4. **오류 처리**: 스레드 내 예외 전파, 오류 로깅, 복구 메커니즘
5. **성능 모니터링**: 실행 통계 수집, 병목 현상 분석, 성능 프로파일링
6. **테스트 전략**: 동시성 버그 탐지를 위한 스트레스 테스트, 레이스 컨디션 검증

이러한 패턴과 기법들을 조합하면 확장성 있고 안정적인 파이썬 멀티스레드 애플리케이션을 구축할 수 있습니다. 특히 I/O 바운드 작업(네트워크, 파일, 데이터베이스)이 많은 애플리케이션에서 스레드는 성능 향상을 위한 강력한 도구가 됩니다.