---
layout: post
title: Spring - 파일·이미지·대용량 처리
date: 2025-10-16 21:25:23 +0900
category: Spring
---
# 15. 파일·이미지·대용량 처리 — 멀티파트·썸네일 파이프라인·대용량 다운로드/Resume·S3/GCS·CDN

> 목표: **안전하고 빠른 업로드/다운로드**, **이미지 파이프라인(썸네일/변환)**, **대용량/범위 요청(Resume)**, **S3/GCS 연동**과 **CDN 캐싱 전략**까지 실전에 필요한 모든 조각을 “끝에서 끝까지” 엮는다.  
> 전제: Spring Boot 3.3+, Java 21 기준. 예제는 MVC(서블릿) 중심으로 보여 주되, WebFlux 시나리오도 함께 짚는다.

---

## A. 업로드(멀티파트) — 안전·검증·저장 구조

### A-1. 아키텍처 개요
1) **수신 계층**: 멀티파트 요청 수신(파일/메타 파라미터).  
2) **검증**: 사이즈/확장자/콘텐츠타입 **양면 검증**(헤더+실제 바이너리).  
3) **보안**: 경로 탈출(path traversal)·특수 확장자 차단, **악성 스크립트 업로드 방지**.  
4) **저장**:  
   - 로컬(임시) → 이미지 파이프라인 → 영구 저장소(S3/GCS/네트워크 파일시스템).  
   - 또는 **바이패스 업로드(Pre-signed URL)**로 서버 우회.  
5) **메타데이터 DB**: id, 원본명, MIME, 크기, 해시, 저장 위치, 생성자/권한.  
6) **후처리**: 썸네일 생성, AVIF/WebP 변환, EXIF 제거, 바이러스 스캔.

### A-2. multipart 설정
```yaml
spring:
  servlet:
    multipart:
      max-file-size: 100MB
      max-request-size: 120MB
      resolve-lazily: true        # 파라미터 접근 시에만 파싱 (DoS 완화)
server:
  tomcat:
    max-swallow-size: -1          # 대용량 안정성 (기본 제한 제거)
```

### A-3. DTO/컨트롤러(단건/다건)
```java
@RestController
@RequestMapping("/files")
@RequiredArgsConstructor
class FileUploadController {

  private final FileService fileService;

  @PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
  public ResponseEntity<FileResponse> upload(
      @RequestPart("file") MultipartFile file,
      @RequestParam(required = false) String folder,
      UriComponentsBuilder uri) throws IOException {

    var saved = fileService.store(file, folder);
    var location = uri.path("/files/{id}").buildAndExpand(saved.id()).toUri();
    return ResponseEntity.created(location).body(saved);
  }

  @PostMapping(path="/bulk", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
  public List<FileResponse> uploadMany(@RequestPart("files") List<MultipartFile> files,
                                       @RequestParam(required = false) String folder) {
    return files.stream().map(f -> fileService.store(f, folder)).toList();
  }
}
```

### A-4. 검증/식별: 확장자 + **Tika**로 MIME 탐지 + 크기/제한
```kotlin
dependencies {
  implementation("org.apache.tika:tika-core:2.9.0")
}
```

```java
@Service
@RequiredArgsConstructor
class FileService {
  private static final Set<String> ALLOW = Set.of("image/jpeg","image/png","image/webp","application/pdf");
  private final Tika tika = new Tika();
  private final Path root = Path.of("/data/uploads");

  public FileResponse store(MultipartFile mf, String folder) {
    if (mf.isEmpty()) throw new IllegalArgumentException("Empty file");
    if (mf.getSize() > 100 * 1024 * 1024) throw new IllegalArgumentException("Too large");

    // 1) 컨텐츠 스니핑(Tika)
    String detected = detect(mf);
    if (!ALLOW.contains(detected)) throw new IllegalArgumentException("Unsupported type: " + detected);

    // 2) 파일명 정규화 (경로 탈출 방지)
    String safeName = sanitize(mf.getOriginalFilename());

    // 3) 저장 경로
    String ymd = DateTimeFormatter.ofPattern("yyyy/MM/dd").format(LocalDate.now());
    Path dir = root.resolve(Optional.ofNullable(folder).orElse("default")).resolve(ymd);
    try { Files.createDirectories(dir); } catch (IOException ignore) {}
    // 4) 고유 ID + 확장자
    String ext = extensionByMime(detected); // jpg/png/webp/pdf…
    String id = UUID.randomUUID().toString().replace("-", "");
    Path path = dir.resolve(id + (ext.isEmpty() ? "" : "." + ext));

    // 5) 스트리밍 저장 + 해시
    String sha256;
    try (var in = mf.getInputStream();
         var th = new DigestInputStream(in, MessageDigest.getInstance("SHA-256"))) {
      Files.copy(th, path, StandardCopyOption.REPLACE_EXISTING);
      sha256 = HexFormat.of().formatHex(th.getMessageDigest().digest());
    } catch (Exception e) { throw new UncheckedIOException(e instanceof IOException ? (IOException)e : new IOException(e)); }

    return new FileResponse(id, safeName, detected, mf.getSize(), sha256,
      path.toString(), Instant.now());
  }

  private String detect(MultipartFile mf) {
    try (var in = mf.getInputStream()) { return tika.detect(in, mf.getOriginalFilename()); }
    catch (IOException e) { throw new UncheckedIOException(e); }
  }
  private String sanitize(String name) {
    if (name == null) return "unknown";
    String n = name.replace("\\", "/");
    n = n.substring(n.lastIndexOf('/') + 1);
    n = n.replaceAll("[\\r\\n]", "").replaceAll("[^\\w.\\- ]","_");
    return n.length() > 200 ? n.substring(n.length()-200) : n;
  }
  private String extensionByMime(String mime) {
    return switch (mime) {
      case "image/jpeg" -> "jpg";
      case "image/png"  -> "png";
      case "image/webp" -> "webp";
      case "application/pdf" -> "pdf";
      default -> "";
    };
  }
}
```

> 팁  
> - **헤더 기반 content-type**만 믿지 말고 **바이너리 탐지**까지 반드시 수행.  
> - 파일 저장과 동시에 **SHA-256**을 계산해 **무결성·중복 제거**에 활용.  
> - 악성 SVG/HTML 업로드 후 **임의 실행** 방지: “**다운로드 전용**” 경로에서 **`Content-Disposition: attachment`** 사용(아래 C-3 참고).

---

## B. 이미지 파이프라인 — 썸네일/포맷 변환/메타 제거

### B-1. 파이프라인 설계
- **입력**: 원본 이미지(최대 크기 제한)  
- **전처리**: EXIF 제거(개인 정보), sRGB 변환, 회전 자동 교정(Orientation)  
- **변환**: 목표 사이즈 묶음(예: 128, 512, 1024), 포맷(WebP/AVIF/JPEG)  
- **출력**: 스토리지(경로 규약: `{id}/{variant}.{ext}`) + 메타 DB 업데이트  
- **동기/비동기**: 업로드 응답은 “원본 저장”까지만, **썸네일은 비동기**(@Async/Kafka/RabbitMQ/배치)

### B-2. 라이브러리 선택
- **Thumbnailator**(간단·빠름) 또는 **imgscalr**.  
- 고급 포맷(WebP/AVIF)은 **TwelveMonkeys ImageIO** + 별도 플러그인(또는 네이티브 도구) 필요.  
- 품질/색상 관리가 중요하면 **ImageMagick/GraphicsMagick** 래퍼(외부 프로세스) 고려.

Gradle:
```kotlin
dependencies {
  implementation("net.coobird:thumbnailator:0.4.20")
  implementation("com.twelvemonkeys.imageio:imageio-jpeg:3.10.1")
  implementation("com.twelvemonkeys.imageio:imageio-webp:3.10.1") // WebP plugin
}
```

### B-3. 썸네일 생성기(동기 예제)
```java
@Component
class ImageVariants {

  record Variant(int max, String suffix, float quality, String format) {}

  private static final List<Variant> VARIANTS = List.of(
    new Variant(128,  "_s", 0.8f, "webp"),
    new Variant(512,  "_m", 0.85f, "webp"),
    new Variant(1024, "_l", 0.9f, "jpeg")
  );

  public List<Path> generate(Path source) {
    try {
      BufferedImage src = ImageIO.read(source.toFile());
      if (src == null) throw new IllegalArgumentException("Not an image");

      String base = stripExt(source.getFileName().toString());
      Path dir = source.getParent();
      List<Path> outs = new ArrayList<>();

      for (Variant v : VARIANTS) {
        var out = dir.resolve(base + v.suffix + "." + v.format);
        Thumbnails.of(src)
          .size(v.max, v.max)
          .outputQuality(v.quality)
          .outputFormat(v.format)
          .toFile(out.toFile());
        outs.add(out);
      }
      return outs;
    } catch (IOException e) { throw new UncheckedIOException(e); }
  }

  private String stripExt(String n) {
    int i = n.lastIndexOf('.');
    return i > -1 ? n.substring(0, i) : n;
  }
}
```

> 운영 팁  
> - **색공간**(CMYK → sRGB) 변환이 필요할 수 있다. JPEG CMYK는 브라우저 표시 이슈. TwelveMonkeys가 어느 정도 커버.  
> - **EXIF 제거**: Thumbnailator는 보존 안 함(대체로 안전). 필요 시 메타 제거 전용 단계 추가.

### B-4. 비동기 파이프라인(@Async/브로커)
```java
@Service
@RequiredArgsConstructor
class AsyncImagePipeline {

  private final ImageVariants variants;

  @Async("appExecutor")
  public CompletableFuture<Void> run(Path source) {
    variants.generate(source);
    return CompletableFuture.completedFuture(null);
  }
}
```

업로드 서비스에서:
```java
var saved = fileService.store(file, folder);
if (saved.contentType().startsWith("image/")) {
  asyncImagePipeline.run(Path.of(saved.localPath()));
}
```

> 대량 처리/고가용성은 **Kafka/RabbitMQ 작업 큐**로 분리하고, 컨슈머가 원본 경로를 입력받아 처리하도록 설계.

---

## C. 다운로드 — Content-Disposition, 캐시, **Range/Resume(206)**

### C-1. 기본 다운로드(attachment)
```java
@GetMapping("/files/{id}")
public ResponseEntity<Resource> download(@PathVariable String id) throws IOException {
  FileMeta meta = metaService.get(id);                       // DB 조회
  Path path = Path.of(meta.localPath());
  if (!Files.exists(path)) throw new FileNotFoundException();

  var res = new FileSystemResource(path);
  String encoded = URLEncoder.encode(meta.originalName(), StandardCharsets.UTF_8).replace("+","%20");
  return ResponseEntity.ok()
    .contentType(MediaType.parseMediaType(meta.contentType()))
    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename*=UTF-8''" + encoded)
    .cacheControl(CacheControl.maxAge(Duration.ofDays(30)).cachePublic())
    .eTag("\"" + meta.sha256().substring(0,16) + "\"")       // 약식 ETag
    .body(res);
}
```

> **ETag/Cache-Control**을 적극 활용하면 CDN/브라우저가 **304 Not Modified**로 대역폭을 절약.

### C-2. **Range 요청** 지원(Resume/시킹)
- 요청 헤더: `Range: bytes=START-END`  
- 응답: `206 Partial Content` + `Content-Range`, `Accept-Ranges: bytes`

Spring MVC(서블릿) — `ResourceRegion`:
```java
@GetMapping("/files/{id}/stream")
public ResponseEntity<ResourceRegion> stream(@PathVariable String id, @RequestHeader HttpHeaders headers) throws IOException {
  var meta = metaService.get(id);
  var resource = new FileSystemResource(meta.localPath());
  long length = resource.contentLength();
  List<HttpRange> ranges = headers.getRange();
  if (ranges == null || ranges.isEmpty()) {
    ResourceRegion region = new ResourceRegion(resource, 0, Math.min(1024*1024, length)); // 첫 청크
    return ResponseEntity.status(HttpStatus.PARTIAL_CONTENT)
      .contentType(MediaType.parseMediaType(meta.contentType()))
      .header("Accept-Ranges","bytes")
      .header(HttpHeaders.CONTENT_RANGE, "bytes 0-" + (region.getCount()-1) + "/" + length)
      .body(region);
  }
  HttpRange range = ranges.get(0);
  ResourceRegion region = range.toResourceRegion(resource, length);
  return ResponseEntity.status(HttpStatus.PARTIAL_CONTENT)
    .contentType(MediaType.parseMediaType(meta.contentType()))
    .header("Accept-Ranges","bytes")
    .header(HttpHeaders.CONTENT_RANGE, "bytes " + region.getPosition() + "-" + (region.getPosition()+region.getCount()-1) + "/" + length)
    .body(region);
}
```

> **비디오/오디오/대용량 ZIP** 재개 다운로드에 필수. CDN도 Range를 인지한다.

### C-3. 보안 헤더/다운로드 전용 도메인
- **다운로드 전용 서브도메인**(e.g., `dl.example.com`)에서만 제공하고  
  `Content-Disposition: attachment` +  
  `X-Content-Type-Options: nosniff` +  
  `Content-Security-Policy: default-src 'none';`  
  로 **실행/렌더링 차단**(특히 HTML/SVG).

---

## D. 대용량 처리 — 청크 업로드, 서버 메모리 보호, **Zero-Copy**

### D-1. 청크 업로드 API(간단 패턴)
테이블:
```
upload_session(id, file_name, total_size, chunk_size, chunks, completed, checksum, created_at)
```

흐름:
1) `POST /uploads/session` → 세션 ID/청크 크기 응답  
2) `PUT /uploads/session/{id}/chunk?index=n` (Body: raw bytes)  
3) `POST /uploads/session/{id}/complete` with 전체 해시 → 서버가 합치고 **무결성 검증**  
4) 완료 시 파일 엔티티로 승격

**청크 수신(파일 합치기) 예**:
```java
@PutMapping(path="/uploads/session/{id}/chunk", consumes=MediaType.APPLICATION_OCTET_STREAM_VALUE)
public ResponseEntity<Void> putChunk(@PathVariable String id, @RequestParam int index, InputStream body) throws IOException {
  var s = sessionService.get(id);
  Path chunk = s.dir().resolve("chunk-" + index);
  try (var out = Files.newOutputStream(chunk, StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)) {
    body.transferTo(out); // 스트리밍 복사
  }
  sessionService.markReceived(id, index);
  return ResponseEntity.accepted().build();
}
```

> 장점: **장거리·불안정 네트워크**에도 회복력↑, **재시도 범위가 작은** 안정 업로드.  
> S3/GCS를 쓰면 **서비스로 직접 청크 업로드(Resumable/Multi-part)**를 권장(아래 E/F).

### D-2. 서버 메모리 보호
- `resolve-lazily=true`, 스트림 복사(`transferTo`), **no buffering**  
- 필터에서 **요청 바디 사이즈** 제한(리버스 프록시(Nginx)/LB도 제한)

### D-3. Zero-Copy(전송 최적화)
- 서블릿 컨테이너/OS가 지원하는 **sendfile** 사용: `FileSystemResource`를 그대로 반환하면 톰캣/네티가 최적화.  
- WebFlux(Netty)는 내부적으로 **zero-copy** 경로가 있음(파일→소켓).

---

## E. S3 연동 — 서버 저장/다운로드/사전 서명 URL

### E-1. AWS SDK v2 의존성
```kotlin
dependencies {
  implementation("software.amazon.awssdk:s3:2.26.9")
}
```

### E-2. 클라이언트/버킷 설정
```java
@Configuration
class S3Config {
  @Bean
  S3Client s3() {
    return S3Client.builder()
      .region(Region.AP_NORTHEAST_2) // 서울
      .build();
  }
  @Bean
  S3Presigner presigner() {
    return S3Presigner.builder()
      .region(Region.AP_NORTHEAST_2)
      .build();
  }
}
```

### E-3. 업로드(스트리밍)
```java
@Service
@RequiredArgsConstructor
class S3Storage {
  private final S3Client s3;

  public void put(String bucket, String key, String contentType, InputStream in, long size) {
    var req = PutObjectRequest.builder()
      .bucket(bucket).key(key)
      .contentType(contentType)
      .acl(ObjectCannedACL.PRIVATE)
      .build();
    s3.putObject(req, RequestBody.fromInputStream(in, size));
  }

  public URL presignPut(String bucket, String key, Duration ttl) {
    var presigner = S3Presigner.create();
    var req = PutObjectRequest.builder().bucket(bucket).key(key).build();
    var pr = PutObjectPresignRequest.builder().signatureDuration(ttl).putObjectRequest(req).build();
    return presigner.presignPutObject(pr).url();
  }

  public URL presignGet(String bucket, String key, Duration ttl) {
    var presigner = S3Presigner.create();
    var req = GetObjectRequest.builder().bucket(bucket).key(key).build();
    var pr = GetObjectPresignRequest.builder().signatureDuration(ttl).getObjectRequest(req).build();
    return presigner.presignGetObject(pr).url();
  }
}
```

> **권장 패턴**: **클라이언트 → S3 직접 전송**(presigned PUT). 서버는 **메타 등록**만.  
> 다운로드도 presigned GET으로 **S3/CDN이 직접** 서빙하게 하여 트래픽을 오프로드.

### E-4. 멀티파트 업로드(S3 기능 이용)
- 매우 큰 파일(수 GB)은 **S3 Multipart Upload**:  
  1) `createMultipartUpload` → `uploadPart` 반복 → `completeMultipartUpload`.  
  2) 클라이언트가 직접 수행(프런트에서 SDK 사용)하거나 서버 프록시.

---

## F. GCS(구글 클라우드 스토리지) — Resumable/Signed URL

### F-1. 의존성
```kotlin
dependencies {
  implementation("com.google.cloud:google-cloud-storage:2.40.1")
}
```

### F-2. 클라이언트
```java
@Configuration
class GcsConfig {
  @Bean
  Storage gcs() { return StorageOptions.getDefaultInstance().getService(); }
}
```

### F-3. 업로드(Resumable)
```java
@Service
@RequiredArgsConstructor
class GcsStorage {
  private final Storage storage;

  public void put(String bucket, String key, String contentType, InputStream in) throws IOException {
    var blobInfo = BlobInfo.newBuilder(BlobId.of(bucket, key)).setContentType(contentType).build();
    try (var writer = storage.writer(blobInfo)) {
      in.transferTo(Channels.newOutputStream(writer)); // 스트리밍 업로드
    }
  }

  public URL signedGet(String bucket, String key, Duration ttl) {
    return storage.signUrl(BlobInfo.newBuilder(bucket, key).build(), ttl.toSeconds(), TimeUnit.SECONDS,
      Storage.SignUrlOption.withV4Signature());
  }
}
```

> GCS는 **Resumable Upload** natively 제공(오프셋 재시도). 프런트가 직접 올리면 서버 부담↓.

---

## G. CDN 캐싱 전략 — URL 전략, 헤더, 서명, 무효화

### G-1. 불변(immutable) vs 가변
- **불변 에셋**(버전 파일명, 해시 포함):  
  `Cache-Control: public, max-age=31536000, immutable`  
  파일 이름에 **콘텐츠 해시**(예: `photo_s.8f3d2c.webp`) → 컨텐츠 변경=새 URL → **무효화 불필요**.
- **가변 리소스**(동적):  
  `Cache-Control: public, max-age=60, stale-while-revalidate=30`  
  짧은 TTL + SWR로 체감 성능↑.

### G-2. ETag/Last-Modified/변조 방지
- **ETag**로 조건부 GET, CDN은 원본 변경 탐지.  
- 다운로드 무결성 확인이 필요하면 별도 **SHA-256 헤더**를 제공(클라이언트 검증).

### G-3. 서명 URL/쿠키
- **CloudFront Signed URL/Cookie**, **Cloud CDN Signed URL**로 **권한 있는 사용자만** 접근.  
- 만료가 짧은 서명 URL + 애플리케이션 쿠키/토큰 검증.

### G-4. 범위 요청과 CDN
- CloudFront/Cloud CDN 모두 **Range** 전달 가능. 동영상 스트리밍/대용량 Resume에 유리.  
- 오리진이 Range를 지원해야 CDN이 중간 캐시 가능(위 C-2 참고).

### G-5. 무효화(Invalidate) 전략
- 정적 버전 파일은 **무효화 필요 없음**(해시 파일명).  
- **동일 URL** 갱신이 필요한 경우만 무효화 API 사용(비용/지연 고려).

---

## H. 권한/보안 — 다운로드 권한·바이러스 스캔·XSS

### H-1. 다운로드 ACL
- 파일 메타에 **owner/role/tenant** 저장 → 컨트롤러에서 권한 검증 후 **302 리다이렉트**로 presigned URL 반환(권한 우회 방지).
```java
@GetMapping("/files/{id}/redirect")
public ResponseEntity<Void> authorizeAndRedirect(@PathVariable String id) {
  var meta = metaService.get(id);
  authz.checkDownload(meta, currentUser()); // 권한 체크
  var url = s3Storage.presignGet(meta.bucket(), meta.key(), Duration.ofMinutes(5));
  return ResponseEntity.status(302).location(URI.create(url.toString())).build();
}
```

### H-2. 악성 파일 방어
- **MIME 스니핑** + **확장자 화이트리스트**.  
- **안티바이러스**(ClamAV 등) 스캔 후 저장/다운로드 허용.  
- **SVG/HTML**은 무조건 `attachment` + CSP로 렌더링 차단.

---

## I. 관측/모니터링 — 전송 지표, 실패/재시도, 비용

- **업로드 성공률/실패 사유**(타임아웃/용량/유형), 평균 크기/피크 시간대.  
- 다운로드 **히트율**(CDN), **Range 비율**, 평균 전송 속도.  
- S3/GCS **요청 수/트래픽/요금** 대시보드화.  
- **DLT**(썸네일 실패 큐)로 재처리.

---

## J. WebFlux(리액티브) 시나리오 스니펫

### J-1. 업로드(파일 스트림 → S3)
```java
@PostMapping(path="/rx/files", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public Mono<ResponseEntity<Map<String,Object>>> rxUpload(ServerRequest req) {
  return req.multipartData().flatMap(parts -> {
    FilePart file = (FilePart) parts.toSingleValueMap().get("file");
    String key = "rx/" + UUID.randomUUID();
    // 임시 파일에 스트림 파이프 (S3 SDK v2의 AsyncClient를 쓰면 진짜 논블로킹 가능)
    Path temp = Files.createTempFile("rx-", ".bin");
    return file.transferTo(temp.toFile())
      .then(Mono.fromCallable(() -> {
        try (var in = Files.newInputStream(temp)) {
          s3Storage.put("bucket", key, "application/octet-stream", in, Files.size(temp));
        }
        return ResponseEntity.ok(Map.of("key", key));
      }).subscribeOn(Schedulers.boundedElastic()));
  });
}
```

### J-2. 다운로드(리액티브 Range)
WebFlux는 `Zero-copy`가 자동 경로로 선택되기도 한다. 큰 파일은 `DataBufferUtils.read`로 청킹 가능.

---

## K. 테스트 전략 — 무결성/Range/성능

### K-1. MockMvc + TempFile
```java
@Test
void upload_and_download() throws Exception {
  MockMultipartFile f = new MockMultipartFile("file", "test.jpg", "image/jpeg",
      Files.readAllBytes(Path.of("src/test/resources/test.jpg")));

  var res = mvc.perform(multipart("/files").file(f))
    .andExpect(status().isCreated())
    .andReturn();

  String location = res.getResponse().getHeader("Location");
  mvc.perform(get(location))
    .andExpect(status().isOk())
    .andExpect(header().string("Content-Disposition", Matchers.containsString("attachment")));
}
```

### K-2. Range 응답 테스트
```java
mvc.perform(get("/files/{id}/stream", id)
    .header("Range","bytes=0-1023"))
  .andExpect(status().isPartialContent())
  .andExpect(header().string("Content-Range", Matchers.containsString("bytes 0-1023/")));
```

### K-3. 부하/대역폭
- k6/JMeter로 **동시 업/다운** 시나리오, **CDN 포함** E2E 레이턴시 측정.  
- 서버/오리진/클라이언트 병목 파악(네트워크/IO/CPU).

---

## L. 운영 체크리스트(요약)

- [ ] **업로드**: 사이즈 제한, MIME 스니핑, 파일명 정규화, 바이러스 스캔, 해시 저장.  
- [ ] **이미지**: EXIF 제거, sRGB, 썸네일 사이즈 세트, 품질/포맷, 비동기 파이프라인.  
- [ ] **다운로드**: `attachment` + `nosniff` + `CSP`, **Range(206)** 지원, ETag/Cache-Control.  
- [ ] **대용량**: 청크 업로드/멀티파트(S3/GCS), 서버 버퍼 금지, zero-copy.  
- [ ] **스토리지**: presigned URL로 **직접 업/다운**, 서버는 권한/메타.  
- [ ] **CDN**: 해시 기반 파일명(immutable), 가변은 짧은 TTL+SWR, 서명 URL/쿠키.  
- [ ] **보안/권한**: 다운로드 ACL, 테넌트 분리, 감사 로깅(traceId).  
- [ ] **관측/비용**: 트래픽·요금 대시보드, 실패/DLT 모니터, 핫 파일 캐시 전략.

---

## M. 한 페이지 요약

- **업로드**는 “검증→보안→스트리밍 저장→무결성(해시)”가 핵심. **콘텐츠 스니핑**과 **파일명 정규화**를 절대 빼지 말 것.  
- **이미지 파이프라인**은 EXIF 제거/색공간/여러 변형(썸네일·WebP/AVIF)과 **비동기 처리**로 확장성↑.  
- **다운로드**는 `Content-Disposition`/보안 헤더, **Range(206)**로 Resume/시킹, **ETag+캐시**로 비용↓.  
- **S3/GCS**는 **presigned URL**로 클라이언트 직행을 표준으로. 멀티파트/Resumable로 대용량을 견고하게.  
- **CDN 전략**은 “해시 버전 파일 → 무효화 불필요”, 가변은 짧은 TTL+SWR, 필요한 곳에 **서명 URL/쿠키**.  
- 전 구간에서 **멱등성·무결성·권한**과 **관측성**을 넣어야 대규모에서도 안정적으로 굴러간다.