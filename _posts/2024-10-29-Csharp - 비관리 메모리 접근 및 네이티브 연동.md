---
layout: post
title: C# - 비관리 메모리 접근 및 네이티브 연동
date: 2024-10-29 19:20:23 +0900
category: Csharp
---
# C# 비관리 메모리 접근 및 네이티브 연동

## 소개: 안전한 코드에서 저수준 제어까지

C#은 기본적으로 안전한(safe) 관리 코드 환경을 제공하지만, 성능이 중요한 시나리오나 기존 네이티브 라이브러리와 통합해야 할 때는 비관리 메모리와 직접 상호작용해야 합니다. 이러한 작업은 복잡하고 오류가 발생하기 쉽지만, C#은 이를 위한 강력한 도구들을 제공합니다. 이 가이드는 비관리 메모리 접근, 네이티브 코드와의 상호 운용, 그리고 안전성을 유지하면서 성능을 극대화하는 방법을 체계적으로 설명합니다.

---

## 1. 기본 개념 이해: 관리 vs 비관리 메모리

### 관리 메모리(Managed Memory)

- **가비지 컬렉터(GC)** 가 자동으로 할당, 이동, 해제
- **타입 안전성** 보장
- **편리하지만 오버헤드**가 있을 수 있음
- 일반적인 C# 객체, 배열, 문자열 등

### 비관리 메모리(Unmanaged Memory)

- **개발자가 직접 할당하고 해제**해야 함
- GC의 통제를 받지 않음
- **성능 최적화** 가능하지만 **메모리 누수, 댕글링 포인터, 버퍼 오버런** 위험
- 네이티브 코드(C/C++), 운영체제 API, 하드웨어 직접 접근 등

### 왜 비관리 메모리를 사용해야 하나?

1. **성능**: 대량 데이터 처리 시 복사 오버헤드 제거
2. **상호 운용**: 기존 C/C++ 라이브러리 사용
3. **제어**: 특정 메모리 레이아웃이나 정렬 요구사항 충족
4. **시스템 호출**: 운영체제 API 직접 호출

---

## 2. P/Invoke: 네이티브 DLL 함수 호출하기

P/Invoke(Platform Invocation Services)는 관리 코드에서 비관리 DLL의 함수를 호출할 수 있게 해줍니다.

### 기본적인 P/Invoke 예제

```csharp
using System;
using System.Runtime.InteropServices;

class NativeMethods
{
    // Windows MessageBox 함수 호출
    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    public static extern int MessageBox(
        IntPtr hWnd, 
        string text, 
        string caption, 
        uint type);
}

class Program
{
    static void Main()
    {
        // 네이티브 함수 호출
        int result = NativeMethods.MessageBox(
            IntPtr.Zero, 
            "안녕하세요, P/Invoke!", 
            "테스트", 
            0);
        
        Console.WriteLine($"MessageBox 결과: {result}");
    }
}
```

### P/Invoke 속성 이해하기

```csharp
[DllImport(
    "kernel32.dll",                    // DLL 이름
    CharSet = CharSet.Unicode,        // 문자열 인코딩
    CallingConvention = CallingConvention.StdCall, // 호출 규약
    SetLastError = true,              // Win32 에러 코드 가져오기
    ExactSpelling = false)]           // 정확한 함수 이름 일치 여부
public static extern bool CreateDirectory(
    string lpPathName,
    IntPtr lpSecurityAttributes);
```

### 오류 처리

```csharp
[DllImport("kernel32.dll", SetLastError = true)]
public static extern IntPtr LoadLibrary(string lpFileName);

static void LoadLibraryWithErrorHandling(string libraryName)
{
    IntPtr handle = LoadLibrary(libraryName);
    
    if (handle == IntPtr.Zero)
    {
        // 마지막 Win32 오류 코드 가져오기
        int errorCode = Marshal.GetLastWin32Error();
        
        // 오류 코드를 메시지로 변환
        string errorMessage = new System.ComponentModel.Win32Exception(
            errorCode).Message;
        
        Console.WriteLine($"라이브러리 로드 실패: {errorMessage} (코드: {errorCode})");
    }
    else
    {
        Console.WriteLine("라이브러리 로드 성공");
        // 사용 후 정리 필요
    }
}
```

---

## 3. 메모리 할당과 해제

비관리 메모리를 사용할 때 가장 중요한 것은 할당한 메모리를 반드시 해제하는 것입니다.

### 전통적인 방법: Marshal 클래스

```csharp
using System;
using System.Runtime.InteropServices;

class MarshalExample
{
    static void AllocateAndFreeMemory()
    {
        IntPtr memory = IntPtr.Zero;
        
        try
        {
            // 1KB 메모리 할당
            memory = Marshal.AllocHGlobal(1024);
            
            if (memory == IntPtr.Zero)
            {
                throw new OutOfMemoryException("메모리 할당 실패");
            }
            
            Console.WriteLine($"할당된 메모리 주소: 0x{memory.ToInt64():X}");
            
            // 메모리 사용 예: 바이트 배열로 복사
            byte[] data = new byte[] { 1, 2, 3, 4, 5 };
            Marshal.Copy(data, 0, memory, data.Length);
            
            // 메모리에서 데이터 읽기
            byte[] readData = new byte[5];
            Marshal.Copy(memory, readData, 0, 5);
            Console.WriteLine($"읽은 데이터: {string.Join(", ", readData)}");
        }
        finally
        {
            // 반드시 메모리 해제
            if (memory != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(memory);
                Console.WriteLine("메모리 해제 완료");
            }
        }
    }
}
```

### 현대적인 방법: NativeMemory 클래스 (.NET 6+)

```csharp
using System;
using System.Runtime.InteropServices;

class NativeMemoryExample
{
    unsafe static void AllocateNativeMemory()
    {
        // nint는 IntPtr과 유사하지만 산술 연산이 더 편리합니다
        nint memory = (nint)0;
        
        try
        {
            // 1KB 메모리 할당 (0으로 초기화된 버전도 있음: AllocZeroed)
            memory = (nint)NativeMemory.Alloc(1024);
            
            Console.WriteLine($"할당된 메모리 주소: 0x{memory:X}");
            
            // Span으로 래핑하여 안전하게 접근
            Span<byte> span = new Span<byte>((void*)memory, 1024);
            
            // 데이터 채우기
            span.Fill(0xAA);
            
            // 일부 데이터 수정
            span[0] = 0xFF;
            span[1] = 0xFE;
            
            Console.WriteLine($"첫 번째 바이트: 0x{span[0]:X2}");
            Console.WriteLine($"두 번째 바이트: 0x{span[1]:X2}");
        }
        finally
        {
            // 메모리 해제
            if (memory != (nint)0)
            {
                NativeMemory.Free((void*)memory);
                Console.WriteLine("메모리 해제 완료");
            }
        }
    }
}
```

---

## 4. 구조체 마샬링: 네이티브와 C# 구조체 맞추기

네이티브 코드와 데이터를 교환할 때는 구조체의 메모리 레이아웃이 정확히 일치해야 합니다.

### 기본 구조체 마샬링

```csharp
using System;
using System.Runtime.InteropServices;

// 네이티브 구조체와 정확히 일치하도록 설정
[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct Point
{
    public int X;
    public int Y;
    
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
    
    public override string ToString() => $"({X}, {Y})";
}

class StructMarshalingExample
{
    // 구조체를 마샬링하는 예제 함수 (실제 네이티브 함수 대신)
    static void ProcessPoint(ref Point point)
    {
        // X, Y 값 교환 (예제용)
        int temp = point.X;
        point.X = point.Y;
        point.Y = temp;
    }
    
    static void MarshalStructToNative()
    {
        Point point = new Point(10, 20);
        Console.WriteLine($"원본: {point}");
        
        // 구조체를 비관리 메모리로 마샬링
        IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf<Point>());
        
        try
        {
            // 구조체를 비관리 메모리에 쓰기
            Marshal.StructureToPtr(point, ptr, false);
            
            // 여기서 실제 네이티브 함수를 호출할 수 있음
            // 예: NativeProcessPoint(ptr);
            
            // 비관리 메모리에서 구조체 읽기
            Point result = Marshal.PtrToStructure<Point>(ptr);
            Console.WriteLine($"결과: {result}");
        }
        finally
        {
            // 메모리 해제
            Marshal.FreeHGlobal(ptr);
        }
    }
}
```

### 고급 구조체: 고정 크기 배열, 공용체(Union)

```csharp
using System;
using System.Runtime.InteropServices;

// 고정 크기 배열을 포함한 구조체
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Person
{
    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
    public string Name;
    
    public int Age;
    
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
    public float[] Scores; // 크기가 3인 고정 배열
}

// 공용체(Union) 구현
[StructLayout(LayoutKind.Explicit)]
public struct DataUnion
{
    [FieldOffset(0)]
    public int IntegerValue;
    
    [FieldOffset(0)]
    public float FloatValue;
    
    [FieldOffset(0)]
    public byte Byte1;
    
    [FieldOffset(1)]
    public byte Byte2;
    
    [FieldOffset(2)]
    public byte Byte3;
    
    [FieldOffset(3)]
    public byte Byte4;
}

class AdvancedStructExample
{
    static void DemonstrateUnion()
    {
        DataUnion union = new DataUnion();
        
        // 정수 값 설정
        union.IntegerValue = 0x12345678;
        
        Console.WriteLine($"정수: 0x{union.IntegerValue:X}");
        Console.WriteLine($"실수: {union.FloatValue}");
        Console.WriteLine($"바이트: {union.Byte1:X2} {union.Byte2:X2} " +
                         $"{union.Byte3:X2} {union.Byte4:X2}");
        
        // 바이트를 통해 값 변경
        union.Byte1 = 0xFF;
        Console.WriteLine($"변경 후 정수: 0x{union.IntegerValue:X}");
    }
}
```

---

## 5. SafeHandle: 리소스 누수 방지

`SafeHandle`은 비관리 리소스의 수명을 안전하게 관리하는 데 사용됩니다. 이는 리소스 누수를 방지하고 예외 상황에서도 정리가 보장되도록 합니다.

### SafeHandle 구현 예제

```csharp
using System;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;

// 파일 핸들을 안전하게 관리하는 SafeHandle 파생 클래스
public sealed class SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid
{
    // private 생성자 - 외부에서 직접 생성하지 않음
    private SafeFileHandle() : base(true) { }
    
    // 네이티브 핸들로부터 생성
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle) 
        : base(ownsHandle)
    {
        SetHandle(preexistingHandle);
    }
    
    // 리소스 해제 메서드
    protected override bool ReleaseHandle()
    {
        // 네이티브 핸들 해제 (여기서는 CloseHandle 사용)
        return CloseHandle(handle);
    }
    
    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool CloseHandle(IntPtr hObject);
}

class SafeHandleExample
{
    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    public static extern SafeFileHandle CreateFileW(
        string lpFileName,
        uint dwDesiredAccess,
        uint dwShareMode,
        IntPtr lpSecurityAttributes,
        uint dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile);
    
    static void UseSafeFileHandle()
    {
        // SafeHandle 사용 - using 블록이 끝나면 자동으로 해제됨
        using (var fileHandle = CreateFileW(
            "test.txt",
            0x80000000, // GENERIC_READ
            0,          // 공유 안함
            IntPtr.Zero,
            3,          // OPEN_EXISTING
            0x80,       // FILE_ATTRIBUTE_NORMAL
            IntPtr.Zero))
        {
            if (fileHandle.IsInvalid)
            {
                int error = Marshal.GetLastWin32Error();
                Console.WriteLine($"파일 열기 실패: {error}");
                return;
            }
            
            Console.WriteLine("파일 핸들 획득 성공");
            
            // 파일 작업 수행...
            
        } // using 블록이 끝나면 자동으로 ReleaseHandle() 호출
        
        Console.WriteLine("파일 핸들이 안전하게 해제되었습니다.");
    }
}
```

---

## 6. Span<T>와 Memory<T>: 안전한 고성능 메모리 접근

`Span<T>`와 `Memory<T>`는 비관리 메모리를 안전하게 접근할 수 있는 현대적인 방법을 제공합니다.

### Span<T>로 비관리 메모리 다루기

```csharp
using System;
using System.Runtime.InteropServices;

class SpanUnsafeMemoryExample
{
    unsafe static void ProcessUnsafeMemoryWithSpan()
    {
        // 비관리 메모리 할당
        nint memory = (nint)NativeMemory.Alloc(1000);
        
        try
        {
            // Span으로 래핑
            Span<byte> buffer = new Span<byte>((void*)memory, 1000);
            
            // 안전하게 데이터 채우기
            buffer.Fill(0xCC);
            
            // 부분 데이터 접근
            Span<byte> first100 = buffer.Slice(0, 100);
            first100.Fill(0xFF);
            
            // 데이터 복사
            byte[] sourceData = new byte[] { 1, 2, 3, 4, 5 };
            sourceData.CopyTo(buffer.Slice(200, 5));
            
            // 데이터 읽기
            Console.WriteLine($"버퍼[0]: {buffer[0]:X2}"); // 0xFF
            Console.WriteLine($"버퍼[200]: {buffer[200]}"); // 1
            
            // 구조체로 해석하기
            if (buffer.Length >= sizeof(int) * 4)
            {
                Span<int> intView = MemoryMarshal.Cast<byte, int>(buffer);
                intView[0] = 0x12345678;
                intView[1] = 0x9ABCDEF0;
                
                Console.WriteLine($"정수[0]: 0x{intView[0]:X}");
                Console.WriteLine($"정수[1]: 0x{intView[1]:X}");
            }
        }
        finally
        {
            NativeMemory.Free((void*)memory);
        }
    }
    
    static void ProcessFileWithMemoryMappedSpan()
    {
        // MemoryMappedFile과 함께 사용하는 예제 (간략화)
        // 실제로는 System.IO.MemoryMappedFiles 사용
        Console.WriteLine("Memory-mapped 파일은 Span<T>와 잘 어울립니다.");
    }
}
```

---

## 7. 실전 예제: 이미지 데이터 처리

이미지 처리와 같은 고성능 작업에서 비관리 메모리를 효과적으로 사용하는 방법을 알아봅시다.

```csharp
using System;
using System.Runtime.InteropServices;

public unsafe class ImageProcessor : IDisposable
{
    private nint _imageData;
    private int _width;
    private int _height;
    private int _stride; // 한 줄의 바이트 수
    
    public ImageProcessor(int width, int height)
    {
        _width = width;
        _height = height;
        _stride = width * 4; // ARGB (4바이트 픽셀)
        
        // 이미지 데이터 할당 (가로 * 높이 * 픽셀당 바이트 수)
        long totalSize = (long)_stride * height;
        
        if (totalSize > int.MaxValue)
            throw new ArgumentException("이미지가 너무 큽니다.");
        
        _imageData = (nint)NativeMemory.Alloc((nuint)totalSize);
        
        // 0으로 초기화
        new Span<byte>((void*)_imageData, (int)totalSize).Clear();
    }
    
    // 안전한 Span 기반 접근
    public Span<byte> GetPixelData()
    {
        if (_imageData == (nint)0)
            throw new ObjectDisposedException(nameof(ImageProcessor));
        
        return new Span<byte>((void*)_imageData, _stride * _height);
    }
    
    // 고속 픽셀 조작 (포인터 사용)
    public unsafe void InvertColors()
    {
        if (_imageData == (nint)0)
            throw new ObjectDisposedException(nameof(ImageProcessor));
        
        byte* ptr = (byte*)_imageData;
        int totalBytes = _stride * _height;
        
        for (int i = 0; i < totalBytes; i++)
        {
            // 각 색상 채널 반전 (알파 채널 제외)
            if (i % 4 != 3) // 4번째 바이트는 알파 채널
            {
                ptr[i] = (byte)(255 - ptr[i]);
            }
        }
    }
    
    // 더 안전한 Span 기반 버전
    public void AdjustBrightness(float factor)
    {
        if (_imageData == (nint)0)
            throw new ObjectDisposedException(nameof(ImageProcessor));
        
        Span<byte> data = GetPixelData();
        
        for (int i = 0; i < data.Length; i++)
        {
            if (i % 4 != 3) // 알파 채널 제외
            {
                int value = (int)(data[i] * factor);
                data[i] = (byte)Math.Clamp(value, 0, 255);
            }
        }
    }
    
    // 네이티브 라이브러리와 통합 예제
    [DllImport("ImageProcessing.dll", CallingConvention = CallingConvention.Cdecl)]
    private static extern void ApplyFilter(
        byte* data, 
        int width, 
        int height, 
        int stride, 
        float strength);
    
    public void ApplyNativeFilter(float strength)
    {
        if (_imageData == (nint)0)
            throw new ObjectDisposedException(nameof(ImageProcessor));
        
        unsafe
        {
            ApplyFilter(
                (byte*)_imageData, 
                _width, 
                _height, 
                _stride, 
                strength);
        }
    }
    
    public void SaveToFile(string path)
    {
        // 실제 구현은 파일 I/O를 포함
        Console.WriteLine($"이미지를 {path}에 저장");
    }
    
    public void Dispose()
    {
        if (_imageData != (nint)0)
        {
            NativeMemory.Free((void*)_imageData);
            _imageData = (nint)0;
        }
        
        GC.SuppressFinalize(this);
    }
    
    ~ImageProcessor()
    {
        Dispose();
    }
}

class Program
{
    static void Main()
    {
        // 이미지 프로세서 사용 예제
        using (var processor = new ImageProcessor(800, 600))
        {
            Console.WriteLine("이미지 프로세서 생성 완료");
            
            // 색상 반전
            processor.InvertColors();
            Console.WriteLine("색상 반전 적용");
            
            // 밝기 조절
            processor.AdjustBrightness(1.2f);
            Console.WriteLine("밝기 조절 적용");
            
            // 네이티브 필터 적용 (가상)
            // processor.ApplyNativeFilter(0.5f);
            
            // 저장
            processor.SaveToFile("output.bmp");
            
            Console.WriteLine("처리 완료");
        } // using 블록이 끝나면 자동으로 Dispose 호출
    }
}
```

---

## 8. 문자열 인코딩과 마샬링

네이티브 코드와 문자열을 교환할 때는 인코딩을 정확히 맞추는 것이 중요합니다.

### 다양한 문자열 인코딩 처리

```csharp
using System;
using System.Runtime.InteropServices;
using System.Text;

class StringEncodingExample
{
    // UTF-16 (Windows Unicode)
    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    public static extern int MessageBoxW(
        IntPtr hWnd, 
        string text, 
        string caption, 
        uint type);
    
    // ANSI (레거시 Windows)
    [DllImport("user32.dll", CharSet = CharSet.Ansi)]
    public static extern int MessageBoxA(
        IntPtr hWnd, 
        string text, 
        string caption, 
        uint type);
    
    // UTF-8 문자열 처리
    [DllImport("MyNativeLib.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern int ProcessUtf8String(byte* utf8String);
    
    static unsafe void SendUtf8ToNative(string text)
    {
        // UTF-8 바이트 배열로 변환 (널 종료 문자 포함)
        byte[] utf8Bytes = Encoding.UTF8.GetBytes(text + "\0");
        
        fixed (byte* ptr = utf8Bytes)
        {
            int result = ProcessUtf8String(ptr);
            Console.WriteLine($"네이티브 함수 결과: {result}");
        }
    }
    
    static void DemonstrateStringMarshaling()
    {
        string message = "안녕하세요, 세계!";
        
        // UTF-16 (Windows Unicode)
        MessageBoxW(IntPtr.Zero, message, "UTF-16", 0);
        
        // ANSI (문자 깨짐 가능성 있음)
        MessageBoxA(IntPtr.Zero, message, "ANSI", 0);
        
        // UTF-8
        SendUtf8ToNative(message);
    }
    
    // StringBuilder를 사용한 출력 매개변수
    [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
    public static extern int GetCurrentDirectory(
        int bufferLength, 
        StringBuilder buffer);
    
    static string GetCurrentDirectorySafe()
    {
        // 첫 번째 호출: 필요한 버퍼 크기 확인
        int length = GetCurrentDirectory(0, null);
        
        if (length == 0)
            throw new System.ComponentModel.Win32Exception();
        
        // 적절한 크기의 StringBuilder 생성
        StringBuilder buffer = new StringBuilder(length);
        
        // 실제 데이터 가져오기
        length = GetCurrentDirectory(length, buffer);
        
        if (length == 0)
            throw new System.ComponentModel.Win32Exception();
        
        return buffer.ToString();
    }
}
```

---

## 9. 교차 플랫폼 고려사항

### NativeLibrary 클래스를 사용한 동적 로딩

```csharp
using System;
using System.Runtime.InteropServices;

class CrossPlatformNativeLoading
{
    // 플랫폼별 라이브러리 확장자
    private static string GetPlatformLibraryName(string baseName)
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return $"{baseName}.dll";
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            return $"lib{baseName}.so";
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            return $"lib{baseName}.dylib";
        else
            return baseName;
    }
    
    static void LoadNativeLibraryDynamically()
    {
        string libraryName = GetPlatformLibraryName("mylib");
        
        IntPtr libraryHandle = IntPtr.Zero;
        
        try
        {
            // 동적으로 라이브러리 로드
            libraryHandle = NativeLibrary.Load(libraryName);
            
            if (libraryHandle == IntPtr.Zero)
            {
                Console.WriteLine($"라이브러리 로드 실패: {libraryName}");
                return;
            }
            
            Console.WriteLine($"라이브러리 로드 성공: {libraryName}");
            
            // 함수 포인터 가져오기
            if (NativeLibrary.TryGetExport(libraryHandle, "native_function", 
                out IntPtr functionPtr))
            {
                // 함수 포인터를 델리게이트로 변환
                var function = Marshal.GetDelegateForFunctionPointer<NativeFunction>(
                    functionPtr);
                
                // 함수 호출
                int result = function(10, 20);
                Console.WriteLine($"네이티브 함수 결과: {result}");
            }
            else
            {
                Console.WriteLine("함수를 찾을 수 없습니다.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"오류 발생: {ex.Message}");
        }
        finally
        {
            // 라이브러리 언로드
            if (libraryHandle != IntPtr.Zero)
            {
                NativeLibrary.Free(libraryHandle);
                Console.WriteLine("라이브러리 언로드 완료");
            }
        }
    }
    
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    delegate int NativeFunction(int a, int b);
}
```

---

## 결론: 안전성과 성능의 균형 맞추기

비관리 메모리와 네이티브 코드 연동은 C#의 강력한 기능이지만, 신중하게 사용해야 합니다. 다음 원칙들을 기억하세요:

### 1. 필요할 때만 사용하세요
- 대부분의 애플리케이션에서는 완전히 관리되는 코드로 충분합니다.
- 성능 문제가 확인된 후에만 비관리 메모리나 네이티브 연동을 고려하세요.

### 2. 가장 안전한 도구부터 시도하세요
   a. 먼저 **관리되는 솔루션**을 시도하세요.
   b. 필요하면 **Span<T>/Memory<T>** 를 사용하세요.
   c. 정말 필요할 때만 **unsafe 코드와 포인터**를 사용하세요.

### 3. 리소스 관리에 철저하세요
- 할당한 모든 비관리 메모리는 반드시 해제하세요.
- `SafeHandle`을 사용하여 리소스 누수를 방지하세요.
- `using` 문과 `try-finally` 블록을 활용하세요.

### 4. 플랫폼 차이를 고려하세요
- Windows, Linux, macOS는 각기 다른 ABI(응용 프로그램 이진 인터페이스)를 가집니다.
- 문자열 인코딩, 구조체 정렬, 호출 규약을 플랫폼에 맞게 조정하세요.

### 5. 테스트와 문서화를 철저히 하세요
- 비관리 코드는 디버깅이 어렵습니다.
- 철저한 단위 테스트와 통합 테스트를 작성하세요.
- 코드가 어떻게 동작하는지 명확히 문서화하세요.

### 최종 권장사항

**현대적인 C#에서는 가능하면 `Span<T>`, `Memory<T>`, `NativeMemory`와 같은 안전한 추상화를 사용하세요.** 이러한 도구들은 성능과 안전성 사이의 균형을 잘 유지해줍니다. 정말로 저수준 제어가 필요한 특수한 경우에만 포인터와 `unsafe` 코드를 사용하되, 그 범위를 최소한으로 제한하고 철저하게 테스트하세요.

비관리 메모리와 네이티브 연동을 올바르게 사용하면 C#으로도 시스템 수준의 고성능 애플리케이션을 구축할 수 있습니다. 그러나 이는 강력한 도구일 뿐, 모든 문제에 대한 해답이 아님을 기억하세요. 적절한 도구를 적절한 상황에 사용하는 것이 좋은 소프트웨어 엔지니어의 핵심 역량입니다.