---
layout: post
title: C# - 비관리 메모리 접근 및 네이티브 연동
date: 2024-10-29 19:20:23 +0900
category: Csharp
---
# C# 비관리 메모리 접근 및 네이티브 연동

## 큰 그림 한 장 요약

| 문제/목표 | 권장 도구/패턴 | 핵심 포인트 |
|---|---|---|
| 네이티브 DLL 호출 | **P/Invoke (`[DllImport]`)** | 호출 규약/문자셋/오류 전달(`SetLastError`)을 정확히 지정 |
| 안전한 핸들 관리 | **`SafeHandle` 파생형** | `IntPtr` 생포보다 안전. 해제 누수 방지 |
| 비관리 메모리 할당 | **`NativeMemory.Alloc/Free` (.NET 6+)** | 간결/빠름. 또는 전통적 `Marshal.AllocHGlobal/FreeHGlobal` |
| 관리 객체 주소 고정 | **`fixed` / `GCHandle.Alloc(..., Pinned)`** | GC 이동 방지. 사용 범위 최소화 |
| 고성능 버퍼 조작 | **`Span<byte>`/`MemoryMarshal`** | 범위검사+무할당. 포인터를 감싸 안전성↑ |
| 문자열 마샬링 | **문자셋(UTF-16/UTF-8) 명시**, `MarshalAs` | 플랫폼/라이브러리 기대와 일치시킬 것 |
| 구조체 ABI 일치 | **`StructLayout(LayoutKind.Sequential/Explicit)`** | 패딩/정렬/필드 순서 일치 필수 |
| 오류/리소스 | **Try-패턴, using, finally** | 실패 경로에서 누수, UAF 방지 |

---

## 비관리 메모리란?

**관리 메모리**는 GC가 할당/이동/회수하며 안전성과 생산성을 제공합니다. 반면 **비관리 메모리**는 GC가 **모르며**, **직접 할당/해제**해야 합니다. C/C++과 동일한 모델로 **성능/제어**는 좋지만, **누수/댕글링 포인터/오버런** 위험이 있습니다.

### 핵심 개념

- **수명**: 누가 할당했고 누가 해제하는가? (Owner 명확화)
- **레이아웃**: 네이티브 구조체/배열과 **바이트 단위 일치** 여부
- **문자셋**: `char*`가 **UTF-8인지 ANSI인지 UTF-16인지** 합의
- **호출 규약**: cdecl/stdcall/winapi 등 일치

> 메모리 복사량이 큰 루프에서 비용은 대략
> $$ \text{총 복사량} \approx N \cdot S $$
> (호출 빈도 \(N\), 단위 복사 크기 \(S\))
> → **Span/포인터/참조**로 복사를 줄이면 성능 향상.

---

## Marshal: 전통적인 비관리 메모리/마샬링 API

### 할당/해제

```csharp
using System;
using System.Runtime.InteropServices;

IntPtr p = IntPtr.Zero;
try
{
    p = Marshal.AllocHGlobal(100); // 100바이트
    Span<byte> buf = new Span<byte>((void*)p, 100);
    buf.Clear();
    // 사용...
}
finally
{
    if (p != IntPtr.Zero) Marshal.FreeHGlobal(p);
}
```

### 구조체 ↔ 포인터

```csharp
[StructLayout(LayoutKind.Sequential)]
struct Point
{
    public int X;
    public int Y;
}

var pt = new Point { X = 10, Y = 20 };
IntPtr pp = Marshal.AllocHGlobal(Marshal.SizeOf<Point>());
try
{
    Marshal.StructureToPtr(pt, pp, fDeleteOld: false);
    Point back = Marshal.PtrToStructure<Point>(pp);
    Console.WriteLine($"{back.X}, {back.Y}");
}
finally
{
    Marshal.FreeHGlobal(pp);
}
```

### 문자열 마샬링

```csharp
// 비관리 메모리로 문자열 복사 (UTF-16)
IntPtr ps = Marshal.StringToHGlobalUni("안녕하세요");
try
{
    // ps는 wchar_t* (UTF-16)로 간주 가능
}
finally
{
    Marshal.FreeHGlobal(ps);
}
```

---

## NativeMemory: .NET 6+ 현대적 비관리 메모리 API

더 간결/빠름. **nint**는 `IntPtr`의 산술 친화형.

```csharp
using System.Runtime.InteropServices;

nint p = 0;
try
{
    p = NativeMemory.Alloc(256);          // calloc 유사 AllocZeroed도 있음
    var span = new Span<byte>((void*)p, 256);
    span[0] = 0x42;
}
finally
{
    if (p != 0) NativeMemory.Free(p);
}
```

- `Alloc`, `AllocZeroed`, `Realloc`, `Free`
- 포인터 산술, `Span<byte>` 래핑으로 **안전성/편의성**↑

---

## `Span<byte>`로 비관리 메모리 안전 래핑

**범위 검사를 제공**하므로 오버런 위험 감소.

```csharp
nint p = NativeMemory.Alloc(10);
try
{
    Span<byte> s = new((void*)p, 10);
    s.Fill(0xFF);
    // s.CopyTo(...), s.Slice(...) 등 다양
}
finally
{
    NativeMemory.Free(p);
}
```

### `MemoryMarshal`/`Unsafe`(고급)

```csharp
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

Span<int> ints = stackalloc int[] { 1, 2, 3, 4 };
Span<byte> bytes = MemoryMarshal.AsBytes(ints); // int 뷰를 byte 슬라이스로
ref int first = ref MemoryMarshal.GetReference(ints);
ref byte b0 = ref Unsafe.As<int, byte>(ref first); // 고급: 형 재해석
```
> `Unsafe`는 타입 안전을 깨므로 **테스트/리뷰 필수**.

---

## P/Invoke 기초: 외부 C 함수 호출

### 가장 단순한 예

```csharp
using System;
using System.Runtime.InteropServices;

class Native
{
    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    public static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type);
}

Native.MessageBox(IntPtr.Zero, "Hello", "P/Invoke", 0);
```

- **문자셋**: Win32 대부분 **UTF-16**(W 함수). `CharSet.Unicode` 권장.
- **호출 규약**: Windows `CallingConvention.Winapi`(기본). C 라이브러리는 보통 `Cdecl`.

### 사용자 DLL (C)와 연동

C (Windows):
```c
// MyLib.c
__declspec(dllexport) int Add(int a, int b) { return a + b; }
```
C#:
```csharp
[DllImport("MyLib.dll", CallingConvention = CallingConvention.Cdecl)]
public static extern int Add(int a, int b);
```

### 오류 전달 (SetLastError)

```csharp
[DllImport("kernel32.dll", SetLastError = true)]
static extern IntPtr LoadLibrary(string name);

IntPtr h = LoadLibrary("notfound.dll");
if (h == IntPtr.Zero)
{
    int err = Marshal.GetLastWin32Error();
    Console.Error.WriteLine($"LoadLibrary failed: {err}");
}
```

### 문자열/문자셋 주의

- C API가 **UTF-8**을 받는다면 C#에서 `byte[]` 또는 `ReadOnlySpan<byte>`로 **직접 UTF-8 인코딩** 후 포인터 전달:
```csharp
[DllImport("libc", CallingConvention = CallingConvention.Cdecl)]
static extern int puts(byte* s);

unsafe
{
    byte[] utf8 = System.Text.Encoding.UTF8.GetBytes("안녕\0"); // NUL 종료
    fixed (byte* p = utf8)
        puts(p);
}
```

---

## 구조체 레이아웃: ABI 일치가 생명

### Sequential/Explicit

```csharp
[StructLayout(LayoutKind.Sequential, Pack = 1)]
struct Header
{
    public byte Magic;
    public int Length;
    public short Version;
}

[StructLayout(LayoutKind.Explicit)]
struct Mixed
{
    [FieldOffset(0)] public int I32;
    [FieldOffset(0)] public float F32; // 공용체(union) 표현
}
```
- **Pack**로 정렬을 C와 일치.
- **Fixed buffer**(unsafe)로 C의 `char name[16]` 대응:
```csharp
unsafe struct Name16
{
    public fixed byte Data[16];
}
```

### Blittable vs NonBlittable

- **Blittable**: 메모리 복사만으로 표현 가능(예: `int`, `double`, 단순 struct)
- **Non-blittable**: 참조/문자열/관리형 필드 포함 → **특별 마샬링 필요**

---

## 배열/버퍼 마샬링 패턴

### 관리 배열 → 네이티브 버퍼

```csharp
[DllImport("mylib", CallingConvention = CallingConvention.Cdecl)]
static extern void ProcessBuffer(byte* data, int len);

unsafe
{
    byte[] managed = new byte[1024];
    fixed (byte* p = managed) // GC 고정
        ProcessBuffer(p, managed.Length);
}
```

### 네이티브가 메모리를 할당해서 돌려줄 때

- 네이티브 쪽에서 `malloc`/`LocalAlloc` 등으로 할당 → **어떤 함수로 해제해야 하는지** 약속 필요.
- Windows `LocalAlloc`/`LocalFree`, `CoTaskMemAlloc`/`CoTaskMemFree` 등 대응 API를 C#에서 사용:
```csharp
[DllImport("ole32.dll")]
static extern IntPtr CoTaskMemAlloc(IntPtr cb);
[DllImport("ole32.dll")]
static extern void CoTaskMemFree(IntPtr pv);
```

---

## `SafeHandle`: 자원/핸들 수명 안전화

### 기본 패턴

```csharp
using System;
using System.Runtime.InteropServices;

class SafeLibHandle : SafeHandle
{
    public SafeLibHandle() : base(IntPtr.Zero, ownsHandle: true) { }
    public override bool IsInvalid => handle == IntPtr.Zero;

    [DllImport("kernel32.dll")]
    private static extern bool FreeLibrary(IntPtr hModule);

    protected override bool ReleaseHandle() => FreeLibrary(handle);
}
```

P/Invoke 시그니처에서 `IntPtr` 대신 `SafeHandle`을 쓰면 **예외/종료/경로 이탈**에도 자동 해제:
```csharp
[DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
static extern SafeLibHandle LoadLibraryW(string name);
```

> **`SafeHandle` 사용을 습관화**하면 **메모리/핸들 누수**를 크게 줄일 수 있습니다.

---

## `GCHandle`: 관리 객체 고정/참조 유지

```csharp
using System.Runtime.InteropServices;

var arr = new byte[256];
var gch = GCHandle.Alloc(arr, GCHandleType.Pinned);
try
{
    IntPtr p = gch.AddrOfPinnedObject();
    // 네이티브에 p 전달 (스코프 짧게!)
}
finally
{
    gch.Free();
}
```
- **Pinned**는 GC 컴팩션 효율을 낮출 수 있어 **최소 범위**로 사용.

---

## `unsafe`/포인터/`fixed`의 정확한 역할

### 포인터로 직접 쓰기

```csharp
unsafe
{
    byte* p = (byte*)NativeMemory.Alloc(16);
    try
    {
        for (int i = 0; i < 16; i++) p[i] = (byte)i;
    }
    finally
    {
        NativeMemory.Free(p);
    }
}
```

### `fixed`로 관리 메모리 주소 고정

```csharp
unsafe
{
    byte[] buffer = new byte[8];
    fixed (byte* p = buffer) // GC 이동 억제
    {
        // p를 통해 네이티브 API 호출
    }
}
```

---

## 문자열: UTF-16, UTF-8, ANSI 정리

| 환경 | 기본 |
|---|---|
| .NET 문자열 | UTF-16 |
| Win32 “W” API | UTF-16 |
| C/C++ 라이브러리(리눅스/크로스) | 대개 UTF-8 |

### UTF-8 인코딩 후 NUL 종료 전달

```csharp
unsafe static void CallUtf8(Func<byte*, int> native)
{
    var utf8 = System.Text.Encoding.UTF8.GetBytes("안녕\0"); // NUL 필수
    fixed (byte* p = utf8)
        native(p);
}
```

### `MarshalAs`로 제어(필요 시)

```csharp
[DllImport("mylib", CharSet = CharSet.Ansi)]
static extern int print_str([MarshalAs(UnmanagedType.LPStr)] string s);
```
> 실제 라이브러리의 **기대 문자셋**과 반드시 맞춰야 글자 깨짐/크래시 방지.

---

## 동적 로딩: `NativeLibrary` (cross-platform)

```csharp
using System;
using System.Runtime.InteropServices;

nint lib = 0;
try
{
    lib = NativeLibrary.Load("mylib"); // .dll / .so / .dylib
    if (NativeLibrary.TryGetExport(lib, "add", out nint fn))
    {
        // 함수 포인터 → 델리게이트 바인딩
        var add = Marshal.GetDelegateForFunctionPointer<AddDelegate>(fn);
        Console.WriteLine(add(2, 3));
    }
}
finally
{
    if (lib != 0) NativeLibrary.Free(lib);
}

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
delegate int AddDelegate(int a, int b);
```

---

## 함수 포인터(`delegate*`) (고급/unsafe, .NET 5+)

```csharp
unsafe
{
    nint lib = NativeLibrary.Load("mylib");
    try
    {
        NativeLibrary.TryGetExport(lib, "add", out nint sym);
        var add = (delegate* unmanaged[Cdecl]<int, int, int>)sym;
        int r = add(5, 7);
        Console.WriteLine(r);
    }
    finally
    {
        NativeLibrary.Free(lib);
    }
}
```
- **최소 오버헤드** 호출. 시그니처/호출 규약이 정확해야 함.

---

## 고성능 입출력: Span + P/Invoke 혼합 레시피

### 네이티브 압축 API 호출(출력 버퍼 직접 제공)

```csharp
[DllImport("compressor", CallingConvention = CallingConvention.Cdecl)]
static extern int compress_buffer(byte* src, int srcLen, byte* dst, int dstLen); // 반환: 출력 길이 or <0 실패

public static bool TryCompress(ReadOnlySpan<byte> src, Span<byte> dst, out int written)
{
    written = 0;
    unsafe
    {
        fixed (byte* ps = src)
        fixed (byte* pd = dst)
        {
            int r = compress_buffer(ps, src.Length, pd, dst.Length);
            if (r < 0 || r > dst.Length) return false;
            written = r;
            return true;
        }
    }
}
```
- **할당 제로**, 예외 대신 **Try 패턴**으로 실패 처리.

---

## 단위/배열/정렬 함정 체크리스트

- [ ] **구조체**: `StructLayout`/`Pack` 설정이 네이티브와 일치?
- [ ] **정렬(Alignment)**/패딩: 컴파일러/플랫폼 별 다름 → 헤더/ABI 문서 확인
- [ ] **엔디언**: 교차 아키텍처(ARM/리틀/빅) 시 주의
- [ ] **문자열**: 인코딩/NUL 종결? 길이 인자? 소유권?
- [ ] **오류**: `SetLastError`, errno, 반환 코드 정의?
- [ ] **수명**: 누가 할당/해제? `SafeHandle` 도입 여지?
- [ ] **스레드 안전**: 콜백/글로벌 상태/재진입성?
- [ ] **보안**: 경계 검사, 오버런/언더런, 정수 오버플로 방지

---

## 메모리 복사/대역폭 관점 (간단 모델)

- 복사 비용은 대략 **선형**:
  $$ T \approx \alpha + \beta \cdot (N \cdot S) $$
  - \(N\): 복사 횟수, \(S\): 평균 복사 크기
  - \(\beta\): 메모리 대역폭 지연/대수
→ **복사 제거(참조/슬라이스)**, **Batch 처리**, **핀/직접쓰기**가 성능 핵심.

---

## 미니 레퍼런스

### 주요 특성/속성

- `[DllImport(Name, CharSet=..., CallingConvention=..., SetLastError=true, ExactSpelling=true)]`
- `[UnmanagedFunctionPointer(CallingConvention.Cdecl)]`
- `[StructLayout(LayoutKind.Sequential/Explicit, Pack=...)]`
- `[MarshalAs(UnmanagedType.LPStr/LPWStr/LPUTF8Str/ByValTStr/ByValArray)]`

### 자주 쓰는 API

- `Marshal.AllocHGlobal/FreeHGlobal/StructureToPtr/PtrToStructure`
- `Marshal.StringToHGlobalUni/Ansi/UTF8`
- `NativeMemory.Alloc/AllocZeroed/Realloc/Free`
- `NativeLibrary.Load/TryGetExport/Free`
- `GCHandle.Alloc(..., Pinned).AddrOfPinnedObject()`
- `MemoryMarshal.AsBytes/Read/Write/GetReference`

---

## 실전 예제: UTF-8 파일에 안전히 쓰기 (무할당 경로 최소화)

```csharp
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

public static class Utf8Writer
{
    // C: ssize_t write(int fd, const void* buf, size_t count)
    [DllImport("c", CallingConvention = CallingConvention.Cdecl, EntryPoint = "write")]
    private static extern nint write_unix(int fd, byte* buf, nuint count);

    public static void WriteLineUnix(FileStream fs, ReadOnlySpan<char> line)
    {
        // 1) UTF-8 길이 계산 (최대 바이트 수 확보)
        int maxLen = Encoding.UTF8.GetMaxByteCount(line.Length + 1); // '\n'
        Span<byte> stackBuf = maxLen <= 512 ? stackalloc byte[512] : new byte[maxLen]; // 필요시 힙
        int bytes = Encoding.UTF8.GetBytes(line, stackBuf);
        stackBuf[bytes++] = (byte)'\n';

        unsafe
        {
            fixed (byte* p = stackBuf)
            {
                // FileStream.SafeFileHandle.DangerousGetHandle() 사용 가능하지만
                // 여기서는 데모로 Unix 표준 fd 추정 불가 → 대체로 fs.Write 사용 권장.
                // 실제 P/Invoke 쓰려면 플랫폼/핸들 추출 로직 필요.
                fs.Write(stackBuf[..bytes]); // 안전/간결 대안
            }
        }
    }
}
```
- 실제로는 **플랫폼/핸들 추출 방법**이 달라 추가 작업 필요.
- 포인트: **UTF-8 인코딩 + Span 버퍼 + 무할당 우선, 필요시 힙 폴백**.

---

## 마무리 가이드

1. **간단/안전**이 우선: 최고 성능이 꼭 필요하지 않다면 **P/Invoke + SafeHandle + Span**으로 충분.
2. **문자셋/호출 규약/레이아웃**을 라이브러리 문서와 **정확히 일치**시켜라.
3. 소유권/해제 규칙을 문서화. 실패 경로에서 **누수/이중 해제**를 막아라.
4. 고성능이 필요하면 `NativeMemory` + `Span<byte>`/`MemoryMarshal`로 복사 제거.
5. 더 내려갈수록(`unsafe`/포인터) 안전장치를 잃는다. **테스트/프로파일링/코드리뷰**를 필수로.
6. 교차 플랫폼이면 `NativeLibrary`와 경로/이름 규칙(`.dll`/`.so`/`.dylib`)을 고려.

---

## 빠른 선택표

| 시나리오 | 추천 |
|---|---|
| Win32 API 호출 | `[DllImport]` + `CharSet.Unicode` + `SafeHandle` |
| C 라이브러리(cdecl) 호출 | `[DllImport(..., CallingConvention.Cdecl)]` |
| UTF-8 문자열 전달 | 직접 UTF-8 인코딩 + `byte*`/`ReadOnlySpan<byte>` |
| 대형 버퍼 읽기/쓰기 | `Span<byte>`/`ReadOnlySpan<byte>` + `Try` 패턴 |
| 임시 버퍼 | `stackalloc` 우선, 크면 힙 폴백 |
| 비관리 할당 | `NativeMemory.Alloc/Free` (또는 API 맞춤 `CoTaskMem*`, `Local*`) |
| 핸들 수명 | `SafeHandle` |
| 관리 배열 주소 | `fixed`/`GCHandleType.Pinned` (짧게) |
