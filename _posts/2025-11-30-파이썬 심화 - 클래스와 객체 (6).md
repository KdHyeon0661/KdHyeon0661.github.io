---
layout: post
title: íŒŒì´ì¬ ì‹¬í™” - í´ë˜ìŠ¤ì™€ ê°ì²´ (6)
date: 2025-11-30 20:25:23 +0900
category: íŒŒì´ì¬ ì‹¬í™”
---
# í´ë˜ìŠ¤ì™€ ê°ì²´ (6)

## ë¬¸ìì—´ë¡œ ì´ë¦„ì´ ì£¼ì–´ì§„ ê°ì²´ì˜ ë©”ì†Œë“œ í˜¸ê²°

### ë‹¤ì–‘í•œ ë™ì  ë©”ì†Œë“œ í˜¸ì¶œ ê¸°ë²•
```python
print("="*60)
print("ë¬¸ìì—´ë¡œ ì´ë¦„ì´ ì£¼ì–´ì§„ ê°ì²´ì˜ ë©”ì†Œë“œ í˜¸ì¶œ")
print("="*60)

# 1. getattr()ë¥¼ ì´ìš©í•œ ê¸°ë³¸ì ì¸ ë™ì  í˜¸ì¶œ
print("1. getattr()ë¥¼ ì´ìš©í•œ ë™ì  ë©”ì†Œë“œ í˜¸ì¶œ:")

class Calculator:
    """ê°„ë‹¨í•œ ê³„ì‚°ê¸° í´ë˜ìŠ¤"""
    
    def add(self, a, b):
        return a + b
    
    def subtract(self, a, b):
        return a - b
    
    def multiply(self, a, b):
        return a * b
    
    def divide(self, a, b):
        if b == 0:
            raise ValueError("0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        return a / b
    
    def power(self, a, b):
        return a ** b

# ë™ì  ë©”ì†Œë“œ í˜¸ì¶œ í•¨ìˆ˜
def call_method_dynamically(obj, method_name, *args, **kwargs):
    """
    ê°ì²´ì˜ ë©”ì†Œë“œë¥¼ ë¬¸ìì—´ ì´ë¦„ìœ¼ë¡œ ë™ì ìœ¼ë¡œ í˜¸ì¶œ
    
    Args:
        obj: ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•  ê°ì²´
        method_name: í˜¸ì¶œí•  ë©”ì†Œë“œ ì´ë¦„ ë¬¸ìì—´
        *args: ë©”ì†Œë“œì— ì „ë‹¬í•  ìœ„ì¹˜ ì¸ì
        **kwargs: ë©”ì†Œë“œì— ì „ë‹¬í•  í‚¤ì›Œë“œ ì¸ì
    
    Returns:
        ë©”ì†Œë“œ ì‹¤í–‰ ê²°ê³¼
    """
    # ë©”ì†Œë“œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    if not hasattr(obj, method_name):
        raise AttributeError(f"ê°ì²´ {type(obj).__name__}ì— ë©”ì†Œë“œ '{method_name}'ì´ ì—†ìŠµë‹ˆë‹¤")
    
    # ë©”ì†Œë“œ ê°€ì ¸ì˜¤ê¸°
    method = getattr(obj, method_name)
    
    # í˜¸ì¶œ ê°€ëŠ¥í•œì§€ í™•ì¸
    if not callable(method):
        raise TypeError(f"'{method_name}'ì€ í˜¸ì¶œ ê°€ëŠ¥í•œ ë©”ì†Œë“œê°€ ì•„ë‹™ë‹ˆë‹¤")
    
    # ë©”ì†Œë“œ í˜¸ì¶œ
    return method(*args, **kwargs)

# ì‚¬ìš© ì˜ˆì‹œ
calc = Calculator()

print("ê¸°ë³¸ì ì¸ ë™ì  í˜¸ì¶œ:")
operations = [
    ('add', (10, 5)),
    ('subtract', (10, 5)),
    ('multiply', (10, 5)),
    ('divide', (10, 5)),
    ('power', (2, 3))
]

for method_name, args in operations:
    try:
        result = call_method_dynamically(calc, method_name, *args)
        print(f"  {method_name}{args} = {result}")
    except Exception as e:
        print(f"  {method_name}{args} ì˜¤ë¥˜: {e}")

# ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë©”ì†Œë“œ í˜¸ì¶œ ì‹œë„
try:
    call_method_dynamically(calc, 'modulo', 10, 3)
except AttributeError as e:
    print(f"\nì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë©”ì†Œë“œ í˜¸ì¶œ: {e}")

# 2. operator ëª¨ë“ˆì„ ì´ìš©í•œ í•¨ìˆ˜ ê¸°ë°˜ ì ‘ê·¼
print("\n2. operator ëª¨ë“ˆê³¼ì˜ ë¹„êµ:")

import operator

# operator ëª¨ë“ˆì€ ë¯¸ë¦¬ ì •ì˜ëœ í•¨ìˆ˜ë“¤ì„ ì œê³µ
operator_functions = {
    'add': operator.add,
    'sub': operator.sub,
    'mul': operator.mul,
    'truediv': operator.truediv,
    'pow': operator.pow
}

print("operator ëª¨ë“ˆ ì‚¬ìš©:")
for op_name, op_func in operator_functions.items():
    result = op_func(10, 5)
    print(f"  {op_name}(10, 5) = {result}")

# 3. dispatch ë”•ì…”ë„ˆë¦¬ë¥¼ ì´ìš©í•œ ë§¤í•‘
print("\n3. dispatch ë”•ì…”ë„ˆë¦¬ íŒ¨í„´:")

class CommandProcessor:
    """ëª…ë ¹ì–´ ì²˜ë¦¬ê¸° - dispatch ë”•ì…”ë„ˆë¦¬ íŒ¨í„´"""
    
    def __init__(self):
        # ëª…ë ¹ì–´ì™€ ë©”ì†Œë“œ ë§¤í•‘ í…Œì´ë¸”
        self._commands = {
            'start': self._start_process,
            'stop': self._stop_process,
            'status': self._get_status,
            'restart': self._restart_process,
            'help': self._show_help
        }
        
        self._process_status = 'stopped'
        self._process_id = None
    
    def execute(self, command, *args):
        """ëª…ë ¹ì–´ ì‹¤í–‰"""
        if command not in self._commands:
            raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ëª…ë ¹ì–´: {command}")
        
        # dispatch ë”•ì…”ë„ˆë¦¬ì—ì„œ ë©”ì†Œë“œ ê°€ì ¸ì™€ ì‹¤í–‰
        handler = self._commands[command]
        return handler(*args)
    
    def _start_process(self):
        self._process_status = 'running'
        self._process_id = id(self)
        return f"í”„ë¡œì„¸ìŠ¤ ì‹œì‘ë¨ (ID: {self._process_id})"
    
    def _stop_process(self):
        self._process_status = 'stopped'
        result = f"í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ë¨ (ì´ì „ ID: {self._process_id})"
        self._process_id = None
        return result
    
    def _get_status(self):
        return f"ìƒíƒœ: {self._process_status}, ID: {self._process_id}"
    
    def _restart_process(self):
        self._stop_process()
        return self._start_process()
    
    def _show_help(self):
        available_commands = ', '.join(self._commands.keys())
        return f"ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´: {available_commands}"

# ì‚¬ìš© ì˜ˆì‹œ
processor = CommandProcessor()

print("Dispatch ë”•ì…”ë„ˆë¦¬ íŒ¨í„´:")
commands = ['start', 'status', 'restart', 'status', 'stop', 'help']

for cmd in commands:
    result = processor.execute(cmd)
    print(f"  {cmd}: {result}")

# 4. ë°ì½”ë ˆì´í„°ë¥¼ ì´ìš©í•œ ìë™ ë“±ë¡
print("\n4. ë°ì½”ë ˆì´í„°ë¥¼ ì´ìš©í•œ ìë™ ë“±ë¡ íŒ¨í„´:")

class PluginRegistry:
    """í”ŒëŸ¬ê·¸ì¸ ë ˆì§€ìŠ¤íŠ¸ë¦¬ - ë°ì½”ë ˆì´í„° ê¸°ë°˜ ìë™ ë“±ë¡"""
    
    def __init__(self):
        self._plugins = {}
    
    def register(self, name=None):
        """í”ŒëŸ¬ê·¸ì¸ ë“±ë¡ ë°ì½”ë ˆì´í„°"""
        def decorator(func):
            plugin_name = name or func.__name__
            self._plugins[plugin_name] = func
            return func
        return decorator
    
    def execute(self, plugin_name, *args, **kwargs):
        """í”ŒëŸ¬ê·¸ì¸ ì‹¤í–‰"""
        if plugin_name not in self._plugins:
            raise KeyError(f"í”ŒëŸ¬ê·¸ì¸ '{plugin_name}'ì´ ë“±ë¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
        
        plugin_func = self._plugins[plugin_name]
        return plugin_func(*args, **kwargs)
    
    def list_plugins(self):
        """ë“±ë¡ëœ í”ŒëŸ¬ê·¸ì¸ ëª©ë¡ ë°˜í™˜"""
        return list(self._plugins.keys())

# í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ ìƒì„±
registry = PluginRegistry()

# ë°ì½”ë ˆì´í„°ë¥¼ ì´ìš©í•œ í”ŒëŸ¬ê·¸ì¸ ë“±ë¡
@registry.register('greet')
def greet_plugin(name):
    return f"ì•ˆë…•í•˜ì„¸ìš”, {name}ë‹˜!"

@registry.register('calculate')
def calculate_plugin(operation, a, b):
    operations = {
        'add': lambda x, y: x + y,
        'subtract': lambda x, y: x - y,
        'multiply': lambda x, y: x * y,
        'divide': lambda x, y: x / y if y != 0 else 'ì˜¤ë¥˜: 0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŒ'
    }
    
    if operation not in operations:
        return f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì—°ì‚°: {operation}"
    
    return operations[operation](a, b)

@registry.register()  # ì´ë¦„ì„ ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ í•¨ìˆ˜ ì´ë¦„ ì‚¬ìš©
def weather_plugin(city):
    # ê°„ë‹¨í•œ ë‚ ì”¨ ì •ë³´ ì‹œë®¬ë ˆì´ì…˜
    weather_data = {
        'ì„œìš¸': {'temp': 22, 'condition': 'ë§‘ìŒ'},
        'ë¶€ì‚°': {'temp': 24, 'condition': 'íë¦¼'},
        'ì œì£¼': {'temp': 26, 'condition': 'ë¹„'}
    }
    
    if city in weather_data:
        data = weather_data[city]
        return f"{city}ì˜ ë‚ ì”¨: {data['temp']}Â°C, {data['condition']}"
    return f"{city}ì˜ ë‚ ì”¨ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"

# ì‚¬ìš© ì˜ˆì‹œ
print("ë°ì½”ë ˆì´í„° ê¸°ë°˜ í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ:")

# ë“±ë¡ëœ í”ŒëŸ¬ê·¸ì¸ í™•ì¸
print(f"ë“±ë¡ëœ í”ŒëŸ¬ê·¸ì¸: {registry.list_plugins()}")

# í”ŒëŸ¬ê·¸ì¸ ì‹¤í–‰
plugin_calls = [
    ('greet', ('ê¹€ì² ìˆ˜',)),
    ('calculate', ('add', 10, 5)),
    ('calculate', ('divide', 10, 0)),
    ('weather_plugin', ('ì„œìš¸',)),
    ('weather_plugin', ('ë„ì¿„',))
]

for plugin_name, args in plugin_calls:
    try:
        result = registry.execute(plugin_name, *args)
        print(f"  {plugin_name}{args} â†’ {result}")
    except Exception as e:
        print(f"  {plugin_name}{args} ì˜¤ë¥˜: {e}")

# 5. í´ë˜ìŠ¤ì˜ ëª¨ë“  ë©”ì†Œë“œë¥¼ ìë™ìœ¼ë¡œ í˜¸ì¶œ ê°€ëŠ¥í•˜ê²Œ ë§Œë“¤ê¸°
print("\n5. í´ë˜ìŠ¤ ë©”ì†Œë“œ ìë™ í˜¸ì¶œ ì‹œìŠ¤í…œ:")

class DynamicDispatcher:
    """ë™ì  ë””ìŠ¤íŒ¨ì²˜ - ë©”ì†Œë“œ ìë™ ë“±ë¡"""
    
    def __init__(self):
        self._methods = {}
        self._register_methods()
    
    def _register_methods(self):
        """í´ë˜ìŠ¤ì˜ ëª¨ë“  ê³µê°œ ë©”ì†Œë“œë¥¼ ìë™ ë“±ë¡"""
        for attr_name in dir(self):
            # ë°‘ì¤„ë¡œ ì‹œì‘í•˜ëŠ” ë¹„ê³µê°œ ë©”ì†Œë“œëŠ” ì œì™¸
            if attr_name.startswith('_'):
                continue
            
            attr = getattr(self, attr_name)
            
            # í˜¸ì¶œ ê°€ëŠ¥í•œ ë©”ì†Œë“œë§Œ ë“±ë¡
            if callable(attr):
                self._methods[attr_name] = attr
    
    def dispatch(self, method_name, *args, **kwargs):
        """ë©”ì†Œë“œ ë””ìŠ¤íŒ¨ì¹˜"""
        if method_name not in self._methods:
            raise ValueError(f"ë©”ì†Œë“œ '{method_name}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        
        return self._methods[method_name](*args, **kwargs)
    
    def list_methods(self):
        """ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ì†Œë“œ ëª©ë¡ ë°˜í™˜"""
        return list(self._methods.keys())

class TextProcessor(DynamicDispatcher):
    """í…ìŠ¤íŠ¸ ì²˜ë¦¬ê¸° - DynamicDispatcher ìƒì†"""
    
    def to_uppercase(self, text):
        return text.upper()
    
    def to_lowercase(self, text):
        return text.lower()
    
    def capitalize_words(self, text):
        return text.title()
    
    def remove_spaces(self, text):
        return ''.join(text.split())
    
    def reverse_text(self, text):
        return text[::-1]
    
    def count_words(self, text):
        return len(text.split())

# ì‚¬ìš© ì˜ˆì‹œ
processor = TextProcessor()

print("ìë™ ë“±ë¡ëœ ë©”ì†Œë“œë“¤:")
print(f"  ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ì†Œë“œ: {processor.list_methods()}")

text = "Hello World! Python Programming"
print(f"\nì›ë³¸ í…ìŠ¤íŠ¸: '{text}'")

# ë™ì ìœ¼ë¡œ ë©”ì†Œë“œ í˜¸ì¶œ
operations = ['to_uppercase', 'to_lowercase', 'capitalize_words', 
              'remove_spaces', 'reverse_text', 'count_words']

for operation in operations:
    result = processor.dispatch(operation, text)
    print(f"  {operation}: '{result}'")

# 6. ì•ˆì „í•œ ë™ì  ë©”ì†Œë“œ í˜¸ì¶œì„ ìœ„í•œ ê³ ê¸‰ ë˜í¼
print("\n6. ì•ˆì „í•œ ë™ì  ë©”ì†Œë“œ í˜¸ì¶œ ë˜í¼:")

class SafeMethodCaller:
    """
    ì•ˆì „í•œ ë™ì  ë©”ì†Œë“œ í˜¸ì¶œ ë˜í¼
    - íƒ€ì… íŒíŠ¸ ì§€ì›
    - ì¸ì ê²€ì¦
    - ì˜¤ë¥˜ ì²˜ë¦¬
    - ê²°ê³¼ ìºì‹±
    """
    
    def __init__(self, obj, cache_enabled=True):
        self._obj = obj
        self._cache_enabled = cache_enabled
        self._cache = {}
        self._call_stats = {}
    
    def call(self, method_name, *args, **kwargs):
        """
        ë©”ì†Œë“œë¥¼ ì•ˆì „í•˜ê²Œ í˜¸ì¶œ
        
        Args:
            method_name: í˜¸ì¶œí•  ë©”ì†Œë“œ ì´ë¦„
            *args: ìœ„ì¹˜ ì¸ì
            **kwargs: í‚¤ì›Œë“œ ì¸ì
        
        Returns:
            ë©”ì†Œë“œ ì‹¤í–‰ ê²°ê³¼
        
        Raises:
            MethodCallError: ë©”ì†Œë“œ í˜¸ì¶œ ì¤‘ ë°œìƒí•œ ì˜¤ë¥˜
        """
        # ìºì‹œ í‚¤ ìƒì„±
        cache_key = self._create_cache_key(method_name, args, kwargs)
        
        # ìºì‹œì— ìˆìœ¼ë©´ ë°˜í™˜
        if self._cache_enabled and cache_key in self._cache:
            return self._cache[cache_key]
        
        try:
            # ë©”ì†Œë“œ ì¡´ì¬ í™•ì¸
            if not hasattr(self._obj, method_name):
                raise AttributeError(f"ë©”ì†Œë“œ '{method_name}'ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
            
            # ë©”ì†Œë“œ ê°€ì ¸ì˜¤ê¸°
            method = getattr(self._obj, method_name)
            
            # í˜¸ì¶œ ê°€ëŠ¥í•œì§€ í™•ì¸
            if not callable(method):
                raise TypeError(f"'{method_name}'ì€ í˜¸ì¶œ ê°€ëŠ¥í•œ ë©”ì†Œë“œê°€ ì•„ë‹™ë‹ˆë‹¤")
            
            # ë©”ì†Œë“œ í˜¸ì¶œ
            result = method(*args, **kwargs)
            
            # í†µê³„ ì—…ë°ì´íŠ¸
            self._update_stats(method_name, success=True)
            
            # ìºì‹œ ì €ì¥
            if self._cache_enabled:
                self._cache[cache_key] = result
            
            return result
            
        except Exception as e:
            # í†µê³„ ì—…ë°ì´íŠ¸
            self._update_stats(method_name, success=False)
            
            # ì‚¬ìš©ì ì •ì˜ ì˜ˆì™¸ë¡œ ë˜í•‘
            raise MethodCallError(method_name, args, kwargs, e)
    
    def _create_cache_key(self, method_name, args, kwargs):
        """ìºì‹œ í‚¤ ìƒì„±"""
        import hashlib
        import pickle
        
        # ì§ë ¬í™” ê°€ëŠ¥í•œ ë°ì´í„°ë§Œ ìºì‹œ
        try:
            data = (method_name, args, tuple(sorted(kwargs.items())))
            serialized = pickle.dumps(data)
            return hashlib.md5(serialized).hexdigest()
        except (pickle.PickleError, TypeError):
            # ì§ë ¬í™” ë¶ˆê°€ëŠ¥í•˜ë©´ ìºì‹œí•˜ì§€ ì•ŠìŒ
            return None
    
    def _update_stats(self, method_name, success):
        """í˜¸ì¶œ í†µê³„ ì—…ë°ì´íŠ¸"""
        if method_name not in self._call_stats:
            self._call_stats[method_name] = {
                'total_calls': 0,
                'successful_calls': 0,
                'failed_calls': 0
            }
        
        stats = self._call_stats[method_name]
        stats['total_calls'] += 1
        
        if success:
            stats['successful_calls'] += 1
        else:
            stats['failed_calls'] += 1
    
    def get_stats(self):
        """í˜¸ì¶œ í†µê³„ ë°˜í™˜"""
        return self._call_stats.copy()
    
    def clear_cache(self):
        """ìºì‹œ ì´ˆê¸°í™”"""
        self._cache.clear()
        return "ìºì‹œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤"

class MethodCallError(Exception):
    """ë©”ì†Œë“œ í˜¸ì¶œ ì˜¤ë¥˜"""
    
    def __init__(self, method_name, args, kwargs, original_error):
        self.method_name = method_name
        self.args = args
        self.kwargs = kwargs
        self.original_error = original_error
        
        error_msg = (
            f"ë©”ì†Œë“œ '{method_name}' í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ\n"
            f"ì¸ì: args={args}, kwargs={kwargs}\n"
            f"ì›ë³¸ ì˜¤ë¥˜: {type(original_error).__name__}: {original_error}"
        )
        
        super().__init__(error_msg)

# ì‚¬ìš© ì˜ˆì‹œ
class MathOperations:
    """ìˆ˜í•™ ì—°ì‚° í´ë˜ìŠ¤"""
    
    def add(self, a: float, b: float) -> float:
        return a + b
    
    def multiply(self, a: float, b: float) -> float:
        return a * b
    
    def divide(self, a: float, b: float) -> float:
        if b == 0:
            raise ValueError("0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        return a / b

print("ì•ˆì „í•œ ë™ì  ë©”ì†Œë“œ í˜¸ì¶œ:")

math_ops = MathOperations()
caller = SafeMethodCaller(math_ops, cache_enabled=True)

# ì„±ê³µì ì¸ í˜¸ì¶œ
print("ì„±ê³µì ì¸ í˜¸ì¶œ:")
try:
    result1 = caller.call('add', 10, 5)
    print(f"  add(10, 5) = {result1}")
    
    result2 = caller.call('multiply', 10, 5)
    print(f"  multiply(10, 5) = {result2}")
    
    # ìºì‹œëœ ê²°ê³¼ ì‚¬ìš©
    result3 = caller.call('add', 10, 5)
    print(f"  add(10, 5) (ìºì‹œëœ ê²°ê³¼) = {result3}")
    
except MethodCallError as e:
    print(f"  ì˜¤ë¥˜: {e}")

# ì‹¤íŒ¨í•˜ëŠ” í˜¸ì¶œ
print("\nì‹¤íŒ¨í•˜ëŠ” í˜¸ì¶œ:")
try:
    result = caller.call('divide', 10, 0)
except MethodCallError as e:
    print(f"  ì˜ˆìƒëœ ì˜¤ë¥˜: {e.original_error}")

# ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë©”ì†Œë“œ í˜¸ì¶œ
print("\nì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë©”ì†Œë“œ í˜¸ì¶œ:")
try:
    result = caller.call('modulo', 10, 3)
except MethodCallError as e:
    print(f"  ì˜ˆìƒëœ ì˜¤ë¥˜: {e.original_error}")

# í†µê³„ í™•ì¸
print(f"\ní˜¸ì¶œ í†µê³„: {caller.get_stats()}")

# 7. ì‹ íƒìŠ¤ ìŠˆê°€ë¥¼ ìœ„í•œ __getattr__ í™œìš©
print("\n7. __getattr__ì„ ì´ìš©í•œ ë™ì  ë©”ì†Œë“œ ìƒì„±:")

class SmartAPI:
    """
    ë™ì  ë©”ì†Œë“œ ìƒì„±ì„ í†µí•œ ìœ ì—°í•œ API
    __getattr__ì„ ì´ìš©í•œ ë©”ì†Œë“œ ìƒì„±
    """
    
    def __init__(self, base_url="https://api.example.com"):
        self.base_url = base_url
        self._endpoints = {}
        self._setup_default_endpoints()
    
    def _setup_default_endpoints(self):
        """ê¸°ë³¸ ì—”ë“œí¬ì¸íŠ¸ ì„¤ì •"""
        self._endpoints.update({
            'users': '/users',
            'products': '/products',
            'orders': '/orders',
            'categories': '/categories'
        })
    
    def __getattr__(self, name):
        """
        ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì†ì„± ì ‘ê·¼ ì‹œ í˜¸ì¶œ
        ë™ì ìœ¼ë¡œ ë©”ì†Œë“œ ìƒì„±
        """
        # HTTP ë©”ì†Œë“œ ì ‘ë‘ì‚¬ í™•ì¸
        http_methods = ['get_', 'post_', 'put_', 'delete_', 'patch_']
        
        for method_prefix in http_methods:
            if name.startswith(method_prefix):
                # ì—”ë“œí¬ì¸íŠ¸ ì´ë¦„ ì¶”ì¶œ
                endpoint_name = name[len(method_prefix):]
                
                # ë™ì  ë©”ì†Œë“œ ìƒì„±
                def create_dynamic_method(method=method_prefix[:-1], endpoint=endpoint_name):
                    def method_wrapper(**params):
                        return self._make_request(method.upper(), endpoint, **params)
                    return method_wrapper
                
                return create_dynamic_method()
        
        # ê·¸ ì™¸ì˜ ê²½ìš° ê¸°ë³¸ ë™ì‘
        raise AttributeError(f"'{type(self).__name__}' ê°ì²´ì— '{name}' ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤")
    
    def _make_request(self, method, endpoint, **params):
        """HTTP ìš”ì²­ ì‹œë®¬ë ˆì´ì…˜"""
        # ì‹¤ì œ ì—”ë“œí¬ì¸íŠ¸ í™•ì¸
        actual_endpoint = self._endpoints.get(endpoint, f"/{endpoint}")
        
        url = f"{self.base_url}{actual_endpoint}"
        
        # ìš”ì²­ ì •ë³´ êµ¬ì„±
        request_info = {
            'method': method,
            'url': url,
            'params': params,
            'timestamp': datetime.now()
        }
        
        # ì‘ë‹µ ì‹œë®¬ë ˆì´ì…˜
        response = {
            'status': 'success',
            'data': {
                'endpoint': endpoint,
                'method': method,
                'params': params,
                'items': [
                    {'id': 1, 'name': f'{endpoint} í•­ëª© 1'},
                    {'id': 2, 'name': f'{endpoint} í•­ëª© 2'}
                ]
            },
            'request': request_info
        }
        
        return response
    
    def add_endpoint(self, name, path):
        """ìƒˆë¡œìš´ ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€"""
        self._endpoints[name] = path
        return self

# ì‚¬ìš© ì˜ˆì‹œ
print("__getattr__ì„ ì´ìš©í•œ ë™ì  API:")

api = SmartAPI(base_url="https://api.myservice.com")

# ì¶”ê°€ ì—”ë“œí¬ì¸íŠ¸ ë“±ë¡
api.add_endpoint('customers', '/v2/customers')

# ë™ì ìœ¼ë¡œ ìƒì„±ëœ ë©”ì†Œë“œ í˜¸ì¶œ
print("ë™ì  ë©”ì†Œë“œ í˜¸ì¶œ:")
try:
    # GET ìš”ì²­
    users_response = api.get_users(page=1, limit=10)
    print(f"  get_users() â†’ í•­ëª© ìˆ˜: {len(users_response['data']['items'])}")
    
    # POST ìš”ì²­
    new_product = api.post_products(name="ìƒˆ ì œí’ˆ", price=10000)
    print(f"  post_products() â†’ ìƒíƒœ: {new_product['status']}")
    
    # PUT ìš”ì²­
    updated_order = api.put_orders(order_id=123, status="shipped")
    print(f"  put_orders() â†’ ì—”ë“œí¬ì¸íŠ¸: {updated_order['data']['endpoint']}")
    
    # DELETE ìš”ì²­
    delete_result = api.delete_categories(category_id=456)
    print(f"  delete_categories() â†’ ë©”ì†Œë“œ: {delete_result['data']['method']}")
    
    # ë™ì ìœ¼ë¡œ ì¶”ê°€ëœ ì—”ë“œí¬ì¸íŠ¸
    customers = api.get_customers(region="Asia")
    print(f"  get_customers() â†’ íŒŒë¼ë¯¸í„°: {customers['data']['params']}")
    
except AttributeError as e:
    print(f"  ì˜¤ë¥˜: {e}")
```

## ë¹„ì§€í„° íŒ¨í„´ êµ¬í˜„

### ì „í†µì ì¸ ë¹„ì§€í„° íŒ¨í„´ êµ¬í˜„
```python
print("\n" + "="*60)
print("ë¹„ì§€í„° íŒ¨í„´ êµ¬í˜„")
print("="*60)

# 1. ì „í†µì ì¸ ë¹„ì§€í„° íŒ¨í„´ (ì´ì¤‘ ë””ìŠ¤íŒ¨ì¹˜)
print("1. ì „í†µì ì¸ ë¹„ì§€í„° íŒ¨í„´ (ì´ì¤‘ ë””ìŠ¤íŒ¨ì¹˜):")

# ë°©ë¬¸ ê°€ëŠ¥í•œ ìš”ì†Œë“¤ (Element í´ë˜ìŠ¤ë“¤)
class DocumentElement:
    """ë¬¸ì„œ ìš”ì†Œ ë² ì´ìŠ¤ í´ë˜ìŠ¤"""
    
    def accept(self, visitor):
        """ë¹„ì§€í„°ë¥¼ ë°›ì•„ë“¤ì´ëŠ” ë©”ì†Œë“œ"""
        raise NotImplementedError("ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤")

class Header(DocumentElement):
    """ë¬¸ì„œ í—¤ë”"""
    
    def __init__(self, text, level=1):
        self.text = text
        self.level = level
    
    def accept(self, visitor):
        return visitor.visit_header(self)
    
    def __str__(self):
        return f"Header(level={self.level}, text='{self.text}')"

class Paragraph(DocumentElement):
    """ë¬¸ì„œ ë‹¨ë½"""
    
    def __init__(self, text):
        self.text = text
        self.lines = text.split('\n')
    
    def accept(self, visitor):
        return visitor.visit_paragraph(self)
    
    def __str__(self):
        return f"Paragraph(text='{self.text[:30]}...')"

class List(DocumentElement):
    """ë¬¸ì„œ ëª©ë¡"""
    
    def __init__(self, items, ordered=False):
        self.items = items
        self.ordered = ordered
    
    def accept(self, visitor):
        return visitor.visit_list(self)
    
    def __str__(self):
        return f"List(ordered={self.ordered}, items={len(self.items)})"

class Image(DocumentElement):
    """ì´ë¯¸ì§€ ìš”ì†Œ"""
    
    def __init__(self, src, alt="", width=None, height=None):
        self.src = src
        self.alt = alt
        self.width = width
        self.height = height
    
    def accept(self, visitor):
        return visitor.visit_image(self)
    
    def __str__(self):
        return f"Image(src='{self.src}', alt='{self.alt}')"

# ë¹„ì§€í„° ì¸í„°í˜ì´ìŠ¤
class DocumentVisitor:
    """ë¬¸ì„œ ë¹„ì§€í„° ì¸í„°í˜ì´ìŠ¤"""
    
    def visit_header(self, header):
        raise NotImplementedError()
    
    def visit_paragraph(self, paragraph):
        raise NotImplementedError()
    
    def visit_list(self, list_item):
        raise NotImplementedError()
    
    def visit_image(self, image):
        raise NotImplementedError()

# êµ¬ì²´ì ì¸ ë¹„ì§€í„° êµ¬í˜„ë“¤
class HTMLExportVisitor(DocumentVisitor):
    """HTML ë‚´ë³´ë‚´ê¸° ë¹„ì§€í„°"""
    
    def __init__(self):
        self.output = []
        self.indent_level = 0
    
    def _indent(self):
        return "  " * self.indent_level
    
    def visit_header(self, header):
        tag = f"h{header.level}"
        html = f"{self._indent()}<{tag}>{header.text}</{tag}>"
        self.output.append(html)
        return html
    
    def visit_paragraph(self, paragraph):
        lines_html = "<br>\n".join(paragraph.lines)
        html = f"{self._indent()}<p>\n{self._indent()}  {lines_html}\n{self._indent()}</p>"
        self.output.append(html)
        return html
    
    def visit_list(self, list_item):
        tag = "ol" if list_item.ordered else "ul"
        
        self.output.append(f"{self._indent()}<{tag}>")
        self.indent_level += 1
        
        for item in list_item.items:
            html = f"{self._indent()}<li>{item}</li>"
            self.output.append(html)
        
        self.indent_level -= 1
        self.output.append(f"{self._indent()}</{tag}>")
        
        return "\n".join(self.output[-len(list_item.items)-2:])
    
    def visit_image(self, image):
        attrs = []
        if image.width:
            attrs.append(f'width="{image.width}"')
        if image.height:
            attrs.append(f'height="{image.height}"')
        
        attr_str = " ".join(attrs)
        html = f'{self._indent()}<img src="{image.src}" alt="{image.alt}" {attr_str}>'
        self.output.append(html)
        return html
    
    def get_full_html(self):
        """ì „ì²´ HTML ë¬¸ì„œ ìƒì„±"""
        body = "\n".join(self.output)
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>Exported Document</title>
</head>
<body>
{body}
</body>
</html>"""

class TextExportVisitor(DocumentVisitor):
    """í…ìŠ¤íŠ¸ ë‚´ë³´ë‚´ê¸° ë¹„ì§€í„°"""
    
    def __init__(self, width=80):
        self.output = []
        self.width = width
    
    def visit_header(self, header):
        text = f"{'#' * header.level} {header.text}"
        self.output.append(text)
        self.output.append("")  # ë¹ˆ ì¤„
        return text
    
    def visit_paragraph(self, paragraph):
        # í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ
        import textwrap
        
        wrapped_lines = []
        for line in paragraph.lines:
            wrapped = textwrap.wrap(line, width=self.width)
            wrapped_lines.extend(wrapped)
        
        text = "\n".join(wrapped_lines)
        self.output.append(text)
        self.output.append("")  # ë¹ˆ ì¤„
        return text
    
    def visit_list(self, list_item):
        lines = []
        
        for i, item in enumerate(list_item.items):
            if list_item.ordered:
                prefix = f"{i+1}."
            else:
                prefix = "â€¢"
            
            lines.append(f"{prefix} {item}")
        
        text = "\n".join(lines)
        self.output.append(text)
        self.output.append("")  # ë¹ˆ ì¤„
        return text
    
    def visit_image(self, image):
        text = f"[ì´ë¯¸ì§€: {image.alt}]"
        self.output.append(text)
        self.output.append("")  # ë¹ˆ ì¤„
        return text
    
    def get_full_text(self):
        """ì „ì²´ í…ìŠ¤íŠ¸ ë¬¸ì„œ ìƒì„±"""
        return "\n".join(self.output)

class DocumentStatisticsVisitor(DocumentVisitor):
    """ë¬¸ì„œ í†µê³„ ìˆ˜ì§‘ ë¹„ì§€í„°"""
    
    def __init__(self):
        self.stats = {
            'total_elements': 0,
            'headers': 0,
            'paragraphs': 0,
            'lists': 0,
            'images': 0,
            'total_chars': 0,
            'total_words': 0
        }
    
    def visit_header(self, header):
        self.stats['total_elements'] += 1
        self.stats['headers'] += 1
        self.stats['total_chars'] += len(header.text)
        self.stats['total_words'] += len(header.text.split())
        return self.stats
    
    def visit_paragraph(self, paragraph):
        self.stats['total_elements'] += 1
        self.stats['paragraphs'] += 1
        self.stats['total_chars'] += len(paragraph.text)
        self.stats['total_words'] += len(paragraph.text.split())
        return self.stats
    
    def visit_list(self, list_item):
        self.stats['total_elements'] += 1
        self.stats['lists'] += 1
        
        for item in list_item.items:
            self.stats['total_chars'] += len(item)
            self.stats['total_words'] += len(item.split())
        
        return self.stats
    
    def visit_image(self, image):
        self.stats['total_elements'] += 1
        self.stats['images'] += 1
        return self.stats
    
    def get_stats(self):
        """í†µê³„ ë°˜í™˜"""
        return dict(self.stats)

# ì‚¬ìš© ì˜ˆì‹œ
print("ì „í†µì ì¸ ë¹„ì§€í„° íŒ¨í„´ ì˜ˆì œ:")

# ë¬¸ì„œ ìƒì„±
document = [
    Header("Python ë¹„ì§€í„° íŒ¨í„´", level=1),
    Paragraph("ë¹„ì§€í„° íŒ¨í„´ì€ ì•Œê³ ë¦¬ì¦˜ì„ ê°ì²´ êµ¬ì¡°ì—ì„œ ë¶„ë¦¬ì‹œí‚¤ëŠ” í–‰ë™ ë””ìì¸ íŒ¨í„´ì…ë‹ˆë‹¤.\nì´ íŒ¨í„´ì„ ì‚¬ìš©í•˜ë©´ ê°ì²´ êµ¬ì¡°ë¥¼ ë³€ê²½í•˜ì§€ ì•Šê³ ë„ ìƒˆë¡œìš´ ì—°ì‚°ì„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."),
    Header("ì¥ì ", level=2),
    List([
        "ê°ì²´ êµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ë¶„ë¦¬",
        "ìƒˆë¡œìš´ ì—°ì‚° ì¶”ê°€ ìš©ì´",
        "ê´€ë ¨ëœ ì—°ì‚°ë“¤ì„ í•œ ê³³ì— ëª¨ìŒ",
        "ê°ì²´ êµ¬ì¡°ë¥¼ ìˆœíšŒí•˜ë©´ì„œ ì‘ì—… ìˆ˜í–‰"
    ], ordered=True),
    Image("visitor_pattern.png", alt="ë¹„ì§€í„° íŒ¨í„´ ë‹¤ì´ì–´ê·¸ë¨"),
    Paragraph("ì´ íŒ¨í„´ì€ ì»´íŒŒì¼ëŸ¬, ë¬¸ì„œ ì²˜ë¦¬ê¸°, GUI ì»´í¬ë„ŒíŠ¸ ë“±ì—ì„œ ë„ë¦¬ ì‚¬ìš©ë©ë‹ˆë‹¤.")
]

print("\në¬¸ì„œ ìš”ì†Œë“¤:")
for i, element in enumerate(document):
    print(f"  {i+1}. {element}")

# HTML ë‚´ë³´ë‚´ê¸°
print("\nHTML ë‚´ë³´ë‚´ê¸°:")
html_visitor = HTMLExportVisitor()
for element in document:
    element.accept(html_visitor)

html_output = html_visitor.get_full_html()
print(f"HTML ê¸¸ì´: {len(html_output)} ë¬¸ì")
print(f"HTML ë¯¸ë¦¬ë³´ê¸°:\n{html_output[:200]}...")

# í…ìŠ¤íŠ¸ ë‚´ë³´ë‚´ê¸°
print("\ní…ìŠ¤íŠ¸ ë‚´ë³´ë‚´ê¸°:")
text_visitor = TextExportVisitor(width=50)
for element in document:
    element.accept(text_visitor)

text_output = text_visitor.get_full_text()
print(f"í…ìŠ¤íŠ¸ ì¶œë ¥:\n{text_output}")

# í†µê³„ ìˆ˜ì§‘
print("\në¬¸ì„œ í†µê³„:")
stats_visitor = DocumentStatisticsVisitor()
for element in document:
    element.accept(stats_visitor)

stats = stats_visitor.get_stats()
for key, value in stats.items():
    print(f"  {key}: {value}")

# 2. ë‹¨ì¼ ë©”ì†Œë“œ ë¹„ì§€í„° íŒ¨í„´ (íŒŒì´ì¬ìŠ¤íƒ€ì¼)
print("\n2. ë‹¨ì¼ ë©”ì†Œë“œ ë¹„ì§€í„° íŒ¨í„´ (íŒŒì´ì¬ìŠ¤íƒ€ì¼):")

class PythonicVisitor:
    """
    íŒŒì´ì¬ìŠ¤íƒ€ì¼ ë¹„ì§€í„°
    ë‹¨ì¼ visit ë©”ì†Œë“œì™€ íƒ€ì… ê¸°ë°˜ ë””ìŠ¤íŒ¨ì¹˜
    """
    
    def visit(self, element, *args, **kwargs):
        """
        ìš”ì†Œ ë°©ë¬¸ - íƒ€ì…ì— ë”°ë¼ ì ì ˆí•œ í•¸ë“¤ëŸ¬ í˜¸ì¶œ
        """
        # ìš”ì†Œ íƒ€ì…ì— ë”°ë¥¸ ë©”ì†Œë“œ ì´ë¦„ ìƒì„±
        element_type = type(element).__name__.lower()
        method_name = f"visit_{element_type}"
        
        # ì ì ˆí•œ í•¸ë“¤ëŸ¬ ì°¾ê¸°
        if hasattr(self, method_name):
            handler = getattr(self, method_name)
            return handler(element, *args, **kwargs)
        else:
            # ê¸°ë³¸ í•¸ë“¤ëŸ¬
            return self.default_visit(element, *args, **kwargs)
    
    def default_visit(self, element, *args, **kwargs):
        """ê¸°ë³¸ ë°©ë¬¸ í•¸ë“¤ëŸ¬"""
        return f"ë°©ë¬¸: {type(element).__name__}"

class JSONExportVisitor(PythonicVisitor):
    """JSON ë‚´ë³´ë‚´ê¸° ë¹„ì§€í„°"""
    
    def __init__(self):
        self.data = {
            'document': {
                'elements': [],
                'metadata': {
                    'exported_at': datetime.now().isoformat(),
                    'version': '1.0'
                }
            }
        }
    
    def visit_header(self, element, *args, **kwargs):
        element_data = {
            'type': 'header',
            'level': element.level,
            'text': element.text,
            'char_count': len(element.text),
            'word_count': len(element.text.split())
        }
        self.data['document']['elements'].append(element_data)
        return element_data
    
    def visit_paragraph(self, element, *args, **kwargs):
        element_data = {
            'type': 'paragraph',
            'text': element.text,
            'lines': len(element.lines),
            'char_count': len(element.text),
            'word_count': len(element.text.split())
        }
        self.data['document']['elements'].append(element_data)
        return element_data
    
    def visit_list(self, element, *args, **kwargs):
        element_data = {
            'type': 'list',
            'ordered': element.ordered,
            'item_count': len(element.items),
            'items': element.items
        }
        self.data['document']['elements'].append(element_data)
        return element_data
    
    def visit_image(self, element, *args, **kwargs):
        element_data = {
            'type': 'image',
            'src': element.src,
            'alt': element.alt,
            'width': element.width,
            'height': element.height
        }
        self.data['document']['elements'].append(element_data)
        return element_data
    
    def get_json(self, indent=2):
        """JSON ë¬¸ìì—´ ë°˜í™˜"""
        import json
        return json.dumps(self.data, ensure_ascii=False, indent=indent)

print("íŒŒì´ì¬ìŠ¤íƒ€ì¼ ë¹„ì§€í„° íŒ¨í„´:")

# JSON ë‚´ë³´ë‚´ê¸°
json_visitor = JSONExportVisitor()

for element in document:
    result = json_visitor.visit(element)
    print(f"  ë°©ë¬¸: {type(element).__name__} â†’ {result['type']}")

json_output = json_visitor.get_json()
print(f"\nJSON ì¶œë ¥ (ì²« 200ì):\n{json_output[:200]}...")
```

## ì¬ê·€ ì—†ì´ ë¹„ì§€í„° íŒ¨í„´ êµ¬í˜„

### ë°˜ë³µì  ë¹„ì§€í„° íŒ¨í„´ êµ¬í˜„
```python
print("\n" + "="*60)
print("ì¬ê·€ ì—†ì´ ë¹„ì§€í„° íŒ¨í„´ êµ¬í˜„")
print("="*60)

# 1. ìŠ¤íƒì„ ì´ìš©í•œ ë°˜ë³µì  íŠ¸ë¦¬ ìˆœíšŒ
print("1. ìŠ¤íƒì„ ì´ìš©í•œ ë°˜ë³µì  íŠ¸ë¦¬ ìˆœíšŒ:")

class TreeNode:
    """íŠ¸ë¦¬ ë…¸ë“œ"""
    
    def __init__(self, value, children=None):
        self.value = value
        self.children = children or []
    
    def add_child(self, child):
        self.children.append(child)
        return self
    
    def __str__(self):
        return f"TreeNode({self.value}, children={len(self.children)})"

class IterativeTreeVisitor:
    """ë°˜ë³µì  íŠ¸ë¦¬ ë°©ë¬¸ì"""
    
    def __init__(self):
        self._stack = []
        self._visited = set()
        self._results = []
    
    def visit_tree(self, root):
        """íŠ¸ë¦¬ ë°©ë¬¸ (ì¬ê·€ ì—†ì´)"""
        if not root:
            return []
        
        # ìŠ¤íƒì— ë£¨íŠ¸ ë…¸ë“œ ì¶”ê°€
        self._stack.append(('enter', root))
        
        while self._stack:
            action, node = self._stack.pop()
            
            # ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œ ê±´ë„ˆë›°ê¸°
            if id(node) in self._visited:
                continue
            
            if action == 'enter':
                # ë…¸ë“œ ë°©ë¬¸ ì „ì²˜ë¦¬
                self._visited.add(id(node))
                
                # ìì‹ ë…¸ë“œë“¤ì„ ì—­ìˆœìœ¼ë¡œ ìŠ¤íƒì— ì¶”ê°€ (ì •ë°©í–¥ ìˆœíšŒë¥¼ ìœ„í•´)
                for child in reversed(node.children):
                    self._stack.append(('enter', child))
                
                # í˜„ì¬ ë…¸ë“œì˜ 'exit' ì‘ì—… ìŠ¤íƒì— ì¶”ê°€
                self._stack.append(('exit', node))
                
                # ë…¸ë“œ ë°©ë¬¸ ì²˜ë¦¬
                result = self.process_node(node, 'enter')
                if result is not None:
                    self._results.append(result)
            
            elif action == 'exit':
                # ë…¸ë“œ ë°©ë¬¸ í›„ì²˜ë¦¬
                result = self.process_node(node, 'exit')
                if result is not None:
                    self._results.append(result)
        
        return self._results
    
    def process_node(self, node, action):
        """ë…¸ë“œ ì²˜ë¦¬ (ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œ)"""
        # ê¸°ë³¸ êµ¬í˜„
        return {
            'node': node.value,
            'action': action,
            'timestamp': datetime.now()
        }

class DirectoryTreeVisitor(IterativeTreeVisitor):
    """ë””ë ‰í† ë¦¬ íŠ¸ë¦¬ ë°©ë¬¸ì"""
    
    def __init__(self):
        super().__init__()
        self._depth = 0
        self._indent_cache = {}
    
    def _get_indent(self, depth):
        """ë“¤ì—¬ì“°ê¸° ë¬¸ìì—´ ê°€ì ¸ì˜¤ê¸°"""
        if depth not in self._indent_cache:
            self._indent_cache[depth] = "  " * depth
        return self._indent_cache[depth]
    
    def process_node(self, node, action):
        """ë””ë ‰í† ë¦¬ ë…¸ë“œ ì²˜ë¦¬"""
        if action == 'enter':
            # ë””ë ‰í† ë¦¬ ì§„ì…
            indent = self._get_indent(self._depth)
            self._depth += 1
            return f"{indent}ğŸ“ {node.value}/"
        
        elif action == 'exit':
            # ë””ë ‰í† ë¦¬ ì¢…ë£Œ
            self._depth -= 1
            return None  # exit ë‹¨ê³„ì—ì„œëŠ” ê²°ê³¼ ë°˜í™˜ ì•ˆí•¨

class SizeCalculatorVisitor(IterativeTreeVisitor):
    """í¬ê¸° ê³„ì‚° ë°©ë¬¸ì"""
    
    def __init__(self):
        super().__init__()
        self._size_stack = []  # ë””ë ‰í† ë¦¬ í¬ê¸° ê³„ì‚°ì„ ìœ„í•œ ìŠ¤íƒ
    
    def process_node(self, node, action):
        """í¬ê¸° ê³„ì‚°"""
        if action == 'enter':
            # ë””ë ‰í† ë¦¬ ì§„ì… - í¬ê¸° 0ìœ¼ë¡œ ì´ˆê¸°í™”
            self._size_stack.append(0)
            return None
        
        elif action == 'exit':
            # ë””ë ‰í† ë¦¬ ì¢…ë£Œ - ì „ì²´ í¬ê¸° ê³„ì‚°
            dir_size = self._size_stack.pop()
            
            # íŒŒì¼ ë…¸ë“œì¸ ê²½ìš° (ìì‹ì´ ì—†ëŠ” ê²½ìš°)
            if not node.children:
                file_size = len(node.value) * 10  # íŒŒì¼ í¬ê¸° ì‹œë®¬ë ˆì´ì…˜
                dir_size += file_size
                
                # ìƒìœ„ ë””ë ‰í† ë¦¬ í¬ê¸°ì— ì¶”ê°€
                if self._size_stack:
                    self._size_stack[-1] += file_size
                
                return f"íŒŒì¼: {node.value} ({file_size} bytes)"
            else:
                # ë””ë ‰í† ë¦¬ì¸ ê²½ìš°
                # ìƒìœ„ ë””ë ‰í† ë¦¬ í¬ê¸°ì— ì¶”ê°€
                if self._size_stack:
                    self._size_stack[-1] += dir_size
                
                return f"ë””ë ‰í† ë¦¬: {node.value}/ (ì´ {dir_size} bytes)"

# ë””ë ‰í† ë¦¬ íŠ¸ë¦¬ ìƒì„±
print("ë””ë ‰í† ë¦¬ íŠ¸ë¦¬ êµ¬ì¡°:")
root = TreeNode("root")
docs = TreeNode("docs")
src = TreeNode("src")
tests = TreeNode("tests")

docs.add_child(TreeNode("api.md"))
docs.add_child(TreeNode("readme.md"))

src.add_child(TreeNode("main.py"))
src.add_child(TreeNode("utils.py"))

lib = TreeNode("lib")
lib.add_child(TreeNode("math.py"))
lib.add_child(TreeNode("string.py"))
src.add_child(lib)

tests.add_child(TreeNode("test_main.py"))
tests.add_child(TreeNode("test_utils.py"))

root.add_child(docs)
root.add_child(src)
root.add_child(tests)

# ë°˜ë³µì  ë°©ë¬¸ í…ŒìŠ¤íŠ¸
print("\në””ë ‰í† ë¦¬ íŠ¸ë¦¬ ì¶œë ¥:")
dir_visitor = DirectoryTreeVisitor()
dir_results = dir_visitor.visit_tree(root)

for result in dir_results:
    print(f"  {result}")

print("\ní¬ê¸° ê³„ì‚°:")
size_visitor = SizeCalculatorVisitor()
size_results = size_visitor.visit_tree(root)

for result in size_results:
    if result:
        print(f"  {result}")

# 2. íë¥¼ ì´ìš©í•œ ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS) ë¹„ì§€í„°
print("\n2. íë¥¼ ì´ìš©í•œ ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS) ë¹„ì§€í„°:")

from collections import deque

class BFSVisitor:
    """ë„ˆë¹„ ìš°ì„  íƒìƒ‰ ë°©ë¬¸ì"""
    
    def __init__(self):
        self._queue = deque()
        self._visited = set()
        self._results = []
        self._level = 0
    
    def visit_graph(self, start_node, get_neighbors_func):
        """
        ê·¸ë˜í”„ ë„ˆë¹„ ìš°ì„  íƒìƒ‰
        
        Args:
            start_node: ì‹œì‘ ë…¸ë“œ
            get_neighbors_func: ë…¸ë“œì˜ ì´ì›ƒì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
        """
        if not start_node:
            return []
        
        # ì‹œì‘ ë…¸ë“œ íì— ì¶”ê°€
        self._queue.append((0, start_node))  # (ë ˆë²¨, ë…¸ë“œ)
        
        while self._queue:
            level, node = self._queue.popleft()
            
            # ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œ ê±´ë„ˆë›°ê¸°
            node_id = id(node)
            if node_id in self._visited:
                continue
            
            # ë…¸ë“œ ë°©ë¬¸ ì²˜ë¦¬
            self._visited.add(node_id)
            result = self.process_node(node, level)
            self._results.append(result)
            
            # ì´ì›ƒ ë…¸ë“œë“¤ íì— ì¶”ê°€
            neighbors = get_neighbors_func(node)
            for neighbor in neighbors:
                if id(neighbor) not in self._visited:
                    self._queue.append((level + 1, neighbor))
        
        return self._results
    
    def process_node(self, node, level):
        """ë…¸ë“œ ì²˜ë¦¬ (ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œ)"""
        # ê¸°ë³¸ êµ¬í˜„
        return {
            'node': str(node),
            'level': level
        }

class SocialNetworkBFSVisitor(BFSVisitor):
    """ì†Œì…œ ë„¤íŠ¸ì›Œí¬ BFS ë°©ë¬¸ì"""
    
    def __init__(self):
        super().__init__()
        self._user_details = {}
    
    def process_node(self, user, level):
        """ì‚¬ìš©ì ì²˜ë¦¬"""
        # ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì‹œë®¬ë ˆì´ì…˜)
        if user not in self._user_details:
            self._user_details[user] = {
                'friends_count': hash(user) % 100,
                'activity_score': hash(user) % 50 + 50
            }
        
        details = self._user_details[user]
        
        # ê´€ê³„ ìˆ˜ì¤€ì— ë”°ë¥¸ ì ‘ë‘ì‚¬
        if level == 0:
            relation = "ë³¸ì¸"
        elif level == 1:
            relation = "ì¹œêµ¬"
        elif level == 2:
            relation = "ì¹œêµ¬ì˜ ì¹œêµ¬"
        else:
            relation = f"{level}ì´Œ ì§€ì¸"
        
        return {
            'user': user,
            'relation': relation,
            'level': level,
            'friends': details['friends_count'],
            'activity': details['activity_score']
        }

print("ì†Œì…œ ë„¤íŠ¸ì›Œí¬ BFS íƒìƒ‰:")

# ì†Œì…œ ë„¤íŠ¸ì›Œí¬ ê·¸ë˜í”„ ìƒì„±
class User:
    def __init__(self, name):
        self.name = name
    
    def __str__(self):
        return self.name
    
    def __repr__(self):
        return f"User('{self.name}')"

# ì‚¬ìš©ìë“¤ ìƒì„±
users = {
    'alice': User("Alice"),
    'bob': User("Bob"),
    'charlie': User("Charlie"),
    'diana': User("Diana"),
    'eve': User("Eve"),
    'frank': User("Frank"),
    'grace': User("Grace")
}

# ì¹œêµ¬ ê´€ê³„ ì •ì˜
friendships = {
    users['alice']: [users['bob'], users['charlie'], users['diana']],
    users['bob']: [users['alice'], users['eve']],
    users['charlie']: [users['alice'], users['diana'], users['frank']],
    users['diana']: [users['alice'], users['charlie'], users['grace']],
    users['eve']: [users['bob']],
    users['frank']: [users['charlie']],
    users['grace']: [users['diana']]
}

def get_friends(user):
    """ì‚¬ìš©ìì˜ ì¹œêµ¬ ëª©ë¡ ë°˜í™˜"""
    return friendships.get(user, [])

# BFS íƒìƒ‰ ì‹¤í–‰
bfs_visitor = SocialNetworkBFSVisitor()
results = bfs_visitor.visit_graph(users['alice'], get_friends)

print("ë„¤íŠ¸ì›Œí¬ íƒìƒ‰ ê²°ê³¼:")
for result in results:
    print(f"  [{result['relation']}] {result['user']} "
          f"(ì¹œêµ¬ ìˆ˜: {result['friends']}, í™œë™ ì ìˆ˜: {result['activity']})")

# 3. ì‘ì—… íë¥¼ ì´ìš©í•œ ë³‘ë ¬ ë¹„ì§€í„° íŒ¨í„´
print("\n3. ì‘ì—… íë¥¼ ì´ìš©í•œ ë³‘ë ¬ ë¹„ì§€í„° íŒ¨í„´:")

import queue
import threading
import time
from concurrent.futures import ThreadPoolExecutor

class ParallelVisitor:
    """ë³‘ë ¬ ë°©ë¬¸ì íŒ¨í„´"""
    
    def __init__(self, max_workers=4):
        self.max_workers = max_workers
        self.task_queue = queue.Queue()
        self.result_queue = queue.Queue()
        self.visited_lock = threading.Lock()
        self.visited = set()
        self.results = []
        self.active_workers = 0
    
    def visit_parallel(self, start_nodes):
        """
        ë³‘ë ¬ ë°©ë¬¸ ì‹œì‘
        
        Args:
            start_nodes: ì‹œì‘ ë…¸ë“œ ëª©ë¡
        """
        # ì‹œì‘ ë…¸ë“œë“¤ì„ ì‘ì—… íì— ì¶”ê°€
        for node in start_nodes:
            self.task_queue.put(('process', node, 0))  # (ì‘ì—…íƒ€ì…, ë…¸ë“œ, ê¹Šì´)
        
        # ì›Œì»¤ ìŠ¤ë ˆë“œ ì‹œì‘
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = []
            
            for _ in range(self.max_workers):
                future = executor.submit(self._worker)
                futures.append(future)
            
            # ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
            self.task_queue.join()
            
            # ì›Œì»¤ ì¢…ë£Œ ì‹ í˜¸ ì „ë‹¬
            for _ in range(self.max_workers):
                self.task_queue.put(('stop', None, None))
            
            # ê²°ê³¼ ìˆ˜ì§‘
            while not self.result_queue.empty():
                self.results.append(self.result_queue.get())
        
        return self.results
    
    def _worker(self):
        """ì›Œì»¤ ìŠ¤ë ˆë“œ í•¨ìˆ˜"""
        while True:
            try:
                task_type, node, depth = self.task_queue.get(timeout=1)
                
                if task_type == 'stop':
                    self.task_queue.task_done()
                    break
                
                elif task_type == 'process':
                    # ë°©ë¬¸ ì—¬ë¶€ í™•ì¸ (ìŠ¤ë ˆë“œ ì•ˆì „í•˜ê²Œ)
                    node_id = id(node)
                    
                    with self.visited_lock:
                        if node_id in self.visited:
                            self.task_queue.task_done()
                            continue
                        self.visited.add(node_id)
                    
                    # ë…¸ë“œ ì²˜ë¦¬
                    result = self.process_node(node, depth)
                    if result:
                        self.result_queue.put(result)
                    
                    # í•˜ìœ„ ë…¸ë“œë“¤ íƒìƒ‰
                    child_nodes = self.get_child_nodes(node)
                    for child in child_nodes:
                        child_id = id(child)
                        
                        with self.visited_lock:
                            if child_id not in self.visited:
                                self.task_queue.put(('process', child, depth + 1))
                    
                    self.task_queue.task_done()
            
            except queue.Empty:
                continue
            except Exception as e:
                print(f"ì›Œì»¤ ì˜¤ë¥˜: {e}")
                self.task_queue.task_done()
    
    def process_node(self, node, depth):
        """ë…¸ë“œ ì²˜ë¦¬ (ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œ)"""
        # ê¸°ë³¸ êµ¬í˜„
        time.sleep(0.01)  # ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
        return {
            'node': str(node),
            'depth': depth,
            'thread': threading.current_thread().name,
            'timestamp': time.time()
        }
    
    def get_child_nodes(self, node):
        """ìì‹ ë…¸ë“œ ê°€ì ¸ì˜¤ê¸° (ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œ)"""
        # ê¸°ë³¸ êµ¬í˜„ - ìì‹ì´ ì—†ëŠ” ê²ƒìœ¼ë¡œ ê°€ì •
        return []

class WebCrawlerVisitor(ParallelVisitor):
    """ì›¹ í¬ë¡¤ëŸ¬ ë³‘ë ¬ ë°©ë¬¸ì"""
    
    def __init__(self, max_workers=4):
        super().__init__(max_workers)
        self.domain = "example.com"
    
    def process_node(self, url, depth):
        """URL ì²˜ë¦¬ (ì›¹ í˜ì´ì§€ í¬ë¡¤ë§ ì‹œë®¬ë ˆì´ì…˜)"""
        # í¬ë¡¤ë§ ì‹œë®¬ë ˆì´ì…˜
        time.sleep(0.05)
        
        # í˜ì´ì§€ ë‚´ìš© ì‹œë®¬ë ˆì´ì…˜
        content_length = hash(url) % 10000 + 1000
        
        return {
            'url': url,
            'depth': depth,
            'content_length': content_length,
            'status': 'success',
            'crawled_by': threading.current_thread().name,
            'timestamp': time.time()
        }
    
    def get_child_nodes(self, url):
        """ë§í¬ ì¶”ì¶œ ì‹œë®¬ë ˆì´ì…˜"""
        # ë§í¬ ì‹œë®¬ë ˆì´ì…˜
        base_url = url.rstrip('/')
        links = []
        
        # ê°™ì€ ë„ë©”ì¸ ë‚´ì˜ ë§í¬ë§Œ ì¶”ì¶œ
        if self.domain in url:
            # ê¹Šì´ ì œí•œ (ìµœëŒ€ 3ë‹¨ê³„)
            depth = int(url.split('#')[0].split('/')[-1]) if '#' in url else 0
            
            if depth < 3:
                links = [
                    f"{base_url}/page{depth+1}_1",
                    f"{base_url}/page{depth+1}_2",
                    f"{base_url}/page{depth+1}_3"
                ]
        
        return links

print("ë³‘ë ¬ ì›¹ í¬ë¡¤ëŸ¬ ì‹œë®¬ë ˆì´ì…˜:")

# ì‹œì‘ URLë“¤
start_urls = [
    "https://example.com/page1",
    "https://example.com/page2",
    "https://example.com/page3"
]

# ë³‘ë ¬ í¬ë¡¤ë§ ì‹¤í–‰
print("í¬ë¡¤ë§ ì‹œì‘...")
start_time = time.time()

crawler = WebCrawlerVisitor(max_workers=3)
results = crawler.visit_parallel(start_urls)

end_time = time.time()
print(f"í¬ë¡¤ë§ ì™„ë£Œ: {len(results)} í˜ì´ì§€, ì†Œìš”ì‹œê°„: {end_time - start_time:.2f}ì´ˆ")

# ê²°ê³¼ ìš”ì•½
print("\ní¬ë¡¤ë§ ê²°ê³¼ ìš”ì•½:")
for result in results[:5]:  # ì²˜ìŒ 5ê°œ ê²°ê³¼ë§Œ ì¶œë ¥
    print(f"  {result['url']} (ê¹Šì´: {result['depth']}, "
          f"í¬ê¸°: {result['content_length']}, "
          f"ìŠ¤ë ˆë“œ: {result['crawled_by']})")

print(f"\nì´ {len(results)} í˜ì´ì§€ í¬ë¡¤ë§ë¨")

# 4. ì œë„ˆë ˆì´í„°ë¥¼ ì´ìš©í•œ ì§€ì—° í‰ê°€ ë¹„ì§€í„°
print("\n4. ì œë„ˆë ˆì´í„°ë¥¼ ì´ìš©í•œ ì§€ì—° í‰ê°€ ë¹„ì§€í„°:")

class LazyVisitor:
    """ì§€ì—° í‰ê°€ ë°©ë¬¸ì (ì œë„ˆë ˆì´í„° ê¸°ë°˜)"""
    
    def __init__(self):
        self._stack = []
    
    def visit_iterative(self, root):
        """ë°˜ë³µì  ë°©ë¬¸ ì œë„ˆë ˆì´í„°"""
        if not root:
            return
        
        # ìŠ¤íƒ ì´ˆê¸°í™”
        self._stack.append(root)
        
        while self._stack:
            node = self._stack.pop()
            
            # ë…¸ë“œ ì²˜ë¦¬ (ì œë„ˆë ˆì´í„°ë¡œ ê²°ê³¼ ìƒì„±)
            result = self.process_node(node)
            if result is not None:
                yield result
            
            # ìì‹ ë…¸ë“œë“¤ ìŠ¤íƒì— ì¶”ê°€ (ì›í•˜ëŠ” ìˆœì„œì— ë”°ë¼)
            child_nodes = self.get_child_nodes(node)
            
            # ì—­ìˆœìœ¼ë¡œ ì¶”ê°€í•˜ì—¬ ì›ë˜ ìˆœì„œ ìœ ì§€
            for child in reversed(child_nodes):
                self._stack.append(child)
    
    def process_node(self, node):
        """ë…¸ë“œ ì²˜ë¦¬ (ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œ)"""
        # ê¸°ë³¸ êµ¬í˜„
        return str(node)
    
    def get_child_nodes(self, node):
        """ìì‹ ë…¸ë“œ ê°€ì ¸ì˜¤ê¸° (ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œ)"""
        # ê¸°ë³¸ êµ¬í˜„
        if hasattr(node, 'children'):
            return node.children
        return []

class FileSystemVisitor(LazyVisitor):
    """íŒŒì¼ ì‹œìŠ¤í…œ íƒìƒ‰ ë°©ë¬¸ì"""
    
    def __init__(self, max_depth=None):
        super().__init__()
        self.max_depth = max_depth
        self._depth_map = {}
    
    def process_node(self, node):
        """íŒŒì¼/ë””ë ‰í† ë¦¬ ì²˜ë¦¬"""
        # ê¹Šì´ ê³„ì‚°
        node_id = id(node)
        if node.parent_id in self._depth_map:
            depth = self._depth_map[node.parent_id] + 1
        else:
            depth = 0
        
        self._depth_map[node_id] = depth
        
        # ìµœëŒ€ ê¹Šì´ ì œí•œ
        if self.max_depth is not None and depth > self.max_depth:
            return None
        
        # ë“¤ì—¬ì“°ê¸° ìƒì„±
        indent = "  " * depth
        
        if node.is_directory:
            return f"{indent}ğŸ“ {node.name}/"
        else:
            size_str = self._format_size(node.size)
            return f"{indent}ğŸ“„ {node.name} ({size_str})"
    
    def _format_size(self, size_bytes):
        """íŒŒì¼ í¬ê¸° í¬ë§·íŒ…"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f} TB"
    
    def get_child_nodes(self, node):
        """ìì‹ ë…¸ë“œ ë°˜í™˜"""
        if node.is_directory:
            return node.children
        return []

class FileSystemNode:
    """íŒŒì¼ ì‹œìŠ¤í…œ ë…¸ë“œ"""
    
    def __init__(self, name, is_directory=False, size=0, parent=None):
        self.name = name
        self.is_directory = is_directory
        self.size = size
        self.parent = parent
        self.children = []
        self.parent_id = id(parent) if parent else None
    
    def add_child(self, child):
        child.parent = self
        child.parent_id = id(self)
        self.children.append(child)
        return self
    
    def __str__(self):
        return f"{'ğŸ“' if self.is_directory else 'ğŸ“„'} {self.name}"

print("ì œë„ˆë ˆì´í„° ê¸°ë°˜ íŒŒì¼ ì‹œìŠ¤í…œ íƒìƒ‰:")

# íŒŒì¼ ì‹œìŠ¤í…œ íŠ¸ë¦¬ ìƒì„±
root_dir = FileSystemNode("root", is_directory=True)

# í•˜ìœ„ ë””ë ‰í† ë¦¬ ìƒì„±
home = FileSystemNode("home", is_directory=True)
documents = FileSystemNode("documents", is_directory=True)
pictures = FileSystemNode("pictures", is_directory=True)

# íŒŒì¼ ìƒì„±
files = [
    FileSystemNode("readme.txt", size=1024),
    FileSystemNode("report.pdf", size=512000),
    FileSystemNode("photo1.jpg", size=2048000),
    FileSystemNode("photo2.jpg", size=3072000),
    FileSystemNode("notes.txt", size=2048)
]

# íŠ¸ë¦¬ êµ¬ì„±
root_dir.add_child(home)
home.add_child(documents)
home.add_child(pictures)

documents.add_child(files[0]).add_child(files[1])
pictures.add_child(files[2]).add_child(files[3]).add_child(files[4])

# ì§€ì—° í‰ê°€ ë°©ë¬¸ ì‹¤í–‰
visitor = FileSystemVisitor(max_depth=3)

print("íŒŒì¼ ì‹œìŠ¤í…œ êµ¬ì¡°:")
for i, item in enumerate(visitor.visit_iterative(root_dir)):
    print(f"  {item}")
    
    # ì¼ì • ìˆ˜ì¤€ì—ì„œ ì¤‘ë‹¨ (ë©”ëª¨ë¦¬ íš¨ìœ¨ì )
    if i >= 20:  # 20ê°œ í•­ëª©ë§Œ ì¶œë ¥
        print("  ... (ìƒëµ)")
        break

# 5. ì½”ë£¨í‹´ì„ ì´ìš©í•œ ë¹„ë™ê¸° ë¹„ì§€í„° íŒ¨í„´
print("\n5. ì½”ë£¨í‹´ì„ ì´ìš©í•œ ë¹„ë™ê¸° ë¹„ì§€í„° íŒ¨í„´:")

import asyncio

class AsyncVisitor:
    """ë¹„ë™ê¸° ë°©ë¬¸ì íŒ¨í„´"""
    
    def __init__(self, max_concurrent=10):
        self.max_concurrent = max_concurrent
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self.visited = set()
        self.results = []
    
    async def visit_async(self, start_nodes):
        """
        ë¹„ë™ê¸° ë°©ë¬¸ ì‹œì‘
        
        Args:
            start_nodes: ì‹œì‘ ë…¸ë“œ ëª©ë¡
        """
        tasks = []
        
        for node in start_nodes:
            task = asyncio.create_task(self._visit_node(node, 0))
            tasks.append(task)
        
        # ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
        await asyncio.gather(*tasks)
        
        return self.results
    
    async def _visit_node(self, node, depth):
        """ë…¸ë“œ ë°©ë¬¸ (ë¹„ë™ê¸°)"""
        node_id = id(node)
        
        # ë°©ë¬¸ ì—¬ë¶€ í™•ì¸
        if node_id in self.visited:
            return
        
        # ë°©ë¬¸ í‘œì‹œ
        self.visited.add(node_id)
        
        # ì„¸ë§ˆí¬ì–´ë¥¼ ì‚¬ìš©í•œ ë™ì‹œì„± ì œì–´
        async with self.semaphore:
            # ë…¸ë“œ ì²˜ë¦¬ (ë¹„ë™ê¸°)
            result = await self.process_node_async(node, depth)
            if result:
                self.results.append(result)
            
            # í•˜ìœ„ ë…¸ë“œë“¤ ë¹„ë™ê¸°ì ìœ¼ë¡œ ë°©ë¬¸
            child_nodes = await self.get_child_nodes_async(node)
            
            child_tasks = []
            for child in child_nodes:
                if id(child) not in self.visited:
                    task = asyncio.create_task(self._visit_node(child, depth + 1))
                    child_tasks.append(task)
            
            # ëª¨ë“  í•˜ìœ„ ë…¸ë“œ ë°©ë¬¸ ì™„ë£Œ ëŒ€ê¸°
            if child_tasks:
                await asyncio.gather(*child_tasks)
    
    async def process_node_async(self, node, depth):
        """ë¹„ë™ê¸° ë…¸ë“œ ì²˜ë¦¬ (ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œ)"""
        # ê¸°ë³¸ êµ¬í˜„
        await asyncio.sleep(0.01)  # ë¹„ë™ê¸° ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
        return {
            'node': str(node),
            'depth': depth,
            'timestamp': asyncio.get_event_loop().time()
        }
    
    async def get_child_nodes_async(self, node):
        """ë¹„ë™ê¸° ìì‹ ë…¸ë“œ ê°€ì ¸ì˜¤ê¸° (ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œ)"""
        # ê¸°ë³¸ êµ¬í˜„
        await asyncio.sleep(0.001)
        return []

class APICrawlerVisitor(AsyncVisitor):
    """API í¬ë¡¤ëŸ¬ ë¹„ë™ê¸° ë°©ë¬¸ì"""
    
    def __init__(self, max_concurrent=5):
        super().__init__(max_concurrent)
        self.api_base = "https://api.example.com"
    
    async def process_node_async(self, endpoint, depth):
        """API ì—”ë“œí¬ì¸íŠ¸ ì²˜ë¦¬ (ë¹„ë™ê¸°)"""
        # API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
        await asyncio.sleep(0.1)
        
        # ì‘ë‹µ ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜
        response_size = hash(endpoint) % 5000 + 1000
        status = "success" if hash(endpoint) % 10 != 0 else "error"
        
        return {
            'endpoint': endpoint,
            'depth': depth,
            'response_size': response_size,
            'status': status,
            'timestamp': asyncio.get_event_loop().time()
        }
    
    async def get_child_nodes_async(self, endpoint):
        """ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸ ì¶”ì¶œ (ë¹„ë™ê¸°)"""
        await asyncio.sleep(0.01)
        
        # ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸ ì‹œë®¬ë ˆì´ì…˜
        if depth := len(endpoint.split('/')) < 3:
            return [
                f"{endpoint}/users",
                f"{endpoint}/products",
                f"{endpoint}/orders"
            ]
        
        return []

async def run_async_crawler():
    """ë¹„ë™ê¸° í¬ë¡¤ëŸ¬ ì‹¤í–‰"""
    print("ë¹„ë™ê¸° API í¬ë¡¤ë§ ì‹œì‘...")
    start_time = asyncio.get_event_loop().time()
    
    # ì‹œì‘ ì—”ë“œí¬ì¸íŠ¸ë“¤
    start_endpoints = [
        "/api/v1",
        "/api/v2",
        "/api/v3"
    ]
    
    # ë¹„ë™ê¸° ë°©ë¬¸ì ìƒì„± ë° ì‹¤í–‰
    crawler = APICrawlerVisitor(max_concurrent=3)
    results = await crawler.visit_async(start_endpoints)
    
    end_time = asyncio.get_event_loop().time()
    print(f"í¬ë¡¤ë§ ì™„ë£Œ: {len(results)} ì—”ë“œí¬ì¸íŠ¸, "
          f"ì†Œìš”ì‹œê°„: {end_time - start_time:.2f}ì´ˆ")
    
    # ê²°ê³¼ ìš”ì•½
    print("\ní¬ë¡¤ë§ ê²°ê³¼ ìš”ì•½:")
    success_count = sum(1 for r in results if r['status'] == 'success')
    error_count = len(results) - success_count
    total_size = sum(r['response_size'] for r in results)
    
    print(f"  ì„±ê³µ: {success_count}ê°œ")
    print(f"  ì‹¤íŒ¨: {error_count}ê°œ")
    print(f"  ì´ ë°ì´í„° í¬ê¸°: {total_size:,} bytes")
    print(f"  í‰ê·  ì‘ë‹µ í¬ê¸°: {total_size/len(results):.0f} bytes")
    
    # ì²˜ìŒ 3ê°œ ê²°ê³¼ ìƒì„¸ ì¶œë ¥
    print("\nì²˜ìŒ 3ê°œ ê²°ê³¼:")
    for result in results[:3]:
        print(f"  {result['endpoint']} (ê¹Šì´: {result['depth']}, "
              f"í¬ê¸°: {result['response_size']}, ìƒíƒœ: {result['status']})")

# ë¹„ë™ê¸° í¬ë¡¤ëŸ¬ ì‹¤í–‰
asyncio.run(run_async_crawler())
```

## ê²°ë¡ 

ë¬¸ìì—´ë¡œ ì´ë¦„ì´ ì£¼ì–´ì§„ ê°ì²´ì˜ ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ê¸°ìˆ ì€ Pythonì˜ ë™ì  íŠ¹ì„±ì„ í™œìš©í•œ ê°•ë ¥í•œ íŒ¨í„´ì…ë‹ˆë‹¤. `getattr()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ëŸ°íƒ€ì„ì— ë©”ì†Œë“œ ì´ë¦„ì„ ë¬¸ìì—´ë¡œ ì§€ì •í•˜ì—¬ í˜¸ì¶œí•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ, ëª…ë ¹ì–´ ì²˜ë¦¬ê¸°, ë™ì  API ìƒì„± ë“±ì— ìœ ìš©í•©ë‹ˆë‹¤. ì•ˆì „í•œ í˜¸ì¶œì„ ìœ„í•´ `hasattr()`ë¡œ ë©”ì†Œë“œ ì¡´ì¬ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê³ , `callable()`ë¡œ í˜¸ì¶œ ê°€ëŠ¥í•œì§€ ê²€ì¦í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

ë¹„ì§€í„° íŒ¨í„´ì€ ì•Œê³ ë¦¬ì¦˜ì„ ê°ì²´ êµ¬ì¡°ì—ì„œ ë¶„ë¦¬ì‹œí‚¤ëŠ” í–‰ë™ ë””ìì¸ íŒ¨í„´ìœ¼ë¡œ, ê°ì²´ êµ¬ì¡°ë¥¼ ë³€ê²½í•˜ì§€ ì•Šê³ ë„ ìƒˆë¡œìš´ ì—°ì‚°ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì „í†µì ì¸ êµ¬í˜„ì—ì„œëŠ” ê° ìš”ì†Œê°€ `accept()` ë©”ì†Œë“œë¥¼ í†µí•´ ë¹„ì§€í„°ë¥¼ ë°›ì•„ë“¤ì´ê³ , ë¹„ì§€í„°ëŠ” ê° ìš”ì†Œ íƒ€ì…ì— ë§ëŠ” `visit_xxx()` ë©”ì†Œë“œë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. íŒŒì´ì¬ì—ì„œëŠ” ë‹¨ì¼ `visit()` ë©”ì†Œë“œì™€ íƒ€ì… ê¸°ë°˜ ë””ìŠ¤íŒ¨ì¹˜ë¥¼ ì‚¬ìš©í•œ ë” íŒŒì´ì¬ìŠ¤ëŸ¬ìš´ êµ¬í˜„ë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì¬ê·€ ì—†ì´ ë¹„ì§€í„° íŒ¨í„´ì„ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì€ ì—¬ëŸ¬ ê°€ì§€ê°€ ìˆìŠµë‹ˆë‹¤:
1. **ìŠ¤íƒì„ ì´ìš©í•œ ê¹Šì´ ìš°ì„  íƒìƒ‰**: ëª…ì‹œì  ìŠ¤íƒì„ ì‚¬ìš©í•˜ì—¬ ì¬ê·€ í˜¸ì¶œì„ í”¼í•¨
2. **íë¥¼ ì´ìš©í•œ ë„ˆë¹„ ìš°ì„  íƒìƒ‰**: íë¥¼ ì‚¬ìš©í•˜ì—¬ ë ˆë²¨ë³„ë¡œ ë…¸ë“œ ë°©ë¬¸
3. **ì‘ì—… íì™€ ìŠ¤ë ˆë“œ í’€**: ë³‘ë ¬ ì²˜ë¦¬ë¥¼ ìœ„í•œ ë©€í‹°ìŠ¤ë ˆë”© ì ‘ê·¼
4. **ì œë„ˆë ˆì´í„° ê¸°ë°˜ ì§€ì—° í‰ê°€**: ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ì ì§„ì  ì²˜ë¦¬
5. **ì½”ë£¨í‹´ ê¸°ë°˜ ë¹„ë™ê¸° ì²˜ë¦¬**: I/O ë°”ìš´ë“œ ì‘ì—…ì— ì í•©í•œ ë¹„ë™ê¸° íŒ¨í„´

ì´ëŸ¬í•œ ë¹„ì¬ê·€ì  ì ‘ê·¼ ë°©ì‹ì˜ ì¥ì ì€:
- **ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€**: ê¹Šì€ ì¬ê·€ í˜¸ì¶œë¡œ ì¸í•œ ë¬¸ì œ íšŒí”¼
- **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: í•„ìš”í•œ ë§Œí¼ë§Œ ë©”ëª¨ë¦¬ ì‚¬ìš©
- **ë³‘ë ¬ ì²˜ë¦¬ ìš©ì´ì„±**: ì‘ì—…ì„ ë¶„ì‚°í•˜ì—¬ ì„±ëŠ¥ í–¥ìƒ
- **ìœ ì—°í•œ ì œì–´**: ë°©ë¬¸ ìˆœì„œ, ì¤‘ë‹¨, ì¬ê°œ ë“± ì œì–´ ê°€ëŠ¥

ì ì ˆí•œ íŒ¨í„´ ì„ íƒì€ ë¬¸ì œì˜ íŠ¹ì„±ì— ë”°ë¼ ë‹¬ë¼ì§‘ë‹ˆë‹¤:
- **íŠ¸ë¦¬ êµ¬ì¡° íƒìƒ‰**: ìŠ¤íƒ ê¸°ë°˜ DFSê°€ ì í•©
- **ê·¸ë˜í”„ íƒìƒ‰ ë˜ëŠ” ìµœë‹¨ ê²½ë¡œ**: í ê¸°ë°˜ BFSê°€ ì í•©
- **ëŒ€ê·œëª¨ ë°ì´í„° ì²˜ë¦¬**: ë³‘ë ¬ ë˜ëŠ” ë¹„ë™ê¸° íŒ¨í„´ì´ ì í•©
- **ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¬ë°**: ì œë„ˆë ˆì´í„° ê¸°ë°˜ ì§€ì—° í‰ê°€ê°€ ì í•©

Pythonì˜ ë™ì  íŠ¹ì„±ê³¼ ë‹¤ì–‘í•œ ìë£Œêµ¬ì¡°, ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° ê¸°ëŠ¥ì„ í™œìš©í•˜ë©´ ë³µì¡í•œ ê°ì²´ êµ¬ì¡°ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ë‹¤ì–‘í•œ ë¹„ì§€í„° íŒ¨í„´ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.