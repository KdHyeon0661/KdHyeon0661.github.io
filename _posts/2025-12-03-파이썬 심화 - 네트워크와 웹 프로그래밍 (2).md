---
layout: post
title: 파이썬 심화 - 네트워크와 웹 프로그래밍 (2)
date: 2025-12-03 22:30:23 +0900
category: 파이썬 심화
---
# 네트워크와 웹 프로그래밍 (2)

## CIDR 주소를 활용한 IP 주소 생성 및 관리

CIDR(Classless Inter-Domain Routing) 표기법은 IP 주소와 서브넷 마스크를 결합한 간결한 표현 방식으로, 네트워크 관리와 IP 주소 할당에 필수적인 개념입니다.

### CIDR 기본 이해 및 IP 주소 생성

```python
import ipaddress
from typing import List, Generator, Union
import itertools

class CIDRManager:
    """
    CIDR 주소를 관리하고 IP 주소를 생성하는 클래스
    
    CIDR 표기법: 192.168.1.0/24
    - 192.168.1.0: 네트워크 주소
    - /24: 서브넷 마스크 (255.255.255.0)
    """
    
    def __init__(self, cidr_str: str):
        """
        CIDR 매니저 초기화
        
        Args:
            cidr_str: CIDR 표기법 문자열 (예: '192.168.1.0/24')
        """
        self.cidr = ipaddress.ip_network(cidr_str, strict=False)
        self.network_address = self.cidr.network_address
        self.broadcast_address = self.cidr.broadcast_address
        self.netmask = self.cidr.netmask
        self.hostmask = self.cidr.hostmask
        self.num_addresses = self.cidr.num_addresses
        self.num_usable_hosts = self.num_addresses - 2  # 네트워크/브로드캐스트 주소 제외
        
        print(f"CIDR 네트워크 정보:")
        print(f"  CIDR 표현: {self.cidr}")
        print(f"  네트워크 주소: {self.network_address}")
        print(f"  브로드캐스트 주소: {self.broadcast_address}")
        print(f"  서브넷 마스크: {self.netmask}")
        print(f"  호스트 마스크: {self.hostmask}")
        print(f"  전체 주소 수: {self.num_addresses:,}")
        print(f"  사용 가능 호스트 수: {self.num_usable_hosts:,}")
    
    def generate_all_ips(self) -> List[ipaddress.IPv4Address]:
        """
        CIDR 범위 내 모든 IP 주소 생성
        
        Returns:
            CIDR 범위 내 모든 IP 주소 리스트
        """
        return list(self.cidr.hosts())
    
    def generate_usable_ips(self) -> List[ipaddress.IPv4Address]:
        """
        사용 가능한 호스트 IP 주소만 생성 (네트워크/브로드캐스트 주소 제외)
        
        Returns:
            사용 가능한 호스트 IP 주소 리스트
        """
        # network_address와 broadcast_address를 제외한 모든 주소
        return [ip for ip in self.cidr.hosts()]
    
    def generate_ip_range(self, start: int = 0, end: Union[int, None] = None) -> List[ipaddress.IPv4Address]:
        """
        특정 범위의 IP 주소만 생성
        
        Args:
            start: 시작 인덱스 (0부터 시작)
            end: 종료 인덱스 (None이면 끝까지)
        
        Returns:
            지정 범위의 IP 주소 리스트
        """
        all_hosts = list(self.cidr.hosts())
        
        if end is None:
            end = len(all_hosts)
        
        if start < 0 or end > len(all_hosts):
            raise ValueError(f"인덱스 범위 초과 (0-{len(all_hosts)})")
        
        return all_hosts[start:end]
    
    def generate_ips_by_count(self, count: int = 10, 
                            start_from: Union[str, None] = None) -> List[ipaddress.IPv4Address]:
        """
        지정된 개수만큼의 IP 주소 생성
        
        Args:
            count: 생성할 IP 주소 개수
            start_from: 시작 IP 주소 (None이면 네트워크 주소 다음부터)
        
        Returns:
            생성된 IP 주소 리스트
        """
        if count > self.num_usable_hosts:
            raise ValueError(f"요청한 개수({count})가 사용 가능 호스트 수({self.num_usable_hosts})를 초과합니다.")
        
        all_hosts = list(self.cidr.hosts())
        
        if start_from:
            start_ip = ipaddress.ip_address(start_from)
            try:
                start_index = all_hosts.index(start_ip)
            except ValueError:
                start_index = 0
        else:
            start_index = 0
        
        end_index = start_index + count
        
        if end_index > len(all_hosts):
            end_index = len(all_hosts)
        
        return all_hosts[start_index:end_index]
    
    def is_ip_in_range(self, ip_str: str) -> bool:
        """
        특정 IP 주소가 CIDR 범위에 속하는지 확인
        
        Args:
            ip_str: 확인할 IP 주소 문자열
        
        Returns:
            CIDR 범위 내에 있으면 True, 아니면 False
        """
        try:
            ip = ipaddress.ip_address(ip_str)
            return ip in self.cidr
        except ValueError:
            return False
    
    def get_subnets(self, prefixlen_diff: int = 1) -> List['CIDRManager']:
        """
        CIDR 네트워크를 더 작은 서브넷으로 분할
        
        Args:
            prefixlen_diff: 서브넷 마스크 증가량 (기본값: 1)
                           예: /24 -> prefixlen_diff=1 -> /25 서브넷들
        
        Returns:
            분할된 서브넷 CIDRManager 객체 리스트
        """
        subnets = list(self.cidr.subnets(prefixlen_diff=prefixlen_diff))
        return [CIDRManager(str(subnet)) for subnet in subnets]
    
    def get_ip_info(self, ip_str: str) -> dict:
        """
        IP 주소의 상세 정보 제공
        
        Args:
            ip_str: IP 주소 문자열
        
        Returns:
            IP 주소 정보 딕셔너리
        """
        if not self.is_ip_in_range(ip_str):
            return {"error": f"IP {ip_str}는 CIDR {self.cidr} 범위에 속하지 않습니다."}
        
        ip = ipaddress.ip_address(ip_str)
        
        return {
            "ip_address": str(ip),
            "is_private": ip.is_private,
            "is_global": ip.is_global,
            "is_multicast": ip.is_multicast,
            "is_reserved": ip.is_reserved,
            "is_loopback": ip.is_loopback,
            "is_link_local": ip.is_link_local,
            "hex_representation": hex(int(ip)),
            "integer_representation": int(ip),
            "in_cidr_range": True
        }

# 사용 예시
def demonstrate_cidr_operations():
    """
    CIDR 관리 기능 데모
    """
    print("=" * 60)
    print("CIDR 주소 관리 시스템")
    print("=" * 60)
    
    # CIDR 네트워크 생성
    cidr_str = "192.168.1.0/24"
    cidr_manager = CIDRManager(cidr_str)
    
    print("\n1. 기본 IP 주소 생성")
    print("-" * 40)
    
    # 모든 사용 가능한 IP 주소 생성
    usable_ips = cidr_manager.generate_usable_ips()
    print(f"첫 10개 IP 주소:")
    for i, ip in enumerate(usable_ips[:10], 1):
        print(f"  {i:2d}. {ip}")
    print(f"  ... (총 {len(usable_ips)}개)")
    
    print("\n2. 특정 개수의 IP 주소 생성")
    print("-" * 40)
    
    # 5개의 IP 주소만 생성
    five_ips = cidr_manager.generate_ips_by_count(5)
    for i, ip in enumerate(five_ips, 1):
        print(f"  {i}. {ip}")
    
    print("\n3. IP 주소 범위 확인")
    print("-" * 40)
    
    test_ips = ["192.168.1.10", "192.168.2.10", "192.168.1.255"]
    for test_ip in test_ips:
        is_in_range = cidr_manager.is_ip_in_range(test_ip)
        status = "✓ 범위 내" if is_in_range else "✗ 범위 밖"
        print(f"  IP {test_ip:15s}: {status}")
    
    print("\n4. 서브넷 분할")
    print("-" * 40)
    
    # /24 네트워크를 /25 서브넷으로 분할
    subnets = cidr_manager.get_subnets(prefixlen_diff=1)
    print(f"/24 네트워크를 {len(subnets)}개의 /25 서브넷으로 분할:")
    for i, subnet in enumerate(subnets, 1):
        print(f"  서브넷 {i}: {subnet.cidr} (사용 가능 호스트: {subnet.num_usable_hosts}개)")
    
    print("\n5. IP 주소 상세 정보")
    print("-" * 40)
    
    ip_info = cidr_manager.get_ip_info("192.168.1.100")
    for key, value in ip_info.items():
        print(f"  {key:25s}: {value}")

# 고급 CIDR 활용 예시
class AdvancedCIDRProcessor:
    """
    고급 CIDR 처리 기능을 제공하는 클래스
    """
    
    @staticmethod
    def cidr_to_ip_range(cidr_str: str) -> tuple:
        """
        CIDR을 시작 IP와 끝 IP 범위로 변환
        
        Args:
            cidr_str: CIDR 문자열
        
        Returns:
            (시작_IP, 끝_IP, 전체_개수) 튜플
        """
        network = ipaddress.ip_network(cidr_str, strict=False)
        
        # 네트워크 주소와 브로드캐스트 주소
        start_ip = int(network.network_address)
        end_ip = int(network.broadcast_address)
        
        return (start_ip, end_ip, network.num_addresses)
    
    @staticmethod
    def generate_sequential_ips(base_ip: str, count: int) -> List[str]:
        """
        기준 IP부터 순차적인 IP 주소 생성
        
        Args:
            base_ip: 기준 IP 주소
            count: 생성할 IP 개수
        
        Returns:
            순차적인 IP 주소 리스트
        """
        try:
            ip = ipaddress.ip_address(base_ip)
            ips = []
            
            for i in range(count):
                ips.append(str(ip + i))
            
            return ips
        except ValueError as e:
            raise ValueError(f"유효하지 않은 IP 주소: {e}")
    
    @staticmethod
    def find_available_subnet(existing_cidrs: List[str], 
                            required_hosts: int, 
                            network_size: str = "24") -> Union[str, None]:
        """
        사용 가능한 서브넷 찾기
        
        Args:
            existing_cidrs: 기존에 사용 중인 CIDR 리스트
            required_hosts: 필요한 호스트 수
            network_size: 기본 네트워크 크기
        
        Returns:
            사용 가능한 서브넷 CIDR 또는 None
        """
        # 필요한 호스트 수에 따른 서브넷 크기 계산
        import math
        
        # 필요한 IP 수 (호스트 + 네트워크/브로드캐스트)
        required_ips = required_hosts + 2
        
        # 적절한 서브넷 마스크 계산
        for prefix in range(32, 0, -1):
            max_hosts = 2 ** (32 - prefix) - 2
            if max_hosts >= required_hosts:
                suitable_prefix = prefix
                break
        
        # 간단한 구현: 지정된 네트워크에서 첫 번째 사용 가능한 서브넷 반환
        # 실제 구현에서는 더 복잡한 로직 필요
        base_network = f"10.0.0.0/{network_size}"
        
        return f"10.0.1.0/{suitable_prefix}"
    
    @staticmethod
    def validate_and_parse_cidr(cidr_str: str) -> dict:
        """
        CIDR 문자열 검증 및 파싱
        
        Args:
            cidr_str: 검증할 CIDR 문자열
        
        Returns:
            파싱 결과 딕셔너리
        """
        try:
            network = ipaddress.ip_network(cidr_str, strict=True)
            
            return {
                "valid": True,
                "network_address": str(network.network_address),
                "broadcast_address": str(network.broadcast_address),
                "netmask": str(network.netmask),
                "prefixlen": network.prefixlen,
                "num_addresses": network.num_addresses,
                "is_private": network.is_private,
                "is_global": network.is_global
            }
        except ValueError as e:
            return {
                "valid": False,
                "error": str(e),
                "suggestions": []
            }

# CIDR 유틸리티 함수들
def cidr_batch_processing(cidr_list: List[str], operation: str = "info") -> List[dict]:
    """
    여러 CIDR에 대한 일괄 처리
    
    Args:
        cidr_list: 처리할 CIDR 리스트
        operation: 수행할 작업 ('info', 'ips', 'subnets')
    
    Returns:
        처리 결과 리스트
    """
    results = []
    
    for cidr_str in cidr_list:
        try:
            manager = CIDRManager(cidr_str)
            
            if operation == "info":
                result = {
                    "cidr": cidr_str,
                    "network": str(manager.network_address),
                    "broadcast": str(manager.broadcast_address),
                    "usable_hosts": manager.num_usable_hosts,
                    "status": "success"
                }
            elif operation == "ips":
                ips = manager.generate_usable_ips()[:5]  # 처음 5개만
                result = {
                    "cidr": cidr_str,
                    "sample_ips": [str(ip) for ip in ips],
                    "total_ips": len(manager.generate_usable_ips()),
                    "status": "success"
                }
            elif operation == "subnets":
                subnets = manager.get_subnets()
                result = {
                    "cidr": cidr_str,
                    "subnets": [str(subnet.cidr) for subnet in subnets],
                    "subnet_count": len(subnets),
                    "status": "success"
                }
            
            results.append(result)
            
        except Exception as e:
            results.append({
                "cidr": cidr_str,
                "status": "error",
                "error": str(e)
            })
    
    return results

# 데모 실행
if __name__ == "__main__":
    demonstrate_cidr_operations()
    
    # 고급 기능 데모
    print("\n" + "=" * 60)
    print("고급 CIDR 처리 기능")
    print("=" * 60)
    
    # CIDR 범위 변환
    cidr_range = AdvancedCIDRProcessor.cidr_to_ip_range("192.168.1.0/24")
    print(f"\n1. CIDR 범위 변환:")
    print(f"   192.168.1.0/24 → 시작: {cidr_range[0]}, 끝: {cidr_range[1]}, 개수: {cidr_range[2]}")
    
    # 순차적 IP 생성
    sequential_ips = AdvancedCIDRProcessor.generate_sequential_ips("10.0.0.1", 5)
    print(f"\n2. 순차적 IP 생성:")
    print(f"   10.0.0.1부터 5개: {sequential_ips}")
    
    # CIDR 검증
    test_cidrs = ["192.168.1.0/24", "invalid_cidr", "10.256.0.0/8"]
    print(f"\n3. CIDR 검증:")
    for test_cidr in test_cidrs:
        validation = AdvancedCIDRProcessor.validate_and_parse_cidr(test_cidr)
        status = "✓ 유효" if validation["valid"] else "✗ 무효"
        print(f"   {test_cidr:20s}: {status}")
        if not validation["valid"]:
            print(f"     오류: {validation['error']}")
    
    # 일괄 처리
    print(f"\n4. CIDR 일괄 처리:")
    cidr_list = ["10.0.0.0/24", "172.16.0.0/16", "192.168.0.0/24"]
    batch_results = cidr_batch_processing(cidr_list, "info")
    
    for result in batch_results:
        if result["status"] == "success":
            print(f"   CIDR: {result['cidr']}")
            print(f"     네트워크: {result['network']}")
            print(f"     브로드캐스트: {result['broadcast']}")
            print(f"     사용 가능 호스트: {result['usable_hosts']:,}")
```

## 간단한 REST 기반 인터페이스 생성

REST(Representational State Transfer)는 HTTP 프로토콜을 활용한 간단하고 확장 가능한 웹 서비스 아키텍처 스타일입니다.

### Flask를 활용한 기본 REST API 구현

```python
from flask import Flask, request, jsonify, make_response
from flask_restful import Api, Resource, reqparse
from functools import wraps
import json
import sqlite3
from datetime import datetime
from typing import Dict, Any, List, Optional

# Flask 애플리케이션 초기화
app = Flask(__name__)
api = Api(app)

# 데이터베이스 초기화
def init_database():
    """
    SQLite 데이터베이스 초기화
    """
    conn = sqlite3.connect('rest_api.db')
    cursor = conn.cursor()
    
    # 사용자 테이블 생성
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        email TEXT UNIQUE NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # 제품 테이블 생성
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS products (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        price REAL NOT NULL,
        stock INTEGER DEFAULT 0,
        category TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    conn.commit()
    conn.close()
    print("데이터베이스 초기화 완료")

# 요청 인증 데코레이터
def require_auth(f):
    """
    API 인증을 요구하는 데코레이터
    
    간단한 API 키 기반 인증 구현
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        
        # 실제 구현에서는 데이터베이스에서 API 키 검증
        valid_api_keys = ['test-api-key-123', 'demo-key-456']
        
        if not api_key or api_key not in valid_api_keys:
            return jsonify({
                'error': '인증 실패',
                'message': '유효한 API 키가 필요합니다.'
            }), 401
        
        return f(*args, **kwargs)
    return decorated_function

# 데이터베이스 연결 관리
def get_db_connection():
    """
    데이터베이스 연결 생성
    """
    conn = sqlite3.connect('rest_api.db')
    conn.row_factory = sqlite3.Row  # 딕셔너리 형태로 결과 반환
    return conn

# Health Check 엔드포인트
class HealthCheck(Resource):
    """
    서비스 상태 확인을 위한 헬스 체크 엔드포인트
    """
    
    def get(self):
        """
        서비스 상태 확인
        """
        return {
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'service': 'REST API 서비스',
            'version': '1.0.0'
        }

# 사용자 관리 API
class UserResource(Resource):
    """
    사용자 관리를 위한 REST API 리소스
    """
    
    # 요청 파서 설정
    parser = reqparse.RequestParser()
    parser.add_argument('username', type=str, required=True, 
                       help='사용자명은 필수 입력 항목입니다.')
    parser.add_argument('email', type=str, required=True,
                       help='이메일은 필수 입력 항목입니다.')
    
    def get(self, user_id: Optional[int] = None):
        """
        사용자 정보 조회
        
        Args:
            user_id: 조회할 사용자 ID (None이면 전체 조회)
        """
        conn = get_db_connection()
        
        if user_id:
            # 특정 사용자 조회
            user = conn.execute(
                'SELECT * FROM users WHERE id = ?', 
                (user_id,)
            ).fetchone()
            
            if user:
                result = dict(user)
            else:
                return {'error': '사용자를 찾을 수 없습니다.'}, 404
        else:
            # 모든 사용자 조회 (페이징 처리)
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', 10, type=int)
            offset = (page - 1) * per_page
            
            users = conn.execute(
                'SELECT * FROM users LIMIT ? OFFSET ?',
                (per_page, offset)
            ).fetchall()
            
            # 총 사용자 수
            total_count = conn.execute(
                'SELECT COUNT(*) FROM users'
            ).fetchone()[0]
            
            result = {
                'users': [dict(user) for user in users],
                'pagination': {
                    'page': page,
                    'per_page': per_page,
                    'total': total_count,
                    'total_pages': (total_count + per_page - 1) // per_page
                }
            }
        
        conn.close()
        return jsonify(result)
    
    @require_auth
    def post(self):
        """
        새로운 사용자 생성
        """
        args = self.parser.parse_args()
        
        conn = get_db_connection()
        
        try:
            cursor = conn.execute(
                'INSERT INTO users (username, email) VALUES (?, ?)',
                (args['username'], args['email'])
            )
            conn.commit()
            
            # 생성된 사용자 정보 반환
            user_id = cursor.lastrowid
            user = conn.execute(
                'SELECT * FROM users WHERE id = ?', 
                (user_id,)
            ).fetchone()
            
            conn.close()
            
            return jsonify({
                'message': '사용자가 생성되었습니다.',
                'user': dict(user)
            }), 201
            
        except sqlite3.IntegrityError as e:
            conn.close()
            return {'error': '사용자 생성 실패', 'details': str(e)}, 400
    
    @require_auth
    def put(self, user_id: int):
        """
        사용자 정보 수정
        """
        args = self.parser.parse_args()
        
        conn = get_db_connection()
        
        # 사용자 존재 여부 확인
        existing = conn.execute(
            'SELECT id FROM users WHERE id = ?', 
            (user_id,)
        ).fetchone()
        
        if not existing:
            conn.close()
            return {'error': '사용자를 찾을 수 없습니다.'}, 404
        
        try:
            conn.execute(
                '''UPDATE users 
                   SET username = ?, email = ?, updated_at = CURRENT_TIMESTAMP
                   WHERE id = ?''',
                (args['username'], args['email'], user_id)
            )
            conn.commit()
            
            # 수정된 사용자 정보 조회
            user = conn.execute(
                'SELECT * FROM users WHERE id = ?', 
                (user_id,)
            ).fetchone()
            
            conn.close()
            
            return jsonify({
                'message': '사용자 정보가 수정되었습니다.',
                'user': dict(user)
            })
            
        except sqlite3.IntegrityError as e:
            conn.close()
            return {'error': '사용자 수정 실패', 'details': str(e)}, 400
    
    @require_auth
    def delete(self, user_id: int):
        """
        사용자 삭제
        """
        conn = get_db_connection()
        
        # 사용자 존재 여부 확인
        existing = conn.execute(
            'SELECT id FROM users WHERE id = ?', 
            (user_id,)
        ).fetchone()
        
        if not existing:
            conn.close()
            return {'error': '사용자를 찾을 수 없습니다.'}, 404
        
        conn.execute('DELETE FROM users WHERE id = ?', (user_id,))
        conn.commit()
        conn.close()
        
        return {'message': f'사용자 ID {user_id}가 삭제되었습니다.'}, 200

# 제품 관리 API
class ProductResource(Resource):
    """
    제품 관리를 위한 REST API 리소스
    """
    
    parser = reqparse.RequestParser()
    parser.add_argument('name', type=str, required=True)
    parser.add_argument('price', type=float, required=True)
    parser.add_argument('stock', type=int, default=0)
    parser.add_argument('category', type=str)
    
    def get(self, product_id: Optional[int] = None):
        """
        제품 정보 조회
        """
        conn = get_db_connection()
        
        if product_id:
            # 특정 제품 조회
            product = conn.execute(
                'SELECT * FROM products WHERE id = ?', 
                (product_id,)
            ).fetchone()
            
            if product:
                result = dict(product)
            else:
                return {'error': '제품을 찾을 수 없습니다.'}, 404
        else:
            # 필터링 및 정렬 옵션
            category = request.args.get('category')
            min_price = request.args.get('min_price', type=float)
            max_price = request.args.get('max_price', type=float)
            sort_by = request.args.get('sort_by', 'id')
            sort_order = request.args.get('sort_order', 'asc')
            
            # 기본 쿼리
            query = 'SELECT * FROM products WHERE 1=1'
            params = []
            
            # 필터링 조건 추가
            if category:
                query += ' AND category = ?'
                params.append(category)
            
            if min_price is not None:
                query += ' AND price >= ?'
                params.append(min_price)
            
            if max_price is not None:
                query += ' AND price <= ?'
                params.append(max_price)
            
            # 정렬 조건 추가
            valid_sort_columns = ['id', 'name', 'price', 'stock', 'created_at']
            if sort_by in valid_sort_columns:
                query += f' ORDER BY {sort_by} {sort_order.upper()}'
            
            # 실행
            products = conn.execute(query, params).fetchall()
            result = {'products': [dict(product) for product in products]}
        
        conn.close()
        return jsonify(result)
    
    @require_auth
    def post(self):
        """
        새로운 제품 생성
        """
        args = self.parser.parse_args()
        
        conn = get_db_connection()
        
        cursor = conn.execute(
            'INSERT INTO products (name, price, stock, category) VALUES (?, ?, ?, ?)',
            (args['name'], args['price'], args['stock'], args.get('category'))
        )
        conn.commit()
        
        product_id = cursor.lastrowid
        product = conn.execute(
            'SELECT * FROM products WHERE id = ?', 
            (product_id,)
        ).fetchone()
        
        conn.close()
        
        return jsonify({
            'message': '제품이 생성되었습니다.',
            'product': dict(product)
        }), 201
    
    @require_auth
    def patch(self, product_id: int):
        """
        제품 정보 부분 수정
        """
        conn = get_db_connection()
        
        # 기존 제품 확인
        existing = conn.execute(
            'SELECT * FROM products WHERE id = ?', 
            (product_id,)
        ).fetchone()
        
        if not existing:
            conn.close()
            return {'error': '제품을 찾을 수 없습니다.'}, 404
        
        # 요청 데이터에서 제공된 필드만 업데이트
        update_data = request.json or {}
        update_fields = []
        update_values = []
        
        for field in ['name', 'price', 'stock', 'category']:
            if field in update_data:
                update_fields.append(f"{field} = ?")
                update_values.append(update_data[field])
        
        if not update_fields:
            conn.close()
            return {'error': '수정할 데이터가 제공되지 않았습니다.'}, 400
        
        update_values.append(product_id)
        
        update_query = f'''
            UPDATE products 
            SET {', '.join(update_fields)}
            WHERE id = ?
        '''
        
        conn.execute(update_query, update_values)
        conn.commit()
        
        # 업데이트된 제품 정보 조회
        product = conn.execute(
            'SELECT * FROM products WHERE id = ?', 
            (product_id,)
        ).fetchone()
        
        conn.close()
        
        return jsonify({
            'message': '제품 정보가 수정되었습니다.',
            'product': dict(product)
        })

# API 라우트 등록
api.add_resource(HealthCheck, '/health')
api.add_resource(UserResource, '/users', '/users/<int:user_id>')
api.add_resource(ProductResource, '/products', '/products/<int:product_id>')

# 에러 핸들러
@app.errorhandler(404)
def not_found(error):
    """
    404 에러 처리
    """
    return jsonify({
        'error': '리소스를 찾을 수 없습니다.',
        'message': str(error)
    }), 404

@app.errorhandler(500)
def internal_error(error):
    """
    500 에러 처리
    """
    return jsonify({
        'error': '서버 내부 오류',
        'message': '서버에서 예기치 않은 오류가 발생했습니다.'
    }), 500

# 요청 전후 처리
@app.before_request
def before_request():
    """
    요청 전처리
    """
    # 요청 로깅
    app.logger.info(f'요청: {request.method} {request.path}')
    
    # CORS 헤더 설정 (개발용)
    if request.method == 'OPTIONS':
        response = make_response()
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-API-Key')
        response.headers.add('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE')
        return response

@app.after_request
def after_request(response):
    """
    응답 후처리
    """
    # CORS 헤더 추가
    response.headers.add('Access-Control-Allow-Origin', '*')
    response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-API-Key')
    response.headers.add('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE')
    
    # 응답 로깅
    app.logger.info(f'응답: {response.status}')
    
    return response

# FastAPI 버전 (대안)
"""
# requirements.txt 추가: fastapi uvicorn

from fastapi import FastAPI, HTTPException, Depends, Query
from pydantic import BaseModel, EmailStr
from typing import List, Optional
from datetime import datetime
import uvicorn

app = FastAPI(
    title="REST API 서비스",
    description="FastAPI 기반 REST API 서비스",
    version="1.0.0"
)

# Pydantic 모델 정의
class UserCreate(BaseModel):
    username: str
    email: EmailStr

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime

@app.get("/health", response_model=dict)
async def health_check():
    return {"status": "healthy", "timestamp": datetime.now()}

@app.post("/users", response_model=UserResponse, status_code=201)
async def create_user(user: UserCreate):
    # 사용자 생성 로직 구현
    return {
        "id": 1,
        "username": user.username,
        "email": user.email,
        "created_at": datetime.now()
    }

@app.get("/users", response_model=List[UserResponse])
async def get_users(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100)
):
    # 사용자 목록 조회 로직 구현
    return []
"""

# 애플리케이션 실행
if __name__ == '__main__':
    # 데이터베이스 초기화
    init_database()
    
    # Flask 서버 실행
    app.run(
        host='0.0.0.0',
        port=5000,
        debug=True,
        threaded=True
    )
```

### REST API 클라이언트 구현

```python
import requests
import json
from typing import Dict, Any, Optional
from datetime import datetime

class RESTAPIClient:
    """
    REST API 클라이언트
    """
    
    def __init__(self, base_url: str, api_key: Optional[str] = None):
        """
        REST API 클라이언트 초기화
        
        Args:
            base_url: API 서버 기본 URL
            api_key: API 인증 키 (선택사항)
        """
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key
        self.session = requests.Session()
        
        # 세션 헤더 설정
        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'User-Agent': 'REST-API-Client/1.0'
        }
        
        if api_key:
            headers['X-API-Key'] = api_key
        
        self.session.headers.update(headers)
    
    def health_check(self) -> Dict[str, Any]:
        """
        서비스 상태 확인
        """
        try:
            response = self.session.get(f"{self.base_url}/health", timeout=5)
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            return {'error': str(e), 'status': 'unhealthy'}
    
    def create_user(self, username: str, email: str) -> Dict[str, Any]:
        """
        사용자 생성
        """
        data = {
            'username': username,
            'email': email
        }
        
        try:
            response = self.session.post(
                f"{self.base_url}/users",
                json=data,
                timeout=10
            )
            response.raise_for_status()
            return response.json()
        except requests.HTTPError as e:
            return {
                'error': f"HTTP 오류: {e.response.status_code}",
                'details': e.response.text if e.response.text else str(e)
            }
        except requests.RequestException as e:
            return {'error': str(e)}
    
    def get_users(self, page: int = 1, per_page: int = 10) -> Dict[str, Any]:
        """
        사용자 목록 조회
        """
        params = {
            'page': page,
            'per_page': per_page
        }
        
        try:
            response = self.session.get(
                f"{self.base_url}/users",
                params=params,
                timeout=10
            )
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            return {'error': str(e)}
    
    def get_products(self, **filters) -> Dict[str, Any]:
        """
        제품 목록 조회 (필터링 가능)
        """
        try:
            response = self.session.get(
                f"{self.base_url}/products",
                params=filters,
                timeout=10
            )
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            return {'error': str(e)}
    
    def update_product_stock(self, product_id: int, stock_change: int) -> Dict[str, Any]:
        """
        제품 재고 수정
        """
        data = {
            'stock': stock_change
        }
        
        try:
            response = self.session.patch(
                f"{self.base_url}/products/{product_id}",
                json=data,
                timeout=10
            )
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            return {'error': str(e)}
    
    def delete_resource(self, resource_type: str, resource_id: int) -> Dict[str, Any]:
        """
        리소스 삭제
        """
        try:
            response = self.session.delete(
                f"{self.base_url}/{resource_type}/{resource_id}",
                timeout=10
            )
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            return {'error': str(e)}

# 클라이언트 사용 예시
def demonstrate_rest_client():
    """
    REST API 클라이언트 데모
    """
    print("=" * 60)
    print("REST API 클라이언트 데모")
    print("=" * 60)
    
    # 클라이언트 생성
    client = RESTAPIClient(
        base_url="http://localhost:5000",
        api_key="test-api-key-123"
    )
    
    # 서버 상태 확인
    print("\n1. 서버 상태 확인:")
    health = client.health_check()
    print(f"   상태: {health.get('status', 'unknown')}")
    print(f"   시간: {health.get('timestamp', 'N/A')}")
    
    # 사용자 생성
    print("\n2. 사용자 생성:")
    new_user = client.create_user("testuser", "test@example.com")
    if 'error' in new_user:
        print(f"   오류: {new_user['error']}")
    else:
        print(f"   성공: {new_user.get('message', '사용자 생성됨')}")
        print(f"   사용자 ID: {new_user.get('user', {}).get('id', 'N/A')}")
    
    # 사용자 목록 조회
    print("\n3. 사용자 목록 조회:")
    users = client.get_users(page=1, per_page=5)
    if 'error' in users:
        print(f"   오류: {users['error']}")
    else:
        user_list = users.get('users', [])
        print(f"   총 {len(user_list)}명의 사용자:")
        for user in user_list[:3]:  # 처음 3명만 출력
            print(f"     - {user.get('username')} ({user.get('email')})")
    
    # 제품 목록 조회
    print("\n4. 제품 목록 조회 (필터링):")
    products = client.get_products(category="electronics", max_price=1000)
    if 'error' in products:
        print(f"   오류: {products['error']}")
    else:
        product_list = products.get('products', [])
        print(f"   총 {len(product_list)}개의 제품")
        for product in product_list[:3]:  # 처음 3개만 출력
            print(f"     - {product.get('name')}: ${product.get('price')}")

# 비동기 REST 클라이언트 (선택사항)
"""
import aiohttp
import asyncio

class AsyncRESTClient:
    async def get_users_async(self):
        async with aiohttp.ClientSession() as session:
            async with session.get(f"{self.base_url}/users") as response:
                return await response.json()
"""

if __name__ == "__main__":
    # REST 클라이언트 데모 실행
    demonstrate_rest_client()
```

## XML-RPC로 간단한 원격 프로시저 호출 구현

XML-RPC는 XML을 사용하여 원격 프로시저 호출을 수행하는 간단한 프로토콜로, HTTP를 전송 계층으로 사용합니다.

### 기본 XML-RPC 서버 및 클라이언트 구현

```python
from xmlrpc.server import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler
from xmlrpc.client import ServerProxy, Fault
import threading
import time
import sys
import os
from datetime import datetime
from typing import Any, Dict, List, Union
import inspect
import logging

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('xmlrpc_server')

# 커스텀 요청 핸들러
class RequestHandler(SimpleXMLRPCRequestHandler):
    """
    커스텀 XML-RPC 요청 핸들러
    로깅과 접근 제어 기능 추가
    """
    
    rpc_paths = ('/RPC2', '/xmlrpc')  # 처리할 경로
    
    def do_POST(self):
        """
        POST 요청 처리
        요청 정보 로깅 추가
        """
        client_ip = self.client_address[0]
        logger.info(f"요청 수신: {self.path} from {client_ip}")
        
        # 접근 제어 (선택사항)
        # allowed_ips = ['127.0.0.1', '192.168.1.0/24']
        # if not self._is_ip_allowed(client_ip, allowed_ips):
        #     self.send_error(403, "접근 거부")
        #     return
        
        super().do_POST()
    
    def _is_ip_allowed(self, ip: str, allowed_ips: List[str]) -> bool:
        """
        IP 주소 접근 허용 여부 확인
        """
        # 간단한 구현 - 실제 구현에서는 CIDR 체크 등 추가
        return ip in allowed_ips

# XML-RPC 서버 클래스
class XMLRPCServer:
    """
    XML-RPC 서버 구현
    """
    
    def __init__(self, host: str = 'localhost', port: int = 8000):
        """
        XML-RPC 서버 초기화
        
        Args:
            host: 서버 호스트
            port: 서버 포트
        """
        self.host = host
        self.port = port
        self.server = None
        self.is_running = False
        
        # 서버 인스턴스 생성
        self.server = SimpleXMLRPCServer(
            (host, port),
            requestHandler=RequestHandler,
            allow_none=True,
            logRequests=True  # 요청 로깅 활성화
        )
        
        # 서버 설정
        self.server.register_introspection_functions()  # 시스템 함수 등록
        self.server.register_multicall_functions()      # 멀티콜 지원
        
        # 서비스 메서드 자동 등록
        self._register_services()
        
        logger.info(f"XML-RPC 서버 초기화: {host}:{port}")
    
    def _register_services(self):
        """
        서비스 메서드 등록
        """
        # 계산기 서비스
        self.server.register_function(self.add, 'calculator.add')
        self.server.register_function(self.subtract, 'calculator.subtract')
        self.server.register_function(self.multiply, 'calculator.multiply')
        self.server.register_function(self.divide, 'calculator.divide')
        
        # 문자열 서비스
        self.server.register_function(self.uppercase, 'string.uppercase')
        self.server.register_function(self.lowercase, 'string.lowercase')
        self.server.register_function(self.reverse, 'string.reverse')
        
        # 시스템 정보 서비스
        self.server.register_function(self.get_system_info, 'system.info')
        self.server.register_function(self.get_server_time, 'system.time')
        self.server.register_function(self.echo, 'system.echo')
        
        # 파일 서비스 (실제 구현에서는 보안 검증 필요)
        self.server.register_function(self.list_directory, 'file.list')
        self.server.register_function(self.get_file_info, 'file.info')
        
        # 인스턴스 메서드를 서비스로 등록
        self.server.register_instance(self)
    
    # ===== 서비스 메서드들 =====
    
    # 계산기 메서드
    def add(self, a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
        """
        두 숫자의 합을 계산
        
        Args:
            a: 첫 번째 숫자
            b: 두 번째 숫자
        
        Returns:
            a와 b의 합
        """
        logger.debug(f"add 호출: {a} + {b}")
        return a + b
    
    def subtract(self, a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
        """두 숫자의 차를 계산"""
        return a - b
    
    def multiply(self, a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
        """두 숫자의 곱을 계산"""
        return a * b
    
    def divide(self, a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
        """두 숫자의 나눗셈을 계산"""
        if b == 0:
            raise Fault(1, "0으로 나눌 수 없습니다.")
        return a / b
    
    # 문자열 메서드
    def uppercase(self, text: str) -> str:
        """문자열을 대문자로 변환"""
        return text.upper()
    
    def lowercase(self, text: str) -> str:
        """문자열을 소문자로 변환"""
        return text.lower()
    
    def reverse(self, text: str) -> str:
        """문자열을 역순으로 변환"""
        return text[::-1]
    
    # 시스템 메서드
    def get_system_info(self) -> Dict[str, Any]:
        """시스템 정보 반환"""
        return {
            'platform': sys.platform,
            'python_version': sys.version,
            'server_time': datetime.now().isoformat(),
            'pid': os.getpid(),
            'hostname': os.uname().nodename if hasattr(os, 'uname') else 'unknown'
        }
    
    def get_server_time(self, format_str: str = "%Y-%m-%d %H:%M:%S") -> str:
        """서버 시간 반환"""
        return datetime.now().strftime(format_str)
    
    def echo(self, message: str, repeat: int = 1) -> str:
        """메시지를 반복하여 반환"""
        return (message + " ") * repeat
    
    # 파일 메서드 (보안 주의)
    def list_directory(self, path: str = ".") -> List[str]:
        """디렉토리 내용 목록 반환"""
        # 보안 검증 (실제 구현에서는 더 강력한 검증 필요)
        if '..' in path or path.startswith('/'):
            raise Fault(2, "잘못된 경로입니다.")
        
        try:
            return os.listdir(path)
        except Exception as e:
            raise Fault(3, f"디렉토리 읽기 실패: {str(e)}")
    
    def get_file_info(self, filename: str) -> Dict[str, Any]:
        """파일 정보 반환"""
        try:
            stat_info = os.stat(filename)
            return {
                'filename': filename,
                'size': stat_info.st_size,
                'modified': datetime.fromtimestamp(stat_info.st_mtime).isoformat(),
                'accessed': datetime.fromtimestamp(stat_info.st_atime).isoformat(),
                'is_file': os.path.isfile(filename),
                'is_dir': os.path.isdir(filename)
            }
        except Exception as e:
            raise Fault(4, f"파일 정보 조회 실패: {str(e)}")
    
    # 서버 관리 메서드
    def get_registered_methods(self) -> List[str]:
        """등록된 메서드 목록 반환"""
        return self.server.system_listMethods()
    
    def get_method_help(self, method_name: str) -> str:
        """메서드 도움말 반환"""
        try:
            return self.server.system_methodHelp(method_name)
        except:
            return "도움말 정보가 없습니다."
    
    def shutdown_server(self, secret: str = None) -> str:
        """
        서버 종료 (인증 필요)
        
        실제 구현에서는 더 안전한 인증 방식 사용
        """
        # 간단한 시크릿 검증
        valid_secret = "shutdown123"
        
        if secret != valid_secret:
            raise Fault(5, "잘못된 시크릿 키입니다.")
        
        # 별도 스레드에서 종료 실행
        def delayed_shutdown():
            time.sleep(0.5)
            self.stop()
        
        threading.Thread(target=delayed_shutdown, daemon=True).start()
        return "서버가 곧 종료됩니다."
    
    # 서버 실행 메서드
    def start(self, background: bool = False):
        """
        서버 시작
        
        Args:
            background: 백그라운드 스레드에서 실행할지 여부
        """
        if self.is_running:
            logger.warning("서버가 이미 실행 중입니다.")
            return
        
        logger.info(f"XML-RPC 서버 시작: {self.host}:{self.port}")
        
        if background:
            # 백그라운드 스레드에서 서버 실행
            server_thread = threading.Thread(
                target=self._run_server,
                daemon=True,
                name="XMLRPC-Server-Thread"
            )
            server_thread.start()
            
            # 서버 시작 대기
            time.sleep(1)
            logger.info("서버가 백그라운드에서 시작되었습니다.")
        else:
            # 현재 스레드에서 서버 실행
            self._run_server()
    
    def _run_server(self):
        """서버 실행 루프"""
        self.is_running = True
        try:
            self.server.serve_forever()
        except KeyboardInterrupt:
            logger.info("서버가 사용자 요청으로 종료됩니다.")
        except Exception as e:
            logger.error(f"서버 실행 중 오류 발생: {e}")
        finally:
            self.is_running = False
            logger.info("서버가 중지되었습니다.")
    
    def stop(self):
        """서버 중지"""
        if self.server and self.is_running:
            logger.info("서버 중지 요청 수신")
            self.server.shutdown()
            self.is_running = False

# XML-RPC 클라이언트 클래스
class XMLRPCClient:
    """
    XML-RPC 클라이언트 구현
    """
    
    def __init__(self, server_url: str):
        """
        XML-RPC 클라이언트 초기화
        
        Args:
            server_url: 서버 URL (예: 'http://localhost:8000')
        """
        self.server_url = server_url
        
        # 프록시 서버 생성
        self.proxy = ServerProxy(
            server_url,
            allow_none=True,
            use_datetime=True  # datetime 객체 지원
        )
        
        logger.info(f"XML-RPC 클라이언트 초기화: {server_url}")
    
    def call_method(self, method_name: str, *args, **kwargs) -> Any:
        """
        원격 메서드 호출
        
        Args:
            method_name: 호출할 메서드 이름
            *args: 위치 인자
            **kwargs: 키워드 인자 (XML-RPC에서는 제한적 지원)
        
        Returns:
            메서드 실행 결과
        """
        try:
            # 메서드 호출
            method = getattr(self.proxy, method_name)
            
            # 키워드 인자 처리 (XML-RPC는 키워드 인자를 완벽히 지원하지 않음)
            if kwargs:
                # 딕셔너리로 변환하여 전달
                return method(*args, kwargs)
            else:
                return method(*args)
                
        except Fault as e:
            logger.error(f"XML-RPC 오류: {e.faultCode} - {e.faultString}")
            return {'error': f'{e.faultCode}: {e.faultString}'}
        except Exception as e:
            logger.error(f"클라이언트 오류: {str(e)}")
            return {'error': str(e)}
    
    def get_server_methods(self) -> List[str]:
        """서버의 사용 가능한 메서드 목록 조회"""
        try:
            return self.proxy.system.listMethods()
        except:
            return []
    
    def test_connection(self) -> bool:
        """서버 연결 테스트"""
        try:
            # 간단한 echo 메서드로 연결 테스트
            result = self.call_method('system.echo', 'test')
            return 'error' not in str(result)
        except:
            return False
    
    # 편의 메서드들
    def calculate(self, operation: str, a: float, b: float) -> float:
        """계산기 기능"""
        method_map = {
            'add': 'calculator.add',
            'subtract': 'calculator.subtract',
            'multiply': 'calculator.multiply',
            'divide': 'calculator.divide'
        }
        
        if operation not in method_map:
            raise ValueError(f"지원되지 않는 연산: {operation}")
        
        return self.call_method(method_map[operation], a, b)
    
    def get_system_info(self) -> Dict[str, Any]:
        """시스템 정보 조회"""
        return self.call_method('system.info')
    
    def process_string(self, text: str, operation: str) -> str:
        """문자열 처리"""
        method_map = {
            'uppercase': 'string.uppercase',
            'lowercase': 'string.lowercase',
            'reverse': 'string.reverse'
        }
        
        if operation not in method_map:
            raise ValueError(f"지원되지 않는 문자열 연산: {operation}")
        
        return self.call_method(method_map[operation], text)

# 데모 실행 함수
def demonstrate_xmlrpc():
    """
    XML-RPC 서버와 클라이언트 데모
    """
    print("=" * 60)
    print("XML-RPC 원격 프로시저 호출 시스템")
    print("=" * 60)
    
    # 서버 시작 (백그라운드 스레드)
    server = XMLRPCServer('localhost', 8000)
    server_thread = threading.Thread(target=server.start, daemon=True)
    server_thread.start()
    
    # 서버 시작 대기
    time.sleep(2)
    
    # 클라이언트 생성
    client = XMLRPCClient('http://localhost:8000')
    
    print("\n1. 서버 연결 테스트:")
    if client.test_connection():
        print("   ✓ 서버에 성공적으로 연결되었습니다.")
    else:
        print("   ✗ 서버 연결에 실패했습니다.")
        return
    
    print("\n2. 사용 가능한 메서드 조회:")
    methods = client.get_server_methods()
    print(f"   총 {len(methods)}개의 메서드:")
    for method in sorted(methods)[:10]:  # 처음 10개만 출력
        print(f"     - {method}")
    if len(methods) > 10:
        print(f"     ... (외 {len(methods)-10}개)")
    
    print("\n3. 계산기 기능 테스트:")
    operations = [
        ('add', 10, 5),
        ('subtract', 10, 5),
        ('multiply', 10, 5),
        ('divide', 10, 5)
    ]
    
    for op, a, b in operations:
        try:
            result = client.calculate(op, a, b)
            print(f"   {a} {op} {b} = {result}")
        except Exception as e:
            print(f"   {op} 실패: {e}")
    
    print("\n4. 문자열 처리 테스트:")
    test_string = "Hello XML-RPC"
    
    for operation in ['uppercase', 'lowercase', 'reverse']:
        try:
            result = client.process_string(test_string, operation)
            print(f"   {operation}('{test_string}') = '{result}'")
        except Exception as e:
            print(f"   {operation} 실패: {e}")
    
    print("\n5. 시스템 정보 조회:")
    system_info = client.get_system_info()
    if 'error' not in str(system_info):
        print(f"   플랫폼: {system_info.get('platform', 'N/A')}")
        print(f"   서버 시간: {system_info.get('server_time', 'N/A')}")
    else:
        print(f"   시스템 정보 조회 실패")
    
    print("\n6. 직접 메서드 호출:")
    # 직접 메서드 호출 예시
    echo_result = client.call_method('system.echo', '테스트 메시지', 3)
    print(f"   echo('테스트 메시지', 3) = '{echo_result}'")
    
    # 디렉토리 목록 조회 (보안상 현재 디렉토리만)
    dir_list = client.call_method('file.list', '.')
    if 'error' not in str(dir_list):
        print(f"   현재 디렉토리 파일 수: {len(dir_list)}개")
    else:
        print(f"   디렉토리 조회 실패: {dir_list.get('error', '알 수 없음')}")
    
    # 서버 종료 (시크릿 필요)
    print("\n7. 서버 관리:")
    # client.call_method('shutdown_server', 'shutdown123')  # 서버 종료
    
    print("\n테스트 완료. 서버가 계속 실행 중입니다.")
    print("서버를 종료하려면 Ctrl+C를 누르세요.")
    
    try:
        # 메인 스레드 유지
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\n프로그램을 종료합니다.")
        server.stop()

# 고급 기능: XML-RPC 멀티콜
def demonstrate_multicall():
    """
    XML-RPC 멀티콜 데모
    한 번의 요청으로 여러 메서드 호출
    """
    client = XMLRPCClient('http://localhost:8000')
    
    # 멀티콜 생성
    multicall = client.proxy.system.multicall()
    
    # 여러 호출 추가
    multicall.add_call('calculator.add', 10, 20)
    multicall.add_call('calculator.multiply', 5, 6)
    multicall.add_call('string.uppercase', 'hello')
    multicall.add_call('system.echo', 'multicall test', 2)
    
    # 한 번에 실행
    try:
        results = multicall()
        print("\n멀티콜 결과:")
        for i, result in enumerate(results, 1):
            print(f"  호출 {i}: {result}")
    except Exception as e:
        print(f"멀티콜 실패: {e}")

# 안전한 XML-RPC 서버 확장
class SecureXMLRPCServer(XMLRPCServer):
    """
    보안 기능이 강화된 XML-RPC 서버
    
    실제 운영 환경에서는 추가 보안 조치 필요:
    1. SSL/TLS 암호화
    2. 강력한 인증 시스템
    3. 입력값 검증
    4. 접근 제어 목록
    5. 요청 제한
    """
    
    def __init__(self, host='localhost', port=8000, ssl_context=None):
        """
        보안 서버 초기화
        
        Args:
            ssl_context: SSLContext 객체 (SSL 사용 시)
        """
        super().__init__(host, port)
        
        # SSL 설정 (선택사항)
        if ssl_context:
            self.server.socket = ssl_context.wrap_socket(
                self.server.socket,
                server_side=True
            )
            logger.info("SSL/TLS 암호화 활성화")
    
    def register_function_with_auth(self, function, name=None, 
                                   required_role=None):
        """
        인증이 필요한 함수 등록
        
        실제 구현에서는 더 정교한 인증/인가 시스템 구현 필요
        """
        if required_role:
            # 데코레이터로 인증 체크 추가
            def secured_function(*args, **kwargs):
                # 인증 로직 구현
                # if not self._check_auth(required_role):
                #     raise Fault(403, "접근 권한이 없습니다.")
                return function(*args, **kwargs)
            
            secured_function.__name__ = function.__name__
            secured_function.__doc__ = function.__doc__
            
            self.server.register_function(
                secured_function, 
                name or function.__name__
            )
        else:
            self.server.register_function(function, name)

if __name__ == "__main__":
    # XML-RPC 데모 실행
    demonstrate_xmlrpc()
    
    # 멀티콜 데모 (선택사항)
    # demonstrate_multicall()
```

## 결론

CIDR 주소 처리, REST API 구현, XML-RPC 원격 프로시저 호출은 각각 네트워크 프로그래밍, 웹 서비스, 분산 시스템에서 필수적인 기술 요소들입니다.

**CIDR 주소 관리**는 현대 네트워크 환경에서 IP 주소 할당과 관리를 효율적으로 수행하기 위한 핵심 기술입니다. `ipaddress` 모듈을 활용하면 CIDR 표기법을 쉽게 파싱하고, IP 주소 범위를 생성하며, 서브넷 분할을 구현할 수 있습니다. 이는 네트워크 관리 도구, 클라우드 인프라 자동화, 보안 정책 구현 등 다양한 분야에서 활용됩니다.

**REST API**는 HTTP 프로토콜의 표준 메서드(GET, POST, PUT, DELETE 등)를 활용한 직관적이고 확장 가능한 웹 서비스 인터페이스입니다. Flask나 FastAPI 같은 프레임워크를 사용하면 데이터베이스 연동, 인증 시스템, 에러 처리, 문서화 등 완전한 기능의 RESTful 서비스를 빠르게 구축할 수 있습니다. 적절한 상태 코드 사용, 일관된 응답 형식, 버전 관리 전략은 견고한 REST API 설계의 핵심 요소입니다.

**XML-RPC**는 간단하면서도 효과적인 원격 프로시저 호출 프로토콜로, 복잡한 설정 없이도 시스템 간 통신을 구현할 수 있습니다. 특히 레거시 시스템이나 간단한 분산 애플리케이션에서 유용하며, 멀티콜 기능을 통해 여러 호출을 한 번의 요청으로 처리할 수 있어 효율성이 높습니다. 단, 보안 측면에서는 SSL/TLS 암호화와 강력한 인증 시스템을 반드시 함께 구현해야 합니다.

이 세 기술을 결합하면 완전한 네트워크 애플리케이션 스택을 구성할 수 있습니다:
1. CIDR을 통한 네트워크 리소스 관리
2. REST API를 통한 외부 인터페이스 제공
3. XML-RPC를 통한 내부 시스템 간 통신

실제 프로덕션 환경에서는 각 기술의 보안 취약점을 고려하여 적절한 보안 조치(입력 검증, 인증/인가, 암호화, 요청 제한 등)를 반드시 구현해야 합니다. 또한 모니터링, 로깅, 에러 처리, 문서화를 통해 안정적이고 유지보수가 용이한 시스템을 구축하는 것이 중요합니다.