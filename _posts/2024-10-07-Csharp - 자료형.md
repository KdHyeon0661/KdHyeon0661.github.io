---
layout: post
title: C# - 자료형
date: 2024-10-07 19:20:23 +0900
category: Csharp
---
# 변수, 자료형, 연산자

## 변수, 자료형, 연산자

C#은 정적 타입 언어로, 모든 변수는 사용 전에 명확한 자료형을 가져야 합니다. 주요 개념은 다음과 같습니다

- **변수**: 데이터를 저장하는 이름 붙은 메모리 공간입니다. `var`로 타입 추론이 가능하며, `const`와 `readonly`로 변경 불가능한 값을 정의할 수 있습니다.
- **자료형**: 값 형식(`struct`, 스택)과 참조 형식(`class`, 힙)으로 구분됩니다. 숫자, 문자, 문자열부터 튜플, 레코드까지 다양한 내장 타입을 제공합니다.
- **연산자**: 산술, 비교, 논리 연산자 외에도 널 처리(`?.`, `??`), 패턴 매칭(`is`, `switch`), 범위/인덱스(`..`, `^`) 같은 현대적인 연산자를 지원합니다.
- **형 변환**: 암시적/명시적 캐스팅, `Convert` 클래스, `TryParse` 메서드 등을 상황에 맞게 사용해야 합니다.
- **Null 안정성**: `Nullable` 컨텍스트를 활성화하여 `null` 참조 예외를 컴파일 타임에 미리 방지하는 것이 현대 C# 개발의 핵심입니다.

---

## 변수 : 데이터에 이름 붙이기

변수는 메모리 공간에 이름을 붙여, 프로그램 실행 중 데이터를 저장하고 참조할 수 있게 합니다. C#은 정적 타입 언어이기 때문에 변수를 선언할 때 그 타입이 결정되며, 일반적으로 컴파일 시간에 타입 안전성이 검증됩니다.

```csharp
int age = 25;           // 정수형 변수 선언과 초기화
string name = "Alice";  // 문자열 변수
bool isActive = true;   // 부울 변수
```

### 변수의 범위(Scope)와 수명(Lifetime)

변수가 접근 가능하고 존재하는 영역과 시간은 선언된 위치에 따라 결정됩니다.

```csharp
public class ExampleClass
{
    private int _field; // 필드: 클래스 전체에서 접근 가능. 객체와 생명주기를 함께함.

    public void MyMethod()
    {
        int localVar = 10; // 지역 변수: 메서드 블록 안에서만 접근 가능.
        {
            int innerVar = localVar + 1; // 중첩 블록의 지역 변수
        } // innerVar의 수명은 여기서 종료
        // Console.WriteLine(innerVar); // 오류: innerVar는 이 범위에 없음.
    } // localVar의 수명은 여기서 종료
}
```

- **지역 변수**: 메서드나 블록(`{}`) 내부에서 선언됩니다. 해당 블록을 벗어나면 소멸합니다.
- **필드/속성**: 클래스 내부에서 선언되며, 객체가 생성될 때 할당되고 가비지 컬렉션에 의해 수집될 때까지 존재합니다.

- **메모리 할당**: 일반적으로 값 형식(기본 타입, `struct`)은 스택에, 참조 형식(`class`, `string`, 배열 등)은 힙에 할당됩니다. 단, 값 형식이 참조 형식의 필드로 포함되면 힙에 함께 할당되며, 박싱된 값 형식도 힙에 저장됩니다.

### `var`: 암시적 타입 지역 변수

`var` 키워드를 사용하면 컴파일러가 오른쪽 초기화식의 타입을 추론하여 변수 타입을 결정합니다.

```csharp
var score = 95; // 컴파일러는 score를 int로 추론합니다.
var message = "Hello, World!"; // string으로 추론됩니다.
var list = new List<string>(); // List<string>으로 추론됩니다.

// var는 반드시 초기화와 함께 사용해야 하며, 지역 변수에만 적용 가능합니다.
// var notAllowed; // 오류: 초기화 필요
```

**사용 가이드라인**: `var`는 타입이 명확할 때(예: `new` 키워드, 캐스트 결과, 명확한 메서드 반환형) 코드 가독성을 높이기 위해 사용하세요. 타입이 불분명해지는 경우에는 명시적 타입 선언을 유지하는 것이 좋습니다.

### `dynamic`: 런타임에 결정되는 타입

`dynamic` 타입은 컴파일 타임 타입 검사를 우회하고, 모든 연산의 타입 검사를 런타임으로 미룹니다.

```csharp
dynamic anything = 10;
anything = "Now I'm a string"; // 문제없이 컴파일됨
anything.SomeMethod(); // 이 메서드 호출도 컴파일됨 (런타임에 존재하지 않으면 예외 발생)
```

**사용 가이드라인**: `dynamic`은 주로 COM 객체, 동적 언어(예: IronPython) 연동, 리플렉션 대체 등 특수한 상황에서만 제한적으로 사용해야 합니다. 일반적인 비즈니스 로직에서는 타입 안전성을 해치고 런타임 오류를 유발할 수 있으므로 피하는 것이 좋습니다.

### 상수(`const`)와 읽기 전용 필드(`readonly`)

값을 변경할 수 없는 식별자를 정의하는 두 가지 방법입니다.

| 특성 | `const` (상수) | `readonly` (읽기 전용 필드) |
| :--- | :--- | :--- |
| **할당 시기** | 컴파일 타임 | 런타임 (선언 시 또는 생성자 내) |
| **저장 위치** | 메타데이터(값이 호출 코드에 인라인됨) | 힙(객체의 일부) |
| **타입 제한** | 기본 제공 타입, `string`, `enum` 등 | 모든 타입 가능 |
| **표현식** | 컴파일 타임에 평가 가능한 상수 표현식만 | 런타임에 계산된 값 가능 |

```csharp
public class ConstantsExample
{
    public const double Pi = 3.14159; // 컴파일 타임 상수
    public static readonly DateTime AppStartTime = DateTime.UtcNow; // 런타임에 초기화

    public readonly string _id;
    public ConstantsExample(string id)
    {
        _id = id; // 생성자에서 한 번 할당 가능
    }
    // _id = "another"; // 생성자 외부에서는 할당 불가
}
```

**중요**: `const`로 정의된 값은 참조하는 어셈블리에 **값 자체가 복사되어 포함됩니다**. 따라서 라이브러리의 `const` 값을 변경하고 재배포하더라도, 이전 버전의 라이브러리를 참조한 클라이언트 코드는 변경 전의 `const` 값이 인라인되어 있기 때문에 새로운 값을 인식하지 못합니다. **공개 API의 일부로 제공될 가능성이 있는 상수 값은 `static readonly`를 사용하는 것이 버전 호환성에 유리합니다.**

---

## 자료형의 세계: 값 형식과 참조 형식

C#의 타입 시스템은 크게 **값 형식(Value Type)** 과 **참조 형식(Reference Type)** 으로 나뉩니다. 이 구분은 데이터가 메모리에 어떻게 저장되고 전달되는지를 결정하며, 성능과 동작 방식에 직접적인 영향을 미칩니다.

| 특성 | 값 형식 (예: `int`, `struct`, `enum`) | 참조 형식 (예: `string`, `class`, `배열`) |
| :--- | :--- | :--- |
| **저장 위치** | 주로 스택(또는 포함된 객체 내부) | 힙 |
| **변수 내용** | 실제 데이터 자체 | 데이터가 위치한 힙 메모리의 참조(주소) |
| **할당 동작** | 값 전체가 복사됨 | 참조(주소)만 복사됨 (객체는 공유) |
| **기본값** | `default(T)` (예: `int`는 0) | `null` |
| **상속** | `System.ValueType`에서 상속(시뮬레이션) | 모든 클래스는 `System.Object`에서 직접/간접 상속 |

### 주요 내장 자료형 요약

아래 표는 C#에서 자주 사용하는 내장 자료형을 정리한 것입니다. 각 타입의 크기, 표현 범위, 주요 사용 상황을 함께 설명하여 선택에 도움을 줍니다.

| 분류 | 타입 | 크기(바이트) | 표현 범위 / 정밀도 | 설명 및 예시 |
| :--- | :--- | :--- | :--- | :--- |
| **정수** | `byte` | 1 | 0 ~ 255 | 부호 없는 8비트 정수. 이진 데이터 처리에 적합. |
| | `sbyte` | 1 | -128 ~ 127 | 부호 있는 8비트 정수. |
| | `short` | 2 | -32,768 ~ 32,767 | 부호 있는 16비트 정수. |
| | `ushort` | 2 | 0 ~ 65,535 | 부호 없는 16비트 정수. |
| | `int` | 4 | -2,147,483,648 ~ 2,147,483,647 | **기본 정수 타입**. 대부분의 정수 계산에 사용. |
| | `uint` | 4 | 0 ~ 4,294,967,295 | 부호 없는 32비트 정수. 양수만 필요하거나 비트 연산에 사용. |
| | `long` | 8 | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 큰 정수 값이 필요할 때 사용. 리터럴 접미사 `L` (예: `100L`). |
| | `ulong` | 8 | 0 ~ 18,446,744,073,709,551,615 | 부호 없는 64비트 정수. 리터럴 접미사 `UL` (예: `100UL`). |
| **부동소수점** | `float` | 4 | 약 ±1.5e-45 ~ ±3.4e38, 정밀도 7자리 | **단정밀도**. 메모리가 중요하고 정밀도가 덜 중요한 그래픽스, 물리 엔진 등에 사용. 리터럴 접미사 `f` (예: `3.14f`). |
| | `double` | 8 | 약 ±5.0e-324 ~ ±1.7e308, 정밀도 15~16자리 | **배정밀도, 기본 부동소수점 타입**. 일반적인 과학/공학 계산에 사용. 리터럴 접미사 `d` 생략 가능. |
| | `decimal` | 16 | 약 ±1.0e-28 ~ ±7.9e28, 정밀도 28~29자리 | **고정밀도 10진수**. 금융, 회계 등 정확한 10진 연산이 필요한 경우에 사용. 부동소수점 오차 없음. 리터럴 접미사 `m` (예: `19.99m`). |
| **논리** | `bool` | 1 (실제 크기는 다양) | `true` 또는 `false` | 조건문, 논리 연산에 사용. |
| **문자** | `char` | 2 | U+0000 ~ U+FFFF (UTF-16 코드 유닛) | 단일 유니코드 문자. 리터럴은 작은따옴표 `'A'`. 서러게이트 쌍이나 결합 문자의 경우 여러 `char`로 표현. |
| **문자열** | `string` | (참조 형식) | 가변 길이 | **불변(Immutable)** UTF-16 문자열. 리터럴은 큰따옴표 `"Hello"`. 보간 `$"..."`, 원시 문자열 `"""..."""` 지원. |
| **객체** | `object` | (참조 형식) | 모든 타입의 기본 | 모든 타입의 최상위 기본 클래스. 값 형식을 할당하면 **박싱** 발생. |
| **동적** | `dynamic` | (참조 형식) | 런타임에 결정 | 컴파일러 검사 우회. 특수한 경우에만 사용. |
| **네이티브 정수** | `nint` | 플랫폼 종속(4/8) | 플랫폼에 따라 32/64비트 부호 있는 정수 | 네이티브 상호 운용, 포인터 산술에 사용. |
| | `nuint` | 플랫폼 종속(4/8) | 플랫폼에 따라 32/64비트 부호 없는 정수 | 위와 동일. |
| **인덱스/범위** | `Index` | (참조 형식) | 컬렉션 위치 표현 | `^1`(끝에서 첫 번째) 같은 구문 지원. |
| | `Range` | (참조 형식) | 컬렉션 범위 표현 | `1..4`(인덱스 1부터 3까지) 같은 구문 지원. 배열 슬라이싱에 사용. |
| **튜플** | `(T1, T2)` | (값 형식) | 여러 값의 임시 그룹 | `(int Id, string Name)` 형태로 명명 필드 가능. 분해(deconstruction) 지원. |
| **열거형** | `enum E` | 기본 `int` | 명명된 정수 상수 집합 | `[Flags]` 특성으로 비트 플래그 정의 가능. |
| **레코드** | `record class` | (참조 형식) | 데이터 중심의 불변 타입 | `with` 식으로 비파괴적 수정, 값 기반 동등성 비교. |
| | `record struct` | (값 형식) | 위와 동일, 구조체 버전 | 위와 동일. |

### 부동소수점 타입 심층 비교

`float`, `double`, `decimal`은 모두 실수를 표현하지만, 내부 표현 방식과 정밀도, 성능 특성이 크게 다릅니다.

*   **`float` (단정밀도)**:
    *   **메모리**: 4바이트
    *   **정밀도**: 약 7자리의 10진수 정밀도
    *   **용도**: 3D 그래픽스, 게임 물리 엔진처럼 수많은 실수 연산이 필요하지만 높은 정밀도가 필요하지 않은 분야. 메모리 대역폭과 계산 속도가 중요할 때.
    *   **주의**: 매우 작은 오차가 누적될 수 있습니다.

*   **`double` (배정밀도)**:
    *   **메모리**: 8바이트
    *   **정밀도**: 약 15~16자리의 10진수 정밀도
    *   **용도**: 기본 부동소수점 타입. 과학 계산, 공학, 통계 등 대부분의 일반적인 실수 연산에 적합. CPU에서 하드웨어 수준으로 최적화되어 있어 `float`보다 느리지 않은 경우가 많습니다.
    *   **주의**: 역시 이진 부동소수점 방식이므로 10진 소수(예: 0.1)를 정확히 표현할 수 없어 약간의 오차가 발생합니다.

*   **`decimal` (고정밀도 10진수)**:
    *   **메모리**: 16바이트
    *   **정밀도**: 약 28~29자리의 10진수 정밀도
    *   **용도**: 금융, 회계, 통화 계산처럼 **10진수 연산이 정확해야 하는 분야**. 10진수 값을 이진 부동소수점의 근사치가 아닌 정확한 10진 표현으로 저장합니다.
    *   **주의**: `double`이나 `float`보다 연산 속도가 현저히 느립니다(소프트웨어적으로 구현). 메모리 사용량도 큽니다.

**실무 규칙**: 일반 계산은 `double`, 정확한 10진 계산(특히 금액)은 `decimal`, 메모리와 속도가 최우선이면서 정밀도가 낮아도 되는 경우에만 `float`를 선택하세요.

### Nullable Reference Types (널 허용 참조 형식)

C# 8.0부터 도입된 이 기능은 참조 형식 변수에 `null`이 할당되는 것을 컴파일러가 추적하고 경고함으로써 `NullReferenceException`을 방지하는 데 도움을 줍니다.

```csharp
#nullable enable // 프로젝트 파일에 <Nullable>enable</Nullable> 설정과 동일

string nonNullable = "Hello";
// nonNullable = null; // 컴파일러 경고 발생

string? nullable = null; // 명시적으로 ?를 붙여 null 허용
int length = nullable?.Length ?? 0; // 널 조건 연산자로 안전하게 접근
```

**실무 규칙**: 새 프로젝트는 반드시 Nullable 참조 형식 컨텍스트를 활성화(`<Nullable>enable</Nullable>`)하고, `null`을 의도적으로 허용하는 참조에만 `?`를 붙여 명시하는 습관을 들이세요. 이는 코드의 안정성을 획기적으로 높여줍니다.

### 박싱(Boxing)과 언박싱(Unboxing)

값 형식을 참조 형식(`object`, `interface`)으로 변환하거나 그 반대로 변환하는 과정입니다. 이 과정은 성능 오버헤드(메모리 할당, 가비지 컬렉션 압력)를 수반합니다.

```csharp
int value = 123;
object boxed = value; // 박싱: 값 형식(int)을 object로 감쌈. 힙에 새 객체 생성.
int unboxed = (int)boxed; // 언박싱: object에서 원래 값 형식(int)으로 추출.
// int wrong = (short)boxed; // 오류: 언박싱은 정확히 일치하는 타입으로만 가능.
```

**성능 고려사항**: 반복문이나 고빈도 호출 경로에서의 박싱은 성능을 저하시킬 수 있습니다. 이를 피하려면 제네릭 컬렉션(`List<int>`), 제네릭 메서드, `struct` 제약 조건, 또는 `System.Span<T>` 같은 최신 API를 활용하세요.

---

## 연산자: 데이터를 조작하는 도구

연산자는 변수와 값에 대해 특정 연산을 수행하기 위해 사용되는 기호입니다.

### 기본 연산자 카테고리

| 연산자 | 설명 | 예시 |
| :--- | :--- | :--- |
| **산술** | 기본 수학 연산 | `+`, `-`, `*`, `/`, `%`(나머지), `++`, `--` |
| **비교** | 두 값을 비교 | `==`, `!=`, `<`, `>`, `<=`, `>=` |
| **논리** | 부울(`bool`) 값 연산 | `&&`(AND), `\|\|`(OR), `!`(NOT) |
| **대입** | 값 할당 | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `??=` |
| **비트/시프트** | 비트 단위 연산 | `&`(AND), `\|`(OR), `^`(XOR), `~`(NOT), `<<`, `>>` |
| **멤버/인덱스 접근** | 객체 멤버 접근 | `.`(멤버), `[]`(인덱서) |
| **타입 테스트/변환** | 타입 관련 | `is`, `as`, `(type)` |
| **널 조건/널 합병** | `null` 안전 처리 | `?.`, `?[]`, `??`, `??=` |
| **범위/인덱스** | 컬렉션 범위 지정 | `..`, `^` |

### 주요 연산자 심화 설명

#### 산술 연산자와 오버플로우(Overflow)

```csharp
int a = 10, b = 3;
Console.WriteLine(a / b); // 3 (정수 나눗셈은 소수점 이하를 버림)
Console.WriteLine((double)a / b); // 3.333... (한쪽을 double로 캐스팅)

int max = int.MaxValue;
int wrapped = max + 1; // 기본(unchecked 컨텍스트): 오버플로 발생, 값이 '감싸여' int.MinValue가 됨.
// checked(max + 1); // checked 컨텍스트: OverflowException 예외 발생
```

*   `checked` / `unchecked`: 정수 산술 연산 및 변환에서 오버플로를 검사할지 여부를 제어합니다. 기본적으로 대부분의 컨텍스트는 `unchecked`입니다. 민감한 계산(예: 금융)에서는 `checked`를 사용하는 것이 안전합니다.

#### 비교 및 논리 연산자

*   `==`와 `!=`: **값 형식**의 경우 값 자체를 비교합니다. **참조 형식**의 경우 기본적으로 참조(메모리 주소)가 같은지를 비교합니다. `string`은 특별히 **내용**을 비교하도록 재정의되어 있습니다.
*   **문자열 비교**: 문화권과 대소문자를 고려한 비교가 필요할 때는 `String.Equals` 메서드와 `StringComparison` 열거형을 사용하세요.

```csharp
string str1 = "Hello";
string str2 = "HELLO";
bool ordinalIgnoreCase = string.Equals(str1, str2, StringComparison.OrdinalIgnoreCase); // True
bool invariantCulture = string.Equals(str1, str2, StringComparison.InvariantCultureIgnoreCase); // True
```

#### 널 조건 및 널 합병 연산자 (Null-conditional / Null-coalescing)

`null` 값을 안전하게 처리하는 현대 C#의 필수 도구입니다.

```csharp
Person? person = GetPersonMaybeNull();

// ?. (널 조건 멤버 접근): person이 null이면 전체 식의 결과는 null
int? length = person?.Name?.Length;

// ?? (널 합병 연산자): 왼쪽 피연산자가 null이면 오른쪽 피연산자 반환
string displayName = person?.Name ?? "Unknown";

// ??= (널 합병 할당): 왼쪽 변수가 null일 때만 오른쪽 값을 할당
person ??= new Person("Default");
```

#### 패턴 매칭 연산자 (`is`, `switch`)

C# 7.0부터 강력해진 패턴 매칭은 타입 검사, 속성 검사 등을 간결한 구문으로 수행할 수 있게 합니다.

```csharp
object obj = "This is a string";

// 'is' 패턴 매칭: 타입 검사와 동시에 변수에 캐스팅
if (obj is string s && s.Length > 5)
{
    Console.WriteLine($"Long string: {s}");
}

// 'switch' 식 패턴 매칭
string description = obj switch
{
    int i when i > 0 => $"Positive number: {i}",
    int i => $"Non-positive number: {i}",
    string str => $"String of length {str.Length}",
    null => "Nothing",
    _ => "Unknown type" // 디폴트 케이스
};
```

#### 범위(`..`)와 인덱스(`^`) 연산자

C# 8.0에서 도입되어 배열이나 컬렉션의 부분을 쉽게 추출할 수 있습니다.

```csharp
int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

Index lastIndex = ^1; // 끝에서 첫 번째 요소
Console.WriteLine(numbers[lastIndex]); // 9
Console.WriteLine(numbers[^2]); // 8 (끝에서 두 번째)

Range middle = 1..^1; // 인덱스 1부터 끝에서 1 앞까지
int[] slice = numbers[middle]; // [1, 2, 3, 4, 5, 6, 7, 8]
var subSlice = numbers[2..5]; // [2, 3, 4]
```

---

## 형 변환: 타입 사이를 오가기

### 암시적 변환(Implicit Conversion)

컴파일러가 자동으로 수행할 수 있는 안전한 변환입니다. 주로 작은 타입에서 큰 타입으로, 또는 파생 클래스에서 기본 클래스로 변환할 때 발생합니다.

```csharp
int small = 100;
long big = small; // 암시적 변환: int -> long (데이터 손실 없음)

string text = "Hello";
object obj = text; // 암시적 변환: 파생 클래스(string) -> 기본 클래스(object)
```

### 명시적 변환(Explicit Conversion, 캐스팅)

데이터 손실 가능성이 있거나 변환 규칙이 명확하지 않을 때, 프로그래머가 명시적으로 요청해야 하는 변환입니다.

```csharp
double pi = 3.14159;
int approx = (int)pi; // 명시적 캐스팅: double -> int (소수점 이하 버림, 값 3)

object maybeString = "123";
string? str = maybeString as string; // 'as' 연산자: 안전한 참조 형식 변환 (실패시 null)
// string str2 = (string)maybeString; // 캐스팅: 실패시 InvalidCastException
```

### `Convert` 클래스와 `Parse`/`TryParse` 메서드

문자열 등 다른 형식에서 특정 타입으로 변환할 때 주로 사용됩니다.

```csharp
// Convert: 다양한 기본 타입 간 변환 지원. null을 기본값으로 처리할 수 있음.
int fromString1 = Convert.ToInt32("123"); // 123
int fromNull = Convert.ToInt32(null); // 0

// Parse: 문자열을 특정 타입으로 변환. 형식이 정확하지 않으면 FormatException 발생.
int fromString2 = int.Parse("123");

// TryParse: 변환 시도. 성공 여부를 bool로 반환하고, out 매개변수에 결과 저장. (예외 없음, 권장)
bool success = int.TryParse("123abc", out int result); // success = false, result = 0
success = int.TryParse("456", out result); // success = true, result = 456
```

**문화권(Culture) 주의점**: `double.Parse("1.23")`은 현재 시스템의 문화권 설정(한국은 `,`가 소수점)에 영향을 받습니다. 독립적인 형식을 보장하려면 `CultureInfo.InvariantCulture`를 명시하세요.

```csharp
using System.Globalization;
double value = double.Parse("1.23", CultureInfo.InvariantCulture);
```

---

## 실무 베스트 프랙티스 및 마무리

C#의 변수, 자료형, 연산자를 효과적으로 사용하기 위한 몇 가지 핵심 원칙을 정리합니다.

1. **Nullable Reference Types는 필수 도구**: 새 프로젝트에서는 반드시 활성화하고, 의식적으로 `null` 가능성을 표현하세요. 이는 런타임 오류를 컴파일 타임으로 끌어올리는 가장 효과적인 방법입니다.
2. **적절한 숫자 타입 선택**: 일반적인 계산은 `int`나 `double`, **금융이나 정확한 소수점 계산이 필요한 경우 반드시 `decimal`**을 사용하세요.
3. **문화권을 의식하라**: 사용자 입력 처리나 파일 입출력 시 `CultureInfo.InvariantCulture`를 사용하여 지역 설정에 독립적인 코드를 작성하세요.
4. **박싱은 성능의 적**: 고성능이 요구되는 코드에서는 박싱을 유발하는 코드(예: 값 형식을 `object`에 넣기, 제네릭이 아닌 컬렉션 사용)를 최소화하세요.
5. **연산자 우선순위에 맡기지 마라**: 복잡한 표현식에서는 명확성을 위해 괄호 `()`를 적극적으로 사용하세요.
6. **`const` vs `static readonly`**: 라이브러리를 만들어 배포한다면, 외부에 공개되는 상수 값은 버전 관리 문제를 피하기 위해 `static readonly`를 고려하세요.
7. **패턴 매칭을 활용한 깔끔한 코드**: 복잡한 `if-else` 체인이나 `switch` 문을 최신 패턴 매칭 구문으로 리팩터링하면 가독성이 크게 향상됩니다.
8. **문자열 보간은 편리하지만**: 고빈도 로깅 경로에서는 문자열 보간(`$""`)이 임시 문자열을 생성할 수 있으므로, 구조적 로깅 라이브러리(예: Serilog, Microsoft.Extensions.Logging)를 사용하는 것이 더 효율적일 수 있습니다.

변수와 타입 시스템을 이해하는 것은 모든 C# 프로그래밍의 기초입니다. 이 강력한 타입 시스템과 풍부한 연산자를 잘 활용하면 더욱 안정적이고 표현력 있는 코드를 작성할 수 있습니다. 이제 이 기본기를 바탕으로 컬렉션, LINQ, 비동기 프로그래밍 등 C#의 더 넓은 세계로 나아갈 준비가 되었습니다.