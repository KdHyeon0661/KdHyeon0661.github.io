---
layout: post
title: C# - 자료형
date: 2024-10-07 19:20:23 +0900
category: Csharp
---
# 변수, 자료형, 연산자

## 변수, 자료형, 연산자 (한눈에 보는 핵심)

C#은 정적 타입 언어로, 모든 변수는 사용 전에 명확한 자료형을 가져야 합니다. 주요 개념은 다음과 같습니다:
* **변수**: 데이터를 저장하는 이름 붙은 메모리 공간입니다. `var`로 타입 추론이 가능하며, `const`와 `readonly`로 변경 불가능한 값을 정의할 수 있습니다.
* **자료형**: 값 형식(`struct`, 스택)과 참조 형식(`class`, 힙)으로 구분됩니다. 숫자, 문자, 문자열부터 튜플, 레코드까지 다양한 내장 타입을 제공합니다.
* **연산자**: 산술, 비교, 논리 연산자 외에도 널 처리(`?.`, `??`), 패턴 매칭(`is`, `switch`), 범위/인덱스(`..`, `^`) 같은 현대적인 연산자를 지원합니다.
* **형 변환**: 암시적/명시적 캐스팅, `Convert` 클래스, `TryParse` 메서드 등을 상황에 맞게 사용해야 합니다.
* **Null 안정성**: `Nullable` 컨텍스트를 활성화하여 `null` 참조 예외를 컴파일 타임에 미리 방지하는 것이 현대 C# 개발의 핵심입니다.

---

## 1. 변수: 데이터에 이름 붙이기

변수는 메모리 공간에 이름을 붙여, 프로그램 실행 중 데이터를 저장하고 참조할 수 있게 합니다. C#은 정적 타입 언어이기 때문에 변수를 선언할 때 그 타입이 결정되며, 일반적으로 컴파일 시간에 타입 안전성이 검증됩니다.

```csharp
int age = 25;           // 정수형 변수 선언과 초기화
string name = "Alice";  // 문자열 변수
bool isActive = true;   // 부울 변수
```

### 변수의 범위(Scope)와 수명(Lifetime)

변수가 접근 가능하고 존재하는 영역과 시간은 선언된 위치에 따라 결정됩니다.

```csharp
public class ExampleClass
{
    private int _field; // 필드: 클래스 전체에서 접근 가능. 객체와 생명주기를 함께함.

    public void MyMethod()
    {
        int localVar = 10; // 지역 변수: 메서드 블록 안에서만 접근 가능.
        {
            int innerVar = localVar + 1; // 중첩 블록의 지역 변수
        } // innerVar의 수명은 여기서 종료
        // Console.WriteLine(innerVar); // 오류: innerVar는 이 범위에 없음.
    } // localVar의 수명은 여기서 종료
}
```

*   **지역 변수**: 메서드나 블록(`{}`) 내부에서 선언됩니다. 해당 블록을 벗어나면 소멸합니다.
*   **필드/속성**: 클래스 내부에서 선언되며, 객체가 생성될 때 할당되고 가비지 컬렉션에 의해 수집될 때까지 존재합니다.
*   **메모리 할당**: 일반적으로 값 형식(기본 타입, `struct`)은 스택에, 참조 형식(`class`, `string`, 배열 등)은 힙에 할당됩니다. (박싱된 값 형식은 예외)

### `var`: 암시적 타입 지역 변수

`var` 키워드를 사용하면 컴파일러가 오른쪽 초기화식의 타입을 추론하여 변수 타입을 결정합니다.

```csharp
var score = 95; // 컴파일러는 score를 int로 추론합니다.
var message = "Hello, World!"; // string으로 추론됩니다.
var list = new List<string>(); // List<string>으로 추론됩니다.

// var는 반드시 초기화와 함께 사용해야 하며, 지역 변수에만 적용 가능합니다.
// var notAllowed; // 오류: 초기화 필요
```

**사용 가이드라인**: `var`는 타입이 명확할 때(예: `new` 키워드, 캐스트 결과, 명확한 메서드 반환형) 코드 가독성을 높이기 위해 사용하세요. 타입이 불분명해지는 경우에는 명시적 타입 선언을 유지하는 것이 좋습니다.

### `dynamic`: 런타임에 결정되는 타입

`dynamic` 타입은 컴파일 타임 타입 검사를 우회하고, 모든 연산의 타입 검사를 런타임으로 미룹니다.

```csharp
dynamic anything = 10;
anything = "Now I'm a string"; // 문제없이 컴파일됨
anything.SomeMethod(); // 이 메서드 호출도 컴파일됨 (런타임에 존재하지 않으면 예외 발생)
```

**사용 가이드라인**: `dynamic`은 주로 COM 객체, 동적 언어(예: IronPython) 연동, 리플렉션 대체 등 특수한 상황에서만 제한적으로 사용해야 합니다. 일반적인 비즈니스 로직에서는 타입 안전성을 해치고 런타임 오류를 유발할 수 있으므로 피하는 것이 좋습니다.

### 상수(`const`)와 읽기 전용 필드(`readonly`)

값을 변경할 수 없는 식별자를 정의하는 두 가지 방법입니다.

| 특성 | `const` (상수) | `readonly` (읽기 전용 필드) |
| :--- | :--- | :--- |
| **할당 시기** | 컴파일 타임 | 런타임 (선언 시 또는 생성자 내) |
| **저장 위치** | 메타데이터(값이 호출 코드에 인라인됨) | 힙(객체의 일부) |
| **타입 제한** | 기본 제공 타입, `string`, `enum` 등 | 모든 타입 가능 |
| **표현식** | 컴파일 타임에 평가 가능한 상수 표현식만 | 런타임에 계산된 값 가능 |

```csharp
public class ConstantsExample
{
    public const double Pi = 3.14159; // 컴파일 타임 상수
    public static readonly DateTime AppStartTime = DateTime.UtcNow; // 런타임에 초기화

    public readonly string _id;
    public ConstantsExample(string id)
    {
        _id = id; // 생성자에서 한 번 할당 가능
        // _id = "another"; // 생성자 외부에서는 할당 불가
    }
}
```

**중요**: `const`로 정의된 값은 참조하는 어셈블리에 **값 자체가 복사되어 포함됩니다**. 따라서 라이브러리의 `const` 값을 변경하고 재배포하더라도, 이전 버전의 라이브러리를 참조한 클라이언트 코드는 변경 전의 `const` 값이 인라인되어 있기 때문에 새로운 값을 인식하지 못합니다. **공개 API의 일부로 제공될 가능성이 있는 상수 값은 `static readonly`를 사용하는 것이 버전 호환성에 유리합니다.**

---

## 2. 자료형의 세계: 값 형식과 참조 형식

C#의 타입 시스템은 크게 **값 형식(Value Type)** 과 **참조 형식(Reference Type)** 으로 나뉩니다. 이 구분은 데이터가 메모리에 어떻게 저장되고 전달되는지를 결정하며, 성능과 동작 방식에 직접적인 영향을 미칩니다.

| 특성 | 값 형식 (예: `int`, `struct`, `enum`) | 참조 형식 (예: `string`, `class`, `배열`) |
| :--- | :--- | :--- |
| **저장 위치** | 주로 스택(또는 포함된 객체 내부) | 힙 |
| **변수 내용** | 실제 데이터 자체 | 데이터가 위치한 힙 메모리의 참조(주소) |
| **할당 동작** | 값 전체가 복사됨 | 참조(주소)만 복사됨 (객체는 공유) |
| **기본값** | `default(T)` (예: `int`는 0) | `null` |
| **상속** | `System.ValueType`에서 상속(시뮬레이션) | 모든 클래스는 `System.Object`에서 직접/간접 상속 |

### 주요 내장 자료형 요약

| 분류 | 타입 | 설명 및 예시 | 주의사항 |
| :--- | :--- | :--- | :--- |
| **정수** | `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong` | 부호 있음/없음, 8~64비트 크기. `long big = 1_000_000_000L;` | 리터럴 접미사: `u`(uint), `L`(long), `UL`(ulong) |
| **실수** | `float`, `double`, `decimal` | 부동소수점. `float f = 1.23f;`, `double d = 1.23;`, `decimal m = 1.23m;` | **금융 계산은 `decimal`**(정밀도 높음). `double.NaN` 비교는 `double.IsNaN()` 사용. |
| **논리** | `bool` | `true` 또는 `false` | |
| **문자** | `char` | 단일 UTF-16 코드 유닛 (유니코드 스칼라 값) | 서러게이트 쌍이나 결합 문자를 처리할 때는 주의. |
| **문자열** | `string` | **불변(Immutable)** UTF-16 코드 유닛의 시퀀스. | 변경 연산(`Substring`, `Replace` 등)은 새 문자열 생성. 보간`$"..."`, Raw String `"""..."""` 지원. |
| **객체** | `object` | 모든 타입의 최상위 기본 클래스. | 값 형식을 `object`에 할당하면 **박싱** 발생. |
| **동적** | `dynamic` | 런타임에 타입 바인딩. | 컴파일러 검사 우회. 주의 요망. |
| **네이티브 정수** | `nint`, `nuint` | 플랫폼에 의존하는 크기(32/64비트). | 주로 네이티브 코드 상호 운용용. |
| **인덱스/범위** | `Index`, `Range` | `^1`(끝에서 첫 번째), `1..4`(범위) | 배열/컬렉션 슬라이싱에 사용. |
| **튜플** | `(int, string)` 또는 `(int Id, string Name)` | 경량 다중 값 컨테이너. | 분해, 명명 필드 지원. 간단한 DTO 대용. |
| **열거형** | `enum` | 명명된 상수 집합. 기본 `int`. | `[Flags]` 특성으로 비트 플래그 열거형 정의 가능. |
| **레코드** | `record class`, `record struct` | 데이터 중심의 불변 타입. | `with` 식으로 비파괴적 수정. |

### Nullable Reference Types (널 허용 참조 형식)

C# 8.0부터 도입된 이 기능은 참조 형식 변수에 `null`이 할당되는 것을 컴파일러가 추적하고 경고함으로써 `NullReferenceException`을 방지하는 데 도움을 줍니다.

```csharp
#nullable enable // 프로젝트 파일에 <Nullable>enable</Nullable> 설정과 동일

string nonNullable = "Hello";
// nonNullable = null; // 컴파일러 경고 발생

string? nullable = null; // 명시적으로 ?를 붙여 null 허용
int length = nullable?.Length ?? 0; // 널 조건 연산자로 안전하게 접근
```

**실무 규칙**: 새 프로젝트는 반드시 Nullable 참조 형식 컨텍스트를 활성화(`<Nullable>enable</Nullable>`)하고, `null`을 의도적으로 허용하는 참조에만 `?`를 붙여 명시하는 습관을 들이세요. 이는 코드의 안정성을 획기적으로 높여줍니다.

### 박싱(Boxing)과 언박싱(Unboxing)

값 형식을 참조 형식(`object`, `interface`)으로 변환하거나 그 반대로 변환하는 과정입니다. 이 과정은 성능 오버헤드(메모리 할당, 가비지 컬렉션 압력)를 수반합니다.

```csharp
int value = 123;
object boxed = value; // 박싱: 값 형식(int)을 object로 감쌈. 힙에 새 객체 생성.
int unboxed = (int)boxed; // 언박싱: object에서 원래 값 형식(int)으로 추출.
// int wrong = (short)boxed; // 오류: 언박싱은 정확히 일치하는 타입으로만 가능.
```

**성능 고려사항**: 반복문이나 고빈도 호출 경로에서의 박싱은 성능을 저하시킬 수 있습니다. 이를 피하려면 제네릭 컬렉션(`List<int>`), 제네릭 메서드, `struct` 제약 조건, 또는 `System.Span<T>` 같은 최신 API를 활용하세요.

---

## 3. 연산자: 데이터를 조작하는 도구

연산자는 변수와 값에 대해 특정 연산을 수행하기 위해 사용되는 기호입니다.

### 기본 연산자 카테고리

| 연산자 | 설명 | 예시 |
| :--- | :--- | :--- |
| **산술** | 기본 수학 연산 | `+`, `-`, `*`, `/`, `%`(나머지), `++`, `--` |
| **비교** | 두 값을 비교 | `==`, `!=`, `<`, `>`, `<=`, `>=` |
| **논리** | 부울(`bool`) 값 연산 | `&&`(AND), `\|\|`(OR), `!`(NOT) |
| **대입** | 값 할당 | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `??=` |
| **비트/시프트** | 비트 단위 연산 | `&`(AND), `\|`(OR), `^`(XOR), `~`(NOT), `<<`, `>>` |
| **멤버/인덱스 접근** | 객체 멤버 접근 | `.`(멤버), `[]`(인덱서) |
| **타입 테스트/변환** | 타입 관련 | `is`, `as`, `(type)` |
| **널 조건/널 합병** | `null` 안전 처리 | `?.`, `?[]`, `??`, `??=` |
| **범위/인덱스** | 컬렉션 범위 지정 | `..`, `^` |

### 주요 연산자 심화 설명

#### 산술 연산자와 오버플로우(Overflow)

```csharp
int a = 10, b = 3;
Console.WriteLine(a / b); // 3 (정수 나눗셈은 소수점 이하를 버림)
Console.WriteLine((double)a / b); // 3.333... (한쪽을 double로 캐스팅)

int max = int.MaxValue;
int wrapped = max + 1; // 기본(unchecked 컨텍스트): 오버플로 발생, 값이 '감싸여' int.MinValue가 됨.
// checked(max + 1); // checked 컨텍스트: OverflowException 예외 발생
```

*   `checked` / `unchecked`: 정수 산술 연산 및 변환에서 오버플로를 검사할지 여부를 제어합니다. 기본적으로 대부분의 컨텍스트는 `unchecked`입니다. 민감한 계산(예: 금융)에서는 `checked`를 사용하는 것이 안전합니다.

#### 비교 및 논리 연산자

*   `==`와 `!=`: **값 형식**의 경우 값 자체를 비교합니다. **참조 형식**의 경우 기본적으로 참조(메모리 주소)가 같은지를 비교합니다. `string`은 특별히 **내용**을 비교하도록 재정의되어 있습니다.
*   **문자열 비교**: 문화권과 대소문자를 고려한 비교가 필요할 때는 `String.Equals` 메서드와 `StringComparison` 열거형을 사용하세요.

```csharp
string str1 = "Hello";
string str2 = "HELLO";
bool ordinalIgnoreCase = string.Equals(str1, str2, StringComparison.OrdinalIgnoreCase); // True
bool invariantCulture = string.Equals(str1, str2, StringComparison.InvariantCultureIgnoreCase); // True
```

#### 널 조건 및 널 합병 연산자 (Null-conditional / Null-coalescing)

`null` 값을 안전하게 처리하는 현대 C#의 필수 도구입니다.

```csharp
Person? person = GetPersonMaybeNull();

// ?. (널 조건 멤버 접근): person이 null이면 전체 식의 결과는 null
int? length = person?.Name?.Length;

// ?? (널 합병 연산자): 왼쪽 피연산자가 null이면 오른쪽 피연산자 반환
string displayName = person?.Name ?? "Unknown";

// ??= (널 합병 할당): 왼쪽 변수가 null일 때만 오른쪽 값을 할당
person ??= new Person("Default");
```

#### 패턴 매칭 연산자 (`is`, `switch`)

C# 7.0부터 강력해진 패턴 매칭은 타입 검사, 속성 검사 등을 간결한 구문으로 수행할 수 있게 합니다.

```csharp
object obj = "This is a string";

// 'is' 패턴 매칭: 타입 검사와 동시에 변수에 캐스팅
if (obj is string s && s.Length > 5)
{
    Console.WriteLine($"Long string: {s}");
}

// 'switch' 식 패턴 매칭
string description = obj switch
{
    int i when i > 0 => $"Positive number: {i}",
    int i => $"Non-positive number: {i}",
    string str => $"String of length {str.Length}",
    null => "Nothing",
    _ => "Unknown type" // 디폴트 케이스
};
```

#### 범위(`..`)와 인덱스(`^`) 연산자

C# 8.0에서 도입되어 배열이나 컬렉션의 부분을 쉽게 추출할 수 있습니다.

```csharp
int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

Index lastIndex = ^1; // 끝에서 첫 번째 요소
Console.WriteLine(numbers[lastIndex]); // 9
Console.WriteLine(numbers[^2]); // 8 (끝에서 두 번째)

Range middle = 1..^1; // 인덱스 1부터 끝에서 1 앞까지
int[] slice = numbers[middle]; // [1, 2, 3, 4, 5, 6, 7, 8]
var subSlice = numbers[2..5]; // [2, 3, 4]
```

---

## 4. 형 변환: 타입 사이를 오가기

### 암시적 변환(Implicit Conversion)

컴파일러가 자동으로 수행할 수 있는 안전한 변환입니다. 주로 작은 타입에서 큰 타입으로, 또는 파생 클래스에서 기본 클래스로 변환할 때 발생합니다.

```csharp
int small = 100;
long big = small; // 암시적 변환: int -> long (데이터 손실 없음)

string text = "Hello";
object obj = text; // 암시적 변환: 파생 클래스(string) -> 기본 클래스(object)
```

### 명시적 변환(Explicit Conversion, 캐스팅)

데이터 손실 가능성이 있거나 변환 규칙이 명확하지 않을 때, 프로그래머가 명시적으로 요청해야 하는 변환입니다.

```csharp
double pi = 3.14159;
int approx = (int)pi; // 명시적 캐스팅: double -> int (소수점 이하 버림, 값 3)

object maybeString = "123";
string? str = maybeString as string; // 'as' 연산자: 안전한 참조 형식 변환 (실패시 null)
// string str2 = (string)maybeString; // 캐스팅: 실패시 InvalidCastException
```

### `Convert` 클래스와 `Parse`/`TryParse` 메서드

문자열 등 다른 형식에서 특정 타입으로 변환할 때 주로 사용됩니다.

```csharp
// Convert: 다양한 기본 타입 간 변환 지원. null을 기본값으로 처리할 수 있음.
int fromString1 = Convert.ToInt32("123"); // 123
int fromNull = Convert.ToInt32(null); // 0

// Parse: 문자열을 특정 타입으로 변환. 형식이 정확하지 않으면 FormatException 발생.
int fromString2 = int.Parse("123");

// TryParse: 변환 시도. 성공 여부를 bool로 반환하고, out 매개변수에 결과 저장. (예외 없음, 권장)
bool success = int.TryParse("123abc", out int result); // success = false, result = 0
success = int.TryParse("456", out result); // success = true, result = 456
```

**문화권(Culture) 주의점**: `double.Parse("1.23")`은 현재 시스템의 문화권 설정(한국은 `,`가 소수점)에 영향을 받습니다. 독립적인 형식을 보장하려면 `CultureInfo.InvariantCulture`를 명시하세요.

```csharp
using System.Globalization;
double value = double.Parse("1.23", CultureInfo.InvariantCulture);
```

---

## 5. 실무 베스트 프랙티스 및 마무리

C#의 변수, 자료형, 연산자를 효과적으로 사용하기 위한 몇 가지 핵심 원칙을 정리합니다.

1. **Nullable Reference Types는 필수 도구**: 새 프로젝트에서는 반드시 활성화하고, 의식적으로 `null` 가능성을 표현하세요. 이는 런타임 오류를 컴파일 타임으로 끌어올리는 가장 효과적인 방법입니다.
2. **적절한 숫자 타입 선택**: 일반적인 계산은 `int`나 `double`, **금융이나 정확한 소수점 계산이 필요한 경우 반드시 `decimal`**을 사용하세요.
3. **문화권을 의식하라**: 사용자 입력 처리나 파일 입출력 시 `CultureInfo.InvariantCulture`를 사용하여 지역 설정에 독립적인 코드를 작성하세요.
4. **박싱은 성능의 적**: 고성능이 요구되는 코드에서는 박싱을 유발하는 코드(예: 값 형식을 `object`에 넣기, 제네릭이 아닌 컬렉션 사용)를 최소화하세요.
5. **연산자 우선순위에 맡기지 마라**: 복잡한 표현식에서는 명확성을 위해 괄호 `()`를 적극적으로 사용하세요.
6. **`const` vs `static readonly`**: 라이브러리를 만들어 배포한다면, 외부에 공개되는 상수 값은 버전 관리 문제를 피하기 위해 `static readonly`를 고려하세요.
7. **패턴 매칭을 활용한 깔끔한 코드**: 복잡한 `if-else` 체인이나 `switch` 문을 최신 패턴 매칭 구문으로 리팩터링하면 가독성이 크게 향상됩니다.
8. **문자열 보간은 편리하지만**: 고빈도 로깅 경로에서는 문자열 보간(`$""`)이 임시 문자열을 생성할 수 있으므로, 구조적 로깅 라이브러리(예: Serilog, Microsoft.Extensions.Logging)를 사용하는 것이 더 효율적일 수 있습니다.

변수와 타입 시스템을 이해하는 것은 모든 C# 프로그래밍의 기초입니다. 이 강력한 타입 시스템과 풍부한 연산자를 잘 활용하면 더욱 안정적이고 표현력 있는 코드를 작성할 수 있습니다. 이제 이 기본기를 바탕으로 컬렉션, LINQ, 비동기 프로그래밍 등 C#의 더 넓은 세계로 나아갈 준비가 되었습니다.