---
layout: post
title: C# - 자료형
date: 2024-10-05 19:20:23 +0900
category: Csharp
---
# 변수, 자료형, 연산자

## 0) TL;DR

- **변수**: 정적 타입·지역/필드/상수/`readonly` 구분, **nullable reference** 켜기(`Nullable`).
- **자료형**: 값형(`struct`) vs 참조형(`class`), 숫자/문자열/`Span`/튜플/열거형/record.
- **연산자**: 산술/비교/논리/대입 + **비트/시프트**, **널 합류(??)**, **널 조건(?.)**, **패턴 매칭 `is`/`switch`**, **범위/인덱스 `..` `^`**.
- **형 변환**: 암시/명시 캐스팅, `Convert`, `TryParse`(+로캘), 박싱/언박싱 비용 인지.
- **오버플로**: `checked/unchecked`, `decimal` vs `double`, NaN 주의.

---

## 1) 변수란?

변수는 **메모리 공간에 이름을 붙인 것**이며, C#은 정적 타입 언어로 **선언 시 타입이 확정**됩니다.

```csharp
int age = 25;
string name = "Alice";
bool isActive = true;
```

### 1.1 스코프와 수명

```csharp
void Scope()
{
    int x = 10;                 // 지역 변수: 블록 안
    {
        int y = x + 1;          // 내부 블록
    }
    // y는 여기서 존재하지 않음
}
```

- **지역 변수**는 선언된 블록을 벗어나면 소멸.
- **필드/속성**은 객체 수명에 따름.
- **스택 할당 vs 힙 할당**: 값형은 보통 스택(박싱 제외), 참조형은 힙(객체).

### 1.2 `var`와 `dynamic`

```csharp
var score = 90;           // 컴파일 타임에 int로 고정(초기화 필수)
dynamic any = 123;        // 런타임 바인딩, 잘못 쓰면 예외가 런타임에
any = "text";             // 타입이 바뀌어도 컴파일러는 모름
```

- **권장**: `var`는 **코드 읽기성이 유지될 때** 사용. `dynamic`은 상호운용/메타프로그래밍 특수 상황만.

### 1.3 상수 `const` vs 읽기전용 `readonly`

```csharp
const double Pi = 3.141592653589793;  // 컴파일 타임 상수(릴터럴 또는 다른 const로만)
readonly DateTime _started = DateTime.UtcNow; // 런타임에 한 번만 설정 가능한 필드
```

- **라이브러리 배포 시**: `const`의 값은 **호출자에 인라인**되므로 버전 호환성 이슈 가능 → 바뀔 가능성 있는 값은 `static readonly` 사용.

---

## 2) 주요 자료형 (확장 해설)

| 분류 | 형식 | 크기/예시 | 메모 |
|---|---|---|---|
| 정수 | `sbyte`/`byte`/`short`/`ushort`/`int`/`uint`/`long`/`ulong` | `-128~127`… | 서픽스: `u`(uint), `L/UL`(long/ulong) |
| 실수 | `float`/`double`/`decimal` | `float f=1.23f` / `double d=1.23` / `decimal m=1.23m` | **금융**은 `decimal` 권장(정밀) |
| 논리 | `bool` | `true/false` | |
| 문자 | `char` | UTF-16 코드 유닛 1개 | 서러게이트/조합문자 조심 |
| 문자열 | `string` | 불변(immutable) | 보간 `$"Hi {x}"`, raw string `""" ... """` |
| 부호 | `nint`/`nuint` | 네이티브 정수 | 64/32비트 플랫폼 의존 |
| 참조 | `object` | 모든 타입의 최상 | 박싱/언박싱 주의 |
| 동적 | `dynamic` | 런타임 결정 | 최소한으로 사용 |
| 암시 | `var` | 컴파일러 추론 | 초기화 필수 |
| 범위·인덱스 | `Index`/`Range` | `^1`, `1..^1` | 슬라이싱 |
| 튜플 | `(int a, string b)` | 분해/명명 | 경량 DTO 대용 |
| 열거 | `enum` | 기본 `int` 기반 | 플래그 → `[Flags]` |
| 값형 레코드 | `record struct` | 불변 값 타입 | |

> **Nullable Reference Types**: 프로젝트에  
> ```xml
> <Nullable>enable</Nullable>
> ```  
> 를 켜면 `string`은 **Null 불가**, `string?`만 Null 허용. 실무 필수.

### 2.1 정수/실수 서픽스·리터럴

```csharp
long a = 8_000_000_000L;     // _로 가독성 향상
uint b = 100u;
decimal price = 19.99m;      // 금융/정밀 계산
double nan = double.NaN;     // NaN 비교는 항상 false(자기 자신과도)
```

```csharp
Console.WriteLine(double.NaN == double.NaN); // False
Console.WriteLine(double.IsNaN(double.NaN)); // True
```

### 2.2 값형 vs 참조형, 박싱/언박싱

```csharp
object box = 42;     // 박싱(힙에 상자)
int unbox = (int)box; // 언박싱(형 일치해야 함)
```

- 고빈도 경로에서 박싱은 **할당과 GC 압력**을 초래 → 제네릭, `struct` 제약, `Span<T>`로 회피.

---

## 3) 상수와 리터럴 세부

```csharp
const string Banner = "Welcome";    // 문자열 상수
const int Size = 1024;              // 수치 상수
```

- **컴파일 타임 표현식**만 가능. `DateTime.Now`는 `const` 불가.

---

## 4) 기본 연산자

### 4.1 산술

| 연산자 | 의미 | 비고 |
|---|---|---|
| `+ - * / %` | +, -, 곱, 나눗셈, 나머지 | 정수 나눗셈은 **버림** |
| `++ --` | 증감 | 전위/후위 모두 지원 |
| `checked/unchecked` | 오버플로 검사 | 기본은 **unchecked**(대부분 컨텍스트) |

```csharp
int a = 5, b = 2;
Console.WriteLine(a / b);           // 2
Console.WriteLine((double)a / b);   // 2.5 (형 변환)
```

**오버플로 제어**:

```csharp
int big = int.MaxValue;
int wrapped = big + 1;                  // 오버플로, 값 회전(정의됨)
int fail = checked(big + 1);            // OverflowException
```

### 4.2 비교

| 연산자 | 의미 |
|---|---|
| `== !=` | 값/참조 동등성(타입에 따라 의미 다름) |
| `> < >= <=` | 크기 비교 |

- `string` 비교는 **문화권/대소문자**를 의식. 기본 `==`는 **서수(ordinal)** 비교가 아닌 **내용 비교**. 정확 제어는 `StringComparer` 사용.

```csharp
bool eq = string.Equals(a, b, StringComparison.OrdinalIgnoreCase);
```

### 4.3 논리

| 연산자 | 의미 | 단축 평가 |
|---|---|---|
| `&&` | AND | O |
| `||` | OR | O |
| `!` | NOT | - |

### 4.4 대입/복합 대입

| 연산자 | 의미 |
|---|---|
| `=` `+=` `-=` `*=` `/=` `%=` | 산술 복합 |
| `&=` `|=` `^=` `<<=` `>>=` | 비트 복합 |
| `??=` | 왼쪽이 `null`일 때만 대입 |

```csharp
string? s = null;
s ??= "default"; // s가 null이면 "default"로
```

### 4.5 삼항, 널 합류/조건

```csharp
var label = score >= 60 ? "PASS" : "FAIL";
string name = input ?? "Unknown";       // null이면 대체
int? len = input?.Length;               // input이 null이면 결과 null
```

### 4.6 비트/시프트

| 연산자 | 의미 |
|---|---|
| `&` `|` `^` `~` | AND/OR/XOR/NOT |
| `<<` `>>` | 좌/우 시프트(부호 유지) |

```csharp
const int R=0b_0001, W=0b_0010, X=0b_0100;
int perm = R | W;
bool canExec = (perm & X) != 0;
```

> C# 11+: `>>`는 산술 시프트(부호 비트 유지). 부호 없는 시프트가 필요하면 `uint/ulong`으로 캐스팅.

### 4.7 연산자 우선순위(요약)

$$
() \;>\; [] \;>\; \text{단항} \;>\; * / \% \;>\; + - \;>\; << >> \;>\; < <= > >= \;>\; == != \;>\; \& \;>\; \^ \;>\; \| \;>\; \&\& \;>\; \|\| \;>\; ?? \;>\; ?: \;>\; = \text{류}
$$

- 헷갈리면 **괄호로 명시**하세요.

---

## 5) 최신 문법으로 더 편하게

### 5.1 패턴 매칭 `is` / `switch`

```csharp
object o = "text";
if (o is string s && s.Length > 0)
    Console.WriteLine(s.ToUpperInvariant());

string Describe(int n) => n switch
{
    < 0         => "negative",
    0           => "zero",
    > 0 and <10 => "small",
    _           => "large"
};
```

### 5.2 튜플과 분해

```csharp
(string Name, int Age) Get() => ("Kim", 29);

var (name, age) = Get();
Console.WriteLine($"{name} / {age}");
```

### 5.3 인덱스/범위

```csharp
int[] a = {10,20,30,40,50};
Console.WriteLine(a[^1]);     // 50 (끝에서 1번째)
var mid = a[1..^1];           // 20,30,40
```

---

## 6) 형 변환(Conversions)

### 6.1 암시/명시 캐스팅

```csharp
int i = 3;
double d = i;                 // 암시적(손실 없음)
int j = (int)3.9;             // 명시적(소수 버림)
```

### 6.2 `Convert` vs 캐스트 vs 파싱

```csharp
int n1 = Convert.ToInt32("123");     // 문화권 영향 O(공백 등 허용 폭 넓음)
int n2 = int.Parse("123");           // 형식 엄격
bool ok = int.TryParse("123", out var n3); // 예외 없이 안전
```

**문화권 제어**:

```csharp
using System.Globalization;

double v = double.Parse("3.14",
    NumberStyles.Float,
    CultureInfo.InvariantCulture);
```

### 6.3 박싱/언박싱 변환

```csharp
object o = 10;      // boxing
int k = (int)o;     // unboxing (형 일치 필수)
```

---

## 7) 문자열과 보간·서식

```csharp
int x = 5;
Console.WriteLine($"x={x:D3}");      // x=005
Console.WriteLine(string.Format("{0,8}", x)); // 폭/정렬
Console.WriteLine($$"""raw {{ braces }} and "quotes" {{x}}""");
```

- 고빈도에서 보간은 임시 문자열 할당 유발 → 로깅은 **구조적 로깅** 사용 권장.

---

## 8) 불변/가변, record/struct

```csharp
public record User(string Id, string Name, int Age);
var u1 = new User("u1","Kim",29);
var u2 = u1 with { Age = 30 };  // 비파괴적 복사

public readonly record struct Point(int X, int Y); // 값형 레코드
```

- **불변**은 버그를 줄이고 동시성 안전성↑.

---

## 9) 열거형과 플래그

```csharp
[Flags]
public enum FileOptionsEx { None=0, Read=1, Write=2, Execute=4 }

var opt = FileOptionsEx.Read | FileOptionsEx.Write;
bool canWrite = opt.HasFlag(FileOptionsEx.Write);
```

- `HasFlag`는 박싱 가능 → 고성능 경로에서는 `(opt & FileOptionsEx.Write) != 0` 사용.

---

## 10) 예제 모음

### 10.1 연산자 종합 출력

```csharp
using System;

class Program
{
    static void Main()
    {
        int a = 10, b = 3;
        Console.WriteLine("산술:");
        Console.WriteLine($"a+b={a+b}, a-b={a-b}, a*b={a*b}, a/b={a/b}, a%b={a%b}");

        Console.WriteLine("\n비교:");
        Console.WriteLine($"a==b:{a==b}, a!=b:{a!=b}, a>b:{a>b}, a<b:{a<b}");

        bool x = true, y = false;
        Console.WriteLine("\n논리:");
        Console.WriteLine($"x&&y:{x&&y}, x||y:{x||y}, !x:{!x}");

        Console.WriteLine("\n대입/널:");
        string? s = null;
        s ??= "default";
        Console.WriteLine(s);

        Console.WriteLine("\n비트:");
        const int R=1, W=2, X=4;
        int perm = R | W;
        Console.WriteLine($"perm={perm}, exec={(perm & X) != 0}");

        Console.WriteLine("\n형변환:");
        Console.WriteLine((double)a / b); // 3.333...
    }
}
```

### 10.2 오버플로/checked

```csharp
int max = int.MaxValue;
int wrap = max + 1;                 // 오버플로, wrap(정의된 동작)
try
{
    int fail = checked(max + 1);    // 예외
}
catch (OverflowException)
{
    Console.WriteLine("Overflow caught");
}
```

### 10.3 튜플/패턴/범위

```csharp
var user = (Id: "u1", Age: 20);
string segment = user switch
{
    { Age: < 13 } => "child",
    { Age: < 20 } => "teen",
    _             => "adult"
};

int[] xs = {1,2,3,4,5};
Console.WriteLine(xs[^1]);     // 5
Console.WriteLine(string.Join(",", xs[1..^1])); // 2,3,4
```

---

## 11) 실무 주의점·베스트 프랙티스

1. **Nullable Reference 활성화**: Null 안정성.
2. **`decimal` vs `double`**: 금액/금융은 `decimal`.
3. **문화권**: 파싱/서식은 `InvariantCulture` 또는 명시적 Culture.
4. **오버플로 민감 로직**: `checked`로 가드.
5. **박싱 최소화**: 제네릭·`struct`·`Span<T>` 활용.
6. **연산자 우선순위** 헷갈리면 **괄호**.
7. **`dynamic` 최소화**: 테스트/런타임 예외 위험.
8. **비트 플래그**: `[Flags]`+마스크 연산.
9. **읽기성**: `var`는 타입이 명백할 때만.
10. **상수 값 배포**: 라이브러리 외부 노출은 `const` 남용 금지 → `static readonly`.

---

## 12) 수학 보충 (정수 나눗셈·오버플로 직관)

정수 나눗셈은 **버림**:

$$
\left\lfloor \frac{5}{2} \right\rfloor = 2, \quad 5 \bmod 2 = 1
$$

32비트 정수 오버플로는 **모듈러 산술**처럼 동작:

$$
\text{int}:\; x \mapsto x \bmod 2^{32}
$$

따라서 `int.MaxValue + 1`은 최소값으로 회전합니다(검사 컨텍스트 제외).

---

## 13) 요약표

| 개념 | 핵심 |
|---|---|
| 변수/상수 | `var`(컴파일 추론), `dynamic`(런타임), `const`(컴파일 상수), `readonly`(런타임 1회 설정) |
| 타입 | 값형 vs 참조형, `decimal`(정밀), `string`(불변), 튜플/enum/record |
| 변환 | 암시/명시, `Convert`, `TryParse(Culture)` |
| 연산자 | 산술·비교·논리·대입 + 비트/시프트 + `?:` `??` `?.` `??=` |
| 안정성 | `checked`/`unchecked`, Nullable Reference, 박싱 최소화 |

---

## 14) 연습 과제 (간단)

1) 사용자에게 정수 **N**을 입력받아, `1..N`의 합을 **정수/실수** 두 방식으로 출력(형변환 차이 체험).  
2) 권한 플래그 `R=1,W=2,X=4`에서 입력 문자열 `"RW"`를 플래그로 변환하고 실행권한 여부 판단.  
3) 점수 → 등급 `A/B/C/F`를 **`switch` 패턴**으로 작성.

---

# 부록 A — 타입/리터럴 치트시트

```csharp
// 리터럴 서픽스
float f = 1.23f;
double d = 1.23;
decimal m = 1.23m;
long   L = 10L;
uint   u = 10u;
ulong ul = 10UL;

// 숫자 구분자
int big = 1_000_000;

// 2/8/16진
int bin = 0b_1010_0011;
int hex = 0xDEAD_BEEF;

// raw string literal (여러 줄)
string json = """
{
  "a": 1,
  "b": "text"
}
""";
```

---

# 부록 B — 빠른 Q&A

- **Q: `5/2`가 2인 이유?**  
  A: **정수 나눗셈**은 소수부를 버림. `5/2.0` 또는 `(double)5/2`로 2.5.

- **Q: `double.NaN == double.NaN`이 false인 이유?**  
  A: IEEE 754 규칙. NaN은 어떤 값과도 같지 않음. `double.IsNaN()` 사용.

- **Q: `const` 값 변경 시 호출자에게 반영되지 않는 이유?**  
  A: 호출자 **어셈블리**에 값이 인라인됨. `static readonly`로 대체.

- **Q: 문화권 이슈를 피하려면?**  
  A: 파싱/서식에 `CultureInfo.InvariantCulture` 사용.

---

# 끝맺음

이 글의 코드·표·규칙을 토대로, **변수 선언 → 타입 선택 → 형 변환 → 연산자 활용** 흐름을 체득하면 C# 문법의 80%는 잡습니다. 이후에는 **컬렉션/LINQ**, **비동기 `async/await`**, **메모리/성능(Span/record struct)** 로 확장하세요.