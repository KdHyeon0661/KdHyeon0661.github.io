---
layout: post
title: 파이썬 - 함수
date: 2024-08-08 19:20:23 +0900
category: Python
---
# 함수

## 1. 함수란?

- **특정 작업을 수행하는 코드 블록**으로, **재사용성·가독성·모듈화**를 제공합니다.
- `def`로 정의하며, 필요 시 **값을 반환**합니다(없으면 `None`).

```python
def say_hello():
    print("Hello, World!")

say_hello()  # Hello, World!
```

---

## 2. 기본 구조와 호출

```python
def add(a, b):
    """두 수를 더한 값을 반환한다."""
    return a + b

result = add(3, 5)
print(result)  # 8
```

| 요소 | 설명 |
|---|---|
| `def` | 함수 정의 시작 키워드 |
| 함수명 | 호출 시 사용할 식별자 |
| 매개변수 | 외부로부터 전달받는 값 |
| 본문 | 수행할 로직 |
| `return` | 결과 반환(없으면 `None`) |
| Docstring | `help()`/툴링에서 노출되는 설명 |

---

## 3. 매개변수의 모든 것

파이썬은 **다섯 종류**의 매개변수 자리를 제공합니다. (순서는 고정)

1) **Positional-only**: `/` 앞에 배치 → **오직 위치 인자**만 허용  
2) **Positional-or-keyword**: 일반 매개변수  
3) **Var-positional**: `*args` (가변 위치 인자)  
4) **Keyword-only**: `*` 뒤에 배치 → **키워드로만** 전달  
5) **Var-keyword**: `**kwargs` (가변 키워드 인자)

```python
def f(a, b, /, c, d=0, *args, e, f_=1, **kwargs):
    """a,b: 위치-only / e,f_: 키워드-only"""
    return a, b, c, d, args, e, f_, kwargs

print(f(1, 2, 3, e=10))               # (1,2,3,0,(),10,1,{})
print(f(1, 2, 3, 4, 5, 6, e=7, k=8))  # (1,2,3,4,(5,6),7,1,{'k':8})
# f(a=1, b=2, c=3, e=10)  # TypeError: a,b는 위치-only
# f(1, 2, 3, 4, 5, 6, 7)  # TypeError: e는 키워드-only
```

### 3.1 기본값(디폴트)과 평가 시점
- **기본값은 함수 정의 시점에 단 한 번 평가**되어 보관됩니다.
- 가변 객체를 기본값으로 쓰면 **공유**되어 버그의 원인이 됩니다.

```python
def append_bad(x, acc=[]):   # ❌ 위험
    acc.append(x)
    return acc

print(append_bad(1))  # [1]
print(append_bad(2))  # [1, 2]  ← 이전 호출의 리스트 재사용됨!

def append_good(x, acc=None):  # ✅ 안전
    if acc is None:
        acc = []
    acc.append(x)
    return acc
```

### 3.2 `*args`와 `**kwargs` 조합
```python
def audit(name, *scores, grade=None, **meta):
    return name, scores, grade, meta

print(audit("kim", 10, 20, grade="A", cls=2))
# ('kim', (10, 20), 'A', {'cls': 2})
```

---

## 4. 반환값: 하나·여러 개·`None`

- `return`이 없으면 `None`.
- 여러 값을 **튜플**로 패킹해 반환합니다(파이썬 문법적 설탕).

```python
def min_max(seq):
    return min(seq), max(seq)

lo, hi = min_max([3, 1, 9])
print(lo, hi)  # 1 9
```

---

## 5. 스코프와 이름 해석 (LEGB)

파이썬은 이름을 **L → E → G → B** 순으로 찾습니다.

- **L**ocal(함수 내부)  
- **E**nclosing(바로 바깥 함수 스코프)  
- **G**lobal(모듈 수준)  
- **B**uiltins(내장)

```python
x = "global"
def outer():
    x = "enclosing"
    def inner():
        x = "local"
        print(x)  # local
    inner()
    print(x)      # enclosing
outer()
print(x)          # global
```

### 5.1 `global`과 `nonlocal`
- `global`: **모듈 전역 변수**를 바인딩(재할당)하겠다고 선언
- `nonlocal`: **바로 바깥 함수 스코프 변수**에 바인딩

```python
count = 0
def inc_global():
    global count
    count += 1

def make_counter():
    n = 0
    def inc():
        nonlocal n
        n += 1
        return n
    return inc

c = make_counter()
print(c(), c(), c())  # 1 2 3
```

---

## 6. 클로저(Closure)와 late binding 함정

- 내부 함수가 **자신을 둘러싼 스코프의 변수**를 **포획**하여 유지하는 구조.

```python
def make_power(k):
    def power(x):
        return x ** k
    return power

square = make_power(2)
cube   = make_power(3)
print(square(5), cube(5))  # 25 125
```

**late binding**(루프 변수 캡처) 함정과 해결:

```python
funcs = []
for i in range(3):
    funcs.append(lambda x: x + i)   # i는 루프 종료 후 2로 남음

print([f(10) for f in funcs])  # [12, 12, 12]  ❌ 기대와 다름

# 해결 1) 디폴트 인자 활용 (정의 시점에 값 고정)
funcs = []
for i in range(3):
    funcs.append(lambda x, i=i: x + i)
print([f(10) for f in funcs])  # [10, 11, 12] ✅

# 해결 2) 클로저 팩토리
def make_adder(k):
    return lambda x: x + k
funcs = [make_adder(i) for i in range(3)]
```

---

## 7. 문서화 문자열(Docstring)과 `help()`

```python
def multiply(a: int, b: int) -> int:
    """
    두 수 a와 b를 곱한 값을 반환한다.

    Parameters
    ----------
    a : int
    b : int

    Returns
    -------
    int
    """
    return a * b

help(multiply)
```

- NumPy/Google 스타일 등 팀 컨벤션에 맞춰 일관되게 작성.
- Docstring은 툴링/IDE/문서 생성에서 활용됩니다.

---

## 8. 람다(lambda) 함수

- **익명 함수**. 짧고 단순한 표현식에 적합.

```python
square = lambda x: x * x
print(square(4))  # 16
```

> 복잡한 로직엔 `def`로 명시적으로 작성하는 것이 가독성/디버깅에 유리합니다.

---

## 9. 함수는 일급 객체 (First-class function)

- 변수에 할당, 다른 함수의 **인자/반환**으로 사용, 컨테이너에 저장 가능.

```python
def shout(s): return s.upper()
def speak(func, msg): return func(msg)
print(speak(shout, "hello"))  # HELLO

pipeline = [str.strip, str.title, lambda s: s.replace(" ", "")]
s = "  hello world  "
for fn in pipeline:
    s = fn(s)
print(s)  # HelloWorld
```

---

## 10. 고계 함수: `map`/`filter`/`functools`

```python
nums = [1, 2, 3, 4, 5]
print(list(map(lambda x: x*x, nums)))        # [1,4,9,16,25]
print(list(filter(lambda x: x%2==0, nums)))  # [2,4]
```

### 10.1 부분 적용(Partial)과 커링
```python
import functools as F

def mul(a, b, c): return a * b * c
mul_by_2 = F.partial(mul, 2)      # a=2 고정
print(mul_by_2(3, 4))             # 24
```

---

## 11. 데코레이터(Decorator)

- 함수를 **감싸**서 동작을 확장하는 패턴(로깅/권한/캐싱/리트라이 등).

```python
import time, functools as F

def timed(fn):
    @F.wraps(fn)
    def wrapper(*args, **kwargs):
        t0 = time.perf_counter()
        try:
            return fn(*args, **kwargs)
        finally:
            dt = time.perf_counter() - t0
            print(f"{fn.__name__} took {dt:.4f}s")
    return wrapper

@timed
def work(n):
    s = 0
    for i in range(n):
        s += i*i
    return s

print(work(100_000))
```

### 11.1 표준 라이브러리: `lru_cache`, `singledispatch`
```python
from functools import lru_cache, singledispatch

@lru_cache(maxsize=1024)
def fib(n: int) -> int:
    if n < 2: return n
    return fib(n-1) + fib(n-2)

@singledispatch
def dump(x): print("obj:", x)

@dump.register
def _(x: int): print("int:", x)

dump("hi")  # obj: hi
dump(10)    # int: 10
```

---

## 12. 제너레이터 함수와 `yield`

- `yield`를 포함하면 **제너레이터**가 되어 값을 **지연 생성**합니다.
- 큰 데이터 처리/파이프라인에 적합.

```python
def count_up_to(n):
    i = 1
    while i <= n:
        yield i
        i += 1

for x in count_up_to(3):
    print(x)  # 1 2 3
```

### 12.1 `yield from`으로 위임
```python
def chain(*iterables):
    for it in iterables:
        yield from it

print(list(chain([1,2], "ab")))  # [1,2,'a','b']
```

---

## 13. 비동기 함수: `async def` / `await`

- **코루틴**(coroutine)을 정의. 비동기 I/O에 적합.

```python
import asyncio

async def fetch(n):
    await asyncio.sleep(0.1)
    return f"res-{n}"

async def main():
    # 동시 실행
    res = await asyncio.gather(*(fetch(i) for i in range(3)))
    print(res)

asyncio.run(main())  # ['res-0', 'res-1', 'res-2']
```

---

## 14. 타입 힌트(PEP 484)와 시그니처

```python
from typing import Iterable, Callable, TypeVar, Optional, Any

T = TypeVar("T")
U = TypeVar("U")

def transform(xs: Iterable[T], f: Callable[[T], U]) -> list[U]:
    return [f(x) for x in xs]
```

- 정적 분석(IDE/mypy/pyright)과 문서화, 리팩터링에 큰 도움.
- 런타임 강제는 아니나, **API 계약**을 명확히 합니다.

---

## 15. 함수 객체의 메타데이터와 리플렉션

```python
def g(a: int, b: str = "x", /, *args, k: float, **kw) -> bool:
    """demo"""
    return True

print(g.__name__)         # 'g'
print(g.__doc__)          # 'demo'
print(g.__defaults__)     # ('x',)
print(g.__kwdefaults__)   # {'k': None}  (키워드-only 기본값)
print(g.__annotations__)  # {'a': <class 'int'>, 'b': <class 'str'>, 'return': <class 'bool'>}

import inspect
print(inspect.signature(g))  # (a: int, /, b: str = 'x', *args, k: float, **kw) -> bool
```

---

## 16. 인자 전달 모델(객체 참조에 의한 전달)

- 파이썬은 **객체 참조**를 전달합니다.  
- **불변 객체**(int/str/tuple 등)는 “새로 대입”하면 원본에 영향 없음.  
- **가변 객체**(list/dict/set 등)는 **제자리 수정**이 호출자에 영향을 줍니다.

```python
def touch(a, b):
    a += 1         # int: 새로운 객체 바인딩 (호출자 영향X)
    b.append(99)   # list: 제자리 수정 (호출자 영향O)

x = 1
y = [1, 2]
touch(x, y)
print(x, y)  # 1 [1, 2, 99]
```

---

## 17. 재귀(Recursion)와 종료 보장

- 재귀는 **기저 조건**이 필수. 복잡도/깊이 한계 주의.
- 꼬리 재귀 최적화는 **파이썬에서 자동 지원되지 않습니다**.

```python
def fact(n: int) -> int:
    if n <= 1: return 1
    return n * fact(n-1)
```

누적합 불변식(정확성 사고의 예):
$$
\text{루프 시작 시 } acc = \sum_{k=1}^{i-1} k
$$

---

## 18. 예외와 함수 경계

- **EAFP**(try/except) vs **LBYL**(사전 검사) 트레이드오프.
- 함수 경계에서 **에러 메시지**를 명확히.

```python
def to_int(s: str) -> int:
    try:
        return int(s)
    except ValueError as e:
        raise ValueError(f"정수가 아님: {s!r}") from e
```

---

## 19. 테스트 친화적 설계

- 순수 함수(입력→출력, 사이드이펙트 없음)를 선호.
- I/O는 **주입(인자)** 받아 테스트 더블로 치환.

```python
def read_first_line(reader) -> str:
    return reader().splitlines()[0]
```

---

## 20. 성능/모범사례 체크리스트

- **가변 기본값 금지**(필요 시 `None` + 내부 초기화).
- **분리와 명명**: 하나의 함수는 **하나의 책임**.
- **타입 힌트/Docstring**으로 계약 명확화.
- **데코레이터**로 교차 관심사(로깅/캐시/리트라이) 분리.
- 빈번 호출 로직엔 **지역 변수 바인딩**(속성/전역 접근 최소화).
- 대량 처리엔 **제너레이터/이터러블 파이프라인**으로 메모리 절약.
- **예외 흐름** 명확화: `raise` vs `return` 규약 일관.
- **API 안정성**: 파라미터 추가는 **키워드-only**로 먼저 도입하면 하위호환이 쉽다.

---

## 21. 종합 예제: 파이프라인 + 데코레이터 + 타입힌트

```python
from __future__ import annotations
from typing import Iterable, Callable, TypeVar, Iterator
from functools import wraps, lru_cache

T = TypeVar("T")
U = TypeVar("U")

def logged(fn: Callable[..., U]) -> Callable[..., U]:
    @wraps(fn)
    def wrapper(*args, **kw):
        print(f"[CALL] {fn.__name__} args={args} kw={kw}")
        out = fn(*args, **kw)
        print(f"[RET ] {fn.__name__} -> {out!r}")
        return out
    return wrapper

def map_iter(xs: Iterable[T], f: Callable[[T], U]) -> Iterator[U]:
    for x in xs:
        yield f(x)

@lru_cache(maxsize=256)
def square(n: int) -> int:
    return n * n

@logged
def pipeline(nums: Iterable[int], /, *, thresh: int = 0) -> list[int]:
    it = map_iter(nums, square)
    return [v for v in it if v >= thresh]

print(pipeline([1, 2, 3, 4], thresh=5))
print(pipeline([1, 2, 3, 4], thresh=5))  # square는 캐시로 재사용
```

---

## 22. 마무리 요약

- 함수는 **일급 객체**이며, **다양한 인자 체계**(pos-only/kw-only/가변)를 통해 **표현력 높은 API**를 설계할 수 있습니다.
- **LEGB** 규칙과 `global`/`nonlocal`, **클로저**를 정확히 이해하면, 상태를 품은 함수/팩토리를 안전하게 만들 수 있습니다.
- **가변 기본값** 함정, **late binding** 함정을 피하고, **데코레이터/제너레이터/타입 힌트**로 실전적인 품질을 끌어올리세요.
- **EAFP/LBYL**, **문서화/테스트 가능성**, **성능**까지 고려하면 **유지보수 친화적**인 함수형 API를 설계할 수 있습니다.
