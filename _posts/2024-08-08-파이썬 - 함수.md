---
layout: post
title: 파이썬 - 함수
date: 2024-08-08 19:20:23 +0900
category: Python
---
# 함수

함수는 프로그래밍에서 가장 중요한 개념 중 하나로, 특정 작업을 수행하는 재사용 가능한 코드 블록입니다. 파이썬에서 함수는 프로그램을 논리적 단위로 분해하고, 코드 재사용성을 높이며, 가독성과 유지보수성을 크게 향상시킵니다. 이 글에서는 함수의 기본 개념부터 고급 활용법까지 실제 예제를 통해 상세히 알아보겠습니다.

## 함수의 기본 개념과 정의

함수는 `def` 키워드로 정의되며, 특정 작업을 수행하고 필요에 따라 값을 반환하는 코드 블록입니다.

```python
# 기본 함수 정의 예제
def greet(name):
    """인사말을 생성하는 함수"""
    message = f"안녕하세요, {name}님!"
    return message

# 함수 호출
result = greet("김철수")
print(result)  # 안녕하세요, 김철수님!

# 여러 번 재사용
print(greet("이영희"))  # 안녕하세요, 이영희님!
print(greet("박지민"))  # 안녕하세요, 박지민님!
```

### 함수의 주요 구성 요소

1. **함수명**: 함수를 식별하는 이름 (일반적으로 소문자와 언더스코어 사용)
2. **매개변수**: 함수에 전달되는 입력 값
3. **본문**: 실제 작업을 수행하는 코드 블록
4. **반환값**: 함수의 결과로 반환되는 값 (`return`이 없으면 `None` 반환)
5. **독스트링**: 함수의 설명을 담은 문자열

## 다양한 매개변수 패턴

파이썬 함수는 다양한 방식으로 매개변수를 받을 수 있어 매우 유연한 API를 설계할 수 있습니다.

### 기본 매개변수와 필수 매개변수

```python
# 기본 매개변수가 있는 함수
def create_user(name, age, city="서울", active=True):
    """사용자 정보를 생성하는 함수"""
    return {
        "name": name,
        "age": age,
        "city": city,
        "active": active
    }

# 다양한 호출 방식
user1 = create_user("홍길동", 30)  # city와 active는 기본값 사용
user2 = create_user("김영희", 25, "부산")  # city만 지정
user3 = create_user("박지민", 28, "인천", False)  # 모든 매개변수 지정

print(user1)  # {'name': '홍길동', 'age': 30, 'city': '서울', 'active': True}
print(user2)  # {'name': '김영희', 'age': 25, 'city': '부산', 'active': True}
print(user3)  # {'name': '박지민', 'age': 28, 'city': '인천', 'active': False}
```

### 가변 길이 인자: `*args`와 `**kwargs`

```python
# *args: 가변 개수의 위치 인자
def sum_numbers(*args):
    """여러 숫자의 합을 계산"""
    print(f"인자: {args}, 타입: {type(args)}")  # 튜플로 받음
    return sum(args)

print(sum_numbers(1, 2, 3))        # 6
print(sum_numbers(1, 2, 3, 4, 5))  # 15
print(sum_numbers())               # 0 (빈 튜플)

# **kwargs: 가변 개수의 키워드 인자
def print_user_info(**kwargs):
    """사용자 정보를 출력"""
    print(f"인자: {kwargs}, 타입: {type(kwargs)}")  # 딕셔너리로 받음
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_user_info(name="김철수", age=30, city="서울")
print_user_info(name="이영희", occupation="개발자")

# 혼합 사용
def process_data(name, *scores, **metadata):
    """다양한 인자를 처리하는 함수"""
    print(f"이름: {name}")
    print(f"점수들: {scores}")
    print(f"메타데이터: {metadata}")
    return {
        "name": name,
        "average_score": sum(scores) / len(scores) if scores else 0,
        **metadata
    }

result = process_data("홍길동", 85, 90, 78, student_id="S001", grade="A")
print(result)
```

### 위치 전용과 키워드 전용 인자

파이썬 3.8부터 `/`와 `*`를 사용하여 인자 전달 방식을 명시적으로 제한할 수 있습니다.

```python
# / 앞의 매개변수는 위치 전용, * 뒤의 매개변수는 키워드 전용
def process_data(name, /, age, *, city="서울", country="한국"):
    """
    name: 위치 전용 인자 (positional-only)
    age: 위치 또는 키워드 인자 (positional-or-keyword)
    city, country: 키워드 전용 인자 (keyword-only)
    """
    return {
        "name": name,
        "age": age,
        "city": city,
        "country": country
    }

# 올바른 호출 방식
print(process_data("김철수", 30, city="부산"))  # 정상
print(process_data("이영희", age=25))           # 정상
# print(process_data(name="박지민", age=28))    # 오류: name은 위치 전용
# print(process_data("최민수", 22, "대구"))    # 오류: city는 키워드 전용
```

## 반환값과 다중 반환

함수는 여러 값을 튜플로 묶어 반환할 수 있으며, 이를 구조 분해 할당으로 받을 수 있습니다.

```python
# 여러 값 반환
def calculate_statistics(numbers):
    """통계 정보 계산"""
    if not numbers:
        return None, None, None
    
    mean = sum(numbers) / len(numbers)
    maximum = max(numbers)
    minimum = min(numbers)
    
    return mean, maximum, minimum  # 튜플로 반환

# 구조 분해 할당으로 받기
avg, max_val, min_val = calculate_statistics([85, 90, 78, 92, 88])
print(f"평균: {avg:.2f}, 최대값: {max_val}, 최소값: {min_val}")

# 딕셔너리로 반환하는 방식
def calculate_statistics_dict(numbers):
    """통계 정보를 딕셔너리로 반환"""
    if not numbers:
        return {}
    
    return {
        "mean": sum(numbers) / len(numbers),
        "max": max(numbers),
        "min": min(numbers),
        "count": len(numbers),
        "sum": sum(numbers)
    }

stats = calculate_statistics_dict([85, 90, 78, 92, 88])
print(stats)
```

## 변수의 스코프(Scope)

파이썬에서 변수의 유효 범위는 LEGB 규칙에 따라 결정됩니다.

```python
# LEGB 규칙 예제
x = "전역 변수 (Global)"

def outer_function():
    x = "외부 함수 변수 (Enclosing)"
    
    def inner_function():
        x = "내부 함수 변수 (Local)"
        print(f"내부 함수: {x}")
    
    inner_function()
    print(f"외부 함수: {x}")

outer_function()
print(f"전역: {x}")

# 출력 결과:
# 내부 함수: 내부 함수 변수 (Local)
# 외부 함수: 외부 함수 변수 (Enclosing)
# 전역: 전역 변수 (Global)
```

### `global`과 `nonlocal` 키워드

```python
# global 키워드
counter = 0

def increment_global():
    global counter  # 전역 변수 사용 선언
    counter += 1
    print(f"카운터: {counter}")

increment_global()  # 카운터: 1
increment_global()  # 카운터: 2
increment_global()  # 카운터: 3

# nonlocal 키워드
def make_counter():
    count = 0
    
    def increment():
        nonlocal count  # 외부 함수의 변수 사용 선언
        count += 1
        return count
    
    return increment

counter_func = make_counter()
print(counter_func())  # 1
print(counter_func())  # 2
print(counter_func())  # 3
```

## 람다 함수

람다는 이름 없이 정의되는 간단한 익명 함수입니다.

```python
# 기본 람다 함수
square = lambda x: x ** 2
print(square(5))  # 25

# sorted 함수와 함께 사용
students = [
    {"name": "김철수", "score": 85},
    {"name": "이영희", "score": 92},
    {"name": "박지민", "score": 78}
]

# 점수 기준 정렬
sorted_by_score = sorted(students, key=lambda s: s["score"], reverse=True)
print("점수 기준 정렬:", sorted_by_score)

# 이름 기준 정렬
sorted_by_name = sorted(students, key=lambda s: s["name"])
print("이름 기준 정렬:", sorted_by_name)

# map과 filter에서 사용
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
squares = list(map(lambda x: x * x, numbers))
evens = list(filter(lambda x: x % 2 == 0, numbers))

print(f"제곱수: {squares}")
print(f"짝수: {evens}")
```

## 함수 데코레이터

데코레이터는 함수를 수정하지 않고 기능을 추가하는 강력한 도구입니다.

```python
# 기본 데코레이터
def timer_decorator(func):
    """함수 실행 시간을 측정하는 데코레이터"""
    import time
    from functools import wraps
    
    @wraps(func)  # 원본 함수의 메타데이터 유지
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        elapsed = end_time - start_time
        
        print(f"{func.__name__} 실행 시간: {elapsed:.4f}초")
        return result
    
    return wrapper

# 데코레이터 사용
@timer_decorator
def calculate_sum(n):
    """1부터 n까지의 합 계산"""
    return sum(range(1, n + 1))

print(calculate_sum(1000000))

# 여러 데코레이터 조합
def log_decorator(func):
    """함수 호출을 로깅하는 데코레이터"""
    from functools import wraps
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"[LOG] 함수 {func.__name__} 호출, 인자: {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"[LOG] 함수 {func.__name__} 반환: {result}")
        return result
    
    return wrapper

@log_decorator
@timer_decorator
def process_data(data):
    """데이터 처리 함수"""
    return sum(data) / len(data) if data else 0

process_data([1, 2, 3, 4, 5])

# 데코레이터에 매개변수 전달
def repeat_decorator(times=1):
    """함수를 여러 번 반복 실행하는 데코레이터"""
    def decorator(func):
        from functools import wraps
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            results = []
            for i in range(times):
                print(f"반복 {i+1}/{times}")
                result = func(*args, **kwargs)
                results.append(result)
            return results
        
        return wrapper
    return decorator

@repeat_decorator(times=3)
def greet_person(name):
    return f"안녕, {name}!"

print(greet_person("철수"))
```

## 제너레이터 함수

제너레이터는 값을 필요할 때마다 생성하는 이터레이터를 만드는 함수입니다.

```python
# 기본 제너레이터
def count_up_to(n):
    """1부터 n까지 카운트하는 제너레이터"""
    i = 1
    while i <= n:
        yield i  # yield로 값을 반환하고 상태 유지
        i += 1

# 사용 예제
counter = count_up_to(5)
print(next(counter))  # 1
print(next(counter))  # 2
print(next(counter))  # 3

# for 루프와 함께 사용
for number in count_up_to(3):
    print(number)  # 1, 2, 3

# yield from으로 다른 제너레이터 위임
def flatten(nested_list):
    """중첩 리스트를 평탄화하는 제너레이터"""
    for item in nested_list:
        if isinstance(item, list):
            yield from flatten(item)  # 재귀적으로 평탄화
        else:
            yield item

nested = [1, [2, [3, 4], 5], 6]
print(list(flatten(nested)))  # [1, 2, 3, 4, 5, 6]

# 파일 처리에 유용한 제너레이터
def read_large_file(file_path):
    """대용량 파일을 한 줄씩 읽는 제너레이터"""
    with open(file_path, 'r', encoding='utf-8') as file:
        for line in file:
            yield line.strip()

# 메모리 효율적인 피보나치 수열
def fibonacci_generator(n):
    """피보나치 수열 생성기"""
    a, b = 0, 1
    count = 0
    while count < n:
        yield a
        a, b = b, a + b
        count += 1

print(list(fibonacci_generator(10)))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

## 타입 힌트와 함수 시그니처

파이썬 3.5부터 도입된 타입 힌트는 코드의 가독성과 유지보수성을 높여줍니다.

```python
from typing import List, Dict, Tuple, Optional, Union, Callable, Any
from typing import Iterable, Iterator

# 기본 타입 힌트
def calculate_average(numbers: List[float]) -> float:
    """숫자 리스트의 평균 계산"""
    if not numbers:
        return 0.0
    return sum(numbers) / len(numbers)

# 복합 타입
def process_user_data(
    user_id: int,
    name: str,
    scores: Optional[List[int]] = None,
    metadata: Dict[str, Any] = None
) -> Dict[str, Union[int, str, float, None]]:
    """사용자 데이터 처리"""
    if scores is None:
        scores = []
    if metadata is None:
        metadata = {}
    
    average = sum(scores) / len(scores) if scores else 0.0
    
    return {
        "user_id": user_id,
        "name": name,
        "average_score": average,
        "score_count": len(scores),
        **metadata
    }

# 콜백 함수 타입 힌트
def process_items(
    items: List[Any],
    processor: Callable[[Any], Any]
) -> List[Any]:
    """아이템 리스트를 처리 함수로 변환"""
    return [processor(item) for item in items]

# 제너릭 타입 (Python 3.9+)
from typing import TypeVar

T = TypeVar('T')  # 제너릭 타입 변수

def first_item(items: List[T]) -> Optional[T]:
    """리스트의 첫 번째 항목 반환"""
    return items[0] if items else None

# 실제 타입 체크 (런타임)
from typing import get_type_hints

def validate_types(func):
    """타입 힌트를 검증하는 데코레이터"""
    from functools import wraps
    import inspect
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        # 인자의 타입 검증 로직
        sig = inspect.signature(func)
        bound_args = sig.bind(*args, **kwargs)
        
        for param_name, param_value in bound_args.arguments.items():
            if param_name in func.__annotations__:
                expected_type = func.__annotations__[param_name]
                if not isinstance(param_value, expected_type):
                    raise TypeError(
                        f"매개변수 '{param_name}'의 타입이 잘못되었습니다. "
                        f"기대: {expected_type}, 실제: {type(param_value)}"
                    )
        
        return func(*args, **kwargs)
    
    return wrapper

@validate_types
def typed_function(name: str, age: int) -> str:
    return f"{name}은(는) {age}살입니다."

print(typed_function("김철수", 30))
# print(typed_function("이영희", "스물다섯"))  # TypeError 발생
```

## 함수형 프로그래밍 기법

파이썬은 함수형 프로그래밍 패러다임도 지원합니다.

```python
# 고차 함수: 함수를 인자로 받거나 반환하는 함수
def apply_twice(func, value):
    """함수를 두 번 적용"""
    return func(func(value))

def add_five(x):
    return x + 5

print(apply_twice(add_five, 10))  # 20 (10 → 15 → 20)

# 클로저를 이용한 함수 팩토리
def make_multiplier(factor):
    """지정된 배수를 반환하는 함수 생성"""
    def multiplier(x):
        return x * factor
    return multiplier

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15

# functools 모듈 활용
from functools import partial, reduce, lru_cache

# partial: 함수의 일부 인자를 고정
def power(base, exponent):
    return base ** exponent

square = partial(power, exponent=2)
cube = partial(power, exponent=3)

print(square(5))  # 25
print(cube(5))    # 125

# reduce: 시퀀스를 단일 값으로 축소
numbers = [1, 2, 3, 4, 5]
product = reduce(lambda x, y: x * y, numbers)
print(f"곱: {product}")  # 120

# lru_cache: 자동 메모이제이션
@lru_cache(maxsize=128)
def fibonacci(n):
    """피보나치 수 계산 (캐싱 적용)"""
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(100))  # 빠르게 계산됨
```

## 실전 응용 예제

### 데이터 처리 파이프라인

```python
from typing import List, Callable, Any
from functools import reduce

def create_data_pipeline(*processors: Callable[[Any], Any]):
    """데이터 처리 파이프라인 생성"""
    def pipeline(data):
        for processor in processors:
            data = processor(data)
        return data
    return pipeline

# 처리 함수들 정의
def filter_even(numbers: List[int]) -> List[int]:
    return [n for n in numbers if n % 2 == 0]

def square_numbers(numbers: List[int]) -> List[int]:
    return [n * n for n in numbers]

def sum_numbers(numbers: List[int]) -> int:
    return sum(numbers)

# 파이프라인 생성
process_pipeline = create_data_pipeline(
    filter_even,
    square_numbers,
    sum_numbers
)

# 실행
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = process_pipeline(data)
print(f"결과: {result}")  # 짝수만 필터링 → 제곱 → 합계
```

### API 요청 핸들러

```python
import json
from typing import Dict, Any, Optional
from functools import wraps
import time

def retry_decorator(max_retries=3, delay=1):
    """요청 실패 시 재시도하는 데코레이터"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_retries - 1:
                        raise
                    print(f"시도 {attempt + 1} 실패: {e}, {delay}초 후 재시도...")
                    time.sleep(delay)
            return None
        return wrapper
    return decorator

def validate_request(func):
    """요청 검증 데코레이터"""
    @wraps(func)
    def wrapper(data: Dict[str, Any], *args, **kwargs):
        # 필수 필드 검증
        required_fields = {"user_id", "action"}
        missing = required_fields - set(data.keys())
        
        if missing:
            raise ValueError(f"필수 필드 누락: {missing}")
        
        # 값 검증
        if not isinstance(data["user_id"], (int, str)):
            raise TypeError("user_id는 숫자나 문자열이어야 합니다")
        
        return func(data, *args, **kwargs)
    return wrapper

@retry_decorator(max_retries=2, delay=0.5)
@validate_request
def process_api_request(request_data: Dict[str, Any]) -> Dict[str, Any]:
    """API 요청 처리"""
    # 실제 API 처리 로직 (여기서는 시뮬레이션)
    print(f"요청 처리 중: {request_data}")
    
    if request_data.get("action") == "get_user":
        return {
            "status": "success",
            "data": {
                "user_id": request_data["user_id"],
                "name": "김철수",
                "email": "chulsoo@example.com"
            }
        }
    elif request_data.get("action") == "update_user":
        return {
            "status": "success",
            "message": "사용자 정보가 업데이트되었습니다"
        }
    else:
        return {
            "status": "error",
            "message": f"지원하지 않는 액션: {request_data.get('action')}"
        }

# 테스트
test_request = {
    "user_id": 12345,
    "action": "get_user",
    "additional_data": {"key": "value"}
}

try:
    response = process_api_request(test_request)
    print(json.dumps(response, indent=2, ensure_ascii=False))
except Exception as e:
    print(f"요청 실패: {e}")
```

## 결론

파이썬의 함수는 단순한 코드 재사용 도구를 넘어 다양한 프로그래밍 패러다임을 구현할 수 있는 강력한 도구입니다. 기본적인 함수 정의와 호출부터 시작하여, 가변 인자, 데코레이터, 제너레이터, 타입 힌트 등 다양한 고급 기능을 이해하고 활용하면 더욱 강력하고 유지보수 가능한 코드를 작성할 수 있습니다.

함수형 프로그래밍 기법을 적절히 활용하면 상태 관리가 간단해지고 테스트하기 쉬운 코드를 만들 수 있으며, 데코레이터를 통해 횡단 관심사를 깔끔하게 분리할 수 있습니다. 제너레이터는 대용량 데이터 처리를 메모리 효율적으로 수행할 수 있게 해주며, 타입 힌트는 코드의 의도를 명확히 전달하고 버그를 사전에 방지하는 데 도움이 됩니다.

실무에서는 하나의 함수가 하나의 명확한 책임만 가지도록 설계하고, 적절한 수준의 추상화로 복잡도를 관리하며, 문서화와 테스트를 철저히 하는 것이 중요합니다. 함수는 프로그램의 기본 구성 요소이므로, 함수 설계와 활용에 대한 깊은 이해는 파이썬 프로그래머로서의 역량을 크게 향상시킬 것입니다.