---
layout: post
title: Spring - 아키텍처 패턴
date: 2025-10-21 18:25:23 +0900
category: Spring
---
# 22. 아키텍처 패턴 — 계층형·헥사고널·클린 비교, 모듈러 모노리스 vs 마이크로서비스, DDD와 스프링 실전

> 목표: **아키텍처 선택 기준**을 명확히 하고(계층형/헥사고널/클린), **모듈러 모노리스**로 시작해 **마이크로서비스**로 확장할 수 있는 길을 열며, **DDD 전술·전략 패턴**을 **Spring**에서 구현하는 방법을 코드와 함께 정리한다.
> 기준: Spring Boot 3.3+, Java 21, Gradle 8, JPA 중심 예시(필요 시 JDBC/메시징 언급).

---

## A. 아키텍처 패턴 비교: 계층형 vs 헥사고널 vs 클린

### A-1. 공통 용어
- **도메인**: 비즈니스 규칙(풍부한 모델/불변식/정합성).
- **애플리케이션**: 유스케이스(트랜잭션 경계, 흐름 조립), 도메인 호출.
- **어댑터**: 입/출력 IO 구현(Web, DB, 메시징…).
- **포트**: 어댑터가 구현해야 하는 인터페이스(계약).

### A-2. 계층형(Layered)
```
Presentation (Controller, DTO)
↓
Application (Service, Tx, 유스케이스)
↓
Domain (Entity, Aggregate, Policy)
↓
Infrastructure (Repository 구현, 외부시스템)
```
- 장점: 이해 쉬움, 스프링 기본 샘플과 친화적, 빠른 온보딩.
- 단점: **의존 방향이 아래로만** 향해 **도메인 순수성** 유지가 어렵다(인프라 타입이 상위로 새어 올라오기 쉬움), 순환의존/Service-끼리 호출 난립.
- 적합: 단일 앱, 팀/규모 작거나 빠른 MVP.

### A-3. 헥사고널(Hexagonal, Ports & Adapters)
```
     ┌───────── Inbound Adapters (Web, gRPC, CLI…) ─────────┐
     │                                                       │
     │  Application (use cases, tx)  ←→  Domain (core)      │
     │                                                       │
     └──────── Outbound Adapters (DB, Kafka, S3, Mail) ─────┘
                 ↑ via Ports (interfaces)
```
- 장점: **의존이 항상 내부로**(도메인↔애플리케이션 중심). **테스트 용이**(포트 대체), 교체 가능성↑.
- 단점: 개념·분리 비용, 작은 팀에 과한 느낌일 수 있음.
- 적합: 장기 유지보수, 규제/테스트가 중요한 시스템.

### A-4. 클린(Clean Architecture)
- 원의 중심에 **엔터프라이즈 비즈니스 규칙(엔티티/유즈케이스)**, 바깥으로 프레임워크/어댑터.
- 사실상 헥사고널과 같은 철학(의존성 규칙: **밖→안만**).

### A-5. 구조 비교 표

| 항목 | 계층형 | 헥사고널/클린 |
|---|---|---|
| 의존 규칙 | 위→아래 | 바깥→안쪽(도메인 온전) |
| 테스트 | 통합 위주 | 유닛/계약 테스트 쉬움 |
| 변경 용이성 | 프레임워크 결합↑ | 프레임워크 교체 수월 |
| 학습·속도 | 빠름 | 초기 비용↑ |
| 권장 시작점 | MVP/단일 | 장기 프로젝트/도메인 복잡 |

---

## B. 모듈러 모노리스 vs 마이크로서비스

### B-1. 모듈러 모노리스(Modular Monolith)
- **단일 프로세스**지만 **강한 내부 경계**(모듈/패키지/빌드)로 나눈다.
- 장점: 트랜잭션/쿼리 단순, 배포/오버헤드↓, **도메인 경계를 발견**하기 좋음.
- 도구: **Gradle 멀티모듈**, ArchUnit, 패키지 프라이빗, JPMS(선택).

예) 멀티모듈
```
settings.gradle.kts
:app (Spring Boot, web/inbound)
:order-domain (순수 자바/도메인)
:order-application (use case/ports)
:order-adapter-jpa (JPA repo/엔티티 매핑)
:order-adapter-web (REST 어댑터)
:shared-kernel (ID, Money, DomainEvent 등)
```

> 원칙
> - `domain`은 **Spring/JPA 의존 금지**(순수 자바).
> - `application`은 **인터페이스(포트)**만 의존(도메인·shared만).
> - 어댑터(웹/JPA/메시징)에서 포트를 **구현**.
> - `app`(부트)만 스프링 자동구성/빈 wiring을 가짐.

### B-2. 마이크로서비스(MSA)
- **프로세스 분리** + **네트워크 경계**(배포/스케일/장애 격리).
- 장점: 독립 배포/스케일, 경계 명확.
- 단점: **분산 트랜잭션/일관성/운영 복잡도**(옵저버빌리티/레이트리밋/회복탄력성).
- 권장: **모듈러 모노리스로 시작** → 측정/성숙 후 **경계별 독립**.

### B-3. 마이그레이션 경로
1) 모듈러 모노리스에서 **Boundary(BC)**를 탄탄히: 포트/어댑터, 이벤트 발행.
2) **Anti-Corruption Layer**(ACL)로 외부 의존 줄이기.
3) 특정 모듈에 **독립적 비기능 요구**(스케일/성능/규제)가 생기면 **분리**.
4) 데이터는 **복제·소유권 이전**(CDC/이중쓰기 지양, **Outbox**로 이벤트화).
5) 런북/모니터링/서킷브레이커/스키마 버저닝을 갖추었을 때 분리.

---

## C. DDD(도메인 주도 설계)와 스프링 — 전술 패턴

### C-1. Aggregate/Entity/Value/Object
- **Aggregate**: 일관성 경계(트랜잭션 경계). **루트**만 외부가 참조/변경.
- **Entity**: 식별자(ID) 있음.
- **Value Object**: 동등성=속성값, 불변(예: `Money`, `Email`).
- **Domain Service**: 엔티티에 넣기 애매한 도메인 연산.

#### 예: Shared Kernel 값 타입
```java
// :shared-kernel
public record Money(@NonNull BigDecimal amount, @NonNull Currency currency) {
  public Money {
    if (amount.scale() > 2) amount = amount.setScale(2, RoundingMode.HALF_UP);
  }
  public Money add(Money other) {
    requireSameCurrency(other);
    return new Money(amount.add(other.amount), currency);
  }
  private void requireSameCurrency(Money other){
    if (!currency.equals(other.currency)) throw new IllegalArgumentException("diff currency");
  }
}
```

### C-2. Domain Model (순수 자바, 의존 0)
```java
// :order-domain
public final class Order {
  private final OrderId id;
  private final CustomerId customerId;
  private final List<OrderLine> lines = new ArrayList<>();
  private OrderState state = OrderState.PENDING;
  private Money total = new Money(BigDecimal.ZERO, Currency.getInstance("KRW"));

  private Order(OrderId id, CustomerId customerId) {
    this.id = id; this.customerId = customerId;
  }

  public static Order create(OrderId id, CustomerId customerId) {
    return new Order(id, customerId);
  }

  public void addLine(ProductId pid, Money price, int qty) {
    if (state != OrderState.PENDING) throw new IllegalStateException("immutable");
    lines.add(new OrderLine(pid, price, qty));
    recomputeTotal();
  }

  public void pay(Money paid) {
    if (!paid.equals(total)) throw new IllegalArgumentException("mismatch");
    state = OrderState.PAID;
  }

  public void cancel() {
    if (state == OrderState.PAID) throw new IllegalStateException("already paid");
    state = OrderState.CANCELLED;
  }

  private void recomputeTotal() {
    total = lines.stream().map(l -> l.price().multiply(l.qty()))
                 .reduce(new Money(BigDecimal.ZERO, total.currency()), Money::add);
  }

  // getters ... (ID, state, total, lines)
}
```

> 도메인 모델은 **JPA 애너테이션도 금지**. 영속화는 **어댑터**에서 담당.

### C-3. 애플리케이션(유스케이스, 포트)
```java
// :order-application
public interface PlaceOrderUseCase {
  OrderId place(PlaceOrderCommand cmd);
}
public record PlaceOrderCommand(CustomerId customerId, List<Line> lines) {
  public record Line(ProductId productId, Money price, int qty) {}
}

public interface OrderRepository {   // Outbound Port
  Optional<Order> findById(OrderId id);
  void save(Order order);
}

@Service
public class OrderApplicationService implements PlaceOrderUseCase {
  private final OrderRepository repo;
  private final DomainEventPublisher eventPublisher; // Outbound Port
  private final Clock clock;

  public OrderApplicationService(OrderRepository repo, DomainEventPublisher eventPublisher, Clock clock){
    this.repo = repo; this.eventPublisher = eventPublisher; this.clock = clock;
  }

  @Transactional
  public OrderId place(PlaceOrderCommand cmd) {
    var order = Order.create(OrderId.newId(), cmd.customerId());
    cmd.lines().forEach(l -> order.addLine(l.productId(), l.price(), l.qty()));
    repo.save(order);
    eventPublisher.publish(new OrderPlacedEvent(order.id(), Instant.now(clock)));
    return order.id();
  }
}
```

### C-4. 어댑터 — JPA 구현
```java
// :order-adapter-jpa
@Entity(name="orders")
class OrderJpa {
  @Id String id;
  String customerId;
  @Enumerated(EnumType.STRING) OrderState state;
  BigDecimal total;
  @OneToMany(mappedBy="order", cascade = CascadeType.ALL, orphanRemoval = true)
  List<OrderLineJpa> lines = new ArrayList<>();
  // ... toDomain()/fromDomain() 변환 로직
}

@Repository
class JpaOrderRepository implements OrderRepository {
  private final SpringDataOrderRepo jpa;

  public void save(Order order) { jpa.save(OrderMapper.toJpa(order)); }

  public Optional<Order> findById(OrderId id) {
    return jpa.findById(id.value()).map(OrderMapper::toDomain);
  }
}

interface SpringDataOrderRepo extends JpaRepository<OrderJpa, String> {}
```

### C-5. 어댑터 — Web(입력 포트 호출)
```java
// :order-adapter-web
@RestController
@RequestMapping("/orders")
@RequiredArgsConstructor
class OrderController {
  private final PlaceOrderUseCase place;

  @PostMapping
  ResponseEntity<Map<String,String>> place(@RequestBody PlaceOrderRequest req) {
    var id = place.place(req.toCommand());
    return ResponseEntity.created(URI.create("/orders/"+id.value()))
                         .body(Map.of("id", id.value()));
  }
}
```

> 의존 방향: `web` → `application`(port) → `domain` / `application` → `jpa-adapter`(port 구현).
> 스프링 빈은 `app` 모듈에서만 스캔/조립(자동구성)해도 좋다.

---

## D. 경계 강제: 빌드·코드 레벨 가드

### D-1. Gradle 멀티모듈 의존 그래프
```kotlin
// :app
implementation(project(":order-application"))
implementation(project(":order-adapter-web"))
implementation(project(":order-adapter-jpa"))
implementation(project(":shared-kernel"))

// :order-application
implementation(project(":order-domain"))
implementation(project(":shared-kernel"))
// (Spring 의존 최소화; @Service, @Transactional 정도 허용 or 순수 자바로 두고 app에서 구성)

// :order-domain
// no Spring/JPA deps
```

### D-2. 패키지 캡슐화
- **패키지-프라이빗** 생성자/메서드로 Aggregate 수술 제한.
- `internal` 패키지에 구현체 배치하고 컨트롤러는 DTO/포트만 보게.

### D-3. ArchUnit로 규칙 테스트
```java
@AnalyzeClasses(packages = "com.acme")
class ArchitectureTest {

  @Test
  void domain_should_not_depend_on_spring() {
    noClasses().that().resideInAnyPackage("..order.domain..")
      .should().dependOnClassesThat().resideInAnyPackage("org.springframework..","jakarta..")
      .check(new ClassFileImporter().importPackages("com.acme"));
  }

  @Test
  void adapters_should_depend_on_ports_not_vice_versa() {
    classes().that().resideInAnyPackage("..adapter..")
      .should().onlyDependOnClassesThat().resideInAnyPackage("..application..","..domain..","..shared..","java..","org.springframework..");
  }
}
```

---

## E. DDD 전략 패턴: Bounded Context, ACL, 통합

### E-1. Bounded Context & Ubiquitous Language
- **주문(Order) BC**, **재고(Inventory) BC**, **결제(Payment) BC**처럼 **모델/언어/데이터**를 분리.
- 동일 용어라도 **의미 다르면 분리**(예: “고객” vs “구매자”).

### E-2. 컨텍스트 매핑
- **Conformist**: 약자 쪽이 강자의 모델 준수.
- **ACL(Anti-Corruption Layer)**: 번역 계층으로 우리 모델 **오염 방지**.
- **Published Language**: 이벤트/문서화된 API로 느슨한 결합.

### E-3. ACL 예(외부 결제 게이트웨이)
```java
// 외부 결제 응답 → 우리 Domain 값으로 번역
@Component
class PaymentAcl {
  PaymentStatus toPaymentStatus(GatewayResponse r) {
    return switch (r.code()) {
      case "00" -> PaymentStatus.APPROVED;
      case "51" -> PaymentStatus.DECLINED_LIMIT;
      default -> PaymentStatus.UNKNOWN;
    };
  }
}
```

---

## F. 트랜잭션, 이벤트, 일관성

### F-1. 트랜잭션 경계
- **유스케이스(Application Service)**에서 시작/끝(`@Transactional`).
- Aggregate의 **불변식**은 **한 트랜잭션**에서 보장.

### F-2. 도메인 이벤트
- Aggregate 내부에서 **상태 변화** 시 이벤트 발행.
- **Outbox 패턴**: 같은 트랜잭션에 이벤트 레코드 저장 → 별도 퍼블리셔가 브로커(Kafka/RabbitMQ)에 전달(최종 일관성).

간단 예:
```java
public record OrderPlacedEvent(OrderId id, Instant at) implements DomainEvent {}

public interface DomainEventPublisher {
  void publish(DomainEvent e);
}

@Service
class OutboxPublisher implements DomainEventPublisher {
  private final OutboxRepository repo;
  public void publish(DomainEvent e) {
    repo.save(Outbox.of(e)); // JSON 저장
  }
}
```

퍼블리셔(별도 배치/스케줄러)에서:
```java
@Scheduled(fixedDelay = "PT2S")
void flush() {
  repo.findUnsent(100).forEach(evt -> {
    kafka.send("order.placed", evt.payload());
    repo.markSent(evt.id());
  });
}
```

### F-3. 사가(Saga) 개요
- 여러 BC에 걸친 장기 트랜잭션: **Orchestration**(중앙 조정자) vs **Choreography**(이벤트 기반).
- 실패 시 **보상 트랜잭션** 설계 필요.

---

## G. 데이터 모델링(DDD + JPA 팁)

### G-1. Aggregate 설계 규칙
- **쓰기 모델**은 작은 경계(한 엔티티 그래프)로 강한 일관성.
- **읽기 모델**은 **Projection/조회용 스키마**(CQRS)로 유연하게.
- **양방향 연관 최소화**, 외부 키는 **ID 값**만 들고 도메인에서 조회는 리포지토리로.

### G-2. JPA 매핑 어댑터 팁
- **값 타입(Member, Address)**은 **@Embeddable**로 어댑터에서만 사용 → 도메인 값 객체와 **매핑 변환**.
- N+1 방지: 조회용 리포지토리 별도(`findView…` + `fetch join`) 또는 **Spring Data Projections**.

---

## H. 테스트 전략

### H-1. 단위(도메인) 테스트
```java
class OrderTest {
  @Test void pay_requires_exact_amount() {
    var o = Order.create(OrderId.newId(), new CustomerId("C1"));
    o.addLine(new ProductId("P1"), new Money(new BigDecimal("1000"), KRW), 1);
    assertThrows(IllegalArgumentException.class, () -> o.pay(new Money(new BigDecimal("900"), KRW)));
  }
}
```

### H-2. 애플리케이션 유스케이스 테스트(포트 더블)
```java
class OrderAppServiceTest {
  OrderRepository repo = new InMemoryRepo();
  DomainEventPublisher pub = e -> events.add(e);
  OrderApplicationService svc = new OrderApplicationService(repo, pub, Clock.systemUTC());

  @Test void placeOrder_publishes_event() {
    var id = svc.place(new PlaceOrderCommand(new CustomerId("C1"), List.of(...)));
    assertThat(events).hasSize(1);
  }
}
```

### H-3. 어댑터 통합 테스트
- Web: `@WebMvcTest`/`@SpringBootTest(webEnvironment=RANDOM_PORT)`
- JPA: `@DataJpaTest`로 매핑/쿼리 검증.

---

## I. 모듈러 모노리스 완성 샘플(폴더/의존/스캔)

### I-1. 컴포넌트 스캔
- `@SpringBootApplication(scanBasePackages = {"com.acme.app","com.acme.order.adapter"})`
- 도메인/애플리케이션은 스프링 빈이 아니어도 됨(구성에서 `@Bean`으로 Wiring).

### I-2. 구성 루트
```java
@Configuration
class OrderModuleConfig {

  @Bean
  OrderApplicationService orderApplicationService(OrderRepository repo, DomainEventPublisher pub, Clock clock) {
    return new OrderApplicationService(repo, pub, clock);
  }

  @Bean Clock clock() { return Clock.systemUTC(); }
}
```

---

## J. 마이크로서비스 분리 시 고려사항 체크리스트

- [ ] **경계 명확**(포트/이벤트 이미 있다).
- [ ] **데이터 소유권/읽기 복제** 전략 수립(CDC 가능).
- [ ] **계약 고정**(OpenAPI/AsyncAPI/스키마 레지스트리).
- [ ] **관측성**: 로그/메트릭/트레이스 상관관계 준비.
- [ ] **회복탄력성**: 서킷/리트라이/타임아웃 기본값.
- [ ] **릴리즈 전략**: 게이트웨이 Canary/Blue-Green.
- [ ] **보안**: 서비스 간 mTLS, 토큰/스코프.
- [ ] **운영비용** 감당 가능한가? (CI/CD·인프라·알람).

---

## K. 패턴 모음(실전 메모)

- **API 조합은 BFF**에서(게이트웨이에서 과도한 변환은 지양).
- **읽기 최적화**는 별도 Projection(조회 전용 Repository)로 CQRS.
- **Idempotency-Key**로 중복 요청 안전화.
- **비즈니스 규칙**은 도메인으로 끌어올리고, **인프라 상세**는 어댑터로 내린다.
- **모듈 간 호출 금지**: 반드시 포트·이벤트 경유.
- **업무 규칙 테스트**가 **DB/웹 없이**도 빠르게 돌도록 만든다.

---

## L. FAQ/안티패턴

- **Service 안에 비즈니스 규칙** 전부? → **Anemic Domain**(빈약 도메인) 위험. 규칙은 **엔티티/VO/정책**으로.
- **도메인에 JPA Entity**? → 프레임워크 결합. **매핑은 어댑터**에서.
- **모듈 경계 뚫기**(다른 모듈 엔티티 직접 import) → **포트/이벤트**로만 교류.
- **트랜잭션 경계 남발** → 유스케이스 1개=1경계(명확).
- **이벤트 남발** → 동기 호출로 충분한 경우 단순하게. 이벤트는 **팀 경계/비동기 이점** 있을 때.

---

## M. 한 장 요약

1) **헥사고널/클린**은 “**의존은 항상 핵심으로**”라는 규칙으로 테스트·교체 가능성을 높인다.
2) **모듈러 모노리스**로 시작해 경계를 가다듬고, **Outbox/ACL/이벤트**를 준비하면 **MSA 전환 비용**을 최소화할 수 있다.
3) **DDD 전술**(Aggregate/Value/Domain Service)로 **불변식**을 모델에 녹이고, **애플리케이션 서비스**는 트랜잭션과 흐름만 담당한다.
4) **포트/어댑터**를 통해 프레임워크/JPA/Web을 **변경 가능 부품**으로 만든다.
5) **ArchUnit/멀티모듈**로 경계를 강제하고, **테스트**는 도메인/유스케이스 중심으로 빠르게 돌린다.
