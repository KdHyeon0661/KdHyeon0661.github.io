---
layout: post
title: 네트워크보안 - 필수 도구 모음
date: 2025-11-03 21:25:23 +0900
category: 네트워크보안
---
# A. 필수 도구 모음: tcpdump / Wireshark / Zeek / Suricata / Nmap / Masscan / Scapy

> 목표
> - **현업/랩**에서 가장 자주 쓰는 7대 도구의 **역할·강점**을 비교하고, 실전에 바로 쓰는 **명령어·필터·스크립트**를 체계적으로 익힌다.
> - **수집 → 해석 → 탐지 → 시각화 → 재현**까지의 **엔드투엔드 흐름**을 예제와 함께 다룬다.
> - 모든 예제는 **합법적·승인된 환경**(랩/테스트망/자사 자산)에서만 수행한다. 무단 스캔/침입은 **불법**이다.

---

## A.0 한눈에 보는 도구 포지션

| 도구 | 주 역할 | 강점 | 한계/주의 | 대표 아웃풋 |
|---|---|---|---|---|
| **tcpdump** | 패킷 **캡처/필터** | 가벼움, 정확한 BPF, 자동화 친화 | GUI 없음, 해석은 별도 | `.pcap` 파일/텍스트 |
| **Wireshark/tshark** | 패킷 **해석/시각화** | 강력한 디스섹터, 필터/컬러링 | 대용량/헤드리스 제약 | GUI, CSV, PDML |
| **Zeek** | **L7 가시성/로그** | 세션화·파일 추출·스크립팅 | 룰 대신 정책 기반, 튜닝 필요 | `*.log`(TSV/JSON) |
| **Suricata** | **서명 기반 IDS/IPS** | 다중 스레드, `eve.json` | 룰 품질/튜닝 필수 | JSON 이벤트/PCAP |
| **Nmap** | **서비스 식별/포트** | NSE 스크립트 생태계 | 대규모 스캔 느림 | 텍스트/XML |
| **Masscan/ZMap** | **초고속 스캔** | PPS/대역 활용 | 결과 **오탐/미확인** ↑ | 텍스트/JSON |
| **Scapy** | **패킷 제작/실험** | 프로토콜 교육/테스트 | 숙련 필요, 속도 한계 | 파이썬/pcap |

---

## A.1 공통 준비·윤리·성능 팁

- **윤리/법**: (1) **승인된 범위(ROE)** 문서화, (2) **소유 증빙** 확보, (3) **로깅/개인정보 최소화**, (4) **속도 제한(rate-limit)**, (5) **연락 포인트** 포함.
- **성능**: 캡처는 **드롭률**이 핵심. 필터(BPF), 스냅샷 길이(`-s`), 링버퍼(`-G/-W`), 고정 크기 MTU/Offload 옵션(Tx/Rx checksum offload 비활성) 튜닝.
- **타임스탬프**: 로그/PCAP/시스템 시각 **UTC 통일** 권장.
- **재현성**: 모든 실습은 **명령·환경·결과**를 텍스트로 남긴다(“정답”보다 **근거**가 중요).

---

## A.2 tcpdump — 캡처의 표준

### A.2.1 필수 옵션과 BPF 필터

```bash
# 인터페이스 목록

sudo tcpdump -D

# 표준 캡처: eth0에서 HTTP(S)와 DNS만, 256바이트만 캡처, pcap 저장

sudo tcpdump -i eth0 -s 256 '(tcp port 80 or tcp port 443 or udp port 53)' -w web_dns.pcap

# 3-way handshakes만 보기(SYN, ACK없는 SYN-ACK 제외)

sudo tcpdump -i eth0 'tcp[13] & 2 != 0 and tcp[13] & 16 = 0'

# 특정 서버와의 TLS ClientHello 잡기(포트, SNI 전 메타만)

sudo tcpdump -i eth0 'tcp port 443 and (tcp[13] & 2 != 0 or tcp[13] & 16 != 0)' -A

# 링 버퍼(5분 파일로 순환, 48개=4시간)

sudo tcpdump -i eth0 -s 96 -G 300 -W 48 -w 'cap-%Y%m%d-%H%M%S.pcap' 'tcp or udp'

# IPv6, VLAN, 802.11(모니터 모드) 예시

sudo tcpdump -i wlan0mon -I -s 0 type mgt or type ctl or type data
sudo tcpdump -i eth0 'vlan and ip6 and port 443'
```

**자주 쓰는 BPF 스니펫**
- TCP 플래그: `tcp[13] & 1 = 1`(FIN), `2`(SYN), `4`(RST), `16`(ACK)
- 패킷 크기: `greater 1500`
- 넷·호스트: `net 10.0.0.0/8`, `host 10.0.0.5`, `src net`, `dst host`
- 조합: `and / or / not` (괄호 필수!)

### A.2.2 실무 캡처 레시피

**레시피 1 — 재전송/손실 의심 캡처**
```bash
sudo tcpdump -i eth0 -s 0 -w suspect.pcap 'tcp and (port 80 or port 443)'
# 후속: Wireshark "tcp.analysis.retransmission || tcp.analysis.fast_retransmission"

```

**레시피 2 — DNS 싱크홀/피싱 탐지**
```bash
sudo tcpdump -i eth0 -s 0 -vvv udp port 53 and '((udp[10:2] & 0x8000) = 0)' # 쿼리만
```

**레시피 3 — NetFlow 못 쓰는 구간 간이 흐름 통계**
```bash
sudo tcpdump -i eth0 -nn -tt 'tcp or udp' -l | awk '{print $3,$5}' | cut -d'.' -f1-4 | sort | uniq -c | sort -nr | head
```

### A.2.3 문제해결 팁

- **드롭률?** `-v`로 “packets captured/received/dropped by kernel” 확인, `-B`(ring buffer) 증가.
- **오프로드 이슈**: `ethtool -K eth0 gro off gso off tso off lro off` (테스트 망에서만).
- **스냅샷**: 0(전체)은 디스크 부담↑, 일반적으로 `96~256`로 충분(헤더+일부 페이로드).

---

## A.3 Wireshark / tshark — 해석과 시각화

### A.3.1 실무 프로필 세팅(핵심)

- **컬럼 추가**: `tcp.stream`, `http.host`, `dns.qry.name`, `tls.handshake.extensions_server_name`
- **컬러링 룰**: RST/재전송/윈도우 제로/ICMP 오류 강조.
- **Display Filter 단골**
  - `tcp.flags.syn == 1 and tcp.flags.ack == 0` (초기 SYN)
  - `tcp.analysis.retransmission || tcp.analysis.fast_retransmission`
  - `dns.flags.response == 1 && dns.a`
  - `http.request || http.response`
  - `tls.handshake.type == 1` (ClientHello), `tls.handshake.extensions_server_name`
  - `icmp || icmpv6`

### A.3.2 tshark 자동화 예제

```bash
# PCAP에서 호스트별 총 바이트 집계

tshark -r web_dns.pcap -q -z conv,tcp

# SNI 목록 뽑기

tshark -r web_dns.pcap -Y "tls.handshake.extensions_server_name" -T fields -e ip.src -e ssl.handshake.extensions_server_name | sort -u

# HTTP 요청 라인 + Host

tshark -r cap.pcap -Y "http.request" -T fields -e ip.src -e http.host -e http.request.method -e http.request.uri
```

### A.3.3 TLS 복호화(테스트용)

- **프리마스터 로깅**(클라이언트 브라우저 설정, `SSLKEYLOGFILE`) → Wireshark `Edit > Preferences > TLS > (Pre)-Master-Secret log filename` 지정
- 서버 프라이빗 키 복호화는 **TLS 1.3 + PFS**에서는 불가(키로그 필요).

---

## A.4 Zeek — L7 로그·행위 기반 가시성

### A.4.1 빠른 시작

```bash
# PCAP 오프라인 분석

zeek -r web_dns.pcap

# 생성 로그 예
# conn.log, dns.log, http.log, ssl.log, x509.log, files.log, notice.log ...

```

**로그 확인**
```bash
zeek-cut id.orig_h id.resp_h service < conn.log | head
zeek-cut query answers < dns.log | head
```

### A.4.2 스크립팅(정책 예제)

**예제: 이상한 User-Agent 감지하여 notice**
```zeek
# ua_notice.zeek

export {
  redef Notice::policy += {
    [$action=Notice::ACTION_LOG, $priority=5]
  };
}

event http_header(c: connection, is_orig: bool, name: string, value: string)
{
  if (!is_orig || name != "user-agent") return;
  if ( /curl|python-requests|wget/ in to_lower(value) ) {
    local n: Notice::Info = [$note=Notice::NOTICE, $msg=fmt("Suspicious UA: %s", value), $conn=c];
    NOTICE(n);
  }
}
```

```bash
zeek -r web_dns.pcap ua_notice.zeek
cat notice.log
```

**예제: JA3 핑거프린트 상위 카운트**
```bash
zeek -r web_dns.pcap
cut -f2,9 ssl.log | head
# (필드: id.resp_h, ja3)

```

### A.4.3 파일 추출/해시

```bash
# 파일 추출 스크립트

@load files/extract-all-files
zeek -r cap.pcap
# extracted_files/ 디렉터리 생성

```

**Tip**: 대용량 환경에서 `Log::default_writer=Log::WRITER_BATCH` 튜닝, `Zeek AF_Packet/DPDK` 고려.

---

## A.5 Suricata — 서명 기반 IDS/IPS

### A.5.1 실행 모드

```bash
# 오프라인 PCAP 분석

suricata -r cap.pcap -c /etc/suricata/suricata.yaml -l ./out

# 라이브(IDS)

suricata -i eth0 --af-packet -c /etc/suricata/suricata.yaml

# 출력: eve.json(기본), fast.log, stats.log

jq '.event_type' out/eve.json | sort | uniq -c
```

### A.5.2 룰 작성(기본)

**의심 UA 차단/탐지 룰**
```suricata
alert http any any -> any any (msg:"SUS UA curl/wget/requests"; http.user_agent; content:"curl"; nocase; pcre:"/python-requests|wget/i"; classtype:policy-violation; sid:3000001; rev:1;)
```

**TLS SNI 필터(차단은 IPS에서만)**
```suricata
alert tls any any -> any any (msg:"SUS SNI disposable CDN"; tls.sni; content:".cdn-bad.example"; endswith; sid:3000002; rev:1;)
```

**Threshold/Rate-limit**
```suricata
threshold: type both, track by_src, count 5, seconds 60;
```

### A.5.3 성능 핵심

- **Hyperscan**(정규식 고속화), **AF-Packet** multi-queue, **`max-pending-packets`**, **`detect.profile`**
- **CPU Pinning**과 **RSS/Flow pinning** 일치시키기
- **파일 출력** 대신 **Unix socket/Redis/Elasticsearch** 바로 전송

**Filebeat로 `eve.json` 수집(요약)**
```yaml
filebeat.inputs:
- type: filestream
  paths: ["/var/log/suricata/eve.json"]
  parsers:
    - ndjson:
        target: ""
output.elasticsearch.hosts: ["http://es:9200"]
```

---

## A.6 Nmap — 식별과 스크립팅

### A.6.1 필수 옵션

```bash
# 빠른 포트 스캔(상위 1000), 서비스/버전/NSE 기본

nmap -sS -sV -O -T4 10.10.10.0/24

# UDP Top-Ports (느림) – 승인된 범위에서만

nmap -sU --top-ports 50 -T3 10.10.10.5

# 방화벽 뒤 의심 호스트(핑 차단) – 직접 포트 시도

nmap -Pn -p 22,80,443 -sS 10.10.20.30

# 스크립트: SSL/TLS 체크

nmap --script ssl-enum-ciphers -p 443 site.example

# 출력 저장

nmap -sS -sV 10.10.10.0/24 -oA inventory_oct
# inventory_oct.nmap/.gnmap/.xml

```

### A.6.2 NSE 스크립트 활용

```bash
# 취약 헤더/기본 점검

nmap --script http-headers,http-methods -p80,443 web.example

# Heartbleed(역사적 예)

nmap --script ssl-heartbleed -p443 old.example
```

**Tip**: 대역/공개 스캔은 **속도 제한**과 **연락처** 노출, 법적 준수 필수.

---

## A.7 Masscan / ZMap — 초고속 스캔

### A.7.1 Masscan 기본

```bash
# 443/TCP, 초당 1000 패킷, 출력 JSON

sudo masscan 203.0.113.0/24 -p443 --rate 1000 -oJ masscan.json

# 재확인은 Nmap으로(상호 보완)

jq -r '.[].ip' masscan.json | xargs -I{} nmap -sS -sV -p443 {}

# exclude 파일(자사/민감 대역 제외)

masscan 0.0.0.0/0 -p443 --exclude-file excludes.txt --rate 10000
```

### A.7.2 ZMap(443 예)

```bash
zmap -p 443 203.0.113.0/24 -r 2000 -o zmap.txt
```

**주의**: **SYN 핸드셰이크 미완료** 특성상 **오탐/미확인** 존재 → **Nmap/헤드리스 TLS**로 **2차 확인**.

---

## A.8 Scapy — 패킷 제작/실습의 만능 공구

### A.8.1 기초

```python
from scapy.all import *

# Ping

ans,unans = sr(IP(dst="10.10.10.5")/ICMP(), timeout=1)
ans.summary()

# TCP SYN 스캔 (소량, 승인된 대상)

for p in sr(IP(dst="10.10.10.5")/TCP(dport=[22,80,443], flags="S"), timeout=2)[0]:
    print(p[1][TCP].flags)  # SA면 open

# DNS 질의

pkt = IP(dst="8.8.8.8")/UDP(dport=53)/DNS(rd=1,qd=DNSQR(qname="example.com"))
ans=sr1(pkt, timeout=2); ans[DNS].an.summary()
```

### A.8.2 맞춤 트래픽 생성 → IDS/Zeek 테스트

```python
# suspicious UA 요청 전송(테스트망)

req = IP(dst="10.10.20.30")/TCP(dport=80, flags="S")
synack = sr1(req, timeout=1)
ack = IP(dst="10.10.20.30")/TCP(dport=80, flags="A", seq=1, ack=synack[TCP].seq+1)
send(ack)
payload = b"GET / HTTP/1.1\r\nHost: test\r\nUser-Agent: curl/7.88\r\n\r\n"
send(IP(dst="10.10.20.30")/TCP(dport=80, flags="PA", seq=1, ack=synack[TCP].seq+1)/Raw(payload))
```

### A.8.3 스니퍼/필터

```python
# HTTP 요청만 캡처

def onpkt(p):
    if p.haslayer(Raw) and b"HTTP" in bytes(p[Raw]):
        print(p[IP].src, len(p))
sniff(iface="eth0", prn=onpkt, filter="tcp port 80", count=50)
```

**Tip**: 속도는 낮다. **기능 검증/랩 재현**에 최적.

---

## A.9 “엔드투엔드” 흐름 예시: 수집→해석→탐지→대응

1) **tcpdump**로 5분 링 캡처(HTTP/TLS/DNS).
2) **Wireshark**로 재전송·RTT·SNI/Host 상위 도메인 분석.
3) 같은 PCAP을 **Zeek**에 넣어 `http.log/dns.log/ssl.log` 생성 → 상위 SNI/UA/응답코드 표.
4) **Suricata**에 투입 → `eve.json`에서 정책 위반/알림 추출.
5) **Nmap**으로 문제 호스트 포트/서비스 확인, 필요하면 **Masscan**으로 대역 시야 확장(→ Nmap 재확인).
6) **Scapy**로 의심 시그니처 트래픽을 **재현**해서 룰/탐지기 반응 테스트.
7) 모든 로그는 **SIEM**(예: Elasticsearch)으로 보내 **대시보드**와 **티켓 자동화**.

---

## A.10 실습 세트(랩)

### A.10.1 실습 1 — “3-way/4-way, 재전송” 찾기

- **캡처**: `sudo tcpdump -i eth0 -s 0 -G 120 -W 1 -w handshakes.pcap 'tcp'`
- **질문**:
  - SYN 후 SYN/ACK 지연이 큰 플로우? `Wireshark: tcp.analysis.ack_rtt > 0.3`
  - 4-way 종료가 **FIN/ACK** 대신 **RST**로 끝난 세션 수?

### A.10.2 실습 2 — Zeek+Suricata 동시 파이프라인

```bash
suricata -r handshakes.pcap -l ./suri_out
zeek -r handshakes.pcap
# Q1: Suricata alert top-msg?  Q2: Zeek http.log에서 top user-agent?

```

### A.10.3 실습 3 — 인벤토리 작성(Nmap + Masscan)

- **Masscan**: 승인 대역 443/TCP 열림 IP 추출
- **Nmap**: `-sV --script ssl-enum-ciphers`로 재확인, XML을 파싱해 스프레드시트 생성

```bash
jq -r '.[].ip' masscan.json | xargs -I{} nmap -sS -sV -p443 -oX out_{}.xml {}
```

### A.10.4 실습 4 — Scapy로 Suricata 룰 테스트

- Suricata 룰: `SUS UA curl/wget/requests`
- Scapy 스크립트로 `User-Agent: curl` 요청 전송 → `eve.json`에서 **alert** 발생 확인

---

## A.11 치트시트

### A.11.1 tcpdump BPF

- `tcp[13] & 2 != 0`(SYN), `tcp[13] & 4 != 0`(RST)
- `port 53 and udp`(DNS), `port 443 and tcp`(TLS)
- `host 10.0.0.1`, `src net 192.168.0.0/16`
- `greater 1500`(큰 프레임)

### A.11.2 Wireshark 필터

- `tcp.analysis.retransmission`
- `dns.flags.response == 1 && dns.a`
- `tls.handshake.extensions_server_name contains ".corp"`
- `http.response.code >= 500`

### A.11.3 Zeek 로그 필드(자주)

- `conn.log`: `id.orig_h/id.resp_h`, `proto`, `service`, `bytes`, `state`
- `http.log`: `host`, `uri`, `user_agent`, `status_code`
- `ssl.log`: `ja3`, `ja3s`, `version`, `cipher`, `server_name`
- `dns.log`: `query`, `qtype_name`, `answers`

### A.11.4 Suricata 룰 키워드

- `flow`, `content`, `http.host`, `http.user_agent`, `pcre`, `tls.sni`, `threshold`
- 출력: `eve.json`(`alert`, `flow`, `dns`, `http`, `tls` 섹션)

### A.11.5 Nmap 핵심

- `-sS` SYN, `-sU` UDP, `-sV` 버전, `-O` OS, `-Pn` 핑 스킵
- 스크립트: `--script ssl-enum-ciphers`, `http-*` 등
- 출력: `-oA name`(3종 동시)

### A.11.6 Scapy 패턴

- `IP()/TCP()/UDP()/DNS()/Raw()` 조합
- `sniff(filter="tcp port 80", prn=...)`
- `wrpcap("out.pcap", packets)`

---

## A.12 마무리 — 도구의 **역할 분담**을 기억하자

- **tcpdump**로 **정확히 필요한 것만** 캡처하고,
- **Wireshark**로 **보여주며 설득**하고,
- **Zeek**로 **지속 가능한 L7 로그**를 만들고,
- **Suricata**로 **정책·탐지 신호**를 추가하고,
- **Nmap/Masscan**으로 **자산/노출**을 파악하고,
- **Scapy**로 **재현/증명**한다.
