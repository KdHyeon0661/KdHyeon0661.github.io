---
layout: post
title: Spring - 도메인 공통 모듈 설계
date: 2025-10-21 19:25:23 +0900
category: Spring
---
# 23. 도메인 공통 모듈 설계 — 예외/응답/유틸/보안/감사, 멀티모듈 분리, 국제화·현지화·시간대

> 목표: 여러 서비스/모듈에서 **재사용되는 공통 규약**을 정립해 “어디서나 같은 방식으로 동작하는” 기반을 만든다.
> 범위: **공통 예외/에러코드/표준 응답 스펙**, **로깅·트레이싱·감사(Auditing)**, **보안 유틸(현재 사용자/권한/메서드 시큐리티)**, **멀티모듈 분리 전략**, **i18n(국제화)·l10n(현지화)·시간대 처리**.
> 기준: Spring Boot 3.3+, Java 21, Gradle 8, JPA 사용을 가정.

---

## A. 공통 모듈 목표와 레이어

### A-1. 왜 공통 모듈인가?
- **일관성**: 에러 응답, 로깅, 보안 컨텍스트, 시간 처리 방식이 프로젝트마다 다르면 운영비 상승.
- **재사용**: 중복 구현/버그를 줄이고, 팀 간 **합의된 규약**을 코드화 (“규약=라이브러리”).
- **독립 배포 가능**: 공통 모듈은 **별도 버전**으로 배포(BOM/플랫폼 관리)해 서비스들이 참조.

### A-2. 모듈 구성(권장)
```
:common-bom              # 공통 의존성 버전 관장(Gradle platform)
:common-core             # 에러코드, 예외, Result/Util, time, masking 등(스프링 비의존)
:common-web              # 응답래퍼, 예외핸들러, WebMvc/WebFlux 공통 필터, MDC/traceId
:common-security         # CurrentUser, 권한어노테이션, PermissionEvaluator, 세션/토큰 어댑터
:common-jpa              # BaseEntity, Auditing, SoftDelete, 스펙/페이지 유틸
:common-i18n             # MessageSource, LocaleResolver, 메시지 키 규약, 번역 헬퍼
```
> 원칙: `:common-core`는 **Spring/JPA 불포함**. 위로 갈수록 프레임워크 의존이 추가된다.

---

## B. 공통 예외/에러코드/표준 응답 설계

### B-1. 에러코드 규약
- 정수/문자열 코드를 **영역별로 범위 할당**:
  - `1xxx` 인증/인가, `2xxx` 유효성, `3xxx` 도메인 룰, `5xxx` 시스템/외부 연동.
- 키는 국제화 메시지 키와 1:1 매핑: `error.auth.unauthorized`, `error.validation.field`.

```java
// :common-core
public interface ErrorCode {
  String code();       // "AUTH-1001" or "2001"
  int http();          // 추천 HTTP 상태
  String messageKey(); // i18n 키(예: "error.auth.unauthorized")
}

public enum CommonErrors implements ErrorCode {
  BAD_REQUEST("2000", 400, "error.bad_request"),
  VALIDATION("2001", 400, "error.validation"),
  UNAUTHORIZED("1001", 401, "error.auth.unauthorized"),
  FORBIDDEN("1003", 403, "error.auth.forbidden"),
  NOT_FOUND("2004", 404, "error.not_found"),
  CONFLICT("2009", 409, "error.conflict"),
  TOO_MANY_REQUESTS("1009", 429, "error.rate_limit"),
  SERVER_ERROR("5000", 500, "error.server"),
  UPSTREAM_ERROR("5002", 502, "error.upstream");
  // ...
  // constructors/getters...
}
```

### B-2. 공통 예외 타입
```java
// :common-core
public class AppException extends RuntimeException {
  private final ErrorCode error;
  private final Map<String, Object> args;

  public AppException(ErrorCode error, String message, Map<String,Object> args, Throwable cause) {
    super(message, cause); this.error = error; this.args = args == null? Map.of(): Map.copyOf(args);
  }
  public ErrorCode error() { return error; }
  public Map<String,Object> args() { return args; }

  public static AppException of(ErrorCode e, String msg, Object... kv) {
    return new AppException(e, msg, toMap(kv), null);
  }
  private static Map<String,Object> toMap(Object... kv){ // k1,v1,k2,v2,...
    Map<String,Object> m=new LinkedHashMap<>();
    for(int i=0;i+1<kv.length;i+=2) m.put(String.valueOf(kv[i]), kv[i+1]);
    return m;
  }
}
```

도메인 전용 예외:
```java
public class DomainRuleException extends AppException {
  public DomainRuleException(String msg, Object... kv) {
    super(CommonErrors.CONFLICT, msg, AppException.toMap(kv), null);
  }
}
```

### B-3. 표준 응답 래퍼 (성공/실패 통일)
RFC 7807(Problem Details) 호환 + 팀 전용 필드 추가:
```java
// :common-web
public record ApiError(
    String code,            // "2001"
    int status,             // 400
    String message,         // i18n resolved human message
    String key,             // i18n key e.g. "error.validation"
    String traceId,         // MDC traceId
    Map<String, Object> data // field errors, context
) {}

public record ApiResponse<T>(
    boolean success,
    T data,
    ApiError error,
    Instant timestamp
) {
  public static <T> ApiResponse<T> ok(T body) {
    return new ApiResponse<>(true, body, null, Instant.now());
  }
  public static ApiResponse<Void> empty() {
    return new ApiResponse<>(true, null, null, Instant.now());
  }
  public static ApiResponse<Void> fail(ApiError err) {
    return new ApiResponse<>(false, null, err, Instant.now());
  }
}
```

### B-4. 글로벌 예외 핸들러
```java
// :common-web
@RestControllerAdvice
@RequiredArgsConstructor
public class GlobalExceptionHandler {

  private final MessageResolver msg; // :common-i18n
  private final TraceIdProvider trace;

  @ExceptionHandler(MethodArgumentNotValidException.class)
  public ResponseEntity<ApiResponse<Void>> handleValidation(MethodArgumentNotValidException ex, Locale locale) {
    Map<String,Object> fields = new LinkedHashMap<>();
    ex.getBindingResult().getFieldErrors().forEach(fe -> {
      String key = "validation." + fe.getCode(); // e.g. validation.NotBlank
      fields.put(fe.getField(), msg.getMessage(fe.getDefaultMessage(), locale, fe.getArguments()));
    });
    ApiError error = new ApiError(
        CommonErrors.VALIDATION.code(),
        CommonErrors.VALIDATION.http(),
        msg.getMessage(CommonErrors.VALIDATION.messageKey(), locale),
        CommonErrors.VALIDATION.messageKey(),
        trace.currentTraceId(),
        Map.of("fields", fields)
    );
    return ResponseEntity.status(CommonErrors.VALIDATION.http()).body(ApiResponse.fail(error));
  }

  @ExceptionHandler(AppException.class)
  public ResponseEntity<ApiResponse<Void>> handleApp(AppException ex, Locale locale) {
    var e = ex.error();
    String message = msg.getMessage(e.messageKey(), locale, ex.args());
    ApiError error = new ApiError(e.code(), e.http(), message, e.messageKey(), trace.currentTraceId(), ex.args());
    return ResponseEntity.status(e.http()).body(ApiResponse.fail(error));
  }

  @ExceptionHandler(Exception.class)
  public ResponseEntity<ApiResponse<Void>> handleAny(Exception ex, Locale locale) {
    var e = CommonErrors.SERVER_ERROR;
    ApiError error = new ApiError(e.code(), e.http(), msg.getMessage(e.messageKey(), locale), e.messageKey(), trace.currentTraceId(), Map.of());
    return ResponseEntity.status(e.http()).body(ApiResponse.fail(error));
  }
}
```

### B-5. 응답 예시
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "2001",
    "status": 400,
    "message": "이 필드는 필수입니다.",
    "key": "error.validation",
    "traceId": "2f7c9c1b3b12e6a1",
    "data": {
      "fields": {
        "email": "올바른 이메일 형식이 아닙니다."
      }
    }
  },
  "timestamp": "2025-10-23T05:15:12Z"
}
```

---

## C. 로깅·트레이싱·MDC·감사(Auditing)

### C-1. traceId/tenantId MDC 필터
```java
// :common-web
@Component
public class MDCFilter extends OncePerRequestFilter {
  @Override protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
      throws ServletException, IOException {
    String traceId = Optional.ofNullable(req.getHeader("X-Trace-Id")).orElse(UUID.randomUUID().toString().replace("-","").substring(0,16));
    String tenant = Optional.ofNullable(req.getHeader("X-Tenant-Id")).orElse("public");

    MDC.put("traceId", traceId);
    MDC.put("tenantId", tenant);
    try {
      res.setHeader("X-Trace-Id", traceId);
      chain.doFilter(req, res);
    } finally {
      MDC.clear();
    }
  }
}
```

**logback-spring.xml** (요약)
```xml
<encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
  <pattern>%d{ISO8601} %-5level [%X{traceId}] [%X{tenantId}] %logger{36} - %msg%n</pattern>
</encoder>
```

### C-2. 감사(Auditing) — 생성/수정자·시각 자동 주입
```java
// :common-jpa
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class AuditableEntity {
  @CreatedDate protected Instant createdAt;
  @LastModifiedDate protected Instant updatedAt;
  @CreatedBy protected String createdBy;
  @LastModifiedBy protected String updatedBy;
}

@Configuration
@EnableJpaAuditing
class JpaAuditConfig {
  @Bean AuditorAware<String> auditorAware(CurrentUserProvider current) {
    return () -> Optional.ofNullable(current.username()).or(() -> Optional.of("system"));
  }
}
```

`CurrentUserProvider`는 :common-security에서 제공(토큰/세션 어디든 추상화).

### C-3. 감사 이벤트(Outbox) — 누가 무엇을 했는가
```java
// :common-core
public record AuditEvent(String actor, String action, String targetType, String targetId,
                         Map<String,Object> meta, Instant at, String traceId) {}

public interface AuditPublisher { void publish(AuditEvent e); }
```
```java
// :common-web or :common-jpa
@Service
@RequiredArgsConstructor
public class OutboxAuditPublisher implements AuditPublisher {
  private final AuditOutboxRepo repo; private final TraceIdProvider trace; private final CurrentUserProvider user;
  @Override public void publish(AuditEvent e) {
    repo.save(Outbox.from(e.withTrace(trace.currentTraceId()).withActor(defaultActor())));
  }
  private String defaultActor(){ return Optional.ofNullable(user.username()).orElse("system"); }
}
```
> 운영에서는 배치/스트리머가 Outbox → Kafka/ES로 전송, 대시보드/감사 리포트에 활용.

### C-4. 민감정보 마스킹 유틸
```java
// :common-core
public final class Masking {
  public static String email(String e){ if (e==null) return null; int i=e.indexOf('@'); if(i<2) return "***"; return e.charAt(0)+"***"+e.substring(i-1); }
  public static String phone(String p){ if (p==null) return null; return p.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2"); }
}
```

---

## D. 공통 보안 유틸 — 현재 사용자, 권한, 메서드 시큐리티

### D-1. 도메인 친화적 Principal 추상화
```java
// :common-security
public record AppPrincipal(String userId, String username, Set<String> roles, String tenantId) {
  public boolean has(String role){ return roles.contains(role); }
}
public interface CurrentUserProvider {
  AppPrincipal current();
  default String username(){ return Optional.ofNullable(current()).map(AppPrincipal::username).orElse(null); }
  default String tenantId(){ return Optional.ofNullable(current()).map(AppPrincipal::tenantId).orElse("public"); }
}
```

스프링 시큐리티 어댑터:
```java
@Component
public class SecurityCurrentUser implements CurrentUserProvider {
  @Override public AppPrincipal current() {
    var a = SecurityContextHolder.getContext().getAuthentication();
    if (a==null || !a.isAuthenticated()) return null;
    var name = a.getName();
    var roles = a.getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.toSet());
    var tenant = Optional.ofNullable(((Jwt) a.getPrincipal())).map(jwt -> jwt.getClaimAsString("tenant")).orElse("public");
    var uid = Optional.ofNullable(((Jwt) a.getPrincipal())).map(jwt -> jwt.getSubject()).orElse(name);
    return new AppPrincipal(uid, name, roles, tenant);
  }
}
```

### D-2. 메타 어노테이션(권한 단축)
```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("hasAuthority('ROLE_ADMIN')")
public @interface IsAdmin {}
```

### D-3. PermissionEvaluator로 도메인 권한
```java
@Component
public class DomainPermissionEvaluator implements PermissionEvaluator {
  @Override public boolean hasPermission(Authentication auth, Object targetDomainObject, Object permission) {
    if (targetDomainObject instanceof Order o && "READ".equals(permission)) {
      var p = (Jwt) auth.getPrincipal();
      return o.tenantId().equals(p.getClaimAsString("tenant"));
    }
    return false;
  }
  @Override public boolean hasPermission(Authentication auth, Serializable targetId, String targetType, Object permission) { return false; }
}
```

사용:
```java
@PreAuthorize("hasPermission(#order, 'READ')")
public OrderView get(Order order) { ... }
```

---

## E. 공통 유틸: 시간/ID/페이지/스펙/결과형

### E-1. 시간 유틸 (UTC 저장, 현지 표시)
```java
// :common-core
public final class Times {
  public static final ZoneId UTC = ZoneId.of("UTC");
  public static Instant now(){ return Instant.now(); }
  public static ZonedDateTime toZone(Instant i, ZoneId zone){ return i.atZone(zone); }
  public static OffsetDateTime toOffset(Instant i, ZoneId zone){ return i.atZone(zone).toOffsetDateTime(); }
}
```

### E-2. Jackson 설정(ISO-8601, Offset 유지)
```java
// :common-web
@Configuration
class JacksonTimeConfig {
  @Bean
  ObjectMapper objectMapper() {
    return JsonMapper.builder()
      .addModule(new JavaTimeModule())
      .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
      .build();
  }
}
```

### E-3. 페이지/정렬 표준 DTO
```java
public record PageRequestDto(int page, int size, String sort) {
  public Pageable toPageable(){ return PageRequest.of(Math.max(page,0), Math.min(size,200), Sort.by(parse(sort))); }
  private Sort.Order[] parse(String s){ /* "createdAt,desc;name,asc" 파싱 */ return new Sort.Order[]{ Sort.Order.desc("createdAt") }; }
}
public record PageResponse<T>(List<T> content, int page, int size, long total) {}
```

### E-4. JPA Specification 유틸(:common-jpa)
```java
public final class Specs {
  public static <T> Specification<T> eq(String field, Object value) {
    return (root, q, cb) -> value==null? cb.conjunction() : cb.equal(root.get(field), value);
  }
  public static <T> Specification<T> like(String field, String qstr) {
    return (root, q, cb) -> qstr==null? cb.conjunction() : cb.like(cb.lower(root.get(field)), "%"+qstr.toLowerCase()+"%");
  }
}
```

### E-5. Result/Either(선택)
```java
public sealed interface Result<T> permits Result.Ok, Result.Err {
  record Ok<T>(T value) implements Result<T> {}
  record Err<T>(ErrorCode code, String message) implements Result<T> {}
}
```

---

## F. 멀티모듈 & 공통 라이브러리 분리 전략

### F-1. Gradle BOM(플랫폼)으로 버전 관리
`:common-bom/build.gradle.kts`
```kotlin
plugins { `java-platform` }
javaPlatform { allowDependencies() }
dependencies {
  constraints {
    api("org.springframework.boot:spring-boot-starter-web:3.3.3")
    api("org.springframework.boot:spring-boot-starter-data-jpa:3.3.3")
    api("ch.qos.logback:logback-classic:1.5.8")
    api("com.fasterxml.jackson.core:jackson-databind:2.17.1")
    // ... 팀 표준 버전
  }
}
```
서비스 쪽:
```kotlin
dependencies {
  implementation(platform(project(":common-bom")))
  implementation(project(":common-core"))
  implementation(project(":common-web"))
  implementation(project(":common-security"))
  implementation(project(":common-jpa"))
  implementation(project(":common-i18n"))
}
```

### F-2. 의존 방향 수칙
- `:common-*` ↔ 서로 간 의존 최소화. `:common-core`에 하위 유틸 통합, 위 모듈은 **core만 참조**.
- 서비스 모듈은 `:common-*`만 참조. **서비스 간 직접 참조 금지**(shared-kernel로만 공유).

### F-3. 버저닝 전략
- 공통 모듈은 **semver** 채택. `MAJOR.MINOR.PATCH`
- **Breaking** 변경 시 메이저 승격(예: 예외/응답 스키마 변경).
- 서비스는 `platform(project(":common-bom"))` 버전만 바꿔 **일괄 승격**.

---

## G. 국제화(i18n)·현지화(l10n)·시간대(TZ) 처리

### G-1. 메시지 소스 및 캐시
```java
// :common-i18n
@Configuration
public class I18nConfig {
  @Bean
  MessageSource messageSource() {
    var ms = new ReloadableResourceBundleMessageSource();
    ms.setBasenames("classpath:i18n/messages", "classpath:i18n/errors");
    ms.setDefaultEncoding("UTF-8");
    ms.setCacheSeconds(3600); // 운영: 캐시, 개발: 1
    return ms;
  }

  @Bean
  public LocaleResolver localeResolver() {
    // Accept-Language 우선, 쿼리 파라미터 ?lang=ko 지원하려면 LocaleChangeInterceptor 활용
    var r = new AcceptHeaderLocaleResolver();
    r.setDefaultLocale(Locale.KOREAN);
    return r;
  }
}
```

### G-2. 메시지 해석기(예외 핸들러에서 사용)
```java
// :common-i18n
@Component
@RequiredArgsConstructor
public class MessageResolver {
  private final MessageSource ms;

  public String getMessage(String key, Locale locale) {
    return ms.getMessage(key, null, key, locale);
  }
  public String getMessage(String key, Locale locale, Map<String,Object> args) {
    if (args==null || args.isEmpty()) return getMessage(key, locale);
    var values = args.values().toArray();
    return ms.getMessage(key, values, key, locale);
  }
}
```

`errors_ko.properties`
```
error.validation=요청 값이 올바르지 않습니다.
error.auth.unauthorized=인증이 필요합니다.
validation.NotBlank={0}은(는) 필수 입력 값입니다.
```

### G-3. Bean Validation 국제화
```java
// DTO
public record SignUpRequest(
  @NotBlank(message = "{validation.NotBlank}") String email,
  @Size(min=8, message="{validation.Size.min}") String password
) {}
```
`messages_ko.properties`
```
validation.Size.min={0}의 길이는 최소 {1}자 입니다.
```

### G-4. 시간대 전략
- 저장: **UTC(Instant)**.
- 표시: 사용자 **Locale/TZ** 기반 `ZonedDateTime`/`OffsetDateTime`.
- 입력: 클라이언트가 ISO-8601(오프셋 포함)로 전송. 없는 경우 **프로필/TZ 설정** 또는 서버 기본 TZ.

`application.yml`(표준화)
```yaml
spring:
  jackson:
    time-zone: UTC        # 직렬화 기본을 UTC로
    date-format: "yyyy-MM-dd'T'HH:mm:ssXXX"  # ISO-8601
```

컨트롤러 변환 예:
```java
@GetMapping("/events/{id}")
public ApiResponse<EventView> get(@PathVariable String id, @RequestHeader(name="X-Timezone", required=false) String tz) {
  ZoneId zone = tz!=null? ZoneId.of(tz): ZoneId.of("Asia/Seoul");
  var e = service.find(id);
  var view = new EventView(e.id(), Times.toOffset(e.startsAt(), zone), Times.toOffset(e.endsAt(), zone));
  return ApiResponse.ok(view);
}
```

### G-5. 통화/숫자 포맷
```java
public String formatMoney(Money money, Locale locale){
  NumberFormat f = NumberFormat.getCurrencyInstance(locale);
  f.setCurrency(money.currency());
  return f.format(money.amount());
}
```

---

## H. Web 공통: 에러 페이지, CORS, API 문서화 훅

### H-1. CORS 전역 설정(:common-web)
```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
  @Override public void addCorsMappings(CorsRegistry r) {
    r.addMapping("/**").allowedOrigins("https://app.example.com").allowedMethods("*").allowCredentials(true).maxAge(3600);
  }
}
```

### H-2. 문서화(스웨거/OpenAPI) 어노테이션 프리셋
```java
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Operation(summary = "표준 성공 응답", responses = {
  @ApiResponse(responseCode="200", description="OK", content=@Content(schema=@Schema(implementation=ApiResponse.class)))
})
public @interface StandardOk {}
```

---

## I. 적용 예시: 서비스 코드가 얼마나 가벼워지는가

컨트롤러:
```java
@RestController
@RequestMapping("/members")
@RequiredArgsConstructor
class MemberController {
  private final MemberService service;

  @PostMapping
  @StandardOk
  public ApiResponse<MemberDto> register(@Valid @RequestBody SignUpRequest req) {
    return ApiResponse.ok(service.register(req));
  }
}
```

서비스:
```java
@Service
@RequiredArgsConstructor
class MemberService {
  private final MemberRepo repo;
  private final AuditPublisher audit;

  @Transactional
  public MemberDto register(SignUpRequest req){
    if (repo.existsByEmail(req.email())) throw AppException.of(CommonErrors.CONFLICT, "email exists", "email", req.email());
    var m = repo.save(Member.of(req.email(), passwordHash(req.password())));
    audit.publish(new AuditEvent(null, "member.register", "Member", m.id(), Map.of("email", Masking.email(m.email())), Instant.now(), null));
    return MemberDto.from(m);
  }
}
```

> **예외/응답/감사/마스킹/i18n/트레이싱**이 모두 공통 모듈로 흡수되어, 도메인 로직만 남는다.

---

## J. 테스트 전략(공통 모듈 기준)

- `:common-core`는 **순수 자바 단위 테스트**(JVM만).
- `:common-web`는 `@WebMvcTest(GlobalExceptionHandler.class, MDCFilter.class)`로 예외/응답/헤더/traceId 검증.
- `:common-jpa`는 `@DataJpaTest`로 Auditing/SoftDelete 검증.
- i18n은 `MessageSource`로 로케일별 메시지 해석 테스트.

예: 예외 핸들러 테스트
```java
@WebMvcTest(controllers = TestController.class)
@Import({GlobalExceptionHandler.class, I18nConfig.class, JacksonTimeConfig.class, MDCFilter.class})
class ExceptionHandlerTest {
  @Autowired MockMvc mvc;

  @Test void validation_error_is_localized() throws Exception {
    mvc.perform(post("/test").contentType(APPLICATION_JSON).content("{\"email\":\"bad\"}"))
      .andExpect(status().isBadRequest())
      .andExpect(jsonPath("$.error.code").value("2001"))
      .andExpect(jsonPath("$.error.message").exists())
      .andExpect(header().exists("X-Trace-Id"));
  }
}
```

---

## K. 운영 체크리스트

- [ ] **예외/응답 스키마**를 문서화(OpenAPI 스키마)하고 모든 서비스가 동일 적용.
- [ ] **MDC traceId** 헤더 패스스루(`X-Trace-Id`), 로그/메트릭/트레이스 상관.
- [ ] **Auditing**: 생성/수정자/시각 + AuditEvent Outbox → 중앙 수집.
- [ ] **Secret/PII 마스킹**: 로그/감사/이벤트에 적용.
- [ ] **i18n 메시지 키 규약**: `error.*`, `validation.*`, `label.*` 네이밍 컨벤션.
- [ ] **시간대**: 저장 UTC, 표시 TZ, 입력 ISO-8601. Jackson 설정 일관화.
- [ ] **멀티모듈**: `:common-bom`으로 버전 동기화, 의존 방향 단방향 유지.
- [ ] **호환성 정책**: 공통 모듈 **메이저 변경 시 공지/마이그 가이드** 제공.

---

## L. 한 페이지 요약

1) **공통 예외/응답**을 컨벤션으로 끝내지 말고 **라이브러리**로 강제하라.
2) **MDC/traceId, Auditing, 마스킹**을 기본값으로 깔아 두면 운영 난이도가 급격히 내려간다.
3) **CurrentUser/권한 어노테이션/PermissionEvaluator**로 도메인 권한 검증을 재사용화.
4) **Gradle BOM + 멀티모듈**로 버전/의존을 표준화하고, `:common-core`를 중심으로 단방향 의존을 유지.
5) **i18n·l10n·TZ**를 프레임워크 레벨에서 해결(메시지/검증/시간 직렬화)하면 서비스는 비즈니스에 집중할 수 있다.
