---
layout: post
title: C# - 인터페이스
date: 2024-10-16 19:20:23 +0900
category: Csharp
---
# C# 인터페이스(interface)

## 0) 한눈에 보는 핵심

- **인터페이스 = 계약(Contract)**: “무엇을 할 수 있어야 하는가”만 정의(메서드/속성/인덱서/이벤트의 **시그니처**).  
- **다형성**: 호출자는 인터페이스만 알고, 구현체 교체는 자유.  
- **최신 기능**:
  - **기본 구현(Default Interface Methods, C# 8+)**: 인터페이스에 *선택적* 기본 동작 제공(남용 금지).
  - **공변/반공변(variance)**: 제네릭 인터페이스의 안전한 타입 치환.  
  - **정적 추상 멤버(C# 11+)**: 제네릭에서 **연산자/상수**를 인터페이스로 추상화(일명 *Generic Math*).  
- **성능/안정성**: 인터페이스 호출은 가상 호출(미세 오버헤드), 값 형식과 함께 쓰면 **박싱** 가능성 주의.  
- **버저닝**: 멤버 추가는 구현체를 깨뜨릴 수 있음 → 필요하면 **기본 구현**으로 완화.

---

## 1) 인터페이스란?

- **메서드, 속성, 이벤트, 인덱서의 시그니처만 정의**(필드 없음).
- 클래스/구조체는 인터페이스를 **구현(implement)**. 선언 문법은 상속과 동일하게 `:` 사용.
- **다중 인터페이스 구현 가능**(클래스 다중 상속은 불가).

```csharp
public interface IShape
{
    void Draw();
    double GetArea();
}
```

### 구현 클래스 & 다형성 호출

```csharp
public class Circle : IShape
{
    public double Radius { get; set; }
    public void Draw() => Console.WriteLine("원을 그립니다.");
    public double GetArea() => Math.PI * Radius * Radius;
}

void RenderShape(IShape shape)
{
    shape.Draw();
    Console.WriteLine($"넓이: {shape.GetArea()}");
}

IShape s = new Circle { Radius = 5 };
RenderShape(s);
```

---

## 2) 인터페이스 멤버 종류 — 속성/인덱서/이벤트

```csharp
public interface IReadable
{
    string Content { get; }                  // 읽기 속성
    string this[int index] { get; }          // 인덱서
    event EventHandler? Changed;             // 이벤트
}
```

구현 예:

```csharp
public class TextPage : IReadable
{
    private readonly string[] _lines;
    public TextPage(params string[] lines) => _lines = lines;

    public string Content => string.Join("\n", _lines);
    public string this[int index] => _lines[index];

    public event EventHandler? Changed;
    public void Update(int i, string line)
    {
        _lines[i] = line;
        Changed?.Invoke(this, EventArgs.Empty);
    }
}
```

---

## 3) 명시적 인터페이스 구현(Explicit Implementation)

**목적**:  
- 같은 시그니처 충돌 해결  
- 인터페이스 멤버를 **공용 API에서 숨기고**, 인터페이스로 볼 때만 노출

```csharp
public interface ILogger { void Log(string message); }

public class DualLogger : ILogger
{
    public void LogPublic(string message) => Console.WriteLine("[PUB] " + message);

    // 명시적 구현: 객체를 ILogger로 캐스팅해야 보임
    void ILogger.Log(string message) => Console.WriteLine("[IFC] " + message);
}

var d = new DualLogger();
d.LogPublic("hello");
// d.Log("x");                // ❌ 컴파일 오류
((ILogger)d).Log("x");        // ✅ 인터페이스로 캐스팅해 호출
```

---

## 4) 인터페이스 기본 구현(Default Interface Methods, C# 8+)

**선언부에 구현을 제공**할 수 있습니다(선택적 동작, 버저닝 완화용).

```csharp
public interface ILogger
{
    void Log(string message) => Console.WriteLine($"[기본 로그] {message}");
}
public class ConsoleLogger : ILogger { } // 구현 없이도 기본 동작 사용
```

> 주의: **복잡도 증가/다이아몬드 충돌** 가능. 공용 API보다는 내부 프레임워크의 **점진 진화**에 신중히 사용.

---

## 5) 제네릭 인터페이스 & 제약

### 5.1 계약 강화

```csharp
public interface IEntity { string Id { get; } }

public interface IRepository<T> where T : IEntity
{
    void Save(T entity);
    T? Find(string id);
}
```

- `where T : IEntity`로 **컴파일 타임 계약 보장** → 형 안전성 향상.

### 5.2 공변/반공변(variance)

- `out`(공변): 생산자 시나리오. `IEnumerable<out T>`
- `in` (반공변): 소비자 시나리오. `IComparer<in T>`

```csharp
public interface IProducer<out T> { T Produce(); }
public interface IConsumer<in T>   { void Consume(T item); }

IProducer<string> ps = /* ... */;
IProducer<object> po = ps; // 공변(문자열은 객체다) ✅

IConsumer<object> co = /* ... */;
IConsumer<string> cs = co; // 반공변(문자열 소비자에 '객체' 소비 가능) ✅
```

---

## 6) 정적 추상 멤버(C# 11+) — Generic Math 패턴

**인터페이스에 정적 추상 멤버**를 선언해, 제네릭에서 연산자를 추상화합니다.

```csharp
public interface INumeric<TSelf> where TSelf : INumeric<TSelf>
{
    static abstract TSelf operator +(TSelf a, TSelf b);
    static abstract TSelf Zero { get; }
}

public readonly struct MyInt(int v) : INumeric<MyInt>
{
    public int Value { get; } = v;
    public static MyInt operator +(MyInt a, MyInt b) => new(a.Value + b.Value);
    public static MyInt Zero => new(0);
}

public static T Sum<T>(IEnumerable<T> xs) where T : INumeric<T>
{
    var acc = T.Zero;
    foreach (var x in xs) acc = acc + x;
    return acc;
}
```

- 산술/집계/알고리즘의 **형식 추상화**가 가능.

---

## 7) DI(의존성 주입) & 테스트 전략

### 7.1 DI 예제(.NET 기본 컨테이너)

```csharp
public interface IClock { DateTime Now { get; } }
public sealed class SystemClock : IClock { public DateTime Now => DateTime.UtcNow; }

public interface IGreeter { string Hello(); }
public sealed class Greeter(IClock clock) : IGreeter
{
    public string Hello() => $"Hello @ {clock.Now:O}";
}

// Program.cs (ASP.NET Core 등)
var services = new ServiceCollection()
    .AddSingleton<IClock, SystemClock>()
    .AddTransient<IGreeter, Greeter>()
    .BuildServiceProvider();

var g = services.GetRequiredService<IGreeter>();
Console.WriteLine(g.Hello());
```

### 7.2 테스트 더블(목/스텁)로 교체 용이

```csharp
public sealed class FakeClock(DateTime fixedNow) : IClock
{
    public DateTime Now { get; } = fixedNow;
}

// 단위 테스트
var g = new Greeter(new FakeClock(new DateTime(2000,1,1)));
Console.WriteLine(g.Hello()); // 고정된 시각으로 결정적 테스트
```

- 인터페이스 기반으로 **의존성 절단 → 테스트 용이성/재현성↑**

---

## 8) 패턴 모음 — 전략/어댑터/데코레이터

### 8.1 전략(Strategy)

```csharp
public interface IShippingFee { decimal Calc(decimal weightKg); }

public sealed class FlatFee : IShippingFee { public decimal Calc(decimal _) => 5m; }
public sealed class WeightFee : IShippingFee { public decimal Calc(decimal w) => 2m + w * 1.2m; }

public sealed class Checkout(IShippingFee fee)
{
    public decimal Total(decimal price, decimal weight) => price + fee.Calc(weight);
}
```

### 8.2 어댑터(Adapter) — 레거시 포장

```csharp
public sealed class LegacyLogger { public void WriteLine(string s) => Console.WriteLine(s); }

public interface ILogger { void Log(string msg); }

public sealed class LoggerAdapter(LegacyLogger inner) : ILogger
{
    public void Log(string msg) => inner.WriteLine("[LOG] " + msg);
}
```

### 8.3 데코레이터(Decorator)

```csharp
public sealed class TimingLogger(ILogger next) : ILogger
{
    public void Log(string msg) => next.Log($"[{DateTime.UtcNow:O}] {msg}");
}
```

---

## 9) 인터페이스 vs 추상 클래스 — 2025 관점 비교

| 항목 | 인터페이스 | 추상 클래스 |
|---|---|---|
| 목적 | **역할/계약** 정의 | **공통 구현/상태** 공유 |
| 다중 상속 | 가능 | 불가 |
| 필드 | 없음 | 가능 |
| 기본 구현 | C# 8+ 일부 가능(주의) | 자유롭게 가능 |
| 정적 추상 멤버 | 가능(C# 11+) | N/A |
| 버저닝 | 멤버 추가 시 깨짐 위험 → **기본 구현**으로 완화 | 멤버 추가 상대적 안전(기본 구현 제공 가능) |

> **상태/공통 코드 공유**가 핵심이면 *추상 클래스*, **교체 가능성/테스트성**이 핵심이면 *인터페이스* 선호.

---

## 10) 성능·메모리·박싱 메모

1. **인터페이스 호출 = 가상 호출** → 일반 호출 대비 미세 오버헤드.  
2. **값 타입(struct) + 인터페이스** 경로에서 **박싱** 발생 가능(힙 할당).  
   - 제네릭 경로(`where T : interface`)로 **박싱 회피**가 가능.  
3. **JIT 최적화(devirtualization)**: 수신자 타입이 정적으로 **sealed**로 확정되는 등 경우 인라이닝 기회 존재.  
4. 리플렉션 기반 호출은 비용 큼 → **캐싱/소스 제너레이터** 고려.

---

## 11) 버저닝 전략(중요)

- 공개 인터페이스에 **멤버 추가**는 기존 구현체를 **컴파일 에러**로 만들 수 있음.  
- 대안:
  - **보조 인터페이스** 추가(`IFoo2`) 후 선택 구현  
  - **기본 구현**으로 안전 추가(단, 런타임 호환성/충돌 고려)  
  - **어댑터/확장 메서드**로 기능 보완

---

## 12) 패턴 매칭 & 타입 검사와 함께 쓰기

```csharp
public interface IMessage { string Type { get; } }

public sealed class Ping : IMessage { public string Type => "ping"; }
public sealed class Data(string payload) : IMessage { public string Type => "data"; public string Payload => payload; }

string Route(IMessage m) => m switch
{
    { Type: "ping" }         => "PONG",
    Data d when d.Payload.Length > 0 => $"DATA:{d.Payload}",
    _                        => "UNKNOWN"
};
```

- `is`/패턴 매칭은 **인터페이스 기반 분기**를 간결/안전하게 합니다.

---

## 13) 수학적 직관 — 리스코프 치환(LSP)

> **LSP**: 베이스 계약 \( B \)를 만족하는 한, 파생 \( D \)는 어디서든 \( B \)로 치환 가능해야 한다.

$$
\forall\ C[\cdot].\; C[B] \Rightarrow C[D]
$$

- 인터페이스는 **계약을 명시**하므로, LSP를 **준수**하도록 구현을 설계해야 합니다(전제/사후조건, 예외 규약 등).

---

## 14) 실전 종합 예제 — 인터페이스 + 기본 구현 + 디폴트 훅

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public interface IParser<T>
{
    // 필수 계약
    T Parse(string s);

    // 선택적 훅(기본 구현 제공)
    public virtual string Normalize(string s) => s.Trim();

    // 템플릿 메서드 스타일(기본 구현에서 계약 재사용)
    public virtual IEnumerable<T> ParseMany(IEnumerable<string> lines) =>
        lines.Select(l => Parse(Normalize(l)));
}

public sealed class IntParser : IParser<int>
{
    public int Parse(string s)
    {
        if (!int.TryParse(Normalize(s), out var v))
            throw new FormatException("정수 아님");
        return v;
    }

    // 필요시 Normalize 재정의 가능
    public override string Normalize(string s) => s.Replace("_", "").Trim();
}

public static class Demo
{
    public static void Run()
    {
        IParser<int> p = new IntParser();
        var xs = p.ParseMany(new[] { " 1 ", " 2_3 ", " 0042 " });
        Console.WriteLine(string.Join(", ", xs)); // 1, 23, 42
    }
}

Demo.Run();
```

- **필수 계약**은 `Parse`, **선택적 훅/템플릿**을 인터페이스 기본 구현으로 제공.  
- 구현체는 **핵심 규칙만** 집중 구현 → 재사용/확장성↑.

---

## 15) 흔한 실수 & 해결책

| 실수 | 문제 | 해결 |
|---|---|---|
| 인터페이스에 무분별한 멤버 추가 | 구현체 부담/깨짐 | **인터페이스 분리(ISP)**, 기본 구현 신중 사용 |
| 값 타입을 인터페이스 변수로 자주 담음 | **박싱** 발생 | 제네릭 경로/구조체 친화 API 사용 |
| 명시적 구현 후 멤버가 “안 보임” | 의도대로 숨겨짐 | 인터페이스로 캐스팅해 사용 |
| 기본 구현 남용 | 다이아몬드 충돌/해석 혼란 | 최소한으로, 문서화 철저 |
| 공변·반공변 혼동 | 타입 안전성 저하 | `out`=생산자, `in`=소비자 규칙 준수 |

---

## 16) 체크리스트

- [ ] 이 기능은 **계약**만 필요? → 인터페이스  
- [ ] **공통 상태/코드**가 많나? → 추상 클래스 고려  
- [ ] 공개 인터페이스 **버저닝 계획** 수립  
- [ ] 값 타입과 함께 쓸 때 **박싱 경로** 점검  
- [ ] DI/테스트에서 **교체 가능성** 극대화  
- [ ] 필요 최소의 **기본 구현**, **명시적 구현**으로 표면 축소

---

## 17) 연습 과제

1) `IFormatter`(Format(string)→string)와 구현 `UpperFormatter`, `TrimFormatter` 작성.  
   - 인터페이스에 `Normalize` 기본 구현을 두고, `TrimFormatter`에서 재정의.  
2) `IRepository<T>`(where T : IEntity) 설계 후, InMemory/JsonFile 두 구현을 만들어 DI로 교체해보기.  
3) `INumeric<T>` 정적 추상 멤버를 사용해 **범용 합계/평균** 유틸리티 작성.  
4) `IProducer<out T>`/`IConsumer<in T>`를 직접 선언하고 **공변/반공변 치환** 예제를 코드로 검증.  
5) 명시적 구현으로 두 인터페이스(`ILogger`,`ITracer`)의 같은 메서드 이름 충돌을 해결.

---

## 18) 요약

- **인터페이스 = 계약 중심 설계**: 구현을 느슨히 결합하고, 교체/테스트/확장을 쉽게 한다.  
- **최신 C# 기능**(기본 구현, 정적 추상 멤버, 공변/반공변)을 이해하면 더 강력한 추상화가 가능.  
- **성능/버저닝/테스트** 관점을 함께 고려해 **안전하고 진화 가능한 API**를 설계하자.