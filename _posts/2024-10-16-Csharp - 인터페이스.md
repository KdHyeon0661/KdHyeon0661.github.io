---
layout: post
title: C# - 인터페이스
date: 2024-10-16 19:20:23 +0900
category: Csharp
---
# C# 인터페이스(interface)

## 핵심 개념

**인터페이스는 "무엇을 할 수 있어야 하는가"라는 계약(Contract)을 정의**합니다. 구현 세부사항이 아닌 메서드, 속성, 이벤트, 인덱서의 시그니처만을 명시하며, 이를 통해 다형성과 느슨한 결합을 실현합니다. 최신 C#에서는 기본 구현, 정적 추상 멤버, 공변/반공변 같은 강력한 기능들이 추가되어 더욱 표현력 있는 추상화가 가능해졌습니다.

---

## 인터페이스의 본질과 구현

인터페이스는 구현체가 준수해야 할 행동의 청사진을 제공합니다. 필드를 포함할 수 없으며, 오직 멤버의 형태만을 정의합니다.

```csharp
public interface IShape
{
    void Draw();
    double GetArea();
}

public class Circle : IShape
{
    public double Radius { get; set; }
    
    public void Draw() => Console.WriteLine("원을 그립니다.");
    public double GetArea() => Math.PI * Radius * Radius;
}

// 다형성 활용
void RenderShape(IShape shape)
{
    shape.Draw();
    Console.WriteLine($"넓이: {shape.GetArea()}");
}
```

클래스는 여러 인터페이스를 동시에 구현할 수 있어 다양한 역할을 부여받을 수 있습니다.

---

## 다양한 멤버 타입과 명시적 구현

인터페이스는 속성, 인덱서, 이벤트도 정의할 수 있습니다.

```csharp
public interface IDataContainer
{
    string Name { get; }
    string this[int index] { get; }
    event EventHandler DataChanged;
}
```

**명시적 인터페이스 구현**은 같은 시그니처의 충돌을 해결하거나 인터페이스 멤버를 공용 API에서 숨기고 싶을 때 사용합니다.

```csharp
public interface ILogger 
{ 
    void Log(string message); 
}

public class DualLogger : ILogger
{
    // 공용 메서드
    public void LogToConsole(string message) => Console.WriteLine("[PUBLIC] " + message);
    
    // 명시적 구현 - ILogger로 캐스팅해야 접근 가능
    void ILogger.Log(string message) => Console.WriteLine("[INTERFACE] " + message);
}

// 사용 예
var logger = new DualLogger();
logger.LogToConsole("Hello");  // ✅ 직접 호출 가능
// logger.Log("Hello");        // ❌ 컴파일 오류
((ILogger)logger).Log("Hello"); // ✅ 인터페이스로 캐스팅 후 호출
```

---

## 현대적 인터페이스 기능들

### 기본 구현 메서드 (C# 8+)
인터페이스에 메서드 구현을 제공하여 하위 호환성을 유지하면서 기능을 확장할 수 있습니다.

```csharp
public interface IDataProcessor
{
    // 필수 구현 메서드
    string Process(string data);
    
    // 기본 구현 제공
    public virtual string Preprocess(string data) => data.Trim().ToUpper();
    
    // 템플릿 메서드 패턴 구현
    public string ProcessWithTemplate(string data)
    {
        var processed = Preprocess(data);
        return Process(processed);
    }
}
```

### 정적 추상 멤버 (C# 11+)
제네릭 수학 연산을 위한 패턴으로, 연산자와 정적 속성을 인터페이스로 추상화합니다.

```csharp
public interface IAddable<T> where T : IAddable<T>
{
    static abstract T Zero { get; }
    static abstract T operator +(T left, T right);
}

public static T Sum<T>(IEnumerable<T> values) where T : IAddable<T>
{
    var result = T.Zero;
    foreach (var value in values)
        result = result + value;
    return result;
}
```

### 공변/반공변 제네릭 인터페이스
타입 안전성을 유지하며 더 유연한 타입 치환을 가능하게 합니다.

```csharp
// 공변(out): 출력 위치에서만 사용
public interface IProducer<out T>
{
    T Produce();
}

// 반공변(in): 입력 위치에서만 사용  
public interface IConsumer<in T>
{
    void Consume(T item);
}

// 사용 예
IProducer<string> stringProducer = GetStringProducer();
IProducer<object> objectProducer = stringProducer; // ✅ 공변성

IConsumer<object> objectConsumer = GetObjectConsumer();
IConsumer<string> stringConsumer = objectConsumer; // ✅ 반공변성
```

---

## 설계 패턴과의 시너지

### 전략 패턴
런타임에 알고리즘을 교체할 수 있도록 합니다.

```csharp
public interface ISortStrategy<T>
{
    void Sort(List<T> items);
}

public class QuickSort<T> : ISortStrategy<T> { /* 구현 */ }
public class MergeSort<T> : ISortStrategy<T> { /* 구현 */ }

public class Sorter<T>
{
    private ISortStrategy<T> _strategy;
    
    public Sorter(ISortStrategy<T> strategy) => _strategy = strategy;
    
    public void SetStrategy(ISortStrategy<T> strategy) => _strategy = strategy;
    public void Sort(List<T> items) => _strategy.Sort(items);
}
```

### 어댑터 패턴
호환되지 않는 인터페이스를 함께 작동하도록 합니다.

```csharp
// 레거시 클래스
public class LegacyLogger
{
    public void WriteToConsole(string msg) => Console.WriteLine(msg);
}

// 현대적 인터페이스
public interface ILogger
{
    void Log(string message, LogLevel level);
}

// 어댑터
public class LegacyLoggerAdapter : ILogger
{
    private readonly LegacyLogger _legacyLogger;
    
    public LegacyLoggerAdapter(LegacyLogger logger) => _legacyLogger = logger;
    
    public void Log(string message, LogLevel level)
    {
        _legacyLogger.WriteToConsole($"[{level}] {message}");
    }
}
```

### 데코레이터 패턴
기능을 동적으로 추가할 수 있습니다.

```csharp
public interface IDataService
{
    string GetData(string id);
}

public class CachingDecorator : IDataService
{
    private readonly IDataService _innerService;
    private readonly Dictionary<string, string> _cache = new();
    
    public CachingDecorator(IDataService innerService) => _innerService = innerService;
    
    public string GetData(string id)
    {
        if (_cache.TryGetValue(id, out var cached))
            return cached;
            
        var data = _innerService.GetData(id);
        _cache[id] = data;
        return data;
    }
}
```

---

## 인터페이스 vs 추상 클래스: 현대적 관점

| 기준 | 인터페이스 | 추상 클래스 |
|------|-----------|-------------|
| **상속** | 다중 구현 가능 | 단일 상속만 가능 |
| **상태** | 필드 보유 불가 | 필드와 상태 보유 가능 |
| **구현** | 기본 구현 선택적 제공(C# 8+) | 완전/부분 구현 모두 가능 |
| **목적** | 계약과 역할 정의 | 공통 구현과 템플릿 제공 |
| **버저닝** | 멤버 추가 시 파괴적 변경 가능 | 상대적으로 안전한 확장 |

**선택 가이드라인:**
- **인터페이스**는 테스트 용이성, 느슨한 결합, 다형성이 중요할 때
- **추상 클래스**는 공통 상태와 행동을 공유하는 강력한 계층 구조가 필요할 때

---

## 성능 고려사항과 최적화

1. **가상 호출 오버헤드**: 인터페이스 메서드 호출은 가상 테이블을 통한 간접 호출로, 직접 호출보다 약간의 오버헤드가 있습니다.

2. **값 타입과 박싱**: 구조체를 인터페이스 타입으로 사용할 때 박싱이 발생할 수 있습니다.
   ```csharp
   struct Point : IDrawable { /* 구현 */ }
   
   IDrawable drawable = new Point(); // ❌ 박싱 발생
   
   // 개선: 제네릭 사용
   void Draw<T>(T shape) where T : IDrawable
   {
       shape.Draw(); // ✅ 박싱 없음
   }
   ```

3. **JIT 최적화**: sealed 클래스나 정적으로 알려진 타입에 대해 JIT 컴파일러가 가상 호출을 제거할 수 있습니다.

---

## 버저닝과 호환성 관리

공개 인터페이스의 변경은 기존 구현체를 깨뜨릴 수 있습니다. 안전한 진화 전략:

1. **새 인터페이스 생성**: `IFoo` → `IFoo2`
2. **기본 구현 추가**: 새로운 메서드에 기본 구현 제공
3. **확장 메서드 활용**: 정적 클래스로 기능 추가

```csharp
// 버전 1
public interface IRepository<T>
{
    T GetById(int id);
}

// 버전 2 - 하위 호환성 유지
public interface IRepository<T> : IRepository<T>
{
    // 새로운 메서드에 기본 구현
    public virtual IEnumerable<T> GetAll() => throw new NotImplementedException();
    
    // 또는 확장 메서드로 제공
    // (확장 메서드는 별도 정적 클래스에서 정의)
}
```

---

## 실전 적용 예제: 완전한 시스템 설계

```csharp
// 핵심 인터페이스
public interface IOrder
{
    string Id { get; }
    decimal CalculateTotal();
    DateTime CreatedAt { get; }
}

public interface IPaymentProcessor
{
    PaymentResult ProcessPayment(IOrder order, PaymentDetails details);
}

public interface INotificationService
{
    Task SendOrderConfirmation(IOrder order, string customerEmail);
}

// 구현체
public class OnlineOrder : IOrder
{
    public string Id { get; } = Guid.NewGuid().ToString();
    public List<OrderItem> Items { get; } = new();
    public DateTime CreatedAt { get; } = DateTime.UtcNow;
    
    public decimal CalculateTotal() => Items.Sum(i => i.Price * i.Quantity);
}

// 서비스 조립
public class OrderProcessingService
{
    private readonly IPaymentProcessor _paymentProcessor;
    private readonly INotificationService _notificationService;
    private readonly IRepository<IOrder> _repository;
    
    public OrderProcessingService(
        IPaymentProcessor paymentProcessor,
        INotificationService notificationService,
        IRepository<IOrder> repository)
    {
        _paymentProcessor = paymentProcessor;
        _notificationService = notificationService;
        _repository = repository;
    }
    
    public async Task<OrderResult> ProcessOrder(IOrder order, PaymentDetails payment)
    {
        var paymentResult = _paymentProcessor.ProcessPayment(order, payment);
        if (!paymentResult.Success)
            return OrderResult.Failed(paymentResult.Error);
            
        await _repository.Save(order);
        await _notificationService.SendOrderConfirmation(order, payment.Email);
        
        return OrderResult.Success(order.Id);
    }
}
```

---

## 결론: 인터페이스 중심 설계의 힘

C# 인터페이스는 단순한 계약 정의를 넘어, 현대적 소프트웨어 설계의 핵심 도구로 진화했습니다. 기본 구현 메서드, 정적 추상 멤버, 공변/반공변 같은 기능들은 더 강력하고 유연한 추상화를 가능하게 합니다.

**인터페이스 중심 설계의 핵심 가치는 다음과 같습니다:**

1. **테스트 용이성**: 모의 객체를 통한 단위 테스트가 간편해집니다.
2. **느슨한 결합**: 컴포넌트 간 의존성을 최소화하여 시스템 유연성을 높입니다.
3. **다형성**: 동일한 인터페이스를 통해 다양한 구현체를 일관되게 사용할 수 있습니다.
4. **진화 용이성**: 새로운 구현체 추가나 기존 구현체 교체가 용이합니다.
5. **명확한 계약**: 시스템의 각 구성 요소가 무엇을 해야 하는지 명확히 정의합니다.

인터페이스를 효과적으로 사용하는 핵심은 "구현이 아닌 계약에 프로그래밍하라"는 원칙을 준수하는 것입니다. 이는 더 견고하고 유지보수 가능하며 확장성 있는 시스템을 구축하는 데 필수적인 접근 방식입니다.