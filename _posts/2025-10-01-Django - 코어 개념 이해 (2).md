---
layout: post
title: Django - 코어 개념 이해 (2)
date: 2025-10-01 16:25:23 +0900
category: Django
---
# — Forms, ORM & 모델, 마이그레이션 (Django 5.x 기준)

## A. Forms — ModelForm, 검증/에러 처리, Formset/InlineFormset, 파일 업로드

### A-1. 폼 시스템 큰 그림

- **Form**: 요청 데이터(POST/FILES)를 **검증(validate)** → **정규화(cleaned_data)** → **에러 메시지 관리**
- **ModelForm**: 모델 필드 정의를 재활용, CRUD 폼 생산성 ↑
- **Formset / InlineFormset**: **여러 행**(또는 부모-자식 관계) 묶음 입력
- **파일 업로드(Form + Storage)**: `FileField`, `ImageField`, `MEDIA_*` 설정, 스토리지 백엔드(S3 등)

**기본 처리 사이클**
1) `request.method == "POST"` → `form = Form(request.POST, request.FILES)`
2) `form.is_valid()` → 내부적으로 **필드별 clean + 폼 전체 clean**
3) 성공: `form.cleaned_data` 사용 / **ModelForm은 `.save()`**
4) 실패: `form.errors` 로 템플릿에서 렌더

---

### A-2. ModelForm 기본

#### 모델 정의

```python
# apps/blog/models.py

from django.db import models

class Category(models.Model):
    name = models.CharField(max_length=60, unique=True)

    def __str__(self):
        return self.name

class Post(models.Model):
    title = models.CharField(max_length=150)
    slug = models.SlugField(unique=True)
    body = models.TextField()
    category = models.ForeignKey(Category, on_delete=models.PROTECT, related_name="posts")
    is_public = models.BooleanField(default=True)
    published_at = models.DateTimeField(null=True, blank=True)

    # 비즈니스 규칙 예시
    def can_publish(self) -> bool:
        return self.title and self.body
```

#### ModelForm 정의

```python
# apps/blog/forms.py

from django import forms
from .models import Post

class PostForm(forms.ModelForm):
    # 폼 전용 위젯/라벨/도움말 메시지 커스터마이징 가능
    class Meta:
        model = Post
        fields = ["title", "slug", "body", "category", "is_public", "published_at"]
        widgets = {
            "published_at": forms.DateTimeInput(attrs={"type": "datetime-local"}),
        }
        help_texts = {
            "slug": "고유 슬러그(주소). 공백 없이 소문자/하이픈 권장.",
        }
        error_messages = {
            "title": {"required": "제목은 필수입니다."},
            "slug": {"unique": "이미 사용 중인 슬러그입니다."},
        }

    # 필드 단위 검증: clean_<fieldname>
    def clean_title(self):
        title = self.cleaned_data.get("title", "")
        if len(title.strip()) < 3:
            raise forms.ValidationError("제목은 3자 이상 입력해 주세요.")
        return title

    # 폼 전체 교차 검증: clean()
    def clean(self):
        cleaned = super().clean()
        is_public = cleaned.get("is_public")
        published_at = cleaned.get("published_at")
        if is_public and not published_at:
            # 공개글은 공개 시각 필수라는 예시 규칙
            self.add_error("published_at", "공개 글은 공개 시각이 필요합니다.")
        return cleaned
```

#### 뷰/템플릿

```python
# apps/blog/views.py

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .forms import PostForm
from .models import Post

def post_new(request):
    if request.method == "POST":
        form = PostForm(request.POST)
        if form.is_valid():
            post = form.save()     # ModelForm은 save 지원
            messages.success(request, "게시글을 작성했습니다.")
            return redirect("blog:detail", slug=post.slug)
    else:
        form = PostForm()
    return render(request, "blog/post_form.html", {"form": form})

def post_edit(request, slug):
    post = get_object_or_404(Post, slug=slug)
    if request.method == "POST":
        form = PostForm(request.POST, instance=post)
        if form.is_valid():
            post = form.save()
            messages.success(request, "수정했습니다.")
            return redirect("blog:detail", slug=post.slug)
    else:
        form = PostForm(instance=post)
    return render(request, "blog/post_form.html", {"form": form})
```

{% raw %}
```html
<!-- templates/blog/post_form.html -->
{% extends "base.html" %}
{% block content %}
<h1>{{ form.instance.pk|yesno:"게시글 수정,새 글" }}</h1>
<form method="post">
  {% csrf_token %}
  {{ form.non_field_errors }}
  <div>
    {{ form.title.label_tag }} {{ form.title }}
    {{ form.title.errors }}
  </div>
  <div>
    {{ form.slug.label_tag }} {{ form.slug }} <small>{{ form.slug.help_text }}</small>
    {{ form.slug.errors }}
  </div>
  <div>
    {{ form.body.label_tag }} {{ form.body }}
    {{ form.body.errors }}
  </div>
  <div>
    {{ form.category.label_tag }} {{ form.category }}
    {{ form.category.errors }}
  </div>
  <div>
    {{ form.is_public.label_tag }} {{ form.is_public }}
    {{ form.is_public.errors }}
  </div>
  <div>
    {{ form.published_at.label_tag }} {{ form.published_at }}
    {{ form.published_at.errors }}
  </div>

  <button type="submit">저장</button>
</form>
{% endblock %}
```
{% endraw %}

---

### A-3. 검증/에러 처리 패턴

- **필드 단위**: `clean_<field>()`
- **교차 검증**: `clean()` → `self.add_error("field", "msg")` 또는 `raise ValidationError({...})`
- **비정상 입력 케이스**: `form.errors`, `form.non_field_errors()`로 템플릿에서 출력
- **오류 메시지 국제화**: `from django.utils.translation import gettext_lazy as _`

```python
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _

def clean(self):
    cleaned = super().clean()
    start = cleaned.get("start_date")
    end = cleaned.get("end_date")
    if start and end and start > end:
        raise ValidationError(_("시작일은 종료일보다 빠르거나 같아야 합니다."))
    return cleaned
```

---

### A-4. Formset — 여러 폼을 하나로 (동일 모델이 아닌 일반 폼도 가능)

```python
# apps/orders/forms.py

from django import forms
from django.forms import formset_factory

class CouponForm(forms.Form):
    code = forms.CharField(max_length=20)
    discount = forms.IntegerField(min_value=0, max_value=100)

CouponFormSet = formset_factory(CouponForm, extra=2, can_delete=True)
```

```python
# apps/orders/views.py

from django.shortcuts import render, redirect
from .forms import CouponFormSet

def coupon_manage(request):
    if request.method == "POST":
        formset = CouponFormSet(request.POST)
        if formset.is_valid():
            # formset.cleaned_data 는 각 폼의 dict 리스트
            data = [cd for cd in formset.cleaned_data if cd and not cd.get("DELETE")]
            # 저장/적용 로직...
            return redirect("orders:coupon_manage")
    else:
        formset = CouponFormSet()
    return render(request, "orders/coupon_manage.html", {"formset": formset})
```

{% raw %}
```html
<!-- templates/orders/coupon_manage.html -->
<form method="post">
  {% csrf_token %}
  {{ formset.management_form }}
  <table>
    {% for form in formset %}
    <tr>
      <td>{{ form.code }}</td>
      <td>{{ form.discount }}</td>
      {% if formset.can_delete %}
        <td>{{ form.DELETE }} 삭제</td>
      {% endif %}
    </tr>
    {% endfor %}
  </table>
  <button type="submit">저장</button>
</form>
```
{% endraw %}

---

### 묶음

**시나리오**: `Order`(부모), `OrderItem`(자식들)을 한 화면에서 관리

```python
# apps/orders/models.py

from django.db import models

class Order(models.Model):
    customer = models.CharField(max_length=80)
    created_at = models.DateTimeField(auto_now_add=True)

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="items")
    product = models.CharField(max_length=120)
    quantity = models.PositiveIntegerField(default=1)
    price = models.PositiveIntegerField(default=0)  # 단가
```

```python
# apps/orders/forms.py

from django.forms import inlineformset_factory
from .models import Order, OrderItem

OrderItemFormSet = inlineformset_factory(
    Order,
    OrderItem,
    fields=["product", "quantity", "price"],
    extra=1,
    can_delete=True,
    min_num=1,
    validate_min=True,
)
```

```python
# apps/orders/views.py

from django.shortcuts import render, redirect, get_object_or_404
from .models import Order
from .forms import OrderItemFormSet

def order_edit(request, pk):
    order = get_object_or_404(Order, pk=pk)
    if request.method == "POST":
        formset = OrderItemFormSet(request.POST, instance=order)
        if formset.is_valid():
            # 유효성 체크 강화: 총액 0 금지 같은 교차 검증은 clean()에서
            formset.save()  # 내부에서 add/delete 처리
            return redirect("orders:detail", pk=order.pk)
    else:
        formset = OrderItemFormSet(instance=order)
    return render(request, "orders/order_edit.html", {"order": order, "formset": formset})
```

{% raw %}
```html
<!-- templates/orders/order_edit.html -->
<h1>주문 수정: {{ order.pk }}</h1>
<form method="post">
  {% csrf_token %}
  {{ formset.management_form }}
  <table>
    <thead>
      <tr><th>상품</th><th>수량</th><th>단가</th><th>삭제</th></tr>
    </thead>
    <tbody>
      {% for form in formset %}
      <tr>
        <td>{{ form.product }}</td>
        <td>{{ form.quantity }}</td>
        <td>{{ form.price }}</td>
        <td>{% if formset.can_delete %}{{ form.DELETE }}{% endif %}</td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
  <button type="submit">저장</button>
</form>
```
{% endraw %}

**InlineFormset 교차 검증 예시**
```python
# apps/orders/forms.py (추가)

from django.core.exceptions import ValidationError

class ValidatingOrderItemFormSet(OrderItemFormSet):
    def clean(self):
        super().clean()
        total = 0
        for form in self.forms:
            if getattr(form, "cleaned_data", None) and not form.cleaned_data.get("DELETE"):
                qty = form.cleaned_data.get("quantity") or 0
                price = form.cleaned_data.get("price") or 0
                total += qty * price
        if total <= 0:
            raise ValidationError("주문 총액이 0원 이하여서는 안 됩니다.")
```

---

### A-6. 파일 업로드 — ImageField/파일 크기 제한/스토리지

**설정**
```python
# config/settings/base.py 일부

MEDIA_URL = "media/"
MEDIA_ROOT = BASE_DIR / "media"
```

**모델**
```python
# apps/assets/models.py

from django.db import models

def upload_to_post_image(instance, filename):
    # 예: "posts/<pk or temp>/filename"
    return f"posts/{instance.pk or 'new'}/{filename}"

class PostImage(models.Model):
    image = models.ImageField(upload_to=upload_to_post_image)
    caption = models.CharField(max_length=120, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
```

> `ImageField` 사용 시 **Pillow** 필요: `pip install Pillow`

**폼 & 뷰**
```python
# apps/assets/forms.py

from django import forms
from .models import PostImage

class PostImageForm(forms.ModelForm):
    class Meta:
        model = PostImage
        fields = ["image", "caption"]

    def clean_image(self):
        f = self.cleaned_data["image"]
        max_mb = 5
        if f.size > max_mb * 1024 * 1024:
            raise forms.ValidationError(f"이미지 크기는 {max_mb}MB 이하만 가능합니다.")
        if not f.content_type.startswith("image/"):
            raise forms.ValidationError("이미지 파일만 업로드하세요.")
        return f
```

```python
# apps/assets/views.py

from django.shortcuts import render, redirect
from .forms import PostImageForm

def upload(request):
    if request.method == "POST":
        form = PostImageForm(request.POST, request.FILES)
        if form.is_valid():
            form.save()
            return redirect("assets:list")
    else:
        form = PostImageForm()
    return render(request, "assets/upload.html", {"form": form})
```

{% raw %}
```html
<!-- templates/assets/upload.html -->
<form method="post" enctype="multipart/form-data">
  {% csrf_token %}
  {{ form.non_field_errors }}
  {{ form.image.label_tag }} {{ form.image }} {{ form.image.errors }}<br>
  {{ form.caption.label_tag }} {{ form.caption }} {{ form.caption.errors }}<br>
  <button type="submit">업로드</button>
</form>
```
{% endraw %}

**보안/성능 팁**
- 확장자+MIME **이중 검증**(서버에서 Pillow로 이미지 열어보기 등)
- 큰 파일: **청크 업로드**(클라이언트) + **백그라운드 처리**(썸네일, 바이러스 스캔)
- 스토리지: `django-storages` + S3/CloudFront 사용 시 **서명 URL**, **브라우저 캐시 정책** 고려

---

## B. ORM & 모델 — 필드/옵션, 관계(M2M/ForeignKey), 쿼리셋 API, 매니저

### B-1. 필드 & 옵션 핵심 요약

- **문자열/텍스트**: `CharField(max_length=...)`, `TextField()`
- **숫자**: `IntegerField`, `PositiveIntegerField`, `DecimalField(max_digits, decimal_places)`
- **날짜/시간**: `DateField`, `DateTimeField`, `auto_now_add`, `auto_now`
- **논리**: `BooleanField` (+ `NullBooleanField`는 제거)
- **파일/이미지**: `FileField`, `ImageField`
- **기타**: `EmailField`, `URLField`, `UUIDField`, `JSONField` 등
- **공통 옵션**: `null`, `blank`, `default`, `unique`, `db_index`, `choices`, `validators`, `help_text`
- **Meta 옵션**:
  - `ordering = ["-created_at"]`
  - `constraints` (`UniqueConstraint`, `CheckConstraint`)
  - `indexes` (다중 컬럼 인덱스)
  - `db_table`, `verbose_name`, `verbose_name_plural`

```python
# apps/inventory/models.py

from django.db import models
from django.db.models import Q, F

class Product(models.Model):
    sku = models.CharField(max_length=20, unique=True, db_index=True)
    name = models.CharField(max_length=120)
    price = models.PositiveIntegerField()
    stock = models.PositiveIntegerField(default=0)
    is_active = models.BooleanField(default=True)
    meta = models.JSONField(default=dict, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-created_at"]
        constraints = [
            models.CheckConstraint(check=Q(price__gte=0), name="price_non_negative"),
            models.CheckConstraint(check=Q(stock__gte=0), name="stock_non_negative"),
        ]
        indexes = [
            models.Index(fields=["is_active", "price"]),
        ]

    def __str__(self):
        return f"{self.sku} - {self.name}"

    @property
    def inventory_value(self):
        return self.price * self.stock
```

---

### B-2. 관계 — ForeignKey / OneToOne / ManyToMany

```python
# apps/inventory/models.py (추가)

class Brand(models.Model):
    name = models.CharField(max_length=80, unique=True)

class ProductDetail(models.Model):
    product = models.OneToOneField(Product, on_delete=models.CASCADE, related_name="detail")
    description = models.TextField(blank=True)
    spec = models.JSONField(default=dict, blank=True)

class Tag(models.Model):
    name = models.CharField(max_length=40, unique=True)
    products = models.ManyToManyField(Product, related_name="tags", blank=True)
```

- **FK on_delete**: `CASCADE`, `PROTECT`, `SET_NULL`, `SET_DEFAULT`, `DO_NOTHING`
- `related_name` 으로 역참조 이름 제어: `order.items.all()` 같은 표현
- M2M은 `through` 모델로 **중간 테이블** 커스터마이징 가능(추가 속성 보유)

```python
# M2M 중간모델 예시

class ProductTag(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)
    priority = models.PositiveIntegerField(default=0)

class Tag(models.Model):
    name = models.CharField(max_length=40, unique=True)
    products = models.ManyToManyField(Product, through=ProductTag, related_name="tags2")
```

---

### B-3. 쿼리셋 API — 필터링/정렬/슬라이싱/집계/표현식

**기본**
```python
qs = Product.objects.filter(is_active=True).order_by("-created_at")[:20]
exists = Product.objects.filter(sku="A001").exists()
count = Product.objects.filter(price__gte=10000).count()
```

**Q/F 객체 & 조건식**
```python
from django.db.models import Q, F, Value, Case, When, IntegerField

qs = Product.objects.filter(Q(price__gte=10000) | Q(stock__gte=50))

# 컬럼 간 비교

qs = Product.objects.filter(stock__gt=F("price") / 100)

# 조건식(할인율 컬럼 예시)

qs = Product.objects.annotate(
    discount_flag=Case(
        When(price__gte=50000, then=Value(1)),
        default=Value(0),
        output_field=IntegerField(),
    )
)
```

**집계/그룹**
```python
from django.db.models import Sum, Avg, Max, Min, Count

agg = Product.objects.aggregate(
    total_stock=Sum("stock"),
    avg_price=Avg("price"),
)
per_brand = Product.objects.values("brand__name").annotate(
    cnt=Count("id"),
    sum_stock=Sum("stock"),
).order_by("-cnt")
```

**Subquery/Exists**
```python
from django.db.models import Subquery, OuterRef, Exists
from apps.inventory.models import ProductDetail

detail_qs = ProductDetail.objects.filter(product=OuterRef("pk"))
qs = Product.objects.annotate(
    has_detail=Exists(detail_qs)
).filter(has_detail=True)
```

**select_related / prefetch_related (N+1 방지)**
```python
# FK/OneToOne → select_related

qs = Product.objects.select_related("detail").all()

# M2M/역참조 → prefetch_related

qs = Product.objects.prefetch_related("tags").all()

# 복합 prefetch

from django.db.models import Prefetch
qs = Product.objects.prefetch_related(
    Prefetch("tags", queryset=Tag.objects.order_by("name"))
)
```

**bulk API**
```python
# 대량 생성

Product.objects.bulk_create([
    Product(sku="B001", name="Bag", price=12000),
    Product(sku="B002", name="Cap", price=8000),
], ignore_conflicts=True)

# 시그널/clean 호출되지 않음)

Product.objects.filter(is_active=True).update(stock=F("stock") + 10)
```

**get_or_create / update_or_create**
```python
obj, created = Product.objects.get_or_create(sku="X001", defaults={"name": "X", "price": 1000})
obj, created = Product.objects.update_or_create(sku="X001", defaults={"price": 1500})
```

**트랜잭션 & 잠금**
```python
from django.db import transaction

with transaction.atomic():
    # select_for_update: 행 잠금
    p = Product.objects.select_for_update().get(pk=1)
    p.stock -= 1
    p.save()
```

---

### B-4. 매니저 & 커스텀 쿼리셋

**커스텀 QuerySet**: 체이닝 가능한 도메인 메서드
```python
# apps/inventory/querysets.py

from django.db import models

class ProductQuerySet(models.QuerySet):
    def active(self):
        return self.filter(is_active=True)

    def expensive(self, min_price=50000):
        return self.filter(price__gte=min_price)
```

**매니저에 연결**
```python
# apps/inventory/models.py (일부)

from .querysets import ProductQuerySet

class Product(models.Model):
    # ...
    objects = ProductQuerySet.as_manager()

# 사용

qs = Product.objects.active().expensive()
```

**여러 매니저**
- 기본 `objects` 외 별도 매니저를 두고 싶다면 커스텀 매니저 정의 후 `objects = CustomManager()` 패턴
- Admin이 어떤 매니저를 쓰는지 고려(보통 기본 objects)

---

## C. 마이그레이션 — 생성/의존성/병합, 데이터 마이그레이션, 흔한 충돌 해결

### C-1. 기본 명령 & 사이클

```bash
python manage.py makemigrations   # 모델 변경 감지 → 마이그레이션 파일 생성
python manage.py migrate          # DB에 적용
python manage.py showmigrations   # 적용 상태 조회
```

**마이그레이션 파일 구조**
```python
# apps/inventory/migrations/0003_add_check_constraints.py

from django.db import migrations, models
import django.db.models.deletion

class Migration(migrations.Migration):
    dependencies = [
        ("inventory", "0002_previous"),
    ]

    operations = [
        migrations.AddConstraint(
            model_name="product",
            constraint=models.CheckConstraint(
                check=models.Q(("price__gte", 0)),
                name="price_non_negative",
            ),
        ),
    ]
```

- `dependencies`: 반드시 선행되어야 하는 마이그레이션
- `operations`: 스키마 변경 or 데이터 작업 내용

---

### C-2. 스키마 변경(대표적인 Operation)

- `CreateModel`, `DeleteModel`, `AddField`, `RemoveField`, `AlterField`, `RenameModel`, `RenameField`
- `AddConstraint`, `RemoveConstraint`
- `RunPython`, `RunSQL` (데이터/커스텀 작업)

**주의사항**
- 컬럼 **nullable → not-null** 전환 시, **기존 데이터 채우기** 필요 (default 제공 or `RunPython` 로 값 세팅)
- **대용량 테이블**에서의 `ALTER` 는 **잠금/다운타임** 유발 가능 → **배치/단계적** 전환 전략

---

### C-3. 데이터 마이그레이션 — `RunPython`

**시나리오**: `Product` 에 새 필드 `slug` 추가 후, 기존 `sku` 기반으로 slug 채우기

```python
# apps/inventory/migrations/0010_add_slug_and_fill.py

from django.db import migrations
from django.utils.text import slugify

def forwards(apps, schema_editor):
    Product = apps.get_model("inventory", "Product")
    for p in Product.objects.all().iterator():
        p.slug = slugify(p.sku)
        p.save(update_fields=["slug"])

def backwards(apps, schema_editor):
    Product = apps.get_model("inventory", "Product")
    Product.objects.update(slug=None)

class Migration(migrations.Migration):
    dependencies = [("inventory", "0009_previous")]
    operations = [
        migrations.AddField(
            model_name="product",
            name="slug",
            field=models.SlugField(unique=True, null=True),
        ),
        migrations.RunPython(forwards, backwards),
        migrations.AlterField(
            model_name="product",
            name="slug",
            field=models.SlugField(unique=True),  # null 제거
        ),
    ]
```

**팁**
- 대량 업데이트 시 **`update()` + 표현식** 또는 **배치 처리**(`iterator()`, chunk) 고려
- `RunPython.noop` 으로 역방향 생략 가능하나, 가능하면 **reversible** 작성

---

### — 브랜치 충돌 다루기

**상황**: 서로 다른 브랜치에서 `0005` 를 기초로 `0006_a.py`, `0006_b.py` 를 만들고 병합 시 **그래프 분기** 발생

해결: `makemigrations` 시 **자동 merge migration** 생성되거나, 수동으로 병합 파일 작성
```python
# apps/blog/migrations/0007_merge_0006_a_0006_b.py

from django.db import migrations

class Migration(migrations.Migration):
    dependencies = [
        ("blog", "0006_a"),
        ("blog", "0006_b"),
    ]

    operations = []
```
- 단순히 **병합 노드**로 기능, 이후 마이그레이션은 0007에 의존
- 스키마 충돌(동일 필드 서로 다른 정의) 시, 한쪽을 선택/조정 후 `AlterField` 로 맞춤

---

### C-5. 흔한 충돌/오류와 해결

1) **`unique_together`/`UniqueConstraint` 추가 전 기존 중복 데이터 존재**
   - 마이그레이션 전에 **정합성 정리**(`RunPython` or SQL) → 그 다음 제약 추가

2) **Not-null 전환 시 기존 null 데이터**
   - 단계적 접근:
     a) 필드 추가(`null=True`) →
     b) `RunPython` 으로 값 채우기 →
     c) `AlterField(null=False)` 로 전환

3) **필드 타입 변경**(예: `CharField` → `IntegerField`)
   - 데이터 변환 필요: `RunPython` 으로 안전 변환 + 예외 처리
   - 대규모 테이블에서는 **검증/롤백 전략** 마련

4) **긴 인덱스/대용량 인덱스 생성**
   - 오프피크 시간대 적용
   - DB별 **CONCURRENTLY** 옵션(포스트그레스) 고려 → `RunSQL` 사용

5) **순환 의존성**
   - 앱/마이그레이션 설계를 재검토
   - 모델 분리 or 의존 관계 정리, 필요한 경우 `apps.get_model` 동적 접근

---

### — 오래된 마이그레이션 병합

```bash
python manage.py squashmigrations appname 0001 0050
```
- 0001~0050 사이를 하나로 스쿼시한 파일 생성
- **주의**: 프로덕션/로컬 적용 상태가 다를 수 있으므로, 스쿼시 전후 **동일 스키마**임을 검증

---

### C-7. 상태 제어 — fake/fake-initial/특정 버전으로 이동

```bash
# 마이그레이션 적용은 하지 않고, 상태만 적용된 것으로 표시

python manage.py migrate appname 0005 --fake

# 초기 마이그레이션과 DB 스키마가 이미 일치하면 초기만 fake-initial

python manage.py migrate --fake-initial

# 특정 마이그레이션까지 롤백/전진

python manage.py migrate appname 0003
python manage.py migrate appname zero   # 앱 전체 초기화 (주의!)
```

---

### C-8. 무중단/대규모 테이블 마이그레이션 전략(개념)

- **단계적 배포**:
  1) **읽기/쓰기 호환성** 유지되는 스키마 추가(새 컬럼 nullable)
  2) 애플리케이션 코드가 새 컬럼도 채우도록 배포
  3) 데이터 백필(배치)
  4) 컬럼 not-null/제약 강화
  5) 구식 컬럼 제거
- **잠금 최소화**: DB별 온라인 DDL/인덱스 옵션 활용, 오프피크 적용
- **롱 러닝 마이그레이션 분할**: chunk 단위로 처리, `iterator()`
- **백업/롤백 플랜**: 스냅샷, 트랜잭션 경계, 재적용 시나리오

---

## D. 종합 예제 — “주문 + 아이템 + 쿠폰” (폼/인라인폼셋/ORM/마이그레이션)

### D-1. 모델

```python
# apps/shop/models.py

from django.db import models
from django.db.models import Sum, F

class Order(models.Model):
    customer = models.CharField(max_length=80)
    email = models.EmailField()
    created_at = models.DateTimeField(auto_now_add=True)
    coupon_code = models.CharField(max_length=20, blank=True)
    discount_rate = models.PositiveIntegerField(default=0)  # 0~100

    def subtotal(self):
        s = self.items.aggregate(total=Sum(F("quantity") * F("unit_price")))["total"]
        return s or 0

    def total(self):
        sub = self.subtotal()
        return sub - (sub * self.discount_rate // 100)

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="items")
    product_name = models.CharField(max_length=120)
    quantity = models.PositiveIntegerField(default=1)
    unit_price = models.PositiveIntegerField(default=0)
```

### D-2. 폼/인라인폼셋

```python
# apps/shop/forms.py

from django import forms
from django.forms import inlineformset_factory
from .models import Order, OrderItem

class OrderForm(forms.ModelForm):
    class Meta:
        model = Order
        fields = ["customer", "email", "coupon_code", "discount_rate"]

    def clean_discount_rate(self):
        r = self.cleaned_data.get("discount_rate", 0)
        if r > 90:
            raise forms.ValidationError("할인율은 90% 이하여야 합니다.")
        return r

OrderItemFormSet = inlineformset_factory(
    Order,
    OrderItem,
    fields=["product_name", "quantity", "unit_price"],
    extra=1,
    can_delete=True,
    min_num=1, validate_min=True,
)
```

### D-3. 뷰

```python
# apps/shop/views.py

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .forms import OrderForm, OrderItemFormSet
from .models import Order

def order_new(request):
    if request.method == "POST":
        form = OrderForm(request.POST)
        formset = OrderItemFormSet(request.POST)
        if form.is_valid() and formset.is_valid():
            order = form.save()
            formset.instance = order
            formset.save()
            messages.success(request, f"주문 생성: #{order.pk}")
            return redirect("shop:order_detail", pk=order.pk)
    else:
        form = OrderForm()
        formset = OrderItemFormSet()
    return render(request, "shop/order_form.html", {"form": form, "formset": formset})

def order_edit(request, pk):
    order = get_object_or_404(Order, pk=pk)
    if request.method == "POST":
        form = OrderForm(request.POST, instance=order)
        formset = OrderItemFormSet(request.POST, instance=order)
        if form.is_valid() and formset.is_valid():
            form.save()
            formset.save()
            messages.success(request, "수정 완료")
            return redirect("shop:order_detail", pk=order.pk)
    else:
        form = OrderForm(instance=order)
        formset = OrderItemFormSet(instance=order)
    return render(request, "shop/order_form.html", {"form": form, "formset": formset, "order": order})

def order_detail(request, pk):
    order = get_object_or_404(Order, pk=pk)
    return render(request, "shop/order_detail.html", {"order": order})
```

### D-4. 템플릿

{% raw %}
```html
<!-- templates/shop/order_form.html -->
{% extends "base.html" %}
{% block content %}
<h1>{{ order|default_if_none:"새 주문" }}</h1>
<form method="post">
  {% csrf_token %}
  {{ form.non_field_errors }}
  <div>{{ form.customer.label_tag }} {{ form.customer }} {{ form.customer.errors }}</div>
  <div>{{ form.email.label_tag }} {{ form.email }} {{ form.email.errors }}</div>
  <div>{{ form.coupon_code.label_tag }} {{ form.coupon_code }} {{ form.coupon_code.errors }}</div>
  <div>{{ form.discount_rate.label_tag }} {{ form.discount_rate }} {{ form.discount_rate.errors }}</div>

  <h2>아이템</h2>
  {{ formset.management_form }}
  <table>
    <thead><tr><th>상품명</th><th>수량</th><th>단가</th><th>삭제</th></tr></thead>
    <tbody>
      {% for f in formset %}
      <tr>
        <td>{{ f.product_name }} {{ f.product_name.errors }}</td>
        <td>{{ f.quantity }} {{ f.quantity.errors }}</td>
        <td>{{ f.unit_price }} {{ f.unit_price.errors }}</td>
        <td>{% if formset.can_delete %}{{ f.DELETE }}{% endif %}</td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
  <button type="submit">저장</button>
</form>
{% endblock %}
```
{% endraw %}

{% raw %}
```html
<!-- templates/shop/order_detail.html -->
{% extends "base.html" %}
{% block content %}
<h1>주문 #{{ order.pk }}</h1>
<p>고객: {{ order.customer }} ({{ order.email }})</p>
<p>할인율: {{ order.discount_rate }}%</p>
<table>
  <thead><tr><th>상품명</th><th>수량</th><th>단가</th><th>금액</th></tr></thead>
  <tbody>
  {% for i in order.items.all %}
    <tr>
      <td>{{ i.product_name }}</td>
      <td>{{ i.quantity }}</td>
      <td>{{ i.unit_price }}</td>
      <td>{{ i.quantity|add:"0"|floatformat:0|yesno:"" }}{{ i.quantity|default_if_none:0|add:0|mul:i.unit_price }}</td>
    </tr>
  {% endfor %}
  </tbody>
</table>
<p>소계: {{ order.subtotal }}</p>
<p>총액: {{ order.total }}</p>
<a href="{% url 'shop:order_edit' pk=order.pk %}">수정</a>
{% endblock %}
```
{% endraw %}

> 참고: 템플릿에서 곱셈이 필요하면 **커스텀 필터**를 만들거나, 컨텍스트에서 계산한 값을 전달하는 편이 더 명확합니다. 위의 `mul` 사용 부분은 커스텀 필터가 있다고 가정한 예시입니다.

---

## E. 체크리스트 & 모범 사례

**Forms**
- [ ] `clean_<field>()` + `clean()` 로 필드/교차 검증 분리
- [ ] 사용자 메시지: `error_messages`, 국제화(`gettext_lazy`)
- [ ] Formset/InlineFormset 에서 `management_form` 렌더 잊지 말기
- [ ] 파일 업로드: **크기/MIME/확장자** 다층 검증, Pillow로 이미지 확인

**ORM**
- [ ] `select_related` / `prefetch_related` 로 N+1 최소화
- [ ] `Q/F/Case/When/Subquery/Exists` 로 복잡 쿼리 선언적 표현
- [ ] 도메인 메서드는 **QuerySet 메서드**로 만들어 체이닝 가능하게
- [ ] 트랜잭션 경계, **`select_for_update`** 잠금, 재시도/타임아웃 전략

**마이그레이션**
- [ ] not-null 전환은 **단계적**(nullable 추가 → 백필 → not-null)
- [ ] 대용량 인덱스/ALTER 는 오프피크 + 온라인 옵션 고려
- [ ] 브랜치 병합 시 **merge migration** 으로 그래프 정합성 확보
- [ ] 데이터 마이그레이션은 **reversible** 하게 작성(가능하다면)

---

## F. 자주 묻는 질문(FAQ)

1) **ModelForm의 `save(commit=False)`는 언제 사용?**
→ 인스턴스를 만들되 DB에 아직 쓰지 않고, 뷰에서 추가 필드를 채운 뒤 `instance.save()` 하고 싶을 때.

```python
post = form.save(commit=False)
post.author = request.user
post.save()
form.save_m2m()  # M2M 필드는 save 후 별도 호출
```

2) **InlineFormset에서 자식 삭제가 안 되는 것 같아요**
→ 템플릿에 `{{ formset.management_form }}` 가 빠졌거나, `can_delete=True` 설정/`{{ f.DELETE }}` 렌더 누락.

3) **대용량 업로드/처리 병목**
→ 업로드 자체는 스토리지로 오프로드(서명 URL), 처리(썸네일/바이러스 스캔)는 **Celery** 같은 작업 큐로 비동기화.

4) **쿼리 느림**
→ `django-debug-toolbar` 로 N+1 검사, 필요한 관계는 `select_related/prefetch_related`, 인덱스 점검(`EXPLAIN`).

5) **마이그레이션 충돌 지옥**
→ 기능 단위로 PR를 작게, 자주 머지. 충돌 시 `makemigrations` 가 제안하는 merge migration 수용 후, 스키마 상충은 `AlterField` 등으로 조정.

---

## G. 추가 스니펫 모음

**G-1. 커스텀 유효성 검사기(validator)**
```python
# apps/common/validators.py

from django.core.exceptions import ValidationError

def validate_korean_name(value):
    if any(c.isdigit() for c in value):
        raise ValidationError("이름에 숫자가 포함될 수 없습니다.")
```

```python
# 모델/폼에서 사용

name = models.CharField(max_length=20, validators=[validate_korean_name])
```

**G-2. Unique 조건 + 필드 조합**
```python
class Enrollment(models.Model):
    student = models.ForeignKey("Student", on_delete=models.CASCADE)
    course = models.ForeignKey("Course", on_delete=models.CASCADE)
    semester = models.CharField(max_length=10)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["student", "course", "semester"], name="uniq_enrollment"
            )
        ]
```

**G-3. Window 함수 예시**
```python
from django.db.models import Window
from django.db.models.functions import Rank

qs = Product.objects.annotate(
    price_rank=Window(
        expression=Rank(),
        partition_by=[F("is_active")],
        order_by=F("price").desc(),
    )
)
```

**G-4. 조건부 업데이트 (경합 방지)**
```python
from django.db.models import F
updated = Product.objects.filter(pk=1, stock__gte=1).update(stock=F("stock") - 1)
if updated == 0:
    # 재고 부족 or 경합 실패
    ...
```

**G-5. RunSQL로 DB 전용 기능 사용(예: PG partial index)**
```python
from django.db import migrations

class Migration(migrations.Migration):
    dependencies = [("inventory", "0011_auto")]
    operations = [
        migrations.RunSQL(
            """
            CREATE INDEX CONCURRENTLY IF NOT EXISTS product_active_price_idx
            ON inventory_product (price)
            WHERE is_active = TRUE;
            """,
            reverse_sql="""
            DROP INDEX CONCURRENTLY IF EXISTS product_active_price_idx;
            """,
        )
    ]
```

---

## 마무리

이 문서에서는 **Form/ModelForm의 정석 검증 패턴**, **Formset/InlineFormset으로 묶음 입력**, **파일 업로드 보안·성능 포인트**를 실전 예제와 함께 다뤘습니다. 이어서 **ORM & 모델** 섹션에서는 **필드/옵션/관계 설계**, **쿼리셋 API(표현식/집계/서브쿼리/N+1 최적화)**, **커스텀 매니저/QuerySet** 으로 **도메인 친화** 코드를 작성하는 요령을 살폈고, 마지막으로 **마이그레이션**에서는 **데이터 마이그레이션/병합/스쿼시/무중단 전략**까지 실무 기준으로 정리했습니다.
