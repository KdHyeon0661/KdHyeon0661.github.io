---
layout: post
title: 데이터 통신 - Digital Transmission (5)
date: 2024-07-21 19:20:23 +0900
category: DataCommunication
---
# Delta Modulation (DM)

## 개요 — “레벨” 대신 “증분(Δ)”만 보낸다

PCM은 샘플 하나를 **n비트**로 부호화(예: 8/12/16bit)하지만, **DM(Delta Modulation)**은 **직전 복원값과의 차이 부호**만(보통 **1비트**) 전송합니다. 핵심은 “현재 샘플이 지난 샘플보다 **높은가/낮은가**”를 알려 주는 것입니다. 따라서 **오버샘플링**과 **스텝 크기(Δ)** 설계가 품질을 좌우합니다.

- 장점: 회로 단순(적분기 + 1비트 양자기), 1비트 스트림 → 구현/복원 간단.
- 한계: 신호 변화가 급하면 **기울기 포화(slope overload)**, 너무 미세하면 **과립 잡음(granular noise)**.

---

## DM 모듈레이터/디모듈레이터

### Modulator

스칼라 이산시간 표기로, 입력 \(x[n]\), 복원(예측)값 \(\hat{x}[n]\)이라 할 때:

1) **오차**: \(e[n] = x[n] - \hat{x}[n-1]\)
2) **부호 양자화(1비트)**:
\[
b[n] =
\begin{cases}
+1, & e[n] \ge 0 \\
-1, & e[n] < 0
\end{cases}
\]
3) **업데이트(적분기)**:
\[
\hat{x}[n] = \hat{x}[n-1] + b[n]\cdot \Delta
\]

여기서 \(\Delta\)는 **스텝 크기(델타)**.

### Demodulator

수신된 \(b[n]\)을 누적(적분)해 \(\hat{x}[n]\)을 만들고, 필요 시 **저역통과(LPF)**로 평활:

\[
\hat{x}[n] = \hat{x}[n-1] + b[n]\cdot \Delta \ \xrightarrow{\ \text{LPF}\ }\ y[n]
\]

---

## 설계 핵심 — Δ, 샘플율, 오차 조건

### 조건

한 샘플 간 최대 따라갈 수 있는 변화량은 \(\Delta\)입니다. 연속시간 입력 \(x(t)\)와 샘플 주기 \(T_s\)에서,

\[
|x(t+T_s)-x(t)| \le \Delta \ \ \Rightarrow\ \ \max |x'(t)| \cdot T_s \le \Delta
\]

정현파 \(x(t)=A\sin(2\pi f t)\)라면 \(\max|x'(t)|=2\pi f A\), 따라서
\[
2\pi f A \cdot T_s \le \Delta \quad\Rightarrow\quad \Delta \ge \frac{2\pi fA}{f_s}
\]
즉 **주파수/진폭이 높을수록**, 또는 **샘플율이 낮을수록** 더 큰 Δ가 필요합니다.

### Granular Noise(과립 잡음)

입력이 거의 평탄할 때도 DM은 **Δ 단위로 껑충껑충** 움직여서 **잔물결**이 생깁니다. 이를 줄이려면 Δ를 **작게** 잡아야 하는데, Δ가 작아지면 앞의 **slope overload**에 취약해집니다. **트레이드오프**입니다.

---

## — Δ를 “상황 적응”으로

**연속된 부호가 같은 방향**으로 오래 가면 Δ를 **키우고**, 부호가 **번갈아** 나오면 Δ를 **줄이는** 간단한 규칙으로 과립 잡음/기울기 포화를 동시 경감합니다.

예:
\[
\Delta[n+1] =
\begin{cases}
\alpha\cdot \Delta[n], & b[n]=b[n-1]\ (\text{같은 방향 지속})\\
\beta\cdot \Delta[n], & b[n]\neq b[n-1]\ (\text{지그재그})
\end{cases}
\]
보통 \(\alpha>1,\, 0<\beta<1\) (예: \(\alpha=1.5, \beta=0.6\)).

> 참고: **Δ-Σ(델타-시그마) 변조**는 다른 계열(노이즈 셰이핑)입니다. 여기서는 **순수 DM/ADM**에 집중합니다.

---

## DM vs PCM — 언제 유리한가?

- **동일 비트율**에서 **PCM**은 양자화 단계가 훨씬 촘촘하여 **정적 SNR**이 유리한 경우가 많습니다.
- **1비트 + 높은 오버샘플링**·**적응 Δ**·**저역통과 복원** 조건에서는 **저주파(음성 등)**에서 DM/ADM이 **저비용/저복잡** 이점을 줄 수 있습니다.
- 결론적으로 “DM의 양자화 에러가 PCM보다 항상 적다”는 일반화는 **부정확**합니다. **비트 예산, 스펙트럼, 오버샘플링 비, Δ 적응**을 포함한 **전체 설계**에 달려 있습니다.

---

## 파이썬 시뮬 — DM/ADM 인코딩·복원·오차 비교

```python
import numpy as np

def dm_encode(x, Delta=0.05):
    """단순 DM: 1비트 부호와 누적 복원값 반환"""
    n = len(x)
    bhat = np.zeros(n, dtype=int)  # {-1,+1}
    y = np.zeros(n)                # 재구성
    for i in range(1, n):
        e = x[i] - y[i-1]
        bhat[i] = 1 if e >= 0 else -1
        y[i] = y[i-1] + bhat[i]*Delta
    return bhat, y

def adm_encode(x, Delta0=0.01, alpha=1.5, beta=0.6, Dmin=1e-5, Dmax=1.0):
    """적응 DM: Δ를 방향 지속성에 따라 증감"""
    n = len(x)
    bhat = np.zeros(n, dtype=int)
    y = np.zeros(n)
    Delta = Delta0
    for i in range(1, n):
        e = x[i] - y[i-1]
        b = 1 if e >= 0 else -1
        bhat[i] = b
        # Δ 갱신
        if bhat[i] == bhat[i-1]:  # 같은 방향 지속
            Delta = min(Dmax, Delta*alpha)
        else:                     # 지그재그
            Delta = max(Dmin, Delta*beta)
        y[i] = y[i-1] + b*Delta
    return bhat, y

def nmse_db(x, xr):
    mse = np.mean((x-xr)**2)
    pwr = np.mean(x**2)+1e-18
    return 10*np.log10(mse/pwr+1e-18), mse

# 테스트: 저주파+급격변화 혼합 파형

fs = 96000
t = np.arange(0, 0.05, 1/fs)
x = 0.6*np.sin(2*np.pi*800*t)              # 800 Hz
x += 0.3*np.sin(2*np.pi*2000*t)            # 2 kHz
x += (t>0.025)*0.3*(np.sin(2*np.pi*6000*t))# 6 kHz (절반 구간 급격 변화)

b_dm, y_dm = dm_encode(x, Delta=0.01)
b_adm, y_adm = adm_encode(x, Delta0=0.005, alpha=1.6, beta=0.5)

e_dm_db, _  = nmse_db(x, y_dm)
e_adm_db, _ = nmse_db(x, y_adm)

print("DM   NMSE(dB):", round(e_dm_db,2))
print("ADM  NMSE(dB):", round(e_adm_db,2))
print("Avg Δ 효과: ADM이 급변구간 추적 개선 및 평탄 구간 과립 저감 기대")
```

- 관찰 포인트:
  - Δ가 **너무 작으면** → **slope overload**(급격 변화 시 추종 실패).
  - Δ가 **너무 크면** → **granular noise**(평탄 구간에서 톱니).
  - **ADM**은 두 구간을 **적응 Δ**로 타협.

---

## 체크 문제

1) 정현파 \(A\sin(2\pi f t)\)를 DM으로 전송할 때 slope overload를 피하려면 \(f_s, \Delta\) 사이에 어떤 부등식이 성립해야 하는가?
2) ADM에서 \(\alpha,\beta\)를 너무 크게/작게 잡을 때 각각 어떤 부작용이 생기는가?
3) 1비트 DM 스트림의 **유효 비트율**은 무엇과 비례하며, 복원 품질에 어떤 영향을 주는가?

---

# Transmission Mode

## 개요

**병렬(Parallel)** vs **직렬(Serial)**, 그리고 **비동기/동기/등시성**은 **물리적 선로 비용, 거리, 타이밍, 지터 허용도** 등의 관점에서 선택됩니다.

---

## Parallel Transmission (병렬)

- **n개 비트**를 **n개 선로**로 동시 전송.
- **장점**: 짧은 거리에서 **높은 유효 처리량**, 단순 수신(복잡한 클럭 복원이 덜 필요).
- **한계**:
  - **스큐(skew)**: 각 라인 지연이 조금씩 달라 **워드 정렬** 문제가 생김.
  - **EMI/크로스토크** 증가, **케이블/커넥터 비용** 큼.
  - 거리↑·속도↑일수록 동기 맞추기 어려워 **고속·장거리**에는 **직렬**이 대세.
- **실전 예**: 칩 내부/보드 내부 버스, 과거 프린터 패러렐, (현대는 대부분 고속 직렬로 대체: PCIe/USB/DisplayPort 등).

---

## Serial Transmission (직렬)

- **한 선로**로 **비트 시퀀스**를 나열 전송.
- **장점**: 선로 비용↓, 장거리 적합, 차동 전송/라인코딩으로 **EMI 억제**, **CDR** 기술 발달로 초고속화.
- **실전 라인코딩**: NRZ/NRZ-I + 스크램블, 8b/10b, 64b/66b, PAM-4 등.
- **멀티레벨 코드(2B1Q, 8B6T, 4D-PAM5)**는 **케이블/대역/SNR/복잡도** 타협으로 주로 **근거리/특정 표준**에서 사용. 광/장거리 코어망은 **다른 변조·코딩** 조합을 사용(예: PAM-4, QAM 변조 + FEC).

---

## Asynchronous Serial (비동기 직렬: UART 스타일)

- **문자 단위 프레이밍**: **Start(0)** → **Data(5~8bit)** → **Parity(옵션)** → **Stop(1, 1.5, 2bit)**.
- 송수신 클럭은 **근사 동기**(오차 허용), **스타트 가장자리**를 기준으로 샘플링 타이밍 재정렬.
- **간격(gap)** 허용: 프레임 간 유휴 상태는 ‘1’(마크).

### 계산

예) **8N1 @ 115,200 bps**
- 1 start + 8 data + 1 stop = **10비트/문자** → **유효 80%**(패리티 없음).
- **순수 데이터 처리량**: \(115{,}200 \times 0.8 \approx 92.16\ \text{kbps}\).

```python
def uart_efficiency(data_bits=8, parity='N', stop_bits=1):
    start = 1
    parity_bits = 0 if parity.upper()=='N' else 1
    frame = start + data_bits + parity_bits + stop_bits
    return data_bits / frame

print("8N1 효율:", uart_efficiency(8,'N',1))  # 0.8
print("7E1 효율:", uart_efficiency(7,'E',1))  # 7/9 ≈ 0.777...
```

- 장점: **저가/간단**, 링크가 **간헐적 트래픽**일 때 유리.
- 한계: 프레임당 오버헤드, 고속/대용량에는 비효율.

---

## Synchronous Serial (동기 직렬)

- **블록(프레임) 단위**로 전송, **클럭 동기**는 별도 라인 또는 **데이터 내 전이 패턴**으로 **CDR**(PLL/디지털 CDR)이 복원.
- **라인코딩/블록코딩**(예: 4B/5B+NRZ-I, 8b/10b, 64b/66b)로 **전이 밀도/런 길이/DC 균형**을 관리.
- **바이트/비트 지향 프로토콜**:
  - **바이트 지향**: 프레임 헤더/길이/체크(예: HDLC의 상위 변형들은 주소/제어/정보/CRC).
  - **비트 지향(HDLC)**: **플래그 0x7E(01111110)**로 프레임 경계, **비트 스터핑**으로 데이터 내 ‘011111’ 다음엔 ‘0’ 삽입 → 경계 혼동 방지.
- **프리엠블/동기**: 예) 이더넷(10/100BASE-T) **프리엠블 7바이트 + SFD 1바이트**로 수신 동기 확보.

### 효율 예시 — 100BASE-TX 파이프라인(요약)

- **4B/5B**로 **전이 밀도** 보장 → **NRZ-I** → **MLT-3**로 **주파수 성분 낮춤**(EMI/대역 유리).
- 100 Mbps 데이터 → 4B/5B 오버헤드로 **125 MBd**, MLT-3로 라인 최고 전이 약 **31.25 MHz** 수준.

---

## Isochronous (등시성)

- **지터/간헐적 지연**에 민감한 **오디오/비디오/실시간** 스트림에 초점.
- **균등한 시간 간격**으로 페이로드를 제공하도록 **스케줄링/버퍼링**. **손실 몇 비트 허용**·**지연 변화 최소화**가 목표(반대로 파일전송은 손실 금지/지연 덜 민감).

### 지터와 버퍼

- **버퍼 깊이** \(B\)가 있을 때, **지터**(도착간격 편차) \(\sigma_\tau\)와 **평균 지연** \(D\)를 트레이드오프:
  - 버퍼를 크게 잡으면 재생은 안정(지터 흡수)하나 지연↑.
  - 작으면 지연↓, 프리언더런(underrun) 위험↑.
- **간단 지터 예**: 송신 간격 \(T\), 도착 간격 \(T+\epsilon_n\) (평균 0, 분산 \(\sigma_\tau^2\)).
  - **플레이아웃 타임스탬프**를 \(D\)만큼 뒤에서 재생하면, \(D\)가 충분히 크면 Underrun 확률 \(\downarrow\).

---

## 직렬/병렬·동기/비동기 선택 가이드

| 상황 | 권장 모드 | 근거 |
|---|---|---|
| 보드 내부 짧은 거리, 하위 MHz | 병렬 또는 저속 직렬 | 라우팅 쉬움, 비용↓, 스큐 제어 가능 |
| 수 미터 이상, 수십~수백 Mbps | 동기 직렬 + 라인코딩 | CDR/EMI/대역·BER 관리 |
| 낮은 속도, 간헐 데이터, MCU↔모듈 | 비동기 직렬(UART) | HW 단순/저가 |
| 오디오/비디오 실시간 | 등시성 채널(isochronous) | 지터 제한/주기적 슬롯 |
| UTP 상 100M/1G/10G 이더넷 | 동기 직렬 + (4B/5B, 8b/10b, 64b/66b, PAM-4 등) | 표준화된 PHY/코딩 |

---

## 미니 계산·시나리오

### 시나리오 1 — UART 설정과 유효 처리량

- 요구: 센서 데이터 9.6 kB/s 연속 전송. UART 115,200 bps, **8E1**(패리티 포함) 사용.
- 프레임: 1(start)+8(data)+1(parity)+1(stop)=**11비트/바이트** → 효율 \(=8/11\approx 72.7\%\).
- 유효 처리량: \(115{,}200\times 0.727 \approx 83.8\ \text{kbps}\approx 10.5\ \text{kB/s}\). **충분**.

### 시나리오 2 — 동기 직렬·프레임 오버헤드

- 1500B 페이로드에 프리엠블/헤더/CRC/IFG 오버헤드가 40B라면 효율 \(=1500/(1540)\approx 97.4\%\).
- 블록코딩(예: 8b/10b)까지 고려 시 **라인 보율 상승**을 감안하여 링크 예산 수립.

---

## 추가 구현 팁

- **CDR 안정**: 블록코딩/스크램블로 **전이 밀도 확보**, 런 길이 제한.
- **DC 균형**: 차동 전송 + **balanced code**(8b/10b의 running disparity 관리 등).
- **EMI/스펙트럼**: MLT-3/스크램블로 고주파 성분 저감, 방사 규격 여유 확보.
- **에러 제어**: CRC/FEC/ARQ 필요 수준 결정(대역·지연 제약과 함께).

---

## 체크 문제

1) 병렬 전송의 **스큐** 문제는 왜 거리/속도 증가에 비례해 심각해지는가? PCB·케이블에서 어떤 물리적 요인이 작용하는가?
2) HDLC의 **비트 스터핑** 규칙을 간단히 설명하고, 수신 측이 어떻게 **역-스터핑** 하는지 서술하라.
3) **8N1 @ 921,600 bps**에서 유효 데이터 처리량(kB/s)을 계산하라.
4) 등시성 스트리밍에서 **플레이아웃 지연 D**를 줄이면 어떤 위험이 증가하는가?
5) 100BASE-TX에서 **4B/5B + NRZ-I + MLT-3**를 사용하는 이유를, **CDR·DC·EMI·대역** 관점에서 한 줄씩 요약하라.

---

## 핵심 요약

- **DM/ADM**: 1비트 증분 전송, \(\Delta\)·오버샘플링 설계가 품질 결정. **slope overload vs granular noise**의 균형이 관건.
- **직렬이 장거리 표준**: 라인코딩/블록코딩/스크램블로 **전이·DC·EMI**를 제어, **CDR**을 안정화.
- **비동기(UART)**: 프레이밍 간단/오버헤드 존재, **간헐·저속**에 적합.
- **동기**: **프레임 단위**, 고속·대용량, **효율↑**.
- **등시성**: 지터 제한이 핵심, **버퍼와 지연**의 트레이드오프.
