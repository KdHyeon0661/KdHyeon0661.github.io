---
layout: post
title: 컴퓨터시스템 - 공유 변수
date: 2025-09-10 20:20:23 +0900
category: 컴퓨터시스템
---
# 쓰레드 프로그램에서의 **공유 변수(Shared Variables)** — 정확성·성능·안전성 완전 가이드

> 형식: 이 문서는 전체를 `~~~markdown`으로 감싸고, **코드/명령은 모두 ```** 로 표기합니다.  
> 대상: C/pthreads + C11 원자 연산을 중심으로 설명하되, 일반 원칙은 대부분 언어에 공통 적용됩니다.

---

## 1) 공유 변수란? 왜 어려울까

- **공유 변수**: 한 프로세스의 동일 **주소공간**을 사용하는 여러 쓰레드가 **같은 메모리 위치**를 읽고/쓰기 하는 변수.
- 어려운 이유
  1. **데이터 레이스(data race)**: 동기화 없이 동시에 접근(최소 한쪽이 쓰기) → **정의되지 않은 동작(UB)**  
  2. **가시성(visibility)**: 한 코어의 쓰기가 다른 코어에 **언제 보이는가**  
  3. **순서(ordering)**: 컴파일러/CPU의 **재배치(reordering)**로 기대한 실행 순서가 깨질 수 있음  
  4. **성능 함정**: 캐시 일관성 트래픽, **거짓 공유(false sharing)**

---

## 2) 필수 개념 요약

### 2.1 원자성·가시성·순서
- **원자성(Atomicity)**: 연산이 중간 상태 없이 “한 번에” 일어난 것처럼 보임.
- **가시성(Visibility)**: 한 쓰레드의 쓰기가 **다른 쓰레드에 관측**되는 시점.
- **순서(Ordering)**: 프로그램적 순서 ↔ 실제 실행/관측 순서의 일치 보장.

### 2.2 happens-before 관계
- “A happens-before B”이면, **A의 쓰기는 B에서 반드시 보임**.
- C/pthreads에서 **락(lock) 해제 → 락 획득**, **조건변수 signal → wait 반환**, **atomic release → atomic acquire**가 대표적인 **happens-before** 엣지들.

### 2.3 C11 원자(Atomic)와 메모리 오더
- `<stdatomic.h>`: `_Atomic`, `atomic_*` API.
- 메모리 오더(강→약): `seq_cst` > `acq_rel`(acquire/release) > `relaxed`.
  - **release store** + **acquire load** 조합 → 쓰기-읽기 가시성 보장.
  - `relaxed`는 **원자성만** 보장(순서/가시성 보장 X).

---

## 3) “잘못된” 공유 변수 접근 예와 수정

### 3.1 데이터 레이스 예
```c
// BAD: 동기화 없음
int flag = 0;
void* t1(void*) { flag = 1; return NULL; }
void* t2(void*) { while (!flag) { /* spin */ } /* ... */ return NULL; }
```
- 문제: `t2`가 `flag` 변경을 **관측 못할 수도** 있고, 컴파일러가 루프를 최적화해 **무한 루프**가 될 수 있음.

#### 수정 1) 뮤텍스
```c
#include <pthread.h>
int flag = 0;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

void* t1(void*) { pthread_mutex_lock(&m); flag = 1; pthread_mutex_unlock(&m); return NULL; }
void* t2(void*) { for(;;){ pthread_mutex_lock(&m); int f=flag; pthread_mutex_unlock(&m); if (f) break; } return NULL; }
```

#### 수정 2) C11 원자 + acquire/release
```c
#include <stdatomic.h>
atomic_int flag = 0;
void* t1(void*) { atomic_store_explicit(&flag, 1, memory_order_release); return NULL; }
void* t2(void*) { while (!atomic_load_explicit(&flag, memory_order_acquire)) {} return NULL; }
```

> 실전 팁: 바쁜 대기(spin)는 짧은 임계/즉시 완료 이벤트에 한정. 보통은 **조건변수**로 대기/깨움을 구성.

---

## 4) 공유 변수를 안전하게 설계하는 5가지 방법

1) **불변(Immutable)으로 만들기**  
   - 초기화 후 **절대 수정하지 않는 값**: 락/원자 불필요, 읽기 경합 없음.  
   - 예: 구성 테이블, 룩업 테이블(빌드 후 read-only)

2) **소유권(Ownership) 부여**  
   - 쓰기는 오직 “소유자 쓰레드”만, 다른 쓰레드는 읽기만 → **경합/락 비용 최소화**.  
   - 소유권 변경 시 **메시지 전달(큐)** 로 handoff.

3) **메시지 패싱(Queues) 우선**  
   - 공유 변수 대신 **MPMC 큐**(락/락프리)에 메시지를 보냄.  
   - **데이터 복제**가 안전성과 구조 단순화에 종종 더 싸다.

4) **복사-갱신( Copy-On-Write / RCU )**  
   - 쓰는 쪽은 새 사본을 만들고 포인터 한 번에 교체(atomic `store release`).  
   - 읽는 쪽은 acquire load로 포인터 읽기 → 레이턴시/락 프리.

5) **락의 범위를 줄여라**  
   - **미세 락(fine-grained)**, **읽기-쓰기 락**, **샤딩(sharding)**, **퍼-코어 데이터**로 경합 감소.

---

## 5) 동기화 도구별 공유 변수 패턴

### 5.1 뮤텍스 + 조건변수 (정석)
- **불변식**: 조건변수는 **“상태(predicate)”**를 기다릴 때 사용. **항상 `while`**로 보호.
```c
// 큐가 비면 소비자는 기다리고, 생산자가 넣으면 깨움
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  cv = PTHREAD_COND_INITIALIZER;

int q[16], head, tail, cnt;

void put(int x){
  pthread_mutex_lock(&m);
  while (cnt==16) pthread_cond_wait(&cv, &m);
  q[tail]=x; tail=(tail+1)&15; cnt++;
  pthread_cond_signal(&cv);
  pthread_mutex_unlock(&m);
}
int get(void){
  pthread_mutex_lock(&m);
  while (cnt==0) pthread_cond_wait(&cv, &m);
  int x=q[head]; head=(head+1)&15; cnt--;
  pthread_cond_signal(&cv);
  pthread_mutex_unlock(&m);
  return x;
}
```

### 5.2 C11 원자 (카운터·플래그·인덱스)
```c
#include <stdatomic.h>
atomic_long counter = 0;
void inc(){ atomic_fetch_add_explicit(&counter, 1, memory_order_relaxed); }
long read_counter(){ return atomic_load_explicit(&counter, memory_order_relaxed); }
```
- `relaxed` 카운터: 통계/모니터링처럼 **순서/동기화 필요 없는** 사용에 적합. 결과의 “실시간 정확”은 보장 X.

### 5.3 RCU 스타일 포인터 스왑
```c
#include <stdatomic.h>
typedef struct table table_t;
_Atomic(table_t*) tbl;

void publish_new(table_t* t_new){
  atomic_store_explicit(&tbl, t_new, memory_order_release);
}
table_t* acquire_tbl(void){
  return atomic_load_explicit(&tbl, memory_order_acquire);
}
```
- 쓰는 쪽이 **새 구조**를 만든 뒤 **포인터 한 번**에 교체.
- 수거(garbage) 문제는 epoch/참조 카운팅/해저드 포인터 등 별도 기법 필요.

### 5.4 읽기-쓰기 락 (읽기 다수/쓰기 드묾)
```c
pthread_rwlock_t rw = PTHREAD_RWLOCK_INITIALIZER;
/* reader */ pthread_rwlock_rdlock(&rw); /* read shared vars */ pthread_rwlock_unlock(&rw);
/* writer */ pthread_rwlock_wrlock(&rw); /* write shared vars */ pthread_rwlock_unlock(&rw);
```

---

## 6) 메모리 모델·재배치 함정과 **`volatile` 오해**

- **컴파일러/CPU 재배치**: 독립 메모리 접근은 성능 위해 순서가 바뀔 수 있음.
- **`volatile`는 동기화가 아니다**  
  - 목적: **메모리 매핑 I/O**, 신호 핸들러와의 상호작용 등 *최적화 금지* 힌트.  
  - **스레드 간 가시성/순서 보장 X** → 반드시 **락/원자**를 사용.

---

## 7) 캐시 일관성과 **거짓 공유(False Sharing)**

- 여러 쓰레드가 서로 다른 변수를 쓰더라도 **같은 캐시라인(보통 64B)** 에 있으면 쓰기마다 **라인 무효화**가 발생 → 성능 급락.
- 해결:
  - **패딩/정렬**: 변수 사이에 64B 패딩
  - **퍼-코어 구조**: 코어별 카운터 후 집계(reduce)

```c
#include <stdalign.h>
#define CL 64
typedef struct { alignas(CL) long v; char pad[CL-sizeof(long)]; } padded_t;
padded_t per_core[128]; // 충분히 띄워서 배치
```

---

## 8) 병행 컨테이너·알고리즘에서의 공유 변수

- **Lock-free** 구조: 원자적 CAS(Compare-And-Swap)로 포인터/카운터 갱신, **ABA 문제**를 태그/스탬프/해저드 포인터로 해결.
- **분할(Sharding)**: 키 해시 기반으로 여러 버킷/락에 분산 → 각 락에서 보호하는 **공유 변수 집합**을 작게.
- **핫 스팟** 피하기: 중앙 전역 맵/리스트 대신 **지역 큐 + 워크 스틸링(work-stealing)**.

---

## 9) 실용 예제 모음

### 9.1 플래그 + 페이로드(원자적 순서 보장)
```c
#include <stdatomic.h>
typedef struct { atomic_int ready; int data; } slot_t;
void producer(slot_t* s){
  s->data = 123; // 일반 쓰기
  atomic_store_explicit(&s->ready, 1, memory_order_release);
}
int consumer(slot_t* s){
  while(!atomic_load_explicit(&s->ready, memory_order_acquire)) {}
  return s->data; // 123이 보장됨(happens-before)
}
```

### 9.2 단순 통계 카운터(경합 완화: 퍼-쓰레드 후 집계)
```c
#include <stdatomic.h>
_Atomic long global_sum = 0;
__thread long local_sum = 0; // TLS: 각 쓰레드 전용

void add(int x){
  local_sum += x;
  if ((local_sum & 0xFFFF) == 0) { // 임계치마다 전역에 반영
    atomic_fetch_add_explicit(&global_sum, local_sum, memory_order_relaxed);
    local_sum = 0;
  }
}
long snapshot(){
  return atomic_load_explicit(&global_sum, memory_order_relaxed);
}
```

### 9.3 더블체크 초기화(Double-Checked Locking, 올바른 버전)
```c
#include <stdatomic.h>
#include <pthread.h>
typedef struct config config_t;
_Atomic(config_t*) g_cfg = NULL;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

config_t* get_cfg(){
  config_t* p = atomic_load_explicit(&g_cfg, memory_order_acquire);
  if (!p) {
    pthread_mutex_lock(&m);
    p = atomic_load_explicit(&g_cfg, memory_order_acquire);
    if (!p) {
      config_t* newp = /* allocate & init */;
      atomic_store_explicit(&g_cfg, newp, memory_order_release);
      p = newp;
    }
    pthread_mutex_unlock(&m);
  }
  return p;
}
```

---

## 10) 테스트·디버깅·검증

- **ThreadSanitizer(TSan)**: 데이터 레이스 탐지(Clang/GCC `-fsanitize=thread`).
- **Helgrind/DRD(Valgrind)**: 락 순서/레이스 분석.
- **디버깅 팁**
  - **로그에 쓰레드 ID** 포함(`pthread_self()`/`gettid()`).
  - **시간·순서 의존 버그** 재현 위해 **난수 sleep/스케줄 요동** 주기.
  - **락 순서 규약**을 문서화하고 단위 테스트에서 강제.

---

## 11) 체크리스트 (현업용)

- [ ] 공유 변수에 **락/원자/조건** 없이 접근하지 않는다(데이터 레이스 금지).  
- [ ] **happens-before**를 만드는 지점(락 해제/획득, atomic acq/rel)을 명확히 설계.  
- [ ] 플래그/레디 신호는 **release-store / acquire-load**로 구현.  
- [ ] **조건변수는 while** 루프로 상태 재확인.  
- [ ] 통계/모니터링 값은 `relaxed` 원자 또는 **퍼-쓰레드 누적** 후 집계.  
- [ ] **거짓 공유** 방지(패딩/정렬/퍼-코어 데이터).  
- [ ] 전역 컨테이너는 **샤딩** 또는 **워크 스틸링**으로 핫스팟 분산.  
- [ ] `volatile`를 **동기화 수단으로 쓰지 않는다**.  
- [ ] lock-free/RCU를 도입할 땐 **ABA/수거 전략**까지 함께 설계.  
- [ ] 테스트는 TSan/Helgrind로 **레이스 없는지** 먼저 확인.

---

## 12) 한 줄 결론
공유 변수는 **정확성(레이스 없음) → 가시성/순서 보장 → 성능(경합·거짓 공유 최소화)** 순서로 설계하세요.  
락/조건/원자, 그리고 **happens-before** 규칙을 정확히 사용하면, 복잡한 동시성 코드에서도 **예측 가능하고 빠른** 동작을 얻을 수 있습니다.