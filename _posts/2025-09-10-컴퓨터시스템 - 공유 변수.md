---
layout: post
title: 컴퓨터시스템 - 공유 변수
date: 2025-09-10 20:20:23 +0900
category: 컴퓨터시스템
---
# 쓰레드 프로그램에서의 **공유 변수(Shared Variables)**

## 0) 한눈에 보는 의사결정 표

| 목적/상황 | 권장 패턴 | 핵심 이유/주의 |
|---|---|---|
| **읽기만 많은 전역 설정** | **불변(Immutable)** + 포인터 교체 | 락 필요↓. 교체는 release-store / acquire-load |
| **플래그/레디 신호** | `atomic<bool>` + **release → acquire** | 순서/가시성 보장 |
| **단순 카운터/통계** | `atomic_fetch_add`(`relaxed`) + **per-thread 누적 후 집계** | 경합↓, 정확도 vs 지연 trade-off |
| **SP/SC 큐**(싱글 생산/싱글 소비) | lock-free 링버퍼 | `head/tail` 분리, false sharing 패딩 |
| **MP/MC 큐**(여러 생산/여러 소비) | 뮤텍스+조건변수 or 검증된 큐 라이브러리 | 설계 난이도↓, 정확성↑ |
| **읽기 압도적** | **RW락** 또는 **RCU/Copy-on-Write** | 읽기 동시성↑ |
| **긴 임계구역 + 혼합 작업** | **샤딩**(per-core 데이터) + 마지막에 reduction | 락 경합/캐시 무효화↓ |
| **Lock-free 자료구조** | CAS + **ABA/Hazard/Epoch** | 메모리 재활용 안전성 필수 |
| **I/O 이벤트 연계 플래그** | `atomic` + **fence/seq_cst**(필요 시) | 외부 장치/신호와 순서 정합 |

---

## 1) 공유 변수란? 왜 어려운가

- **공유 변수**: 같은 프로세스의 **공유 주소공간**을 쓰는 여러 쓰레드가 **동일 메모리 위치**에 접근하는 변수.
- 어려운 이유 (요약):
  1) **데이터 레이스**: 동기화 없이 동시 접근(최소 한쪽 쓰기) → **UB(Undefined Behavior)**
  2) **가시성**: 한 코어의 쓰기가 언제/어떻게 다른 코어에서 보이는가
  3) **순서**: 컴파일러/CPU의 **재배치**로 의도한 순서가 깨질 수 있음
  4) **성능 함정**: 캐시 일관성 트래픽, **거짓 공유(false sharing)**, NUMA

---

## 2) 메모리 모델 필수 개념

### 2.1 원자성·가시성·순서
- **원자성(Atomicity)**: 중간 상태 없이 “한 번에”.
- **가시성(Visibility)**: 쓰기가 다른 쓰레드에서 관측되는 보장.
- **순서(Ordering)**: 프로그램 순서와 관측 순서의 일치.

### 2.2 happens-before (HB)
- “A HB B”라면 A의 쓰기는 B에서 **반드시** 보인다.
- 대표 HB 엣지
  - **락 해제 → 같은 락 획득**
  - **조건변수 signal/broadcast → wait 반환(동일 락 보호 하에서)**
  - **atomic release-store → atomic acquire-load**
  - **스레드 생성 전 준비 → `pthread_create` 후 새 스레드 시작점**(구현 정의 HB 존재)

### 2.3 C11 원자와 메모리 오더
- `<stdatomic.h>`: `_Atomic(T)` / `atomic_*`.
- 오더(강→약): `memory_order_seq_cst` > `acq_rel`(acquire/release) > `relaxed`.
  - **release-store** + **acquire-load**: 쓰기-읽기 **가시성/순서** 확보.
  - **relaxed**: 원자성만 보장(순서/가시성 보장 X). 통계/모니터링에 적합.
- **consume**는 최적화/이식성 문제로 실무 비권장(사실상 acquire로 취급).

### 2.4 페ンス
- `atomic_thread_fence(order)`: 명시적 메모리 장벽.
- 실무 권장: **데이터와 함께 하는 원자 연산**으로 충분히 모델링하고, **페ンス는 예외적 상황**(다중 위치 조합 최적화 등)에서만.

---

## 3) “잘못된” 접근과 수정

### 3.1 레디 플래그(나쁜 예 → 좋은 예)

```c
// BAD: 데이터 레이스 + 무한 루프 위험
int ready = 0;
void* t1(void*) { ready = 1; return NULL; }
void* t2(void*) { while (!ready) {} /* ... */ return NULL; }
```

```c
// GOOD #1: 뮤텍스 (정석)
#include <pthread.h>
int ready = 0; pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
void* t1(void*){ pthread_mutex_lock(&m); ready=1; pthread_mutex_unlock(&m); return NULL; }
void* t2(void*){ for(;;){ pthread_mutex_lock(&m); int r=ready; pthread_mutex_unlock(&m); if(r) break; } return NULL; }
```

```c
// GOOD #2: C11 원자 + acq/rel
#include <stdatomic.h>
atomic_int ready = 0;
void* t1(void*){ atomic_store_explicit(&ready, 1, memory_order_release); return NULL; }
void* t2(void*){ while(!atomic_load_explicit(&ready, memory_order_acquire)) {} return NULL; }
```

> **실무 팁**: 바쁜대기(spin)는 **아주 짧은 임계**에서만. 보통은 **조건변수**가 낫다.

---

## 4) 공유 변수를 줄이는 5가지 아키텍처

1) **불변(Immutable)**
   - 초기화 후 **절대 수정 X**. 락 불필요, 캐시 트래픽↓.
   - 예: 설정 테이블, 라우팅 테이블 스냅샷.

2) **소유권(Ownership)**
   - **쓰기는 오직 소유자 스레드**, 타 스레드는 읽기만.
   - 소유권 이전은 **메시지 큐**로 hand-off.

3) **메시지 패싱(Actor/CSP)**
   - 공유 대신 전달(복제). 종종 **복제가 더 싸다**.

4) **Copy-on-Write / RCU**
   - 쓰는 쪽: 새 사본 구성 → 포인터 한 번에 교체(release).
   - 읽는 쪽: acquire로 포인터 읽기 → 락 프리.

5) **샤딩(sharding)**
   - 전역을 N개 **부분 상태**로 나눠 락/경합/캐시 무효화 감소. 마지막에 **reduction**.

---

## 5) 동기화 도구별 패턴

### 5.1 뮤텍스 + 조건변수 (정석)

```c
#include <pthread.h>

#define QN 16
int q[QN], head, tail, cnt;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  cv_not_full  = PTHREAD_COND_INITIALIZER;
pthread_cond_t  cv_not_empty = PTHREAD_COND_INITIALIZER;

void put(int x){
  pthread_mutex_lock(&m);
  while (cnt==QN) pthread_cond_wait(&cv_not_full, &m);
  q[tail]=x; tail=(tail+1)%QN; cnt++;
  pthread_cond_signal(&cv_not_empty);
  pthread_mutex_unlock(&m);
}
int get(void){
  pthread_mutex_lock(&m);
  while (cnt==0) pthread_cond_wait(&cv_not_empty, &m);
  int x=q[head]; head=(head+1)%QN; cnt--;
  pthread_cond_signal(&cv_not_full);
  pthread_mutex_unlock(&m);
  return x;
}
```

- **항상 `while`**: 스퍼리어스 웨이크업·유실신호 방지.
- 한정 큐 → **백프레셔** 자연 구현.

### 5.2 C11 원자(카운터/플래그/인덱스)

```c
#include <stdatomic.h>
atomic_long cnt = 0;
void add1(){ atomic_fetch_add_explicit(&cnt, 1, memory_order_relaxed); }
long snapshot(){ return atomic_load_explicit(&cnt, memory_order_relaxed); }
```

- 통계/모니터링: **relaxed**로 충분(정확 시점은 비결정).
- 강한 순서 필요 시 `acq/rel` 또는 `seq_cst`.

### 5.3 포인터 발행(Release/Acquire)

```c
#include <stdatomic.h>
typedef struct table table_t;
_Atomic(table_t*) g_tbl = NULL;

void publish(table_t* nt){
  atomic_store_explicit(&g_tbl, nt, memory_order_release);
}
table_t* acquire_tbl(){
  return atomic_load_explicit(&g_tbl, memory_order_acquire);
}
```

- **가시성**: 교체 이전의 모든 쓰기가 독자에게 보장.

### 5.4 읽기-쓰기 락

```c
pthread_rwlock_t rw = PTHREAD_RWLOCK_INITIALIZER;
// reader
pthread_rwlock_rdlock(&rw);
// ... read shared ...
pthread_rwlock_unlock(&rw);
// writer
pthread_rwlock_wrlock(&rw);
// ... write shared ...
pthread_rwlock_unlock(&rw);
```

- 읽기 다수/쓰기 드묾: 파인 그레인 RW락 또는 **RCU** 고려.

---

## 6) 링 버퍼(싱글 생산/싱글 소비, SP/SC)

> 간결하고 빠른 **lock-free** 예. 핵심은 **head/tail 분리**, **패딩으로 false sharing 방지**.

```c
#include <stdatomic.h>
#include <stddef.h>
#include <stdint.h>

#define N (1u<<12) // 4096
#define MASK (N-1)

typedef struct {
  alignas(64) _Atomic uint32_t head;
  char _pad1[64 - sizeof(_Atomic uint32_t)];
  alignas(64) _Atomic uint32_t tail;
  char _pad2[64 - sizeof(_Atomic uint32_t)];
  int buf[N];
} spscq;

int spsc_push(spscq* q, int v){
  uint32_t t = atomic_load_explicit(&q->tail, memory_order_relaxed);
  uint32_t h = atomic_load_explicit(&q->head, memory_order_acquire);
  if (((t+1)&MASK) == (h&MASK)) return 0; // full
  q->buf[t & MASK] = v;
  atomic_store_explicit(&q->tail, t+1, memory_order_release);
  return 1;
}
int spsc_pop(spscq* q, int* out){
  uint32_t h = atomic_load_explicit(&q->head, memory_order_relaxed);
  uint32_t t = atomic_load_explicit(&q->tail, memory_order_acquire);
  if ((h&MASK) == (t&MASK)) return 0; // empty
  *out = q->buf[h & MASK];
  atomic_store_explicit(&q->head, h+1, memory_order_release);
  return 1;
}
```

- 생산자는 **tail**만, 소비자는 **head**만 갱신 → 레이스 없음.
- **acquire/release**로 슬롯 내용 가시성 확보.
- **패딩**: head/tail을 다른 캐시라인에 고정(거짓 공유 방지).

---

## 7) 더블 체크드 로킹(DCLP): 올바른 버전

```c
#include <stdatomic.h>
#include <pthread.h>

typedef struct cfg cfg_t;
_Atomic(cfg_t*) g = NULL;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

cfg_t* get_cfg(){
  cfg_t* p = atomic_load_explicit(&g, memory_order_acquire);
  if (!p){
    pthread_mutex_lock(&m);
    p = atomic_load_explicit(&g, memory_order_acquire);
    if (!p){
      cfg_t* n = /* allocate+initialize */;
      atomic_store_explicit(&g, n, memory_order_release);
      p = n;
    }
    pthread_mutex_unlock(&m);
  }
  return p;
}
```

- **핵심**: 포인터 발행에 **release-store / acquire-load**를 써야 **부분 초기화 관측**을 막는다.

---

## 8) 거짓 공유(False Sharing)와 캐시라인

- **문제**: 서로 다른 변수가 **같은 캐시라인(보통 64B)** 에 있어 서로의 쓰기가 **무효화**를 유발 → 성능↓.
- **해결**
  - `alignas(64)` 패딩, 배열 stride 조절
  - **per-core(또는 per-thread) 데이터** 후 **reduction**

```c
#include <stdalign.h>
#define CL 64
typedef struct { alignas(CL) long v; } padded_long;
padded_long per_core[128]; // 충분히 띄워서
```

---

## 9) NUMA·할당기·스케줄러

- **NUMA**: 원격 노드 메모리 접근 비용↑ → **first-touch** 초기화, **코어 고정(affinity)**, 데이터/작업 **노드별 샤딩**.
- **할당기 경합**: 전역 락 malloc → **tcmalloc/jemalloc** 등 스레드 캐시형 권장.
- **오버서브스크립션**: 스레드 ≫ 코어 → 컨텍스트 스위치↑, 캐시 손실↑. → 스레드 수 **물리 코어 수 ±α**.

---

## 10) Lock-free 요소와 **ABA/재활용 안전성**

- CAS 기반 구조는 **메모리 재활용**이 핵심 난제.
- **ABA**: A→B→A 변화가 “무변화”로 보임 → **태그 포인터**(세대 카운터) 도입.

```c
// 태그+포인터(개념 스케치)
typedef struct { _Atomic(unsigned __int128) pack; } tagptr;
// [tag:64 | ptr:64]
```

- **Hazard Pointer** 또는 **Epoch-Based Reclamation(EBR)** 로 **해제 시점**을 안전화.
  - HP: 각 스레드가 “내가 보는 포인터”를 공개 → retire 목록은 **모든 HP에서 사라진 뒤** free.
  - EBR: 에폭 단위로 retire → 모든 스레드가 해당 에폭을 지나간 뒤 batch free.

---

## 11) TOCTTOU와 파일/매핑/권한

- **Check-then-Use** 사이의 경쟁을 공유 변수에서도 동일하게 경계.
- 파일 경로 검증 후 열기 전에 바뀌는 문제 → **`openat`/디렉터리 FD** + **동일 락**으로 원자화.

---

## 12) 수학적 직관 — Amdahl/Little/경합 근사

### 12.1 Amdahl’s Law
$$
S(N) = \frac{1}{(1-P) + \frac{P}{N}}
$$
- \(P\): 병렬 가능 비율. 공유 변수 경합은 **\(1-P\) 증가**로 작동 → **샤딩/불변/메시지 패싱**이 근본 해법.

### 12.2 Little’s Law
$$
L = \lambda W
$$
- 큐에 체류하는 작업 수 \(L\)는 도착률 \(\lambda\)와 평균 지연 \(W\)의 곱.
- 무제한 공유 큐는 **메모리 폭주** → **유한 큐 + 백프레셔**로 운영.

---

## 13) 테스트·디버깅·검증 도구

- **ThreadSanitizer(TSan)**: 레이스/순서 문제 탐지 → `-fsanitize=thread`.
- **Helgrind/DRD(Valgrind)**: 락/레이스 분석.
- **rr(Record/Replay)**: 비결정 실행 재현.
- **perf / eBPF / Flamegraph**: 핫 패스·락 경합·스케줄링 비용 가시화.
- **Fuzz/Stress**: 난수 스케줄·장시간 부하 → 희귀 버그 노출.

---

## 14) 실전 스니펫 모음

### 14.1 플래그 + 페이로드(정석)

```c
#include <stdatomic.h>
typedef struct { atomic_int ready; int data; } slot;
void produce(slot* s){
  s->data = 123; // 일반 쓰기
  atomic_store_explicit(&s->ready, 1, memory_order_release);
}
int consume(slot* s){
  while(!atomic_load_explicit(&s->ready, memory_order_acquire)) {}
  return s->data; // 123 보장
}
```

### 14.2 퍼-스레드 누적 후 집계(경합 완화)

```c
#include <stdatomic.h>
_Atomic long global = 0;
__thread long local = 0;

void add(int x){
  local += x;
  if ((local & 0xFFFF) == 0) {
    atomic_fetch_add_explicit(&global, local, memory_order_relaxed);
    local = 0;
  }
}
long total(){ return atomic_load_explicit(&global, memory_order_relaxed); }
```

### 14.3 조건변수 타임아웃(단조시계)

```c
#include <pthread.h>
#include <time.h>
#include <errno.h>

int wait_ms(pthread_cond_t* cv, pthread_mutex_t* m, long ms){
  struct timespec dl; clock_gettime(CLOCK_MONOTONIC, &dl);
  dl.tv_sec  += ms/1000;
  dl.tv_nsec += (ms%1000)*1000000L;
  if (dl.tv_nsec >= 1000000000L){ dl.tv_sec++; dl.tv_nsec -= 1000000000L; }
  return pthread_cond_timedwait(cv, m, &dl);
}
```

### 14.4 `volatile` 오해 방지(반례)

```c
// BAD: volatile은 동기화가 아니다!
volatile int flag = 0;
// 스레드 A: flag = 1;
// 스레드 B: while (!flag) {}
// → 재배치/가시성 미보장. 반드시 atomic/락 사용.
```

---

## 15) 체크리스트(현업용)

- [ ] **데이터 레이스 금지**: 락/원자/조건 변수를 통한 보호.
- [ ] **happens-before** 엣지 명확화(락 언락↔락 획득, release↔acquire, cond wait).
- [ ] 플래그·신호는 **release-store / acquire-load**.
- [ ] **조건변수는 while** 루프(스퍼리어스/유실 신호 대비).
- [ ] **거짓 공유** 방지(alignas(64)/패딩/배열 stride).
- [ ] **샤딩/불변/메시지 패싱**으로 공유 자체를 최소화.
- [ ] Lock-free면 **ABA/수거 전략**(Hazard/Epoch)까지 설계.
- [ ] NUMA **first-touch**, 코어 고정·스레드 수 튜닝.
- [ ] **유한 큐 + 백프레셔**(드롭/지연/재시도 정책).
- [ ] TSan/Helgrind/rr/perf/eBPF로 **정확성+성능** 동시 검증.
- [ ] `volatile`로 동기화하지 않는다.

---

## 16) 요약 결론

1) 공유 변수는 **정확성(레이스·가시성·순서)** → **성능(경합·캐시·NUMA)** → **운영(타임아웃·백프레셔·관측)** 순으로 설계한다.
2) 가능하면 **공유를 없애라**(불변/소유권/메시지/샤딩/RCU).
3) 불가피한 공유엔 **락/원자**를 쓰되, **release/acquire**를 기본으로 **happens-before**를 명확히 만든다.
4) 성능 문제는 **거짓 공유/락 경합**부터 의심하고, 검증은 **도구**로 한다.
