---
layout: post
title: 컴퓨터시스템 - 저장의 논리와 구조
date: 2025-07-16 20:20:23 +0900
category: 컴퓨터시스템
---
# 정보의 저장: 비트에서 워드까지, 저장의 논리와 구조

컴퓨터는 정보를 저장하고 처리할 때 **물리적인 장치** 위에서 **논리적인 규칙**을 따르며 동작한다. 이때 가장 기본이 되는 개념은 **비트**, **바이트**, **워드**, **진법**, **엔디안**, **논리 연산** 등이다. 이 글에서는 정보 저장의 관점에서 이 기본 요소들을 하나씩 짚어본다.

---

## 1. 비트, 바이트, 워드

### 📌 비트 (bit)
- 정보 저장의 **가장 작은 단위**
- 값은 오직 두 개: `0` 또는 `1`

### 📌 바이트 (byte)
- **8비트의 묶음**
- 현대 시스템의 최소 주소 단위
- 예: `10101100` = 1바이트 = 8비트

### 📌 워드 (word)
- **CPU가 한 번에 처리하는 데이터 단위**
- 보통 32비트(4바이트), 64비트(8바이트) 등 아키텍처에 따라 다름
- 예: 64비트 시스템에서 워드는 64비트 = 8바이트

---

## 2. 진법: 이진수, 16진수, 8진수

컴퓨터는 이진수(binary)를 사용하지만, 사람이 읽기 쉽도록 16진수나 8진수로 표기하기도 한다.

### 📌 이진수 (Binary)
- 기수: 2  
- 예: `1101` = \( 1 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 13 \)

### 📌 16진수 (Hexadecimal)
- 기수: 16, 0~9 + A~F  
- 바이트 단위 표기에 적합  
- 예: `0x1F` = \( 1 \times 16^1 + 15 = 31 \)

### 📌 8진수 (Octal)
- 기수: 8, 0~7  
- 과거 유닉스 권한 표기 등에 사용  
- 예: `0755` (권한: rwxr-xr-x)

---

## 3. 리틀 엔디안 vs 빅 엔디안

멀티바이트 데이터를 **메모리에 어떻게 저장하는가**를 결정하는 방식이다.

### 📌 리틀 엔디안 (Little Endian)
- **하위 바이트**를 **먼저 저장**
- 인텔 아키텍처에서 사용

### 📌 빅 엔디안 (Big Endian)
- **상위 바이트**를 **먼저 저장**
- 네트워크 전송 표준, 일부 CPU(ARM 등)에서 사용

### 예제 (16진수 0x12345678을 저장한다고 가정, 메모리 주소가 낮은 쪽부터)

| 주소 | 리틀 엔디안 | 빅 엔디안 |
|------|-------------|-----------|
| 0x00 | 0x78        | 0x12      |
| 0x01 | 0x56        | 0x34      |
| 0x02 | 0x34        | 0x56      |
| 0x03 | 0x12        | 0x78      |

---

## 4. 부울 대수 (Boolean Algebra)

컴퓨터 논리는 **참(True)**과 **거짓(False)**, 즉 `1`과 `0`만으로 모든 논리를 구성한다.  
부울 대수는 **논리 회로**, **조건 판단**, **비트 연산**에 활용된다.

### 기본 연산:

| 연산 | 기호 | 설명 | 예 |
|------|------|------|----|
| AND  | ∧ 또는 `&` | 둘 다 1일 때만 1 | `1 & 0 = 0` |
| OR   | ∨ 또는 `|` | 하나라도 1이면 1 | `1 | 0 = 1` |
| NOT  | ¬ 또는 `~` | 반전 | `~1 = 0` |
| XOR  | ⊕ 또는 `^` | 다르면 1 | `1 ^ 0 = 1`, `1 ^ 1 = 0` |

---

## 5. 비트 쉬프트 연산 (Shift)

비트를 **왼쪽 또는 오른쪽으로 이동**시키는 연산으로, **곱셈과 나눗셈**, **마스크 처리**, **최적화** 등에 사용된다.

### 📌 좌측 쉬프트 (<<)
- 왼쪽으로 비트 이동 → **2의 거듭제곱 곱셈** 효과  
- 예: `00001010 << 1` → `00010100` (10 → 20)

### 📌 우측 쉬프트 (>>)
- 오른쪽으로 비트 이동 → **2의 거듭제곱 나눗셈** 효과  
- 예: `00001010 >> 1` → `00000101` (10 → 5)

### 주의:
- **산술 쉬프트**: 부호 비트를 유지 (signed 연산자에 해당)
- **논리 쉬프트**: 무조건 0으로 채움 (unsigned에서 사용)

---

## 6. 정보 저장 시 고려할 것들

| 개념 | 설명 |
|------|------|
| 정렬(alignment) | CPU는 데이터가 특정 바이트 경계에 정렬되어 있을 때 더 빠르게 접근 가능 |
| 패딩(padding) | 정렬을 맞추기 위해 구조체 등에 추가 공간 삽입 |
| 크기(Size) | 정수는 보통 1, 2, 4, 8바이트, float는 4, double은 8바이트 |
| 오버플로우(Overflow) | 비트 수가 부족해 결과가 잘리는 현상 (예: 8비트에서 256은 0으로 돌아감) |

---

## 마무리

정보는 단순히 비트로만 저장되는 것이 아니라, 그 **해석 기준과 저장 방식**에 따라 완전히 다른 의미를 지닌다.  
단위의 이해, 진법의 활용, 엔디안의 구분, 부울 논리와 쉬프트 연산은 시스템 프로그래밍의 기본 중의 기본이며,  
이 모든 것은 결국 더 효율적이고 정확한 **정보 표현과 저장을 위한 도구들**이다.

이해 없이 사용하는 저장은 오류를 낳고, 구조를 이해한 저장은 성능과 신뢰성을 만든다.