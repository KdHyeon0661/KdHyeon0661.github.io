---
layout: post
title: 컴퓨터시스템 - 저장의 논리와 구조
date: 2025-07-16 20:20:23 +0900
category: 컴퓨터시스템
---
# 정보의 저장: 비트에서 워드까지, 저장의 논리와 구조

## 0. 개요 — 왜 “비트 관점”이 중요한가

저장·전송·연산 성능은 **비트 수준 표현**이 거의 모든 층위(컴파일러 → ISA → 마이크로아키텍처 → 메모리/스토리지 → 네트워크)에서 관여한다.
이 글은 다음을 중심으로 실전 감각을 만든다.

- 단위: **비트·니블·바이트·워드**와 주소 가능 단위
- 수 체계: **이진·16진·8진** 변환과 표기
- 정수 표현: **부호 없는/2의 보수**와 **오버플로/모듈러 산술**
- 논리/시프트/회전: **마스크/테스트/토글**의 습관화
- **엔디안**: 메모리 표준 배치와 네트워크 바이트 순서
- 부동소수점: **IEEE 754** 비트 구조(Inf/NaN/서브노멀/반올림)
- 텍스트: **ASCII/UTF-8/UTF-16**과 슬라이스 함정
- **정렬/패딩/비트필드/팩킹**과 휴대성
- 고정소수점(Q형), **그레이 코드**, **패리티/ECC**

각 절마다 **표·그림·코드**를 곁들인다.

---

## 1. 단위 — 비트·니블·바이트·워드·라인·페이지

| 이름 | 기호 | 크기 | 비고 |
|---|---|---:|---|
| 비트 | bit | 1b | 0/1 |
| 니블 | nibble | 4b | 16진 한 자리(0x0~0xF) |
| 바이트 | B | 8b | 현대 CPU 최소 주소 단위 |
| 워드 | word | 16/32/64b | 아키텍처 의존(예: 64b 시스템 “워드=64b”) |
| 캐시 라인 | – | 보통 64B | 라인 충돌·거짓 공유 단위 |
| 페이지 | – | 4KB/2MB/1GB | TLB/가상메모리 단위 |

---

## 2. 진법 — 이진·16진·8진 변환과 수식

### 2.1 자리값 표기(가중치)

$$
\text{값} = \sum_{i=0}^{k-1} d_i \cdot b^i,\quad d_i \in \{0,\dots,b-1\}
$$

예: `1101₂` = \(1\cdot2^3 + 1\cdot2^2 + 0\cdot2^1 + 1\cdot2^0 = 13\)

### 2.2 실전 팁

- **이진↔16진**: 4비트=1니블 매핑으로 즉시 변환.
- **8진**은 3비트 묶음: 권한 비트(Unix `0755`) 등 역사적 유산에 잦다.

```python
# 진법 변환 간단 도구 (학습용)
def to_base(n, b):
    s = "0123456789ABCDEF"
    if n == 0: return "0"
    out = []
    neg = n < 0
    n = abs(n)
    while n: n, r = divmod(n, b); out.append(s[r])
    return ("-" if neg else "") + "".join(reversed(out))

print(to_base(0x1F, 2))   # 11111
print(to_base(13, 16))    # D
```

---

## 3. 정수 표현 — 부호 없는, 2의 보수, 범위, 오버플로

### 3.1 부호 없는(unsigned) n비트

$$
\text{값} = \sum_{i=0}^{n-1} b_i 2^i \quad\Rightarrow\quad [0, 2^n-1]
$$

### 3.2 2의 보수(two’s complement) n비트

부호 비트를 포함해 **자연스럽게 덧셈/뺄셈**이 동작하도록 설계.

$$
\text{값} = -b_{n-1}\cdot 2^{n-1} + \sum_{i=0}^{n-2} b_i 2^i
$$

범위: \([-2^{n-1}, 2^{n-1}-1]\)

- 음수 생성: **비트 반전 + 1**.
- 덧셈기 하나로 +/− 동일 회로.

#### 예) 8비트의 범위와 오버플로(모듈러 산술)

- 부호 없는: 0..255
- 2의 보수: −128..127

오버플로는 **모듈러 \(2^n\)** 래핑:

$$
(x + y) \bmod 2^n
$$

### 3.3 부호 확장 vs 제로 확장

- **sign-extend**: 2의 보수에서 상위 비트를 부호 비트로 채움.
- **zero-extend**: 부호 없는 확장.

```c
#include <stdint.h>
#include <stdio.h>
int main(){
    int8_t  s8  = -1;         // 0xFF
    uint8_t u8  = (uint8_t)s8; // 255
    int32_t s32 = (int32_t)s8; // -1 (부호 확장: 0xFFFFFFFF)
    uint32_t u32= (uint32_t)u8;// 255 (제로 확장: 0x000000FF)
    printf("%d %u %d %u\n", s8, u8, s32, u32);
}
```

### 3.4 C/C++의 덫: 서명 정수 오버플로는 **정의되지 않음(UB)**

- `int` 덧셈 오버플로 → UB
- 안전이 필요하면 **부호 없는**로 연산 후 범위 검사, 또는 **내장 포화 연산** 사용(플랫폼/라이브러리).

---

## 4. 부울 대수·비트 연산 — 마스크로 지식을 새긴다

### 4.1 기본 연산과 항등식

| 연산 | C 기호 | 진리 | 메모 |
|---|---|---|---|
| NOT | `~x` | 비트 반전 | |
| AND | `x & y` | 둘 다 1 | 마스킹/클리어 |
| OR  | `x \| y` | 하나라도 1 | 셋팅 |
| XOR | `x ^ y` | 다르면 1 | 토글/패리티 |

**드모르간**

$$
\neg(x\land y)=\neg x \lor \neg y,\;\; \neg(x\lor y)=\neg x \land \neg y
$$

### 4.2 마스크 실전 패턴

```c
// 비트 k 설정/해제/토글/테스트
uint32_t set_k   (uint32_t x, unsigned k){ return x |  (1u<<k); }
uint32_t clear_k (uint32_t x, unsigned k){ return x & ~(1u<<k); }
uint32_t toggle_k(uint32_t x, unsigned k){ return x ^  (1u<<k); }
int      test_k  (uint32_t x, unsigned k){ return (x>>k) & 1u;   }
```

### 4.3 집합 표현(비트셋)과 예

- **권한 플래그**, **상태 머신**, **체스 비트보드** 등에서 메모리/연산 모두 경제적.

```c
// 예: 권한 플래그
enum { R=1<<0, W=1<<1, X=1<<2 };
unsigned perm = 0;
perm = set_k(perm, 0);          // R
perm |= W;                      // W
int can_exec = (perm & X) != 0; // 테스트
```

### 4.4 인구수(popcount)/패리티

```c
// 이식성: __builtin_popcountll(GCC/Clang), _mm_popcnt_u64(SSE4.2)
static inline unsigned popcount64(uint64_t x){
    x -= (x>>1) & 0x5555555555555555ull;
    x = (x & 0x3333333333333333ull) + ((x>>2) & 0x3333333333333333ull);
    x = (x + (x>>4)) & 0x0F0F0F0F0F0F0F0Full;
    return (x * 0x0101010101010101ull) >> 56;
}
```

---

## 5. 시프트와 회전 — 논리/산술/순환

### 5.1 정의

- **논리 좌/우**: 빈자리를 0으로 채움(부호 없는에서 사용)
- **산술 우**: 최상위 비트(부호)로 채움(부호 있는에서 “보통”)
- **순환(rotate)**: 비트를 양 끝으로 순환(암호/해시·비트 섞기)

```c
#include <stdint.h>
static inline uint32_t rol32(uint32_t x, unsigned r){
    r &= 31; return (x<<r) | (x>>(32-r));
}
static inline uint32_t ror32(uint32_t x, unsigned r){
    r &= 31; return (x>>r) | (x<<(32-r));
}
```

### 5.2 주의

- **부호 있는 우시프트의 동작**은 언어/컴파일러 규정 확인. C는 구현정의.
- 시프트 폭 ≥ 비트폭은 **UB**. 마스크로 제한.

---

## 6. 엔디안 — 메모리 바이트 순서와 네트워크

### 6.1 리틀 vs 빅

| 주소 증가 방향 → | 0x00 | 0x01 | 0x02 | 0x03 |
|---|---:|---:|---:|---:|
| 리틀(0x12345678) | 78 | 56 | 34 | 12 |
| 빅(0x12345678)    | 12 | 34 | 56 | 78 |

- x86/x64: **리틀 엔디안**
- 네트워크(“network byte order”): **빅 엔디안**

### 6.2 런타임 판별과 바이트 스왑

```c
#include <stdint.h>
#include <stdio.h>
static int is_little(){
    uint16_t x=0x0102; return *(uint8_t*)&x == 0x02;
}
static uint32_t bswap32(uint32_t x){
    return ((x&0x000000FFu)<<24)|((x&0x0000FF00u)<<8)|
           ((x&0x00FF0000u)>>8) |((x&0xFF000000u)>>24);
}
// POSIX/리눅스: htobe32/be32toh, __builtin_bswap32 등 활용
int main(){ printf("%s\n", is_little()?"LE":"BE"); }
```

### 6.3 구조체-파일/네트워크 간 휴대성

- **직렬화는 바이트 순서·정렬·패딩을 명시**하라.
- C **비트필드/패킹**은 구현/엔디안 의존 → **직접 시프트·마스크**로 구성 권장.

```c
// 휴대적 직렬화 예: 32비트 필드 3개를 네트워크 바이트순으로
void write_hdr(uint8_t out[12], uint32_t a, uint32_t b, uint32_t c){
    uint32_t v[3]={a,b,c};
    for(int i=0;i<3;i++){
        uint32_t x=v[i];
        out[4*i+0]=(x>>24)&0xFF;
        out[4*i+1]=(x>>16)&0xFF;
        out[4*i+2]=(x>> 8)&0xFF;
        out[4*i+3]=(x>> 0)&0xFF;
    }
}
```

---

## 7. IEEE 754 부동소수점 — 비트가 의미가 되는 법

### 7.1 형식

| 형식 | 비트 | 부호 s | 지수 e | 가수 f | 바이어스 |
|---|---:|---:|---:|---:|---:|
| float | 32 | 1 | 8 | 23 | 127 |
| double| 64 | 1 | 11| 52 | 1023 |

### 7.2 값의 해석

정규화 수(normalized):

$$
(-1)^s \times (1.f)_2 \times 2^{(e - \text{bias})}
$$

서브노멀:

$$
(-1)^s \times (0.f)_2 \times 2^{(1 - \text{bias})}
$$

특수값: `e` all-1 → `f=0`: **±∞**, `f≠0`: **NaN**

### 7.3 반올림과 함정

- 기본 모드: **반올림-최근접 ties-to-even**
- 실수 비교는 `==` 대신 **허용 오차**(ULP/상대 오차)로.

```c
#include <stdint.h>
#include <string.h>
#include <stdio.h>
typedef union { float f; uint32_t u; } U32F;
int main(){
    U32F x; x.f = 0.1f;
    printf("0.1f bits=0x%08X\n", x.u);
    // 0.1은 이진 유한 표현 불가 → 근사 저장
}
```

---

## 8. 텍스트 저장 — ASCII, UTF-8, UTF-16, BOM

| 인코딩 | 특징 | 장점 | 주의 |
|---|---|---|---|
| ASCII | 7비트 | 역사적 표준 | 영문만 |
| UTF-8 | 가변 1~4바이트 | ASCII 호환, 웹 표준 | **문자 길이≠바이트 수** |
| UTF-16 | 2/4바이트 | BMP 2B, 보조평면 서러게이트 | 엔디안·BOM·문자 경계 주의 |

- “문자”는 **코드 포인트**와 ≠ **그래프(보이는 글자)**. 조합형(음절/악센트) 주의.

```python
# UTF-8 바이트 길이 vs 문자 길이
s = "가á"  # a + 결합 악센트
print(len(s), len(s.encode("utf-8")))  # 문자 수, 바이트 수
```

- **문자 슬라이스는 코드포인트/그래프 단위 라이브러리 사용**(언어별 API).

---

## 9. 정렬(alignment)·패딩(padding) — CPU가 좋아하는 배치

### 9.1 원칙

- 타입 T의 자연 정렬: 보통 **min(sizeof(T), 8)** 또는 ABI 규칙.
- 구조체는 멤버 정렬 규칙에 따라 **패딩**을 삽입해 전체가 정렬.

```c
#include <stdio.h>
#include <stdint.h>
struct A { uint8_t a; uint32_t b; uint16_t c; };
struct B { uint32_t b; uint16_t c; uint8_t a; };
int main(){
    printf("A=%zu, B=%zu\n", sizeof(struct A), sizeof(struct B)); // 예: A=12, B=8
}
```

- **멤버 재배치**만으로도 저장·캐시 효율 개선.

### 9.2 패킹의 위험

`#pragma pack(1)` / `__attribute__((packed))`는 패딩 제거하지만:

- **오정렬 접근** → 일부 CPU에서 페널티/트랩
- I/O 구조체 등에서만 제한적으로 사용, 그 외에는 **수동 직렬화** 권장.

---

## 10. 비트필드 vs 수동 팩킹 — 휴대성과 통제

### 10.1 C 비트필드의 문제

- 비트 순서/엔디안/패킹이 구현 정의 → 바이너리 호환 취약.

### 10.2 안전한 수동 팩킹

```c
// 3비트 type, 5비트 flags, 24비트 length → 32비트 헤더
uint32_t pack(uint32_t type, uint32_t flags, uint32_t len24){
    return ((type  & 0x7 )<<29) |
           ((flags & 0x1F)<<24) |
           ( len24 & 0xFFFFFF );
}
void unpack(uint32_t h, uint32_t*outT, uint32_t*outF, uint32_t*outL){
    *outT = (h>>29)&0x7; *outF=(h>>24)&0x1F; *outL=h&0xFFFFFF;
}
```

---

## 11. 고정소수점(Q 형식) — 정밀도와 속도의 절충

### 11.1 정의

Q\(m.n\): 총 \(m+n\) 비트, **정수부 m**, **소수부 n**. 저장값 \(x\)는 실제값 \(x/2^n\).

$$
\text{실수값} = \frac{\text{정수표현}}{2^n}
$$

### 11.2 예: Q1.15(16비트) 곱셈

$$
z = \frac{(a \cdot b)}{2^{15}}
$$

```c
// Q1.15 곱셈 (포화 포함)
#include <stdint.h>
static inline int16_t q15_mul(int16_t a, int16_t b){
    int32_t t = (int32_t)a * (int32_t)b;     // 32b
    t += 1<<14;                              // 반올림
    t >>= 15;
    if(t >  32767) t= 32767;
    if(t < -32768) t=-32768;
    return (int16_t)t;
}
```

---

## 12. 그레이 코드(Gray) — 인접 값의 1비트 차이

$$
g = n \oplus (n \gg 1)
$$

- 하드웨어 인코더/ADC/기계적 스위치에서 **글리치 완화**.

```c
static inline uint32_t gray(uint32_t n){ return n ^ (n>>1); }
static inline uint32_t ungray(uint32_t g){
    for(uint32_t b=g>>1; b; b>>=1) g ^= b; return g;
}
```

---

## 13. 무결성 — 패리티, 체크섬, CRC, ECC(개요)

### 13.1 패리티/체크섬/CRC

- **패리티**: 1비트(홀/짝) → 단일 비트 오류 검출
- **체크섬**: 단순 합(모듈러) → 가벼움
- **CRC**: 다항식 기반 → 버스트 오류 강함(프레임/스토리지)

```c
// CRC-8 (다항식 0x07, 초기 0x00)
uint8_t crc8(const uint8_t* p, int n){
    uint8_t c=0;
    for(int i=0;i<n;i++){
        c ^= p[i];
        for(int b=0;b<8;b++)
            c = (c&0x80) ? (c<<1)^0x07 : (c<<1);
    }
    return c;
}
```

### 13.2 ECC 메모리(SECDED)

- **싱글 비트 오류 정정**, **더블 비트 오류 검출** → 서버/스토리지 신뢰성.

---

## 14. 저장 매체/주소성과 메모리 맵 I/O

- 현대 시스템은 보통 **바이트 주소 가능(byte-addressable)**.
- 일부 임베디드는 워드 주소 가능.
- **MMIO**: 디바이스 레지스터를 주소 공간에 매핑.
  - C에서 `volatile`로 최적화 억제, **메모리 장벽**(언어/플랫폼 API)로 순서 보장.

---

## 15. 관찰 도구 — 메모리 덤프/시각화

```python
# 바이트 배열을 주소/오프셋 표로 출력 (학습용)
def hexdump(b, base=0):
    for i in range(0, len(b), 16):
        chunk = b[i:i+16]
        hexs = " ".join(f"{x:02X}" for x in chunk)
        text = "".join(chr(x) if 32<=x<127 else "." for x in chunk)
        print(f"{base+i:08X}: {hexs:<47} {text}")
buf = bytes([0x12,0x34,0x56,0x78, 0x00,0xFF,0x41,0xC3])
hexdump(buf)
```

---

## 16. 예제: 엔디안 안전한 파일 포맷 I/O(파이썬)

```python
import struct

# 네트워크 바이트 순서(빅엔디안)로 헤더 3필드
def write_hdr(f, a, b, c):
    f.write(struct.pack(">III", a, b, c))

def read_hdr(f):
    data = f.read(12)
    return struct.unpack(">III", data)

# 사용
with open("hdr.bin", "wb") as fp:
    write_hdr(fp, 0x12345678, 0xABCDEF01, 4096)

with open("hdr.bin", "rb") as fp:
    print([hex(x) for x in read_hdr(fp)])
```

---

## 17. 언어별 주의사항 요약

- **C/C++**: 서명 오버플로=UB, 시프트 폭 체크, 비트필드·packed는 휴대성 낮음
- **Java**: `byte`는 **부호 있는 8비트**; `ByteBuffer.order(ByteOrder)`로 엔디안 제어
- **C#**: `BitConverter.IsLittleEndian`; `BinaryPrimitives.ReverseEndianness`
- **Python**: `int` 무한정 정밀도(오버플로 없음), `struct`/`int.to_bytes(...)`로 엔디안 제어
- **JavaScript**: `Number`는 IEEE754 double; `BigInt`/`DataView`로 비트·엔디안 제어

---

## 18. 체크리스트 — 저장을 설계할 때

1. **표현 선택**: 부호/범위/해상도(정수 vs 부동 vs 고정소수)
2. **엔디안/정렬/패딩**: 파일/네트워크/메모리/ABI 분리 명시
3. **직렬화**: 명확한 포맷(필드 폭·순서·단위·버전), 테스트 벡터 포함
4. **오버플로**: 래핑/포화/예외 중 정책 결정 후 일관 적용
5. **정밀도/반올림**: 754 모드/스케일 정의, 비교는 ULP/epsilon
6. **문자열**: 인코딩을 명시(UTF-8 권장), 길이는 바이트가 아닌 **코드포인트/그래프** 고려
7. **무결성**: CRC/체크섬/ECC 필요 여부
8. **성능**: 캐시/라인 친화, 연속 메모리, 구조체 재배치
9. **이식성**: 테스트를 다른 엔디안/플랫폼에서 자동 실행

---

## 19. 연습 문제(자가 점검)

1) 16비트 2의 보수에서 `0b1000_0000_0000_0000`의 값은?
2) 32비트 부호 없는에서 `0xFFFF_FFFF + 1`의 결과는?
3) 0x12345678을 리틀 엔디안 메모리에 저장할 때 주소+오프셋 표 작성.
4) IEEE 754 float에서 `s=0,e=127,f=0`의 값은?
5) Q1.15에서 0.5(=16384)×0.5의 결과(정확/반올림/포화 처리 포함)를 구하라.

---

## 20. 요약 — “비트는 콘텐츠, 바이트는 그 컨테이너”

- **비트 표현**(정수/부동/고정소수/텍스트)은 **정확도/범위/성능**을 결정한다.
- **엔디안·정렬·패딩**을 명시하지 않으면 휴대성은 무너진다.
- 저장은 “그냥 담는” 행위가 아니라 **의미·정합·효율을 설계**하는 일이다.
- 한 장의 표와 몇 줄의 마스크/시프트/직렬화 코드가 **버그의 90%**를 예방한다.

---
```c
// 부록: 엔디안·정렬·범위를 한 번에 검증하는 C 스모크 테스트
#include <stdint.h>
#include <stdio.h>
int main(){
    union { uint32_t u; uint8_t b[4]; } v={ .u=0x12345678 };
    printf("endian=%s\n", v.b[0]==0x78?"little":"big");
    struct { uint8_t a; uint32_t b; uint16_t c; } A;
    printf("sizeof(A)=%zu\n", sizeof(A));
    // 래핑 예시
    uint32_t x=0xFFFFFFFFu; x+=1u; printf("wrap=%u\n", x);
    return 0;
}
```
```python
# 부록: 비트 시각화 유틸
def bits(x, w=32):
    return "".join("1" if (x>>(w-1-i))&1 else "0" for i in range(w))
print(bits(0x12345678))
```

이해 없이 저장하면 버그가, 이해하고 저장하면 **성능과 신뢰성**이 따라온다. 오늘부터 자료구조의 설계 문서에 **비트·엔디안·정렬·직렬화 표**를 빈칸 없이 포함하라.
