---
layout: post
title: ì•”í˜¸í•™ - ë‚œìˆ˜Â·ì‹œë“œÂ·í‚¤ ìƒì„±
date: 2025-10-08 23:30:23 +0900
category: ì•”í˜¸í•™
---
# ë‚œìˆ˜Â·ì‹œë“œÂ·í‚¤ ìƒì„±

## âœ… 4.1 ì™œ â€˜ë‚œìˆ˜â€™ê°€ ë³´ì•ˆì˜ ì‹¬ì¥ì¸ê°€

- **í‚¤/Nonce/ì‹œë“œ**ê°€ ì˜ˆì¸¡ë˜ë©´ ê¸°ë°€ì„±Â·ë¬´ê²°ì„±Â·ì¸ì¦ì´ **ëª¨ë‘** ë¶•ê´´í•œë‹¤.
- ë¹„ë°€ë²ˆí˜¸ í•´ì‹œëŠ” **KDF(í‚¤ ìœ ë„ í•¨ìˆ˜)**ì˜ íŒŒë¼ë¯¸í„°(ì†”íŠ¸Â·ë©”ëª¨ë¦¬Â·ë°˜ë³µ íšŸìˆ˜)ì— ë‹¬ë ¤ ìˆìœ¼ë©°, ëœë¤ ì†”íŠ¸ê°€ ë¶€ì¡±í•˜ê±°ë‚˜ ì¬ì‚¬ìš©ë˜ë©´ **ëŒ€ëŸ‰ í¬ë˜í‚¹ì´ ê°€ì†**ëœë‹¤.
- **AEAD(GCM/ChaCha20-Poly1305)** ì—ì„œ Nonce ì¶©ëŒì€ **í‰ë¬¸ XOR ìœ ì¶œÂ·íƒœê·¸ ìœ„ì¡°**ë¡œ ì§ê²°ëœë‹¤.

> ê·œì¹™: **ì§ì ‘ ë‚œìˆ˜ê¸°ë¥¼ ë§Œë“¤ì§€ ë§ê³ ** ìš´ì˜ì²´ì œ/ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ **CSPRNG**ë§Œ ì‚¬ìš©í•˜ë¼.

---

## âœ… 4.2 PRG vs CSPRNG (ê°œë…Â·ì •ì˜Â·í…ŒìŠ¤íŠ¸)

### ìš©ì–´

- **PRG (Pseudo-Random Generator)**: ì§§ì€ ì‹œë“œ â†’ ê¸´ ì˜ì‚¬ë‚œìˆ˜ì—´. í†µê³„ í…ŒìŠ¤íŠ¸ì— â€˜ëœë¤ì²˜ëŸ¼â€™ ë³´ì´ëŠ” ìƒì„±ê¸°.
- **CSPRNG (Cryptographically Secure PRNG)**: PRG ì¤‘ì—ì„œë„ **ì•”í˜¸í•™ì ** ë³´ì•ˆ ìš”ê±´(ì˜ˆì¸¡ ë¶ˆê°€ì„±, **next-bit test** í†µê³¼, **ì—­ì¶”ì /ì „ë‹¬ ë¹„ë°€ì„±**)ì„ ì¶©ì¡±í•˜ëŠ” ê²ƒ.

### ë³´ì•ˆ ì†ì„±(í•µì‹¬ 3ì¢…)

1) **ì˜ˆì¸¡ ë¶ˆê°€ì„±**: ì§€ê¸ˆê¹Œì§€ì˜ ì¶œë ¥ìœ¼ë¡œ **ë‹¤ìŒ ë¹„íŠ¸**ë¥¼ ì˜ˆì¸¡í•  ìˆ˜ ì—†ì–´ì•¼ í•œë‹¤.
2) **ì—­ì¶”ì  ì €í•­(Backtracking resistance)**: ë‚´ë¶€ ìƒíƒœê°€ ë…¸ì¶œë˜ì–´ë„ **ê³¼ê±° ì¶œë ¥**ì„ ë³µì›í•˜ê¸° ì–´ë µë‹¤.
3) **ì „ë‹¬ ë¹„ë°€ì„±(Forward secrecy)**: ê³¼ê±° ìƒíƒœ/ì¶œë ¥ì´ ë…¸ì¶œë¼ë„ **ë¯¸ë˜ ì¶œë ¥** ì˜ˆì¸¡ì´ ì–´ë µë‹¤(ì£¼ê¸°ì  **reseed** í•„ìš”).

### ì™œ â€œí†µê³„ì  ë‚œìˆ˜â€ì™€ â€œì•”í˜¸ìš© ë‚œìˆ˜â€ëŠ” ë‹¤ë¥¼ê¹Œ

- ë‹¨ìˆœ PRNG(Mersenne Twister ë“±)ëŠ” í†µê³„ì ìœ¼ë¡œ ë§¤ìš° ìš°ìˆ˜í•˜ì§€ë§Œ, **ìƒíƒœ ë³µêµ¬**ê°€ ì‰¬ì›Œ ì•”í˜¸ìš©ìœ¼ë¡œ ë¶€ì ì ˆ.
- CSPRNGëŠ” ë‚´ë¶€ ìƒíƒœê°€ ë…¸ì¶œë˜ë”ë¼ë„ **ì¶”ê°€ ì—”íŠ¸ë¡œí”¼ë¥¼ ì„ëŠ” ì¬ì‹œë“œ ì„¤ê³„**ê°€ í•„ìˆ˜.

---

## âœ… 4.3 ì—”íŠ¸ë¡œí”¼(Entropy)ì™€ ì‹œë“œ(Seed)

### ì—”íŠ¸ë¡œí”¼ ì›ì²œê³¼ í˜¼í•©(Conditioning)

- ë¬¼ë¦¬ì  ì†ŒìŠ¤: **íƒ€ì´ë° ì§€í„°, ë””ìŠ¤í¬/ë„¤íŠ¸ì›Œí¬ ì¸í„°ëŸ½íŠ¸, HWRNG(ì¸í…” RDRAND/RDSEED, SoC TRNG)** ë“±.
- ì»¤ë„/ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ë‹¤ì–‘í•œ ì†ŒìŠ¤ë¡œë¶€í„° ì—”íŠ¸ë¡œí”¼ë¥¼ ìˆ˜ì§‘ â†’ **ì¶”ì¶œê¸°(í•´ì‹œ/HMAC/ë¸”ë¡ì•”í˜¸)** ë¡œ **ê· ì§ˆí™”**(bias ì œê±°) â†’ **ì‹œë“œ í’€**ì— ì¶•ì .

### ì—”íŠ¸ë¡œí”¼ ì¶”ì •ì€ ì–´ë µë‹¤

- ë‹¨ìˆœ ì¹´ìš´íŒ…/ë¶„í¬ë§Œìœ¼ë¡œ â€œì§„ì§œ ì—”íŠ¸ë¡œí”¼â€ë¥¼ ì •í™•íˆ ì¶”ì •í•˜ê¸°ëŠ” **ë§¤ìš° ì–´ë ¤ì›€**.
- ê²°ë¡ : **ì§ì ‘ ì¶”ì •í•˜ì§€ ë§ê³ ** ê²€ì¦ëœ **ì‹œìŠ¤í…œ RNG**ì— ìœ„ì„.

---

## âœ… 4.4 ìš´ì˜ì²´ì œ/í”Œë«í¼ ë‚œìˆ˜ API (ë¬´ì—‡ì„ ì“°ë‚˜)

- **Linux**: `getrandom(2)`, **`/dev/urandom`** (í˜„ëŒ€ ë¦¬ëˆ…ìŠ¤ì—ì„œëŠ” ë¸”ë¡œí‚¹ ì—†ì´ **ì•”í˜¸í•™ì ìœ¼ë¡œ ì•ˆì „**í•œ ìŠ¤íŠ¸ë¦¼ ì œê³µ)
- **Windows**: CNG `BCryptGenRandom`, ì˜› API `CryptGenRandom`(CSP) â†’ **CNG ê¶Œì¥**
- **macOS/iOS**: `SecRandomCopyBytes`
- **Web**: `window.crypto.getRandomValues()`
- **Python**: `os.urandom(n)`, `secrets` ëª¨ë“ˆ(`secrets.token_bytes()`, `token_hex()` ë“±)
- **OpenSSL**: `RAND_bytes()`

> ì›ì¹™: **ì–¸ì–´ê°€ ì œê³µí•˜ëŠ” â€œë³´ì•ˆìš© ë‚œìˆ˜â€ API**ë§Œ ì‚¬ìš©. `random`, `numpy.random` ë“± **ì¨ì„œëŠ” ì•ˆ ë¨**.

**íŒŒì´ì¬ ì˜ˆì‹œ (ì‹¤ì „ ì•ˆì „)**
```python
import os, secrets

# ì•”í˜¸í•™ì ìœ¼ë¡œ ì•ˆì „í•œ ë°”ì´íŠ¸

k = os.urandom(32)                # 256-bit key
nonce = secrets.token_bytes(12)   # GCM ê¶Œì¥ 96-bit nonce

# ì‚¬ëŒì´ ì½ê¸° ì¢‹ì€ í† í° (ì„¸ì…˜/CSRF ë“±)

token = secrets.token_urlsafe(32) # URL-safe base64
print(len(k), len(nonce), token[:20])
```

---

## â€” Hash/HMAC/CTR-DRBG ì§ê´€

### DRBG ì‚¶ì˜ ì£¼ê¸°

1) **Instantiate**: ì—”íŠ¸ë¡œí”¼ ì…ë ¥(ì‹œë“œ) + **Nonce** + **Personalization String** â†’ ë‚´ë¶€ ìƒíƒœ ì´ˆê¸°í™”
2) **Generate**: í•„ìš”í•  ë•Œë§ˆë‹¤ ì˜ì‚¬ë‚œìˆ˜ ì¶œë ¥, **ìš”ì²­ ê¸¸ì´** ì œí•œ
3) **Reseed**: ì£¼ê¸°ì ìœ¼ë¡œ/ìš”ì²­ëŸ‰ ì´ˆê³¼ ì‹œ **ìƒˆ ì—”íŠ¸ë¡œí”¼**ë¥¼ í¡ìˆ˜í•´ ìƒíƒœ ê°±ì‹ 
4) **Uninstantiate**: ì¢…ë£Œ ì‹œ ìƒíƒœ ì†Œê±°(ë©”ëª¨ë¦¬ ì œë¡œí™”)

### ì„¸ ê³„ì—´ ì§ê´€

- **Hash-DRBG**: SHA-256 ê°™ì€ í•´ì‹œë¥¼ ì••ì¶•ê¸°/ì¶”ì¶œê¸°ë¡œ ì‚¬ìš©
- **HMAC-DRBG**: HMAC(K, V) êµ¬ì¡°ë¡œ ìƒíƒœ ìœ ì§€ (NIST í‘œì¤€ êµ¬í˜„ ì‰¬ì›€)
- **CTR-DRBG**: ë¸”ë¡ì•”í˜¸ AES-CTR ê¸°ë°˜. ê³ ì†Â·í•˜ë“œì›¨ì–´ ê°€ì† ìœ ë¦¬

### ë¯¸ë‹ˆ HMAC-DRBG ë°ëª¨(êµìœ¡ìš© ê°„ì†Œí™”)

```python
import hmac, hashlib, os

class HMAC_DRBG:
    # SP 800-90A HMAC-DRBGì—ì„œ ì•„ì´ë””ì–´ë§Œ ë¹¼ ì˜¨ ì¶•ì•½ ë²„ì „(êµìœ¡ìš©!)
    def __init__(self, seed_material: bytes):
        self.K = b'\x00' * 32
        self.V = b'\x01' * 32
        self._update(seed_material)

    def _hmac(self, key, data):
        return hmac.new(key, data, hashlib.sha256).digest()

    def _update(self, provided_data=b''):
        self.K = self._hmac(self.K, self.V + b'\x00' + provided_data)
        self.V = self._hmac(self.K, self.V)
        if provided_data:
            self.K = self._hmac(self.K, self.V + b'\x01' + provided_data)
            self.V = self._hmac(self.K, self.V)

    def reseed(self, entropy: bytes):
        self._update(entropy)

    def generate(self, n: int) -> bytes:
        out = b''
        while len(out) < n:
            self.V = self._hmac(self.K, self.V)
            out += self.V
        # (ì„ íƒ) ì˜ˆì¸¡ì €í•­: ìš”ì²­ë§ˆë‹¤ _update()ë¡œ ìƒíƒœ ê°•í™” ê°€ëŠ¥
        return out[:n]

# ì‚¬ìš©: ì‹œìŠ¤í…œ ì—”íŠ¸ë¡œí”¼ë¥¼ ì‹œë“œë¡œ

seed = os.urandom(48)
drbg = HMAC_DRBG(seed)
print(drbg.generate(64).hex()[:64])
drbg.reseed(os.urandom(32))
print(drbg.generate(32).hex()[:64])
```

> **ì‹¤ì „**: ì´ì™€ ê°™ì€ â€œìì‘ DRBGâ€ë¥¼ ì“°ì§€ ë§ê³ , **í”Œë«í¼ ì œê³µ CSPRNG**ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”. ìœ„ ì½”ë“œëŠ” DRBGì˜ ì§ê´€ì  ë™ì‘ì„ ë³´ì—¬ì£¼ëŠ” **í•™ìŠµ ë„êµ¬**ì…ë‹ˆë‹¤.

---

## ì§€ë„: â€œë¬´ì—‡ì„ ì–¸ì œ ì“°ë‚˜â€

- **ë¹„ë°€ë²ˆí˜¸ ê¸°ë°˜ KDF**: **PBKDF2**, **scrypt**, **Argon2**
  - ëª©ì : **ì‚¬ì „/ë¸Œë£¨íŠ¸í¬ìŠ¤ ê³µê²© ë¹„ìš©ì„ í‚¤ìš°ê¸°**, ë™ì‹œì„±Â·ë©”ëª¨ë¦¬Â·GPU/ASIC ì €í•­
- **í‚¤ ê¸°ë°˜ KDF**: **HKDF**(Extract-then-Expand), **KMAC**(í•´ì‹œê¸°ë°˜, SHA-3 ê³„ì—´)
  - ëª©ì : í‚¤/ì„¸ì…˜í‚¤ íŒŒìƒ, **ë„ë©”ì¸ ë¶„ë¦¬**, **í‚¤ ë¶„í™”**(contextë³„ ì„œë¡œ ë‹¤ë¥¸ í‚¤)

> ë¹„ë°€ë²ˆí˜¸ ì €ì¥/ê²€ì¦ â†’ **Argon2id/scrypt ê¶Œì¥**, PBKDF2ëŠ” **ë ˆê±°ì‹œ** í˜¸í™˜ìš©.
> ECDH ë“±ì—ì„œ **ì„¸ì…˜í‚¤ íŒŒìƒ** â†’ **HKDF**(salt+info).

---

## âœ… 4.7 PBKDF2 â€” êµ¬ì¡°Â·ì¥ë‹¨ì Â·ì½”ë“œ

### êµ¬ì¡° ìš”ì•½

- **HMAC(í•´ì‹œ)** ë¥¼ ë°˜ë³µ(`iterations = c`)í•´ì„œ **ë¹„ìš©ì„ ì„ í˜• ì¦ê°€**.
- íŒŒë¼ë¯¸í„°: `salt`(ëœë¤, â‰¥16ë°”ì´íŠ¸), `iterations`(ì‹œê°„ ë¹„ìš©), `dklen`(ì¶œë ¥ ê¸¸ì´).

### ì¥ë‹¨ì 

- ğŸ‘ í‘œì¤€Â·ê´‘ë²”ìœ„ ì§€ì›, êµ¬í˜„ ê°„í¸
- ğŸ‘ **ë©”ëª¨ë¦¬ ë¹„ìš© ê±°ì˜ ì—†ìŒ** â†’ GPU/ASICìœ¼ë¡œ **ëŒ€ê·œëª¨ ë³‘ë ¬ ê³µê²© ìœ ë¦¬** â†’ **í˜„ëŒ€ ê¶Œì¥ ì•„ë‹˜**

### íŒŒì´ì¬ ì˜ˆì‹œ

```python
import os, hashlib, hmac

def pbkdf2_hash(password: str, salt: bytes=None, iters: int=600_000, dklen: int=32):
    if salt is None:
        salt = os.urandom(16)
    pwd = password.encode('utf-8')
    dk = hashlib.pbkdf2_hmac('sha256', pwd, salt, iters, dklen=dklen)
    return salt, iters, dk

def pbkdf2_verify(password: str, salt: bytes, iters: int, dk: bytes):
    pwd = password.encode('utf-8')
    cand = hashlib.pbkdf2_hmac('sha256', pwd, salt, iters, dklen=len(dk))
    # ìƒìˆ˜ì‹œê°„ ë¹„êµ
    return hmac.compare_digest(cand, dk)

salt, iters, dk = pbkdf2_hash("correct horse battery staple")
print(iters, salt.hex(), dk.hex()[:32])
print(pbkdf2_verify("correct horse battery staple", salt, iters, dk))
```

> **ì‹¤ì „ íŒ**: PBKDF2ëŠ” **ê°•í•œ í˜¸í™˜ì„±**ì´ í•„ìš”í•  ë•Œë§Œ. ìƒˆ ì„¤ê³„ë©´ **scrypt/Argon2id**ë¡œ.

---

## âœ… 4.8 scrypt â€” ë©”ëª¨ë¦¬ í•˜ë“œ KDF

### êµ¬ì¡° ìš”ì•½

- íŒŒë¼ë¯¸í„°: \(N\)(CPU/ë©”ëª¨ë¦¬ ë¹„ìš©, 2ì˜ ê±°ë“­ì œê³±), \(r\)(ë¸”ë¡ í¬ê¸°), \(p\)(ë³‘ë ¬ë„).
- í•µì‹¬: **í° ë©”ëª¨ë¦¬ ë²„í¼**ë¥¼ ì°¸ì¡°í•˜ëŠ” êµ¬ì¡°ë¡œ **GPU/ASIC ë³‘ë ¬ íš¨ìœ¨ì„ ë–¨ì–´ëœ¨ë¦¼**.

### ë©”ëª¨ë¦¬ ë¹„ìš© ê·¼ì‚¬

- ë©”ëª¨ë¦¬ \(\approx 128 \cdot r \cdot N\) ë°”ì´íŠ¸(ëŒ€ëµ). ì˜ˆ: \(N=2^{15}, r=8 \Rightarrow\) ì•½ 32 MiB.

### íŒŒì´ì¬ ì˜ˆì‹œ(`hashlib.scrypt`)

```python
import os, hashlib, hmac

def scrypt_hash(password: str, salt: bytes=None, N: int=2**15, r: int=8, p: int=1, dklen: int=32):
    if salt is None:
        salt = os.urandom(16)
    pwd = password.encode('utf-8')
    dk = hashlib.scrypt(pwd, salt=salt, n=N, r=r, p=p, dklen=dklen)
    return salt, (N,r,p), dk

def scrypt_verify(password: str, salt: bytes, params, dk: bytes):
    N,r,p = params
    cand = hashlib.scrypt(password.encode('utf-8'), salt=salt, n=N, r=r, p=p, dklen=len(dk))
    return hmac.compare_digest(cand, dk)

salt, params, dk = scrypt_hash("Tr0ub4dor&3")
print(params, salt.hex(), dk.hex()[:32], scrypt_verify("Tr0ub4dor&3", salt, params, dk))
```

> **ê°€ì´ë“œ(ì˜ˆì‹œ)**: ì„œë²„ê¸‰ â†’ \(N=2^{15\sim 16}\), \(r=8\), \(p=1\) (ë©”ëª¨ë¦¬ ìˆ˜ì‹­~ë°±ì—¬ MiB, 100ms ì•ˆíŒ ëª©í‘œ)
> ëª¨ë°”ì¼/ì„ë² ë””ë“œ â†’ ë””ë°”ì´ìŠ¤ë³„ ì‹œí—˜ ì¸¡ì •ìœ¼ë¡œ **ì²´ê° 200ms** ìˆ˜ì¤€ì—ì„œ íƒ€í˜‘

---

## âœ… 4.9 Argon2 â€” í˜„ ì„¸ëŒ€ ê¶Œì¥ (Argon2id ì¶”ì²œ)

### ë³€í˜•

- **Argon2d**: ë°ì´í„° ì˜ì¡´ì  ë©”ëª¨ë¦¬ ì ‘ê·¼(ì¸¡ì±„ë„ ìœ„í—˜)
- **Argon2i**: ë°ì´í„° ë¹„ì˜ì¡´(ì¸¡ì±„ë„ ì•ˆì „)
- **Argon2id**: í˜¼í•©í˜•(ì‹¤ë¬´ **ê¶Œì¥**)

### íŒŒë¼ë¯¸í„°

- `m_cost`(ë©”ëª¨ë¦¬, KiB), `t_cost`(ì‹œê°„/ë¼ìš´ë“œ), `parallelism`(ìŠ¤ë ˆë“œ)
- **ê¶Œì¥ ëŠë‚Œì¹˜**(ì‹¤ì¥ë¹„ ì¸¡ì • í•„ìˆ˜)
  - ì„œë²„/ë°ìŠ¤í¬í†±: `m=64~256 MiB`, `t=2~3`, `p=ìë™(ì½”ì–´)`
  - ëª¨ë°”ì¼: `m=16~64 MiB`, `t=2~3`, `p=1~2`
- **ì†”íŠ¸ â‰¥ 16ë°”ì´íŠ¸**, **ì„œë²„ ì¸¡ Pepper(ì„ íƒ)**ëŠ” HSM/í™˜ê²½ë³€ìˆ˜ ë“± ë³„ë„ ë³´ê´€

### íŒŒì´ì¬ ì‹¤ìŠµ(ì„¤ëª…ìš©; `argon2-cffi`ê°€ ìˆì–´ì•¼ ì‹¤í–‰)

```python
# pip install argon2-cffi
# from argon2.low_level import hash_secret, Type, Parameters, verify_secret
# params = Parameters(type=Type.ID, version=19, salt_len=16, hash_len=32, time_cost=3, memory_cost=65536, parallelism=2)
# salt = os.urandom(params.salt_len)
# h = hash_secret(b"password", salt, time_cost=params.time_cost, memory_cost=params.memory_cost,
#                 parallelism=params.parallelism, hash_len=params.hash_len, type=params.type)
# # ì €ì¥ì€ Argon2 í‘œì¤€ ì¸ì½”ë”© ë¬¸ìì—´ë¡œ(ë²„ì „/íŒŒë¼ë¯¸í„° í¬í•¨)
# ok = verify_secret(h, b"password", type=Type.ID)
# print(ok)

```

> **ë³´ì•ˆ í¬ì¸íŠ¸**: Argon2ëŠ” **ë©”ëª¨ë¦¬ í•˜ë“œ** â†’ GPU/ASIC ë³‘ë ¬í™” ì €í•­.
> **ë°˜ë“œì‹œ ë””ë°”ì´ìŠ¤ë³„ ì„±ëŠ¥ ì¸¡ì •**ìœ¼ë¡œ 100~250ms ì •ë„ì˜ **ì‚¬ìš©ì ìˆ˜ìš© ì‹œê°„**ì„ ëª©í‘œë¡œ ì¡°ì •.

---

## âœ… 4.10 HKDF â€” í‚¤ íŒŒìƒì˜ í‘œì¤€(Extract-then-Expand)

### êµ¬ì¡°

- **Extract**: \(\text{PRK} = \mathrm{HMAC}_{\text{salt}}(\text{IKM})\) â€” ì…ë ¥ í‚¤ ì¬ë£Œ(IKM)ì— **ì†Œê¸ˆ**ì„ ë”í•´ â€˜ê· ì§ˆí™”â€™
- **Expand**: \(\text{OKM} = \mathrm{HMAC}_{\text{PRK}}(\text{info} \parallel \text{ctr})\) ë¥¼ ë°˜ë³µí•´ ì›í•˜ëŠ” ê¸¸ì´ë§Œí¼ í‚¤ ì¬ë£Œ ìƒì„±
- **ì¥ì **: **ë„ë©”ì¸ ë¶„ë¦¬**(`info`), í‚¤ ë¶„í™”, ì¶©ëŒÂ·ì¬ì‚¬ìš© ì•ˆì „ì„±

### íŒŒì´ì¬ ì˜ˆì‹œ(`cryptography`)

```python
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
import os

ikm = os.urandom(32)       # ì˜ˆ: ECDH ê³µìœ ë¹„ë°€
salt = os.urandom(16)      # ë…ë¦½ ë‚œìˆ˜ (ì—†ì–´ë„ ë™ì‘í•˜ë‚˜ ë³´ì•ˆìƒ ê¶Œì¥)
info = b"context:tls-keys"

hkdf = HKDF(algorithm=hashes.SHA256(), length=64, salt=salt, info=info)
okm = hkdf.derive(ikm)
client_write_key = okm[:32]
server_write_key = okm[32:]
print(client_write_key.hex()[:16], server_write_key.hex()[:16])
```

> **ì›ì¹™**: ì„œë¡œ ë‹¤ë¥¸ ìš©ë„(ì•”í˜¸í™”í‚¤, MACí‚¤, IV ë“±)ì—ëŠ” **ì„œë¡œ ë‹¤ë¥¸ info/ë¼ë²¨**ë¡œ í‚¤ë¥¼ **ë¶„í™”**í•˜ë¼(í•œ ì¬ë£Œë¡œ ì—¬ëŸ¬ í‚¤).

---

## âœ… 4.11 ë¹„ë°€ë²ˆí˜¸ ì €ì¥Â·ê²€ì¦ ì„¤ê³„ ë ˆì‹œí”¼

### ì €ì¥ í¬ë§·(ì˜ˆ)

- ìŠ¤í‚´: `$argon2id$v=19$m=65536,t=3,p=2$<base64(salt)>$<base64(hash)>`
- ë˜ëŠ” PBKDF2/scryptë„ **íŒŒë¼ë¯¸í„°Â·ì†”íŠ¸**ë¥¼ ëª¨ë‘ **ì¸ì½”ë”©í•´ í•¨ê»˜ ì €ì¥**(ë§ˆì´ê·¸ë ˆì´ì…˜ ìš©ì´)

### ê²€ì¦ íë¦„

1) ì €ì¥ ë¬¸ìì—´ íŒŒì‹± â†’ ì•Œê³ ë¦¬ì¦˜/íŒŒë¼ë¯¸í„°Â·ì†”íŠ¸Â·í•´ì‹œ ì¶”ì¶œ
2) ì…ë ¥ ë¹„ë°€ë²ˆí˜¸ì— **ë™ì¼ íŒŒë¼ë¯¸í„°ë¡œ KDF** â†’ ê²°ê³¼ë¥¼ **ìƒìˆ˜ì‹œê°„ ë¹„êµ**
3) íŒŒë¼ë¯¸í„°ê°€ êµ¬í˜•ì´ë©´ **ì¦ê°€/ë§ˆì´ê·¸ë ˆì´ì…˜**(ë¡œê·¸ì¸ ì‹œ ì¬í•´ì‹œ)

### ì½”ë“œ ìŠ¤ì¼€ì¹˜(PBKDF2 ì˜ˆ)

```python
def store_pbkdf2(password: str):
    salt, iters, dk = pbkdf2_hash(password, iters=600_000)
    # ì €ì¥: algo|iters|salt|hash (base64/hex)
    return {"algo":"pbkdf2-sha256","iters":iters,"salt":salt.hex(),"hash":dk.hex()}

def verify_pbkdf2(password: str, rec):
    salt = bytes.fromhex(rec["salt"])
    dk = bytes.fromhex(rec["hash"])
    ok = pbkdf2_verify(password, salt, rec["iters"], dk)
    # íŒŒë¼ë¯¸í„° ì—…ê·¸ë ˆì´ë“œ ì¡°ê±´
    needs_upgrade = rec["iters"] < 600_000
    return ok, needs_upgrade
```

> **ì¤‘ìš”**:
> - **ì†”íŠ¸ëŠ” ê³„ì •ë§ˆë‹¤ ëœë¤**(â‰¥16B).
> - (ì„ íƒ) **Pepper**: ì„œë²„/ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì—­ ë¹„ë°€(ë³„ë„ ë³´ê´€: KMS/HSM/í™˜ê²½ë³€ìˆ˜)ë¡œ **í•´ì‹œ ì „ HMAC**â€”DB íƒˆì·¨ ì‹œ ì¶”ê°€ ì¥ë²½.
> - **ë¡œê·¸ì— ë¹„ë°€/ì†”íŠ¸/í•´ì‹œ ì €ì¥ ê¸ˆì§€**, ë¤í”„ ë³´í˜¸.

---

## âœ… 4.12 Nonce/IV ìƒì„± ê·œì¹™(AEADÂ·CTR)

- **GCM**: 96ë¹„íŠ¸(12ë°”ì´íŠ¸) Nonce ê¶Œì¥. **ì¤‘ë³µ ê¸ˆì§€**ê°€ ì ˆëŒ€ ê·œì¹™.
  - ë‹¤ì¤‘ ì¸ìŠ¤í„´ìŠ¤/ì»¨í…Œì´ë„ˆ/ì¬ë¶€íŒ… í™˜ê²½ì—ì„œ **ì¶©ëŒ ë°©ì§€ ì„¤ê³„**(ëœë¤+ì¹´ìš´í„°+ë…¸ë“œID ì¡°í•©, í˜¹ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ë§¡ê¸°ê¸°).
- **CTR/ChaCha20**: ë™ì¼ í‚¤ì—ì„œ Nonce ì¶©ëŒ ì‹œ **í‰ë¬¸ XOR ìœ ì¶œ**.
- **CBC**: IVëŠ” **ë¬´ì‘ìœ„**(ì˜ˆì¸¡ ë¶ˆê°€). ë¬´ê²°ì„±ì€ ë³„ë„ë¡œ í™•ë³´í•´ì•¼ í•˜ë¯€ë¡œ **AEAD ìš°ì„ **.

**íŒŒì´ì¬: ì•ˆì „ Nonce ìƒì„±**
```python
import secrets
nonce_gcm = secrets.token_bytes(12)       # 96-bit
nonce_chacha = secrets.token_bytes(12)    # libs vary; ë¼ì´ë¸ŒëŸ¬ë¦¬ ìš”êµ¬ ê¸¸ì´ í™•ì¸
```

> **ê·œì¹™**: NonceëŠ” **ì•ˆì „ APIë¡œ ë§¤ë²ˆ ìƒˆë¡œ ìƒì„±**í•˜ê³ , ì¬ì‚¬ìš© ê¸ˆì§€. ì§ì ‘ ê´€ë¦¬ ëŒ€ì‹  **AEAD ê³ ìˆ˜ì¤€ API**ì— ë§¡ê²¨ë¼.

---

## â€” â€œì¸¡ì •í•˜ê³  ì˜¬ë ¤ë¼â€

> ì•„ë˜ ê°’ë“¤ì€ **ì¶œë°œì **. ëª©í‘œ **ì²´ê° ì‹œê°„**ì„ ì •í•˜ê³ (ì˜ˆ: 100~250ms), **ë””ë°”ì´ìŠ¤ì—ì„œ ì§ì ‘ ì¸¡ì •**í•´ ìµœì¢… ê²°ì •.

### ë¹„ë°€ë²ˆí˜¸ KDF

| í™˜ê²½ | ì¶”ì²œ ìš°ì„ ìˆœìœ„ | íŒŒë¼ë¯¸í„°(ì¶œë°œì ) |
|---|---|---|
| ì„œë²„/ë°ìŠ¤í¬í†± | **Argon2id** > scrypt > PBKDF2 | Argon2id: m=128 MiB, t=3, p=ì½”ì–´/2; scrypt: N=2^16, r=8, p=1; PBKDF2: â‰¥600k(sha256) |
| ëª¨ë°”ì¼(ìƒì¤‘ê¸‰) | **Argon2id** > scrypt > PBKDF2 | Argon2id: m=32~64 MiB, t=2~3, p=1; scrypt: N=2^15, r=8, p=1; PBKDF2: â‰¥300k |
| ì„ë² ë””ë“œ/ë ˆê±°ì‹œ | scrypt or PBKDF2 | scrypt: N=2^14, r=8, p=1(í™˜ê²½ ì œí•œ); PBKDF2: ê°€ëŠ¥í•œ í° ë°˜ë³µ(ì²´ê° 200ms) |

**ì›ì¹™**
- ìƒˆ ì‹œìŠ¤í…œ: **Argon2id** ìš°ì„ .
- **ë©”ëª¨ë¦¬**ë¥¼ ê³µê²©ìì™€ ê°™ì€ ë¹„ìœ¨ë¡œ â€œì†Œëª¨â€í•˜ê²Œ ë§Œë“¤ì–´ GPU/ASIC ì´ë“ì„ ê¹ëŠ”ë‹¤.
- íŒŒë¼ë¯¸í„°ëŠ” **ë²„ì „ ê´€ë¦¬**í•˜ê³  ì£¼ê¸°ì ìœ¼ë¡œ **ìƒí–¥**.

### HKDF

- `salt`ëŠ” **ë…ë¦½ ëœë¤**(ê°€ëŠ¥í•˜ë©´)
- `info`ë¡œ **ë„ë©”ì¸ ë¶„ë¦¬**: `"app:v1:enc"`, `"app:v1:mac"`, `"tls-1.3 exporter"` ë“±

### DRBG/CSPRNG

- **ì§ì ‘ êµ¬í˜„ ê¸ˆì§€**. OS/ë¼ì´ë¸ŒëŸ¬ë¦¬ í˜¸ì¶œ.
- ì¥ì‹œê°„ í”„ë¡œì„¸ìŠ¤ì—ì„œ ì£¼ê¸°ì  **reseed**ëŠ” í”Œë«í¼ì´ ê´€ë¦¬. ë³„ë„ DRBGë¥¼ ë‘ë©´ **ì˜¤íˆë ¤ ìœ„í—˜**.

---

## & ì²´í¬ë¦¬ìŠ¤íŠ¸

**í•¨ì •**
1) `random`/`numpy.random`ìœ¼ë¡œ í‚¤/í† í° ìƒì„± â†’ **ì˜ˆì¸¡ ê°€ëŠ¥**
2) PBKDF2 ì†”íŠ¸ ì¬ì‚¬ìš©/ê³ ì • ì†”íŠ¸ â†’ **ë ˆì¸ë³´ìš° í…Œì´ë¸”** ì¬ë“±ì¥
3) scrypt/Argon2ì—ì„œ **ë©”ëª¨ë¦¬ ë„ˆë¬´ ë‚®ê²Œ** â†’ GPU ì´ë“ ì»¤ì§
4) GCM Nonce ìˆ˜ë™ ê´€ë¦¬ ì¤‘ **ì¶©ëŒ** â†’ **ì¹˜ëª…ì **
5) HKDFì—ì„œ `info` ê³ ì • â†’ ì—¬ëŸ¬ í”„ë¡œí† ì½œ í‚¤ **í˜¼ë™**(í‚¤-ì¬ì‚¬ìš© ë¬¸ì œ)
6) ë¡œê·¸ì— ì†”íŠ¸/í•´ì‹œ/í‚¤/Nonce ì¶œë ¥ â†’ **2ì°¨ ì‚¬ê³ **

**ì²´í¬ë¦¬ìŠ¤íŠ¸**
- [ ] í‚¤/Nonce/í† í°: **`os.urandom`/`secrets`/í”Œë«í¼ CSPRNG**ë§Œ ì‚¬ìš©
- [ ] ë¹„ë°€ë²ˆí˜¸: **Argon2id(ìš°ì„ )**, ì†”íŠ¸ â‰¥16B, íŒŒë¼ë¯¸í„° **ë²„ì „ ê´€ë¦¬/ìƒí–¥**
- [ ] HKDF: **salt ìˆìŒ**, `info`ë¡œ **ë„ë©”ì¸ ë¶„ë¦¬**, ì¶œë ¥ ê¸¸ì´ ì¶©ë¶„
- [ ] AEAD: **Nonce ì¬ì‚¬ìš© ê¸ˆì§€**, ê°€ëŠ¥í•˜ë©´ **ë¼ì´ë¸ŒëŸ¬ë¦¬ ìë™**
- [ ] ì½”ë“œ ë¦¬ë·°: **ìƒìˆ˜ì‹œê°„ ë¹„êµ**, ì—ëŸ¬ ë©”ì‹œì§€/íƒ€ì´ë° ê· ë“±í™”
- [ ] ìš´ì˜: **ë¹„ë°€/ì†”íŠ¸/í‚¤** ë¡œê·¸ ê¸ˆì§€, KMS/HSM ê²€í† , ë¡¤ë§/íšŒì „

---

## âœ… 4.15 ì‹¤ìŠµ ëª¨ìŒ

### ì•ˆì „ í† í° ìƒì„±(ì„¸ì…˜/CSRF)

```python
import secrets
def new_token(nbytes=32) -> str:
    return secrets.token_urlsafe(nbytes)
print(new_token(), new_token())
```

### â€” scrypt ì˜ˆ

```python
import os, hashlib, hmac, json, base64

def scrypt_store(password: str, N=2**15, r=8, p=1, dklen=32) -> str:
    salt = os.urandom(16)
    dk = hashlib.scrypt(password.encode(), salt=salt, n=N, r=r, p=p, dklen=dklen)
    rec = {
        "algo":"scrypt",
        "n":N, "r":r, "p":p, "dklen":dklen,
        "salt": base64.b64encode(salt).decode(),
        "hash": base64.b64encode(dk).decode()
    }
    return json.dumps(rec)

def scrypt_verify_record(password: str, rec_json: str) -> bool:
    rec = json.loads(rec_json)
    salt = base64.b64decode(rec["salt"])
    want = base64.b64decode(rec["hash"])
    cand = hashlib.scrypt(password.encode(), salt=salt, n=rec["n"], r=rec["r"], p=rec["p"], dklen=rec["dklen"])
    return hmac.compare_digest(cand, want)

rec = scrypt_store("S3curePa$$w0rd")
print(rec[:120], "...")
print(scrypt_verify_record("S3curePa$$w0rd", rec))
```

### HKDFë¡œ í‚¤ ë¶„í™”(ì•”í˜¸í™”í‚¤/ì¸ì¦í‚¤)

```python
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
import os

ikm = os.urandom(32)
salt = os.urandom(16)

def hkdf_expand(label: bytes, L=32):
    return HKDF(algorithm=hashes.SHA256(), length=L, salt=salt, info=label).derive(ikm)

k_enc = hkdf_expand(b"app:v1:enc", 32)
k_mac = hkdf_expand(b"app:v1:mac", 32)
print(k_enc != k_mac, len(k_enc), len(k_mac))
```

---

## âœ… 4.16 ìš”ì•½ ì¹´ë“œ

- **ë‚œìˆ˜**ëŠ” ë³´ì•ˆì˜ ì‹¬ì¥ â€” **CSPRNG**ë§Œ ì“°ê³  **ì§ì ‘ ë§Œë“¤ì§€ ë§ë¼**.
- **DRBG**ëŠ” Instantiateâ†’Generateâ†’Reseedâ€”ê·¸ëŸ¬ë‚˜ ì‹¤ì „ì€ **OS RNG** í˜¸ì¶œì´ ì •ë‹µ.
- **KDF**: ë¹„ë°€ë²ˆí˜¸ëŠ” **Argon2id/scrypt**(ë©”ëª¨ë¦¬ í•˜ë“œ), ì„¸ì…˜í‚¤/ë¶„í™”ëŠ” **HKDF**.
- **íŒŒë¼ë¯¸í„°**ëŠ” **ë””ë°”ì´ìŠ¤ì—ì„œ ì¸¡ì •** í›„ ìƒí–¥. ì†”íŠ¸â‰¥16B, ìƒìˆ˜ì‹œê°„ ë¹„êµ, ë¡œê·¸ ë¹„ë°€ ê¸ˆì§€.
- **AEAD Nonce** ì¬ì‚¬ìš© ê¸ˆì§€ â€” ê°€ëŠ¥í•˜ë©´ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— **Nonce ê´€ë¦¬**ë¥¼ ë§¡ê²¨ë¼.

---

## âœ… 4.17 ì—°ìŠµë¬¸ì œ

1) **CSPRNG**ì˜ `backtracking resistance`ì™€ `forward secrecy`ë¥¼ ì˜ˆë¡œ ë“¤ì–´ ì„¤ëª…í•˜ë¼.
2) **PBKDF2 vs scrypt vs Argon2id**ì˜ ì°¨ì´ë¥¼ **ê³µê²©ì ëª¨ë¸(GPU/ASIC/ì¸¡ì±„ë„)** ê´€ì ì—ì„œ ë¹„êµí•˜ë¼.
3) ì„œë²„/ëª¨ë°”ì¼ ê°ê°ì—ì„œ **Argon2id íŒŒë¼ë¯¸í„°**ë¥¼ ì •í•˜ëŠ” ì ˆì°¨(ì¸¡ì •â†’ëª©í‘œ ì‹œê°„â†’ìƒí–¥)ë¥¼ ì„œìˆ í•˜ë¼.
4) **HKDF**ì˜ `salt`Â·`info`ê°€ ì œê³µí•˜ëŠ” ë³´ì•ˆ ì„±ì§ˆ(ë„ë©”ì¸ ë¶„ë¦¬Â·ì¬ì‚¬ìš© ì•ˆì „)ì„ ì„¤ëª…í•˜ë¼.
5) **GCM Nonce** ì¶©ëŒì˜ ìœ„í—˜ì„ ìˆ˜ì‹/ì§ê´€ìœ¼ë¡œ ì„¤ëª…í•˜ê³ , **ì¶©ëŒ ë°©ì§€ ì „ëµ 2ê°€ì§€**ë¥¼ ì œì‹œí•˜ë¼.
