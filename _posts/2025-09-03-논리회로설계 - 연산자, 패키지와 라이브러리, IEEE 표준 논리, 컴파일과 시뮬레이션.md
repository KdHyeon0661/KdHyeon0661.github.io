---
layout: post
title: 논리회로설계 - 연산자, 패키지와 라이브러리, IEEE 표준 논리, 컴파일과 시뮬레이션
date: 2025-09-03 22:25:23 +0900
category: 논리회로설계
---
# VHDL 소개 — **연산자(operators)**, **패키지와 라이브러리**, **IEEE 표준 논리**, **컴파일과 시뮬레이션**

> 권장 기본 선언
> ```vhdl
> library ieee;
> use ieee.std_logic_1164.all;
> use ieee.numeric_std.all;   -- signed/unsigned 연산 표준
> ```
> *주의*: `std_logic_arith`, `std_logic_unsigned/ signed` 등 **비표준/벤더 확장**은 혼용하지 않는 것이 좋습니다. (표준은 `numeric_std`)

---

## 1) VHDL **연산자** 총정리

### 1.1 분류와 개요
- **논리(logical)**: `and or nand nor xor xnor not`
- **관계(relational)**: `= /= < <= > >=`
- **산술(arithmetic)**: `+ - * /` (정수/실수, `signed/unsigned`), `mod rem`(정수)
- **부호/절대(unary)**: `+ - abs`
- **연결(concatenation)**: `&`
- **시프트/회전(shift/rotate)**: `sll srl sla sra rol ror` (벡터류), 또한 `numeric_std`의 함수 `shift_left/right`, `rotate_left/right`
- **기타**: 전개·집합형 **aggregate** `(others => '0')`, 조건 연산은 *연산자*가 아니라 `when-else`, `with-select`, `if/case`

### 1.2 **우선순위(Precedence)** — 높은 것 → 낮은 것
1) `**` (거듭제곱; 주로 실수/정수)  
2) `abs`, 단항 `not`, 단항 `+ -`  
3) `* / mod rem`  
4) `+ - &`  *(연결 `&`도 이 레벨)*  
5) `sll srl sla sra rol ror`  
6) `= /= < <= > >=`  
7) `and`  
8) `or xor`  
9) `nand nor xnor`
> 괄호로 우선순위를 명확히 하십시오. 특히 `&`와 `+`가 섞일 때 실수가 잦습니다.

### 1.3 **타입별 연산 핵심**
- **`std_logic_vector`**: **연결 `&`**, **시프트·회전**(연산자), **비트 논리**(and/or/…)에 적합. **산술은 불가** → `unsigned/signed`로 캐스팅.
- **`unsigned`, `signed`** (`numeric_std`): **산술/관계 연산**(+, -, *, <, …) 정의. **시프트/회전**은 연산자(`sll/srl/…`)도 도구가 지원하나 표준적으로는 **함수** `shift_left/right`, `rotate_left/right`를 권장.
- **정수/실수(`integer/real`)**: 산술/관계 가능. 하드웨어 합성은 주로 정수 범위에서.

### 1.4 **형 변환 패턴**
```vhdl
-- 덧셈: std_logic_vector → unsigned로
y <= std_logic_vector( unsigned(a) + unsigned(b) );

-- 부호 있는 연산
s <= std_logic_vector( signed(a) + signed(b) );

-- 폭 변경(부호/제로 확장) - numeric_std
wide  <= std_logic_vector( resize(unsigned(a), 16) );  -- zero-extend
wideS <= std_logic_vector( resize(signed(a),   16) );  -- sign-extend
```

### 1.5 **시프트/회전** 예시
```vhdl
-- std_logic_vector: 시프트/회전 연산자
y <= x sll 3;   -- 왼쪽 논리 시프트
y <= x sra 1;   -- 오른쪽 산술 시프트(부호 유지; 벡터 최상위 비트 확장)

-- unsigned/signed: 함수 사용 권장
u2 <= std_logic_vector( shift_left (unsigned(u1), 2) );
s2 <= std_logic_vector( shift_right(signed(s1),   1) ); -- 산술 시프트
r  <= std_logic_vector( rotate_left(unsigned(u1), 3) );
```

### 1.6 **관계/논리** 예시와 주의
```vhdl
-- 관계: 타입 맞추기
flag <= '1' when signed(a) < signed(b) else '0';

-- 논리: 벡터/스칼라 모두 가능
y <= (a and b) or (not c);
```
- `std_logic`는 9값('U','X','0','1','Z','W','L','H','-')을 가짐. 비교 `=`는 **같은 글자면 TRUE**입니다(예: 'U'='U'는 TRUE). “don't care” 매칭은 **연산자 없음** → `std_match`(함수) 사용.

### 1.7 **연결 `&` / 집합형 aggregate**
```vhdl
word <= a & b;                    -- 연결
pad  <= (15 downto 8 => '0', 7 downto 0 => data);  -- 부분 지정
zeros <= (others => '0');         -- 폭 전체 초기화
```

### 1.8 **`std_match`/패턴 매칭** (std_logic_1164)
```vhdl
-- '-'를 don't care로 사용하는 패턴 매칭
ok <= '1' when std_match(code, "1-0-") else '0';
```

---

## 2) **패키지(package)** 와 **라이브러리(library)**

### 2.1 개념
- **라이브러리**: **설계 단위들의 저장소**(디렉터리/아카이브 개념). 기본: `work`(현재 프로젝트), `ieee`, `std` 등.
- **패키지**: 타입/상수/함수/연산자 오버로딩/컴포넌트 선언의 **모음**. `package`/`package body` 쌍.

### 2.2 선언·사용 문법
```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- 사용자 패키지
library work;
use work.my_pkg.all;
```

### 2.3 사용자 **패키지** 예 (타입/상수/함수)
```vhdl
package my_pkg is
  subtype byte  is std_logic_vector(7 downto 0);
  type    slv_array_t is array (natural range <>) of std_logic_vector;
  constant VERSION : natural := 1;

  function popcount(u : unsigned) return natural;
end package;

package body my_pkg is
  function popcount(u : unsigned) return natural is
    variable c : natural := 0;
  begin
    for i in u'range loop
      if u(i) = '1' then c := c + 1; end if;
    end loop;
    return c;
  end;
end package body;
```
- **컴파일 순서**: `my_pkg` → `my_pkg` **body** → 해당 패키지를 **use**하는 엔티티/아키텍처.
- **오버로딩**: 같은 이름의 함수/연산자를 타입 시그니처로 구분(예: `+`를 `unsigned`·`signed`에 각각 정의한 것이 `numeric_std`).

### 2.4 VHDL-2008 **컨텍스트(Context)** (편의)
```vhdl
context my_ctx is
  library ieee;
  use ieee.std_logic_1164.all, ieee.numeric_std.all;
end context;

-- 사용
context my_ctx;  -- 파일 머리에 한 줄로 동등 효과
```

---

## 3) **IEEE 표준 논리** (std_logic_1164) & 수치(`numeric_std`)

### 3.1 `std_logic_1164` — 9값 로직과 해상(Resolution)
- **값**:  
  `U`(초기화 안됨), `X`(알 수 없음), `0`(강한 0), `1`(강한 1),  
  `Z`(하이임피던스), `W`(약한 알수없음), `L`(약한 0), `H`(약한 1), `-`(don't care, 시뮬용)
- **`std_ulogic` vs `std_logic`**  
  - `std_ulogic`: **미해상**. 하나의 드라이버만 허용 → **안전**.  
  - `std_logic`: **해상(resolved)**. 다중 드라이버를 **해상 함수**로 병합(버스/3-state 모델링).
- **핵심 유틸**:
  - `rising_edge(sig)`, `falling_edge(sig)` — 클록 에지 검출(메타값 필터 포함)
  - `std_match(vec, pattern)` — `'-'` 패턴 매칭
  - `to_x01`, `to_x01z`, `to_ux01` — X/Z 정규화 함수(시뮬/검증용)

### 3.2 `numeric_std` — **정수형 비트벡터** 표준
- **타입**: `unsigned`, `signed` (둘 다 `std_logic_vector`와 동일한 비트 저장 구조, **의미만 다름**)
- **변환**:
  - `to_integer(unsigned(..))`, `to_unsigned(i, WIDTH)`, `to_signed(i, WIDTH)`
- **산술/비교**: `+ - * /`, `< <= > >= = /=` (부호 고려)
- **크기 변경**: `resize(signed/unsigned, new_len)`
- **시프트/회전 함수**: `shift_left/right`, `rotate_left/right`
- **주의**: 산술하려면 **반드시** `unsigned`/`signed`로 **캐스팅** 후 연산.

### 3.3 `numeric_bit` (참고)
- `bit/bit_vector` 기반(2값) 수치 패키지. 섞어 쓰기 드묾.

### 3.4 시계/에지 검출 예
```vhdl
process(clk) is
begin
  if rising_edge(clk) then
    q <= d;
  end if;
end process;
```

---

## 4) **컴파일(Analyze)과 시뮬레이션(Elaborate/Run)**

### 4.1 개념적 단계
1) **분석(Analyze/Compile)**: 소스 파싱 → 라이브러리에 유닛 저장 (`work` 등)
2) **정교(Elaboration)**: **엔티티-아키텍처 바인딩**, 제네릭 적용, 인스턴스 계층 구성
3) **시뮬레이션(Run)**: 시간/델타 사이클 이벤트 구동, 파형/메시지 출력

### 4.2 **델타 사이클(delta cycle)** & 지연
- **델타 사이클**: 같은 물리 시간에서 **신호 할당 전파 순서**를 정하는 미세 단계.  
  → 조합 프로세스 여러 개가 상호 의존해도 안정점에 도달할 때까지 **델타 반복**.
- **지연 종류**
  - **관성(inertial)**: 짧은 펄스 제거(게이트처럼). *기본 동작*  
    `y <= a after 2 ns;             -- inertial (기본)`  
    `y <= reject 1 ns inertial a after 2 ns;`  (*1ns 미만 펄스 거부*)
  - **수송(transport)**: 펄스 그대로 전달(배선 모델)  
    `y <= transport a after 2 ns;`
> 합성 대상 RTL에는 `after`, `wait for` 등 **시간 제어를 넣지 않습니다**. 테스트벤치에서만.

### 4.3 **테스트벤치** 패턴
- **자극 생성**: `process` + `wait for`, 또는 클록 생성 `wait until rising_edge(clk)`
- **검증**: `assert ... report ... severity ...`
- **파일 I/O**: `textio`, `std_logic_textio` (벡터 입출력)
- **종료**: VHDL-2008 `std.env.finish;` 또는 `assert false report "done" severity failure;`

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;

entity tb is end;
architecture sim of tb is
  signal a,b : std_logic_vector(7 downto 0);
  signal s   : std_logic_vector(8 downto 0);
begin
  -- DUT
  dut: entity work.adder
    port map(a=>a, b=>b, s=>s);

  -- stimulus
  process
  begin
    a <= x"0F"; b <= x"01"; wait for 10 ns;
    assert s = std_logic_vector(('0' & unsigned(x"0F")) + unsigned(x"01"))
      report "Mismatch!" severity error;
    std.env.finish;
  end process;
end;
```

### 4.4 **컴파일/실행 예(도구 무관 개념)**

- **GHDL (오픈소스)**
  ```sh
  ghdl -a my_pkg.vhd adder.vhd tb.vhd     # Analyze
  ghdl -e tb                               # Elaborate
  ghdl -r tb --vcd=wave.vcd                # Run + dump
  ```

- **ModelSim/Questa**
  ```tcl
  vlib work
  vcom my_pkg.vhd adder.vhd tb.vhd
  vsim work.tb
  add wave *
  run -all
  ```

- **Vivado 시뮬레이터**
  ```tcl
  xvhdl my_pkg.vhd adder.vhd tb.vhd
  xelab tb -debug typical
  xsim  tb -runall
  ```

### 4.5 **합성 친화 규칙 요약**
- 조합: `process(all)` + **완전할당**(기본값/`others`) → 래치 방지
- 산술: `numeric_std`의 `signed/unsigned` 사용, **형변환 명시**
- 지연 명시 금지(RTL): `after`, `wait for` 등은 테스트벤치에서만
- 3상태는 **I/O**에서만. 내부는 MUX로 합성됨(대부분의 FPGA)

---

## 5) 자주 쓰는 **스니펫** 모음

### 5.1 산술/비교 안전 템플릿
```vhdl
signal a,b : std_logic_vector(15 downto 0);
signal lt   : std_logic;

lt <= '1' when signed(a) < signed(b) else '0';
sum <= std_logic_vector( resize(unsigned(a), 17) + resize(unsigned(b), 17) );
```

### 5.2 시프트/마스킹
```vhdl
signal x,y : std_logic_vector(31 downto 0);
y <= x srl 8;                                    -- 우 논리 시프트
mask <= (31 downto 16 => '1', others => '0');    -- 마스크
```

### 5.3 `std_match`와 패턴
```vhdl
is_hex <= '1' when std_match(ch, "0011----") else '0';  -- '3x' 범위
```

### 5.4 패키지/컨텍스트로 헤더 단순화
```vhdl
-- ctx.vhd
context ctx is
  library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
end context;

-- 소스 파일 상단
context ctx;
```

---

## 6) **디버깅/품질** 체크리스트

- [ ] `library/use` 는 **파일 맨 위**에, 패키지/바디는 **먼저 컴파일**했는가?  
- [ ] 조합 프로세스는 `process(all)`를 사용했는가? (민감도 누락 방지)  
- [ ] 모든 출력이 **모든 경로에서 할당**되는가? (`others`/기본값)  
- [ ] 산술 전에 `signed/unsigned`로 **명시 캐스팅**했는가?  
- [ ] `&`(연결)과 `+` 혼용 시 **괄호**로 의도 명시했는가?  
- [ ] 테스트벤치에 `assert`와 **파형 덤프**를 넣었는가?  
- [ ] 시뮬은 **기능→타이밍** 순으로, 합성은 비표준 라이브러리 **금지**로 일관성을 유지했는가?

---

### 포켓 요약
- **연산자**: 논리/관계/산술/시프트/연결. 우선순위 숙지, 산술은 `signed/unsigned`.  
- **패키지·라이브러리**: `ieee`(표준), `work`(프로젝트). 사용자 패키지로 타입·함수 공유.  
- **표준 논리**: `std_logic(9값)`과 해상, `numeric_std`로 안전한 수치 연산.  
- **컴파일·시뮬**: Analyze→Elab→Run, 델타·지연 개념 이해, 테스트벤치/`assert`로 검증.