---
layout: post
title: 논리회로설계 - 연산자, 패키지와 라이브러리, IEEE 표준 논리, 컴파일과 시뮬레이션
date: 2025-09-03 22:25:23 +0900
category: 논리회로설계
---
# VHDL 소개 — **연산자(operators)**, **패키지와 라이브러리**, **IEEE 표준 논리**, **컴파일과 시뮬레이션**

> 권장 기본 선언
> ```vhdl
> library ieee;
> use ieee.std_logic_1164.all;
> use ieee.numeric_std.all;   -- signed/unsigned 연산 표준
> ```
> *주의*: `std_logic_arith`, `std_logic_unsigned/signed` 등 비표준/벤더 확장은 혼용하지 않는 것을 권장합니다(표준은 `numeric_std`).

---

## VHDL **연산자** 총정리

### 분류와 개요

- **논리(logical)**: `and or nand nor xor xnor not`
- **관계(relational)**: `= /= < <= > >=`
- **산술(arithmetic)**: `+ - * /` (정수/실수, `signed/unsigned`), `mod rem`(정수)
- **부호/절대(unary)**: `+ - abs`
- **연결(concatenation)**: `&`
- **시프트/회전(shift/rotate)**: `sll srl sla sra rol ror` (벡터류), `numeric_std`의 `shift_left/right`, `rotate_left/right`
- **그 밖에**: 집합형 **aggregate** (`(others => '0')`), 조건은 연산자가 아니라 `when-else`, `with-select`, `if/case`

### **우선순위(Precedence)** — 높은 것 → 낮은 것

1) `**`
2) `abs`, 단항 `not`, 단항 `+ -`
3) `* / mod rem`
4) `+ - &` *(연결 `&`도 이 레벨)*
5) `sll srl sla sra rol ror`
6) `= /= < <= > >=`
7) `and`
8) `or xor`
9) `nand nor xnor`

> 팁: `&`와 `+`가 섞이면 항상 괄호로 의도를 명확히 하세요.

### 타입별 연산 핵심

- **`std_logic_vector`**: 비트 논리/연결/시프트에 적합. **산술 없음** → `unsigned/signed`로 변환 후 연산.
- **`unsigned`, `signed`** (`numeric_std`): 산술/관계/비교 정의. 시프트·회전은 연산자도 되지만 **함수** 사용을 권장.
- **정수/실수(`integer/real`)**: 산술/관계 가능(합성은 정수 위주).

### 형 변환 패턴(안전 스니펫)

```vhdl
-- 덧셈: std_logic_vector → unsigned
sum_u <= std_logic_vector(unsigned(a) + unsigned(b));

-- 부호 연산
sum_s <= std_logic_vector(signed(a) + signed(b));

-- 폭 변경(제로/사인 확장)
wide_u <= std_logic_vector(resize(unsigned(a), 16));
wide_s <= std_logic_vector(resize(signed(a),   16));

-- 비교
lt <= '1' when signed(a) < signed(b) else '0';
```

### 시프트/회전 예시

```vhdl
-- std_logic_vector: 연산자 기반
y <= x sll 3;    -- 왼쪽 논리 시프트
y <= x sra 1;    -- 오른쪽 산술 시프트(부호 유지)

-- unsigned/signed: 함수 기반(권장)
u2 <= std_logic_vector(shift_left (unsigned(u1), 2));
s2 <= std_logic_vector(shift_right(signed(s1),   1));
r  <= std_logic_vector(rotate_left(unsigned(u1), 3));
```

### 관계/논리 예시와 주의

```vhdl
-- 관계: 타입 일치가 필요
flag <= '1' when signed(a) < signed(b) else '0';

-- 논리: 벡터/스칼라 가능
y <= (a and b) or (not c);
```
- `std_logic`는 9값('U','X','0','1','Z','W','L','H','-')을 가짐. `=` 비교는 **문자 동일**여부를 확인합니다. `'-'`를 don't care로 쓰려면 **연산자**가 아니라 `std_match` 함수를 사용합니다.

### 연결 `&` / 집합형 aggregate

```vhdl
word  <= a & b;                                         -- 연결
pad   <= (15 downto 8 => '0', 7 downto 0 => data);      -- 부분 지정
zeros <= (others => '0');                                -- 전체 초기화
```

### `std_match`/패턴 매칭 (`std_logic_1164`)

```vhdl
ok <= '1' when std_match(code, "1-0-") else '0';  -- '-'는 don't care
```

### 선택형 할당(요약)

```vhdl
-- 조건부 신호할당
y <= d0 when sel="00" else
     d1 when sel="01" else
     d2 when sel="10" else d3;

-- with-select
with sel select
  y <= d0 when "00",
       d1 when "01",
       d2 when "10",
       d3 when others;
```

---

## **패키지(package)** 와 **라이브러리(library)**

### 개념

- **라이브러리**: 설계 단위 저장소(기본: `work`, `ieee`, `std`).
- **패키지**: 타입/상수/함수/연산자 오버로딩/컴포넌트 선언의 묶음(`package`/`package body`).

### 선언·사용 문법

```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.my_pkg.all;
```

### 사용자 패키지(타입/함수) 예

```vhdl
package my_pkg is
  subtype byte is std_logic_vector(7 downto 0);
  type slv_array_t is array (natural range <>) of std_logic_vector;
  constant VERSION : natural := 1;

  function popcount(u : unsigned) return natural;
end package;

package body my_pkg is
  function popcount(u : unsigned) return natural is
    variable c : natural := 0;
  begin
    for i in u'range loop
      if u(i) = '1' then c := c + 1; end if;
    end loop;
    return c;
  end function;
end package body;
```
- **컴파일 순서**: 패키지 → 패키지 body → 이를 `use`하는 설계.
- **오버로딩**: 동일 이름 함수/연산자를 타입 시그니처로 구분.

### (VHDL-2008) **컨텍스트(Context)** — 헤더 간소화

```vhdl
context ctx is
  library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
end context;

-- 사용
context ctx;
```

### (VHDL-2008) **제네릭 패키지** 빠른 예

```vhdl
package vec_ops is
  generic (W : positive := 8);
  function add(a,b : unsigned(W-1 downto 0)) return unsigned;
end package;

package body vec_ops is
  function add(a,b : unsigned) return unsigned is
  begin
    return resize(a, a'length+1) + resize(b, b'length+1);
  end;
end package body;
```

---

## **IEEE 표준 논리**(std_logic_1164) & **수치**(numeric_std)

### `std_logic_1164` — 9값 로직/해상(Resolution)

- **9값**: `U, X, 0, 1, Z, W, L, H, -`
- **`std_ulogic` vs `std_logic`**
  - `std_ulogic`는 **미해상형**(단일 드라이버 강제 → 더 안전)
  - `std_logic`은 **해상형**(여러 드라이버를 해상 함수로 병합 → 버스/3상태 모델링 가능)
- **유틸**: `rising_edge`, `falling_edge`, `std_match`, `to_x01`/`to_x01z` 등

### `numeric_std` — 정수형 비트벡터 표준

- **타입**: `unsigned`, `signed`
- **변환**: `to_integer(unsigned(x))`, `to_unsigned(i, W)`, `to_signed(i, W)`
- **폭 변경**: `resize(signed/unsigned, new_len)`
- **시프트/회전**: `shift_left/right`, `rotate_left/right`
- **원칙**: 산술 전에는 **반드시** `unsigned/signed`로 캐스팅

### (참고) `numeric_bit`

- `bit/bit_vector` 기반 2값 수치 패키지(섞어 쓰는 일 드묾).

### 에지 검출 예

```vhdl
process(clk) is
begin
  if rising_edge(clk) then
    q <= d;
  end if;
end process;
```

---

## **컴파일(Analyze) & 시뮬레이션(Elaborate/Run)**

### 단계

1) **Analyze(Compile)**: 파일 파싱/검사 → 라이브러리(`work`)에 등록
2) **Elaboration**: 엔티티–아키텍처 바인딩, 제네릭 적용, 인스턴스 계층 구성
3) **Run**: 이벤트/델타 사이클 구동, 파형/메시지 출력

### **델타 사이클(delta cycle)** & 지연

- **델타 사이클**: 같은 물리 시각에서 **신호 할당의 전파 순서**를 풀기 위한 미세 단계. 조합 프로세스가 상호 의존해도 **안정점**에 도달할 때까지 델타 반복 후 다음 시간으로 진행.
- **지연**
  - **관성(inertial)**: 짧은 펄스 제거(게이트 모델, 기본 동작)
    ```vhdl
    y <= a after 2 ns;                     -- inertial
    y <= reject 1 ns inertial a after 2 ns;-- 1ns 미만 펄스 거부
    ```
  - **수송(transport)**: 펄스를 그대로 전달(배선 모델)
    ```vhdl
    y <= transport a after 2 ns;
    ```
> 합성용 RTL에는 `after`, `wait for` 같은 시간 제어를 넣지 않습니다(테스트벤치 전용).

### 테스트벤치 패턴(자극·검증·파일 I/O)

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;

entity tb is end;
architecture sim of tb is
  signal a,b : std_logic_vector(7 downto 0);
  signal s   : std_logic_vector(8 downto 0);
begin
  dut: entity work.adder port map(a=>a, b=>b, s=>s);

  process
  begin
    a <= x"0F"; b <= x"01"; wait for 10 ns;
    assert s = std_logic_vector(('0' & unsigned(x"0F")) + unsigned(x"01"))
      report "Mismatch!" severity error;
    std.env.finish;  -- VHDL-2008
  end process;
end;
```

- **TEXTIO**로 벡터를 파일에서 읽어오는 골격:
```vhdl
library std; use std.textio.all;
library ieee; use ieee.std_logic_textio.all;

-- 파일 선언: file vecs : text open read_mode is "vectors.txt";
-- readline(vecs, L);  read(L, slv_value);
```

### 도구별 명령(개념적 예)

```sh
# GHDL

ghdl -a my_pkg.vhd adder.vhd tb.vhd   # Analyze
ghdl -e tb                             # Elaborate
ghdl -r tb --vcd=wave.vcd              # Run + VCD

# ModelSim/Questa (Tcl)

vlib work
vcom my_pkg.vhd adder.vhd tb.vhd
vsim work.tb
add wave *
run -all

# Vivado Simulator (Tcl)

xvhdl my_pkg.vhd adder.vhd tb.vhd
xelab tb -debug typical
xsim  tb -runall
```

---

## **합성 친화** 규칙·스니펫

### 조합 논리: 완전할당 + `process(all)`

```vhdl
process(all) is
begin
  y <= (others => '0');               -- 기본값
  if sel='1' then y <= a or b; end if;
end process;                          -- 래치 인퍼런스 방지
```

### 산술: `numeric_std`만 사용

```vhdl
sum <= std_logic_vector(resize(unsigned(a),17) + resize(unsigned(b),17));
lt  <= '1' when signed(a) < signed(b) else '0';
```

### 시프트/마스킹

```vhdl
y    <= x srl 8;
mask <= (31 downto 16 => '1', others => '0');
```

### 3상태는 **I/O**에서만 (내부는 MUX로 합성)

- 현대 FPGA 내부는 대개 **참 3상태**를 지원하지 않으며, 동작상 **멀티플렉서**로 대체됩니다.

### 엔티티 직접 인스턴스 vs 컴포넌트

```vhdl
-- 직접 인스턴스 (권장)
u_add: entity work.add8(rtl) port map(...);

-- 컴포넌트 선언/바인딩(레거시 호환)
component add8 port (...); end component;
```

---

## **디버깅/품질** 체크리스트

- [ ] `library/use`는 파일 맨 위에 정리되었는가?
- [ ] 패키지/바디를 먼저 컴파일했는가?
- [ ] 조합 프로세스는 `process(all)` + **모든 경로 할당**(기본값/`others`)인가?
- [ ] 산술 전 `unsigned/signed`로 **명시 캐스팅**했는가?
- [ ] `&`와 `+` 혼용 시 괄호로 의도를 명확히 했는가?
- [ ] 테스트벤치에 `assert`와 파형 덤프를 넣었는가?
- [ ] 시뮬은 기능→타이밍 순으로, 합성은 비표준 패키지 사용을 피했는가?
- [ ] 내부 3상태 지양, 버스는 MUX/레지스터로 구성했는가?

---

## 심화 주제 — 델타 사이클/변수 vs 신호/관성·수송(짧은 예제)

### 변수(`:=`) vs 신호(`<=`)

```vhdl
signal s : std_logic_vector(3 downto 0);

process(all) is
  variable v : std_logic_vector(3 downto 0);
begin
  v := s;            -- 변수는 즉시 갱신
  v(0) := '1';
  s <= v;            -- 신호는 '이번 델타' 종료 후 스케줄
end process;
```
- **규칙**: 조합 계산엔 변수 임시값, 외부로 나가는 것은 신호 할당(순서·의도 명료화).

### 관성 vs 수송

```vhdl
y_inertial  <= a after 2 ns;                       -- 관성: 짧은 펄스 소거
y_transport <= transport a after 2 ns;             -- 수송: 펄스 보존
```

---

## 실습: 8비트 가산기·패턴체커·테스트벤치

### 8비트 가산기(캐리 인/아웃)

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity add8 is
  port(a,b : in  std_logic_vector(7 downto 0);
       cin : in  std_logic;
       s   : out std_logic_vector(7 downto 0);
       cout: out std_logic);
end;

architecture rtl of add8 is
  signal w : unsigned(8 downto 0);
begin
  w    <= ('0' & unsigned(a)) + ('0' & unsigned(b)) + (0 to 8 => '0');
  s    <= std_logic_vector(w(7 downto 0)) when cin='0' else
          std_logic_vector(w(7 downto 0) + 1);
  cout <= std_logic(w(8)) when cin='0' else
          std_logic( (w + 1)(8) );
end;
```

### `std_match`로 프레임 헤더 검사

```vhdl
hdr_ok <= '1' when std_match(hdr, "1010----") else '0';
```

### 테스트벤치(전수검사 예시, GHDL/Questa 공용)

```vhdl
-- tb_add8.vhd
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity tb is end;
architecture sim of tb is
  signal a,b : std_logic_vector(7 downto 0);
  signal s   : std_logic_vector(7 downto 0);
  signal cin,cout : std_logic;
begin
  dut: entity work.add8 port map(a=>a,b=>b,cin=>cin,s=>s,cout=>cout);

  process
    variable ref : unsigned(8 downto 0);
  begin
    cin <= '0';
    for i in 0 to 255 loop
      for j in 0 to 255 loop
        a <= std_logic_vector(to_unsigned(i,8));
        b <= std_logic_vector(to_unsigned(j,8));
        wait for 1 ns;
        ref := to_unsigned(i,9) + to_unsigned(j,9);
        assert (unsigned(s) = ref(7 downto 0)) and (cout = std_logic(ref(8)))
          report "Mismatch at " & integer'image(i) & "," & integer'image(j) severity error;
      end loop;
    end loop;
    std.env.finish;
  end process;
end;
```

---

## 포켓 요약

- **연산자**: 논리/관계/산술/시프트/연결 — 우선순위 숙지, 산술은 `signed/unsigned`.
- **패키지·라이브러리**: `ieee.std_logic_1164`(9값/해상), `ieee.numeric_std`(정수형 벡터).
- **시뮬레이션**: Analyze→Elaborate→Run, **델타 사이클**·관성/수송 지연 이해.
- **합성 규칙**: 비표준 패키지 지양, `process(all)` + 완전할당, 내부 tri-state 지양.

---

### 부록: 아주 간단한 수식 메모

- **우선순위 레벨**을 \(p(\cdot)\)라 하면, 예를 들어
  $$ p(**) > p(\text{unary}) > p(*,/,mod,rem) > p(+,-,\&) > p(\text{shift/rotate}) > p(\text{rel}) > p(\text{and}) > p(\text{or,xor}) > p(\text{nand,nor,xnor}) $$
- **델타 사이클**은 물리 시간 \(t\)에서의 **순서 해결 단계**로, \((t,\delta)\)가 안정될 때 \((t,\delta+1)\to(t,\delta)\) 수렴 후 다음 시간 \(t+\Delta t\)로 진행합니다.
