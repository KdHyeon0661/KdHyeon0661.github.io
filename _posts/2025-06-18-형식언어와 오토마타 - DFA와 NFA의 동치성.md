---
layout: post
title: 형식언어와 오토마타 - DFA와 NFA의 동치성
date: 2025-06-18 20:20:23 +0900
category: 형식언어와 오토마타
---
# 결정적 유한 인식기(DFA)와 비결정적 유한 인식기(NFA)의 동치성

정규 언어 이론에서 가장 핵심적인 사실 중 하나는 다음과 같습니다:

> **모든 NFA는 동치인 DFA로 변환 가능하며, 그 반대도 성립한다.**  
> 즉, DFA와 NFA는 **정규 언어**만을 인식하며 **표현력은 동등**하다.

이 글에서는 DFA와 NFA의 동치성을 수학적으로 정리하고, 변환 알고리즘 및 예제를 통해 그 과정을 구체적으로 설명합니다.

---

## 1. DFA와 NFA의 차이 요약

| 항목 | DFA | NFA |
|------|-----|-----|
| 전이 함수 \\( \delta \\) | 단일 상태로 전이 | 상태 집합으로 전이 |
| 결정성 | 입력마다 유일한 경로 | 여러 경로 허용 |
| ε-이동 | 불가 | ε-NFA는 허용 |
| 인식 방식 | 단일 경로가 수용 상태 도달 | 하나 이상의 경로만 수용되면 OK |

---

## 2. 동치성 정리

> **정리(Theorem):**  
> 임의의 NFA \\( N \\)에 대해, 동일한 언어를 인식하는 DFA \\( D \\)가 존재한다.  
> 즉, \\( L(N) = L(D) \\)

이 정리는 다음을 의미합니다:

- 비결정성은 **이론적인 단순화 도구**일 뿐, 인식 능력의 확장이 아님
- DFA와 NFA는 같은 정규 언어 클래스 \\( \mathcal{L}_{\text{REG}} \\)를 정의함

---

## 3. 변환 방법: NFA → DFA (Subset Construction)

이 알고리즘은 NFA의 모든 가능한 상태 집합을 DFA의 하나의 상태로 취급하여 변환합니다. 핵심 아이디어는:

> **DFA의 각 상태는 NFA 상태들의 집합이다.**

### 3.1 변환 알고리즘

#### NFA 정의
\\[
N = (Q_N, \Sigma, \delta_N, q_0, F_N)
\\]

#### DFA 정의
\\[
D = (Q_D, \Sigma, \delta_D, q_0', F_D)
\\]

- \\( Q_D = \mathcal{P}(Q_N) \\) : NFA 상태의 멱집합
- \\( q_0' = \{ q_0 \} \\) 또는 ε-closure로 확장
- 전이 함수:

\\[
\delta_D(S, a) = \bigcup_{q \in S} \delta_N(q, a)
\\]

- 종료 상태:

\\[
F_D = \{ S \subseteq Q_N \mid S \cap F_N \ne \emptyset \}
\\]

즉, 어떤 NFA 상태 집합이 종료 상태를 하나라도 포함하면, 해당 DFA 상태도 종료 상태로 간주합니다.

---

## 4. 예제

### 4.1 NFA 예시

언어 \\( L = \{ w \in \{a, b\}^* \mid w \text{에 } ab \text{가 포함됨} \} \\)

#### 상태 및 전이:

```text
Q = {q0, q1, q2}
Σ = {a, b}
q0: 시작 상태
F = {q2}

δ:
  δ(q0, a) = {q0, q1}
  δ(q0, b) = {q0}
  δ(q1, b) = {q2}
```

### 4.2 DFA로 변환 (상태 집합 구성)

DFA의 상태는 NFA 상태들의 집합:

- \\( \{q0\} \\)
- \\( \{q0, q1\} \\)
- \\( \{q2\} \\)
- \\( \{q0, q2\} \\)
- ...

이러한 상태들을 기준으로 DFA의 전이 함수를 구성하면 DFA가 완성됩니다. 실제로는 **최소 필요 상태들만 생성**되며, 사용되지 않는 상태는 생략됩니다.

---

## 5. DFA와 NFA의 언어 동치성 증명 개요

### 5.1 \\( L(NFA) \subseteq L(DFA) \\)

변환된 DFA는 NFA의 모든 가능한 실행 경로를 추적하므로, NFA가 수용하는 문자열은 DFA도 반드시 수용합니다.

### 5.2 \\( L(DFA) \subseteq L(NFA) \\)

DFA는 모든 실행 경로를 정해진 하나의 경로로 계산하지만, 이는 원래 NFA에서 가능한 경로들의 조합을 그대로 따릅니다. DFA가 수용하는 문자열은 NFA에서도 가능한 경로를 따라 수용됩니다.

결론: \\( L(N) = L(D) \\)

---

## 6. 실용적 시사점

- 이론적으로는 NFA보다 DFA가 항상 **더 강력**하거나 **덜 강력**하지 않음
- 하지만 실무에서는 NFA가 표현은 간결하고, DFA가 실행은 빠름
  - NFA: 정규 표현식 컴파일 시 중간 구조
  - DFA: 실제 런타임에서 빠르게 판단

---

## 7. 요약

| 구분 | DFA | NFA |
|------|-----|-----|
| 전이 함수 | 단일 상태 | 다중 상태 (집합) |
| 표현력 | 정규 언어 | 정규 언어 |
| 변환 가능성 | NFA → DFA 가능 (subset construction) |
| 실행 방식 | 결정적 (유일한 경로) | 비결정적 (여러 경로 중 하나) |

> **결론:**  
> DFA와 NFA는 **정규 언어를 인식하는 데 동등한 계산 모델**입니다.  
> NFA는 표현의 유연함을 제공하고, DFA는 효율적인 실행을 제공합니다.