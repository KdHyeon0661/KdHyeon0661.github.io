---
layout: post
title: 형식언어와 오토마타 - DFA와 NFA의 동치성
date: 2025-06-18 20:20:23 +0900
category: 형식언어와 오토마타
---
# 결정적 유한 인식기(DFA)와 비결정적 유한 인식기(NFA)의 동치성

정규 언어 이론의 핵심 사실:

> **모든 NFA는 동치인 DFA로 변환 가능하고, 반대로 모든 DFA는 (자명하게) NFA로 볼 수 있다.**
> 따라서 DFA와 NFA는 **정규 언어(Regular Languages)**만을 인식하며 **표현력은 동등**하다.

---

## 표기(Notation) 및 합의

- 알파벳: $$\Sigma$$ (유한 집합)
- 문자열: $$w\in\Sigma^\*$$, 길이 $$|w|$$, 공백 $$\varepsilon$$
- 언어: $$L\subseteq\Sigma^\*$$
- DFA: $$D=(Q_D,\Sigma,\delta_D,q_0,F_D)$$, 전이 $$\delta_D:Q_D\times\Sigma\to Q_D$$
- NFA(ε-허용): $$N=(Q_N,\Sigma,\Delta,q_0,F_N)$$, 전이 $$\Delta:Q_N\times(\Sigma\cup\{\varepsilon\})\to \mathcal P(Q_N)$$
- ε-폐포(closure): $$\text{ECl}(S)=\{q\in Q_N \mid S\text{에서 ε-이동만으로 }q\text{에 도달}\}$$

---

## DFA와 NFA의 차이 (요약 표)

| 항목 | DFA | NFA |
|---|---|---|
| 전이 | 상태 하나로 전이: $$\delta(q,a)=q'$$ | 상태 **집합**으로 전이: $$\Delta(q,a)\subseteq Q_N$$ |
| 결정성 | 입력마다 유일 경로 | 여러 경로 허용(분기) |
| ε-이동 | 없음 | ε-이동 가능(ε-NFA) |
| 수용 조건 | 단일 경로가 최종 상태 도달 | **적어도 하나의 경로**가 최종 상태 도달 |
| 실행 직관 | 빠르고 예측 가능 | 표현 간결, 구성 쉬움(특히 정규식→NFA) |

> 실무 감각: 정규식을 **NFA(또는 ε-NFA)**로 쉽게 만들고, 배포/실행은 **DFA**(혹은 JIT된 테이블)로.

---

## 동치성 정리(Statement)와 직관

**정리(Theorem)**: 임의의 NFA $$N$$에 대해 **동일 언어를 인식**하는 DFA $$D$$가 존재한다. 즉,
$$
\mathcal L(N)=\mathcal L(D).
$$

**직관**: NFA는 같은 시점에 여러 상태에 “동시에” 있을 수 있다(분기). DFA는 이 **상태 집합 그 자체**를 하나의 상태로 “응축”해 추적한다.
→ “분기를 한꺼번에 따라간다 = 부분집합(멱집합) 자동자”.

---

## ε-이동 처리(ε-폐포)

ε-이동을 가진 NFA(ε-NFA)는 먼저 ε-폐포를 써서 “동치의 NFA(ε 없음)”로 만들거나, **부분집합 구성법 내부**에서 ε-폐포를 곁들여 바로 처리할 수 있다.

- **ε-폐포**: $$\text{ECl}(S)$$는 집합 $$S$$에서 ε만 타고 갈 수 있는 모든 상태(자기 포함).
- 입력 기호 $$a$$를 읽을 때의 이동:
  $$
  \text{move}(S,a) \stackrel{\text{def}}{=} \bigcup_{q\in S} \Delta(q,a),\qquad
  \text{next}(S,a)=\text{ECl}(\text{move}(\text{ECl}(S),a)).
  $$

---

## 부분집합 구성법(Subet Construction): NFA → DFA

### 형식적 정의

NFA $$N=(Q_N,\Sigma,\Delta,q_0,F_N)$$에 대해 DFA $$D=(Q_D,\Sigma,\delta_D,S_0,F_D)$$를 다음과 같이 정의:

- **상태**: $$Q_D=\mathcal P(Q_N)$$ (NFA 상태의 모든 부분집합)
- **시작 상태**: $$S_0=\text{ECl}(\{q_0\})$$
- **전이**:
  $$
  \delta_D(S,a)=\text{ECl}\!\Big(\bigcup_{q\in S}\Delta(q,a)\Big)
  $$
- **수용 상태**:
  $$
  F_D=\{S\subseteq Q_N \mid S\cap F_N\neq\emptyset\}.
  $$

> 구현 팁: 실제로는 **도달 가능한 부분집합**만 생성(BFS/큐).

### 올바름의 핵심 불변식(Invariant)

모든 접두사 $$x\in\Sigma^\*$$에 대해
$$
\hat\delta_D(S_0,x) \;=\; \text{ECl}\Big(\{\,q\in Q_N \mid q_0 \xRightarrow[\text{NFA}]{x} q\,\}\Big).
$$

좌변: DFA가 $$x$$를 읽고 도달한 “부분집합 상태”
우변: NFA가 $$x$$를 읽고 **갈 수 있는 모든 상태**의 ε-폐포

이 불변식으로부터 $$w\in \mathcal L(D) \Leftrightarrow w\in \mathcal L(N)$$이 곧장 따른다.

---

## 정식 증명 스케치

### 포함 ①: $$\mathcal L(N)\subseteq \mathcal L(D)$$

귀납(접두사 길이)에 의해 위 불변식을 보이면, $$w$$ 읽은 뒤 DFA 상태에 **최종상태가 포함** ⇔ NFA가 어떤 경로로든 최종상태 도달.

### 포함 ②: $$\mathcal L(D)\subseteq \mathcal L(N)$$

역으로, DFA가 수용했다면 그 상태 집합 안에는 NFA 최종상태가 있다. 그 상태는 어떤 분기 경로로 도달 가능했음을 의미. 따라서 NFA도 수용.

> **결론**: 두 포함이 성립하므로 $$\mathcal L(N)=\mathcal L(D)$$.

---

## 예제 1 — 부분문자열 “ab”를 포함하는 언어

**언어**:
$$
L=\{w\in\{a,b\}^\*\mid \text{‘ab’가 부분문자열로 나타남}\}.
$$

### NFA 설계(간결한 표현)

```text
Q = {q0, q1, q2},  Σ = {a, b},  시작: q0,  F = {q2}
δ:
  δ(q0, a) = {q0, q1}     # 어디서든 a를 보면 'ab'의 a가 될 수 있고, 반복도 허용
  δ(q0, b) = {q0}         # 아직 'ab'를 못 봤으면 b는 유지만
  δ(q1, b) = {q2}         # 직전에 a를 보았고 b를 보면 'ab' 성립
  (나머지는 공집합)
```

### 부분집합 구성(핵심만)

가능한 도달 부분집합들 중 **실제로 도달되는** 것만 생성:

- $$S_0=\{q0\}$$ (ε 없음 가정)
- $$\delta_D(\{q0\},a) = \{q0,q1\}$$
  $$\delta_D(\{q0\},b) = \{q0\}$$
- $$\delta_D(\{q0,q1\},a) = \{q0,q1\}$$
  $$\delta_D(\{q0,q1\},b) = \{q0,q2\}$$ (수용 포함)
- $$\delta_D(\{q0,q2\},a) = \{q0,q1,q2\}$$
  $$\delta_D(\{q0,q2\},b) = \{q0,q2\}$$
- … (이후 수용 집합을 항상 포함하는 흡수 성질 관찰)

**수용 상태**: $$\{q0,q2\},\ \{q0,q1,q2\}$$ (최종상태 $$q2$$를 포함하는 집합)

> **상황 감각**: “`ab`가 한 번이라도 나오면 이후는 무조건 수용”이라는 직관이 DFA 전이에서도 **흡수(accept-sink)** 형태로 드러난다.

---

## 예제 2 — 정규식 \((a\mid b)^\*abb\) 의 NFA → DFA

**언어**: “`abb`로 끝나는 문자열”.

### NFA(ε-없음) 한 가지 구성

```text
Q = {q0, q1, q2, q3},  Σ = {a,b},  시작: q0,  F = {q3}

δ:
  δ(q0, a) = {q0, q1}   # 어디서든 a를 보면 '...abb'의 첫 a 가능성
  δ(q0, b) = {q0}       # '...abb'를 만들려면 b도 축적 허용
  δ(q1, b) = {q2}
  δ(q2, b) = {q3}
```

### 부분집합 구성 요약

- 시작 $$\{q0\}$$ → a: $$\{q0,q1\}$$, b: $$\{q0\}$$
- $$\{q0,q1\}$$ → a: $$\{q0,q1\}$$, b: $$\{q0,q2\}$$
- $$\{q0,q2\}$$ → a: $$\{q0,q1\}$$, b: $$\{q0,q3\}$$(수용)
- $$\{q0,q3\}$$ → a: $$\{q0,q1,q3\}$$, b: $$\{q0,q3\}$$(흡수 수용)
- … (표 전개 가능)

---

## 실습 코드 (ε-폐포 포함 NFA→DFA + 시뮬레이터)

> 교육용으로 간결하게 작성. 실서비스는 검증/에러 처리/완전화(싱크 상태)/최소화(Hopcroft) 등을 추가하세요.

```python
from collections import defaultdict, deque

class NFA:
    def __init__(self, states, alphabet, delta, start, accepts, eps='ε'):
        """
        delta: dict[(q, sym)] -> set(next_states), sym in alphabet ∪ {eps}
        """
        self.states = set(states)
        self.alphabet = set(alphabet)
        self.delta = defaultdict(set)
        for (q,a), dests in delta.items():
            self.delta[(q,a)].update(dests)
        self.start = start
        self.accepts = set(accepts)
        self.eps = eps

    def eclosure(self, S):
        """ε-폐포"""
        stack = list(S)
        seen = set(S)
        while stack:
            q = stack.pop()
            for r in self.delta.get((q, self.eps), set()):
                if r not in seen:
                    seen.add(r); stack.append(r)
        return frozenset(seen)

    def move(self, S, a):
        U = set()
        for q in S:
            U |= self.delta.get((q,a), set())
        return frozenset(U)

class DFA:
    def __init__(self, states, alphabet, delta, start, accepts):
        self.states = set(states)
        self.alphabet = set(alphabet)
        self.delta = dict(delta)       # (Q,a)->Q
        self.start = start
        self.accepts = set(accepts)

    def run(self, s):
        q = self.start
        for ch in s:
            if ch not in self.alphabet:
                return False
            q = self.delta.get((q, ch))
            if q is None:
                return False
        return q in self.accepts

def nfa_to_dfa(nfa: NFA):
    """ε-폐포를 내장하여 NFA -> DFA (도달 상태만 생성)"""
    S0 = nfa.eclosure({nfa.start})
    qname = {S0: "S0"}          # 부분집합 -> 명칭
    name_id = 1
    work = deque([S0])
    dfa_delta = {}
    dfa_states = {"S0"}
    dfa_accepts = set()

    def name_of(S):
        nonlocal name_id
        if S not in qname:
            qname[S] = f"S{name_id}"
            dfa_states.add(qname[S])
            name_id += 1
        return qname[S]

    # 시작 상태가 수용인지 판정
    if any(q in nfa.accepts for q in S0):
        dfa_accepts.add("S0")

    while work:
        T = work.popleft()
        Tn = qname[T]
        for a in nfa.alphabet:
            U = nfa.eclosure(nfa.move(T, a))
            if not U:
                continue  # 불완전 DFA (학습용). 실무에선 sink 추가 권장.
            Un = name_of(U)
            dfa_delta[(Tn, a)] = Un
            if Un not in dfa_states:
                dfa_states.add(Un)
            if U not in [X for X in qname]:
                work.append(U)
            # 수용 상태 표시
            if any(q in nfa.accepts for q in U):
                dfa_accepts.add(Un)

            # 큐 삽입 (새로운 U면)
            if U not in [k for k in qname]:
                work.append(U)

    return DFA(states=dfa_states, alphabet=nfa.alphabet,
               delta=dfa_delta, start="S0", accepts=dfa_accepts), qname

# === 예제 1: 'ab' 부분문자열 NFA ===

states = {'q0','q1','q2'}
alphabet = {'a','b'}
delta = {
    ('q0','a'):{'q0','q1'},
    ('q0','b'):{'q0'},
    ('q1','b'):{'q2'},
}
nfa_ab = NFA(states, alphabet, delta, start='q0', accepts={'q2'})
dfa_ab, mapping = nfa_to_dfa(nfa_ab)

tests = ["", "a", "b", "aa", "ba", "ab", "baba", "aaaaab", "bbb"]
print("=== DFA 수용여부('ab' 포함) ===")
for t in tests:
    print(f"{t or 'ε':>6} -> {dfa_ab.run(t)}")

# 상태 매핑(부분집합 -> 이름) 보기

print("\n부분집합 상태 매핑:")
for subset, name in mapping.items():
    print(f"{name:>3} <= {sorted(subset)}")

# === 예제 2: (a|b)*abb NFA ===

states2 = {'q0','q1','q2','q3'}
delta2 = {
    ('q0','a'):{'q0','q1'},
    ('q0','b'):{'q0'},
    ('q1','b'):{'q2'},
    ('q2','b'):{'q3'},
}
nfa_abb = NFA(states2, alphabet, delta2, start='q0', accepts={'q3'})
dfa_abb, mapping2 = nfa_to_dfa(nfa_abb)

print("\n=== DFA 수용여부(abb로 끝남) ===")
for t in ["abb","aabb","ababb","aba","ab","babb","baba"]:
    print(f"{t:>6} -> {dfa_abb.run(t)}")
```

> 실행 결과(예상):
> - `'ab' 포함` 테스트에서 `ab`, `baba`, `aaaaab` 등은 True, `""`, `a`, `b`, `bbb` 등은 False.
> - `abb` 케이스에서 `abb`, `aabb`, `babb`는 True, `ab`, `aba` 등은 False.

---

## DFA ↔ NFA 상호 변환 요약

- **DFA → NFA**: 자명(전이를 단일 원소 집합으로). 표현력 변화 없음.
- **NFA → DFA**: 부분집합 구성(ε 포함 시 ε-폐포 내장).
  **최대 상태 수**는 $$2^{|Q_N|}$$ (도달 가능한 부분집합으로 제한 시 더 작음).

---

## 복잡도/실전 팁

### 상태 폭발(State Explosion)

- 최악 $$2^n$$. 특히 패턴이 길고 겹치는 경우(예: 긴 접미사 자동자)
- **대응**:
  - **지연 결정화(lazy determinization)**: 실제로 필요한 부분집합만 생성(위 코드가 해당)
  - **최소화(Hopcroft)**: 결정화 후 테이블 축소(상황에 따라 대폭 절감)
  - **분리·조합**: 큰 정규식을 파트별 DFA로 분해 후 상위에서 선택/조합

### 완전화와 여집합

- 여집합을 쓰려면 **완전 DFA** 필요(정의되지 않은 전이는 **sink**로).
- 본문 코드는 학습을 위해 불완전 DFA를 허용—실무용은 sink 추가를 권장.

### 정규식 엔진 vs 이론 정규식

- 실제 엔진은 **역참조/전후방 탐색** 등 **정규 언어 밖** 기능을 지원 → 백트래킹 폭발 주의.
- 본 이론은 **순수 정규 언어**에 대한 것. 대규모 로그 필터링/IDS/컴파일러 렉서는 보통 **DFA 기반**으로 최적화.

---

## 동치성의 응용(자주 쓰는 카드)

- **폐쇄성 증명**(합/교/차): DFA의 **곱구성**으로 구성 → NFA로 하든 DFA로 하든 동치.
- **멤버십 판정**: 실행은 DFA가 선형 시간/상수 메모리로 유리.
- **정규식 컴파일**: 정규식 → (Thompson) ε-NFA → 부분집합 → (최소화) → 테이블.

---

## 연습문제(해설 스케치 포함)

1) **NFA → DFA**:
   $$L=\{w\in\{0,1\}^\*\mid \text{부분문자열로 }01\text{이 나타남}\}$$
   - NFA로 `0` 보자마자 “기대 상태”로, 그다음 `1`에서 수용.
   - 부분집합 구성으로 3~4개 상태 DFA 도출.

2) **ε-루프 포함 NFA**:
   $$q_0 \xrightarrow{\varepsilon} q_1,\ q_1 \xrightarrow{a} q_1,\ q_1 \xrightarrow{b} q_2\ (\text{수용})$$
   - 시작 ε-폐포가 \(\{q_0,q_1\}\)가 됨을 확인하고, `a`,`b` 전이 전개.

3) **최소화 필요성**:
   NFA→DFA 후 얻은 DFA에 최고 6~8개 상태가 나오면 Hopcroft 최소화로 줄여 보라(등가 상태 병합).

4) **여집합 활용**:
   “`ab`를 **포함하지 않는** 언어” DFA를 위 `ab` DFA로부터 **완전화 → 여집합**으로 얻어 보라.

5) **곱구성**:
   “`ab` **포함** ∧ `aa` **미포함**” 언어 DFA를 두 DFA의 곱으로 구성해 보라.

---

## 결론

- **핵심**: NFA의 “동시 분기”는 DFA에서 “상태 집합”으로 흡수된다.
- **올바름**: ε-폐포를 곁들인 **부분집합 구성**과 **불변식**으로 $$\mathcal L(N)=\mathcal L(D)$$ 증명.
- **실전**: NFA로 **쉽게 표현** → DFA로 **빠르게 실행**, 필요 시 **최소화**와 **완전화**로 안정된 성능/정확성 확보.
