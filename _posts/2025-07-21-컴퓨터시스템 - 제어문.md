---
layout: post
title: 컴퓨터시스템 - 제어문
date: 2025-07-21 23:20:23 +0900
category: 컴퓨터시스템
---
# 🧭 제어문 (Control Flow)

제어문은 프로그램의 실행 흐름을 제어하는 구조적 문법입니다. 고급 언어에서는 `if`, `switch`, `for`, `while`, `do-while`, `goto` 등이 있으며, 이는 컴파일러에 의해 **분기(branch)**와 **조건 판단**을 포함하는 **기계 수준 코드**로 번역됩니다.

---

## 📌 1. 분기의 기계 수준 의미

CPU는 기본적으로 **순차적**으로 명령어를 실행합니다. 그러나 조건문과 반복문은 **특정 주소로 점프(jump)**해야 하기 때문에 **프로그램 카운터(PC)**를 수동으로 조작해야 합니다.

C의 제어문 → 어셈블리 → 기계어 → CPU는 다음과 같은 흐름을 거칩니다.

예:  
```c
if (x > 0) {
    y = x;
}
```

어셈블리에서는 다음과 같이 표현됩니다:
```asm
    cmp     x, 0
    jle     ELSE_LABEL
    mov     y, x
ELSE_LABEL:
```

- `cmp`: 비교 명령어
- `jle`: 점프(jump) if less or equal

---

## 📌 2. 조건 분기 (Conditional Branching)

### 🔹 if-else

```c
if (cond) {
    A;
} else {
    B;
}
```

어셈블리:
```asm
    test    cond, cond
    je      ELSE
    ; A 실행
    jmp     END
ELSE:
    ; B 실행
END:
```

- `test`: cond와 cond의 AND 결과를 ZF에 설정
- `je`: Zero flag가 1이면 jump (cond가 false일 때)

---

### 🔹 다중 조건: if-else if-else

```c
if (a > b) {
    A;
} else if (a == b) {
    B;
} else {
    C;
}
```

어셈블리:
```asm
    cmp     a, b
    jg      LABEL_A
    je      LABEL_B
    ; C 실행
    jmp     END
LABEL_A:
    ; A 실행
    jmp     END
LABEL_B:
    ; B 실행
END:
```

---

## 📌 3. 반복문 (Loops)

### 🔹 while

```c
while (cond) {
    A;
}
```

어셈블리:
```asm
LOOP_START:
    test    cond, cond
    je      LOOP_END
    ; A 실행
    jmp     LOOP_START
LOOP_END:
```

---

### 🔹 for

```c
for (init; cond; step) {
    A;
}
```

이는 다음과 동일합니다:

```c
init;
while (cond) {
    A;
    step;
}
```

어셈블리:
```asm
    ; init
LOOP_START:
    ; cond 평가
    je  LOOP_END
    ; A
    ; step
    jmp LOOP_START
LOOP_END:
```

---

### 🔹 do-while

```c
do {
    A;
} while (cond);
```

어셈블리:
```asm
LOOP_START:
    ; A 실행
    test    cond, cond
    jne     LOOP_START
```

do-while은 무조건 한 번은 실행되며 조건은 나중에 평가됩니다.

---

## 📌 4. switch-case

```c
switch (x) {
    case 0:
        A;
        break;
    case 1:
        B;
        break;
    default:
        C;
}
```

컴파일러는 `x` 값을 기반으로 **jump table**을 만들기도 하고, **if-else cascade**로 컴파일하기도 합니다.

### 🔸 방법 1: 순차적 비교

```asm
    cmp x, 0
    je  LABEL0
    cmp x, 1
    je  LABEL1
    jmp DEFAULT
LABEL0:
    ; A
    jmp END
LABEL1:
    ; B
    jmp END
DEFAULT:
    ; C
END:
```

### 🔸 방법 2: Jump Table (빠름)

```asm
    cmp     x, max_case
    ja      DEFAULT
    jmp     [JUMP_TABLE + x*4]
```

Jump table은 주소 배열이며, 각 인덱스에 따라 분기합니다.

---

## 📌 5. goto 문

`goto`는 현재의 흐름을 지정된 라벨로 즉시 이동시킵니다.

```c
if (error) goto FAIL;
```

어셈블리에서는 `jmp FAIL`과 같습니다.

`goto`는 예외 처리나 리소스 해제를 위해 간혹 사용되지만, 구조적 프로그래밍에서는 일반적으로 지양됩니다.

---

## 📌 6. 조건 판단과 플래그 레지스터

x86-64 등 대부분의 아키텍처는 조건 판단을 위해 **플래그 레지스터(EFLAGS)**를 사용합니다.

### 주요 플래그

| 플래그 | 의미 |
|--------|------|
| ZF (Zero Flag) | 연산 결과가 0이면 1 |
| SF (Sign Flag) | 부호 비트 |
| CF (Carry Flag) | 이진 덧셈에서 오버플로 여부 |
| OF (Overflow Flag) | 산술 오버플로 |

예: `cmp a, b`는 내부적으로 `a - b`를 수행하고, 플래그를 설정합니다.

---

## 📌 7. 조건부 점프 명령어

| 명령어 | 의미 |
|--------|------|
| `je` / `jz` | equal / zero |
| `jne` / `jnz` | not equal |
| `jg` / `jnle` | greater than (signed) |
| `jl` / `jnge` | less than (signed) |
| `ja` | above (unsigned) |
| `jb` | below (unsigned) |

---

## 📌 8. 예제: 조건에 따라 두 수 중 큰 값 반환

```c
int max(int a, int b) {
    if (a > b)
        return a;
    else
        return b;
}
```

어셈블리 (x86-64):

```asm
    mov     eax, edi       ; a → eax
    cmp     edi, esi       ; a vs b
    jge     DONE           ; a >= b이면 eax 그대로
    mov     eax, esi       ; b → eax
DONE:
    ret
```

---

## 📌 9. 제어 흐름의 중요성

제어문은 프로그램의 **논리 흐름**을 결정하는 핵심입니다. 컴파일러는 고급 언어의 조건, 반복, 분기를 모두 **분기 명령어**로 변환합니다.

또한, 성능 최적화를 위해:
- 분기 예측(branch prediction)
- 루프 언롤링(loop unrolling)
- 조건 이동(conditional move)

등의 기술이 활용되기도 합니다.

---

## 📌 10. 고급 기법: 조건 이동 (Conditional Move)

조건문 없이 분기하지 않고 이동하는 방식입니다.

```c
if (x < y)
    min = x;
else
    min = y;
```

→ 조건 이동 활용 (분기 없음)

```asm
    mov     eax, x
    mov     ebx, y
    cmp     eax, ebx
    cmovg   eax, ebx      ; x > y → y로 덮기
```

`cmov` 명령어는 분기 예측 실패 비용 없이 동작하므로 **짧은 조건문**에 유리합니다.

---

## ✅ 정리

- 제어문은 프로그램의 흐름을 결정
- 어셈블리에서는 `jmp`, `cmp`, `je`, `jne` 등의 명령어로 표현
- 조건 분기, 반복문, switch, goto 모두 기계 수준에서 분기로 구성
- 조건 이동은 성능 최적화를 위해 활용됨
- 제어 흐름의 정확한 이해는 저수준 디버깅과 보안, 최적화에 필수