---
layout: post
title: 컴퓨터시스템 - 제어문
date: 2025-07-21 23:20:23 +0900
category: 컴퓨터시스템
---
# 제어문 (Control Flow)

## 0. 준비: 분기의 최소 기계 모델

CPU는 **PC(프로그램 카운터)** 가 가리키는 명령을 순차 실행한다.  
제어문은 결국 **PC를 다른 주소로 바꾸는 분기(branch/jump)** 로 번역된다.

- **비조건 분기**: 항상 점프. `jmp label`
- **조건 분기**: 직전 비교/연산이 남긴 **플래그 레지스터**(x86의 EFLAGS 등)를 검사하여 점프.
- **플래그 예시(x86)**: ZF(0 여부), SF(부호), CF(자리올림/차용), OF(산술 오버플로)

`cmp a, b` 는 내부적으로 `a - b` 를 계산하고 플래그만 남긴다(결과는 버림).

---

## 1. if / if-else — 기본 분기 패턴

### 1.1 단일 if

```c
if (x > 0) {
    y = x;
}
```

개념적 x86-64:

```asm
    cmp     edi, 0          ; x - 0
    jle     .Lelse          ; x <= 0 이면 else로
    mov     esi, edi        ; y = x
.Lelse:
```

- `cmp A, B` → `A-B`의 결과로 플래그 설정
- `jle`(signed ≤), `ja`/`jb`는 unsigned 비교에 대응

### 1.2 if-else

```c
if (a > b) u = a;
else       u = b;
```

```asm
    mov     eax, edi        ; u <- a (가정: a in edi, b in esi)
    cmp     edi, esi
    jge     .Ldone          ; a>=b 이면 u=a 유지
    mov     eax, esi        ; 그렇지 않으면 u=b
.Ldone:
```

- 흔한 패턴: **참 경로**를 기본값으로 두고 분기 한 번으로 끝낸다(분기 예측에 유리할 수 있음).

---

## 2. 조건 이동(Branchless) — cmov/setcc로 분기 제거

짧은 조건식은 **분기 없이** 실행하는 편이 분기 예측 실패를 피하는 데 유리하다.

### 2.1 cmov (조건 이동)

```c
int max(int a, int b){
    int r = a;
    if (b > a) r = b;
    return r;
}
```

가능한 번역:

```asm
    mov     eax, edi        ; r=a
    cmp     esi, edi        ; b ? a
    cmovg   eax, esi        ; (signed) b>a 이면 eax<-b
    ret
```

- `cmovcc dst, src` : 조건(cc)이 참이면 `dst=src`.
- 분기 예측 실패 패널티(파이프라인 flush)를 피할 수 있음. 다만 **항상 양쪽 피연산자가 준비**되어야 하므로 **의존성/메모리 접근**이 크면 이득이 작다.

### 2.2 setcc + 비트 마스크

```c
// r = (cond ? x : y)
```

```asm
    cmp     edi, esi
    setg    al              ; AL=cond(0/1)
    movzx   eax, al
    ; r = y + (x - y)*cond
```

분기 없이 산술로 선택:

$$
r = y + (x-y)\cdot \text{cond}
$$

---

## 3. 논리식과 단락 평가(short-circuit)

C의 `&&`, `||` 는 **좌측부터 평가**하고, **결과가 정해지면 우측은 평가하지 않는다**.

```c
if (p && *p == 'A') { ... }    // p==NULL이면 *p 평가 안 함(안전)
```

컴파일 결과는 보통 **중간 분기**로 구현된다. **부작용 함수**가 섞이면 평가 순서를 믿어야 하므로 단락 의미가 중요하다.

> 주의: C에서 **피연산자 평가 순서**는 여러 경우에 **미정**이다(단락 연산, `?:`, `,` 연산자, `&&/||` 등 일부를 제외).

---

## 4. switch — 연속 범위는 점프 테이블, 산개는 체인/이진검색

```c
int f(int x){
    switch (x) {
    case 0: return 10;
    case 1: return 20;
    case 2: return 30;
    default: return -1;
    }
}
```

### 4.1 연속·밀집(dense) 케이스: Jump Table

```asm
    cmp     edi, 2
    ja      .Ldefault
    jmp     QWORD PTR [.LJUMP+8*rdi]   ; 64비트 엔트리
.LJUMP:
    .quad   .Lcase0, .Lcase1, .Lcase2
```

### 4.2 산개(sparse) 케이스: 비교 체인/이진검색

```asm
    cmp     edi, 100
    je      .L100
    cmp     edi, 1000
    je      .L1000
    ...
```

- 컴파일러는 **범위/밀도/개수**로 전략을 고른다.
- GCC/Clang은 `-fprofile-generate/use` 로 **프로파일 기반** 최적화를 적용, **자주 가는 케이스를 위로** 배치한다.

#### fallthrough 제어

C에서는 `break` 누락이 실수의 원인. 최신 컴파일러는 `[[fallthrough]]`(C23 일부/컴파일러 확장) 또는 주석 지시로 의도적 낙하를 표시해 경고를 억제한다.

---

## 5. while / for / do-while — 루프 골격과 변환

### 5.1 while

```c
while (cond) {
    body;
}
```

```asm
.Ltest:
    ; cond 평가 -> 플래그
    je      .Lend
    ; body
    jmp     .Ltest
.Lend:
```

### 5.2 for

```c
for (init; cond; step) {
    body;
}
```

동치 변환:

```c
init;
while (cond) {
    body;
    step;
}
```

번역은 보통 **조건 검사→바디→스텝→검사** 순환.

### 5.3 do-while

```c
do { body; } while (cond);
```

```asm
.Lloop:
    ; body
    ; cond
    jne     .Lloop       ; 적어도 1회 실행
```

---

## 6. 루프 최적화 개론 — 언롤링·강도 감소·벡터화·호이스팅

### 6.1 루프 불변 코드 이동(hoisting)

```c
for (int i=0; i<n; i++) s += a[i] * scale;   // scale 불변
```

`scale` 의 로드를 루프 밖으로 뺀다.

### 6.2 강도 감소(strength reduction)

```c
p = base;
for (i=0;i<n;i++){ use(*p); p++; }   // i*stride → 포인터 증가로 대체
```

곱셈/주소 계산을 **증가 연산**으로 대체.

### 6.3 언롤링(unrolling)

```c
for(i=0;i<n;i+=4){
  s+=a[i+0]; s+=a[i+1]; s+=a[i+2]; s+=a[i+3];
}
```

분기 횟수↓, ILP↑. 남는 꼬리(tail)는 별도 처리.

### 6.4 자동 벡터화와 별칭

```c
void saxpy(int n, float a,
           float * __restrict x,
           float * __restrict y) {
  for (int i=0;i<n;i++) y[i] += a*x[i];
}
```

- `restrict` 가 참일 때 **메모리 별칭 없음** 가정 → **벡터화**/레지스터 보존 최적화 가능.
- 잘못 쓰면 UB.

---

## 7. 분기 예측과 성능 — 실패 비용과 분기 제거 설계

**대략 모델:**

$$
T \approx N \cdot \big(p_m \cdot M + (1-p_m)\cdot H\big)
$$

- \( N \): 분기 횟수, \( p_m \): 예측 실패율, \( M \): 실패 패널티(수~수십 사이클), \( H \): 적중 비용
- 고도로 불규칙한 조건은 **cmov/비트 마스크**로 **분기 제거**가 유리할 수 있다.

### 7.1 힌트 주기

- GCC/Clang: `__builtin_expect(cond, 1)`  
  매크로 예:

```c
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)

if (likely(len > 0)) { ... }
```

- 코드 레이아웃을 **핫 경로가 낙하(fall-through)** 되도록 구성하면 I-cache/BTB에 유리.

### 7.2 보안 측면(스펙터류)

분기 예측/추측 실행은 **경계 검사 우회(side-channel)** 를 일으킬 수 있음.  
필요 시 **경계 마스킹**, **직렬화/barrier**, **분기 없는 인덱스 정규화**를 사용.

---

## 8. 조건 코드와 분기 종류 — signed vs unsigned

| 비교 의미 | signed 분기 | unsigned 분기 |
|---|---|---|
| `==` | `je/jz` | 동일 |
| `!=` | `jne/jnz` | 동일 |
| `<`  | `jl`     | `jb` (below) |
| `<=` | `jle`    | `jbe` |
| `>`  | `jg`     | `ja` (above) |
| `>=` | `jge`    | `jae` |

- **서명성**을 잘못 고르면 결과가 틀린다. 매개 타입이 서로 다르면 **정수 승격/변환** 규칙으로 비교 의미가 바뀔 수 있다.

---

## 9. goto — 정리 구간(cleanup)과 오류 처리

구조적 프로그래밍에서는 `goto`를 자제하지만, **단일 종료/자원 해제**에는 유용하다.

```c
int process(void){
    FILE *f = fopen("in","rb");
    if (!f) return -1;

    char *buf = malloc(4096);
    if (!buf) { goto FAIL_F; }

    if (read_into(f, buf) < 0) { goto FAIL_BUF; }

    free(buf); fclose(f); return 0;

FAIL_BUF:
    free(buf);
FAIL_F:
    fclose(f);
    return -1;
}
```

- 중첩 `if` 를 피하고 **해제 경로를 일관**시키는 장점.

---

## 10. 고급: 듀프의 기법(Duff’s Device) — switch+루프 언롤링

고전적 `memcpy` 최적화 패턴(교육 목적으로만):

```c
void copy16(char *d, const char *s, int count){
    int n = (count + 7) / 8;
    switch (count % 8) {
    case 0: do { *d++ = *s++;
    case 7:      *d++ = *s++;
    case 6:      *d++ = *s++;
    case 5:      *d++ = *s++;
    case 4:      *d++ = *s++;
    case 3:      *d++ = *s++;
    case 2:      *d++ = *s++;
    case 1:      *d++ = *s++;
            } while(--n > 0);
    }
}
```

- 실전에서는 컴파일러/라이브러리의 벡터화 구현을 사용하는 것이 보통 더 빠르고 안전하다.

---

## 11. 플랫폼 차이 — ARM의 조건부 실행/선택, MIPS 지연 슬롯

- **ARMv7(32비트)**: 대부분의 명령이 조건부 실행 필드를 가짐 → **분기 없이** 조건부 수행 가능.  
- **AArch64(ARMv8)**: `csel`(조건 선택), `csinc` 등 **조건 선택** 명령 선호.  
- **MIPS(고전)**: **지연 슬롯(delay slot)** 존재. 분기 직후 명령 1개가 항상 실행되어야 하므로 컴파일러가 재배치.

이식 가능한 C 관점에서는 **구현 세부**가 다르지만, 개념은 동일: 조건을 **플래그/상태**로 두고 **선택/분기**를 수행.

---

## 12. 함수 호출 흐름 — call/ret, 테일 콜 최적화

- `call addr` : 복귀 주소를 스택/레지스터에 저장 후 점프, `ret` : 복귀.
- **테일 콜**: 마지막 연산이 `return g(..)` 이면 현재 프레임을 버리고 `jmp g` 로 최적화될 수 있다(ABI 제약 충족 시).  
  C 표준이 보장하진 않지만 컴파일러가 많이 적용.

```c
int f(int n){         // 단순 꼬리재귀는 루프로 바뀔 수 있음
    if (n==0) return 0;
    return f(n-1);
}
```

---

## 13. 예제: 분기 제거로 일정 시간(constant-time) 비교

보안 코드에서는 분기/타이밍 의존을 피한다.

```c
// return 1 if equal, 0 otherwise. Branchless.
int bytes_equal(const unsigned char *a,
                const unsigned char *b, size_t n){
    unsigned diff = 0;
    for (size_t i=0;i<n;i++) diff |= (unsigned)(a[i] ^ b[i]);
    /* diff==0 -> 1, else 0 */
    diff |= -diff;           // 상위 비트 전파
    return (int)((diff >> 31) ^ 1);   // 0->1, else->0
}
```

---

## 14. 실습: 분기/분기없는 max, switch 변형, 루프 언롤

### 14.1 max — 분기 vs cmov

```c
int max_branch(int a,int b){
    if (a >= b) return a; else return b;
}

int max_cmov(int a,int b){
    int r=a;
    if (b>a) r=b;   // cmovg 로 바뀔 가능성
    return r;
}
```

### 14.2 switch — 점프 테이블 직접 흉내(학습용)

```c
typedef int (*casefun)(int);
int c0(int x){return x+10;}
int c1(int x){return x+20;}
int cx(int x){return -1;}

int dispatch(int k, int x){
    static casefun jt[2] = { c0, c1 };
    if ((unsigned)k < 2) return jt[k](x);
    return cx(x);
}
```

- 직접 함수 포인터 테이블을 쓰면 컴파일러의 점프 테이블과 유사한 동작을 구현 가능.

### 14.3 언롤과 꼬리 처리

```c
int sum_unroll(const int* a, int n){
    int s=0, i=0;
    for (; i+3<n; i+=4) s+=a[i]+a[i+1]+a[i+2]+a[i+3];
    for (; i<n; i++) s+=a[i];
    return s;
}
```

---

## 15. 수식으로 보는 루프 비용과 분기 예측

한 루프 반복의 기대 비용:

$$
C_{\text{iter}} \approx C_{\text{body}} + p_m \cdot M
$$

- \( C_{\text{body}} \): 바디 자체 비용  
- \( p_m \): 루프 분기 예측 실패율(데이터 의존 조건이 흔하면 ↑)  
- 루프 언롤로 **분기/반복 횟수 감소** → \( p_m \cdot M \) 항이 상대적으로 줄어든다.

---

## 16. 디버깅 팁 — 어셈블리/IR에서 흐름 읽기

- `-S` 로 어셈블리 출력, `objdump -d` 로 디스어셈.
- `-O0` vs `-O2` 를 비교하여 **제어 흐름이 최적화로 어떻게 바뀌는지** 관찰.
- `-fsanitize=undefined,address` 로 **미정의 동작/오버런**을 조기에 잡는다.
- `-fno-strict-aliasing` 로 별칭 최적화 해제(디버깅 목적), 실전은 규칙 준수 권장.

---

## 17. 체크리스트 — 정확성과 성능을 동시에

1. **서명성**에 맞는 분기 코드(`jl/jg` vs `jb/ja`).  
2. **단락 평가** 전제(부작용 포함)를 깨지 않게 작성.  
3. **핫 경로**를 낙하(fall-through)로, 콜드 경로는 분기로.  
4. **분기 제거**(cmov/마스크) 는 데이터 의존 메모리 접근이 없을 때 이득.  
5. 루프는 **연속 접근**(스트라이드 1)·**언롤**·**restrict** 로 벡터화 지원.  
6. 외부 입력 인덱스는 **경계 마스킹/검사**로 스펙터류 완화.  
7. `goto`는 **정리 구간**에만 절제 사용.  
8. `switch` 는 **값 범위/밀도**에 따라 설계(케이스 재배치·디폴트 처리 명확화).  
9. 성능은 **측정 기반**(프로파일/PMU)으로 판단.  
10. 최적화 전후 **어셈블리/IR** 을 확인해 의도를 점검.

---

## 18. 연습 문제

1) `min(a,b)` 를 (a) 분기형, (b) `cmov` 유도형, (c) `setcc`+마스크형으로 각각 작성하고 성능을 비교하라.  
2) `switch` 케이스가 0..7, 1000..1015 두 군으로 나뉘는 함수에서, 컴파일러가 점프 테이블 두 개 vs 체인을 고르는 차이를 관찰하라.  
3) `for (i=0;i<n;i++) if (a[i]>t) s+=a[i];` 의 분기를 분기 없는 형태로 변환해보라.  
4) `while` 루프를 `do-while` 로 바꾸어 바디가 0회/1회일 때의 분기 수를 비교하라.  
5) `__builtin_expect` 를 이용해 핫·콜드 경로를 힌트하고 I-cache miss / 분기 실패율 변화를 측정하라.

---

## 19. 참고 코드: 분기없는 조건 누적/경계 마스킹

```c
// s += (a[i] > t ? a[i] : 0)  (branchless)
int sum_thresh(const int* a, int n, int t){
    int s=0;
    for (int i=0;i<n;i++){
        int x = a[i];
        int ge = -(x > t);         // true:-1, false:0 (조건→마스크)
        s += x & ge;               // true면 x, false면 0
    }
    return s;
}

// 안전 인덱스(리틀엔디안, 길이 k는 2의 거듭제곱 가정)  Branchless mask
unsigned at_pow2(const unsigned *tab, size_t k, size_t i){
    return tab[i & (k-1)];
}
```

---

## 결론

제어문은 모두 **플래그 설정 → 조건 검사 → PC 갱신**이라는 단순한 기계 메커니즘으로 귀결된다.  
고급 언어의 문법은 **분기/점프/조건 이동**으로 환원되고, 성능은 **분기 예측**과 **데이터 레이아웃/접근 패턴**의 상호작용으로 결정된다.

- 정확성 측면: **서명성/단락/별칭/미정의 동작**을 엄격히 지킬 것.  
- 성능 측면: **핫 경로 낙하, 분기 제거, 루프 최적화, 점프 테이블**을 도구로 삼을 것.  
- 보안 측면: **추측 실행 부작용**을 의식한 **경계 마스킹/분기 없는 설계**를 검토할 것.

어셈블리 관점에서 흐름을 읽는 습관은 **디버깅·최적화·안전성**을 한 번에 끌어올린다.