---
layout: post
title: Java - HTTP 통신
date: 2025-08-13 19:20:23 +0900
category: Java
---
# HTTP 통신 — 자바로 간단·견고한 클라이언트 작성

## 1. 큰 그림 — 선택 가이드 (업데이트 반영)

| 방법 | 핵심 장점 | 단점/주의 | 추천 상황 |
|---|---|---|---|
| **JDK 11+ HttpClient** | 표준/무의존, **HTTP/2**, 동기·비동기, 타임아웃·리다이렉트, 쿠키·프록시 | 멀티파트·인터셉터 직접 구현 필요 | **기본 선택**. 대부분 REST 호출에 충분 |
| HttpURLConnection | JDK 내장, 의존성 無 | 불편한 API, 에러/스트림 처리 번거로움, 비동기/HTTP/2 부재 | 레거시 호환, 초소형 유틸 |
| OkHttp / Apache HC | 성숙한 기능(멀티파트, 연결풀 튜닝, 인터셉터) | 외부 의존성 | 고도화(인터셉터/플러그인/멀티파트) 필요 시 |

> **권장**: 표준 **HttpClient**로 시작 → “인터셉터/멀티파트 도우미/관측(Observability)” 같은 고급 니즈가 커지면 **OkHttp** 고려.

---

## 2. HttpClient 기본 설정

```java
import java.net.http.*;
import java.time.Duration;

HttpClient client = HttpClient.newBuilder()
        .version(HttpClient.Version.HTTP_2)           // HTTP/1.1과 자동 협상
        .connectTimeout(Duration.ofSeconds(3))        // TCP 연결 타임아웃
        .followRedirects(HttpClient.Redirect.NORMAL)  // 301/302/307 등 기본 처리
        .build();

// 실무 팁: HttpClient는 스레드-세이프. 앱 전체에서 싱글턴 재사용(커넥션 풀/HTTP2 재사용 이점).
```

---

## 3. 요청 작성 — GET/POST/헤더/타임아웃/쿼리

### 3.1 GET (쿼리 파라미터, 헤더, 요청별 타임아웃)
```java
import java.net.URI;
import java.net.URLEncoder;
import static java.nio.charset.StandardCharsets.UTF_8;
import java.time.Duration;

String q = URLEncoder.encode("한글 테스트", UTF_8); // 쿼리 문자열 전용
URI uri = URI.create("https://httpbin.org/get?q=" + q);

HttpRequest req = HttpRequest.newBuilder(uri)
        .GET()
        .header("Accept", "application/json")
        .timeout(Duration.ofSeconds(5))               // 읽기(대기) 타임아웃
        .build();

HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));
if (res.statusCode() / 100 != 2) {
    throw new IllegalStateException("HTTP " + res.statusCode() + " : " + res.body());
}
System.out.println(res.body());
```

> **경고**: `URLEncoder`는 **쿼리 전용**. **경로 세그먼트** 인코딩은 별도 유틸을 쓰거나, 서버가 경로 디코딩을 허용하는지 확인.

### 3.2 POST(JSON) — Jackson 직렬화
> Jackson 버전은 **최신 안정판(2.17+ / 2.18+)** 사용 권장.

```java
// Maven
// <dependency>
//   <groupId>com.fasterxml.jackson.core</groupId>
//   <artifactId>jackson-databind</artifactId>
//   <version>2.18.0</version> <!-- 최신 안정판 권장 -->
// </dependency>

// Gradle(Kotlin)
// implementation("com.fasterxml.jackson.core:jackson-databind:2.18.0")

import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Map;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.net.URI;

ObjectMapper om = new ObjectMapper();
String json = om.writeValueAsString(Map.of("name","Alice","age",30));

HttpRequest req = HttpRequest.newBuilder(URI.create("https://httpbin.org/post"))
        .header("Content-Type","application/json; charset=UTF-8")
        .POST(HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8))
        .build();

HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());
System.out.println(res.statusCode());
System.out.println(res.body());
```

### 3.3 `application/x-www-form-urlencoded`
```java
String form = "username=" + URLEncoder.encode("kim", UTF_8) +
              "&password=" + URLEncoder.encode("secret", UTF_8);

HttpRequest req = HttpRequest.newBuilder(URI.create("https://example.com/login"))
        .header("Content-Type","application/x-www-form-urlencoded; charset=UTF-8")
        .POST(HttpRequest.BodyPublishers.ofString(form, UTF_8))
        .build();
```

---

## 4. 멀티파트 업로드(파일) — **메모리 복사 없이 스트리밍** 구현

표준 HttpClient에는 멀티파트 퍼블리셔가 없다. 하지만 **`BodyPublishers.concat(...)`**로 파트 퍼블리셔들을 이어 붙이면 된다.

```java
import java.net.http.HttpRequest.BodyPublisher;
import java.net.http.HttpRequest.BodyPublishers;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

final class Multipart {
    private final String boundary;
    Multipart() { this.boundary = "----JavaBoundary" + System.currentTimeMillis(); }
    String contentType() { return "multipart/form-data; boundary=" + boundary; }

    private BodyPublisher str(String s) {
        return BodyPublishers.ofString(s, StandardCharsets.UTF_8);
    }
    private static final String CRLF = "\r\n";

    BodyPublisher of(String name, String value) {
        String part = "--" + boundary + CRLF +
                "Content-Disposition: form-data; name=\"" + name + "\"" + CRLF + CRLF +
                value + CRLF;
        return str(part);
    }

    BodyPublisher ofFile(String field, Path file, String filename, String contentType) throws Exception {
        String pre = "--" + boundary + CRLF +
                "Content-Disposition: form-data; name=\"" + field + "\"; filename=\"" + filename + "\"" + CRLF +
                "Content-Type: " + contentType + CRLF + CRLF;
        String post = CRLF; // 파트 종료 CRLF
        return BodyPublishers.concat(
                str(pre),
                BodyPublishers.ofInputStream(() -> Files.newInputStream(file)), // 스트리밍
                str(post)
        );
    }

    BodyPublisher finish(BodyPublisher... parts) {
        BodyPublisher end = str("--" + boundary + "--" + CRLF);
        BodyPublisher all = parts.length == 0 ? end : BodyPublishers.concat(parts[0],
                java.util.Arrays.stream(parts).skip(1).reduce((a,b)->BodyPublishers.concat(a,b)).orElseThrow(),
                end);
        return all;
    }
}
```

사용:
```java
Multipart mp = new Multipart();
BodyPublisher body = mp.finish(
        mp.of("meta", "hello"),
        mp.ofFile("file", Path.of("hello.txt"), "hello.txt", "text/plain")
);

HttpRequest req = HttpRequest.newBuilder(URI.create("https://httpbin.org/post"))
        .header("Content-Type", mp.contentType())
        .POST(body)
        .build();

HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());
System.out.println(res.statusCode());
System.out.println(res.body());
```

> **장점**: 파일을 메모리에 올리지 않고 스트리밍. 대용량 업로드에 적합.

---

## 5. 비동기 — `CompletableFuture`로 합성

```java
import java.net.http.*;
import java.net.URI;
import java.util.concurrent.CompletableFuture;

HttpRequest req = HttpRequest.newBuilder(URI.create("https://httpbin.org/delay/1"))
        .GET().build();

CompletableFuture<String> cf =
        client.sendAsync(req, HttpResponse.BodyHandlers.ofString())
              .thenApply(HttpResponse::body)
              .exceptionally(ex -> { ex.printStackTrace(); return "fallback"; });

System.out.println(cf.join()); // 데모용
```

### 5.1 동시성(팬아웃) & 처리 합류
```java
var urls = java.util.List.of(
        "https://httpbin.org/get?i=1",
        "https://httpbin.org/get?i=2",
        "https://httpbin.org/get?i=3");

var futures = urls.stream().map(u -> {
    var r = HttpRequest.newBuilder(URI.create(u)).GET().build();
    return client.sendAsync(r, HttpResponse.BodyHandlers.ofString());
}).toList();

var all = CompletableFuture.allOf(futures.toArray(CompletableFuture[]::new));
all.join();
futures.forEach(f -> System.out.println(f.join().statusCode()));
```

---

## 6. 쿠키/프록시/인증/TLS

### 6.1 쿠키 & 프록시 & 기본 인증
```java
import java.net.*;
import java.net.http.*;
import java.time.Duration;

CookieManager cm = new CookieManager();
cm.setCookiePolicy(CookiePolicy.ACCEPT_ALL);

HttpClient client = HttpClient.newBuilder()
    .cookieHandler(cm)
    .proxy(ProxySelector.of(new InetSocketAddress("proxy.local", 8080)))
    .authenticator(new Authenticator() {
        @Override protected PasswordAuthentication getPasswordAuthentication() {
            return new PasswordAuthentication("user", "pass".toCharArray());
        }
    })
    .connectTimeout(Duration.ofSeconds(3))
    .build();
```

### 6.2 Bearer 토큰 / Basic
```java
String bearer = "Bearer " + token;
HttpRequest req = HttpRequest.newBuilder(URI.create("https://api.example.com"))
        .header("Authorization", bearer)
        .GET().build();

// Basic: "Basic base64(user:pass)" 직접 생성
```

### 6.3 TLS (자체 CA/Mutual TLS)
> **운영**에서는 신뢰 저장소/키 저장소를 정확히 설정해야 한다.

```java
import javax.net.ssl.*;
import java.security.KeyStore;
import java.nio.file.Path;
import java.io.FileInputStream;

// TrustStore (CA)
KeyStore ts = KeyStore.getInstance("JKS");
try (var in = new FileInputStream("truststore.jks")) { ts.load(in, "tsPass".toCharArray()); }
TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init(ts);

// KeyStore (클라이언트 인증서, mTLS)
KeyStore ks = KeyStore.getInstance("PKCS12");
try (var in = new FileInputStream("client.p12")) { ks.load(in, "keyPass".toCharArray()); }
KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
kmf.init(ks, "keyPass".toCharArray());

SSLContext ssl = SSLContext.getInstance("TLS");
ssl.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom());

HttpClient client = HttpClient.newBuilder().sslContext(ssl).build();
```

> **주의**: 테스트 편의용 “신뢰 검사 무시” SSLContext는 보안상 금지. (테스트 격리 환경에서만 일시 사용)

---

## 7. 재시도/백오프/레이트 리미트

```java
import java.net.http.HttpResponse;
import java.time.Duration;

int max = 3;
Duration wait = Duration.ofMillis(200);
HttpResponse<String> res = null;

for (int i = 1; i <= max; i++) {
    res = client.send(req, HttpResponse.BodyHandlers.ofString());
    int s = res.statusCode();

    if (s == 429 || s/100 == 5) {
        // Retry-After 헤더 존중
        var ra = res.headers().firstValue("Retry-After");
        if (ra.isPresent()) {
            try { Thread.sleep(Integer.parseInt(ra.get()) * 1000L); }
            catch (NumberFormatException e) { Thread.sleep(wait.toMillis()); }
        } else {
            Thread.sleep(wait.toMillis());
        }
        wait = wait.multipliedBy(2);
        continue;
    }
    break;
}
if (res == null || res.statusCode()/100 != 2) throw new IllegalStateException("HTTP " + (res==null?"?":res.statusCode()));
```

> **원칙**: **idempotent** 메서드(GET/PUT/DELETE/HEAD)만 기본 재시도. **POST**는 멱등 보장 또는 **멱등 키(Idempotency-Key)**를 사용할 때만.

---

## 8. 캐싱/조건부 요청 — ETag & If-None-Match

```java
HttpResponse<String> first = client.send(
        HttpRequest.newBuilder(URI.create("https://example.com/data")).GET().build(),
        HttpResponse.BodyHandlers.ofString());

String etag = first.headers().firstValue("ETag").orElse(null);
if (etag != null) {
    HttpRequest cond = HttpRequest.newBuilder(URI.create("https://example.com/data"))
            .header("If-None-Match", etag)
            .GET().build();

    HttpResponse<String> second = client.send(cond, HttpResponse.BodyHandlers.ofString());
    if (second.statusCode() == 304) {
        // 캐시 사용
    } else {
        // 최신 데이터
    }
}
```

---

## 9. 스트리밍 — 대용량 다운로드/업로드

### 9.1 다운로드 to 파일 (자동 스트림)
```java
import java.nio.file.Path;
HttpResponse<Path> r = client.send(req, HttpResponse.BodyHandlers.ofFile(Path.of("out.bin")));
```

### 9.2 다운로드 InputStream 직접 처리 (압축 수동 해제 예)
```java
import java.io.*;
import java.util.zip.GZIPInputStream;

HttpResponse<InputStream> r = client.send(req, HttpResponse.BodyHandlers.ofInputStream());
try (InputStream is = r.body();
     InputStream maybeGzip = "gzip".equalsIgnoreCase(r.headers().firstValue("Content-Encoding").orElse(""))
             ? new GZIPInputStream(is) : is;
     OutputStream os = new FileOutputStream("out.bin")) {
    is.transferTo(os);
}
```

### 9.3 업로드 스트리밍
```java
HttpRequest req = HttpRequest.newBuilder(URI.create("https://upload.example.com"))
        .header("Content-Type", "application/octet-stream")
        .POST(HttpRequest.BodyPublishers.ofInputStream(() -> {
            try { return new java.io.FileInputStream("bigfile.bin"); }
            catch (java.io.IOException e) { throw new RuntimeException(e); }
        }))
        .build();
```

---

## 10. 로깅/디버깅/관측성

### 10.1 JDK 디버그 로그
```
-Djdk.httpclient.HttpClient.log=all
```

### 10.2 커스텀 로깅(요청/응답)
```java
static HttpRequest logReq(HttpRequest r) {
    System.out.println("=> " + r.method() + " " + r.uri());
    r.headers().map().forEach((k,v)->System.out.println("=> " + k + ": " + v));
    return r;
}
static <T> HttpResponse<T> logRes(HttpResponse<T> res) {
    System.out.println("<= " + res.statusCode());
    res.headers().map().forEach((k,v)->System.out.println("<= " + k + ": " + v));
    return res;
}
```

---

## 11. 예외/에러 처리 — 안정성

| 예외/상태 | 의미/원인 | 대응 |
|---|---|---|
| `HttpTimeoutException` | 요청별 타임아웃 초과 | 타임아웃 상향/재시도 |
| `ConnectException` | 연결 실패/거절 | 네트워크/프록시 확인, 재시도 |
| `SSLHandshakeException` | 인증서/프로토콜 문제 | 신뢰/키 저장소 점검 |
| 3xx | 리다이렉트 | Redirect 정책/보안(메서드 변경) 확인 |
| 4xx | 클라이언트 오류 | 요청·인증·권한·쿼리 재점검 |
| 5xx | 서버 오류 | 백오프 재시도/알림 |

---

## 12. WebSocket (java.net.http.WebSocket)

```java
import java.net.URI;
import java.net.http.WebSocket;
import java.util.concurrent.*;

WebSocket ws = HttpClient.newHttpClient().newWebSocketBuilder()
        .buildAsync(URI.create("wss://echo.websocket.events"), new WebSocket.Listener() {
            @Override public void onOpen(WebSocket webSocket) {
                System.out.println("OPEN");
                webSocket.request(1);
            }
            @Override public CompletionStage<?> onText(WebSocket webSocket, CharSequence data, boolean last) {
                System.out.println("RECV: " + data);
                webSocket.request(1);
                return null;
            }
            @Override public void onError(WebSocket webSocket, Throwable error) {
                error.printStackTrace();
            }
        }).join();

ws.sendText("hello", true);
Thread.sleep(300);
ws.sendClose(WebSocket.NORMAL_CLOSURE, "bye");
```

---

## 13. 레거시: `HttpURLConnection` (요약 예)

```java
import java.io.InputStream;
import java.net.*;
import java.nio.charset.StandardCharsets;

URL url = new URL("https://httpbin.org/get");
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestMethod("GET");
conn.setConnectTimeout(3000);
conn.setReadTimeout(5000);

int code = conn.getResponseCode();
try (InputStream is = (code >= 200 && code < 300) ? conn.getInputStream() : conn.getErrorStream()) {
    String body = new String(is.readAllBytes(), StandardCharsets.UTF_8);
    System.out.println(code + " " + body);
}
conn.disconnect();
```

> 신규는 **HttpClient** 권장. 레거시 유지 목적으로만 사용.

---

## 14. 외부 라이브러리 (OkHttp 추천 예)

```kotlin
// Gradle
implementation("com.squareup.okhttp3:okhttp:4.12.0") // 최신 안정판 권장
```

```java
import okhttp3.*;

OkHttpClient ok = new OkHttpClient.Builder()
        .connectTimeout(java.time.Duration.ofSeconds(3))
        .readTimeout(java.time.Duration.ofSeconds(5))
        .build();

Request req = new Request.Builder()
        .url("https://httpbin.org/get")
        .get()
        .addHeader("Accept","application/json")
        .build();

try (Response resp = ok.newCall(req).execute()) {
    if (!resp.isSuccessful()) throw new java.io.IOException("HTTP " + resp.code());
    System.out.println(resp.body().string());
}
```

**멀티파트 (간단)**
```java
RequestBody fileBody = RequestBody.create(
        java.nio.file.Files.readAllBytes(java.nio.file.Path.of("hello.txt")),
        MediaType.parse("text/plain")
);
RequestBody multipart = new MultipartBody.Builder()
        .setType(MultipartBody.FORM)
        .addFormDataPart("meta","hello")
        .addFormDataPart("file","hello.txt", fileBody)
        .build();
```

---

## 15. 테스트 — MockWebServer / WireMock

- **단위 테스트**: HTTP 호출부를 인터페이스로 추상화하여 **Mock/Fake** 주입
- **통합 테스트**: **OkHttp MockWebServer** 또는 **WireMock**으로 가짜 서버 구성

```java
// MockWebServer 예(요약)
mockWebServer.enqueue(new MockResponse()
        .setResponseCode(200)
        .setBody("{\"ok\":true}")
        .addHeader("Content-Type","application/json"));
String baseUrl = mockWebServer.url("/").toString();
// 클라이언트의 베이스 URL을 baseUrl로 주입하고 검증
```

---

## 16. 공용 유틸 — 간단 GET/POST 래퍼 (실전용 뼈대)

```java
import java.net.http.*;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.io.IOException;

public final class Http {
    private final HttpClient client;
    public Http(HttpClient client) { this.client = client; }

    public String getJson(String url) throws IOException, InterruptedException {
        HttpRequest req = HttpRequest.newBuilder(URI.create(url))
                .header("Accept","application/json")
                .GET().build();
        HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));
        if (res.statusCode()/100 != 2) throw new IOException("HTTP " + res.statusCode() + ": " + res.body());
        return res.body();
    }

    public String postJson(String url, String json) throws IOException, InterruptedException {
        HttpRequest req = HttpRequest.newBuilder(URI.create(url))
                .header("Content-Type","application/json; charset=UTF-8")
                .POST(HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8))
                .build();
        HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));
        if (res.statusCode()/100 != 2) throw new IOException("HTTP " + res.statusCode() + ": " + res.body());
        return res.body();
    }
}
```

---

## 17. 성능·설계 체크리스트 (운영 준비)

1. **HttpClient 싱글턴**: 커넥션/HTTP2 세션 재사용  
2. **타임아웃**: `connectTimeout` + 요청별 `.timeout()`  
3. **에러 처리**: `2xx` 외 상태/본문 로깅, 예외 구분(`HttpTimeoutException`, `SSLHandshakeException` 등)  
4. **인코딩**: 쿼리=URLEncoder, 바디=명시적 charset  
5. **대용량**: `ofFile`/`ofInputStream`, 멀티파트 스트리밍(복사 회피)  
6. **재시도**: 429/5xx만, **백오프** + `Retry-After` 준수, 멱등성 보장  
7. **보안**: TLS 저장소/버전, 인증 헤더, 비밀 관리(환경/키체인)  
8. **관측성**: 요청/응답 로그(개발), 메트릭(성공률/지연/재시도 횟수)  
9. **테스트**: Mock 서버로 결정적 시나리오, 타임아웃/에러/리다이렉트 케이스 포함  
10. **HTTP/2**: 동일 호스트 다중 요청 시 **sendAsync**로 병렬성 극대화

---

## 18. 보너스 — 경량 “정책형” 실행기 (재시도/로그/타임아웃 래핑)

```java
import java.net.http.*;
import java.time.Duration;
import java.util.function.Function;

public final class HttpExec {
    private final HttpClient client;
    private final int maxRetry;

    public HttpExec(HttpClient client, int maxRetry) {
        this.client = client; this.maxRetry = maxRetry;
    }

    public <T> HttpResponse<T> run(HttpRequest req, HttpResponse.BodyHandler<T> h) throws Exception {
        Duration wait = Duration.ofMillis(200);
        HttpResponse<T> res = null;
        for (int i=1; i<=maxRetry; i++) {
            long t0 = System.nanoTime();
            try {
                System.out.println("=> " + req.method() + " " + req.uri());
                res = client.send(req, h);
                System.out.println("<= " + res.statusCode() + " (" + (System.nanoTime()-t0)/1_000_000 + "ms)");
                int s = res.statusCode();
                if (s == 429 || s/100 == 5) { Thread.sleep(wait.toMillis()); wait = wait.multipliedBy(2); continue; }
                return res;
            } catch (java.net.http.HttpTimeoutException te) {
                System.out.println("TIMEOUT -> retry"); Thread.sleep(wait.toMillis()); wait = wait.multipliedBy(2);
            }
        }
        return res; // 마지막 응답(또는 null) 반환; 호출자가 판단
    }
}
```

---

### 결론

- **JDK 11+ `HttpClient`**만으로 **HTTP/2/비동기/타임아웃/쿠키/프록시/TLS** 등 실무 핵심 요구를 충족한다.  
- **대용량/멀티파트/관측/인터셉터**가 중요해지면 **OkHttp** 같은 라이브러리를 혼용하라.  
- **테스트는 Mock 서버**, 운영은 **백오프·멱등성·TLS·로그/메트릭**으로 견고성을 확보하라.  
이 문서의 조각들을 프로젝트에 바로 붙여 넣어 **안전하고 빠른 HTTP 클라이언트**를 완성할 수 있다.