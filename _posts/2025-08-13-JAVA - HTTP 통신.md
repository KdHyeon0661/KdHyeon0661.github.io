---
layout: post
title: Java - HTTP 통신
date: 2025-08-13 19:20:23 +0900
category: Java
---
# HTTP 통신 — 자바로 간단한 클라이언트 작성 (JDK 11+ 중심)

자바에서 HTTP 요청을 보내는 대표 방법은  
1) **JDK 11+의 `java.net.http.HttpClient`(현대적·HTTP/2·비동기 지원)**,  
2) 레거시 **`HttpURLConnection`**,  
3) 외부 라이브러리(**OkHttp**, **Apache HttpClient**)입니다.  
아래는 **실전에서 바로 쓰는 최소 예제 + 베스트 프랙티스**를 JDK 11+ 표준 클라이언트 중심으로 정리했습니다.

---

## 1) 빠른 비교

| 방법 | 장점 | 단점/주의 |
|---|---|---|
| **HttpClient (JDK 11+)** | 표준 라이브러리, HTTP/2/비동기/타임아웃/리다이렉트, 쿠키/프락시 | 멀티파트 등은 직접 작성 필요 |
| HttpURLConnection | JDK 내장, 의존성 無 | 불편한 API, 에러 처리/스트림 관리 번거로움 |
| OkHttp / Apache | 성숙한 기능(멀티파트/연결풀/인터셉터/HTTP/2) | 외부 의존성 추가 필요 |

---

## 2) HttpClient 기본 세팅 (JDK 11+)

```java
import java.net.URI;
import java.net.http.*;
import java.nio.charset.StandardCharsets;
import java.time.Duration;

HttpClient client = HttpClient.newBuilder()
        .version(HttpClient.Version.HTTP_2)         // HTTP/1.1 도 자동 협상
        .connectTimeout(Duration.ofSeconds(3))      // 연결 타임아웃
        .followRedirects(HttpClient.Redirect.NORMAL)
        .build();
```

### 2.1 GET 요청 (쿼리 파라미터, 헤더, 타임아웃)
```java
import java.net.URLEncoder;
import static java.nio.charset.StandardCharsets.UTF_8;

String q = URLEncoder.encode("한글 테스트", UTF_8);
URI uri = URI.create("https://httpbin.org/get?q=" + q);

HttpRequest req = HttpRequest.newBuilder(uri)
        .GET()
        .header("Accept", "application/json")
        .timeout(Duration.ofSeconds(5))             // 읽기 타임아웃(요청별)
        .build();

HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));
int status = res.statusCode();
if (status / 100 != 2) {
    throw new IllegalStateException("HTTP " + status + " : " + res.body());
}
System.out.println(res.body());
```

### 2.2 POST(JSON) — Jackson으로 직렬화
**의존성** (택1)
- Maven
```xml
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.17.1</version>
</dependency>
```
- Gradle (Kotlin)
```kotlin
implementation("com.fasterxml.jackson.core:jackson-databind:2.17.1")
```

**코드**
```java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Map;

ObjectMapper om = new ObjectMapper();
String json = om.writeValueAsString(Map.of("name","Alice","age",30));

HttpRequest req = HttpRequest.newBuilder(URI.create("https://httpbin.org/post"))
        .header("Content-Type","application/json; charset=UTF-8")
        .POST(HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8))
        .build();

HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());
System.out.println(res.statusCode());
System.out.println(res.body());
```

### 2.3 x-www-form-urlencoded 전송
```java
String form = "username=" + URLEncoder.encode("kim", UTF_8) +
              "&password=" + URLEncoder.encode("secret", UTF_8);

HttpRequest req = HttpRequest.newBuilder(URI.create("https://example.com/login"))
        .header("Content-Type","application/x-www-form-urlencoded; charset=UTF-8")
        .POST(HttpRequest.BodyPublishers.ofString(form, UTF_8))
        .build();

HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));
```

### 2.4 멀티파트 업로드(파일) — 간단 구현 예
> JDK 표준엔 멀티파트 퍼블리셔가 없으므로 **바운더리/파트**를 직접 구성합니다. 파일이 크면 `ofInputStream` 사용을 권장합니다.

```java
import java.io.*;
import java.nio.file.*;

String boundary = "----JavaBoundary" + System.currentTimeMillis();
var baos = new ByteArrayOutputStream();
var w = new PrintWriter(new OutputStreamWriter(baos, StandardCharsets.UTF_8), true);

w.printf("--%s\r\n", boundary);
w.print("Content-Disposition: form-data; name=\"meta\"\r\n\r\n");
w.print("hello\r\n");

w.printf("--%s\r\n", boundary);
w.print("Content-Disposition: form-data; name=\"file\"; filename=\"hello.txt\"\r\n");
w.print("Content-Type: text/plain\r\n\r\n");
w.flush();
Files.copy(Path.of("hello.txt"), baos);  // 파일 바디
w.print("\r\n");
w.printf("--%s--\r\n", boundary);
w.flush();

HttpRequest req = HttpRequest.newBuilder(URI.create("https://httpbin.org/post"))
        .header("Content-Type", "multipart/form-data; boundary=" + boundary)
        .POST(HttpRequest.BodyPublishers.ofByteArray(baos.toByteArray()))
        .build();

HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());
```

### 2.5 비동기 요청 (`CompletableFuture`)
```java
HttpRequest req = HttpRequest.newBuilder(URI.create("https://httpbin.org/delay/1"))
        .GET().build();

client.sendAsync(req, HttpResponse.BodyHandlers.ofString())
      .thenApply(HttpResponse::body)
      .thenAccept(System.out::println)
      .exceptionally(ex -> { ex.printStackTrace(); return null; })
      .join(); // 데모용
```

### 2.6 쿠키/프록시/TLS/인증
```java
import java.net.*;
import java.net.Authenticator;
import java.net.PasswordAuthentication;
import java.util.*;

CookieManager cm = new CookieManager();
cm.setCookiePolicy(CookiePolicy.ACCEPT_ALL);

HttpClient client = HttpClient.newBuilder()
    .cookieHandler(cm)
    .proxy(ProxySelector.of(new InetSocketAddress("proxy.my", 8080)))
    .authenticator(new Authenticator() {
        @Override protected PasswordAuthentication getPasswordAuthentication() {
            return new PasswordAuthentication("user", "pass".toCharArray());
        }})
    .build();
// TLS 커스텀(사설 CA 등)은 SSLContext 설정 필요(별도 구성)
```

### 2.7 간단한 재시도(백오프)
> **주의**: 재시도는 보통 **idempotent** 메서드(GET/PUT/DELETE) 위주로. POST는 주의.
```java
import java.util.concurrent.TimeUnit;

int max = 3; long backoffMs = 200;
HttpResponse<String> res = null;
for (int i=1; i<=max; i++) {
    res = client.send(req, HttpResponse.BodyHandlers.ofString());
    int s = res.statusCode();
    if (s == 429 || s/100 == 5) {            // 재시도 가치가 있는 상태
        TimeUnit.MILLISECONDS.sleep(backoffMs);
        backoffMs *= 2;
    } else break;
}
```

### 2.8 디버깅(로깅)
실행 시 JVM 옵션에:
```
-Djdk.httpclient.HttpClient.log=all
```
> 요청/응답 헤더 등 디버그 출력(개발 환경에서만).

---

## 3) 레거시: `HttpURLConnection` (간단 예)
```java
import java.io.InputStream;
import java.net.*;
import java.nio.charset.StandardCharsets;

URL url = new URL("https://httpbin.org/get");
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestMethod("GET");
conn.setConnectTimeout(3000);
conn.setReadTimeout(5000);

int code = conn.getResponseCode();
try (InputStream is = (code >= 200 && code < 300) ? conn.getInputStream() : conn.getErrorStream()) {
    String body = new String(is.readAllBytes(), StandardCharsets.UTF_8);
    System.out.println(code + " " + body);
}
conn.disconnect();
```
> 간단하지만 **리소스/에러 처리**가 번거롭고, 비동기/HTTP/2 지원이 없어 **신규 개발엔 `HttpClient` 권장**.

---

## 4) 외부 라이브러리 예시

### 4.1 OkHttp (간결·강력 추천)
**의존성**
```kotlin
implementation("com.squareup.okhttp3:okhttp:4.12.0")
```
**코드**
```java
import okhttp3.*;

OkHttpClient ok = new OkHttpClient.Builder()
        .connectTimeout(java.time.Duration.ofSeconds(3))
        .readTimeout(java.time.Duration.ofSeconds(5))
        .build();

Request req = new Request.Builder()
        .url("https://httpbin.org/get")
        .get()
        .addHeader("Accept","application/json")
        .build();

try (Response resp = ok.newCall(req).execute()) {
    if (!resp.isSuccessful()) throw new java.io.IOException("HTTP " + resp.code());
    System.out.println(resp.body().string());
}
```
**멀티파트**
```java
RequestBody fileBody = RequestBody.create(
        java.nio.file.Files.readAllBytes(java.nio.file.Path.of("hello.txt")),
        MediaType.parse("text/plain")
);
RequestBody multipart = new MultipartBody.Builder()
        .setType(MultipartBody.FORM)
        .addFormDataPart("meta","hello")
        .addFormDataPart("file","hello.txt", fileBody)
        .build();

Request req = new Request.Builder()
        .url("https://httpbin.org/post")
        .post(multipart)
        .build();
```

---

## 5) 테스트 전략 (WireMock / MockWebServer)

- **단위 테스트**: HTTP 호출부를 **인터페이스**로 추상화하고 **Mock/Fake** 주입.
- **통합 테스트**: **WireMock**(자바 서버형), **OkHttp MockWebServer**(경량)로 가짜 서버 구성.
```java
// OkHttp MockWebServer (의존성: mockwebserver)
mockWebServer.enqueue(new MockResponse().setBody("{\"ok\":true}").setResponseCode(200));
String baseUrl = mockWebServer.url("/").toString();
// 클라이언트의 베이스 URL을 baseUrl로 지정해 테스트
```

---

## 6) 실전 체크리스트

- [ ] **타임아웃**: 연결/요청별(read) 타임아웃 설정  
- [ ] **에러 처리**: `2xx` 외 상태, 예외 메시지/본문 로깅  
- [ ] **인코딩**: 쿼리/폼에 `URLEncoder`, 바디에 명시적 `charset`  
- [ ] **리소스 관리**: try-with-resources, 큰 파일은 스트리밍(`ofInputStream`)  
- [ ] **보안**: 인증(Authorization 헤더, 토큰), TLS 검증(필요 시 신뢰 저장소)  
- [ ] **재시도 정책**: 429/5xx만, 백오프, **idempotent 우선**  
- [ ] **테스트**: 실제 외부 대신 Mock 서버로 결정성 확보  
- [ ] **로그**: 개발 환경에서만 상세 로깅

---

## 7) 미니 헬퍼(재사용 예) — 간단 GET/POST 유틸

```java
public final class Http {
    private final HttpClient client;

    public Http(HttpClient client) { this.client = client; }

    public String getJson(String url) throws Exception {
        HttpRequest req = HttpRequest.newBuilder(URI.create(url))
                .header("Accept","application/json")
                .GET().build();
        HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());
        if (res.statusCode()/100 != 2) throw new IOException("HTTP " + res.statusCode() + ": " + res.body());
        return res.body();
    }

    public String postJson(String url, String json) throws Exception {
        HttpRequest req = HttpRequest.newBuilder(URI.create(url))
                .header("Content-Type","application/json; charset=UTF-8")
                .POST(HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8))
                .build();
        HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());
        if (res.statusCode()/100 != 2) throw new IOException("HTTP " + res.statusCode() + ": " + res.body());
        return res.body();
    }
}
```

---

### 결론
- **JDK 11+ `HttpClient`**로 대부분의 REST 호출을 깔끔하게 처리할 수 있습니다.  
- **타임아웃/에러/인코딩/리소스**를 기본기로 챙기고, 멀티파트·인터셉터가 필요하면 **OkHttp** 같은 라이브러리를 고려하세요.  
- 테스트는 **Mock 서버**로 결정성을 확보하고, 운영에선 **백오프 재시도**와 **로깅**을 정교하게 다듬으면 됩니다.