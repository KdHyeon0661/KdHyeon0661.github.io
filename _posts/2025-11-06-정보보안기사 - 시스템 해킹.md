---
layout: post
title: 정보보안기사 - 시스템 해킹
date: 2025-11-06 14:25:23 +0900
category: 정보보안기사
---
# SECTION 01 시스템 기본 학습 — 05. 시스템 해킹

## 개요 — 시스템 해킹의 단계와 방어 포인트

- **초기 침투(Initial Access)**: 취약 서비스, 자격증명 오용, 잘못된 노출.
- **권한 상승(Privilege Escalation)**: 구성 실수(서비스·SUID·sudo), 메모리 결함.
- **자격증명 접근(Credential Access)**: 평문/캐시·LSASS 접근 방지, 키/토큰 보호.
- **지속성(Persistence)**: 스케줄러·서비스·레지스트리·systemd·cron.
- **측면 이동(Lateral Movement)**: RDP/SMB/WinRM/SSH 오남용.
- **방어 회피(Defense Evasion)**: 로깅 비활성화·인증 우회.
- **데이터 탈취(Exfiltration)**: 은닉 채널·클라우드 전송.
- **탐지·대응(Detection & Response)**: 로그 상관·EDR·격리·근절·복구.

**핵심 원칙**: 최소 권한, 최소 노출, 표준화된 로깅/감사, 재현 가능한 복구 절차, 자동화.

---

## 랩 토폴로지(안전한 실습 전용)

- **공격자 노드**: Kali/Ubuntu(단일 네트워크), 오프라인.
- **Windows VM**: Win10/11, Sysmon 설치, Defender ASR 활성.
- **Linux VM**: Ubuntu/RHEL 기반, `auditd`/`journald` 영속, `nftables` 적용.
- **“의도적 취약” 샘플**:
  - Linux: SUID 과다, 잘못된 sudoers, 취약 웹(로컬 바인딩).
  - Windows: 서비스 경로 인용 누락, 과도 권한 폴더, 약한 로컬 정책.
- **공유 네트워크 없음**(호스트부터 격리). 스냅샷 준비(롤백).

---

## — 방어 우선 가이드

### 주된 벡터

- 노출 서비스(약한 인증/취약 버전), 잘못된 방화벽, 기본 자격증명.
- 웹 앱 취약점(예: 파일업로드·RCE), 잘못된 리버스 프록시 설정.
- 피싱/매크로/원격 템플릿 호출 — **코드 제공·자동화 금지**(정책상).

### 방어 체크리스트

- [ ] **인바운드 기본 차단**, 필요 포트만 허용(nftables/ufw/firewalld).
- [ ] **키 기반 SSH**, RDP는 VPN+MFA+원천지 제한.
- [ ] **서비스 버전 고정/패치**, 취약 플러그인 제거.
- [ ] 공개 자산 **주기 스캔**(외부 명세+내부 CMDB)와 차이점 티켓화.

### Linux 간단 정책 예

```bash
# nftables 최소 정책(22, 80, 443만)

cat >/etc/nftables.conf <<'EOF'
table inet filter {
  chain input { type filter hook input priority 0;
    ct state established,related accept
    iif lo accept
    tcp dport {22,80,443} accept
    ip protocol icmp accept
    ip6 nexthdr icmpv6 accept
    drop
  }
}
EOF
nft -f /etc/nftables.conf && systemctl enable --now nftables
```

### Windows 포트 노출 억제 예

```powershell
# 인바운드 기본 차단, 관리망만 원격 허용(예: 10.0.0.0/24)

Set-NetFirewallProfile -Profile Domain,Private,Public -DefaultInboundAction Block
New-NetFirewallRule -DisplayName "Allow-RDP-From-IT" -Direction Inbound -Protocol TCP -LocalPort 3389 -RemoteAddress 10.0.0.0/24 -Action Allow
```

---

## — **구성 오류**를 찾고 고친다

### Linux: 잘못된 sudoers / SUID / PATH 하이재킹

#### 오남용 sudoers

- `NOPASSWD: /bin/vi`, `/usr/bin/find` 등 **셸 실행 가능 도구** 허용은 고위험.

**탐지(점검 스크립트)**:
```bash
# sudoers 위험 커맨드 후보 열람

grep -R "NOPASSWD" /etc/sudoers /etc/sudoers.d 2>/dev/null \
| grep -E "vi|vim|less|more|nano|awk|perl|python|find|tee|bash|sh|tar|cp|rsync"
```

**완화**: 허용 명령을 **비상호작용 래퍼**로 제한(절대 경로·고정 인자).
```bash
# /usr/local/sbin/restart_web.sh
#!/usr/bin/env bash

exec /usr/bin/systemctl restart web.service
```
`/etc/sudoers.d/webops`:
```
%webops ALL=(root) NOPASSWD: /usr/local/sbin/restart_web.sh
```

#### SUID 바이너리 남용

**탐지**:
```bash
find / -xdev -perm -4000 -type f -print 2>/dev/null | sort
```
**완화**: 불필요 SUID 제거.
```bash
chmod u-s /path/to/binary
```

#### PATH/LD_* 기반 하이재킹(설명·방어)

- root가 실행하는 스크립트가 **상대 경로/신뢰되지 않은 PATH**에 의존하면 위험.
**탐지**: root 크론·systemd에서 호출하는 스크립트의 **명령 경로가 풀 패스인지** 확인.
**완화**: `PATH=/usr/sbin:/usr/bin:/sbin:/bin` **고정** 및 명령 **절대 경로** 사용, `LD_PRELOAD` 무시(권한 파일에 `noexec` 마운트).

---

### Windows: 서비스 오남용 / 경로 인용 누락 / 과다 ACL

#### 서비스 경로 인용 누락(Unquoted Service Path)

- `ImagePath`가 `"C:\Program Files\My App\app.exe"` 대신 `C:\Program Files\My App\app.exe`로 설정되어 있고, 상위 폴더에 쓰기가능할 때 **권한 상승** 위험.

**탐지**:
```powershell
Get-CimInstance Win32_Service |
  Where-Object { $_.PathName -and $_.PathName -notmatch '^".*"$' } |
  Select-Object Name,State,StartMode,PathName
```

**완화**: 경로 **항상 인용부호** 처리, 서비스 실행 계정 최소화, 상위 폴더 **쓰기 금지**.

#### AlwaysInstallElevated 정책

- MSI를 관리 권한으로 설치 가능하게 하는 오래된 정책. **비활성 권장**.

**탐지/완화**:
```powershell
# 레지스트리 정책 읽기(둘 다 1이면 위험)

reg query HKCU\Software\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\Software\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
# 그룹정책에서 사용 안 함

```

#### 폴더/레지스트리 과다 권한

**탐지**:
```powershell
# Everyone/Users에 Modify 이상 권한이 있는 프로그램 폴더

$paths = "C:\Program Files","C:\Program Files (x86)","C:\"
foreach($p in $paths){ icacls $p | Select-String "(Everyone|BUILTIN\\Users).*(\(M\)|\(F\))" -Context 1,1 }
```
**완화**: `icacls`로 권한 축소, 상속 차단 후 필요한 그룹/서비스 계정만 허용.

---

## — 접근 자체를 차단하라

### Windows — LSASS 보호/토큰 보호

- **LSASS 보호**(CREDGUARD/RunAsPPL), **EDR/ASR**로 프로세스 접근 차단.
```powershell
# LSASS 보호(정책/GPO 권장, 예시는 레지스트리 수준)

New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Force | Out-Null
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name RunAsPPL -Type DWord -Value 1
```
- **ASR 규칙** 예: 자격증명 도용 차단군 활성.
```powershell
Set-MpPreference -AttackSurfaceReductionRules_Ids 9E6C4E1F-7D60-472F-BA1A-A0A3E78D85B5 -AttackSurfaceReductionRules_Actions Enabled
```
- **탐지**: Sysmon **Event ID 10(ProcessAccess)** 로 `lsass.exe`에 대한 의심 접근 경보.

### Linux — 키/토큰/SSH 에이전트 보호

- `~/.ssh` 권한 700/600, **에이전트 포워딩 금지**, `/proc` 제한(`hidepid=2`).
- **Kerberos** 사용 시 티켓 캐시 권한 엄격, 만료/폐기 자동화.

---

## — 등록 지점 가시화

### Linux

- **cron/systemd**/profile.d/autostart.
**탐지**:
```bash
# 스케줄러/유닛/오토런 훑기

crontab -l
ls -l /etc/cron.*/*
systemctl list-unit-files --type=service --state=enabled
grep -R --exclude-dir=.git -nE '(^|\s)(bashrc|profile\.d|rc\.local)' /etc /home 2>/dev/null
```
**완화**: 변경 감시(AIDE), `auditd`로 `/etc/systemd/system`·`/etc/cron*` 감시.

### Windows

- **Run/RunOnce** 키, **Scheduled Tasks**, **Services**, WMI Permanent Event.
**탐지**:
```powershell
Get-ScheduledTask | Where-Object {$_.State -eq 'Ready' -or $_.State -eq 'Running'} | Select-Object TaskName,TaskPath,State
Get-ItemProperty 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Run'
```
**완화**: **AppLocker/WDAC**, 서명 강제, 변경 시 SIEM 알림.

---

## — 통신면 제한·로그 상관

- **RDP/SMB/WinRM/SSH**를 **관리망**으로만 제한, **서버→서버** 횡이동 금지.
- Windows 이벤트: 4624/4625(로그온), 4672(특권), 4648(명시적 자격), 7045(서비스 생성).
- Linux: `/var/log/auth.log`, `journalctl -u sshd`, `last/lastb`.

**예: Windows 원격 명령 허용 조직의 방어형 구성**
```powershell
# WinRM은 관리 VLAN에서만 허용하고, 로컬 관리자 권한 분리(LAPS+Just Enough Admin)

Enable-PSRemoting -Force
New-NetFirewallRule -DisplayName "Allow-WinRM-From-AdminVLAN" -Direction Inbound -Protocol TCP -LocalPort 5985 -RemoteAddress 10.0.1.0/24 -Action Allow
```

---

## — 로깅 끄기 시도 탐지

- **Linux**: `auditd` 중지/규칙 삭제, `/var/log` 권한 변경, `LD_PRELOAD` 회피.
  **탐지 규칙 예**:
```bash
# auditd 서비스 제어 감시

auditctl -w /usr/sbin/service -p x -k svcctl
auditctl -w /bin/systemctl -p x -k svcctl
```

- **Windows**: 이벤트 로그 서비스 중지 시도(1102 로그 지움, 104 서비스 변경).
  **대응**: 시스템 보호 EDR, SIEM 알림, 서비스 권한 제한.

---

## — 억제·가시화

- **프록시/게이트웨이**에서 **대용량 비정상 전송** 탐지, **차단 정책**(DLP/Proxy·FW).
- 민감 경로는 **egress 제어**(특정 목적지만 허용), **암호화+정책 감사**.

---

## — **취약 코드 → 방어·수정** 중심

### — **실습은 랩 전용**

```c
// vuln_echo.c (의도적 취약: gets 사용 금지 예시용)
#include <stdio.h>
#include <string.h>

int main() {
    char buf[64];
    puts("type:");
    gets(buf); // 취약: 경계 검사 없음. 데모 전용.
    printf("you said: %s\n", buf);
    return 0;
}
```
**컴파일(보호 완화는 데모용으로만)**:
```bash
gcc vuln_echo.c -o vuln_echo -fno-stack-protector -z execstack -no-pie
```
> 주의: 위 플래그는 **절대 실서비스에 사용 금지**. 오직 취약성 이해와 **방어 테스트**를 위해서만 랩에서 사용.

**방어·수정**:
```c
// safe_echo.c
#include <stdio.h>
#include <string.h>

int main() {
    char buf[64] = {0};
    if(!fgets(buf, sizeof(buf), stdin)) return 1;
    buf[strcspn(buf, "\n")] = 0; // 개행 제거
    printf("you said: %s\n", buf);
    return 0;
}
```
**현대 빌드 방어 플래그**:
```bash
gcc safe_echo.c -o safe_echo -fstack-protector-strong -D_FORTIFY_SOURCE=2 -O2 -z noexecstack -fPIE -pie -Wl,-z,relro,-z,now
```
**운영 정책**: `ASLR(커널)`, `DEP/NX`, `Stack Canary`, `PIE`, `RELRO`, `seccomp`, **컴파일러 경고 에러화**(`-Werror`) 적용.

### 간단한 수식 메모(정수 오버플로우 개념)

정수 누산 시 오버플로우 조건(32비트 부호 정수) 개념식:
$$
\text{overflow} \iff (a > 0 \land b > 0 \land a + b < 0) \lor (a < 0 \land b < 0 \land a + b > 0)
$$
> 실제 코드는 **정수 안전 연산자**(언어/라이브러리 지원) 사용 권장.

---

## 탐지·로깅 — Sysmon/auditd 규칙 예시

### Windows(Sysmon)

- **Event ID 1**: 프로세스 생성, **ID 3**: 네트워크 접속, **ID 7**: 이미지 로드, **ID 10**: 프로세스 접근.
- **의심 접근**: `lsass.exe` 접근, `reg save` SAM, 비서명 드라이버 로드.

**간단 KQL 예시(Defender/Sentinel 계열)**
```text
DeviceProcessEvents
| where FileName in~ ("procdump.exe","rundll32.exe","reg.exe","wmic.exe","psexec.exe","nltest.exe")
| where InitiatingProcessAccountName !in ("SYSTEM","LOCAL SERVICE","NETWORK SERVICE")
| summarize count() by FileName, InitiatingProcessAccountName, bin(Timestamp, 1h)
```

### Linux(auditd)

- **규칙**: `/etc/passwd`, `/etc/shadow`, `/etc/sudoers`, `/etc/ssh/sshd_config`, `/etc/systemd/system` 쓰기/속성 변경 감시.
- **검색**:
```bash
ausearch -k shadow -ts today
ausearch -k unitdir -x systemctl -ts -1h
```

---

## — 단계별

### 시나리오 A: “취약 sudoers” 탐지·수정

1) 취약 환경: `NOPASSWD: /bin/vi`.
2) 증상: 특정 사용자로 셸 가능성.
3) **탐지**: sudoers 그랩/정책 리뷰.
4) **수정**: 래퍼 스크립트로 대체, `vi` 제외.
5) **검증**: `sudo -l` 재확인, `auditd`로 변경 로그 남김.

### 시나리오 B: Windows “인용 누락 서비스” 점검

1) `PathName` 비인용 서비스 식별 PowerShell.
2) 상위 폴더 권한 재검토(`icacls`).
3) **수정**: 서비스 경로 인용, 폴더 권한 축소.
4) **검증**: 재부팅/서비스 재시작·로그 무오류.

### 시나리오 C: “AIDE 무결성 + systemd 샌드박스”

1) 웹 유닛에 Protect*/Restrict* 적용.
2) AIDE 초기화 후 유닛 변경 시 보고서 차이 확인.
3) **조치**: 승인된 변경만 새 DB에 반영.

---

## 빠른 대응 Runbook(요약)

1) **감지**: EDR/SIEM 경보, 상관 이벤트 확인.
2) **격리**: 네트워크 세그먼트 차단, 계정 잠금, 자산 태깅.
3) **현장 보존**: 메모리/디스크 이미지(엔터프라이즈 툴), 로그 스냅샷.
4) **근절**: 악성 지속성 제거(서비스/스케줄러/레지스트리/유닛), 패치, 비밀/키 교체.
5) **복구**: 골든 이미지/백업 복원, 취약 구성 수정, 재발 방지 통제 배포.
6) **사후**: RCA/교훈·운영 표준 업데이트, 탐지 규칙 보강.

---

## 하드닝 체크리스트(시스템 해킹 관점)

- [ ] 인바운드 기본 차단, RDP/SSH는 **원천지 제한+MFA**.
- [ ] SSH **패스워드 금지**, 강한 KEX/Cipher/MAC, Fail2ban 동작.
- [ ] sudoers **최소 명령**, 위험 도구 제외, 래퍼 사용.
- [ ] SUID/세계 쓰기 경로 **정기 점검**, 불필요 SUID 제거.
- [ ] Windows 서비스 **경로 인용**, 폴더 ACL 최소화, AlwaysInstallElevated 금지.
- [ ] LSASS 보호/ASR/EDR, Sysmon 규칙·경보.
- [ ] auditd 핵심 규칙, journald 영속/보존/원격 전송.
- [ ] AppLocker/WDAC, Linux systemd 샌드박스/SELinux(AppArmor) Enforcing.
- [ ] 빌드/런타임 **메모리 보호(ASLR·DEP·Canary·PIE·RELRO·seccomp)**.
- [ ] 백업/키 관리, 복구 리허설 정례화.

---

## 예상문제(필기+실무 지향)

1) **sudoers**에서 허용하면 안 되는 커맨드 유형과 대안 설계를 설명하라.
2) **SUID** 위험 점검 명령을 제시하고, 줄이는 방법을 쓰라.
3) Windows **Unquoted Service Path**의 위험 조건과 완화책을 쓰라.
4) **LSASS 보호**를 활성화하는 설정(개념/정책)을 설명하고, 탐지 이벤트를 한 가지 제시하라.
5) Linux에서 **지속성** 확보에 활용되는 등록 지점 3가지를 들고, 각각 탐지 방법을 쓰라.
6) C 프로그램에서 **입력 경계 검증 실패**를 막는 컴파일/런타임 방어 기법 4가지를 쓰라.
7) **측면 이동**을 억제하기 위한 네트워크/계정/로깅 관점의 3중 방어를 설계하라.

예시 스니펫:
```bash
# SUID 점검

find / -xdev -perm -4000 -type f -print 2>/dev/null
```
```powershell
# Unquoted Service Path 점검

Get-CimInstance Win32_Service | Where-Object { $_.PathName -and $_.PathName -notmatch '^".*"$' } | Select Name,PathName
```
```text
# journald 지속성 설정 요약

Storage=persistent
SystemMaxUse=1G
MaxRetentionSec=2w
```

---

## 결론

- “시스템 해킹”을 **가르치는 목적**은 **실제 침해를 재현**하기 위함이 아니라, **방어 설계·탐지·대응**을 **정확히** 하기 위함이다.
- 구성 실수(권한·서비스·경로·정책)를 **표준화된 점검과 자동화**로 줄이고, **로깅/감사/EDR/LSM**으로 **가시성과 저지력**을 확보하라.
- 이렇게 구축된 방어 체계를 기반으로, 운영팀·개발팀·보안팀의 **공동 Runbook**을 꾸준히 개선하면, “시스템 해킹”은 곧 **시스템 방어의 품질 향상**으로 귀결된다.
