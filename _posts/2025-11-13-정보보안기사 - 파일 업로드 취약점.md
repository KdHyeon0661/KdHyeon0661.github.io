---
layout: post
title: 정보보안기사 - 파일 업로드 취약점
date: 2025-11-13 06:25:23 +0900
category: 정보보안기사
---
# SECTION 08 웹 애플리케이션 취약점 — 06. 파일 업로드(File Upload) 취약점 완전 정리 (우회 기법·폴리글랏·경로탈출·실행 차단·이미지/문서 가공·클라우드 저장·안전코드 템플릿·운영 체크리스트·실기 예상문제)

## 개요 — “업로드 1개가 서버의 경계가 된다”
파일 업로드는 편리하지만, **서버 측 코드 실행(RCE)**, **웹셸 설치**, **경로 탈출(Path Traversal)**, **악성 콘텐츠 배포(XSS/Drive-by)**, **스토리지/대역폭 고갈(DoS)**까지 광범위한 위험을 가진다.
핵심은 **“업로드를 절대 실행하지 않기(Non-executable)”**, **“콘텐츠 기반 검증(확장자 신뢰 금지)”**, **“격리 저장(별도 오리진/도메인)”**, **“재인코딩/무해화”**, **“평가 완료 전 비공개”**이다.

---

## 위협 모델 & 일반 흐름

```
[클라이언트] --(multipart/form-data)--> [웹앱] --(검증/가공/격리저장)--> [정적서버/오브젝트스토리지]
                                  ^                 ^                 ^
                               입력검증 실패     재인코딩 실패      공개권한 오설정
```

수식적 직관:
\[
R = \frac{P(\text{ValidationBypass}) \times I(\text{Execution/Exposure})}{D(\text{Detection/Isolation})}
\]
- \(P\)를 낮추기: **화이트리스트 + MIME 시그니처 검사 + 재인코딩 + 압축 해제 안전화**
- \(I\)를 낮추기: **실행권한/인터프리터 차단 + 별도 도메인/서브넷 + CSP/다운로드 처리**
- \(D\)를 높이기: **AV/콘텐츠 스캐닝 + 로깅/알람 + 샌드박스 처리**

---

## 주요 공격 벡터(요약 표)

| 범주 | 설명 | 대표 예시 |
|---|---|---|
| 실행형 업로드 | 스크립트/바이너리 업로드 후 직접 실행 | `.php`, `.jsp`, `.aspx`, `.exe`, `.cgi` |
| 확장자 우회 | 이중 확장/대체 인코딩/대소문자 | `shell.php.jpg`, `SHeLl.PhP`, `pHp3` |
| Content-Type 위조 | 헤더 `image/jpeg` 등 임의 지정 | 클라이언트가 마음대로 설정 가능 |
| 시그니처 우회·폴리글랏 | 헤더 매직+스크립트 혼합 | `GIF89a` + PHP, PDF/JPG 폴리글랏 |
| 경로 탈출 | 저장 경로에 `../` 주입 | `../../../../webroot/shell.php` |
| 서버사이드 렌더 취약 | SVG/MD/Office JS 내장 | `<svg onload=...>`, PDF-JS |
| 압축파일 해제(Zip Slip) | 아카이브 경로 탈출 | ZIP/TAR에 `../` 엔트리 |
| 백엔드후처리 취약 | ImageMagick/ffmpeg 호출 | 외부 프로세스 주입/SSRF |
| 악성 문서/AV미회피 | 매크로/DDE/JS 내장 | `.docm`, `.xlsm`, `.pdf` JS |
| 대용량/폭탄 | ZIP bombs, huge files | 자원 고갈(메모리/CPU/디스크) |

---

## 최소 안전 설계(10원칙)

1. **허용 파일군 화이트리스트**(MIME/확장자/시그니처 동시 검사).
2. **콘텐츠 시그니처 검사(libmagic)**로 확장자 신뢰 금지.
3. **재인코딩/무해화**: 이미지/문서는 **파서로 열어 재저장**(EXIF 제거, 스크립트 제거).
4. **업로드 디렉터리 실행 금지**: 웹서버/앱서버에서 **코드 실행**·**서빙 해석** 차단.
5. **별도 도메인/오리진**에서만 서빙(쿠키 분리, CSP 별도).
6. **평가 완료 전 비공개**: 승인(AV/YARA/규칙 통과) 전에는 **403/프리사인 URL 없음**.
7. **파일명/경로는 서버 생성**(UUID), **원본 파일명 저장은 메타데이터로만**.
8. **압축 해제 금지 or 안전해제**(경로 정규화/크기·개수·심볼릭 링크 차단).
9. **사이즈/해상도/비트레이트/페이지수 상한**과 **타임아웃**.
10. **로깅/추적**: 업로더·IP·UA·해시(SHA-256)·검증결과 기록.

---

## 서버/웹서버 레벨 실행 차단 설정

### Nginx — 업로드 디렉터리 실행 금지 & 강제 다운로드
```nginx
# 업로드는 /var/www/uploads 에 존재(웹루트 밖 권장). 아래는 예시로 정적 노출하는 경우.
location /uploads/ {
    alias /var/www/uploads/;
    # 스크립트 해석 금지
    default_type application/octet-stream;
    types { }                      # MIME 매핑 제거
    add_header X-Content-Type-Options "nosniff";
    add_header Content-Disposition "attachment";
    # 특정 확장 금지
    location ~* \.(php|phtml|phar|pl|cgi|jsp|jspx|asp|aspx|sh|py)$ { return 403; }
}
```

### Apache(.htaccess) — PHP/CGI 해석 차단
```apache
# 업로드 디렉터리 내부 .htaccess
RemoveHandler .php .phtml .phar .pl .cgi .jsp .asp .aspx
RemoveType .php .phtml .phar .pl .cgi .jsp .asp .aspx
php_flag engine off
Options -ExecCGI
Header set X-Content-Type-Options "nosniff"
Header set Content-Disposition "attachment"
```

### IIS(web.config) — 실행 금지
```xml
<configuration>
  <system.webServer>
    <handlers>
      <remove name="PHP_via_FastCGI" />
      <remove name="CGI-exe" />
      <!-- 업로드 경로에 대해 전체 실행형 거부 -->
      <add name="DenyAllScripts" path="*" verb="*" modules="IsapiModule"
           scriptProcessor="" resourceType="File" preCondition="bitness32" requireAccess="Read" />
    </handlers>
    <staticContent>
      <remove fileExtension=".php" />
      <remove fileExtension=".aspx" />
    </staticContent>
    <httpProtocol>
      <customHeaders>
        <add name="X-Content-Type-Options" value="nosniff" />
        <add name="Content-Disposition" value="attachment" />
      </customHeaders>
    </httpProtocol>
  </system.webServer>
</configuration>
```

---

## 백엔드 안전 코드 템플릿

### Python (Flask) — 시그니처 검사 + 이미지 재인코딩 + 격리저장
```python
from flask import Flask, request, abort
from werkzeug.utils import secure_filename
import magic, secrets, os, pathlib
from PIL import Image

ALLOWED = {"image/png", "image/jpeg"}  # 예시
UPLOAD_DIR = pathlib.Path("/srv/uploads-private")  # 웹에서 직접 접근 불가
PUBLIC_DIR = pathlib.Path("/srv/uploads-public")   # 공개용(정적 오리진)

def sniff_mime(buf: bytes) -> str:
    return magic.from_buffer(buf, mime=True)

def save_private(fname: str, data: bytes) -> pathlib.Path:
    UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
    p = UPLOAD_DIR / fname
    with open(p, "wb") as f: f.write(data)
    os.chmod(p, 0o640)
    return p

def reencode_image(src_path: pathlib.Path, mime: str) -> pathlib.Path:
    # EXIF 제거, 컬러 프로필 제거, 품질 제한, PNG/JPEG만
    with Image.open(src_path) as im:
        im = im.convert("RGB")
        dst = PUBLIC_DIR / (src_path.stem + ".jpg")
        PUBLIC_DIR.mkdir(parents=True, exist_ok=True)
        im.save(dst, format="JPEG", quality=85, optimize=True)
        os.chmod(dst, 0o640)
        return dst

app = Flask(__name__)

@app.post("/upload")
def upload():
    f = request.files.get("file")
    if not f: abort(400, "file required")
    # 1) 크기 상한(예: 5MB)
    f.stream.seek(0, os.SEEK_END)
    size = f.stream.tell()
    if size > 5*1024*1024: abort(413, "too large")
    f.stream.seek(0)

    # 2) sniffer로 MIME 판별
    head = f.read(4096)
    mime = sniff_mime(head)
    if mime not in ALLOWED: abort(415, "unsupported type")
    f.stream.seek(0)

    # 3) 서버가 파일명 생성(원본명은 메타로 DB 저장)
    rid = secrets.token_hex(16)
    fname = f"{rid}.bin"
    path = save_private(fname, f.read())

    # 4) 이미지 재인코딩(무해화) 후 공개 디렉터리로 배치
    if mime.startswith("image/"):
        pub = reencode_image(path, mime)
        # 5) 공개 URL은 별도 정적 오리진(예: img.cdn.example)으로 제공
        return {"id": rid, "url": f"https://img.example.com/{pub.name}"}

    abort(415, "only images allowed")
```

### Node.js (Express + Multer) — 파일명/경로 고정 + S3 사전검증 업로드
```js
import express from "express";
import multer from "multer";
import crypto from "node:crypto";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import fileType from "file-type";
import { readFile } from "node:fs/promises";

const app = express();
const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 5 * 1024 * 1024 } });
const s3 = new S3Client({ region: "ap-northeast-2" });
const ALLOWED = new Set(["image/png", "image/jpeg"]);

app.post("/upload", upload.single("file"), async (req, res) => {
  if (!req.file) return res.status(400).send("file required");
  const ft = await fileType.fromBuffer(req.file.buffer);
  if (!ft || !ALLOWED.has(ft.mime)) return res.status(415).send("unsupported");

  const key = `pending/${crypto.randomBytes(16).toString("hex")}.${ft.ext}`;
  await s3.send(new PutObjectCommand({
    Bucket: process.env.BUCKET,
    Key: key,
    Body: req.file.buffer,
    ContentType: ft.mime,
    ACL: "private" // 승인 전 절대 public-read 금지
  }));

  // 이후 워커에서 AV/재인코딩 → safe/ 경로로 move/copy, 그때만 서빙
  res.json({ id: key });
});

app.listen(3000);
```

### Java (Spring Boot) — MultipartFile 검증 + Zip Slip 방지
```java
@PostMapping("/upload")
public ResponseEntity<?> upload(@RequestParam("file") MultipartFile f) throws Exception {
    if (f.isEmpty() || f.getSize() > 5 * 1024 * 1024) return ResponseEntity.status(413).build();

    // magic(리눅스 libmagic 바인딩) 또는 tika 사용
    String mime = tika.detect(f.getBytes());
    if (!List.of("image/png", "image/jpeg").contains(mime)) return ResponseEntity.status(415).build();

    Path base = Paths.get("/srv/uploads-private");
    Files.createDirectories(base);
    String rid = UUID.randomUUID().toString().replace("-", "");
    Path p = base.resolve(rid + ".bin").normalize();
    if (!p.startsWith(base)) throw new SecurityException("path traversal");
    Files.write(p, f.getBytes(), StandardOpenOption.CREATE_NEW);

    // 이미지 재인코딩은 별도 서비스/워커로 위임(타임아웃/리소스 제한)
    return ResponseEntity.ok(Map.of("id", rid));
}
```

---

## 이미지/문서 무해화(핵심 포인트)

- **이미지**: **열어서 다시 저장**(re-encode) → EXIF/ICC/프로파일 제거, 지원 포맷 축소(PNG/JPEG). **SVG는 text이므로 금지 or Sanitizer**로 스크립트/`foreignObject` 제거 후 벡터→래스터 변환 권장.
- **PDF**: JS/액션 제거, **qpdf/ocrmypdf** 등으로 재생성, 페이지/폰트 개수/파일 크기 상한.
- **Office**: `.docx/.xlsx`만 허용(매크로형 `.docm/.xlsm` 금지).
- **오디오/동영상**: ffmpeg 재인코딩(컨테이너/코덱 화이트리스트), 메타데이터 제거.

**ImageMagick 보안 설정(policy.xml) 예시**
```xml
<policymap>
  <policy domain="coder" rights="none" pattern="EPHEMERAL" />
  <policy domain="path" rights="none" pattern="@*" />
  <policy domain="coder" rights="read|write" pattern="JPEG,PNG" />
  <policy domain="coder" rights="none" pattern="PDF,PS,SVG,MIFF,MVG,URL" />
  <policy domain="resource" name="memory" value="256MiB"/>
  <policy domain="resource" name="map" value="256MiB"/>
</policymap>
```

---

## 클라우드 저장(S3/GCS/Azure) 안전 패턴

- **버킷 수준**: `BlockPublicAcls = true`, `PublicAccessBlock = true`, 버킷 정책으로 **리퍼러/오리진 기반 제한**.
- **업로드 단계**: **서버를 통해 검증 후** → 안전 경로에만 `CopyObject`.
- **URL 발급**: 공개 필요 시 **짧은 만료 pre-signed URL** 또는 **CDN 서명 URL**.
- **서빙 도메인 분리**: `upload.example.com`이 아닌 `cdn.example-uploads.com` (쿠키/세션 분리).
- **CSP 예시(업로드 전용 오리진)**:
```http
Content-Security-Policy: default-src 'none'; img-src https://cdn.example-uploads.com; media-src https://cdn.example-uploads.com; object-src 'none'; frame-ancestors 'none';
X-Content-Type-Options: nosniff
```

---

## 악성 예시 & 우회 기법 데모(교육용)

### 1. 폴리글랏(이미지+PHP)
```
GIF89a
<?php system($_GET['cmd']); ?>
```
- 서버가 **확장자 .jpg**만 확인하고 `Content-Type: image/gif`로 제공 →
  업로드 디렉터리에서 **PHP 해석 허용**이면 `shell.jpg`가 실행될 수 있다 → **서버 설정으로 실행 차단** 필수.

### 2. 이중 확장자
```
resume.pdf.php
```
- Windows/IIS/Apache 설정 조합에 따라 **뒤 확장자 우선**으로 실행.
  **서버측 저장 시 확장자를 강제 교체**(`.bin` 등)하고 **다운로드 시 Content-Disposition**으로 원본명 표기.

### 3. Zip Slip(경로 탈출) 방지 스니펫 (Java)
```java
try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zip))) {
  ZipEntry e;
  while ((e = zis.getNextEntry()) != null) {
    Path target = dest.resolve(e.getName()).normalize();
    if (!target.startsWith(dest)) throw new SecurityException("zip slip");
    // 파일 크기/개수/확장자 상한 확인 후 쓰기
  }
}
```

---

## 안티바이러스/규칙 기반 점검

### ClamAV(간단 예시)
```bash
# 데몬 준비
freshclam && clamd
# 단발성 검사
clamscan --no-summary /srv/uploads-private/a1b2.bin
```

### Python에서 ClamAV socket 사용
```python
import socket, pathlib
def clamav_scan(path: pathlib.Path) -> bool:
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect("/var/run/clamav/clamd.ctl")
    s.sendall(f"SCAN {path}\n".encode())
    data = s.recv(4096).decode()
    return "OK" in data  # FOUND면 차단/격리
```

> **유의**: AV는 **보조 수단**이다. **재인코딩/무해화/실행차단**이 우선, AV는 보강.

---

## 업로드 처리 파이프라인(참고 설계)

```
[1] 수신(메모리/임시) → [2] 크기/헤더 상한 → [3] MIME 시그니처(libmagic)
 → [4] 서버생성 파일명(UUID)/사설 저장 → [5] AV+YARA+규칙 스캔
 → [6] 포맷별 파서로 열기/재인코딩(EXIF 제거) → [7] 비주얼/문서 무해화
 → [8] 공용 버킷 safe/ 경로로 복사 → [9] CDN 캐시/서명URL 발급
 → [10] 로깅(SHA-256, 사이즈, MIME, 처리결과)
```

---

## 브라우저/전달 보안 헤더

- `Content-Disposition: attachment; filename="..."` (다운로드 강제)
- `X-Content-Type-Options: nosniff` (브라우저 MIME 스니핑 차단)
- `Content-Security-Policy` (업로드 오리진에 최소 권한)
- `Cross-Origin-Resource-Policy: cross-origin` (의도한 공유만)
- `Cache-Control`(민감파일은 no-store)

---

## 성능/용량 관리

- **최대 파일 크기**, **동시 업로드 수**, **1일 총합 제한**.
- 이미지: 리사이징/썸네일 **서버사이드 큐**(워커)로 비동기 처리, 원본은 **승인 전 비공개**.
- 압축: **해제 금지**가 원칙, 필요 시 **개수·합계 크기 상한** 및 **타임아웃**.

---

## 운영 관제 포인트

- **의심 확장자 업로드 시도** 증가.
- **검증 실패 비율 급증**(봇형 악용 가능).
- **업로드 후 즉시 다량 접근**(링크배포/피싱).
- **AV 탐지/정책 차단** 이벤트 알림(웹훅+SIEM).
- **스토리지 성장률 급증**(폭탄/스팸).

---

## 보안 테스트(합법·사전승인 환경)

- **SAST**: 업로드 엔드포인트에서 `Content-Type`만 신뢰, 확장자 그대로 저장, 실행 가능한 경로로 배치하는 부분 탐지.
- **DAST**:
  - 이중확장/대소문자/비표준 확장 업로드 → 접근 시 실행/다운로드 여부 확인
  - 폴리글랏 파일(이미지 헤더 + 스크립트) → 이미지 파서 재인코딩이 제거하는지 확인
  - ZIP Slip PoC → 해제 루틴 방호 확인
  - 큰 파일/ZIP bomb → 자원 상한 동작 확인

---

## 체크리스트(현장용)

- [ ] 허용 포맷 **화이트리스트**(확장자+MIME+시그니처 3중 확인)
- [ ] **서버 생성명(UUID)**으로 저장, 원본명은 **메타데이터만**
- [ ] **업로드 디렉터리 실행 금지**(Nginx/Apache/IIS)
- [ ] **웹서버는 항상 attachment + nosniff**
- [ ] **별도 도메인/오리진/서브넷**으로 격리 서빙
- [ ] **평가 완료 전 비공개**(private ACL, presign 금지)
- [ ] 이미지/문서 **재인코딩/무해화**, SVG/PDF/Office는 별도 정책
- [ ] **압축 해제 금지** 또는 Zip Slip/용량 상한/링크 금지
- [ ] **AV/YARA** 보강, 실패 시 격리/삭제
- [ ] **사이즈/해상도/페이지수/시간** 상한, 워커 타임아웃
- [ ] **로깅**: 업로더, IP, 해시, MIME, 처리결과, 실패 사유
- [ ] **정기 점검**: 버킷 퍼블릭 액세스, 웹서버 실행 핸들러 재확인

---

## 실기 예상문제

1) **문항**: 다음 업로드 코드의 문제점을 3가지 이상 지적하고 개선안을 쓰시오.
```php
// 교육용 취약 예시
move_uploaded_file($_FILES['f']['tmp_name'], "/var/www/html/uploads/".$_FILES['f']['name']);
header("Location: /uploads/".$_FILES['f']['name']);
```
**모범요지**
- 원본 파일명 그대로 사용(경로 탈출/이중확장).
- 웹루트 내부 저장 + 실행 위험.
- 검증 없음(MIME/시그니처/크기).
- 개선: 서버생성명(UUID) + 웹루트 밖 저장 → 검증/재인코딩 후 별도 오리진에서 attachment로 서빙.

2) **문항**: MIME 검증 시 `Content-Type` vs **시그니처(libmagic)** 차이와 우선순위는?
**정답**: 클라이언트 `Content-Type`은 신뢰 불가. **시그니처 기반**을 우선하고, 확장자/화이트리스트와 **교차검증**.

3) **문항**: ZIP 업로드 후 서버에서 해제하는 기능이 있다. 어떤 위험과 방어를 설계해야 하는가?
**정답 요지**: Zip Slip 경로 탈출, 파일 개수/합계 크기 폭탄, 링크/권한 문제. **경로 정규화/상한/링크 거부/타임아웃**.

4) **문항**: Nginx/Apache/IIS에서 업로드 디렉터리 실행 차단을 각 1가지 설정으로 제시하라.
**정답**: (본문 설정 예시 인용 가능)

5) **문항**: 이미지 업로드인데 PHP 웹셸이 “이미지처럼” 업로드/접근되었다. 서버 설정·코드 측면에서 무엇이 잘못되었나?
**정답**: 이미지 검증 미흡(시그니처/재인코딩 없음), 업로드 경로에서 **스크립트 해석 허용**, `nosniff`/`attachment` 미적용, 별도 오리진 격리 부재.

---

## 결론
- 파일 업로드 보안의 본질은 **실행 차단**, **콘텐츠 기반 검증**, **격리·무해화**, **지연 공개(승인 후 공개)**, **강력한 운영 정책**이다.
- 본문 템플릿을 팀 **표준 코드/서버 설정**으로 채택하고, **클라우드 버킷·CDN·워커 파이프라인**과 **AV/정책 스캐닝**을 자동화하라.
- 점검·로깅·관제를 통해 우회 시도(폴리글랏/이중확장/ZIP slip/대용량)를 조기에 탐지하고, **실행 환경 자체**를 영구적으로 **비실행 상태**로 유지하라.
