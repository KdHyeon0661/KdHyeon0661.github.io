---
layout: post
title: 컴퓨터시스템 - 프로시저
date: 2025-07-26 14:20:23 +0900
category: 컴퓨터시스템
---
# 🧩 프로시저: 제어 흐름의 추상화

프로시저(Procedure)는 프로그램 내에서 특정 작업을 수행하는 코드 블록으로, 고수준 언어에서는 `함수(function)` 또는 `서브루틴(subroutine)`이라고도 부른다. 시스템 수준에서는 이러한 프로시저 호출이 **스택**과 **레지스터**, 그리고 **명령어 흐름 조작(jump)** 등을 통해 구현된다.

---

## 📌 프로시저란 무엇인가?

- 프로시저는 **작업의 추상화**이다.
- 동일한 코드 블록을 여러 번 재사용할 수 있게 해주며, 프로그램의 **모듈화(modularity)** 와 **가독성(readability)** 을 향상시킨다.
- 함수 호출은 일시적으로 **현재 실행 중인 컨텍스트(context)** 를 저장하고, **새로운 작업을 수행**한 뒤, **원래 위치로 돌아오는 작업**을 포함한다.

---

## 🔁 함수 호출과 복귀의 과정

C 코드:
```c
int square(int x) {
    return x * x;
}

int main() {
    int result = square(5);
}
```

어셈블리 수준에서는 다음과 같은 일이 일어난다.

1. **인자(argument)** 를 전달한다.
2. `call` 명령어를 통해 **프로시저로 점프**한다.
3. **복귀 주소(return address)** 가 **스택에 저장**된다.
4. **함수가 로컬 변수와 레지스터를 위한 스택 프레임을 만든다.**
5. **작업을 수행하고 결과를 반환한다.**
6. `ret` 명령어를 통해 원래 위치로 돌아간다.

---

## 📦 스택 프레임(Stack Frame)

함수가 호출되면, 호출자의 상태를 저장하고 피호출자가 작업을 수행할 수 있도록 하기 위해 **스택 프레임(stack frame, 또는 활성 레코드 activation record)** 이 스택 상에 생성된다.

### 스택 프레임 구조

```
|----------------------|
|  반환 주소 (Return)  |
|----------------------|
|  저장된 %rbp        |
|----------------------|
|  지역 변수          |
|----------------------|
|  임시 데이터        |
|----------------------|
```

- `%rbp`: 프레임 포인터 (Base Pointer)
- `%rsp`: 스택 포인터 (Stack Pointer)
- 함수 진입 시: `push %rbp` → `mov %rsp, %rbp`

---

## 📌 호출 규약 (Calling Convention)

### System V AMD64 ABI 기준 (x86-64 리눅스에서 사용)

**인자 전달 방식:**
- 1~6번째 인자 → 레지스터 사용
  - `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9`
- 7번째 이상 인자 → 스택 사용
- 반환 값 → `%rax` 사용

```c
long sum(long a, long b, long c);
```

호출 시:
- `a` → `%rdi`, `b` → `%rsi`, `c` → `%rdx`

---

## 🧮 함수 예제: sum3

C 코드:
```c
long sum3(long x, long y, long z) {
    long t = x + y + z;
    return t;
}
```

어셈블리:
```asm
sum3:
    movq %rdi, %rax      # x → rax
    addq %rsi, %rax      # y
    addq %rdx, %rax      # z
    ret
```

---

## 🛠 함수 호출자와 피호출자의 역할

| 역할           | 설명 |
|----------------|------|
| **호출자** | 인자를 전달하고, 반환값을 받으며, 함수 진입 전/후 레지스터를 보존 |
| **피호출자** | 레지스터와 스택 프레임 설정 및 정리, 반환값 설정, `ret` 수행 |

### 호출자 보존(caller-saved)
- `%r10`, `%r11`, `%rax`, `%rcx`, `%rdx`, `%rsi`, `%rdi`
- 함수 호출 전에 이들을 백업해둬야 함

### 피호출자 보존(callee-saved)
- `%rbx`, `%rbp`, `%r12`~`%r15`
- 함수 내부에서 이들을 변경하면 `push/pop`으로 저장 및 복원해야 함

---

## 🧩 리턴 주소와 보안

리턴 주소(return address)는 `call` 명령어에 의해 **스택에 push**된다. 이 주소를 악의적으로 덮어쓰는 것이 **버퍼 오버플로우(Buffer Overflow)** 공격의 핵심이다.

```c
void foo() {
    char buf[8];
    gets(buf); // 위험: 리턴 주소가 덮일 수 있음
}
```

---

## 🧮 재귀 함수와 스택

재귀 함수는 **스택 프레임이 재귀적으로 누적**된다.

```c
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```

재귀 깊이만큼 스택 사용량이 증가하며, 너무 깊은 재귀는 **스택 오버플로우**를 유발할 수 있다.

---

## 🧪 예제: 프로시저와 레지스터

```c
long f(long x, long y) {
    long a = x + y;
    long b = x - y;
    return a * b;
}
```

어셈블리:
```asm
f:
    movq %rdi, %rax      # x
    addq %rsi, %rax      # x + y → a
    movq %rdi, %rdx      # x
    subq %rsi, %rdx      # x - y → b
    imulq %rdx, %rax     # a * b
    ret
```

---

## 🧠 프로시저와 최적화

컴파일러는 프로시저를 최적화하면서 인라인 확장(inlining), 레지스터 할당 최적화 등을 수행할 수 있다.

예:
```c
int square(int x) {
    return x * x;
}

int main() {
    return square(5); // 컴파일러는 이 호출을 인라인으로 대체할 수 있음
}
```

---

## 🗂 정리: 함수 호출의 핵심

| 항목 | 설명 |
|------|------|
| **call** | 스택에 리턴 주소 저장 후 함수로 점프 |
| **ret** | 스택에서 주소 꺼내 복귀 |
| **스택 프레임** | 로컬 변수, 저장 레지스터, 반환 주소 저장 |
| **호출 규약** | 레지스터와 스택을 통한 인자 전달 규칙 |
| **보안 이슈** | 스택 기반의 리턴 주소 덮어쓰기는 보안 위험 |
| **최적화** | 함수 인라인, tail call optimization 등이 있음 |