---
layout: post
title: 컴퓨터시스템 - 프로시저
date: 2025-07-26 14:20:23 +0900
category: 컴퓨터시스템
---
# 프로시저(Procedure): 제어 흐름의 추상화

## 1. 프로시저란 무엇인가 — 추상화의 본질

- **프로시저/함수**는 작업을 **이름**으로 묶고, **입력(인자)** → **계산** → **출력(반환값)** 을 캡슐화하는 단위다.
- **재사용·모듈화·가독성**을 제공하며, 시스템 수준에서는 **스택**과 **레지스터**, **분기** 명령으로 구현된다.
- 핵심 아이디어: **호출자(CallER)** 의 실행 문맥을 잠시 보관하고 **피호출자(CallEE)** 가 실행한 뒤 **복귀**한다.

---

## 2. 함수 호출의 여섯 단계 (고수준 → 저수준 매핑)

C 예시:
```c
int square(int x) { return x * x; }

int main(void) {
    int r = square(5);
    return r;
}
```

기계 수준의 일반 흐름:

1. **인자 전달**: 레지스터(우선)와 스택으로 함수 인자를 전달한다.
2. **호출(call)**: `call target` — **다음 명령 주소(복귀 주소)** 를 **스택에 push**하고 `target`으로 분기.
3. **진입(prologue)**: 프레임 포인터 저장/설정, 스택 공간 확보, callee-saved 레지스터 저장.
4. **실행(body)**: 연산 수행, 지역 변수 접근, 필요하면 다른 함수를 또 호출.
5. **탈출(epilogue)**: callee-saved 레지스터 복원, 스택 정리, 반환값 레지스터 설정.
6. **복귀(ret)**: 스택 최상단의 **복귀 주소**로 점프.

---

## 3. 스택과 스택 프레임 — 무엇이 저장되는가

스택은 **낮은 주소**→**높은 주소** 또는 그 반대로 자라도록 정의되며, x86-64 SysV에서 **RSP**(스택 포인터)가 **8바이트 단위**로 변한다.

### 3.1 전형적 프레임 모식도

```
높은 주소
|------------------------------|
|   호출자의 ...               |
|------------------------------|
|   인자 (7번째 이후)          |  ← call 전에 caller가 미리 배치
|------------------------------|
|   return address             |  ← call이 push
|------------------------------|
|   saved %rbp                 |  ← prologue: push %rbp
|------------------------------|
|   callee-saved regs (rbx...) |
|------------------------------|
|   local variables / temps    |  ← sub $imm, %rsp
|------------------------------|  낮은 주소
```

- **%rbp**: 선택적 프레임 포인터(최적화 시 생략 가능).
- **%rsp**: 스택 포인터(항상 유효).
- **로컬 변수**: `subq $N, %rsp`로 확보한 공간에 배치.

### 3.2 프로로그/에필로그(전형)

```asm
# SysV AMD64, 프레임포인터 사용 버전
foo:
    pushq %rbp
    movq  %rsp, %rbp
    subq  $32, %rsp        # 로컬 32B 확보 (16B 정렬 고려)
    ...
    leave                   # mov %rbp,%rsp; pop %rbp
    ret
```

- **정렬(Alignment)**: **호출 직전** 스택은 **16바이트 정렬**을 만족해야 한다(벡터/SIMD 인스트럭션·ABI 요구).
  실무 규칙: “**함수 진입 시 (RSP+8) % 16 == 0**”가 되도록 컴파일러가 조정한다.

---

## 4. 호출 규약(Calling Convention) — 레지스터 약속

### 4.1 SysV AMD64 (리눅스/유닉스)

- **정수/포인터 인자 (1~6번째)**: `RDI, RSI, RDX, RCX, R8, R9`
- **부동소수 인자 (1~8번째)**: `XMM0..XMM7`
- **추가 인자**: 스택
- **반환값**: 정수/포인터는 `RAX` (필요시 `RDX` 추가), 부동소수는 `XMM0`(필요시 `XMM1` 추가)
- **Caller-saved(Volatile)**: `RAX, RCX, RDX, RSI, RDI, R8, R9, R10, R11`, `XMM0..XMM15`
- **Callee-saved(Non-volatile)**: `RBX, RBP, R12..R15`
- **Red Zone(128B)**: **인터럽트/시그널 제외** 상황에서 프레임 없이 **RSP 아래 128B** 임시 사용 허용(리눅스 전용, Windows에는 없음).
- **가변 인자 함수(printf 등)**: 호출 시 **AL**에 “XMM 레지스터 사용 개수”를 담아 알린다(ABI 규칙).

> **주의**: 작은 구조체/복합 타입의 전달 규칙은 “**분류(Classification)**” 규칙에 따라 **레지스터** 또는 **메모리**로 나뉜다(단순화: **작고 단순한 POD(≤16B)** 는 레지스터로, 크거나 복잡하면 **메모리**).

### 4.2 Windows x64 (요약 대비)
- **정수 인자 (1~4)**: `RCX, RDX, R8, R9` (부동소수는 XMM0..3)
- **Shadow Space**: 호출자는 항상 **스택에 32B(4×8B)** 를 예약.
- **Red Zone 없음**, **XMM6..15** callee-saved 등 **세부 차이**가 존재.
- 실습 시 OS별 규약을 반드시 일치시켜야 한다.

---

## 5. 인자 전달과 지역 변수 — 실제 접근 방식

### 5.1 레지스터 인자 접근
```c
long sum3(long x, long y, long z) {
    return x + y + z;
}
```

```asm
sum3:
    movq %rdi, %rax     # x
    addq %rsi, %rax     # + y
    addq %rdx, %rax     # + z
    ret
```

### 5.2 스택 인자(7번째 이후) 접근
```c
long f(long a,long b,long c,long d,long e,long f,long g) {
    return g - a;
}
```

- `a..f`는 레지스터, **g는 스택**에 있음.
- 접근: **[RBP+offset]**(프레임포인터 사용 시) 또는 **[RSP+offset]**(FP 생략 시 컴파일러가 계산).

### 5.3 지역 변수의 배치와 정렬
- 배열/벡터/구조체는 **정렬(예: 16B)** 을 만족하도록 간격이 삽입될 수 있다(패딩).
- 대형 객체는 **스택에 직접** 놓거나, **힙에 할당**한 포인터만 스택에 둔다.

---

## 6. Caller vs Callee 책임 — 레지스터 보존 규칙

| 구분 | 책임 |
|---|---|
| **Caller** | 호출 전 **caller-saved** 레지스터 보존(필요 시 push), 호출 후 복원. |
| **Callee** | 사용한 **callee-saved** 레지스터를 **prologue에서 저장**, **epilogue에서 복원**. |

예시(피호출자가 RBX, R12 사용):
```asm
foo:
    pushq %rbp
    movq  %rsp,%rbp
    pushq %rbx
    pushq %r12
    subq  $16,%rsp
    ...
    addq  $16,%rsp
    popq  %r12
    popq  %rbx
    leave
    ret
```

---

## 7. 반환값 규칙 — 스칼라·벡터·구조체

- **정수/포인터**: `RAX` (128비트 등 큰 스칼라는 `RDX` 추가).
- **부동소수/벡터**: `XMM0`(필요시 `XMM1`).
- **큰 구조체**: “**숨은 첫 번째 인자**(sret)”로 **호출자가 결과를 저장할 버퍼의 주소**를 넘기고, `RAX`로 그 포인터를 다시 반환하기도 한다(컴파일러/ABI가 자동 처리).

---

## 8. 가변 인자(printf 등) — va_list 내부

```c
#include <stdarg.h>
int sum_n(int n, ...) {
    int s = 0;
    va_list ap;
    va_start(ap, n);
    for (int i=0;i<n;i++) s += va_arg(ap,int);
    va_end(ap);
    return s;
}
```

- SysV에선 호출 시 **AL**로 XMM 인자 사용 개수를 알리고, **va_list**는 **레지스터 영역 오프셋(gp_offset/fp_offset)** 과 **스택 영역 포인터**를 통해 추가 인자를 순차적으로 읽는다.
- 컴파일러가 ABI 규칙을 따르므로, 개발자는 **`va_*` 매크로만 올바로 사용**하면 된다.

---

## 9. 재귀와 스택 — 깊이에 비례한 사용량

```c
unsigned long fact(unsigned long n){
    return (n<=1) ? 1 : n*fact(n-1);
}
```

- 호출 깊이만큼 **프레임이 누적**된다.
- 과도한 깊이는 **스택 오버플로우** 위험 → 반복문 전환, **tail call** 최적화 가능성 고려.

---

## 10. 보안: 리턴 주소와 오버플로우, 카나리·NX·ASLR

### 10.1 리턴 주소 덮어쓰기
```c
void vuln(void){
    char buf[8];
    gets(buf); // 위험: 경계 검사 없음 — 옛 함수(금지)
}
```
- **오버런**이 발생하면 **리턴 주소**까지 덮어 ROP/ret2libc 공격 가능.

### 10.2 방어 기법 개요
- **Stack Canary**: 반환 직전 무결성 검사.
- **NX(DEP)**: 스택 실행 금지.
- **ASLR**: 주소 랜덤화로 가젯 위치 예측 난이도 상승.
- **Fortify/CFI**: 강화된 라이브러리·흐름 무결성.

> 실무에서는 안전한 함수(`fgets`, `snprintf` 등) 사용, **정적/동적 분석** 병행.

---

## 11. 성능·최적화: 인라인·레드존·프레임 생략·정렬

### 11.1 인라인(Inline)
- 작은 함수는 **호출 오버헤드 제거**(분기/레지스터 저장 회피).
- 단, 코드 부풀림(code bloat)과 I-cache 압박 고려.

### 11.2 Red Zone(리눅스)
- **프레임 없이** 임시 128B 사용 가능:
```asm
; leaf 함수, 프레임 미생성
leaf:
    movq $0, -8(%rsp)     ; red zone 활용 (주의: 신호/ISR에 안전하지 않음)
    ret
```

### 11.3 프레임포인터 생략(omit-frame-pointer)
- 최적화 시 `-fomit-frame-pointer`로 **%rbp를 일반 레지스터로 활용** → 레지스터 압박 완화.
- 디버깅·언와인드 필요 환경에선 유지가 유리.

### 11.4 16바이트 정렬
- SSE/AVX 로드/스토어 최적화를 위해 **스택/구조체 정렬** 준수.

---

## 12. 구조체·배열 전달 — 값/참조와 ABI

### 12.1 값으로 전달 vs 포인터로 전달
- 큰 구조체를 **값**으로 넘기면 **복사 비용** 발생.
- 보통 **`const` 포인터**로 넘겨 불필요한 복사를 피한다.

### 12.2 작은 구조체의 레지스터 귀속(요약)
- SysV는 타입 분류 규칙으로 **≤16B POD** 를 **INTEGER/SSE** 로 나눠 **레지스터로 분해 전달** 가능.
- 구현체/플랫폼에 따라 다르므로 **크로스-ABI 코드**에서는 **보수적으로 포인터 사용**이 안전.

---

## 13. 예제 모음 — 호출/프레임/보존/정렬을 한 번에

### 13.1 Callee-saved 레지스터 사용
```c
// rbx, r12를 보존해야 하는 케이스 (합성 예제)
long dot3(long a,long b,long c, const long* p){
    // p[0]*a + p[1]*b + p[2]*c 를 계산
    return p[0]*a + p[1]*b + p[2]*c;
}
```

```asm
dot3:
    pushq %rbp
    movq  %rsp,%rbp
    pushq %rbx
    pushq %r12
    subq  $16,%rsp

    movq  %rcx, %r12       # p → r12 (callee-saved로 보관)
    movq  (%r12), %rbx     # p[0]
    imulq %rdi, %rbx       # p[0]*a

    movq  8(%r12), %rax    # p[1]
    imulq %rsi, %rax       # p[1]*b
    addq  %rax, %rbx

    movq 16(%r12), %rax    # p[2]
    imulq %rdx, %rax       # p[2]*c
    addq  %rbx, %rax       # 누적합 in rax

    addq  $16,%rsp
    popq  %r12
    popq  %rbx
    leave
    ret
```

### 13.2 16B 정렬과 벡터 인자(스칼라 요약)
```c
double axpy(double a, double x, double y) { return a*x + y; }
```

```asm
axpy:
    movapd %xmm0,%xmm2     # a
    mulsd  %xmm1,%xmm2     # a*x
    addsd  %xmm2,%xmm2     # 예시 연산(실제는 addsd xmm2,xmm3 형태)
    ; 실제로는 y가 %xmm2/%xmm3 중 어디에 오는지 ABI가 결정
    addsd  %xmm2,%xmm0     # (a*x) + y → %xmm0
    ret
```
- 부동소수 인자는 **XMM 레지스터**로, 반환도 **XMM0**로.

---

## 14. Tail Call / TCO — 호출을 분기로 바꾼다

- **꼬리 호출**: “현재 함수가 **곧바로** 다른 함수의 반환값을 반환”하는 형태.
- 가능 시, **스택 프레임을 유지한 채** `call` 대신 **`jmp`(tailcall)** 로 대체 가능(ABI·옵션·최적화 여부에 의존).
- 깊은 재귀를 **반복**처럼 실행하여 스택 사용 감소.

---

## 15. 예외/언와인드/디버깅 — 프레임 정보의 역할

- **언와인드 정보(.eh_frame 등)** 로 스택 프레임을 역추적(backtrace).
- **프레임포인터 보존** 시 디버깅이 쉬우나, 최적화와 상충할 수 있다.
- `setjmp/longjmp` 같은 **비지역 점프**는 레지스터/스택 상태를 특별 취급(ABI 규칙에 따름).

---

## 16. 실전 체크리스트 — 이식성·안정성·성능

1. **ABI 일치**: OS/플랫폼에 맞는 **호출 규약**을 코드/ASM/FFI가 모두 준수.
2. **정렬**: 호출 직전 **16B 정렬**(특히 SIMD/변수 인자).
3. **보존 규칙**: callee-saved는 반드시 저장/복원.
4. **프레임 생략 판단**: 디버깅·언와인드 vs 레지스터 압박.
5. **가변 인자**: `va_*` 매크로만 사용(수동 레지스터 접근 금지).
6. **보안**: 안전한 API, 카나리/NX/ASLR 옵션 활성화, 경계검사.
7. **성능**: 잦은 소함수는 **inline**, 큰 구조체는 **포인터 전달**, 벡터는 **정렬**.
8. **Windows 차이**: Shadow space/Red zone 금지 등 **차이점 반영**.

---

## 17. 미니 예제 — 호출자/피호출자 책임의 합연산

C:
```c
// 큰 구조체는 포인터로 전달하여 복사 비용 절감
typedef struct { double x, y, z; } Vec3;

double dot3(const Vec3* a, const Vec3* b) {
    return a->x*b->x + a->y*b->y + a->z*b->z;
}

double axpy3(double a, const Vec3* x, const Vec3* y) {
    // a*x + y 의 내적(y와 x의 스칼라 조합)
    Vec3 t = { a*x->x + y->x, a*x->y + y->y, a*x->z + y->z };
    return t.x + t.y + t.z;
}
```

핵심 포인트:
- **포인터 전달**로 큰 구조체 복사 방지.
- `axpy3`의 임시 `t`는 **스택**에 배치(정렬 보장).
- 컴파일러는 필요하면 부분 인라인/레지스터 재배치를 수행.

---

## 18. 수식으로 정리 — 호출 오버헤드와 인라인 이득(개념식)

호출 오버헤드(대략)
$$
T_\text{call} \approx T_\text{push/pop} + T_\text{branch} + T_\text{icache\_miss?} + T_\text{save/restore}
$$

인라인 후(일부 제거)
$$
T' \approx T_\text{body} + \Delta T_\text{icache} \quad (\text{code size 증가 영향 포함})
$$

작은 함수의 경우 \(T_\text{call}\) 제거 이득이 크고, 큰 함수는 **I-cache 압박**으로 역효과 가능.

---

## 19. 종합 요약(치트시트)

- **call**: 복귀주소 push → 타겟으로 분기. **ret**: 복귀주소 pop → 복귀.
- **스택 프레임**: 저장 `%rbp`/callee-saved, 로컬 확보, 정렬 준수.
- **호출 규약(SysV)**: 정수/포인터 인자 `RDI,RSI,RDX,RCX,R8,R9`, 부동소수 `XMM0..7`; 반환 `RAX`/`XMM0`.
- **보존 규칙**: caller-saved(클러버), callee-saved(보존).
- **가변 인자**: `va_list`/`va_start`/`va_arg`만 사용.
- **보안**: 카나리/NX/ASLR, 안전 API, 경계검사.
- **최적화**: 인라인, 프레임포인터 생략, Red zone(리눅스), 16B 정렬, 포인터로 구조체 전달.
- **이식성**: Windows x64는 Shadow space·Red zone 없음 등 차이 **반드시 확인**.

---

## 20. 부록: 실습용 어셈블리 스켈레톤 (SysV AMD64)

```asm
    .text
    .globl addmul
addmul:                         # long addmul(long a,long b,long c) { return (a+b)*c; }
    pushq %rbp
    movq  %rsp,%rbp
    # 인자: a=RDI, b=RSI, c=RDX
    movq  %rdi,%rax             # rax = a
    addq  %rsi,%rax             # rax = a+b
    imulq %rdx,%rax             # rax = (a+b)*c
    popq  %rbp
    ret
```

```asm
    .text
    .globl callee_saves_demo
callee_saves_demo:
    pushq %rbp
    movq  %rsp,%rbp
    pushq %rbx
    pushq %r12
    subq  $32,%rsp              # 로컬 32B
    # ... 연산 ...
    addq  $32,%rsp
    popq  %r12
    popq  %rbx
    leave
    ret
```

> 실습 팁: `-fno-omit-frame-pointer -O0`로 빌드 후 `objdump -d` 혹은 `gcc -S`로 프레임/호출자·피호출자 동작을 눈으로 확인하라.
