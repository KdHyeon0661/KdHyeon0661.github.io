---
layout: post
title: 영상처리 - 영상의 회전 변환
date: 2025-09-23 23:25:23 +0900
category: 영상처리
---
# 영상의 회전 변환 (Rotation)

## 1) 회전 변환에 관한 이론적 설명

### 1.1 회전 행렬과 동차 좌표
영상의 한 점 \((x,y)\)를 기준점(피벗) \((c_x,c_y)\)을 중심으로 **반시계(CCW)** 각도 \(\theta\)만큼 회전시키는 2D 변환은

\[
\begin{aligned}
\begin{bmatrix}x'\\y'\end{bmatrix}
&=
\begin{bmatrix}
\cos\theta & -\sin\theta\\
\sin\theta &  \cos\theta
\end{bmatrix}
\left(\begin{bmatrix}x\\y\end{bmatrix}
  - \begin{bmatrix}c_x\\c_y\end{bmatrix}\right)
+ \begin{bmatrix}c_x\\c_y\end{bmatrix}.
\end{aligned}
\]

- 디스플레이 좌표계(Top-Down, y가 아래로 증가)에서는 \(\theta>0\)가 **화면상 시계 방향**처럼 보입니다. 본 장에서는 **수학적 정의(CCW)** 를 따릅니다.  
- 실제 구현은 **역방향 매핑**(Backward warping)을 사용합니다. 출력 픽셀 중심 \((x,y)\)에서 원본 좌표 \((x_s,y_s)\)를 찾은 뒤 샘플링하여 채웁니다.

### 1.2 픽셀 센터 정렬
스케일과 마찬가지로 **픽셀 중심 정렬**을 쓰면 오프셋 오류를 줄일 수 있습니다.  
픽셀 중심을 \((x+0.5, y+0.5)\)라 할 때, 피벗 중심도 \((c_x+0.5, c_y+0.5)\)로 해석하여 매핑합니다. (코드에 반영)

### 1.3 캔버스 확장과 바운딩 박스
회전하면 사각 영상의 꼭짓점이 비스듬히 뻗으므로 **잘림**이 발생합니다.  
옵션: **캔버스 확장(Expand canvas)** 으로 회전된 사각형을 모두 담는 출력 크기를 계산합니다.  
4개의 꼭짓점(픽셀 경계 기준)  
\[
(0,0),(W,0),(0,H),(W,H)
\]
을 피벗 \(P=(c_x+0.5, c_y+0.5)\) 기준으로 \(\theta\)만큼 회전 → \((x'_i,y'_i)\).  
\[
\text{newW}=\lceil \max_i x'_i - \min_i x'_i \rceil,\quad
\text{newH}=\lceil \max_i y'_i - \min_i y'_i \rceil.
\]
오프셋 \((o_x,o_y)=(-\min x'_i, -\min y'_i)\) 를 두어 출력 좌표계를 0 이상으로 이동합니다.

### 1.4 보간과 경계
- **보간**: 최근접(빠름), 양선형(자연스러움), 3차 회선(바이큐빅; 선명).  
- **경계(Border)**: Constant(색 채움), Replicate(가장자리 복제), Wrap(타일링).

---

## 2) 임의의 각도 회전 구현

`Rotate.h`에서 **일반 회전**(Nearest/Bilinear/Bicubic)과 **특수 각도 빠른 경로**(90/180/270)를 제공합니다.  
보간 샘플러/Border는 9.2절 `Resize.h`를 재사용합니다.

```cpp
// Rotate.h
#pragma once
#include <cstdint>
#include <cmath>
#include <algorithm>
#include <vector>
#include "IppDib.h"
#include "Resize.h"   // ScaleFilter, BorderMode, sample_* 재사용 (9.2절)

// ---- 파라미터 ----
struct RotateParams {
    float angleDeg = 0.f;      // +: CCW (수학적 정의)
    float pivotX   = -1.f;     // <0면 영상 중심 사용
    float pivotY   = -1.f;
    bool  expandCanvas = true; // true면 바운딩 박스로 캔버스 확장
    ScaleFilter filter  = ScaleFilter::Bicubic;
    BorderMode  border  = BorderMode::Replicate;
    uint8_t fillB=0, fillG=0, fillR=0, fillA=255; // Constant 색
};

// ---- 유틸: clamp ----
inline uint8_t clamp_u8(float v){
    if(v<0) v=0; else if(v>255) v=255; return (uint8_t)std::lround(v);
}

// ---- 코너 회전(픽셀 경계 좌표계: [0..W], [0..H]) ----
inline void rotate_point(float x, float y, float cx, float cy, float c, float s, float& ox, float& oy){
    float dx = x - cx, dy = y - cy;
    ox = cx + c*dx - s*dy;
    oy = cy + s*dx + c*dy;
}

// ---- 특수 각도 감지 ----
inline int NormalizeToRightAngle(float deg, float eps=1e-4f){
    // -180..180로 정규화 후 0/±90/180과 근접하면 해당 코드 반환
    float a = std::fmod(deg, 360.f);
    if (a>180.f) a -= 360.f; else if (a<=-180.f) a += 360.f;
    if (std::fabs(a) < eps) return 0;          // 0°
    if (std::fabs(a-90.f) < eps) return 90;    // +90°
    if (std::fabs(a+90.f) < eps) return -90;   // -90°
    if (std::fabs(std::fabs(a)-180.f) < eps) return 180; // ±180°
    return 9999; // 일반각
}

// ---- 180° 빠른 회전 ----
inline void Rotate180_BGRA32(const IppDib& src, IppDib& dst){
    dst.create(src.width(), src.height(), 32);
    const int W=src.width(), H=src.height();
    for (int y=0;y<H;++y){
        const uint8_t* srow = (const uint8_t*)src.bits() + (size_t)(H-1-y)*src.stride();
        uint8_t*       drow = (uint8_t*)dst.bits() + (size_t)y*dst.stride();
        for (int x=0;x<W;++x){
            const uint8_t* ps=&srow[(W-1-x)*4];
            uint8_t*       pd=&drow[x*4];
            pd[0]=ps[0]; pd[1]=ps[1]; pd[2]=ps[2]; pd[3]=ps[3];
        }
    }
}

// ---- 90°/270° 빠른 회전(Top-Down) ----
// +90°(CCW): 화면상 CW처럼 보일 수 있으나 수학 정의 준수.
// 여기서는 '수학적 +90°(CCW)'를 구현: (x',y') <- ( -y, x ) 패턴을 화면 좌표에 맞게 변환.
// 결과 해상도: newW=H, newH=W
inline void Rotate90CCW_BGRA32(const IppDib& src, IppDib& dst){
    const int W=src.width(), H=src.height();
    dst.create(H, W, 32);
    for (int y=0;y<H;++y){
        const uint8_t* srow=(const uint8_t*)src.bits() + (size_t)y*src.stride();
        for (int x=0;x<W;++x){
            const uint8_t* ps=&srow[x*4];
            // CCW: dst(x',y') = src(x,y) with
            // x' = y, y' = (W-1 - x)
            uint8_t* pd=(uint8_t*)dst.bits() + (size_t)(W-1-x)*dst.stride() + y*4;
            pd[0]=ps[0]; pd[1]=ps[1]; pd[2]=ps[2]; pd[3]=ps[3];
        }
    }
}
inline void Rotate90CW_BGRA32(const IppDib& src, IppDib& dst){
    const int W=src.width(), H=src.height();
    dst.create(H, W, 32);
    for (int y=0;y<H;++y){
        const uint8_t* srow=(const uint8_t*)src.bits() + (size_t)y*src.stride();
        for (int x=0;x<W;++x){
            const uint8_t* ps=&srow[x*4];
            // CW: dst(x',y') = src(x,y) with
            // x' = (H-1 - y), y' = x
            uint8_t* pd=(uint8_t*)dst.bits() + (size_t)x*dst.stride() + (H-1-y)*4;
            pd[0]=ps[0]; pd[1]=ps[1]; pd[2]=ps[2]; pd[3]=ps[3];
        }
    }
}

// ---- 임의 각도 회전 ----
inline void Rotate_BGRA32(const IppDib& src, IppDib& dst, const RotateParams& P, float cubicA=-0.5f)
{
    if (!src) { dst = src; return; }

    // 1) 특수 각도 빠른 경로
    int ra = NormalizeToRightAngle(P.angleDeg);
    if (ra == 0) { dst = src; return; }
    if (ra == 180){ Rotate180_BGRA32(src, dst); return; }
    if (ra == 90) { Rotate90CCW_BGRA32(src, dst); return; }
    if (ra == -90){ Rotate90CW_BGRA32(src, dst); return; }

    // 2) 일반 각도
    const int W=src.width(), H=src.height();
    // 피벗(픽셀 중심 좌표계)
    float cx = (P.pivotX>=0)? P.pivotX : (W-1)*0.5f;
    float cy = (P.pivotY>=0)? P.pivotY : (H-1)*0.5f;
    float c = std::cos(P.angleDeg * (float)M_PI/180.f);
    float s = std::sin(P.angleDeg * (float)M_PI/180.f);

    uint8_t fill[4]={P.fillB,P.fillG,P.fillR,P.fillA};

    int outW=W, outH=H;
    float xoff=0.f, yoff=0.f; // 출력 좌표계 오프셋

    if (P.expandCanvas){
        // 코너(픽셀 경계): (0,0),(W,0),(0,H),(W,H), 피벗은 (cx+0.5, cy+0.5)
        float pcx=cx+0.5f, pcy=cy+0.5f;
        float xs[4], ys[4];
        rotate_point(0.f, 0.f, pcx, pcy, c, s, xs[0], ys[0]);
        rotate_point((float)W, 0.f, pcx, pcy, c, s, xs[1], ys[1]);
        rotate_point(0.f, (float)H, pcx, pcy, c, s, xs[2], ys[2]);
        rotate_point((float)W,(float)H, pcx, pcy, c, s, xs[3], ys[3]);
        float minx = std::min(std::min(xs[0],xs[1]), std::min(xs[2],xs[3]));
        float maxx = std::max(std::max(xs[0],xs[1]), std::max(xs[2],xs[3]));
        float miny = std::min(std::min(ys[0],ys[1]), std::min(ys[2],ys[3]));
        float maxy = std::max(std::max(ys[0],ys[1]), std::max(ys[2],ys[3]));
        outW = (int)std::ceil(maxx - minx);
        outH = (int)std::ceil(maxy - miny);
        xoff = -minx;
        yoff = -miny;
    }

    dst.create(outW, outH, 32);

    // 3) 역방향 샘플링
    for (int y=0;y<outH;++y){
        uint8_t* drow=(uint8_t*)dst.bits()+(size_t)y*dst.stride();
        for (int x=0;x<outW;++x){
            // 픽셀 중심 좌표(연속) p_d = (x+0.5, y+0.5)
            float xd = (float)x + 0.5f;
            float yd = (float)y + 0.5f;

            // expandCanvas면 오프셋을 제거하여 원래 좌표계로 보정
            xd -= xoff;
            yd -= yoff;

            // 목적 좌표를 피벗 기준으로 역회전(-θ) → 원본 좌표
            float pcx=cx+0.5f, pcy=cy+0.5f;
            float dx = xd - pcx;
            float dy = yd - pcy;
            float xs =  c*dx + s*dy + pcx;
            float ys = -s*dx + c*dy + pcy;

            // 보간 샘플
            uint8_t* pd=&drow[x*4];
            switch (P.filter){
            case ScaleFilter::Nearest:
                sample_nearest_BGRA32(src, xs-0.5f, ys-0.5f, P.border, fill, pd); // -0.5: 중심→인덱스 보정
                break;
            case ScaleFilter::Bilinear:
                sample_bilinear_BGRA32(src, xs-0.5f, ys-0.5f, P.border, fill, pd);
                break;
            case ScaleFilter::Bicubic:
            default:
                sample_bicubic_BGRA32(src, xs-0.5f, ys-0.5f, P.border, fill, pd, /*a=*/-0.5f);
                break;
            }
        }
    }
}
```

> 구현 노트  
> - 좌표는 **픽셀 중심** 기준으로 계산하고, 샘플러는 **인덱스 좌표계**를 쓰므로 `xs-0.5, ys-0.5`로 보정합니다.  
> - 특수 각도는 **전치/라인 복사**로 수십 배 빠릅니다.  
> - Bicubic은 4×4=16 샘플/픽셀이므로 **멀티스레딩** 또는 **수평/수직 분리(고급)** 최적화가 유효합니다.

---

## 3) 특수 각도(0/90/180/270°) 회전 구현
위 `Rotate.h`의 `Rotate180_BGRA32`, `Rotate90CCW_BGRA32`, `Rotate90CW_BGRA32`가 해당됩니다.

- **0°**: 복사 없이 포인터만 교체해도 되지만, 여기선 `dst=src`.  
- **180°**: 행·열 역순 복사.  
- **±90°**: 전치 + 반전. 결과 크기: `(newW=newHsrc, newH=newWsrc)`.

> 팁: alpha 채널도 동일하게 복사/전치합니다.

---

## 4) 회전 변환 대화 상자 만들기

### 4.1 리소스 ID

```cpp
// resource.h (추가)
#define IDD_ROTATE_DLG                 1010
#define IDC_EDIT_RT_ANGLE              2301
#define IDC_RAD_RT_NEAREST             2302
#define IDC_RAD_RT_BILINEAR            2303
#define IDC_RAD_RT_BICUBIC             2304
#define IDC_RAD_RT_BORDER_CONST        2305
#define IDC_RAD_RT_BORDER_REPL         2306
#define IDC_RAD_RT_BORDER_WRAP         2307
#define IDC_EDIT_RT_R                  2308
#define IDC_EDIT_RT_G                  2309
#define IDC_EDIT_RT_B                  2310
#define IDC_CHK_RT_EXPAND              2311
#define IDC_CHK_RT_USE_PIVOT           2312
#define IDC_EDIT_RT_PX                 2313
#define IDC_EDIT_RT_PY                 2314

// 메뉴
#define ID_TRANSFORM_ROTATE_DLG        62030
```

### 4.2 RC (대화 상자)

```rc
// ImageTool.rc (추가)
IDD_ROTATE_DLG DIALOGEX 0,0, 280, 178
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Rotate"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Angle (deg, +CCW):", -1, 12, 14, 90, 10
    EDITTEXT IDC_EDIT_RT_ANGLE, 104, 12, 40, 14, ES_AUTOHSCROLL | WS_TABSTOP

    GROUPBOX "Filter", -1, 12, 34, 112, 42
    AUTORADIOBUTTON "Nearest",  IDC_RAD_RT_NEAREST, 20, 48, 60, 10, WS_TABSTOP
    AUTORADIOBUTTON "Bilinear", IDC_RAD_RT_BILINEAR,20, 60, 60, 10
    AUTORADIOBUTTON "Bicubic",  IDC_RAD_RT_BICUBIC, 20, 72, 60, 10

    GROUPBOX "Border", -1, 130, 34, 70, 42
    AUTORADIOBUTTON "Const",    IDC_RAD_RT_BORDER_CONST, 136, 48, 44, 10, WS_TABSTOP
    AUTORADIOBUTTON "Repl",     IDC_RAD_RT_BORDER_REPL,  136, 60, 44, 10
    AUTORADIOBUTTON "Wrap",     IDC_RAD_RT_BORDER_WRAP,  136, 72, 44, 10

    LTEXT "Fill RGB:", -1, 210, 38, 50, 10
    EDITTEXT IDC_EDIT_RT_R, 210, 50, 20, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_RT_G, 234, 50, 20, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_RT_B, 258, 50, 20, 14, ES_NUMBER

    AUTOCHECKBOX "Expand canvas", IDC_CHK_RT_EXPAND, 12, 84, 90, 12, WS_TABSTOP

    AUTOCHECKBOX "Custom pivot", IDC_CHK_RT_USE_PIVOT, 12, 100, 80, 12
    LTEXT "Px:", -1, 100, 100, 14, 10
    EDITTEXT IDC_EDIT_RT_PX, 116, 98, 40, 14, ES_NUMBER
    LTEXT "Py:", -1, 160, 100, 14, 10
    EDITTEXT IDC_EDIT_RT_PY, 176, 98, 40, 14, ES_NUMBER

    DEFPUSHBUTTON "OK", IDOK,  160, 146, 50, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 214, 146, 50, 16
END
```

### 4.3 대화 상자 로직

```cpp
// RotateDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "Rotate.h"

class RotateDlg {
public:
    RotateDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    float ReadFloat(HWND h, int id, float def) const;
    int   ReadInt  (HWND h, int id, int def) const;
    bool  IsChecked(HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }

private:
    HWND   owner_=nullptr;
    IppDib& dib_;
};
```

```cpp
// RotateDlg.cpp
#include "RotateDlg.h"

INT_PTR RotateDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_ROTATE_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK RotateDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(RotateDlg*)l; return self->OnInit(h);
    }
    auto* self=(RotateDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w,l);
    return FALSE;
}
INT_PTR RotateDlg::OnInit(HWND h){
    SetDlgItemTextW(h, IDC_EDIT_RT_ANGLE, L"15.0");
    CheckRadioButton(h, IDC_RAD_RT_NEAREST, IDC_RAD_RT_BICUBIC, IDC_RAD_RT_BICUBIC);
    CheckRadioButton(h, IDC_RAD_RT_BORDER_CONST, IDC_RAD_RT_BORDER_WRAP, IDC_RAD_RT_BORDER_REPL);
    SetDlgItemInt(h, IDC_EDIT_RT_R, 0, FALSE);
    SetDlgItemInt(h, IDC_EDIT_RT_G, 0, FALSE);
    SetDlgItemInt(h, IDC_EDIT_RT_B, 0, FALSE);
    CheckDlgButton(h, IDC_CHK_RT_EXPAND, BST_CHECKED);

    // Custom pivot 기본 Off, 값은 이미지 중심을 안내할 수도 있지만 읽을 때 결정
    CheckDlgButton(h, IDC_CHK_RT_USE_PIVOT, BST_UNCHECKED);
    EnableWindow(GetDlgItem(h, IDC_EDIT_RT_PX), FALSE);
    EnableWindow(GetDlgItem(h, IDC_EDIT_RT_PY), FALSE);

    return TRUE;
}
float RotateDlg::ReadFloat(HWND h, int id, float def) const {
    wchar_t buf[64]; GetDlgItemTextW(h, id, buf, 64);
    wchar_t* e=nullptr; double v=wcstod(buf,&e);
    if (e==buf) return def; return (float)v;
}
int RotateDlg::ReadInt(HWND h, int id, int def) const {
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    if (!ok) return def; return v;
}

INT_PTR RotateDlg::OnCommand(HWND h, WPARAM w, LPARAM){
    switch (LOWORD(w)){
    case IDC_CHK_RT_USE_PIVOT: {
        BOOL on = (IsDlgButtonChecked(h, IDC_CHK_RT_USE_PIVOT)==BST_CHECKED);
        EnableWindow(GetDlgItem(h, IDC_EDIT_RT_PX), on);
        EnableWindow(GetDlgItem(h, IDC_EDIT_RT_PY), on);
        return TRUE;
    }
    case IDOK: {
        RotateParams P;
        P.angleDeg = ReadFloat(h, IDC_EDIT_RT_ANGLE, 0.f);
        P.expandCanvas = (IsDlgButtonChecked(h, IDC_CHK_RT_EXPAND)==BST_CHECKED);

        if (IsDlgButtonChecked(h, IDC_RAD_RT_NEAREST)==BST_CHECKED) P.filter=ScaleFilter::Nearest;
        else if (IsDlgButtonChecked(h, IDC_RAD_RT_BILINEAR)==BST_CHECKED) P.filter=ScaleFilter::Bilinear;
        else P.filter=ScaleFilter::Bicubic;

        if (IsDlgButtonChecked(h, IDC_RAD_RT_BORDER_REPL)==BST_CHECKED) P.border=BorderMode::Replicate;
        else if (IsDlgButtonChecked(h, IDC_RAD_RT_BORDER_WRAP)==BST_CHECKED) P.border=BorderMode::Wrap;
        else P.border=BorderMode::Constant;

        P.fillR=(uint8_t)ReadInt(h, IDC_EDIT_RT_R, 0);
        P.fillG=(uint8_t)ReadInt(h, IDC_EDIT_RT_G, 0);
        P.fillB=(uint8_t)ReadInt(h, IDC_EDIT_RT_B, 0);
        P.fillA=255;

        if (IsDlgButtonChecked(h, IDC_CHK_RT_USE_PIVOT)==BST_CHECKED){
            // 사용자가 지정 (픽셀 인덱스 좌표)
            P.pivotX = (float)ReadInt(h, IDC_EDIT_RT_PX, (dib_.width()-1)/2);
            P.pivotY = (float)ReadInt(h, IDC_EDIT_RT_PY, (dib_.height()-1)/2);
        } else {
            P.pivotX = -1.f; P.pivotY=-1.f; // 중심 자동
        }

        IppDib out; Rotate_BGRA32(dib_, out, P, -0.5f);
        dib_ = out;
        EndDialog(h, IDOK);
        return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

---

## 5) 회전 변환 메뉴 만들기 (연동)

```cpp
// ImageTool.rc (일부)
POPUP "&Transform"
BEGIN
    MENUITEM "Rotate...\tCtrl+E", ID_TRANSFORM_ROTATE_DLG
END

// 가속키
IDR_ACCEL ACCELERATORS
BEGIN
    "E", ID_TRANSFORM_ROTATE_DLG, VIRTKEY, CONTROL
END
```

```cpp
// main_multiwin.cpp (발췌)
#include "RotateDlg.h"

// ...
case ID_TRANSFORM_ROTATE_DLG:
    if (st && st->dib) {
        RotateDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK) {
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st);
            UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 6) 실전 예제 & 상황

### 예제 A) 사진 기울기 보정 (수평선 맞추기)
- **상황**: 바다 사진이 약간 기울어져 수평선이 삐뚤어짐.  
- **동작**: `Transform → Rotate…` → Angle **-1.8°** (CCW 기준; 화면상 오른쪽으로 약간 회전)  
  필터 **Bicubic**, Border **Replicate**, **Expand canvas ON**.  
- **결과**: 수평선이 반듯. 가장자리 빈 영역은 Replicate로 자연스럽게 보완되며, 필요시 **Crop**으로 마무리.

### 예제 B) 아이콘 90° 돌리기(초고속 경로)
- **상황**: 64×128 UI 자산을 90° CW로 회전.  
- **동작**: Angle **-90°** 입력 → 특수 경로 `Rotate90CW_BGRA32` 자동 사용.  
- **결과**: 즉시 회전, 품질 손실 無, 해상도는 **128×64**로 교체.

### 예제 C) 원근 합성용 피벗 회전
- **상황**: 스티커(로고)를 왼쪽 위 모서리를 축으로 회전해 벽에 붙인 느낌 연출.  
- **동작**: `Custom pivot` 체크 → Px=0, Py=0 (왼상단), Angle **+25°**, Border **Constant(255,255,255)**, Expand **ON**.  
- **결과**: 로고가 왼상단을 축으로 회전하며 흰 배경의 새 캔버스 위에 배치.

### 예제 D) 텍스처 타일 테스트(45°)
- **상황**: 타일 가능한 무늬를 45°로 회전시 Seam 검사.  
- **동작**: Angle **+45°**, Border **Wrap**, Filter **Bilinear**, Expand **ON**.  
- **결과**: 회전 후에도 Wrap으로 경계가 자연스럽게 연결되는지 확인 용이.

---

## 7) 정확성/성능/UX 팁

- **정확성**
  - **픽셀 중심 정렬**과 **역방향 보간**으로 홀 없이 안정적.  
  - Bicubic은 선명하지만 **링잉**이 생길 수 있어, 텍스트/선화엔 Bilinear가 더 자연스러울 때도 있습니다.

- **성능**
  - ±90/180°는 **전치/반전**으로 극히 빠름.  
  - 일반 각도: 멀티스레딩(행 블록), 캐시 친화 타일링, 고정 소수점 `cos/sin` 사용으로 최적화.  
  - Bicubic은 16 샘플/픽셀 → **Bilinear** 대비 약 3~4배 느릴 수 있음.

- **UX**
  - **Expand canvas** 기본 ON 권장(잘림 방지). 후처리로 Crop/패딩 처리.  
  - `Custom pivot`으로 **도형/로고 회전**을 정밀 제어.  
  - Border=Wrap은 **타일 텍스처** 전용. 자연 사진엔 Replicate가 무난.

- **알파**
  - 본 코드는 A도 동일 보간. 프리멀티플라이를 쓰는 파이프라인이라면 **선형 공간**에서 색곱 후 보간하도록 설계(고급).

---

## 8) 수학 메모

- 역방향 매핑(출력→입력)으로 각 출력 픽셀을 정확히 채움:  
\[
\begin{bmatrix}x_s\\y_s\end{bmatrix} =
R(-\theta)\left(\begin{bmatrix}x_d+0.5\\y_d+0.5\end{bmatrix}
-\begin{bmatrix}o_x\\o_y\end{bmatrix}
-\begin{bmatrix}c_x+0.5\\c_y+0.5\end{bmatrix}\right)
+ \begin{bmatrix}c_x+0.5\\c_y+0.5\end{bmatrix}.
\]
- 바운딩 박스는 4코너 회전 후 **min/max**로 계산. 픽셀 경계 좌표계를 쓰면 off-by-1 이슈를 줄일 수 있습니다.

---

## 9) 요약
- 회전은 **피벗 기준 회전 행렬**과 **역방향 보간**으로 구현.  
- **Nearest/Bilinear/Bicubic** 지원, **Constant/Replicate/Wrap** 경계 처리.  
- **±90/180°** 는 전치·반전으로 **초고속** 처리.  
- **Expand canvas**/Custom Pivot/Border/Filter를 **Rotate 대화 상자**에서 제어.  
- 사진 보정·아이콘 회전·합성·타일 테스트 등 **실전 시나리오**에서 즉시 활용 가능.