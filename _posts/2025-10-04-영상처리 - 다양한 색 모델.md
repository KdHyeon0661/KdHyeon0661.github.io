---
layout: post
title: 영상처리 - 다양한 색 모델
date: 2025-10-04 14:25:23 +0900
category: 영상처리
---
# 다양한 색 모델

## 색상 표현 방법(개념 정리)

### 색 모델 vs 색 공간

- **색 모델(Color Model)**: 색을 수치화하는 좌표계(예: RGB, HSI, YUV).
- **색 공간(Color Space)**: 구체적 정의(원점·기저·감마·화이트포인트 포함)된 모델(예: **sRGB**, AdobeRGB, BT.601 Y’CbCr).
  - 같은 RGB라도 **sRGB**(감마 포함)와 **linear RGB**(감마 제거)는 다름.

### 가산/감산 혼합

- **가산(Additive)**: 빛의 합(디스플레이) → **RGB**.
- **감산(Subtractive)**: 잉크의 흡수(인쇄) → CMY/CMYK.

### 감마와 밝기

- sRGB는 **비선형(감마 약 2.2)**. 대부분의 픽셀 연산(샤프닝, 블러, 합성)은 **선형 공간**에서 더 물리적이나,
  실무에서는 간소화를 위해 sRGB 공간에서 HSI/HSV/YUV를 다루기도 함. 본 장은 **실무 표준 근사**에 맞춰 sRGB값을 직접 변환합니다(필요시 “고급: 선형화/재감마” 메모 제공).

---

## RGB 색 모델

### 정의

픽셀을 **세 채널**로 표현: \(R,G,B \in [0,255]\) 또는 정규화 \(R,G,B \in [0,1]\).
디스플레이는 RGB 가산 혼합으로 색을 만든다.

### 장점/단점

- 장점: 하드웨어 친화, 간단, 광범위한 지원.
- 단점: **밝기/색상 분리 어려움**, 채널별 연산이 지각적으로 비일관.

### 실전 팁

- 밝기 조절은 단순 `R,G,B` 스케일보다 **루마(Y)** 기반이 더 지각적.
- 색상 보정·톤 조절은 **HSI/HSV** 또는 **YUV/YCbCr**로 전환 후 작업이 편리.

---

## HSI 색 모델 (Hue–Saturation–Intensity)

> **목표**: 사람 지각에 가까운 축(색상·채도·광도)으로 분해하여,
> 색조·채도·밝기를 **독립적으로** 수정하기 쉽게 하자.

### 정의(정규화 RGB에서 계산)

정규화 \(r,g,b \in [0,1]\) 로 두고,
- **Intensity** \(I = \frac{r+g+b}{3}\)
- **Saturation** \(S = 1 - \frac{3\min(r,g,b)}{r+g+b+\varepsilon}\)  (분모 0 방지 \(\varepsilon\!\approx\!10^{-6}\))
- **Hue** (라디안, \(0\)~\(2\pi\))
  \[
  \theta = \operatorname{atan2}\!\Big(\sqrt{3}\,(g-b),\ 2r-g-b\Big),\quad
  H=\begin{cases}\theta&\theta\ge 0\\ \theta+2\pi & \theta<0\end{cases}
  \]
  디그리(°)로 쓰려면 \(H^\circ = H\cdot \frac{180}{\pi}\).

### 역변환(HSI → RGB)

영역을 3섹터로 나눔(각도 단위는 **deg**):
- \(0^\circ \le H < 120^\circ\):
  \[
  b = I(1-S),\quad r = I\Big(1+\frac{S\cos H}{\cos(60^\circ-H)}\Big),\quad g = 3I-(r+b)
  \]
- \(120^\circ \le H < 240^\circ\) 에서 \(H' = H-120^\circ\):
  \[
  r = I(1-S),\quad g = I\Big(1+\frac{S\cos H'}{\cos(60^\circ-H')}\Big),\quad b = 3I-(r+g)
  \]
- \(240^\circ \le H < 360^\circ\) 에서 \(H'' = H-240^\circ\):
  \[
  g = I(1-S),\quad b = I\Big(1+\frac{S\cos H''}{\cos(60^\circ-H'')}\Big),\quad r = 3I-(g+b)
  \]
수치 안정성을 위해 \(\cos(\cdot)\) 분모가 0에 가까우면 \(\varepsilon\) 처리.

> 참고: HSI는 고전적 정의로, 오늘날은 **HSV/HSL**이 더 흔합니다. 다만 HSI의 **Intensity**는 세 채널 평균이라 “조명” 느낌을 주는 데 직관적입니다.

---

## 색 모델

> **목표**: **밝기(Y’)**와 **색차(Cb/Cr)** 를 분리해 **밝기만** 조절하거나,
> 크로마를 **서브샘플링(4:2:0)** 하여 압축 효율을 높이기 위함. 방송/코덱 표준에서 널리 사용.

### 디지털 영상에서의 Y’CbCr(Full Range, JPEG)

정수 8비트 풀레인지(0..255) 근사:
\[
\begin{aligned}
Y'  &= 0.299R + 0.587G + 0.114B \\
Cb &= 128 + (-0.168736R - 0.331264G + 0.5B) \\
Cr &= 128 + ( 0.5R - 0.418688G - 0.081312B)
\end{aligned}
\]
역변환:
\[
\begin{aligned}
R &= Y' + 1.402(Cr-128)\\
G &= Y' - 0.344136(Cb-128) - 0.714136(Cr-128)\\
B &= Y' + 1.772(Cb-128)
\end{aligned}
\]

> 주의: 방송(BT.601/709)에서는 **리미티드 레인지**(Y’∈[16,235], CbCr∈[16,240])가 흔합니다. 여기선 **풀레인지**를 기본으로 합니다(간단·일반적).

---

## 데이터 구조 & 유틸(본 장에서 추가)

```cpp
// ColorModels.hpp
#pragma once
#include <cstdint>
#include <cmath>
#include "IppImage.h"
#include "RGB24.h"

// ===== 색 모델 구조체 =====
struct HSI32f {
    float h; // degrees [0,360)
    float s; // [0,1]
    float i; // [0,1]
};

struct YCbCr8 {
    uint8_t y, cb, cr; // Full-range 0..255, Cb/Cr 중심 128
};

// ===== 공통 유틸 =====
inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }
inline float clamp01(float v){ return (v<0.f)?0.f:((v>1.f)?1.f:v); }
inline float rad2deg(float r){ return r * 180.0f / (float)M_PI; }
inline float deg2rad(float d){ return d * (float)M_PI / 180.0f; }
```

---

## **RGB ↔ HSI** 변환 구현

```cpp
// RGB_HSI.hpp
#pragma once
#include "ColorModels.hpp"

// 안전 acos/atan2 보조
static inline float safe_div(float n, float d, float eps=1e-6f){
    return (std::fabs(d)<eps)? (n>=0? 1e6f : -1e6f) : (n/d);
}

inline void RGB24_to_HSI(const IppImage<RGB24>& src, IppImage<HSI32f>& dst){
    dst.create(src.width(), src.height());
    for (int y=0; y<src.height(); ++y){
        const RGB24* s = src.row(y);
        HSI32f* d = dst.row(y);
        for (int x=0; x<src.width(); ++x){
            float r = s[x].r / 255.f;
            float g = s[x].g / 255.f;
            float b = s[x].b / 255.f;

            float I = (r+g+b)/3.f;
            float minc = std::fmin(r, std::fmin(g,b));
            float S = (I>1e-6f)? (1.f - (minc / I)) : 0.f;

            // Hue via atan2(sqrt(3)*(g-b), 2r - g - b)
            float num = std::sqrt(3.f) * (g - b);
            float den = 2.f*r - g - b;
            float H = std::atan2(num, den); // [-π, π]
            if (H < 0) H += 2.f*(float)M_PI;
            float Hdeg = rad2deg(H); // [0,360)

            d[x] = { Hdeg, clamp01(S), clamp01(I) };
        }
    }
}

inline void HSI_to_RGB24(const IppImage<HSI32f>& src, IppImage<RGB24>& dst){
    dst.create(src.width(), src.height());
    for (int y=0; y<src.height(); ++y){
        const HSI32f* s = src.row(y);
        RGB24* d = dst.row(y);
        for (int x=0; x<src.width(); ++x){
            float H = s[x].h; while (H<0) H+=360.f; while (H>=360.f) H-=360.f;
            float S = clamp01(s[x].s);
            float I = clamp01(s[x].i);

            float r=0,g=0,b=0;
            // 3 섹터 분기
            if (H < 120.f){
                float Hr = deg2rad(H);
                float denom = std::cos(deg2rad(60.f) - Hr);
                float tmp = (denom!=0.f)? (S*std::cos(Hr)/denom) : 0.f;
                b = I*(1.f - S);
                r = I*(1.f + tmp);
                g = 3.f*I - (r + b);
            } else if (H < 240.f){
                float H2 = deg2rad(H - 120.f);
                float denom = std::cos(deg2rad(60.f) - H2);
                float tmp = (denom!=0.f)? (S*std::cos(H2)/denom) : 0.f;
                r = I*(1.f - S);
                g = I*(1.f + tmp);
                b = 3.f*I - (r + g);
            } else {
                float H3 = deg2rad(H - 240.f);
                float denom = std::cos(deg2rad(60.f) - H3);
                float tmp = (denom!=0.f)? (S*std::cos(H3)/denom) : 0.f;
                g = I*(1.f - S);
                b = I*(1.f + tmp);
                r = 3.f*I - (g + b);
            }

            int R = (int)std::lround(clamp01(r)*255.f);
            int G = (int)std::lround(clamp01(g)*255.f);
            int B = (int)std::lround(clamp01(b)*255.f);
            d[x] = RGB24((uint8_t)R,(uint8_t)G,(uint8_t)B);
        }
    }
}

// ===== HSI 편의 연산 =====

// Hue 회전(도), S/I 스케일링
inline void HSI_adjust(IppImage<HSI32f>& img, float hue_deg, float s_scale, float i_scale){
    for (int y=0; y<img.height(); ++y){
        HSI32f* p = img.row(y);
        for (int x=0; x<img.width(); ++x){
            float H = p[x].h + hue_deg;
            while (H<0) H+=360.f; while (H>=360.f) H-=360.f;
            p[x].h = H;
            p[x].s = clamp01(p[x].s * s_scale);
            p[x].i = clamp01(p[x].i * i_scale);
        }
    }
}
```

> 정확성 메모
> - HSI는 **sRGB(감마 포함)** 에서 계산해도 사용 측면으론 충분히 쓸만합니다.
> - 과학적 밝기 일관성이 중요한 경우: **선형화** 후 HSI(HSL/HSV)와 유사 개념으로 작업하세요(고급편).

---

## **RGB ↔ YCbCr** 변환 구현 (Full-range)

```cpp
// RGB_YCbCr.hpp
#pragma once
#include "ColorModels.hpp"

inline void RGB24_to_YCbCr(const IppImage<RGB24>& src, IppImage<YCbCr8>& dst){
    dst.create(src.width(), src.height());
    for (int y=0; y<src.height(); ++y){
        const RGB24* s = src.row(y);
        YCbCr8* d = dst.row(y);
        for (int x=0; x<src.width(); ++x){
            int R=s[x].r, G=s[x].g, B=s[x].b;
            int Y  = (  299*R + 587*G + 114*B + 500) / 1000;
            int Cb = 128 + ((-168736*R - 331264*G + 500000*B + 500000)/1000000);
            int Cr = 128 + (( 500000*R - 418688*G -  81312*B + 500000)/1000000);
            d[x].y  = clamp_u8(Y);
            d[x].cb = clamp_u8(Cb);
            d[x].cr = clamp_u8(Cr);
        }
    }
}

inline void YCbCr_to_RGB24(const IppImage<YCbCr8>& src, IppImage<RGB24>& dst){
    dst.create(src.width(), src.height());
    for (int y=0; y<src.height(); ++y){
        const YCbCr8* s = src.row(y);
        RGB24* d = dst.row(y);
        for (int x=0; x<src.width(); ++x){
            int Y=s[x].y, Cb=s[x].cb-128, Cr=s[x].cr-128;
            int R = (int)std::lround(Y + 1.402 * Cr);
            int G = (int)std::lround(Y - 0.344136 * Cb - 0.714136 * Cr);
            int B = (int)std::lround(Y + 1.772 * Cb);
            d[x].r = clamp_u8(R);
            d[x].g = clamp_u8(G);
            d[x].b = clamp_u8(B);
        }
    }
}

// ===== Y’만 조절(밝기/명암비), Cb/Cr 유지 =====
inline void Y_adjust(IppImage<YCbCr8>& yuv, float gain, float bias){
    // gain: 곱(명암비), bias: 더하기(밝기), 둘 다 Y'에만 적용
    for (int y=0; y@yuv.height(); ++y){
        YCbCr8* p = yuv.row(y);
        for (int x=0; x@yuv.width(); ++x){
            int Y = (int)std::lround(p[x].y * gain + bias);
            p[x].y = clamp_u8(Y);
        }
    }
}
```

> 팁
> - “기울기/라이트” 조정은 Y’에서 처리하면 **색조 변형이 덜**합니다.
> - 스킨톤 보호 같이 섬세한 작업은 **Cb/Cr 범위 마스크**와 결합하면 좋습니다.

---

## `IppDib` ↔ `IppImage` 간 연결(요약)

```cpp
// DibImageConvert.hpp (앞 절 요약 재사용)
inline void DibToImageRGB24(const IppDib& dib, IppImage<RGB24>& img);
inline void ImageRGB24ToDib(const IppImage<RGB24>& img, IppDib& dib);
```

---

## **실전 예제 시나리오**

### **색조(Hue) 회전·채도(S) 증폭 후 되돌리기**

- **상황**: 풍경 사진의 전체 색조를 약간 따뜻하게(+15°), 채도를 1.2배로 높이고 싶음.
- **절차**:
```cpp
// 1) DIB → RGB24 → HSI
IppImage<RGB24> rgb; DibToImageRGB24(st->dib, rgb);
IppImage<HSI32f> hsi; RGB24_to_HSI(rgb, hsi);

// 2) H,S,I 조정 (Hue +15°, Saturation ×1.2, Intensity ×1.0)
HSI_adjust(hsi, /*hue_deg=*/15.f, /*s_scale=*/1.2f, /*i_scale=*/1.0f);

// 3) HSI → RGB24 → DIB
IppImage<RGB24> rgb2; HSI_to_RGB24(hsi, rgb2);
ImageRGB24ToDib(rgb2, st->dib);
InvalidateRect(hWnd, nullptr, FALSE);
```
- **결과**: 전체적으로 **따뜻한 색조**로 치우치며, 과포화 없이 **선명함**이 증가.

---

### **조명만 밝게(색상 유지)** — Y’만 보정

- **상황**: 색감은 좋지만 사진이 전체적으로 어두움.
- **절차**:
```cpp
// DIB → RGB24 → YCbCr
IppImage<RGB24> rgb; DibToImageRGB24(st->dib, rgb);
IppImage<YCbCr8> yuv; RGB24_to_YCbCr(rgb, yuv);

// Y’만 감마 비슷하게 보정(간단: gain,bias)
Y_adjust(yuv, /*gain=*/1.12f, /*bias=*/8.0f); // 살짝 밝히고 대비 상승

// YCbCr → RGB24 → DIB
IppImage<RGB24> out; YCbCr_to_RGB24(yuv, out);
ImageRGB24ToDib(out, st->dib);
InvalidateRect(hWnd, nullptr, FALSE);
```
- **결과**: 채도·색조는 유지되면서 **밝기/대비**만 개선.

---

### **특정 Hue 범위만 채도 감쇄(피부 톤 보호)**

- **상황**: 전반적으로 채도를 올렸더니 피부가 과포화됨 → 피부 Hue 범위(예: 10°~40°)만 S를 낮춤.
```cpp
IppImage<RGB24> rgb; DibToImageRGB24(st->dib, rgb);
IppImage<HSI32f> hsi; RGB24_to_HSI(rgb, hsi);

// 전체 S ×1.15, 단 피부 톤(10°~40°)은 S ×0.85 보정
for (int y=0; y<hsi.height(); ++y){
    HSI32f* p = hsi.row(y);
    for (int x=0; x<hsi.width(); ++x){
        float H = p[x].h;
        p[x].s = clamp01(p[x].s * 1.15f);
        if (H>=10.f && H<=40.f)
            p[x].s = clamp01(p[x].s * 0.85f);
    }
}
IppImage<RGB24> out; HSI_to_RGB24(hsi, out);
ImageRGB24ToDib(out, st->dib);
```
- **결과**: 배경/의상은 선명, 피부는 자연스러움 유지.

---

### **YCbCr에서 색감 따뜻하게(크로마 오프셋)**

- **상황**: 겨울 실내 사진이 푸른 느낌 → Cr을 조금 올려 따뜻하게.
```cpp
IppImage<RGB24> rgb; DibToImageRGB24(st->dib, rgb);
IppImage<YCbCr8> yuv; RGB24_to_YCbCr(rgb, yuv);

// Cr + 6, Cb - 2 (미세 조정)
for (int y=0; y<yuv.height(); ++y){
    YCbCr8* p = yuv.row(y);
    for (int x=0; x<yuv.width(); ++x){
        p[x].cr = clamp_u8((int)p[x].cr + 6);
        p[x].cb = clamp_u8((int)p[x].cb - 2);
    }
}
IppImage<RGB24> out; YCbCr_to_RGB24(yuv, out);
ImageRGB24ToDib(out, st->dib);
```
- **결과**: 전체적으로 **따뜻한 톤**(skin-friendly) 연출.

---

## 정확성/성능/안정성 팁

- **감마**: 물리적 정확도를 따지면 RGB를 **선형화**(sRGB EOTF 역함수) 후 Y 계산/혼합 → 결과를 **재감마**.
  - 간단한 사진 편집은 sRGB 공간에서 직접 처리해도 충분히 실용적.
- **HSI 수치 안정성**: \(S\rightarrow 1\), \(H\approx 60^\circ,180^\circ,300^\circ\) 근방에서 분모가 작아짐 → \(\varepsilon\)로 보호.
- **YCbCr 범위**: 본 코드는 **풀레인지**. 코덱/방송과 연결 시 리미티드 레인지 변환을 고려.
- **성능**:
  - 메모리 연속 접근(행 우선) 유지.
  - 큰 영상은 **멀티스레딩**(행 블록)과 **SIMD**(특히 YCbCr)가 매우 효과적.
- **색상 클리핑**: 역변환 후 R,G,B를 반드시 **0..255 클램프**.

---

## 단위 테스트 스니펫

```cpp
// test_color_models.cpp
#include <cassert>
#include "DibImageConvert.hpp"
#include "RGB_HSI.hpp"
#include "RGB_YCbCr.hpp"

int main(){
    // 2x1: 빨강(255,0,0), 청록(0,255,255)
    IppImage<RGB24> rgb(2,1);
    rgb.at(0,0) = RGB24(255,0,0);
    rgb.at(0,1) = RGB24(0,255,255);

    // RGB->HSI->RGB 왕복 정확성(대략)
    IppImage<HSI32f> hsi; RGB24_to_HSI(rgb, hsi);
    IppImage<RGB24> rgb2; HSI_to_RGB24(hsi, rgb2);
    assert(std::abs((int)rgb2.at(0,0).r - 255) < 2);
    assert(rgb2.at(0,0).g < 2 && rgb2.at(0,0).b < 2);

    // RGB->YCbCr->RGB 왕복
    IppImage<YCbCr8> yuv; RGB24_to_YCbCr(rgb, yuv);
    IppImage<RGB24> rgb3; YCbCr_to_RGB24(yuv, rgb3);
    assert(std::abs((int)rgb3.at(0,0).r - 255) < 2);

    // HSI 조정: Hue+180 → 보색 근처
    HSI_adjust(hsi, 180.f, 1.f, 1.f);
    HSI_to_RGB24(hsi, rgb2);
    // 빨강(255,0,0) → 시안(0,≈255,≈255)
    assert(rgb2.at(0,0).r < 8);
    return 0;
}
```

---

## 메뉴 아이디어

본 절의 핵심은 **변환/조정 함수**지만, 사용 편의를 위해 메뉴를 간단히 제안합니다.

- **Color → Hue/Saturation (HSI)…** : Hue(°), Saturation(×), Intensity(×) 슬라이더
- **Color → Warm up (YCbCr)** : Cr+δ, Cb−δ 프리셋
- **Color → Luma Contrast (Y’)…** : Y’의 gain/bias

핸들러에서는 `DIB→RGB24→(모델로 변환→조정→RGB24)→DIB` 파이프라인을 그대로 호출하면 됩니다.

---

## 요약

- **RGB**: 디스플레이·하드웨어 친화. 직접 편집은 간단하지만 지각적 의미는 약함.
- **HSI**: **색상·채도·광도**로 나누어, Hue/Saturation/Intensity를 독립적으로 제어하기 좋음.
- **YUV(=YCbCr)**: **밝기-색차** 분리. 밝기만 조절·압축(4:2:0)·색 보정에 유리.
