---
layout: post
title: 웹해킹 - 정적 분석 룰
date: 2025-10-15 16:25:23 +0900
category: 웹해킹
---
# 30. 정적 분석 룰(Semgrep 등) — **웹 특화 가이드**
**— “찾기” 핫스팟( `eval/new Function`, 동적 `require`, 템플릿 표현식, 위험 헤더, `sendFile(req.query...)` …) · 언어/프레임워크별 룰 예시(JS/TS, Node/Express, Python/Django, Java/Spring, Go) · PR 게이트(경고=Fail) 운영 · 예외(만료일 의무화) · 자동수정(autofix) · CI/CD 통합( GitHub Actions )**

> 목표  
> 린트/테스트는 **스타일/기능**을, **정적 분석**은 **보안 결함/취약 패턴**을 잡습니다. 여기서는 **웹 앱**에 흔한 취약 패턴을 **Semgrep** 중심으로 “룰+예시 코드+수정 가이드+CI 운용”까지 **복붙 가능한 수준**으로 정리합니다.

---

## 0. 한눈에 보기 (핵심만)
- **탐지 대상(웹 특화)**  
  - **동적 실행**: `eval`, `new Function`, 동적 `require/import`, `child_process.exec` 등  
  - **템플릿 인젝션/XSS**: EJS/Handlebars “미이스케이프( triple mustache )”, `res.send(req.query...)`  
  - **경로/파일**: `sendFile(req.query.path)`, `fs.readFile(req.query…)`, `path.join(base, user)`  
  - **네트워크 싱크**: SSRF류 `axios(fetch)(req.query.url)`  
  - **헤더/CORS**: `Access-Control-Allow-Origin: *` + `credentials:true`, CRLF 헤더 인젝션  
  - **보안 옵션 미설정/약화**: CSP 미설정, `helmet` 비활성, `cookie httpOnly=false` 등
- **운영**  
  - **PR 게이트**: `semgrep ci` 결과 **경고=Fail**(severity 기준), **예외는 만료일 필수**  
  - **Autofix**로 치유 가능한 건 자동 수정, 나머지만 리뷰  
  - **Baseline**(기존 이슈)와 **새 이슈 구분**해 점진 도입

---

## 1. 세팅(빠르게)
```bash
# 1. 설치
pipx install semgrep           # 또는 pip install semgrep
# 2. 레지스트리 룰도 가져오기(선택)
semgrep login                  # semgrep App 쓴다면
# 3. 로컬 스캔
semgrep --config p/owasp-top-ten --config p/javascript
# 4. 프로젝트 전용 룰 실행
semgrep --config .semgrep/web.yml
```

`.semgrep/` 아래에 언어별 룰을 모읍니다:
```
.semgrep/
  web.yml            # 공통 웹 룰(아래 제공)
  js.yml             # JS/TS 추가 룰
  python.yml         # Django/Flask
  java.yml           # Spring
  go.yml             # net/http, echo, gin 등
```

---

## 2. **핵심 룰 모음(web.yml)** — “찾기” 요구사항 반영  
> 아래는 **Node/Express** 중심으로, **언어 확장** 가능한 형태입니다.

{% raw %}
```yaml
# .semgrep/web.yml
rules:
  # 2.1 동적 실행: eval / new Function
  - id: js-danger-eval
    message: "Avoid dynamic code execution (eval/new Function). Use safe alternatives."
    languages: [javascript, typescript]
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: eval($X)
          - pattern: new Function($ARGS)
    fix-regex:
      regex: 'eval\((.*)\)'
      replacement: 'JSON.parse(\1) /* TODO: replace with safe parser */'

  # 2.2 동적 require/import
  - id: node-dynamic-require
    message: "Dynamic require/import with user input can lead to RCE or path traversal."
    languages: [javascript, typescript]
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: require($X)
          - pattern: import($X)
    metavariable-pattern:
      metavariable: $X
      pattern-not: "'@org/package'"
    # 리뷰유도: 고정 상수/화이트리스트만 허용

  # 2.3 템플릿 인젝션(Handlebars/EJS 미이스케이프)
  - id: tpl-unsafe-triple-mustache
    message: "Unescaped template injection (Handlebars triple-mustache) → XSS."
    languages: [generic]
    severity: ERROR
    pattern-regex: '{{{[^}]+}}}'

  - id: ejs-unescaped-output
    message: "EJS unescaped output (<%- %>) → XSS. Prefer <%= %>."
    languages: [generic]
    severity: ERROR
    pattern-regex: '<%-\s*[^%]+%>'

  # 2.4 Express XSS: res.send(req.query/params/body/headers)
  - id: express-direct-send
    message: "Sending raw user input can cause XSS. Sanitize or escape before send."
    languages: [javascript, typescript]
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: res.send(req.query.$X)
          - pattern: res.send(req.params.$X)
          - pattern: res.send(req.body.$X)
          - pattern: res.end(req.query.$X)
          - pattern: res.write(req.query.$X)

  # 2.5 파일 경로: res.sendFile/ fs.* with user input
  - id: express-sendfile-userinput
    message: "User-controlled path in sendFile / fs call → Path Traversal."
    languages: [javascript, typescript]
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: res.sendFile(req.$OBJ.$FIELD)
          - pattern: fs.readFile(req.$OBJ.$FIELD, ...)
          - pattern: fs.createReadStream(req.$OBJ.$FIELD, ...)
    metadata:
      owasp: "A01-Broken Access Control / A05-Security Misconfiguration"

  # 2.6 SSRF: axios/fetch에 사용자 URL
  - id: ssrf-user-url
    message: "Potential SSRF: HTTP client called with user-controlled URL. Whitelist hosts."
    languages: [javascript, typescript]
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: axios($U)
          - pattern: fetch($U)
          - pattern: http.get($U)
          - pattern: https.get($U)
    metavariable-regex:
      metavariable: $U
      regex: '(req\.query|req\.body|req\.params|process\.env\.)'

  # 2.7 헤더 인젝션(CRLF)
  - id: header-crlf
    message: "Header injection via CRLF. Strip \\r or \\n from header values."
    languages: [javascript, typescript]
    severity: ERROR
    patterns:
      - pattern: res.set($K, $V)
    metavariable-pattern:
      metavariable: $V
      pattern-either:
        - pattern: req.query.$X
        - pattern: req.params.$X
        - pattern: req.body.$X

  # 2.8 위험/약한 보안 헤더 설정
  - id: cors-star-credentials
    message: "CORS misconfig: Access-Control-Allow-Origin:* with credentials=true."
    languages: [javascript, typescript]
    severity: ERROR
    pattern: |
      app.use(cors({origin: '*', credentials: true}))
    fix: |
      app.use(cors({origin: ['https://app.example.com'], credentials: true}))

  - id: missing-helmet
    message: "helmet() not enabled. Set secure HTTP headers."
    languages: [javascript, typescript]
    severity: WARNING
    pattern: |
      const express = require('express')
      const app = express()
      ...
      module.exports = app
    # 단순 힌트용: 실제로는 import/require 유무/실행 여부를 복합검사

  # 2.9 쿠키 보안 속성
  - id: cookie-insecure
    message: "Set-Cookie missing HttpOnly/Secure/SameSite."
    languages: [javascript, typescript]
    severity: ERROR
    patterns:
      - pattern: res.cookie($N, $V, $OPTS)
    metavariable-pattern:
      metavariable: $OPTS
      pattern-not: '{..., httpOnly: true, secure: true, sameSite: $S, ...}'

  # 2.10 child_process.* 인젝션 위험
  - id: child-process-injection
    message: "Command injection risk. Avoid using user input in exec/spawn with shell."
    languages: [javascript, typescript]
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: child_process.exec($CMD)
          - pattern: child_process.execSync($CMD)
          - pattern: child_process.spawn($BIN, $ARGS, {shell: true, ...})
    metavariable-regex:
      metavariable: $CMD
      regex: '(req\.query|req\.body|req\.params)'

  # 2.11 JWT 검증 취약 패턴
  - id: jwt-no-verify
    message: "JWT verify must specify algorithm & secret/public key."
    languages: [javascript, typescript]
    severity: ERROR
    pattern: jwt.verify($T, $K)
    # 실제에선 verify 옵션 점검/none 금지 등을 taint로 구성하면 더 정확

  # 2.12 약한 해시/암호
  - id: weak-hash
    message: "Avoid MD5/SHA1 for security. Use SHA-256/Argon2/bcrypt/scrypt."
    languages: [javascript, typescript]
    severity: WARNING
    pattern-either:
      - pattern: crypto.createHash('md5')
      - pattern: crypto.createHash('sha1')
```
{% endraw %}

> **팁**: 실제 운영에선 **taint mode**로 “**source → sanitizer → sink**”를 연결하면 **오탐↓, 탐지력↑**. 아래 3장에서 예시.

---

## 3. Taint 모드(고급) — **데이터 흐름**으로 정확도 높이기
**목표**: “**사용자 입력**이 **위험 싱크**로 들어가면 경고”, 중간에 **sanitize**가 있으면 통과.

### 3.1 Express: 사용자 입력 → 파일 경로(sink)  
```yaml
# .semgrep/taint-node.yml
rules:
  - id: path-traversal-taint
    message: "User input flows into filesystem path → Path Traversal."
    languages: [javascript, typescript]
    severity: ERROR
    mode: taint
    pattern-sources:
      - pattern: req.query
      - pattern: req.params
      - pattern: req.body
    pattern-sinks:
      - pattern: |
          fs.readFile($P, ...)
      - pattern: |
          res.sendFile($P)
    pattern-sanitizers:
      - pattern: |
          path.normalize($P)
      - pattern: |
          $CLEAN = $FN($P)  # 사내 유틸 정규화 함수
```

### 3.2 SSRF: 사용자 URL → axios/fetch  
```yaml
rules:
  - id: ssrf-taint
    message: "Possible SSRF: user-controlled URL to HTTP client."
    languages: [javascript, typescript]
    severity: ERROR
    mode: taint
    pattern-sources:
      - pattern: req.query.url
      - pattern: req.body.url
    pattern-sinks:
      - pattern: axios($URL)
      - pattern: fetch($URL)
    pattern-sanitizers:
      - pattern: whitelistCheck($URL) # 화이트리스트 함수
```

---

## 4. **취약 코드 → 수정 예시**

### 4.1 `sendFile(req.query.path)` (취약)
```js
// ❌ 취약
app.get('/download', (req, res) => {
  res.sendFile(req.query.path); // ex) ?path=../../etc/passwd
});
```

**수정**
```js
// ✅ 안전
import path from 'node:path';
const ROOT = '/srv/downloads';

app.get('/download', (req, res) => {
  const name = String(req.query.name || '');
  // 화이트리스트(영숫자/.-_ 만 허용)
  if (!/^[\w.\-]+$/.test(name)) return res.status(400).end();
  const p = path.join(ROOT, name);
  if (!p.startsWith(ROOT)) return res.status(400).end(); // 이중 방어
  res.sendFile(p);
});
```

### 4.2 `eval(req.query.code)` (취약)
```js
// ❌ 취약
app.get('/run', (req, res) => {
  res.send(String(eval(req.query.code)));  // RCE
});
```
**수정**
```js
// ✅ 안전: 미니 DSL/화이트리스트 파서, 혹은 서버 기능으로 맵핑
const ALLOWED = { ping: () => 'pong', add: (a,b)=>a+b };
app.get('/run', (req,res)=>{
  const { op, a, b } = req.query;
  if (!(op in ALLOWED)) return res.status(400).end();
  res.json({ result: ALLOWED[op](Number(a), Number(b)) });
});
```

### 4.3 CORS 오구성
```js
// ❌ 취약
app.use(cors({ origin: '*', credentials: true }));
```
**수정**
```js
// ✅ 안전
const ORIGINS = ['https://app.example.com', 'https://admin.example.com'];
app.use(cors({
  origin: (o, cb) => cb(null, ORIGINS.includes(o) ? o : false),
  credentials: true
}));
```

---

## 5. Python/Django & Java/Spring & Go 룰/예시 (요약)

### 5.1 Django (템플릿/응답/파일)
```yaml
rules:
  - id: django-unsafe-template
    message: "Django: mark_safe or autoescape off → XSS."
    languages: [python]
    severity: ERROR
    pattern-either:
      - pattern: mark_safe($X)
      - pattern: |
          @render_to(...)
          def $F(...):
            autoescape = False
  - id: django-sendfile-userinput
    message: "User input flows into open/sendfile."
    languages: [python]
    severity: ERROR
    mode: taint
    pattern-sources:
      - pattern: request.GET
      - pattern: request.POST
    pattern-sinks:
      - pattern: open($P, ...)
      - pattern: HttpResponse(open($P, ...))
```

### 5.2 Spring (SSRF/경로/헤더)
```yaml
rules:
  - id: spring-ssrf
    message: "RestTemplate/HttpClient with user-controlled URL → SSRF."
    languages: [java]
    severity: ERROR
    mode: taint
    pattern-sources:
      - pattern: request.getParameter(...)
    pattern-sinks:
      - pattern: new RestTemplate().getForObject($U, ..)
      - pattern: HttpClientBuilder.create().build().execute(new HttpGet($U))
  - id: spring-header-crlf
    message: "Response header from user input → CRLF."
    languages: [java]
    severity: ERROR
    patterns:
      - pattern: response.addHeader($K, $V)
```

### 5.3 Go (net/http)
```yaml
rules:
  - id: go-path-traversal
    message: "http.ServeFile with user path → traversal."
    languages: [go]
    severity: ERROR
    pattern: http.ServeFile($W, $R, $PATH)
    # 실제로는 $PATH에 userinput taint 연결

  - id: go-ssrf
    message: "http.Get with user-controlled URL → SSRF."
    languages: [go]
    severity: ERROR
    pattern: http.Get($U)
```

---

## 6. **PR 게이트** 운영: “경고=Fail”, 예외는 **만료일 필수**

### 6.1 GitHub Actions 예시
{% raw %}
```yaml
# .github/workflows/semgrep.yml
name: Semgrep CI
on:
  pull_request:
    branches: [ main ]
jobs:
  semgrep:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: returntocorp/semgrep-action@v1
        with:
          config: |
            .semgrep/web.yml
            .semgrep/js.yml
            .semgrep/python.yml
            .semgrep/java.yml
            .semgrep/go.yml
          generateSarif: true
          auditOn: pull_request
          # 기존 메인과 비교해서 '새 이슈'만 실패시키기
          baselineRef: origin/main
      - name: Fail on any findings (ERROR/WARNING)
        if: ${{ steps.semgrep.outputs.summary != '' }}
        run: |
          echo "Semgrep findings detected."
          exit 1
```
{% endraw %}

> `baselineRef`로 과거 부채는 유지하되 **새 부채만 Fail**. 일정 기간 후 baseline을 줄이며 **정리**.

### 6.2 예외(waiver) **만료일 강제**
- **규칙**: 예외(comment)에는 **사유**와 **만료일(YYYY-MM-DD)**를 반드시 포함.  
- 주석 포맷(예):  
  ```js
  // nosemgrep: js-danger-eval -- reason: legacy plugin -- until: 2025-12-31
  ```
- CI에서 **만료일 검사 스크립트**로 **기한 초과 시 실패**.

```bash
# tools/check_nosem_expiry.sh
#!/usr/bin/env bash
set -euo pipefail
TODAY=$(date +%F)
if grep -RIn --exclude-dir=.git -E 'nosemgrep: .*until:\s*[0-9]{4}-[0-9]{2}-[0-9]{2}' . \
 | awk -v today="$TODAY" -F'until:' '{gsub(/ /,"",$2); d=substr($2,1,10); if (d < today) print "Expired nosemgrep at", $0}' \
 | grep .; then
  echo "❌ Found expired nosemgrep exceptions."
  exit 1
fi
echo "✅ no expired nosemgrep exceptions."
```

Actions에 추가:
```yaml
- name: Check nosemgrep expiry
  run: bash tools/check_nosem_expiry.sh
```

---

## 7. **Autofix** 적용(가능한 룰은 자동 수정)
- Semgrep `fix`/`fix-regex`로 **코드 치유**(예: `cors('*', credentials:true)` → 화이트리스트 템플릿).
- PR 게이트에서 **semgrep --autofix** 먼저 실행 → **Diff** 생성 → 나머지 이슈만 리뷰.

```yaml
- name: Semgrep autofix
  run: semgrep --config .semgrep/web.yml --autofix || true
```

---

## 8. **현실 적용 팁**
1. **오탐 관리**:  
   - 초기엔 **WARNING**로 시작 → 오탐 낮아지면 **ERROR** 승격.  
   - taint로 **sanitizer 함수**를 명시해 오탐↓.
2. **룰 분리**: “**필수**(Fail)” vs “**권고**(Report)” 파일을 분리.  
3. **조직 공통 룰팩**: mono-repo·다수 서비스에 일관 룰 배포.  
4. **메트릭**: “새 부채” 개수, `ERROR` 대비 `WARNING` 비율, **예외 만료 준수율**.

---

## 9. **시연: 취약 코드 → Semgrep 탐지 로그 → 수정**

### 9.1 취약 코드
```js
// routes/download.js
app.get('/download', (req, res) => {
  res.sendFile(req.query.path); // ❌
});

app.get('/proxy', async (req, res) => {
  const r = await fetch(req.query.url);   // ❌ SSRF
  res.send(await r.text());
});

app.get('/xss', (req, res) => {
  res.send(req.query.q);                  // ❌ XSS
});
```

### 9.2 Semgrep 결과(요약)
```
web.yml:express-sendfile-userinput  ERROR  res.sendFile(req.query.path)
web.yml:ssrf-user-url               ERROR  fetch(req.query.url)
web.yml:express-direct-send         ERROR  res.send(req.query.q)
```

### 9.3 수정
```js
// ✅
import path from 'node:path';
const ROOT='/srv/downloads';

app.get('/download', (req, res) => {
  const name = String(req.query.name||'');
  if (!/^[\w.\-]+$/.test(name)) return res.status(400).end();
  const p = path.join(ROOT, name);
  if (!p.startsWith(ROOT)) return res.status(400).end();
  res.sendFile(p);
});

app.get('/proxy', async (req, res) => {
  const u = String(req.query.url||'');
  if (!isAllowedHost(u)) return res.status(400).end();
  const r = await fetch(u, { method: 'GET' });
  res.type('text/plain').send(await r.text());
});

app.get('/xss', (req, res) => {
  res.render('safe-view', { q: escapeHtml(String(req.query.q||'')) });
});
```

---

## 10. **추가 룰 아이디어(확장)**
- **Open Redirect**: `res.redirect(req.query.url)`  
- **HTTP Header Injection**: `res.set(name, userInput)`에 `\r|\n` 포함  
- **JWT “none” 알고리즘 허용** 감지  
- **HSTS 미설정**(공개 서비스)  
- **CSP 없는 HTML 응답**  
- **업로드 크기 제한 미설정**(Express body limit 없음)  
- **템플릿 엔진별 미이스케이프**(Pug `!=`, Nunjucks `safe`)  
- **비밀번호 로그 출력**(keywords)  
- **비밀키 하드코딩**(AWS 키/토큰 정규식)

---

## 11. 체크리스트
- [ ] **핵심 룰**: eval/new Function, dynamic require, template unescape, sendFile/user path, SSRF, header CRLF, CORS `*+credentials`, cookie 보안, child_process  
- [ ] **taint**: source(req.*) → sink(fs/axios/res.send) + sanitizer  
- [ ] **PR 게이트**: 새 이슈 **Fail**, baseline 유지  
- [ ] **예외 주석**: `nosemgrep: <rule> -- reason: ... -- until: YYYY-MM-DD` + CI 만료 검사  
- [ ] **autofix**: 가능한 항목은 자동 수정  
- [ ] **지표**: 새 부채, 예외 만료율, 오탐률

---

### 마무리
이 문서의 **룰·코드·CI 예시**를 그대로 붙여 넣으면, **웹 특화 취약 패턴**을 **PR 단계에서 즉시 차단**할 수 있습니다.  
원하시면 **스택별 세분화(Next.js/Remix, FastAPI, Spring MVC/Boot, Gin/Echo)**로 룰을 더 쪼개고,  
사내 유틸(정규화 함수/화이트리스트 체커)을 **sanitizer**로 등록해 **오탐을 더 줄인** 버전을 만들어 드릴게요.