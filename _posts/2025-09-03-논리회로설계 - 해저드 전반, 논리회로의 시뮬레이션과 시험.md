---
layout: post
title: 논리회로설계 - 해저드 전반, 논리회로의 시뮬레이션과 시험
date: 2025-09-03 18:25:23 +0900
category: 논리회로설계
---
# 조합회로 설계 & 시뮬레이션 — **해저드(Glitch) 전반**, **논리회로의 시뮬레이션과 시험(Testing)**

> 표기: \(+\)=OR, \(\cdot\) 또는 생략=AND, \(\overline{X}\)=NOT \(X\), \(X' \equiv \overline{X}\), \(\oplus\)=XOR.
> 목표: 조합 논리회로에서 **해저드의 원인·종류·검출·제거**를 체계적으로 정리하고, **시뮬레이션(기능/타이밍)**과 **시험(verification & manufacturing test)** 절차를 빠짐없이 다룬다.
> 권장 라이브러리/도구 예: VHDL(`std_logic_1164`, `numeric_std`), SystemVerilog(SVA), 게이트-레벨 타이밍(SDF), 파형(VCD/FSDB).

---

## 0. 배경과 전제

- **해저드(hazard)**는 **지연 불균형**으로 인해 **출력이 잠시 잘못된 값**을 내는 현상(짧은 펄스, glitch). 논리적으로는 등가지만, **물리적 지연**이 존재하는 한 발생할 수 있다.
- 설계자는 **해저드-프리 커버**(중첩 덮개)와 **구조적 구현**(예: 2단 NAND–NAND)로 위험을 낮추고, **시뮬레이션/시험**으로 잔여 리스크를 검증한다.

---

## 1. 조합 논리회로의 **해저드(Glitch)**

### 1.1 왜 생기나? (근본 원인)
- **경로 지연 불균형**: 동일 입력이 **재수렴(reconvergent)** 하여 다른 지연을 거쳐 OR/AND에 합류하면, **선도 경로**가 먼저 바뀌어 잠시 잘못된 출력이 생김.
- **K-map 관점의 ‘덮개 공백’**: 1–1(또는 0–0)로 인접한 두 셀을 **하나의 임플리컨트**가 동시에 덮지 않으면, 그 경계에서 토글 시 glitch 가능.
- **관성 지연(inertial)**: 너무 짧은 펄스는 게이트가 거르지만, **임계 이상 폭**이면 출력 glitch로 관측.

**근사적 글리치 폭**
두 경로 지연을 \(t_1,t_2\)라 할 때, 단일 OR(또는 AND) 합류에서 글리치 폭은
\[
\tau_g \approx |t_1-t_2|
\]
(게이트 고유 관성/상승·하강 비대칭, 하류 단계 전파로 실제 폭은 더 짧아질 수 있음)

### 1.2 해저드의 종류
- **정적-1(static-1)**: 이론상 \(1\to 1\)이어야 하는 전이에서 **0**이 잠깐 발생.
  예) \(F=AB+\overline{A}C\). \(B=C=1\), \(A:0\to 1\) 시 경로 불균형으로 \(F\)가 잠시 0.
- **정적-0(static-0)**: 이론상 \(0\to 0\)이어야 하는데 **1** 펄스 발생. (POS에서 대칭 개념)
- **동적(dynamic)**: \(0\to 1\) 또는 \(1\to 0\) 전이에서 **여러 번 튐**(0→1→0→1). 재수렴 경로가 다단이거나 임플리컨트가 다수일 때.
- **기능적(functional)**: 여러 입력이 동시 변화 시 **순서/타이밍에 의존**(프로토콜/환경 문제).
- **필수(essential)**: (주로 **비동기**) 물리 경로 전파 방향/배선에 기인. 논리식 수정만으로는 어려워 **지연 설계/배선**까지 고려.

### 1.3 K-map으로 **정적 해저드 검출**
- **규칙**: SOP(1 묶기)에서는 **인접 1–1 에지**(한 비트 차)가 **항상 하나의 곱항**으로 동시에 덮여야 정적-1 해저드 없음.
  POS(0 묶기)에서는 0–0 에지에 대해 대칭.

### 1.4 **합의(컨센서스) 항**으로 제거 (SOP 기준)
- 정리: \(AB+\overline{A}C+\underline{BC}=AB+\overline{A}C\).
  \(\underline{BC}\)는 논리적으로 **흡수**되지만, 물리적으로는 **중첩 덮개**를 형성해 정적-1 해저드를 제거.
- **알고리즘(해저드-프리 커버)**
  1) 최소 SOP(예: Q–M, Espresso)를 얻는다.
  2) K-map에서 **모든 1–1 에지**가 한 곱항에 포함되는지 점검.
  3) 공백이 있으면 그 에지를 함께 덮는 **추가 임플리컨트(합의항 포함)**를 넣는다.
  4) don’t-care가 있다면 **묶음을 키워**(2,4,8셀) **리터럴 수↓ & 해저드-프리**를 동시에 달성.

### 1.5 동적 해저드 대처
- 원인: 다단 재수렴, 여러 임플리컨트가 순차적으로 켜졌다 꺼짐.
- 대책:
  - **2단 구조**로 납작하게(예: SOP → **NAND–NAND**) + **중첩 덮개 강화**.
  - **샤논 전개**로 **MUX 구조화**:
    \[
    F = x\cdot F_1 + \overline{x}\cdot F_0 \;\Rightarrow\; F=\mathrm{MUX}(x,F_1,F_0)
    \]
    단일 선택 경로로 동적 해저드 확률 저감.
  - **지연 균형화**: 동일 신호 분기 경로의 **버퍼/배선 길이 매칭**.

### 1.6 해저드와 전력
- glitch는 **불필요 토글률** \(\alpha\)를 올려 동적 전력 \(P\approx \alpha C V^2 f\)를 증가시킨다.
- 대형 조합 블록(예: 디코더, PLA, S-Box 등)은 해저드 저감이 **전력 최적화**에 직결.

### 1.7 문자 파형(개념)
```
A:  ────┌────────
        │
        └────────
B:  ───────────── (1)
C:  ────────┌──── (1 유지)
            │
            └────
F1 = AB + A'C:
    ────┐__/\_____   ← 정적-1 해저드(짧은 0 펄스)
        └─────────
F2 = AB + A'C + BC:
    ──────────────   ← 합의항으로 중첩 확보 → 해저드 완화
```

---

## 2. 논리회로의 **시뮬레이션** (기능/타이밍, 모델, 파형)

### 2.1 시뮬레이션 수준
- **기능(Zero-delay/Unit-delay)**: 논리 기능/커버리지 확인, 해저드 잠재 구간 파악의 1차 관문.
- **게이트-레벨 타이밍**: 표준 셀/배선 지연 반영. **SDF(표준 지연 포맷)** 백어노테이션으로 **min/typ/max** PVT 코너 검증.
- **트랜지스터/Spice**: 아날로그 정밀(상승/하강 시간, 펄스 소거 한계 등). 필요 시 일부 경로 샘플링.

### 2.2 지연 모델
- **전파 지연** \(t_{pHL}, t_{pLH}\), **오염 지연** \(t_{cd}\), **배선 지연** \(t_{wire}\).
- **관성(Inertial)** vs **수송(Transport)**
  - 관성: **짧은 펄스 소거**(실제 게이트 근사).
  - 수송: 펄스를 **있는 그대로** 전달(배선/와이어 모델, worst-case 탐색).

### 2.3 2/4/9-값 로직 & X-전파
- \(0,1\) 외에 **X(unknown), Z(High-Z)** 등을 갖는 다값 시뮬레이터에서 **X-전파**가 지나치게 낙관/비관되지 않도록 설정·테스트 작성에 주의.
- 리셋 없는 조합 경로가 레지스터에 영향 → **X-전파 체크**로 조기 발견.

### 2.4 Verilog 예: 해저드 관찰(게이트 지연 부여)
```verilog
`timescale 1ns/1ps
module hazard_demo(input A,B,C, output F);
  wire nA, t1, t2;
  not  #(1,1)  U0(nA, A);
  and  #(2,2)  U1(t1, A, B);    // 경로1
  and  #(3,3)  U2(t2, nA, C);   // 경로2 (느림)
  or   #(1,1)  U3(F, t1, t2);
endmodule

module tb;
  reg A,B,C; wire F;
  hazard_demo U(.A(A),.B(B),.C(C),.F(F));
  initial begin
    $dumpfile("wave.vcd"); $dumpvars(0,tb);
    B=1; C=1; A=0; #5;     // 정상: F=1
    A=1;        #30;       // A 토글: 글리치 관찰
    $finish;
  end
endmodule
```

### 2.5 글리치 폭 측정 & 어서션(간단)
```verilog
// 최소 펄스폭 1.5ns 미만이면 리포트
time last_edge;
initial last_edge = 0;
always @(posedge F or negedge F) begin
  if (last_edge!=0) begin
    time pw = $time - last_edge;
    if (pw < 15) $display("**GLITCH width=%0t at %0t", pw, $time);
  end
  last_edge = $time;
end
```

**SVA(권장)**
```systemverilog
// F가 0->1 후 1.5ns 이내에 1 유지해야 함
property min_pw_high; @(posedge F) ##[0:$] $stable(F) [*15];
endproperty
assert property(min_pw_high) else $error("Pulse too short on F");
```

### 2.6 VHDL로 관성/수송 비교(테스트벤치 전용)
```vhdl
signal a, y_inert, y_trans : std_logic;

-- 관성(inertial, 기본): 짧은 펄스 소거
y_inert <= a after 2 ns;

-- 수송(transport): 펄스 그대로 전달
y_trans <= transport a after 2 ns;

stim: process
begin
  a <= '0'; wait for 5 ns;
  a <= '1'; wait for 1 ns; a <= '0'; -- 1ns 펄스
  wait for 10 ns;
  a <= '1'; wait for 3 ns; a <= '0'; -- 3ns 펄스
  wait;
end process;
```
- 결과: 1ns 펄스는 `y_inert`에서 소거, 3ns는 통과(관성 한계 2ns). `y_trans`는 둘 다 통과.

### 2.7 타이밍도 읽기 요령
- **동일 시간 축**에 입력/내부노드/출력을 배열하여 경로 지연 차이와 glitch 창을 시각화.
- **최장 경로(크리티컬)**와 **최단 경로(오염)**를 함께 마킹.

---

## 3. **시험(Testing)** — 설계 검증부터 제조 시험까지

### 3.1 설계 검증(Verification)
- **Directed + Constrained-random** 자극으로 기능 코너를 포괄.
- **커버리지**: 코드(라인/분기), **함수 커버리지**(조건/조합), **토글**.
- **LEC**(Logic Equivalence Check): RTL ↔ 게이트 등가성.
- **포멀 검증**: 조합 블록은 **SAT/BDD** 기반으로 명세 위반 불가를 증명하기 용이.

### 3.2 제조 시험(Manufacturing Test) — 조합 회로 중심
- **결함 모델**
  - **Stuck-at-0/1**: 노드가 항상 0 또는 1. 노드 수 \(N\) → 결함 수 \(2N\).
  - **Transition/Delay fault**: 느린 상승/하강(경로 지연 결함 포함).
  - (참고) **Bridging**(단락), **Open**(단선) 등 물리 결함도 고려.
- **ATPG**(Automatic Test Pattern Generation)
  1) **활성화**: 결함 노드 값을 **반대로** 만들기
  2) **전파**: 결함 효과가 출력까지 도달하도록 경로 개방
  3) **정당화**: 모든 내부 조건을 일관되게 만드는 입력을 산출
  (D-알고리즘, PODEM, FAN 등 고전 알고리즘 사용)
- **Fault coverage**
  \[
  \mathrm{FC} = \frac{\#\text{검출 결함}}{\#\text{총 결함}}
  \]
  목표치 설정(예: \(>99\%\)) 후 패턴 수/시험 시간과 트레이드오프.
- **SCOAP 제어성/관측성**: 낮을수록 테스트 용이. DFT에서 **관측점/제어점 삽입**을 검토.
- **BIST**(Built-In Self-Test)
  - **LFSR**로 pseudo-random 패턴 생성, **MISR**로 응답 압축.
  - **서명(aliasing)** 확률 \(\approx 2^{-n}\) (서명 길이 \(n\)).

### 3.3 간단 stuck-at 시험(시뮬레이션)
```verilog
// 정상 회로
module comb(input A,B,C, output F);
  assign F = (A & B) | (~A & C);
endmodule

// 결함 주입: 내부 AND의 출력 't1'이 stuck-at-0
module comb_faulty(input A,B,C, output F);
  wire t1 = 1'b0; // 원래는 A & B
  assign F = t1 | (~A & C);
endmodule

module tb;
  reg A,B,C; wire F_ok, F_bad;
  comb        U1(.A(A),.B(B),.C(C),.F(F_ok));
  comb_faulty U2(.A(A),.B(B),.C(C),.F(F_bad));

  initial begin
    $display("A B C | good bad  (detect=1 if differ)");
    for (int i=0;i<8;i++) begin
      {A,B,C}=i[2:0]; #1;
      $display("%0b %0b %0b |   %0b    %0b    %0d",
               A,B,C, F_ok, F_bad, (F_ok^F_bad));
    end
    $finish;
  end
endmodule
```
- **검출 패턴** 예: \(A=B=1,C=0\)에서 정상 \(F=1\), 결함 \(F=0\) → 검출.

### 3.4 BIST 예(간략, 조합 DUT 감싸기)
```verilog
module lfsr #(parameter N=8) (input clk, rst, output reg [N-1:0] q);
  wire fb = q[N-1] ^ q[5] ^ q[4] ^ q[3]; // 예: x^8+x^6+x^5+x^4+1
  always @(posedge clk or posedge rst)
    if (rst) q <= 'h1; else q <= {q[N-2:0], fb};
endmodule

module misr #(parameter N=8, M=1)
 (input clk, rst, input [M-1:0] din, output reg [N-1:0] sig);
  wire fb = sig[N-1] ^ din[0]; // 단일비트 응답 가정
  always @(posedge clk or posedge rst)
    if (rst) sig <= '0; else sig <= {sig[N-2:0], fb};
endmodule

module dut(input [2:0] in, output out);
  assign out = (in[2]&in[1]) | (~in[2]&in[0]); // 예시 조합 회로
endmodule

module top_bist(input clk, rst, output [7:0] signature);
  wire [7:0] prn; wire out;
  lfsr L(.clk(clk), .rst(rst), .q(prn));
  dut  D(.in(prn[2:0]), .out(out));
  misr M(.clk(clk), .rst(rst), .din(out), .sig(signature));
endmodule
```
- 충분한 클록 후 `signature`를 **골든 서명**과 비교(실리콘에서는 테스터가 읽어 확인).

---

## 4. **해저드-프리 설계 절차**(SOP 기준, 실무 레시피)

1) **최소 SOP** 도출(Q–M/알고리즘).
2) K-map에서 **모든 1–1 에지**가 **한 곱항**으로 덮이는지 확인.
3) 비덮개 에지는 그 둘을 함께 덮는 **추가 임플리컨트**(합의항 포함) 삽입.
4) 가능하면 **2단 구조**(NAND–NAND)로 구현해 단계 수 축소.
5) **지연 균형**(버퍼/배선 매칭) 및 **배선 인접성** 고려(필수 해저드 저감).
6) **타이밍 시뮬레이터**로 **min/typ/max** 코너의 **펄스 폭** 확인(SDF).

> POS 사용 시 0–0 에지와 **합항**에 대해 대칭적으로 적용(정적-0 방지).

---

## 5. 종합 예제 — “설계 → 해저드 제거 → 시뮬레이션 → 시험”

**사양**: 3입력 **다수결** \(F=1 \iff \text{입력 중 2개 이상이 1}\).
최소 SOP: \(F=AB+AC+BC\).

### 5.1 해저드 점검
- \(AB, AC, BC\)가 K-map에서 **서로 중첩** → **정적-1 해저드 없음**.
- 대안형 \(F=(A+B)(A+C)=A+BC\)로 **다단 경로** 만들면 동적 해저드 가능 → **SOP 2단** 권장.

### 5.2 NAND–NAND 2단 구현
```verilog
module majority3(input A,B,C, output F);
  wire n1 = ~(A & B);
  wire n2 = ~(A & C);
  wire n3 = ~(B & C);
  assign F = ~(n1 & n2 & n3);
endmodule
```

### 5.3 타이밍 시뮬 & 글리치 체크(인위적 지연 차 부여)
```verilog
module majority3_glitchy(input A,B,C, output F);
  wire n1, n2, n3;
  nand #(2,2) U1(n1, A, B);
  nand #(5,5) U2(n2, A, C);   // 지연 차
  nand #(3,3) U3(n3, B, C);
  nand #(1,1) U4(F, n1, n2, n3);
endmodule

// TB: 랜덤 토글 + 펄스폭 체크
module tb;
  reg A,B,C; wire F;
  majority3_glitchy U(.A(A),.B(B),.C(C),.F(F));
  initial begin
    $dumpfile("maj.vcd"); $dumpvars(0,tb);
    {A,B,C}=3'b000; #5;
    repeat (50) begin
      #3 A=$urandom%2; #2 B=$urandom%2; #4 C=$urandom%2;
    end
    #20 $finish;
  end
  time last;
  always @(posedge F or negedge F) begin
    if (last!=0) begin
      time pw=$time-last; if (pw<10) $display("GLITCH pw=%0t at %0t", pw, $time);
    end
    last=$time;
  end
endmodule
```
- **관측**: SOP 2단이라도 **인위적 큰 지연 불균형**이면 짧은 펄스가 보일 수 있음 → **지연 균형화** 또는 **MUX 구조** 검토.

### 5.4 간단 stuck-at 시험(다수결 예)
- 내부 `nand` 출력 stuck-at-0/1로 가정.
- \(A,B,C\) 조합 가운데 **정상/결함**이 다르게 나오는 패턴을 찾고(ATPG), TB로 **fault coverage** 확인.

---

## 6. 체크리스트 (현장용)

- [ ] **해저드-프리 커버**: 모든 1–1(또는 0–0) 에지가 **한 임플리컨트**에 포함되는가?
- [ ] **합의항** 추가로 중첩을 확보했는가(전력/면적 트레이드오프 포함)?
- [ ] **2단 매핑**(NAND–NAND / NOR–NOR)으로 구조 단순화했는가?
- [ ] **지연 균형**(버퍼/배선 길이)과 **배선 인접**(필수 해저드) 고려를 했는가?
- [ ] **기능·타이밍 시뮬**(SDF min/typ/max)과 **X-전파** 체크를 모두 수행했는가?
- [ ] **시험 전략**: 대상 결함/커버리지 목표, ATPG/BIST 계획, SCOAP 개선 포인트가 명확한가?

---

## 7. 연습문제

1) \(F=AB+\overline{A}C\)
   - (a) K-map으로 **정적-1 해저드** 에지를 표시하라.
   - (b) **SOP 해저드-프리 커버**를 구성하고, **합의항**을 명시하라.
   - (c) Verilog로 원식/개선식 둘 다 타이밍 시뮬, **펄스폭 통계**를 출력하라.

2) POS \(F=(A+B)(\overline{A}+C)\)
   - (a) **정적-0 해저드** 조건을 찾고 K-map에 표시.
   - (b) **NOR–NOR 2단** 구현과 함께 해저드-프리 커버를 제시하라.

3) 재수렴 경로가 깊은 조합 네트워크에서 **동적 해저드** 파형을 생성하고,
   - (a) **샤논 전개 기반 MUX**로 구조 변경,
   - (b) 글리치 폭/빈도를 수치 비교하라.

4) 작은 조합 블록에 대해 **stuck-at** 결함 리스트(노드 \(N\)개 → \(2N\))를 만들고,
   - (a) 간단한 ATPG로 검출 패턴을 도출,
   - (b) TB에서 **fault coverage**를 산출하라.

---

## 8. 참고문헌(미국/유럽권, 최신 판본 우선)

- M. Morris Mano, Michael Ciletti, **Digital Design**, Pearson.
- Charles Roth, Larry Kinney, **Fundamentals of Logic Design**, Cengage.
- David Harris, Sarah Harris, **Digital Design and Computer Architecture**, Morgan Kaufmann.
- M. Abramovici, M. Breuer, A. Friedman, **Digital Systems Testing and Testable Design**, IEEE Press.
- Laung-Terng Wang, Cheng-Wen Wu, Xiaoqun Wen, **VLSI Test Principles and Architectures**, Morgan Kaufmann.
- R. Bryant, D. O’Hallaron, **Computer Systems: A Programmer’s Perspective**, Pearson. (타이밍/X-전파 및 실무 감각에 도움)

> 위 서적들은 해저드/K-map/합의항, ATPG/BIST, 타이밍·시뮬레이션 등 본문 주제를 체계적으로 다룬 표준 레퍼런스들이다.

---

### 포켓 요약
- **해저드=지연 불균형 + 덮개 공백**. K-map에서 **에지마다 한 임플리컨트**가 덮게 하라.
- **합의항**은 논리적으로 불필요해도 물리적으로 **안정**을 준다.
- **시뮬레이션**은 기능→타이밍(SDF). **관성 vs 수송** 차이를 이해하고 SVA로 **펄스폭**을 체크.
- **시험**은 설계 검증(LEC/포멀/커버리지)과 제조 시험(ATPG/BIST) 모두 필요.
- 전력 관점에서도 **글리치 저감**은 유의미한 이득을 만든다.
