---
layout: post
title: 암호학 - 동형암호·MPC
date: 2025-10-17 14:30:23 +0900
category: 암호학
---
# 16. 동형암호·MPC

> 이 장은 **동형암호(HE: PHE/SHE/FHE)**의 수학적 직관과 실제 엔지니어링(노이즈·레벨·부트스트랩·파라미터·패킹) →  
> **MPC(안전한 다자간 계산)**의 비밀공유·가비지드 서킷·OT·Beaver 트리플·SPDZ/GMW →  
> **실용 사례(통계 집계·의료/금융 협업·PSI/FL/안전한 집계)**를 **코드 스케치/체크리스트/실수 방지**까지 포함해 정리합니다.  
> 목표: “**데이터는 항상 암호화/분산된 채로** 계산하고, **유의미한 성능**을 얻는 법”을 감 잡기.

---

## ✅ 16.1 큰 그림: HE vs MPC — 무엇이 다른가?

| 관점 | 동형암호(HE) | MPC |
|---|---|---|
| 신뢰/배치 | **단일 계산자**도 OK(서버는 평문 미접근) | **여러 당사자**가 나누어 계산 |
| 데이터 상태 | **암호문 그대로 연산** | **쉐어(비밀분산)** 또는 **암호문/가비지드** |
| 연산 모델 | 덧셈/곱셈(및 비교/부호 등은 변환 필요) | 임의의 회로(AND/XOR/+,×, 비교 등) |
| 성능/비용 | 곱셈 레벨/부트스트랩 비용 큼, 네이티브 병렬/벡터화 | 통신 왕복·대역폭·OT/트리플 사전생성 비용 |
| 장점 | 단독 서버에서도 프라이버시 보존, 감사·감염면 좁음 | 일반성·유연성·조건분기 쉬움, 비교/최댓값 효율적 |
| 결론 | **비정형 비교/분기 적은 수치연산·집계·ML** | **조건·비교·프로토콜 상호작용 많은 계산** |

> 현실은 **하이브리드(HE+MPC+PSI+FL)**. 예: **HE로 집계** + **MPC로 비교/질의**.

---

## ✅ 16.2 동형암호 HE: PHE/SHE/FHE 개념

### 16.2.1 용어·정의
- **동형성(Homomorphism)**: 암호문 연산이 평문 연산으로 “대응”  
  \[
  \mathsf{Dec}(\mathsf{Enc}(m_1)\circ \mathsf{Enc}(m_2)) = m_1 \star m_2
  \]
- **PHE(부분 동형)**: 덧셈 **또는** 곱셈만(예: Paillier: 덧셈 동형, ElGamal 변종).  
- **SHE(준동형/Leveled HE)**: 제한된 깊이의 덧셈+곱셈(노이즈 버짓 소모).  
- **FHE(완전 동형)**: **임의의 다항식**(무한 깊이) 계산 가능. 비결: **부트스트랩**으로 노이즈 초기화.

### 16.2.2 노이즈와 레벨
- 암호문에는 **잡음(noise)**가 포함되고, **곱셈**할수록 증가 → **복호 오류** 발생 임계점 존재.  
- **레벨(Depth)**: 허용 가능한 곱셈 층수. **Leveled HE**는 미리 정한 깊이까지 부트스트랩 없이 수행.  
- **부트스트랩(Bootstrapping)**: “암호문을 자기자신으로 복호하는 회로”를 **암호문 위에서 실행**해 노이즈를 리셋 → FHE 완성. (비용 큼, 최근 속도 개선)

### 16.2.3 대표 스킴·서술
- **Paillier (PHE-Add)**: \(\mathsf{Enc}(m_1)\cdot \mathsf{Enc}(m_2)=\mathsf{Enc}(m_1+m_2)\), 정수 덧셈 집계에 훌륭.  
- **BFV/BGV (Leveled/FHE, 정수)**: 모듈러 정수 연산 정확. RNS·CRT로 고속화.  
- **CKKS (近실수近似)**: 실수/복소 벡터에 대한 **근사(스케일)** 연산. ML/통계에 적합.  
- **TFHE / FHEW (Bit-level, 부트스트랩 빠름)**: 부울/비교/룩업에 유리.

> **정수 정확성**이 중요하면 **BFV/BGV**. **수치/ML**이면 **CKKS**. **비교/부울**이면 **TFHE류**.

---

## ✅ 16.3 HE 엔지니어링: 파라미터·패킹·회로

### 16.3.1 보안 파라미터 감각
- **안전성 λ**: 128/192/256-bit 등.  
- **다항환 차수 \(N\)**, **모듈러스 \(q\)**, **스케일(Δ)**(CKKS) → **깊이/정밀도/크기** 결정.  
- **RNS(Residue Number System)**: 큰 \(q\)를 소수 곱으로 분해해 병렬 산술.  
- **키·릴리니어라이제이션 키(자동곱셈 키)** 메모리/생성 비용 고려.

### 16.3.2 패킹(Packing / SIMD)
- 다항환 슬롯에 **벡터를 일괄 인코딩** → 한 번의 동형 연산으로 다수 요소 처리.  
- **회전/부트스트랩 비용** 있지만, 집계/컨볼루션/행렬-벡터에 유리.  
- 예: CKKS에서 2N 슬롯 복소 벡터, **Galois 회전키** 필요.

### 16.3.3 회로 설계 요령
- **곱셈 깊이 최소화**: ReLU 대신 **poly近似**(Chebyshev), 비교는 **sign近似** 또는 TFHE 하이브리드.  
- **스케일 관리(CKKS)**: 곱셈마다 스케일 ↑ → **Rescale**로 유지, 마지막에 정밀도 평가.  
- **정수 BFV**: 모듈러 wrap-around 고려(범위 제한), overflow 예방.

### 16.3.4 미니 의사코드(개념: CKKS 평균)
```text
# 공개: HE 파라미터(λ, N, q, Δ), 공개키 pk, 회전키 rk
# 클라 i: 벡터 x_i (길이 L <= 슬롯 수)

Client i:
  c_i = Enc_pk( Encode_CKKS(x_i, scale=Δ) )
  send c_i

Server:
  c_sum = Σ_i c_i
  c_mean = c_sum * (1/num_clients)   # 상수배는 가벼움
  send c_mean

Client (or Server with sk):
  x_mean ≈ Decode( Dec_sk(c_mean) )  # 근사오차 존재(Δ,레벨에 의존)
```

---

## ✅ 16.4 부트스트랩 직관

- 암호문 \(c\)의 노이즈를 **암호문 상태에서 복호 연산을 실행**해 초기화.  
- **아이디어**: 복호식 \(m = \lfloor \frac{q}{t} \cdot (c \bmod q) \rceil \bmod t\) 를 “낮은 깊이의 회로”로 근사/테이블화하고, **암호문**으로 평가.  
- 비용: 과거 수초→최근 **수~수십 ms/슬롯**까지 최적화(스킴·파라미터 의존).  
- **레벨드 설계**에서 보트스트랩 **없애고** 대신 입력 정규화/깊이 제한으로 처리하는 전략이 현실적.

---

## ✅ 16.5 MPC: 비밀 공유와 안전 계산

### 16.5.1 비밀 공유(Secret Sharing)
- **Additive Sharing (mod p/2^k)**: \(x = x_1 + x_2 + \dots + x_n \pmod{p}\), 각 당사자는 자신의 몫만 보유. 합치면 복원.  
- **Shamir (t-of-n)**: \(\mathbb{F}_p\) 다항식 \(f(0)=x\), \(t\)개 이상 점으로 복구(프라이버시/내결함성).

**연산**
- **덧셈**: 로컬로 쉽게.  
- **곱셈**: 공유끼리 곱은 교차항 발생 → **보조 자료(Beaver triples)** 또는 **상호작용**으로 처리.

### 16.5.2 Beaver 트리플(곱셈 가속)
- 미리 공유된 \(a,b,c\) (단 \(c=a\cdot b\)), 각 당사자가 쉐어 보유.  
- 런타임에 \(x\cdot y\) 계산:
  1) \(\alpha = x - a\), \(\beta = y - b\) 를 공개(또는 부분 공개)  
  2) \(x\cdot y = c + \alpha b + \beta a + \alpha\beta\) 를 로컬 조합  
- 곱 연산을 1~2 라운드로 단축. (트리플은 오프라인에서 OT/HE 등으로 생성)

### 16.5.3 OT(Oblivious Transfer)
- 송신자 \( (m_0,m_1)\), 수신자 \(b\in\{0,1\}\). 수신자는 \(m_b\)만 얻고, 송신자는 \(b\)를 모름.  
- **IKNP/ALSZ 확장 OT**로 수천~수백만 OT를 효율 생성 → **GMW/야오** 기반 MPC의 핵심 부품.

### 16.5.4 대표 프로토콜 스택
- **Yao 가비지드 서킷(2-Party)**: 보안 함수 평가. AND 게이트당 상수 통신. 조건/비교 쉬움.  
- **GMW**: 비트 공유 + AND에 OT 사용, N-Party 확장 용이.  
- **SPDZ(MASCOT/Overdrive 계열)**: MAC이 붙은 유한체 공유 + 트리플 대량 생성(OT/HE로) + 온라인 빠름.  
- **ABY/ABY3**: **세 가지 표현(Arithmetic/Boolean/Yao)**을 동적으로 변환해 장점 결합.

### 16.5.5 미니 스케치(2-Party, 평균)
```text
Alice: x, Bob: y
- Field mod p에서 additive share: 
  Alice picks r <-$ F, send (y - r) to Alice? (역할 교환 가능)
  평균 (x+y)/2 = ( (x_shareA + y_shareA) + (x_shareB + y_shareB) ) / 2
- OR Yao: 
  회로 f(x,y) = floor((x+y)/2) 만 구성, 게이트 수 작음 → 매우 빠른 2PC
```

---

## ✅ 16.6 HE–MPC 하이브리드

- **HE로 집계/선형 계산** (덧셈, 스칼라곱) → **MPC로 비교/최댓값/Argmax**.  
- **PSI(Private Set Intersection)**: OPRF/OT/HE 혼합으로 대규모 교집합/조인.  
- **FL(연합학습)**: 클라이언트 업데이트 **HE 암호화** → 서버 합 → 필요 시 **MPC로 이상치/규칙 검증**.

**예: 안전한 평균 + 이상치 필터**
1) 클라이언트: CKKS로 업데이트 벡터 암호화 후 전송  
2) 서버: 합/평균을 HE로 계산  
3) MPC 단계: “평균 대비 L2 노름 > τ 인지”를 공유/비교(조건분기 용이)

---

## ✅ 16.7 실용 사례

### 16.7.1 통계 집계(산업/공공)
- **문제**: 여러 기관의 민감 카운트/합계/평균을 **개별 데이터 공개 없이** 산출.  
- **해법**: Paillier(덧셈 동형) 또는 CKKS로 **암호문 합산**.  
- **주의**: 집계 결과의 **차등프라이버시(DP)** 노이즈 추가로 재식별 방어.

**의사코드(Paillier)**
```text
Each org i:
  c_i = Enc_pk(count_i)
Send c_i -> aggregator
Aggregator:
  C = Π_i c_i       # 곱이 곧 합의 암호문
  send C -> key-holder (또는 TEE/MPC로 분산 복호)
Key-holder:
  total = Dec_sk(C)
```

### 16.7.2 의료 협업(유전체/영상/표준 검정)
- **유전자 변이 빈도**, **코호트 통계**, **로지스틱 회귀 계수**.  
- **HE**: 벡터-행렬 곱, 다항 근사(시그모이드).  
- **MPC**: 환자 필터링/인클루전-익스클루전 규칙(조건/비교/범위)을 효율 처리.  
- **PSI**: 병원 간 환자 레코드 **교집합 추출**(e.g., 동일 환자 식별자 해시에 대해 OPRF-PSI).

### 16.7.3 금융 데이터 협업
- **신용 점수 산출**, **부정거래 탐지**, **KYC 교차검증**.  
- **HE 집계 + MPC 검증**: 특정 임계 이상 거래 수/금액 비교, 블랙리스트 매칭(PSI).  
- **감사/거버넌스**: 로그/정책/법적 근거를 함께 보관.

---

## ✅ 16.8 성능 최적화 팁(요지)

- **HE**  
  - 패킹/SIMD 극대화 → 회전키 준비, **배치 연산** 설계  
  - 곱셈 깊이 줄이기(다항 근사 차수↓, 폴리 팩토리)  
  - **키/릴리니어라이제이션** 최소화(필요한 회전만)  
  - **레벨 예산** 계산 → 부트스트랩 생략 가능한 형태로 설계  
- **MPC**  
  - **라운드 수 최소화**(야오의 상수 라운드 vs GMW의 O(depth))  
  - **트리플/OT 오프라인 대량 생성**  
  - 네트워킹: **배치·파이프라이닝**·압축·TLS 재사용  
- **하이브리드**  
  - 선형 부분은 HE, 비선형(비교/Max/Argmax)은 MPC  
  - PSI/OPRF로 **키-밸류 조인**을 프라이버시 보존

---

## ✅ 16.9 안전 설계·운영 체크리스트

- **위협 모델**  
  - 정직하지만 궁금한(semihonest) vs 악의적(malicious) 가정 분명히  
  - 키 보유자/복호 권한 분리(단일 실패점 제거), 필요 시 **임계 복호(t-of-n)**  
- **키/파라미터**  
  - HE 보안 레벨(λ≥128), \(N,q\)와 레벨/정밀도 문서화, 키 회전 및 파기  
  - MPC 키/시드/트리플·OT 시드 **감사 로그**  
- **부채널·오라클**  
  - 에러 메시지 통일(복호 실패/정밀도 부족 등), 13장 원칙 적용(타이밍/메모리/로그)  
- **출력 프라이버시**  
  - 소수 집단/단일 레코드 재식별 방지(차등프라이버시, 버킷 최소 크기)  
- **거버넌스**  
  - 데이터 사용 목적/보존 기간/감사 정책, 법적 동의/윤리 검토

---

## ✅ 16.10 흔한 실수(안티-패턴)

1) **CKKS 정밀도 오해**: 스케일/Rescale 설계 없이 무작정 곱 → 오차 폭증/언더플로.  
2) **레벨 초과**: 곱셈 깊이 예산 없이 회로 작성 → 복호 실패.  
3) **회전키/릴리 키 과다**: 모든 회전 생성 → 키 크기 폭증/배포 어려움.  
4) **MPC 통신 무시**: WAN에서 라운드 많은 GMW → 지연 폭탄.  
5) **악의적 모델 미고려**: 실제 적대자 가정은 악의적이나 프로토콜은 정직가정 → 공격 여지.  
6) **PSI 결과 누설**: 단순 교집합 크기만 공개해도 소수 집합에서 재식별 위험 → DP/threshold 공개.

---

## ✅ 16.11 미니 워크플로 예제

### 16.11.1 “여러 병원 혈당 평균 + 고위험군 비율”
1) **평균**: CKKS로 환자별 혈당 벡터 암호화 → 중앙에서 합/건수 계산 → 평균 복호(혹은 분산 복호).  
2) **고위험군 비율(> 180mg/dL)**:  
   - 옵션 A(HE-only): 비교를 다항근사(sign)로 대체(근사오차 허용).  
   - 옵션 B(HE+MPC): HE로 집계된 벡터를 각 병원에 **쉐어**로 변환 → MPC로 정확 비교/카운트.  
3) **출력 보호**: 병원별/그룹별 최소 집단 크기, DP 노이즈 추가.

### 16.11.2 “금융기관 간 블랙리스트 매칭(PSI) + 한도 초과 탐지”
- **PSI**: 고객 ID 해시에 대한 OPRF-PSI로 교집합만 계산.  
- **한도 탐지**: 교집합된 개체의 거래 합계를 Paillier/CKKS로 합산, MPC로 임계 비교.

---

## ✅ 16.12 코드 스니펫(개념)

### 16.12.1 HE 라이브러리 의사코드(BFV 정수 합)
```python
# params = (poly_modulus_degree=N, coeff_modulus=[...], plain_modulus=t)
ctx = SEAL.Context(params)
sk, pk, rlk = KeyGen(ctx)
enc = Encryptor(ctx, pk)
eva = Evaluator(ctx)
dec = Decryptor(ctx, sk)
bte = BatchEncoder(ctx)  # 패킹

# 클라이언트: 정수 벡터 v 인코딩 → 암호화
pt = bte.encode(v)                  # Z_t^n
c  = enc.encrypt(pt)

# 서버: 여러 c_i 합
C_sum = sum_ciphertexts(c_list)     # eva.add_many
# (선택) 상수배, 회전, 재선형 등

# 복호
pt_sum = dec.decrypt(C_sum)
v_sum  = bte.decode(pt_sum)
```

### 16.12.2 MPC(파이썬 유사, 개념) — Beaver 곱
```python
# 각 당사자는 공유 xA,xB / yA,yB 보유 (2-Party additive)
# 오프라인: a,b,c=a*b 공유 준비
alphaA = xA - aA ; alphaB = xB - aB
betaA  = yA - bA ; betaB  = yB - bB
# 공개 단계
alpha = alphaA + alphaB
beta  =  betaA +  betaB
# 온라인 곱 결과 공유
zA = cA + alpha*bA + beta*aA + (0.5 if partyA else 0.5)*alpha*beta  # 분배 방식 예시
zB = cB + alpha*bB + beta*aB + (0.5 if partyB else 0.5)*alpha*beta
```

*(실제 구현은 정교한 모듈러/분배 규약 사용. 위는 개념만.)*

---

## ✅ 16.13 선택 가이드

- **단독 서버·수치 집계/ML** → **CKKS/BFV** (가능하면 레벨 설계로 부트스트랩 회피)  
- **정확 비교/조건 로직 많음** → **MPC(GMW/ABY/YaO)**  
- **대규모 교집합/조인** → **PSI(OPRF/OT 기반)**  
- **강한 적대자·투명성 요구** → **STARK류(HE 아님)** + **MPC 악의적 보장**  
- **하이브리드**: HE(선형) + MPC(비선형) + PSI(조인) + DP(출력 보호)

---

## ✅ 16.14 운영·배포 모범사례

- **키 관리**: HE sk는 HSM/KMS/임계복호, 회전/폐기 계획(12장 참조).  
- **성능 모니터링**: 부트스트랩/회전/곱수 카운트, 통신량·라운드 수, QPS/지연.  
- **CI/테스트**: 정밀도 회귀(CKKS ULP), 레벨 버짓 초과 알람, MPC 라운드 회귀.  
- **감사**: 프로토콜 버전/파라미터 해시/회로 카운트/키 지문/정책 로그 고정.  
- **법·윤리**: 목적 제한, 재식별 방지(DP/최소 그룹), 데이터 보존/삭제.

---

## ✅ 16.15 요약 카드

- **HE**: PHE(덧셈)/Leveled/FHE(부트스트랩). 노이즈·레벨·패킹·스케일이 성능/정확도 좌우.  
- **MPC**: 비밀공유·OT·Beaver·SPDZ/GMW/YaO. 통신/라운드가 병목.  
- **하이브리드**가 실전의 왕도: HE(선형) + MPC(비선형) + PSI + DP + 거버넌스.  
- **체크리스트**: 파라미터·레벨·키관리·출력프라이버시·감사/CI/DR.

---

## ✅ 16.16 연습문제

1) CKKS에서 **스케일(Δ)**과 **Rescale**이 정확도/레벨에 미치는 영향을 수식과 예로 설명하라.  
2) Beaver 트리플을 이용한 곱 연산에서, 왜 \(\alpha,\beta\) 공개가 **정보 유출을 일으키지 않는지**를 증명하라(공격자 모델 포함).  
3) HE로 **로지스틱 회귀**를 구현하려면 시그모이드를 어떻게 근사/분해할지, 회로 깊이와 정밀도 관점에서 설계하라.  
4) GMW와 Yao를 **라운드 수/통신량/게이트 유형** 기준으로 비교하고, WAN/ LAN 각각에서의 선택을 정당화하라.  
5) PSI에서 OPRF 기반 접근과 OT 기반 접근의 **확장성/통신·계산 비용** 차이를 분석하라.  
6) 의료 협업 시나리오에서 **HE-only**와 **HE+MPC**의 위험/성능 트레이드오프를 표로 정리하라.
