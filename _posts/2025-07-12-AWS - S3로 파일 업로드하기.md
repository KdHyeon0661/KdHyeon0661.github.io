---
layout: post
title: AWS - S3로 파일 업로드하기
date: 2025-07-12 22:20:23 +0900
category: AWS
---
# S3로 파일 업로드하기: EC2 웹사이트 방식과 로컬 업로드 실습

## 로드맵

1. EC2에서 S3로 업로드하는 간단 웹사이트
2. 로컬 PC에서 S3 업로드(AWS CLI, Python Boto3)
3. 공통 보안(퍼블릭 차단, 최소 권한, KMS 암호화, VPC 엔드포인트)
4. 프런트엔드 직업로드(Pre-signed URL/POST) 모범 예제
5. CORS/버킷 정책/수명주기/버전 관리
6. 대용량·고성능 업로드(멀티파트, 전송 가속)
7. 비용 모델과 점검 체크리스트

---

# EC2에서 S3로 업로드하는 웹사이트 만들기

## 사전 준비

| 항목 | 내용 |
|---|---|
| EC2 인스턴스 | Amazon Linux 2, 퍼블릭 도달 가능 |
| S3 버킷 | 예: `my-upload-demo-2025` (글로벌 고유) |
| IAM 역할(인스턴스 프로파일) | EC2에 연결, S3 PutObject 최소 권한 |
| Flask | 간단한 업로드 UI/엔드포인트 |
| Boto3 | AWS SDK for Python |

### 중요 원칙

- 실습을 제외하고 **퍼블릭 읽기 허용**은 지양한다. 안전한 접근은 **Pre-signed URL/POST** 를 사용한다.
- EC2가 프라이빗 서브넷이라면 **S3 VPC 엔드포인트**로 인터넷 없이 접근한다.

---

## IAM 역할: 최소 권한 정책 예시

실습 간소화를 위해 `AmazonS3FullAccess`를 붙이는 경우가 많지만, 운영에선 아래처럼 **버킷/접두사 제한 + 암호화 강제**가 기본이다.

```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Sid": "AllowPutOnlyToSpecificPrefixWithSSE",
    "Effect": "Allow",
    "Action": ["s3:PutObject", "s3:AbortMultipartUpload", "s3:ListBucketMultipartUploads", "s3:ListMultipartUploadParts"],
    "Resource": [
      "arn:aws:s3:::my-upload-demo-2025",
      "arn:aws:s3:::my-upload-demo-2025/uploads/*"
    ],
    "Condition": {
      "StringEquals": { "s3:x-amz-server-side-encryption": "aws:kms" }
    }
  }]
}
```

KMS 키 사용 시 역할에 `kms:Encrypt`, `kms:Decrypt` 등 필요한 권한도 부여한다.

---

## S3 버킷 생성 및 안전 설정

### 버킷 생성(CLI 예)

```bash
aws s3api create-bucket \
  --bucket my-upload-demo-2025 \
  --create-bucket-configuration LocationConstraint=ap-northeast-2 \
  --region ap-northeast-2
```

### 퍼블릭 차단(권장)

```bash
aws s3api put-public-access-block \
  --bucket my-upload-demo-2025 \
  --public-access-block-configuration \
  BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
```

### 버전 관리/기본 암호화

```bash
aws s3api put-bucket-versioning \
  --bucket my-upload-demo-2025 \
  --versioning-configuration Status=Enabled

aws s3api put-bucket-encryption \
  --bucket my-upload-demo-2025 \
  --server-side-encryption-configuration '{
    "Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"aws:kms"}}]}'
```

### 선택: CORS (브라우저 직업로드를 계획할 때)

```json
[
  {
    "AllowedOrigins": ["*"],
    "AllowedMethods": ["GET", "PUT", "POST"],
    "AllowedHeaders": ["*"],
    "ExposeHeaders": ["ETag"],
    "MaxAgeSeconds": 3000
  }
]
```
운영에서는 `AllowedOrigins` 를 특정 도메인으로 제한한다.

---

## EC2에 Python/Flask/Boto3 설치

```bash
sudo yum update -y
sudo yum install -y python3 git
pip3 install --upgrade pip
pip3 install flask boto3
```

---

## 업로드 서버 코드(학습용 최소 구현)

`app.py`:
```python
from flask import Flask, request, render_template_string
import boto3, os, mimetypes, uuid

app = Flask(__name__)
s3  = boto3.client('s3')
bucket = os.environ.get('BUCKET', 'my-upload-demo-2025')
prefix = os.environ.get('PREFIX', 'uploads/')

html = '''
<h2>S3 파일 업로드(EC2 경유)</h2>
<form method="POST" enctype="multipart/form-data">
  <input type="file" name="file"><br>
  <input type="submit" value="업로드">
</form>
'''

@app.route('/', methods=['GET', 'POST'])
def upload():
    if request.method == 'POST':
        file = request.files.get('file')
        if not file or file.filename == '':
            return '파일을 선택하세요', 400

        key = prefix + str(uuid.uuid4()) + '-' + file.filename
        ctype = mimetypes.guess_type(file.filename)[0] or 'application/octet-stream'

        s3.upload_fileobj(
            file, bucket, key,
            ExtraArgs={
                'ContentType': ctype,
                'ServerSideEncryption': 'aws:kms'    # SSE-KMS 강제
            }
        )
        return f'업로드 완료: s3://{bucket}/{key}'
    return render_template_string(html)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)
```

실행:
```bash
sudo -E BUCKET=my-upload-demo-2025 PREFIX=uploads/ python3 app.py
```

브라우저에서 `http://<EC2 퍼블릭 IP>` 접속 → 업로드 후 S3에서 확인.

> 운영 권고: 파일은 EC2를 거치지 않고 **브라우저 → S3 직업로드(Pre-signed URL/POST)** 로 전환하여 EC2의 대역폭/CPU 부담을 줄인다. 아래 4장 참조.

---

## 결과 확인

```bash
aws s3 ls s3://my-upload-demo-2025/uploads/
```

접속 URL(버킷 퍼블릭 허용이 아닌 경우 403이 정상이다. 접근은 Pre-signed URL로):
```
https://my-upload-demo-2025.s3.ap-northeast-2.amazonaws.com/uploads/<object>
```

---

## EC2 방식 정리

| 장점 | 단점 |
|---|---|
| 단순한 서버 코드로 빠르게 구현 | 트래픽이 EC2를 경유하여 비용/성능 손해 |
| IAM 역할로 키 관리 불필요 | 대용량 업로드 시 멀티파트 처리/큐잉 필요 |
| 서버 측 검증/후처리 용이 | 대역폭 증설/오토스케일 필요 |

---

# 로컬에서 S3로 직접 업로드

## AWS CLI

### 설치

```bash
# macOS

brew install awscli
# Ubuntu/Debian

sudo apt-get update && sudo apt-get install -y awscli
# Windows: 공식 인스톨러 사용

```

### 자격 증명 설정

```bash
aws configure
# AWS Access Key ID / Secret / region / output

```

### 단일 파일 업로드

```bash
aws s3 cp ./example.jpg s3://my-upload-demo-2025/uploads/
```

### 디렉터리 동기화

```bash
aws s3 sync ./site/ s3://my-upload-demo-2025/site/ --delete
```

### 메타데이터/암호화/ACL 예시

```bash
aws s3 cp ./report.pdf s3://my-upload-demo-2025/docs/report.pdf \
  --content-type application/pdf \
  --metadata project=alpha,owner=do-hyun \
  --sse aws:kms \
  --acl private
```

---

## Python Boto3

### 설치

```bash
pip install boto3 tqdm python-dotenv
```

### 단순 업로드

```python
import boto3
s3 = boto3.client('s3', region_name='ap-northeast-2')  # 프로파일/환경변수로 인증
s3.upload_file('example.jpg', 'my-upload-demo-2025', 'uploads/example.jpg',
               ExtraArgs={'ContentType':'image/jpeg','ServerSideEncryption':'aws:kms'})
print('업로드 완료')
```

### 멀티파트/진행률 표시

```python
import boto3, os, sys
from boto3.s3.transfer import TransferConfig
from tqdm import tqdm

bucket = 'my-upload-demo-2025'
key    = 'uploads/big.bin'
path   = '/path/to/big.bin'

config = TransferConfig(multipart_threshold=32*1024*1024, multipart_chunksize=16*1024*1024, max_concurrency=8)

s3 = boto3.client('s3')

size = os.path.getsize(path)
progress = tqdm(total=size, unit='B', unit_scale=True)

def cb(bytes_amount):
    progress.update(bytes_amount)

s3.upload_file(path, bucket, key, Callback=cb, Config=config,
               ExtraArgs={'ServerSideEncryption':'aws:kms'})
progress.close()
```

> 자격 증명은 **환경변수, 프로파일, IAM 역할** 등 안전한 경로로 주입한다. 코드에 키를 하드코딩하지 않는다.

---

# 공통 보안 설계

## 퍼블릭 차단과 버킷 정책

기본은 퍼블릭 차단이다. 다음과 같이 **TLS 미사용 요청 거부**, 특정 역할만 허용하는 정책을 추가할 수 있다.

```json
{
  "Version":"2012-10-17",
  "Statement":[
    {
      "Sid":"DenyInsecureTransport",
      "Effect":"Deny",
      "Principal":"*",
      "Action":"s3:*",
      "Resource":[
        "arn:aws:s3:::my-upload-demo-2025",
        "arn:aws:s3:::my-upload-demo-2025/*"
      ],
      "Condition":{"Bool":{"aws:SecureTransport":"false"}}
    }
  ]
}
```

## KMS 암호화

- 버킷 기본 암호화 또는 업로드 시 `--sse aws:kms`
- KMS 키 정책에 EC2 역할/사용자를 포함

## VPC 엔드포인트(S3 Gateway)

프라이빗 서브넷의 EC2가 NAT/인터넷 없이 S3에 접근하게 하여 보안/비용 개선.

---

# 브라우저 직업로드: Pre-signed URL/POST 모범 예제

EC2를 경유하지 않고 **클라이언트가 S3에 직접 업로드**하는 방식.

## 서버에서 Pre-signed URL 생성(Flask)

```python
import boto3, datetime
from flask import Flask, request, jsonify

app = Flask(__name__)
s3  = boto3.client('s3', region_name='ap-northeast-2')
bucket = 'my-upload-demo-2025'

@app.post('/presign')
def presign():
    key      = request.json['key']     # 예: uploads/uuid-filename.jpg
    ctype    = request.json.get('contentType', 'application/octet-stream')
    expires  = 900                     # 15분
    url = s3.generate_presigned_url(
        ClientMethod='put_object',
        Params={'Bucket':bucket,'Key':key,'ContentType':ctype,'ServerSideEncryption':'aws:kms'},
        ExpiresIn=expires,
        HttpMethod='PUT'
    )
    return jsonify({'url': url})
```

프런트엔드(JavaScript):
```javascript
async function upload(file) {
  const key = `uploads/${crypto.randomUUID()}-${file.name}`;
  const res = await fetch('/presign', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ key, contentType: file.type })
  });
  const { url } = await res.json();
  const put = await fetch(url, { method:'PUT', headers:{'Content-Type':file.type}, body: file });
  if (!put.ok) throw new Error('업로드 실패');
  return { key };
}
```

## Pre-signed POST (폼 업로드)

서버:
```python
resp = s3.generate_presigned_post(
  Bucket=bucket,
  Key='uploads/${filename}',
  Fields={'x-amz-server-side-encryption':'aws:kms'},
  Conditions[
    {"x-amz-server-side-encryption": "aws:kms"},
    ["starts-with", "$Content-Type", ""]
  ],
  ExpiresIn=900
)
```

클라이언트(HTML 폼):
```html
<form action="<resp['url']>" method="post" enctype="multipart/form-data">
  <!-- resp['fields']의 모든 키/값을 hidden으로 삽입 -->
  <input type="file"   name="file">
  <input type="submit" value="업로드">
</form>
```

장점: 대역폭 절약, 서버 부하 감소, 대용량 업로드 유리.

---

# CORS, 정적 배포, 접근 제어

## CORS 설정 예시(제한형)

```json
[
  {
    "AllowedOrigins": ["https://example.com"],
    "AllowedMethods": ["GET","PUT","POST"],
    "AllowedHeaders": ["Authorization","Content-Type","x-amz-date","x-amz-security-token","x-amz-user-agent","x-amz-content-sha256"],
    "ExposeHeaders": ["ETag"],
    "MaxAgeSeconds": 600
  }
]
```

## 정적 웹 호스팅

정적 웹은 S3 + CloudFront 조합이 일반적이다. 원본 접근은 **Origin Access Control(OAC)** 로 사설화한다.

---

# 대용량·고성능 업로드

## 멀티파트 업로드

- Boto3 Managed Transfer 또는 직접 `create_multipart_upload` → `upload_part` → `complete_multipart_upload`
- 중단 복구, 병렬 업로드, 네트워크 효율

## 전송 가속(Transfer Acceleration)

장거리 클라이언트 업로드 성능 개선:
```text
https://<bucket>.s3-accelerate.amazonaws.com/<key>
```
활성화 필요. 비용/효과를 검토.

## 간단 성능 모델

업로드 시간 근사:
$$
T_{\text{upload}} \approx \frac{S}{B_{\text{eff}}}
$$

- \(S\): 파일 크기
- \(B_{\text{eff}}\): 실효 업로드 대역폭
멀티파트 병렬화로 \(B_{\text{eff}}\) 를 끌어올릴 수 있다.

---

# 수명주기, 버전 관리, 백업

## 수명주기 정책 예

```json
{
  "Rules": [
    {
      "ID": "move-logs-to-glacier",
      "Prefix": "logs/",
      "Status": "Enabled",
      "Transitions": [{"Days": 30, "StorageClass": "GLACIER"}],
      "Expiration": {"Days": 365}
    }
  ]
}
```

## 버전 관리

- 우발적 덮어쓰기/삭제에 대한 안전망
- 비용 증가 가능 → 불필요 버전 수명주기 만료를 함께 설계

---

# 비용 모델과 거버넌스

## 단순 비용 근사

$$
C_{\text{월}} \approx C_{\text{저장}} + C_{\text{요청}} + C_{\text{전송}} + C_{\text{옵션}}
$$

- \(C_{\text{저장}}\): GB-월 단가 × 저장 용량
- \(C_{\text{요청}}\): PUT/GET 요청 수 × 요청 단가
- \(C_{\text{전송}}\): 인터넷 송출 GB × 단가
- \(C_{\text{옵션}}\): 전송 가속, KMS 요청 등

## 실무 가드레일

- 태그 표준(Project/Env/Owner/CostCenter), 예산/알람
- 퍼블릭 차단, 조건부 버킷 정책(HTTPS 강제, 프린시펄 제한)
- KMS 기본 암호화, 키 보안/회전
- 접근 경로: 프라이빗 → VPC 엔드포인트
- 로깅/감사: CloudTrail, S3 서버 액세스 로그 또는 CloudTrail Data Events

---

# 점검 체크리스트

- [ ] 버킷 퍼블릭 차단 활성
- [ ] 최소 권한 IAM(버킷/접두사 제한, SSE 강제)
- [ ] KMS 기본 암호화 및 키 권한 설정
- [ ] CORS 최소 허용 원칙
- [ ] EC2 경유 업로드는 학습/관리 전용, 사용자 파일은 Pre-signed 직업로드
- [ ] 멀티파트/전송 가속 필요성 검토
- [ ] 버전 관리/수명주기/삭제 보호
- [ ] 비용 모니터링 및 태깅

---

# 에지 케이스와 트러블슈팅

| 증상 | 원인 | 해결 |
|---|---|---|
| 403 Forbidden | 퍼블릭 차단, 권한 부족, 조건 불충족(SSE 등) | 버킷 정책/권한/조건 재검토, Pre-signed 사용 |
| 400 Bad Request (POST) | 폼 필드 누락, 정책 조건 불일치 | `generate_presigned_post` 로 받은 필드 그대로 사용 |
| 느린 업로드 | 장거리, 단일 스트림 | 멀티파트 병렬화, 전송 가속 |
| MIME 타입 오표기 | ContentType 미설정 | 업로드 시 ContentType 명시 |
| 덮어쓰기 사고 | 버전 관리 미사용 | 버전 관리 활성 + 수명주기 설계 |

---

# 서버리스 백엔드로 Pre-signed URL 발급(AWS Lambda)

`index.mjs`:
```javascript
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

const s3 = new S3Client({ region: "ap-northeast-2" });
const bucket = "my-upload-demo-2025";

export const handler = async (event) => {
  const body = JSON.parse(event.body || "{}");
  const key = body.key;
  const ctype = body.contentType || "application/octet-stream";

  const cmd = new PutObjectCommand({
    Bucket: bucket, Key: key, ContentType: ctype,
    ServerSideEncryption: "aws:kms"
  });

  const url = await getSignedUrl(s3, cmd, { expiresIn: 900 });
  return { statusCode: 200, body: JSON.stringify({ url }) };
};
```

API Gateway로 노출하여 웹/모바일이 호출한다.

---

# S3 URL 스타일

- 가상 호스트 스타일(권장)
  `https://<bucket>.s3.<region>.amazonaws.com/<key>`
- 경로 스타일은 단계적으로 지원 축소. 가급적 가상 호스트 스타일 사용.

---

# 요약

- EC2 경유 업로드는 학습·관리에는 단순하지만, 실무에선 **Pre-signed URL/POST** 로 브라우저 직업로드가 표준이다.
- **퍼블릭 차단, 최소 권한, KMS 암호화, VPC 엔드포인트** 로 보안을 기본값으로.
- **멀티파트/전송 가속** 으로 대용량 업로드를 안정화하고, **버전 관리·수명주기** 로 데이터 생애주기를 관리한다.
- 비용은 저장/요청/전송 항목으로 구성되며, 태깅과 알람으로 통제한다.
