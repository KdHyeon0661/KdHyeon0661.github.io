---
layout: post
title: MFC - 인쇄 & 프린트 프리뷰 파이프라인
date: 2025-08-26 19:25:23 +0900
category: MFC
---
# 인쇄 & 프린트 프리뷰 파이프라인

이 글은 MFC에서 **인쇄(Printing)**와 **프린트 프리뷰(Print Preview)**가 **어떤 순서로**, **어떤 객체/메서드가** 관여하며, **무엇을 어디서 구현해야 하는지**를 **실전 예제**와 함께 정리합니다.  
핵심 철학은 “**한 번 그리되, 대상만 바꾼다**”: 화면(`OnDraw`)과 인쇄/프리뷰(`OnPrint`)는 **동일한 레이아웃 로직**을 재사용하고, **좌표계/스케일/페이지 매김**만 분리합니다.

> 본문은 `~~~markdown` 블록, 코드는 모두 ```로 감쌉니다. 예제는 SDI 기준이지만 MDI도 동일한 훅과 흐름을 사용합니다.

---

## 0) 예제 프로젝트의 전제

- **App / Frame / View / Doc**: `CMyApp`, `CMainFrame`, `CMyView : CView`, `CMyDoc : CDocument`
- **인쇄 콘텐츠**: 
  - 텍스트 본문(워드랩 + 머리말/꼬리말)
  - 간단 도형/이미지(선/사각형/비트맵)
- **좌표 전략**: 인쇄/프리뷰에서 `MM_ANISOTROPIC` 매핑, 화면은 기본 `MM_TEXT`
- **페이지 매김**: `OnPreparePrinting`에서 **전체 페이지 테이블**을 계산→ `SetMinPage/SetMaxPage`
- **취소/진행률**: 간단 진행 상태 + `m_bContinuePrinting` 점검

---

## 1) 큰 그림: “한 번 그리되, 대상만 바꾼다”

- **그리기 타깃**
  - 화면: `CView::OnDraw(CDC* pDC)`  
  - 인쇄/프리뷰: `CView::OnPrint(CDC* pDC, CPrintInfo* pInfo)`
- **프레임워크가 해주는 일**
  - 명령 경로: `ID_FILE_PRINT`, `ID_FILE_PRINT_DIRECT`, `ID_FILE_PRINT_PREVIEW`
  - 프린터 DC/프리뷰 DC 준비, 페이지 범위/옵션 수집, 스풀러 전송, 프리뷰 UI 관리
- **우리가 할 일**
  - **페이지 매김**: 페이지 수/경계(라인 인덱스, 타일 분할 등)
  - **좌표/스케일링**: 프린터 DPI·여백·`m_rectDraw` 기반 맵핑
  - **페이지 렌더**: `OnPrint`에서 `m_nCurPage`별 실제 그리기

---

## 2) 명령 라우팅 & 표준 핸들 흐름

### 2-1. 명령 ID와 라우팅 규칙
- `ID_FILE_PRINT` : 일반 인쇄(대화상자 표시)
- `ID_FILE_PRINT_DIRECT` : 최근 설정/기본값으로 **즉시 인쇄**
- `ID_FILE_PRINT_PREVIEW` : 프리뷰 창 진입

라우팅: **Active View → Frame → Document → App** 순.  
일반적으로 **View**가 인쇄 파이프라인의 주도권을 갖고, **Document**는 데이터 공급자 역할을 담당합니다.

### 2-2. 인쇄 파이프라인 핵심 메서드
- `OnPreparePrinting(CPrintInfo* pInfo)`  
  - **총 페이지** 계산(`SetMinPage`, `SetMaxPage`)  
  - `DoPreparePrinting(pInfo)` 호출로 표준 대화상자를 띄우는 경로
- `OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo)`  
  - **공유 리소스**(폰트/브러시/펜/버퍼) 생성
- `OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)`  
  - **맵핑 모드/오리진/스케일** 설정(매 페이지 호출, 프리뷰 포함)
- `OnPrint(CDC* pDC, CPrintInfo* pInfo)`  
  - **현재 페이지 렌더**(`pInfo->m_nCurPage`)
- `OnEndPrinting(CDC* pDC, CPrintInfo* pInfo)`  
  - 리소스 해제/상태 복구

---

## 3) 데이터/레이아웃 모델 (뷰가 사용할 정보)

```cpp
// PrintLayout.h
#pragma once
#include <afx.h>
#include <vector>

struct LineLayout
{
    CString text;
    CRect   bounds;  // 논리 좌표(예: 1/100 mm 단위 등), 실제 DC에서 매핑
};

struct PageLayout
{
    int            pageNo = 1;
    std::vector<int> lineIndices; // 이 페이지가 포함하는 라인 인덱스 범위
    CRect          contentRect;   // 페이지 내 본문 논리 영역(여백 제외)
};

struct PrintMetrics
{
    // 논리 단위(예: 100DPMM: 1논리단위 = 0.01mm)
    int   dpmx = 1000; // 1000 = 0.0254 mm 기준이 아님, 예시. 아래 매핑에서 비율만 중요
    int   dpmy = 1000;

    int   marginLeft   = 2000; // 논리 단위
    int   marginTop    = 2000;
    int   marginRight  = 2000;
    int   marginBottom = 2000;

    int   headerHeight = 1200; // 머리말 높이
    int   footerHeight = 800;  // 꼬리말 높이

    int   lineSpacing  = 200;  // 줄 간격(논리)
    int   charHeight   = 400;  // 본문 글꼴 높이(논리)
};
```

---

## 4) View 클래스 뼈대: 인쇄 훅 구현

```cpp
// MyView.h
#pragma once
#include <afxwin.h>
#include "PrintLayout.h"

class CMyView : public CView
{
protected:
    DECLARE_DYNCREATE(CMyView)
    CMyView() noexcept {}

public:
    // 레이아웃/상태
    std::vector<CString> m_lines;     // 본문 라인(워드랩 후)
    std::vector<PageLayout> m_pages;  // 페이지 테이블
    PrintMetrics m_metrics;
    CFont   m_fontBody, m_fontHeader, m_fontFooter;

    // 화면 렌더
    virtual void OnDraw(CDC* pDC) override;

    // 인쇄 훅
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo) override;
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo) override;
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo) override;
    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = nullptr) override;
    virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo) override;

protected:
    // 내부 도우미
    void BuildLineListFromDoc(); // 문서 텍스트→워드랩→m_lines
    void BuildPageTable(CDC* pDC, CPrintInfo* pInfo); // m_pages 채우기
    void DrawPage(CDC* pDC, const PageLayout& pg, CPrintInfo* pInfo); // 한 페이지 렌더
    void CreatePrintFonts(CDC* pDC);
    void DeletePrintFonts();

    DECLARE_MESSAGE_MAP()
};
```

```cpp
// MyView.cpp (중요 부분만 발췌)
#include "pch.h"
#include "MyView.h"
#include "MyDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMyView, CView)

BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_COMMAND(ID_FILE_PRINT, &CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, &CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CView::OnFilePrintPreview)
END_MESSAGE_MAP()
```

---

## 5) 화면 그리기(OnDraw): 인쇄와의 로직 공유

> 원칙: **레이아웃 계산/텍스트 분할/표/도형 위치 결정**은 가능하면 **공통 함수**로 두고, 화면과 인쇄에서 **같은 논리 모델**을 사용합니다.

```cpp
void CMyView::OnDraw(CDC* pDC)
{
    auto* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    if (!pDoc) return;

    // 화면은 간단히 프리뷰 느낌으로 1페이지 일부를 스케치(또는 전체 스크롤 구현)
    // 여기서는 예시로 몇 줄만 그립니다.
    CFont font; LOGFONT lf{}; lf.lfHeight = -18; _tcscpy_s(lf.lfFaceName, _T("Malgun Gothic"));
    font.CreateFontIndirect(&lf);
    CFont* pOld = pDC->SelectObject(&font);

    int y = 10; 
    pDC->TextOut(10, y, _T("[화면 미리보기] 인쇄/프리뷰는 OnPrint에서 전체 페이지를 정확히 렌더합니다."));
    y += 24;

    pDC->TextOut(10, y, _T("문서 첫 줄 미리보기:"));
    y += 24;

    CString first = pDoc->GetFirstParagraph();
    pDC->TextOut(10, y, first);

    pDC->SelectObject(pOld);
}
```

---

## 6) 페이지 매김: OnPreparePrinting & BuildPageTable

### 6-1. OnPreparePrinting에서 페이지 수 계산

```cpp
BOOL CMyView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // 1) 표준 대화상자 흐름을 사용
    //    (DoPreparePrinting 안에서 OnBeginPrinting/OnEndPrinting 호출 전 pInfo 구성)
    //    여기서는 페이지 수를 계산하기 위해 사전 라인 목록을 준비
    BuildLineListFromDoc();

    // 2) 임시로 화면 DC를 사용하거나, 프린터 DC가 있다면 그것을 사용해 페이지 매김
    //    OnPrepareDC에서 바인딩하는 편이 정석이지만, 여기선 간단히 pInfo->m_rectDraw를 활용
    //    실제론 프린터 DC의 DPI를 기준으로 글꼴 메트릭을 얻어야 정확함.
    return DoPreparePrinting(pInfo); // 내부에서 SetMin/MaxPage를 세팅할 기회를 제공
}
```

> `DoPreparePrinting`은 내부적으로 `OnPreparePrinting` → 인쇄 대화상자 → `OnBeginPrinting` 순으로 이어지는 표준 경로를 구성합니다.  
> **실제 페이지 수 세팅**은 `OnBeginPrinting` 또는 `OnPreparePrinting` 내에서 수행해도 됩니다. 본 글에서는 **OnBeginPrinting에서 글꼴/메트릭을 확정**한 뒤 **BuildPageTable**을 호출해 페이지 수를 최종 결정합니다.

### 6-2. Document 텍스트 → 워드랩 → 라인 목록

```cpp
void CMyView::BuildLineListFromDoc()
{
    m_lines.clear();
    auto* pDoc = GetDocument();
    if (!pDoc) return;

    // 예시: 문서의 전체 텍스트를 단락으로 받아, 단순 워드랩 (실무는 GDI TextExtent로 정교하게)
    CString all = pDoc->GetAllText();

    // 간단 분리 (개행 기준). 실제 워드랩은 글꼴 메트릭과 폭을 기준으로 해야 함.
    int start = 0;
    while (true)
    {
        int pos = all.Find(_T('\n'), start);
        if (pos < 0) { m_lines.push_back(all.Mid(start)); break; }
        m_lines.push_back(all.Mid(start, pos - start));
        start = pos + 1;
    }
}
```

### 6-3. 폰트 생성 & 페이지 테이블 구성

```cpp
void CMyView::CreatePrintFonts(CDC* pDC)
{
    DeletePrintFonts();

    // 프린터 DPI → 포인트 기반 폰트 크기 변환
    // pt → px: px = pt * DPI / 72, GDI에선 lfHeight 음수=문자 높이 지정
    const int dpiY = pDC->GetDeviceCaps(LOGPIXELSY);

    LOGFONT lf{}; _tcscpy_s(lf.lfFaceName, _T("Malgun Gothic"));

    lf.lfHeight = -MulDiv(10, dpiY, 72); // 10pt 본문
    m_fontBody.CreateFontIndirect(&lf);

    lf.lfHeight = -MulDiv(12, dpiY, 72); // 12pt 머리말
    m_fontHeader.CreateFontIndirect(&lf);

    lf.lfHeight = -MulDiv(9, dpiY, 72); // 9pt 꼬리말
    m_fontFooter.CreateFontIndirect(&lf);
}

void CMyView::DeletePrintFonts()
{
    if (m_fontBody.GetSafeHandle())   m_fontBody.DeleteObject();
    if (m_fontHeader.GetSafeHandle()) m_fontHeader.DeleteObject();
    if (m_fontFooter.GetSafeHandle()) m_fontFooter.DeleteObject();
}

void CMyView::BuildPageTable(CDC* pDC, CPrintInfo* pInfo)
{
    m_pages.clear();

    // 1) 프레임워크가 계산한 그리기 가능 영역(디바이스 단위)
    CRect dev = pInfo->m_rectDraw;

    // 2) 논리 좌표로 사용할 가상의 "페이지 캔버스" 정의
    //    ANISOTROPIC 매핑에서 WindowExt(논리) ↔ ViewportExt(디바이스)를 연결
    //    여기선 논리 페이지를 A4 세로 기준으로 가정(예시)
    //    실제 mm→논리 변환은 일관되게만 유지하면 됨.
    CSize logicalPage(21000, 29700); // 210 x 297 mm를 100배 스케일한 논리값 예시

    // 3) 본문 영역 계산(머리말/꼬리말/여백 제외)
    CRect content( m_metrics.marginLeft,
                   m_metrics.marginTop + m_metrics.headerHeight,
                   logicalPage.cx - m_metrics.marginRight,
                   logicalPage.cy - m_metrics.marginBottom - m_metrics.footerHeight );

    // 4) 글꼴 메트릭으로 라인 높이 산정(정밀하려면 SelectObject 후 TEXTMETRIC 사용)
    CFont* pOld = pDC->SelectObject(&m_fontBody);
    TEXTMETRIC tm{}; pDC->GetTextMetrics(&tm);
    const int lineHeight = max(tm.tmHeight + tm.tmExternalLeading, m_metrics.lineSpacing);
    pDC->SelectObject(pOld);

    // 5) 한 페이지에 들어갈 라인 수
    const int linesPerPage = max(1, (content.Height() / lineHeight));

    // 6) 라인 인덱스를 페이지에 배치
    int totalLines = (int)m_lines.size();
    int cur = 0, pageNo = 1;
    while (cur < totalLines)
    {
        PageLayout pg{};
        pg.pageNo = pageNo++;
        pg.contentRect = content;
        for (int i = 0; i < linesPerPage && cur < totalLines; ++i)
        {
            pg.lineIndices.push_back(cur++);
        }
        m_pages.push_back(std::move(pg));
    }

    // 7) 페이지 범위 반영
    if (!m_pages.empty())
    {
        pInfo->SetMinPage(1);
        pInfo->SetMaxPage((short)m_pages.back().pageNo);
    }
    else
    {
        pInfo->SetMinPage(1);
        pInfo->SetMaxPage(1);
    }
}
```

---

## 7) OnBeginPrinting / OnEndPrinting

```cpp
void CMyView::OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo)
{
    // 프린터/프리뷰 DC가 준비된 시점: DPI/용지 유효
    // 1) 인쇄용 폰트/펜/브러시 생성
    CreatePrintFonts(pDC);

    // 2) 페이지 테이블 계산(글꼴 메트릭 반영)
    BuildPageTable(pDC, pInfo);
}

void CMyView::OnEndPrinting(CDC* pDC, CPrintInfo* pInfo)
{
    // 인쇄/프리뷰 종료: 리소스 해제
    DeletePrintFonts();
}
```

---

## 8) OnPrepareDC: 맵핑 모드/오리진/스케일

> **핵심**: `pInfo->m_rectDraw`(디바이스 좌표의 “안전 그릴 수 있는 영역”)을 **논리 페이지**에 매핑합니다.

```cpp
void CMyView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
    CView::OnPrepareDC(pDC, pInfo); // 기본 동작 유지(스크롤뷰 등)

    if (pInfo)
    {
        // 1) 프리뷰 여부 / 페이지 번호 얻기
        const bool bPreview = !!pInfo->m_bPreview;
        const int curPage = pInfo->m_nCurPage;

        // 2) 맵핑 모드
        pDC->SetMapMode(MM_ANISOTROPIC);

        // 3) 논리 페이지 크기와 디바이스 그리기 영역 연결
        CRect dev = pInfo->m_rectDraw; // 디바이스 단위
        CSize logicalPage(21000, 29700); // 논리 페이지(예: mm*100)

        pDC->SetWindowOrg(0, 0);
        pDC->SetWindowExt(logicalPage);
        pDC->SetViewportOrg(dev.left, dev.top);
        pDC->SetViewportExt(dev.Size()); // 프레임워크 계산 영역에 꽉 차도록

        // 참고: 필요하면 가로/세로 비율을 따로 조절하거나 여백 확보를 위해
        // dev를 조정할 수 있습니다.
    }
}
```

---

## 9) OnPrint: 실제 페이지 렌더

```cpp
void CMyView::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
    if (m_pages.empty()) return;
    const int cur = pInfo->m_nCurPage;
    const PageLayout* pg = nullptr;
    for (auto& p : m_pages) if (p.pageNo == cur) { pg = &p; break; }
    if (!pg) return;

    DrawPage(pDC, *pg, pInfo);
}

void CMyView::DrawPage(CDC* pDC, const PageLayout& pg, CPrintInfo* pInfo)
{
    // 1) 배경/테두리(선택)
    CPen pen(PS_SOLID, 10, RGB(200,200,200));
    CPen* oldPen = pDC->SelectObject(&pen);
    pDC->Rectangle(CRect(0, 0, 21000, 29700)); // 논리 페이지 외곽
    pDC->SelectObject(oldPen);

    // 2) 머리말/꼬리말
    CFont* old = pDC->SelectObject(&m_fontHeader);
    CString head; head.Format(_T("문서 제목 - 페이지 %d / %d"), pg.pageNo, (int)m_pages.size());
    pDC->TextOut(m_metrics.marginLeft, m_metrics.marginTop, head);
    pDC->SelectObject(old);

    old = pDC->SelectObject(&m_fontFooter);
    CString foot; foot.Format(_T("%s  %s"), _T("MyApp"), CTime::GetCurrentTime().Format(_T("%Y-%m-%d %H:%M")));
    pDC->TextOut(m_metrics.marginLeft, 29700 - m_metrics.marginBottom - m_metrics.footerHeight/2, foot);
    pDC->SelectObject(old);

    // 3) 본문 텍스트
    old = pDC->SelectObject(&m_fontBody);
    TEXTMETRIC tm{}; pDC->GetTextMetrics(&tm);
    const int lineHeight = max(tm.tmHeight + tm.tmExternalLeading, m_metrics.lineSpacing);

    int y = pg.contentRect.top;
    int x = pg.contentRect.left;

    for (int idx : pg.lineIndices)
    {
        if (idx >= 0 && idx < (int)m_lines.size())
        {
            pDC->TextOut(x, y, m_lines[idx]);
            y += lineHeight;
        }

        // 취소 체크: 오래 걸리는 경우 페이지 내에서도 중단 가능
        if (!pInfo->m_bContinuePrinting) break;
    }
    pDC->SelectObject(old);

    // 4) 도형/이미지 예시(본문 영역에 맞춰)
    CPen pen2(PS_SOLID, 0, RGB(100,150,230));
    CBrush brush2(RGB(220,235,255));
    CPen* oldPen2 = pDC->SelectObject(&pen2);
    CBrush* oldBr2 = pDC->SelectObject(&brush2);
    CRect box(pg.contentRect.left, pg.contentRect.bottom - 2000, pg.contentRect.left + 4000, pg.contentRect.bottom - 200);
    pDC->RoundRect(box, CPoint(300,300));
    pDC->SelectObject(oldPen2);
    pDC->SelectObject(oldBr2);
}
```

---

## 10) 프린트 프리뷰의 동작 방식 & 커스터마이징

- 프리뷰는 **실제 인쇄 파이프라인**(Begin/PrepareDC/Print/End)을 그대로 사용하되 DC가 `CPreviewDC`로 대체됩니다.
- 툴바(확대/축소, 1·2페이지 보기, 인쇄, 닫기)는 프레임워크가 제공합니다.
- **팁**: 프리뷰 전용 UI(예: “워터마크 미리보기”)는 `pInfo->m_bPreview`로 분기하여 추가 표시 가능.

```cpp
// 프리뷰 진입은 기본 핸들러로 충분
// BEGIN_MESSAGE_MAP에서 ID_FILE_PRINT_PREVIEW → CView::OnFilePrintPreview 연결됨
```

---

## 11) 프린트 대화상자 & Page Setup

- `OnPreparePrinting` → `DoPreparePrinting` 경로에서 **표준 인쇄 대화상자**가 열리고,  
  `pInfo->m_pPD->m_pd`( `PRINTDLG` )의 **DEVMODE**를 통해 용지/방향/트레이/양면 등 접근이 가능합니다.
- 별도의 **Page Setup** 대화상자를 두어 사용자 **여백/머리말/꼬리말**을 설정하고 `m_metrics`에 반영하면 UX 향상.

---

## 12) 좌표/스케일링 디테일 (실무 체크리스트)

- 프린터 **DPI**: `LOGPIXELSX/Y`  
- 인쇄 가능 영역: `HORZRES`×`VERTRES`  
- 물리 여백: `PHYSICALOFFSETX/Y`  
- **원칙**: `pInfo->m_rectDraw` 안에서 그리면 **안전**.  
- **맵핑 모드**: `MM_ANISOTROPIC`을 쓰고, **논리 페이지(예: mm기반)** ↔ **디바이스 영역**을 1:1로 맞춰 **프린터/프리뷰/화면 간 일관성**을 확보.  
- 폰트 크기: **pt → 픽셀 = pt * DPI / 72**, 인쇄 시 매번 **프린터 DPI**로 재산정.

---

## 13) 대용량/스풀러/성능

- 큰 비트맵을 다량 인쇄하면 **스풀 파일**이 급증.  
  → 이미지 **사전 다운스케일**(출력 해상도 기준), **필요 영역만 렌더**, 가능하면 **벡터** 사용
- 인쇄는 일반적으로 **동기**. 길어질 경우  
  - 진행 다이얼로그 + **취소** 버튼  
  - 각 페이지 렌더 루프에서 `pInfo->m_bContinuePrinting` 확인

```cpp
// 예: 간단 진행 UI와 연동
// 페이지 루프 바깥에서: pInfo->m_bContinuePrinting = TRUE;
// UI 스레드에서 취소 시: pInfo->m_bContinuePrinting = FALSE;
// OnPrint 내부에서 매 라인/섹션마다 검사
```

---

## 14) 에러 처리 & 복구

- 프린터 DC 획득 실패/오프라인/드라이버 오류 → `AfxMessageBox` 등으로 사용자 안내
- 페이지 렌더 중 예외 → 해당 페이지 건너뛰기/인쇄 중단 선택지 제공
- PDF 가상 프린터(“Microsoft Print to PDF”)로 **사전 검증** 권장

---

## 15) 다중 페이지/섹션/용지 전환

- 하나의 인쇄 작업(StartDoc~EndDoc) 중 **DEVMODE 변경은 보장되지 않음**.  
  → 페이지마다 용지/방향이 다르면, **섹션 단위로 나눈 개별 인쇄 작업**을 고려하거나 사용자 안내.
- **양면**: 드라이버 옵션 사용 + 홀/짝 페이지의 **내측/외측 여백** 분리 반영.

---

## 16) 흔한 문제와 해결 표

| 증상 | 원인 | 해결 |
|---|---|---|
| 프리뷰/인쇄 잘림 | 물리 여백 미고려, (0,0) 고정 | `m_rectDraw` 기준, `OnPrepareDC`에서 ViewportOrg를 `m_rectDraw.left/top`으로 |
| 화면-인쇄 크기 차이 | DPI 무시, 픽셀 고정 좌표 | `MM_ANISOTROPIC` + pt→픽셀 변환을 프린터 DPI로 |
| 페이지 수 틀림 | 워드랩/라인 높이 불정확 | `TEXTMETRIC` 기반 라인 높이, **사전 레이아웃 패스**로 `m_pages` 고정 |
| 스풀 폭증 | 고해상도 비트맵 대량 | 다운스케일/타일/필요 영역만 렌더 |
| 취소 불가 | 루프에서 플래그 미검사 | `m_bContinuePrinting`를 라인/섹션 루프마다 확인 |
| 폰트 대체/깨짐 | 프린터에 폰트 없음 | 장치 독립 폰트/내장 폰트 사용, 대체 전제 하 메트릭 보정 |
| 양면 여백 반대 | 내측/외측 고려 누락 | 홀/짝 페이지별 여백/오리진 분기 |

---

## 17) 전체 흐름(시퀀스 정리)

1. 사용자가 **인쇄/프리뷰 명령**(메뉴/툴바/단축키) → View가 라우팅 받음  
2. 프레임워크가 **프린터/프리뷰 DC** 준비 (+ 인쇄 대화상자)  
3. `OnPreparePrinting` : 본문 라인 목록 등 준비(워드랩)  
4. `OnBeginPrinting` : 프린터 DPI로 폰트 생성, **`BuildPageTable`**로 총 페이지 수 확정  
5. (페이지 루프)  
   - `OnPrepareDC` : **ANISOTROPIC 매핑**과 오리진/스케일 설정  
   - `OnPrint` : `m_nCurPage` 대상 **머리말/본문/꼬리말** 렌더  
   - (취소 플래그 주기적 확인)  
6. `OnEndPrinting` : 리소스 해제/상태 복구  
7. 프린트는 **스풀러 전송**, 프리뷰는 닫기 시 원래 뷰로 복귀

---

## 18) 확장: 표/이미지/워터마크/페이지 번호

### 18-1. 표 그리기(벡터 우선)

```cpp
void DrawTable(CDC* pDC, const CRect& rc, int rows, int cols)
{
    CPen pen(PS_SOLID, 0, RGB(0,0,0));
    CPen* old = pDC->SelectObject(&pen);

    // 외곽
    pDC->Rectangle(rc);

    const int cw = rc.Width() / cols;
    const int rh = rc.Height() / rows;

    for (int c=1; c<cols; ++c)
        pDC->MoveTo(rc.left + c*cw, rc.top), pDC->LineTo(rc.left + c*cw, rc.bottom);

    for (int r=1; r<rows; ++r)
        pDC->MoveTo(rc.left, rc.top + r*rh), pDC->LineTo(rc.right, rc.top + r*rh);

    pDC->SelectObject(old);
}
```

### 18-2. 이미지 인쇄(다운스케일)

```cpp
bool DrawBitmapFitted(CDC* pDC, const CRect& logicalBox, HBITMAP hBmp)
{
    if (!hBmp) return false;

    CDC memDC; memDC.CreateCompatibleDC(pDC);
    HBITMAP old = (HBITMAP)memDC.SelectObject(hBmp);

    BITMAP bm{}; ::GetObject(hBmp, sizeof(bm), &bm);
    // StretchBlt: HALFTONE 추천
    int oldMode = pDC->SetStretchBltMode(HALFTONE);
    pDC->StretchBlt(logicalBox.left, logicalBox.top, logicalBox.Width(), logicalBox.Height(),
                    &memDC, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
    pDC->SetStretchBltMode(oldMode);

    memDC.SelectObject(old);
    return true;
}
```

### 18-3. 워터마크(프리뷰와 인쇄 모두)

```cpp
void DrawWatermark(CDC* pDC, const CRect& page, const CString& text)
{
    int oldBk = pDC->SetBkMode(TRANSPARENT);
    int oldEsc = pDC->SetGraphicsMode(GM_ADVANCED);

    LOGFONT lf{}; lf.lfHeight = - (page.Height()/10);
    _tcscpy_s(lf.lfFaceName, _T("Arial"));
    CFont f; f.CreateFontIndirect(&lf);
    CFont* of = pDC->SelectObject(&f);

    // 회전
    XFORM xf{}; 
    double theta = -30.0 * 3.14159265 / 180.0;
    xf.eM11 = (FLOAT)cos(theta); xf.eM12 = (FLOAT)sin(theta);
    xf.eM21 = (FLOAT)-sin(theta); xf.eM22 = (FLOAT)cos(theta);
    xf.eDx = (FLOAT)((page.left + page.right)/2);
    xf.eDy = (FLOAT)((page.top + page.bottom)/2);
    pDC->SetWorldTransform(&xf);

    COLORREF oldText = pDC->SetTextColor(RGB(200,200,200));
    CSize sz = pDC->GetTextExtent(text);
    pDC->TextOut(-sz.cx/2, -sz.cy/2, text);

    pDC->SetTextColor(oldText);
    pDC->ModifyWorldTransform(nullptr, MWT_IDENTITY);
    pDC->SetGraphicsMode(oldEsc);
    pDC->SelectObject(of);
    pDC->SetBkMode(oldBk);
}
```

---

## 19) 취소 가능한 인쇄(진행 UI 연동 예시 스케치)

> 실제 앱에서는 모달 진행 대화상자를 띄우고 **취소 버튼**을 누르면 `m_bContinuePrinting = FALSE`로 바꿉니다.

```cpp
// OnPrint 내부 루프 중
for (int idx : pg.lineIndices)
{
    if (!pInfo->m_bContinuePrinting) break;
    // ... 라인 그리기 ...
}
```

---

## 20) 테스트 & 디버깅

- **프린터 없이 검증**: “Microsoft Print to PDF”로 출력 → 페이지 수/여백/폰트 스케일 확인
- **스풀러**: 큐 상태/EMF 크기/오류 모니터링
- **국제화**: CJK/RTL 줄바꿈, 폰트 대체 여부
- **대용량**: 100+ 페이지 스트레스, 취소 동작/메모리/GDI 객체 누수 점검

---

## 21) 구현 체크리스트(요약)

1. **명령 연결**: `ID_FILE_PRINT(_DIRECT/_PREVIEW)` 표준 핸들 사용  
2. **두 단계 그리기**: **레이아웃(사전 계산) → 렌더** 분리  
3. **페이지 테이블**: `OnBeginPrinting`에서 **총 페이지**를 확정  
4. **좌표계**: `MM_ANISOTROPIC` + `m_rectDraw` 매핑(오리진/스케일 일관화)  
5. **폰트/PT 변환**: 프린터 DPI 기준으로 재계산  
6. **취소 가능성**: 루프마다 `m_bContinuePrinting` 확인  
7. **이미지 최적화**: 다운스케일/할프트톤  
8. **프리뷰 분기**: `m_bPreview`로 UI/워터마크 등 추가 가능

---

## 22) 보너스: 페이지 범위 인쇄(선택 페이지만)

> 프린터 대화상자에서 사용자가 3–5페이지만 인쇄하도록 선택했다면, `pInfo->m_nCurPage`가 그 범위에 들어온 페이지만 호출됩니다.  
> 별도 커스터마이즈로 **사용자 필터**를 적용하려면 `OnPreparePrinting`에서 `pInfo->m_pPD->m_pd.nFromPage / nToPage`를 참고해 `SetMinPage/SetMaxPage`를 조정할 수 있습니다.

```cpp
BOOL CMyView::OnPreparePrinting(CPrintInfo* pInfo)
{
    BuildLineListFromDoc();
    BOOL ok = DoPreparePrinting(pInfo);
    if (!ok) return FALSE;

    // 예시: 사용자가 대화상자에서 범위를 입력했다면, 여기서 재조정 가능
    // 단, 일반적으로는 프레임워크가 그 범위를 사용하므로 별도 변경이 필요 없습니다.
    return TRUE;
}
```

---

## 23) 마무리

MFC의 인쇄·프리뷰 파이프라인은 **정해진 후크 지점**(Prepare/Begin/PrepareDC/Print/End)을 정확히 나눠 쓰면 **예측 가능하고 안정적**입니다.  
핵심은 **페이지 매김 테이블**과 **좌표계 표준화(MM_ANISOTROPIC + m_rectDraw 매핑)** 입니다. 이를 토대로 텍스트/표/도형/이미지/워터마크를 **일관된 품질**로 출력할 수 있습니다.  
위 예제 코드를 프로젝트에 맞게 확장해 **페이지 번호/머리말·꼬리말/양면 여백/섹션 인쇄/진행 취소**까지 차근차근 완성해 보세요.
