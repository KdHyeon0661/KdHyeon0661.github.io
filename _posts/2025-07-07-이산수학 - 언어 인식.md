---
layout: post
title: 이산수학 - 언어 인식
date: 2025-07-03 21:20:23 +0900
category: 이산수학
---
# 언어 인식 (Language Recognition)

## 한눈에 보는 언어 인식

- **문제**: 주어진 문자열 $$w$$가 언어 $$L$$(형식적 사양) 에 **속하는지 판별**
  $$w \in L\ \ ?$$
- **인식기(Recognizer)**: 언어별로 설계된 절차/오토마타/알고리즘이 입력 $$w$$를 **수용(Accept)** 또는 **거부(Reject)**

| 계층(Chomsky) | 전형 언어 | 전형 인식기 | 대표 알고리즘/사실 |
|---|---|---|---|
| 정규(Regular) | 정규식으로 기술 가능 | DFA/NFA/ε-NFA | DFA O(n), NFA 시뮬 O(n·m), DFA 최소화(Hopcroft) |
| 문맥자유(CFL) | 중첩 구조 | PDA(스택) | CYK O(n³), Earley O(n³)/평균 양호 |
| 문맥민감(CSL) | $$a^n b^n c^n$$ 등 | LBA(선형제한 TM) | 결정성 유지, 강력 |
| 재귀적(결정가능) | 항상 멈춰 판정 | 결정적 TM | 멤버십 결정 가능 |
| RE(반결정가능) | 멈추면 수용 | (비)결정 TM | 보완(Complement) 닫힘 아님 |

> **현업 파이프라인**: 정규식(DFA)로 **토큰화(렉싱)** → CFG(PDA/파서)로 **구문 분석(파싱)**.

---

## 정규 언어 인식 — DFA/NFA/ε-NFA/정규식

### DFA 형식 정의

- $$M=(Q,\Sigma,\delta,q_0,F)$$
- $$\delta:Q\times \Sigma \to Q,\ \ \delta^*(q,w)\ \text{은 확장 전이}$$
- 수용 조건: $$\delta^*(q_0,w)\in F$$

#### 예: 짝수 개의 `a`를 포함하는 언어

- 상태: 짝수( \(q_e\) ), 홀수( \(q_o\) )
- 전이:
  - `a`: \(q_e \leftrightarrow q_o\)
  - `b`: 자기루프
- 수용: \(q_e\)

```python
# 범용 DFA 시뮬레이터

def dfa_accepts(trans, start, finals, s):
    """
    trans: dict[state][symbol] = next_state
    start: start state
    finals: set of accepting states
    s: input string
    """
    q = start
    for ch in s:
        q = trans[q].get(ch, None)
        if q is None:
            return False
    return q in finals

# 짝수 a DFA

trans = {
    'qe': {'a':'qo','b':'qe'},
    'qo': {'a':'qe','b':'qo'},
}
print(dfa_accepts(trans, 'qe', {'qe'}, "aba"))   # True
print(dfa_accepts(trans, 'qe', {'qe'}, "abaa"))  # False
```

### NFA/ε-NFA와 부분집합 구성(SubSet Construction)

- **NFA**는 한 입력에 다수 전이/ε-무시.
- **등가성**: DFA ≡ NFA ≡ 정규식.
- **부분집합 구성**: NFA의 상태 부분집합을 **DFA의 상태**로 하여 결정화.

```python
# ε-NFA 시뮬레이터 (ε-폐포 + 이동)

from collections import defaultdict, deque

EPS = ''  # epsilon

def epsilon_closure(nfa, states):
    stack = list(states)
    closure = set(states)
    while stack:
        q = stack.pop()
        for nq in nfa[q].get(EPS, []):
            if nq not in closure:
                closure.add(nq)
                stack.append(nq)
    return closure

def move(nfa, states, sym):
    nxt = set()
    for q in states:
        for nq in nfa[q].get(sym, []):
            nxt.add(nq)
    return nxt

def nfa_accepts(nfa, start, finals, s, alphabet):
    cur = epsilon_closure(nfa, {start})
    for ch in s:
        if ch not in alphabet:
            return False
        cur = epsilon_closure(nfa, move(nfa, cur, ch))
    return len(cur & finals) > 0

# 예: 정규식 (a|b)*abb 의 Thompson-스타일 ε-NFA 일부(간단 시연용)
# 실제로는 Thompson 구성기를 만들어 주입하는 편이 일반적.

alphabet = {'a','b'}
nfa = defaultdict(lambda: defaultdict(list))
# 간단 시연: 상태 0 시작, a,b* 루프 후 abb 체킹 구조(교육용 축약)

nfa[0][EPS] = [1, 3]     # split for (a|b)* and to 'a'
nfa[1]['a'] = [1]; nfa[1]['b'] = [1]; nfa[1][EPS] = [2]  # (a|b)* then eps to 2
nfa[2]['a'] = [3]
nfa[3]['b'] = [4]
nfa[4]['b'] = [5]  # 5 accepting
start, finals = 0, {5}

print(nfa_accepts(nfa, start, finals, "abb", alphabet))      # True
print(nfa_accepts(nfa, start, finals, "aaabb", alphabet))    # True
print(nfa_accepts(nfa, start, finals, "ababa", alphabet))    # False
```

### 정규식 → NFA(Thompson), NFA → DFA(부분집합), DFA 최소화(Hopcroft)

- **Thompson**: 연결/합/클로저에 대한 **국소 구성**을 ε-NFA로 결합 → 선형 크기.
- **부분집합**: 상태 폭증 가능(최악 지수)이나, **실무의 많은 입력은 희소**.
- **Hopcroft 최소화**: $$O(|\Sigma| \cdot n \log n)$$

> 실전: 정규식 엔진은 **DFA 기반(선형 시간)** 또는 **백트래킹 NFA(경우에 따라 지수)**. 보안상 **Catastrophic backtracking** 회피 중요(아래 §8.3 참고).

---

## Myhill–Nerode 정리 & 최소 DFA

- **정리(핵심)**: 언어 $$L$$ 에 대해 **구별 불가능(equivalent)** 한 접미사 동치관계의 지수(동치류 수)가 **유한** ⇔ $$L$$ **정규**.
- **의의**: (1) 정규성 판정, (2) **최소 DFA 상태수 = 동치류 수**.

### DFA 최소화 알고리즘 개요(분할 정제)

1) 수용/비수용으로 분할
2) 같은 블록 내 상태들이 **동일하게 전이**하지 않으면 블록 분할
3) 분할이 안정화될 때까지 반복 → 각 블록이 **최소 DFA의 상태**

---

## 문맥자유 언어 인식 — PDA & 파싱(CYK/Earley)

### PDA 모델

- **스택** 보유 → 중첩 구조(`()` 중첩, `a^n b^n` 등) 인식 가능
- 수용: **최종 상태** 또는 **빈 스택** (표현에 따라 동치)

### CYK 알고리즘(Chomsky Normal Form)

- CNF: $$A \to BC$$ 또는 $$A \to a$$ (시작기호 예외 허용)
- **DP**로 길이 1→n 구간을 확장하며 가능한 비종결 기호 집합 계산
- 시간복잡도: $$O(n^3 \cdot |P|)$$

#### CYK 파이썬 구현(문자열 `w`가 CFG(CNF)로 유도 가능한지)

```python
from collections import defaultdict

def cyk_accepts(grammar, start, w):
    """
    grammar: dict like {
      'A': [('B','C'), ...],   # A->BC
      'B': [('a',), ('b',), ...]  # B->a
    }
    start: start symbol e.g. 'S'
    w: input string (list of terminals or str of chars)
    """
    if isinstance(w, str): w = list(w)
    n = len(w)
    if n == 0:
        # 빈문자열 허용 여부는 별도 처리(예: S->ε를 CNF특례로 허용했는지)
        return False
    # P[i][l]: i부터 길이 l인 구간을 생성 가능한 비단말 집합
    P = [[set() for _ in range(n+1)] for _ in range(n)]
    # 길이 1 초기화
    for i, a in enumerate(w):
        for A, rules in grammar.items():
            for rhs in rules:
                if len(rhs)==1 and rhs[0]==a:
                    P[i][1].add(A)
    # 길이 2..n
    for l in range(2, n+1):
        for i in range(n-l+1):
            for split in range(1, l):
                lefts = P[i][split]
                rights = P[i+split][l-split]
                if not lefts or not rights:
                    continue
                # A->BC 검사
                for A, rules in grammar.items():
                    for rhs in rules:
                        if len(rhs)==2:
                            B, C = rhs
                            if B in lefts and C in rights:
                                P[i][l].add(A)
    return start in P[0][n]

# 예: 균형괄호 CNF

G = {
  'S': [('S','S'), ('B',)],
  'B': [('(','C')],
  'C': [('S',')'), (')',)]  # 간단 예시(교육용), 실제 CNF 변환은 더 엄밀히 필요
}
print(cyk_accepts(G, 'S', "()()"))   # True (단, 위 예는 단순화된 CNF 스케치)
print(cyk_accepts(G, 'S', "(()"))    # False
```

> **실무 파싱**: LL(k)/LR(1) 계열(컴파일러), **Earley**(일반 CFG, 평균 양호), **GLR**(모호한 문법 처리) 등.

### DPDA vs NPDA

- **DPDA**(결정적 PDA)는 **모든 CFL**을 인식하지 못함(예: $$L=\{a^i b^j c^k \mid i=j \text{ or } j=k\}$$ 은 CFL이지만 DPDA 불가).
- **NPDA**는 **CFL 전체**를 커버.

---

## 문맥민감 언어 & LBA, 그리고 튜링기계

### LBA(Linear Bounded Automaton)

- 입력테이프 길이의 **선형 공간**만 사용 가능한 TM 변형
- **문맥민감 언어(CSL)** 인식, 결정성 유지.

#### 예: $$L=\{a^n b^n c^n \mid n\ge 0\}$$ (CFL 아님, CSL)

- LBA 스케치: 왼→오른쪽 스캔하며 `a`마다 매칭되지 않은 `b`,`c`를 **표시/소거**; 각 라운드 일치하면 계속, 끝나면 수용.

### 튜링 기계

- 재귀적(결정가능) 언어: **항상 멈추는** TM.
- RE(반결정가능) 언어: **수용 시 멈춤**, 거부 시 **비멈춤 가능**.

---

## 복잡도 & 결정문제 & 폐쇄성

### 멤버십 복잡도

- 정규: DFA O(n), NFA 시뮬 O(n·m) 정도(구현/전이 크기 의존)
- CFL: CYK O(n³), Earley 최악 O(n³), 그러나 **현업 문법은 빠름**
- CSL: 다항 공간 내 결정(PSPACE 상한)

### 전형 결정문제

| 문제 | 정규 | CFL |
|---|---|---|
| 공집합성(emptiness) | 결정가능 | 결정가능 |
| 유한성(finiteness) | 결정가능 | 결정가능 |
| 동치성(equivalence) | 결정가능 | 일반적으로 **결정불가** |
| 포함성(inclusion) | 결정가능 | 일반적으로 **결정불가** |
| 보편성(universality) | 결정가능 | 일반적으로 **결정불가** |

### 폐쇄성(Closure)

- **정규 언어**: 합, 교, 여, 차, 접두/접미, 동형사상 등 **풍부**
- **CFL**: 합/연결/클리니*, **교/여/차는 닫힘 아님**(교집합은 정규와의 교는 닫힘)

---

## — 비정규/비CFL 판정

- **정규 펌핑**: 충분히 긴 $$w=xyz$$ 로 분해, $$|xy|\le p, |y|>0, \forall i\ge 0: xy^iz \in L$$
- **CFL 펌핑(바루-힐)**: $$w=uvxyz, |vxy|\le p, |vy|>0, \forall i\ge 0: uv^i x y^i z \in L$$
- 용도: **반례**로 특정 언어가 정규/문맥자유 아님을 증명.

---

## 실전: 렉싱 & 파싱 파이프라인

1) **토큰화(정규식 → DFA)**: 키워드/식별자/리터럴/연산자 분리
2) **파싱(CFG)**: 문법 규칙에 맞는 구문 트리(AST) 생성
3) **의미분석/타입체킹**: AST 기반 정적 검사

> 정규식 엔진은 **DFA 기반**(선형, 안전) 또는 **백트래킹 NFA**. 보안상 URL/로그 패턴 등은 **DFA 또는 제한된 문법** 권장.

---

## 추가 실무 포인트

### 정규식의 안전성

- **Catastrophic backtracking** 방지: **고정-진행 패턴**, **수량자 겹침 회피**, **엔진에선 불변/ Possessive/ Atomic group 사용**.
- 큰 입력은 **컴파일된 DFA** 또는 **RE2 류(선형시간 엔진)** 활용.

### 오류 복구 파싱

- IDE/컴파일러: Earley/GLR, 또는 LL/LR에서 **에러 프로덕션/팬싱(panic)**으로 복원.

### 국제화/프로토콜

- 입력 알파벳(Σ) 정의 엄격: 유니코드 클래스/정규화(NFC) 고려, 프로토콜 상태기계는 DFA로 명세.

---

## 코드 모음 — 정규/CFG 인식 실습

### 범용 DFA 최소 예 (위 §1.1 확장 처리)

```python
def run_dfa(trans, start, finals, s):
    q = start
    for ch in s:
        if ch not in trans[q]:
            return False
        q = trans[q][ch]
    return q in finals

# 예: (a|b)*abb 인식 DFA를 직접 주면 선형 시간

dfa_trans = {
  0:{'a':1,'b':0},  # 접미 "abb"에 수렴하도록 설계된 DFA 예(요약)
  1:{'a':1,'b':2},
  2:{'a':1,'b':3},
  3:{'a':1,'b':0},
}
print(run_dfa(dfa_trans, 0, {3}, "aaabb"))  # True
```

### ε-NFA 시뮬 + 부분집합 구성으로 DFA 생성

```python
from collections import defaultdict, deque

EPS = ''  # epsilon

def eclosure(nfa, states):
    st = list(states)
    vis = set(states)
    while st:
        u = st.pop()
        for v in nfa[u].get(EPS, []):
            if v not in vis:
                vis.add(v); st.append(v)
    return frozenset(vis)

def nfa_to_dfa(nfa, start, finals, alphabet):
    start_cl = eclosure(nfa, {start})
    dfa_states = {start_cl: 0}
    dfa_trans = {}
    dfa_finals = set()
    qid = 1
    Q = deque([start_cl])
    while Q:
        S = Q.popleft()
        dfa_trans[dfa_states[S]] = {}
        for a in alphabet:
            T = set()
            for s in S:
                for v in nfa[s].get(a, []):
                    T |= eclosure(nfa, {v})
            T = frozenset(T)
            if not T:
                continue
            if T not in dfa_states:
                dfa_states[T] = qid; qid += 1; Q.append(T)
            dfa_trans[dfa_states[S]][a] = dfa_states[T]
        if any(s in finals for s in S):
            dfa_finals.add(dfa_states[S])
    return dfa_trans, 0, dfa_finals

# 앞서 만든 nfa를 DFA로 변환

alphabet = {'a','b'}
dfa_t, dfa_s, dfa_f = nfa_to_dfa(nfa, start, finals, alphabet)
print("DFA finals:", dfa_f)
print(run_dfa(dfa_t, dfa_s, dfa_f, "abb"))     # True
print(run_dfa(dfa_t, dfa_s, dfa_f, "ababa"))   # False
```

### CYK(§3.2)의 사용 예(정상 CNF 전제)

```python
# 간단 CNF 예시(문자열 'a^n b^n' 형태는 CNF 변환 후 CYK 가능)

G = {
  'S': [('A','B')],
  'A': [('A','A'), ('a',)],
  'B': [('B','B'), ('b',)],
}
# 위는 실제 a^n b^n을 정확히 생성하진 않는 단순 예시(교육 목적).
# 실제 a^n b^n의 CNF 변환은 도입규칙을 추가한 엄밀한 절차 필요.

print(cyk_accepts(G, 'S', "ab"))    # 예시 출력(문법에 따라 다름)
print(cyk_accepts(G, 'S', "aab"))   # 예시 출력
```

> **주의**: CYK는 **정확한 CNF 변환**이 중요. 실무에서는 **Earley/GLR** 등 **문법 그대로** 처리 가능한 파서를 선호.

---

## 요약 & 체크리스트

- **정규 언어**: DFA/NFA/정규식 동치. **DFA 선형시간**, NFA는 ε-폐포 시뮬, **DFA 최소화**로 최적 상태.
- **CFL**: PDA/파서로 인식. **CYK/Earley**로 보편 인식, 시간은 다항(최악 n³).
- **CSL/LBA**: $$a^n b^n c^n$$ 등 더 강한 제약 인식.
- **TM**: (반)결정가능 언어까지 포괄.
- **결정문제**: 정규는 풍부히 결정가능, CFL은 포함/동치/보편성 등 다수 **결정불가**.
- **폐쇄성**: 정규는 강력, CFL은 합/연결/⋆는 닫힘이나 교/여/차는 일반적으로 아님.
- **실전**: 정규식(렉서) + CFG(파서). **안전한 정규식 엔진**(선형시간) 사용 권장.

---

## 연습문제

1) 언어 $$L=\{ w\in\{0,1\}^* \mid w \text{에 }1\text{의 개수가 3의 배수}\}$$ 에 대한 **최소 DFA**를 설계하고, 코드로 시뮬레이터를 작성하라.
2) 정규식 `(ab|a)*b` 를 Thompson으로 ε-NFA를 구성하고, 부분집합 구성으로 DFA를 생성해 **커버리지 테스트**를 수행하라.
3) 균형괄호 언어에 대해 CNF로 변환한 뒤 **CYK로 멤버십**을 판정하라(샘플 10개).
4) $$L=\{a^n b^n c^n\}$$ 가 **CFL 아님**을 펌핑 보조정리(바루–힐) 아이디어로 스케치하라.
5) 정규식 보안: 이메일 로그 패턴에서 **카타스트로픽 백트래킹을 유발하는 패턴**을 제시하고, **DFA 기반 대체**를 설계하라.
