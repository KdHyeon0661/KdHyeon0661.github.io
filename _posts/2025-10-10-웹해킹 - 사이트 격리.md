---
layout: post
title: 웹해킹 - 사이트 격리
date: 2025-10-10 22:25:23 +0900
category: 웹해킹
---
# 26. COOP/COEP/CORP로 **사이트 격리(Site Isolation)**  
**— 개념·효과 · WebAssembly/SharedArrayBuffer 사용 조건(크로스 오리진 고립) · 실제 적용 단계(서버/프런트) · 스택별 설정 예제(Express/Spring/Nginx/CloudFront/Workers) · 깨지기 쉬운 지점(3rd-party/iframe/폰트/이미지) · 디버깅 & 롤아웃 체크리스트**

## 0. 한눈에 보기 (Executive Summary)

- **COOP (Cross-Origin-Opener-Policy)**  
  현재 문서를 **다른 오리진 문서와 ‘opener’ 연결**로부터 격리.  
  **권장값**: `same-origin` (또는 단계 도입 시 `same-origin-allow-popups`)  
  → `window.opener` 단절, 독립 프로세스 → **XS-Leaks 표면 축소**.

- **COEP (Cross-Origin-Embedder-Policy)**  
  이 문서가 **임베드(로드)하는** 모든 크로스 오리진 리소스가 **안전하게 공유 가능**해야 함을 요구.  
  **옵션**:  
  - `require-corp` : 임베드되는 리소스가 **CORS 허용** 또는 **CORP 헤더**를 제공해야 통과  
  - `credentialless` : **자격증명 없이**(쿠키 미포함) 가져오는 크로스 오리진 응답은 임베드 허용 (브라우저 지원/행동 차이 고려)

- **CORP (Cross-Origin-Resource-Policy)**  
  **리소스 제공자**가 그 리소스를 **누가 임베드할 수 있는지**를 지정.  
  값: `same-origin` / `same-site` / `cross-origin`  
  → **COEP의 ‘회사(사이트) 경계선’을 협조적으로 맞추는 스위치**.

- **크로스 오리진 고립(crossOriginIsolated)**  
  `COOP: same-origin` **+** `COEP: require-corp(또는 credentialless)` 을 충족하면  
  `window.crossOriginIsolated === true` → **SharedArrayBuffer/Atomics** 등 사용 가능.

---

## 1. 왜 ‘사이트 격리’가 필요한가?

1) **XS-Leaks 완화**  
   - opener 체인이 있으면, 링크로 연 문서/팝업이 **간접적으로 상태 누출**에 악용될 수 있음.  
   - COOP는 이런 ‘문서 간 문맥 공유’를 끊어 **타이밍/리다이렉션 기반 추론** 난이도를 올립니다.

2) **성능/기능 (WASM, SAB)**  
   - **SharedArrayBuffer**(고성능 병렬 처리), 일부 **WASM** 기능은 **교차 오리진 고립**을 요구.  
   - 대규모 이미지/비디오 처리, 과학 연산, 게임/엔진 포팅에서 필수.

---

## 2. 동작 모델 (요약 다이어그램)

```
[ 문서 A (origin: a.com) ]
  | COOP: same-origin           ---> (opener 단절, 별도 browsing context group)
  | COEP: require-corp          ---> (임베드 리소스가 CORS or CORP 요건 충족)
  |-----------------------------|--> crossOriginIsolated = true  (충족 시)
```

- **COOP**: 윈도 간 연결(opener/`window.open`)을 **동일 오리진끼리만** 유지.  
- **COEP**: 나(문서)가 임베드하는 **다른 오리진의 자원**은 **CORS 허용**이나 **CORP**를 요구.  
- **CORP**: 리소스 **제공자**가 임베드 허용 범위를 **명시** → COEP 요구를 **만족**시키는 방법.

---

## 3. 기본 헤더 설정 (권장 스니펫)

### 3.1 페이지(문서) 응답 헤더  
```http
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
```

→ 이 문서가 로드하는 **모든 크로스 오리진 리소스**(JS, WASM, 이미지, 워커 등)는  
**CORS 허용** 또는 **CORP 헤더**가 있어야만 로드 성공.

> 단계적 도입 시:  
> `COOP: same-origin-allow-popups` (팝업 호환성 ↑, opener는 여전히 제한)  
> `COEP: credentialless` (3rd-party 이미지/폰트 등 **자격증명 없이** 로드 허용 — 브라우저/사용처 테스트 필수)

### 3.2 리소스(정적 파일, 이미지, 폰트, 스크립트 등) 응답 헤더  
```http
# 동일 오리진 외 사용을 허용하지 않으려면:
Cross-Origin-Resource-Policy: same-origin

# 같은 사이트(서브도메인 포함)까지 허용하려면:
Cross-Origin-Resource-Policy: same-site

# 누구나 임베드 가능하게 하려면(정말 그럴 때만):
Cross-Origin-Resource-Policy: cross-origin

# CORS로도 허용하고 싶다면(예: 폰트/이미지/JS):
Access-Control-Allow-Origin: https://app.example.com
# 또는 여러 오리진이면 Vary 처리 + 동적 허용
```

> **COEP를 만족시키려면**:  
> - 리소스가 **CORS 허용(응답의 ACAO)** 이거나,  
> - **CORP 헤더**를 보내야 함.  
> **둘 중 하나**로 문서의 COEP 요구를 만족시킬 수 있습니다.

---

## 4. 스택별 설정 예

### 4.1 Node/Express (문서 + 정적자원)
```js
// app.js
import express from 'express';
const app = express();

// (A) 문서 응답에 COOP/COEP
app.use((req, res, next) => {
  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');
  res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');
  next();
});

// (B) 정적 리소스에 CORP (우리 오리진 전용)
app.use('/static', (req, res, next) => {
  res.setHeader('Cross-Origin-Resource-Policy', 'same-origin');
  next();
}, express.static('public', { immutable: true, maxAge: '1y' }));

app.get('/', (_req, res) => {
  res.send(`
    <!doctype html>
    <meta charset="utf-8">
    <title>COOP/COEP Demo</title>
    <script>
      // 런타임에서 확인
      console.log('crossOriginIsolated?', window.crossOriginIsolated);
      if (!window.crossOriginIsolated) {
        document.body.innerHTML = '<h3>⚠️ crossOriginIsolated=false</h3>' +
          '<p>3rd-party 리소스 중 COEP 요건 미충족이 있을 수 있습니다.</p>';
      }
    </script>
  `);
});

app.listen(8080, () => console.log('http://localhost:8080'));
```

### 4.2 Nginx (문서/자원 분리)
```nginx
server {
  listen 443 ssl;
  server_name app.example.com;

  # 문서(HTML) 응답에 COOP/COEP
  location / {
    add_header Cross-Origin-Opener-Policy "same-origin" always;
    add_header Cross-Origin-Embedder-Policy "require-corp" always;
    try_files $uri /index.html;
  }

  # 정적 리소스: 기본 same-origin (필요에 따라 same-site/cross-origin)
  location /assets/ {
    add_header Cross-Origin-Resource-Policy "same-origin" always;
    add_header Cache-Control "public, max-age=31536000, immutable";
    try_files $uri =404;
  }

  # 폰트는 CORS로 특정 오리진 허용(예시)
  location /fonts/ {
    add_header Cross-Origin-Resource-Policy "same-origin" always;
    add_header Access-Control-Allow-Origin "https://app.example.com" always;
    add_header Cache-Control "public, max-age=31536000, immutable";
  }
}
```

### 4.3 Spring (필터)
```java
@Component
public class IsolationHeadersFilter extends OncePerRequestFilter {
  @Override
  protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
      throws ServletException, IOException {
    res.setHeader("Cross-Origin-Opener-Policy", "same-origin");
    res.setHeader("Cross-Origin-Embedder-Policy", "require-corp");
    chain.doFilter(req, res);
  }
}

// 정적 자원 서빙 컨트롤러/필터에서:
// res.setHeader("Cross-Origin-Resource-Policy", "same-origin");
```

### 4.4 CloudFront (응답 헤더 정책)
- **Response Headers Policy**로 `COOP/COEP/CORP` 추가.  
- 정적 경로별(예: `/assets/*`) 정책 차등 적용.

### 4.5 Cloudflare Workers (엣지에서 헤더 주입)
```js
export default {
  async fetch(req, env, ctx) {
    const res = await fetch(req);
    // 문서 응답이면 COOP/COEP 주입 (콘텐츠타입 검사)
    const newHeaders = new Headers(res.headers);
    if ((newHeaders.get('content-type') || '').includes('text/html')) {
      newHeaders.set('Cross-Origin-Opener-Policy', 'same-origin');
      newHeaders.set('Cross-Origin-Embedder-Policy', 'require-corp');
    }
    // 리소스 경로 정책
    const url = new URL(req.url);
    if (url.pathname.startsWith('/assets/')) {
      newHeaders.set('Cross-Origin-Resource-Policy', 'same-origin');
    }
    return new Response(res.body, { status: res.status, headers: newHeaders });
  }
}
```

---

## 5. SharedArrayBuffer/WASM 사용 예 (고립이 되었는지 확인)

### 5.1 런타임 체크
```html
<script>
  if (window.crossOriginIsolated) {
    // SharedArrayBuffer 사용 가능
    const sab = new SharedArrayBuffer(1024);
    const view = new Int32Array(sab);
    // ... Worker와 Atomics로 병렬 처리
  } else {
    console.warn('Not cross-origin isolated: fallback path');
  }
</script>
```

### 5.2 Worker와 병렬 처리(개념 예시)
```js
// main.js
if (crossOriginIsolated) {
  const sab = new SharedArrayBuffer(4 * 1024);
  const arr = new Int32Array(sab);
  const worker = new Worker('/assets/worker.js', { type: 'module' });
  worker.postMessage({ sab });
  // Atomics를 사용한 동기화/신호 등...
}
```

```js
// /assets/worker.js
self.onmessage = ({ data }) => {
  const arr = new Int32Array(data.sab);
  // 연산 후 특정 인덱스에 결과 저장
  arr[0] = 42;
  // 필요 시 Atomics.notify 등 사용
};
```

> **주의**: 실제로는 **COOP/COEP가 모두 충족**되어야 `crossOriginIsolated=true`.  
> 하나라도 누락되면 SharedArrayBuffer는 **사용 불가**입니다.

---

## 6. `COEP: credentialless` vs `require-corp`

- `require-corp`  
  - **임베드되는 리소스가 스스로** `Cross-Origin-Resource-Policy`(혹은 CORS 허용)를 제공해야 함.  
  - **서드파티 리소스 공급자의 협조**가 필요(대신 모델이 명확).

- `credentialless`  
  - **자격증명(쿠키 등)을 제거**한 **no-credentials fetch**로 가져오는 외부 리소스를 허용.  
  - 제3자(이미지·폰트 등)에 협조를 덜 요구할 수 있으나,  
  - **브라우저별 지원/세부 동작** 차이가 있을 수 있고, **인증 필요한 리소스**는 로드 불가.  
  - **점진 도입/테스트 환경**에서 활용 → 핵심 경로엔 `require-corp` 권장.

---

## 7. 흔히 깨지는 지점 & 해결법

1) **3rd-party 스크립트/위젯**  
   - COEP 도입 시 **아무 응답 헤더 없이 주는 외부 스크립트**는 **차단**됩니다.  
   - 해결: 공급자가 JS에 **CORS 헤더** 혹은 **CORP: cross-origin**을 보내도록 요청.  
   - 대안: **서버-사이드 프록시**로 **same-origin** 제공(보안 검토 필수, 무결성/SRI 등 병행).

2) **이미지/폰트**  
   - 폰트는 **CORS 규칙**이 엄격. 외부 폰트는 `Access-Control-Allow-Origin` 필요.  
   - 이미지/비디오도 응답 헤더 요건 불충족 시 차단 → **자체 호스팅**이 가장 안정.

3) **iframe 임베드**  
   - 교차 오리진 `iframe`이 내부에서 스크립트/폰트를 다시 불러오면 **그 내부 문서도 COEP 요건**을 충족해야 사용할 수 있는 기능이 있음.  
   - 불가피한 임베드라면 **기능 분리**(해당 프레임에 SAB/WASM 불필요) 또는 공급자와 협의.

4) **OAuth / 결제 리다이렉션**  
   - COOP로 **opener 단절**이 생기면 일부 **리다이렉션 흐름**에 영향.  
   - 팝업을 사용하는 플로우는 `same-origin-allow-popups`로 완화하거나, **리디자인**.

5) **Service Worker**  
   - COEP 환경과 SW의 **자원 페치 정책** 충돌 검토.  
   - 캐시에 들어 있는 외부 자원도 **요건 미충족 시 차단** → **캐시 초기화** 전략 필요.

---

## 8. 배포/캐시 고려

- **HTML은 정책의 ‘근원’** → CDN 캐시/엣지 경로에서 **항상 COOP/COEP 헤더 보존**.  
- 동적 경로/HTML 변형(압축/리라이트) 시 헤더 유실 주의.  
- 정적 자원에선 경로별로 **CORP/CORS**를 일관되게 부여.  
- **정적 분석/테스트**로 “COEP가 켜진 문서가 불러오는 모든 자원은 규칙을 만족하는가”를 자동 점검.

---

## 9. 디버깅 방법

1) **DevTools → 네트워크 탭**  
   - 차단 원인이 **COEP/CORP** 때문이면 **콘솔 경고/에러** 메시지가 나타남.  
   - 응답 헤더에 `CORP`/`ACAO`(CORS)가 있는지 확인.

2) **런타임 플래그**  
   ```js
   console.log(window.crossOriginIsolated); // true/false
   ```

3) **진단 스크립트(간단)**
   ```js
   async function probe(url) {
     try {
       const r = await fetch(url, { mode: 'cors', credentials: 'include' });
       console.log(url, r.status, r.headers.get('cross-origin-resource-policy'), r.headers.get('access-control-allow-origin'));
     } catch (e) { console.warn(url, 'failed', e); }
   }
   probe('https://third.party/lib.js');
   ```

---

## 10. 롤아웃 전략 (권장 단계)

1) **인벤토리**: 페이지가 로드하는 **모든 외부 리소스** 목록(스크립트/이미지/폰트/워커/WASM).  
2) **무중단 시험**: 스테이징에서 **COOP/COEP** 켜고 **문제 리소스** 식별(콘솔/네트워크 에러 수집).  
3) **리소스 정리**:  
   - 외부 의존은 **가급적 자체 호스팅**으로 전환,  
   - 불가 시 공급자에 **CORS 또는 CORP** 요청.  
4) **부분 적용**: 특정 경로/서브도메인에서 먼저 적용(예: `wasm.example.com`).  
5) **전면 적용**: 핵심 앱 도메인 적용 후 모니터링(에러율/성능/리포트).  
6) **SAB/WASM 기능 활성**: `crossOriginIsolated` 확인 후 기능 게이트 오픈.

---

## 11. “막혀야 정상” 테스트 (자동 체크 예)

### 11.1 문서 헤더 존재 검사
```bash
curl -si https://app.example.com/ | egrep "Cross-Origin-Opener-Policy|Cross-Origin-Embedder-Policy"
# 둘 다 보여야 pass
```

### 11.2 외부 리소스 적합성 검사 (간단)
```bash
for u in $(cat external-assets.txt); do
  curl -si "$u" | egrep "Cross-Origin-Resource-Policy|Access-Control-Allow-Origin" || \
    echo "⚠️ header missing: $u"
done
```

### 11.3 런타임 E2E
- 브라우저 테스트에서 `expect(await page.evaluate(() => crossOriginIsolated)).toBe(true)`  
- 차단 이벤트/콘솔 에러 캡처를 **알람**으로 승격.

---

## 12. 보안 보조 수단과의 관계

- **CSP**: 스크립트/커넥트/프레임 **출처 허용 범위**를 통제 → COOP/COEP와 **상호 보완**.  
- **SRI**: 외부 리소스 **무결성** 보장 → COEP로 **임베드 정책**, SRI로 **내용 변조**를 동시 방어.  
- **Fetch Metadata 헤더**(`Sec-Fetch-Site` 등): 서버에서 **교차 출처 요청** 거부 정책 강화.  
- **ORB(구 CORB)**: 교차 오리진 **민감 MIME** 차단 → COEP와 함께 **정보 노출 경감**.

---

## 13. 체크리스트

- [ ] 문서에 `COOP: same-origin`, `COEP: require-corp`(또는 `credentialless`)  
- [ ] 모든 외부 자원에 **CORS 허용** 또는 **CORP** 부여(또는 자체 호스팅)  
- [ ] 런타임 `crossOriginIsolated === true` 확인  
- [ ] 폰트/이미지/워커/WASM **특별 케이스** 점검  
- [ ] OAuth/결제 등 **팝업/리다이렉션 플로우** 영향 검토  
- [ ] 캐시/엣지에서 **헤더 유실 방지**  
- [ ] 자동화된 **검사/모니터링**(콘솔 에러/네트워크 실패 수집)  
- [ ] 문서화: 3rd-party 공급자 **헤더 요건** 가이드 공유

---

## 14. 미니 FAQ

- **Q. COOP만 켜면 SAB 쓸 수 있나요?**  
  A. 아니요. **COOP + COEP** 조합이 충족되어야 `crossOriginIsolated=true`.

- **Q. COEP를 켜면 외부 이미지도 다 막히나요?**  
  A. 외부 리소스가 **CORS 허용** 또는 **CORP**를 보내면 로드됩니다. 그렇지 않으면 **차단**.

- **Q. `credentialless`로 충분하지 않나요?**  
  A. 환경/브라우저별 차이가 있고 **자격증명 필요한 리소스**는 불가합니다.  
     핵심 경로엔 `require-corp`가 더 예측 가능.

- **Q. 3rd-party 스크립트를 꼭 써야 한다면?**  
  A. 공급자가 **CORS/ CORP**를 제공하도록 요청하거나, **자체 호스팅**으로 전환(라이선스/업데이트 전략 포함).

---

## 15. “복붙” 스타터(Express + Nginx)

### Express
```js
app.use((req, res, next) => {
  res.set('Cross-Origin-Opener-Policy', 'same-origin');
  res.set('Cross-Origin-Embedder-Policy', 'require-corp');
  next();
});
app.use('/assets', (req, res, next) => {
  res.set('Cross-Origin-Resource-Policy', 'same-origin');
  next();
}, express.static('dist/assets'));
```

### Nginx
```nginx
location / {
  add_header Cross-Origin-Opener-Policy "same-origin" always;
  add_header Cross-Origin-Embedder-Policy "require-corp" always;
  try_files $uri /index.html;
}
location /assets/ {
  add_header Cross-Origin-Resource-Policy "same-origin" always;
  try_files $uri =404;
}
```

---

### 마무리
**COOP/COEP/CORP**는 “**문서 경계**”와 “**리소스 경계**”를 명확히 하여,  
**XS-Leaks**를 줄이고 **고성능 기능(SAB/WASM)** 을 **안전한 조건**에서 사용하게 해줍니다.  
핵심은 **문서에 COOP/COEP**, **리소스에 CORP/CORS**, **런타임 검증(crossOriginIsolated)**,  
그리고 **3rd-party 리소스의 헤더 정렬**입니다.