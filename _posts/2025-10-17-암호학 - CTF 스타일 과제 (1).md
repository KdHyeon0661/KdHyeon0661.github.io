---
layout: post
title: ì•”í˜¸í•™ - CTF ìŠ¤íƒ€ì¼ ê³¼ì œ (1)
date: 2025-10-17 18:30:23 +0900
category: ì•”í˜¸í•™
---
# 19. ì‹¤ìŠµ ë© & CTF ìŠ¤íƒ€ì¼ ê³¼ì œ (1)
## ëŒ€ì¹­í‚¤ ì‹¤ìŠµ: AES-GCM íŒŒì¼ ì•”ë³µí˜¸, **Nonce ì˜¤ìš©** ì‹¤í—˜ (ğŸ”°â†’âš™ï¸â†’ğŸš¨)

> ëª©í‘œ
> 1) **ì•ˆì „í•œ íŒŒì¼ ì•”ë³µí˜¸ í¬ë§·**(í—¤ë”Â·ë´‰íˆ¬ ì•”í˜¸í™”Â·AEAD AAD)ì„ ì§ì ‘ ì„¤ê³„/êµ¬í˜„í•œë‹¤.  
> 2) **Nonce(=IV) ì¬ì‚¬ìš©**ì˜ ìœ„í—˜ì„ **ì½”ë“œì™€ ë°ì´í„°**ë¡œ í™•ì¸í•œë‹¤(í‰ë¬¸ ëˆ„ì„¤/XOR ê´€ê³„, ìœ„Â·ë³€ì¡° ì‹¤íŒ¨/ì„±ê³µ íŒ¨í„´).  
> 3) **ìš´ì˜ ê´€ì **ì—ì„œ ì•ˆì „í•œ Nonce ì •ì±…(ì „ì—­ ê³ ìœ ì„±, prefix+counter, ì¶©ëŒ ê°ì§€)ì„ êµ¬í˜„í•œë‹¤.

---

## 0. ì¤€ë¹„ë¬¼
- Python 3.10+ (ì¶”ê°€ íŒ¨í‚¤ì§€ ì—†ì´ ê°€ëŠ¥, ì„ íƒìœ¼ë¡œ `cryptography` ê¶Œì¥)
- ì„ íƒ: Go(1.21+)/Rust(1.77+) ëŒ€ì²´ ìŠ¤ë‹ˆí« í¬í•¨
- ì‹¤ìŠµ ë°ì´í„°: ì‘ì€ í…ìŠ¤íŠ¸/ì´ë¯¸ì§€/CSV ì•„ë¬´ê±°ë‚˜

---

## 1. ì„¤ê³„ ê°œìš”

### 1.1 ì™œ AEAD(AES-GCM)ì¸ê°€?
- **ê¸°ë°€ì„± + ë¬´ê²°ì„±/ì¸ì¦**ì„ ë‹¨ì¼ ì—°ì‚°ìœ¼ë¡œ ì œê³µ(íƒœê·¸ ê²€ì¦ ì‹¤íŒ¨ ì‹œ í‰ë¬¸ **ê¸ˆì§€**).
- **GCMì€ Nonce(12B) ê³ ìœ ì„±**ì´ ì ˆëŒ€ ì¡°ê±´. **ê°™ì€ í‚¤**ì—ì„œ **ê°™ì€ Nonce** ì¬ì‚¬ìš© ì‹œ **ì¹˜ëª…ì **:
  - CTR ê³„ì¸µ ë•Œë¬¸ì— **C1 âŠ• C2 = P1 âŠ• P2** ëˆ„ì„¤(í‰ë¬¸ XOR ë…¸ì¶œ).
  - GHASHê°€ ê°™ì•„ì ¸ **íƒœê·¸ ìœ„ì¡° ê°€ëŠ¥ì„±**ì´ ìƒê¹€(ìˆ˜í•™ì ìœ¼ë¡œëŠ” ë‹¤í•­ì‹ ì¶©ëŒì„ ì´ìš©í•œ ìœ„ì¡°, ì‹¤ì „ PoCëŠ” ì¡°ê±´ë¶€/ê³ ë‚œë„).

### 1.2 íŒŒì¼ í¬ë§·(ê¶Œì¥; ë²„ì „ë“œ)
```
| magic(4:'AGF1') | ver(1:0x01) | alg(1:0x01=AEAD_AES_256_GCM) |
| nonce_len(1) | nonce | aad_len(2) | aad | edk_len(2) | edk | ct_len(8) | ct || tag(16) |
```
- **AAD**(Associated Data): íŒŒì¼ ë¬¸ë§¥(ë²„ì „, í…Œë„ŒíŠ¸, ê²½ë¡œ, í•„ë“œëª… ë“±)ì„ ë„£ì–´ **ë°”ì¸ë”©**.
- **EDK**(Encrypted Data Key): KMSë¡œ ë˜í•‘ëœ ë°ì´í„° í‚¤(ë´‰íˆ¬ ì•”í˜¸í™”). ì´ë²ˆ ë©ì—ì„œëŠ” **ë‹¨ì¼ ì„¸ì…˜ í‚¤**ë¡œ ì‹œì‘ â†’ ì´í›„ í™•ì¥.
- **ct||tag**: ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œëŠ” ë³´í†µ **ë¶™ì—¬ì„œ** ë‚˜ì˜¨ë‹¤. í‘œì¤€í™”ëœ ê¸¸ì´(íƒœê·¸ 16B ê¶Œì¥).

---

## 2. Python ê¸°ì¤€ **ì°¸ê³  êµ¬í˜„**: ì•ˆì „í•œ ì•”ë³µí˜¸ CLI

### 2.1 ì˜ì¡´ì„± ì„ íƒ
- ìˆœì • íŒŒì´ì¬ë§Œìœ¼ë¡œë„ ê°€ëŠ¥í•˜ì§€ë§Œ, ì‹¤ìš©ì„±/ì•ˆì „ì„±ì„ ìœ„í•´ `cryptography` ê¶Œì¥:
  - `pip install cryptography`
- í‘œì¤€ RNG: `os.urandom`(ë‚´ë¶€ì ìœ¼ë¡œ OS CSPRNG).  
- í‚¤ íŒŒìƒ(ì˜µì…˜): `HKDF`(SHA-256) â€” ì´ë²ˆ ë©ì—ì„  **ì´ë¯¸ 32B í‚¤ê°€ ìˆë‹¤ê³  ê°€ì •**.

### 2.2 ê³µí†µ ìœ í‹¸
```python
# aead_file.py
import os, json, struct, sys
from typing import Optional
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

MAGIC = b"AGF1"                 # "AEAD-GCM File v1"
VER   = 0x01
ALG_AES_256_GCM = 0x01

def u16(x): return struct.pack("!H", x)
def u64(x): return struct.pack("!Q", x)
def ru16(b, off): return struct.unpack("!H", b[off:off+2])[0], off+2
def ru64(b, off): return struct.unpack("!Q", b[off:off+8])[0], off+8

def encrypt_file(plaintext: bytes, key: bytes, aad: bytes=b"", nonce: Optional[bytes]=None) -> bytes:
    if len(key) != 32: raise ValueError("key must be 32B for AES-256-GCM")
    if nonce is None: nonce = os.urandom(12)
    if len(nonce) != 12: raise ValueError("nonce must be 12B")
    aead = AESGCM(key)
    ct = aead.encrypt(nonce, plaintext, aad)  # returns ct||tag(16B)
    edk = b""  # ë´‰íˆ¬ ì•”í˜¸í™” ë¯¸ì‚¬ìš©(ë°ëª¨). ì‹¤ì œëŠ” KMS wrap ê²°ê³¼ë¥¼ ë„£ê¸°.
    # header
    out = bytearray()
    out += MAGIC
    out += bytes([VER, ALG_AES_256_GCM, len(nonce)])
    out += nonce
    out += u16(len(aad)) + aad
    out += u16(len(edk)) + edk
    out += u64(len(ct))  + ct
    return bytes(out)

def decrypt_file(blob: bytes, key: bytes, expect_aad: Optional[bytes]=None) -> bytes:
    off=0
    if blob[:4] != MAGIC: raise ValueError("bad magic")
    off += 4
    ver = blob[off]; off += 1
    if ver != VER: raise ValueError("bad version")
    alg = blob[off]; off += 1
    if alg != ALG_AES_256_GCM: raise ValueError("bad alg")
    nlen = blob[off]; off += 1
    nonce = blob[off:off+nlen]; off += nlen
    aad_len, off = ru16(blob, off); aad = blob[off:off+aad_len]; off += aad_len
    edk_len, off = ru16(blob, off); edk = blob[off:off+edk_len]; off += edk_len
    ct_len, off  = ru64(blob, off); ct  = blob[off:off+ct_len];  off += ct_len
    if off != len(blob): raise ValueError("trailing bytes")
    if expect_aad is not None and aad != expect_aad:
        # AAD mismatchëŠ” ì¸ì¦ ì‹¤íŒ¨ì™€ **ë™ì¼í•˜ê²Œ** ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì•ˆì „. ì—¬ê¸°ì„  í•™ìŠµ ìœ„í•´ ë¶„ë¦¬.
        raise ValueError("aad mismatch")
    aead = AESGCM(key)
    return aead.decrypt(nonce, ct, aad)

def save(path, b): open(path,"wb").write(b)
def load(path)   : return open(path,"rb").read()

def main():
    if len(sys.argv) < 4:
        print("Usage: aead_file.py enc|dec key_hex in [out] [aad_str]")
        sys.exit(2)
    mode, key_hex, fin = sys.argv[1], sys.argv[2], sys.argv[3]
    fout = sys.argv[4] if len(sys.argv)>=5 else (fin + (".agf" if mode=="enc" else ".dec"))
    aad  = sys.argv[5].encode() if len(sys.argv)>=6 else b""
    key  = bytes.fromhex(key_hex)
    if mode == "enc":
        pt = load(fin)
        blob = encrypt_file(pt, key, aad)
        save(fout, blob)
        print(f"ok: wrote {fout}  (len={len(blob)})")
    elif mode == "dec":
        blob = load(fin)
        pt = decrypt_file(blob, key, aad)
        save(fout, pt)
        print(f"ok: wrote {fout}  (len={len(pt)})")
    else:
        print("mode must be enc|dec"); sys.exit(2)

if __name__ == "__main__":
    main()
```

#### ë¹ ë¥¸ ì‚¬ìš©
```bash
# 32B í‚¤ ìƒì„±(16ì§„)
KEY=$(python - <<'PY'
import os, binascii; print(binascii.hexlify(os.urandom(32)).decode())
PY)

# ì•”í˜¸í™”
python aead_file.py enc $KEY sample.txt sample.txt.agf "v=1|tenant=t1|file=sample.txt"
# ë³µí˜¸í™”
python aead_file.py dec $KEY sample.txt.agf sample.txt.dec "v=1|tenant=t1|file=sample.txt"
diff sample.txt sample.txt.dec && echo "OK same"
```

> í¬ì¸íŠ¸  
> - **AADë¥¼ ë°”ê¾¸ë©´ ë³µí˜¸ ì‹¤íŒ¨**(íƒœê·¸ ë¶ˆì¼ì¹˜) â†’ ë¬¸ë§¥ ë°”ì¸ë”© ê²€ì¦ë¨.  
> - í—¤ë”ì— **nonce**ë¥¼ í‰ë¬¸ ì €ì¥í•´ë„ ì•ˆì „(íƒœê·¸ê°€ ë³´í˜¸). ë‹¨, **ë°˜ë“œì‹œ ê³ ìœ **í•´ì•¼ í•¨.

---

## 3. **Nonce ì •ì±…**: ê³ ìœ ì„± ë³´ì¥ êµ¬í˜„

### 3.1 Bad vs Good
- âŒ **Bad**: ë§¤ë²ˆ `os.urandom(12)`(ì¶©ë¶„íˆ ì•ˆì „í•˜ê¸´ í•˜ë‚˜, **í´ëŸ¬ìŠ¤í„°/ë³µì œ/ì¬ì‹œì‘**ì—ì„œ **ì¤‘ë³µ ê°€ëŠ¥ì„±** ê´€ë¦¬ê°€ ì–´ë µë‹¤).  
- âœ… **Better**: **`prefix(4~8B instanceID) + counter(8~4B)`**  
  - ì¸ìŠ¤í„´ìŠ¤ ì¬ì‹œì‘ ì‹œ ì¹´ìš´í„° **ì˜ì†**(íŒŒì¼/DB/ì›ì ì—…ë°ì´íŠ¸)  
  - **ì „ì—­ ê³ ìœ ì„±** ë³´ì¥: (instanceID, counter) **ì ˆëŒ€ ì¤‘ë³µ ê¸ˆì§€**

### 3.2 íŒŒì¼ ê¸°ë°˜ ì¹´ìš´í„°(ì›ì ì—…ë°ì´íŠ¸)
```python
# nonce_policy.py
import os, struct, fcntl, time

NONCE_PREFIX = os.urandom(4)  # í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì‹œ ê³ ì •. ì‹¤ì „: í™˜ê²½/ì„¤ì •ê°’ìœ¼ë¡œ ë°°í¬.
COUNTER_PATH = ".nonce.counter"

def next_counter() -> int:
    # íŒŒì¼ ì ê¸ˆ ê¸°ë°˜ ì›ì ì¦ê°€
    fd = os.open(COUNTER_PATH, os.O_RDWR|os.O_CREAT, 0o600)
    try:
        fcntl.flock(fd, fcntl.LOCK_EX)
        data = os.read(fd, 8)
        cur = struct.unpack("!Q", data)[0] if len(data)==8 else 0
        nxt = (cur + 1) & 0xFFFFFFFFFFFFFFFF
        os.lseek(fd, 0, os.SEEK_SET)
        os.write(fd, struct.pack("!Q", nxt))
        os.fsync(fd)
        return nxt
    finally:
        fcntl.flock(fd, fcntl.LOCK_UN)
        os.close(fd)

def next_nonce12() -> bytes:
    ctr = next_counter()
    return NONCE_PREFIX + struct.pack("!Q", ctr)

# ì‚¬ìš©: nonce = next_nonce12()
```

> ìš´ì˜ íŒ  
> - **ë³µìˆ˜ ì¸ìŠ¤í„´ìŠ¤**ë©´ prefixëŠ” **ë…¸ë“œ ê³ ìœ  ID**(ì˜ˆ: RPC-alloc, KMS-derived, MACí•´ì‹œ)ë¡œ ë°°ì •.  
> - ì¹´ìš´í„° ë©ì–´ë¼ìš´ë“œ ì „ì— **í‚¤ íšŒì „**. ëª¨ë‹ˆí„°ë§ìœ¼ë¡œ **nonce ì¦ê°€ëŸ‰** ì¶”ì .

---

## 4. **Nonce ì¬ì‚¬ìš©** ì‚¬ê³  **ì‹¤í—˜**

> ê°™ì€ **í‚¤**ì—ì„œ **ê°™ì€ Nonce**ë¡œ **ì„œë¡œ ë‹¤ë¥¸ í‰ë¬¸**ì„ ì•”í˜¸í™”í•˜ë©´?  
> - CTR ê³„ì¸µ: `C1 = P1 âŠ• KS`, `C2 = P2 âŠ• KS`  â‡’  `C1 âŠ• C2 = P1 âŠ• P2`  
> - ì‹¤ì œë¡œëŠ” íƒœê·¸ ê²€ì¦ì´ ê¹¨ì ¸ ë³µí˜¸ëŠ” **ê±°ë¶€**ë˜ì§€ë§Œ, **í‰ë¬¸ XOR**ì´ ëˆ„ì„¤ë˜ë¯€ë¡œ ê³µê²©ìê°€ ì •ë³´íšë“.

### 4.1 ì‹¤í—˜ ì½”ë“œ
```python
# gcm_nonce_reuse_demo.py
import os
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

def xor(a,b): return bytes(x^y for x,y in zip(a,b))
key   = os.urandom(32)
nonce = os.urandom(12)

P1 = b"PAY=100USD;ACC=123456789;NOTE=salary"
P2 = b"PAY=900USD;ACC=123456789;NOTE=salary"  # ì¼ë¶€ ë°”ì´íŠ¸ë§Œ ë‹¤ë¦„

aead = AESGCM(key)
C1 = aead.encrypt(nonce, P1, b"ctx=v1")
C2 = aead.encrypt(nonce, P2, b"ctx=v1")  # ğŸš¨ ì¬ì‚¬ìš©(ìœ„í—˜)

# íƒœê·¸ê°€ í¬í•¨(ct||tag)ì´ë¼ ë’¤ìª½ ì˜ë¼ ë¹„êµë¥¼ ìœ„í•´ ê¸¸ì´ë¥¼ ë§ì¶¤
L = min(len(C1), len(C2)) - 16  # íƒœê·¸ ì œì™¸
c1, c2 = C1[:L], C2[:L]
print("xor(C1,C2)[:32] =", xor(c1,c2)[:32])
print("xor(P1,P2)[:32] =", xor(P1,P2)[:32])
```

**ê´€ì°°**: `xor(C1,C2)` == `xor(P1,P2)` (íƒœê·¸ ë¶€ë¶„ ì „ê¹Œì§€).  
- ê³µê²©ìëŠ” **ë‘˜ ì¤‘ í•˜ë‚˜ì˜ í‰ë¬¸ì˜ ì¼ë¶€ë¼ë„ ì•Œë©´** ë‹¤ë¥¸ ìª½ì„ **ë³µì›** ê°€ëŠ¥.  
- íŒŒì¼ í¬ë§·ì´ ì •í˜•(ì˜ˆ: CSV/JSON í—¤ë”)ì¼ìˆ˜ë¡ ìœ ë¦¬.

### 4.2 AAD ë°”ê¾¸ì–´ë„?  
- AADë¥¼ ë°”ê¾¸ë©´ íƒœê·¸ëŠ” **ë¬´ê²°ì„± ì‹¤íŒ¨**ì´ì§€ë§Œ, **CTR ê³„ì¸µ XOR ëˆ„ì„¤**ì€ ê·¸ëŒ€ë¡œ ë°œìƒ(ì•”í˜¸ë¬¸ì€ ì´ë¯¸ ì „ì†¡ë¨).  
- ê²°ë¡ : **Nonce ì¬ì‚¬ìš©ì€ ì ˆëŒ€ ê¸ˆì§€** â€” AADë¡œëŠ” ë°©ì–´ ë¶ˆê°€.

---

## 5. **CTF ê³¼ì œ ì„¸íŠ¸** (ë¡œì»¬ ì „ìš© Â· í‰ê°€ í¬ì¸íŠ¸ í¬í•¨)

### CHAL-1: ì•ˆì „ í¬ë§· êµ¬í˜„ & ìƒí˜¸ ìš´ìš©
- **ìš”êµ¬**: ìœ„ 2ì¥ í¬ë§·ëŒ€ë¡œ **ì•”ë³µí˜¸ ë„êµ¬**ë¥¼ ë§Œë“¤ê³ , ë‹¤ìŒì„ ë§Œì¡±:
  1) **Nonce = prefix+counter** ì •ì±… êµ¬í˜„(3ì¥).  
  2) **AAD**ì— `v=1|tenant=t1|path=/doc/a.txt` ë°©ì‹ì˜ ì»¨í…ìŠ¤íŠ¸ ì‚½ì….  
  3) ì•”í˜¸í™” ê²°ê³¼ í—¤ë”ë¥¼ JSONìœ¼ë¡œ **pretty-print**í•˜ëŠ” `--show-header` ì˜µì…˜.  
- **ê²€ì¦**: ì„ì˜ íŒŒì¼ 3ê°œ ì•”í˜¸í™” í›„, **ìˆœì„œ ë°”ê¿” ë³µí˜¸**(í‚¤/nonce/AAD ë§¤ì¹­ í•„ìˆ˜), í•˜ë‚˜ë¼ë„ AAD í‹€ë¦¬ë©´ **ì‹¤íŒ¨**í•´ì•¼ í•¨.

### CHAL-2: Nonce ì¬ì‚¬ìš© íƒì§€ê¸°
- **ìš”êµ¬**: ì•”í˜¸í™” ì‹œ **(key_id, nonce)** ë¥¼ ë¡œì»¬ DB(ì˜ˆ: SQLite)ì— ê¸°ë¡í•˜ê³ , **ì¤‘ë³µì´ë©´ ì¦‰ì‹œ ì‹¤íŒ¨**.  
- **ë³´ë„ˆìŠ¤**: **ë™ì‹œì„± í…ŒìŠ¤íŠ¸**(Nê°œ í”„ë¡œì„¸ìŠ¤ ë³‘ë ¬ ì•”í˜¸í™”)ì—ì„œ ì¤‘ë³µì´ ì—†ìŒì„ ì¦ëª…(í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸).

### CHAL-3: ì¬ì‚¬ìš© ëˆ„ì„¤ ì‹œê°í™”
- **ìš”êµ¬**: ê°™ì€ í‚¤/Nonceë¡œ ë‹¤ë¥¸ íŒŒì¼ 2ê°œë¥¼ ì•”í˜¸í™”(ì˜ë„ì  ì¬ì‚¬ìš©), `xor(C1,C2)`ë¥¼ **í—¥ìŠ¤ ë¤í”„**ë¡œ ì¶œë ¥.  
- **ë¶„ì„**: CSV/JSON ë“± **êµ¬ì¡°ì  í¬ë§·**ì—ì„œ ì–´ëŠ í•„ë“œê°€ ë“œëŸ¬ë‚˜ëŠ”ì§€ **ì„¤ëª…**(ìƒ˜í”Œ ì²¨ë¶€).

### CHAL-4: í‚¤ íšŒì „ & ì¬ì•”í˜¸í™”
- **ìš”êµ¬**: ê¸°ì¡´ íŒŒì¼(EDK ì—†ì´ ì•”í˜¸í™”)ì„ **ìƒˆ í‚¤**ë¡œ **ë¬´ì†ì‹¤ ì¬ì•”í˜¸í™”**:  
  - ë³µí˜¸ â†’ ìƒˆ í‚¤ë¡œ ì•”í˜¸í™” â†’ í—¤ë” `v` ì¦ê°€ â†’ Nonce ìƒˆë¡œ í• ë‹¹  
- **ê²€ì¦**: êµ¬/ì‹  í•´ì‹œ(SHA-256) ë¹„êµ, ì‚¬ì´ì¦ˆ ë³€ë™/ì†ìƒ ì—†ìŒ.

---

## 6. **ìš´ì˜ ì²´í¬ë¦¬ìŠ¤íŠ¸** (ë°°í¬ ì „Â·í›„)

- [ ] **AEADë§Œ ì‚¬ìš©**(AES-GCM/ChaCha20-Poly1305), CBC ê¸ˆì§€  
- [ ] **Nonce = prefix+counter**(ì „ì—­ ê³ ìœ ), **ì¶©ëŒ ê°ì§€**(DB/ì €ë„ë§)  
- [ ] **í‚¤ íšŒì „ ì£¼ê¸°** ì •ì˜(ì˜ˆ: 90ì¼ ë˜ëŠ” Nê±´) + íšŒì „ ì‹œ **nonce ì¹´ìš´í„° ë¦¬ì…‹**  
- [ ] **AAD ì •ì±…**: í…Œë„ŒíŠ¸/ë¦¬ì†ŒìŠ¤ ê²½ë¡œ/ë²„ì „/ê¶Œí•œ ìŠ¤ì½”í”„ ë“± **ë¬¸ë§¥ ë°”ì¸ë”©**  
- [ ] **ì˜¤ë¥˜ ë©”ì‹œì§€ ê· ì¼í™”**(ì¸ì¦ ì‹¤íŒ¨/í¬ë§· ì˜¤ë¥˜/í‚¤ ë¯¸ì¼ì¹˜ëŠ” ë™ì¼ ì—ëŸ¬)  
- [ ] **ë¡œê·¸**: ì™¸ë¶€ì—ëŠ” ì¶”ìƒ ì½”ë“œ, ë‚´ë¶€ì—ëŠ” ì •ë°€ ì½”ë“œ(íƒœê·¸ ì‹¤íŒ¨/nonce ì¤‘ë³µ)  
- [ ] **KMS ë´‰íˆ¬ ì•”í˜¸í™”** ë„ì… ì‹œ: EDK ì €ì¥/ë³µêµ¬, CMK ì ‘ê·¼ ì œì–´/ê°ì‚¬  
- [ ] **ì¬ì‹œë„** ë¡œì§: ì•”í˜¸í™”/ë³µí˜¸ ì‹¤íŒ¨ ì‹œ **ë©±ë“±** ë³´ì¥(íŒŒì¼ ì„ì‹œì´ë¦„ â†’ ì›ìì  rename)

---

## 7. ë¶€ë¡: **ê°„ë‹¨ ë´‰íˆ¬ ì•”í˜¸í™”**(KMS ì—†ëŠ” ë¡œì»¬ ë²„ì „)

> ì‹¤ì œ ìš´ì˜ì€ **KMS(Cloud KMS/HSM)** ë¥¼ ê¶Œì¥. ì—¬ê¸°ì„  ê°œë…ë§Œ.

- ì ˆì°¨  
  1) **DEK(32B ëœë¤)** ìƒì„±  
  2) íŒŒì¼ì€ **DEKë¡œ AEAD ì•”í˜¸í™”**  
  3) **EDK = Wrap(CMK, DEK)** ë¥¼ í—¤ë”ì— ì €ì¥  
  4) ë³µí˜¸: **Unwrap(CMK, EDK) â†’ DEK** ì¬í˜„ â†’ AEAD ë³µí˜¸

```python
# envelope_demo.py (ê°œë…)
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

def wrap_with_master(cmk: bytes, dek: bytes) -> bytes:
    # ë°ëª¨ìš©: AESGCMë¡œ ê°„ë‹¨ wrap (ì‹¤ì „ì€ KMS API)
    aead = AESGCM(cmk)
    nonce = os.urandom(12)
    edk = nonce + aead.encrypt(nonce, dek, b"wrap-v1")
    return edk

def unwrap_with_master(cmk: bytes, edk: bytes) -> bytes:
    aead = AESGCM(cmk)
    nonce, ct = edk[:12], edk[12:]
    return aead.decrypt(nonce, ct, b"wrap-v1")
```

---

## 8. Go / Rust ìŠ¤ë‹ˆí«(ì„ íƒ)

### 8.1 Go (AES-GCM)
```go
// go_aead.go
package main
import (
  "crypto/aes"; "crypto/cipher"; "crypto/rand"; "io"; "os"
)
func main() {
  key := make([]byte, 32); io.ReadFull(rand.Reader, key)
  block, _ := aes.NewCipher(key)
  gcm, _ := cipher.NewGCM(block)
  nonce := make([]byte, gcm.NonceSize()); io.ReadFull(rand.Reader, nonce)
  pt := []byte("hello aead")
  ct := gcm.Seal(nil, nonce, pt, []byte("ctx=v1"))
  // ë³µí˜¸
  pt2, err := gcm.Open(nil, nonce, ct, []byte("ctx=v1"))
  if err != nil { panic(err) }
  os.Stdout.Write(pt2)
}
```

### 8.2 Rust (aes-gcm í¬ë ˆì´íŠ¸)
```rust
// Cargo.toml: aes-gcm="0.10", rand="0.8", hex="0.4"
use aes_gcm::{Aes256Gcm, Key, Nonce, aead::{Aead, KeyInit}};
use rand::RngCore;
fn main() {
    let mut keyb=[0u8;32]; rand::thread_rng().fill_bytes(&mut keyb);
    let cipher = Aes256Gcm::new(Key::from_slice(&keyb));
    let mut nonceb=[0u8;12]; rand::thread_rng().fill_bytes(&mut nonceb);
    let nonce = Nonce::from_slice(&nonceb);
    let pt = b"hello aead";
    let ct = cipher.encrypt(nonce, aes_gcm::aead::Payload{msg:pt, aad:b"ctx=v1"}).unwrap();
    let dec = cipher.decrypt(nonce, aes_gcm::aead::Payload{msg:&ct, aad:b"ctx=v1"}).unwrap();
    println!("{}", String::from_utf8_lossy(&dec));
}
```

---

## 9. íŠ¸ëŸ¬ë¸”ìŠˆíŒ…(í˜„ì¥ì—ì„œ ìì£¼ ë§Œë‚¨)

- **ë³µí˜¸ ì‹¤íŒ¨(â€œInvalidTagâ€)**: í‚¤/nonce/AAD ì¤‘ **í•˜ë‚˜ë¼ë„** ë‹¤ë¥´ë©´ ì˜¬ë¼ì˜¨ë‹¤.  
  â†’ í—¤ë”Â·ì»¨í…ìŠ¤íŠ¸ ë™ê¸°í™”, ì „ì†¡/ì €ì¥ ì¤‘ ì†ìƒ ì—¬ë¶€ ê²€ì‚¬(í•´ì‹œ).  
- **Nonce ì¤‘ë³µ ê²½ê³ **: ì¹´ìš´í„° íŒŒì¼ ì´ˆê¸°í™”/ë¡¤ë°±/ì»¨í…Œì´ë„ˆ ì¬ìƒì„± ì‹œ ë°œìƒ  
  â†’ ì¹´ìš´í„°ë¥¼ **í¼ì‹œìŠ¤í„´íŠ¸ ë³¼ë¥¨**ì— ë‘ê³ , ë¡¤ë°± ì‹œì ì— **í‚¤ íšŒì „** ë³‘í–‰.  
- **ëŒ€ìš©ëŸ‰ ìŠ¤íŠ¸ë¦¬ë°**: íŒŒì¼ ì „ì²´ ë©”ëª¨ë¦¬ì— ì˜¬ë¦¬ë©´ OOM  
  â†’ ìŠ¤íŠ¸ë¦¼ AEAD(ì²­í¬ë§ˆë‹¤ ê³ ìœ  Nonce) + AADì— **ì´ ê¸¸ì´/ì¸ë±ìŠ¤** ë°”ì¸ë”©.  
- **ë©€í‹°í…Œë„ŒíŠ¸**: ì„œë¡œ ë‹¤ë¥¸ í…Œë„ŒíŠ¸ê°€ ê°™ì€ nonceë¥¼ ì¨ë„ ë˜ë‚˜?  
  â†’ **ê°™ì€ í‚¤**ë¼ë©´ ì•ˆ ë¨. í‚¤ ë¶„ë¦¬(í…Œë„ŒíŠ¸ë³„ í‚¤) ë˜ëŠ” Nonce prefixì— **í…Œë„ŒíŠ¸ ID í•´ì‹œ** í¬í•¨.

---

## 10. ë¦¬ë·° ì§ˆë¬¸(ìê¸° ì ê²€)

1) AES-GCMì—ì„œ **Nonce ì¬ì‚¬ìš©**ì´ ì™œ ì¹˜ëª…ì ? (CTRÂ·GHASH ê´€ì  ê°ê° ì„¤ëª…)  
2) AADì˜ ì—­í• ì€? AADê°€ ë‹¤ë¥´ë©´ ì–´ë–¤ í˜„ìƒì´ ë°œìƒí•˜ë©°, ë¬´ì—‡ì„ ë°©ì–´í•˜ë‚˜?  
3) `prefix+counter` ì •ì±…ì—ì„œ **prefix**ì™€ **counter**ëŠ” ì–´ë–¤ ë³´ì•ˆÂ·ìš´ì˜ ì†ì„±ì„ ë§Œì¡±í•´ì•¼ í•˜ë‚˜?  
4) íŒŒì¼ ìŠ¤íŠ¸ë¦¬ë° ì•”í˜¸í™”ì—ì„œ **ì²­í¬ë³„ Nonce** ì„¤ê³„ ì‹œ ì£¼ì˜í•  ì  3ê°€ì§€?  
5) ë³µí˜¸ ì‹¤íŒ¨ë¥¼ **ì™¸ë¶€ ì‘ë‹µ**ì—ì„œ ì–´ë–»ê²Œ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ”ê°€(ì˜¤ë¥˜ ê· ì¼í™” ê´€ì )?

---

## 11. ìš”ì•½ ì¹´ë“œ

- **ì„¤ê³„**: ë²„ì „ë“œ í—¤ë” + **AEAD(AES-GCM)** + **AAD ë°”ì¸ë”©** + (ì„ íƒ) **ë´‰íˆ¬ ì•”í˜¸í™”**  
- **ì •ì±…**: **Nonce ì „ì—­ ê³ ìœ ì„±**(prefix+counter), ì¶©ëŒ ê°ì§€/ëª¨ë‹ˆí„°ë§, íšŒì „/ë°±ì—…/ë¡¤ë°± ì „ëµ  
- **ì‹¤í—˜**: Nonce ì¬ì‚¬ìš© ì‹œ **C1âŠ•C2 = P1âŠ•P2** ëˆ„ì„¤ì´ **ì‹¤ì œë¡œ** ì¼ì–´ë‚¨ì„ í™•ì¸  
- **ìš´ì˜**: ì˜¤ë¥˜ ê· ì¼í™”, ë¡œê¹…/ê°ì‚¬, í‚¤ ìˆ˜ëª…ì£¼ê¸°, ìŠ¤íŠ¸ë¦¬ë°Â·í…Œë„Œì‹œ ê³ ë ¤

> ì´ì œ ì´ ë© ìŠ¤ì¼ˆë ˆí†¤ì„ **ë‹¹ì‹ ì˜ ë¸”ë¡œê·¸**ì— ë§ê²Œ: â€œê°œë… â†’ ì„¤ê³„ â†’ ì½”ë“œ â†’ ì‹¤í—˜ â†’ ì²´í¬ë¦¬ìŠ¤íŠ¸ â†’ Q&Aâ€ íë¦„ìœ¼ë¡œ ë„£ìœ¼ë©´,  
> í•™ìŠµê³¼ ì‹¤ë¬´ ì „ê°œë¥¼ ë™ì‹œì— ë§Œì¡±ì‹œí‚¤ëŠ” **ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í…œí”Œë¦¿**ì´ ë©ë‹ˆë‹¤.