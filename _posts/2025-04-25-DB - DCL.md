---
layout: post
title: DB - DCL
date: 2025-04-25 19:20:23 +0900
category: DB
---
# DCL (Data Control Language)

## 왜 DCL인가? — 보안과 신뢰의 언어

DCL(Data Control Language)은 **데이터베이스 내 보안 정책을 집행하는 최종 수단**이다.
주요 목적은 아래와 같다.

- **접근 통제**: 누가(Principal) 무엇(securable)에 대해 어떤 동작(permission)을 할 수 있는가?
- **위임·회수**: 필요한 최소 권한만, 필요한 기간 동안, 추적 가능하게.
- **감사(Audit)**: 누가 언제 어떤 권한을 받았고, 어떤 객체에 접근했는가?

보안 설계의 이론적 뼈대는 **접근 행렬(access matrix)** 로 요약할 수 있다. 사용자/역할을 행, 객체를 열로 하고 권한을 행렬 값으로 본다.

$$
A \in \{0,1\}^{U \times O},\quad
A_{u,o}=1 \iff \text{user }u \text{ 가 객체 }o \text{에 접근권한 보유}
$$

→ 실무에서는 이 행렬을 **ROLE(집합)** 로 압축하고, **GRANT/REVOKE** 로 갱신한다.

---

## DCL 핵심 명령 — GRANT / REVOKE (+ DENY in SQL Server)

### 공통 개념

- **GRANT**: 권한 부여
- **REVOKE**: 권한 회수
- **WITH GRANT OPTION**: 부여받은 사용자가 **다른 사용자에게 재부여** 가능
- (**SQL Server 전용**) **DENY**: 명시적 거부 — 상속/역할의 GRANT를 **차단**하는 우선 규칙

> 원칙: **최소 권한(Least Privilege)** + **역할 기반(Role-Based)** + **감사 가능(Auditable)**

---

## 엔진별 권한 모델 한눈에 보기

| 항목 | Oracle | PostgreSQL | MySQL 8.0+ | SQL Server |
|---|---|---|---|---|
| 권한 계층 | **시스템 권한** vs **객체 권한** | DB/스키마/테이블/열/함수/시퀀스 권한 | 글로벌/DB/테이블/열/프로시저 권한 + **Dynamic Privileges** | 서버/DB/스키마/객체 **Securables** |
| 역할 | ROLE, `WITH ADMIN OPTION` | ROLE(로그인 가능 여부 분리), `ALTER DEFAULT PRIVILEGES` | 8.0+ 역할 정식 지원 | 서버/DB 고정 역할 + 사용자 정의 역할 |
| 재부여 | `WITH GRANT OPTION` | `WITH GRANT OPTION` | `WITH GRANT OPTION` | `WITH GRANT OPTION` |
| 거부 | 없음(보통 REVOKE) | 없음(보통 REVOKE) | 없음(보통 REVOKE) | **DENY** (우선순위 높음) |
| RLS(행 수준) | VPD/정책(Enterprise 옵션) | **Row-Level Security** 표준 지원 | 뷰/저장프로시저/앱단 구현 | **Row-Level Security** 지원 |
| 감사 | Unified Auditing | pgaudit/로깅 | 일반/감사 플러그인 | SQL Server Audit/Extended Events |

> 실무는 **역할(RBAC)** 기반으로 설계하고, 엔진별 문법 차이는 **grant 세트 스크립트**로 흡수하는 전략이 안정적이다.

---

## 공통 시나리오: RBAC 설계 → GRANT/REVOKE 배포

### 공통 설계 패턴

1) **업무도메인별 역할 정의** (예: `app_reader`, `app_writer`, `etl_runner`)
2) **권한은 역할에만 GRANT** 하고, **사람/계정은 역할을 할당**
3) **직무분리(SoD)**: 변경·운영·감사 역할을 분리
4) **기본권한(기본 스키마 USAGE/CONNECT)** 를 누락하지 않도록 **부트스트랩 역할** 제공

---

### Oracle 예제

```sql
-- 1) 사용자/역할
CREATE USER app_user IDENTIFIED BY "S3cret!" DEFAULT TABLESPACE users QUOTA UNLIMITED ON users;
CREATE ROLE app_reader;
CREATE ROLE app_writer;

-- 2) 권한(시스템/객체)
GRANT CREATE SESSION TO app_user;
GRANT SELECT ON hr.emp TO app_reader;
GRANT INSERT, UPDATE, DELETE ON hr.emp TO app_writer;

-- 3) 역할 할당
GRANT app_reader TO app_user;
-- 필요 시 쓰기 권한
GRANT app_writer TO app_user;

-- 4) 재부여 권한 주의 (권한 확산 위험)
GRANT SELECT ON hr.emp TO app_user WITH GRANT OPTION; -- 신중히!
```

**주의**
- **시스템 권한**(예: `CREATE SESSION`, `CREATE TABLE`) vs **객체 권한**(예: `SELECT ON hr.emp`) 구분
- **WITH ADMIN OPTION**(역할에 대한 관리자 권한 위임) vs **WITH GRANT OPTION**(객체 권한 재부여) 혼동 금지

---

### PostgreSQL 예제

```sql
-- 1) 역할(로그인/비로그인 분리)
CREATE ROLE app_reader NOLOGIN;
CREATE ROLE app_writer NOLOGIN;
CREATE ROLE app_user LOGIN PASSWORD 'S3cret!';

-- 2) 스키마·DB 기본권한
GRANT CONNECT ON DATABASE mydb TO app_user;
GRANT USAGE ON SCHEMA public TO app_reader, app_writer;

-- 3) 객체 권한
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_reader;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_writer;

-- 4) 향후 생성되는 테이블에 대한 기본 권한 (중요!)
ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT SELECT ON TABLES TO app_reader;

ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO app_writer;

-- 5) 사용자에게 역할 부여
GRANT app_reader TO app_user;
```

**핵심**
- 신규 테이블이 생길 때 권한이 **자동 적용**되도록 `ALTER DEFAULT PRIVILEGES` 를 꼭 설정
- 스키마 권한(USAGE)과 테이블 권한(SELECT/INSERT …)을 **둘 다** 부여해야 접근 가능

---

### MySQL 8.0+ 예제

```sql
-- 1) 역할
CREATE ROLE app_reader, app_writer;
CREATE USER 'app_user'@'%' IDENTIFIED BY 'S3cret!';

-- 2) 권한 (DB/테이블/열/프로시저)
GRANT SELECT ON mydb.* TO app_reader;
GRANT SELECT, INSERT, UPDATE, DELETE ON mydb.* TO app_writer;

-- 3) 역할을 사용자에게
GRANT app_reader TO 'app_user'@'%';

-- 4) 역할 활성화(세션/전역)
SET DEFAULT ROLE app_reader FOR 'app_user'@'%';
```

**메모**
- 8.0부터 정식 역할 지원.
- **Dynamic Privileges**(예: `REPLICATION SLAVE`, `SHOW_ROUTINE`)는 `GRANT` 로 부여.

---

### SQL Server 예제 (DENY 포함)

```sql
-- 1) 로그인/사용자/역할
CREATE LOGIN app_login WITH PASSWORD = 'S3cret!';
CREATE USER app_user FOR LOGIN app_login;
CREATE ROLE app_reader, app_writer;

-- 2) 권한
GRANT SELECT ON SCHEMA::dbo TO app_reader;
GRANT SELECT, INSERT, UPDATE, DELETE ON SCHEMA::dbo TO app_writer;

-- 3) 역할 멤버십
EXEC sp_addrolemember 'app_reader', 'app_user';

-- 4) 명시적 거부 (DENY가 GRANT보다 우선)
DENY DELETE ON OBJECT::dbo.Orders TO app_user;  -- 특정 위험 동작 차단
```

**포인트**
- SQL Server에는 **DENY** 가 있어서 “상속된 GRANT” 도 **차단** 가능
- **Ownership chaining**(같은 소유자 간 권한 위임)을 이해해야 예상치 못한 접근을 막을 수 있다

---

## 행·열·객체 단위: “필요한 만큼만” 주는 법

### 열(Column) 단위 권한 (엔진별 지원/제약)

- **PostgreSQL**: `GRANT SELECT(col1, col2) ON table TO role;`
- **MySQL**: `GRANT SELECT (col1, col2) ON mydb.table TO 'user'@'%';`
- **SQL Server**: `GRANT SELECT ON OBJECT::dbo.Table (col1, col2) TO user;`
- **Oracle**: 컬럼 수준 SELECT 제약은 **VIEW** + `WITH CHECK OPTION` 패턴으로 구현하는 경우가 일반적

```sql
-- PostgreSQL: 특정 열만 SELECT 허용
GRANT SELECT (name, age) ON people TO app_reader;
```

### 행(Row) 단위 권한 — Row-Level Security (RLS)

- **PostgreSQL/SQL Server**: RLS 정책을 정의해 조건에 맞는 행만 보이게
- **Oracle**: VPD(가상 사설 DB)/정책 함수
- **MySQL**: View/저장프로시저·앱단 조건으로 구현

```sql
-- PostgreSQL: 고객별 소유 데이터만 조회 가능
CREATE POLICY own_rows ON orders
  FOR SELECT USING (customer_id = current_setting('app.current_customer')::int);

ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
```

> **전략**: RLS + 최소 컬럼 권한 + 뷰 = 안전한 “업무 단위” 데이터 노출

---

## WITH GRANT OPTION / ADMIN OPTION — 권한 확산 제어

- **WITH GRANT OPTION**: 객체 권한의 **재부여** 가능
- **WITH ADMIN OPTION**: **역할** 의 멤버십을 **관리** 가능 (Oracle/SQL Server 유사 개념)

**실무 권고**
- 운영계에서는 되도록 **역할 관리자 소수**에게만 `ADMIN OPTION` 부여
- 애플리케이션 계정에는 **재부여 권한 금지**(권한 확산/스풀 위험)

---

## REVOKE와 CASCADE — 회수의 정확성

- **PostgreSQL**: `REVOKE ... FROM ...;` / `REVOKE ALL PRIVILEGES ON ...`
- **Oracle**: 재부여 체인을 고려, 경우에 따라 **연쇄 회수**가 발생할 수 있다
- **SQL Server**: `REVOKE` 와 `DENY` 의 상호작용을 유념(denied이면 grant 무력화)
- **MySQL**: GRANT OPTION으로 파생된 권한 정리가 필요

**퇴사/권한 축소 프로시저**
1) **세션 강제 종료**(가능 시)
2) 역할 멤버십 제거 → 직접 부여 권한 REVOKE → 재부여 체인 확인
3) 감사 로그에 남김

---

## 스키마·오브젝트 생애주기와 “미래 객체” 권한

### PostgreSQL의 정석

```sql
-- 향후 생성 테이블에도 자동 적용
ALTER DEFAULT PRIVILEGES IN SCHEMA sales
  GRANT SELECT ON TABLES TO sales_reader;
```

### Oracle/SQL Server/MySQL 대안

- **배포 파이프라인**에서 마이그레이션 직후 **GRANT 재실행**
- “스키마 주인” 역할을 통해 새 객체 생성 시 **소유자에 따른 자동 접근**을 설계(단, 소유자 체인 주의)

---

## 보안 패턴: VIEW/PROC/OWNERSHIP CHAIN/EXECUTE AS

### VIEW로 최소 공개 + 데이터 마스킹

```sql
-- SQL Server: 민감정보 마스킹 뷰
CREATE VIEW v_customer_safe AS
SELECT id,
       name,
       CONCAT(LEFT(phone,3), '****', RIGHT(phone,4)) AS phone_masked
FROM dbo.customer;
GRANT SELECT ON v_customer_safe TO app_reader;
```

### 저장 프로시저로 권한 위임

- **SQL Server**: `EXECUTE AS OWNER`
- **MySQL**: DEFINER/INVOKER
- **Oracle**: Definer’s rights / Invoker’s rights

```sql
-- SQL Server: 최소권한 사용자도 프로시저를 통해 제한 동작만 수행
CREATE PROCEDURE dbo.p_safe_update @id int, @amount money
WITH EXECUTE AS OWNER
AS
  UPDATE dbo.orders SET amount = @amount WHERE id = @id;
GO
GRANT EXECUTE ON dbo.p_safe_update TO app_writer;
```

---

## 감사(Audit)와 변경 추적

### Oracle

- Unified Auditing: `AUDIT INSERT, UPDATE, DELETE ON hr.emp BY ACCESS;`
- 뷰: `UNIFIED_AUDIT_TRAIL`

### PostgreSQL

- **pgaudit** 확장 / 서버 로그 파싱
- RLS 정책 접근 시도도 로깅 가능(설정 필요)

### MySQL

- 일반 로그/감사 플러그인(엔터프라이즈/오픈소스)
- `performance_schema` 이벤트

### SQL Server

- SQL Server Audit / Extended Events
- 권한 변경/실행 추적 정책 구성

> 권한 변경은 **Change Control** 에 남기고, **자동 알림**(SIEM 연동)으로 실시간 탐지

---

## 운영 자동화: 선언형 권한/역할 스크립트

### 선언형 접근

- “**목표 상태**(원하는 GRANT/REVOKE/ROLE 멤버십)”를 코드로 정의
- CICD에서 **Idempotent** 하게 적용

```sql
-- PostgreSQL: 존재 검사 후 부여(의사 코드)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='app_reader') THEN
    CREATE ROLE app_reader;
  END IF;
  GRANT USAGE ON SCHEMA public TO app_reader;
  GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_reader;
  ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO app_reader;
END $$;
```

### 환경 분리

- Dev/Stg/Prod 별 **역할/권한 세트** 분리
- Prod에는 **WITH GRANT/ADMIN OPTION 금지** + **DENY/감사 활성화**

---

## 인시던트 대응 레시피

1) **즉시 차단**: SQL Server면 `DENY`, 공통으로는 `REVOKE` + 로그인 잠금
2) **소급 회수**: 재부여 체인 역추적, `WITH GRANT OPTION` 유출 경로 정리
3) **감사/보고**: 누가·언제·무엇을 — 시간축으로 정리
4) **재발 방지**: 역할 재설계, 자동화 파이프라인에 **정책 테스트** 추가

---

## 실전 레시피 모음 (Cookbook)

### “리포트 전용 읽기 역할” 만들기

```sql
-- PostgreSQL
CREATE ROLE report_reader NOLOGIN;
GRANT CONNECT ON DATABASE mydb TO report_reader;
GRANT USAGE ON SCHEMA rpt TO report_reader;
GRANT SELECT ON ALL TABLES IN SCHEMA rpt TO report_reader;
ALTER DEFAULT PRIVILEGES IN SCHEMA rpt GRANT SELECT ON TABLES TO report_reader;

-- 최종 사용자 연결
CREATE ROLE analyst LOGIN PASSWORD 'S3cret!';
GRANT report_reader TO analyst;
```

### “애플리케이션 쓰기 최소 권한 (INSERT/UPDATE만)”

```sql
-- MySQL
CREATE ROLE app_writer;
GRANT INSERT, UPDATE ON mydb.sales TO app_writer;
CREATE USER 'app'@'10.%' IDENTIFIED BY 'S3cret!';
GRANT app_writer TO 'app'@'10.%';
SET DEFAULT ROLE app_writer FOR 'app'@'10.%';
```

### “특정 테이블의 DELETE만 명시적 거부”

```sql
-- SQL Server
DENY DELETE ON OBJECT::dbo.Orders TO app_user;
```

### “미래 생성 테이블 자동 권한” (분석 스키마)

```sql
-- PostgreSQL
ALTER DEFAULT PRIVILEGES IN SCHEMA analytics
  GRANT SELECT ON TABLES TO bi_reader;
```

### “행 제한: 본인 소유 데이터만”

```sql
-- SQL Server RLS
CREATE FUNCTION dbo.fn_tenant_filter(@tenant_id int)
RETURNS TABLE
WITH SCHEMABINDING
AS RETURN SELECT 1 AS allowed WHERE @tenant_id = CAST(SESSION_CONTEXT(N'tenant_id') AS int);

CREATE SECURITY POLICY dbo.TenantFilter
ADD FILTER PREDICATE dbo.fn_tenant_filter(tenant_id) ON dbo.Invoices
WITH (STATE = ON);
```

---

## 흔한 실수와 대처

| 실수 | 증상 | 해결 |
|---|---|---|
| 스키마 USAGE 미부여 | 테이블 SELECT 권한 있어도 “권한 없음” | 스키마 USAGE/EXECUTE(함수) 함께 GRANT |
| 신규 테이블 권한 누락 | 배포 후 앱 403/권한 오류 | `ALTER DEFAULT PRIVILEGES` or 배포 스크립트에 GRANT 루틴 삽입 |
| WITH GRANT OPTION 남발 | 권한 폭증, 회수 어려움 | 재부여 금지, 역할 관리자만 권한 부여 |
| Ownership chain 오해 | 의도치 않은 접근 허용 | 소유자/스키마 설계 점검, EXECUTE AS/권한 명시 |
| REVOKE 후에도 접근됨 | 상위 권한/다른 역할 통해 상속 | **DENY**(SQL Server), 역할 멤버십 정리, 상속 경로 추적 |
| 컬럼 제한 누락 | 개인정보 유출 | **VIEW** + 컬럼권한/마스킹, RLS 병행 |

---

## 검증 체크리스트

- [ ] 최소 권한 원칙 준수(읽기/쓰기/관리자 분리)
- [ ] 역할 기반(RBAC) 설계, 사용자→역할 매핑만 사용
- [ ] 스키마/DB 기본 권한(USAGE/CONNECT) 포함
- [ ] 신규 객체 기본 권한(ALTER DEFAULT PRIVILEGES 등) 구성
- [ ] WITH GRANT/ADMIN OPTION 최소화
- [ ] RLS/VIEW로 민감정보 최소 노출
- [ ] 감사(Audit) 활성화 및 경보(SIEM) 연동
- [ ] 권한 변경 자동화(Idempotent) 및 코드로 버전관리

---

## 부록 — 엔진별 명령 스니펫 모음

### Oracle

```sql
-- 시스템 권한/객체 권한
GRANT CREATE SESSION TO u1;
GRANT SELECT, INSERT ON hr.emp TO u1;

-- 역할과 관리자 권한
CREATE ROLE r_analyst;
GRANT r_analyst TO u1;
GRANT r_analyst TO u2 WITH ADMIN OPTION;

-- 회수
REVOKE r_analyst FROM u2;
```

### PostgreSQL

```sql
GRANT CONNECT ON DATABASE mydb TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public
  GRANT SELECT ON TABLES TO app_user;
```

### MySQL

```sql
GRANT SELECT (id, name) ON mydb.people TO 'report'@'%';
REVOKE UPDATE ON mydb.people FROM 'report'@'%';
```

### SQL Server

```sql
GRANT SELECT ON SCHEMA::dbo TO report_role;
DENY UPDATE ON OBJECT::dbo.Customers TO report_user;
REVOKE SELECT ON OBJECT::dbo.Customers TO report_user; -- 회수
```

---

## 맺음말

- DCL은 “명령어”가 아니라 **보안 운영의 체계**다.
- **RBAC + 최소 권한 + 감사**는 필수 삼총사, 여기에 **RLS/VIEW/PROC** 패턴을 더해 **안전한 데이터 노출 설계**를 완성하라.
- 엔진별 차이는 스크립트/자동화로 표준화하고, **WITH GRANT/ADMIN OPTION** 과 **DENY** 의 파급효과를 항상 점검하라.
- 마지막으로, 권한은 **부여보다 회수가 어렵다**. “줄 때는 작게, 늘릴 때는 단계별로, 기록은 상세히.”
