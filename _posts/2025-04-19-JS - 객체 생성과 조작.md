---
layout: post
title: JavaScript - 객체 생성과 조작
date: 2025-04-19 19:20:23 +0900
category: JavaScript
---
# 객체 생성과 조작 (JavaScript Object Basics)

## 0. 핵심 로드맵

- **생성**: 리터럴 → `Object.create(proto)` → 생성자/클래스
- **모양(Shape)**: 데이터 프로퍼티 vs 접근자 프로퍼티, 속성 기술자(`writable`, `enumerable`, `configurable`)
- **상속**: `[[Prototype]]`(프로토타입 체인)과 메서드 조회
- **조작**: 추가/수정/삭제, 안전한 병합, 얕은/깊은 복사
- **검사/순회**: `in`/`hasOwn`/`hasOwnProperty`, `for...in` vs `Object.keys/values/entries`, `Object.getOwnPropertyNames/Symbols`, 키 순서 규칙
- **보호**: `freeze`/`seal`/`preventExtensions`
- **모던 문법**: 구조분해, 나머지/스프레드, 선택적 체이닝, Nullish 병합, 클래스 필드/접근자
- **메타**: `Reflect`·`Proxy`, `Symbol` 키, `WeakMap`으로 프라이빗 데이터
- **직렬화**: `JSON.stringify` 한계 vs `structuredClone`

---

## 1. 객체 생성 방법(확장)

### 1.1 리터럴(Literal)
```js
const user = { name: "Alice", age: 25, isAdmin: true };
```
- 가장 빠르고, 엔진 최적화가 잘 된다(정적 모양/shape).

### 1.2 `Object.create(proto[, descriptors])`
```js
const proto = { greet() { console.log("hi"); } };
const user = Object.create(proto, {
  name: { value: "Eve", writable: true, enumerable: true, configurable: true }
});
user.greet();            // "hi"
console.log(user.name);  // "Eve"
```
- **정확한 프로토타입 지정** + **초기 속성 기술자** 설정 가능.
- 라이브러리/프레임워크에서 객체 모양을 제어할 때 유용.

### 1.3 생성자 함수(함수형 생성자)
```js
function User(name, age) {
  this.name = name;
  this.age = age;
}
User.prototype.say = function() { return `Hi, ${this.name}`; };

const u = new User("Charlie", 28);
console.log(u.say());
```
- `new` 호출 시 `this`는 `User.prototype`을 상속하는 새 객체가 된다.

### 1.4 클래스(Class, ES6+)
```js
class User {
  #secret = 42;                    // 프라이빗 필드(클래스 스코프)
  constructor(name, age) { this.name = name; this.age = age; }
  get isAdult() { return this.age >= 18; }   // 접근자 프로퍼티
  sayHi() { return `Hi, I'm ${this.name}`; } // 프로토타입 메서드
}
const u = new User("Dana", 22);
console.log(u.isAdult, u.sayHi());
```
- 문법 설탕이지만 **프로토타입 기반**. 프라이빗 필드 `#x`는 외부 접근 불가.

---

## 2. 프로퍼티 접근과 키

### 2.1 점/대괄호
```js
const user = { "first-name": "Kim", level: 3 };
console.log(user.level);          // 3
console.log(user["first-name"]);  // "Kim"
const key = "level";
console.log(user[key]);           // 3
```
- **동적 키/특수문자 키**는 대괄호만 가능.

### 2.2 Symbol 키(충돌 없는 메타데이터)
```js
const ID = Symbol("id");
const obj = { [ID]: 123, name: "Alice" };
console.log(Object.keys(obj));             // ["name"] (심볼은 제외)
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(id)]
```
- 라이브러리 간 프로퍼티 이름 충돌 방지에 유용.

---

## 3. 추가/수정/삭제 — 속성 기술자 관점

### 3.1 단순 조작
```js
const user = { name: "Alice" };
user.email = "a@ex.com";   // 추가
user.name = "Alicia";      // 수정
delete user.email;         // 삭제
```

### 3.2 속성 기술자(Descriptor)
```js
const obj = {};
Object.defineProperty(obj, "x", {
  value: 10, writable: false, enumerable: true, configurable: false
});
console.log(obj.x);  // 10
obj.x = 20;          // 무시(비엄격) / TypeError(엄격)
```
- `writable`: 값 변경 가능 여부
- `enumerable`: 열거 대상 여부(`for...in`, `Object.keys`)
- `configurable`: 삭제/재정의 가능 여부

### 3.3 접근자 프로퍼티(get/set)
```js
const size = {
  _w: 100,
  get w() { return this._w; },
  set w(v) { if (v > 0) this._w = v; }
};
size.w = 200;
console.log(size.w); // 200
```
- 계산/검증/캐싱 로직을 숨길 때 사용.

---

## 4. 프로토타입 체인과 메서드 조회

### 4.1 [[Prototype]] 흐름
```js
const proto = { a: 1 };
const child = Object.create(proto);
child.b = 2;

console.log(child.a);           // 1 (체인을 따라 proto에서 조회)
console.log("a" in child);      // true (체인 포함)
console.log(child.hasOwnProperty("a")); // false (자기 소유만)
```

### 4.2 상속 관계 확인/설정
```js
Object.getPrototypeOf(child) === proto; // true
Object.setPrototypeOf(child, null);     // 체인 끊기(주의: 성능 저하 가능)
```

### 4.3 메서드 오버라이드와 super(객체 리터럴)
```js
const base = { hi(){ return "base"; } };
const obj = {
  __proto__: base,
  hi(){ return super.hi() + " + obj"; }
};
console.log(obj.hi()); // "base + obj"
```

---

## 5. 객체 검사 — 소유/존재/타입

```js
const o = Object.create({ z: 3 });
o.x = 1;

console.log("x" in o);                  // true
console.log("z" in o);                  // true (프로토타입)
console.log(Object.hasOwn(o, "x"));     // true (ES13+)
console.log(o.hasOwnProperty("x"));     // true

console.log(typeof o === "object");     // 객체/배열/함수 구분 어려움
console.log(Array.isArray(o));          // 배열 판별 시 권장
```

> `in`은 체인을 포함, `hasOwn`/`hasOwnProperty`는 **자기 소유**만.

---

## 6. 순회 — 열거/소유/순서의 차이

### 6.1 `for...in` (열거 가능 + 체인 포함)
```js
const p = { a:1 };
const o = Object.create(p, {
  b: { value: 2, enumerable: true },
  c: { value: 3, enumerable: false }
});
for (const k in o) console.log(k); // "b", "a" (c는 비열거, a는 체인)
```

### 6.2 소유 키/값/엔트리
```js
Object.keys(o);    // ["b"]
Object.values(o);  // [2]
Object.entries(o); // [["b",2]]
```

### 6.3 모든 소유 키(비열거 포함)
```js
Object.getOwnPropertyNames(o);   // ["b","c"]
Object.getOwnPropertySymbols(o); // [ ...심볼들 ]
Reflect.ownKeys(o);              // 모든 키(문자열+심볼)
```

### 6.4 키 순서 규칙(요약)
1. **정수형 키(배열 인덱스 문자열)** 오름차순
2. 그 외 문자열 키 **정의 순서**
3. **Symbol 키** 정의 순서

---

## 7. 얕은 복사 vs 깊은 복사

### 7.1 얕은 복사(Assign/Spread)
```js
const original = { a: 1, nested: { x: 10 } };
const copy1 = Object.assign({}, original);
const copy2 = { ...original };

copy1.nested.x = 99;
console.log(original.nested.x);  // 99 (참조 공유)
```

### 7.2 깊은 복사(간단 옵션)

- **브라우저/Node 17+**: `structuredClone`
```js
const deep = structuredClone(original);
deep.nested.x = 77;
console.log(original.nested.x); // 10
```
- **JSON 직렬화**: 함수/심볼/순환 참조 누락, Date 손실 → 권장하지 않음.
```js
const cloned = JSON.parse(JSON.stringify(original)); // 제약 많음
```

### 7.3 커스텀(순환 참조 처리)
```js
function deepClone(obj, seen = new Map()) {
  if (obj === null || typeof obj !== "object") return obj;
  if (seen.has(obj)) return seen.get(obj);

  const out = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
  seen.set(obj, out);
  for (const key of Reflect.ownKeys(obj)) {
    const desc = Object.getOwnPropertyDescriptor(obj, key);
    if ("value" in desc) desc.value = deepClone(desc.value, seen);
    Object.defineProperty(out, key, desc);
  }
  return out;
}
```
- **Descriptor 보존** + **프로토타입 유지** + **순환 참조** 지원.

---

## 8. 구조 분해/스프레드/나머지

```js
const user = { name: "Alice", age: 25, city: "Seoul" };
const { name, ...rest } = user;
console.log(name); // "Alice"
console.log(rest); // { age: 25, city: "Seoul" }

const defaults = { dark:false, pageSize:20 };
const overrides = { pageSize:50 };
const merged = { ...defaults, ...overrides }; // 오른쪽 우선
```

- **얕은 병합**임을 항상 기억. 중첩은 별도 병합 로직 필요.

---

## 9. 안전한 접근과 기본값

### 9.1 선택적 체이닝 `?.` + Nullish 병합 `??`
```js
const user2 = { profile: { addr: { city: "Seoul" } } };
console.log(user2.profile?.addr?.city ?? "N/A"); // "Seoul"
console.log(user2.company?.name ?? "(none)");    // "(none)"
```

### 9.2 기본값과 단락 평가
```js
function init(cfg = {}) {
  const port = cfg.port ?? 8080; // 0 허용
  const verbose = !!cfg.verbose;
  return { port, verbose };
}
```

---

## 10. 불변 패턴(Immutable Update)

```js
const state = { user: { name: "A", tags: ["js"] } };
// 이름 바꾸기(불변)
const newState = {
  ...state,
  user: { ...state.user, name: "B" }
};
// 배열 추가(불변)
const newState2 = {
  ...state,
  user: { ...state.user, tags: [...state.user.tags, "node"] }
};
```
- 리액트/리덕스/신뢰성 높은 변경 추적에 필수.

---

## 11. 객체 보호 — 동결/봉인/확장 금지

```js
const o = { a: 1 };
Object.preventExtensions(o); // 새 프로퍼티 추가 불가
Object.seal(o);              // 추가/삭제 불가(값 수정 가능 if writable)
Object.freeze(o);            // 추가/삭제/수정 모두 불가
```

검사:
```js
Object.isExtensible(o); // false
Object.isSealed(o);     // true/false
Object.isFrozen(o);     // true/false
```

> **깊은 불변**이 아님(중첩 객체는 별도 처리 필요): 재귀적으로 `freeze`하거나 **구현 정책으로 불변 패턴 유지**.

---

## 12. 객체 병합과 충돌 처리

### 12.1 우선순위 기반 병합
```js
const base = { a:1, nested:{x:1}, list:[1] };
const extra = { b:2, nested:{y:2}, list:[2] };
const merged = { ...base, ...extra };
// merged.nested -> { y:2 } (x 사라짐), list -> [2] (대체)
```
- 중첩을 **머지**하려면 커스텀 deep merge가 필요.

### 12.2 안전한 Deep Merge(간단 버전)
```js
function deepMerge(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) return [...a, ...b];
  if (a && typeof a === "object" && b && typeof b === "object") {
    const out = { ...a };
    for (const k of Reflect.ownKeys(b)) {
      out[k] = k in a ? deepMerge(a[k], b[k]) : deepClone(b[k]);
    }
    return out;
  }
  return deepClone(b);
}
```

---

## 13. 직렬화 — `JSON` 한계와 대안

```js
const data = { d: new Date(), set: new Set([1,2]), fn(){}, sym: Symbol() };
console.log(JSON.stringify(data)); // {"d":"2025-11-09T..."} (함수/심볼 누락, Set 무시)
```
- `Date`는 문자열로, `Set/Map/BigInt/함수/심볼`은 손실.
- **대안**: `structuredClone`(대부분 지원), 커스텀 replacer/reviver, 라이브러리(예: superjson).

---

## 14. 성능·메모리 관점 팁

- **리터럴/일관된 모양(shape)** → 히든 클래스 최적화에 유리.
- 실행 중 **프로퍼티를 임의로 추가/삭제**하면 모양이 변해 JIT 최적화가 깨질 수 있다. 필요 키는 미리 정의.
- 빈번한 읽기는 **프로토타입 체인 짧게** 유지.
- 대량 키-값 저장/삭제는 **`Map`/`Set`**가 유리(순회/크기/성능 측면).

---

## 15. Map/WeakMap vs 일반 객체

```js
const m = new Map([["a",1],["b",2]]);
m.get("a"); m.set("c",3); m.size; m.has("b"); m.delete("b");

const wm = new WeakMap();
const key = {};
wm.set(key, { secret: 123 });
// key가 GC되면 엔트리도 수거(메모리 누수 완화)
```
- **객체 키**만 허용(WeakMap), **GC 친화**.
- 프라이빗 데이터 저장에 이상적(외부에서 열거 불가).

---

## 16. 값 변환(ToPrimitive)과 사용자 정의 표시

```js
const price = {
  amount: 1000,
  [Symbol.toPrimitive](hint) {
    return hint === "string" ? `$${this.amount}` : this.amount;
  }
};
String(price);  // "$1000"
price + 500;    // 1500
```
- 로깅/템플릿/산술 컨텍스트에서의 동작 제어.

---

## 17. Reflect와 Proxy — 메타 프로그래밍

### 17.1 Reflect로 일관 API 사용
```js
const obj = {};
Reflect.defineProperty(obj, "x", { value: 1, writable: true });
Reflect.get(obj, "x");         // 1
Reflect.ownKeys(obj);          // ["x"]
Reflect.has(obj, "x");         // true
```
- `Object.*` 대비 **반환값이 일관되고 예외 대신 boolean** 제공(일부 메서드).

### 17.2 Proxy로 접근 가로채기
```js
const target = { a: 1 };
const p = new Proxy(target, {
  get(t, k, r) {
    console.log("get", k);
    return Reflect.get(t, k, r);
  },
  set(t, k, v, r) {
    console.log("set", k, v);
    return Reflect.set(t, k, v, r);
  }
});
p.a;     // 로그: get a
p.b = 2; // 로그: set b 2
```
- 검증/로깅/가상 프로퍼티/불변 강제 등 다양한 패턴에 활용.

---

## 18. 실전 레시피 모음

### 18.1 안전한 읽기 + 기본값
```js
function read(cfg) {
  const host = cfg?.net?.host ?? "localhost";
  const port = cfg?.net?.port ?? 8080;
  return { host, port };
}
```

### 18.2 디폴트 + 오버라이드(얕은)
```js
const defaults = Object.freeze({ timeout: 5000, retries: 2 });
const cfg = { retries: 5 };
const final = { ...defaults, ...cfg }; // { timeout: 5000, retries: 5 }
```

### 18.3 접근자와 내부 상태 은닉
```js
function makeCounter() {
  let c = 0;
  return {
    get value() { return c; },
    inc() { c++; }
  };
}
const ctr = makeCounter();
ctr.inc(); console.log(ctr.value); // 1
```

### 18.4 객체 → `Map` 변환(정렬/빈번한 삽입삭제)
```js
const obj = { a:1, b:2 };
const map = new Map(Object.entries(obj));
map.set("c",3).delete("a");
```

### 18.5 깊은 동결(재귀)
```js
function deepFreeze(o) {
  for (const k of Reflect.ownKeys(o)) {
    const v = o[k];
    if (v && typeof v === "object") deepFreeze(v);
  }
  return Object.freeze(o);
}
```

---

## 19. 디버깅/점검 체크리스트

- [ ] 값이 없을 수 있으면 **`?.` + `??`**로 방어.
- [ ] 배열에 **`for...in` 금지**, 객체에만 사용(필요시 `hasOwn` 체크).
- [ ] **얕은 복사**와 **깊은 복사** 구분.
- [ ] 프로토타입/열거성/기술자 구분: `getOwnPropertyDescriptor(s)`, `ownKeys`.
- [ ] 보호 레벨 선택: `preventExtensions` < `seal` < `freeze`.
- [ ] 대량 키-값은 **Map/Set**, 프라이빗은 **WeakMap**.
- [ ] JSON 직렬화 한계 인지, 가능하면 **structuredClone**.

---

## 20. 미니 퀴즈

```js
// Q1: 결과는?
const p = { a:1 };
const o = Object.create(p, { b:{ value:2, enumerable:true }, c:{ value:3 } });
console.log(Object.keys(o));         // ?
console.log("a" in o, o.hasOwnProperty("a")); // ?

// Q2: 얕은 vs 깊은
const src = { x:{ y:1 } };
const s1 = { ...src };
const s2 = structuredClone(src);
s1.x.y = 9; console.log(src.x.y, s2.x.y); // ?

// Q3: 접근자
const obj = {
  _n: 0,
  get n(){ return this._n; },
  set n(v){ if(v>=0) this._n=v; }
};
obj.n = -1; console.log(obj.n); // ?
obj.n = 5;  console.log(obj.n); // ?

// Q4: 순회
const k = Symbol("k");
const t = { 2:"b", 1:"a", [k]:"sym", z:"z" };
console.log(Reflect.ownKeys(t)); // 순서?
```

**힌트**
- Q1: `Object.keys(o)`는 열거 가능한 **소유**만 → `["b"]`. `"a" in o`는 true, `hasOwnProperty("a")`는 false.
- Q2: 얕은 복사 공유로 `src.x.y`는 9, `s2.x.y`는 1.
- Q3: 검증 로직으로 음수 무시 → 0, 이후 5.
- Q4: 정수 키 `"1","2"` → 오름차순, 그다음 `"z"`, 마지막 심볼 → `["1","2","z", Symbol(k)]`.

---

## 21. 결론

자바스크립트 객체는 **프로토타입 + 속성 기술자**의 조합으로 동작한다.
생성은 간단히 **리터럴**로 시작하되, **`Object.create`**로 프로토타입과 기술자를 정확히 제어할 수 있고, **클래스**로 구조화할 수 있다.
조작 시에는 **얕은/깊은 복사 구분**, **열거/소유/순서 규칙**을 인지하고, **선택적 체이닝/Nullish 병합**으로 안정성을 확보하라.
보호가 필요하면 **freeze/seal/preventExtensions**를 목적에 맞게 선택하고, 프라이빗/메타 로직은 **WeakMap/Reflect/Proxy**로 구현하라.
이 원리를 이해하면, 유지보수성·안정성·성능을 모두 잡는 **견고한 객체 설계**가 가능해진다.
