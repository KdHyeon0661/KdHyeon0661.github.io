---
layout: post
title: 형식언어와 오토마타 - 튜링 기계의 다른 모델들
date: 2025-07-30 20:20:23 +0900
category: 형식언어와 오토마타
---
# 튜링 기계의 **다른 모델들** — 작은 변형, 동등성, Stay-이동, 일방 무한 테이프, 오프라인 TM

> 핵심 메시지  
> - “합리적인” 변형(Stay 이동, 일방 무한 테이프, 오프라인 입력, 다중 테이프/트랙/헤드 등)은 **계산 가능성(what)** 을 바꾸지 않는다.  
> - 서로를 **유효한 인코딩**으로 모사할 수 있고, 비용은 **상수~다항 오버헤드** 안에 든다.  
> - 차이는 **효율(시간/공간)** 의 상수·다항 인자뿐이다.

---

## 0) 표준 TM 요약(기본 기준점)

표준(단일 테이프) TM은 7-튜플
\[
M=(Q,\Sigma,\Gamma,\delta,q_0,q_{\mathrm{acc}},q_{\mathrm{rej}})
\]
- \(\Sigma\) 입력 알파벳(\(\sqcup\notin\Sigma\)), \(\Gamma\supseteq\Sigma\) 테이프 알파벳(\(\sqcup\in\Gamma\))  
- \(\delta:Q\times\Gamma\to Q\times\Gamma\times\{L,R\}\)  
- 입력은 왼쪽부터 쓰고 나머지는 \(\sqcup\)  
- \(q_{\mathrm{acc}},q_{\mathrm{rej}}\) 도달 시 정지

---

## 1) “작은 변형들” — **동등성**과 모사 직관

### 1.1 알파벳, 공백, 좌끝 표식
- 유한 알파벳 크기 변경은 **이진 인코딩/묶음 기법**으로 상호 모사 가능.  
- **좌끝 표식** ⊢ 을 두거나 말거나: 필요하면 첫 칸에 ⊢ 를 쓰고 **보존 불변식**으로 관리.

### 1.2 다중 테이프 · 다중 트랙 · 다중 헤드
- **다중 테이프 \(\Rightarrow\) 단일 테이프**: 섹션을 나열(구분자 사용) + 왕복 스캔으로 **1 스텝 모사**, 총 \(O(T(n)^2)\) 고전 상한.  
- **다중 트랙**: 한 칸에 여러 레지스터 → **평탄화**(문자 곱 알파벳)로 즉시 단일 트랙화.  
- **다중 헤드**: 각 헤드 위치를 마커로 코딩하고 지그재그 스캔으로 동기화.

### 1.3 양방향 무한 ↔ **일방(좌끝만) 무한** 테이프
- 좌표 \(\mathbb{Z}\)를 \(\mathbb{N}\)으로 **전단사 열거(지그재그)** 해 저장 → **동등** (§4).

### 1.4 **Stay(S)** 이동 허용
- \(\{L,R,S\}\) 허용 모델은 **상수배 단계**로 S-이동을 제거 가능(§3).

> 결론: 위 변형들은 **RE/REC 경계**를 바꾸지 않는다. (효율 상수·다항만 변동)

---

## 2) 큰 그림: 모델 ↔ 언어 계층

| 모델 | 인식/생성 언어 |
|---|---|
| DFA/NFA/정규식 | 정규 REG |
| PDA(비결정)/CFG | 문맥 자유 CFL |
| LBA/CSG | 문맥 인식 CSL |
| TM(수용) / RE-문법 | 재귀적 열거 RE |
| TM(결정) | 재귀적(결정 가능) REC |

※ TM에서 결정적/비결정적은 **무엇을** 계산하느냐(RE/REC)는 같고, **얼마나 빠르냐**(복잡도)는 다를 수 있음.

---

## 3) **Stay(S)-이동** 보유 TM → 표준 TM( L/R 만 )

### 3.1 정의 확장
\[
\delta: Q\times\Gamma \to Q\times\Gamma\times\{L,R,S\}
\]
\(S\): 헤드 위치 **유지**.

### 3.2 제거(표준 모사 매크로)
아이디어: “제자리 쓰고 끝”을 **R→L 왕복**으로 흉내.

- 기본 매크로
```
# (q, a) -> (q', b, S)  를 모사
(q,  a)   -> (q_tmp, b, R)
(q_tmp, c)-> (q',    c, L)   # c는 임의 기호(알파벳 전체에 대해 동일 동작)
```

- 좌끝 경계(⊢) 안전 처리
```
(q_tmp, ⊢) -> (q_tmp, ⊢, R)  # L로 나갈 수 없으니 한 칸 더 R 후 다음 단계에서 L
```

- **시간 오버헤드**: S 한 번당 **정수(2~3)** 단계.  
- **공간 오버헤드**: 상수.

---

## 4) **일방(좌끝) 무한 테이프**로 **양방향** 테이프 모사

### 4.1 지그재그 인코딩 \(\phi:\mathbb{Z}\to\mathbb{N}\)
\[
\phi(0)=0,\ \phi(1)=1,\ \phi(-1)=2,\ \phi(2)=3,\ \phi(-2)=4,\ldots
\]
```
index N:  0   1   2   3   4   5   6   ...
Z-cell :  0  +1  -1  +2  -2  +3  -3  ...
```
- 2D 좌표 대신 1D지만, 여기선 “좌/우 정수선”을 지그재그로 포장.  
- 실제 헤드 좌표 \(i\in\mathbb{Z}\)를 \(\phi(i)\) 위치에 저장/참조.

### 4.2 전이 모사
- 원기계가 \((q,a)\to(q',b,\mathrm{E/W})\) 라면:  
  1) 일방 테이프의 \(\phi(i)\) 칸에서 \(a\) 확인·\(b\) 기록  
  2) \(i\leftarrow i\pm1\), \(\phi(i)\) 로 **점프**(유한 제어가 \(i\)의 부호/증감을 상태로 추적)  
- \(\phi\)·\(\phi^{-1}\) 는 **유한상태 + 마커**로 충분(정확 좌표값을 테이프에 유지할 필요 없이 “현재가 짝수면 음수쪽, 홀수면 양수쪽” 류의 규칙으로 이동).

### 4.3 복잡도
- 한 칸 이동을 **상수~소수 단계**로 흉내 가능(구현 세부에 따라 약간의 상수 차).  
- 전반적으로 **다항 시간 안**에 모사(고전 교재 기준).

> 다른 전형: “원점 마커 + 블록 시프트” — 원점 넘나들 때만 국소 재배치. 역시 다항 오버헤드.

---

## 5) **오프라인(Off-line) TM** — 입력 분리 모델

### 5.1 정의
- **입력 테이프**: 읽기 전용, 양방향 이동 가능, 변경 불가.  
- **작업 테이프(들)**: 읽기-쓰기, 초기 공백.

### 5.2 동등성
- **오프라인 → 표준**: 시작에 입력을 작업 영역에 **복사**(\(O(n)\)) 후 표준처럼 동작.  
- **표준 → 오프라인**: 단일 테이프를 “논리적 분할”(입력 구간을 읽기 전용으로 취급) + 작업 테이프에 변경사항 반영.

### 5.3 복잡도 해석
- **시간**: 최대 선형 초기화 + 나머지 동일 계열.  
- **공간**: 작업 테이프 공간 = 알고리즘 보조 공간(복잡도 클래스 L, NL, PSPACE 분석에 적합).

---

## 6) 다중 요소들(테이프/트랙/헤드) — 구성 개요와 오버헤드

### 6.1 k-테이프 → 1-테이프 (고전 스윕)
- 테이프 내용을 `[ #1 ... ^a ... | #2 ... ^b ... | ... | #k ... ]` 로 **구획**  
- 한 스텝 모사:
  1) 왼→오른쪽 스캔으로 각 헤드 아래 기호 수집  
  2) \(\delta\) 계산  
  3) 재스캔하며 쓰기·마커 이동  
- 총 \(T(n)\) 스텝 → 길이 선형 증가 → **\(O(T(n)^2)\)**.

### 6.2 다중 트랙
- 알파벳을 곱 \(\Gamma_1\times\cdots\times\Gamma_m\) 로 확장하여 **단일 칸**에 누적 저장.

### 6.3 다중 헤드
- 각 헤드의 위치를 **마커**로 표시하고, 지그재그 스캔으로 순차 **동기화**.  
- 한 스텝당 상수~작은 상수 팩터의 추가 왕복.

---

## 7) **작동 예시 시나리오** (설계 → 변형 → 모사)

### 7.1 예시 A — 팰린드롬 \(\{ ww^R \}\) 판정 (S-이동 사용 → 제거)
- **아이디어**: 좌우 끝에서 중앙으로 수렴 비교.  
- **S-이동 버전 스니펫**
```
(q_scanL, a) -> (q_holdL, a, S)     # 왼끝 글자 고정(S)
(q_holdL, b) -> (q_seekR, b, R)     # 오른쪽으로 달려가서 짝 찾기
...
(q_cmp,  a) -> (q_ok,   a, S)       # 같은 글자면 S로 제자리 성공 표시
(q_ok,   c) -> (q_back, c, L)
```
- **S 제거**: 위 S 전이를 모두 §3의 매크로로 치환(R→L 왕복).  
- **정확성**: 왕복은 “헤드 제자리 유지”와 동치이므로 언어 보존.

### 7.2 예시 B — 양방향 테이프 버전 → 일방 테이프로
- **원 설계**: 원점에서 좌/우로 탐색하며 마커를 이동.  
- **모사**: 지그재그 \(\phi\) 로 칸 재배치. 원점 0은 N=0 칸, +1은 N=1, -1은 N=2 …  
- **주의**: 원점 경계 넘기 전후의 이동이 번갈아가며 홀/짝 패턴을 보이므로, **상태 플래그(부호/홀짝)** 로 처리.

### 7.3 예시 C — 오프라인 TM로 괄호 균형
- **입력 테이프**: `(`, `)` 읽기 전용.  
- **작업 테이프**: 스택 역할(`(` push, 짝 발견 시 pop).  
- **수용**: 끝에서 스택이 비면 ACCEPT.  
- **표준 TM와 동등**: 입력을 수정하지 않는다는 점 외엔 동일 논리.

---

## 8) 미니 **교육용 코드** — 개념 확인용(간단 TM 인터프리터 & 모사기)

> 목적: (a) **S-이동 제거**가 상수 단계로 가능함을 코드 수준에서 보여주고,  
> (b) **양방향→일방** 지그재그 인덱싱 \(\phi\) 를 계산해본다.  
> (실행 환경에 의존 없이 읽기용으로 충분합니다.)

### 8.1 S-이동 제거 “컴파일러” (규칙 변환)
```python
# rules: dict[(q, a)] = (q', b, move)  where move in {'L','R','S'}
# 출력: S를 제거한 rules'
from collections import defaultdict

def remove_stay(rules, blank='_'):
    new_rules = dict()
    tmp_count = 0

    def fresh(base):
        nonlocal tmp_count
        tmp_count += 1
        return f"{base}__tmp{tmp_count}"

    # 알파벳/상태 스캔(단순화를 위해 규칙에 등장하는 기호만 사용)
    states = {q for (q, _a) in rules} | {q for (q, _a), (qp, _b, _m) in rules.items()}
    gamma  = {a for (_q, a) in rules} | {b for (_qa, ( _qb, b, _m)) in rules.items()}
    gamma.add(blank)

    for (q, a), (qp, b, m) in rules.items():
        if m != 'S':
            new_rules[(q, a)] = (qp, b, m)
        else:
            qtmp = fresh(q)
            # (q, a) -> (qtmp, b, R)
            new_rules[(q, a)] = (qtmp, b, 'R')
            # (qtmp, c) -> (qp, c, L) for all c
            for c in gamma:
                new_rules[(qtmp, c)] = (qp, c, 'L')
    return new_rules
```

### 8.2 지그재그 \(\phi,\phi^{-1}\) (양방향↔일방 좌표)
```python
def phi(z):
    # Z -> N
    if z >= 0:
        return 2*z if z==0 else 2*z - 1  # 0->0, +1->1, +2->3, ...
    else:
        return -2*z                       # -1->2, -2->4, ...

def phi_inv(n):
    # N -> Z
    if n == 0: return 0
    if n % 2 == 1:
        # odd: +1 -> 1, +2 -> 3, ...
        return (n+1)//2
    else:
        # even: 2->-1, 4->-2, ...
        return -n//2
```

> 실 TM 모사에서는 \(\phi\) 값을 직접 저장하기보다 **부호/홀짝 플래그** 상태로 이동을 구현하는 쪽이 전형적(상태기계로 충분).

---

## 9) 자주 묻는 포인트(FAQ) · 함정

1. **S-이동이 없으면 표현력이 약해지나?** → 전혀 아님. R→L 왕복으로 상수배에 모사.  
2. **일방 테이프로 음수 좌표를 어떻게?** → \(\phi\) 같은 전단사 열거로 충실히 복원 가능.  
3. **다중 테이프는 왜 빠른가?** → 설계가 직관적이고, 한 스텝에 “병행” 접근. 하지만 단일 테이프에서 \(O(T^2)\) 로 모사 가능.  
4. **오프라인 TM은 현실적?** → 입력을 파괴하지 않는 모델로, 파서/스트리밍/공간분석에 매우 자연스럽다.  
5. **결정성/비결정성** → 무엇을 계산하는가(RE/REC)는 같지만, 시간/공간 복잡도에서 차이가 중요(P vs NP 등).

---

## 10) 복잡도 요약 표(모사 오버헤드)

| 변형 → 표준 모사 | 시간 | 공간 | 메모 |
|---|---|---|---|
| S 포함 → S 미포함 | 상수배 | 상수 | R→L 왕복 매크로 |
| k-테이프 → 1-테이프 | \(O(T^2)\) | \(O(S)\) | 고전 스윕 구성 |
| 양방향 → 일방 | 상수~다항 | 상수 | 지그재그/원점-시프트 |
| 오프라인 → 표준 | \(O(n)\) 초기 + 동일 | 동일 | 처음에 입력 복사 |

---

## 11) 체크리스트(설계→모사 절차)

- [ ] 원 모델의 **불변식**(마커, 좌끝, 공백 규칙) 명시  
- [ ] 사용 알파벳 **폐쇄성** 확인(표식 추가 시 규칙 확장)  
- [ ] **S-이동** 존재 시 매크로 치환(경계 예외 처리 포함)  
- [ ] **좌/우 방향성** 차이는 \(\phi\) 또는 원점-시프트로 해결  
- [ ] 다중 테이프는 **구획/왕복 스윕**으로 1-테이프화  
- [ ] 오프라인은 **입력 복사/필터링**으로 표준화  
- [ ] 복잡도 상한(상수·다항) 명시

---

## 12) 한 페이지 요약

- **동등성**: Stay, 일방/양방, 오프라인, 다중 테이프/트랙/헤드 — 모두 **표준 TM과 동등**(RE/REC 불변).  
- **모사법**:  
  - S→R→L 왕복,  
  - \(\mathbb{Z}\to\mathbb{N}\) 지그재그 \(\phi\),  
  - 구획·왕복 스윕,  
  - 입력 분리/복사.  
- **복잡도**: 시간/공간에 상수~다항 오버헤드만 추가.  
- **실무 감각**: 모델 변형은 **설계 편의/효율**을 바꾸는 수단이지, **계산 가능성**의 경계를 바꾸지 않는다.

---

### (보너스) 아주 작은 실습 과제
1) 위 `remove_stay` 로 임의 규칙 집합의 S-이동을 제거해 보라(규칙 수 증가 관찰).  
2) `phi/phi_inv` 로 \(-5..+5\) 를 변환·역변환하여 일치성 확인.  
3) 다중 테이프 팰린드롬 TM을 **1-테이프 모사** 스텝으로 손으로 3~4단계 추적해 보라.