---
layout: post
title: Java - 로깅
date: 2025-08-18 15:25:23 +0900
category: Java
---
# 로깅 (java.util.logging, Log4j/Log4j2, SLF4J)

## 2025-11 버전 스냅샷

| 컴포넌트 | 최신 참고 버전(예) | 출처 |
|---|---:|---|
| Log4j **2.25.x** (2.25.2 API 문서 공개) | 2.25.2 |
| Log4j 2.25.0 릴리스(2025-06-13) | 2.25.0 |
| Log4j **2.25.1** 릴리스 공지(2025-07-11) | 2.25.1 |
| SLF4J API 2.0.x (예: 2.0.17) | 2.0.17 |
| Logback Classic 1.5.x (예: 1.5.15) | 1.5.15 |
| logstash-logback-encoder (JSON) (예: 8.0) | 8.0 |

> 참고: Log4j 1.x는 **EOL**이다. 새 프로젝트/운영 환경에서는 사용하지 말 것. (Apache 공지)

---

## 공통 핵심 개념

### 로그 레벨

- 일반적 순서(높음→낮음): **FATAL/SEVERE > ERROR > WARN > INFO > DEBUG > TRACE**
- JUL은 `SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST`를 사용(레벨 매핑 필요)

### 로거 계층과 전파(Additivity)

- 패키지/클래스명을 이름으로 하는 **계층 로거**. 상위의 레벨/핸들러(또는 Appender)가 하위로 **전파**될 수 있음
- 일부 구현(Log4j2/Logback)은 `additivity="false"`(Log4j2)나 명시적 Appender 바인딩으로 전파를 끊을 수 있음

### 출력 대상과 포맷

- **콘솔, 파일(시간/사이즈 롤링), 원격 수집(Syslog, Socket, HTTP), JSON 구조화** 등
- **MDC**(Mapped Diagnostic Context) / **ThreadContext**로 **요청 ID, 사용자 ID** 등을 로그에 주입 → 추적성↑

### 성능 팁

- **파라미터화 메시지** 사용: `logger.debug("u={} took={}ms", u, took)`
- **비동기 로깅**(Log4j2 AsyncLogger / Logback AsyncAppender)로 I/O 병목 완화
- DEBUG/TRACE는 운영에서 **샘플링** 또는 **조건부 활성화**

---

## java.util.logging (JUL)

### 특징

- JDK 내장. 외부 의존성 없음
- 단, Appender/플러그인 다양성/설정 유연성은 Log4j2/Logback 대비 제한

### 간단 사용

```java
import java.util.logging.Logger;
import java.util.logging.Level;

public class JulExample {
    private static final Logger log = Logger.getLogger(JulExample.class.getName());

    public static void main(String[] args) {
        log.info("정보 로그");
        log.log(Level.WARNING, "경고: {0}", "상태 이상");
        if (log.isLoggable(Level.FINE)) {
            log.fine("자세한 디버그 정보");
        }
    }
}
```

### `logging.properties` 설정

JVM 옵션: `-Djava.util.logging.config.file=path/logging.properties`
```properties
.level = INFO
handlers = java.util.logging.ConsoleHandler

java.util.logging.ConsoleHandler.level = INFO
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter

com.myapp.level = FINE
```

> JUL을 프로젝트 표준으로 쓰지 않을 경우, **SLF4J 브리지**로 단일화하는 것을 권장(§5).

---

## Log4j2

### 왜 Log4j2인가

- **Async Logger**(LMAX Disruptor 기반)로 고성능
- 다양한 Appender(파일 롤링, Syslog, Socket, JDBC, JSON 등), 유연한 Layout/필터

### 의존성 (Maven 예)

```xml
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-api</artifactId>
  <version>2.25.1</version>
</dependency>
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-core</artifactId>
  <version>2.25.1</version>
</dependency>
```
> 2.25.x 라인 참고(2025). 릴리스/보안 공지는 Apache 페이지를 확인.

### 사용 코드

```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class L4j2Example {
    private static final Logger log = LogManager.getLogger();

    public static void main(String[] args) {
        log.info("Hello {}", "Log4j2");
        log.warn("경고 발생", new RuntimeException("원인"));
    }
}
```

### `log4j2.xml` 예시(콘솔 + 롤링 파일 + MDC)

`src/main/resources/log4j2.xml`
```xml
<Configuration status="WARN">
  <Appenders>
    <Console name="CONSOLE" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{ISO8601} %-5level [%t] %X{reqId} %c{1} - %msg%n"/>
    </Console>
    <RollingFile name="FILE" fileName="logs/app.log"
                 filePattern="logs/app-%d{yyyy-MM-dd}-%i.log.gz">
      <PatternLayout pattern="%d{ISO8601} %-5level [%t] %X{reqId} %c - %msg%n"/>
      <Policies>
        <TimeBasedTriggeringPolicy />
        <SizeBasedTriggeringPolicy size="50 MB"/>
      </Policies>
      <DefaultRolloverStrategy max="10"/>
    </RollingFile>
  </Appenders>

  <Loggers>
    <Logger name="com.myapp" level="debug" additivity="false">
      <AppenderRef ref="CONSOLE"/>
      <AppenderRef ref="FILE"/>
    </Logger>
    <Root level="info">
      <AppenderRef ref="CONSOLE"/>
    </Root>
  </Loggers>
</Configuration>
```

### 비동기 로거 활성화(전역)

- JVM 옵션:
  `-Dlog4j2.contextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector`

### MDC(ThreadContext)

```java
import org.apache.logging.log4j.ThreadContext;

ThreadContext.put("reqId", "9f1e-123");
try {
    log.info("요청 처리 시작");
} finally {
    ThreadContext.clearAll();
}
```

---

## SLF4J — 로깅 파사드

SLF4J는 **API**만 제공하고, 실제 출력은 **바인딩된 구현체**(Logback/Log4j2/JUL 등)가 담당한다.
**장점**: 애플리케이션 코드는 SLF4J만 의존 → **구현체 교체 용이**, 이질 API를 **브리지**로 통일 가능.

### 사용 코드

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Slf4jExample {
    private static final Logger log = LoggerFactory.getLogger(Slf4jExample.class);
    public static void main(String[] args) {
        String user = "alice";
        log.info("로그인 시도 user={}", user);
        log.warn("느린 응답: {} ms", 123);
        log.error("실패", new IllegalStateException("사유"));
    }
}
```

---

## 브리지(Bridge) — 혼재된 로깅을 SLF4J로 단일화

### 전략(권장)

- **JUL → SLF4J**: `jul-to-slf4j`
- **Commons-Logging(JCL) → SLF4J**: `jcl-over-slf4j`
- **Log4j 1.x → SLF4J**: `log4j-over-slf4j`
→ 그런 다음 **단 하나의 구현체**(예: Logback 또는 Log4j2)만 바인딩.

### Gradle 예시(모두 SLF4J로 모으고 Logback으로 출력)

```kotlin
dependencies {
    implementation("org.slf4j:slf4j-api:2.0.17")
    implementation("ch.qos.logback:logback-classic:1.5.15")

    // 브리지
    implementation("org.slf4j:jcl-over-slf4j:2.0.17")
    implementation("org.slf4j:jul-to-slf4j:2.0.17")
    implementation("org.slf4j:log4j-over-slf4j:2.0.17")
}
```
> JUL을 SLF4J로 라우팅할 때는 부팅 시 아래를 호출해 루트 핸들러를 제거 후 브리지를 설치하는 패턴을 사용한다.
```java
import org.slf4j.bridge.SLF4JBridgeHandler;
public class Bootstrap {
  public static void init() {
    SLF4JBridgeHandler.removeHandlersForRootLogger();
    SLF4JBridgeHandler.install();
  }
}
```

---

## Logback (Spring Boot 기본 구현체)

### 의존성(예)

```kotlin
implementation("ch.qos.logback:logback-classic:1.5.15")
implementation("org.slf4j:slf4j-api:2.0.17")
```
> 위 버전 라인은 2025-11 기준 참고.

### `logback-spring.xml` (콘솔 + 롤링 파일 + MDC)

```xml
<configuration>
  <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d{ISO8601} %-5level [%thread] %X{reqId} %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>

  <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/app.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>logs/app-%d{yyyy-MM-dd}.%i.gz</fileNamePattern>
      <timeBasedFileNamingAndTriggeringPolicy
        class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
        <maxFileSize>50MB</maxFileSize>
      </timeBasedFileNamingAndTriggeringPolicy>
      <maxHistory>14</maxHistory>
    </rollingPolicy>
    <encoder>
      <pattern>%d %-5level [%thread] %X{reqId} %logger - %msg%n</pattern>
    </encoder>
  </appender>

  <logger name="com.myapp" level="DEBUG"/>
  <root level="INFO">
    <appender-ref ref="CONSOLE"/>
    <appender-ref ref="FILE"/>
  </root>
</configuration>
```

### 비동기(Appender) — I/O 지연 최소화

```xml
<appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
  <appender-ref ref="FILE"/>
  <queueSize>8192</queueSize>
  <discardingThreshold>0</discardingThreshold>
  <neverBlock>true</neverBlock>
</appender>
```

### MDC(SLF4J API)

```java
import org.slf4j.MDC;
MDC.put("reqId", "abc-123");
try {
  log.info("처리중");
} finally {
  MDC.clear();
}
```

---

## 구조화(JSON) 로깅 & 수집

### Logback + logstash-logback-encoder

```kotlin
implementation("net.logstash.logback:logstash-logback-encoder:8.0")
```
`logback-spring.xml`:
```xml
<appender name="JSON" class="ch.qos.logback.core.rolling.RollingFileAppender">
  <file>logs/app.json</file>
  <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
    <fileNamePattern>logs/app-%d{yyyy-MM-dd}.json.gz</fileNamePattern>
  </rollingPolicy>
  <encoder class="net.logstash.logback.encoder.LogstashEncoder"/>
</appender>
```
> ELK/OpenSearch/Datadog 등에서 필드 기반 검색·집계가 쉬워진다. (버전 레퍼런스)

### 필드 설계 팁

- 공통 필드: `timestamp`, `level`, `logger`, `thread`, **`traceId/reqId`**, **`userId`**, `message`, `error.stacktrace`, `service`, `env`

---

## Spring Boot 연계

### 기본

- 기본 로거 구현체: **Logback**
- `application.yml`에서 레벨 조정:
```yaml
logging:
  level:
    root: INFO
    com.myapp: DEBUG
```

### 패턴/파일

```yaml
logging:
  file:
    name: logs/app.log
```
> Boot는 내부적으로 SLF4J/JUL 브리지를 적절히 구성하지만, 혼재 환경에선 §5의 브리지 전략을 명시 적용할 것.

---

## 보안/규정 준수 — 민감정보 마스킹

### 패턴 치환(예: Logback)

```xml
<encoder>
  <pattern>%replace(%msg){'(?i)(password|secret)=[^&\\s]+' , '$1=****'}%n</pattern>
</encoder>
```
> 운영 정책에 맞춰 **토큰/계정/주민번호** 등은 로그로 남기지 말 것. (정규식 마스킹 아이디어)

---

## 테스트에서 로그 다루기

### 메시지·레벨 검증(Logback Test Appender)

- 테스트에서 커스텀 Appender를 붙여 **마지막 로그**를 검증
- 또는 통합 테스트에서 **JSON 로그 파일 파싱**으로 이벤트 검증

### 성능/플레이키 주의

- 파일 롤링, 권한, 디스크 용량에 따라 동작이 바뀔 수 있으므로 **격리된 테스트 디렉터리** 사용
- 비동기 로깅 검증 시 **flush/대기** 로직을 넣어 타이밍 이슈 방지

---

## 흔한 문제 & 해결

- **바인딩 중복 경고**: SLF4J 바인딩이 둘 이상(예: logback + log4j2) → **하나만 남기기**
- **레거시 혼재**: JUL/JCL/Log4j1이 섞여 중복 출력 → **브리지로 SLF4J 단일화**(§5)
- **레벨이 안 바뀜**: 상위 로거 additivity/별도 설정 파일 중복 적용 여부 확인
- **MDC 누락**: 쓰레드 풀/비동기 경계에서 **컨텍스트 전파** 코드 또는 라이브러리 적용 필요

---

## 운영 베스트 프랙티스 체크리스트

- [ ] **단일 파사드(SLF4J)** + **단일 구현체(Logback 또는 Log4j2)**
- [ ] **브리지**로 JUL/JCL/Log4j1 통합 (필요 시 `SLF4JBridgeHandler.install()` 호출)
- [ ] **비동기 로깅**(처리량/지연 민감 서비스) — Log4j2 AsyncLogger(컨텍스트 셀렉터) / Logback AsyncAppender
- [ ] **MDC로 traceId/reqId** 포함
- [ ] **JSON 로깅** + 수집/검색(ELK 등) 구성
- [ ] **민감정보 마스킹** 규칙 적용(정규식/필터)
- [ ] **버전/보안 공지** 주기 확인(Log4j2 2.25.x, SLF4J 2.0.x, Logback 1.5.x)

---

## 빠른 선택 가이드

- **새 프로젝트 / Spring 생태계**: *SLF4J + Logback* (간결, Spring 기본)
- **고성능/커스텀 Appender 풍부**: *SLF4J + Log4j2* (AsyncLogger)
- **레거시 혼재**: *SLF4J 단일화 + 브리지*로 통합
- **운영 가시성 최우선**: *JSON 로깅 + MDC(traceId) + 중앙 수집*

---

### 마무리

- 코드는 **SLF4J API**로 단순화하고, 구현체(Logback/Log4j2)는 **환경·요구 성능**에 맞게 선택하라.
- **MDC, 비동기, JSON 로깅**을 조합하면 **재현/분석/모니터링**이 쉬워진다.
- 무엇보다 **민감정보 마스킹**과 **최신 버전 유지(EOL 회피)**가 안전한 로깅의 핵심이다. (Log4j 1.x EOL 재확인)
