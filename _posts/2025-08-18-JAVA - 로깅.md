---
layout: post
title: Java - 로깅
date: 2025-08-18 15:25:23 +0900
category: Java
---
# 로깅 (java.util.logging, Log4j/Log4j2, SLF4J) — 개념, 설정, 실전 베스트 프랙티스

Java에서 로깅은 **문제 분석**, **운영 모니터링**, **감사(감사 추적)**를 위해 필수입니다.  
여기서는 표준 로깅인 **java.util.logging(JUL)**, 범용 프레임워크 **Log4j(특히 Log4j2)**, 그리고 **파사드(SLF4J)**를 중심으로 **개념→구성→사용→브리지→운영 팁**까지 체계적으로 정리합니다.

> 용어 정리  
> - **로깅 API**: 애플리케이션 코드에서 호출하는 인터페이스(예: SLF4J).  
> - **로깅 구현체**: 실제 출력/롤링/포맷을 수행(예: Log4j2, Logback, JUL).  
> - **브리지/어댑터**: 서로 다른 API/구현체를 연결.

---

## 1) 공통 핵심 개념

### 1.1 레벨(중요도)
- 보편적 순서(높음→낮음): `FATAL/SEVERE` > `ERROR` > `WARN` > `INFO` > `DEBUG` > `TRACE`
- JUL은 `SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST`를 사용(매핑 필요).

### 1.2 로거 계층 & 전파
- 패키지/클래스 경로를 이름으로 하는 **계층적 구조**. 상위 설정(레벨/핸들러/앱엔더)이 하위로 **전파**될 수 있음.

### 1.3 출력 대상
- **콘솔**, **파일(롤링/백업)**, **원격 수집(예: Syslog, Socket, HTTP)**, **JSON 구조화** 등.

### 1.4 성능 팁
- **파라미터화 로그**(지연 평가)로 문자열 연결 비용 감소.  
- **비동기(Appender/AsyncLogger)**로 I/O 지연 최소화.  
- 과도한 `DEBUG/TRACE`는 **샘플링** 또는 조건부 활성화.

### 1.5 컨텍스트(MDC)
- **MDC/ThreadContext**: 요청 ID, 사용자 ID처럼 **진행 중인 작업의 문맥 값**을 로그에 자동 포함.

---

## 2) java.util.logging (JUL)

### 2.1 특징
- JDK 내장(외부 의존성 없음).  
- 기본 기능은 충분하지만, **설정/확장성/생태계**는 Log4j2/Logback에 비해 제한적.

### 2.2 기본 사용
```java
import java.util.logging.Logger;
import java.util.logging.Level;

public class JulExample {
    private static final Logger log = Logger.getLogger(JulExample.class.getName());

    public static void main(String[] args) {
        log.info("정보 로그");
        log.log(Level.WARNING, "경고: {0}", "상태 이상");
        if (log.isLoggable(Level.FINE)) {
            log.fine("자세한 디버그 정보");
        }
    }
}
```

### 2.3 설정(`logging.properties`)
- JVM 옵션: `-Djava.util.logging.config.file=path/logging.properties`
```properties
# 루트 레벨
.level = INFO

# 핸들러 등록
handlers = java.util.logging.ConsoleHandler

# 콘솔 핸들러 레벨/포맷
java.util.logging.ConsoleHandler.level = INFO
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter

# 패키지별 레벨 조정
com.myapp.level = FINE
```

> JUL은 포맷터/핸들러 커스터마이징이 가능하나, 풍부한 Appender/플러그인은 제한적입니다.

---

## 3) Log4j (권장: Log4j2)

> **Log4j 1.x는 EOL**이며 보안/안정성 측면에서 **Log4j2 사용 권장**.  
> (운영 시 최신 버전 유지와 **보안 공지** 주기적 확인 필수)

### 3.1 장점
- 고성능 **Async Logger**(LMAX Disruptor 기반), 풍부한 Appender(파일 롤링, SMTP, Syslog, Socket, JDBC, JSON 등), 유연한 패턴 레이아웃.

### 3.2 의존성 (예: Maven)
```xml
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-api</artifactId>
  <version>2.23.1</version>
</dependency>
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-core</artifactId>
  <version>2.23.1</version>
</dependency>
```

### 3.3 사용 코드(Log4j2 API)
```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class L4j2Example {
    private static final Logger log = LogManager.getLogger();

    public static void main(String[] args) {
        log.info("Hello {}", "Log4j2");   // 파라미터화 메시지
        log.warn("경고 발생", new RuntimeException("원인"));
    }
}
```

### 3.4 설정 예시(`log4j2.xml`)
`src/main/resources/log4j2.xml` 에 두면 자동 인식.
```xml
<Configuration status="WARN">
  <Appenders>
    <Console name="CONSOLE" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{ISO8601} %-5level [%t] %c{1} - %msg%n"/>
    </Console>
    <RollingFile name="FILE" fileName="logs/app.log"
                 filePattern="logs/app-%d{yyyy-MM-dd}-%i.log.gz">
      <PatternLayout pattern="%d{ISO8601} %-5level [%t] %X{reqId} %c - %msg%n"/>
      <Policies>
        <TimeBasedTriggeringPolicy />
        <SizeBasedTriggeringPolicy size="50 MB"/>
      </Policies>
      <DefaultRolloverStrategy max="10"/>
    </RollingFile>
  </Appenders>

  <Loggers>
    <Logger name="com.myapp" level="debug" additivity="false">
      <AppenderRef ref="CONSOLE"/>
      <AppenderRef ref="FILE"/>
    </Logger>
    <Root level="info">
      <AppenderRef ref="CONSOLE"/>
    </Root>
  </Loggers>
</Configuration>
```

### 3.5 비동기 로거 활성화(고성능)
- JVM 옵션: `-Dlog4j2.contextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector`  
- 또는 설정에서 `AsyncLogger`/`AsyncAppender` 사용.

### 3.6 MDC(ThreadContext)
```java
import org.apache.logging.log4j.ThreadContext;

ThreadContext.put("reqId", "9f1e-123");
log.info("요청 처리 시작");
// ...
ThreadContext.clearAll();
```
- 패턴 `%X{reqId}` 로 출력.

---

## 4) SLF4J — 로깅 **파사드** (Logback/Log4j2/JUL을 추상화)

> SLF4J는 **API만 제공**. 실제 출력은 **바인딩(구현체)**가 담당합니다.  
> - 대표 구현체: **Logback**(Spring Boot 기본), Log4j2, JUL 바인딩 등.

### 4.1 장점
- 애플리케이션 코드는 **SLF4J API**만 사용 → **구현체 교체** 용이.  
- 풍부한 브릿지로 **이질 API 통합**.

### 4.2 사용 코드(SLF4J API)
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Slf4jExample {
    private static final Logger log = LoggerFactory.getLogger(Slf4jExample.class);

    public static void main(String[] args) {
        String user = "alice";
        log.info("로그인 시도 user={}", user);
        log.warn("느린 응답: {} ms", 123);
        log.error("실패", new IllegalStateException("사유"));
    }
}
```

### 4.3 구현체 선택

#### (A) Logback (Spring Boot 기본)
**의존성 (Gradle 예시)**:
```kotlin
implementation("ch.qos.logback:logback-classic:1.5.6")
implementation("org.slf4j:slf4j-api:2.0.13")
```

`logback-spring.xml` 또는 `logback.xml`:
```xml
<configuration>
  <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d{ISO8601} %-5level [%thread] %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>
  <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/app.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>logs/app-%d{yyyy-MM-dd}.%i.gz</fileNamePattern>
      <timeBasedFileNamingAndTriggeringPolicy
        class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
        <maxFileSize>50MB</maxFileSize>
      </timeBasedFileNamingAndTriggeringPolicy>
      <maxHistory>14</maxHistory>
    </rollingPolicy>
    <encoder>
      <pattern>%d %-5level [%thread] %X{reqId} %logger - %msg%n</pattern>
    </encoder>
  </appender>

  <logger name="com.myapp" level="DEBUG"/>
  <root level="INFO">
    <appender-ref ref="CONSOLE"/>
    <appender-ref ref="FILE"/>
  </root>
</configuration>
```

`MDC`:
```java
import org.slf4j.MDC;

MDC.put("reqId", "abc-123");
// ...
MDC.clear();
```

#### (B) SLF4J + Log4j2
```xml
<!-- Maven 핵심 -->
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-api</artifactId>
  <version>2.0.13</version>
</dependency>
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-slf4j2-impl</artifactId> <!-- SLF4J 바인딩을 Log4j2로 -->
  <version>2.23.1</version>
</dependency>
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-core</artifactId>
  <version>2.23.1</version>
</dependency>
```

---

## 5) 브리지(Bridge) — 혼재된 로깅 정리

### 5.1 “모두 SLF4J로 모으기” (권장 전략)
- **JUL → SLF4J**: `jul-to-slf4j`  
- **Log4j 1.x → SLF4J**: `log4j-over-slf4j`  
- **JCL(commons-logging) → SLF4J**: `jcl-over-slf4j`  
- 그런 다음 **단 하나의 구현체**(Logback 또는 Log4j2)만 바인딩.

**예: Gradle**
```kotlin
implementation("org.slf4j:slf4j-api:2.0.13")
implementation("ch.qos.logback:logback-classic:1.5.6")

// 브리지
implementation("org.slf4j:jcl-over-slf4j:2.0.13")
implementation("org.slf4j:jul-to-slf4j:2.0.13")
implementation("org.slf4j:log4j-over-slf4j:2.0.13")

// 충돌 방지: 기존 commons-logging, log4j-1.x 바인딩은 제외
```

> **주의**  
> - “API와 바인딩이 여러 개”면 **중복/충돌 경고** 발생. **바인딩은 단 하나만** 유지하세요.  
> - Spring Boot는 기본적으로 **SLF4J + Logback** 구성을 제공(추가 설정 최소화).

---

## 6) 구조화/JSON 로깅 & 수집

### 6.1 JSON 출력(예: Logback + logstash-encoder)
```kotlin
implementation("net.logstash.logback:logstash-logback-encoder:7.4")
```
`logback-spring.xml`:
```xml
<appender name="JSON" class="ch.qos.logback.core.rolling.RollingFileAppender">
  <file>logs/app.json</file>
  <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
    <fileNamePattern>logs/app-%d{yyyy-MM-dd}.json.gz</fileNamePattern>
  </rollingPolicy>
  <encoder class="net.logstash.logback.encoder.LogstashEncoder"/>
</appender>
```
→ ELK/Opensearch/Datadog 등으로 **로그 수집/검색**이 쉬워짐.

### 6.2 필드 설계 팁
- `timestamp`, `level`, `logger`, `thread`, **`traceId/reqId`**, **`userId`**, `message`, `error.stacktrace`, `service`, `env`.

---

## 7) 운영 베스트 프랙티스

1. **민감정보 마스킹**: 비밀번호/토큰/주민번호 등은 **절대 평문 기록 금지**(마스킹 필터/패턴 적용).  
2. **레벨 정책**:  
   - `ERROR`: 사용자 영향/롤백 필요한 오류  
   - `WARN`: 비정상 징후(재시도, 폴백)  
   - `INFO`: 상태 변화/주요 비즈니스 이벤트  
   - `DEBUG/TRACE`: 개발/문제 분석 시에만(운영에선 비활성 또는 샘플링)  
3. **롤링 전략**: **시간+사이즈 기반** + 보존 기간(`maxHistory`) 설정.  
4. **비동기 로깅**: 처리량/지연 민감 서비스에서 **AsyncAppender/AsyncLogger** 사용.  
5. **상황별 컨텍스트(MDC)**: `reqId/traceId`로 **분산 추적**과 연계(예: Sleuth/OpenTelemetry).  
6. **표준 키/포맷**: 마이크로서비스 간 **일관된 로그 포맷** 유지.  
7. **보안**: 구현체/의존성 **최신 유지**. (Log4j2 등 보안 이슈 이력 있으므로 정기 확인)  
8. **테스트**: 로깅이 성능/동작에 미치는 영향(파일 권한, 롤링 용량 초과) **사전 점검**.

---

## 8) 빠른 선택 가이드

- **새 프로젝트**  
  - 단독 애플리케이션: **SLF4J + Logback**(간편, Spring 표준).  
  - 고성능/커스텀 Appender 풍부: **SLF4J + Log4j2**(Async Logger).  
- **레거시 혼재 환경**: 브리지로 **SLF4J 단일화** → 구현체 하나만 유지.  
- **운영 가시성**: **JSON 로깅 + 수집(ELK/Datadog)** + MDC(traceId).

---

## 9) 치트시트

- 코드: `logger.info("id={} status={}", id, status)` (문자열 더하기 금지)  
- MDC: `MDC.put("reqId", rid); try {...} finally { MDC.clear(); }`  
- Logback 파일 위치: `logback-spring.xml`(Spring), `logback.xml`(일반)  
- Log4j2 파일 위치: `log4j2.xml`/`log4j2-spring.xml`  
- 브리지: `jul-to-slf4j`, `jcl-over-slf4j`, `log4j-over-slf4j`  
- 바인딩은 **단 하나**만!

---

### 마무리
- **SLF4J**로 애플리케이션 코드를 단순화하고, 운영 요구에 맞는 **구현체(Logback/Log4j2)**를 선택하세요.  
- **MDC, 비동기, JSON 로깅**을 조합하면 **문제 재현/분석/모니터링**이 훨씬 수월해집니다.  
- 무엇보다 **민감정보 마스킹**과 **최신 버전 유지**가 안전한 로깅의 핵심입니다.