---
layout: post
title: DB 심화 - 조인 제거
date: 2025-11-18 22:25:23 +0900
category: DB 심화
---
# 조인 제거(Join Elimination)

**목표**  
- 실행계획과 옵티마이저 변환 관점에서 **“어떤 조인이 왜/언제 사라지는지”**를 끝까지 이해한다.  
- **Inner/Outer/EXISTS/Self-Join/집계-후-조인** 등 실전 패턴을 예제로 체화한다.  
- **제약조건 신뢰(VALIDATE/ NOVALIDATE/ RELY)**, 뷰 병합, SARGable 작성이 조인 제거에 어떤 영향을 주는지 정리한다.  
- 마지막으로 **DBMS_XPLAN과 V$ 통계로 진짜 제거됐는지 증명**하는 루틴을 갖는다.

---

## 0) 개요 — 조인 제거란 무엇인가

**조인 제거(Join Elimination)**는 실행 결과에 영향을 주지 않는 조인을 **옵티마이저가 자동으로 제거**해, 불필요한 테이블/인덱스 접근, 해시 빌드, 재분배 등을 **완전히 없애는 비용 기반 쿼리 변환(CBQT)**이다.  
Oracle SQL Tuning Guide의 쿼리 변환 목록에서도 **“Join Elimination”이 대표적인 변환으로 언급**된다. 

핵심 직관은 아주 단순하다.

1. **해당 조인이 결과 행을 줄이지 않는가?**(필터 효과 0)  
2. **해당 조인이 결과 행을 늘리지 않는가?**(중복/증식 효과 0)  
3. **해당 테이블의 컬럼이 결과/필터에 전혀 쓰이지 않는가?**

이 3가지를 **제약조건(PK/UK/FK/NOT NULL)**과 논리 동등성으로 “증명”할 수 있으면 조인은 사라진다.

---

## 1) 조인 제거의 위치 — 옵티마이저 쿼리 변환(CBQT) 흐름 안에서

Oracle 옵티마이저는 대략 다음 순서로 복잡한 SQL을 정리한다.

1. **문법/의미 분석**  
2. **쿼리 블록 정규화**(뷰/CTE 정리, 상수 전파, 프레디킷 간소화)  
3. **의미 보존 변환(CBQT)**  
   - View Merging, Predicate Pushdown, Subquery Unnesting  
   - **Join Elimination / Outer Join Elimination**  
4. **비용 기반 플랜 탐색(CBO)**

따라서 **조인 제거는 “플랜 선택 이전”에 일어나는 재작성**이다.  
플랜에서 특정 테이블이 “아예 등장하지 않는” 형태로 나타나는 것은, 그 뒤 단계(CBO)가 아니라 **앞 단계(CBQT)에서 그 테이블을 제거해 버렸기 때문**이다.

---

## 2) 옵티마이저가 “안전하게 제거”하는 논리 조건

조인 제거를 논리적으로 쓰면 다음과 같다.

### 2.1 Inner Join 제거의 충분조건(직관)

Child(사실) → Parent(차원) 구조에서

- Child의 FK가 **NOT NULL**  
- FK 제약이 **ENABLE VALIDATE(또는 RELY)로 신뢰 가능**  
- Parent의 PK/UK로 **매칭이 최대 1행(Unique)**  
- Parent columns **미참조(SELECT/HAVING/ORDER BY 등)**  
- Parent에 대한 **추가 필터 없음**

이면,

> 조인은 **행 필터도, 중복도 만들지 않고, 값 계산에도 기여하지 않으므로** 제거 가능.

도식으로는

\[
\text{Child} \ \underset{\text{FK (NOT NULL)}}{\longrightarrow}\ \text{Parent (PK/UK)} 
\ \wedge\ \text{Parent 열 미참조/필터 없음}
\Rightarrow \text{Join 제거}
\]

### 2.2 Outer Join 제거의 충분조건(직관)

Left Outer Join에서

- Right 테이블 컬럼 **미참조**  
- Right에 **추가 필터 없음**  
- Right 매칭이 **Left 1행당 최대 1행(Unique)**  
  → Right PK/UK 또는 동등한 유일성 증명을 통해 확인  
- 조인을 제거해도 Left의 NULL 보존/행 수가 변하지 않음

이면 Left Outer Join도 제거 가능.

---

## 3) Inner Join 제거 — 가장 흔하고 강력한 패턴

### 3.1 기본 패턴: Child → Parent FK 조인인데 Parent를 안 씀

```sql
-- 부모(고객), 자식(판매)
CREATE TABLE d_customer (
  cust_id NUMBER PRIMARY KEY,
  region  VARCHAR2(8) NOT NULL,
  tier    VARCHAR2(8) NOT NULL
);

CREATE TABLE f_sales (
  sales_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  prod_id  NUMBER NOT NULL,
  sales_dt DATE   NOT NULL,
  qty      NUMBER NOT NULL,
  amount   NUMBER(12,2) NOT NULL,
  CONSTRAINT fk_sales_customer
    FOREIGN KEY (cust_id) REFERENCES d_customer(cust_id)
);

CREATE INDEX ix_sales_cust ON f_sales(cust_id);
```

**원형 SQL**

```sql
SELECT s.sales_id, s.amount
FROM   f_sales s
JOIN   d_customer c
  ON   c.cust_id = s.cust_id
WHERE  s.sales_dt >= DATE '2025-01-01';
```

**변환 후 의미 동일 SQL**

```sql
SELECT s.sales_id, s.amount
FROM   f_sales s
WHERE  s.sales_dt >= DATE '2025-01-01';
```

**왜 제거되는가?**

- FK **VALID** → f_sales의 cust_id는 무조건 d_customer에 존재 → **필터 효과 0**  
- d_customer.cust_id **Unique(PK)** → Left 1행당 Right 최대 1행 → **중복 효과 0**  
- c 컬럼 **미참조/추가 필터 없음** → **결과 계산 기여 0**

이 3가지가 조인을 없애도 결과가 같다는 증명이다.

---

### 3.2 EXISTS/SEMijoin 제거 — FK가 “존재성”을 증명

```sql
-- 원형: 부모 존재 확인
SELECT s.sales_id
FROM   f_sales s
WHERE  EXISTS (
  SELECT 1
  FROM   d_customer c
  WHERE  c.cust_id = s.cust_id
);

-- FK VALID면 항상 참 → 제거
SELECT s.sales_id
FROM   f_sales s;
```

**의미**  
EXISTS는 “부모가 있는 자식만” 남기는데, FK가 VALID이면 **모든 자식이 이미 그 조건을 만족**한다.  
따라서 EXISTS는 **항상 참인 조건**이 되어 제거된다.

---

### 3.3 집계 후 부모 조인도 제거될 수 있다

```sql
-- 원형: 고객별 합계를 구한 후 고객 테이블과 조인(하지만 고객 컬럼 사용 X)
SELECT c.cust_id, x.sum_amt
FROM   d_customer c
JOIN  (SELECT s.cust_id, SUM(s.amount) sum_amt
       FROM   f_sales s
       WHERE  s.sales_dt >= DATE '2025-01-01'
       GROUP  BY s.cust_id) x
  ON   x.cust_id = c.cust_id;

-- 개선: 고객 조인 제거
SELECT s.cust_id, SUM(s.amount) sum_amt
FROM   f_sales s
WHERE  s.sales_dt >= DATE '2025-01-01'
GROUP  BY s.cust_id;
```

**핵심**  
집계 결과 x.cust_id는 **FK 컬럼 기반 그룹 키**다.  
FK VALID + Parent Unique + Parent 미참조가 증명되면, **집계 뒤에 붙은 Parent 조인도 제거**된다.

---

### 3.4 Inner Join 제거가 막히는 전형적 반례

1) **FK 컬럼이 NULL 가능**

```sql
ALTER TABLE f_sales MODIFY cust_id NULL;

SELECT s.sales_id
FROM f_sales s
JOIN d_customer c ON c.cust_id = s.cust_id;
```

Inner Join은 NULL FK 행을 버린다.  
NULL 허용이면 조인 자체가 “필터” 역할이 되어 **제거 불가**.

2) **Parent 컬럼을 참조/필터**

```sql
SELECT s.sales_id
FROM f_sales s
JOIN d_customer c ON c.cust_id = s.cust_id
WHERE c.tier = 'VIP';
```

c.tier 필터는 조인의 의미 그 자체 → 제거 불가.  
가능하면 필터를 Child에 “미리 존재하는 속성”으로 이관하거나(비정규화/ETL), 다른 방식으로 재작성해야 한다.

3) **제약이 신뢰되지 않음(DISABLE/NOVALIDATE/RELY 없음)**  
→ §7에서 자세히.

---

## 4) Left Outer Join 제거 — Right가 “유일 매칭 + 미참조”일 때

### 4.1 기본 패턴

```sql
CREATE TABLE d_product (
  prod_id  NUMBER PRIMARY KEY,
  category VARCHAR2(16) NOT NULL,
  brand    VARCHAR2(16) NOT NULL
);

ALTER TABLE f_sales
  ADD CONSTRAINT fk_sales_product
  FOREIGN KEY (prod_id) REFERENCES d_product(prod_id);
```

```sql
-- Right(제품) 컬럼을 쓰지 않는 LEFT JOIN
SELECT c.cust_id
FROM   d_customer c
LEFT JOIN d_product p
  ON    p.prod_id = 10; -- PK 매칭 → 0 또는 1행
```

Right 컬럼 미참조 + p.prod_id PK로 **유일 매칭 보장**이므로, 조인을 제거해도 결과가 같다.

```sql
SELECT c.cust_id
FROM   d_customer c;
```

### 4.2 “LEFT JOIN + IS NULL”은 제거 불가(의미가 필터)

```sql
SELECT c.cust_id
FROM   d_customer c
LEFT JOIN f_sales s
  ON s.cust_id = c.cust_id
WHERE s.sales_id IS NULL;
```

이 패턴은 **Anti-Join(매칭 없는 행 찾기)** 그 자체다.  
LEFT JOIN을 제거하면 “주문 없는 고객”이라는 의미가 사라지므로 제거 불가.

---

## 5) Self-Join / 중복 조인 제거

### 5.1 PK 동등 자기 조인

```sql
SELECT a.cust_id
FROM   d_customer a
JOIN   d_customer b
  ON   b.cust_id = a.cust_id;
```

PK로 자기 자신과 조인해도 **행 수/값이 변하지 않는다.**  
b의 컬럼 미참조면 b가 제거된다.

```sql
SELECT a.cust_id
FROM d_customer a;
```

### 5.2 같은 Parent를 체인으로 중복 참조한 경우

```sql
SELECT s.sales_id
FROM   f_sales s
JOIN   d_customer c1 ON c1.cust_id = s.cust_id
JOIN   d_customer c2 ON c2.cust_id = c1.cust_id;
```

c1과 c2는 같은 키/같은 테이블/추가 조건 없음.  
c2는 아무 의미가 없으므로 제거된다.

---

## 6) View / CTE 병합과 조인 제거의 상호작용

조인 제거는 **뷰가 병합되어 평탄화된 뒤** 더 잘 드러난다.

### 6.1 “존재성만 들고 있는 뷰”는 제거 후보

```sql
SELECT s.sales_id
FROM   f_sales s
JOIN  (SELECT c.cust_id FROM d_customer c) v
  ON  v.cust_id = s.cust_id;
```

- v는 c.cust_id만 제공  
- 이미 FK로 존재성이 보장  
→ v 전체 제거 가능.

### 6.2 병합을 막으면 제거도 막힐 수 있다

```sql
WITH v AS (
  SELECT /*+ NO_MERGE */ cust_id
  FROM d_customer
)
SELECT s.sales_id
FROM f_sales s
JOIN v ON v.cust_id = s.cust_id;
```

NO_MERGE/MATERIALIZE로 뷰가 물리화되면,  
옵티마이저가 “조인을 제거해도 항상 의미 동일”임을 증명하기 어려워져 제거가 실패할 수 있다.  

**실무 결론**  
- 제거를 기대한다면 **뷰 병합/푸시다운이 잘 되도록 단순하게** 작성한다.  
- 제거가 너무 aggressive해서 곤란하면(드문 케이스) **NO_MERGE/NO_QUERY_TRANSFORMATION** 같은 변환 차단을 고려한다.

---

## 7) 제약조건의 “신뢰도”가 조인 제거를 좌우한다

옵티마이저는 **신뢰할 수 있는 제약**만 사용해 의미 보존을 증명한다.  
Oracle 문서에서도 RELY/Novalidate 상태에 따라 옵티마이저가 제약을 **쿼리 변환/리라이트 판단에 활용**할 수 있음을 명확히 설명한다. :contentReference[oaicite:1]{index=1}

### 7.1 제약 상태 요약

| 상태 | 의미 | 조인 제거 영향 |
|---|---|---|
| **ENABLE VALIDATE** | 기존/신규 데이터 모두 검증, 가장 강한 신뢰 | **최고로 잘 됨** |
| **ENABLE NOVALIDATE** | 신규 데이터만 검증, 기존 데이터는 미검증 | 기본적으로 신뢰 약함 → 제거 실패 가능 |
| **RELY** | “제약을 신뢰하라”는 선언(주로 DW/ETL) | **RELY가 있으면 변환 근거로 사용 가능** |
| DISABLE | 옵티마이저 근거로 사용 불가 | 제거 거의 불가 |

### 7.2 DW에서 자주 쓰는 패턴: NOVALIDATE + RELY

대용량 DW는 기존 데이터 전체 검증 비용이 크므로,

```sql
ALTER TABLE f_sales
  MODIFY CONSTRAINT fk_sales_customer ENABLE NOVALIDATE RELY;
```

처럼 **NOVALIDATE로 비용을 줄이되, RELY로 옵티마이저에게 “증명 근거로 써도 된다”**고 알려 조인 제거를 살린다.  
(운영 정책상 데이터 무결성을 ETL/배치가 보장한다는 전제)

---

## 8) 플랜에서 조인 제거를 “증거로 확인”하는 법

### 8.1 가장 단순한 신호: 계획에 테이블이 없다

```sql
SELECT /* before */ s.sales_id
FROM f_sales s
JOIN d_customer c ON c.cust_id = s.cust_id
WHERE s.sales_dt >= DATE '2025-03-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL, 'ALLSTATS LAST +PREDICATE +ALIAS +NOTE'));
```

**체크 포인트**
- `d_customer`에 대한 `TABLE ACCESS` / `INDEX` / `JOIN` 노드가 **완전히 사라졌는가?**
- `Predicate Information`에서 c 관련 프레디킷이 **사라졌는가?**

### 8.2 Outline/Note에서 변환 로그를 본다

Oracle 튜닝 문서의 플랜 비교/리포트에서는 **“Join Elimination이 적용되었다”**는 변환 로그가 표시될 수 있다고 설명한다. 

실측 루틴:

```sql
ALTER SESSION SET statistics_level = ALL;

-- before/after 각각 실행
SELECT /*+ MONITOR */ s.sales_id
FROM f_sales s
JOIN d_customer c ON c.cust_id=s.cust_id
WHERE s.sales_dt >= DATE '2025-03-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL, 'ALLSTATS LAST +OUTLINE +NOTE +PREDICATE +ALIAS'));
```

- `NOTE` 섹션에 변환 흔적이 남거나  
- `OUTLINE`에서 조인 제거 관련 힌트가 생성되기도 한다(버전/세팅에 따라 상이).

### 8.3 V$ 통계로 “정량 증명”

```sql
-- 실행 전 스냅샷
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON ms.stat#=sn.stat#
WHERE  sn.name IN ('session logical reads','physical reads','consistent gets');

-- SQL 실행

-- 실행 후 스냅샷
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON ms.stat#=sn.stat#
WHERE  sn.name IN ('session logical reads','physical reads','consistent gets');
```

조인 제거 전/후에  
- 논리 읽기(consistent gets), 물리 읽기(physical reads), CPU time이 **의미 있게 감소**해야 “진짜 이득”이다.

---

## 9) 조인 제거를 깨뜨리는 패턴과 실전 해결법

### 9.1 조인 키에 함수/형변환이 있다

```sql
JOIN d_customer c ON c.cust_id = TO_NUMBER(s.cust_id_char)
```

→ 동등성/유일성 증명이 약해져 제거 실패.

**해결**  
- 타입을 **원천에서 정합**하게 만들고  
- 불가피하면 가상 컬럼/FBI로 SARGable하게 만든다.

### 9.2 OR가 조인을 “필터로 만들었다”

```sql
WHERE c.tier='VIP' OR s.amount>1000
```

분기별로 의미가 달라져 “조인 제거 증명”이 어렵다.

**해결**
- `UNION ALL`로 분해해 분기별로 제거 가능성을 살린다.  
- 필요하면 `USE_CONCAT` 힌트로 OR Expansion을 유도한다.

### 9.3 Outer Join에서 Right 중복 가능

Right 1행이 Left 여러 행에 매칭되면 Left가 **증식**한다.  
적어도 Right의 PK/UK 또는 동등 논리로 **유일 매칭**이 증명돼야 한다.

### 9.4 제약이 신뢰되지 않는다

- FK가 `DISABLE/NOVALIDATE` 이고 RELY가 없으면  
- 옵티마이저는 “고아 행이 존재할 수 있다”는 가능성을 남겨둔다.  

**해결**  
- `ENABLE VALIDATE`가 최선  
- 검증 비용이 크면 **ETL 무결성 보장 전제 + RELY 조합**을 쓴다(§7).

---

## 10) 실전 튜닝 시나리오

### 10.1 눈사람 스키마(snowflake)에서 차원 체인을 걷어낸다

DW에서 사실 → 차원 → 하위 차원으로 길게 조인했는데  
상위 차원만 값이 필요하고 하위 차원은 단순 “존재 확인” 용도라면

- **하위 차원 조인이 제거되면서**
- 조인 그래프가 단축되고
- 해시 빌드/재분배가 크게 줄어든다.

### 10.2 “필요 없는 차원 조인”을 의도적으로 남겨두는 실수

```sql
SELECT SUM(s.amount)
FROM f_sales s
JOIN d_customer c ON c.cust_id=s.cust_id  -- 여기서 c는 안 씀
WHERE s.sales_dt >= :d1 AND s.sales_dt < :d2;
```

- 설계 당시엔 c의 filter가 붙을 줄 알았지만  
- 리팩터링 과정에서 filter가 사라짐  

→ 조인 제거가 되면 다행이지만,  
**제약이 불완전하면 제거가 안 되고 “그냥 쓸데없이 비싸기만 한 조인”이 남는다.**

실무 습관:
- “차원 컬럼을 쓰지 않는 조인”은 **의식적으로 제거**하거나  
- “정말 존재성 필터가 의도라면” **EXISTS로 명시**해 의미를 드러낸다.

---

## 11) 미니 랩 — 한 번에 검증하는 스크립트

```sql
-- 0) 데이터 준비
TRUNCATE TABLE d_customer;
TRUNCATE TABLE d_product;
TRUNCATE TABLE f_sales;

INSERT INTO d_customer VALUES (1,'USA','VIP');
INSERT INTO d_customer VALUES (2,'USA','STD');
INSERT INTO d_product  VALUES (10,'ELEC','B0');
INSERT INTO d_product  VALUES (20,'HOME','B1');

INSERT INTO f_sales VALUES (100, 1, 10, DATE '2025-03-01', 1, 10000);
INSERT INTO f_sales VALUES (101, 1, 20, DATE '2025-03-02', 2, 15000);
INSERT INTO f_sales VALUES (102, 2, 10, DATE '2025-03-03', 1,  9000);
COMMIT;

ALTER SESSION SET statistics_level=ALL;

-- 1) Inner Join 제거 관찰
SELECT /* before */ s.sales_id
FROM   f_sales s JOIN d_customer c ON c.cust_id=s.cust_id
WHERE  s.sales_dt >= DATE '2025-03-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +ALIAS +NOTE'));

-- 2) EXISTS 제거 관찰
SELECT /* before */ COUNT(*)
FROM   f_sales s
WHERE  EXISTS (SELECT 1 FROM d_customer c WHERE c.cust_id=s.cust_id);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +ALIAS +NOTE'));

-- 3) LEFT JOIN 제거(유일 매칭 + 미참조)
SELECT /* before */ COUNT(*)
FROM   d_customer c LEFT JOIN d_product p ON p.prod_id=10;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +ALIAS +NOTE'));

-- 4) 집계 후 부모 조인 제거
SELECT /* before */ c.cust_id, x.sum_amt
FROM d_customer c
JOIN (SELECT cust_id, SUM(amount) sum_amt
      FROM f_sales GROUP BY cust_id) x
ON x.cust_id=c.cust_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +ALIAS +NOTE'));
```

**랩에서 확인할 것**
- 제거된 테이블이 플랜에서 **아예 사라졌는가**  
- A-Rows/논리읽기/물리읽기가 **눈에 띄게 줄었는가**  
- 제약을 DISABLE/ NOVALIDATE로 바꿨을 때 제거가 **즉시 실패하는지**(원인 체감)

---

## 12) 최종 요약

- 조인 제거는 **“필터도 중복도 만들지 않고, 아무 컬럼도 쓰지 않는 조인”**을 제거하는 **의미 보존 최적화**다.  
- **Inner Join 제거의 핵**:  
  **FK(VALID + NOT NULL)** + **Parent Unique(PK/UK)** + **Parent 미참조/무필터**  
- **Left Outer Join 제거의 핵**:  
  **Right 유일 매칭** + **Right 미참조/무필터**  
- **제약 신뢰도(VALIDATE / RELY)가 곧 제거의 연료**다. Oracle 문서도 RELY 제약이 옵티마이저 변환/리라이트에 사용될 수 있음을 명시한다. :contentReference[oaicite:3]{index=3}  
- **검증은 플랜 + 통계**로 한다:  
  제거 대상 테이블 노드가 사라지고, 읽기/CPU가 줄어야 “진짜 성공”.

> 결론: 조인 제거는 “읽지 않아도 되는 테이블은 **아예 읽지 않는다**”는 가장 강력하고 안전한 최적화다.  
> FK·PK/Unique·NOT NULL로 **의미 동일을 증명할 수 있는 모델**을 만들고, 쿼리를 **단순·SARGable**하게 쓰면, 옵티마이저는 그 증명을 바탕으로 조인을 조용히 걷어낸다.