---
layout: post
title: DB 심화 - 조인 제거
date: 2025-11-18 22:25:23 +0900
category: DB 심화
---
# 조인 제거(Join Elimination)

> **핵심 요약**
> - **조인 제거**는 실행 결과에 **영향을 주지 않는 조인**을 **옵티마이저가 자동으로 제거**(평탄화/재작성)하여 **I/O·CPU·메모리** 비용을 줄이는 **비용기반 쿼리 변환**이다.
> - 대표 사례
>   1) **Inner Join 제거**: Child→Parent **FK(참조 무결성)** + **NOT NULL** + **Parent PK/Unique 보장** + **Parent 컬럼 미참조/추가필터 없음**
>   2) **Left Outer Join 제거**: Right(외부)측 **중복 불가(Unique)** + **Right 컬럼 미참조/추가필터 없음**
>   3) **EXISTS 계열 제거**: `EXISTS (select 1 from parent where parent.pk = child.fk)`는 **FK 유효**면 항상 참 → 제거
>   4) **자기 조인·집계 후 조인 제거**: 키 동등성/유일성(또는 그룹화 키) 증명 시
> - **필요 근거**: **제약조건(Constraint)·NOT NULL·Unique** 와 **의미 보존**.
> - **차단 요인**: 외부조인 중복/NULL 보존, FK 컬럼 **NULL 허용**, **제약 미검증/비신뢰**, 함수/형변환, 해당 테이블 컬럼 **참조 또는 필터**.

---

## 실습 스키마(요약) & 제약조건

조인 제거는 **제약이 “증명”** 을 제공할 때 가장 잘 발생한다.

```sql
-- 부모(고객), 자식(판매)
CREATE TABLE d_customer (
  cust_id NUMBER PRIMARY KEY,
  region  VARCHAR2(8) NOT NULL,
  tier    VARCHAR2(8) NOT NULL
);

CREATE TABLE f_sales (
  sales_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  prod_id  NUMBER NOT NULL,
  sales_dt DATE   NOT NULL,
  qty      NUMBER NOT NULL,
  amount   NUMBER(12,2) NOT NULL,
  CONSTRAINT fk_sales_customer
    FOREIGN KEY (cust_id)
    REFERENCES d_customer(cust_id)         -- FK로 '부모 존재'를 보장
);

-- 부모(제품), 자식(판매)
CREATE TABLE d_product (
  prod_id  NUMBER PRIMARY KEY,
  category VARCHAR2(16) NOT NULL,
  brand    VARCHAR2(16) NOT NULL
);

ALTER TABLE f_sales
  ADD CONSTRAINT fk_sales_product
  FOREIGN KEY (prod_id) REFERENCES d_product(prod_id);

-- 인덱스(예시)
CREATE INDEX ix_sales_cust ON f_sales(cust_id);
CREATE INDEX ix_sales_prod ON f_sales(prod_id);
```

> **Check**
> - FK 컬럼이 **NOT NULL** 이어야 Inner Join 제거 시 “필터 없음”을 증명하기 쉽다.
> - Parent 쪽 **PK/Unique** 로 **중복 불가** 를 증명해야 중복 제거시 결과 동일성 유지.

---

# 조인 제거란? (정의와 직관)

- **정의**: 쿼리에 등장한 조인이 **행 수를 바꾸지 않고(필터X·중복X)**, **선택/계산에도 기여하지 않는(컬럼 미참조)** 경우, 옵티마이저가 **그 테이블과 조인 자체를 제거**하는 변환.
- **왜 빠른가**: 제거된 테이블에 대한 **인덱스 탐색/테이블 스캔/해시 빌드** 등이 **완전히 생략**된다.
- **언제 일어나는가**: CBO가 **제약조건**(PK/FK/Unique/NOT NULL)과 **논리 등가**를 통해 **의미 보존**을 증명할 때.

> **직관 도식**
> - Inner Join 제거
>   $$\text{Child} \ \underset{\text{FK (NOT NULL)}}{\longrightarrow}\ \text{Parent(PK/Unique)} \quad\wedge\quad \text{Parent열 미참조} \Rightarrow \text{Join 제거}$$
> - Left Outer Join 제거
>   $$\text{Left} \ \overset{\text{LEFT JOIN}}{\longrightarrow}\ \text{Right(Unique 매칭)} \quad\wedge\quad \text{Right열 미참조} \Rightarrow \text{Join 제거}$$

---

# Inner Join 제거

## 가장 흔한 패턴

> “자식에서 부모로 Inner Join 했지만 부모 컬럼을 쓰지 않고, 부모 조인이 **필터/중복** 을 만들지 않는 경우”

```sql
-- (원형) 부모 컬럼을 전혀 사용하지 않는 조인
SELECT /* Child Only */
       s.sales_id, s.amount
FROM   f_sales s
JOIN   d_customer c
ON     c.cust_id = s.cust_id      -- FK: s.cust_id, PK: c.cust_id
WHERE  s.sales_dt >= DATE '2025-01-01';

-- (의미 동일) 부모 조인 제거 가능
SELECT s.sales_id, s.amount
FROM   f_sales s
WHERE  s.sales_dt >= DATE '2025-01-01';
```

**왜 안전한가?**
- **FK가 VALID** → s의 각 행은 **반드시** c에 **존재하는 cust_id** 를 가진다(**필터 없음**).
- **c.cust_id가 Unique** → 매칭은 **최대 1건**(**중복 없음**).
- 상단 SELECT/WHERE에 **c.* 미참조**, c에 대한 **추가 필터도 없음**.

> **주의**: FK 컬럼이 **NULL 가능** 이면 Inner Join이 **NULL 행을 제거** 하는 효과가 있으므로 조인 제거 **불가**.

### EXISTS 검증용 조인 제거

```sql
-- (원형) "부모가 있는 자식만" 사실 확인 (EXISTS)
SELECT s.sales_id
FROM   f_sales s
WHERE  EXISTS (
  SELECT 1
  FROM   d_customer c
  WHERE  c.cust_id = s.cust_id
);

-- (개선) FK가 VALID면 항상 참 → EXISTS 제거
SELECT s.sales_id
FROM   f_sales s;
```

### Aggregation 뒤 Parent 조인 제거

```sql
-- (원형) 고객별 매출합을 구하고 고객과 조인 (하지만 고객 컬럼을 안 씀)
SELECT c.cust_id, x.sum_amt
FROM   d_customer c
JOIN  (SELECT s.cust_id, SUM(s.amount) sum_amt
       FROM   f_sales s
       WHERE  s.sales_dt >= DATE '2025-01-01'
       GROUP  BY s.cust_id) x
ON     x.cust_id = c.cust_id;

-- (개선) FK VALID + c 컬럼 미참조 → c 조인 제거 가능
SELECT s.cust_id, SUM(s.amount) sum_amt
FROM   f_sales s
WHERE  s.sales_dt >= DATE '2025-01-01'
GROUP  BY s.cust_id;
```

> 그룹화 키(= FK)가 **NOT NULL** 이고 Parent에 대해 **중복/필터가 발생하지 않음**을 증명할 수 있으면 제거.

---

# Left Outer Join 제거

## 조건

- Right(외부) 테이블 컬럼 **미참조**, Right 테이블에 **추가 필터 없음**
- 조인으로 **중복이 생기지 않음**(= Left당 Right 매칭 **최대 1행**, 보통 Right PK/Unique로 보장)
- Left의 결과(행 수·값)를 바꾸지 않음

```sql
-- (원형) Left Outer Join 이지만 오른쪽 컬럼을 쓰지 않음, 중복도 없음
SELECT c.cust_id
FROM   d_customer c
LEFT JOIN d_product p
  ON    p.prod_id = :const_unique_prod_id;

-- Right 컬럼 미참조 + Right 유일 매칭 + 필터 없음 → 제거 가능
SELECT c.cust_id
FROM   d_customer c;
```

> **경고**: Right에 **복수 매칭** 가능성이 있으면 Left 행이 **증식**할 수 있다 → 제거 시 **행 수가 달라져** 결과가 바뀜.
> 반드시 **Unique**(또는 등가) 확인 필요.

### LEFT JOIN + IS NULL 패턴은 제거 불가

```sql
-- (반례) "고객 중 '주문 없는' 고객 찾기"
SELECT c.cust_id
FROM   d_customer c
LEFT JOIN f_sales s
  ON s.cust_id = c.cust_id
WHERE s.sales_id IS NULL;

-- 이 조인은 필터 의미 그 자체다 → 제거 불가
```

---

# 자기 조인(Self-Join) 및 키-등가 조인 제거

## PK 동등 자기 조인

```sql
-- (원형) 같은 테이블을 PK로 자기 조인 (불필요한 중복)
SELECT a.cust_id
FROM   d_customer a
JOIN   d_customer b
ON     b.cust_id = a.cust_id;

-- (개선) 제거
SELECT a.cust_id
FROM   d_customer a;
```

## 동일 키를 여러 번 거칠 필요가 없는 체인

```sql
-- (원형) s -> c -> (다시) c 별칭
SELECT s.sales_id
FROM   f_sales s
JOIN   d_customer c1 ON c1.cust_id = s.cust_id
JOIN   d_customer c2 ON c2.cust_id = c1.cust_id;

-- (개선) c2 제거 (같은 키/같은 테이블/추가 조건 없음)
SELECT s.sales_id
FROM   f_sales s
JOIN   d_customer c1 ON c1.cust_id = s.cust_id;
```

---

# View/Inline-View와 조인 제거

## “존재만 보장”하는 뷰

```sql
-- (원형) 뷰 v는 존재성 증명 외 실질 컬럼 제공 X
SELECT s.sales_id
FROM   f_sales s
JOIN  (SELECT /* v: 부모키 집합 */ c.cust_id
       FROM d_customer c) v
ON     v.cust_id = s.cust_id;

-- (개선) FK로 존재가 이미 보장 → v 제거
SELECT s.sales_id
FROM   f_sales s;
```

## 집계 뷰 + 조인 제거 (의미 보존되는 경우)

```sql
-- (원형) 고객별 매출합 뷰 a와 고객 조인. 고객 컬럼 미사용
SELECT c.cust_id, a.sum_amt
FROM   d_customer c
JOIN  (SELECT s.cust_id, SUM(s.amount) sum_amt
       FROM   f_sales s
       GROUP  BY s.cust_id) a
ON a.cust_id = c.cust_id;

-- (개선) c 제거
SELECT s.cust_id, SUM(s.amount) sum_amt
FROM   f_sales s
GROUP  BY s.cust_id;
```

> **팁**: View Merging(뷰 병합)과 결합되어 **조인 제거**가 더 쉽게 드러난다.
> 플랜에 `VIEW` 노드가 사라지고, 해당 테이블 스캔/조인이 없어졌는지 확인.

---

# 조인 제거가 **막히는** 경우와 해결책

| 차단 요인 | 설명 | 해결 |
|---|---|---|
| FK 컬럼 **NULL 허용** | Inner Join이 NULL 행을 **거르는** 역할 → 제거 시 의미 변경 | FK 컬럼 **NOT NULL** 로 변경/보장 |
| Parent Unique **불명확** | 중복 가능 → Inner/Left 조인 제거 시 행 수 변형 위험 | Parent에 **PK/Unique** 선언·검증 |
| Parent **컬럼 참조/필터** | 결과 값/행에 영향 → 제거 불가 | 참조 제거/필터를 Child 측 조건으로 변환 |
| **외부조인** 중복 | Right 복수 매칭 가능성 → 제거 시 행 수 변형 | Right에 Unique 보장 또는 재설계 |
| 제약 **DISABLE/NOVALIDATE/신뢰X** | CBO가 신뢰 못 함 | **ENABLE VALIDATE** 또는 **RELY**(정책에 맞게) |
| 함수/형변환 · 가공 | 동등성 증명 실패 | SARGABLE 작성(컬럼 가공 금지, 타입 일치) |
| OR/복합 조건 | 의미 증명 어렵거나 분기별 차이 | `USE_CONCAT`로 분해 후 분기별 판단 |
| 뷰 내부 분석함수/ROWNUM | 순서/상태 의존 → 병합/제거 제한 | 수동 재작성 or 물리화 후 상위에서 최적화 |

---

# 실전 예제 세트

## Inner Join 제거 — FK 존재 보장

```sql
-- (데이터 예시)
INSERT INTO d_customer(cust_id, region, tier) VALUES (100, 'KOR', 'VIP');
INSERT INTO f_sales(sales_id, cust_id, prod_id, sales_dt, qty, amount)
VALUES (1, 100, 10, DATE '2025-03-01', 1, 10000);

COMMIT;

-- (원형)
SELECT s.sales_id
FROM   f_sales s
JOIN   d_customer c ON c.cust_id = s.cust_id
WHERE  s.sales_dt >= DATE '2025-01-01';

-- (개선: 제거)
SELECT s.sales_id
FROM   f_sales s
WHERE  s.sales_dt >= DATE '2025-01-01';
```

**플랜 확인**
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL, 'ALLSTATS LAST +PREDICATE +ALIAS'));
-- 기대: d_customer에 대한 액세스/조인 오퍼레이터가 사라짐
```

## EXISTS 제거 (FK가 증명)

```sql
-- (원형)
SELECT COUNT(*)
FROM   f_sales s
WHERE  EXISTS (SELECT 1
               FROM d_customer c
               WHERE c.cust_id = s.cust_id);

-- (개선: 제거)
SELECT COUNT(*) FROM f_sales s;
```

## Left Outer Join 제거 — Right 유일 + 미참조

```sql
-- 제품 PK에 대한 고정 매칭(유일) + p.* 미참조
SELECT COUNT(*)
FROM   d_customer c
LEFT JOIN d_product p
  ON p.prod_id = 10;

-- (개선) 제거
SELECT COUNT(*) FROM d_customer c;
```

> 단, `p.prod_id = 10` 매칭이 **0 또는 1행**임이 보장(=PK/Unique).
> 또한 `p.*` 컬럼 사용 없음, `p` 조건 추가 없음.

## 자기 조인 제거

```sql
-- (원형)
SELECT a.cust_id
FROM   d_customer a
JOIN   d_customer b ON b.cust_id = a.cust_id;

-- (개선)
SELECT a.cust_id
FROM   d_customer a;
```

## 집계 후 부모 조인 제거

```sql
-- (원형)
SELECT c.cust_id, x.sum_amt
FROM   d_customer c
JOIN  (SELECT s.cust_id, SUM(s.amount) sum_amt
       FROM   f_sales s
       GROUP  BY s.cust_id) x
ON x.cust_id = c.cust_id;

-- (개선)
SELECT s.cust_id, SUM(s.amount) sum_amt
FROM   f_sales s
GROUP  BY s.cust_id;
```

---

# 조인 제거를 유도/보장하는 작성 습관

1) **제약 선언과 검증**
   - Parent **PK/Unique**, Child→Parent **FK ENABLE VALIDATE**, FK 컬럼 **NOT NULL**
   - 실데이터 **고아 행 없음**을 보장해야 옵티마이저가 신뢰

2) **SARGABLE & 단순 동등**
   - 조인키에 **함수/형변환 금지**, 양쪽 **타입 일치**
   - 조인식은 **등치**로 간단히

3) **불필요한 참조/필터 제거**
   - 제거 후보 테이블의 **컬럼을 SELECT/WHERE에서 참조하지 않기**
   - 해당 테이블에 **추가 필터** 두지 않기

4) **뷰 병합과 결합**
   - 필요 시 `MERGE(qb)`(뷰 병합)·`PUSH_PRED` 등으로 **평탄화**를 먼저 만든 뒤, 제거가 눈에 띄게 하라

5) **OR 분해**
   - `USE_CONCAT`로 분기를 나눠, **분기별로 제거 가능성**을 확보

---

# 관찰/검증 루틴

```sql
-- 1) (옵션) 실행 전 통계 스냅샷
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON ms.stat#=sn.stat#
WHERE  sn.name IN ('session logical reads','physical reads','consistent gets');

-- 2) 쿼리 실행 (제거 전/후 버전 각각)

-- 3) 실측 실행계획
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL, 'ALLSTATS LAST +PREDICATE +ALIAS +NOTE'));
```

**체크 포인트**
- 제거 대상 테이블에 대한 `TABLE ACCESS`/`INDEX`/`JOIN` 노드가 **사라졌는가?**
- `A-Rows`(실제 행)·세션 통계(논리/물리 읽기)가 **감소**했는가?
- `Predicate Information`에서 해당 테이블 관련 프레디킷이 **더 이상 등장하지 않는가?**

---

# 흔한 오해와 반례

- **“LEFT JOIN은 항상 제거 가능”** → **오답**. Right에서 **중복**이 발생하면 Left 결과가 증식된다.
  → Right의 **Unique 보장** 또는 **결과 중복 무해** 가 증명되어야 함.

- **“FK만 있으면 무조건 제거”** → **아님**.
  - FK 컬럼이 **NULL 허용**이면 Inner Join은 **NULL 제거** 역할을 하므로 **제거 불가**.
  - Parent **컬럼 참조/필터**가 있으면 **제거 불가**.

- **“제약 DISABLE/NOVALIDATE여도 CBO가 알아서”** → **불확실**.
  - CBO가 **신뢰할 수 있는 제약** 만 활용한다. 운영 정책(VALIDATE/RELY)에 맞춰야 한다.

---

# 튜닝 체크리스트

- [ ] 제거 후보 조인의 **양쪽 키**에 함수/형변환이 없는가?
- [ ] 제거 대상 테이블의 **컬럼을 SELECT/WHERE에서 참조하지 않는가?**
- [ ] 해당 조인이 **필터/중복**을 만들지 않는가? (**FK NOT NULL** + **Parent Unique**)
- [ ] **제약은 ENABLE VALIDATE**(또는 정책상 **RELY**) 상태인가?
- [ ] 외부조인(LEFT/RIGHT)의 경우 Right/Left 측 **중복 불가**가 보장되는가?
- [ ] 뷰/CTE 구성이면 **뷰 병합**을 통해 평탄화했는가? (`MERGE(qb)` 등)
- [ ] OR은 **USE_CONCAT**로 분해해 분기별 제거 가능성을 높였는가?
- [ ] 실측 플랜에서 **해당 테이블 액세스가 사라졌는가?**
- [ ] 세션 통계(논리/물리 읽기)가 **유의미하게 감소**했는가?

---

## 부록 A. 미니 실습 스크립트(한 번에 시험)

```sql
-- 0) 샘플 로드
TRUNCATE TABLE d_customer;
TRUNCATE TABLE d_product;
TRUNCATE TABLE f_sales;

INSERT INTO d_customer VALUES (1,'KOR','VIP');
INSERT INTO d_customer VALUES (2,'USA','STD');
INSERT INTO d_product  VALUES (10,'ELEC','B0');
INSERT INTO d_product  VALUES (20,'HOME','B1');

INSERT INTO f_sales VALUES (100, 1, 10, DATE '2025-03-01', 1, 10000);
INSERT INTO f_sales VALUES (101, 1, 20, DATE '2025-03-02', 2, 15000);
INSERT INTO f_sales VALUES (102, 2, 10, DATE '2025-03-03', 1,  9000);
COMMIT;

-- 1) Inner Join 제거 관찰
EXPLAIN PLAN FOR
SELECT /* before */ s.sales_id
FROM   f_sales s
JOIN   d_customer c ON c.cust_id = s.cust_id
WHERE  s.sales_dt >= DATE '2025-03-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT /* after */ s.sales_id
FROM   f_sales s
WHERE  s.sales_dt >= DATE '2025-03-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 2) EXISTS 제거 관찰
EXPLAIN PLAN FOR
SELECT /* before */ COUNT(*)
FROM   f_sales s
WHERE  EXISTS (SELECT 1 FROM d_customer c WHERE c.cust_id = s.cust_id);
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT /* after */ COUNT(*) FROM f_sales s;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 3) LEFT JOIN 제거(유일 매칭 + 미참조)
EXPLAIN PLAN FOR
SELECT /* before */ COUNT(*)
FROM   d_customer c LEFT JOIN d_product p
  ON p.prod_id = 10;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT /* after */ COUNT(*)
FROM   d_customer c;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 4) 집계 후 부모 조인 제거
EXPLAIN PLAN FOR
SELECT /* before */ c.cust_id, x.sum_amt
FROM   d_customer c
JOIN  (SELECT s.cust_id, SUM(s.amount) sum_amt
       FROM   f_sales s
       GROUP  BY s.cust_id) x
ON x.cust_id = c.cust_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT /* after */ s.cust_id, SUM(s.amount) sum_amt
FROM   f_sales s
GROUP  BY s.cust_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## 부록 B. FAQ

**Q1. 조인 제거를 “강제/금지”하는 힌트가 있나요?**
- 오라클은 **자동 변환**이 기본이다. 일반적으로는 제거를 의도적으로 막고 싶으면 **해당 테이블 컬럼을 참조**하거나, 변환 전체를 막는 `NO_QUERY_TRANSFORMATION`, 또는 **뷰 물리화**(`NO_MERGE`/`MATERIALIZE`)로 우회한다.
- 반대로 제거를 돕고 싶다면 **제약을 검증**하고, **뷰 병합/프레디킷 푸시**가 잘 일어나도록 쿼리를 정리한다.

**Q2. 왜 내 환경에서는 제거가 안 되나요?**
- (1) FK 컬럼이 **NULL 허용**, (2) 제약이 **DISABLE/NOVALIDATE**, (3) Parent **Unique 불명확**,
  (4) Parent 컬럼 **참조/필터**, (5) 뷰 내부에 **분석함수/ROWNUM**, (6) **함수/형변환** 탓에 등가 증명 실패.

**Q3. 제거가 성능에 항상 이득인가요?**
- **그렇다**—대부분의 경우 **I/O/CPU 절감**이 크다.
  다만, 가끔 옵티마이저의 다른 선택(예: 조인필터/Bloom 활용)과 상호작용하므로 **실측 플랜**으로 확인하라.

---

## 맺음말

- **조인 제거**는 “읽지 않아도 되는 테이블은 **아예 읽지 않는다**”는, 가장 강력하고도 안전한 최적화다.
- **FK·PK/Unique·NOT NULL** 로 “필터/중복 없음”을 증명하고, **불필요 참조 제거**와 **SARGABLE** 작성으로 옵티마이저가 확신을 갖게 하라.
- 마지막은 항상 **증거**: `DBMS_XPLAN … ALLSTATS LAST`와 **세션 통계(논리/물리 읽기)** 로 **정말 사라졌는지** 확인하라.
- 이 습관만으로도 **OLTP·DW** 모두에서 **가시적 성능 향상**을 얻을 수 있다.
