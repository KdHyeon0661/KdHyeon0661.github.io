---
layout: post
title: Svelte - 예제 미니 프로젝트 (2)
date: 2025-10-03 23:30:23 +0900
category: Svelte
---
# 16. 실전 예제 미니 프로젝트 (2) — **블로그/문서 사이트 (SSG · RSS · 검색)**
**SvelteKit + mdsvex(마크다운/MDX) · 정적 사이트 생성(SSG) · RSS/Atom · 검색(JSON 인덱스/Minisearch) · 태그/목차/수학 · 코드 하이라이트(Shiki) · 이미지 최적화**

> 목표: SvelteKit로 **빠르고 접근성 좋은** 블로그/문서(Documentation) 사이트를 만든다.  
> - **SSG**: 빌드 시간에 모든 페이지/피드/검색 인덱스를 생성  
> - **콘텐츠**: `/content`의 Markdown/MDX + **frontmatter**  
> - **피드**: `/rss.xml`, `/atom.xml` 정적 생성  
> - **검색**: `/search.json`(메타/토큰) + **Minisearch**(클라이언트)  
> - **수학**: $$ … $$ (remark-math + MathJax or KaTeX)  
> - **문서 사이트**: 사이드바 네비, 버전/섹션, 자동 목차(TOC)

---

## 16.1 프로젝트 구조

```
project/
  svelte.config.js
  mdsvex.config.js
  vite.config.ts
  static/
    favicon.ico
    images/...
  content/
    posts/
      2025-01-hello-sveltekit.md
      2025-02-ssg-deep-dive.md
      ...
    docs/
      getting-started.md
      guide/
        01-installation.md
        02-configuration.md
        advanced/
          01-ssg-strategy.md
    pages/
      about.md
  src/
    lib/
      content/
        posts.ts       # 글 메타/본문 로더
        docs.ts        # 문서 트리/메타
        markdown.ts    # 공통 파서 유틸
        rss.ts         # RSS/Atom builder
        search.ts      # 검색 인덱스 builder
      components/
        Layout.svelte
        BlogCard.svelte
        PostMeta.svelte
        Toc.svelte
        DocSidebar.svelte
        SearchBox.svelte
      styles/
        prose.css
    routes/
      +layout.svelte
      +layout.server.ts
      +page.svelte              # 홈(최근 글)
      blog/
        +page.svelte            # 목록/페이지네이션
        [slug]/
          +page.svelte          # 상세
          +page.ts
      tags/
        [tag]/
          +page.svelte
      docs/
        +layout.svelte
        +layout.ts
        +page.svelte            # 문서 홈(개요)
        [slug]/
          +page.svelte
          +page.ts
      pages/
        [slug]/
          +page.svelte
          +page.ts
      rss.xml/+server.ts
      atom.xml/+server.ts
      search.json/+server.ts
```

- **SSG**: 루트 레이아웃/서버에서 `export const prerender = true` 선언 → 모든 라우트 **정적 HTML/JSON** 생성  
- 컨텐츠는 **파일 시스템 기반**. 빌드 시 `import.meta.glob`으로 수집/파싱 → 메타/본문/TOC/요약 생성  
- 문서 섹션은 **폴더 트리 자체**가 네비게이션이 됨

---

## 16.2 mdsvex & 마크다운 파이프라인

### 16.2.1 mdsvex 설정 (Shiki + remark/rehype 플러그인)
```js
// mdsvex.config.js
import { defineMDSveXConfig as defineConfig } from 'mdsvex';
import remarkFrontmatter from 'remark-frontmatter';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import rehypeSlug from 'rehype-slug';
import rehypeAutolink from 'rehype-autolink-headings';
import rehypeToc from '@jsdevtools/rehype-toc'; // 간단 TOC
import rehypePrettyCode from 'rehype-pretty-code';

const shikiTheme = 'github-dark'; // 또는 'one-dark-pro'

export default defineConfig({
  extensions: ['.md', '.svx', '.mdx'],
  remarkPlugins: [remarkFrontmatter, remarkGfm, remarkMath],
  rehypePlugins: [
    rehypeSlug,
    [rehypeAutolink, { behavior: 'wrap' }],
    [rehypePrettyCode, {
      theme: shikiTheme,
      keepBackground: false
    }],
    [rehypeToc, { headings: ['h2', 'h3'], cssClasses: { toc: 'toc' } }]
  ],
  layout: {
    posts: './src/lib/components/Layout.svelte',
    docs:  './src/lib/components/Layout.svelte',
    pages: './src/lib/components/Layout.svelte'
  }
});
```

### 16.2.2 svelte.config.js 연결
```js
// svelte.config.js
import adapter from '@sveltejs/adapter-static';
import preprocess from 'svelte-preprocess';
import { mdsvex } from 'mdsvex';
import mdsvexConfig from './mdsvex.config.js';

const config = {
  extensions: ['.svelte', ...mdsvexConfig.extensions],
  preprocess: [preprocess(), mdsvex(mdsvexConfig)],
  kit: {
    adapter: adapter(),
    alias: { $content: 'content', $lib: 'src/lib' }
  }
};
export default config;
```

> **어댑터**: 정적 호스팅(Vercel/Netlify/Cloudflare Pages)에 맞춰 **adapter-static** 사용. SSR 기능이 필요하면 다른 어댑터로 교체하되, 이번 예제는 **풀 SSG** 전제.

---

## 16.3 콘텐츠 포맷 (frontmatter)

### 16.3.1 포스트 예시 (`/content/posts/2025-01-hello-sveltekit.md`)
```md
---
title: "Hello SvelteKit"
slug: "hello-sveltekit"
date: "2025-01-15"
updated: "2025-01-20"
summary: "SvelteKit 소개 및 생산성 팁"
tags: ["sveltekit","intro"]
draft: false
cover: "/images/hello-sveltekit.webp"
---

# Hello SvelteKit

여기에 본문 **마크다운**.
수식은 $$E = mc^2$$ 처럼 입력합니다.

```ts
export const greet = (name: string) => `Hello, ${name}!`;
```
```

### 16.3.2 문서 예시 (`/content/docs/guide/01-installation.md`)
```md
---
title: "설치"
slug: "guide/installation"
order: 1
---

# 설치

Node 20+ 권장, PNPM 사용 예:

```bash
pnpm create svelte@latest mydocs
```
```

---

## 16.4 콘텐츠 로더(빌드 타임 수집)

### 16.4.1 공통 타입 & 유틸
```ts
// src/lib/content/markdown.ts
export type Frontmatter = {
  title: string;
  slug?: string;
  date?: string;
  updated?: string;
  summary?: string;
  tags?: string[];
  draft?: boolean;
  cover?: string;
  order?: number;
};

export type PostMeta = Frontmatter & {
  slug: string; // 최종 확정
  type: 'post' | 'page' | 'doc';
  readingTime: string;
  path: string;     // 라우트 path
};

export function calcReadingTime(text: string) {
  const words = text.trim().split(/\s+/).length;
  const mins = Math.max(1, Math.round(words / 250));
  return `${mins} min read`;
}

export function normalizeSlug(file: string, fmSlug?: string) {
  if (fmSlug) return fmSlug;
  return file
    .replace(/^.*\/content\/(posts|docs|pages)\//, '')
    .replace(/\.mdx?$/, '')
    .replace(/^\d{4}-\d{2}-\d{2}-/, ''); // 날짜 prefix 제거(포스트)
}
```

### 16.4.2 포스트 수집
```ts
// src/lib/content/posts.ts
import { calcReadingTime, normalizeSlug, type PostMeta } from './markdown';

const postFiles = import.meta.glob('/content/posts/**/*.md', { eager: true });
type M = { metadata: any; default: { render: () => { html: string } } };

export const posts: PostMeta[] = Object
  .entries(postFiles as Record<string, M>)
  .map(([file, mod]) => {
    const fm = mod.metadata ?? {};
    const slug = normalizeSlug(file, fm.slug);
    const html = mod.default?.render?.().html ?? '';
    const readingTime = calcReadingTime(html.replace(/<[^>]+>/g,' '));
    return {
      ...fm,
      slug,
      type: 'post',
      readingTime,
      path: `/blog/${slug}`
    } as PostMeta;
  })
  .filter(p => !p.draft)
  .sort((a, b) => (b.date?.localeCompare(a.date ?? '') ?? 0));
```

### 16.4.3 문서 수집(트리/사이드바)
```ts
// src/lib/content/docs.ts
import { normalizeSlug, type PostMeta } from './markdown';

const docFiles = import.meta.glob('/content/docs/**/*.md', { eager: true });
type M = { metadata: any };

export const docs: PostMeta[] = Object.entries(docFiles as any).map(([file, mod]) => {
  const fm = (mod as any).metadata ?? {};
  const slug = normalizeSlug(file, fm.slug); // e.g. guide/installation
  return {
    ...fm,
    slug,
    type: 'doc',
    path: `/docs/${slug}`
  };
}).sort((a, b) => (a.order ?? 999) - (b.order ?? 999));

// 사이드바 트리: 'guide/installation' -> ['guide', 'installation']
export type DocNode = { title: string; path?: string; children?: Record<string, DocNode> };
export function buildTree(items: PostMeta[]) {
  const root: Record<string, DocNode> = {};
  for (const it of items) {
    const parts = it.slug.split('/');
    let cur = root;
    let acc = '';
    parts.forEach((p, i) => {
      acc = acc ? `${acc}/${p}` : p;
      cur[p] ??= { title: i === parts.length - 1 ? it.title : p, path: i === parts.length - 1 ? it.path : undefined, children: {} };
      cur = cur[p].children!;
    });
  }
  return root;
}
```

---

## 16.5 레이아웃 & 전역 SSG

### 16.5.1 루트 레이아웃
```svelte
<!-- src/routes/+layout.svelte -->
<script lang="ts">
  export let data: { site: { title:string; url:string; description:string } };
</script>

<svelte:head>
  <title>{data.site.title}</title>
  <meta name="description" content={data.site.description} />
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml"/>
  <link rel="alternate" type="application/atom+xml" title="Atom" href="/atom.xml"/>
</svelte:head>

<a class="skip" href="#main">본문 바로가기</a>
<header class="site">
  <a href="/">🏠 {data.site.title}</a>
  <nav>
    <a href="/blog">블로그</a>
    <a href="/docs">문서</a>
    <a href="/pages/about">소개</a>
  </nav>
</header>
<main id="main"><slot/></main>
<footer class="foot">© {new Date().getFullYear()} • CC BY-NC</footer>

<style>
.skip{position:absolute;left:-9999px}.skip:focus{left:10px;top:10px;background:#fff;padding:8px;border:2px solid}
.site{display:flex;justify-content:space-between;align-items:center;padding:12px}
.foot{margin-top:4rem;padding:2rem 0;border-top:1px solid #eee;color:#667}
</style>
```

```ts
// src/routes/+layout.server.ts
import type { LayoutServerLoad } from './$types';
export const prerender = true;

export const load: LayoutServerLoad = async ({ url }) => {
  return {
    site: {
      title: 'SvelteKit Docs/Blog',
      description: 'SSG, RSS, 검색까지 한 번에',
      url: url.origin
    }
  };
};
```

---

## 16.6 홈 & 블로그 목록/페이지네이션

### 16.6.1 홈 (최근 글)
```svelte
<!-- src/routes/+page.svelte -->
<script lang="ts">
  import { posts } from '$lib/content/posts';
  const latest = posts.slice(0, 5);
</script>

<h1>최신 글</h1>
<ul class="cards">
  {#each latest as p}
    <li>
      <a href={p.path}><strong>{p.title}</strong></a>
      <div class="muted">{p.date} • {p.readingTime}</div>
      <p>{p.summary}</p>
      {#if p.tags?.length}<small>#{p.tags.join(' #')}</small>{/if}
    </li>
  {/each}
</ul>

<style>
.cards{display:grid;gap:1rem}
.muted{color:#667}
</style>
```

### 16.6.2 블로그 인덱스 + 페이지네이션
```svelte
<!-- src/routes/blog/+page.svelte -->
<script lang="ts">
  import { posts } from '$lib/content/posts';
  export let url: URL;
  const page = Number(url.searchParams.get('page') ?? 1);
  const size = 10;
  const start = (page - 1) * size;
  const items = posts.slice(start, start + size);
  const pages = Math.ceil(posts.length / size);
</script>

<h1>블로그</h1>
<ul class="cards">
  {#each items as p}
    <li><a href={p.path}><strong>{p.title}</strong></a><div class="muted">{p.date} • {p.readingTime}</div><p>{p.summary}</p></li>
  {/each}
</ul>

<nav class="pager">
  {#if page>1}<a href={`?page=${page-1}`}>← 이전</a>{/if}
  <span>{page} / {pages}</span>
  {#if page<pages}<a href={`?page=${page+1}`}>다음 →</a>{/if}
</nav>
```

---

## 16.7 포스트 상세(TOC/메타/수학/코드)

### 16.7.1 로드(+page.ts)
```ts
// src/routes/blog/[slug]/+page.ts
import type { PageLoad } from './$types';
import { posts } from '$lib/content/posts';

export const load: PageLoad = async ({ params }) => {
  const meta = posts.find(p => p.slug === params.slug);
  if (!meta) return { notFound: true };
  // mdsvex는 Svelte 컴포넌트로 변환됨 → 동적 import
  const mod = await import(`../../../../content/posts/${meta.slug}.md`);
  return { meta, Content: mod.default };
};
```

> **주의**: slug가 파일명과 정확히 매핑되도록 `normalizeSlug` 규칙을 맞춘다.  
> 날짜 prefix 등 규칙을 사용하면 동일하게 변환해서 import 경로를 구성.

### 16.7.2 페이지(+page.svelte)
```svelte
<!-- src/routes/blog/[slug]/+page.svelte -->
<script lang="ts">
  export let data: { meta?: any; Content?: any; notFound?: boolean };
</script>

{#if data.notFound}
  <h1>404</h1><p>글을 찾을 수 없습니다.</p>
{:else}
  <svelte:head>
    <title>{data.meta.title} – SvelteKit Docs/Blog</title>
    <meta name="description" content={data.meta.summary}/>
    <meta property="og:type" content="article"/>
    <meta property="og:title" content={data.meta.title}/>
    <meta property="og:description" content={data.meta.summary}/>
    {#if data.meta.cover}<meta property="og:image" content={data.meta.cover}/>{/if}
    <link rel="canonical" href={data.meta.path}/>
  </svelte:head>

  <article class="prose">
    <header>
      <h1>{data.meta.title}</h1>
      <p class="muted">{data.meta.date} · {data.meta.readingTime}</p>
      {#if data.meta.tags?.length}
        <p class="tags">{#each data.meta.tags as t}<a href={`/tags/${t}`}>#{t}</a>{/each}</p>
      {/if}
    </header>

    <!-- 본문 (mdsvex 컴포넌트) -->
    <svelte:component this={data.Content} />

    <footer class="muted">마지막 업데이트: {data.meta.updated ?? data.meta.date}</footer>
  </article>
{/if}

<style>
.prose{max-width:800px}
.muted{color:#667}
.tags a{margin-right:.4rem}
</style>
```

### 16.7.3 수학(Markdown $$…$$) — MathJax
> 요구사항: “수학이 있으면 **무조건 $$ 로 감싸** (MathJax)”.

- `app.html`에 MathJax 로더:
```html
<!-- src/app.html (발췌) -->
<head>
  <!-- ... -->
  <script>
    window.MathJax = { tex: { inlineMath: [['$', '$']], displayMath: [['$$','$$']] }, svg: { fontCache: 'global' } };
  </script>
  <script id="mathjax" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
```

- 네비게이션 후 재렌더(클라이언트 훅):
```ts
// src/hooks.client.ts
import { afterNavigate } from '$app/navigation';
afterNavigate(() => {
  // @ts-expect-error
  window.MathJax?.typeset?.();
});
```

> KaTeX로 정적 렌더링을 하고 싶다면 `rehype-katex` + CSS를 쓰면 더 빠르다.  
> 여기서는 **요구사항에 맞춰 MathJax**로 구현.

---

## 16.8 태그 페이지

```svelte
<!-- src/routes/tags/[tag]/+page.svelte -->
<script lang="ts">
  import { posts } from '$lib/content/posts';
  export let params: { tag: string };
  const list = posts.filter(p => p.tags?.includes(params.tag));
</script>

<h1>#{params.tag}</h1>
{#if list.length===0}
  <p>이 태그의 글이 없습니다.</p>
{:else}
  <ul class="cards">
    {#each list as p}
      <li><a href={p.path}><strong>{p.title}</strong></a> <span class="muted">{p.date}</span><p>{p.summary}</p></li>
    {/each}
  </ul>
{/if}
```

---

## 16.9 정적 페이지 (About 등)

```ts
// src/routes/pages/[slug]/+page.ts
import type { PageLoad } from './$types';
import { normalizeSlug } from '$lib/content/markdown';

const pageFiles = import.meta.glob('/content/pages/**/*.md');

export const load: PageLoad = async ({ params }) => {
  const slug = params.slug;
  const key = Object.keys(pageFiles).find(f => normalizeSlug(f).endsWith(slug));
  if (!key) return { notFound: true };
  const mod: any = await pageFiles[key]();
  return { Content: mod.default, meta: mod.metadata ?? { title: slug } };
};
```

```svelte
<!-- src/routes/pages/[slug]/+page.svelte -->
<script lang="ts">
  export let data;
</script>

{#if data.notFound}<h1>404</h1>{:else}
  <svelte:head><title>{data.meta.title}</title></svelte:head>
  <article class="prose"><svelte:component this={data.Content}/></article>
{/if}
```

---

## 16.10 RSS/Atom 피드

### 16.10.1 RSS 빌더 유틸
```ts
// src/lib/content/rss.ts
import type { PostMeta } from './markdown';

const esc = (s: string) => s.replace(/[<>&'"]/g, (c) => ({'<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;'}[c]!));

export function buildRSS({ site, items }: { site: { title:string; url:string; description:string }, items: PostMeta[] }) {
  const feedItems = items.map((p) => `
    <item>
      <title>${esc(p.title)}</title>
      <link>${site.url}${p.path}</link>
      <guid>${site.url}${p.path}</guid>
      <pubDate>${new Date(p.date ?? '').toUTCString()}</pubDate>
      <description>${esc(p.summary ?? '')}</description>
    </item>`).join('');

  return `<?xml version="1.0" encoding="UTF-8"?>
  <rss version="2.0">
    <channel>
      <title>${esc(site.title)}</title>
      <link>${site.url}</link>
      <description>${esc(site.description)}</description>
      ${feedItems}
    </channel>
  </rss>`;
}

export function buildAtom({ site, items }: { site: { title:string; url:string; description:string }, items: PostMeta[] }) {
  const updated = items[0]?.updated ?? items[0]?.date ?? new Date().toISOString();
  const entries = items.map((p) => `
    <entry>
      <title>${esc(p.title)}</title>
      <link href="${site.url}${p.path}"/>
      <id>${site.url}${p.path}</id>
      <updated>${new Date(p.updated ?? p.date ?? '').toISOString()}</updated>
      <summary>${esc(p.summary ?? '')}</summary>
    </entry>`).join('');

  return `<?xml version="1.0" encoding="utf-8"?>
  <feed xmlns="http://www.w3.org/2005/Atom">
    <title>${esc(site.title)}</title>
    <link href="${site.url}/atom.xml" rel="self"/>
    <link href="${site.url}"/>
    <updated>${new Date(updated).toISOString()}</updated>
    <id>${site.url}/</id>
    ${entries}
  </feed>`;
}
```

### 16.10.2 서버 라우트(+server.ts) — **SSG**
```ts
// src/routes/rss.xml/+server.ts
import type { RequestHandler } from './$types';
import { posts } from '$lib/content/posts';
import { buildRSS } from '$lib/content/rss';

export const prerender = true;

export const GET: RequestHandler = async ({ url }) => {
  const xml = buildRSS({
    site: { title:'SvelteKit Docs/Blog', url:url.origin, description:'SSG, RSS, 검색' },
    items: posts.slice(0, 50)
  });
  return new Response(xml, { headers: { 'content-type': 'application/rss+xml; charset=utf-8', 'cache-control':'public, max-age=3600' } });
};
```

```ts
// src/routes/atom.xml/+server.ts
import type { RequestHandler } from './$types';
import { posts } from '$lib/content/posts';
import { buildAtom } from '$lib/content/rss';

export const prerender = true;

export const GET: RequestHandler = async ({ url }) => {
  const xml = buildAtom({ site: { title:'SvelteKit Docs/Blog', url:url.origin, description:'SSG, RSS, 검색' }, items: posts.slice(0, 50) });
  return new Response(xml, { headers: { 'content-type': 'application/atom+xml; charset=utf-8', 'cache-control':'public, max-age=3600' } });
};
```

---

## 16.11 검색(정적 인덱스 + Minisearch)

### 16.11.1 서버에서 **검색 JSON** 생성(SSG)
```ts
// src/lib/content/search.ts
import type { PostMeta } from './markdown';

// 간단 인덱스: 제목/요약/태그만
export function buildSearchIndex(items: PostMeta[]) {
  return items.map(p => ({
    id: p.slug,
    url: p.path,
    title: p.title,
    summary: p.summary ?? '',
    tags: p.tags ?? []
  }));
}
```

```ts
// src/routes/search.json/+server.ts
import type { RequestHandler } from './$types';
import { posts } from '$lib/content/posts';
import { buildSearchIndex } from '$lib/content/search';

export const prerender = true;

export const GET: RequestHandler = async () => {
  const json = JSON.stringify(buildSearchIndex(posts));
  return new Response(json, { headers: { 'content-type':'application/json; charset=utf-8', 'cache-control': 'public, max-age=3600' } });
};
```

### 16.11.2 클라이언트 검색 UI (Minisearch)
```bash
pnpm add minisearch
```

```svelte
<!-- src/lib/components/SearchBox.svelte -->
<script lang="ts">
  import MiniSearch from 'minisearch';
  import { onMount } from 'svelte';

  let q = '';
  let hits: any[] = [];
  let ms: MiniSearch;

  onMount(async () => {
    const data = await fetch('/search.json').then(r=>r.json());
    ms = new MiniSearch({
      fields: ['title', 'summary', 'tags'], // 검색 필드
      storeFields: ['title', 'url', 'summary', 'tags']
    });
    ms.addAll(data);
  });

  $: if (ms && q.trim()) {
    hits = ms.search(q, { prefix: true, fuzzy: 0.1 }).slice(0, 10);
  } else { hits = []; }
</script>

<input placeholder="검색…" bind:value={q} aria-label="검색" />
{#if hits.length}
  <ul class="panel" role="listbox">
    {#each hits as h}
      <li><a href={h.url}><strong>{@html h.title}</strong> <small>{h.tags?.join(', ')}</small><div class="muted">{h.summary}</div></a></li>
    {/each}
  </ul>
{/if}

<style>
.panel{position:absolute;z-index:20;background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:.6rem;max-width:40rem;width:min(90vw,40rem);box-shadow:0 10px 30px rgba(0,0,0,.08)}
.muted{color:#667}
</style>
```

> 대안: **lunr**, **FlexSearch**. 대용량이면 **Algolia/Meilisearch**로 아웃소싱.

---

## 16.12 문서(Documentation) 레이아웃

### 16.12.1 DOC 레이아웃
```svelte
<!-- src/routes/docs/+layout.svelte -->
<script lang="ts">
  import { docs, buildTree } from '$lib/content/docs';
  import DocSidebar from '$lib/components/DocSidebar.svelte';
  const tree = buildTree(docs);
</script>

<div class="doc">
  <aside><DocSidebar {tree}/></aside>
  <section><slot/></section>
</div>

<style>
.doc{display:grid;grid-template-columns:280px 1fr;gap:1.5rem}
@media (max-width: 900px){.doc{grid-template-columns:1fr}}
aside{position:sticky;top:1rem;align-self:start;height:max-content}
</style>
```

```svelte
<!-- src/lib/components/DocSidebar.svelte -->
<script lang="ts">
  export let tree: Record<string, any>;
</script>

<nav class="toc">
  {#each Object.entries(tree) as [seg, node]}
    <details open>
      <summary>{node.title}</summary>
      {#if node.children}
        <ul>
          {#each Object.values(node.children) as child}
            <li>
              {#if child.path}<a href={child.path}>{child.title}</a>{:else}{child.title}{/if}
              {#if child.children}
                <ul>
                  {#each Object.values(child.children) as sub}
                    <li>{#if sub.path}<a href={sub.path}>{sub.title}</a>{:else}{sub.title}{/if}</li>
                  {/each}
                </ul>
              {/if}
            </li>
          {/each}
        </ul>
      {/if}
    </details>
  {/each}
</nav>

<style>
summary{cursor:pointer}
ul{list-style:none;padding-left:1rem}
a{color:#0ea5e9}
</style>
```

### 16.12.2 문서 페이지 로드
```ts
// src/routes/docs/[slug]/+page.ts
import type { PageLoad } from './$types';
import { docs } from '$lib/content/docs';

const fileMap = import.meta.glob('/content/docs/**/*.md');

export const load: PageLoad = async ({ params }) => {
  const meta = docs.find(d => d.slug === params.slug);
  if (!meta) return { notFound: true };

  const fileKey = Object.keys(fileMap).find(k => k.includes(meta.slug));
  if (!fileKey) return { notFound: true };

  const mod: any = await fileMap[fileKey]!();
  return { meta, Content: mod.default };
};
```

```svelte
<!-- src/routes/docs/[slug]/+page.svelte -->
<script lang="ts">
  export let data;
</script>

{#if data.notFound}<h1>404</h1>{:else}
  <svelte:head><title>{data.meta.title} – 문서</title></svelte:head>
  <article class="prose">
    <h1>{data.meta.title}</h1>
    <svelte:component this={data.Content}/>
  </article>
{/if}
```

---

## 16.13 SSG 엔트리(모든 정적 경로 내보내기)

> SvelteKit **정적 프리렌더**에서는 크롤링으로 충분히 발견되지 않는 라우트를 **entries**에 추가해줘야 한다. (예: `/blog/[slug]`, `/docs/[slug]`, `/tags/[tag]`, `/pages/[slug]`)

```ts
// src/routes/docs/+layout.ts (혹은 루트 +layout.ts)
import type { EntryGenerator } from './$types';
import { posts } from '$lib/content/posts';
import { docs } from '$lib/content/docs';

export const prerender = true;

export const entries: EntryGenerator = () => {
  const blog = posts.map(p => `/blog/${p.slug}`);
  const doc = docs.map(d => `/docs/${d.slug}`);
  const tags = Array.from(new Set(posts.flatMap(p => p.tags ?? []))).map(t => `/tags/${t}`);
  const pages = ['/pages/about']; // 필요 시 추가
  return ['/', '/blog', '/docs', ...blog, ...doc, ...tags, ...pages, '/rss.xml', '/atom.xml', '/search.json'];
};
```

---

## 16.14 스타일 & 프로즈

### 16.14.1 프로즈 기본
```css
/* src/lib/styles/prose.css */
.prose { line-height: 1.7; }
.prose h1, .prose h2, .prose h3 { scroll-margin-top: 5rem; }
.prose pre { padding: .8rem; border-radius: 12px; overflow:auto; border:1px solid #eee; }
.prose img { max-width: 100%; border-radius: 12px; }
.prose table { border-collapse: collapse; }
.prose th, .prose td { border: 1px solid #eee; padding:.4rem .6rem; }
.toc { border-left: 3px solid #eee; padding-left: .8rem; margin: 1rem 0; }
```

루트 레이아웃에서 한 번 임포트:
```svelte
<!-- src/routes/+layout.svelte -->
<script>
  import '$lib/styles/prose.css';
</script>
```

---

## 16.15 이미지 최적화(선택)

- 정적 `/static/images/*`에 WebP/AVIF 제공  
- LCP 후보는 `<link rel="preload" as="image">`  
- 본문 이미지는 `width/height` 또는 CSS `aspect-ratio`로 CLS 방지

```svelte
<picture>
  <source srcset="/images/cover.avif" type="image/avif"/>
  <source srcset="/images/cover.webp" type="image/webp"/>
  <img src="/images/cover.jpg" width="1200" height="630" alt="cover"/>
</picture>
```

---

## 16.16 접근성 & SEO

- `<svelte:head>`에서 각 페이지별 **title/description/canonical/OG**  
- 문서/포스트 h2/h3에 자동 slug(링크 복사 용이)  
- 키보드 내비/스킵 링크/명확한 포커스 표시  
- `robots.txt`/`sitemap.xml`(14장/11장 예제 변형)

---

## 16.17 배포(정적 호스팅)

- `adapter-static`으로 **정적 파일** 생성 → Netlify/Vercel/Cloudflare Pages에 업로드  
- 커스텀 도메인 + HTTPS  
- 캐시: `/_app/immutable` 자산은 무기한 캐시, 페이지는 **프리렌더 결과** 제공

`package.json`:
```json
{
  "scripts": {
    "build": "svelte-kit build",
    "preview": "svelte-kit preview"
  }
}
```

---

## 16.18 확장 기능

1) **코멘트**: GitHub Issues/Utterances → 정적 페이지에 위젯 삽입  
2) **OG 이미지**: `/og/[slug]` 서버 라우트로 동적 이미지(11장 참조) 프리렌더  
3) **다국어**: `[[lang]]` 세그먼트 + `hreflang`(11장)  
4) **버전 문서**: `/docs/v1`, `/docs/v2` 폴더 분리 + 버전 스위처  
5) **검색 강화**: 카테고리/가중치/스니펫 하이라이트, Web Worker로 인덱스 로드  
6) **드래프트 미리보기**: `draft: true`는 빌드 제외. 프리뷰 토큰으로 임시 빌드

---

## 16.19 전체 체크리스트 (요약)

- [ ] `adapter-static` + `prerender = true`  
- [ ] `import.meta.glob`으로 **모든 콘텐츠** 로드 → 메타/TOC/읽기시간  
- [ ] 라우트 `entries`에 **동적 경로**(blog/docs/tags/pages) 등록  
- [ ] **RSS/Atom**: `/rss.xml` `/atom.xml` 정적 생성  
- [ ] **검색**: `/search.json` 정적 생성 + **Minisearch UI**  
- [ ] **수학**: $$…$$ + MathJax(typeset after navigate)  
- [ ] **코드 하이라이트**: Shiki( rehype-pretty-code )  
- [ ] **접근성/SEO**: 제목/요약/OG/키보드/대비  
- [ ] **이미지/폰트**: LCP 최적화, 폭/높이 지정

---

## 16.20 마무리

- 이 예제는 **SSG 블로그/문서 사이트의 기본기**를 모두 담았다:  
  - **빠른 배포/낮은 비용**(정적 호스팅)  
  - **완전한 SEO**(정적 HTML + 피드)  
  - **오프라인 친화**(클라이언트 검색)  
- 콘텐츠만 채우면 **즉시 운영 가능**하며, 필요 시 14장(배포/운영), 12장(성능), 11장(SEO/A11y) 내용을 합쳐 **프로덕션 품질**로 확장하면 된다.
