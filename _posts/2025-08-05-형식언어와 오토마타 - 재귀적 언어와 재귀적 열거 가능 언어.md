---
layout: post
title: 형식언어와 오토마타 - 재귀적 언어와 재귀적 열거 가능 언어
date: 2025-08-05 16:20:23 +0900
category: 형식언어와 오토마타
---
# 재귀적 언어와 재귀적 열거 가능 언어

## 한 눈에 보는 포함 관계

$$
\boxed{\ \textbf{Recursive} \;\subsetneq\; \textbf{RE(c.e.)} \;\subsetneq\; \mathcal{P}(\Sigma^*)\ }
$$

- **Recursive(결정 가능)**: 어떤 튜링 기계가 **모든 입력에서 정지**하여 YES/NO를 낸다.
- **RE(c.e., 반결정 가능)**: 어떤 튜링 기계가 언어의 원소에 대해 **언젠가 수용**(정지)한다. (원소가 아니면 **무한히 돈다**일 수도 있음)
- **non-RE**: “예 사례”를 **열거**할 수 있는 알고리즘조차 없다.

---

## 형식적 정의와 등가 특성

### 재귀적(Recursive, 결정 가능) 언어

언어 \(L\subseteq\Sigma^*\)에 대해 다음이 서로 **동치**:

1) **결정기(Decider)** 존재
   - 어떤 TM \(D\)가 **모든 입력에서 정지**하고
     \(w\in L \Rightarrow D(w)=\textsf{accept}\),
     \(w\notin L \Rightarrow D(w)=\textsf{reject}\).

2) **전(總) 계산 가능 특성함수** 존재
   - \(\chi_L:\Sigma^*\!\to\!\{0,1\}\)가 **총 계산 가능(total computable)**.

3) **정확 열거 + 판정**
   - 어떤 **열거기(enumerator)** \(E\)가 \(L\)의 원소를 중복 없이 모두 출력하며, 임의 \(w\)에 대해 **유한 시간 내** \(w\in L\) 여부를 알 수 있다.

> 직관: Recursive = “**언제나 멈추는 검사기**가 있다.”

---

### 재귀적 열거 가능(RE / c.e. / 반결정 가능) 언어

다음이 서로 **동치**:

1) **인식기(Recognizer)** 존재
   - 어떤 TM \(N\)이 \(w\in L\)이면 **언젠가 수용**한다(정지). \(w\notin L\)이면 **영원히** 돌 수 있다.

2) **부분 특성함수** 존재
   - \(\psi:\Sigma^*\rightharpoonup\{0,1\}\)가 **부분 계산 가능(partial computable)** 이고
     \(\psi(w)=1 \iff w\in L\) (그 외는 미정/무한루프 가능).

3) **열거기** 존재
   - 어떤 절차가 \(L\)의 모든 원소를 **언젠가** 출력한다(순서·중복 무관).
   - “예가 있으면 나온다”가 핵심.

> 용어 대응: **RE** = **r.e.** = **c.e.** = **반결정 가능(semi-decidable)**.

---

### 고전 등식: “양쪽이 RE면 Recursive”

$$
L \text{와 } \overline{L} \text{가 모두 RE} \quad\Longleftrightarrow\quad L \text{는 Recursive}.
$$

- **(\(\Rightarrow\)) 도베일링 증명 스케치**
  두 인식기 \(M_+\) (L의 RE)와 \(M_-\) (\(\overline{L}\)의 RE)을 서로 한 걸음씩 **교대로** 달린다.
  어느 쪽이든 먼저 수용하는 순간 답이 결정 → **항상 유한 시간에 정지**.

```text
Decide(w):
  for t = 1,2,3,...:
    simulate M_plus(w) for t steps;  if accept: return YES
    simulate M_minus(w) for t steps; if accept: return NO
```

- **(\(\Leftarrow\))** 자명: 결정기가 있으면 양쪽 모두 RE.

---

## 열거(증인) 관점과 \(\Sigma^0_1\)

RE는 **존재적 증인**이 있는 집합으로도 특징지어진다.

$$
x\in L \iff \exists t\; R(x,t),
$$

여기서 \(R\)은 **결정 가능**(재귀적) 관계. (예: “길이 \(t\) 안에 TM이 \(x\)를 수용한다”)
따라서 RE는 **산술 계층(Arithmetical Hierarchy)** 의 **\(\Sigma^0_1\) 집합**이다.
co-RE는 \(\Pi^0_1\) (모든 \(t\)에 대해 …)에 해당.

> **NP와의 직관 비교**: NP도 “다항 길이 증인”이 있지만 **시간 제한**이 핵심. RE는 **시간 제한 없이** “언젠가 수용”.

---

## 폐포(닫힘) 성질

### Recursive의 닫힘

- **보수**(Complement), **합·교·차**, **연접·Kleene★**, **호모모르피즘/역호모모르피즘**, **정규연산** 전반에 닫힘.

### RE의 닫힘 (대표)

- **YES**: \(\cup\) (합), \(\cap\) (교), **연접**, **Kleene★**, **호모모르피즘**, **역호모모르피즘**,
  **정규 언어와의 교집합**, **Recursive와의 교집합**, **상·역상(λ-자유 치환)** 등.
- **NO**: **보수**(일반적으로 닫히지 않음), 따라서 **차집합**도 일반적으로 닫히지 않음.
  (단, \(L\in\mathrm{RE}, R\in\mathrm{Recursive}\)이면 \(L\cap R, L\setminus R\)은 RE.)

> **교·합의 RE 구성 아이디어**: 두 인식기를 **도베일링**으로 병렬 실행하여
> - 합: 어느 쪽이든 수용하면 수용
> - 교: **두 쪽 모두** 수용하는 순간 수용

---

## 대표 예시 모음

### Recursive(결정 가능)

- 모든 **정규 언어**(DFA/NFA → 선형시간 결정)
- 모든 **문맥 자유 언어**(CYK/Earley 등 다항시간 결정)
- \( \{a^n b^n \mid n\ge 0\}\) (스택/카운터로 결정 가능)
- **균형 괄호** 집합 등 구체 알고리즘 존재

> 예) 균형 괄호 결정기(스택 카운트)

```python
def is_balanced(s):
    c = 0
    for ch in s:
        if ch == '(':
            c += 1
        elif ch == ')':
            c -= 1
            if c < 0: return False
    return c == 0
```

### RE이지만 Recursive가 **아닌** (RE \ Recursive)

- \( \mathbf{A_{TM}} = \{\langle M\rangle \# w \mid M \text{이 } w \text{를 수용}\}\)
  (시뮬레이션으로 **반결정** 가능, 그러나 **결정 불가능** — 정지 문제로 귀류)
- \( \mathbf{K}=\{e \mid \varphi_e(e)\ \text{정지}\}\) — **RE-완전**(Kleene의 자기 참조 집합)
- **PCP-YES**: 주어진 PCP 인스턴스에 **해가 존재**하는 집합 — RE, **결정 불가능**
- **디오판토스 해 존재 집합** (Hilbert 10번째: **존재 여부**는 RE, 결정 불가능)

### non-RE (RE도 co-RE도 아님 혹은 co-RE이지만 RE 아님)

- \( \overline{A_{TM}} \) — **non-RE**
  (만약 RE였다면 \(A_{TM}\)과 함께 Recursive가 되어 모순)
- \( \mathbf{E_{TM}}=\{\langle M\rangle \mid L(M)=\varnothing\}\) — **co-RE**, **RE 아님**
  (보수 \(\{ \langle M\rangle \mid \exists w: M(w)\text{ 수용}\}\)은 RE)
- \( \mathbf{ALL_{TM}}=\{\langle M\rangle \mid L(M)=\Sigma^*\}\) — **RE도 co-RE도 아님**
  (Rice 정리 + 표준 감소로 확인)

---

## 고전 정리들(증명 스케치 포함)

### 정지 문제(HALT)는 결정 불가능

- \( \textsf{HALT}=\{\langle M\rangle\#w \mid M(w)\text{ 정지}\}\)는 결정 불가능.
- **대각선화/귀류**: “정지 여부를 결정한다” 가정 → 자기 입력에서 모순을 만들 수 있다.

### Rice 정리 (모든 비자명 **의미** 속성은 결정 불가능)

- **정리**: “튜링 기계가 인식하는 언어의 **비자명한 의미적 속성**”은 **결정 불가능**.
  (비자명 = 어떤 기계는 속성을 갖고, 어떤 기계는 갖지 않는다)
- **스케치**: HALT/A\_TM에서 해당 속성 판정기로 감소 → 결정 불가능 도출.

> **즉**: “정규성인지?”, “유한/무한인지?”, “공백인지?”, “보편인지?” … **대체로 불가**(Type-0 세계에선).

### RE vs co-RE vs Recursive: 도베일링 정리

위 §1.3 등식. 실무적으로 가장 많이 쓰이는 “**둘 다 RE면 결정 가능**” 트릭.

### (참고) Post–Kleene–Church–Turing 풍경

- **RE = \(\Sigma^0_1\)** (존재적 정량자 1겹)
- **Recursive = \(\Delta^0_1\)**
- 튜링 점프·산술 계층 상위로 올라가면( \(\Sigma^0_k/\Pi^0_k\) ) 더 강한 비결정성/비결정가능성이 등장.

---

## 감소(m-reduction)로 구분하기

### many-one 감소 정의

집합 \(A\)에서 \(B\)로의 **many-one 감소** \(A\le_m B\):
**총 계산 가능 함수** \(f\)가 있어
$$
x\in A \iff f(x)\in B.
$$
- \(A\le_m B\)이고 \(B\)가 결정 가능 ⇒ \(A\)도 결정 가능
- \(A\)가 RE이고 \(A\le_m B\) ⇒ \(B\)는 **RE-어려움**(hard)
- 표준 **완전성**: \(A_{TM}\)은 RE-완전

### 짧은 예: \(A_{TM}\le_m PCP\text{-YES}\)

- 입력 \(\langle M\rangle\#w\)를 받아, “\(M\)이 \(w\)를 수용” ⇔ “구성한 PCP 인스턴스가 해를 가짐” 이 되도록 타일을 조립(계산 테이블 인코딩).
- 따라서 PCP-YES는 **RE-완전** → **결정 불가능**.

---

## 실전 감각: 인식기·열거기·도베일링 예시

### RE 인식기(“예면 언젠가 수용”)

```text
Recognize_A_TM(<M>#w):
  simulate M(w) step-by-step
  if M(w) ever accepts: ACCEPT
  # else loop forever (reject-입력에서 멈추지 않을 수 있음)
```

### RE 열거기(“모든 예를 결국 출력”)

```text
Enumerate_A_TM():
  for s = 1,2,3,...:
    for all pairs (<M>, w) with code length ≤ s:
      simulate M(w) for s steps
      if M(w) accepted within s steps:
        output <M>#w
```

### RE 합·교 구성(도베일링 병렬)

```text
# 두 RE 언어 L1, L2의 인식기 M1, M2가 주어졌다고 하자.

Recognize_Union(w):
  for t = 1,2,3,...:
    step M1(w) once; if M1 accepted: ACCEPT
    step M2(w) once; if M2 accepted: ACCEPT
  # both loop on non-members

Recognize_Intersection(w):
  # '둘 다 accept'가 필요 -> 독립 추적
  for t = 1,2,3,...:
    step M1(w) once; if M1 accepted: f1 := True
    step M2(w) once; if M2 accepted: f2 := True
    if f1 and f2: ACCEPT
```

### “양쪽 RE ⇒ 결정” 도베일링

```text
Decide_if_both_RE(w):
  for t = 1,2,3,...:
    step M_yes(w) once; if M_yes accepted: return YES
    step M_no (w) once; if M_no  accepted: return NO
```

---

## 왜 **non-RE** 는 “증거조차 없다”라고 하나?

RE는 “**존재적 증인 \(t\)**”로 표현된다:
“어떤 \(t\)가 있어 \(R(w,t)\) (결정 가능) 성립.”
**non-RE**는 그러한 **결정 가능한 관계 \(R\)** 와 **유한 길이 증인**으로는 표현되지 않는다.
즉, “예”를 **유한하게 확인**할 메커니즘이 **원리적으로 존재하지 않음**을 뜻한다.

---

## 실전 분류 체크리스트

- (1) **정지 보장?** 모든 입력에서 반드시 답?
  → **Recursive** 후보
- (2) “예” 입력에서 **언젠가** 멈추나?
  → 최소한 **RE** 후보
- (3) 보수도 (2)인가?
  → 둘 다 RE ⇒ **Recursive**
- (4) 위가 아니면 **non-RE** 가능. Rice/감소로 증명 시도.

---

## 작은 실습: “RE지만 Recursive가 아님”을 체감하기

### A\_TM 인식기(반결정)

```text
# input: (<M>, w)
# output: accept iff M accepts w (반결정)

Recognize_ATM(code):
  parse code as <M>#w
  simulate M(w) step-by-step
  if accept observed: ACCEPT
  # reject or loop -> this recognizer might never halt
```

### “결정기”가 불가능함을 느끼기

- 만약 “언젠가 거절도 보장”하는 결정기가 있었다면 정지 문제를 풀 수 있게 되어 모순.
- 실제로 많은 정적 분석/검증 문제가 여기에 걸린다(“모든 입력에서 null-dereference가 없는가?”류).

---

## 자주 묻는 질문(FAQ)

**Q1. 모든 CFL은 RE인가요?**
A. 예, 더 강하게 **Recursive**다(CYK 등 다항시간 결정).

**Q2. 왜 RE는 보수에 닫히지 않나요?**
A. 닫혔다면 RE = co-RE가 되고, §1.3에 의해 모든 RE가 Recursive가 된다.
하지만 \(A_{TM}\)은 RE이면서 Recursive가 아니다 → 모순.

**Q3. co-RE 예를 하나만 더?**
A. \(\mathrm{INF_{TM}}=\{\langle M\rangle \mid |L(M)|=\infty\}\) 의 **보수**(유한 언어)는 co-RE가 아니다 등 다양한 변형이 있다.
일반적으로 **언어의 의미 속성**은 Rice 정리로 **결정 불가능**이며, RE/co-RE 여부는 별도 감소로 나뉜다.

**Q4. “열거기”는 왜 중요하죠?**
A. RE = “효과적인 열거 가능”이기 때문. 실무에선 “포인트를 **찾아내기**는 쉬운데 **없음을 증명**하기는 어려운” 상황과 상응한다.

---

## 연습 문제

1) **보이기**: RE는 **정규 언어와의 교집합**에 닫힌다. (힌트: 정규는 결정 가능 → 제품 구성)
2) **구성하기**: 두 RE 언어 \(L_1,L_2\)에 대해 \(L_1\cdot L_2\) (연접)가 RE임을 보이는 **열거기**를 설계하라.
3) **증명 스케치**: \(\overline{A_{TM}}\)이 **non-RE**임을 §1.3을 써서 두 줄로 적어라.
4) **기출 감각**: “다음 중 RE에 닫혀 있지 않은 연산은?” (A. 보수 B. 합 C. 교 D. Kleene★) → **정답 A**.

---

## 요약 표

| 클래스 | 직관/정의 | 대표 예 | 보수 닫힘 |
|---|---|---|---|
| **Recursive** | **항상 정지**하는 결정기 존재 | 정규, CFL, \( \{a^n b^n\}\), 균형 괄호 | **Yes** |
| **RE \ Recursive** | “예면 언젠가 수용”(거절은 무한루프 가능) | \(A_{TM}\), \(K\), PCP-YES, 디오판토스 해-존재 | **No** |
| **co-RE \ Recursive** | “아니오면 언젠가 수용” | \(E_{TM}\) | **No** |
| **non-RE** | 예 사례 **열거 불가** | \(\overline{A_{TM}}\), \(ALL_{TM}\) (둘 다 neither RE nor co-RE) | — |

---

## 한 페이지 결론

- **Recursive ⊊ RE ⊊ 모든 언어**.
- RE는 “**언젠가 예를 찾아낸다**(존재적 증인)”라는 **\(\Sigma^0_1\)** 관점과 정확히 맞닿는다.
- “양쪽이 RE면 Recursive” 도베일링 트릭은 가장 실무적인 판단도구.
- **Rice 정리**와 **감소**는 “왜 이게 여전히 불가능한가?”를 설명하는 표준 망치다.
- 완전 자동화의 벽은 흔히 **RE / non-RE 경계**에서 온다—제약을 가하면(정규/CFL/유한 모델 등) 많은 문제가 다시 **결정 가능**해진다.
