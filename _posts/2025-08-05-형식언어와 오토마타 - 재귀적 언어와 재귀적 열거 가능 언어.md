---
layout: post
title: 형식언어와 오토마타 - 재귀적 언어와 재귀적 열거 가능 언어
date: 2025-08-05 16:20:23 +0900
category: 형식언어와 오토마타
---
# 재귀적 언어와 재귀적 열거 가능 언어 — 정의, 예시, 구분, 고전 정리들

이 글은 계산가능성 이론의 핵심 개념인 **재귀적(결정 가능) 언어**, **재귀적 열거 가능(반결정 가능, c.e./r.e.) 언어**, 그리고 **재귀적으로 열거 가능하지 않은(non-RE)** 언어를 한꺼번에 정리한다. 각 부류의 **정의**, **동치 특성**, **폐포 성질**, **대표 예시**, **구분 증명 스케치**를 제공한다.

---

## 1) 큰 그림 — 포함 관계

\[
\boxed{\ \text{Recursive} \;\subsetneq\; \text{RE(c.e.)} \;\subsetneq\; \mathcal{P}(\Sigma^*)\ }
\]

- **Recursive(=결정 가능)**: 어떤 튜링 기계가 **모든 입력에서 정지**하여 Yes/No를 말한다.  
- **RE(=c.e., 반결정 가능)**: 어떤 튜링 기계가 **언젠가 수용**하는 방식으로 “예” 사례를 **열거**할 수 있다(거절 사례는 영원히 돌 수도 있음).  
- **non-RE**: 어떤 기계로도 “예” 사례를 열거할 수 없다.

---

## 2) 정의와 동치 특성

### 2.1 재귀적(Recursive, 결정 가능) 언어
언어 \(L\subseteq\Sigma^*\) 에 대해 다음이 서로 동치:

1. (결정기) 어떤 TM \(D\)가 **모든 입력에서 정지**하며 \(w\in L \Rightarrow \text{accept}\), \(w\notin L \Rightarrow \text{reject}\).
2. (특성 함수) **전(總) 계산 가능 함수** \(\chi_L:\Sigma^*\to\{0,1\}\) 가 존재.
3. (정렬 열거) 어떤 **열거기**가 \(L\)의 원소들을 사전식(또는 중복 없이) **정확히** 모두 출력하며, 임의의 \(w\)에 대해 \(w\in L\)인지 **유한 시간에 판정** 가능.

### 2.2 재귀적 열거 가능(RE, c.e., 반결정 가능) 언어
다음이 동치:

1. (인식기) 어떤 TM \(N\)이 \(w\in L\)이면 **언젠가 수용**하고, \(w\notin L\)이면 **정지하지 않을 수도 있다**.
2. (부분 특성 함수) **부분 계산 가능 함수** \(\psi:\Sigma^*\rightharpoonup\{0,1\}\) 가 존재하여 \(\psi(w)=1\iff w\in L\), \(w\notin L\)이면 **미정** 가능.
3. (열거기) 어떤 **열거기**가 정확히 \(L\)의 모든 원소를 **어떤 순서로든** 출력한다.  
   (즉, “예” 사례가 **있으면 언젠가 나온다**.)

> 용어: RE = r.e. = c.e.(computably enumerable) = **반결정 가능(semi-decidable)**.

### 2.3 기본 정리
\[
L \text{와 } \overline{L} \text{가 모두 RE} \;\Longleftrightarrow\; L \text{는 Recursive}.
\]
(한쪽과 그 보수가 모두 열거 가능하면, 양쪽 모두 유한 시간에 판정 가능해진다 — **도베일링**으로 두 인식기를 병렬 시뮬레이션하여 먼저 끝나는 쪽의 답을 채택.)

---

## 3) 폐포(Closure) 스냅샷

- **Recursive**: 합·교·차·보수·역상/상 이미지(호모모르피즘) 등 **대부분의 연산에 닫힘**.
- **RE**:  
  - **Yes**: 합집합, 교집합, 연접, Kleene★, 역호모모르피즘, 존재적 정량자(\(\Sigma^0_1\) 성질)  
  - **No**: **보수**에는 일반적으로 **닫혀 있지 않음**. (RE ∩ coRE = Recursive)

---

## 4) 예시 모음

### 4.1 재귀적(결정 가능) 언어의 예
- 모든 **정규 언어**(DFA로 선형시간 결정 가능)
- 모든 **문맥 자유 언어**(CYK/Earley 등으로 다항시간 결정 가능)
- \(\{a^n b^n\mid n\ge 0\}\), \(\{w\mid w \text{ 에 괄호가 균형}\}\) 등 (적절한 알고리즘 존재)

### 4.2 RE지만 재귀적이 **아닌** 언어 (RE \(\setminus\) Recursive)
- \(\displaystyle \mathbf{A_{TM}}=\{\langle M\rangle \# w \mid M \text{이 } w \text{를 수용}\}\)  
  (인식기는 “\(M(w)\)”를 시뮬레이션하여 수용 시 accept → **RE**.  
  하지만 **정지 문제** 귀류로 **결정 불가능**.)
- \(\mathbf{K}=\{e \mid \varphi_e(e)\ \text{가 정지}\}\) (자기입력 정지 집합) — **RE-완전**.
- **PCP(우해 존재)**: 주어진 인스턴스가 **해를 갖는가**의 집합 — **RE**, **결정 불가능**.
- **디오판토스 방정식 해 존재 집합**(Hilbert 10번째 문제의 “예” 측) — **RE**, **결정 불가능**.

### 4.3 RE가 **아닌** 언어 (non-RE)
- \(\overline{\mathbf{A_{TM}}}\) (A\_TM의 보수) — **non-RE**.  
  (A\_TM이 RE이면서 재귀적이 아님 ⇒ 그 보수는 RE일 수 없다. 위 기본 정리 참고.)
- \(\mathbf{E_{TM}}=\{\langle M\rangle \mid L(M)=\varnothing\}\) — **co-RE**, **RE 아님**.  
  (보수 \(\{\langle M\rangle\mid L(M)\neq\varnothing\}\) 은 “어떤 \(w\)가 수용됨”을 찾으면 되므로 **RE**.)
- \(\mathbf{ALL_{TM}}=\{\langle M\rangle \mid L(M)=\Sigma^*\}\) — **RE도 co-RE도 아님**(Rice + 표준 감소).

> 직관: **non-RE** 집합은 “예” 증거를 **유한 시간에 검증/탐지**할 알고리즘이 **원천적으로 없다**.

---

## 5) 구분 증명 스케치

### 5.1 \(A_{TM}\) 은 RE지만 재귀적이 아니다
- **RE성**: 입력 \(\langle M\rangle,w\)에서 \(M\)을 시뮬레이션. 수용하면 accept(정지). 거절/루프면 그냥 돈다.
- **비결정성(결정 불가능)**: “정지 문제” 표준 귀류 또는 리스(Rice) 정리로 유도.

### 5.2 \(\overline{A_{TM}}\) 은 non-RE
- 만약 \(\overline{A_{TM}}\) 이 RE라면 \(A_{TM}\)과 \(\overline{A_{TM}}\) 둘 다 RE ⇒ \(A_{TM}\)은 **Recursive** (기본 정리).  
  하지만 \(A_{TM}\)은 재귀적이 아님(위) ⇒ 모순.

### 5.3 \(E_{TM}\) 은 co-RE이지만 RE가 아니다
- **co-RE**: \(\overline{E_{TM}}=\{\langle M\rangle\mid \exists w: M(w)\ \text{수용}\}\) 을 인식  
  (모든 \(w\)를 도베일링하며 \(M(w)\) 시뮬 → 어떤 \(w\)라도 수용하면 accept).  
- **RE 아님**: 만약 RE였다면 co-RE ∩ RE = Recursive ⇒ 공백성은 결정 가능해야 하나 **리스 정리**로 불가능.

---

## 6) 열거 관점과 \(\Sigma^0_1\) (초등 해석)

- RE 집합은 “존재적 양화가 밖에 있는” 꼴의 술어로 표현된다:
  \[
  x\in L \iff \exists t\ \ R(x,t),
  \]
  여기서 \(R\)은 **결정 가능(재귀적)** 한 관계. (예: “길이 \(t\) 안에 \(M(x)\)가 수용한다”)  
  ⇒ RE = **아리스토텔레스 계층**의 \(\Sigma^0_1\) 집합.
- co-RE는 \(\Pi^0_1\)(모든 t에 대해 …)에 해당.

이 관점은 “RE는 존재적인 ‘증인’(certificate)이 있는 언어”라는 **NP와의 유사 직관**을 준다.  
차이: 여기서는 **시간 제한이 없다**(튜링 정지 여부 차원).

---

## 7) 작은 FAQ

- **Q. 모든 CFL은 RE인가?** A. 네, 더 강하게 **Recursive** 다(멤버십이 다항시간에 결정 가능).  
- **Q. RE는 왜 보수에 닫혀 있지 않은가?** A. 닫혀 있었다면 RE = co-RE ⇒ 모든 RE가 Recursive가 되어 \(A_{TM}\)과 모순.  
- **Q. “열거기”는 꼭 필요할까?** A. 예. “RE ↔ 어떤 효과적 과정이 ‘예’ 사례를 모두 뽑아낸다”는 등식은 실무적/개념적 직관을 준다.

---

## 8) 요약 표

| 클래스 | 직관/정의 | 대표 예 | 보수 폐포 |
|---|---|---|---|
| **Recursive** | 모든 입력에서 정지하는 **결정기** 존재 | 정규, CFL, \( \{a^n b^n\}\) | **Yes** |
| **RE \(\setminus\) Recursive** | “예”면 언젠가 수용; “아니오”는 무한루프 가능 | \(A_{TM}\), \(K\), PCP-YES, 디오판토스 해 존재 | **No** |
| **co-RE \(\setminus\) Recursive** | “아니오”면 언젠가 판정; “예”는 무한루프 가능 | \(E_{TM}\) | **No** |
| **non-RE** | “예” 사례를 열거할 방법조차 없음 | \(\overline{A_{TM}}\), \(ALL_{TM}\), TM-동일성 | — |

---

## 9) 미니 의사코드: 도베일링으로 \(L\)과 \(\overline{L}\)이 RE이면 \(L\)을 결정

```text
# M_yes: L의 인식기 (w∈L이면 언젠가 accept)
# M_no : ȽL의 인식기 (w∉L이면 언젠가 accept)

Decide(w):
  for t = 1,2,3,...:
    simulate M_yes(w) for t steps; if it accepts: return YES
    simulate M_no (w) for t steps; if it accepts: return NO
```

둘 중 하나는 반드시 언젠가 수용 ⇒ 유한 시간에 결정.

---

## 10) 결론

- **Recursive ⊊ RE ⊊ 모든 언어**: 결정 가능 ↔ 반결정 가능 ↔ 비열거.  
- 실전에서 “**정적 분석의 한계**”, “**완전 자동 검증 불가**” 같은 메시지는 바로 **RE/non-RE 경계**에서 나온다.  
- 판단 불가능성은 피할 수 없으나, **제한된 모델(정규/CFL/DPDA 등)** 로 문제를 재정의하면 많은 성질이 다시 **결정 가능**해진다.
