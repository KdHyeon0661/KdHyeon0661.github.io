---
layout: post
title: 이산수학 - 일반화된 수열과 조합
date: 2025-06-08 22:20:23 +0900
category: 이산수학
---
# 🔄 일반화된 수열과 조합 (Generalized Sequences & Combinations)

## 표기, 배경, 큰그림

- 집합의 크기를 $$|A|$$, 자연수 집합을 $$\mathbb{N}=\{0,1,2,\dots\}$$ 로 둡니다.
- **중복 허용·순서 무시**(*multicombination*, ‘사탕 문제’)와
  **순서/라벨/용량** 제약(‘창고·인벤토리·CPU 슬롯’)을 별개로 다룹니다.
- **선형 점화 수열**은 조합적 모델의 “갯수 함수”로 자주 등장합니다(타일링/경로/스케줄).

---

## — 기본부터 상·하한 제약까지

### 정의·기본 공식

서로 다른 종류가 $$n$$개, 각 종류를 **중복 허용**하여 총 $$r$$개 선택(순서 무시):

$$
\boxed{\text{중복 조합 수}=\binom{n+r-1}{r}=\binom{n+r-1}{n-1}}.
$$

- 해석: 정수해의 개수 문제 $$x_1+\cdots+x_n=r,\ x_i\ge 0$$ 과 동치.

### 하한/상한이 있을 때(재고·용량 제약)

- 하한 $$L_i$$, 상한 $$U_i$$ 가 있을 때
  $$
  x_1+\cdots+x_n=r,\quad L_i\le x_i\le U_i
  $$
  를 만족하는 해의 개수는 **포함배제**로
  $$
  \#=\sum_{S\subseteq [n]}(-1)^{|S|}\binom{(r-\sum_i L_i)-\sum_{i\in S}(U_i-L_i+1)+n-1}{n-1}.
  $$
  (정의역을 $$y_i=x_i-L_i\ (\ge 0)$$ 로 평행이동 후, 상한 위반을 포함배제로 제거.)

- **균일 상한** $$0\le x_i\le U$$, 합 $$r$$:
  $$
  \#=\sum_{j=0}^{\lfloor r/(U+1)\rfloor}(-1)^j\binom{n}{j}\binom{r-j(U+1)+n-1}{n-1}.
  $$

### 생성함수 시점

- 각 항목은 $$1+x+x^2+\cdots=\frac{1}{1-x}$$, $$n$$종이면
  $$
  \left(\frac{1}{1-x}\right)^n=\sum_{r\ge 0}\binom{n+r-1}{r}x^r.
  $$
- 상한 $$U_i$$ 는 $$1+x+\cdots+x^{U_i}$$ 로 반영.

### 실무 모델링 예시

- **인벤토리 배분**: CPU 코어 $$n$$종(스레드 클래스), 총 $$r$$ 태스크를 클래스별로 배정.
  *상한(코어별 슬롯)* 있으면 포함배제나 DP.
- **가게 묶음 할인**: 상품종류 $$n$$, 장바구니 품목수 합 $$r$$, 품목별 최대 구매량 한도.

### 파이썬 구현(상·하한 포함)

```python
from math import comb

def multicomb(n, r):
    # 기본 중복 조합: (n+r-1 choose r)
    if r < 0: return 0
    return comb(n+r-1, r)

def multicomb_bounded(L, U, r):
    """
    x_i in [L[i], U[i]], sum x_i = r 의 해 개수 (포함배제)
    L, U: 길이 n 리스트, 각 L[i] <= U[i]
    """
    n = len(L)
    R = r - sum(L)
    if R < 0: return 0
    # 포함배제 over subsets via bitmask (n <= 20 정도 권장)
    total = 0
    for mask in range(1 << n):
        bits = 0
        shift = 0
        for i in range(n):
            if mask >> i & 1:
                bits += 1
                shift += (U[i] - L[i] + 1)
        total += ((-1) ** bits) * comb(R - shift + n - 1, n - 1) if R - shift >= 0 else 0
    return total

# 예시

print(multicomb(3, 5))  # 사탕 3종에서 5개 = 21
print(multicomb_bounded([0,0,0], [2,2,5], 5))  # 상한 제약 예시
```

---

## 다항 계수와 다항 정리 — 분할·라벨·역할 할당

### 다항 계수 정의

서로 다른 $$n$$개를 $$m$$개의 그룹 크기 $$k_1,\dots,k_m$$로 분할(순서 무시, 그룹에 **라벨 또는 역할**이 있음):

$$
\boxed{\binom{n}{k_1,\dots,k_m}=\frac{n!}{k_1!\cdots k_m!}},\quad \sum k_i=n.
$$

### 다항 정리

$$
(x_1+\cdots+x_m)^n=\!\!\sum_{k_1+\cdots+k_m=n}\!\!\binom{n}{k_1,\dots,k_m}\prod_{i=1}^m x_i^{k_i}.
$$

### 실전 포인트

- **배치/역할**: “QA 3명, 서버 4명, 클라 3명” 같이 *역할 라벨*이 붙으면 다항계수.
- **좌석/권한 부여**: 권한 종류가 라벨이면 다항, **팀의 순서 무관**이면 마지막에 $$m!$$ 로 나눔.

### 파이썬: 다항계수 & 무작위 샘플(다항 분포)

```python
from math import factorial
import random

def multinomial_coeff(parts):
    # parts = [k1,...,km], sum(parts) = n
    n = sum(parts)
    den = 1
    for k in parts:
        den *= factorial(k)
    return factorial(n) // den

def sample_multinomial(n, probs):
    """
    n회 실험, 범주 확률 probs(합=1).
    반환: 카운트 리스트
    """
    from bisect import bisect
    pref = []
    s = 0.0
    for p in probs:
        s += p; pref.append(s)
    cnt = [0]*len(probs)
    for _ in range(n):
        u = random.random()
        i = bisect(pref, u)
        cnt[i] += 1
    return cnt

print(multinomial_coeff([3,4,3]))  # 10명을 3/4/3
print(sample_multinomial(10, [0.3,0.4,0.3]))
```

---

## — ‘덧셈 중심’ 조합

### 정의

정수 $$n$$을 *순서 무시* 합으로 나타내는 방법의 수를 $$p(n)$$. 예:
$$4=4=3+1=2+2=2+1+1=1+1+1+1 \Rightarrow p(4)=5.$$

### 생성함수(가장 중요)

$$
\sum_{n\ge 0}p(n)x^n=\prod_{k\ge 1}\frac{1}{1-x^k}.
$$

### 핵심 정리·사실

- **Distinct vs Odd** 동치: “모두 다른 수”로 분할하는 수 = “모두 홀수”로 분할하는 수.
  (오일러의 놀라운 결과)
- **오일러 오각수 정리(빠른 재귀)**:
  $$
  p(n)=\sum_{k\in\mathbb{Z}\setminus\{0\}}(-1)^{k-1}p\!\left(n-\frac{k(3k-1)}{2}\right),
  $$
  범위를 벗어나면 0, $$p(0)=1$$.
- **점근식(하디–라마누잔)**:
  $$
  p(n)\sim \frac{1}{4n\sqrt{3}}\,\exp\!\left(\pi\sqrt{\frac{2n}{3}}\right).
  $$

### vs 오각수 재귀(고속)

```python
def partitions_dp(n):
    # O(n sqrt n) 정도: 1,2,3,... 동전 무한개 조합수
    dp = [0]*(n+1)
    dp[0] = 1
    k = 1
    while k <= n:
        for s in range(k, n+1):
            dp[s] += dp[s - k]
        k += 1
    return dp[n]

def partitions_pentagonal(n):
    # 오일러 오각수 기반 재귀/DP
    p = [0]*(n+1)
    p[0] = 1
    for m in range(1, n+1):
        total = 0
        k = 1
        while True:
            g1 = k*(3*k-1)//2
            g2 = k*(3*k+1)//2
            if g1 > m: break
            total += (-1)**(k-1)*p[m-g1]
            if g2 <= m:
                total += (-1)**(k-1)*p[m-g2]
            k += 1
        p[m] = total
    return p[n]

print(partitions_dp(100))
print(partitions_pentagonal(100))
```

### 제약 분할

- **최대 부품 개수 $$\le m$$**: 생성함수 $$\prod_{k\ge 1}\frac{1-x^{(m+1)k}}{1-x^k}$$.
- **부품의 최대 크기 $$\le M$$**: $$\prod_{k=1}^{M}\frac{1}{1-x^k}$$.
- **모두 서로 다른 부품**: $$\prod_{k\ge 1}(1+x^k).$$

---

## 일반화 수열 — 선형 점화, k-step, 생성함수·행렬

### 선형 점화의 표준형

$$
a_n=c_1 a_{n-1}+c_2 a_{n-2}+\cdots+c_k a_{n-k},\quad (n\ge k)
$$
- **특성다항식** $$\lambda^k-c_1\lambda^{k-1}-\cdots-c_k=0$$
- 근이 단순하면 **일반해**는 $$a_n=\sum_j \alpha_j \lambda_j^n$$.

### k-step Fibonacci (Tribonacci 등)

$$
G_n=\sum_{i=1}^{k}G_{n-i},\quad \text{초기값 지정}.
$$
- 생성함수:
  $$
  G(x)=\frac{\text{초기다항식}(x)}{1-\sum_{i=1}^{k}x^i}.
  $$
- **지배근**의 크기 $$>1$$ 이면 $$G_n\sim C\cdot \rho^n$$ (지수적 성장).

### 조합적 해석(타일링/경로)

- 길이 $$n$$ 선분을 길이 1…k 타일로 덮는 경우의 수가 k-step 수열.
  (1·2 타일 ⇒ 피보나치)

### 빠른 계산: 행렬 거듭제곱 / 키타마사(Kitamasa)

```python
# k-step: a_n = sum_{i=1..k} c[i]*a_{n-i}, 0-index 초기값 a[0..k-1]
# Kitamasa: O(k^2 log n)

def kitamasa(coeff, init, n):
    # coeff: c1..ck, init: a0..a_{k-1}, compute a_n
    k = len(coeff)
    if n < len(init): return init[n]

    def combine(p, q):
        # 多項式 합성: p(x)*q(x) mod (x^k - sum c_i x^{k-i})
        k = len(coeff)
        r = [0]*k
        for i in range(k):
            if p[i] == 0: continue
            for j in range(k):
                r[min(i+j, k-1)] += p[i]*q[j]
        # reduce 고차항
        for d in range(2*k-2, k-1, -1):
            t = r[d - (k-1)]
            if t:
                for i in range(1, k+1):
                    r[d - i] += t*coeff[i-1]
        return r[:k]

    # x^n mod characteristic
    pol = [0]*k; pol[1 if k>1 else 0] = 1  # x
    res = [0]*k; res[0] = 1               # 1
    nn = n
    while nn:
        if nn & 1:
            res = combine(res, pol)
        pol = combine(pol, pol)
        nn >>= 1

    # a_n = sum res[i]*a_i for i=0..k-1
    ans = 0
    for i in range(k):
        ans += res[i]*init[i]
    return ans

# Tribonacci: a_n = a_{n-1}+a_{n-2}+a_{n-3}, a0=0,a1=0,a2=1

coeff = [1,1,1]; init = [0,0,1]
print(kitamasa(coeff, init, 25))
```

---

## 일반화 이항계수 — 실수/음수/q-이항(가우스 이항)

### 실수/음수 지수 이항계수

$$
\binom{\alpha}{r}=\frac{\alpha(\alpha-1)\cdots(\alpha-r+1)}{r!},\quad r\ge 0.
$$
- **Newton 이항정리(무한급수)**: $$ (1+x)^\alpha=\sum_{r\ge 0}\binom{\alpha}{r}x^r,\ |x|<1.$$
- **음수 상한**: $$\binom{-\alpha}{r}=(-1)^r\binom{\alpha+r-1}{r}.$$

### 이항계수(유한체 조합)

$$
\boxed{\binom{n}{k}_q=\frac{(q^n-1)(q^{n-1}-1)\cdots(q^{n-k+1}-1)}{(q^k-1)(q^{k-1}-1)\cdots(q-1)}}
$$
- 해석: $$\mathbb{F}_q^n$$ 의 **$$k$$-차원 부분공간** 개수.
- q-이항정리(기본형):
  $$
  \prod_{i=0}^{n-1}(1+q^i x)=\sum_{k=0}^n q^{\binom{k}{2}}\binom{n}{k}_q x^k.
  $$

### 구현 스니펫(q-이항)

```python
def q_binom(n, k, q):
    if k < 0 or k > n: return 0
    num, den = 1, 1
    for i in range(k):
        num *= (q**(n - i) - 1)
        den *= (q**(i + 1) - 1)
    return num // den  # q가 정수면 딱 나눠떨어짐

print(q_binom(4, 2, 2))  # F_2^4에서 2차원 부분공간 수
```

---

## ‘사람/물건/상자’ 표 — 구분/라벨 유무에 따른 공식을 한눈에

| 볼(물건) | 상자(그룹) | 상자 라벨 | 중복 | 비어있음 허용 | 경우의 수(대표) |
|---|---|---|---|---|---|
| **서로 다름** | **라벨** | Yes | Yes | Yes | $$m^n$$ (함수수) |
| 서로 다름 | 라벨 | Yes | No | No | **전사함수**: $$m!\,S(n,m)$$ |
| 서로 다름 | **무라벨** | - | - | No | **집합분할**: $$S(n,1)+\cdots+S(n,n)$$ (스털링 수 합) |
| **서로 같음** | 라벨 | Yes | Yes | Yes | Stars & Bars: $$\binom{n+m-1}{m-1}$$ |
| 서로 같음 | 라벨 | Yes | No | Yes | 상한 1: $$\binom{m}{n}$$ |
| 서로 같음 | 라벨 | Yes | 상한 U | Yes | 포함배제/생성함수 |
| 서로 같음 | **무라벨** | - | - | - | 정수 분할(파티션) |

> 실무 팁: **라벨 유무**(부서명/권한/서버 ID)와 **서로 다름/같음**(개체 식별성)부터 고정하세요.

---

## 통합 예제 — 상황 → 모델링 → 수식/알고리즘

### 재고·인벤토리(상·하한)

- 품목 5종, 총 20개 판매, 품목별 하한/상한: $$L=[0,0,2,0,1],\ U=[10,7,5,6,3]$$.
  **질문:** 가능한 주문 배치 수?
  **해법:** `multicomb_bounded(L,U,20)`.

### 팀편성과 역할

- 10명 중 (3,4,3) 명으로 **역할 라벨**(FE/BE/QA)을 부여:
  $$\binom{10}{3,4,3}=12{,}600.$$
- 역할의 순서가 *의미 없으면* 결과를 $$3!$$ 로 나눔.

### 통신 슬롯·대역폭(상한 동일)

- 베이스스테이션 8개, 사용자 20명(서로 같음), 각 BS 상한 4:
  $$
  \sum_{j=0}^{\lfloor 20/5\rfloor}(-1)^j\binom{8}{j}\binom{20-5j+8-1}{8-1}.
  $$

### 정수 분할 기반의 적재 시나리오

- 서버에 작업 크기 합이 $$N$$, 작업은 **크기 제한 없음·서로 같음**: 분할의 수 = $$p(N)$$.
  크기 제한/서로 다름 여부에 따라 생성함수/DP 선택.

### k-step 수열로 보는 타일링

- 길이 $$n$$ 을 길이 1/2/3 타일로 덮는 경우의 수 = **Tribonacci**.
  대규모 $$n$$ 은 `kitamasa` 로 $$O(k^2\log n)$$에 계산.

---

## 검산·항등식(필수 레퍼런스)

- **다항계수 합**: $$\sum_{k_1+\cdots+k_m=n}\binom{n}{k_1,\dots,k_m}=m^n.$$
- **반더몬드**: $$\sum_k \binom{m}{k}\binom{n}{r-k}=\binom{m+n}{r}.$$
- **중복 조합의 상향 귀납**: $$\binom{n+r-1}{r}=\binom{n+r-2}{r}+\binom{n+r-2}{r-1}.$$
- **Distinct vs Odd**(파트): $$\prod_{k\ge 1}(1+x^k)=\prod_{k\ge 1}\frac{1}{1-x^{2k-1}}.$$
- **이항 변환**: $$b_n=\sum_{k=0}^n \binom{n}{k}a_k \iff a_n=\sum_{k=0}^n(-1)^{n-k}\binom{n}{k}b_k.$$

---

## 실전용 파이썬 유틸(모듈화 스니펫)

```python
from math import comb, factorial

# Stars & Bars

def stars_bars(n_types, total):
    return comb(n_types + total - 1, total)

# Stars & Bars with uniform cap U

def stars_bars_cap(n_types, total, U):
    s = 0
    for j in range(0, total // (U+1) + 1):
        s += (-1)**j * comb(n_types, j) * comb(total - j*(U+1) + n_types - 1, n_types - 1)
    return s

# Multinomial coefficient

def multinomial(parts):
    n = sum(parts)
    den = 1
    for k in parts: den *= factorial(k)
    return factorial(n) // den

# Partitions via Euler pentagonal recursion

def partition_count(n):
    p = [0]*(n+1); p[0] = 1
    for m in range(1, n+1):
        tot = 0; k = 1
        while True:
            g1 = k*(3*k-1)//2; g2 = k*(3*k+1)//2
            if g1 > m: break
            tot += (-1)**(k-1) * p[m - g1]
            if g2 <= m: tot += (-1)**(k-1) * p[m - g2]
            k += 1
        p[m] = tot
    return p[n]

# k-step linear recurrence via Kitamasa (see earlier)

def k_step(coeff, init, n):
    # thin wrapper around the earlier kitamasa
    return kitamasa(coeff, init, n)

print("S&B:", stars_bars(3, 5))
print("S&B cap:", stars_bars_cap(8, 20, 4))
print("Multinomial(10 -> 3,4,3):", multinomial([3,4,3]))
print("p(100):", partition_count(100))
```

---

## 체크리스트(모델링 순서)

1) **개체가 서로 같은가/다른가?**
2) **그룹(상자/역할)에 라벨이 있는가?**
3) **상한/하한/총합 제약**은?
4) **순서 고려**(배열) vs **순서 무시**(선택·합)?
5) **큰 $$n$$**(성능): DP/포함배제/생성함수/행렬거듭제곱/키타마사 선택.

---

## 미니 연습(힌트 포함)

1) (상한) 사탕 5종, 총 14개, 각 종 최대 4개. 경우의 수?
   ⇒ `stars_bars_cap(5, 14, 4)`.

2) (파트) $$p(50)$$ 을 오각수 DP로 계산하라.
   ⇒ `partition_count(50)`.

3) (다항) 12명을 2/5/5명으로 역할 배정, 팀 순서 무의미.
   ⇒ $$\binom{12}{2,5,5}/3!$$.

4) (k-step) $$a_n=a_{n-1}+a_{n-3}$$, $$a_0=a_1=a_2=1$$, $$a_{10}?$$
   ⇒ `k_step([1,0,1],[1,1,1],10)`.

5) (중복+상한 혼합) 물류센터 7곳(슬롯 상한 6), 박스 25개(서로 같음).
   ⇒ 균일 상한 포함배제.

---

## 결론

- **중복 조합**은 “선택의 합 = 총량” 문제의 표준 도구이며, **상·하한**은 포함배제/생성함수로 확장됩니다.
- **다항계수**와 **다항정리**는 라벨 있는 다중 분할/배치의 기본 언어입니다.
- **정수 분할**은 “덧셈 중심” 조합의 왕도로, 생성함수·오각수 재귀·점근식까지 함께 이해해야 합니다.
- **일반화 수열(선형 점화, k-step)**은 타일링·경로·스케줄의 갯수 함수를 설명하며, **행렬/키타마사**로 대규모를 효율 계산합니다.
- **일반화 이항계수**(실수/음수/q-)는 이항정리 확장과 유한체 조합(선형대수)까지 다리를 놓습니다.
