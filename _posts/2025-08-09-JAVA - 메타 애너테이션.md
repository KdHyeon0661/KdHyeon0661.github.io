---
layout: post
title: Java - 메타 애너테이션
date: 2025-08-09 17:20:23 +0900
category: Java
---
# 메타 애너테이션(Meta-Annotations) — @Target, @Retention, @Documented, @Inherited, @Repeatable

메타 애너테이션은 **애너테이션을 정의할 때** 그 애너테이션의 **적용 위치, 유지 범위, 문서 포함 여부, 상속 방식, 반복 가능성** 등을 지정하는 애너테이션입니다.  
모두 `java.lang.annotation` 패키지에 있으며, 주로 아래 다섯 가지를 사용합니다.

- `@Target` — 어디에 붙일 수 있는가?
- `@Retention` — 언제까지 살아남는가?
- `@Documented` — Javadoc에 보일 것인가?
- `@Inherited` — 서브클래스가 상속받는가?
- `@Repeatable` — 같은 애너테이션을 여러 번 붙일 수 있는가?

---

## 0) 빠른 개요 표

| 메타 애너테이션 | 핵심 기능 | 자주 쓰는 값/설정 | 비고 |
|---|---|---|---|
| `@Target` | 적용 가능한 **대상** 제한 | `TYPE`, `METHOD`, `FIELD`, `PARAMETER`, `CONSTRUCTOR`, `TYPE_USE`, `TYPE_PARAMETER` 등 | 최소 범위로 제한할수록 안전 |
| `@Retention` | 애너테이션 **유지 기간** | `SOURCE`, `CLASS`(기본값), `RUNTIME` | 런타임 리플렉션 필요 시 **RUNTIME** |
| `@Documented` | Javadoc에 노출 | (값 없음) | 공개 API 애너테이션에 권장 |
| `@Inherited` | 클래스 **상속 여부** | (값 없음) | **클래스에만** 적용. 인터페이스/멤버에는 적용 안 됨 |
| `@Repeatable` | **반복 적용** 가능 | 컨테이너 애너테이션 타입 지정 | 컨테이너의 `@Target/@Retention`은 원 애너테이션과 동일해야 함 |

---

## 1) @Target — “어디에 붙일 수 있나?”

### 지원값(대표)
- `TYPE`(클래스/인터페이스/enum/record), `FIELD`, `METHOD`, `PARAMETER`, `CONSTRUCTOR`,  
  `LOCAL_VARIABLE`, `ANNOTATION_TYPE`(메타 애너테이션), `PACKAGE`,  
  **`TYPE_PARAMETER`**(제네릭 타입 매개변수, Java 8+), **`TYPE_USE`**(타입이 쓰이는 모든 곳, Java 8+),  
  `MODULE`(Java 9+), `RECORD_COMPONENT`(Java 14+).

> 보통 **정확히 필요한 위치만 허용**하도록 좁게 지정하세요. (유효하지 않은 사용을 컴파일 타임에 차단)

### 예시 1 — 메서드 전용 애너테이션
```java
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExecutionTime {}
```

### 예시 2 — TYPE_USE / TYPE_PARAMETER 활용
```java
import java.lang.annotation.*;

@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface NonEmpty {}

class Sample<@NonEmpty T> {
    void run() {
        String s = (@NonEmpty String) "a"; // 타입 사용 위치에도 부착 가능
    }
}
```

---

## 2) @Retention — “언제까지 남겨둘 건가?”

- `SOURCE` : **컴파일러 전용**. `.class`로 가지 않음(컴파일 시 사라짐).  
  → 예: `@Override`, 코드 분석/체크용.
- `CLASS` : `.class`에는 남지만 **런타임 리플렉션으로는 못 봄**(기본값).  
  → 바이트코드 변환기, 링크 단계 도구 등에 유용.
- `RUNTIME` : 런타임에도 유지, **리플렉션으로 조회 가능**.  
  → 프레임워크/컨테이너(AOP, DI 등)에서 **반드시 필요**.

> **흔한 실수**: Retention을 지정하지 않아 기본 `CLASS`가 되어, 런타임에 `getAnnotation()`으로 안 보이는 문제.  
> **리플렉션으로 읽을 거면 `@Retention(RetentionPolicy.RUNTIME)`**을 반드시 지정하세요.

### 예시
```java
import java.lang.annotation.*;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Role {
    String value();
}
```

---

## 3) @Documented — “Javadoc에 노출할까?”

- `@Documented`가 붙은 애너테이션은 **Javadoc 생성 시 문서에 포함**됩니다.
- 공개 라이브러리의 **공개용 애너테이션**이라면 가급적 붙이세요.

```java
import java.lang.annotation.*;

@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PublicApi {}
```

---

## 4) @Inherited — “서브클래스가 상속받는가?”

- **클래스 수준(TYPE)** 애너테이션에만 의미가 있습니다.  
  (메서드/필드/생성자/매개변수/인터페이스에는 적용되지 않음)
- 부모 클래스에 붙은 애너테이션을 **자식 클래스에서 자동으로 보이게** 합니다.
- **주의**: 인터페이스에 붙인 애너테이션은 구현 클래스에 자동 상속되지 않습니다.

### 예시 & 주의점
```java
import java.lang.annotation.*;

@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Audited {}

// 부모에 부착
@Audited
class Parent {}

// 자식은 @Audited가 명시적으로 없어도 getAnnotation(Audited.class)에 잡힘
class Child extends Parent {}

// 하지만 메서드에는 적용 안 됨 (아래는 '상속'되지 않음)
class A {
    @Deprecated
    public void m() {}
}
class B extends A { /* B.m()에 @Deprecated가 자동으로 붙지 않는다 */ }
```

---

## 5) @Repeatable — “같은 애너테이션을 여러 번 붙일 수 있나?”

- 한 대상에 **동일 애너테이션을 여러 번** 적용할 수 있게 합니다.
- **컨테이너 애너테이션**(배열 요소를 담는 껍데기)을 별도로 정의해야 하며,  
  컨테이너의 `@Target`/`@Retention`은 **반드시 원(반복될) 애너테이션과 동일**하게 맞춰야 합니다.
- 리플렉션 시 **`getAnnotationsByType(원애너테이션.class)`** 를 쓰면 반복된 개별 애너테이션을 평평하게(flat) 받아옵니다.  
  (`getAnnotation(컨테이너.class)`로도 접근 가능하지만 번거롭습니다)

### 정의 & 사용 예시
```java
import java.lang.annotation.*;

@Repeatable(Tags.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Tag {
    String value();
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Tags {
    Tag[] value();
}

// 사용
@Tag("java")
@Tag("annotation")
class Article {}

// 조회
class Demo {
    public static void main(String[] args) {
        Tag[] tags = Article.class.getAnnotationsByType(Tag.class);
        for (Tag t : tags) System.out.println(t.value()); // java / annotation
    }
}
```

---

## 6) 함께 쓰일 때의 상호작용 & 규칙

- `@Repeatable` 사용 시 **컨테이너의 Retention/Target = 원 애너테이션과 동일**(불일치하면 경고/오동작).
- 런타임에서 읽을 애너테이션은 **반드시 `@Retention(RUNTIME)`**.
- 공개 API 애너테이션은 `@Documented` 권장.
- `@Inherited`는 **클래스 상속에만** 작동. 인터페이스 구현/멤버에는 적용되지 않음.
- `@Target`은 **최소 권한 원칙**으로 좁게 지정(잘못된 사용을 컴파일 타임에 차단).

---

## 7) 실전 패턴

### 7.1 AOP/DI용 마커 애너테이션
```java
import java.lang.annotation.*;

@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Injectable {}

// 런타임 스캐너가 @Injectable 클래스를 빈으로 등록
```

### 7.2 검증(Validation) 애너테이션
```java
import java.lang.annotation.*;

@Documented
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface Range {
    int min();
    int max();
}
```
검증기에서 리플렉션으로 읽고 값 검사.

### 7.3 TYPE_USE로 정밀 제어
```java
import java.lang.annotation.*;

@Target(ElementType.TYPE_USE)
@Retention(RetentionPolicy.RUNTIME)
@interface NonNull {}

class Ex {
    String join(@NonNull String a, @NonNull String b) { return a + b; }
}
```

---

## 8) 디버깅/리플렉션 팁

- 반사 조회 시:
  - **클래스**: `getAnnotation`, `getAnnotationsByType`, `getDeclaredAnnotation(s)`
  - **메서드/필드**: 동일하게 `getAnnotation` 계열 사용
- **반복 애너테이션**은 `getAnnotationsByType(원애너테이션.class)`로 바로 개별 요소 얻기.
- **보이지 않음 문제** 대부분은 `@Retention` 누락(= 기본 CLASS) 때문.

---

## 9) 체크리스트(요약)

- 어디에 붙일까? → `@Target`  
- 언제 읽을까? → `@Retention`(SOURCE/CLASS/RUNTIME)  
- 문서화할까? → `@Documented`  
- 서브클래스에도 보이게? → `@Inherited` (**클래스만**)  
- 여러 번 붙이고 싶다? → `@Repeatable` + 컨테이너 정의  
- 공개 API라면: `@Documented` + 테스트 포함  
- 프레임워크에서 읽는다면: `@Retention(RUNTIME)` 필수
