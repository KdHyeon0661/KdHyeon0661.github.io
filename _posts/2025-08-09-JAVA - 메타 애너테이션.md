---
layout: post
title: Java - 메타 애너테이션
date: 2025-08-09 17:20:23 +0900
category: Java
---
# 메타 애너테이션(Meta-Annotations)

## 한눈에 개요 표

| 메타 애너테이션 | 핵심 의미 | 대표 값/설정 | 비고·버전 |
|---|---|---|---|
| `@Target` | **부착 가능한 위치** 제한 | `TYPE`, `METHOD`, `FIELD`, `PARAMETER`, `CONSTRUCTOR`, `LOCAL_VARIABLE`, `ANNOTATION_TYPE`, `PACKAGE`, `MODULE`(9+), `TYPE_PARAMETER`(8+), `TYPE_USE`(8+), `RECORD_COMPONENT`(14+) | **최소 범위로** 좁혀 오용을 컴파일 타임에 차단 |
| `@Retention` | **유지 기간** | `SOURCE`, `CLASS`(기본), `RUNTIME` | 런타임 리플렉션 필요하면 **RUNTIME** 필수 |
| `@Documented` | Javadoc에 **노출** | (값 없음) | 공개 API 애너테이션에 권장 |
| `@Inherited` | **클래스 상속 시 전파** | (값 없음) | **클래스 수준(TYPE)** 에만 의미. 멤버/인터페이스에는 동작 X |
| `@Repeatable` | **동일 애너테이션 중복 부착** | 컨테이너 애너테이션 지정 | 컨테이너의 Target/Retention은 **원 애너테이션과 동일**해야 함 |

---

## @Target — “어디에 붙일 수 있나?”

### 지원 값과 버전 메모

- **기본**: `TYPE`, `FIELD`, `METHOD`, `PARAMETER`, `CONSTRUCTOR`, `LOCAL_VARIABLE`, `ANNOTATION_TYPE`, `PACKAGE`
- **Java 8+**: `TYPE_PARAMETER`(제네릭 타입 변수), `TYPE_USE`(타입이 쓰이는 모든 위치)
- **Java 9+**: `MODULE`(module-info.java에 부착)
- **Java 14+**: `RECORD_COMPONENT`(레코드 컴포넌트)

> 원칙: **정확히 필요한 위치만** 허용하라. 오용을 컴파일 단계에서 차단하여 API 품질을 높인다.

### 예제 — 메서드 전용

```java
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExecutionTime {}
```

### 예제 — TYPE_USE/TYPE_PARAMETER 활용 (정밀한 타입 애너테이션)

```java
import java.lang.annotation.*;

@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface NonEmpty {}

class Box<@NonEmpty T> {
    @SuppressWarnings("all")
    String join(String a, String b) {
        String s = (@NonEmpty String) a; // 타입 사용 위치에도 적용
        return s + b;
    }
}
```

### 예제 — RECORD_COMPONENT, MODULE, PACKAGE

```java
// RECORD_COMPONENT (Java 14+)
@Target(ElementType.RECORD_COMPONENT)
@Retention(RetentionPolicy.RUNTIME)
@interface Label { String value(); }

record User(@Label("identifier") String id, String name) {}


// PACKAGE: package-info.java에 붙인다
@API(status = API.Status.STABLE) // 예시
package com.example.mylib;

import org.apiguardian.api.API;


// MODULE: module-info.java에 붙인다 (Java 9+)
@AuditedModule(owner="platform-team")
module com.example.app {
    requires com.example.core;
}
```

---

## @Retention — “언제까지 남겨둘 건가?”

- `SOURCE` : **컴파일러 전용**. `.class`에 남지 않는다. (예: `@Override`)
- `CLASS` : `.class`에는 남지만 **리플렉션으로 보이지 않음**(기본값)
- `RUNTIME` : 런타임까지 유지되어 **리플렉션 조회 가능**

> **흔한 실수**: Retention을 지정하지 않아 기본 `CLASS`가 되어 런타임에 `getAnnotation()`이 빈값을 반환.
> 프레임워크나 런타임 처리 목적이라면 반드시 `@Retention(RetentionPolicy.RUNTIME)`.

### RUNTIME vs CLASS 동작 차이 확인

```java
import java.lang.annotation.*;
import java.lang.reflect.*;

// 런타임 유지
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE)
@interface Role { String value(); }

// 클래스까지만 유지
@Retention(RetentionPolicy.CLASS) @Target(ElementType.TYPE)
@interface Internal {}

@Role("admin") @Internal
class Demo {}

class Test {
    public static void main(String[] args) {
        Annotation[] anns = Demo.class.getAnnotations();
        for (Annotation a : anns) System.out.println(a); // @Role만 출력
        System.out.println(Demo.class.isAnnotationPresent(Internal.class)); // false
    }
}
```

---

## @Documented — “Javadoc에 보이게 할까?”

```java
import java.lang.annotation.*;

@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PublicApi {
    String since() default "";
}
```

- 라이브러리 공개용 애너테이션은 가급적 `@Documented`를 붙여 **사용자 문서에 노출**한다.

---

## @Inherited — “서브클래스에서 자동으로 보이나?”

- **클래스 수준(TYPE)** 애너테이션에만 의미가 있다.
- 부모 클래스에 지정된 애너테이션을 **자식 클래스에서 `getAnnotation()`으로 조회**할 때에도 보이게 한다.
- 인터페이스/멤버(필드/메서드/생성자)에는 적용되지 않는다.

### 예제 & 주의

```java
import java.lang.annotation.*;

@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Audited {}

@Audited
class Parent {}

class Child extends Parent {}

class Check {
    public static void main(String[] args) {
        System.out.println(Child.class.isAnnotationPresent(Audited.class)); // true
        // 단, getDeclaredAnnotation은 부모로부터 '상속된' 것은 반환하지 않는다.
        System.out.println(Child.class.getDeclaredAnnotation(Audited.class)); // null
    }
}
```

---

## @Repeatable — “여러 번 붙여도 되는가?”

- 동일 애너테이션을 반복 적용하려면 **컨테이너 애너테이션**이 필요하다.
- 컨테이너의 `@Target/@Retention`은 **원 애너테이션과 일치**해야 한다.
- 리플렉션 시 **`getAnnotationsByType(원애너테이션.class)`**가 개별 요소 배열을 반환한다.

### 정의 & 사용

```java
import java.lang.annotation.*;

@Repeatable(Tags.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Tag { String value(); }

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Tags { Tag[] value(); }

// 사용
@Tag("java") @Tag("annotation")
class Article {}

// 조회
class Demo {
    public static void main(String[] args) {
        for (Tag t : Article.class.getAnnotationsByType(Tag.class)) {
            System.out.println(t.value());
        }
    }
}
```

### 흔한 실수

- 컨테이너에 `@Retention(RUNTIME)`을 빼먹어 런타임에 읽히지 않는 경우
- 컨테이너의 `@Target`이 원 애너테이션과 다를 경우 경고/오동작

---

## 리플렉션과의 올바른 결합

### 선언 애너테이션 vs 타입 애너테이션 조회

- 선언(선언부) 애너테이션: `getAnnotation(s)`, `getDeclaredAnnotation(s)`
- **타입 애너테이션(TYPE_USE)**: `getAnnotatedType()`, `Executable#getAnnotatedParameterTypes()`

```java
import java.lang.annotation.*;
import java.lang.reflect.*;

@Target(ElementType.TYPE_USE)
@Retention(RetentionPolicy.RUNTIME)
@interface NonNull {}

class UseTypeAnno {
    String concat(@NonNull String a, @NonNull String b) { return a + b; }

    static void inspect() throws Exception {
        Method m = UseTypeAnno.class.getDeclaredMethod("concat", String.class, String.class);
        AnnotatedType[] ats = m.getAnnotatedParameterTypes();
        for (AnnotatedType at : ats) {
            System.out.println(at.getAnnotations().length); // 각 파라미터의 타입 애너테이션 수
        }
    }
}
```

### RECORD_COMPONENT 애너테이션 조회 (Java 16+ API)

```java
record User(@Label("id") String id, String name) {}

class R {
    public static void main(String[] args) {
        for (var rc : User.class.getRecordComponents()) {
            System.out.println(rc.getName());
            for (var a : rc.getAnnotations()) {
                System.out.println("  " + a);
            }
        }
    }
}
```

---

## SOURCE 애너테이션 & 애너테이션 프로세서(선택)

`@Retention(SOURCE)`는 컴파일 시에만 의미가 있으므로 **애너테이션 프로세서**로 처리한다.

```java
// 애너테이션 정의
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.TYPE)
public @interface AutoBuilder {}

// (간단 스텁) Processor
@SupportedAnnotationTypes("com.example.AutoBuilder")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class AutoBuilderProcessor extends AbstractProcessor {
    public boolean process(Set<? extends TypeElement> annos, RoundEnvironment env) {
        for (Element e : env.getElementsAnnotatedWith(AutoBuilder.class)) {
            // e 정보를 바탕으로 소스/리소스 생성
        }
        return true; // 우리가 처리했다
    }
}
```

---

## PACKAGE/MODULE 애너테이션 — package-info.java / module-info.java

### PACKAGE

- `package-info.java` 파일의 패키지 선언 **위**에 부착
```java
@Stable
package com.example.api;

import com.example.meta.Stable;
```

### MODULE (Java 9+)

- `module-info.java` 파일 상단에 부착
```java
@AuditedModule(owner="core-team", since="1.2")
module com.example.core {
    exports com.example.core.api;
}
```

> `@Target(ElementType.MODULE)`이 선언된 애너테이션만 module-info.java에 부착 가능.

---

## 실전 패턴 모음

### DI/AOP용 마커 애너테이션

```java
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Injectable {
    Scope scope() default Scope.SINGLETON;
    enum Scope { SINGLETON, PROTOTYPE }
}
```
- 런타임 스캐너가 `@Injectable` 클래스를 찾아 빈 등록.

### 검증 애너테이션(필드/파라미터)

```java
@Documented
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface Range {
    int min();
    int max();
}
```
- 검증기에서 리플렉션으로 값을 읽어 범위 체크.

### Nullness/상태 표현 — TYPE_USE

```java
@Target(ElementType.TYPE_USE)
@Retention(RetentionPolicy.RUNTIME)
public @interface NonNull {}
```
- Checker Framework와 같은 정적 분석 도구, 혹은 런타임 검증 로직에 활용.

### 반복 태깅 — @Repeatable

```java
@Repeatable(Roles.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Role { String value(); }

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Roles { Role[] value(); }
```

---

## JPMS(모듈 시스템)와의 상호작용 요점

- 애너테이션 자체는 모듈 경계를 특별히 변경하지 않지만, **리플렉션으로 읽으려면 대상 패키지가 모듈에서 개방**되어 있어야 할 수 있다.
- 런타임 리플렉션을 수행하는 프레임워크(예: Jackson, Hibernate)는 대상 패키지에 대해 **`opens`** 또는 실행 옵션 `--add-opens`가 필요할 수 있다.
- 메타 애너테이션과는 별개이지만 **설계 시 함께 고려**:
  - 공개 API 패키지: `exports`
  - 리플렉션 필요 패키지: `opens` (필요 시 `opens ... to 특정모듈`)

---

## 종합 예제 — 올바른 메타 애너테이션 조합과 사용

### 정의: 서비스 메타데이터 애너테이션

```java
import java.lang.annotation.*;

@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Inherited // 서브클래스도 기본 정책 상속
public @interface ServiceInfo {
    String name();
    String since() default "";
    String owner() default "unknown";
}
```

### 사용: 부모/자식, 런타임 조회

```java
@ServiceInfo(name="BasePayment", owner="pay-team", since="2.0")
class PaymentService {}

class CardPaymentService extends PaymentService {}

class Inspect {
    public static void main(String[] args) {
        // 상속 여부 확인: @Inherited 덕분에 true
        System.out.println(CardPaymentService.class.isAnnotationPresent(ServiceInfo.class));

        ServiceInfo s = CardPaymentService.class.getAnnotation(ServiceInfo.class);
        System.out.printf("%s/%s%n", s.name(), s.owner()); // BasePayment/pay-team
    }
}
```

---

## 디버그/학습용 리플렉션 유틸 (스캐너)

```java
import java.lang.annotation.*;
import java.lang.reflect.*;
import java.util.*;

public final class AnnScanner {
    public static void printAll(Class<?> type) {
        System.out.println("== Class ==");
        for (Annotation a : type.getAnnotations()) System.out.println(a);

        System.out.println("== Declared Methods ==");
        for (Method m : type.getDeclaredMethods()) {
            System.out.println(m.getName());
            for (Annotation a : m.getAnnotations()) System.out.println("  " + a);
            // 파라미터 타입 애너테이션(TYPE_USE)
            AnnotatedType[] ps = m.getAnnotatedParameterTypes();
            for (int i = 0; i < ps.length; i++) {
                System.out.println("  param#" + i + " type anns=" + Arrays.toString(ps[i].getAnnotations()));
            }
        }

        if (type.isRecord()) {
            System.out.println("== Record Components ==");
            for (var rc : type.getRecordComponents()) {
                System.out.println("  " + rc.getName() + " " + Arrays.toString(rc.getAnnotations()));
            }
        }
    }
}
```

---

## 베스트 프랙티스 체크리스트

- [ ] **Target 최소화** — 필요한 위치만 허용하여 오용/남용 방지
- [ ] **Retention 의도대로** — 런타임 처리라면 반드시 `RUNTIME`
- [ ] **Documented** — 공개 API 애너테이션은 문서에 노출
- [ ] **Inherited 사용 위치** — 클래스 수준에만 의미, 멤버/인터페이스에는 X
- [ ] **Repeatable 정합성** — 컨테이너의 Target/Retention을 원 애너테이션과 동일하게
- [ ] **TYPE_USE/TYPE_PARAMETER** — 타입 수준 단언/검증이 필요하면 적극 활용
- [ ] **패키지/모듈 레벨** — package-info.java/module-info.java로 메타 지정
- [ ] **리플렉션/JPMS** — 리플렉션으로 읽을 패키지는 `opens` 설계(또는 `--add-opens`)
- [ ] **테스트** — 리플렉션으로 의도대로 읽히는지 단위 테스트에 포함

---

## 부록 A — ElementType 빠른 참조 표

| ElementType | 적용 대상 | 비고 |
|---|---|---|
| `TYPE` | 클래스/인터페이스/enum/record | 가장 흔함 |
| `FIELD` | 필드(멤버 변수) | 상수/상태 메타 |
| `METHOD` | 메서드 | AOP/권한/문서화 |
| `PARAMETER` | 파라미터(선언) | 인자 검증 |
| `CONSTRUCTOR` | 생성자 | 팩토리/주입 |
| `LOCAL_VARIABLE` | 지역 변수 | 제한적 사용 |
| `ANNOTATION_TYPE` | 애너테이션 타입 | 메타-애너테이션 |
| `PACKAGE` | 패키지 | package-info.java |
| `TYPE_PARAMETER` (8+) | 제네릭 타입 변수 | `class Box<@A T>` |
| `TYPE_USE` (8+) | 타입 사용 모든 위치 | `(@A String)`, `List<@A T>` |
| `MODULE` (9+) | 모듈 선언 | module-info.java |
| `RECORD_COMPONENT` (14+) | 레코드 컴포넌트 | `record User(@A String id)` |

---

## 부록 B — Retention 선택 가이드

| 목적 | 권장 Retention | 이유 |
|---|---|---|
| 코드 스타일/컴파일러 힌트 | `SOURCE` | 바이너리에 불필요 |
| 바이트코드 도구/링커용 메타 | `CLASS` | 클래스엔 남고 런타임엔 불필요 |
| 프레임워크 런타임 처리 | `RUNTIME` | 리플렉션으로 읽어야 함 |

---

## 결론

메타 애너테이션은 “**애너테이션의 설계 계약**”이다.
**Target은 최소로, Retention은 의도대로, Documented는 공개 API에, Inherited는 클래스 수준에, Repeatable은 컨테이너 정합성**을 지키면서 설계하라.
타입 시스템을 풍부하게 활용하려면 **TYPE_USE/TYPE_PARAMETER**를 적극 도입하고, **패키지/모듈 레벨** 메타까지 포함해 일관된 정책을 제공하라.
마지막으로, **리플렉션/JPMS**와의 결합을 미리 테스트하여 배포 환경에서도 애너테이션이 **의도대로 관찰/작동**하는지 확인하는 습관이 중요하다.
