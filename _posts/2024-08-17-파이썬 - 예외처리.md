---
layout: post
title: 파이썬 - 예외처리
date: 2024-08-17 19:20:23 +0900
category: Python
---
# 파이썬 예외 처리

예외 처리는 프로그램이 예기치 않은 상황을 우아하게 처리하고, 에러 발생 시에도 안정적으로 동작하도록 보장하는 핵심 기술입니다. 파이썬의 예외 처리 시스템은 직관적이면서도 강력하여, 작은 스크립트부터 대규모 애플리케이션까지 다양한 상황에서 활용됩니다. 이 글에서는 예외 처리의 기본 개념부터 고급 패턴까지 실제 예제를 통해 자세히 알아보겠습니다.

## 예외 처리의 두 가지 접근 방식: EAFP vs LBYL

### EAFP (Easier to Ask Forgiveness than Permission)

"허락보다 용서가 쉽다"라는 철학으로, 먼저 코드를 실행하고 예외가 발생하면 처리하는 방식입니다. 파이썬에서 권장되는 스타일입니다.

```python
# EAFP 스타일 예제
def process_file_eafp(filepath):
    """EAFP 방식으로 파일 처리"""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        return content
    except FileNotFoundError:
        return f"파일을 찾을 수 없습니다: {filepath}"
    except PermissionError:
        return f"파일 접근 권한이 없습니다: {filepath}"
    except UnicodeDecodeError:
        return f"파일 인코딩 문제: {filepath}"

# 사용 예제
result = process_file_eafp("data.txt")
print(result)
```

### LBYL (Look Before You Leap)

"뛰기 전에 살펴보라"는 철학으로, 실행 전에 조건을 검사하는 방식입니다.

```python
# LBYL 스타일 예제
import os

def process_file_lbyl(filepath):
    """LBYL 방식으로 파일 처리"""
    if not os.path.exists(filepath):
        return f"파일을 찾을 수 없습니다: {filepath}"
    
    if not os.access(filepath, os.R_OK):
        return f"파일 읽기 권한이 없습니다: {filepath}"
    
    # 파일 크기 검사 (너무 큰 파일 처리 방지)
    if os.path.getsize(filepath) > 10 * 1024 * 1024:  # 10MB
        return f"파일이 너무 큽니다: {filepath}"
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        return content
    except UnicodeDecodeError:
        return f"파일 인코딩 문제: {filepath}"

# 사용 예제
result = process_file_lbyl("data.txt")
print(result)
```

### 어떤 방식을 선택해야 할까?

- **EAFP**가 일반적으로 권장됩니다:
  - 코드가 더 간결하고 직관적입니다
  - 경합 조건(race condition)에 더 안전합니다
  - 파이썬다운(Pythonic) 스타일입니다
- **LBYL**은 다음과 같은 경우 유용합니다:
  - 사전 검사 비용이 낮고 자주 발생하는 에러가 있을 때
  - 특정 조건에서 작업을 완전히 피하고 싶을 때
  - 여러 단계의 검증이 필요한 복잡한 작업에서

## 기본 예외 처리 구문

### try-except 블록

가장 기본적인 예외 처리 구조입니다.

```python
# 기본 try-except 예제
def divide_numbers(a, b):
    """두 수를 나누는 함수"""
    try:
        result = a / b
        return result
    except ZeroDivisionError:
        return "0으로 나눌 수 없습니다."
    except TypeError:
        return "숫자 타입이 아닙니다."

# 사용 예제
print(divide_numbers(10, 2))      # 5.0
print(divide_numbers(10, 0))      # 0으로 나눌 수 없습니다.
print(divide_numbers(10, "2"))    # 숫자 타입이 아닙니다.

# 여러 예외를 한 번에 처리
def process_input(user_input):
    """사용자 입력 처리"""
    try:
        number = int(user_input)
        return f"입력된 숫자: {number}"
    except (ValueError, TypeError):
        return "유효한 숫자가 아닙니다."

print(process_input("123"))       # 입력된 숫자: 123
print(process_input("abc"))       # 유효한 숫자가 아닙니다.
```

### else와 finally 절

```python
# else와 finally 사용 예제
def process_data(filename):
    """데이터 처리 함수"""
    file = None
    try:
        file = open(filename, 'r', encoding='utf-8')
        data = file.read()
        
        # 추가적인 검증
        if not data:
            raise ValueError("파일이 비어 있습니다")
            
    except FileNotFoundError:
        print(f"파일을 찾을 수 없습니다: {filename}")
        return None
    except ValueError as e:
        print(f"데이터 오류: {e}")
        return None
    else:
        # 예외가 발생하지 않았을 때만 실행
        print("파일을 성공적으로 읽었습니다.")
        return data
    finally:
        # 항상 실행 (자원 정리)
        if file and not file.closed:
            file.close()
            print("파일을 닫았습니다.")

# 사용 예제
result = process_data("data.txt")
if result:
    print(f"처리된 데이터 길이: {len(result)}")
```

### 예외 정보 활용하기

```python
# 예외 정보 상세히 활용하기
import traceback

def analyze_exception():
    """예외 정보 분석"""
    try:
        # 의도적으로 예외 발생
        numbers = [1, 2, 3]
        print(numbers[10])  # IndexError 발생
    except IndexError as e:
        print("예외 정보:")
        print(f"  예외 타입: {type(e).__name__}")
        print(f"  메시지: {e}")
        print(f"  예외 인수: {e.args}")
        
        # 트레이스백 정보
        print("\n트레이스백 정보:")
        tb_info = traceback.format_exc()
        print(tb_info)
        
        # 파일에 로그 저장
        with open("error.log", "a", encoding="utf-8") as log_file:
            log_file.write(f"{'-'*50}\n")
            log_file.write(tb_info)
        
        # 사용자에게 친숙한 메시지
        return "목록에서 항목을 찾을 수 없습니다. 인덱스를 확인해주세요."

# 사용 예제
result = analyze_exception()
print(f"\n사용자 메시지: {result}")
```

## 예외의 계층 구조와 사용자 정의 예외

### 파이썬의 예외 계층 구조

파이썬의 예외는 계층 구조를 이루고 있습니다:

```
BaseException
 ├── KeyboardInterrupt
 ├── SystemExit
 ├── GeneratorExit
 └── Exception
      ├── ArithmeticError
      │    ├── ZeroDivisionError
      │    └── OverflowError
      ├── LookupError
      │    ├── IndexError
      │    └── KeyError
      ├── OSError
      │    ├── FileNotFoundError
      │    ├── PermissionError
      │    └── IsADirectoryError
      ├── ValueError
      ├── TypeError
      └── ... (기타 여러 예외들)
```

### 사용자 정의 예외 만들기

```python
# 사용자 정의 예외 계층 구조
class AppError(Exception):
    """애플리케이션 기본 예외"""
    pass

class ConfigurationError(AppError):
    """설정 관련 예외"""
    pass

class DatabaseError(AppError):
    """데이터베이스 관련 예외"""
    pass

class ValidationError(AppError):
    """데이터 검증 예외"""
    def __init__(self, message, field=None, value=None):
        super().__init__(message)
        self.field = field
        self.value = value
    
    def __str__(self):
        base_message = super().__str__()
        if self.field:
            return f"{base_message} (필드: {self.field}, 값: {self.value})"
        return base_message

class UserNotFoundError(DatabaseError):
    """사용자를 찾을 수 없을 때 발생하는 예외"""
    def __init__(self, user_id):
        super().__init__(f"사용자를 찾을 수 없습니다: ID={user_id}")
        self.user_id = user_id

# 사용자 정의 예외 사용 예제
class UserManager:
    """사용자 관리 클래스"""
    
    def __init__(self):
        self.users = {1: "김철수", 2: "이영희"}
    
    def get_user(self, user_id):
        """사용자 정보 조회"""
        if user_id not in self.users:
            raise UserNotFoundError(user_id)
        return self.users[user_id]
    
    def validate_user_data(self, name, age):
        """사용자 데이터 검증"""
        errors = []
        
        if not name or len(name.strip()) < 2:
            errors.append(ValidationError("이름은 2자 이상이어야 합니다", "name", name))
        
        if not isinstance(age, int) or age < 0 or age > 150:
            errors.append(ValidationError("나이는 0에서 150 사이의 정수여야 합니다", "age", age))
        
        if errors:
            # 여러 검증 오류를 한 번에 처리
            raise ValidationError("데이터 검증 실패") from errors[0]
        
        return True

# 사용 예제
manager = UserManager()

try:
    user = manager.get_user(3)  # 존재하지 않는 사용자
except UserNotFoundError as e:
    print(f"사용자 조회 실패: {e}")
    print(f"찾으려는 사용자 ID: {e.user_id}")

try:
    manager.validate_user_data("", 200)  # 잘못된 데이터
except ValidationError as e:
    print(f"검증 실패: {e}")
    if e.field:
        print(f"문제 필드: {e.field}, 값: {e.value}")
```

## 예외 전파와 재발생

### 예외 전파 이해하기

```python
# 예외 전파 예제
def inner_function():
    """내부 함수에서 예외 발생"""
    raise ValueError("내부 함수에서 발생한 오류")

def middle_function():
    """중간 함수"""
    print("중간 함수 시작")
    try:
        inner_function()
    except ValueError as e:
        print(f"중간 함수에서 예외 처리: {e}")
        # 예외를 재발생시킴
        raise RuntimeError("중간 함수에서 재발생한 오류") from e

def outer_function():
    """외부 함수"""
    print("외부 함수 시작")
    try:
        middle_function()
    except RuntimeError as e:
        print(f"외부 함수에서 예외 처리: {e}")
        # 원래 예외 정보 확인
        if e.__cause__:
            print(f"원인 예외: {e.__cause__}")

# 실행
outer_function()

# 실행 결과:
# 외부 함수 시작
# 중간 함수 시작
# 중간 함수에서 예외 처리: 내부 함수에서 발생한 오류
# 외부 함수에서 예외 처리: 중간 함수에서 재발생한 오류
# 원인 예외: 내부 함수에서 발생한 오류
```

### `raise from`의 중요성

```python
# raise from 사용 예제
def read_config_file(config_path):
    """설정 파일 읽기"""
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError as original_error:
        # 원래 예외 정보를 보존하면서 새로운 예외 발생
        raise ConfigurationError(f"설정 파일을 찾을 수 없습니다: {config_path}") from original_error
    except UnicodeDecodeError as original_error:
        raise ConfigurationError(f"설정 파일 인코딩 오류: {config_path}") from original_error

def load_config():
    """설정 로드"""
    try:
        config_text = read_config_file("config.json")
        # 설정 파싱 로직
        return {"parsed": True, "content": config_text}
    except ConfigurationError as e:
        print(f"설정 로드 실패: {e}")
        
        # 원인 예외 정보 확인
        if e.__cause__:
            print(f"  원인: {type(e.__cause__).__name__}: {e.__cause__}")
            print(f"  원인 예외 트레이스백:")
            import traceback
            traceback.print_tb(e.__cause__.__traceback__)
        
        return {"parsed": False, "error": str(e)}

# 사용 예제
result = load_config()
print(f"결과: {result}")
```

## 실전 예외 처리 패턴

### 재시도 패턴 (Retry Pattern)

```python
import time
import random
from functools import wraps

def retry_on_exception(max_attempts=3, delay=1, backoff=2, exceptions=(Exception,)):
    """예외 발생 시 재시도 데코레이터"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            current_delay = delay
            
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    attempts += 1
                    
                    if attempts == max_attempts:
                        print(f"최대 재시도 횟수({max_attempts}) 초과")
                        raise
                    
                    print(f"시도 {attempts}/{max_attempts} 실패: {e}. {current_delay}초 후 재시도...")
                    time.sleep(current_delay)
                    
                    # 지수 백오프 적용
                    current_delay *= backoff
                    
                    # 지터(jitter) 추가로 동시 재시도 충돌 방지
                    current_delay += random.uniform(0, 0.1 * current_delay)
            
            # 여기까지 오면 안 됨
            raise RuntimeError("재시도 로직 오류")
        return wrapper
    return decorator

# 재시도 데코레이터 사용 예제
class UnstableAPI:
    """불안정한 API 시뮬레이션 클래스"""
    
    def __init__(self, success_rate=0.7):
        self.success_rate = success_rate
    
    @retry_on_exception(max_attempts=5, delay=0.5, backoff=1.5, exceptions=(ConnectionError, TimeoutError))
    def call_api(self, endpoint):
        """API 호출 (가상)"""
        if random.random() > self.success_rate:
            if random.random() > 0.5:
                raise ConnectionError("연결 실패")
            else:
                raise TimeoutError("요청 시간 초과")
        
        return f"{endpoint}에서 데이터를 성공적으로 받았습니다"

# 사용 예제
api = UnstableAPI(success_rate=0.3)  # 성공률 30%로 낮게 설정

try:
    result = api.call_api("/users")
    print(f"결과: {result}")
except Exception as e:
    print(f"최종 실패: {e}")
```

### 컨텍스트 관리자와 예외 처리

```python
# 커스텀 컨텍스트 관리자
import os
from contextlib import contextmanager

@contextmanager
def safe_file_operation(filename, mode='r', encoding='utf-8'):
    """안전한 파일 작업 컨텍스트 관리자"""
    file = None
    temp_filename = f"{filename}.tmp"
    
    try:
        if 'w' in mode or 'a' in mode:
            # 쓰기 모드일 경우 임시 파일에 쓰기
            file = open(temp_filename, mode, encoding=encoding)
            yield file
            file.close()
            file = None
            
            # 원본 파일 백업 및 임시 파일로 교체
            if os.path.exists(filename):
                backup_name = f"{filename}.bak"
                if os.path.exists(backup_name):
                    os.remove(backup_name)
                os.rename(filename, backup_name)
            
            os.rename(temp_filename, filename)
            print(f"파일 안전하게 저장됨: {filename}")
            
        else:
            # 읽기 모드일 경우 일반적으로 처리
            file = open(filename, mode, encoding=encoding)
            yield file
            file.close()
            file = None
            
    except Exception as e:
        # 예외 발생 시 정리 작업
        print(f"파일 작업 중 오류 발생: {e}")
        
        # 임시 파일 정리
        if os.path.exists(temp_filename):
            os.remove(temp_filename)
            print(f"임시 파일 삭제됨: {temp_filename}")
        
        raise  # 예외 재발생
    finally:
        # 파일 핸들 정리
        if file and not file.closed:
            file.close()

# 컨텍스트 관리자 사용 예제
def update_config(config_file, new_setting):
    """설정 파일 업데이트"""
    try:
        with safe_file_operation(config_file, 'r+', encoding='utf-8') as f:
            content = f.read()
            # 설정 업데이트 로직
            updated_content = content + f"\n{new_setting}"
            
            # 파일 포인터 처음으로 이동 후 쓰기
            f.seek(0)
            f.write(updated_content)
            f.truncate()
            
        print("설정 업데이트 완료")
    except FileNotFoundError:
        print(f"설정 파일이 없어 새로 생성합니다: {config_file}")
        with safe_file_operation(config_file, 'w', encoding='utf-8') as f:
            f.write(f"{new_setting}")
        print("새 설정 파일 생성 완료")
    except Exception as e:
        print(f"설정 업데이트 실패: {e}")
        return False
    
    return True

# 사용 예제
update_config("app_config.txt", "theme=dark")
```

### 예외 그룹 처리 (Python 3.11+)

```python
# Python 3.11의 ExceptionGroup 예제
def validate_user_inputs(inputs):
    """여러 사용자 입력 검증"""
    errors = []
    
    for i, user_input in enumerate(inputs, 1):
        try:
            if not user_input.strip():
                raise ValueError(f"입력 {i}: 빈 입력")
            if len(user_input) < 3:
                raise ValueError(f"입력 {i}: 너무 짧음 (최소 3자)")
            if not any(c.isalpha() for c in user_input):
                raise ValueError(f"입력 {i}: 문자 포함 필요")
        except ValueError as e:
            errors.append(e)
    
    if errors:
        # Python 3.11+ 에서만 사용 가능
        # raise ExceptionGroup("사용자 입력 검증 실패", errors)
        
        # 3.11 미만 호환 버전
        error_messages = [str(e) for e in errors]
        raise ValueError(f"검증 실패:\n" + "\n".join(error_messages))

# 사용 예제
user_inputs = ["", "ab", "123", "Valid"]

try:
    validate_user_inputs(user_inputs)
    print("모든 입력이 유효합니다")
except ValueError as e:
    print(f"입력 검증 실패:")
    print(e)
```

## 실전 프로젝트 예제: 데이터 처리 파이프라인

```python
import json
import csv
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any

class DataPipelineError(Exception):
    """데이터 파이프라인 기본 예외"""
    pass

class DataValidationError(DataPipelineError):
    """데이터 검증 예외"""
    pass

class DataTransformationError(DataPipelineError):
    """데이터 변환 예외"""
    pass

class DataExportError(DataPipelineError):
    """데이터 내보내기 예외"""
    pass

class DataPipeline:
    """데이터 처리 파이프라인"""
    
    def __init__(self, source_file: str):
        self.source_file = Path(source_file)
        self.data = None
        self.processed_data = None
        self.log_file = Path("pipeline.log")
    
    def _log(self, message: str, level: str = "INFO"):
        """로깅 메서드"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}\n"
        
        try:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(log_entry)
        except Exception as e:
            print(f"로그 기록 실패: {e}")
    
    def load_data(self) -> List[Dict[str, Any]]:
        """데이터 로드"""
        self._log(f"데이터 로드 시작: {self.source_file}")
        
        if not self.source_file.exists():
            error_msg = f"소스 파일을 찾을 수 없음: {self.source_file}"
            self._log(error_msg, "ERROR")
            raise FileNotFoundError(error_msg)
        
        try:
            if self.source_file.suffix == '.json':
                with open(self.source_file, 'r', encoding='utf-8') as f:
                    self.data = json.load(f)
            elif self.source_file.suffix == '.csv':
                with open(self.source_file, 'r', encoding='utf-8', newline='') as f:
                    reader = csv.DictReader(f)
                    self.data = list(reader)
            else:
                error_msg = f"지원하지 않는 파일 형식: {self.source_file.suffix}"
                self._log(error_msg, "ERROR")
                raise ValueError(error_msg)
            
            self._log(f"데이터 로드 완료: {len(self.data)}개 레코드")
            return self.data
            
        except (json.JSONDecodeError, UnicodeDecodeError) as e:
            error_msg = f"파일 파싱 오류: {e}"
            self._log(error_msg, "ERROR")
            raise DataValidationError(error_msg) from e
        except Exception as e:
            error_msg = f"데이터 로드 중 알 수 없는 오류: {e}"
            self._log(error_msg, "ERROR")
            raise DataPipelineError(error_msg) from e
    
    def validate_data(self) -> bool:
        """데이터 검증"""
        self._log("데이터 검증 시작")
        
        if not self.data:
            error_msg = "검증할 데이터가 없습니다"
            self._log(error_msg, "ERROR")
            raise DataValidationError(error_msg)
        
        validation_errors = []
        
        for i, record in enumerate(self.data):
            try:
                # 필수 필드 검증
                if 'id' not in record or not record['id']:
                    raise DataValidationError(f"레코드 {i}: id 필드 누락")
                
                if 'name' not in record or not record['name'].strip():
                    raise DataValidationError(f"레코드 {i}: name 필드 누락 또는 빈 값")
                
                # 데이터 타입 검증
                if not isinstance(record.get('age', 0), (int, type(None))):
                    raise DataValidationError(f"레코드 {i}: age 필드 타입 오류")
                
            except DataValidationError as e:
                validation_errors.append(str(e))
        
        if validation_errors:
            error_msg = f"데이터 검증 실패: {len(validation_errors)}개 오류"
            self._log(error_msg, "ERROR")
            self._log("상세 오류:\n" + "\n".join(validation_errors), "DEBUG")
            raise DataValidationError(f"{error_msg}\n" + "\n".join(validation_errors[:3]))
        
        self._log("데이터 검증 완료")
        return True
    
    def transform_data(self) -> List[Dict[str, Any]]:
        """데이터 변환"""
        self._log("데이터 변환 시작")
        
        try:
            self.processed_data = []
            
            for record in self.data:
                transformed = record.copy()
                
                # 이름 포맷팅
                if 'name' in transformed:
                    transformed['name_formatted'] = transformed['name'].strip().title()
                
                # 나이 그룹 계산
                if 'age' in transformed and transformed['age']:
                    age = transformed['age']
                    if age < 20:
                        transformed['age_group'] = '청소년'
                    elif age < 40:
                        transformed['age_group'] = '청년'
                    elif age < 60:
                        transformed['age_group'] = '중년'
                    else:
                        transformed['age_group'] = '노년'
                
                # 타임스탬프 추가
                transformed['processed_at'] = datetime.now().isoformat()
                
                self.processed_data.append(transformed)
            
            self._log(f"데이터 변환 완료: {len(self.processed_data)}개 레코드")
            return self.processed_data
            
        except Exception as e:
            error_msg = f"데이터 변환 오류: {e}"
            self._log(error_msg, "ERROR")
            raise DataTransformationError(error_msg) from e
    
    def export_data(self, output_format: str = 'json') -> str:
        """데이터 내보내기"""
        self._log(f"데이터 내보내기 시작: 형식={output_format}")
        
        if not self.processed_data:
            error_msg = "내보낼 데이터가 없습니다"
            self._log(error_msg, "ERROR")
            raise DataExportError(error_msg)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = Path(f"output_{timestamp}.{output_format}")
        
        try:
            if output_format == 'json':
                with open(output_file, 'w', encoding='utf-8') as f:
                    json.dump(self.processed_data, f, ensure_ascii=False, indent=2)
            elif output_format == 'csv':
                if not self.processed_data:
                    raise DataExportError("CSV로 내보낼 데이터가 없습니다")
                
                fieldnames = self.processed_data[0].keys()
                with open(output_file, 'w', encoding='utf-8', newline='') as f:
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    writer.writerows(self.processed_data)
            else:
                raise DataExportError(f"지원하지 않는 출력 형식: {output_format}")
            
            self._log(f"데이터 내보내기 완료: {output_file}")
            return str(output_file)
            
        except Exception as e:
            error_msg = f"데이터 내보내기 오류: {e}"
            self._log(error_msg, "ERROR")
            raise DataExportError(error_msg) from e
    
    def run_pipeline(self, output_format: str = 'json') -> str:
        """파이프라인 전체 실행"""
        self._log("=" * 50)
        self._log("데이터 파이프라인 시작")
        
        try:
            # 1. 데이터 로드
            self.load_data()
            
            # 2. 데이터 검증
            self.validate_data()
            
            # 3. 데이터 변환
            self.transform_data()
            
            # 4. 데이터 내보내기
            output_file = self.export_data(output_format)
            
            self._log("데이터 파이프라인 성공적으로 완료")
            self._log("=" * 50)
            
            return output_file
            
        except DataPipelineError as e:
            # 파이프라인 관련 오류 처리
            self._log(f"파이프라인 오류: {e}", "ERROR")
            self._log("=" * 50)
            raise
            
        except Exception as e:
            # 예상치 못한 오류 처리
            self._log(f"예상치 못한 오류: {type(e).__name__}: {e}", "CRITICAL")
            self._log("=" * 50)
            raise DataPipelineError(f"파이프라인 실행 중 알 수 없는 오류: {e}") from e

# 사용 예제
def main():
    """메인 실행 함수"""
    
    # 테스트 데이터 생성
    test_data = [
        {"id": 1, "name": "김철수", "age": 30},
        {"id": 2, "name": "이영희", "age": 25},
        {"id": 3, "name": "박지민", "age": 35}
    ]
    
    # JSON 파일로 저장
    with open("test_data.json", 'w', encoding='utf-8') as f:
        json.dump(test_data, f, ensure_ascii=False, indent=2)
    
    # 파이프라인 실행
    pipeline = DataPipeline("test_data.json")
    
    try:
        output_file = pipeline.run_pipeline(output_format='json')
        print(f"파이프라인 성공! 출력 파일: {output_file}")
        
        # 결과 확인
        with open(output_file, 'r', encoding='utf-8') as f:
            result = json.load(f)
            print(f"\n처리된 데이터 ({len(result)}개):")
            for item in result[:2]:  # 처음 2개만 출력
                print(f"  - {item}")
                
    except DataPipelineError as e:
        print(f"파이프라인 실패: {e}")
        return 1
    except Exception as e:
        print(f"예상치 못한 오류: {e}")
        return 2
    
    return 0

if __name__ == "__main__":
    exit(main())
```

## 결론

예외 처리는 단순히 오류를 숨기는 기술이 아니라, 프로그램의 신뢰성과 견고성을 보장하는 핵심적인 기술입니다. 파이썬의 예외 처리 시스템은 다음과 같은 장점을 제공합니다:

1. **명확한 에러 핸들링**: 각 예외 타입을 구분하여 적절하게 처리할 수 있습니다.
2. **자원 관리**: `finally` 블록과 컨텍스트 관리자를 통해 자원 누수를 방지합니다.
3. **디버깅 용이성**: 상세한 예외 정보와 트레이스백을 통해 문제를 쉽게 진단할 수 있습니다.
4. **코드 가독성**: 정상 흐름과 예외 처리를 명확히 분리하여 코드를 이해하기 쉽게 만듭니다.

실전에서는 다음과 같은 원칙을 따르는 것이 좋습니다:
- **구체적인 예외 처리**: 가능한 한 구체적인 예외 타입을 처리하세요.
- **적절한 예외 전파**: 예외를 숨기지 말고, 필요한 경우 적절한 수준에서 처리하세요.
- **사용자 정의 예외**: 도메인에 맞는 의미 있는 예외를 정의하세요.
- **로깅**: 모든 예외를 적절히 로깅하여 추후 분석에 활용하세요.
- **자원 정리**: `finally` 블록이나 컨텍스트 관리자를 사용하여 자원을 확실히 정리하세요.

예외 처리를 잘 설계하고 구현하면, 프로그램은 예기치 않은 상황에서도 우아하게 실패하고, 문제를 쉽게 진단하며, 사용자에게 의미 있는 피드백을 제공할 수 있습니다. 이는 전문적인 소프트웨어 개발에서 필수적인 요소입니다.