---
layout: post
title: 파이썬 - 예외처리
date: 2024-08-17 19:20:23 +0900
category: Python
---
# 파이썬 예외 처리

## 0. 예외 처리의 철학: EAFP vs LBYL

- **EAFP (Easier to Ask Forgiveness than Permission)**: “허락보다 용서가 쉽다.”  
  → 미리 검사하기보다 시도하고 실패를 **예외로 처리**하는 파이썬식 스타일.
- **LBYL (Look Before You Leap)**: “뛰기 전에 살펴봐라.”  
  → 사전 조건을 체크하고 실행.

실무에서는 **경합 조건(race condition)** 가능성이 있는 자원(파일/소켓/레코드 잠금 등)에서 EAFP가 더 안전합니다.

```python
# EAFP: 권장
try:
    with open("data.txt", "x", encoding="utf-8") as f:  # 존재하면 예외
        f.write("init")
except FileExistsError:
    pass  # 이미 있으면 무시하고 진행

# LBYL: 존재 검사 후 생성 (경합에 취약)
import os
if not os.path.exists("data.txt"):
    with open("data.txt", "w", encoding="utf-8") as f:
        f.write("init")
```

---

## 1. 예외란?

- **예외(Exception)**: 실행 중 발생한 비정상 상황을 객체로 표현. 잡지 않으면 호출 스택을 타고 **전파**되어 프로그램이 중단.
- 대표 예: `ZeroDivisionError`, `FileNotFoundError`, `IndexError`, `KeyError`, `ValueError` 등.

```python
print(1 / 0)  # ZeroDivisionError
```

---

## 2. 기본 `try/except` 구조와 변형

### 2.1 가장 단순한 형태
```python
try:
    risky()
except ValueError:
    recover()
```

### 2.2 다중 except
```python
try:
    x = int(input("정수: "))
    print(10 // x)
except (ValueError, TypeError) as e:
    print("숫자만 입력하세요:", e)
except ZeroDivisionError:
    print("0으로 나눌 수 없습니다.")
```

### 2.3 전체(광범위) 포착 — **필요할 때만**
```python
try:
    do()
except Exception as e:
    # 로깅 후 재전파가 안전 (무조건 삼키지 말 것)
    import logging
    logging.exception("예상치 못한 예외")
    raise
```
- `except Exception`은 **업무 로직 오류** 포착용.  
- **절대** `BaseException`을 넓게 잡지 말 것 (`KeyboardInterrupt`, `SystemExit`까지 잡혀 종료가 안 됨).

---

## 3. `else`, `finally` — 성공/정리 훅

- `else`: 예외 **없을 때만** 실행 (성공 경로 처리).
- `finally`: 예외 여부 **무관** 정리(자원 반납, 잠금 해제, 임시파일 삭제).

```python
try:
    f = open("data.txt", "r", encoding="utf-8")
    content = f.read()
except FileNotFoundError:
    print("파일이 없습니다.")
else:
    print(content)  # 성공했을 때만
finally:
    if 'f' in locals():
        f.close()   # 항상 실행
```

### 3.1 with-context 선호
파일/락/연결 등은 **컨텍스트 매니저**(`with`)가 더 안전·간결.
```python
from contextlib import suppress

with suppress(FileNotFoundError):
    with open("data.txt", encoding="utf-8") as f:
        print(f.read())
```

---

## 4. 예외 정보 활용과 트레이스백

```python
try:
    1 / 0
except ZeroDivisionError as e:
    print("메시지:", e.__class__.__name__, "-", e)
```

### 4.1 트레이스백 문자열 얻기
```python
import traceback

try:
    fail()
except Exception:
    tb = traceback.format_exc()
    print(tb)  # 로깅/알림에 사용
```

---

## 5. 예외 전파·재발생·연결 (Exception Chaining)

### 5.1 재발생(re-raise)
```python
try:
    do_low_level()
except KeyError:
    # 일부 정리 후 동일 예외 전파
    raise
```

### 5.2 메시지 감싸기 + 체이닝 유지 (`raise from`)
```python
def load_config(path):
    try:
        with open(path, encoding="utf-8") as f:
            return parse(f.read())
    except FileNotFoundError as exc:
        raise RuntimeError(f"설정 파일 누락: {path}") from exc   # __cause__ 보존
```

- `raise ... from exc` 는 원인 예외를 **명시적으로 체이닝**(`__cause__`)하여 디버깅 친화적.
- 의도적으로 체인 숨기기: `raise NewError(...) from None`

---

## 6. 사용자 정의 예외 — **의미 있는 계층** 만들기

### 6.1 기본형
```python
class AppError(Exception):
    """애플리케이션 최상위 예외(포착 지점에서 이 한가지만 잡아도 됨)."""

class ConfigError(AppError): ...
class DatabaseError(AppError): ...
class ExternalAPIError(AppError): ...
```

### 6.2 데이터 포함 예외
```python
class HTTPError(AppError):
    def __init__(self, status, url, body=None):
        super().__init__(f"HTTP {status} for {url}")
        self.status = status
        self.url = url
        self.body = body
```

### 6.3 사용 예
```python
def fetch_user(api, uid):
    resp = api.get(f"/users/{uid}")
    if resp.status != 200:
        raise HTTPError(resp.status, resp.url, resp.text)
    return resp.json()
```

> **포착 레이어**(경계/엔드포인트)에서 `AppError`만 잡아 통일 처리 → 메시지/코드/알림 라우팅.

---

## 7. 자원/트랜잭션과 예외 — 누수 없이!

### 7.1 컨텍스트 매니저
```python
from contextlib import ExitStack

def copy_many(paths, dest_dir):
    with ExitStack() as stack:
        files = [stack.enter_context(open(p, "rb")) for p in paths]
        out = stack.enter_context(open(dest_dir / "bundle.bin", "wb"))
        for f in files:
            out.write(f.read())
```

### 7.2 DB 트랜잭션
```python
conn = get_connection()
try:
    with conn:
        with conn.cursor() as cur:
            cur.execute("INSERT ...")
            cur.execute("UPDATE ...")
    # with conn: 블록 성공 시 자동 commit, 예외 시 rollback
except Exception:
    log_exception()
    raise
```

---

## 8. 재시도/백오프 패턴 (네트워크/외부 의존)

**지수 백오프**(exponential backoff)는 간단히  
$$
\text{sleep}_k = \min(B_{\max}, B_0 \cdot 2^k) \quad (k=0,1,2,\dots)
$$
형태로 늘려갑니다. (필요 시 **Jitter** 추가)

```python
import time, random

def retry(op, *, retries=5, base=0.2, cap=5.0, jitter=True):
    for k in range(retries):
        try:
            return op()
        except Exception as e:
            if k == retries - 1:
                raise
            backoff = min(cap, base * (2 ** k))
            if jitter:
                backoff *= (0.5 + random.random() / 2)  # 0.5~1.0 배
            time.sleep(backoff)

# 사용
data = retry(lambda: http_get_json(url))
```

- **재시도 대상**을 선별하라: 5xx/네트워크 오류만, 4xx는 즉시 실패 등.
- 백오프 중 `KeyboardInterrupt`는 **즉시 전파**되도록 `except Exception` 범위 유지.

---

## 9. `asyncio` 환경의 예외와 취소

### 9.1 태스크 취소
```python
import asyncio

async def worker():
    try:
        await asyncio.sleep(10)
    except asyncio.CancelledError:
        print("작업이 취소되었습니다.")  # 정리 작업
        raise

async def main():
    task = asyncio.create_task(worker())
    await asyncio.sleep(0.1)
    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        print("main: 취소 확인")

asyncio.run(main())
```

- **`CancelledError`는 예외가 아니라 “취소 신호”**에 가깝지만, `Exception`의 서브클래스였던 과거와 달리 최신 버전에선 `BaseException` 계열로 분류될 수 있음(런타임 버전에 주의).  
- 작업 정리가 필요하면 `CancelledError`를 **잡고** 정리 후 **다시 raise**.

### 9.2 `gather`의 예외 처리
```python
async def main():
    tasks = [fetch(u) for u in urls]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    for r in results:
        if isinstance(r, Exception):
            log_exception(r)
        else:
            use(r)
```

---

## 10. 표준 예외들 — 자주 쓰는 것만 압축 표

| 카테고리 | 예외 | 트리거 |
|---|---|---|
| 산술 | `ZeroDivisionError`, `OverflowError` | 0 나누기, 큰 정수 변환 등 |
| 조회 | `IndexError`, `KeyError` | 시퀀스/딕셔너리 키 없음 |
| 변환/타입 | `ValueError`, `TypeError` | 파싱 실패, 잘못된 인자 타입 |
| 파일/IO | `FileNotFoundError`, `PermissionError`, `IsADirectoryError`, `EOFError` | 파일 접근/권한/형태 |
| OS | `OSError` (부모), `TimeoutError` | 시스템 콜/네트워크/락 |
| 임포트 | `ImportError`, `ModuleNotFoundError` | 모듈/심볼 없음 |
| 어설션 | `AssertionError` | `assert` 실패 |
| 인터럽트 | `KeyboardInterrupt` | Ctrl+C |
| 종료 | `SystemExit` | `sys.exit()` 호출 |

> 세밀한 분류가 필요 없다면 **상위 예외**로 잡는 것이 유지보수에 유리 (`OSError`, `LookupError`, `ArithmeticError` 등).

---

## 11. 안티 패턴과 개선

### 11.1 “빈 except”는 금지
```python
# 나쁨
try:
    do()
except:
    pass
```
- 디버깅 악몽. `KeyboardInterrupt`까지 먹어 치움.

### 11.2 메시지 없이 삼키기 금지
```python
# 나쁨
try: do()
except Exception: pass
```
- 최소한 **로그**를 남기고, 필요 시 **재전파**.
```python
import logging
try:
    do()
except Exception:
    logging.exception("실패")
    raise
```

### 11.3 `assert`는 입력 검증 용도 아님
- 최적화(`-O`)로 **제거** 가능. 런타임 입력 검증은 **명시 if + 예외**.

```python
def sqrt(x):
    if x < 0:
        raise ValueError("x must be non-negative")
    ...
```

---

## 12. 테스트/품질과 예외

### 12.1 `pytest`로 예외 검증
```python
import pytest

def div(a, b):
    return a / b

def test_div_by_zero():
    with pytest.raises(ZeroDivisionError):
        div(1, 0)
```

### 12.2 “발생했는지” + “메시지”까지 검증
```python
with pytest.raises(ValueError, match="must be non-negative"):
    sqrt(-1)
```

---

## 13. 로깅/관측성(Observability)

- 예외는 **로깅**과 **상태코드/응답**으로 연결되어야 운영에 유용.
- 웹 프레임워크(예: FastAPI, Django)에서는 전역 예외 핸들러로 **예외 → 표준화된 응답(JSON 코드/메시지)** 매핑.

```python
import logging
log = logging.getLogger(__name__)

try:
    do()
except AppError as e:
    log.warning("업무 오류: %s", e)     # 4xx 가능
    raise
except Exception:
    log.exception("시스템 오류")       # 5xx
    raise
```

---

## 14. 패턴 도감: 실전 스니펫 모음

### 14.1 “존재하면 쓰고 없으면 생성”
```python
from contextlib import suppress
from pathlib import Path

p = Path("cache/result.json")
if p.exists():
    data = p.read_text(encoding="utf-8")
else:
    data = compute()
    with suppress(FileExistsError):
        p.parent.mkdir(parents=True)
    p.write_text(data, encoding="utf-8")
```

### 14.2 “최대 N회 재시도 + 특정 예외만”
```python
def retry_on(ex_types, func, *, tries=3):
    for i in range(tries):
        try:
            return func()
        except ex_types:
            if i == tries - 1: raise
```

### 14.3 “예외 → 도메인 에러로 번역”
```python
class PriceServiceError(AppError): ...
def get_price(api, id):
    try:
        return api.get_price(id)
    except TimeoutError as e:
        raise PriceServiceError("가격 서비스 지연") from e
```

### 14.4 “정리 무조건 보장”
```python
lock.acquire()
try:
    critical()
finally:
    lock.release()
```

---

## 15. 고급: 예외 객체의 메타 속성

- `__cause__`: `raise ... from ...`로 연결된 **원인 예외**
- `__context__`: 예외 처리 중 또 다른 예외가 발생했을 때 자동 연결
- `__suppress_context__`: `True`면 기본 컨텍스트 숨김 (`from None`와 유사)

```python
try:
    1/0
except ZeroDivisionError as e:
    raise RuntimeError("연산 실패") from e
```

---

## 16. 종합 예제: 파일 → 파싱 → 업로드 파이프라인

- 단계별로 **구체 예외 → 도메인 예외 번역**  
- 경계(엔드포인트)에서 **최상위 예외(AppError)** 만 포착

```python
import json, time, random
from pathlib import Path

class AppError(Exception): ...
class ReadError(AppError): ...
class ParseError(AppError): ...
class UploadError(AppError): ...

def read_file(path: Path) -> str:
    try:
        return path.read_text(encoding="utf-8")
    except FileNotFoundError as e:
        raise ReadError(f"파일 없음: {path}") from e
    except OSError as e:
        raise ReadError(f"파일 읽기 실패: {path}") from e

def parse_json(text: str) -> dict:
    try:
        return json.loads(text)
    except json.JSONDecodeError as e:
        raise ParseError("JSON 파싱 실패") from e

def upload_payload(obj: dict):
    # 외부 서비스로 업로드(가상)
    if random.random() < 0.3:
        # 간헐적 실패
        raise TimeoutError("업스트림 타임아웃")

def pipeline(path: Path):
    data = parse_json(read_file(path))
    # 재시도 백오프
    for k in range(5):
        try:
            upload_payload(data)
            return "OK"
        except TimeoutError as e:
            if k == 4:
                raise UploadError("업로드 반복 실패") from e
            time.sleep(min(5.0, 0.2 * (2 ** k)))

def main(path: str):
    try:
        print(pipeline(Path(path)))
    except AppError as e:
        # 모든 도메인 에러 집계 포인트 (로깅/알림/메트릭)
        import logging; logging.exception("파이프라인 실패: %s", e)
        return 1
    return 0

if __name__ == "__main__":
    raise SystemExit(main("payload.json"))
```

---

## 17. 체크리스트 (배포 전 자가 점검)

- [ ] `except:` **절대 금지**, 범위 명시 (`except Exception as e:`)
- [ ] 로깅 시 **`logging.exception`** 사용 (스택 포함)
- [ ] 자원은 **`with`/`finally`** 로 정리 보장
- [ ] 외부 의존(네트워크/DB)은 **재시도&백오프** + **타임아웃**
- [ ] `raise from` 로 예외 원인 연결 유지
- [ ] 앱 경계에서 **최상위 도메인 예외**로 통일 처리
- [ ] 테스트: `pytest.raises` 로 실패 경로 커버
- [ ] `asyncio` 작업은 **취소 처리(`CancelledError`)** 구현

---

## 부록 A) 자주 쓰는 컨텍스트 유틸

```python
from contextlib import suppress, ExitStack

with suppress(FileExistsError):
    Path("out").mkdir()

with ExitStack() as stack:
    f1 = stack.enter_context(open("a.txt", "rb"))
    f2 = stack.enter_context(open("b.txt", "rb"))
    out = stack.enter_context(open("c.txt", "wb"))
    out.write(f1.read() + f2.read())
```

---

## 부록 B) 학습 과제

1. **API 호출 래퍼**를 만들고, 5xx/네트워크 오류만 재시도 + `raise from`으로 체인 보존.
2. **파일 파서**에서 `UnicodeDecodeError`를 `ParseError`로 번역하고, 실패 입력을 `bad/` 디렉터리에 자동 보관.
3. `asyncio.gather`로 10개 요청 동시 처리, 실패는 수집하여 JSON 리포트 생성.

---

## 맺음말

예외 처리는 “에러를 숨기는 기술”이 아니라 **“프로그램을 신뢰 가능하게 만드는 계약”**입니다.  
의미 있는 예외 계층, 깔끔한 정리, 원인 체인 유지, 재시도/타임아웃, 로깅·관측성까지 갖추면 **운영 가능한 코드**가 됩니다.