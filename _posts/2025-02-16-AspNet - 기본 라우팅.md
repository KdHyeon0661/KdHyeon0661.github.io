---
layout: post
title: AspNet - 기본 라우팅
date: 2025-02-16 20:20:23 +0900
category: AspNet
---
# ASP.NET Core 기본 라우팅 이해: Razor Pages와 MVC 비교

## 라우팅이란?

**라우팅(Routing)**은 요청 URL을 분석해 **핸들러**(Razor Page, MVC Controller/Action, Minimal API, Static File)에 연결하는 과정입니다.

요청 예시:
```
GET /Products/Details/3 → ProductsController.Details(3)
GET /Contact             → Pages/Contact.cshtml
```

ASP.NET Core는 **엔드포인트 라우팅(Endpoint Routing)**을 사용합니다. 파이프라인에서 `UseRouting`이 경로 매칭을 수행하고, `UseEndpoints`/`Map*` 계열이 실제 엔드포인트(페이지/액션/핸들러)를 등록합니다.

---

## Razor Pages의 기본 라우팅 — 파일/폴더 매핑

### 디렉터리-URL 매핑

```
Pages/
├── Index.cshtml         → GET /
├── About.cshtml         → GET /About
├── Products/
│   ├── List.cshtml      → GET /Products/List
│   └── Details.cshtml   → GET /Products/Details
```

- `Index.cshtml`은 루트 `/`에 매핑됩니다.
- **하위 폴더 구조**가 URL 경로로 반영됩니다.

### @page 라우트 템플릿과 파라미터

`Pages/Product.cshtml`
```cshtml
@page "{id:int}"
@model ProductModel
<h2>Product ID: @Model.Id</h2>
```

`Pages/Product.cshtml.cs`
```csharp
public class ProductModel : PageModel
{
    public int Id { get; private set; }
    public void OnGet(int id) => Id = id;
}
```

- `/Product/3` → `id = 3` 바인딩
- 자주 쓰는 **제약(Constraints)**:
  - `int`, `long`, `guid`, `bool`
  - 길이/범위: `min(1)`, `max(100)`, `length(3,10)`
  - 패턴: `regex(^[a-z0-9-]+$)`
  - 알파벳/소문자: `alpha`

예:
```cshtml
@page "{slug:regex(^[a-z0-9-]+$)}"
```

### 여러 라우트를 하나의 페이지에 매핑

```cshtml
@page "/Notice"
@page "/공지사항"
@model NoticeModel
<h1>공지</h1>
```

- `/Notice`와 `/공지사항` 모두 동일 페이지 처리

---

## MVC의 기본 라우팅 — 컨벤션 및 속성 라우팅

### 기본 컨벤션 라우팅

`Program.cs`
```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

- `/` → `HomeController.Index()`
- `/Products/Details/5` → `ProductsController.Details(5)`

### 속성 라우팅(Attribute Routing)

```csharp
[Route("blog")]
public class BlogController : Controller
{
    [HttpGet("{year:int}/{month:int}/{slug}")]
    public IActionResult Post(int year, int month, string slug) => View();
}
```

- `/blog/2024/12/hello-world` 매칭
- 클래스/액션에 중첩 라우팅 가능, **복잡한 URL 설계**에 유리

---

## Razor Pages vs MVC 라우팅 비교

| 항목            | Razor Pages                               | MVC(컨트롤러/액션)                          |
|-----------------|-------------------------------------------|---------------------------------------------|
| 라우팅 기준     | **파일·폴더 구조** + `@page` 템플릿       | **컨벤션 라우팅** + **속성 라우팅**         |
| 선언 위치       | 각 `.cshtml` 파일 상단                     | `Program.cs`(MapControllerRoute) / 특성     |
| 학습·생산성     | CRUD/백오피스에 직관적                    | 복잡한 도메인/버전/언어/SEO 유연성 우수     |
| 링크 생성       | `asp-page`, `Url.Page`                    | `asp-action/controller`, `Url.Action`       |
| 영역 지원       | `Areas/…/Pages`                           | `Areas/…/Controllers`                       |

**실무 팁**: 단일 솔루션에서 **Razor Pages(백오피스/SSR UI)** + **MVC(공개 웹/SEO/블로그)**를 **혼합**해도 무방합니다.

---

## 엔드포인트 라우팅 파이프라인과 미들웨어 순서

`Program.cs`
```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorPages();
builder.Services.AddControllersWithViews();

var app = builder.Build();

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();            // 1) 라우팅 테이블 준비
app.UseAuthentication();     // 2) 사용자 식별
app.UseAuthorization();      // 3) 권한 확인

app.MapRazorPages();         // 4) Razor Pages 엔드포인트 등록
app.MapControllers();        // 5) MVC 엔드포인트 등록
app.Run();
```

- `UseRouting` 이전에 인증/권한을 배치하면 **라우팅 컨텍스트**가 없어서 정책이 적용되지 않음.
- **정적 파일**은 보통 라우팅 이전에 처리.

---

## 링크 생성: Tag Helper와 Url/LinkGenerator

### Razor Pages

뷰에서:
```cshtml
<a asp-page="/Products/Details" asp-route-id="42">자세히</a>
```

PageModel/서비스에서:
```csharp
var url = Url.Page("/Products/Details", values: new { id = 42 });
// 또는 DI 받은 LinkGenerator 사용
var generated = _link.GetPathByPage(HttpContext, "/Products/Details", new { id = 42 });
```

### MVC

뷰에서:
```cshtml
<a asp-controller="Products" asp-action="Details" asp-route-id="42">자세히</a>
```

컨트롤러/서비스에서:
```csharp
var url = Url.Action("Details", "Products", new { id = 42 });
var path = _link.GetPathByAction(HttpContext, "Details", "Products", new { id = 42 });
```

**주의**: 하드코딩된 URL 대신 **라우트 기반 링크 생성**을 사용하면 **리팩터링 안전성**이 높아집니다.

---

## 라우트 템플릿: 기본값·옵션·캐치올

### 기본값/옵션 구간

MVC 컨벤션:
```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```
- `{id?}`는 선택적
- `{controller=Home}`는 기본값

Razor Pages 커스텀(Conventions, 9장 참조) 또는 `@page "/Path/{id?}"`로도 옵션화 가능

### 캐치올(catch-all)

```csharp
app.MapControllerRoute(
    name: "docs",
    pattern: "docs/{*path}"); // path에 / 포함 전체 캡처
```

SPA/문서 뷰어 등에서 유용

---

## 심화

### 내장 제약 예시

```csharp
app.MapControllerRoute(
    name: "byDate",
    pattern: "archive/{year:int:min(2000):max(2030)}/{month:int:range(1,12)}",
    defaults: new { controller = "Archive", action = "ByDate" });
```

Razor Pages 템플릿에서도 동일 문법:
```cshtml
@page "{year:int:min(2000):max(2030)}/{month:int:range(1,12)}"
```

### 정규식 제약

```csharp
[HttpGet("u/{name:regex(^[a-z][a-z0-9_-]{2,15}$)}")]
public IActionResult Profile(string name) => View();
```

### 커스텀 제약

컨벤션 라우팅에서 `IRouteConstraint`(또는 엔드포인트 정책)을 등록해 사용할 수 있습니다(고급 주제, 필요 시 별도 구현).

---

## Razor Pages 전용 Conventions — 글로벌 라우팅/권한/경로 재매핑

`Program.cs`
```csharp
builder.Services.AddRazorPages(options =>
{
    // 특정 페이지에 추가 라우트(별칭) 부여
    options.Conventions.AddPageRoute("/Products/Details", "p/{id:int}");

    // 폴더/페이지별 권한
    options.Conventions.AuthorizeFolder("/Admin", "AdminPolicy");
    options.Conventions.AllowAnonymousToPage("/Account/Login");

    // 영역(Area) 페이지에 대한 규칙도 가능
});
```

- **AddPageRoute**: 파일 기반 라우팅에 **별칭 URL**을 추가해 SEO/마이그레이션에 유용
- **AuthorizeFolder/Page**: 라우팅 레벨에서 권한 정책 결합

---

## MVC 영역(Areas)와 Razor Pages 영역

프로젝트 구조:
```
Areas/
└── Admin/
    ├── Controllers/…        // MVC
    └── Pages/…              // Razor Pages
```

### Razor Pages Area 라우팅

`Areas/Admin/Pages/Users/Index.cshtml`
```cshtml
@page
@model Admin.Pages.Users.IndexModel
<h1>Users</h1>
```

`Program.cs`
```csharp
app.MapAreaControllerRoute(
    name: "admin",
    areaName: "Admin",
    pattern: "Admin/{controller=Home}/{action=Index}/{id?}");

app.MapRazorPages(); // Area Pages는 자동으로 매핑됨
```

URL:
```
/Admin/Users        (Razor Pages Area)
/Admin/Home/Index   (MVC Area Controller)
```

---

## 속성 라우팅 고급: 이름·버전·제약 결합

```csharp
[Route("api/v{version:apiVersion}/orders")]
[ApiVersion("1.0")]
public class OrdersController : ControllerBase
{
    [HttpGet("{id:int}", Name = "GetOrder")]
    public IActionResult Get(int id) => Ok(new { id });

    [HttpPost]
    public IActionResult Create([FromBody] OrderDto dto)
        => CreatedAtRoute("GetOrder", new { version = "1.0", id = 123 }, dto);
}
```

- **경로 이름(Name)**을 부여해 `CreatedAtRoute`/링크 생성 시 안정적 참조
- **버전/제약**과 조합해 공용 API URL 스키마를 엄격히 관리

---

## 라우팅 패턴

### URL에 문화권 코드 포함

컨트롤러:
```csharp
[Route("{culture:regex(^[a-z]{2}-[A-Z]{2}$)}/products")]
public class ProductsController : Controller
{
    [HttpGet("{id:int}")]
    public IActionResult Details(string culture, int id) => View();
}
```

요청:
```
/ko-KR/products/10
/en-US/products/10
```

### RequestLocalization과 연동

`Program.cs`에서 `RequestLocalizationOptions` 설정 후, 미들웨어로 문화권을 결정합니다. 라우트 파라미터의 `culture` 값을 미들웨어에서 읽어 `CurrentCulture`에 반영하는 커스텀 파이프라인을 구성할 수 있습니다(필요 시 별도 미들웨어/필터 구현).

---

## — 슬러기파이

**컨벤션 라우팅**에서 파라미터 변환기로 URL 미관/SEO를 개선합니다. 예를 들어 **PascalCase 액션을 kebab-case**로 변환:

```csharp
public class SlugifyParameterTransformer : IOutboundParameterTransformer
{
    public string? TransformOutbound(object? value)
        => value is null ? null
           : Regex.Replace(value.ToString()!, "([a-z])([A-Z])", "$1-$2").ToLowerInvariant();
}

builder.Services.AddRouting(o =>
{
    o.ConstraintMap["slugify"] = typeof(SlugifyParameterTransformer);
});

// 사용 예(라우트 토큰 변환기)
app.MapControllerRoute(
    name: "default",
    pattern: "{controller:slugify}/{action:slugify}/{id?}");
```

- `/ProductCatalog/ShowDetails` → `/product-catalog/show-details`

---

## 라우팅과 SPA

### SPA 정적 파일로 폴백

```csharp
app.MapFallbackToFile("index.html"); // React/Vue/SPA 라우팅
```

- 서버에 등록된 엔드포인트가 없으면 `index.html` 반환
- API/페이지 경로와 충돌하지 않도록 **우선순위**에 유의

### 커스텀 폴백

```csharp
app.MapFallback(context =>
{
    context.Response.StatusCode = StatusCodes.Status404NotFound;
    return context.Response.WriteAsync("Not Found");
});
```

---

## 우선순위·충돌·디버깅

### Razor Pages

- **파일 경로 매칭**이 우선
- 동일 경로에 `@page "/same"`를 **여러 페이지**에 선언하면 충돌

### MVC

- `MapControllerRoute`는 **등록 순서**가 우선순위를 결정
- 보다 **특정한 패턴 → 일반 패턴** 순으로 등록
- **속성 라우팅**은 해당 컨트롤러/액션의 템플릿이 우선

### 디버깅 팁

- 개발 환경에서 **`app.UseDeveloperExceptionPage()`**
- **`RouteDebugger`** 유틸(간단한 미들웨어) 또는 **미들웨어 로깅**으로 `Endpoint.DisplayName` 출력
- `HttpContext.GetEndpoint()`로 매칭된 엔드포인트 확인

```csharp
app.Use(async (ctx, next) =>
{
    await next();
    var ep = ctx.GetEndpoint();
    if (ep != null)
    {
        Console.WriteLine($"Matched: {ep.DisplayName}");
    }
});
```

---

## 상태 코드 페이지 / 커스텀 404

```csharp
app.UseStatusCodePagesWithReExecute("/Error/{0}");
```

`Pages/Error/{code}.cshtml`
```cshtml
@page "{code:int}"
@model ErrorCodeModel
<h1>오류 @Model.Code</h1>
```

`ErrorCodeModel.cs`
```csharp
public class ErrorCodeModel : PageModel
{
    public int Code { get; private set; }
    public void OnGet(int code) => Code = code;
}
```

- 404/403 등 상황별 **사용자 친화적** 페이지 제공

---

## Razor Pages·MVC·Minimal API 혼용

`Program.cs`
```csharp
app.MapRazorPages();
app.MapControllers();

app.MapGet("/api/ping", () => Results.Ok(new { ok = true })); // Minimal API
```

- 한 애플리케이션에서 **세 접근 방식**을 함께 사용할 수 있음
- 라우트 충돌을 피하려면 **경로 네임스페이스**(`/api`, `/admin`)를 일관되게 설계

---

## 보안·권한과 라우팅

- **[Authorize]**/**[AllowAnonymous]**를 PageModel/Controller/Action에 적용
- Razor Pages 전역 규칙:
```csharp
builder.Services.AddRazorPages(options =>
{
    options.Conventions.AuthorizeFolder("/Admin", "AdminPolicy");
    options.Conventions.AllowAnonymousToPage("/Account/Login");
});
```

- 라우팅으로 **접근 경로**를 설계하고, 권한으로 **접근 권한**을 모델링

---

## 실전 예제 모음

### Razor Pages — SEO 별칭과 다국어, 슬러그 매핑

`Program.cs`
```csharp
builder.Services.AddRazorPages(options =>
{
    options.Conventions.AddPageRoute("/Products/Details", "p/{id:int}");
    options.Conventions.AddPageRoute("/Blog/Post", "{culture:regex(^[a-z]{2}-[A-Z]{2}$)}/blog/{slug}");
});
```

`Pages/Blog/Post.cshtml`
```cshtml
@page "{culture:regex(^[a-z]{2}-[A-Z]{2}$)}/blog/{slug:regex(^[a-z0-9-]+$)}"
@model BlogPostModel
<h1>@Model.Slug (@Model.Culture)</h1>
```

`Pages/Blog/Post.cshtml.cs`
```csharp
public class BlogPostModel : PageModel
{
    public string Culture { get; private set; } = "ko-KR";
    public string Slug { get; private set; } = "";

    public void OnGet(string culture, string slug)
    {
        Culture = culture;
        Slug = slug;
        // RequestLocalization과 연동하여 Culture 적용 가능
    }
}
```

### MVC — 날짜 아카이브와 캐치올 문서

`Program.cs`
```csharp
app.MapControllerRoute(
    "archive",
    "archive/{year:int:min(2000):max(2050)}/{month:int:range(1,12)}",
    new { controller = "Archive", action = "ByDate" });

app.MapControllerRoute(
    "docs",
    "docs/{*path}",
    new { controller = "Docs", action = "Show" });
```

`ArchiveController.cs`
```csharp
public class ArchiveController : Controller
{
    public IActionResult ByDate(int year, int month) => View();
}
```

`DocsController.cs`
```csharp
public class DocsController : Controller
{
    public IActionResult Show(string path) => View(model: path);
}
```

### 링크 생성의 일관성

뷰(공용 레이아웃):
```cshtml
<a asp-page="/Products/Details" asp-route-id="10">제품 #10</a>
<a asp-controller="Archive" asp-action="ByDate" asp-route-year="2024" asp-route-month="12">12월 글</a>
```

---

## 라우팅 설계 체크리스트

1) **명확한 네임스페이스**: `/api`, `/admin`, `/account` 등 영역별 prefix
2) **SEO/유저 친화 URL**: 소문자, `-` 구분자, 안정적 슬러그
3) ** 링크 생성 기반**: `asp-page`, `asp-action/controller`, `Url.Page/Action`, `LinkGenerator`
4) **제약 적극 활용**: 잘못된 요청은 라우트 레벨에서 방어
5) **폴백과 404**: SPA/문서/짧은 링크에 폴백, 사용자 친화 404
6) **권한 정책과 결합**: 라우트 구조와 권한 정책을 함께 설계
7) **로깅/디버깅**: 매칭된 `Endpoint.DisplayName` 기록, 충돌 조기 발견
8) **국제화**: 문화권 코드 경로 전략 또는 헤더/쿠키 기반 정책 명확화
9) **버전/이관**: AddPageRoute/Route 이름으로 마이그레이션 안전성 확보
10) **테스트**: 통합 테스트로 경로→핸들러 매핑과 상태 코드 검증

---

## 요약 표(확장)

| 주제                   | 핵심 요점 |
|------------------------|-----------|
| Razor Pages 기본       | 파일·폴더 → URL, `@page` 템플릿으로 파라미터/제약 |
| MVC 기본               | 컨벤션 라우팅 + 속성 라우팅, 복잡 URL에 유리 |
| 우선순위               | Razor Pages: 파일 매칭 우선 / MVC: 등록 순서 중요 |
| 링크 생성              | `asp-*` Tag Helper, `Url.Page/Action`, `LinkGenerator` |
| 제약/옵션/캐치올       | `int/guid/regex`, `{id?}`, `{*path}` |
| Conventions            | `AddPageRoute`, `AuthorizeFolder`, Area 지원 |
| 폴백(SPA)              | `MapFallbackToFile("index.html")` |
| 지역화 라우팅          | `{culture}` 세그먼트 + RequestLocalization |
| 파라미터 변환          | Slugify 등 변환기로 kebab-case 노출 |
| 디버깅                 | `GetEndpoint()`, 라우트 로깅, 404/405 커스텀 |

---

# 결론

- **Razor Pages**는 **파일 중심 라우팅**으로 CRUD/백오피스 생산성이 매우 높고, `@page`·Conventions로 정밀 제어가 가능합니다.
- **MVC**는 **컨벤션 + 속성 라우팅**으로 복잡한 공개 웹/SEO/API에 유연하며, 영역/버전/제약을 조합해 확장 가능합니다.
- 엔드포인트 라우팅 아래에서 **우선순위/폴백/권한/지역화/링크 생성**을 일관되게 설계하면, 단일 앱에서 Pages·MVC·Minimal API를 **안전하게 혼용**할 수 있습니다.
- 본 글의 예제/체크리스트를 프로젝트 템플릿에 반영해 **경로 안정성**과 **개발 속도**를 동시에 확보하십시오.
