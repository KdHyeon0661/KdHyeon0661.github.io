---
layout: post
title: DB 심화 - 조건절 이행
date: 2025-11-18 15:25:23 +0900
category: DB 심화
---
# 조건절 이행(Predicate Transitivity)

> **요약**
> - **조건절 이행**은 `A=B`와 `A`에 대한 조건으로부터 **B에 대한 동치(또는 범위) 조건을 유도**해 **더 하단(테이블/파티션/인덱스)까지 필터를 밀어 넣는** 쿼리 변환입니다.
> - 대표적으로 `c.cust_id = s.cust_id AND c.cust_id BETWEEN :lo AND :hi` ⇒ **`s.cust_id BETWEEN :lo AND :hi`** 를 도출합니다.
> - 효과: **I/O 감소**, **파티션 프루닝 촉진**, **인덱스 접근 최적화**, **조인 비용 절감**.
> - 주의: **외부조인(NULL 보존)**, **형변환/함수 가공**, **OR 묶임**, **비결정적 함수** 등은 이행을 막거나 의미를 변형합니다.

---

## 실습 스키마(요약) & 기본 인덱스

```sql
-- 차원/사실 모델
CREATE TABLE d_customer (
  cust_id NUMBER PRIMARY KEY,
  region  VARCHAR2(8) NOT NULL,
  tier    VARCHAR2(8) NOT NULL
);

CREATE TABLE d_product (
  prod_id  NUMBER PRIMARY KEY,
  category VARCHAR2(16) NOT NULL,
  brand    VARCHAR2(16) NOT NULL
);

-- 날짜 차원 (월/일 속성 포함)
CREATE TABLE d_date (
  dt       DATE PRIMARY KEY,
  yyyymm   CHAR(6) NOT NULL,
  yyyy     CHAR(4) NOT NULL,
  mm       CHAR(2) NOT NULL
);

-- 사실 테이블: RANGE PARTITION(sales_dt) 가정(월 단위)
CREATE TABLE f_sales (
  sales_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  prod_id  NUMBER NOT NULL,
  sales_dt DATE   NOT NULL,
  qty      NUMBER NOT NULL,
  amount   NUMBER(12,2) NOT NULL
)
PARTITION BY RANGE (sales_dt) (
  PARTITION p202403 VALUES LESS THAN (DATE '2024-04-01'),
  PARTITION p202404 VALUES LESS THAN (DATE '2024-05-01'),
  PARTITION pmax    VALUES LESS THAN (MAXVALUE)
);

-- 인덱스(예시)
CREATE INDEX ix_fs_cust_dt ON f_sales(cust_id, sales_dt);
CREATE INDEX ix_fs_prod_dt ON f_sales(prod_id, sales_dt);
CREATE INDEX ix_prod_cat_br ON d_product(category, brand, prod_id);
```

**플랜 관찰 루틴**

```sql
-- 실측 실행계획 (Predicate 이동/이행 흔적까지)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL, 'ALLSTATS LAST +PREDICATE +ALIAS +NOTE'));
```

---

# 개념 — 조건절 이행이란 무엇인가?

### 정의

- **조건절 이행(predicate transitivity)**은 **등치 조인/동치 관계**를 매개로 한 **조건의 전파**입니다.
  - `A.col = B.col` **AND** `A.col BETWEEN :lo AND :hi` ⇒ **`B.col BETWEEN :lo AND :hi`**
  - `A.col = B.col` **AND** `A.col = :k` ⇒ **`B.col = :k`**
- Oracle 옵티마이저(이하 CBO)는 **Query Transformation**의 일환으로 이를 자동 시도(**Predicate Move-Around**).

### 혜택

1) **베이스 테이블 접근 전**에 **access predicate**로 만들 수 있어 **인덱스/파티션 프루닝** 촉진
2) **Probe 횟수 감소**(NL Join), **스캔 조기차단**(Hash Join + Bloom Filter)
3) **카디널리티 축소** → 이후 연산(조인/집계) 비용↓

---

# 등치 이행(Equality Transitivity) — 가장 기본이자 강력한 형태

## 2-테이블 등치 이행

```sql
-- 등치: c.cust_id = s.cust_id
-- 상수/범위 조건: c.cust_id BETWEEN :lo AND :hi
-- ⇒ 이행: s.cust_id BETWEEN :lo AND :hi (인덱스/파티션에 활용 가능)
SELECT /*+ USE_NL(s) LEADING(c s) */
       COUNT(*)
FROM   d_customer c
JOIN   f_sales   s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id BETWEEN :lo AND :hi
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

**플랜 기대 포인트**
- `Predicate Information`에 **`access("S"."CUST_ID" BETWEEN :lo AND :hi)`**
- 파티션 가능 구조라면 **`PARTITION RANGE`**가 `:d1~:d2`로 **프루닝**
- 인덱스 `ix_fs_cust_dt` **RANGE SCAN** 유발

## 상수 이행 (Equality to Constant)

```sql
-- c.cust_id = s.cust_id AND c.cust_id = :k
-- ⇒ s.cust_id = :k (빠른 Unique/RANGE 접근)
SELECT /*+ USE_NL(s) LEADING(c s) */
       s.*
FROM   d_customer c
JOIN   f_sales s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id = :k
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

- **NL 조인**에서 특히 강함: 바깥(c)의 키 `:k`가 **안쪽(s)** 인덱스를 곧장 찌름.
- 해시 조인에서도 **Join Filter** 생성이 쉬워져 **프로브 스캔**이 가벼워짐.

## 다단계 이행(3-테이블 체인)

```sql
-- 체인: c.cust_id = s.cust_id AND s.prod_id = p.prod_id
-- 상수/범위 조건: p.brand='B0'
-- ⇒ 이행(전이+푸시): s.prod_id IN (브랜드=B0 집합) → s 접근 축소
SELECT /*+ USE_HASH(p s) LEADING(p s c) */
       c.cust_id, SUM(s.amount)
FROM   d_product p
JOIN   f_sales   s ON s.prod_id = p.prod_id
JOIN   d_customer c ON c.cust_id = s.cust_id
WHERE  p.brand='B0'
AND    c.region='KOR'
GROUP  BY c.cust_id;
```

- `p.brand='B0'`가 `p.prod_id` 집합을 **축소** → 그 제약이 `s.prod_id`로 **이행**
- 해시 조인이라면 `JOIN FILTER CREATE/USE`가 관찰될 수 있음(블룸).

---

# 범위 이행(Range Transitivity) — 등치 조인을 매개로 범위를 전파

## 날짜 차원 → 사실(파티션 프루닝)

```sql
-- 날짜 차원과 조인 + 월 필터만 있음
-- d_date.dt = s.sales_dt AND d_date.yyyymm = '202403'
-- ⇒ 이행: s.sales_dt BETWEEN '2024-03-01' AND '2024-03-31' (또는 < '2024-04-01')
SELECT /*+ USE_HASH(d s) LEADING(d s) */
       COUNT(*)
FROM   d_date  d
JOIN   f_sales s
ON     s.sales_dt = d.dt
WHERE  d.yyyymm = '202403';
```

- CBO는 **차원 필터**(`yyyymm='202403'`)를 기반으로 `d.dt` 범위를 인지하고,
  **등치 조인(sales_dt = dt)** 을 통해 **`s.sales_dt` 범위**로 **이행** → **파티션 p202403만 스캔**.
- 실무에서 **스타 변환(Star Transformation)**/ **동적 파티션 프루닝**과 함께 폭발적인 효과.

## 숫자 범위 — 등치 기반 전파

```sql
-- c.cust_id = s.cust_id AND c.cust_id BETWEEN 100 AND 200
-- ⇒ s.cust_id BETWEEN 100 AND 200
SELECT /*+ USE_NL(s) LEADING(c s) */
       COUNT(*)
FROM   d_customer c
JOIN   f_sales s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id BETWEEN 100 AND 200
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

- 범위는 **인덱스 access predicate**가 되며, **랜덤 I/O**와 **버퍼 미스**를 크게 줄입니다.

---

# 조인 조건 이행(Join Predicate Pushdown) — 전이성 & Bloom

## 조인 전이성(Equality Transitivity)로 상호 전파

```sql
-- 전이성: 등치 조인과 한쪽의 범위/상수가 있으면 상대에도 복제
SELECT /*+ USE_NL(s) LEADING(c s) */
       s.sales_id
FROM   d_customer c
JOIN   f_sales s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id BETWEEN :lo AND :hi
AND    s.sales_dt BETWEEN :d1 AND :d2;
```
- `Predicate Information`에 `s.cust_id BETWEEN ...`가 **access**로 내려가면 성공.

## — 해시 조인의 스캔 차단

```sql
-- p.brand='B0' → p.prod_id 집합 생성 → s.prod_id 스캔 중 조기차단
SELECT /*+ USE_HASH(p) LEADING(p s) */
       SUM(s.amount)
FROM   f_sales s
JOIN   d_product p
ON     p.prod_id = s.prod_id
WHERE  p.brand='B0'
AND    s.sales_dt BETWEEN :d1 AND :d2;
```
- 플랜에 `JOIN FILTER CREATE`(p) / `JOIN FILTER USE`(s)
- 사실 테이블 스캔에서 **불필요한 probe 감소** → I/O 크게 감소

---

# 조건절 이행이 “막히는” 8가지와 해결책

## 외부조인(NULL 보존)

```sql
-- 위험한 패턴: LEFT OUTER에서 내부 테이블 필터를 WHERE에 두면 LEFT→INNER 변질
SELECT c.cust_id, s.amount
FROM   d_customer c
LEFT JOIN f_sales s
  ON s.cust_id = c.cust_id
WHERE c.region='KOR'
  AND s.amount > 100;   -- NULL 보존 깨짐 (이행/푸시 제한)

-- 안전한 위치: ON 절
SELECT c.cust_id, s.amount
FROM   d_customer c
LEFT JOIN f_sales s
  ON s.cust_id = c.cust_id
 AND s.amount  > 100
WHERE c.region='KOR';
```
- 외부조인에서는 **필터 위치**가 핵심. 내부 테이블 필터는 **ON**에 두기.

## 형변환/함수 가공(비 SARGABLE)

```sql
-- 나쁨: 컬럼 가공/형변환은 이행·인덱스 접근을 막음
WHERE TO_CHAR(s.sales_dt,'YYYYMM') = '202403';

-- 좋음: SARGABLE
WHERE s.sales_dt >= DATE '2024-03-01'
  AND s.sales_dt <  DATE '2024-04-01';
```

```sql
-- 나쁨: 암묵적 형변환 (문자↔숫자)
WHERE s.cust_id = :cust_id_varch2;  -- :cust_id_varch2 = '123'

-- 좋음: 바인드 타입을 숫자로 맞추거나, 명시적 변환(좌측 컬럼을 가공하지 않기)
WHERE s.cust_id = TO_NUMBER(:cust_id_varch2);
```

## OR 묶임

```sql
-- OR가 이행/푸시를 막을 때
WHERE (p.brand='B0' OR p.category='ELEC');

-- 해결: USE_CONCAT로 분해 (UNION ALL)
SELECT /*+ USE_CONCAT */ ...
FROM ...
WHERE p.brand='B0'
UNION ALL
SELECT /*+ USE_CONCAT */ ...
FROM ...
WHERE p.category='ELEC';
```

## 비결정적 함수/부작용 함수

- `SYSDATE`, `DBMS_RANDOM`, 패키지 호출 등은 **의미 보존을 깨뜨릴 수** 있어 이행/푸시 제한.

## 분석함수/ROWNUM/CONNECT BY 등 순서·상태 의존 요소

- 의미 보존을 위해 **이행/푸시**가 제한. 필요 시 **수동 재작성** 또는 **뷰 물리화** 고려.

## 제약조건/통계 부재

- **NOT NULL/PK/FK/CHECK**가 선언되어야 CBO가 **안전한 이행**을 자신 있게 수행.
- 통계/히스토그램/확장통계 미비 시 **카디널리티 오판**으로 변환이 회피될 수 있음.

## 결합 조건에 함수 포함

```sql
-- 등치 조인인데 함수가 끼어 있으면 이행 실패/제한
ON  s.sales_dt = TRUNC(d.dt)  -- d.dt와 동일해도 표현이 다르면 막힘

-- 해법: 데이터 정규화(동일 표현), 가상 컬럼/함수기반 인덱스
ALTER TABLE d_date ADD dt_trunc AS (TRUNC(dt));
CREATE INDEX ix_d_date_trunc ON d_date(dt_trunc);
-- 조인도 s.sales_dt = d.dt_trunc 로 통일
```

## 대소문자/콜레이션 이슈(문자열 비교)

- `NLS_COMP/NLS_SORT` 영향으로 **등치**가 **논리적 등치**와 다르면 이행 제한.
- **일관된 콜레이션/대소문자 규칙** 유지 또는 **함수기반 인덱스**.

---

# “조건절 이행”으로 얻는 실전 이득 — 시나리오 별

## 스타 스키마: 차원 필터 → 사실 파티션 프루닝

```sql
-- d_date에만 '202403' 필터가 있는데도, f_sales의 p202403만 읽게 만들기
SELECT /*+ USE_HASH(d s) LEADING(d s) */
       SUM(s.amount)
FROM   d_date d
JOIN   f_sales s
ON     s.sales_dt = d.dt
WHERE  d.yyyymm='202403'
AND    s.prod_id IN (
  SELECT p.prod_id FROM d_product p WHERE p.brand='B0'
);
```

**관찰 포인트**
- `PARTITION RANGE`가 **p202403**으로 제한
- `JOIN FILTER CREATE/USE`(p→s)
- `Predicate Information`에 `access("S"."SALES_DT">=... AND <...)`

## OLTP NL 조인에서의 강력함 (랜덤 I/O 절감)

```sql
-- 바깥(c)이 소량 + 등치/범위 이행으로 s 인덱스 '한 번에' 찌르기
SELECT /*+ USE_NL(s) LEADING(c s) */
       s.*
FROM   d_customer c
JOIN   f_sales s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id IN (:k1,:k2,:k3)
AND    s.sales_dt BETWEEN :d1 AND :d2;
```
- 이행된 `s.cust_id IN (:k...)`로 **키별 인덱스 탐색** → **early-out** 가능

## 집계와 결합 — 사전집계 위치 재배치와 함께

```sql
-- 고객별 3월 매출합 (차원/사실/제품 필터 결합)
SELECT /*+ USE_HASH(d p s) LEADING(d p s c) */
       c.cust_id, SUM(s.amount) sum_amt
FROM   d_date d
JOIN   f_sales s ON s.sales_dt = d.dt
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_customer c ON c.cust_id = s.cust_id
WHERE  d.yyyymm='202403'
AND    p.brand='B0'
AND    c.region='KOR'
GROUP  BY c.cust_id;
```
- `d.yyyymm='202403'` & `p.brand='B0'`가 **각각 s.sales_dt/s.prod_id**로 이행
- 집계는 **이미 축소된 사실 행**만 대상으로 수행 → CPU/I/O 절감

---

# 튜닝 절차 — “이행이 일어났는지” 확인하는 방법

```sql
-- 1) 실행 전후 세션 통계(논리/물리 읽기) 비교
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON ms.stat#=sn.stat#
WHERE  sn.name IN ('session logical reads','physical reads','consistent gets');

-- 2) 쿼리 실행(이행 유도 전/후 버전 각각)

-- 3) 실측 계획(ALLSTATS LAST)로 Access/Filter 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL, 'ALLSTATS LAST +PREDICATE +NOTE +ALIAS'));
```

**체크 포인트**
- `Predicate Information`
  - **access("S"."CUST_ID" …)**, **access("S"."SALES_DT" …)** 등 **안쪽 테이블**에 전파되었는지
- `PARTITION RANGE` 노드가 **필요 파티션만** 가리키는지
- `JOIN FILTER CREATE/USE` 등장(해시 조인)
- `E-Rows vs A-Rows`가 **가까워졌는지**(카디널리티 추정 정확도)

---

# 실전 팁 & 힌트

## 작성 습관

- **SARGABLE**: 컬럼 좌측, 상수/바인드는 우측. **컬럼 가공 금지**
- **동치 조인**은 **함수/형변환 없는** 순수 등치로
- **바인드 타입 일치**(숫자는 숫자, 날짜는 날짜)
- 날짜/숫자 범위는 `>= AND <`(상한 미만) 형태로 명확히

## 힌트/변환

- `PUSH_PRED`/`PUSH_SUBQ`/`UNNEST` 로 **먼저 좁히기**
- `MERGE(qb)`로 **인라인 뷰 병합** → 이행/푸시 여지 확대
- `USE_HASH/USE_NL` & `LEADING/ORDERED`로 **조인 전략** 고정
- 스타 스키마면 `STAR_TRANSFORMATION`/`FACT`/`DIMENSION`(버전/옵션 의존)

## 물리 설계 보조

- **필요 컬럼 조합**으로 **복합 인덱스**(선두열이 이행된 조건과 일치하도록)
- **파티션 키**를 **이행이 잘 걸리는 컬럼**으로 설계(날짜)
- 불가피한 함수엔 **함수기반 인덱스**/가상 컬럼

---

# 잘못된 이행/의미 변경을 피하기(경계 사례)

### 외부조인 + WHERE 필터

```sql
-- 나쁨
SELECT c.cust_id
FROM   d_customer c LEFT JOIN f_sales s
ON     s.cust_id = c.cust_id
WHERE  s.amount > 0;   -- LEFT→INNER 변질(이행/푸시도 억제)

-- 올바름: ON에 배치
SELECT c.cust_id
FROM   d_customer c LEFT JOIN f_sales s
ON     s.cust_id = c.cust_id
AND    s.amount  > 0;
```

### 암묵적 형변환

```sql
-- 인덱스/이행 둘 다 깨짐 가능
WHERE s.cust_id = '100';  -- 문자상수

-- 해결
WHERE s.cust_id = TO_NUMBER(:cust_id_varchar2);
```

### 조인에 함수 개입

```sql
-- 이행 제한
ON  s.sales_dt = TRUNC(d.dt);

-- 해결(동치 표현 통일 or 함수기반 인덱스)
ALTER TABLE d_date ADD dt_trunc AS (TRUNC(dt));
CREATE INDEX ix_d_date_trunc ON d_date(dt_trunc);
-- 조인: s.sales_dt = d.dt_trunc
```

---

# 요약 체크리스트

- [ ] 등치 조인 + 한쪽 상수/범위 ⇒ **반대쪽 컬럼으로 이행되었는지**(Access Pred)
- [ ] 날짜 차원 필터 ⇒ 사실의 **파티션 프루닝**으로 연결되는지
- [ ] **SARGABLE** 작성(컬럼 가공 금지, 바인드 타입 일치)
- [ ] **외부조인** 내부 필터는 **ON 절**(NULL 보존 유지)
- [ ] OR은 **USE_CONCAT**로 분해해 분기별 이행/푸시 회복
- [ ] 통계/히스토그램/확장통계로 **카디널리티 오판** 방지
- [ ] 실측: `DBMS_XPLAN … ALLSTATS LAST +PREDICATE +NOTE`로 확인

---

## 부록 A. 미니 실습 묶음

### A-1. 등치 이행 관찰(Access로 내려갔는지)

```sql
EXPLAIN PLAN FOR
SELECT /*+ USE_NL(s) LEADING(c s) */
       COUNT(*)
FROM   d_customer c
JOIN   f_sales   s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id BETWEEN 100 AND 200
AND    s.sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 실측
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE +ALIAS'));
-- 기대: access("S"."CUST_ID" BETWEEN 100 AND 200)
```

### A-2. 날짜 차원 → 파티션 프루닝

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   d_date  d
JOIN   f_sales s ON s.sales_dt = d.dt
WHERE  d.yyyymm = '202403';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
-- 기대: PARTITION RANGE (p202403) 만 액세스
```

### A-3. OR-EXPAND로 이행 회복

```sql
SELECT /*+ USE_CONCAT */
       COUNT(*)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  (p.brand='B0' OR p.category='ELEC')
AND    s.sales_dt BETWEEN :d1 AND :d2;

-- 실행계획에서 각 분기별로 이행/푸시 여부 확인
```

### A-4. 외부조인 의미 보존

```sql
-- 잘못된 WHERE 필터 → ON으로 이동
SELECT c.cust_id, s.amount
FROM   d_customer c
LEFT JOIN f_sales s
  ON s.cust_id = c.cust_id
 AND s.amount  > 100
WHERE c.region  = 'KOR';
```

---

## 부록 B. FAQ

**Q1. “조건절 이행”과 “조건절 푸시다운”의 차이?**
- **이행**은 **동치/등가 관계를 이용해 조건을 복제**하는 논리(예: c=cust_id=s.cust_id ⇒ s 쪽에도 같은 범위/상수).
- **푸시다운**은 그(또는 원래의) 조건을 **더 아래(뷰 내부/테이블/파티션)로 이동**하는 전략.
- 실무에서는 **이행으로 만든 조건을 푸시**하는 것이 한 세트로 동작.

**Q2. 항상 자동으로 되나요?**
- 아닙니다. **외부조인/함수/형변환/OR**/의미 보존 이슈/통계 부족 등으로 **회피**될 수 있습니다.
  → **SARGABLE** 작성, **힌트/재작성**, **통계 정비**로 돕습니다.

**Q3. 해시 조인에서도 이행이 유효한가요?**
- 예. 해시 조인은 **Join Filter(Bloom)**까지 생성되어 **스캔 단계에서 조기 차단** 효과가 큽니다.

---

### 결론

- **조건절 이행**은 Oracle 최적화의 **핵심 기초 체인**입니다. 등치 조인과 한쪽 조건만으로 **반대쪽 테이블의 access predicate**를 자동 생성해 **읽기 최소화**를 이끕니다.
- **SARGABLE 작성**, **필터의 올바른 위치(특히 외부조인)**, **통계 정비**만 지켜도 대부분의 쿼리에서 **프루닝/인덱스 효율/조인 비용**이 눈에 띄게 개선됩니다.
- 최종 판단은 **실측 실행계획 + 세션 통계**로! — *“내려갔는지(Access Pred), 잘 잘렸는지(Partition), 덜 읽었는지(Reads)”*를 확인하세요.
