---
layout: post
title: DB 심화 - 조건절 이행
date: 2025-11-18 15:25:23 +0900
category: DB 심화
---
# 오라클 조건절 이행(Predicate Transitivity) 완전 가이드

## 핵심 개념과 중요성

**조건절 이행(Predicate Transitivity)**은 등치(동치) 관계를 활용하여 조건을 자동으로 복제하고, 복제된 조건이 액세스 조건(access predicate)으로 하향 전파되도록 하는 쿼리 변환 기법입니다.

### 간결한 정의
등치 관계 `A = B`와 A에 대한 조건이 주어졌을 때, 옵티마이저가 **B에 대한 동등한 조건을 논리적으로 유추하여 생성**하고, 이를 **테이블, 파티션, 인덱스 접근 단계까지 전파**하는 자동화된 최적화 과정입니다.

### 왜 조건절 이행이 중요한가?

조건절 이행이 성공적으로 적용되면 생성된 조건이 **액세스 조건(access predicate)**으로 작용하여 다음과 같은 성능 향상을 가져옵니다:

1. **인덱스 스캔 범위 축소**: 불필요한 인덱스 범위 읽기를 제거합니다.
2. **파티션 프루닝 활성화**: 필요한 파티션만 접근하도록 최적화합니다.
3. **조인 입력 크기 감소**: 조인 전에 데이터를 사전 필터링합니다.
4. **실행계획 전면 개선**: 조인 방식, 조인 순서, 집계 위치 선택에 근본적인 영향을 미칩니다.

즉, 조건절 이행은 단순한 조건 추가가 아니라 **다른 모든 최적화 기법의 기반이 되는 핵심 메커니즘**입니다.

---

## 내부 동작 메커니즘: 동치 클래스와 전이 폐쇄

### 동치 클래스(Equivalence Class) 형성
옵티마이저는 쿼리 최적화 초기 단계에서 등치 조인 조건들을 분석하여 **동치 집합(Equivalence Class)**을 구성합니다.

예를 들어:
- `c.cust_id = s.cust_id`
- `c.cust_id = r.cust_id`

위 조건들로부터 `{c.cust_id, s.cust_id, r.cust_id}`라는 동치 클래스가 생성됩니다.

### 전이 폐쇄(Transitive Closure) 규칙
동치 클래스 내에서 한 요소에 적용된 조건은 **논리적으로 안전한 경우** 다른 모든 요소로 복제됩니다:

- **상수 이행**
  - `A.col = B.col AND A.col = :k`
  - ⇒ `B.col = :k`

- **범위 이행**
  - `A.col = B.col AND A.col BETWEEN :lo AND :hi`
  - ⇒ `B.col BETWEEN :lo AND :hi`

- **다단계 이행**
  - `A = B AND B = C AND A IN R`
  - ⇒ `B IN R`, `C IN R`

이러한 복제된 조건은 **조건절 재배치(Predicate Move-Around)** 및 **푸시다운(Pushdown)**과 결합되어 실제 데이터 액세스 단계까지 전파됩니다.

### 액세스 조건 vs 필터 조건: 성공 판단 기준
조건절 이행의 진정한 성공 여부는 **이행된 조건이 액세스 조건으로 작용하는지**에 달려 있습니다:

- **액세스 조건(Access Predicate)**: 인덱스, 파티션, 조인 입력을 **접근하기 전에** 줄이는 조건
- **필터 조건(Filter Predicate)**: 읽은 결과를 **후처리 단계에서** 거르는 조건

`DBMS_XPLAN.DISPLAY_CURSOR(..., '+PREDICATE')` 출력에서 다음을 확인할 수 있습니다:
- `access("S"."CUST_ID" BETWEEN :lo AND :hi)` → 성공
- `filter("S"."CUST_ID" BETWEEN :lo AND :hi)` → 부분 성공 또는 실패

---

## 조건절 이행의 주요 패턴과 예제

### 등치 이행(Equality Transitivity)

#### 2-테이블 기본 패턴
```sql
SELECT /*+ qb_name(main) USE_NL(s) LEADING(c s) */
       COUNT(*)
FROM   d_customer c
JOIN   f_sales   s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id BETWEEN :lo AND :hi
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

**이행 효과**
- `c.cust_id = s.cust_id` 관계를 통해
- `s.cust_id BETWEEN :lo AND :hi` 조건이 자동 생성
- `ix_fs_cust_dt(cust_id, sales_dt)` 인덱스의 **범위 스캔(RANGE SCAN)** 유도

**성과**: Nested Loops 조인에서 내부 테이블 인덱스 탐색 범위가 크게 축소되어 I/O가 현저히 감소합니다.

#### 상수 이행(Equality-to-Constant)
```sql
SELECT /*+ USE_NL(s) LEADING(c s) */
       s.sales_id, s.amount
FROM   d_customer c
JOIN   f_sales s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id = :k
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

- 이행된 `s.cust_id = :k` 조건이 **유일 스캔(UNIQUE SCAN)** 또는 **범위 스캔(RANGE SCAN)**의 직접적인 키가 됩니다.
- 내부 테이블 접근이 **단일 프로브**로 최적화됩니다.

#### 다단계(체인) 이행
```sql
SELECT /*+ qb_name(main) USE_HASH(p s c) LEADING(p s c) */
       c.cust_id, SUM(s.amount)
FROM   d_product  p
JOIN   f_sales    s ON s.prod_id = p.prod_id
JOIN   d_customer c ON c.cust_id = s.cust_id
WHERE  p.brand  = 'B0'
AND    c.region = 'KOR'
GROUP  BY c.cust_id;
```

**이행 체인**
1. `p.brand='B0'` → `p.prod_id` 후보 필터링
2. `p.prod_id = s.prod_id` ⇒ `s.prod_id` 조건 이행
3. `c.region='KOR'` → `c.cust_id` 후보 필터링
4. `c.cust_id = s.cust_id` ⇒ `s.cust_id` 조건 이행

**핵심 통찰**: 팩트 테이블의 키들에 대한 **양쪽 차원 테이블 필터가 동시에 액세스 조건으로 전파**되며, 이는 스타 변환(Star Transformation)과 블룸 필터(Bloom Filter) 최적화로 자연스럽게 이어집니다.

### 범위 이행(Range Transitivity)

#### 날짜 차원 → 팩트 테이블(파티션 프루닝)
```sql
SELECT /*+ qb_name(main) USE_HASH(d s) LEADING(d s) */
       COUNT(*)
FROM   d_date  d
JOIN   f_sales s
ON     s.sales_dt = d.dt
WHERE  d.yyyymm = '202403';
```

**이행 논리**
- `d.yyyymm='202403'`은 `d.dt`의 특정 범위를 의미합니다.
- `d.dt = s.sales_dt` 등치 관계를 통해
- `s.sales_dt` 범위 조건으로 이행됩니다.
- `f_sales` 테이블이 RANGE 파티션이면 **p202403 파티션만 스캔**합니다.

**실무적 의미**: **차원 테이블에만 조건이 있어도 팩트 테이블 파티션이 즉시 축소되는** 가장 효과적인 사례입니다.

#### 숫자 범위 이행
```sql
SELECT /*+ USE_NL(s) LEADING(c s) */
       COUNT(*)
FROM   d_customer c
JOIN   f_sales s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id BETWEEN 100 AND 200
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

- `s.cust_id BETWEEN 100 AND 200` 조건이 액세스 조건으로 전파되면
- `cust_id` 선두열 인덱스에서 **불필요한 범위를 완전히 배제**하고 스캔합니다.

---

## 해시 조인과 조건절 이행: 블룸 필터(Join Filter)와의 시너지

### 블룸 필터의 역할
해시 조인에서:
- 작은 테이블(빌드 입력)에서 해시 테이블을 생성할 때 **블룸 필터(Join Filter)**도 함께 생성됩니다.
- 큰 테이블(프로브 입력) 스캔 시 블룸 필터를 사용하여 **조기 차단(Early Filtering)**을 수행합니다.

### 차원 필터가 팩트 스캔을 최적화하는 패턴
```sql
SELECT /*+ USE_HASH(p s) LEADING(p s) */
       SUM(s.amount)
FROM   f_sales s
JOIN   d_product p
ON     p.prod_id = s.prod_id
WHERE  p.brand='B0'
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

**실행계획 관찰점**
- `JOIN FILTER CREATE` (p 측)
- `JOIN FILTER USE` (s 측)

**작동 원리**
- `p.brand='B0'` 조건이 `p.prod_id` 후보 집합을 생성합니다.
- `p.prod_id = s.prod_id` 등치 관계를 통해
- `s.prod_id IN (후보)` 형태의 조건이 이행되고 블룸 필터로 구현됩니다.
- 팩트 테이블 스캔 중 **조기 필터링**이 적용되어 불필요한 I/O를 방지합니다.

---

## 조건절 이행이 제한되는 8가지 상황과 해결 방안

### 1. 외부 조인과 NULL 보존 문제
```sql
-- 문제 패턴: WHERE 절 조건이 LEFT JOIN을 INNER JOIN으로 변환
SELECT c.cust_id, s.amount
FROM   d_customer c
LEFT JOIN f_sales s
  ON s.cust_id = c.cust_id
WHERE  c.region='KOR'
  AND  s.amount > 100;
```

**문제점**: WHERE 절의 `s.amount > 100` 조건은 `s`가 NULL인 행을 모두 제거하여 LEFT JOIN의 의미를 훼손합니다. 옵티마이저는 이러한 의미 변경을 방지하기 위해 이행을 제한합니다.

**해결책**:
```sql
SELECT c.cust_id, s.amount
FROM   d_customer c
LEFT JOIN f_sales s
  ON s.cust_id = c.cust_id
 AND s.amount  > 100
WHERE  c.region='KOR';
```

### 2. 컬럼 가공/비 SARGABLE 조건
```sql
-- 비효율 패턴
WHERE TO_CHAR(s.sales_dt,'YYYYMM')='202403';
```

**문제점**: 컬럼 가공으로 인해 파티션 키나 인덱스 선두열로 인식되지 않으며, 등치성 판단이 어려워져 이행이 제한됩니다.

**해결책**:
```sql
WHERE s.sales_dt >= DATE '2024-03-01'
  AND s.sales_dt <  DATE '2024-04-01';
```

### 3. 암묵적 형변환
```sql
WHERE s.cust_id = '100';           -- 숫자 컬럼에 문자 상수
WHERE s.cust_id = :varch2_bind;    -- 데이터 타입 불일치
```

**문제점**: 암묵적 형변환으로 등치 관계가 불명확해져 이행이 중단됩니다.

**해결책**:
- 바인드 변수 타입 일치화
- 명시적 형변환 적용:
```sql
WHERE s.cust_id = TO_NUMBER(:varch2_bind);
```

### 4. OR 조건의 복잡성
```sql
WHERE (p.brand='B0' OR p.category='ELEC');
```

**문제점**: OR 조건은 선택도 추정이 어렵고, 조건 이행 시 각 분기별 의미가 달라질 수 있어 이행이 제한됩니다.

**해결책**:
```sql
SELECT /*+ USE_CONCAT */ ...
FROM ...
WHERE p.brand='B0'
UNION ALL
SELECT /*+ USE_CONCAT */ ...
FROM ...
WHERE p.category='ELEC';
```

### 5. 비결정적 함수/부작용 함수 사용
- `SYSDATE`, `SYSTIMESTAMP`, `DBMS_RANDOM`, 부작용이 있는 사용자 정의 함수

**문제점**: 함수 평가 시점 차이로 인해 결과 일관성이 보장되지 않아 옵티마이저가 보수적으로 접근합니다.

### 6. 분석 함수/ROWNUM/CONNECT BY 사용
**문제점**: 실행 순서와 상태에 의존적인 구성요소가 포함되면 조건 평가 시점이 결과에 영향을 미쳐 이행이 제한됩니다.

### 7. 조인 조건에 함수 포함
```sql
ON s.sales_dt = TRUNC(d.dt);
```

**문제점**: 표현식 차이로 정확한 등치 관계로 인식되지 않아 이행 효과가 약화됩니다.

**해결책**:
```sql
-- 가상 컬럼과 함수 기반 인덱스 활용
ALTER TABLE d_date ADD dt_trunc AS (TRUNC(dt));
CREATE INDEX ix_d_date_trunc ON d_date(dt_trunc);
-- 조인 조건
ON s.sales_dt = d.dt_trunc;
```

### 8. 제약조건/통계 정보 부재
**문제점**: PK, FK, NOT NULL, CHECK 제약이 없거나 히스토그램/확장 통계가 부재하면 등치성과 전이 안전성을 확신할 수 없어 이행이 제한됩니다.

---

## 조건절 이행이 성능에 미치는 결정적 영향: 실전 시나리오

### 스타 스키마 최적화: 차원 조건만으로 팩트 파티션 축소
```sql
SELECT /*+ USE_HASH(d p s) LEADING(d p s) */
       SUM(s.amount)
FROM   d_date d
JOIN   f_sales s ON s.sales_dt = d.dt
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  d.yyyymm='202403'
AND    p.brand='B0';
```

**이행 체인 효과**
- `d.yyyymm='202403'` → `s.sales_dt` 범위 이행 → 파티션 프루닝
- `p.brand='B0'` → `s.prod_id` 조건 이행 → 블룸 필터/인덱스 접근 강화

### OLTP Nested Loops 조인: 외부 키로 내부 인덱스 단일 프로브
```sql
SELECT /*+ USE_NL(s) LEADING(c s) */
       s.*
FROM   d_customer c
JOIN   f_sales s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id IN (:k1,:k2,:k3)
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

- `c.cust_id IN (...)` 조건이 `s.cust_id IN (...)`으로 이행되어 액세스 조건이 되면
- **3개의 키에 대한 인덱스 프로브만 수행**하고 작업을 종료합니다.

### 집계 위치 재조정을 유도하는 연쇄 효과
```sql
SELECT /*+ USE_HASH(d p s c) LEADING(d p s c) */
       c.cust_id, SUM(s.amount)
FROM   d_date d
JOIN   f_sales s ON s.sales_dt = d.dt
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_customer c ON c.cust_id = s.cust_id
WHERE  d.yyyymm='202403'
AND    p.brand='B0'
AND    c.region='KOR'
GROUP  BY c.cust_id;
```

- 조건절 이행으로 인해 `f_sales` 테이블이 극적으로 축소됩니다.
- 후속 집계와 조인 작업들이 **축소된 팩트 테이블을 기준으로 재배치**됩니다.
- 결과적으로 해시, 정렬, 그룹화 비용이 현저히 감소합니다.

---

## 조건절 이행 성공 여부 진단 프로세스

### 실측 실행계획 분석
```sql
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE +ALIAS'));
```

### 체크포인트

1. **Predicate Information 분석**
   - 내부 테이블에 이행된 조건이 존재하는가?
   - 해당 조건이 `access`인지 `filter`인지 확인

2. **파티션 범위 확인**
   - 필요한 파티션만 스캔하는 파티션 프루닝이 적용되었는가?

3. **조인 필터 확인**
   - 해시 조인에서 `JOIN FILTER CREATE/USE`가 관찰되는가?

4. **예상 vs 실제 행 수 비교**
   - 이행 적용 후 카디널리티 추정 정확도가 개선되었는가?

5. **세션 통계 모니터링**
   - 논리적 읽기(logical reads)와 물리적 읽기(physical reads)가 현저히 감소했는가?

---

## 실전 개발 및 설계 지침

### 쿼리 작성 모범 사례

- **SARGABLE 조건 준수**
  - 컬럼은 조건 좌측, 상수/바인드는 우측에 배치
  - 컬럼 가공 최소화
- **순수 등치 조인 유지**
  - 함수나 형변환 없는 `A.col = B.col` 패턴 사용
- **데이터 타입 일관성**
  - 숫자는 숫자 타입, 날짜는 날짜 타입으로 통일
- **범위 조건 표준화**
  - `>= AND <` 패턴 사용으로 파티션/인덱스 인식률 극대화

### 힌트 활용 전략(최소 개입 원칙)

- **조기 축소 유도**
  - `UNNEST`, `PUSH_PRED`, `PUSH_SUBQ` 힌트 활용
- **전이 경로 확보**
  - `MERGE(@qb)` / 방어적 `NO_MERGE(@qb)`
- **조인 전략 명시**
  - `LEADING`, `USE_NL`, `USE_HASH`로 실행계획 안정화
- **변환 제어**
  - `NO_QUERY_TRANSFORMATION`은 쿼리 블록 단위로 최후의 수단으로만 사용

### 물리적 데이터베이스 설계 최적화

- **이행 가능성이 높은 컬럼을 인덱스 선두열로 구성**
  - 예: `(cust_id, sales_dt)`
- **파티션 키는 이행이 잘 적용되는 컬럼 선택**
  - 날짜 컬럼이 가장 이상적
- **불가피한 함수는 가상 컬럼과 함수 기반 인덱스로 구현**
  - 조건절 이행 및 푸시다운 기능 회복

---

## 결론

조건절 이행은 오라클 옵티마이저의 **기본적이면서도 가장 강력한 최적화 체인**입니다. 이 기법의 성공적 적용은 단순한 조건 추가를 넘어 **인덱스 선택, 파티션 프루닝, 조인 순서, 조인 방식, 집계 위치에 이르기까지 실행계획 전반에 걸친 근본적인 변화**를 초래합니다.

효과적인 조건절 이행을 위한 실전 원칙은 다음과 같습니다:

1. **기술적 기반 구축**: SARGABLE 조건과 순수 등치 조인으로 이행 경로를 확보합니다.
2. **전파 메커니즘 활성화**: 이행된 조건이 액세스 조건으로 작용하도록 최적화 환경을 조성합니다.
3. **실증적 검증**: 실행계획과 성능 통계를 통해 실제 성능 개선 효과를 검증합니다.

이 세 가지 원칙을 체계적으로 적용하면 대부분의 실무 쿼리에서 **I/O 부하, 조인 비용, 응답 시간이 현저히 개선**되는 결과를 얻을 수 있습니다. 조건절 이행은 복잡해 보이지만, 그 동작 원리를 이해하고 적절히 활용하면 데이터베이스 성능 최적화의 강력한 도구가 됩니다.