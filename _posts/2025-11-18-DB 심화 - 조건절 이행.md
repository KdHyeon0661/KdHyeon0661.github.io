---
layout: post
title: DB 심화 - 조건절 이행
date: 2025-11-18 15:25:23 +0900
category: DB 심화
---
# 오라클 조건절 이행(Predicate Transitivity)

> 목표는 한 문장이다.
> **“등치(동치) 관계를 이용해 조건을 복제하고, 그 복제된 조건이 access predicate로 내려가게 만들어라.”**

---

## 한 줄 정의와 큰 그림

### 한 줄 정의

- **조건절 이행**은
  **`A=B`(동치) 관계 + A에 대한 조건**으로부터
  **B에 대한 동치/범위 조건을 자동으로 유도**해
  **더 하단(테이블·파티션·인덱스)으로 필터를 전파**하는 쿼리 변환이다.

### 왜 중요한가

옵티마이저는 이행된 조건을 **access predicate**로 만들 수 있으면:
1. **인덱스 범위가 즉시 좁아짐**
2. **파티션 프루닝이 즉시 가능해짐**
3. **조인 입력량이 즉시 줄어듦**
4. 그 결과 **조인 방식/조인 순서/집계 위치** 선택이 완전히 달라질 수 있다.

즉, 조건절 이행은 **단일 변환이 아니라 “다른 변환을 가능하게 하는 바닥 공사”** 다.

---

## 내부 메커니즘: “동치 클래스(Equivalence Class)와 전이 폐쇄”

### 옵티마이저는 무엇을 만들나

CBO는 최적화 초기에 **등치 조인 조건들로 동치 집합(Equivalence Class)** 을 만든다.

예)
`c.cust_id = s.cust_id`
`c.cust_id = r.cust_id` 라면

동치 클래스는
`{c.cust_id, s.cust_id, r.cust_id}` 로 묶인다.

### 전이 규칙(Transitive Closure)

동치 클래스 안에서
어느 한 원소에 붙은 조건은, **논리적으로 안전하면** 다른 원소로 복제된다.

- **상수 이행**
  - `A.col = B.col AND A.col = :k`
  - ⇒ `B.col = :k`

- **범위 이행**
  - `A.col = B.col AND A.col BETWEEN :lo AND :hi`
  - ⇒ `B.col BETWEEN :lo AND :hi`

- **다단계 이행**
  - `A=B AND B=C AND A in R`
  - ⇒ `B in R`, `C in R`

이 복제된 조건이 **Predicate Move-Around / Pushdown** 과 결합되어
실제 테이블 접근 단계까지 내려간다.

---

## 가장 중요한 결과 형태: access predicate vs filter predicate

### access predicate가 되면 “물리 경로가 바뀐다”

- **access**: 인덱스/파티션/조인 입력을 **“들어가기 전에”** 줄이는 조건
- **filter**: 들어온 결과를 **“나중에”** 거르는 조건

조건절 이행의 **진짜 성공 조건은 “이행된 조건이 access로 내려갔는가”** 다.

### Predicate Information에서 보는 법

`DBMS_XPLAN.DISPLAY_CURSOR(... '+PREDICATE')`의

- `access("S"."CUST_ID" BETWEEN :lo AND :hi)`
- `filter("S"."CUST_ID" BETWEEN :lo AND :hi)`

이 한 줄이 **성공/반쪽 성공/실패**를 가른다.

---

## 등치 이행(Equality Transitivity)

### 2-테이블 기본 패턴

```sql
SELECT /*+ qb_name(main) USE_NL(s) LEADING(c s) */
       COUNT(*)
FROM   d_customer c
JOIN   f_sales   s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id BETWEEN :lo AND :hi
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

**의도**
- 바깥(c)에만 범위가 있어도
  `c.cust_id = s.cust_id` 덕분에

**이행 기대**
- `s.cust_id BETWEEN :lo AND :hi` 생성
- `ix_fs_cust_dt(cust_id, sales_dt)`의 **RANGE SCAN** 유발

**결과**
- NL Join에서 **안쪽 인덱스 탐색 키가 좁아짐**
- 실측 I/O가 눈에 띄게 떨어진다.

### 상수 이행(Equality-to-Constant)

```sql
SELECT /*+ USE_NL(s) LEADING(c s) */
       s.sales_id, s.amount
FROM   d_customer c
JOIN   f_sales s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id = :k
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

- 이행된 `s.cust_id = :k`는 **unique/range scan**의 직접 키가 되어
  안쪽 테이블 접근이 **“1방”** 으로 줄어든다.

### 다단계(체인) 이행

```sql
SELECT /*+ qb_name(main) USE_HASH(p s c) LEADING(p s c) */
       c.cust_id, SUM(s.amount)
FROM   d_product  p
JOIN   f_sales    s ON s.prod_id = p.prod_id
JOIN   d_customer c ON c.cust_id = s.cust_id
WHERE  p.brand  = 'B0'
AND    c.region = 'KOR'
GROUP  BY c.cust_id;
```

**전이 흐름**
1) `p.brand='B0'` → `p.prod_id` 후보가 좁아짐
2) `p.prod_id = s.prod_id` ⇒ `s.prod_id`로 이행
3) `c.region='KOR'` → `c.cust_id` 후보 좁힘
4) `c.cust_id = s.cust_id` ⇒ `s.cust_id`로 이행

**핵심**
- 사실 테이블의 키들에 대한 **양쪽 차원 필터가 동시에 access로 내려감**
- 스타 변환/블룸 필터까지 자연스럽게 이어진다.

---

## 범위 이행(Range Transitivity)

### 날짜 차원 → 사실 테이블(파티션 프루닝)

```sql
SELECT /*+ qb_name(main) USE_HASH(d s) LEADING(d s) */
       COUNT(*)
FROM   d_date  d
JOIN   f_sales s
ON     s.sales_dt = d.dt
WHERE  d.yyyymm = '202403';
```

**논리**
- `d.yyyymm='202403'`은 d.dt 범위를 의미한다.
- `d.dt = s.sales_dt`
- ⇒ `s.sales_dt` 범위로 이행
- ⇒ `f_sales` RANGE 파티션이면 **p202403만 스캔**

**실전 의미**
- **차원 테이블에만 조건이 있어도 사실 파티션이 즉시 줄어드는** 가장 대표적인 케이스.

### 숫자 범위 이행

```sql
SELECT /*+ USE_NL(s) LEADING(c s) */
       COUNT(*)
FROM   d_customer c
JOIN   f_sales s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id BETWEEN 100 AND 200
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

- `s.cust_id BETWEEN 100 AND 200`이 access로 내려가면
  `cust_id` 선두열 인덱스에서 **불필요한 범위를 전혀 읽지 않는다.**

---

## 해시 조인과 조건절 이행: Bloom / Join Filter와 결합

### 조인이 “필터 생성기”가 되는 이유

해시 조인에서는
- 작은 쪽(빌드)에서 해시 테이블을 만들고
- 큰 쪽(프로브)을 스캔하며 매칭을 찾는다.

이때 작은 쪽에서 **블룸 필터(Join Filter)** 를 만들면
큰 쪽 스캔을 **조기 차단**할 수 있다.

### 차원 필터가 사실 스캔을 막는 형태

```sql
SELECT /*+ USE_HASH(p s) LEADING(p s) */
       SUM(s.amount)
FROM   f_sales s
JOIN   d_product p
ON     p.prod_id = s.prod_id
WHERE  p.brand='B0'
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

**관찰**
- `JOIN FILTER CREATE` (p)
- `JOIN FILTER USE` (s)

**설명**
- `p.brand='B0'`가 `p.prod_id` 후보를 만들고
- `p.prod_id = s.prod_id`를 통해
- `s.prod_id IN (후보)` 형태로 **이행 + 블룸 필터**가 생성
- 사실 스캔이 **읽는 도중에 버려진다**.

---

## 조건절 이행이 막히는 대표 8가지 (그리고 실전 해법)

### 외부조인(NULL 보존)

```sql
-- 위험: WHERE의 s.amount가 LEFT를 INNER로 바꿔버림
SELECT c.cust_id, s.amount
FROM   d_customer c
LEFT JOIN f_sales s
  ON s.cust_id = c.cust_id
WHERE  c.region='KOR'
  AND  s.amount > 100;
```

**왜 막히나**
- LEFT 조인의 의미는 “매칭이 없어도 c는 남긴다”
- 그런데 WHERE에 `s.amount>100`을 두면
  `s`가 NULL인 행이 다 제거된다.
  **결과 의미가 달라져서** 옵티마이저는 이행/푸시를 제한한다.

**정답**
```sql
SELECT c.cust_id, s.amount
FROM   d_customer c
LEFT JOIN f_sales s
  ON s.cust_id = c.cust_id
 AND s.amount  > 100
WHERE  c.region='KOR';
```

### 컬럼 가공/형변환(비 SARGABLE)

```sql
-- 나쁨
WHERE TO_CHAR(s.sales_dt,'YYYYMM')='202403';
```
- 파티션 키/인덱스 선두열로 인식 불가
- 이행도 “동치성 판단”이 깨져서 제한

```sql
-- 좋음
WHERE s.sales_dt >= DATE '2024-03-01'
  AND s.sales_dt <  DATE '2024-04-01';
```

### 암묵적 형변환

```sql
WHERE s.cust_id = '100';           -- 문자 상수
WHERE s.cust_id = :varch2_bind;    -- 바인드 타입 불일치
```

- 등치가 깨진 것으로 판단되면 이행 자체가 멈춘다.

**해법**
- 바인드 타입 맞추기
- 또는 “컬럼을 가공하지 않는” 명시적 변환
```sql
WHERE s.cust_id = TO_NUMBER(:varch2_bind);
```

### OR 묶임

```sql
WHERE (p.brand='B0' OR p.category='ELEC');
```
- OR는 선택도를 정확히 분해하기 어렵고
  전이 조건을 넣으면 분기마다 의미가 달라질 수 있어
  이행/푸시가 둔화된다.

**해법**
```sql
SELECT /*+ USE_CONCAT */ ...
FROM ...
WHERE p.brand='B0'
UNION ALL
SELECT /*+ USE_CONCAT */ ...
FROM ...
WHERE p.category='ELEC';
```

### 비결정적 함수/부작용 함수

- `SYSDATE`, `SYSTIMESTAMP`, `DBMS_RANDOM`, 사용자 정의 함수 중 부작용/비결정적 함수
- 이런 조건은 복제하면 “평가 시점”이 달라질 수 있어
  CBO가 최대한 보수적으로 다룬다.

### 분석함수/ROWNUM/CONNECT BY

- 순서·상태 의존 요소가 있으면
  **“조건이 언제 평가되는가”** 가 결과를 바꾼다.
- 이행/푸시가 걸리더라도 부분적으로 제한될 수 있다.

### 조인 조건에 함수가 끼어 있음

```sql
ON s.sales_dt = TRUNC(d.dt);
```
- 표현이 달라서 “정확한 동치”로 볼 수 없으면 이행이 약해진다.

**해법**
- 표현 통일
- 또는 가상 컬럼/함수기반 인덱스
```sql
ALTER TABLE d_date ADD dt_trunc AS (TRUNC(dt));
CREATE INDEX ix_d_date_trunc ON d_date(dt_trunc);
-- 조인: s.sales_dt = d.dt_trunc
```

### 제약조건/통계 부재

- PK/FK/NOT NULL/CHECK가 없으면
  동치·전이의 안전성이 떨어져 이행을 회피하거나 약화한다.
- 특히 스큐 심한 컬럼에서 히스토그램/확장통계가 없으면
  잘못된 전이 조건이 비용 계산을 망칠 위험이 있다.

---

## 이행이 성능을 뒤집는 실전 시나리오

### 스타 스키마: 차원 조건만으로 사실 파티션을 줄이기

```sql
SELECT /*+ USE_HASH(d p s) LEADING(d p s) */
       SUM(s.amount)
FROM   d_date d
JOIN   f_sales s ON s.sales_dt = d.dt
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  d.yyyymm='202403'
AND    p.brand='B0';
```

**이행 체인**
- `d.yyyymm='202403'` ⇒ `s.sales_dt` 범위 이행 ⇒ 파티션 프루닝
- `p.brand='B0'` ⇒ `s.prod_id` 이행 ⇒ 블룸/인덱스 접근 강화

### OLTP NL 조인: 바깥 키로 안쪽 인덱스 1방

```sql
SELECT /*+ USE_NL(s) LEADING(c s) */
       s.*
FROM   d_customer c
JOIN   f_sales s
ON     s.cust_id = c.cust_id
WHERE  c.cust_id IN (:k1,:k2,:k3)
AND    s.sales_dt BETWEEN :d1 AND :d2;
```

- `c.cust_id IN (...)` ⇒ `s.cust_id IN (...)` access로 이행되면
  **키 3개에 대한 인덱스 프로브만 하고 끝**낸다.

### 사전집계 위치가 바뀌는 “연쇄 효과”

```sql
SELECT /*+ USE_HASH(d p s c) LEADING(d p s c) */
       c.cust_id, SUM(s.amount)
FROM   d_date d
JOIN   f_sales s ON s.sales_dt = d.dt
JOIN   d_product p ON p.prod_id = s.prod_id
JOIN   d_customer c ON c.cust_id = s.cust_id
WHERE  d.yyyymm='202403'
AND    p.brand='B0'
AND    c.region='KOR'
GROUP  BY c.cust_id;
```

- 이행 덕분에 s가 먼저 극단적으로 줄고
- 그 뒤의 집계/조인들이 **“줄어든 s”를 기준으로** 재배치된다.
- 결과적으로 해시/소트/그룹 비용이 눈에 띄게 감소한다.

---

## 진단 절차 — “이행이 일어났는지” 확인하는 루틴

### 실측 계획 + 프레디킷

```sql
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE +ALIAS'));
```

### 체크리스트

1. **Predicate Information**
   - 안쪽 테이블에 이행된 조건이 있는가?
   - access인지 filter인지?
2. **Partition Range**
   - 프루닝이 걸려 필요한 파티션만 읽는가?
3. **JOIN FILTER**
   - 해시 조인에서 `CREATE/USE`가 보이는가?
4. **E-Rows vs A-Rows**
   - 이행 후 카디널리티 추정이 더 정확해졌는가?
5. **세션 통계**
   - logical reads / physical reads가 확 꺾였는가?

---

## 실전 작성·설계 팁

### 작성 습관

- **SARGABLE**
  - 컬럼은 좌측
  - 상수·바인드는 우측
  - 컬럼 가공 금지
- **순수 등치 조인**
  - 함수/형변환 없는 `A.col = B.col`
- **바인드 타입 일치**
  - 숫자는 숫자, 날짜는 날짜
- **범위는 `>= AND <` 형태**
  - 파티션/인덱스 인식 최상

### 힌트로 돕는 방식(최소개입)

- **먼저 줄이기**
  - `UNNEST`, `PUSH_PRED`, `PUSH_SUBQ`
- **머지로 전이 경로를 열기**
  - `MERGE(@qb)` / 방어는 `NO_MERGE(@qb)`
- **조인 전략 고정**
  - `LEADING`, `USE_NL`, `USE_HASH`
- **변환 전체를 막는 힌트는 마지막 수단**
  - `NO_QUERY_TRANSFORMATION`은 QB 단위로만

### 물리 설계

- **이행될 가능성이 높은 컬럼을 선두열로**
  - 예: `(cust_id, sales_dt)`
- **파티션 키는 이행이 잘 되는 컬럼으로**
  - 날짜가 이상적
- **불가피한 함수는 가상컬럼/함수기반 인덱스**
  - 전이·푸시를 회복하는 수단

---

## 요약 체크리스트

- [ ] 등치 조인 + 한쪽 상수/범위가 **반대쪽 access predicate로 이행**되었는가?
- [ ] 차원 필터가 사실의 **파티션 프루닝**을 만들었는가?
- [ ] OR/함수/형변환/외부조인 때문에 의미가 깨지지 않는가?
- [ ] 통계(히스토그램/확장통계)가 이행 비용 판단을 뒷받침하는가?
- [ ] 실측 플랜에서 `access`, `partition pruning`, `join filter`가 보이는가?

---

## 결론

조건절 이행은 오라클 최적화의 “기초 체인”이다.
**이행이 된다는 것은 단순히 조건이 하나 더 생기는 일이 아니라,
인덱스·파티션·조인 순서·조인 방식·집계 위치까지 연쇄적으로 바뀌는 사건**이다.

그래서 튜닝의 정석은 늘 같다.

1) **SARGABLE + 순수 등치 조인으로 이행 경로를 열고**
2) **이행된 조건이 access로 내려가게 만들고**
3) **실측 플랜/통계로 “진짜 줄었는지” 확인한다.**

이 세 가지만 지켜도, 대부분의 실무 쿼리에서
**I/O, 조인 비용, 응답 시간**이 눈에 띄게 개선된다.
