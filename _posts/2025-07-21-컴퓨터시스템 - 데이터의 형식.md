---
layout: post
title: 컴퓨터시스템 - 데이터의 형식
date: 2025-07-21 20:20:23 +0900
category: 컴퓨터시스템
---
# 데이터의 형식 (Data Representations)

## 개요 — “같은 비트, 다른 의미”

컴퓨터는 **비트열(bit string)**만 저장/전송한다. 의미는 **해석 규칙**(정수 규약, IEEE 754, 문자 인코딩, 엔디안, 정렬/패딩, ABI 등)이 부여될 때 생긴다.
이 문서는 다음 순서로 설명한다.

1. 비트·바이트·워드·정렬/패딩
2. 정수 표현(무부호/2의 보수)·오버플로·시프트
3. 형 변환/승격/서명-무부호 혼합 규칙
4. 비트 수준 연산·마스크·플래그
5. 엔디안(리틀/빅)과 직렬화
6. 부동소수점(IEEE 754) — 형식/반올림/특수값/오차
7. 고정소수점(Q 형식) — 실수의 정수화
8. 문자 인코딩(ASCII/UTF-8/UTF-16) — 코드포인트 vs 그래프
9. 포인터/주소 — 숫자 같지만 의미가 다른 값
10. 구조체 레이아웃 — 정렬/패딩/비트필드/별칭
11. 안전한 재해석과 직렬화 실무 패턴
12. 체크리스트/연습문제

---

## 비트·바이트·워드·정렬

- **비트(bit)**: 0/1
- **바이트(byte)**: 8비트(대부분의 최소 주소 단위)
- **워드(word)**: ISA 기본 연산 폭(예: 32비트/64비트)

### 범위와 조합 수

$$
\text{n비트가 표현 가능한 값의 수} = 2^n
$$

예) 8비트 → 256개, 64비트 무부호 → \(0..2^{64}-1\)

### 정렬(alignment)과 패딩(padding)

타입의 **자연 경계**(예: 4바이트 정수는 4의 배수 주소)로 정렬되면 접근이 빠르고 단순해진다.
구조체는 멤버 사이/끝에 **패딩**을 삽입해 전체 정렬을 맞춘다.

```c
#include <stdio.h>
#include <stdint.h>

struct A {   // 비효율적 배치 (패딩多)
    uint8_t  a;   // 1B
    uint32_t b;   // 4B (앞에 3B 패딩)
    uint16_t c;   // 2B
};               // 전체 크기: 보통 12B

struct B {   // 재배치로 패딩↓
    uint32_t b;   // 4B
    uint16_t c;   // 2B
    uint8_t  a;   // 1B (끝 패딩)
};               // 전체 크기: 보통 8B

int main(){
    printf("A=%zu, B=%zu\n", sizeof(struct A), sizeof(struct B));
}
```

---

## 정수(integer)의 표현 — 무부호·2의 보수

### 무부호(unsigned)

$$
\text{Value} = \sum_{i=0}^{w-1} b_i 2^i \quad\Rightarrow\quad [0, 2^w-1]
$$

예) 8비트: 0..255

### 2의 보수(two’s complement, 서명 정수)

$$
\text{Value} = -b_{w-1} 2^{w-1} + \sum_{i=0}^{w-2} b_i 2^i
\quad\Rightarrow\quad [-2^{w-1}, 2^{w-1}-1]
$$

- 음수 생성: **비트 반전 + 1**
- 장점: **덧셈/뺄셈 회로를 그대로** 사용 가능, 0은 유일

```c
#include <stdio.h>

int main(){
    signed char x = -1;     // 0xFF
    printf("%d\n", x);      // -1
    printf("%x\n", x & 0xFF); // ff (저장 바이트 관찰)
}
```

### 오버플로(모듈러 산술)와 UB

- **무부호**: 연산은 **모듈러 \(2^w\)** (래핑 정의됨)
- **서명 정수(C/C++)**: 오버플로는 **정의되지 않음(UB)** → 체크드/포화/래핑 전략 명시 필요

---

## 시프트와 비트 연산 — 마스크/플래그 기초

### 연산자

| 연산자 | 의미 |
|---|---|
| `&` | AND |
| `|` | OR |
| `^` | XOR |
| `~` | NOT |
| `<<` | 좌시프트 |
| `>>` | 우시프트(논리/산술 구분 주의) |

- **부호 있는 우시프트**는 구현정의(대부분 산술).
- **좌시프트로 범위를 넘치게** 하면 서명형에서는 UB.

```c
unsigned char a=0xF0, b=0x0F;
unsigned char c=a|b; // 0xFF
```

---

## 형 변환과 승격 — “계산은 넓게, 저장할 때 잘림”

### 일반 승격(usual integer promotions)

- `char`, `short` 등 **작은 정수형**은 계산 전에 **int**(또는 unsigned int)로 승격
- 따라서 `uint8_t` 덧셈은 실제로 **int 폭**에서 수행 → 저장 시 **잘림**

```c
#include <stdint.h>
#include <stdio.h>

int main(){
    uint8_t a=200, b=100;
    uint8_t c=a+b;      // 300을 int로 계산 후 8비트 저장 → 44
    printf("%u\n", c);  // 44
}
```

### 서명/무부호 혼합 주의

피연산자 중 **무부호의 랭크가 더 높으면**, 서명 피연산자가 **무부호로 변환**된다.

```c
#include <stdio.h>

int main(){
    printf("%s\n", (-1 < 1u) ? "true":"false"); // 보통 false (좌변이 거대한 무부호로 변환)
}
```

### 부호 확장/0 확장

- **서명 → 더 큰 서명**: **부호 확장(sign extension)**
- **무부호 → 더 큰 무부호**: **0 확장(zero extension)**

```c
char  x = -10;     // 0xF6
short y = x;       // 0xFFF6 (부호 확장), 값은 -10 유지
```

---

## — 바이트 순서

- **리틀 엔디안**: 하위 바이트가 낮은 주소 (x86/x64)
- **빅 엔디안**: 상위 바이트가 낮은 주소 (네트워크 바이트 순서)

예) 32비트 값 `0x12345678` 저장

| 주소→ | +0 | +1 | +2 | +3 |
|---|---:|---:|---:|---:|
| 리틀 | 78 | 56 | 34 | 12 |
| 빅   | 12 | 34 | 56 | 78 |

```c
#include <stdint.h>
#include <stdio.h>

static int is_little(){
    uint16_t x=0x0102;
    return *(uint8_t*)&x==0x02;
}
int main(){ printf("%s\n", is_little()?"LE":"BE"); }
```

**직렬화**(파일/네트워크)에서는 **바이트 순서 명시**가 필수다.

---

## — 형식/반올림/특수값/오차

### 값의 정의

정규화 수(normalized):

$$
x = (-1)^s \cdot (1.f)_2 \cdot 2^{(E-\text{bias})}
$$

서브노멀(subnormal):

$$
x = (-1)^s \cdot (0.f)_2 \cdot 2^{(1-\text{bias})}
$$

- **binary32(float)**: \(s:1, E:8(\text{bias}=127), f:23\)
- **binary64(double)**: \(s:1, E:11(\text{bias}=1023), f:52\)

### 특수값

- `E=all1, f=0` → `±∞`
- `E=all1, f≠0` → `NaN`(qNaN/sNaN)
- `+0.0`/`-0.0` 구분(부호비트만 다름)

### 반올림 모드(요지)

- **최근접-짝수**(기본), **0쪽 절단**, **+∞/−∞ 쪽** 등
- 연산은 일반적으로 **비결합적**: \((a+b)+c \ne a+(b+c)\)

### 왜 0.1이 정확히 저장되지 않는가

0.1은 2진 분모가 아닌 **무한 이진 소수** → 유한 비트로 근사.

```c
#include <stdio.h>

int main(){
    float f = 0.1f;
    printf("%.20f\n", f);  // 0.10000000149011611938 등 근사치 출력
}
```

### 비트 관찰(안전한 재해석)

```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>

typedef union { float f; uint32_t u; } U; // 일부 구현에서 별칭 경고 가능
int main(){
    U x; x.f=1.0f;
    printf("1.0f bits = 0x%08X\n", x.u); // 보통 0x3F800000
}
```

별칭 규칙을 엄격히 지키려면 `memcpy`를 사용:

```c
uint32_t u;
float f=1.0f;
memcpy(&u, &f, sizeof u);
```

---

## — 실수 연산을 정수로

Q\(m.n\): 저장값 \(X\)의 실제값은 \(X/2^n\).

$$
\text{Real} = \frac{X}{2^n},\quad (a\cdot b)_{\text{real}} = \frac{(A\cdot B)}{2^n}
$$

```c
#include <stdint.h>

static inline int16_t q15_mul(int16_t a, int16_t b){
    int32_t t = (int32_t)a*b;  // 32비트 중간
    t += 1<<14;                // 반올림
    t >>= 15;                  // 스케일 복원
    if(t> 32767) t= 32767;     // 포화
    if(t<-32768) t=-32768;
    return (int16_t)t;
}
```

- 장점: 빠르고 결정적(플랫폼 일관성)
- 단점: 범위/정밀도 설계 필요

---

## 문자 인코딩 — ASCII/UTF-8/UTF-16

### ASCII

- 7비트(128문자), 영문/제어 문자
- 확장 ASCII(8비트)는 코드페이지마다 해석 상이

### UTF-8(가변 길이)

| 코드포인트 범위 | 바이트 수 | 패턴(2진) |
|---|---:|---|
| U+0000..007F | 1 | 0xxxxxxx |
| U+0080..07FF | 2 | 110xxxxx 10xxxxxx |
| U+0800..FFFF | 3 | 1110xxxx 10xxxxxx 10xxxxxx |
| U+10000..10FFFF | 4 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

- **ASCII 호환**, 웹 표준
- **문자 길이 ≠ 바이트 길이**, 결합 문자/그래프 클러스터 주의

```python
s = "A가á"          # 'a' + 결합 악센트
print(len(s))        # 코드포인트 수
print(len(s.encode("utf-8")))  # 바이트 수
```

### UTF-16

- 2바이트 단위, 보조평면은 **서러게이트 페어**
- **엔디안/BOM** 주의

---

## 포인터와 주소 — “숫자지만 덧셈과 같다곤 못 한다”

- 포인터는 **메모리 주소**
- 크기: 32비트 환경 4바이트, 64비트 환경 8바이트(ABI 의존)

```c
#include <stdint.h>
#include <stdio.h>

int x=10;
int* p=&x;
printf("addr=%p\n", (void*)p);
```

- 포인터 산술은 **타입 크기**를 따른다: `p+1`은 바이트 +1이 아니다(예: `int`면 +4/8).
- 포인터를 정수로 캐스팅해 임의 연산하는 행위는 의미론/정렬/UB 위험.

---

## 구조체·비트필드·별칭 — 메모리 레이아웃의 함정

### 구조체 패딩/정렬

- 멤버 순서에 따라 **패딩**이 달라진다(§1.2 예시).
- 패킹 지시문(`#pragma pack`) 남용은 이식성 저해 → **직렬화는 수동 팩킹 권장**.

### 비트필드

```c
struct flags {
    unsigned int a:3;
    unsigned int b:5;
};
```

- 컴파일러/ABI마다 **배치/엔디안/채움 규칙이 다를 수 있어 이식성 낮음**.
- 파일/네트워크 포맷에는 **명시적 마스크/시프트** 사용 권장.

### 별칭(aliasing)과 타입 퍼닝

- C의 **엄격 별칭 규칙(strict aliasing)**: 다른 타입 포인터로 같은 메모리를 읽거나 쓰면 UB(예외: `char*`).
- 재해석은 **`memcpy`** 또는 표준이 허용한 메커니즘 사용.

---

## 안전한 직렬화/재해석 패턴

### 명시적 바이트순서·폭·무결성

- 포맷 문서에 **엔디안, 필드 폭, 정렬/패딩 없음, 버전, 체크섬/CRC** 명시
- 예) 32비트 빅엔디안 정수 3개 + CRC

```c
#include <stdint.h>

void put32be(uint8_t* o, uint32_t x){ o[0]=x>>24; o[1]=x>>16; o[2]=x>>8; o[3]=x; }
uint32_t get32be(const uint8_t* o){ return (o[0]<<24)|(o[1]<<16)|(o[2]<<8)|o[3]; }
```

### 파이썬 `struct` 예시

```python
import struct, binascii
hdr = struct.pack(">III", 0x12345678, 0xABCDEF01, 4096)  # >: big-endian
crc = binascii.crc32(hdr) & 0xffffffff
print(hdr.hex(), hex(crc))
```

---

## 실험: 같은 4바이트, 다른 해석

### `0x3F800000`의 다중 해석

| 해석 | 의미 |
|---|---|
| float | 1.0 |
| unsigned 32-bit | 1060110336 |
| 문자 4개 | `?` `\x80` `\x00` `\x00` (의미 없음) |

```python
import struct
raw = bytes.fromhex("3F800000")
print(struct.unpack(">f", raw)[0], struct.unpack(">I", raw)[0])
```

---

## 요약 표

### 정수 범위(대표)

| 폭 | unsigned | two’s complement |
|---:|---:|---:|
| 8  | 0..255 | −128..127 |
| 16 | 0..65535 | −32768..32767 |
| 32 | 0..\(2^{32}-1\) | −\(2^{31}\)..\(2^{31}-1\) |
| 64 | 0..\(2^{64}-1\) | −\(2^{63}\)..\(2^{63}-1\) |

### IEEE 754 배치

```
binary32: s eeeeeeee fffffffffffffffffffffff
binary64: s eeeeeeeeeee f....................................................
```

값:
$$
(-1)^s \times
\begin{cases}
(1.f)_2 \cdot 2^{E-\text{bias}}, & 0<E<\text{all1} \\
(0.f)_2 \cdot 2^{1-\text{bias}}, & E=0\ (\text{subnormal})\\
\infty/\text{NaN}, & E=\text{all1}
\end{cases}
$$

### UTF-8 요약

| 범위 | 바이트 | 패턴 |
|---|---:|---|
| U+0000..007F | 1 | 0xxxxxxx |
| U+0080..07FF | 2 | 110xxxxx 10xxxxxx |
| U+0800..FFFF | 3 | 1110xxxx 10xxxxxx 10xxxxxx |
| U+10000..10FFFF | 4 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

---

## 체크리스트 — 버그를 막는 10가지 습관

1. **엔디안/폭/정렬/패딩**을 포맷 문서에 명시한다.
2. 서명 정수 **오버플로를 가정한 로직**을 작성하지 않는다(C/C++ UB).
3. **체크드/포화/래핑** 정책을 상황에 맞게 명시하고 테스트한다.
4. **서명-무부호 혼합 비교**를 피한다(필요 시 명시적 캐스트).
5. 문자열은 **UTF-8**을 기본으로 하고, “문자 길이 ≠ 바이트 길이”를 전제한다.
6. 비트필드는 **파일 포맷에 사용하지 않는다**. 마스크/시프트를 쓴다.
7. 포인터 재해석은 **`memcpy`**로 한다(별칭 규칙 준수).
8. 부동 비교는 **허용 오차/ULP** 기반으로 한다.
9. 구조체의 외부 노출은 **명시적 직렬화**로 대체한다.
10. **헥스덤프/비트 출력 유틸**로 실제 바이트를 관찰한다.

---

## 연습 문제

1) 16비트 2의 보수에서 `1000 0000 0000 0000₂`의 값은 무엇인가?
2) 8비트 무부호에서 `250 + 100`의 결과와 이유(계산/저장)를 설명하라.
3) `0x12345678`을 리틀/빅 엔디안 메모리에서 바이트 순서로 나열하라.
4) IEEE 754 binary32에서 `s=0, E=127, f=0`의 실수 값은?
5) UTF-8에서 U+AC00(“가”)의 바이트열을 써라.
6) C에서 `-1 < 1u`가 거짓인 이유를 변환 규칙 관점에서 한 문장으로 설명하라.

---

## 부록: 검증용 코드 모음

```c
// A) 비트/엔디안/부동 비트패턴 시각화
#include <stdint.h>
#include <stdio.h>
#include <string.h>

static void bits32(uint32_t u){
    for(int i=31;i>=0;i--) putchar((u>>i)&1?'1':'0');
}

int main(){
    uint32_t u = 0x3F800000u; // 1.0f
    float f; memcpy(&f, &u, sizeof f);
    printf("u=0x%08X, f=%.8f\n", u, f);
    bits32(u); puts("");
    return 0;
}
```

```python
# 같은 바이트, 다른 해석

import struct, binascii
raw = bytes.fromhex("3F800000")
print("float:", struct.unpack(">f", raw)[0])
print("uint32:", struct.unpack(">I", raw)[0])
print("crc32:", hex(binascii.crc32(raw)&0xffffffff))
```

---

## 결론 — “표시는 계약이고, 계약은 코드와 문서로 남긴다”

같은 비트열도 **해석 규약**이 바뀌면 **의미**가 달라진다.
정수/부동/문자/포인터/구조체 각각의 규약을 **명시하고 검증**하면,
이식성과 신뢰성을 동시에 얻을 수 있다.
데이터 표현은 성능 이전에 **정확성의 토대**다. 정확성을 지키는 습관이 곧 성능과 안정성을 부른다.
