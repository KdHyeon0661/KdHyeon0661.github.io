---
layout: post
title: CSS - CSS 선언 방식
date: 2025-03-06 21:20:23 +0900
category: CSS
---
# CSS 선언 방식 (Inline, Internal, External)

## 0. 개요 — 왜 “선언 방식”이 중요한가

같은 CSS라도 **어디에, 어떻게 선언했는지**에 따라 다음이 달라집니다.

- **캐스캐이딩/특이성/우선순위**: 충돌 시 어떤 규칙이 적용되는지
- **성능**: 초기 렌더(First Paint/Contentful Paint), CSS 차단/비차단
- **보안**: CSP(Content Security Policy) 하에서 허용/차단
- **유지보수/확장성**: 스타일 재사용과 모듈화, 코드 리뷰/버전 관리
- **배포 전략**: 캐시, 해시 파일(예: `style.9f3c.css`), HTTP/2/3 병렬 전송

세 가지 방식(Inline, Internal, External)을 **정의 → 사용 예시 → 실전 시나리오 → 장단점/대안** 순으로 설명합니다.

---

## 1. Inline Style (인라인 스타일)

HTML 요소에 직접 `style` 속성을 적는 방식.

### 1.1 기본 예시
```html
<p style="color: red; font-size: 18px;">이 문장은 빨간색입니다.</p>
```

### 1.2 특징 정리
- **적용 범위**: 해당 **요소 하나**
- **우선순위**: 일반 규칙보다 **강함**(동일 특이성일 때, 인라인이 이김). 단, `!important`는 별도.
- **장점**: 아주 **빠른 테스트**, 실험적 A/B 테스트, 이메일 템플릿 호환
- **단점**: **재사용 불가**, **유지보수 어려움**, **스타일 정의가 구조를 오염**
  보안 측면에서 CSP의 `unsafe-inline`을 요구할 수 있어 **권장되지 않음**.

### 1.3 실전 시나리오
- **이메일 템플릿**: 많은 메일 클라이언트가 `<style>` 지원이 제한적 → 인라인이 안전
- **긴급 패치/운영 배너**: 서버 템플릿에서 특정 문구 색/간격을 급히 변경
- **AB 테스트 도구**: 실험군에서 요소 하나만 빠르게 스타일 주입

### 1.4 안티패턴 → 대안
- ❌ 동일 스타일을 수십 개 요소에 인라인로 반복
  → ✅ **클래스 + External** 로 추출
- ❌ JS로 `.style.xxx=`를 남발
  → ✅ “상태 클래스 토글”로 전환(`element.classList.add('is-open')` 등)

### 1.5 CSP(보안) 고려
- 많은 조직은 `Content-Security-Policy: style-src 'self';`처럼 **인라인 금지**
- 인라인을 쓸 수밖에 없다면 **`style` 태그에 nonce/hash**를 부여하는 쪽을 고려(그러나 요소 `style=""`은 여전히 제약적)

---

## 2. Internal Style (내부 스타일 시트)

문서의 `<head>` 안 `<style>`에 작성.

### 2.1 기본 예시
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>내부 스타일</title>
  <style>
    h1 { color: blue; }
    p  { font-size: 16px; }
  </style>
</head>
<body>
  <h1>내부 스타일 적용</h1>
  <p>이 문장은 16px로 표시됩니다.</p>
</body>
</html>
```

### 2.2 특징 정리
- **적용 범위**: **해당 HTML 문서 전체**
- **장점**: **한 문서** 내에서 빠르게 공통 스타일 적용, 외부 의존 없이 단일 파일로 배포 가능
- **단점**: 문서 수가 늘면 **중복/일관성 붕괴**. CSS가 커지면 HTML도 비대해져 **전송량 증가**,
  캐시 이점(파일 레벨 캐시)이 **부재**.

### 2.3 실전 시나리오
- **단일 페이지 실습/데모**: 외부 파일 없이 즉시 공유
- **SSR/템플릿 엔진**에서 **Critical CSS**만 **인라인 `<style>`**로 삽입하고, 나머지는 외부 CSS로 분리(아래 4장 참조)

### 2.4 CSP/빌드 연계
- `<style>`은 CSP에서 **nonce/hash**로 허용 가능.
- 빌드시 `critical.css`를 생성해 템플릿에 **부분 인라인** 후, 나머지는 chunk로 로드

---

## 3. External Style (외부 스타일 시트)

별도의 `.css` 파일을 `<link>`로 불러옴.

### 3.1 기본 예시

```liquid
{% highlight html %}
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>외부 스타일</title>
  <link rel="stylesheet" href="/assets/style.css" />
</head>
<body>
  <h1>외부 스타일 적용</h1>
</body>
</html>
{% endhighlight %}
```

```css
/* /assets/style.css */
h1 {
  color: green;
  font-weight: bold;
}
```

### 3.2 특징 정리
- **적용 범위**: 여러 문서에 **공유**
- **장점(실무 표준)**:
  - **모듈화/재사용/팀 협업**에 최적
  - **브라우저 캐시** 활용(페이지 간 재사용)
  - **빌드 파이프라인**(Minify/압축/해시/분할/HTTP2 Push/Preload)과 궁합
- **단점**: 초기엔 네트워크 요청이 필요(단, 캐시되면 이후 빠름)

### 3.3 고급 로딩 전략

- **Preload**: 렌더 차단 해소를 위해 우선 로딩

```liquid
{% highlight html %}
<link rel="preload" href="/assets/style.css" as="style" />
<link rel="stylesheet" href="/assets/style.css" />
{% endhighlight %}
```

- **미디어 속성 트릭**(레거시 비차단 로딩):

```liquid
{% highlight html %}
<link rel="preload" href="/assets/print.css" as="style" />
<link rel="stylesheet" href="/assets/print.css" media="print" onload="this.media='all'" />
<noscript><link rel="stylesheet" href="/assets/print.css" /></noscript>
{% endhighlight %}
```

- **파일 쪼개기**: 페이지/라우트 단위 CSS 분할, 사용 시점에 로드(Code splitting)

### 3.4 빌드/배포 고려
- **해시 파일명**: `style.9f3c.css`로 캐시 무효화 제어
- **SRI(Subresource Integrity)**:

```html
<link rel="stylesheet"
      href="https://cdn.example.com/style.css"
      integrity="sha384-ABC..."
      crossorigin="anonymous">
```

---

## 4. 혼합 전략(추천): Critical CSS + External

초기 렌더에 꼭 필요한 **Critical CSS**만 `<head>`의 `<style>`로 **인라인(Internal)** 하고, 나머지는 **External**로 분리.

### 4.1 예시(템플릿)

```liquid
{% highlight html %}
<head>
  <!-- Critical(Above-the-fold) -->
  <style>
    :root { --brand: #2563eb; }
    body { margin: 0; font-family: system-ui, sans-serif; }
    header.site { display: flex; gap: 1rem; align-items: center; padding: .75rem 1rem; }
    .logo { font-weight: 800; color: #111; }
  </style>

  <!-- 나머지 스타일 -->
  <link rel="preload" href="/assets/app.css" as="style">
  <link rel="stylesheet" href="/assets/app.css">
</head>
{% endhighlight %}
```

이렇게 하면:
- **최초 페인트**가 빨라짐
- 나머지 스타일은 **캐시 가능한 외부 파일**로 관리

---

## 5. 세 가지 방식 심화 비교

| 항목 | Inline | Internal | External |
|---|---|---|---|
| 작성 위치 | 요소 `style=""` | `<head><style>...</style>` | `<link rel="stylesheet" href="...">` |
| 적용 범위 | 요소 1개 | 해당 문서 전체 | 여러 문서 공유 |
| 우선순위(일반 규칙 대비) | 높음 | 보통 | 보통 |
| 재사용성 | 낮음 | 중간 | 높음 |
| 유지보수 | 어려움 | 문서 많아지면 복잡 | 쉬움(모듈/폴더링) |
| 성능 | 네트워크 없음(소량 시 OK) | HTML 비대(크면 렌더 지연) | 캐시/압축/분할 최적화 유리 |
| 보안(CSP) | 보통 금지(`unsafe-inline` 필요) | nonce/hash 허용 가능 | 안전 |
| 빌드/배포 | 불리 | 제한적 | 유리(해시, SRI, 분할) |
| 사용 사례 | 급한 핫픽스/이메일 | 데모/크리티컬 인라인 | 실무 기본 |

---

## 6. 우선순위/특이성/!important 상호작용

**대원칙**(동일 타깃 가정):
1. `!important`가 붙은 선언이 우선
2. 인라인(`style=""`) > ID > 클래스/속성/의사클래스 > 요소
3. 선언 **나중에 나온 규칙**이 이김

### 6.1 충돌 예시
```html
<h1 id="title" class="headline" style="color: gray;">제목</h1>
```

```css
/* external.css */
h1 { color: green; }              /* 요소 */
.headline { color: blue; }        /* 클래스 */
#title { color: purple; }         /* ID */
```

적용 결과: **인라인 `gray`**
만약 external에서 `#title { color: purple !important; }`면 → **`purple`**로 역전

---

## 7. 접근성/UX/테마 고려

- **포커스 표시**는 인라인/내부/외부 어디서든 **일관되게** 유지:
```css
:focus-visible { outline: 3px solid #0ea5e9; outline-offset: 2px; }
```
- **다크 모드**는 외부 CSS에서 변수 중심으로:
```css
:root { color-scheme: light dark; --bg: #fff; --fg: #111; }
@media (prefers-color-scheme: dark) {
  :root { --bg: #0b0b0b; --fg: #e6e6e6; }
}
body { background: var(--bg); color: var(--fg); }
```
- **모션 감소**:
```css
@media (prefers-reduced-motion: reduce) {
  * { animation-duration: .001ms !important; transition-duration: .001ms !important; }
}
```

---

## 8. 성능 최적화 팁

- **External**을 기본으로 하고, **Critical**만 Internal 인라인
- **Minify/압축/캐시** 활용, **HTTP/2/3** 병렬 전송
- 레거시 `@import` 체인을 피하고 `<link>` 사용(차단/연쇄 지연 방지)
- 레이아웃 변경은 가능하면 `transform/opacity`로(리플로우/리페인트 비용 감소)

---

## 9. 보안(CSP) 베스트 프랙티스

- 정책 예:
```http
Content-Security-Policy: default-src 'self'; style-src 'self' https://cdn.example.com; object-src 'none';
```
- **Inline 금지**가 일반적 → 인라인 필요 시 **nonce/hash** 사용 가능한 **Internal `<style>`**로 대체
- 서드파티 CSS는 **SRI**와 `crossorigin` 병행

---

## 10. 유지보수/폴더 구조(External 중심)

```
styles/
  ├─ base/          /* reset, html/body, 타이포그래피 */
  ├─ components/    /* 버튼, 카드, 모달, 폼 등 */
  ├─ layouts/       /* 헤더/푸터/사이드바, grid 템플릿 */
  ├─ pages/         /* 페이지 오버라이드 */
  ├─ utilities/     /* 헬퍼(여백, 텍스트, display 등) */
  └─ index.css      /* 진입점(@import or @layer) */
```

`@layer`로 충돌 최소화:
```css
@layer base, components, utilities;
```

---

## 11. 프레임워크/런타임에서의 “선언 방식” 해석

- **React/Vue/Svelte 등**의 CSS-in-JS, Scoped CSS, `<style scoped>`는 대부분 **런타임에 `<style>` 태그(Internal)** 로 삽입
- SSR+Hydration 환경: **Critical**은 템플릿 `<style>`로 출력, 나머지는 **External** chunk로 분할
- 대규모 앱은 **디자인 토큰(커스텀 프로퍼티)** + **컴포넌트 단위 External** 병행

---

## 12. 실제 상황별 레시피

### 12.1 소규모 단일 페이지(랜딩/데모)
- Internal만으로도 충분
- 단, 추후 확장 여지가 보이면 External로 분리

### 12.2 블로그/문서 사이트(여러 페이지)
- **External 기본** + 공통 컴포넌트화
- 홈/아티클 상단의 핵심 레이아웃만 **Critical 인라인**

### 12.3 사내 대시보드/포털(로그인/권한/위젯 다수)
- **External + 코드 스플리팅 + 라우트별 CSS**
- 긴급 핫픽스가 필요하면 일시적으로 Internal에서 오버라이드 후, 나중에 External로 회수(“빚 청산” 프로세스 유지)

---

## 13. “Inline → External” 리팩터링 예제

### 13.1 기존(Inline 남발)
```html
<button style="background:#2563eb;color:#fff;padding:.5rem 1rem;border-radius:.5rem;">
  저장
</button>
<button style="background:#2563eb;color:#fff;padding:.5rem 1rem;border-radius:.5rem;">
  다음
</button>
```

### 13.2 개선(클래스 + External)
```html
<button class="btn btn--primary">저장</button>
<button class="btn btn--primary">다음</button>
```

```css
/* external: components/button.css */
.btn { padding: .5rem 1rem; border-radius: .5rem; border: 0; cursor: pointer; }
.btn--primary { background: #2563eb; color: #fff; }
.btn--primary:hover { filter: brightness(1.05); }
```

효과: **중복 제거**, **재사용/일관성** 향상, **CSP 친화적**

---

## 14. 확장 예제 — 한 페이지에 세 선언 방식 모두 사용

요구: “처음 페인트는 빨라야 하고, 공통 스타일은 재사용, 특정 실험 문구는 임시 빨간색”

### 14.1 HTML 템플릿
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>혼합 전략 데모</title>

  <!-- 1) Critical Internal -->
  <style>
    :root { --brand: #2563eb; }
    body { margin:0; font-family: system-ui, sans-serif; }
    header.site {
      display: flex; align-items: center; gap: 1rem;
      padding: .75rem 1rem; border-bottom: 1px solid rgba(0,0,0,.06);
    }
    .logo { font-weight: 800; color: #111; }
  </style>

  <!-- 2) External(캐시/모듈화) -->
  <link rel="preload" href="/assets/app.css" as="style">
  <link rel="stylesheet" href="/assets/app.css">
</head>
<body>
  <header class="site">
    <a class="logo" href="/">MyBlog</a>
    <nav class="nav"><a href="/posts">Posts</a><a href="/tags">Tags</a></nav>
  </header>

  <main class="container">
    <h1>선언 방식 혼합 가이드</h1>
    <p>이 영역은 외부 CSS(app.css)의 타이포/그리드 규칙의 영향을 받습니다.</p>

    <!-- 3) Inline(임시 실험) -->
    <p style="color:red;">[실험] 특정 문구를 임시로 강조합니다.</p>
  </main>
</body>
</html>
```

### 14.2 `/assets/app.css`(발췌)
```css
.container { width: min(90vw, 72rem); margin-inline: auto; padding: 1.25rem; }
.nav { display: flex; gap: 1rem; align-items: center; }
h1 { font-size: clamp(1.5rem, 2.5vw, 2.25rem); margin: .5rem 0 1rem; }
p { line-height: 1.7; color: #111; }
```

**설명**:
- Critical 레이아웃/헤더는 Internal로 즉시 실행 → **빠른 페인트**
- 본문/타이포/레이아웃은 External로 **캐시/모듈화**
- Inline은 실험적 문구에만 **최소 범위**로 사용 → 이후 External로 회수

---

## 15. 프린트/대체 매체 & noscript

### 15.1 프린트
```css
@media print {
  .nav, footer { display: none !important; }
  article { color: black; }
  a[href^="http"]::after { content: " (" attr(href) ")"; font-size: .85em; }
}
```

### 15.2 스크립트 비활성 사용자
```html
<link rel="stylesheet" href="/assets/app.css">
<noscript><link rel="stylesheet" href="/assets/noscript.css"></noscript>
```

---

## 16. 체크리스트(요약)

- 기본 원칙: **External** 중심 + **Critical Internal** + **Inline 최소화**
- 충돌 시 규칙: `!important` > 인라인 > ID > 클래스 > 요소, **나중 규칙이 승**
- CSP/보안: Inline 지양, 필요 시 Internal `<style>`에 **nonce/hash**
- 성능: Preload/Minify/캐시/분할, `@import` 체인 지양, Critical만 인라인
- 유지보수: 폴더링/레이어링, 디자인 토큰(커스텀 프로퍼티), “핫픽스 후 회수” 프로세스

---

## 17. 결론

- **Inline**: “한 요소 즉시 수정”에는 유용하지만 **장기적으로 빚**
- **Internal**: **단일 문서/크리티컬 스타일**에 적합
- **External**: **실무 표준**. 성능/보안/유지보수/협업에 유리

프로덕션 블로그라면 **External을 기본**으로, 상단 레이아웃/폰트 프리로드 등만 **Internal Critical**로 다루고,
Inline은 **일시적 실험/비상 패치**에 한정한 뒤 **반드시 회수**하세요.
