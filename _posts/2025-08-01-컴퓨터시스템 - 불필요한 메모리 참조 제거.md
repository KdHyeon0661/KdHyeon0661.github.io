---
layout: post
title: 컴퓨터시스템 - 불필요한 메모리 참조 제거
date: 2025-08-01 19:20:23 +0900
category: 컴퓨터시스템
---
# 불필요한 메모리 참조 제거 — 원리, 패턴, C 예제, 주의점까지

CPU가 가장 비싼 일을 하는 순간을 꼽으라면? **메모리 접근**입니다. 레지스터 ↔ L1/L2/L3 ↔ DRAM으로 내려갈수록 레이턴시·대역폭 비용이 급증합니다. 그래서 **같은 값을 여러 번 메모리에서 읽거나, 곧 덮어쓸 값을 굳이 메모리에 쓸 필요가 없다면** 반드시 제거해야 합니다. 여기서는 *어떤 경우에 불필요한 메모리 참조가 생기는지*, *어떻게 없애는지*, *컴파일러가 막히는 이유(별칭, volatile, 함수 경계…)*, *실전 C 코드 before/after*, *도구와 체크리스트*까지 한 번에 정리합니다.

---

## 1) 왜 중요한가? (짧은 동기)
- **레지스터는 공짜, 메모리는 비싸다**: 같은 값을 레지스터에 보관하고 재사용하면 L1 miss/메모리 트래픽이 줄어듭니다.  
- **포트/버스 병목**: 현대 코어는 한 사이클에 허용 가능한 load/store 수가 제한됩니다. 불필요한 참조는 포트 대기·스톨을 만듭니다.  
- **캐시 오염/라인 경쟁**: 의미 없는 read/write도 캐시 라인을 데려오고 더럽힙니다.

---

## 2) 대표 패턴 — 언제 ‘불필요’가 생기는가?

### 2.1 같은 메모리 값을 반복해 읽음 (재사용하지 않음)
```c
// before: node->val을 두 번 메모리에서 읽게 만들 수 있음
sum += node->val;
prod *= node->val;

// after: 한 번만 읽고 레지스터(스칼라)로 보관
int v = node->val;
sum += v;
prod *= v;
```

### 2.2 바로 덮어쓸 변수/배열 원소에 먼저 쓰는 경우 (Dead Store)
```c
// before: x=0은 읽히기 전에 바로 x=src로 덮임 → 무의미한 store
x = 0; 
x = src;

// after
x = src;
```

### 2.3 루프 내부에서 불변 값을 매번 메모리로부터 로드
```c
// before
for (int i=0; i<n; ++i) a[i] *= cfg->scale;

// after
int s = cfg->scale;                // 한 번만 로드
for (int i=0; i<n; ++i) a[i] *= s;
```

### 2.4 store 직후 즉시 같은 주소를 다시 load (불필요한 재확인)
```c
// before
arr[i] = v;
t = arr[i];        // 필요 없다면 제거, 또는 바로 v 사용
use(t);

// after
arr[i] = v;
use(v);
```
> 주의: **다른 쓰레드/시그널/함수 콜**이 사이에 개입해 값을 바꿀 수 있다면 제거 불가(아래 §6).

### 2.5 함수 경계 때문에 컴파일러가 못 없애는 경우
```c
// before
extern int f(int* p);   // p가 가리키는 메모리를 바꿀 수 있다고 가정
int x = *p;
int y = f(p);           // f가 *p를 바꿨을 수 있음
int z = *p;             // 컴파일러는 x 재사용 대신 재로드 할 수 있음

// after(가능하면 설계 변경)
int x = *p; 
int y = f(/* p를 변경하지 않음을 보장하는 API */);
int z = x;              // f가 *p를 바꾸지 않는 계약이 있으면 재사용 가능
```

---

## 3) 실전 기법 (C 중심, before/after)

### 3.1 스칼라 치환 / 레지스터 캐싱 (Scalar Replacement of Aggregates)
배열/구조체의 자주 쓰는 필드를 **스칼라(로컬 변수)** 로 꺼내 반복 사용.

```c
// before
for (int i=0; i<n; ++i) {
    s += a[i].x * a[i].x + a[i].y * a[i].y;
}

// after
for (int i=0; i<n; ++i) {
    int x = a[i].x;      // 두 번 로드 대신 레지스터 재사용
    int y = a[i].y;
    s += x*x + y*y;
}
```

### 3.2 누적값은 메모리 말고 레지스터에 유지
```c
// before: 매 반복마다 C[i]를 읽고 쓰는 패턴
for (int i=0; i<n; ++i) {
    C[i] = C[i] + A[i]*B[i];
}

// after: 누적을 레지스터에, 끝에서 한 번 store
for (int i=0; i<n; ++i) {
    int acc = C[i];          // 1로드
    acc += A[i]*B[i];
    C[i] = acc;              // 1스토어 (로드-스토어 한 쌍으로 최소화)
}
```
> 더 나아가 행렬 곱처럼 **내부 루프 전체**를 하나의 레지스터 누적으로 유지하고 **루프가 끝난 뒤** 한 번만 store 하는 것이 왕도.

### 3.3 루프 불변 로드 호이스팅
```c
// before
for (int i=0; i<n; ++i)
    out[i] = in[i] * cfg->scale * table[3];

// after
int s = cfg->scale;
int t3 = table[3];
for (int i=0; i<n; ++i)
    out[i] = in[i] * s * t3;
```

### 3.4 불필요한 memset 제거 (Dead Store to whole object)
```c
// before: 어차피 전부 덮어쓸 버퍼를 먼저 0으로 만들 필요 없음
void fill(int *buf, size_t n) {
    memset(buf, 0, n*sizeof(int));
    for (size_t i=0; i<n; ++i) buf[i] = i;  // 전체 overwrite
}

// after
void fill(int *buf, size_t n) {
    for (size_t i=0; i<n; ++i) buf[i] = i;
}
```
> 반대 경우엔 **`calloc`**(커널/런타임 제로 페이지 활용)로 한 번만 초기화.

### 3.5 함수 호출이 방해될 때 — `restrict` / `const` / 속성으로 힌트
별칭 가능성(alias)과 부수효과 때문에 컴파일러는 보수적입니다.

```c
// before
void saxpy(int n, float *x, float *y, float a) {
    for (int i=0; i<n; ++i) y[i] += a * x[i];  // x,y alias 가능 → 매번 재로드
}

// after: 별칭 아님을 보장 → 레지스터 보관/벡터화 쉬움
void saxpy(int n, float *restrict x, float *restrict y, float a) {
    float aa = a;                      // 스칼라화
    for (int i=0; i<n; ++i) y[i] += aa * x[i];
}
```

추가 힌트(플랫폼 의존):
- **GCC/Clang**: 사이드 이펙트 없는 함수에 `__attribute__((pure))` / 인자만 사용하는 순수 함수는 `const` 속성 부여 → 호출 주위의 메모리 재로드 감소.  
- 인자로 받은 포인터가 **읽기 전용**이면 `const` 한정자를 적극 사용.

### 3.6 주소계산/인덱싱 최소화 (연산은 싸지만, 패턴 단순화로 최적화 유도)
```c
// before
for (int i=0; i<n; ++i) sum += a[i];

// after (포인터 워크 + 미소 이득 + 최적화 유도)
for (int *p=a, *e=a+n; p!=e; ++p) sum += *p;
```
> 인덱싱 자체는 메모리 참조를 늘리지 않지만, **단순한 패턴**은 컴파일러가 더 과감히 레지스터/벡터화를 적용하게 만듭니다.

### 3.7 크기·정렬 불일치로 인한 store→load 패널티 회피
- 같은 주소를 **다른 크기/정렬**로 store 후 load하면 *store-to-load forwarding*이 실패해 스톨이 생길 수 있습니다.  
- 가능하면 **같은 폭**(예: 둘 다 32비트)·**정렬**로 접근하세요.

---

## 4) 별칭(alias) 때문에 생기는 “의미 있는” 불필요 로드/스토어

컴파일러는 아래 상황이면 **재로드**해야 합니다(정당한 보수성):

```c
void g(int *a, int *b) {
    int t = *a;      // 로드
    *b = 7;          // a와 b가 같다면 *a가 바뀜
    int u = *a;      // 재로드(필요). alias 가능성이 있으면 t를 재사용 못 함
}
```

해결책:
- **타입별칭 규칙(Strict Aliasing)을 지킨 코드** 작성 (`-fstrict-aliasing` 기본 가정).  
- **`restrict`**로 “겹치지 않음”을 보장.  
- **API 재설계**: 변경 불가 영역과 변경 가능 영역을 분리(`const`/out-parameter 구분).

---

## 5) 함수 경계, 스레드, volatile — 제거하면 안 되는 때

불필요해 보이는 참조라도 **정당**할 수 있습니다. 다음은 제거 금지/주의:

1. **함수 호출 사이**  
   - 호출된 함수가 메모리를 바꿀 수 있으면(별칭 가능·글로벌 접근) 호출 전 로드한 값을 재사용 못 함.
   - 해결: 함수에 `pure/const` 속성, 또는 API 계약 문서화.

2. **멀티스레드**  
   - 다른 스레드가 값을 바꿀 수 있으면 로드를 캐시해두면 안 됩니다.  
   - 해결: C/C++ atomics/메모리 오더 규칙 준수. 단일 스레드 구간이라면 지역 복사.

3. **`volatile`**  
   - 메모리 맵 IO/하드웨어 레지스터: **항상 실제 메모리 접근**이 필요. 제거/재배치 금지.

4. **시그널, `setjmp/longjmp`**  
   - 비정상 제어 전이로 인해 중간 상태 관찰 가능 → 보수적으로 접근.

---

## 6) 컴파일러가 이미 잘 하는 것 vs 우리가 도와줘야 하는 것

- 잘하는 것: **DCE(Dead Code Elimination)**, **DSE(Dead Store Elimination)**, **CSE**(공통부분식 제거), **루프 불변 호이스팅**, **SRA(스칼라 대체)**.  
- 막히는 것: **별칭 불명확**, **외부/간접 효과**, **LTO 미사용으로 TU 경계 넘지 못함**, **보수적 빌드 플래그**.  
- 도와주기: `restrict`, `const`, `pure/const` 속성, **LTO(-flto)**, **PGO**, **헤더에 `static inline` 작은 함수**, **내부 심볼은 `static`**.

---

## 7) 마이크로 예제 — 어셈블리 관점의 차이

```c
// before
int f(int *p) {
    int s = *p;           // load [p]
    *p = s + 1;           // store [p]
    return *p;            // load [p]  ← 같은 사이클/파이프에서 재로드 유발
}

// after
int f_opt(int *p) {
    int s = *p;
    s = s + 1;
    *p = s;
    return s;             // 레지스터 반환 → 불필요 로드 제거
}
```

최적화 후에는 **마지막 load가 사라져** `mov`/`ldr` 한 번이 줄어듭니다.

---

## 8) 대용량 데이터 루프 — 메모리 참조 최소화 묶음

### 8.1 블로킹과 레지스터 누적
행렬-벡터/행렬-행렬에서 **내부 루프 누적(scalar) + 끝에 한 번 store**는 기본기.
```c
for (int i=0; i<N; ++i) {
    double acc = C[i];                     // 1 load
    for (int k=0; k<K; ++k) acc += A[i*K+k] * B[k];  // 레지스터 누적
    C[i] = acc;                             // 1 store
}
```

### 8.2 벡터화와 함께
- `restrict`/정렬(`aligned_alloc`)로 **연속성·별칭 없음** 보장 → 자동 벡터화 시 레지스터 유지가 잘 일어남.  
- 경계 처리는 **peeling**(앞뒤 몇 원소 분리)로 정렬을 맞춤.

---

## 9) 도구로 확인하기 — 정말 줄었나?

- **perf stat**: `instructions`, `cycles`, **`L1-dcache-loads`**, **`-misses`**, **`stores`**  
  - 불필요 참조 제거 후 `loads/stores`가 유의미하게 감소해야 합니다.
- **perf record/report**: 핫 루프 어셈블리에서 `mov/ldr/str` 패턴이 줄었는지 확인.  
- **Compiler Explorer**(godbolt): 최적화 전/후 소스의 어셈블리 차이를 즉시 확인.  
- **sanitizers**: 최적화 과정에서 **UB가 가려진 버그**가 없는지 ASan/UBSan로 점검.

---

## 10) 체크리스트 (바로 적용)

- [ ] 같은 메모리 값, **두 번 이상 읽고** 있지 않은가? 로컬 스칼라에 담자.  
- [ ] **읽히지 않을 값을 쓰는(dead store)** 코드가 없는가? (초기화/`memset` 재검토)  
- [ ] 루프 내부에서 **불변 로드**가 있는가? 밖으로 뺄 수 있는가?  
- [ ] **store 후 즉시 load** 같은 패턴이 있는가? 레지스터 값 재사용 가능?  
- [ ] 함수 호출 사이에 메모리가 바뀌지 않는다면, **API/속성으로 안정성**을 알려줬는가? (`restrict`, `const`, `pure`)  
- [ ] 멀티스레드/volatile/시그널 등으로 인해 **실제 접근이 필요**한가? (필요 시 그대로 둔다)  
- [ ] 빌드: `-O3 -march=native -flto` + (가능하면) **PGO** 사용?  
- [ ] 변경 후 **perf 카운터로 loads/stores/미스율**이 줄었는가?

---

## 11) 마무리

불필요한 메모리 참조 제거는 “마이크로 트릭”이 아니라 **확실한 성능 향상 원리**입니다.  
핵심은 두 가지:
1) **같은 값을 다시 메모리에서 읽지 말고 레지스터에 잡아두기.**  
2) **곧 덮을 값을 굳이 쓰지 않기.**
