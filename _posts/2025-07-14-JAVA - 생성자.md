---
layout: post
title: Java - 생성자
date: 2025-07-14 19:20:23 +0900
category: Java
---
# Java 생성자(Constructor)

## 생성자란?

- **객체 생성 시 자동 호출**되는 **특별 메서드**로, **클래스명과 동일**하며 **반환형이 없음**(`void`도 금지).
- 주 역할: **불변식(invariant) 확립**, **필드 초기화**, **유효성 검증**.

```java
class Dog {
    String name;
    Dog() { System.out.println("Dog 생성"); } // 기본 생성자
}
```

---

## 기본 생성자(Default)와 매개변수 생성자

### 기본 생성자 자동 삽입 규칙

- **어떤 생성자도 직접 선언하지 않으면** 컴파일러가 **매개변수 없는 생성자**를 추가.
- **하나라도 선언**하면 기본 생성자는 **자동으로 생성되지 않음** → 필요하면 명시 작성.

```java
class A { /* A() { } 자동 생성 */ }
class B {
    B(int x) { } // 사용자가 작성 → 기본 생성자 자동 생성 안 됨
    // B() { } 필요 시 직접 작성
}
```

### 매개변수 생성자

```java
class Person {
    final String name;
    final int age;
    Person(String name, int age) {
        this.name = java.util.Objects.requireNonNull(name);
        if (age < 0) throw new IllegalArgumentException("age");
        this.age = age;
    }
}
```

---

## 생성자 **오버로딩**과 **체이닝(this/super)**

### 오버로딩

- **이름 동일**, **매개변수 목록(타입/개수/순서)** 다르면 다중 정의 가능.
- **반환형 차이만**으로는 불가.

```java
class Rectangle {
    int w, h;
    Rectangle()         { this(1, 1); }     // 체이닝으로 중복 제거
    Rectangle(int size) { this(size, size); }
    Rectangle(int w, int h) { this.w = w; this.h = h; }
}
```

### `this(...)` 체이닝 규칙

- **반드시 첫 줄**에서만 호출 가능.
- 같은 클래스의 **다른 생성자** 호출 → **중복 초기화 제거**.

```java
class Student {
    final String name; final int grade;
    Student() { this("Unknown", 1); } // 첫 줄
    Student(String name, int grade) { this.name = name; this.grade = grade; }
}
```

### `super(...)` 호출

- **첫 줄**에서만 호출 가능, 생략 시 **암묵적 `super()`**.
- 부모에 **기본 생성자 없으면** 자식은 **명시적으로** 적절한 `super(args)`를 호출해야 함.

```java
class Parent { Parent(String msg){ System.out.println(msg); } }
class Child  extends Parent {
    Child() { super("from Child"); } // 명시 필요(부모에 기본 생성자 없음)
}
```

> **중요**: 같은 생성자에서 `this(...)`와 `super(...)`를 **동시에** 호출할 수 없음(둘 다 첫 줄 규칙).

---

## 초기화의 **정확한 실행 순서**

**`new Sub()` 호출 시** 실제 실행 순서(텍스트 순서 준수):

1. **상위 타입부터** 클래스 로딩된 상태에서 **`static` 필드/정적 블록** 1회 실행(이미 로딩되어 있으면 스킵).
2. **메모리 할당**, 모든 인스턴스 필드 **기본값(0/false/null)** 로 초기화.
3. **부모**로 올라가 동일 과정:
   - 부모의 **인스턴스 필드 초기화식 + 인스턴스 초기화 블록** 실행
   - **부모 생성자 본문** 실행
4. **자식**으로 내려와:
   - 자식의 **인스턴스 필드 초기화식 + 인스턴스 초기화 블록** 실행
   - **자식 생성자 본문** 실행

```java
class P {
    int a = initA();            // (3-부모 단계) 필드 초기화
    { System.out.println("P{}"); } // 인스턴스 초기화 블록
    P() { System.out.println("P()"); }
    int initA(){ System.out.println("init a"); return 1; }
}
class C extends P {
    int b = initB();            // (4-자식 단계)
    { System.out.println("C{}"); }
    C() { System.out.println("C()"); }
    int initB(){ System.out.println("init b"); return 2; }
}
public class Order {
    public static void main(String[] args){ new C(); }
}
/*
출력(대표):
init a
P{}
P()
init b
C{}
C()
*/
```

> **함정**: 생성자/초기화 중 **오버라이딩 가능한 메서드 호출 금지**.
> 자식 필드가 아직 초기화 전일 수 있어 **NPE/불변식 붕괴**가 발생.

---

## vs 생성자

| 구분 | 실행 시점 | 목적 |
|---|---|---|
| 인스턴스 초기화 블록 `{ ... }` | 각 인스턴스 생성 시, **필드 초기화식 후 → 생성자 전** | 모든 생성자에 공통 초기화 |
| 정적 초기화 블록 `static { ... }` | 클래스 로딩 시 **한 번** | 정적 리소스 준비/검증 |
| 생성자 | 인스턴스 생성 시, **부모 생성자 후** | 외부 입력 기반 초기화/검증/불변식 확립 |

> 생성자에 비해 **초기화 블록은 테스트/가독성** 측면에서 신중 사용. “모든 생성자 공통”이면 **private init 메서드**로 추출하는 방법도 대안.

---

## 접근 제어자와 생성자

- `public`/`protected`/(package-private)/`private` 모두 사용 가능.
- **유틸리티 클래스**는 **`private` 생성자**로 인스턴스화 금지.

```java
final class Utils {
    private Utils() { throw new AssertionError("no instances"); }
    public static int add(int a, int b){ return a+b; }
}
```

- **싱글톤**: `private` 생성자 + `static final` 인스턴스(또는 enum).

```java
class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    private Singleton() { }
    public static Singleton getInstance(){ return INSTANCE; }
}
```

---

## 예외와 자원 관리(생성자에서)

- 생성자에서 **체크/언체크 예외** 모두 던질 수 있음.
- **자원 할당 순서**와 **부분 실패**에 주의(실패 원자성):
  1) 필요한 자원 **미리 획득**하고,
  2) 중간 실패 시 **이미 획득한 자원 해제**.

```java
class ReaderHolder implements AutoCloseable {
    private final java.io.BufferedReader br;
    ReaderHolder(java.nio.file.Path p) throws java.io.IOException {
        br = java.nio.file.Files.newBufferedReader(p);
        // 추가 초기화/검증 중 예외 발생 가능
    }
    @Override public void close() throws java.io.IOException { br.close(); }
}
```

- **this 유출 금지**: 생성자에서 `this`를 다른 스레드나 콜백에 등록하지 말 것(공유 전 초기화 완료 보장 어려움).
  → 정적 팩토리 메서드에서 생성 후 등록/구독 처리.

---

## 불변 클래스와 **방어적 복사**

- **불변 필드(`final`)**는 **안전한 게시(safe publication)**에 유리(자바 메모리 모델).
- **가변 입력**은 **복사**하여 보관, 내부 노출 시에도 복사 반환.

```java
final class Period {
    private final java.util.Date start, end;
    Period(java.util.Date start, java.util.Date end) {
        this.start = new java.util.Date(start.getTime()); // 방어적 복사
        this.end   = new java.util.Date(end.getTime());
        if (this.start.after(this.end)) throw new IllegalArgumentException();
    }
    public java.util.Date getStart(){ return new java.util.Date(start.getTime()); }
    public java.util.Date getEnd()  { return new java.util.Date(end.getTime()); }
}
```

---

## 텔레스코핑 vs 빌더 vs 정적 팩토리

### 생성자

```java
class NutritionFacts {
    private final int servingSize;   // 필수
    private final int servings;      // 필수
    private final int calories;      // 선택
    private final int sodium;        // 선택
    NutritionFacts(int servingSize, int servings) { this(servingSize, servings, 0); }
    NutritionFacts(int servingSize, int servings, int calories) { this(servingSize, servings, calories, 0); }
    NutritionFacts(int servingSize, int servings, int calories, int sodium) { /*...*/ }
}
```
- 매개변수 많아지면 **가독성/실수 위험** 증가.

### 빌더 패턴

```java
class Nutrition {
    private final int a, b, c, d;
    private Nutrition(Builder b){ this.a=b.a; this.b=b.b; this.c=b.c; this.d=b.d; }
    static class Builder {
        private final int a, b; int c=0, d=0;
        Builder(int a, int b){ this.a=a; this.b=b; }
        Builder c(int v){ this.c=v; return this; }
        Builder d(int v){ this.d=v; return this; }
        Nutrition build(){ return new Nutrition(this); }
    }
}
// 사용: new Nutrition.Builder(1,2).c(10).d(20).build();
```

### 정적 팩토리 메서드

- `of`, `from`, `valueOf`, `getInstance` 등 명명.
- **캐싱/서브타입 반환/이름을 통한 의미 전달** 가능.

```java
record Point(int x, int y) {
    static Point of(int x, int y){ return new Point(x, y); }
}
```

---

## 상속과 생성자 — 실무 규칙

- 자식 생성자는 **항상** 어떤 형태로든 **부모 생성자를 먼저** 호출(`super(...)`).
- **초기화 순서**(부모 → 자식) 상, 부모 생성자에서 **오버라이딩 가능 메서드 호출 금지**.
- **가시성**: 다른 패키지 하위 클래스에서 `protected` 생성자 호출은 **상속 경유**로만 가능.

---

## 프레임워크/라이브러리와 생성자

- **JPA 엔티티**: `@Entity`는 **`public` 또는 `protected` 무인자 생성자** 필요(프록시/리플렉션용).
- **Jackson/직렬화**: 기본 생성자 또는 `@JsonCreator`/`@JsonProperty`로 매핑.
- **Lombok**: `@NoArgsConstructor`, `@AllArgsConstructor`, `@RequiredArgsConstructor`가 생성자 보일러플레이트를 줄여줌(빌드 환경/가독성 고려).

---

## 고급 토픽

### **레코드(Record)**의 생성자

- **정식 생성자(캐노니컬)** 자동 생성: `record User(String id, int age) { }`
- **컴팩트 생성자**로 **검증/정규화** 가능.

```java
record User(String id, int age) {
    public User { // 컴팩트 생성자: 필드명 그대로 매개변수
        id = id.strip();
        if (age < 0) throw new IllegalArgumentException();
    }
}
```

### **생성자 참조**(`ClassName::new`)와 배열 생성자 참조

```java
import java.util.function.*;
class Foo { Foo(){} Foo(int x){} }
Supplier<Foo> s = Foo::new;          // 무인자
IntFunction<Foo> f = Foo::new;       // int → Foo
IntFunction<int[]> arr = int[]::new; // 길이 → 배열
```

### varargs/`null`과 오버로딩 모호성

```java
class V {
    V(String s) { System.out.println("S"); }
    V(Object... o) { System.out.println("varargs"); }
}
new V("x");     // S
new V();        // varargs
// new V(null); // String vs Object... 모호할 수 있음 → new V((String) null) 로 의도 명시
```

---

## 실전 예제 모음

### “체이닝 + 검증 + 방어적 복사” 종합

```java
final class Report {
    private final String title;
    private final java.util.List<String> lines;

    Report(String title) { this(title, java.util.List.of()); }

    Report(String title, java.util.List<String> lines) {
        this.title = java.util.Objects.requireNonNull(title).strip();
        if (this.title.isEmpty()) throw new IllegalArgumentException("title");
        // 방어적 복사(불변 리스트로 래핑)
        this.lines = java.util.List.copyOf(lines);
    }

    java.util.List<String> lines() { return lines; } // 이미 불변
}
```

### “오버로딩 의사 기본값” 패턴

```java
class Client {
    final int timeoutMs;
    final boolean keepAlive;
    Client() { this(3000); }
    Client(int timeoutMs) { this(timeoutMs, true); }
    Client(int timeoutMs, boolean keepAlive) {
        this.timeoutMs = timeoutMs; this.keepAlive = keepAlive;
    }
}
```

### “this 유출” 방지 — 정적 팩토리로 구독 등록

```java
interface Listener { void onReady(); }
class EventBus { void register(Listener l){ /* ... */ } }

class SafeComponent implements Listener {
    private SafeComponent() { /* 무거운 초기화 */ }
    public static SafeComponent create(EventBus bus) {
        SafeComponent sc = new SafeComponent();
        bus.register(sc); // 생성 완성 후 등록
        return sc;
    }
    @Override public void onReady(){ /* ... */ }
}
```

---

## 표로 보는 핵심 규칙

### 호출/체이닝 규칙

| 항목 | 규칙 |
|---|---|
| `this(...)` | 같은 클래스 다른 생성자 호출, **첫 줄** 전용 |
| `super(...)` | 부모 생성자 호출, **첫 줄** 전용 |
| 병행 금지 | 한 생성자에서 `this(...)`와 `super(...)` **동시 사용 불가** |
| 기본 호출 | 둘 다 생략 시 **암묵적 `super()`** |

### 초기화 순서(요약)

1) `static`(상위→하위, 1회) → 2) 인스턴스 기본값 →
3) **부모**(필드/블록 → 생성자) → 4) **자식**(필드/블록 → 생성자)

### 오버로딩 모호성 해소

| 상황 | 해법 |
|---|---|
| `null` 인수로 다수 후보 | **캐스트**로 의도 명시 |
| `varargs`가 끌어가는 문제 | **정확한 시그니처** 추가 or **빌더/정적 팩토리**로 대체 |

---

## 체크리스트

- [ ] **불변식 확립**: 생성자에서 **검증/정규화**를 마칠 것
- [ ] **중복 초기화 제거**: `this(...)` 체이닝 활용
- [ ] **초기화 순서 숙지**: 부모→자식, 필드/블록→본체
- [ ] **오버라이딩 호출 금지**: 생성자/필드 초기화 중 `override` 메서드 금지
- [ ] **자원/예외**: 실패 원자성·해제 보장, `AutoCloseable` 고려
- [ ] **방어적 복사**: 가변 입력/출력 모두
- [ ] **API 설계**: 텔레스코핑 지양, **빌더/정적 팩토리** 고려
- [ ] **프레임워크 요구**: JPA 무인자 생성자, 직렬화/역직렬화 정책 확인
- [ ] **this 유출 금지**: 완전 초기화 전 외부에 공개하지 말 것

---

## 요약

| 항목 | 핵심 |
|---|---|
| 정의/특징 | 클래스명 동일, 반환형 없음, 객체 초기 상태 확립 |
| 오버로딩 | 매개변수 목록으로 구분, 반환형만 다르면 불가 |
| 체이닝 | `this(...)`/`super(...)`는 각각 **첫 줄** 전용, 상호 배타 |
| 초기화 순서 | 부모 필드/블록 → 부모 생성자 → 자식 필드/블록 → 자식 생성자 |
| 안전성 | 오버라이딩 호출 금지, 자원/예외 처리, 방어적 복사 |
| 설계 | 텔레스코핑 지양, 빌더/정적 팩토리/레코드 활용 |

> 결론: 생성자는 **불변식과 계약을 확립하는 지점**이다.
> **정확한 초기화 순서/체이닝 규칙**을 지키고, **검증·방어적 복사·자원 처리**를 습관화하면, 견고하고 유지보수 쉬운 클래스를 설계할 수 있다.
