---
layout: post
title: 네트워크보안 - 모바일·5G 코어
date: 2025-10-31 18:25:23 +0900
category: 네트워크보안
---
# 23. 모바일·5G 코어

> 목표  
> - **4G(EP Core) / 5G(5GC)** 아키텍처를 한 장의 지도로 정리하고, **시그널링 위협**(Attach/Registration, Session Setup, Paging, Roaming 등)을 이해한다.
> - **네트워크 슬라이싱**의 보안 포인트(격리·정책·가시성·키 관리·SEPP 경계)를 체계화한다.  
> - **캐리어급 방어 전략**(GTP/NGAP/HTTP2-SBI 방화벽, SEPP, Rate Limit, PFCP/UPF 보안, Roaming 보안)을 설계론과 운영 체크리스트로 제시한다.
> - **실습**에서는 가벼운 **시뮬레이터/샘플 PCAP/로그**를 이용해 **시그널링 이상 탐지 파이프라인**(tshark/Zeek → 파이썬 집계 → 규칙/통계 결합)을 구현한다.

---

## 23.1 4G/5G 아키텍처·시그널링 위협

### 23.1.1 큰 그림: 4G EPC vs 5G Core

```
[UE] --(NR/LTE Air)--> [gNB/eNB] --(NG/S1)-->  Access/Core Edge
      LTE: S1-MME(SCTP) + S1-U(GTP-U)
      5G:  NG-C(AMF<->gNB, NGAP over SCTP) + N3(UPF<->gNB, GTP-U)

4G EPC (Control-Plane: S11/S6a/Gx   User-Plane: S1-U/S5)
  UE --eNB--> MME --- S11(GTPv2-C) ---> SGW-C --- S5 --- PGW-C
                           |                       |
                         HSS(S6a)                PCRF(Gx)
                         SGW-U/PGW-U(GTP-U)

5G Core (Service-Based Architecture; HTTP/2+JSON over TLS)
  UE --gNB--> AMF -- SBI --> SMF -- PFCP --> UPF -- N3/N6 --> Data Network
                 |          | \
                AUSF        |  \  PCF(Policy)  UDM/UDR(Subscriber) NRF(Registry) NSSF(Slice)
                (Auth)      |    NEF/BSF/AF/SEPP ... (roaming/edge/interop)
```

- **4G**: 시그널링은 **GTPv2-C(UDP/2123)**, Diameter(S6a/Gx), S1AP(SCTP) 중심. 데이터는 **GTP-U**.  
- **5G**: 시그널링 중심이 **SBI(HTTP/2 + JSON + TLS, Nnrf/Namf/Nsmf/… REST API)** 로 이동. 기지국과 코어는 **NGAP(SCTP)**. 데이터는 **GTP-U**(N3). CP↔UP 분리(PFCP)로 정책/경로를 **SMF**가 **UPF**에 하달.

### 23.1.2 시그널링 절차(요지)

**4G Attach + Default Bearer Setup(간단)**  
1) UE→eNB: RRC, NAS Attach Request → eNB→MME: **S1AP Initial UE Message**  
2) MME→HSS: **Diameter S6a** 인증/가입자 프로필 조회  
3) MME→SGW-C→PGW-C: **GTPv2-C Create Session** (QoS/APN)  
4) SGW/PGW-U: **GTP-U 터널** 설정 → eNB에 **S1AP Initial Context Setup** → Attach Complete

**5G Registration + PDU Session Establishment(간단)**  
1) UE→gNB: RRC, NAS(Registration Request) → gNB→AMF: **NGAP Initial UE Message**  
2) AMF↔AUSF/UDM: SUCI 기반 인증, SUPI 탈식별 → 정책/슬라이스 NSSF  
3) AMF→SMF: **Nsmf PDU Session Create**(HTTP/2, JSON)  
4) SMF→UPF: **PFCP Session Establish** → UPF에 N3/N6 경로 설정 → gNB에 N3 터널 정보(TEID) 송부

### 23.1.3 위협 모델(핵심 포인트)

- **무선(RAN) 측**  
  - LTE IMSI Catcher/도청(2G fallback, 4G Paging 조작). 5G는 **SUCI/SUPI 보호**로 개선되나 **다운그레이드/NSA 혼재**가 취약점.  
  - **Rogue gNB**: 페이크 셀/핸드오버 유도. (실험 금지, 이론 이해만)

- **접속/코어 경계**  
  - **NGAP/S1AP** 유효성 미검증 → **UE Context 혼동/리소스 고갈**  
  - **GTP-U 터널 오용**: 외부에서 임의 IP 주입/스푸핑, TEID 추측 공격(→ **GTP FW** 필수)  
  - **PFCP 조작**: UPF flow rule injection/삭제(→ CP 채널 인증·무결성·허용목록)

- **SBI(5GC 서비스 간 인터페이스)**  
  - **HTTP/2 + TLS**이나, **mTLS**·권한 모델·스키마 검증 부실 시 **가짜 NF** 등록/권한 상승  
  - **NRF 등록/탐색 남용**: 대량 질의로 **리소스 고갈**  
  - **Nsmf/Namf/Nudm 등 API 남용**: 스키마 편차/파라미터 주입, 비인가 데이터 접근

- **로밍/인터커넥트**  
  - 4G의 **SS7/Diameter** 문제는 널리 알려짐 → **Diameter FW** 필수  
  - 5G는 **SEPP**(보안 경계 게이트웨이)로 **E2E 보호/토큰 교환/헤더 가림**. 미구현 시 **사업자간 신뢰망 남용**

- **운영/정책**  
  - 슬라이스별 격리 불충분 → 한 슬라이스 침해가 **UPF 공유 자원**으로 확산  
  - 로깅/가시성 부족 → 시그널링 폭증/오류가 **품질 저하**로만 보임(보안 이벤트로 인지 실패)

---

## 23.2 슬라이싱 보안 포인트

### 23.2.1 슬라이스 핵심 구성요소
- **S-NSSAI (Slice/Service Type + Slice Differentiator)**: 슬라이스 식별자  
- **NSSF**: 슬라이스 선택/AMF/SMF 배정 정책  
- **SMF/UPF**: 슬라이스별 정책/경로(분리 배치 가능)  
- **PCF**: 슬라이스 QoS/Policy  
- **NEF/SEPP**: 외부/로밍 노출 및 경계 보호

### 23.2.2 보안 원칙(슬라이스당)
1) **격리 단위 명시**: **NF 인스턴스/SMF/UPF**를 슬라이스별 분리(고가용성/자원보장 포함).  
2) **SBI RBAC**: 슬라이스 레벨 **토큰/스코프**로 NF 호출 제한(NF 타입+슬라이스 맥락).  
3) **테넌트 정책**: B2B 슬라이스의 경우 **관리 포털**에서 API Key/Client Cert 회전·만료.  
4) **가시성 분리**: 슬라이스/테넌트별 **메트릭/로그 격리**(GDPR/계약 준수).  
5) **키·인증서 관리**: 슬라이스별 PKI/스트롱 암호 스위트, 클록/CRL/OCSP 정상화.  
6) **UPF 자원 보호**: 슬라이스별 큐/테이블 분리, **PFCP rate limit**, 임계치 초과 시 **그레이스풀 디그레이드**.

### 23.2.3 슬라이스 위협 시나리오 & 대응
- **A슬라이스 단말 남용 → UPF 테이블 고갈**  
  - *대응*: PFCP Session/Rule 수 상한, UPF LRU 정책, 슬라이스별 Rate Limit/버스트 제어  
- **NSSF/NRF 질의 폭주(탐색 남용)**  
  - *대응*: API Gateway에 Rate Limit + 캐시, NF 토큰 검증 강화  
- **테넌트 관리 API 오용**  
  - *대응*: mTLS + JWT 스코프 최소화, 감사 로그, 키 롤오버 주기 설정

### 23.2.4 슬라이스 정책 예(개념; OPA/Rego)

```rego
package sbi.authz

default allow = false

# 요청 맥락: { nf_type, slice: {sst, sd}, api: {service, method}, mTLS: {subject}, scopes: [...] }

# 1) 슬라이스 범위 일치
slice_ok {
  input.slice.sst == input.token.slice.sst
  input.slice.sd  == input.token.slice.sd
}

# 2) NF 타입/역할 허용
role_ok {
  input.nf_type == "SMF"
  input.api.service == "Nsmf_PDUSession"
  input.api.method == "Create"
}

# 3) mTLS 주체 및 스코프 확인
tls_ok { startswith(input.mTLS.subject, "CN=amf-") }
scope_ok { some s; s := input.scopes[_]; s == "slice:manage:pdu" }

allow { slice_ok; role_ok; tls_ok; scope_ok }
```

---

## 23.3 캐리어급 방어 전략

### 23.3.1 경계·프로토콜별 보안 기능

**RAN/접속 경계**
- **gNB/eNB ↔ AMF/MME**: **SCTP** 파라미터 검증(스트림 수/하트비트), **NGAP/S1AP** 메시지 형식/상태 머신 체크  
- **Paging 남용** 탐지(빈도 임계, IMSI 추적 시도 의심)

**GTP 보안**
- **GTP-U FW**: TEID/내부 IP 매핑 검증, 역방향 외부 주입 차단, Ingress F-TEID 화이트리스트  
- **GTPv2-C FW**: 메시지 유형/IE 유효성, **Create/Modify/Delete** 시나리오 상태 추적  
- **라벨링**: UE, APN/DNN, 슬라이스별 트래픽 태깅(가시성)

**PFCP/UPF**
- **CP↔UP 인증·무결성**(mTLS/DTLS), PFCP Message Rate Limit, **SEID 재사용/고갈** 방지  
- UPF **표/큐** 한도, 슬라이스별 QoS/버퍼 분리, DDoS 상황에서 **헤드드롭** 정책

**SBI/HTTP2**
- **API Gateway**(mTLS, JWT, 스키마 검증, Rate Limit, 헤더 정규화)  
- **CVE 관리**: HTTP2 RST flood/CONTINUATION abuse 등 L7 취약점 패치  
- **NRF 등록/탐색** 정책: 등록 타임아웃, 헬스체크 실패 시 비활성

**로밍/인터커넥트**
- **SEPP**: end-to-end 보호(가명화/헤더 보호), 피어 인증, 정책 기반 허용  
- **Diameter/SS7 FW**: GT/Realm 필터, MAP/CAP/Diameter 시나리오 검증, 위치 질의 제한

### 23.3.2 운영·모니터링

- **메트릭**  
  - NGAP/S1AP Success Ratio, GTPv2-C Create/Modify 모수, PFCP Session/Rule Count, HTTP2 RPS/오류코드  
  - 슬라이스별 UPRate/Drop, UE attach/registration 실패 사유 분포

- **탐지 룰(개념)**  
  - **NGAP PDU 비율 이상**: Initial UE Message 폭증 → Bot/스캐닝  
  - **GTP TEID 충돌**: 비정상 외부 TEID 등장  
  - **PFCP 세션 급증**: 상한 초과, 같은 UE/슬라이스 반복  
  - **SBI Rare Caller**: 보기 드문 mTLS 주체/스코프로 민감 API 호출

**Suricata 룰 샘플(개념, GTP-U 헤더 존재 확인)**
```suricata
alert udp any any -> any 2152 (msg:"GTP-U suspicious non-tunneled IP"; content:"|30|"; depth:1; # GTP flags
  byte_test:1,=,0x30,0; # 간략 예시
  detection_filter: track by_src, count 100, seconds 10;
  sid:950001; rev:1;)
```

**Sigma(개념) – HTTP/2 SBI Rare Caller**
```yaml
title: Rare NF mTLS Subject Accessing NRF/AMF APIs
logsource: { product: http, service: sbi-gateway }
detection:
  selection:
    request.path|contains:
      - "/nnrf-disc/v1/nf-instances"
      - "/namf-comm/v1/"
  rarity:
    mTLS.subject|rarity: below 1% # 구현체 필요
  condition: selection and rarity
level: high
tags: [5g, sbi, nrfgw]
```

### 23.3.3 변경관리·레질리언스

- **Blue/Red·NOC/SOC 공동 플레이북**(시그널링 폭주/장애 구분)  
- **그레이스풀 디그레이드**: 슬라이스별 속도 제한 → 낮은 우선순위 슬라이스 우선 제한  
- **카나리 배포/롤백**: NF 업데이트는 소수 인스턴스/지역부터, 헬스 실패 시 자동 롤백  
- **재난복구**: Dual-UPF, Anycast GTP-U, 다중 링크/지역

---

## 23.4 실습: 시그널링 이상 탐지(시뮬레이터)

> **목표**: 가벼운 **시뮬레이터/샘플 PCAP/로그**로 **NGAP/GTPv2-C/GTP-U/PFCP/SBI(HTTP2)**의  
> **기본 지표/패턴**을 추출하고, **규칙+통계** 기반 **이상 탐지**를 구현한다.

### 23.4.1 랩 구성(로컬)

```
[Traffic Source]
  ├─ generator.py         # 시뮬레이터(로그/CSV 생성)
  └─ sample.pcap          # 공개 샘플(강의/랩용) 또는 자체 생성 패턴
[Parsing]
  ├─ tshark extracters    # NGAP/GTP/PFCP/HTTP2 필드 뽑기
  └─ zeek (선택)          # http2.log / custom log
[Detect]
  ├─ detect_rules.py      # 룰 기반
  └─ detect_stats.py      # 통계/베이스라인 기반
[Dashboard]
  └─ notebooks / CSV → Grafana/Kibana 로드
```

> 실제 5G 코어(srsRAN/open5gs 등)와 연동 가능한 수준이지만, 여기서는 **네트워크 접속 없이도** 동작하는 **생성 로그 + 파서 + 탐지** 흐름을 다룬다.

---

### 23.4.2 시그널링 로그/PCAP 추출(tshark)

**NGAP 필드 추출 (SCTP/NGAP)**
```bash
tshark -r sample.pcap -Y "ngap" -T fields \
  -e frame.time_epoch -e ip.src -e ip.dst -e sctp.port \
  -e ngap.procedureCode -e ngap.AMF-UE-NGAP-ID -e ngap.RAN-UE-NGAP-ID \
  -E header=y -E separator=, -E quote=d > ngap.csv
```

**GTPv2-C (S11/N11 근사)**
```bash
tshark -r sample.pcap -Y "gtpv2" -T fields \
  -e frame.time_epoch -e ip.src -e ip.dst -e gtpv2.message_type \
  -e gtpv2.teid -e gtpv2.cause \
  -E header=y -E separator=, -E quote=d > gtpv2.csv
```

**PFCP**
```bash
tshark -r sample.pcap -Y "pfcp" -T fields \
  -e frame.time_epoch -e ip.src -e ip.dst -e pfcp.message_type \
  -e pfcp.seid -E header=y -E separator=, -E quote=d > pfcp.csv
```

**GTP-U(사용자면; TEID/바이트)**
```bash
tshark -r sample.pcap -Y "gtp && gtp.msgtype==255" -T fields \
  -e frame.time_epoch -e ip.src -e ip.dst -e gtp.teid -e frame.len \
  -E header=y -E separator=, -E quote=d > gtpu.csv
```

**HTTP/2 + :path (SBI)**
```bash
tshark -r sample.pcap -Y "http2" -T fields \
  -e frame.time_epoch -e ip.src -e ip.dst -e http2.header.path -e http2.header.status \
  -E header=y -E separator=, -E quote=d > sbi.csv
```

---

### 23.4.3 시뮬레이터(로그 제너레이터; 파이썬)

```python
# generator.py — 교육용: NGAP/GTPv2/PFCP/SBI CSV 생성
import csv, time, random, pathlib
from datetime import datetime, timezone

def now(): return str(time.time())

def write_csv(path, headers, rows):
    path.parent.mkdir(exist_ok=True, parents=True)
    with open(path, "w", newline='', encoding="utf-8") as f:
        w=csv.writer(f); w.writerow(headers); w.writerows(rows)

def gen_ngap(n=500):
    rows=[]; ran_ids=[random.randint(100,999) for _ in range(50)]
    for i in range(n):
        proc=random.choice(["initialUEMessage","initialContextSetup","ueContextRelease","downlinkNASTransport"])
        rows.append([now(),"10.0.0.%d"%(i%5+10),"10.0.1.10","38412",proc,random.randint(1000,9999),random.choice(ran_ids)])
    # 이상: short burst of initialUEMessage
    for i in range(80):
        rows.append([now(),"10.0.0.66","10.0.1.10","38412","initialUEMessage",random.randint(5000,9000),random.randint(100,999)])
    return rows

def gen_gtpv2(n=400):
    rows=[]
    for i in range(n):
        t=random.choice(["create_session_req","create_session_res","modify_bearer_req","delete_session_req"])
        cause=random.choice(["req_accepted","no_resources","unknown_apn",""])
        rows.append([now(),"10.0.1.10","10.0.2.10",t,random.randint(10000,20000),cause])
    # 이상: create_session_req flood
    for i in range(120):
        rows.append([now(),"10.0.1.77","10.0.2.10","create_session_req",random.randint(20001,30000),""])
    return rows

def gen_pfcp(n=300):
    rows=[]
    for i in range(n):
        t=random.choice(["session_est","session_mod","session_del"])
        rows.append([now(),"10.0.2.10","10.0.3.10",t,random.randint(100000,200000)])
    # 이상: session_est spike
    for i in range(50):
        rows.append([now(),"10.0.2.77","10.0.3.10","session_est",random.randint(200001,300000)])
    return rows

def gen_sbi(n=600):
    rows=[]; paths=["/namf-comm/v1/ue-contexts","/nsmf-pdusession/v1/sessions","/nnrf-disc/v1/nf-instances"]
    for i in range(n):
        p=random.choice(paths); st=random.choice(["200","201","204","400","401","503"])
        rows.append([now(),"10.0.4.10","10.0.5.10",p,st])
    # 이상: nnrf-disc 폭주 + 503 증가
    for i in range(100):
        rows.append([now(),"10.0.4.77","10.0.5.10","/nnrf-disc/v1/nf-instances","503"])
    return rows

base=pathlib.Path("./sim")
write_csv(base/"ngap.csv", ["ts","src","dst","sctp","proc","amf_ue","ran_ue"], gen_ngap())
write_csv(base/"gtpv2.csv",["ts","src","dst","msg","teid","cause"], gen_gtpv2())
write_csv(base/"pfcp.csv", ["ts","src","dst","msg","seid"], gen_pfcp())
write_csv(base/"sbi.csv",  ["ts","src","dst","path","status"], gen_sbi())
print("generated ./sim/*.csv")
```

---

### 23.4.4 룰 기반 탐지(detect_rules.py)

```python
# detect_rules.py — 간단 룰: Burst/Rate/희귀 경로/오류율 임계
import csv, time, collections

def load(path):
    with open(path, newline='', encoding="utf-8") as f:
        return list(csv.DictReader(f))

ALERTS=[]

# 1) NGAP: initialUEMessage burst
ngap=load("./sim/ngap.csv")
burst= sum(1 for r in ngap if r["proc"]=="initialUEMessage" and r["src"]=="10.0.0.66")
if burst>50:
    ALERTS.append(("NGAP_BURST","initialUEMessage from 10.0.0.66 count="+str(burst)))

# 2) GTPv2: create_session_req flood
gtp=load("./sim/gtpv2.csv")
by_src=collections.Counter([r["src"] for r in gtp if r["msg"]=="create_session_req"])
for s,c in by_src.items():
    if c>80: ALERTS.append(("GTPV2_CREATE_FLOOD",f"{s}={c}"))

# 3) PFCP: session_est spike
pfcp=load("./sim/pfcp.csv")
by_src_pf=collections.Counter([r["src"] for r in pfcp if r["msg"]=="session_est"])
for s,c in by_src_pf.items():
    if c>30: ALERTS.append(("PFCP_SESS_EST_SPIKE",f"{s}={c}"))

# 4) SBI: nnrf-disc 503 rate > 30%
sbi=load("./sim/sbi.csv")
r503=sum(1 for r in sbi if r["path"].startswith("/nnrf-disc") and r["status"]=="503")
tot =sum(1 for r in sbi if r["path"].startswith("/nnrf-disc"))
if tot>0 and r503/tot>0.3:
    ALERTS.append(("SBI_NRF_DISC_503",f"rate={r503}/{tot}={r503/tot:.2f}"))

for a in ALERTS: print("[ALERT]", *a)
```

**실행 결과(예)**  
```
[ALERT] NGAP_BURST initialUEMessage from 10.0.0.66 count=80
[ALERT] GTPV2_CREATE_FLOOD 10.0.1.77=120
[ALERT] PFCP_SESS_EST_SPIKE 10.0.2.77=50
[ALERT] SBI_NRF_DISC_503 rate=100/130=0.77
```

---

### 23.4.5 통계/베이스라인 기반(detect_stats.py)

```python
# detect_stats.py — 시간창/분산 기반 간단 이상 탐지
import csv, collections, statistics as st

def mean_cv(arr):
    if len(arr)<3: return (0,9)
    m=st.mean(arr); cv=(st.pstdev(arr)/(m+1e-9))
    return (m,cv)

# 1) NGAP per-src rate (단순 카운트 분산)
rows=list(csv.DictReader(open("./sim/ngap.csv",encoding="utf-8")))
by_src=collections.Counter([r["src"] for r in rows])
vals=list(by_src.values()); m,cv=mean_cv(vals)
for s,c in by_src.items():
    if m>0 and c>m+3*(st.pstdev(vals) if len(vals)>1 else 0):
        print("ANOMALY: NGAP src burst", s, c, "vs mean", round(m,2))

# 2) SBI path rarity
rows=list(csv.DictReader(open("./sim/sbi.csv",encoding="utf-8")))
cnt=collections.Counter([r["path"] for r in rows])
tot=sum(cnt.values())
for p,v in cnt.items():
    if v/tot<0.02: print("RARE_PATH:", p, v, f"{v/tot:.3f}")

# 3) PFCP 세션 유형 쏠림
rows=list(csv.DictReader(open("./sim/pfcp.csv",encoding="utf-8")))
by_msg=collections.Counter([r["msg"] for r in rows])
dom=by_msg.most_common(1)[0]
if dom[1]/len(rows) > 0.7:
    print("SKEWED_PFCP:", dom)
```

---

### 23.4.6 결과 해석 → 플레이북

- **NGAP Burst**  
  - *가능 원인*: 진짜 접속 폭주(장애 복구/이벤트) vs **스캔/오탐**  
  - *조치*: gNB health, AMF 자원, SCTP queue 관찰 → 이상 지속 시 **SCTP/NGAP 레이트 리미트**(엣지), 필드팀 확인

- **GTPv2 Create Flood**  
  - *가능 원인*: 비정상 MME/AMF 상호작용, 잘못된 재시도 루프, 스푸핑  
  - *조치*: GTPv2-C FW 상태 머신 검증 강화, 문제 소스 임시 차단, 관련 UE/셀 범위 확인

- **PFCP Session Spike**  
  - *가능 원인*: UPF 정책 초기화/롤링 업데이트, SMF 버그, 공격  
  - *조치*: PFCP rate-limit, 동일 UE/슬라이스 집중 여부 분석, UPF 테이블 사용량 임계 확인

- **SBI NRF 503 증가**  
  - *가능 원인*: NRF 다운/오버로드, 잘못된 클라이언트 급증  
  - *조치*: API GW에서 NRF 캐시/백오프, 헬스체크 실패 인스턴스 격리, mTLS 주체별 쿼터 적용

---

### 23.4.7 대시보드 위젯(핵심)

- **NGAP 절차별 카운트/성공률**: Initial/ContextSetup/Release  
- **GTPv2 메시지 스택**: Create/Modify/Delete/Failure cause  
- **PFCP 세션/룰 카운트 & 초당 변화**  
- **SBI HTTP2 경로·상태코드**: 5xx 비율 / Rare Caller  
- **슬라이스별 UE/PDU 세션**: UPRate, Drop, 오류 분포

**예: Kibana KQL**
```kql
(index: sbi-logs-*) and http.path : "/nnrf-disc/*"
| stats count() as hits, sum(case(http.status>=500,1,0)) as s5xx by client.mtls.subject
| eval rate = s5xx / hits
| where rate > 0.2
```

---

## 부록 A. 필드 체크리스트(보안·운영)

- [ ] **GTP FW**: 외부 주입 차단, TEID 검증, DNN/APN 스코핑  
- [ ] **NGAP/S1AP 상태 머신** 검증, SCTP 파라미터 튜닝(하트비트, rto, stream num)  
- [ ] **PFCP 인증·암호화**(mTLS/DTLS), Rate Limit/백오프  
- [ ] **SBI mTLS+RBAC**: NF 타입/슬라이스 스코프, JWT 만료/회전  
- [ ] **SEPP**: 로밍 경계 보호, 가명화, 피어 정책  
- [ ] **슬라이스 격리**: SMF/UPF 분리, 큐/테이블 상한, 모니터링 분리  
- [ ] **로그/메트릭 표준화**: (ECS 유사) `proto`, `msg_type`, `slice`, `ue`, `nf_type`, `status`  
- [ ] **테스트/릴리스**: 카나리·헬스 체크, 자동 롤백, 장애 드릴  
- [ ] **IR 플레이북**: 시그널링 폭주/DoS/NRF 장애/UPF 고갈 시나리오별 조치

## 부록 B. 흔한 함정

- **“TLS면 안전” 오판**: 5GC는 **mTLS+권한+스키마**를 모두 구현해야 안전.  
- **UPF 공용화 남용**: 슬라이스/테넌트 격리 실패 → 성능·보안 동시 악화.  
- **오탐/품질 혼동**: 시그널링 장애/오류를 네트워크 성능 문제로만 취급.  
- **로밍 신뢰 과대평가**: SEPP/정책 미흡 시 **이웃 사업자**가 취약점이 된다.

---

## 요약

- **4G→5G** 전환은 프로토콜만 바뀐 게 아니라 **아키텍처·보안 경계**가 **HTTP2+SBI** 중심으로 바뀌었음을 의미한다.  
- **슬라이싱**은 **격리·정책·가시성·키 관리**의 네 축으로 접근해야 하며, **UPF/PFCP**가 신규 공격면이 된다.  
- **캐리어급 방어**는 **GTP/NGAP/PFCP/SBI/SEPP** 각 계층에 맞춘 검증·RateLimit·mTLS·RBAC·레질리언스가 핵심.  
- **실습 파이프라인**(tshark/시뮬레이터→룰+통계)은 실제망과 분리된 안전한 환경에서 **탐지 감각**을 기르는 데 유용하다.  
- 다음 단계로는 **오픈 코어(예: 데모)** + **컨테이너 배포**를 활용해, 같은 탐지 파이프라인을 **실제 NF 로그 포맷**에 맞춰 확장해보자.