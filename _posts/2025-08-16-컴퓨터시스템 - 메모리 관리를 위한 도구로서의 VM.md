---
layout: post
title: 컴퓨터시스템 - 메모리 관리를 위한 도구로서의 VM
date: 2025-08-16 22:20:23 +0900
category: 컴퓨터시스템
---
# 메모리 관리를 위한 도구로서의 VM (Virtual Memory)

## 0. 한눈에 보는 전체 지도

```
[프로세스 관점]
  연속 가상주소 공간
     ├─ 코드(.text)  R-X
     ├─ 데이터(.data) RW-
     ├─ 힙(Heap)      RW-  ← brk/mmap 확장
     ├─ 공유맵핑      R--/RW-  ← mmap(MAP_SHARED/PRIVATE)
     └─ 스택(Stack)   RW-  ← 자동 확장 + 가드 페이지

[하드웨어/MMU]
  가상주소 ──(TLB)──▶ 물리주소
                │ 미스
                └── 다단계 페이지테이블 탐색(4/5-레벨, 4K/2M/1G 페이지)

[커널/정책]
  - 보호: U/S 비트, R/W/X, ASLR, (옵션) pkeys
  - 자원 분배: 페이지 캐시, NUMA 정책, cgroups v2, OOM 킬러
  - 효율: Demand Paging, COW, Transparent Huge Pages, 워킹셋·교체
  - I/O: 파일 매핑 + 페이지 캐시 + msync/posix_fadvise/madvise
```

---

## 1. VM의 역할과 목표

### 1.1 추상화(Abstraction)
- 프로세스마다 **독립적이고 연속적인** 가상주소 공간 제공 → **이식성·단순성** 향상.
- 실제 물리 배치는 커널이 결정(파편화 은닉, 힌트 반영).

### 1.2 보호(Protection)
- **페이지 단위 R/W/X 권한**, 사용자/커널 모드 분리, (지원 시) **MPK(pkeys)**.
- 잘못된 접근 시 **페이지 폴트(#PF)** → 커널이 대응(할당/시그널).

### 1.3 효율적 자원 분배(Resource Management)
- **수요 페이징(Demand Paging)**, **스와핑**, **페이지 교체**, **페이지 캐시**로 메모리 압력 대응.
- **공유(Shm/MAP_SHARED)** 로 복사 비용 절감, **COW** 로 지연 복사.

---

## 2. 주소변환과 페이지 테이블, TLB

### 2.1 다단계 페이지 테이블
- x86-64: **4/5-레벨 페이지 테이블**(LA57 도입 시 5레벨). 페이지 크기 **4K/2M/1G**.
- 각 엔트리는 **물리 프레임 번호(PFN)** + 권한/상태 비트(R/W/X, U/S, A/D, NX 등).

### 2.2 TLB(Translation Lookaside Buffer)
- 최근 변환 결과를 캐시하는 **소형, 고속 캐시**.
- PCID(Process-Context ID) 지원 시 **주소공간 전환 시 TLB flush 완화**.

### 2.3 평균 접근시간(EAT) 근사
TLB 적중률을 \(h\), TLB 접근시간을 \(t_{TLB}\), 메모리 접근시간을 \(t_{MEM}\)라 하면
$$
\text{EAT} \approx
h\cdot (t_{TLB}+t_{MEM}) + (1-h)\cdot (t_{TLB}+2\cdot t_{MEM})
$$
(미스 시 페이지테이블 접근을 단순화하여 메모리 1회 추가로 근사)

> **시사점**: TLB 적중률을 높이고(지역성·페이지 크기·바인딩), 불필요한 주소공간 전환/슈트다운(TLB shootdown)을 줄이는 것이 성능의 핵심.

---

## 3. 보호: 권한, 가드 페이지, ASLR, (옵션) pkeys

- **권한 비트**: 페이지 단위 R/W/X, User/Supervisor, NX(Execute Disable).
- **가드 페이지**: 스택 끝/매핑 경계에 **접근 불가 페이지**를 두어 오버플로우 탐지.
- **ASLR**: 코드·힙·스택·맵핑 베이스 랜덤화 → ROP/JOP 곤란.
- **Intel MPK(pkeys)**: 사용자 공간에서 **pkey_mprotect** 등으로 빠른 권한 전환.

---

## 4. 페이지의 생명주기: Fault → 채움 → 교체

### 4.1 폴트 유형
- **Minor Fault(soft)**: 페이지가 **메모리에 있으나** 매핑/권한만 필요(예: COW 준비).
- **Major Fault(hard)**: 디스크 I/O 필요(스왑/파일 읽기).
- **COW Fault**: 공유 페이지에 쓰기 → **사본 할당 후 복사**.

### 4.2 수요 페이징(Demand Paging)
- 처음 접근할 때만 페이지를 실제로 할당/읽기 → **초기 시작 빠름**, 워킹셋만 상주.

---

## 5. 스와핑과 페이지 교체

### 5.1 기본 개념
- 물리 메모리 부족 시 **덜 쓰이는 페이지를 스왑영역**으로 내보냄.
- 장점: **다중 프로그램 동시 실행**, 대형 워킹셋 수용. 단점: 과하면 **스래싱**.

### 5.2 스래싱(Thrashing)의 직관적 조건
워킹셋 크기를 \(W\) (활성 페이지 개수), 가용 프레임 수를 \(F\)라 하면
\(W \gg F\) 인 구간에서 **폴트율 급증**, EAT 폭증:
$$
\text{EAT}_\text{fault} \approx p \cdot t_{\text{fault}} + (1-p)\cdot t_{\text{hit}}
$$
여기서 \(p\)는 폴트 확률, \(t_{\text{fault}}\)는 디스크 I/O 포함 비용(수 ms~수십 ms).

### 5.3 교체정책(이론 vs 리눅스 구현)
- 이론: **OPT**(이상적), **LRU**, **Clock**, **NRU**, **Working-Set**.
- 리눅스: **활성/비활성 LRU 리스트**, Reclaim/kswapd, 파일캐시 우선 회수, **refault 거리**로 워킹셋 판별(근사 LRU).

---

## 6. 파일 I/O와 메모리 매핑

### 6.1 `mmap` 모델
- **MAP_SHARED**: 파일과 **동기화**(Dirty → writeback).
- **MAP_PRIVATE**: 쓰기 시 **COW** 발생(파일 원본은 불변).
- **페이지 캐시**: 읽은 파일 페이지가 **페이지 캐시**에 남아 재사용.

### 6.2 예제: 파일을 매핑해 수정
```c
// mmap_write.c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main(){
    int fd = open("data.txt", O_RDWR|O_CREAT, 0644);
    if(fd<0){perror("open");return 1;}
    if(ftruncate(fd, 4096)){perror("ftruncate");return 1;}

    char *p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(p==MAP_FAILED){perror("mmap");return 1;}

    strcpy(p, "Hello VM via mmap!\n");

    // 쓰기 보장(파일 동기)
    if(msync(p, 4096, MS_SYNC)) perror("msync");

    munmap(p,4096);
    close(fd);
    return 0;
}
```

### 6.3 힌트와 최적화
- `madvise(addr, len, MADV_SEQUENTIAL|MADV_RANDOM|MADV_WILLNEED|MADV_DONTNEED|MADV_HUGEPAGE|MADV_NOHUGEPAGE)`.
- `posix_fadvise(fd, ... FADV_* )` 로 **파일 접근 패턴** 힌트.

---

## 7. 공유 메모리(IPC): POSIX `shm_open`

```c
// posix_shm_writer.c
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(){
    const char* name="/my_shm";
    int fd = shm_open(name, O_CREAT|O_RDWR, 0666);
    ftruncate(fd, 4096);
    char* p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    strcpy(p, "shared hello");
    printf("writer wrote: %s\n", p);
    munmap(p,4096); close(fd);
    return 0;
}
```

```c
// posix_shm_reader.c
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int main(){
    int fd = shm_open("/my_shm", O_RDWR, 0666);
    char* p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    printf("reader read: %s\n", p);
    munmap(p,4096); close(fd);
    shm_unlink("/my_shm"); // 정리
    return 0;
}
```

> **특징**: **프로세스 간 동일 물리페이지**를 서로의 가상주소에 매핑 → **복사 없이 고속 IPC**.

---

## 8. COW(Copy-On-Write)와 `fork()`

```c
// cow_demo.c
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(){
    size_t len = 4096;
    char* p = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    strcpy(p, "before fork");
    pid_t pid = fork();
    if(pid==0){
        // 자식: 쓰기 → COW 발생(새 프레임 할당)
        strcpy(p, "child modified");
        printf("[child] %s\n", p);
        return 0;
    } else {
        wait(NULL);
        // 부모 페이지는 여전히 원본
        printf("[parent] %s\n", p);
    }
    munmap(p, len);
    return 0;
}
```

> **관찰 포인트**: `fork()` 직후까지 **페이지 공유**, **쓰기 시점**에만 복사.

---

## 9. 힙/스택, 가드 페이지, 보호 호출

- **힙 확장**: glibc `malloc`은 **작은 블록은 brk/sbrk**, 큰 블록은 **`mmap`** 사용(구현에 따라 상이).
- **스택**: 자동 확장 + **가드 페이지**(접근 시 SIGSEGV).
- **보호 변경**: `mprotect(addr, len, PROT_READ|PROT_WRITE|PROT_EXEC)`
- **잠금(고정)**: `mlock/munlock`(스왑 금지, 키 관리/저지연 버퍼에 유용).

---

## 10. 힌트·튜닝: `madvise`, THP, HugeTLB, userfaultfd

### 10.1 Transparent Huge Pages(THP) & HugeTLB
- **THP**: 커널이 **투명하게 2MB** 페이지 사용을 시도(적중 시 TLB 효율↑, 내부단편화 주의).
  - 힌트: `MADV_HUGEPAGE` / `MADV_NOHUGEPAGE`.
- **HugeTLB**: 명시적 **hugetlbfs** 기반(고정 크기 풀에서 2MB/1GB) — **예측 가능한 지연/메모리 잠금**에 적합.

### 10.2 userfaultfd(고급)
- 사용자 공간이 **특정 주소영역의 폴트를 가로채** 처리 → **라이브 마이그레이션**, 지연 로딩, 원격 페이징 구현에 활용.

---

## 11. NUMA(Non-Uniform Memory Access)

- **First-Touch**: 처음 접근한 CPU의 노드에 페이지 배치(기본).
- **정책**: interleave, preferred, bind(예: `numactl`/`mbind`/`set_mempolicy`).
- **주의**: 원격 노드 접근은 지연↑. **스레드-데이터 배치 일치**가 관건.

간단 예(의사 코드):
```bash
# 노드 간 인터리브 배치로 대용량 배열 초기화
numactl --interleave=all ./your_app
```

---

## 12. 컨테이너/클라우드: cgroups v2·OOM·리밋

- **cgroups v2 memory controller**: `memory.max`, `memory.swap.max`, `memory.high` 등으로 제한.
- 한계 초과 → **OOM killer**가 대상 프로세스 종료.
- K8s: **requests/limits** → 스케줄링 및 cgroup 설정 반영.

---

## 13. 관측·디버깅 도구 모음

| 목적 | 명령 |
|---|---|
| 프로세스 맵 | `cat /proc/$pid/maps`, `pmap -x $pid` |
| 메모리 통계 | `cat /proc/meminfo`, `vmstat 1`, `free -h` |
| 페이지 폴트 | `perf stat -e page-faults,major-faults,minor-faults <cmd>` |
| 스왑상태 | `swapon -s`, `cat /proc/swaps` |
| 워킹셋/스캔 | `sar -B`, `pss`는 `/proc/$pid/smaps` |
| 페이지 유무 | `mincore(addr,len,vec)`로 **캐시 상주 여부** 탐사 |
| 핫/콜드 | `madvise(..., MADV_PAGEOUT/DONTNEED)` 로 콜드화 실험 |

---

## 14. 보안과 VM

- **W^X**: 쓰기 가능 메모리는 실행 금지(NX) 원칙.
- **ASLR**: 매 실행 시 랜덤화(PIE·라이브러리·스택/힙).
- **격리**: pkeys/내장 권한으로 서브도메인 보호(지원 CPU/커널에 한함).
- **가드**: 힙/스택 주변 가드 페이지로 침범 탐지.

---

## 15. 실전 최적화 레시피(상황별)

| 문제 | 진단 | 처방 |
|---|---|---|
| 시작이 느리다 | major faults, readahead 부족 | `madvise(..., WILLNEED)`/`posix_fadvise(FADV_WILLNEED)`, warm-up |
| 폴트 폭증(스래싱) | vmstat/major faults↑ | 워킹셋 축소, 메모리 증설, cgroup 제한 재조정, I/O QoS |
| TLB 미스 과다 | IPC/TLB miss | THP/HugeTLB 검토, 데이터 배치/구조체 압축, 루프 타일링 |
| NUMA 원격 접근 | `numastat`, perf | 바인딩/인터리브/스레드 핀닝, 데이터 초기화 노드 일치 |
| 대형 I/O 복사 과다 | 프로파일 | `mmap(MAP_SHARED)`+`msync` 또는 `O_DIRECT`(설계에 따라) |
| 지연 민감, 스왑 금지 | 지연 tail | `mlockall(MCL_CURRENT|MCL_FUTURE)`, HugeTLB, cfs/rt 튜닝 |

---

## 16. 코드 조각 모음

### 16.1 접근 패턴 힌트
```c
#include <sys/mman.h>
void touch(char* p, size_t n){ for(size_t i=0;i<n;i+=4096) p[i]=0; }
madvise(p, len, MADV_SEQUENTIAL);  // 순차 접근 힌트
madvise(p, len, MADV_WILLNEED);    // 미리 읽기
madvise(p, len, MADV_DONTNEED);    // 캐시 비우기(다음 접근 시 폴트로 가져옴)
```

### 16.2 핀닝(스왑 금지)
```c
#include <sys/mman.h>
mlock(p, len);   // 보안 키/하드실시간 버퍼 등
// 작업 후
munlock(p, len);
```

### 16.3 권한 변경
```c
#include <sys/mman.h>
mprotect(code, len, PROT_READ|PROT_EXEC); // W^X 준수
```

---

## 17. 내부/외부 단편화와 페이지 크기

- **외부 단편화**: VM이 **페이지 단위 매핑**으로 **완화**(연속 물리 불요).
- **내부 단편화**: 페이지 크기가 커질수록 증가(2MB/1GB 거대페이지).
  - **거대페이지**는 **TLB 효율**과 교환: **메모리 단편화/캐시 오염**과 균형 잡기.

---

## 18. 수학·모델: 워킹셋과 폴트율

워킹셋 모델(윈도우 길이 \(\tau\) 동안 서로 다른 참조 페이지 수 \(W(\tau)\))이 가용 프레임 \(F\)를 넘으면 폴트율 급등:
$$
W(\tau) > F \quad \Rightarrow \quad \text{fault rate} \uparrow \uparrow
$$
→ 실무에서는 **참조지역성 강화(타일링/풀링)** 와 **데이터 구조 크기 감소**가 폴트율 저감에 직결.

---

## 19. 체크리스트

- [ ] 보호: R/W/X, W^X, ASLR, 가드 페이지 구성
- [ ] 성능: TLB 적중(THP/배치), 워킹셋 관리, NUMA 일치
- [ ] I/O: 파일은 가급적 **mmap + 힌트**로 패스 수 줄이기
- [ ] 압력: 스왑 정책/한계(cgroup), OOM 상황 가드
- [ ] 힌트: `madvise/posix_fadvise`, `mlock`, `mprotect`, 필요시 HugeTLB
- [ ] 관측: `/proc/$pid/smaps`, `perf page-faults`, `vmstat`, `numastat`

---

## 20. 맺음말

가상 메모리는 **보호/격리**와 **성능/자원관리**를 동시에 달성하는 **운영체제의 메모리 관리 플랫폼**이다.
하드웨어(MMU/TLB) 특성과 커널 정책(워킹셋·교체·캐시·NUMA·cgroups)을 이해하고,
응용에서 **적절한 힌트와 맵핑 전략**(mmap/COW/THP/NUMA)을 조합하면
**지연·대역·안정성**을 모두 만족하는 메모리 프로파일을 만들 수 있다.
