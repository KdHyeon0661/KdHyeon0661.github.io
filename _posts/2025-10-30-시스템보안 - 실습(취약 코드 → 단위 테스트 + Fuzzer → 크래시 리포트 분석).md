---
layout: post
title: 시스템보안 - 실습(취약 코드 → 단위 테스트 + Fuzzer → 크래시 리포트 분석)
date: 2025-10-30 15:30:23 +0900
category: 시스템보안
---
# 12.4 실습: 취약 코드 → 단위 테스트 + Fuzzer → 크래시 리포트 분석

## 12.4.1 시나리오 개요

- **대상**: 바이너리 메시지 포맷 파서 `parse_message(const uint8_t*, size_t)`  
- **버그**: 길이 필드 신뢰로 인한 **OOB Read/Write** + **정수 오버플로** 가능  
- **목표**: (1) 실패 재현, (2) **ASan/UBSan**로 확증, (3) **libFuzzer**로 커버리지 확대,  
  (4) 크래시 입력을 **유닛 테스트로 편입**, (5) **수정 후 회귀 방지**.

디렉터리:
```
/proj
 ├─ CMakeLists.txt
 ├─ src/
 │   ├─ parser.hpp
 │   └─ parser.cpp     # 취약 버전 → 개선
 ├─ test/
 │   └─ parser_test.cpp
 ├─ fuzz/
 │   └─ fuzz_parse.cpp
 ├─ seeds/             # 퍼저 시드 입력
 │   ├─ minimal.bin
 │   └─ example1.bin
 └─ crashes/           # 퍼징 산출물(크래시/타임아웃)
```

---

## 12.4.2 취약 코드(안티패턴) → 재현

### (1) 취약 `parser.cpp` (의도적 결함 포함)
```cpp
// src/parser.hpp
#pragma once
#include <cstdint>
#include <cstddef>
#include <string>
#include <optional>

struct Msg {
  uint32_t type;
  std::string payload;
  std::string to_json() const;
};

std::optional<Msg> parse_message(const uint8_t* data, size_t n);

// src/parser.cpp (취약)
#include "parser.hpp"
#include <cstring>
#include <sstream>

static uint32_t read_u32_unsafe(const uint8_t* p) {
  // 엔디안/범위 검증 없음
  return *(const uint32_t*)p; // ❌ misaligned/aliasing/범위 검증 없음
}

std::string Msg::to_json() const {
  std::ostringstream os;
  os << "{\"type\":" << type << ",\"payload\":\"";
  for (unsigned char c : payload) {
    if (c == '\"') os << "\\\"";
    else if (c == '\\') os << "\\\\";
    else if (c >= 0x20 && c < 0x7f) os << c;
    else os << "\\x" << std::hex << (int)c;
  }
  os << "\"}";
  return os.str();
}

std::optional<Msg> parse_message(const uint8_t* data, size_t n) {
  // 포맷: [u32 type][u32 len][len bytes payload]
  if (n < 8) return std::nullopt;
  uint32_t type = read_u32_unsafe(data);
  uint32_t len  = read_u32_unsafe(data + 4);

  // ❌ len 신뢰 — 정수 오버플로 & 경계 미검증
  std::string payload;
  payload.resize(len);                 // ❌ 거대 할당/메모리고갈/UB 가능
  std::memcpy(payload.data(), data+8, len); // ❌ OOB Read

  return Msg{type, std::move(payload)};
}
```

**즉석 재현(ASan 권장)**
```bash
clang++ -g -O1 -fsanitize=address,undefined -fno-omit-frame-pointer \
  src/parser.cpp -DSAN -o parser_san

# 간단 드라이버: stdin을 그대로 parse (임시)
cat > main.cpp <<'CPP'
#include "src/parser.hpp"
#include <iostream>
#include <vector>
int main(){
  std::vector<unsigned char> buf((std::istreambuf_iterator<char>(std::cin)),
                                  std::istreambuf_iterator<char>());
  auto m = parse_message(buf.data(), buf.size());
  if(!m){ std::cerr<<"ERR\n"; return 1; }
  std::cout<<m->to_json()<<"\n";
}
CPP
clang++ -g -O1 -fsanitize=address,undefined -fno-omit-frame-pointer \
  main.cpp src/parser.cpp -o app_san

# ASan 실행: 크래시 유도
python3 - <<'PY'
import sys,struct
# [type=1][len=0xFFFFFFFF] → OOB/할당 폭탄 유도
sys.stdout.buffer.write(struct.pack("<I",1))
sys.stdout.buffer.write(struct.pack("<I",0xFFFFFFFF))
sys.stdout.buffer.write(b"A"*16)
PY | ./app_san
# => AddressSanitizer/UBSan 리포트 확인 (heap-buffer-overflow 혹은 bad alloc)
```

**ASan 리포트(예시 요약)**
```
==12345==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x... at pc 0x...
READ of size 4294967295 at 0x... thread T0
  #0 memcpy ...
  #1 parse_message .../src/parser.cpp:...
  #2 main ...
```

---

## 12.4.3 단위 테스트(취약 입력 고정) + `gtest` 스켈레톤

```cpp
// test/parser_test.cpp
#include "src/parser.hpp"
#include <gtest/gtest.h>
#include <vector>
#include <cstdint>

static std::vector<uint8_t> mk(const std::vector<uint8_t>& v){ return v; }

TEST(Parser, RejectTooSmall) {
  auto m = parse_message(nullptr, 0);
  EXPECT_FALSE(m.has_value());
}

TEST(Parser, RejectHugeLen) {
  // [type=1][len=0xFFFFFFFF]
  std::vector<uint8_t> v = mk({1,0,0,0, 0xFF,0xFF,0xFF,0xFF});
  auto m = parse_message(v.data(), v.size());
  // 취약 버전에서는 UB/크래시할 수 있음 → 수정 후 PASS 목표
  EXPECT_FALSE(m.has_value());
}

TEST(Parser, MinimalOK) {
  // [type=2][len=3]["abc"]
  std::vector<uint8_t> v = mk({2,0,0,0, 3,0,0,0, 'a','b','c'});
  auto m = parse_message(v.data(), v.size());
  ASSERT_TRUE(m.has_value());
  EXPECT_EQ(m->type, 2u);
  EXPECT_EQ(m->payload, "abc");
}
```

CMake 통합(요약):
```cmake
# CMakeLists.txt (일부)
enable_testing()
find_package(GTest REQUIRED)
add_executable(parser_tests test/parser_test.cpp src/parser.cpp)
target_link_libraries(parser_tests GTest::gtest_main)
add_test(NAME parser_tests COMMAND parser_tests)
```

---

## 12.4.4 libFuzzer 퍼저 추가

```cpp
// fuzz/fuzz_parse.cpp
#include <cstdint>
#include <cstddef>
#include "src/parser.hpp"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  auto m = parse_message(data, size);
  (void)m; // 결과만 검사: 크래시/UB 없이 종료가 목표
  return 0;
}
```

빌드/실행:
```bash
clang++ -g -O1 -fsanitize=address,undefined,fuzzer -fno-omit-frame-pointer \
  fuzz/fuzz_parse.cpp src/parser.cpp -o fuzz_parse

mkdir -p seeds
printf "\x01\x00\x00\x00\x00\x00\x00\x00" > seeds/minimal.bin  # type=1,len=0
./fuzz_parse -max_total_time=60 -jobs=4 -workers=4 -artifact_prefix=crashes/ seeds
# 종료 후 crashes/ 디렉터리 확인 (id:..., sig:...)
```

**크래시 triage & 재현**
```bash
./fuzz_parse crashes/id:000003,sig:11,*
# 동일 크래시 반복 재현되면 → test로 편입
```

---

## 12.4.5 수정(패치) — 안전 파서로 리팩터링

```cpp
// src/parser.cpp (수정)
#include "parser.hpp"
#include <cstring>
#include <limits>
#include <bit>       // C++20 bit_cast
#include <optional>

static bool read_u32_le(const uint8_t* p, size_t n, size_t off, uint32_t& out) {
  if (off + 4 > n) return false;
  // 안전한 재해석 (정렬/alias 회피)
  uint32_t tmp;
  std::memcpy(&tmp, p + off, 4);
  // 필요시 엔디안 처리:
  if constexpr (std::endian::native == std::endian::little) {
    out = tmp;
  } else {
    out = ((tmp & 0xFF) << 0) | ((tmp & 0xFF00) >> 8)
        | ((tmp & 0xFF0000) >> 8) | ((tmp & 0xFF000000) >> 24);
  }
  return true;
}

std::optional<Msg> parse_message(const uint8_t* data, size_t n) {
  if (!data || n < 8) return std::nullopt;

  uint32_t type, len;
  if (!read_u32_le(data, n, 0, type)) return std::nullopt;
  if (!read_u32_le(data, n, 4, len))  return std::nullopt;

  constexpr uint32_t kMaxLen = 1<<20; // 1MB 상한
  if (len > kMaxLen) return std::nullopt;
  if (n < 8u + static_cast<size_t>(len)) return std::nullopt;

  std::string payload; payload.resize(len);
  if (len) std::memcpy(payload.data(), data+8, len);

  return Msg{type, std::move(payload)};
}
```

**다시 퍼징**
```bash
clang++ -g -O1 -fsanitize=address,undefined,fuzzer -fno-omit-frame-pointer \
  fuzz/fuzz_parse.cpp src/parser.cpp -o fuzz_parse
./fuzz_parse -max_total_time=60 -artifact_prefix=crashes/ seeds
# 크래시 없음이 목표
```

---

## 12.4.6 크래시 입력을 **회귀 테스트**로 편입

예: `crashes/id:000003,sig:11` 에서 바이트를 `test/crashes/000003.bin`으로 보관:

```cpp
// test/parser_regressions.cpp
#include "src/parser.hpp"
#include <gtest/gtest.h>
#include <fstream>
#include <vector>

static std::vector<uint8_t> load(const char* path) {
  std::ifstream ifs(path, std::ios::binary);
  return std::vector<uint8_t>((std::istreambuf_iterator<char>(ifs)),
                              std::istreambuf_iterator<char>());
}

TEST(ParserRegression, Crash000003) {
  auto buf = load("test/crashes/000003.bin");
  auto m = parse_message(buf.data(), buf.size());
  // 크래시 없이 반환되기만 하면 PASS (성공/실패는 관심 아님)
  SUCCEED();
}
```

**CI에 회귀 테스트 포함**  
- 새 크래시 발생 시 PR에 **재현 입력 추가** → **영구 회귀 방지**.

---

## 12.4.7 CI 파이프라인(요약) — PR에서 자동 실행

**GitHub Actions 예시**
```yaml
name: ci
on: [push, pull_request]
jobs:
  sanitize:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: deps
        run: sudo apt-get update && sudo apt-get install -y clang lld cmake ninja-build libgtest-dev
      - name: build+asan+ubsan
        run: |
          cmake -S . -B build -G Ninja -DCMAKE_CXX_COMPILER=clang++ \
            -DCMAKE_BUILD_TYPE=Debug \
            -DSANITIZE=ON
          cmake --build build -j
      - name: unit
        run: ctest --test-dir build --output-on-failure
      - name: fuzz smoke
        run: ./build/fuzz_parse -runs=10000 seeds || true
```

---

## 12.4.8 크래시 리포트 **읽기·분해** 팁

1) **첫 주소**(fault addr)와 **stack trace 최상단**을 본다 → 유저 코드 위치 고정  
2) **ASan Note**: “READ of size … at … by thread T0” & shadow byte 레이아웃  
3) **UBSan Note**: “load of misaligned address” / “signed integer overflow” 메시지  
4) **환경 이슈**: ODR mismatch / LTO / CFI 충돌 여부 확인  
5) **Fix** 후, 동일 입력 재실행 → “크래시 없음” 확인, 회귀테스트 반영

---

# 12.5 공급망: SBOM, 서명, 정책 게이트(정적 분석/SCA/라이선스)

## 12.5.1 왜 공급망인가?

- 의존성(라이브러리/툴체인/컨테이너/OS 패키지)은 **대부분 외부**에서 온다.  
- **SBOM**(Software Bill of Materials)로 “무엇이 들어갔는지” 목록화,  
  **서명/프로비넌스**로 “누가/어디서/어떻게 만들었는지” 입증,  
  **정책 게이트**로 “취약/라이선스 위반”을 **CI에서 차단**.

---

## 12.5.2 SBOM 생성 (SPDX/CycloneDX)

### 도구 선택
- **Syft**: 바이너리/이미지/폴더에서 SBOM 생성 (SPDX/CycloneDX)  
- **CycloneDX** 빌드 플러그인(Gradle/Maven/…): 언어 생태계 통합  
- C++(vcpkg/Conan)도 `syft dir:` + `grype` 조합으로 탐색 가능

**예: Syft**
```bash
# 프로젝트 디렉터리에서 CycloneDX JSON 생성
syft dir:. -o cyclonedx-json > sbom.cdx.json

# 컨테이너 이미지 SBOM
syft myrepo/app:1.2.3 -o spdx-json > image.spdx.json
```

**메타 포함(버전/SCM)**
- 빌드 시 `git rev-parse HEAD`, `version.txt`를 SBOM `metadata`에 넣도록 스크립팅.

---

## 12.5.3 SCA(취약성) 스캔 & 정책

- **Grype**(앵커): SBOM/이미지/디렉터리 스캔 → CVE 매칭  
- **OSV-Scanner**: 오픈소스 취약 DB(OSV)와 매칭  
- **Dependency-Track**(서버): CycloneDX 업로드 → 지속 모니터

**예: Grype**
```bash
grype sbom:sbom.cdx.json --fail-on high
# high 이상 있으면 비정상 종료 → CI gate
```

**OSV-Scanner** (예: `conanfile.txt` / `vcpkg.json` 기반)
```bash
osv-scanner -r .
```

**정책 예**
- **Fail**: `critical` 1건 이상, `high` 3건 이상, **Fix version 존재**  
- **Warn**: `low/medium` 합계 10건↑ or EOL 패키지 발견  
- **Ignore**: 벤더 패치로 false positive → **시간 제한 예외(만료일 필수)**

---

## 12.5.4 라이선스 컴플라이언스 (정책 게이트)

- **목표**: 의존성 라이선스가 **조직의 허용 정책**(예: MIT/BSD/Apache-2.0 허용, GPL-3.0 제한)에 부합하는지 CI에서 자동 검증.
- **도구**:  
  - **ORT(OSS Review Toolkit)**: 스캔/정책/저장소 라이선스 검출  
  - **FOSSology**, **scancode-toolkit**(정밀 스캔)  
  - Syft도 라이선스 필드를 추출 가능

**ORT 예(요약)**
```bash
ort analyze -i . -o ort-out/
ort evaluate -i ort-out/analyzer-result.yml -o ort-out/eval/ \
  --rules-resource src/ort-policy/rules.kts
# 평가 결과에 따라 CI 실패
```

**정책 팁**
- 예외(Allowlist)는 **PR로 추가** + **만료일** + **근거 링크**  
- 빌드 산출물에 **NOTICE/THIRD-PARTY 파일** 자동 생성

---

## 12.5.5 서명(Signing) & 프로비넌스 (Sigstore/cosign, SLSA)

- **cosign**: 컨테이너 이미지/파일 서명 + **공개 키/키리스(OIDC)**  
- **SLSA/Provenance**: “누가 어느 빌드에서 만들었는가” 공급망 문맥 제공  
- **in-toto attestations**: 빌드·테스트·스캔 결과를 **증빙(Attestation)**으로 첨부

**cosign 예**
```bash
# 이미지 서명 (OIDC 키리스 예) — GitHub Actions OIDC 연동 가능
cosign sign myrepo/app:1.2.3

# 이미지 검증
cosign verify myrepo/app:1.2.3

# 아티팩트(바이너리) 서명
cosign sign-blob --output-signature app.sig --output-certificate app.crt ./build/app
cosign verify-blob --certificate app.crt --signature app.sig ./build/app
```

**SLSA provenance(개요)**  
- 빌드 시스템(GitHub Actions/GitLab CI)에서 **발행** → 릴리즈에 첨부  
- 정책: “**서명 + provenance 없는 아티팩트 배포 금지**” 게이트

---

## 12.5.6 정적 분석(SAST) & 포맷 보안(Format Security)

- **clang-tidy/clang-analyzer**, **cppcheck**: C++ 기본 SAST  
- **Semgrep**: 레포지토리 레벨 패턴 룰(위험 API/포맷 문자열/경계 체크)  
- **-Wformat -Wformat-security** + `{fmt}` 사용 권장

**Semgrep 예(`semgrep-ci.yml`)**
```yaml
rules:
  - id: c-unsafe-memcpy
    languages: [c, c++]
    patterns:
      - pattern: memcpy($DST, $SRC, $N)
    message: "Use bounds-checked copy or validate $N."
    severity: ERROR
```

CI 단계에서:
```bash
semgrep ci --config p/ci --config semgrep-rules/
```

---

## 12.5.7 정책 게이트(조립)

**GitHub Actions(요약)**
```yaml
name: supplychain
on: [push, pull_request]
jobs:
  sbom-sca-license:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b . v1.17.0
          ./syft dir:. -o cyclonedx-json > sbom.cdx.json
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b . v0.76.0
          ./grype sbom:sbom.cdx.json --fail-on high
      - name: semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: p/default
  sign:
    needs: [sbom-sca-license]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: build
        run: |
          cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
          cmake --build build -j
      - name: cosign install
        run: |
          COSIGN_VERSION=v2.2.4
          curl -sSL -o cosign.tgz https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64.tar.gz
          tar xzf cosign.tgz && sudo mv cosign /usr/local/bin/
      - name: sign binary
        run: cosign sign-blob --yes --output-signature build/app.sig build/app
```

**게이트 성공 조건**  
- SCA: `high` 없음 / `critical` 없음  
- SAST: `ERROR` 0  
- 라이선스: 정책 위반 0 (예외는 만료일 동반)  
- 서명: 성공 + 검증 통과  
- SBOM: 릴리즈 아티팩트에 첨부

---

## 12.5.8 컨테이너 이미지 하드닝 & 정책

- **FROM distroless/ubi-minimal** 등 **슬림 베이스**  
- **non-root** 사용자, **읽기 전용 파일시스템**, **drop capabilities**  
- **SBOM 내장**(OCI artifact), **서명 + attestations**  
- **실행 정책**: Admission Controller(Gatekeeper/Kyverno)로  
  - “서명 검증 실패 이미지 배포 금지”  
  - “SBOM 첨부 없는 이미지 배포 금지”

**Dockerfile(요약)**
```dockerfile
FROM gcr.io/distroless/cc
USER 65532:65532
COPY app /usr/local/bin/app
ENTRYPOINT ["/usr/local/bin/app"]
```

Kubernetes 배포 전 Gate(개요):
- Kyverno 정책: `verifyImages`로 Cosign 검증  
- OPA Gatekeeper: 레이블/어노테이션으로 SBOM 링크 강제

---

## 12.5.9 운영 체크리스트

**개발/PR**
- [ ] ASan/UBSan on, libFuzzer smoke, clang-tidy, Semgrep  
- [ ] 크래시 입력은 즉시 `test/crashes/` 편입

**릴리즈**
- [ ] 하드닝 플래그 on(PIE/RELRO/NOW/NOEXECSTACK/CFG/CET)  
- [ ] SBOM 생성(CycloneDX/SPDX), 아티팩트 서명, provenance 첨부

**정책**
- [ ] SCA Fail-on(high↑), 라이선스 정책, 만료일 있는 예외  
- [ ] 컨테이너 non-root/rofs/caps-drop, 서명 검증 Admission

**감사**
- [ ] 릴리즈 태그에 SBOM/서명/attestations 링크  
- [ ] 릴리즈 노트에 CVE 영향 평가/업데이트 가이드

---

# 부록 A. 최소 CMake 프리셋(테스트·퍼저·하드닝 분리)
```cmake
cmake_minimum_required(VERSION 3.20)
project(secureparse LANGUAGES CXX)

option(SANITIZE "Enable ASan/UBSan" OFF)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

if (MSVC)
  add_compile_options(/W4 /permissive- /EHsc /utf-8)
  if (SANITIZE)
    add_compile_options(/fsanitize=address)
    add_link_options(/fsanitize=address)
  else()
    add_compile_options(/sdl /GS /guard:cf /CETCOMPAT)
    add_link_options(/DYNAMICBASE /NXCOMPAT /guard:cf /CETCOMPAT /HIGHENTROPYVA)
  endif()
else()
  add_compile_options(-Wall -Wextra -Wpedantic -Wformat -Wformat-security)
  if (SANITIZE)
    add_compile_options(-O1 -g -fsanitize=address,undefined -fno-omit-frame-pointer)
    add_link_options(-fsanitize=address,undefined)
  else()
    add_compile_options(-O2 -fstack-protector-strong -fstack-clash-protection -D_FORTIFY_SOURCE=3 -fcf-protection=full)
    add_link_options(-Wl,-z,relro -Wl,-z,now -Wl,-z,noexecstack -fPIE -pie)
  endif()
endif()

add_library(parser src/parser.cpp)
target_include_directories(parser PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

add_executable(app src/main.cpp)
target_link_libraries(app PRIVATE parser)

# gtest (패키지 또는 FetchContent)
enable_testing()
add_executable(parser_tests test/parser_test.cpp test/parser_regressions.cpp)
target_link_libraries(parser_tests PRIVATE parser GTest::gtest_main)
add_test(NAME parser_tests COMMAND parser_tests)

# fuzz (Clang 필요)
add_executable(fuzz_parse fuzz/fuzz_parse.cpp)
if (NOT MSVC)
  target_compile_options(fuzz_parse PRIVATE -fsanitize=address,undefined,fuzzer -g -O1 -fno-omit-frame-pointer)
  target_link_options(fuzz_parse PRIVATE -fsanitize=address,undefined,fuzzer)
endif()
target_link_libraries(fuzz_parse PRIVATE parser)
```

---

# 부록 B. 크래시에서 “루트원인”으로

1) **입력 축소(minimize)**: `-minimize_crash=1` / `-merge=1`  
2) **가시성**: `-use_value_profile=1`로 분기 힌트 개선, `-print_final_stats=1`  
3) **스택 정확성**: `-fno-omit-frame-pointer`, 심볼 빌드  
4) **디버그**: `ASAN_OPTIONS=detect_leaks=1:abort_on_error=1`  
5) **패치**: 경계/오버플로/할당 상한/엔디안/정렬/aliasing → 재현 PASS

---

# 결론

- **실습 12.4**는 “취약 코드 → 유닛 + 퍼즈 → ASan/UBSan → 크래시를 회귀로 봉인”까지를 자동화하는 **개발 습관**을 목표로 합니다.  
- **공급망 12.5**는 “SBOM + SCA + 라이선스 + 서명/프로비넌스 + 게이트”로 **릴리즈의 신뢰성**을 보장합니다.  
- 이 두 축을 CI에 **상시 적용**하면, 취약점 유입을 **초기에 차단**하고, 혹시 남은 결함도 **빠르게 탐지·격리**할 수 있습니다.
