---
layout: post
title: íŒŒì´ì¬ ì‹¬í™” - ìœ í‹¸ë¦¬í‹° ìŠ¤í¬ë¦½íŠ¸ì™€ ì‹œìŠ¤í…œ ê´€ë¦¬ (1)
date: 2025-12-06 19:30:23 +0900
category: íŒŒì´ì¬ ì‹¬í™”
---
# ìœ í‹¸ë¦¬í‹° ìŠ¤í¬ë¦½íŠ¸ì™€ ì‹œìŠ¤í…œ ê´€ë¦¬ (1)

ì»¤ë§¨ë“œë¼ì¸ ë„êµ¬ ê°œë°œì€ íŒŒì´ì¬ì˜ ê°•ë ¥í•œ ì‘ìš© ë¶„ì•¼ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ì‚¬ìš©ì ì…ë ¥ ì²˜ë¦¬, ë°ì´í„° íë¦„ ì œì–´, ë³´ì•ˆ ìƒí˜¸ì‘ìš© ë“± ì „ë¬¸ì ì¸ CLI ë„êµ¬ë¥¼ êµ¬ì¶•í•˜ê¸° ìœ„í•œ ì¢…í•©ì ì¸ ê¸°ìˆ ë“¤ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

## í‘œì¤€ ì…ë ¥/ì¶œë ¥ ë¦¬ë‹¤ì´ë ‰ì…˜ê³¼ íŒŒì´í”„ ì²˜ë¦¬

### ê³ ê¸‰ ë¦¬ë‹¤ì´ë ‰ì…˜ ê¸°ìˆ 

```python
import sys
import os
import select
import io
from typing import Optional, TextIO, List, Union
import tempfile
import contextlib

class StreamRedirector:
    """ë‹¤ì–‘í•œ ë¦¬ë‹¤ì´ë ‰ì…˜ íŒ¨í„´ì„ ì§€ì›í•˜ëŠ” í´ë˜ìŠ¤"""
    
    @staticmethod
    def redirect_stdout_to_file(filepath: str) -> contextlib.AbstractContextManager:
        """í‘œì¤€ ì¶œë ¥ì„ íŒŒì¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸"""
        class StdoutRedirector:
            def __init__(self, filepath):
                self.filepath = filepath
                self.original_stdout = None
                self.file = None
            
            def __enter__(self):
                self.original_stdout = sys.stdout
                self.file = open(self.filepath, 'w', encoding='utf-8')
                sys.stdout = self.file
                return self
            
            def __exit__(self, exc_type, exc_val, exc_tb):
                if self.file:
                    self.file.close()
                sys.stdout = self.original_stdout
        
        return StdoutRedirector(filepath)
    
    @staticmethod
    def redirect_stderr_to_stdout() -> contextlib.AbstractContextManager:
        """í‘œì¤€ ì—ëŸ¬ë¥¼ í‘œì¤€ ì¶œë ¥ìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸"""
        class StderrRedirector:
            def __enter__(self):
                self.original_stderr = sys.stderr
                sys.stderr = sys.stdout
                return self
            
            def __exit__(self, exc_type, exc_val, exc_tb):
                sys.stderr = self.original_stderr
        
        return StderrRedirector()
    
    @staticmethod
    def tee_output(filepath: str) -> contextlib.AbstractContextManager:
        """ì¶œë ¥ì„ í™”ë©´ê³¼ íŒŒì¼ì— ë™ì‹œì— ê¸°ë¡ (tee ëª…ë ¹ì–´ ê¸°ëŠ¥)"""
        class TeeOutput:
            def __init__(self, filepath):
                self.filepath = filepath
                self.original_stdout = None
                self.file = None
            
            def write(self, data):
                self.original_stdout.write(data)
                if self.file:
                    self.file.write(data)
            
            def flush(self):
                self.original_stdout.flush()
                if self.file:
                    self.file.flush()
            
            def __enter__(self):
                self.original_stdout = sys.stdout
                self.file = open(self.filepath, 'w', encoding='utf-8')
                sys.stdout = self
                return self
            
            def __exit__(self, exc_type, exc_val, exc_tb):
                sys.stdout = self.original_stdout
                if self.file:
                    self.file.close()
        
        return TeeOutput(filepath)
    
    @staticmethod
    def capture_output() -> contextlib.AbstractContextManager:
        """ì¶œë ¥ì„ ë¬¸ìì—´ë¡œ ìº¡ì²˜"""
        class OutputCapturer:
            def __enter__(self):
                self.buffer = io.StringIO()
                self.original_stdout = sys.stdout
                sys.stdout = self.buffer
                return self
            
            def __exit__(self, exc_type, exc_val, exc_tb):
                sys.stdout = self.original_stdout
            
            def get_output(self) -> str:
                return self.buffer.getvalue()
        
        return OutputCapturer()

def demonstrate_redirection():
    """ë¦¬ë‹¤ì´ë ‰ì…˜ ë°ëª¨"""
    print("=== ë‹¤ì–‘í•œ ë¦¬ë‹¤ì´ë ‰ì…˜ íŒ¨í„´ ===")
    
    redirector = StreamRedirector()
    
    # 1. í‘œì¤€ ì¶œë ¥ì„ íŒŒì¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
    print("\n1. íŒŒì¼ë¡œ ì¶œë ¥ ë¦¬ë‹¤ì´ë ‰íŠ¸:")
    with redirector.redirect_stdout_to_file('output.txt'):
        print("ì´ ë‚´ìš©ì€ output.txt íŒŒì¼ì— ê¸°ë¡ë©ë‹ˆë‹¤")
        print("ì—¬ëŸ¬ ì¤„ë„ ê°€ëŠ¥í•©ë‹ˆë‹¤")
    
    with open('output.txt', 'r', encoding='utf-8') as f:
        print(f"íŒŒì¼ ë‚´ìš©: {f.read()}")
    
    # 2. tee ê¸°ëŠ¥ ë°ëª¨ (í™”ë©´ê³¼ íŒŒì¼ ë™ì‹œ ì¶œë ¥)
    print("\n2. Tee ê¸°ëŠ¥ (í™”ë©´ê³¼ íŒŒì¼ ë™ì‹œ ì¶œë ¥):")
    with redirector.tee_output('tee_output.txt'):
        print("ì´ ë‚´ìš©ì€ í™”ë©´ê³¼ íŒŒì¼ ëª¨ë‘ì— ì¶œë ¥ë©ë‹ˆë‹¤")
        print("Tee ê¸°ëŠ¥ì€ ìœ ë‹‰ìŠ¤ tee ëª…ë ¹ì–´ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤")
    
    # 3. ì¶œë ¥ ìº¡ì²˜
    print("\n3. ì¶œë ¥ ìº¡ì²˜:")
    with redirector.capture_output() as capturer:
        print("ì´ ë‚´ìš©ì€ ìº¡ì²˜ë©ë‹ˆë‹¤")
        result = 42 * 2
        print(f"ê³„ì‚° ê²°ê³¼: {result}")
    
    captured = capturer.get_output()
    print(f"ìº¡ì²˜ëœ ì¶œë ¥:\n{captured}")
    
    # 4. stderrë¥¼ stdoutìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
    print("\n4. í‘œì¤€ ì—ëŸ¬ë¥¼ í‘œì¤€ ì¶œë ¥ìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸:")
    with redirector.redirect_stderr_to_stdout():
        print("ì¼ë°˜ ë©”ì‹œì§€")
        print("ì—ëŸ¬ ë©”ì‹œì§€", file=sys.stderr)

# ë°ëª¨ ì‹¤í–‰
demonstrate_redirection()
```

### íŒŒì´í”„ ì²˜ë¦¬ì™€ ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë°

```python
import subprocess
import threading
from queue import Queue
from typing import Callable, Optional

class PipeProcessor:
    """ê³ ê¸‰ íŒŒì´í”„ ì²˜ë¦¬ í´ë˜ìŠ¤"""
    
    @staticmethod
    def pipe_through_command(
        input_data: str,
        command: List[str],
        timeout: Optional[float] = None
    ) -> str:
        """ë°ì´í„°ë¥¼ ì™¸ë¶€ ëª…ë ¹ì–´ë¡œ íŒŒì´í•‘"""
        try:
            process = subprocess.Popen(
                command,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8'
            )
            
            stdout, stderr = process.communicate(
                input=input_data,
                timeout=timeout
            )
            
            if process.returncode != 0:
                raise subprocess.CalledProcessError(
                    process.returncode,
                    command,
                    stdout,
                    stderr
                )
            
            return stdout
        
        except subprocess.TimeoutExpired:
            process.kill()
            raise
    
    @staticmethod
    def bidirectional_pipe(
        command: List[str],
        input_handler: Callable[[str], str],
        output_handler: Callable[[str], None],
        error_handler: Optional[Callable[[str], None]] = None
    ):
        """ì–‘ë°©í–¥ íŒŒì´í”„ (ìƒí˜¸ì‘ìš© ê°€ëŠ¥í•œ í”„ë¡œì„¸ìŠ¤)"""
        process = subprocess.Popen(
            command,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE if error_handler else subprocess.DEVNULL,
            text=True,
            encoding='utf-8',
            bufsize=1  # ë¼ì¸ ë²„í¼ë§
        )
        
        def writer():
            """ì…ë ¥ ì“°ê¸° ìŠ¤ë ˆë“œ"""
            try:
                while True:
                    # ì…ë ¥ ìƒì„±
                    user_input = input_handler("")
                    if user_input is None:
                        break
                    
                    process.stdin.write(user_input + '\n')
                    process.stdin.flush()
                    
                    if user_input.lower() == 'exit':
                        break
            except BrokenPipeError:
                pass
            finally:
                process.stdin.close()
        
        def reader():
            """ì¶œë ¥ ì½ê¸° ìŠ¤ë ˆë“œ"""
            for line in iter(process.stdout.readline, ''):
                output_handler(line.rstrip('\n'))
            process.stdout.close()
        
        def error_reader():
            """ì—ëŸ¬ ì½ê¸° ìŠ¤ë ˆë“œ"""
            if error_handler and process.stderr:
                for line in iter(process.stderr.readline, ''):
                    error_handler(line.rstrip('\n'))
                process.stderr.close()
        
        # ìŠ¤ë ˆë“œ ì‹œì‘
        writer_thread = threading.Thread(target=writer, daemon=True)
        reader_thread = threading.Thread(target=reader, daemon=True)
        
        writer_thread.start()
        reader_thread.start()
        
        if error_handler:
            error_thread = threading.Thread(target=error_reader, daemon=True)
            error_thread.start()
        
        # í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ëŒ€ê¸°
        writer_thread.join()
        process.wait()
        reader_thread.join()
        
        return process.returncode
    
    @staticmethod
    def pipeline_multiple_commands(
        input_data: str,
        commands: List[List[str]],
        timeout_per_command: Optional[float] = None
    ) -> str:
        """ì—¬ëŸ¬ ëª…ë ¹ì–´ë¥¼ ì—°ê²°í•œ íŒŒì´í”„ë¼ì¸"""
        if not commands:
            return input_data
        
        # ì²« ë²ˆì§¸ í”„ë¡œì„¸ìŠ¤
        first_process = subprocess.Popen(
            commands[0],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True,
            encoding='utf-8'
        )
        
        # ì¤‘ê°„ í”„ë¡œì„¸ìŠ¤ë“¤
        processes = [first_process]
        
        for i, cmd in enumerate(commands[1:]):
            prev_process = processes[-1]
            
            current_process = subprocess.Popen(
                cmd,
                stdin=prev_process.stdout,
                stdout=subprocess.PIPE,
                text=True,
                encoding='utf-8'
            )
            
            processes.append(current_process)
            
            # ì´ì „ í”„ë¡œì„¸ìŠ¤ì˜ stdoutì„ ë‹«ì•„ íŒŒì´í”„ ì‹ í˜¸ ì „ë‹¬
            prev_process.stdout.close()
        
        # ì…ë ¥ ì“°ê¸°
        try:
            stdout, _ = first_process.communicate(
                input=input_data,
                timeout=timeout_per_command
            )
        except subprocess.TimeoutExpired:
            for p in processes:
                p.kill()
            raise
        
        # ì¤‘ê°„ í”„ë¡œì„¸ìŠ¤ë“¤ ëŒ€ê¸°
        for i, process in enumerate(processes[1:], 1):
            try:
                process.wait(timeout=timeout_per_command)
            except subprocess.TimeoutExpired:
                for p in processes[i:]:
                    p.kill()
                raise
        
        # ë§ˆì§€ë§‰ í”„ë¡œì„¸ìŠ¤ ì¶œë ¥ ì½ê¸°
        final_output = processes[-1].communicate()[0]
        
        return final_output

def demonstrate_pipes():
    """íŒŒì´í”„ ì²˜ë¦¬ ë°ëª¨"""
    print("\n=== ê³ ê¸‰ íŒŒì´í”„ ì²˜ë¦¬ ===")
    
    processor = PipeProcessor()
    
    # 1. ë‹¨ìˆœ íŒŒì´í”„
    print("\n1. ë‹¨ì¼ ëª…ë ¹ì–´ íŒŒì´í•‘:")
    input_text = "hello\nworld\ntest\nlines\n"
    result = processor.pipe_through_command(
        input_text,
        ['grep', '-i', 'lo'],  # 'lo'ê°€ í¬í•¨ëœ ë¼ì¸ í•„í„°ë§
        timeout=5
    )
    print(f"ì…ë ¥:\n{input_text}")
    print(f"grep 'lo' ê²°ê³¼:\n{result}")
    
    # 2. íŒŒì´í”„ë¼ì¸ (ì—¬ëŸ¬ ëª…ë ¹ì–´ ì—°ê²°)
    print("\n2. íŒŒì´í”„ë¼ì¸ (ì •ë ¬ í›„ ìœ ë‹ˆí¬ í•„í„°ë§):")
    data = "banana\napple\ncherry\nbanana\napple\ndate\n"
    pipeline_result = processor.pipeline_multiple_commands(
        data,
        [
            ['sort'],      # ì •ë ¬
            ['uniq'],      # ì¤‘ë³µ ì œê±°
            ['head', '-3'] # ìƒìœ„ 3ê°œ
        ],
        timeout=5
    )
    print(f"ì›ë³¸ ë°ì´í„°:\n{data}")
    print(f"íŒŒì´í”„ë¼ì¸ ê²°ê³¼:\n{pipeline_result}")
    
    # 3. ì–‘ë°©í–¥ íŒŒì´í”„ ë°ëª¨ (ê°„ë‹¨í•œ ê³„ì‚°ê¸°ì™€ ìƒí˜¸ì‘ìš©)
    print("\n3. ì–‘ë°©í–¥ íŒŒì´í”„ ë°ëª¨ (bc ê³„ì‚°ê¸°):")
    
    def provide_input(prompt):
        # ê°„ë‹¨í•œ ì…ë ¥ ì‹œë®¬ë ˆì´ì…˜
        inputs = ["2 + 2", "5 * 3", "scale=2", "10 / 3", "exit"]
        for inp in inputs:
            yield inp
    
    input_gen = provide_input("")
    
    def input_handler(prompt):
        try:
            return next(input_gen)
        except StopIteration:
            return None
    
    output_lines = []
    def output_handler(line):
        output_lines.append(line)
        print(f"ê³„ì‚°ê¸° ì¶œë ¥: {line}")
    
    # bc ê³„ì‚°ê¸°ì™€ ìƒí˜¸ì‘ìš©
    try:
        return_code = processor.bidirectional_pipe(
            ['bc', '-l'],  # ë¦¬ëˆ…ìŠ¤ ê³„ì‚°ê¸°
            input_handler,
            output_handler
        )
        print(f"ê³„ì‚°ê¸° ì¢…ë£Œ ì½”ë“œ: {return_code}")
    except FileNotFoundError:
        print("ì°¸ê³ : ì´ ë°ëª¨ëŠ” bc ëª…ë ¹ì–´ê°€ í•„ìš”í•œ ì‹œìŠ¤í…œì—ì„œë§Œ ì‘ë™í•©ë‹ˆë‹¤")

# íŒŒì´í”„ ë°ëª¨ ì‹¤í–‰
demonstrate_pipes()
```

## ë‹¤ì–‘í•œ ì…ë ¥ ì†ŒìŠ¤ ì²˜ë¦¬

### íŒŒì¼, í‘œì¤€ ì…ë ¥, ë¬¸ìì—´ ì…ë ¥ í†µí•© ì²˜ë¦¬

```python
import argparse
import sys
import os
from pathlib import Path
from typing import Iterator, Union, Optional
import gzip
import bz2
import lzma

class UniversalInputReader:
    """ë‹¤ì–‘í•œ ì…ë ¥ ì†ŒìŠ¤ë¥¼ í†µí•© ì²˜ë¦¬í•˜ëŠ” í´ë˜ìŠ¤"""
    
    SUPPORTED_COMPRESSION = {
        '.gz': gzip,
        '.bz2': bz2,
        '.xz': lzma,
        '.lzma': lzma
    }
    
    def __init__(self, encoding: str = 'utf-8'):
        self.encoding = encoding
    
    def read_input(self, source: Optional[Union[str, Path]] = None) -> Iterator[str]:
        """ì…ë ¥ ì†ŒìŠ¤ë¡œë¶€í„° ë°ì´í„° ì½ê¸°"""
        if source is None:
            # í‘œì¤€ ì…ë ¥ì—ì„œ ì½ê¸°
            yield from self._read_stdin()
        elif source == '-':
            # '-'ëŠ” í‘œì¤€ ì…ë ¥ì„ ì˜ë¯¸
            yield from self._read_stdin()
        else:
            # íŒŒì¼ì—ì„œ ì½ê¸°
            yield from self._read_file(source)
    
    def _read_stdin(self) -> Iterator[str]:
        """í‘œì¤€ ì…ë ¥ ì½ê¸°"""
        # í‘œì¤€ ì…ë ¥ì´ í„°ë¯¸ë„ì¸ì§€ í™•ì¸
        if sys.stdin.isatty():
            # ëŒ€í™”í˜• ì…ë ¥ ëª¨ë“œ
            print("í‘œì¤€ ì…ë ¥ ëª¨ë“œ (ì¢…ë£Œ: Ctrl+D ë˜ëŠ” ë¹ˆ ì¤„)")
            try:
                while True:
                    try:
                        line = input()
                        if not line.strip():  # ë¹ˆ ì¤„ë¡œ ì¢…ë£Œ
                            break
                        yield line
                    except EOFError:
                        break
            except KeyboardInterrupt:
                print("\nì…ë ¥ ì¤‘ë‹¨ë¨")
                sys.exit(1)
        else:
            # íŒŒì´í”„ë‚˜ ë¦¬ë‹¤ì´ë ‰ì…˜ì„ í†µí•œ ì…ë ¥
            for line in sys.stdin:
                yield line.rstrip('\n')
    
    def _read_file(self, filepath: Union[str, Path]) -> Iterator[str]:
        """íŒŒì¼ ì½ê¸° (ì••ì¶• íŒŒì¼ ìë™ ê°ì§€)"""
        filepath = Path(filepath)
        
        if not filepath.exists():
            raise FileNotFoundError(f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: {filepath}")
        
        # ì••ì¶• í¬ë§· ê°ì§€
        suffix = filepath.suffix.lower()
        
        if suffix in self.SUPPORTED_COMPRESSION:
            # ì••ì¶• íŒŒì¼ ì²˜ë¦¬
            module = self.SUPPORTED_COMPRESSION[suffix]
            with module.open(filepath, 'rt', encoding=self.encoding) as f:
                for line in f:
                    yield line.rstrip('\n')
        else:
            # ì¼ë°˜ í…ìŠ¤íŠ¸ íŒŒì¼
            with open(filepath, 'r', encoding=self.encoding) as f:
                for line in f:
                    yield line.rstrip('\n')
    
    def read_chunked(self, source: Optional[Union[str, Path]] = None, 
                     chunk_size: int = 8192) -> Iterator[bytes]:
        """ë°”ì´ë„ˆë¦¬ ì²­í¬ ë‹¨ìœ„ë¡œ ì½ê¸°"""
        if source is None or source == '-':
            # í‘œì¤€ ì…ë ¥ì—ì„œ ë°”ì´ë„ˆë¦¬ ì½ê¸°
            while True:
                chunk = sys.stdin.buffer.read(chunk_size)
                if not chunk:
                    break
                yield chunk
        else:
            # íŒŒì¼ì—ì„œ ë°”ì´ë„ˆë¦¬ ì½ê¸°
            filepath = Path(source)
            with open(filepath, 'rb') as f:
                while True:
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break
                    yield chunk
    
    def read_structured(self, source: Optional[Union[str, Path]] = None,
                       format: str = 'lines') -> Union[Iterator[str], list]:
        """êµ¬ì¡°í™”ëœ í˜•ì‹ìœ¼ë¡œ ì½ê¸°"""
        if format == 'lines':
            return self.read_input(source)
        elif format == 'all':
            # ì „ì²´ ë‚´ìš©ì„ í•œ ë²ˆì— ì½ê¸°
            if source is None or source == '-':
                return sys.stdin.read()
            else:
                with open(source, 'r', encoding=self.encoding) as f:
                    return f.read()
        elif format == 'csv':
            # CSV í˜•ì‹ìœ¼ë¡œ íŒŒì‹± (ê°„ë‹¨í•œ ë²„ì „)
            import csv
            if source is None or source == '-':
                reader = csv.reader(sys.stdin)
            else:
                with open(source, 'r', encoding=self.encoding) as f:
                    reader = csv.reader(f)
            
            for row in reader:
                yield row
        else:
            raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” í˜•ì‹: {format}")

class InputProcessor:
    """ì…ë ¥ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸"""
    
    def __init__(self):
        self.reader = UniversalInputReader()
        self.filters = []
        self.transformers = []
    
    def add_filter(self, filter_func: Callable[[str], bool]):
        """í•„í„° í•¨ìˆ˜ ì¶”ê°€"""
        self.filters.append(filter_func)
        return self
    
    def add_transformer(self, transform_func: Callable[[str], str]):
        """ë³€í™˜ í•¨ìˆ˜ ì¶”ê°€"""
        self.transformers.append(transform_func)
        return self
    
    def process(self, source: Optional[Union[str, Path]] = None) -> Iterator[str]:
        """ì…ë ¥ ì²˜ë¦¬"""
        for line in self.reader.read_input(source):
            # í•„í„° ì ìš©
            if not all(f(line) for f in self.filters):
                continue
            
            # ë³€í™˜ ì ìš©
            for transformer in self.transformers:
                line = transformer(line)
            
            yield line

def demonstrate_input_processing():
    """ì…ë ¥ ì²˜ë¦¬ ë°ëª¨"""
    print("\n=== ë‹¤ì–‘í•œ ì…ë ¥ ì†ŒìŠ¤ ì²˜ë¦¬ ===")
    
    # í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
    test_data = """apple 5
banana 3
cherry 8
date 2
elderberry 6
fig 4
grape 7"""
    
    with open('test_input.txt', 'w', encoding='utf-8') as f:
        f.write(test_data)
    
    # 1. íŒŒì¼ ì…ë ¥ ì²˜ë¦¬
    print("\n1. íŒŒì¼ì—ì„œ ì½ê¸°:")
    reader = UniversalInputReader()
    print("test_input.txt ë‚´ìš©:")
    for line in reader.read_input('test_input.txt'):
        print(f"  {line}")
    
    # 2. ì…ë ¥ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸
    print("\n2. ì…ë ¥ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸:")
    processor = InputProcessor()
    
    # í•„í„°: ìˆ«ìê°€ 5 ì´ìƒì¸ ë¼ì¸ë§Œ
    processor.add_filter(lambda line: int(line.split()[1]) >= 5)
    
    # ë³€í™˜: ëŒ€ë¬¸ìë¡œ ë³€í™˜
    processor.add_transformer(lambda line: line.upper())
    
    # ë˜ ë‹¤ë¥¸ ë³€í™˜: í˜•ì‹ ë³€ê²½
    processor.add_transformer(
        lambda line: line.replace(' ', ' -> ìˆ˜ëŸ‰: ')
    )
    
    print("ì²˜ë¦¬ ê²°ê³¼ (ìˆ˜ëŸ‰ 5 ì´ìƒ, ëŒ€ë¬¸ì ë³€í™˜):")
    for result in processor.process('test_input.txt'):
        print(f"  {result}")
    
    # 3. í‘œì¤€ ì…ë ¥ ì‹œë®¬ë ˆì´ì…˜
    print("\n3. í‘œì¤€ ì…ë ¥ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜:")
    
    # í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ í‘œì¤€ ì…ë ¥ì„ ë¦¬ë‹¤ì´ë ‰íŠ¸
    import io
    test_input = "ì²« ë²ˆì§¸ ì¤„\në‘ ë²ˆì§¸ ì¤„\nì„¸ ë²ˆì§¸ ì¤„\n"
    
    original_stdin = sys.stdin
    sys.stdin = io.StringIO(test_input)
    
    try:
        print("ì‹œë®¬ë ˆì´ì…˜ëœ ì…ë ¥:")
        for line in reader.read_input():  # source=None (í‘œì¤€ ì…ë ¥)
            print(f"  ì½ìŒ: {line}")
    finally:
        sys.stdin = original_stdin
    
    # 4. ì••ì¶• íŒŒì¼ ì²˜ë¦¬ (gzip ì˜ˆì œ)
    print("\n4. ì••ì¶• íŒŒì¼ ì²˜ë¦¬:")
    
    # gzip íŒŒì¼ ìƒì„±
    import gzip
    with gzip.open('test_input.gz', 'wt', encoding='utf-8') as f:
        f.write("ì••ì¶•ëœ íŒŒì¼ ë‚´ìš©\në‘ ë²ˆì§¸ ì¤„\nì„¸ ë²ˆì§¸ ì¤„\n")
    
    print("gzip íŒŒì¼ ë‚´ìš©:")
    for line in reader.read_input('test_input.gz'):
        print(f"  {line}")
    
    # ì •ë¦¬
    os.remove('test_input.txt')
    os.remove('test_input.gz')

# ì…ë ¥ ì²˜ë¦¬ ë°ëª¨ ì‹¤í–‰
demonstrate_input_processing()
```

## ì—ëŸ¬ ë©”ì‹œì§€ì™€ í•¨ê»˜ í”„ë¡œê·¸ë¨ ì¢…ë£Œ

### ì „ë¬¸ì ì¸ ì—ëŸ¬ ì²˜ë¦¬ ì‹œìŠ¤í…œ

```python
import sys
import traceback
import logging
from enum import Enum
from typing import Optional, Any, Dict
from dataclasses import dataclass
import json

class ExitCode(Enum):
    """í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì½”ë“œ ì •ì˜"""
    SUCCESS = 0
    GENERAL_ERROR = 1
    INVALID_ARGUMENTS = 2
    FILE_NOT_FOUND = 3
    PERMISSION_DENIED = 4
    CONFIGURATION_ERROR = 5
    NETWORK_ERROR = 6
    RESOURCE_UNAVAILABLE = 7
    VALIDATION_ERROR = 8
    TIMEOUT = 9
    UNEXPECTED_ERROR = 255

@dataclass
class ErrorContext:
    """ì—ëŸ¬ ì»¨í…ìŠ¤íŠ¸ ì •ë³´"""
    message: str
    exit_code: ExitCode
    details: Optional[Dict[str, Any]] = None
    show_traceback: bool = False
    suggest_solution: bool = True

class ApplicationError(Exception):
    """ì• í”Œë¦¬ì¼€ì´ì…˜ ì—ëŸ¬ ë² ì´ìŠ¤ í´ë˜ìŠ¤"""
    
    def __init__(self, message: str, exit_code: ExitCode = ExitCode.GENERAL_ERROR,
                 details: Optional[Dict[str, Any]] = None):
        super().__init__(message)
        self.message = message
        self.exit_code = exit_code
        self.details = details or {}
        self.timestamp = time.time()

class ConfigError(ApplicationError):
    """ì„¤ì • ì—ëŸ¬"""
    def __init__(self, message: str, details: Optional[Dict] = None):
        super().__init__(message, ExitCode.CONFIGURATION_ERROR, details)

class ValidationError(ApplicationError):
    """ê²€ì¦ ì—ëŸ¬"""
    def __init__(self, message: str, field: Optional[str] = None):
        details = {'field': field} if field else {}
        super().__init__(message, ExitCode.VALIDATION_ERROR, details)

class CLIErrorHandler:
    """CLI ì—ëŸ¬ í•¸ë“¤ëŸ¬"""
    
    def __init__(self, app_name: str = None, debug: bool = False,
                 log_file: Optional[str] = None):
        self.app_name = app_name or Path(sys.argv[0]).stem
        self.debug = debug
        self.log_file = log_file
        
        # ë¡œê¹… ì„¤ì •
        self.setup_logging()
    
    def setup_logging(self):
        """ë¡œê¹… ì„¤ì •"""
        self.logger = logging.getLogger(self.app_name)
        self.logger.setLevel(logging.DEBUG if self.debug else logging.INFO)
        
        # ì½˜ì†” í•¸ë“¤ëŸ¬
        console_handler = logging.StreamHandler(sys.stderr)
        console_formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s'
        )
        console_handler.setFormatter(console_formatter)
        self.logger.addHandler(console_handler)
        
        # íŒŒì¼ í•¸ë“¤ëŸ¬ (ì§€ì •ëœ ê²½ìš°)
        if self.log_file:
            file_handler = logging.FileHandler(self.log_file, encoding='utf-8')
            file_formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            file_handler.setFormatter(file_formatter)
            self.logger.addHandler(file_handler)
    
    def handle_error(self, error_context: ErrorContext):
        """ì—ëŸ¬ ì²˜ë¦¬ ë° í”„ë¡œê·¸ë¨ ì¢…ë£Œ"""
        # ì—ëŸ¬ ë©”ì‹œì§€ ì¶œë ¥
        self._print_error_message(error_context)
        
        # ë¡œê¹…
        self._log_error(error_context)
        
        # ë””ë²„ê·¸ ì •ë³´ (í•„ìš”í•œ ê²½ìš°)
        if error_context.show_traceback or self.debug:
            self._print_traceback()
        
        # í•´ê²° ì œì•ˆ (í•„ìš”í•œ ê²½ìš°)
        if error_context.suggest_solution:
            self._suggest_solutions(error_context)
        
        # í”„ë¡œê·¸ë¨ ì¢…ë£Œ
        sys.exit(error_context.exit_code.value)
    
    def _print_error_message(self, context: ErrorContext):
        """ì—ëŸ¬ ë©”ì‹œì§€ ì¶œë ¥"""
        lines = []
        
        # ì—ëŸ¬ í—¤ë”
        lines.append(f"\n{'='*60}")
        lines.append(f"{self.app_name} ì˜¤ë¥˜ ë°œìƒ")
        lines.append(f"{'='*60}")
        
        # ì£¼ìš” ë©”ì‹œì§€
        lines.append(f"ğŸ“› ì˜¤ë¥˜: {context.message}")
        
        # ì¢…ë£Œ ì½”ë“œ
        lines.append(f"ğŸš« ì¢…ë£Œ ì½”ë“œ: {context.exit_code.name} ({context.exit_code.value})")
        
        # ìƒì„¸ ì •ë³´
        if context.details:
            lines.append(f"\nğŸ“‹ ìƒì„¸ ì •ë³´:")
            for key, value in context.details.items():
                lines.append(f"  {key}: {value}")
        
        # ì¶œë ¥
        print('\n'.join(lines), file=sys.stderr)
    
    def _log_error(self, context: ErrorContext):
        """ì—ëŸ¬ ë¡œê¹…"""
        log_data = {
            'app': self.app_name,
            'message': context.message,
            'exit_code': context.exit_code.value,
            'exit_code_name': context.exit_code.name,
            'details': context.details,
            'timestamp': time.time()
        }
        
        self.logger.error(json.dumps(log_data, ensure_ascii=False))
        
        # ì—ëŸ¬ ë¡œê·¸ íŒŒì¼ì— ì¶”ê°€ ê¸°ë¡ (ì„ íƒì‚¬í•­)
        if self.log_file:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(f"\n--- ì—ëŸ¬ ë°œìƒ: {time.ctime()} ---\n")
                f.write(f"ë©”ì‹œì§€: {context.message}\n")
                f.write(f"ì¢…ë£Œ ì½”ë“œ: {context.exit_code.value}\n")
                if context.details:
                    f.write(f"ìƒì„¸ ì •ë³´: {json.dumps(context.details, ensure_ascii=False)}\n")
    
    def _print_traceback(self):
        """íŠ¸ë ˆì´ìŠ¤ë°± ì¶œë ¥"""
        print("\nğŸ” íŠ¸ë ˆì´ìŠ¤ë°±:", file=sys.stderr)
        exc_type, exc_value, exc_tb = sys.exc_info()
        if exc_tb:
            traceback.print_exception(exc_type, exc_value, exc_tb, file=sys.stderr)
    
    def _suggest_solutions(self, context: ErrorContext):
        """í•´ê²° ì œì•ˆ ì¶œë ¥"""
        suggestions = self._generate_suggestions(context)
        
        if suggestions:
            print(f"\nğŸ’¡ í•´ê²° ì œì•ˆ:", file=sys.stderr)
            for i, suggestion in enumerate(suggestions, 1):
                print(f"  {i}. {suggestion}", file=sys.stderr)
    
    def _generate_suggestions(self, context: ErrorContext) -> List[str]:
        """ì—ëŸ¬ ìœ í˜•ì— ë”°ë¥¸ í•´ê²° ì œì•ˆ ìƒì„±"""
        suggestions = []
        
        if context.exit_code == ExitCode.FILE_NOT_FOUND:
            suggestions.extend([
                "íŒŒì¼ ê²½ë¡œë¥¼ í™•ì¸í•˜ì„¸ìš”",
                "íŒŒì¼ ì´ë¦„ì˜ ëŒ€ì†Œë¬¸ìë¥¼ í™•ì¸í•˜ì„¸ìš”",
                "í•„ìš”í•œ ê²½ìš° íŒŒì¼ì„ ìƒì„±í•˜ì„¸ìš”"
            ])
        
        elif context.exit_code == ExitCode.PERMISSION_DENIED:
            suggestions.extend([
                "íŒŒì¼/ë””ë ‰í† ë¦¬ ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”",
                "ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰í•´ ë³´ì„¸ìš”",
                "SELinux/AppArmor ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”"
            ])
        
        elif context.exit_code == ExitCode.INVALID_ARGUMENTS:
            suggestions.extend([
                "--help ì˜µì…˜ìœ¼ë¡œ ì‚¬ìš©ë²•ì„ í™•ì¸í•˜ì„¸ìš”",
                "í•„ìˆ˜ ì¸ìê°€ ëª¨ë‘ ì œê³µë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”",
                "ì¸ì í˜•ì‹ì´ ì˜¬ë°”ë¥¸ì§€ í™•ì¸í•˜ì„¸ìš”"
            ])
        
        elif context.exit_code == ExitCode.NETWORK_ERROR:
            suggestions.extend([
                "ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•˜ì„¸ìš”",
                "ë°©í™”ë²½ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”",
                "ëŒ€ìƒ ì„œë¹„ìŠ¤ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”"
            ])
        
        # ë””ë²„ê·¸ ëª¨ë“œ ì œì•ˆ
        if not self.debug:
            suggestions.append("--debug ì˜µì…˜ìœ¼ë¡œ ìì„¸í•œ ì •ë³´ë¥¼ í™•ì¸í•˜ì„¸ìš”")
        
        return suggestions
    
    def exit_with_success(self, message: Optional[str] = None):
        """ì„±ê³µ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì¢…ë£Œ"""
        if message:
            print(f"\nâœ… {message}")
        sys.exit(ExitCode.SUCCESS.value)
    
    def exit_with_warning(self, message: str, exit_code: ExitCode = ExitCode.GENERAL_ERROR):
        """ê²½ê³  ë©”ì‹œì§€ì™€ í•¨ê»˜ ì¢…ë£Œ"""
        print(f"\nâš ï¸  ê²½ê³ : {message}", file=sys.stderr)
        sys.exit(exit_code.value)

# ë°ì½”ë ˆì´í„°ë¥¼ ì´ìš©í•œ ì—ëŸ¬ ì²˜ë¦¬
def cli_error_handler(app_name: str = None, debug: bool = False):
    """CLI ì—ëŸ¬ í•¸ë“¤ëŸ¬ ë°ì½”ë ˆì´í„°"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            handler = CLIErrorHandler(app_name, debug)
            try:
                return func(*args, **kwargs)
            except ApplicationError as e:
                handler.handle_error(ErrorContext(
                    message=e.message,
                    exit_code=e.exit_code,
                    details=e.details,
                    show_traceback=debug
                ))
            except Exception as e:
                handler.handle_error(ErrorContext(
                    message=f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {str(e)}",
                    exit_code=ExitCode.UNEXPECTED_ERROR,
                    show_traceback=True,
                    details={'exception_type': type(e).__name__}
                ))
        return wrapper
    return decorator

def demonstrate_error_handling():
    """ì—ëŸ¬ ì²˜ë¦¬ ë°ëª¨"""
    print("\n=== ì „ë¬¸ì ì¸ ì—ëŸ¬ ì²˜ë¦¬ ì‹œìŠ¤í…œ ===")
    
    handler = CLIErrorHandler("demo_app", debug=False)
    
    # 1. ì¼ë°˜ ì—ëŸ¬ ì²˜ë¦¬
    print("\n1. ì¼ë°˜ ì—ëŸ¬ ì²˜ë¦¬:")
    try:
        raise ConfigError(
            "ì„¤ì • íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
            details={
                'config_path': '/etc/demo_app/config.yaml',
                'alternative_paths': ['~/.config/demo_app/config.yaml']
            }
        )
    except ApplicationError as e:
        handler.handle_error(ErrorContext(
            message=e.message,
            exit_code=e.exit_code,
            details=e.details,
            suggest_solution=True
        ))
    
    # 2. ê²€ì¦ ì—ëŸ¬ ì²˜ë¦¬
    print("\n2. ê²€ì¦ ì—ëŸ¬ ì²˜ë¦¬:")
    try:
        raise ValidationError(
            "ì˜ëª»ëœ ì´ë©”ì¼ í˜•ì‹",
            field="email"
        )
    except ApplicationError as e:
        handler.handle_error(ErrorContext(
            message=e.message,
            exit_code=e.exit_code,
            details=e.details
        ))
    
    # 3. íŒŒì¼ ì—ëŸ¬ ì‹œë®¬ë ˆì´ì…˜
    print("\n3. íŒŒì¼ ì‹œìŠ¤í…œ ì—ëŸ¬:")
    error_context = ErrorContext(
        message="íŒŒì¼ ì“°ê¸° ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤",
        exit_code=ExitCode.PERMISSION_DENIED,
        details={
            'file_path': '/root/important_file.txt',
            'user': os.getenv('USER', 'unknown'),
            'required_permission': 'write'
        },
        suggest_solution=True
    )
    
    # ì§ì ‘ ì—ëŸ¬ ì²˜ë¦¬ (ì‹¤ì œ ì¢…ë£ŒëŠ” í•˜ì§€ ì•ŠìŒ)
    print("ì—ëŸ¬ ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œ ì¢…ë£Œ ì•ˆí•¨):")
    handler._print_error_message(error_context)
    suggestions = handler._generate_suggestions(error_context)
    print(f"ì œì•ˆëœ í•´ê²°ì±…: {suggestions}")

# ì—ëŸ¬ ì²˜ë¦¬ ë°ëª¨ ì‹¤í–‰
demonstrate_error_handling()
```

## ê³ ê¸‰ ì»¤ë§¨ë“œ ë¼ì¸ ì˜µì…˜ íŒŒì‹±

### argparseë¥¼ ë„˜ì–´ì„  ê³ ê¸‰ íŒŒì‹± ê¸°ìˆ 

```python
import argparse
from typing import List, Dict, Any, Optional, Callable
import configparser
import yaml
import json
from pathlib import Path
from dataclasses import dataclass, field
from enum import Enum

class OutputFormat(Enum):
    """ì¶œë ¥ í˜•ì‹"""
    TEXT = "text"
    JSON = "json"
    YAML = "yaml"
    CSV = "csv"
    XML = "xml"

@dataclass
class CommandConfig:
    """ëª…ë ¹ì–´ êµ¬ì„±"""
    name: str
    help: str
    arguments: List[Dict[str, Any]] = field(default_factory=list)
    subcommands: Dict[str, 'CommandConfig'] = field(default_factory=dict)
    epilog: Optional[str] = None
    formatter_class: Any = argparse.RawDescriptionHelpFormatter

class AdvancedArgumentParser:
    """ê³ ê¸‰ ì¸ì íŒŒì„œ"""
    
    def __init__(self, app_name: str, version: str = "1.0.0",
                 description: str = None, epilog: str = None):
        self.app_name = app_name
        self.version = version
        self.parser = argparse.ArgumentParser(
            prog=app_name,
            description=description,
            epilog=epilog,
            formatter_class=argparse.RawDescriptionHelpFormatter,
            add_help=False  # ì»¤ìŠ¤í…€ help ì¶”ê°€
        )
        
        # ê³µí†µ ì˜µì…˜ ê·¸ë£¹
        self.common_group = self.parser.add_argument_group('ê³µí†µ ì˜µì…˜')
        self._add_common_arguments()
        
        # ëª…ë ¹ì–´ë³„ ì„œë¸ŒíŒŒì„œ
        self.subparsers = None
        self.commands: Dict[str, CommandConfig] = {}
        
        # êµ¬ì„± íŒŒì¼ ì„¤ì •
        self.config_paths = [
            f"/etc/{app_name}/config.yaml",
            f"{Path.home()}/.config/{app_name}/config.yaml",
            f"./{app_name}.yaml"
        ]
    
    def _add_common_arguments(self):
        """ê³µí†µ ì¸ì ì¶”ê°€"""
        self.common_group.add_argument(
            '-h', '--help',
            action='store_true',
            help='ë„ì›€ë§ ì¶œë ¥'
        )
        
        self.common_group.add_argument(
            '-V', '--version',
            action='store_true',
            help='ë²„ì „ ì •ë³´ ì¶œë ¥'
        )
        
        self.common_group.add_argument(
            '-v', '--verbose',
            action='count',
            default=0,
            help='ìƒì„¸ ì¶œë ¥ ë ˆë²¨ ì¦ê°€ (ì˜ˆ: -v, -vv, -vvv)'
        )
        
        self.common_group.add_argument(
            '-q', '--quiet',
            action='store_true',
            help='ì¶œë ¥ ì–µì œ'
        )
        
        self.common_group.add_argument(
            '--debug',
            action='store_true',
            help='ë””ë²„ê·¸ ëª¨ë“œ í™œì„±í™”'
        )
        
        self.common_group.add_argument(
            '-c', '--config',
            type=Path,
            help='êµ¬ì„± íŒŒì¼ ê²½ë¡œ'
        )
        
        self.common_group.add_argument(
            '-o', '--output',
            type=Path,
            help='ì¶œë ¥ íŒŒì¼ ê²½ë¡œ'
        )
        
        self.common_group.add_argument(
            '--format',
            choices=[fmt.value for fmt in OutputFormat],
            default=OutputFormat.TEXT.value,
            help='ì¶œë ¥ í˜•ì‹'
        )
    
    def add_command(self, config: CommandConfig):
        """ëª…ë ¹ì–´ ì¶”ê°€"""
        if self.subparsers is None:
            self.subparsers = self.parser.add_subparsers(
                title='ëª…ë ¹ì–´',
                dest='command',
                metavar='COMMAND',
                required=True
            )
        
        # ì„œë¸ŒíŒŒì„œ ìƒì„±
        subparser = self.subparsers.add_parser(
            config.name,
            help=config.help,
            epilog=config.epilog,
            formatter_class=config.formatter_class,
            add_help=False
        )
        
        # ëª…ë ¹ì–´ë³„ ê³µí†µ ì˜µì…˜
        cmd_common = subparser.add_argument_group('ëª…ë ¹ì–´ ì˜µì…˜')
        cmd_common.add_argument('-h', '--help', action='help', help='ë„ì›€ë§ ì¶œë ¥')
        
        # ëª…ë ¹ì–´ë³„ ì¸ì ì¶”ê°€
        for arg_def in config.arguments:
            # ì¸ì ì •ì˜ì—ì„œ í•„ìš”í•œ ë¶€ë¶„ ì¶”ì¶œ
            args = arg_def.get('args', [])
            kwargs = {k: v for k, v in arg_def.items() if k != 'args'}
            
            # íƒ€ì… ë³€í™˜ê¸° ì²˜ë¦¬
            if 'type' in kwargs and isinstance(kwargs['type'], str):
                type_str = kwargs['type']
                if type_str == 'path':
                    kwargs['type'] = Path
                elif type_str == 'int_range':
                    def int_range(value):
                        try:
                            ivalue = int(value)
                            if ivalue < 0 or ivalue > 100:
                                raise argparse.ArgumentTypeError(
                                    "ê°’ì€ 0ì—ì„œ 100 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤"
                                )
                            return ivalue
                        except ValueError:
                            raise argparse.ArgumentTypeError(
                                "ì •ìˆ˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
                            )
                    kwargs['type'] = int_range
                elif type_str == 'existing_file':
                    kwargs['type'] = self._existing_file_type
            
            subparser.add_argument(*args, **kwargs)
        
        self.commands[config.name] = config
        
        # ì„œë¸Œëª…ë ¹ì–´ ì¶”ê°€ (ì¬ê·€ì )
        if config.subcommands:
            self._add_subcommands(subparser, config)
    
    def _add_subcommands(self, parent_parser, parent_config: CommandConfig):
        """ì„œë¸Œëª…ë ¹ì–´ ì¶”ê°€"""
        subparsers = parent_parser.add_subparsers(
            title='ì„œë¸Œëª…ë ¹ì–´',
            dest='subcommand',
            metavar='SUBCOMMAND'
        )
        
        for name, cmd_config in parent_config.subcommands.items():
            subparser = subparsers.add_parser(
                name,
                help=cmd_config.help,
                formatter_class=cmd_config.formatter_class
            )
            
            for arg_def in cmd_config.arguments:
                subparser.add_argument(*arg_def.get('args', []),
                                      **{k: v for k, v in arg_def.items() 
                                         if k != 'args'})
    
    def _existing_file_type(self, filename: str) -> Path:
        """ì¡´ì¬í•˜ëŠ” íŒŒì¼ íƒ€ì… ê²€ì¦"""
        path = Path(filename)
        if not path.exists():
            raise argparse.ArgumentTypeError(f"íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {filename}")
        if not path.is_file():
            raise argparse.ArgumentTypeError(f"íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: {filename}")
        return path
    
    def load_config(self, config_file: Optional[Path] = None) -> Dict[str, Any]:
        """êµ¬ì„± íŒŒì¼ ë¡œë“œ"""
        config_files = []
        
        if config_file:
            config_files.append(config_file)
        else:
            # ê¸°ë³¸ ê²½ë¡œì—ì„œ êµ¬ì„± íŒŒì¼ ì°¾ê¸°
            for path_str in self.config_paths:
                path = Path(path_str).expanduser()
                if path.exists():
                    config_files.append(path)
        
        merged_config = {}
        
        for config_path in config_files:
            if config_path.suffix in ['.yaml', '.yml']:
                with open(config_path, 'r', encoding='utf-8') as f:
                    file_config = yaml.safe_load(f)
            elif config_path.suffix == '.json':
                with open(config_path, 'r', encoding='utf-8') as f:
                    file_config = json.load(f)
            elif config_path.suffix in ['.ini', '.cfg']:
                parser = configparser.ConfigParser()
                parser.read(config_path, encoding='utf-8')
                file_config = {s: dict(parser.items(s)) 
                              for s in parser.sections()}
            else:
                continue
            
            # ì„¤ì • ë³‘í•©
            self._merge_configs(merged_config, file_config)
        
        return merged_config
    
    def _merge_configs(self, base: Dict, new: Dict):
        """ì„¤ì • ë”•ì…”ë„ˆë¦¬ ë³‘í•©"""
        for key, value in new.items():
            if key in base and isinstance(base[key], dict) and isinstance(value, dict):
                self._merge_configs(base[key], value)
            else:
                base[key] = value
    
    def parse_args(self, args: Optional[List[str]] = None):
        """ì¸ì íŒŒì‹±"""
        # ëª…ë ¹ì–´ê°€ ì •ì˜ë˜ì§€ ì•Šì•˜ìœ¼ë©´ help ì¶œë ¥
        if not self.commands and args is None:
            self.parser.print_help()
            sys.exit(0)
        
        parsed = self.parser.parse_args(args)
        
        # ë²„ì „ ì •ë³´ ì¶œë ¥
        if hasattr(parsed, 'version') and parsed.version:
            print(f"{self.app_name} ë²„ì „ {self.version}")
            sys.exit(0)
        
        # ë„ì›€ë§ ì¶œë ¥
        if hasattr(parsed, 'help') and parsed.help:
            if hasattr(parsed, 'command') and parsed.command:
                # ëª…ë ¹ì–´ë³„ ë„ì›€ë§
                for action in self.subparsers._choices_actions:
                    if action.dest == parsed.command:
                        action.choices[parsed.command].print_help()
            else:
                self.parser.print_help()
            sys.exit(0)
        
        # êµ¬ì„± íŒŒì¼ ë¡œë“œ
        config = {}
        if hasattr(parsed, 'config') and parsed.config:
            config = self.load_config(parsed.config)
        elif hasattr(parsed, 'command'):
            # ëª…ë ¹ì–´ë³„ ê¸°ë³¸ êµ¬ì„± íŒŒì¼
            config = self.load_config()
        
        # íŒŒì‹±ëœ ì¸ìì™€ ì„¤ì • ë³‘í•©
        result = {
            'args': vars(parsed),
            'config': config,
            'app': {
                'name': self.app_name,
                'version': self.version
            }
        }
        
        return result
    
    def format_output(self, data: Any, format_type: OutputFormat) -> str:
        """ì¶œë ¥ í˜•ì‹ ë³€í™˜"""
        if format_type == OutputFormat.JSON:
            return json.dumps(data, ensure_ascii=False, indent=2)
        elif format_type == OutputFormat.YAML:
            return yaml.dump(data, allow_unicode=True, default_flow_style=False)
        elif format_type == OutputFormat.TEXT:
            if isinstance(data, dict):
                return '\n'.join(f'{k}: {v}' for k, v in data.items())
            elif isinstance(data, list):
                return '\n'.join(str(item) for item in data)
            else:
                return str(data)
        else:
            return str(data)

def demonstrate_argument_parsing():
    """ì¸ì íŒŒì‹± ë°ëª¨"""
    print("\n=== ê³ ê¸‰ ì»¤ë§¨ë“œë¼ì¸ ì¸ì íŒŒì‹± ===")
    
    # 1. êµ¬ì„± íŒŒì¼ ìƒì„±
    config_data = {
        'database': {
            'host': 'localhost',
            'port': 5432,
            'name': 'mydb'
        },
        'output': {
            'format': 'json',
            'pretty': True
        }
    }
    
    config_path = Path('demo_config.yaml')
    with open(config_path, 'w', encoding='utf-8') as f:
        yaml.dump(config_data, f)
    
    # 2. íŒŒì„œ ì„¤ì •
    parser = AdvancedArgumentParser(
        app_name="demo_cli",
        version="2.1.0",
        description="ë°ëª¨ CLI ë„êµ¬\nê³ ê¸‰ ê¸°ëŠ¥ì„ ê°–ì¶˜ ëª…ë ¹ì¤„ ì¸í„°í˜ì´ìŠ¤",
        epilog="ì˜ˆì œ: demo_cli process --input data.txt --format json"
    )
    
    # 3. ëª…ë ¹ì–´ ì •ì˜
    process_cmd = CommandConfig(
        name="process",
        help="ë°ì´í„° ì²˜ë¦¬",
        arguments=[
            {
                'args': ['input', 'output'],
                'nargs': '?',
                'help': 'ì…ë ¥ ë° ì¶œë ¥ íŒŒì¼ (ì¶œë ¥ ìƒëµ ì‹œ í‘œì¤€ ì¶œë ¥)'
            },
            {
                'args': ['-i', '--input'],
                'type': 'existing_file',
                'help': 'ì…ë ¥ íŒŒì¼'
            },
            {
                'args': ['-t', '--type'],
                'choices': ['csv', 'json', 'xml'],
                'default': 'csv',
                'help': 'ì…ë ¥ íŒŒì¼ í˜•ì‹'
            },
            {
                'args': ['--limit'],
                'type': int,
                'help': 'ì²˜ë¦¬í•  ë ˆì½”ë“œ ìˆ˜ ì œí•œ'
            },
            {
                'args': ['--workers'],
                'type': 'int_range',
                'default': 4,
                'help': 'ì‘ì—…ì ìŠ¤ë ˆë“œ ìˆ˜ (0-100)'
            }
        ]
    )
    
    # ì„œë¸Œëª…ë ¹ì–´ë¥¼ ê°€ì§„ ëª…ë ¹ì–´
    db_cmd = CommandConfig(
        name="database",
        help="ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—…",
        arguments=[
            {
                'args': ['--host'],
                'default': 'localhost',
                'help': 'ë°ì´í„°ë² ì´ìŠ¤ í˜¸ìŠ¤íŠ¸'
            }
        ],
        subcommands={
            'backup': CommandConfig(
                name="backup",
                help="ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…",
                arguments=[
                    {
                        'args': ['--output-dir'],
                        'type': Path,
                        'required': True,
                        'help': 'ë°±ì—… ì¶œë ¥ ë””ë ‰í† ë¦¬'
                    },
                    {
                        'args': ['--compress'],
                        'action': 'store_true',
                        'help': 'ì••ì¶• ì‚¬ìš©'
                    }
                ]
            ),
            'restore': CommandConfig(
                name="restore",
                help="ë°ì´í„°ë² ì´ìŠ¤ ë³µì›",
                arguments=[
                    {
                        'args': ['backup_file'],
                        'type': 'existing_file',
                        'help': 'ë³µì›í•  ë°±ì—… íŒŒì¼'
                    }
                ]
            )
        }
    )
    
    # ëª…ë ¹ì–´ ì¶”ê°€
    parser.add_command(process_cmd)
    parser.add_command(db_cmd)
    
    # 4. ë‹¤ì–‘í•œ ì¸ì íŒŒì‹± ì‹œë®¬ë ˆì´ì…˜
    test_cases = [
        # ì¼€ì´ìŠ¤ 1: ë„ì›€ë§ ìš”ì²­
        ['--help'],
        
        # ì¼€ì´ìŠ¤ 2: ë²„ì „ ì •ë³´
        ['--version'],
        
        # ì¼€ì´ìŠ¤ 3: ëª…ë ¹ì–´ ë„ì›€ë§
        ['process', '--help'],
        
        # ì¼€ì´ìŠ¤ 4: ì‹¤ì œ ëª…ë ¹ì–´ ì‹¤í–‰ (ì‹œë®¬ë ˆì´ì…˜)
        ['process', '--input', 'data.csv', '--limit', '100', '--workers', '8'],
        
        # ì¼€ì´ìŠ¤ 5: êµ¬ì„± íŒŒì¼ê³¼ í•¨ê»˜
        ['--config', 'demo_config.yaml', 'process', '--input', 'test.txt'],
        
        # ì¼€ì´ìŠ¤ 6: ì„œë¸Œëª…ë ¹ì–´
        ['database', 'backup', '--output-dir', '/backups', '--compress']
    ]
    
    print("\nì¸ì íŒŒì‹± í…ŒìŠ¤íŠ¸:")
    for i, test_args in enumerate(test_cases, 1):
        print(f"\ní…ŒìŠ¤íŠ¸ {i}: {' '.join(test_args)}")
        try:
            result = parser.parse_args(test_args)
            if 'args' in result:
                print(f"íŒŒì‹± ê²°ê³¼: {result['args']}")
        except SystemExit:
            # help/versionìœ¼ë¡œ ì¸í•œ ì¢…ë£ŒëŠ” ì •ìƒ
            pass
    
    # 5. ì¶œë ¥ í˜•ì‹ ë°ëª¨
    print("\nì¶œë ¥ í˜•ì‹ ë³€í™˜ ë°ëª¨:")
    sample_data = {
        'name': 'ë°ëª¨',
        'value': 42,
        'items': ['A', 'B', 'C']
    }
    
    for fmt in OutputFormat:
        try:
            formatted = parser.format_output(sample_data, fmt)
            print(f"\n{fmt.value.upper()} í˜•ì‹:")
            print(formatted[:100] + "..." if len(formatted) > 100 else formatted)
        except:
            print(f"\n{fmt.value} í˜•ì‹ ë³€í™˜ ì‹¤íŒ¨")
    
    # ì •ë¦¬
    config_path.unlink()

# ì¸ì íŒŒì‹± ë°ëª¨ ì‹¤í–‰
demonstrate_argument_parsing()
```

## ì•”í˜¸ ì…ë ¥ ë°›ê¸°

### ì•ˆì „í•œ ë¹„ë°€ë²ˆí˜¸ ì²˜ë¦¬ ì‹œìŠ¤í…œ

```python
import getpass
import hashlib
import secrets
import base64
from typing import Optional, Tuple
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import os
import sys
import termios
import tty

class SecurePasswordHandler:
    """ì•ˆì „í•œ ë¹„ë°€ë²ˆí˜¸ ì²˜ë¦¬ê¸°"""
    
    def __init__(self, min_length: int = 8, max_length: int = 128,
                 require_complexity: bool = True):
        self.min_length = min_length
        self.max_length = max_length
        self.require_complexity = require_complexity
        
        # ë¹„ë°€ë²ˆí˜¸ ì •ì±…
        self.complexity_rules = {
            'min_length': min_length,
            'require_lowercase': True,
            'require_uppercase': True,
            'require_digits': True,
            'require_special': True,
            'special_chars': '!@#$%^&*()_+-=[]{}|;:,.<>?'
        }
    
    def get_password(self, prompt: str = "ë¹„ë°€ë²ˆí˜¸: ", 
                     confirm: bool = False,
                     stream=None) -> str:
        """ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ë°›ê¸°"""
        # ê¸°ë³¸ í”„ë¡¬í”„íŠ¸
        if confirm:
            while True:
                password1 = self._get_password_input(prompt, stream)
                password2 = self._get_password_input("í™•ì¸ìš© ë¹„ë°€ë²ˆí˜¸: ", stream)
                
                if password1 == password2:
                    # ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
                    validation = self.validate_password(password1)
                    if validation['valid']:
                        return password1
                    else:
                        print(f"ë¹„ë°€ë²ˆí˜¸ ê²€ì¦ ì‹¤íŒ¨: {validation['message']}")
                else:
                    print("ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
        else:
            password = self._get_password_input(prompt, stream)
            validation = self.validate_password(password)
            if validation['valid']:
                return password
            else:
                raise ValueError(f"ë¹„ë°€ë²ˆí˜¸ ê²€ì¦ ì‹¤íŒ¨: {validation['message']}")
    
    def _get_password_input(self, prompt: str, stream=None) -> str:
        """í”Œë«í¼ë³„ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥"""
        try:
            return getpass.getpass(prompt, stream)
        except getpass.GetPassWarning:
            # ì•ˆì „í•˜ì§€ ì•Šì€ í™˜ê²½ì—ì„œì˜ ê²½ê³ 
            print("ê²½ê³ : ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ì´ ì•ˆì „í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤", file=sys.stderr)
            return getpass.getpass(prompt, stream)
    
    def validate_password(self, password: str) -> dict:
        """ë¹„ë°€ë²ˆí˜¸ ë³µì¡ì„± ê²€ì¦"""
        errors = []
        
        # ê¸¸ì´ ê²€ì‚¬
        if len(password) < self.min_length:
            errors.append(f"ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ {self.min_length}ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
        
        if len(password) > self.max_length:
            errors.append(f"ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœëŒ€ {self.max_length}ì ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
        
        # ë³µì¡ì„± ê²€ì‚¬ (í•„ìš”í•œ ê²½ìš°)
        if self.require_complexity:
            import re
            
            if self.complexity_rules['require_lowercase']:
                if not re.search(r'[a-z]', password):
                    errors.append("ì†Œë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤")
            
            if self.complexity_rules['require_uppercase']:
                if not re.search(r'[A-Z]', password):
                    errors.append("ëŒ€ë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤")
            
            if self.complexity_rules['require_digits']:
                if not re.search(r'\d', password):
                    errors.append("ìˆ«ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤")
            
            if self.complexity_rules['require_special']:
                special_chars = re.escape(self.complexity_rules['special_chars'])
                if not re.search(f'[{special_chars}]', password):
                    errors.append("íŠ¹ìˆ˜ë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤")
        
        # ì¼ë°˜ì ì¸ ì•½í•œ ë¹„ë°€ë²ˆí˜¸ ê²€ì‚¬
        weak_passwords = [
            'password', '123456', 'qwerty', 'admin',
            'welcome', 'password123', 'abc123'
        ]
        
        if password.lower() in weak_passwords:
            errors.append("ë„ˆë¬´ ì¼ë°˜ì ì¸ ë¹„ë°€ë²ˆí˜¸ì…ë‹ˆë‹¤")
        
        # ì—°ì†ëœ ë¬¸ì ê²€ì‚¬
        if re.search(r'(.)\1{2,}', password):
            errors.append("ë™ì¼í•œ ë¬¸ìê°€ 3íšŒ ì´ìƒ ì—°ì†ë©ë‹ˆë‹¤")
        
        # ì‚¬ì „ ë‹¨ì–´ ê²€ì‚¬ (ê°„ë‹¨í•œ ë²„ì „)
        common_words = ['secret', 'pass', 'login', 'user']
        for word in common_words:
            if word in password.lower():
                errors.append(f"ë„ˆë¬´ ì¼ë°˜ì ì¸ ë‹¨ì–´ '{word}'ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤")
        
        return {
            'valid': len(errors) == 0,
            'message': '; '.join(errors) if errors else 'ìœ íš¨í•œ ë¹„ë°€ë²ˆí˜¸',
            'errors': errors,
            'score': self._calculate_password_strength(password)
        }
    
    def _calculate_password_strength(self, password: str) -> int:
        """ë¹„ë°€ë²ˆí˜¸ ê°•ë„ ê³„ì‚° (0-100)"""
        score = 0
        
        # ê¸¸ì´ ì ìˆ˜
        length = len(password)
        if length >= 8:
            score += 10
        if length >= 12:
            score += 10
        if length >= 16:
            score += 10
        
        # ë¬¸ì ì¢…ë¥˜ ë‹¤ì–‘ì„±
        import string
        
        char_categories = {
            'lower': string.ascii_lowercase,
            'upper': string.ascii_uppercase,
            'digits': string.digits,
            'special': string.punctuation
        }
        
        for category, chars in char_categories.items():
            if any(c in chars for c in password):
                score += 5
        
        # ì—”íŠ¸ë¡œí”¼ ê³„ì‚° (ê°„ë‹¨í•œ ë²„ì „)
        import math
        
        # ì‚¬ìš©ëœ ë¬¸ì ì§‘í•© í¬ê¸°
        char_set_size = len(set(password))
        if char_set_size > 10:
            score += min(20, char_set_size)
        
        # íŒ¨í„´ ê²€ì‚¬ ê°ì 
        patterns = [
            r'0123', r'1234', r'2345', r'3456', r'4567', r'5678', r'6789',
            r'qwerty', r'asdfgh', r'zxcvbn'
        ]
        
        password_lower = password.lower()
        for pattern in patterns:
            if pattern in password_lower:
                score -= 10
        
        # ìµœì†Œ/ìµœëŒ€ ì ìˆ˜ ì œí•œ
        return max(0, min(100, score))
    
    def hash_password(self, password: str, salt: Optional[bytes] = None) -> Tuple[str, str]:
        """ë¹„ë°€ë²ˆí˜¸ í•´ì‹±"""
        # ì†”íŠ¸ ìƒì„± (ì—†ëŠ” ê²½ìš°)
        if salt is None:
            salt = secrets.token_bytes(16)
        
        # PBKDF2-HMAC-SHA256 ì‚¬ìš©
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        salt_b64 = base64.b64encode(salt).decode('utf-8')
        
        return key.decode('utf-8'), salt_b64
    
    def verify_password(self, password: str, hashed: str, salt_b64: str) -> bool:
        """ë¹„ë°€ë²ˆí˜¸ ê²€ì¦"""
        try:
            salt = base64.b64decode(salt_b64)
            new_hash, _ = self.hash_password(password, salt)
            return secrets.compare_digest(new_hash, hashed)
        except:
            return False
    
    def generate_encryption_key(self, password: str, salt: Optional[bytes] = None) -> bytes:
        """ì•”í˜¸í™” í‚¤ ìƒì„±"""
        if salt is None:
            salt = secrets.token_bytes(16)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        return key
    
    def create_password_vault(self, master_password: str) -> 'PasswordVault':
        """ë¹„ë°€ë²ˆí˜¸ ë³¼íŠ¸ ìƒì„±"""
        return PasswordVault(master_password, self)

class PasswordVault:
    """ë¹„ë°€ë²ˆí˜¸ ì €ì¥ì†Œ"""
    
    def __init__(self, master_password: str, handler: SecurePasswordHandler):
        self.handler = handler
        self.master_key = handler.generate_encryption_key(master_password)
        self.cipher = Fernet(self.master_key)
        self.entries = {}
    
    def add_entry(self, name: str, username: str, password: str, 
                  url: Optional[str] = None, notes: Optional[str] = None):
        """í•­ëª© ì¶”ê°€"""
        # ë¹„ë°€ë²ˆí˜¸ ì•”í˜¸í™”
        encrypted_password = self.cipher.encrypt(password.encode()).decode('utf-8')
        
        self.entries[name] = {
            'username': username,
            'password': encrypted_password,
            'url': url,
            'notes': notes,
            'created': time.time(),
            'updated': time.time()
        }
    
    def get_entry(self, name: str) -> Optional[dict]:
        """í•­ëª© ì¡°íšŒ"""
        if name not in self.entries:
            return None
        
        entry = self.entries[name].copy()
        # ë¹„ë°€ë²ˆí˜¸ ë³µí˜¸í™”
        entry['password'] = self.cipher.decrypt(
            entry['password'].encode()
        ).decode('utf-8')
        
        return entry
    
    def export_vault(self, filepath: Path):
        """ë³¼íŠ¸ ë‚´ë³´ë‚´ê¸°"""
        data = {
            'entries': self.entries,
            'metadata': {
                'version': '1.0',
                'exported': time.time()
            }
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    
    def import_vault(self, filepath: Path):
        """ë³¼íŠ¸ ê°€ì ¸ì˜¤ê¸°"""
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        if 'entries' in data:
            self.entries.update(data['entries'])

def demonstrate_password_handling():
    """ë¹„ë°€ë²ˆí˜¸ ì²˜ë¦¬ ë°ëª¨"""
    print("\n=== ì•ˆì „í•œ ë¹„ë°€ë²ˆí˜¸ ì²˜ë¦¬ ===")
    
    handler = SecurePasswordHandler(
        min_length=8,
        require_complexity=True
    )
    
    # 1. ë¹„ë°€ë²ˆí˜¸ ê²€ì¦ ë°ëª¨
    print("\n1. ë¹„ë°€ë²ˆí˜¸ ê²€ì¦:")
    test_passwords = [
        "weak",
        "password123",
        "StrongPass1!",
        "VeryStrongPassword123!@#"
    ]
    
    for pwd in test_passwords:
        result = handler.validate_password(pwd)
        print(f"{pwd}: {'ìœ íš¨' if result['valid'] else 'ë¬´íš¨'} "
              f"(ê°•ë„: {result['score']}/100, ë©”ì‹œì§€: {result['message']})")
    
    # 2. ë¹„ë°€ë²ˆí˜¸ í•´ì‹± ë° ê²€ì¦
    print("\n2. ë¹„ë°€ë²ˆí˜¸ í•´ì‹±:")
    password = "MySecurePassword123!"
    hashed, salt = handler.hash_password(password)
    
    print(f"ì›ë³¸ ë¹„ë°€ë²ˆí˜¸: {password}")
    print(f"í•´ì‹œ: {hashed[:30]}...")
    print(f"ì†”íŠ¸: {salt[:20]}...")
    
    # ê²€ì¦ í…ŒìŠ¤íŠ¸
    is_valid = handler.verify_password(password, hashed, salt)
    print(f"ê²€ì¦ ê²°ê³¼: {'ì„±ê³µ' if is_valid else 'ì‹¤íŒ¨'}")
    
    # ì˜ëª»ëœ ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
    is_wrong_valid = handler.verify_password("WrongPassword", hashed, salt)
    print(f"ì˜ëª»ëœ ë¹„ë°€ë²ˆí˜¸ ê²€ì¦: {'ì„±ê³µ' if is_wrong_valid else 'ì‹¤íŒ¨'}")
    
    # 3. ë¹„ë°€ë²ˆí˜¸ ë³¼íŠ¸ ë°ëª¨
    print("\n3. ë¹„ë°€ë²ˆí˜¸ ë³¼íŠ¸:")
    
    # ë§ˆìŠ¤í„° ë¹„ë°€ë²ˆí˜¸ ì„¤ì •
    master_password = "MasterPass123!"
    vault = handler.create_password_vault(master_password)
    
    # í•­ëª© ì¶”ê°€
    vault.add_entry(
        name="ì´ë©”ì¼",
        username="user@example.com",
        password="EmailPassword456!",
        url="https://mail.example.com",
        notes="ê°œì¸ ì´ë©”ì¼ ê³„ì •"
    )
    
    vault.add_entry(
        name="ì€í–‰",
        username="john_doe",
        password="BankPass789!",
        url="https://bank.example.com"
    )
    
    # í•­ëª© ì¡°íšŒ
    print("ì €ì¥ëœ í•­ëª©:")
    for name in vault.entries.keys():
        entry = vault.get_entry(name)
        if entry:
            print(f"  {name}: ì‚¬ìš©ìëª…={entry['username']}, "
                  f"ë¹„ë°€ë²ˆí˜¸={entry['password'][:3]}***")
    
    # 4. ëŒ€í™”í˜• ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ (ì‹œë®¬ë ˆì´ì…˜)
    print("\n4. ëŒ€í™”í˜• ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ì‹œë®¬ë ˆì´ì…˜:")
    
    # ì‹¤ì œ ì…ë ¥ ëŒ€ì‹  ì‹œë®¬ë ˆì´ì…˜
    test_inputs = ["FirstTry123!", "FirstTry123!", "SecondTry456#"]
    input_iter = iter(test_inputs)
    
    def mock_getpass(prompt, stream=None):
        try:
            return next(input_iter)
        except StopIteration:
            return ""
    
    # getpass.getpassë¥¼ ì„ì‹œë¡œ ëª¨í‚¹
    import builtins
    original_getpass = getpass.getpass
    getpass.getpass = mock_getpass
    
    try:
        # ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ì‹œë®¬ë ˆì´ì…˜
        print("ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ë°ëª¨ (í™•ì¸ í¬í•¨):")
        password = handler.get_password("ìƒˆ ë¹„ë°€ë²ˆí˜¸: ", confirm=True)
        print(f"ì…ë ¥ëœ ë¹„ë°€ë²ˆí˜¸: {password[:3]}***")
        
        # ê²€ì¦ë§Œ
        print("\në‹¨ì¼ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ë°ëª¨:")
        password2 = handler.get_password("ë¹„ë°€ë²ˆí˜¸: ", confirm=False)
        print(f"ì…ë ¥ëœ ë¹„ë°€ë²ˆí˜¸: {password2[:3]}***")
    finally:
        getpass.getpass = original_getpass
    
    # 5. ë¹„ë°€ë²ˆí˜¸ ê°•ë„ ê³„ì‚°ê¸°
    print("\n5. ë¹„ë°€ë²ˆí˜¸ ê°•ë„ ë¶„ì„ê¸°:")
    
    analyzer_passwords = [
        "abc",
        "12345678",
        "Password",
        "P@ssw0rd",
        "V3ry$tr0ngP@$$w0rd!2024"
    ]
    
    for pwd in analyzer_passwords:
        result = handler.validate_password(pwd)
        strength = "ğŸ”´ ì•½í•¨" if result['score'] < 40 else \
                  "ğŸŸ¡ ë³´í†µ" if result['score'] < 70 else "ğŸŸ¢ ê°•í•¨"
        
        print(f"{pwd}: {strength} ({result['score']}/100)")
        if result['errors']:
            print(f"  ë¬¸ì œì : {', '.join(result['errors'])}")

# ë¹„ë°€ë²ˆí˜¸ ì²˜ë¦¬ ë°ëª¨ ì‹¤í–‰
demonstrate_password_handling()
```

## ê²°ë¡ 

íŒŒì´ì¬ìœ¼ë¡œ ì „ë¬¸ì ì¸ ì»¤ë§¨ë“œë¼ì¸ ë„êµ¬ë¥¼ ê°œë°œí•˜ê¸° ìœ„í•´ì„œëŠ” ë‹¨ìˆœí•œ ì¸ì íŒŒì‹±ì„ ë„˜ì–´ ì¢…í•©ì ì¸ ì…ë ¥/ì¶œë ¥ ê´€ë¦¬, ì—ëŸ¬ ì²˜ë¦¬, ë³´ì•ˆ ìƒí˜¸ì‘ìš©ì´ í•„ìš”í•©ë‹ˆë‹¤. íš¨ê³¼ì ì¸ CLI ë„êµ¬ êµ¬ì¶•ì„ ìœ„í•œ í•µì‹¬ ì›ì¹™ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

1. **ìœ ì—°í•œ ì…ë ¥ ì²˜ë¦¬**: íŒŒì¼, í‘œì¤€ ì…ë ¥, íŒŒì´í”„, ì••ì¶• íŒŒì¼ ë“± ë‹¤ì–‘í•œ ì…ë ¥ ì†ŒìŠ¤ë¥¼ í†µí•©ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

2. **ì „ë¬¸ì ì¸ ì—ëŸ¬ ì²˜ë¦¬**: ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€, ìƒí™©ë³„ í•´ê²° ì œì•ˆ, êµ¬ì¡°í™”ëœ ë¡œê¹…ì„ í†µí•´ ì‚¬ìš©ì ê²½í—˜ì„ í–¥ìƒì‹œì¼œì•¼ í•©ë‹ˆë‹¤.

3. **ê³ ê¸‰ ì¸ì íŒŒì‹±**: argparseì˜ ê¸°ë³¸ ê¸°ëŠ¥ì„ ë„˜ì–´ êµ¬ì„± íŒŒì¼ ì§€ì›, ì„œë¸Œëª…ë ¹ì–´, ë™ì  ê²€ì¦, í˜•ì‹ ë³€í™˜ ë“±ì„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.

4. **ë³´ì•ˆ ìƒí˜¸ì‘ìš©**: ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ì‹œ ì—ì½” ì–µì œ, ì ì ˆí•œ í•´ì‹± ì•Œê³ ë¦¬ì¦˜ ì ìš©, ë¯¼ê° ë°ì´í„° ì•”í˜¸í™” ë“± ë³´ì•ˆ ìµœì„  ì‚¬ë¡€ë¥¼ ì¤€ìˆ˜í•´ì•¼ í•©ë‹ˆë‹¤.

5. **ë°ì´í„° íë¦„ ì œì–´**: ë¦¬ë‹¤ì´ë ‰ì…˜, íŒŒì´í”„, tee ê¸°ëŠ¥ ë“±ì„ ì§€ì›í•˜ì—¬ ìœ ë‹‰ìŠ¤ ì² í•™ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤.

ì‹¤ì œ í”„ë¡œë•ì…˜ê¸‰ CLI ë„êµ¬ë¥¼ ê°œë°œí•  ë•ŒëŠ” ì¶”ê°€ì ìœ¼ë¡œ ë‹¤ìŒ ì‚¬í•­ë“¤ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤:
- êµ­ì œí™”(i18n)ì™€ ì§€ì—­í™”(l10n) ì§€ì›
- ìë™ ì™„ì„±(auto-completion) ê¸°ëŠ¥ êµ¬í˜„
- ë§¤ë‰´ì–¼ í˜ì´ì§€(man page) ìƒì„±
- í†µí•© í…ŒìŠ¤íŠ¸ì™€ E2E í…ŒìŠ¤íŠ¸ êµ¬ì„±
- íŒ¨í‚¤ì§•ê³¼ ë°°í¬ ìë™í™”
- ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ê³¼ í”„ë¡œíŒŒì¼ë§

ì´ëŸ¬í•œ ì›ì¹™ê³¼ ê¸°ë²•ë“¤ì„ ì ìš©í•˜ë©´ ì‚¬ìš©ì ì¹œí™”ì ì´ë©´ì„œë„ ê°•ë ¥í•œ ì»¤ë§¨ë“œë¼ì¸ ë„êµ¬ë¥¼ ê°œë°œí•  ìˆ˜ ìˆìœ¼ë©°, DevOps ë„êµ¬, ì‹œìŠ¤í…œ ìœ í‹¸ë¦¬í‹°, ë°ì´í„° ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ ë“± ë‹¤ì–‘í•œ ë¶„ì•¼ì—ì„œ íš¨ê³¼ì ìœ¼ë¡œ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŒŒì´ì¬ì˜ í’ë¶€í•œ ìƒíƒœê³„ì™€ ê²°í•©í•˜ë©´ ê¸°ì—… í™˜ê²½ì—ì„œë„ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì „ë¬¸ì ì¸ CLI ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.