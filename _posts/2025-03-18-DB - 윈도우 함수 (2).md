---
layout: post
title: DB - 윈도우 함수 (2)
date: 2025-03-18 20:20:23 +0900
category: DB
---
# SQL 고급 윈도우 함수(Window Function)

## 용어 리마인드 & 수학적 직관

**윈도우 함수**는 파티션(집계 범위)과 정렬(순서)을 가진 “가상의 창(window)” 위에서 각 행마다 **요약/순위/참조/분위** 값을 계산한다.
이 글에서 자주 등장할 핵심 수식:

1. **슬라이딩 합계(길이 \(w\))**
   $$
   S_i=\sum_{k=i-w+1}^{i} x_k = P_i - P_{i-w},\quad
   P_i=\sum_{k=1}^{i} x_k
   $$
   → 프리픽스 합(누적합)으로 슬라이딩 비용을 상수시간 근사 가능(엔진 내부 최적화와 유사 직관).

2. **분위/백분위 개념**
   - 누적 분포 \(F(x)=\Pr(X\le x)\) 를 유한 표본에 적용한 것이 `CUME_DIST()`.
   - 상대 순위 \(\frac{\text{rank}(x)-1}{n-1}\) 가 `PERCENT_RANK()`.

3. **지수 이동 평균(EMA)** (감쇠 \(\alpha\))
   $$
   \text{EMA}_i=\alpha \cdot x_i + (1-\alpha)\cdot \text{EMA}_{i-1}
   $$
   → 순수 윈도우로 직접 계산하기 어렵고, **재귀 CTE** 또는 **엔진 내장 함수**(일부 DB)로 구현.

---

## Rolling Window 심화: ROWS / RANGE / GROUPS 정밀 사용

### ROWS vs RANGE vs GROUPS — 선택 기준

| 유형 | 기준 | 대표 사용 | 장점 | 주의점 |
|---|---|---|---|---|
| ROWS | 물리적 행 개수 | “앞 2행~현재행” 이동평균 | 예측 가능 | 값이 같은 동점도 **별개 행**으로 취급 |
| RANGE | 정렬 키의 값 구간 | “이전 30일~현재일” 누적합 | 시간/금액 **연속 구간** 표현 | 동점(피어)이 **한꺼번에 포함**될 수 있음 |
| GROUPS | 피어 그룹 단위 | “이전 1피어 그룹~현재 그룹” | 동점 묶음 기준 제어 | 일부 DB만 지원 |

#### 예: 동일 매출액 동점이 많은 데이터

- **동점 포함** 누적이 필요 → `RANGE` 또는 `GROUPS`.
- **동점 개수와 무관**한 정확한 N-행 이동 → `ROWS`.

---

### 시간 기반 Rolling — RANGE + INTERVAL

```sql
-- [PostgreSQL/Oracle] 월별 매출에서 "이전 2개월 ~ 현재월" 3개월 롤링 합계
SELECT month, amount,
       SUM(amount) OVER (
         ORDER BY month
         RANGE BETWEEN INTERVAL '2 months' PRECEDING AND CURRENT ROW
       ) AS rolling_3m_sum
FROM monthly_sales
ORDER BY month;
```

- **MySQL 8.0**: `RANGE … INTERVAL` 지원이 제한적이다. 대안:
  1) **행 확장 테이블(달력 테이블)** 조인 후 ROWS 프레임,
  2) **조인 + SUM CASE WHEN**로 기간 누적을 구현.

---

### 값 범위 Rolling — 금액/점수 구간 누적

```sql
-- 점수 오름차순에서 "현재 점수 - 5 ~ 현재 점수" 구간 누적
-- RANGE 값-오프셋은 DB별 제약이 있으므로, PSQL/Oracle 중심. MySQL/SQLServer는 조인/서브쿼리 대안.
SELECT student_id, score,
       SUM(score) OVER (
         ORDER BY score
         RANGE BETWEEN 5 PRECEDING AND CURRENT ROW
       ) AS sum_last_5pts
FROM scores
ORDER BY score;
```

---

### 그룹 단위 슬라이딩

```sql
-- [PostgreSQL 11+/Oracle 12c+] 동점-그룹 단위로 이전 1그룹까지 합산
SELECT store_id, revenue,
       SUM(revenue) OVER (
         ORDER BY revenue
         GROUPS BETWEEN 1 PRECEDING AND CURRENT ROW
       ) AS grouped_running
FROM store_revenue
ORDER BY revenue;
```

**언제 쓰나?**
최저가/동점가를 하나의 묶음으로 보고, **그 묶음 단위**로 누적/이동 통계를 내야 할 때.

---

### 기반 Rolling

#### 캘린더 테이블

```sql
CREATE TABLE calendar (
  dt date primary key,
  is_business_day boolean not null
);
```

#### 영업일만 카운트하는 5-영업일 이동 합계

```sql
-- 영업일에게만 넘버링을 부여해 "ROWS BETWEEN 4 PRECEDING" 구현
WITH day_numbered AS (
  SELECT s.sales_date, s.amount,
         ROW_NUMBER() OVER (ORDER BY s.sales_date)
           FILTER (WHERE c.is_business_day) AS bday_seq
  FROM sales s
  JOIN calendar c ON c.dt = s.sales_date
  WHERE c.is_business_day
)
SELECT sales_date, amount,
       SUM(amount) OVER (
         ORDER BY bday_seq
         ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
       ) AS rolling_5bd_sum
FROM day_numbered
ORDER BY sales_date;
```

**핵심 아이디어**: “영업일만” 연속 번호를 매겨 `ROWS` 프레임을 그대로 활용.

---

## — 분포/백분위 분석

### 정의와 차이

- `CUME_DIST()` : 누적 분포 함수(ECDF) — **현재 값 이하**의 비율
  $$
  \text{CUME\_DIST}(x_i) = \frac{\#\{x \le x_i\}}{n}
  $$
- `PERCENT_RANK()` : 상대 순위 비율 — 맨 앞이 0, 맨 뒤가 1
  $$
  \text{PERCENT\_RANK}(x_i) =
  \begin{cases}
  0 & \text{if } n=1\\
  \dfrac{\text{rank}(x_i)-1}{n-1} & \text{else}
  \end{cases}
  $$

> **차이**: `CUME_DIST()`는 **동점 묶음을 한꺼번에 점프**(계단), `PERCENT_RANK()`는 **선형 간격**.

### 기본 예제

```sql
SELECT emp_id, dept, salary,
       CUME_DIST()    OVER (PARTITION BY dept ORDER BY salary) AS cume,
       PERCENT_RANK() OVER (PARTITION BY dept ORDER BY salary) AS prank
FROM employee
ORDER BY dept, salary;
```

- **동점**이 많은 급여 분포에서 `cume`는 같은 값 내에서 같은 수치(계단 형태).

### 임계 백분위 필터링

```sql
-- 부서별 급여 상위 10%만 추출 (CUME_DIST 기반)
WITH ranked AS (
  SELECT e.*,
         CUME_DIST() OVER (PARTITION BY dept ORDER BY salary DESC) AS cume_desc
  FROM employee e
)
SELECT *
FROM ranked
WHERE cume_desc <= 0.10
ORDER BY dept, salary DESC;
```

- 상위/하위 컷오프가 분명해야 하는 보너스/성과지급 시나리오에 유용.

---

## — PERCENTILE_CONT / PERCENTILE_DISC

### 두 함수의 의미

- `PERCENTILE_CONT(p) WITHIN GROUP (ORDER BY x)`
  **연속형** 분위 — **보간(interpolation)** 으로 값 사이를 메움.
- `PERCENTILE_DISC(p) WITHIN GROUP (ORDER BY x)`
  **이산형** 분위 — 분위 위치에 해당하는 **실제 관측값**을 반환.

### 부서별 중앙값(50%)과 90% 분위

```sql
-- [PostgreSQL/Oracle/SQL Server(2012+: PERCENTILE_CONT as analytic?; 내장 분산함수는 다른 문법)]
SELECT dept,
       PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) AS p50,
       PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY salary) AS p90,
       PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY salary) AS p50_disc
FROM employee
GROUP BY dept
ORDER BY dept;
```

- **MySQL 8.0**: `PERCENTILE_CONT` 미지원. 대안: `PERCENTILE_DISC`는 `WITHIN GROUP` 미지원 → **`NTILE()` + 근사**, **윈도우-순위로 위치 계산 후 보간**.

### 윈도우 형태로 퍼센타일(행 보존)

일부 엔진(Oracle/PSQL)은 **분석형 퍼센타일**을 윈도우로 지원한다:

```sql
-- 각 행에 "부서 내 중위수"를 붙여 표시(행 보존)
SELECT emp_id, dept, salary,
       PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary)
         OVER (PARTITION BY dept) AS dept_median
FROM employee;
```

---

## — CURRENT ROW / TIES / GROUP

`EXCLUDE`는 윈도우 프레임에서 **특정 행/그룹을 빼고** 집계를 계산한다. (PostgreSQL 11+, Oracle 12c+)

| 구문 | 의미 |
|---|---|
| `EXCLUDE CURRENT ROW` | 현재 행 제외 |
| `EXCLUDE TIES` | 현재 행과 같은 **피어(동점)** 모두 제외 |
| `EXCLUDE GROUP` | 현재 행이 속한 **피어 그룹 전체** 제외 |
| `EXCLUDE NO OTHERS` | 배제 없음(기본) |

### 자기 자신 제외 평균/표준화

```sql
-- 부서 내 '본인 제외' 평균
SELECT emp_id, dept, salary,
       AVG(salary) OVER (
         PARTITION BY dept ORDER BY salary
         ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
         EXCLUDE CURRENT ROW
       ) AS avg_excl_self
FROM employee;
```

### 동점 배제 Z-점수(간단 표준화)

```sql
-- 동점 그룹 전체를 빼고 표준화하고 싶다(예: 같은 점수 집단 영향 제거)
-- 표준편차/평균은 DB마다 분석함수 or 별도 계산 필요(여기서는 분리 계산 전략)
WITH base AS (
  SELECT e.*,
         AVG(salary) OVER (PARTITION BY dept) AS mu,
         STDDEV_POP(salary) OVER (PARTITION BY dept) AS sigma
  FROM employee e
),
z AS (
  SELECT emp_id, dept, salary, mu, sigma,
         ((salary - mu) / NULLIF(sigma,0)) AS z_all
  FROM base
)
SELECT *
FROM z
ORDER BY dept, salary;
```

`EXCLUDE GROUP`을 직접 평균/표준편차에 적용하려면 엔진 지원이 필요하고, 미지원 시 **동점 그룹 제거용 보조 윈도우/서브쿼리**가 필요하다.

---

## 고급 집계: 가중 이동 평균, 윈저화(Winsorize), 이상치 완화

### 가중 이동 평균 (예: 최근이 더 중요)

```sql
-- 최근 3행, 가중치 1:2:3 (과거→현재)
SELECT tstamp, value,
       SUM(value * weight) OVER (
         ORDER BY tstamp
         ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
       )
       /
       SUM(weight) OVER (
         ORDER BY tstamp
         ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
       ) AS wma3
FROM (
  SELECT tstamp, value,
         CASE
           WHEN ROW_NUMBER() OVER (ORDER BY tstamp)
                - ROW_NUMBER() OVER (ORDER BY tstamp) = 0 THEN 0  -- placeholder
           ELSE 0
         END AS dummy
  FROM series
) s
-- 가중치는 프레임 내부에서 동적으로 산출하기 어렵다.
-- 실무에서는 "직접 weight 열"을 함께 공급하거나, 프레임 내 상대 위치를 계산해 CASE WHEN으로 가중치를 부여한다.
```

**현실적인 구현**
- **프레임 내 상대 위치**를 구해 `CASE`로 가중치 할당:
```sql
WITH x AS (
  SELECT tstamp, value,
         ROW_NUMBER() OVER (ORDER BY tstamp) AS seq
  FROM series
),
y AS (
  SELECT a.tstamp, a.value,
         SUM(
           CASE
             WHEN a.seq - b.seq = 0 THEN 1   -- t-2
             WHEN a.seq - b.seq = 1 THEN 2   -- t-1
             WHEN a.seq - b.seq = 2 THEN 3   -- t
             ELSE 0
           END * b.value
         ) AS num,
         SUM(
           CASE
             WHEN a.seq - b.seq BETWEEN 0 AND 2 THEN (a.seq - b.seq + 1)
             ELSE 0
           END
         ) AS den
  FROM x a
  JOIN x b ON b.seq BETWEEN a.seq-2 AND a.seq
  GROUP BY a.tstamp, a.value, a.seq
)
SELECT tstamp, value, num/NULLIF(den,0) AS wma3
FROM y
ORDER BY tstamp;
```
- 윈도우만으로 간단히 하기 어렵다면 **조인식 근사**가 실무에서 많이 쓰인다.

### 이동 평균 — 극단값 완화

아이디어: 프레임 내 **퍼센타일 컷**으로 상하단을 자르고 평균.

```sql
-- [PostgreSQL/Oracle] 프레임 내 p10~p90만 평균(개념 예시: 실제로는 프레임 내 서브집계 필요)
-- 엔진이 "프레임 내 PERCENTILE_CONT"를 직접 지원하지 않는 경우가 많아 조인/서브쿼리로 근사한다.
```

실무에서는:
1) 전체 데이터가 아니라 **사전 변환 테이블**로 이상치를 클리핑,
2) 또는 **퍼센타일 기반 집계**를 **그룹별로 먼저 계산** 후 결과를 윈도우와 결합.

---

## NTILE과 분위/백분위 레이어링

### NTILE로 분위 레이블 만들기

```sql
-- 부서별 급여 사분위(4분위)
SELECT emp_id, dept, salary,
       NTILE(4) OVER (PARTITION BY dept ORDER BY salary) AS qtile
FROM employee
ORDER BY dept, salary;
```

### NTILE vs PERCENTILE vs CUME_DIST

| 목적 | 추천 함수 |
|---|---|
| “n개 그룹으로 정해 나누고 싶다” | `NTILE(n)` |
| “정확한 p 분위값(연속/이산) 알고 싶다” | `PERCENTILE_CONT/DISC` |
| “현재 값의 누적 비율/순위 비율” | `CUME_DIST/PERCENT_RANK` |

---

## 실무 패턴 모음

### “동일 고객, 최근 N건 평균금액” (N=5)

```sql
WITH numbered AS (
  SELECT t.*,
         ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY tx_time DESC) AS rn
  FROM transactions t
)
SELECT customer_id, AVG(amount) AS avg_last5
FROM numbered
WHERE rn <= 5
GROUP BY customer_id;
```

- **행 보존**이 필요하면 `ROWS BETWEEN 4 PRECEDING AND CURRENT ROW`를 사용해 각 거래행에 이동평균을 직접 부여.

### “상위 10% 고객만 선별 + 내부 랭크/누적”

```sql
WITH ranked AS (
  SELECT customer_id, total_spent,
         CUME_DIST() OVER (ORDER BY total_spent DESC) AS cume
  FROM customer_agg
)
SELECT customer_id, total_spent,
       RANK() OVER (ORDER BY total_spent DESC) AS rnk,
       SUM(total_spent) OVER (ORDER BY total_spent DESC) AS cum_sum
FROM ranked
WHERE cume <= 0.10
ORDER BY total_spent DESC;
```

### 동시 산출”

```sql
WITH base AS (
  SELECT month, amount,
         LAG(amount, 12) OVER (ORDER BY month) AS prev_year
  FROM monthly_sales
)
SELECT month, amount,
       (amount - prev_year) AS yoy_diff,
       SUM(amount) OVER (ORDER BY month) AS ytd,
       AVG(amount) OVER (ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS ma3
FROM base
ORDER BY month;
```

---

## 성능·정확성 트러블슈팅

1) **정렬 비용**: `OVER (ORDER BY ...)`는 소트 비중이 높다 → 정렬 키 인덱스·파티션 축소.
2) **프레임 폭**: `FOLLOWING`까지 열면 전체 범위 참조 → 메모리/디스크 스필 증가.
3) **동점·NULL**: `ORDER BY col NULLS LAST`처럼 **명시**하고, 동점 해소용 2차 키 추가.
4) **EXCLUDE/ GROUPS/ RANGE**: 엔진 지원 차이 큼 → 미지원 시 조인/서브쿼리/CTE 변환.
5) **퍼센타일 함수**: 엔진별 존재/문법 상이. MySQL은 근사(순위 보간)로 대체.
6) **필터링 단계**: 윈도우 결과는 **바깥 SELECT/CTE**에서 필터.
7) **같은 윈도우 재사용**: PostgreSQL `WINDOW` 절로 공유, 타 DB도 동일 정의를 그대로 복제(옵티마이저 공유 가능).
8) **대규모 스트리밍**: 실시간이면 DB보다는 **OLAP 엔진/스트리밍 프레임워크** 고려.

---

## DBMS별 기능 맵 (요지)

| 기능 | PostgreSQL | Oracle | SQL Server | MySQL 8 |
|---|---|---|---|---|
| RANGE INTERVAL | 풍부 | 강력 | 제한 | 제한 |
| GROUPS 프레임 | 11+ | 12c+ | 일부(2022+) | 미지원 |
| EXCLUDE (CURRENT/TIES/GROUP) | 11+ | 12c+ | 미지원 | 미지원 |
| PERCENTILE_CONT/DISC (집계/분석) | 지원 | 지원 | 지원(분석/집계 함수 형태 다름) | 미지원 |
| FILTER(WHERE) | 지원 | 미지원 | 미지원 | 미지원 |
| WINDOW 절(별칭) | 지원 | 미지원 | 미지원 | 미지원 |

※ 실제 버전별/에디션별로 차이가 있을 수 있으므로 **엔진 문서** 확인이 필수.

---

## 수학 코너: 분위/백분위의 경계 처리

- 표본 크기 \(n\), 정렬된 값 \(x_{(1)}\le \cdots \le x_{(n)}\).
- **PERCENT_RANK**:
  $$
  \text{prank}(x_{(k)})=\frac{k-1}{n-1}
  $$
- **CUME_DIST**:
  $$
  \text{cume}(x_{(k)})=\frac{k}{n}
  $$
  (동점일 때는 **동점의 마지막 인덱스** \(k_{\max}\) 사용)
- **PERCENTILE_CONT(p)**:
  위치 \(h=(n-1)\cdot p+1\),
  정수부 \(k=\lfloor h\rfloor\), 분수부 \(\delta=h-k\).
  $$
  x_p=
  \begin{cases}
  x_{(k)}, & \delta=0\\
  (1-\delta)\cdot x_{(k)} + \delta \cdot x_{(k+1)}, & \delta\in(0,1)
  \end{cases}
  $$

---

## 테스트 데이터 & 실습 세트

### 스키마

```sql
CREATE TABLE employee (
  emp_id    INT PRIMARY KEY,
  dept      VARCHAR(20),
  salary    NUMERIC(10,2),
  hire_date DATE
);

CREATE TABLE monthly_sales (
  month  DATE PRIMARY KEY,
  amount NUMERIC(12,2)
);

CREATE TABLE transactions (
  tx_id       BIGINT PRIMARY KEY,
  customer_id INT,
  tx_time     TIMESTAMP,
  amount      NUMERIC(12,2)
);
```

### 샘플 인서트(축약)

```sql
INSERT INTO employee (emp_id, dept, salary, hire_date) VALUES
(1,'A',3000,'2023-01-10'),(2,'A',3000,'2023-02-05'),(3,'A',4500,'2023-03-12'),
(4,'B',5000,'2023-01-20'),(5,'B',7000,'2023-02-25'),(6,'B',7000,'2023-04-01');

INSERT INTO monthly_sales(month, amount) VALUES
('2024-01-01',100),('2024-02-01',120),('2024-03-01',80),
('2024-04-01',150),('2024-05-01',200),('2024-06-01',180);
```

---

## 종합 예제 — “상위 백분위별 KPI + 롤링·누적 지표 + 동점배제 평균”

```sql
WITH kpi AS (
  SELECT e.*,
         CUME_DIST()    OVER (PARTITION BY dept ORDER BY salary DESC)         AS cume_desc,
         PERCENT_RANK() OVER (PARTITION BY dept ORDER BY salary DESC)         AS prank_desc,
         SUM(salary)    OVER (PARTITION BY dept ORDER BY hire_date
                               ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS run_by_tenure
  FROM employee e
),
top10 AS (
  SELECT *
  FROM kpi
  WHERE cume_desc <= 0.10
),
avg_excl_ties AS (
  SELECT emp_id, dept, salary,
         AVG(salary) OVER (
           PARTITION BY dept ORDER BY salary
           ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
           -- EXCLUDE TIES (PostgreSQL/Oracle 지원) :
           -- EXCLUDE TIES
         ) AS avg_with_ties   -- 미지원 엔진은 동점 제거용 보조 계산 필요
  FROM employee
)
SELECT t.dept, t.emp_id, t.salary,
       t.cume_desc, t.prank_desc, t.run_by_tenure,
       a.avg_with_ties
FROM top10 t
JOIN avg_excl_ties a
  ON a.emp_id = t.emp_id
ORDER BY t.dept, t.salary DESC;
```

---

## 베스트 프랙티스 요약

1. **프레임을 명시**: 특히 `LAST_VALUE`, RANGE/GROUPS 사용 시 오해 방지.
2. **정렬·동점·NULL**을 **명시적으로 설계**: `NULLS LAST`, 2차 정렬 키, 동점 처리 의도.
3. **필터 위치**: 윈도우 결과 필터는 바깥 SELECT/CTE.
4. **엔진 기능 맵** 인지: `EXCLUDE`, `GROUPS`, `PERCENTILE_CONT` 등 이질성.
5. **대량 데이터**: 파티션 축소, 프레임 축소, 인덱스, 사전 집계/물질화 뷰, 실행계획 점검.
6. **영업일/비정형 간격**: 캘린더 테이블·조인 패턴으로 행 축을 재정의.
7. **분위·백분위 해석**: CUME_DIST vs PERCENT_RANK 차이/용도 구분.
8. **가중/이상치**: 단순 윈도우로 어려우면 **조인/서브쿼리/재귀/ETL**을 혼합.

---

## 체크리스트 (코드 리뷰용)

- [ ] 프레임 범위와 `EXCLUDE` 의도대로 동작하는가?
- [ ] 동점·NULL·타임존(시간축) 처리 명시?
- [ ] WHERE가 아닌 바깥 SELECT/CTE에서 필터했는가?
- [ ] 동일 윈도우 정의를 중복 계산하지 않았는가(공유/합치기)?
- [ ] 퍼센타일/분위 함수의 엔진 지원 여부를 확인했는가?
- [ ] 대체 전략(조인/서브쿼리/물질화/ETL)을 검토했는가?

---

# 마무리

본 고급편은 **롤링 프레임을 다양한 축(행·값·그룹·영업일)** 으로 설계하고, **분위/백분위**로 분포를 해석하며, **EXCLUDE**로 프레임을 세밀 조정하는 실무 패턴을 총망라했다.
이제 당신은 **Top-N/랭킹/누적/이동/퍼센타일/세그먼트 구분**을 하나의 SQL 문장으로 생산성 높게 구현할 수 있다.
다음 단계는 **엔진별 벤치마크와 실행계획 분석**이다. 동일 쿼리라도 데이터 규모·분포·인덱스에 따라 성능이 크게 달라지므로, 실제 데이터로 테스트해 최적점을 찾자.
