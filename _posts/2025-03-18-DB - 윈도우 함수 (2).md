---
layout: post
title: DB - 윈도우 함수 (2)
date: 2025-03-18 20:20:23 +0900
category: DB
---
# SQL 고급 윈도우 함수(Window Function) 심화 가이드

## 기본 개념 복습 및 수학적 직관

**윈도우 함수**는 파티션(집계 범위)과 정렬(순서)을 가진 "가상의 창(window)" 내에서 각 행마다 요약, 순위, 참조, 분위 값을 계산하는 강력한 SQL 기능입니다. 윈도우 함수를 효과적으로 사용하기 위해 몇 가지 수학적 개념을 이해하는 것이 도움이 됩니다:

1. **슬라이딩 합계(길이 w)**
   윈도우 함수는 프레임 내 데이터의 누적 합계를 효율적으로 계산할 수 있으며, 이는 프리픽스 합(prefix sum) 패턴으로 최적화될 수 있습니다.

2. **분위와 백분위 개념**
   - 누적 분포 함수(CDF)의 개념이 `CUME_DIST()` 함수에 구현되어 있습니다.
   - 상대 순위의 개념이 `PERCENT_RANK()` 함수에 반영되어 있습니다.

3. **지수 이동 평균(EMA)**
   시간 가중치가 있는 이동 평균으로, 재귀적 CTE나 데이터베이스별 내장 함수로 구현할 수 있습니다.

---

## 롤링 윈도우의 고급 기법: ROWS, RANGE, GROUPS의 정밀한 사용

### ROWS, RANGE, GROURS의 차이점과 선택 기준

| 유형 | 기준 | 대표 사용 사례 | 장점 | 주의점 |
|---|---|---|---|---|
| **ROWS** | 물리적 행 개수 | "앞의 2행부터 현재 행까지" 이동 평균 | 예측 가능한 결과, 동점 처리 간단 | 동일 값의 행도 별개로 취급 |
| **RANGE** | 정렬 키의 값 범위 | "이전 30일부터 현재 날짜까지" 누적 합 | 시간/금액의 연속적 구간 표현 | 동점 행들이 한꺼번에 포함됨 |
| **GROUPS** | 동점 그룹 단위 | "이전 1개 동점 그룹부터 현재 그룹까지" | 동점 묶음을 기준으로 제어 | 일부 데이터베이스에서만 지원 |

#### 예시: 동일 매출액을 가진 다수의 행이 있는 경우
- **동점 포함 누적**이 필요하다면: `RANGE` 또는 `GROUPS` 사용
- **정확한 N행 이동**이 필요하다면 (동점 개수와 무관하게): `ROWS` 사용

---

### 시간 기반 롤링 윈도우: RANGE와 INTERVAL 조합

```sql
-- PostgreSQL/Oracle: 월별 매출에서 "이전 2개월 포함 현재월까지" 3개월 롤링 합계
SELECT 
    sales_month, 
    sales_amount,
    SUM(sales_amount) OVER (
        ORDER BY sales_month
        RANGE BETWEEN INTERVAL '2 months' PRECEDING AND CURRENT ROW
    ) AS rolling_3m_sum
FROM monthly_sales
ORDER BY sales_month;
```

**MySQL 8.0 사용자 참고**: `RANGE ... INTERVAL` 지원이 제한적일 수 있습니다. 대안으로:
1. **달력 테이블과 조인** 후 `ROWS` 프레임 사용
2. **조인과 CASE WHEN**을 활용한 기간 누적 구현

---

### 값 범위 기반 롤링 윈도우

```sql
-- 점수 오름차순으로 "현재 점수 -5점부터 현재 점수까지" 구간 누적
SELECT 
    student_id, 
    test_score,
    SUM(test_score) OVER (
        ORDER BY test_score
        RANGE BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS sum_nearby_scores
FROM student_scores
ORDER BY test_score;
```

**참고**: 값 오프셋을 사용한 `RANGE`는 PostgreSQL과 Oracle에서 잘 지원되지만, 다른 데이터베이스에서는 조인이나 서브쿼리로 대체 구현이 필요할 수 있습니다.

---

### 그룹 단위 슬라이딩 윈도우

```sql
-- PostgreSQL 11+/Oracle 12c+: 동점 그룹 단위로 이전 1그룹까지 합산
SELECT 
    store_id, 
    daily_revenue,
    SUM(daily_revenue) OVER (
        ORDER BY daily_revenue
        GROUPS BETWEEN 1 PRECEDING AND CURRENT ROW
    ) AS grouped_running_total
FROM store_daily_revenue
ORDER BY daily_revenue;
```

**적절한 사용 시기**: 최저가나 동점가를 하나의 묶음으로 보고, 이 묶음 단위로 누적 통계를 계산해야 할 때 유용합니다.

---

### 영업일 기준 롤링 윈도우 구현

#### 기본 달력 테이블
```sql
CREATE TABLE business_calendar (
    calendar_date DATE PRIMARY KEY,
    is_business_day BOOLEAN NOT NULL
);
```

#### 영업일만 고려한 5-영업일 이동 합계
```sql
-- 영업일에만 번호를 부여하여 ROWS 프레임 활용
WITH business_days_numbered AS (
    SELECT 
        s.sale_date, 
        s.sale_amount,
        ROW_NUMBER() OVER (ORDER BY s.sale_date) AS business_day_sequence
    FROM sales s
    JOIN business_calendar c ON c.calendar_date = s.sale_date
    WHERE c.is_business_day = TRUE
)
SELECT 
    sale_date, 
    sale_amount,
    SUM(sale_amount) OVER (
        ORDER BY business_day_sequence
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) AS rolling_5_business_day_sum
FROM business_days_numbered
ORDER BY sale_date;
```

**핵심 아이디어**: "영업일만" 연속 번호를 매겨 기존의 `ROWS` 프레임을 그대로 활용할 수 있습니다.

---

## 분포 및 백분위 분석 함수

### CUME_DIST와 PERCENT_RANK의 정의와 차이

- **`CUME_DIST()`**: 누적 분포 함수(ECDF) - **현재 값 이하**의 비율
  $$
  \text{CUME\_DIST}(x_i) = \frac{\#\{x \le x_i\}}{n}
  $$

- **`PERCENT_RANK()`**: 상대 순위 비율 - 첫 번째 행이 0, 마지막 행이 1
  $$
  \text{PERCENT\_RANK}(x_i) = \frac{\text{rank}(x_i)-1}{n-1}
  $$

> **핵심 차이**: `CUME_DIST()`는 동점 묶음을 계단 형태로 처리하고, `PERCENT_RANK()`는 선형 간격으로 처리합니다.

### 기본 사용 예제

```sql
SELECT 
    employee_id, 
    department, 
    salary,
    CUME_DIST() OVER (PARTITION BY department ORDER BY salary) AS cumulative_distribution,
    PERCENT_RANK() OVER (PARTITION BY department ORDER BY salary) AS percentile_rank
FROM employees
ORDER BY department, salary;
```

### 상위 백분위 필터링

```sql
-- 부서별 급여 상위 10% 직원 추출 (CUME_DIST 기반)
WITH department_salary_ranked AS (
    SELECT 
        e.*,
        CUME_DIST() OVER (PARTITION BY department ORDER BY salary DESC) AS top_percentile
    FROM employees e
)
SELECT *
FROM department_salary_ranked
WHERE top_percentile <= 0.10
ORDER BY department, salary DESC;
```

**실무 적용**: 보너스 지급, 성과 평가 등에서 상위/하위 컷오프가 분명해야 하는 시나리오에 유용합니다.

---

## PERCENTILE_CONT와 PERCENTILE_DISC 함수

### 두 함수의 의미 차이

- **`PERCENTILE_CONT(p)`**: **연속형** 분위수 - 보간법(interpolation)으로 값 사이를 채웁니다.
- **`PERCENTILE_DISC(p)`**: **이산형** 분위수 - 분위 위치에 해당하는 실제 관측값을 반환합니다.

### 부서별 중앙값과 90백분위수 계산

```sql
-- PostgreSQL, Oracle, SQL Server(2012+)에서 지원
SELECT 
    department,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) AS median_salary,
    PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY salary) AS p90_salary,
    PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY salary) AS median_actual_salary
FROM employees
GROUP BY department
ORDER BY department;
```

**MySQL 8.0 사용자 참고**: `PERCENTILE_CONT`를 직접 지원하지 않습니다. 대안으로 `NTILE()` 함수와 윈도우 순위를 조합한 근사치 계산이나 애플리케이션 레벨에서의 계산을 고려해야 합니다.

### 행 보존형 퍼센타일 계산

일부 데이터베이스는 분석형 퍼센타일을 윈도우 함수 형태로 지원합니다:

```sql
-- 각 직원 행에 부서 내 중위수 급여 표시
SELECT 
    employee_id, 
    department, 
    salary,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) 
        OVER (PARTITION BY department) AS department_median_salary
FROM employees;
```

---

## EXCLUDE 절: 프레임에서 특정 행 제외하기

`EXCLUDE` 절은 윈도우 프레임에서 특정 행이나 그룹을 제외하고 집계를 계산할 때 사용합니다. (PostgreSQL 11+, Oracle 12c+에서 지원)

| 구문 | 의미 |
|------|------|
| `EXCLUDE CURRENT ROW` | 현재 행 제외 |
| `EXCLUDE TIES` | 현재 행과 동점인 모든 행 제외 |
| `EXCLUDE GROUP` | 현재 행이 속한 동점 그룹 전체 제외 |
| `EXCLUDE NO OTHERS` | 아무것도 제외하지 않음 (기본값) |

### 자기 자신을 제외한 평균 계산

```sql
-- 부서 내 '자기 자신 제외' 평균 급여
SELECT 
    employee_id, 
    department, 
    salary,
    AVG(salary) OVER (
        PARTITION BY department 
        ORDER BY salary
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        EXCLUDE CURRENT ROW
    ) AS department_avg_excluding_self
FROM employees;
```

---

## 고급 집계 패턴: 가중 이동 평균, 윈저화, 이상치 완화

### 가중 이동 평균 구현 (최근 데이터에 더 높은 가중치)

```sql
-- 최근 3개 데이터 포인트에 가중치 1:2:3 적용 (과거 → 현재)
WITH time_series_numbered AS (
    SELECT 
        timestamp_value, 
        metric_value,
        ROW_NUMBER() OVER (ORDER BY timestamp_value) AS time_sequence
    FROM metric_data
),
weighted_averages AS (
    SELECT 
        a.timestamp_value, 
        a.metric_value,
        SUM(
            CASE
                WHEN a.time_sequence - b.time_sequence = 0 THEN 1   -- t-2 (가장 오래된)
                WHEN a.time_sequence - b.time_sequence = 1 THEN 2   -- t-1
                WHEN a.time_sequence - b.time_sequence = 2 THEN 3   -- t (가장 최근)
                ELSE 0
            END * b.metric_value
        ) AS weighted_sum,
        SUM(
            CASE
                WHEN a.time_sequence - b.time_sequence BETWEEN 0 AND 2 
                THEN (a.time_sequence - b.time_sequence + 1)
                ELSE 0
            END
        ) AS weight_total
    FROM time_series_numbered a
    JOIN time_series_numbered b 
        ON b.time_sequence BETWEEN a.time_sequence - 2 AND a.time_sequence
    GROUP BY a.timestamp_value, a.metric_value, a.time_sequence
)
SELECT 
    timestamp_value, 
    metric_value,
    weighted_sum / NULLIF(weight_total, 0) AS weighted_moving_average_3
FROM weighted_averages
ORDER BY timestamp_value;
```

**실무적 접근**: 윈도우 함수만으로 복잡한 가중치 계산이 어려울 때는 **조인 방식**이 실무에서 더 많이 사용됩니다.

---

## NTILE 함수를 활용한 데이터 분할

### NTILE로 사분위 레이블 생성

```sql
-- 부서별 급여 사분위(4분위) 레이블 할당
SELECT 
    employee_id, 
    department, 
    salary,
    NTILE(4) OVER (PARTITION BY department ORDER BY salary) AS salary_quartile
FROM employees
ORDER BY department, salary;
```

### NTILE vs PERCENTILE vs CUME_DIST 비교

| 목적 | 추천 함수 |
|------|----------|
| "n개의 균등 그룹으로 나누고 싶다" | `NTILE(n)` |
| "정확한 p 분위값(연속/이산)을 알고 싶다" | `PERCENTILE_CONT/DISC` |
| "현재 값의 누적 비율이나 순위 비율을 알고 싶다" | `CUME_DIST/PERCENT_RANK` |

---

## 실무 적용 패턴 모음

### 동일 고객의 최근 N건 평균 금액 계산 (N=5)

```sql
-- 고객별 최근 5건 거래 평균
WITH customer_transactions_numbered AS (
    SELECT 
        customer_id,
        transaction_amount,
        transaction_timestamp,
        ROW_NUMBER() OVER (
            PARTITION BY customer_id 
            ORDER BY transaction_timestamp DESC
        ) AS recent_transaction_rank
    FROM transactions
)
SELECT 
    customer_id,
    AVG(transaction_amount) AS avg_last_5_transactions
FROM customer_transactions_numbered
WHERE recent_transaction_rank <= 5
GROUP BY customer_id;
```

**행 보존 필요 시**: 각 거래 행에 이동 평균을 직접 부여하려면 `ROWS BETWEEN 4 PRECEDING AND CURRENT ROW`를 사용하세요.

### 상위 10% 고객 식별 및 내부 랭킹

```sql
-- 상위 10% 고객 선별 및 누적 집계
WITH customer_percentiles AS (
    SELECT 
        customer_id, 
        total_spent,
        CUME_DIST() OVER (ORDER BY total_spent DESC) AS spending_percentile
    FROM customer_summary
),
top_customers AS (
    SELECT 
        customer_id, 
        total_spent,
        RANK() OVER (ORDER BY total_spent DESC) AS spending_rank,
        SUM(total_spent) OVER (ORDER BY total_spent DESC) AS cumulative_spending
    FROM customer_percentiles
    WHERE spending_percentile <= 0.10
)
SELECT *
FROM top_customers
ORDER BY total_spent DESC;
```

### 다중 지표 동시 산출 (연간 비교, 연간 누계, 이동 평균)

```sql
-- 월별 매출에 대한 다양한 분석 지표 동시 계산
WITH monthly_sales_with_lag AS (
    SELECT 
        sales_month, 
        sales_amount,
        LAG(sales_amount, 12) OVER (ORDER BY sales_month) AS sales_same_month_last_year
    FROM monthly_sales
)
SELECT 
    sales_month, 
    sales_amount,
    -- 전년 동월 대비 변화액
    (sales_amount - sales_same_month_last_year) AS year_over_year_change,
    -- 연간 누계 매출
    SUM(sales_amount) OVER (ORDER BY sales_month) AS year_to_date_total,
    -- 3개월 이동 평균
    AVG(sales_amount) OVER (
        ORDER BY sales_month 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_average_3_month
FROM monthly_sales_with_lag
ORDER BY sales_month;
```

---

## 성능 최적화 및 문제 해결 가이드

1. **정렬 비용 최소화**: `OVER (ORDER BY ...)`는 정렬 작업을 수반하므로, 정렬 키에 인덱스를 생성하거나 파티셔닝으로 데이터 범위를 축소하세요.

2. **프레임 크기 관리**: `FOLLOWING`까지 포함하는 넓은 프레임은 메모리 사용량을 증가시킬 수 있습니다. 필요 최소 범위로 제한하세요.

3. **동점 및 NULL 처리**: `ORDER BY column NULLS LAST`와 같이 NULL 처리 방식을 명시하고, 동점 해소를 위한 2차 정렬 키를 추가하세요.

4. **기능 호환성 확인**: `EXCLUDE`, `GROUPS`, `RANGE INTERVAL` 등의 고급 기능은 데이터베이스별 지원 수준이 다르므로, 사용 전 호환성을 확인하세요.

5. **필터링 위치**: 윈도우 함수 결과에 대한 필터링은 바깥쪽 SELECT나 CTE에서 수행해야 합니다.

6. **중복 계산 방지**: 동일한 윈도우 정의를 여러 번 사용한다면 PostgreSQL의 `WINDOW` 절이나 공통 테이블 표현식(CTE)으로 재사용하세요.

7. **대규모 데이터 처리**: 실시간 대규모 스트리밍 데이터에는 OLAP 엔진이나 스트리밍 프레임워크 사용을 고려하세요.

---

## 데이터베이스별 기능 지원 현황

| 기능 | PostgreSQL | Oracle | SQL Server | MySQL 8 |
|------|-----------|--------|------------|---------|
| RANGE with INTERVAL | 풍부한 지원 | 강력한 지원 | 제한적 지원 | 제한적 지원 |
| GROUPS 프레임 | 11+ 지원 | 12c+ 지원 | 2022+ 부분 지원 | 미지원 |
| EXCLUDE 절 | 11+ 지원 | 12c+ 지원 | 미지원 | 미지원 |
| PERCENTILE_CONT/DISC | 지원 | 지원 | 지원 (문법 다름) | 미지원 |
| FILTER(WHERE) | 지원 | 미지원 | 미지원 | 미지원 |
| WINDOW 절(별칭) | 지원 | 미지원 | 미지원 | 미지원 |

**주의**: 실제 버전과 에디션에 따라 기능 지원이 다를 수 있으므로 공식 문서를 참고하세요.

---

## 결론: 고급 윈도우 함수의 효과적 활용

윈도우 함수는 현대 데이터 분석의 핵심 도구로, 복잡한 비즈니스 로직을 간결하고 효율적으로 구현할 수 있게 해줍니다. 효과적으로 활용하기 위한 핵심 원칙은 다음과 같습니다:

1. **적절한 프레임 선택**: 분석 목적에 맞게 `ROWS`, `RANGE`, `GROUPS` 중 선택하세요. 시간 기반 분석에는 `RANGE`, 정확한 행 수 기반 분석에는 `ROWS`가 적합합니다.

2. **명시적 정의**: 정렬 기준, NULL 처리, 동점 처리 방식을 명시적으로 정의하여 예측 가능한 결과를 보장하세요.

3. **분석 목적에 맞는 함수 선택**:
   - 데이터 분할: `NTILE()`
   - 분위수 계산: `PERCENTILE_CONT()` / `PERCENTILE_DISC()`
   - 누적 분포: `CUME_DIST()`
   - 상대 순위: `PERCENT_RANK()`

4. **성능 고려사항**:
   - 대규모 데이터셋에서는 파티셔닝과 인덱스를 활용하세요.
   - 반복되는 윈도우 정의는 재사용하여 성능을 개선하세요.
   - 데이터베이스별 최적화 기법을 이해하고 적용하세요.

5. **실무 적용 패턴 숙지**:
   - 이동 평균 및 누적 합계
   - 상위 N% 데이터 식별
   - 시계열 데이터의 다양한 분석 지표 동시 계산
   - 동점 데이터의 정밀한 처리

윈도우 함수의 진정한 힘은 단순한 기술적 구현을 넘어, 비즈니스 문제를 데이터 관점에서 창의적으로 해결할 수 있는 사고방식에 있습니다. 기본 개념을 탄탄히 익히고, 다양한 실무 시나리오에 적용해보면서 점진적으로 고급 기법을 습득해 나가세요.

데이터베이스 시스템은 계속 발전하고 있으며, 새로운 버전마다 더 강력한 윈도우 함수 기능이 추가되고 있습니다. 최신 기술 동향을 주시하고, 실제 비즈니스 문제 해결에 윈도우 함수를 적극적으로 활용해보세요. 올바르게 사용한다면, 윈도우 함수는 데이터 기반 의사결정의 품질과 속도를 크게 향상시킬 수 있는 강력한 도구가 될 것입니다.