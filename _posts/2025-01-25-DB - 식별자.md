---
layout: post
title: DB - 식별자
date: 2025-01-25 23:20:23 +0900
category: DB
---
# 식별자(Identifier, Key)

## 리마인드(핵심 요약)

- **키는 논리적 계약**(유일 식별, 무결성 보장)이며, **인덱스는 물리적 최적화**다. PK는 자동 인덱스를 동반하지만, 인덱스가 곧 키는 아니다.
- **기본키(PK)**는 **유일성·NOT NULL·단일 테이블 1개**를 만족한다.
- **후보키(CK)**는 PK 후보들의 집합, **대체키(AK)**는 선택되지 않은 CK다(보통 UNIQUE 제약으로 구현).
- **외래키(FK)**는 **참조 무결성**의 축이다. FK 열에는 인덱스를 둬야 한다(삭제/갱신/조인 성능).
- **자연키 vs 인조키**: 대부분 **PK=인조키** + **업무 유일성은 UNIQUE**로 병행하는 전략이 안전하다.

---

## 수학적 관점: 키와 함수적 종속(Functional Dependency)

엔티티의 속성 집합을 \(X = \{A_1,\dots,A_n\}\)라 할 때, **기본키** \(K \subseteq X\)는 다음을 만족한다.

1) **유일성(identification)**
$$
\forall t_1, t_2:\ t_1[K] = t_2[K] \Rightarrow t_1 = t_2
$$

2) **최소성(minimality)**
$$
\not\exists K' \subset K:\ K' \to X
$$

즉, \(K\)는 **모든 속성을 결정**하고(\(K \to X\)), 그 어떤 진부분집합도 같은 결정력을 갖지 않는다(최소성).

---

## 키의 분류와 구현(정제)

### 기본키(PK)

- **유일성 + NOT NULL** + **테이블당 1개**
- 생성 방식: 시퀀스/IDENTITY/UUID/ULID/합성키

```sql
CREATE TABLE app_user (
  user_id      BIGSERIAL PRIMARY KEY, -- PK & 인덱스 자동
  email        TEXT NOT NULL UNIQUE,  -- 대체키(AK)
  username     TEXT NOT NULL UNIQUE,  -- 대체키(AK)
  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### 후보키(CK)와 대체키(AK)

- 후보키: PK가 될 수 있는 키들의 집합(예: email, username).
- 대체키: PK로 채택되지 않은 CK(보통 `UNIQUE NOT NULL`).

```sql
ALTER TABLE app_user
  ADD CONSTRAINT uq_app_user_email UNIQUE (email);
```

### 복합키(Composite Key)

- 두 개 이상 컬럼의 조합으로 유일성을 보장.
- **조인 엔티티**(N:M 해소)에서 자주 사용.

```sql
CREATE TABLE enrollment (
  student_id BIGINT NOT NULL,
  course_id  BIGINT NOT NULL,
  attempt_no INT    NOT NULL DEFAULT 1,
  PRIMARY KEY (student_id, course_id, attempt_no)
);
```

### 외래키(FK)

- 참조 관계의 실체. **참조 무결성**을 보장(ON DELETE/UPDATE 정책 포함).
- **FK 열에 인덱스**는 사실상 필수(조인/삭제 성능, 락 경합 저감).

```sql
CREATE TABLE "order" (
  order_id    BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL,
  FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON DELETE RESTRICT
);
CREATE INDEX idx_order_customer ON "order"(customer_id);
```

---

## 자연키 vs 인조키(서로게이트): 판단 기준

| 항목 | 자연키(업무 의미) | 인조키(서로게이트) |
|---|---|---|
| 의미성 | 높음(직관적) | 없음(숫자/UUID) |
| 변경 가능성 | 종종 존재(이메일, 주민번호 변경/재발급) | 없음(불변 설계) |
| 보안/노출 | 민감/개인정보 위험 | 안전(노출해도 의미 없음) |
| 조인/인덱스 크기 | 길이에 따라 부담 가능 | 대개 짧음(BIGINT) 또는 길음(UUID) |
| 마이그레이션 | 어려움 | 용이 |
| 권장 | 규제·강한 표준키가 불변일 때 | **일반적 기본 선택** |

> 실무 권장: **PK=인조키**(BIGINT/UUID/ULID/타임정렬 ID) + **업무 유일성은 UNIQUE**로 별도 보장.

---

## 분산/대규모 시스템을 위한 키 전략

### 시퀀스/IDENTITY

- 단조 증가, **인덱스 지역성↑** → 쓰기 핫스팟(단일 노드)에 유의.
- 샤딩 시 **각 샤드별 시퀀스 오프셋** 전략(예: +N 간격).

```sql
-- PostgreSQL 예시: 시퀀스 튜닝
CREATE SEQUENCE order_id_seq INCREMENT BY 1 CACHE 1000; -- 캐시↑로 경합↓
```

### UUID (v4 랜덤, v1 시간+노드, v7 시간정렬)

- **v4**: 균등 랜덤. 인덱스 분산(지역성↓).
- **v1/v7**: 시간 정렬성(인덱스 지역성↑). **v7** 권장 추세.

```sql
-- PostgreSQL: uuid-ossp 확장 또는 애플리케이션 생성
-- v7은 라이브러리 사용 권장. 저장은 UUID 타입(16바이트) 또는 TEXT.
```

### ULID (time-ordered, Crockford base32)

- 시간 정렬 + 비교적 짧은 문자열 표현.
- 사전 순 정렬이 시간 순서와 일치.

### Snowflake 스타일(64비트, 시간·노드·시퀀스)

- 시간 기반 41비트 + 워커 10비트 + 시퀀스 12비트(대표 설계).
- **고 QPS/분산 생성**에 유리. 시간 역행(skew) 처리 정책 필요.

> 선택 가이드: **단일 RDB + 단조 증가 인덱스 지역성 필요** → BIGSERIAL/IDENTITY.
> **다중 노드/전역 고유/시간 정렬 필요** → UUID v7/ULID/Snowflake.

---

## NULL과 UNIQUE의 DB별 의미 차이(중요)

- **PostgreSQL/SQL Server/MySQL(InnoDB)**: **UNIQUE 인덱스에서 NULL은 서로 다른 값**으로 간주 → 다중 NULL 허용.
- **Oracle**: 유사하게 다중 NULL 허용(단, 특정 기능/구성에 주의).

> “NULL=미정”의 의미상 **다중 NULL 허용은 합리적**이지만, **업무상 ‘값이 비어도 1행만’**을 원하면 **부분 인덱스/함수 인덱스** 등으로 제약을 설계한다.

```sql
-- PostgreSQL: "이메일이 NULL이 아니면 유일" (다중 NULL 허용)
CREATE UNIQUE INDEX uq_user_email_notnull
ON app_user (email) WHERE email IS NOT NULL;
```

---

## 키와 인덱스: 설계·운영의 디테일

- **PK는 자동 인덱스**. **모든 FK에 인덱스** 생성(삭제/업데이트/조인 성능, 데드락 감소).
- 복합 유니크는 **질의 패턴(WHERE/ORDER)**와 일치하게 **열 순서**를 잡는다.
- **선택도(카디널리티)**가 높은 열을 인덱스 선두로 둘 때 이점이 크다.

```sql
-- 주문 상태별 최근 조회 최적화: (status, ordered_at DESC)
CREATE INDEX idx_order_status_dt ON "order"(status, ordered_at DESC);
```

---

## 복합키 설계의 실전 판단

### 언제 쓰나

- **자연스럽고 안정적인 조합**이 있을 때(예: `(tenant_id, natural_id)`),
- **조인 엔티티**(N:M)를 **행 구분**으로 식별할 때(재수강/회차 포함).

### 비용

- 모든 자식 FK가 복합키를 **전파**해야 → **스키마/쿼리 복잡도 증가**.
- ORM 매핑/캐시 키 관리가 어려워짐.
- 마이그레이션 시 변경 폭이 큼.

> 일반 도메인: **PK는 단일 인조키**, 유일성은 **UNIQUE(복합 가능)**로 분리.

---

## 참조 무결성: ON DELETE/UPDATE 정책의 의미

| 옵션 | 의미 | 권장 사용처 |
|---|---|---|
| RESTRICT/NO ACTION | 자식 있으면 부모 삭제 금지 | 대부분의 핵심 참조 |
| CASCADE | 부모 삭제 시 자식 자동 삭제 | 강한 종속(로그/세부항목) |
| SET NULL | 부모 삭제 시 FK NULL | 부모-자식 느슨한 연결 |
| SET DEFAULT | 기본값으로 치환 | 코드 테이블 등 일부 |

> 삭제비용/감사 요구/보존정책에 따라 선택. **CASCADE는 강력**하지만, 실수로 **대량 삭제 전파** 가능 → 운영 가드 필요.

```sql
FOREIGN KEY (order_id)
  REFERENCES "order"(order_id)
  ON DELETE CASCADE;
```

---

## 템포럴/감사/분석 키: SCD 및 시점 조회

- 운영 PK(서로게이트)와 별개로, 분석계는 **SCD Type 2**로 **서로게이트 키(SK)**를 쓴다.
- 한 자연키(예: `customer_id`)에 **여러 버전**이 존재, **시점 질의** 지원.

```sql
CREATE TABLE dim_customer (
  sk_customer   BIGSERIAL PRIMARY KEY,
  customer_id   BIGINT NOT NULL, -- 운영 키
  email         TEXT  NOT NULL,
  effective_from DATE NOT NULL,
  effective_to   DATE,
  is_current     BOOLEAN NOT NULL,
  UNIQUE (customer_id, effective_from)
);
```

---

## 파티셔닝/샤딩 키와 PK의 관계

- **파티션 키**는 주로 **시간/범위/테넌트**.
- **PK/UK가 파티션 키를 포함**하면 **로컬 인덱스/단일 파티션 쿼리**에 유리.
- 글로벌 유니크 요구가 있을 경우 **전역 인덱스/라우팅** 전략 설계.

```sql
-- 날짜 파티션(엔진별 문법 상이), PK는 (order_id)지만
-- 조회/관리 파티션 키(ordered_at)에 맞춰 보조 인덱스/제약을 설계
```

---

## 키와 정규화: 부분/이행 종속 제거

정규화 핵심은 **키에 대한 종속성** 정리다.

- 2NF: **부분 종속 제거**(복합키의 일부에만 종속한 속성 제거).
- 3NF: **이행 종속 제거**(키→A→B 형태에서 B는 키에만 종속).

수식 관점(개념적 표현):
$$
\text{For 3NF: If } X \to A \text{ and } A \not\subseteq X,\ \text{then } X \text{ is a superkey or } A \text{ is prime.}
$$

---

## 키 도메인/포맷/컬레이션/대소문자

- 문자열 키의 **컬레이션**과 **대소문자** 정책(이메일/사용자명)은 **유니크 판단**에 직접 영향.
- **CITEXT**(대소문자 구분 없는 텍스트) 타입(PostgreSQL) 활용 검토.
- 국제화 식별자(예: 사용자명)에서는 **정규화(NFC/NFKC)**/금지 문자 정책 필요.

```sql
-- PostgreSQL 예: citext
-- CREATE EXTENSION citext;
ALTER TABLE app_user ALTER COLUMN email TYPE citext;
```

---

## 예제 도메인: 커머스 키 설계(완성형)

### 스키마

```sql
-- 사용자
CREATE TABLE app_user (
  user_id     BIGSERIAL PRIMARY KEY,         -- PK(인조키)
  email       TEXT NOT NULL UNIQUE,          -- AK(대체키)
  username    TEXT NOT NULL UNIQUE,          -- AK
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 고객(테넌트 도입 예)
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,         -- PK
  tenant_id   BIGINT NOT NULL,               -- 파티셔닝/샤딩 경계 후보
  ext_code    TEXT,                          -- 외부 시스템 자연키
  name        TEXT NOT NULL,
  UNIQUE (tenant_id, ext_code)               -- 테넌트 내 자연키 유니크
);

-- 상품
CREATE TABLE product (
  product_id  BIGSERIAL PRIMARY KEY,
  sku         TEXT NOT NULL UNIQUE,          -- 자연키 후보(대체키)
  name        TEXT NOT NULL,
  price       NUMERIC(12,2) NOT NULL CHECK (price >= 0)
);

-- 주문
CREATE TABLE "order" (
  order_id    BIGSERIAL PRIMARY KEY,
  order_no    TEXT NOT NULL UNIQUE,          -- 외부 노출용(대체키)
  customer_id BIGINT NOT NULL,
  ordered_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  status      TEXT NOT NULL CHECK (status IN ('PENDING','PAID','CANCELLED','SHIPPED','COMPLETED')),
  FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON DELETE RESTRICT
);
CREATE INDEX idx_order_customer ON "order"(customer_id);

-- 주문 항목(약 엔티티: 식별자 관계)
CREATE TABLE order_item (
  order_id   BIGINT NOT NULL,
  line_no    INT    NOT NULL,
  product_id BIGINT NOT NULL,
  qty        INT    NOT NULL CHECK (qty > 0),
  price_at   NUMERIC(12,2) NOT NULL CHECK (price_at >= 0),
  PRIMARY KEY (order_id, line_no),
  FOREIGN KEY (order_id) REFERENCES "order"(order_id) ON DELETE CASCADE,
  FOREIGN KEY (product_id) REFERENCES product(product_id) ON DELETE RESTRICT
);
CREATE INDEX idx_item_product ON order_item(product_id);

-- 결제(슈퍼/서브타입)
CREATE TABLE payment (
  payment_id BIGSERIAL PRIMARY KEY,
  order_id   BIGINT NOT NULL UNIQUE REFERENCES "order"(order_id) ON DELETE CASCADE,
  amount     NUMERIC(12,2) NOT NULL,
  paid_at    TIMESTAMPTZ   NOT NULL,
  method     TEXT NOT NULL CHECK (method IN ('CARD','BANK'))
);

CREATE TABLE card_payment (
  payment_id   BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  card_no_hash TEXT  NOT NULL,
  auth_code    TEXT  NOT NULL
);
```

### 대표 질의

```sql
-- 1) 유저/이메일/사용자명 유일성 위배 후보(데이터 품질 점검)
SELECT email, COUNT(*) cnt
FROM app_user
GROUP BY email
HAVING COUNT(*) > 1;

-- 2) 고객-주문 참조 무결성(고아 주문 탐지)
SELECT o.order_id
FROM "order" o
LEFT JOIN customer c ON c.customer_id = o.customer_id
WHERE c.customer_id IS NULL;

-- 3) 주문 중복 line_no 점검
SELECT order_id, line_no, COUNT(*) cnt
FROM order_item
GROUP BY order_id, line_no
HAVING COUNT(*) > 1;

-- 4) 최근 30일 고객별 주문 합계(키 기반 조인)
SELECT c.customer_id, COUNT(*) orders,
       SUM(oi.qty * oi.price_at) AS gross
FROM customer c
JOIN "order" o  ON o.customer_id = c.customer_id
JOIN order_item oi ON oi.order_id = o.order_id
WHERE o.ordered_at >= NOW() - INTERVAL '30 days'
GROUP BY c.customer_id
ORDER BY gross DESC
LIMIT 20;
```

---

## 성능 시나리오: FK 인덱스 유무의 차이

```sql
-- (가정) FK 인덱스가 없는 상태에서 부모 삭제
DELETE FROM customer WHERE customer_id = 123;
-- 자식(order) 탐색을 전테이블 스캔할 수 있어 큰 락/지연 발생 가능

-- FK 인덱스 추가
CREATE INDEX idx_order_customer ON "order"(customer_id);

-- 다시 삭제(조인 후보 탐색이 인덱스로 한정, 락/시간 감소)
DELETE FROM customer WHERE customer_id = 123;
```

운영 팁
- 대량 삭제/갱신은 **작은 배치**로 나누어 처리.
- FK 인덱스 누락을 주기적으로 점검(카탈로그 조회 스크립트 운영).

---

## 마이그레이션: PK 교체/분리의 안전 절차

### 자연키 PK → 인조키 PK 전환

1) **새 인조키 칼럼 추가**(NULL 허용 X, 기본값 시퀀스/UUID).
2) 모든 자식 테이블에 **새 FK 병행 추가**.
3) 애플리케이션을 **새 PK/FK로 전환**(읽기→쓰기).
4) 구 PK를 **UNIQUE 제약**으로 강등(업무 유일성 유지).
5) 충분한 안정화 후 구 FK/구 PK 제거.

```sql
ALTER TABLE customer ADD COLUMN customer_id2 BIGSERIAL;
UPDATE customer SET customer_id2 = DEFAULT;    -- 시퀀스 채우기
ALTER TABLE customer ALTER COLUMN customer_id2 SET NOT NULL;

-- 자식 테이블에 새로운 FK 추가 후, 애플리케이션 전환
-- 전환 완료 뒤:
ALTER TABLE customer ADD CONSTRAINT pk_customer PRIMARY KEY (customer_id2);
ALTER TABLE customer ADD CONSTRAINT uq_customer_old UNIQUE (old_natural_key);
```

### 1:N → N:M 정규화 전환(키 재설계)

- 기존 `order.product_id` 제거, `order_item` 신설(복합 PK).
- 데이터 백필(임시 `line_no=1`) → 코드 전환 → 구 컬럼 제거.

---

## 특수 키 주제

### 멱등 키(Idempotency-Key)

- **중복 요청 방지**(결제/주문).
- `(client_key)`에 **UNIQUE** 부여, 이전 응답 캐싱.

```sql
CREATE TABLE api_idempotency (
  key          TEXT PRIMARY KEY,
  request_hash TEXT NOT NULL,
  response     JSONB,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### 폴리모픽 참조 키(안티패턴 주의)

- 하나의 FK가 다수 테이블을 가리키는 패턴 → **제약 약화**.
- 대안: **슈퍼타입 테이블** 도입 또는 **조인 엔티티**로 모델링.

### 가상/생성 컬럼 기반 키

- 엔진 기능으로 **가공값**을 인덱스/UNIQUE에 활용 가능(전화 정규화 등).

---

## 품질 점검·회귀 테스트 스니펫

```sql
-- 1) FK 인덱스 누락 후보(카탈로그 기반 탐지: DB별 쿼리 상이, 예시)
-- PostgreSQL: pg_constraint / pg_index / pg_attribute 조합으로 FK 열의 인덱스 존재 여부 확인

-- 2) 다중 NULL 유니크 의도 점검(부분 인덱스)
SELECT * FROM app_user WHERE email IS NULL;

-- 3) 실행계획 회귀 감시
EXPLAIN ANALYZE
SELECT o.order_no, SUM(oi.qty*oi.price_at)
FROM "order" o
JOIN order_item oi ON oi.order_id = o.order_id
WHERE o.customer_id = 1
GROUP BY o.order_id;

-- 4) 중복 후보키 탐지
SELECT username, COUNT(*) cnt
FROM app_user
GROUP BY username
HAVING COUNT(*) > 1;
```

---

## 자주 묻는 질문(FAQ)

### Q1. PK는 반드시 숫자여야 하나?

아니다. **숫자 PK**는 인덱스 지역성·길이 측면에서 유리하지만, **UUID/ULID**도 충분히 실전적이다(특히 분산/충돌 회피).

### Q2. 복합 PK를 쓰면 항상 나쁜가?

아니다. **조인 엔티티**나 **자연스럽고 안정적인 조합**이 있을 때 유효하다. 다만 **확장성/ORM/이관 비용**을 고려하라.

### Q3. UNIQUE와 NULL은?

대부분 DB에서 **다중 NULL 허용**. “NULL도 유일해야” 한다면 **부분 인덱스/제약**으로 구현.

### Q4. 이메일을 PK로 써도 되나?

권장하지 않는다. 변경/민감/대소문자/국제화/중복 위험. **PK=인조키**, 이메일은 **UNIQUE**로.

---

## 학습·연습 과제

1) 동일 도메인에서 **PK=BIGSERIAL vs UUID v7**의 인덱스/저장/조인 성능 비교.
2) `order_item`을 **복합 PK** vs **단일 인조키 + UNIQUE(order_id,line_no)**로 설계하여 쿼리/이관 난이도 비교.
3) **FK 인덱스 유무**에 따른 삭제/업데이트 실험(대량 데이터).
4) **UNIQUE + NULL 처리** 패턴을 업무 규칙(다중 NULL 허용/금지)에 맞게 구현.

---

## 결론

- 키는 **데이터의 정체성·무결성의 계약**이며, 인덱스는 **그 계약을 빠르게 지키기 위한 도구**다.
- 일반적으로 **PK=인조키** + **업무 유일성=UNIQUE** 병행이 **안전·유연·확장**적이다.
- FK 인덱스, ON DELETE/UPDATE 정책, NULL·UNIQUE의 의미, 분산 ID 선택, 파티션/샤딩 설계까지 고려해 **현재와 미래의 운영 비용을 최소화**하라.
- 모델은 살아 있는 계약이다. **테스트/모니터링/마이그레이션**으로 지속적으로 개선하라.
