---
layout: post
title: DB - 식별자
date: 2025-01-25 23:20:23 +0900
category: DB
---
# 식별자(Identifier, Key)

## 리마인드(핵심 요약)

키는 데이터를 유일하게 식별하고 무결성을 보장하는 **논리적 계약**입니다. 인덱스는 이러한 키를 빠르게 찾기 위한 **물리적 최적화 도구**이며, 기본키는 자동으로 인덱스를 생성하지만 모든 인덱스가 키는 아닙니다.

**기본키(PK)**는 유일성, NOT NULL, 그리고 한 테이블에 하나만 존재한다는 세 가지 조건을 만족해야 합니다. **후보키(CK)**는 기본키가 될 수 있는 모든 키의 집합이고, 그 중 선택받지 못한 키를 **대체키(AK)**라고 하며 보통 UNIQUE 제약으로 구현됩니다. **외래키(FK)**는 테이블 간의 관계를 정의하고 참조 무결성을 보장하는 핵심 요소로, 성능을 위해 인덱스 생성이 권장됩니다.

실무에서는 대부분 **인조키(예: 자동 증가 숫자, UUID)를 기본키로 사용**하고, **업무적으로 유일해야 하는 값(예: 이메일, 주민등록번호)은 별도의 UNIQUE 제약**으로 관리하는 전략이 안전하고 유연합니다.

---

## 수학적 관점: 키와 함수적 종속

엔티티의 속성 집합을 \(X = \{A_1,\dots,A_n\}\)라고 할 때, **기본키** \(K \subseteq X\)는 다음 두 조건을 만족합니다.

1) **유일성**: 키가 같으면 튜플 전체가 같아야 합니다.
   $$
   \forall t_1, t_2:\ t_1[K] = t_2[K] \Rightarrow t_1 = t_2
   $$

2) **최소성**: 키를 구성하는 어떤 부분집합도 나머지 속성들을 결정할 수 없어야 합니다.
   $$
   \not\exists K' \subset K:\ K' \to X
   $$

즉, 기본키 \(K\)는 모든 속성을 결정하면서(\(K \to X\)), 그 어떤 진부분집합도 같은 결정력을 갖지 않는 최소한의 집합이어야 합니다.

---

## 키의 분류와 구현

### 기본키(Primary Key)
테이블에서 행을 유일하게 식별하는 핵심 키입니다. 데이터베이스는 기본키에 대해 자동으로 인덱스를 생성합니다.

```sql
CREATE TABLE app_user (
  user_id      BIGSERIAL PRIMARY KEY, -- PK & 인덱스 자동 생성
  email        TEXT NOT NULL UNIQUE,  -- 대체키(AK)
  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### 후보키와 대체키
**후보키**는 기본키 후보가 되는 모든 키들의 집합입니다. 예를 들어, `사용자` 테이블에서 `user_id`, `email`, `주민등록번호` 모두 후보키가 될 수 있습니다. 이 중 기본키로 선택되지 않은 후보키들을 **대체키**라고 하며, `UNIQUE` 제약으로 구현됩니다.

### 복합키(Composite Key)
두 개 이상의 컬럼을 조합하여 유일성을 보장하는 키입니다. 특히 다대다(N:M) 관계를 해소하는 조인 테이블에서 자주 사용됩니다.

```sql
CREATE TABLE enrollment (
  student_id BIGINT NOT NULL,
  course_id  BIGINT NOT NULL,
  PRIMARY KEY (student_id, course_id) -- 복합 기본키
);
```

### 외래키(Foreign Key)
다른 테이블의 기본키를 참조하여 테이블 간의 관계를 정의하고 참조 무결성을 보장합니다. 외래키 컬럼에는 인덱스를 생성하는 것이 성능상 매우 중요합니다.

```sql
CREATE TABLE "order" (
  order_id    BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL,
  FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON DELETE RESTRICT
);
-- 외래키 인덱스 생성 (성능 향상)
CREATE INDEX idx_order_customer ON "order"(customer_id);
```

---

## 자연키 vs 인조키: 선택 기준

**자연키**는 업무 도메인에서 자연스럽게 존재하는 식별자(예: 이메일, 주민등록번호, 사번)입니다. 반면 **인조키**(또는 대리키)는 데이터베이스 시스템이 생성한 의미 없는 식별자(예: 자동 증가 숫자, UUID)입니다.

| 고려사항 | 자연키 | 인조키 |
|---|---|---|
| **의미성** | 높음 (업무 의미 반영) | 없음 (단순 식별자) |
| **변경 가능성** | 존재할 수 있음 (이메일 변경 등) | 없음 (불변 설계) |
| **보안성** | 민감정보 노출 위험 | 노출해도 의미 없음 |
| **성능** | 길이에 따라 인덱스 부담 가능 | 일반적으로 짧고 효율적 |
| **유연성** | 마이그레이션 어려움 | 시스템 변경에 유연함 |

**실무 권장**: 기본키로는 **인조키**(BIGINT, UUID 등)를 사용하고, 업무적으로 유일해야 하는 값은 별도의 **UNIQUE 제약**으로 관리하세요. 이 방식이 변경에 유연하고 보안성도 높습니다.

---

## 분산 시스템을 위한 키 전략

### 시퀀스/IDENTITY
단일 데이터베이스에서 순차적으로 증가하는 숫자입니다. 인덱스 지역성이 좋지만, 분산 환경에서는 쓰기 핫스팟이 발생할 수 있습니다.

### UUID (범용 고유 식별자)
*   **UUID v4**: 완전한 랜덤 값으로, 인덱스 지역성이 떨어질 수 있습니다.
*   **UUID v7**: 시간 기반으로 생성되어 정렬 가능하며, 인덱스 지역성이 v4보다 우수합니다. 최근 추천되는 방식입니다.

### ULID
시간 정렬 가능하고 비교적 짧은 문자열 표현을 가진 식별자입니다. UUID v7과 유사한 목적으로 사용됩니다.

### Snowflake 스타일
Twitter의 Snowflake에서 유래한 방식으로, 64비트 정수에 타임스탬프, 워커 ID, 시퀀스를 조합합니다. 분산 환경에서 고성능 ID 생성을 위해 설계되었습니다.

**선택 가이드라인**:
*   단일 데이터베이스라면 **시퀀스/IDENTITY**가 가장 효율적입니다.
*   분산 시스템이거나 글로벌 고유성이 필요하면 **UUID v7**이나 **ULID**를 고려하세요.

---

## NULL과 UNIQUE의 함의

대부분의 데이터베이스 시스템(PostgreSQL, MySQL, SQL Server)에서는 UNIQUE 제약이 있는 컬럼에 **여러 개의 NULL 값을 허용**합니다. 이는 NULL을 "알 수 없는 값"으로 해석하기 때문입니다.

업무 규칙상 "NULL이어도 하나의 행만 존재해야 한다"면, 부분 인덱스(Partial Index)를 사용해야 합니다.

```sql
-- PostgreSQL: 이메일이 NULL이 아닐 때만 유일성을 검사
CREATE UNIQUE INDEX uq_user_email_notnull
ON app_user (email) WHERE email IS NOT NULL;
```

---

## 참조 무결성과 삭제 정책

외래키는 참조하는 데이터의 삭제 또는 수정 시 동작을 정의할 수 있습니다.

| 옵션 | 의미 | 사용 예시 |
|---|---|---|
| **RESTRICT / NO ACTION** | 자식 데이터가 있으면 부모 삭제 금지 | 고객이 존재하는 주문을 삭제 불가 |
| **CASCADE** | 부모 삭제 시 모든 자식 데이터도 삭제 | 주문 삭제 시 주문 항목도 함께 삭제 |
| **SET NULL** | 부모 삭제 시 자식의 FK를 NULL로 설정 | 부서 삭제 시 사원의 부서ID를 NULL로 |
| **SET DEFAULT** | 부모 삭제 시 자식의 FK를 기본값으로 설정 | 특별한 기본값이 정의된 경우 |

**CASCADE는 매우 강력한 옵션**으로, 실수로 대량 데이터가 삭제될 수 있으므로 신중하게 사용해야 합니다.

---

## 실전 예제: 커머스 시스템 키 설계

```sql
-- 고객 테이블: 인조키 PK + 업무 대체키
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,      -- PK (인조키)
  email       TEXT NOT NULL UNIQUE,       -- 대체키 (AK)
  personal_id TEXT UNIQUE,                -- 대체키 (주민번호, 암호화 저장 가정)
  name        TEXT NOT NULL
);

-- 주문 테이블
CREATE TABLE "order" (
  order_id    BIGSERIAL PRIMARY KEY,
  order_no    TEXT NOT NULL UNIQUE,       -- 외부 노출용 주문번호 (대체키)
  customer_id BIGINT NOT NULL,
  ordered_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON DELETE RESTRICT
);
CREATE INDEX idx_order_customer ON "order"(customer_id);

-- 주문 항목: 복합 PK 사용 (주문 내 유일한 라인)
CREATE TABLE order_item (
  order_id   BIGINT NOT NULL,
  line_no    INT    NOT NULL,
  product_id BIGINT NOT NULL,
  quantity   INT    NOT NULL CHECK (quantity > 0),
  PRIMARY KEY (order_id, line_no),        -- 복합 기본키
  FOREIGN KEY (order_id) REFERENCES "order"(order_id) ON DELETE CASCADE
);
```

---

## 마이그레이션: 자연키에서 인조키로 전환

기존 자연키 기반 시스템을 인조키로 전환하는 안전한 절차:

1. **새 인조키 컬럼 추가**: NULL을 허용하지 않고 기본값 설정
2. **자식 테이블에 새 외래키 추가**: 기존 관계 유지하면서 새 키로 연결
3. **애플리케이션 전환**: 읽기부터 시작하여 쓰기까지 점진적으로 전환
4. **기존 자연키를 UNIQUE 제약으로 변경**: 업무 유일성은 유지
5. **구조 정리**: 안정화 후 기존 외래키와 불필요한 인덱스 제거

```sql
-- 1단계: 새 인조키 추가
ALTER TABLE customer ADD COLUMN new_id BIGSERIAL;
UPDATE customer SET new_id = DEFAULT;
ALTER TABLE customer ALTER COLUMN new_id SET NOT NULL;

-- 4단계: 기존 자연키를 UNIQUE 제약으로 변경
ALTER TABLE customer ADD CONSTRAINT uq_customer_old_key UNIQUE (old_natural_key);
```

---

## 자주 묻는 질문

### Q1. 기본키는 반드시 숫자여야 하나요?
아니요. 숫자(BIGINT)가 인덱스 성능과 저장 공간 측면에서 유리하지만, UUID나 ULID도 분산 시스템에서는 훌륭한 선택입니다. 특히 UUID v7은 시간 정렬이 가능해 인덱스 지역성 문제를 완화합니다.

### Q2. 이메일을 기본키로 사용해도 되나요?
권장하지 않습니다. 이메일은 변경 가능성, 대소문자 문제, 국제화 이슈, 보안 문제(개인정보 노출) 등 여러 가지 문제가 있습니다. 기본키는 인조키를 사용하고, 이메일은 UNIQUE 제약으로 관리하세요.

### Q3. 복합 기본키는 언제 사용하나요?
다대다 관계를 나타내는 조인 테이블이나, "학생ID + 강의ID + 수강회차"와 같이 자연스러운 복합 식별자가 존재할 때 사용할 수 있습니다. 하지만 ORM 매핑의 복잡성과 마이그레이션 비용을 고려해야 합니다.

### Q4. 모든 외래키에 인덱스가 필요한가요?
대부분의 경우 필요합니다. 외래키 인덱스는 부모 테이블의 행을 삭제하거나 업데이트할 때 자식 테이블을 효율적으로 검색하며, 조인 성능도 향상시킵니다. 단, 데이터량이 매우 적거나 쓰기 성능이 극도로 중요한 특수한 경우는 예외일 수 있습니다.

---

## 결론

식별자는 단순한 기술적 선택이 아닌, 데이터의 정체성과 무결성을 정의하는 **시스템의 핵심 계약**입니다. 기본키로 인조키를 사용하고 업무 유일성은 별도 제약으로 관리하는 전략은 대부분의 시나리오에서 안전하고 유연한 기반을 제공합니다.

키 설계는 현재의 요구사항뿐만 아니라 미래의 확장성도 고려해야 합니다. 분산 환경을 대비한 키 전략(UUID v7, ULID), 참조 무결성 정책, 인덱스 전략까지 종합적으로 검토해야 합니다. 또한 키는 한번 설계하면 변경하기 어렵기 때문에, 초기 설계에 충분한 시간을 투자하고 지속적인 테스트와 모니터링을 통해 데이터 무결성을 유지하는 것이 중요합니다. 좋은 키 설계는 시스템의 장기적인 안정성과 유지보수성을 결정하는 토대가 됩니다.