---
layout: post
title: JavaScript - 조건문과 반복문
date: 2025-04-12 20:20:23 +0900
category: JavaScript
---
# 조건문과 반복문 (if, switch, for, while)

## 0. 사전 지식: Truthy/Falsy와 조건식 평가

- 조건식은 내부적으로 **ToBoolean** 규칙을 적용한다.
- **falsy**: `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`  
  그 외 대부분은 **truthy** (예: `[]`, `{}`, `"0"`, `new Boolean(false)`)

```js
if ("") console.log("실행 안됨");
if ([]) console.log("실행됨");         // 빈 배열은 truthy
if (new Boolean(false)) console.log("실행됨"); // 객체는 truthy
```

---

## 1. 조건문 — if / else if / else

### 1.1 기본형과 가드 절(early return)

```js
function classify(age) {
  if (age == null) return "N/A";           // 가드 절: null/undefined 조기 종료
  if (age < 13)   return "어린이";
  if (age < 18)   return "청소년";
  return "성인";
}
```

- **가드 절**은 중첩을 줄여 가독성을 높인다.
- 옵션 병합 시 `??`(nullish 병합)과 함께 쓰면 명확하다.

```js
function init(cfg = {}) {
  const timeout = cfg.timeout ?? 5000; // 0 허용, null/undefined만 대체
  if (timeout <= 0) throw new Error("timeout must be positive");
  return timeout;
}
```

### 1.2 복합 조건과 단축 평가

```js
// 조건을 의미 단위로 나눠 가독성 확보
const isValidEmail = (s) =>
  typeof s === "string" && s.includes("@") && s.split("@")[1].includes(".");
```

---

## 2. switch — **엄격 동등(===)** 기반의 분기

- `switch (expr)`는 각 `case`와 **`===`**로 비교한다(숫자 `"1"` vs 1은 다름).
- `break` 없으면 **fall-through**.

```js
function fruitLabel(fruit) {
  switch (fruit) {
    case "banana":
    case "plantain":        // fall-through 묶음 처리
      return "바나나 계열";
    case "apple":
      return "사과";
    default:
      return "기타";
  }
}
```

### 2.1 범위 분기는 if가 적합, switch에는 **범주형 값**이 적합

```js
// 숫자 범위는 if/else if 사용
function grade(score) {
  if (score >= 90) return "A";
  if (score >= 80) return "B";
  if (score >= 70) return "C";
  return "D";
}
```

### 2.2 에러 코드 → 메시지 맵핑(객체/Map이 더 깔끔한 경우)

```js
const messages = {
  E_INVALID: "입력 오류",
  E_TIMEOUT: "타임아웃",
  E_NOTFOUND: "리소스 없음",
};

function msg(code) {
  return messages[code] ?? "알 수 없는 오류";
}
```

---

## 3. 반복문 총정리

### 3.1 전통적 for

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

- **반복 횟수 명확**하거나 인덱스 기반 접근이 필요할 때 적합.

### 3.2 while / do...while

```js
let i = 0;
while (i < 5) { console.log(i++); }

let j = 0;
do { console.log(j++); } while (j < 5); // 최소 1회 실행
```

- 횟수 불명/조건 기반 루프는 `while`.
- `do...while`은 **적어도 1회** 실행이 필요할 때.

### 3.3 for...in vs for...of

- `for...in`: **열거 가능한 키**를 순회(원형 체인 포함 가능). **객체**에 적합, **배열에는 권장 X**.
- `for...of`: **이터러블의 값**을 순회(배열/문자열/Map/Set/TypedArray/제너레이터 등).

```js
const obj = { a: 1, b: 2 };
for (const k in obj) {
  if (Object.prototype.hasOwnProperty.call(obj, k)) {
    console.log(k, obj[k]);
  }
}

const arr = [10, 20, 30];
for (const v of arr) console.log(v); // 10, 20, 30
```

### 3.4 Map/Set 순회

```js
const m = new Map([["a",1],["b",2]]);
for (const [k, v] of m) console.log(k, v);

const s = new Set([1,2,2,3]);
for (const v of s) console.log(v); // 1,2,3
```

### 3.5 이터러블/이터레이터 프로토콜 이해

```js
const range = {
  from: 1, to: 3,
  [Symbol.iterator]() {
    let cur = this.from;
    return {
      next: () => ({ value: cur, done: cur++ > this.to })
    };
  }
};
for (const v of range) console.log(v); // 1 2 3
```

---

## 4. break / continue / label

### 4.1 기본

```js
for (let i = 1; i <= 5; i++) {
  if (i === 3) continue; // 그 회차 건너뜀
  if (i === 5) break;    // 루프 종료
  console.log(i);
}
// 1, 2, 4
```

### 4.2 라벨을 사용한 중첩 탈출

```js
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i + j > 3) break outer; // 바깥 루프까지 탈출
    console.log(i, j);
  }
}
```

> 라벨은 **과도 사용 지양**. 구조를 함수로 분리하거나 조건을 재설계하는 것이 보통 더 안전하다.

---

## 5. 실전 패턴

### 5.1 FizzBuzz(규칙 기반 분기)

```js
function fizzBuzz(n) {
  for (let i = 1; i <= n; i++) {
    const x = (i % 3 === 0 ? "Fizz" : "") + (i % 5 === 0 ? "Buzz" : "");
    console.log(x || i);
  }
}
```

### 5.2 입력 검증 + 가드 절

```js
function createUser({ id, email }) {
  if (!id || !email) throw new Error("id/email required");
  if (!email.includes("@")) throw new Error("email invalid");
  return { id, email };
}
```

### 5.3 상태 기계(HTTP 요청 흐름)

```js
function handle(state) {
  switch (state) {
    case "idle":     return "대기";
    case "loading":  return "불러오는 중";
    case "success":  return "완료";
    case "error":    return "실패";
    default:         return "알 수 없음";
  }
}
```

### 5.4 재시도 루프(지수 백오프)

```js
async function fetchWithRetry(url, { retries = 3, base = 200 } = {}) {
  let attempt = 0;
  while (attempt <= retries) {
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(res.statusText);
      return await res.json();
    } catch (e) {
      if (attempt === retries) throw e;
      const delay = base * 2 ** attempt;
      await new Promise(r => setTimeout(r, delay));
      attempt++;
    }
  }
}
```

### 5.5 큐 비우기(배치 처리)

```js
function drain(queue, batchSize = 100) {
  while (queue.length) {
    const batch = queue.splice(0, batchSize);
    // 처리
  }
}
```

### 5.6 `switch` 대신 객체 맵 전략

```js
const op = {
  add: (a,b)=>a+b,
  sub: (a,b)=>a-b,
  mul: (a,b)=>a*b,
};

function calc(kind, a, b) {
  const f = op[kind];
  if (!f) throw new Error("unknown op");
  return f(a, b);
}
```

---

## 6. 비동기 반복 — **for await...of**

- **AsyncIterable**을 순회하며 각 단계에서 `await`한다.
- 스트림/페이지네이션/이벤트 소스 처리에 적합.

```js
async function* fetchPages(urls) {
  for (const u of urls) {
    const r = await fetch(u);
    yield r.status;
  }
}

(async () => {
  for await (const status of fetchPages(["/a", "/b"])) {
    console.log(status);
  }
})();
```

---

## 7. 성능·가독성·안전성 팁

1. **조건 단순화**: 복합 조건은 의미 단위 상수/함수로 추출.
2. **분기 재배치**: 발생 확률 높은 케이스를 먼저 배치.
3. **배열 순회**: 대량 데이터는 `for`/`for...of`가 `forEach` 대비 **조금** 빠를 때가 많다(콜백 오버헤드). 가독성이 더 중요하면 `forEach`도 무방.
4. **`for...in`**: 객체에만, 그리고 `hasOwnProperty` 체크.
5. **루프 내부 할당/클로저** 최소화: 필요 객체는 재사용.
6. **break/continue 오남용** 지양: 흐름이 복잡해지면 함수 분리.
7. **switch**는 **카테고리 값**에, 범위/복합 로직은 `if`에.
8. **비동기 루프**: 병렬이 유리하면 `Promise.all`(단, 폭주 주의), 직렬 처리 필요하면 `for await...of`.

---

## 8. 흔한 함정과 대처

### 8.1 switch의 비교는 `===`

```js
switch ("1") {
  case 1:   console.log("숫자 1"); break;
  case "1": console.log("문자열 1"); break; // 이쪽만 실행
}
```

### 8.2 do...while의 세미콜론

```js
do { console.log("once"); } while (false); // 끝의 ; 필수
```

### 8.3 for...in으로 배열 순회 (권장 X)

```js
const a = [10, 20];
a.foo = 99;
for (const k in a) console.log(k); // "0", "1", "foo" (예상 밖)
```

### 8.4 무한 루프 방지

```js
let i = 0;
while (true) {
  if (++i > 1000) break; // 안전장치
}
```

---

## 9. 종합 예제: 로그 필터링 & 집계

**문제**: 다음 로그에서 에러만 수집하고, 코드별 건수를 집계하라.
```js
const logs = [
  { level: "info",  msg: "ok" },
  { level: "error", code: "E_TIMEOUT", msg: "timeout" },
  { level: "warn",  msg: "slow" },
  { level: "error", code: "E_INVALID", msg: "invalid" },
  { level: "error", code: "E_TIMEOUT", msg: "retry" },
];
```

**풀이**:

```js
function summarizeErrors(entries) {
  const counts = Object.create(null);   // 깨끗한 해시 맵
  const errors = [];

  for (const e of entries) {
    if (e.level !== "error") continue;  // 필터
    errors.push(e);
    const k = e.code ?? "UNKNOWN";
    counts[k] = (counts[k] ?? 0) + 1;
  }
  return { errors, counts };
}

console.log(summarizeErrors(logs));
/*
{
  errors: [ ... 3개 ... ],
  counts: { E_TIMEOUT: 2, E_INVALID: 1 }
}
*/
```

---

## 10. 미니 퀴즈(자기 점검)

```js
// Q1: 출력은?
let v = 0;
if (v || "A") console.log("X");

// Q2: 어떤 분기가 실행될까?
switch (0) {
  case false: console.log("F"); break;
  case 0:     console.log("Z"); break;
  default:    console.log("D");
}

// Q3: 무엇이 잘못됐나?
const arr = [1,2,3];
for (const k in arr) {
  if (arr[k] % 2 === 0) continue;
  console.log(k); // 기대는 값? 인덱스 vs 값?
}

// Q4: 무한 루프를 막는 안전장치 추가
let i = 0;
while (/* 조건 불명 */) {
  // ...
}

// Q5: 비동기 리스트를 차례로 요청 — for await...of로 바꾸기
async function* gen(urls) { for (const u of urls) yield u; }
```

**해설 힌트**

- Q1) `v || "A"` → `"A"`(truthy) → `"X"` 출력.
- Q2) `switch`는 `===` → `0 === false`는 false, `0 === 0`은 true → `"Z"`.
- Q3) `for...in`은 **키**(문자열 인덱스)를 순회. 값이 아니라 `"0","1","2"`가 출력됨. 배열 값 순회는 `for...of`.
- Q4) 카운터/타임아웃을 도입해 `break` 조건을 명시.
- Q5) `for await (const url of gen(urls)) { await fetch(url) }`.

---

## 11. 체크리스트 요약

- [ ] 값이 카테고리면 **`switch`**, 범위/복합 로직은 **`if`**.
- [ ] 배열/이터러블 값 순회는 **`for...of`**, 객체 키는 **`for...in`**(+ `hasOwnProperty`).
- [ ] **break/continue**는 절제해서 사용, 중첩 탈출은 가급적 구조 재설계(필요 시 label).
- [ ] 비동기는 **`for await...of`**로 단계적 처리, 병렬은 `Promise.all`(부하 주의).
- [ ] 루프 종료 조건/안전장치를 **명시**.
- [ ] 조건은 **가드 절**로 단순화, 기본값은 `??`로 명확히.

---

## 12. 결론

조건문과 반복문은 **프로그램의 제어 흐름**을 설계하는 기본 도구다.  
**엄격 비교**, **Truthiness**, **이터러블 순회 규칙**, **단축 평가와 가드 절**, **break/continue/label**의 역할을 이해하면  
분기와 반복을 *안전하고 읽기 쉬운 구조*로 설계할 수 있다.  
실전에서는 **switch/객체 맵/상태기계**·**for/for...of/for await...of**를 상황에 맞게 선택하고,  
항상 **종료 조건과 예외 흐름**을 명시하라.