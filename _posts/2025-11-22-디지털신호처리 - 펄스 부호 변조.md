---
layout: post
title: 디지털신호처리 - 펄스 부호 변조
date: 2025-11-22 18:25:23 +0900
category: 디지털신호처리
---
# 펄스 부호 변조(PCM, Pulse Code Modulation)

핵심 흐름은 단순하다.

1. **샘플링(Sampling)**: 시간축을 이산화 → \(x(t)\to x[n]\)
2. **양자화(Quantization)**: 진폭을 이산화 → \(x[n]\to \hat{x}[n]\)
3. **부호화(Encoding)**: 이산 진폭을 비트로 표현 → \(\hat{x}[n]\to b[n]\)

---

## 0) PCM이 필요한 이유와 위치

### 디지털 시스템의 “입구”

마이크, 가속도계, 전압/전류 센서, RF 수신기 등 대부분의 센서는 연속값을 출력한다.
디지털 처리(필터링, 분석, 압축, 추정, 제어)를 하려면 결국 “연속값 → 비트열” 변환이 필요하다.
PCM이 바로 이 변환의 **기본 형식**이다.

### PCM의 장점/단점

- 장점
  1. **표준적이고 단순**: 구현/분석/호환이 쉽다.
  2. **잡음 해석이 명료**: 양자화 잡음 모델로 성능을 예측 가능.
  3. **재생 품질이 일정**: 링크에서 비트가 정확히 전달되면 원신호 품질이 유지된다.

- 단점
  1. **비트율이 큼**: 고품질일수록 비트율이 급증.
  2. **양자화 왜곡**: 비트 수가 적으면 잡음/왜곡이 커진다.
  3. **과부하(overload) 민감**: 입력 레벨 설계가 잘못되면 급격한 클리핑 왜곡.

---

## 1) PCM 체인 전체 개요

### 블록도(개념)

```text
아날로그 x(t)
   │
   ▼
[Anti-Alias LPF]  (대역 제한)
   │
   ▼
[Sampler]         (샘플링: fs)
   │  x[n]
   ▼
[Quantizer]       (양자화: B bits, Δ)
   │  x̂[n]
   ▼
[Encoder]         (이진 부호화)
   │  b[n]
   ▼
디지털 전송/저장/처리
```

### 수식으로 본 핵심 단계

1) 샘플링
$$
x[n] = x(nT_s),\quad T_s=\frac{1}{f_s}
$$

2) 양자화
$$
\hat{x}[n] = Q(x[n]),\quad e[n]=\hat{x}[n]-x[n]
$$

3) 부호화
$$
\hat{x}[n]\ \longrightarrow\ \text{binary index}\ \longrightarrow\ b[n]
$$

---

## 2) 샘플링 — 시간축 이산화

### 나이퀴스트-섀넌 샘플링 정리

연속시간 신호 \(x(t)\)가 **대역제한(bandlimited)** 이고 최대 주파수가 \(f_{\max}\) 라면

$$
f_s \ge 2f_{\max}
$$

로 샘플링하면 **이론상 완전 복원 가능**하다.

### 에일리어싱(aliasing)

샘플링을 너무 낮게 하면 스펙트럼이 겹치며 왜곡이 생긴다.

- 원래 스펙트럼 \(X(f)\)가
- 샘플링 후
  $$
  X_s(f)=\frac{1}{T_s}\sum_{k=-\infty}^{\infty}X(f-kf_s)
  $$
  로 복제되어 겹침.

### Anti-aliasing 필터

실제 시스템은 \(x(t)\)가 완전히 대역제한이 아니므로 샘플러 앞에 **아날로그 저역통과 필터**를 둔다.

설계 관점
- 통과대역: 원하는 신호 대역
- 저지대역: \(f_s/2\) 넘어가는 성분 억제

---

## 3) 양자화 — 진폭축 이산화

### 균일 양자화(uniform quantization)

풀스케일이 \(\pm X_{\max}\), 비트 수 \(B\)일 때

$$
\Delta = \frac{2X_{\max}}{2^B}
$$

미드트레드 양자화기(대표적 구현)

$$
Q(x)=\Delta\left\lfloor\frac{x}{\Delta}+\frac12\right\rfloor
$$

오차

$$
e(x)=Q(x)-x
$$

**과립(granular) 영역**: \(|x| \ll X_{\max}\)
- 오차가 대략 \([-\Delta/2,\Delta/2]\)

**과부하(overload) 영역**: \(|x|>X_{\max}\)
- 포화(clipping)로 큰 비선형 왜곡

---

### 양자화 오차의 확률 모델(이상 가정)

입력이 “충분히 복잡하고 양자화 레벨과 비상관”이면

$$
e \sim \mathcal{U}\left(-\frac{\Delta}{2},\frac{\Delta}{2}\right)
$$

따라서

$$
\mathbb{E}[e]=0,\qquad \sigma_e^2=\mathrm{Var}(e)=\frac{\Delta^2}{12}
$$

이 모델은 PCM 성능을 계산하는 **기본 도구**다.

---

### 사인파 입력에서 SNR 근사

풀스케일 사인:

$$
x[n]=A\sin(\omega_0 n),\quad A=X_{\max}
$$

신호 파워

$$
P_s=\frac{A^2}{2}
$$

양자화 잡음 파워

$$
P_e\approx\frac{\Delta^2}{12}
$$

SNR

$$
\mathrm{SNR}\approx 10\log_{10}\frac{P_s}{P_e}
=10\log_{10}\frac{6A^2}{\Delta^2}
\approx 6.02B+1.76\ \mathrm{dB}
$$

즉 **비트 1개 늘 때마다 SNR이 약 6 dB 증가**한다.

---

## 4) 부호화 — 양자화 레벨을 비트열로

### 레벨 인덱싱

양자화기 출력은 \(2^B\)개의 레벨 중 하나.
이를 인덱스 \(m\in\{0,\dots,2^B-1\}\)로 매핑한다.

### 이진 부호(PCM 코드워드)

인덱스를 \(B\)비트 이진수로 표현하면 PCM 스트림이 된다.

예: \(B=3\)일 때
| 레벨 index \(m\) | 이진 코드 |
|---:|:---|
|0|000|
|1|001|
|2|010|
|3|011|
|4|100|
|5|101|
|6|110|
|7|111|

### 부호화 형식

- **부호-크기(sign-magnitude)**
- **1’s complement, 2’s complement**
- **Offset binary**
- **Gray code**(레벨 인접 오류 최소화)

실무/ADC 내부는 대개 2’s complement 또는 offset binary.

---

## 5) PCM의 비트율(bit rate)과 대역폭

### 비트율

샘플링 주파수 \(f_s\), 비트 수 \(B\)

$$
R_b = B f_s\quad (\mathrm{bits/s})
$$

예: CD 오디오
- \(f_s=44.1\ \mathrm{kHz}\), \(B=16\)
$$
R_b = 16\times 44100 \approx 705.6\ \mathrm{kbit/s}
$$
스테레오면 2배.

### 기본 대역폭 근사

NRZ 전송이라면 최소 대역폭은 대략

$$
B_{\text{min}}\approx \frac{R_b}{2}
$$

실제는 라인코딩/펄스성형에 따라 달라진다.

---

## 6) 비균일 양자화와 컴팬딩(companding)

균일 양자화는 **큰 진폭에 친절하고 작은 진폭에 불친절**하다.
하지만 청각/주관적 지각은 작은 진폭 변화에도 민감하다.
그래서 **로그형 압축 → 균일 양자화 → 로그형 확장**을 한다.

### 개념

압축기 \(F(\cdot)\), 확장기 \(F^{-1}(\cdot)\)

$$
u=F(x),\quad \hat{u}=Q(u),\quad \hat{x}=F^{-1}(\hat{u})
$$

작은 진폭이 더 촘촘한 스텝을 얻어 SNR이 좋아진다.

---

### μ-law 컴팬딩(미국 계열 PSTN 표준)

입력 스케일을 \(|x|\le 1\)로 정규화했을 때

$$
F_\mu(x)=\mathrm{sgn}(x)\frac{\ln(1+\mu|x|)}{\ln(1+\mu)}
$$

역변환

$$
F_\mu^{-1}(y)=\mathrm{sgn}(y)\frac{(1+\mu)^{|y|}-1}{\mu}
$$

보통 \(\mu=255\).

---

### A-law 컴팬딩(유럽 계열 PSTN 표준)

\(A\approx 87.6\)

$$
F_A(x)=
\begin{cases}
\mathrm{sgn}(x)\dfrac{A|x|}{1+\ln A}, & 0\le |x|<1/A\\[6pt]
\mathrm{sgn}(x)\dfrac{1+\ln(A|x|)}{1+\ln A}, & 1/A\le |x|\le 1
\end{cases}
$$

역변환도 구간별로 정의된다.

---

## 7) DPCM/ADPCM — PCM의 예측 기반 확장

### 왜 필요한가

PCM은 샘플 자체를 보내므로 비트율이 크다.
하지만 신호는 보통 **연속성이 강해 예측 가능**하다.
그래서 “샘플이 아니라 **예측 오차**를 양자화해 보내면” 비트율을 줄이거나 품질을 올릴 수 있다.

---

### DPCM 구조

예측기 \(\hat{x}[n]=\sum_{k=1}^{P} a_k \tilde{x}[n-k]\)

오차

$$
d[n]=x[n]-\hat{x}[n]
$$

오차를 양자화/부호화해서 전송.

수신기는 같은 예측기로 복원.

---

### ADPCM

예측 오차의 분산이 시간에 따라 변하므로
양자화 스텝을 적응적으로 조정(자기 스케일링).
음성/저비트 오디오에서 매우 흔하다.

---

## 8) 오버샘플링/노이즈 셰이핑(ΣΔ와의 연결)

PCM에서도 오버샘플링을 하면 대역 내 잡음이 줄어든다.

### 오버샘플링 이득

OSR(oversampling ratio) = \(f_s/(2f_{\max})\)

단순 저역통과+디시메이션하면 대역 내 잡음이 대략

$$
P_{e,\text{in-band}}\propto \frac{1}{\mathrm{OSR}}
$$

따라서 SNR이 약

$$
10\log_{10}\mathrm{OSR}\ \mathrm{dB}
$$

만큼 증가.

### 노이즈 셰이핑

양자화 잡음을 신호대역 밖으로 밀어내는 구조.
정밀 ADC에서 ΣΔ가 사실상 표준인 이유.

---

## 9) GNU Octave로 PCM 체인 직접 구현

이제 샘플링→양자화→부호화를 직접 코딩해 보자.

### 유틸: 미드트레드 균일 양자화

```octave
function xq = q_uniform_mid_tread(x, B, Xmax)
  % x   : 입력(연속값)
  % B   : 비트 수
  % Xmax: 풀스케일
  Delta = 2*Xmax/(2^B);
  x_clip = min(max(x, -Xmax), Xmax-Delta); % 포화 방지(상한 하나 비움)
  xq = Delta * round(x_clip/Delta);
end
```

---

### 실험 1: 사인파 PCM SNR 검증

```octave
clear; close all; clc

Fs = 48000; N = 48000; n = (0:N-1)';
t  = n/Fs;

B = 8; Xmax = 1.0;
f0 = 997.3;                         % 비정합 주파수(스펙트럼 누설 완화)
x  = 0.999*Xmax*sin(2*pi*f0*t);

xq = q_uniform_mid_tread(x, B, Xmax);
e  = xq - x;

Ps = mean(x.^2);
Pe = mean(e.^2);
SNR_meas = 10*log10(Ps/Pe);
SNR_theo = 6.02*B + 1.76;

fprintf("Measured SNR = %.2f dB\n", SNR_meas);
fprintf("Theoretical  ≈ %.2f dB\n", SNR_theo);
```

---

### 실험 2: 비트율 vs 품질 곡선

```octave
clear; close all; clc

Fs=48000; N=48000; n=(0:N-1)'; t=n/Fs;
x = 0.8*sin(2*pi*1000*t) + 0.2*sin(2*pi*3000*t); % 두 톤 혼합

Xmax=1.0;
Bs = 4:2:16;
snrs = zeros(size(Bs));
rb   = zeros(size(Bs));

for i=1:length(Bs)
  B=Bs(i);
  xq=q_uniform_mid_tread(x,B,Xmax);
  e=xq-x;
  snrs(i)=10*log10(mean(x.^2)/mean(e.^2));
  rb(i)=B*Fs/1000;  % kbps
end

disp([Bs(:), rb(:), snrs(:)]);
figure;
plot(rb, snrs, "-o"); grid on;
xlabel("Bit rate (kbps)"); ylabel("SNR (dB)");
title("PCM Bit Rate vs SNR");
```

---

### 실험 3: μ-law 컴팬딩의 작은 신호 개선

```octave
function y = mu_compress(x, mu)
  y = sign(x) .* log(1+mu*abs(x)) / log(1+mu);
end
function x = mu_expand(y, mu)
  x = sign(y) .* ((1+mu).^abs(y) - 1) / mu;
end

clear; close all; clc

Fs=48000; N=48000; n=(0:N-1)'; t=n/Fs;
x = 0.03*sin(2*pi*1000*t);          % 작은 신호
B = 8; Xmax=1; mu=255;

% (A) 일반 PCM
xq1 = q_uniform_mid_tread(x, B, Xmax);
e1 = xq1 - x;

% (B) μ-law PCM
u = mu_compress(x, mu);
uq = q_uniform_mid_tread(u, B, 1);  % 압축 후 범위가 [-1,1]
xr = mu_expand(uq, mu);
e2 = xr - x;

fprintf("RMS error normal PCM  = %.3e\n", rms(e1));
fprintf("RMS error mu-law PCM  = %.3e\n", rms(e2));
```

작은 톤에서 μ-law가 RMS 에러를 더 줄이는 것을 확인할 수 있다.

---

### 실험 4: DPCM(1차 예측) 간단 데모

```octave
clear; close all; clc

Fs=16000; N=20000; n=(0:N-1)'; t=n/Fs;
x = sin(2*pi*400*t) + 0.6*sin(2*pi*900*t);
x = x / max(abs(x));

B=4; Xmax=1;
Delta = 2*Xmax/(2^B);

% 1차 예측기: x̂[n]=x̃[n-1]
x_rec = zeros(N,1);
d = zeros(N,1); dq = zeros(N,1);

for k=2:N
  pred = x_rec(k-1);
  d(k) = x(k) - pred;
  dq(k)= Delta*round(d(k)/Delta);       % 예측오차 양자화
  x_rec(k)= pred + dq(k);              % 수신기 복원
end

e_pcm = q_uniform_mid_tread(x,B,Xmax) - x;
e_dpcm = x_rec - x;

fprintf("PCM  SNR  = %.2f dB\n", 10*log10(mean(x.^2)/mean(e_pcm.^2)));
fprintf("DPCM SNR  = %.2f dB\n", 10*log10(mean(x.^2)/mean(e_dpcm.^2)));
```

예측이 잘 맞는 신호에서는 DPCM이 같은 비트 수로 더 좋은 SNR을 얻는다.

---

## 10) PCM 설계 절차(실무형 요약)

### 요구조건 정리

1. **신호 대역폭 \(f_{\max}\)**
2. **목표 SNR / THD+N / ENOB**
3. **허용 비트율/저장량/지연**
4. **입력 동적 범위(풀스케일)와 과부하 허용도**

### 샘플링 주파수 결정

- 최소: \(f_s\ge 2f_{\max}\)
- 실무: 여유(transition band, anti-alias 필터 난이도) 때문에 보통 더 높게.

### 비트 수 결정

- 이론 SNR 근사: \(6.02B+1.76\) dB
- 작은 신호 품질이 중요하면 컴팬딩 고려.

### 포화/스케일링

- 입력 스케일 정합 실패는 가장 치명적인 오류.
- 과부하 방지 여유(headroom)를 둔다.

### (옵션) 컴팬딩 / DPCM / ADPCM / ΣΔ

- 비트율 제한 → 예측/컴팬딩
- 고정밀 ADC → 오버샘플링/노이즈 셰이핑

---

## 11) 연습문제(풀이 힌트 포함)

### 문제 1 — PCM 비트율 계산

대역폭이 \(f_{\max}=3\,\mathrm{kHz}\)인 음성 신호를
\(f_s=8\,\mathrm{kHz},\ B=8\)로 PCM 한다. 비트율 \(R_b\)를 구하라.

**풀이 힌트**
$$
R_b=Bf_s
$$

---

### 문제 2 — SNR 근사

풀스케일 사인 입력을 \(B=10\) 비트 균일 PCM 한다.
이론 SNR을 구하라.

**풀이 힌트**
$$
\mathrm{SNR}\approx 6.02B+1.76
$$

---

### 문제 3 — 과부하 왜곡

\(X_{\max}=1\), \(B=8\) PCM에서 입력이 1.2까지 커질 때
과부하가 생기는 비율을 사인파로 추정하라.

**풀이 힌트**
사인 \(x=A\sin\theta\).
\(|x|>X_{\max}\)인 구간 길이를 전체 주기에서 비율로 계산.

---

### 문제 4 — μ-law 효과 비교

작은 사인 \(A=0.03\)을 8비트 PCM할 때
균일 PCM과 μ-law PCM의 RMS 오차를 Octave로 비교하라.

**풀이 힌트**
§9.4 코드를 그대로 가져와 A만 바꾼다.

---

### 문제 5 — DPCM의 이득 조건

다음 두 신호에 대해 PCM vs 1차 DPCM 성능을 비교하고
DPCM이 유리한 이유를 설명하라.

1) \(x[n]=\sin(0.01\pi n)\) (매우 저주파)
2) \(x[n]=\) 백색잡음

**풀이 힌트**
예측오차의 분산을 비교하면 된다.
저주파는 예측 잘 됨 → 오차 작음 → DPCM 유리.
백색잡음은 예측 불가 → 오차가 원신호와 같음 → 이득 없음.

---

## 12) 전체 정리

PCM은

- **샘플링(시간 이산화)**
- **양자화(진폭 이산화)**
- **부호화(비트열화)**

로 구성되는 **디지털화의 표준 체인**이다.

핵심 성능 식:

- 스텝:
  $$
  \Delta=\frac{2X_{\max}}{2^B}
  $$
- 양자화 잡음:
  $$
  \sigma_e^2=\frac{\Delta^2}{12}
  $$
- 사인 입력 SNR:
  $$
  \mathrm{SNR}\approx 6.02B+1.76\ \mathrm{dB}
  $$
- 비트율:
  $$
  R_b=Bf_s
  $$

실무에선

- **입력 스케일/과부하 방지**
- **비트율↔품질 트레이드오프**
- **작은 신호 품질을 위한 컴팬딩**
- **비트 절감을 위한 DPCM/ADPCM**
- **고정밀을 위한 오버샘플링/노이즈 셰이핑**

이 설계 레버를 조합해 시스템을 만든다.

원하면 다음 글로
- PCM 기반 실제 음성/오디오 코덱(ADPCM, CELP, MDCT 계열)
- ΣΔ ADC의 루프 설계와 안정성
- 고정소수점에서 PCM 체인의 수치 이슈
를 같은 형식으로 이어서 확장해줄 수 있다.
