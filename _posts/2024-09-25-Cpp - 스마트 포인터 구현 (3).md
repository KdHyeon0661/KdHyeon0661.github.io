---
layout: post
title: C++ - 스마트 포인터 구현 (3)
date: 2024-09-25 19:20:23 +0900
category: Cpp
---
# C++ weak_ptr과 enable_shared_from_this 구현: 순환 참조와 자기 참조의 해법

이전 편에서 `shared_ptr`의 참조 카운팅 메커니즘을 구현했다면, 이번에는 공유 소유권 모델의 두 가지 중요한 문제를 해결하는 도구들을 구현해보겠습니다: 순환 참조 문제를 해결하는 `weak_ptr`과, 객체가 자신을 안전하게 참조할 수 있게 하는 `enable_shared_from_this`입니다.

## 순환 참조: 공유 소유권의 그림자

참조 카운팅의 가장 큰 약점은 **순환 참조(cyclic reference)** 문제입니다. 두 객체가 서로를 `shared_ptr`로 참조할 때, 각 객체의 참조 카운트는 결코 0이 되지 않아 메모리 누수가 발생합니다.

```cpp
// 순환 참조의 전형적인 예
class Node {
    std::shared_ptr<Node> next;  // 다음 노드를 강한 참조
};

auto node1 = std::make_shared<Node>();
auto node2 = std::make_shared<Node>();
node1->next = node2;
node2->next = node1;  // 순환 참조 발생! 둘 다 영원히 파괴되지 않음
```

이 문제를 해결하기 위해 `weak_ptr`이 등장합니다. 약한 참조(weak reference)는 객체의 수명에 영향을 주지 않으면서 객체를 관찰할 수 있는 능력을 제공합니다.

## 약한 참조의 메커니즘

`weak_ptr`의 핵심 아이디어는 간단하지만 정교합니다: 객체를 참조하지만 참조 카운트를 증가시키지 않습니다. 대신 컨트롤 블록에는 별도의 `weak_count`를 유지합니다.

```cpp
struct ControlBlockBase {
    std::atomic<long> shared_count{1};  // 강한 참조 카운트
    std::atomic<long> weak_count{0};    // 약한 참조 카운트
    
    virtual void destroy_object() noexcept = 0;
    virtual void delete_this() noexcept = 0;
    virtual ~ControlBlockBase() = default;
};
```

수명 관리 규칙은 다음과 같습니다:
1. **객체 파괴**: `shared_count`가 0이 되는 순간
2. **컨트롤 블록 파괴**: `shared_count`가 0이고 `weak_count`도 0일 때

이 규칙은 약한 참조가 여전히 존재하는 동안에는 컨트롤 블록이 살아있도록 보장하면서, 객체 자체는 적절히 파괴될 수 있게 합니다.

## MyWeakPtr 구현

`MyWeakPtr`의 구현은 `MySharedPtr`과 유사하지만 몇 가지 중요한 차이가 있습니다:

```cpp
template <class T>
class MyWeakPtr {
private:
    T* ptr_ = nullptr;
    ControlBlockBase* ctrl_ = nullptr;
    
public:
    // shared_ptr에서 weak_ptr 생성
    template <class U>
    MyWeakPtr(const MySharedPtr<U>& sp) noexcept
        : ptr_(sp.get()), ctrl_(sp.ctrl_) {
        inc_weak();
    }
    
    // 핵심 메서드: 약한 참조를 강한 참조로 변환
    MySharedPtr<T> lock() const noexcept {
        if (!ctrl_) return MySharedPtr<T>();
        
        long cnt = ctrl_->shared_count.load(std::memory_order_acquire);
        while (cnt > 0) {
            // 원자적으로 shared_count 증가 시도
            if (ctrl_->shared_count.compare_exchange_weak(
                    cnt, cnt + 1,
                    std::memory_order_acq_rel,
                    std::memory_order_acquire)) {
                // 성공: 새로운 shared_ptr 생성
                return MySharedPtr<T>(ctrl_, ptr_);
            }
            // 실패 시 최신 카운트로 재시도
        }
        // 객체가 이미 파괴됨
        return MySharedPtr<T>();
    }
    
    bool expired() const noexcept {
        return !ctrl_ || ctrl_->shared_count.load() == 0;
    }
    
private:
    void inc_weak() noexcept {
        if (ctrl_) ctrl_->weak_count.fetch_add(1);
    }
    
    void dec_weak() noexcept {
        if (!ctrl_) return;
        
        if (ctrl_->weak_count.fetch_sub(1) == 1) {
            // 마지막 약한 참조
            if (ctrl_->shared_count.load() == 0) {
                // 객체도 파괴됐으므로 컨트롤 블록 삭제
                ctrl_->delete_this();
            }
        }
    }
};
```

`lock()` 메서드의 구현이 특히 흥미롭습니다. `compare_exchange_weak`를 사용한 루프는 다른 스레드에서 동시에 참조 카운트를 변경하는 상황에서도 안전하게 작동합니다.

## 순환 참조 해결 패턴

`weak_ptr`을 사용하면 순환 참조 문제를 우아하게 해결할 수 있습니다:

```cpp
class Node {
    std::string name;
    MySharedPtr<Node> next;    // 다음 노드: 강한 참조
    MyWeakPtr<Node> prev;      // 이전 노드: 약한 참조
    
public:
    Node(std::string n) : name(std::move(n)) {}
    ~Node() { std::cout << "~Node(" << name << ")\n"; }
};

// 이중 연결 리스트 구성
auto node1 = my_make_shared<Node>("A");
auto node2 = my_make_shared<Node>("B");

node1->next = node2;      // node1 → node2 (강한 참조)
node2->prev = node1;      // node2 → node1 (약한 참조)

// node1 해제 가능 - node2의 prev는 약한 참조이므로
node1.reset();

// node2는 여전히 유효
assert(node2->prev.expired());  // true
```

이 패턴에서 중요한 점은 한 방향으로만 강한 참조를 사용하고, 반대 방향은 약한 참조를 사용함으로써 순환을 끊는다는 것입니다.

## enable_shared_from_this: 자기 참조의 안전한 방법

비동기 프로그래밍에서 흔히 마주치는 또 다른 문제는 객체가 자신을 참조해야 할 때입니다. 콜백 함수나 이벤트 핸들러에서 `this` 포인터를 캡처하는 것은 위험할 수 있습니다:

```cpp
// 위험한 패턴
class Session {
    void start_async() {
        async_operation([this]() {
            // this가 이미 파괴됐을 수 있음!
            this->handle_completion();
        });
    }
};
```

`enable_shared_from_this`는 이 문제를 해결하기 위해 설계된 CRTP(Curiously Recurring Template Pattern) 기반의 클래스입니다:

```cpp
template <class T>
class enable_shared_from_this {
protected:
    mutable MyWeakPtr<T> weak_this_;
    
public:
    MySharedPtr<T> shared_from_this() {
        auto sp = weak_this_.lock();
        if (!sp) throw my_bad_weak_ptr{};
        return sp;
    }
    
    MyWeakPtr<T> weak_from_this() const noexcept {
        return weak_this_;
    }
    
private:
    template <class U>
    friend class MySharedPtr;
    
    void _accept_owner(const MySharedPtr<T>& owner, T* self) noexcept {
        if (weak_this_.expired()) {
            weak_this_ = MyWeakPtr<T>(owner);
        }
    }
};
```

이 클래스의 마법은 `MySharedPtr`이 객체를 소유하기 시작할 때 자동으로 `weak_this_` 멤버를 설정한다는 점에 있습니다:

```cpp
template <class T>
void MySharedPtr<T>::try_attach_enable_shared_from_this() {
    if constexpr (std::is_base_of<enable_shared_from_this<T>, T>::value) {
        auto* base = static_cast<enable_shared_from_this<T>*>(ptr_);
        base->_accept_owner(*this, ptr_);
    }
}

// 생성자에서 호출
explicit MySharedPtr(T* p) {
    if (p) {
        ctrl_ = new ControlBlockPtr<T, std::default_delete<T>>(p, {});
        ptr_ = p;
        try_attach_enable_shared_from_this();  // 여기서 연결!
    }
}
```

이제 안전한 자기 참조가 가능해집니다:

```cpp
class Session : public enable_shared_from_this<Session> {
public:
    void start_async() {
        auto self = shared_from_this();  // 안전한 자기 참조
        
        async_operation([self]() {
            // self는 shared_ptr이므로 수명이 보장됨
            self->handle_completion();
        });
    }
};
```

## 실제 적용 예시

이 두 도구를 결합하면 견고한 비동기 시스템을 구축할 수 있습니다:

```cpp
class Connection : public enable_shared_from_this<Connection> {
    MyWeakPtr<Connection> self_weak_;
    std::vector<std::function<void()>> pending_callbacks_;
    
public:
    Connection() {
        self_weak_ = weak_from_this();
    }
    
    void schedule_callback(std::function<void()> cb) {
        // 약한 참조를 캡처하여 순환 참조 방지
        pending_callbacks_.push_back([this, weak=self_weak_, cb]() {
            if (auto self = weak.lock()) {
                cb();
            }
            // self가 파괴됐으면 아무 것도 하지 않음
        });
    }
    
    void process_callbacks() {
        for (auto& cb : pending_callbacks_) {
            cb();
        }
        pending_callbacks_.clear();
    }
};
```

이 패턴은 객체가 여전히 존재할 때만 콜백을 실행하고, 객체가 파괴된 경우에는 조용히 무시하는 안전한 시스템을 만듭니다.

## 스레드 안전성과 메모리 모델

`weak_ptr`의 구현은 특히 멀티스레드 환경에서 주의 깊은 설계가 필요합니다:

1. **lock()의 원자성**: `compare_exchange_weak` 루프는 다른 스레드에서 객체가 파괴되는 중에도 안전하게 작동합니다.
2. **메모리 순서**: `memory_order_acq_rel`과 `memory_order_acquire`의 적절한 사용은 파괴 연산의 가시성을 보장합니다.
3. **약한 참조 카운트**: `weak_count`는 컨트롤 블록의 수명을 관리하며, 객체 파괴 후에도 컨트롤 블록이 살아있을 수 있게 합니다.

## 결론

`weak_ptr`과 `enable_shared_from_this`는 `shared_ptr`의 참조 카운팅 시스템을 완성하는 중요한 구성 요소입니다. `weak_ptr`은 순환 참조라는 참조 카운팅의 고질적 문제를 해결하고, 캐시나 관찰자 패턴과 같은 시나리오에서 유용하게 사용됩니다. `enable_shared_from_this`는 객체가 자신을 안전하게 참조할 수 있는 방법을 제공하며, 비동기 프로그래밍과 콜백 기반 시스템에서 필수적입니다.

이 두 도구의 구현을 통해 우리는 C++의 스마트 포인터 시스템이 얼마나 정교하게 설계되었는지 깊이 이해할 수 있었습니다. 단순한 메모리 관리 도구를 넘어, 현대 소프트웨어의 복잡한 수명 관리 문제를 해결하는 강력한 추상화라는 점이 인상적입니다.

그러나 이 추상화에는 비용이 따릅니다. 원자적 연산의 오버헤드, 추가적인 메모리 사용(약한 참조 카운트), 그리고 더 복잡한 수명 관리 규칙은 성능이 중요한 상황에서는 고려해야 할 요소입니다. 이러한 트레이드오프를 이해하는 것이 적절한 도구 선택과 효율적인 시스템 설계의 열쇠입니다.

다음 편에서는 배열 지원, 커스텀 삭제자의 고급 사용법, 그리고 다형성 캐스팅과 같은 실용적인 기능들을 구현하며, 우리의 스마트 포인터 시스템을 완성해나가겠습니다.