---
layout: post
title: C++ - 스마트 포인터 구현 (3)
date: 2024-09-25 19:20:23 +0900
category: Cpp
---
# C++ 스마트 포인터 구현 3/6 — `MyWeakPtr`(약참조) & `enable_shared_from_this`

> 목표: 2편에서 만든 **컨트롤 블록(공유/약참조 카운트)** 를 바탕으로  
> (1) **약참조(`MyWeakPtr`)** 를 구현하고, (2) **자기 자신을 안전하게 `shared_ptr`로 꺼내는** `enable_shared_from_this` 호환을 직접 만든다.  
> 본 편의 구현은 4~6편에서 다룰 **순환 참조 해결·리소스 관리 고급 패턴**의 기반이 된다.

---

## 0. 로드맵 & 전편 요약

- 1편: `MyUniquePtr` — 단독 소유(이동 전용)
- 2편: `MySharedPtr` — 컨트롤 블록, 참조 카운팅, `my_make_shared` 1회 할당, **aliasing 생성자**
- **3편(이번)**: `MyWeakPtr`(약참조), `enable_shared_from_this`(자기참조 안전화)
- 4편: 배열/커스텀 deleter 고급, 다형성, 불완전형
- 5편: 실전 적용/벤치마킹/안전 가이드
- 6편: 테스트, 디버그 어댑터, 인터페이스 정리

---

## 1. 왜 `weak` 이 필요한가?

### 1.1 순환 참조(Circular Reference) 문제

`shared_ptr` 두 개가 서로를 가리키면 **둘 다 참조 카운트가 0이 되지 않아** 객체가 **영원히 해제되지 않는다**.

```
A(shared_ptr) --> B(shared_ptr)
^                               |
|-------------------------------|
```

이를 끊는 표준 수단이 **약참조(weak)** 이다. 약참조는 **소유권이 없고** 수명 연장을 하지 않는다.

### 1.2 카운트 불변식

컨트롤 블록은 다음을 유지한다:

$$
\text{shared\_count} \ge 0,\quad \text{weak\_count} \ge 0
$$

- $$\text{shared\_count} = 0$$ 이 되는 **순간**: **객체 파괴**(`destroy_object()`)
- 그 이후 $$\text{weak\_count} = 0$$ 이 되면: **컨트롤 블록 파괴**(`delete_this()`)

---

## 2. 2편 컨트롤 블록(재사용)

> 2편에서 이미 아래 구조를 만들었다. (요약만 표기, 세부는 2편 참고)

```cpp
struct ControlBlockBase {
    std::atomic<long> shared_count{1};
    std::atomic<long> weak_count{0};
    virtual void destroy_object() noexcept = 0;
    virtual void delete_this() noexcept = 0;
    virtual void* get_object_ptr() noexcept = 0;
    virtual ~ControlBlockBase() = default;
};

template <class T, class Deleter>
struct ControlBlockPtr final : ControlBlockBase { /* 외부 포인터 + deleter */ };

template <class T>
struct ControlBlockInplace final : ControlBlockBase { /* my_make_shared용 in-place */ };
```

---

## 3. `MyWeakPtr<T>` 설계

### 3.1 핵심 포인트

- **소유권 없음**: 객체 수명에 영향을 주지 않는다.
- **잠금(lock)**: 살아있으면 `MySharedPtr<T>`를 **생성**해 돌려준다.
- **aliasing 보존**: `shared_ptr`에서 만든 `weak_ptr`는 **그때의 관찰 포인터**(aliased pointer)를 기억해야 한다.

### 3.2 인터페이스(목업)

```cpp
template <class T>
class MyWeakPtr {
public:
    MyWeakPtr() noexcept;
    MyWeakPtr(const MyWeakPtr&) noexcept;
    MyWeakPtr(MyWeakPtr&&) noexcept;

    template <class U> MyWeakPtr(const MyWeakPtr<U>&) noexcept;
    template <class U> MyWeakPtr(const MySharedPtr<U>&) noexcept; // ← 핵심: from shared

    ~MyWeakPtr();

    MyWeakPtr& operator=(const MyWeakPtr&) noexcept;
    MyWeakPtr& operator=(MyWeakPtr&&) noexcept;
    template <class U> MyWeakPtr& operator=(const MyWeakPtr<U>&) noexcept;
    template <class U> MyWeakPtr& operator=(const MySharedPtr<U>&) noexcept;

    void swap(MyWeakPtr&) noexcept;
    void reset() noexcept;

    long use_count() const noexcept; // 남은 shared 개수 조회
    bool expired() const noexcept;   // 파괴 여부

    MySharedPtr<T> lock() const noexcept; // 살아있으면 shared 생성

private:
    T* ptr_ = nullptr;                 // (aliased pointer) 관찰 포인터
    ControlBlockBase* ctrl_ = nullptr; // 같은 컨트롤 블록 공유

    void inc_weak() noexcept;
    void dec_weak() noexcept;

    template <class U> friend class MyWeakPtr;
    template <class U> friend class MySharedPtr; // enable_shared_from_this 연결용
};
```

### 3.3 구현

```cpp
#include <atomic>
#include <utility>
#include <type_traits>

template <class T>
class MyWeakPtr {
public:
    using element_type = T;

    MyWeakPtr() noexcept = default;

    // from weak
    MyWeakPtr(const MyWeakPtr& other) noexcept
        : ptr_(other.ptr_), ctrl_(other.ctrl_) { inc_weak(); }

    template <class U, class = std::enable_if_t<std::is_convertible<U*,T*>::value>>
    MyWeakPtr(const MyWeakPtr<U>& other) noexcept
        : ptr_(other.ptr_), ctrl_(other.ctrl_) { inc_weak(); }

    MyWeakPtr(MyWeakPtr&& other) noexcept
        : ptr_(other.ptr_), ctrl_(other.ctrl_) {
        other.ptr_ = nullptr; other.ctrl_ = nullptr;
    }

    // from shared (핵심)
    template <class U, class = std::enable_if_t<std::is_convertible<U*,T*>::value>>
    MyWeakPtr(const MySharedPtr<U>& sp) noexcept
        : ptr_(sp.ptr_), ctrl_(sp.ctrl_) { inc_weak(); }

    ~MyWeakPtr() { dec_weak(); }

    // assign
    MyWeakPtr& operator=(const MyWeakPtr& other) noexcept {
        if (this != &other) {
            dec_weak();
            ptr_ = other.ptr_; ctrl_ = other.ctrl_;
            inc_weak();
        }
        return *this;
    }

    MyWeakPtr& operator=(MyWeakPtr&& other) noexcept {
        if (this != &other) {
            dec_weak();
            ptr_ = other.ptr_; ctrl_ = other.ctrl_;
            other.ptr_ = nullptr; other.ctrl_ = nullptr;
        }
        return *this;
    }

    template <class U>
    MyWeakPtr& operator=(const MyWeakPtr<U>& other) noexcept {
        dec_weak();
        ptr_ = other.ptr_; ctrl_ = other.ctrl_;
        inc_weak();
        return *this;
    }

    template <class U>
    MyWeakPtr& operator=(const MySharedPtr<U>& sp) noexcept {
        dec_weak();
        ptr_ = sp.ptr_; ctrl_ = sp.ctrl_;
        inc_weak();
        return *this;
    }

    void reset() noexcept { dec_weak(); ptr_ = nullptr; ctrl_ = nullptr; }

    void swap(MyWeakPtr& other) noexcept {
        using std::swap;
        swap(ptr_, other.ptr_);
        swap(ctrl_, other.ctrl_);
    }

    long use_count() const noexcept {
        return ctrl_ ? ctrl_->shared_count.load(std::memory_order_acquire) : 0;
    }

    bool expired() const noexcept { return use_count() == 0; }

    // 살아있으면 shared를 "원자적으로" 1 증가시키며 획득
    MySharedPtr<T> lock() const noexcept {
        if (!ctrl_) return MySharedPtr<T>();
        long cnt = ctrl_->shared_count.load(std::memory_order_acquire);
        while (cnt > 0) {
            if (ctrl_->shared_count.compare_exchange_weak(
                    cnt, cnt + 1,
                    std::memory_order_acq_rel,
                    std::memory_order_acquire)) {
                // 성공: 새 shared 생성
                return MySharedPtr<T>(ctrl_, ptr_); // 내부 전용 생성자
            }
            // 실패 시 cnt가 최신 값으로 갱신되어 루프 지속
        }
        // 이미 파괴됨
        return MySharedPtr<T>();
    }

private:
    void inc_weak() noexcept {
        if (ctrl_) ctrl_->weak_count.fetch_add(1, std::memory_order_relaxed);
    }
    void dec_weak() noexcept {
        if (!ctrl_) return;
        if (ctrl_->weak_count.fetch_sub(1, std::memory_order_acq_rel) == 1) {
            // 더 이상 약참조 없음. 객체는 이미 파괴된 상태여야 컨트롤 블록 제거 가능.
            if (ctrl_->shared_count.load(std::memory_order_acquire) == 0) {
                ctrl_->delete_this();
            }
        }
        ctrl_ = nullptr; ptr_ = nullptr;
    }

    template <class U> friend class MySharedPtr; // 내부 전용 생성자 접근
};
```

> `lock()` 은 **확실한 증가**를 위해 `compare_exchange_weak` 루프를 쓴다.  
> `shared_count` 가 0이면 이미 파괴된 상태 — 빈 `MySharedPtr` 반환.

---

## 4. `MySharedPtr` 보완: 내부 전용 생성자 & weak 연동

2편에서 제안했던 **내부 전용 생성자**를 실제로 사용한다.  
그리고 `MyWeakPtr`과의 상호 운용을 위해 `friend` 를 연계한다.

```cpp
template <class T>
class MySharedPtr {
public:
    using element_type = T;

private:
    T* ptr_ = nullptr;
    ControlBlockBase* ctrl_ = nullptr;

    // 내부 전용 생성자: 같은 컨트롤 블록을 공유하는 shared 생성(aliased pointer 허용)
    MySharedPtr(ControlBlockBase* c, T* p) noexcept : ptr_(p), ctrl_(c) {}

    template <class U> friend class MySharedPtr;
    template <class U> friend class MyWeakPtr;
    template <class U, class... Args> friend MySharedPtr<U> my_make_shared(Args&&...);

    // ... (나머지 2편 구현 동일: 복사/이동/소멸/aliasing 등)

    // 생성 시점에 enable_shared_from_this 연결용 헬퍼 호출(§5)
    void try_attach_enable_shared_from_this();
};
```

---

## 5. `enable_shared_from_this<T>` 구현

### 5.1 개념

- `T` 가 `enable_shared_from_this<T>` 를 상속하면, **내부에 약참조**(`weak_this_`) 를 보관한다.
- `shared_from_this()` 호출 시, 이 약참조를 **`lock()`** 하여 **현재 소유 중인 컨트롤 블록**에 엮인 `shared_ptr` 를 안전하게 돌려준다.
- 핵심은 **객체가 반드시 `shared_ptr` 로 관리되고 있을 때만** `shared_from_this()` 를 호출해야 한다.

### 5.2 인터페이스 & 구현

```cpp
#include <exception>

struct my_bad_weak_ptr : std::exception {
    const char* what() const noexcept override { return "bad weak ptr"; }
};

template <class T>
class enable_shared_from_this {
protected:
    mutable MyWeakPtr<T> weak_this_;

public:
    MySharedPtr<T> shared_from_this() {
        auto sp = weak_this_.lock();
        if (!sp) throw my_bad_weak_ptr{};
        return sp;
    }
    MyWeakPtr<T> weak_from_this() const noexcept {
        return weak_this_;
    }

private:
    // MySharedPtr 가 소유를 시작할 때 한 번만 불려서 weak_this_ 세팅
    template <class U>
    void _accept_owner(const MySharedPtr<U>& ownerShared, T* p) const noexcept {
        if (weak_this_.expired()) {
            // ownerShared 와 동일한 컨트롤 블록을 공유하게 약참조 채움
            weak_this_ = MyWeakPtr<T>(MySharedPtr<T>(ownerShared, p)); // aliasing 보존
        }
    }
    template <class U> friend class MySharedPtr; // MySharedPtr에서 접근
};
```

### 5.3 `MySharedPtr` 쪽에서 연결해주기

**규칙**: 오너십을 처음 갖는 순간(**raw 포인터 채택** 또는 **my_make_shared**)에만 연결한다.  
단순 복사/이동/aliasing 생성자는 연결을 건드리지 않는다.

```cpp
template <class T>
void MySharedPtr<T>::try_attach_enable_shared_from_this() {
    if constexpr (std::is_base_of<enable_shared_from_this<T>, T>::value) {
        // 정확히 T가 enable_shared_from_this<T> 를 상속한 경우
        auto* base = static_cast<enable_shared_from_this<T>*>(ptr_);
        base->_accept_owner(*this, ptr_);
    }
    // ※ 실전에서는 "T의 기반/파생 타입" 시나리오(다형성)까지 포괄하려면
    //    더 일반적인 메타프로그래밍/캐스팅 보강이 필요하다. (4편에서 확장)
}
```

그리고 **오너십 생성 경로**에서 이 함수를 호출한다:

```cpp
// raw 포인터 채택 생성자(2편)
explicit MySharedPtr(T* p)
    : ptr_(p), ctrl_(nullptr) {
    if (p) {
        ctrl_ = new ControlBlockPtr<T, std::default_delete<T>>(p, std::default_delete<T>{});
        try_attach_enable_shared_from_this(); // ★ 연결
    }
}

// my_make_shared(§6) 내부 전용 생성자 경로에서도 호출
```

---

## 6. `my_make_shared` — enable_shared_from_this 연결 포함

```cpp
template <class T, class... Args>
MySharedPtr<T> my_make_shared(Args&&... args) {
    auto* ctrl = new ControlBlockInplace<T>(std::forward<Args>(args)...);
    MySharedPtr<T> sp(ctrl, static_cast<T*>(ctrl->get_object_ptr()));
    sp.try_attach_enable_shared_from_this(); // ★ 오너십 첫 연결
    return sp;
}
```

---

## 7. 동작 확인: 예제

### 7.1 순환 참조 방지 — `MyWeakPtr` 활용

```cpp
#include <iostream>
#include <string>

struct Node {
    std::string name;
    MySharedPtr<Node>  next; // 다음 노드는 강참조(예: 리스트 소유)
    MyWeakPtr<Node>    prev; // 이전 노드는 약참조(순환 방지)

    explicit Node(std::string n) : name(std::move(n)) {}
    ~Node() { std::cout << "~Node(" << name << ")\n"; }
};

int main() {
    auto a = my_make_shared<Node>("A");
    auto b = my_make_shared<Node>("B");

    a->next = b;
    b->prev = a; // ← 순환을 weak으로 끊음

    std::cout << "b.prev.expired? " << std::boolalpha << b->prev.expired() << "\n";

    a.reset(); // A 파괴 가능 (B만 남음)
    std::cout << "after a.reset(), b.prev.expired? " << b->prev.expired() << "\n";
}
```

예상 출력(환경마다 줄바꿈/순서는 다를 수 있음):

```
b.prev.expired? false
~Node(A)
after a.reset(), b.prev.expired? true
```

> 핵심: `prev` 가 `weak` 이므로 **A가 해제**될 수 있고, `b->prev.lock()` 은 이후 빈 `shared` 를 돌려준다.

---

### 7.2 `enable_shared_from_this` — 콜백에서 자기 수명 연장

```cpp
#include <functional>
#include <thread>
#include <chrono>

void async_invoke(std::function<void()> cb) {
    std::thread([cb=std::move(cb)]{
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        cb();
    }).detach();
}

struct Session : enable_shared_from_this<Session> {
    void start() {
        // 자기 자신을 안전하게 shared로 캡처
        auto self = shared_from_this();
        async_invoke([self]{
            // 콜백이 실행될 때까지 self가 수명 보장
            self->on_message("ping");
        });
    }
    void on_message(const char* m) {
        std::cout << "Session got: " << m << "\n";
    }
};

int main() {
    auto s = my_make_shared<Session>();
    s->start();
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    // main 종료 전 콜백이 안전히 완료됨
}
```

> `enable_shared_from_this` 가 없다면, 콜백에 **raw this** 를 넘겼을 때  
> 호출 시점에 객체가 이미 파괴된 **댕글링 포인터** 위험이 있다.  
> `shared_from_this()` 로 **컨트롤 블록에 조인**해 수명을 안전히 연장한다.

---

### 7.3 `weak` + aliasing — 서브오브젝트 관찰 유지

```cpp
struct Image {
    int w, h;
    unsigned char* pixels;
    Image(int w,int h): w(w),h(h),pixels(new unsigned char[w*h]{}){}
    ~Image(){ delete[] pixels; }
};

int main() {
    auto img = my_make_shared<Image>(4,4);
    auto pix_sh = MySharedPtr<unsigned char>(img, img->pixels + 5); // aliasing
    MyWeakPtr<unsigned char> pix_w = pix_sh; // 그 지점 관찰

    auto locked = pix_w.lock(); // 살아있으면 같은 alias 로 획득
    if (locked) {
        *locked = 0x7F;
    }

    img.reset(); // Image 파괴 → pixels도 해제
    auto expired = pix_w.lock(); // 빈 shared
    std::cout << "expired? " << std::boolalpha << !expired << "\n";
}
```

---

## 8. 경계 조건 & 주의점

1) **`shared_from_this()` 호출 시점**  
   - 반드시 **`shared_ptr` 가 오너십을 가진 뒤** 호출해야 한다.  
     `my_make_shared` 또는 `MySharedPtr(raw)` 로 소유 시작 이전에 호출하면 **예외(`my_bad_weak_ptr`)**.

2) **다형성(polymorphism) 시나리오**  
   - `struct Base : enable_shared_from_this<Base> {}; struct Der : Base {};`  
   - `MySharedPtr<Base>` 로 생성했을 때 **정확한 연결**을 위해선  
     `_accept_owner` 를 **최종 동적 타입** 기준으로 호출하는 일반화가 필요하다.  
     (4편에서 **SFINAE/캐스팅 보강**으로 확장)

3) **스레드 안전성**  
   - 카운팅은 `std::atomic<long>` 로 구현했다.  
   - `lock()` 은 `compare_exchange_weak` 루프를 사용하여 **파괴 경합**에서 안전.

4) **메모리 순서**  
   - 카운트 증감에 `relaxed / acq_rel / acquire` 를 혼합 사용.  
   - 오브젝트 파괴 경계에서 **해당 오브젝트 쓰기의 가시성**을 확보한다.  
     (고성능/락프리 상호작용은 5편에서 심화)

---

## 9. 요약 체크리스트(3편 달성)

- [x] `MyWeakPtr<T>`: 약참조 구현(aliased pointer 보존)  
- [x] `lock()` 의 원자적 증가 & 안전 획득  
- [x] 컨트롤 블록의 `weak_count` 경계 파괴 처리  
- [x] `enable_shared_from_this<T>` 구현 및 **오너십 최초 연결**  
- [x] `my_make_shared`/raw 채택 경로에서 연결 호출  
- [x] 순환 참조 방지·콜백 자기수명 연장 예제 검증

---

## 10. 부록: 전체 미니 헤더(핵심 조각)

> 실습/리뷰용으로 2편과 3편의 **핵심 타입만** 간략히 묶은 버전.

```cpp
// control_block.hpp
struct ControlBlockBase {
    std::atomic<long> shared_count{1};
    std::atomic<long> weak_count{0};
    virtual void destroy_object() noexcept = 0;
    virtual void delete_this() noexcept = 0;
    virtual void* get_object_ptr() noexcept = 0;
    virtual ~ControlBlockBase() = default;
};

template <class T, class D>
struct ControlBlockPtr final : ControlBlockBase {
    T* ptr; D del;
    ControlBlockPtr(T* p, D d): ptr(p), del(std::move(d)) {}
    void destroy_object() noexcept override { if(ptr){ del(ptr); ptr=nullptr; } }
    void delete_this() noexcept override { delete this; }
    void* get_object_ptr() noexcept override { return ptr; }
};

template <class T>
struct ControlBlockInplace final : ControlBlockBase {
    typename std::aligned_storage<sizeof(T), alignof(T)>::type storage;
    template <class... A>
    ControlBlockInplace(A&&... a){ ::new(&storage) T(std::forward<A>(a)...); }
    T* get() noexcept { return reinterpret_cast<T*>(&storage); }
    void destroy_object() noexcept override { get()->~T(); }
    void delete_this() noexcept override { delete this; }
    void* get_object_ptr() noexcept override { return get(); }
};
```

```cpp
// my_shared_weak.hpp
struct my_bad_weak_ptr : std::exception {
    const char* what() const noexcept override { return "bad weak ptr"; }
};

template <class T> class MySharedPtr;
template <class T> class MyWeakPtr;

template <class T>
class enable_shared_from_this {
protected:
    mutable MyWeakPtr<T> weak_this_;
public:
    MySharedPtr<T> shared_from_this(){
        auto sp = weak_this_.lock();
        if(!sp) throw my_bad_weak_ptr{};
        return sp;
    }
    MyWeakPtr<T> weak_from_this() const noexcept { return weak_this_; }
private:
    template <class U>
    void _accept_owner(const MySharedPtr<U>& sp, T* p) const noexcept {
        if (weak_this_.expired()) { weak_this_ = MyWeakPtr<T>(MySharedPtr<T>(sp, p)); }
    }
    template <class U> friend class MySharedPtr;
};

template <class T>
class MySharedPtr {
public:
    using element_type = T;
    MySharedPtr() noexcept = default;
    explicit MySharedPtr(T* p){
        if(p){ ctrl_=new ControlBlockPtr<T,std::default_delete<T>>(p,{}); ptr_=p; try_attach_enable_shared_from_this(); }
    }
    template <class U>
    MySharedPtr(const MySharedPtr<U>& owner, T* alias) noexcept : ptr_(alias), ctrl_(owner.ctrl_) { inc_shared(); }

    MySharedPtr(const MySharedPtr& o) noexcept : ptr_(o.ptr_), ctrl_(o.ctrl_){ inc_shared(); }
    template <class U, class = std::enable_if_t<std::is_convertible<U*,T*>::value>>
    MySharedPtr(const MySharedPtr<U>& o) noexcept : ptr_(o.ptr_), ctrl_(o.ctrl_){ inc_shared(); }
    MySharedPtr(MySharedPtr&& o) noexcept : ptr_(o.ptr_), ctrl_(o.ctrl_){ o.ptr_=nullptr; o.ctrl_=nullptr; }
    ~MySharedPtr(){ release_shared(); }

    MySharedPtr& operator=(const MySharedPtr& o) noexcept { if(this!=&o){ release_shared(); ptr_=o.ptr_; ctrl_=o.ctrl_; inc_shared(); } return *this; }
    MySharedPtr& operator=(MySharedPtr&& o) noexcept { if(this!=&o){ release_shared(); ptr_=o.ptr_; ctrl_=o.ctrl_; o.ptr_=nullptr; o.ctrl_=nullptr; } return *this; }

    T* get() const noexcept { return ptr_; }
    T& operator*() const noexcept { return *ptr_; }
    T* operator->() const noexcept { return ptr_; }
    explicit operator bool() const noexcept { return ptr_!=nullptr; }
    long use_count() const noexcept { return ctrl_? ctrl_->shared_count.load():0; }

    void reset() noexcept { MySharedPtr().swap(*this); }
    void swap(MySharedPtr& o) noexcept { using std::swap; swap(ptr_,o.ptr_); swap(ctrl_,o.ctrl_); }

private:
    T* ptr_ = nullptr;
    ControlBlockBase* ctrl_ = nullptr;

    MySharedPtr(ControlBlockBase* c, T* p) noexcept : ptr_(p), ctrl_(c) {}
    template <class U, class... A> friend MySharedPtr<U> my_make_shared(A&&...);
    template <class U> friend class MyWeakPtr;

    void inc_shared() noexcept { if(ctrl_) ctrl_->shared_count.fetch_add(1); }
    void release_shared() noexcept {
        if(!ctrl_) return;
        if (ctrl_->shared_count.fetch_sub(1, std::memory_order_acq_rel)==1){
            ctrl_->destroy_object();
            if (ctrl_->weak_count.load(std::memory_order_acquire)==0) ctrl_->delete_this();
        }
        ptr_=nullptr; ctrl_=nullptr;
    }
    void try_attach_enable_shared_from_this(){
        if constexpr (std::is_base_of<enable_shared_from_this<T>,T>::value){
            static_cast<enable_shared_from_this<T>*>(ptr_)->_accept_owner(*this, ptr_);
        }
    }
};

template <class T>
class MyWeakPtr {
public:
    using element_type = T;
    MyWeakPtr() noexcept = default;
    template <class U, class = std::enable_if_t<std::is_convertible<U*,T*>::value>>
    MyWeakPtr(const MySharedPtr<U>& sp) noexcept : ptr_(sp.ptr_), ctrl_(sp.ctrl_) { inc_weak(); }
    MyWeakPtr(const MyWeakPtr& o) noexcept : ptr_(o.ptr_), ctrl_(o.ctrl_) { inc_weak(); }
    ~MyWeakPtr(){ dec_weak(); }
    MySharedPtr<T> lock() const noexcept {
        if(!ctrl_) return {};
        long c = ctrl_->shared_count.load(std::memory_order_acquire);
        while(c>0){
            if(ctrl_->shared_count.compare_exchange_weak(c, c+1, std::memory_order_acq_rel, std::memory_order_acquire))
                return MySharedPtr<T>(ctrl_, ptr_);
        }
        return {};
    }
    bool expired() const noexcept { return !ctrl_ || ctrl_->shared_count.load()==0; }
private:
    T* ptr_ = nullptr;
    ControlBlockBase* ctrl_ = nullptr;
    void inc_weak() noexcept { if(ctrl_) ctrl_->weak_count.fetch_add(1); }
    void dec_weak() noexcept {
        if(!ctrl_) return;
        if(ctrl_->weak_count.fetch_sub(1, std::memory_order_acq_rel)==1){
            if(ctrl_->shared_count.load(std::memory_order_acquire)==0) ctrl_->delete_this();
        }
        ptr_=nullptr; ctrl_=nullptr;
    }
    template <class U> friend class MySharedPtr;
};

template <class T, class... A>
MySharedPtr<T> my_make_shared(A&&... a){
    auto* ctrl = new ControlBlockInplace<T>(std::forward<A>(a)...);
    MySharedPtr<T> sp(ctrl, static_cast<T*>(ctrl->get_object_ptr()));
    sp.try_attach_enable_shared_from_this();
    return sp;
}
```

---

## 11. 마무리

- `MyWeakPtr` 로 **순환 참조를 끊고**,  
- `enable_shared_from_this` 로 **자기 자신을 안전하게 `shared_ptr` 로 노출**할 수 있게 되었다.  
- 4편에서는 **배열/다형성/불완전형/커스텀 deleter 심화**와 함께,  
  `enable_shared_from_this` 의 **다형성 일반화**(기반/파생 타입 연결)까지 확장한다.