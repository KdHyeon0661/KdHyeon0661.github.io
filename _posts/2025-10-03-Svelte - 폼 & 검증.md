---
layout: post
title: Svelte - 폼 & 검증
date: 2025-10-03 16:30:23 +0900
category: Svelte
---
# 10. 폼 & 검증
**기본 `<form>` → 액션으로 이관 · 클라이언트/서버 이중 검증(Zod) · 파일 업로드/진행률 표시 · 이미지 처리 파이프라인(썸네일/EXIF/리사이즈)**

> 이 장은 SvelteKit 애플리케이션에서 **폼을 안전하고 견고하게** 다루는 전 과정을 다룬다.  
> - “일반 HTML 폼”을 **서버 액션(actions)**으로 이관해 **서버 우선(SSR) + 점진적 향상**을 달성  
> - **Zod**를 중심으로 **클라이언트/서버 이중 검증** 패턴 정립  
> - **파일 업로드**(단일/다중), **프로그레스 바**, **오류/재시도** UX  
> - 서버에서의 **이미지 처리 파이프라인**(용량 제한/리사이즈/웹포맷/메타 처리)

---

## 10.1 기본 `<form>` → 액션으로 이관하기

### 10.1.1 “페이지 내부 처리”에서 “서버 액션 처리”로
**출발점**: 간단한 로그인/회원가입 폼을 **컴포넌트 내부 이벤트로 처리**하고 있었다고 가정.  
**목표**: **서버에서** 처리(검증/저장/리다이렉트)하고, JS가 없어도 동작하도록 한다.

#### 1) 가장 단순한 서버 액션
```ts
// src/routes/account/signup/+page.server.ts
import type { Actions } from './$types';
import { fail, redirect } from '@sveltejs/kit';

export const actions: Actions = {
  default: async ({ request }) => {
    const fd = await request.formData();
    const email = String(fd.get('email') ?? '').trim();
    const pass = String(fd.get('password') ?? '');
    if (!email || !pass) {
      // 폼 값 유지 + 오류 메시지
      return fail(400, { message: '필수 입력입니다', values: Object.fromEntries(fd) });
    }
    // TODO: 서버에서 생성(중복 체크/암호 해시/DB 저장)
    // 성공 시 PRG 패턴: 303
    throw redirect(303, '/account/welcome');
  }
};
```

```svelte
<!-- src/routes/account/signup/+page.svelte -->
<script lang="ts">
  export let form; // 액션이 반환한 값(form store)에 자동 반영
</script>

<h1>회원가입</h1>
<form method="POST" class="stack">
  <label>Email <input name="email" value={form?.values?.email ?? ''} /></label>
  <label>Password <input name="password" type="password" /></label>

  {#if form?.message}<p class="err">{form.message}</p>{/if}
  <button>가입</button>
</form>

<style>
  .stack { display: grid; gap: .6rem; }
  .err { color: #b00020; }
</style>
```

- JS 미사용 환경에서도 **서버 POST → 페이지 리렌더**로 작동한다.
- 성공 시 **303 Redirect(PRG)** 로 **중복 제출**과 **새로고침 이슈**를 피한다.

#### 2) 점진적 향상: `enhance`로 AJAX 제출
```svelte
<script lang="ts">
  import { enhance } from '$app/forms';
  export let form;
  let pending = false;

  const opts = () => ({
    async pending() { pending = true; },
    async result({ result, update }) {
      pending = false;
      await update(); // form 스토어 갱신(오류/성공 반영)
      // result.type === 'success' 인 경우, 리다이렉트는 자동 처리됨
    }
  });
</script>

<form method="POST" use:enhance={opts} class="stack">
  <!-- ...같음 -->
  <button disabled={pending}>{pending ? '처리 중…' : '가입'}</button>
</form>
```

> **패턴**: 먼저 **서버 우선**으로 작동하게 만들고, 그 위에 `enhance`로 **UX 업그레이드**.

---

## 10.2 클라이언트/서버 이중 검증(Zod)

> **원칙**: **신뢰 경계**는 서버. 항상 **서버에서 최종 검증**.  
> **동시에** 클라이언트에서 즉시 피드백을 제공해 UX를 높인다.

### 10.2.1 Zod 스키마 공유
```
src/
  lib/
    schema/
      account.ts      # 클라이언트·서버 공용 Zod
```

```ts
// src/lib/schema/account.ts
import { z } from 'zod';

export const SignupSchema = z.object({
  email: z.string().email('유효한 이메일을 입력하세요'),
  password: z.string().min(8, '비밀번호는 8자 이상')
             .regex(/[0-9]/, '숫자를 포함해야 합니다')
             .regex(/[a-zA-Z]/, '영문자를 포함해야 합니다'),
  name: z.string().min(2, '이름은 2자 이상').optional().or(z.literal(''))
});

export type SignupInput = z.infer<typeof SignupSchema>;
```

### 10.2.2 서버 검증(액션)
```ts
// src/routes/account/signup/+page.server.ts
import type { Actions } from './$types';
import { fail, redirect } from '@sveltejs/kit';
import { SignupSchema } from '$lib/schema/account';

export const actions: Actions = {
  default: async ({ request }) => {
    const fd = await request.formData();
    const raw = Object.fromEntries(fd) as Record<string, string>;
    const parsed = SignupSchema.safeParse(raw);

    if (!parsed.success) {
      const fieldErrors = parsed.error.flatten().fieldErrors;
      return fail(400, { message: '입력을 확인하세요', errors: fieldErrors, values: raw });
    }

    const { email, password, name } = parsed.data;
    // TODO: 중복메일 검사/해시/DB 저장
    throw redirect(303, '/account/welcome');
  }
};
```

```svelte
<!-- src/routes/account/signup/+page.svelte -->
<script lang="ts">
  import { SignupSchema } from '$lib/schema/account';
  import { z } from 'zod';
  export let form;

  // 클라이언트 측 즉시 검증(선택)
  let email = form?.values?.email ?? '';
  let password = '';
  let name = form?.values?.name ?? '';
  let clientErrors: Record<string, string[]> = {};

  function validateClient() {
    const res = SignupSchema.safeParse({ email, password, name });
    clientErrors = res.success ? {} : res.error.flatten().fieldErrors as any;
  }
</script>

<form method="POST" on:input={validateClient}>
  <label>
    Email
    <input name="email" bind:value={email} />
    {#if clientErrors.email}<small class="err">{clientErrors.email[0]}</small>{/if}
    {#if form?.errors?.email}<small class="err">{form.errors.email[0]}</small>{/if}
  </label>

  <label>
    Password
    <input name="password" type="password" bind:value={password} />
    {#if clientErrors.password}<small class="err">{clientErrors.password[0]}</small>{/if}
    {#if form?.errors?.password}<small class="err">{form.errors.password[0]}</small>{/if}
  </label>

  <label>
    Name (optional)
    <input name="name" bind:value={name} />
    {#if clientErrors.name}<small class="err">{clientErrors.name[0]}</small>{/if}
  </label>

  {#if form?.message}<p class="err">{form.message}</p>{/if}
  <button>가입</button>
</form>

<style>.err{color:#b00020}</style>
```

> **요점**  
> - **서버**: `safeParse` → `fail(400, { errors, values })`로 **필드 단위** 오류 전달  
> - **클라이언트**: 입력 중 즉시 검증으로 빠른 피드백.  
> - **권장**: 오류 키는 **필드 이름과 동일**하게 유지.

---

## 10.3 파일 업로드 — 단일/다중, 크기 제한, MIME 검증

### 10.3.1 최소 업로드(서버 액션)
```ts
// src/routes/upload/+page.server.ts
import type { Actions } from './$types';
import { fail } from '@sveltejs/kit';

const MAX = 5 * 1024 * 1024; // 5MB

export const actions: Actions = {
  default: async ({ request }) => {
    const fd = await request.formData();
    const file = fd.get('file');

    if (!(file instanceof File)) {
      return fail(400, { message: '파일을 선택하세요' });
    }
    if (file.size === 0) {
      return fail(400, { message: '빈 파일입니다' });
    }
    if (file.size > MAX) {
      return fail(400, { message: '최대 5MB까지 허용' });
    }
    if (!/^image\/(png|jpeg|webp|gif)$/.test(file.type)) {
      return fail(400, { message: '이미지 파일만 업로드 가능' });
    }

    // 서버 저장(예: 파일시스템/스토리지/S3 등)
    // Node 런타임 예시: await fs.writeFile('uploads/'+file.name, Buffer.from(await file.arrayBuffer()));

    return { ok: true, name: file.name, size: file.size, type: file.type };
  }
};
```

```svelte
<!-- src/routes/upload/+page.svelte -->
<script lang="ts"> export let form; </script>

<h1>이미지 업로드</h1>
<form method="POST" enctype="multipart/form-data" class="stack">
  <input type="file" name="file" accept="image/*" />
  <button>업로드</button>
</form>

{#if form?.ok}
  <p>업로드 완료: {form.name} ({Math.round(form.size/1024)} KB)</p>
{:else if form?.message}
  <p class="err">{form.message}</p>
{/if}

<style>.stack{display:grid;gap:.6rem}.err{color:#b00020}</style>
```

### 10.3.2 다중 파일 + Zod로 필드 검증(메타 포함)
```ts
// src/routes/upload/albums/+page.server.ts
import type { Actions } from './$types';
import { fail } from '@sveltejs/kit';
import { z } from 'zod';

const MetaSchema = z.object({
  title: z.string().min(1, '제목 필수'),
  description: z.string().max(200).optional()
});

export const actions: Actions = {
  default: async ({ request }) => {
    const fd = await request.formData();
    const meta = MetaSchema.safeParse({
      title: String(fd.get('title') ?? ''),
      description: String(fd.get('description') ?? '')
    });
    if (!meta.success) {
      return fail(400, { message: '메타 검증 실패', errors: meta.error.flatten().fieldErrors, values: Object.fromEntries(fd) });
    }

    const files = fd.getAll('images');
    if (!files.length) return fail(400, { message: '이미지를 선택하세요', values: Object.fromEntries(fd) });

    for (const f of files) {
      if (!(f instanceof File)) return fail(400, { message: '잘못된 파일' });
      if (f.size === 0) return fail(400, { message: '빈 파일 포함' });
      if (f.size > 10 * 1024 * 1024) return fail(400, { message: '최대 10MB' });
      if (!/^image\//.test(f.type)) return fail(400, { message: '이미지 아닌 파일 포함' });
    }

    // TODO: 저장/썸네일 큐잉 등
    return { ok: true, count: files.length, meta: meta.data };
  }
};
```

```svelte
<!-- src/routes/upload/albums/+page.svelte -->
<script lang="ts"> export let form; </script>

<form method="POST" enctype="multipart/form-data" class="stack">
  <label>제목 <input name="title" value={form?.values?.title ?? ''}/></label>
  {#if form?.errors?.title}<small class="err">{form.errors.title[0]}</small>{/if}

  <label>설명 <textarea name="description">{form?.values?.description ?? ''}</textarea></label>

  <input type="file" name="images" multiple accept="image/*" />
  {#if form?.message}<p class="err">{form.message}</p>{/if}

  <button>업로드</button>
</form>

{#if form?.ok}<p>{form.count}개 업로드 완료</p>{/if}
<style>.stack{display:grid;gap:.6rem}.err{color:#b00020}</style>
```

---

## 10.4 진행률 표시(Progress) — XHR + `enhance` 커스터마이즈

> HTML 표준 `fetch`는 **업로드 진행률 이벤트**를 노출하지 않는다. 진행률이 필요하면 **XMLHttpRequest**를 사용하거나, 백엔드로 청크 업로드를 구현한다. 아래는 **XHR로 대체 전송**하는 `enhance` 활용 예시.

```svelte
<!-- src/routes/upload/progress/+page.svelte -->
<script lang="ts">
  import { enhance } from '$app/forms';
  export let form;

  let pct = 0;
  const opts = ({ form }) => ({
    // fetch 대체: XHR로 전송하여 progress 획득
    async apply(action, data, _formEl) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', action, true);
        xhr.upload.onprogress = (e) => {
          if (e.lengthComputable) pct = Math.round((e.loaded / e.total) * 100);
        };
        xhr.onload = () => {
          // SvelteKit는 액션 결과를 JSON envelope으로 돌려준다.
          try { resolve(JSON.parse(xhr.responseText)); } catch (e) { reject(e); }
        };
        xhr.onerror = reject;
        xhr.send(data);
      });
    },
    async result({ update }) {
      await update(); // form store 반영
      // 성공/실패 메시지는 form으로 전달됨
    }
  });
</script>

<h1>업로드(진행률)</h1>
<form method="POST" enctype="multipart/form-data" use:enhance={opts}>
  <input type="file" name="file" />
  <button>업로드</button>
</form>

{#if pct}
  <div class="bar"><div class="fill" style={`width:${pct}%`}></div></div>
{/if}
{#if form?.message}<p class="err">{form.message}</p>{/if}
{#if form?.ok}<p>완료!</p>{/if}

<style>
  .bar{height:8px;background:#e5e7eb;border-radius:6px;margin:.6rem 0;overflow:hidden}
  .fill{height:100%;background:#0ea5e9}
  .err{color:#b00020}
</style>
```

> **대안**: S3(또는 클라우드 스토리지) **Pre-signed URL**에 직접 업로드 → 서버는 메타만 기록. 이 경우 **XHR** 또는 **업로더 SDK**가 진행률을 제공.

---

## 10.5 이미지 처리 파이프라인 — 리사이즈/웹포맷/EXIF

> 서버에서 업로드된 이미지를 **안전하게 표준화**하는 파이프라인을 구축한다.  
> - **검증**: MIME/크기/픽셀 제한  
> - **리사이즈**: 썸네일/미들/원본  
> - **포맷**: WebP/AVIF로 용량 절감(환경에 따라 지원)  
> - **EXIF**: 회전/위치 정보 제거

### 10.5.1 Sharp 예시(Node 어댑터)
```ts
// src/lib/server/image.ts
import sharp from 'sharp';

export async function normalizeImage(file: File) {
  const buf = Buffer.from(await file.arrayBuffer());

  // 1) 기본 메타
  const meta = await sharp(buf).metadata();
  if (!meta.width || !meta.height) throw new Error('메타 파싱 실패');
  if (meta.width > 8000 || meta.height > 8000) throw new Error('해상도 초과');

  // 2) EXIF 회전 적용 + 메타 제거
  const base = sharp(buf, { failOnError: true }).rotate(); // Orientation 보정

  // 3) 파생 생성
  const [thumb, medium, webp] = await Promise.all([
    base.clone().resize({ width: 320 }).jpeg({ quality: 78, mozjpeg: true }).toBuffer(),
    base.clone().resize({ width: 1280 }).jpeg({ quality: 80, mozjpeg: true }).toBuffer(),
    base.clone().resize({ width: 1280 }).webp({ quality: 78 }).toBuffer()
  ]);

  return {
    thumb, medium, webp,
    meta: { width: meta.width, height: meta.height, format: meta.format }
  };
}
```

```ts
// src/routes/upload/images/+page.server.ts
import type { Actions } from './$types';
import { fail } from '@sveltejs/kit';
import { normalizeImage } from '$lib/server/image';
import { writeFile } from 'node:fs/promises';
import { mkdir } from 'node:fs/promises';

export const actions: Actions = {
  default: async ({ request }) => {
    const fd = await request.formData();
    const file = fd.get('file');
    if (!(file instanceof File)) return fail(400, { message: '파일 없음' });
    if (!/^image\//.test(file.type)) return fail(400, { message: '이미지만 허용' });

    const { thumb, medium, webp } = await normalizeImage(file);

    await mkdir('uploads', { recursive: true });
    const base = crypto.randomUUID();
    await Promise.all([
      writeFile(`uploads/${base}-320.jpg`, thumb),
      writeFile(`uploads/${base}-1280.jpg`, medium),
      writeFile(`uploads/${base}.webp`, webp)
    ]);

    return { ok: true, id: base };
  }
};
```

```svelte
<!-- src/routes/upload/images/+page.svelte -->
<script lang="ts"> export let form; </script>

<h1>이미지 파이프라인</h1>
<form method="POST" enctype="multipart/form-data">
  <input type="file" accept="image/*" name="file" />
  <button>업로드</button>
</form>

{#if form?.ok}
  <p>저장됨: {form.id}</p>
  <img src={`/uploads/${form.id}-320.jpg`} alt="thumb" />
  <img src={`/uploads/${form.id}-1280.jpg`} alt="large" />
  <img src={`/uploads/${form.id}.webp`} alt="webp" />
{:else if form?.message}
  <p class="err">{form.message}</p>
{/if}

<style>.err{color:#b00020}</style>
```

> **배포 환경 주의**  
> - **Node 어댑터**에서 Sharp 사용 가능.  
> - **서버리스/에지**는 Sharp 빌드/성능/메모리 제약이 있을 수 있다. 이 경우  
>   - 업로드는 **스토리지**로, 변환은 **백그라운드 워커/큐**(Cloud Functions/Worker)로 위임  
>   - 혹은 **이미지 CDN**(imgproxy, Cloudflare Images 등) 사용

---

## 10.6 UX 풍부화 — 낙관적 UI/리트라이/에러 연출

### 10.6.1 낙관적 추가 + 실패 롤백(간단)
```svelte
<!-- src/routes/todos/+page.svelte (일부) -->
<script lang="ts">
  import { enhance } from '$app/forms';
  import { invalidate } from '$app/navigation';

  let items = $page.data.items; // 가정
  const opts = () => ({
    async pending({ data }) {
      // 낙관적 추가
      const title = (data as FormData).get('title') as string;
      items = [{ id: 'temp', title, done: false }, ...items];
    },
    async result({ result, update }) {
      if (result.type === 'failure' || result.type === 'error') {
        // 롤백: 전체 무효화로 원상 복원
        await invalidate('/api/todos');
      } else {
        await update();
        await invalidate('/api/todos');
      }
    }
  });
</script>

<form method="POST" use:enhance={opts}>
  <input name="title" required />
  <button>추가</button>
</form>
```

### 10.6.2 서버 에러/검증 메시지 표시 원칙
- **필드 오류**는 각 입력 아래에, **폼 전역 오류**는 상단/버튼 위에  
- 실패 후 **포커스**를 첫 오류 필드로 이동(접근성)

```svelte
<script lang="ts">
  export let form;
  import { onMount, tick } from 'svelte';

  onMount(async () => {
    if (form?.errors) {
      await tick();
      const first = document.querySelector('[aria-invalid="true"]') as HTMLElement | null;
      first?.focus();
    }
  });
</script>

<input name="email" aria-invalid={!!form?.errors?.email} />
```

---

## 10.7 보안 체크리스트(폼/업로드)

- [ ] **서버 우선** 제출(기본 `<form method="POST">`) + `enhance`로 점진적 향상  
- [ ] **검증은 서버가 최종 권위**(Zod 등) — 클라는 보조  
- [ ] **파일**: `size/MIME/픽셀` 제한, **확장자 신뢰 금지**, 저장 시 **랜덤 파일명**  
- [ ] 이미지 처리에서 **EXIF 제거** 또는 **민감 정보(위치) 차단**  
- [ ] 업로드 경로를 **서버에서만 접근 가능**하게(또는 사전 서명 URL)  
- [ ] 큰 업로드는 **직접 스토리지**(S3 등) + **백엔드 콜백**으로 메타 기록  
- [ ] 에러는 **구체적이되 과도한 내부 정보 노출 금지**  
- [ ] PRG(303)로 **중복 제출 방지**  
- [ ] 진입/전환 시 **CSRF** 고려(특히 크로스-사이트 POST 필요 시)  
- [ ] **CSP/파일 컨텐츠 검증**으로 XSS/Content Sniffing 방지

---

## 10.8 종합: “프로필 편집 + 아바타 업로드” 예제

**요구사항**  
- 이름/닉네임 Zod 검증  
- 아바타 업로드(2MB, 이미지), 서버에서 **정사각 리사이즈**  
- 성공 시 **정밀 무효화**로 `/api/me`만 새로고침

### 10.8.1 API `/api/me`
```ts
// src/routes/api/me/+server.ts
import type { RequestHandler } from './$types';

let profile = { name: 'Ada', nick: 'lovelace', avatar: null as string | null };

export const GET: RequestHandler = async () => {
  return new Response(JSON.stringify(profile), { headers:{ 'content-type':'application/json', 'cache-control':'no-store' } });
};
export const PATCH: RequestHandler = async ({ request }) => {
  const body = await request.json();
  profile = { ...profile, ...body };
  return new Response('ok');
};
```

### 10.8.2 페이지 `+page.ts`
```ts
// src/routes/settings/profile/+page.ts
import type { PageLoad } from './$types';

export const load: PageLoad = async ({ fetch, depends }) => {
  depends('/api/me');
  const me = await fetch('/api/me').then(r=>r.json());
  return { me };
};
```

### 10.8.3 서버 액션(검증 + 이미지 파이프라인)
```ts
// src/routes/settings/profile/+page.server.ts
import type { Actions } from './$types';
import { fail } from '@sveltejs/kit';
import { z } from 'zod';
import sharp from 'sharp';

const Schema = z.object({
  name: z.string().min(2, '이름 2자 이상'),
  nick: z.string().min(2).max(20).regex(/^[a-z0-9_]+$/i, '영문/숫자/_')
});

export const actions: Actions = {
  save: async ({ request, fetch }) => {
    const fd = await request.formData();

    const raw = { name: String(fd.get('name') ?? ''), nick: String(fd.get('nick') ?? '') };
    const val = Schema.safeParse(raw);
    if (!val.success) {
      return fail(400, { message: '입력 오류', errors: val.error.flatten().fieldErrors, values: raw });
    }

    let avatarUrl: string | undefined;
    const file = fd.get('avatar');
    if (file instanceof File && file.size) {
      if (file.size > 2*1024*1024) return fail(400, { message: '아바타는 2MB 이하' });
      if (!/^image\/(png|jpeg|webp)$/.test(file.type)) return fail(400, { message: 'PNG/JPEG/WEBP만' });

      const buf = Buffer.from(await file.arrayBuffer());
      // 정사각형 중앙 크롭 후 256x256, webp
      const webp = await sharp(buf).rotate().resize(256,256,{ fit:'cover' }).webp({ quality: 80 }).toBuffer();

      const id = crypto.randomUUID();
      await (await import('node:fs/promises')).mkdir('uploads/avatars', { recursive: true });
      await (await import('node:fs/promises')).writeFile(`uploads/avatars/${id}.webp`, webp);
      avatarUrl = `/uploads/avatars/${id}.webp`;
    }

    // 서버 상태 반영(API)
    await fetch('/api/me', { method: 'PATCH', body: JSON.stringify({ ...val.data, ...(avatarUrl? { avatar: avatarUrl } : {}) }) });

    return { ok: true, avatarUrl };
  }
};
```

### 10.8.4 컴포넌트: `enhance` + 무효화
```svelte
<!-- src/routes/settings/profile/+page.svelte -->
<script lang="ts">
  import { enhance } from '$app/forms';
  import { invalidate } from '$app/navigation';
  export let data; export let form;

  const opts = () => ({
    async result({ result, update }) {
      await update();
      if (result.type === 'success') await invalidate('/api/me');
    }
  });
</script>

<h1>프로필</h1>
<form method="POST" use:enhance={opts} enctype="multipart/form-data" class="stack">
  <label>이름 <input name="name" value={form?.values?.name ?? data.me.name} aria-invalid={!!form?.errors?.name}/></label>
  {#if form?.errors?.name}<small class="err">{form.errors.name[0]}</small>{/if}

  <label>닉네임 <input name="nick" value={form?.values?.nick ?? data.me.nick} aria-invalid={!!form?.errors?.nick}/></label>
  {#if form?.errors?.nick}<small class="err">{form.errors.nick[0]}</small>{/if}

  <label>아바타 <input type="file" name="avatar" accept="image/png,image/jpeg,image/webp" /></label>

  {#if form?.message}<p class="err">{form.message}</p>{/if}
  {#if form?.ok}<p>저장됨!</p>{/if}

  <button name="save">저장</button>
</form>

<section class="preview">
  <h2>미리보기</h2>
  <img src={data.me.avatar ?? '/placeholder-avatar.svg'} alt="avatar" width="128" height="128" />
</section>

<style>
  .stack{display:grid;gap:.6rem;max-width:520px}
  .err{color:#b00020}
  .preview{margin-top:1rem}
  img{border-radius:14px}
</style>
```

---

## 10.9 요약 체크리스트

- [ ] **기본 폼 → 액션**: 서버 우선 제출, JS 없어도 동작  
- [ ] **Zod 공유 스키마**: 클라 즉시 피드백 + 서버 최종 검증  
- [ ] **`fail(400, { errors, values })`**로 값 보존/필드 오류 표시  
- [ ] **파일 업로드**: 크기/MIME/픽셀 제한, 랜덤 파일명, 백엔드 저장  
- [ ] **진행률**: 필요 시 `enhance`의 `apply`로 **XHR** 대체  
- [ ] **이미지 파이프라인**: EXIF 회전, 리사이즈, WebP/AVIF, 메타 제거  
- [ ] **PRG(303)**: 재전송 방지  
- [ ] **무효화**: 성공 후 `invalidate('정밀 URL')`로 필요한 데이터만 새로고침  
- [ ] **보안**: CSRF/CSP/권한 체크(보호 라우트는 `+layout.server.ts` 가드)  
- [ ] **배포 고려**: Sharp/스토리지/백그라운드 워커/이미지 CDN
