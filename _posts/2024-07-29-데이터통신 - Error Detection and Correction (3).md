---
layout: post
title: 데이터 통신 - Error Detection and Correction (3)
date: 2024-07-29 20:20:23 +0900
category: DataCommunication
---
# Error Detection and Correction (3)

앞에서 패리티 비트, CRC, 체크섬 등을 이용해 **오류를 검출**하는 방법을 봤다면,
이번 절은 “**되도록 재전송 없이 스스로 복구하는 방식**”인 **FEC(Forward Error Correction)** 을 다루는 부분이다.

- 오류 검출만 하는 코드는, 오류가 나면 상위 계층이 **ARQ(Automatic Repeat reQuest)** 로 재전송을 요구해야 한다.
- FEC 코드는 수신 측이 **추가 정보를 이용해 오류를 “정정”** 할 수 있다.

---

## Using Hamming Distance

### 1) Hamming Distance의 기본 정의

길이가 $$n$$ 인 두 비트열
$$
\mathbf{x} = (x_1, x_2, \dots, x_n),\quad
\mathbf{y} = (y_1, y_2, \dots, y_n)
$$
의 **해밍 거리(Hamming distance)** 는, 두 비트열이 **서로 다른 위치의 개수**이다.

수식으로 쓰면

$$
d_H(\mathbf{x}, \mathbf{y}) = \sum_{i=1}^{n} \delta(x_i, y_i)
$$

여기서 $$\delta(a,b) = 1$$ 은 $$a \neq b$$ 일 때, 그렇지 않으면 0이다.

예:

- $$\mathbf{x} = 101101, \ \mathbf{y} = 001001$$ 이라면, 서로 다른 위치는 1번째(1 vs 0), 3번째(1 vs 1은 같음), 4번째(1 vs 0), 5번째(0 vs 0), 6번째(1 vs 1이 같음)
  실제로 비교해보면
  - 1번째: 1 vs 0 → 다름
  - 2번째: 0 vs 0 → 같음
  - 3번째: 1 vs 1 → 같음
  - 4번째: 1 vs 0 → 다름
  - 5번째: 0 vs 0 → 같음
  - 6번째: 1 vs 1 → 같음
  → 두 위치가 다르므로
  $$
  d_H(101101, 001001) = 2
  $$

---

### 2) 코드의 최소 거리와 검출/정정 능력

코드 설계에서는 여러 개의 **코드워드(codeword)** 를 정의한다. 예를 들어, 3비트짜리 코드워드 집합이

- 000
- 111

두 개 뿐이라고 하자. 그러면 이 코드는 가능한 모든 코드워드 사이의 Hamming distance 중 **최소값**이

$$
d_{\min} = d_H(000, 111) = 3
$$

이 된다.

이때 중요한 사실은:

- 코드의 최소거리가 $$d_{\min}$$ 이라면,
  이 코드는

  - 최대 $$d_{\min}-1$$ 개의 비트 오류를 **검출**할 수 있고,
  - 최대 $$t = \left\lfloor \frac{d_{\min}-1}{2} \right\rfloor$$ 개의 비트 오류를 **정정**할 수 있다.

요약하면:

$$
\text{검출 가능한 최대 오류 수: } d_{\min} - 1
$$

$$
\text{정정 가능한 최대 오류 수: } t = \left\lfloor \dfrac{d_{\min} - 1}{2} \right\rfloor
$$

#### 예시 1: 단순 패리티 코드

“짝수 패리티”를 쓰는 3비트 코드라고 하자. 데이터 2비트 + 패리티 1비트로 구성한다.

- 00 → 000 (0개 1 → 짝수)
- 01 → 011 (2개 1 → 짝수)
- 10 → 101 (2개 1 → 짝수)
- 11 → 110 (2개 1 → 짝수)

이 코드의 가능한 코드워드는

- 000
- 011
- 101
- 110

네 개이다.

이들 사이의 거리를 모두 계산해 보면

- 000 vs 011 → 2
- 000 vs 101 → 2
- 000 vs 110 → 2
- 011 vs 101 → 2 (0 1 1 vs 1 0 1 → 1·1·0· 비교에서 2개 다름)
- 011 vs 110 → 2
- 101 vs 110 → 2

모든 쌍의 거리가 2이므로 $$d_{\min} = 2$$ 이다.

따라서

- 오류 **검출**: $$d_{\min}-1 = 1$$ → 최대 1비트 오류까지는 항상 검출 가능.
- 오류 **정정**:
  $$
  t = \left\lfloor \frac{2 - 1}{2} \right\rfloor = \left\lfloor \frac{1}{2} \right\rfloor = 0
  $$
  → **정정 능력은 없다.**

즉, 단순 패리티는 “**1비트 오류 검출**” 전용 코드임을 Hamming distance 관점에서 정확하게 설명할 수 있다.

---

#### 예시 2: 두 코드워드만 있는 단순 코드

앞서 든 코드워드 집합 {000, 111}은 $$d_{\min} = 3$$ 이고, 따라서

- 검출: $$d_{\min}-1 = 2$$ → 최대 2비트 오류까지는 검출 가능.
- 정정:
  $$
  t = \left\lfloor \frac{3 - 1}{2} \right\rfloor = 1
  $$

1비트 오류는 항상 정정 가능하다.

수신자가 어떤 3비트 단어를 받았을 때,
- 000에서 거리 1, 111에서 거리 2라면 → 원래는 000
- 000에서 거리 2, 111에서 거리 1이라면 → 원래는 111

식으로, **“가장 가까운 코드워드”** 를 찾으면 되는 구조이다.

---

### 3) Hamming 코드 (7,4)를 통한 구체적인 FEC 예

이제 Hamming distance의 개념을 **실제 FEC 코드**에 적용한 대표적인 예가 **Hamming 코드**이다.

대표적으로

- Hamming(7,4) 코드:
  - 한 코드워드 길이: $$n = 7$$
  - 유효 데이터 비트: $$k = 4$$
  - 패리티 비트: $$n - k = 3$$
  - 최소 거리: $$d_{\min} = 3$$
  - 따라서 $$t = 1$$ → **단일 비트 오류 정정(Single Error Correction, SEC)** 가능.

#### (1) 비트 위치와 패리티 비트 배치

Hamming(7,4) 코드의 전통적인 배치는 다음과 같다.

- 1, 2, 4번 위치: 패리티 비트 $$p_1, p_2, p_4$$
- 3, 5, 6, 7번 위치: 데이터 비트 $$d_3, d_5, d_6, d_7$$

표로 정리하면

| 위치 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|------|---|---|---|---|---|---|---|
| 역할 | p1 | p2 | d3 | p4 | d5 | d6 | d7 |

패리티 비트는 각각 특정 위치들의 “짝수 패리티”를 만족하도록 설정한다.

예를 들어, 흔히 쓰는 규칙 중 하나는

- $$p_1$$: 위치 1, 3, 5, 7의 비트들의 짝수 패리티
- $$p_2$$: 위치 2, 3, 6, 7의 비트들의 짝수 패리티
- $$p_4$$: 위치 4, 5, 6, 7의 비트들의 짝수 패리티

이다.

수식으로 쓰면 (모든 연산은 mod 2)

$$
p_1 = d_3 \oplus d_5 \oplus d_7
$$

$$
p_2 = d_3 \oplus d_6 \oplus d_7
$$

$$
p_4 = d_5 \oplus d_6 \oplus d_7
$$

여기서 $$\oplus$$ 는 XOR(배타적 논리합)을 의미한다.

---

#### (2) 인코딩 예제

데이터 비트가

- $$d_3 = 1,\ d_5 = 0,\ d_6 = 1,\ d_7 = 1$$ (즉, 데이터 4비트는 1 0 1 1)

라고 하자. 그럼 패리티 비트는

- $$p_1 = d_3 \oplus d_5 \oplus d_7 = 1 \oplus 0 \oplus 1 = 0$$
  (1 ⊕ 0 = 1, 1 ⊕ 1 = 0)
- $$p_2 = d_3 \oplus d_6 \oplus d_7 = 1 \oplus 1 \oplus 1 = 1$$
  (1 ⊕ 1 = 0, 0 ⊕ 1 = 1)
- $$p_4 = d_5 \oplus d_6 \oplus d_7 = 0 \oplus 1 \oplus 1 = 0$$
  (0 ⊕ 1 = 1, 1 ⊕ 1 = 0)

따라서 코드워드(7비트)는

| 위치 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|------|---|---|---|---|---|---|---|
| 비트 | p1 | p2 | d3 | p4 | d5 | d6 | d7 |
| 값   | 0  | 1  | 1  | 0  | 0  | 1  | 1  |

즉, 코드워드는

- 0 1 1 0 0 1 1

이 된다.

---

#### (3) 단일 비트 오류 정정 예제

이제 전송 중에 5번 위치의 비트가 뒤집혔다고 가정하자.

- 전송된 코드워드: 0 1 1 0 0 1 1
- 수신된 코드워드: 0 1 1 0 1 1 1
  (5번 위치만 0 → 1로 바뀌었다고 가정)

수신자는 **“각 패리티 검사 그룹의 짝수 패리티가 맞는지”** 를 다시 검사해 본다.

- $$s_1$$: 위치 1, 3, 5, 7의 XOR
  $$
  s_1 = r_1 \oplus r_3 \oplus r_5 \oplus r_7
  $$
  여기서 $$r_i$$ 는 수신된 코드워드의 i번째 비트이다.

  - $$r_1 = 0,\ r_3 = 1,\ r_5 = 1,\ r_7 = 1$$
  $$
  s_1 = 0 \oplus 1 \oplus 1 \oplus 1
  $$
  계산해 보면
  - 0 ⊕ 1 = 1
  - 1 ⊕ 1 = 0
  - 0 ⊕ 1 = 1

  따라서 $$s_1 = 1$$ (패리티 에러 존재)

- $$s_2$$: 위치 2, 3, 6, 7의 XOR
  $$
  s_2 = r_2 \oplus r_3 \oplus r_6 \oplus r_7
  $$
  - $$r_2 = 1,\ r_3 = 1,\ r_6 = 1,\ r_7 = 1$$
  - 1 ⊕ 1 = 0
  - 0 ⊕ 1 = 1
  - 1 ⊕ 1 = 0

  따라서 $$s_2 = 0$$

- $$s_4$$: 위치 4, 5, 6, 7의 XOR
  $$
  s_4 = r_4 \oplus r_5 \oplus r_6 \oplus r_7
  $$
  - $$r_4 = 0,\ r_5 = 1,\ r_6 = 1,\ r_7 = 1$$
  - 0 ⊕ 1 = 1
  - 1 ⊕ 1 = 0
  - 0 ⊕ 1 = 1

  따라서 $$s_4 = 1$$

이때 에러 패턴의 위치는 다음처럼 **3비트 바이너리** 로 해석한다.

$$
\text{에러 위치} = (s_4 s_2 s_1)_2
$$

즉, $$s_4 = 1, s_2 = 0, s_1 = 1$$ 이므로

$$
(1 0 1)_2 = 5
$$

따라서 5번 비트에 오류가 있음을 알 수 있다. 수신자는 5번 비트를 다시 뒤집어

- 0 1 1 0 0 1 1

을 복구한다.

이런 방식으로 Hamming(7,4) 코드는 **임의의 단일 비트 오류를 항상 정확히 찾고, 뒤집어 정정**할 수 있다. 이것이 바로 **최소 거리 3인 코드가 단일 오류 정정 가능**하다는 사실의 구체적인 구현이다.

---

### 4) Hamming 거리 관점의 “공간적” 이해

코드워드들을 $$n$$ 차원 {0,1} 공간의 점이라고 생각해 보자.

- 각 코드워드는 $$n$$차원 공간의 한 점.
- Hamming 거리는 두 점 사이의 “맨해튼 거리”와 비슷한 개념이다.

최소 거리가 $$d_{\min}$$ 인 코드라면, 각 코드워드는 **반지름 $$t = \left\lfloor (d_{\min}-1)/2 \right\rfloor$$ 인 구(sphere)** 를 차지한다. 서로 다른 코드워드에 대해 이 구들이 겹치지 않게 만들 수 있다면, 수신된 단어가 어느 코드워드에 가장 가까운지 명확히 결정할 수 있고, 그 범위 안에서 오류를 정정할 수 있다.

이 그림은 실제로는 고차원이라 그릴 수는 없지만, 개념은 다음과 같다.

- 코드워드들 사이를 **멀리 떨어뜨리면** 오류 정정 능력이 커진다.
- 그 대신 같은 길이 $$n$$ 에 대해 표현할 수 있는 유효 데이터 비트 수 $$k$$ 는 줄어든다 (오버헤드 증가).

따라서 FEC 설계는

- 최소 거리 $$d_{\min}$$ (정정 능력),
- 코드율 $$R = k/n$$ (효율),

사이의 **트레이드오프** 문제라고 볼 수 있다.

---

## Using XOR

이제 Hamming distance라는 개념적 토대 위에서, 네트워크 엔지니어들이 현장에서 가장 많이 사용하는 FEC 형태 중 하나인 **XOR 기반 패킷 FEC** 를 살펴보자.

### 1) XOR의 성질

비트 단위 XOR의 중요한 성질은 두 가지다.

1. $$a \oplus a = 0$$
2. $$a \oplus 0 = a$$

그리고 세 개 이상의 항에 대해서도 교환/결합 법칙이 성립하므로

$$
a \oplus b \oplus a = (a \oplus a) \oplus b = 0 \oplus b = b
$$

이 된다. 즉, **같은 비트열을 두 번 XOR하면 서로 상쇄**된다는 개념이 핵심이다.

---

### 2) 여러 패킷에 대한 XOR 패리티 패킷

가장 단순한 XOR 기반 FEC는 다음과 같은 구조를 가진다.

- 유효 데이터 패킷: $$D_1, D_2, \dots, D_n$$
- FEC 패킷:
  $$
  P = D_1 \oplus D_2 \oplus \dots \oplus D_n
  $$

여기서 각 $$D_i$$ 는 **같은 길이의 비트열(또는 바이트 배열)** 이라고 가정한다.

이제 전송 과정에서 이들 중 하나, 예를 들어 $$D_k$$ 가 완전히 손실되었다고 하자. 나머지와 $$P$$ 를 알고 있으므로

$$
D_k = P \oplus D_1 \oplus \dots \oplus D_{k-1} \oplus D_{k+1} \oplus \dots \oplus D_n
$$

으로 복구할 수 있다. 왜냐하면, 위 식의 오른쪽에 있는 모든 $$D_i$$ 는 총 두 번씩 등장하지만, $$D_k$$ 만 **한 번만 등장**하기 때문이다.

다르게 쓰면

$$
P = D_1 \oplus \dots \oplus D_k \oplus \dots \oplus D_n
$$

이므로

$$
P \oplus D_1 \oplus \dots \oplus D_{k-1} \oplus D_{k+1} \oplus \dots \oplus D_n = D_k
$$

이 되는 것이다.

---

### 3) 간단한 예: 3개 패킷 + XOR 패리티

예를 들어, 3개의 데이터 패킷이 각각 짧은 비트열이라고 하자.

- $$D_1 = 1011$$
- $$D_2 = 0011$$
- $$D_3 = 1100$$

XOR 패리티 패킷은

$$
P = D_1 \oplus D_2 \oplus D_3
$$

계산을 해보면 각 비트 위치별로

- 1번째 비트: 1 ⊕ 0 ⊕ 1 = 0
- 2번째 비트: 0 ⊕ 0 ⊕ 1 = 1
- 3번째 비트: 1 ⊕ 1 ⊕ 0 = 0
- 4번째 비트: 1 ⊕ 1 ⊕ 0 = 0

따라서

- $$P = 0100$$

이라고 하자.

이제 전송 중에 $$D_2$$ 가 통째로 손실되었다고 가정한다.

수신 측은 $$D_1, D_3, P$$ 를 가지고 있고, 이를 통해

$$
D_2 = P \oplus D_1 \oplus D_3
$$

을 계산할 수 있다.

위의 비트 단위 계산을 다시 해보면

- 1번째 비트: 0 ⊕ 1 ⊕ 1 = 0 ⊕ 0 = 0
- 2번째 비트: 1 ⊕ 0 ⊕ 1 = 1 ⊕ 1 = 0
- 3번째 비트: 0 ⊕ 1 ⊕ 0 = 1
- 4번째 비트: 0 ⊕ 1 ⊕ 0 = 1

즉, $$D_2 = 0011$$ 을 정확히 복구할 수 있다.

이 구조의 특징은:

- 한 그룹에 데이터 패킷이 $$n$$ 개 있을 때, **1개의 FEC 패킷을 추가**하면,
  “**그룹 내에서 최대 1개 패킷 손실까지는 복구 가능**”하다.
- 오버헤드는 그룹당 **1/n** 이다. (예: $$n=4$$ 이면 25% 오버헤드, $$n=10$$ 이면 10% 오버헤드)

---

### 4) XOR 기반 FEC의 한계와 확장

단일 XOR 패리티는 **“그룹당 최대 1개 손실”** 까지밖에 커버하지 못한다는 한계가 있다.

- 그룹 안에서 2개 이상의 패킷이 동시에 손실되면, 식이 미지수 두 개 이상을 포함한 연립방정식이 되어 **단순 XOR 하나로는 해결 불가**하다.
- 이 경우에는 **여러 개의 독립적인 XOR 패리티를 서로 다른 조합으로 구성**하거나, 보다 일반적인 **선형 코드(예: Reed–Solomon, LDPC 등)** 를 써야 한다.

예를 들어

- $$P_1 = D_1 \oplus D_2 \oplus D_3 \oplus D_4$$
- $$P_2 = D_1 \oplus D_2 \oplus D_5 \oplus D_6$$

처럼 서로 다른 조합을 XOR해서 여러 개의 패리티를 만들면, 그 조합 행렬이 충분한 Rank를 가지는 한, 선형대수적으로 미지수(손실된 패킷)를 풀어낼 수 있다.

하지만 이 부분은 이미 **일반적인 선형 블록 코드론** 영역이므로, 여기서는 “XOR를 이용한 가장 직관적인 FEC 형태” 정도로 이해하고 넘어가면 된다.

---

## Chunk Interleaving

앞의 Hamming 코드나 XOR 패리티 FEC는 일반적으로 **“랜덤 오류(random errors)”** 가 발생하는 채널에서 잘 동작하도록 설계되어 있다. 그러나 실제 무선 채널, DSL, 저장장치 등에서는 **버스트 오류(burst errors)** 가 자주 발생한다.

- 버스트 오류:
  짧은 시간 동안 **연속된 여러 비트 또는 여러 패킷이 한꺼번에 손상/손실**되는 현상.

FEC는 각 코드워드마다 “최대 몇 개의 오류까지 정정 가능”한지 제한이 있기 때문에, 버스트 오류가 **한 코드워드 안에 집중**되면 그 코드워드는 더 이상 복구할 수 없게 된다.

이를 완화하는 기법이 **Interleaving(인터리빙)** 이다. 여기서는 특히 “Chunk Interleaving”이라는 표현을 **“일정 크기의 조각(Chunk)을 시간/공간상으로 재배열하여 보내는 방법”** 으로 이해하면 된다.

---

### 1) 기본 아이디어: 오류를 “퍼뜨리기”

인터리빙의 핵심 아이디어는 다음 한 문장으로 요약된다.

> “버스트 오류가 나더라도, **같은 코드워드에 속한 비트들이 한꺼번에 깨지지 않도록** 미리 비트를 섞어서 보낸다.”

즉,

- 송신 시:
  논리적으로는 여러 개 코드워드를 **행(row)** 으로 쓴 뒤,
  실제 전송 순서는 **열(column)** 방향으로 보내는 식이다.
- 수신 시:
  다시 반대로 디인터리빙(de-interleaving)을 해서 원래 코드워드들을 복원한다.

이렇게 하면 전송 과정에서 연속된 시간 구간(열 방향)이 깨져도,
각 코드워드의 다른 위치(행 방향)에 조금씩 분산되어 들어가므로,
각 코드워드는 “**각각 적은 수의 오류**”만 겪게 되고, FEC로 정정 가능해진다.

---

### 2) 간단한 비트 인터리빙 예

송신자가 4개의 코드워드를 가지고 있다고 하자. 각 코드워드는 5비트 길이다.

- 코드워드 A: a1 a2 a3 a4 a5
- 코드워드 B: b1 b2 b3 b4 b5
- 코드워드 C: c1 c2 c3 c4 c5
- 코드워드 D: d1 d2 d3 d4 d5

이를 표로 쓰면

| 위치 | 1  | 2  | 3  | 4  | 5  |
|------|----|----|----|----|----|
| A    | a1 | a2 | a3 | a4 | a5 |
| B    | b1 | b2 | b3 | b4 | b5 |
| C    | c1 | c2 | c3 | c4 | c5 |
| D    | d1 | d2 | d3 | d4 | d5 |

보통이라면 A의 5비트, 그다음 B의 5비트, C의 5비트, D의 5비트를 순서대로 보낼 수 있다.

그러나 인터리빙을 적용하면, 전송 순서를 다음과 같이 바꾼다.

1. a1 → B의 b1 → C의 c1 → D의 d1
2. a2 → b2 → c2 → d2
3. a3 → b3 → c3 → d3
4. a4 → b4 → c4 → d4
5. a5 → b5 → c5 → d5

즉, 전송 순서는

- a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4, a5, b5, c5, d5

가 된다.

이제 채널에서 **“연속된 네 비트가 손상된다”** 는 버스트 오류가 발생했다고 하자. 어떤 구간에서든 연속 4비트가 깨질 수 있다. 예를 들어, a3 이후 4비트 구간에서 버스트가 났다면

- a3, b3, c3, d3

이 깨질 것이다.

그러면 각 코드워드 입장에서 보면

- A는 a3 위치 하나만 에러
- B는 b3 위치 하나만 에러
- C는 c3 위치 하나만 에러
- D는 d3 위치 하나만 에러

로 분산된다.

만약 각 코드워드가 “**단일 비트 오류 정정**” 기능을 가진 Hamming 코드였다면, 네 개 중 어떤 것도 망가지지 않고 모두 복구할 수 있다.

반대로 인터리빙을 하지 않았다면, 예를 들어 A의 5비트를 연속 전송하는 구간에서 버스트가 났다면

- a2, a3, a4, a5 (연속 4비트)

가 깨질 것이고, Hamming 코드로는 **한 코드워드 안에서 4비트 오류는 정정 불가능**하다.

---

### 3) Chunk 단위 인터리빙

위 예는 비트 단위 인터리빙이었다. 실제 시스템에서는 다음과 같이 다양한 수준에서 인터리빙이 적용된다.

- **비트 인터리빙**: 비트 단위로 섞음.
- **심볼 인터리빙**: 한 심볼(예: 8비트, 16비트)을 하나의 단위로 보고, 심볼 단위로 섞음.
- **패킷/Chunk 인터리빙**: 패킷이나 “Chunk”를 단위로 보며, 여러 스트림의 Chunk를 시간상으로 섞어서 송출.

Chunk Interleaving은 흔히 다음 상황에서 쓰인다.

- 실시간 오디오/비디오를 여러 프레임으로 나눠 보낼 때,
  하나의 프레임이 어느 한 시점의 네트워크 페이드나 충돌로 통째로 날아가면, **그 프레임 전체가 깨지게 된다.**
- 이를 방지하기 위해,
  하나의 프레임을 여러 개의 Chunk로 나누고, 이 Chunk들을 시간적으로 “섞어서” 보낸다.

예:

- Frame 1: F1-1, F1-2, F1-3, F1-4 (4개의 Chunk)
- Frame 2: F2-1, F2-2, F2-3, F2-4
- Frame 3: F3-1, F3-2, F3-3, F3-4
- Frame 4: F4-1, F4-2, F4-3, F4-4

전송 순서를

- F1-1, F2-1, F3-1, F4-1, F1-2, F2-2, F3-2, F4-2, …

이런 식으로 바꾸면, 잠깐의 패킷 손실 구간이 생겨도 **여러 프레임에 골고루 조금씩 영향**을 줄 뿐이다. 각 프레임은 결손 Chunk 수가 상대적으로 적어지고, 상위 계층에서 **보간·재생성** 등의 기법으로 “조금 깨진 프레임”은 보완하지만, **아예 통째로 사라진 프레임** 같은 상태는 줄어든다.

---

### 4) 인터리빙의 대가: 지연(latency)

인터리빙은 “정보를 여러 프레임에 걸쳐 섞어 보내는” 작업이므로, 자연스럽게 **지연이 증가**한다.

- 송신 측:
  여러 코드워드를 채운 뒤에야, 인터리버 버퍼를 채우고 전송할 수 있다.
- 수신 측:
  역으로 여러 수신 Chunk를 모은 뒤에야, 디인터리빙해서 원래 코드워드/프레임을 복원할 수 있다.

따라서 통신 시스템 설계에서는

- 버스트 오류에 대한 견고함,
- 추가 지연 허용 범위,

사이의 절충이 필요하다.

예를 들어, 실시간 음성 통화에서는 **수십 ms 수준의 추가 지연**은 허용되지만, **수백 ms 이상**은 사용자의 체감 품질을 크게 떨어뜨린다. 반면, VOD(비디오 온디맨드) 스트리밍에서는 수백 ms 정도의 추가 지연은 상대적으로 큰 문제가 되지 않을 수 있다.

---

## Combining Hamming Distance and Interleaving

이제

- “Hamming distance가 충분히 큰 코드가 가진 **단일 코드워드 내부의 오류 정정 능력**”과
- “Interleaving이 주는 **버스트 오류 분산 효과**”

를 결합해 보자.

### 1) 문제 상황: 버스트 오류가 Hamming 코드의 한계를 넘을 때

Hamming(7,4) 코드처럼 $$d_{\min} = 3$$ 인 코드는,
각 코드워드에서 **최대 1비트 오류까지 정정 가능**하다.

하지만 현실 채널에서는 다음과 같은 상황이 일어날 수 있다.

- 한 코드워드에 대해 **연속 3비트**가 동시에 손상.
- Hamming(7,4)는 2비트 이상 오류에 대해서는
  “검출은 가능하지만, 어떤 경우에는 잘못된 코드워드로 정정(오정정)”할 수 있다.

예를 들어, 네 개의 Hamming 코드워드가 있고, 그 중 하나에 3비트 버스트 오류가 난다고 하자. 이 경우

- 그 코드워드는 정정 불가능.
- 나머지 세 개는 문제가 없다.

즉, **버스트가 어디에 걸리느냐에 따라, 한 프레임 전체가 깨질 수도 있고, 아닐 수도 있는** 상황이 된다.

---

### 2) Hamming 코드 + 인터리빙 예제

앞서의 비트 인터리빙 구조를 다시 Hamming 코드에 적용해 보자.

- 각 코드워드: Hamming(7,4) 코드워드, 길이 7비트.
- 네 개의 코드워드: A, B, C, D.

이를 표로 나타내면

| 위치 | 1  | 2  | 3  | 4  | 5  | 6  | 7  |
|------|----|----|----|----|----|----|----|
| A    | a1 | a2 | a3 | a4 | a5 | a6 | a7 |
| B    | b1 | b2 | b3 | b4 | b5 | b6 | b7 |
| C    | c1 | c2 | c3 | c4 | c5 | c6 | c7 |
| D    | d1 | d2 | d3 | d4 | d5 | d6 | d7 |

인터리빙 없이 보낼 경우:

- A의 7비트, B의 7비트, C의 7비트, D의 7비트를 순서대로 보낸다고 하자.
- 만약 채널에서 “연속 4비트”가 깨지는 버스트가 A 코드워드 구간 한복판에 걸리면,
  - 예: a3, a4, a5, a6이 손상
- A 코드워드는 **4비트 오류**를 가지게 되고, Hamming(7,4)로는 정정 불가능하다.

---

이제 **인터리빙**을 적용한다.

전송 순서를 “열 방향”으로 바꾼다.

1. a1, b1, c1, d1
2. a2, b2, c2, d2
3. a3, b3, c3, d3
4. a4, b4, c4, d4
5. a5, b5, c5, d5
6. a6, b6, c6, d6
7. a7, b7, c7, d7

다시 버스트 오류가 “연속 4비트” 구간에서 발생했다고 하자. 예를 들어, 세 번째 묶음 중간에 걸려

- a3, b3, c3, d3

이 손상되었다고 가정하자.

그러면

- A 코드워드: a3 한 비트만 오류
- B 코드워드: b3 한 비트만 오류
- C 코드워드: c3 한 비트만 오류
- D 코드워드: d3 한 비트만 오류

각 코드워드는 **“단일 비트 오류 정정”** 기능으로 자기 오류를 정정할 수 있다.

결과적으로:

- Hamming(7,4) 코드 자체는 여전히 “한 코드워드 내에서 1비트 오류만 정정 가능”이라는 한계를 갖지만,
- 인터리빙 덕분에 **버스트 오류가 여러 코드워드에 분산**되므로,
  - “각 코드워드에 1비트 오류씩”이 되는 경우,
  - 전체 시스템 입장에서는 **버스트 오류도 정정 가능한 것처럼 보이는 효과**가 생긴다.

---

### 3) 설계 관점에서의 일반 원칙

Hamming+Interleaving 조합을 포함해, 많은 FEC 시스템에서 공통으로 쓰이는 설계 원칙은 다음과 같다.

1. 코드가 **단일 코드워드 내에서 정정 가능한 오류 개수**를 $$t$$ 라고 할 때,
2. 인터리버는 채널에서 예상되는 최대 버스트 길이 $$B$$ 에 대해
   - “버스트가 어떤 위치에 와도, 각 코드워드에 분산되는 오류 개수는 $$t$$ 를 넘지 않는다.”
   는 조건을 만족하도록 깊이와 패턴을 설계한다.

예를 들어, **“최대 4비트 버스트 오류가 발생하는 채널에서, 단일 비트 오류 정정 코드(Hamming(7,4))를 쓴다.”** 라는 상황이라면,

- 인터리버 깊이를 4 이상으로 잡고,
- 한 시점에 전송되는 비트들이 서로 다른 코드워드에서 오도록 섞는다.

그러면 버스트가 어느 곳에 와도 각 코드워드는 1비트씩만 영향을 받게 되어, 전체 시스템이 **4비트 버스트까지 견디는** FEC 시스템처럼 동작한다.

---

## Compounding High- and Low-Resolution Packets

마지막으로, FEC와 인터리빙 개념을 **멀티미디어/계층형 서비스**와 결합하는 예를 보자. 여기서 “high- and low-resolution packets”는 다음과 같은 상황을 떠올리면 이해하기 쉽다.

- 동영상 스트리밍에서
  - 저해상도(혹은 기본화질) 스트림: **Base Layer**
  - 고해상도(혹은 추가 디테일) 스트림: **Enhancement Layer**
- 오디오에서
  - 저비트레이트 기본 스트림 + 추가 고역/저역 정보
- 센서 네트워크에서
  - 저정밀 측정값 + 고정밀 보정 정보

네트워크 환경이 나빠도

- **최소한 저해상도(또는 저정밀) 정보는 유지**해서 “끊기지 않는 서비스”를 제공하고,
- 여건이 좋을 때는 **고해상도까지 함께 전송/복구**하는 구조를 설계하는 것이다.

이를 FEC 관점에서 보면, **Unequal Error Protection (UEP)** 구조이다.

---

### 1) Base Layer와 Enhancement Layer의 역할

가장 단순한 계층형 설계는 다음과 같다.

- Base Layer
  - 서비스 품질의 “최소 기준”을 담당.
  - 예: 240p 영상, 저비트 오디오, 기본 센서값 등.
  - **강한 FEC, 낮은 코드율**(예: 1/2, 2/3)을 적용해 손실에 매우 강하게 만든다.
- Enhancement Layer
  - Base Layer 위에 추가로 얹는 “고급 정보”.
  - 예: 1080p 디테일, 서브밴드 오디오, 고정밀 측정값 보정 정보 등.
  - **약한 FEC, 높은 코드율**(예: 3/4, 5/6)을 적용해, 같은 대역폭으로 더 많은 유효 정보를 전달하지만 손실 시 쉽게 깨질 수 있다.

이렇게 하면 네트워크가 나쁠 때도:

- Base Layer는 높은 확률로 살아남아서 **저해상도라도 안정적으로 재생** 가능하고,
- Enhancement Layer는 없어져도 “화질만 떨어질 뿐 서비스는 계속 제공”할 수 있다.

---

### 2) 단순 패킷 예: High/Low 해상도 패킷 구성

한 화면(Frame)을 전송한다고 가정하자.

- Base Layer 데이터: B (저해상도, 필수)
- High Layer 데이터: H (고해상도, 선택)

그리고 네트워크가 총 4개의 패킷을 보낼 수 있는 상황이라고 하자.

#### (1) Base Layer 보호 설계

Base Layer를 두 개의 패킷으로 나눠

- B1, B2

라고 하고, 여기에 XOR 기반 FEC 패킷 하나를 붙인다.

- BP = B1 ⊕ B2

그럼 Base Layer 관련 패킷은

- B1, B2, BP

세 개이다.

이 구조는

- 세 개 중 어느 하나가 손실되어도, 나머지 두 개로 세 번째를 복구할 수 있다.
- 즉, Base Layer에 대해 “3개 중 최대 1개 손실까지 정정 가능”하다.

#### (2) High Layer에 대한 상대적 약한 보호

남은 패킷 하나에 High Layer 전체를 넣는다고 해보자.

- H

그러면 전체 패킷은

- [B1], [B2], [BP], [H]

네 개이다.

전송 중 패킷 손실이 일어나면 다음과 같은 경우가 있을 수 있다.

- 케이스 A: H만 손실
  - Base Layer는 여전히 B1, B2, BP 중 2개 이상이 남았으므로 복구 가능.
  - High Layer가 사라져 화질이 기본 해상도로 떨어지지만, 영상은 끊기지 않고 재생 가능.
- 케이스 B: B1이 손실, H는 살아 있음
  - B2와 BP로 B1 복원 가능.
  - H도 있고, 결국 고해상도 재생 가능.
- 케이스 C: B1, H 두 개 모두 손실
  - Base Layer: B2와 BP만 남아 있으므로 B1 복원 가능 → 기본 영상은 재생 가능.
  - High Layer는 완전히 사라짐 → 화질 저하.
- 케이스 D: B1, B2 두 개가 모두 손실
  - Base Layer는 더 이상 XOR 하나로 복구 불가.
  - 영상 기본층 자체가 깨짐.

이 설계는 Base Layer에 더 많은 보호(3 패킷 중 2 이상 살아남으면 복구 가능)를 주고, High Layer는 보호를 거의 하지 않는 방식이다. 조금 더 고급 설계에서는 High Layer에도 약간의 FEC를 추가한다.

---

### 3) High/Low 해상도 패킷과 Interleaving의 결합

실제 네트워크 환경에서는 패킷 손실/손상도 **버스트 형태**로 나타나는 경우가 많다. 예:

- Wi-Fi 전송에서 특정 짧은 구간에 전파 간섭,
- LTE/5G 무선에서 짧은 페이드,
- 라우터 버퍼가 가득 찼다가 잠깐동안 패킷을 연속 드롭.

이때, Base Layer와 High Layer 패킷을 **시간적으로 섞어 보내면서**, 각 Layer 내부에서도 인터리빙을 적용할 수 있다.

예를 들어, 2프레임을 고려하자.

- Frame 1: B1-1, B1-2, BP1 (Base), H1 (High)
- Frame 2: B2-1, B2-2, BP2, H2

인터리빙 없이 프레임 단위로 보내면

- F1: B1-1, B1-2, BP1, H1
- F2: B2-1, B2-2, BP2, H2

순서로 전송될 것이다.

하지만 Chunk Interleaving을 적용해서

- B1-1, B2-1, B1-2, B2-2, BP1, BP2, H1, H2

같이 섞어서 보낸다면, 특정 짧은 손실 구간이 생겨도

- “Frame 1 전체가 한꺼번에 날아간다”거나
- “Frame 2의 Base Layer가 통째로 깨진다”

같은 최악의 상황을 피할 확률이 높아진다.

---

### 4) 해상도/계층에 따른 명시적 UEP

위의 단순 예에서 우리는

- Base Layer: 강한 XOR FEC (3개 중 2개만 있어도 복구)
- High Layer: 거의 무보호

라는 형태로 “구체적인 계층별 보호 수준”을 정했다.

일반화하면:

1. 패킷에 **중요도 레벨**을 부여한다.
   - Level 0: 절대적으로 중요한 메타데이터, 헤더, 키 프레임 등
   - Level 1: Base Layer 내용
   - Level 2: Enhancement Layer 내용
2. 레벨이 낮을수록(**중요도가 높을수록**) 더 강한 FEC, 더 깊은 인터리빙, 더 보수적인 전송 스케줄링을 적용한다.
3. 레벨이 높을수록(**중요도가 낮을수록**) 약한 FEC, 또는 아예 FEC 없이도 허용한다.

이렇게 하면 네트워크가 나빠질수록:

- 가장 먼저 깨지는 것은 Enhancement Layer와 같은 **부가 정보**이고,
- 마지막까지 살아남는 것은 **헤더, Key Frame, Base Layer** 등이다.

결과적으로 사용자 입장에서는

- “조금 뭉개진 영상, 조금 떨어진 음질” 정도로 품질이 저하되지만,
- **서비스가 완전히 끊어지지는 않는다**는 장점이 있다.

---

### 5) Hamming Distance 관점에서 본 UEP 구조

이론적으로 보면, High/Low 해상도 패킷의 조합은 다음과 같은 해석이 가능하다.

- Base Layer에 대해서는 **최소 거리 $$d_{\min}^{(B)}$$ 가 큰 코드**를 사용해,
  더 많은 오류를 정정할 수 있도록 한다.
- Enhancement Layer에 대해서는 **최소 거리 $$d_{\min}^{(H)}$$ 가 상대적으로 작은 코드**를 사용하거나, 최소 거리 2인 단순 검출 코드만 사용한다.

즉, 두 계층이 서로 다른 코드북을 사용하는 셈이고, 각 코드북의 Hamming distance 특성이 **서로 다른 수준의 오류 보호**를 제공한다.

게다가, Interleaving까지 결합하면, Base Layer의 코드에 대해서는

- 각 코드워드에 들어가는 오류 개수 자체를 줄여 줌으로써,
- “실질적인 정정 가능한 버스트 길이”를 더욱 늘리는 효과가 생긴다.

---

## 정리

10.5절에서 본 FEC의 핵심 아이디어들을 다시 정리하면 다음과 같다.

1. **Hamming distance**
   - 코드워드들 사이의 최소 거리 $$d_{\min}$$ 은
     “**최대 검출/정정 가능한 오류 개수**”를 결정한다.
   - 단순 패리티는 $$d_{\min}=2$$ 이므로 오류 검출만 가능하고,
   - Hamming(7,4)는 $$d_{\min}=3$$ 으로 단일 비트 오류 정정이 가능하다.

2. **XOR 기반 FEC**
   - 여러 데이터 패킷의 XOR를 FEC 패킷으로 추가하면,
     “**그룹 내에서 최대 1개 패킷 손실까지 복구**”할 수 있다.
   - 오버헤드는 그룹당 1패킷(1/n)이고, 더 많은 손실을 다루려면 여러 XOR 조합이나 보다 일반적인 블록 코드를 써야 한다.

3. **Chunk Interleaving**
   - 버스트 오류가 한 코드워드에 집중되는 것을 방지하기 위해,
     비트/Chunk/패킷을 시간적으로 섞어서 보낸다.
   - 버스트 오류가 발생해도 각 코드워드가 입는 피해가 “조금씩 분산”되므로,
     각 코드워드의 FEC 정정 능력 안에서 복구가 가능해진다.
   - 그 대가로 **추가 지연(latency)** 이 생긴다.

4. **Hamming Distance + Interleaving의 결합**
   - Hamming(7,4) 같은 단일 비트 오류 정정 코드도,
     충분히 깊은 인터리빙과 결합하면 버스트 오류도 정정 가능한 시스템처럼 동작할 수 있다.
   - 설계 시에는 “예상 버스트 길이 vs 코드의 정정 능력”을 맞춰야 한다.

5. **High-/Low-Resolution 패킷의 계층형 설계**
   - Base Layer와 Enhancement Layer에 서로 다른 수준의 FEC를 적용해,
     Base Layer를 더 강하게 보호하면,
     네트워크 상황이 나빠져도 최소한의 서비스(저해상도/저품질)는 유지할 수 있다.
   - Interleaving과 결합하면, 패킷 손실/손상 패턴이 계층별로 더 고르게 분산되고,
     Base Layer의 생존 확률이 더욱 올라간다.
   - 이 구조는 **Unequal Error Protection (UEP)** 의 대표적인 예다.

앞에서 다뤘던 오류 검출 기법(CRC, 체크섬, 단순 패리티)을 “오류를 **발견**하는 기술”이라고 한다면,
이 절에서 본 Hamming distance, XOR FEC, Interleaving, UEP는 “오류를 **견디고 복구**하는 기술”에 해당한다.

실제 시스템에서는 이 둘을 함께 사용해,
- 우선 FEC로 가능한 한 많은 오류를 자동 정정하고,
- 그래도 안 되는 경우에만 ARQ로 재전송을 요구하며,
- Base Layer/High Layer 설계로 사용자 경험의 급격한 붕괴를 막는 구조를 만든다.

이때 Hamming distance는 **“얼마나 멀리 떨어뜨려야, 어느 정도까지의 오류를 정정할 수 있는가”** 를 수학적으로 평가하는 핵심 지표라는 점을 기억하면, 이후 더 복잡한 블록 코드(예: Reed–Solomon, LDPC)를 공부할 때도 큰 도움이 된다.
