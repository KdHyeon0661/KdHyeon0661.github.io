---
layout: post
title: 이산수학 - 관계와 그들의 특성
date: 2025-06-25 19:20:23 +0900
category: 이산수학
---
# 관계와 그들의 특성 (Relations and Their Properties)

## 0) 한눈에 보기 — 관계의 큰 그림

- **이항관계**: 집합 \(A\) 위의 이항관계 \(R\)는 \(A\times A\)의 부분집합
  $$
  R\subseteq A\times A,\qquad (a,b)\in R\ \Leftrightarrow\ a\ R\ b.
  $$
- **표현 방식**: (1) 순서쌍 집합, (2) 방향그래프(정점: 원소, 간선: 관계), (3) 0-1 행렬, (4) Hasse 다이어그램(부분순서에서 축약)
- **핵심 성질**: 반사성/비반사성, 대칭성/반대칭성/비대칭성, 추이성
- **특수 종류**: 동치관계(≡), 부분순서관계(≤), 전순서/전주문(total/preorder)
- **연산**: 역관계, 합성, 멱집합/연쇄( \(R^k\) ), 폐포(반사·대칭·추이 폐포)
- **응용**: 동치류/몫집합, poset/정렬, 경로/도달성(Warshall), 데이터베이스 릴레이션, 상태전이, 타입/상속 계층 등

---

## 1) 정의와 표기

### 1.1 이항관계의 정의
- 집합 \(A\) 위의 관계 \(R\)는
  $$
  R\subseteq A\times A.
  $$
- \(a,b\in A\)에 대해 \((a,b)\in R\)이면 \(aRb\) 또는 \(a\sim b\)로도 쓴다.

### 1.2 표기/표현 예
- **순서쌍 집합**: \(R=\{(a,b),(b,c),(c,a)\}\)
- **그래프**: 정점 \(A\), 방향간선 \(a\to b\) iff \((a,b)\in R\)
- **행렬**: \(A=\{a_1,\dots,a_n\}\)에 대해
  $$
  (M_R)_{ij}=\begin{cases}
  1,&(a_i,a_j)\in R\\
  0,&\text{otherwise}
  \end{cases}
  $$
- **Hasse 다이어그램**: 부분순서에서 **반사 간선(대각)**과 **추이 간선** 제거 후 남은 최소 간선만 시각화

---

## 2) 관계의 기본 성질

### 2.1 반사성/비반사성
- **반사성**(reflexive): 
  $$
  \forall a\in A,\ (a,a)\in R.
  $$
  예: \(=\), \(\le\), \(\subseteq\).
- **비반사성**(irreflexive):
  $$
  \forall a\in A,\ (a,a)\notin R.
  $$
  예: \(<\), “엄격 포함” \(\subset\).

> 메모: 어떤 관계는 **반사성도 비반사성도 아닐** 수 있다(일부 원소만 대각 포함).

### 2.2 대칭성/반대칭성/비대칭성
- **대칭성**(symmetric):
  $$
  (a,b)\in R\Rightarrow (b,a)\in R.
  $$
  예: \(=\), “형제/친하다”(모델에 따라).
- **반대칭성**(antisymmetric):
  $$
  (a,b)\in R\ \wedge\ (b,a)\in R\ \Rightarrow\ a=b.
  $$
  예: \(\le\), \(\subseteq\). (양방향이면 동일해야 함)
- **비대칭성**(asymmetric):
  $$
  (a,b)\in R\Rightarrow (b,a)\notin R.
  $$
  예: \(<\), \(\subset\).  
  **사실** 비대칭이면 자동으로 **비반사성**이다: \( (a,a)\in R \)가 되면 정의와 모순.

> 구별 포인트
> - 대칭 vs 반대칭은 **동시에** 성립 가능(예: \(=\)는 둘 다).  
> - 비대칭은 대칭과 양립 불가, 또한 반사성도 불가.

### 2.3 추이성
- **추이성**(transitive):
  $$
  (a,b)\in R\ \wedge\ (b,c)\in R\ \Rightarrow\ (a,c)\in R.
  $$
  예: \(\le\), \(\subseteq\), “선조(ancestor-of)”.

---

## 3) 자주 나오는 관계의 유형

### 3.1 동치관계 (Equivalence)
- **정의**: 반사성 + 대칭성 + 추이성
- **예시**
  - 모듈로 \(n\) 동치:
    $$
    a\equiv b\pmod n\ \Leftrightarrow\ n\mid (a-b).
    $$
  - 동일형(그래프 동형성), 동치 클래스(문자열의 아나그램류) 등
- **결과**: 동치관계는 \(A\)를 **동치류(partition)**로 분할, 몫집합 \(A/{\sim}\) 정의

### 3.2 부분순서관계 (Partial Order)
- **정의**: 반사성 + 반대칭성 + 추이성
- **예시**: \(\le\) on \(\mathbb{R}\), \(\subseteq\) on \(\mathcal{P}(S)\), **나눗셈** \(\mid\) on \(\mathbb{N}\)
- **구조**: (A, ≤)는 **poset**. 선형(전)순서(total order)는 모든 두 원소 비교 가능
- **Hasse 다이어그램**: poset을 간결히 표현; **최소/최대원소**, **극솟/극댓**, **상한/하한**, **최소상한(lub)**, **최대하한(glb)** 개념 논의

### 3.3 전주문(Preorder)
- **정의**: 반사성 + 추이성(대칭/반대칭 요구 안 함)
- **활용**: 준서열, 유사도/도달성의 전개, 분류 전처리(동치폐포로 quotient하여 poset 얻기)

---

## 4) 관계 연산

### 4.1 역관계
$$
R^{-1}=\{(b,a)\mid (a,b)\in R\}.
$$
- 대칭성이면 \(R=R^{-1}\).

### 4.2 합성 (Composition)
$$
R_1\circ R_2=\{(a,c)\mid \exists b:(a,b)\in R_2\ \wedge\ (b,c)\in R_1\}.
$$
- 그래프 경로 길이 2에 해당. \(R^k\)는 길이 \(k\) 경로.

### 4.3 폐포(closure)
- **반사폐포**: \(R^{=}=R\cup \{(a,a)\mid a\in A\}\)
- **대칭폐포**: \(R^{\leftrightarrow}=R\cup R^{-1}\)
- **추이폐포**(transitive closure): 
  $$
  R^{+}=\bigcup_{k\ge 1}R^k,\qquad R^{*}=R^{+}\cup I\ \ (\text{반사추이})
  $$
  계산: **Warshall** / DFS-closure

---

## 5) 행렬로 보는 관계

- \(A=\{a_1,\dots,a_n\}\), 관계 행렬 \(M\in\{0,1\}^{n\times n}\)
- **합성**은 **불 대수 곱셈**:
  $$
  (M_{R\circ S})_{ij}=\bigvee_{k=1}^{n}\big(M_S\big)_{ik}\wedge\big(M_R\big)_{kj}.
  $$
- **추이폐포**: \(M^+\)는 \(M\lor M^2\lor \cdots\) (불 곱/불 합), 실전은 **Warshall**로 \(O(n^3)\).

---

## 6) 예시 테이블로 감 잡기

| 관계 | 반사 | 대칭 | 반대칭 | 비대칭 | 추이 |
|---|---|---|---|---|---|
| \(=\) | ✅ | ✅ | ✅ | ❌ | ✅ |
| \(\le\) | ✅ | ❌ | ✅ | ❌ | ✅ |
| \(<\) | ❌ | ❌ | ✅ | ✅ | ✅ |
| “형제” | 보통 ❌ | ✅ | ❌ | ❌ | 보통 ❌ |
| “친하다” | 보통 ❌ | ✅ | ❌ | ❌ | 보통 ❌ |
| \(\subseteq\) | ✅ | ❌ | ✅ | ❌ | ✅ |
| \(\subset\) | ❌ | ❌ | ✅ | ✅ | ✅ |

> 주의: “형제/친하다” 같은 사회적 관계는 모델링에 따라 달라질 수 있다.

---

## 7) 실전 증명 스니펫

- \(<\)가 비대칭인 이유: \(a<b\)이면 동시에 \(b<a\)가 될 수 없음(삼단논법으로 모순), 또한 \(a<a\)는 거짓 → 비반사성.
- \(\subseteq\)가 반대칭인 이유: \(A\subseteq B\)와 \(B\subseteq A\)가 동시에 성립하면 \(A=B\).
- 모듈러 동치 \(\equiv\)가 동치관계인 이유:  
  - 반사: \(a-a=0\Rightarrow n\mid 0\)  
  - 대칭: \(n\mid (a-b)\Rightarrow n\mid (b-a)\)  
  - 추이: \(n\mid(a-b), n\mid(b-c)\Rightarrow n\mid(a-c)\).

---

## 8) Python 유틸 — 관계 성질 검사/폐포/합성

> **입력 형식**: 원소 리스트 `A`와 관계 집합 `R`(쌍들의 집합 또는 리스트)

```python
# ------------------------------
# 기본: 성질 검사
# ------------------------------
def is_reflexive(A, R):
    return all((a, a) in R for a in A)

def is_irreflexive(A, R):
    return all((a, a) not in R for a in A)

def is_symmetric(R):
    return all((b, a) in R for (a, b) in R)

def is_antisymmetric(R):
    return all(a == b or (b, a) not in R for (a, b) in R)

def is_asymmetric(R):
    return all((b, a) not in R for (a, b) in R)  # implies irreflexive

def is_transitive(A, R):
    # 삼중 루프 대신, (a,b),(b,c) 있으면 (a,c) 검사
    Rset = set(R)
    from collections import defaultdict
    succ = defaultdict(set)
    for a, b in R:
        succ[a].add(b)
    for a, Bs in succ.items():
        for b in Bs:
            for c in succ.get(b, ()):
                if (a, c) not in Rset:
                    return False
    return True
```

```python
# ------------------------------
# 폐포: 반사/대칭/추이 (Warshall)
# ------------------------------
def reflexive_closure(A, R):
    R2 = set(R)
    for a in A: R2.add((a, a))
    return R2

def symmetric_closure(R):
    R2 = set(R)
    for (a,b) in list(R2):
        R2.add((b,a))
    return R2

def transitive_closure(A, R):
    # Warshall: 인덱스 기반
    idx = {a:i for i,a in enumerate(A)}
    n = len(A)
    M = [[False]*n for _ in range(n)]
    for (a,b) in R:
        M[idx[a]][idx[b]] = True
    for k in range(n):
        Mk = M[k]
        for i in range(n):
            if M[i][k]:
                Mi = M[i]
                # 불 대수: OR over column
                for j in range(n):
                    Mi[j] = Mi[j] or Mk[j]
    out = set()
    for i,a in enumerate(A):
        for j,b in enumerate(A):
            if M[i][j]:
                out.add((a,b))
    return out
```

```python
# ------------------------------
# 합성/거듭제곱/반사추이폐포
# ------------------------------
def compose(A, R1, R2):
    # R1 ∘ R2 : (a,c) if ∃b: (a,b)∈R2 and (b,c)∈R1
    succ1, succ2 = {}, {}
    for a,b in R1:
        succ1.setdefault(a,set()).add(b)
    for a,b in R2:
        succ2.setdefault(a,set()).add(b)
    out = set()
    for a, Bs in succ2.items():
        for b in Bs:
            for c in succ1.get(b, ()):
                out.add((a,c))
    return out

def power(A, R, k):
    assert k >= 1
    out = set(R)
    for _ in range(k-1):
        out = compose(A, out, R)
    return out

def reflexive_transitive_closure(A, R):
    return reflexive_closure(A, transitive_closure(A, R))
```

---

## 9) 동치류/몫집합 계산 (예: 모듈러 동치)

```python
def equivalence_classes(A, R):
    # R이 동치관계라 가정
    # 그래프 연결요소(무향) = 동치류
    G = {a:set() for a in A}
    for a,b in R:
        G[a].add(b); G[b].add(a)
    seen, classes = set(), []
    for a in A:
        if a in seen: continue
        comp, stack = [], [a]
        seen.add(a)
        while stack:
            x = stack.pop()
            comp.append(x)
            for y in G[x]:
                if y not in seen:
                    seen.add(y); stack.append(y)
        classes.append(sorted(comp))
    return classes

# 데모: A={0..7}, mod 3 동치
A = list(range(8))
R = {(a,b) for a in A for b in A if (a-b) % 3 == 0}
print(equivalence_classes(A, R))  # [[0,3,6],[1,4,7],[2,5]]
```

---

## 10) 부분순서 & Hasse 다이어그램(간선 축약)

### 10.1 예: \((\mathcal{P}(\{a,b,c\}), \subseteq)\)
- 정점 8개: \(\emptyset, \{a\},\{b\},\{c\},\{a,b\},\{a,c\},\{b,c\},\{a,b,c\}\)
- Hasse 간선: 바로 위/아래(원소 1개 차이)만 연결

### 10.2 트랜지티브 리덕션(간선 축약) 코드 스케치
```python
def hasse_edges(V, leq):
    # V: 노드 리스트, leq(x,y): x≤y 여부 (반사성 포함)
    # 1) 모든 커버 후보 수집  2) 추이 간선 제거
    edges = {(x,y) for x in V for y in V if x!=y and leq(x,y)}
    cover = set(edges)
    for a,b in list(edges):
        for c in V:
            if c not in (a,b) and (a,c) in edges and (c,b) in edges:
                if (a,b) in cover:
                    cover.remove((a,b)); break
    return cover

# 예시: V = subsets of {a,b,c}, leq = subseteq
def subsets(S):
    S=list(S); n=len(S); out=[]
    for mask in range(1<<n):
        out.append(tuple(S[i] for i in range(n) if (mask>>i)&1))
    return out

S = ['a','b','c']
V = subsets(S)

def leq(x,y):  # x ⊆ y
    return set(x).issubset(set(y))

print(sorted(hasse_edges(V, leq)))
```

---

## 11) 관계와 그래프/오토마타/DB

- **그래프**: 방향 그래프의 간선 집합이 곧 관계. 도달성은 추이폐포. DAG는 비순환 → 부분순서와 자연스럽게 연결.
- **오토마타(DFA/NFA)**: 상태 집합 \(Q\)과 입력 알파벳 \(\Sigma\), 전이관계 \(\delta\subseteq Q\times \Sigma\times Q\). 입력 글자를 고정하면 \(Q\times Q\)의 관계가 된다.
- **데이터베이스**: 릴레이션은 **수학적 관계의 일반화**(튜플 집합). 키/종속성/조인 등은 부분순서/함수적 종속 관계와 맞닿아 있다.

---

## 12) 연습 & 해설 예시

### 12.1 “부모(parent-of)” 관계의 합성
- \(P=\) parent-of. 그러면 \(P\circ P=\) grandparent-of, \(P^k=\) \(k\)세대 상위.
- 보통 \(P\)는 비대칭·비반사·**비**추이(부모의 부모≠부모). 반면 “선조(ancestor-of)”는 추이적.

### 12.2 “나눗셈 \(\mid\)” 관계
- \((\mathbb{N},\mid)\): 반사( \(a\mid a\) ), 반대칭( \(a\mid b, b\mid a \Rightarrow a=b\) ), 추이.
- 최소/최대 원소: 1은 모든 수의 약수(최소), \(0\) 포함 시 주의(모델에 따라 정의 변경).

### 12.3 “같은 길이의 문자열” 동치
- \(s\sim t\) iff \(|s|=|t|\): 반사/대칭/추이 모두 OK → 동치류는 길이별 버킷.

---

## 13) 성질 판정 실전 패턴

- **반사성**: 대각선 모두 1인지(행렬), 또는 모든 \(a\)에 대해 \((a,a)\in R\)인지.
- **대칭성**: 행렬이 전치와 동일한지 \(M=M^\top\).
- **반대칭성**: \(M\wedge M^\top\)의 1이 **대각선에만** 존재하는지.
- **비대칭성**: 반대칭 + 비반사성.
- **추이성**: \(M\circ M\le M\) (불 대수 비교) 또는 Warshall로 \(R^+\subseteq R\).

---

## 14) 대규모 데이터에서의 팁

- **Warshall \(O(n^3)\)**: \(n\le 2\sim3\)천 수준의 밀집 그래프에 적합.
- 희소 그래프는 **DFS/BFS 기반** 도달성(노드 당 \(O(m)\))이 더 실용.
- 동치 판단은 **Union-Find(Disjoint Set Union)**가 빠르고 간단.

```python
class DSU:
    def __init__(self, items):
        self.id = {x:i for i,x in enumerate(items)}
        n = len(items)
        self.p = list(range(n)); self.r = [0]*n
        self.items = list(items)
    def find(self, x):
        i = self.id[x]
        while self.p[i]!=i:
            self.p[i]=self.p[self.p[i]]
            i=self.p[i]
        return i
    def union(self, x, y):
        rx, ry = self.find(x), self.find(y)
        if rx==ry: return
        if self.r[rx]<self.r[ry]: rx,ry=ry,rx
        self.p[ry]=rx
        if self.r[rx]==self.r[ry]: self.r[rx]+=1
    def groups(self):
        buckets={}
        for x in self.items:
            r=self.find(x)
            buckets.setdefault(r, []).append(x)
        return list(buckets.values())

# 예: mod 3 동치
A = list(range(10))
dsu = DSU(A)
for a in A:
    for b in A:
        if (a-b)%3==0: dsu.union(a,b)
print([sorted(g) for g in dsu.groups()])
```

---

## 15) 체크리스트 & 흔한 오해

1. **대칭 ↔ 반대칭** 헷갈림: 둘은 상충 개념이 아님(= 은 둘 다).
2. **비대칭 ⇒ 비반사성**을 잊지 말기.
3. **부분순서 vs 전순서**: poset은 **비교 불가능**한 원소 쌍이 존재할 수 있다.
4. **Hasse**: 반사·추이 간선을 제거한 **커버 관계**만 그림.
5. **합성 방향**: \(R_1\circ R_2\)의 정의에서 순서를 일관되게(코드와 수식 일치).
6. **행렬 곱**: 불 대수(OR/AND)로 해야 관계 합성이 맞는다.

---

## 16) 미니 프로젝트 과제 아이디어 (실습)

- **Poset 시각화**: 임의의 부분집합 포함 관계를 받아 Hasse 간선 출력 → graphviz로 그림.
- **정규식 파생관계**: DFA 전이관계를 빼와 문자별 관계 행렬 구성, 길이 \(k\) 단어 수를 행렬 멱으로 계산.
- **클린업**: 주어진 관계를 동치 폐포(반사·대칭·추이 폐포)로 **최소 동치관계**로 확장, 동치류 출력.

---

## 17) 요약

- 관계는 \(A\times A\)의 부분집합이며 **성질 조합**으로 성격이 정해진다.
- **동치**(반사/대칭/추이) → **동치류/몫집합**.  
  **부분순서**(반사/반대칭/추이) → **poset/Hasse/상하한**.
- **연산**(역, 합성, 멱)과 **폐포**(반사·대칭·추이)는 실전에서 필수.
- **행렬/그래프** 관점은 알고리즘화(도달성, Warshall, DSU)에 직결된다.

---

## 18) 빠른 자가 테스트 (True/False)

1) \(R\)이 비대칭이면 반사적일 수 있다. → **False**  
2) \(R\)이 대칭이고 반대칭이면 \(R\)은 항상 \(=\)이다. → **False** (공집합 관계도 해당)  
3) \(\subset\)는 비대칭이고 추이적이다. → **True**  
4) 모듈러 동치는 poset이다. → **False** (반대칭 미충족)