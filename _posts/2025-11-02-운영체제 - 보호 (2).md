---
layout: post
title: 운영체제 - 보호 (2)
date: 2025-11-02 15:25:23 +0900
category: 운영체제
---
# Chapter 17 — Protection (2)

## Domain of Protection

### 도메인(Domain)의 직관

**Protection Domain**은 “어떤 주체가 지금 **무엇을 할 수 있는가**”를 묶은 **권한의 집합**이다.
- **주체(Subject)**: 프로세스/스레드/사용자/역할(role)/컨테이너 등.
- **객체(Object)**: 파일/디렉터리/소켓/IPC/메모리/디바이스/네임스페이스 등.
- **연산(Operation)**: read, write, execute, append, ioctl, mount, kill, bind…

**도메인 = 권한들의 모음**이며, 실행 중에 **도메인 전환(domain switch)** 이 일어나면 **허용되는 연산의 집합**이 바뀐다. 예:
- UNIX의 **setuid**, Linux capability **승격/하향**, Windows의 **권한 상승(UAC)**, 컨테이너의 **user/ mount/ pid 네임스페이스 진입** 등.

---

### 도메인의 표현: 정적 vs 동적

- **정적 도메인**: 로그인한 사용자/그룹에 의해 대부분 고정(예: CLI 유저 세션).
- **동적 도메인**: 실행 중 역할 교체/권한 임대(lease)/세션 컨텍스트 교체(예: `sudo`, Kerberos TGT 변경, Linux **ambient capability** 추가/제거, SELinux **type transition**).

**형식화**
도메인 \(D\) 는 권한 집합 \(R\) 의 부분집합으로 표현된다:
$$
D \subseteq R,\quad R=\{read, write, execute, \ldots\}
$$

---

### 도메인 전환 (Domain Switching)

도메인 간 전환은 **참조 모니터**가 **정책**에 따라 허용/거부한다.
- **수동 전환**(사용자 요청): `su`, `sudo`, Windows runas.
- **자동 전환**(실행/접근에 따른): setuid 파일 실행, SELinux type transition, Windows 서비스 로그온.

**전환 조건**은 “전환 요청자”와 “전환 대상”의 **관계**로 정의:
$$
\text{allow\_switch}(D_i \to D_j) \iff (D_i, D_j) \in T
$$
여기서 \(T\) 는 **허용된 전환**의 관계 그래프(또는 행렬).

#### 예: 최소권한 하향(권한 드롭) — Linux

```c
// drop_to_user.c — 루트로 시작했더라도, 필요한 작업 후 일반 사용자로 "도메인 전환"
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>

int main() {
  printf("start: euid=%d\n", geteuid());
  // 특권 작업(예: 80 포트 바인드)을 마쳤다고 가정 후 일반 사용자 전환
  if (setgid(1000) < 0 || setuid(1000) < 0) { perror("setid"); return 1; }
  printf("after drop: euid=%d\n", geteuid());
  // 이후는 일반 사용자 도메인에서만 동작
  return 0;
}
```

---

### 도메인 교차 시 **증폭/감쇠**(Amplification/Attenuation)

- **증폭**: 한정된 조건에서 일시적으로 더 강한 권한(예: setuid root).
- **감쇠**: 더 적은 권한으로 축소(예: chroot/namespace/ seccomp).
목표는 **Least Privilege**: 필요한 순간에만 증폭, 끝나면 즉시 감쇠.

---

### 도메인 = “능력 집합” 관점

**능력(capability)** 은 “특정 객체에 대한 참조 + 권한”을 **위조 불가** 토큰으로 지칭.
도메인은 **보유한 능력들의 합집합**:
$$
D = \bigcup_k \mathrm{cap}_k
$$
- **장점**: 최소권한과 **권한 전달(delegation)** 이 자연스럽다.
- **이슈**: **대규모 철회**(revocation)가 어렵다 → **간접 참조/버전**으로 해결.

#### 예: FD(파일 디스크립터) 기반 도메인(능력) 전달

```python
# fd_capability.py — UNIX domain socket을 통해 FD(능력) 전달 → 전달받은 프로세스의 "도메인" 확장

import os, socket, struct

def send_fd(sock, fd):
    sock.sendmsg([b"x"], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, struct.pack("i", fd))])

def recv_fd(sock):
    msg, anc, *_ = sock.recvmsg(1, 64)
    for level, ctype, data in anc:
        if level==socket.SOL_SOCKET and ctype==socket.SCM_RIGHTS:
            return struct.unpack("i", data[:4])[0]

# 서버: /srv/data 디렉터리 FD를 "능력"으로 전달

srv = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
addr="/tmp/fd.sock"
try: os.unlink(addr)
except FileNotFoundError: pass
srv.bind(addr); srv.listen(1)
dirfd = os.open("/srv/data", os.O_RDONLY | os.O_DIRECTORY)
cli,_ = srv.accept()
send_fd(cli, dirfd)  # 여기서 클라이언트 도메인에 "해당 디렉터리에 대한 접근 권한"이 추가됨
```

---

## Access Matrix

### 정의

**Access Matrix** \(M\) 는 주체(또는 도메인) 집합 \(S\) 와 객체 집합 \(O\) 에 대해,
$$
M: S \times O \to 2^{R},\quad M[s,o] \subseteq R
$$
- 각 **셀**은 “주체 \(s\) 가 객체 \(o\) 에 대해 가진 권한 집합”을 담는다.
- **희소(sparse)** 이므로 실제 구현은 **ACL(객체 중심)** 또는 **Capability(주체 중심)** 으로 나타낸다.

### 행/열과 의미

- **행(Row) = 도메인/주체**: 한 주체가 **무엇을 할 수 있는가**
- **열(Column) = 객체**: 한 객체에 **누가 무엇을 할 수 있는가**

### HRU 모델(권한 동역학) 요약

Harrison–Ruzzo–Ullman 모델은 접근 행렬 위에 **권한 변경 연산**을 둔다.
- **enter r into M[s,o]**: 권한 \(r\) 부여
- **delete r from M[s,o]**: 권한 \(r\) 회수
- **create object/subject**, **destroy object/subject**
- **copy r from M[x,y] to M[u,v]**: 권한 전달(제약 가능: 소유자만, 읽기만, copy-flag 등)

**안전성(Safety) 문제**: 임의의 초기 상태와 연산 집합이 주어졌을 때, “권한 \(r\) 이 **권한 없는 셀**로 **유출(leak)** 되는 일이 **절대 일어나지 않는다**”를 결정 가능한가?
- **일반적으로 비결정 가능(undecidable)**.
- 그러나 **제약된 모델**(예: mono-operational, copy 제한, 소유자/제어자 규칙)은 **결정 가능**.

> 직관: 시스템 전체 권한 전달/복사/생성 조합은 사실상 **프로그래밍 언어**와 유사한 표현력을 갖는다 → 정지문제류.

---

### 소유자(owner)/제어(control)/복사(copy) 권한

실무에서는 다음 **메타 권한**으로 관리한다:
- **owner(o)**: 객체 \(o\) 에 대한 **ACL 수정 권한**.
- **control(s)**: 주체 \(s\) 에 대한 **권한 제한/종료** 권한(관리 도메인).
- **copy(r)**: 권한 \(r\) 을 **전달**할 수 있는 권한(예: `r*` 형태로 표기).

---

### 도메인 전환을 행렬로 표현

도메인 \(D_i\) 와 \(D_j\) 에 대해 **switch** 권한을 별도 객체(또는 도메인-열)에 담는다:
- \(M[D_i, D_j]\) 에 **switch** 가 있으면 \(D_i \to D_j\) 전환 가능.
- 또는 “실행 파일 객체” 열에 **switch-to-\(D_j\)** 권한을 넣어 **그 파일 실행 시** 자동 전환(= setuid).

---

### 미니 실습: 접근 행렬 엔진 (Python)

#### (A) 행렬 및 연산

```python
# access_matrix.py — HRU 스타일 최소 엔진: enter/delete/copy/create/destroy/switch

from collections import defaultdict

class AccessMatrix:
    def __init__(self):
        self.S = set()  # subjects/domains
        self.O = set()  # objects
        self.M = defaultdict(lambda: defaultdict(set))  # M[s][o] = {rights}

    # ---- 생성/파괴 ----
    def create_subject(self, s):
        self.S.add(s)

    def create_object(self, o, owner=None):
        self.O.add(o)
        if owner:
            self.M[owner][o].update({"owner"})  # ACL 관리 권한

    def destroy_object(self, o):
        for s in list(self.M.keys()):
            if o in self.M[s]: del self.M[s][o]
        self.O.discard(o)

    # ---- 권한 조작 ----
    def enter(self, s, o, r, by=None):
        # by가 owner 또는 control 권한을 가지고 있는지 검사(간단화)
        if by and "owner" not in self.M[by][o] and "control" not in self.M[by].get(s, set()):
            raise PermissionError("no admin right")
        self.M[s][o].add(r)

    def delete(self, s, o, r, by=None):
        if by and "owner" not in self.M[by][o] and "control" not in self.M[by].get(s, set()):
            raise PermissionError("no admin right")
        self.M[s][o].discard(r)

    def copy(self, src_s, src_o, r, dst_s, dst_o):
        # src가 r과 r의 copy 권한(r*)을 모두 가져야 전달 가능(정책 예)
        if r not in self.M[src_s][src_o] or (r+"*") not in self.M[src_s][src_o]:
            raise PermissionError("no copy right")
        self.M[dst_s][dst_o].add(r)

    # ---- 접근 검사 ----
    def can(self, s, o, r):
        return r in self.M[s][o]

    # ---- 도메인 전환 ----
    def allow_switch(self, fromD, toD, admin):
        self.enter(fromD, toD, "switch", by=admin)

    def switch(self, curD, toD):
        if "switch" not in self.M[curD][toD]: raise PermissionError("no switch")
        return toD  # 새 도메인으로 전환했다고 간주

# ------------------ 예시 ------------------

if __name__ == "__main__":
    am = AccessMatrix()
    for s in ["HR","Engineer","Auditor","Admin"]: am.create_subject(s)
    for o in ["/payroll.csv","/src","/audit.log"]: am.create_object(o, owner="Admin")

    # Admin이 ACL 관리(enter) 수행
    am.enter("HR", "/payroll.csv", "read", by="Admin")
    am.enter("HR", "/payroll.csv", "write", by="Admin")
    am.enter("Engineer", "/src", "read", by="Admin")
    am.enter("Auditor", "/audit.log", "read", by="Admin")

    # 도메인 전환: Engineer -> Auditor (감사 정책상 허용 안 한다 가정)
    am.allow_switch("Engineer", "Auditor", admin="Admin")  # 허용해보자
    newD = am.switch("Engineer", "Auditor")
    print("switched to", newD, "can read audit?", am.can(newD, "/audit.log", "read"))
```

#### (B) 권한 전달과 철회

- 위 엔진에서 `copy` 를 제한하여 **권한 유출**을 제어한다.
- 철회는 `delete` 로 가능하지만 이미 전달된 곳까지 **일괄 회수**하려면 **간접화**(17.6에서 다룸)가 필요.

---

## Implementation of the Access Matrix

실제 OS는 거대한 희소 행렬을 **직접 저장하지 않는다**. 대신 **두 축 중 하나를 기준**으로 묶어 표현한다.

### ACL(Access Control List) — 객체 중심

- 각 **객체**가 “누가 무엇을 할 수 있는가”의 목록을 가짐.
- 예: Unix의 **모드비트/소유자/그룹**, **POSIX ACL**, Windows **DACL**.

**장점**
- 객체 소유자/관리자가 **중앙집중**으로 관리(감사/리뷰 용이).
- **선택적 철회** 용이(목록에서 특정 주체만 삭제).

**단점**
- 분산 시스템에서 **권한 전달**(delegation) 표현이 번거롭다.
- 다중 시스템/세션에 흩어진 **최소권한 부여**의 자동화가 어렵다.

#### 예: 간단 ACL 파일시스템(메모리) — Python

```python
# acl_fs.py — 객체 중심의 ACL 구현

from collections import defaultdict

class ACLFS:
    def __init__(self):
        self.data = {}  # obj -> bytes
        self.acl  = defaultdict(lambda: defaultdict(set))  # obj -> {subject -> {rights}}

    def create(self, obj, owner):
        self.data[obj] = b""
        self.acl[obj][owner].update({"read","write","grant","revoke"})

    def grant(self, obj, owner, subject, rights):
        if "grant" not in self.acl[obj][owner]: raise PermissionError("no grant")
        self.acl[obj][subject].update(rights)

    def revoke(self, obj, owner, subject, rights):
        if "revoke" not in self.acl[obj][owner]: raise PermissionError("no revoke")
        self.acl[obj][subject].difference_update(rights)

    def read(self, obj, s):
        if "read" not in self.acl[obj][s]: raise PermissionError("no read")
        return self.data[obj]

    def write(self, obj, s, buf:bytes):
        if "write" not in self.acl[obj][s]: raise PermissionError("no write")
        self.data[obj] = buf
```

---

### Capability List — 주체 중심(능력)

- 각 **주체**가 “어떤 객체에 어떤 권한으로 접근 가능한지”를 **토큰**으로 보유.
- 예: Unix **파일 디스크립터**, Web 브라우저의 **Object Capability** 패턴, 일부 OS(난독화된 참조).

**장점**
- **Least Privilege** 구현이 자연스러움(필요한 능력만 전달).
- **경로 우회** 없이 **핸들 기반** 접근 → TOCTOU 완화.

**단점**
- 이미 배포된 능력을 **일괄 회수**(revocation)하기 어렵다 → **간접화**로 해결.

#### 예: 능력 토큰과 간접화(버전) — Python

```python
# cap_table.py — capability = (object_id, version, rights), 객체마다 version을 올려 "선택적 철회"

import os

class CapTable:
    def __init__(self):
        self.objects = {}  # oid -> {"data":bytes, "version":int}
        self.caps    = {}  # cap_id -> (oid, version, rights)

    def create_object(self, data=b""):
        oid = os.urandom(8).hex()
        self.objects[oid] = {"data":data, "version":1}
        return oid

    def issue(self, oid, rights):
        cap_id = os.urandom(8).hex()
        v = self.objects[oid]["version"]
        self.caps[cap_id] = (oid, v, set(rights))
        return cap_id

    def revoke_selective(self, oid):
        # 객체 oid의 버전을 올려, "새 버전" 캡만 유효하게
        self.objects[oid]["version"] += 1

    def read(self, cap_id):
        oid, v, rights = self.caps[cap_id]
        if "read" not in rights or v != self.objects[oid]["version"]:
            raise PermissionError("no read or revoked")
        return self.objects[oid]["data"]

    def write(self, cap_id, data):
        oid, v, rights = self.caps[cap_id]
        if "write" not in rights or v != self.objects[oid]["version"]:
            raise PermissionError("no write or revoked")
        self.objects[oid]["data"] = data
```
> **선택적 철회**: 특정 객체의 **버전**을 증가 → **해당 객체의 기존 캡**은 모두 무효화. 세밀히(일부 캡만) 회수하려면 **중간 프록시 객체**(sub-object)를 두고 그 버전만 올린다.

---

### Lock–Key(자물쇠–열쇠) 모델

- **객체**는 **lock**(키 ID 목록/정책)을 갖고
- **주체**는 **key**(키 ID)를 보유 → 키가 맞아야 권한 부여.
- 키 회전/무효화로 **그 키를 가진 모든 주체**의 접근을 동시에 철회할 수 있음(글로벌/그룹 철회).

```python
# lock_key.py — 키 회전으로 그룹 철회

class LockKeyFS:
    def __init__(self):
        self.data = {}
        self.locks = {}      # obj -> {"keys": set([kid])}
        self.subject_keys = {} # subject -> set([kid])

    def add_key(self, subject, kid):
        self.subject_keys.setdefault(subject,set()).add(kid)

    def create(self, obj, keys):
        self.data[obj]=b""; self.locks[obj]={"keys":set(keys)}

    def rotate_key(self, oldkid, newkid):
        # 모든 객체의 lock에서 old→new 로 교체(혹은 제거)
        for o in self.locks:
            if oldkid in self.locks[o]["keys"]:
                self.locks[o]["keys"].remove(oldkid)
                self.locks[o]["keys"].add(newkid)

    def can_access(self, subject, obj):
        return len(self.subject_keys.get(subject,set()) & self.locks[obj]["keys"])>0
```

---

### POSIX/Windows에서의 구현 대응표

| 개념 | POSIX/리눅스 | Windows |
|---|---|---|
| ACL | 모드비트(ugo+rwx), **POSIX ACL** (`setfacl`/`getfacl`) | DACL/ACE (SDDL) |
| Capability(주체 중심) | **FD**, Linux capabilities(`cap_net_bind_service` 등) | **핸들(Handle)**, Restricted Token |
| 도메인 전환 | setuid/setgid, `sudo`, SELinux type transition | Runas, UAC, Logon Session 교체 |
| 라벨 기반(MAC) | SELinux/AppArmor(라벨/프로파일) | Windows Integrity Level, SRP/AppLocker/WDAC |

---

### 도메인 전환의 실무 예: setuid & `openat`(경로 고정)

**문제**: setuid root 도구가 **경로 경주(TOCTOU)** 로 잘못된 파일을 열 수 있다.
**해법**: **도메인 증폭**(setuid)로 필요한 최소 작업만 수행 후, **디렉터리 FD를 능력으로 캡슐화**해 **openat** 으로만 접근.

```c
// safe_helper.c — setuid 루트: 디렉터리 FD 준비 후 권한 하향, 그 FD로만 openat 허용
#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>

int main(){
  // 1) setuid root로 시작한다고 가정: 민감 디렉터리 FD 확보
  int dfd = open("/srv/secure", O_DIRECTORY | O_RDONLY);
  if(dfd<0){perror("open dir"); return 1;}

  // 2) 권한 하향(도메인 감쇠)
  if (setgid(1000)<0 || setuid(1000)<0){perror("drop"); return 1;}

  // 3) 사용자 요청 파일은 반드시 dfd 하위 상대경로로만
  int fd = openat(dfd, "user.txt", O_RDONLY | O_NOFOLLOW | O_CLOEXEC);
  if(fd<0){perror("openat"); return 1;}
  char buf[64]={0}; read(fd,buf,63); puts(buf);
  return 0;
}
```
> **핵심**: setuid 구간을 **최단화**하고, 이후에는 **능력(FD)** 으로만 접근 → 도메인 전환과 접근 행렬의 **안전한 구현**.

---

### 철회(Revocation) 전략 — 비교

| 전략 | 설명 | 장점 | 단점 | 예 |
|---|---|---|---|---|
| **즉시 철회** | ACL에서 당사자 항목 삭제 | 간단 | 이미 **복제된 능력**(핸들/FD)엔 영향 X | ACL `revoke` |
| **간접 참조** | 객체→핸들 사이에 **버전/프록시** 삽입 | 광범위 동시 철회 | 구현 복잡 | cap-table 버전 |
| **키 회전** | Lock–Key 키 교체 | 그룹 철회 용이 | 키 배포 필요 | Lock–Key |
| **만료/임대** | 능력에 TTL/lease | 자동 회수 | 재발급 비용 | NFS lease, SMB oplock |
| **감사+차단** | 차단 리스트를 **참조 모니터**에 | 배포 간단 | 지연 가능, 성능 영향 | deny-list |

---

### 정보 흐름(무결성/기밀성)과 격자(Lattice)

**Bell–LaPadula(BLP)**(기밀성):
$$
\text{no read up},\quad \text{no write down}
$$
**Biba**(무결성):
$$
\text{no read down},\quad \text{no write up}
$$
라벨 \(L\) 의 부분순서 \(\le\) 에 대해 **허용 규칙**을 **참조 모니터**가 강제. 실제 OS에선 **SELinux** 타입/레벨로 근사.

---

### RBAC(역할 기반 접근제어)와 행렬

행렬의 행을 “주체” 대신 **역할(Role)** 로 두면 대량 관리가 쉬워진다.
- 사용자 ↔ 역할 매핑, 역할 ↔ 권한 매핑(행), 객체 ↔ 권한(열).
- 상속/제약(SOD, DSD) 등 정책을 추가.

---

### 트러블슈팅 체크리스트

- **권한 유출**: copy-flag 오용, 임시 파일/소켓 FD **상속**(exec) 체크 → `O_CLOEXEC`.
- **철회 불가**: ACL만 사용 중인데 이미 **핸들/FD** 가 퍼짐 → **간접화** 도입.
- **경로 경주**: `stat` 후 `open` 금지 → **`openat` + `O_NOFOLLOW`** 사용.
- **과권한 서비스**: root 데몬 → **capabilities** 로 분해, seccomp/LSM으로 축소.
- **라벨 불일치**: SELinux/AppArmor 정책/컨텍스트 재라벨링 필요.

---

## 종합 예제 — “급여/감사/개발” 보호 설계

### 목표

- HR만 `/payroll.csv` 읽기/쓰기.
- Engineer는 `/src` 읽기만.
- Auditor는 `/audit.log` 읽기/쓰기.
- Admin만 **행렬 조작**(owner/control).
- 엔지니어가 감사 역할로 **임시 전환**(정책 허용 시에만).
- 이미 전달된 권한의 **선택적 철회**가 가능해야 함.

### 단계 1) 행렬 정의/전환 허용

```python
# demo_policy.py

from access_matrix import AccessMatrix

am = AccessMatrix()
for s in ["HR","Engineer","Auditor","Admin"]: am.create_subject(s)
for o in ["/payroll.csv","/src","/audit.log"]: am.create_object(o, owner="Admin")

am.enter("HR","/payroll.csv","read",  by="Admin")
am.enter("HR","/payroll.csv","write", by="Admin")
am.enter("Engineer","/src","read",    by="Admin")
am.enter("Auditor","/audit.log","read",  by="Admin")
am.enter("Auditor","/audit.log","write", by="Admin")

am.allow_switch("Engineer","Auditor", admin="Admin")   # 정책 허용
curD = am.switch("Engineer","Auditor")
assert am.can(curD,"/audit.log","read")
```

### 단계 2) 선택적 철회(객체 단위) — cap-table 버전

```python
# demo_revoke.py

from cap_table import CapTable
ct = CapTable()
oid = ct.create_object(b"logs")
capA = ct.issue(oid, ["read","write"])   # 엔지니어의 감사 권한 대행용 sub-object라 가정
print(ct.read(capA))
ct.revoke_selective(oid)                 # sub-object 버전 증가 → 이전 capA는 무효화
try:
    ct.write(capA, b"tamper")
except PermissionError:
    print("cap revoked successfully")
```

---

## 핵심 요약

- **17.4 Domain of Protection**: 도메인은 **현재 가능한 권한의 집합**이며, **전환**(증폭/감쇠)은 정책과 메커니즘(참조 모니터)로 통제한다. FD/능력 전달은 **도메인 구성**의 1급 도구다.
- **17.5 Access Matrix**: 이론적 “정답형” 모델로, HRU의 **안전성 문제**는 일반적으로 **비결정 가능**. 실무에서는 **owner/control/copy** 메타 권한으로 거버넌스를 단순화한다.
- **17.6 Implementation**:
  - **ACL(객체 중심)** ↔ **Capability(주체 중심)** 를 **혼합**해 쓴다.
  - **철회**는 **간접화/버전/키 회전/임대** 등으로 해결.
  - **openat+FD**, **capabilities**, **seccomp/LSM** 으로 행렬의 의도를 시스템에 **견고하게 구현**하라.
