---
layout: post
title: 선형대수 - 행렬의 곱의 성질
date: 2025-05-14 22:20:23 +0900
category: 선형대수
---
# 행렬의 곱의 성질과 주의점

## 1. 행렬 곱의 정의

두 행렬 $$\mathbf{A}\in\mathbb{R}^{m\times n}$$, $$\mathbf{B}\in\mathbb{R}^{n\times p}$$ 의 곱 $$\mathbf{C}=\mathbf{A}\mathbf{B}$$ 는
$$
\mathbf{C}_{ij}=\sum_{k=1}^{n}\mathbf{A}_{ik}\,\mathbf{B}_{kj}.
$$
즉, **A의 i번째 행**과 **B의 j번째 열**의 내적입니다.

---

## 2. 기본 성질(정방 여부와 무관, 정의 가능한 경우)

### 2.1 결합법칙
$$
\mathbf{A}(\mathbf{B}\mathbf{C})=(\mathbf{A}\mathbf{B})\mathbf{C}.
$$
결과는 같지만 **연산 순서(괄호)** 에 따라 비용과 수치오차가 달라질 수 있습니다.

### 2.2 분배법칙
$$
\mathbf{A}(\mathbf{B}+\mathbf{C})=\mathbf{A}\mathbf{B}+\mathbf{A}\mathbf{C},\qquad
(\mathbf{A}+\mathbf{B})\mathbf{C}=\mathbf{A}\mathbf{C}+\mathbf{B}\mathbf{C}.
$$

### 2.3 항등원
$$
\mathbf{A}\mathbf{I}=\mathbf{I}\mathbf{A}=\mathbf{A}
$$
(크기가 맞는 단위행렬 $$\mathbf{I}$$).

### 2.4 전치 연산과의 관계
$$
(\mathbf{A}\mathbf{B})^\top=\mathbf{B}^\top\mathbf{A}^\top,\qquad
(\mathbf{A}\mathbf{B}\mathbf{C})^\top=\mathbf{C}^\top\mathbf{B}^\top\mathbf{A}^\top.
$$
**순서가 역전**됩니다.

### 2.5 역행렬과의 관계(정방, 가역일 때)
$$
(\mathbf{A}\mathbf{B})^{-1}=\mathbf{B}^{-1}\mathbf{A}^{-1}.
$$
단, 개별 역행렬이 실제로 존재해야 합니다.

---

## 3. 주의할 점

### 3.1 교환법칙은 일반적으로 성립하지 않음
$$
\mathbf{A}\mathbf{B}\ne \mathbf{B}\mathbf{A}.
$$
특수한 경우(모두 대각행렬, 단위행렬, 동시대각화 가능, 같은 행렬의 다항식 등)를 제외하면 거의 불성립입니다.

### 3.2 차원 조건
$$
\mathbf{A}_{m\times n}\cdot \mathbf{B}_{n\times p}
$$
와 같이 **앞의 열 수 = 뒤의 행 수** 여야 곱셈이 정의됩니다.

### 3.3 영이 아닌 행렬의 곱이 영행렬이 될 수 있음
$$
\mathbf{A}\ne \mathbf{0},\ \mathbf{B}\ne \mathbf{0}\quad \text{이지만}\quad \mathbf{A}\mathbf{B}=\mathbf{0}.
$$
이는 스칼라 세계와 다른 중요한 차이점입니다.

### 3.4 역행렬 관련 착각 방지
$$
(\mathbf{A}\mathbf{B})^{-1}=\mathbf{B}^{-1}\mathbf{A}^{-1}
$$
는 **두 행렬 모두** 가역일 때만. 또한 $$\mathbf{A}\mathbf{B}$$ 가 가역이면 각각도 가역입니다(정방).

### 3.5 계산 비용
정방 $$n\times n$$ 행렬 일반 곱의 연산량은 전통적으로 $$O(n^3)$$. (이론적으로는 더 빠른 알고리즘 존재하지만 실무는 고성능 BLAS/GPU 사용)
**괄호 배치**에 따라 총 곱셈 수가 크게 달라질 수 있습니다(아래 §8 참조).

### 3.6 원소곱과 행렬곱 혼동 금지
PyTorch에서 `*` 는 **원소별 곱**, `@` 또는 `torch.matmul`/`torch.mm` 은 **행렬곱**입니다.

---

## 4. 랭크와 부분공간 관점

- 열공간 포함관계: $$\operatorname{Col}(\mathbf{A}\mathbf{B})\subseteq \operatorname{Col}(\mathbf{A})$$
- 행공간 포함관계: $$\operatorname{Row}(\mathbf{A}\mathbf{B})\subseteq \operatorname{Row}(\mathbf{B})$$
- 랭크 상계:
$$
\operatorname{rank}(\mathbf{A}\mathbf{B})\le \min\bigl(\operatorname{rank}(\mathbf{A}),\operatorname{rank}(\mathbf{B})\bigr).
$$

---

## 5. 정방에서의 행렬식·트레이스·고유값

- 행렬식: $$\det(\mathbf{A}\mathbf{B})=\det(\mathbf{A})\det(\mathbf{B}).$$
- 트레이스의 순환성(스칼라 결과가 정의될 때):
$$
\operatorname{tr}(\mathbf{A}\mathbf{B})=\operatorname{tr}(\mathbf{B}\mathbf{A}),\quad
\operatorname{tr}(\mathbf{A}\mathbf{B}\mathbf{C})=\operatorname{tr}(\mathbf{B}\mathbf{C}\mathbf{A})=\operatorname{tr}(\mathbf{C}\mathbf{A}\mathbf{B}).
$$
- 고유값: 일반적으로 $$\lambda(\mathbf{A}\mathbf{B})\ne \lambda(\mathbf{B}\mathbf{A})$$ 이지만, **영이 아닌 고유값**의 다중집합은 동일합니다(크기 맞는 경우).

---

## 6. 노름과 안정성(2-노름, 프로베니우스)

- 부서브다항성(서브멀티플리커티브):
$$
\lVert \mathbf{A}\mathbf{B}\rVert \le \lVert \mathbf{A}\rVert\,\lVert \mathbf{B}\rVert.
$$
- 프로베니우스 노름: $$\lVert\mathbf{A}\mathbf{B}\rVert_F \le \lVert\mathbf{A}\rVert_F \lVert\mathbf{B}\rVert_2$$ 등 다양한 상계.
- 수치적 안정성: **조건수** $$\kappa(\mathbf{A})=\lVert\mathbf{A}\rVert\,\lVert\mathbf{A}^{-1}\rVert$$ 가 크면 곱이나 풀이는 오차에 민감.

---

## 7. 행렬곱과 선형사상 합성

행렬은 선형사상. $$\mathbf{B}$$ 다음에 $$\mathbf{A}$$ 를 적용하는 합성은
$$
\mathbf{x}\mapsto \mathbf{B}\mathbf{x}\mapsto \mathbf{A}(\mathbf{B}\mathbf{x})=(\mathbf{A}\mathbf{B})\mathbf{x}.
$$
즉, **합성의 순서**가 곧 **곱의 순서**입니다.

---

## 8. 계산 비용과 괄호 최적화(행렬 연쇄 곱)

세 행렬:
- $$\mathbf{A}\in\mathbb{R}^{10\times 100},\ \mathbf{B}\in\mathbb{R}^{100\times 5},\ \mathbf{C}\in\mathbb{R}^{5\times 50}.$$

1) $$(\mathbf{A}\mathbf{B})\mathbf{C}$$
- $$\mathbf{A}\mathbf{B}$$ 비용: $$10\cdot 100\cdot 5=5{,}000$$
- 결과 크기: $$10\times 5$$
- 그 다음 비용: $$10\cdot 5\cdot 50=2{,}500$$
- 총: **7,500**

2) $$\mathbf{A}(\mathbf{B}\mathbf{C})$$
- $$\mathbf{B}\mathbf{C}$$ 비용: $$100\cdot 5\cdot 50=25{,}000$$
- 결과 크기: $$100\times 50$$
- 다음 비용: $$10\cdot 100\cdot 50=50{,}000$$
- 총: **75,000**

같은 결과라도 괄호만으로 비용이 **10배 차이**가 납니다. 실제 시스템에서는 **동적 계획법**(Matrix Chain Multiplication)으로 최적 괄호화를 선택합니다.

---

## 9. 블록 행렬 곱(형상 나누기)

블록 분할
$$
\mathbf{A}=\begin{bmatrix}\mathbf{A}_{11}&\mathbf{A}_{12}\\\mathbf{A}_{21}&\mathbf{A}_{22}\end{bmatrix},\quad
\mathbf{B}=\begin{bmatrix}\mathbf{B}_{11}&\mathbf{B}_{12}\\\mathbf{B}_{21}&\mathbf{B}_{22}\end{bmatrix}
$$
이면
$$
\mathbf{A}\mathbf{B}=
\begin{bmatrix}
\mathbf{A}_{11}\mathbf{B}_{11}+\mathbf{A}_{12}\mathbf{B}_{21} & \mathbf{A}_{11}\mathbf{B}_{12}+\mathbf{A}_{12}\mathbf{B}_{22}\\
\mathbf{A}_{21}\mathbf{B}_{11}+\mathbf{A}_{22}\mathbf{B}_{21} & \mathbf{A}_{21}\mathbf{B}_{12}+\mathbf{A}_{22}\mathbf{B}_{22}
\end{bmatrix}.
$$
대규모 곱에서 **캐시 효율**과 **병렬화**를 위해 블록화를 적극 활용합니다.

---

## 10. PyTorch 실전 팁(요약)

- 행렬곱: `A @ B`, `torch.matmul(A,B)`, 2D 전용은 `torch.mm(A,B)`
- 배치 행렬곱: `torch.bmm(B1, B2)` (크기: `(batch, m, n)` × `(batch, n, p)` → `(batch, m, p)`)
- 원소곱: `A * B` (브로드캐스팅 주의)
- 전치: `A.T` 또는 `A.transpose(-1,-2)`
- 형상 확인: `A.shape`, 디버깅 시 `assert A.size(1) == B.size(0)`
- 메모리/성능: 괄호로 중간 형상 축소, `einsum` 으로 의도를 명시 가능
- 수치안정: float64, 정규화, 필요 시 SVD/QR 사용

---

## 11. PyTorch 예제 모음

```python
import torch
torch.set_printoptions(precision=5, sci_mode=False)
dtype = torch.float64

# 1. 기본 정의·차원 검사
A = torch.randn(3, 2, dtype=dtype)
B = torch.randn(2, 4, dtype=dtype)
C = A @ B  # (3x4)
print("C.shape =", C.shape)

# 2. 결합법칙(값 동일성 확인)
X = torch.randn(5, 6, dtype=dtype)
Y = torch.randn(6, 7, dtype=dtype)
Z = torch.randn(7, 4, dtype=dtype)
left  = X @ (Y @ Z)
right = (X @ Y) @ Z
print("Associativity OK? ", torch.allclose(left, right, atol=1e-10))

# 3. 분배법칙
U = torch.randn(4, 4, dtype=dtype)
V = torch.randn(4, 3, dtype=dtype)
W = torch.randn(4, 3, dtype=dtype)
lhs = U @ (V + W)
rhs = U @ V + U @ W
print("Distributivity OK? ", torch.allclose(lhs, rhs, atol=1e-10))

# 4. 전치와의 관계
A = torch.randn(3, 5, dtype=dtype)
B = torch.randn(5, 2, dtype=dtype)
left  = (A @ B).T
right = B.T @ A.T
print("(AB)^T = B^T A^T ? ", torch.allclose(left, right, atol=1e-10))

# 5. 비교환성 예시
A = torch.tensor([[1., 2.],
                  [3., 4.]], dtype=dtype)
B = torch.tensor([[2., 0.],
                  [1., 2.]], dtype=dtype)
print("AB =\n", A @ B)
print("BA =\n", B @ A)  # 다름

# 6. 영곱 예시(둘 다 영이 아닌데 AB=0)
A = torch.tensor([[ 1., -1.],
                  [ 1., -1.]], dtype=dtype)
B = torch.tensor([[1., 1.],
                  [1., 1.]], dtype=dtype)
print("Zero product AB =\n", A @ B)  # 0행렬

# 7. 항등원
I = torch.eye(3, dtype=dtype)
M = torch.randn(3, 3, dtype=dtype)
print("MI - M Fro norm =", torch.linalg.norm(M @ I - M))
print("IM - M Fro norm =", torch.linalg.norm(I @ M - M))

# 8. 랭크 상계 확인
P = torch.randn(6, 3, dtype=dtype)  # rank ≤ 3
Q = torch.randn(3, 5, dtype=dtype)  # rank ≤ 3
PQ = P @ Q
rankP  = torch.linalg.matrix_rank(P)
rankQ  = torch.linalg.matrix_rank(Q)
rankPQ = torch.linalg.matrix_rank(PQ)
print("rank(PQ) ≤ min(rank(P), rank(Q)) ? ",
      int(rankPQ.item()), "<=", min(int(rankP.item()), int(rankQ.item())))

# 9. 트레이스 순환성(스칼라 결과 정의되는 형상)
A = torch.randn(4, 3, dtype=dtype)
B = torch.randn(3, 4, dtype=dtype)
tr1 = torch.trace(A @ B)      # 4x4 trace
tr2 = torch.trace(B @ A)      # 3x3 trace
print("tr(AB) == tr(BA)? ", torch.allclose(tr1, tr2, atol=1e-10))

# 10. 원소곱 vs 행렬곱 구분
X = torch.randn(2, 2, dtype=dtype)
Y = torch.randn(2, 2, dtype=dtype)
print("Elementwise X*Y =\n", X * Y)
print("Matrix X@Y =\n", X @ Y)

# 11. 괄호에 따른 형상·비용 차이(간단 데모)
A = torch.randn(10, 100, dtype=dtype)
B = torch.randn(100, 5, dtype=dtype)
C = torch.randn(5, 50, dtype=dtype)
# (AB)C 와 A(BC)는 결과 동일하지만, 중간 형상과 연산량이 크게 다름
left  = (A @ B) @ C   # 중간 10x5
right = A @ (B @ C)   # 중간 100x50
print("Same result? ", torch.allclose(left, right, atol=1e-10))
print("Intermediates shapes: (AB) ->", (A @ B).shape, "  (BC) ->", (B @ C).shape)
```

---

## 12. 오류와 함정 체크리스트

1) 곱의 **차원 조건**을 먼저 확인(런타임 에러 예방).
2) `*`(원소곱) vs `@`(행렬곱) 구분.
3) 괄호로 **중간 형상**을 줄여 연산량·메모리 절약.
4) 수치감도 높은 문제에서는 float64, 정규화, SVD/QR 사용.
5) 배치 곱에서 브로드캐스트 의도 확인(`bmm`, `einsum` 적극 활용).

---

## 13. 요약 표

| 항목 | 수식 | 메모 |
|---|---|---|
| 결합법칙 | $$\mathbf{A}(\mathbf{B}\mathbf{C})=(\mathbf{A}\mathbf{B})\mathbf{C}$$ | 결과 동일, 비용은 다름 |
| 분배법칙 | $$\mathbf{A}(\mathbf{B}+\mathbf{C})=\mathbf{A}\mathbf{B}+\mathbf{A}\mathbf{C}$$ | 좌·우 동일하게 성립 |
| 항등원 | $$\mathbf{A}\mathbf{I}=\mathbf{I}\mathbf{A}=\mathbf{A}$$ | 크기 일치 필요 |
| 전치 | $$(\mathbf{A}\mathbf{B})^\top=\mathbf{B}^\top\mathbf{A}^\top$$ | 순서 역전 |
| 교환법칙 | $$\mathbf{A}\mathbf{B}\neq \mathbf{B}\mathbf{A}$$ | 일반적으로 불성립 |
| 랭크 | $$\operatorname{rank}(\mathbf{A}\mathbf{B})\le \min(\operatorname{rank}\mathbf{A},\operatorname{rank}\mathbf{B})$$ | 포함관계로 이해 |
| 행렬식 | $$\det(\mathbf{A}\mathbf{B})=\det\mathbf{A}\cdot \det\mathbf{B}$$ | 정방일 때 |
| 트레이스 | $$\operatorname{tr}(\mathbf{A}\mathbf{B})=\operatorname{tr}(\mathbf{B}\mathbf{A})$$ | 형상 맞춰 스칼라일 때 |
| 노름 | $$\lVert\mathbf{A}\mathbf{B}\rVert\le \lVert\mathbf{A}\rVert\lVert\mathbf{B}\rVert$$ | 안정성 상계 |

---

## 14. 연습문제(해설 힌트)

1) $$\mathbf{A}\in\mathbb{R}^{m\times n},\ \mathbf{B}\in\mathbb{R}^{n\times p}$$ 에 대해
   i) $$\operatorname{Col}(\mathbf{A}\mathbf{B})\subseteq \operatorname{Col}(\mathbf{A})$$,
   ii) $$\operatorname{Row}(\mathbf{A}\mathbf{B})\subseteq \operatorname{Row}(\mathbf{B})$$ 를 보이시오.
   힌트: $$\mathbf{A}\mathbf{B}=[\mathbf{A}\mathbf{b}_1\ \cdots\ \mathbf{A}\mathbf{b}_p]$$.

2) 아래 세 곱의 비용을 계산하고 최적 괄호화를 고르시오.
   $$\mathbf{A}\in\mathbb{R}^{40\times 10},\ \mathbf{B}\in\mathbb{R}^{10\times 30},\ \mathbf{C}\in\mathbb{R}^{30\times 5}.$$

3) $$\mathbf{A},\mathbf{B}$$ 가 정방일 때 $$\operatorname{tr}(\mathbf{A}\mathbf{B})=\operatorname{tr}(\mathbf{B}\mathbf{A})$$ 를 지수 표기(원소 합)로 증명하시오.

4) 원소곱과 행렬곱을 혼동하면 발생 가능한 버그 시나리오 두 가지를 들고, PyTorch 코드로 재현하시오.

5) $$\mathbf{A}\mathbf{B}=\mathbf{0}$$ 이지만 $$\mathbf{A}\ne \mathbf{0},\ \mathbf{B}\ne \mathbf{0}$$ 인 3×3 예를 구성하시오.
   힌트: 서로 직교인 부분공간으로의 사상 조합.

---

## 15. 결론

- 행렬 곱은 **합성의 연산**이며, 스칼라와 달리 **교환법칙이 없다**는 점이 핵심입니다.
- 결과는 같아도 **괄호** 에 따라 연산량·메모리가 크게 달라집니다.
- 부분공간·랭크·행렬식·트레이스·노름 관점의 성질을 함께 이해하면, 해석과 구현 양쪽에서 실수를 줄일 수 있습니다.
- 실무에서는 **형상 확인 → 올바른 연산자 선택(@/bmm/einsum) → 괄호 최적화 → 수치안정 고려**의 순서로 접근하는 것이 안전합니다.
