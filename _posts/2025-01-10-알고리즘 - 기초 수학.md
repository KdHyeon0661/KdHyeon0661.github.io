---
layout: post
title: 알고리즘 - 기초 수학
date: 2025-01-10 20:20:23 +0900
category: 알고리즘
---
# 알고리즘 기본 수학 정리

## 0. 표기·전제

- 자연수 \( \mathbb{N}=\{1,2,3,\dots\} \), 정수 \( \mathbb{Z} \).
- 나눗셈 표기: \( a \mid b \iff \exists k\in\mathbb{Z}: b=ak \).
- 바닥/천장: \( \lfloor x \rfloor, \lceil x \rceil \).
- 시간복잡도는 입력 크기 \( n \) 또는 값의 크기(비트수 \( \log n \)) 기준으로 명시.

---

## 1. 약수(Divisor) — 정의, 개수, 합, 구하는 법

### 1.1 정의와 성질
- \( d \mid n \iff \exists k : n=dk \).
- 약수는 대칭쌍으로 등장: \( d \mid n \Rightarrow \frac{n}{d} \mid n \).
- **소인수분해** \( n=\prod_{i=1}^{r} p_i^{\alpha_i} \) 이면
  - 약수의 개수:
    $$
    \tau(n)=\prod_{i=1}^{r} (\alpha_i+1)
    $$
  - 약수의 합:
    $$
    \sigma(n)=\prod_{i=1}^{r} \frac{p_i^{\alpha_i+1}-1}{p_i-1}
    $$

### 1.2 약수 전부 나열 — \(O(\sqrt{n})\)
```python
def get_divisors(n: int):
    res = []
    i = 1
    while i * i <= n:
        if n % i == 0:
            res.append(i)
            if i != n // i:
                res.append(n // i)
        i += 1
    res.sort()
    return res
```
- 각 쌍 \((i, n/i)\) 한 번씩만 생성 → \(O(\sqrt{n})\).
- 경계: \(n=1\Rightarrow [1]\). 완전제곱수에서 중복 제거.

### 1.3 약수 개수/합 빠른 계산 — 소인수분해 기반
```python
from collections import Counter

def factor_count(n: int) -> Counter:
    c = Counter()
    d = 2
    while d * d <= n:
        while n % d == 0:
            c[d] += 1
            n //= d
        d += 1 if d == 2 else 2  # 2 이후 홀수만 시도(미세 최적화)
    if n > 1:
        c[n] += 1
    return c  # 예: 180 -> {2:2, 3:2, 5:1}

def tau_sigma_from_factor(fac: Counter):
    # tau, sigma
    tau = 1
    sigma = 1
    for p, a in fac.items():
        tau *= (a + 1)
        sigma *= (p**(a+1) - 1) // (p - 1)
    return tau, sigma
```

---

## 2. 배수(Multiple) — 배수판정, 공배수 집합

- \( a\mid n \iff n \)은 \( a \)의 배수.
- 공배수 집합: \( \{k\cdot \mathrm{lcm}(a,b): k\in\mathbb{Z}_{\ge 0}\} \).
- 배수 판정은 모듈러로 간명: \( n\equiv 0\ (\bmod\ a) \).

---

## 3. 소수(Prime) — 정의, 판정, 고급 판별 개요

### 3.1 정의
- \( n\ge 2 \)가 **소수** \(\iff\) 약수가 \(1,n\)뿐.
- 합성수는 그 외.

### 3.2 단순 판별 — \(O(\sqrt{n})\)
```python
def is_prime(n: int) -> bool:
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    d = 3
    while d * d <= n:
        if n % d == 0:
            return False
        d += 2
    return True
```

### 3.3 고급 판별(스케치)
- **Miller–Rabin** 확률적 테스트: 64비트 정수는 소수의 몇 개 고정 밑으로 결정적 판정 가능.
- 매우 큰 수(수백~수천 자리)는 **AKS**가 이론적으로 다항시간이지만 실전은 Miller–Rabin + 소수 후보 생성·검증 사용.

---

## 4. 유클리드 호제법 — GCD/LCM, 확장형, 성질

### 4.1 기본 호제법
- 정리:
  $$
  \gcd(a,b)=\gcd(b, a\bmod b),\quad \gcd(a,0)=|a|
  $$
- 시간복잡도: \(O(\log \min(a,b))\) (평균적으로 매우 빠름).

```python
def gcd(a: int, b: int) -> int:
    while b:
        a, b = b, a % b
    return abs(a)

def lcm(a: int, b: int) -> int:
    return abs(a // gcd(a, b) * b) if a and b else 0
```
- 곱 오버플로 방지: `a // gcd(a,b) * b` 순서 권장.

### 4.2 확장 유클리드 — 베주 항등식, 모듈러 역원
- 베주 항등식:
  $$
  \gcd(a,b)=ax+by \quad(\exists x,y\in\mathbb{Z})
  $$
- \( \gcd(a,m)=1 \)일 때 \( ax\equiv 1\pmod m \)을 만족하는 **모듈러 역원** \(x\)는 확장 호제법으로 구한다.

```python
def egcd(a: int, b: int):
    # returns (g, x, y): ax + by = g = gcd(a,b)
    if b == 0:
        return (abs(a), 1 if a > 0 else -1, 0)
    g, x1, y1 = egcd(b, a % b)
    x, y = y1, x1 - (a // b) * y1
    return (g, x, y)

def modinv(a: int, m: int):
    g, x, _ = egcd(a, m)
    if g != 1:
        return None  # inverse does not exist
    return x % m
```

### 4.3 여러 수의 GCD/LCM
```python
from math import gcd as _gcd

def gcd_list(arr):
    from functools import reduce
    return reduce(_gcd, arr)

def lcm_list(arr):
    from functools import reduce
    def _lcm(a, b): return abs(a // _gcd(a, b) * b) if a and b else 0
    return reduce(_lcm, arr, 1)
```
- 성질: \( \gcd(a,b)\cdot \mathrm{lcm}(a,b)=|ab| \).
- 분모 통일, 주기 계산, 타임라인 동기화 문제에서 상용.

---

## 5. 최대/최솟값 — 선형 스캔, 분할정복, 자료구조

### 5.1 선형 스캔
```python
def minmax(arr):
    it = iter(arr)
    first = next(it)
    mn = mx = first
    for x in it:
        if x < mn: mn = x
        if x > mx: mx = x
    return mn, mx
```
- \(O(n)\), 비교 \(2(n-1)\).

### 5.2 비교 횟수 줄이기(페어링) — 평균 \(3n/2-2\) 비교
- 원소를 쌍으로 비교해 지역 최소/최대 후보를 만든 뒤 전역 비교를 줄인다.

```python
def minmax_pairwise(a):
    n = len(a)
    if n == 0: raise ValueError
    if n == 1: return a[0], a[0]
    if a[0] < a[1]:
        mn, mx = a[0], a[1]
    else:
        mn, mx = a[1], a[0]
    i = 2
    while i + 1 < n:
        x, y = a[i], a[i+1]
        if x < y:
            if x < mn: mn = x
            if y > mx: mx = y
        else:
            if y < mn: mn = y
            if x > mx: mx = x
        i += 2
    if i < n:
        if a[i] < mn: mn = a[i]
        if a[i] > mx: mx = a[i]
    return mn, mx
```

### 5.3 범위 질의(RMQ) — 스파스 테이블(정적)
- 전처리 \(O(n\log n)\), 질의 \(O(1)\). 업데이트 없음.

```python
import math

def build_sparse_min(a):
    n = len(a)
    k = math.floor(math.log2(n)) + 1
    st = [[0]*n for _ in range(k)]
    st[0] = a[:]
    j = 1
    while (1 << j) <= n:
        i = 0
        while i + (1 << j) <= n:
            st[j][i] = min(st[j-1][i], st[j-1][i + (1 << (j-1))])
            i += 1
        j += 1
    lg = [0]*(n+1)
    for i in range(2, n+1):
        lg[i] = lg[i//2] + 1
    return st, lg

def range_min(st, lg, l, r):
    j = lg[r-l+1]
    return min(st[j][l], st[j][r - (1 << j) + 1])
```

---

## 6. 에라토스테네스의 체 — 최적화, 확장

### 6.1 기본 체 \(O(n\log\log n)\)
```python
def sieve(n: int):
    is_p = [True]*(n+1)
    if n >= 0: is_p[0] = False
    if n >= 1: is_p[1] = False
    i = 2
    while i * i <= n:
        if is_p[i]:
            step = i
            start = i*i
            is_p[start:n+1:step] = [False]*(((n - start)//step) + 1)
        i += 1
    return [i for i, v in enumerate(is_p) if v]
```

### 6.2 최소소인수(SPF) 체 — 빠른 소인수분해
- 각 수의 **최소 소인수(spf)**를 저장하면 개별 분해가 \(O(\log n)\).

```python
def sieve_spf(n: int):
    spf = list(range(n+1))
    for i in range(2, int(n**0.5)+1):
        if spf[i] == i:
            for j in range(i*i, n+1, i):
                if spf[j] == j:
                    spf[j] = i
    return spf

def factorize_with_spf(x: int, spf):
    fac = []
    while x > 1:
        p = spf[x]
        fac.append(p)
        x //= p
    return fac
```

### 6.3 분할(세그먼트) 체 — 구간 \([L,R]\) 소수
- 큰 범위에서 부분 구간만 소수 판정할 때 사용(메모리 절약).
- 아이디어: \(\le \sqrt{R}\) 소수로 \([L,R]\)의 배수만 마킹.

```python
def segmented_sieve(L: int, R: int):
    import math
    lim = int(math.isqrt(R)) + 1
    base = sieve(lim)
    is_p = [True]*(R-L+1)
    if L == 1:
        is_p[0] = False
    for p in base:
        s = max(p*p, ((L + p - 1)//p)*p)
        for x in range(s, R+1, p):
            is_p[x - L] = False
    return [L+i for i,v in enumerate(is_p) if v]
```

---

## 7. 소인수분해 — 기본, 다중 쿼리 최적화, 결과 가공

### 7.1 기본 \(O(\sqrt{n})\)
```python
def factorize(n: int):
    res = []
    d = 2
    while d * d <= n:
        while n % d == 0:
            res.append(d)
            n //= d
        d += 1 if d == 2 else 2
    if n > 1:
        res.append(n)
    return res
```

### 7.2 SPF로 다중 쿼리 가속
- 위 6.2 참고: **사전 전처리 \(O(n\log\log n)\)** + 각 쿼리 \(O(\log n)\).

### 7.3 소인수 카운트/집합/표현
```python
from collections import Counter

def factor_counter(n: int):
    c = Counter()
    d = 2
    while d * d <= n:
        while n % d == 0:
            c[d] += 1
            n //= d
        d += 1 if d == 2 else 2
    if n > 1:
        c[n] += 1
    return c  # 예: 60 -> {2:2, 3:1, 5:1}

def factor_format(c: Counter):
    # 60 -> "2^2 * 3 * 5"
    parts = []
    for p in sorted(c):
        e = c[p]
        parts.append(f"{p}^{e}" if e > 1 else f"{p}")
    return " * ".join(parts)
```

---

## 8. 오일러 피 함수 \( \varphi(n) \) — 서로소 개수

- 정의: \( \varphi(n) = |\{ 1\le k\le n : \gcd(k,n)=1 \}| \).
- 성질: \( n=\prod p_i^{\alpha_i} \Rightarrow \varphi(n)=\prod p_i^{\alpha_i-1}(p_i-1) \).
- 체로 일괄 계산 가능(토션트 체).

```python
def phi_from_factor(c: Counter):
    res = 1
    for p, a in c.items():
        res *= (p - 1) * (p ** (a - 1))
    return res
```

토션트 체(1..N의 \(\varphi\))는 별도 구현이 있으나 여기서는 개념만 언급.

---

## 9. 모듈러 연산 — 역원, 거듭제곱, 중국인의 나머지 정리(개요)

### 9.1 모듈러 거듭제곱(분할정복)
```python
def modpow(a: int, e: int, m: int) -> int:
    a %= m
    r = 1
    while e > 0:
        if e & 1:
            r = (r * a) % m
        a = (a * a) % m
        e >>= 1
    return r
```

### 9.2 역원: \( \gcd(a,m)=1 \Rightarrow a^{-1}\equiv a^{\varphi(m)-1}\ (\bmod m) \)
- \( m \)이 소수이면 **페르마 소정리**: \( a^{m-1}\equiv 1 \Rightarrow a^{m-2} \)가 역원.
- 일반 \( m \): **확장 유클리드**를 쓰는 편이 범용.

```python
def modinv_prime(a, p):  # p is prime
    return modpow(a, p-2, p)
```

### 9.3 중국인의 나머지 정리(CRT) 개요
- 서로소 법 \(m_1,\dots,m_k\) 에 대하여
  $$
  x\equiv a_i\pmod{m_i} \quad \Rightarrow\quad \exists!\ x\ (\bmod\ M),\ M=\prod m_i
  $$
- 구현은 확장 유클리드로 각 성분 결합(여기서는 설계만).

---

## 10. 실전 패턴 — 문제 유형과 즉용 레시피

1) **배열의 모든 원소 GCD/LCM**
   - 누적 \( \gcd \)/\( \mathrm{lcm} \) 축적. 값이 커지면 오버플로 주의.
2) **범위 내 소수 개수/열거**
   - 단일 범위: 체. 긴 범위 일부: 분할 체.
3) **다중 소수 판정 쿼리**
   - 상한 \(N\) 작음: 체로 전처리, 쿼리 \(O(1)\).
   - 상한 큼: Miller–Rabin(64비트 결정적 밑) + 캐시.
4) **약수 관련 합/개수**
   - 소인수분해 후 공식 적용.
5) **모듈러 역원/방정식**
   - \(\gcd(a,m)=1\) 확인 → 확장 유클리드 또는 페르마(소수 모듈러).
6) **최솟값/최댓값 반복 질의**
   - 정적: 스파스 테이블. 동적 갱신: 세그먼트 트리(여기서는 생략).

---

## 11. 예제 모음 — 입력/출력과 함께

### 11.1 약수 나열, 개수/합
```python
def divisors_info(n: int):
    divs = get_divisors(n)
    fac = factor_count(n)
    tau, sigma = tau_sigma_from_factor(fac)
    return divs, tau, sigma

# 예시
n = 180
divs, cnt, s = divisors_info(n)
print(n, divs[:10], "...", "개수:", cnt, "합:", s)
```

### 11.2 다중 소수 판정 + 체 활용
```python
def primes_upto(n: int):
    return sieve(n)

def primes_query(queries, limit):
    # limit 이하 질의만 처리
    is_p = [False]*(limit+1)
    for p in sieve(limit):
        is_p[p] = True
    return [is_p[x] if 0 <= x <= limit else None for x in queries]

print(primes_query([1,2,3,4,9973,10007], 10007))
```

### 11.3 배열 GCD/LCM
```python
arr = [24, 36, 60]
print(gcd_list(arr))  # 12
print(lcm_list(arr))  # 360
```

### 11.4 모듈러 역원과 선형 방정식
```python
# ax ≡ b (mod m), gcd(a,m)=g
# 해가 존재하려면 g | b, 해의 수는 g개
def solve_linear_congruence(a, b, m):
    g, x, _ = egcd(a, m)
    if b % g != 0:
        return None
    a2, b2, m2 = a//g, b//g, m//g
    inv = modinv(a2 % m2, m2)
    x0 = (inv * (b2 % m2)) % m2
    # 일반해: x ≡ x0 (mod m2)
    return x0, m2

print(solve_linear_congruence(6, 8, 14))  # (x0, mod') or None
```

---

## 12. 증명 스케치·정당성 핵심

### 12.1 유클리드 호제법 유도
- 나눗셈 알고리즘 \( a = bq + r \)에서 \( d\mid a \)이자 \( d\mid b \)면 \( d\mid r \).
  따라서 공약수의 집합이 \( \gcd(b,r) \)와 동일 → 최대원도 동일.

### 12.2 체의 복잡도
- \( \sum_{p\le n} \frac{n}{p} \approx n \log \log n \) 수준(조화급수와 소수 분포 성질) → \(O(n\log\log n)\).

### 12.3 약수 개수/합 공식
- 곱셈적 성질: 서로소 정수 \(a,b\)에 대해 \(\tau(ab)=\tau(a)\tau(b)\), \(\sigma(ab)=\sigma(a)\sigma(b)\)가 성립.
  소수 거듭제곱에 대한 닫힌식에서 곱으로 확장.

---

## 13. 경계·테스트 체크리스트

- **소수 판정**: \(n<2\) 처리, 짝수 예외 처리(2), 루프 한계 \(i*i\le n\).
- **약수 나열**: 완전제곱수 중복 방지.
- **GCD/LCM**: 0 포함 케이스, 부호 처리(`abs`). LCM 곱 순서로 오버플로 방지.
- **체**: `is_prime[0]=is_prime[1]=False`, 시작점 `i*i` 최적화.
- **분할 체**: \(L=1\) 처리, 오프셋 정렬.
- **확장 유클리드**: 부호 일관, 역원 없음 처리.
- **RMQ**: 구간 포함 인덱스, 로그 배열 준비.

---

## 14. 실전 응용 미니 과제

1) **구간 [L,R]의 소수 개수와 합**: 분할 체로 소수 목록을 만들고 합산.
2) **정수 배열의 모든 원소를 동일 수로 만들기 최소 연산**: 공약수/나머지 패턴으로 귀결되는 경우가 많음.
3) **분수 합 단순화**: 분자/분모 GCD로 기약분수화.
4) **동일 주기 만남 시각**: 여러 주기 \(T_i\)의 동시 발생 주기 \( \mathrm{lcm}(T_1,\dots,T_k) \).
5) **나머지 연립방정식**: CRT로 결합(서로소 조건 검토).

---

## 부록 A. 수식 요약

- \( \gcd(a,b)=\gcd(b, a\bmod b) \)
- \( \gcd(a,b)\cdot \mathrm{lcm}(a,b)=|ab| \)
- \( n=\prod p_i^{\alpha_i}\Rightarrow
  \tau(n)=\prod (\alpha_i+1),\
  \sigma(n)=\prod \frac{p_i^{\alpha_i+1}-1}{p_i-1},\
  \varphi(n)=\prod p_i^{\alpha_i-1}(p_i-1) \)
- 체 복잡도:
  $$
  O(n\log\log n)
  $$

---

## 결론

초안의 핵심(약수·배수·소수·유클리드 호제법·최대/최솟값·체·소인수분해)을 **정의→구현→증명 스케치→경계 케이스→응용 패턴** 순으로 확장했다.
현업/대회에서 자주 마주치는 **배열 GCD/LCM, 대량 소수 쿼리, 모듈러 역원, 구간 소수, RMQ**를 빠르게 풀려면, 위 **레시피(코드 스니펫 + 선택 기준)**를 바로 적용하면 된다. 다음 학습 경로로는 **Miller–Rabin의 결정적 밑(64비트), 토션트 체, 세그먼트 트리(RMQ/합/최댓값), CRT 구현**을 추천한다.
