---
layout: post
title: 논리회로설계 - 순서회로설계 (1)
date: 2025-09-08 23:25:23 +0900
category: 논리회로설계
---
# 순서회로설계 — **설계 과정 요약**, **설계 예제: 코드 변환기**, **반복회로(Iterative) 설계**, **ROM/PLA 기반 순서회로 설계**

> 표기: 입력 \(x\), 출력 \(y\), 상태벡터 \(\mathbf{Q}=(Q_{n-1}\dots Q_0)\), 다음상태 \(\mathbf{Q}^+\), \(\overline{X}\)=NOT, \(\oplus\)=XOR.  
> 모델: **동기식(클럭형)** Mealy/Moore, 에지 트리거 D FF 가정. 출력은 실무상 **등록(레지스터링)** 권장.

---

## 1) 순서회로 설계 과정 **요약**

### 1.1 요구사항·명세 정리
- **기능**: 입력/출력 의미, 타이밍(동기/비동기), 초기화/리셋 방식.  
- **모델**: **Mealy**(간선 출력) vs **Moore**(노드 출력). Mealy는 **즉시성**↑, Moore는 **글리치 내성**↑.  
- **제약**: 클럭 주기 \(T\), 팬인/팬아웃, 전력/면적, CDC(Clock Domain Crossing) 유무.  
- **오버랩**(sequence detector), **프레임/프로토콜**(시작/종료 비트), **오류 처리**(Self-Start, Lockout 금지).

### 1.2 상태 도출·그래프/표
1) **기억해야 할 정보**를 **상태**로 정의(접두/접미 원리, 카운터·타이머 포함).  
2) **상태그래프**(Mealy: 간선 `입력/출력`, Moore: 노드 `출력`).  
3) **상태표**: 모든 `(현재상태, 입력)`에 대해 `(다음상태, 출력)`을 **완전**기입. (ISM이면 ‘–’로 표시)

### 1.3 간략화
- **Reachability**: 도달 불가 상태 제거.  
- **최소화**: 등가/호환 병합(함의 차트, 분할 정련).  
- **ISM**(불완전 명세): **호환/닫힌 커버**로 병합, 미정 전이는 **안전하게 채움**(IDLE 복귀 등).

### 1.4 상태할당(State Assignment)
- **원-핫**(FPGA 친화, 고속, FF↑), **이진**(ASIC 친화, FF↓), **그레이**(해밍1 전이, 해저드↓).  
- **가이드**: 빈번 전이를 **해밍 1**로, Moore 출력은 **상태코드 비트 내장** 검토.

### 1.5 플립플롭 입력식 유도
\[
\boxed{
D_i=Q_i^+,\quad
T_i=Q_i\oplus Q_i^+,\quad
J_i=\overline{Q_i}Q_i^+,\;\;K_i=Q_i\overline{Q_i^+}
}
\]
(SR도 동일 형태, 단 금지 \(S=R=1\) 방지 확인)

### 1.6 구현·검증·타이밍
- **합성 친화** RTL(VHDL/SystemVerilog), **Mealy 출력 등록** 권장.  
- **타이밍**: \(t_{CQ}+t_{\text{comb}}+t_{SU}\le T\), **리셋 해제 동기화**.  
- **시뮬/포멀**: 단위 테스트, 커버리지, 어서션(불법상태 진입 금지), Self-Start 검증.  
- **물리 고려**: 클록트리 부하(원-핫), 배선/지연 균형(해저드 회피), 전력(토글 확률).

---

## 2) 설계 예제 — **코드 변환기**

### 2.1 예제 1: **직렬 NRZI ↔ NRZ 디코더** (Mealy, 2상태)
- **규칙**: NRZI 수신 레벨 \(r[k]\)가 **변화하면 1**, **유지하면 0**.  
- **상태** \(q\): 직전 레벨.  
- **방정식**: \(q^+=r,\;\; y=r\oplus q\) (Mealy).  
- **상태표**

| q(이전) | r(현재) | q⁺ | y(NRZ) |
|:--:|:--:|:--:|:--:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 0 |

- **VHDL(출력 등록)**:
```vhdl
library ieee; use ieee.std_logic_1164.all;
entity nrzi_dec is
  port (clk,rst: in std_logic; r: in std_logic; y: out std_logic);
end;
architecture rtl of nrzi_dec is
  signal q, y_i : std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then q<='0'; y_i<='0';
      else            y_i <= r xor q; q <= r;
      end if;
    end if;
  end process;
  y <= y_i;
end;
```

> **인코더(Moore)**: \(q^+=q\oplus d,\; y=q^+\). (상태=라인 레벨)

---

### 2.2 예제 2: **프레임 있는 직렬 BCD→그레이 변환기** (Moore, 중규모 FSM)

**프레임 포맷**: `START=1` → `D3 D2 D1 D0`(MSB→LSB, BCD) → `PARITY(EVEN)` → `STOP=0`.  
**목표**: 각 프레임마다 **그레이 코드 4비트**를 병렬로 내보내고 `VAL` 펄스 1클럭 출력.

#### (1) 기능 블록 분해
- **수신기/프레이머 FSM**: START/STOP·길이·패리티 체크, 비트 카운터.  
- **시리얼 쉬프트레지스터**: 4비트 수집.  
- **조합 변환기(BCD→Gray)**: \(G_3=B_3,\; G_2=B_3\oplus B_2,\; G_1=B_2\oplus B_1,\; G_0=B_1\oplus B_0\).  
- **에러 처리**: 패리티 불일치면 `ERR=1`, 프레임 폐기.

#### (2) 상태 설계(원-핫 예)
- \(S0\)(IDLE), \(S1\)(DATA3), \(S2\)(DATA2), \(S3\)(DATA1), \(S4\)(DATA0), \(S5\)(PAR), \(S6\)(STOP/OUT)  
- 입력: `x`(시리얼 비트), `tick`(오버샘플링 동기 1펄스).  
- 출력: `VAL`, `ERR`, `G[3:0]`(등록된 병렬).  
- 전이(요지):  
  - S0: `tick & x=1 → S1`(START), 그 외 S0 유지.  
  - S1..S4: 매 `tick`마다 쉬프트, 다음 상태로 진행.  
  - S5: 패리티 비교, 오류면 `ERR=1`, 그래도 S6로.  
  - S6: `tick & x=0`이면 STOP OK → `VAL=1`, S0 복귀. 아니면 ERR.

#### (3) 시프트·패리티
- 쉬프트레지스터 \(R\leftarrow (R<<1)|x\) (MSB-먼저 수신이면 반대로).  
- **짝수 패리티**: 누적 XOR `p ^= x`(DATA4개만).

#### (4) Moore 출력 정의
- `VAL=1` @S6(정상 STOP 감지 사이클)  
- `ERR=1` @S5(패리티 불일치) 또는 S6에서 STOP 오류  
- `G <= Gray(R)` @S6 입장 시 등록

#### (5) VHDL 스켈레톤
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity bcd2gray_serial is
  port (clk,rst: in std_logic; tick: in std_logic; x: in std_logic;
        G: out std_logic_vector(3 downto 0);
        VAL, ERR: out std_logic);
end;
architecture rtl of bcd2gray_serial is
  type S_t is (S0,S1,S2,S3,S4,S5,S6);
  signal s, ns: S_t := S0;
  signal R: std_logic_vector(3 downto 0) := (others=>'0');
  signal parity: std_logic := '0';
  signal G_i: std_logic_vector(3 downto 0) := (others=>'0');
  signal VAL_i, ERR_i: std_logic := '0';
  function gray4(b: std_logic_vector(3 downto 0)) return std_logic_vector is
  begin
    return b(3) & (b(3) xor b(2)) & (b(2) xor b(1)) & (b(1) xor b(0));
  end;
begin
  -- next-state
  process(all) begin
    ns   <= s; VAL_i <= '0'; ERR_i <= '0';
    case s is
      when S0 =>
        if tick='1' and x='1' then ns <= S1; end if;  -- START=1
      when S1 =>
        if tick='1' then ns <= S2; end if;
      when S2 =>
        if tick='1' then ns <= S3; end if;
      when S3 =>
        if tick='1' then ns <= S4; end if;
      when S4 =>
        if tick='1' then ns <= S5; end if;
      when S5 => -- parity check
        if tick='1' then
          if parity = x then ns <= S6; else ns <= S6; ERR_i<='1'; end if;
        end if;
      when S6 => -- STOP=0 expected
        if tick='1' then
          if x='0' then VAL_i<='1'; else ERR_i<='1'; end if;
          ns <= S0;
        end if;
    end case;
  end process;

  -- state/regs
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then s<=S0; R<=(others=>'0'); parity<='0'; G_i<=(others=>'0');
      else
        s <= ns;
        if tick='1' then
          case s is
            when S1|S2|S3|S4 =>
              R <= R(2 downto 0) & x;    -- shift in
              parity <= parity xor x;    -- even parity accumulate
            when S5 =>
              null;                      -- only check in comb part
            when S6 =>
              G_i <= gray4(R);           -- latch Gray
              parity <= '0';
            when others => null;
          end case;
        end if;
      end if;
    end if;
  end process;

  G   <= G_i;
  VAL <= VAL_i;
  ERR <= ERR_i;
end;
```

> **검증 팁**: 무작위 프레임 생성 TB에서 `Gray(B)`와 매칭, 패리티/STOP 오류 삽입 테스트, 커버리지(상태/전이/ERR) 100% 목표.

---

## 3) **반복회로(Iterative Circuit) 설계**

반복회로는 **작은 하드웨어**를 **여러 클럭에 걸쳐** 동작시켜 연산을 완성한다. 컨트롤러(FSM)+데이터패스(레지스터·ALU)의 **마이크로연산**이 핵심.

### 3.1 예제 1 — **직렬 가산기**(Serial Adder)
- 구성: 시리얼 입력 \(a_i,b_i\) (LSB→MSB), **전가산기(FA)** + **캐리 FF \(C\)** + **시프트레지스터**.  
- 방정식: \(s_i = a_i \oplus b_i \oplus C\), \(C^+ = a_ib_i + (a_i\oplus b_i)C\).  
- 제어: **한 상태**로도 가능(매 클럭 동일 동작).  
- 장점: 면적↓, 단점: \(n\)클럭 지연.

### 3.2 예제 2 — **시프트-가산 곱셈기**(Shift-Add Multiplier, unsigned)
- 목표: \(P \leftarrow A \times B\) (n비트).  
- 데이터패스: `Areg`(피승수), `Breg`(승수), `Preg`(누산기 2n비트), `cnt`(n).  
- 마이크로연산(LSB 먼저):
  1) if \(B_0=1\) then `P <= P + A<<k` (현재 시프트 위치)  
  2) `B >>= 1`, `A <<= 1`, `cnt--`  
  3) `cnt=0`이면 종료
- FSM: `IDLE → RUN → DONE`.  
- VHDL 스케치:
```vhdl
-- 핵심 루프만 개략
if state=RUN and tick='1' then
  if B(0)='1' then P <= std_logic_vector(unsigned(P) + unsigned(A) sll k); end if;
  A <= A sll 1; B <= B srl 1; k <= k + 1; cnt <= cnt - 1;
  if cnt=0 then state<=DONE; end if;
end if;
```

### 3.3 예제 3 — **복원 나눗셈기**(Restoring Divider, unsigned)
- 아이디어: 상위 비트부터 나눗셈, 나머지를 비교·복원.  
- 데이터패스: `Dividend`, `Divisor`, `Quotient`, `Remainder`.  
- FSM: `LOAD → ITER(n회) → DONE`.  
- 각 반복: `R <- (R<<1) + next(Dividend)`, if `R >= Divisor` then `R -= Divisor; Qbit=1` else `Qbit=0`.

> 반복회로는 **타이밍 여유**가 크고 **전력 절감**에 유리. 대역폭이 필요하면 **파이프라인/병렬화**로 확장.

---

## 4) **ROM/PLA를 이용한 순서회로 설계**

FSM의 정의는 결국 **표**다. 이를 **저장**해서 구현하는 방식이 **ROM**이고, **부울 최소식**으로 구현하는 게 **PLA**다.

### 4.1 ROM 방식 (표 기반)
- **주소**: \([Q_{n-1..0}, X_{m-1..0}]\) (현재상태+입력)  
- **데이터**: \([Q^+_{n-1..0}, Y_{k-1..0}]\) (다음상태+출력)  
- **크기**: \(2^{n+m}\times(n+k)\) 비트 ROM.
- **예**(2상태 NRZI 디코더, 입력 1, 출력 1):  
  - \(n=1,m=1,k=1\) → **4×2 ROM**.  
  - 주소 00: \(q=0,r=0\to q^+=0,y=0\) → 데이터 `00`  
  - 주소 01: \(0,1\to 1,1\) → `11`  
  - 주소 10: \(1,0\to 0,1\) → `01`  
  - 주소 11: \(1,1\to 1,0\) → `10`

**장점**: 명세 변경이 용이, 복잡한 FSM도 균일 지연.  
**단점**: 작은 FSM에도 주소공간이 지배, 메모리 비용↑.

### 4.2 PLA 방식 (SOP 기반)
- **목표**: 각 \(D_i(Q,X), Y_j(Q,X)\)를 **최소 항의 합**으로.  
- **AND plane**: **곱항(Product term)** 생성, **OR plane**: 각 신호로 합.  
- **절차**:
  1) 상태할당(이진/원-핫).  
  2) 상태표에서 \(Q^+\)/\(Y\)에 대해 1인 칸 표시.  
  3) 불법/미정은 **don’t-care**로 묶어서 큰 그룹 형성.  
  4) 최소 SOP → **곱항 목록**과 **연결 매트릭스** 작성.

**예**(위 §2.2의 간소화된 Moore 하위 FSM, 3상태 이진 \(S_0=00,S_1=01,S_2=10\)):  
- 도출 예:
\[
\begin{aligned}
D_1 &= Q_1\overline{Q_0} \;\;+\;\; \overline{Q_1}Q_0 x\\
D_0 &= \overline{Q_1}\,\overline{Q_0}\,\overline{x}\\
Y   &= Q_1\overline{Q_0}
\end{aligned}
\]
- **곱항**: \(P_1=Q_1\overline{Q_0}\), \(P_2=\overline{Q_1}Q_0x\), \(P_3=\overline{Q_1}\overline{Q_0}\overline{x}\).  
- **OR 연결**: \(D_1 \gets P_1+P_2\), \(D_0 \gets P_3\), \(Y\gets P_1\).

**장점**: 항 수만큼 면적 사용 → 작은 FSM 유리, 빠른 조합로직.  
**단점**: 항 수가 많아지면 크기/지연↑, fan-in 제한 고려.

### 4.3 ROM vs PLA 선택 가이드
- **ROM**: 상태·입력 비트가 많고 **패턴이 산재**한 FSM, 추후 **마이크로코드**적 확장 예상.  
- **PLA**: **ISM don’t-care**가 많아 **큰 묶음**이 가능한 FSM, 소형/중형 FSM.  
- FPGA에서는 **LUT-RAM/분산 RAM**(ROM) vs **LUT 논리**(PLA). ASIC은 **메모리 컴파일러** vs **AOI/OAI** 게이트.

---

## 5) 통합 설계·검증 체크리스트

- [ ] 명세: 모델(Mealy/Moore), 오버랩, 프레임, 오류 처리 명확화.  
- [ ] 상태표 완전성(+ ISM은 ‘–’ 표시) & **Self-Start** 경로.  
- [ ] 최소화: 도달성 제거, 등가 병합(함의 차트).  
- [ ] 상태할당: 빈번 전이 해밍1, Moore 출력 비트 내장, 플랫폼 고려(원-핫/이진/그레이).  
- [ ] FF 입력식 유도: \(D/T/JK\) 공식, K-맵 최소화, don’t-care 활용.  
- [ ] Mealy 출력 **등록**. 비동기 리셋 **동기 해제**(복구/제거 시간).  
- [ ] 타이밍: \(t_{CQ}+t_{\text{comb}}+t_{SU}\le T\), 팬인 제한, 경로 균형(해저드↓).  
- [ ] TB: 정상/오류/경계 케이스, 랜덤 프레임, 커버리지(상태·전이·표기·ERR).  
- [ ] 물리: 클록 부하(원-핫 FF 수), 전력(토글률), 레이턴시/처리량 트레이드오프(반복회로).

---

## 6) 부록 — 수식·도구 빠른 참고

### 6.1 자주 쓰는 변환식
- **Parity 누적**: \(q^+=q\oplus x\) (짝/홀)  
- **그레이 변환(4b)**: \(G_3=B_3,\; G_2=B_3\oplus B_2,\; G_1=B_2\oplus B_1,\; G_0=B_1\oplus B_0\)  
- **업카운터(T-FF)**: \(T_0=1,\; T_i=\prod_{k=0}^{i-1} Q_k\)

### 6.2 ASCII 상태그래프 예(검출기, Mealy)
```
S0 --0/0--> S0  ; S0 --1/0--> S1
S1 --0/0--> S2  ; S1 --1/0--> S1
S2 --0/0--> S0  ; S2 --1/0--> S3
S3 --0/0--> S2  ; S3 --1/1--> S1
```

---

### 마무리
- **설계 과정**은 “명세→상태→간략화→할당→식 유도→검증→타이밍”의 **일관된 루틴**을 따른다.  
- **코드 변환기**는 직렬·프레임·패리티를 포함하면 **순서회로 교과서적 종합 예제**가 되고,  
- **반복회로**는 데이터패스/컨트롤 분해로 **마이크로아키텍처 감각**을 길러준다.  
- **ROM/PLA** 두 방식은 “표 그대로” vs “최소식”의 철학 차이—문제 성격과 플랫폼에 맞춰 선택하라.
