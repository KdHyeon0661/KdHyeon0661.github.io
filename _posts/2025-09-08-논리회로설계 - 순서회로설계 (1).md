---
layout: post
title: 논리회로설계 - 순서회로설계 (1)
date: 2025-09-08 23:25:23 +0900
category: 논리회로설계
---
# 설계**, **ROM/PLA 기반 순서회로 설계**

> 표기: 입력 \(x\), 출력 \(y\), 상태벡터 \(\mathbf{Q}=(Q_{n-1}\dots Q_0)\), 다음상태 \(\mathbf{Q}^+\), \(\overline{X}\)=NOT, \(\oplus\)=XOR.
> 모델: **동기식(클럭형)** Mealy/Moore, 에지 트리거 D FF 가정. **Mealy 출력은 실무상 등록(레지스터링) 권장**.

---

## 순서회로 설계 과정 **요약**

### 요구사항·명세 정리 (Design Input)

- **기능·I/O**: 입력/출력 의미, 폭·부호, 초기화/리셋.
- **모델**: **Mealy**(간선 출력, 즉시 반응) vs **Moore**(노드 출력, 글리치 내성).
- **타이밍 제약**: 클럭 주기 \(T\), \(t_{CQ}+t_{\text{comb}}+t_{SU}\le T\).
- **플랫폼 제약**: FPGA(원-핫/LUT), ASIC(이진/그레이·AOI/OAI), 전력/면적.
- **프로토콜**: 프레이밍(START/STOP), 오버랩(패턴검출), 오류 처리(Self-Start, Lockout 금지).
- **CDC**: 외부 비동기 신호는 **2단 동기화**.

### 상태 도출·그래프/표 (Behavior → Model)

1) **기억해야 할 정보**를 **상태**로 정의(접두/접미 원리, 카운터/타이머 포함).
2) **상태그래프**: Mealy는 간선 `입력/출력`, Moore는 노드에 `출력`.
3) **상태표**: 모든 `(현재,입력)`에 대해 `(다음,출력)` **완전 기입**. (불완전 명세는 `–`로 표시)

### 간략화 (Reduce)

- **Reachability**: 도달 불가 상태 제거.
- **최소화**: 동치(등가) 병합(함의 차트·분할 정련).
- **ISM**: don’t-care(`–`)를 활용해 호환/닫힌 커버로 병합, **Self-Start** 경로 확보.

### 상태할당 (Encode)

- **원-핫**(FPGA 고속, FF↑), **이진**(ASIC FF↓), **그레이**(해밍1 전이, 해저드↓).
- **가이드**: 빈번 전이를 **해밍 1**로, Moore 출력은 **상태코드 비트에 내장** 검토.

### FF 입력식 유도 (Logic)

\[
\boxed{
D_i=Q_i^+,\quad
T_i=Q_i\oplus Q_i^+,\quad
J_i=\overline{Q_i}Q_i^+,\;\;K_i=Q_i\overline{Q_i^+}
}
\]
(SR도 동일 형태, 단 금지 \(S=R=1\) 방지 확인)

### 구현·검증·타이밍 (Build & Verify)

- **RTL**: 합성 친화 VHDL/SystemVerilog, **Mealy 출력 등록**.
- **시뮬/포멀**: 단위 테스트, 커버리지, SVA/어설션(불법상태 진입 금지).
- **타이밍/물리**: 팬인 제한, 배선 균형, 클록트리(원-핫 FF 다수), 리셋 동기 해제.

---

## 설계 예제 — **코드 변환기(Code Converter)**

### 예제 A: **NRZI ↔ NRZ 디코더** (Mealy, 2상태)

- **규칙**: NRZI 레벨 \(r[k]\)가 **변화하면 1**, **유지하면 0**.
- **상태** \(q\): 직전 레벨(1비트).
- **방정식**: \(q^+=r,\;\; y=r\oplus q\) (Mealy).

**상태표**

| \(q\) | \(r\) | \(q^+\) | \(y\) |
|:--:|:--:|:--:|:--:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 0 |

**VHDL(출력 등록)**
```vhdl
library ieee; use ieee.std_logic_1164.all;
entity nrzi_dec is
  port (clk,rst: in std_logic; r: in std_logic; y: out std_logic);
end;
architecture rtl of nrzi_dec is
  signal q, y_i : std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then q<='0'; y_i<='0';
      else            y_i <= r xor q; q <= r;
      end if;
    end if;
  end process;
  y <= y_i;
end;
```

> **인코더(Moore)**: \(q^+=q\oplus d,\; y=q^+\). (상태=라인 레벨)

---

### 예제 B: **프레임 있는 직렬 BCD→그레이 변환기** (Moore)

**프레임 포맷**: `START=1` → `D3 D2 D1 D0`(MSB→LSB, BCD) → `PARITY(EVEN)` → `STOP=0`
**목표**: 프레임마다 **그레이 코드 4비트** 병렬 출력(`G[3:0]`)과 `VAL` 펄스(1클럭).

**기능 블록**
- **수신기/프레이머 FSM**: START/STOP·길이·패리티 체크, 비트 카운터.
- **시프트레지스터**: 4비트 수집, 패리티 누적 \(p^+=p\oplus x\).
- **조합 변환**: \(G_3=B_3\), \(G_2=B_3\oplus B_2\), \(G_1=B_2\oplus B_1\), \(G_0=B_1\oplus B_0\).

**상태계(원-핫)**
- \(S0\)=IDLE, \(S1\)=DATA3, \(S2\)=DATA2, \(S3\)=DATA1, \(S4\)=DATA0, \(S5\)=PAR, \(S6\)=STOP/OUT

**ASCII 상태그래프(요지)**
```
S0 --(tick & x=1)--> S1
S1 -(tick)-> S2  ; S2 -(tick)-> S3 ; S3 -(tick)-> S4 ; S4 -(tick)-> S5
S5 -(tick)-> S6 (ERR=~(parity==x))
S6 -(tick & x=0)-> S0 (VAL=1)  else (ERR=1, S0)
```

**VHDL 스켈레톤**
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity bcd2gray_serial is
  port (clk,rst: in std_logic; tick: in std_logic; x: in std_logic;
        G: out std_logic_vector(3 downto 0); VAL, ERR: out std_logic);
end;
architecture rtl of bcd2gray_serial is
  type S_t is (S0,S1,S2,S3,S4,S5,S6);
  signal s, ns: S_t := S0;
  signal R: std_logic_vector(3 downto 0) := (others=>'0');
  signal parity: std_logic := '0';
  signal G_i: std_logic_vector(3 downto 0); signal VAL_i, ERR_i: std_logic;

  function gray4(b: std_logic_vector(3 downto 0)) return std_logic_vector is
  begin return b(3) & (b(3) xor b(2)) & (b(2) xor b(1)) & (b(1) xor b(0)); end;

begin
  -- next-state & Moore outputs
  process(all) begin
    ns<=s; VAL_i<='0'; ERR_i<='0';
    case s is
      when S0 => if tick='1' and x='1' then ns<=S1; end if;
      when S1 => if tick='1' then ns<=S2; end if;
      when S2 => if tick='1' then ns<=S3; end if;
      when S3 => if tick='1' then ns<=S4; end if;
      when S4 => if tick='1' then ns<=S5; end if;
      when S5 => if tick='1' then ns<=S6; end if; -- parity checked in seq
      when S6 =>
        if tick='1' then
          if x='0' then VAL_i<='1'; else ERR_i<='1'; end if;
          ns<=S0;
        end if;
    end case;
  end process;

  -- sequential: shift/parity/gray latch
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then s<=S0; R<=(others=>'0'); parity<='0'; G_i<=(others=>'0');
      else
        s<=ns;
        if tick='1' then
          case s is
            when S1|S2|S3|S4 => R <= R(2 downto 0) & x; parity <= parity xor x;
            when S5 =>
              -- even parity: expect x == parity
              if x /= parity then ERR_i <= '1'; end if;
            when S6 =>
              G_i <= gray4(R); parity <= '0';
            when others => null;
          end case;
        end if;
      end if;
    end if;
  end process;

  G<=G_i; VAL<=VAL_i; ERR<=ERR_i;
end;
```

---

### 예제 C: **직렬 7-세그 드라이버**(Start/Len/Stop 프로토콜)

> 조합 변환기(BCD→7seg)는 익숙하므로 생략. **순서회로** 포인트는 프레이밍과 유효 펄스(`STB`) 타이밍.

**프레임**: `START=1` → `4b 데이터` → `STOP=0`
**출력**: `SEG[6:0]`(등록), `STB`(1클럭 펄스)

**상태표(요지, Moore)**

| 상태 | tick & x | 다음 | 출력 |
|---|---|---|---|
| IDLE | 1 | D3 | STB=0 |
| D3 | * | D2 | STB=0 |
| D2 | * | D1 | STB=0 |
| D1 | * | D0 | STB=0 |
| D0 | * | STOP | STB=0 |
| STOP & x=0 | 1 | IDLE | **STB=1**; SEG<=f(BCD) |

---

## 설계**

반복회로는 **작은 연산기**를 여러 클럭에 걸쳐 돌린다. 컨트롤러(FSM)+데이터패스(레지스터/ALU)의 **마이크로연산**이 핵심.

### 직렬 가산기 (Serial Adder)

- **마이크로연산**
  \[
  s_i = a_i \oplus b_i \oplus C,\quad
  C^+ = a_ib_i + (a_i\oplus b_i)C
  \]
- **데이터패스**: 입력 시프트레지스터 2개, 캐리 FF \(C\), 출력 시프트레지스터.
- **컨트롤**: `IDLE → RUN(n회) → DONE`.

**컨트롤러 상태전이**

| 상태 | 조건 | 다음 | 제어 |
|---|---|---|---|
| IDLE | start | RUN | load, cnt←n |
| RUN | cnt>0 | RUN | shift, add, cnt-- |
| RUN | cnt=0 | DONE | — |
| DONE | ack | IDLE | clear |

### 시프트-가산 곱셈기 (Shift-Add Multiplier, unsigned)

- **데이터패스**: `Areg`(피승수), `Breg`(승수), `Preg`(누산 2n), `cnt`, 쉬프터.
- **마이크로연산(LSB 먼저)**
  1) if \(B_0=1\): `P <= P + A<<k`
  2) `A <<= 1; B >>= 1; k++ ; cnt--`
  3) `cnt==0` → DONE

**SystemVerilog 스켈레톤(핵심 루프)**
```systemverilog
always_ff @(posedge clk) if (run) begin
  if (B[0]) P <= P + (A << k);
  A <= A << 1; B <= B >> 1; k <= k + 1; cnt <= cnt - 1;
  if (cnt==0) state <= DONE;
end
```

### 복원 나눗셈기 (Restoring Divider, unsigned)

- **알고리즘**(MSB→LSB):
  \[
  R \leftarrow (R\ll 1) + \text{next}(D);\quad
  \text{if }R\ge V\text{ then }R\leftarrow R-V,\;Q\_i\leftarrow 1\text{ else }Q\_i\leftarrow 0
  \]
- **상태**: `LOAD → ITER(n회) → DONE`.
- **장점**: 면적↓, **단점**: 레이턴시 \(n\)클럭.

### 이터러티브 컨트롤러/데이터패스 분리 예 (GCD: 유클리드)

**마이크로연산**
\[
\begin{aligned}
&\text{while }B\ne 0:\; (A,B)\leftarrow (B, A\bmod B) \\
&\text{정수 나눗셈은 반복 뺄셈/시프트-뺄셈 등으로 구현}
\end{aligned}
\]

**컨트롤러 상태**: `IDLE → CMP → SUB/SHIFT → SWAP → CMP → … → DONE`
**데이터패스**: `A,B` 레지스터, 비교기, 감산기, 시프터.

---

## **ROM/PLA 기반 순서회로 설계**

FSM은 본질적으로 **표**다. 이를 **메모리**로 구현하면 **ROM 방식**, **최소식**으로 구현하면 **PLA 방식**.

### ROM 방식 (표 저장)

- **주소**: \([Q_{n-1..0}, X_{m-1..0}]\) (현재상태+입력)
- **데이터**: \([Q^+_{n-1..0}, Y_{k-1..0}]\) (다음상태+출력)
- **크기**: \(2^{n+m}\times(n+k)\) 비트 ROM.

**예(2상태 NRZI 디코더)**: \(n=1,m=1,k=1\) → **4×2 ROM**

| 주소 \([q\,r]\) | 데이터 \([q^+\,y]\) | 의미 |
|---:|:---:|---|
| 00 | 00 | 0,0 → 0,0 |
| 01 | 11 | 0,1 → 1,1 |
| 10 | 01 | 1,0 → 0,1 |
| 11 | 10 | 1,1 → 1,0 |

**VHDL ROM 구현(분산 RAM/케이스)**
```vhdl
type rom_t is array (0 to 3) of std_logic_vector(1 downto 0);
constant TBL: rom_t := ( "00", "11", "01", "10" );
signal addr: unsigned(1 downto 0); signal dout: std_logic_vector(1 downto 0);
addr <= unsigned(q & r);
dout <= TBL(to_integer(addr));
q_next <= dout(1); y <= dout(0);
```

**장단점**
- **장점**: 설계 변경 용이, 복잡 FSM도 균일 지연.
- **단점**: 작은 FSM에도 주소공간 지배 → 메모리 비용↑.

### PLA 방식 (SOP 최소식)

- 각 \(D_i(Q,X), Y_j(Q,X)\)를 **최소 항의 합**으로.
- **AND plane**: 곱항 생성, **OR plane**: 신호별 합.
- **ISM don’t-care**를 최대 활용해 큰 그룹 형성.

**예(3상태 Moore, 이진 \(S_0=00,S_1=01,S_2=10\))**
상태표에서 도출(예시):
\[
\begin{aligned}
D_1 &= Q_1\overline{Q_0} \;+\; \overline{Q_1}Q_0 x\\
D_0 &= \overline{Q_1}\,\overline{Q_0}\,\overline{x}\\
Y   &= Q_1\overline{Q_0}
\end{aligned}
\]

- **곱항**: \(P_1=Q_1\overline{Q_0},\ P_2=\overline{Q_1}Q_0x,\ P_3=\overline{Q_1}\overline{Q_0}\overline{x}\)
- **OR 연결**: \(D_1\gets P_1+P_2,\; D_0\gets P_3,\; Y\gets P_1\)

**장단점**
- **장점**: 항 수만큼 면적 사용 → 소/중형 FSM 효율적, 빠른 조합.
- **단점**: 항 수↑ 시 크기/지연↑, fan-in 제약 관리 필요.

### ROM vs PLA 선택 가이드

| 상황 | ROM 권장 | PLA 권장 |
|---|---|---|
| 상태·입력 비트가 큼 | ✔ | △ |
| 패턴 산재, 규칙성 적음 | ✔ | △ |
| ISM don’t-care 많음 | △ | ✔ |
| 향후 마이크로코드 확장 | ✔ | △ |
| 지연 균일성 중요 | ✔ | △ |
| 면적 극소화(소형 FSM) | △ | ✔ |

---

## 통합 설계·검증 체크리스트

- [ ] 명세: Mealy/Moore, 프레임/오버랩, 오류 처리(Self-Start/락아웃 금지).
- [ ] 상태표 **완전성**(+ ISM은 ‘–’ 명시) & **Self-Start** 경로.
- [ ] 최소화: 도달성 제거, 등가/호환 병합(함의 차트).
- [ ] 상태할당: 빈번 전이 해밍1, Moore 출력 비트 내장, 플랫폼 고려.
- [ ] FF 입력식: \(D/T/JK\) 공식, K-맵 최소화, don’t-care 적극 활용.
- [ ] Mealy 출력 **등록**, 비동기 리셋 **동기 해제**(복구/제거 시간).
- [ ] 타이밍: \(t_{CQ}+t_{\text{comb}}+t_{SU}\le T\), 팬인 제한, 경로 균형(해저드↓).
- [ ] TB/포멀: 정상/오류/경계·랜덤, 커버리지(상태/전이/ERR), 어설션.
- [ ] 물리: 클록 부하(원-핫), 전력(토글률), 반복회로 레이턴시/처리량 트레이드오프.

---

## 부록 — 수식·표·도구 빠른 참고

### 자주 쓰는 변환식

- **Parity 누적**: \(p^+=p\oplus x\)
- **그레이(4b)**: \(G_3=B_3,\; G_2=B_3\oplus B_2,\; G_1=B_2\oplus B_1,\; G_0=B_1\oplus B_0\)
- **업카운터(T-FF)**: \(T_0=1,\; T_i=\prod_{k=0}^{i-1} Q_k\)

### ASCII 상태그래프(패턴검출 Mealy)

```
S0 --0/0--> S0  ; S0 --1/0--> S1
S1 --0/0--> S2  ; S1 --1/0--> S1
S2 --0/0--> S0  ; S2 --1/0--> S3
S3 --0/0--> S2  ; S3 --1/1--> S1
```

### 타이밍 불등식

\[
t_{CQ} + t_{\text{comb}} + t_{SU} \le T,\qquad t_{\text{hold}} \le t_{CD}
\]

---

### 맺음말

- **설계 과정**은 “명세→상태→간략화→할당→식 유도→검증→타이밍”의 **일관 루틴**으로 체계화된다.
- **코드 변환기**는 프레이밍/패리티/타이밍을 포함하면 순서회로의 전 과정을 훈련시키는 **교과서적 예제**다.
- **반복회로**는 데이터패스·컨트롤 분리 감각을 키우며 성능·면적 트레이드오프를 체험하게 해준다.
- **ROM/PLA**는 “표 그대로” vs “최소식” 철학—문제 성격·플랫폼·확장성에 맞춰 선택하라.
