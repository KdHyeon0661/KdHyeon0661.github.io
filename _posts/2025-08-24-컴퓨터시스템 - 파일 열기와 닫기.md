---
layout: post
title: 컴퓨터시스템 - 파일 열기와 닫기
date: 2025-08-24 22:20:23 +0900
category: 컴퓨터시스템
---
# 파일 **열기와 닫기**

## 큰 그림 — “열기 → 사용 → 닫기”의 계약

- **열기(open)**: 경로 해석 + 권한 검사 + 커널의 **open file description(열린 파일 설명자)** 생성 → **FD(정수)** 반환
  (※ 한 개의 open file description을 여러 FD가 **공유**할 수 있음: `dup`, `fork` 등)
- **사용**: `read/write/pread/pwrite/lseek/fcntl/ioctl/...` 을 **FD**로 호출
- **닫기(close)**: **FD 참조 카운트 감소**. 마지막 참조가 닫히면 커널이 **캐시/락/리소스 정리**
  (지연된 I/O 오류가 **`close` 반환값**으로 보고될 수 있음)

```text
path → open/openat → [open file description] ←(FD)→ read/write/... → close
```

---

## 파일 열기 — 시스템콜과 변종

### `open(2)` 기본

```c
#include <fcntl.h>

int open(const char *path, int flags, ... /* mode_t mode if O_CREAT */);
```
- 실패 시 `-1`과 `errno` 설정. `mode`는 **`O_CREAT`가 있을 때만** 의미.

### `openat(2)` — 디렉터리 FD 기준 경로 해석

```c
#include <fcntl.h>

int openat(int dirfd, const char *path, int flags, mode_t mode);
/* dirfd=AT_FDCWD 이면 CWD 기준. 보안/샌드박스/서버에서 TOCTTOU 방지의 핵심 */
```

### `creat(2)`

- 역사적 API.
  `creat(path, mode)` ≒ `open(path, O_WRONLY|O_CREAT|O_TRUNC, mode)`.

### 임시 파일

- **권장**: `mkstemp()` — 경로 생성과 **배타적 open**을 결합.
- **이름 없는 임시 파일**(파일시스템 지원 필요): `open(path_to_dir, O_TMPFILE|O_RDWR, 0600)`
  → 디렉터리에 **연결되지 않은(unnamed)** 파일 생성. 필요 시 `linkat()`로 이름 부여.

```c
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

int mk_tmp(char tmpl[]) {          // tmpl 예: "/tmp/app.XXXXXX"
    int fd = mkstemp(tmpl);        // 파일 생성 + O_EXCL 보장
    if (fd < 0) return -1;
    // 필요하다면 즉시 unlink하여 이름 제거(익명화)
    // unlink(tmpl);
    return fd;
}
```

> 최신 리눅스에서는 **`openat` + `O_NOFOLLOW` + 디렉터리 FD** 조합으로 경로 레이스를 견고하게 다룬다(§4).

---

## `flags` / `mode` 총정리 (핵심 플래그 설명)

### 접근/생성/배치 플래그

| 플래그 | 의미/용도 |
|---|---|
| `O_RDONLY` / `O_WRONLY` / `O_RDWR` | 접근 모드(필수 중 하나) |
| `O_CREAT` | 없으면 생성 (`mode` 필요; `umask` 적용) |
| `O_EXCL` | `O_CREAT`와 함께 **이전에 존재하면 실패**(경쟁 안전 생성) |
| `O_TRUNC` | 열 때 길이 0으로(쓰기 가능한 모드일 때) |
| `O_APPEND` | 매 쓰기를 **끝에** 추가(오프셋 경쟁 방지) |
| `O_CLOEXEC` | **exec 시 자동 닫힘**(FD 유출 방지) |
| `O_NOFOLLOW` | 마지막 경로 요소가 심링크면 실패(TOCTTOU/권한 상승 방지) |
| `O_DIRECTORY` | 디렉터리만 열기(아니면 실패) |
| `O_NONBLOCK` | 비차단 I/O(주로 파이프/소켓/터미널) |
| `O_SYNC` / `O_DSYNC` | 동기식 쓰기(데이터+메타 / 데이터 중심) |
| `O_DIRECT` | 페이지 캐시 우회(정렬 요건; DB/스토리지용) |
| `O_PATH` | **경로 핸들만** 열기(데이터 I/O 불가, 메타 연산용) |

### `mode_t` (퍼미션)

- `O_CREAT` 시에만 의미.
- **`umask`가 빼기(subtract) 적용**됨(§3).
- 8진수 표기: `0644`(rw-r--r--), `0600`(rw-------), `0755`(rwxr-xr-x), …

### 권장 조합(실전)

- **새 파일 배타적 생성**: `O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC`, `mode=0600` (민감 데이터) / `0644`(일반)
- **로그 append 전용**: `O_WRONLY|O_APPEND|O_CLOEXEC`
- **디렉터리 핸들**: `O_RDONLY|O_DIRECTORY|O_CLOEXEC`
- **안전한 읽기 전용(심링크 차단)**: `openat(dfd, name, O_RDONLY|O_NOFOLLOW|O_CLOEXEC, 0)`

---

## 권한과 `umask`

- `umask`는 **프로세스 전역** 비트마스크. 생성 퍼미션에서 **해당 비트를 제거**.
- 공식적으로:
$$
\text{final\_mode} \;=\; \text{requested\_mode} \;\&\; \sim\text{umask}
$$
- 민감 파일은 **처음부터 최소 권한**(예 `0600`)으로 열고, 필요하면 나중에 `fchmod`로 넓히는 것이 안전.

```c
#include <sys/stat.h>

mode_t old = umask(077);                      // 잠시 매우 보수적으로
int fd = open("secret", O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 0666);
umask(old);
```

> **반패턴**: `access()`로 미리 검사 → 그 사이 경로가 바뀌어 **TOCTTOU**. 즉시 `open()` 시도 후 에러로 판단하라.

---

## 방지 레시피

1) 먼저 **디렉터리 FD**를 확보
2) **항상** `openat(dfd, name, O_NOFOLLOW|...)`로 하위 항목 접근
3) 유형/권한은 **`fstatat`**(또는 `fstat`)로 **열린 핸들 기준** 재검증
4) 갱신은 **임시 → `fsync` → `rename`**(동일 FS에서 원자적)로 수행

```c
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

int open_secure_child(const char *dir, const char *name) {
    int dfd = open(dir, O_RDONLY|O_DIRECTORY|O_CLOEXEC);
    if (dfd < 0) return -1;

    int fd = openat(dfd, name, O_RDONLY|O_NOFOLLOW|O_CLOEXEC);
    if (fd < 0) { close(dfd); return -1; }

    struct stat st;
    if (fstat(fd, &st) < 0) { close(fd); close(dfd); return -1; }
    if (!S_ISREG(st.st_mode)) { close(fd); close(dfd); errno = EISDIR; return -1; }

    close(dfd);
    return fd;
}
```

> 더 강력한 해법으로는 최근 리눅스의 **`openat2(2)`**(경로 해석 정책 지정)가 있다. 사용 가능 시 `RESOLVE_NO_SYMLINKS`, `RESOLVE_BENEATH` 등으로 **심링크/루프/상위탈출**을 커널에서 차단한다(플랫폼 지원 여부 확인).

---

## FD 수명, 복제, 상속 — `dup/dup2/dup3` & `O_CLOEXEC`

### 복제

```c
#include <fcntl.h>

int nfd  = dup(fd);                         // 가장 낮은 미사용 FD
int nfd2 = dup2(fd, 7);                     // 7번 FD로 강제(기존 7은 닫힘)
int nfd3 = dup3(fd, 7, O_CLOEXEC);          // + CLOEXEC 함께
```
- **리디렉션**: `dup2(fd, STDOUT_FILENO)` 등
- `fcntl(fd, F_SETFD, FD_CLOEXEC)` 로 사후 설정 가능하나, **경쟁 위험**(다중 스레드에서 exec 사이 창) → **생성 시 `O_CLOEXEC` 권장**.

### FD 한도

- `EMFILE`(프로세스 한도), `ENFILE`(시스템 한도).
  → **“비상 FD” 전략**: 시작 시 더미 FD 하나 열어두었다가 EMFILE 시 닫고 로그/정리 후 재시도.

```c
#include <sys/resource.h>

struct rlimit rl; getrlimit(RLIMIT_NOFILE, &rl);
```

---

## `close(2)` — 단순해 보이지만 마지막 관문

```c
#include <unistd.h>

int r = close(fd);     // 0: 성공, -1: 오류
```

- **`EINTR`**: 신호로 중단될 수 있음. **POSIX 상 FD 상태는 불특정** →
  실무적으로 **성공으로 간주**하고 재시도하지 않는 편이 안전(재시도 시 **다른 용도로 재사용된 새 FD를 닫는** 위험).
- **지연 오류 전파**: 네트워크/NFS/저널링 FS에서 **쓰기 실패가 `close` 시 보고**될 수 있다.
  → **반드시 `close` 반환값을 확인**하라.
- **영속성**: `close`만으로 **디스크 내구성 보장 X**. 필요한 경우 **`fsync`/`fdatasync`**를 병행(§8).

### 잠금과 `close`

- `fcntl(F_SETLK)` **레코드 잠금**: **프로세스 단위** — 같은 파일에 대한 **프로세스의 모든 FD**가 영향을 받는다(특정 FD만 해제 불가).
- `flock` **어드바이저리 잠금**: **open file description 단위** — 그 설명자에 연결된 모든 FD가 닫혀야 잠금 해제.

### 소켓/파이프에서

- `SO_LINGER` 설정 시 `close`가 **블록**될 수 있음(전송 완료 대기).
- 반쪽 종료는 `shutdown(fd, SHUT_WR)` 사용.

```c
#include <errno.h>

int close_safe(int fd){
    if (fd < 0) return 0;
    int r = close(fd);
    if (r == -1 && errno == EINTR) return 0; // 실무상 성공 취급
    return r;
}
```

---

## 데이터 영속성 — `fsync`/`fdatasync` & 원자적 교체

### 권장 패턴(전원 장애/크래시 안전)

1) **임시 파일**에 전체 쓰기
2) `fsync(tmpfd)` (데이터를 **디스크로 내보내기**)
3) **같은 파일시스템**에서 `rename(tmp, dst)` (**원자적 교체**)
4) **부모 디렉터리** `fsync(dirfd)` (디렉터리 엔트리까지 보존)

```c
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

int atomic_replace(const char *dir, const char *tmp, const char *dst,
                   const void *data, size_t n)
{
    int dfd = open(dir, O_RDONLY|O_DIRECTORY|O_CLOEXEC);
    if (dfd < 0) return -1;

    int tfd = openat(dfd, tmp, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 0644);
    if (tfd < 0) { close(dfd); return -1; }

    if (write(tfd, data, n) != (ssize_t)n) { close(tfd); close(dfd); return -1; }
    if (fsync(tfd) < 0) { close(tfd); close(dfd); return -1; }
    if (close_safe(tfd) < 0) { close(dfd); return -1; }

    if (renameat(dfd, tmp, dfd, dst) < 0) { close(dfd); return -1; }
    if (fsync(dfd) < 0) { close(dfd); return -1; }   // 디렉터리 안정화

    return close_safe(dfd);
}
```

### `O_SYNC/O_DSYNC` vs `fsync`

- `O_SYNC`: 각 `write`가 데이터+메타데이터 **안정화까지 대기**(처리량↓, 지연↑)
- `O_DSYNC`: 데이터 중심 동기화(일부 메타는 지연 가능)
- 보통은 **배치 쓰기 → `fsync`** 가 효율적(로그·저널 설계 제외)

---

## 임시 파일과 삭제 시맨틱

- 열린 파일을 **`unlink`** 해도 FD를 통해 계속 접근 가능. **마지막 FD가 닫히면** 실제 제거.
- Linux **`O_TMPFILE`**: 생성 시부터 **무명**. 필요한 시점에 `linkat`로 이름 부여.
  경합/청소 문제를 크게 줄인다(파일시스템 지원 필요).

```c
int dfd = open("/tmp", O_TMPFILE|O_RDWR|O_CLOEXEC, 0600); // /tmp 안에서 무명 생성
// … 쓰기/작업 …
linkat(dfd, "", AT_FDCWD, "/tmp/final", AT_EMPTY_PATH);   // 이름 부여(권한 체크됨)
```

---

## `stdio`(fopen/fclose)와 UNIX I/O 혼용

- `FILE*`는 내부 버퍼를 가진 **고수준 인터페이스**.
- **같은 FD**를 `FILE*`와 `write(2)`로 **섞어 쓰면** 순서/버퍼가 꼬일 수 있다.
  → 한쪽만 쓰거나, **`fflush(fp); fsync(fileno(fp));`** 로 경계를 명시.
- 기존 FD를 `FILE*`로 감싸기: `fdopen(fd, "r+")`.

---

## 에러와 방어적 프로그래밍(요약 표)

| 상황 | 전형적 `errno` | 대처 |
|---|---|---|
| 경로 없음/부모 없음 | `ENOENT` | 상위 디렉터리 존재/권한 확인 |
| 이미 존재 (`O_EXCL`) | `EEXIST` | 다른 이름 재시도/오류 반환 |
| 권한/정책 | `EACCES`/`EPERM` | 퍼미션/SELinux/AppArmor 등 검토 |
| 디렉터리가 아님/디렉터리 문제 | `ENOTDIR`/`EISDIR` | 경로 구성 재검증 |
| 심링크 루프/너무 김 | `ELOOP`/`ENAMETOOLONG` | 경로 정규화/정책 변경 |
| FD 한도 | `EMFILE`/`ENFILE` | 비상 FD 해제 후 처리 |
| `close` 지연 오류 | `EIO` 등 | 로그/롤백/복구 절차 |

> **로그 즉시화**: 실패 직후 `errno`를 보존하고 메시지를 남겨라(`perror`, `strerror_r`).

---

## 디렉터리 열기/닫기 & `*at` 일괄 작업

- 디렉터리 FD를 잡아두고 그 하위는 **모두 `openat/fstatat/unlinkat/renameat`** 로 처리하면
  CWD 변조·경로 레이스를 크게 줄일 수 있다.
- POSIX 디렉터리 I/O:
```c
#include <dirent.h>

DIR *d = opendir("/var/log");
struct dirent *e;
while ((e = readdir(d))) { /* e->d_name */ }
int dfd = dirfd(d);        // 디렉터리 FD 취득
closedir(d);
```

---

## 안전한 코드 패턴 모음

### 배타적 생성(심링크·경쟁 안전)

```c
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>

int open_new_secure(const char *dir, const char *name, mode_t mode) {
    int dfd = open(dir, O_RDONLY | O_DIRECTORY | O_CLOEXEC);
    if (dfd < 0) return -1;

    int fd = openat(dfd, name,
        O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC | O_NOFOLLOW, mode);
    int e = errno;
    close(dfd);
    if (fd < 0) { errno = e; return -1; }
    return fd;
}
```

### 로그 파일 열고 append(원자적 오프셋 갱신)

```c
int open_log(const char *path) {
    return open(path, O_WRONLY | O_APPEND | O_CLOEXEC | O_CREAT, 0644);
}
```

### 표준 출력 리디렉션

```c
int fd = open("out.log", O_WRONLY|O_CREAT|O_APPEND|O_CLOEXEC, 0644);
dup2(fd, STDOUT_FILENO);   // stdout → 파일
close_safe(fd);
```

### 대응

```c
// 시작 시 비상 FD를 열어둔다(예: /dev/null)
// 오류 발생 시 close(backup_fd) → 로깅용 파일을 열고 → 정리 후 backup_fd 재확보
```

### `O_PATH`로 경로 핸들 얻고 메타 연산

```c
int pfd = open("/var/data/item", O_PATH|O_CLOEXEC);
struct stat st; fstat(pfd, &st);        // 메타 정보
// 데이터 I/O는 불가하지만, 하위 openat 등에 활용 가능
```

---

## 대량 FD 닫기

- 리눅스: `close_range(3, ~0U, 0)` — 3번 이상 모든 FD 닫기(로그인 셸/샌드박스 초기화에 유용)
- BSD: `closefrom(3)`
- 이식성: `/proc/self/fd` 열거 후 반복 `close`

---

## 체크리스트

- [ ] 생성 시 **`O_CLOEXEC`** 사용(FD 유출 방지)
- [ ] 새 파일은 **`O_CREAT|O_EXCL`** 또는 **`mkstemp`**, 필요 시 **`openat` + `O_NOFOLLOW`**
- [ ] **디렉터리 FD** 기반 `*at` 계열로 **TOCTTOU** 최소화
- [ ] 쓰기 후 내구성 요구 시 **`fsync(file)` + `rename` + `fsync(dir)`**
- [ ] `close` **반환값 확인**(지연 오류), `EINTR`는 **성공 취급**
- [ ] `O_APPEND`로 다중 작성자 오프셋 경쟁 방지(레코드 원자성은 별도 설계)
- [ ] `stdio`와 UNIX I/O **혼용 금지**(혼용 시 `fflush`/`fsync` 철저)
- [ ] 권한은 **최소 권한으로 생성**하고 `umask` 고려

---

## 한 줄 결론

**열기**는 플래그·권한·경로 안전(특히 **`openat` + `O_NOFOLLOW`**)이 핵심이고,
**닫기**는 단순해 보여도 **내구성 보장과 지연 오류 전파**의 마지막 관문이다.
이 문서의 **패턴/래퍼/체크리스트**를 그대로 적용하면, 서버·도구·데몬에서
**경쟁 안전·권한 안전·내구성 보장**을 동시에 달성할 수 있다.
