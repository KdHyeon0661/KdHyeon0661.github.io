---
layout: post
title: Svelte - 개발 환경 준비
date: 2025-09-28 15:25:23 +0900
category: Svelte
---
# 개발 환경 준비 — “Node → 패키지 관리자 → 템플릿 → TS → Lint/Format → Alias → 디버깅/확장”

> 이 장은 **Svelte/SvelteKit** 개발을 위한 바닥부터의 셋업 가이드다.
> Node 설치 전략, NPM/PNPM 선택과 워크스페이스, Vite 템플릿/프로젝트 생성, TypeScript **strict** 세팅, ESLint/Prettier 일원화, **import alias/절대경로**, 그리고 **디버깅/Devtools/VS Code** 확장까지 “팀 합의안을 그대로 복붙”해도 돌아가도록 예제 중심으로 정리한다.

---

## 전체 로드맵(요약)

1) **Node** 설치: nvm/Volta → LTS 고정 + `.nvmrc`/`package.json#engines`
2) **PNPM/NPM**: 멀티 패키지(선택) 대비 PNPM 권장, `corepack` 활성화
3) **프로젝트 생성**: Vite + `@sveltejs/kit` 템플릿 / Svelte(standalone) 템플릿 선택
4) **TypeScript**: `strict`/`noUncheckedIndexedAccess`/`paths`/`vite-tsconfig-paths`
5) **ESLint/Prettier**: 충돌 제거, `@sveltejs/eslint-plugin-svelte` + `eslint-config-prettier`
6) **Alias/절대경로**: `tsconfig.json` + `vite.config.ts#resolve.alias` + `src/lib`
7) **디버깅**: VS Code `launch.json`(Vite dev attach), 브라우저 devtools, **Svelte Inspector**
8) **VS Code 확장**: Svelte for VS Code, ESLint, Prettier, Error Lens, Tailwind 등
9) **실전 스크립트**: format/lint/typecheck/test/build/dev 모두 `package.json` 한 곳에

---

## Node 설치 — “버전 고정이 곧 재현성”

### nvm(또는 Volta)로 LTS 고정

- 팀 재현성을 위해 **LTS(예: `v20.x`) 고정**을 권장한다.
- nvm 예시:

```bash
# Windows: nvm-windows, macOS/Linux: nvm

nvm install --lts
nvm use --lts
node -v    # v20.x.y (예시)
corepack enable  # npm/pnpm/yarn shim 활성화
```

- 프로젝트 루트에 `.nvmrc`를 두면 IDE/CI가 자동 인식:

```bash
# .nvmrc

v20
```

- `package.json`에 `engines`로 경고를 띄우면 실수 방지:

```json
{
  "engines": {
    "node": ">=20 <21",
    "pnpm": ">=9"
  }
}
```

> **팁**: Volta를 쓰면 개발자 PC별 자동 버전 고정이 편하다. (필수는 아님)

---

## 패키지 관리자 — “NPM vs PNPM vs Yarn, 우리는 PNPM”

### 왜 PNPM?

- **하드링크** 기반 저장소로 디스크 절감, 설치 속도 유리.
- 워크스페이스(**모노레포**) 지원이 강력하고 간단.
- Node 20 기준 안정적이며 CI 캐시 전략도 확립하기 쉽다.

```bash
# corepack으로 pnpm 활성화 후

pnpm -v
pnpm config set auto-install-peers true
pnpm setup   # Windows에선 PATH 적용 필요
```

> **NPM을 선호한다면** 모든 예제의 `pnpm`을 `npm run`/`npm create`/`npx`로 치환 가능.

---

## 템플릿/프로젝트 생성 — “SvelteKit(추천) 또는 Svelte(단일 컴포넌트 앱)”

### SvelteKit 기본 템플릿 생성

```bash
# 최신 스캐폴딩

pnpm create svelte@latest my-app
# ↳ Skeleton project?   → Yes(또는 No)
# ↳ TypeScript?         → Yes (strict로 나중에 강화)
# ↳ ESLint/Prettier?    → Yes (동시에 구성)
# ↳ Playwright/Vitest?  → 필요에 따라 Yes

cd my-app
pnpm install
pnpm dev
```

생성 후 기본 구조(요약):

```
my-app/
  src/
    lib/               # 공용 라이브러리(컴포넌트/유틸)
    routes/
      +layout.svelte
      +page.svelte
  static/
  svelte.config.js|ts
  vite.config.ts
  tsconfig.json
  package.json
```

### Svelte(standalone) + Vite

- 서버 라우팅 없이 **순수 SPA**를 원할 때:

```bash
pnpm create vite@latest my-spa -- --template svelte-ts
cd my-spa
pnpm i
pnpm dev
```

---

## TypeScript 기본 세팅 — “strict가 미래를 지킨다”

> 템플릿이 만들어주는 TS 설정을 **한 단계 더 강하게** 다듬는다.

### `tsconfig.json` 권장값

```json
{
  "extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "useUnknownInCatchVariables": true,
    "noImplicitOverride": true,
    "noFallthroughCasesInSwitch": true,
    "importsNotUsedAsValues": "error",
    "jsx": "preserve",
    "types": ["vite/client", "@sveltejs/kit"],
    "baseUrl": ".",
    "paths": {
      "$lib/*": ["src/lib/*"],
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*.d.ts", "src/**/*.ts", "src/**/*.svelte"],
  "exclude": ["node_modules", "dist", ".svelte-kit"]
}
```

- **핵심 포인트**
  - `strict`: 전반적 엄격 모드
  - `noUncheckedIndexedAccess`: `arr[i]`를 `T | undefined`로 안전 처리
  - `paths`: **절대경로/alias** 설정(아래 1.6과 연동)
  - SvelteKit은 `.svelte-kit`를 확장하는 구조가 일반적

### 타입 체크 스크립트

```json
{
  "scripts": {
    "typecheck": "svelte-kit sync && tsc --noEmit"
  }
}
```

```bash
pnpm typecheck
```

> CI에서 `build` 전 `typecheck`를 강제하면 회귀를 줄인다.

---

## ESLint/Prettier — “충돌 없이 하나의 진실원천(Single Source of Truth)”

### 의존성 설치(권장 세트)

```bash
pnpm add -D eslint @eslint/js typescript-eslint \
  prettier eslint-config-prettier \
  @sveltejs/eslint-plugin-svelte \
  eslint-plugin-import eslint-plugin-unused-imports
```

- `eslint-config-prettier`: ESLint의 포매팅 룰을 꺼서 **Prettier와 충돌 제거**
- `eslint-plugin-import`: import 순서/정렬/미사용 점검
- `eslint-plugin-unused-imports`: 미사용 변수/임포트를 정리

### ESLint 설정(`eslint.config.js` 예시, Flat Config)

```js
// eslint.config.js
import js from '@eslint/js';
import tseslint from 'typescript-eslint';
import svelte from '@sveltejs/eslint-plugin-svelte';
import globals from 'globals';

export default [
  { ignores: ['node_modules', 'dist', '.svelte-kit', 'coverage'] },

  // JS/TS 공통
  {
    files: ['**/*.{js,ts}'],
    languageOptions: {
      parserOptions: { ecmaVersion: 'latest', sourceType: 'module' },
      globals: { ...globals.browser, ...globals.node }
    },
    rules: {
      ...js.configs.recommended.rules,
      'no-console': ['warn', { allow: ['warn', 'error'] }],
      'no-debugger': 'warn'
    }
  },

  // TS 강화
  ...tseslint.configs.recommendedTypeChecked.map((c) => ({
    ...c,
    files: ['**/*.{ts}'],
    languageOptions: {
      ...c.languageOptions,
      parserOptions: {
        ...c.languageOptions?.parserOptions,
        project: ['./tsconfig.json']
      }
    }
  })),

  // Svelte
  ...svelte.configs['flat/recommended'],
  {
    files: ['**/*.svelte'],
    languageOptions: {
      parserOptions: {
        parser: tseslint.parser,
        extraFileExtensions: ['.svelte'],
        project: ['./tsconfig.json']
      }
    },
    rules: {
      'svelte/no-at-html-tags': 'warn',
      'svelte/no-target-blank': 'warn'
    }
  },

  // import/unused 정리
  {
    files: ['**/*.{ts,js,svelte}'],
    plugins: {
      'unused-imports': await import('eslint-plugin-unused-imports'),
      import: await import('eslint-plugin-import')
    },
    rules: {
      'unused-imports/no-unused-imports': 'warn',
      'unused-imports/no-unused-vars': [
        'warn',
        { vars: 'all', varsIgnorePattern: '^_', args: 'after-used', argsIgnorePattern: '^_' }
      ],
      'import/order': [
        'warn',
        {
          groups: [['builtin', 'external'], 'internal', ['parent', 'sibling', 'index']],
          'newlines-between': 'always',
          alphabetize: { order: 'asc', caseInsensitive: true }
        }
      ]
    }
  }
];
```

### Prettier 설정

```bash
pnpm add -D prettier prettier-plugin-svelte
```

```json
{
  "name": "my-app",
  "prettier": {
    "semi": true,
    "singleQuote": true,
    "printWidth": 100,
    "trailingComma": "none",
    "plugins": ["prettier-plugin-svelte"],
    "overrides": [
      { "files": "*.svelte", "options": { "parser": "svelte" } }
    ]
  }
}
```

> **중요**: ESLint와 Prettier가 **서로 포맷을 두 번 하지 않도록** Flat Config + `eslint-config-prettier`를 사용한다.

### 스크립트 통일

```json
{
  "scripts": {
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write .",
    "check": "pnpm lint && pnpm typecheck",
    "precommit": "pnpm lint && pnpm typecheck && pnpm format"
  }
}
```

---

## import alias/절대경로 — “경로 지옥 탈출”

### `tsconfig.json` + `vite.config.ts`

- **목표**: 다음과 같은 임포트가 되게 하자.
  - `import { Button } from '$lib/components/ui/Button.svelte'`
  - `import { fetcher } from '@/shared/fetcher'`

`tsconfig.json`의 `paths`는 이미 1.4에서 설정했다. 이제 Vite에 반영:

```ts
// vite.config.ts
import { sveltekit } from '@sveltejs/kit/vite';
import path from 'node:path';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [sveltekit()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
      $lib: path.resolve(__dirname, 'src/lib')
    }
  }
});
```

### 폴더 관례

```
src/
  lib/
    components/
    stores/
    server/        # 서버 전용 유틸 (SvelteKit)
    utils/
  routes/
```

- 공용 컴포넌트/유틸은 **`src/lib`**으로 모아 `$lib/*`으로 임포트.
- 클라이언트 전용/서버 전용 파일을 구분(SvelteKit: `+server.ts` 등).

---

## 디버깅 — “브레이크포인트/소스맵/검사기”

### VS Code `launch.json`(Vite dev 서버 attach)

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "SvelteKit: dev",
      "type": "node",
      "request": "launch",
      "runtimeExecutable": "pnpm",
      "runtimeArgs": ["run", "dev", "--", "--inspect"],
      "console": "integratedTerminal",
      "skipFiles": ["<node_internals>/**", "**/node_modules/**"],
      "sourceMaps": true
    },
    {
      "name": "Attach to Chrome",
      "type": "pwa-chrome",
      "request": "launch",
      "url": "http://localhost:5173",
      "webRoot": "${workspaceFolder}",
      "sourceMaps": true
    }
  ]
}
```

- 첫 구성은 **Node 서버측**(SvelteKit SSR/로드 함수) 브레이크포인트.
- 두 번째는 **브라우저 클라이언트측** 코드 브레이크포인트.

### 소스맵 보장

- Vite dev는 기본적으로 소스맵을 제공. 빌드 시에도 켜고 싶다면:

```ts
// vite.config.ts (빌드 소스맵 예시)
export default defineConfig({
  build: {
    sourcemap: true
  }
});
```

### **Svelte Inspector** 활성화

- 마우스 + `Alt`(기본)로 요소를 클릭하면 **소스 파일**로 점프.

```ts
// vite.config.ts
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    sveltekit({
      inspector: {
        toggleKeyCombo: 'control-shift', // 예: 토글 단축키 변경
        holdMode: true                   // 키 누르는 동안만 활성
      }
    })
  ]
});
```

- 브라우저에서 요소를 가리키면 파일/라인을 표시 → VS Code로 빠른 왕복.

---

## VS Code 확장/설정 — “DX는 습관이다”

### 확장 목록(권장)

- **Svelte for VS Code** (svelte.svelte-vscode)
- **ESLint**
- **Prettier**
- **Error Lens**(경고/에러 인라인 표시)
- **DotENV**
- **Tailwind CSS IntelliSense**(선택)
- **GitLens**(선택)
- **Import Cost**(선택)

### 워크스페이스 설정(`.vscode/settings.json`)

```json
{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit",
    "source.organizeImports": "never" // import/order는 ESLint가 수행
  },
  "eslint.validate": ["javascript", "typescript", "svelte"],
  "files.eol": "\n",
  "prettier.requireConfig": true,
  "svelte.enable-ts-plugin": true,
  "typescript.tsdk": "node_modules/typescript/lib",
  "search.exclude": {
    "**/.svelte-kit": true,
    "**/node_modules": true,
    "**/dist": true
  }
}
```

---

## 환경 변수(.env) — “클라이언트/서버 경계를 명확히”

> **SvelteKit 규칙**: `PUBLIC_` 접두사는 **클라이언트로 노출**된다.
> 민감 값은 **서버 전용** 파일에서만 접근(`+server.ts`, `hooks.server.ts`, `src/lib/server/*`).

```bash
# .env (예시)

PUBLIC_API_BASE=/api
SECRET_DB_URL=postgres://...
```

```ts
// src/lib/config.ts
export const API_BASE = import.meta.env.PUBLIC_API_BASE;
```

```ts
// src/lib/server/db.ts (서버 전용)
import 'dotenv/config';
export const DB_URL = process.env.SECRET_DB_URL!;
```

- **주의**: 클라이언트에서 `process.env` 직접 접근 X. `import.meta.env`만.

---

## 스크립트 레시피 — “한 줄로 팀 규범 지키기”

```json
{
  "scripts": {
    "dev": "vite dev",                    // 또는 svelte-kit dev
    "build": "svelte-kit build",
    "preview": "svelte-kit preview",
    "typecheck": "svelte-kit sync && tsc --noEmit",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write .",
    "check": "pnpm lint && pnpm typecheck",
    "test": "vitest run",
    "test:ui": "vitest",
    "coverage": "vitest run --coverage"
  }
}
```

> **권장 루틴**: `pnpm check` → `pnpm test` → `pnpm build`.

---

## 실전 예제: “SvelteKit + TS + ESLint/Prettier + Alias + Inspector”

아래는 **처음부터 끝까지** 한 번에 적용된 샘플 조합이다.

### 프로젝트 생성

```bash
pnpm create svelte@latest sveltekit-starter
cd sveltekit-starter
pnpm i
```

### TS 강화 + Alias

`tsconfig.json`을 1.4 예시대로 보강하고, `vite.config.ts`를 1.6 예시대로 수정한다.

### ESLint/Prettier 설정

- 1.5의 `eslint.config.js`와 Prettier 설정을 복사한다.
- 설치:

```bash
pnpm add -D eslint @eslint/js typescript-eslint \
  prettier eslint-config-prettier prettier-plugin-svelte \
  @sveltejs/eslint-plugin-svelte eslint-plugin-import eslint-plugin-unused-imports
```

### Svelte Inspector

- 1.7의 `vite.config.ts` 예시처럼 `inspector` 옵션을 추가.

### VS Code 설정

- `.vscode/settings.json`을 1.8 예시대로.

### 간단 페이지/컴포넌트

```svelte
<!-- src/routes/+page.svelte -->
<script>
  let count = 0;
</script>

<h1>Welcome</h1>
<button on:click={() => count++}>Count: {count}</button>
```

```svelte
<!-- src/lib/components/Hero.svelte -->
<script>
  export let title = 'SvelteKit Starter';
  export let subtitle = 'Strict TS + ESLint + Prettier + Inspector';
</script>

<section class="hero">
  <h1>{title}</h1>
  <p>{subtitle}</p>
</section>

<style>
  .hero { padding: 2rem; }
  h1 { margin: 0; }
</style>
```

```svelte
<!-- src/routes/about/+page.svelte -->
<script>
  import Hero from '$lib/components/Hero.svelte';
</script>

<Hero title="About" subtitle="Alias $lib 테스트" />
```

### Lint/Format/Typecheck

```bash
pnpm lint
pnpm format
pnpm typecheck
```

### 디버깅

- `pnpm dev -- --inspect` → VS Code “SvelteKit: dev”로 Node attach
- “Attach to Chrome”으로 브라우저 측 디버깅

---

## 1.12(선택) PNPM 워크스페이스(모노레포) — “앱/패키지 병행”

> 블로그+관리도구+UI 라이브러리 등을 **하나의 저장소**에서 관리할 때

### 루트 `pnpm-workspace.yaml`

```yaml
packages:
  - apps/*
  - packages/*
```

### 구조 예시

```
.
├─ apps/
│  ├─ web/           # SvelteKit 앱
│  └─ admin/         # SvelteKit 또는 SPA
└─ packages/
   └─ ui/            # Svelte 컴포넌트 라이브러리
```

### 공용 UI 패키지 설정

- `packages/ui` 안에서 `svelte`/`types` 필드를 노출해 **트리 셰이킹**과 TS 지원

```json
{
  "name": "@acme/ui",
  "version": "0.0.0",
  "type": "module",
  "svelte": "./src/index.ts",
  "types": "./src/index.d.ts",
  "exports": {
    ".": {
      "svelte": "./src/index.ts",
      "types": "./src/index.d.ts"
    }
  },
  "devDependencies": {
    "svelte": "^5.0.0",
    "typescript": "^5.6.0"
  }
}
```

- `apps/web`에서 `@acme/ui` 사용: 루트에서 `pnpm -r build`로 전 빌드, 로컬 참조

---

## 1.13(선택) 테스트(Vitest) 빠른 온보딩

```bash
pnpm add -D vitest @vitest/coverage-v8 @testing-library/svelte @testing-library/jest-dom
```

```ts
// vitest.config.ts
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [sveltekit()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./vitest.setup.ts'],
    coverage: { reporter: ['text', 'lcov'] }
  }
});
```

```ts
// vitest.setup.ts
import '@testing-library/jest-dom';
```

```ts
// src/lib/components/Hero.spec.ts
import { render } from '@testing-library/svelte';
import { describe, it, expect } from 'vitest';
import Hero from './Hero.svelte';

describe('Hero', () => {
  it('renders props', () => {
    const { getByText } = render(Hero, { title: 'T', subtitle: 'S' });
    expect(getByText('T')).toBeInTheDocument();
    expect(getByText('S')).toBeInTheDocument();
  });
});
```

---

## 1.14(선택) Tailwind 통합(요약)

```bash
pnpm add -D tailwindcss postcss autoprefixer
pnpm exec tailwindcss init -p
```

```js
// tailwind.config.cjs|js
export default {
  content: ['./src/**/*.{html,js,svelte,ts}'],
  theme: { extend: {} },
  plugins: []
};
```

```css
/* src/app.css (또는 +layout.svelte에서 import) */
@tailwind base;
@tailwind components;
@tailwind utilities;
```

```svelte
<!-- src/routes/+layout.svelte -->
<script>
  import '../app.css';
</script>

<slot />
```

---

## 1.15(선택) 커밋 훅/Husky/Lint-Staged

```bash
pnpm add -D husky lint-staged
pnpm dlx husky-init && pnpm i
```

```json
{
  "lint-staged": {
    "*.{ts,js,svelte}": ["eslint --fix", "prettier --write"],
    "*.{json,md,css}": ["prettier --write"]
  }
}
```

`.husky/pre-commit`에 `pnpm lint-staged` 추가.

---

## 1.16(선택) CI(예: GitHub Actions) — 최소 파이프라인

```yaml
# .github/workflows/ci.yml

name: CI
on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
      - run: corepack enable
      - run: pnpm i
      - run: pnpm check
      - run: pnpm test
      - run: pnpm build
```

---

## 1.17(FAQ) 자주 막히는 포인트

- **ESLint/Prettier 충돌**: `eslint-config-prettier`를 반드시 포함하고, Flat Config를 한 파일에서 관리.
- **경로 alias 동작 안 함**: `tsconfig.json`과 `vite.config.ts` **둘 다** 설정.
- **`PUBLIC_` 누락**: 클라이언트에서 쓰는 env는 반드시 `PUBLIC_` 접두사.
- **Inspector 안 뜸**: Vite 플러그인 옵션 확인, 단축키 충돌(브라우저/OS) 체크.
- **nvm 미적용**: 터미널/IDE가 올바른 셸 초기화 스크립트를 읽는지 확인(`.zshrc`/`.bashrc`).

---

## 1.18(체크리스트) 팀 합의안 샘플

- [ ] Node LTS(20) 고정, `.nvmrc`/`engines` 설정
- [ ] PNPM 사용(자동 peer 설치, 워크스페이스 on)
- [ ] SvelteKit 템플릿 + TypeScript **strict**
- [ ] ESLint(Flat) + `@sveltejs/eslint-plugin-svelte` + Prettier 무충돌
- [ ] Alias: `$lib/*`, `@/*` 일관화
- [ ] Svelte Inspector on, VS Code 확장 통일
- [ ] `format`/`lint`/`typecheck`/`test`/`build` 스크립트 통일
- [ ] (옵션) Husky + lint-staged / CI 파이프라인

---

# 결론

이 장의 설정을 **프로젝트 템플릿으로 커밋**해 두면, 이후 새 서비스를 시작할 때 “셋업 비용 0”에 가깝다. 팀은 **기능 개발**에 집중하고, 규칙은 도구가 강제한다. 다음 장에서는 이 발판 위에 **반응성/스토어/컴포넌트 아키텍처**를 올린다.
