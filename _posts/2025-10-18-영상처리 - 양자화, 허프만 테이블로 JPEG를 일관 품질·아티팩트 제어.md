---
layout: post
title: 영상처리 - 양자화/허프만 테이블로 JPEG를 일관 품질·아티팩트 제어
date: 2025-10-18 14:25:23 +0900
category: 영상처리
---
# 사용자 정의 **양자화/허프만 테이블**로 JPEG를 “일관 품질·아티팩트 제어”하기
> 목표  
> - **품질 슬라이더(Q)** 대신, **고정된 양자화(Quantization)·허프만(Huffman) 테이블**을 주입해서 **완전 재현 가능한(Deterministic)** JPEG을 만든다.  
> - “사진(4:2:0, 자연스러운 텍스처)” vs “UI/문서(4:4:4, 글자 경계 선명)”처럼 **사용처별 아티팩트 제어**를 한다.  
> - 실전 코드는 **libjpeg-turbo의 jpeglib** 경로를 사용(※ TurboJPEG 고수준 API는 커스텀 테이블 주입을 지원하지 않음).  
> - 코드 블록은 한 번만 ` ```cpp ` 로 감싼다. 수학은 MathJax를 쓴다.

---

## 0) 왜 직접 테이블을 쓰나?
- **Q값은 상대적**이다. 라이브러리 버전/스케일러/샘플링에 따라 실제 테이블이 달라질 수 있다.  
  → 대규모 파이프라인(앱·서버·CI)이 섞이면 **아티팩트와 용량 편차**가 발생.
- **커스텀 테이블**을 쓰면:
  - 동일 입력 → **바이트 레벨 동일** 출력(진정한 재현성; `optimize_coding=FALSE`, DCT/샘플링/메타 고정 가정).
  - **고주파(엣지) 보존**/**크로마 노이즈 억제** 등 사용처별 미세 조절.

---

## 1) JPEG 양자화/허프만 개요(필수만)
### 1.1 양자화(Quantization)
8×8 DCT 블록의 계수 \(C(u,v)\)를 **양자화 계수 \(Q(u,v)\)** 로 나눈 뒤 반올림:
\[
\hat{C}(u,v) = \mathrm{round}\!\left(\frac{C(u,v)}{Q(u,v)}\right)
\]
- \(Q(u,v)\)가 **작을수록** 세밀(용량↑, 노이즈↓), **클수록** 거칠(용량↓, 블록/링잉↑).
- JPEG는 **밝기(Y)용** 테이블과 **색차(Cb/Cr)용** 테이블 **최대 4개** 사용(보통 2개).

### 1.2 허프만 부호화(Huffman)
- DC는 **직전 블록 DC와의 차**를 부호화, AC는 **(연속 0-run, 크기)** 조합 기호로 부호화.  
- **테이블 = (코드 길이 분포 bits[1..16], 기호 목록 huffval[])**  
  - `bits[i]` = 길이 i 비트인 코드 개수  
  - `huffval[]` = 위 길이 분포 순으로 나열된 심볼들  
- “**optimize_coding=TRUE**”면 **사진별 최적 허프만**을 런타임 생성(크기↓, **재현성↓**).  
  - **고정 테이블**을 쓰려면 **FALSE** + 우리가 넣은 테이블을 사용.

---

## 2) 전략 설계 — 두 가지 프리셋
- **Photo(자연 사진)**: 4:2:0, 표준 Y 테이블 근처 / CbCr는 더 거칠게(색 노이즈 억제)  
- **UI/문서(텍스트/그래픽)**: 4:4:4, Y의 고주파를 **표준보다 작게**(엣지 보존), CbCr도 과도한 블러 방지

> 아래 테이블은 “예시 시작점”이다. 프로젝트/디스플레이 환경에 맞게 미세 조정하라.

---

## 3) 코드: **커스텀 양자화/허프만 테이블**로 메모리 인코딩
- 입력: BGRA 8비트 이미지(가정)  
- 출력: `std::vector<uint8_t> jpeg`  
- 핵심 포인트:
  1) `jpeg_set_defaults()` 후 **샘플링/색공간** 설정  
  2) **양자화 테이블 `JQUANT_TBL`** 직접 주입 (`cinfo.quant_tbl_ptrs[...]`)  
  3) **허프만 테이블 `JHUFF_TBL`** 직접 주입 (`dc_huff_tbl_ptrs`, `ac_huff_tbl_ptrs`)  
  4) `cinfo.optimize_coding = FALSE` (우리가 준 테이블을 그대로 쓰게)  
  5) DCT/Restart/Progressive 등을 **고정**(재현성)

```cpp
#include <jpeglib.h>
#include <vector>
#include <stdexcept>
#include <cstring>

// ---------- 8x8 양자화 테이블(자연 순서, Row-major) ----------
// Annex K 표준 Luma "기본" 테이블(예시; 품질 스케일 없음)
static const unsigned int Q_Y_STD[64] = {
    16,11,10,16,24, 40, 51, 61,
    12,12,14,19,26, 58, 60, 55,
    14,13,16,24,40, 57, 69, 56,
    14,17,22,29,51, 87, 80, 62,
    18,22,37,56,68,109,103, 77,
    24,35,55,64,81,104,113, 92,
    49,64,78,87,103,121,120,101,
    72,92,95,98,112,100,103, 99
};
// Annex K 표준 Chroma "기본" 테이블(예시)
static const unsigned int Q_C_STD[64] = {
    17,18,24,47,99,99,99,99,
    18,21,26,66,99,99,99,99,
    24,26,56,99,99,99,99,99,
    47,66,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99
};

// UI/문서용(4:4:4) 예시: Y 고주파 보존(상대적으로 작은 값), C는 과도 보존 방지
static const unsigned int Q_Y_UI_SHARP[64] = {
    12, 8, 8,12,16, 26, 33, 40,
     8, 8, 9,11,15, 32, 33, 30,
     9, 8,12,16,26, 36, 43, 35,
     9,10,14,18,31, 55, 50, 39,
    12,14,24,36,44, 70, 66, 49,
    16,23,35,40,51, 66, 72, 58,
    33,40,49,55,66, 78, 77, 65,
    48,61,63,65,73, 66, 68, 66
};
static const unsigned int Q_C_UI_SHARP[64] = {
    13,14,18,36,72,72,72,72,
    14,16,20,48,72,72,72,72,
    18,20,44,72,72,72,72,72,
    36,48,72,72,72,72,72,72,
    72,72,72,72,72,72,72,72,
    72,72,72,72,72,72,72,72,
    72,72,72,72,72,72,72,72,
    72,72,72,72,72,72,72,72
};

// ---------- 허프만: 표준(Annex K) 디폴트 테이블 예시 ----------
// bits[0]는 0, bits[1..16]에 각 길이별 개수. huffval에는 해당 개수 총합만큼 기호.
static const UINT8 DC_LUMA_BITS[17] =
 { 0, 0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
static const UINT8 DC_LUMA_VALS[12] =
 { 0,1,2,3,4,5,6,7,8,9,10,11 };

static const UINT8 DC_CHROMA_BITS[17] =
 { 0, 0x03,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00 };
static const UINT8 DC_CHROMA_VALS[12] =
 { 0,1,2,3,4,5,6,7,8,9,10,11 };

static const UINT8 AC_LUMA_BITS[17] =
 { 0, 0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,0x00,0x01,0x7d,0x00 };
static const UINT8 AC_LUMA_VALS[162] =
{
  // 표준 Luma AC table (161~162개 값). 실제 표는 고정이며 널리 알려져 있음.
  0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
  0x22,0x71,0x14,0x32,0x81,0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,
  0x24,0x33,0x62,0x72,0x82,0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,
  0x29,0x2A,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
  0x4A,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
  0x6A,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
  0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,
  0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,
  0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xE1,0xE2,
  0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,
  0xF9,0xFA
};

static const UINT8 AC_CHROMA_BITS[17] =
 { 0, 0x02,0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01,0x02,0x77,0x00 };
static const UINT8 AC_CHROMA_VALS[162] =
{
  0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
  0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,0x52,0xF0,
  0x15,0x62,0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,0xF1,0x17,0x18,0x19,0x1A,0x26,
  0x27,0x28,0x29,0x2A,0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,
  0x49,0x4A,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,
  0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x82,0x83,0x84,0x85,0x86,0x87,
  0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,
  0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xC2,0xC3,
  0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,
  0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,
  0xF9,0xFA
};

// --- 유틸: 테이블 주입 ---
static JQUANT_TBL* make_quant_tbl(j_compress_ptr cinfo, const unsigned int q[64]) {
    JQUANT_TBL* qt = jpeg_alloc_quant_table(cinfo);
    for (int i=0;i<64;i++) {
        unsigned v = q[i];
        if (v < 1) v = 1;
        if (v > 255) v = 255;            // Baseline 8-bit 제한
        qt->quantval[i] = (UINT16)v;
    }
    qt->sent_table = FALSE;
    return qt;
}
static JHUFF_TBL* make_huff_tbl(j_compress_ptr cinfo, const UINT8 bits[17],
                                const UINT8* vals, int nvals) {
    JHUFF_TBL* ht = jpeg_alloc_huff_table(cinfo);
    std::memset(ht, 0, sizeof(*ht));
    for (int i=0;i<17;i++) ht->bits[i] = bits[i];
    for (int i=0;i<nvals;i++) ht->huffval[i] = vals[i];
    ht->sent_table = FALSE;
    return ht;
}

// 입력 BGRA(또는 RGB) → 커스텀 테이블로 JPEG 메모리 인코딩
bool EncodeJPEG_CustomTables_BGRA(const unsigned char* bgra, int width, int height, int stride,
                                  bool uiMode /* true: UI/문서(444), false: 사진(420) */,
                                  std::vector<unsigned char>& outJpeg,
                                  std::string& err)
{
    err.clear(); outJpeg.clear();

    jpeg_compress_struct cinfo{};
    jpeg_error_mgr jerr{};
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_compress(&cinfo);

    // 메모리로 출력
    unsigned char* dstBuf = nullptr;
    unsigned long dstLen = 0;
    jpeg_mem_dest(&cinfo, &dstBuf, &dstLen);

    cinfo.image_width  = width;
    cinfo.image_height = height;

#ifdef JCS_EXTENSIONS
    cinfo.in_color_space = JCS_EXT_BGRA; // libjpeg-turbo 전용
#else
    cinfo.in_color_space = JCS_RGB;
#endif

    jpeg_set_defaults(&cinfo);

    // 색공간/샘플링
    // 내부 변환: BGRA -> YCbCr. 샘플링은 컴포넌트별 h/v factor로 지정.
    jpeg_set_colorspace(&cinfo, JCS_YCbCr);
    if (uiMode) {
        // 4:4:4
        cinfo.comp_info[0].h_samp_factor = 1; cinfo.comp_info[0].v_samp_factor = 1; // Y
        cinfo.comp_info[1].h_samp_factor = 1; cinfo.comp_info[1].v_samp_factor = 1; // Cb
        cinfo.comp_info[2].h_samp_factor = 1; cinfo.comp_info[2].v_samp_factor = 1; // Cr
    } else {
        // 4:2:0
        cinfo.comp_info[0].h_samp_factor = 2; cinfo.comp_info[0].v_samp_factor = 2; // Y
        cinfo.comp_info[1].h_samp_factor = 1; cinfo.comp_info[1].v_samp_factor = 1; // Cb
        cinfo.comp_info[2].h_samp_factor = 1; cinfo.comp_info[2].v_samp_factor = 1; // Cr
    }

    // 품질 슬라이더 비사용: jpeg_set_quality / set_linear_quality 호출하지 않음

    // --- (A) 양자화 테이블 주입 ---
    // 슬롯 0=Y, 1=CbCr (慣例). 컴포넌트 → 테이블 번호 연결.
    cinfo.quant_tbl_ptrs[0] = make_quant_tbl(&cinfo, uiMode ? Q_Y_UI_SHARP : Q_Y_STD);
    cinfo.quant_tbl_ptrs[1] = make_quant_tbl(&cinfo, uiMode ? Q_C_UI_SHARP : Q_C_STD);
    cinfo.comp_info[0].quant_tbl_no = 0; // Y
    cinfo.comp_info[1].quant_tbl_no = 1; // Cb
    cinfo.comp_info[2].quant_tbl_no = 1; // Cr

    // --- (B) 허프만 테이블 주입 ---
    // 고정 테이블 사용: optimize_coding 반드시 끄기
    cinfo.optimize_coding = FALSE;
    cinfo.dc_huff_tbl_ptrs[0] = make_huff_tbl(&cinfo, DC_LUMA_BITS,   DC_LUMA_VALS,   (int)sizeof(DC_LUMA_VALS));
    cinfo.ac_huff_tbl_ptrs[0] = make_huff_tbl(&cinfo, AC_LUMA_BITS,   AC_LUMA_VALS,   (int)sizeof(AC_LUMA_VALS));
    cinfo.dc_huff_tbl_ptrs[1] = make_huff_tbl(&cinfo, DC_CHROMA_BITS, DC_CHROMA_VALS, (int)sizeof(DC_CHROMA_VALS));
    cinfo.ac_huff_tbl_ptrs[1] = make_huff_tbl(&cinfo, AC_CHROMA_BITS, AC_CHROMA_VALS, (int)sizeof(AC_CHROMA_VALS));

    // 각 컴포넌트가 어떤 허프만 테이블을 쓰는지 지정(慣例: 0=Y, 1=CbCr)
    cinfo.comp_info[0].dc_tbl_no = 0; cinfo.comp_info[0].ac_tbl_no = 0;
    cinfo.comp_info[1].dc_tbl_no = 1; cinfo.comp_info[1].ac_tbl_no = 1;
    cinfo.comp_info[2].dc_tbl_no = 1; cinfo.comp_info[2].ac_tbl_no = 1;

    // 재현성 강화를 위한 기타 고정값
    cinfo.restart_interval = 0;              // Restart OFF(0이면 발행 안함)
    cinfo.dct_method = JDCT_ISLOW;           // DCT 고정
    cinfo.smoothing_factor = 0;              // 스무딩 비활성
    // progressive를 쓰더라도 테이블은 동일하게 쓰이지만 스캔 스크립트가 달라지면 바이트가 달라질 수 있다.
    // 완전 재현성을 원한다면 baseline(비-progressive) 권장.
    // cinfo.num_scans/scan_info 사용 시 스크립트도 고정 필요.

    jpeg_start_compress(&cinfo, TRUE);

    // BGRA → 스캔라인 입력
    JSAMPROW row[1];
#ifdef JCS_EXTENSIONS
    while (cinfo.next_scanline < cinfo.image_height) {
        row[0] = (JSAMPROW)(bgra + (size_t)stride * cinfo.next_scanline);
        jpeg_write_scanlines(&cinfo, row, 1);
    }
#else
    // RGB로 변환하여 입력(간단)
    std::vector<unsigned char> tmpRGB((size_t)width*3);
    while (cinfo.next_scanline < cinfo.image_height) {
        const unsigned char* s = bgra + (size_t)stride * cinfo.next_scanline;
        for (int x=0;x<width;x++) {
            tmpRGB[x*3+0] = s[x*4+2]; // R
            tmpRGB[x*3+1] = s[x*4+1]; // G
            tmpRGB[x*3+2] = s[x*4+0]; // B
        }
        row[0] = (JSAMPROW)tmpRGB.data();
        jpeg_write_scanlines(&cinfo, row, 1);
    }
#endif

    jpeg_finish_compress(&cinfo);

    // 출력 복사
    outJpeg.assign(dstBuf, dstBuf + dstLen);
    free(dstBuf);

    jpeg_destroy_compress(&cinfo);
    return true;
}
```

> **검증 팁**: 출력 JPEG를 다시 `jpeg_read_header()`로 열어 `cinfo.quant_tbl_ptrs`, `dc_huff_tbl_ptrs/ac_huff_tbl_ptrs` 값을 덤프해 **DQT/DHT**가 의도대로 들어갔는지 확인하라.

---

## 4) “사진 vs UI” **상황별 프리셋** 운용
### 4.1 사진(4:2:0)
- `Q_Y_STD / Q_C_STD` 사용(또는 표준보다 C를 살짝 키워 색 노이즈 더 억제)
- 샘플링: **Y 2×2, Cb/Cr 1×1**
- 허프만: 표준 디폴트(위 AC/DC 테이블)로 충분. 용량 예측도 쉬움.

### 4.2 UI/문서(4:4:4)
- `Q_Y_UI_SHARP / Q_C_UI_SHARP` 예시 사용  
  - Y의 고주파(오른쪽 아래) 값을 **표준보다 낮게** → 엣지(글자) 보존  
  - C는 표준보다 **좀 작지만 과하지 않게** → 색 경계 번짐 방지
- 샘플링: **모두 1×1 (4:4:4)**  
- 허프만: 표준 디폴트로도 충분하나, **UI 전용 허프만**(빈도 치우친 기호에 짧은 코드)으로 더 줄일 수 있다.  
  - 단, 허프만을 바꾸면 **동일 이미지라도 바이트가 달라지므로** 프리셋 명세에 꼭 기록.

---

## 5) 커스텀 허프만 테이블 생성(선택 고급) — “1pass 최적화 → 고정화”
**목표**: 프로젝트/도메인(예: 스캔 문서, 지도 타일, UI 캡처)에 맞는 **대표 데이터**를 대상으로  
한 번 `optimize_coding=TRUE` 인코딩을 수행해 **생성된 허프만 테이블**을 **고정 프리셋**으로 추출.

### 5.1 절차
1. `optimize_coding = TRUE` 로 메모리 인코딩(사진 몇 백 장 배치).  
2. `jpeg_finish_compress` 이후 `cinfo.dc_huff_tbl_ptrs[k]`/`ac_huff_tbl_ptrs[k]`의 `bits`·`huffval`를 **복사**.  
3. 코드를 종료하기 전에 해당 배열을 **파일/소스 코드**로 덤프.  
4. 프로덕션에서는 `optimize_coding = FALSE` + **고정 테이블**로 사용.

### 5.2 덤프 코드 스케치
```cpp
static void DumpHuff(const JHUFF_TBL* ht, const char* name) {
    printf("static const UINT8 %s_bits[17] = {", name);
    for (int i=0;i<17;i++) printf("%s0x%02X", i?", ":" ", ht->bits[i]);
    printf(" };\n");
    int n=0; for(int i=1;i<=16;i++) n += ht->bits[i];
    printf("static const UINT8 %s_vals[%d] = {", name, n);
    for (int i=0;i<n;i++) printf("%s0x%02X", i?", ":" ", ht->huffval[i]);
    printf(" };\n");
}
```

---

## 6) **테스트 & 디버그** 체크리스트
- **재현성**  
  - 동일 입력, 동일 테이블 → **바이트 동일** 확인(파일 해시)  
  - DCT/샘플링/Restart/Progressive/메타(JFIF/EXIF/ICC) 까지 **고정 여부** 확인
- **비주얼**  
  - 사진: 과도한 링잉/블록? C 채널 얼룩?  
  - UI: 글자 엣지 번짐/컬러 프린지?
- **부호화 제약**  
  - 양자화 값 범위 1..255(Baseline)  
  - 허프만 `bits[1..16]` 총합 = `huffval` 길이, **접두 코드(prefix-free)** 생성 가능 분포인지  
    - 직접 생성 시엔 jpeglib 내부 `jpeg_gen_optimal_table`를 참조(최적 테이블 제작용)

---

## 7) 실전 운영 팁
- **프리셋 버전**을 파일 메타(예: COM 마커)나 파일명에 기록 — 나중에 “어떤 테이블로 인코딩했는가?”를 추적 가능.  
- **샘플링/프리셋 매핑**을 일관화:  
  - `PHOTO_V1`: 420 + Q_Y_STD/Q_C_STD + 표준 Huffman  
  - `UI_V1`: 444 + Q_Y_UI_SHARP/Q_C_UI_SHARP + 표준 Huffman  
- 서버/클라이언트/툴 전부 같은 프리셋을 공유(문서화).

---

## 8) 추가: 이미 인코딩된 JPEG의 **테이블 읽어오기**(검증/분석)
```cpp
#include <jpeglib.h>
#include <vector>
#include <cstdio>

struct JT_Parsed {
    std::vector<UINT16> qY, qC;
    std::vector<UINT8>  dcY_bits, dcY_vals, acY_bits, acY_vals;
    std::vector<UINT8>  dcC_bits, dcC_vals, acC_bits, acC_vals;
};
bool ParseTables(const char* path, JT_Parsed& out) {
    FILE* fp = std::fopen(path, "rb"); if(!fp) return false;
    jpeg_decompress_struct c{}; jpeg_error_mgr jerr{};
    c.err=jpeg_std_error(&jerr); jpeg_create_decompress(&c);
    jpeg_stdio_src(&c, fp);
    if (jpeg_read_header(&c, TRUE) != JPEG_HEADER_OK) { fclose(fp); return false; }

    auto copyQ = [&](int idx, std::vector<UINT16>& v){
        if (c.quant_tbl_ptrs[idx]) {
            v.assign(c.quant_tbl_ptrs[idx]->quantval, c.quant_tbl_ptrs[idx]->quantval+64);
        }
    };
    copyQ(0, out.qY); copyQ(1, out.qC);

    auto copyH = [&](JHUFF_TBL* ht, std::vector<UINT8>& bits, std::vector<UINT8>& vals){
        if (!ht) return;
        bits.assign(ht->bits, ht->bits+17);
        int n=0; for(int i=1;i<=16;i++) n += ht->bits[i];
        vals.assign(ht->huffval, ht->huffval+n);
    };
    copyH(c.dc_huff_tbl_ptrs[0], out.dcY_bits, out.dcY_vals);
    copyH(c.ac_huff_tbl_ptrs[0], out.acY_bits, out.acY_vals);
    copyH(c.dc_huff_tbl_ptrs[1], out.dcC_bits, out.dcC_vals);
    copyH(c.ac_huff_tbl_ptrs[1], out.acC_bits, out.acC_vals);

    jpeg_destroy_decompress(&c);
    fclose(fp);
    return true;
}
```

---

## 9) 실패/주의 포인트
- **optimize_coding를 켰는데 커스텀 허프만이 안 먹는다**  
  → 사양: 최적화 모드가 **우리 테이블을 덮어씀**. **반드시 OFF**.  
- **양자화 테이블 값이 0**  
  → 부호화 불가. **1 이상 255 이하**로 clamp.  
- **progressive에서 바이트 불안정**  
  → 스캔 스크립트/임계가 구현체마다 달라질 수 있다. **baseline으로 시작**하라.  
- **TurboJPEG API로는 테이블 주입 불가**  
  → 반드시 **jpeglib** 저수준 경로 사용.

---

## 10) 요약
- **Q값 대신 테이블 고정**이 **가장 확실한** 품질/용량·재현성 제어다.  
- 프로젝트는 “**프리셋(양자화+허프만+샘플링)**”을 표준화하고, 전 경로(앱/서버/도구)에 공유하라.  
- 위 예제 코드를 바로 붙이면 **사진/문서** 각각 **일관된 아티팩트 특성**을 얻을 수 있다.  
- 이후 단계: 대표 코퍼스에 대해 1회 최적화 → **허프만 테이블 고정화**로 추가 이득을 가져가라.
