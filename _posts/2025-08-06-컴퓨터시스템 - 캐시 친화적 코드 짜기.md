---
layout: post
title: 컴퓨터시스템 - 캐시 친화적 코드 짜기
date: 2025-08-06 21:20:23 +0900
category: 컴퓨터시스템
---
# 캐시 친화적 코드 짜기 — 데이터·루프·메모리·동시성까지

> 목표: **같은 연산이라도 더 빨리** 끝나게 만드는 “캐시 친화적” 패턴을 정리한다.  
> 핵심: **연속(Stride-1)·재사용(Reuse)·충돌 회피(Thrash 방지)·측정(검증)**.

---

## 1) 데이터 레이아웃이 절반이다

### 1.1 AoS → SoA (배열-의-구조체로 쪼개기)
- **문제**(AoS):
```c
typedef struct { float x, y, z; } Vec3;
void norm_aos(const Vec3 *a, float *out, int n){
  for (int i=0;i<n;i++) out[i] = a[i].x*a[i].x + a[i].y*a[i].y + a[i].z*a[i].z;
}
```
  - 각 반복에서 `x,y,z`가 **서로 다른 라인**에 걸치기 쉬움. 불필요한 바이트 끌어옴.

- **해결**(SoA):
```c
typedef struct { float *x, *y, *z; } Vec3SoA;
void norm_soa(const Vec3SoA v, float *out, int n){
  #pragma omp simd
  for (int i=0;i<n;i++){
    float dx=v.x[i], dy=v.y[i], dz=v.z[i];
    out[i] = dx*dx + dy*dy + dz*dz; // 연속, 벡터화 쉬움
  }
}
```
- 효과: **Stride-1**, **벡터화**, 캐시 라인 당 유효 데이터↑.

### 1.2 패킹·정렬(Alignment)·패딩(Padding)
- 구조체는 자주 쓰는 필드를 **앞쪽으로 모아** 같은 라인에 오도록.
- **정렬**: `posix_memalign`/`aligned_alloc(64, ...)`로 64B 정렬 → 로드/스토어 포트 효율↑.
- **패딩**: 같은 세트로 몰리는 배열엔 **오프셋/더미**를 넣어 충돌(Conflict miss) 완화.

---

## 2) 루프를 캐시에 맞춰 바꾼다

### 2.1 Stride-1 순회 (언어의 메모리 배치와 일치)
```c
// C는 row-major
for (int i=0;i<N;i++)
  for (int j=0;j<N;j++)
    sum += A[i][j];      // ✅

for (int j=0;j<N;j++)
  for (int i=0;i<N;i++)
    sum += A[i][j];      // ❌ 큰 스트라이드
```

### 2.2 타일링(Blocking) — L1/L2에 붙잡아두기
```c
void mm_block(int n, const float *A, const float *B, float *C, int Bsz){
  for (int ii=0; ii<n; ii+=Bsz)
    for (int jj=0; jj<n; jj+=Bsz)
      for (int kk=0; kk<n; kk+=Bsz){
        int im = (ii+Bsz<n)?ii+Bsz:n, jm=(jj+Bsz<n)?jj+Bsz:n, km=(kk+Bsz<n)?kk+Bsz:n;
        for (int i=ii;i<im;i++)
          for (int j=jj;j<jm;j++){
            float acc = C[i*n+j];                  // 레지스터 누적
            for (int k=kk;k<km;k++) acc += A[i*n+k]*B[k*n+j];
            C[i*n+j] = acc;                        // 라인 재사용 극대화
          }
      }
}
```
- `Bsz`는 **L1/L2 크기와 요소 크기**로 가설 설정 → **측정**으로 미세 조정.

### 2.3 루프 변환(Interchange/Fusion/Fission)
- **Interchange**: 안쪽 루프를 Stride-1로.  
- **Fusion**: 같은 배열을 두 번 순회 → **한 번에**(캐시 적중↑).  
- **Fission**: 너무 큰 본문을 쪼개 레지스터 압박↓, 벡터화↑.

### 2.4 스칼라 치환(Scalar Replacement)
```c
for (int i=0;i<n;i++){
  float xi = x[i], yi = y[i];  // 두 번 로드 금지
  y[i] = yi + a*xi;
}
```
- **같은 원소는 한 번만** 로드, 레지스터에서 재사용.

---

## 3) 캐시 오염과 충돌을 줄이는 트릭

### 3.1 스트리밍(다시 안 볼 큰 결과) — 비휘발(Non-temporal) 저장
- 대형 결과 버퍼는 **캐시에 올리지 말고** DRAM으로 바로 내보내기(플랫폼 힌트/내장 함수 사용).
- 효과: **유효 데이터**가 캐시에서 쫓겨나지 않음.

### 3.2 소프트웨어 프리패치 (예측 가능한 패턴)
```c
void sum_prefetch(const float *a, int n){
  float s=0;
  for (int i=0;i<n;i+=16){
    __builtin_prefetch(&a[i+64], 0, 1); // 읽기, 약한 지역성
    for (int k=0;k<16 && i+k<n;k++) s += a[i+k];
  }
  (void)s;
}
```
- **거리(distance)** 는 DRAM 왕복/루프당 소비 사이클을 감안해 **측정으로 조정**.

### 3.3 해시·맵·트리의 지역성
- **오픈 어드레싱**(선형/Quadratic probing) + **저부하율**로 **연속 탐사** 유도.  
- B-tree류는 **큰 노드(페이지 크기 맞춤)** 로 디스크/캐시 효율↑.  
- **메모리 풀/아레나**로 노드를 **연속 할당** → 포인터 추적 비용↓.

---

## 4) 그래프·이미지·과학 루틴 같은 “난이도 상” 워크로드

### 4.1 그래프(BFS/SpMV)
- **CSR/CSC** 포맷으로 압축, 정점/에지 **리오더링**(Cuthill–McKee, Hilbert/Z-order)로 지역성 향상.
- **프런티어 기반 BFS**: 레벨 단위 버킷으로 순차 접근.

### 4.2 이미지/컨볼루션
- 슬라이딩 윈도우를 **타일**로 나눠 필터/패치 재사용.
- 경계 처리는 **peeling**(별도 처리) → 핵심 루프는 깔끔한 Stride-1.

### 4.3 캐시-무지(Oblivious) 알고리즘
- **분할정복**으로 자연스런 재귀 타일링(예: 캐시-무지 행렬곱, FFT).
- 하드웨어 캐시 크기를 **몰라도** 좋은 지역성 달성.

---

## 5) 멀티코어: 코히어런시·폴스 셰어링을 잊지 말 것

- **같은 캐시 라인**에 서로 다른 스레드가 쓰면 무효화 폭풍.
```c
typedef struct { _Alignas(64) long v; } Padded;
Padded counters[64];
```
- **샤딩**(스레드별 카운터) → 마지막에 합치기(reduction).  
- **NUMA**: first-touch로 노드 로컬 할당, 스레드와 데이터 바인딩.

---

## 6) TLB·페이지 레벨 지역성

- 큰 워킹셋이면 **Huge Page(2MB/1GB)** 로 TLB 미스 감소.  
- 대형 배열 초기화는 **연속 쓰기**로 페이지 워밍업.

```c
#pragma omp parallel for
for (long i=0;i<n;i++) buf[i] = 0;   // first-touch: NUMA 로컬화
```

---

## 7) 실전 “전/후” 미니 예시

### 7.1 행렬-벡터 곱 (AoS → SoA + 타일링)
```c
// before: 산발적 접근
float gemv_bad(int n, const float *A, const float *x, float *y){
  for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
      y[i] += A[j*n+i] * x[j]; // 열 우선 접근(스트라이드 큼)
  return 0;
}

// after: 행 우선 + 타일
void gemv_block(int n, const float *A, const float *x, float *y, int B){
  for(int ii=0; ii<n; ii+=B){
    int im = (ii+B<n)?ii+B:n;
    for(int i=ii; i<im; i++){
      float acc = y[i];
      for(int j=0; j<n; j++) acc += A[i*n + j] * x[j]; // 행 우선
      y[i] = acc;
    }
  }
}
```
- 행 우선 + 레지스터 누적으로 L1 재사용↑.

### 7.2 해시 테이블 재배치(연속 탐사)
```c
// 고정 크기 오픈 어드레싱: 선형 탐사로 캐시 라인 히트율↑
```

---

## 8) 계측과 검증 — 말이 아닌 숫자

### 8.1 필수 카운터(리눅스)
```bash
perf stat -e \
  cycles,instructions,branches,branch-misses,IPC,\
  L1-dcache-loads,L1-dcache-load-misses,\
  LLC-loads,LLC-load-misses,\
  dTLB-load-misses,stalled-cycles-frontend,stalled-cycles-backend \
  ./app
```
- **IPC<1 + LLC 미스↑** → 메모리 바운드 가능성.  
- **dTLB 미스↑** → 페이지/레이아웃 문제.  
- 전/후 **loads/stores/미스율** 감소를 확인해야 “캐시 친화적”이 된 것.

### 8.2 마이크로벤치 설계 팁
- **워밍업 → N회 반복 → 중앙값** 보고.  
- 입력 크기: **캐시 경계(L1/L2/L3)** 를 넘나드는 값들로 스윕.  
- 단일 변경만 적용(원인-효과 분리).

---

## 9) 체크리스트 (바로 적용)

- [ ] 루프의 **안쪽**이 Stride-1인가?  
- [ ] **타일링**으로 L1/L2에 맞췄는가? 블록 크기 실험했는가?  
- [ ] **SoA/정렬/패딩**으로 벡터화·충돌 완화했는가?  
- [ ] **스칼라 치환/루프 불변 호이스팅**으로 중복 로드 제거했는가?  
- [ ] **프리패치**가 통하는 패턴인가? 거리 튜닝했는가?  
- [ ] **스트리밍 결과**는 non-temporal로 캐시 오염을 막았는가?  
- [ ] 멀티스레드: **폴스 셰어링**과 **NUMA**를 다뤘는가?  
- [ ] `perf`로 **IPC/미스율/대역**이 좋아졌는가?

---

## 10) 한 줄 결론

캐시 친화적 코드는 **데이터를 가깝게·연속적으로·오래** 쓰게 만든다.  
데이터 레이아웃(SoA), 루프 타일링·Stride-1, 충돌/오염 억제, NUMA/코히어런시 고려만 지켜도  
대부분의 워크로드에서 **체감 성능**(특히 p95)을 끌어올릴 수 있다.  
결국 답은 **측정→개선→재측정**이다. 말보다 숫자!