---
layout: post
title: 컴퓨터시스템 - 캐시 친화적 코드 짜기
date: 2025-08-06 21:20:23 +0900
category: 컴퓨터시스템
---
# 캐시 친화적 코드 짜기

## 배경 압축 — 왜 “캐시 친화”인가

- DRAM 왕복은 수백 ns, L1은 수 사이클. **캐시 히트**를 늘리는 순간 성능이 급격히 오른다.
- 평균 접근 시간(AMAT)은 다음과 같다.
  $$
  \text{AMAT} = T_{L1} + m_1\Big(T_{L2} + m_2\big(T_{L3} + m_3 T_\text{Mem}\big)\Big)
  $$
  상층 미스율 \(m_1, m_2\)를 조금만 줄여도 전체 지연이 **기하급수적**으로 준다.
- 실무 규칙: **캐시에 오래·자주·연속으로** 머물게 하라.

---

## 데이터 레이아웃이 절반이다

### AoS → SoA (배열-의-구조체로 쪼개기)

- **문제**(AoS): 동일 필드들을 열 방향으로 처리할 때 캐시 라인에 불필요 바이트가 섞여들어온다.

```c
typedef struct { float x, y, z; } Vec3;
void norm_aos(const Vec3 *a, float *out, int n){
  for (int i=0;i<n;i++) out[i] = a[i].x*a[i].x + a[i].y*a[i].y + a[i].z*a[i].z;
}
```

- **해결**(SoA): 같은 성질의 값들을 연속 배치 → Stride-1 + 벡터화 용이.

```c
typedef struct { float *x, *y, *z; } Vec3SoA;
void norm_soa(const Vec3SoA v, float *out, int n){
  #pragma omp simd
  for (int i=0;i<n;i++){
    float dx=v.x[i], dy=v.y[i], dz=v.z[i];
    out[i] = dx*dx + dy*dy + dz*dz; // 연속 접근 → 캐시 라인 유효 데이터↑
  }
}
```

> 변형: **AoSoA**(Array-of-Structs-of-Arrays, 타일 크기 T 단위로 SoA 묶음)로 L1/L2에 딱 맞게 자르는 방식도 실전에서 강력하다.

### 패킹·정렬(Alignment)·패딩(Padding)

- **정렬**: 64B 정렬은 라인 경계 교차를 줄이고, 넓은 로드/스토어 포트 활용에 유리.
- **패킹**: 자주 함께 쓰는 필드를 구조체 **앞쪽**에 모아 동일 라인에 실리게 한다.
- **패딩**: 세트 충돌이 반복되면(예: 길이/스트라이드가 세트 수의 배수), **더미 컬럼/오프셋**으로 색을 바꿔준다.

```c
#include <stdlib.h>

float *new_aligned(size_t n){
  // 64바이트 정렬된 배열
  return aligned_alloc(64, sizeof(float)*n);
}
```

### 압축(Compaction)·배열 재배치

- 희소 데이터는 **인덱스+값** 압축(CSR/COO)로 무의미한 캐시 통과를 줄인다.
- **핫 필드**와 **콜드 필드**를 분리(Hot/Cold Split)해 I-cache/D-cache를 절약.

---

## 루프를 캐시에 맞춰 바꾼다

### Stride-1 순회 (언어의 메모리 배치와 일치)

```c
// C는 row-major
for (int i=0;i<N;i++)
  for (int j=0;j<N;j++)
    sum += A[i][j];      // ✅ 행-주도 (Stride-1)

for (int j=0;j<N;j++)
  for (int i=0;i<N;i++)
    sum += A[i][j];      // ❌ 열-주도 (큰 스트라이드)
```

### 타일링(Blocking) — L1/L2에 붙잡아두기

```c
void mm_block(int n, const float *A, const float *B, float *C, int Bsz){
  for (int ii=0; ii<n; ii+=Bsz)
    for (int jj=0; jj<n; jj+=Bsz)
      for (int kk=0; kk<n; kk+=Bsz){
        int im=(ii+Bsz<n)?ii+Bsz:n, jm=(jj+Bsz<n)?jj+Bsz:n, km=(kk+Bsz<n)?kk+Bsz:n;
        for (int i=ii;i<im;i++)
          for (int j=jj;j<jm;j++){
            float acc = C[i*n + j];             // 레지스터 누적 (스칼라 치환)
            for (int k=kk;k<km;k++) acc += A[i*n + k] * B[k*n + j];
            C[i*n + j] = acc;                   // 라인 재사용 극대화
          }
      }
}
```

- 블록 크기 초기 가설:
  $$
  B \approx \sqrt{\frac{\alpha \cdot C_\text{cache}}{\text{element\_size} \times \text{행렬 수}}}
  $$
  여기서 \(C_\text{cache}\)는 목표 캐시 용량(L1/L2), \(\alpha\)는 여유 계수(메타데이터·연관도 고려). **실측으로 미세 조정**한다.

### 루프 변환(Interchange / Fusion / Fission)

- **Interchange**: 안쪽 루프를 Stride-1로 바꿔 히트율을 높인다.
- **Fusion**: 동일 배열을 두 번 순회하던 루프를 **합쳐** 메모리 통과 횟수↓.
- **Fission**: 레지스터 압박/캐시 압박이 큰 루프는 **나눠** 벡터화/캐시 적중을 개선.

### 스칼라 치환(Scalar Replacement)

```c
for (int i=0;i<n;i++){
  float xi = x[i], yi = y[i]; // 같은 원소 두 번 로드 금지
  y[i] = yi + a * xi;
}
```

- 레지스터에서 최대한 재사용하여 **메모리 트래픽**을 줄인다.

### 벡터화 힌트: 별칭·정렬·분기 제거

- 포인터에 `restrict`를 붙여 **별칭**이 없음을 알려준다.
- 정렬 보장(`__builtin_assume_aligned`)과 **분기 없는** 마스크를 사용하면 자동 벡터화가 쉬워진다.

```c
void saxpy(int n, float * restrict y, const float * restrict x, float a){
  y = __builtin_assume_aligned(y, 64);
  x = __builtin_assume_aligned(x, 64);
  #pragma omp simd
  for(int i=0;i<n;i++){
    float xi=x[i], yi=y[i];
    y[i] = yi + a*xi;
  }
}
```

---

## 캐시 오염과 충돌을 줄이는 트릭

### 스트리밍(다시 안 볼 큰 결과) — 비휘발(Non-temporal) 저장

- 거대한 결과 버퍼를 **캐시에 올리지 않고** DRAM으로 직행(플랫폼 힌트).
- 효과: 현재 **핫 데이터**가 캐시에서 쫓겨나지 않는다.

```c
// x86 예시 (컴파일러/플랫폼 확인)
#include <immintrin.h>

void stream_store(float *dst, const float *src, int n){
  for(int i=0;i<n; i+=4){
    __m128 v = _mm_load_ps(&src[i]);
    _mm_stream_ps(&dst[i], v);  // non-temporal store
  }
  _mm_sfence(); // 가시성 보장
}
```

### 소프트웨어 프리패치 (예측 가능한 패턴)

```c
void sum_prefetch(const float *a, int n){
  float s=0;
  for (int i=0;i<n;i+=16){
    __builtin_prefetch(&a[i+64], 0, 1); // 읽기, 약한 지역성
    for (int k=0;k<16 && i+k<n;k++) s += a[i+k];
  }
  (void)s;
}
```

- **거리(distance)** 는 “DRAM 왕복 지연(사이클) / 루프당 사이클” 근사로 잡고 **실측으로 조정**한다.
- 프리패처 오조준 → **오염** 위험. **효과가 보이는 패턴**(선형/완만한 스트라이드)에만 사용.

### 충돌(Conflict) 완화

- 세트 수의 배수 스트라이드/길이는 특정 세트만 두드린다 → **패딩** 또는 배열 길이 소수화.
- **페이지 컬러링**(OS/할당기)나 버킷 **색칠**로 매핑 분산.

---

## 난이도 “상” 워크로드의 지역성 전략

### 그래프(불규칙 접근) — BFS / SpMV

- **CSR/CSC**로 압축. 프런티어 기반 BFS는 **버킷 순차 처리**로 캐시/대역 효율↑.
- 정점/에지 **리오더링**(예: Cuthill–McKee, Hilbert/Z-order)로 공간 근접성 강화.

```c
// CSR SpMV: row_offsets, col_idx, values
void spmv_csr(int n, const int *row, const int *col, const float *val,
              const float *x, float *y){
  for(int i=0;i<n;i++){
    float acc=0.0f;
    for(int p=row[i]; p<row[i+1]; ++p) acc += val[p] * x[col[p]];
    y[i]=acc;
  }
}
```

### 이미지/컨볼루션

- 슬라이딩 윈도우를 **타일**로 묶고, 경계는 **peeling**으로 따로 처리 → 코어 루프는 Stride-1.

```c
void conv3x3_tile(float *dst, const float *src, int H, int W, int B){
  for(int ii=1; ii<H-1; ii+=B)
    for(int jj=1; jj<W-1; jj+=B){
      int im=(ii+B<H-1)?ii+B:H-1, jm=(jj+B<W-1)?jj+B:W-1;
      for(int i=ii;i<im;i++)
        for(int j=jj;j<jm;j++){
          float acc=0.0f;
          acc+=src[(i-1)*W+(j-1)] + src[(i-1)*W+j] + src[(i-1)*W+(j+1)];
          acc+=src[i*W+(j-1)]     + src[i*W+j]     + src[i*W+(j+1)];
          acc+=src[(i+1)*W+(j-1)] + src[(i+1)*W+j] + src[(i+1)*W+(j+1)];
          dst[i*W+j]=acc;
        }
    }
}
```

### 캐시-무지(Oblivious) 알고리즘

- 분할정복(재귀 타일링)으로 캐시 크기를 몰라도 좋은 지역성 달성(캐시-무지 GEMM/FFT/정렬).

---

## 멀티코어: 코히어런시·폴스 셰어링을 잊지 말 것

- 서로 **다른 변수**라도 같은 캐시 **라인**이면 무효화 폭주(폴스 셰어링).
- **샤딩**(스레드별 버퍼/카운터), **라인 패딩**, 마지막에 **리덕션**.

```c
typedef struct { _Alignas(64) long v; } Padded;
static Padded cnt[64];

void add(int tid, long x){ cnt[tid].v += x; } // 스레드 전용 라인
long total(){ long s=0; for(int t=0;t<64;t++) s+=cnt[t].v; return s; }
```

- **락 범위** 최소화, 읽기 다수면 **RW락**. 원자적 업데이트는 **배치 후 병합**.

---

## NUMA: first-touch와 바인딩

- 페이지는 **처음 쓰는** 스레드의 노드에 할당(First-touch). 초기화도 병렬로 수행.

```c
#pragma omp parallel for

for (long i=0;i<n;i++) a[i]=0; // NUMA 로컬화
```

- **스레드/메모리 바인딩**(numactl/OS API)으로 원격 접근을 피한다.
- 노드별 **샤딩**: (키 범위/모듈로) → 교차 노드 트래픽 최소화.

---

## TLB·페이지 레벨 지역성

- **TLB reach** \(=\text{엔트리수}\times\text{페이지크기}\)가 워킹셋보다 작으면 dTLB 미스↑.
- **Huge Page**(2MB/1GB)로 reach 확대.
- 대형 배열은 **연속 초기화**로 페이지 워밍업.

---

## “전/후” 미니 사례 3선

### GEMV (열-주도 → 행-주도 + 타일)

```c
// before: 열 우선 (큰 스트라이드)
void gemv_bad(int n, const float *A, const float *x, float *y){
  for(int j=0;j<n;j++)
    for(int i=0;i<n;i++)
      y[i] += A[j*n+i]*x[j];
}

// after: 행 우선 + 레지스터 누적
void gemv_good(int n, const float *A, const float *x, float *y){
  for(int i=0;i<n;i++){
    float acc=y[i];
    for(int j=0;j<n;j++) acc += A[i*n+j]*x[j];
    y[i]=acc;
  }
}
```

**예상 변화**: LLC miss↓, IPC↑, 시간↓.

### AoS → SoA + 벡터화

```c
typedef struct { float *x,*y,*z; } V3;
float l2_sum(V3 v, int n){
  v.x = __builtin_assume_aligned(v.x,64);
  float s=0.0f;
  #pragma omp simd reduction(+:s)
  for(int i=0;i<n;i++){ float dx=v.x[i]; s += dx*dx; }
  return s;
}
```

**예상 변화**: 대역 효율↑, 로드 수/미스율↓.

### 스트리밍 결과 버퍼(Non-temporal store)

```c
#include <immintrin.h>

void write_stream(float *dst, const float *src, int n){
  for(int i=0;i<n;i+=8){
    __m256 v = _mm256_load_ps(&src[i]);
    _mm256_stream_ps(&dst[i], v); // 캐시 오염 최소화
  }
  _mm_sfence();
}
```

**예상 변화**: 핫 데이터의 L1/L2 보존, p95 안정화.

---

## 마이크로벤치 설계와 계측(필수)

### 최소 타이밍 틀

```c
#include <time.h>

double now_sec(){ struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
                  return t.tv_sec + t.tv_nsec*1e-9; }
```

- **프로토콜**: 워밍업 → N회 반복 → **중앙값 + 95% CI** 보고.
- 입력 크기: **L1/L2/L3 경계**를 넘나드는 사이즈로 스윕.

### perf 카운터(리눅스)

```bash
perf stat -e \
  cycles,instructions,branches,branch-misses,IPC,\
  L1-dcache-loads,L1-dcache-load-misses,\
  LLC-loads,LLC-load-misses,\
  dTLB-loads,dTLB-load-misses,\
  stalled-cycles-frontend,stalled-cycles-backend \
  ./app
```

- **IPC<1 + LLC miss↑** → 메모리 바운드.
- **dTLB miss↑** → 페이지/레이아웃 개선(Huge Page/타일링).
- 전/후 **loads/stores/미스율** 감소가 나와야 “캐시 친화적”이라고 말할 수 있다.

### Cachegrind/VTune

- `valgrind --tool=cachegrind ./app` 으로 루틴별 L1/LLC 미스 비교.
- VTune/Advisor로 대역/프리패치 유효성, 자동 벡터화 상태 확인.

---

## 수식 2개만 기억하자 — 타일 크기·Roofline

- **타일 크기 가설**(초기값):
  $$
  B \approx \sqrt{\frac{\alpha \cdot C_\text{cache}}{\text{element\_size}\times\text{동시 참조 배열 수}}}
  $$
  실측으로 조정한다(too small→루프 오버헤드↑, too large→용량 미스↑).

- **Roofline 상한**:
  $$
  \text{Perf} \le \min(\text{Peak FLOPs},\ \text{AI}\cdot \text{Peak BW}),\quad
  \text{AI}=\frac{\text{FLOPs}}{\text{Bytes moved}}
  $$
  AI가 낮으면(예: SAXPY) **메모리 바운드** → 연산 최적화 대신 **데이터 이동 최소화**가 우선.

---

## 현장 체크리스트 (즉시 적용)

- [ ] 루프 **안쪽**이 **Stride-1**인가? (언어 레이아웃과 일치)
- [ ] **타일링**으로 L1/L2에 붙여두었는가? 블록 크기 실험했는가?
- [ ] **SoA/AoSoA + 정렬/패딩**으로 벡터화·충돌을 도왔는가?
- [ ] **스칼라 치환/불변 호이스팅**으로 중복 로드를 제거했는가?
- [ ] **프리패치/스트리밍 저장**의 거리·정책을 검증했는가?
- [ ] 멀티코어: **폴스 셰어링** 방지(라인 패딩/샤딩), **락 범위** 최소화?
- [ ] **NUMA first-touch/바인딩**, **Huge Page** 적용 여부 확인?
- [ ] `perf`로 **IPC/LLC·dTLB miss/스톨**이 실제로 개선되었는가?

---

## 부록: 실험 스켈레톤(전/후 프레임)

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

double now_sec(){ struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
                  return t.tv_sec + t.tv_nsec*1e-9; }

void kernel_before(float *a, float *b, float *c, int n){
  for(int j=0;j<n;j++)
    for(int i=0;i<n;i++)
      c[i*n+j] += a[j*n+i] * b[j]; // 열-주도 (나쁜 예)
}

void kernel_after(float *a, float *b, float *c, int n, int B){
  for(int ii=0; ii<n; ii+=B){
    int im=(ii+B<n)?ii+B:n;
    for(int i=ii;i<im;i++){
      float acc=0.0f;
      for(int j=0;j<n;j++) acc += a[i*n+j] * b[j]; // 행-주도
      c[i*n] += acc; // 단순 예시
    }
  }
}

int main(int argc, char**argv){
  int n = (argc>1)? atoi(argv[1]) : 4096;
  int B = (argc>2)? atoi(argv[2]) : 128;
  size_t sz = (size_t)n*n*sizeof(float);
  float *a = aligned_alloc(64, sz);
  float *c = aligned_alloc(64, sz);
  float *b = aligned_alloc(64, sizeof(float)*n);

  for(int i=0;i<n*n;i++) a[i]=(float)(i&7)*0.1f, c[i]=0;
  for(int i=0;i<n;i++) b[i]=0.5f;

  double t0=now_sec(); kernel_before(a,b,c,n);
  double t1=now_sec(); kernel_after(a,b,c,n,B);
  double t2=now_sec();

  printf("before=%.3f s, after=%.3f s (B=%d)\n", t1-t0, t2-t1, B);
  free(a); free(b); free(c);
}
```

```bash
# 컴파일 & 측정

gcc -O3 -march=native -fopenmp -Wall demo.c -o demo
./demo 4096 128

# 하드웨어 카운터(핵심 이벤트)

perf stat -e cycles,instructions,IPC,\
L1-dcache-load-misses,LLC-load-misses,\
dTLB-load-misses,stalled-cycles-backend ./demo 4096 128
```

---

## 맺음말

캐시 친화적 코드는 **데이터를 가깝게·연속적으로·오래** 쓰게 만드는 기술의 집합이다.
데이터 레이아웃(SoA/AoSoA), 루프 변환(Stride-1/타일링/스칼라 치환), 오염·충돌 억제(프리패치/스트리밍 저장/패딩),
그리고 동시성(폴스 셰어링/락 범위)·NUMA·TLB를 함께 다루면, 대부분의 워크로드에서 **체감 성능(p95 포함)**을 끌어올릴 수 있다.
마지막으로 잊지 말 것: **측정 → 개선 → 재측정**. 말이 아니라 **숫자**로 증명하라.
