---
layout: post
title: 정보통신기사 - 데이터 · DB · 파일시스템
date: 2025-08-23 12:25:23 +0900
category: 정보통신기사
---
# 데이터 · DB · 파일시스템 개요

## 0) 큰 그림: 데이터는 “수집→저장→처리→활용→보호”의 순환

```
[소스] 디바이스/앱/로그/이벤트
  ↓ 수집(배치·스트리밍: ETL/ELT, CDC)
[저장] 트랜잭션 DB(OLTP) · 데이터 웨어하우스/레이크(OLAP) · 캐시/NoSQL
  ↓ 처리 SQL/프로시저/잡 · 스트림처리(윈도우/조인)
[활용] 리포트/대시보드/피처서빙/추천
[보호] 보안(권한/암호화) · 백업/DR(RPO/RTO) · 거버넌스/품질
[저장 기반] 파일시스템/오브젝트 스토리지/분산FS · RAID/LVM/스냅샷
```

---

## 1) 데이터 기본기

### 1.1 데이터 종류
- **정형(Structured)**: 테이블/스키마 고정(SQL).  
- **반정형(Semi-structured)**: JSON/Avro/Parquet(스키마 있지만 유연).  
- **비정형(Unstructured)**: 이미지/오디오/문서.

### 1.2 데이터 품질 6요소
**정확성 · 완전성 · 일관성 · 적시성 · 유일성 · 유효성**. 품질지표는 데이터 카탈로그/검증 쿼리로 측정.

### 1.3 단위/크기 감
- 1행 평균 500B, 초당 2k행 삽입 → **1초 ≈ 1MB, 하루 ≈ 86GB**.

---

## 2) 관계형 데이터베이스(OLTP)

### 2.1 관계모형과 키
- **엔터티–관계(ER)**, **테이블(릴레이션)**, **투플(행)**, **속성(열)**.  
- 키: **기본키(PK)**, **후보키**, **대체키**, **외래키(FK)**, **슈퍼키**.

**ASCII ER 스케치**
```
[Users]──< Orders >──[Products]
  PK: user_id          PK: order_id          PK: product_id
```

### 2.2 정규화(1NF→2NF→3NF→BCNF)
- **1NF**: 원자값.  
- **2NF**: 부분함수종속 제거(복합키일 때).  
- **3NF**: 이행함수종속 제거(비키→비키).  
- **BCNF**: 모든 결정자는 슈퍼키.

**예)** 주문(주문ID, 고객ID, 고객이름, 주소, 주문일) → 고객 정보 분리:  
`Customers(고객ID PK, 이름, 주소)`, `Orders(주문ID PK, 고객ID FK, 주문일)`

### 2.3 트랜잭션과 ACID
- **Atomicity**(전부/전무), **Consistency**, **Isolation**, **Durability**.  
- **로그(Write-Ahead Log)**로 장애 후 **REDO/UNDO**.

### 2.4 고립화수준(격리)
- **RU/RC/RR/Serializable**.  
- 이상 현상: **Dirty Read, Non-Repeatable Read, Phantom**.

**동시성 예시 (두 세션)**  
```sql
-- 세션1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id=1;

-- 세션2 (RC)
SELECT balance FROM accounts WHERE id=1; -- Dirty Read? RC에서는 막힘, RU면 보일 수 있음
```

### 2.5 인덱스 (B-Tree/해시)
- **B-Tree**: 범위/정렬, 대부분의 기본 인덱스.  
- **해시**: 정확히 일치 검색(범위에 불리), 일부 엔진.  
- **선택도(Selectivity)** 높을수록 효과↑.  
- **복합 인덱스**(a,b): **왼쪽 접두어 규칙**(a만, a+b 가능 / b만 단독 사용 X).

**예: 커버링 인덱스**  
```sql
CREATE INDEX ix_orders_user_date ON orders(user_id, order_date) INCLUDE(total_amount);
-- WHERE user_id=? AND order_date BETWEEN...  → 테이블 접근 없이 인덱스만으로 해결(커버)
```

### 2.6 실행계획/코스트 감
- **카디널리티 추정** → **조인 순서/방식**(NLJ/Hash/Merge) 결정.  
- 통계가 부정확하면 **잘못된 계획** → **ANALYZE/STATISTICS** 갱신.

```sql
EXPLAIN ANALYZE
SELECT u.name, SUM(o.total_amount)
FROM users u JOIN orders o ON o.user_id=u.id
WHERE u.country='KR' AND o.order_date>=current_date-30
GROUP BY u.name;
```

### 2.7 파티셔닝
- **범위·해시·리스트**. 대용량 테이블 관리/프루닝/아카이빙.  
- **샤딩**(수평 분산): 애플리케이션/미들웨어로 분배 키 설계.

---

## 3) 분산/NoSQL 개요

### 3.1 CAP & PACELC
- **CAP**: 네트워크 분할(P) 상황에서 **일관성(C)** vs **가용성(A)** 중 택1.  
- **PACELC**: 분할 시(P) C/A 선택, 평상시(Else)엔 **지연(L)** vs **일관성(C)** 절충.

### 3.2 일관성 모델
- **강한(Strong)**, **선형화(Linearizability)**, **순서/단조 일관(모노토닉)**, **Read-your-writes**, **Causal**, **Eventual**.

### 3.3 Dynamo 패러다임 (N,R,W)
- 복제본 수 $N$, 읽기 정족수 $R$, 쓰기 정족수 $W$.  
- $R+W > N$이면 **강한 읽기 일관성**(네트워크/클럭 가정).  
- **충돌 해결**: LWW, 벡터클록, **CRDT**.

### 3.4 유형별 특징/예제
- **Key-Value**(Redis/Riak): 초저지연 캐시/세션. TTL/만료/원자연산.  
- **Document**(MongoDB/Couch): JSON 문서, 유연 스키마, **인덱스/샤딩**.  
- **Wide-Column**(Cassandra/HBase): 파티션키+클러스터링키, **쓰기/수평확장↑**.  
- **Graph**(Neo4j): 노드/관계/속성, **패턴 탐색**.  
- **Time-Series**(Influx/Prometheus): 시간키, **압축/다운샘플**.  
- **Search**(Elasticsearch): 역인덱스/토큰화, 전문검색·애그리게이션.

**Cassandra 테이블 예**  
```sql
CREATE TABLE sensor_timeseries(
  device_id text,
  ts       timestamp,
  field    text,
  value    double,
  PRIMARY KEY ((device_id), ts, field)  -- 파티션=device_id, 클러스터링=ts,field
) WITH CLUSTERING ORDER BY (ts DESC);
```

### 3.5 분산 트랜잭션(요지)
- **2PC**: 코디네이터가 prepare/commit(블로킹·코디네이터 장애 취약).  
- **3PC**: 일부 개선이나 복잡, 실제로는 **합의 알고리즘(Raft/Paxos)** + 로그 복제로 구현.  
- **SAGA**: 분산 장기 트랜잭션을 **보상 단계**로 분해(오케스트레이션/코레오그래피).

---

## 4) OLAP · 데이터웨어하우스 · 레이크/레이크하우스

### 4.1 OLTP vs OLAP
| 구분 | OLTP(운영) | OLAP(분석) |
|---|---|---|
| 워크로드 | 잦은 단건 읽기/쓰기 | 대용량 스캔/집계 |
| 스키마 | 정규화 | 스타/스노우플레이크 |
| 저장 | 행 지향 | 열 지향(압축/벡터화) |
| 지표 | 지연(ms) | 처리량(GB/s) |

### 4.2 스타/스노우플레이크
- **사실 테이블(Fact)**: 측정값(금액, 수량) + **외래키**.  
- **차원(Dimension)**: 날짜/상품/고객 등 속성.

```sql
-- Fact
CREATE TABLE fact_sales(
  date_key int, product_key int, store_key int,
  qty int, amount decimal(12,2),
  PRIMARY KEY(date_key, product_key, store_key)
);

-- Dimension (예: 날짜)
CREATE TABLE dim_date(date_key int PRIMARY KEY, y int, q int, m int, d int, dow int);
```

### 4.3 열 지향/압축/벡터화
- **인코딩**: RLE, Dictionary, Delta, Frame-of-Reference, Bit-Packing.  
- **벡터화**: 칼럼 청크를 SIMD로 한번에 처리 → **CPU 캐시 활용↑**.

### 4.4 파일 포맷
- **CSV**: 텍스트, 스키마X, 압축X(선택).  
- **JSON**: 반정형, 중첩.  
- **Avro**: Row+스키마, 스트리밍/스키마 진화 적합.  
- **Parquet/ORC**: **Columnar + Dictionary + Statistics** → 스캔 최소화·압축↑.

**파이썬 CSV→Parquet(교육용)**  
```python
import pandas as pd
df = pd.read_csv("sales.csv")
df.to_parquet("sales.parquet", index=False)  # pyarrow or fastparquet 필요
```

### 4.5 ETL vs ELT
- **ETL**: 추출→변환→적재(전통 DWH).  
- **ELT**: 추출→적재→(DWH에서)변환(Modern cloud DWH).

---

## 5) 스트리밍 데이터(핵심만)

- **Kafka**: 토픽/파티션/오프셋, **컨슈머 그룹**(병렬성).  
- **처리시간 vs 이벤트시간**, **워터마크**(지연 이벤트 기준).  
- 윈도우: **Tumbling/Sliding/Session**.  
- **Exactly-once**: 프로듀서 **Idempotence** + 트랜잭션, 싱크 사가/업서트 키.

---

## 6) 파일시스템 기본

### 6.1 개념·구성
- **블록(Block)**: 최소 할당 단위(예: 4KiB).  
- **inode**: 메타데이터(소유/권한/타임스탬프/블록 포인터).  
- **디렉터리**: 이름→inode 매핑(엔트리).  
- **하드링크/심볼릭링크**: 동일 inode 참조 vs 경로 참조.

### 6.2 저널링 vs CoW
- **저널링(Ext4/XFS/NTFS)**: 메타데이터(옵션: 데이터) 로그 후 반영 → **크래시 일관성**.  
- **CoW(ZFS/Btrfs)**: 블록을 **새로 쓰고 포인터 스왑**, **스냅샷/체크섬** 용이.

### 6.3 리눅스 주요 FS
- **Ext4**: 범용, 저널링, 익스텐트, 대용량 안정.  
- **XFS**: 대파일/병렬 I/O 강점.  
- **Btrfs**: CoW, 스냅샷, 서브볼륨(성숙도/튜닝 필요).  
- **ZFS**: 풀/데이터셋, 압축/중복제거/체크섬/스크럽, RAIDZ.

### 6.4 권한/ACL
```bash
# POSIX 권한
chmod 640 file   # -rw-r-----
chown alice:dev file
# ACL
setfacl -m u:bob:r file
getfacl file
```

### 6.5 캐시/일관성
- **페이지 캐시/버퍼 캐시**, **write-back** 지연 쓰기 → `fsync()`로 내구성 보장.  
- POSIX 일관성: 열고/쓰기/닫기/읽기의 순서 보장(분산FS/NFS는 예외 존재).

### 6.6 RAID/LVM(간략)
- RAID0(스트라이핑, 속도↑, 내구X), RAID1(미러), RAID5/6(패리티), RAID10(미러+스트라이프).  
  $$
  \text{RAID10 용량} = \frac{N}{2}\times \text{DiskSize},\qquad
  \text{RAID5 용량} = (N-1)\times \text{DiskSize}
  $$
- **LVM**: PV→VG→LV, **스냅샷/확장** 유연.

### 6.7 분산/오브젝트 스토리지
- **NFS/SMB**: 네트워크 파일 공유(락/캐시/일관성 주의).  
- **HDFS**: 네임노드/데이터노드, 큰 파일 스트리밍 최적화, 복제 3.  
- **CephFS/GlusterFS**: 오브젝트 기반/스케일아웃.  
- **오브젝트(S3 등)**: 버킷/오브젝트 키, **Eventually Consistent**(강한 일관 옵션도 존재). 메타데이터/수명 정책/버저닝.

---

## 7) 성능/용량 산정 & 튜닝

### 7.1 I/O 산술
$$
\text{Throughput(MB/s)} \approx \frac{\text{IOPS} \times \text{BlockSize(KB)}}{1024}
$$
- 랜덤 4KiB 100k IOPS ≈ **~390 MB/s**.  
- **큐 깊이(QD)**로 병렬성↑, 하지만 지연↑(OLTP는 낮게, OLAP는 높게).

### 7.2 DB 성능 요령
- **핵심 컬럼에 인덱스**, **선택도 낮은 컬럼은 지양**.  
- **커버링 인덱스**로 테이블 접근 최소화.  
- **배치/벌크** 쓰기, **트랜잭션 크기** 조정.  
- **파티션 프루닝**(파티션 키 조건 명시).  
- **실행계획** 확인 후 **통계 갱신/힌트**.

### 7.3 파일시스템 튜닝
```bash
mkfs.ext4 -b 4096 -E lazy_itable_init=1 /dev/vg/data
mount -o noatime,discard /dev/vg/data /data
# noatime: 읽기 시 atime 미갱신, discard: SSD TRIM
```

---

## 8) 백업/복구/DR

### 8.1 정의
- **RPO**: 허용 데이터 손실량(시간).  
- **RTO**: 복구 완료까지 시간.

### 8.2 전략
- **전체/증분/차등**, **오프사이트/오프라인(랜섬웨어 대비)**, **스냅샷 + 로그(POINT-IN-TIME)**.  
- DB: **WAL/REDO** 기반 PITR, **복제 + 백업** 병행.  
- **복구 시험**으로만 진짜 보장.

---

## 9) 보안/거버넌스(요지)

- **암호화**: 전송(TLS), 저장(TDE/디스크 암호화).  
- **권한**: RBAC/ABAC, 최소권한, 감사로그.  
- **민감정보**: 마스킹/토큰화, **컬럼·행 수준 보안**.  
- **데이터 라인리지/카탈로그**: 소스→변환→사용처 추적.  
- **GDPR/개인정보**: 보존기간/파기/가명처리.

---

## 10) 예제 모음

### 10.1 SQL DDL/DML
```sql
CREATE TABLE users(
  id BIGINT PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  country CHAR(2) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE orders(
  id BIGINT PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id),
  order_date DATE NOT NULL,
  total_amount NUMERIC(12,2) NOT NULL,
  status VARCHAR(16) NOT NULL
);
CREATE INDEX ix_orders_user_date ON orders(user_id, order_date);

-- 최근 30일 KR 사용자 매출 TOP5
SELECT u.id, u.name, SUM(o.total_amount) AS revenue
FROM users u JOIN orders o ON o.user_id=u.id
WHERE u.country='KR' AND o.order_date >= current_date - 30
GROUP BY u.id, u.name
ORDER BY revenue DESC
LIMIT 5;
```

### 10.2 트랜잭션/격리 예(Phantom)
```sql
-- 세션1
BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT COUNT(*) FROM orders WHERE order_date = CURRENT_DATE; -- n

-- 세션2
INSERT INTO orders VALUES (1001, 1, CURRENT_DATE, 99.9, 'NEW'); COMMIT;

-- 세션1 (같은 트랜잭션 내)
SELECT COUNT(*) FROM orders WHERE order_date = CURRENT_DATE; -- n+1 (팬텀) → RR/Serializable로 방지
```

### 10.3 리눅스 FS 실습(루프 디스크)
```bash
dd if=/dev/zero of=/tmp/disk.img bs=1M count=1024
losetup -fP /tmp/disk.img
mkfs.ext4 /dev/loop0
mkdir -p /mnt/test && mount /dev/loop0 /mnt/test
echo hello > /mnt/test/a.txt
umount /mnt/test && losetup -d /dev/loop0
```

---

## 11) 자주 틀리는 포인트(정오표)

1) **인덱스가 많을수록 빠르다** → 쓰기/유지비용↑, 선택도 낮으면 역효과.  
2) **샤딩=무조건 성능↑** → **조인/트랜잭션/리밸런싱** 복잡↑.  
3) **CAP의 오해**: 분할이 없으면 C/A 둘 다 가능. 평상시엔 **지연 vs 일관**(PACELC).  
4) **CSV=가볍다** → 스키마X·압축X, 대스캔 비효율. 열지향 포맷 우선.  
5) **스냅샷=백업 대체**? → 동일 장애/암호화 전파 위험. **오프사이트 백업** 필요.  
6) **RAID=백업**? → 아님. RAID는 **가용성**, 백업은 **복구**.  
7) **CoW FS는 항상 빠르다** → 랜덤 쓰기/조각화/스냅샷 다수 시 성능 편차.

---

## 12) 체크리스트(현장용)

### 모델링/스키마
- [ ] 엔터티/관계/키 정의(ERD)  
- [ ] 정규화(3NF) + 필요한 곳만 **비정규화**  
- [ ] 기본/외래키 제약, **도메인 제약**(CHECK)

### OLTP 운영
- [ ] 핵심 질의 **복합 인덱스** 설계(접두어 규칙)  
- [ ] 실행계획/통계 점검, **ANALYZE 주기**  
- [ ] 파티션 키 기준 접근(프루닝)

### 분산/NoSQL
- [ ] 접근 패턴 기반 **파티션키** 설계  
- [ ] 정족수(R/W/N)와 일관성 수준 확정  
- [ ] 충돌 해결(LWW/CRDT) 정책 문서화

### 파일시스템/스토리지
- [ ] 워크로드에 맞는 FS(ext4/XFS/ZFS)  
- [ ] 마운트 옵션(noatime, discard 등)  
- [ ] RAID/LVM 레이아웃, 스냅샷/모니터링

### 백업/DR/보안
- [ ] RPO/RTO 정의, 정기 **복구 리허설**  
- [ ] 오프사이트/오프라인 백업  
- [ ] TDE/TLS, RBAC/감사, 민감데이터 정책

---

## 13) 연습문제(풀이 포함)

**Q1. 정규화**  
테이블 `Sales(order_id, order_date, customer_id, customer_name, city)`에서 정규화하라.  
**A.** `Customers(customer_id PK, customer_name, city)`, `Sales(order_id PK, order_date, customer_id FK)`.

**Q2. 인덱스**  
쿼리: `WHERE category='A' AND created_at>=:d`가 많다. 복합 인덱스를 설계하라.  
**A.** `CREATE INDEX ix ON t(category, created_at);` (카디널리티 높은 created_at이 뒤여도 범위조건에 유리. 카디널리티/분포 따라 (created_at, category)도 테스트)

**Q3. 트랜잭션 격리**  
RC에서 가능한 이상 2개와 방지 레벨은?  
**A.** **Non-Repeatable**·**Phantom** 발생, **Repeatable Read/Serializable**로 방지(엔진별 차).

**Q4. CAP/PACELC**  
네트워크 분할 P 상황에서 가용성을 우선하면 어떤 모델? 평상시엔?  
**A.** **AP** 선택(일부 eventual). 평상시엔 **EL**(지연 우선) 전략.

**Q5. RAID**  
8TB 디스크 6개, RAID6 유효 용량?  
**A.** $(N-2)\times 8=4\times 8=32\ \text{TB}$.

**Q6. OLTP vs OLAP**  
OLAP 컬럼형 포맷의 장점 2가지?  
**A.** 필요한 컬럼만 스캔(입출력↓), **압축↑**로 메모리/IO 효율↑.

**Q7. 파티셔닝**  
월별 파티션 테이블에서 2025-09 데이터만 읽도록 하는 WHERE 절은?  
**A.** `WHERE order_date >= '2025-09-01' AND order_date < '2025-10-01'` (프루닝 유도)

**Q8. 일관성 모델**  
Read-your-writes 일관성을 설명하라.  
**A.** 클라이언트가 **자신이 방금 쓴 값을 읽을 때** 보장되는 일관성(다른 클라이언트에겐 보장X 가능).

**Q9. 파일시스템**  
하드링크와 심볼릭링크 차이?  
**A.** 하드링크=**같은 inode** 참조(같은 FS 내), 심링크=경로 참조(교차FS/원본 삭제 시 깨짐).

**Q10. E2E 지연**  
랜덤 4KiB IO 80k IOPS, 평균 큐깊이 8, 장치 서비스시간 100µs일 때 지연 근사?  
**A.** 리틀의 법칙 $L=\lambda W$: $W\approx L/\lambda = 8/80000 \text{s} = 100\ \mu s$ (서비스시간 수준으로 포화 직전).

---

## 14) 암기표(초압축 24줄)

1) ER: 엔터티/관계/키(PK/FK)  
2) 정규화: 1NF→2NF→3NF(이행종속X)→BCNF  
3) ACID + WAL(REDO/UNDO)  
4) 격리: RU/RC/RR/Serializable & 이상(Dirty/NR/Phantom)  
5) 인덱스: B-Tree, **접두어 규칙**, 커버링  
6) 실행계획=통계 기반, 조인(NLJ/Hash/Merge)  
7) 파티셔닝(범위/해시), 샤딩(수평)  
8) CAP, PACELC(분할시 C/A, 평상시 L/C)  
9) Dynamo $N,R,W$, $R+W>N$이면 읽기 강일관  
10) CRDT/벡터클록 충돌해결  
11) OLTP(행) vs OLAP(열)  
12) 스타 스키마: Fact + Dimension  
13) 컬럼 압축: RLE/Dictionary/Delta  
14) 파일포맷: CSV/JSON vs Parquet/ORC  
15) 스트리밍: 토픽/파티션/워터마크/윈도우  
16) FS: 블록/inode/저널링 vs CoW  
17) 권한: rwx + ACL, fsync=내구성  
18) RAID: 0/1/5/6/10 용량 공식  
19) LVM: PV→VG→LV, 스냅샷  
20) NFS/HDFS/S3 특성(일관성 차)  
21) IOPS×블록크기 ≈ 처리량  
22) 프루닝 조건(폐구간/반개구간)  
23) 백업: RPO/RTO, PITR, 오프사이트  
24) 보안: TDE/TLS, RBAC, 마스킹

---

## 15) 마무리

데이터 **모델링**이 올바르면 **인덱스/쿼리/확장**이 단순해지고,  
저장소(파일시스템/RAID/분산FS) 이해가 튼튼하면 **성능/내구성/복구**가 예측 가능합니다.  
**원리 → 공식 → 예제 → 체크리스트**의 루틴으로 실전 감각을 쌓으세요.