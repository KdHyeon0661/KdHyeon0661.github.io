---
layout: post
title: 정보통신기사 - 데이터 · DB · 파일시스템
date: 2025-08-23 12:25:23 +0900
category: 정보통신기사
---
# 데이터 · DB · 파일시스템 개요

## 큰 그림: 데이터는 “수집→저장→처리→활용→보호”의 순환

```
[소스] 디바이스/앱/로그/이벤트
  ↓ 수집(배치·스트리밍: ETL/ELT, CDC)
[저장] 트랜잭션 DB(OLTP) · 데이터 웨어하우스/레이크(OLAP) · 캐시/NoSQL
  ↓ 처리 SQL/프로시저/잡 · 스트림처리(윈도우/조인)
[활용] 리포트/대시보드/피처서빙/추천
[보호] 보안(권한/암호화) · 백업/DR(RPO/RTO) · 거버넌스/품질
[저장 기반] 파일시스템/오브젝트 스토리지/분산FS · RAID/LVM/스냅샷
```

---

## 데이터 기본기

### 데이터 종류

- **정형(Structured)**: 테이블/스키마 고정(SQL).
- **반정형(Semi-structured)**: JSON/Avro/Parquet(스키마 있지만 유연).
- **비정형(Unstructured)**: 이미지/오디오/문서.

### 데이터 품질 6요소

**정확성 · 완전성 · 일관성 · 적시성 · 유일성 · 유효성**. 품질지표는 데이터 카탈로그/검증 쿼리로 측정.

### 단위/크기 감

- 1행 평균 500B, 초당 2k행 삽입 → **1초 ≈ 1MB, 하루 ≈ 86GB**.

---

## 관계형 데이터베이스(OLTP)

### 관계모형과 키

- **엔터티–관계(ER)**, **테이블(릴레이션)**, **투플(행)**, **속성(열)**.
- 키: **기본키(PK)**, **후보키**, **대체키**, **외래키(FK)**, **슈퍼키**.

**ASCII ER 스케치**
```
[Users]──< Orders >──[Products]
  PK: user_id          PK: order_id          PK: product_id
```

### 정규화(1NF→2NF→3NF→BCNF)

- **1NF**: 원자값.
- **2NF**: 부분함수종속 제거(복합키일 때).
- **3NF**: 이행함수종속 제거(비키→비키).
- **BCNF**: 모든 결정자는 슈퍼키.

**예)** 주문(주문ID, 고객ID, 고객이름, 주소, 주문일) → 고객 정보 분리:
`Customers(고객ID PK, 이름, 주소)`, `Orders(주문ID PK, 고객ID FK, 주문일)`

### 트랜잭션과 ACID

- **Atomicity**(전부/전무), **Consistency**, **Isolation**, **Durability**.
- **로그(Write-Ahead Log)**로 장애 후 **REDO/UNDO**.

### 고립화수준(격리)

- **RU/RC/RR/Serializable**.
- 이상 현상: **Dirty Read, Non-Repeatable Read, Phantom**.

**동시성 예시 (두 세션)**
```sql
-- 세션1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id=1;

-- 세션2 (RC)
SELECT balance FROM accounts WHERE id=1; -- Dirty Read? RC에서는 막힘, RU면 보일 수 있음
```

### 인덱스 (B-Tree/해시)

- **B-Tree**: 범위/정렬, 대부분의 기본 인덱스.
- **해시**: 정확히 일치 검색(범위에 불리), 일부 엔진.
- **선택도(Selectivity)** 높을수록 효과↑.
- **복합 인덱스**(a,b): **왼쪽 접두어 규칙**(a만, a+b 가능 / b만 단독 사용 X).

**예: 커버링 인덱스**
```sql
CREATE INDEX ix_orders_user_date ON orders(user_id, order_date) INCLUDE(total_amount);
-- WHERE user_id=? AND order_date BETWEEN...  → 테이블 접근 없이 인덱스만으로 해결(커버)
```

### 실행계획/코스트 감

- **카디널리티 추정** → **조인 순서/방식**(NLJ/Hash/Merge) 결정.
- 통계가 부정확하면 **잘못된 계획** → **ANALYZE/STATISTICS** 갱신.

```sql
EXPLAIN ANALYZE
SELECT u.name, SUM(o.total_amount)
FROM users u JOIN orders o ON o.user_id=u.id
WHERE u.country='KR' AND o.order_date>=current_date-30
GROUP BY u.name;
```

### 파티셔닝

- **범위·해시·리스트**. 대용량 테이블 관리/프루닝/아카이빙.
- **샤딩**(수평 분산): 애플리케이션/미들웨어로 분배 키 설계.

---

## 분산/NoSQL 개요

### CAP & PACELC

- **CAP**: 네트워크 분할(P) 상황에서 **일관성(C)** vs **가용성(A)** 중 택1.
- **PACELC**: 분할 시(P) C/A 선택, 평상시(Else)엔 **지연(L)** vs **일관성(C)** 절충.

### 일관성 모델

- **강한(Strong)**, **선형화(Linearizability)**, **순서/단조 일관(모노토닉)**, **Read-your-writes**, **Causal**, **Eventual**.

### Dynamo 패러다임 (N,R,W)

- 복제본 수 $N$, 읽기 정족수 $R$, 쓰기 정족수 $W$.
- $R+W > N$이면 **강한 읽기 일관성**(네트워크/클럭 가정).
- **충돌 해결**: LWW, 벡터클록, **CRDT**.

### 유형별 특징/예제

- **Key-Value**(Redis/Riak): 초저지연 캐시/세션. TTL/만료/원자연산.
- **Document**(MongoDB/Couch): JSON 문서, 유연 스키마, **인덱스/샤딩**.
- **Wide-Column**(Cassandra/HBase): 파티션키+클러스터링키, **쓰기/수평확장↑**.
- **Graph**(Neo4j): 노드/관계/속성, **패턴 탐색**.
- **Time-Series**(Influx/Prometheus): 시간키, **압축/다운샘플**.
- **Search**(Elasticsearch): 역인덱스/토큰화, 전문검색·애그리게이션.

**Cassandra 테이블 예**
```sql
CREATE TABLE sensor_timeseries(
  device_id text,
  ts       timestamp,
  field    text,
  value    double,
  PRIMARY KEY ((device_id), ts, field)  -- 파티션=device_id, 클러스터링=ts,field
) WITH CLUSTERING ORDER BY (ts DESC);
```

### 분산 트랜잭션(요지)

- **2PC**: 코디네이터가 prepare/commit(블로킹·코디네이터 장애 취약).
- **3PC**: 일부 개선이나 복잡, 실제로는 **합의 알고리즘(Raft/Paxos)** + 로그 복제로 구현.
- **SAGA**: 분산 장기 트랜잭션을 **보상 단계**로 분해(오케스트레이션/코레오그래피).

---

## OLAP · 데이터웨어하우스 · 레이크/레이크하우스

### OLTP vs OLAP

| 구분 | OLTP(운영) | OLAP(분석) |
|---|---|---|
| 워크로드 | 잦은 단건 읽기/쓰기 | 대용량 스캔/집계 |
| 스키마 | 정규화 | 스타/스노우플레이크 |
| 저장 | 행 지향 | 열 지향(압축/벡터화) |
| 지표 | 지연(ms) | 처리량(GB/s) |

### 스타/스노우플레이크

- **사실 테이블(Fact)**: 측정값(금액, 수량) + **외래키**.
- **차원(Dimension)**: 날짜/상품/고객 등 속성.

```sql
-- Fact
CREATE TABLE fact_sales(
  date_key int, product_key int, store_key int,
  qty int, amount decimal(12,2),
  PRIMARY KEY(date_key, product_key, store_key)
);

-- Dimension (예: 날짜)
CREATE TABLE dim_date(date_key int PRIMARY KEY, y int, q int, m int, d int, dow int);
```

### 열 지향/압축/벡터화

- **인코딩**: RLE, Dictionary, Delta, Frame-of-Reference, Bit-Packing.
- **벡터화**: 칼럼 청크를 SIMD로 한번에 처리 → **CPU 캐시 활용↑**.

### 파일 포맷

- **CSV**: 텍스트, 스키마X, 압축X(선택).
- **JSON**: 반정형, 중첩.
- **Avro**: Row+스키마, 스트리밍/스키마 진화 적합.
- **Parquet/ORC**: **Columnar + Dictionary + Statistics** → 스캔 최소화·압축↑.

**파이썬 CSV→Parquet(교육용)**
```python
import pandas as pd
df = pd.read_csv("sales.csv")
df.to_parquet("sales.parquet", index=False)  # pyarrow or fastparquet 필요
```

### ETL vs ELT

- **ETL**: 추출→변환→적재(전통 DWH).
- **ELT**: 추출→적재→(DWH에서)변환(Modern cloud DWH).

---

## 스트리밍 데이터(핵심만)

- **Kafka**: 토픽/파티션/오프셋, **컨슈머 그룹**(병렬성).
- **처리시간 vs 이벤트시간**, **워터마크**(지연 이벤트 기준).
- 윈도우: **Tumbling/Sliding/Session**.
- **Exactly-once**: 프로듀서 **Idempotence** + 트랜잭션, 싱크 사가/업서트 키.

---

## 파일시스템 기본

### 개념·구성

- **블록(Block)**: 최소 할당 단위(예: 4KiB).
- **inode**: 메타데이터(소유/권한/타임스탬프/블록 포인터).
- **디렉터리**: 이름→inode 매핑(엔트리).
- **하드링크/심볼릭링크**: 동일 inode 참조 vs 경로 참조.

### 저널링 vs CoW

- **저널링(Ext4/XFS/NTFS)**: 메타데이터(옵션: 데이터) 로그 후 반영 → **크래시 일관성**.
- **CoW(ZFS/Btrfs)**: 블록을 **새로 쓰고 포인터 스왑**, **스냅샷/체크섬** 용이.

### 리눅스 주요 FS

- **Ext4**: 범용, 저널링, 익스텐트, 대용량 안정.
- **XFS**: 대파일/병렬 I/O 강점.
- **Btrfs**: CoW, 스냅샷, 서브볼륨(성숙도/튜닝 필요).
- **ZFS**: 풀/데이터셋, 압축/중복제거/체크섬/스크럽, RAIDZ.

### 권한/ACL

```bash
# POSIX 권한

chmod 640 file   # -rw-r-----
chown alice:dev file
# ACL

setfacl -m u:bob:r file
getfacl file
```

### 캐시/일관성

- **페이지 캐시/버퍼 캐시**, **write-back** 지연 쓰기 → `fsync()`로 내구성 보장.
- POSIX 일관성: 열고/쓰기/닫기/읽기의 순서 보장(분산FS/NFS는 예외 존재).

### RAID/LVM(간략)

- RAID0(스트라이핑, 속도↑, 내구X), RAID1(미러), RAID5/6(패리티), RAID10(미러+스트라이프).
  $$
  \text{RAID10 용량} = \frac{N}{2}\times \text{DiskSize},\qquad
  \text{RAID5 용량} = (N-1)\times \text{DiskSize}
  $$
- **LVM**: PV→VG→LV, **스냅샷/확장** 유연.

### 분산/오브젝트 스토리지

- **NFS/SMB**: 네트워크 파일 공유(락/캐시/일관성 주의).
- **HDFS**: 네임노드/데이터노드, 큰 파일 스트리밍 최적화, 복제 3.
- **CephFS/GlusterFS**: 오브젝트 기반/스케일아웃.
- **오브젝트(S3 등)**: 버킷/오브젝트 키, **Eventually Consistent**(강한 일관 옵션도 존재). 메타데이터/수명 정책/버저닝.

---

## 성능/용량 산정 & 튜닝

### I/O 산술

$$
\text{Throughput(MB/s)} \approx \frac{\text{IOPS} \times \text{BlockSize(KB)}}{1024}
$$
- 랜덤 4KiB 100k IOPS ≈ **~390 MB/s**.
- **큐 깊이(QD)**로 병렬성↑, 하지만 지연↑(OLTP는 낮게, OLAP는 높게).

### DB 성능 요령

- **핵심 컬럼에 인덱스**, **선택도 낮은 컬럼은 지양**.
- **커버링 인덱스**로 테이블 접근 최소화.
- **배치/벌크** 쓰기, **트랜잭션 크기** 조정.
- **파티션 프루닝**(파티션 키 조건 명시).
- **실행계획** 확인 후 **통계 갱신/힌트**.

### 파일시스템 튜닝

```bash
mkfs.ext4 -b 4096 -E lazy_itable_init=1 /dev/vg/data
mount -o noatime,discard /dev/vg/data /data
# noatime: 읽기 시 atime 미갱신, discard: SSD TRIM

```

---

## 백업/복구/DR

### 정의

- **RPO**: 허용 데이터 손실량(시간).
- **RTO**: 복구 완료까지 시간.

### 전략

- **전체/증분/차등**, **오프사이트/오프라인(랜섬웨어 대비)**, **스냅샷 + 로그(POINT-IN-TIME)**.
- DB: **WAL/REDO** 기반 PITR, **복제 + 백업** 병행.
- **복구 시험**으로만 진짜 보장.

---

## 보안/거버넌스(요지)

- **암호화**: 전송(TLS), 저장(TDE/디스크 암호화).
- **권한**: RBAC/ABAC, 최소권한, 감사로그.
- **민감정보**: 마스킹/토큰화, **컬럼·행 수준 보안**.
- **데이터 라인리지/카탈로그**: 소스→변환→사용처 추적.
- **GDPR/개인정보**: 보존기간/파기/가명처리.

---

## 예제 모음

### SQL DDL/DML

```sql
CREATE TABLE users(
  id BIGINT PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  country CHAR(2) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE orders(
  id BIGINT PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id),
  order_date DATE NOT NULL,
  total_amount NUMERIC(12,2) NOT NULL,
  status VARCHAR(16) NOT NULL
);
CREATE INDEX ix_orders_user_date ON orders(user_id, order_date);

-- 최근 30일 KR 사용자 매출 TOP5
SELECT u.id, u.name, SUM(o.total_amount) AS revenue
FROM users u JOIN orders o ON o.user_id=u.id
WHERE u.country='KR' AND o.order_date >= current_date - 30
GROUP BY u.id, u.name
ORDER BY revenue DESC
LIMIT 5;
```

### 트랜잭션/격리 예(Phantom)

```sql
-- 세션1
BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT COUNT(*) FROM orders WHERE order_date = CURRENT_DATE; -- n

-- 세션2
INSERT INTO orders VALUES (1001, 1, CURRENT_DATE, 99.9, 'NEW'); COMMIT;

-- 세션1 (같은 트랜잭션 내)
SELECT COUNT(*) FROM orders WHERE order_date = CURRENT_DATE; -- n+1 (팬텀) → RR/Serializable로 방지
```

### 리눅스 FS 실습(루프 디스크)

```bash
dd if=/dev/zero of=/tmp/disk.img bs=1M count=1024
losetup -fP /tmp/disk.img
mkfs.ext4 /dev/loop0
mkdir -p /mnt/test && mount /dev/loop0 /mnt/test
echo hello > /mnt/test/a.txt
umount /mnt/test && losetup -d /dev/loop0
```

---

## 자주 틀리는 포인트(정오표)

1) **인덱스가 많을수록 빠르다** → 쓰기/유지비용↑, 선택도 낮으면 역효과.
2) **샤딩=무조건 성능↑** → **조인/트랜잭션/리밸런싱** 복잡↑.
3) **CAP의 오해**: 분할이 없으면 C/A 둘 다 가능. 평상시엔 **지연 vs 일관**(PACELC).
4) **CSV=가볍다** → 스키마X·압축X, 대스캔 비효율. 열지향 포맷 우선.
5) **스냅샷=백업 대체**? → 동일 장애/암호화 전파 위험. **오프사이트 백업** 필요.
6) **RAID=백업**? → 아님. RAID는 **가용성**, 백업은 **복구**.
7) **CoW FS는 항상 빠르다** → 랜덤 쓰기/조각화/스냅샷 다수 시 성능 편차.

---

## 체크리스트(현장용)

### 모델링/스키마

- [ ] 엔터티/관계/키 정의(ERD)
- [ ] 정규화(3NF) + 필요한 곳만 **비정규화**
- [ ] 기본/외래키 제약, **도메인 제약**(CHECK)

### OLTP 운영

- [ ] 핵심 질의 **복합 인덱스** 설계(접두어 규칙)
- [ ] 실행계획/통계 점검, **ANALYZE 주기**
- [ ] 파티션 키 기준 접근(프루닝)

### 분산/NoSQL

- [ ] 접근 패턴 기반 **파티션키** 설계
- [ ] 정족수(R/W/N)와 일관성 수준 확정
- [ ] 충돌 해결(LWW/CRDT) 정책 문서화

### 파일시스템/스토리지

- [ ] 워크로드에 맞는 FS(ext4/XFS/ZFS)
- [ ] 마운트 옵션(noatime, discard 등)
- [ ] RAID/LVM 레이아웃, 스냅샷/모니터링

### 백업/DR/보안

- [ ] RPO/RTO 정의, 정기 **복구 리허설**
- [ ] 오프사이트/오프라인 백업
- [ ] TDE/TLS, RBAC/감사, 민감데이터 정책

---

## 연습문제(풀이 포함)

**Q1. 정규화**
테이블 `Sales(order_id, order_date, customer_id, customer_name, city)`에서 정규화하라.
**A.** `Customers(customer_id PK, customer_name, city)`, `Sales(order_id PK, order_date, customer_id FK)`.

**Q2. 인덱스**
쿼리: `WHERE category='A' AND created_at>=:d`가 많다. 복합 인덱스를 설계하라.
**A.** `CREATE INDEX ix ON t(category, created_at);` (카디널리티 높은 created_at이 뒤여도 범위조건에 유리. 카디널리티/분포 따라 (created_at, category)도 테스트)

**Q3. 트랜잭션 격리**
RC에서 가능한 이상 2개와 방지 레벨은?
**A.** **Non-Repeatable**·**Phantom** 발생, **Repeatable Read/Serializable**로 방지(엔진별 차).

**Q4. CAP/PACELC**
네트워크 분할 P 상황에서 가용성을 우선하면 어떤 모델? 평상시엔?
**A.** **AP** 선택(일부 eventual). 평상시엔 **EL**(지연 우선) 전략.

**Q5. RAID**
8TB 디스크 6개, RAID6 유효 용량?
**A.** $(N-2)\times 8=4\times 8=32\ \text{TB}$.

**Q6. OLTP vs OLAP**
OLAP 컬럼형 포맷의 장점 2가지?
**A.** 필요한 컬럼만 스캔(입출력↓), **압축↑**로 메모리/IO 효율↑.

**Q7. 파티셔닝**
월별 파티션 테이블에서 2025-09 데이터만 읽도록 하는 WHERE 절은?
**A.** `WHERE order_date >= '2025-09-01' AND order_date < '2025-10-01'` (프루닝 유도)

**Q8. 일관성 모델**
Read-your-writes 일관성을 설명하라.
**A.** 클라이언트가 **자신이 방금 쓴 값을 읽을 때** 보장되는 일관성(다른 클라이언트에겐 보장X 가능).

**Q9. 파일시스템**
하드링크와 심볼릭링크 차이?
**A.** 하드링크=**같은 inode** 참조(같은 FS 내), 심링크=경로 참조(교차FS/원본 삭제 시 깨짐).

**Q10. E2E 지연**
랜덤 4KiB IO 80k IOPS, 평균 큐깊이 8, 장치 서비스시간 100µs일 때 지연 근사?
**A.** 리틀의 법칙 $L=\lambda W$: $W\approx L/\lambda = 8/80000 \text{s} = 100\ \mu s$ (서비스시간 수준으로 포화 직전).

---

## 암기표(초압축 24줄)

1) ER: 엔터티/관계/키(PK/FK)
2) 정규화: 1NF→2NF→3NF(이행종속X)→BCNF
3) ACID + WAL(REDO/UNDO)
4) 격리: RU/RC/RR/Serializable & 이상(Dirty/NR/Phantom)
5) 인덱스: B-Tree, **접두어 규칙**, 커버링
6) 실행계획=통계 기반, 조인(NLJ/Hash/Merge)
7) 파티셔닝(범위/해시), 샤딩(수평)
8) CAP, PACELC(분할시 C/A, 평상시 L/C)
9) Dynamo $N,R,W$, $R+W>N$이면 읽기 강일관
10) CRDT/벡터클록 충돌해결
11) OLTP(행) vs OLAP(열)
12) 스타 스키마: Fact + Dimension
13) 컬럼 압축: RLE/Dictionary/Delta
14) 파일포맷: CSV/JSON vs Parquet/ORC
15) 스트리밍: 토픽/파티션/워터마크/윈도우
16) FS: 블록/inode/저널링 vs CoW
17) 권한: rwx + ACL, fsync=내구성
18) RAID: 0/1/5/6/10 용량 공식
19) LVM: PV→VG→LV, 스냅샷
20) NFS/HDFS/S3 특성(일관성 차)
21) IOPS×블록크기 ≈ 처리량
22) 프루닝 조건(폐구간/반개구간)
23) 백업: RPO/RTO, PITR, 오프사이트
24) 보안: TDE/TLS, RBAC, 마스킹

---

## 마무리

데이터 **모델링**이 올바르면 **인덱스/쿼리/확장**이 단순해지고,
저장소(파일시스템/RAID/분산FS) 이해가 튼튼하면 **성능/내구성/복구**가 예측 가능합니다.
**원리 → 공식 → 예제 → 체크리스트**의 루틴으로 실전 감각을 쌓으세요.
