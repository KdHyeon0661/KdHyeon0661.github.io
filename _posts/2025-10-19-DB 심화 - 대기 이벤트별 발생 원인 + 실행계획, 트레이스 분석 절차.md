---
layout: post
title: DB 심화 - 대기 이벤트별 발생 원인 + 실행계획/트레이스 분석 절차
date: 2025-10-19 22:25:23 +0900
category: DB 심화
---
# Oracle **대기 이벤트별 발생 원인 + 실행계획/트레이스 분석 절차** (19c 기준, 실전 위주)

> 목표  
> - 자주 만나는 **대기 이벤트(Wait Events)** 를 **원인·징후·진단 SQL·해결책**까지 표준 절차로 연결합니다.  
> - **실행계획(Plan)** 과 **트레이스(10046/10053, SQL Monitor)** 를 묶어 **“이벤트 → 어느 Plan 라인에서 왜?”** 를 끝까지 추적합니다.  
> - **예제 시나리오**(락 경합, 인덱스/정렬/해시, 로그 동기화, RAC, ITL 부족, 라이브러리/로우 캐시 등)를 제시합니다.

---

## 0) 한눈 핵심 요약(현장 플로우)

1) **증상 수집**: AWR Top Events/SQL, ASH Top Waits → **상위 이벤트/SQL** 식별  
2) **대기 클래스 확인**: User I/O / Concurrency / Commit / Cluster / Configuration / Network / Other  
3) **SQL 단건 추적**: `DBMS_XPLAN.DISPLAY_CURSOR(…, 'ALLSTATS LAST +PEEKED_BINDS')` + **실행 행수(A-Rows)** 와 **추정 카디널리티** 비교  
4) **Line ↔ Wait 매핑**: SQL Monitor(Row Source Statistics) 또는 10046 trace → **어느 Plan Id** 가 시간을 쓰는지  
5) **원인-해법 매핑**: (예) `enq: TX - row lock contention` → **락 보유자/대상** 찾기 → **커밋/순서/지표/인덱스/ITL** 조치  
6) **수정 후 검증**: 재실행 → AWR/Monitor 비교, 레그레션 방지

---

## 1) 공용 진단 도구 치트시트

```sql
-- 시스템/세션 이벤트
SELECT event, total_waits, time_waited_micro/1e6 sec
FROM   v$system_event ORDER BY sec DESC;

SELECT sid, event, state, seconds_in_wait, blocking_session
FROM   v$session WHERE state='WAITING' ORDER BY seconds_in_wait DESC;

-- ASH(상시 샘플)에서 상위 이벤트/SQL/Plan Line
SELECT sample_time, session_id, sql_id, sql_plan_hash_value, sql_plan_line_id, event, wait_class
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE;

-- 상위 SQL
SELECT sql_id, plan_hash_value, executions, elapsed_time/1e6 sec, cpu_time/1e6 cpu_sec
FROM   v$sqlarea ORDER BY sec DESC FETCH FIRST 20 ROWS ONLY;

-- 실행계획(실제 실행 통계)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(:sql_id, :child, 'ALLSTATS LAST +PEEKED_BINDS +OUTLINE'));
```

**SQL Trace / Monitor**

```sql
-- (A) 10046 Trace: 대기/바인드 포함(세션 단)
EXEC DBMS_MONITOR.SESSION_TRACE_ENABLE(waits=>TRUE, binds=>TRUE);

-- (B) 특정 SQL만 모니터(실시간 통계)
SELECT * FROM v$sql_monitor WHERE sql_id=:sql_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(:sql_id, NULL, 'ALLSTATS LAST'));

-- (C) Optimizer 10053 (힌트/통계 의사결정 추적) : 테스트 세션에서만 사용 권장
ALTER SESSION SET events '10053 trace name context forever, level 1';
```

---

## 2) **User I/O** 계열

### 2.1 `db file sequential read` (단일 블록 I/O)
- **원인**: **인덱스 탐색/테이블 랜덤 액세스** 위주. OLTP에서 흔함.  
- **징후**: Plan에서 **INDEX RANGE/UNIQUE SCAN → TABLE ACCESS BY ROWID** 라인에 시간이 집중.  
- **진단**:
  - Plan 라인별 **A-Rows** vs **Rows**(추정) 비교 → **카디널리티 과소/과대** 여부  
  - **히트 비율**이 낮고 **I/O 시간** 많으면 **인덱스 선택성/필터 효율** 확인  
  - ASH의 `sql_plan_line_id` 로 **문제 라인** 확인
- **해결**:
  - **정확한 접근경로**: **복합 인덱스 정렬**(선행 컬럼 선택성), **필터를 인덱스로 흡수**  
  - **Covering Index**(include), **Index Skip Scan/Bitmap**는 신중  
  - **클러스터링 팩터** 나쁜 인덱스 교체(리빌드로 해결되지 않음 → **물리 정렬** 필요)

**예제**

```sql
CREATE TABLE orders(o_id NUMBER PRIMARY KEY, cust NUMBER, dt DATE, amt NUMBER);
CREATE INDEX ix_orders_cust_dt ON orders(cust, dt);

-- 'cust=:b AND dt BETWEEN …' 에서 RANGE SCAN → ROWID 랜덤 접근
SELECT /*+ monitor */ *
FROM   orders
WHERE  cust=:b AND dt BETWEEN :d1 AND :d2;

-- DBMS_XPLAN : INDEX RANGE SCAN 라인의 A-Rows가 많고 전체 Elapsed 대부분을 차지
```

---

### 2.2 `db file scattered read` (멀티블록 I/O, 테이블/인덱스 풀)
- **원인**: **Full Table/Index Scan**, 범위 넓은 스캔.  
- **해결**:  
  - **선행 필터 인덱스**로 범위 축소, **파트ition Pruning**  
  - **병렬 스캔(PX)** 로 ETL/리포트 가속  
  - 사실상 필요한 행이 대부분이면 **FTS** 가 맞음(오버힌트 금지)

---

### 2.3 `direct path read/write`, `direct path read temp`
- **원인**: PGA 메모리 부족으로 **TEMP** 사용(정렬/해시 조인 spill), 또는 병렬/직접경로 Insert/Select.  
- **진단**: SQL Monitor에서 **Sort/Hash** 단계의 **TempSpc** 크게, Wait 대부분이 Direct Path.  
- **해결**:
  - `pga_aggregate_target`/`workarea_size_policy=auto` 조정, **정렬/해시 크기 감소**(카디널리티 정확화)  
  - **해시→Nested Loop** 유도(선행 필터 인덱스)  
  - TEMP 디스크/ASM IOPS 증설

**예제**

```sql
-- 대형 해시 조인(Temp spill)
SELECT /*+ monitor */ /* 힌트 없이 카디널리티 오판 시 해시+스필 유발 */
       SUM(s.amt)
FROM   sales s JOIN cust c ON s.c_id=c.id
WHERE  c.region=:r AND s.dt BETWEEN :d1 AND :d2;
-- Display_Cursor에 TEMP spills, direct path read temp 다량
```

---

## 3) **Concurrency** 계열

### 3.1 `enq: TX - row lock contention` (행 잠금)
- **원인**: 동일 행/키 갱신 충돌, **FK 미인덱스**, **비트맵 인덱스 갱신**, **ITL 부족**(allocate ITL entry), 긴 트랜잭션.  
- **진단**:
  - `DBA_WAITERS/BLOCKERS`, `V$LOCK`(TX/ID1/ID2), `V$SESSION.blocking_session`  
  - **락 보유자** 세션이 뭘 하는지(PL/외부콜/대형 I/O/분할/redo flush 지연) 확인
- **해결**:
  - **커밋 타이밍 단축**, **잠금 순서 표준화**(데드락 방지)  
  - **FK 인덱스 전수 생성**, **비트맵 → B*Tree**(OLTP), **INITRANS/PCTFREE** 상향  
  - **핫키 분산**(Reverse/Hash/샤딩)

**2세션 데모(요지)**

```sql
-- A
UPDATE t SET v=v+1 WHERE id=1;  -- 보유
-- B
UPDATE t SET v=v+1 WHERE id=1;  -- TX 대기
-- A가 COMMIT할 때까지 B 대기 → '락의 열쇠는 COMMIT'
```

---

### 3.2 `library cache: lock/pin`, `cursor: mutex S/X`, `row cache mutex`
- **원인**: **하드 파싱 폭주**, 리터럴 남발, **Child Cursor 폭증**(바인드 타입/길이 불일치, NLS, ACS), DDL/통계 갱신으로 잦은 **Invalidation**.  
- **진단**:
  - `v$librarycache`, `v$sqlarea(version_count, parse_calls)`, `v$sql_shared_cursor(reason)`  
- **해결**:
  - **바인드 변수**/SQL 표준화, `session_cached_cursors`↑, DDL/통계 **배치화**, 필요 최소 **KEEP**.

---

### 3.3 `buffer busy waits`, `read by other session`
- **원인**: **같은 블록**에 동시 접근(핫블록), ITL/헤더 확장 지연, 인덱스 리프 충돌.  
- **해결**: **키 분산**, `INITRANS/PCTFREE`↑, 파티셔닝, Reverse Key.

---

## 4) **Commit/Redo/Log** 계열

### 4.1 `log file sync`
- **원인**: **자주 커밋**(Row 단위 커밋 등) → 커밋마다 LGWR 동기 플러시 대기.  
- **진단**: Top Event로 `log file sync`, **per exec commit** 확인(`v$sesstat` parse/commit)  
- **해결**:
  - **적절한 배치 커밋**(업무와 타협), **네트워크/스토리지 지연** 축소, **그룹 커밋** 유도(짧은 대기 합치기)  
  - LGWR 대상 디스크 성능 강화

### 4.2 `log buffer space`, `log file switch (checkpoint incomplete)`
- **원인**: 로그 버퍼/그룹 크기 부족, 빈번한 스위치.  
- **해결**: **redo 로그 사이즈/그룹 수 확대**, 체크포인트 튜닝.

---

## 5) **Cluster(RAC)** 계열

### 5.1 `gc cr/current block busy`, `gc buffer busy acquire/release`
- **원인**: 다른 인스턴스 보유 버퍼를 **캐시 퓨전**으로 전달받는 동안 대기, **글로벌 핫블록**.  
- **진단**: ASH에서 `inst_id`, `P1/P2`로 블록 주소, 오브젝트 추적; **서비스→파티션 로컬리티** 확인.  
- **해결**:
  - **데이터 로컬리티**: 서비스별 파티션 고정, **Sequence NOORDER + 큰 CACHE**  
  - 핫 블록 분산(Reverse/Hash), 애플리케이션 **노드 친화도**

---

## 6) **Configuration/Network/Other**

- `SQL*Net more data from client/server`: **네트워크 왕복/패킷**. 배열 페치/배치 바인드 조정.  
- `resmgr:cpu quantum`: 리소스 매니저에 의한 CPU 할당 제약.  
- `latch: …`/`mutex`: 내부 구조체 직렬화(Shared Pool/Cache Buffers Chains 등) → 파싱 억제, 핫해시 분산.

---

## 7) **실행계획 기반 분석 절차** (표준 7단계)

1) **문제 SQL 식별**: AWR Top SQL / ASH에서 `sql_id` 추출  
2) **계획 확보**:  
   ```sql
   SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(:sql_id, NULL,
      'ALLSTATS LAST +PEEKED_BINDS +PROJECTION +ALIAS'));
   ```
3) **핵심 지표 읽기**: 각 라인의  
   - **A-Rows(실행 행수)** vs **Rows(추정)**, **Starts**, **Time**, **TempSpc**, **Read/Write**  
   - **큰乂(오차)** → 통계/히스토그램/바인드 선택도/조인순서 문제  
4) **대기 매핑**:  
   - SQL Monitor(Real-Time)에서 **Plan Line별 경과 시간/대기**  
   - ASH `sql_plan_line_id` 로 **대기 이벤트**와 라인 연결  
5) **카디널리티/접근경로 검증**:  
   - 인덱스 선택성, 조인 열 분포, 필터의 선행 적용 가능성  
   - 필요한 경우 **10053**(옵티마이저 결정 이유)  
6) **수정안 적용**:  
   - 통계 보정(히스토그램), 인덱스 추가/변경, 힌트(임시), SQL 리라이트, 파티셔닝/바인드  
7) **재검증**: 동일 데이터/부하에서 **Before/After** SQL Monitor/AWR 비교

**예시(정렬 스필 개선)**

- Before: `SORT ORDER BY` 라인에서 `TempSpc=5GB`, Wait=`direct path read temp`  
- 조치: **선행 필터 인덱스** 추가 → **Rows 대폭 축소** → After: Temp 0, Elapsed 1/10

---

## 8) **트레이스 분석 절차** (10046/10053/TKPROF)

### 8.1 10046 (대기+바인드)
```sql
EXEC DBMS_MONITOR.SESSION_TRACE_ENABLE(waits=>TRUE, binds=>TRUE);
-- 문제 SQL 실행 후
EXEC DBMS_MONITOR.SESSION_TRACE_DISABLE;
```
- trace 파일을 **TKPROF**: SQL별 **Parse/Exec/Fetch 시간**, **대기 이벤트 목록**, **행수** 정리.

읽는 요령  
- **큰 Fetch call 시간** + `db file sequential/scattered read` → 스캔행·랜덤 I/O  
- **Exec 시간** + `enq: TX…` → 실행 단계에서 **락 대기**  
- **커밋 직후** `log file sync` → 커밋 지연

### 8.2 10053 (옵티마이저 내부)
- **언제?** 추정 카디널리티/조인순서가 **비상식적**일 때.  
- **주의**: 운영 세션에 상시 켜지 말 것. 테스트에서만.

---

## 9) **이벤트별 원인·진단·해결 표(요지)**

| 이벤트 | 주 원인 | 핵심 진단 | 주 조치 |
|---|---|---|---|
| db file sequential read | 인덱스→ROWID 랜덤 I/O | Plan 라인 A-Rows, ASH 라인 | 인덱스 설계, 카디널리티 보정, 커버링 |
| db file scattered read | FTS/범위 스캔 | Plan에서 FTS | 인덱스/파티셔닝/병렬 |
| direct path read temp | 정렬/해시 스필 | SQL Monitor TempSpc↑ | PGA↑, 카디널리티↓, 조인전략 |
| enq: TX - row lock contention | 행잠금 충돌/FK미인덱스/ITL | DBA_WAITERS/BLOCKERS | 커밋단축, FK인덱스, INITRANS, 분산 |
| buffer busy waits | 핫블록/ITL | v$segment_statistics | 키 분산, INITRANS/PCTFREE |
| library cache: lock/pin | 하드파싱/Invalidation | v$sqlarea/version_count | 바인드, DDL 배치, 세션커서캐시 |
| row cache mutex | 사전 캐시 경합 | v$rowcache | 하드파싱 억제, DDL 빈발 억제 |
| log file sync | 잦은 커밋/LGWR I/O | v$system_event, per txn | 배치커밋, 스토리지/네트워크 튜닝 |
| log buffer space | redo 버퍼/그룹 부족 | 로그 스위치 빈발 | 그룹/사이즈 증설 |
| gc … (RAC) | 글로벌 버퍼 경합 | ASH inst/blk | 데이터 로컬리티, 시퀀스/키 분산 |
| SQL*Net more data … | 네트워크 왕복 | 배열 크기/패킷 | 배열 페치/배치 바인드 |

---

## 10) **예제 시나리오 5선**

### 10.1 Lost Update 방지 실패로 `TX` 폭주
- **증상**: `enq: TX - row lock contention` 상위, 세션 다수 대기  
- **Plan**: NL UPDATE 라인 A-Rows 작은데 Elapsed 큼  
- **원인**: 동일 키 UPDATE 동시, **커밋 지연**  
- **조치**: `SELECT … FOR UPDATE NOWAIT/WAIT`, 키 분산, 커밋 지연 제거

### 10.2 정렬/해시 스필
- **증상**: `direct path read temp` 상위  
- **Plan**: `HASH JOIN` 또는 `SORT ORDER BY` 라인 TempSpc↑  
- **조치**: 인덱스 선행 필터, 조인순서 변경(드라이빙 소량), PGA↑

### 10.3 FK 미인덱스
- **증상**: 부모 DELETE/UPDATE 때 자식 TM/TX 대기 확산  
- **진단**: `dba_constraints`/`dba_ind_columns` 매칭  
- **조치**: **FK 컬럼 인덱스 생성**

### 10.4 RAC 시퀀스/인덱스 핫스팟
- **증상**: `gc buffer busy acquire`, `gc current block busy`  
- **원인**: 증가키 우측 집중, ORDER 시퀀스  
- **조치**: `NOORDER CACHE↑`, Reverse/파티션, 서비스 로컬리티

### 10.5 라이브러리 캐시 경합
- **증상**: `cursor: mutex S/X`, `library cache: lock`  
- **원인**: 리터럴 남발, Child 폭증  
- **조치**: 바인드, `session_cached_cursors`↑, DDL/통계 배치

---

## 11) 체크리스트(운영)

1) **탑다운**: AWR Top Events/SQL → ASH 라인 → 문제 SQL 집중  
2) **라인별 분석**: DBMS_XPLAN ‘ALLSTATS LAST’에서 **A-Rows vs Rows** 확인  
3) **대기-라인 연결**: SQL Monitor/ASH `sql_plan_line_id`  
4) **원인 카테고리화**: I/O/MVCC/락/로그/파싱/네트워크/클러스터  
5) **최소 변경으로 최대 효과**: 인덱스/통계/조인순/커밋 정책/키 분산  
6) **재현+회귀 방지**: 테스트로 Before/After 증명, 바인드 범주/데이터 편향 검토  
7) **관측 자동화**: 주기 ASH/AWR 스냅샷, 상위 5 이벤트/SQL 대시보드

---

## 12) 수학적 감각(개념)

- **총 지연 시간 근사**  
  $$ T_{\text{elapsed}} \approx T_{\text{CPU}} + \sum_i T_{\text{I/O}_i} + \sum_j T_{\text{Wait}_j} $$
- **정렬 스필 임계**(개념):  
  $$ \text{Needed\_PGA} \propto N \log N \quad (\text{행수 } N) $$
  실제는 **중간 카디널리티 오판**이 스필을 부릅니다 → **카디널리티 정확화가 최우선**.

---

## 13) 결론

- **대기 이벤트**는 “느림의 표지판”입니다. **표지판 → 실행계획 라인 → 원인**으로 **계통적으로 추적**하면 답이 보입니다.  
- **정확한 카디널리티, 올바른 접근경로, 적절한 커밋·키 분산·FK 인덱스·PGA/로그 설정**이 80%를 해결합니다.  
- **트레이스/모니터**는 “말 대신 증거”입니다. **ALLSTATS LAST + SQL Monitor + 10046** 3종 세트로 재현·증명하세요.

> 한 줄 정리  
> **이벤트를 읽고, 계획을 읽고, 라인을 고쳐라.**  
> 원인은 **데이터/통계/경합/구조**에 있고, 해법은 **작고 정확한 변경**에 있다.