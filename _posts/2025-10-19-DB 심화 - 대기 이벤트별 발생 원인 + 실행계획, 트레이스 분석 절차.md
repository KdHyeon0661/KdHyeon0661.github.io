---
layout: post
title: DB 심화 - 대기 이벤트별 발생 원인 + 실행계획/트레이스 분석 절차
date: 2025-10-19 22:25:23 +0900
category: DB 심화
---
# Oracle **대기 이벤트별 발생 원인 + 실행계획/트레이스 분석 절차** (19c 기준)

> 목표
> - 자주 만나는 **대기 이벤트(Wait Events)** 를 **원인·징후·진단 SQL·해결책**까지 표준 절차로 연결합니다.
> - **실행계획(Plan)** 과 **트레이스(10046/10053, SQL Monitor)** 를 묶어 **“이벤트 → 어느 Plan 라인에서 왜?”** 를 끝까지 추적합니다.
> - **예제 시나리오**(락 경합, 인덱스/정렬/해시, 로그 동기화, RAC, ITL 부족, 라이브러리/로우 캐시 등)를 제시합니다.

---

## 실전 진단 플로우 개요

효과적인 성능 문제 진단은 체계적인 접근에서 시작합니다. 다음은 현장에서 검증된 핵심 절차입니다.

1.  **증상 식별**: AWR/ASH 리포트를 확인하여 시스템 전반의 **상위 대기 이벤트**와 **문제 SQL**을 식별합니다.
2.  **대기 클래스 분류**: 이벤트를 **User I/O**, **Concurrency**, **Commit**, **Cluster** 등의 클래스로 분류하여 문제 영역을 좁힙니다.
3.  **문제 SQL 심층 분석**: `DBMS_XPLAN.DISPLAY_CURSOR`를 사용해 해당 SQL의 **실제 실행 통계가 포함된 실행 계획**을 확인합니다. 특히 **실제 반환 행수(A-Rows)** 와 옵티마이저의 **추정 행수(E-Rows)** 를 비교합니다.
4.  **대기와 실행 계획 라인 연결**: **SQL Monitor 리포트** 또는 **10046 트레이스**를 활용하여, 각 대기 이벤트가 실행 계획의 **어느 단계(Plan Line)** 에서 발생했는지를 정확히 매핑합니다.
5.  **근본 원인 도출 및 해결**: 연결된 정보를 바탕으로 원인(예: 인덱스 부재, 핫 블록, 과도한 파싱)을 특정하고, 표적화된 해결책(예: 인덱스 추가, 파티셔닝, 바인드 변수 사용)을 적용합니다.
6.  **개선 효과 검증**: 변경 사항 적용 후 성능을 재측정하고, AWR/SQL Monitor 리포트를 비교하여 개선 효과를 확인하고 회귀(Regression)를 방지합니다.

---

## 필수 진단 도구 활용법

### 시스템 및 세션 현황 파악
```sql
-- 시스템 누적 대기 이벤트 Top 10
SELECT event, wait_class, total_waits,
       ROUND(time_waited_micro / 1000000, 2) AS time_waited_secs
FROM   v$system_event
WHERE  wait_class != 'Idle'
ORDER  BY time_waited_micro DESC
FETCH FIRST 10 ROWS ONLY;

-- 현재 대기 중인 세션 실시간 조회
SELECT sid, serial#, username, event, state, seconds_in_wait, blocking_session, sql_id
FROM   v$session
WHERE  state = 'WAITING'
AND    wait_class != 'Idle'
ORDER  BY seconds_in_wait DESC;
```

### 실행 계획과 실제 실행 통계 확인
```sql
-- 특정 SQL의 실제 실행 계획 (실행 후 캐시에 있는 정보)
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(
    sql_id        => '&SQL_ID', -- 문제 SQL_ID 입력
    cursor_child_no => NULL,
    format        => 'ALLSTATS LAST +PEEKED_BINDS'
  )
);
```
- **핵심 포인트**: `A-Rows`(실제 처리 행) vs `E-Rows`(옵티마이저 예상 행)의 차이를 확인하세요. 큰 차이는 통계 부정확 또는 바인드 변수 편향을 의미합니다.

### 실시간 SQL 모니터링 및 트레이스
```sql
-- 1. SQL 모니터 활성화 (자동 또는 힌트로)
SELECT /*+ MONITOR */ * FROM your_table WHERE ...;

-- 2. 모니터링 중인 SQL 조회
SELECT sql_id, status, sql_text FROM v$sql_monitor;

-- 3. 10046 트레이스 활성화 (세션 단위, 상세 대기/바인드 정보)
EXEC DBMS_MONITOR.SESSION_TRACE_ENABLE(waits=>TRUE, binds=>TRUE);
-- ... 문제 작업 수행 ...
EXEC DBMS_MONITOR.SESSION_TRACE_DISABLE;
-- 생성된 트레이스 파일은 tkprof 유틸리티로 가독성 있게 변환
```

---

## 대기 이벤트별 상세 원인 분석 및 대응

### User I/O 계열: `db file sequential read`
- **의미**: 인덱스를 통한 조회 후, ROWID로 테이블 블록을 접근하는 등의 **단일 블록 읽기** 대기.
- **원인**: 비효율적인 인덱스 범위 스캔, 나쁜 클러스터링 팩터(Clustering Factor), 적은 버퍼 캐시 히트율.
- **진단**:
    - 실행 계획에서 `TABLE ACCESS BY INDEX ROWID` 단계의 `A-Rows`가 매우 많음.
    - `v$segment_statistics`에서 해당 오브젝트의 논리적/물리적 읽기 비율이 높음.
- **해결**:
    - **인덱스 설계 개선**: 조회 조건에 맞는 복합 인덱스 생성, 커버링 인덱스 사용 검토.
    - **통계 정확성**: 히스토그램 수집으로 데이터 분포를 정확히 반영.
    - **I/O 성능**: 스토리지 레이턴시 점검 및 최적화.

### User I/O 계열: `direct path read temp`
- **의미**: 정렬(SORT) 또는 해시 조인(HASH JOIN) 작업이 PGA 메모리를 초과하여 **임시(TEMP) 테이블스페이스**로 스필(Spill)될 때 발생.
- **원인**: 과대평가된 카디널리티로 큰 워크영역이 할당되거나, `PGA_AGGREGATE_TARGET`이 부족.
- **진단**:
    - 실행 계획의 `SORT ORDER BY` 또는 `HASH JOIN` 단계에서 `TempSpc` 사용량이 큼.
    - SQL Monitor에서 해당 단계의 대기 시간 대부분이 `direct path read temp`.
- **해결**:
    - **SQL 튜닝**: 불필요한 정렬 제거, 조인 순서 변경으로 드라이빙 집합(Driing Set) 축소.
    - **PGA 관리**: `PGA_AGGREGATE_TARGET`을 적절히 증가.
    - **통계/실행 계획**: 카디널리티 예측을 정확히 하도록 통계 보정 또는 힌트 사용.

### Concurrency 계열: `enq: TX - row lock contention`
- **의미**: 한 트랜잭션이 특정 행을 갱신 중일 때, 다른 트랜잭션이 동일 행을 갱신하려고 대기하는 **행 수준 잠금 경합**.
- **원인**: 동일 데이터에 대한 동시 업데이트, 외래 키 제약조건 컬럼에 인덱스 부재, 과도하게 긴 트랜잭션.
- **진단**:
    - `v$session`에서 `event`와 `blocking_session`을 확인.
    - `v$lock`을 조인하여 잠금을 보유 중인 세션과 SQL을 확인.
- **해결**:
    - **애플리케이션 설계**: 트랜잭션 길이 최소화, 접근 순서 표준화.
    - **데이터베이스 설계**: 모든 외래 키 컬럼에 인덱스 생성, 핫 로우 분산(예: 시퀀스 캐시 증가).
    - **모니터링**: `AWR`의 `Segments by Row Lock Waits` 섹션을 주기적으로 확인.

### Concurrency 계열: `buffer busy waits`
- **의미**: 여러 세션이 동시에 **같은 데이터 블록**에 접근하려고 할 때 발생하는 대기.
- **원인**: '핫 블록(Hot Block)' 현상(예: 시퀀스 기반 PK 인덱스의 리프 블록, 작은 참조 테이블), `INITRANS` 설정 부족.
- **진단**:
    - `v$segment_statistics`에서 `buffer busy waits`가 높은 오브젝트 식별.
    - `x$bh`(SYS 권한)를 조회하여 `TCH`(터치 카운트)가 높은 블록 확인.
- **해결**:
    - **설계 변경**: Reverse Key 인덱스, 해시 파티셔닝으로 블록 접근 분산.
    - **스토리지 매개변수 조정**: `INITRANS`, `PCTFREE` 값을 증가시켜 블록 내부 공간 경합 완화.

### Commit 계열: `log file sync`
- **의미**: 사용자 세션이 `COMMIT` 명령을 실행한 후, **LGWR 프로세스**가 해당 트랜잭션의 리두(Redo)를 디스크에 기록하기를 기다리는 대기.
- **원인**: 너무 잦은 커밋, 느린 리두 로그 디스크 I/O.
- **진단**:
    - `v$system_event`에서 `log file sync`의 평균 대기 시간 확인(일반적으로 5ms 미만이 바람직함).
    - 세션 통계(`v$sesstat`)에서 초당 커밋 횟수가 매우 높은 세션 확인.
- **해결**:
    - **애플리케이션 수정**: 가능한 경우 배치(Batch) 커밋으로 변경.
    - **시스템 구성**: 리두 로그 파일을 최고 성능의 스토리지(저지연 SSD)에 배치, 로그 파일 크기 적절화.

### Cluster(RAC) 계열: `gc buffer busy`
- **의미**: RAC 환경에서, 한 인스턴스가 다른 인스턴스가 보유한 버퍼 블록을 요청했으나, 해당 블록이 상대방 인스턴스에서 바쁜 상태(예: 변경 중)일 때 발생하는 대기.
- **원인**: 인스턴스 간에 공유되는 '핫 블록', 시퀀스 생성 시 `ORDER` 옵션 사용.
- **진단**:
    - ASH(`v$active_session_history`)에서 `event`와 `BLOCKING_INST_ID`를 확인.
    - `gc buffer busy` 이벤트의 `P1`(파일 번호), `P2`(블록 번호) 값을 통해 문제 블록 식별.
- **해결**:
    - **애플리케이션 아키텍처**: 서비스(Service)별로 데이터 접근을 분리(애플리케이션 컨테이너화).
    - **데이터 설계**: 시퀀스에 `NOORDER` 및 큰 `CACHE` 사용, 파티셔닝으로 데이터 로컬리티(Affinity) 강화.

---

## 실행 계획과 트레이스를 통한 근본 원인 추적

대기 이벤트는 '증상'입니다. '병인'을 찾기 위해서는 실행 계획과 트레이스 파일을 심층 분석해야 합니다.

### 실행 계획 분석 핵심
1.  **접근 경로(Access Path) 확인**: `FULL TABLE SCAN`이 예상보다 많다면 인덱스 검토가 필요합니다. `INDEX RANGE SCAN` 후 높은 `TABLE ACCESS BY INDEX ROWID` 비용은 클러스터링 팩터가 나쁨을 의미할 수 있습니다.
2.  **조인 방법(Join Method) 평가**: 대량의 데이터를 조인할 때 `HASH JOIN`이 `NESTED LOOPS`보다 효율적일 수 있지만, 드라이빙 테이블이 작다면 `NESTED LOOPS`가 더 나을 수 있습니다. 옵티마이저의 잘못된 선택을 `LEADING`, `USE_NL` 힌트로 보정할 수 있습니다.
3.  **카디널리티 불일치 탐지**: `A-Rows`와 `E-Rows`의 차이가 크다면 옵티마이저가 잘못된 결정을 내렸을 가능성이 높습니다. 이는 부정확한 통계, 히스토그램 부재, 바인드 변수 편향 때문일 수 있습니다.

### 10046 트레이스 분석
`tkprof`로 포맷팅한 트레이스 파일은 다음 정보를 제공합니다.
- **SQL 실행 단계별 소요 시간**: Parse, Execute, Fetch 각 단계에서 시간을 어디서 소모했는지 확인.
- **대기 이벤트 목록**: 각 호출(call)에서 발생한 대기 이벤트와 누적 시간을 라인별로 보여줍니다.
- **바인드 변수 값**: `BINDS #` 섹션에서 실제로 사용된 바인드 값을 확인하여 옵티마이저의 카디널리티 예측 오류 원인을 파악할 수 있습니다.

### 10053 트레이스 활용
옵티마이저가 특정 실행 계획을 선택한 근거를 알고 싶을 때 사용합니다. 통계 정보, 계산된 선택도(Selectivity), 비용(Cost) 계산 내역이 상세히 기록됩니다.
```sql
ALTER SESSION SET events '10053 trace name context forever, level 1';
-- 쿼리 실행
ALTER SESSION SET events '10053 trace name context off';
```
**주의**: 과도한 디버그 출력을 생성하므로, 테스트 환경에서 특정 문제 해결을 위해 제한적으로 사용하세요.

---

## 종합 결론: 구조적 문제 해결을 위한 사고방식

Oracle 성능 문제 해결은 단순히 대기 이벤트를 억제하는 기술이 아닙니다. 그것은 **데이터베이스 내부에서 발생하는 현상(대기 이벤트)** 을 관찰하고, 그것을 생성하는 **실행 엔진의 결정(실행 계획)** 을 분석하며, 그 결정의 근거가 된 **데이터의 특성(통계, 분포)** 과 **시스템의 제약(리소스, 설정)** 을 종합적으로 이해하는 구조적인 사고 과정입니다.

`db file sequential read`가 많다고 해서 무조건 인덱스를 추가하는 것이 답이 아닙니다. 그 이벤트가 발생하는 실행 계획 라인이 정말 필요한 작업인지, 옵티마이저가 데이터 양을 잘못 예측했는지(`A-Rows` vs `E-Rows`), 또는 인덱스 자체의 설계가 비효율적인지(클러스터링 팩터)를 먼저 질문해야 합니다.

마찬가지로 `log file sync` 대기는 항상 스토리지 문제만은 아닙니다. 애플리케이션이 1건마다 커밋하는 패턴을 100건 단위 배치 커밋으로 바꾸는 간단한 수정이 근본적인 해결책이 될 수 있습니다.

따라서 성능 튜닝의 최종 목표는 특정 이벤트의 숫자를 줄이는 것이 아니라, **업무 로직을 정확히 반영하면서 최소의 리소스로 완료되는 데이터 접근 경로**를 확보하는 데 있습니다. 이를 위해 AWR/ASH로 '거시적' 건강 상태를 점검하고, SQL Monitor와 트레이스로 '미시적' 실행 패턴을 들여다보며, 궁극적으로는 데이터 모델링, 인덱스 설계, 애플리케이션 코딩 패턴까지 영향을 미치는 **전체적인 관점**을 유지하는 것이 가장 중요합니다. 모든 훌륭한 튜닝은 정확한 관측에서 시작되며, 지속적인 검증으로 완성됩니다.