---
layout: post
title: JavaScript - 폼 처리와 유효성 검사
date: 2025-05-13 23:20:23 +0900
category: JavaScript
---
# 자바스크립트로 폼 처리와 유효성 검사

## HTML5 기본 폼과 제출 처리

```html
<form id="loginForm" action="/login" method="post" novalidate>
  <label>
    사용자명
    <input type="text" name="username" required minlength="3" autocomplete="username">
  </label>
  <label>
    비밀번호
    <input type="password" name="password" required minlength="6" autocomplete="current-password">
  </label>
  <button type="submit">로그인</button>
</form>
```

### 자바스크립트로 `submit` 처리

```js
const form = document.getElementById('loginForm');

form.addEventListener('submit', async (e) => {
  e.preventDefault();               // 기본 제출 방지(페이지 리로드 X)

  // 1) 내장 검증 먼저
  if (!form.checkValidity()) {
    form.reportValidity();          // 브라우저 기본 메시지/하이라이트
    return;
  }

  // 2) FormData 수집
  const data = new FormData(form);

  // 3) 전송 중 이중 제출 방지
  const submitBtn = form.querySelector('button[type="submit"]');
  submitBtn.disabled = true;

  try {
    const res = await fetch(form.action, { method: 'POST', body: data });
    if (!res.ok) throw new Error('서버 오류');
    // 성공 후 처리(리다이렉트/토스트)
  } catch (err) {
    console.error(err);
    // 실패 메시지 UI
  } finally {
    submitBtn.disabled = false;
  }
});
```

> `novalidate`는 브라우저 기본 팝업을 막고 JS로 컨트롤하려는 의도일 때 사용합니다. 기본 팝업을 활용하려면 제거하세요.

---

## Constraint Validation API — HTML만으로 되는 것들

### 필수 속성 요약

| 속성 | 설명 |
|---|---|
| `required` | 공란 금지 |
| `type="email|url|number|date|tel|password|color|…"` | 형식 검증/네이티브 키패드 |
| `min`, `max`, `step` | 수치/날짜/시간 범위 |
| `minlength`, `maxlength` | 문자열 길이 |
| `pattern="정규식"` | 커스텀 패턴(전체 일치) |
| `multiple` | 이메일/파일 복수 허용 |
| `accept` | 파일 타입 제한(`input[type=file]`) |
| `autocomplete` | 자동완성 힌트 |
| `inputmode`, `enterkeyhint` | 모바일 키보드/엔터 힌트 |

```html
<input type="email" required>
<input type="number" min="0" max="120" step="1">
<input type="text" pattern="^[a-zA-Z0-9]{5,}$">
<input type="file" accept=".png,.jpg" multiple>
```

### 상태/메서드

```js
const el = document.querySelector('input[name=email]');
el.validity;            // ValidityState (customError, valueMissing 등)
el.checkValidity();     // boolean
el.reportValidity();    // 메시지 + 하이라이트
el.setCustomValidity('에러 메시지');  // 커스텀 메시지 설정/초기화('')
```

### CSS로 즉각 피드백

```css
input:required:invalid { border-color: #d00; }
input:valid           { border-color: #0a0; }
input:focus:invalid   { outline-color: #d00; }
```

---

## 커스텀 유효성 검사 패턴들

### 인라인 에러 + 접근성(ARIA) 연동

```html
<form id="registerForm" novalidate>
  <label for="username">사용자명</label>
  <input id="username" name="username" required minlength="3" aria-describedby="usernameErr">
  <p id="usernameErr" class="err" role="alert" hidden></p>

  <label for="password">비밀번호</label>
  <input id="password" type="password" name="password" required minlength="8" aria-describedby="passwordErr">
  <p id="passwordErr" class="err" role="alert" hidden></p>

  <label for="confirm">비밀번호 확인</label>
  <input id="confirm" type="password" required aria-describedby="confirmErr">
  <p id="confirmErr" class="err" role="alert" hidden></p>

  <button type="submit">회원가입</button>
</form>
```

```js
const f = document.getElementById('registerForm');
const $ = (sel) => f.querySelector(sel);

const showError = (input, msg) => {
  const errId = input.getAttribute('aria-describedby');
  const errEl = errId && document.getElementById(errId);
  if (!errEl) return;
  errEl.textContent = msg;
  errEl.hidden = !msg;
  input.setAttribute('aria-invalid', msg ? 'true' : 'false');
};

const validators = {
  username(input) {
    const v = input.value.trim();
    if (!v) return '사용자명을 입력하세요.';
    if (v.length < 3) return '3자 이상이어야 합니다.';
    if (!/^[a-z0-9_]+$/i.test(v)) return '영문/숫자/밑줄만 허용됩니다.';
    return '';
  },
  password(input) {
    const v = input.value;
    if (v.length < 8) return '비밀번호는 8자 이상이어야 합니다.';
    if (!/[A-Z]/.test(v) || !/[0-9]/.test(v)) return '대문자와 숫자를 포함하세요.';
    return '';
  },
  confirm(confirmInput) {
    const v = confirmInput.value;
    if (v !== $('#password').value) return '비밀번호가 일치하지 않습니다.';
    return '';
  }
};

['input', 'blur'].forEach(evt =>
  f.addEventListener(evt, (e) => {
    if (!(e.target instanceof HTMLInputElement)) return;
    const id = e.target.id;
    if (id in validators) {
      const msg = validators[id](e.target);
      e.target.setCustomValidity(msg);
      showError(e.target, msg);
    }
  })
);

f.addEventListener('submit', (e) => {
  e.preventDefault();
  let ok = true;
  for (const id of Object.keys(validators)) {
    const input = document.getElementById(id);
    const msg = validators[id](input);
    input.setCustomValidity(msg);
    showError(input, msg);
    if (msg) ok = false;
  }
  if (!ok) {
    // 첫 에러로 포커스 이동
    const firstInvalid = f.querySelector('[aria-invalid="true"]');
    firstInvalid?.focus();
    return;
  }
  // fetch 전송 등
});
```

### 숫자/날짜 범위와 로케일

- `type="number"`는 문자열이 아닌 **숫자**를 요구합니다. 쉼표/로케일 구분자는 거절될 수 있으니, 로케일 입력 UI가 필요하면 텍스트 + 마스킹/파싱을 고려합니다.
- `type="date"`는 브라우저별 포맷 UI가 다릅니다. 국제화가 중요하면 **라이브러리(Flatpickr 등)** 또는 native + 보조 텍스트 힌트를 병행합니다.

---

## 비동기(서버) 검증 — 중복 아이디, 초대 코드 등

### 디바운스 + 중복 요청 취소(AbortController)

```js
const debounce = (fn, wait=300) => {
  let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
};

const nameInput = document.getElementById('username');
let ctrl = null;

const checkUsername = async (name) => {
  if (ctrl) ctrl.abort();                 // 이전 요청 취소
  ctrl = new AbortController();
  try {
    const res = await fetch(`/api/username/check?u=${encodeURIComponent(name)}`, {
      signal: ctrl.signal
    });
    if (!res.ok) throw new Error('네트워크');
    const { available } = await res.json();
    return available;
  } catch (e) {
    if (e.name === 'AbortError') return null; // 사용자가 더 타이핑함
    throw e;
  }
};

nameInput.addEventListener('input', debounce(async () => {
  const v = nameInput.value.trim();
  if (v.length < 3) return;
  const available = await checkUsername(v);
  if (available === null) return; // 취소된 요청
  const msg = available ? '' : '이미 사용 중인 아이디입니다.';
  nameInput.setCustomValidity(msg);
  showError(nameInput, msg);
}, 400));
```

---

## 폼 전송 — `FormData` vs JSON, 파일 업로드

### `FormData` (파일/멀티파트에 유리, 네이티브 폼과 친화)

```js
const form = document.querySelector('#profileForm');
form.addEventListener('submit', async (e) => {
  e.preventDefault();
  if (!form.checkValidity()) return form.reportValidity();

  const fd = new FormData(form);              // 파일 포함 자동 처리
  // 클라이언트 선검증
  const file = fd.get('avatar');
  if (file && file.size > 2 * 1024 * 1024) {  // 2MB
    alert('파일이 큽니다.');
    return;
  }

  const res = await fetch('/api/profile', { method: 'POST', body: fd });
  const out = await res.json();
  console.log(out);
});
```

### JSON (API 일관성/서버 파싱 단순)

```js
const data = Object.fromEntries(new FormData(form)); // name 속성이 키
const res = await fetch('/api/register', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data)
});
```

> 파일이 있으면 `FormData`, 순수 텍스트면 JSON이 일반적입니다.

### 더 나은 제출 트리거: `form.requestSubmit()`

```js
// 특정 버튼 name/value를 포함해 제출하고 싶을 때 유용
form.requestSubmit(form.querySelector('button[type=submit]'));
```

---

## 이중 제출 방지 & 네트워크 제어

- 제출 직후 `submit` 버튼을 **비활성**하고, 응답 시 복원
- **진행 표시(스피너)** 제공
- 같은 폼에서 재제출 시 이전 요청 **Abort**
- 타임아웃/재시도(지수 백오프) 정책

```js
const ctl = new AbortController();
setTimeout(() => ctl.abort(), 10000); // 10초 타임아웃

const res = await fetch(url, { method: 'POST', body: data, signal: ctl.signal });
```

---

## 파일 입력 고급 검증

```js
const fileInput = document.querySelector('input[type=file]');
fileInput.addEventListener('change', () => {
  const files = [...fileInput.files];
  if (files.length > 3) {
    alert('최대 3개까지만 업로드 가능합니다.');
    fileInput.value = '';
    return;
  }
  for (const f of files) {
    if (!/^image\/(png|jpeg)$/.test(f.type)) {
      alert('PNG/JPEG만 지원합니다.'); fileInput.value = ''; return;
    }
    if (f.size > 2 * 1024 * 1024) {
      alert('각 파일은 2MB 이하'); fileInput.value = ''; return;
    }
  }
});
```

> 미리보기가 필요하면 `URL.createObjectURL(file)` 또는 `FileReader`를 사용합니다.

---

## 보안 필수 사항(서버 검증은 **반드시**)

- **서버 측 유효성 검증**: 클라이언트 검증은 UX 개선일 뿐 신뢰하지 말 것
- **CSRF**: 토큰 + SameSite 쿠키, `fetch` 시 `credentials` 정책 주의
- **XSS**: 서버 렌더링 시 출력 이스케이프, 리치 텍스트는 sanitize
- **Rate limiting**: 제출/검증 API 남용 방지
- **인증/권한**: 서버에서 최종 판단
- **파일**: 서버에서 MIME/확장자/크기 검증, 이미지 디코드/재인코딩으로 매직바이트 우회 방지

---

## 접근성(Accessibility) — 에러 전달과 포커스

- 레이블은 **반드시** `<label for>` 또는 래핑으로 연결
- 에러 텍스트는 `aria-describedby`로 필드와 연결, 에러 발생 시 `aria-invalid="true"`
- 제출 실패 시 **상단 에러 요약**에 `role="alert"`/`aria-live="assertive"`로 알림
- 첫 번째 에러 필드로 **포커스 이동**

```html
<div id="errorSummary" role="alert" aria-live="assertive" hidden></div>
```

```js
function showSummary(errors) {
  const box = document.getElementById('errorSummary');
  box.innerHTML = `<ul>${errors.map(e => `<li>${e}</li>`).join('')}</ul>`;
  box.hidden = errors.length === 0;
  if (errors.length) box.focus();
}
```

---

## UX 패턴 — 실시간/지연 피드백, 마스킹, 포맷팅

- **실시간** 검증: `input` 이벤트로 즉시 피드백(너무 잦으면 디바운스)
- **지연** 검증: `blur`에서만 에러 노출(입력 중 스트레스 감소)
- **입력 마스킹**: 전화/카드번호는 보기 좋게 포맷(저장 전 정규화)
- **에러 문구는 구체적으로**: “형식이 잘못되었습니다” 대신 “영문 5자 이상”

---

## 고급 이벤트 — `invalid`, `input`, `change`, `beforeinput`

```js
// 브라우저 내장 검증 실패 시 각 필드에서 발생(버블링 안 함)
form.addEventListener('invalid', (e) => {
  const el = e.target;
  // 사용자 정의 메시지 로그 등
}, true); // 캡처 단계에서 듣기

// 입력값 변경 직후(IME 완료) — 실시간 검증
input.addEventListener('input', handle);

// 값 변경 직전(취소 가능) — 리치 에디터에서 중요
input.addEventListener('beforeinput', (e) => {
  if (/* 허용하지 않는 삽입/삭제 */) e.preventDefault();
});
```

---

## 다중 스텝 폼(위자드) — 단계별 검증

```js
let step = 0;
const steps = [...document.querySelectorAll('.step')];
function show(i) { steps.forEach((s, idx) => s.hidden = idx !== i); }

document.getElementById('next').addEventListener('click', () => {
  const current = steps[step];
  // 현재 단계 유효성 체크
  if (!current.querySelector('form')?.checkValidity()) {
    current.querySelector('form')?.reportValidity();
    return;
  }
  step = Math.min(step + 1, steps.length - 1);
  show(step);
});
```

---

## 예제 — 실전 회원가입 폼(로컬+서버 검증, 파일 포함)

```html
<form id="signUp" action="/api/register" method="post" enctype="multipart/form-data" novalidate>
  <label for="email">이메일</label>
  <input id="email" name="email" type="email" required aria-describedby="emailErr" autocomplete="email">
  <p id="emailErr" class="err" hidden></p>

  <label for="nick">닉네임</label>
  <input id="nick" name="nick" required minlength="3" maxlength="20" aria-describedby="nickErr" autocomplete="nickname">
  <p id="nickErr" class="err" hidden></p>

  <label for="pwd">비밀번호</label>
  <input id="pwd" name="pwd" type="password" required minlength="8" aria-describedby="pwdErr" autocomplete="new-password">
  <p id="pwdErr" class="err" hidden></p>

  <label for="avatar">아바타(선택, PNG/JPEG, ≤2MB)</label>
  <input id="avatar" name="avatar" type="file" accept="image/png,image/jpeg" aria-describedby="avatarErr">
  <p id="avatarErr" class="err" hidden></p>

  <button type="submit">가입</button>
  <div id="sum" role="alert" aria-live="assertive" hidden></div>
</form>
```

```js
const form = document.getElementById('signUp');
const byId = (id) => document.getElementById(id);
const err = (id, msg='') => { const el = byId(id); el.textContent = msg; el.hidden = !msg; };

const ctrl = new AbortController();
const de = (fn, ms=400) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; };

const validate = {
  async email() {
    const el = byId('email'); const v = el.value.trim();
    if (!v) return '이메일을 입력하세요.';
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v)) return '이메일 형식이 올바르지 않습니다.';
    // 서버 중복검사(디바운스/취소 포함)
    try {
      const res = await fetch(`/api/email/check?e=${encodeURIComponent(v)}`, { signal: ctrl.signal });
      const { available } = await res.json();
      if (!available) return '이미 사용 중인 이메일입니다.';
    } catch (_) { /* 네트워크 오류는 폼 제출 시 재검증 */ }
    return '';
  },
  nick() {
    const el = byId('nick'); const v = el.value.trim();
    if (v.length < 3) return '닉네임은 3자 이상';
    if (!/^[\p{L}\p{N}_-]+$/u.test(v)) return '문자/숫자/언더스코어/대시만 허용';
    return '';
  },
  pwd() {
    const v = byId('pwd').value;
    if (v.length < 8) return '8자 이상';
    if (!/[A-Z]/.test(v) || !/[0-9]/.test(v)) return '대문자와 숫자를 포함';
    return '';
  },
  avatar() {
    const f = byId('avatar').files?.[0];
    if (!f) return '';
    if (!/^image\/(png|jpeg)$/.test(f.type)) return 'PNG/JPEG만 허용';
    if (f.size > 2*1024*1024) return '2MB 이하만 허용';
    return '';
  }
};

const bindField = (id, fn, errId) => {
  const run = async () => {
    const msg = await fn();
    byId(id).setCustomValidity(msg);
    err(errId, msg);
    byId(id).setAttribute('aria-invalid', msg ? 'true' : 'false');
    return msg;
  };
  byId(id).addEventListener('input', de(run, 350));
  byId(id).addEventListener('blur', run);
  return run;
};

const runEmail = bindField('email', validate.email, 'emailErr');
const runNick  = bindField('nick',  () => Promise.resolve(validate.nick()), 'nickErr');
const runPwd   = bindField('pwd',   () => Promise.resolve(validate.pwd()),  'pwdErr');
const runAvt   = bindField('avatar',() => Promise.resolve(validate.avatar()), 'avatarErr');

form.addEventListener('submit', async (e) => {
  e.preventDefault();

  const results = await Promise.all([runEmail(), runNick(), runPwd(), runAvt()]);
  const errors = results.filter(Boolean);
  if (errors.length) { form.reportValidity(); return; }

  const fd = new FormData(form);
  const submitBtn = form.querySelector('button[type=submit]');
  submitBtn.disabled = true;

  try {
    const res = await fetch(form.action, { method: 'POST', body: fd });
    const data = await res.json();
    if (!res.ok || data.error) throw new Error(data.error || '등록 실패');
    byId('sum').hidden = false;
    byId('sum').textContent = '가입 완료!';
    form.reset();
  } catch (errObj) {
    byId('sum').hidden = false;
    byId('sum').textContent = String(errObj.message || errObj);
  } finally {
    submitBtn.disabled = false;
  }
});
```

---

## 스타일/상태 — 집중/오류/완료

```css
.err { color: #a40000; margin: 4px 0 12px; }
input[aria-invalid="true"] { border-color: #d33; }
input:focus-visible { outline: 2px solid #0a7; outline-offset: 2px; }
button[disabled] { opacity: .6; cursor: not-allowed; }
```

---

## 실무 팁 모음

- **서버 에러 맵핑**: `{ field: 'email', message: '이미 사용 중' }[]` → 각 필드 오류 라벨에 반영
- **주소/전화/카드**: 입력 **정규화** 후 검증(공백/대시 제거)
- **국제화**: 에러 메시지는 키 기반 번역 테이블에서 가져오기
- **진행 표기**: 제출 중 버튼 내 스피너 SVG 삽입
- **프로그레시브 향상**: JS 미사용 시에도 `<form action method>`가 동작하도록 유지

---

## 테스트 전략

- 단위: 커스텀 검증 함수에 다양한 케이스 투입
- E2E: Cypress/Playwright로
  - 필수값 누락 → 제출 → 인라인 에러/포커스 이동 확인
  - 서버 중복 검증 모킹 → 메시지 확인
  - 파일 사이즈/타입 위반 → 메시지 확인
  - 성공 플로우 → 리다이렉트/토스트 확인

---

## 요약

- **먼저 HTML**로 가능한 검증을 모두 선언하라.
- 부족한 부분은 **JS 커스텀 검증**과 **서버 검증**으로 보완하라.
- **UX/접근성**을 위해 인라인 피드백, 에러 요약, 포커스 이동, 라이브 리전을 제공하라.
- **보안**(서버 재검증/CSRF/XSS/파일 검증)과 **성능**(디바운스/AbortController/이중 제출 방지)을 함께 고려하라.
- 테스트로 신뢰도를 확보하라.

---

## 부록 A) 공통 유틸 스니펫

```js
export const formToJSON = (form) =>
  Object.fromEntries(new FormData(form));

export const normalizePhone = (s) =>
  s.replace(/[^\d]/g, '');

export const required = (v, msg='필수 입력입니다.') =>
  v?.trim() ? '' : msg;

export const minLen = (n, msg) => (v) =>
  (v?.length ?? 0) >= n ? '' : (msg || `${n}자 이상`);

export const compose = (...rules) => (v) =>
  rules.map(r => r(v)).find(Boolean) || '';
```

---

## 부록 B) `pattern` 자주 쓰는 정규식

| 목적 | 정규식 |
|---|---|
| 영문/숫자 5자 이상 | `^[A-Za-z0-9]{5,}$` |
| 한국 휴대전화(단순) | `^01[016789]-?\d{3,4}-?\d{4}$` |
| 닉네임(문자/숫자/_/-) | `^[\p{L}\p{N}_-]{3,20}$` (u 플래그 필요) |

> **주의**: 정규식은 서비스 정책/국제화에 맞게 조정하세요.

---

## 부록 C) fetch 에러 매핑 예시(JSON API)

```js
const res = await fetch('/api/register', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(formToJSON(form)) });
const payload = await res.json();
if (!res.ok) {
  if (payload.errors?.length) {
    // [{ field: 'email', message: '이미 사용 중' }, ...]
    for (const { field, message } of payload.errors) {
      const input = form.querySelector(`[name="${field}"]`);
      const id = input?.getAttribute('aria-describedby');
      input?.setCustomValidity(message);
      id && (document.getElementById(id).textContent = message, document.getElementById(id).hidden = false);
    }
    form.reportValidity();
  } else {
    // 글로벌 에러
    const sum = document.getElementById('sum');
    sum.hidden = false;
    sum.textContent = payload.message || '요청 처리 실패';
  }
  return;
}
```

이제 어떤 종류의 폼이든, **선언적 검증 → 커스텀 로직 → 서버 검증 → 접근성/UX → 보안/성능**까지 균형 잡힌 흐름으로 구현할 수 있습니다.
