---
layout: post
title: 파이썬 - 모듈 (1)
date: 2024-08-14 19:20:23 +0900
category: Python
---
# 파이썬 모듈 — import 시스템

## 빠른 정의

- **모듈(module)**: 하나의 `.py` 파일.
- **패키지(package)**: 모듈(또는 하위 패키지)을 담는 **디렉터리**. 보통 `__init__.py`가 있으면 전통적 패키지, 없어도 **네임스페이스 패키지**(PEP 420)일 수 있음.
- **import**: 다른 모듈(패키지)을 현재 모듈의 네임스페이스로 불러오기.

```python
# mymath.py  (모듈)

def add(a, b):
    return a + b
```

```python
# main.py

import mymath
print(mymath.add(3, 5))  # 8
```

---

## import의 다양한 형태와 의미

### 기본 import

```python
import math
print(math.sqrt(16))  # 4.0
```

### from-import (부분 심볼만 가져오기)

```python
from math import sqrt, pi
print(sqrt(16), pi)
```

### 별칭(alias)

```python
import numpy as np
import math as m
print(m.pi)
```

### 와일드카드 (비추천)

```python
from math import *
# 가독성/충돌 위험. 교육용 외에는 피하세요.

```

**가이드**: 팀 코딩에선 **명시적 import**가 유지보수/정적분석/IDE 도움에 유리합니다.

---

## `__name__ == "__main__"`의 의미

```python
# demo.py

def run():
    print("실행됨")

if __name__ == "__main__":  # 직접 실행 시에만 발화
    run()
```

- `python demo.py` → `"실행됨"` 출력
- `import demo` → **조용함** (초기화 코드가 main에서만 수행)

**패턴**: 모듈 파일에 **실행 진입점**을 넣어 CLI 스크립트처럼도 사용.

---

## 표준 라이브러리 맛보기 (샘플)

```python
import os, sys, math, random, datetime, itertools, collections, pathlib

print(random.choice(["a", "b", "c"]))
print(datetime.datetime.now())
p = pathlib.Path.cwd() / "data" / "file.txt"
print(p)
```

> 실무에선 `pathlib`를 적극 권장(문자열 경로보다 안전·가독성↑).

---

## 사용자 정의 모듈 & 패키지

### 단일 모듈

```
project/
  main.py
  utils.py
```

```python
# utils.py

def hello(): print("안녕하세요")
```

```python
# main.py

import utils
utils.hello()
```

### 패키지 구조(전통적 패키지)

```
project/
  main.py
  mypkg/
    __init__.py
    mathx.py
    textx.py
```

```python
# mypkg/mathx.py

def add(a, b): return a + b
```

```python
# mypkg/__init__.py

from .mathx import add           # 패키지 루트에서 바로 노출
__all__ = ["add"]                # from mypkg import * 의 공개 심볼
```

```python
# main.py

from mypkg import add
print(add(2, 3))
```

### 네임스페이스 패키지(PEP 420)

- `__init__.py` **없어도** 동작.
- 여러 디렉터리에 **같은 패키지명**을 분산 배치 가능(플러그인 구조에 유용).

```
plugins_a/myext/foo.py
plugins_b/myext/bar.py
# 둘 다 myext 패키지의 일부가 됨

```

> 단, 일부 툴/구버전 호환성 고려. 배포/도구 체인은 최신 기반 추천.

---

## import가 실제로 동작하는 순서 (로더/파인더, 캐시)

1. **캐시 확인**: `sys.modules`에 이미 로드된 모듈이 있으면 **그 객체를 재사용**.
2. **모듈 탐색**: `sys.meta_path`의 **파인더**들이 경로(`sys.path`)에서 모듈 위치 검색.
3. **로딩**: 찾으면 **로더**가 바이트코드/소스 읽고 모듈 객체 생성, **`sys.modules[name]`에 등록**.
4. **실행**: 모듈 코드가 **한 번 실행**되며 전역이 채워짐.

```python
import sys, math
print("math in sys.modules:", "math" in sys.modules)  # True
```

### `sys.path` 이해

- 모듈 탐색 경로 리스트. **현재 스크립트 디렉터리**, 표준 라이브러리 경로, site-packages 등이 들어감.
- 런타임에 수정 가능하지만(교육/실험용), **패키징으로 풀 것**을 권장.

```python
import sys, pathlib
sys.path.append(str(pathlib.Path(__file__).parent / "vendor"))
```

> 실무에서는 **가상환경+정상 배포**로 경로 꼬임을 피하세요.

---

## 절대 import vs 상대 import

### 절대 import(권장)

```python
# package.subpkg.mod 처럼 루트부터 전체 경로

from mypkg.mathx import add
```

### 상대 import(패키지 내부 전용)

```python
# mypkg/textx.py 내부

from .mathx import add           # 같은 패키지
from ..common.logx import log     # 한 단계 위 패키지의 common.logx
```

> **상대 import는 패키지 안에서만**. **스크립트로 직접 실행**하면 상대 기준이 깨질 수 있어 `python -m package.module` 방식 사용.

---

## 문제와 해결 패턴

### 증상

- `A`가 `B`를 import, `B`가 다시 `A` import → 로딩 중간 상태로 **AttributeError** 등.

### 회피 전략

1. **구조 재설계**: 공통 의존은 상위 모듈/패키지로 분리.
2. **런타임 import**: 함수/메서드 내부에서 필요할 때 import.

```python
# runtime_import.py

def use_heavy():
    from heavy.module import run   # 함수 안에서 import
    return run()
```

3. **타입힌트 전용 import는 지연**: `if TYPE_CHECKING:` 블록 사용.

```python
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .models import User   # 런타임엔 불러오지 않음(순환 방지)
```

---

## 모듈 재로드: `importlib.reload`

- 디버깅/REPL에서 모듈 수정 후 **다시 읽기**.

```python
import importlib, mypkg.mathx as mathx
# ... mathx 소스 수정 후

importlib.reload(mathx)
```

> 프로덕션에서는 재로드보단 **프로세스 재시작**이 예측 가능.

---

## 모듈 속성과 메타 데이터

```python
# any_module.py

print(__name__)      # 모듈 이름 (직접 실행 시 "__main__")
print(__package__)   # 패키지 경로 접두사
print(__file__)      # 파일 경로
print(__spec__)      # import 사양(파인더/로더 정보)
```

- `__all__`: `from module import *` 시 **공개할 심볼 목록**.

```python
__all__ = ["public_api", "CONST"]
```

---

## 실행 스크립트로 모듈 구동: `-m` 스위치

```
project/
  -m_pkg/
    __init__.py
    __main__.py
```

```bash
python -m m_pkg           # __main__.py 가 entry
python -m http.server     # 표준 라이브러리도 동일 방식
```

> 패키지를 **실행 단위**로 설계할 때 유용.

---

## 성능/메모리/보안 팁

- **지연 import**: 무거운 의존성은 함수 내부에서 import → 시작 속도↑, 불필요 의존 회피.
- **순수 데이터는 코드로 두지 않기**: 큰 상수 테이블은 **외부 파일+lazy load**.
- **`from x import *` 지양**: 네임스페이스 오염/정적분석 저해.
- **경로 주입(`sys.path.insert(0, ...)`) 남용 금지**: 충돌/예측 불가.
- **신뢰할 수 없는 문자열에 `eval` 금지**: 필요 시 `ast.literal_eval` 고려.

---

## 가상환경과 의존성 관리(기본기)

```bash
# venv 생성/활성화

python -m venv .venv
# Windows: .venv\Scripts\activate
# macOS/Linux:

source .venv/bin/activate

pip install requests
pip freeze > requirements.txt
```

> 팀/배포 표준으론 **pip-tools, Poetry, Hatch, PDM** 등도 검토.

---

## 기초: `pyproject.toml` (PEP 517/518)

```
yourlib/
  yourlib/
    __init__.py
    core.py
  tests/
  pyproject.toml
  README.md
  LICENSE
```

**최소 예시 (`pyproject.toml`)**

```toml
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "yourlib"
version = "0.1.0"
description = "Example library"
readme = "README.md"
requires-python = ">=3.10"
authors = [{ name = "You", email = "you@example.com" }]
dependencies = ["requests>=2.32"]

[project.urls]
Homepage = "https://example.com"

[project.scripts]
yourlib-cli = "yourlib.core:main"   # 엔트리 포인트(콘솔 스크립트)
```

빌드/설치:

```bash
pip install build
python -m build           # dist/*.whl, *.tar.gz 생성
pip install dist/yourlib-0.1.0-py3-none-any.whl
```

> 콘솔 스크립트는 `python -m yourlib` 없이 `yourlib-cli`로 바로 실행.

---

## 테스트 가능한 모듈 설계(실전 팁)

- 모듈 상단에서 **무거운 작업(네트워크/대용량 로딩)** 수행하지 않기.
- 함수로 **사이드이펙트를 감싸고**, 테스트에서 **주입/모킹** 가능하게.
- `if __name__ == "__main__":` 블록에 **데모/CLI** 배치.

```python
# exporter.py

def export(data, *, storage):
    storage.save(data)  # 의존성 주입

if __name__ == "__main__":
    from mypkg.backends import LocalStorage
    export({"x": 1}, storage=LocalStorage("./out"))
```

---

## 예제: 플러그인 구조(네임스페이스 패키지 + entry_points)

```
myapp/
  pyproject.toml
  myapp/
    __init__.py
    core.py

myapp-plugin-a/
  pyproject.toml
  myapp_plugin_a/
    __init__.py
    a.py
```

`pyproject.toml` (플러그인 쪽):

```toml
[project.entry-points."myapp.plugins"]
plugin_a = "myapp_plugin_a.a:register"
```

`myapp/core.py`:

```python
import importlib.metadata as md

def load_plugins():
    for ep in md.entry_points(group="myapp.plugins"):
        plugin = ep.load()
        plugin()  # 각 플러그인의 register() 호출

def main():
    print("myapp start")
    load_plugins()
```

> 플러그인은 독립 배포/설치되면서 메인 앱이 **엔트리 포인트 그룹**으로 자동 탐색.

---

## 모듈 단위 실수 방지 체크리스트

- [ ] **상대 import**는 패키지 내부에서만. 실행은 `python -m pkg.mod`.
- [ ] 무거운 작업은 **함수/클래스 진입 시**로 미루기(지연 import).
- [ ] **`__all__`**로 공개 API 통제.
- [ ] `sys.path` 조작 최소화, 대신 **정상 패키징**.
- [ ] 순환 의존은 **구조 재배치** + `TYPE_CHECKING` + 런타임 import로 차단.
- [ ] `__main__` 블록에서만 실행 코드를 두기.
- [ ] 가상환경/고정 의존성으로 **재현 가능 빌드** 확보.
- [ ] 배포는 **wheel**(바이너리) 우선.

---

## 작은 실습 세트

### 패키지 루트에서 API 정리

```
calc/
  __init__.py
  ops.py
```

```python
# calc/ops.py

def add(a, b): return a + b
def sub(a, b): return a - b
```

```python
# calc/__init__.py

from .ops import add, sub
__all__ = ["add", "sub"]
```

```python
# 사용

from calc import add
print(add(10, 2))
```

### 순환 회피

```
app/
  __init__.py
  models.py
  services.py
```

```python
# models.py

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .services import Repo   # 타입체커만 사용

class User: ...
```

```python
# services.py

from .models import User
class Repo:
    def get(self, uid: int) -> User: ...
```

---

## 요약

| 주제 | 핵심 요점 |
|---|---|
| import 기본 | 명시적/부분/별칭 import, `*` 지양 |
| 실행 제어 | `if __name__ == "__main__":` |
| 탐색/로드 | `sys.path`·파인더/로더·`sys.modules` 캐시 |
| 패키지 | 전통적 패키지(`__init__.py`) vs 네임스페이스(PEP 420) |
| 절대/상대 import | 절대 권장, 상대는 패키지 내부에서만 |
| 순환 의존 | 구조 재설계·런타임 import·`TYPE_CHECKING` |
| 재로드 | `importlib.reload` (개발/REPL용) |
| 공개 API | `__all__`로 통제 |
| 가상환경/배포 | venv + `pyproject.toml` + wheel |
| 엔트리 포인트 | `-m` 실행, 콘솔 스크립트(entry points) |
| 성능/보안 | 지연 import, 경로 주입 자제, eval 금지 |

---

## 부록: 자주 쓰는 코드 스니펫

```python
# 안전한 지연 import

def heavy_task():
    import pandas as pd
    ...

# 타입 힌트 순환 방지

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .domain import Entity

# 패키지 실행
# python -m yourpkg.cli

# 공개 API

__all__ = ["foo", "Bar"]

# REPL에서 수정 후 재로드

import importlib, mypkg.foo as foo
importlib.reload(foo)
```
