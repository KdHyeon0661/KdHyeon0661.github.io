---
layout: post
title: MFC - 간단 에디터
date: 2025-09-17 22:25:23 +0900
category: MFC
---
# “간단 에디터(SDI)” 실전 가이드 — 문서/뷰, 직렬화, MRU, 인쇄까지 한 번에  
_MFC SDI · `CDocument`/`CView`/`CFrameWnd` · CArchive 직렬화 · MRU(최근 문서) · 프린트/프리뷰 파이프라인_

> 목표: **메모장처럼 가볍지만** SDI 문서/뷰 구조·직렬화·인쇄 같은 **프레임워크 표준 기능**을 모두 갖춘 “간단 텍스트/리치 에디터”를 설계·구현합니다.  
> 본문은 **구조 → 수명주기 → 직렬화 → MRU → 인쇄/프리뷰 → UX 세부 → 트러블슈팅** 순서로, **전체 흐름을 깨지지 않게** 설명합니다.  
> 샘플은 **유니코드 텍스트 에디터**를 기본으로, 옵션으로 **RTF/바이너리 설정**까지 확장합니다.

---

## 0. 완성 UX 한 장 요약

- SDI(문서 1개) + 메뉴/툴바: **새로 만들기/열기/저장/다른 이름으로 저장**, **인쇄/프리뷰**  
- **상태 표시줄**: 줄/열, 변경 상태(●), 인코딩(UTF-8/UTF-16), CRLF/LF  
- **MRU(최근 문서)** 4~10개 자동 관리  
- **변경 감지**: 수정 시 제목에 `*` 표시, 닫기/새문서/열기/종료 시 저장 확인  
- **인쇄**: 헤더(파일명/날짜), 푸터(페이지 X/Y), 페이지 매김, 프리뷰  
- **직렬화**: 텍스트 파일(UTF-8 BOM/무BOM 자동 감지), 선택적으로 RTF/바이너리 설정 저장

---

## 1. 프로젝트 뼈대 구조

```
/SimpleEditor
  ├─ App.h / App.cpp          // CWinApp 派生: InitInstance, 명령 라우팅 허브, MRU/레지스트리
  ├─ MainFrm.h / MainFrm.cpp  // CFrameWnd: 메뉴/툴바/상태바, 클라이언트 영역에 View 부착
  ├─ Doc.h / Doc.cpp          // CDocument: 데이터(텍스트/메타), 직렬화(파일 I/O), 변경 플래그
  ├─ View.h / View.cpp        // CView(or CEditView/CScrollView): 화면 표시/편집, OnDraw/입력
  ├─ Resource.h, .rc          // 메뉴/툴바/아이콘/문자열, DocString
  └─ AboutDlg.(h/cpp)         // 정보 대화상자(선택)
```

**클래스 선택**
- 가장 간단: **`CEditView`** 기반(Win32 Edit 컨트롤 래핑) → 텍스트 편집이 즉시 가능  
- 커스터마이즈가 많다면: **`CView`** + 자체 렌더/텍스트 버퍼 → 스크롤/줄 번호/하이라이트 확장 용이  
- 본문은 “**가볍게 시작**(CEditView) → **점진 확장**(CView 커스텀)” 전략으로 설명합니다.

---

## 2. App 초기화와 DocTemplate 연결

### 2-1. `CWinApp::InitInstance` 핵심

```cpp
BOOL CSimpleEditorApp::InitInstance() {
    CWinApp::InitInstance();

    // 1) 공용 컨트롤 초기화(비주얼 스타일)
    INITCOMMONCONTROLSEX icc{ sizeof(icc), ICC_WIN95_CLASSES|ICC_STANDARD_CLASSES };
    InitCommonControlsEx(&icc);

    // 2) 레지스트리 키(회사/제품) 설정: MFC 프로필 API의 루트
    SetRegistryKey(L"DoHyun\\SimpleEditor");

    // 3) MRU 목록 등록 (4~10개)
    LoadStdProfileSettings(8); // 8개 MRU

    // 4) DocTemplate 등록(SDI)
    auto pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,                       // DocString과 메뉴/툴바 리소스를 묶는 ID
        RUNTIME_CLASS(CSimpleEditorDoc),     // 문서
        RUNTIME_CLASS(CMainFrame),           // 프레임
        RUNTIME_CLASS(CSimpleEditorView));   // 뷰 (CEditView 기반)
    AddDocTemplate(pDocTemplate);

    // 5) 명령라인 파싱(파일 더블클릭/쉘 연계 등)
    CCommandLineInfo cmdInfo; ParseCommandLine(cmdInfo);

    // 6) 첫 문서 열기 (새문서 or 파일)
    if (!ProcessShellCommand(cmdInfo)) return FALSE;

    // 7) 창 보이기
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();
    return TRUE;
}
```

**DocString 리소스(IDR_MAINFRAME)**
```
IDR_MAINFRAME STRINGTABLE 
"SimpleEditor\nSimpleEditor\nSimpleEditor Files (*.txt)\n.txt\nSimpleEditor.Document\nSimpleEditor Document"
```
- **확장자/필터**가 파일 대화상자에 반영, 창 타이틀 형식에도 사용됩니다.

---

## 3. 문서/뷰/프레임의 역할 분리

### 3-1. `CDocument` (Doc): 데이터·파일 I/O·변경 플래그

```cpp
class CSimpleEditorDoc : public CDocument {
    DECLARE_DYNCREATE(CSimpleEditorDoc)
public:
    CStringW m_text;        // 현재 문서 텍스트(UTF-16)
    UINT     m_encoding = 65001; // CP_UTF8 등 표시용 메타 (선택)
    BOOL OnNewDocument() override;
    void Serialize(CArchive& ar) override; // 파일 저장/로드
};
```

- **변경 감지**: `SetModifiedFlag(TRUE/FALSE)`  
- **뷰 브로드캐스트**: 데이터 바뀌면 `UpdateAllViews(nullptr, HINT_TEXT, nullptr)`

### 3-2. `CView` (View): 표시/편집/인쇄

- **`CEditView`**를 상속하면 `GetEditCtrl()`로 텍스트 접근 가능  
- 바인딩:
  - 문서→뷰 표시: `OnInitialUpdate()` 때 문서 내용 SetWindowText  
  - 뷰→문서 반영: **저장 직전**, 혹은 `EN_CHANGE`에서 문서의 변경 플래그 갱신

```cpp
class CSimpleEditorView : public CEditView {
    DECLARE_DYNCREATE(CSimpleEditorView)
public:
    void OnInitialUpdate() override {
        CEditView::OnInitialUpdate();
        auto pDoc = GetDocument();
        GetEditCtrl().SetWindowTextW(pDoc->m_text);
    }
    void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) override {
        if (lHint==HINT_TEXT) GetEditCtrl().SetWindowTextW(GetDocument()->m_text);
    }
    CSimpleEditorDoc* GetDocument() const { return static_cast<CSimpleEditorDoc*>(m_pDocument); }
};
```

### 3-3. `CFrameWnd` (Frame): 메뉴/툴바/상태바·레이아웃

- 상태바에 “줄:열, 인코딩, 변경상태” 표시  
- `OnUpdateCommandUI`로 활성/비활성 관리

---

## 4. 수명 주기 — 새문서/열기/저장/닫기

### 4-1. 새 문서

```cpp
BOOL CSimpleEditorDoc::OnNewDocument() {
    if (!CDocument::OnNewDocument()) return FALSE;
    m_text.Empty();
    m_encoding = 65001;     // 기본 UTF-8
    SetModifiedFlag(FALSE);
    return TRUE;
}
```

### 4-2. 열기/저장(IMPT) — `Serialize(CArchive&)`

- **텍스트 파일**을 기본으로, **UTF-8 BOM/UTF-16 BOM/ANSI** 자동 감지  
- 저장은 **UTF-8(BOM)** 권장(교차 에디터 호환)

```cpp
void CSimpleEditorDoc::Serialize(CArchive& ar) {
    if (ar.IsStoring()) {
        // 저장: UTF-8 with BOM
        CFile* f = ar.GetFile(); ASSERT(f);
        static const BYTE bom[] = {0xEF,0xBB,0xBF};
        f->Write(bom, sizeof(bom));
        // UTF-16 → UTF-8
        int need = WideCharToMultiByte(CP_UTF8,0,m_text, (int)m_text.GetLength(), NULL, 0, NULL, NULL);
        std::string u8; u8.resize(need);
        WideCharToMultiByte(CP_UTF8,0,m_text, (int)m_text.GetLength(), u8.data(), need, NULL, NULL);
        f->Write(u8.data(), (UINT)u8.size());
        SetModifiedFlag(FALSE);
    } else {
        // 로드
        CFile* f = ar.GetFile(); ASSERT(f);
        ULONGLONG sz = f->GetLength();
        std::string buf; buf.resize((size_t)sz);
        f->Read(buf.data(), (UINT)sz);

        // BOM 검사
        const BYTE* p = (const BYTE*)buf.data();
        if (sz >= 3 && p[0]==0xEF && p[1]==0xBB && p[2]==0xBF) { // UTF-8 BOM
            m_encoding = 65001;
            int need = MultiByteToWideChar(CP_UTF8,0, (LPCSTR)p+3, (int)sz-3, NULL, 0);
            m_text.SetString(L'\0', need);
            MultiByteToWideChar(CP_UTF8,0, (LPCSTR)p+3, (int)sz-3, m_text.GetBuffer(), need);
        } else if (sz >= 2 && p[0]==0xFF && p[1]==0xFE) { // UTF-16 LE
            m_encoding = 1200;
            int wc = (int)((sz-2)/2);
            m_text.SetString((LPCWSTR)(p+2), wc);
        } else if (sz >= 2 && p[0]==0xFE && p[1]==0xFF) { // UTF-16 BE → LE 변환
            m_encoding = 1201;
            int wc = (int)((sz-2)/2);
            m_text.Empty(); m_text.Preallocate(wc);
            for (int i=0;i<wc;++i) {
                WCHAR w = ((WCHAR*) (p+2))[i];
                w = MAKEWORD(HIBYTE(w), LOBYTE(w)); // byte swap
                m_text.AppendChar(w);
            }
        } else {
            // ANSI 가정 → 시스템 ACP → UTF-16
            m_encoding = GetACP();
            int need = MultiByteToWideChar(m_encoding, 0, (LPCSTR)p, (int)sz, NULL, 0);
            m_text.SetString(L'\0', need);
            MultiByteToWideChar(m_encoding, 0, (LPCSTR)p, (int)sz, m_text.GetBuffer(), need);
        }
        SetModifiedFlag(FALSE);
    }
}
```

> **Tip**  
> - 대용량 텍스트는 `CEdit` 컨트롤 한계에 부딪힐 수 있습니다(수MB↑). 이후 커스텀 버퍼 + `CView`로 확장 고려.  
> - RTF를 지원하려면 `CRichEditView` + `StreamIn/StreamOut` 사용이 간단.

### 4-3. 저장 확인 UX

- `CDocument` 기본 로직: 닫기/새문서/열기 때 변경됨이면 **저장 확인** 자동.  
- 제목에 `*` 추가: `CMainFrame::OnUpdateFrameTitle` 또는 문서 `SetTitle` 호출 후 프레임 업데이트.

---

## 5. MRU(최근 문서) 설정 & 동작

### 5-1. 활성화

- `LoadStdProfileSettings(n)` 호출 시 자동으로 `m_pRecentFileList` 생성  
- 메뉴 리소스에 `ID_FILE_MRU_FILE1` 블록 포함

### 5-2. 저장/로드 위치(레지스트리)

- `SetRegistryKey()` + `LoadStdProfileSettings()` → `HKCU\Software\<회사>\<앱>\Recent File List`  
- 최대 개수 변경: `LoadStdProfileSettings(12)` …

### 5-3. 기본 사용

- 파일 열기/저장 성공 시 자동으로 MRU 갱신  
- 메뉴 클릭 → 프레임워크가 `OpenDocumentFile(path)` 호출

> **Tip**  
> - 프로젝트 템플릿으로 생성하면 대부분 **자동 구성**됩니다.  
> - 최근 문서에 아이콘/고정 기능까지 원하면 **점프 리스트**(Windows 7+)도 고려.

---

## 6. 인쇄/프리뷰 파이프라인(텍스트 페이지 매김)

### 6-1. 훅 개요

- `OnPreparePrinting(CPrintInfo*)` : **페이지 수 계산**, `SetMinPage/SetMaxPage`  
- `OnBeginPrinting` : **폰트/리소스 준비**  
- `OnPrepareDC` : 페이지별 **맵핑/오리진** 설정  
- `OnPrint` : **페이지별 텍스트 그리기**  
- `OnEndPrinting` : 리소스 해제

### 6-2. 뷰에서 구현 (CEditView 기반이라도 OnPrint 가능)

**레이아웃 전략**
1) 프린터 DC 메트릭: `LOGPIXELSY`, `m_rectDraw`  
2) 인쇄용 폰트: 포인트→픽셀 변환  
3) 줄 높이 계산 → **한 페이지 라인 수**  
4) 문서 텍스트를 **워드랩**하여 **라인 배열** 생성  
5) 페이지 경계 테이블 → `SetMaxPage`

```cpp
class CSimpleEditorView : public CEditView {
    CArray<CStringW> m_lines; // 워드랩 결과
    CArray<int,int>  m_pages; // 페이지 시작 라인 인덱스
    CFont m_printFont;
    int m_lineHeight = 0;

    BOOL OnPreparePrinting(CPrintInfo* pInfo) override {
        LayoutForPrint(pInfo); // m_lines/m_pages 생성
        pInfo->SetMinPage(1);
        pInfo->SetMaxPage((UINT)m_pages.GetCount());
        return DoPreparePrinting(pInfo);
    }
    void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo) override {
        // 폰트 준비(10pt)
        LOGFONT lf{}; lf.lfHeight = -MulDiv(10, pDC->GetDeviceCaps(LOGPIXELSY), 72);
        wcscpy_s(lf.lfFaceName, L"Consolas");
        m_printFont.CreateFontIndirect(&lf);
        CFont* old = pDC->SelectObject(&m_printFont);
        TEXTMETRIC tm; pDC->GetTextMetrics(&tm); m_lineHeight = tm.tmHeight + tm.tmExternalLeading;
        pDC->SelectObject(old);
    }
    void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo) override {
        CEditView::OnPrepareDC(pDC, pInfo);
        // pInfo->m_rectDraw 사용(안전 영역)
    }
    void OnPrint(CDC* pDC, CPrintInfo* pInfo) override {
        auto page = pInfo->m_nCurPage;
        int start = m_pages[page-1];
        int end   = (page-1<m_pages.GetCount()-1)? m_pages[page]-1 : (int)m_lines.GetCount()-1;

        CFont* old = pDC->SelectObject(&m_printFont);
        int y = pInfo->m_rectDraw.top;

        // 헤더
        CString head; head.Format(L"%s — %s", GetDocument()->GetPathName(), CTime::GetCurrentTime().Format(L"%Y-%m-%d %H:%M"));
        pDC->TextOut(pInfo->m_rectDraw.left, y, head); 
        y += m_lineHeight*2;

        // 본문
        for (int i=start; i<=end; ++i) {
            pDC->TextOut(pInfo->m_rectDraw.left, y, m_lines[i]);
            y += m_lineHeight;
            if (y > pInfo->m_rectDraw.bottom - m_lineHeight*2) break;
        }

        // 푸터(페이지)
        CString foot; foot.Format(L"- %d / %d -", page, (int)m_pages.GetCount());
        pDC->TextOut(pInfo->m_rectDraw.left, pInfo->m_rectDraw.bottom - m_lineHeight, foot);

        pDC->SelectObject(old);
    }
    void OnEndPrinting(CDC*, CPrintInfo*) override { m_printFont.DeleteObject(); }

    void LayoutForPrint(CPrintInfo* pInfo) {
        // 1) 문서 텍스트 → 라인(워드랩)
        m_lines.RemoveAll(); m_pages.RemoveAll();
        CStringW text = GetDocument()->m_text;
        // 개행 단위 split
        CArray<CStringW> para; SplitByLine(text, para);

        // 간단 워드랩(폰트 폭 계산 필요) → 여기선 monospaced 가정 or GDI GetTextExtentPoint 사용
        CDC* pDC = GetDC(); CFont font; LOGFONT lf{}; lf.lfHeight = -MulDiv(10, pDC->GetDeviceCaps(LOGPIXELSY), 72); wcscpy_s(lf.lfFaceName, L"Consolas"); font.CreateFontIndirect(&lf);
        CFont* old = pDC->SelectObject(&font);
        TEXTMETRIC tm; pDC->GetTextMetrics(&tm); int lh = tm.tmHeight+tm.tmExternalLeading;
        int maxWidth = pInfo->m_rectDraw.Width();
        for (auto& p : para) {
            CStringW line; int start=0;
            while (start < p.GetLength()) {
                int lo=start, hi=p.GetLength(), cut=start;
                // 이진 탐색으로 수평폭 초과 직전 컷
                while (lo<=hi) {
                    int mid=(lo+hi)/2; CStringW sub(p.Mid(start, mid-start));
                    CSize sz; pDC->GetTextExtent(sub, sub.GetLength(), &sz);
                    if (sz.cx <= maxWidth) { cut=mid; lo=mid+1; } else { hi=mid-1; }
                }
                if (cut==start) { // 한 글자도 못 들어가면 최소 1
                    cut = min(start+1, p.GetLength());
                }
                m_lines.Add(p.Mid(start, cut-start));
                start = cut;
            }
            if (p.GetLength()==0) m_lines.Add(L""); // 빈 줄 보존
        }
        pDC->SelectObject(old); font.DeleteObject(); ReleaseDC(pDC);

        // 2) 페이지 경계
        int linesPerPage = max(1, (pInfo->m_rectDraw.Height() - lh*3) / lh); // 헤더/푸터 여유
        for (int i=0;i<(int)m_lines.GetCount(); i += linesPerPage) m_pages.Add(i);
        if (m_pages.IsEmpty()) m_pages.Add(0);
    }
    void SplitByLine(const CStringW& s, CArray<CStringW>& out) {
        int i=0, n=s.GetLength(), b=0;
        while (i<n) {
            if (s[i]==L'\r' || s[i]==L'\n') {
                out.Add(s.Mid(b, i-b));
                if (s[i]==L'\r' && i+1<n && s[i+1]==L'\n') i++;
                b = i+1;
            }
            i++;
        }
        if (b<=n) out.Add(s.Mid(b));
    }
};
```

> **프리뷰**는 위 인쇄 경로를 그대로 사용(`CPreviewDC`), **스케일/페이지 전환**만 다릅니다.

---

## 7. 편집·상태 표시(줄/열, 인코딩, 변경 상태)

### 7-1. 줄/열 구하기(CEditView)

```cpp
void CSimpleEditorView::UpdateCaretStatus() {
    auto& edit = GetEditCtrl();
    DWORD pos = edit.CharFromPos(edit.GetCaretPos());
    int line = HIWORD(pos);           // 0-based
    int col  = LOWORD(pos) - edit.LineIndex(line);
    CString text; text.Format(L"Ln %d, Col %d", line+1, col+1);
    AfxGetMainWnd()->SendMessage(WM_APP+10, 0, (LPARAM)new CString(text)); // 상태바로 전달
}
```

- `OnSelChange`/`OnKeyUp`/`OnMouseUp` 등에서 호출 → 상태바 갱신

### 7-2. 변경 상태 플래그

- `EN_CHANGE`에서 문서 `SetModifiedFlag(TRUE)` + 타이틀 `*` 표시  
- 저장 성공 시 `FALSE`로 바꾸고 `*` 제거

---

## 8. 파일 인코딩 옵션(선택)

- “**다른 이름으로 저장**”에 **UTF-8(BOM)/UTF-8(no BOM)/UTF-16LE/ANSI(ACP)** 선택  
- 문서에 `m_encoding` 메타 보관 → 상태바 표시

> **권장**: 기본 저장은 **UTF-8(BOM)**. (Windows 메모장/다수 툴과 호환)

---

## 9. 찾기/바꾸기(간단)

- `CFindReplaceDialog` 사용  
- **모달리스**로 만들어 편집 도중 자유롭게 반복

```cpp
class CSimpleEditorView : public CEditView {
    CFindReplaceDialog* m_pFindDlg = nullptr;
    afx_msg void OnEditFind() {
        if (m_pFindDlg) { m_pFindDlg->SetActiveWindow(); return; }
        m_pFindDlg = new CFindReplaceDialog();
        m_pFindDlg->Create(TRUE, L"", NULL, FR_DOWN, this); // 찾기만
    }
    afx_msg LRESULT OnFindReplace(WPARAM, LPARAM lParam) {
        auto p = CFindReplaceDialog::GetFindReplaceMsg();
        if (!m_pFindDlg || lParam!=(LPARAM)m_pFindDlg) return 0;
        if (m_pFindDlg->FindNext()) {
            CStringW needle = m_pFindDlg->GetFindString();
            FindNext(needle, !m_pFindDlg->SearchDown(), m_pFindDlg->MatchCase(), m_pFindDlg->MatchWholeWord());
        }
        if (m_pFindDlg->IsTerminating()) { m_pFindDlg=nullptr; }
        return 0;
    }
    void FindNext(const CStringW& s, bool up, bool matchCase, bool whole) {
        auto& e = GetEditCtrl();
        CStringW text; e.GetWindowTextW(text);
        int selStart, selEnd; e.GetSel(selStart, selEnd);
        int pos = up ? text.Left(selStart).ReverseFind(s[0]) : text.Mid(selEnd).Find(s);
        // (간단 구현 — 실제론 대소문/전체단어 옵션 반영한 검색 함수로 확장)
        if (!up && pos>=0) { pos += selEnd; e.SetSel(pos, pos+(int)s.GetLength()); e.SetFocus(); }
        // (생략: up 방향/옵션 처리)
    }
    DECLARE_MESSAGE_MAP()
};
```

---

## 10. 메뉴/툴바/단축키(핵심 매핑)

```cpp
BEGIN_MESSAGE_MAP(CSimpleEditorView, CEditView)
    ON_COMMAND(ID_EDIT_FIND, &CSimpleEditorView::OnEditFind)
    ON_REGISTERED_MESSAGE(AFX_WM_FINDREPLACE, &CSimpleEditorView::OnFindReplace)
    // 인쇄 표준
    ON_COMMAND(ID_FILE_PRINT, &CEditView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, &CEditView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CEditView::OnFilePrintPreview)
END_MESSAGE_MAP()
```

- Doc/View/Frame 라우팅 규칙에 따라 **데이터 처리(문서)**, **표시/명령(뷰)**로 배치  
- `ID_FILE_OPEN/SAVE/NEW` 등은 템플릿 기본 핸들러가 처리

---

## 11. 설정/프로필(레지스트리) — 창 위치, 최근 폴더 등

- `GetProfileString/WriteProfileString`으로 **마지막 폴더**, **글꼴 크기**, **탭 크기** 등 저장  
- `SetRegistryKey()` 아래에 자동 저장됨

```cpp
void CSimpleEditorApp::LoadUserSettings() {
    m_lastDir = GetProfileString(L"Settings", L"LastDir", L"");
    m_printFontName = GetProfileString(L"Settings", L"PrintFont", L"Consolas");
}
void CSimpleEditorApp::SaveUserSettings() {
    WriteProfileString(L"Settings", L"LastDir", m_lastDir);
    WriteProfileString(L"Settings", L"PrintFont", m_printFontName);
}
```

---

## 12. DPI/글꼴/스크롤·큰 파일 가이드

- **DPI**: Per-Monitor-V2 활성화(매니페스트), `CEdit`의 폰트는 `OnInitialUpdate`에서 **DPI 의존 크기**로 설정  
- **큰 파일**(수MB~수십MB):  
  - `CEdit` 컨트롤은 느려질 수 있음 → 나중에 **자체 텍스트 버퍼 + CView 렌더** 전환  
  - “큰 파일 모드”: 검색/렌더를 **부분 로딩/페이징**으로 단순화

---

## 13. 예외/오류 처리 체크리스트

- **파일 인코딩 감지 실패**: ANSI fall-back + 사용자 경고(상태바/메시지)  
- **쓰기 실패**: 디스크 용량/권한 → 저장 임시 파일(`.tmp`) 후 교체(원자적) 권장  
- **인쇄 실패**: 프린터 드라이버/DC 획득 실패 시 사용자 표시 + 프리뷰/Print to PDF 안내

---

## 14. 테스트 플랜(요약)

1. 새 문서 → 편집 → 저장 → 재열기(인코딩 유지)  
2. ANSI/UTF-8/UTF-16 파일 열기(한글/이모지 포함)  
3. 변경 상태(*)/저장 확인 동작  
4. MRU 표시/클릭 열기  
5. 인쇄 프리뷰 줄/페이지 매김 정확성(머리말/푸터)  
6. DPI 100/150/200%에서 폰트/레이아웃  
7. 대용량 텍스트 성능(스크롤/검색)  
8. 충돌/예외 상황: 파일 잠김/경로 없음/쓰기 금지

---

## 15. 트러블슈팅 모음

| 증상 | 원인 | 대응 |
|---|---|---|
| 한글 깨짐 | 인코딩 오인식 | BOM 우선, 없으면 Heuristic(UTF-8 유효 바이트 검사) 후 ACP |
| 저장 후 *가 안 사라짐 | `SetModifiedFlag(FALSE)` 누락 | 저장 성공 직후 호출 + 타이틀 갱신 |
| MRU 안 보임 | 리소스에 `ID_FILE_MRU_FILE1` 없음 | 메뉴 리소스 재확인, `LoadStdProfileSettings` 호출 |
| 프리뷰와 인쇄 줄 수 차이 | 폰트/맵핑 차이 | `OnBeginPrinting` 폰트와 `OnPrint` 동일 사용, `m_rectDraw` 기준 |
| 큰 파일 느림 | `CEdit` 한계 | 커스텀 버퍼 + `CView` 스크롤 렌더로 리팩터링 |

---

## 16. 확장 아이디어

- **리치 텍스트**: `CRichEditView`로 전환 → 굵게/기울임/색/링크, `StreamIn/Out`으로 RTF/UTF-8 저장  
- **문서 설정(메타)**: 줄 번호, 탭폭, 개행 형식(CRLF/LF) → `CDocument`에 메타, `Serialize`로 JSON 저장  
- **자동 저장/복구**: 타이머로 임시 파일 주기 저장 → 크래시 시 복구  
- **플러그인**: 파일 후처리(예: Markdown 미리보기), 명령 패턴 + `ON_UPDATE_COMMAND_UI`로 탭/상태 제어  
- **다국어**: 리소스 전환(MUI), 상태바/대화상자 문자열 분리

---

## 17. 최소 동작 샘플(핵심만 발췌)

```cpp
// Doc.cpp
IMPLEMENT_DYNCREATE(CSimpleEditorDoc, CDocument)
BOOL CSimpleEditorDoc::OnNewDocument(){ if(!CDocument::OnNewDocument()) return FALSE; m_text.Empty(); SetModifiedFlag(FALSE); return TRUE; }
void CSimpleEditorDoc::Serialize(CArchive& ar){ /* 위 직렬화 코드 */ }

// View.cpp
IMPLEMENT_DYNCREATE(CSimpleEditorView, CEditView)
BEGIN_MESSAGE_MAP(CSimpleEditorView, CEditView)
  ON_COMMAND(ID_EDIT_FIND, &CSimpleEditorView::OnEditFind)
  ON_REGISTERED_MESSAGE(AFX_WM_FINDREPLACE, &CSimpleEditorView::OnFindReplace)
  ON_COMMAND(ID_FILE_PRINT, &CEditView::OnFilePrint)
  ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CEditView::OnFilePrintPreview)
END_MESSAGE_MAP()

void CSimpleEditorView::OnInitialUpdate(){ CEditView::OnInitialUpdate(); GetEditCtrl().SetWindowTextW(GetDocument()->m_text); }
void CSimpleEditorView::OnUpdate(CView*, LPARAM lHint, CObject*){ if(lHint==HINT_TEXT) GetEditCtrl().SetWindowTextW(GetDocument()->m_text); }

// App.cpp
BOOL CSimpleEditorApp::InitInstance(){
  CWinApp::InitInstance(); SetRegistryKey(L"DoHyun\\SimpleEditor"); LoadStdProfileSettings(8);
  auto pDT=new CSingleDocTemplate(IDR_MAINFRAME,RUNTIME_CLASS(CSimpleEditorDoc),RUNTIME_CLASS(CMainFrame),RUNTIME_CLASS(CSimpleEditorView));
  AddDocTemplate(pDT);
  CCommandLineInfo info; ParseCommandLine(info);
  if(!ProcessShellCommand(info)) return FALSE;
  m_pMainWnd->ShowWindow(SW_SHOW); m_pMainWnd->UpdateWindow(); return TRUE;
}
```

---

## 18. 마무리

이 가이드는 **MFC SDI의 정석 흐름**(DocTemplate → Doc/View/Frame → 직렬화 → MRU → 인쇄)을 **가장 작은 예제**로 하나씩 맞물리게 구성했습니다.  
여기까지 구현하면 **“메모장 그 이상”**: 인코딩 관리, 프린트/프리뷰, MRU, 상태 표시, 저장 확인 등 **데스크톱 앱의 핵심 골격**이 완성됩니다.
