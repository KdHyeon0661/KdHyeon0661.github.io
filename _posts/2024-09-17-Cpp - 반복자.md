---
layout: post
title: C++ - 반복자
date: 2024-09-17 20:20:23 +0900
category: Cpp
---
# C++ 반복자(Iterator): STL의 핵심 연결고리

## 서론: 반복자가 왜 중요한가?

반복자는 STL의 심장이자 혁신입니다. 이 작지만 강력한 추상화 덕분에 알고리즘과 컨테이너가 서로 독립적으로 발전할 수 있게 되었습니다. 반복자는 단순히 컨테이너를 순회하는 도구를 넘어서, C++에서 **일반화 프로그래밍의 꽃**이라 할 수 있습니다.

핵심 아이디어는 간단합니다: **알고리즘은 컨테이너가 아니라 반복자와만 대화합니다.** 이로 인해 `sort` 알고리즘 하나로 `vector`, `deque`, `array` 등 다양한 컨테이너를 정렬할 수 있습니다. 이는 마치 다양한 종류의 소켓에 모두 맞는 범용 충전기처럼, 하나의 알고리즘이 다양한 데이터 구조에 적용될 수 있게 합니다.

---

## 제1부: 반복자의 5가지 계급제도

반복자에는 계급이 있습니다. 이 계급은 단순한 기능 구분을 넘어, 알고리즘이 요구하는 최소한의 능력을 정의합니다.

### 1. 입력 반복자 (Input Iterator): 일회성 독자
```cpp
std::istream_iterator<int> reader(std::cin);
int first_value = *reader;  // 한 번만 읽을 수 있습니다
```
- **특징**: 순방향으로만 이동, 읽기만 가능, 각 위치는 한 번만 읽을 수 있음
- **비유**: 일회용 카메라 - 한 번 지나가면 다시 볼 수 없습니다
- **사용처**: 입력 스트림, 일회성 데이터 소스

### 2. 출력 반복자 (Output Iterator): 일회성 작가
```cpp
std::ostream_iterator<int> writer(std::cout, " ");
*writer = 42;  // 쓰기만 가능합니다
```
- **특징**: 순방향으로만 이동, 쓰기만 가능
- **비유**: 편지지 - 한 번 쓴 곳에 다시 쓸 수 없습니다
- **사용처**: 출력 스트림, 결과 수집기

### 3. 순방향 반복자 (Forward Iterator): 신뢰할 수 있는 안내자
```cpp
std::forward_list<int>::iterator it = flist.begin();
int first = *it;
++it;
int second = *it;  // 같은 곳을 여러 번 방문할 수 있습니다
```
- **특징**: 다중 순회 가능, 읽기/쓰기 모두 가능
- **비유**: 박물관 안내원 - 여러 번 같은 전시물을 설명할 수 있습니다
- **사용처**: `forward_list`, 해시 테이블

### 4. 양방향 반복자 (Bidirectional Iterator): 자유로운 탐험가
```cpp
std::list<int>::iterator it = mylist.end();
--it;  // 뒤로도 이동 가능!
int last_value = *it;
```
- **특징**: 앞뒤 이동 모두 가능
- **비유**: 책 - 앞으로 넘기거나 뒤로 넘길 수 있습니다
- **사용처**: `list`, `set`, `map`

### 5. 임의 접근 반복자 (Random Access Iterator): 초능력자
```cpp
std::vector<int>::iterator it = vec.begin();
int third = it[2];      // 바로 점프!
int fifth = *(it + 4);  // 산술 연산 가능
bool closer = (it < vec.end());  // 비교 연산 가능
```
- **특징**: 임의 위치로 즉시 이동, 포인터 산술 연산 가능
- **비유**: 헬리콥터 - 어디든 바로 이동 가능
- **사용처**: `vector`, `array`, `deque`

---

## 제2부: 알고리즘과 반복자의 만남

각 알고리즘은 특정 계급의 반복자를 요구합니다. 이것이 알고리즘의 힘과 한계를 결정합니다.

### 알고리즘의 요구사항 이해하기

```cpp
// sort는 임의 접근 반복자가 필요합니다
std::vector<int> vec = {3, 1, 4, 1, 5};
std::sort(vec.begin(), vec.end());  // OK - vector는 임의 접근

std::list<int> lst = {3, 1, 4, 1, 5};
// std::sort(lst.begin(), lst.end());  // 컴파일 오류!
lst.sort();  // list는 자체 sort 멤버 함수를 제공합니다
```

**왜 `sort`는 임의 접근이 필요할까요?**
퀵소트나 인트로소트 같은 알고리즘은 중간 요소에 즉시 접근해야 합니다(피벗 선택). `list`에서는 이게 O(n)의 비용이 들기 때문에, `list`는 다른 정렬 알고리즘을 사용합니다.

### 반복자 계급에 따른 성능 차이

```cpp
#include <chrono>
#include <vector>
#include <list>
#include <iostream>

void benchmark_distance() {
    constexpr size_t SIZE = 10'000'000;
    
    std::vector<int> vec(SIZE);
    std::list<int> lst(SIZE);
    
    // distance 성능 비교
    auto start = std::chrono::high_resolution_clock::now();
    auto vec_dist = std::distance(vec.begin(), vec.end());  // O(1)
    auto vec_time = std::chrono::high_resolution_clock::now() - start;
    
    start = std::chrono::high_resolution_clock::now();
    auto lst_dist = std::distance(lst.begin(), lst.end());  // O(n)
    auto lst_time = std::chrono::high_resolution_clock::now() - start;
    
    std::cout << "Vector distance: " << vec_time.count() << " ns\n";
    std::cout << "List distance: " << lst_time.count() << " ns\n";
}
```

---

## 제3부: 현실적인 도구들

STL은 반복자를 다루기 위한 실용적인 도구들을 제공합니다.

### `std::advance`: 지능적인 이동

```cpp
std::list<int> mylist(100);
auto it = mylist.begin();

// list는 임의 접근이 아니지만 advance가 최적의 방법으로 이동합니다
std::advance(it, 50);  // O(n) - 50번 ++ 연산 수행
```

### `std::next`와 `std::prev`: 안전한 이동

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// 원본을 변경하지 않고 다음 위치 얻기
auto next_it = std::next(vec.begin(), 2);  // vec[2]를 가리킴
auto prev_it = std::prev(vec.end(), 1);    // 마지막 요소를 가리킴

// 원본 vec.begin()은 변경되지 않았습니다!
```

### `std::distance`: 두 반복자 사이의 거리

```cpp
std::vector<int> vec(100);
std::list<int> lst(100);

// vector: O(1) - 단순 포인터 차이
size_t vec_len = std::distance(vec.begin(), vec.end());

// list: O(n) - 하나씩 세어야 함
size_t lst_len = std::distance(lst.begin(), lst.end());
```

---

## 제4부: 특수한 반복자들

### 역방향 반복자: 거꾸로 보기

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};

// 정방향 출력
for (auto it = numbers.begin(); it != numbers.end(); ++it) {
    std::cout << *it << " ";  // 1 2 3 4 5
}

// 역방향 출력
for (auto rit = numbers.rbegin(); rit != numbers.rend(); ++rit) {
    std::cout << *rit << " ";  // 5 4 3 2 1
}
```

흥미로운 점: 역방향 반복자에서 `++` 연산은 실제로는 `--`로 동작합니다!

### 삽입 반복자: 지능적인 복사

```cpp
std::vector<int> source = {1, 2, 3, 4, 5};
std::vector<int> dest;

// back_inserter: 뒤에 추가 (push_back 호출)
std::copy(source.begin(), source.end(), 
          std::back_inserter(dest));

// front_inserter: 앞에 추가 (push_front 호출) - deque나 list에서 사용
std::list<int> mylist;
std::copy(source.begin(), source.end(),
          std::front_inserter(mylist));  // 결과: 5 4 3 2 1

// inserter: 특정 위치에 삽입
std::vector<int> vec2 = {10, 20, 30};
auto insert_pos = vec2.begin() + 1;
std::copy(source.begin(), source.end(),
          std::inserter(vec2, insert_pos));
// 결과: 10 1 2 3 4 5 20 30
```

### 이동 반복자: 효율적인 소유권 이전

```cpp
std::vector<std::string> source = {"Hello", "World"};
std::vector<std::string> destination;

// move_iterator를 사용하여 소유권 이전
std::move(std::make_move_iterator(source.begin()),
          std::make_move_iterator(source.end()),
          std::back_inserter(destination));

// source의 문자열들은 이제 "moved-from" 상태입니다
// destination이 메모리 소유권을 가져갔습니다
```

---

## 제5부: 반복자 무효화 - 가장 흔한 함정

반복자 무효화는 C++ 프로그래머가 가장 자주 마주치는 문제 중 하나입니다.

### 위험한 코드 예시

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// 위험: 순회 중에 erase 호출
for (auto it = vec.begin(); it != vec.end(); ++it) {
    if (*it == 3) {
        vec.erase(it);  // it가 무효화됨!
        // 다음 반복에서 ++it는 미정의 동작
    }
}
```

### 안전한 삭제 패턴

**패턴 1: erase-remove 관용구**
```cpp
std::vector<int> vec = {1, 2, 3, 4, 3, 5};
vec.erase(std::remove(vec.begin(), vec.end(), 3), vec.end());
```

**패턴 2: 반복자 갱신**
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
for (auto it = vec.begin(); it != vec.end(); ) {
    if (*it == 3) {
        it = vec.erase(it);  // erase는 다음 유효한 반복자를 반환
    } else {
        ++it;
    }
}
```

**패턴 3: C++20의 `std::erase_if`**
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
std::erase_if(vec, [](int x) { return x == 3; });
```

### 컨테이너별 무효화 규칙 요약

| 컨테이너 | 삽입 시 | 삭제 시 | 특별 주의사항 |
|----------|---------|---------|--------------|
| **`vector`** | 재할당 시 모두 무효, 아니면 삽입점 이후만 | 삭제점 이후 무효 | `reserve()`로 재할당 방지 |
| **`deque`** | 복잡하게 무효화됨 | 복잡하게 무효화됨 | 보수적으로 접근: 변경 후 재획득 |
| **`list`** | 다른 반복자 안전 | 지운 노드만 무효 | 안정적! |
| **`set`/`map`** | 다른 반복자 안전 | 지운 노드만 무효 | 안정적! |
| **`unordered_*`** | 재해시 시 모두 무효 | 지운 노드만 무효 | `reserve()`로 재해시 방지 |

---

## 제6부: 반복자 특성과 메타프로그래밍

### `iterator_traits`: 반복자의 내부 살펴보기

```cpp
template<typename Iterator>
void process_iterator(Iterator it) {
    // 반복자의 특성 추출
    using value_type = typename std::iterator_traits<Iterator>::value_type;
    using category = typename std::iterator_traits<Iterator>::iterator_category;
    
    // value_type을 사용한 일반적인 처리
    value_type temp = *it;
    
    // iterator_category에 따른 분기
    if constexpr (std::is_same_v<category, std::random_access_iterator_tag>) {
        // 고성능 알고리즘 사용
        process_fast(it);
    } else {
        // 일반 알고리즘 사용
        process_safe(it);
    }
}
```

### 태그 디스패치: 컴파일 타임 최적화

```cpp
// 태그 디스패치를 이용한 advance 구현
template<typename Iterator>
void advance_impl(Iterator& it, int n, std::random_access_iterator_tag) {
    it += n;  // O(1) - 바로 이동
}

template<typename Iterator>
void advance_impl(Iterator& it, int n, std::bidirectional_iterator_tag) {
    if (n > 0) {
        while (n--) ++it;  // O(n) - 앞으로 이동
    } else {
        while (n++) --it;  // O(n) - 뒤로 이동
    }
}

template<typename Iterator>
void advance_impl(Iterator& it, int n, std::forward_iterator_tag) {
    while (n-- > 0) ++it;  // O(n) - 앞으로만 이동
}

template<typename Iterator>
void my_advance(Iterator& it, int n) {
    using category = typename std::iterator_traits<Iterator>::iterator_category;
    advance_impl(it, n, category{});  // 적절한 버전 호출
}
```

---

## 제7부: C++20의 새로운 세계 - 개념과 범위

### 개념(Concepts): 더 나은 인터페이스

```cpp
// C++20 이전: 템플릿 오류 메시지가 난해함
template<typename Iterator>
void sort_range(Iterator begin, Iterator end) {
    std::sort(begin, end);  // Iterator가 부적절하면 컴파일 에러
}

// C++20: 명확한 요구사항
template<std::random_access_iterator Iterator>
void sort_range(Iterator begin, Iterator end) {
    std::sort(begin, end);  // 컴파일 타임에 요구사항 검증
}

// 사용
std::vector<int> vec = {3, 1, 4};
sort_range(vec.begin(), vec.end());  // OK

std::list<int> lst = {3, 1, 4};
// sort_range(lst.begin(), lst.end());  // 컴파일 에러: 명확한 메시지
```

### 범위(Ranges): 더 선언적인 코드

```cpp
#include <ranges>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 파이프라인 스타일: 필터 → 변환 → 출력
    auto result = numbers 
        | std::views::filter([](int n) { return n % 2 == 0; })  // 짝수만
        | std::views::transform([](int n) { return n * n; })    // 제곱
        | std::views::take(3);                                  // 처음 3개
    
    for (int n : result) {
        std::cout << n << " ";  // 4 16 36
    }
}
```

**범위의 장점:**
1. **지연 평가**: 필요할 때만 계산
2. **구성 가능**: 파이프라인으로 연결
3. **안전성**: 뷰는 원본을 소유하지 않음
4. **표현력**: 의도를 명확히 표현

---

## 제8부: 커스텀 반복자 만들기

사용자 정의 반복자를 만드는 것은 반복자의 동작을 깊이 이해하는 최고의 방법입니다.

### 간단한 범위 반복자 구현

```cpp
#include <iterator>

class NumberRange {
    class Iterator {
        int current_;
    public:
        // 반복자 특성 정의 (필수!)
        using iterator_category = std::forward_iterator_tag;
        using value_type = int;
        using difference_type = std::ptrdiff_t;
        using pointer = int*;
        using reference = int&;
        
        explicit Iterator(int start = 0) : current_(start) {}
        
        // 기본 연산자들
        int operator*() const { return current_; }
        Iterator& operator++() { ++current_; return *this; }
        Iterator operator++(int) { 
            Iterator temp = *this; 
            ++current_; 
            return temp; 
        }
        
        bool operator==(const Iterator& other) const {
            return current_ == other.current_;
        }
        bool operator!=(const Iterator& other) const {
            return !(*this == other);
        }
    };
    
    int start_, end_;
    
public:
    NumberRange(int start, int end) : start_(start), end_(end) {}
    
    Iterator begin() const { return Iterator(start_); }
    Iterator end() const { return Iterator(end_); }
};

// 사용 예
#include <iostream>
#include <algorithm>

int main() {
    NumberRange range(5, 10);
    
    // 범위 기반 for 문
    for (int n : range) {
        std::cout << n << " ";  // 5 6 7 8 9
    }
    
    // STL 알고리즘과도 호환
    auto it = std::find(range.begin(), range.end(), 7);
    if (it != range.end()) {
        std::cout << "\nFound: " << *it;
    }
}
```

---

## 결론: 반복자 마스터하기

반복자는 C++ STL의 근간을 이루는 개념입니다. 이를 제대로 이해하면:

### 1. **알고리즘 선택의 지혜**
어떤 알고리즘이 어떤 컨테이너에서 작동하는지, 왜 작동하지 않는지를 이해할 수 있습니다. `sort`가 `vector`에서는 작동하지만 `list`에서는 작동하지 않는 이유를 알게 됩니다.

### 2. **성능 예측 능력**
`std::distance`가 `vector`에서는 O(1)이지만 `list`에서는 O(n)인 이유를 이해하면, 대규모 데이터를 다룰 때 현명한 선택을 할 수 있습니다.

### 3. **버그 예방**
반복자 무효화 규칙을 이해하면 가장 흔한 C++ 버그를 사전에 방지할 수 있습니다. 컨테이너를 수정할 때 반복자가 어떻게 영향을 받는지 알게 됩니다.

### 4. **표현력의 확장**
커스텀 반복자를 만들어 자신만의 추상화를 설계할 수 있습니다. 이는 라이브러리 설계나 도메인 특화 언어(DSL) 구축에 유용합니다.

### 5. **현대적 C++로의 진화**
C++20의 개념과 범위를 이해하면 더 안전하고 표현력 있는 코드를 작성할 수 있습니다.

반복자는 단순한 기술적 도구를 넘어, **추상화의 힘**을 보여주는 사례입니다. 처음에는 다소 추상적으로 느껴질 수 있지만, 일단 내재된 패턴을 이해하면 C++ 코드의 품질과 안전성을 크게 향상시킬 수 있습니다.

기억하세요: 좋은 C++ 프로그래머는 반복자를 도구처럼 사용하는 것이 아니라, 언어처럼 생각합니다. 반복자가 제공하는 추상화 계층을 이해하고 활용할 때, 진정한 STL의 힘을 발휘할 수 있습니다.