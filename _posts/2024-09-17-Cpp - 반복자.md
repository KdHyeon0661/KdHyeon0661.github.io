---
layout: post
title: C++ - 반복자
date: 2024-09-17 20:20:23 +0900
category: Cpp
---
# C++ 반복자(Iterator)

## 0. 왜 반복자를 이해해야 하나?

STL의 알고리즘은 컨테이너에 의존하지 않고 **반복자 범주**에 의존한다.  
즉, “내 반복자는 어디까지 할 수 있는가?”를 알면, **어떤 알고리즘을 안전·효율적으로 쓸 수 있는지**가 보인다.

- 컨테이너 교체(예: `vector` ↔ `list`)에도 알고리즘을 재사용 가능.
- 반복자 범주에 따라 $$\text{time}(\text{distance}) \in \{O(1), O(n)\}$$ 등 **복잡도**가 달라진다.
- 무효화 규칙을 알면 **미묘한 버그**와 **UB**(Undefined Behavior)를 피할 수 있다.

---

## 1. 반복자란?

- 컨테이너 원소를 **순회**하는 포인터 유사 객체.  
- `*`(역참조), `++`(전진), 범주에 따라 `--`, `+`, `-`, `[]` 등을 제공.
- 컨테이너마다 제공하는 반복자 범주가 다르다. (예: `vector`는 Random Access, `list`는 Bidirectional)

---

## 2. 고전적 5대 범주 (iterator tag)

| 반복자 종류 | 핵심 특징 | 대표 연산 |
|---|---|---|
| **Input** | 읽기전용·1패스 | `*`, `++`, `==`, `!=` |
| **Output** | 쓰기전용·1패스 | `*`(할당), `++` |
| **Forward** | 여러 번 읽기 가능·전진만 | `*`, `++`, `==`, `!=` |
| **Bidirectional** | 전·후진 | `*`, `++`, `--` |
| **Random Access** | 임의접근 | `+`, `-`, `[]`, `<`, `<=`, `>` , `>=` |

> **C++20**에는 **컨셉(Concept)** 기반의 현대적 분류가 추가된다. (뒤 §8)

---

## 3. 각 범주별 예시

### 3.1 Input Iterator — 스트림 입력

```cpp
#include <iterator>
#include <iostream>

int main() {
    std::istream_iterator<int> in(std::cin), eos;
    if (in != eos) {
        int x = *in; // 한 번 읽으면 소모되는 1패스 성격
        std::cout << "첫 정수: " << x << "\n";
    }
}
```

- **1패스**: 같은 위치를 두 번 읽는 전제는 깨질 수 있다.
- 대표 요구 알고리즘: `std::accumulate`(실제로는 Input도 OK), `std::find`, `std::copy` 등.

### 3.2 Output Iterator — 스트림 출력

```cpp
#include <iterator>
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> v{1,2,3};
    std::ostream_iterator<int> out(std::cout, " ");
    std::copy(v.begin(), v.end(), out); // 1 2 3
}
```

- **쓰기 전용**. `*out = value; ++out;` 패턴으로 동작.

### 3.3 Forward Iterator — 전진·다중패스

```cpp
#include <forward_list>
#include <iostream>

int main() {
    std::forward_list<int> fl = {1,2,3};
    auto it = fl.begin();
    ++it; // OK
    std::cout << *it << "\n"; // 2
}
```

- 여러 번 순회 가능. `std::forward_list`의 반복자.

### 3.4 Bidirectional Iterator — 양방향

```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1,2,3};
    auto it = lst.end();
    --it;
    std::cout << *it << "\n"; // 3
}
```

- `std::list`, `std::set`, `std::map` 등 노드 기반 컨테이너.

### 3.5 Random Access Iterator — 임의접근

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> v = {10, 20, 30};
    auto it = v.begin();
    std::cout << it[1] << " " << *(it + 2) << "\n"; // 20 30
}
```

- `std::vector`, `std::array`, `std::string` 등.
- **`std::deque`는 Random Access이지만 메모리 연속성은 없다.**

---

## 4. 반복자 계층 구조 (개념도)

```
         RandomAccessIterator
              ↑
   BidirectionalIterator
              ↑
     ForwardIterator
     ↑           ↑
InputIterator  OutputIterator
```

- 위로 갈수록 기능·요구사항 증가.
- 상위 범주는 하위 요구를 모두 만족한다.

---

## 5. 실전 도구: `std::advance`, `std::distance`, `std::next`, `std::prev`

### 5.1 성능 규칙 (중요)

- $$\text{distance}(first, last)$$  
  - Random Access: $$O(1)$$  
  - 그 외: $$O(n)$$  
- $$\text{advance}(it, n)$$  
  - Random Access: $$O(1)$$(포인터 산술)  
  - Bidirectional: $$O(|n|)$$(앞/뒤로 n번)  
  - Forward/Input: $$O(n)$$(앞으로 n번)

### 5.2 예시

```cpp
#include <vector>
#include <list>
#include <iterator>
#include <iostream>

int main(){
    std::vector<int> v(100);
    auto itv = v.begin();
    std::advance(itv, 50); // O(1)

    std::list<int> lst(100);
    auto itl = lst.begin();
    std::advance(itl, 50); // O(n)

    std::cout << std::distance(v.begin(), v.end()) << "\n";   // O(1)
    std::cout << std::distance(lst.begin(), lst.end()) << "\n"; // O(n)
}
```

### 5.3 `next/prev` — 값 리턴(원본 보존)

```cpp
#include <vector>
#include <iostream>
#include <iterator>

int main() {
    std::vector<int> v{1,2,3,4};
    auto it2 = std::next(v.begin(), 2); // v[2]를 가리키는 반복자
    std::cout << *it2 << "\n";          // 3
}
```

---

## 6. 반복자 어댑터 & 도우미

### 6.1 `const_iterator` / `cbegin`, `cend`

```cpp
#include <vector>
#include <iostream>

int main() {
    const std::vector<int> v{1,2,3};
    for (auto it = v.cbegin(); it != v.cend(); ++it) {
        // *it = 42; // ❌ 읽기전용
        std::cout << *it << " ";
    }
}
```

### 6.2 `reverse_iterator`

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> v{1,2,3};
    for (auto it = v.rbegin(); it != v.rend(); ++it)
        std::cout << *it << " "; // 3 2 1
}
```

### 6.3 `move_iterator` — 이동 시멘틱으로 복사 비용 절감

```cpp
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>

int main(){
    std::vector<std::string> src = {"A","B","C"};
    std::vector<std::string> dst;
    dst.reserve(src.size());
    std::move(std::make_move_iterator(src.begin()),
              std::make_move_iterator(src.end()),
              std::back_inserter(dst));
}
```

### 6.4 `insert_iterator` — `back_inserter`/`front_inserter`/`inserter`

```cpp
#include <vector>
#include <list>
#include <algorithm>
#include <iterator>

int main(){
    std::vector<int> v{1,2,3};
    std::list<int>   L;

    std::copy(v.begin(), v.end(), std::back_inserter(L)); // 뒤에 append
    std::copy(v.begin(), v.end(), std::front_inserter(L));// 앞에 prepend
    std::copy(v.begin(), v.end(), std::inserter(L, L.begin())); // 임의 위치
}
```

### 6.5 스트림 반복자

```cpp
#include <iterator>
#include <iostream>
#include <vector>
#include <algorithm>

int main(){
    std::istream_iterator<int> in(std::cin), eos;
    std::ostream_iterator<int> out(std::cout, "\n");

    std::vector<int> v;
    std::copy(in, eos, std::back_inserter(v));   // 입력 모두 읽기
    std::copy(v.begin(), v.end(), out);          // 한 줄씩 출력
}
```

---

## 7. 무효화(Invalidation) 규칙 — “언제 반복자가 죽는가?”

| 컨테이너 | 삽입 | 삭제 | 비고 |
|---|---|---|---|
| `vector`/`string` | 재할당 발생 시 **모두 무효**, 재할당 없어도 삽입점 이후 무효 | 삭제점 이후 무효 | `reserve`로 재할당 최소화 |
| `deque` | 양끝·중간 삽입이 **폭넓게 무효화** | 삭제도 폭넓게 무효 | 보수적으로 “대부분 무효” 가정 |
| `list`/`forward_list` | **안정**(다른 반복자 유효) | 지운 그 노드만 무효 | 노드 기반 |
| `map`/`set` | **안정**(삽입해도 기존 유효) | 지운 노드만 무효 | 노드 기반 |
| `unordered_*` | **rehash 시 전부 무효** | 지운 노드만 무효 | `reserve`, `max_load_factor`로 제어 |

> 해시 컨테이너는 **리해시**가 핵심 위험. 대량 삽입 전에 **`reserve`** 하라.

---

## 8. C++20 Ranges 개념(Concept) — 현대적 분류

고전 태그 대신 **컨셉**으로 제약:

- `std::input_iterator`, `std::forward_iterator`, `std::bidirectional_iterator`, `std::random_access_iterator`, **`std::contiguous_iterator`**
- **연속 반복자(contiguous)**: 메모리가 연속이며 `std::to_address`로 원시 포인터에 일치. `vector`, `string`, `array` 등. (※ `deque`는 비연속)

### 사용 예: 정적 보증

```cpp
#include <vector>
#include <list>
#include <concepts>
#include <type_traits>

template <std::random_access_iterator It>
void only_random_access(It, It){ /* ... */ }

int main(){
    std::vector<int> v;
    // only_random_access(v.begin(), v.end()); // OK

    std::list<int> L;
    // only_random_access(L.begin(), L.end()); // ❌ 컴파일 에러
}
```

### `ranges` 파이프라인

```cpp
#include <vector>
#include <ranges>
#include <algorithm>
#include <iostream>

int main(){
    std::vector<int> v{1,2,3,4,5,6};

    auto evens_sq = v
      | std::views::filter([](int x){ return x%2==0; })
      | std::views::transform([](int x){ return x*x; });

    for (int x : evens_sq) std::cout << x << " "; // 4 16 36
}
```

---

## 9. 알고리즘이 요구하는 “최소 반복자 범주”

| 알고리즘 | 최소 요구 | 메모 |
|---|---|---|
| `std::find`, `std::count`, `std::copy` | Input | 1패스면 OK |
| `std::unique`, `std::remove` | Forward | 결과를 앞에 모으려면 다중패스 필요 |
| `std::sort`, `std::nth_element`, `std::partial_sort` | Random Access | 피벗점/인덱싱 필요 |
| `std::reverse` | Bidirectional | 앞뒤 swap |
| `std::merge`, `std::set_union` | Forward | 양쪽에서 전진 |
| `std::distance`, `std::advance` | 범주 따라 O(1)~O(n) | 위 §5 |

---

## 10. `iterator_traits` — 범주/형 추출

```cpp
#include <iterator>
#include <type_traits>

template <typename It>
void foo(It first, It last) {
    using Cat = typename std::iterator_traits<It>::iterator_category;
    static_assert(!std::is_same_v<Cat, std::output_iterator_tag>, "읽기 필요!");

    using Val = typename std::iterator_traits<It>::value_type;
    // Val 기반으로 로직…
}
```

- `value_type`, `difference_type`, `reference`, `pointer`, `iterator_category` 제공.
- 포인터에도 동작 (`iterator_traits<T*>`가 부분 특수화).

---

## 11. 실무 패턴 — “범주 분기로 성능 최적화”

```cpp
#include <iterator>
#include <type_traits>

// Random Access면 O(1), 아니면 O(n)으로 이동
template <typename It>
void advance_smart(It& it, typename std::iterator_traits<It>::difference_type n,
                   std::random_access_iterator_tag) {
    it += n; // O(1)
}

template <typename It>
void advance_smart(It& it, typename std::iterator_traits<It>::difference_type n,
                   std::input_iterator_tag) {
    if (n >= 0) while (n--) ++it; // O(n)
    else static_assert(sizeof(It) == 0, "Input은 뒤로 못 감");
}

template <typename It>
void advance_smart(It& it, typename std::iterator_traits<It>::difference_type n) {
    using Cat = typename std::iterator_traits<It>::iterator_category;
    advance_smart(it, n, Cat{});
}
```

---

## 12. 반복자 관련 “자주 하는 실수”와 처방

1) **range-for에서 `erase` 호출**  
   - ❌: 반복자 무효화/건너뛰기  
   - ✅: `it = c.erase(it)` 또는 `erase-remove`/`std::erase_if` 사용.

2) **`deque`가 연속 메모리라고 착각**  
   - 랜덤 접근은 가능하지만 **contiguous 아님**. 포인터 전달 금지.

3) **해시 컨테이너에서 rehash 무시**  
   - 대량 삽입 전 `reserve(n)` + `max_load_factor(α)`.

4) **스트림 반복자 1패스를 다중패스처럼 사용**  
   - Input/Output은 **한 번 지나가면 끝**.

5) **`iterator`가 포인터와 항상 동일하다고 가정**  
   - 디버그/커스텀 반복자는 검증 로직 포함. 포인터 산술 금지.

---

## 13. 예제: 다양한 반복자 조합

### 13.1 `erase-remove` + `back_inserter`

```cpp
#include <vector>
#include <algorithm>
#include <iterator>
#include <iostream>

int main(){
    std::vector<int> v{1,2,3,2,4,5};
    v.erase(std::remove(v.begin(), v.end(), 2), v.end());

    std::vector<int> sq;
    sq.reserve(v.size());
    std::transform(v.begin(), v.end(), std::back_inserter(sq),
                   [](int x){ return x*x; });

    for (int x : sq) std::cout << x << " ";
}
```

### 13.2 `reverse_iterator`로 뒤집어 복사

```cpp
#include <vector>
#include <algorithm>
#include <iterator>

int main(){
    std::vector<int> v{1,2,3,4};
    std::vector<int> out;
    out.reserve(v.size());
    std::copy(v.rbegin(), v.rend(), std::back_inserter(out)); // 4 3 2 1
}
```

### 13.3 `move_iterator`로 값 옮기기

```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <iterator>

int main(){
    std::vector<std::string> src = {"largeA","largeB"};
    std::vector<std::string> dst;
    dst.reserve(src.size());

    std::move(std::make_move_iterator(src.begin()),
              std::make_move_iterator(src.end()),
              std::back_inserter(dst));
}
```

---

## 14. 직접 반복자 구현 — 간단한 구간(range) 반복자

> **학습용** 예제: `[start, end)` 정수 시퀀스를 생성하는 Forward 반복자.

```cpp
#include <iterator>
#include <cstddef>

class int_range {
    struct iter {
        using iterator_category = std::forward_iterator_tag;
        using value_type        = int;
        using difference_type   = std::ptrdiff_t;
        using pointer           = const int*;
        using reference         = const int&;

        int cur;

        explicit iter(int x) : cur(x) {}
        int operator*() const { return cur; }
        iter& operator++() { ++cur; return *this; }
        iter operator++(int){ auto t=*this; ++cur; return t; }
        bool operator==(const iter& rhs) const { return cur == rhs.cur; }
        bool operator!=(const iter& rhs) const { return !(*this == rhs); }
    };

    int b_, e_;
public:
    int_range(int b, int e) : b_(b), e_(e) {}
    iter begin() const { return iter{b_}; }
    iter end()   const { return iter{e_}; }
};

// 사용 예
#include <iostream>
int main(){
    for (int x : int_range(3, 7)) std::cout << x << " "; // 3 4 5 6
}
```

- 최소한의 태그/형 정의(`iterator_category` 등)를 제공.
- C++20에선 `std::ranges` 커스텀 뷰(예: `view_interface`)로 더 세련되게 구현 가능.

---

## 15. 테스트: 내 반복자는 어떤 범주인가? (정적 점검)

```cpp
#include <vector>
#include <list>
#include <type_traits>
#include <iterator>

static_assert(std::is_base_of_v<std::random_access_iterator_tag,
              std::iterator_traits<std::vector<int>::iterator>::iterator_category>);

static_assert(std::is_base_of_v<std::bidirectional_iterator_tag,
              std::iterator_traits<std::list<int>::iterator>::iterator_category>);
```

C++20에선:

```cpp
#include <concepts>
#include <vector>
#include <list>

static_assert(std::random_access_iterator<std::vector<int>::iterator>);
static_assert(std::bidirectional_iterator<std::list<int>::iterator>);
```

---

## 16. “컨테이너 × 반복자” 무효화/연속성 요약

| 컨테이너 | 반복자 범주 | 연속 메모리 | 주의 포인트 |
|---|---|---|---|
| `vector`, `string`, `array` | Random Access | ✅ (array는 고정 크기) | 삽입·삭제 시 무효화, `reserve`로 완화 |
| `deque` | Random Access | ❌ | 블록 구조, 무효화 규칙 보수적 |
| `list` | Bidirectional | N/A | 삽입/삭제에 강함 |
| `forward_list` | Forward | N/A | 단방향, `insert_after/erase_after` |
| `set`, `map` | Bidirectional | N/A | 키 불변(수정 금지), 노드 안정 |
| `unordered_*` | Forward-ish | N/A | rehash에 취약, `reserve` |

---

## 17. 복잡도 메모 (대표)

- $$\text{sort} \colon O(n\log n)$$ (Random Access 필요)  
- $$\text{reverse} \colon O(n)$$ (Bidirectional 필요)  
- $$\text{unique/remove} \colon O(n)$$ (Forward 이상)  
- $$\text{merge} \colon O(n + m)$$ (정렬 전제, Forward 이상)  
- $$\text{distance} \colon O(1)\ \text{or}\ O(n)$$ (범주 의존)

---

## 18. 체크리스트 — 프로젝트에 바로 적용

- [ ] 사용할 알고리즘이 요구하는 **최소 반복자 범주** 확인  
- [ ] `advance/distance`의 **복잡도 차이** 고려  
- [ ] 삭제는 `it=erase(it)`/`erase-remove`/`std::erase(_if)`  
- [ ] 해시 컨테이너 대량 삽입 전 `reserve`  
- [ ] 반복자 무효화 규칙 숙지 (`vector` 재할당, `unordered` rehash)  
- [ ] 컨테이너 선택: **연속/랜덤접근 vs 노드 안정성**  
- [ ] 가능하면 C++20 **ranges**로 표현력·안전성 향상  
- [ ] 커스텀 비교자/해시 동치 일관성 보장

---

## 19. 마무리

- 반복자는 **알고리즘의 언어**다. 범주와 무효화 규칙, 보조 함수의 복잡도를 이해하면 **버그를 줄이고** 같은 코드로 **여러 컨테이너**를 다룰 수 있다.  
- C++20의 **컨셉/레인지**를 더하면, 잘못된 반복자 사용을 **컴파일 타임에 차단**하고 파이프라인으로 **의도를 표준화**할 수 있다.  
- 필요하면 직접 반복자를 구현하라. 스스로 만들어 보면 “왜 표준 태그/트레잇/개념이 필요한가”가 **손끝으로** 체득된다.