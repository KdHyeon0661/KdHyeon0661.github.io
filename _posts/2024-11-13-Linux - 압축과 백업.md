---
layout: post
title: Linux - 압축과 백업
date: 2024-11-13 19:20:23 +0900
category: Linux
---
# 압축·백업·디스크 이미지 전략

## 압축과 아카이빙의 개념 이해

리눅스 시스템에서 데이터 관리를 위한 두 가지 핵심 개념을 이해해야 합니다:

- **아카이빙(archive)**: 여러 파일과 디렉터리를 하나의 파일로 묶는 과정입니다. 대표적인 도구로는 `tar`, `cpio`가 있습니다.
- **압축(compress)**: 데이터의 크기를 줄이는 과정입니다. 주요 도구로는 `gzip`, `bzip2`, `xz`, `zstd` 등이 있습니다.

실무에서는 보통 두 가지를 결합하여 사용하며, `.tar.gz`, `.tar.xz`, `.tar.zst`와 같은 형식으로 파일을 관리합니다.

---

## tar — 아카이브의 표준과 실무 활용

tar는 리눅스에서 가장 널리 사용되는 아카이빙 도구입니다. 기본적인 사용법부터 실무에서 필요한 고급 옵션까지 알아보겠습니다.

### 기본 사용법

```bash
# 아카이브 생성 (압축 없이)
tar -cf archive.tar dir/

# 아카이브 추출
tar -xf archive.tar

# 다양한 압축 형식으로 아카이브 생성
tar -czf archive.tar.gz dir/      # gzip 압축
tar -cjf archive.tar.bz2 dir/     # bzip2 압축
tar -cJf archive.tar.xz dir/      # xz 압축
tar --zstd -cf archive.tar.zst dir/  # zstd 압축
```

### 실무에서 반드시 알아야 할 고급 옵션

```bash
# 커스텀 압축기 사용
tar -I 'pigz -9 -p 8' -cvf archive.tar.gz dir/

# 파일 제외 규칙 적용
tar -czf src.tar.gz src/ --exclude='*.o' --exclude-from=.tarignore

# 안전한 복원 (상대경로, 상위탈출 방지, 특정 계층 제거)
tar -xzf archive.tar.gz -C /restore --strip-components=1

# 확장 속성과 권한 보존
sudo tar --xattrs --xattrs-include='*' --acls --selinux \
         --numeric-owner -czf backup.tar.gz /important

# 동일 파일시스템만 아카이빙 (/proc, /dev 등 제외)
sudo tar --one-file-system -czf rootfs.tar.gz /

# 아카이브 내용 확인 및 무결성 검증
tar -tvf archive.tar.gz
tar -tzf archive.tar.gz > /dev/null   # 아카이브 열람 가능 여부 체크
```

**중요한 포인트**:
- `--numeric-owner`: 다른 시스템에서 복원 시 UID/GID를 유지합니다.
- `--xattrs/--acls/--selinux`: 확장 속성과 보안 컨텍스트를 보존합니다.
- `--one-file-system`: 루트 백업 시 다른 파일시스템을 침범하지 않도록 방지합니다.
- `--strip-components`: 추출 시 상위 디렉터리 구조를 제거하여 경로 오염을 방지합니다.

### tar를 이용한 증분/차등 백업

```bash
# 전체 백업 스냅샷 생성
sudo tar --listed-incremental=/var/backups/base.snar -czf full_$(date +%F).tar.gz /data

# 증분 백업 (변경된 부분만)
sudo tar --listed-incremental=/var/backups/base.snar -czf incr_$(date +%F).tar.gz /data

# 복원은 전체 백업 → 증분 백업 순서로 적용
```

tar의 증분 백업 기능은 간편하지만 SNAR 파일 관리가 필요합니다. 대규모 또는 장기 보관이 필요한 경우에는 restic나 borg와 같은 전문 백업 도구를 사용하는 것이 좋습니다.

---

## 단일 파일 압축 도구 비교

리눅스에서는 다양한 압축 도구를 사용할 수 있으며, 각각 장단점이 있습니다:

```bash
gzip -k file.txt        # file.txt.gz 생성 (원본 유지: -k 옵션)
bzip2 -k file.txt       # .bz2 형식으로 압축
xz -k file.txt          # .xz 형식으로 압축
zstd -k file.txt        # .zst 형식으로 압축 (빠른 고압축)
unxz file.txt.xz        # 압축 해제
gunzip file.txt.gz      # 압축 해제
```

### 압축률과 속도 비교 (대략적)

- **속도**: zstd ≈ gzip > bzip2 > xz
- **압축률**: xz ≳ zstd(고레벨) > bzip2 > gzip

### 병렬 압축 도구 활용

```bash
pigz -9 -p 8 bigfile      # gzip의 병렬 버전
pbzip2 -9 -p8 bigfile     # bzip2의 병렬 버전
pixz -9 bigfile           # xz의 병렬 버전
zstd -T0 -19 bigfile      # 모든 CPU 코어 사용
```

---

## zip/unzip — Windows 호환성과 암호화

zip 형식은 Windows와의 호환성이 필요한 경우 유용합니다:

```bash
zip -r archive.zip folder/
unzip archive.zip
```

유용한 옵션:
```bash
zip -r -x '*.git*' -x '*.o' archive.zip folder/
zip -r -e secret.zip documents/     # 암호화 (주의: 레거시 암호화는 취약할 수 있음)
```

**암호화 주의사항**: `zip -e` 명령의 레거시 암호화는 보안에 취약할 수 있습니다. 가능하면 7z(AES-256)나 zstd와 age/gpg 조합을 사용하는 것이 좋습니다.

---

## rsync — 증분 동기화의 핵심 도구

rsync는 로컬 및 원격 파일 동기화에 가장 많이 사용되는 도구입니다:

```bash
# 로컬 동기화
rsync -aHv --delete /src/ /dst/

# 원격 동기화 (SSH 사용)
rsync -aHv -e 'ssh -p 22' /src/ user@server:/dst/
```

### 주요 옵션 설명

- `-a` (archive): 권한, 타임스탬프, 심볼릭 링크 등을 보존합니다.
- `-H`: 하드링크를 보존합니다.
- `-A`: ACL을 보존합니다.
- `-X`: 확장 속성(xattrs)을 보존합니다.
- `--delete`: 대상에 없는 파일을 삭제합니다 (주의 필요).
- `--partial --inplace`: 대용량 파일 전송 시 재시도 효율성을 높입니다.
- `--bwlimit=5m`: 대역폭을 제한합니다.
- `--exclude-from=.rsyncignore`: 제외할 파일 패턴을 지정합니다.
- `--numeric-ids`: 사용자/그룹 이름 대신 숫자 ID를 사용하여 불일치 문제를 회피합니다.
- `--link-dest=/snap/prev`: 하드링크 기반 스냅샷을 생성하여 저장 공간을 절약합니다.

### 하드링크 스냅샷 패턴 (시간별 보관)

```bash
# 매일 스냅샷 생성 (오래된 파일은 전일 스냅샷과 하드링크로 공유)
rsync -a --delete --link-dest=/backup/current/ /data/ /backup/snapshots/$(date +%F)/
rm -f /backup/current
ln -s /backup/snapshots/$(date +%F) /backup/current
```

---

## cpio — find 명령과의 강력한 조합

cpio는 find 명령과 파이프라인으로 연결하여 사용할 때 강력한 아카이빙 도구가 됩니다:

```bash
# 아카이브 생성
find . -xdev -print0 | cpio -0 -ov > backup.cpio

# 아카이브 추출
cpio -idv < backup.cpio

# gzip과 함께 사용
find /etc -type f -name '*.conf' -print0 | cpio -0 -ov | gzip > cfg.cpio.gz
gzip -dc cfg.cpio.gz | cpio -idv
```

cpio의 주요 장점은 find 명령의 강력한 필터링 기능(권한, 파일 타입, 시간 조건 등)과 결합하여 정교한 백업을 생성할 수 있다는 점입니다. 안전을 위해 `--no-absolute-filenames` 옵션으로 절대경로 사용을 방지할 수 있습니다.

---

## dd — 저수준 블록 복제 및 ddrescue

dd는 블록 단위의 저수준 복제 도구로, 디스크 이미징에 유용합니다:

```bash
# 디스크 전체 복제 (주의: 대상 디스크가 완전히 덮어쓰여짐)
sudo dd if=/dev/sda of=/dev/sdb bs=4M status=progress

# 부트 레코드 백업
sudo dd if=/dev/sda of=boot_mbr.img bs=512 count=1

# ISO 이미지를 USB에 기록 (대상 디스크 확인 필수)
sudo dd if=ubuntu.iso of=/dev/sdX bs=4M status=progress && sync
```

### ddrescue — 손상된 디스크 복구 도구

ddrescue는 읽기 실패가 발생한 디스크에서 데이터를 복구할 때 유용합니다:

```bash
# 1단계: 읽을 수 있는 블록부터 빠르게 이미지화
sudo ddrescue -f -n /dev/sda damaged.img ddrescue.log

# 2단계: 재시도 (손상된 구간만 추가로 읽기 시도)
sudo ddrescue -d -r3 /dev/sda damaged.img ddrescue.log
```

ddrescue의 장점은 읽기 실패 구간을 로그 파일로 관리하면서 점진적으로 복구할 수 있다는 점입니다.

---

## 파일시스템 인식 이미징 도구

### partclone — 사용된 블록만 이미지화

```bash
# 백업
sudo partclone.ext4 -c -s /dev/sda1 -o sda1.img

# 복원
sudo partclone.ext4 -r -s sda1.img -o /dev/sda1

# 압축과 함께 사용
sudo partclone.ext4 -c -s /dev/sda1 | zstd -T0 -19 > sda1.img.zst
zstd -dc sda1.img.zst | sudo partclone.ext4 -r -o /dev/sda1
```

### fsarchiver — 파일 단위 보존

```bash
# 백업
sudo fsarchiver savefs /backup/root.fsa /dev/sda1

# 복원
sudo fsarchiver restfs /backup/root.fsa id=0,dest=/dev/sda1
```

### Clonezilla — 통합 이미징 솔루션

Clonezilla는 GUI 기반의 통합 디스크 이미징 도구로, 내부적으로 partclone, ntfsclone, dd, rsync 등을 활용합니다. 네트워크 저장소(NFS, SSH, Samba)와 연동하여 사용할 수 있습니다.

---

## 스냅샷과 일관성 — LVM, Btrfs, ZFS 활용

### LVM 스냅샷을 이용한 백업

```bash
# 10GB 크기의 스냅샷 생성
sudo lvcreate -L 10G -s -n data_snap /dev/vg/data

# 스냅샷 마운트 및 백업
sudo mount /dev/vg/data_snap /mnt/snap
tar --xattrs --acls -czf /backup/data_$(date +%F).tar.gz -C /mnt/snap .

# 스냅샷 제거
sudo umount /mnt/snap
sudo lvremove -y /dev/vg/data_snap
```

### Btrfs/ZFS 스냅샷 및 스트리밍

```bash
# Btrfs 스냅샷
sudo btrfs subvolume snapshot -r /data /data_snap_$(date +%F)
sudo btrfs send /data_snap_2025-11-10 | zstd -T0 -19 > data_2025-11-10.btrfs.zst

# ZFS 스냅샷
sudo zfs snapshot pool/data@2025-11-10
sudo zfs send -I pool/data@prev pool/data@2025-11-10 | zstd -T0 -19 > data.zfs.zst
```

스냅샷의 주요 장점은 파일 시스템의 일관성을 보장하면서 순간적인 백업 지점을 생성할 수 있다는 점입니다.

---

## 무결성과 암호화

### 체크섬과 디지털 서명

```bash
# 체크섬 생성 및 검증
sha256sum backup.tar.zst > backup.tar.zst.sha256
sha256sum -c backup.tar.zst.sha256

# GPG 서명 생성 및 검증
gpg --detach-sign --armor backup.tar.zst
gpg --verify backup.tar.zst.asc backup.tar.zst
```

### 데이터 암호화

```bash
# OpenSSL을 이용한 대칭키 암호화 (AES-256)
openssl enc -aes-256-cbc -salt -pbkdf2 -in backup.tar -out backup.tar.enc
openssl enc -d -aes-256-cbc -pbkdf2 -in backup.tar.enc -out backup.tar

# age를 이용한 현대적 암호화
age -p -o backup.tar.age backup.tar
age -d -o backup.tar backup.tar.age
```

### 전문 백업 도구: restic와 borg

**restic 사용 예시**:
```bash
restic -r s3:s3.amazonaws.com/bucket init
export AWS_ACCESS_KEY_ID=...; export AWS_SECRET_ACCESS_KEY=...
restic -r s3:s3.amazonaws.com/bucket backup /data
restic snapshots
restic restore latest -t /restore
```

**borgbackup 사용 예시**:
```bash
borg init --encryption=repokey-blake2 /backup/borg
borg create /backup/borg::daily-$(date +%F) /data
borg list /backup/borg
borg extract /backup/borg::daily-2025-11-10
```

restic와 borg는 증분 백업, 중복 제거, 암호화, 무결성 검증을 통합적으로 제공하는 현대적인 백업 솔루션입니다.

---

## 클라우드 및 오프사이트 백업 — rclone 활용

rclone은 다양한 클라우드 저장소와의 동기화를 지원하는 도구입니다:

```bash
rclone config                     # S3, Wasabi, Backblaze, Google Drive 등 설정
rclone copy /backup remote:mybucket/host1/ --progress --transfers=8 --checkers=16
rclone sync /backup remote:mybucket/host1/ --delete-after
rclone cryptwrap remote:mybucket/secure/ localcrypt:   # 암호화 래퍼
```

클라우드 백업 시 버전 관리, 객체 수명 주기 정책, 전송 암호화 등을 고려해야 합니다. 비용과 데이터 회수 시간을 고려한 보관 정책 설계가 중요합니다.

---

## 백업 보관 정책 예시

효과적인 백업 관리를 위해 다음과 같은 계층적 보관 정책을 고려할 수 있습니다:

- **일간(Daily)**: 최근 7일간의 백업 보관
- **주간(Weekly)**: 최근 4-5주간의 백업 보관  
- **월간(Monthly)**: 최근 6-12개월간의 백업 보관
- **정기적 복원 테스트**: 분기별 1회 이상의 복원 리허설 수행
- **RPO/RTO 문서화**: 복구 목표 시간과 복구 시점 목표를 명확히 문서화
- **모니터링 및 알림**: 백업 실패 시 자동 알림 시스템 구현

---

## 실전 백업 레시피

### 레시피 1 — LVM 스냅샷을 이용한 무정지 백업

```bash
# LVM 스냅샷 생성
lvcreate -L 10G -s -n data_snap /dev/vg/data
mkdir -p /mnt/snap && mount /dev/vg/data_snap /mnt/snap

# 권한과 확장 속성 보존 + 고압축 zstd 병렬 처리
tar --xattrs --acls --numeric-owner \
    -I 'zstd -T0 -19' -cvf /backup/data_$(date +%F).tar.zst -C /mnt/snap .

# 정리 작업
umount /mnt/snap && lvremove -y /dev/vg/data_snap
```

### 레시피 2 — rsync 하드링크 스냅샷 (저장 공간 절약)

```bash
N=$(date +%F)
rsync -aHAX --delete --link-dest=/backup/current/ /data/ /backup/snapshots/$N/
rm -f /backup/current
ln -s /backup/snapshots/$N /backup/current
```

### 레시피 3 — 손상된 디스크 이미지 복구

```bash
ddrescue -f -n /dev/sda /backup/sda.img /backup/ddrescue.log
ddrescue -d -r3 /dev/sda /backup/sda.img /backup/ddrescue.log
```

### 레시피 4 — tar 증분 백업

```bash
SNAR=/backup/base.snar
tar --listed-incremental=$SNAR -I 'zstd -T0 -3' -cf /backup/full_$(date +%F).tar.zst /srv

# 이후 변경분 백업
tar --listed-incremental=$SNAR -I 'zstd -T0 -3' -cf /backup/incr_$(date +%F_%H%M).tar.zst /srv
```

### 레시피 5 — 백업 무결성 및 암호화 체인

```bash
# 무결성 검증을 위한 체크섬 생성
sha256sum /backup/data_*.tar.zst > /backup/SHA256SUMS
sha256sum -c /backup/SHA256SUMS

# age를 이용한 암호화
age -p -o /offsite/data_$(date +%F).tar.zst.age /backup/data_$(date +%F).tar.zst
```

### 레시피 6 — systemd timer를 이용한 자동화

```ini
# /etc/systemd/system/nightly-backup.service
[Unit]
Description=Nightly Data Backup

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/nightly-backup.sh
User=backup
Group=backup
ProtectSystem=full
NoNewPrivileges=true
```

```ini
# /etc/systemd/system/nightly-backup.timer
[Unit]
Description=Nightly Data Backup Timer

[Timer]
OnCalendar=02:30
RandomizedDelaySec=5m
Persistent=true
Unit=nightly-backup.service

[Install]
WantedBy=timers.target
```

---

## 보안 및 거버넌스 고려사항

효과적인 백업 전략에는 다음과 같은 보안 요소가 포함되어야 합니다:

- **암호화**: 저장 데이터와 전송 중 데이터 모두 암호화 (예: restic/borg + TLS/S3 SSE)
- **키 관리**: GPG/age 키 백업, 키 회수 절차, HSM/KMS 시스템 검토
- **규정 준수**: GDPR, ISMS 등 관련 규정에 따른 보유 기간 및 삭제 증적 관리
- **접근 제어**: 백업 저장소에 대한 쓰기 권한 제한, 랜섬웨어 대비 WORM/버전 관리
- **감사 및 모니터링**: 백업 성공/실패 로그 집계, Slack/PagerDuty 등과의 알림 연동

---

## 핵심 명령어 요약

| 범주 | 명령/옵션 | 주요 기능 |
|---|---|---|
| tar | `--xattrs --acls --selinux --numeric-owner --one-file-system --exclude-from --strip-components -I` | 확장 속성, 보안 컨텍스트, 성능 최적화 |
| 압축 도구 | `pigz, pixz, zstd -T0` | 병렬 처리 및 고성능 압축 |
| zip | `-r -x -e` | Windows 호환성 (암호화 주의) |
| rsync | `-aHAX --delete --link-dest --partial --inplace --bwlimit` | 증분 동기화 및 스냅샷 관리 |
| cpio | `-0 -ov / -idv` | find 명령과의 강력한 조합 |
| dd | `if= of= bs= status=progress` | 블록 단위 복제 |
| ddrescue | `-n` (1단계), `-r` (재시도) | 손상된 디스크 복구 |
| partclone | `-c/-r -s -o` | 사용된 블록만 이미지화 |
| fsarchiver | `savefs/restfs` | 파일 단위 복원 |
| ZFS/Btrfs | `snapshot/send` | 일관된 증분 스냅샷 |
| 무결성/암호화 | `sha256sum, gpg, age, openssl` | 검증 및 보안 |
| 클라우드 동기화 | `rclone copy/sync` | 오프사이트 백업 |

---

## 결론

리눅스 시스템에서 효과적인 압축, 아카이빙, 백업 전략은 데이터 보호의 핵심 요소입니다. 압축은 저장 공간을 절약하고, 아카이빙은 여러 파일을 체계적으로 관리하며, 백업은 데이터 복구 가능성을 보장합니다.

운영 환경에서는 일관성 있는 스냅샷 생성부터 시작하여 증분 백업, 중복 제거, 암호화, 보관 정책에 이르는 종합적인 접근이 필요합니다. 초기에는 간단한 `tar+zstd`나 `rsync --link-dest`로 시작하되, 장기적으로는 restic/borg와 같은 전문 백업 도구와 rclone, systemd timer를 조합한 자동화 시스템을 구축하는 것이 좋습니다.

가장 중요한 원칙은 "백업은 복원이 가능할 때만 의미가 있다"는 것입니다. 정기적인 복원 테스트를 통해 백업 시스템의 신뢰성을 검증하고, 문서화된 복구 절차를 준비해야 합니다. 오늘 당장 작은 규모의 샘플 데이터로 복원 테스트를 시작하는 것이 장기적인 데이터 보호 전략의 첫걸음이 될 것입니다.