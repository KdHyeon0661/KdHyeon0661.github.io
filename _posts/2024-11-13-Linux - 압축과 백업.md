---
layout: post
title: Linux - 압축과 백업
date: 2024-11-13 19:20:23 +0900
category: Linux
---
# 압축·백업·디스크 이미지 전략

## 압축과 아카이빙의 개념 — 먼저 용어를 정리

- **아카이빙(archive)**: 여러 파일/디렉터리를 **하나의 스트림/파일**로 묶는다. 대표: `tar`, `cpio`.
- **압축(compress)**: 데이터 크기를 줄인다. 대표: `gzip`, `bzip2`, `xz`, `zstd`, 병렬 버전 `pigz/pbzip2/pixz`.
- 실무에서는 둘을 결합: **`.tar.gz`, `.tar.xz`, `.tar.zst`** 등.

---

## tar — 아카이브의 표준, 그리고 실무 옵션 총정리

### 기본/확장 사용법

```bash
# 묶기 (압축 없이)

tar -cf archive.tar dir/

# 해제

tar -xf archive.tar

# gzip/bzip2/xz/zstd

tar -czf archive.tar.gz dir/
tar -cjf archive.tar.bz2 dir/
tar -cJf archive.tar.xz dir/
tar --zstd -cf archive.tar.zst dir/
```

### 빈틈 메우기: 반드시 알아둘 실무 옵션

```bash
# 예시

tar -I 'pigz -9 -p 8' -cvf archive.tar.gz dir/      # -I: 커스텀 압축기
tar --zstd -I 'zstd -T0 -19' -cvf archive.tar.zst dir/

# 제외 규칙

tar -czf src.tar.gz src/ --exclude='*.o' --exclude-from=.tarignore

# 안전한 복원(상대경로, 상위탈출 방지, 특정 계층 제거)

tar -xzf archive.tar.gz -C /restore --strip-components=1

# 보존

sudo tar --xattrs --xattrs-include='*' --acls --selinux \
         --numeric-owner -czf backup.tar.gz /important

# 같은 파일시스템만 묶기(마운트 넘지 않음: /proc, /dev 등 제외)

sudo tar --one-file-system -czf rootfs.tar.gz /

# 목록 확인/무결성 확인

tar -tvf archive.tar.gz
tar -tzf archive.tar.gz > /dev/null   # 열람 가능 여부 체크
```

> 포인트
> - **--numeric-owner**: 다른 시스템에서 복원 시 **UID/GID 유지**.
> - **--xattrs/--acls/--selinux**: 권한/보안속성까지 보존.
> - **--one-file-system**: 루트 백업 시 **타 파일시스템 침범 방지**.
> - 추출 시 **--strip-components**로 상위 디렉터리 탈출/경로 오염 방지.

### tar 증분/차등 백업(`--listed-incremental`)

```bash
# 스냅샷 생성

sudo tar --listed-incremental=/var/backups/base.snar -czf full_$(date +%F).tar.gz /data

# 증분(변경분만)

sudo tar --listed-incremental=/var/backups/base.snar -czf incr_$(date +%F).tar.gz /data

# 복원은 full → 증분 순서대로 적용

```
- 간편하지만, **SNAR 파일** 관리 필요. 대규모/장기 보관은 **restic/borg** 같은 백업 도구 추천(아래 참고).

---

## 단일 파일 압축기 — gzip/bzip2/xz/zstd와 병렬판

```bash
gzip -k file.txt        # file.txt.gz (원본 유지: -k)
bzip2 -k file.txt       # .bz2
xz -k file.txt          # .xz
zstd -k file.txt        # .zst (빠른 고압축)
unxz file.txt.xz
gunzip file.txt.gz
```

### 압축률 vs 속도(대략)

- `속도`: **zstd ≈ gzip > bzip2 > xz**
- `압축률`: **xz ≳ zstd(고레벨) > bzip2 > gzip**

### 병렬 압축기

```bash
pigz -9 -p 8 bigfile      # gzip 병렬버전
pbzip2 -9 -p8 bigfile     # bzip2 병렬
pixz -9 bigfile           # xz 병렬(스트리밍 분할)
zstd -T0 -19 bigfile      # 모든 코어 사용(T0)
```

---

## zip/unzip — Windows 호환과 암호화 주의점

```bash
zip -r archive.zip folder/
unzip archive.zip
```
- 유용한 옵션:
```bash
zip -r -x '*.git*' -x '*.o' archive.zip folder/
zip -r -e secret.zip documents/     # 암호화(구암호는 취약할 수 있음)
```

> **암호화 주의**: `zip -e`의 레거시 암호화는 안전하지 않을 수 있다. 가능하면 **7z(AES-256)** 또는 **zstd+age/gpg** 조합을 추천.

---

## rsync — 증분·동기화의 왕도 (로컬/원격)

```bash
# 로컬 동기화

rsync -aHv --delete /src/ /dst/

# 원격(SSH)

rsync -aHv -e 'ssh -p 22' /src/ user@server:/dst/
```

### 핵심 옵션 설명

- `-a`(archive): 퍼미션/타임스탬프/링크 보존
- `-H` 하드링크 보존, `-A` ACL, `-X` xattrs(수집기/OS 지원 필요)
- `--delete` 대상에 없는 파일 삭제(**주의**)
- `--partial --inplace` 대용량 전송 재시도 효율화
- `--bwlimit=5m` 대역폭 제한
- `--exclude-from=.rsyncignore` 제외 규칙
- `--numeric-ids` 사용자/그룹명의 불일치 문제 회피
- `--link-dest=/snap/prev` **하드링크 기반 스냅샷** (이력 유지 + 저장공간 절약)

### 하드링크 스냅샷 패턴(시간축 보관)

```bash
# 매일 스냅샷(오래된 파일은 하드링크로 전일 스냅샷과 공유)

rsync -a --delete --link-dest=/backup/current/ /data/ /backup/snapshots/$(date +%F)/
rm -f /backup/current
ln -s /backup/snapshots/$(date +%F) /backup/current
```

---

## cpio — find와 궁합이 좋은 스트림 아카이버

```bash
# 생성

find . -xdev -print0 | cpio -0 -ov > backup.cpio

# 해제

cpio -idv < backup.cpio

# gzip과 파이프

find /etc -type f -name '*.conf' -print0 | cpio -0 -ov | gzip > cfg.cpio.gz
gzip -dc cfg.cpio.gz | cpio -idv
```

> 장점: **find의 강력한 필터**(권한/타입/시간조건 등)와 결합해 정교한 백업 가능.
> 안전: `--no-absolute-filenames`로 절대경로 무시.

---

## dd — 저수준 블록 복제 (그리고 ddrescue)

```bash
# 디스크 전체 복제(주의: 대상 완전 덮어씀)

sudo dd if=/dev/sda of=/dev/sdb bs=4M status=progress

# 백업

sudo dd if=/dev/sda of=boot_mbr.img bs=512 count=1

# ISO→USB (정확한 대상 확인 필수)

sudo dd if=ubuntu.iso of=/dev/sdX bs=4M status=progress && sync
```

### ddrescue — 손상 디스크의 구원자

```bash
# 1차: 읽히는 블록부터 빠르게 이미지화

sudo ddrescue -f -n /dev/sda damaged.img ddrescue.log

# 2차: 재시도(손상 구간만 추가 읽기)

sudo ddrescue -d -r3 /dev/sda damaged.img ddrescue.log
```
- 장점: 읽기 실패 구간을 **로그**로 관리하며 점진 복구.

---

## 파일시스템 인식 이미지: partclone / fsarchiver / Clonezilla

### partclone — 사용된 블록만(효율↑)

```bash
sudo partclone.ext4 -c -s /dev/sda1 -o sda1.img    # 백업
sudo partclone.ext4 -r -s sda1.img -o /dev/sda1    # 복원

# 압축 파이프

sudo partclone.ext4 -c -s /dev/sda1 | zstd -T0 -19 > sda1.img.zst
zstd -dc sda1.img.zst | sudo partclone.ext4 -r -o /dev/sda1
```

### fsarchiver — 파일 단위 보존(UID/GID/ACL/xattrs)

```bash
sudo fsarchiver savefs /backup/root.fsa /dev/sda1
sudo fsarchiver restfs /backup/root.fsa id=0,dest=/dev/sda1
```

### Clonezilla — 통합 GUI/자동화

- Live 부팅 후 디스크/파티션 이미지 생성/복원
- 내부적으로 `partclone/ntfsclone/dd/rsync` 활용
- 네트워크 저장소(NFS/SSH/Samba) 연동 가능

---

## 스냅샷과 일관성 — LVM·Btrfs·ZFS를 백업에 녹이기

### LVM 스냅샷

```bash
# 10G 스냅샷 생성(읽기전용 백업 소스)

sudo lvcreate -L 10G -s -n data_snap /dev/vg/data

# 스냅샷 마운트해서 백업

sudo mount /dev/vg/data_snap /mnt/snap
tar --xattrs --acls -czf /backup/data_$(date +%F).tar.gz -C /mnt/snap .

# 스냅샷 제거

sudo umount /mnt/snap
sudo lvremove -y /dev/vg/data_snap
```

### Btrfs/ZFS 스냅샷 & 스트리밍

```bash
# Btrfs

sudo btrfs subvolume snapshot -r /data /data_snap_$(date +%F)
sudo btrfs send /data_snap_2025-11-10 | zstd -T0 -19 > data_2025-11-10.btrfs.zst

# ZFS

sudo zfs snapshot pool/data@2025-11-10
sudo zfs send -I pool/data@prev pool/data@2025-11-10 | zstd -T0 -19 > data.zfs.zst
```
- 장점: **순간 스냅샷**으로 **일관성** 확보, 증분 전송 가능.

---

## 무결성과 암호화 — 체크섬·서명·암호 도구

### 체크섬과 서명

```bash
sha256sum backup.tar.zst > backup.tar.zst.sha256
sha256sum -c backup.tar.zst.sha256

# GPG 서명/검증

gpg --detach-sign --armor backup.tar.zst
gpg --verify backup.tar.zst.asc backup.tar.zst
```

### 대칭/비대칭 암호화

```bash
# openssl 대칭(AES-256)

openssl enc -aes-256-cbc -salt -pbkdf2 -in backup.tar -out backup.tar.enc
openssl enc -d -aes-256-cbc -pbkdf2 -in backup.tar.enc -out backup.tar

# age(심플/현대적)

age -p -o backup.tar.age backup.tar
age -d -o backup.tar backup.tar.age
```

### 전용 백업 스토어(중복제거/암호화 내장)

- **restic**:
```bash
restic -r s3:s3.amazonaws.com/bucket init
export AWS_ACCESS_KEY_ID=...; export AWS_SECRET_ACCESS_KEY=...
restic -r s3:s3.amazonaws.com/bucket backup /data
restic snapshots
restic restore latest -t /restore
```
- **borgbackup**:
```bash
borg init --encryption=repokey-blake2 /backup/borg
borg create /backup/borg::daily-$(date +%F) /data
borg list /backup/borg
borg extract /backup/borg::daily-2025-11-10
```

> restic/borg: **증분·중복제거·암호화·무결성**을 한 번에 해결, **장기 보관**에 강력.

---

## 클라우드/오프사이트 — rclone로 원격 저장소로 밀기

```bash
rclone config                     # S3/Wasabi/Backblaze/Drive 등 설정
rclone copy /backup remote:mybucket/host1/ --progress --transfers=8 --checkers=16
rclone sync /backup remote:mybucket/host1/ --delete-after
rclone cryptwrap remote:mybucket/secure/ localcrypt:   # 암호화 래퍼
```

- **버전 관리/수명 주기**(Object Lock/Glacier)와 **전송 암호/TLS** 고려.
- **비용/회수시간** 감안한 **보관 정책** 설계.

---

## 예시

- **일간(Son)**: 최근 7일 보관
- **주간(Father)**: 최근 4~5주 보관
- **월간(Grandfather)**: 최근 6~12개월 보관
- **테스트 복원**: 분기 1회 이상 **복원 리허설**을 의무화
- **RPO/RTO** 목표를 문서화, **모니터링/알림**(실패 시 Page/Slack) 자동화

---

## 실전 레시피 모음

### 레시피 1 — `/data` 무정지 스냅샷 백업(tar+zstd)

```bash
# LVM 스냅샷

lvcreate -L 10G -s -n data_snap /dev/vg/data
mkdir -p /mnt/snap && mount /dev/vg/data_snap /mnt/snap

# 권한·xattr 보존 + 고압축 zstd 병렬

tar --xattrs --acls --numeric-owner \
    -I 'zstd -T0 -19' -cvf /backup/data_$(date +%F).tar.zst -C /mnt/snap .

# 정리

umount /mnt/snap && lvremove -y /dev/vg/data_snap
```

### 레시피 2 — rsync 하드링크 스냅샷(저장공간 절약)

```bash
N=$(date +%F)
rsync -aHAX --delete --link-dest=/backup/current/ /data/ /backup/snapshots/$N/
rm -f /backup/current
ln -s /backup/snapshots/$N /backup/current
```

### 레시피 3 — 손상 디스크 이미지 확보(ddrescue)

```bash
ddrescue -f -n /dev/sda /backup/sda.img /backup/ddrescue.log
ddrescue -d -r3 /dev/sda /backup/sda.img /backup/ddrescue.log
```

### 레시피 4 — tar 증분(간단 운용)

```bash
SNAR=/backup/base.snar
tar --listed-incremental=$SNAR -I 'zstd -T0 -3' -cf /backup/full_$(date +%F).tar.zst /srv
# 이후 변경분

tar --listed-incremental=$SNAR -I 'zstd -T0 -3' -cf /backup/incr_$(date +%F_%H%M).tar.zst /srv
```

### 레시피 5 — 백업 무결성·암호화 체인

```bash
# 무결성

sha256sum /backup/data_*.tar.zst > /backup/SHA256SUMS
sha256sum -c /backup/SHA256SUMS

# 암호화(age)

age -p -o /offsite/data_$(date +%F).tar.zst.age /backup/data_$(date +%F).tar.zst
```

### 레시피 6 — systemd timer 스케줄링(11편 연계)

```ini
# /etc/systemd/system/nightly-backup.service

[Unit]
Description=Nightly Data Backup

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/nightly-backup.sh
User=backup
Group=backup
ProtectSystem=full
NoNewPrivileges=true
```

```ini
# /etc/systemd/system/nightly-backup.timer

[Unit]
Description=Nightly Data Backup Timer

[Timer]
OnCalendar=02:30
RandomizedDelaySec=5m
Persistent=true
Unit=nightly-backup.service

[Install]
WantedBy=timers.target
```

---

## 체크리스트 — 백업은 “복원”이 된다면 백업이다

- **샘플 복원 리허설**: 정기적으로 **격리 환경**에서 복원 절차를 검증
- **버전/시점** 선택(증분 체인 순서)
- 권한/소유자/ACL/xattrs가 **실제 복원**되는지 확인
- **부팅 가능 이미지**는 VM/실장비로 부팅 시험
- **문서화**: “누가/언제/어디서/무엇을/어떻게”를 위키화

---

## 보안·거버넌스 요점

- **암호화**: 저장(rest)과 전송(in-transit) 모두(예: restic/borg + TLS/S3 SSE).
- **키 관리**: GPG/age 키 백업, 회수 절차, HSM/KMS 검토.
- **보관정책**: GDPR/ISMS 등 규정 준수, 보유기간 및 삭제 증적.
- **접근제어**: 백업 저장소는 쓰기 권한 제한, **랜섬웨어 대비** WORM/버전닝.
- **감사/알림**: 실패/성공 로그 집계, Slack/PagerDuty 연동.

---

## 명령어·옵션 요약표(치트시트)

| 범주 | 명령/옵션 | 핵심 |
|---|---|---|
| tar | `--xattrs --acls --selinux --numeric-owner --one-file-system --exclude-from --strip-components -I 'pigz/zstd'` | 권한/보안/성능/안전 |
| gzip/xz/zstd | `pigz/pixz/zstd -T0` | 병렬·고성능 |
| zip | `-r -x -e` | Windows 호환(암호화는 주의) |
| rsync | `-aHAX --delete --link-dest --partial --inplace --bwlimit` | 증분·스냅샷 |
| cpio | `-0 -ov / -idv` | find와 조합 |
| dd | `if= of= bs= status=progress` | 블록 복제 |
| ddrescue | `-n` 빠른 1차, `-r` 재시도 | 손상 디스크 |
| partclone | `-c/-r -s -o` | 사용블록만 이미지 |
| fsarchiver | `savefs/restfs` | 파일 단위 복원 |
| zfs/btrfs | `snapshot/send` | 일관·증분 스트림 |
| 무결성/암호 | `sha256sum, gpg, age, openssl` | 검증/보안 |
| 클라우드 | `rclone copy/sync` | 오프사이트 백업 |

---

## 마무리

- **압축은 공간 절감**, **아카이빙은 묶기**, **백업은 복원성**이다.
- 운영에서는 **일관성 확보(스냅샷) → 효율(증분/중복제거) → 보안(암호/무결성) → 보관정책(수명주기)** 순으로 설계하라.
- 시작은 간단히 `tar+zstd` 또는 `rsync --link-dest`, 장기 운용은 **restic/borg + rclone + systemd timer**로 **표준화/자동화**하라.
- 무엇보다 **복원 리허설**이 전부를 증명한다. 오늘 당장, 10GB 정도의 샘플로 **복원 테스트**를 해보자.
