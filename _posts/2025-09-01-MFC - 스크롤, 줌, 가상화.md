---
layout: post
title: MFC - 스크롤, 줌, 가상화
date: 2025-09-01 18:25:23 +0900
category: MFC
---
# 스크롤/줌/가상화: 큰 캔버스·이미지 뷰어 패턴 (MFC/Win32 실전 총정리 + 예제 다수)

초대형 이미지(수만×수만 px), 긴 타임라인, 기하학 캔버스, 지도/도면 등 **스크롤·줌**이 핵심인 화면을 **부드럽고 가볍게** 구현하는 방법을 **MFC/Win32** 관점에서 정리합니다.  
`CScrollView` 기반과 **커스텀 뷰(CWnd)** 기반을 모두 다루며, **더블버퍼링**, **정확한 휠-커서 기준 줌**, **관성/패닝**, **타일 가상화(LOD/피라미드)**, **백그라운드 디코딩 + LRU 캐시**까지 **생략 없이** 담았습니다.

> 대상: SDI/MDI/대화상자 앱, Windows 10/11, x64/Unicode 권장  
> 그래픽: GDI/GDI+ 혼용. 초대형 이미지 디코딩엔 WIC 권장(필요 시 GDI+로 대체 가능).  
> 표기: 모든 코드는 ``` 로 감싸며, 재빨리 붙여 넣어 테스트 가능한 형태를 지향합니다.

---

## 0) 큰 그림: “스크롤/줌/가상화” 3단 합체

1. **스크롤**: 가시 영역(viewport)을 **가상 캔버스(logical world)** 위에서 이동  
2. **줌**: **화면 좌표 ↔ 논리 좌표** 사이의 **스케일** 변경(커서 고정/중심 고정 등 정책)  
3. **가상화**: 보여야 하는 부분만 **지연 로딩/부분 렌더링**, 나머지는 **타일 캐시**로 관리

핵심은 **좌표 변환**과 **부분 무효화**(InvalidateRect), **오프스크린 렌더링**(플리커 제거), 그리고 **타일 캐시** 설계입니다.

---

# 1) 좌표계·스크롤의 기본기

## 1-1. 뷰포트/월드/장치 좌표

- **월드(논리)**: 원본 데이터의 “실제” 좌표(픽셀·미터·프레임 등)
- **뷰포트(화면)**: 현재 화면에 보이는 사각형(스크롤/줌에 따라 바뀜)
- **장치(DC)**: 그리기 대상 장치(윈도우 DC) 좌표

변환(픽셀 기반 예):
```
device = (world * zoom) - scroll_offset
world  = (device + scroll_offset) / zoom
```

## 1-2. 스크롤바와 가상 크기

- `CScrollView`는 `SetScrollSizes(MM_TEXT, CSize(totalW,totalH))` 로 **가상 문서 크기**를 설정.  
- 맞춤 구현(CWnd 기반)은 `SCROLLINFO` 를 설정하고 `WM_HSCROLL/WM_VSCROLL`에서 오프셋 갱신.

---

# 2) 패턴 A — CScrollView 기반(빠른 스타터)

### 2-1. 최소 골격

```cpp
class CZoomScrollView : public CScrollView {
    DECLARE_DYNCREATE(CZoomScrollView)
public:
    double m_zoom = 1.0;        // 0.1 ~ 8.0
    CSize  m_worldSize{10000, 8000}; // 논리 크기(원본 px 기준)
protected:
    afx_msg void OnInitialUpdate() override {
        CScrollView::OnInitialUpdate();
        UpdateScrollSizes();
    }
    void UpdateScrollSizes() {
        // CScrollView는 MM_TEXT 기준 px 스크롤. zoom을 반영한 가상 크기 지정
        CSize dev( (int)(m_worldSize.cx*m_zoom), (int)(m_worldSize.cy*m_zoom) );
        SetScrollSizes(MM_TEXT, dev);
    }
    void OnDraw(CDC* pDC) override {
        CRect rc; GetClientRect(&rc);
        CPoint origin = GetScrollPosition(); // 스크롤 오프셋(디바이스 px)
        // 장치 → 월드 역변환: world = (device + origin) / zoom
        // 화면에 필요한 월드 사각형 계산 후 그리기(부분 렌더링)
        CRectF worldView(
            (float)origin.x / (float)m_zoom,
            (float)origin.y / (float)m_zoom,
            (float)rc.Width() / (float)m_zoom,
            (float)rc.Height()/ (float)m_zoom);

        // 배경
        pDC->FillSolidRect(rc, RGB(255,255,255));

        // 예: 격자
        CPen pen(PS_DOT, 1, RGB(220,220,220));
        auto oldP = pDC->SelectObject(&pen);
        int step = max(8, (int)(20*m_zoom));
        for (int x=-origin.x%step; x<rc.right; x+=step) { pDC->MoveTo(x,0); pDC->LineTo(x,rc.bottom); }
        for (int y=-origin.y%step; y<rc.bottom; y+=step){ pDC->MoveTo(0,y); pDC->LineTo(rc.right,y); }
        pDC->SelectObject(oldP);

        // 예: 월드 좌표(100,100, 400×300) 사각형을 디바이스로 변환 후 그리기
        CRectF wrect(100,100,400,300);
        CRect drect(
            int(wrect.left  * m_zoom - origin.x),
            int(wrect.top   * m_zoom - origin.y),
            int(wrect.right * m_zoom - origin.x),
            int(wrect.bottom* m_zoom - origin.y));
        pDC->FillSolidRect(drect, RGB(245,250,255));
        pDC->Rectangle(drect);
    }
    afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt) {
        // 커서 고정 줌(아래 3-2에서 자세히)
        double before = m_zoom;
        if (zDelta > 0) m_zoom = min(8.0, m_zoom*1.1); else m_zoom = max(0.1, m_zoom/1.1);
        CPoint origin = GetScrollPosition();
        ScreenToClient(&pt);
        // 월드 좌표의 커서 점
        CPointF w(
            (origin.x + pt.x)/before,
            (origin.y + pt.y)/before);
        // 새 zoom에서 해당 점이 다시 커서에 오도록 origin 재계산
        CPoint newOrigin(
            int(w.x*m_zoom - pt.x),
            int(w.y*m_zoom - pt.y));
        ScrollToPosition(newOrigin);
        UpdateScrollSizes();
        Invalidate(FALSE);
        return TRUE;
    }
    DECLARE_MESSAGE_MAP()
};
BEGIN_MESSAGE_MAP(CZoomScrollView, CScrollView)
    ON_WM_MOUSEWHEEL()
END_MESSAGE_MAP()
```

**장점**: 스크롤 관리가 편함(자동 스크롤바, Page/Line 단위 등).  
**단점**: 매우 큰 크기(>2^31 px)나 초미세 커스터마이즈에 제약. 이런 경우 **CWnd 기반**으로 전환.

---

# 3) 패턴 B — CWnd 기반(완전 커스텀, 추천 템플릿 포함)

**핵심**: `m_offset`(스크롤 오프셋, device px), `m_zoom`(배율), `m_worldSize`(논리 px).  
`WM_HSCROLL/WM_VSCROLL/WM_MOUSEWHEEL`에서 정확한 수학으로 갱신하고, `OnPaint`에서는 **더블버퍼** + **부분 렌더링**.

### 3-1. 커스텀 뷰 클래스(더블버퍼 + 스크롤바 + 휠 줌)

```cpp
class CZoomCanvas : public CWnd {
    DECLARE_DYNAMIC(CZoomCanvas)
public:
    BOOL Create(CWnd* parent, UINT id, const CRect& r) {
        CString cls = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW, ::LoadCursor(nullptr, IDC_ARROW));
        return CWnd::CreateEx(WS_EX_COMPOSITED, cls, L"", WS_CHILD|WS_VISIBLE|WS_HSCROLL|WS_VSCROLL, r, parent, id);
    }

    // 상태
    double m_zoom = 1.0;              // 0.05 ~ 32
    CSize  m_world{20000, 15000};     // 논리 px
    CPoint m_offset{0,0};             // 디바이스 px 기준 스크롤 오프셋(좌상단 세계가 얼마만큼 밀려났는지)
    CDC     m_mem; CBitmap m_bmp; CSize m_buf{0,0}; // 백버퍼

protected:
    void EnsureBuffer(int cx, int cy) {
        if (m_buf.cx==cx && m_buf.cy==cy && m_mem.m_hDC) return;
        CClientDC dc(this);
        m_mem.DeleteDC(); m_bmp.DeleteObject();
        m_mem.CreateCompatibleDC(&dc);
        m_bmp.CreateCompatibleBitmap(&dc, cx, cy);
        m_mem.SelectObject(&m_bmp);
        m_buf = {cx, cy};
    }
    void UpdateScrollbars() {
        CRect rc; GetClientRect(&rc);
        const int vw = rc.Width(), vh = rc.Height();
        const int cw = (int)std::max(0.0, m_world.cx*m_zoom);
        const int ch = (int)std::max(0.0, m_world.cy*m_zoom);

        SCROLLINFO si{sizeof(SCROLLINFO), SIF_ALL};
        // H
        si.nMin = 0; si.nMax = std::max(0, cw-1);
        si.nPage = std::max(1, vw);
        si.nPos  = std::clamp(m_offset.x, 0, std::max(0, cw - vw));
        SetScrollInfo(SB_HORZ, &si, TRUE);
        // V
        si.nMin = 0; si.nMax = std::max(0, ch-1);
        si.nPage = std::max(1, vh);
        si.nPos  = std::clamp(m_offset.y, 0, std::max(0, ch - vh));
        SetScrollInfo(SB_VERT, &si, TRUE);
    }
    void ClampOffset() {
        CRect rc; GetClientRect(&rc);
        int cw = (int)(m_world.cx*m_zoom);
        int ch = (int)(m_world.cy*m_zoom);
        m_offset.x = std::clamp(m_offset.x, 0, std::max(0, cw - rc.Width()));
        m_offset.y = std::clamp(m_offset.y, 0, std::max(0, ch - rc.Height()));
    }
    void DeviceToWorldRect(const CRect& dev, CRect& world) const {
        world.left   = (int)((dev.left  + m_offset.x)/m_zoom);
        world.top    = (int)((dev.top   + m_offset.y)/m_zoom);
        world.right  = (int)((dev.right + m_offset.x)/m_zoom);
        world.bottom = (int)((dev.bottom+ m_offset.y)/m_zoom);
        world.IntersectRect(&world, CRect(0,0,m_world.cx, m_world.cy));
    }

    // ----- 그리기 (여기서 원하는 만큼 정밀하게) -----
    void RenderOffscreen(const CRect& rcClient) {
        // 1) 백그라운드
        m_mem.FillSolidRect(rcClient, RGB(255,255,255));

        // 2) 가시 월드 영역 계산
        CRect wview; DeviceToWorldRect(rcClient, wview);

        // 3) 예시: 격자 (줌 고려)
        int step = std::max(8, (int)(20*m_zoom));
        CPen grid(PS_DOT, 1, RGB(230,230,230));
        auto op = m_mem.SelectObject(&grid);
        for (int x=-m_offset.x%step; x<rcClient.right; x+=step){ m_mem.MoveTo(x,0); m_mem.LineTo(x,rcClient.bottom); }
        for (int y=-m_offset.y%step; y<rcClient.bottom; y+=step){ m_mem.MoveTo(0,y); m_mem.LineTo(rcClient.right,y); }
        m_mem.SelectObject(op);

        // 4) 예시: 큰 이미지 일부 그리기(타일러와 결합 시 6장 참조). 여기선 단색 박스들로 대체.
        // world 오브젝트(100,100, 600×400)
        CRect w(100,100,700,500);
        CRect i; if (i.IntersectRect(&w, &wview)) {
            CRect d(
               int(i.left  * m_zoom - m_offset.x),
               int(i.top   * m_zoom - m_offset.y),
               int(i.right * m_zoom - m_offset.x),
               int(i.bottom* m_zoom - m_offset.y));
            m_mem.FillSolidRect(d, RGB(245,250,255));
            m_mem.Rectangle(d);
        }

        // 5) 텍스트(디바이스 기준으로)
        CString msg; msg.Format(L"zoom=%.2f  offset=(%d,%d)  world=%dx%d", m_zoom, m_offset.x, m_offset.y, m_world.cx, m_world.cy);
        m_mem.SetBkMode(TRANSPARENT); m_mem.SetTextColor(RGB(50,50,50));
        m_mem.TextOut(10, 10, msg);
    }

    // ----- 메시지 -----
    afx_msg void OnPaint(){
        CPaintDC dc(this);
        CRect rc; GetClientRect(&rc);
        EnsureBuffer(rc.Width(), rc.Height());
        RenderOffscreen(rc);
        dc.BitBlt(0,0, rc.Width(), rc.Height(), &m_mem, 0,0, SRCCOPY);
    }
    afx_msg BOOL OnEraseBkgnd(CDC*) { return TRUE; }

    afx_msg void OnSize(UINT, int cx, int cy){
        EnsureBuffer(cx, cy);
        ClampOffset();
        UpdateScrollbars();
        Invalidate(FALSE);
    }
    afx_msg void OnHScroll(UINT code, UINT pos, CScrollBar* bar){
        SCROLLINFO si{sizeof(si), SIF_ALL}; GetScrollInfo(SB_HORZ, &si);
        int old = m_offset.x;
        switch (code) {
            case SB_LINELEFT:   m_offset.x -= 30; break;
            case SB_LINERIGHT:  m_offset.x += 30; break;
            case SB_PAGELEFT:   m_offset.x -= (int)si.nPage; break;
            case SB_PAGERIGHT:  m_offset.x += (int)si.nPage; break;
            case SB_THUMBTRACK: m_offset.x = pos; break;
        }
        ClampOffset(); if (m_offset.x!=old){ UpdateScrollbars(); Invalidate(FALSE); }
    }
    afx_msg void OnVScroll(UINT code, UINT pos, CScrollBar* bar){
        SCROLLINFO si{sizeof(si), SIF_ALL}; GetScrollInfo(SB_VERT, &si);
        int old = m_offset.y;
        switch (code) {
            case SB_LINEUP:     m_offset.y -= 30; break;
            case SB_LINEDOWN:   m_offset.y += 30; break;
            case SB_PAGEUP:     m_offset.y -= (int)si.nPage; break;
            case SB_PAGEDOWN:   m_offset.y += (int)si.nPage; break;
            case SB_THUMBTRACK: m_offset.y = pos; break;
        }
        ClampOffset(); if (m_offset.y!=old){ UpdateScrollbars(); Invalidate(FALSE); }
    }

    // 3-2) 휠 줌(커서 고정)
    afx_msg BOOL OnMouseWheel(UINT, short zDelta, CPoint ptScreen) {
        ScreenToClient(&ptScreen);
        double before = m_zoom;
        m_zoom = (zDelta>0) ? std::min(32.0, m_zoom*1.1) : std::max(0.05, m_zoom/1.1);
        // 커서 고정: (world under cursor) = const
        double wx = (m_offset.x + ptScreen.x)/before;
        double wy = (m_offset.y + ptScreen.y)/before;
        m_offset.x = int(wx*m_zoom - ptScreen.x);
        m_offset.y = int(wy*m_zoom - ptScreen.y);
        ClampOffset(); UpdateScrollbars(); Invalidate(FALSE);
        return TRUE;
    }

    // 3-3) 마우스 드래그 패닝
    bool   m_panning=false; CPoint m_dragStart;
    afx_msg void OnLButtonDown(UINT, CPoint pt){ SetCapture(); m_panning=true; m_dragStart=pt; }
    afx_msg void OnMouseMove(UINT, CPoint pt){
        if (!m_panning) return;
        CPoint d = pt - m_dragStart; m_dragStart=pt;
        m_offset -= d; ClampOffset(); UpdateScrollbars(); Invalidate(FALSE);
    }
    afx_msg void OnLButtonUp(UINT, CPoint){ if(m_panning){ m_panning=false; ReleaseCapture(); } }

    // 공용 API
public:
    void SetWorldSize(CSize sz){ m_world=sz; ClampOffset(); UpdateScrollbars(); Invalidate(FALSE); }
    void SetZoom(double z, const CPoint* pAnchorDevice=nullptr){
        if (z<0.05 || z>32.0) return;
        if (pAnchorDevice){
            double wx = (m_offset.x + pAnchorDevice->x)/m_zoom;
            double wy = (m_offset.y + pAnchorDevice->y)/m_zoom;
            m_zoom = z;
            m_offset.x = int(wx*m_zoom - pAnchorDevice->x);
            m_offset.y = int(wy*m_zoom - pAnchorDevice->y);
        } else m_zoom = z;
        ClampOffset(); UpdateScrollbars(); Invalidate(FALSE);
    }

    DECLARE_MESSAGE_MAP()
};
BEGIN_MESSAGE_MAP(CZoomCanvas, CWnd)
    ON_WM_PAINT()
    ON_WM_ERASEBKGND()
    ON_WM_SIZE()
    ON_WM_HSCROLL()
    ON_WM_VSCROLL()
    ON_WM_MOUSEWHEEL()
    ON_WM_LBUTTONDOWN()
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
END_MESSAGE_MAP()
```

**특징**  
- **커서 기준 줌**: 사용자가 보는 지점을 **정확히 붙들고** 배율만 변경 → UX의 핵심  
- **더블 버퍼** + `OnEraseBkgnd=TRUE` → 플리커 제거  
- 스크롤바 범위/페이지는 **줌 반영한 총 크기**로 계산

---

# 4) 정밀 줌 UX: 휠/터치/키보드

## 4-1. 줌 단계 관리 & 적응형 스텝
- **로그 스케일** 사용: `zoom *= 2^(delta/120 * step)` → 고/저 배율에서 체감 균일  
- **최소/최대**: 1%~3200% 정도(0.01~32) 범위 권장  
- **정확한 100%**(원본 픽셀 1:1) 버튼 제공

```cpp
double ZoomStep(double z, int wheelDelta) {
    // delta=120 per notch
    double factor = std::pow(2.0, (wheelDelta/120.0)*0.2); // 20% of an octave
    return std::clamp(z*factor, 0.05, 32.0);
}
```

## 4-2. 확대 중심 정책
- **커서 고정**(권장): 시각적 기준 유지  
- **뷰 중앙 고정**: 프레임 프로그램/도면뷰에서 선호되기도  
- 옵션으로 전환 가능하게

## 4-3. 터치/트랙패드
- `WM_GESTURE`(핀치) 또는 고수준 라이브러리 사용  
- **관성 스크롤**: 꾹 드래그 후 떼면 속도 감쇠하며 이동(5-3 참고)

---

# 5) 스크롤을 부드럽게: 더티영역/스와이프/관성

## 5-1. 부분 무효화 + ScrollWindowEx

스크롤 시 전체 무효화 대신 **Shift + Invalidate**:

```cpp
void SmoothScrollBy(CPoint delta) {
    // 1) 이미 그린 백버퍼 일부를 이동
    ScrollWindowEx(-delta.x, -delta.y, nullptr, nullptr, nullptr, nullptr, SW_INVALIDATE);
    // 2) 오프셋 갱신
    m_offset += delta; ClampOffset(); UpdateScrollbars();
    // 3) 이동으로 드러난 가장자리만 WM_PAINT에서 새로 그림(자동 무효화)
}
```

> 백버퍼로 화면 복사 비용을 줄이고, **가장자리만** 새로 그려 성능↑

## 5-2. 키보드 스크롤
- 방향키/페이지 업다운 → `OnKeyDown` 에서 `SmoothScrollBy`

## 5-3. 관성(kinetic) 패닝(기본형)

```cpp
// 드래그 중 속도 추적→ MouseUp 후 타이머로 감쇠 이동
CPoint m_v{0,0}; ULONGLONG m_lastTime=0;
void StartPan() { m_v={0,0}; m_lastTime = GetTickCount64(); }
void TrackPan(CPoint delta) {
    ULONGLONG now=GetTickCount64(); double dt= (now-m_lastTime)/1000.0; m_lastTime=now;
    // 지수 평균으로 속도 추정
    m_v.x = (int)(0.7*m_v.x + 0.3*(delta.x/dt));
    m_v.y = (int)(0.7*m_v.y + 0.3*(delta.y/dt));
}
void EndPan() {
    SetTimer(42, 16, nullptr); // 관성 타이머
}
afx_msg void OnTimer(UINT_PTR id) {
    if (id==42) {
        // 감쇠
        m_v.x = (int)(m_v.x*0.9); m_v.y=(int)(m_v.y*0.9);
        if (abs(m_v.x)<1 && abs(m_v.y)<1){ KillTimer(42); return; }
        SmoothScrollBy(CPoint(-m_v.x/60, -m_v.y/60)); // 60fps 기준
    }
}
```

---

# 6) 대용량 이미지/대캔버스 가상화: 타일 + LOD 피라미드

수만×수만 픽셀 이미지를 한 번에 디코딩/스케일링하면 **메모리/시간 폭발**.  
**타일(Tile)** 로 쪼개고, **줌 레벨별 다운샘플(LOD pyramid)** 을 준비해 **필요한 타일만** 로드/그리기.

## 6-1. 타일 좌표계

- 줌 레벨 `z`: 0(최저해상도) ~ N(원본)  
- 각 z에서 이미지 크기: `Wz = ceil(W0 / 2^(N-z))`, `Hz = ceil(H0 / 2^(N-z))`  
- 타일 크기(T): 256 또는 512 권장  
- 타일 인덱스: `(tx, ty)`, 0..ceil(Wz/T)-1, 0..ceil(Hz/T)-1

## 6-2. 현재 줌에서 필요한 z 선택

- `z`를 연속값으로 운용(예: 0.05~32)하더라도, **가장 가까운 정수 LOD**를 선택해 타일 표시(또는 두 LOD를 블렌딩)
- `z_to_LOD = round(log2(z_base * z))` 형태로 설계(원본이 LOD N일 때 맵핑)

## 6-3. 타일 로더 + LRU 캐시(스레드)

```cpp
struct TileKey { int level, tx, ty; bool operator<(const TileKey& o) const {
    return std::tie(level,tx,ty) < std::tie(o.level,o.tx,o.ty);
}};

class TileImage : public CObject {
public:
    // 디코딩된 비트맵; 여기선 GDI+ Bitmap* 로 가정(실무: WIC BitmapLock/CopyPixels 권장)
    std::unique_ptr<Gdiplus::Bitmap> bmp;
};

class TileCache {
    // 간단 LRU 구현(멀티스레드 주의)
    size_t m_capacity = 256;
    std::map<TileKey, std::shared_ptr<TileImage>> m_items;
    std::list<TileKey> m_lru; // front = most recent
    std::mutex m;
public:
    void SetCapacity(size_t c){ std::scoped_lock lk(m); m_capacity=c; Trim(); }
    std::shared_ptr<TileImage> Get(const TileKey& k) {
        std::scoped_lock lk(m);
        auto it = m_items.find(k);
        if (it==m_items.end()) return {};
        Touch(k);
        return it->second;
    }
    void Put(const TileKey& k, std::shared_ptr<TileImage> v){
        std::scoped_lock lk(m);
        m_items[k]=v; Touch(k); Trim();
    }
private:
    void Touch(const TileKey& k){
        m_lru.remove(k);
        m_lru.push_front(k);
    }
    void Trim(){
        while (m_items.size() > m_capacity) {
            auto last = m_lru.back(); m_lru.pop_back();
            m_items.erase(last);
        }
    }
};

// 비동기 로더(스레드) 개략
class TileLoader {
    std::atomic<bool> stop{false};
    std::thread th;
    std::condition_variable cv;
    std::mutex qmutex;
    std::deque<TileKey> q;
public:
    std::function<void(const TileKey&, std::shared_ptr<TileImage>)> OnLoaded; // UI로 알림
    TileCache* cache = nullptr;

    void Start(){ th = std::thread([this]{ Run(); }); }
    void Stop(){ stop=true; cv.notify_all(); if(th.joinable()) th.join(); }
    void Request(TileKey k){
        { std::lock_guard lk(qmutex); q.push_back(k); }
        cv.notify_one();
    }
private:
    void Run(){
        CoInitializeEx(nullptr, COINIT_MULTITHREADED); // WIC/GDI+ 안전
        while(!stop){
            TileKey k;
            {
                std::unique_lock lk(qmutex);
                cv.wait(lk, [&]{ return stop || !q.empty(); });
                if (stop) break;
                k = q.front(); q.pop_front();
            }
            // 캐시에 이미 있으면 스킵
            if (cache && cache->Get(k)) continue;

            // TODO: 파일/네트워크에서 (level,tx,ty) 타일 데이터 디코드
            // 샘플: 단색 타일 생성
            auto tile = std::make_shared<TileImage>();
            tile->bmp.reset(new Gdiplus::Bitmap(256,256, PixelFormat32bppARGB));
            Gdiplus::Graphics g(tile->bmp.get());
            g.Clear(Gdiplus::Color(255, 240-k.level*10, 240, 255));
            // ... 실제로는 WIC로 원본에서 영역 디코딩/리샘플링

            if (cache) cache->Put(k, tile);
            if (OnLoaded) OnLoaded(k, tile);
        }
        CoUninitialize();
    }
};
```

## 6-4. 뷰와 타일 결합

- `OnPaint`에서 **가시 디바이스 영역 → 월드 → 해당 LOD의 타일 범위**를 계산  
- 캐시에 있으면 즉시 그리기, 없으면 **요청 큐에 push**하고 자리에는 **플레이스홀더**  
- `OnLoaded` 콜백에서 **해당 타일의 디바이스 사각형만 InvalidateRect**하여 최소 리페인트

```cpp
// CZoomCanvas 내부에 멤버 추가
TileCache  m_cache;
TileLoader m_loader;
int        m_tileSize = 256;

void InitTiles(){
    m_cache.SetCapacity(512);
    m_loader.cache = &m_cache;
    m_loader.OnLoaded = [this](const TileKey& k, std::shared_ptr<TileImage>){
        // 해당 타일의 화면 사각형 무효화
        PostMessage(WM_APP+1, *(WPARAM*)&k.level, MAKELPARAM(k.tx, k.ty));
    };
    m_loader.Start();
}
afx_msg LRESULT OnTileLoaded(WPARAM w, LPARAM l){
    TileKey k; k.level = (int)w; k.tx=LOWORD(l); k.ty=HIWORD(l);
    // 현재 레벨/가시영역에 해당하면 그 부분만 업데이트
    InvalidateTile(k);
    return 0;
}

void InvalidateTile(const TileKey& k){
    // 타일의 월드Rect → 디바이스Rect
    int tz = m_tileSize;
    int scalePow = /*LOD간 배율*/ 1; // 실제 구현에서는 level→축소 비율 계산
    CRect world(k.tx*tz<<scalePow, k.ty*tz<<scalePow, ((k.tx+1)*tz)<<scalePow, ((k.ty+1)*tz)<<scalePow);
    CRect dev(
        int(world.left  * m_zoom - m_offset.x),
        int(world.top   * m_zoom - m_offset.y),
        int(world.right * m_zoom - m_offset.x),
        int(world.bottom* m_zoom - m_offset.y));
    InvalidateRect(&dev, FALSE);
}

void RenderTiles(const CRect& rcClient){
    // 1) 가시 월드 영역
    CRect wv; DeviceToWorldRect(rcClient, wv);

    // 2) 현 zoom → LOD 결정 (샘플: 1.0 근사로 가정)
    int LOD = 0; // TODO: log2 기반 맵핑

    // 3) 월드 → 타일 인덱스 범위
    int tz = m_tileSize, sPow=0; // LOD별 축소 비율
    int tx0 = std::clamp(wv.left  >> sPow, 0, (m_world.cx>>sPow)/tz);
    int ty0 = std::clamp(wv.top   >> sPow, 0, (m_world.cy>>sPow)/tz);
    int tx1 = std::clamp((wv.right + tz-1)>>sPow, 0, (m_world.cx>>sPow + tz-1)/tz);
    int ty1 = std::clamp((wv.bottom+ tz-1)>>sPow, 0, (m_world.cy>>sPow + tz-1)/tz);

    for (int ty=ty0; ty<=ty1; ++ty){
        for (int tx=tx0; tx<=tx1; ++tx){
            TileKey k{LOD, tx, ty};
            auto tile = m_cache.Get(k);
            CRect w(tx*tz<<sPow, ty*tz<<sPow, (tx+1)*tz<<sPow, (ty+1)*tz<<sPow);
            CRect d(
                int(w.left  * m_zoom - m_offset.x),
                int(w.top   * m_zoom - m_offset.y),
                int(w.right * m_zoom - m_offset.x),
                int(w.bottom* m_zoom - m_offset.y));

            if (tile && tile->bmp) {
                // GDI+: DrawImage
                Gdiplus::Graphics g(m_mem);
                g.SetInterpolationMode(Gdiplus::InterpolationModeHighQualityBicubic);
                g.DrawImage(tile->bmp.get(), Gdiplus::Rect(d.left,d.top,d.Width(),d.Height()));
            } else {
                // 요청 큐에 등록 + 플레이스홀더
                m_loader.Request(k);
                m_mem.FillSolidRect(d, RGB(245,245,245));
                m_mem.Rectangle(d);
            }
        }
    }
}
```

> 실제 LOD 계산, 원본에서 타일 디코딩(WIC), 정확한 인덱싱·경계 처리 등을 채우면 **대형 이미지 뷰어** 수준이 됩니다.

---

# 7) HitTest/선택/편집을 위한 좌표 유틸

```cpp
// 화면 좌표 → 월드 좌표
CPoint DeviceToWorldPt(CPoint d) const {
    return CPoint( int((d.x + m_offset.x)/m_zoom), int((d.y + m_offset.y)/m_zoom) );
}
// 월드 좌표 → 화면 좌표
CPoint WorldToDevicePt(CPoint w) const {
    return CPoint( int(w.x*m_zoom - m_offset.x), int(w.y*m_zoom - m_offset.y) );
}
// 월드 사각형 → 화면 사각형
CRect WorldToDeviceRc(const CRect& w) const {
    return CRect( WorldToDevicePt({w.left, w.top}), WorldToDevicePt({w.right, w.bottom}) );
}
```

선택 박스/핸들 드래그시 **항상 월드 좌표로 판단**하고, 그릴 때만 디바이스 변환.

---

# 8) 더블버퍼와 플리커 제로 전략

- `OnEraseBkgnd`에서 **TRUE 반환** (배경 지우기 금지)  
- **전체 화면**을 백버퍼에 그리고 **BitBlt**  
- 스크롤은 **스크롤 복사 + 가장자리만 무효화**(5-1)

---

# 9) DPI/고해상도에서의 스크롤/줌

- 줌/스크롤 수치는 **디바이스 픽셀 기준**으로 잘 동작하지만, UI 요소(선 두께/폰트)는 **DPI 반영**  
- 타일 크기는 **논리 픽셀 기준 고정**(예: 256px). DPI가 달라도 **월드 기준** 변환이므로 문제 없음.

---

# 10) 이미지를 WIC로 부분 디코딩(실전)

**대형 JPEG/PNG**에서 특정 영역만 `IWICBitmapSource::CopyPixels`로 가져와 타일에 채우기:

```cpp
#include <wincodec.h>
#pragma comment(lib, "windowscodecs.lib")

// 샘플: 파일을 열어서 필요한 영역만 읽어오는 개략(예외/오류 처리 생략)
std::unique_ptr<Gdiplus::Bitmap> DecodeRegionWIC(const std::wstring& path, int x, int y, int w, int h, int dstW, int dstH) {
    CComPtr<IWICImagingFactory> fac; fac.CoCreateInstance(CLSID_WICImagingFactory);
    CComPtr<IWICBitmapDecoder> dec; fac->CreateDecoderFromFilename(path.c_str(), nullptr, GENERIC_READ, WICDecodeMetadataCacheOnDemand, &dec);
    CComPtr<IWICBitmapFrameDecode> frm; dec->GetFrame(0, &frm);

    // 변환기(픽셀포맷 통일) + 스케일 변환기
    CComPtr<IWICFormatConverter> conv; fac->CreateFormatConverter(&conv);
    conv->Initialize(frm, GUID_WICPixelFormat32bppPBGRA, WICBitmapDitherTypeNone, nullptr, 0.0, WICBitmapPaletteTypeCustom);

    // 영역 크롭 + 스케일
    CComPtr<IWICBitmapScaler> scaler; fac->CreateBitmapScaler(&scaler);
    scaler->Initialize(conv, dstW, dstH, WICBitmapInterpolationModeFant);

    // 스케일러에서 원하는 영역만 복사하려면 사전 크롭 + 스케일 or 타일별 별도 변환 파이프 구축
    // (간단화를 위해 전체 스케일 후 사각형 CopyPixels라 가정, 실무는 WriteSourceRect 등 사용)

    auto bmp = std::make_unique<Gdiplus::Bitmap>(dstW, dstH, PixelFormat32bppPARGB);
    Gdiplus::BitmapData bd{};
    Gdiplus::Rect r(0,0,dstW,dstH);
    bmp->LockBits(&r, Gdiplus::ImageLockModeWrite, bmp->GetPixelFormat(), &bd);

    WICRect rc{0,0,dstW,dstH};
    scaler->CopyPixels(&rc, (UINT)bd.Stride, dstH*(UINT)bd.Stride, (BYTE*)bd.Scan0);

    bmp->UnlockBits(&bd);
    return bmp;
}
```

> **핵심**: 파일 전체를 디코딩하지 않고 **필요한 영역만** 읽어 타일을 채움 → 메모리·시간 절약

---

# 11) 성능/안정성 체크리스트

1. **더블버퍼** + `OnEraseBkgnd=TRUE`  
2. **스크롤 이동 = 복사 + 가장자리만 무효화**  
3. **커서 기준 줌**(정확한 수학)  
4. **LOD + 타일 캐시**(LRU, 백그라운드 디코딩)  
5. **InvalidateRect 최소화**(타일 단위)  
6. **스레드 안전**: 로더/캐시 락, UI 스레드에서만 DC/그리기  
7. **픽셀 포맷**: 32bpp PBGRA 권장(알파 합성 품질)  
8. **줌 한계**: 0.05~32(상황에 맞게)  
9. **파일/네트워크 I/O**: 워커 스레드, 타임아웃/취소  
10. **메모리 상한**: 타일 수·크기·레벨별 제한, 메모리 모니터링

---

# 12) 문제 해결 가이드

| 증상 | 원인 | 해결 |
|---|---|---|
| 줌 시 화면이 훅훅 이동 | 중심 고정/커서 고정 안 맞음 | “커서 고정” 공식을 정확히 적용 |
| 페인트 깜빡임 | 배경 지우기 | 더블버퍼 + OnEraseBkgnd=TRUE |
| 스크롤 느림 | 전체 무효화 | ScrollWindowEx + 경계만 페인트 |
| 큰 이미지 로딩 느림 | 전체 디코딩 | WIC 부분 디코딩 + 타일 캐시 |
| 줌 품질 나쁨 | 보간 품질 낮음 | GDI+: HighQualityBicubic |
| 타일 깨짐/경계 라인 | 부정확한 디바이스 사각형 | 월드→디바이스 변환 정밀, 경계 1px 오프셋 점검 |
| 프리즈 | UI스레드에서 디코딩 | 백그라운드 로더로 이동 |

---

# 13) 통합 샘플: “UltraImageView” (축약 버전)

```cpp
// 사용법: 뷰 생성 → InitTiles() → SetWorldSize(원본 크기)
// OnPaint에서 RenderOffscreen → RenderTiles 순서로 호출
class CUltraImageView : public CZoomCanvas {
    std::wstring m_path; // 원본 이미지(or 딥줌 패키지)
public:
    void Load(const std::wstring& p, CSize world){
        m_path = p; SetWorldSize(world); InitTiles();
    }
protected:
    void RenderOffscreen(const CRect& rcClient) override {
        // 1) 기본
        m_mem.FillSolidRect(rcClient, RGB(255,255,255));
        // 2) 타일
        RenderTiles(rcClient);
        // 3) 오버레이 UI (스케일/좌표)
        CString msg; msg.Format(L"z=%.2f (%dx%d)", m_zoom, m_world.cx, m_world.cy);
        m_mem.SetBkMode(TRANSPARENT); m_mem.SetTextColor(RGB(40,40,40));
        m_mem.TextOut(10,10,msg);
    }
};
```

---

# 14) 부가 UX: 미니맵/Zoom Slider/상자 선택

- **미니맵**: 전체 축소 이미지를 우하단 작은 패널에, 현재 뷰 사각형 표시 → 클릭으로 이동  
- **줌 슬라이더**: 25/50/100/200/400% 버튼  
- **드래그 선택**: 월드 좌표 기준 박스 선택 → 확대(“선택 영역으로 확대”)

---

# 15) 테스트 시나리오 체크

- 100MB+ 이미지(예: 20000×20000) → 줌/스크롤 안정·속도  
- 고DPI(150/200/300%)  
- 빠른 휠 연타, 패닝 도중 줌  
- 초저/초고 배율 전환  
- 타일 캐시 용량 축소/확대 시 thrash 여부  
- IME/메뉴/리본과의 포커스 충돌 없음

---

## 결론

- **커서 고정 줌**과 **ScrollWindowEx 기반 스크롤 최적화**만으로도 체감 성능이 확 올라갑니다.  
- 초대형 데이터는 **LOD 타일 가상화**가 정석. **WIC 부분 디코딩 + LRU 캐시 + 백그라운드 로더**로 UI는 늘 즉답성을 유지하세요.  
- 이 글의 **CScrollView 기반**과 **CWnd 기반 템플릿**을 시작점으로 삼으면, **이미지 뷰어/지도/도면/타임라인**까지 확장하기 수월합니다.
