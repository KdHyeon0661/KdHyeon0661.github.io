---
layout: post
title: 운영체제 - 데드락 (2)
date: 2025-10-20 23:25:23 +0900
category: 운영체제
---
# Methods for Handling Deadlocks • Deadlock Prevention

---

## 8.4 Methods for Handling Deadlocks  
> 데드락을 다루는 방법은 크게 **무시**(Ostrich), **검출·복구**, **회피**(Avoidance), **예방**(Prevention)으로 나뉜다.  
> 8.5에서 **예방**을 자세히 파고들 것이므로, 여기서는 **전체 전략 지도**와 **검출·복구/회피**의 실전 구현을 담는다.

### 8.4.1 전략 개요 비교

| 전략 | 아이디어 | 장점 | 단점 | 쓰임새 |
|---|---|---|---|---|
| **무시(Ostrich)** | 확률 낮고 영향 작으면 “신경 끄기” | 구현 0 | 장애 시 재시작 의존 | 임베디드/단일 사용자 앱, 크리티컬 아님 |
| **검출 & 복구** | 주기적으로 **사이클** 탐지 → kill/rollback/선점 | 회피보다 자원 활용↑ | 검출·복구 비용, 롤백 필요 | 배치/DB/OS 커널 일부 경로 |
| **회피(Avoidance)** | **안전 상태**만 허용(Banker) | 데드락 없음 | 요청 거부/대기 ↑, 사전 최대요구 필요 | 고가치 트랜잭션, RT 제한적 |
| **예방(Prevention)** | Coffman 4조건 중 **하나를 깨뜨림** | 구조적으로 안전 | 자원 활용↓, 설계 제약↑ | 하드 실시간/커널 경로 |

---

### 8.4.2 Deadlock Detection (검출)

#### (A) Wait-For Graph (WFG) — 스레드/락 환경
- 노드: 스레드, 간선: “A가 B가 가진 락을 기다림”.
- **사이클 ⇔ 데드락(단일 인스턴스 락 가정)**

```python
# wfg_detect.py — 간단 사이클 검출 (DFS)
def has_cycle(adj):
    N=len(adj); color=[0]*N    # 0=unseen,1=visiting,2=done
    def dfs(u):
        color[u]=1
        for v in adj[u]:
            if color[v]==1: return True
            if color[v]==0 and dfs(v): return True
        color[u]=2; return False
    for i in range(N):
        if color[i]==0 and dfs(i): return True
    return False

# 예: T1→T2, T2→T3, T3→T1
adj = {0:[1],1:[2],2:[0]}
print("deadlocked?", has_cycle(adj))  # True
```

**운영 적용**  
- C++/POSIX: 락 대기/소유 로그를 수집해 주기적 분석(샘플러에 thread→lock→owner 맵 기록).  
- Java: `jstack`/JFR에 **"Found one Java-level deadlock"** 가시화 → 자동 경보.

#### (B) 자원-할당 행렬 기반 검출(다중 인스턴스 포함)
- 상태(Available, Allocation, Request)를 주기적으로 스냅샷.  
- **검출 알고리즘**(회피의 안전성 검사와 유사하지만 “최대” 대신 “현재 요청” 기준으로 시뮬):  
  가능한 작업을 완료해 자원을 회수하는 과정을 반복, **완료 불가 집합**이 남으면 **교착 의심**.

```python
# matrix_detect.py — 간단 검출기(현재 Request 기준)
def detect(available, allocation, request):
    import copy
    work = available[:]                  # 남은 자원
    finish = [False]*len(allocation)     # 완료 여부
    while True:
        progress=False
        for i in range(len(allocation)):
            if not finish[i] and all(request[i][j] <= work[j] for j in range(len(work))):
                # i를 완료시킨다(할당 자원 회수)
                for j in range(len(work)):
                    work[j] += allocation[i][j]
                finish[i]=True; progress=True
        if not progress: break
    deadlocked = [i for i,f in enumerate(finish) if not f]
    return deadlocked

# 예시
available=[3,3,2]
allocation=[[0,1,0],[2,0,0],[3,0,2],[2,1,1],[0,0,2]]
request   =[[0,0,0],[2,0,2],[0,0,0],[1,0,0],[0,0,0]]
print(detect(available, allocation, request))  # [] or deadlocked IDs
```

> **팁**: 실서비스에서는 스냅샷 시간/정확성 trade-off가 있다. **짧은 주기**로 **부분 그래프**라도 보는 편이 실용적.

---

### 8.4.3 Deadlock Recovery (복구)

복구는 **대상**과 **방법**을 결정해야 한다.

#### (A) 희생자 선택(Victim Selection)
- **비용 함수** 예: 진행률↓, 우선순위↓, 리소스 보유↑, 롤백 비용↑ → 가중치로 결정.  
- **기아 방지**: 동일 희생자 반복 금지(에이징).

#### (B) 프로세스/스레드 종료(Termination)
- **장점**: 확실, 빠름.  
- **단점**: 상태 손실/일관성 파손, 리소스 누수 가능.  
- **실전**: 워커는 **멱등(idempotent)** 작업 단위로 설계하여 재시도 가능케 한다.

#### (C) 자원 선점(Resource Preemption) — 롤백/체크포인팅
- 보유 자원을 회수하고 이전 **체크포인트**로 **롤백**.  
- DB/트랜잭션 시스템은 자연스럽다(로그 기반 REDO/UNDO).

##### (예제) 체크포인트+롤백 시뮬(사용자 공간)
```cpp
// checkpoint_rollback.cpp — 간단한 in-memory 트랜잭션
#include <vector>
#include <functional>
struct TxLogEntry { std::function<void()> undo; };
struct Tx {
    std::vector<TxLogEntry> log;
    void record_undo(std::function<void()> f){ log.push_back({std::move(f)}); }
    void rollback(){ for(auto it=log.rbegin(); it!=log.rend(); ++it) it->undo(); log.clear(); }
};

// 사용 예
int main(){
    int balanceA=100, balanceB=100;
    Tx tx;
    auto transfer=[&](int& from,int& to,int amt){
        tx.record_undo([&]{ from+=amt; to-=amt; });
        from-=amt; to+=amt;
    };

    transfer(balanceA,balanceB,30); // A->B
    // 데드락 등 오류 감지 시:
    tx.rollback(); // 상태 복귀
}
```

#### (D) **강제 선점이 어려운 락**의 복구
- **타임아웃**+**경고/덤프** → 운영자 개입  
- **중단 가능 락**(`Interruptible lock`) 사용(자바 `lockInterruptibly` 등)으로 **복구 경로** 마련.

---

### 8.4.4 Deadlock Avoidance (회피) — Banker’s Algorithm

> **핵심**: 시스템이 “**안전 상태**”만 통과하도록 **사전 검사**.  
> 프로세스별 **최대 필요량(Max)** 을 사전에 신고해야 하며, 자원 요청이 들어오면 “그 요청을 승인해도 **safe sequence** 가 존재하는가?”를 검사한다.

#### 수식 요약
- $$Need[i,j] = Max[i,j] - Allocation[i,j]$$  
- 항상 요청 \(Request[i]\) 에 대해 $$Request[i] \le Need[i] \land Request[i] \le Available$$ 이면,  
  **가상 할당** 후 **안전성 검사**를 수행하여 **안전**이면 승인.

#### (예제) 파이썬 구현
```python
# banker.py — 안전성 검사 + 요청 승인 시뮬
def is_safe(available, maxm, allocation):
    n=len(allocation); m=len(available)
    need=[[maxm[i][j]-allocation[i][j] for j in range(m)] for i in range(n)]
    work=available[:]; finish=[False]*n; order=[]
    while True:
        progress=False
        for i in range(n):
            if not finish[i] and all(need[i][j] <= work[j] for j in range(m)):
                for j in range(m): work[j]+=allocation[i][j]
                finish[i]=True; progress=True; order.append(i)
        if not progress: break
    return all(finish), order

def request_grant(available, maxm, allocation, pid, req):
    m=len(available)
    # Need/Available 확인
    need=[maxm[pid][j]-allocation[pid][j] for j in range(m)]
    if any(req[j] > need[j] for j in range(m)): return False, "exceeds need"
    if any(req[j] > available[j] for j in range(m)): return False, "insufficient available"
    # 가상 할당
    avail2=available[:]; alloc2=[row[:] for row in allocation]
    for j in range(m): avail2[j]-=req[j]; alloc2[pid][j]+=req[j]
    safe, order = is_safe(avail2, maxm, alloc2)
    return (True, order) if safe else (False, "unsafe")

# 예시 데이터
available=[3,3,2]
maxm=[[7,5,3],[3,2,2],[9,0,2],[2,2,2],[4,3,3]]
allocation=[[0,1,0],[2,0,0],[3,0,2],[2,1,1],[0,0,2]]
print(is_safe(available, maxm, allocation))               # (True, [1,3,4,0,2]) 등
print(request_grant(available, maxm, allocation, 1,[1,0,2]))
```

**장·단점 요약**  
- 장점: **데드락 완전 배제**  
- 단점: **최대 필요량** 선신고, **보수적 승인**으로 병행성↓, 고정된 자원 수 가정  
- 적용: **고가치/안전성 최우선** 배치/임무형 시스템(실시간은 제약 큼)

---

### 8.4.5 운영 체크리스트(검출/복구/회피)

- **검출 주기**: 서비스 SLO/장애 파급 고려(초~분 단위).  
- **희생자 선택**: *진행률/우선순위/롤백비용* 기반 가중치 + 에이징.  
- **체크포인트**: 비용 큰 작업/긴 트랜잭션은 **주기적 스냅샷**; 멱등 작업 설계.  
- **회피 적용 범위**: 전체가 아닌 **핵심 서브시스템**에만 적용해 오버헤드 최소화.  
- **가시성**: 스택/락맵 덤프, RAG/WFG 시각화, 경보.

---

## 8.5 Deadlock Prevention  
> **Coffman 4조건** 중 최소 하나를 **설계로 파괴**하여 데드락 자체를 구조적으로 차단한다.

### 8.5.1 4조건 복습
1) **Mutual Exclusion**(상호배제)  
2) **Hold and Wait**(보유 상태에서 추가 대기)  
3) **No Preemption**(비선점)  
4) **Circular Wait**(순환 대기)

**예방**은 위 4개 중 **한 개 이상을 거짓**으로 만든다.

---

### 8.5.2 Mutual Exclusion 깨기 — **자원 가상화/복제/락 없는 설계**

- **읽기 경로 무락화**(RCU/스냅샷/Copy-on-Write/불변 자료구조)  
- **자원 복제**: 단일 인스턴스를 다중 인스턴스로 바꿔 경쟁 완화  
- **대안 프로토콜**: Actor/CSP/메시지 전달 — **공유 상태 없음**

```java
// 불변 스냅샷으로 읽기 락 제거 (Copy-on-Write Map)
class SafeMap {
  private volatile Map<String,String> cur = Map.of();
  public String get(String k){ return cur.get(k); }  // 락 없음
  public synchronized void put(String k,String v){
    var n = new HashMap<>(cur); n.put(k,v);
    cur = Map.copyOf(n); // 새 스냅샷으로 교체
  }
}
```

> **트레이드오프**: 쓰기 코스트/GC 증가 ↔ 데드락 위험 0.

---

### 8.5.3 Hold-and-Wait 깨기 — **All-or-Nothing**(사전할당)

- **규칙**: 작업은 필요한 모든 자원을 **한 번에** 요청, 일부만 얻으면 **아무 것도 보유하지 않고** 대기.  
- **장점**: 데드락 불가.  
- **단점**: 자원 **유휴 시간** 증가(보수적), 최대 필요량 과대신고 가능.

```cpp
// all_or_nothing.cpp — 두 락이 모두 필요하면 atomically 취득, 실패 시 전부 해제
#include <mutex>
#include <thread>
#include <chrono>
#include <iostream>
std::mutex A,B;

bool acquire_all_or_none(std::mutex& a, std::mutex& b){
    if(!a.try_lock()) return false;
    if(!b.try_lock()){ a.unlock(); return false; }
    return true;
}
void worker(){
    using namespace std::chrono_literals;
    while(true){
        if(acquire_all_or_none(A,B)){
            // 임계구역 ...
            B.unlock(); A.unlock(); break;
        }else{
            std::this_thread::sleep_for(1ms); // backoff
        }
    }
}
```

---

### 8.5.4 No Preemption 깨기 — **선점 가능 자원/트랜잭션화**

- **선점 가능한 자원**: CPU 타임슬라이스, 메모리 프레임(가상메모리 스와핑), 네트워크 대역폭.  
- **락**은 선점 곤란 → **타임아웃/인터럽트 가능 잠금**으로 “사실상의 선점” 제공.  
- **트랜잭션화**: STM/DB 트랜잭션처럼 충돌 시 **자동 롤백** → 자원 회수 가능.

```java
// tryLock + 타임아웃으로 사실상 선점
Lock a=new ReentrantLock(true), b=new ReentrantLock(true);
void doWork() throws InterruptedException {
  if(!a.tryLock(50, TimeUnit.MILLISECONDS)) return; // 선점 실패 → 양보
  try{
    if(!b.tryLock(50, TimeUnit.MILLISECONDS)) return;
    try{
      // work
    } finally { b.unlock(); }
  } finally { a.unlock(); }
}
```

---

### 8.5.5 Circular Wait 깨기 — **글로벌 순서 규약(Ordered Locking)**

- 모든 잠재적 락/자원에 **정렬 키**(ID/주소/계층)를 부여하고, **항상 작은 키→큰 키**로만 획득.  
- 순환 대기가 **위상 정렬 DAG**로 치환되어 **불가능**해진다.

```cpp
// ordered_locking.cpp — 주소 순서 기반
#include <mutex>
#include <algorithm>
void lock_two(std::mutex& a, std::mutex& b){
    std::mutex* first=&a; std::mutex* second=&b;
    if(first>second) std::swap(first,second);
    std::lock(*first,*second); // C++ 표준 데드락-프리 알고리즘
}
```

#### (A) 계층형 뮤텍스(Hierarchical Mutex) — 규약 위반 런타임 감지
```cpp
// hierarchical_mutex.hpp (핵심 아이디어)
#include <mutex>
#include <climits>
class hierarchical_mutex{
  std::mutex m; unsigned long level;
  static thread_local unsigned long current_level;
public:
  explicit hierarchical_mutex(unsigned long lvl): level(lvl){}
  void lock(){
    if(current_level <= level) throw std::logic_error("lock order violation");
    m.lock(); current_level = level;
  }
  void unlock(){ current_level = ULONG_MAX; m.unlock(); }
};
thread_local unsigned long hierarchical_mutex::current_level=ULONG_MAX;
```

> **실전 팁**: **모듈 경계**마다 락 레벨을 문서화하고 **lint/테스트**에서 강제.

---

### 8.5.6 Prevention 조합 전략(현실 설계)

- **핵심 공유 구조**는 **DAG 락 순서**(Circular Wait 제거).  
- 고경합 카운터/맵은 **락 없는/불변 스냅샷**(Mutual Exclusion 완화).  
- 긴 연산은 **트랜잭션/복제-교체** 후 **짧게 교체**(Hold-and-Wait 완화).  
- 경로에 **타임아웃/tryLock**을 기본값으로 둬 **사실상 선점** 허용.  
- 모든 API는 **취소/롤백** 경로를 제공(복구 가능성↑).

---

### 8.5.7 실무 시나리오와 예방 적용

#### (A) 웹 결제 워크플로우(멀티 리소스)
- 리소스: 사용자 락, 재고 락, 결제 트랜잭션, 외부 게이트웨이.  
- **예방**:  
  1) **정해진 순서**: (user→inventory→payment)  
  2) 외부 I/O는 **락 밖**에서 수행(콜백으로 결과 commit)  
  3) 실패 시 **멱등 보상 트랜잭션**(보류 재고 해제)

#### (B) 커널 네트워크 스택
- 인터럽트 경로: **수면 금지**, 스핀락 **짧게**  
- **per-CPU 큐**로 락 분할, 공유 맵은 **RCU**  
- 데이터 경로 락 레벨: `skb_queue` < `dev_queue` < `tc_filter` … **문서화**

#### (C) DB + 애플리케이션 락 교차
- **한 방향 규약**: 항상 **DB 락 먼저**, 그 다음 **앱락**  
- 트랜잭션 내 동기 RPC **금지**(외부가 다시 DB를 잡아 순환 위험)

---

### 8.5.8 수학적 가드레일 — “락 직렬 구간” 상한 줄이기

암달의 법칙:
$$
S(N) = \frac{1}{(1-P) + \frac{P}{N}},\quad (1-P):\ \text{직렬 구간(락)}
$$
- **예방**은 단지 데드락만 막는 게 아니라 `(1-P)` 자체를 줄여 **스케일**도 높인다.  
- **락 분할/샤딩/락프리/불변화**는 모두 `(1-P)` 감소 전략.

---

## 종합 실습

### 실습 A — Detection + Recovery 자동화 미니프레임
1) 앱에 **락 대기/소유 로깅** 삽입 → 주기적으로 **WFG 사이클** 검사.  
2) 사이클 감지 시 **희생자 선택** → **취소 토큰/타임아웃**으로 안전 중단 → **롤백**.  
3) **지표**: 평균 복구 시간, 재시도 성공률, 손실 작업 수.

### 실습 B — Prevention Before/After
1) 의도적으로 **교차 락**을 걸어 데드락 재현.  
2) **Ordered Locking** + **tryLock 타임아웃** 도입 후 **재현 실패** 확인.  
3) **p95 지연**과 **처리량** 변화를 보고 과도한 보수성 여부 평가.

### 실습 C — Banker 회피 vs 검출 비교
1) 동일 워크로드에서 **Banker 회피**와 **검출·복구**를 각각 적용.  
2) **승인 실패율**, **자원 활용률**, **평균 지연**, **장애 복구 횟수**를 비교.

---

## 핵심 요약

- **8.4 Methods**: 선택지는 **무시 / 검출·복구 / 회피 / 예방**.  
  - 검출: **WFG/행렬**로 사이클 탐지 → **kill/rollback/선점**으로 복구.  
  - 회피: **Banker**로 안전 상태만 승인(데드락 0, 보수성↑).  
- **8.5 Prevention**: Coffman 4조건 중 **하나 이상을 설계로 파기**.  
  - **순환 대기 차단(Ordered Locking)** 이 가장 보편적/효율적.  
  - **All-or-Nothing**, **tryLock/타임아웃**, **락 없는/불변 구조**를 상황에 맞게 조합.  
- 운영의 정답은 **혼합 전략**: 핵심은 **예방**, 주변은 **검출·복구/타임아웃**, 고가치 경로엔 **회피**.
