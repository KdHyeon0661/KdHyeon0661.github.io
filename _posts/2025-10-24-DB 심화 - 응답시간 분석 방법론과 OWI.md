---
layout: post
title: DB 심화 - 응답시간 분석 방법론과 OWI
date: 2025-10-24 18:25:23 +0900
category: DB 심화
---
# 방법론**과 **OWI(Oracle Wait Interface)**

## 한눈 요약(현장 루틴)

1) **증상 정의**: “보고서 페이지가 느리다(>3초)”. 기준 SLO/슬로우 시간대를 고정.
2) **RTA 프로파일** 만들기:
   - **DB Time = CPU Time + Σ Wait Time**
   - **Top Wait Class/Event**(User I/O, Concurrency, Commit, Cluster, Network…)
3) **Plan/라인 매핑**: SQL Monitor 또는 `DBMS_XPLAN.DISPLAY_CURSOR('ALLSTATS LAST')`로 **어느 Row Source**에서 시간을 쓰는지 연결.
4) **병목 제거**:
   - I/O면 **범위 축소/인덱스 설계/파티션 프루닝**
   - TEMP 스필이면 **PGA↑/카디널리티 보정/조인전략 전환**
   - Commit 지연이면 **배치 커밋/스토리지 지연 개선**
   - 락이면 **보유자/대상/순서/FK 인덱스/ITL**
   - RAC면 **데이터 로컬리티/핫 블록 분산**
5) **Before/After** AWR/ASH/모니터로 **효과 검증**.

---

## 핵심 개념

### 응답시간 분해

- 단일 호출(예: 한 SQL, 한 HTTP 요청)의 **총 경과 시간**을 **서버 CPU 사용 시간**과 **대기 시간**의 합으로 쪼갠다.

$$
T_{\text{elapsed}} \;=\; T_{\text{CPU}} \;+\; \sum_{k} T_{\text{wait}_k}
$$

- DB 관점에서는 **DB Time**이 동일 개념으로 쓰인다(활성 세션의 경과시간 합).

### DB Time, AAS

- **DB Time**: DB 내부에서 SQL 실행에 소비된 시간 총합(활성 세션).
- **AAS(Active Sessions)**:
  $$ \text{AAS} \approx \frac{\text{DB Time}}{\text{Wall-clock Time}} $$
  CPU 위 또는 특정 대기 이벤트에서 **활성** 상태인 세션의 평균 개수.
  AAS가 높을수록 **혼잡/대기**가 늘고 응답시간이 커지기 쉽다.

### 리틀의 법칙(감각)

- **리틀의 법칙**
  $$ L = \lambda \times W $$
  - \(L\): 시스템 내 평균 작업 수(= AAS)
  - \(\lambda\): 처리율(초당 트랜잭션)
  - \(W\): 평균 응답시간
- → 처리량/응답시간/활성세션의 **상관**을 직관적으로 파악할 수 있다.

---

## OWI(Oracle Wait Interface)란?

- Oracle은 세션이 **CPU**가 아니라면 **무엇을 기다리고 있는지** 이벤트 단위로 기록한다.
- **Wait Class**(대분류)와 **Wait Event**(세부명)로 구조화:
  - **User I/O**: `db file sequential read`, `db file scattered read`, `direct path read temp` …
  - **Concurrency**: `enq: TX - row lock contention`, `buffer busy waits`, `library cache: lock` …
  - **Commit**: `log file sync`
  - **Cluster (RAC)**: `gc cr/current block busy`, `global cache busy` …
  - **Configuration/Network/Other** …

**핵심**: **“느림의 이름표”** 를 세분류로 제공 → **원인 지점**에 빠르게 도달.

---

## Time Model & 관련 뷰 살펴보기

- `V$SYS_TIME_MODEL`, `V$SESS_TIME_MODEL` : **DB CPU**, **SQL execute elapsed time**, **parse time**, **connection mgmt elapsed time** …
- `V$SYSTEM_EVENT`, `V$SESSION`, `V$ACTIVE_SESSION_HISTORY(ASH)` : 대기 이벤트, 대기 클래스, 블로커/블로키
- `V$SQL{,_AREA,_MONITOR}` : SQL별 누적/실시간 통계
- **AWR**(`DBA_HIST_*`) : 과거 시계열 스냅샷

**예: 전체 DB Time 분해**
```sql
SELECT stat_name, round(value/1e6,1) AS seconds
FROM   v$sys_time_model
WHERE  stat_name IN ('DB time','DB CPU','sql execute elapsed time','parse time elapsed')
ORDER  BY 2 DESC;
```

**예: 상위 대기 이벤트(시스템)**
```sql
SELECT event, total_waits, round(time_waited_micro/1e6,1) AS sec
FROM   v$system_event
WHERE  wait_class <> 'Idle'
ORDER  BY sec DESC FETCH FIRST 10 ROWS ONLY;
```

---

## RTA 표준 절차(탑다운 7단계)

1) **범위 고정**: 슬로우 시간대(예: 10:30~10:45), 서비스/모듈/사용자/SQL ID
2) **DB Time → CPU/Wait 분해**(Time Model + Top Events)
3) **Top Wait Class & Event** 식별: I/O? Concurrency? Commit? Cluster?
4) **핫 SQL** 추출: AWR Top SQL / ASH(해당 구간)
5) **Plan 라인 매핑**: SQL Monitor / `DISPLAY_CURSOR('ALLSTATS LAST')`
6) **원인 조치** 매핑: 인덱스/조인/메모리/로그/락/서비스 라우팅 등
7) **재검증**: 동일 조건으로 Before/After 비교

---

## 실전 SQL: **RTA 프로파일** 빠르게 뽑기

### **Top Wait Class/Event**

```sql
-- 최근 10분 ASH 샘플 기준
SELECT wait_class, event, COUNT(*) AS samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
  AND  session_type = 'FOREGROUND'
GROUP  BY wait_class, event
ORDER  BY samples DESC FETCH FIRST 15 ROWS ONLY;
```

### 구간별 **Top SQL(응답시간 기여)**

```sql
SELECT sql_id,
       COUNT(*) AS samples,
       SUM(CASE WHEN session_state='ON CPU' THEN 1 ELSE 0 END) AS on_cpu,
       SUM(CASE WHEN session_state='WAITING' THEN 1 ELSE 0 END) AS on_wait
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type = 'FOREGROUND'
GROUP  BY sql_id
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;
```

### 특정 SQL의 **Wait 타임라인(초단위 프로파일)**

```sql
-- 특정 SQL_ID의 wait_class 분포를 시간 버킷으로
WITH buckets AS (
  SELECT TRUNC(CAST(sample_time AS DATE) + (TO_NUMBER(TO_CHAR(sample_time,'SSSSS'))/5))/ (1/288) AS bucket_start,
         wait_class
  FROM   v$active_session_history
  WHERE  sql_id = :sql_id
    AND  sample_time BETWEEN :t1 AND :t2
)
SELECT MIN(bucket_start) AS bucket,
       wait_class,
       COUNT(*) AS samples
FROM   buckets
GROUP  BY bucket_start, wait_class
ORDER  BY bucket, wait_class;
```

> 이 타임라인으로 “**언제** 무슨 대기가 **튀었는지**” 즉시 보인다.

---

## 대기 클래스별 **원인 → 조치** 매핑(요지)

| Wait Class | 대표 이벤트 | 주 원인 | 대표 처방 |
|---|---|---|---|
| User I/O | `db file sequential read` | 랜덤 I/O(인덱스→ROWID) | 인덱스 설계/선택성/커버링/클러스터링 팩터 |
|  | `db file scattered read` | FTS/범위 스캔 | 인덱스/파티션/병렬 |
|  | `direct path read temp` | 정렬/해시 스필 | PGA↑, 카디널리티 보정, 조인전략 전환 |
| Concurrency | `enq: TX - row lock contention` | 행잠금 충돌, FK 미인덱스, ITL 부족 | FK 인덱스, 커밋 단축, INITRANS↑, 키 분산 |
|  | `buffer busy waits` | 핫블록/헤더 | 키 분산, PCTFREE/INITRANS 조정 |
| Library/Row Cache | `library cache: lock/pin` | 하드파싱/Invalidation | 바인드, 커서 캐시, DDL 배치 |
| Commit | `log file sync` | 잦은 커밋, 스토리지 지연 | 배치 커밋, LGWR 대상 성능 개선 |
| Cluster(RAC) | `gc current/cr block busy` | 글로벌 핫블록 | 데이터 로컬리티, Reverse Key, 시퀀스 NOORDER |

---

## **OWI + Plan 라인** 연결(결정적 단계)

- **왜?** “I/O가 많다”는 사실만으로는 해결이 안 된다. **어느 연산(라인)** 이 원인인지 알아야 **정확한 처방**이 가능.
- **어떻게?**
  - **SQL Monitor**: Row Source별 경과시간/대기/Temp 시각화
  - **`DBMS_XPLAN.DISPLAY_CURSOR(..., 'ALLSTATS LAST')`** : A-Rows/Starts/Time/Temp/Buffers 표

**예시**
```sql
-- 마지막 실행의 실제 라인 통계
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(:sql_id, NULL,
  'ALLSTATS LAST +PEEKED_BINDS +PREDICATE +PROJECTION +OUTLINE +NOTE'));
```
- `SORT ORDER BY` 라인의 **TempSpc**↑이면 → PGA/정렬 회피 필요
- `HASH JOIN` 라인의 Time↑이면 → 카디널리티 정확화/드라이빙 변경/인덱스 선행 필터
- `INDEX RANGE SCAN` + `TABLE ACCESS BY ROWID`에서 Time↑이면 → **선택성 개선/커버링** 등

---

## **사례 시나리오**로 배우는 RTA

### 정렬 스필이 응답시간의 70%를 먹는 케이스

- **증상**: 보고서 쿼리 평균 8초.
- **RTA**: Top Wait = `direct path read temp` (User I/O)
- **Plan 매핑**: `SORT GROUP BY`/`SORT ORDER BY` 라인 Time↑, `TempSpc`↑
- **원인**: 카디널리티 오판으로 해시/정렬 데이터량 과대
- **조치**:
  - `region` 히스토그램 생성 → 선택도 개선
  - 커버링 인덱스로 정렬 회피(`(region,dt)` 포함)
  - `pga_aggregate_target` 상향
- **효과**: TempSpc 5GB → 0, Elapsed 8s → 0.9s

### `log file sync`가 40% — 커밋 병목

- **증상**: OLTP TPS 증가와 함께 응답시간 급증(피크 타임).
- **RTA**: Commit 클래스로 대기 집중.
- **원인**: 매 행 커밋, 네트워크+스토리지 지연.
- **조치**: 업무 타협 하에 **배치 커밋**, 드라이버/네트워크 지연 점검, 로그 그룹/대상 디스크 성능 개선.
- **효과**: 평균 응답 2.2s → 0.7s.

### `enq: TX - row lock contention` — FK 미인덱스

- **증상**: 특정 삭제/갱신 트랜잭션에서 전체 느려짐.
- **RTA**: Concurrency 최상위, ASH에서 같은 테이블 Child 참조 다수.
- **원인**: **외래키 미인덱스**로 부모 업데이트/삭제마다 자식 테이블 범용 스캔/락 경합.
- **조치**: FK 컬럼 인덱스 생성.
- **효과**: 대기 제거, 응답시간 정상화.

### RAC `gc current block busy` — 글로벌 핫블록

- **증상**: 2노드 RAC, 피크 시간 느려짐.
- **RTA**: Cluster 클래스 상위, `gc current block busy` 집중.
- **원인**: 증가키 우측 집중 인덱스/시퀀스 ORDER, 특정 파티션에 트래픽 집중.
- **조치**: 시퀀스 `NOORDER CACHE n`, Reverse Key 인덱스, 서비스 로컬리티, 파티션 분산.
- **효과**: AAS 급감, 응답시간 안정화.

---

## **RTA 대시보드**: 10분 만에 만드는 SQL

### Wait Class 프로파일(최근 15분)

```sql
SELECT wait_class,
       COUNT(*) AS samples,
       ROUND(100 * RATIO_TO_REPORT(COUNT(*)) OVER (), 1) AS pct
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '15' MINUTE
  AND  session_type = 'FOREGROUND'
GROUP  BY wait_class
ORDER  BY samples DESC;
```

### Top Event + Top SQL 교차

```sql
WITH base AS (
  SELECT event, sql_id FROM v$active_session_history
  WHERE  sample_time BETWEEN :t1 AND :t2
    AND  session_type='FOREGROUND'
)
SELECT event, sql_id, COUNT(*) samples
FROM   base
GROUP  BY event, sql_id
ORDER  BY samples DESC FETCH FIRST 20 ROWS ONLY;
```

### AAS(구간 평균 활성 세션)

```sql
SELECT ROUND(COUNT(*) / (EXTRACT(SECOND FROM (:t2-:t1)) + 60*EXTRACT(MINUTE FROM (:t2-:t1)) + 3600*EXTRACT(HOUR FROM (:t2-:t1))),2)
       AS AAS
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND';
```

> 위 3개만 붙여도, “무엇이 문제인지”를 1~2분 안에 보여줄 수 있다.

---

## SLO/퍼센타일과 RTA

- 평균은 **왜곡에 취약**. **p50/p90/p99**로 사용자 체감에 맞춰 본다.
- 트랜잭션 로그/웹 게이트웨이/애플리케이션 계층에서 **요청-끝 시간**과 **DB 호출 시간**을 함께 기록하여 **DB 기여 분**을 분리.
- **RTA 결과**와 **퍼센타일 SLO** 를 연결: 예) “p95 1.0s” 목표라면, DB Time 프로파일에서 p95 구간의 **병목 클래스**를 먼저 제거.

---

## 고급: 간이 대기행렬 감각(선택)

- **Utilization Law**:
  $$ R \approx \frac{S}{1-U} $$
  - \(S\): 순수 서비스 시간(예: CPU)
  - \(U\): 자원 이용률
  이용률이 70~80%를 넘으면 **대기 급증** → RTA로 해당 자원(예: 디스크, 로그, CPU)의 **대기 이벤트**가 실제로 늘었는지 확인.

---

## 운영 체크리스트(습관화)

1) **시간 범위, 서비스/모듈 고정**(흔들리면 분석이 틀어진다)
2) **Top Wait Class/Event** → **핫 SQL** → **Plan 라인**
3) **증거 저장**: AWR 비교 스냅샷, SQL Monitor 레포트
4) **작은 변경으로 최대 효과**: 인덱스/통계/조인순서/커밋 정책/키 분산
5) **재검증**: 같은 부하, 같은 시간대, 같은 대시보드

---

## 미니 실습(끝까지 따라하기)

### 시나리오: 보고서 페이지 6~8초

**1) 구간 고정**
```sql
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '10' MINUTE;
EXEC :t2 := SYSTIMESTAMP;
```

**2) Wait Class 프로파일**
```sql
SELECT wait_class, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY wait_class
ORDER  BY samples DESC;
```
→ `User I/O`/`Commit`가 상위라고 가정.

**3) Top Event/Top SQL**
```sql
SELECT event, sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY event, sql_id
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;
```
→ `direct path read temp` + 특정 `sql_id=abc123` 상위.

**4) 해당 SQL 실제 라인 통계**
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('abc123', NULL,
  'ALLSTATS LAST +PREDICATE +PROJECTION +PEEKED_BINDS +OUTLINE +NOTE'));
```
→ `SORT GROUP BY` 라인 TempSpc↑, Time↑.

**5) 처방**
- 인덱스 추가 `(region, dt)`로 정렬 회피 or 드라이빙 축소
- PGA 상향 검토 / 카디널리티 보정(히스토그램)
- 재검증: 같은 대시보드로 Temp 대기↓, Elapsed↓ 확인

---

## 스크립트 모음(복붙 용)

### 시스템 수준 RTA 스냅샷(최근 15분, Top 12 이벤트)

```sql
SELECT wait_class, event, COUNT(*) AS samples,
       ROUND(100*RATIO_TO_REPORT(COUNT(*)) OVER (),1) AS pct
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '15' MINUTE
  AND  session_type='FOREGROUND'
GROUP  BY wait_class, event
ORDER  BY samples DESC FETCH FIRST 12 ROWS ONLY;
```

### 특정 서비스/모듈만 핀포인트

```sql
SELECT wait_class, event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  service_hash = (SELECT service_hash FROM v$active_services WHERE name='PAYROLL_SVC')
  AND  module = 'PAYROLL-BATCH'
GROUP  BY wait_class, event
ORDER  BY samples DESC;
```

### 응답시간과 처리량(리틀의 법칙 감각)

```sql
-- AAS
WITH t AS (
  SELECT COUNT(*) AS samples
  FROM   v$active_session_history
  WHERE  sample_time BETWEEN :t1 AND :t2
    AND  session_type='FOREGROUND'
)
SELECT ROUND(samples / (EXTRACT(SECOND FROM (:t2-:t1))
       +60*EXTRACT(MINUTE FROM (:t2-:t1))
       +3600*EXTRACT(HOUR FROM (:t2-:t1))),2) AS aas
FROM t;

-- Tx/초(대략): 애플리케이션/로그에서 건수 수집 권장(아래는 예시)
-- response_time ≈ AAS / throughput  (단위 일치 주의)
```

---

## 자주 하는 질문(FAQ)

**Q1. 평균 대신 퍼센타일을 보려면?**
A. DB만으로는 한계가 있으니 AP 게이트웨이/미들웨어에서 **요청 p90/p99** 측정 후, 해당 시각대의 **DB RTA** 를 매칭해 DB 기여도를 본다.

**Q2. AWR만 보면 되나요?**
A. **AWR=요약**, **ASH=세밀 타임라인**. 실전은 **둘 다** 쓴다. 장수행/현재 실행은 **SQL Monitor**가 베스트.

**Q3. BCHR가 99%인데도 느립니다.**
A. 정상일 수 있다. TEMP 스필/Commit/LIB/락/네트워크 등 **다른 병목**이 응답시간을 지배한다. **RTA**는 그 “이름표”를 찾는 도구.

---

## 결론

- **RTA**는 “느림을 **시간**으로 해체”하는 기술이다.
- **OWI**는 그 시간을 **이벤트 명찰**로 붙여준다.
- **분해(Top Class/Event) → 매핑(Plan Line) → 처방(정확한 변경)** 이 **정석 루틴**이다.
- **증거 기반**(AWR/ASH/SQL Monitor/ALLSTATS LAST)으로 바꾸고, **Before/After**로 증명하라.

> 한 줄 정리
> **Response Time = CPU + ΣWait.**
> **OWI**가 **Wait의 얼굴**을, **DBMS_XPLAN/Monitor**가 **병목 라인**을 보여준다.
> 이 세 장을 겹쳐 보면, **정답은 자동으로 드러난다**.
