---
layout: post
title: DB 심화 - 응답시간 분석 방법론과 OWI
date: 2025-10-24 18:25:23 +0900
category: DB 심화
---
# 응답시간 분석 방법론**과 **OWI(Oracle Wait Interface)**

## 한눈 요약

1) **증상 정의**: "보고서 페이지가 느리다(>3초)". 기준 SLO/슬로우 시간대를 명확히 정의합니다.
2) **RTA 프로파일** 만들기:
   - **DB Time = CPU Time + Σ Wait Time**
   - **Top Wait Class/Event**(User I/O, Concurrency, Commit, Cluster, Network…) 식별
3) **Plan/라인 매핑**: SQL Monitor 또는 `DBMS_XPLAN.DISPLAY_CURSOR('ALLSTATS LAST')`로 **어느 Row Source**에서 시간을 쓰는지 연결합니다.
4) **병목 제거**:
   - I/O 병목이면 **범위 축소/인덱스 설계/파티션 프루닝**
   - TEMP 스필이면 **PGA↑/카디널리티 보정/조인전략 전환**
   - Commit 지연이면 **배치 커밋/스토리지 지연 개선**
   - 락 경합이면 **보유자/대상/순서/FK 인덱스/ITL**
   - RAC 환경이면 **데이터 로컬리티/핫 블록 분산**
5) **Before/After** AWR/ASH/모니터로 **효과 검증**.

---

## 핵심 개념

### 응답시간 분해

단일 호출(예: 한 SQL, 한 HTTP 요청)의 **총 경과 시간**을 **서버 CPU 사용 시간**과 **대기 시간**의 합으로 분해합니다.

$$
T_{\text{elapsed}} \;=\; T_{\text{CPU}} \;+\; \sum_{k} T_{\text{wait}_k}
$$

데이터베이스 관점에서는 **DB Time**이 동일한 개념으로 사용되며, 이는 활성 세션의 경과시간 총합을 의미합니다.

### DB Time과 AAS(Active Sessions)

- **DB Time**: 데이터베이스 내부에서 SQL 실행에 소비된 시간의 총합(활성 세션 기준).
- **AAS(Active Sessions)**:
  $$ \text{AAS} \approx \frac{\text{DB Time}}{\text{Wall-clock Time}} $$
  CPU 사용 중이거나 특정 대기 이벤트에서 **활성** 상태인 세션의 평균 개수입니다.
  AAS가 높을수록 **시스템 혼잡도와 대기 시간**이 증가하며, 이는 응답시간 저하로 이어질 수 있습니다.

### 리틀의 법칙(감각)

- **리틀의 법칙**
  $$ L = \lambda \times W $$
  - \(L\): 시스템 내 평균 작업 수(= AAS)
  - \(\lambda\): 처리율(초당 트랜잭션)
  - \(W\): 평균 응답시간
- 이 법칙은 처리량, 응답시간, 활성 세션 수의 **상관관계**를 직관적으로 이해하는 데 도움을 줍니다.

---

## OWI(Oracle Wait Interface)란?

Oracle 데이터베이스는 세션이 **CPU**를 사용하지 않을 때 **무엇을 기다리고 있는지**를 이벤트 단위로 기록합니다.
이러한 대기 정보는 **Wait Class**(대분류)와 **Wait Event**(세부명)로 구조화되어 있습니다:

- **User I/O**: `db file sequential read`, `db file scattered read`, `direct path read temp` …
- **Concurrency**: `enq: TX - row lock contention`, `buffer busy waits`, `library cache: lock` …
- **Commit**: `log file sync`
- **Cluster (RAC)**: `gc cr/current block busy`, `global cache busy` …
- **Configuration/Network/Other** …

**핵심**: OWI는 시스템 성능 저하의 원인인 **"느림의 이름표"** 를 세분화된 형태로 제공하여, 문제 해결에 필요한 **정확한 원인 지점**에 빠르게 도달할 수 있도록 합니다.

---

## Time Model & 관련 뷰 살펴보기

- `V$SYS_TIME_MODEL`, `V$SESS_TIME_MODEL`: **DB CPU**, **SQL execute elapsed time**, **parse time**, **connection mgmt elapsed time** …
- `V$SYSTEM_EVENT`, `V$SESSION`, `V$ACTIVE_SESSION_HISTORY(ASH)`: 대기 이벤트, 대기 클래스, 블로커/블로키 세션 정보
- `V$SQL{,_AREA,_MONITOR}`: SQL별 누적/실시간 성능 통계
- **AWR**(`DBA_HIST_*`): 과거 시계열 성능 스냅샷 데이터

**예시: 전체 DB Time 분해**
```sql
SELECT stat_name, round(value/1e6,1) AS seconds
FROM   v$sys_time_model
WHERE  stat_name IN ('DB time','DB CPU','sql execute elapsed time','parse time elapsed')
ORDER  BY 2 DESC;
```

**예시: 상위 대기 이벤트(시스템 전체)**
```sql
SELECT event, total_waits, round(time_waited_micro/1e6,1) AS sec
FROM   v$system_event
WHERE  wait_class <> 'Idle'
ORDER  BY sec DESC FETCH FIRST 10 ROWS ONLY;
```

---

## RTA 표준 절차(탑다운 7단계)

1) **범위 고정**: 성능 저하가 발생한 시간대(예: 10:30~10:45), 특정 서비스/모듈/사용자/SQL ID를 명확히 정의
2) **DB Time → CPU/Wait 분해**(Time Model + Top Events)
3) **Top Wait Class & Event** 식별: 주 병목이 I/O, Concurrency, Commit, Cluster 중 어디인지 확인
4) **핫 SQL** 추출: AWR Top SQL 또는 ASH(해당 구간) 데이터를 활용
5) **Plan 라인 매핑**: SQL Monitor 또는 `DISPLAY_CURSOR('ALLSTATS LAST')`로 실제 실행 계획 분석
6) **원인 조치** 매핑: 인덱스/조인/메모리/로그/락/서비스 라우팅 등 적절한 최적화 방안 도출
7) **재검증**: 동일 조건에서 Before/After 성능 비교

---

## 실전 SQL: **RTA 프로파일** 빠르게 추출하기

### **Top Wait Class/Event**

```sql
-- 최근 10분 ASH 샘플 기준
SELECT wait_class, event, COUNT(*) AS samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
  AND  session_type = 'FOREGROUND'
GROUP  BY wait_class, event
ORDER  BY samples DESC FETCH FIRST 15 ROWS ONLY;
```

### 구간별 **Top SQL(응답시간 기여도)**

```sql
SELECT sql_id,
       COUNT(*) AS samples,
       SUM(CASE WHEN session_state='ON CPU' THEN 1 ELSE 0 END) AS on_cpu,
       SUM(CASE WHEN session_state='WAITING' THEN 1 ELSE 0 END) AS on_wait
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type = 'FOREGROUND'
GROUP  BY sql_id
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;
```

### 특정 SQL의 **Wait 타임라인(초단위 프로파일)**

```sql
-- 특정 SQL_ID의 wait_class 분포를 시간 버킷으로 분석
WITH buckets AS (
  SELECT TRUNC(CAST(sample_time AS DATE) + (TO_NUMBER(TO_CHAR(sample_time,'SSSSS'))/5))/ (1/288) AS bucket_start,
         wait_class
  FROM   v$active_session_history
  WHERE  sql_id = :sql_id
    AND  sample_time BETWEEN :t1 AND :t2
)
SELECT MIN(bucket_start) AS bucket,
       wait_class,
       COUNT(*) AS samples
FROM   buckets
GROUP  BY bucket_start, wait_class
ORDER  BY bucket, wait_class;
```

> 이 타임라인 분석을 통해 "**언제** 무슨 대기가 **급증했는지**"를 즉시 파악할 수 있습니다.

---

## 대기 클래스별 **원인 → 조치** 매핑(요지)

| Wait Class | 대표 이벤트 | 주 원인 | 대표 처방 |
|---|---|---|---|
| User I/O | `db file sequential read` | 랜덤 I/O(인덱스→ROWID) | 인덱스 설계/선택성/커버링/클러스터링 팩터 |
|  | `db file scattered read` | FTS/범위 스캔 | 인덱스/파티션/병렬 |
|  | `direct path read temp` | 정렬/해시 스필 | PGA↑, 카디널리티 보정, 조인전략 전환 |
| Concurrency | `enq: TX - row lock contention` | 행잠금 충돌, FK 미인덱스, ITL 부족 | FK 인덱스, 커밋 단축, INITRANS↑, 키 분산 |
|  | `buffer busy waits` | 핫블록/헤더 | 키 분산, PCTFREE/INITRANS 조정 |
| Library/Row Cache | `library cache: lock/pin` | 하드파싱/Invalidation | 바인드, 커서 캐시, DDL 배치 |
| Commit | `log file sync` | 잦은 커밋, 스토리지 지연 | 배치 커밋, LGWR 대상 성능 개선 |
| Cluster(RAC) | `gc current/cr block busy` | 글로벌 핫블록 | 데이터 로컬리티, Reverse Key, 시퀀스 NOORDER |

---

## **OWI + Plan 라인** 연결(결정적 단계)

- **왜 필요한가?** "I/O가 많다"는 사실만으로는 해결책을 도출하기 어렵습니다. **어떤 특정 연산(라인)** 이 원인인지 알아야 **정확하고 효과적인 처방**이 가능합니다.
- **어떻게 하는가?**
  - **SQL Monitor**: Row Source별 경과시간/대기/Temp 사용량을 시각적으로 표현
  - **`DBMS_XPLAN.DISPLAY_CURSOR(..., 'ALLSTATS LAST')`** : A-Rows/Starts/Time/Temp/Buffers 등의 실제 실행 통계 제공

**예시**
```sql
-- 마지막 실행의 실제 라인 통계
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(:sql_id, NULL,
  'ALLSTATS LAST +PEEKED_BINDS +PREDICATE +PROJECTION +OUTLINE +NOTE'));
```
- `SORT ORDER BY` 라인의 **TempSpc** 증가 → PGA 조정 또는 정렬 회피 필요
- `HASH JOIN` 라인의 Time 증가 → 카디널리티 정확화/드라이빙 테이블 변경/인덱스 선행 필터
- `INDEX RANGE SCAN` + `TABLE ACCESS BY ROWID`에서 Time 증가 → **선택성 개선/커버링 인덱스** 등

---

## **사례 시나리오**로 배우는 RTA

### 정렬 스필이 응답시간의 70%를 차지하는 케이스

- **증상**: 보고서 쿼리 평균 실행 시간 8초.
- **RTA**: Top Wait = `direct path read temp` (User I/O)
- **Plan 매핑**: `SORT GROUP BY`/`SORT ORDER BY` 라인 Time 증가, `TempSpc` 증가
- **원인**: 카디널리티 오판으로 해시/정렬 데이터량이 과대 추정됨
- **조치**:
  - `region` 컬럼에 히스토그램 생성 → 선택도 개선
  - 커버링 인덱스로 정렬 작업 회피(`(region,dt)` 포함)
  - `pga_aggregate_target` 파라미터 상향 조정
- **효과**: TempSpc 사용량 5GB → 0, Elapsed Time 8s → 0.9s

### `log file sync`가 40% — 커밋 병목

- **증상**: OLTP TPS 증가와 함께 응답시간 급증(피크 타임).
- **RTA**: Commit 클래스로 대기 집중.
- **원인**: 매 행마다 커밋 발생, 네트워크 및 스토리지 지연.
- **조치**: 업무 타협 하에 **배치 커밋** 도입, 드라이버/네트워크 지연 점검, 로그 그룹/대상 디스크 성능 개선.
- **효과**: 평균 응답시간 2.2s → 0.7s.

### `enq: TX - row lock contention` — FK 미인덱스

- **증상**: 특정 삭제/갱신 트랜잭션에서 전체 시스템 느려짐.
- **RTA**: Concurrency 최상위, ASH에서 같은 테이블 Child 참조 다수 발견.
- **원인**: **외래키 미인덱스**로 인해 부모 테이블 업데이트/삭제 시마다 자식 테이블 전체 스캔 및 락 경합 발생.
- **조치**: FK 컬럼 인덱스 생성.
- **효과**: 대기 이벤트 제거, 응답시간 정상화.

### RAC `gc current block busy` — 글로벌 핫블록

- **증상**: 2노드 RAC 환경, 피크 시간 시스템 느려짐.
- **RTA**: Cluster 클래스 상위, `gc current block busy` 집중.
- **원인**: 증가키 우측 집중 인덱스/시퀀스 ORDER 설정, 특정 파티션에 트래픽 집중.
- **조치**: 시퀀스 `NOORDER CACHE n` 설정, Reverse Key 인덱스 적용, 서비스 로컬리티 구성, 파티션 분산.
- **효과**: AAS 급감, 응답시간 안정화.

---

## **RTA 대시보드**: 10분 만에 구축하는 SQL

### Wait Class 프로파일(최근 15분)

```sql
SELECT wait_class,
       COUNT(*) AS samples,
       ROUND(100 * RATIO_TO_REPORT(COUNT(*)) OVER (), 1) AS pct
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '15' MINUTE
  AND  session_type = 'FOREGROUND'
GROUP  BY wait_class
ORDER  BY samples DESC;
```

### Top Event + Top SQL 교차 분석

```sql
WITH base AS (
  SELECT event, sql_id FROM v$active_session_history
  WHERE  sample_time BETWEEN :t1 AND :t2
    AND  session_type='FOREGROUND'
)
SELECT event, sql_id, COUNT(*) samples
FROM   base
GROUP  BY event, sql_id
ORDER  BY samples DESC FETCH FIRST 20 ROWS ONLY;
```

### AAS(구간 평균 활성 세션) 계산

```sql
SELECT ROUND(COUNT(*) / (EXTRACT(SECOND FROM (:t2-:t1)) + 60*EXTRACT(MINUTE FROM (:t2-:t1)) + 3600*EXTRACT(HOUR FROM (:t2-:t1))),2)
       AS AAS
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND';
```

> 위 세 가지 쿼리 결과를 통합하면, "**무엇이 문제인지**"를 1~2분 안에 명확히 파악할 수 있는 대시보드를 구성할 수 있습니다.

---

## SLO/퍼센타일과 RTA

- 평균 응답시간은 **극단값에 의해 쉽게 왜곡**될 수 있습니다. **p50/p90/p99**와 같은 퍼센타일 지표를 함께 분석하여 실제 사용자 체감에 맞는 성능을 평가해야 합니다.
- 트랜잭션 로그, 웹 게이트웨이, 애플리케이션 계층에서 **요청 시작-종료 시간**과 **데이터베이스 호출 시간**을 함께 기록하여 **데이터베이스 기여 분**을 정확히 분리할 수 있어야 합니다.
- **RTA 분석 결과**와 **퍼센타일 SLO** 를 연결합니다: 예를 들어 "p95 응답시간 1.0초" 목표라면, DB Time 프로파일에서 p95 구간의 **주요 병목 클래스**를 우선적으로 제거해야 합니다.

---

## 고급: 간이 대기행렬 이론(선택)

- **Utilization Law**(이용률 법칙):
  $$ R \approx \frac{S}{1-U} $$
  - \(S\): 순수 서비스 시간(예: CPU 처리 시간)
  - \(U\): 자원 이용률
  시스템 자원의 이용률이 70~80%를 넘으면 **대기 시간이 급증**합니다. RTA 분석을 통해 해당 자원(디스크 I/O, 로그 버퍼, CPU 등)의 **대기 이벤트**가 실제로 증가했는지 확인할 수 있습니다.

---

## 운영 체크리스트(습관화)

1) **시간 범위, 서비스/모듈 명확히 고정**(분석 기준이 흔들리면 잘못된 결론에 도달할 수 있습니다)
2) **Top Wait Class/Event** → **핫 SQL** → **Plan 라인** 순서로 체계적으로 추적
3) **증거 저장**: AWR 비교용 스냅샷, SQL Monitor 리포트 등 객관적 데이터 보관
4) **작은 변경으로 최대 효과**: 인덱스/통계/조인순서/커밋 정책/키 분산 등 핵심적인 최적화에 집중
5) **재검증**: 동일한 부하 조건, 동일한 시간대, 동일한 대시보드를 활용한 효과 검증

---

## 미니 실습(끝까지 따라하기)

### 시나리오: 보고서 페이지 응답시간 6~8초

**1) 구간 고정**
```sql
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '10' MINUTE;
EXEC :t2 := SYSTIMESTAMP;
```

**2) Wait Class 프로파일**
```sql
SELECT wait_class, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY wait_class
ORDER  BY samples DESC;
```
→ 결과 예시: `User I/O`와 `Commit`가 상위 Wait Class.

**3) Top Event/Top SQL**
```sql
SELECT event, sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY event, sql_id
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;
```
→ 결과 예시: `direct path read temp` 이벤트와 특정 `sql_id='abc123'` SQL이 상위.

**4) 해당 SQL 실제 라인 통계**
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('abc123', NULL,
  'ALLSTATS LAST +PREDICATE +PROJECTION +PEEKED_BINDS +OUTLINE +NOTE'));
```
→ 결과 분석: `SORT GROUP BY` 라인에서 TempSpc 증가, Time 증가 확인.

**5) 처방 및 개선**
- 인덱스 추가 `(region, dt)`로 정렬 작업 회피 또는 드라이빙 결과 집합 축소
- PGA 상향 조정 검토 / 카디널리티 보정(히스토그램 생성)
- 재검증: 동일한 대시보드에서 Temp 대기 감소, Elapsed Time 감소 확인

---

## 스크립트 모음(복붙 용)

### 시스템 수준 RTA 스냅샷(최근 15분, Top 12 이벤트)

```sql
SELECT wait_class, event, COUNT(*) AS samples,
       ROUND(100*RATIO_TO_REPORT(COUNT(*)) OVER (),1) AS pct
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '15' MINUTE
  AND  session_type='FOREGROUND'
GROUP  BY wait_class, event
ORDER  BY samples DESC FETCH FIRST 12 ROWS ONLY;
```

### 특정 서비스/모듈만 핀포인트 분석

```sql
SELECT wait_class, event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  service_hash = (SELECT service_hash FROM v$active_services WHERE name='PAYROLL_SVC')
  AND  module = 'PAYROLL-BATCH'
GROUP  BY wait_class, event
ORDER  BY samples DESC;
```

### 응답시간과 처리량 분석(리틀의 법칙 적용)

```sql
-- AAS 계산
WITH t AS (
  SELECT COUNT(*) AS samples
  FROM   v$active_session_history
  WHERE  sample_time BETWEEN :t1 AND :t2
    AND  session_type='FOREGROUND'
)
SELECT ROUND(samples / (EXTRACT(SECOND FROM (:t2-:t1))
       +60*EXTRACT(MINUTE FROM (:t2-:t1))
       +3600*EXTRACT(HOUR FROM (:t2-:t1))),2) AS aas
FROM t;

-- Tx/초(대략): 실제 처리량은 애플리케이션/트랜잭션 로그에서 수집 권장
-- response_time ≈ AAS / throughput  (단위 일치 주의)
```

---

## 자주 하는 질문(FAQ)

**Q1. 평균 대신 퍼센타일을 분석하려면 어떻게 해야 하나요?**
A. 데이터베이스 단독으로는 한계가 있으므로, 애플리케이션 게이트웨이/미들웨어에서 **요청 p90/p99 응답시간**을 측정한 후, 해당 시각대의 **데이터베이스 RTA** 분석을 매칭하여 DB 기여도를 평가해야 합니다.

**Q2. AWR 리포트만 보면 충분한가요?**
A. **AWR=시스템 요약**, **ASH=세밀한 타임라인**입니다. 실전 분석에서는 **둘 다 활용**하는 것이 이상적입니다. 장시간 실행 중인 SQL이나 현재 실행 중인 작업은 **SQL Monitor**가 가장 효과적인 도구입니다.

**Q3. Buffer Cache Hit Ratio가 99%인데도 시스템이 느립니다.**
A. 이는 정상적인 상황일 수 있습니다. TEMP 스필, 커밋 지연, 라이브러리 캐시 락, 네트워크 대기 등 **다른 유형의 병목**이 응답시간을 지배하고 있을 수 있습니다. **RTA 분석**은 바로 이러한 "진짜 병목의 이름표"를 찾는 도구입니다.

---

## 결론

응답시간 분석(RTA) 방법론과 Oracle Wait Interface(OWI)는 현대 데이터베이스 성능 튜닝의 근간을 이루는 핵심 기술입니다. 이 접근법은 단순히 "시스템이 느리다"는 모호한 문제 진술을, CPU 시간과 다양한 대기 이벤트로 구성된 정량적인 시간 구성 요소로 분해하여, 문제 해결을 체계적이고 과학적으로 접근할 수 있도록 합니다.

RTA의 성공적인 적용을 위해서는 확고한 분석 프로세스가 필요합니다: 성능 저하 구간의 명확한 정의, DB Time의 CPU/대기 분해, Top 대기 이벤트 식별, 문제 SQL 추출, 실행 계획 라인별 상세 분석의 단계를 꼼꼼히 따르는 것입니다. 이 과정에서 OWI는 각 대기 현상에 정확한 "이름표"를 부여하고, SQL Monitor 및 DBMS_XPLAN 도구들은 그 원인이 되는 정확한 실행 계획 라인을 지목해 줍니다.

이러한 분석의 궁극적 목표는 단순한 문제 해결을 넘어, 데이터베이스 시스템의 동작에 대한 깊은 이해와 예측 능력을 갖추는 데 있습니다. 각 대기 이벤트가 의미하는 바, 다양한 비율 지표들의 상관관계, 그리고 시스템 자원의 이용률과 응답시간의 관계를 이해함으로써, 단순한 반응적 튜닝에서 예측적이고 선제적인 성능 관리로 나아갈 수 있습니다.

실무에서의 성공은 이론적 지식과 도구 숙련도를 넘어, 체계적인 문제 해결 프로세스를 습관화하고, 모든 변경의 효과를 객관적인 데이터로 검증하는 문화를 정착시키는 데 달려 있습니다. RTA와 OWI는 그러한 문화를 구축하는 데 필요한 가장 강력한 프레임워크를 제공합니다.