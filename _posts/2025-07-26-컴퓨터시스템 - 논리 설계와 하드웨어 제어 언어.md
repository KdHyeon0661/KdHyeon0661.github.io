---
layout: post
title: 컴퓨터시스템 - 논리 설계와 하드웨어 제어 언어
date: 2025-07-26 20:20:23 +0900
category: 컴퓨터시스템
---
# 논리 설계와 하드웨어 제어 언어(HCL): Y86-64를 통한 데이터경로·제어

## 개요: 논리 설계와 HCL의 역할

- **논리 설계(Logical Design)**는 디지털 회로를 **불 대수(Boolean Algebra)**로 추상화해, 입력과 상태가 출력·다음 상태를 어떻게 결정하는지 정의한다.
- **HCL**(Hardware Control Language)은 데이터경로상의 **제어 신호**를 **조건부 선택**으로 기술해 **멀티플렉서(MUX)**, **연산 선택**, **읽기/쓰기 제어**, **PC 갱신** 등을 선언형으로 표현한다.
- Y86-64는 교육용 ISA로서, x86-64의 본질을 단순화한 **레지스터·메모리·연산·분기/호출**의 최소 집합을 제공한다.

---

## 디지털 논리 기초와 데이터경로

### 조합·순차 논리

- **조합 논리(Combinational)**: 출력이 **현재 입력**만으로 결정.
  예) 가산기, 비교기, 멀티플렉서.
- **순차 논리(Sequential)**: **상태(레지스터/플립플롭)** + 현재 입력으로 다음 출력·상태가 결정.
  예) 레지스터 파일, 상태기계(FSM), 파이프라인 레지스터.

### 데이터경로 핵심 블록

| 블록 | 요약 | 신호 예 |
|---|---|---|
| **PC** | 현재 명령어의 주소 보관 | `pc`, `new_pc` |
| **명령 메모리** | 명령 페치 | `imem_data`, `imem_error` |
| **레지스터 파일** | 2R1W(두 읽기/한 쓰기) 일반적 | `srcA/srcB`, `dstE/dstM`, `valA/valB` |
| **ALU** | add/sub/and/xor/… | `aluA/aluB`, `alufun`, `cc(ZF,SF,OF)` |
| **데이터 메모리** | load/store | `mem_read/write`, `mem_addr`, `mem_data` |
| **MUX** | 다중 선택 | HCL 조건부 선택문으로 기술 |

---

## HCL 빠른 문법 가이드

### 형식·타입·상수

- **타입**: `bool`, `word`(고정 폭 정수/비트열).
- **상수**: `ALUADD`, `REG_NONE`, `IJXX` 등은 기호 상수로 전개.
- 집합 포함: `icode in { IOPQ, IMRMOVQ }`

### 선택(멀티플렉싱)과 기본형

```hcl
word x = [
    cond1 : expr1;
    cond2 : expr2;
    1     : default_expr;
];
```

- 위는 **우선순위 선택**. `cond1` 성립 시 `expr1`, 아니면 다음, 끝까지 없으면 `default_expr`.

### 불 논리

```hcl
bool write_reg = icode in { IRRMOVQ, IIRMOVQ, IOPQ, IMRMOVQ };
bool use_mem   = icode in { IMRMOVQ, IRMMOVQ, IPOPQ, IPUSHQ };
```

---

## Y86-64 명령·필드·가치 흐름(리캡)

- **첫 바이트**: `icode`(상위 4bit) + `ifun`(하위 4bit)
- **레지스터 바이트**: `rA`(상위) + `rB`(하위), 없을 때 `REG_NONE(0xF)`
- **즉시값 `valC`**(8바이트, 리틀엔디안), **다음 PC `valP`**

주요 명령(요지):

| 범주 | 명령 |
|---|---|
| 이동/조건이동 | `rrmovq/cmovXX`, `irmovq`, `rmmovq`, `mrmovq` |
| 연산 | `OPq` = `addq/subq/andq/xorq` (ifun으로 선택) |
| 제어 | `jXX`(조건 점프), `call`, `ret`, `halt`, `nop` |
| 스택 | `pushq`, `popq` |

---

## 단일사이클(SEQ) 설계: HCL로 제어 신호 정의

> 목표: 한 클록에 **Fetch→Decode→Execute→Memory→Write-back→PC Update**를 순회.
> HCL은 **각 단계의 제어 신호**를 명령별 규칙에 따라 계산한다.

### Fetch (명령 페치)

```hcl
word f_icode = imem_icode;
word f_ifun  = imem_ifun;

word f_valC  = extracted_imm64;     # 명령 내 즉시값
word f_valP  = pc + instr_len;      # 다음 명령의 기본 주소
bool f_ok    = !imem_error && insn_valid;
```

- 구현에서는 `pc`에서 가변 길이 인스트럭션을 읽고, 구성요소(icode/ifun/rA/rB/valC/valP)를 디코드.

### Decode (레지스터 읽기 대상 선택)

명령별 **소스/목적** 레지스터 id를 먼저 HCL로 계산:

```hcl
word srcA = [
    icode in { IRRMOVQ, IRMMOVQ, IOPQ } : rA;
    icode in { IPUSHQ, IPOPQ, IRET }    : RRSP;   # 스택 사용
    1 : REG_NONE;
];

word srcB = [
    icode in { IOPQ, IRMMOVQ, IMRMOVQ } : rB;
    icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
    1 : REG_NONE;
];

word dstE = [
    icode in { IRRMOVQ, IIRMOVQ, IOPQ } : rB;
    icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;  # 스택 갱신
    1 : REG_NONE;
];

word dstM = [
    icode in { IMRMOVQ, IPOPQ } : rA;   # 메모리에서 레지스터로
    1 : REG_NONE;
];
```

레지스터 파일에서 **값 읽기**:

```hcl
word d_valA = reg_output(srcA);
word d_valB = reg_output(srcB);
```

### Execute (ALU 입력·연산·분기 조건)

ALU 입력 선택:

```hcl
word aluA = [
    icode in { IRRMOVQ, IOPQ }                 : d_valA;
    icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ }     : valC;
    icode in { ICALL, IPUSHQ }                 : -8;
    icode in { IRET,  IPOPQ  }                 : 8;
    1 : 0;
];

word aluB = [
    icode in { IOPQ, IRMMOVQ, IMRMOVQ }        : d_valB;
    icode in { ICALL, IPUSHQ, IRET, IPOPQ }    : d_valB;  # RSP 기반
    1 : 0;
];

word alufun = [
    icode == IOPQ : ifun;    # add/sub/and/xor
    1 : ALUADD;              # 기본은 더하기(주소계산/스택)
];
```

조건 코드(CC) 갱신:

```hcl
bool set_cc = icode == IOPQ;     # 산술/논리 연산에서만 CC 갱신
```

분기 조건 판단:

```hcl
bool Cnd = [
    ifun == JMP  : 1;
    ifun == JLE  : (ZF | (SF ^ OF));
    ifun == JL   : (SF ^ OF);
    ifun == JE   : ZF;
    ifun == JNE  : !ZF;
    ifun == JGE  : !(SF ^ OF);
    ifun == JG   : !(SF ^ OF) & !ZF;
    1 : 0;
];
```

ALU 결과:

```hcl
word e_valE = alu(aluA, aluB, alufun, set_cc);
```

**조건이동**의 목적지 무효화(조건 불충족 시 결과 폐기):

```hcl
word e_dstE = [
    (icode == IRRMOVQ) && !Cnd : REG_NONE;   # 조건 실패 → 쓰기 금지
    1 : dstE;
];
```

### Memory (로드/스토어 제어)

메모리 접근 여부·주소·데이터:

```hcl
bool mem_read =  icode in { IMRMOVQ, IPOPQ, IRET };
bool mem_write = icode in { IRMMOVQ, IPUSHQ, ICALL };

word mem_addr = [
    icode in { IRMMOVQ, IMRMOVQ, IOPQ } : e_valE;  # 유효주소(기준+오프셋)
    icode in { IPUSHQ, ICALL, IRET, IPOPQ } : e_valE or m_valA; # 규약에 맞게
    1 : 0;
];

word mem_data = [
    icode in { IRMMOVQ } : d_valA;
    icode in { IPUSHQ, ICALL } : valP;   # call은 복귀주소 저장
    1 : 0;
];

bool m_ok = !dmem_error;
word m_valM = data_mem_read(mem_addr, mem_read);   # load 결과
```

### Write-back (레지스터 쓰기)

```hcl
# E 결과를 dstE에, M 결과(load)를 dstM에

write_reg(e_dstE, e_valE);
write_reg(dstM,  m_valM);
```

### PC Update

```hcl
word new_pc = [
    icode == IJXX   && Cnd : valC;     # 분기 성립
    icode == IJXX   && !Cnd: valP;     # 불성립 → fall-through
    icode == ICALL            : valC;  # 타깃으로 점프
    icode == IRET             : m_valM;# 스택서 리턴주소 pop
    1 : valP;                         # 기본: 다음 명령
];
```

### 상태코드(stat)

```hcl
word stat = [
    imem_error | dmem_error : SADR;   # 주소 오류
    !insn_valid             : SINS;   # 잘못된 명령
    icode == IHALT          : SHLT;   # 정상 종료
    1                       : SAOK;   # 정상 진행
];
```

---

## 동작 검증 워크스루(핵심 명령)

### `irmovq $V, rB`

- `srcA=REG_NONE`, `srcB=REG_NONE`, `dstE=rB`, `dstM=NONE`
- `aluA=valC`, `aluB=0`, `alufun=ADD`, `e_valE=V` → `rB ← V`
- `mem_*` 없음, `new_pc=valP`

### `rmmovq rA, D(rB)`

- `srcA=rA`, `srcB=rB`, `dst*` 없음
- `aluA=valC(D)`, `aluB=d_valB(R[rB])` → 유효주소
- `mem_write=1`, `mem_addr=e_valE`, `mem_data=d_valA` → `M[addr] ← R[rA]`

### `mrmovq D(rB), rA`

- `srcB=rB`, `dstM=rA`
- 유효주소 계산 후 `mem_read=1`, `m_valM`를 `rA`에 기록

### `OPq rA,rB`

- `srcA=rA`, `srcB=rB`, `dstE=rB`, `set_cc=1`
- `rB ← R[rB] op R[rA]`, CC 갱신

### `call D` / `ret`

- `call`: `rsp ← rsp-8`, `M[rsp] ← valP`, `pc ← D`
- `ret`: `valM ← M[rsp]`, `rsp ← rsp+8`, `pc ← valM`

---

## 파이프라인(PIPE) 설계: 전방전달·스톨·버블 HCL

> 5단계 파이프: **F / D / E / M / W** + 각 단계 사이 레지스터(F/D/E/M/W).
> 목표: 데이터 위험(Forwarding), 제어 위험(분기/ret), 메모리 위험 처리.

### 전방전달(Forwarding) — Decode단의 피연산자 선택

```hcl
# d_valA 선택(우선순위: M→W→레지스터)

word fwdA = [
    (srcA != REG_NONE) && (srcA == e_dstE) : e_valE;    # 바로 앞 E결과 (가능 시)
    (srcA != REG_NONE) && (srcA == M_dstM) : m_valM;    # M단 load 결과
    (srcA != REG_NONE) && (srcA == M_dstE) : M_valE;    # M단 ALU 결과
    (srcA != REG_NONE) && (srcA == W_dstM) : W_valM;    # W단 load 결과
    (srcA != REG_NONE) && (srcA == W_dstE) : W_valE;    # W단 ALU 결과
    1 : reg_output(srcA);
];

word fwdB = [  # srcB도 동일 패턴
    (srcB != REG_NONE) && (srcB == e_dstE) : e_valE;
    (srcB != REG_NONE) && (srcB == M_dstM) : m_valM;
    (srcB != REG_NONE) && (srcB == M_dstE) : M_valE;
    (srcB != REG_NONE) && (srcB == W_dstM) : W_valM;
    (srcB != REG_NONE) && (srcB == W_dstE) : W_valE;
    1 : reg_output(srcB);
];
```

> 실제 교재 파이프는 **Decode단**에서 전방전달을 활용해 `d_valA/d_valB`를 만든다.

### Load-Use Hazard: 스톨 + 버블

패턴: `mrmovq`나 `popq`가 **다음 명령의 피연산자**로 바로 필요할 때.

```hcl
bool load_use_hazard =
    (E_icode in { IMRMOVQ, IPOPQ }) &&
    ( (E_dstM == D_srcA) || (E_dstM == D_srcB) );

# 제어 신호

bool F_stall = load_use_hazard;
bool D_stall = load_use_hazard;
bool E_bubble = load_use_hazard;
```

해석: Fetch/Decode를 정지(F/D 스톨), Execute 단계에 **버블**(noop) 삽입.

### `ret` Hazard: PC 의존성 해결

`ret`는 **메모리에서 복귀주소를 읽기** 전까지 다음 PC를 모른다 → F/D 스톨.

```hcl
bool ret_in_pipe = (D_icode == IRET) || (E_icode == IRET) || (M_icode == IRET);

bool F_stall |= ret_in_pipe;
bool D_bubble = ret_in_pipe && !load_use_hazard;   # 상황 조합에 따라
```

### 분기 오예측: E단에서 Cnd 확정 후 버블

예측 정책: 기본 **Not-Taken**(fall-through).
E단에서 실제 `Cnd`가 참일 경우, 이미 가져온 D단 명령은 **잘못된 경로** → 버블.

```hcl
bool mispred_branch = (E_icode == IJXX) && !E_Cnd;

bool D_bubble |= mispred_branch;
bool E_bubble |= mispred_branch;
```

### 예외/정지 전파

오류(stat=ADR/INS)나 `halt`는 파이프 하류(W)까지 **전파**해 종료.

---

## 예제: Y86-64로 배열 합(파이프 기준) — 신호 추적

### Y86 어셈(개념)

```asm
# rdi = base, rsi = n

init:   irmovq $0, %rax        # sum=0
        irmovq $0, %rcx        # i=0
loop:   rrmovq %rcx, %r8
        irmovq $4, %r9
        OPq mul? (단순화 가정: addq %r9,%r8;%r8=%rcx*4)
        mrmovq 0(%rdi,%r8), %rbx
        addq   %rbx, %rax
        addq   $1, %rcx
        rrmovq %rcx, %r10
        subq   %rsi, %r10
        jge    done
        jmp    loop
done:   halt
```

> 실제 Y86에는 스케일 주소 지정/곱이 없으므로 `rcx*4`는 더하기로 전개.
> 파이프에서는 각 단계의 **전방전달·스톨**이 이 루프의 **load-use** 상황(방금 읽은 `mrmovq` 결과를 바로 더함)에 개입한다.

### Hazard 스냅샷

- `mrmovq` → 다음 `addq`가 바로 `rbx` 사용 → **load-use** → F/D 스톨 & E 버블 1사이클.
- 분기 `jge/jmp`는 기본 Not-Taken 가정 → 실제 분기 발생 시 E단에서 **misprediction** 처리로 D/E 버블.

---

## 타이밍·임계경로·성능 직관

- **SEQ(단일사이클)**: 한 클록에 모든 단계 → 클록 주기 = **최장 경로 지연**.
  $$ T_{\text{clk}} \ge t_{\text{IMEM}} + t_{\text{DEC}} + t_{\text{ALU}} + t_{\text{DMEM}} + t_{\text{WB}} + \text{여유} $$
- **PIPE**: 단계를 쪼개고 레지스터로 경계 →
  $$ T_{\text{clk}} \ge \max_i (t_i) + t_{\text{reg}} $$
  처리량(throughput)↑, 지연(latency)≈단계 수 증가.

---

## 검증과 관찰 포인트

- **stat**: `SAOK/SHLT/SADR/SINS` 전파 및 종료 판정.
- **imem_error/dmem_error**: 범위 밖 접근 검출.
- **insn_valid**: 미정의 icode/ifun 차단.
- **리셋/초기 PC**: `.pos`/`pc=0` 등 설계 상수.
- **레지스터·메모리 덤프**: 단계별 값이 기대치와 일치하는지 비교.

---

## HCL → HDL → 합성(개요)

- HCL은 본질적으로 **조합 논리 식 + 상태 레지스터 기술** → Verilog/VHDL로 **자동 전개** 가능.
- 합성 단계에서 **로직 최적화**, **플립플롭 배치**, **타이밍 폐색(closure)** 수행.
- 반도체(ASIC)/FPGA 맵핑 시 **타이밍 예산**, **클록 도메인**, **리셋 전략**, **메모리 매핑**을 실제 파라미터로 확정.

---

## HCL 완성 예(SEQ 기준) — 핵심 신호 모음

> 실제 파일은 수십~수백 라인이지만, 핵심만 **연결 가능한 조각**으로 제시한다.

```hcl
# 소스/목적 레지스터

word srcA = [
  icode in { IRRMOVQ, IRMMOVQ, IOPQ } : rA;
  icode in { IPUSHQ, IPOPQ, IRET    } : RRSP;
  1 : REG_NONE;
];

word srcB = [
  icode in { IOPQ, IRMMOVQ, IMRMOVQ } : rB;
  icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
  1 : REG_NONE;
];

word dstE = [
  icode in { IRRMOVQ, IIRMOVQ, IOPQ } : rB;
  icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
  1 : REG_NONE;
];

word dstM = [
  icode in { IMRMOVQ, IPOPQ } : rA;
  1 : REG_NONE;
];

# ALU 입력/연산

word aluA = [
  icode in { IRRMOVQ, IOPQ }                 : valA;
  icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ }     : valC;
  icode in { ICALL, IPUSHQ }                 : -8;
  icode in { IRET,  IPOPQ  }                 : 8;
  1 : 0;
];

word aluB = [
  icode in { IOPQ, IRMMOVQ, IMRMOVQ }        : valB;
  icode in { ICALL, IPUSHQ, IRET, IPOPQ }    : valB;
  1 : 0;
];

word alufun = [
  icode == IOPQ : ifun;
  1 : ALUADD;
];

bool set_cc = icode == IOPQ;

# 분기 조건

bool Cnd = [
  ifun == JMP : 1;
  ifun == JLE : (ZF | (SF ^ OF));
  ifun == JL  : (SF ^ OF);
  ifun == JE  : ZF;
  ifun == JNE : !ZF;
  ifun == JGE : !(SF ^ OF);
  ifun == JG  : !(SF ^ OF) & !ZF;
  1 : 0;
];

# 조건이동 목적지 무효화

word e_dstE = [
  (icode == IRRMOVQ) && !Cnd : REG_NONE;
  1 : dstE;
];

# 메모리 제어

bool mem_read  = icode in { IMRMOVQ, IPOPQ, IRET };
bool mem_write = icode in { IRMMOVQ, IPUSHQ, ICALL };

word mem_addr = [
  icode in { IRMMOVQ, IMRMOVQ, IOPQ } : e_valE;
  icode in { ICALL, IPUSHQ, IRET, IPOPQ } : e_valE; # 단일사이클 가정
  1 : 0;
];

word mem_data = [
  icode == IRMMOVQ : valA;
  icode in { IPUSHQ, ICALL } : valP;
  1 : 0;
];

# PC 업데이트

word new_pc = [
  icode == IJXX  && Cnd : valC;
  icode == IJXX  && !Cnd: valP;
  icode == ICALL         : valC;
  icode == IRET          : m_valM;
  1 : valP;
];

# stat

word stat = [
  imem_error | dmem_error : SADR;
  !insn_valid             : SINS;
  icode == IHALT          : SHLT;
  1 : SAOK;
];
```

---

## 실습 팁: 설계-시뮬레이션-검증 루프

1) **명령 단위 유닛 테스트**: `irmovq/rmmovq/mrmovq/opq/jXX/call/ret/push/pop` 각각 입출력·상태 확인
2) **짧은 트레이스**로 **레지스터/메모리**를 단계별 덤프 → 기대치와 비교
3) 파이프라인으로 올릴 때는 **forwarding**이 실제로 load-use를 한 사이클만 지연시키는지 확인
4) **예외 경로(stat)**, **ret 경로**, **분기 오예측** 케이스 의도적으로 삽입

---

## C vs HCL vs HDL: 관점 차이 요약

| 관점 | C | HCL | HDL(Verilog/VHDL) |
|---|---|---|---|
| 대상 | 소프트웨어 동작 | 제어 신호 수식화 | 하드웨어 구조·타이밍 |
| 시점 | 런타임 | 클록 경계 간 조합 결정 | 클록/리셋/지연 포함 |
| 상태 | 언어 런타임/메모리 | 외부 상태 레지스터 참조 | 레지스터/와이어 명시 |
| 결과 | 바이너리 실행 | 제어망 + MUX 구성 | 게이트/FF 네트리스트 |

---

## 수식 메모(조건·타이밍 직관)

- 부호 비교(예):
  $$ \text{less} \iff (SF \oplus OF) $$
  $$ \text{le} \iff (SF \oplus OF) \lor ZF $$
- 처리량/지연(개념):
  $$ \text{Throughput} \approx \frac{1}{T_{\text{clk}}}, \quad
     \text{Latency} \approx N_{\text{stages}} \cdot T_{\text{clk}} $$

---

## 마무리

- **HCL은 하드웨어의 “if/else”**: 데이터경로의 스위치를 **선언적**으로 기술해, 명령별 제어 신호를 체계화한다.
- **Y86-64**는 최소한의 ISA로 **주소계산·연산·분기·호출·스택**의 본질을 드러낸다.
- **SEQ**에서 논리를 확립하고, **PIPE**에서 전방전달·스톨·버블로 실제 프로세서 동작을 만든다.
- 타이밍·검증·합성 관점까지 연결하면, **소프트웨어가 전기 신호로 움직이는 전 과정**을 손에 잡히게 된다.

---
```hcl
# 연습1: OPq(add/sub/and/xor)에서 alufun과 set_cc만 수정해,
#        다른 명령의 주소계산은 ALUADD 고정이 되도록 유지하라.

# 연습2: jXX 오예측을 "항상 Taken"으로 가정하도록 바꾸고,
#        new_pc HCL을 수정해 성능/정확성 차이를 관찰하라.

# 연습3: load-use 조건(load이 E_dstM에 기록될 때)을 일반화하여
#        multi-source hazard(두 피연산자 모두 의존)도 커버하도록 확장하라.

```
