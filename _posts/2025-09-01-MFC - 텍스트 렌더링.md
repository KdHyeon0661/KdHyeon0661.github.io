---
layout: post
title: MFC - 텍스트 렌더링
date: 2025-09-01 17:25:23 +0900
category: MFC
---
# 텍스트 렌더링: 폰트/유니코드/문자폭, 국제화 주의점 (MFC·Win32·GDI/GDI+/DirectWrite 총정리)

이 글은 **Windows(MFC/Win32)** 환경에서의 **텍스트 렌더링**을 처음부터 끝까지 정리합니다.  
**폰트 메트릭**과 **유니코드(서로게이트·조합문자·이모지)**, **문자폭(East Asian Width)**, **줄나눔/말줄임/정렬**, **Bidi(혼합 방향 스크립트)**, **셰이핑(Arabic/Indic)**, **폰트 대체/연결**, **ClearType·안티앨리어싱**, **DPI·고해상도**, **인쇄**, **IME**까지 **실전 코드** 위주로 다룹니다.  
GDI/GDI+/Uniscribe/DirectWrite를 모두 비교 소개하되, **새 프로젝트**라면 **DirectWrite**를 우선 추천합니다.

> 대상: MFC SDI/MDI/대화상자 앱, Windows 10/11, x64/Unicode  
> 표기: 코드 블록은 모두 ```로 감쌉니다.  
> 용어: Code Point(코드포인트), Grapheme Cluster(사용자 인식 문자), Glyph(글리프)

---

## 0) 로드맵

1) **문자·폰트 기초**: UTF-16, 코드포인트/서로게이트, 글리프 vs 글자, 폰트 메트릭  
2) **측정/그리기(GDI/GDI+)**: 폭 측정, 줄바꿈, 말줄임, 탭, 자간/커닝  
3) **국제화 핵심**: 조합문자·이모지, East Asian Width, Bidi, 줄나눔 규칙(UAX #14), 하이픈/말줄임  
4) **셰이핑(Uniscribe/DirectWrite)**: 아랍·힌디어 등 복잡 스크립트 렌더  
5) **폰트 선택/대체**: 폰트 링크, 폴백, 컬러 이모지  
6) **품질/성능**: ClearType, 힌팅, DPI, 인쇄, 캐싱  
7) **IME/입력**: 조합 상태 렌더, 커서/선택의 올바른 정의  
8) **통합 예제**: GDI+/DirectWrite로 국제 텍스트 렌더 컴포넌트 만들기

---

# 1) 문자와 폰트의 기초

## 1-1. Windows의 유니코드: UTF-16LE
- **`wchar_t`/`TCHAR`(유니코드 빌드)**는 UTF-16 코드 유닛(16비트)입니다.
- **BMP 밖(code point > U+FFFF)** 문자는 **서로게이트 페어**(high+low) 2유닛으로 표현됩니다. (예: 많은 이모지)
- **한 “글자”**(사용자 눈에 보이는 단위) = **Grapheme Cluster** = 코드포인트 1개일 수도, **여러 개**의 조합일 수도.

```cpp
// U+1F600 😀 (smiling face): UTF-16에서는 2 code units
std::wstring s = L"\U0001F600"; // C++11: \Uxxxxxxxx 표기
```

## 1-2. 글자·글리프·클러스터
- **Code Point**: 유니코드 번호
- **Grapheme Cluster**: 사용자 기준 “한 글자”(예: “가”, “🇰🇷”, “â”(a + COMBINING CIRCUMFLEX))
- **Glyph**: 폰트가 그리는 “그림”. 1코드포인트→여러 글리프 또는 여러 코드포인트→1글리프(합자) 가능

## 1-3. 폰트 메트릭(라인 높이의 근거)
- **em**: 폰트 설계 단위(보통 2048upm 등)
- **Ascent/Descent/LineGap**: 라인 박스 계산의 핵심
- **External Leading**: GDI의 전통 메트릭(폰트에 따라 0)
- 한 줄 높이 추정: `TextHeight ≈ Ascent + Descent + LineGap`

```cpp
// GDI: 텍스트 메트릭
TEXTMETRIC tm{};
GetTextMetrics(hdc, &tm);
// tm.tmAscent, tm.tmDescent, tm.tmExternalLeading 등
int lineHeight = tm.tmHeight + tm.tmExternalLeading; // 전통적 계산
```

> **DirectWrite**는 더 정밀한 메트릭 제공(폰트 디자인 값 기반).

---

# 2) GDI/GDI+로 측정·그리기 (기본기 다지기)

## 2-1. GDI: 기본 그리기/측정

```cpp
void DrawBasic(HDC hdc, const wchar_t* text) {
    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, RGB(30,30,30));
    TextOut(hdc, 10, 10, text, lstrlenW(text));  // 그리기

    SIZE sz{};
    GetTextExtentPoint32W(hdc, text, lstrlenW(text), &sz); // 폭 측정
    Rectangle(hdc, 10, 40, 10 + sz.cx, 60);
}
```

### 2-1-1. GDI에서의 한계
- GDI는 **복잡 셰이핑(Arabic/Indic)**을 자동 처리하지 못합니다.  
- `ExtTextOutW`로 일부 조정 가능하지만, 복잡 스크립트/이모지/조합문자/커닝/합자에 한계 → **Uniscribe/DirectWrite** 필요.

## 2-2. GDI+: 텍스트 안티앨리어싱/폭 측정

```cpp
void DrawGDIPlus(HDC hdc, const wchar_t* text) {
    Gdiplus::Graphics g(hdc);
    g.SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

    Gdiplus::FontFamily ff(L"Segoe UI");
    Gdiplus::Font font(&ff, 14.0f, FontStyleRegular, UnitPoint);
    Gdiplus::SolidBrush br(Color(255,30,30,30));

    g.DrawString(text, -1, &font, Gdiplus::PointF(10,10), &br);

    // 폭/높이 측정
    Gdiplus::RectF b;
    g.MeasureString(text, -1, &font, Gdiplus::PointF(0,0), &b);
    // b.Width, b.Height 사용
}
```

> GDI+는 **안티앨리어싱**과 **간단한 국제 텍스트**에 유리하지만, **완전한 셰이핑 엔진은 아님**.  
> 복잡 스크립트/Bidi 레이아웃/폰트 폴백은 **DirectWrite**가 더 강력합니다.

## 2-3. 말줄임/줄바꿈(GDI)

```cpp
RECT rc = {10,10,320,100};
DrawTextW(hdc, L"긴 문장을 말줄임으로…", -1, &rc, DT_LEFT|DT_WORDBREAK|DT_END_ELLIPSIS);
```

- `DT_WORDBREAK`: 단어 단위 줄바꿈
- `DT_END_ELLIPSIS`: 말줄임(…)
- 주의: GDI의 줄나눔은 **UAX #14(유니코드 줄바꿈 규칙)**를 완전하게 따르지 않습니다.

---

# 3) 국제 텍스트 핵심 쟁점

## 3-1. 서로게이트/조합문자/그래프 클러스터
- 커서 이동·백스페이스·선택 범위는 **code unit** 단위가 아니라 **grapheme cluster** 단위로 다뤄야 합니다.
- 예: `A`+`COMBINING ACUTE`(U+0301)는 **두 code units**지만 사용자 입장에선 **한 글자**.

### 3-1-1. 클러스터 탐색(간단 전략)
- 빠른 길: **DirectWrite**의 `IDWriteTextLayout`가 클러스터 경계를 제공합니다.
- GDI만 쓸 때: Uniscribe의 **`ScriptBreak`**를 사용해 클러스터/줄나눔 경계 파악.

## 3-2. East Asian Width(전각/반각, 폭 2/1/가변)
- CJK 문자는 **전각(2칸)** 개념이 있고, ASCII는 반각(1칸).
- 모노스페이스 UI, 그리드 정렬 시 **East Asian Width** 고려(전각/반각 혼재 줄 정렬 이슈).
- 한글 “가” 등은 **폰트에 따라 폭이 균등/가변**. UI 요구사항에 따라 폰트/측정 방식 선택.

## 3-3. 줄나눔 규칙(UAX #14)와 하이픈/말줄임
- 단순 공백 분리로는 **CJK/태국어** 등에서 오동작.
- **DirectWrite**는 언어별 라인브레이킹을 제공.  
- 하이픈: 가능한 경우 **soft hyphen(U+00AD)**, 또는 localized hyphenation 패턴(별도 라이브러리 필요).

## 3-4. Bidi(아랍어/히브리어 + 라틴 혼합)
- 입력 순서(로그컬 오더) ↔ 표시 순서(비주얼 오더)가 다릅니다.
- Bidi 레벨 계산/글리프 순서 재배치는 **Uniscribe**/ **DirectWrite**에 맡기세요.
- 마크: RLE/LRE/RLM/LRM/… 제어 문자로 방향 힌트 가능(필요 시만).

---

# 4) 셰이핑(복잡 스크립트) — Uniscribe vs DirectWrite

## 4-1. Uniscribe(전통 API, 유연성 높음)

**흐름**: `ScriptItemize` → `ScriptShape` → `ScriptPlace` → `ScriptTextOut`

```cpp
#include <usp10.h>
#pragma comment(lib, "usp10.lib")

void DrawArabic(HDC hdc, const std::wstring& text, HFONT hFont, int x, int y) {
    SCRIPT_CONTROL sc{}; SCRIPT_STATE st{};
    int cItems = 0; std::vector<SCRIPT_ITEM> items(text.size()+1);
    ScriptItemize(text.c_str(), (int)text.size(), (int)items.size(), &sc, &st, items.data(), &cItems);

    HGDIOBJ old = SelectObject(hdc, hFont);

    for (int i=0; i<cItems; ++i) {
        int iCharPos = items[i].iCharPos;
        int iNext    = items[i+1].iCharPos;
        int runLen   = iNext - iCharPos;

        SCRIPT_CACHE scache = nullptr;
        std::vector<WORD> glyphs(runLen * 1.5 + 16);
        std::vector<WORD> clusters(runLen);
        std::vector<SCRIPT_VISATTR> vis(runLen);
        int glyphCount = 0;

        ScriptShape(hdc, &scache, text.c_str() + iCharPos, runLen,
                    (int)glyphs.size(), &items[i].a, glyphs.data(), clusters.data(), vis.data(), &glyphCount);

        std::vector<int> advance(glyphCount);
        std::vector<GOFFSET> goff(glyphCount);
        ABC abc;
        ScriptPlace(hdc, &scache, glyphs.data(), glyphCount, vis.data(), &items[i].a, advance.data(), goff.data(), &abc);

        SCRIPT_STRING_ANALYSIS ssa = nullptr;
        // 보통은 ScriptTextOut 사용
        int xRun = x;
        ScriptTextOut(hdc, &scache, xRun, y, ETO_CLIPPED, nullptr, &items[i].a,
                      nullptr, 0, glyphs.data(), glyphCount, advance.data(), nullptr, goff.data());
        x += std::accumulate(advance.begin(), advance.end(), 0);
        if (scache) ScriptFreeCache(&scache);
    }

    SelectObject(hdc, old);
}
```

> 장점: GDI와 맞물려 세밀 제어, 레거시 환경 호환  
> 단점: 코드가 길고, 국제화/Bidi/폴백/폰트 선택을 직접 관리해야 함

## 4-2. DirectWrite(권장) — 고급 레이아웃/폴백/국제화 일체 처리

```cpp
#include <dwrite.h>
#pragma comment(lib, "dwrite.lib")

// 공장 초기화(앱 1회)
ComPtr<IDWriteFactory> g_dwf;
DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), (IUnknown**)&g_dwf);

// 텍스트 레이아웃 생성/그리기
void DrawDWrite(HDC hdc, const wchar_t* text, float w, float h) {
    ComPtr<IDWriteTextFormat> fmt;
    g_dwf->CreateTextFormat(
        L"Segoe UI", nullptr, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL,
        DWRITE_FONT_STRETCH_NORMAL, 14.0f, L"ko-kr", &fmt);

    fmt->SetWordWrapping(DWRITE_WORD_WRAPPING_WRAP);
    fmt->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
    fmt->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);

    ComPtr<IDWriteTextLayout> layout;
    g_dwf->CreateTextLayout(text, (UINT32)wcslen(text), fmt.Get(), w, h, &layout);

    // GDI 인터페이스로 렌더
    ComPtr<IDWriteGdiInterop> gi;
    g_dwf->GetGdiInterop(&gi);

    HDC h = hdc;
    // DWrite 전용 렌더러를 작성하거나, DW DrawingContext 사용(간단 예시는 생략)
    // 실무에서는 Direct2D + IDWriteTextLayout::Draw 사용 권장
}
```

> **실전**: **Direct2D 렌더 타깃** + `IDWriteTextLayout::Draw()`가 가장 간결/강력합니다.  
> MFC 앱에서도 D2D/DWrite를 혼합 사용하는 것이 표준입니다.

---

# 5) 폰트 선택/대체/링킹/이모지

## 5-1. 폰트 폴백과 링크
- Windows는 폰트가 특정 코드포인트를 **미지원**하면 **대체 폰트**를 찾습니다(폰트 링크/폴백).
- GDI는 제한적으로, **DirectWrite는 자동/정교**하게 처리.
- 한 줄 내에 여러 폰트가 혼합될 수 있으니 **색/기하학 일관성** 유의.

## 5-2. 컬러 이모지
- 기능: COLR/CPAL(OpenType 벡터 계층), CBDT/CBLC(bitmap), SVG-in-OpenType  
- Windows 10+에서 **Segoe UI Emoji** 폰트로 컬러 이모지 지원(DirectWrite 추천).  
- GDI/GDI+에서는 컬러 이모지 폴백이 제한적/흑백 글리프로 보일 수 있음.

---

# 6) 품질/성능/인쇄/DPI

## 6-1. ClearType/힌팅
- **ClearType**: LCD 서브픽셀 기반 텍스트 선명화. `CLEARTYPE_QUALITY`(GDI), `TextRenderingHintClearTypeGridFit`(GDI+), DirectWrite는 기본 품질 우수.
- 작은 사이즈 UI 텍스트는 **UI 시스템 폰트(예: Segoe UI)** 사용 추천.

```cpp
LOGFONT lf{}; wcscpy_s(lf.lfFaceName, L"Segoe UI"); lf.lfHeight = -MulDiv(14, GetDpiForWindow(hWnd), 72);
HFONT hFont = CreateFontIndirect(&lf);
SetBkMode(hdc, TRANSPARENT);
SetBkColor(hdc, RGB(255,255,255));
SetTextColor(hdc, RGB(30,30,30));
// ClearType: 시스템 설정 의존. GDI로는 SetBkMode/폰트 품질이 영향.
```

## 6-2. DPI/고해상도
- 폰트 픽셀 높이는 **DPI 반영**해야 동일한 pt 크기 실현.
- DirectWrite는 로컬 DPI를 고려해 레이아웃 계산.

```cpp
int dpi = GetDpiForWindow(hWnd);
int px = MulDiv(12, dpi, 72); // 12pt → px
```

## 6-3. 인쇄
- 인쇄 DC는 DPI가 **수백~수천**. 텍스트는 포인트 단위로 지정하면 자연스러움(DirectWrite/프린터 레이아웃 권장).
- GDI 인쇄는 맵핑 모드/폰트 변환을 주의.

---

# 7) 줄바꿈/말줄임/정렬/탭/커닝

## 7-1. 말줄임(…”)
- **GDI**: `DrawTextW(..., DT_END_ELLIPSIS)`  
- **DirectWrite**: `DWRITE_TRIMMING_GRANULARITY_CHARACTER/WORD` + `SetTrimming` + `SetLineSpacing`

```cpp
// DirectWrite trimming
DWRITE_TRIMMING trim{};
trim.granularity = DWRITE_TRIMMING_GRANULARITY_CHARACTER;
ComPtr<IDWriteInlineObject> ellipsis; // 기본 또는 커스텀
fmt->SetTrimming(&trim, ellipsis.Get());
```

## 7-2. 탭/탭스톱
- GDI `DrawText`는 탭 해석 제한. 직접 **탭 폭 계산** 후 열 정렬 또는 RichEdit 사용.
- DirectWrite `TextLayout`은 탭스톱/단락 서식 확장 가능(커스텀 형식 엔진 필요 시 DWrite+RichEdit 조합 추천).

## 7-3. 커닝/리거처(OpenType)
- GDI: `GetKerningPairs` + `ExtTextOut`의 DX 배열로 수동 적용 가능하지만 비용 큼.
- DirectWrite: **자동**(폰트 기능/스크립트에 따라).

---

# 8) IME/입력: 조합 문자열과 커서

- 조합 중(한글/중국어/일본어/태국어 등)에는 **확정 전 문자열**이 별도 렌더되어야 함.
- **WM_IME_COMPOSITION** / **ImmGetCompositionStringW**로 조합 목표/문자열 취득 → **시각적 별도 강조**.
- 커서/선택 이동은 **grapheme cluster** 기준. DirectWrite `HitTestTextPosition/Point`로 정확한 히트테스트 가능.

```cpp
// IME 조합 문자열 받기(개요)
LRESULT OnImeComposition(WPARAM wParam, LPARAM lParam) {
    HIMC hIMC = ImmGetContext(hWnd);
    LONG len = ImmGetCompositionStringW(hIMC, GCS_COMPSTR, nullptr, 0);
    std::wstring comp; comp.resize(len/2);
    ImmGetCompositionStringW(hIMC, GCS_COMPSTR, comp.data(), len);

    // caret/underline 등 별도 렌더
    ImmReleaseContext(hWnd, hIMC);
    Invalidate();
    return 0;
}
```

---

# 9) 예제 모음

## 9-1. GDI+로 국제 텍스트(간단 렌더)

```cpp
void DrawIntl_GDIPlus(HDC hdc, const std::wstring& s) {
    using namespace Gdiplus;
    Graphics g(hdc);
    g.SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

    FontFamily ff(L"Segoe UI");
    Font font(&ff, 14.0f, FontStyleRegular, UnitPoint);
    SolidBrush br(Color(255,30,30,30));

    RectF rc(10, 10, 480, 160);
    StringFormat fmt;
    fmt.SetAlignment(StringAlignmentNear);
    fmt.SetLineAlignment(StringAlignmentNear);
    fmt.SetTrimming(StringTrimmingEllipsisCharacter);
    fmt.SetFormatFlags(StringFormatFlagsLineLimit); // 박스 끝에서 줄 제한

    g.DrawString(s.c_str(), -1, &font, rc, &fmt, &br);
}
```

> **복잡 스크립트**가 섞이면 일부 폰트/엔진 제약으로 모양이 충분히 예쁘지 않을 수 있습니다. **DirectWrite**가 더 낫습니다.

## 9-2. DirectWrite 텍스트 레이아웃(권장)

```cpp
struct DWriteCtx {
    ComPtr<IDWriteFactory> factory;
    ComPtr<IDWriteTextFormat> fmt;
    DWriteCtx() {
        DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), (IUnknown**)&factory);
        factory->CreateTextFormat(
            L"Segoe UI", nullptr, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL,
            DWRITE_FONT_STRETCH_NORMAL, 14.0f, L"ko-kr", &fmt);
        fmt->SetWordWrapping(DWRITE_WORD_WRAPPING_WRAP);
        fmt->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
        fmt->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
    }
    void Draw(HDC hdc, const std::wstring& s, float w, float h) {
        ComPtr<IDWriteTextLayout> layout;
        factory->CreateTextLayout(s.c_str(), (UINT32)s.size(), fmt.Get(), w, h, &layout);

        // Direct2D 없이 GDI로 그리려면 전용 렌더러 필요(간단화를 위해 D2D 생략).
        // 실무에서는 ID2D1RenderTarget + layout->Draw()를 사용하세요.
    }
};
```

## 9-3. Uniscribe로 아랍어 셰이핑(요약)

```cpp
// 위 4-1 참조: ScriptItemize → ScriptShape → ScriptPlace → ScriptTextOut
```

---

# 10) 폰트 고급: OpenType 기능/기본선/밑줄/취소선

- OpenType의 **기능 태그**(liga, kern, hlig, ss01…)는 DirectWrite에서 선택적 제어 가능(고급 API).
- 기본선/밑줄/취소선 위치는 폰트 메트릭에서 제공(DirectWrite `GetMetrics`, `GetUnderlineMetrics` 등).

---

# 11) 텍스트 편집기 구현 포인트

1. **커서/선택**: grapheme cluster 단위(DirectWrite `HitTest` API 활용)  
2. **라인 레이아웃**: `TextLayout`로 줄나눔/폭 측정/말줄임  
3. **IME 조합**: 조합 문자열을 별도 스타일(밑줄/박스)로 오버레이  
4. **스크롤**: 더티 영역만 무효화/더블 버퍼  
5. **Bidi**: 논리 인덱스↔비주얼 인덱스 매핑 제공 API 사용  
6. **탭/고정폭**: 탭스톱 계산 또는 RichEdit 컨트롤 위임

---

# 12) 성능/안정성 체크리스트

- **캐시**: 폰트/텍스트 레이아웃 재사용, 이미지처럼 텍스트 런별 캐시  
- **품질 토글**: 확대/미세 요소에서만 HighQuality, 나머지는 Balanced  
- **DPI**: 창 DPI 변경(`WM_DPICHANGED`) 대응 → 폰트/레이아웃 재계산  
- **폴백 확인**: 다국어 문자열 테스트(한글/영문/아랍/이모지/조합)  
- **인쇄/프리뷰**: DirectWrite + 고DPI 타깃  
- **스레드**: 렌더는 UI 스레드, 레이아웃은 워커 스레드에서 미리 계산 가능(주의 깊게 동기화)

---

# 13) 문제 해결 가이드

| 증상 | 원인 | 해결 |
|---|---|---|
| 이모지가 네모(□)로 보임 | 폰트 미지원 | **DirectWrite 폴백** 또는 Segoe UI Emoji 사용 |
| 아랍/힌디어 모양이 틀림 | 셰이핑 미수행 | **Uniscribe/DirectWrite** 사용 |
| 말줄임 위치가 어색 | 줄나눔 규칙 미고려 | DirectWrite 트리밍/줄나눔 사용 |
| 커서가 조합문자를 쪼갬 | code unit 단위 처리 | **클러스터 단위** 이동(DirectWrite HitTest) |
| CJK 정렬이 들쭉날쭉 | East Asian Width/폰트 가변폭 | 고정폭 CJK폰트/탭스톱 기반 레이아웃 |
| DPI에서 텍스트 크기 불일치 | px 계산 고정 | pt→px 변환에 **DPI 반영** |
| 프린트에서 흐림 | 저해상도 타깃 | 인쇄 DC DPI 기반 폰트/레이아웃 |

---

# 14) 통합 샘플: DirectWrite 텍스트 뷰(말줄임·Bidi·이모지 OK)

```cpp
// 간단한 DirectWrite 기반 텍스트 박스(그리기만, D2D 생략 버전)
// 실전에서는 D2D RenderTarget + layout->Draw() 사용 권장

#include <dwrite.h>
#pragma comment(lib, "dwrite.lib")

class DWriteTextBox {
    ComPtr<IDWriteFactory>      m_fac;
    ComPtr<IDWriteTextFormat>   m_fmt;
    ComPtr<IDWriteTextLayout>   m_layout;
    std::wstring                m_text;
    float m_w=0, m_h=0;

public:
    DWriteTextBox() {
        DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), (IUnknown**)&m_fac);
        m_fac->CreateTextFormat(L"Segoe UI", nullptr,
            DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            14.0f, L"", &m_fmt);
        m_fmt->SetWordWrapping(DWRITE_WORD_WRAPPING_WRAP);
        m_fmt->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
        m_fmt->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
        // 말줄임
        DWRITE_TRIMMING t{}; t.granularity = DWRITE_TRIMMING_GRANULARITY_CHARACTER;
        ComPtr<IDWriteInlineObject> ellipsis;
        m_fac->CreateEllipsisTrimmingSign(m_fmt.Get(), &ellipsis);
        m_fmt->SetTrimming(&t, ellipsis.Get());
    }

    void SetText(std::wstring s) { m_text = std::move(s); m_layout.Reset(); }
    void SetSize(float w, float h) { m_w=w; m_h=h; m_layout.Reset(); }

    void EnsureLayout() {
        if (!m_layout) {
            m_fac->CreateTextLayout(m_text.c_str(), (UINT32)m_text.size(), m_fmt.Get(), m_w, m_h, &m_layout);
        }
    }

    // 여기서는 GDI로 배경/외곽만, 텍스트는 별도 렌더러 필요. 실무는 D2D를 쓰세요.
    void Draw(HDC hdc, int x, int y) {
        EnsureLayout();
        // 배경
        HBRUSH bg = CreateSolidBrush(RGB(255,255,255));
        RECT rc = {x,y, x+(int)m_w, y+(int)m_h};
        FillRect(hdc, &rc, bg); DeleteObject(bg);
        FrameRect(hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
        // 텍스트 그리기는 Direct2D/전용 렌더러 필요(지면 절약상 생략)
        // -> 샘플의 목적은 레이아웃만 보여주기
    }
};
```

---

## 마무리

- 텍스트는 **단순 “문자 배열”이 아니라 레이아웃 엔진의 결과**입니다.  
- **유니코드·grapheme cluster·줄나눔 규칙·Bidi·셰이핑**을 **엔진(DirectWrite/Uniscribe)**에 맡기고,  
  우리는 **폰트 선택/폴백·DPI·품질·캐싱**에 집중하면 안정적입니다.  
- 새 구현이라면 **DirectWrite(＋Direct2D)**로 가세요.  
  레거시 유지라면 GDI/GDI+ + Uniscribe로 보완하되, 국제화 요구가 크면 점진적으로 DWrite로 이관하는 전략을 추천합니다.
