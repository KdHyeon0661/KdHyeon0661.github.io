---
layout: post
title: 디자인패턴 - 생성 패턴
date: 2025-06-09 21:20:23 +0900
category: 디자인패턴
---
# 생성 패턴(Creational Patterns)

## 개요

**생성 패턴(Creational Patterns)**은 **객체 생성 방식과 책임을 추상화**하여, 생성 시점, 방법, 의존, 표현을 유연하게 만든다. 핵심은 “**클라이언트가 구체 클래스에 덜 의존**하도록” 만들고, “**생성 로직을 적절한 위치에 캡슐화**”하는 것이다.

**해결하려는 대표 문제**
- 생성 분기가 코드 곳곳에 흩어져 변경이 어렵다.
- 생성자가 복잡(매개변수 폭발, 순서 의존, 필수/선택 혼재).
- 런타임 조건(OS/환경/설정)에 따라 다른 타입이 필요.
- 테스트에서 구체 타입 결합 때문에 목/스텁 주입이 어렵다.

---

### 핵심 목표(요약 유지 + 보강)

- 생성 로직 캡슐화로 **중복 제거·응집도 상승**
- **결합도 감소**(구체 타입 → 추상 계약)
- **생성 시점/방법의 유연성 확보**(지연 로딩, 제품군 전환, 단계적 조립)
- **테스트 가능성 향상**(대체 용이)

---

### 대표적인 생성 패턴(원문 표 유지 + 간단 설명)

| 패턴 이름            | 설명 |
|---------------------|------|
| **Singleton**        | 하나의 인스턴스만 존재하도록 보장 |
| **Factory Method**   | 서브클래스가 객체 생성 방식을 결정 |
| **Abstract Factory** | 관련 객체의 집합(제품군)을 생성 |
| **Builder**          | 객체를 단계적으로 생성 |
| **Prototype**        | 기존 객체를 복제하여 생성 |

---

## 공통 냄새와 리팩토링 출발선

### 냄새(Signs)

- “큰 생성자”와 **옵션 폭발**: `new Report(a,b,c,d,e,f,g)`
- **거대한 switch/if-else**로 타입 선택이 퍼져 있음
- **복잡한 초기화 순서**가 여러 곳에서 재현
- **테스트에서 대체 어려움**: 구체 클래스 직결

### 리팩토링 가이드(매핑)

- **거대한 생성 분기** → Factory Method / Abstract Factory
- **생성 단계/옵션 복잡** → Builder
- **템플릿 복제/스냅샷** → Prototype
- **진짜 단일성 필요** → Singleton(그러나 남용 금지; DI/IoC 고려)

---

## Singleton — “유일 인스턴스” 보장

### 의도·문제 맥락

전역적으로 하나만 있어야 하는 관리 객체(설정, 로깅, 자원 레지스트리 등).

### 구조(UML)

```
┌─────────────────────┐
│     Singleton       │
├─────────────────────┤
│ - instance: static  │
├─────────────────────┤
│ + getInstance()     │
└─────────────────────┘
```

### Python(지연 로딩 + DCL)

```python
import threading

class Singleton:
    _inst = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._inst is None:
            with cls._lock:
                if cls._inst is None:
                    cls._inst = super().__new__(cls)
                    # 1회 초기화
        return cls._inst
```

### `Lazy<T>`

```csharp
public sealed class AppConfig
{
    private static readonly Lazy<AppConfig> _inst = new(() => new AppConfig());
    public static AppConfig Instance => _inst.Value;
    private AppConfig() { }
}
```

### 자바(정적 홀더 / enum)

```java
public class Config {
  private Config() {}
  private static class Holder { static final Config I = new Config(); }
  public static Config getInstance() { return Holder.I; }
}
// enum Singleton도 견고(직렬화/리플렉션 방어)
```

### 테스트/주의

- 전역 상태 누수 → **Provider/인터페이스로 한 단계 감싸서** 테스트에서 교체
- 멀티프로세스(컨테이너) 환경: “프로세스별 싱글턴”임
- DB “연결 자체”를 싱글턴으로 두지 말 것(풀 관리자를 싱글턴으로)

---

## Factory Method — “하위가 생성 책임”

### 의도·문제 맥락

**생성 분기**를 상위 골격에서 감추고 **하위 타입이 제품 생성**을 결정.

### 구조(그림)

```
        ┌──────────────────────┐
        │   Creator (추상)     │
        ├──────────────────────┤
        │ + factoryMethod()    │◄──── 확장 지점
        │ + operation()        │    (공통 흐름)
        └──────────────────────┘
                ▲
                │
 ┌──────────────────────┐
 │ ConcreteCreatorA     │ → ProductA
 └──────────────────────┘
 ┌──────────────────────┐
 │ ConcreteCreatorB     │ → ProductB
 └──────────────────────┘
```

### Python 예시(GUI 버튼)

```python
class Button:
    def render(self): raise NotImplementedError

class WinButton(Button):
    def render(self): print("Windows Button")

class MacButton(Button):
    def render(self): print("Mac Button")

class Dialog:
    def create_button(self) -> Button: raise NotImplementedError
    def render_window(self):
        btn = self.create_button()   # 생성 책임 위임
        btn.render()                 # 공통 골격

class WinDialog(Dialog):
    def create_button(self) -> Button: return WinButton()

class MacDialog(Dialog):
    def create_button(self) -> Button: return MacButton()
```

### C# 예시(전송 클라이언트)

```csharp
public interface IClient { Task SendAsync(string s); }

public class HttpClientX : IClient {
    public Task SendAsync(string s) => Task.CompletedTask;
}
public class GrpcClientX : IClient {
    public Task SendAsync(string s) => Task.CompletedTask;
}

public abstract class ClientCreator {
    public abstract IClient Create();        // 확장 포인트
    public async Task RunAsync(string msg) { // 공통 골격
        var c = Create();
        await c.SendAsync(msg);
    }
}

public class HttpCreator : ClientCreator {
    public override IClient Create() => new HttpClientX();
}
public class GrpcCreator : ClientCreator {
    public override IClient Create() => new GrpcClientX();
}
```

### 변형/팁

- 등록(Registry) 기반: 키→생성자 매핑(플러그인)
- DI/IoC와 결합: “**선택**은 팩토리, **조립**은 컨테이너”
- 과도한 추상화 금지: 단순 생성은 정적 팩토리/직접 생성이 명료

---

## Abstract Factory — “제품군 일관 생성”

### 의도·문제 맥락

관련된 **제품군(세트)**을 **일관된 테마**로 생성해야 할 때.

### 구조(그림)

```
AbstractFactory
 ├─ createButton(): Button
 └─ createTextbox(): Textbox
   ▲
   │
ConcreteFactoryDark/Light
 ├─ DarkButton / DarkTextbox
 └─ LightButton / LightTextbox
```

### C# 예시(위젯 테마)

```csharp
public interface IButton { void Draw(); }
public interface ITextbox { void Draw(); }

public interface IWidgetFactory {
    IButton CreateButton();
    ITextbox CreateTextbox();
}

public class DarkFactory : IWidgetFactory {
    public IButton CreateButton() => new DarkButton();
    public ITextbox CreateTextbox() => new DarkTextbox();
}
public class LightFactory : IWidgetFactory {
    public IButton CreateButton() => new LightButton();
    public ITextbox CreateTextbox() => new LightTextbox();
}
```

### 팁/주의

- “세트” 일관성이 핵심. 단일 축 다양화면 **Factory Method**가 더 단순.
- DI와 함께: 환경/설정에 따라 **팩토리 자체를 주입**.

---

## Builder — “복잡 생성의 단계 분리”

### 의도·문제 맥락

필수/선택 옵션이 많고, **생성 순서/검증**이 중요한 복잡 객체.

### 구조(그림)

```
Director → Builder(interface) → ConcreteBuilder → Product
```

### Python 예시(SQL 쿼리 조립)

```python
class SqlBuilder:
    def __init__(self): self._parts = []
    def select(self, cols): self._parts.append(f"SELECT {', '.join(cols)}"); return self
    def from_(self, table): self._parts.append(f"FROM {table}"); return self
    def where(self, cond): self._parts.append(f"WHERE {cond}"); return self
    def order(self, col): self._parts.append(f"ORDER BY {col}"); return self
    def build(self): return " ".join(self._parts)

sql = SqlBuilder().select(["id","name"]).from_("users").where("age>=18").order("name").build()
```

### C# 예시(HTTP 요청 조립)

```csharp
public class Request {
    public string Method { get; init; }
    public Uri Url { get; init; }
    public Dictionary<string,string> Headers { get; } = new();
    public string Body { get; init; }
}

public class RequestBuilder {
    private readonly Request _r = new();
    public RequestBuilder Method(string m){ _r.Method = m; return this; }
    public RequestBuilder Url(string u){ _r.Url = new Uri(u); return this; }
    public RequestBuilder Header(string k,string v){ _r.Headers[k]=v; return this; }
    public RequestBuilder Body(string b){ _r.Body=b; return this; }
    public Request Build() {
        if (string.IsNullOrEmpty(_r.Method)) throw new InvalidOperationException("Method?");
        if (_r.Url is null) throw new InvalidOperationException("Url?");
        return _r;
    }
}
```

### 수식(옵션 조합 수)

선택 가능한 독립 옵션의 개수가 \(k\)개일 때 가능한 조합 수는
$$ 2^k $$
(단, 상호 배타/의존 제약이 있으면 제약식에 따라 감소).

### 주의

- 과한 Fluent는 흐름 추적이 어렵다 → **검증 시점 명확화**
- 불변 객체(Immutable Product)에 적합

---

## Prototype — “복제로 빠른 생성”

### 의도·문제 맥락

생성 비용이 큰 객체(깊은 트리/그래프)나 **런타임에 타입을 확정**해야 하는 경우.

### 구조(그림)

```
Client → Prototype.clone() → New Object
```

### Python 예시(깊은 복제)

```python
import copy

class Node:
    def __init__(self, text, children=None):
        self.text = text
        self.children = children or []
    def clone(self):  # 깊은 복제
        return copy.deepcopy(self)

root = Node("root", [Node("a"), Node("b")])
copy1 = root.clone()
```

### Java 예시(`Cloneable` 주의)

```java
class Doc implements Cloneable {
  String title;
  List<String> tags = new ArrayList<>();
  @Override protected Doc clone() {
    try {
      Doc d = (Doc) super.clone();
      d.tags = new ArrayList<>(this.tags); // 깊은 복제 일부
      return d;
    } catch (CloneNotSupportedException e) { throw new AssertionError(e); }
  }
}
```

### 주의

- 얕은/깊은 복사 경계 명확히(식별자, 핸들, 캐시 키)
- 그래프 순환 시 **방문 집합** 필요
- **팩토리와 혼용**: 프로토타입 레지스트리(키→원본) + `.clone()`

---

## 패턴 간 비교/선정 가이드

### 빠른 선택 표

| 요구/상황 | 권장 |
|---|---|
| 단일 인스턴스 보장 | Singleton(가능하면 DI 싱글턴 수명) |
| 생성 분기 캡슐화(단일 축) | Factory Method |
| 관련 제품군 일관 생성 | Abstract Factory |
| 옵션/단계 복잡, 검증 필요 | Builder |
| 템플릿에서 빠르게 복제 | Prototype |

### 관계/조합

- Factory Method ↔ Abstract Factory: **단일 축 vs 세트**
- Builder ↔ Prototype: 초기 템플릿을 **복제 후 커스터마이즈**
- Singleton ↔ Abstract Factory: “**전역 팩토리**” 자체를 싱글턴으로(남용 주의)

---

## DI/IoC와 생성 패턴

- **조립 문제**는 컨테이너가, **선택 문제**는 팩토리가 담당하는 것이 이상적.
- ASP.NET Core 예: `AddSingleton<TService, TImpl>()`로 **수명 관리**, 팩토리에서 **환경/키**로 구현 선택.
- 추상 팩토리 자체를 **컨테이너에서 주입**하면 테스트 교체가 쉽다.

---

## 테스트 전략(패턴 공통 관점)

- **Factory/Abstract Factory**: 계약 테스트(새 구현 추가 시 공통 테스트 재사용)
- **Builder**: 필수/선택 검증, 빌더로 생성한 결과의 **불변/일관성** 체크
- **Prototype**: 원본 ≠ 복제(참조 동일성 금지), 깊은/얕은 복제 경계
- **Singleton**: 테스트 간 **상태 누수 방지**(Provider/Reset 훅, 프로세스 격리)

---

## 실전 리팩토링 예(스텝 바이 스텝)

### 거대한 switch 제거 → Factory Method

나쁜 예:
```csharp
IClient Make(string scheme) {
  switch (scheme) {
    case "http": return new HttpClientX();
    case "grpc": return new GrpcClientX();
    default: throw new NotSupportedException();
  }
}
```
개선 절차
1) `ClientCreator` 추상화 + `Create()` 도입
2) `HttpCreator`/`GrpcCreator` 구현
3) 클라이언트는 `ClientCreator`만 의존(주입/선택은 외부로)

### 생성자 폭발 → Builder

나쁜 예:
```java
new Report(a,b,c,d,e,f,g,h) // 의미 불명, 순서 의존
```
개선:
```java
Report r = Report.builder().title("...").author("...").includeCharts(true).build();
```

### 템플릿 복제 → Prototype

- 대형 객체를 표준 템플릿으로 보관(레지스트리) → `.clone()` → 부분 변경.

---

## 패턴별 추가 예제(요청 잦은 도메인)

### Abstract Factory(데이터베이스 제품군)

```
IDbFactory
 ├─ createConnection(): IConnection
 └─ createCommand(): ICommand
Concrete: MySqlFactory / PgFactory / SqliteFactory
```
```csharp
public interface IDbFactory {
    IConnection Conn();
    ICommand Cmd();
}
```
- 테스트에서는 **InMemoryFactory**로 교체.

### Builder(REST 클라이언트)

```python
class RestBuilder:
    def __init__(self): self._h={}, self._qs={}
    def header(self,k,v): self._h[k]=v; return self
    def query(self,k,v): self._qs[k]=v; return self
    def build(self): return {"headers":self._h, "query":self._qs}
```

### Prototype(게임 오브젝트)

- 몬스터 베이스를 프로토타입으로 등록 → 스테이지별로 복제 후 수치 조정.

---

## 안티패턴/주의

- **Singleton 남용**: 전역 상태가 많아질수록 테스트/이해/동시성 악화
- **과도한 추상화**: 단순한 곳에 Factory/Abstract Factory를 강행
- **Builder 남용**: 간단 생성에 Fluent 체인이 가독성만 해친다
- **Prototype 함정**: 깊은 복제 누락, 식별자/락/핸들 복제 금지

---

## 성능/동시성/수명

- **지연 로딩**: 초기 지연 vs 첫 호출 지연 비용 트레이드오프
- **풀링**: 객체 재사용(주의: 상태 초기화/누수/동기화 비용)
- **불변(Immutable) 제품**: Builder/Prototype과 궁합, 동시성에 유리

---

## 패턴 종합 비교표(확장판)

| 항목 | Singleton | Factory Method | Abstract Factory | Builder | Prototype |
|---|---|---|---|---|---|
| 주 해결 문제 | 유일성 | 생성 분기 캡슐화 | 제품군 일관 | 단계적 조립 | 복제 기반 생성 |
| 결합도 영향 | 전역 접근점 ↑ | 구체→추상 | 제품군 인터페이스 | 생성자 의존 감소 | 원본 계약 의존 |
| 유연성 | 낮음 | 중 | 중~높음 | 높음 | 중 |
| 테스트 난이도 | 높음 | 낮음 | 중 | 낮음 | 중 |
| DI/IoC | 수명으로 대체 | 선택과 조립 분리 | 팩토리 주입 | 빌더 주입 | 프로토타입 레지스트리 |
| 대표 위험 | 전역 상태 | 과추상화 | 인터페이스 폭증 | Fluent 남용 | 복제 오류 |

---

## 연습 과제(스켈레톤 제공)

### 이미지 인코더(Factory Method + 등록)

```python
class Encoder:
    def encode(self, b, **opt): raise NotImplementedError

class Jpeg(Encoder): ...
class Png(Encoder): ...

class EncoderFactory:
    _map={}
    @classmethod
    def register(cls,k,ctor): cls._map[k]=ctor
    @classmethod
    def create(cls,k,**opt): return cls._map[k](**opt)

# 등록

EncoderFactory.register("jpeg", Jpeg)
EncoderFactory.register("png", Png)
enc = EncoderFactory.create("jpeg")
```

### 보고서 Builder

```csharp
public class Report {
  public string Title { get; init; }
  public string Author { get; init; }
  public bool WithCharts { get; init; }
  public class Builder {
    private readonly Report _r = new();
    public Builder Title(string v){ _r.Title=v; return this; }
    public Builder Author(string v){ _r.Author=v; return this; }
    public Builder WithCharts(bool v){ _r.WithCharts=v; return this; }
    public Report Build(){
      if (string.IsNullOrWhiteSpace(_r.Title)) throw new InvalidOperationException();
      return _r;
    }
  }
}
```

### 프로토타입 레지스트리

```python
class ProtoReg:
    _store={}
    @classmethod
    def add(cls,k,obj): cls._store[k]=obj
    @classmethod
    def clone(cls,k):
        import copy
        return copy.deepcopy(cls._store[k])
```

---

## 체크리스트(최종)

- **정말** 싱글턴이 필요한가? (수명/테스트/멀티프로세스 고려)
- 생성 분기가 흩어졌는가? → Factory Method/Abstract Factory
- 생성 단계/옵션이 복잡한가? → Builder
- 템플릿 복제가 자연스러운가? → Prototype
- DI/IoC와 **역할 분담**이 명확한가(선택 vs 조립)?
- 테스트 더블/목을 **쉽게 주입**할 수 있는가?

---

## 결론

생성 패턴은 “무엇을 만들 것인가”뿐 아니라 “**어디서/언제/어떻게** 만들 것인가”를 구조적으로 통제한다. **현재의 단순성**을 우선하되, **합리적인 변화**를 매끄럽게 수용하도록 추상화 수준을 선택하라. 과용하지 말고, **냄새가 보일 때 정확히** 적용하라. 그러면 프레임워크/플러그인/엔터프라이즈 코드에서 유지보수성과 테스트 가능성이 비약적으로 상승한다.
