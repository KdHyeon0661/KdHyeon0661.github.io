---
layout: post
title: 컴퓨터시스템 - 시스템 성능의 본질
date: 2025-07-16 18:20:23 +0900
category: 컴퓨터시스템
---
# 시스템 성능의 본질: Amdahl의 법칙, 동시성과 병렬성

많은 개발자와 시스템 설계자들이 성능 향상을 위해 **병렬 처리** 또는 **멀티스레딩**을 고민한다. 하지만 이러한 접근이 항상 성능을 선형적으로 향상시켜주지는 않는다. 그 이유는 바로 **Amdahl의 법칙**과 **동시성과 병렬성의 차이**에 있다.

---

## 1. Amdahl의 법칙이란?

Amdahl의 법칙(Amdahl's Law)은 **전체 시스템 중 일부만 병렬화할 수 있을 때, 전체 성능 향상의 한계**를 수학적으로 설명한다. 이 법칙은 다음과 같이 표현된다:

\[
S(N) = \frac{1}{(1 - P) + \frac{P}{N}}
\]

- \( S(N) \): 병렬화된 작업을 \( N \)개의 처리 장치로 수행할 때의 **속도 향상 배율**
- \( P \): 전체 작업 중 **병렬화 가능한 부분의 비율**
- \( N \): 병렬로 처리하는 **프로세서 또는 스레드 수**
- \( 1 - P \): 병렬화 불가능한 **직렬 처리 영역**

### 📌 핵심 메시지:
아무리 많은 프로세서를 사용해도, **직렬 구간이 존재하면 속도 향상에는 한계가 있다.**

---

## 2. Amdahl의 법칙 예제

어떤 프로그램의 80%가 병렬화 가능하고, 나머지 20%는 직렬 처리만 가능하다고 가정해보자. 이때 병렬 프로세서 수에 따른 속도 향상을 계산해보면 다음과 같다:

| 프로세서 수 \( N \) | 속도 향상 \( S(N) \) |
|--------------------|--------------------|
| 1                  | \( \frac{1}{1} = 1 \) (기준) |
| 2                  | \( \frac{1}{0.2 + 0.8/2} = 1.67 \) |
| 4                  | \( \frac{1}{0.2 + 0.8/4} = 2.5 \) |
| 8                  | \( \frac{1}{0.2 + 0.8/8} = 3.33 \) |
| 16                 | \( \frac{1}{0.2 + 0.8/16} \approx 4.0 \) |
| ∞                  | \( \frac{1}{0.2 + 0} = 5 \) (이론적 최대) |

### 🎯 결론:
- 병렬 구간이 아무리 많아도, 직렬 구간(20%)이 존재하면 **속도 향상은 최대 5배**를 넘을 수 없다.
- **직렬 코드 제거가 병렬화보다 더 큰 성능 향상을 줄 수도 있다.**

---

## 3. 동시성과 병렬성의 차이

많은 사람들이 **동시성(concurrency)**과 **병렬성(parallelism)**을 같은 의미로 사용하지만, 실제로는 명확히 다르다.

| 구분 | 동시성 (Concurrency) | 병렬성 (Parallelism) |
|------|----------------------|----------------------|
| 정의 | 여러 작업을 **교차 처리** | 여러 작업을 **동시에 실행** |
| 실행 수단 | **단일 CPU**에서도 가능 (문맥 전환) | **다중 CPU/코어** 필요 |
| 예시 | 웹 서버가 수많은 클라이언트 요청을 처리 | 행렬 계산을 다수의 코어로 나누어 병렬 수행 |
| 목표 | **응답성(responsiveness)** 개선 | **처리량(throughput)** 향상 |

### 📌 비유:
- 동시성: 한 사람이 여러 사람과 번갈아 대화하는 것
- 병렬성: 여러 사람이 동시에 각자 다른 사람과 대화하는 것

---

## 4. 실제 코드 예시로 보기

```c
// 병렬성: OpenMP로 루프 병렬 처리
#pragma omp parallel for
for (int i = 0; i < N; ++i) {
    A[i] = compute(i);
}

// 동시성: 멀티스레드 웹 서버 구조
while (true) {
    int client = accept(sock);
    std::thread(handle_request, client).detach();
}
```

- 첫 번째 예는 계산을 병렬화하여 **처리 속도를 높이는 병렬성**
- 두 번째 예는 클라이언트 요청을 동시에 처리하여 **응답 지연을 줄이는 동시성**

---

## 5. 동시성과 병렬성을 결합한 시스템 설계

실제 시스템은 다음과 같이 **동시성과 병렬성을 조합**해 설계된다:

- CPU는 멀티코어 → 병렬성
- 각 코어는 멀티스레딩 지원 → 동시성
- 운영체제는 컨텍스트 스위칭 → 동시성
- 고성능 서버는 스레드 + 병렬 연산 → 둘 다 사용

---

## 마무리

시스템의 성능을 향상시키기 위해서는 단순히 병렬 처리 기술을 사용하는 것을 넘어서, 다음을 함께 고려해야 한다:

1. **직렬 구간 제거**: Amdahl의 법칙에 따라 병목이 된다
2. **병렬성 vs 동시성의 목표**를 명확히 이해
3. **작업 분할의 적절성**과 **오버헤드 최소화**까지 고려

시스템을 빠르게 만든다는 것은 곧, **똑똑하게 나누고**, **최대한 동시에 실행하며**, **병목을 제거하는 것**이다.
