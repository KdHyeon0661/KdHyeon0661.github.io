---
layout: post
title: 운영체제 - 가상머신 (3)
date: 2025-11-02 20:25:23 +0900
category: 운영체제
---
# Chapter 18 — Virtual Machines (3)
## Examples

### KVM/QEMU: 표준형 하이퍼바이저 스택

**구성도(개념)**
```
[HW: x86/ARM] ─ [리눅스 커널: KVM 모듈 + vhost-*] ─ [QEMU: 디바이스 모델]
                                                 └─[libvirt: 관리/오케스트레이션]
```

**핵심 포인트**
- KVM이 VM-Exit/Entry, EPT/NPT 등 **CPU/메모리 가상화의 핵심**을 담당.
- QEMU가 **디바이스 모델**(virtio-net/blk 등)과 이미지/스냅샷을 다룸.
- vhost-net/scsi 등 커널 fast-path로 **문맥 전환**을 줄임.

**실습 A — cloud 이미지로 즉석 VM 만들기**
```bash
# 베이스 디스크 만들기

qemu-img create -f qcow2 /var/lib/libvirt/images/vm.qcow2 20G

# 클라우드 이미지(예: ubuntu cloud image)를 'base.qcow2'로 보관했다고 가정

qemu-img create -f qcow2 -b base.qcow2 /var/lib/libvirt/images/vm.qcow2

# cloud-init user-data 준비

cat > user-data <<'YAML'
#cloud-config

users:
  - name: dev
    groups: sudo
    shell: /bin/bash
    ssh_authorized_keys:
      - ssh-ed25519 AAAA... dev@laptop
package_update: true
packages: [htop, git]
YAML
cloud-localds seed.iso user-data

# QEMU 실행 (KVM + virtio + 호스트 포워딩)

qemu-system-x86_64 -enable-kvm -m 4096 -smp 4 -cpu host \
  -drive if=virtio,file=/var/lib/libvirt/images/vm.qcow2,format=qcow2,cache=none,aio=native \
  -drive file=seed.iso,if=virtio,format=raw \
  -netdev user,id=n0,hostfwd=tcp::2222-:22 -device virtio-net-pci,netdev=n0 \
  -nographic
# 호스트에서: ssh -p 2222 dev@127.0.0.1

```

**실습 B — 라이브 마이그레이션(공유 스토리지 가정)**
```bash
# 소스 호스트 QMP/HMP에서:

(qemu) migrate tcp:10.0.0.12:4444
(qemu) info migrate  # 진행률, 더티율 확인
```

**튜닝 체크리스트**
- `-cpu host`로 **호스트 기능 패스스루**(마이그레이션 계획 시는 CPUID 마스킹).
- 네트워크 **멀티큐** + `vhost-net`, 블록 I/O는 `cache=none` + `aio=native`.
- **HugePages**(호스트/게스트)로 TLB 미스 감소.

---

### Xen: 도메인 모델(dom0/domU)

**요점**
- Type-1 구조. **dom0** 가 관리/드라이버, **domU** 는 게스트.
- **PV/PVH/HVM** 모드(현대는 대개 HVM 혹은 PVH).

**domU 기동 예(개념)**
```ini
# /etc/xen/vm.cfg

name = "u18"
memory = 4096
vcpus  = 2
disk   = [ 'phy:/dev/mapper/vg/u18,xvda,w' ]
vif    = [ 'bridge=xenbr0,model=virtio-net' ]
bootloader = "pygrub"
```
```bash
xl create /etc/xen/vm.cfg
xl console u18
```

---

### Hyper-V: 파워셸로 VM 배포

```powershell
# 가상 스위치 생성

New-VMSwitch -Name "vSwitch" -SwitchType External -NetAdapterName "Ethernet"

# VM 생성(Gen2, Secure Boot on)

New-VM -Name "hv-demo" -MemoryStartupBytes 4GB -Generation 2 -VHDPath "C:\VMs\hv-demo.vhdx" -SwitchName "vSwitch"
Set-VMFirmware -VMName "hv-demo" -EnableSecureBoot On
Set-VMDvdDrive -VMName "hv-demo" -Path "C:\ISO\installer.iso"
Start-VM "hv-demo"
```

**팁**
- **Integration Services**/Guest Services 활성화로 시간/메모리/종료 이벤트 동기화.
- **Dynamic Memory**(최소/최대)로 밀도↑.

---

### VMware ESXi: 스냅샷/마이그레이션

**개념**
- vSphere 스택(vCenter, vMotion, DRS/HA)로 **운영 자동화**.
- 스토리지: VMFS/NFS, Storage vMotion.

**esxcli 예(개념)**
```bash
# NTP/네트워크/스토리지 등 호스트 레벨 표준 설정은 esxcli로 자동화 가능

esxcli network nic list
esxcli software vib list
```

---

### macOS: Hypervisor.framework(HVF) 이용

- QEMU는 macOS에서 `-accel hvf`로 하드웨어 가속을 사용.
```bash
qemu-system-x86_64 -accel hvf -m 4096 -smp 4 -drive file=vm.qcow2,if=virtio
```

---

### MicroVM: Firecracker

**특징**
- 장치 모델 최소화(virtio-net/blk), REST API로 정의/부팅.
- **부팅 수백 ms~초** → 서버리스/함수형 워크로드에 적합.

**REST 예**
```bash
# 커널/루트FS/CPU/메모리 정의

curl --unix-socket /tmp/fc.socket -i \
 -X PUT 'http://localhost/machine-config' \
 -H 'Accept: application/json' \
 -H 'Content-Type: application/json' \
 -d '{ "vcpu_count": 2, "mem_size_mib": 1024 }'

curl --unix-socket /tmp/fc.socket -i \
 -X PUT 'http://localhost/boot-source' \
 -H 'Content-Type: application/json' \
 -d '{ "kernel_image_path": "/kernels/vmlinux",
       "boot_args": "console=ttyS0 reboot=k panic=1 pci=off" }'

curl --unix-socket /tmp/fc.socket -i \
 -X PUT 'http://localhost/drives/rootfs' \
 -H 'Content-Type: application/json' \
 -d '{ "drive_id": "rootfs", "path_on_host": "/images/rootfs.ext4",
       "is_root_device": true, "is_read_only": false }'

curl --unix-socket /tmp/fc.socket -i \
 -X PUT 'http://localhost/actions' \
 -H 'Content-Type: application/json' \
 -d '{ "action_type": "InstanceStart" }'
```

---

### WASM/WASI: 프로세스 VM로서의 샌드박스

```bash
# wasmtime로 preopen 디렉터리(능력) 부여

wasmtime run --dir=/data app.wasm
```

프로그램은 **주입된 디렉터리 능력** 밖을 볼 수 없음 → **OCAP** 스타일 보호와 잘 맞는다.

---

### SR-IOV NIC & VFIO 패스스루

**NIC SR-IOV 활성화(개념)**
```bash
echo 4 | sudo tee /sys/class/net/eth0/device/sriov_numvfs  # VF 4개 생성
ip link set eth0 vf 0 mac 52:54:00:12:34:56 vlan 100 trust on
```

**VF를 게스트에 패스스루(libvirt XML)**
```xml
<hostdev mode='subsystem' type='pci' managed='yes'>
  <source>
    <address domain='0x0000' bus='0x3b' slot='0x10' function='0x2'/>
  </source>
</hostdev>
```

---

### vTPM + Secure Boot (libvirt)

```xml
<tpm model='tpm-crb'>
  <backend type='emulator' version='2.0'/>
</tpm>
<os>
  <type arch='x86_64' machine='q35'>hvm</type>
  <loader readonly='yes' type='pflash'>/usr/share/OVMF/OVMF_CODE.secboot.fd</loader>
  <nvram>/var/lib/libvirt/qemu/nvram/vm_VARS.fd</nvram>
</os>
```

---

### eBPF/bpftrace로 KVM 관측

```bash
# kvm_exit 이유 카운터(개념)

sudo bpftrace -e '
kprobe:kvm_handle_exit { @cnt[probe] = count(); }
tracepoint:kvm:kvm_exit { @reason[args->exit_reason] = count(); }'
```

**해석 포인트**
- `EPT/NPT violation` ↑ → 게스트 메모리 액세스 패턴/SLAT 미스.
- `IO`/`MSR` ↑ → 디바이스/하이퍼콜 경로 최적화 필요.

---

## Virtualization Research

> “현대 가상화 연구”의 축: **안전성(Confidentiality/Integrity), 고성능 I/O, 초저지연 부팅, 운영/관측성, 이식성/경량화, 형식 검증**.

### Confidential VMs (CVM): 메모리 암호화 & 원격 검증

- **개념**: 하이퍼바이저/호스트가 **게스트 메모리 내용을 볼 수 없도록** 암호화/무결성 보호 + **원격 측정(Attestation)** 으로 신뢰 부팅 증빙.
- **예**: (개념) **게스트 ⇄ 플랫폼 보안 모듈**(칩/펌웨어)
  $$\text{Quote} = \mathrm{Sign}_{\mathrm{HW}}(\text{Measurement} \,\|\, \text{Nonce})$$
  원격 검증자는 Quote를 검증하고 **정책**에 따라 비밀을 전달할지 결정.

**연구 과제**
- 페이지 공유(KSM)/라이브 마이그레이션과 **암호화 무결성**의 공존.
- **I/O 경로 보호**(vTPM, 가상 디바이스 무결성, DMA 보호).
- **디버깅/관측성**과 **프라이버시**의 균형.

---

### 초고속 부팅: MicroVM 스냅샷/리스토어

- **목표**: 서버리스/배치에서 **대기시간≈0**에 가깝게.
- **기술**: **메모리 스냅샷 + CPU/장치 상태**를 보존하고, 부팅 대신 **재개(resume)**.
- **공식(개념)**: 총 cold start 지연
  $$T_{\text{cold}} \approx T_{\text{boot}} + T_{\text{prov}}$$
  스냅샷 시는
  $$T_{\text{snap}} \approx T_{\text{load(snapshot)}} + T_{\text{attach}} \ll T_{\text{boot}}$$

**연구**: 스냅샷 **델타 압축**, 공유 페이지 **COW**, **계층 스냅샷**으로 이미지 캐시 히트율 극대화.

---

### 라이브 마이그레이션 고도화

- **Post-Copy**: 즉시 전환 후 **페이지 폴트**로 원격 당김(네트워크 안정성 요구).
- **RDMA 기반** 전송/압축/우선순위 스케줄링.
- **Dirty-ring**/UFFD(유저 공간 페이지 폴트)와의 결합.

```python
# post_copy_skeleton.py — 개념 스케치

def post_copy(vm):
    vm.freeze(); switch_dst(); vm.thaw()
    while vm.page_faults():
        pf = vm.next_fault()
        fetch_from_src(pf.addr)
```

연구 초점: **SLA 지연**과 **컨버전스 시간**을 수학적으로 예측/제어.

---

### vDPA / 사용자 공간 가상 I/O 스택

- **아이디어**: virtio 규격은 유지하면서, 데이터 경로를 **커널/가속기/DPDK** 로 이동.
- 사용자 공간 **vhost-user**(SPDK vhost-blk/-scsi), **vDPA** 기반 NIC 오프로드.

```bash
# QEMU에서 vhost-user-blk(개념)

-chardev socket,id=char0,path=/var/run/vhostblk.sock \
-device vhost-user-blk-pci,chardev=char0,num-queues=4
```

연구 포인트: **zero-copy**/폴 모드 → **레이턴시/CPU 사용률** 최적화, **멀티큐 스케일링**.

---

### 스케줄링 연구: 이중 스케줄러 & 스핀락 문제

- 문제: **Lock-holder preemption**으로 지연 폭발.
- 해결: **co-scheduling**, **PV-spinlock**, **tickless**, **스케줄러 힌트**.

**간단 모델**
$$
E[\text{latency}] \approx \frac{p \cdot T_q}{1 - \rho}
$$
- \(p\): preempt 확률, \(T_q\): 큐 대기, \(\rho\): 호스트 부하율
→ \(p\)와 \(\rho\) 를 낮추는 **핀닝/NUMA 배치**가 효과적.

---

### 메모리 연구: Balloon, Hinting, 압축, 대페이지

- **free-page reporting**: 게스트가 안 쓰는 페이지를 **즉시 호스트에 힌트**.
- **zswap/zram** vs **balloon** 상호작용 분석.
- **HugePages/THP** 일관성 → 마이그레이션/스냅샷과의 트레이드오프.

---

### 스토리지: 멀티큐/DPDK/저장 계층 분리

- **blk-mq**(리눅스), **virtio-blk multiqueue**, **NVMe-virtio**.
- 사용자 공간 **SPDK vhost**로 **폴 모드**/**zero-copy**.

**실험 흐름(개념)**
1) vhost-user-blk 구성
2) VM에서 fio: `--ioengine=libaio --numjobs=4 --iodepth=64`
3) 큐/IRQ affinity 튜닝 → 선형 확장 관찰

---

### GPU 가상화: mdev/SR-IOV/타임 슬라이싱

- **mdev**(mediated pass-through): 물리 GPU를 가상 기능으로 분할.
- **SR-IOV GPU**: 최신 GPU의 하드웨어 가상화.
- 연구 주제: **그래픽/쿠다** 혼합 워크로드 QoS, **메모리 격리**와 **스케줄링 공정성**.

---

### 형식 검증/안전 언어 하이퍼바이저

- **TCB 축소** + **형식 검증된 커널/하이퍼바이저**(소형, 엄격 사양).
- **Rust VMM**(Cloud-Hypervisor 등): **메모리 안전**으로 취약면 줄이기.
- 연구: **property-based testing**, **모델 체크**, **SFI/CFI** 결합.

---

### VM Introspection(VMI) & 보안 가시성

- 하이퍼바이저가 **게스트 내부 상태**(프로세스/커널 구조체)를 관찰.
- 악성코드 은닉 탐지/포렌식/정책 집행.

```python
# (개념) LibVMI 스타일: 프로세스 리스트 스캔 의사코드

def list_tasks(vmi):
    init = vmi.read_symbol("init_task")
    cur  = init
    seen=set()
    while cur not in seen:
        seen.add(cur)
        comm = vmi.read_str(cur + OFFSET_TASK_COMM)
        print(comm)
        cur = vmi.read_ptr(cur + OFFSET_TASK_NEXT)
```

연구 포인트: **무침습/고정밀**과 성능의 균형, **암호화 VM** 시대의 대안(정책 게이트/에이전트).

---

### Record/Replay & Time-Travel Debugging

- **결정적 실행**을 위해 **입력/인터럽트/시간**을 기록 → **재현성 디버깅**.
- 과제: 오버헤드 최소화, I/O 동기화, 멀티코어 순서 결정.

---

### 엣지/서버리스/멀티테넌시

- **MicroVM + 컨테이너** 이중 경계로 멀티테넌시 강화.
- **콜드스타트 제로화**를 위한 **프리-웜업 스냅샷 풀**.

---

### 분해(Disaggregation)/CXL 시대

- **메모리/가속기 분해**: CXL/PCIe fabric 위에서 **원격 메모리/장치**를 투명 가상화.
- 연구: **지연 모델링**, **페이지 캐싱/프리페치**, **보안 도메인** 분할.

---

## 종합 실습: “저지연 API용 MicroVM 팜”

**요구**
- 200ms 이내 기동, p99 레이턴시 안정, 멀티테넌시 보안.

**설계**
1) **Firecracker** 기반 MicroVM.
2) **스냅샷 풀** 사전 로드(버전별).
3) NIC는 **vhost-net** 혹은 SR-IOV VF.
4) 관측: eBPF로 **kvm_exit**, **vhost-net** 대기, **softirq** 지표 수집.
5) 보안: **vTPM**(비밀 배포), IOMMU on, 정책 거리두기.

**스냅샷 워크플로(의사코드)**
```python
# snapshot_pool.py

pool = load_snapshots(["api-v1.snap","api-v2.snap"])
def serve(req):
    vm = pool.checkout(version=req.hdr["x-api-version"])
    vm.attach_net(vf=req.vf)
    vm.resume()
    return vm.invoke(req)
```

---

## 요약

- **18.7 Examples**: KVM/QEMU, Xen, Hyper-V, ESXi, Firecracker, WASM/WASI, SR-IOV/VFIO, vTPM, bpftrace 관측까지 **운영 가능한 예제** 중심 정리.
- **18.8 Research**: **Confidential VMs**, 초고속 스냅샷/리스토어, vDPA/사용자공간 I/O, 이중 스케줄링, 메모리 힌팅/압축, 멀티큐 스토리지, GPU 가상화, 형식 검증, VMI, 레코드/리플레이, 분해형 자원, CXL—지금과 가까운 미래의 **핵심 연구 축**.

> 실전 팁: “**기본 거부**(IOMMU/보안 부팅/최신 virtio) → **최소권한**(SR-IOV는 도메인 격리로, 파일은 virtio-fs 권한 최소화) → **관측성**(eBPF/QMP) → **재현성**(스냅샷/템플릿)”의 순으로 운영을 설계하라.
