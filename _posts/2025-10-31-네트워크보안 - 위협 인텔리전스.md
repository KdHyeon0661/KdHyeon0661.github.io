---
layout: post
title: 네트워크보안 - 위협 인텔리전스
date: 2025-10-31 21:25:23 +0900
category: 네트워크보안
---
# 26. 위협 인텔리전스 (Threat Intelligence)

> 목표
> - **MISP/STIX/TAXII** 핵심 개념과 실무 연동(수집·가공·배포) 흐름을 이해한다.
> - **내부 텔레메트리(프록시/DNS/Email/EDR/NetFlow/CloudTrail)**를 **운영 가능한 인텔**로 전환하는 가공 규칙을 설계한다.
> - **피드 품질**을 정량 평가(커버리지·정확도·시의성·컨텍스트)하고, **오탐 관리**(억제/감쇠/익스플레인)를 체계화한다.
> - **실습**: IoC→SIEM 배포 파이프라인(정규화→중복 제거→스코어링→룰/피드 생성→배포→백테스트→억제)을 코드로 구성한다.

---

## 26.1 MISP/STIX/TAXII

### 26.1.1 용어·배경
- **MISP (Malware Information Sharing Platform)**: 커뮤니티/조직 간 **사건(Event) 중심**의 IoC 공유 플랫폼. TLP/Confidence/Tag/Galaxy(ATT&CK 등)로 풍부한 컨텍스트 첨부.
- **STIX 2.1**: 인텔 표준 스키마. **Indicator/Observed Data/Attack Pattern/Malware/Campaign/Relationship** 등 **객체 간 그래프** 모델링.
- **TAXII 2.1**: STIX 번들을 **컬렉션 단위**로 제공하는 **API 프로토콜**(Pull/Pagination/Filter).

### 26.1.2 MISP 이벤트→STIX 변환(개념)
```
[MISP Event(#123)]
  ├─ Attribute: domain=evil.example (type=domain)
  ├─ Attribute: ip=203.0.113.10 (type=ip-dst)
  ├─ Attribute: sha256=... (type=malware-sample)
  └─ Tag: tlp:amber, galaxy=ATT&CK T1059

→ STIX 2.1 Bundle
  ├─ indicator(domain)      id: indicator--...
  ├─ indicator(ip)          id: indicator--...
  ├─ indicator(sha256)      id: indicator--...
  ├─ malware                id: malware--...
  ├─ attack-pattern(T1059)  id: attack-pattern--...
  └─ relationship(indicator → malware), (malware → attack-pattern)
```

### 26.1.3 STIX 2.1 인디케이터 예시
```json
{
  "type": "bundle",
  "id": "bundle--e8f0...",
  "objects": [
    {
      "type": "indicator",
      "spec_version": "2.1",
      "id": "indicator--b3fc...",
      "created": "2025-10-31T10:00:00Z",
      "modified": "2025-10-31T10:00:00Z",
      "name": "C2 domain seen in phishing",
      "description": "Observed in Oct 2025 campaign; relates T1059",
      "pattern": "[domain-name:value = 'evil.example']",
      "pattern_type": "stix",
      "valid_from": "2025-10-31T10:00:00Z",
      "confidence": 70,
      "labels": ["malicious-activity", "c2"],
      "external_references": [{ "source_name":"case", "url":"https://ti.corp/case/123" }]
    },
    {
      "type":"indicator",
      "id":"indicator--c7a1...",
      "pattern":"[ipv4-addr:value = '203.0.113.10']",
      "pattern_type":"stix",
      "valid_from":"2025-10-31T10:00:00Z",
      "confidence":60,
      "labels":["c2"]
    }
  ]
}
```

### 26.1.4 TAXII 2.1 Pull(개념 cURL)
```bash
# 컬렉션 나열
curl -s -H "Authorization: Bearer $TOKEN" \
  https://taxii.example.org/taxii2/ | jq

# 특정 컬렉션에서 STIX 번들 페이지 단위 가져오기
curl -s -H "Authorization: Bearer $TOKEN" \
  "https://taxii.example.org/taxii2/collections/abc123/objects?added_after=2025-10-30T00:00:00Z&limit=500"
```

### 26.1.5 STIX Pattern → 엔진 변환 개론
- `domain-name:value = 'evil.example'` → **프록시/DNS 룰**(정확히 일치, 와일드카드 병행)
- `url:value MATCHES '^https?://.*/login\.php\?r=.*$'` → **프록시 L7 룰/시그마/정규식**
- `file:hashes.'SHA-256' = '...'` → **EDR/AV/FS 룰**
- `network-traffic:dst_port = 4444 AND ipv4-addr:value = 'x.x.x.x'` → **NIDS 룰**

---

## 26.2 내부 텔레메트리→운영 가능한 인텔

### 26.2.1 “원천 로그” 분류
- **네트워크**: 프록시(HTTP/SNI), DNS, NetFlow/IPFIX, 방화벽, NIDS(Suricata/Zeek)
- **엔드포인트**: EDR, Sysmon, Windows Event, Linux Auditd
- **이메일**: SMTP/DMARC/정책 엔진
- **클라우드**: CloudTrail, GCS/Azure Activity, WAF, LB
- **IDP/SSO**: 로그인/위험 점수/디바이스 포스처

### 26.2.2 정규화 스키마(ECS 유사 예)
```json
{
  "ts":"2025-10-31T12:00:00Z",
  "event":{"category":"network","type":"connection"},
  "source":{"ip":"10.0.0.5","port":51514},
  "destination":{"ip":"203.0.113.10","port":443,"domain":"evil.example"},
  "http":{"host":"evil.example","url":"/login.php?r=...","user_agent":"..."},
  "tls":{"sni":"evil.example","ja3":"..."},
  "user":{"id":"a@corp"},
  "device":{"managed":true}
}
```

### 26.2.3 가공 규칙(“운영 가능”의 기준)
1) **정규화**: 필드 공통화(ECS), 시간·타임존 통일
2) **컨텍스트 결합**:
   - **자산 DB**(관리/비관리, 중요도, 소유 부서),
   - **아이덴티티**(역할/그룹/위험 점수),
   - **위협 맵**(ATT&CK TTP, 캠페인, 태그)
3) **우선순위 산정**(Score): IoC 신뢰도, TLP, 최신성(Decay), 내부 관측 빈도/중요 자산 가중치
4) **결정 가능 액션**: **차단/격리/알림/티켓/추가 수집** 중 하나 이상 바로 실행 가능해야 “운영 가능”

### 26.2.4 스코어링 함수(샘플; 파이썬)
```python
from math import exp

def decay(days):  # 0~1, 0일=1, 30일~ 0.2 근사
    return max(0.2, exp(-days/20))

def ioc_score(confidence, tlp, days_old, seen_count, critical_asset):
    base = confidence/100  # 0~1
    tlp_w = {"red":0.9,"amber":1.0,"green":1.0,"white":1.0}.get(tlp,1.0)
    sight = min(1.0, 0.2 + 0.1*seen_count)
    asset = 1.2 if critical_asset else 1.0
    return round(100 * base * tlp_w * decay(days_old) * sight * asset, 1)

# 예: confidence=70, tlp=amber, 3일 경과, 관측 2회, 중요 자산
print(ioc_score(70,"amber",3,2,True))  # 70 * 1.0 * ~0.86 * 0.4 * 1.2 ≈ 29.0
```
- **Threshold** 예: `≥70` 차단 후보, `40~69` 알림/추가 수집, `<40` 관찰 리스트.

### 26.2.5 내부 Sightings → 피드백 루프
- IoC가 **내부 텔레메트리에서 관측**되면 `sighting` 기록
  - **양성**: 탐지→조사→침해 확인 시 **신뢰도↑**
  - **음성**: 정상 서비스/파트너로 확인 시 **억제 목록** 또는 **정책 예외** 추가
- **MISP Sightings API** 또는 내부 DB에 **타임라인·증거 링크** 저장

---

## 26.3 피드 품질 평가·오탐 관리

### 26.3.1 품질 축
1) **정확도(Precision)**: 오탐률↓(정상 FQDN 포함 여부)
2) **재현율(Recall) 프록시**: 내부 사건 커버 여부(백테스트)
3) **시의성(Freshness)**: 최근 캠페인 반영 속도/Decay
4) **컨텍스트(Enrichment)**: TTP/가족/캠페인/리스크 등 **설명 가능성**
5) **중복률/Dedup Quality**: 동일 IoC·서브도메인·동일 해시 중복 제거 능력

### 26.3.2 정량 평가(백테스트) 흐름
1) **히스토리컬 로그**(예: 30일)에서 **의심 이벤트** 수집
2) 각 피드 후보의 IoC를 적용해 **탐지 수/양성률/오탐률** 측정
3) **비용 지표**: 경보/티켓 처리 시간, 차단으로 인한 **업무 영향**(차단 해제 비율)

**간단 백테스트(파이썬; CSV 가정)**
```python
import csv

def load_indicators(path):  # domain list
    with open(path) as f: return {r["indicator"]:float(r["score"]) for r in csv.DictReader(f)}

def test(logs_csv, ind):
    hits=0; alerts=0
    with open(logs_csv) as f:
        for r in csv.DictReader(f):
            dom=r["http.host"]
            if dom in ind and ind[dom]>=70:
                hits+=1
                if r["label"]=="malicious": alerts+=1
    prec = (alerts/hits) if hits else 0.0
    return hits, alerts, prec

ind = load_indicators("ioc.csv")
hits, alerts, prec = test("web_logs.csv", ind)
print("hits:",hits,"TP:",alerts,"precision:",round(prec,3))
```

### 26.3.3 오탐 관리(억제/감쇠/설명)
- **억제(Suppression)**:
  - **허용 목록(Allowlist)**: 파트너/내부 자산/정상 CDNs
  - **상황 억제**: 근무시간 외 이벤트/테스트 환경 제외
  - **기간 억제**: 24~72시간 임시 억제(중복 알림 방지)
- **감쇠(Scoring Down)**:
  - **대형 도메인**(`*.googleusercontent.com` 등)에서 서브경로 IoC는 **스코어 감쇠**
  - **재현 불가**(며칠간 관측 0) → 자동 **Decay 증가**
- **설명 가능성(Explainability)**:
  - 경보에 **근거** 포함: 소스 피드/Confidence/최근 sighting/ATT&CK
  - **왜 차단/허용**했는지 대시보드에 표시 → 운영 신뢰도↑

**Sigma 예(설명 필드)**
```yaml
title: Suspicious C2 Domain Contact
status: experimental
logsource: {category: proxy}
detection:
  sel:
    http.host: evil.example
condition: sel
level: high
tags: [attack.t1059, threat.c2]
falsepositives: [ "Partner PoC during 2025-10-20 ~ 2025-10-22" ]
fields: [ event.original, user.id, source.ip, destination.domain ]
```

---

## 26.4 실습: IoC→SIEM 배포 파이프라인

### 26.4.1 목표·아키텍처
> **목표**: TAXII/MISP/CSV 등 **다양한 소스**의 IoC를 **정규화·중복 제거·스코어링** 후
> **SIEM 룰/피드**(Elastic KQL, Sigma, Suricata 룰, DNS Sinkhole)로 **자동 배포**하고,
> **백테스트/억제/롤백**까지 한 번에 관리한다.

```
[Sources]  →  [Collector] → [Normalizer] → [Deduper] → [Scoring] → [Outputs]
 (TAXII,       (pull)        (type/tag       (hashset,     (decay,     (Elastic KQL rules,
  MISP, CSV)                 normalize)      fqdn fold)     context)     Sigma, Suricata)
                                                ↓
                                            [Backtest] ↔ [Suppression] → [Deploy/Rollback]
```

### 26.4.2 샘플 데이터 모델（내부 중간 포맷）
```json
{
  "indicator": "evil.example",
  "type": "domain",
  "source": "taxii:abc",
  "first_seen": "2025-10-29T09:00:00Z",
  "last_seen":  "2025-10-31T07:00:00Z",
  "confidence": 70,
  "tlp": "amber",
  "tags": ["c2","phishing","attack.t1059"],
  "context": {"case":"123","campaign":"Oct-Phish"},
  "score": 0,          // 계산 후 채움
  "state": "candidate" // candidate/active/suppressed/retired
}
```

### 26.4.3 파이프라인 코드(축약 파이썬)

**(1) 수집 + 정규화**
```python
# collect_normalize.py
import json, sys, csv, re, datetime as dt
def norm_indicator(raw):
    i = raw.strip().lower()
    if raw.startswith("http"):
        from urllib.parse import urlparse
        i = urlparse(raw).hostname or i
    if re.match(r"^\d{1,3}(\.\d{1,3}){3}$", i): t="ip"
    elif re.match(r"^[a-f0-9]{64}$", i): t="sha256"
    else: t="domain"
    return i, t

def load_csv(path, source):
    out=[]
    with open(path) as f:
        for r in csv.DictReader(f):
            ind, t = norm_indicator(r["indicator"])
            out.append({
              "indicator":ind, "type":t, "source":source,
              "first_seen":r.get("first_seen") or dt.datetime.utcnow().isoformat()+"Z",
              "last_seen": r.get("last_seen")  or dt.datetime.utcnow().isoformat()+"Z",
              "confidence":int(r.get("confidence",60)), "tlp":r.get("tlp","amber"),
              "tags": [x.strip() for x in r.get("tags","").split(",") if x.strip()],
              "context": {"raw": r}
            })
    return out

print(json.dumps(load_csv("src_ioc.csv","csv:feed1")))
```

**(2) Dedup + FQDN Fold + Allowlist**
```python
# dedup_filter.py
import json, sys
allow = {"portal.partner.com","cdn.safe.example"}
seen = set(); res=[]
for item in json.load(sys.stdin):
    ind=item["indicator"]
    if ind in allow: continue
    key=(item["type"], ind)
    if key in seen: continue
    seen.add(key); res.append(item)
print(json.dumps(res))
```

**(3) 스코어링 + 상태 결정**
```python
# score_stage.py
import json, sys, datetime as dt
from math import exp

def decay(days): return max(0.2, exp(-days/20))
def days_old(ts):
    d = (dt.datetime.utcnow() - dt.datetime.fromisoformat(ts.replace("Z","+00:00"))).days
    return max(d,0)

buf=[]
for it in json.load(sys.stdin):
    d = days_old(it["last_seen"])
    base = it["confidence"]/100
    tlp_w = 1.0 if it["tlp"] in ("green","amber","white") else 0.8
    score = round(100*base*tlp_w*decay(d),1)
    it["score"]=score
    it["state"]="active" if score>=70 else ("observe" if score>=40 else "candidate")
    buf.append(it)
print(json.dumps(buf))
```

**(4) Outputs: Elastic KQL / Sigma / Suricata 룰 생성**
```python
# emit_rules.py
import json, sys
data=json.load(sys.stdin)
kql_rules=[]; sigma=[]; suri=[]
for it in data:
    if it["state"]!="active": continue
    ind=it["indicator"]; typ=it["type"]; tags=",".join(it["tags"])
    if typ=="domain":
        kql_rules.append({
          "title": f"TI Domain Hit: {ind}",
          "kql": f'url.domain: "{ind}" or dns.question.name: "{ind}"'
        })
        sigma.append({
          "title": f"TI Domain {ind}",
          "logsource":{"category":"proxy"},
          "detection":{"sel":{"http.host": ind},"condition":"sel"},
          "level":"high","tags":it["tags"]
        })
    elif typ=="ip":
        kql_rules.append({"title":f"TI IP {ind}","kql":f'destination.ip: "{ind}" or source.ip: "{ind}"'})
        suri.append(f'alert ip any any -> {ind} any (msg:"TI IP {ind}"; sid:1000001; rev:1;)')
    elif typ=="sha256":
        sigma.append({
          "title":f"TI Hash {ind}",
          "logsource":{"product":"windows","service":"sysmon"},
          "detection":{"sel":{"hashes|contains":ind},"condition":"sel"},
          "level":"high","tags":["file.hash","ti"]
        })
print(json.dumps({"kql":kql_rules,"sigma":sigma,"suricata":suri}, indent=2))
```

**(5) 배포(개념)**
- **Elastic**: Kibana API로 KQL 룰 업로드/활성화
- **Sigma→SIEM 변환**: `sigmac`(로컬)로 ES DSL/Splunk SPL 변환 후 API 배포
- **Suricata**: 룰 파일로 저장 후 `suricata-update`/`systemctl reload suricata`

```bash
# Suricata 룰 배포 예(개념)
python3 pipeline.py | jq -r '.suricata[]' > /etc/suricata/rules/ti.rules
suricata-update && systemctl reload suricata
```

### 26.4.4 백테스트 & 억제(자동)
**백테스트 스크립트(간단)**
```python
# backtest.py
import csv, json, sys
rules=json.load(sys.stdin)["kql"]   # 간소; 실제는 ES에 쿼리 수행
# 데모: 로컬 CSV에서 도메인 매칭
hits={}
with open("web_logs.csv") as f:
    for r in csv.DictReader(f):
        h=r["http.host"]
        for rule in rules:
            ind=rule["title"].split(":")[-1].strip()
            if h==ind:
                hits[ind]=hits.get(ind,0)+1
for k,v in hits.items():
    print("backtest_hit",k,v)
```

**억제 목록 자동 생성(조건 예)**
- **7일간 관측 0** + **대형 도메인 서브** → `suppressed`
- **파트너 도메인/ASN** 일치 → `allowlist`
- **과다 경보**이지만 내부 조사 결과 정상 → `suppress 72h`

억제 룰(JSON)
```json
[
  {"type":"domain","pattern":"*.cloudfront.net","action":"score_down","factor":0.5},
  {"type":"domain","pattern":"portal.partner.com","action":"allow"},
  {"type":"ip","pattern":"198.51.100.0/24","action":"suppress","ttl_hours":72}
]
```

### 26.4.5 운영 대시보드 지표(필수)
- **피드→룰 전환율**: 수집 수 대비 활성 룰 수
- **중복률**: 정규화 전/후 수
- **경보 품질**: 경보 수, 케이스 생성률, 양성(Confirmed) 비율
- **시의성**: IoC 발행→배포까지 평균 지연
- **억제 효과**: 억제 전/후 경보 감소율, 재발 경보율

### 26.4.6 롤백 & 변경관리
- 룰/피드 버전을 **Git**으로 관리(번들 ID/시점)
- 배포 실패/오탐 폭증 시 **이전 버전으로 즉시 롤백**
- **카나리 배포**: 일부 인덱스/티어만 활성→지표 정상 시 전체 확대

---

## 부록 A. SIEM 쿼리 스니펫

**Elastic KQL**
```kql
(url.domain: "evil.example" or dns.question.name: "evil.example")
and not source.ip: 10.0.0.0/8
```

**Splunk SPL**
```spl
index=proxy http_host="evil.example"
| stats count by src_ip, user, uri_path
```

**Zeek Notice → Elastic**
```kql
event.module: "zeek" and rule.name: "TI Domain evil.example"
```

## 부록 B. TIP 운영 체크리스트
- [ ] **TLP/콘피던스/수명(Expiration)** 필드 사용
- [ ] **도메인 정규화**: punycode, FQDN lower, dot-trim
- [ ] **URL 파편화 대응**: 쿼리 정규화/리스트
- [ ] **해시 타입 구분**: MD5/SH1/SH256, 파일크기·서명 메타 병행
- [ ] **ASN/Geo/CDN** 컨텍스트로 **감쇠/오탐 방지**
- [ ] **Sighting 루프** 활성화(내부 양성/음성 피드백)
- [ ] **백테스트** 자동화, 경계값 튜닝(A/B)
- [ ] **배포/롤백** 자동화(버전/카나리/헬스)

---

## 요약
- **MISP/STIX/TAXII**로 표준화된 **수집–가공–배포**를 구성하고, 내부 텔레메트리와 **컨텍스트 결합**으로 **운영 가능한 인텔**을 만든다.
- **스코어링(Confidence·TLP·Decay·Sighting)**과 **오탐 관리(억제·감쇠·설명)**가 품질을 좌우한다.
- **IoC→SIEM 파이프라인**은 정규화→Dedup→Score→룰 생성→배포→백테스트→억제/롤백의 **폐루프**로 설계하라.
- 모든 변경은 **지표 기반**으로 검증하고, **카나리·버전·롤백**이 가능한 **운영 자동화**를 유지하라.
