---
layout: post
title: 운영체제 - 가상머신 (2)
date: 2025-11-02 19:25:23 +0900
category: 운영체제
---
# Chapter 18 — Virtual Machines (2)

## 18.4 Building Blocks

가상화 스택은 **CPU/메모리/I/O/펌웨어/관리**의 다섯 축으로 나뉜다. 각각의 “블록”을 이해하면, 하이퍼바이저가 *무엇을 가짜로 보이게 만들고*, 게스트 OS가 *어떻게 속아준다* 를 정확히 파악할 수 있다.

### 18.4.1 CPU Virtualization

**핵심 아이디어**: 게스트 커널이 특권 명령을 실행하려 하면 **VM-Exit**(trap)으로 VMM(하이퍼바이저)이 가로채 **에뮬레이션** 후, 다시 **VM-Entry**로 게스트에 복귀한다.

- **HW 지원(현대 x86/ARM/RISC-V)**
  - x86: **VT-x**(VMCS, VM-Exit/Entry, EPT), AMD-V(VMCB, NPT)
  - ARM: **EL2**(HCR_EL2, Stage-2 MMU), GICv2/3 가상 인터럽트
  - RISC-V: **HS** 확장(2-stage 주소 변환)

- **컨트롤 데이터 구조**
  - x86 **VMCS**(VM Control Structure): 인터셉트 비트, MSR 맵, EPTP, APIC-v, TSC 스케일 등
  - AMD **VMCB**: 유사 기능

- **게스트→호스트 전환 사유(Exit Reason)**: CPUID, HLT, I/O, MSR, EPT/NPT violation, APIC access 등

- **시간 개념**: TSC 스케일링/오프셋, PV-clock(kvm-clock)
  - 지터를 줄이려면 **TSC 안정화**와 **PV-timer**가 중요

**개념 수식**: VM-Exit 비용을 $$C_e$$, VM-Entry 비용을 $$C_r$$, 에뮬레이션 비용을 $$C_m$$, 단위 시간당 Exit 빈도를 $$\lambda$$ 라 두면 총 오버헤드는
$$
\Delta \approx \lambda \cdot (C_e + C_m + C_r)
$$
→ **Para-virt**(hypercall)·**APICv**·**posted interrupt** 등으로 $$\lambda$$ 를 낮추는 것이 핵심.

---

### 18.4.2 Memory Virtualization

게스트의 **VA→(게스트)PA** 변환 뒤에, 하이퍼바이저는 **(게스트)PA→(호스트)PA**를 한 단계 더 수행한다.

- **Shadow Page Table(SPT)**: 게스트 PT를 추적해 **그림자 PT**를 동기화(초기 기법, 오버헤드↑)
- **SLAT**: x86 **EPT** / AMD **NPT** / ARM **Stage-2**
  $$\text{VA}_{guest} \xrightarrow{\text{guest PT}} \text{PA}_{guest} \xrightarrow{\text{EPT/NPT}} \text{PA}_{host}$$

- **KSM/Memory Sharing**: 완전히 동일한 페이지를 **공유**(Copy-on-Write)
- **Ballooning**: 게스트 드라이버가 **페이지를 “풍선”에 넣어** 하이퍼바이저로 반환
- **HugePages**: 2MiB/1GiB 페이지로 TLB 미스 감소(게스트·호스트 양쪽에 적용 가능)

**TLB 고려**: 2단 변환은 TLB 미스 비용을 키운다 → **nested TLB**(TLB에 2단 변환 결과를 캐시)와 **HugePages**로 완화.

---

### 18.4.3 I/O Virtualization

I/O는 전체 성능의 관건. 구현 방식은 **에뮬레이션 ↔ 파라가상 ↔ 패스스루**로 스펙트럼을 이룬다.

- **디바이스 에뮬**: 게스트에 e1000/AHCI 같은 구형 하드웨어를 흉내냄(호환성↑/성능↓)
- **Para-virtual(virtio)**: 게스트 드라이버가 **virtqueue**(ring)로 백엔드와 통신(성능↑)
- **vhost-net/vhost-vsock/vhost-scsi**: 커널 fast-path로 virtqueue 처리(문맥 전환↓)
- **SR-IOV 패스스루**: NIC가 제공하는 **VF**를 게스트에게 직할(레이턴시 최소화)
- **VFIO + IOMMU**: DMA를 IOMMU-도메인으로 가두어 **격리**

**Virtqueue(개념)**
- 디스크립터 테이블 + **available ring** + **used ring**
- 게스트가 desc를 **avail**에 올리고 KICK → 호스트가 처리 후 **used**에 기록

```python
# virtqueue_min.py — virtio 큐 개념 시뮬레이터(극단 단순화)
from collections import deque
class VirtQueue:
    def __init__(self): self.avail=deque(); self.used=deque()
    def kick(self, desc): self.avail.append(desc)       # 게스트 -> 호스트
    def poll(self):
        if not self.avail: return None
        d=self.avail.popleft()                           # 호스트 처리
        res = {"id": d["id"], "len": len(d["buf"])}
        self.used.append(res); return res

vq=VirtQueue(); vq.kick({"id":1,"buf":b"hello"})
print(vq.poll())  # {'id': 1, 'len': 5}
```

---

### 18.4.4 Interrupt / APIC Virtualization

- **APIC-v / Posted Interrupts**: 인터럽트를 VM-Exit 없이 **게스트 vCPU 런큐에 직접 포스팅**
- **MSI/MSI-X 가상화**: 게스트에게 MSI를 허용하되, **리맵 테이블**로 하이퍼바이저가 최종 라우팅
- **Timer**: HPET/PIT 에뮬 + **PV-timer**(kvm-clock, Xen pv-timer)로 정밀 제어

---

### 18.4.5 Firmware/Boot/장치 트리

- **SeaBIOS/OVMF(UEFI)**: 게스트 부트 펌웨어
- **ACPI 테이블**: CPU/메모리/열 관리/전원, virtio 디스크립터
- **Device Tree(ARM)**: 가상 하드웨어 서술

---

### 18.4.6 Management Plane

- **QMP**(QEMU Monitor Protocol): 런타임 제어(스냅샷/마이그레이션/장치 핫플러그)
- **libvirt**: XML/CLI(`virsh`)로 하이퍼바이저 추상화
- **cloud-init**: 템플릿 대량 배포 자동화

```python
# libvirt_hotplug.py — VCPU 핫플러그(개념)
import libvirt, time
conn=libvirt.open('qemu:///system'); dom=conn.lookupByName('vm-demo')
dom.setVcpusFlags(4, libvirt.VIR_DOMAIN_AFFECT_LIVE)  # 라이브로 vCPU를 4개로
time.sleep(1); print("vcpus:", dom.maxVcpus())
```

---

## 18.5 Types of VMs and Their Implementations

### 18.5.1 분류 지도

1) **Full Virtualization**
   - 게스트 수정을 **요구하지 않음**.
   - 구현: Binary Translation(초기 x86), Hardware-assist(VT-x/AMD-V).
   - 예: **KVM/QEMU**, **VMware ESXi**, **Hyper-V**.

2) **Paravirtualization (PV)**
   - 게스트가 **hypercall** 을 사용하도록 수정.
   - 예: **Xen PV**(옛 방식), 오늘날은 **PVH/PVHVM**(혼합).

3) **Emulation (ISA 변환)**
   - 전혀 다른 ISA를 SW로 에뮬(QEMU TCG) — **정확성↑/성능↓**.
   - 임베디드/테스트/고고학적 환경 복원에 유용.

4) **MicroVM / 경량 하이퍼바이저**
   - 최소한의 디바이스 모델(네트/블록만)과 **보안 경계 강화**.
   - 예: Firecracker, Cloud-Hypervisor. 부팅 수백 ms~초.

5) **Process VM**
   - 전체 OS 대신 **바이트코드/ABI** 를 위한 런타임(JVM/CLR/WASM).
   - 시스템 VM과 레이어가 다름(그러나 샌드박스/능력 모델로 보안 결합 가능).

> 컨테이너는 *VM이 아님*. 같은 커널을 공유하는 **OS-level 가상화**지만, 현실 배치에서는 **VM 위 컨테이너**(이중 경계)가 일반적.

---

### 18.5.2 구현 패턴/사례 요약

- **KVM/QEMU(Type-2 하이브리드)**
  - KVM: 커널 모듈이 **VM-Exit/Entry/SLAT** 등 핵심을 제공
  - QEMU: 사용자 공간에서 **디바이스 모델/이미지 관리**
  - **vhost-net/scsi** 로 커널 fast-path

```bash
# KVM/virtio 기반 일반적인 QEMU 실행 예
qemu-system-x86_64 -enable-kvm -m 4096 -smp 4 \
  -cpu host -machine q35,accel=kvm \
  -drive if=virtio,file=vm.qcow2,format=qcow2,cache=none,aio=native \
  -netdev tap,id=n0,script=no,downscript=no -device virtio-net-pci,netdev=n0 \
  -device virtio-balloon-pci -chardev socket,id=mon,path=/tmp/qmp,server,nowait \
  -mon chardev=mon,mode=control
```

- **Xen(Type-1)**
  - **dom0**(관리/드라이버), **domU**(게스트)
  - 모드: PV, HVM(VT-x), PVH(하이브리드)

```ini
# xen.cfg (개념)
name="vm"
memory=2048
vcpus=2
disk=['phy:/dev/mapper/vg/vm,xvda,w']
vif=['bridge=xenbr0,model=virtio-net']
```

- **Hyper-V**
  - 파티션 모델(루트/자식 파티션), enlightenments(PV-timer/Spin/Clock)

- **ESXi**
  - 강력한 관리/스토리지/네트워킹 스택 + vMotion/DRS/HA

- **MicroVM (Firecracker)**
  - API-driven(MMDS/REST), minimal device model(virtio-net/blk), jailer

```bash
# (개념) Firecracker: VM 정의 JSON 전달 → 빠른 부팅
# PUT /guest-config, /drives, /network-interfaces ... 이후 /actions:InstanceStart
```

- **Emulation (QEMU TCG)**
  - `-accel tcg` 로 ISA 전환(학습/테스트용)

---

### 18.5.3 Nested Virtualization

하이퍼바이저 위에서 또 다른 하이퍼바이저를 구동.
- x86: **VMX nested**(L0↔L1↔L2), ARM: **EL2** nested 지원 확산
- 오버헤드와 복잡도가 커지므로, 테스트/특수 목적에서 신중히 사용

---

### 18.5.4 성능/보안 트레이드오프

| 방식 | 성능 | 호환성 | 보안 경계 | 운영 난이도 |
|---|---|---|---|---|
| Full virt(HW) | 높음 | 매우 높음 | 높음 | 중 |
| PV | 높음 | OS 수정 필요 | 높음 | 중 |
| Emu(TCG) | 낮음 | 최고 | 중 | 낮음 |
| SR-IOV | 최고 | 장치 의존 | 경계 단순화(도메인 격리) | 중 |
| MicroVM | 높음 | 제한 | 높음(공격면↓) | 중 |

---

## 18.6 Virtualization and Operating-System Components

가상화는 **게스트 OS의 모든 서브시스템**에 관여한다. 각 컴포넌트가 어떻게 “가상화 친화적”이어야 하는지 살펴보자.

### 18.6.1 Process/Thread Scheduling (게스트 ↔ 호스트 이중 스케줄링)

- **게스트 스케줄러**: vCPU를 **실제 CPU**라고 믿고 **프로세스**를 할당
- **호스트 스케줄러**: vCPU 자체가 **호스트의 스레드**로 스케줄링

문제: 게스트가 **busy-wait 스핀락**을 돌면, 같은 물리코어를 못 잡아 **진행 정지**(lock-holder preemption).
해결:
- **PV-spinlock**(하이퍼콜로 양보)
- **vCPU co-scheduling / pinning**(동일 NUMA에 고정)
- **halt-poll/tickless**: 인터럽트 대기 지연 감소

```bash
# 게스트 튜닝 예(리눅스)
echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs
# 호스트: vCPU 핀닝 + 같은 NUMA노드에 메모리 고정
virsh vcpupin vm 0 2; virsh vcpupin vm 1 3; virsh numatune vm --mode strict --nodeset 0
```

---

### 18.6.2 Memory Management (게스트 내부 vs 하이퍼바이저 외부)

- **Balloon Driver**: 게스트가 페이지를 “풍선”으로 확보 → 하이퍼바이저에 반환
- **Hinting**: free page reporting(게스트가 “나는 이 페이지 안 써” 힌트)
- **Swap 전략**: *가능하면 호스트 스왑 금지*, 게스트 내부 스왑 선호(가시성↑)

```bash
# 호스트: balloon 사용(virsh)
virsh qemu-monitor-command vm --hmp "balloon 2048"   # 2GiB로 내려
```

- **HugePages**: 게스트 THP on + 호스트 HugeTLB로 이중 최적화
- **KSM**: 동일 페이지 병합(보안/성능 트레이드오프 고려)

---

### 18.6.3 File Systems & Block I/O

- **게스트 블록**: virtio-blk/scsi, 캐시 모드(writeback/writethrough/none)
- **저장 백엔드**: raw(LVM/NVMe), qcow2(스냅샷/백킹), 네트워크 블록(CEPH/RBD, iSCSI)

```xml
<!-- libvirt XML: 안전한 고성능 디스크 -->
<disk type='block' device='disk'>
  <driver name='qemu' type='raw' cache='none' io='native'/>
  <source dev='/dev/nvme0n1'/>
  <target dev='vda' bus='virtio'/>
</disk>
```

- **virtio-fs / 9p**: 호스트 디렉터리를 게스트에 공유 (빌드/개발에 유용)
- **쓰기 순서 보장**: 게스트 FS 저널 + 호스트 sync 정책(장애 복원 설계 중요)

---

### 18.6.4 Networking

- **모델**: tap + 브리지/OVS, NAT, VXLAN 오버레이, SR-IOV VF
- **튜닝**: GRO/LRO, TSO, RFS/RPS, RSS 큐, multiqueue virtio-net

```bash
# 멀티큐 virtio-net 예(QEMU)
-device virtio-net-pci,netdev=n0,mq=on,vectors=8 \
-netdev tap,id=n0,queues=4
```

게스트/호스트 모두에서 큐 수/IRQ affinity를 맞추면 **스ループット**과 **코어 확장이 선형**에 가까워진다.

---

### 18.6.5 Timekeeping & Timers

- **PV-clock**(kvm-clock, xen clocksource) 사용으로 VM-Exit 감소
- **TSC scaling**: 호스트/게스트 주파수 불일치 보정
- **NTP**: 게스트 내부도 NTP 동기화(마이그레이션/스냅샷 후 시계 보정)

```bash
# 게스트: pvclock 사용 여부 확인
cat /sys/devices/system/clocksource/clocksource0/current_clocksource
# kvm-clock 권장
```

---

### 18.6.6 Interrupts & Timer Tick

- **tickless( NO_HZ )** 게스트 커널로 context switch/인터럽트 빈도↓
- **APIC-v/posted interrupts**: VM-Exit 없이 인터럽트 전달 → 레이턴시/스루↑

---

### 18.6.7 Security in a VM

- **IOMMU on**(디폴트 강제), **virtio 최신**, **Secure Boot/TPM/vTPM**
- **패스스루 시 주의**: 게스트가 장치 펌웨어/옵코드를 잘못 다루면 호스트 안정성 영향 → 최신 마이크로코드/드라이버 필요
- **Nested** 환경은 공격면↑ → 엄격한 격리/감사

```xml
<!-- vTPM 추가(개념) -->
<tpm model='tpm-crb'>
  <backend type='emulator' version='2.0'/>
</tpm>
```

---

### 18.6.8 Power / CPU Features

- **CPUID mask/host-passthrough**: 마이그레이션 호환 vs 성능
- **pstate/cpufreq 가상화**: 게스트 전력 정책이 호스트 실제 주파수에 영향 없도록 추상화

```xml
<cpu mode='host-passthrough'>
  <feature policy='require' name='erms'/>
  <feature policy='require' name='invpcid'/>
</cpu>
```

---

### 18.6.9 Live Migration & Storage Consistency

- **Pre-copy**: 더티 페이지 반복 전송 → stop-and-copy 최소화
- **포스트-카피**: 즉시 전환 후 **페이지 폴트로 당김**, 네트워크 안정성 요구
- **스토리지**: 공유 스토리지(vMotion-like) 또는 **block-migration**(저장도 전송)

```bash
# QEMU HMP 예(개념): 라이브 마이그레이션
(qemu) migrate tcp:dst:4444
(qemu) info migrate
```

---

### 18.6.10 디버깅/관측

- **KVM 스탯**: `kvm_exit_*` 카운터, dirty rate, balloon, steal time
- **eBPF/BCC**: vhost-net/blk 경로 관찰, IRQ latency
- **QMP**: 게스트 내부/외부 이벤트 수집

```python
# qmp_dirtyrate.py — QMP로 더티율 조회(개념)
import socket, json
s=socket.socket(); s.connect(("/tmp/qmp",0))
s.send(b'{"execute":"qmp_capabilities"}\n')
s.send(b'{"execute":"query-dirty-rate"}\n')
print(s.recv(4096))
```

---

## 종합 실습 시나리오 — “고성능 웹 VM” 설계

**요구**
- 레이턴시 민감 API 서버. 대역폭↑, 지터↓, 무중단 마이그레이션, 튜닝/관측 가능.

**설계**
1) **CPU/NUMA**: vCPU 핀닝 + 게스트 tickless + PV-spinlock
2) **메모리**: HugePages(호스트/게스트), balloon on(여유 시 회수), KSM off(보안/변동성)
3) **I/O**: virtio-net multiqueue + vhost-net, virtio-blk(raw+io=native, cache=none)
4) **보안**: IOMMU on, vTPM, 최신 virtio
5) **마이그레이션**: pre-copy + dirty-ring 튜닝
6) **관측**: QMP, eBPF, 게스트 NTP/chrony

```bash
# QEMU 실행 요약(핵심 플래그)
-enable-kvm -cpu host -smp 4 -m 8192 \
-object memory-backend-file,id=mem0,mem-path=/dev/hugepages,size=8G,share=on \
-machine q35,accel=kvm,mem-merge=off,memory-backend=mem0 \
-device virtio-net-pci,netdev=n0,mq=on,vectors=10 -netdev tap,id=n0,queues=4 \
-drive if=none,id=d0,file=/dev/nvme0n1,format=raw,cache=none,aio=native \
-device virtio-blk-pci,drive=d0 \
-chardev socket,id=qmp,path=/tmp/qmp,server,nowait -mon chardev=qmp,mode=control
```

게스트 내:
```bash
# 네트워크 큐/IRQ 핀닝(개념)
ethtool -L eth0 combined 4
for i in 0 1 2 3; do
  echo $((2+i)) | sudo tee /proc/irq/$(grep eth0-TxRx-$i -rl /proc/irq/*/ | sed 's/.*\/\([0-9]\+\)\/.*/\1/')/smp_affinity_list
done
```

---

## 핵심 요약

- **18.4 Building Blocks**: CPU(Exit/Entry, VMCS/VMCB), 메모리(EPT/NPT, Balloon/HugePages), I/O(virtio/vhost/SR-IOV), 인터럽트(APIC-v), 펌웨어/ACPI, 관리(QMP/libvirt/cloud-init).
- **18.5 Types & Implementations**: Full(하드웨어 보조), PV, Emu, MicroVM, Nested — KVM/QEMU/Xen/ESXi/Hyper-V/Firecracker의 **건축 양식** 비교.
- **18.6 OS Components**: 스케줄러의 이중성, PV-spinlock/tickless, 메모리 회수/힌팅, virtio-fs/blk, multiqueue 네트, PV-clock, 라이브 마이그레이션, vTPM/IOMMU — **게스트 OS의 모든 층**이 가상화 친화적으로 동작해야 한다.
