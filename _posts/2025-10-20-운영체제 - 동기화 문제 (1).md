---
layout: post
title: 운영체제 - 동기화 문제 (1)
date: 2025-10-20 20:25:23 +0900
category: 운영체제
---
# Synchronization Examples

## 7.1 Classic Problems of Synchronization

### 7.1.1 Bounded Buffer (Producer–Consumer)

#### (A) 세마포어 풀이 (교과서 표준)
- `slots`: 남은 슬롯 수(초기 CAP)  
- `items`: 채워진 항목 수(초기 0)  
- `m`: 큐 조작 보호 뮤텍스

```c
// bounded_buffer_sem.c
#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>

#define CAP 8
int q[CAP], h=0, t=0;
sem_t slots, items;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

void* prod(void*){
  for(int x=1;x<=40;x++){
    sem_wait(&slots);                  // 빈 슬롯 확보
    pthread_mutex_lock(&m);
    q[h]=x; h=(h+1)%CAP;
    pthread_mutex_unlock(&m);
    sem_post(&items);                  // 아이템 증가 알림
  }
  return NULL;
}
void* cons(void*){
  for(int i=0;i<40;i++){
    sem_wait(&items);                  // 아이템 대기
    pthread_mutex_lock(&m);
    int v=q[t]; t=(t+1)%CAP;
    pthread_mutex_unlock(&m);
    sem_post(&slots);                  // 슬롯 반납
    printf("got %d\n", v);
  }
  return NULL;
}
int main(){
  sem_init(&slots,0,CAP); sem_init(&items,0,0);
  pthread_t p,c; pthread_create(&p,NULL,prod,NULL); pthread_create(&c,NULL,cons,NULL);
  pthread_join(p,NULL); pthread_join(c,NULL);
}
```

- **정확성**: 큐 불변식 $$0 \le \text{size} \le \text{CAP}$$ 유지, 상호배제는 `m`이 보장.
- **활성**: 생산/소비가 진행 중이면 항상 누군가는 깨워짐(`items/slots`).

#### (B) 모니터(조건변수) 풀이 — Mesa 의미론 필수 `while`
```cpp
// bounded_buffer_monitor.cpp
#include <mutex>
#include <condition_variable>
#include <deque>

class BoundedBuffer {
  std::mutex m;
  std::condition_variable not_full, not_empty;
  std::deque<int> q; const size_t cap;
public:
  explicit BoundedBuffer(size_t c):cap(c){}
  void put(int x){
    std::unique_lock<std::mutex> lk(m);
    not_full.wait(lk,[&]{return q.size()<cap;});
    q.push_back(x);
    lk.unlock(); not_empty.notify_one();
  }
  int take(){
    std::unique_lock<std::mutex> lk(m);
    not_empty.wait(lk,[&]{return !q.empty();});
    int v=q.front(); q.pop_front();
    lk.unlock(); not_full.notify_one();
    return v;
  }
};
```

- **실무 팁**: `not_empty/not_full` **조건 분리**로 불필요한 깨어남 감소.

---

### 7.1.2 Readers–Writers (RW) 문제

#### (A) Reader Preference — writer 기아 가능
```c
// rw_read_pref.c
#include <semaphore.h>
#include <pthread.h>
int readcount=0; sem_t rcount_mux, rw_mutex;
void* reader(void*){
  sem_wait(&rcount_mux);
  if(++readcount==1) sem_wait(&rw_mutex);  // 첫 reader가 writer 차단
  sem_post(&rcount_mux);

  // read...

  sem_wait(&rcount_mux);
  if(--readcount==0) sem_post(&rw_mutex);
  sem_post(&rcount_mux);
  return NULL;
}
void* writer(void*){
  sem_wait(&rw_mutex); // 독점
  // write...
  sem_post(&rw_mutex);
  return NULL;
}
```

#### (B) Writer Preference — 공정성 개선(대기열 세마포어)
```c
// rw_write_pref.c
sem_t rw_mutex, rcount_mux, queue; int readcount=0;
void* reader(void*){
  sem_wait(&queue);                      // 대기열 통과
  sem_wait(&rcount_mux);
  if(++readcount==1) sem_wait(&rw_mutex);
  sem_post(&rcount_mux);
  sem_post(&queue);
  // read...
  sem_wait(&rcount_mux);
  if(--readcount==0) sem_post(&rw_mutex);
  sem_post(&rcount_mux);
  return NULL;
}
void* writer(void*){
  sem_wait(&queue);
  sem_wait(&rw_mutex);
  // write...
  sem_post(&rw_mutex);
  sem_post(&queue);
  return NULL;
}
```

- **선택 기준**: 읽기가 압도적이면 reader-pref, 공정성이 중요하면 writer-pref 또는 **공정(FIFO) RW락**.

---

### 7.1.3 Dining Philosophers (교착·기아·라이브락 연구용)

#### (A) 단순 세마포어 — 한 철학자는 반대 순서 (교착 완화)  
```c
// dining_simple.c
#define N 5
sem_t forkS[N];
void* phil(void* arg){
  int i=(int)(size_t)arg, L=i, R=(i+1)%N;
  for(int k=0;k<100;k++){
    if(i==0){ sem_wait(&forkS[R]); sem_wait(&forkS[L]); }
    else    { sem_wait(&forkS[L]); sem_wait(&forkS[R]); }
    // eat
    sem_post(&forkS[L]); sem_post(&forkS[R]);
  }
  return NULL;
}
```
- **교착 감소**지만 **기아 가능**.

#### (B) 웨이터(모니터) 접근 — N-1 제한 + 공정성(기아 제거)
```java
// DiningMonitor.java
public class DiningMonitor {
  private final int N; private final boolean[] fork;
  public DiningMonitor(int n){ N=n; fork=new boolean[n]; }
  private boolean canEat(int i){ return !fork[i] && !fork[(i+1)%N]; }
  public synchronized void pick(int i) throws InterruptedException {
    while(!canEat(i) || activeCount()>=N-1) wait();
    fork[i]=fork[(i+1)%N]=true;
  }
  public synchronized void put(int i){
    fork[i]=fork[(i+1)%N]=false; notifyAll();
  }
  private int activeCount(){ int c=0; for(boolean b:fork) if(b) c++; return c/2; }
}
```

---

### 7.1.4 Sleeping Barber (대기실 한정/손님 유실)

- 자원: **의자(cap)**, **이발사**(mutex), **손님 수 세마포어**

```c
// sleeping_barber.c
#include <semaphore.h>
#include <pthread.h>
#define CHAIRS 4
sem_t customers, barbers, accessSeats;
int freeSeats = CHAIRS;

void* barber(void*){
  for(;;){
    sem_wait(&customers);               // 손님 도착 대기
    sem_wait(&accessSeats);
    freeSeats++;                        // 의자 하나 비워짐
    sem_post(&barbers);                 // 이발사 준비 완료
    sem_post(&accessSeats);
    // cut hair...
  }
  return NULL;
}
void* customer(void*){
  sem_wait(&accessSeats);
  if(freeSeats>0){
    freeSeats--;                        // 대기실 착석
    sem_post(&customers);
    sem_post(&accessSeats);
    sem_wait(&barbers);                 // 이발차례 대기
    // haircut...
  } else {
    sem_post(&accessSeats);             // 만석 => 떠남
  }
  return NULL;
}
```

---

### 7.1.5 Cigarette Smokers (리소스 매칭) — 조건변수/세마포어 매핑
- 조합공간(종이/담배/성냥)을 **세 개의 세마포어**로 모델링하거나,  
- 모니터 내부에서 **조건변수 3개**로 “내 재료 대기열”을 분할.

---

### 7.1.6 Barriers & Rendezvous (스레드 동시 도착)

#### (A) 센스 리버설 바리어 (스핀/원자)
```cpp
// sense_barrier.cpp
#include <atomic>
struct SenseBarrier {
  const int n; std::atomic<int> count{0}; std::atomic<bool> sense{false};
  thread_local static bool local;
  void wait(){
    bool s = local = !local;
    if(count.fetch_add(1,std::memory_order_acq_rel)==n-1){
      count.store(0,std::memory_order_relaxed);
      sense.store(s,std::memory_order_release);
    } else {
      while(sense.load(std::memory_order_acquire)!=s) { /* spin */ }
    }
  }
}; bool SenseBarrier::local=false;
```

#### (B) 모니터 바리어 (블록/깨우기)
```cpp
// barrier_monitor.cpp
#include <mutex>
#include <condition_variable>
struct Barrier {
  std::mutex m; std::condition_variable cv; int n, cnt=0, gen=0;
  explicit Barrier(int n):n(n){}
  void wait(){
    std::unique_lock<std::mutex> lk(m);
    int g=gen;
    if(++cnt==n){ gen++; cnt=0; cv.notify_all(); }
    else cv.wait(lk,[&]{return g!=gen;});
  }
};
```

---

### 7.1.7 The Santa Claus Problem (조합 동기화 패턴)
- 조건: **썰매 준비(8마리 사슴)** 또는 **정비공 3명 모임** 시 산타를 깨움.  
- 해법: **우선순위 있는 조건변수** 2개 + 카운터/게이트.

---

### 7.1.8 요약 표 (문제→도구 매핑)

| 문제 | 자연스런 도구 | 주의점 |
|---|---|---|
| Bounded Buffer | 세마포어 2 + 뮤텍스, 모니터 | 혼합 대기열 → `notifyAll` 또는 분리 조건 |
| Readers–Writers | 세마포어, RW락 | 기아 방지 정책 선택 |
| Dining Philosophers | 웨이터 모니터 | N-1 제한, 공정성 |
| Sleeping Barber | 세마포어(좌석/손님/이발사) | 만석 처리(유실 허용/큐잉) |
| Barriers | 센스(락프리) / 모니터 | 스레드 수 가변 시 주의 |
| Cigarette Smokers | 조건변수 분할 | 스퍼리어스 웨이크업 |

---

## 7.2 Synchronization within the Kernel

커널은 **사용자 공간과 다르게** 다음 제약이 있다:

- **인터럽트 컨텍스트**: **수면 금지**(블로킹 금지), 아주 짧게 끝나야 함.  
- **소프트IRQ/Tasklet/Workqueue**: 인터럽트 후반부로 작업 분할.  
- **프리엠션/CPU/NUMA**: 선점/마이그레이션, 캐시/메모리 일관성 고려.  
- **디버깅/안전**: 교착 시 시스템 전체가 멈춤 → **락 순서 규약/lockdep** 필수.

### 7.2.1 커널 동기화 도구(리눅스 중심)

- **스핀락** (`spin_lock`, `spin_lock_irqsave`)  
  - **IRQ 금지 변형**: 인터럽트 컨텍스트와 공유 자료 보호
- **뮤텍스 / 세마포어** (`mutex_lock`, `down`/`up`)  
  - **수면 가능**: **프로세스 컨텍스트에서만 사용**
- **RW 락** (`rwlock_t`, `rw_semaphore`)  
- **RCU(Read-Copy-Update)**: 다수 읽기/드문 쓰기, **락 없는 읽기 경로**  
- **Seqlock / Seqcount**: 쓰기 시퀀스 번호, 읽기는 재시도(락프리 읽기 + 단순 쓰기 락)  
- **원자 타입** (`atomic_t`, `refcount_t`)  
- **per-CPU 변수**: 각 CPU 전용 데이터로 락 회피  
- **메모리 배리어**: `smp_mb()`, `smp_rmb()`, `smp_wmb()`, `READ_ONCE/WRITE_ONCE`

> **규칙**: **인터럽트/하드IRQ** 경로에서는 **절대 수면 금지**. 필요 시 **softirq/workqueue**로 내려보낸다.

---

### 7.2.2 사례 1 — ISR ↔ Bottom-Half 링버퍼 (키보드/NET RX 등)

**요구**:  
- 상단부(ISR)가 패킷/스캔코드 push (아주 짧게)  
- 하단부(softirq/tasklet) 또는 workqueue가 pop하여 처리

```c
/* isr_ring.c — 개념 스케치: ISR에서 push, softirq에서 pop */
#include <linux/spinlock.h>
#define CAP 1024
static u8 ring[CAP]; static int h, t;
static spinlock_t lock; /* IRQ-safe */

irqreturn_t my_isr(int irq, void *dev){
    unsigned long flags;
    spin_lock_irqsave(&lock, flags);      // IRQ 비활성 + 스핀락
    ring[h] = read_hw_byte();
    h = (h+1) & (CAP-1);
    spin_unlock_irqrestore(&lock, flags);
    raise_softirq(MY_SOFTIRQ);            // 하반부 기상
    return IRQ_HANDLED;
}

static void my_softirq_handler(struct softirq_action *a){
    /* 소프트IRQ에서는 인터럽트 이미 off, 스핀락만 */
    while (t != h) {
        u8 v = ring[t]; t = (t+1) & (CAP-1);
        process(v);
    }
}
```

- **포인트**: ISR은 **극히 짧게**, 동기화는 `spin_lock_irqsave` 변형으로 보호.

---

### 7.2.3 사례 2 — Wait Queue로 “수면 가능한” 소비자 깨우기

**맥락**: 네트워크 소켓 RX 큐, 블록 디바이스 요청 완료 등.

```c
/* waitqueue_example.c — 생산자(완료 경로) → 소비자(프로세스) */
#include <linux/wait.h>
#include <linux/sched.h>
static DECLARE_WAIT_QUEUE_HEAD(wq);
static atomic_t ready = ATOMIC_INIT(0);

ssize_t my_read(/*...*/){
    /* 수면 가능 컨텍스트 */
    wait_event_interruptible(wq, atomic_read(&ready));
    atomic_set(&ready, 0);
    return copy_to_user_data();
}
void completion_from_irq(/*...*/){
    atomic_set(&ready, 1);
    wake_up_interruptible(&wq);
}
```

- **원칙**: 수면은 **프로세스 컨텍스트**에서만, 깨움은 ISR/softirq 어디서든 가능.

---

### 7.2.4 사례 3 — Completion 객체 (1회성 이벤트 동기화)

```c
/* completion_example.c */
#include <linux/completion.h>
static DECLARE_COMPLETION(done);

static int worker(void *arg){
    /* ... long op ... */
    complete(&done);               // 완료 신호
    return 0;
}
static int caller(void){
    /* ... spawn worker ... */
    wait_for_completion(&done);    // 블록 대기
    return 0;
}
```

---

### 7.2.5 사례 4 — RCU로 읽기 경로 무락화

- **읽기 경로**: `rcu_read_lock()`/`rcu_read_unlock()` 사이에서 **락 없이 포인터 역참조**  
- **쓰기 경로**: 새 구조체를 준비→포인터 교체→`call_rcu()`로 **지연 해제**

```c
/* rcu_example.c — 단일 포인터 교체 */
#include <linux/rcupdate.h>
struct foo { int v; /* ... */ };
struct foo __rcu *gptr;

int reader(void){
    rcu_read_lock();
    struct foo *p = rcu_dereference(gptr);
    int v = READ_ONCE(p->v);
    rcu_read_unlock();
    return v;
}
void writer(void){
    struct foo *n = kmalloc(sizeof(*n), GFP_KERNEL);
    n->v = 42;
    struct foo *old = rcu_replace_pointer(gptr, n, true);
    call_rcu(&old->rcu, foo_free_cb);   // 그래이스 기간 후 해제
}
```

- **장점**: 읽기가 **완전 비차단**, 고읽기 비율 워크로드에 최적.

---

### 7.2.6 사례 5 — Seqcount/Seqlock (락 없는 읽기 + 재시도)

```c
/* seqlock_example.c */
#include <linux/seqlock.h>
seqlock_t sl; u64 X, Y;

u64 read_pair(void){
    unsigned seq; u64 x,y;
    do {
        seq = read_seqbegin(&sl);
        x = READ_ONCE(X); y = READ_ONCE(Y);
    } while (read_seqretry(&sl, seq));
    return x+y;
}
void write_pair(u64 nx, u64 ny){
    write_seqlock(&sl);
    WRITE_ONCE(X, nx); WRITE_ONCE(Y, ny);
    write_sequnlock(&sl);
}
```

- **사용처**: 타이밍/스냅샷 값 같이 **작은 구조**를 일관되게 읽고 싶을 때.

---

### 7.2.7 per-CPU 변수로 락 회피
- 각 CPU가 자신의 카운터/통계를 **로컬 캐시라인**에 유지 → 합산 시만 수집.

```c
/* percpu_counter.c */
#include <linux/percpu.h>
DEFINE_PER_CPU(long, pkt_cnt);
static inline void inc_pkt(void){ this_cpu_inc(pkt_cnt); }
long total(void){
    long sum=0; int cpu;
    for_each_possible_cpu(cpu) sum += per_cpu(pkt_cnt, cpu);
    return sum;
}
```

---

### 7.2.8 메모리 배리어 & 순서 보장

- **공식 API**: `smp_mb()/smp_rmb()/smp_wmb()`, `READ_ONCE/WRITE_ONCE`, `rcu_dereference`  
- **의미**: 아키텍처별 느슨한 메모리 모델에서 **재배치/가시성** 보장

> **패턴**: “producer writes data → **wmb** → writes flag” / “consumer reads flag → **rmb** → reads data”.

---

### 7.2.9 락 순서·교착 방지·lockdep

- **글로벌 순서 규약**(예: `A → B → C`) 유지  
- **trylock**로 잠재 순환 탐지, 실패 시 롤백  
- **lockdep**: 정적/동적 락 종속성 검사(커널 설정 필요)

---

### 7.2.10 우선순위 역전과 PI(실시간 커널)

- RT 환경에서는 **우선순위 상속(Priority Inheritance) 뮤텍스** 사용  
- **irq off** 구간 최소화, **preempt off** 시간 제한(스케줄러 감시)

---

### 7.2.11 커널 동기화 선택 가이드(요약)

| 컨텍스트 | 도구 | 수면 가능 | 용례 |
|---|---|---:|---|
| 하드IRQ/ISR | `spin_lock_irqsave` | ✗ | 링버퍼, 레지스터 보호 |
| 소프트IRQ/Tasklet | `spin_lock` | ✗ | 패킷 처리 하반부 |
| 프로세스 컨텍스트 | `mutex`, `down/up`, `wait_event`, `completion` | ✓ | 블로킹 I/O, 장시간 작업 |
| 고읽기:저쓰기 | **RCU** | 읽기: ✗ / 쓰기: ✓ | 라우팅 테이블, 핸들 |
| 작은 스냅샷 | **seqcount/seqlock** | 읽기: ✗ | 시각/좌표 읽기 |
| 통계/카운터 | per-CPU | n/a | 락 회피, 캐시 친화 |

---

## 검증·평가(운영 팁)

- **정확성**: 불변식(경계/카운트), 교착 탐지(타임아웃/스택 추적)  
- **성능**: p95/p99 대기, 컨텍스트 스위치, **migration/NUMA 원격비율**, 캐시 미스  
- **관측 도구**  
  - 사용자: `perf`, `bpftrace`(futex/condvar), 샘플링 프로파일러  
  - 커널: `perf sched/lock`, ftrace, lockdep, `rcu stalls` 모니터링

---

## 미니 프로젝트: 커널 패턴의 사용자 공간 재현

### 과제 A — ISR/softirq 링버퍼를 **스레드+스핀락**으로 시뮬레이션
- 하나의 쓰레드가 “ISR 역할”로 빠르게 push, 다른 쓰레드가 소비.  
- **`spinlock` vs `mutex`**, **배치 pop** 유무에 따른 처리량/p99 비교.

### 과제 B — RCU 유사 패턴 (read-mostly 맵)
- 읽기 경로는 `shared_ptr` 스냅샷, 쓰기는 카피-온-라이트 + 지연 해제.  
- **읽기 락 유무**에 따른 지연 비교.

---

## 핵심 요약

- **7.1 고전 문제**는 **세마포어/모니터/락프리**를 배우는 최적의 연습장이다. `while(wait)` 패턴, 조건 분리, 공정성(기아 방지)을 늘 염두에 둔다.  
- **7.2 커널 동기화**는 **컨텍스트 제약(IRQ/수면 금지)** 이 본질. 상황별로 **스핀락/뮤텍스/RCU/seqlock/per-CPU** 를 적재적소에 사용하고, **메모리 배리어**와 **락 순서 규약**을 엄격히 지킨다.  
- 올바른 선택은 **안전(Safety)** 과 **활성(Liveness)** 을 동시에 만족하면서 **성능**과 **예측 가능성**을 보장한다.
