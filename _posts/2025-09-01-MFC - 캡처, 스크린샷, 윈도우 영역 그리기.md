---
layout: post
title: MFC - 캡처, 스크린샷, 윈도우 영역 그리기
date: 2025-09-01 19:25:23 +0900
category: MFC
---
# 캡처/스크린샷, 윈도우 영역 그리기(투명/반투명 오버레이 개념) — MFC/Win32 실전 총정리

이 글은 **Windows 데스크톱(MFC/Win32)** 에서
1) **화면/윈도우 캡처(스크린샷)**,  
2) **반투명/투명 오버레이**(선택 영역, 하이라이트, 가이드 라인, HUD)  
를 **성능·DPI·멀티모니터**까지 고려해 **끝까지** 정리합니다.

> 대상: SDI/MDI/대화상자 앱, Windows 10/11, x64/Unicode 권장  
> 그래픽: GDI/GDI+ 기본, 필요 시 WIC/Direct2D/디스플레이 복제 API(고급) 언급  
> 표기: 모든 코드는 ```로 감싸고, **바로 붙여 넣어** 테스트 가능한 최소 형태 지향

---

## 0) 로드맵

- **A. 캡처의 종류와 선택 기준**: `BitBlt` / `PrintWindow` / DWM 썸네일 / Magnification / DXGI Desktop Duplication  
- **B. GDI 캡처 실전**: 전체 화면, 멀티모니터, 특정 윈도우/클라이언트, 커서 포함, 고DPI  
- **C. 저장/인코딩**: GDI+로 PNG/JPEG, WIC로 빠른 인코딩  
- **D. 오버레이 기본기**: `WS_EX_LAYERED` / `UpdateLayeredWindow` / 클릭 스루 / 반투명 브러시  
- **E. 선택 영역 도구**: 화면 어둡게 덮고, 드래그로 사각/자유형 선택, 스냅/가이드 표시  
- **F. 반투명 하이라이트/툴팁 HUD**: 라운드 박스, 그림자, 블러(대안), 리전 히트 테스트  
- **G. 성능·DPI·보안·안정성 체크리스트**  
- **H. 고급 API 개요**: Magnification API, DXGI Desktop Duplication, DWM API

---

# A) 캡처의 종류와 선택 기준

| 방법 | 장점 | 단점 | 용도 |
|---|---|---|---|
| **GDI BitBlt(스크린 DC)** | 간단, 빠름, 대부분 동작 | 일부 UWP/보호 콘텐츠, 엣지 케이스 | 일반 화면 캡처 |
| **PrintWindow(HWND)** | 윈도우 비가시·가려짐에도 시도 | 앱/테마에 따라 실패/느림 | 특정 창 캡처 |
| **DWM 썸네일(DwmRegisterThumbnail)** | 합성 후 결과 미리보기 | 정밀 제어 어려움, 저장 직접 X | 프리뷰/라이브 미리보기 |
| **Magnification API** | 가속, 하드웨어 최적화 | 앱 매니페스트·권한 이슈 | 화면 확대/부분 샘플 |
| **DXGI Desktop Duplication** | 최고 성능·변경 영역 추출 | DX11 필요, 복잡 | 고주사율/스트리밍 |

> **가장 현실적인 기본값**: **GDI BitBlt + GDI+ 저장**.  
> **특정 창**이 가려져 있어도 찍고 싶다면 `PrintWindow`를 **보조**로 시도.

---

# B) GDI 캡처 실전

## B-1) 전체 화면(가상 화면) 캡처

멀티 모니터까지 한 번에(가상 스크린):

```cpp
// 전체 화면 캡처 → HBITMAP 반환(32bpp)
HBITMAP CaptureVirtualScreen()
{
    HDC hdcScreen = GetDC(nullptr);
    int left   = GetSystemMetrics(SM_XVIRTUALSCREEN);
    int top    = GetSystemMetrics(SM_YVIRTUALSCREEN);
    int width  = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    int height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    HDC hdcMem = CreateCompatibleDC(hdcScreen);
    BITMAPINFO bi = {};
    bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth       = width;
    bi.bmiHeader.biHeight      = -height; // top-down
    bi.bmiHeader.biPlanes      = 1;
    bi.bmiHeader.biBitCount    = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    void* pBits = nullptr;
    HBITMAP hbm = CreateDIBSection(hdcScreen, &bi, DIB_RGB_COLORS, &pBits, nullptr, 0);
    HGDIOBJ old = SelectObject(hdcMem, hbm);

    BitBlt(hdcMem, 0, 0, width, height, hdcScreen, left, top, SRCCOPY);
    SelectObject(hdcMem, old);
    DeleteDC(hdcMem);
    ReleaseDC(nullptr, hdcScreen);
    return hbm;
}
```

> **Tip**: 32bpp top-down DIB를 쓰면 GDI+/WIC로 **바로 저장**하기 편합니다.

## B-2) 특정 모니터만 캡처

```cpp
struct MonitorShot {
    HMONITOR hmon{};
    RECT     rc{};
    HBITMAP  bmp{};
};

BOOL CALLBACK EnumMonProc(HMONITOR hMon, HDC, LPRECT rc, LPARAM lParam) {
    auto vec = reinterpret_cast<std::vector<MonitorShot>*>(lParam);
    MonitorShot s; s.hmon=hMon; s.rc=*rc;

    HDC scr = GetDC(nullptr);
    HDC mem = CreateCompatibleDC(scr);
    BITMAPINFO bi{}; bi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth=rc->right-rc->left;
    bi.bmiHeader.biHeight=-(rc->bottom-rc->top);
    bi.bmiHeader.biPlanes=1; bi.bmiHeader.biBitCount=32; bi.bmiHeader.biCompression=BI_RGB;
    void* pBits = nullptr;
    s.bmp = CreateDIBSection(scr, &bi, DIB_RGB_COLORS, &pBits, nullptr, 0);

    HGDIOBJ old = SelectObject(mem, s.bmp);
    BitBlt(mem,0,0, bi.bmiHeader.biWidth, -bi.bmiHeader.biHeight, scr, rc->left, rc->top, SRCCOPY);
    SelectObject(mem, old);
    DeleteDC(mem);
    ReleaseDC(nullptr, scr);

    vec->push_back(std::move(s));
    return TRUE;
}

std::vector<MonitorShot> CaptureAllMonitors() {
    std::vector<MonitorShot> out;
    EnumDisplayMonitors(nullptr, nullptr, EnumMonProc, (LPARAM)&out);
    return out;
}
```

## B-3) 특정 윈도우 캡처(가려짐 포함 시도)

1) **보이는 대로**: 부모/최상위로 올라가 `BitBlt`(창 위치)  
2) **가려짐 무시 시도**: `PrintWindow(hwnd, hdc, PW_RENDERFULLCONTENT)`  

```cpp
HBITMAP CaptureWindow(HWND hwnd, bool tryPrintWindow = true)
{
    RECT rc; GetWindowRect(hwnd, &rc);
    int w = rc.right-rc.left, h = rc.bottom-rc.top;
    HDC scr = GetDC(nullptr);
    HDC mem = CreateCompatibleDC(scr);

    BITMAPINFO bi{}; bi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth=w; bi.bmiHeader.biHeight=-h; bi.bmiHeader.biPlanes=1; bi.bmiHeader.biBitCount=32; bi.bmiHeader.biCompression=BI_RGB;
    void* pBits=nullptr;
    HBITMAP hb = CreateDIBSection(scr, &bi, DIB_RGB_COLORS, &pBits, nullptr, 0);
    HGDIOBJ old=SelectObject(mem, hb);

    BOOL ok = FALSE;
    if (tryPrintWindow) {
        ok = PrintWindow(hwnd, mem, PW_RENDERFULLCONTENT);
    }
    if (!ok) {
        // BitBlt로 대체
        POINT pt{rc.left, rc.top};
        BitBlt(mem, 0,0, w,h, scr, pt.x, pt.y, SRCCOPY);
    }
    SelectObject(mem, old);
    DeleteDC(mem);
    ReleaseDC(nullptr, scr);
    return hb;
}
```

> `PrintWindow`는 앱/테마/보호 콘텐츠/최신 UI요소에서 **부분 실패**할 수 있습니다. **fallback** 구조(위 예시) 권장.

## B-4) 클라이언트 영역만

```cpp
HBITMAP CaptureClient(HWND hwnd)
{
    RECT client; GetClientRect(hwnd, &client);
    POINT tl{client.left, client.top};
    ClientToScreen(hwnd, &tl);
    int w = client.right-client.left, h = client.bottom-client.top;

    HDC scr = GetDC(nullptr), mem = CreateCompatibleDC(scr);
    BITMAPINFO bi{}; bi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth=w; bi.bmiHeader.biHeight=-h; bi.bmiHeader.biPlanes=1; bi.bmiHeader.biBitCount=32; bi.bmiHeader.biCompression=BI_RGB;
    void* bits=nullptr; HBITMAP hb=CreateDIBSection(scr,&bi,DIB_RGB_COLORS,&bits,nullptr,0);
    HGDIOBJ old=SelectObject(mem, hb);
    BitBlt(mem,0,0,w,h, scr, tl.x, tl.y, SRCCOPY);
    SelectObject(mem, old);
    DeleteDC(mem); ReleaseDC(nullptr, scr);
    return hb;
}
```

## B-5) 커서 포함 캡처

```cpp
void DrawCursor(HDC hdc, int x, int y) {
    CURSORINFO ci{sizeof(ci)};
    if (GetCursorInfo(&ci) && (ci.flags & CURSOR_SHOWING)) {
        ICONINFO ii{};
        if (GetIconInfo(ci.hCursor, &ii)) {
            int cx=0, cy=0;
            BITMAP bm{};
            if (ii.hbmMask) { GetObject(ii.hbmMask, sizeof(bm), &bm); cx=bm.bmWidth; cy=abs(bm.bmHeight)/ (ii.hbmColor?1:2); }
            int hx=ii.xHotspot, hy=ii.yHotspot;
            DrawIcon(hdc, x + (int)ci.ptScreenPos.x - hx, y + (int)ci.ptScreenPos.y - hy, ci.hCursor);
            if (ii.hbmMask) DeleteObject(ii.hbmMask);
            if (ii.hbmColor) DeleteObject(ii.hbmColor);
        }
    }
}
```

> 전체 화면 캡처 후 `DrawCursor`로 **마우스 포인터 오버레이**.

## B-6) DPI/배율 주의

- `GetDpiForWindow`, `GetDpiForSystem` 이용  
- 좌표 변환(스크린 px vs 논리 px) 혼동 금지  
- **픽셀 단위 캡처**는 **스크린 좌표** 기준이 안전

---

# C) 저장/인코딩

## C-1) GDI+ PNG/JPEG 저장

```cpp
#include <gdiplus.h>
#pragma comment(lib, "gdiplus.lib")

CLSID GetEncoderClsid(const WCHAR* format) {
    UINT num=0, size=0; Gdiplus::GetImageEncodersSize(&num, &size);
    std::vector<BYTE> buf(size); auto p=(Gdiplus::ImageCodecInfo*)buf.data();
    Gdiplus::GetImageEncoders(num, size, p);
    for (UINT i=0;i<num;i++) if (wcscmp(p[i].MimeType, format)==0) return p[i].Clsid;
    return CLSID();
}

bool SaveHBITMAPAsPNG(HBITMAP hb, const std::wstring& path)
{
    Gdiplus::Bitmap bmp(hb, nullptr);
    CLSID clsid = GetEncoderClsid(L"image/png");
    return bmp.Save(path.c_str(), &clsid) == Gdiplus::Ok;
}
```

## C-2) WIC 인코딩(빠르고 유연)

```cpp
#include <wincodec.h>
#pragma comment(lib, "windowscodecs.lib")

bool SaveHBITMAP_WIC(HBITMAP hb, const std::wstring& path)
{
    BITMAP bm{}; GetObject(hb, sizeof(bm), &bm); // 32bpp ARGB top-down일 것
    CComPtr<IWICImagingFactory> fac; fac.CoCreateInstance(CLSID_WICImagingFactory);

    CComPtr<IWICBitmap> wicBmp;
    fac->CreateBitmapFromHBITMAP(hb, nullptr, WICBitmapIgnoreAlpha, &wicBmp);

    CComPtr<IWICStream> stm; fac->CreateStream(&stm);
    stm->InitializeFromFilename(path.c_str(), GENERIC_WRITE);

    CComPtr<IWICBitmapEncoder> enc;
    fac->CreateEncoder(GUID_ContainerFormatPng, nullptr, &enc);
    enc->Initialize(stm, WICBitmapEncoderNoCache);

    CComPtr<IWICBitmapFrameEncode> frame; CComPtr<IPropertyBag2> bag;
    enc->CreateNewFrame(&frame, &bag);
    frame->Initialize(bag);
    UINT w=0,h=0; wicBmp->GetSize(&w,&h);
    frame->SetSize(w,h);
    WICPixelFormatGUID fmt = GUID_WICPixelFormat32bppBGRA;
    frame->SetPixelFormat(&fmt);
    frame->WriteSource(wicBmp, nullptr);
    frame->Commit(); enc->Commit();
    return true;
}
```

---

# D) 오버레이 기본기 — 투명/반투명 윈도우

**목표**: 화면 위에 **반투명**으로 **선택 영역/가이드**를 그리되,  
1) **클릭 스루**(아래 윈도우 클릭 통과) 선택 가능,  
2) **부드러운 알파** 적용,  
3) **고DPI**에서 픽셀 정확.

## D-1) Layered Window 생성

- `WS_EX_LAYERED` + 필요 시 `WS_EX_TRANSPARENT`(마우스 이벤트를 **통과**시켜 클릭 스루)  
- **두 가지 방식**  
  1) **Per-Window Alpha**: `SetLayeredWindowAttributes(h, 0, alpha, LWA_ALPHA)` — 창 전체 동일 투명도  
  2) **Per-Pixel Alpha**: `UpdateLayeredWindow` — **ARGB 비트맵**으로 픽셀별 알파

### (1) Per-Window Alpha: 간단 오버레이

```cpp
BOOL CreateOverlaySimple(HWND hParent, RECT r)
{
    HWND h = CreateWindowExW(
        WS_EX_LAYERED|WS_EX_TOPMOST|WS_EX_TOOLWINDOW|WS_EX_TRANSPARENT,
        L"STATIC", L"", WS_POPUP, r.left, r.top, r.right-r.left, r.bottom-r.top,
        hParent, nullptr, AfxGetInstanceHandle(), nullptr);
    if (!h) return FALSE;

    // 반투명 전체(검은색 배경 40% 투명)
    SetLayeredWindowAttributes(h, 0, (BYTE)(255*0.6), LWA_ALPHA);
    ShowWindow(h, SW_SHOW);
    return TRUE;
}
```

> **장점**: 구현 쉬움  
> **단점**: 픽셀별 알파/그래픽은 불가 → **가장 쉬운 어둡게 덮개**에 적합

### (2) Per-Pixel Alpha: UpdateLayeredWindow (권장)

**절차**:  
- 창 크기만큼 **ARGB DIB** 생성  
- **GDI+로 도형/텍스트/알파** 그리기  
- `UpdateLayeredWindow`로 화면에 반영

```cpp
class COverlayLayered : public CWnd {
    CDC     m_mem; CBitmap m_bmp; SIZE m_sz{0,0};
public:
    BOOL CreateOverlay(RECT r) {
        CString cls = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW);
        DWORD ex = WS_EX_LAYERED|WS_EX_TOPMOST|WS_EX_TOOLWINDOW; // 클릭 차단하려면 WS_EX_TRANSPARENT 추가
        return CreateEx(ex, cls, L"", WS_POPUP, r, nullptr, 0);
    }
    void Resize(int w, int h) {
        if (m_sz.cx==w && m_sz.cy==h) return;
        m_mem.DeleteDC(); m_bmp.DeleteObject();
        HDC scr = ::GetDC(nullptr);
        m_mem.CreateCompatibleDC(scr);
        BITMAPINFO bi{}; bi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biWidth=w; bi.bmiHeader.biHeight=-h; bi.bmiHeader.biPlanes=1;
        bi.bmiHeader.biBitCount=32; bi.bmiHeader.biCompression=BI_RGB;
        void* pBits=nullptr; HBITMAP hb=CreateDIBSection(scr,&bi,DIB_RGB_COLORS,&pBits,nullptr,0);
        m_bmp.Attach(hb);
        m_mem.SelectObject(&m_bmp);
        m_sz = {w,h};
        ::ReleaseDC(nullptr, scr);
    }
    void DrawOverlay(const RECT& rSel)
    {
        // 1) 배경 완전 투명 초기화
        Gdiplus::Graphics g(m_mem);
        g.SetCompositingMode(Gdiplus::CompositingModeSourceCopy);
        g.Clear(Gdiplus::Color(0,0,0,0));

        // 2) 화면 어둡게(반투명 블랙)
        g.SetCompositingMode(Gdiplus::CompositingModeSourceOver);
        Gdiplus::SolidBrush dark(Gdiplus::Color(160,0,0,0)); // A=160/255
        g.FillRectangle(&dark, 0,0, m_sz.cx, m_sz.cy);

        // 3) 선택 영역은 밝게(구멍 뚫기 효과) → SourceCopy로 투명 덮기
        Gdiplus::SolidBrush clear(Gdiplus::Color(0,0,0,0));
        g.SetCompositingMode(Gdiplus::CompositingModeSourceCopy);
        g.FillRectangle(&clear, rSel.left, rSel.top, rSel.right-rSel.left, rSel.bottom-rSel.top);

        // 4) 선택 테두리/핸들
        g.SetCompositingMode(Gdiplus::CompositingModeSourceOver);
        Gdiplus::Pen pen(Gdiplus::Color(255,0,120,215), 2.0f);
        g.DrawRectangle(&pen, (Gdiplus::Rect)Gdiplus::Rect(rSel.left, rSel.top, rSel.right-rSel.left, rSel.bottom-rSel.top));

        // 5) UpdateLayeredWindow
        POINT ptSrc{0,0};
        POINT ptPos{}; RECT win; GetWindowRect(m_hWnd, &win); ptPos.x=win.left; ptPos.y=win.top;
        BLENDFUNCTION bf{AC_SRC_OVER,0,255,AC_SRC_ALPHA};
        SIZE sz{m_sz.cx, m_sz.cy};
        HDC scr = ::GetDC(nullptr);
        UpdateLayeredWindow(m_hWnd, scr, &ptPos, &sz, m_mem, &ptSrc, 0, &bf, ULW_ALPHA);
        ::ReleaseDC(nullptr, scr);
    }
};
```

> **핵심**: **ARGB 32bpp** + **CompositingMode**로 **구멍 뚫기/반투명 덮개**를 구현.  
> 마우스 통과(클릭 스루)가 필요하면 `WS_EX_TRANSPARENT`를 class style에 추가.

---

# E) 선택 영역 도구 (Snipping UX)

- 오버레이 창을 **전체 화면**에 띄우고, 마우스 드래그로 **선택 사각형**을 만든 후 캡처.  
- **Shift/Alt**로 정비율/중심 기준 등 보조 기능.  
- 키보드 ESC 취소, Enter 확정, Space로 패닝(선택 이동) 등.

## E-1) 상호작용 골격

```cpp
class CSnippingOverlay : public COverlayLayered {
    bool   m_drag=false; POINT m_start{}, m_cur{};
public:
    BOOL Begin() {
        RECT v;
        v.left   = GetSystemMetrics(SM_XVIRTUALSCREEN);
        v.top    = GetSystemMetrics(SM_YVIRTUALSCREEN);
        v.right  = v.left + GetSystemMetrics(SM_CXVIRTUALSCREEN);
        v.bottom = v.top  + GetSystemMetrics(SM_CYVIRTUALSCREEN);
        if (!CreateOverlay(v)) return FALSE;
        SetWindowPos(HWND_TOPMOST, v.left, v.top, v.right-v.left, v.bottom-v.top, SWP_SHOWWINDOW);
        Resize(v.right-v.left, v.bottom-v.top);
        SetCapture(); // 마우스 캡처
        return TRUE;
    }
    afx_msg void OnMouseMove(UINT, CPoint pt){ if(m_drag){ m_cur=pt; Redraw(); } }
    afx_msg void OnLButtonDown(UINT, CPoint pt){ m_drag=true; m_start=m_cur=pt; Redraw(); }
    afx_msg void OnLButtonUp(UINT, CPoint){ if(m_drag){ m_drag=false; ReleaseCapture(); Redraw(); /*확정*/ } }
    afx_msg void OnKeyDown(UINT vk, UINT, UINT){ if(vk==VK_ESCAPE){ DestroyWindow(); } }
    void Redraw(){
        RECT sel{ min(m_start.x,m_cur.x), min(m_start.y,m_cur.y), max(m_start.x,m_cur.x), max(m_start.y,m_cur.y) };
        DrawOverlay(sel);
    }
    DECLARE_MESSAGE_MAP()
};
BEGIN_MESSAGE_MAP(CSnippingOverlay, COverlayLayered)
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_KEYDOWN()
END_MESSAGE_MAP()
```

> **고급화**:  
> - **스냅라인**: 셀/그리드/창 경계에 스냅  
> - **가이드**: 3×3 그리드, 중앙선 표시  
> - **라운드 선택/자유형 다각형**: GDI+ `GraphicsPath`

## E-2) 선택 결과 캡처

선택이 확정되면 **선택 사각형 스크린 좌표**를 사용해 `BitBlt`:

```cpp
HBITMAP CaptureRect(const RECT& r)
{
    HDC scr=GetDC(nullptr), mem=CreateCompatibleDC(scr);
    int w=r.right-r.left, h=r.bottom-r.top;
    BITMAPINFO bi{}; bi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth=w; bi.bmiHeader.biHeight=-h; bi.bmiHeader.biPlanes=1; bi.bmiHeader.biBitCount=32; bi.bmiHeader.biCompression=BI_RGB;
    void* p=nullptr; HBITMAP hb=CreateDIBSection(scr,&bi,DIB_RGB_COLORS,&p,nullptr,0);
    HGDIOBJ old=SelectObject(mem, hb);
    BitBlt(mem,0,0,w,h, scr, r.left, r.top, SRCCOPY);
    SelectObject(mem, old);
    DeleteDC(mem); ReleaseDC(nullptr, scr);
    return hb;
}
```

---

# F) 반투명 하이라이트/툴팁 HUD

## F-1) 특정 영역 하이라이트(네모/라운드/그림자)

```cpp
void DrawHighlight(Gdiplus::Graphics& g, const Gdiplus::Rect& r)
{
    // 외곽 그림자(간단한 페이크)
    for (int i=0;i<8;i++){
        BYTE a = (BYTE)(40 - i*5);
        Gdiplus::Pen sh(Gdiplus::Color(a,0,0,0), 1.0f + i*2.0f);
        g.DrawRectangle(&sh, r);
    }
    // 라운드 박스
    Gdiplus::GraphicsPath path;
    float rad=8.0f;
    auto addRound=[&](Gdiplus::RectF rc){
        path.Reset();
        path.AddArc(rc.X, rc.Y, rad, rad, 180, 90);
        path.AddArc(rc.X+rc.Width-rad, rc.Y, rad, rad, 270, 90);
        path.AddArc(rc.X+rc.Width-rad, rc.Y+rc.Height-rad, rad, rad, 0, 90);
        path.AddArc(rc.X, rc.Y+rc.Height-rad, rad, rad, 90, 90);
        path.CloseFigure();
    };
    addRound(Gdiplus::RectF((float)r.X,(float)r.Y,(float)r.Width,(float)r.Height));
    Gdiplus::SolidBrush b(Gdiplus::Color(40, 0,120,215)); // 얇은 파란박스
    g.FillPath(&b, &path);
    Gdiplus::Pen p(Gdiplus::Color(200,0,120,215), 2.0f);
    g.DrawPath(&p, &path);
}
```

## F-2) HUD(정보 풍선, 좌표/크기 표시)

- `UpdateLayeredWindow` 비트맵에 **텍스트** 그려 함께 반영  
- DPI 반영한 폰트 사이즈

```cpp
void DrawHUD(Gdiplus::Graphics& g, const POINT pt, const CString& text)
{
    Gdiplus::FontFamily ff(L"Segoe UI");
    Gdiplus::Font f(&ff, 12.0f);
    Gdiplus::RectF rc; g.MeasureString(text, text.GetLength(), &f, Gdiplus::PointF(0,0), &rc);
    int pad=8;
    Gdiplus::RectF box((float)pt.x+16,(float)pt.y+16, rc.Width+pad*2, rc.Height+pad*2);
    Gdiplus::SolidBrush bg(Gdiplus::Color(200, 32,32,32));
    g.FillRectangle(&bg, box);
    Gdiplus::SolidBrush fg(Gdiplus::Color(255, 240,240,240));
    g.DrawString(text, -1, &f, Gdiplus::PointF(box.X+pad, box.Y+pad), &fg);
}
```

---

# G) 성능·DPI·보안·안정성 체크리스트

1. **캡처**: DIB 32bpp top-down으로 받기 → GDI+/WIC 직결 저장  
2. **BitBlt 실패** 케이스: 보호 콘텐츠/UWP/드라이버 → PrintWindow 보조, Magnification/DXGI 고려  
3. **멀티모니터**: 가상 화면 좌표(SM_XVIRTUALSCREEN …) 사용  
4. **DPI**: 화면 좌표는 물리 픽셀. HUD/폰트는 `GetDpiForWindow`로 pt→px 변환  
5. **UpdateLayeredWindow**: 드로우 전 **완전 투명 초기화**(SourceCopy) → SourceOver로 오버레이  
6. **클릭 스루**: `WS_EX_TRANSPARENT` + `SetWindowLong(h, GWL_EXSTYLE, …)`  
   - 필요 시 **히트테스트**로 특정 영역만 클릭 허용  
7. **Alt-Tab 숨김**: `WS_EX_TOOLWINDOW` 사용(작업 전환 리스트에서 제외)  
8. **TopMost**: 캡처/선택 중엔 `HWND_TOPMOST`, 끝나면 해제  
9. **리소스 수명**: HBITMAP/HDC/폰트/브러시 **반드시 정리**  
10. **보안 정책**: 일부 앱은 캡처 금지(`DRM`) → **예외 처리/실패 표시** 제공

---

# H) 고급 API 개요

## H-1) Magnification API (간단 샘플)

- `MagInitialize` 필요(매니페스트/권한)  
- 사각형 입력 → 확대된 비트맵 제공

```cpp
#include <magnification.h>
#pragma comment(lib, "Magnification.lib")
```

> 실제 사용은 **확대 미러 윈도우**를 만들어 소스 지정. 일반 캡처 대안으로는 설정/제약이 다소 큼.

## H-2) DXGI Desktop Duplication (DirectX 11)

- **고주사율**, 변경 영역(Dirty Rects) 제공 → **화면 녹화/스트리밍**에 최적  
- 복잡: DX11 디바이스/스왑체인/듀플리케이션 세션/맵핑 등  
- 일반 캡처 앱은 **GDI+WIC**로 충분. 고성능 필요 시 **별도 모듈**로 분리 설계.

## H-3) DWM API (썸네일 프리뷰)

- `DwmRegisterThumbnail`로 다른 창의 프리뷰를 **내 창**에 표시  
- 저장/비트맵 획득엔 적합하지 않고 **라이브 프리뷰 UI**에 적합

---

# I) 통합 예제: “SnipOverlay + Save PNG”

아래 코드는  
1) **전체 화면 반투명 오버레이** 띄우고  
2) **드래그로 선택**  
3) **해당 영역 캡처** 후  
4) **PNG로 저장**하는 간단 프로그램의 핵심부입니다.

```cpp
// 1) GDI+ 초기화
ULONG_PTR g_gdiplusToken;
void InitGDIPlus(){ Gdiplus::GdiplusStartupInput si; Gdiplus::GdiplusStartup(&g_gdiplusToken, &si, nullptr); }
void TermGDIPlus(){ Gdiplus::GdiplusShutdown(g_gdiplusToken); }

// 2) 오버레이 창
class CSnip : public COverlayLayered {
    bool m_drag=false; POINT m_a{}, m_b{};
public:
    BOOL Start() {
        RECT v; v.left=GetSystemMetrics(SM_XVIRTUALSCREEN); v.top=GetSystemMetrics(SM_YVIRTUALSCREEN);
        v.right=v.left+GetSystemMetrics(SM_CXVIRTUALSCREEN); v.bottom=v.top+GetSystemMetrics(SM_CYVIRTUALSCREEN);
        CreateOverlay(v);
        SetWindowPos(HWND_TOPMOST, v.left, v.top, v.right-v.left, v.bottom-v.top, SWP_SHOWWINDOW);
        Resize(v.right-v.left, v.bottom-v.top);
        SetCapture();
        DrawOverlay({0,0,0,0});
        return TRUE;
    }
    afx_msg void OnLButtonDown(UINT, CPoint pt){ m_drag=true; m_a=m_b=pt; Redraw(); }
    afx_msg void OnMouseMove(UINT, CPoint pt){ if(m_drag){ m_b=pt; Redraw(); } }
    afx_msg void OnLButtonUp(UINT, CPoint){ if(!m_drag) return; m_drag=false; ReleaseCapture();
        RECT r = GetSelRect();
        // 스크린 좌표로 변환
        RECT win; GetWindowRect(m_hWnd, &win);
        OffsetRect(&r, win.left, win.top);
        auto hb = CaptureRect(r);
        SaveHBITMAPAsPNG(hb, L"snip.png");
        DeleteObject(hb);
        DestroyWindow();
    }
    afx_msg void OnKeyDown(UINT vk, UINT, UINT){ if (vk==VK_ESCAPE){ DestroyWindow(); } }
    RECT GetSelRect() const {
        RECT r{ min(m_a.x,m_b.x), min(m_a.y,m_b.y), max(m_a.x,m_b.x), max(m_a.y,m_b.y) };
        return r;
    }
    void Redraw(){ DrawOverlay(GetSelRect()); }
    DECLARE_MESSAGE_MAP()
};
BEGIN_MESSAGE_MAP(CSnip, COverlayLayered)
    ON_WM_LBUTTONDOWN()
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_KEYDOWN()
END_MESSAGE_MAP()

// 3) 사용: Ctrl+Shift+S 같은 단축키에서
void DoSnip() {
    CSnip* s = new CSnip();
    s->Start(); // 자기 수명: 캡처 후 DestroyWindow → delete는 소멸자에서 처리(필요 시 PostNcDestroy)
}
```

> 파일이 저장되는 작업 폴더/권한을 확인하세요(테스트는 바탕화면 등).

---

# J) 확장 아이디어

- **윈도우 픽커**: 크로스헤어 커서를 움직이면 **현재 아래 HWND**의 경계가 오버레이로 하이라이트( `WindowFromPoint` + `GetWindowRect` )  
- **자동 스크롤 캡처**: 웹페이지/문서 자동 스크롤 → 여러 이미지 **스티칭**(OpenCV 등)  
- **OCR**: 캡처 후 OCR 라이브러리 호출(Tesseract/Windows.Media.Ocr)  
- **주석/마크업**: 화살표/번호/형광펜, 도형/텍스트 삽입  
- **프레임 버퍼 스트림**: DXGI Duplication + H.264(미디어 파운데이션)로 라이브 스트리밍

---

## 마무리

- **GDI BitBlt + UpdateLayeredWindow** 조합만으로도 **전문 캡처/오버레이** UX 구현 가능.  
- **선택 영역**은 **투명 레이어** 위에 **어둡게 덮고 구멍 뚫기** 패턴이 가장 직관적입니다.  
- 고급/고성능이 필요하면 **Magnification** 또는 **DXGI Duplication**을 병행.  
- 이 글의 스니펫을 **프로젝트 템플릿**으로 삼아,  
  - 캡처 범위(전체/모니터/창/선택),  
  - 저장 옵션(PNG/JPEG/클립보드),  
  - 오버레이 보조선/스냅/툴팁  
  을 빠르게 확장해 보세요.
