---
layout: post
title: 선형대수 - 3×3 행렬의 행렬식과 부피 변화, 반사의 의미
date: 2025-06-06 20:20:23 +0900
category: 선형대수
---
# 📦 3×3 행렬의 행렬식(det), 부피 변화, 그리고 “반사(뒤집힘)”의 의미 완전 정복

> **핵심 요약**  
> - 3차원 선형변환 \(A\in\mathbb{R}^{3\times 3}\)는 단위 입방체를 평행육면체로 보낸다. 이때 **부피 스케일**은  
>   $$\boxed{\text{새 부피} = |\det(A)|\times\text{원래 부피}}$$  
> - \(\det(A)>0\): 방향(오리엔테이션) **보존**, \(\det(A)<0\): **반사(뒤집힘)** 포함(오리엔테이션 반전), \(\det(A)=0\): **납작해짐(차원 축소)**

---

## 1. 3×3 선형변환과 평행육면체

\(A\)의 **열벡터**를 \(\mathbf{a},\mathbf{b},\mathbf{c}\)라 하면
\[
A=[\ \mathbf{a}\ \ \mathbf{b}\ \ \mathbf{c}\ ] \in \mathbb{R}^{3\times 3}.
\]
기하적으로 이는 **표준기저** \((\mathbf{e}_1,\mathbf{e}_2,\mathbf{e}_3)\)을 각각 \(\mathbf{a},\mathbf{b},\mathbf{c}\)로 보낸다.  
단위 입방체는 **평행육면체(parallelepiped)**로 바뀌며, 그 **부피**는
\[
\boxed{V=|\mathbf{a}\cdot(\mathbf{b}\times \mathbf{c})|=|\det([\mathbf{a}\ \mathbf{b}\ \mathbf{c}])|=|\det(A)|}.
\]
- \(\mathbf{b}\times\mathbf{c}\): 밑면의 **법선벡터×면적**(방향 포함)  
- \(\mathbf{a}\cdot(\cdot)\): 그 법선 방향으로 투영된 **높이**

> **직관**: 부피는 “밑면(벡터 곱) × 높이(내적)”로 계산되며, 이 한 줄을 **행렬식**이 모두 담는다.

---

## 2. 부호와 방향(오리엔테이션): 왜 \(\det<0\)이면 “반사”인가?

- \(\det(A)>0\): 오른손 좌표계 → **오른손 유지**(방향 보존).  
- \(\det(A)<0\): 오른손 좌표계 → **왼손 좌표계**로 바뀜(방향 반전).  
  이는 변환에 **반사(reflection)** 또는 **반사와 회전의 합성**(roto-reflection)이 포함되었음을 뜻한다.

> **참고**: **직교행렬** \(Q\)에서 \(\det(Q)=+1\)이면 **순수 회전**(\(SO(3)\)), \(\det(Q)=-1\)이면 **반사(혹은 반사+회전)**을 포함한 **부정직교** 변환.

---

## 3. 대표 행렬 가족에서의 det·부피·반사

### 3.1 스케일(확대/축소)
\[
S=\mathrm{diag}(s_x,s_y,s_z),\quad \det(S)=s_x s_y s_z,\quad |\,\det(S)\,|=\text{부피 배수}.
\]
- 예: \(\mathrm{diag}(2,3,0.5)\Rightarrow \det=3\) → 부피 3배.
- 음수 스케일(축 방향 뒤집기) 하나만 있어도 전체 부호는 음수가 될 수 있음 ⇒ **반사 포함**.

### 3.2 쉬어(shear)
\[
H=\begin{bmatrix}1&k&0\\0&1&0\\0&0&1\end{bmatrix},\quad \det(H)=1.
\]
- **부피 불변**(늘어지지만 찌그러질 뿐, 부피는 그대로).  
- 쉬어는 방향을 뒤집지 않음(부호 \(+1\)).

### 3.3 반사(평면 반사 = 하우스홀더)
단위 법선 \(\mathbf{n}\)에 대한 평면 반사:
\[
\boxed{H=I-2\,\mathbf{n}\mathbf{n}^\top,\quad \det(H)=-1}
\]
- \(\mathbf{n}\) 방향 고유값 \(-1\), 그 직교평면에서 \(+1\) → 고유값 곱 \(-1\).  
- 예: \(z\)-축 반사 \(\Rightarrow \mathrm{diag}(1,1,-1),\ \det=-1\).

### 3.4 직교투영(차원 축소)
평면(법선 \(\mathbf{n}\))으로의 **직교투영**:
\[
P=I-\mathbf{n}\mathbf{n}^\top,\quad \det(P)=0.
\]
- 한 축(법선)으로 **완전히 납작해짐** → 부피 0 → **특이(singular)**.

---

## 4. 수학적 근거 ①: SVD로 본 부피 스케일

모든 \(A\)는 \(A=U\Sigma V^\top\) (SVD)로 분해.  
- \(U,V\): 직교(\(|\det|=1\)) → 부피 보존(부호만 ±).  
- \(\Sigma=\mathrm{diag}(\sigma_1,\sigma_2,\sigma_3)\): **축 방향 스케일** → 부피 스케일 \(=\sigma_1\sigma_2\sigma_3\).  
따라서
\[
|\det(A)|=|\det(U)\det(\Sigma)\det(V^\top)|=\sigma_1\sigma_2\sigma_3.
\]
즉, **부피 변화량 = 특이값의 곱**. 부호는 \(U,V\)의 부호(오리엔테이션)에 의해 결정.

---

## 5. 수학적 근거 ②: 삼중스칼라곱(Triple Scalar Product)

세 벡터 \(\mathbf{a},\mathbf{b},\mathbf{c}\)의 부피:
\[
V=|\mathbf{a}\cdot(\mathbf{b}\times\mathbf{c})|=|\det([\mathbf{a}\ \mathbf{b}\ \mathbf{c}])|.
\]
- 값의 **부호**는 \((\mathbf{a},\mathbf{b},\mathbf{c})\)의 **오리엔테이션(손잡이)**을 나타냄.  
- 크기는 부피, 0이면 동일평면/직선에 눌림(종속).

---

## 6. 예제로 이해하기

### 6.1 순수 회전
\[
R_z(\theta)=\begin{bmatrix}
\cos\theta&-\sin\theta&0\\
\sin\theta& \cos\theta&0\\
0&0&1
\end{bmatrix},\quad \det(R_z)=1,\ \text{부피 유지},\ \text{방향 보존}.
\]

### 6.2 반사 + 축소
\[
A=\mathrm{diag}(2,\,0.5,\,-3)\Rightarrow \det(A)=2\times 0.5\times(-3)=-3.
\]
- **부피 3배** 확대지만 **오리엔테이션 반전**(반사 포함).

### 6.3 쉬어(부피 보존)
\[
A=\begin{bmatrix}1&2&0\\0&1&0\\0&0&1\end{bmatrix},\quad \det(A)=1.
\]
- 입방체가 평행육면체로 찌그러질 뿐, **부피 동일**.

### 6.4 납작해짐(특이)
\[
A=\begin{bmatrix}1&0&0\\0&1&0\\0&0&0\end{bmatrix},\quad \det(A)=0.
\]
- \(z\)-성분이 사라져 **평면으로 투영** → 부피 0.

---

## 7. 파이썬 실습 (NumPy): 부피·반사 체크

```python
import numpy as np

def volume_scale_and_reflection(A):
    det = np.linalg.det(A)
    vol_scale = abs(det)
    orientation = "preserved (+)" if det > 0 else "reversed (-)" if det < 0 else "collapsed (0)"
    return det, vol_scale, orientation

# 1. z-축 반사
A_reflect_z = np.diag([1, 1, -1])
print(volume_scale_and_reflection(A_reflect_z))  # (-1.0, 1.0, 'reversed (-)')

# 2. 스케일링
A_scale = np.diag([2.0, 0.5, 3.0])
print(volume_scale_and_reflection(A_scale))      # (3.0, 3.0, 'preserved (+)')

# 3. 쉬어
A_shear = np.array([[1, 2, 0],
                    [0, 1, 0],
                    [0, 0, 1]], dtype=float)
print(volume_scale_and_reflection(A_shear))      # (1.0, 1.0, 'preserved (+)')

# 4. 특이(납작)
A_singular = np.array([[1,0,0],[0,1,0],[0,0,0]], dtype=float)
print(volume_scale_and_reflection(A_singular))   # (0.0, 0.0, 'collapsed (0)')
```

### 삼중스칼라곱 = det 검증
```python
# 임의 벡터로 평행육면체 부피를 두 방식으로 비교
a = np.array([1,2,0.5])
b = np.array([0,1,3])
c = np.array([2,0,1])

A = np.column_stack([a,b,c])          # [a b c]
detA = np.linalg.det(A)
triple = a.dot(np.cross(b, c))

print(detA, triple, abs(detA), abs(triple))      # 같은 값(부호도 동일)
```

---

## 8. PyTorch로 빠른 벡터라이즈 (선호 프레임워크)

```python
import torch

def torch_det_orientation(A):
    # A: (..., 3, 3)
    det = torch.linalg.det(A)
    ori = torch.where(det > 0, torch.tensor(1),
          torch.where(det < 0, torch.tensor(-1), torch.tensor(0)))
    return det, ori

# 배치 예시
A = torch.stack([
    torch.diag(torch.tensor([1.,1.,-1.])),                     # 반사
    torch.diag(torch.tensor([2.,0.5,3.])),                     # 스케일
    torch.tensor([[1.,2.,0.],[0.,1.,0.],[0.,0.,1.]]),          # 쉬어
])
det, ori = torch_det_orientation(A)
print("det:", det)     # tensor([-1.,  3.,  1.])
print("ori:", ori)     # tensor([-1,  1,  1])
```

---

## 9. 응용 스냅샷

### 9.1 다변수 적분: 좌표변환의 야코비안
변수변환 \(\Phi:\mathbf{u}\mapsto\mathbf{x}\)에서
\[
\iiint_{\Omega_x} f(\mathbf{x})\,d\mathbf{x}
=\iiint_{\Omega_u} f(\Phi(\mathbf{u}))\ \big|\det J_\Phi(\mathbf{u})\big|\ d\mathbf{u}.
\]
- \(|\det J|\)는 **부피 스케일**. 음수는 오리엔테이션 반전이지만, 적분은 **절대값** 사용.  
- 구면좌표의 야코비안 \(r^2\sin\phi\)가 대표적 3×3 예.

### 9.2 컴퓨터 그래픽스: 노멀 변환
일반 선형변환 \(A\)에서 **노멀**은 \(\mathbf{n}'\propto (A^{-1})^\top \mathbf{n}\).  
- \(\det(A)<0\)면 오리엔테이션 반전 → **백페이스 컬링**/조명 계산 시 주의.

### 9.3 로보틱스/3D 기하
- 강체운동의 회전부분 \(R\)은 \(\det(R)=+1\).  
- \(\det=-1\)이 섞이면 **미러링**이 있어, 로봇 포즈/캘리브레이션 파이프라인에서 **불량 데이터** 신호일 수 있음.

### 9.4 데이터/기하 안정성
- \(|\det(A)|\approx 0\)이면 거의 납작 → **수치 불안정**(조건수↑).  
  → `slogdet`(부호와 로그크기), SVD(특이값 곱)로 안정적으로 판단.

---

## 10. “반사”를 수식으로: 하우스홀더(평면 반사)

단위 법선 \(\mathbf{n}\)에 대한 평면에 점 \(\mathbf{x}\)를 반사:
\[
\mathbf{x}'=\underbrace{\big(I-2\mathbf{n}\mathbf{n}^\top\big)}_{H}\mathbf{x},\qquad \det(H)=-1.
\]
- **두 번 반사**하면 회전(또는 항등)이 됨 → \((-1)\times(-1)=+1\).

```python
import numpy as np

def householder_reflection(n):
    n = np.asarray(n, dtype=float)
    n = n / np.linalg.norm(n)
    H = np.eye(3) - 2*np.outer(n, n)
    return H, np.linalg.det(H)

H, d = householder_reflection([0,0,1])   # z=0 평면 반사
print(d, "\n", H)  # det ~ -1, diag([1,1,-1])
```

---

## 11. “부피 그대로 맞나?”—실험으로 체감

임의 \(A\)에 대해 **평행육면체 부피**를  
(1) `abs(det(A))` 와 (2) **격자 샘플링 근사**로 비교:

```python
import numpy as np

# 랜덤 행렬(가역)
rng = np.random.default_rng(7)
A = rng.normal(size=(3,3))
while abs(np.linalg.det(A)) < 1e-3:
    A = rng.normal(size=(3,3))

# (1) 이론 부피 배수
theory = abs(np.linalg.det(A))

# (2) 격자 샘플 (0~1)^3를 변환 → bounding box로 근사
grid = np.stack(np.meshgrid(np.linspace(0,1,21),
                            np.linspace(0,1,21),
                            np.linspace(0,1,21)), axis=-1).reshape(-1,3)
mapped = grid @ A.T
mins, maxs = mapped.min(0), mapped.max(0)
bbox_vol = np.prod(maxs - mins)       # 상계(실제 평행육면체는 이보다 작거나 같음)

print("abs(det(A)) =", theory)
print("bbox volume (upper bound) =", bbox_vol)
```

> 평행육면체의 실제 부피는 `abs(det(A))`이며, 격자 포인트의 bounding box 부피는 **상계**다(느슨하지만 감각적으로 ‘스케일’을 보여줌).

---

## 12. 3D 기하 문제에 바로 쓰는 체크리스트

- **부피 스케일**: \(|\det(A)|\)  
- **오리엔테이션**: \(\mathrm{sign}(\det(A))\) (±1, 0)  
- **반사 여부**: \(\det(A)<0\) → **있음**  
- **퇴화(납작)**: \(\det(A)=0\) → 특이, 차원 축소  
- **수치판정**: det가 아주 작을 땐 `slogdet`/SVD(특이값 곱)로 검증  
- **정사영/투영**: 대부분 \(\det=0\) (부피 소멸)  
- **회전**: 직교 \(Q\) with \(\det=+1\)  
- **하우스홀더**: \(H=I-2nn^\top\), \(\det=-1\)

---

## 13. 추가 예제: 사면체 부피 & 오리엔테이션

네 점 \(\mathbf{p}_0,\mathbf{p}_1,\mathbf{p}_2,\mathbf{p}_3\)의 **사면체 부피**:
\[
\boxed{V=\frac{1}{6}\Big|\det\big([\mathbf{p}_1-\mathbf{p}_0\ \ \mathbf{p}_2-\mathbf{p}_0\ \ \mathbf{p}_3-\mathbf{p}_0]\big)\Big|}
\]
- 부호는 \((\mathbf{p}_1-\mathbf{p}_0,\ \mathbf{p}_2-\mathbf{p}_0,\ \mathbf{p}_3-\mathbf{p}_0)\)의 손잡이를 말해줌.

```python
import numpy as np

def tet_volume(p0,p1,p2,p3):
    A = np.column_stack([p1-p0, p2-p0, p3-p0])
    return abs(np.linalg.det(A))/6.0

p0 = np.array([0.,0.,0.])
p1 = np.array([1.,0.,0.])
p2 = np.array([0.,1.,0.])
p3 = np.array([0.,0.,1.])

print(tet_volume(p0,p1,p2,p3))  # 1/6
```

---

## 14. 자주 하는 실수와 방어 요령

1. **정방행렬이 아닌데 det로 부피 판단** → ❌  
   3×3이 아니면 det 의미가 달라짐. (좌표변환의 야코비안이나 열 3개짜리 블록으로 판단)
2. **수치적으로 0에 가까운 det**를 0으로 단정 → ❌  
   `np.linalg.svd`의 **최소 특이값**·조건수로 안정성 확인.
3. **노멀을 A로 직접 변환** → ❌  
   일반 선형변환에서 노멀은 \((A^{-1})^\top\)로 변환.
4. **부호 해석 착각**: \(|\det|\)는 부피, \(\mathrm{sign}(\det)\)는 방향(반사 여부).

---

## 15. 요약 표

| 케이스 | \(\det(A)\) | 부피 스케일 \(|\det|\) | 방향(오리엔테이션) | 의미 |
|---|---:|---:|---|---|
| 회전 | \(+1\) | 1 | 보존 | 강체 회전 |
| 반사 | \(-1\) | 1 | 반전 | 평면 반사(뒤집힘) |
| 스케일 | \(s_x s_y s_z\) | \(|s_x s_y s_z|\) | 부호에 따름 | 축별 확대/축소 |
| 쉬어 | \(1\) | 1 | 보존 | 찌그러짐(부피 불변) |
| 특이(투영 등) | \(0\) | 0 | — | 차원 축소/납작 |

---

## 16. 한 줄 결론

- **부피 변화량**은 \(\boxed{|\det(A)|}\),  
- **반사 포함 여부**는 \(\boxed{\mathrm{sign}(\det(A))}\),  
- **납작해짐 여부**는 \(\boxed{\det(A)=0}\).

> 이 세 가지를 기억하면, 3D 선형변환의 기하학을 거의 즉시 읽어낼 수 있다.