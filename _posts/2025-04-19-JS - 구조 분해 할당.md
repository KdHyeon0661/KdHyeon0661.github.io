---
layout: post
title: JavaScript - 구조 분해 할당
date: 2025-04-19 21:20:23 +0900
category: JavaScript
---
# 구조 분해 할당(Destructuring)

## 빠른 로드맵

- **배열 구조 분해**: 순서 기반, 이터러블 지원, 누락/건너뛰기/나머지.
- **객체 구조 분해**: 키(프로퍼티) 이름 기반, 별칭/기본값, 중첩.
- **선언 vs 대입**: 대입식의 좌변이 패턴일 때 괄호 필요할 수 있음.
- **기본값 평가**: `undefined`에만 발동, 표현식은 **지연 평가**.
- **나머지 `...rest`**: 마지막에만 사용, 얕은 복사.
- **함수 매개변수**: 인자 자체에 패턴 적용, 전체 인자 기본값과 중첩 기본값.
- **반복/이터러블**: `for...of`와 결합, `Object.entries`와 궁합.
- **실전 패턴**: 안전 추출, 옵션 병합, 다중 반환, 스왑, JSON 파싱, React/Node 핸들러 등.
- **함정**: `null` 기본값 미적용, 중첩 존재 가정, 선언 컨텍스트, 중복 키, 성능/가독성.

---

## 배열 구조 분해 — 순서 기반

```js
const numbers = [1, 2, 3];
const [a, b, c] = numbers;
console.log(a, b, c); // 1 2 3
```

### 일부만/건너뛰기

```js
const [first, , third] = [10, 20, 30];
console.log(first, third); // 10 30
```

### 기본값 (undefined 에만 적용)

```js
const [x = 100, y = 200] = [undefined];
console.log(x, y); // 100 200

const [p = 1] = [null];
console.log(p); // null  (기본값은 undefined에서만 반응)
```

### 나머지 요소 수집 `...rest`

```js
const [head, ...tail] = [1, 2, 3, 4];
console.log(head); // 1
console.log(tail); // [2, 3, 4]
```
> 나머지는 **마지막 위치에서만** 가능.

### 이터러블 전반에 적용(문자열/Set/제너레이터)

```js
const [c1, c2] = "OK";         // "O", "K"
const [s1, s2] = new Set([7,8]); // 7, 8

function* gen(){ yield 10; yield 20; }
const [g1, g2] = gen();        // 10, 20
```

### 스왑(swap)

```js
let a1 = 1, a2 = 2;
[a1, a2] = [a2, a1];
console.log(a1, a2); // 2 1
```

---

## 객체 구조 분해 — 키 이름 기반

```js
const user = { name: "Alice", age: 25 };
const { name, age } = user;
console.log(name, age); // "Alice", 25
```

### 부여

```js
const { name: userName } = user;
console.log(userName); // "Alice"
```

### 기본값

```js
const { city = "Seoul" } = {};
console.log(city); // "Seoul"

const person = { city: null };
const { city: c = "Seoul" } = person;
console.log(c); // null  (undefined에만 기본값 적용)
```

### 나머지 속성 `...rest`

```js
const { name: n, ...rest } = { name: "Bob", age: 30, isAdmin: true };
console.log(n);    // "Bob"
console.log(rest); // { age: 30, isAdmin: true }
```

### 중첩 구조 분해

```js
const cfg = { server: { host: "127.0.0.1", port: 8080 } };
const { server: { host, port } } = cfg;
console.log(host, port); // "127.0.0.1" 8080
```
> 중첩에서 **중간 객체 식별자**(예: `server`)는 남지 않는다. 필요하면 별도 바인딩:
```js
const { server, server: { host: h } } = cfg;
console.log(server, h);
```

### 존재 안 할 수 있는 중첩에 기본값 결합

```js
const app = {};
const {
  server: {
    host: H = "localhost",
    port: P = 3000
  } = {}    // server 자체의 디폴트 객체
} = app;
console.log(H, P); // "localhost", 3000
```

### 계산된 키/심볼 키

```js
const K = "token";
const S = Symbol("id");
const obj = { [K]: "abc", [S]: 123 };
const { [K]: token, [S]: id } = obj;
console.log(token, id); // "abc", 123
```

---

## “선언” vs “대입” — 괄호 규칙과 평가 순서

### 선언(Declaration)

```js
const {a, b} = { a: 1, b: 2 };
let [x, y] = [3, 4];
```

### — 괄호 필요할 수 있음

객체 **대입 구조 분해**는 좌변이 블록으로 오해될 수 있어 **괄호**를 씌운다.
```js
let a, b;
({ a, b } = { a: 10, b: 20 }); // 괄호 필수
console.log(a, b); // 10 20
```
배열은 괄호 불필요:
```js
[a, b] = [b, a];
```

### 평가 순서 & 지연 평가

- 우변(소스) → 좌변(패턴) 순으로 평가.
- 기본값은 **해당 바인딩이 `undefined`일 때**만 **지연 평가**로 실행.
```js
function heavy() { console.log("compute"); return 99; }

const [m = heavy()] = [5]; // heavy() 호출 안 됨 (m은 5)
const [n = heavy()] = [undefined]; // compute → n=99
```

---

## 기본값 — undefined에서만, 의존 기본값

### `undefined`에서만 동작

```js
const [d1 = 1] = [null];         // d1 = null
const { v = 1 } = { v: 0 };      // v = 0
```

### 다른 변수에 의존하는 기본값(선언 순서 중요)

```js
const [a1 = 1, a2 = a1 * 2] = [undefined, undefined];
console.log(a1, a2); // 1, 2

const { x1 = 3, y1 = x1 + 4 } = {};
console.log(x1, y1); // 3, 7
```

---

## 나머지 `...rest` — 규칙과 한계

- **마지막 위치**에서만 허용(배열/객체 모두).
- **얕은 복사**(중첩 객체는 공유).
- 객체의 나머지는 **열거 가능한 own 속성**만 포함(심볼 제외).

```js
const src = { a:1, nested:{ n:9 } };
const { a, ...others } = src;
others.nested.n = 100;
console.log(src.nested.n); // 100 (얕은 복사)
```

---

## 함수 매개변수 구조 분해 — 안정적 API

### 객체 인자 패턴

```js
function connect({
  host = "localhost",
  port = 3306,
  secure = false,
} = {}) {                         // 전체 인자의 기본값(빈 객체)
  return { host, port, secure };
}

connect();                        // 안전
connect({ port: 5432 });          // {host:"localhost", port:5432, secure:false}
```

### 중첩 디폴트

```js
function init({
  db: {
    url = "sqlite://:memory:",
    pool = 5
  } = {}
} = {}) {
  return { url, pool };
}
```

### 배열 인자

```js
function sum([a, b] = [0, 0]) {
  return a + b;
}
sum([3, 5]); // 8
sum();       // 0
```

### 나머지 인자와 혼합

```js
function groupBy([head, ...tail] = []) {
  return { head, tail };
}
```

---

## 반복/이터러블과 구조 분해 — 궁합 최고

### `for...of` + 배열/제너레이터

```js
for (const [i, val] of [10, 20, 30].entries()) {
  console.log(i, val);
}
```

### `Object.entries`와 객체 순회

```js
const user = { name: "Kim", age: 29 };
for (const [k, v] of Object.entries(user)) {
  console.log(k, v);
}
```

### Map/Set

```js
const m = new Map([["a",1],["b",2]]);
for (const [k, v] of m) console.log(k, v);

const s = new Set([1,2,3]);
for (const v of s) console.log(v);
```

---

## 실전 패턴 모음

### 안전 추출(옵셔널 체이닝 + 기본값)

```js
const user = {};
const city = user.profile?.address?.city ?? "N/A";
const { profile: { address: { zip = "00000" } = {} } = {} } = user;
```

### 옵션 병합(기본 + 오버라이드)

```js
const defaults = { timeout: 5000, retries: 2, log: false };
function setup(cfg = {}) {
  const { timeout = defaults.timeout, retries = defaults.retries, log = defaults.log } = cfg;
  return { timeout, retries, log };
}
```

### 다중 반환값(튜플 스타일)

```js
function divmod(a, b) {
  return [Math.floor(a / b), a % b];
}
const [q, r] = divmod(13, 5); // 2, 3
```

### HTTP 응답 파싱

```js
const response = { data: { id: 1, title: "hello" }, status: 200 };
const { data: { id, title }, status } = response;
```

### React/JSX Props

```js
function Profile({ name, age, ...rest }) {
  return <div {...rest}>{name} ({age})</div>;
}
```

### 이벤트 객체 빠른 추출

```js
document.addEventListener("click", ({ clientX:x, clientY:y }) => {
  console.log(x, y);
});
```

### 정규식 매치 결과

```js
const [, year, month, day] = "2025-11-09".match(/(\d{4})-(\d{2})-(\d{2})/);
console.log(year, month, day); // "2025" "11" "09"
```

### 불변 업데이트(리덕스/상태)

```js
const state = { user: { name: "A", tags: ["js"] } };
const { user } = state;
const newState = {
  ...state,
  user: { ...user, tags: [...user.tags, "node"] }
};
```

### Node 스타일 콜백 `(err, data)`

```js
fs.readFile("file.txt", (err, data) => {
  const [e, d] = [err, data]; // 또는 if (err) ...
});
```

---

## 성능/가독성 팁

- **짧고 의미 있는 추출**을 지향. 중첩이 깊어지면 **중간 변수**로 나눠라.
- 대량 루프 안에서는 과도한 구조 분해가 **미미하게 느릴 수 있음**. 성능이 중요하면 프로파일링.
- **기본값 표현식**은 지연 평가이므로 무거운 계산을 기본값에 둬도 안전하지만, **명확성**을 위해 분리하는 것도 좋다.
- 객체 구조 분해는 **own + 열거 가능** 속성만 대상으로 하는 것이 아니라, **정의된 키 이름**으로 정확히 집어온다. 존재하지 않으면 `undefined`.

---

## 흔한 함정과 회피법

### `null`은 기본값 트리거가 아니다

```js
const { x = 1 } = { x: null };
console.log(x); // null
```
필요하면 `??`와 결합:
```js
const { x: raw } = { x: null };
const x2 = raw ?? 1; // 1
```

### 존재 보장되지 않는 중첩

```js
// 오류: Cannot destructure property 'city' of undefined
// const { profile: { address: { city } } } = user;

// 안전 버전
const { profile: { address: { city } = {} } = {} } = user || {};
```

### 선언 컨텍스트와 괄호

```js
let a;
// ({ a } = { a: 1 }); // OK
// { a } = { a: 1 };   // SyntaxError (블록으로 해석)
```

### 나머지 위치/중복 키

- `...rest`는 **마지막** 이어야 한다.
- 같은 키를 두 번 바인딩하면 마지막 것이 유효.
```js
const { k, k: alias } = { k: 1 }; // k=1, alias=1
```

### 배열 “홀(holes)”과 누락

```js
const arr = [ , 2 ];          // length=2, arr[0] === undefined
const [x = 7, y] = arr;       // x=7, y=2  (기본값은 undefined에만)
```

### 프로토타입/접근자 주의

- 구조 분해는 **프로퍼티 접근**이므로 접근자(getter)가 실행될 수 있다.
- 사이드 이펙트가 있는 getter라면 주의.

---

## 패턴 리팩터링 — “왼쪽만 바꿔도 가독성 상승”

### 긴 체인 캡쳐

```js
// before
const city = user && user.profile && user.profile.address
  ? user.profile.address.city
  : "N/A";

// after
const { profile: { address: { city = "N/A" } = {} } = {} } = user || {};
```

### “옵션 오브젝트” 일반화

```js
function createButton({
  text = "OK",
  size = "md",
  onClick = () => {}
} = {}) {/* ... */}
```

### transform + entries

```js
const input = { a:1, b:2, c:3 };
const doubled = Object.fromEntries(
  Object.entries(input).map(([k, v]) => [k, v * 2])
);
```

---

## 테스트 가능한 스니펫(동작 체감)

### 선언 vs 대입

```js
let a, b;
({ a, b } = { a: 1, b: 2 });
console.log(a, b);
```

### 기본값 지연 평가

```js
let hit = 0;
function tick(){ hit++; return 9; }
const [v = tick()] = [5];       // tick 실행 안 됨
const [w = tick()] = [undefined]; // tick 실행 (hit=1)
console.log(hit); // 1
```

### for...of + entries

```js
for (const [i, val] of ["x","y","z"].entries()) {
  console.log(i, val);
}
```

### 안전 추출 조합

```js
const res = {};
const { data: { items = [] } = {} } = res;
console.log(items.length); // 0
```

---

## 미니 퀴즈

```js
// Q1: 결과?
const [a = 1, b = a * 2] = [undefined, undefined];
console.log(a, b);

// Q2: 결과?
const { x = 1 } = { x: null };
console.log(x);

// Q3: 오류 없이 city를 "N/A"로 얻으려면?
// const { profile: { addr: { city } } } = user;

// Q4: 대입 구조 분해가 문법 오류인 줄 맞춰라
let u, v;
// { u, v } = { u:1, v:2 }; // ?
// ({ u, v } = { u:1, v:2 }); // ?

// Q5: entries 변환
const src = { a:1, b:2 };
const out = Object.fromEntries(Object.entries(src).map(([k, v]) => [k, v+1]));
console.log(out);
```

**해설 힌트**
- Q1: `a=1`, `b=2`.
- Q2: `null`은 기본값 트리거가 아님 → `null`.
- Q3: `const { profile: { addr: { city = "N/A" } = {} } = {} } = user || {};`
- Q4: 첫 줄은 SyntaxError(블록으로 인식), 둘째 줄은 OK.
- Q5: `{ a:2, b:3 }`.

---

## 체크리스트 요약

- [ ] **undefined**일 때만 기본값. `null`은 `??`로 처리.
- [ ] **대입 구조 분해**의 객체 패턴은 괄호로 감싸기.
- [ ] **중첩**은 `= {}`로 안전 망을 깔아라.
- [ ] **나머지**는 마지막에만, 얕은 복사임을 인지.
- [ ] **이터러블** 전반에 배열 패턴 적용 가능(문자열/Set/제너레이터).
- [ ] 대량/핫 루프에서는 **과도한 구조 분해**가 미세한 오버헤드를 낼 수 있음 — 필요 시 단순 접근.
- [ ] 가독성이 떨어지면 **중간 변수**로 나누거나 **함수 인자 구조 분해**로 이전.

---

## 결론

구조 분해 할당은 **데이터 추출을 선언적으로 표현**하게 해준다.
기본값의 **지연 평가**와 `undefined` 조건, **선언 vs 대입**의 괄호 규칙, **안전한 중첩 디폴트**, **이터러블 결합**만 정확히 이해하면
현대 자바스크립트 코드의 **가독성·견고성·재사용성**을 크게 끌어올릴 수 있다.
이 글의 패턴을 실무 코드에 **점진적으로 도입**해, 긴 체인 접근/옵션 처리/반복 변환을 간결하고 안전하게 리팩터링해 보자.
