---
layout: post
title: 영상처리 - 컬러 영상 처리
date: 2025-10-04 16:25:23 +0900
category: 영상처리
---
# 컬러 영상 처리

## 1) 컬러 엣지 검출(이론)

### 1.1 스칼라화(밝기 기반)
컬러를 루마 \(Y'\) (또는 HSI의 \(I\))로 **스칼라화** 후, 기존 엣지(예: Sobel/Canny)를 적용합니다.  
- 장점: 빠름, 안정적.  
- 단점: 색상 변화(밝기는 비슷, 색만 다른 경계)는 약하게 나옴.

### 1.2 채널 결합(Per-Channel Combine)
채널별 그래디언트 크기 \(\|\nabla R\|,\|\nabla G\|,\|\nabla B\|\) 를 결합:
\[
M\_{\text{max}}=\max(\|\nabla R\|,\|\nabla G\|,\|\nabla B\|),\quad
M\_{\text{rss}}=\sqrt{\|\nabla R\|^2+\|\nabla G\|^2+\|\nabla B\|^2}
\]
- 색 경계 민감도↑, 노이즈에도 민감.

### 1.3 **디젠초(Di Zenzo) 컬러 그래디언트**(권장)
RGB 각 채널의 미분을 \(R\_x, G\_x, B\_x\), \(R\_y, G\_y, B\_y\) 라 하면, **구조 텐서**:
\[
a=\sum\_c (I\_x^c)^2,\quad
b=\sum\_c I\_x^c I\_y^c,\quad
c=\sum\_c (I\_y^c)^2
\]
에서 **최대 고유값**이 그래디언트 크기 제곱:
\[
\lambda\_{\max}=\frac{(a+c)+\sqrt{(a-c)^2+4b^2}}{2},\quad
|\nabla I|\_{\text{DZ}}=\sqrt{\lambda\_{\max}}
\]
방향:
\[
\phi=\tfrac{1}{2}\operatorname{atan2}(2b, a-c)
\]
- 장점: 물리적 타당성(채널 상관 고려), 색 경계 강함.  
- 비용: 채널 결합보다 약간 무겁지만 Sobel 수준에서 충분히 실시간.

---

## 2) 구현 — 컬러 엣지 모듈

```cpp
// ColorEdge.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <cmath>
#include <algorithm>
#include "IppDib.h"
#include "IppImage.h"
#include "RGB24.h"
#include "DibImageConvert.hpp" // Dib<->RGB24 변환

// ===== 옵션 =====
enum class EdgeColorOut { Grayscale, Overlay };        // 그레이 맵 or 원본 위 오버레이
enum class EdgeMethod   { LumaY, ChannelMax, ChannelRSS, DiZenzo };

struct ColorEdgeOptions {
    EdgeMethod method = EdgeMethod::DiZenzo;
    EdgeColorOut out  = EdgeColorOut::Overlay;
    int threshPercent = 15;   // max magnitude 대비 % 임계(0~100)
    uint8_t edgeR=255, edgeG=32, edgeB=32; // Overlay 색
    bool replicateBorder = true;           // 경계 보간 정책(Sobel)
};

// ===== 공통 유틸 =====
inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }
inline int clampi(int v, int lo, int hi){ return v<lo?lo:(v>hi?hi:v); }
inline float sampleF(const std::vector<float>& A, int W,int H,int x,int y, bool repl){
    if (repl){ x=clampi(x,0,W-1); y=clampi(y,0,H-1); return A[(size_t)y*W+x]; }
    if ((unsigned)x>=(unsigned)W || (unsigned)y>=(unsigned)H) return 0.f;
    return A[(size_t)y*W+x];
}

// ===== RGB24 그레이 변환 (Y' 루마) =====
inline void RGB24_to_Luma(const IppImage<RGB24>& src, std::vector<float>& Y, int& W,int& H){
    W=src.width(); H=src.height(); Y.assign((size_t)W*H,0.f);
    for (int y=0;y<H;++y){
        const RGB24* s=src.row(y);
        for (int x=0;x<W;++x){
            float yv = 0.299f*s[x].r + 0.587f*s[x].g + 0.114f*s[x].b;
            Y[(size_t)y*W+x]=yv; // 0..255 float
        }
    }
}

// ===== Sobel on float image =====
inline void sobelGradF(const std::vector<float>& S, int W,int H,
                       std::vector<float>& Gx, std::vector<float>& Gy, bool repl)
{
    Gx.assign((size_t)W*H,0.f); Gy.assign((size_t)W*H,0.f);
    auto at=[&](int x,int y){ return sampleF(S,W,H,x,y,repl); };
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            float p00=at(x-1,y-1), p10=at(x,y-1), p20=at(x+1,y-1);
            float p01=at(x-1,y  ), /*p11*/0.f,    p21=at(x+1,y  );
            float p02=at(x-1,y+1), p12=at(x,y+1), p22=at(x+1,y+1);
            float gx = (-p00 + p20) + (-2.f*p01 + 2.f*p21) + (-p02 + p22);
            float gy = (-p00 - 2.f*p10 - p20) + (p02 + 2.f*p12 + p22);
            Gx[(size_t)y*W+x]=gx; Gy[(size_t)y*W+x]=gy;
        }
    }
}

// ===== 핵심: 컬러 엣지 맵 계산 =====
inline void ColorEdgeMagnitude(const IppImage<RGB24>& rgb,
                               const ColorEdgeOptions& opt,
                               std::vector<float>& Mag, int& W, int& H)
{
    W=rgb.width(); H=rgb.height();
    Mag.assign((size_t)W*H, 0.f);

    if (opt.method==EdgeMethod::LumaY){
        std::vector<float> Y; int w,h; RGB24_to_Luma(rgb, Y, w,h);
        std::vector<float> Gx,Gy; sobelGradF(Y,w,h,Gx,Gy,opt.replicateBorder);
        for (size_t i=0;i<Mag.size();++i) Mag[i]=std::hypot(Gx[i],Gy[i]);
        return;
    }

    // 채널별 그래디언트 준비
    std::vector<float> Rx((size_t)W*H), Ry((size_t)W*H),
                       Gx((size_t)W*H), Gy((size_t)W*H),
                       Bx((size_t)W*H), By((size_t)W*H);
    // R,G,B 채널 분리
    std::vector<float> Rf((size_t)W*H), Gf((size_t)W*H), Bf((size_t)W*H);
    for (int y=0;y<H;++y){
        const RGB24* s=rgb.row(y);
        for (int x=0;x<W;++x){
            size_t idx=(size_t)y*W+x;
            Rf[idx]= (float)s[x].r;
            Gf[idx]= (float)s[x].g;
            Bf[idx]= (float)s[x].b;
        }
    }
    sobelGradF(Rf,W,H,Rx,Ry,opt.replicateBorder);
    sobelGradF(Gf,W,H,Gx,Gy,opt.replicateBorder);
    sobelGradF(Bf,W,H,Bx,By,opt.replicateBorder);

    if (opt.method==EdgeMethod::ChannelMax){
        for (size_t i=0;i<Mag.size();++i){
            float mr=std::hypot(Rx[i],Ry[i]);
            float mg=std::hypot(Gx[i],Gy[i]);
            float mb=std::hypot(Bx[i],By[i]);
            Mag[i]=std::max(mr, std::max(mg,mb));
        }
        return;
    }
    if (opt.method==EdgeMethod::ChannelRSS){
        for (size_t i=0;i<Mag.size();++i){
            float mr=Rx[i]*Rx[i]+Ry[i]*Ry[i];
            float mg=Gx[i]*Gx[i]+Gy[i]*Gy[i];
            float mb=Bx[i]*Bx[i]+By[i]*By[i];
            Mag[i]=std::sqrt(mr+mg+mb);
        }
        return;
    }
    // Di Zenzo
    for (size_t i=0;i<Mag.size();++i){
        float a = Rx[i]*Rx[i] + Gx[i]*Gx[i] + Bx[i]*Bx[i];
        float c = Ry[i]*Ry[i] + Gy[i]*Gy[i] + By[i]*By[i];
        float b = Rx[i]*Ry[i] + Gx[i]*Gy[i] + Bx[i]*By[i];
        float t = (a+c);
        float s = std::sqrt((a-c)*(a-c) + 4.f*b*b);
        float lamMax = 0.5f*(t + s);
        Mag[i] = std::sqrt(std::max(0.f, lamMax));
    }
}

// ===== 임계 적용 & 출력 =====
inline void RenderEdges(const IppImage<RGB24>& src,
                        const std::vector<float>& Mag, int W,int H,
                        const ColorEdgeOptions& opt, IppDib& out)
{
    // 임계: max 대비 %
    float maxv=0.f; for (auto v:Mag) if (v>maxv) maxv=v;
    float thr = maxv * (std::clamp(opt.threshPercent,0,100)/100.f);

    if (opt.out==EdgeColorOut::Grayscale){
        out.create(W,H,32);
        float scale = (maxv>1e-6f)? (255.f/maxv) : 1.f;
        for (int y=0;y<H;++y){
            uint8_t* d=(uint8_t*)out.bits()+(size_t)y*out.stride();
            for (int x=0;x<W;++x){
                float m = Mag[(size_t)y*W+x];
                uint8_t g = (m>=thr)? clamp_u8((int)std::lround(m*scale)) : 0;
                d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
            }
        }
    } else {
        // Overlay: 원본 복사 후 edge 픽셀만 지정 색으로 찍기
        ImageRGB24ToDib(src, out);
        for (int y=0;y<H;++y){
            uint8_t* d=(uint8_t*)out.bits()+(size_t)y*out.stride();
            for (int x=0;x<W;++x){
                float m = Mag[(size_t)y*W+x];
                if (m>=thr){
                    d[x*4+0]=opt.edgeB; d[x*4+1]=opt.edgeG; d[x*4+2]=opt.edgeR; d[x*4+3]=255;
                }
            }
        }
    }
}

// ===== 공개 API =====
inline bool ColorEdges(const IppDib& in, IppDib& out, const ColorEdgeOptions& opt){
    if (!in) return false;
    IppImage<RGB24> rgb; DibToImageRGB24(in, rgb);
    std::vector<float> Mag; int W,H; ColorEdgeMagnitude(rgb,opt,Mag,W,H);
    RenderEdges(rgb,Mag,W,H,opt,out);
    return true;
}
```

---

## 3) UI — **컬러 엣지 검출** 메뉴/대화 상자

### 3.1 리소스 ID

```cpp
// resource.h (추가)
#define ID_MENU_COLOR_EDGES               83010
#define IDD_COLOR_EDGE_DLG                4000
#define IDC_RAD_EDGE_LUMA                 4001
#define IDC_RAD_EDGE_MAX                  4002
#define IDC_RAD_EDGE_RSS                  4003
#define IDC_RAD_EDGE_DZ                   4004
#define IDC_RAD_EDGE_GRAY                 4005
#define IDC_RAD_EDGE_OVERLAY              4006
#define IDC_EDIT_EDGE_THRPCT              4007
#define IDC_EDIT_EDGE_R                   4008
#define IDC_EDIT_EDGE_G                   4009
#define IDC_EDIT_EDGE_B                   4010
```

### 3.2 RC

```rc
// ImageTool.rc (추가)
POPUP "&Color"
BEGIN
    MENUITEM "Color Edges...\tCtrl+E", ID_MENU_COLOR_EDGES
END

IDD_COLOR_EDGE_DLG DIALOGEX 0,0, 280, 160
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Color Edge Detection"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Method", -1, 12, 8, 122, 74
    AUTORADIOBUTTON "Luma (Y')",    IDC_RAD_EDGE_LUMA, 22, 22, 70, 10, WS_TABSTOP
    AUTORADIOBUTTON "Channel Max",  IDC_RAD_EDGE_MAX,  22, 36, 80, 10
    AUTORADIOBUTTON "Channel RSS",  IDC_RAD_EDGE_RSS,  22, 50, 80, 10
    AUTORADIOBUTTON "Di Zenzo",     IDC_RAD_EDGE_DZ,   22, 64, 80, 10

    GROUPBOX "Output", -1, 142, 8, 126, 54
    AUTORADIOBUTTON "Grayscale", IDC_RAD_EDGE_GRAY,    152, 22, 66, 10, WS_TABSTOP
    AUTORADIOBUTTON "Overlay",   IDC_RAD_EDGE_OVERLAY, 152, 36, 66, 10

    LTEXT "Thresh %:", -1, 142, 68, 50, 10
    EDITTEXT IDC_EDIT_EDGE_THRPCT, 196, 66, 24, 14, ES_NUMBER

    LTEXT "Color (R,G,B):", -1, 12, 92, 60, 10
    EDITTEXT IDC_EDIT_EDGE_R, 76, 90, 28, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_EDGE_G, 108, 90, 28, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_EDGE_B, 140, 90, 28, 14, ES_NUMBER

    DEFPUSHBUTTON "OK", IDOK,  168, 118, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 218, 118, 44, 16
END
```

### 3.3 대화 상자 코드 & 메뉴 핸들러

```cpp
// ColorEdgeDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "ColorEdge.hpp"

class ColorEdgeDlg {
public:
    ColorEdgeDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();
private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);

    double ReadDouble(HWND h, int id, double def) const;
    int    ReadInt   (HWND h, int id, int def) const;
    bool   Checked(HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }

    HWND owner_{};
    IppDib& dib_;
};
```

```cpp
// ColorEdgeDlg.cpp
#include "ColorEdgeDlg.h"

INT_PTR ColorEdgeDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_COLOR_EDGE_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK ColorEdgeDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((ColorEdgeDlg*)l)->OnInit(h); }
    auto* self=(ColorEdgeDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
INT_PTR ColorEdgeDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_EDGE_LUMA, IDC_RAD_EDGE_DZ, IDC_RAD_EDGE_DZ);
    CheckRadioButton(h, IDC_RAD_EDGE_GRAY, IDC_RAD_EDGE_OVERLAY, IDC_RAD_EDGE_OVERLAY);
    SetDlgItemInt(h, IDC_EDIT_EDGE_THRPCT, 15, FALSE);
    SetDlgItemInt(h, IDC_EDIT_EDGE_R, 255, FALSE);
    SetDlgItemInt(h, IDC_EDIT_EDGE_G, 32,  FALSE);
    SetDlgItemInt(h, IDC_EDIT_EDGE_B, 32,  FALSE);
    return TRUE;
}
int ColorEdgeDlg::ReadInt(HWND h, int id, int def) const{
    BOOL ok=FALSE; int v=GetDlgItemInt(h,id,&ok,FALSE); return ok? v : def;
}
double ColorEdgeDlg::ReadDouble(HWND, int, double def) const{ return def; }

INT_PTR ColorEdgeDlg::OnCommand(HWND h, WPARAM w){
    switch (LOWORD(w)){
    case IDOK: {
        ColorEdgeOptions opt;
        if (Checked(h, IDC_RAD_EDGE_LUMA)) opt.method=EdgeMethod::LumaY;
        else if (Checked(h, IDC_RAD_EDGE_MAX)) opt.method=EdgeMethod::ChannelMax;
        else if (Checked(h, IDC_RAD_EDGE_RSS)) opt.method=EdgeMethod::ChannelRSS;
        else opt.method=EdgeMethod::DiZenzo;

        opt.out = Checked(h, IDC_RAD_EDGE_GRAY)? EdgeColorOut::Grayscale : EdgeColorOut::Overlay;
        opt.threshPercent = ReadInt(h, IDC_EDIT_EDGE_THRPCT, 15);
        opt.edgeR = (uint8_t)clampi(ReadInt(h, IDC_EDIT_EDGE_R, 255),0,255);
        opt.edgeG = (uint8_t)clampi(ReadInt(h, IDC_EDIT_EDGE_G, 32 ),0,255);
        opt.edgeB = (uint8_t)clampi(ReadInt(h, IDC_EDIT_EDGE_B, 32 ),0,255);

        IppDib out;
        if (ColorEdges(dib_, out, opt)) dib_ = out;
        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

```cpp
// main_multiwin.cpp (발췌)
#include "ColorEdgeDlg.h"

// ...
case ID_MENU_COLOR_EDGES:
    if (st && st->dib){
        ColorEdgeDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 4) 컬러 영상의 **히스토그램 균등화**

> 핵심 원칙: **색 뒤틀림(Color Shift)** 을 막으려면 **밝기 채널만** 균등화하는 것이 안전합니다.

### 4.1 선택지
- **권장: Y’(YCbCr) 균등화** — 색차(Cb/Cr)는 유지, 밝기 대비만 개선.  
- **대안: HSI의 \(I\)** 균등화 — 지각적 밝기와 유사, H 유지.  
- **주의: RGB 채널별 균등화** — 채널 독립 처리 → **색상 왜곡** 가능 (특수 효과용으로는 OK).

### 4.2 알고리즘(8비트, 전역 균등화)
1) 256-bin 히스토그램 \(h[k]\) (0..255)  
2) 누적분포 \(H[k]=\sum\_{i=0}^k h[i]\)  
3) 매핑 \(m[k]=\left\lfloor \dfrac{H[k]-H\_{\min}}{N - H\_{\min}} \cdot 255 \right\rfloor\) (유효 픽셀 \(N\))  
4) 픽셀 \(p \mapsto m[p]\)

### 4.3 구현 모듈

```cpp
// ColorHistEq.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <algorithm>
#include "IppDib.h"
#include "IppImage.h"
#include "RGB24.h"
#include "DibImageConvert.hpp"
#include "RGB_YCbCr.hpp"
#include "RGB_HSI.hpp"

inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }

// 공통: 단일 채널 8비트 균등화
inline void HistEqGray(IppImage<uint8_t>& g){
    const int W=g.width(), H=g.height();
    std::vector<int> hist(256,0);
    for (int y=0;y<H;++y){
        const uint8_t* p=g.row(y);
        for (int x=0;x<W;++x) hist[p[x]]++;
    }
    // CDF
    std::vector<int> cdf(256,0);
    int c=0; for (int i=0;i<256;++i){ c+=hist[i]; cdf[i]=c; }
    int cmin=0; for (int i=0;i<256;++i){ if (hist[i]){ cmin=cdf[i]; break; } }
    if (cdf[255]==cmin) return; // 모두 동일
    std::vector<uint8_t> map(256);
    const double denom = (double)(W*H - cmin);
    for (int i=0;i<256;++i){
        int v = (int)std::floor( ( (cdf[i]-cmin) / denom ) * 255.0 + 0.5 );
        map[i]=clamp_u8(v);
    }
    for (int y=0;y<H;++y){
        uint8_t* p=g.row(y);
        for (int x=0;x<W;++x) p[x]=map[p[x]];
    }
}

// ===== 1) 권장: Y' 균등화 (YCbCr) =====
inline bool HistEq_Y(const IppDib& in, IppDib& out){
    if (!in) return false;
    IppImage<RGB24> rgb; DibToImageRGB24(in, rgb);
    IppImage<YCbCr8> yuv; RGB24_to_YCbCr(rgb, yuv);
    IppImage<uint8_t> Y(yuv.width(),yuv.height());
    for (int y=0;y<yuv.height();++y){
        const YCbCr8* s=yuv.row(y); uint8_t* d=Y.row(y);
        for (int x=0;x<yuv.width();++x) d[x]=s[x].y;
    }
    HistEqGray(Y); // Y’만
    for (int y=0;y<yuv.height();++y){
        YCbCr8* d=yuv.row(y); const uint8_t* s=Y.row(y);
        for (int x=0;x<yuv.width();++x) d[x].y = s[x];
    }
    IppImage<RGB24> outRGB; YCbCr_to_RGB24(yuv, outRGB);
    ImageRGB24ToDib(outRGB, out); return true;
}

// ===== 2) HSI의 I 균등화 =====
inline bool HistEq_I(const IppDib& in, IppDib& out){
    if (!in) return false;
    IppImage<RGB24> rgb; DibToImageRGB24(in, rgb);
    IppImage<HSI32f> hsi; RGB24_to_HSI(rgb, hsi);
    // I를 0..255로 변환 → 균등화 → 되돌림
    IppImage<uint8_t> I8(hsi.width(),hsi.height());
    for (int y=0;y<hsi.height();++y){
        const HSI32f* s=hsi.row(y); uint8_t* d=I8.row(y);
        for (int x=0;x<hsi.width();++x) d[x]=(uint8_t)std::lround(std::clamp(s[x].i,0.f,1.f)*255.f);
    }
    HistEqGray(I8);
    for (int y=0;y<hsi.height();++y){
        HSI32f* d=hsi.row(y); const uint8_t* s=I8.row(y);
        for (int x=0;x<hsi.width();++x) d[x].i = s[x]/255.f;
    }
    IppImage<RGB24> outRGB; HSI_to_RGB24(hsi, outRGB);
    ImageRGB24ToDib(outRGB, out); return true;
}

// ===== 3) (주의) RGB 채널별 균등화 =====
inline bool HistEq_RGB(const IppDib& in, IppDib& out){
    if (!in) return false;
    IppImage<RGB24> rgb; DibToImageRGB24(in, rgb);
    // R,G,B 각 채널을 8비트 그레이로 취급해 균등화
    IppImage<uint8_t> R(rgb.width(),rgb.height()), G(rgb.width(),rgb.height()), B(rgb.width(),rgb.height());
    for (int y=0;y<rgb.height();++y){
        const RGB24* s=rgb.row(y); uint8_t* pr=R.row(y),*pg=G.row(y),*pb=B.row(y);
        for (int x=0;x<rgb.width();++x){ pr[x]=s[x].r; pg[x]=s[x].g; pb[x]=s[x].b; }
    }
    HistEqGray(R); HistEqGray(G); HistEqGray(B);
    for (int y=0;y<rgb.height();++y){
        RGB24* d=rgb.row(y); const uint8_t* pr=R.row(y),*pg=G.row(y),*pb=B.row(y);
        for (int x=0;x<rgb.width();++x){ d[x].r=pr[x]; d[x].g=pg[x]; d[x].b=pb[x]; }
    }
    ImageRGB24ToDib(rgb, out); return true;
}
```

---

## 5) UI — **컬러 히스토그램 균등화** 메뉴/대화 상자

### 5.1 리소스 ID

```cpp
// resource.h (추가)
#define ID_MENU_COLOR_HISTEQ             83020
#define IDD_COLOR_HISTEQ_DLG             4050
#define IDC_RAD_HISTEQ_Y                 4051
#define IDC_RAD_HISTEQ_I                 4052
#define IDC_RAD_HISTEQ_RGB               4053
#define IDC_ST_WARN                      4054
```

### 5.2 RC

```rc
// ImageTool.rc (추가)
POPUP "&Color"
BEGIN
    MENUITEM "Color Histogram Equalization...\tCtrl+H", ID_MENU_COLOR_HISTEQ
END

IDD_COLOR_HISTEQ_DLG DIALOGEX 0,0, 260, 124
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Color Histogram Equalization"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Mode", -1, 12, 10, 236, 54
    AUTORADIOBUTTON "Y' (YCbCr) — Recommended", IDC_RAD_HISTEQ_Y,   22, 24, 140, 10, WS_TABSTOP
    AUTORADIOBUTTON "I (HSI)",                  IDC_RAD_HISTEQ_I,   22, 38, 70, 10
    AUTORADIOBUTTON "RGB channels (color shift!)", IDC_RAD_HISTEQ_RGB, 120, 38, 120, 10
    LTEXT "Note: RGB per-channel equalization can change colors.", IDC_ST_WARN, 18, 68, 224, 10
    DEFPUSHBUTTON "OK", IDOK,  146, 88, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 196, 88, 44, 16
END
```

### 5.3 대화 상자 코드 & 메뉴 핸들러

```cpp
// ColorHistEqDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "ColorHistEq.hpp"

class ColorHistEqDlg {
public:
    ColorHistEqDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();
private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);

    HWND owner_{}; IppDib& dib_;
};
```

```cpp
// ColorHistEqDlg.cpp
#include "ColorHistEqDlg.h"

INT_PTR ColorHistEqDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_COLOR_HISTEQ_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK ColorHistEqDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((ColorHistEqDlg*)l)->OnInit(h); }
    auto* self=(ColorHistEqDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
INT_PTR ColorHistEqDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_HISTEQ_Y, IDC_RAD_HISTEQ_RGB, IDC_RAD_HISTEQ_Y);
    return TRUE;
}
INT_PTR ColorHistEqDlg::OnCommand(HWND h, WPARAM w){
    switch (LOWORD(w)){
    case IDOK: {
        IppDib out;
        if (IsDlgButtonChecked(h, IDC_RAD_HISTEQ_I)==BST_CHECKED) {
            HistEq_I(dib_, out);
        } else if (IsDlgButtonChecked(h, IDC_RAD_HISTEQ_RGB)==BST_CHECKED) {
            HistEq_RGB(dib_, out);
        } else {
            HistEq_Y(dib_, out); // 기본
        }
        dib_ = out;
        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

```cpp
// main_multiwin.cpp (발췌)
#include "ColorHistEqDlg.h"

// ...
case ID_MENU_COLOR_HISTEQ:
    if (st && st->dib){
        ColorHistEqDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 6) 예제 & 상황

### 예제 A) **원색 경계가 뚜렷한 로고(색 경계 강조)**
- **상황**: 배경은 밝고 로고는 원색. 루마 엣지는 약함.  
- **동작**: `Color → Color Edges…` → **Method=Di Zenzo**, **Output=Overlay**, **Thresh=10~15%**.  
- **결과**: 색상 변화 경계(밝기가 비슷해도)에서 강한 엣지 → 로고 윤곽 선명.

### 예제 B) **인물 사진의 저대비 조명 개선**
- **상황**: 어두운 실내 사진. 색감은 좋음.  
- **동작**: `Color → Color Histogram Equalization…` → **Y’(YCbCr)** 선택.  
- **결과**: 밝기 대비만 개선되어 피부톤/의상 색상은 **보존**, 인상적인 개선.

### 예제 C) **과포화 사진 톤 재배치**
- **상황**: 노을·네온 사진, 채널별 클리핑.  
- **동작**: **HSI-I 균등화**로 광도만 재분배(채도/H 유지).  
- **결과**: 하이라이트·섀도우 디테일 복원, 색조 안정.

### 예제 D) **특수 효과**
- **상황**: 아트 필터.  
- **동작**: **RGB per-channel equalization**.  
- **결과**: 컬러 시프트를 활용한 **초현실적** 분위기.

---

## 7) 정확성/성능 팁

- **엣지 임계**: 영상마다 대비가 달라 **상대 임계(%)** 가 편함. 필요하면 Otsu 기반 자동 임계 확장 가능.  
- **사전 평활화**: 소금-후추/센서 노이즈가 많으면, 엣지 전 **σ≈1 가우시안**을 권장(8.2절).  
- **NMS(비최대 억제)**: 과도한 두께가 거슬리면, Mag 기반 8-연결 이웃 NMS를 추가하면 좋음(11.1절 코드를 재사용).  
- **균등화 과대 강화 방지**: 전역 균등화는 노이즈도 올릴 수 있음. 필요하면 **CLAHE**(Clip Limit)로 확장.  
- **성능**: Sobel는 메모리 대역폭 지배 → 행 블록 멀티스레딩/SIMD로 2~4× 가속.

---

## 8) 간단 테스트 스니펫

```cpp
// test_color_edges_histeq.cpp
#include <cassert>
#include "IppDib.h"
#include "DibImageConvert.hpp"
#include "ColorEdge.hpp"
#include "ColorHistEq.hpp"

int main(){
    // 64x64 테스트 패턴: 좌반은 빨강, 우반은 초록 (밝기는 유사, 색만 다름)
    IppDib dib; dib.create(64,64,32);
    for(int y=0;y<64;++y){
        uint8_t* d=(uint8_t*)dib.bits()+y*dib.stride();
        for(int x=0;x<64;++x){
            bool left = x<32;
            d[x*4+2] = left? 255:0; // R
            d[x*4+1] = left? 0:255; // G
            d[x*4+0] = 0;           // B
            d[x*4+3] = 255;
        }
    }
    // 1) DiZenzo 엣지 → 색 경계에서 검출되어야 함
    ColorEdgeOptions eo; eo.method=EdgeMethod::DiZenzo; eo.out=EdgeColorOut::Grayscale; eo.threshPercent=5;
    IppDib edges; bool ok = ColorEdges(dib, edges, eo); assert(ok);

    // 2) Y' 균등화 왕복(단조로운 그라디언트로도 동작해야 함)
    IppDib heq; ok = HistEq_Y(dib, heq); assert(ok);

    return 0;
}
```

---

## 9) 요약
- **컬러 엣지**: 빠른 **루마 기반**, 간단한 **채널 결합**, 정확한 **Di Zenzo** 중 선택.  
- **메뉴/대화상자**로 방법·임계·출력 모드를 즉시 조절(오버레이/그레이).  
- **컬러 균등화**: 색 변형 없이 대비를 올리려면 **Y’(또는 I)만** 균등화.