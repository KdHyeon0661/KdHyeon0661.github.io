---
layout: post
title: flask - 로깅 & 모니터링
date: 2025-09-16 23:25:23 +0900
category: flask
---
# 11. 로깅 & 모니터링

> 이 장은 **구조화 로깅(JSON)과 요청/코릴레이션 ID**, **에러 수집(Sentry)**, **메트릭(StatsD/Prometheus)**, **헬스체크/레디니스/라이브니스 엔드포인트**를 **Flask 운영 기준**으로 정리한다.  
> 모든 코드는 ``` 로 감싸고, 수식이 필요하면 $$...$$ 로 표기한다(본 장은 수식이 거의 없다).

---

## 11.1 운영 관점에서의 로깅 & 모니터링 큰그림

- **구조화 로깅(JSON)**: 텍스트 로그 대신 **기계가 읽기 쉬운 JSON**. 필드(레벨, 타임스탬프, 요청ID, 경로, 사용자, 라우트, 지연, 크기, 에러 코드, 호스트, 버전 등).
- **코릴레이션**: 요청 → 내부 함수 → 외부 호출 → 백그라운드 작업까지 **request_id / correlation_id**를 전파.
- **에러 수집**: Sentry(또는 Rollbar 등)로 **스택트레이스, 태그, 사용자 컨텍스트** 자동 수집.
- **메트릭**: **Counter/Gauge/Histogram**(Prometheus) 또는 **StatsD**로 요청률/지연/오류율/큐길이/캐시적중률 추적.
- **헬스체크**: Kubernetes/로드밸런서용 **liveness/readiness**. 내부 의존성(데이터베이스/캐시/외부 API) 점검.

> 원칙: **표준화/일관성/자동화**. “로그는 JSON, 메트릭은 라벨, 트레이싱/코릴레이션 필수, 헬스엔드포인트는 빠르고 결정적”을 기본으로.

---

## 11.2 구조화 로깅(JSON)

### 11.2.1 파이프라인 전제

- 컨테이너/오케스트레이션(예: Kubernetes)에서는 **STDOUT** 으로 출력 → **수집기(Fluent Bit/Vector/Filebeat)** 가 전송.
- 보관/검색: Elastic/OpenSearch, Loki, CloudWatch, Datadog 등.

### 11.2.2 Python 로거 구성(기본)

```python
# app/logging.py
import logging, sys
from pythonjsonlogger import jsonlogger

def setup_json_logging(app, level=logging.INFO):
    handler = logging.StreamHandler(sys.stdout)
    fmt = jsonlogger.JsonFormatter(
        "%(asctime)s %(levelname)s %(name)s %(message)s "
        "%(pathname)s %(lineno)s %(process)d %(thread)d"
    )
    handler.setFormatter(fmt)

    root = logging.getLogger()
    root.handlers[:] = [handler]
    root.setLevel(level)

    # Flask 자체 로거도 루트로 전파
    app.logger.handlers[:] = []
    app.logger.propagate = True

    # noisy 로거 제어(원하는 수준으로 낮춤)
    for noisy in ("werkzeug", "urllib3", "botocore", "boto3"):
        logging.getLogger(noisy).setLevel(logging.WARNING)
```

### 11.2.3 요청/코릴레이션 ID 주입

```python
# app/middleware.py
import uuid, time
from flask import g, request

def setup_request_context(app):
    @app.before_request
    def start_timer():
        g.start_ts = time.time()
        # 클라이언트가 보낼 수도 있음을 고려(X-Request-ID or x-correlation-id)
        rid = request.headers.get("X-Request-ID") or request.headers.get("X-Correlation-ID")
        g.request_id = rid or uuid.uuid4().hex

    @app.after_request
    def add_log_and_headers(resp):
        elapsed_ms = int((time.time() - g.get("start_ts", time.time())) * 1000)
        resp.headers["X-Request-ID"] = g.request_id
        # 구조화 access 로그(애플리케이션 레이어에서 보강)
        request.environ.get("werkzeug.server.shutdown")  # no-op: import guard
        app.logger.info(
            "access",
            extra={
                "event": "http_access",
                "request_id": g.request_id,
                "method": request.method,
                "path": request.full_path.split("?")[0],
                "query": request.query_string.decode("utf-8"),
                "status": resp.status_code,
                "size": resp.calculate_content_length() or 0,
                "remote_addr": request.headers.get("X-Forwarded-For", request.remote_addr),
                "user_agent": request.headers.get("User-Agent"),
                "elapsed_ms": elapsed_ms,
            },
        )
        return resp
```

**사용자/세션 컨텍스트** 추가(로그인 사용자 ID):

```python
# app/middleware.py (after_request 안/또는 before_request에서 current_user 활용)
from flask_login import current_user

user_id = getattr(current_user, "id", None)
app.logger.info("access", extra={"user_id": user_id, ...})
```

### 11.2.4 보안: 민감정보 마스킹

```python
# app/log_filters.py
import logging, re

REDACT_KEYS = {"password", "secret", "token", "authorization", "api_key"}

class RedactFilter(logging.Filter):
    def filter(self, record):
        if isinstance(record.args, dict):
            record.args = {k: ("***" if k.lower() in REDACT_KEYS else v) for k, v in record.args.items()}
        if hasattr(record, "message") and isinstance(record.message, str):
            record.message = re.sub(r"(password|secret|token)=[^&\s]+", r"\1=***", record.message, flags=re.I)
        return True
```

핸들러에 필터 추가:

```python
handler.addFilter(RedactFilter())
```

### 11.2.5 Gunicorn 액세스 로그를 JSON으로

```bash
# gunicorn.conf.py
import json, sys, time

def post_worker_init(worker):
    pass

accesslog = "-"
errorlog = "-"
loglevel = "info"

def access_log_format(environ, resp, request_time):
    # Gunicorn의 custom access log 포맷 대신 직접 print로 JSON 한 줄
    # (대안: structlog/JSONFormatter-enabled logger 사용)
    ts = time.strftime("%Y-%m-%dT%H:%M:%S%z", time.localtime())
    rec = {
        "asctime": ts,
        "levelname": "INFO",
        "name": "gunicorn.access",
        "event": "http_access",
        "method": environ.get("REQUEST_METHOD"),
        "path": environ.get("RAW_URI") or environ.get("PATH_INFO"),
        "status": resp.status,
        "length": resp.response_length,
        "remote": environ.get("HTTP_X_FORWARDED_FOR") or environ.get("REMOTE_ADDR"),
        "ua": environ.get("HTTP_USER_AGENT"),
        "request_id": environ.get("HTTP_X_REQUEST_ID"),
        "elapsed_ms": int(request_time * 1000),
    }
    print(json.dumps(rec), file=sys.stdout)
    return ""
```

> 환경/조직에 맞게 **한 포맷**으로 통일하고, 로깅 파이프라인(필드 매핑)을 문서화한다.

---

## 11.3 에러 수집: Sentry

### 11.3.1 설치/초기화

```bash
pip install sentry-sdk
```

```python
# app/observability/sentry.py
import os, sentry_sdk
from sentry_sdk.integrations.flask import FlaskIntegration
from sentry_sdk.integrations.celery import CeleryIntegration
from sentry_sdk.integrations.redis import RedisIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration

def init_sentry(app):
    dsn = os.getenv("SENTRY_DSN")
    if not dsn:
        return
    sentry_sdk.init(
        dsn=dsn,
        integrations=[FlaskIntegration(), CeleryIntegration(), RedisIntegration(), SqlalchemyIntegration()],
        traces_sample_rate=float(os.getenv("SENTRY_TRACES_SAMPLE_RATE", "0.0")),  # APM(옵션)
        profiles_sample_rate=float(os.getenv("SENTRY_PROFILES_SAMPLE_RATE", "0.0")),  # 프로파일링(옵션)
        environment=os.getenv("APP_ENV", "development"),
        release=os.getenv("RELEASE", "dev"),
        send_default_pii=False,  # 개인정보 자동 포함 비활성(사용자 컨텍스트는 선택적으로)
        max_breadcrumbs=200,
    )
```

앱에서:

```python
# app/__init__.py
from .observability.sentry import init_sentry
def create_app(config=None):
    app = Flask(__name__)
    ...
    init_sentry(app)
    return app
```

### 11.3.2 수동 보고/부가정보(태그/유저/컨텍스트)

```python
import sentry_sdk
from flask_login import current_user

def capture_business_error(msg: str, **kvs):
    with sentry_sdk.push_scope() as scope:
        scope.set_tag("component", "billing")
        if getattr(current_user, "id", None):
            scope.user = {"id": current_user.id, "email": getattr(current_user, "email", None)}
        for k, v in kvs.items():
            scope.set_extra(k, v)
        sentry_sdk.capture_message(msg, level="error")
```

예외 포착:

```python
try:
    risky()
except Exception:
    sentry_sdk.capture_exception()
    raise
```

### 11.3.3 샘플링/PII/보안 모범사례

- **샘플링**: 트래픽 많은 서비스는 **에러 이벤트 100%**, 트랜잭션(APM)은 **샘플링(예: 0.05)**.
- **PII**: `send_default_pii=False` 유지, 사용자 태그는 **명시**적으로 추가.
- **출시 버전/환경**: `release` & `environment` 태그로 배포 추적.
- **Ignore/Grouping**: 알려진 예외(클라이언트 중단, 봇) ignore 규칙.

---

## 11.4 메트릭: StatsD / Prometheus

### 11.4.1 무엇을 측정하나

- **트래픽/오류/지연**: RPS, 2xx/4xx/5xx, p50/p90/p99, 타임아웃/리트라이
- **리소스**: 워커 수, 큐 길이, DB 연결, 캐시 적중률, 파일 핸들, CPU/메모리
- **비즈니스**: 주문수, 결제 성공률, 가입수, 로그인 실패율

### 11.4.2 StatsD/Datadog(UDP/UDS) 예시

```bash
pip install datadog
```

```python
# app/metrics/statsd.py
import os
from datadog import initialize, statsd

def init_statsd():
    # 환경에 따라 로컬 에이전트(8125/UDS)로 보냄
    initialize(statsd_host=os.getenv("STATSD_HOST", "127.0.0.1"),
               statsd_port=int(os.getenv("STATSD_PORT", "8125")),
               statsd_socket_path=os.getenv("STATSD_SOCKET", None))
```

미들웨어로 HTTP 지표 발행:

```python
# app/middleware_metrics.py
import time
from flask import request
from datadog import statsd

def setup_http_metrics(app):
    @app.before_request
    def _start():
        request._t0 = time.time()

    @app.after_request
    def _end(resp):
        t = time.time() - getattr(request, "_t0", time.time())
        route = (request.url_rule.rule if request.url_rule else request.path)
        method = request.method
        code = resp.status_code
        tags = [f"route:{route}", f"method:{method}", f"status:{code}"]
        statsd.increment("http.requests", tags=tags)
        statsd.histogram("http.latency_ms", t * 1000, tags=tags)
        return resp
```

비즈니스 지표:

```python
statsd.increment("signup.completed", tags=["plan:pro", "channel:web"])
statsd.gauge("queue.length", length, tags=["name:media"])
```

### 11.4.3 Prometheus(Pull 모델) — 공식 클라이언트

```bash
pip install prometheus-client
```

지표 등록:

```python
# app/metrics/prom.py
from prometheus_client import Counter, Histogram, Gauge, generate_latest, CONTENT_TYPE_LATEST
from flask import Blueprint, Response

REQUESTS = Counter("http_requests_total", "Total HTTP requests", ["route", "method", "status"])
LATENCY = Histogram("http_request_duration_seconds", "Latency", ["route", "method"], buckets=(.005,.01,.025,.05,.1,.25,.5,1,2,5))
INPROG = Gauge("http_inprogress", "In-progress requests")

metrics_bp = Blueprint("metrics", __name__)

@metrics_bp.get("/metrics")
def metrics():
    return Response(generate_latest(), mimetype=CONTENT_TYPE_LATEST)
```

미들웨어:

```python
# app/middleware_prom.py
import time
from flask import request
from .metrics.prom import REQUESTS, LATENCY, INPROG

def setup_prom_middleware(app):
    @app.before_request
    def _start():
        request._t0 = time.time()
        INPROG.inc()

    @app.after_request
    def _end(resp):
        t = time.time() - getattr(request, "_t0", time.time())
        route = (request.url_rule.rule if request.url_rule else request.path)
        REQUESTS.labels(route=route, method=request.method, status=resp.status_code).inc()
        LATENCY.labels(route=route, method=request.method).observe(t)
        INPROG.dec()
        return resp
```

> 배포 시 Prometheus 서버가 `/metrics` 스크랩. Kubernetes는 `PodMonitor/ServiceMonitor` 로 라벨링 후 스크랩.

### 11.4.4 지표 네이밍 & 라벨 가이드

- `snake_case` 영어, 단위 포함(`_seconds`, `_bytes`, `_total`)  
- **라벨 카디널리티**(조합 개수) 관리: `user_id` 처럼 **폭증** 라벨 금지.  
- 경로 라벨은 **정규화된 라우트 패턴** 사용(`/users/<id>`), **querystring/원본 URL 금지**.

---

## 11.5 헬스체크 / 레디니스 / 라이브니스

### 11.5.1 개념

- **라이브니스(liveness)**: 프로세스가 **살아** 있는가? (하드락/데드락/GC스톨 등 감지) → 실패시 재시작  
- **레디니스(readiness)**: **요청을 받아도 되는 상태**인가? (DB 연결, 캐시, 외부 의존성 준비) → 실패시 트래픽 제외  
- **헬스(health)**: 운영자/상태페이지용 상세 진단

### 11.5.2 구현 예제

```python
# app/health.py
from flask import Blueprint, jsonify
from app.extensions import db
import time

health_bp = Blueprint("health", __name__)

@health_bp.get("/healthz/live")
def live():
    # 매우 가벼워야 함. 논리적으로 True면 200.
    return jsonify(status="ok", ts=int(time.time()))

@health_bp.get("/healthz/ready")
def ready():
    # 내부 의존성 체크: 짧은 타임아웃으로 실패/성공만 판단
    ok_db = _check_db()
    ok_cache = _check_cache()
    ok_ext = _check_external()
    ok = ok_db and ok_cache and ok_ext
    code = 200 if ok else 503
    return jsonify(
        status="ok" if ok else "fail",
        deps={"db": ok_db, "cache": ok_cache, "external": ok_ext},
        ts=int(time.time())
    ), code

def _check_db(timeout=0.2) -> bool:
    try:
        with db.engine.connect() as conn:
            conn.exec_driver_sql("SELECT 1")
        return True
    except Exception:
        return False

def _check_cache() -> bool:
    try:
        from app.extensions import cache
        cache.set("health:ping", "1", timeout=5)
        return cache.get("health:ping") == "1"
    except Exception:
        return False

def _check_external() -> bool:
    # 외부 API 핑(옵션, 타임아웃 매우 짧게)
    return True
```

Kubernetes 프로브 예시:

```yaml
livenessProbe:
  httpGet:
    path: /healthz/live
    port: 8000
  initialDelaySeconds: 10
  periodSeconds: 10
readinessProbe:
  httpGet:
    path: /healthz/ready
    port: 8000
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 1
```

> **규칙**: `live`는 **항상 가볍게**, `ready`는 **의존성 점검**. 실패시 503.

### 11.5.3 헬스 상세(내부용)

```python
@health_bp.get("/health")
def health():
    # 내부 관리자/운영자 조회용 풍부한 상태(메트릭 수준은 아님)
    return jsonify({
        "uptime_s": _uptime(),
        "version": {"release": os.getenv("RELEASE","dev"), "env": os.getenv("APP_ENV","dev")},
        "limits": {"max_fds": _get_fd_limit()},
        "threads": _thread_count(),
        "queue": {"default_len": _rq_len("default")},
    })
```

> 인증/권한 필수(공개 금지). 민감정보 노출 주의.

---

## 11.6 코릴레이션: 외부 호출/백그라운드/실시간까지

### 11.6.1 외부 HTTP 요청에 헤더 전파

```python
# app/http/client.py
import requests
from flask import g

session = requests.Session()

def get_json(url, timeout=3):
    headers = {}
    rid = getattr(g, "request_id", None)
    if rid:
        headers["X-Request-ID"] = rid
        headers["X-Correlation-ID"] = rid
    r = session.get(url, timeout=timeout, headers=headers)
    r.raise_for_status()
    return r.json()
```

### 11.6.2 Celery 태스크로 전파

```python
# 제출 측
task = do_stuff.apply_async(args=[...], headers={"X-Request-ID": g.request_id})

# 태스크에서 g 사용 불가 → 명시적 추출
@celery.task(bind=True)
def do_stuff(self, ...):
    rid = self.request.get("headers", {}).get("X-Request-ID")
    # 로거에 바인딩:
    logger = logging.getLogger("worker")
    logger = logging.LoggerAdapter(logger, extra={"request_id": rid})
    logger.info("worker started")
```

### 11.6.3 SocketIO 이벤트 전파

```python
socketio.emit("evt", {...}, to=room, headers={"X-Request-ID": g.request_id})
```

> **일관된 키**(`X-Request-ID` = 코릴레이션 기준)를 정하고 문서화.

---

## 11.7 레벨/샘플링/레이트리밋

### 11.7.1 로그 레벨 가이드

- `DEBUG`: 개발/디버깅, 운영에서는 **샘플링** 또는 비활성
- `INFO`: 정상 상태 변경(시작/중지/주요 비즈니스 이벤트)
- `WARNING`: 복구 가능 오류(리트라이/대체경로)
- `ERROR`: 요청 실패/사용자 영향
- `CRITICAL`: 시스템 전체 위험/즉시 조치

### 11.7.2 샘플링/레이트리밋 필터

```python
# app/log_filters.py (추가)
import random, time

class SamplingFilter(logging.Filter):
    def __init__(self, rate=0.1):  # 10%
        super().__init__()
        self.rate = rate
    def filter(self, record):
        if record.levelno == logging.DEBUG:
            return random.random() < self.rate
        return True

class RateLimitFilter(logging.Filter):
    last = {}
    def __init__(self, key="message", interval=5):
        super().__init__()
        self.key = key; self.interval = interval
    def filter(self, record):
        k = getattr(record, self.key, record.getMessage())
        now = time.time()
        last = self.last.get(k, 0)
        if (now - last) < self.interval and record.levelno <= logging.INFO:
            return False
        self.last[k] = now
        return True
```

핸들러에 적용:

```python
handler.addFilter(SamplingFilter(rate=0.05))
handler.addFilter(RateLimitFilter(interval=2))
```

---

## 11.8 테스트: 로그 단언 & 메트릭 단언

### 11.8.1 로그 단언(Pytest caplog)

```python
def test_access_log(client, caplog):
    caplog.set_level(logging.INFO)
    r = client.get("/ping")
    assert r.status_code == 200
    assert any("access" in rec.message for rec in caplog.records)
```

### 11.8.2 Prometheus 테스트

```python
from prometheus_client import REGISTRY

def test_metric_exposed(client):
    r = client.get("/metrics")
    assert r.status_code == 200
    assert b"http_requests_total" in r.data
```

---

## 11.9 운영 체크리스트

- [ ] **JSON 구조화 로그**(레벨/타임스탬프/요청ID/경로/상태/지연/호스트/릴리즈)  
- [ ] **민감정보 마스킹**(비밀번호/토큰/Authorization)  
- [ ] **요청/코릴레이션 ID 전파**(외부 HTTP/큐/소켓)  
- [ ] **에러 수집(Sentry)** 초기화/샘플링/PII/환경/릴리즈 태깅  
- [ ] **메트릭**: HTTP 요청/지연/오류, DB 커넥션, 큐 길이, 캐시 적중률  
- [ ] **알람**: SLO 기반(오류율/지연), 지표+로그 상관  
- [ ] **헬스 엔드포인트**: `/healthz/live`, `/healthz/ready` 구분, 빠르고 결정적  
- [ ] **장애 대응 런북**: 어떤 알람에 어떤 절차(스케일/롤백/플래그)  
- [ ] **로그/메트릭 보존 정책**: GDPR/개인정보/보존기간  
- [ ] **추적성**: request_id 가 모든 스택에서 통과되는지 정기 점검

---

## 11.10 흔한 안티패턴

- **텍스트 로그(프리폼)**: 파싱 안됨, 검색/경보 어려움  
- **요청ID 없이** 여러 시스템 간 추적 시도 → 디버깅 지옥  
- **민감정보 원문 로깅**(Authorization 헤더, 비밀번호, 카드정보)  
- **메트릭 라벨 폭발**: user_id/고유키 라벨링으로 TSDB 폭발  
- **헬스 엔드포인트가 느림**: DB full scan 등 → k8s가 앱을 계속 죽임  
- **Sentry PII 활성화**: 개인정보 누출 위험  
- **로그 레벨 남용**: DEBUG/INFO 과다로 비용/소음 급증

---

## 11.11 붙여넣기 스타터

### 11.11.1 앱 부트스트랩

```python
# app/__init__.py
from flask import Flask
from .logging import setup_json_logging
from .middleware import setup_request_context
from .observability.sentry import init_sentry
from .metrics.prom import metrics_bp
from .middleware_prom import setup_prom_middleware
from .health import health_bp

def create_app(config=None):
    app = Flask(__name__)
    setup_json_logging(app)
    init_sentry(app)
    setup_request_context(app)
    setup_prom_middleware(app)

    app.register_blueprint(metrics_bp)     # /metrics
    app.register_blueprint(health_bp)      # /healthz/live, /healthz/ready

    @app.get("/ping")
    def ping():
        app.logger.info("pong", extra={"event":"ping"})
        return {"pong": True}
    return app
```

### 11.11.2 docker-compose 예시(관측 스택 부분)

```yaml
version: "3.9"
services:
  web:
    build: .
    ports: ["8000:8000"]
    environment:
      - APP_ENV=production
      - SENTRY_DSN=${SENTRY_DSN}
      - RELEASE=${GIT_SHA}
    command: >
      gunicorn "wsgi:app" -k gthread --threads 8 -w 2
      --bind :8000 --access-logfile - --error-logfile -
  prometheus:
    image: prom/prometheus
    volumes:
      - ./ops/prometheus.yml:/etc/prometheus/prometheus.yml
    ports: ["9090:9090"]
  loki:
    image: grafana/loki:2.9.0
  promtail:
    image: grafana/promtail:2.9.0
    volumes:
      - /var/log:/var/log
```

---

## 11.12 확장: OpenTelemetry(로그-트레이스 상관)

> 10장에서 트레이싱을 다뤘다면, **로그에 trace_id/span_id**를 포함하면 **단일 클릭 상관**이 가능.

```python
# app/logging_otlp.py
from opentelemetry.trace import get_current_span

class OTelContextFilter(logging.Filter):
    def filter(self, record):
        span = get_current_span()
        ctx = span.get_span_context() if span is not None else None
        if ctx and ctx.is_valid:
            record.trace_id = format(ctx.trace_id, "032x")
            record.span_id = format(ctx.span_id, "016x")
        else:
            record.trace_id = None
            record.span_id = None
        return True

handler.addFilter(OTelContextFilter())
```

로그에 필드 추가:

```python
fmt = jsonlogger.JsonFormatter("%(asctime)s %(levelname)s %(name)s %(message)s %(trace_id)s %(span_id)s")
```

---

## 11.13 보안/컴플라이언스 노트

- **개인정보(PII)와 금융/건강 정보**는 로그에 남기지 않음(마스킹/삭제 정책).  
- **보존 기간**: 최소화 원칙(예: 14~30일). 백업/보관 체계 분리.  
- **접근 제어**: 관측 시스템(로그/메트릭/트레이스/대시보드) 접근 권한.  
- **시그널링/알람**: 밤중 호출 정책(온콜), 에러예산 기반.

---

## 11.14 마무리

이 장에서는 **JSON 구조화 로깅**과 **요청/코릴레이션 ID 전파**, **Sentry 에러 수집**, **StatsD/Prometheus 메트릭**의 **구현 패턴**을 정리하고, **liveness/readiness 헬스 엔드포인트**를 **Kubernetes 운용 기준**으로 설계했다. 여기에 **샘플링/레이트리밋**, **민감정보 마스킹**, **트레이스-로그 상관**까지 더하면 **관측 가능한 Flask 서비스**의 기본 골격이 완성된다.