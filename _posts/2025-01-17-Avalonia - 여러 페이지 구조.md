---
layout: post
title: Avalonia - 여러 페이지 구조
date: 2025-01-17 20:20:23 +0900
category: Avalonia
---
# Avalonia MVVM: 여러 페이지 구조

## 0. 프로젝트 스캐폴드

```
MyAvaloniaApp/
├── App.axaml
├── Views/
│   ├── MainView.axaml
│   ├── DashboardView.axaml
│   ├── SettingsView.axaml
│   ├── AboutView.axaml
│   └── Shared/
│       └── LoadingView.axaml
├── ViewModels/
│   ├── MainViewModel.cs
│   ├── DashboardViewModel.cs
│   ├── SettingsViewModel.cs
│   ├── AboutViewModel.cs
│   └── Navigation/
│       ├── INavigationService.cs
│       ├── NavigationService.cs
│       ├── NavigationEntry.cs
│       ├── Route.cs
│       └── Guards.cs
└── Services/
    └── AppServices.cs (DI 예시)
```

---

## 1. 탭(TabControl) 기반 — 고정 소수 페이지에 적합

### 1.1 MainView.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:views="clr-namespace:MyAvaloniaApp.Views"
             xmlns:vm="clr-namespace:MyAvaloniaApp.ViewModels"
             x:Class="MyAvaloniaApp.Views.MainView">

  <UserControl.DataContext>
    <vm:MainViewModel/>
  </UserControl.DataContext>

  <TabControl SelectedIndex="{Binding SelectedTab}">
    <TabItem Header="대시보드">
      <views:DashboardView />
    </TabItem>
    <TabItem Header="설정">
      <views:SettingsView />
    </TabItem>
    <TabItem Header="정보">
      <views:AboutView />
    </TabItem>
  </TabControl>
</UserControl>
```

### 1.2 MainViewModel.cs

```csharp
using ReactiveUI;

public class MainViewModel : ReactiveObject
{
    private int _selectedTab;
    public int SelectedTab
    {
        get => _selectedTab;
        set => this.RaiseAndSetIfChanged(ref _selectedTab, value);
    }
}
```

**장점**: 구현이 가장 빠름.
**한계**: 탭 수가 고정될수록 적합. 동적 화면/상태 공유/복잡한 전환에는 제약.

---

## 2. 메뉴 + `ContentControl` — 동적 전환(권장 기본형)

핵심은 **`CurrentViewModel` 속성**과 **DataTemplate 매핑**이다.
ViewModel만 바꿔주면 Avalonia가 적절한 View를 매핑해 렌더링한다.

### 2.1 App.axaml — DataTemplate 등록(권장)

```xml
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:views="clr-namespace:MyAvaloniaApp.Views"
             xmlns:vm="clr-namespace:MyAvaloniaApp.ViewModels"
             x:Class="MyAvaloniaApp.App">

  <Application.Styles>
    <FluentTheme Mode="Light" />
  </Application.Styles>

  <Application.DataTemplates>
    <DataTemplate DataType="{x:Type vm:DashboardViewModel}">
      <views:DashboardView/>
    </DataTemplate>
    <DataTemplate DataType="{x:Type vm:SettingsViewModel}">
      <views:SettingsView/>
    </DataTemplate>
    <DataTemplate DataType="{x:Type vm:AboutViewModel}">
      <views:AboutView/>
    </DataTemplate>
  </Application.DataTemplates>
</Application>
```

> 권장: **`IDataTemplate` 기반 커스텀 ViewLocator**도 가능하지만, 정적 DataTemplate이 성능/안정성 면에서 가장 명확하다.

### 2.2 MainView.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="clr-namespace:MyAvaloniaApp.ViewModels"
             x:Class="MyAvaloniaApp.Views.MainView">

  <UserControl.DataContext>
    <vm:MainViewModel/>
  </UserControl.DataContext>

  <DockPanel>
    <Menu DockPanel.Dock="Top">
      <MenuItem Header="페이지">
        <MenuItem Header="대시보드" Command="{Binding ShowDashboardCommand}" />
        <MenuItem Header="설정" Command="{Binding ShowSettingsCommand}" />
        <MenuItem Header="정보" Command="{Binding ShowAboutCommand}" />
      </MenuItem>
    </Menu>

    <ContentControl Content="{Binding CurrentViewModel}" />
  </DockPanel>
</UserControl>
```

### 2.3 MainViewModel.cs

```csharp
using ReactiveUI;
using System.Reactive;

public class MainViewModel : ReactiveObject
{
    private object? _current;
    public object? CurrentViewModel
    {
        get => _current;
        set => this.RaiseAndSetIfChanged(ref _current, value);
    }

    public ReactiveCommand<Unit, Unit> ShowDashboardCommand { get; }
    public ReactiveCommand<Unit, Unit> ShowSettingsCommand { get; }
    public ReactiveCommand<Unit, Unit> ShowAboutCommand { get; }

    public MainViewModel()
    {
        ShowDashboardCommand = ReactiveCommand.Create(() => CurrentViewModel = new DashboardViewModel());
        ShowSettingsCommand  = ReactiveCommand.Create(() => CurrentViewModel = new SettingsViewModel());
        ShowAboutCommand     = ReactiveCommand.Create(() => CurrentViewModel = new AboutViewModel());

        CurrentViewModel = new DashboardViewModel();
    }
}
```

**장점**: 동적·유연, MVVM 친화.
**팁**: `CurrentViewModel`를 **서비스**를 통해 바꾸도록 하면 더 구조적(다음 장).

---

## 3. NavigationService 도입 — 유지보수·테스트·확장성 향상

### 3.1 인터페이스

```csharp
public interface INavigationService
{
    object? Current { get; }
    IReadOnlyList<NavigationEntry> BackStack { get; }
    IReadOnlyList<NavigationEntry> ForwardStack { get; }

    void Navigate(object viewModel);
    bool CanGoBack { get; }
    bool CanGoForward { get; }
    void GoBack();
    void GoForward();
    void Clear();
}
```

### 3.2 NavigationEntry/Route

```csharp
public sealed record NavigationEntry(object ViewModel, string? Title = null);

public sealed record Route(string Name, object? Parameter = null);
// 예: new Route("Settings", new SettingsArgs(userId: "A-1"))
```

### 3.3 구현: NavigationService.cs

```csharp
using ReactiveUI;
using System.Collections.Generic;

public sealed class NavigationService : ReactiveObject, INavigationService
{
    private readonly Stack<NavigationEntry> _back = new();
    private readonly Stack<NavigationEntry> _forward = new();
    private object? _current;

    public object? Current
    {
        get => _current;
        private set => this.RaiseAndSetIfChanged(ref _current, value);
    }

    public IReadOnlyList<NavigationEntry> BackStack => _back.Reverse().ToList();
    public IReadOnlyList<NavigationEntry> ForwardStack => _forward.Reverse().ToList();

    public bool CanGoBack => _back.Count > 0;
    public bool CanGoForward => _forward.Count > 0;

    public void Navigate(object viewModel)
    {
        if (Current is not null)
            _back.Push(new NavigationEntry(Current));
        _forward.Clear();
        Current = viewModel;
        this.RaisePropertyChanged(nameof(CanGoBack));
        this.RaisePropertyChanged(nameof(CanGoForward));
    }

    public void GoBack()
    {
        if (!CanGoBack) return;
        if (Current is not null)
            _forward.Push(new NavigationEntry(Current));
        Current = _back.Pop().ViewModel;
        this.RaisePropertyChanged(nameof(CanGoBack));
        this.RaisePropertyChanged(nameof(CanGoForward));
    }

    public void GoForward()
    {
        if (!CanGoForward) return;
        if (Current is not null)
            _back.Push(new NavigationEntry(Current));
        Current = _forward.Pop().ViewModel;
        this.RaisePropertyChanged(nameof(CanGoBack));
        this.RaisePropertyChanged(nameof(CanGoForward));
    }

    public void Clear()
    {
        _back.Clear();
        _forward.Clear();
        this.RaisePropertyChanged(nameof(CanGoBack));
        this.RaisePropertyChanged(nameof(CanGoForward));
    }
}
```

### 3.4 MainViewModel에 주입

```csharp
using ReactiveUI;
using System.Reactive;

public class MainViewModel : ReactiveObject
{
    private readonly INavigationService _nav;

    public object? CurrentViewModel => _nav.Current;

    public ReactiveCommand<Unit, Unit> ShowDashboard { get; }
    public ReactiveCommand<Unit, Unit> ShowSettings  { get; }
    public ReactiveCommand<Unit, Unit> ShowAbout     { get; }
    public ReactiveCommand<Unit, Unit> Back          { get; }
    public ReactiveCommand<Unit, Unit> Forward       { get; }

    public MainViewModel(INavigationService nav)
    {
        _nav = nav;

        ShowDashboard = ReactiveCommand.Create(() => _nav.Navigate(new DashboardViewModel()));
        ShowSettings  = ReactiveCommand.Create(() => _nav.Navigate(new SettingsViewModel()));
        ShowAbout     = ReactiveCommand.Create(() => _nav.Navigate(new AboutViewModel()));

        Back    = ReactiveCommand.Create(() => _nav.GoBack(),   this.WhenAnyValue(_ => _nav.CanGoBack));
        Forward = ReactiveCommand.Create(() => _nav.GoForward(),this.WhenAnyValue(_ => _nav.CanGoForward));

        this.WhenAnyValue(_ => _nav.Current).Subscribe(_ => this.RaisePropertyChanged(nameof(CurrentViewModel)));

        _nav.Navigate(new DashboardViewModel()); // 초기 페이지
    }
}
```

### 3.5 MainView.axaml — 브레드크럼/버튼

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="clr-namespace:MyAvaloniaApp.ViewModels"
             x:Class="MyAvaloniaApp.Views.MainView">

  <UserControl.DataContext>
    <!-- DI 환경이면 코드비하인드/팩토리에서 주입 -->
    <vm:MainViewModel/>
  </UserControl.DataContext>

  <DockPanel>
    <StackPanel Orientation="Horizontal" DockPanel.Dock="Top" Spacing="8" Margin="8">
      <Button Content="Back"    Command="{Binding Back}"/>
      <Button Content="Forward" Command="{Binding Forward}"/>
      <Button Content="대시보드" Command="{Binding ShowDashboard}"/>
      <Button Content="설정"    Command="{Binding ShowSettings}"/>
      <Button Content="정보"    Command="{Binding ShowAbout}"/>
    </StackPanel>

    <ContentControl Content="{Binding CurrentViewModel}"/>
  </DockPanel>
</UserControl>
```

---

## 4. 파라미터 전달 패턴 3종

### 4.1 생성자 인자

```csharp
public sealed class ProfileViewModel
{
    public string UserId { get; }
    public ProfileViewModel(string userId) => UserId = userId;
}
```

```csharp
_nav.Navigate(new ProfileViewModel("U-001"));
```

### 4.2 초기화 메서드(생성자 가벼움 유지)

```csharp
public interface IInitializable<T>
{
    void Initialize(T parameter);
}
```

```csharp
public sealed class ProfileViewModel : IInitializable<string>
{
    public string? UserId { get; private set; }
    public void Initialize(string parameter) => UserId = parameter;
}
```

```csharp
var vm = new ProfileViewModel();
vm.Initialize("U-002");
_nav.Navigate(vm);
```

### 4.3 Route + Factory(권장, 테스트 용이)

```csharp
public sealed record Route(string Name, object? Parameter = null);

public interface IRouteFactory
{
    object Resolve(Route route);
}
```

라우팅 표를 한 곳에 관리:

```csharp
public sealed class RouteFactory : IRouteFactory
{
    public object Resolve(Route route) => route.Name switch
    {
        "Dashboard" => new DashboardViewModel(),
        "Settings"  => new SettingsViewModel(),
        "About"     => new AboutViewModel(),
        "Profile"   => new ProfileViewModel((string)route.Parameter!),
        _           => new AboutViewModel() // fallback
    };
}
```

---

## 5. 화면 이탈 가드(저장 확인 등)

전환 전에 **Dirty 여부**를 검사해 경고하는 패턴.

```csharp
public interface INavigationGuard
{
    Task<bool> CanLeaveAsync();
}

public sealed class SettingsViewModel : INavigationGuard
{
    public bool IsDirty { get; private set; }
    public Task<bool> CanLeaveAsync()
    {
        if (!IsDirty) return Task.FromResult(true);
        // 여기서 다이얼로그 서비스로 "저장하시겠습니까?" 처리 가능
        return Task.FromResult(false);
    }
}
```

NavigationService 전환 시 검사:

```csharp
public async Task<bool> TryNavigateAsync(object next)
{
    if (Current is INavigationGuard guard)
    {
        if (!await guard.CanLeaveAsync()) return false;
    }
    Navigate(next);
    return true;
}
```

---

## 6. 비동기 전환과 로딩 UX

전환 시 데이터 로딩이 필요하면, **로딩 VM**으로 잠깐 교체했다가 완료 후 실제 화면으로 교체.

```csharp
public sealed class LoadingViewModel
{
    public string Message { get; }
    public LoadingViewModel(string message = "Loading...") => Message = message;
}
```

```csharp
public async Task NavigateWithLoadingAsync(Func<Task<object>> factory)
{
    Navigate(new LoadingViewModel());
    var vm = await factory();
    Navigate(vm);
}
```

사용:

```csharp
await _nav.NavigateWithLoadingAsync(async () =>
{
    await Task.Delay(800); // IO
    return new DashboardViewModel();
});
```

`LoadingView.axaml`을 DataTemplate에 매핑하면 끝.

---

## 7. 브레드크럼 UI 예시

```xml
<ItemsControl Items="{Binding BackStack}">
  <ItemsControl.ItemTemplate>
    <DataTemplate>
      <TextBlock Text="{Binding Title}" Margin="0,0,8,0"/>
    </DataTemplate>
  </ItemsControl.ItemTemplate>
</ItemsControl>
```

> `NavigationEntry(Title)` 채우는 규칙을 각 VM에서 노출하거나 라우트 테이블에 정의.

---

## 8. 딥링크(간단 라우팅) — 문자열 명령 처리

예: `"settings"` 입력 → 설정으로 이동, `"profile:U-123"` → 프로필 이동

```csharp
public static Route Parse(string deepLink)
{
    if (deepLink.StartsWith("profile:", StringComparison.OrdinalIgnoreCase))
        return new Route("Profile", deepLink.Split(':')[1]);
    return deepLink.ToLowerInvariant() switch
    {
        "dashboard" => new Route("Dashboard"),
        "settings"  => new Route("Settings"),
        "about"     => new Route("About"),
        _           => new Route("Dashboard")
    };
}
```

---

## 9. DI 구성(간단)

```csharp
// Services/AppServices.cs
using Microsoft.Extensions.DependencyInjection;

public static class AppServices
{
    public static ServiceProvider Build()
    {
        var sc = new ServiceCollection();
        sc.AddSingleton<INavigationService, NavigationService>();
        sc.AddSingleton<IRouteFactory, RouteFactory>();
        sc.AddTransient<MainViewModel>();
        // 다른 VM/서비스 등록…
        return sc.BuildServiceProvider();
    }
}
```

`MainView`의 코드비하인드나 App 초기화에서 `provider.GetRequiredService<MainViewModel>()` 주입.

---

## 10. 단위 테스트 포인트

- **NavigationService**
  - 초기 상태/전환/Back/Forward/스택 정합성
  - 가드 실패 시 전환 억제
- **RouteFactory**
  - 문자열 → VM 매핑 정확성
- **파라미터 전달**
  - 생성자/Initialize/Route 기반 모두 시나리오화

```csharp
using Xunit;

public sealed class NavigationTests
{
    [Fact]
    public void Navigate_Pushes_BackStack_And_Updates_Current()
    {
        var nav = new NavigationService();
        var a = new DashboardViewModel();
        var b = new SettingsViewModel();

        nav.Navigate(a);
        Assert.Same(a, nav.Current);

        nav.Navigate(b);
        Assert.Same(b, nav.Current);
        Assert.True(nav.CanGoBack);

        nav.GoBack();
        Assert.Same(a, nav.Current);
    }
}
```

---

## 11. 성능·유지보수 체크리스트

- **DataTemplate**로 VM→View 매핑(정적) 사용 → 런타임 탐색/리플렉션 비용 감소
- 화면 VM은 가능한 **가볍게**, 무거운 IO는 **비동기 + 로딩 VM**으로
- **BackStack**이 커질 수 있는 화면은 디스포즈/캐시 정책 고려
- **파라미터/라우트**는 **레코드/불변**으로 타입 안정성 유지
- **가드**로 이탈 조건을 명시해 데이터 손실 방지
- **WhenActivated**(ReactiveUI) 패턴으로 수명 기반 구독 해제

---

## 12. 최소 View/VM 예시(각 화면)

### DashboardViewModel.cs

```csharp
using ReactiveUI;

public sealed class DashboardViewModel : ReactiveObject
{
    public string Greeting => "대시보드에 오신 것을 환영합니다.";
}
```

### DashboardView.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="MyAvaloniaApp.Views.DashboardView">
  <StackPanel Margin="16">
    <TextBlock Text="대시보드" FontSize="20" Margin="0,0,0,8"/>
    <TextBlock Text="{Binding Greeting}"/>
  </StackPanel>
</UserControl>
```

유사하게 `SettingsViewModel`, `AboutViewModel`을 구성하고 App의 `Application.DataTemplates`에 등록한다.

---

## 13. 정리 표

| 방식 | 핵심 | 언제 쓰나 | 확장성 |
|------|------|-----------|--------|
| TabControl | 정적 탭 | 페이지 수 고정/간단 | 낮음 |
| 메뉴 + ContentControl | `CurrentViewModel` + DataTemplate | 일반적인 다중 페이지 | 높음 |
| 버튼 + ContentControl | 최소 전환 | 마이크로 앱 | 중간 |
| NavigationService | Back/Forward/가드/파라미터/라우트 | 중·대형 앱 | 매우 높음 |

---

## 14. 결론

- **DataTemplate 기반 전환**(VM→View 매핑)을 중심에 두고,
- **NavigationService**로 **스택·파라미터·가드**를 표준화하면,
- 화면이 늘어나도 코드가 **응집적**이고 **예측 가능**하게 유지된다.

이 아키텍처에 **테마/메시지 버스/저장 서비스(JSON)** 글의 구조를 결합하면, 데스크톱/크로스 플랫폼 Avalonia 앱의 골격이 완성된다.
