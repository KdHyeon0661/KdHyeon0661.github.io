---
layout: post
title: C# - 메서드와 클래스
date: 2024-10-10 19:20:23 +0900
category: Csharp
---
# 메서드와 클래스의 기본 구조

## 큰 그림 요약 (TL;DR)

- **클래스**는 **필드/프로퍼티/메서드/생성자**를 담는 **설계도**.
- **객체**는 클래스로부터 **new**로 만들어지는 **인스턴스**.
- **메서드**는 **동작**을 정의하며, **반환형/매개변수/접근 제한자**를 갖는다.
- **프로퍼티**로 캡슐화, **생성자**로 유효한 초기 상태 보장, **소멸/해제**는 `IDisposable` 패턴.
- **상속/인터페이스/가상 메서드**로 **다형성**, **제네릭**으로 **재사용성과 타입 안정성** 확보.
- **async/await**/이터레이터(`yield`)는 현대 C#의 핵심 제어 흐름.

---

## 클래스(Class)의 최소 골격

```csharp
class Car
{
    public string Model; // 필드
    public int Year;     // 필드
}
```

- `Model`, `Year`: **필드(field)**
- `public`: **접근 제한자** (이후 표로 정리)

실무에서는 필드보다 **프로퍼티**를 선호합니다(캡슐화/검증/알림 등 확장성).

```csharp
class Car2
{
    public string Model { get; set; } = ""; // 자동 구현 프로퍼티
    public int Year { get; init; }          // init 전용(생성 시에만 설정)
}
```

---

## 객체(Object) 생성과 초기화

```csharp
var myCar = new Car();
myCar.Model = "Hyundai";
myCar.Year = 2024;
```

### 객체/컬렉션 초기자

```csharp
var p = new Person { Name = "Kim", Age = 29 }; // set 접근자 필요

var list = new List<int> { 1, 2, 3 }; // 컬렉션 초기자
```

### 생성자(Constructor)

```csharp
class Person
{
    public string Name { get; }
    public int Age { get; }

    public Person(string name, int age) // 생성자
    {
        if (string.IsNullOrWhiteSpace(name)) throw new ArgumentException("name");
        if (age < 0) throw new ArgumentOutOfRangeException(nameof(age));
        Name = name;
        Age  = age;
    }
}
```

- **역할**: 유효한 초기 상태 보장(불변 조건 확보).
- **오버로딩** 가능, **기본 생성자**는 다른 생성자가 없을 때 자동 제공.

### 정적 생성자(Static ctor) — 1회 초기화

```csharp
class Config
{
    public static readonly string Root;
    static Config() // 최초 접근 시 1회 실행, 스레드 안전
    {
        Root = "/var/app";
    }
}
```

---

## 메서드(Method)의 구조

```csharp
[접근제한자] [한정자] 반환형 메서드명(매개변수 목록)
{
    // 본문
    return 값; // 반환형이 void가 아니면 필요
}
```

### 기본 예제

```csharp
class Calculator
{
    // 인스턴스 메서드
    public int Add(int a, int b) => a + b;

    // static 메서드
    public static int Sub(int a, int b) => a - b;
}

class Program
{
    static void Main()
    {
        var calc = new Calculator();
        Console.WriteLine(calc.Add(3,5)); // 8
        Console.WriteLine(Calculator.Sub(9,2)); // 7
    }
}
```

- **static 메서드**: **타입 소속**, 인스턴스 없이 호출.
- **인스턴스 메서드**: 객체 상태(`this`)에 접근.

### 반환값/매개변수/기본값

```csharp
public double Square(double x) => x * x;

public void Greet(string name = "Guest") => Console.WriteLine($"Hello, {name}");
```

### 이름있는 인자/옵셔널 인자

```csharp
void Log(string msg, string level = "INFO", bool utc = true) { /*...*/ }

Log("start");
Log(level: "WARN", msg: "careful");
Log("t", utc: false);
```

### `ref` / `out` / `in` (값 전달 방식)

```csharp
void Bump(ref int x) => x++;           // 호출자 변수 자체 수정
void Make(out int x) { x = 42; }       // 초기화 책임을 callee가 가짐
int Sum(in ReadOnlySpan<int> s) { int acc=0; foreach(var v in s) acc+=v; return acc; }
```

- `in`은 **읽기 전용 ref**(복사 최소화/안전성).

### `params` 가변 인자

```csharp
int Sum(params int[] xs) => xs.Sum();

var s = Sum(1,2,3,4); // 배열을 명시하지 않아도 됨
```

### 로컬 함수(Local function) — 메서드 내부 도우미

```csharp
int Outer(int n)
{
    int Square(int v) => v * v; // Outer 스코프 캡처 가능
    return Square(n);
}
```

---

## 접근 제한자와 멤버 용어 정리

| 구분 | 의미 | 사용 위치 |
|---|---|---|
| `public` | 어디서나 접근 | 타입/멤버 |
| `internal` | 동일 어셈블리 내 | 타입/멤버 |
| `protected` | 파생 타입에서 접근 | 멤버 |
| `private` | 같은 타입 내부 | 멤버 |
| `protected internal` | 같은 어셈블리 또는 파생형 | 멤버 |
| `private protected` | 같은 어셈블리 **내 파생형** | 멤버 |

> 실무 기본: **클래스는 `public` 최소화**, 멤버는 **가장 좁은 범위**.

---

## 필드 → 프로퍼티(캡슐화)

```csharp
class Account
{
    private decimal _balance;
    public decimal Balance
    {
        get => _balance;
        private set
        {
            if (value < 0) throw new InvalidOperationException();
            _balance = value;
        }
    }

    public void Deposit(decimal amount) => Balance += amount;
}
```

- **자동 구현 프로퍼티**: `public string Name { get; set; } = "";`
- **초기화 전용**: `public int Year { get; init; }`
- **식 본문**: `public string Title => $"{Name} ({Year})";`

### `const` vs `readonly`

```csharp
const double Pi = 3.141592653589793;         // 컴파일 상수
readonly DateTime started = DateTime.UtcNow; // 런타임 한 번만 설정
```

> 외부에 노출되는 바뀔 수 있는 값은 `const` 대신 `static readonly` 권장.

---

## this / 생성자 체이닝 / 멤버 숨김

```csharp
class Box
{
    public int W { get; }
    public int H { get; }

    public Box(int w, int h) { W = w; H = h; }

    public Box(int size) : this(size, size) { } // 생성자 체이닝

    public int Area() => W * H;

    // 멤버 이름이 충돌할 때 this로 명시
    public void Set(int W, int H)
    {
        this.W = W; // 자동 구현 프로퍼티가 아니라면 set 필요
        this.H = H;
    }
}
```

> 참고: 자동 구현 프로퍼티에선 set 접근자 정의가 필요합니다. 위 예시는 개념 목적.

---

## 상속, 메서드 오버라이드/숨김

```csharp
class Shape
{
    public virtual double Area() => 0; // 가상 메서드
}

class Circle : Shape
{
    public double R { get; }
    public Circle(double r) => R = r;

    public override double Area() => Math.PI * R * R; // 재정의
}

class Foo
{
    public void Print() => Console.WriteLine("Foo");
}

class Bar : Foo
{
    public new void Print() => Console.WriteLine("Bar"); // 숨김(new)
}
```

- **`virtual`/`override`/`sealed`**로 다형성 구성.
- **`new`** 키워드는 **메서드 숨김**(다형성 아님).
- **추상 클래스**는 인스턴스화 불가, **추상 메서드**는 파생형에서 구현 필수.

```csharp
abstract class Repository
{
    public abstract Task SaveAsync(object e);
}

class MemoryRepository : Repository
{
    public override Task SaveAsync(object e) => Task.CompletedTask;
}
```

---

## 인터페이스와 구현

```csharp
interface IClock { DateTime Now { get; } }

class SystemClock : IClock
{
    public DateTime Now => DateTime.UtcNow;
}
```

- 인터페이스는 **행동 계약**. 클래스는 **구현**.
- 단위 테스트에서 **의존성 주입**에 매우 유용.

---

## 제네릭 클래스/메서드와 제약(Constraints)

```csharp
class Pair<T1, T2>
{
    public T1 First { get; }
    public T2 Second { get; }
    public Pair(T1 a, T2 b) { First = a; Second = b; }
}

T Identity<T>(T x) => x;

class Repo<T> where T : Entity, new()
{
    public T Create() => new T();
}
```

- **장점**: 형 안전 + 박싱/언박싱 제거 + 재사용성.
- 제약: `where T : class/struct, new(), IDisposable, SomeBase, ISomething, unmanaged` 등.

---

## 확장 메서드(Extension Methods)

```csharp
static class StringExt
{
    public static bool IsNullOrWhite(this string? s) => string.IsNullOrWhiteSpace(s);
}

Console.WriteLine("  ".IsNullOrWhite()); // true
```

- **정적** 클래스/메서드에 `this 대상형` 첫 매개변수.
- 기존 타입에 **메서드 추가처럼 보이는 문법**(실제로는 정적 호출).

---

## 비동기 메서드(`async/await`)와 반환형

```csharp
public async Task<int> FetchSizeAsync(HttpClient http, string url)
{
    using var resp = await http.GetAsync(url);
    var body = await resp.Content.ReadAsByteArrayAsync();
    return body.Length;
}
```

- 반환형: `Task`, `Task<T>`, **이벤트 루프 없는 동기 메서드엔 사용 금지**.
- 예외는 **Task로 전파** → 호출 측에서 `await`시 `try/catch`.

---

## 이터레이터(Iterator) — `yield return`

```csharp
IEnumerable<int> Odds(int start, int count)
{
    for (int i = 0; i < count; i++)
        yield return start + i * 2;
}
```

- **지연 생성**으로 메모리/응답성 향상.
- 비동기는 `IAsyncEnumerable<T>` + `await foreach`.

---

## 수명주기와 자원 해제 — `IDisposable` 패턴

```csharp
class FileHolder : IDisposable
{
    private FileStream? _fs;
    public FileHolder(string path) => _fs = File.OpenRead(path);

    public void Dispose()
    {
        _fs?.Dispose();
        _fs = null;
        GC.SuppressFinalize(this);
    }
}
```

- **`using`**/`await using`으로 안전하게 정리:

```csharp
await using var conn = new NpgsqlConnection(cs); // IAsyncDisposable
```

> 파일/소켓/DB 연결 등 **관리되지 않는 자원**은 반드시 해제.

---

## 부분/중첩/레코드/partial methods

### 부분 클래스(Partial)

```csharp
partial class BigType { /* a.cs */ }
partial class BigType { /* b.cs */ }
```

- 코드 생성 도구/대형 타입 분리에 유용.

### 중첩 클래스(Nested)

```csharp
class Outer
{
    public class Inner { }
}
```

- 범위 한정/도우미 타입 캡슐화.

### 레코드(Record) — 값 동일성 중심

```csharp
public record User(string Id, string Name);
var u2 = u1 with { Name = "Lee" }; // 비파괴적 복사
```

---

## 정리표 — 언제 무엇을 쓰나

| 목적 | 도구 | 핵심 포인트 |
|---|---|---|
| 상태+동작을 하나로 | 클래스/프로퍼티/메서드 | 캡슐화, 불변 조건 |
| 초기화 강제 | 생성자/정적 생성자 | 유효 상태 보장/1회 초기화 |
| 외부 노출 API | 접근 제한자 | 최소 공개 원칙 |
| 다형성 | 가상 메서드/인터페이스 | `virtual/override/sealed` |
| 재사용/타입 안정 | 제네릭/제약 | 박싱 제거/컴파일 타임 안전 |
| 기존 타입 확장 | 확장 메서드 | 정적 메서드 문법 설탕 |
| I/O 비동기 | `async/await` | `Task/Task<T>` 반환 |
| 시퀀스 생성 | `yield` | 지연/저할당 |
| 자원 해제 | `IDisposable` | `using` 패턴 |

---

## 종합 예제 — 작은 도메인 묶기

```csharp
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;

// 계약(인터페이스)
interface IClock { DateTime Now { get; } }
class SystemClock : IClock { public DateTime Now => DateTime.UtcNow; }

// 엔터티(클래스)
class Article
{
    public string Id { get; }
    public string Title { get; private set; }
    public DateTimeOffset Created { get; }

    public Article(string id, string title, IClock clock)
    {
        Id = id ?? throw new ArgumentNullException(nameof(id));
        Title = string.IsNullOrWhiteSpace(title) ? throw new ArgumentException(nameof(title)) : title;
        Created = clock.Now;
    }

    public void Rename(string title)
    {
        if (string.IsNullOrWhiteSpace(title)) throw new ArgumentException(nameof(title));
        Title = title;
    }

    public override string ToString() => $"{Title}({Id})";
}

// 저장소(제네릭 + 제약)
interface IRepository<T>
{
    Task SaveAsync(T e);
    Task<T?> GetAsync(string id);
}

class MemoryArticleRepo : IRepository<Article>
{
    private readonly Dictionary<string, Article> _db = new();

    public Task SaveAsync(Article e) { _db[e.Id] = e; return Task.CompletedTask; }
    public Task<Article?> GetAsync(string id) =>
        Task.FromResult(_db.TryGetValue(id, out var v) ? v : null);
}

// 서비스(비동기/의존성 주입)
class ArticleService
{
    private readonly IRepository<Article> _repo;
    private readonly IClock _clock;

    public ArticleService(IRepository<Article> repo, IClock clock)
    {
        _repo = repo;
        _clock = clock;
    }

    public async Task<Article> CreateAsync(string id, string title)
    {
        var a = new Article(id, title, _clock);
        await _repo.SaveAsync(a);
        return a;
    }
}

// 확장 메서드
static class ArticleExt
{
    public static bool IsFresh(this Article a, TimeSpan span, IClock clock) =>
        (clock.Now - a.Created) < span;
}

class Program
{
    static async Task Main()
    {
        var clock = new SystemClock();
        var repo  = new MemoryArticleRepo();
        var svc   = new ArticleService(repo, clock);

        var a = await svc.CreateAsync("A001", "Hello");
        Console.WriteLine(a);

        Console.WriteLine(a.IsFresh(TimeSpan.FromMinutes(10), clock)); // true
    }
}
```

---

## 성능·안정성 체크리스트

1. **캡슐화 우선**: 필드 공개 대신 **프로퍼티** 사용.
2. **불변 규칙**: 생성자에서 유효성 검사, `init`/`readonly` 적극 활용.
3. **상속의 비용**: 먼저 **컴포지션** 고려 → 필요할 때만 상속/가상화.
4. **예외 vs 반환**: 예외는 예외적 상황에만. `Try` 패턴 고려.
5. **비동기**: `async void`는 이벤트 핸들러 전용. 나머지는 `Task/Task<T>`.
6. **리소스 해제**: `IDisposable`/`IAsyncDisposable` 지키고 `using` 사용.
7. **제네릭 박싱 주의**: `struct` 제네릭 경로에서 인터페이스 캐스트는 박싱 가능.
8. **확장 메서드 남용 금지**: 도메인 바깥 기능은 별도 유틸/서비스로.

---

## 수학적 메모 — 클래스 설계와 상태 공간

클래스의 가능한 상태 개수(상태 공간)가 클수록 **검증 비용**이 늘어납니다.
생성자/프로퍼티 제약으로 **유효 상태 집합**을 줄이면 테스트/증명 비용이 감소합니다.
이를 개념적으로 나타내면:

$$
\text{Valid States} \subseteq \text{All States}, \quad
|\text{Valid States}| \ll |\text{All States}|
$$

**효과**: 버그 확률 감소, 추론 가능성 증가.

---

## 연습 과제

1) 불변 `Order` 클래스를 설계: `Id`, `Items(Count>0)`, `Total(=Items 합)` 제약 보장.
2) `IClock`을 주입받는 `Subscription` 생성 → `IsExpired` 메서드 구현.
3) `IRepository<T>`의 파일 기반 구현(직렬화)과 `using`/`Dispose` 처리.
4) `async`로 외부 API에서 데이터를 가져와 캐시하는 서비스(동시성 제한 포함).
5) 복합 도메인에서 상속 대신 컴포지션으로 재사용하는 예시 작성.

---

## 결론

- **클래스**는 데이터와 동작의 **캡슐화 단위**, **메서드**는 동작의 기본 단위입니다.
- 생성자/프로퍼티로 **유효 상태**를 강제하고, 상속/인터페이스/제네릭으로 **확장성**을 설계하세요.
- 현대 C#의 **async/await**, **yield**, **확장 메서드**는 생산성과 표현력을 크게 높입니다.
- 이 글의 패턴을 토대로 **가독성·안정성·테스트 용이성**을 갖춘 클래스를 구현해 보세요.
