---
layout: post
title: C# - 메서드와 클래스
date: 2024-10-10 19:20:23 +0900
category: Csharp
---
# 메서드와 클래스의 기본 구조

## 개요: 객체 지향 프로그래밍의 기본 구성 요소

C#은 객체 지향 언어로서, **클래스(Class)** 를 설계도로 사용하여 **객체(Object)** 를 생성하고, 이 객체들이 서로 상호작용하도록 프로그램을 구성합니다. 클래스는 **데이터(상태)** 를 담는 필드와 프로퍼티, 그리고 그 데이터를 조작하는 **동작**을 정의하는 메서드로 이루어집니다. 이 구조를 잘 이해하는 것이 C# 프로그래밍의 핵심입니다.

---

## 1. 클래스(Class): 객체의 설계도

클래스는 특정 종류의 객체가 가져야 할 데이터(속성)와 동작(기능)을 정의하는 템플릿입니다.

```csharp
// 가장 단순한 클래스 예시
public class Car
{
    // 필드(Field): 객체의 데이터를 저장
    public string Model;
    public int Year;
}
```

위의 `Car` 클래스는 `Model`과 `Year`라는 두 개의 **필드**를 가지고 있습니다. 이 클래스를 바탕으로 실제 객체(인스턴스)를 생성할 수 있습니다.

```csharp
// 클래스를 이용해 객체 생성
Car myCar = new Car(); // 'new' 키워드로 인스턴스화
myCar.Model = "Tesla Model 3";
myCar.Year = 2023;

Console.WriteLine($"{myCar.Model} ({myCar.Year})");
```

### 필드보다 프로퍼티를 선호하라

실무에서는 데이터를 직접 노출하는 필드보다 **프로퍼티(Property)** 를 사용하는 것이 일반적입니다. 프로퍼티는 필드를 캡슐화하고, 유효성 검사, 값 변경 알림 등의 로직을 추가할 수 있는 더욱 유연한 방법을 제공합니다.

```csharp
public class Car
{
    // 자동 구현 프로퍼티(Auto-implemented Property)
    public string Model { get; set; } = string.Empty; // 초기값 설정 가능
    
    // Init-only 프로퍼티 (객체 생성 시에만 설정 가능)
    public int Year { get; init; }
    
    // 계산된 프로퍼티 (읽기 전용)
    public string Description => $"{Model} ({Year})";
}

// 객체 생성 및 초기화
var myCar = new Car { Model = "Hyundai Ioniq 5", Year = 2024 };
// myCar.Year = 2025; // 오류: init-only 프로퍼티는 생성 후 설정 불가
Console.WriteLine(myCar.Description);
```

---

## 2. 메서드(Method): 객체의 행동 정의

메서드는 클래스가 수행할 수 있는 작업 또는 동작을 정의합니다. 데이터를 처리하는 로직을 담는 곳입니다.

### 메서드의 기본 구조

```csharp
[접근제한자] [한정자] 반환타입 메서드이름([매개변수 목록])
{
    // 메서드 본문
    // 로직 수행...
    return 반환값; // 반환타입이 void가 아닐 경우
}
```

### 기본 예제: 계산기 클래스

```csharp
public class Calculator
{
    // 인스턴스 메서드: 객체의 상태에 접근 가능
    public int Add(int a, int b)
    {
        return a + b;
    }
    
    // 정적(Static) 메서드: 객체 없이 클래스 이름으로 호출
    public static int Multiply(int a, int b)
    {
        return a * b;
    }
    
    // 식 본문 메서드(Expression-bodied method): 간단한 로직에 적합
    public double Square(double x) => x * x;
}

// 사용
Calculator calc = new Calculator();
int sum = calc.Add(5, 3); // 8
int product = Calculator.Multiply(4, 5); // 20 (정적 메서드 호출)
double squared = calc.Square(2.5); // 6.25
```

### 메서드 매개변수의 다양한 형태

```csharp
public class ParameterExamples
{
    // 1. 기본값을 가진 매개변수 (Optional Parameter)
    public void Greet(string name = "Guest")
    {
        Console.WriteLine($"Hello, {name}!");
    }
    
    // 2. params 키워드: 가변 개수의 인자 받기
    public int Sum(params int[] numbers)
    {
        int total = 0;
        foreach (int num in numbers)
        {
            total += num;
        }
        return total;
    }
    
    // 3. ref 매개변수: 참조에 의한 전달 (호출자의 변수 직접 수정)
    public void Increment(ref int number)
    {
        number++;
    }
    
    // 4. out 매개변수: 출력 전용 매개변수 (메서드 내에서 반드시 초기화)
    public bool TryParseToInt(string input, out int result)
    {
        return int.TryParse(input, out result);
    }
    
    // 5. in 매개변수: 읽기 전용 참조 전달 (대규모 구조체 복사 방지)
    public double CalculateDistance(in Point p1, in Point p2)
    {
        // p1과 p2는 수정할 수 없지만, 복사 비용이 없음
        double dx = p2.X - p1.X;
        double dy = p2.Y - p1.Y;
        return Math.Sqrt(dx * dx + dy * dy);
    }
}

// 사용 예시
var examples = new ParameterExamples();
examples.Greet(); // "Hello, Guest!"
examples.Greet("Alice"); // "Hello, Alice!"

int total = examples.Sum(1, 2, 3, 4, 5); // 15

int value = 10;
examples.Increment(ref value); // value는 이제 11

if (examples.TryParseToInt("123", out int parsedValue))
{
    Console.WriteLine($"Parsed: {parsedValue}"); // 123
}
```

### 로컬 함수(Local Function)

메서드 내부에 도우미 함수를 정의하여 사용할 수 있습니다. 외부 메서드의 변수에 접근할 수 있어 편리합니다.

```csharp
public class MathUtility
{
    public double CalculateHypotenuse(double a, double b)
    {
        // 로컬 함수 정의
        double Square(double x) => x * x;
        
        return Math.Sqrt(Square(a) + Square(b));
    }
}
```

---

## 3. 생성자(Constructor): 객체 초기화

생성자는 클래스의 새 인스턴스를 만들 때 호출되는 특별한 메서드입니다. 객체가 유효한 상태로 시작하도록 보장하는 역할을 합니다.

```csharp
public class Person
{
    public string Name { get; }
    public int Age { get; }
    public string Email { get; }
    
    // 기본 생성자
    public Person()
    {
        Name = "Unknown";
        Age = 0;
        Email = string.Empty;
    }
    
    // 매개변수가 있는 생성자
    public Person(string name, int age)
    {
        // 유효성 검사
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Name cannot be empty", nameof(name));
        
        if (age < 0)
            throw new ArgumentOutOfRangeException(nameof(age), "Age cannot be negative");
        
        Name = name;
        Age = age;
        Email = string.Empty;
    }
    
    // 생성자 오버로딩 (다른 매개변수 조합)
    public Person(string name, int age, string email) : this(name, age)
    {
        // : this(name, age)는 위의 생성자를 먼저 호출
        Email = email ?? string.Empty;
    }
}

// 객체 생성 방법들
var person1 = new Person(); // 기본 생성자 사용
var person2 = new Person("Kim", 29); // 매개변수 있는 생성자
var person3 = new Person("Lee", 35, "lee@example.com");
```

### 객체 초기화 구문(Object Initializer)

생성자 호출 후 프로퍼티를 설정하는 간편한 구문입니다.

```csharp
var person = new Person("Park", 30)
{
    Email = "park@example.com" // 생성자 호출 후 추가 초기화
};
```

### 정적 생성자(Static Constructor)

클래스가 처음 사용되기 전에 한 번만 실행되는 생성자입니다. 정적 필드를 초기화하는 데 사용됩니다.

```csharp
public class AppConfig
{
    public static readonly string AppName;
    public static readonly DateTime StartTime;
    
    // 정적 생성자
    static AppConfig()
    {
        AppName = "MyApplication";
        StartTime = DateTime.UtcNow; // 어플리케이션 시작 시간 기록
        Console.WriteLine("Static constructor called");
    }
}
```

---

## 4. 접근 제한자(Access Modifiers): 캡슐화 구현

접근 제한자는 클래스 멤버(필드, 프로퍼티, 메서드)의 접근 가능 범위를 제어합니다. 이는 객체 지향의 핵심 개념인 **캡슐화**를 구현하는 수단입니다.

| 접근 제한자 | 설명 | 사용 가능 범위 |
|------------|------|---------------|
| `public` | 제한 없이 어디서나 접근 가능 | 클래스, 인터페이스, 모든 멤버 |
| `private` | 동일 클래스 내부에서만 접근 가능 | 클래스 멤버, 중첩 클래스 |
| `protected` | 동일 클래스와 파생(상속받은) 클래스에서 접근 가능 | 클래스 멤버 |
| `internal` | 동일 어셈블리(프로젝트) 내에서만 접근 가능 | 클래스, 인터페이스, 멤버 |
| `protected internal` | 동일 어셈블리 내부이거나 파생 클래스에서 접근 가능 | 클래스 멤버 |
| `private protected` | 동일 어셈블리 내부의 파생 클래스에서만 접근 가능 | 클래스 멤버 |

**실무 원칙**: 정보 은닉을 위해 가능한 한 가장 제한적인 접근 수준을 사용하세요. 즉, `private`을 기본으로 하고, 필요에 따라 점점 더 넓은 범위로 열어가는 방식이 좋습니다.

```csharp
public class BankAccount
{
    // private 필드: 외부에서 직접 접근 불가
    private decimal _balance;
    private string _accountNumber;
    
    // public 프로퍼티: 제어된 접근 허용
    public decimal Balance 
    { 
        get => _balance;
        private set // setter도 접근 제한 가능
        {
            if (value < 0)
                throw new InvalidOperationException("Balance cannot be negative");
            _balance = value;
        }
    }
    
    public string AccountNumber => _accountNumber; // 읽기 전용
    
    public BankAccount(string accountNumber, decimal initialBalance)
    {
        _accountNumber = accountNumber;
        Balance = initialBalance;
    }
    
    // public 메서드: 허용된 작업만 노출
    public void Deposit(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("Deposit amount must be positive", nameof(amount));
        
        Balance += amount;
    }
    
    public bool Withdraw(decimal amount)
    {
        if (amount <= 0 || amount > Balance)
            return false;
        
        Balance -= amount;
        return true;
    }
}
```

---

## 5. 상속과 다형성: 객체 지향의 핵심

### 상속(Inheritance)

클래스는 다른 클래스로부터 상속받아 멤버를 재사용하고 확장할 수 있습니다.

```csharp
// 기본(부모) 클래스
public class Vehicle
{
    public string Make { get; set; } = string.Empty;
    public string Model { get; set; } = string.Empty;
    public int Year { get; set; }
    
    public virtual void Start()
    {
        Console.WriteLine($"{Make} {Model} is starting...");
    }
}

// 파생(자식) 클래스
public class Car : Vehicle // : Vehicle로 상속
{
    public int NumberOfDoors { get; set; }
    
    // 메서드 오버라이딩(재정의)
    public override void Start()
    {
        base.Start(); // 부모 클래스의 메서드 호출 (선택적)
        Console.WriteLine("Engine is running smoothly.");
    }
    
    // 새로운 메서드 추가
    public void Honk()
    {
        Console.WriteLine("Beep beep!");
    }
}

public class ElectricCar : Car
{
    public int BatteryCapacity { get; set; } // kWh
    
    // sealed 키워드로 더 이상의 오버라이드 방지
    public sealed override void Start()
    {
        Console.WriteLine($"{Make} {Model} (Electric) is starting silently...");
    }
}

// 사용
Vehicle myVehicle = new Car { Make = "Tesla", Model = "Model S", Year = 2023 };
myVehicle.Start(); // 다형성: Car의 Start 메서드가 호출됨
```

### 추상 클래스와 인터페이스

```csharp
// 추상 클래스: 인스턴스화 불가, 공통 기능 제공
public abstract class Shape
{
    public abstract double CalculateArea(); // 추상 메서드: 파생 클래스에서 구현 필수
    
    public virtual void Display()
    {
        Console.WriteLine($"Area: {CalculateArea()}");
    }
}

public class Circle : Shape
{
    public double Radius { get; set; }
    
    public override double CalculateArea() => Math.PI * Radius * Radius;
}

// 인터페이스: 계약(Contract) 정의
public interface IDrawable
{
    void Draw();
    string Color { get; set; }
}

public class Square : Shape, IDrawable // 다중 인터페이스 구현 가능
{
    public double Side { get; set; }
    public string Color { get; set; } = "Black";
    
    public override double CalculateArea() => Side * Side;
    
    public void Draw()
    {
        Console.WriteLine($"Drawing a {Color} square with side {Side}");
    }
}
```

---

## 6. 제네릭(Generics): 타입 안전성과 재사용성

제네릭을 사용하면 타입 매개변수를 통해 클래스나 메서드를 일반화하여 다양한 데이터 타입에 재사용할 수 있습니다.

```csharp
// 제네릭 클래스
public class Box<T>
{
    public T Content { get; set; }
    
    public Box(T content)
    {
        Content = content;
    }
    
    public T GetContent()
    {
        return Content;
    }
}

// 제네릭 메서드
public class Utility
{
    public static void Swap<T>(ref T a, ref T b)
    {
        T temp = a;
        a = b;
        b = temp;
    }
    
    public static T Max<T>(T a, T b) where T : IComparable<T>
    {
        return a.CompareTo(b) > 0 ? a : b;
    }
}

// 사용
var stringBox = new Box<string>("Hello");
var intBox = new Box<int>(42);

int x = 5, y = 10;
Utility.Swap(ref x, ref y); // x=10, y=5

string larger = Utility.Max("apple", "banana"); // "banana"
```

### 제네릭 제약조건(Constraints)

제네릭 타입에 제약을 추가하여 특정 기능을 사용할 수 있게 합니다.

```csharp
public class Repository<T> where T : class, new()
{
    public T CreateItem()
    {
        return new T(); // new() 제약으로 인해 가능
    }
    
    public void Process<TItem>(TItem item) where TItem : IComparable<TItem>
    {
        // IComparable 메서드 사용 가능
        item.CompareTo(default);
    }
}
```

---

## 7. 확장 메서드(Extension Methods): 기존 타입 확장

확장 메서드를 사용하면 기존 클래스의 소스 코드를 수정하지 않고도 새로운 메서드를 추가한 것처럼 사용할 수 있습니다.

```csharp
// 정적 클래스에 확장 메서드 정의
public static class StringExtensions
{
    public static bool IsNullOrEmptyOrWhitespace(this string str)
    {
        return string.IsNullOrWhiteSpace(str);
    }
    
    public static string Repeat(this string str, int count)
    {
        if (count <= 0) return string.Empty;
        return string.Concat(Enumerable.Repeat(str, count));
    }
}

// 사용
string text = "Hello";
Console.WriteLine(text.IsNullOrEmptyOrWhitespace()); // false
Console.WriteLine(text.Repeat(3)); // "HelloHelloHello"
```

확장 메서드는 첫 번째 매개변수 앞에 `this` 키워드를 붙여 정의하며, 해당 타입의 인스턴스 메서드인 것처럼 호출할 수 있습니다.

---

## 8. 비동기 메서드: async/await 패턴

현대 애플리케이션에서는 I/O 작업(파일, 네트워크, 데이터베이스)을 비동기적으로 처리하는 것이 필수적입니다. C#의 `async`/`await` 키워드는 비동기 코드를 동기 코드처럼 읽기 쉽게 작성할 수 있게 해줍니다.

```csharp
public class DataService
{
    public async Task<string> FetchDataAsync(string url)
    {
        using HttpClient client = new HttpClient();
        
        try
        {
            // await: 비동기 작업이 완료될 때까지 메서드 실행 일시 중단
            HttpResponseMessage response = await client.GetAsync(url);
            response.EnsureSuccessStatusCode();
            
            string content = await response.Content.ReadAsStringAsync();
            return content;
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"Error fetching data: {ex.Message}");
            return string.Empty;
        }
    }
    
    public async Task ProcessMultipleUrlsAsync()
    {
        var urls = new[] { "https://api.example.com/data1", "https://api.example.com/data2" };
        
        // 여러 비동기 작업 병렬 실행
        var tasks = urls.Select(url => FetchDataAsync(url)).ToArray();
        
        // 모든 작업 완료 대기
        string[] results = await Task.WhenAll(tasks);
        
        foreach (var result in results)
        {
            Console.WriteLine($"Received {result.Length} characters");
        }
    }
}

// 호출
var service = new DataService();
string data = await service.FetchDataAsync("https://api.example.com/data");
```

**비동기 메서드 주의사항**:
- 비동기 메서드는 `Task` 또는 `Task<T>`를 반환해야 합니다.
- `async void`는 이벤트 핸들러에만 사용하세요.
- 비동기 메서드 이름에는 `Async` 접미사를 붙이는 것이 관례입니다.

---

## 9. yield와 이터레이터: 지연 실행 컬렉션

`yield return`을 사용하면 컬렉션을 한 번에 메모리에 올리지 않고 필요할 때마다 요소를 생성할 수 있습니다.

```csharp
public class NumberGenerator
{
    public static IEnumerable<int> GetEvenNumbers(int max)
    {
        for (int i = 0; i <= max; i++)
        {
            if (i % 2 == 0)
            {
                yield return i; // 호출자에게 값을 반환하고 실행 상태 유지
            }
        }
    }
    
    public static IEnumerable<int> GetFibonacci(int count)
    {
        int a = 0, b = 1;
        
        for (int i = 0; i < count; i++)
        {
            yield return a;
            int temp = a;
            a = b;
            b = temp + b;
        }
    }
}

// 사용
foreach (int even in NumberGenerator.GetEvenNumbers(10))
{
    Console.Write(even + " "); // 0 2 4 6 8 10
}

// 큰 시퀀스도 메모리 효율적으로 처리
var first100Fib = NumberGenerator.GetFibonacci(100);
foreach (int num in first100Fib.Take(10)) // 처음 10개만 필요
{
    Console.WriteLine(num);
}
```

---

## 10. IDisposable과 자원 관리

파일, 데이터베이스 연결, 네트워크 소켓 등 관리되지 않는 자원을 사용하는 클래스는 `IDisposable` 인터페이스를 구현하여 명시적으로 자원을 해제해야 합니다.

```csharp
public class FileLogger : IDisposable
{
    private StreamWriter _writer;
    private bool _disposed = false;
    
    public FileLogger(string filePath)
    {
        _writer = new StreamWriter(filePath, append: true);
    }
    
    public void Log(string message)
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(FileLogger));
        
        _writer.WriteLine($"{DateTime.UtcNow:O}: {message}");
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this); // 파이널라이저 호출 방지
    }
    
    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                // 관리되는 자원 해제
                _writer?.Dispose();
            }
            
            // 관리되지 않는 자원 해제 (있는 경우)
            // ...
            
            _disposed = true;
        }
    }
    
    // 파이널라이저 (안전망)
    ~FileLogger()
    {
        Dispose(false);
    }
}

// 사용 (using 문으로 자동 해제)
using (var logger = new FileLogger("log.txt"))
{
    logger.Log("Application started");
    logger.Log("Processing data...");
} // 여기서 자동으로 Dispose() 호출

// C# 8.0+: 간소화된 using 선언
using var logger2 = new FileLogger("log2.txt");
logger2.Log("Another log entry");
// 블록 끝에서 자동으로 Dispose()
```

---

## 종합 실전 예제: 간단한 작업 관리 시스템

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

// 1. 기본 엔터티 클래스
public class TaskItem
{
    public int Id { get; }
    public string Title { get; private set; }
    public string Description { get; set; }
    public DateTime CreatedAt { get; }
    public bool IsCompleted { get; private set; }
    
    public TaskItem(int id, string title)
    {
        if (string.IsNullOrWhiteSpace(title))
            throw new ArgumentException("Task title cannot be empty", nameof(title));
        
        Id = id;
        Title = title;
        CreatedAt = DateTime.UtcNow;
        IsCompleted = false;
    }
    
    public void MarkComplete() => IsCompleted = true;
    public void UpdateTitle(string newTitle) => Title = newTitle ?? throw new ArgumentNullException(nameof(newTitle));
    
    public override string ToString() => $"[{(IsCompleted ? "✓" : " ")}] {Title} (ID: {Id})";
}

// 2. 리포지토리 인터페이스 (계약)
public interface ITaskRepository
{
    Task<TaskItem?> GetByIdAsync(int id);
    Task<IEnumerable<TaskItem>> GetAllAsync();
    Task AddAsync(TaskItem task);
    Task UpdateAsync(TaskItem task);
    Task<bool> DeleteAsync(int id);
}

// 3. 메모리 기반 리포지토리 구현
public class InMemoryTaskRepository : ITaskRepository
{
    private readonly Dictionary<int, TaskItem> _tasks = new();
    private int _nextId = 1;
    
    public Task<TaskItem?> GetByIdAsync(int id)
    {
        _tasks.TryGetValue(id, out var task);
        return Task.FromResult(task);
    }
    
    public Task<IEnumerable<TaskItem>> GetAllAsync()
    {
        return Task.FromResult<IEnumerable<TaskItem>>(_tasks.Values);
    }
    
    public Task AddAsync(TaskItem task)
    {
        // ID 자동 생성 (실제 DB에서는 DB가 처리)
        var taskWithId = new TaskItem(_nextId++, task.Title)
        {
            Description = task.Description,
            IsCompleted = task.IsCompleted
        };
        
        _tasks[taskWithId.Id] = taskWithId;
        return Task.CompletedTask;
    }
    
    public Task UpdateAsync(TaskItem task)
    {
        if (!_tasks.ContainsKey(task.Id))
            throw new KeyNotFoundException($"Task with ID {task.Id} not found");
        
        _tasks[task.Id] = task;
        return Task.CompletedTask;
    }
    
    public Task<bool> DeleteAsync(int id)
    {
        return Task.FromResult(_tasks.Remove(id));
    }
}

// 4. 서비스 레이어 (비즈니스 로직)
public class TaskService
{
    private readonly ITaskRepository _repository;
    
    public TaskService(ITaskRepository repository)
    {
        _repository = repository ?? throw new ArgumentNullException(nameof(repository));
    }
    
    public async Task<TaskItem> CreateTaskAsync(string title, string description = "")
    {
        var task = new TaskItem(0, title) { Description = description };
        await _repository.AddAsync(task);
        return task;
    }
    
    public async Task CompleteTaskAsync(int taskId)
    {
        var task = await _repository.GetByIdAsync(taskId);
        if (task == null)
            throw new InvalidOperationException($"Task {taskId} not found");
        
        task.MarkComplete();
        await _repository.UpdateAsync(task);
    }
    
    public async Task<IEnumerable<TaskItem>> GetPendingTasksAsync()
    {
        var allTasks = await _repository.GetAllAsync();
        var pendingTasks = new List<TaskItem>();
        
        foreach (var task in allTasks)
        {
            if (!task.IsCompleted)
                pendingTasks.Add(task);
        }
        
        return pendingTasks;
    }
}

// 5. 확장 메서드
public static class TaskExtensions
{
    public static string GetStatusEmoji(this TaskItem task)
    {
        return task.IsCompleted ? "✅" : "⏳";
    }
    
    public static bool IsOverdue(this TaskItem task, int daysThreshold = 7)
    {
        return !task.IsCompleted && (DateTime.UtcNow - task.CreatedAt).TotalDays > daysThreshold;
    }
}

// 6. 프로그램 진입점
class Program
{
    static async Task Main()
    {
        // 의존성 구성
        ITaskRepository repository = new InMemoryTaskRepository();
        TaskService service = new TaskService(repository);
        
        // 작업 생성
        await service.CreateTaskAsync("Learn C#", "Study classes and methods");
        await service.CreateTaskAsync("Buy groceries");
        await service.CreateTaskAsync("Call mom");
        
        // 첫 번째 작업 완료 처리
        await service.CompleteTaskAsync(1);
        
        // 보류 중인 작업 조회
        var pendingTasks = await service.GetPendingTasksAsync();
        
        Console.WriteLine("Pending Tasks:");
        Console.WriteLine("==============");
        
        foreach (var task in pendingTasks)
        {
            Console.WriteLine($"{task.GetStatusEmoji()} {task}");
            
            if (task.IsOverdue(1)) // 1일 이상 지난 작업
            {
                Console.WriteLine("   ⚠️ This task is overdue!");
            }
        }
        
        Console.WriteLine($"\nTotal pending: {((List<TaskItem>)pendingTasks).Count}");
    }
}
```

---

## 결론: 견고한 클래스 설계를 위한 원칙

클래스와 메서드는 C# 프로그래밍의 기본 구성 요소입니다. 효과적으로 사용하기 위해 다음 원칙들을 기억하세요:

1. **단일 책임 원칙**: 각 클래스는 하나의 명확한 책임만 가져야 합니다.
2. **캡슐화**: 내부 구현을 숨기고 잘 정의된 공개 인터페이스만 노출하세요.
3. **불변성 가능성**: 가능한 경우 `readonly` 필드와 `init` 전용 프로퍼티를 사용하여 객체의 상태 변화를 제한하세요.
4. **의존성 주입**: 클래스가 직접 의존성을 생성하기보다 생성자를 통해 주입받도록 설계하세요. 이는 테스트 용이성을 높입니다.
5. **적절한 추상화**: 인터페이스와 추상 클래스를 사용해 구현과 계약을 분리하세요.
6. **명명 규칙**: 클래스는 명사로, 메서드는 동사로, 프로퍼티는 명사나 형용사로 명명하세요.
7. **예외 처리**: 생성자와 공개 메서드에서 유효성 검사를 수행하고, 적절한 예외를 던지세요.
8. **비동기 지원**: I/O 작업이 포함된 메서드는 비동기 버전을 제공하세요.

이러한 기본 구조와 원칙을 이해하고 적용하면, 유지보수하기 쉽고 확장성 있는 견고한 C# 애플리케이션을 구축할 수 있습니다. 클래스는 단순히 데이터를 담는 그릇이 아니라, 도메인의 개념과 행동을 모델링하는 강력한 도구입니다.