---
layout: post
title: Avalonia - 실시간 업데이트
date: 2025-02-17 19:20:23 +0900
category: Avalonia
---
# Avalonia MVVM에서 실시간 업데이트(WebSocket)

핵심은 다음 다섯 가지다.

1) **연결과 수명주기**: `Connect/Disconnect` + 백그라운드 수신 루프 + 앱 종료 정리  
2) **신뢰성**: 지수 백오프 재연결, 핑/퐁(heartbeat), 부분 프레임 재조립, 압축/대용량 대응  
3) **보안/인증**: `wss`(TLS), Bearer 토큰 헤더 주입, 프록시/인증서 검증  
4) **구조화**: `IWebSocketService`(서비스) ↔ `DashboardViewModel`(구독자) ↔ `DashboardView`(UI)  
5) **테스트**: 서비스 목킹, 메시지 파서 단위 테스트, 재연결 시나리오 검증  

---

## 0) 디렉터리 구조(확장판)

```
MyApp/
├── Models/
│   ├── NotificationMessage.cs           // 메시지 DTO
│   └── RealtimeEvent.cs                 // 다형 메시지 루트(선택)
├── Services/
│   ├── IWebSocketService.cs
│   ├── WebSocketOptions.cs              // 연결옵션(URI, 헤더, 토큰 등)
│   ├── WebSocketService.cs              // 구현(재연결/핑/퐁/부분조립)
│   ├── IWebSocketClient.cs              // 테스트용 추상 클라이언트(선택)
│   ├── ClientWebSocketAdapter.cs        // .NET ClientWebSocket 어댑터
│   └── ExponentialBackoff.cs            // 지수백오프 정책
├── ViewModels/
│   └── DashboardViewModel.cs
├── Views/
│   └── DashboardView.axaml
└── App.axaml(.cs)
```

---

## 1) 데이터 모델과 다형 메시지

단일 DTO로 시작해도 되지만, 실무에서는 `type` 필드로 라우팅하는 **다형 메시지**가 흔하다. 기본형부터 시작하자.

### Models/NotificationMessage.cs

```csharp
public class NotificationMessage
{
    public string Type { get; set; } = "";
    public string Message { get; set; } = "";
    public DateTime Timestamp { get; set; }
}
```

선택) 여러 타입을 한 통로에서 처리하고 싶다면 루트 타입을 두고 `type`으로 분기한다.

```csharp
public abstract class RealtimeEvent
{
    public string Type { get; init; } = "";
}

public sealed class NotificationEvent : RealtimeEvent
{
    public string Message { get; init; } = "";
    public DateTime Timestamp { get; init; }
}

public sealed class OrderCreatedEvent : RealtimeEvent
{
    public string OrderId { get; init; } = "";
    public decimal Amount { get; init; }
}
```

파싱은 `JsonDocument`로 `type`만 먼저 읽은 뒤 각 DTO로 역직렬화한다(아래 서비스에서 예시).

---

## 2) WebSocket 서비스 계약과 옵션

### Services/WebSocketOptions.cs

```csharp
public sealed class WebSocketOptions
{
    public Uri ServerUri { get; init; } = new("ws://localhost:5000/ws");
    public TimeSpan ConnectTimeout { get; init; } = TimeSpan.FromSeconds(10);
    public TimeSpan ReceiveLoopDelay { get; init; } = TimeSpan.FromMilliseconds(10);
    public TimeSpan HeartbeatInterval { get; init; } = TimeSpan.FromSeconds(25);
    public TimeSpan ReconnectMinDelay { get; init; } = TimeSpan.FromMilliseconds(300);
    public TimeSpan ReconnectMaxDelay { get; init; } = TimeSpan.FromSeconds(5);
    public bool EnableCompression { get; init; } = false; // 서버/중간자 지원 전제
    public string? BearerToken { get; set; } // 인증 필요 시
    public IDictionary<string, string>? ExtraHeaders { get; init; } // 커스텀 헤더
}
```

### Services/IWebSocketService.cs

```csharp
public interface IWebSocketService : IAsyncDisposable
{
    Task ConnectAsync(WebSocketOptions options, CancellationToken ct = default);
    Task DisconnectAsync(CancellationToken ct = default);

    // 수신 알림
    event EventHandler<NotificationMessage>? OnNotification;
    // 다형 이벤트로 확장할 경우
    event EventHandler<RealtimeEvent>? OnEvent;

    // 송신(선택)
    Task SendAsync(string text, CancellationToken ct = default);
    Task SendAsync<T>(T payload, CancellationToken ct = default);

    // 상태
    bool IsConnected { get; }
}
```

---

## 3) 테스트를 위한 클라이언트 어댑터(선택)

직접 `ClientWebSocket`을 목킹하기 어렵다. 인터페이스를 두고 어댑터를 구현하면 테스트가 쉽다.

### Services/IWebSocketClient.cs

```csharp
using System.Net.WebSockets;

public interface IWebSocketClient : IAsyncDisposable
{
    WebSocketState State { get; }
    Task ConnectAsync(Uri uri, CancellationToken ct);
    Task SendAsync(ArraySegment<byte> buffer, WebSocketMessageType type, bool endOfMessage, CancellationToken ct);
    Task<WebSocketReceiveResult> ReceiveAsync(ArraySegment<byte> buffer, CancellationToken ct);
    Task CloseAsync(WebSocketCloseStatus status, string? description, CancellationToken ct);
    void SetRequestHeader(string name, string value);
    void EnableCompression();
}
```

### Services/ClientWebSocketAdapter.cs

```csharp
using System.Net.WebSockets;

public sealed class ClientWebSocketAdapter : IWebSocketClient
{
    private readonly ClientWebSocket _inner = new();

    public WebSocketState State => _inner.State;

    public Task ConnectAsync(Uri uri, CancellationToken ct) => _inner.ConnectAsync(uri, ct);

    public Task SendAsync(ArraySegment<byte> buffer, WebSocketMessageType type, bool endOfMessage, CancellationToken ct)
        => _inner.SendAsync(buffer, type, endOfMessage, ct);

    public Task<WebSocketReceiveResult> ReceiveAsync(ArraySegment<byte> buffer, CancellationToken ct)
        => _inner.ReceiveAsync(buffer, ct);

    public Task CloseAsync(WebSocketCloseStatus status, string? description, CancellationToken ct)
        => _inner.CloseAsync(status, description, ct);

    public ValueTask DisposeAsync() => _inner.DisposeAsync();

    public void SetRequestHeader(string name, string value)
        => _inner.Options.SetRequestHeader(name, value);

    public void EnableCompression()
        => _inner.Options.DangerousDeflateOptions = new WebSocketDeflateOptions
        {
            ClientMaxWindowBits = 15,
            ServerMaxWindowBits = 15,
            ClientContextTakeover = false,
            ServerContextTakeover = false
        };
}
```

---

## 4) 지수 백오프 유틸

재연결, 일시 오류 대응에 사용.

### Services/ExponentialBackoff.cs

```csharp
public static class ExponentialBackoff
{
    public static IEnumerable<TimeSpan> Delays(TimeSpan min, TimeSpan max, int maxRetries)
    {
        var d = min.TotalMilliseconds;
        for (int i = 0; i < maxRetries; i++)
        {
            yield return TimeSpan.FromMilliseconds(Math.Min(d, max.TotalMilliseconds));
            d *= 2.0;
        }
    }
}
```

---

## 5) WebSocket 구현 — 재연결/핑퐁/부분조립/다형파싱

핵심 포인트

- **부분 프레임**: `EndOfMessage == false`라면 누적 버퍼에 이어붙인 뒤 완성 시 처리
- **Heartbeat**: 일정 주기로 Ping(Frame) 또는 텍스트 ping 메시지 전송, 서버 pong 필요
- **재연결**: 예외/Close 발생 시 백오프 후 연결 재시도
- **인증**: `Authorization: Bearer <token>` 헤더, 추가 헤더
- **스레드 안전**: 송신은 `SemaphoreSlim`으로 직렬화
- **UI 스레드 반영**: ViewModel에서 Dispatcher 사용(아래에서)

### Services/WebSocketService.cs

```csharp
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;

public sealed class WebSocketService : IWebSocketService
{
    private readonly Func<IWebSocketClient> _clientFactory; // DI에서 어댑터 생성자 주입
    private IWebSocketClient? _client;
    private CancellationTokenSource? _cts;
    private Task? _receiveLoopTask;
    private Task? _heartbeatTask;

    private readonly SemaphoreSlim _sendGate = new(1, 1);

    private WebSocketOptions? _options;

    public event EventHandler<NotificationMessage>? OnNotification;
    public event EventHandler<RealtimeEvent>? OnEvent;

    public bool IsConnected => _client?.State == WebSocketState.Open;

    public WebSocketService(Func<IWebSocketClient> clientFactory)
    {
        _clientFactory = clientFactory;
    }

    public async Task ConnectAsync(WebSocketOptions options, CancellationToken ct = default)
    {
        if (IsConnected) return;

        _options = options;
        _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        _client = _clientFactory();

        if (_options.EnableCompression)
            _client.EnableCompression();

        if (!string.IsNullOrWhiteSpace(_options.BearerToken))
            _client.SetRequestHeader("Authorization", $"Bearer {_options.BearerToken}");

        if (_options.ExtraHeaders is not null)
        {
            foreach (var kv in _options.ExtraHeaders)
                _client.SetRequestHeader(kv.Key, kv.Value);
        }

        // 연결 및 수신 루프 시작
        await TryConnectWithReconnectAsync(_cts.Token);

        // Heartbeat
        _heartbeatTask = Task.Run(() => HeartbeatLoop(_cts.Token));
    }

    private async Task TryConnectWithReconnectAsync(CancellationToken ct)
    {
        var delays = ExponentialBackoff.Delays(
            _options!.ReconnectMinDelay, _options.ReconnectMaxDelay, maxRetries: int.MaxValue);

        foreach (var delay in delays)
        {
            ct.ThrowIfCancellationRequested();

            try
            {
                await _client!.ConnectAsync(_options.ServerUri, ct);
                // 연결 성공 → 수신 루프 시작
                _receiveLoopTask = Task.Run(() => ReceiveLoop(ct), ct);
                return;
            }
            catch (Exception ex) when (!ct.IsCancellationRequested)
            {
                await Task.Delay(delay, ct);
                // 다음 루프에서 재시도
            }
        }
    }

    private async Task ReceiveLoop(CancellationToken ct)
    {
        // 부분 메시지 누적 버퍼
        var buffer = new byte[8192];
        using var ms = new MemoryStream(8192);

        while (!ct.IsCancellationRequested && _client!.State == WebSocketState.Open)
        {
            WebSocketReceiveResult result;
            try
            {
                result = await _client.ReceiveAsync(new ArraySegment<byte>(buffer), ct);
            }
            catch (Exception)
            {
                // 연결 손실 → 재연결 시도
                await Reconnect(ct);
                continue;
            }

            if (result.MessageType == WebSocketMessageType.Close)
            {
                try { await _client.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closed by server", ct); } catch { }
                await Reconnect(ct);
                continue;
            }

            // 부분 프레임 누적
            ms.Write(buffer, 0, result.Count);

            if (!result.EndOfMessage)
                continue;

            ms.Position = 0;

            if (result.MessageType == WebSocketMessageType.Text)
            {
                using var reader = new StreamReader(ms, Encoding.UTF8, leaveOpen: true);
                string text = await reader.ReadToEndAsync();
                HandleTextMessage(text);
            }
            else if (result.MessageType == WebSocketMessageType.Binary)
            {
                // 필요 시 바이너리 메시지 처리
                byte[] bin = ms.ToArray();
                HandleBinaryMessage(bin);
            }

            ms.SetLength(0); // 누적 버퍼 리셋
            ms.Position = 0;

            await Task.Delay(_options!.ReceiveLoopDelay, ct);
        }
    }

    private void HandleTextMessage(string text)
    {
        try
        {
            // 1) 단일 타입
            var trySimple = JsonSerializer.Deserialize<NotificationMessage>(text);
            if (trySimple is not null && !string.IsNullOrWhiteSpace(trySimple.Type))
            {
                OnNotification?.Invoke(this, trySimple);
                return;
            }

            // 2) 다형 라우팅
            using var doc = JsonDocument.Parse(text);
            if (!doc.RootElement.TryGetProperty("type", out var tProp)) return;
            var t = tProp.GetString();

            switch (t)
            {
                case "Notification":
                {
                    var dto = JsonSerializer.Deserialize<NotificationEvent>(text);
                    if (dto is not null) OnEvent?.Invoke(this, dto);
                    break;
                }
                case "OrderCreated":
                {
                    var dto = JsonSerializer.Deserialize<OrderCreatedEvent>(text);
                    if (dto is not null) OnEvent?.Invoke(this, dto);
                    break;
                }
                default:
                    // 알 수 없는 타입 → 무시 또는 로깅
                    break;
            }
        }
        catch (Exception)
        {
            // 파싱 실패 → 로깅 정도만
        }
    }

    private void HandleBinaryMessage(byte[] data)
    {
        // 바이너리 프로토콜(예: Protobuf) 사용 시 구현
        // 현재 예제에서는 패스
    }

    private async Task HeartbeatLoop(CancellationToken ct)
    {
        if (_options!.HeartbeatInterval <= TimeSpan.Zero) return;

        var pingPayload = Encoding.UTF8.GetBytes("{\"type\":\"ping\"}");
        while (!ct.IsCancellationRequested)
        {
            try
            {
                if (IsConnected)
                {
                    await _sendGate.WaitAsync(ct);
                    try
                    {
                        await _client!.SendAsync(new ArraySegment<byte>(pingPayload),
                            WebSocketMessageType.Text, endOfMessage: true, ct);
                    }
                    finally { _sendGate.Release(); }
                }
            }
            catch { /* 연결 손실 시 재연결 루프가 처리 */ }

            await Task.Delay(_options.HeartbeatInterval, ct);
        }
    }

    private async Task Reconnect(CancellationToken ct)
    {
        if (ct.IsCancellationRequested) return;

        try { await _client!.DisposeAsync(); } catch { }
        _client = _clientFactory();
        if (_options!.EnableCompression) _client.EnableCompression();
        if (!string.IsNullOrWhiteSpace(_options.BearerToken))
            _client.SetRequestHeader("Authorization", $"Bearer {_options.BearerToken}");
        if (_options.ExtraHeaders is not null)
            foreach (var kv in _options.ExtraHeaders) _client.SetRequestHeader(kv.Key, kv.Value);

        await TryConnectWithReconnectAsync(ct);
    }

    public async Task SendAsync(string text, CancellationToken ct = default)
    {
        if (!IsConnected) throw new InvalidOperationException("WebSocket is not open.");
        var bytes = Encoding.UTF8.GetBytes(text);

        await _sendGate.WaitAsync(ct);
        try
        {
            await _client!.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, ct);
        }
        finally { _sendGate.Release(); }
    }

    public Task SendAsync<T>(T payload, CancellationToken ct = default)
    {
        var json = JsonSerializer.Serialize(payload);
        return SendAsync(json, ct);
    }

    public async Task DisconnectAsync(CancellationToken ct = default)
    {
        try
        {
            if (_client is not null && _client.State == WebSocketState.Open)
            {
                await _client.CloseAsync(WebSocketCloseStatus.NormalClosure, "Client closing", ct);
            }
        }
        catch { /* 무시 */ }

        _cts?.Cancel();
        if (_receiveLoopTask is not null) await Task.WhenAny(_receiveLoopTask, Task.Delay(1000, ct));
        if (_heartbeatTask is not null) await Task.WhenAny(_heartbeatTask, Task.Delay(1000, ct));

        try { if (_client is not null) await _client.DisposeAsync(); } catch { }

        _client = null;
        _receiveLoopTask = null;
        _heartbeatTask = null;
        _cts?.Dispose();
        _cts = null;
    }

    public async ValueTask DisposeAsync()
    {
        await DisconnectAsync();
        _sendGate.Dispose();
    }
}
```

---

## 6) ViewModel — UI 스레드 반영, 메시지 제한, 수동 송신

### ViewModels/DashboardViewModel.cs

```csharp
using ReactiveUI;
using System.Collections.ObjectModel;

public sealed class DashboardViewModel : ReactiveObject
{
    private readonly IWebSocketService _ws;

    public ObservableCollection<NotificationMessage> Notifications { get; } = new();
    public ReactiveCommand<Unit, Unit> ConnectCommand { get; }
    public ReactiveCommand<Unit, Unit> DisconnectCommand { get; }
    public ReactiveCommand<string, Unit> SendTextCommand { get; }

    private string _status = "Disconnected";
    public string Status { get => _status; private set => this.RaiseAndSetIfChanged(ref _status, value); }

    public DashboardViewModel(IWebSocketService ws)
    {
        _ws = ws;

        _ws.OnNotification += (_, msg) =>
        {
            Avalonia.Threading.Dispatcher.UIThread.Post(() =>
            {
                Notifications.Insert(0, msg);
                const int Max = 200;
                if (Notifications.Count > Max) Notifications.RemoveAt(Notifications.Count - 1);
            });
        };

        ConnectCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            var opt = new WebSocketOptions
            {
                ServerUri = new Uri("ws://localhost:5000/ws"),
                BearerToken = null, // 필요 시 토큰 주입
                EnableCompression = false
            };
            try
            {
                await _ws.ConnectAsync(opt);
                Status = "Connected";
            }
            catch (Exception ex)
            {
                Status = $"Connect failed: {ex.Message}";
            }
        });

        DisconnectCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            await _ws.DisconnectAsync();
            Status = "Disconnected";
        });

        SendTextCommand = ReactiveCommand.CreateFromTask<string>(async text =>
        {
            if (string.IsNullOrWhiteSpace(text)) return;
            await _ws.SendAsync(new { type = "Echo", message = text, ts = DateTime.UtcNow });
        });
    }
}
```

---

## 7) View — 단순 목록 바인딩과 송신 UI

### Views/DashboardView.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="MyApp.Views.DashboardView">
  <StackPanel Spacing="10" Margin="20">
    <TextBlock Text="실시간 알림" FontSize="18"/>
    <StackPanel Orientation="Horizontal" Spacing="8">
      <Button Content="Connect" Command="{Binding ConnectCommand}"/>
      <Button Content="Disconnect" Command="{Binding DisconnectCommand}"/>
      <TextBlock Text="{Binding Status}" VerticalAlignment="Center"/>
    </StackPanel>

    <StackPanel Orientation="Horizontal" Spacing="6">
      <TextBox x:Name="MessageBox" Width="300" Watermark="메시지 입력"/>
      <Button Content="Send" Command="{Binding SendTextCommand}" CommandParameter="{Binding #MessageBox.Text}"/>
    </StackPanel>

    <ScrollViewer Height="320">
      <ItemsControl Items="{Binding Notifications}">
        <ItemsControl.ItemTemplate>
          <DataTemplate>
            <Border BorderBrush="Gray" BorderThickness="1" Padding="6" Margin="2">
              <StackPanel>
                <TextBlock Text="{Binding Message}" FontWeight="Bold"/>
                <TextBlock Text="{Binding Timestamp}" FontSize="11" Opacity="0.8"/>
                <TextBlock Text="{Binding Type}" FontSize="11" Opacity="0.6"/>
              </StackPanel>
            </Border>
          </DataTemplate>
        </ItemsControl.ItemTemplate>
      </ItemsControl>
    </ScrollViewer>
  </StackPanel>
</UserControl>
```

---

## 8) DI 등록

```csharp
// App.xaml.cs (또는 구성 루트)
private void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<Func<IWebSocketClient>>(_ => () => new ClientWebSocketAdapter());
    services.AddSingleton<IWebSocketService, WebSocketService>();
    services.AddTransient<DashboardViewModel>();
}
```

뷰 생성 시:

```csharp
var view = new DashboardView
{
    DataContext = Services.GetRequiredService<DashboardViewModel>()
};
```

---

## 9) 종료/정리

메인 윈도우 종료 시 정리:

```csharp
window.Closing += async (_, _) =>
{
    if (window.DataContext is DashboardViewModel vm)
        await (Services.GetRequiredService<IWebSocketService>()).DisconnectAsync();
};
```

> ViewModel에 `CleanupAsync()`를 별도로 두는 패턴도 가능하다.

---

## 10) 안정성·성능 팁

### 부분 메시지/대용량

- `ReceiveAsync`는 **부분 프레임**을 반환할 수 있으므로 메모리 스트림에 누적 후 `EndOfMessage`에서 처리한다.
- 대용량 메시지는 **Chunking** 또는 서버 측 압축(WebSocket permessage-deflate) 사용.

### 핑/퐁

- 서버가 서버-사이드 ping/pong을 지원한다면 클라이언트에서 텍스트 ping 대신 WebSocket ping 프레임을 보낼 수 있게 확장한다(표준 `ClientWebSocket`은 직접 ping 전송 API가 제한적이므로 텍스트 ping 메시지로 대체하는 경우가 있다).

### 재연결 백오프(간단 모델)

선형 시간이 \( t \)일 때 지수 백오프 \( B(t) \)는 다음처럼 둘 수 있다.

$$
B(t) = \min\left(B_{\text{max}},\ B_{\text{min}} \cdot 2^{k}\right)
$$

여기서 \( k \)는 재시도 횟수, \(B_{\text{min}}\)·\(B_{\text{max}}\)는 최소/최대 대기시간이다.

---

## 11) 보안/인증

- 운영 환경은 **wss://**(TLS) 강제.
- 토큰 전달은 `Authorization: Bearer <token>` 헤더 또는 **쿼리스트링 금지**(로그/프록시 유출 위험).
- 프록시/사설 인증서 환경에서는 `ClientWebSocketOptions`의 인증서 검증 콜백(별도 어댑터 확장)을 통해 신뢰할 루트만 허용.
- 민감 정보(토큰)는 로그에 남기지 말고, 디버그 시 앞 몇 글자만 마스킹.

---

## 12) 에러 처리/상태 머신

- 상태 전이: `Disconnected → Connecting → Connected → Reconnecting → Disconnected`
- 사용자 피드백: `Status` 바인딩, 재연결 중임을 표시
- 서버 Close 코드 분석(정상 종료 vs 정책 위반) 후 재연결 여부 결정

---

## 13) 단위 테스트 전략

1) **메시지 파싱**: `HandleTextMessage`를 파서 함수로 분리하여 다양한 JSON을 입력하고 기대 DTO가 나오는지 검증  
2) **재연결**: `IWebSocketClient` 목 구현으로 첫 `ReceiveAsync`에서 예외 → 재연결 시 두 번째는 성공하도록 시나리오 주입  
3) **송신 직렬화**: `_sendGate`를 통한 동시 호출이 순차 수행되는지 테스트

간단 목 핸들러 예시:

```csharp
public sealed class FakeWebSocketClient : IWebSocketClient
{
    private readonly Queue<Func<ArraySegment<byte>, WebSocketMessageType, bool, CancellationToken, Task>> _sendHandlers = new();
    private readonly Queue<Func<ArraySegment<byte>, CancellationToken, Task<WebSocketReceiveResult>>> _receiveHandlers = new();
    public WebSocketState State { get; private set; } = WebSocketState.None;

    public void EnqueueReceive(Func<ArraySegment<byte>, CancellationToken, Task<WebSocketReceiveResult>> f) => _receiveHandlers.Enqueue(f);
    public void EnqueueSend(Func<ArraySegment<byte>, WebSocketMessageType, bool, CancellationToken, Task> f) => _sendHandlers.Enqueue(f);

    public Task ConnectAsync(Uri uri, CancellationToken ct) { State = WebSocketState.Open; return Task.CompletedTask; }
    public Task<WebSocketReceiveResult> ReceiveAsync(ArraySegment<byte> buffer, CancellationToken ct) => _receiveHandlers.Dequeue()(buffer, ct);
    public Task SendAsync(ArraySegment<byte> buffer, WebSocketMessageType type, bool eom, CancellationToken ct) => _sendHandlers.Dequeue()(buffer, type, eom, ct);
    public Task CloseAsync(WebSocketCloseStatus status, string? desc, CancellationToken ct) { State = WebSocketState.Closed; return Task.CompletedTask; }
    public ValueTask DisposeAsync() { State = WebSocketState.Closed; return ValueTask.CompletedTask; }
    public void SetRequestHeader(string name, string value) { }
    public void EnableCompression() { }
}
```

---

## 14) 확장: SignalR로 대체

- 서버가 ASP.NET Core면 **SignalR** 클라이언트(`Microsoft.AspNetCore.SignalR.Client`)로 이벤트 메서드 기반 구독이 편리하다.
- 장점: 그룹, 사용자 대상 브로드캐스트, 재연결/전송 프로토콜 관리.
- 단점: 의존성 증가, 비(닷넷) 서버와의 상호운용성 제한.

---

## 15) 성능/메모리

- `MemoryStream` 재사용, 큰 버퍼는 `ArrayPool<byte>` 사용 고려.
- UI 컬렉션 크기 제한(예: 1,000건 보관 후 roll-off).
- CPU 바운드 파싱은 백그라운드에서 처리 후 결과만 UI 스레드로 반영.

---

## 16) 요약 표

| 주제 | 핵심 포인트 |
|---|---|
| 연결/수명 | `Connect/Disconnect`, 백그라운드 `ReceiveLoop` |
| 신뢰성 | 지수 백오프 재연결, heartbeat, 부분 프레임 처리 |
| 인증/보안 | wss, Bearer 헤더, 프록시/인증서 관리 |
| 구조화 | `IWebSocketService` + 어댑터 + ViewModel 바인딩 |
| UI | Dispatcher로 안전 갱신, 컬렉션 용량 제한 |
| 테스트 | `IWebSocketClient` 목, 파서/재연결 시나리오 |
| 확장 | 다형 메시지, 바이너리(프로토콜 버퍼), SignalR |

---

## 17) 마무리

이 가이드는 Avalonia MVVM에서 WebSocket을 **안정적으로 운영**하기 위한 실전 설계를 제공했다.  
핵심은 **서비스로 네트워킹 로직을 격리**하고, **UI는 바인딩만 담당**하도록 하며, **재연결·heartbeat·부분조립** 같은 실무 디테일을 일찍부터 반영하는 것이다.  
여기에 인증 토큰, TLS, 프록시, 테스트 전략까지 갖추면 대다수 실시간 대시보드·알림·스트리밍 요구사항을 견고하게 충족할 수 있다.