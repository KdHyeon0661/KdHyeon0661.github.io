---
layout: post
title: 영상처리 - 공간적 필터링 & 영상 부드럽게 만들기
date: 2025-09-23 17:25:23 +0900
category: 영상처리
---
# 공간적(Spatial) 필터링 & 영상 부드럽게 만들기
_개념 → 2D/가우시안(분리가능) 컨볼루션 구현 → 평균/가중 평균/가우시안 필터 → 가우시안 대화 상자(UI) → 메뉴/이벤트 연동 → 실제 예제 시나리오_

> 전제
> - Win32(비-MFC) **ImageTool** 프로젝트, `IppDib`(Top-Down BGRA32).
> - 수식은 **MathJax**, 코드는 **한 번만** \`\`\` 로 감쌉니다.
> - 알파(A)는 **보존**, B/G/R에만 필터 적용.

---

## 8.1 | 공간적 필터링의 기본 개념

### 8.1.1 공간적 필터링이란?
영상의 한 픽셀을 주변 이웃 픽셀들과 **가중 합**으로 다시 계산하는 연산. 일반적으로 **컨볼루션(Convolution)** 으로 표현합니다.

- 입력 영상 \(I(x,y)\), 커널(마스크) \(K(u,v)\) (\(u,v\)는 \(-r..\,+r\))
- 출력 \(O(x,y)\):
\[
O(x,y)=\sum_{u=-r}^{r}\sum_{v=-r}^{r} K(u,v)\,I(x-u,\,y-v)
\]
- **저주파(부드럽게)**: 평균/가우시안 등
- **고주파(선명하게)**: 샤프닝/엣지 검출 등(다음 장에서)

### 8.1.2 구현 포인트
1) **커널 정규화**: 평균/가우시안은 \(\sum K=1\) 이 되도록 스케일 → 전체 밝기 유지.
2) **경계 처리**: 좌표가 영상 밖으로 나갈 때 보정. 여기선 **가장자리 클램프(Replicate)** 를 사용합니다.
3) **정밀도와 성능**:
   - 소형 커널(3×3, 5×5)은 단순 2D 컨볼루션으로 충분.
   - **가우시안**은 2D 대신 **1D 두 번(분리가능)** 으로 빠르게 구현:
     \[
     G_{\sigma}(x,y)=g_{\sigma}(x)\,g_{\sigma}(y)
     \]
   - 큰 박스(평균)라면 적분영상(Integral Image)로 \(O(1)\) 구현 가능(여기선 개념 소개만).

---

## 8.1 | 공간적 필터링의 구현 방법 (핵심 코드)

아래 헤더 하나로 **경계 접근 + 2D/분리 컨볼루션**을 제공합니다.

```cpp
// SpatialFilter.h
#pragma once
#include <cstdint>
#include <vector>
#include <cmath>
#include <algorithm>
#include "IppDib.h"

// -------- 공통 유틸 --------
inline uint8_t clamp_u8(float v) {
    if (v < 0.f) v = 0.f; else if (v > 255.f) v = 255.f;
    return (uint8_t)std::lround(v);
}
inline int clampi(int v, int lo, int hi) { return (v<lo)?lo:((v>hi)?hi:v); }

// BGRA32에서 (x,y) 픽셀 포인터 얻기(경계 클램프)
inline const uint8_t* sample_BGRA32_clamp(const IppDib& src, int x, int y) {
    x = clampi(x, 0, src.width()-1);
    y = clampi(y, 0, src.height()-1);
    const uint8_t* row = (const uint8_t*)src.bits() + (size_t)y * src.stride();
    return &row[x*4];
}

// -------- 2D 컨볼루션(일반) --------
// float 커널 사용, 합이 1이 아닐 수도 있으므로 normalize 옵션 제공
inline void Convolve2D_BGRA32(const IppDib& src, IppDib& dst,
                              const std::vector<float>& kernel, int kW, int kH,
                              bool normalize=true)
{
    if (!src || kW<=0 || kH<=0 || (int)kernel.size()!=kW*kH) return;
    dst.create(src.width(), src.height(), 32);

    // 정규화 계수
    float ksum = 0.f;
    if (normalize) {
        for (float w: kernel) ksum += w;
        if (std::fabs(ksum) < 1e-8f) ksum = 1.f;
    } else ksum = 1.f;

    int rx = kW/2, ry = kH/2;

    for (int y=0; y<src.height(); ++y) {
        const uint8_t* srow = (const uint8_t*)src.bits() + (size_t)y * src.stride();
        uint8_t* drow       = (uint8_t*)dst.bits() + (size_t)y * dst.stride();
        for (int x=0; x<src.width(); ++x) {
            float accB=0, accG=0, accR=0;
            int idx=0;
            for (int j=-ry; j<=ry; ++j) {
                for (int i=-rx; i<=rx; ++i, ++idx) {
                    const uint8_t* p = sample_BGRA32_clamp(src, x+i, y+j);
                    float w = kernel[idx];
                    accB += w * p[0];
                    accG += w * p[1];
                    accR += w * p[2];
                }
            }
            drow[x*4 + 0] = clamp_u8(accB / ksum);
            drow[x*4 + 1] = clamp_u8(accG / ksum);
            drow[x*4 + 2] = clamp_u8(accR / ksum);
            drow[x*4 + 3] = srow[x*4 + 3]; // alpha 보존
        }
    }
}

// -------- 1D 컨볼루션(행/열) --------
inline void Convolve1D_Horizontal_BGRA32(const IppDib& src, IppDib& dst,
                                         const std::vector<float>& k, bool normalize=true)
{
    if (!src || k.empty()) return;
    dst.create(src.width(), src.height(), 32);

    float ksum = 0.f;
    if (normalize) { for (float w: k) ksum += w; if (std::fabs(ksum) < 1e-8f) ksum = 1.f; }
    else ksum = 1.f;

    int r = (int)k.size()/2;

    for (int y=0; y<src.height(); ++y) {
        const uint8_t* srow = (const uint8_t*)src.bits() + (size_t)y*src.stride();
        uint8_t* drow       = (uint8_t*)dst.bits() + (size_t)y*dst.stride();
        for (int x=0; x<src.width(); ++x) {
            float accB=0, accG=0, accR=0;
            for (int i=-r; i<=r; ++i) {
                const uint8_t* p = sample_BGRA32_clamp(src, x+i, y);
                float w = k[i+r];
                accB += w * p[0];
                accG += w * p[1];
                accR += w * p[2];
            }
            drow[x*4 + 0] = clamp_u8(accB / ksum);
            drow[x*4 + 1] = clamp_u8(accG / ksum);
            drow[x*4 + 2] = clamp_u8(accR / ksum);
            drow[x*4 + 3] = srow[x*4 + 3];
        }
    }
}
inline void Convolve1D_Vertical_BGRA32(const IppDib& src, IppDib& dst,
                                       const std::vector<float>& k, bool normalize=true)
{
    if (!src || k.empty()) return;
    dst.create(src.width(), src.height(), 32);

    float ksum = 0.f;
    if (normalize) { for (float w: k) ksum += w; if (std::fabs(ksum) < 1e-8f) ksum = 1.f; }
    else ksum = 1.f;

    int r = (int)k.size()/2;

    for (int y=0; y<src.height(); ++y) {
        const uint8_t* srow = (const uint8_t*)src.bits() + (size_t)y*src.stride();
        uint8_t* drow       = (uint8_t*)dst.bits() + (size_t)y*dst.stride();
        for (int x=0; x<src.width(); ++x) {
            float accB=0, accG=0, accR=0;
            for (int j=-r; j<=r; ++j) {
                const uint8_t* p = sample_BGRA32_clamp(src, x, y+j);
                float w = k[j+r];
                accB += w * p[0];
                accG += w * p[1];
                accR += w * p[2];
            }
            drow[x*4 + 0] = clamp_u8(accB / ksum);
            drow[x*4 + 1] = clamp_u8(accG / ksum);
            drow[x*4 + 2] = clamp_u8(accR / ksum);
            drow[x*4 + 3] = srow[x*4 + 3];
        }
    }
}
```

---

## 8.2 | 영상 부드럽게 만들기 (Smoothing)

### 8.2.1 평균 값 필터 (Box/Mean Filter)
크기 \(N\times N\) 의 커널을 **모두 같은 가중치**로 적용:
\[
K(u,v)=\frac{1}{N^2},\quad u,v \in \left[-\tfrac{N-1}{2},\,\tfrac{N-1}{2}\right]
\]
- **노이즈 억제**에 유효하지만, 엣지를 **둔화**시킵니다.

### 8.2.2 가중 평균 값 필터 (Weighted Mean)
중앙에 더 큰 가중치를 부여. 대표적인 3×3:
\[
\frac{1}{16}
\begin{bmatrix}
1 & 2 & 1\\
2 & 4 & 2\\
1 & 2 & 1
\end{bmatrix}
\]
→ 사실상 **가우시안 \(\sigma\approx1\)** 의 근사.

### 8.2.3 가우시안 필터 (Gaussian)
연속형:
\[
G_{\sigma}(x,y)=\frac{1}{2\pi\sigma^2}\,e^{-\frac{x^2+y^2}{2\sigma^2}}
\]
이산 커널은 \(|x|,|y| \le r\) 에서 샘플링, **정규화**.
**분리 가능**: \(G(x,y)=g(x)\cdot g(y)\)
\[
g_{\sigma}(t)=\frac{1}{\sqrt{2\pi}\sigma}\,e^{-\frac{t^2}{2\sigma^2}}
\]
> 보통 \(r=\lceil 3\sigma\rceil\) (커널 크기 \(=2r+1\))면 충분.

---

## 구현: 평균/가중 평균/가우시안 + 가우시안 대화 상자

### 1. Smoothing API (래퍼)

```cpp
// Smoothing.h
#pragma once
#include "SpatialFilter.h"
#include <numeric>

// ---- 평균 필터 ----
inline void MeanFilter_BGRA32(const IppDib& src, IppDib& dst, int ksize /*odd:3,5,7...*/) {
    if (ksize <= 1) { dst = src; return; }
    std::vector<float> k(ksize*ksize, 1.0f);
    Convolve2D_BGRA32(src, dst, k, ksize, ksize, /*normalize=*/true);
}

// ---- 가중 평균(3x3 1-2-1) ----
inline void WeightedMean3x3_BGRA32(const IppDib& src, IppDib& dst) {
    const float K[9] = {1,2,1, 2,4,2, 1,2,1};
    std::vector<float> k(K, K+9);
    Convolve2D_BGRA32(src, dst, k, 3, 3, /*normalize=*/true);
}

// ---- 가우시안 커널 1D 생성 ----
inline std::vector<float> MakeGaussian1D(float sigma, int ksize /*odd*/) {
    int r = ksize/2;
    std::vector<float> k(ksize);
    float denom = 2.f * sigma * sigma;
    for (int i=-r; i<=r; ++i) k[i+r] = std::exp(-(i*i)/denom);
    // 여기서는 분리 컨볼루션에서 normalize=true로 처리하므로 스케일은 생략 가능
    return k;
}

// ---- 가우시안 필터(분리 컨볼루션) ----
inline void GaussianFilter_BGRA32(const IppDib& src, IppDib& dst, float sigma, int ksize /*odd*/) {
    if (sigma <= 0.f) { dst = src; return; }
    if (ksize < 3) ksize = 3;
    if ((ksize & 1)==0) ++ksize;

    std::vector<float> g = MakeGaussian1D(sigma, ksize);
    IppDib tmp;
    Convolve1D_Horizontal_BGRA32(src, tmp, g, /*normalize=*/true);
    Convolve1D_Vertical_BGRA32(tmp, dst, g,   /*normalize=*/true);
}
```

---

### 2. 가우시안 필터 대화 상자

- **입력**: \(\sigma\) (실수), 커널 크기(홀수), **자동 크기**(예: \(r=\lceil 3\sigma\rceil\))
- **미리보기(옵션)**: 여기서는 단순화하여 OK 시 적용.

#### 2-1. 리소스 정의

```cpp
// resource.h (추가)
#define IDD_GAUSSIAN                  600
#define IDC_EDIT_SIGMA                1601
#define IDC_EDIT_KSIZE                1602
#define IDC_CHECK_AUTOSIZE            1603
#define IDC_STAT_PREVIEWNOTE          1604

// 메뉴명령
#define ID_IMAGE_SMOOTH_MEAN3         51001
#define ID_IMAGE_SMOOTH_MEAN5         51002
#define ID_IMAGE_SMOOTH_WEIGHTED3     51003
#define ID_IMAGE_SMOOTH_GAUSSIAN      51004
```

```rc
// ImageTool.rc (추가)
IDD_GAUSSIAN DIALOGEX 0,0, 220, 120
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Gaussian Blur"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Sigma (σ):", -1, 12, 14, 50, 10
    EDITTEXT IDC_EDIT_SIGMA, 70, 12, 50, 14, ES_AUTOHSCROLL | WS_TABSTOP

    LTEXT "Kernel size (odd):", -1, 12, 36, 70, 10
    EDITTEXT IDC_EDIT_KSIZE,  90, 34, 30, 14, ES_NUMBER | WS_TABSTOP

    AUTOCHECKBOX "Auto size (≈ 2*ceil(3σ)+1)", IDC_CHECK_AUTOSIZE, 12, 56, 160, 12, WS_TABSTOP
    LTEXT "Preview is applied on OK.", IDC_STAT_PREVIEWNOTE, 12, 74, 180, 10

    DEFPUSHBUTTON "OK", IDOK,  90, 92, 50, 14
    PUSHBUTTON    "Cancel", IDCANCEL, 146, 92, 50, 14
END
```

#### 2-2. 대화 상자 클래스

```cpp
// GaussianDlg.h
#pragma once
#include <windows.h>
#include <string>
#include <cmath>
#include "resource.h"
#include "Smoothing.h"

class GaussianDlg {
public:
    GaussianDlg(HWND owner, IppDib& dib) : owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    float  ReadSigma(HWND h) const;
    int    ReadKsize(HWND h) const;
    int    AutoKsizeFromSigma(float s) const;

private:
    HWND   owner_ = nullptr;
    HWND   hDlg_  = nullptr;
    IppDib& dib_;
};

```

```cpp
// GaussianDlg.cpp
#include "GaussianDlg.h"

INT_PTR GaussianDlg::DoModal() {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_GAUSSIAN),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK GaussianDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m==WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self = (GaussianDlg*)l; self->hDlg_ = h;
        return self->OnInit(h);
    }
    auto* self = (GaussianDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;

    switch (m) {
    case WM_COMMAND: return self->OnCommand(h, w, l);
    default: return FALSE;
    }
}
INT_PTR GaussianDlg::OnInit(HWND h) {
    SetDlgItemTextW(h, IDC_EDIT_SIGMA, L"1.0");
    SetDlgItemTextW(h, IDC_EDIT_KSIZE, L"5");
    CheckDlgButton(h, IDC_CHECK_AUTOSIZE, BST_CHECKED);
    return TRUE;
}
float GaussianDlg::ReadSigma(HWND h) const {
    wchar_t buf[64]; GetDlgItemTextW(h, IDC_EDIT_SIGMA, buf, 64);
    wchar_t* end=nullptr; double v = wcstod(buf, &end);
    if (end==buf || v<=0.0) v=1.0;
    return (float)v;
}
int GaussianDlg::ReadKsize(HWND h) const {
    BOOL ok=FALSE; int k = GetDlgItemInt(h, IDC_EDIT_KSIZE, &ok, FALSE);
    if (!ok) k=5;
    if (k<3) k=3; if ((k&1)==0) ++k;
    return k;
}
int GaussianDlg::AutoKsizeFromSigma(float s) const {
    int r = (int)std::ceil(3.0f*s);
    int k = 2*r + 1;
    if (k<3) k=3;
    return k;
}
INT_PTR GaussianDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)) {
    case IDOK: {
        float sigma = ReadSigma(h);
        int k = 0;
        if (IsDlgButtonChecked(h, IDC_CHECK_AUTOSIZE)==BST_CHECKED) {
            k = AutoKsizeFromSigma(sigma);
            wchar_t tmp[16]; swprintf(tmp, 16, L"%d", k);
            SetDlgItemTextW(h, IDC_EDIT_KSIZE, tmp);
        } else {
            k = ReadKsize(h);
        }
        IppDib out;
        GaussianFilter_BGRA32(dib_, out, sigma, k);
        dib_ = out; // 적용
        EndDialog(h, IDOK);
        return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL);
        return TRUE;
    }
    return FALSE;
}
```

---

### 3. “영상 부드럽게 만들기” 메뉴 만들기

#### 3-1. 리소스 메뉴/가속기

```rc
// ImageTool.rc (추가/일부)
POPUP "&Image"
BEGIN
    POPUP "Smooth"
    BEGIN
        MENUITEM "Mean 3x3",            ID_IMAGE_SMOOTH_MEAN3
        MENUITEM "Mean 5x5",            ID_IMAGE_SMOOTH_MEAN5
        MENUITEM "Weighted 3x3 (1-2-1)",ID_IMAGE_SMOOTH_WEIGHTED3
        MENUITEM "Gaussian...\tCtrl+G", ID_IMAGE_SMOOTH_GAUSSIAN
    END
    // ... (기존 항목)
END

IDR_ACCEL ACCELERATORS
BEGIN
    "G", ID_IMAGE_SMOOTH_GAUSSIAN, VIRTKEY, CONTROL
END
```

#### 3-2. 메인 윈도우 이벤트 처리기

```cpp
// main_multiwin.cpp (발췌)
#include "Smoothing.h"
#include "GaussianDlg.h"

// ...
case ID_IMAGE_SMOOTH_MEAN3:
    if (st && st->dib) {
        IppDib out; MeanFilter_BGRA32(st->dib, out, 3);
        st->dib = out; InvalidateRect(hWnd,nullptr,FALSE);
        OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
    }
    return 0;

case ID_IMAGE_SMOOTH_MEAN5:
    if (st && st->dib) {
        IppDib out; MeanFilter_BGRA32(st->dib, out, 5);
        st->dib = out; InvalidateRect(hWnd,nullptr,FALSE);
        OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
    }
    return 0;

case ID_IMAGE_SMOOTH_WEIGHTED3:
    if (st && st->dib) {
        IppDib out; WeightedMean3x3_BGRA32(st->dib, out);
        st->dib = out; InvalidateRect(hWnd,nullptr,FALSE);
        OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
    }
    return 0;

case ID_IMAGE_SMOOTH_GAUSSIAN:
    if (st && st->dib) {
        GaussianDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK) {
            InvalidateRect(hWnd,nullptr,FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 예제 코드 & 상황 (실전 테스트)

### 상황 A) 스마트폰 저조도 사진의 색 노이즈 완화
- **입력**: ISO가 높은 실내 사진(컬러 노이즈).
- **동작**: `Image → Smooth → Gaussian...` 에서 \(\sigma=1.0\), Auto size(≈7×7) → OK.
- **결과**: 노이즈가 줄고 피부 톤이 매끈. 디테일 손실이 크면 \(\sigma=0.7\) 로 낮춰 재적용.

### 상황 B) 글자 스캔의 얼룩 제거
- **입력**: 스캔된 문서(배경 얼룩/스캐너 줄무늬 약간).
- **동작**: `Mean 3x3` 또는 `Weighted 3x3` 적용.
- **결과**: 배경 얼룩이 감소, 글자 가장자리의 둔화가 심하면 **Weighted 3x3** 가 더 자연스러움.

### 상황 C) 다운스케일 전 프리필터
- **입력**: 4K 이미지를 1080p로 축소 예정.
- **동작**: 축소 전 `Gaussian (σ≈1.0)` → 다운스케일(외부 기능).
- **결과**: 에일리어싱/모아레 감소, 더 부드러운 축소 품질.

### 상황 D) 엣지 검출 전 노이즈 억제
- **입력**: 소금-후추(Salt&Pepper) 잡음이 약간 있는 이미지.
- **동작**: `Mean 5x5` 또는 `Gaussian σ≈1.2` 적용 후 Canny/Sobel(다음 장).
- **결과**: 잡음 유발 가짜 에지 감소 → 더 안정된 엣지 맵.

---

## 구현 세부/주의 사항

1) **정규화**
   - `Convolve2D_BGRA32`와 1D 버전에서 `normalize=true`면 커널 합으로 나눔.
   - 평균/가중 평균/가우시안 모두 밝기 보존.

2) **경계 처리**
   - 여기선 **Replicate**(클램프). 대안: Zero padding, Reflect 등.
   - 강한 블러에서 경계가 부자연스럽다면 Reflect가 낫기도 함(필요 시 옵션화).

3) **성능**
   - 가우시안은 **분리 컨볼루션**으로 속도 확보(ksize가 커질수록 효과 큼).
   - 아주 큰 박스 필터는 **적분영상**으로 \(O(1)\) 가능(추가 과제로 권장).

4) **정수 커널**
   - 1-2-1 커널은 정수 연산으로 빠르게 구현 가능. 여기서는 일관성을 위해 float 사용.

5) **알파 채널**
   - 본 예제는 A를 **그대로 복사**. 필요 시 프리멀티플라이 베이스로 연산 설계.

6) **UI/UX**
   - 가우시안 대화 상자의 Auto size는 \(\;k=2\lceil 3\sigma\rceil+1\;\) 경험칙.
   - 미리보기까지 원한다면, 감마 장(6.3)처럼 원본 백업 + 슬라이더 디바운스 적용.

---

## 수학 메모

- 평균 필터(박스)는 **저역 통과**, 주파수 영역에서 sinc 형태. 링잉(진동) 유발 가능 → 가우시안이 시각적으로 더 자연.
- 가우시안의 분리 가능성:
\[
e^{-\frac{x^2+y^2}{2\sigma^2}}
= e^{-\frac{x^2}{2\sigma^2}} \cdot e^{-\frac{y^2}{2\sigma^2}}
\]
- 커널 합 정규화:
\[
\sum_{u,v}K(u,v)=1 \;\Rightarrow\; \text{DC 성분 보존}
\]

---

## 확장 아이디어

- **가우시안 σ/크기 미리보기** + 프로파일(라인컷) 오버레이
- **양방향(Bilateral) 필터**(엣지 보존) — 색/공간 거리 결합
- **미디언 필터**(Salt&Pepper에 강함) — 다음 장 노이즈 제거에서 소개
- **Separable Box**(누적합) / **GUIDED FILTER** 등 고급 스무딩

---

## 요약

- 공간적 필터링을 **2D/분리 컨볼루션**으로 구현했고,
- **평균/가중 평균/가우시안** 3종의 스무딩을 제공,
- 가우시안은 **대화 상자**로 \(\sigma\)/크기 제어,
- 메뉴/이벤트 연결로 **즉시 사용** 가능.
