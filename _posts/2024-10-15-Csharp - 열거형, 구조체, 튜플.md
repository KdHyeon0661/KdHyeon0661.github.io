---
layout: post
title: C# - 열거형, 구조체, 튜플
date: 2024-10-15 19:20:23 +0900
category: Csharp
---
# C# 열거형(enum), 구조체(struct), 튜플(tuple)

## 전체 개요

C#의 데이터 타입 시스템은 다양한 프로그래밍 시나리오를 지원하기 위해 세 가지 핵심 구성 요소를 제공합니다. **enum**은 의미 있는 상수 집합을 정의하고, **struct**는 값 기반의 사용자 정의 타입을 만들며, **tuple**은 경량 다중 반환 값을 처리합니다. 각각은 고유한 특징과 적절한 사용 사례가 있으며, 이들을 올바르게 이해하고 적용하는 것이 효율적인 C# 프로그래밍의 핵심입니다.

---

## enum (열거형) - 의미 있는 상수의 집합

### 기본 개념과 선언

열거형은 관련된 명명된 상수 집합을 정의하는 강력한 방법입니다. 코드의 가독성을 높이고 마법 숫자를 제거하는 데 효과적입니다.

```csharp
enum DayOfWeek
{
    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
}

enum Priority
{
    Low = 1,
    Medium = 2,
    High = 3
}
```

기본적으로 enum의 기저형(underlying type)은 `int`이지만, 필요에 따라 `byte`, `short`, `long` 등으로 명시적으로 지정할 수 있습니다:

```csharp
enum StatusCode : ushort
{
    OK = 200,
    NotFound = 404,
    ServerError = 500
}
```

### 플래그 열거형: 다중 상태 표현

`[Flags]` 특성을 사용하면 열거형 값을 비트 플래그로 사용할 수 있습니다. 이는 여러 상태를 동시에 표현해야 할 때 유용합니다:

```csharp
[Flags]
enum Permissions
{
    None    = 0,
    Read    = 1 << 0,  // 1
    Write   = 1 << 1,  // 2
    Execute = 1 << 2,  // 4
    All     = Read | Write | Execute
}

var userPermissions = Permissions.Read | Permissions.Write;
Console.WriteLine(userPermissions); // Read, Write

// 플래그 확인
if (userPermissions.HasFlag(Permissions.Read))
{
    Console.WriteLine("읽기 권한 있음");
}

// 플래그 추가
userPermissions |= Permissions.Execute;

// 플래그 제거
userPermissions &= ~Permissions.Write;
```

플래그 열거형을 설계할 때는 각 값을 2의 거듭제곱으로 정의하여 비트 연산이 올바르게 작동하도록 해야 합니다.

### 안전한 변환과 검증

enum 값을 다룰 때는 항상 안전한 변환 방법을 사용하는 것이 중요합니다:

```csharp
// 문자열에서 enum으로 안전한 변환
if (Enum.TryParse<DayOfWeek>("Friday", ignoreCase: true, out var day))
{
    Console.WriteLine(day); // Friday
}

// 정수값의 유효성 검증
int numericValue = 99;
if (Enum.IsDefined(typeof(DayOfWeek), numericValue))
{
    var validDay = (DayOfWeek)numericValue;
}
else
{
    Console.WriteLine("유효하지 않은 enum 값입니다.");
}
```

### 패턴 매칭과의 통합

C#의 패턴 매칭 기능은 enum과 자연스럽게 통합됩니다:

```csharp
string GetDayType(DayOfWeek day) => day switch
{
    DayOfWeek.Saturday or DayOfWeek.Sunday => "주말",
    DayOfWeek.Monday => "월요일 블루스",
    _ => "평일"
};
```

---

## struct (구조체) - 값 의미론의 구현

### 구조체의 본질

구조체는 값 타입(value type)으로, 대입이나 전달 시 복사가 발생합니다. 이는 클래스의 참조 의미론과 대조적입니다. 구조체는 일반적으로 작고, 단순하며, 불변적인 데이터 모델링에 적합합니다.

```csharp
public readonly struct Vector2D
{
    public double X { get; }
    public double Y { get; }

    public Vector2D(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double Magnitude => Math.Sqrt(X * X + Y * Y);
    
    public static Vector2D operator +(Vector2D a, Vector2D b)
        => new(a.X + b.X, a.Y + b.Y);
}
```

### `readonly struct`의 장점

`readonly struct`는 모든 인스턴스 멤버가 읽기 전용임을 보장합니다. 이는 불변성을 강제하고, 방어적 복사 비용을 줄이며, JIT 컴파일러의 최적화 기회를 증가시킵니다.

### 가변 구조체의 위험성

가변 구조체는 복사 의미론 때문에 예기치 않은 동작을 초래할 수 있습니다:

```csharp
struct MutablePoint
{
    public int X;
    public int Y;
    
    public void Move(int dx, int dy)
    {
        X += dx;
        Y += dy;
    }
}

var point = new MutablePoint { X = 5, Y = 10 };
var pointCopy = point;  // 복사 발생
pointCopy.Move(2, 3);   // 복사본만 변경

Console.WriteLine($"원본: ({point.X}, {point.Y})");     // (5, 10)
Console.WriteLine($"복사본: ({pointCopy.X}, {pointCopy.Y})"); // (7, 13)
```

이러한 이유로 가능하면 불변 구조체를 사용하는 것이 권장됩니다.

### 동등성 비교 구현

값 타입으로서의 구조체는 적절한 동등성 비교 구현이 중요합니다:

```csharp
public readonly struct Color : IEquatable<Color>
{
    public byte R { get; }
    public byte G { get; }
    public byte B { get; }

    public Color(byte r, byte g, byte b) => (R, G, B) = (r, g, b);

    public bool Equals(Color other) => R == other.R && G == other.G && B == other.B;
    
    public override bool Equals(object? obj) => obj is Color other && Equals(other);
    
    public override int GetHashCode() => HashCode.Combine(R, G, B);
    
    public static bool operator ==(Color left, Color right) => left.Equals(right);
    public static bool operator !=(Color left, Color right) => !left.Equals(right);
}
```

### `record struct`의 편의성

C# 10부터 도입된 `record struct`는 구조체에 record의 편의 기능을 추가합니다:

```csharp
public readonly record struct Position(int X, int Y)
{
    public double Distance => Math.Sqrt(X * X + Y * Y);
}

var pos1 = new Position(3, 4);
var pos2 = pos1 with { X = 5 };  // 비파괴적 수정
Console.WriteLine(pos1 == pos2); // 구조적 비교
```

### 고급: `ref struct`의 제한적 사용

`ref struct`는 스택에만 존재할 수 있는 특수한 구조체로, 고성능 시나리오에서 사용됩니다:

```csharp
public ref struct StackBuffer
{
    private Span<int> _buffer;
    
    public StackBuffer(Span<int> buffer) => _buffer = buffer;
    
    public void Fill(int value) => _buffer.Fill(value);
}
```

`ref struct`는 힙 할당이 불가능하고, 제네릭 타입 매개변수나 비동기 메서드에서 사용할 수 없으며, 클래스의 필드로 사용할 수 없습니다.

---

## tuple (튜플) - 경량 다중 값 컨테이너

### 값 튜플(ValueTuple)의 등장

C# 7에서 도입된 값 튜플은 `System.ValueTuple` 구조체를 기반으로 하며, 이전의 참조 타입 튜플(`System.Tuple`)보다 성능상 이점이 있습니다:

```csharp
var simpleTuple = (42, "Answer", true);
Console.WriteLine(simpleTuple.Item1); // 42
Console.WriteLine(simpleTuple.Item2); // Answer
```

### 명명된 튜플 요소

튜플 요소에 의미 있는 이름을 부여하면 코드 가독성이 크게 향상됩니다:

```csharp
var person = (Name: "Alice", Age: 30, IsActive: true);
Console.WriteLine(person.Name);     // Alice
Console.WriteLine(person.Age);      // 30
Console.WriteLine(person.IsActive); // true
```

이러한 이름은 컴파일 타임에만 존재하며, 리플렉션을 통한 런타임 접근 시에는 사용할 수 없습니다.

### 다중 반환 값과 분해

튜플의 가장 일반적인 사용 사례는 메서드에서 여러 값을 반환하는 것입니다:

```csharp
// 성공 여부, 결과 값, 오류 메시지를 함께 반환
(bool success, int result, string? error) TryParsePositive(string input)
{
    if (!int.TryParse(input, out var number))
        return (false, 0, "숫자가 아닙니다.");
    
    if (number <= 0)
        return (false, 0, "양수가 아닙니다.");
    
    return (true, number, null);
}

// 결과 분해
var (success, result, error) = TryParsePositive("42");

if (success)
    Console.WriteLine($"결과: {result}");
else
    Console.WriteLine($"오류: {error}");
```

### 구조적 비교와 사전 키

튜플은 구조적 비교를 지원하여 딕셔너리 키로 사용하기에 적합합니다:

```csharp
var point1 = (X: 10, Y: 20);
var point2 = (X: 10, Y: 20);

Console.WriteLine(point1 == point2); // True

var cache = new Dictionary<(int X, int Y), string>();
cache[(5, 7)] = "위치 A";
cache[(10, 15)] = "위치 B";

Console.WriteLine(cache[(5, 7)]); // "위치 A"
```

### 튜플의 적절한 사용 범위

튜플은 내부적인 보조 데이터 구조나 임시적인 값 그룹화에 적합하지만, 공개 API에서는 신중하게 사용해야 합니다:

```csharp
// ✅ 적절한 사용: 내부 헬퍼 메서드
private (int min, int max) FindMinMax(IEnumerable<int> numbers)
{
    return (numbers.Min(), numbers.Max());
}

// ❌ 부적절한 사용: 공개 API
public (string, int, DateTime) GetUserDetails()  // 의미 불분명
{
    // ...
}

// ✅ 더 나은 방법: 명시적 타입 정의
public record UserDetails(string Name, int Age, DateTime RegisteredDate);
```

---

## 통합 활용 사례

### 도메인 모델링 예제

세 가지 타입을 조합하여 명확한 도메인 모델을 구성할 수 있습니다:

```csharp
[Flags]
enum ProductFeatures
{
    None = 0,
    EcoFriendly = 1,
    Recyclable = 2,
    Biodegradable = 4,
    All = EcoFriendly | Recyclable | Biodegradable
}

readonly record struct ProductId(int Value);

readonly record struct Price(decimal Amount, string CurrencyCode)
{
    public static Price operator +(Price a, Price b)
    {
        if (a.CurrencyCode != b.CurrencyCode)
            throw new InvalidOperationException("통화 코드가 일치하지 않습니다.");
        
        return new Price(a.Amount + b.Amount, a.CurrencyCode);
    }
}

record struct CartItem(ProductId ProductId, int Quantity, Price UnitPrice)
{
    public Price TotalPrice => new(UnitPrice.Amount * Quantity, UnitPrice.CurrencyCode);
}

class ShoppingCart
{
    private readonly List<CartItem> _items = new();
    
    // 튜플을 사용한 통계 정보 반환
    public (int TotalItems, Price TotalValue, int UniqueProducts) GetSummary()
    {
        var totalItems = _items.Sum(item => item.Quantity);
        var totalValue = _items.Aggregate(
            new Price(0, "USD"),
            (sum, item) => sum + item.TotalPrice);
        var uniqueProducts = _items.Select(item => item.ProductId).Distinct().Count();
        
        return (totalItems, totalValue, uniqueProducts);
    }
}
```

### 성능 고려사항

1. **enum**: 정수 기반이므로 매우 빠르고 메모리 효율적입니다. 스위치 문과 잘 통합됩니다.
2. **struct**: 작은 크기(일반적으로 16-32바이트 이하)일 때 성능 이점이 있습니다. 큰 구조체는 복사 비용이 클 수 있습니다.
3. **tuple**: 값 타입이므로 GC 압력이 적지만, 많은 필드를 가진 튜플은 명시적 타입 정의를 고려해야 합니다.

### 패턴 매칭의 통합 활용

C#의 패턴 매칭은 enum, struct, tuple을 모두 자연스럽게 처리합니다:

```csharp
object ProcessData(object input) => input switch
{
    // enum 패턴
    DayOfWeek.Saturday or DayOfWeek.Sunday => "주말 처리",
    
    // 구조체 패턴
    Vector2D { X: > 0, Y: > 0 } vector => $"1사분면: {vector}",
    
    // 튜플 패턴
    (int x, int y) when x == y => "대각선",
    (string name, int age) person => $"{name}({age}세)",
    
    // 재귀적 패턴
    CartItem { Quantity: > 10 } item => "대량 주문",
    
    _ => "기본 처리"
};
```

---

## 결론

C#의 enum, struct, tuple은 각각 고유한 역할과 최적의 사용 시나리오를 가진 강력한 언어 기능입니다.

**enum**은 명명된 상수 집합을 정의하여 코드의 가독성과 유지보수성을 높이는 동시에, 플래그 열거형을 통해 복합 상태를 효율적으로 표현할 수 있습니다. 타입 안전성을 제공하면서도 기본적으로 정수형으로 동작하여 성능 저하 없이 사용할 수 있습니다.

**struct**는 값 의미론을 구현하는 데 필수적입니다. 작고 불변적인 데이터 타입을 모델링할 때 클래스보다 적합할 수 있으며, 특히 `readonly struct`와 `record struct`의 등장으로 더욱 안전하고 표현력 있는 구조체 설계가 가능해졌습니다. 그러나 구조체의 복사 의미론을 이해하고, 크기와 사용 패턴을 고려하여 클래스와의 선택을 신중하게 해야 합니다.

**tuple**은 경량 다중 반환 값 메커니즘으로서 내부 코드를 간결하게 만들어줍니다. 명명된 튜플과 분해 구문은 가독성을 유지하면서 편의성을 제공합니다. 그러나 공개 API에서는 튜플의 과용을 피하고, 의미 있는 타입으로 승격시켜 도메인 모델의 명확성을 유지하는 것이 중요합니다.

이 세 가지 타입을 적절히 조합하고 활용하면 더욱 표현력 있고, 효율적이며, 유지보수 가능한 C# 코드를 작성할 수 있습니다. 각각의 특징을 이해하고 상황에 맞게 적용하는 것이 현대 C# 프로그래밍의 핵심 역량입니다.