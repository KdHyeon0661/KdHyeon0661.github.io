---
layout: post
title: C# - 열거형, 구조체, 튜플
date: 2024-10-15 19:20:23 +0900
category: Csharp
---
# C# 열거형(enum), 구조체(struct), 튜플(tuple)

## 0. 큰 그림 요약

- **enum**: “의미 있는 정수 집합”. `switch`/패턴매칭·비트 플래그·파싱에 강함.
- **struct**: **값 타입(Value Type)** 사용자 정의. 작고 불변인 모델에 적합. 복사语의 의미, `readonly struct`, `record struct`, `ref struct(Span<T>)` 주의.
- **tuple**: 경량 “여러 값 묶음”. `ValueTuple` 기반, **이름 붙은 요소/분해** 지원. 과사용 시 **DTO/record**로 격상 고려.

---

## 1. enum (열거형)

### 1.1 선언·기본 사용

```csharp
enum DayOfWeek
{
    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
}

enum Level
{
    Low = 1,
    Medium = 2,
    High = 3
}
```

```csharp
DayOfWeek today = DayOfWeek.Monday;
if (today == DayOfWeek.Monday)
    Console.WriteLine("월요일입니다.");
```

- 기본 **기저형(underlying type)**은 `int`. 필요 시 지정 가능: `byte`, `short`, `long` 등.

```csharp
enum ErrorCode : ushort
{
    None = 0,
    NotFound = 404,
    Internal = 500
}
```

### 1.2 [Flags] 비트 플래그

여러 상태를 **비트 OR**로 합성할 때:

```csharp
[Flags]
enum FileAccess
{
    None  = 0,
    Read  = 1 << 0,  // 1
    Write = 1 << 1,  // 2
    Exec  = 1 << 2,  // 4
    All   = Read | Write | Exec
}

var perms = FileAccess.Read | FileAccess.Write;
Console.WriteLine(perms);             // Read, Write
Console.WriteLine(perms.HasFlag(FileAccess.Read)); // True

perms |= FileAccess.Exec;             // 부여
perms &= ~FileAccess.Write;           // 제거
```

> **주의**: `[Flags]`를 쓰면 `ToString()`이 **조합된 이름**을 출력. 값은 **2의 거듭제곱**으로 정의하는 것이 일반적.

### 1.3 파싱·변환·검증

```csharp
// 문자열 → enum
if (Enum.TryParse<DayOfWeek>("Friday", ignoreCase: true, out var d))
{
    Console.WriteLine(d); // Friday
}

// 정수 → enum (검증 권장)
int raw = 123;
if (Enum.IsDefined(typeof(DayOfWeek), raw))
    today = (DayOfWeek)raw;
```

- **정수 캐스팅**은 어떤 값도 들어올 수 있으므로, 항상 `Enum.IsDefined` 또는 **화이트리스트 스위치**로 검증.

### 1.4 switch/패턴 매칭

```csharp
string Describe(DayOfWeek d) => d switch
{
    DayOfWeek.Saturday or DayOfWeek.Sunday => "주말",
    _ => "평일"
};
```

### 1.5 제네릭 제약 (C# 7.3+)

```csharp
// enum 제약
static bool IsDefined<T>(T value) where T : struct, Enum
    => Enum.IsDefined(typeof(T), value);
```

### 1.6 직렬화·표시 문자열

- **표시 이름**이 필요하면 별도 맵이나 **`Display` 특성**(+리플렉션) 사용.
- 외부 I/O 스키마에는 **정수값 고정**을 신중히. 값 변경 시 호환성 깨질 수 있음.

---

## 2. struct (구조체)

### 2.1 개요와 선택 기준

- **값 타입**: 대입/전달 시 **복사语 의미**.  
- 보통 **작고 불변(immutable)**, **상태 공유 불필요**한 데이터에 적합.  
- **상속 불가**, 인터페이스는 구현 가능.

> 흔한 오해: “struct는 스택, class는 힙” → **값 타입은 컨텍스트에 따라 스택/힙/박싱 내**에 저장될 수 있습니다. 핵심은 **값语의 의미(복사)**.

### 2.2 선언·생성자·불변 설계

```csharp
public readonly struct Point
{
    public int X { get; }
    public int Y { get; }

    // C# 10: 매개변수 없는 생성자(값 타입) 허용
    public Point() { X = 0; Y = 0; } 

    public Point(int x, int y) { X = x; Y = y; }

    public void Deconstruct(out int x, out int y) { x = X; y = Y; }
}
```

- **`readonly struct`**: 인스턴스의 **모든 인스턴스 멤버가 읽기 전용**이어야 하며, 방어적 복사 비용을 줄여 JIT 최적화에 유리.

### 2.3 가변 struct 주의

```csharp
struct MutableVec
{
    public int X, Y;
    public void MoveX(int dx) => X += dx;
}

var v = new MutableVec { X = 1, Y = 2 };
var list = new List<MutableVec> { v };

// foreach의 반복 변수는 복사본일 수 있음 → 의도치 않은 “수정 실패”
foreach (var m in list)
    /* m.MoveX(10); */ // 경고/의도 불일치

// 안전: 인덱서로 수정
var tmp = list[0]; tmp.MoveX(10); list[0] = tmp;
```

- 가변 `struct`는 **복사로 인한 변화 손실** 지점이 많음 → **불변** 추천.

### 2.4 `IEquatable<T>`·연산자 오버로드

```csharp
public readonly struct Size : IEquatable<Size>
{
    public int W { get; }
    public int H { get; }
    public Size(int w, int h) { W = w; H = h; }

    public bool Equals(Size other) => W == other.W && H == other.H;
    public override bool Equals(object? obj) => obj is Size s && Equals(s);
    public override int GetHashCode() => HashCode.Combine(W, H);

    public static bool operator ==(Size a, Size b) => a.Equals(b);
    public static bool operator !=(Size a, Size b) => !a.Equals(b);
    public static Size operator +(Size a, Size b) => new(a.W + b.W, a.H + b.H);
}
```

- 값 타입 비교·딕셔너리 키 등에서 **박싱 없이** 빠른 비교를 위해 `IEquatable<T>` 구현 권장.

### 2.5 `record struct` / `readonly record struct`

```csharp
public readonly record struct RPoint(int X, int Y);
```

- **자동 동등성/분해/`with`** 등 **record**의 편의 + **값 타입**의 조합.
- 불변 **DTO/키 타입**에 이상적.

```csharp
var p1 = new RPoint(1, 2);
var p2 = p1 with { X = 10 };   // 복사 기반 업데이트
Console.WriteLine(p1 == p2);   // False (값 비교)
```

### 2.6 고급: `ref struct` (Span<T> 등)

```csharp
public ref struct BufferWindow
{
    private Span<byte> _span;
    public BufferWindow(Span<byte> span) => _span = span;
    public Span<byte> Slice(int start, int len) => _span.Slice(start, len);
}
```

- **스택 한정** 타입: 필드·힙·박싱·클로저·async/yield 등 **제약 많음**.
- **고성능 메모리 처리**(파싱·복사 최소화)에 유리.

### 2.7 성능·박싱·컬렉션

- 인터페이스로 호출 시 **박싱** 가능성 존재 → **제네릭 제약**이나 **구조체 친화 API** 사용.
- 대용량 배열/스팬에선 **복사 최소화**를 최우선.

---

## 3. tuple (튜플)

### 3.1 `System.ValueTuple` 기반 — 선언·접근

```csharp
var tuple = (1, "Apple", true);
Console.WriteLine(tuple.Item1); // 1
Console.WriteLine(tuple.Item2); // Apple
```

- C# 7+ **언어 내장 문법**은 `ValueTuple`(값 타입)을 사용 → **할당·GC 압력↓**.

> 구형 `System.Tuple<T1,...>`은 **참조 타입**. 새 코드에선 가급적 **ValueTuple** 사용.

### 3.2 “이름 붙은” 튜플 요소

```csharp
(string name, int age) person = ("Alice", 30);
Console.WriteLine(person.name); // Alice
Console.WriteLine(person.age);  // 30
```

> 요소 이름은 **호출·대입·반환** 경로에서 **전파**됩니다(컴파일 타임 이름; 런타임 리플렉션 이름과 다를 수 있음).

### 3.3 메서드 반환·분해(Deconstruction)

```csharp
(string name, int age) GetUser() => ("Bob", 25);

// ① ItemX로 접근
var u = GetUser();
Console.WriteLine(u.name); // Bob

// ② 분해
var (n, a) = GetUser();
Console.WriteLine($"{n}, {a}");

// ③ discard
var (_, onlyAge) = GetUser();
```

### 3.4 튜플 비교·해시·키로 사용

```csharp
var a = (x: 1, y: 2);
var b = (x: 1, y: 2);
Console.WriteLine(a == b); // True (구조적 비교)

var dict = new Dictionary<(int x, int y), string>();
dict[(1,2)] = "P";
Console.WriteLine(dict[(1,2)]); // P
```

- `ValueTuple`은 **구조적 동등성/해시**를 제공 → **맵 키**로 쓰기 쉬움.

### 3.5 주의·설계 지침

- **간단한 다중 반환**에 적합.  
- API(public)에서 **튜플 남용**은 의미 흐림/변경 취약 → **DTO/record** 고려.
- 직렬화 프레임워크에 따라 **이름 보존**이 다를 수 있음.

---

## 4. 함께 쓰기 — 작은 예제 모음

### 4.1 enum + switch 표현식

```csharp
enum Kind { Info, Warn, Error }

string Badge(Kind k) => k switch
{
    Kind.Info  => "I",
    Kind.Warn  => "W",
    Kind.Error => "E",
    _          => "?"
};
```

### 4.2 struct + 연산자 + 불변

```csharp
public readonly record struct Money(decimal Amount, string Currency)
{
    public static Money operator +(Money a, Money b)
        => a.Currency == b.Currency
           ? new(a.Amount + b.Amount, a.Currency)
           : throw new InvalidOperationException("통화 다름");
}
```

### 4.3 tuple로 파싱 결과 반환

```csharp
// 성공 여부 + 값 + 에러 메시지
(bool ok, int value, string? error) ParseInt(string s)
{
    if (int.TryParse(s, out var v)) return (true, v, null);
    return (false, 0, "정수가 아님");
}

var (ok, v, err) = ParseInt("123");
Console.WriteLine(ok ? v : err);
```

---

## 5. 패턴 매칭과의 결합 (enum/tuple/struct)

```csharp
enum TokenKind { Number, Ident, Plus, Minus }

readonly record struct Token(TokenKind Kind, string Text);

string Explain(object x) => x switch
{
    Token { Kind: TokenKind.Number, Text: var t } => $"숫자:{t}",
    (int a, int b)                                 => $"튜플 합:{a + b}",
    DayOfWeek.Saturday or DayOfWeek.Sunday         => "주말",
    _                                              => "기타"
};
```

---

## 6. 성능·메모리 메모 (실전 감각)

1. **enum**은 **정수**. 컬렉션/스위치 분기에 **빠름**. 플래그 조합은 **비트 연산**으로 상수시간.  
2. **struct**는 **복사**가 발생. 큰 struct의 빈번한 전달은 **참조 타입**보다 느릴 수 있음.  
   - 불변 + 작게 유지(예: 16~32바이트 내) → 유리.  
   - 인터페이스 호출·박싱 경로 주의.  
3. **ValueTuple**은 **값 타입**이라 GC 우호적. 큰 튜플/중첩 튜플은 **명세 객체(Record/DTO)**로 승격 고려.

---

## 7. 수학적 배경 — product/sum 관점

- **struct/tuple**은 여러 필드를 **곱(product)**처럼 묶는 타입:  
  $$ T = T_1 \times T_2 \times \cdots \times T_n $$
- **enum**은 **합(sum) 타입**의 단순화(배타적 선택):  
  $$ E \in \{e_1, e_2, \ldots, e_k\} $$
- C#은 **직접적 sum 타입**이 없으나, `enum` + **payload**(record/tuple) 조합으로 **재현** 가능.

---

## 8. 체크리스트

**enum**
- [ ] 외부 계약이면 **정수값 고정**에 주의  
- [ ] 플래그면 `[Flags]` + 2ⁿ 값  
- [ ] 입력 파싱 시 `IsDefined` 및 화이트리스트 스위치

**struct**
- [ ] 가능하면 **불변**·`readonly struct`/`record struct`  
- [ ] 크기가 크면 **참조 타입 고려**  
- [ ] 인터페이스 경로 박싱/복사 비용 점검  
- [ ] `IEquatable<T>`·해시 구현

**tuple**
- [ ] 내부 보조 반환에 적합  
- [ ] 공용 API에는 과사용 금지 → **의미 타입(Record/DTO)**로 승격  
- [ ] 요소 이름 전파/직렬화 정책 확인

---

## 9. 확장 예제 — 소형 도메인 모델

```csharp
[Flags]
enum OrderFlags { None = 0, Gift = 1, Express = 2, Overseas = 4 }

readonly record struct ProductId(int Value);
readonly record struct Money(decimal Amount, string Currency);

readonly record struct Line(
    ProductId Product,
    int Qty,
    Money UnitPrice)
{
    public Money Total => new(UnitPrice.Amount * Qty, UnitPrice.Currency);
}

readonly record struct Order(
    Guid Id,
    OrderFlags Flags,
    IReadOnlyList<Line> Lines)
{
    public Money Sum() => Lines.Aggregate(new Money(0, "KRW"),
        (acc, l) => acc.Currency == l.Total.Currency
            ? new(acc.Amount + l.Total.Amount, acc.Currency)
            : throw new InvalidOperationException("통화 불일치"));
}

// 튜플로 파싱+검증 결과 제공
(bool ok, Order order, string? error) CreateSample()
{
    var lines = new List<Line>
    {
        new(new ProductId(10), 2, new Money(5000, "KRW")),
        new(new ProductId(20), 1, new Money(12000, "KRW")),
    };
    var ord = new Order(Guid.NewGuid(), OrderFlags.Gift | OrderFlags.Express, lines);
    return (true, ord, null);
}

var (ok, ord, err) = CreateSample();
Console.WriteLine(ok ? ord.Sum() : err);
```

---

## 10. 요약

- **enum**: 가독성/안전성↑. 플래그·파싱·패턴매칭 활용.  
- **struct**: 값语의 의미·복사 비용을 이해하고 **불변·작은 크기**로 설계. 필요 시 `record struct`/`readonly struct`/`ref struct`.  
- **tuple**: **간단한 다중 반환**에 최적. 공용 API 남용은 피하고, 필요 시 **의미 타입**으로 승격.
