---
layout: post
title: Spring - 스프링이란
date: 2025-10-11 18:25:23 +0900
category: Spring
---
# 스프링이란

> **목표**
> 이 시리즈는 “스프링 생태계를 실무 수준으로 운영”하는 데 필요한 기초→중급→운영까지의 전체 경로를 제시한다.
> - **누구를 위한가?**: Java 기본 문법을 알고 백엔드 웹 개발을 시작/확장하려는 개발자
> - **어떤식으로?**: 개념→코드 예제→실습 과제→운영 체크리스트 순으로, 가능한 **실행 가능한** 예제를 포함
> - **산출물**: 템플릿 레포, 예제 API, 도커/쿠버 배포 스크립트, 로깅/관측 대시보드 구성

---

## 스프링 생태계 한눈에 보기

- **Spring Framework**: IoC/DI, AOP, 트랜잭션 등 스프링의 심장부.
- **Spring Boot**: 자동 구성, 스타터 의존성, 내장 톰캣. “빠르게 시작하고 운영까지 이끄는” 플랫폼.
- **Spring Data**: JPA/Redis/Mongo 등 데이터 접근 추상화.
- **Spring Security**: 인증/인가 표준. 필터 체인 기반.
- **Spring Batch**: 대용량 배치 처리 프레임워크.
- **Spring Cloud**: 분산 시스템(구성 서버, 게이트웨이, 서킷 브레이커, 서비스 디스커버리 등).
- **Observability**: Actuator + Micrometer + OpenTelemetry로 메트릭/로그/트레이스 통합.
- **Build & Packaging**: Gradle/Maven + Buildpacks/Jib + Docker/K8s로 배포.

---

## 학습/실습 방식

- **모든 장**은 다음 패턴을 따른다.
  1. **개념**: 설계 목적과 배경, 오해 포인트.
  2. **핵심 예제**: 최소 기능으로 동작이 보이는 코드.
  3. **실습 과제**: 기능 확장/문제 상황 재현/성능 비교.
  4. **운영 포인트**: 설정 프로파일, 보안, 로깅, 관측성.
  5. **체크리스트**: PR 전/배포 전 확인 항목.

- **실행 환경 표준화**
  - JDK 21 LTS 권장(현 시점 LTS 기준), Gradle 최신 Wrapper, Docker Desktop or Colima(Linux에서는 Podman도 가능).
  - DB는 PostgreSQL 16, 캐시는 Redis 7을 기본으로 사용.

---

## 예제 레포 구조(권장)

```
spring-roadmap/
├─ docs/                         # 블로그용 그림/도표/설정 스니펫
├─ examples/
│  ├─ 01-hello-boot/            # Hello, Spring Boot
│  ├─ 02-web-mvc-validation/
│  ├─ 03-data-jpa/
│  ├─ 04-security-jwt/
│  ├─ 05-test-testcontainers/
│  ├─ 06-observability/
│  ├─ 07-cache-redis/
│  ├─ 08-batch/
│  ├─ 09-messaging-kafka/
│  ├─ 10-cloud-gateway/
│  └─ 99-prod-template/         # 실무 템플릿(멀티모듈, 공통 모듈, 배포 스크립트)
├─ infra/
│  ├─ docker-compose.yml        # 로컬 통합 실행(연습용)
│  ├─ k8s/                      # 매니페스트 샘플
│  └─ grafana-dashboards/       # 관측 대시보드 JSON
└─ Makefile                      # make up / down / test / lint 등
```

---

# 왜 스프링인가: 생태계/채택 이유/대안 비교

## 스프링의 강점

- **생태계 규모**: 웹/보안/데이터/배치/클라우드/관측까지 **엔드투엔드 솔루션**.
- **생산성**: 스프링 부트 자동 구성 + 스타터 = “의존성+설정”의 표준화. 빠른 부팅/개발 주기.
- **테스팅 친화**: 슬라이스 테스트, Testcontainers 연동, 컨텍스트 캐시로 속도 최적화.
- **운영 친화**: Actuator, Micrometer, 헬스체크/메트릭/프로메테우스 노출이 표준화.
- **확장성**: 모듈화/멀티모듈/헥사고널/클린 아키텍처에 쉽게 녹아듦.
- **채택 커뮤니티**: 레퍼런스/샘플/문서가 풍부, 고용 시장에서의 가시성.

## 흔한 오해와 바로잡기

- “스프링 = 무겁다”: 부트 3.x + AOT + GraalVM Native 선택지로 **부팅/메모리** 최적화 가능.
- “JPA는 느리다”: 지연 로딩/N+1/배치 사이즈/캐시/쿼리 튜닝/DB 인덱싱 등 **설계/운영 역량**의 문제인 경우가 대다수.
- “리액티브만이 고성능”: I/O 특성과 팀 역량에 따라 선택. WebMVC도 충분히 고성능. WebFlux는 **대규모 동시성/스트리밍**에 강점.

## 대안 프레임워크 비교(간단 표)

| 항목 | Spring Boot | Quarkus | Micronaut | Ktor(코틀린) | NestJS(Node) |
|---|---|---|---|---|---|
| 철학 | 범용/생태계 중심 | 네이티브/클라우드 퍼스트 | 애노테이션 적고 컴파일타임 처리 | 경량/코틀린 친화 | TS/Node 생태계 |
| 개발속도 | ★★★★★ | ★★★★☆ | ★★★★☆ | ★★★★☆ | ★★★★★ |
| 러닝커브 | 중 | 중 | 중 | 중 | 중 |
| 생태계 | ★★★★★ | ★★★★ | ★★★★ | ★★★ | ★★★★ |
| 네이티브빌드 | 지원(GraalVM) | 강점 | 강점 | 제한 | 해당없음 |
| 관측/운영 | 표준화 강함 | 좋음 | 좋음 | 커스텀 | 다양(플러그인) |
| 채용시장 | 매우 큼 | 늘어나는 중 | 늘어나는 중 | 제한적 | 큼 |

> 결론: **엔드투엔드 표준화/레퍼런스/커뮤니티**를 중시한다면 Spring Boot가 현실적/안정적 선택.

---

# 실습 환경: JDK, Gradle vs Maven, IDE, Docker, DB

> 이 절은 **로컬 개발 환경 표준**을 만든다. “내 PC에서 돌았다”가 **팀 전체에서 재현**되도록 **Wrapper/Container/Compose**를 적극 활용한다.

---

## JDK 설정

### 권장 버전 & 설치 경로

- **권장**: JDK **21 LTS**
- 배포판: Temurin(Adoptium), Liberica, Oracle, Amazon Corretto 등 **팀에서 하나로 고정**
- 경로/버전 관리:
  - macOS/Linux: **SDKMAN!**, asdf, jEnv 중 하나
  - Windows: **Scoop/Chocolatey** + `JAVA_HOME` 고정

### 설치 예시

- **macOS (SDKMAN!)**
  ```bash
  curl -s "https://get.sdkman.io" | bash
  source "$HOME/.sdkman/bin/sdkman-init.sh"
  sdk list java
  sdk install java 21.0.4-tem    # Temurin 21
  sdk default java 21.0.4-tem
  java -version
  ```

- **Windows (Scoop)**
  ```powershell
  Set-ExecutionPolicy RemoteSigned -scope CurrentUser
  irm get.scoop.sh | iex
  scoop bucket add java
  scoop install temurin-lts-jdk
  java -version
  ```

### JAVA_HOME 설정

- **macOS/Linux (bash/zsh)**
  ```bash
  echo 'export JAVA_HOME=$(/usr/libexec/java_home -v 21)' >> ~/.zshrc
  echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.zshrc
  source ~/.zshrc
  ```

- **Windows (PowerShell 프로필)**
  ```powershell
  [Environment]::SetEnvironmentVariable("JAVA_HOME","C:\Program Files\Eclipse Adoptium\jdk-21", "User")
  $env:PATH="$env:JAVA_HOME\bin;$env:PATH"
  ```

---

## 빌드 도구: Gradle vs Maven

### 선택 가이드(짧은 결론)

- **Gradle 권장**: 멀티모듈/캐시/속도/빌드 스크립트 유연성.
- **Maven 선호 팀**: XML 선언형/일관성/많은 기존 문서/레거시 적합.
- **실무**: 두 개 다 사용 가능. “팀의 공용 템플릿”을 확보하는 게 핵심.

### Gradle 핵심 포인트

- **Wrapper 필수**: `./gradlew`로 버전 표준화.
- **의존성 관리는 BOM**: 스프링 공식 BOM/버전 카탈로그 활용.
- **캐시/병렬 빌드**로 빌드 시간 단축.
- **Kotlin DSL**(권장)로 타입 안정성/리팩토링 수월.

**Gradle(카탈로그+멀티모듈) 예시**
`settings.gradle.kts`
```kotlin
rootProject.name = "prod-template"
include("common", "web-api", "batch")

dependencyResolutionManagement {
  versionCatalogs {
    create("libs") {
      version("springBoot", "3.3.4")
      version("springDep", "1.1.6")
      alias("spring-boot").toPluginId("org.springframework.boot").versionRef("springBoot")
      alias("spring-dep").toPluginId("io.spring.dependency-management").versionRef("springDep")
      alias("lombok").to("org.projectlombok","lombok").version("1.18.34")
      alias("spring-boot-starter-web").to("org.springframework.boot","spring-boot-starter-web")
      alias("spring-boot-starter-validation").to("org.springframework.boot","spring-boot-starter-validation")
      alias("spring-boot-starter-actuator").to("org.springframework.boot","spring-boot-starter-actuator")
      alias("spring-boot-starter-test").to("org.springframework.boot","spring-boot-starter-test")
      alias("spring-boot-starter-data-jpa").to("org.springframework.boot","spring-boot-starter-data-jpa")
      alias("postgresql").to("org.postgresql", "postgresql").version("42.7.4")
      alias("testcontainers-bom").to("org.testcontainers","testcontainers-bom").version("1.20.2")
      alias("testcontainers-postgresql").to("org.testcontainers","postgresql")
    }
  }
}
```

`build.gradle.kts`(루트)
```kotlin
plugins {
  alias(libs.plugins.spring.boot) apply false
  alias(libs.plugins.spring.dep) apply false
  kotlin("jvm") version "2.0.20" apply false // 코틀린 쓰는 경우
}

subprojects {
  apply(plugin = "java")
  group = "com.example"
  version = "0.0.1-SNAPSHOT"

  repositories { mavenCentral() }

  tasks.withType<Test> { useJUnitPlatform() }

  // 공통 자바 버전
  extensions.configure<JavaPluginExtension> {
    toolchain { languageVersion.set(JavaLanguageVersion.of(21)) }
  }
}
```

`web-api/build.gradle.kts`
```kotlin
plugins {
  alias(libs.plugins.spring.boot)
  alias(libs.plugins.spring.dep)
}

dependencies {
  implementation(libs.spring.boot.starter.web)
  implementation(libs.spring.boot.starter.validation)
  implementation(libs.spring.boot.starter.actuator)
  implementation(libs.spring.boot.starter.data.jpa)
  runtimeOnly(libs.postgresql)

  testImplementation(libs.spring.boot.starter.test)
  testImplementation(platform(libs.testcontainers.bom))
  testImplementation(libs.testcontainers.postgresql)
}
```

### Maven 핵심 포인트

- XML 기반, **표준 라이프사이클**과 플러그인 중심.
- **Wrapper 제공**(mvnw)으로 버전 고정.
- **dependencyManagement**로 버전 일원화, **Spring Boot Parent**로 간편 버전 관리.

**Maven(멀티모듈) 예시**
`pom.xml`(루트)
```xml
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>prod-template</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>pom</packaging>

  <modules>
    <module>common</module>
    <module>web-api</module>
    <module>batch</module>
  </modules>

  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.3.4</version>
    <relativePath/>
  </parent>

  <properties>
    <java.version>21</java.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>testcontainers-bom</artifactId>
        <version>1.20.2</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <build>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>
```

`web-api/pom.xml`
```xml
<project>
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>com.example</groupId>
    <artifactId>prod-template</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>

  <artifactId>web-api</artifactId>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.testcontainers</groupId>
      <artifactId>postgresql</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>
</project>
```

**속도 팁**
- Gradle: `org.gradle.caching=true`, `org.gradle.parallel=true` (gradle.properties)
- Maven: `mvn -T 1C`(코어 수만큼), `incremental build`, 플러그인 캐시

---

## IDE 선택 & 설정

- **IntelliJ IDEA**(권장): 스프링/스프링부트/스프링 데이터/테스트 지원이 강력.
- **Eclipse STS**: 스프링 툴 플러그인 포함, 경량 선호 시.
- **VS Code**: Java Extension Pack + Spring Boot Dashboard 확장.

**공통 설정**
- JDK 21 toolchain/Project SDK 맞추기.
- 인스펙션: Nullability, Unused, Package cycles 경고 활성화.
- 코드 스타일: Google Style or 팀 컨벤션 + Spotless/Checkstyle 연동.
- **DevTools**(부트)로 핫 리로드 사용:
  ```kotlin
  // Gradle
  dependencies {
    developmentOnly("org.springframework.boot:spring-boot-devtools")
  }
  ```

---

## Docker & DB (로컬 통합 실습)

### Docker 기본

- **이미지 빌드**: 멀티스테이지, Buildpacks, Jib 등 중 택1
- **네트워크**: `bridge` 네트워크로 앱-DB 간 연결 표준화
- **볼륨**: DB 데이터 지속화를 위해 named volume 사용

### docker-compose로 통합

`infra/docker-compose.yml`
```yaml
version: "3.9"
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: app
      POSTGRES_PASSWORD: app
      POSTGRES_DB: appdb
    ports: ["5432:5432"]
    volumes:
      - dbdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL","pg_isready -U app -d appdb"]
      interval: 5s
      timeout: 3s
      retries: 10

  redis:
    image: redis:7
    ports: ["6379:6379"]
    command: ["redis-server","--appendonly","yes"]
    healthcheck:
      test: ["CMD","redis-cli","ping"]
      interval: 5s
      timeout: 3s
      retries: 10

  app:
    build:
      context: ../examples/01-hello-boot
      dockerfile: Dockerfile
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATASOURCE_URL: jdbc:postgresql://db:5432/appdb
      SPRING_DATASOURCE_USERNAME: app
      SPRING_DATASOURCE_PASSWORD: app
      SPRING_REDIS_HOST: redis
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    ports: ["8080:8080"]

volumes:
  dbdata:
```

> **실행**
```bash
cd infra
docker compose up -d --build
```

---

## Hello, Spring Boot 빠른 예제

### 프로젝트 생성(Gradle/Kotlin DSL 예시)

```bash
mkdir -p examples/01-hello-boot && cd $_
curl -s https://start.spring.io/starter.tgz \
  -d bootVersion=3.3.4 \
  -d type=gradle-project \
  -d language=java \
  -d groupId=com.example \
  -d artifactId=hello-boot \
  -d name=hello-boot \
  -d packageName=com.example.hello \
  -d javaVersion=21 \
  -d dependencies=web,validation,actuator \
| tar -xz --strip-components=1
```

### 간단 컨트롤러 + 검증 + 예외 응답

`src/main/java/com/example/hello/api/GreetingController.java`
```java
package com.example.hello.api;

import jakarta.validation.constraints.NotBlank;
import org.springframework.http.HttpStatus;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

record Greeting(String message) {}
record HelloRequest(@NotBlank String name) {}

@RestController
@RequestMapping("/api")
@Validated
public class GreetingController {

  @GetMapping("/greet")
  public Greeting greet(@RequestParam(defaultValue = "world") String name) {
    return new Greeting("Hello, " + name + "!");
  }

  @PostMapping("/hello")
  public Greeting hello(@RequestBody @Validated HelloRequest req) {
    return new Greeting("Hi, " + req.name() + "!");
  }

  @ExceptionHandler
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  public Greeting onError(Exception e) {
    return new Greeting("Bad request: " + e.getMessage());
  }
}
```

### 설정 프로파일/Actuator

`src/main/resources/application.yml`
```yaml
spring:
  application:
    name: hello-boot
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
```

`src/main/resources/application-docker.yml`
```yaml
server:
  port: 8080
management:
  endpoint:
    health:
      probes:
        enabled: true
```

> **실행**
```bash
./gradlew bootRun
curl http://localhost:8080/api/greet
curl -X POST http://localhost:8080/api/hello -H "Content-Type: application/json" -d '{"name":"Spring"}'
curl http://localhost:8080/actuator/health
```

---

## Docker 이미지 빌드 (세 가지 전략)

### 멀티스테이지 Dockerfile

`examples/01-hello-boot/Dockerfile`
```dockerfile
# Build stage

FROM gradle:8.10.2-jdk21 as build
WORKDIR /home/gradle/project
COPY . .
RUN gradle clean bootJar --no-daemon

# Run stage (distroless or slim)

FROM eclipse-temurin:21-jre-jammy
WORKDIR /app
COPY --from=build /home/gradle/project/build/libs/*.jar app.jar

# JVM 런타임 최적화 예시

ENV JAVA_TOOL_OPTIONS="-XX:InitialRAMPercentage=50 -XX:MaxRAMPercentage=80 -XX:+UseZGC"
EXPOSE 8080
ENTRYPOINT ["java","-jar","/app/app.jar"]
```

> **빌드 & 실행**
```bash
docker build -t hello-boot:local .
docker run --rm -p 8080:8080 hello-boot:local
```

### Buildpacks (pack CLI)

- Gradle 플러그인 없이도 가능. JDK+스프링부트 탐지 → 최적 이미지 생성.

```bash
pack build hello-boot:pack --path . --builder paketobuildpacks/builder-jammy-base
docker run --rm -p 8080:8080 hello-boot:pack
```

### Jib(Gradle 플러그인)

- **Dockerfile 없이** 빌드. 레이어 최적화가 쉽다.

`build.gradle.kts`
```kotlin
plugins {
  id("com.google.cloud.tools.jib") version "3.4.4"
}

jib {
  from { image = "eclipse-temurin:21-jre-jammy" }
  to { image = "hello-boot:jib" }
  container {
    jvmFlags = listOf("-XX:+UseZGC","-XX:InitialRAMPercentage=50","-XX:MaxRAMPercentage=80")
    ports = listOf("8080")
  }
}
```

```bash
./gradlew jibDockerBuild
docker run --rm -p 8080:8080 hello-boot:jib
```

---

## DB 연결(JPA + PostgreSQL)

### 엔티티/리포지토리/컨트롤러 샘플

`src/main/java/com/example/hello/user/User.java`
```java
package com.example.hello.user;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import lombok.*;

@Entity @Getter @Setter
@NoArgsConstructor @AllArgsConstructor @Builder
@Table(name = "users")
public class User {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @NotBlank
  @Column(nullable = false, unique = true)
  private String username;

  private String displayName;
}
```

`src/main/java/com/example/hello/user/UserRepository.java`
```java
package com.example.hello.user;

import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
  Optional<User> findByUsername(String username);
}
```

`src/main/java/com/example/hello/user/UserController.java`
```java
package com.example.hello.user;

import jakarta.validation.Valid;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/users")
public class UserController {
  private final UserRepository repo;
  public UserController(UserRepository repo) { this.repo = repo; }

  @PostMapping
  public User create(@RequestBody @Valid User u) {
    return repo.save(u);
  }

  @GetMapping("/{id}")
  public User get(@PathVariable Long id) {
    return repo.findById(id).orElseThrow();
  }
}
```

### JPA 설정(로컬)

`application.yml`(추가)
```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/appdb
    username: app
    password: app
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate.format_sql: true
      hibernate.jdbc.lob.non_contextual_creation: true
  sql:
    init:
      mode: never
```

> **실행 전 DB 준비**
```bash
docker compose -f infra/docker-compose.yml up -d db
```

---

## 테스트: Testcontainers로 실DB 검증

`src/test/java/com/example/hello/user/UserRepositoryTest.java`
```java
package com.example.hello.user;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;

import static org.assertj.core.api.Assertions.assertThat;

@DataJpaTest
class UserRepositoryTest {

  static PostgreSQLContainer<?> PG = new PostgreSQLContainer<>("postgres:16");

  static {
    PG.start();
  }

  @DynamicPropertySource
  static void props(DynamicPropertyRegistry r) {
    r.add("spring.datasource.url", PG::getJdbcUrl);
    r.add("spring.datasource.username", PG::getUsername);
    r.add("spring.datasource.password", PG::getPassword);
  }

  private final UserRepository repo;

  UserRepositoryTest(UserRepository repo) { this.repo = repo; }

  @Test
  void saveAndFind() {
    User u = User.builder().username("alice").displayName("Alice").build();
    User saved = repo.save(u);
    assertThat(saved.getId()).isNotNull();
    assertThat(repo.findByUsername("alice")).isPresent();
  }
}
```

---

## 로깅 & 관측(Actuator/Micrometer)

- **의존성**
  ```kotlin
  dependencies {
    implementation("org.springframework.boot:spring-boot-starter-actuator")
    runtimeOnly("io.micrometer:micrometer-registry-prometheus")
  }
  ```

- **설정**
  ```yaml
  management:
    endpoints:
      web:
        exposure:
          include: health,info,metrics,prometheus
    metrics:
      tags:
        application: ${spring.application.name}
  ```

- **Prometheus 스크랩**
  - 앱: `/actuator/prometheus`
  - Grafana 대시보드: JVM/HTTP/DB 커넥션 풀 지표 확인

---

## 보안(기초 맛보기)

- **폼 로그인/세션** 대신, 실습에서는 먼저 **개발자 편의용**으로 모든 요청을 허용하고 Actuator 공개 범위 제한:

`build.gradle.kts`
```kotlin
dependencies {
  implementation("org.springframework.boot:spring-boot-starter-security")
}
```

`SecurityConfig.java`
```java
package com.example.hello.config;

import org.springframework.context.annotation.Bean;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@org.springframework.context.annotation.Configuration
public class SecurityConfig {

  @Bean
  SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.csrf(csrf -> csrf.disable());
    http.authorizeHttpRequests(auth -> auth
      .requestMatchers("/actuator/**").permitAll()
      .anyRequest().permitAll()
    );
    http.httpBasic(Customizer.withDefaults());
    return http.build();
  }
}
```

> 추후 단계에서 **JWT/OAuth2/메소드 보안**으로 확장.

---

## 프로파일 전략(dev/test/docker/prod)

- **dev**: H2 or 로컬 Postgres, 상세 로그.
- **test**: Testcontainers, 통합 테스트 재현.
- **docker**: 컨테이너로 엮을 때의 네트워크/헬스 프로브.
- **prod**: 보안/성능/로그 포맷(JSON)/외부화된 비밀.

**예시 구조**
```
application.yml
application-dev.yml
application-test.yml
application-docker.yml
application-prod.yml
```

실행:
```bash
SPRING_PROFILES_ACTIVE=dev ./gradlew bootRun
```

---

## 빌드/배포 파이프라인 초안

- **로컬**: `./gradlew check` → `bootJar` → `docker build` → `docker compose up`
- **CI**(GitHub Actions 예시):
  - JDK 21 세팅 → `./gradlew test` → `./gradlew bootJar`
  - 캐시: Gradle 캐시, Dependencies
  - 보안: Dependabot, OWASP dep check(선택)

`.github/workflows/ci.yml`(요약)
```yaml
name: CI
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with: { distribution: temurin, java-version: '21' }
      - uses: gradle/actions/setup-gradle@v3
      - run: ./gradlew build --no-daemon
```

---

## 성능/메모리/부팅 최적화 첫걸음

- **JVM 플래그**: 컨테이너 메모리 비율 기반(`-XX:InitialRAMPercentage`, `-XX:MaxRAMPercentage`).
- **스레드풀/커넥션풀**: HikariCP 최대 커넥션 제한/타임아웃 조정.
- **Actuator 헬스체크**: `readiness/liveness` Probe on K8s.
- **레벨별 로그**: `org.hibernate.SQL=debug`는 **개발**에서만.

---

## GraalVM Native(옵션)

- **장점**: 부팅 속도/메모리 절감.
- **주의**: 리플렉션/프록시 힌트 필요. 라이브러리 호환성 확인.

Gradle 플러그인 추가:
```kotlin
plugins {
  id("org.graalvm.buildtools.native") version "0.10.3"
}
```

빌드:
```bash
./gradlew nativeCompile
./build/native/nativeCompile/hello-boot
```

---

## 실습 과제 목록(이 절 관련)

1) **Hello API 확장**: `/api/greet`에 `lang` 파라미터를 추가하고, `ko/en/ja`에 따른 메시지 국제화 적용.
2) **검증 강화**: `HelloRequest`에 길이 제한(2~20), 공백만 입력 시 에러 응답 포맷 일정화.
3) **DB 연동**: `User`에 고유 제약조건 위반 시 예외를 잡아 409(CONFLICT)로 매핑.
4) **Actuator**: `/actuator/metrics/http.server.requests`에서 라벨(상태코드/메소드/경로)로 필터해보기.
5) **Docker**: `docker compose` 환경에서 애플리케이션이 DB/Redis 헬스체크 후 시작되는지 확인.
6) **테스트**: Testcontainers로 `UserRepository` CRUD 케이스 추가, 롤백 동작 확인.
7) **빌드 전략 비교**: Dockerfile vs Buildpacks vs Jib 빌드 시간/이미지 크기 비교표 작성.
8) **프로파일**: `dev/docker/prod` 별 로깅 포맷/레벨 차이를 명확히 구분.

---

# 자주 막히는 포인트 & 트러블슈팅

- **포트 충돌(5432/6379/8080)**: 이미 실행 중인지 `lsof -i :5432` 확인 후 종료.
- **`JAVA_HOME` 미설정**: `java -version`과 `echo $JAVA_HOME`이 일치하는지 확인.
- **Gradle 캐시 꼬임**: `./gradlew --stop && ./gradlew clean build -refresh-dependencies`.
- **DB 커넥션 누수**: HikariCP 경고 시, 트랜잭션 누락/블로킹 확인, 커넥션 최대치/쿼리 시간 점검.
- **Actuator 노출 과다**: 운영에서는 `/actuator/**`를 내부망/인증 뒤로 제한.
- **도커 메모리 부족**: Docker Desktop → Resources에서 메모리 상향, JVM 비율 플래그 조정.
- **리눅스 권한**: 볼륨 디렉토리 권한 문제 시 `chown -R 999:999`(postgres UID) 등 적용.

---

# 체크리스트 (이 절 완료 기준)

- [ ] JDK 21 설치 및 `JAVA_HOME` 표준화
- [ ] Gradle/Maven 중 팀 표준 선택 & Wrapper 커밋
- [ ] IDE 통일: 인스펙션/포맷 규칙 공유(Spotless/Checkstyle)
- [ ] Docker Desktop/Compose 설치 및 로컬 통합 실습 성공
- [ ] Hello-boot API 실행/검증/예외/Actuator 동작 확인
- [ ] Postgres/Redis 연동(컨테이너) 정상
- [ ] Testcontainers로 통합 테스트 1개 이상 통과
- [ ] 이미지 빌드 전략 1개 이상 성공(Dockerfile/Pack/Jib)
- [ ] 프로파일별(application-*.yml) 설정 분리
- [ ] 기본 로그/메트릭/헬스체크 확인
