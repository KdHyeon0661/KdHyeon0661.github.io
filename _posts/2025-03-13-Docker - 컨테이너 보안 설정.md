---
layout: post
title: Docker - 컨테이너 보안 설정
date: 2025-03-13 19:20:23 +0900
category: Docker
---
# 컨테이너 보안 설정

## 설계 철학과 위협 모델

- **경계 1: 이미지** — 악성/취약 패키지 → *사전 스캔·서명 검증·경량 베이스*
- **경계 2: 런타임** — 과도한 권한·호스트 노출 → *루트 제거, 읽기 전용, capabilities/시스템콜 차단*
- **경계 3: 운영** — 로그/백업/CI 비밀 유출 → *시크릿, 마스킹, 정책 게이트, 감사*

보안 강도를 간단히 수리적으로 표현하면, 공격 난이도 \(R\)를 낮추는 요소를 **반대로** 키우는 최적화 문제다:

$$
\text{Minimize risk} \;\Rightarrow\; \text{Maximize}\;\big( C_{\text{격리}} + C_{\text{가시화}} + C_{\text{무결성}} \big)
$$

여기서 \(C_{\text{격리}}\)는 네임스페이스/권한 격리, \(C_{\text{가시화}}\)는 감사·경보, \(C_{\text{무결성}}\)은 이미지 서명·불변성이다.

---

## 루트 권한 제거(비루트 실행)

### Dockerfile에서 사용자 전환

```dockerfile
FROM python:3.11-slim

# 전용 사용자·그룹 생성(고정 UID/GID로 재현 가능성↑)

RUN groupadd -g 10001 app && useradd -m -u 10001 -g 10001 app

WORKDIR /app
COPY . .
# 소유권·권한 최소화

RUN chown -R app:app /app && chmod -R u=rwX,go=rX /app

# 비루트 사용자 전환

USER 10001:10001

CMD ["python", "app.py"]
```

- **포인트**: UID/GID를 고정값으로 두면 NFS/호스트 볼륨과의 권한 불일치가 줄어든다.
- **실행 중 포트 80 바인딩 문제**는 §4.3에서 해결한다.

### `docker run --user`로 강제

```bash
docker run --user 10001:10001 myorg/myapp:1.0
```

- Dockerfile을 바꾸지 못하는 서드파티 이미지에 유용.

### Rootless Docker(선택) — 데몬 자체를 비루트로

```bash
# 설치 스크립트(예: Ubuntu)

curl -fsSL https://get.docker.com/rootless | sh
# 환경 변수 적용

export PATH=$HOME/bin:$PATH
export DOCKER_HOST=unix:///run/user/$(id -u)/docker.sock
```
- 호스트 차원에서 루트 데몬 의존도를 줄인다(개발자 워크스테이션, CI 워커에 특히 효과적).

---

## 읽기 전용 파일 시스템(Immutable FS)

### 단일 컨테이너

```bash
docker run \
  --read-only \
  --tmpfs /tmp \
  -v appdata:/app/data \
  myorg/myapp:1.0
```

- `--read-only`: 루트 파일시스템을 **RO**로 마운트.
- 앱이 쓰기를 요구하는 경로는 **명시적**으로 `tmpfs`(비영구)나 Volume으로 분리.

### Compose

```yaml
services:
  api:
    image: myorg/api:1.0
    read_only: true
    tmpfs:
      - /tmp
    volumes:
      - appdata:/app/data:rw
```

- “쓰는 곳만 쓴다”는 설계는 **변조·랜섬웨어 동작**을 크게 제약한다.

---

## Linux Capabilities 최소화

### 기본 패턴

```bash
docker run \
  --cap-drop ALL \
  --cap-add NET_BIND_SERVICE \  # 필요 시 낮은 포트 바인딩
  myorg/web:1.0
```

- **드롭이 기본**이고, **예외적으로 add** 한다.
- 참고(자주 오해되는 권한):
  - `CAP_NET_RAW`: ping/패킷 조작 — 일반 웹 앱에는 **불필요**(되도록 피함).
  - `SYS_ADMIN`: “만능”에 가까움 — **절대 금지**.

### Compose

```yaml
services:
  web:
    image: myorg/web:1.0
    cap_drop: ["ALL"]
    cap_add: ["NET_BIND_SERVICE"]
```

---

## 낮은 포트(80/443) 바인딩, 루트 없이 하는 법

### `setcap`으로 바이너리만 권한 부여

```dockerfile
FROM caddy:2.8.4-builder AS builder
# ... (빌드)

FROM caddy:2.8.4
# 이하 포트 바인딩 권한 부여

RUN setcap cap_net_bind_service=+ep /usr/bin/caddy
USER 10001:10001
CMD ["caddy", "run", "--config", "/etc/caddy/Caddyfile"]
```

### 리버스 프록시로 우회

- 호스트(또는 사이드카) Nginx가 80/443을 받고 컨테이너는 8080/8443 등 **고포트** 사용.
- 권한 부여가 어려운 언어/런타임에서 안정적.

---

## Seccomp(시스템콜) 정책

### 기본 적용

```bash
docker run --security-opt seccomp=default.json myorg/api:1.0
```
- Docker 기본 프로파일은 위험 syscall을 다수 차단.

### 사용자 정의(최소 예)

```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "archMap": [{ "architecture": "SCMP_ARCH_X86_64", "subArchitectures": [] }],
  "syscalls": [
    { "names": ["read", "write", "exit", "futex", "clock_gettime"], "action": "SCMP_ACT_ALLOW" }
  ]
}
```
- 테스트 → 실패 syscall 로그 확인(Falco/strace) → **허용 목록** 보강.
- “허용 기반(allowlist)”이 원칙.

---

## LSM(AppArmor/SELinux) 적용

### AppArmor(Ubuntu 등)

```bash
docker run --security-opt apparmor=docker-default myorg/api:1.0
```

**커스텀 프로파일**(간단 예시, `/etc/apparmor.d/my-nginx`):
```
#include <tunables/global>

profile my-nginx flags=(attach_disconnected) {
  #include <abstractions/base>
  /usr/sbin/nginx mr,
  /etc/nginx/** r,
  /var/log/nginx/** rw,
  deny /bin/** w,
  deny network raw,
}
```
적용:
```bash
apparmor_parser -r /etc/apparmor.d/my-nginx
docker run --security-opt apparmor=my-nginx nginx:alpine
```

### SELinux(RHEL/Alma 등) — 볼륨 레이블

```bash
# :Z(독점), :z(공유) 레이블 옵션

docker run -v /srv/web:/usr/share/nginx/html:Z nginx:alpine
```
- 잘못된 레이블은 “Permission denied”를 유발 — 라벨링을 명시적으로 관리.

---

## 호스트 경로 마운트 최소화

- **금지**: `/`, `/proc`, `/sys`, `/var/run/docker.sock`, `/dev` 직접 마운트.
- 꼭 필요하면 **읽기 전용**:
```bash
docker run -v /etc/ssl/certs:/etc/ssl/certs:ro myorg/api:1.0
```
- 도커 소켓이 필요하다면, **Rootless Docker** 또는 **socket-proxy**(권한 축소 프록시) 검토.

---

## 네트워크·IPC·PID 격리

- 네트워크: `--network none`(배치/크론성 컨테이너) 또는 사용자 정의 브리지로 최소 노출.
- PID/IPC 공유 금지: `--pid host`, `--ipc host`는 **회피**.
- Compose:
```yaml
services:
  job:
    image: myorg/batch:1.0
    network_mode: "none"
```

---

## 리소스 제한(cgroups)·ulimit

- CPU/메모리 제한은 **DoS·OOM 전파**를 차단한다.
```bash
docker run --memory 256m --cpus 0.5 --pids-limit 200 myorg/api:1.0
```

Compose:
```yaml
services:
  api:
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 256M
    ulimits:
      nofile: 8192
      nproc: 512
```

---

## `no-new-privileges` 플래그

- SUID/파일 권한 상승을 막는다.
```bash
docker run --security-opt no-new-privileges:true myorg/api:1.0
```

Compose:
```yaml
services:
  api:
    security_opt:
      - no-new-privileges:true
```

---

## 데몬 레벨 하드닝

### User namespace remap

`/etc/docker/daemon.json`:
```json
{
  "userns-remap": "default",
  "icc": false,
  "no-new-privileges": true,
  "live-restore": true
}
```
- **userns-remap**: 컨테이너 root를 호스트 비루트로 매핑.
- `icc:false`: 컨테이너 간 통신 차단(필요 네트워크만 허용).

재시작:
```bash
sudo systemctl reload docker
```

---

## 이미지 단계 보안(공급망)

### 경량 베이스 + 멀티스테이지 + 불변

```dockerfile
# syntax=docker/dockerfile:1.7

FROM golang:1.22-alpine AS builder
WORKDIR /src
COPY . .
RUN CGO_ENABLED=0 go build -o app ./cmd

FROM gcr.io/distroless/static
USER 10001:10001
COPY --from=builder /src/app /app
ENTRYPOINT ["/app"]
```
- 쉘 없음, 패키지 관리자 없음 → **공격 표면 최소화**.

### SBOM·서명

- SBOM: `docker scout sbom myorg/api:1.0` 또는 `trivy sbom`.
- 서명/검증(cosign):
```bash
cosign sign myorg/api:1.0
cosign verify myorg/api:1.0
```
- **정책 게이트**: 미서명 이미지 **차단**.

---

## 런타임 감시·탐지

- **Falco**: 시스템콜 기반 정책(예: 쉘 스폰 감지).
- eBPF 기반 에이전트(Cloud/온프렘): 비정상 네트워크/파일 활동 탐지.
- 중앙 로그(OTEL/ELK) + **비밀 마스킹**(로그 파이프라인에서 키워드 마스킹).

Falco 예(의심스런 쉘 스폰):
```yaml
- rule: Terminal shell in container
  desc: Detect a shell running in a container
  condition: container.id != host and shell_procs and proc.tty != 0
  output: "Shell spawned in container (user=%user.name command=%proc.cmdline container=%container.id)"
  priority: WARNING
```

---

## Compose 보안 템플릿(총집편)

```yaml
version: "3.9"

services:
  web:
    image: myorg/web:1.0
    user: "10001:10001"
    read_only: true
    tmpfs: ["/tmp"]
    cap_drop: ["ALL"]
    cap_add: ["NET_BIND_SERVICE"]
    security_opt:
      - no-new-privileges:true
      - seccomp=default.json
      - apparmor=docker-default
    ports:
      - "443:8443"   # 컨테이너는 8443 등 고포트 사용 권장
    networks: ["dmz"]
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 256M
      restart_policy:
        condition: on-failure

  api:
    image: myorg/api:1.0
    user: "10001:10001"
    read_only: true
    tmpfs: ["/tmp"]
    cap_drop: ["ALL"]
    security_opt:
      - no-new-privileges:true
      - seccomp=default.json
    environment:
      DB_HOST: "db"
      DB_PASSWORD_FILE: "/run/secrets/db_password"
    secrets: ["db_password"]
    depends_on: ["db"]
    networks: ["backend"]

  db:
    image: postgres:15
    read_only: true         # 엔트리포인트 특성상 일부 디렉터리 RW 필요 → 볼륨으로 분리
    tmpfs: ["/tmp"]
    volumes:
      - dbdata:/var/lib/postgresql/data:rw
    environment:
      POSTGRES_DB: appdb
      POSTGRES_USER: app
    secrets: ["db_password"]
    command: >
      bash -lc 'export PGPASSWORD="$(cat /run/secrets/db_password)" &&
                docker-entrypoint.sh postgres'
    networks: ["backend"]

secrets:
  db_password:
    file: ./secrets/db_password.txt

volumes:
  dbdata:

networks:
  dmz: {}
  backend: {}
```

---

## CI/CD 파이프라인에 보안 끼워넣기

1. **Dockerfile 린트**: Dockle/Trivy config → `fail-on=high`.
2. **취약점 스캔**: Trivy/Docker Scout — CRITICAL/HIGH 발견 시 **빌드 실패**.
3. **SBOM 생성·보관**: 아티팩트/레지스트리 첨부.
4. **이미지 서명**: cosign sign → verify **게이트**.
5. **정책 엔진**: OPA/Gatekeeper로 `privileged=false`, `cap_drop=ALL` 미준수 시 **거부**.

GitHub Actions 예(요지):
{% raw %}
```yaml
- name: Scan image with Trivy
  uses: aquasecurity/trivy-action@v0.18.0
  with:
    image-ref: myorg/api:latest
    severity: CRITICAL,HIGH
    ignore-unfixed: true
    exit-code: '1'

- name: Generate SBOM
  run: docker scout sbom --format cyclonedx-json -o sbom.json myorg/api:latest

- name: Cosign sign
  run: cosign sign --key ${{ secrets.COSIGN_KEY }} myorg/api:latest
```
{% endraw %}

---

## 실전 디버깅·운영 FAQ

| 증상 | 원인 | 해결 |
|---|---|---|
| `Permission denied` (파일 쓰기) | `--read-only`인데 쓰기 경로 미정의 | `tmpfs`나 볼륨로 쓰기 경로 분리 |
| 80/443 바인딩 실패(비루트) | CAP 없음 | `setcap cap_net_bind_service=+ep` 또는 고포트 사용 |
| 헬스체크 실패 | seccomp/AppArmor가 필요한 syscall/경로 제한 | 정책 로그 확인 → 허용 목록 보강 |
| 이미지에 쉘/패키지 없어 운영 불편 | distroless 사용 | 디버그용 별도 태그(쉘 포함) 준비, 런타임은 최소 이미지 사용 |
| 취약점 계속 발견 | 오래된 베이스 | 베이스 이미지를 최신 LTS로 자주 재빌드, SBOM·서명 프로세스 준수 |

---

## 최소 보안 프로파일 “카탈로그”

- **러프한 기본**:
  - 비루트 `USER`
  - `read_only: true` + `tmpfs`
  - `cap_drop: ["ALL"]` (+ 필요한 것만 `cap_add`)
  - `security_opt: [no-new-privileges:true, seccomp=default.json, apparmor=docker-default]`
  - 리소스 제한(CPU·메모리·PIDs)
  - 네트워크 최소화(`network_mode: none` 가능한 워크로드엔 적극)
  - 호스트 마운트 금지, 소켓 접근 금지
  - 시크릿은 **파일 경로**로 접근, 환경변수 금지

- **강화판**(배치/비네트워크):
  - `--network none`, `--cap-drop ALL`(추가 `cap_add` 없음), 초경량 distroless 런타임, 프로세스 1개, 루트 FS RO

---

## 정리

- **권한 최소·불변성·가시화**가 3대 원칙.
- **이미지 단계**에서는 경량·서명·SBOM, **런타임 단계**에서는 루트 제거·RO FS·cap/seccomp/AppArmor/SELinux, **운영 단계**에서는 스캔·정책 게이트·감사/경보가 삼위일체로 움직여야 한다.
- “되는 대로 띄우고 문제 생기면 막는다”의 역전 — **처음부터 안전 기본값**으로 출발하라.

---

## 부록 A. 명령 모음

```bash
# 비루트·읽기 전용·권한 최소·리소스 제한 템플릿

docker run \
  --user 10001:10001 \
  --read-only \
  --tmpfs /tmp \
  --cap-drop ALL \
  --security-opt no-new-privileges:true \
  --security-opt seccomp=default.json \
  --security-opt apparmor=docker-default \
  --memory 256m --cpus 0.5 --pids-limit 200 \
  myorg/api:1.0
```

---

## 부록 B. 간단 위험 점수 예(우선순위 산정)

보안 태스크 우선순위를 정할 때, 다음과 같이 가중치 합으로 위험 점수를 근사해볼 수 있다.

$$
\text{Risk} =
3\cdot \mathbb{1}\{\text{root 실행}\} +
3\cdot \mathbb{1}\{\text{RW 루트 FS}\} +
2\cdot \mathbb{1}\{\text{capabilities 과다}\} +
2\cdot \mathbb{1}\{\text{seccomp 미적용}\} +
1\cdot \mathbb{1}\{\text{리소스 제한 부재}\}
$$

점수가 높을수록 **즉시 보완** 대상이다.

---

## 참고(권장 읽을거리)

- Docker Engine Security / Seccomp Profiles
- AppArmor / SELinux 정책 개요
- OWASP Docker Security Cheat Sheet
- Distroless / SBOM / cosign 서명
- Falco 룰 템플릿

> 적용 전, 스테이징에서 정책(특히 seccomp/AppArmor/SELinux)을 충분히 검증하고 단계적으로 “차단 모드”를 강화하라.
