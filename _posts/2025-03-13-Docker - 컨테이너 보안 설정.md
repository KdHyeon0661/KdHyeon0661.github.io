---
layout: post
title: Docker - 컨테이너 보안 설정
date: 2025-03-13 19:20:23 +0900
category: Docker
---
# 컨테이너 보안 설정

## 설계 철학과 위협 모델

컨테이너 보안은 **"공격 표면을 최소화하고, 공격자가 침투했을 때 피해를 국한시키는"** 철학에 기반합니다. 위협 모델은 크게 세 가지 경계로 나눠 접근합니다.

*   **경계 1: 이미지**
    *   위협: 악성 또는 취약한 패키지가 포함된 이미지 배포
    *   방어: 사전 취약점 스캔, 이미지 서명 검증, 경량 베이스 이미지 사용
*   **경계 2: 런타임**
    *   위협: 컨테이너의 과도한 권한으로 인한 호스트 시스템 침해
    *   방어: 루트 권한 제거, 읽기 전용 파일 시스템, Linux Capabilities 및 시스템 호출 제한
*   **경계 3: 운영**
    *   위협: 로그, 백업, CI/CD 파이프라인에서의 비밀 정보 유출
    *   방어: 시크릿 관리, 민감 정보 마스킹, 정책 기반 배포 게이트웨이, 지속적인 감사

이러한 방어 체계를 수리적으로 표현하면, 보안 강화는 공격자의 성공 난이도(R)를 높이는 요소들을 극대화하는 최적화 문제로 볼 수 있습니다.

$$
\text{Minimize Risk} \;\Rightarrow\; \text{Maximize}\;\big( C_{\text{격리}} + C_{\text{가시화}} + C_{\text{무결성}} \big)
$$

여기서 \(C_{\text{격리}}\)는 네임스페이스와 권한 격리 강도, \(C_{\text{가시화}}\)는 모니터링·감사·경보 체계, \(C_{\text{무결성}}\)은 이미지 서명과 불변성 보장을 의미합니다.

---

## 핵심 보안 실천 방법

### 1. 루트 권한 제거 (비루트 실행)
컨테이너 내부에서 루트로 프로세스를 실행하는 것은 가장 큰 위험 요소 중 하나입니다.

**Dockerfile에서 사용자 전환**
```dockerfile
FROM python:3.11-slim

RUN groupadd -g 10001 app && useradd -m -u 10001 -g 10001 app
WORKDIR /app
COPY --chown=app:app . .
USER app:app  # 또는 USER 10001:10001 (고정 UID/GID 권장)

CMD ["python", "app.py"]
```
*   **장점**: 고정된 UID/GID를 사용하면 NFS 또는 호스트 볼륨과의 권한 불일치 문제를 줄일 수 있습니다.
*   **주의점**: 포트 80, 443과 같은 낮은 번호의 포트 바인딩은 기본적으로 루트 권한이 필요합니다.

**실행 시 강제 적용**
```bash
docker run --user 10001:10001 myorg/myapp:1.0
```
*   **용도**: 직접 수정할 수 없는 서드파티 이미지를 실행할 때 유용합니다.

**루트리스 도커(Rootless Docker)**
*   도커 데몬 자체를 호스트의 일반 사용자 권한으로 실행하는 방식입니다. 호스트 침해 리스크를 근본적으로 낮추므로, 개발자 워크스테이션이나 CI 환경에 특히 적합합니다.

### 2. 읽기 전용 파일 시스템 (Immutable FS)
컨테이너의 루트 파일 시스템을 읽기 전용으로 설정하면, 악성 코드의 변조나 랜섬웨어 활동을 효과적으로 차단할 수 있습니다.

```bash
docker run \
  --read-only \          # 루트 파일시스템을 읽기 전용으로 마운트
  --tmpfs /tmp \         # 쓰기가 필요한 임시 경로는 메모리 파일시스템으로 분리
  -v appdata:/app/data \ # 지속적 데이터는 명시적 볼륨으로 분리
  myorg/myapp:1.0
```

### 3. Linux Capabilities 최소화
리눅스 커널의 세분화된 권한 단위인 Capabilities를 최소한으로 부여합니다. '모든 권한을 드롭한 후, 필요한 것만 추가'하는 원칙을 따릅니다.

```bash
docker run \
  --cap-drop ALL \                   # 모든 권한 제거
  --cap-add NET_BIND_SERVICE \      # 예외: 낮은 번호 포트 바인딩 권한만 추가
  myorg/web:1.0
```
*   `CAP_NET_RAW`(raw 패킷 조작)나 `CAP_SYS_ADMIN`(관리자 권한)과 같은 위험한 권한은 일반 애플리케이션에서 거의 필요하지 않습니다.

### 4. 시스템 호출(seccomp) 및 MAC(AppArmor/SELinux) 프로파일 적용
컨테이너가 호출할 수 있는 시스템 호출을 제한하고, 강제 접근 제어를 통해 프로세스 동작을 세밀하게 통제합니다.

**시스템 호출 필터링 (seccomp)**
```bash
# Docker의 기본 seccomp 프로파일 사용 (권장 시작점)
docker run --security-opt seccomp=default.json myorg/api:1.0

# 사용자 정의 허용 목록(allowlist) 프로파일 (최대 보안)
docker run --security-opt seccomp=/path/to/custom-profile.json myorg/api:1.0
```

**강제 접근 제어 (AppArmor 예시)**
```bash
# 기본 프로파일 적용
docker run --security-opt apparmor=docker-default myorg/api:1.0

# 사용자 정의 프로파일 적용
docker run --security-opt apparmor=my-restrictive-profile nginx:alpine
```

### 5. 호스트 리소스 격리 강화
*   **네트워크 격리**: `--network none` (네트워크가 필요 없는 배치 작업), 사용자 정의 브리지 네트워크를 활용합니다.
*   **호스트 경로 마운트 최소화**: `/`, `/proc`, `/sys`, `/var/run/docker.sock` 등을 마운트하는 것은 위험합니다. 필수적인 경우 읽기 전용(`:ro`)으로 제한합니다.
*   **리소스 제한**: CPU, 메모리, 프로세스 수(`--pids-limit`)를 제한하여 DoS(서비스 거부) 공격이나 리소스 고갈로 인한 호스트 영향도를 줄입니다.

### 6. 권한 상승 방지
`no-new-privileges` 플래그를 사용하여 컨테이너 내부에서 SUID/SGID 바이너리를 통해 권한을 상승시키는 경로를 차단합니다.

```bash
docker run --security-opt no-new-privileges:true myorg/api:1.0
```

---

## 공급망 보안: 이미지 수준의 방어

런타임 보안만큼 이미지 빌드 단계의 보안도 중요합니다.

**경량 및 최소화된 베이스 이미지**
*   `alpine`, `distroless` 이미지를 사용하여 불필요한 패키지, 셸, 심지어 libc를 제거함으로써 공격 표면을 극적으로 줄입니다.
*   멀티 스테이지 빌드를 활용하여 최종 이미지에는 애플리케이션과 필수 런타임만 포함시킵니다.

**취약점 스캔 및 SBOM(Software Bill of Materials)**
*   Trivy, Docker Scout 등을 사용하여 빌드 파이프라인에서 취약점을 조기에 발견하고 차단합니다.
*   SBOM을 생성하여 사용된 모든 컴포넌트를 투명하게 관리하고, 새로운 취약점이 발견되었을 때 빠르게 영향 분석을 할 수 있게 합니다.

**이미지 무결성 보장**
*   Cosign과 같은 도구로 이미지에 디지털 서명을 합니다.
*   배포 시(Kubernetes Admission Controller 등) 서명을 검증하여 변조되었거나 승인되지 않은 이미지의 실행을 차단합니다.

---

## 운영 및 모니터링

**중앙화된 로깅과 모니터링**
*   모든 컨테이너와 호스트의 로그, 메트릭, 감사 로그를 중앙 시스템(ELK, OpenTelemetry)으로 수집합니다.
*   로그 파이프라인에서 비밀번호, API 키와 같은 민감 정보는 자동으로 마스킹 처리합니다.

**런타임 위협 탐지**
*   Falco 같은 런타임 보안 도구를 배포하여 정상적인 동작 패턴을 학습하고, 비정상적인 시스템 호출, 파일 접근, 네트워크 활동을 실시간으로 탐지하고 경고합니다.

**정책 기반 통제**
*   OPA(Open Policy Agent), Kyverno, Gatekeeper와 같은 정책 엔진을 사용하여 "모든 컨테이너는 비루트로 실행되어야 한다", `privileged: true`는 금지된다"와 같은 조직의 보안 정책을 코드로 정의하고 자동으로 시행합니다.

---

## 실전 적용: Docker Compose 보안 템플릿

다음은 주요 보안 설정이 적용된 Docker Compose 파일의 예시입니다.

```yaml
version: "3.9"

services:
  web:
    image: myorg/web:1.0
    user: "10001:10001"
    read_only: true
    tmpfs: ["/tmp"]
    cap_drop: ["ALL"]
    cap_add: ["NET_BIND_SERVICE"] # 낮은 포트 바인딩이 필요한 경우
    security_opt:
      - no-new-privileges:true
    # seccomp: default.json (기본 적용)
    networks: ["dmz"]
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: "256M"

  api:
    image: myorg/api:1.0
    user: "10001:10001"
    read_only: true
    tmpfs: ["/tmp"]
    cap_drop: ["ALL"]
    security_opt:
      - no-new-privileges:true
    environment:
      DB_PASSWORD_FILE: "/run/secrets/db_password" # 환경변수 대신 파일 사용
    secrets: ["db_password"]
    networks: ["backend"]

secrets:
  db_password:
    file: ./secrets/db_password.txt

networks:
  dmz:
    driver: bridge
  backend:
    driver: bridge
```

---

## 결론

컨테이너 보안은 한 번의 설정으로 끝나는 것이 아닌, **지속적인 프로세스**입니다. 그러나 명확한 원칙 아래 체계적으로 접근하면 위험을 현저히 낮출 수 있습니다.

1.  **최소 권한의 원칙**을 준수하라: 애플리케이션이 정상 동작에 필요한 최소한의 권한(사용자, Capabilities, 파일 시스템 접근)만을 부여하세요.
2.  **불변성의 원칙**을 설계에 녹여라: 컨테이너는 변경 불가능한 인프라로 취급하고, 읽기 전용 파일 시스템을 기본값으로 삼으세요.
3.  **공급망의 무결성**을 검증하라: 외부에서 가져오는 모든 이미지와 라이브러리를 스캔하고, 자신이 생산하는 아티팩트에는 서명을 하세요.
4.  **가시성을 확보하라** 로그, 모니터링, 런타임 탐지를 통해 환경 내에서 일어나는 일을 항상 파악할 수 있어야 합니다.
5.  **정책을 코드화하고 자동화하라**: 보안 요구사항을 CI/CD 파이프라인과 배포 시스템에 통합하여 인간의 실수나 누락을 방지하세요.

보안은 편의성과의 절충점을 찾는 과정이지만, '일단 실행되고 나중에 고치자'는 접근 방식은 컨테이너 환경에서 큰 위험을 초래합니다. **처음부터 안전한 기본값으로 출발하고, 필요한 경우에만 제어된 방식으로 권한을 완화하는 것이 현명한 전략입니다.**