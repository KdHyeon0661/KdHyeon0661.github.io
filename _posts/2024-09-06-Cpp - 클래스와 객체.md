---
layout: post
title: C++ - 클래스와 객체
date: 2024-09-06 19:20:23 +0900
category: Cpp
---
# 클래스와 객체 — 객체지향 프로그래밍의 시작

## 클래스란?

- **사용자 정의 타입**: 데이터(멤버 변수) + 동작(멤버 함수)을 하나로 묶은 추상화 단위.
- **객체(Object)**: 클래스를 통해 생성된 **실체 인스턴스**.

```cpp
class 클래스이름 {
  접근지정자:
    // 멤버 변수
    // 멤버 함수
};
```

> **기본 접근 지정자**는 `class`는 `private`, `struct`는 `public`.

---

## 첫 예제 — 클래스와 객체

```cpp
#include <iostream>
#include <string>

using namespace std;

class Person {
public:
    string name;
    int    age{};

    void introduce() const {
        cout << "안녕하세요, 저는 " << name << "이고, 나이는 " << age
             << "살입니다.\n";
    }
};

int main() {
    Person p1;           // 스택에 객체 생성 (기본 생성자)
    p1.name = "홍길동";
    p1.age  = 30;
    p1.introduce();
}
```

- **스택 객체**는 **스코프 종료 시 자동 소멸**(소멸자 자동 호출).

---

## 객체 생성 — 스택 vs 힙 vs 스마트 포인터

### 스택(Stack)에 생성

```cpp
MyClass a;       // 기본 생성자
MyClass b(10);   // 매개변수 생성자
```

- 자동 수명 관리, 예외에도 안전.

### 힙(Heap)에 생성(교육용)

```cpp
MyClass* p1 = new MyClass;
MyClass* p2 = new MyClass(10);
delete p1;      // 반드시 해제
delete p2;
```

- **실전에서는 `new/delete` 직접 사용을 지양**하고 **스마트 포인터** 사용.

### 스마트 포인터 권장

```cpp
#include <memory>

auto up = std::make_unique<MyClass>(42);  // 단일 소유
auto sp = std::make_shared<MyClass>(7);   // 공유 소유
```

- **소유권 표현**이 명확하고 **예외 안전**.

---

## 접근 지정자 (Access Specifier)

| 지정자       | 의미                                             |
|--------------|--------------------------------------------------|
| `public`     | 어디서나 접근 가능 (인터페이스)                  |
| `private`    | 클래스 내부에서만 접근 (캡슐화)                  |
| `protected`  | 파생 클래스에서 접근 가능 (상속 확장 지점)       |

> **권장**: 공개 API는 `public`, 내부 상태는 `private`, 확장 지점은 신중히 `protected`.

---

## 생성자(Constructors)와 소멸자(Destructor)

### 생성자 종류

| 종류              | 설명                                                |
|-------------------|-----------------------------------------------------|
| 기본 생성자       | 매개변수 없음                                       |
| 매개변수 생성자   | 인자로 초기화                                       |
| 복사 생성자       | 같은 타입의 객체로부터 복사                         |
| 이동 생성자       | 자원 소유권 이전(C++11~)                            |
| 위임 생성자       | 다른 생성자를 호출하여 초기화(C++11~)               |
| 상속된 생성자     | `using Base::Base;` 로 베이스 생성자 상속(C++11~)  |
| `explicit` 생성자 | 암시적 변환을 막는 생성자                           |

### 이니셜라이저 리스트(권장)

```cpp
class Point {
    int x, y;
public:
    Point()            : x(0), y(0) {}
    Point(int a, int b): x(a), y(b) {}   // 직접 초기화(권장)
};
```

- **const 멤버/참조 멤버**는 이니셜라이저 리스트가 **필수**.
- 멤버 초기화 **순서는 선언 순서**(리스트 순서 아님).

### 복사/이동 생성자

```cpp
class Buffer {
    size_t n{};
    int*   data{};
public:
    Buffer(size_t n) : n(n), data(new int[n]{}) {}
    ~Buffer() { delete[] data; }

    // 복사
    Buffer(const Buffer& other) : n(other.n), data(new int[n]) {
        std::copy(other.data, other.data + n, data);
    }
    Buffer& operator=(const Buffer& other) {
        if (this != &other) {
            Buffer tmp(other);          // copy-and-swap 관용구
            swap(tmp);
        }
        return *this;
    }

    // 이동
    Buffer(Buffer&& other) noexcept : n(other.n), data(other.data) {
        other.n = 0; other.data = nullptr;
    }
    Buffer& operator=(Buffer&& other) noexcept {
        if (this != &other) {
            delete[] data;
            n = other.n; data = other.data;
            other.n = 0; other.data = nullptr;
        }
        return *this;
    }

    void swap(Buffer& o) noexcept { std::swap(n,o.n); std::swap(data,o.data); }
};
```

> **규칙**: 자원을 직접 소유하면 **Rule of Five**, 자원을 멤버(컨테이너/스마트 포인터)에게 맡기면 **Rule of Zero**가 이상적.

### 위임 생성자

```cpp
class Point {
    int x, y;
public:
    Point(int a, int b) : x(a), y(b) {}
    Point(int v) : Point(v, v) {}   // 위임
};
```

### 소멸자

```cpp
~Person() { /* 자원 반납, 로그 등 */ }
```

- **폴리모픽 베이스 클래스**는 반드시 **가상 소멸자**.

---

## 캡슐화와 불변식(Invariants)

```cpp
class Account {
private:
    long long balance_{0};

public:
    void deposit(long long amount) {
        if (amount <= 0) return;
        balance_ += amount;
    }
    bool withdraw(long long amount) {
        if (amount <= 0 || amount > balance_) return false;
        balance_ -= amount;
        return true;
    }
    long long balance() const noexcept { return balance_; }
};
```

- **불변식**: $$\text{balance} \ge 0$$ 항상 유지.
- 인터페이스로만 상태를 조작 → **일관성 확보**.

> 게터/세터는 “막연히 노출”이 아니라 **도메인 의미를 반영**하도록 메서드를 설계.

---

## `this` 포인터와 멤버 함수 한정자

### `this` 포인터

```cpp
class Counter {
    int n{};
public:
    Counter& inc(){ ++n; return *this; }       // fluent
    int value() const { return n; }            // 읽기 전용
};
```

- `const` 멤버 함수에서는 `this`가 `const Counter*`.

### 함수 한정자

- `const` : 내부 상태 변경 금지(논리적 불변)
- `noexcept` : 예외 미발생 약속 → 최적화/안정성
- `[[nodiscard]]` : 반환값 사용 강제(실수 방지)

```cpp
[[nodiscard]] int id() const noexcept { return id_; }
```

---

## 정적 멤버(클래스 수준 데이터/함수)

```cpp
class Config {
public:
    static inline int max_conn = 512; // C++17 inline static
    static void set_max(int n){ max_conn = n; }
};
```

- **객체 없이** `Config::set_max(1024);` 호출 가능.
- 정적 수명 초기화 순서 문제는 **ODR 단일 정의 + inline static**으로 완화.

---

## `explicit` / 변환 생성자 / 변환 연산자

```cpp
class Degree {
    double v_;
public:
    explicit Degree(double d) : v_(d) {}  // 암시 변환 금지
    double value() const { return v_; }
};

class StringViewish {
    const char* p_{};
public:
    StringViewish(const char* p) : p_(p) {} // 암시 변환 허용(의도시)
    operator const char*() const { return p_; } // 변환 연산자
};
```

- **규칙**: 단일 인자 생성자는 기본 `explicit`로 두고, 꼭 필요한 경우에만 암시 변환 허용.

---

## 연산자 오버로딩(의미가 있을 때만)

```cpp
#include <ostream>

class Vec2 {
public:
    double x{}, y{};
    Vec2() = default;
    Vec2(double a, double b): x(a), y(b) {}
    Vec2 operator+(const Vec2& o) const { return {x+o.x, y+o.y}; }
    Vec2& operator+=(const Vec2& o){ x+=o.x; y+=o.y; return *this; }
    friend std::ostream& operator<<(std::ostream& os,const Vec2& v){
        return os << "("<<v.x<<","<<v.y<<")";
    }
};
```

- **의미가 자연스러운 경우에만** 오버로드: +, -, [], (), ==, <=> 등.

---

## 메서드 오버로딩 vs 오버라이딩

### 오버로딩(같은 이름, 다른 매개변수)

```cpp
class Calculator {
public:
    int    add(int a, int b)       { return a+b; }
    double add(double a, double b) { return a+b; }
    int    add(int a, int b, int c){ return a+b+c; }
};
```

> **반환형만 다른** 오버로딩은 불가(서명 모호).

### 오버라이딩(상속 + `virtual` 재정의)

```cpp
struct Animal { virtual void speak(){ std::cout<<"동물\n"; } };
struct Dog    : Animal { void speak() override { std::cout<<"멍멍!\n"; } };
```

- `override`로 서명 불일치를 컴파일 타임에 차단.

---

## 컴포지션(조합)과 불변/가변 설계

```cpp
class Engine {
public:
    void step(){ /*...*/ }
};

class Car {
    Engine engine_;      // 조합
public:
    void run(){ engine_.step(); }
};
```

- **재사용**이 목적이면 상속보다 조합 우선.
- **불변 객체**는 동시성/테스트에 유리. 변경이 필요하면 **새 인스턴스 반환** 패턴 고려.

---

## RAII와 자원 관리(파일/락/소켓)

```cpp
#include <cstdio>

class File {
    std::FILE* f_{};
public:
    explicit File(const char* path, const char* mode){
        f_ = std::fopen(path, mode);
        if (!f_) throw std::runtime_error("open fail");
    }
    ~File(){ if(f_) std::fclose(f_); }

    File(const File&)            = delete;
    File& operator=(const File&) = delete;
    File(File&& o) noexcept : f_(o.f_) { o.f_ = nullptr; }
    File& operator=(File&& o) noexcept {
        if (this != &o) { if(f_) std::fclose(f_); f_ = o.f_; o.f_ = nullptr; }
        return *this;
    }
};
```

- **생성 시 획득, 소멸 시 반환**으로 누수/예외 안전 확보.

---

## 초기화 규칙과 함정

- **멤버 초기화 순서** = **선언 순서**(이니셜라이저 리스트 순서와 무관)
- **정적 초기화 순서** 문제 → `inline static`/함수 지역 정적(`static`)으로 지연 초기화
- **복사 생략 / NRVO**: 값 반환은 대개 복사 없이 최적화

```cpp
class A {
    int x;
    int y;
public:
    A(int x_, int y_) : y(y_), x(x_) {} // 비권장: 선언 순서는 x, y 이므로 경고 유발
};
```

---

## 고급: PImpl(포인터에 의한 구현)로 빌드 의존성 줄이기

```cpp
// widget.hpp
#include <memory>

class Widget {
public:
    Widget();
    ~Widget();
    void draw() const;
private:
    struct Impl;
    std::unique_ptr<Impl> p_;
};

// widget.cpp
#include "widget.hpp"
#include <iostream>

struct Widget::Impl { void draw() const { std::cout<<"draw\n"; } };
Widget::Widget()  : p_(std::make_unique<Impl>()) {}
Widget::~Widget() = default;
void Widget::draw() const { p_->draw(); }
```

- 구현 세부가 헤더에서 숨겨져 **컴파일 시간 단축/ABI 안정성**.

---

## 헤더/소스 분리와 ODR(One Definition Rule)

- **헤더(.hpp/.h)**: 선언(클래스, 인라인/템플릿 정의 포함) + include guard 또는 `#pragma once`
- **소스(.cpp)**: 멤버 함수 정의
- **ODR**: 동일 엔티티는 프로그램 전체에서 **정확히 하나의 정의**만.

```cpp
// Person.hpp
#pragma once
#include <string>

class Person {
public:
    Person(std::string n, int a);
    void introduce() const;
private:
    std::string name_;
    int age_{};
};

// Person.cpp
#include "Person.hpp"
#include <iostream>

Person::Person(std::string n, int a) : name_(std::move(n)), age_(a) {}
void Person::introduce() const {
    std::cout << "안녕하세요, 저는 " << name_ << "이고, 나이는 " << age_ << "살입니다.\n";
}
```

---

## 예제: 요구사항 기반 클래스 설계(불변식 포함)

> 요구: `BankAccount`
> - 시작 잔액 ≥ 0
> - 입금/출금 API, 과도 인출 금지
> - 계좌번호는 읽기 전용
> - 로그성 출력은 외부에서 담당(분리)

```cpp
#include <string>
#include <stdexcept>
#include <utility>

class BankAccount {
    std::string number_;
    long long   balance_{};
public:
    BankAccount(std::string number, long long initial = 0)
      : number_(std::move(number)), balance_(initial)
    {
        if (balance_ < 0) throw std::invalid_argument("negative init");
    }

    const std::string& number()  const noexcept { return number_;  }
    long long          balance() const noexcept { return balance_; }

    void deposit(long long amt){
        if (amt <= 0) throw std::invalid_argument("non-positive");
        balance_ += amt;
    }
    bool withdraw(long long amt) noexcept {
        if (amt <= 0 || amt > balance_) return false;
        balance_ -= amt; return true;
    }
};
```

- **불변식**: $$\text{balance} \ge 0$$, **API로 보장**.
- 출력/로그는 **비즈니스 로직과 분리**.

---

## 수학적 메모: 클래스 불변식

클래스의 불변식을 수식으로 기술하면 검토가 쉬워진다.
$$
\forall t \in \text{lifetime}(\text{Account}) : \text{balance}(t) \in \mathbb{Z}_{\ge 0}
$$
테스트는 **모든 공개 연산 후** 이 조건이 유지되는지를 확인한다.

---

## 테스트/디버깅/툴링

- **경고 최대화**: `-Wall -Wextra -Werror -pedantic`
- **정적 분석**: clang-tidy (modernize-use-override, performance-inefficient-string-concatenation 등)
- **Sanitizer**: ASan/UBSan/TSan
- **단위 테스트**: Catch2 / GoogleTest
- **벤치마크**: google-benchmark

---

## 작은 FAQ

- **Q. 왜 게터/세터 대신 도메인 동작 메서드가 좋은가?**
  A. 상태 일관성과 불변식을 **클래스 내부에서 보장**할 수 있기 때문.

- **Q. 언제 `friend`를 쓰나?**
  A. 단위 테스트/동일 모듈 내 밀접 협력 타입에 한해 최소화. 캡슐화 침식 주의.

- **Q. `struct`와 `class` 차이는?**
  A. 기본 접근자만 다름. 의미적으론 `struct`는 데이터 집합(POCO) 표현에 자주 사용.

- **Q. 멤버 순서가 중요한가?**
  A. 초기화 순서/패킹/정렬에 영향. 특히 **초기화는 선언 순서**를 따른다.

---

## 마무리 요약

- **클래스 = 데이터 + 불변식 + 공개 동작의 계약**.
- **생성·소멸·복사·이동** 시맨틱을 명확히(Zero/Three/Five).
- **캡슐화**로 상태를 보호하고 **API로만 조작**.
- **조합 우선**, 상속은 신중히.
- **RAII**로 자원을 자동 관리.
- **현대 C++ 기능**(스마트 포인터, `explicit`, `noexcept`, `=default`, `=delete`, inline static 등)을 활용해 **안전하고 예측 가능한 타입**을 만들자.

---

# 부록 A) 원 코드 보강 포인트 대응표

| 초안 항목 | 보강 내용 |
|---|---|
| 스택/힙 생성 | 스마트 포인터 권장 패턴 추가 |
| 접근 지정자 | 설계 가이드(인터페이스/캡슐화/확장 지점) |
| 생성자/소멸자 | Rule of Zero/Three/Five, 이니셜라이저 순서, 상속된 생성자 |
| 복사/이동 | copy-and-swap, `noexcept` 이동, 소유권 규약 |
| 캡슐화 | 불변식 설계 및 수학적 명세 |
| 오버로딩/오버라이딩 | `override`, 의미 있는 오버로드 원칙 |
| 기타 | `explicit`, 변환 연산자, 정적 멤버, PImpl, RAII, 툴링 |

---

# 부록 B) 빠른 참고 스니펫

```cpp
// 기본 규약 템플릿
class T {
public:
    T() = default;
    ~T() = default;
    T(const T&)            = default;
    T& operator=(const T&) = default;
    T(T&&)                 = default;
    T& operator=(T&&)      = default;
};

// 금지하고 싶은 연산
class NonCopyable {
public:
    NonCopyable(const NonCopyable&)            = delete;
    NonCopyable& operator=(const NonCopyable&) = delete;
};
```

---

# 부록 C) 컴파일 커맨드

```bash
g++ -std=c++20 -O2 -Wall -Wextra -Werror -pedantic main.cpp -o app
```
