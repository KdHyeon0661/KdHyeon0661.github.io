---
layout: post
title: C++ - 클래스와 객체
date: 2024-09-06 19:20:23 +0900
category: Cpp
---
# 클래스와 객체 — 객체지향 프로그래밍의 시작

## 클래스란?

클래스는 데이터(멤버 변수)와 동작(멤버 함수)을 하나로 묶은 사용자 정의 타입이다. 이를 통해 추상화와 캡슐화를 구현할 수 있으며, 객체(Object)는 클래스를 통해 생성된 실체 인스턴스를 의미한다.

```cpp
class 클래스이름 {
  접근지정자:
    // 멤버 변수
    // 멤버 함수
};
```

기본 접근 지정자는 `class`의 경우 `private`이며, `struct`는 `public`이다.

---

## 첫 예제 — 클래스와 객체

```cpp
#include <iostream>
#include <string>

using namespace std;

class Person {
public:
    string name;
    int    age{};

    void introduce() const {
        cout << "안녕하세요, 저는 " << name << "이고, 나이는 " << age
             << "살입니다.\n";
    }
};

int main() {
    Person p1;           // 스택에 객체 생성 (기본 생성자)
    p1.name = "홍길동";
    p1.age  = 30;
    p1.introduce();
}
```

스택에 생성된 객체는 스코프가 종료되면 자동으로 소멸되며, 이때 소멸자가 자동으로 호출된다.

---

## 객체 생성 — 스택 vs 힙 vs 스마트 포인터

### 스택(Stack)에 생성

```cpp
MyClass a;       // 기본 생성자
MyClass b(10);   // 매개변수 생성자
```

스택 객체는 자동으로 수명이 관리되며, 예외가 발생하더라도 안전하게 소멸된다.

### 힙(Heap)에 생성(교육용)

```cpp
MyClass* p1 = new MyClass;
MyClass* p2 = new MyClass(10);
delete p1;      // 반드시 해제
delete p2;
```

실전에서는 `new`와 `delete`를 직접 사용하는 것을 지양하고, 대신 스마트 포인터를 사용하는 것이 권장된다.

### 스마트 포인터 권장

```cpp
#include <memory>

auto up = std::make_unique<MyClass>(42);  // 단일 소유
auto sp = std::make_shared<MyClass>(7);   // 공유 소유
```

스마트 포인터를 사용하면 소유권 표현이 명확해지고 예외 안전성이 보장된다.

---

## 접근 지정자 (Access Specifier)

| 지정자       | 의미                                             |
|--------------|--------------------------------------------------|
| `public`     | 어디서나 접근 가능 (인터페이스)                  |
| `private`    | 클래스 내부에서만 접근 (캡슐화)                  |
| `protected`  | 파생 클래스에서 접근 가능 (상속 확장 지점)       |

일반적으로 공개 API는 `public`으로, 내부 상태는 `private`으로, 확장 지점은 신중하게 `protected`로 설정하는 것이 권장된다.

---

## 생성자(Constructors)와 소멸자(Destructor)

### 생성자 종류

C++은 다양한 종류의 생성자를 제공한다. 기본 생성자는 매개변수가 없으며, 매개변수 생성자는 인자를 받아 초기화를 수행한다. 복사 생성자는 같은 타입의 객체로부터 복사하며, 이동 생성자는 자원의 소유권을 이전한다(C++11 이상). 위임 생성자는 다른 생성자를 호출하여 초기화를 수행하며(C++11 이상), 상속된 생성자는 `using Base::Base;` 구문으로 베이스 클래스의 생성자를 상속받는다(C++11 이상). `explicit` 생성자는 암시적 변환을 방지한다.

### 이니셜라이저 리스트(권장)

```cpp
class Point {
    int x, y;
public:
    Point()            : x(0), y(0) {}
    Point(int a, int b): x(a), y(b) {}   // 직접 초기화(권장)
};
```

이니셜라이저 리스트를 사용하면 멤버 변수를 직접 초기화할 수 있어 효율적이다. 특히 const 멤버나 참조 멤버의 경우 이니셜라이저 리스트가 필수적이다. 주의할 점은 멤버 초기화 순서가 이니셜라이저 리스트의 순서가 아니라 선언 순서를 따른다는 것이다.

### 복사/이동 생성자

```cpp
class Buffer {
    size_t n{};
    int*   data{};
public:
    Buffer(size_t n) : n(n), data(new int[n]{}) {}
    ~Buffer() { delete[] data; }

    // 복사
    Buffer(const Buffer& other) : n(other.n), data(new int[n]) {
        std::copy(other.data, other.data + n, data);
    }
    Buffer& operator=(const Buffer& other) {
        if (this != &other) {
            Buffer tmp(other);          // copy-and-swap 관용구
            swap(tmp);
        }
        return *this;
    }

    // 이동
    Buffer(Buffer&& other) noexcept : n(other.n), data(other.data) {
        other.n = 0; other.data = nullptr;
    }
    Buffer& operator=(Buffer&& other) noexcept {
        if (this != &other) {
            delete[] data;
            n = other.n; data = other.data;
            other.n = 0; other.data = nullptr;
        }
        return *this;
    }

    void swap(Buffer& o) noexcept { std::swap(n,o.n); std::swap(data,o.data); }
};
```

자원을 직접 소유하는 클래스는 Rule of Five를 따라야 하며, 자원을 컨테이너나 스마트 포인터 같은 멤버에게 맡기는 경우에는 Rule of Zero가 이상적이다.

### 위임 생성자

```cpp
class Point {
    int x, y;
public:
    Point(int a, int b) : x(a), y(b) {}
    Point(int v) : Point(v, v) {}   // 위임
};
```

위임 생성자를 사용하면 초기화 로직의 중복을 제거할 수 있다.

### 소멸자

```cpp
~Person() { /* 자원 반납, 로그 등 */ }
```

소멸자는 객체가 소멸될 때 자동으로 호출되며, 폴리모픽 베이스 클래스의 경우 반드시 가상 소멸자로 선언해야 한다.

---

## 캡슐화와 불변식(Invariants)

```cpp
class Account {
private:
    long long balance_{0};

public:
    void deposit(long long amount) {
        if (amount <= 0) return;
        balance_ += amount;
    }
    bool withdraw(long long amount) {
        if (amount <= 0 || amount > balance_) return false;
        balance_ -= amount;
        return true;
    }
    long long balance() const noexcept { return balance_; }
};
```

이 예제에서 불변식은 잔액이 항상 0 이상이어야 한다는 것이다($\text{balance} \ge 0$). 클래스는 인터페이스를 통해서만 상태를 조작하도록 함으로써 일관성을 확보한다. 게터와 세터는 막연히 노출하는 것이 아니라 도메인의 의미를 반영하도록 메서드를 설계해야 한다.

---

## `this` 포인터와 멤버 함수 한정자

### `this` 포인터

```cpp
class Counter {
    int n{};
public:
    Counter& inc(){ ++n; return *this; }       // fluent 인터페이스
    int value() const { return n; }            // 읽기 전용
};
```

`this`는 현재 객체를 가리키는 포인터이며, const 멤버 함수에서는 `const Counter*` 타입이 된다.

### 함수 한정자

함수 한정자는 멤버 함수의 동작을 제한하거나 명시한다. `const`는 내부 상태 변경을 금지하여 논리적 불변성을 보장하며, `noexcept`는 예외가 발생하지 않음을 약속하여 최적화와 안정성을 높인다. `[[nodiscard]]`는 반환값을 사용하도록 강제하여 실수를 방지한다.

```cpp
[[nodiscard]] int id() const noexcept { return id_; }
```

---

## 정적 멤버(클래스 수준 데이터/함수)

```cpp
class Config {
public:
    static inline int max_conn = 512; // C++17 inline static
    static void set_max(int n){ max_conn = n; }
};
```

정적 멤버는 클래스에 속하지만 특정 객체에 속하지 않는다. 따라서 객체 없이도 `Config::set_max(1024);`와 같이 호출할 수 있다. C++17의 inline static을 사용하면 정적 수명 초기화 순서 문제를 완화할 수 있다.

---

## `explicit` / 변환 생성자 / 변환 연산자

```cpp
class Degree {
    double v_;
public:
    explicit Degree(double d) : v_(d) {}  // 암시 변환 금지
    double value() const { return v_; }
};

class StringViewish {
    const char* p_{};
public:
    StringViewish(const char* p) : p_(p) {} // 암시 변환 허용(의도시)
    operator const char*() const { return p_; } // 변환 연산자
};
```

단일 인자 생성자는 기본적으로 `explicit`로 선언하여 의도하지 않은 암시적 변환을 방지하는 것이 좋다. 꼭 필요한 경우에만 암시 변환을 허용해야 한다.

---

## 연산자 오버로딩(의미가 있을 때만)

```cpp
#include <ostream>

class Vec2 {
public:
    double x{}, y{};
    Vec2() = default;
    Vec2(double a, double b): x(a), y(b) {}
    Vec2 operator+(const Vec2& o) const { return {x+o.x, y+o.y}; }
    Vec2& operator+=(const Vec2& o){ x+=o.x; y+=o.y; return *this; }
    friend std::ostream& operator<<(std::ostream& os,const Vec2& v){
        return os << "("<<v.x<<","<<v.y<<")";
    }
};
```

연산자 오버로딩은 의미가 자연스럽고 직관적인 경우에만 사용해야 한다. 일반적으로 +, -, [], (), ==, <=> 등이 대상이 된다.

---

## 메서드 오버로딩 vs 오버라이딩

### 오버로딩(같은 이름, 다른 매개변수)

```cpp
class Calculator {
public:
    int    add(int a, int b)       { return a+b; }
    double add(double a, double b) { return a+b; }
    int    add(int a, int b, int c){ return a+b+c; }
};
```

오버로딩은 같은 이름의 함수를 매개변수 목록을 다르게 하여 여러 개 정의하는 것이다. 반환형만 다른 오버로딩은 불가능하다.

### 오버라이딩(상속 + `virtual` 재정의)

```cpp
struct Animal { virtual void speak(){ std::cout<<"동물\n"; } };
struct Dog    : Animal { void speak() override { std::cout<<"멍멍!\n"; } };
```

오버라이딩은 상속 관계에서 베이스 클래스의 가상 함수를 파생 클래스에서 재정의하는 것이다. `override` 키워드를 사용하면 서명 불일치를 컴파일 타임에 차단할 수 있다.

---

## 컴포지션(조합)과 불변/가변 설계

```cpp
class Engine {
public:
    void step(){ /*...*/ }
};

class Car {
    Engine engine_;      // 조합
public:
    void run(){ engine_.step(); }
};
```

재사용이 목적이라면 상속보다 조합을 우선하는 것이 좋다. 조합은 결합도를 낮추고 유연성을 높인다. 불변 객체는 동시성 환경과 테스트에서 유리하며, 변경이 필요한 경우에는 새 인스턴스를 반환하는 패턴을 고려할 수 있다.

---

## RAII와 자원 관리(파일/락/소켓)

```cpp
#include <cstdio>

class File {
    std::FILE* f_{};
public:
    explicit File(const char* path, const char* mode){
        f_ = std::fopen(path, mode);
        if (!f_) throw std::runtime_error("open fail");
    }
    ~File(){ if(f_) std::fclose(f_); }

    File(const File&)            = delete;
    File& operator=(const File&) = delete;
    File(File&& o) noexcept : f_(o.f_) { o.f_ = nullptr; }
    File& operator=(File&& o) noexcept {
        if (this != &o) { if(f_) std::fclose(f_); f_ = o.f_; o.f_ = nullptr; }
        return *this;
    }
};
```

RAII(Resource Acquisition Is Initialization)는 생성 시 자원을 획득하고 소멸 시 자원을 반환하는 패턴이다. 이를 통해 자원 누수를 방지하고 예외 안전성을 확보할 수 있다.

---

## 초기화 규칙과 함정

멤버 초기화 순서는 이니셜라이저 리스트의 순서가 아니라 선언 순서를 따른다. 정적 초기화 순서 문제를 해결하기 위해서는 inline static이나 함수 지역 정적 변수를 사용하여 지연 초기화할 수 있다. 현대 C++ 컴파일러는 복사 생략(copy elision)과 NRVO(Named Return Value Optimization)를 통해 값 반환 시 복사를 제거한다.

```cpp
class A {
    int x;
    int y;
public:
    A(int x_, int y_) : y(y_), x(x_) {} // 비권장: 선언 순서는 x, y 이므로 경고 유발
};
```

---

## 고급: PImpl(포인터에 의한 구현)로 빌드 의존성 줄이기

```cpp
// widget.hpp
#include <memory>

class Widget {
public:
    Widget();
    ~Widget();
    void draw() const;
private:
    struct Impl;
    std::unique_ptr<Impl> p_;
};

// widget.cpp
#include "widget.hpp"
#include <iostream>

struct Widget::Impl { void draw() const { std::cout<<"draw\n"; } };
Widget::Widget()  : p_(std::make_unique<Impl>()) {}
Widget::~Widget() = default;
void Widget::draw() const { p_->draw(); }
```

PImpl(Pointer to Implementation) 이디엄은 구현 세부사항을 헤더에서 숨겨 컴파일 시간을 단축하고 ABI 안정성을 높인다.

---

## 헤더/소스 분리와 ODR(One Definition Rule)

헤더 파일(.hpp 또는 .h)에는 클래스 선언과 인라인/템플릿 정의를 포함하며, include guard 또는 `#pragma once`로 중복 포함을 방지한다. 소스 파일(.cpp)에는 멤버 함수의 정의를 작성한다. ODR(One Definition Rule)에 따라 동일한 엔티티는 프로그램 전체에서 정확히 하나의 정의만 가져야 한다.

```cpp
// Person.hpp
#pragma once
#include <string>

class Person {
public:
    Person(std::string n, int a);
    void introduce() const;
private:
    std::string name_;
    int age_{};
};

// Person.cpp
#include "Person.hpp"
#include <iostream>

Person::Person(std::string n, int a) : name_(std::move(n)), age_(a) {}
void Person::introduce() const {
    std::cout << "안녕하세요, 저는 " << name_ << "이고, 나이는 " << age_ << "살입니다.\n";
}
```

---

## 예제: 요구사항 기반 클래스 설계(불변식 포함)

다음은 은행 계좌를 나타내는 `BankAccount` 클래스의 설계 예시다. 시작 잔액은 0 이상이어야 하며, 입금과 출금 API를 제공하되 과도 인출을 금지한다. 계좌번호는 읽기 전용이며, 로그성 출력은 외부에서 담당하도록 분리한다.

```cpp
#include <string>
#include <stdexcept>
#include <utility>

class BankAccount {
    std::string number_;
    long long   balance_{};
public:
    BankAccount(std::string number, long long initial = 0)
      : number_(std::move(number)), balance_(initial)
    {
        if (balance_ < 0) throw std::invalid_argument("negative init");
    }

    const std::string& number()  const noexcept { return number_;  }
    long long          balance() const noexcept { return balance_; }

    void deposit(long long amt){
        if (amt <= 0) throw std::invalid_argument("non-positive");
        balance_ += amt;
    }
    bool withdraw(long long amt) noexcept {
        if (amt <= 0 || amt > balance_) return false;
        balance_ -= amt; return true;
    }
};
```

이 클래스는 잔액이 항상 0 이상이라는 불변식($\text{balance} \ge 0$)을 API를 통해 보장한다. 출력과 로그는 비즈니스 로직과 분리되어 있다.

---

## 수학적 메모: 클래스 불변식

클래스의 불변식을 수식으로 기술하면 검토가 쉬워진다. 예를 들어 계좌 클래스의 불변식은 다음과 같이 표현할 수 있다.

$$
\forall t \in \text{lifetime}(\text{Account}) : \text{balance}(t) \in \mathbb{Z}_{\ge 0}
$$

테스트는 모든 공개 연산 후에 이 조건이 유지되는지를 확인해야 한다.

---

## 테스트/디버깅/툴링

코드 품질을 높이기 위해서는 다양한 도구를 활용해야 한다. 경고는 최대화하여(`-Wall -Wextra -Werror -pedantic`) 잠재적 문제를 조기에 발견한다. 정적 분석 도구인 clang-tidy는 modernize-use-override, performance-inefficient-string-concatenation 등의 검사를 수행한다. Sanitizer(ASan/UBSan/TSan)는 메모리 오류와 정의되지 않은 동작을 탐지한다. 단위 테스트는 Catch2나 GoogleTest를 사용하고, 성능 측정은 google-benchmark로 수행할 수 있다.

---

## 작은 FAQ

**Q. 왜 게터/세터 대신 도메인 동작 메서드가 좋은가?**  
A. 상태 일관성과 불변식을 클래스 내부에서 보장할 수 있기 때문이다.

**Q. 언제 `friend`를 쓰나?**  
A. 단위 테스트나 동일 모듈 내에서 밀접하게 협력하는 타입에 한해 최소화해서 사용한다. 캡슐화를 침식할 수 있으므로 주의해야 한다.

**Q. `struct`와 `class` 차이는?**  
A. 기본 접근 지정자만 다르다. 의미적으로는 `struct`를 데이터 집합(POCO) 표현에 자주 사용한다.

**Q. 멤버 순서가 중요한가?**  
A. 초기화 순서, 메모리 패킹, 정렬에 영향을 미친다. 특히 초기화는 선언 순서를 따른다.

---

## 빠른 참고 스니펫

```cpp
// 기본 규약 템플릿
class T {
public:
    T() = default;
    ~T() = default;
    T(const T&)            = default;
    T& operator=(const T&) = default;
    T(T&&)                 = default;
    T& operator=(T&&)      = default;
};

// 금지하고 싶은 연산
class NonCopyable {
public:
    NonCopyable(const NonCopyable&)            = delete;
    NonCopyable& operator=(const NonCopyable&) = delete;
};
```

---

## 컴파일 커맨드

```bash
g++ -std=c++20 -O2 -Wall -Wextra -Werror -pedantic main.cpp -o app
```

---

## 결론

클래스는 데이터와 불변식, 공개 동작의 계약을 하나로 묶는 강력한 추상화 도구다. 생성, 소멸, 복사, 이동의 시맨틱을 명확히 정의하고(Rule of Zero/Three/Five), 캡슐화를 통해 상태를 보호하며 API를 통해서만 조작하도록 설계해야 한다. 재사용이 필요할 때는 상속보다 조합을 우선하고, RAII 패턴을 활용하여 자원을 자동으로 관리한다. 현대 C++의 기능들(스마트 포인터, `explicit`, `noexcept`, `=default`, `=delete`, inline static 등)을 적극 활용하면 안전하고 예측 가능하며 유지보수하기 쉬운 타입을 만들 수 있다. 결국 좋은 클래스 설계란 명확한 책임, 강력한 불변식, 직관적인 인터페이스를 갖추는 것이다.