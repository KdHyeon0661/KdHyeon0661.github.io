---
layout: post
title: C# - 유닛 테스트
date: 2024-10-23 19:20:23 +0900
category: Csharp
---
# C# 유닛 테스트와 xUnit 정리

## 유닛 테스트의 중요성과 시작하기

유닛 테스트는 소프트웨어 개발의 품질을 보장하는 핵심 실천법입니다. 코드의 정확성을 검증하고, 리팩토링의 안전성을 제공하며, 문서로서의 역할을 합니다. xUnit은 .NET 생태계에서 가장 널리 사용되는 테스트 프레임워크로, 간결한 문법과 강력한 기능을 제공합니다.

테스트 프로젝트 설정부터 시작해 보겠습니다:

```bash
# 솔루션과 프로젝트 생성
dotnet new sln -n MyAppSolution
dotnet new classlib -n MyApp
dotnet new xunit -n MyApp.Tests

# 프로젝트 연결
dotnet sln add MyApp/MyApp.csproj MyApp.Tests/MyApp.Tests.csproj
dotnet add MyApp.Tests reference MyApp

# 필요한 패키지 추가 (템플릿에 포함될 수 있음)
dotnet add MyApp.Tests package xunit
dotnet add MyApp.Tests package xunit.runner.visualstudio
dotnet add MyApp.Tests package Microsoft.NET.Test.Sdk

# 테스트 실행
dotnet test
```

권장되는 프로젝트 구조는 다음과 같습니다:

```
MyAppSolution/
├── MyApp/
│   ├── Services/
│   ├── Models/
│   └── Utilities/
└── MyApp.Tests/
    ├── Services/
    ├── Models/
    └── Utilities/
```

이러한 구조는 프로덕션 코드와 테스트 코드 간의 명확한 분리를 제공합니다.

---

## xUnit 기본: 테스트 작성의 기초

### AAA 패턴과 명명 규칙

AAA 패턴(Arrange-Act-Assert)은 테스트를 구성하는 표준적인 방법입니다:

1. **Arrange**: 테스트에 필요한 모든 설정을 준비합니다. 객체 생성, 의존성 주입, 초기 데이터 설정 등이 포함됩니다.
2. **Act**: 테스트하려는 동작을 실행합니다. 보통 단일 메서드 호출입니다.
3. **Assert**: 예상된 결과를 검증합니다.

테스트 메서드 이름은 가독성 있게 지어야 합니다. 일반적으로 `메서드명_조건_기대결과` 형식을 따릅니다:

```csharp
[Fact]
public void CalculateTotal_WithValidItems_ReturnsCorrectSum()
{
    // Arrange
    var calculator = new ShoppingCartCalculator();
    var items = new[] { new Item(100), new Item(200), new Item(300) };
    
    // Act
    var total = calculator.CalculateTotal(items);
    
    // Assert
    Assert.Equal(600, total);
}
```

### Fact와 Theory의 구분

`[Fact]` 특성은 단일 테스트 케이스를 정의할 때 사용합니다:

```csharp
[Fact]
public void Add_TwoPositiveNumbers_ReturnsSum()
{
    var calculator = new Calculator();
    var result = calculator.Add(2, 3);
    Assert.Equal(5, result);
}
```

`[Theory]` 특성은 여러 입력 데이터에 대해 같은 테스트를 반복 실행할 때 사용합니다:

```csharp
[Theory]
[InlineData(2, 3, 5)]
[InlineData(10, -5, 5)]
[InlineData(0, 0, 0)]
[InlineData(int.MaxValue, 0, int.MaxValue)]
public void Add_VariousInputs_ReturnsCorrectSum(int a, int b, int expected)
{
    var calculator = new Calculator();
    var result = calculator.Add(a, b);
    Assert.Equal(expected, result);
}
```

---

## Assertions: 다양한 검증 방법

### 기본적인 검증

```csharp
// 값 비교
Assert.Equal(expected, actual);
Assert.NotEqual(unexpected, actual);

// 조건 검증
Assert.True(condition);
Assert.False(condition);

// Null 검증
Assert.Null(object);
Assert.NotNull(object);

// 참조 동일성
Assert.Same(expectedReference, actual);
Assert.NotSame(unexpectedReference, actual);
```

### 컬렉션 검증

```csharp
// 컬렉션 포함 여부
Assert.Contains(expectedItem, collection);
Assert.DoesNotContain(unexpectedItem, collection);

// 컬렉션 비교
Assert.Equal(expectedList, actualList);
Assert.NotEqual(unexpectedList, actualList);

// 컬렉션 순서
Assert.IsAssignableFrom<IEnumerable<int>>(collection);
```

### 예외 검증

```csharp
// 동기 예외
var exception = Assert.Throws<ArgumentException>(
    () => validator.Validate(null)
);
Assert.Equal("input", exception.ParamName);

// 비동기 예외
await Assert.ThrowsAsync<HttpRequestException>(
    () => httpClient.GetAsync("invalid-url")
);
```

### 범위와 근사값 검증

```csharp
// 범위 검증
Assert.InRange(value, low, high);
Assert.NotInRange(value, low, high);

// 부동소수점 근사값
Assert.Equal(expected, actual, precision: 5);
Assert.Equal(Math.PI, actual, precision: 3);
```

### 사용자 정의 비교자

```csharp
public class CaseInsensitiveComparer : IEqualityComparer<string>
{
    public bool Equals(string x, string y) 
        => string.Equals(x, y, StringComparison.OrdinalIgnoreCase);
    
    public int GetHashCode(string obj) 
        => obj.ToUpperInvariant().GetHashCode();
}

[Fact]
public void Collection_WithCustomComparer()
{
    var expected = new[] { "HELLO", "WORLD" };
    var actual = new[] { "hello", "world" };
    
    Assert.Equal(expected, actual, new CaseInsensitiveComparer());
}
```

---

## 비동기 테스트: 현대적 접근 방식

### 기본 비동기 테스트

```csharp
[Fact]
public async Task LoadDataAsync_ValidUrl_ReturnsData()
{
    // Arrange
    var service = new DataService();
    
    // Act
    var data = await service.LoadDataAsync("https://api.example.com/data");
    
    // Assert
    Assert.NotNull(data);
    Assert.NotEmpty(data);
}
```

### 취소와 타임아웃 처리

```csharp
[Fact]
public async Task ProcessAsync_CancelledToken_ThrowsCancellation()
{
    // Arrange
    var processor = new DataProcessor();
    using var cts = new CancellationTokenSource();
    cts.Cancel(); // 즉시 취소
    
    // Act & Assert
    await Assert.ThrowsAsync<OperationCanceledException>(
        () => processor.ProcessAsync(cts.Token)
    );
}

[Fact]
public async Task LongRunningTask_WithTimeout_CompletesInTime()
{
    // Arrange
    var task = new LongRunningService().ExecuteAsync();
    
    // Act & Assert
    await task.WaitAsync(TimeSpan.FromSeconds(5));
    // 작업이 5초 내에 완료되지 않으면 TimeoutException 발생
}
```

### 비동기 스트림 테스트

```csharp
[Fact]
public async Task GetItemsAsync_ReturnsAllItems()
{
    // Arrange
    var repository = new ItemRepository();
    var expectedItems = new[] { "Item1", "Item2", "Item3" };
    
    // Act
    var items = new List<string>();
    await foreach (var item in repository.GetItemsAsync())
    {
        items.Add(item);
    }
    
    // Assert
    Assert.Equal(expectedItems, items);
}
```

---

## 데이터 주도 테스트: 다양한 데이터 소스 활용

### MemberData를 이용한 테스트 데이터 분리

```csharp
public class CalculatorTests
{
    public static IEnumerable<object[]> AdditionTestData =>
        new List<object[]>
        {
            new object[] { 1, 2, 3 },
            new object[] { -1, -1, -2 },
            new object[] { int.MaxValue, 0, int.MaxValue },
            new object[] { int.MinValue, 1, int.MinValue + 1 }
        };
    
    [Theory]
    [MemberData(nameof(AdditionTestData))]
    public void Add_VariousInputs_ReturnsCorrectSum(int a, int b, int expected)
    {
        var calculator = new Calculator();
        var result = calculator.Add(a, b);
        Assert.Equal(expected, result);
    }
}
```

### ClassData를 이용한 재사용 가능한 테스트 데이터

```csharp
public class MultiplicationTestData : IEnumerable<object[]>
{
    public IEnumerator<object[]> GetEnumerator()
    {
        yield return new object[] { 2, 3, 6 };
        yield return new object[] { 4, 5, 20 };
        yield return new object[] { 10, 0, 0 };
        yield return new object[] { -3, 7, -21 };
    }
    
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

[Theory]
[ClassData(typeof(MultiplicationTestData))]
public void Multiply_VariousInputs_ReturnsCorrectProduct(int a, int b, int expected)
{
    var calculator = new Calculator();
    var result = calculator.Multiply(a, b);
    Assert.Equal(expected, result);
}
```

### TheoryData를 이용한 타입 안전한 테스트 데이터

```csharp
public class UserValidationTestData : TheoryData<string, int, bool>
{
    public UserValidationTestData()
    {
        Add("Alice", 25, true);    // 유효한 사용자
        Add("Bob", 17, false);     // 나이 부족
        Add("", 30, false);        // 이름 없음
        Add("Charlie", 151, false); // 나이 초과
    }
}

[Theory]
[ClassData(typeof(UserValidationTestData))]
public void ValidateUser_ReturnsExpectedResult(string name, int age, bool expected)
{
    var validator = new UserValidator();
    var isValid = validator.Validate(name, age);
    Assert.Equal(expected, isValid);
}
```

---

## 테스트 픽스처: 리소스 공유와 관리

### 클래스 수준 픽스처 (IClassFixture)

데이터베이스 연결이나 파일 시스템 같은 비용이 큰 리소스를 여러 테스트에서 공유할 때 사용합니다:

```csharp
public class DatabaseFixture : IDisposable
{
    public DatabaseConnection Connection { get; }
    
    public DatabaseFixture()
    {
        Connection = new DatabaseConnection("TestDatabase");
        Connection.Open();
        InitializeTestData();
    }
    
    private void InitializeTestData()
    {
        // 테스트용 초기 데이터 설정
    }
    
    public void Dispose()
    {
        Connection.Close();
        Connection.Dispose();
    }
}

public class UserRepositoryTests : IClassFixture<DatabaseFixture>
{
    private readonly DatabaseFixture _fixture;
    
    public UserRepositoryTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }
    
    [Fact]
    public void GetUser_ExistingId_ReturnsUser()
    {
        var repository = new UserRepository(_fixture.Connection);
        var user = repository.GetUser(1);
        Assert.NotNull(user);
    }
    
    [Fact]
    public void CreateUser_ValidData_ReturnsNewId()
    {
        var repository = new UserRepository(_fixture.Connection);
        var newUserId = repository.CreateUser("TestUser", "test@example.com");
        Assert.True(newUserId > 0);
    }
}
```

### 컬렉션 수준 픽스처 (ICollectionFixture)

여러 테스트 클래스에서 동일한 리소스를 공유해야 할 때 사용합니다:

```csharp
[CollectionDefinition("Database collection")]
public class DatabaseCollection : ICollectionFixture<DatabaseFixture>
{
    // 이 클래스는 빈 클래스로, 정의만 제공합니다
}

[Collection("Database collection")]
public class UserServiceTests
{
    private readonly DatabaseFixture _fixture;
    
    public UserServiceTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }
    
    [Fact]
    public void TestWithSharedDatabase()
    {
        // 데이터베이스 공유 테스트
    }
}

[Collection("Database collection")]
public class ProductServiceTests
{
    private readonly DatabaseFixture _fixture;
    
    public ProductServiceTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }
    
    [Fact]
    public void AnotherTestWithSameDatabase()
    {
        // 동일한 데이터베이스 인스턴스 사용
    }
}
```

---

## 테스트 출력과 진단 정보

테스트 실행 중에 추가 정보를 출력할 수 있습니다:

```csharp
public class OutputTests
{
    private readonly ITestOutputHelper _output;
    
    public OutputTests(ITestOutputHelper output)
    {
        _output = output;
    }
    
    [Fact]
    public void TestWithDetailedOutput()
    {
        _output.WriteLine($"테스트 시작 시간: {DateTime.Now:HH:mm:ss.fff}");
        
        // 테스트 로직
        var processor = new DataProcessor();
        var result = processor.Process("test data");
        
        _output.WriteLine($"처리 결과: {result}");
        _output.WriteLine($"메모리 사용량: {GC.GetTotalMemory(false):N0} bytes");
        
        Assert.NotNull(result);
        
        _output.WriteLine("테스트 완료 시간: " + DateTime.Now.ToString("HH:mm:ss.fff"));
    }
}
```

이 출력은 테스트 실행기(Visual Studio Test Explorer, dotnet test 등)에서 확인할 수 있습니다.

---

## 목(Mock)과 테스트 더블(Test Doubles)

### 의존성 추상화의 중요성

테스트 가능한 코드를 작성하기 위해서는 의존성을 추상화해야 합니다:

```csharp
// 인터페이스 정의
public interface IEmailService
{
    Task SendAsync(string to, string subject, string body);
}

public interface IDateTimeProvider
{
    DateTime UtcNow { get; }
}

// 실제 구현
public class SmtpEmailService : IEmailService
{
    public async Task SendAsync(string to, string subject, string body)
    {
        // 실제 SMTP 서버로 이메일 전송
    }
}

public class SystemDateTimeProvider : IDateTimeProvider
{
    public DateTime UtcNow => DateTime.UtcNow;
}

// 서비스 클래스
public class NotificationService
{
    private readonly IEmailService _emailService;
    private readonly IDateTimeProvider _dateTimeProvider;
    
    public NotificationService(IEmailService emailService, IDateTimeProvider dateTimeProvider)
    {
        _emailService = emailService;
        _dateTimeProvider = dateTimeProvider;
    }
    
    public async Task SendWelcomeEmail(string email)
    {
        var currentDate = _dateTimeProvider.UtcNow;
        var subject = $"환영합니다! ({currentDate:yyyy-MM-dd})";
        var body = "서비스에 가입해 주셔서 감사합니다.";
        
        await _emailService.SendAsync(email, subject, body);
    }
}
```

### Moq를 이용한 목킹

Moq는 .NET에서 가장 널리 사용되는 목킹 라이브러리입니다:

```csharp
[Fact]
public async Task SendWelcomeEmail_CallsEmailService()
{
    // Arrange
    var mockEmailService = new Mock<IEmailService>();
    var mockDateTimeProvider = new Mock<IDateTimeProvider>();
    
    var fixedDate = new DateTime(2024, 1, 1, 0, 0, 0, DateTimeKind.Utc);
    mockDateTimeProvider.Setup(p => p.UtcNow).Returns(fixedDate);
    
    var service = new NotificationService(
        mockEmailService.Object, 
        mockDateTimeProvider.Object
    );
    
    // Act
    await service.SendWelcomeEmail("test@example.com");
    
    // Assert
    mockEmailService.Verify(
        s => s.SendAsync(
            "test@example.com",
            $"환영합니다! ({fixedDate:yyyy-MM-dd})",
            "서비스에 가입해 주셔서 감사합니다."
        ),
        Times.Once
    );
}
```

### 다양한 목킹 시나리오

```csharp
// 반환값 설정
mock.Setup(x => x.GetValue()).Returns(42);
mock.Setup(x => x.GetValueAsync()).ReturnsAsync(42);

// 예외 발생 설정
mock.Setup(x => x.FailingMethod()).Throws<InvalidOperationException>();

// 속성 설정
mock.SetupProperty(x => x.Name, "기본값");
mock.Object.Name = "새값";

// 콜백 설정
int callCount = 0;
mock.Setup(x => x.Process(It.IsAny<string>()))
    .Callback<string>(input => callCount++)
    .Returns(true);

// 조건부 설정
mock.Setup(x => x.Process(It.Is<string>(s => s.Length > 5)))
    .Returns(true);
mock.Setup(x => x.Process(It.Is<string>(s => s.Length <= 5)))
    .Returns(false);
```

### HTTP 클라이언트 테스트

```csharp
public class MockHttpMessageHandler : HttpMessageHandler
{
    private readonly HttpResponseMessage _response;
    
    public MockHttpMessageHandler(HttpResponseMessage response)
    {
        _response = response;
    }
    
    protected override Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request, 
        CancellationToken cancellationToken)
    {
        return Task.FromResult(_response);
    }
}

[Fact]
public async Task ApiClient_GetData_ReturnsParsedResponse()
{
    // Arrange
    var jsonResponse = """{"id": 1, "name": "Test Item"}""";
    var response = new HttpResponseMessage(HttpStatusCode.OK)
    {
        Content = new StringContent(jsonResponse, Encoding.UTF8, "application/json")
    };
    
    var handler = new MockHttpMessageHandler(response);
    var httpClient = new HttpClient(handler);
    var apiClient = new ApiClient(httpClient);
    
    // Act
    var result = await apiClient.GetItemAsync(1);
    
    // Assert
    Assert.NotNull(result);
    Assert.Equal(1, result.Id);
    Assert.Equal("Test Item", result.Name);
}
```

---

## 테스트 조직화와 실행 제어

### 카테고리화와 필터링

```csharp
[Trait("Category", "Integration")]
[Trait("Priority", "High")]
public class IntegrationTests
{
    [Fact]
    public void DatabaseIntegrationTest()
    {
        // 통합 테스트
    }
}

[Trait("Category", "Unit")]
[Trait("Priority", "Medium")]
public class UnitTests
{
    [Fact]
    public void BusinessLogicTest()
    {
        // 단위 테스트
    }
}
```

명령줄에서 특정 카테고리의 테스트만 실행할 수 있습니다:

```bash
dotnet test --filter "Category=Integration"
dotnet test --filter "Priority=High"
dotnet test --filter "Category=Unit&Priority=Medium"
```

### 테스트 건너뛰기

```csharp
[Fact(Skip = "외부 API 문제로 임시 건너뜀")]
public void ExternalApiTest()
{
    // 외부 의존성이 있는 테스트
}

// 조건부 실행
[Fact]
public void WindowsSpecificTest()
{
    if (!OperatingSystem.IsWindows())
    {
        throw new SkipException("이 테스트는 Windows에서만 실행됩니다");
    }
    
    // Windows 특정 테스트
}
```

### 병렬 실행 제어

`xunit.runner.json` 파일을 통해 테스트 실행 방식을 제어할 수 있습니다:

```json
{
  "$schema": "https://xunit.net/schema/current/xunit.runner.schema.json",
  "parallelizeAssembly": false,
  "parallelizeTestCollections": true,
  "maxParallelThreads": 2,
  "diagnosticMessages": true,
  "longRunningTestSeconds": 30
}
```

컬렉션을 사용하여 특정 테스트들이 순차적으로 실행되도록 강제할 수 있습니다:

```csharp
[Collection("NonParallelTests")]
public class DatabaseTests1
{
    [Fact]
    public void Test1() { /* 데이터베이스 작업 */ }
}

[Collection("NonParallelTests")]
public class DatabaseTests2
{
    [Fact]
    public void Test2() { /* 동일한 데이터베이스 작업 */ }
}
```

---

## 테스트 커버리지 분석

코드 커버리지는 테스트가 얼마나 많은 코드를 실행하는지 측정합니다:

```bash
# 커버리지 데이터 수집
dotnet test --collect:"XPlat Code Coverage"

# coverlet 사용 시
dotnet add package coverlet.collector
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura

# 리포트 생성
dotnet tool install -g dotnet-reportgenerator-globaltool
reportgenerator -reports:**/coverage.cobertura.xml -targetdir:coverage-report -reporttypes:Html
```

커버리지는 품질 지표 중 하나이지만, 높은 커버리지가 반드시 좋은 테스트를 의미하지는 않습니다. 의미 있는 테스트 케이스가 더 중요합니다.

---

## 통합 테스트와 엔드투엔드 테스트

### 통합 테스트 예제

```csharp
public class OrderIntegrationTests : IAsyncLifetime
{
    private TestServer _server;
    private HttpClient _client;
    private IServiceScope _scope;
    private ApplicationDbContext _dbContext;
    
    public async Task InitializeAsync()
    {
        // 테스트 서버 설정
        var builder = WebApplication.CreateBuilder();
        builder.Services.AddDbContext<ApplicationDbContext>(options =>
            options.UseInMemoryDatabase("TestDb"));
        
        var app = builder.Build();
        _server = new TestServer(new WebHostBuilder().UseStartup<TestStartup>());
        _client = _server.CreateClient();
        
        // 데이터베이스 컨텍스트 설정
        _scope = app.Services.CreateScope();
        _dbContext = _scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
        await _dbContext.Database.EnsureCreatedAsync();
    }
    
    [Fact]
    public async Task PlaceOrder_ValidRequest_CreatesOrder()
    {
        // Arrange
        var customer = new Customer { Name = "Test Customer" };
        _dbContext.Customers.Add(customer);
        await _dbContext.SaveChangesAsync();
        
        var request = new
        {
            CustomerId = customer.Id,
            Items = new[]
            {
                new { ProductId = 1, Quantity = 2 },
                new { ProductId = 2, Quantity = 1 }
            }
        };
        
        // Act
        var response = await _client.PostAsJsonAsync("/api/orders", request);
        
        // Assert
        response.EnsureSuccessStatusCode();
        var order = await response.Content.ReadFromJsonAsync<Order>();
        Assert.NotNull(order);
        Assert.Equal(customer.Id, order.CustomerId);
        Assert.Equal(2, order.Items.Count);
    }
    
    public async Task DisposeAsync()
    {
        _client?.Dispose();
        _server?.Dispose();
        await _dbContext.Database.EnsureDeletedAsync();
        _scope?.Dispose();
    }
}
```

### 실제 애플리케이션 테스트 예제

복잡한 비즈니스 로직을 가진 애플리케이션의 테스트를 살펴보겠습니다:

```csharp
public class ECommerceServiceTests
{
    [Fact]
    public async Task ProcessOrder_WithValidItemsAndCustomer_CompletesSuccessfully()
    {
        // Arrange
        var mockInventory = new Mock<IInventoryService>();
        var mockPayment = new Mock<IPaymentGateway>();
        var mockShipping = new Mock<IShippingService>();
        var mockNotifications = new Mock<INotificationService>();
        
        // 재고 확인 설정
        mockInventory.Setup(x => x.CheckAvailability(It.IsAny<int>(), It.IsAny<int>()))
                     .ReturnsAsync(true);
        
        // 결제 성공 설정
        mockPayment.Setup(x => x.ProcessPayment(It.IsAny<decimal>(), It.IsAny<string>()))
                   .ReturnsAsync(new PaymentResult { Success = true, TransactionId = "TXN123" });
        
        // 배송 예약 성공 설정
        mockShipping.Setup(x => x.ScheduleDelivery(It.IsAny<Address>(), It.IsAny<List<OrderItem>>()))
                    .ReturnsAsync(new DeliverySchedule { TrackingNumber = "TRACK123", EstimatedDate = DateTime.Now.AddDays(2) });
        
        var service = new OrderProcessingService(
            mockInventory.Object,
            mockPayment.Object,
            mockShipping.Object,
            mockNotifications.Object
        );
        
        var order = new Order
        {
            CustomerId = 1,
            Items = new List<OrderItem>
            {
                new OrderItem { ProductId = 101, Quantity = 2, UnitPrice = 25.00m },
                new OrderItem { ProductId = 102, Quantity = 1, UnitPrice = 49.99m }
            },
            ShippingAddress = new Address { /* 주소 정보 */ }
        };
        
        // Act
        var result = await service.ProcessOrderAsync(order);
        
        // Assert
        Assert.True(result.Success);
        Assert.Equal(OrderStatus.Completed, result.OrderStatus);
        Assert.Equal("TXN123", result.TransactionId);
        Assert.Equal("TRACK123", result.TrackingNumber);
        
        // 모든 의존성이 적절히 호출되었는지 검증
        mockInventory.Verify(x => x.CheckAvailability(101, 2), Times.Once);
        mockInventory.Verify(x => x.CheckAvailability(102, 1), Times.Once);
        mockPayment.Verify(x => x.ProcessPayment(99.99m, It.IsAny<string>()), Times.Once);
        mockShipping.Verify(x => x.ScheduleDelivery(It.IsAny<Address>(), It.IsAny<List<OrderItem>>()), Times.Once);
        mockNotifications.Verify(x => x.SendOrderConfirmation(It.IsAny<int>()), Times.Once);
    }
    
    [Theory]
    [InlineData(0, 2, 25.00, "수량 부족")]
    [InlineData(2, 0, 25.00, "가격 오류")]
    [InlineData(2, -1, 25.00, "잘못된 수량")]
    public void ValidateOrderItem_InvalidData_ThrowsException(
        int productId, int quantity, decimal unitPrice, string expectedError)
    {
        // Arrange
        var item = new OrderItem
        {
            ProductId = productId,
            Quantity = quantity,
            UnitPrice = unitPrice
        };
        
        var validator = new OrderValidator();
        
        // Act & Assert
        var exception = Assert.Throws<ValidationException>(
            () => validator.ValidateItem(item)
        );
        
        Assert.Contains(expectedError, exception.Message);
    }
}
```

---

## 결론

유닛 테스트는 단순히 코드를 검증하는 도구를 넘어서, 더 나은 소프트웨어 설계와 개발 문화를 만드는 핵심 요소입니다. xUnit을 효과적으로 사용하기 위한 핵심 원칙을 정리해 보겠습니다:

### 테스트 철학과 접근법

1. **테스트 주도 설계(TDD)**: 테스트를 먼저 작성함으로써 더 나은 API 설계와 구현을 유도하세요. 실패하는 테스트를 먼저 작성하고, 최소한의 코드로 통과시킨 후 리팩토링하는 사이클을 따르세요.

2. **FIRST 원칙**:
   - **Fast**: 테스트는 빠르게 실행되어야 합니다. 느린 테스트는 자주 실행하지 않게 만듭니다.
   - **Independent**: 각 테스트는 독립적이어야 하며, 다른 테스트에 의존해서는 안 됩니다.
   - **Repeatable**: 테스트는 어떤 환경에서도 동일한 결과를 반환해야 합니다.
   - **Self-validating**: 테스트는 성공/실패를 스스로 판단할 수 있어야 합니다.
   - **Timely**: 테스트는 테스트 대상 코드와 동시에 또는 그 직전에 작성되어야 합니다.

### 기술적 모범 사례

3. **의존성 주입과 추상화**: 외부 의존성(데이터베이스, 파일 시스템, 시간, 랜덤 등)은 인터페이스를 통해 추상화하고, 테스트 시에는 목(Mock)이나 스텁(Stub)으로 대체하세요.

4. **테스트 더블의 적절한 사용**: 
   - **Dummy**: 전달만 하고 실제 사용되지 않는 객체
   - **Fake**: 실제 구현의 단순화된 버전 (예: 인메모리 데이터베이스)
   - **Stub**: 미리 정의된 응답을 반환하는 객체
   - **Mock**: 호출을 기대하고 검증하는 객체
   - **Spy**: 호출 정보를 기록하는 객체

5. **테스트 피라미드 준수**: 단위 테스트(많음) > 통합 테스트(중간) > E2E 테스트(적음)의 비율을 유지하세요.

### 실용적인 조언

6. **의미 있는 테스트 이름**: 테스트 이름은 실패 시 어떤 문제인지 알 수 있도록 명확하게 지으세요. `MethodName_Scenario_ExpectedResult` 패턴을 따르는 것이 좋습니다.

7. **한 번에 하나의 개념 테스트**: 각 테스트는 하나의 개념이나 시나리오만 검증하세요. 여러 가지를 한 테스트에서 검증하면 실패 원인을 파악하기 어려워집니다.

8. **실제 환경 고려**: 테스트가 CI/CD 파이프라인에서 어떻게 실행될지, 병렬 실행 시 충돌은 없는지, 성능은 어떤지 고려하세요.

9. **리팩토링과 유지보수**: 테스트 코드도 프로덕션 코드만큼 중요하게 관리하세요. 중복을 제거하고, 가독성을 높이며, 정기적으로 리팩토링하세요.

10. **지속적인 학습과 개선**: 테스트 커버리지, 테스트 실행 시간, 실패율 등을 모니터링하고 지속적으로 개선하세요. 새로운 테스트 기법과 도구를 배우고 팀과 공유하세요.

유닛 테스트는 단기적으로는 시간 투자가 필요하지만, 장기적으로는 버그 감소, 리팩토링 용이성, 문서화 효과, 개발자 자신감 향상 등의 가치를 제공합니다. xUnit의 강력한 기능들을 잘 활용하여 견고하고 유지보수 가능한 테스트 스위트를 구축하세요. 이는 단순한 기술적 선택이 아니라, 소프트웨어 개발의 품질과 지속 가능성을 보장하는 문화적 변화입니다.