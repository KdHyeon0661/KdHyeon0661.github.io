---
layout: post
title: C# - 유닛 테스트
date: 2024-10-23 19:20:23 +0900
category: Csharp
---
# C# 유닛 테스트와 xUnit 정리

## 0) 빠른 시작: 프로젝트 생성과 실행

```bash
# (1) 솔루션과 두 프로젝트(프로덕션 + 테스트) 생성
dotnet new sln -n DemoSolution
dotnet new classlib -n DemoApp
dotnet new xunit -n DemoApp.Tests

# (2) 참조 연결
dotnet sln DemoSolution.sln add DemoApp/DemoApp.csproj DemoApp.Tests/DemoApp.Tests.csproj
dotnet add DemoApp.Tests/DemoApp.Tests.csproj reference DemoApp/DemoApp.csproj

# (3) (필수) 러너/SDK 추가 (템플릿에 이미 포함되어 있으면 생략)
dotnet add DemoApp.Tests package xunit
dotnet add DemoApp.Tests package xunit.runner.visualstudio
dotnet add DemoApp.Tests package Microsoft.NET.Test.Sdk

# (4) 테스트 실행
dotnet test
```

프로젝트 구조(권장):

```
DemoSolution/
  DemoApp/
    Services/
    Models/
  DemoApp.Tests/
    Services/
    Models/
```

---

## 1) xUnit 기본: AAA 패턴과 `[Fact]`/`[Theory]`

### 1.1 AAA(Arrange-Act-Assert)와 명명 규칙

- **Arrange**: 준비(입력/환경/의존성)
- **Act**: 대상 메서드 호출
- **Assert**: 결과 검증

권장 테스트 이름: `MethodName_Should_ExpectedBehavior_When_Scenario()` 또는 한글로 `메서드명_상황_기대결과()`.

### 1.2 `[Fact]` — 고정 입력

```csharp
using Xunit;

public sealed class Calculator
{
    public int Add(int a, int b) => a + b;
}

public class CalculatorTests
{
    [Fact]
    public void Add_Should_ReturnSum_When_ValidInputs()
    {
        // Arrange
        var sut = new Calculator();

        // Act
        var result = sut.Add(2, 3);

        // Assert
        Assert.Equal(5, result);
    }
}
```

### 1.3 `[Theory]` + `InlineData` — 데이터 주입

```csharp
public class CalculatorTheoryTests
{
    [Theory]
    [InlineData(2, 3, 5)]
    [InlineData(10, -5, 5)]
    [InlineData(0, 0, 0)]
    public void Add_Should_Work_For_MultipleInputs(int a, int b, int expected)
    {
        var sut = new Calculator();
        var result = sut.Add(a, b);
        Assert.Equal(expected, result);
    }
}
```

---

## 2) 주요 Assert와 컬렉션/예외/근사 비교

| 메서드 | 용도 | 비고 |
|---|---|---|
| `Assert.Equal(expected, actual)` | 값/시퀀스 비교 | 커스텀 비교는 IEqualityComparer 사용 |
| `Assert.True/False(cond)` | 조건 검증 | 메시지 인자로 디버그 힌트 추가 가능 |
| `Assert.Null/NotNull(obj)` | 널 체크 | |
| `Assert.Same/NotSame(a,b)` | 참조 동일성 | 레퍼런스 비교 |
| `Assert.Contains/DoesNotContain` | 컬렉션/문자열 | |
| `Assert.Throws<T>` | 동기 예외 | 메시지/속성 추가 검증 가능 |
| `Assert.ThrowsAsync<T>` | 비동기 예외 | `await` 필수 |
| `Assert.InRange/NotInRange` | 범위 | 수치/날짜 등 |
| `Assert.Equal` with precision | 부동소수 근사 | `Assert.Equal(PI, actual, precision: 5)` 등 |

예외 메시지/속성까지 검증:

```csharp
[Fact]
public void Withdraw_Should_Throw_When_Insufficient()
{
    var acct = new BankAccount(balance: 100);

    var ex = Assert.Throws<InvalidOperationException>(() => acct.Withdraw(200));

    Assert.Contains("Insufficient", ex.Message);
}
```

---

## 3) 비동기/타임아웃/취소 토큰 테스트

### 3.1 비동기 로직

```csharp
[Fact]
public async Task FetchAsync_Should_Return_Data()
{
    var svc = new DataService();
    var r = await svc.FetchAsync();
    Assert.NotEmpty(r);
}
```

### 3.2 예외 비동기

```csharp
[Fact]
public async Task FetchAsync_Should_Throw_On_404()
{
    var svc = new DataService(always404: true);
    await Assert.ThrowsAsync<HttpRequestException>(async () => await svc.FetchAsync());
}
```

### 3.3 취소 토큰

```csharp
[Fact]
public async Task WorkAsync_Should_Observe_Cancellation()
{
    using var cts = new CancellationTokenSource();
    cts.Cancel();

    await Assert.ThrowsAsync<OperationCanceledException>(
        () => new Worker().WorkAsync(cts.Token));
}
```

.NET 6+의 `WaitAsync`로 간단 타임아웃:

```csharp
[Fact]
public async Task WorkAsync_Should_Finish_Within_1s()
{
    var task = new Worker().WorkAsync(CancellationToken.None);
    await task.WaitAsync(TimeSpan.FromSeconds(1));
}
```

---

## 4) 데이터 주도 테스트 심화: `MemberData`, `ClassData`, `TheoryData`

### 4.1 MemberData

```csharp
public static IEnumerable<object[]> AddCases => new[]
{
    new object[] { 1, 2, 3 },
    new object[] { int.MaxValue, 0, int.MaxValue },
};

[Theory]
[MemberData(nameof(AddCases))]
public void Add_Should_Work_With_MemberData(int a, int b, int expected)
{
    Assert.Equal(expected, new Calculator().Add(a, b));
}
```

### 4.2 ClassData

```csharp
public class PrimeCases : IEnumerable<object[]>
{
    public IEnumerator<object[]> GetEnumerator()
    {
        yield return new object[] { 2, true };
        yield return new object[] { 15, false };
    }
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

[Theory]
[ClassData(typeof(PrimeCases))]
public void IsPrime_Should_Return_Correct(int n, bool expected)
{
    Assert.Equal(expected, Number.IsPrime(n));
}
```

### 4.3 TheoryData

```csharp
public class UserCases : TheoryData<string, int>
{
    public UserCases()
    {
        Add("Alice", 30);
        Add("Bob", 25);
    }
}

[Theory]
[ClassData(typeof(UserCases))]
public void CreateUser_Should_Set_Props(string name, int age)
{
    var u = new User(name, age);
    Assert.Equal(name, u.Name);
    Assert.Equal(age, u.Age);
}
```

---

## 5) 픽스처: **IClassFixture**, **ICollectionFixture** (비용 큰 리소스 공유)

### 5.1 IClassFixture — 클래스 단위 공유

```csharp
public sealed class DbFixture : IDisposable
{
    public readonly FakeDb Db = new();
    public void Dispose() => Db.Dispose();
}

public class RepositoryTests : IClassFixture<DbFixture>
{
    private readonly DbFixture _fx;
    public RepositoryTests(DbFixture fx) => _fx = fx;

    [Fact]
    public void Insert_Should_Affect_Count()
    {
        _fx.Db.Clear();
        _fx.Db.Insert(new Item("A"));
        Assert.Equal(1, _fx.Db.Count());
    }
}
```

### 5.2 ICollectionFixture — 컬렉션(여러 클래스) 간 공유

```csharp
public class ExternalServerFixture : IDisposable { /* start server */ public void Dispose(){/*stop*/} }

[CollectionDefinition("Server collection")]
public class ServerCollection : ICollectionFixture<ExternalServerFixture> { }

[Collection("Server collection")]
public class ServiceATests { /* ctor inject ExternalServerFixture */ }

[Collection("Server collection")]
public class ServiceBTests { /* 공유 서버 사용 */ }
```

---

## 6) TestOutput: 로그/진단

```csharp
using Xunit.Abstractions;

public class LoggingTests
{
    private readonly ITestOutputHelper _out;

    public LoggingTests(ITestOutputHelper output) => _out = output;

    [Fact]
    public void Can_Write_Output()
    {
        _out.WriteLine("diagnostic message");
        Assert.True(true);
    }
}
```

---

## 7) 목킹/스텁/페이크 — 의존성 제거

### 7.1 인터페이스 설계로 테스트 용이성 확보

```csharp
public interface IClock { DateTime UtcNow { get; } }

public sealed class SystemClock : IClock { public DateTime UtcNow => DateTime.UtcNow; }

public sealed class TokenService
{
    private readonly IClock _clock;
    public TokenService(IClock clock) => _clock = clock;

    public bool IsExpired(DateTime expiresUtc) => _clock.UtcNow >= expiresUtc;
}
```

#### 스텁 구현

```csharp
public sealed class FixedClock : IClock
{
    public DateTime UtcNow { get; }
    public FixedClock(DateTime now) => UtcNow = now;
}

[Fact]
public void IsExpired_Should_Use_Clock()
{
    var sut = new TokenService(new FixedClock(new DateTime(2030,1,1,0,0,0,DateTimeKind.Utc)));
    Assert.True(sut.IsExpired(new DateTime(2029,12,31,23,59,0,DateTimeKind.Utc)));
}
```

### 7.2 Moq/NSubstitute (예: Moq)

```csharp
# 툴 복사: 패키지 추가
dotnet add DemoApp.Tests package Moq
```

```csharp
using Moq;

[Fact]
public void Service_Should_Call_Repo_Save()
{
    var repo = new Mock<IRepository>();
    var svc = new OrderService(repo.Object);

    svc.Place(new Order("A"));

    repo.Verify(r => r.Save(It.Is<Order>(o => o.Id == "A")), Times.Once);
}
```

### 7.3 HTTP 테스트 — `HttpMessageHandler` 스텁

```csharp
public class StubHandler : HttpMessageHandler
{
    private readonly HttpResponseMessage _resp;
    public StubHandler(HttpResponseMessage resp) => _resp = resp;

    protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage req, CancellationToken ct)
        => Task.FromResult(_resp);
}

[Fact]
public async Task HttpClient_Should_Return_Stubbed_Response()
{
    var handler = new StubHandler(new HttpResponseMessage(HttpStatusCode.OK)
    {
        Content = new StringContent("{\"ok\":true}")
    });
    var http = new HttpClient(handler);
    var json = await http.GetStringAsync("http://unit-test");

    Assert.Contains("ok", json);
}
```

### 7.4 파일 테스트 — 임시 디렉터리

```csharp
[Fact]
public void Writer_Should_Create_File()
{
    var tempDir = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
    Directory.CreateDirectory(tempDir);
    try
    {
        var path = Path.Combine(tempDir, "out.txt");
        FileWriter.Write(path, "data");
        Assert.True(File.Exists(path));
        Assert.Equal("data", File.ReadAllText(path));
    }
    finally { Directory.Delete(tempDir, recursive: true); }
}
```

---

## 8) 카테고리/스킵/주문/병렬

### 8.1 Trait(카테고리)
```csharp
[Trait("Category", "Integration")]
[Fact]
public void Integration_Test() { /* ... */ }
```
CLI에서 필터링:  
```bash
dotnet test --filter "Category=Integration"
```

### 8.2 Skip/조건부 실행
```csharp
[Fact(Skip = "외부 API 점검 중")]
public void TemporarilySkipped() { }
```

### 8.3 테스트 순서(필요 시만)
```csharp
[TestCaseOrderer("Xunit.Sdk.MethodDisplayOrderer", "xunit.execution")] // 또는 커스텀
```
> 일반적으로 **순서 의존 테스트는 지양**. 독립적으로 구성.

### 8.4 병렬 실행 제어
`xunit.runner.json` (테스트 프로젝트 루트):

```json
{
  "parallelizeAssembly": true,
  "parallelizeTestCollections": true,
  "maxParallelThreads": 0
}
```

릭키 리소스(파일/포트)를 쓰는 테스트에 [Collection("…")]으로 동시 실행 억제.

---

## 9) 커버리지 수집과 품질 게이트

### 9.1 coverlet.collector

```bash
dotnet add DemoApp.Tests package coverlet.collector
```

실행:

```bash
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura
```

ReportGenerator로 HTML 변환(옵션):

```bash
dotnet tool install -g dotnet-reportgenerator-globaltool
reportgenerator -reports:**/coverage.cobertura.xml -targetdir:coverage-report
```

**커버리지 직관**:  
$$ \text{라인 커버리지} = \frac{\text{실행된 라인 수}}{\text{전체 라인 수}} \times 100(\%) $$

> **주의**: 커버리지는 “품질의 대리 지표”일 뿐. **의미 있는 시나리오**를 우선.

---

## 10) 테스트 친화적 설계 원칙 (현업 체크리스트)

- **의존성 주입**(시간·랜덤·I/O·HTTP 등)을 인터페이스로 추상화
- **순수 함수/불변 데이터** 선호, 사이드이펙트 최소화
- **작은 단위**로 분리, public API 기준으로 테스트
- **비동기 전파**: `.Result`/`.Wait()` 금지(교착/플레이크)
- **고정 시드**로 랜덤성 통제
- **테스트 데이터 빌더** 패턴으로 가독성 확보

---

## 11) 실전 예제: 서비스 + 리포지토리 + 시계 + HTTP

### 11.1 프로덕션 코드 (간소화)

```csharp
// DemoApp/Services/UserService.cs
public interface IUserRepository
{
    Task<User?> FindAsync(string id, CancellationToken ct);
    Task SaveAsync(User user, CancellationToken ct);
}

public sealed record User(string Id, string Name, DateTime CreatedUtc);

public sealed class UserService
{
    private readonly IUserRepository _repo;
    private readonly IClock _clock;
    private readonly HttpClient _http;

    public UserService(IUserRepository repo, IClock clock, HttpClient http)
    {
        _repo = repo; _clock = clock; _http = http;
    }

    public async Task<User> CreateAsync(string id, string name, CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(id)) throw new ArgumentException(nameof(id));
        if (await _repo.FindAsync(id, ct) is not null)
            throw new InvalidOperationException("duplicate");

        // 외부 검증 API (예시)
        var ok = await _http.GetStringAsync($"https://example.test/validate?id={id}", ct);
        if (!ok.Contains("OK")) throw new InvalidOperationException("invalid id");

        var u = new User(id, name, _clock.UtcNow);
        await _repo.SaveAsync(u, ct);
        return u;
    }
}
```

### 11.2 테스트 (Moq + StubHandler + FixedClock)

```csharp
// DemoApp.Tests/Services/UserServiceTests.cs
using Moq;
using Xunit;

public class UserServiceTests
{
    private static HttpClient OkClient()
    {
        var handler = new StubHandler(new HttpResponseMessage(HttpStatusCode.OK)
        {
            Content = new StringContent("OK")
        });
        return new HttpClient(handler);
    }

    [Fact]
    public async Task CreateAsync_Should_Save_User_When_Valid()
    {
        // Arrange
        var repo = new Mock<IUserRepository>();
        repo.Setup(r => r.FindAsync("u1", It.IsAny<CancellationToken>())).ReturnsAsync((User?)null);
        var clock = new FixedClock(new DateTime(2030,1,1,0,0,0,DateTimeKind.Utc));
        var http  = OkClient();
        var sut   = new UserService(repo.Object, clock, http);

        // Act
        var u = await sut.CreateAsync("u1", "Alice", CancellationToken.None);

        // Assert
        Assert.Equal("u1", u.Id);
        Assert.Equal("Alice", u.Name);
        Assert.Equal(clock.UtcNow, u.CreatedUtc);
        repo.Verify(r => r.SaveAsync(It.Is<User>(x => x.Id=="u1"), It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task CreateAsync_Should_Throw_When_Duplicate()
    {
        var repo = new Mock<IUserRepository>();
        repo.Setup(r => r.FindAsync("u1", It.IsAny<CancellationToken>())).ReturnsAsync(new User("u1", "Old", DateTime.UtcNow));

        var sut = new UserService(repo.Object, new FixedClock(DateTime.UtcNow), OkClient());

        await Assert.ThrowsAsync<InvalidOperationException>(
            () => sut.CreateAsync("u1", "Alice", CancellationToken.None));
    }
}
```

---

## 12) 실행/필터/출력 옵션 요약

- 전체 실행: `dotnet test`
- 카테고리/이름 필터: `dotnet test --filter "Category=Slow|FullyQualifiedName~UserService"`
- 병렬 제한: `xunit.runner.json`에서 제어
- 테스트 탐색기(IDE)로 부분 실행/디버깅 지원

---

## 13) CI 통합(GitHub Actions 예시)

```yaml
name: tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'
    - run: dotnet restore
    - run: dotnet build --configuration Release --no-restore
    - run: dotnet test --configuration Release --no-build --logger "trx;LogFileName=test.trx" /p:CollectCoverage=true
```

---

## 14) 빈틈 메우기 Q&A

- **비동기 테스트에서 교착이 나요**  
  → 테스트/코드 모두 끝까지 `await`로 전파, `.Result`/`.Wait()` 금지.

- **시간 기반 로직이 불안정해요**  
  → `IClock` 주입으로 결정적 시간 고정(`FixedClock`).

- **랜덤/ID 생성**  
  → `IRandom`/`IGuidProvider` 추상화, 고정 시드/일관 GUID로 테스트.

- **파일/포트 충돌**  
  → 임시 디렉터리/랜덤 포트 + [Collection]으로 병렬 억제.

- **커버리지 100%가 목표인가요?**  
  → 목표치는 팀 기준. **의미 있는 케이스** 우선, **지표는 보조 수단**.

---

## 15) 마무리 요약표

| 영역 | 핵심 |
|---|---|
| 구조 | AAA, 명명 규칙, 테스트 독립성 |
| xUnit | `[Fact]`, `[Theory]`(Inline/Member/Class/ TheoryData) |
| 비동기 | `Assert.ThrowsAsync`, `WaitAsync`, 취소 토큰 |
| 픽스처 | `IClassFixture`, `ICollectionFixture`로 비용 큰 리소스 공유 |
| 목킹 | Moq/NSubstitute, Handler 스텁, 파일/시간/HTTP 추상화 |
| 실행/필터 | `dotnet test --filter` / runner.json 병렬 제어 |
| 커버리지 | coverlet + ReportGenerator, 품질 게이트와 함께 운영 |
| CI | GitHub Actions/DevOps 등 자동화 파이프라인 연동 |

---

## 부록: 미니 치트시트

```csharp
// 동기 예외
Assert.Throws<InvalidOperationException>(() => foo.Run());

// 비동기 예외
await Assert.ThrowsAsync<InvalidOperationException>(() => foo.RunAsync());

// 근사 비교
Assert.Equal(expected, actual, precision: 5);

// 컬렉션
Assert.Contains(item, list);
Assert.Equal(expectedSeq, actualSeq);

// 출력
public class T { private readonly ITestOutputHelper _o; public T(ITestOutputHelper o){_o=o;} }

// Trait 필터
[Trait("Category","Integration")]
```