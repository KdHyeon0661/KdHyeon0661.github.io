---
layout: post
title: 이산수학 - 그래프의 표현 방법과 연결성
date: 2025-06-29 19:20:23 +0900
category: 이산수학
---
# 그래프의 표현 방법과 연결성 (Graph Representations & Connectivity)

## 표기와 전제

- 그래프 \( G=(V,E) \), 정점 수 \( n=|V| \), 간선 수 \( m=|E| \).
- 인접(이웃) 집합: \( \Gamma(v)=\{u \mid (v,u)\in E\} \).
- 시간복잡도 표기: \(O(\cdot)\).
- 방향 그래프는 별도 표기(Out/ In 리스트). 무방향은 대칭 간선으로 저장.

---

## 그래프의 표현 방법

### 인접 행렬 (Adjacency Matrix)

- \( n\times n \) 배열 \(A\)로 간선 존재 여부/가중치를 저장:
  $$
  A[i,j] =
  \begin{cases}
  1 & \text{if }(i,j)\in E \\[2pt]
  0 & \text{otherwise}
  \end{cases}
  $$
- **무방향**: 대칭 \(A=A^\top\); **자기루프**는 대각 \(A[i,i]=1\).

**장점**
- 간선 존재 확인 \(O(1)\).
- 행렬 연산(제곱, 비트셋 최적화)·플로이드–워셜 같은 **밀집 그래프**에 유리.

**단점**
- 공간 \(O(n^2)\): 희소 그래프( \(m\ll n^2\) )에서 비효율.

**예시**
```text
V={0,1,2}, E={(0,1),(1,2)} (무방향)
A =
[ [0,1,0],
  [1,0,1],
  [0,1,0] ]
```

---

### 인접 리스트 (Adjacency List)

- 각 정점에 이웃 목록을 저장(파이썬: list/set).
- **공간** \(O(n+m)\), **탐색**(DFS/BFS) \(O(n+m)\).

**장점**
- 희소 그래프에 메모리 효율적.
- 이웃 순회 \(O(\deg v)\)로 빠름.

**단점**
- 간선 존재 확인은 평균 \(O(\deg v)\) (set 사용 시 평균 \(O(1)\), 정렬리스트면 \(O(\log \deg v)\)).

**예시**
```python
graph = {
  0: [1],
  1: [0, 2],
  2: [1]
}
```

---

### 간선 리스트 (Edge List)

- 간선을 튜플로 나열: `edges=[(u,v), ...]` (가중치: `(u,v,w)`).
- **장점**: 입력/출력 단순, Kruskal(정렬+Union-Find)에 적합.
- **단점**: 이웃 순회가 비효율 → 보통 인접 리스트로 변환 후 사용.

```python
edges = [(0,1),(1,2)]
```

---

### — 대용량/수치계산·GPU 친화

- **COO**: `(row, col, val)` 1개 배열씩 — 생성 간단, 중복 허용.
- **CSR**: `indptr(n+1)`, `indices(m)`, `data(m)` — 행(정점)별 이웃 연속 저장, **BFS/SpMV**에 적합.
- **CSC**: 열 우선 — 역방향 탐색이나 In-neighbors가 중요할 때.

> 그래프-수치 하이브리드(페이지랭크, 그래프 신경망)는 CSR/CSC가 표준.

---

### 표현 선택 가이드

| 요구 | 권장 |
|---|---|
| 간선 존재 자주 확인, \(n\) 작고 밀집 | 인접 행렬 |
| 탐색·이웃 순회, 희소 | 인접 리스트 |
| Kruskal/입력 저장 | 간선 리스트 |
| 대규모/선형대수·GPU | CSR/CSC/COO |

**밀도 임계**(경험치): \( m \gtrsim \frac{n^2}{\log n} \) → 행렬이 유리; 그 밖은 리스트.

---

## 표현 간 변환 & 생성 유틸

```python
def edge_list_to_adj_list(n, edges, directed=False):
    g = {i: [] for i in range(n)}
    for u,v in edges:
        g[u].append(v)
        if not directed:
            g[v].append(u)
    return g

def adj_list_to_edge_list(g, directed=False):
    edges=set()
    for u, nbrs in g.items():
        for v in nbrs:
            if directed or u < v:
                edges.add((u,v))
    return sorted(edges)

def adj_list_to_matrix(g):
    n = len(g); A=[[0]*n for _ in range(n)]
    for u, nbrs in g.items():
        for v in nbrs:
            A[u][v]=1
    return A
```

---

## 개념

### 무방향 그래프

- **연결(connected)**: 임의 \(u,v\) 사이 경로 존재.
- **연결 요소**(component): 서로 도달 가능한 정점들의 극대 부분집합.

### 방향 그래프

- **약한 연결(weak)**: 방향 무시하면 연결.
- **강한 연결(strong)**: 모든 쌍 \( (u,v) \)에 대해 \(u\to v\)와 \(v\to u\).
- **SCC**: 강연결 성분(극대 강연결 부분그래프).
- **응축 그래프(condensation)**: SCC를 수축한 DAG.

---

## 기본 탐색: DFS/BFS

```python
from collections import deque

def bfs_levels(g, s):
    """ 무방향/방향 공용: 시작 s로부터 최단거리(비가중) """
    dist = {s:0}; parent={s:None}
    q=deque([s])
    while q:
        u=q.popleft()
        for v in g[u]:
            if v not in dist:
                dist[v]=dist[u]+1
                parent[v]=u
                q.append(v)
    return dist, parent

def dfs_stack(g, s):
    seen=set([s]); order=[]; st=[s]
    while st:
        u=st.pop(); order.append(u)
        for v in g[u]:
            if v not in seen:
                seen.add(v); st.append(v)
    return order
```

**복잡도**: \(O(n+m)\).
**주의**: 재귀 DFS는 파이썬 재귀 제한에 걸릴 수 있음 → 스택 DFS 권장.

---

## — 개수와 군집 추출

```python
def connected_components(g):
    seen=set()
    comps=[]
    for s in g:
        if s in seen: continue
        comp=[]
        # BFS로 하나의 컴포넌트 수집
        from collections import deque
        q=deque([s]); seen.add(s)
        while q:
            u=q.popleft(); comp.append(u)
            for v in g[u]:
                if v not in seen:
                    seen.add(v); q.append(v)
        comps.append(comp)
    return comps

# 예시

g = {0:[1], 1:[0,2], 2:[1], 3:[]}
print(connected_components(g))  # [[0,1,2],[3]]
```

---

## — 오프라인 연결성/동적 합치기

- **연산**: `find(x)`, `union(a,b)`
- 경로 압축 + 랭크/사이즈 병합 → **거의 상수** \( \alpha(n) \).

```python
class DSU:
    def __init__(self, n):
        self.p=list(range(n)); self.sz=[1]*n; self.cc=n
    def find(self, x):
        while x!=self.p[x]:
            self.p[x]=self.p[self.p[x]]
            x=self.p[x]
        return x
    def union(self, a, b):
        a=self.find(a); b=self.find(b)
        if a==b: return False
        if self.sz[a]<self.sz[b]: a,b=b,a
        self.p[b]=a; self.sz[a]+=self.sz[b]; self.cc-=1
        return True

def count_components_with_dsu(n, edges):
    dsu=DSU(n)
    for u,v in edges:
        dsu.union(u,v)
    return dsu.cc
```

**활용**: Kruskal MST, 오프라인로 간선 추가/삭제 시나리오, 대규모 로그 처리.

---

## 방향 그래프의 연결성 — SCC

### Kosaraju (두 번의 DFS)

1) \(G\)에서 **후행 순서**(finish order) 얻기.
2) **간선 뒤집기** \(G^\top\).
3) 1)의 역순으로 \(G^\top\) DFS → 각 DFS 트리가 **하나의 SCC**.

```python
def kosaraju_scc(g):
    n=len(g); seen=set(); order=[]
    # 1) G에서 후행 순서
    def dfs1(u):
        seen.add(u)
        for v in g[u]:
            if v not in seen: dfs1(v)
        order.append(u)
    for u in g:
        if u not in seen: dfs1(u)
    # 2) 전치 그래프
    gt={u:[] for u in g}
    for u in g:
        for v in g[u]:
            gt[v].append(u)
    # 3) 역순으로 G^T에서 DFS
    seen.clear(); comps=[]
    def dfs2(u, bucket):
        seen.add(u); bucket.append(u)
        for v in gt[u]:
            if v not in seen: dfs2(v, bucket)
    for u in reversed(order):
        if u not in seen:
            bucket=[]; dfs2(u, bucket)
            comps.append(bucket)
    return comps
```

**복잡도**: \(O(n+m)\).

---

### Tarjan (단일 DFS, 스택·lowlink)

- 방문 시각 `disc[u]`, 가장 높은 **역방향**으로 갈 수 있는 값 `low[u]`.
- DFS 트리에서 `low[u]==disc[u]`이면 `u`는 **SCC 루트** → 스택에서 팝하며 SCC 구성.

```python
def tarjan_scc(g):
    index=0; stack=[]; onstack=set()
    disc={}; low={}; comps=[]
    def dfs(u):
        nonlocal index
        disc[u]=low[u]=index; index+=1
        stack.append(u); onstack.add(u)
        for v in g[u]:
            if v not in disc:  # tree edge
                dfs(v); low[u]=min(low[u], low[v])
            elif v in onstack: # back edge
                low[u]=min(low[u], disc[v])
        if low[u]==disc[u]:  # root
            comp=[]
            while True:
                w=stack.pop(); onstack.discard(w)
                comp.append(w)
                if w==u: break
            comps.append(comp)
    for u in g:
        if u not in disc: dfs(u)
    return comps
```

---

### 만들기

```python
def scc_condensation(g):
    comps = tarjan_scc(g)
    id_of={u:i for i,comp in enumerate(comps) for u in comp}
    dag={i:set() for i in range(len(comps))}
    for u in g:
        for v in g[u]:
            a=id_of[u]; b=id_of[v]
            if a!=b: dag[a].add(b)
    dag={k:list(vs) for k,vs in dag.items()}
    return comps, dag  # dag는 DAG
```

---

## 단절점(articulation) & 브리지(bridge)

- **단절점**: 제거하면 컴포넌트 수 증가.
- **브리지**: 간선을 제거하면 컴포넌트 수 증가.

Tarjan 변형 — DFS 트리에서 `low[v] > disc[u]`면 `(u,v)`는 **브리지**.
루트는 자식 수 ≥2이면 **단절점**.

```python
def articulation_points_and_bridges(g):
    time=0; disc={}; low={}; parent={}; ap=set(); bridges=[]
    def dfs(u):
        nonlocal time
        disc[u]=low[u]=time; time+=1
        child=0
        for v in g[u]:
            if v not in disc:
                parent[v]=u; child+=1
                dfs(v)
                low[u]=min(low[u], low[v])
                if parent.get(u) is None and child>=2: ap.add(u)
                if parent.get(u) is not None and low[v]>=disc[u]: ap.add(u)
                if low[v]>disc[u]: bridges.append((u,v))
            elif v!=parent.get(u):
                low[u]=min(low[u], disc[v])
    for u in g:
        if u not in disc: parent[u]=None; dfs(u)
    return ap, bridges
```

**활용**: 네트워크 취약 링크 식별, 인프라 설계 이중화.

---

## 연결성 확인/요약 유틸

```python
def is_connected_undirected(g):
    if not g: return True
    from collections import deque
    seen=set(); s=next(iter(g)); q=deque([s]); seen.add(s)
    while q:
        u=q.popleft()
        for v in g[u]:
            if v not in seen: seen.add(v); q.append(v)
    return len(seen)==len(g)

def weakly_connected(dg):
    # 방향 무시
    ug={u:set() for u in dg}
    for u in dg:
        for v in dg[u]:
            ug[u].add(v); ug[v].add(u)
    return is_connected_undirected(ug)

def strongly_connected(dg):
    # 모든 정점이 같은 SCC?
    comps = tarjan_scc(dg)
    return len(comps)==1
```

---

## — 행렬/반복 BFS

### 플로이드–워셜(작은 \(n\), 밀집)

```python
def transitive_closure_matrix(A):
    # A: n×n 0/1 리스트(자기 도달 포함하려면 대각 1 세팅)
    n=len(A)
    R=[row[:] for row in A]
    for k in range(n):
        for i in range(n):
            if R[i][k]:
                # 비트셋이면 OR 한 줄, 여기선 루프
                for j in range(n):
                    R[i][j] = R[i][j] or R[k][j]
    return R
```

### 모든 정점에서 BFS (희소)

```python
from collections import deque

def transitive_closure_bfs(g):
    nodes=list(g); idx={u:i for i,u in enumerate(nodes)}
    n=len(nodes); R=[[0]*n for _ in range(n)]
    for s in nodes:
        si=idx[s]; q=deque([s]); seen={s}
        while q:
            u=q.popleft()
            ui=idx[u]; R[si][ui]=1
            for v in g[u]:
                if v not in seen:
                    seen.add(v); q.append(v)
    return R, nodes
```

---

## 실전 시나리오 예제

### 소셜 그래프 — 친구 네트워크 연결성

- **문제**: 유저군이 분리되어 바이럴이 약함 → 연결요소 파악 후 브리지 후보 추천.

```python
# user friendships (무방향)

edges = [(0,1),(1,2),(3,4)]
g = edge_list_to_adj_list(5, edges, directed=False)
print("연결요소:", connected_components(g))
ap, bridges = articulation_points_and_bridges(g)
print("단절점:", ap, "브리지:", bridges)
```

### 탐지

- **문제**: 마이크로서비스 A→B→C→A 순환으로 배포 정지.
- **해법**: SCC 추출 → 응축(DAG)에서 위상정렬로 배포 순서 설계.

```python
dg = {
  "A":["B"], "B":["C"], "C":["A","D"], "D":[]
}
scc = tarjan_scc(dg); print("SCC:", scc)
comps, dag = scc_condensation(dg); print("Condensed DAG:", dag)
```

### 탐지

- **문제**: 특정 도로 고장 시 도시가 분리되는지.
- **해법**: 무방향 그래프에서 브리지 찾기.

```python
roads = [(0,1),(1,2),(2,0),(1,3)]
G = edge_list_to_adj_list(4, roads, directed=False)
ap, bridges = articulation_points_and_bridges(G)
print("취약 도로(브리지):", bridges, "단절점:", ap)
```

---

## 성능·메모리 체크리스트

- **탐색**: 인접 리스트 \(O(n+m)\) 필수.
- **간선 확인** 자주: 인접 행렬(+비트셋) 고려.
- **대규모/수치**: CSR/CSC. 스파스 연산(SpMV)로 페이지랭크 등 가속.
- **SCC**: Kosaraju 또는 Tarjan \(O(n+m)\).
- **동적 연결성(오프라인)**: DSU. (온라인 fully-dynamic은 고급 주제 — ET-tree 등)
- **취약점**: 브리지/단절점 \(O(n+m)\) Tarjan 변형.
- **재귀 제한**: 파이썬은 **반복(스택)** DFS 권장.

---

## 종합 예제 — 하나로 묶어 보기

```python
def demo():
    # 1) 입력: 간선리스트 → 인접리스트
    edges = [(0,1),(1,2),(2,0),(2,3),(3,4)]
    G = edge_list_to_adj_list(5, edges, directed=False)

    # 2) 연결 요소
    comps = connected_components(G)
    print("Connected Components:", comps)

    # 3) 브리지/단절점
    ap, bridges = articulation_points_and_bridges(G)
    print("AP:", ap, "Bridges:", bridges)

    # 4) 방향 그래프로 전환해 SCC
    DG = {i:[] for i in range(5)}
    for u,v in edges:
        DG[u].append(v)           # 무방향을 편의상 양방향으로
    sccs = kosaraju_scc(DG)
    print("SCCs:", sccs)

    # 5) 트랜지티브 클로저(희소: BFS)
    R, nodes = transitive_closure_bfs(DG)
    print("Reachable from 2:", [nodes[j] for j,b in enumerate(R[nodes.index(2)]) if b])

demo()
```

---

## 자주 하는 실수 & 베스트 프랙티스

- **정점 인덱스 누락**: 고립 정점(차수 0)도 반드시 `g[v]=[]`로 포함.
- **무방향 저장**: (u,v) 추가 시 (v,u)도 추가(중복 방지 용 set 추천).
- **방향 그래프 연결성**: 강연결/약연결을 혼동하지 말 것.
- **재귀 DFS**: 큰 그래프에서 `RecursionError` → 반복 DFS로 전환.
- **메모리**: 파이썬 리스트/딕셔너리는 오버헤드 큼 → 대규모면 `array`, `numpy`, `scipy.sparse` 고려.

---

## 한 화면 요약

| 주제 | 핵심 포인트 |
|---|---|
| 표현 | 행렬(빠른 간선확인, \(O(n^2)\)), 리스트(희소·탐색 \(O(n+m)\)), 간선리스트(Kruskal) |
| 희소 포맷 | CSR/CSC/COO — 대규모·수치·GPU |
| 무방향 연결성 | 연결요소(DFS/BFS), DSU로 오프라인 처리 |
| 방향 연결성 | 약/강연결 구분, SCC는 Kosaraju/Tarjan |
| 취약 구조 | 단절점/브리지 \(O(n+m)\) Tarjan 변형 |
| 클로저 | 플로이드–워셜(작은 n), BFS 전역(희소) |
| 실전 | 소셜군집, 서비스 순환(SCC), 도로 브리지 |
