---
layout: post
title: MFC - 메시지 기반 비동기 vs 동기
date: 2025-09-06 16:25:23 +0900
category: MFC
---
# vs 동기(`SendMessage`) 비교 완전 가이드

(MFC/Win32, 재진입·교착·성능·모달 루프·크로스 스레드까지)

이 글은 Windows/MFC에서 **메시지 전달 방식** 두 축—**비동기(PostMessage)**, **동기(SendMessage)**—를
**동작 원리 → 스레드/모달 루프 영향 → 재진입/교착(Deadlock) → 성능/응답성 → 대안 API** 순으로
예제와 함께 “생략 없이” 정리합니다. 실무에서 빈번한 **버그 패턴**과 **방어 기법**을 특히 강조합니다.

> 대상: Win32/MFC (x64, Unicode), Visual C++
> 표기: “UI 스레드” = 창을 가진 스레드(메시지 펌프), “Worker” = 작업 전용 스레드(보통 펌프 없음)
> 핵심 전제: **UI는 반드시 UI 스레드에서**, 스레드 간 통신은 **메시지/동기화**로.

---

## 한 장 요약 (결론 먼저)

| 항목 | `PostMessage` (비동기) | `SendMessage` (동기) |
|---|---|---|
| 반환 시점 | **큐에 넣은 직후**(수신자가 아직 처리 전) | **수신자 WinProc 처리 완료 후** |
| 교착 위험 | **낮음** (상대가 Hang이어도 내 스레드는 안 막힘) | **높음** (수신자/모달 루프/Hung 차단 → 호출 스레드 Block) |
| 재진입 위험 | 낮음 (일반적으로 다음 펌프 사이클) | **있음** (동기 호출이 **즉시 WinProc** 실행 → 재진입) |
| 순서 보장 | 같은 대상/같은 스레드 큐에 **FIFO** (일부 시스템 메시지 우선권 예외) | 보내는 순간 **즉시** 처리—큐보다 **우선** |
| 크로스 스레드 | 가능(수신 스레드 큐에 Post) | 가능(수신 스레드에서 WinProc 실행; 호출 스레드 **대기**) |
| 크로스 프로세스 | 가능(핸들만 유효하면) | 가능(단, 보안/UIPI/훅 영향) |
| 대량 전송 성능 | **우수** (비동기 적합) | 전송·처리 시간 **합**만큼 호출자 블록 |
| 모달 대화상자 영향 | 모달 루프가 돌면서 **처리됨** | 모달 루프 **도중 재진입** 발생 가능 |
| 대표 용도 | 진행률/상태 보고, 작업 큐, 경량 명령 | 즉시 결과 필요, **WM_GETTEXT**류 쿼리, 컨트롤 동기 질의 |
| 실무 권장 | **기본값으로 Post** + **필요한 곳만 Send** | **Send는 최소화** + `SendMessageTimeout` 방어 |

> 실전 권장 패턴
> 1) **기본은 Post**. 결과가 필요하면 “요청 ID”를 넣고 **추후 응답도 Post**로.
> 2) Send가 필요하면 **짧고 재진입 안전한 핸들러**에서만 사용.
> 3) 교착 방지: `SendMessageTimeout`/`SendNotifyMessage`/`SendMessageCallback` 고려.

---

## 동작 원리: 큐/펌프/우선순위

### 1-1. `PostMessage`

- 호출 스레드는 **수신자의 스레드 메시지 큐**에 메시지를 **넣고 즉시 복귀**.
- 메시지는 수신 스레드의 **메시지 루프(Translate/Dispatch)** 사이클에서 처리.
- **Posted message**는 보통 **Sent message**(동기)보다 뒤에 처리됩니다.

```cpp
// 비동기 전송
::PostMessage(hTargetWnd, WM_APP + 1, (WPARAM)42, 0); // 곧바로 리턴
```

### 1-2. `SendMessage`

- 대상 창의 **윈도우 프로시저를 바로 호출**합니다.
  - 같은 스레드 소유 창이면 **직접 호출**(큐를 거치지 않음) → **즉시 재진입**.
  - 다른 스레드 창이면 **상대 스레드 콘텍스트에서** 처리가 끝날 때까지 **현재 스레드가 대기**.
- **Modal loop**/**Hung**/**장기 처리**가 있으면 **보낸 스레드가 멈춤**.

```cpp
// 동기 전송: WinProc가 반환할 때까지 현재 스레드 대기
LRESULT r = ::SendMessage(hTargetWnd, WM_GETTEXT, cch, (LPARAM)buf);
```

---

## MFC 관점: 메시지 맵과 라우팅 영향

MFC의 **메시지 맵**(ON_WM_XXX / ON_MESSAGE …)은 **DispatchMessage**로 들어온 메시지를 대상 멤버 함수에 연결합니다.

- `PostMessage` → **메시지 루프 → Dispatch → 메시지 맵**
- `SendMessage` → **루프를 거치지 않고 WinProc로 직접** → 메시지 맵 핸들러 실행

> **중요:** 같은 스레드에서 **SendMessage**는 **현재 호출 스택 중간**에 WinProc가 끼어드는 **재진입**을 야기.
> → 상태 플래그/락 보유 구간에서 **재귀적으로 같은 코드**가 실행되는 문제, 예외/힙 오류의 원인이 됩니다.

---

## 데모: 같은 스레드 `SendMessage`의 함정

### 3-1. 문제 코드

```cpp
// CMainDlg: OnBnClickedStart에서 리스트뷰 업데이트 중, 다시 SendMessage로 자기 자신 호출 → 재진입
void CMainDlg::OnBnClickedStart() {
    m_updating = true;                 // 상태 플래그
    m_list.DeleteAllItems();           // 많은 아이템 삭제 (내부적으로 NM_xxx 방출)

    // 나쁜 패턴: 중간 상태에서 동기 호출
    ::SendMessage(m_hWnd, WM_APP + 100, 0, 0); // 재진입 발생 지점

    m_updating = false;
}

LRESULT CMainDlg::OnAppDoSomething(WPARAM, LPARAM) {
    // 재진입 시 여기서도 m_updating == true → 내부 로직이 가정과 달라짐
    if (m_updating) {
        // 예상 못한 분기, 컨트롤 상태 모순 등
    }
    return 0;
}
```

- **분석**: 같은 스레드에서 `SendMessage`는 **즉시** WinProc → 메시지 맵 핸들러 진입.
  `m_updating`이 **true**인 중간 상태에서 코드가 **재실행**되어 **불변식 위반**.

### 3-2. 방어: `PostMessage`로 전환

```cpp
// 안전: 비동기 전송으로 현재 처리(크리티컬 섹션) 끝난 뒤 실행
::PostMessage(m_hWnd, WM_APP + 100, 0, 0);
```

> **규칙**: **상태 전이 중인 구간**(리스트 갱신/모델 변경/락 보유)에서는 **SendMessage 금지**.

---

## 시나리오: 스레드 간 Send

### 4-1. 전형적 패턴

- **UI 스레드 A**: `SendMessage`로 **Worker B** 창에 요청 → **B 스레드가 처리 중에 A로 `SendMessage` 역호출**
- A는 B의 응답을 기다리고, B는 A의 응답을 기다리는 **상호 대기** → **교착**

```cpp
// UI (A) → Worker UI Thread (B)
LRESULT res = ::SendMessage(hB, WM_APP_REQ, 0, 0); // A는 대기

// B 핸들러 안에서
LRESULT OnAppReq(...) {
    // … 처리 중 …
    ::SendMessage(hA, WM_APP_ASK, 0, 0); // B도 A 응답 대기 → 서로 대기
}
```

### 4-2. 해결 전략

1) **한 방향은 항상 Post** (A→B Send면, B→A는 Post).
2) 또는 **양방향 모두 Post** + 응답은 “완료 메시지”로.
3) Send를 써야 한다면 **`SendMessageTimeout`** 로 타임아웃 방어.

```cpp
DWORD_PTR out = 0;
BOOL ok = ::SendMessageTimeout(hB, WM_APP_REQ, 0, 0,
    SMTO_ABORTIFHUNG | SMTO_BLOCK, 3000 /*ms*/, &out);
if (!ok) {
    // B가 응답하지 않음 → 폴백 경로
}
```

---

## 결과가 필요한 경우: Send vs 비동기 응답

### 5-1. 즉시 결과가 정말 필요한가?

- `SendMessage`: 결과를 **동기 반환**. 하지만 **재진입/교착** 위험.
- 대부분의 UI 작업은 **즉시 결과가 불필요**(예: 작업 요청 → 진행률/완료 통지).

### 5-2. 비동기 질의-응답 패턴 (권장)

```cpp
// 요청자(UI): 요청 ID 할당 후 Post
struct Req { UINT id; /*payload*/ };
struct Rsp { UINT id; /*result*/ };

UINT g_nextId = 1;
::PostMessage(hWorkerWnd, WM_APP_REQ, (WPARAM)g_nextId++, (LPARAM)new Req{ id });

// Worker: 처리 후 UI로 결과 Post
::PostMessage(hUIWnd, WM_APP_RSP, (WPARAM)id, (LPARAM)new Rsp{ id, /*result*/ });

// UI: 핸들러에서 id 매칭 후 콜백/프라미스 해결
```

- 장점: **교착 회피**, **응답성 유지**, **타임아웃/취소** 구현 용이.

---

## 모달 대화상자/메시지박스와 재진입

### 6-1. Send 중 모달 진입

- `SendMessage`로 들어간 핸들러가 **MessageBox, DoModal** 같은 **모달 루프**를 열면,
  호출자 스레드는 **계속 대기** 중인데, 수신 스레드는 **다른 메시지**들(심지어 **원 발신자** 향 메시지)을 **처리**할 수 있어
  예상치 못한 **순서 역전/재진입**이 발생.

### 6-2. 방어

- **Send 핸들러 내부에서 모달 실행 금지**(필요하면 **비동기 디퍼**: 나중에 `PostMessage`로 띄우기).
- 또는 호출 측에서 **SendNotifyMessage**/`SendMessageCallback`로 **비동기화**.

```cpp
// 비동기 Send: 다른 스레드 대상일 때만 비동기로 동작(같은 스레드는 동기임에 주의)
::SendNotifyMessage(hTarget, WM_APP_DO, 0, 0); // 호출자는 즉시 반환 (cross-thread일 때)
```

> **주의:** `SendNotifyMessage` / `SendMessageCallback`은 **같은 스레드 창**에 보낼 경우 **동기처럼** 동작합니다.
> 완전한 비동기 보장은 **스레드가 다를 때**만.

---

## 메시지 정렬/우선순위/펌프

### 7-1. 우선순위 개론

- **Sent message**는 큐를 거치지 않고 즉시 처리 → Posted message보다 **먼저** 실행됨.
- `WM_PAINT` 같은 일부 메시지는 **합쳐지거나 지연**될 수 있음(시스템 최적화).
- `WM_TIMER`는 **큐에 들어오지만** 픽업 시점/빈도는 펌프 상태에 따라 변동.

### 7-2. 실무 팁

- “먼저 도착해야 하는 메시지”는 **Send**로 보장할 수 있으나,
  재진입/교착risk가 크므로 대개는 **큐 순서**(Post) + 상태 머신을 설계하세요.

---

## 크로스 스레드/프로세스 고려 사항

- **크로스 스레드 Send**: 수신 스레드가 **메시지 루프**를 돌지 않으면 **응답 없음**(Hang).
  → Worker 스레드로 Send하려면 **Worker가 메시지 루프**를 가져야 함(보통 권장하지 않음).
- **크로스 프로세스 Send/Post**: **UIPI/무결성 레벨**/ACL에 막힐 수 있음.
  → 차라리 **Named Pipe/공유 메모리 + WM_COPYDATA(신호)** 등 IPC 조합을 검토.

---

## `SendMessage`를 꼭 써야 하는 경우

- 컨트롤에서 **즉시 값 질의**(예: `WM_GETTEXT`, `LB_GETCURSEL`, `CB_GETCURSEL`)
- 컨트롤/윈도우의 **동기 설정**이 요구되는 특정 Win32 API
- 시스템이 **Send를 기대**하는 통지/계약(드묾)

> 이때도 핸들러는 **짧고 예측 가능**하게 작성.
> 긴 작업/모달/블로킹 IO 금지. 필요 시 **비동기 handoff**.

---

## API 대안 3종: Timeout/Callback/Notify

### 10-1. `SendMessageTimeout`

- 수신자가 **응답 없을 때 탈출**.

```cpp
DWORD_PTR result=0;
BOOL ok = ::SendMessageTimeout(hWnd, WM_APP_DO, 0, 0,
    SMTO_ABORTIFHUNG | SMTO_BLOCK, 2000, &result);
if (!ok) {
    // 타임아웃 처리
}
```

### 10-2. `SendMessageCallback`

- 메시지 처리 **완료 시 콜백**이 호출(수신 스레드 처리 끝난 뒤).

```cpp
void CALLBACK OnMsgDone(HWND, UINT, ULONG_PTR dwData, LRESULT lResult) {
    // 비동기 완료 보고
}
::SendMessageCallback(hWnd, WM_APP_DO, 0, 0, &OnMsgDone, 1234);
```

> **주의:** 같은 스레드 대상이면 사실상 **동기**처럼 실행될 수 있음.

### 10-3. `SendNotifyMessage`

- **다른 스레드** 대상일 때 호출자는 **즉시** 돌아옴(수신자 처리는 나중에).

```cpp
::SendNotifyMessage(hWnd, WM_APP_DO, 0, 0);
```

---

## vs UI → Worker 질의 (SendTimeout)

```cpp
// 메시지 정의
constexpr UINT WM_APP_PROGRESS = WM_APP + 1;
constexpr UINT WM_APP_QUERY    = WM_APP + 2;

// Worker: 진행률 보고는 Post
::PostMessage(hUI, WM_APP_PROGRESS, (WPARAM)percent, 0);

// UI: 빠른 질의는 SendMessageTimeout (Worker에 메시지 펌프가 있을 때만!)
DWORD_PTR answer=0;
BOOL ok = ::SendMessageTimeout(hWorkerWnd, WM_APP_QUERY, 0, 0,
    SMTO_ABORTIFHUNG | SMTO_BLOCK, 100, &answer);
if (ok) {
    // answer 사용
} else {
    // 응답 없음 → 추후 비동기 응답으로 대체
}
```

> 권장: Worker에 **메시지 펌프가 없다면** UI→Worker 질의도 **Post + 응답 Post**로.

---

## “UI 멈춤”을 부르는 반패턴 모음

1) **UI 스레드**에서 **다른 UI 스레드로 Send** + 상대가 바빠서 Hang
2) 핸들러 내부에서 **MessageBox/DoModal**(모달) + 상호 Send → 교착
3) **락 보유** 상태에서 Send → 수신자가 같은 락을 재진입 시도
4) Worker가 **펌프 없이** 대기 루프, 그런데 UI가 Worker로 Send (응답 없음)
5) 긴 작업 중 **Send flood** → 시스템 전체 응답성 저하

---

## 성능/GC/힙 안정성

- **PostMessage 폭주**는 큐를 부풀립니다 → **배압(back-pressure)** 설계:
  - 진행률은 **샘플링 간격**(예: 50ms마다 1회)
  - 큐 길이가 임계 초과 시 **최근값만 유지**(이전 값 드롭)
- Send는 호출자 시간이 길어질수록 **CPU 점유**가 찢깁니다 → **짧은 핸들러** 원칙.

---

## 실무 체크리스트 (요약)

- [ ] 기본은 **Post**, 결과도 **비동기 응답**으로 설계
- [ ] Send 필요 시 핸들러 **짧고 모달 금지**
- [ ] 교착 방지: **SendMessageTimeout** 사용/한 방향만 Send
- [ ] 같은 스레드에 Send → **재진입** 고려(상태 플래그/락 금지)
- [ ] Worker에 Send 금지(펌프 없음) → PostThreadMessage/큐
- [ ] 진행률/로그는 **샘플링**(과도한 Post 방지)
- [ ] UIPI/권한 차이로 메시지 차단 가능 → IPC(파이프/공유메모리) 고려

---

## 미니 실습: “동기 호출을 비동기로 리팩터”

### 15-1. 문제: 동기 API에 갇힌 대화상자

```cpp
// Before: 버튼 클릭 → Send로 결과 필요, 가끔 응답 멈춤
void CMainDlg::OnBnClickedQuery() {
    DWORD_PTR ans = 0;
    BOOL ok = ::SendMessageTimeout(m_hWorkerWnd, WM_APP_QUERY, 0, 0,
                                   SMTO_BLOCK, 2000, &ans);
    if (!ok) {
        AfxMessageBox(_T("Worker 응답 없음"));
        return;
    }
    m_editAns.SetWindowText(std::to_wstring(ans).c_str());
}
```

### 15-2. 해결: 요청 ID + 비동기 응답

```cpp
// 요청
void CMainDlg::OnBnClickedQuery() {
    UINT id = ++m_reqSeq;
    m_pending.insert(id);
    ::PostMessage(m_hWorkerWnd, WM_APP_QUERY, (WPARAM)id, 0);
    EnableDlgItem(IDC_BTN_QUERY, FALSE); // 중복 요청 방지
}

// Worker 처리 후 응답
::PostMessage(hUI, WM_APP_QUERY_RSP, (WPARAM)id, (LPARAM)new Answer{ id, value });

// UI 응답 처리
LRESULT CMainDlg::OnQueryRsp(WPARAM w, LPARAM l) {
    std::unique_ptr<Answer> a((Answer*)l);
    if (!m_pending.erase(a->id)) return 0; // 이미 취소/무시
    m_editAns.SetWindowText(std::to_wstring(a->value).c_str());
    EnableDlgItem(IDC_BTN_QUERY, TRUE);
    return 0;
}
```

- 이제 **Hang 없음**, 모달 루프 영향 없음, **취소/타임아웃**도 쉬움.

---

## 자주 쓰는 메시지/도우미

```cpp
// 안전한 윈도우 핸들 검사
inline bool IsWindowAlive(HWND h) { return h && ::IsWindow(h); }

// UI 쓰레드로 디퍼 (Send 금지 구간)
inline void DeferToUi(HWND h, UINT msg, WPARAM w=0, LPARAM l=0) {
    if (IsWindowAlive(h)) ::PostMessage(h, msg, w, l);
}

// Send가 필요할 때 타임아웃 방어
inline BOOL SafeSend(HWND h, UINT m, WPARAM w, LPARAM l, DWORD ms, DWORD_PTR* out) {
    return ::SendMessageTimeout(h, m, w, l, SMTO_ABORTIFHUNG | SMTO_BLOCK, ms, out);
}
```

---

## Q&A 스타일 FAQ

**Q1. 같은 스레드 내에서 `SendMessage`는 왜 위험?**
A. **현재 스택 중간**에 WinProc가 들어오며 **재진입**. 락/상태 전이 구간에서 **불변식**이 깨지기 쉬움.

**Q2. `SendNotifyMessage`면 항상 비동기?**
A. **아니요.** **다른 스레드** 창일 때만 비동기. **같은 스레드**면 동기처럼 동작.

**Q3. Worker에 `SendMessage`가 안 먹는 이유?**
A. Worker에 **메시지 펌프가 없기 때문**. → `PostThreadMessage` + Worker 루프에서 `PeekMessage`로 처리.

**Q4. 즉시 결과가 필요한 케이스?**
A. 컨트롤 값 질의, 매우 짧은 WinProc. 그래도 가능하면 **Post + 응답 Post** 구조를 검토.

**Q5. 모달 대화상자 도중 순서가 꼬여요**
A. Send로 들어간 핸들러에서 **모달**을 열어서. 모달은 **내부 메시지 루프**가 돌아 **다른 메시지들이 선처리**됨.

---

## 마무리

- **PostMessage**를 **기본 정책**으로 두면 UI 응답성·안정성을 확보할 수 있습니다.
- **SendMessage**는 “**짧고 재진입 안전한**” 핸들러에서만 제한적으로, 그리고 필요시 **Timeout/Notify/Callback** 대안과 함께 사용하세요.
- **교착/재진입**을 만드는 패턴을 초기에 차단하면, **모달/멀티스레드** 환경에서도 예측 가능한 동작을 확보할 수 있습니다.
