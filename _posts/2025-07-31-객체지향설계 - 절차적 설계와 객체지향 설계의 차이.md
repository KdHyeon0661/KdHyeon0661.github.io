---
layout: post
title: 객체지향설계 - 절차적 설계와 객체지향 설계의 차이
date: 2025-07-31 18:20:23 +0900
category: 객체지향설계
---
# 절차적 설계(Procedural Design)와 객체지향 설계(OOP)의 차이 — 상세 비교

아래는 **절차적(프로시저/함수 중심)** 설계와 **객체지향(데이터+행위 중심)** 설계의 핵심 차이, 장단점, 실무 영향, 코드 예시(은행 계좌)와 마이그레이션 팁까지 포함한 종합 안내입니다.

---

## 1. 핵심 개념 비교 (한눈에)
- **절차적 설계**: 프로그램을 *절차(함수, 루틴)*의 집합으로 보고, 데이터는 함수의 입력/출력(또는 전역 변수)으로 다룬다. 흐름 제어와 알고리즘을 중심으로 설계함.
- **객체지향 설계**: 데이터(속성)와 그 데이터를 다루는 행위(메서드)를 **객체**라는 논리 단위로 묶어 모델링한다. 캡슐화·상속·다형성 등으로 복잡성을 관리함.

---

## 2. 구조적 차이 (상세)

### 2.1 책임 배분
- 절차적: 기능(what to do) 중심. 함수가 로직을 수행하고 데이터를 받아 처리.
- OOP: 책임(who/what belongs to)을 **객체**에 배분. 객체가 스스로 상태를 유지하고 행동을 수행.

### 2.2 데이터와 함수의 결합도
- 절차적: 함수 ↔ 데이터가 **분리**되어 있음(데이터 구조 + 처리 함수). 종종 전역 데이터가 사용됨.
- OOP: 데이터와 함수가 **결합(encapsulation)** 되어 객체 내부에서만 접근 가능.

### 2.3 추상화 방식
- 절차적: 절차(함수), 모듈(파일/네임스페이스)로 추상화. 상위 수준 함수로 서브루틴을 조합.
- OOP: 클래스·인터페이스로 개념을 추상화. 상속·인터페이스·다형성으로 확장성 제공.

### 2.4 코드 재사용
- 절차적: 함수 재사용, 라이브러리 호출 방식. 공통 로직은 함수로 추출.
- OOP: 상속과 합성(composition)을 통한 재사용. 인터페이스 기반 확장으로 런타임 다형성 제공.

### 2.5 변경(유지보수) 영향
- 절차적: 데이터 구조 변경 시 관련 함수들을 광범위하게 고쳐야 할 가능성.
- OOP: 객체 경계를 잘 잡으면 내부 구현 변경이 외부로 덜 전파됨(정보 은닉).

---

## 3. 장단점 비교

### 절차적 설계
**장점**
- 개념적으로 단순하고 직관적 (특히 알고리즘 중심).
- 작은 프로그램이나 스크립트에 빠르게 적합.
- 성능 최적화(구조 단순 → 오버헤드 적음)가 쉬운 경우가 많음.

**단점**
- 큰 규모에서 코드 산만해지기 쉬움 (글로벌 상태·함수 난립).
- 응집도 낮고 결합도 높아 유지보수 곤란.
- 추상화 수준이 낮아 도메인 모델 표현에 한계.

### 객체지향 설계
**장점**
- 현실 세계 도메인 모델링에 적합 (엔티티·행위 매핑).
- 캡슐화, SRP 등 원칙 적용으로 유지보수·확장성 우수.
- 다형성으로 런타임 확장이 쉽고 테스트 용이.

**단점**
- 설계 초기에 추상화 과잉(over-abstraction) 위험.
- 작은 문제에 불필요한 복잡성 초래 가능.
- 언어/프레임워크에 따라 런타임 오버헤드가 있을 수 있음.

---

## 4. 실전 영향 (테스트·동시성·성능·팀 협업)

- **테스트성**
  - 절차적: 순수 함수 스타일이면 테스트 쉬움, 하지만 전역 상태가 있으면 어려움.
  - OOP: 의존성 주입/인터페이스 사용으로 단위 테스트에 유리(테스트 더블 사용).

- **동시성**
  - 절차적: 전역 가변 상태 사용 시 동시성 문제 유발.
  - OOP: 객체 상태가 가변이면 동시성 문제 존재. 그러나 캡슐화로 락 전략 적용이 수월하고, 불변 객체 사용 권장.

- **성능**
  - 절차적: 단순 루틴/데이터 구조로 성능 우수할 수 있음.
  - OOP: 메시지 호출·객체 생성 비용 등이 성능에 영향 줄 수 있으나, 대체로 현대 런타임에서 큰 문제X.

- **팀 협업**
  - 절차적: 기능별로 함수 나눠 작업 가능하나 도메인 경계가 불분명하면 충돌↑
  - OOP: 도메인별 모듈화(패키지/클래스)로 역할 분담이 명확해 협업에 유리

---

## 5. 코드 예시 — 은행 계좌 (간단 비교)

### 절차적 스타일 (C 스타일 / 구조체 + 함수)
```c
// C 스타일 절차적 설계
typedef struct {
    char accountId[32];
    long balanceCents;
} BankAccount;

void deposit(BankAccount *acc, long cents) {
    if (cents <= 0) return;
    acc->balanceCents += cents;
}

int withdraw(BankAccount *acc, long cents) {
    if (cents <= 0) return -1;
    if (acc->balanceCents < cents) return -1;
    acc->balanceCents -= cents;
    return 0;
}
```

### 객체지향 스타일 (Java)
```java
// Java OOP 스타일
public class BankAccount {
    private final String accountId;
    private long balanceCents;

    public BankAccount(String id, long initial) {
        this.accountId = id;
        this.balanceCents = initial;
    }

    public synchronized void deposit(long cents) {
        if (cents <= 0) throw new IllegalArgumentException();
        this.balanceCents += cents;
    }

    public synchronized void withdraw(long cents) {
        if (cents <= 0) throw new IllegalArgumentException();
        if (this.balanceCents < cents) throw new IllegalStateException("insufficient");
        this.balanceCents -= cents;
    }

    public long getBalance() { return balanceCents; }
}
```

- 절차적에서는 `withdraw(account, amount)`처럼 외부에서 계좌 데이터를 직접 전달하고 처리.
- OOP에서는 `account.withdraw(amount)`로 메시지(메서드) 호출, 상태와 행위가 결합되어 있음.

---

## 6. 언제 절차적 설계가 더 적합한가?
- 작은 유틸리티, 스크립트, 데이터 변환 파이프라인.
- 성능이 극도로 중요한 로우 레벨 시스템(임베디드, 커널 모드) — 객체 오버헤드 회피.
- 알고리즘 중심의 라이브러리(수치해석, 신호처리) — 함수 조합이 자연스러움.

## 7. 언제 객체지향 설계가 더 적합한가?
- 복잡한 도메인 모델(비즈니스 규칙이 많은 시스템).
- 대규모 애플리케이션, 여러 개발자가 작업할 때 모듈화·경계가 필요한 경우.
- 확장성(새로운 종류의 엔티티·동작을 추가) 요구가 높은 시스템.

---

## 8. 절차적 → 객체지향으로 리팩터링할 때 고려할 점 (실무 가이드)
1. **유비쿼터스 언어로 도메인 개념 도출**: 명사 → 클래스 후보, 동사 → 메서드 후보.
2. **정보 전문가 원칙(Information Expert)**: 데이터를 가장 잘 아는 곳에 책임을 옮김.
3. **묶을 책임부터 시작**: 관련 함수와 데이터를 하나의 클래스(모듈)으로 묶음.
4. **인터페이스로 경계 정의**: 외부 의존을 인터페이스로 추상화하고 구현은 교체.
5. **테스트 우선**: 기존 동작을 보장하는 단위/통합 테스트 확보 후 리팩터링.
6. **단계적 마이그레이션(Branch by Abstraction / Strangler Fig)**: 한번에 바꾸지 말고 점진적 이관.

---

## 9. 혼합(하이브리드) 접근 — 현실적 권장
- 실제 시스템은 둘을 섞어 사용: OOP 엔진 내부에서 **절차적/함수적** 스타일로 알고리즘 구현.
- 예: 서비스 계층은 OOP로 구성하되, 핵심 알고리즘이나 데이터 처리 루틴은 순수 함수형/절차적 스타일로 작성(성능·테스트성 확보).

---

## 10. 체크리스트 — 어떤 설계(절차적 / OOP)를 선택할지 판단하기
- 시스템의 **도메인 복잡성**은 높은가? → OOP 우대  
- 팀의 경험(객체지향 설계 숙련도)은 충분한가? → OOP 적용 용이  
- 성능·리소스 제약이 매우 엄격한가? → 절차적 또는 최적화된 하이브리드  
- 변경(확장) 요구가 자주 발생하는가? → OOP의 캡슐화/다형성 유리  
- 초기 개발 속도가 가장 중요한가(프로토타이핑)? → 절차적이 빠를 수 있음

---

## 11. 결론(요약)
- **절차적 설계**는 단순성·직관성·성능 면에서 장점이 있고, 작은 범위나 알고리즘 중심 작업에 적합합니다.  
- **객체지향 설계**는 복잡한 도메인을 캡슐화하고 확장성·유지보수성을 제공하는 데 강력합니다.  
- **실무에서는 두 접근을 상황에 맞게 혼용**하는 것이 가장 현실적이고 효과적입니다. 중요한 건 도구(패러다임)를 맹목적으로 따르기보다 **문제 특성·팀 역량·요구 변화**에 맞춰 적절히 선택하고, 테스트·리팩토링으로 설계를 지속 개선하는 것입니다.
