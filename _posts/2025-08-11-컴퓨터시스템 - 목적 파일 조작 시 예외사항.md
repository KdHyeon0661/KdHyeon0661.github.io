---
layout: post
title: 컴퓨터시스템 - 목적 파일 조작 시 예외사항
date: 2025-08-11 23:20:23 +0900
category: 컴퓨터시스템
---
# 목적 파일 조작 시 예외사항

## 변경 전 반드시 하는 8가지

1) **전/후 메타 비교**: `readelf -a`, `objdump -x`, `nm -D`, `patchelf --print-rpath`
2) **런타임 분해능 확인**: `LD_DEBUG=libs,bindings`(ELF), macOS `DYLD_PRINT_LIBRARIES=1`, Windows `dumpbin /dependents`
3) **보안 속성 유지**: PIE/PIC, RELRO, ASLR, CET/BTI, 코드 서명(PE/Mach-O)
4) **버전/심볼 보존**: `GNU version` 테이블, `SONAME`, 심볼 가시성
5) **unwind/초기화 보존**: `.eh_frame(_hdr)`, `.init_array/.fini_array`
6) **RPATH→RUNPATH 변화 영향**: 우선순위/secure-exec 모드
7) **빌드아이디/디버그**: NT_GNU_BUILD_ID, `.gnu_debuglink`, `.note.stapsdt`
8) **크로스/엔디안/REL vs RELA**: 대상용 binutils, 아키텍처별 관례

---

## 심볼·섹션 조작 시 예외사항

### 심볼 약화/숨김으로 ABI 깨짐

- **현상**: 공개 API를 `--localize-symbol`, `--weaken-symbol`로 내리면 동적 링커가 **Undef 심볼**을 해석 못 해 `undefined symbol`로 종료.
- **특히 취약**: 플러그인/인터포지션(함수 오버라이드) 의존 구조, `dlsym(RTLD_NEXT)` 체인.
- **검증**:
  ```bash
  nm -D libfoo.so | grep ' T my_api'         # 내보내야 할 API가 여전히 GLOBAL/DEFAULT?
  readelf -sW libfoo.so | grep 'GLOBAL.*DEFAULT.*my_api'
  ```
- **대안**: **버전 스크립트**로 내보낼 API만 명시, 나머지는 `-fvisibility=hidden`.

### 섹션 제거의 간접 피해

- 안전한 예: `.comment`, 일부 `.note`(단, 보안/특성 노트 제외).
- **치명적 제거 금지**:
  - `.eh_frame`/`.eh_frame_hdr` → C++ 예외/스택 언와인드 실패.
  - `.init_array/.fini_array` → 전역 객체 초기화/종료 누락.
  - `.ctors/.dtors`(구형) → 레거시 초기화 의존 코드 파괴.
  - `.gcc_except_table` → 예외 매칭 정보 손실.
- **실습 (의도적 실패 재현; 학습용)**:
  ```bash
  g++ -O2 a.cpp -o a
  ./a                               # 정상
  objcopy --remove-section .eh_frame --remove-section .eh_frame_hdr a a.nounwind
  ./a.nounwind                      # 스택 언와인드 실패/abort 가능
  ```

### COMDAT/SHF_MERGE/SHF_STRINGS 오염

- **COMDAT**: 중복 섹션 제거 규칙. `objcopy`로 이름 바꾸기/속성 변경 시 **중복 제거 논리**가 깨져 **중복 정의/참조 에러**.
- `SHF_MERGE|SHF_STRINGS` 상수 테이블을 임의 편집 시 **인덱스/오프셋 불일치**로 런타임 오동작.

### STB_GNU_UNIQUE, IFUNC, TLS

- **`STB_GNU_UNIQUE`**: 전역 단일 인스턴스 보장. 지역화/약화 시 의도 붕괴.
- **IFUNC**: 해상(Resolver) 기반 디스패치. `STT_GNU_IFUNC` → `STT_FUNC` 등 **잘못된 타입 변환** 시 **R_*_IRELATIVE** 적용 실패.
- **TLS**: `.tdata/.tbss` 정렬/크기/모델(TLS IE/LE) 변조 시 **스레드 로컬 파괴**.

---

## 동적 속성 변경 — RPATH/RUNPATH/SONAME/Interpreter

### RPATH vs RUNPATH 우선순위 함정

- **RPATH**: `LD_LIBRARY_PATH`보다 **우선**(glibc의 secure-exec 모드 예외 多).
- **RUNPATH**: `LD_LIBRARY_PATH`보다 **후순위**.
- **실수**: RPATH→RUNPATH로 바꾸며 의존 라이브러리 **위치가 달라져** 런타임 로딩 실패.
  ```bash
  patchelf --print-rpath app
  patchelf --set-rpath '$ORIGIN/lib' app      # RUNPATH로 쓰기
  LD_DEBUG=libs ./app                          # 어떤 경로에서 로드되는지 추적
  ```

### SONAME/NEEDED 일관성

- **SONAME**은 링킹/로딩의 **식별자**. 파일명만 바꾸고 SONAME 미갱신 시 **의존 바이너리**가 옛 SONAME을 요구.
  ```bash
  readelf -d libfoo.so | grep SONAME
  patchelf --set-soname libfoo.so.2 libfoo.so.2.0.1
  ```

### 인터프리터(동적 링커) 변경

- `PT_INTERP`(예: `/lib64/ld-linux-x86-64.so.2`) 변경은 **부팅/컨테이너 베이스 이미지**와 충돌 가능.
  공간이 부족한 ELF 헤더에서 **경로 길이가 늘면** 손상 위험.

---

## `strip`/디버그 분리의 함정

### 완전 strip로 디버깅 불능

- `--strip-all`은 GDB/perf/addr2line, eBPF uprobes의 **심볼 해석**을 불능화.
- **권장**: **분리 디버그**(`--only-keep-debug` + `--add-gnu-debuglink`) 또는 **Build-ID** 기반 배포.

```bash
# 분리 디버그 생성·부착

objcopy --only-keep-debug app app.debug
strip --strip-debug app
objcopy --add-gnu-debuglink=app.debug app
eu-readelf -n app | grep -A1 'Build ID'   # NT_GNU_BUILD_ID 확인(elfutils)
```

> **주의**: app을 **다시 수정**하면 `gnu_debuglink` CRC/Build-ID가 **불일치** → 디버깅 서버(debuginfod) 매칭 실패.

### .eh_frame_hdr 제거/손상

- 언와인더가 **빠른 검색**을 못 하고 선형 검색/실패. 특히 **ASAN/TSAN** 리포트 해석 악화.

### USDT/프로브 노트 제거

- `.note.stapsdt`(SystemTap/DTrace/USDT), `.note.gnu.build-id` 제거 → **관측/디버깅/배포 자동화** 체인 붕괴.

---

## 아카이브(.a)·LTO·thin archive

### Thin archive 함정

- `ar rcsT libx.a a.o`는 **외부 경로 참조**. 원본 삭제/이동 시 링크 실패.
- **정적 캐시/재현 빌드**에서는 **Deterministic mode**:
  ```bash
  ar -D rcs libx.a a.o b.o   # UID/GID/mtime 고정
  ranlib libx.a              # 일부 도구 체인에서 필요
  ```

### LTO/bitcode 보존

- `.o`가 **LLVM bitcode**(LTO)일 수 있다. `objcopy`로 엉뚱한 변형/strip 시 **LTO 메타** 소실 → 링크러가 최적화를 못 하거나 실패.

### --gc-sections와 COMDAT 상호작용

- `-ffunction-sections -fdata-sections` + `--gc-sections` 사용 바이너리를 post-link 단계에서 추가 조작하면 **도달성 그래프**가 바뀌어 **죽은 코드**가 되살거나 필요 코드가 제거될 수 있음.

---

## 플랫폼/아키텍처 특수 사항

### ELF (x86-64, AArch64 등)

#### (a) REL vs RELA, addend 손상

- x86-64 대부분 **RELA**(addend는 엔트리 내 포함). ARM 등 **REL**은 메모리 위치에 addend가 있음. 잘못된 변환/편집은 **재배치 계산식**을 망가뜨린다.

> PC-relative 재배치 개념식(ELF):
> $$
> \text{Result} = S + A - P
> $$
> \(S\): 심볼 주소, \(A\): addend, \(P\): 적용 위치.
> addend 손상 시 **분기/호출** 전부 오프셋 오류.

#### (b) GNU property/CET/BTI/SHSTK

- `.note.gnu.property`/`PT_GNU_PROPERTY`에는 **CET(IBT/SHSTK)**, AArch64 **BTI** 등의 **보안 특성**이 인코딩. 제거/손상 시 **런타임 보호** 비활성/충돌 가능.

#### (c) RELRO/BIND_NOW

- `-Wl,-z,relro,-z,now` 상태에서 GOT/plt를 **쓰기 금지**로 고정. `patchelf/objcopy`로 변형 시 **쓰기 접근 크래시**.

### Windows (PE/COFF)

- **코드 서명**: `editbin`/리소스 수정/섹션 편집은 **서명 무효화** → SmartScreen/WDAC 차단.
- **ASLR(동적 베이스)**: `.reloc` 제거 시 **/DYNAMICBASE 불가** → 보안 저하/로딩 실패.
- **CFG/GS/SafeSEH**: LoadConfig/IAT/SEH 테이블 변조 시 **보안 기능 비정상**.
- **Delay-Load**: `delayload` 섹션 교란으로 **지연 로딩 실패**.

### macOS (Mach-O)

- **install_name/LC_ID_DYLIB/LC_RPATH** 수정은 **코드 서명** 재필수(`codesign`).
- **Hardened Runtime**(특히 arm64e/PAC): 텍스트 변경/섹션 재배치 시 **서명/첨자** 상쇄 → 실행 차단.
- **헤더 공간**: Load Command 길이 증가가 불가하면 **툴이 실패**(확장 여유 필요).

---

## 재배치·로더 레벨 예외

### PLT/GOT/IAT 직접 변조 리스크

- **ELF**: RELRO 환경에선 **런타임 쓰기 금지**. Lazy→Eager 바인딩 혼합 시 **예측 불가**.
- **PE**: IAT, Bound Import, Delay Import의 **체계적 갱신** 미흡 시 **로드 실패**.

### PIE/ASLR 토글

- `-fpie/-pie`로 만든 실행파일을 임의 수정해 non-PIE처럼 쓰면 **ASLR 무력화**. OS 정책과 충돌.

### 인터포지션/심볼 버저닝

- `libc`/핵심 라이브러리는 **심볼 버전**(`GLIBC_2.*`)에 강하게 의존. `verdef/verneed` 손상 시 **로드러가 거부**.

---

## 라이선스·법적

- 상용/오픈소스 라이브러리는 **재배포/수정** 조건이 다르다. 심볼/섹션 편집/난독화 금지 조항, 소스 제공 의무(GPL) 등 **준수**.
- 서명 제거/우회는 **정책 위반/법 위반** 가능.

---

## 실무 체크리스트 (변경 전/후)

### 메타/보안

- [ ] **PIE/PIC/RELRO/ASLR** 상태 유지 여부 (`readelf -lW`, `checksec`)
- [ ] **GNU property**(CET/BTI) 보존 (`readelf --notes`)
- [ ] **Build-ID** 유지 (`eu-readelf -n`)
- [ ] **코드 서명** 상태(PE/Mach-O)

### 동적 링크

- [ ] `DT_NEEDED`/`SONAME`/`RUNPATH` 일관성 (`readelf -d`, `patchelf --print-rpath`)
- [ ] `LD_DEBUG=libs,bindings`/`DYLD_PRINT_LIBRARIES` 결과 정상
- [ ] 심볼 버전 테이블/가시성 (`readelf --syms --dyn-syms`)

### 언와인드/초기화

- [ ] `.eh_frame(_hdr)`/`.gcc_except_table` 존재
- [ ] `.init_array/.fini_array`/우선순위 보존
- [ ] `.note.stapsdt`, `.gnu_debuglink` 필요 시 유지

### LTO/아카이브

- [ ] LTO bitcode 보존(필요 시)
- [ ] Thin archive 외부 경로 무결성
- [ ] `ranlib` 인덱스 최신

### 재현성/CI

- [ ] ar **Deterministic** 모드/타임스탬프 고정
- [ ] 전/후 **바이너리 다이제스트**/SBOM 갱신
- [ ] 크래시/성능 회귀 미존재(스모크 테스트)

---

## 미니 실습 — 의도적 실패/복구로 배우기 (ELF)

> **주의**: 개인 테스트 환경/샌드박스에서만. 운영 바이너리 금지.

### RPATH→RUNPATH 전환 영향

```bash
gcc hello.c -Wl,-rpath,'$ORIGIN/lib' -Llib -lfoo -o app
patchelf --print-rpath app
patchelf --set-rpath '$ORIGIN/else' app       # 의존 경로 바꿈
LD_DEBUG=libs ./app                           # 로딩 실패 로그 관찰
patchelf --set-rpath '$ORIGIN/lib' app        # 복구
```

### 디버그 분리·재결합

```bash
objcopy --only-keep-debug app app.debug
strip --strip-debug app
objcopy --add-gnu-debuglink=app.debug app
eu-readelf -n app | grep Build                # Build-ID와 debuglink 확인
```

### unwind 제거로 실패 확인

```bash
g++ throw.cpp -O2 -o t
objcopy --remove-section .eh_frame --remove-section .eh_frame_hdr t t.bad
./t.bad   # 예외 처리 실패/abort 관찰
```

---

## 자주 틀리는 “작은” 것들 15선

1. `--gc-sections` 결과물을 다시 `objcopy --strip-unneeded` → **필요 섹션까지 제거**
2. `.gnu.hash`/`.hash` 테이블 불일치(도구 혼용)
3. `$ORIGIN` 인용부호/쉘 확장 실수로 **런타임 경로 무효**
4. `DT_RUNPATH`만 믿고 secure-exec 모드에서 **무시**되는 상황
5. `.symtab` 전부 제거 후 **uprobes/USDT** 사용 불가
6. `--localize-symbol __dso_handle` 등 **런타임 필수 심볼** 손상
7. `.tdata/.tbss` 정렬 축소로 **TLS 충돌**
8. **IFUNC** 심볼 타입 변경으로 `R_*_IRELATIVE` 실패
9. **REL/RELA** 혼동, addend 손실
10. **Build-ID**를 바꾸고 디버그 서버가 **예전 ID를 캐시**
11. Mach-O `LC_RPATH` 추가 시 헤더 공간 부족 → 툴 실패
12. PE의 `.reloc` 제거로 **ASLR 상실**, 보안 검사 실패
13. Delay-Load 구조 깨져서 **최초 호출 시 크래시**
14. CET/BTI **GNU property** 제거로 보호 불일치
15. `SONAME`을 바꿨지만 **의존 바이너리를 재링크**하지 않음

---

## 개념 공식/계산(요지)

### ELF PC-relative 재배치

$$
\text{Result} = S + A - P
$$
- \(S\): 대상 심볼의 실제 주소, \(A\): addend(REL은 메모리, RELA는 엔트리), \(P\): 적용 위치.
- 잘못된 `A`/섹션 이동은 **점프/콜** 전부 어긋남.

### AMAT-식으로 본 동적 로딩 지연(개념)

$$
T_{\text{start}} \approx T_{\text{mmap}} + \sum_{r \in \text{Reloc}} c_r + \sum_{f \in \text{bindings}} P_f
$$
- strip/변조로 재배치 수↑, 바인딩 실패 재시도↑ → 시작 지연/실패.

---

## 보안/정책 — 바꾸지 말아야 할 것과 바꿀 때 지켜야 할 것

- **바꾸지 말 것(운영)**: 코드 서명된 PE/Mach-O, 핵심 시스템 라이브러리의 SONAME/NEEDED, ELF GNU property, `.eh_frame(_hdr)`.
- **바꿀 때 준수**:
  - PR: 변경 사유/영향범위/롤백 플랜/검증 스크립트 첨부.
  - CI: 전/후 `readelf -a`, `nm -D`, `objdump -x`, `eu-readelf -n` 자동 비교.
  - 배포: SBOM/해시/서명 갱신, 디버그 심볼 서버(Build-ID) 반영.

---

## 문제 해결 흐름(Playbook)

1) **증상**: 실행 실패/의존 로딩 실패/예외 실패/디버깅 불가
2) **파악**: `readelf -d/-S/-l`, `LD_DEBUG=libs,bindings`, `eu-readelf -n`, `patchelf --print-rpath`
3) **보안**: PIE/RELRO/CET/BTI/ASLR/서명 상태 확인
4) **원인 유형화**: (a) 경로(RPATH/RUNPATH) (b) 심볼/버전 (c) 언와인드/초기화 (d) 재배치/IFUNC/TLS (e) 서명/정책
5) **교정**: 최소 변경(원복 우선), 정식 툴 재링크 권장
6) **검증**: 스모크+심볼/프로브/eBPF/예외 테스트
7) **회고**: CI 가드 추가(금지 섹션/속성 변경 감시)

---

## 부록 — 명령 스니펫 모음

```bash
# 전체 맵/의존/보안 속성

readelf -aW app | less
objdump -x app | less
checksec --file=app 2>/dev/null || true

# 동적 항목/경로/버전

readelf -dW app
patchelf --print-rpath app
objdump -s --section .gnu.version_r app

# 심볼/가시성/유형

readelf --dyn-syms -W app | egrep 'GLOBAL|WEAK'
nm -D app | head

# 노트/빌드아이디/보안 특성

eu-readelf -n app | sed -n '1,120p'
readelf --notes app | grep -A2 'GNU_PROPERTY'

# Mach-O

otool -l libfoo.dylib | egrep 'LC_ID_DYLIB|LC_RPATH'
codesign -dv --verbose=4 libfoo.dylib 2>&1 | sed -n '1,80p'

# Windows

dumpbin /headers app.exe | findstr /I "Dynamic base NXCompat Guard"
dumpbin /dependents app.exe
signtool verify /pa app.exe
```

---

## 결론

목적 파일 조작은 “바이트 편집”이 아니라 **링커·로더·언와인더·보안 하드닝·디버거**가 얽힌 **시스템 행위 수정**이다.
작은 실수 하나(섹션 하나 삭제, 속성 한 줄 변경)가 **즉시 크래시** 또는 **보안 기능 상실**로 이어질 수 있다.

- **원칙**: 가능하면 **재빌드/재링크**로 해결하고, 불가피한 조작은 **최소 변경·완전 검증·롤백 보장**으로.
- **도구**를 사용할 때는 **아키텍처·포맷·보안 속성**을 먼저 확인하고, 전/후를 **수치와 로그로 증명**하라.
- **운영 배포** 환경에서는 **서명/정책/하드닝**이 우선이며, 임시 조작은 반드시 **감사 가능**해야 한다.

> “작게 바꾸고 크게 검증하라.”
> 목적 파일 조작은 공학이 아니라 **운영**이다 — 철저한 체크리스트가 최고의 안전장치다.
