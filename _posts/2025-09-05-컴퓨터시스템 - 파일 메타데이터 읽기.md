---
layout: post
title: 컴퓨터시스템 - 파일 메타데이터 읽기
date: 2025-09-05 15:20:23 +0900
category: 컴퓨터시스템
---
# 파일 **메타데이터 읽기**

## 0. 큰 그림 — inode와 “메타데이터”의 사고 모델

- **메타데이터**: 파일 **내용(data)**이 아니라 파일 **속성(state)**.  
  예: **종류/권한/소유자/링크 수/크기/타임스탬프/블록 할당/장치 번호/확장 속성/레이블**.
- **저장 위치**: 유닉스 계열 대부분은 **inode**에 저장(이름은 디렉터리 엔트리; **이름↔inode**가 분리).
- **질의 API**: 경로 기반(`stat/lstat`), FD 기반(`fstat`), **디렉터리 FD 기준 상대경로**(`fstatat`), **확장 정보**(`statx`, Linux).

```
[디렉터리 엔트리: 이름] ──> [inode: 메타데이터 + 데이터 블록 포인터들]
```

---

## 1. 메타데이터 항목 — “무엇을 볼 수 있나?”

- **파일 종류**: regular / directory / symlink / chr / blk / fifo / socket
- **크기**: `st_size`(바이트), `st_blocks`(할당된 **512B 블록** 개수), `st_blksize`(I/O 힌트)
- **권한/모드**: `st_mode`(S_IFMT + rwx + **SUID/SGID/SVTX**)
- **소유자**: `st_uid`/`st_gid`
- **링크 수**: `st_nlink`(하드링크 개수)
- **타임스탬프**:
  - **`atime`**: 마지막 접근
  - **`mtime`**: 내용 수정
  - **`ctime`**: 메타데이터 변경(creation이 아님!)
  - **`btime`**: **생성 시간**(filesystem+커널이 지원하면 **`statx`**로 노출)
- **장치 번호**(특수 파일): `st_rdev`(major/minor)
- **확장 속성(xattr)**, **ACL**, **SELinux/AppArmor 컨텍스트**(별도 API로 취득)

---

## 2. 핵심 API — `stat/lstat/fstat` → `fstatat` → `statx`(Linux)

| API | 경로 기준 | 링크 처리 | 장점 | 비고 |
|---|---|---|---|---|
| `stat(path, &st)` | 절대/상대 | **따라감** | 단순 | 심링크 대상 메타데이터 |
| `lstat(path, &st)` | 절대/상대 | **따라가지 않음** | 링크 자체 | 심링크 길이/모드 등 |
| `fstat(fd, &st)` | FD | N/A | FD만 있으면 빠름/안전 | `O_PATH` FD에도 동작 |
| **`fstatat(dfd, name, &st, flags)`** | **디렉터리 FD 기준** | `AT_SYMLINK_NOFOLLOW` 등 | **TOCTTOU 완화/샌드박스** | `dirfd()+readdir()`와 궁합 |
| **`statx(dfd, name, flags, mask, &stx)`** | 위와 동일 | 위와 동일 | **정밀/선택적 필드 + `btime`** | Linux 전용(적절한 폴백 필요) |

### 2.1 `fstatat`의 대표 `flags`

| flag | 의미 |
|---|---|
| `AT_SYMLINK_NOFOLLOW` | 마지막 경로 요소 심링크 **따라가지 않음** |
| `AT_NO_AUTOMOUNT` | automount 트리거 회피 |
| `AT_EMPTY_PATH` | `name=""` 허용 → **`dfd` 자체를 stat**(Linux) |

### 2.2 `statx` 요점(현대 Linux)

- **필드 마스크**(`mask`)로 필요한 항목만 요청 → **오버헤드 감소**.
- **나노초 해상도** 타임스탬프 + **`btime`(생성 시간)**, **mount ID** 등.  
- 파일시스템/커널이 지원하는 필드만 **유효 비트**로 표시(미지원 시 0/미설정).
- 실무: **`statx` → 실패 시 `fstatat` 폴백**.

---

## 3. `struct stat` 빠르게 훑기 + 모드 비트/특수 비트

```c
struct stat {
    dev_t     st_dev;     ino_t     st_ino;     mode_t    st_mode;
    nlink_t   st_nlink;   uid_t     st_uid;     gid_t     st_gid;
    dev_t     st_rdev;    off_t     st_size;    blksize_t st_blksize;
    blkcnt_t  st_blocks;  struct timespec st_atim, st_mtim, st_ctim;
};
```

- **파일 종류**: `st_mode & S_IFMT` → `S_IFREG/S_IFDIR/S_IFLNK/...`
- **권한 비트**(하위 9비트): `rwx` × (user/group/other)
- **특수 비트**:
  - **S_ISUID(04000)**: set-user-ID
  - **S_ISGID(02000)**: set-group-ID(디렉터리에서는 새 파일의 그룹 상속)
  - **S_ISVTX(01000)**: sticky bit(디렉터리: **소유자만 삭제 가능**, 예 `/tmp`)
- **블록 단위**: `st_blocks`는 **512B 단위**, `st_blksize`는 커널이 권하는 I/O 크기 힌트

> **희소 파일**: `st_size`(논리 크기)와 `st_blocks*512`(실제 할당량)가 **크게 다를 수 있음**.

---

## 4. 타임스탬프 — 의미·정책·정밀도

- **의미**
  - `atime`: 접근(읽기/실행). mount 옵션에 따라 업데이트 정책이 다름.
  - `mtime`: **내용** 변경.
  - `ctime`: **inode 상태** 변경(권한/소유/링크 등) → creation 아님.
  - `btime`: **생성 시각**(filesystem+커널이 지원 시 `statx`로 노출).

- **정책**
  - **`noatime`**: `atime` 갱신 안 함.
  - **`relatime`**(현대 Linux 기본): **`mtime`보다 과거이거나 일정 시간 경과** 시에만 `atime` 갱신 → 성능/정합성 절충.
  - **`lazytime`**: atime/mtime/ctime 갱신을 메모리에 지연, **fsync/flush 시** 내구화.

- **정밀도**
  - `stat`는 `timespec`(ns)로 노출되는 플랫폼이 많음.  
  - **최대 정밀도**/유효성은 파일시스템·커널에 의존.

---

## 5. 링크/이름 — 하드링크와 심링크의 차이

- **하드링크**: 같은 inode를 **여러 이름**으로 연결 → `st_nlink` 증가. 모든 이름이 동등(삭제는 **이름 제거**일 뿐).  
- **심볼릭 링크**: **별도 inode**이며 **문자열 경로**를 가짐.  
  - `lstat`의 `st_size`는 **심링크가 보관하는 경로 문자열 길이**.
  - 심링크 자체의 모드/타임스탬프/소유는 링크 inode의 것.

---

## 6. 장치 파일과 장치 번호

- `S_ISCHR`/`S_ISBLK`인 경우 **`st_rdev`**에 **major/minor** 장치 번호가 담김.
- 추출 매크로: `<sys/sysmacros.h>`의 `major(st_rdev)`, `minor(st_rdev)`.

---

## 7. 희소 파일(sparse)과 `st_blocks`

- **희소 영역**(데이터 없는 구간)은 디스크에 실제 블록이 없음 → `st_size`는 크지만 `st_blocks`는 작을 수 있음.
- 바이트 환산:
  
  $$ \text{실제 할당 바이트} \approx \texttt{st\_blocks} \times 512 $$
  
- 관련 API: `lseek(..., SEEK_HOLE/SEEK_DATA)`, `fallocate`(홀 펀칭/프리할로케이션).

---

## 8. 실전 코드 ① — 안전하고 풍부한 `stat`(경로/FD/심링크 대응)

```c
// meta_basic.c : 경로 → lstat/stat, FD → fstat, 에러/타입/모드/시간 출력
#define _GNU_SOURCE
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/sysmacros.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <errno.h>

static void mode_to_str(mode_t m, char out[11]) {
    const char t = S_ISREG(m)?'-': S_ISDIR(m)?'d': S_ISLNK(m)?'l':
                   S_ISCHR(m)?'c': S_ISBLK(m)?'b': S_ISFIFO(m)?'p':
                   S_ISSOCK(m)?'s':'?';
    out[0]=t;
    const char rwx[]="rwx";
    for (int i=0;i<9;i++) out[i+1]= (m & (1<<(8-i))) ? rwx[i%3] : '-';
    if (m & S_ISUID) out[3] = (out[3]=='x')?'s':'S';
    if (m & S_ISGID) out[6] = (out[6]=='x')?'s':'S';
    if (m & S_ISVTX) out[9] = (out[9]=='x')?'t':'T';
    out[10]='\0';
}
static void print_ts(const char* tag, struct timespec ts){
    char buf[64];
    struct tm tm;
    localtime_r(&ts.tv_sec, &tm);
    strftime(buf, sizeof buf, "%F %T", &tm);
    printf("%-5s: %s.%09ld\n", tag, buf, ts.tv_nsec);
}
static int do_one_path(const char* path){
    struct stat st;
    if (lstat(path, &st) < 0) { perror("lstat"); return -1; }   // 링크 자체
    char mstr[11]; mode_to_str(st.st_mode, mstr);
    printf("[lstat] %s  ino=%ju  nlink=%ju  mode=%s  size=%jd  blocks=%ju  blksize=%jd\n",
           path, (uintmax_t)st.st_ino, (uintmax_t)st.st_nlink, mstr,
           (intmax_t)st.st_size, (uintmax_t)st.st_blocks, (intmax_t)st.st_blksize);
    print_ts("atime", st.st_atim); print_ts("mtime", st.st_mtim); print_ts("ctime", st.st_ctim);

    if (S_ISLNK(st.st_mode)) {
        if (stat(path, &st) == 0) {
            mode_to_str(st.st_mode, mstr);
            printf("[stat ] target mode=%s size=%jd\n", mstr, (intmax_t)st.st_size);
        } else perror("stat(target)");
    }
    return 0;
}
int main(int argc, char** argv){
    if (argc < 2) { fprintf(stderr,"usage: %s PATH...\n", argv[0]); return 2; }
    for (int i=1;i<argc;i++) do_one_path(argv[i]);
    return 0;
}
```

컴파일:
```bash
cc -Wall -O2 meta_basic.c -o meta_basic
```

---

## 9. 실전 코드 ② — `fstatat`(디렉터리 FD 기준, TOCTTOU 완화)

```c
// meta_at.c : dirfd + readdir → fstatat로 메타데이터 수집
#define _GNU_SOURCE
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main(int argc, char** argv){
    const char* root = (argc>1)?argv[1]:".";
    int dfd = open(root, O_RDONLY|O_DIRECTORY|O_CLOEXEC);
    if (dfd < 0) { perror("open root"); return 1; }

    DIR* dp = fdopendir(dfd);
    if (!dp) { perror("fdopendir"); close(dfd); return 1; }

    struct dirent* de;
    errno=0;
    while ((de=readdir(dp)) != NULL){
        if (!strcmp(de->d_name,".") || !strcmp(de->d_name,"..")) continue;
        struct stat st;
        if (fstatat(dfd, de->d_name, &st, AT_SYMLINK_NOFOLLOW) < 0) { perror("fstatat"); continue; }
        printf("%-32s  ino=%ju size=%jd type=%c\n",
               de->d_name, (uintmax_t)st.st_ino, (intmax_t)st.st_size,
               S_ISDIR(st.st_mode)?'d': S_ISLNK(st.st_mode)?'l': S_ISREG(st.st_mode)?'-':'?');
    }
    if (errno) perror("readdir");
    closedir(dp); // dfd도 함께 닫힘
    return 0;
}
```

포인트
- **문자열 경로 결합 없이** 부모 FD 기준으로 하위 항목 메타데이터를 읽어 **경로 레이스(TOCTTOU)**를 줄입니다.
- 심링크는 기본 **따라가지 않음**(`AT_SYMLINK_NOFOLLOW`)으로 시작하고, 필요할 때만 대상 `stat`을 별도 수행.

---

## 10. 실전 코드 ③ — `statx`로 **btime**(생성 시각) 포함 정밀 질의(Linux)

```c
// meta_statx.c : statx → 실패 시 fstatat 폴백
#define _GNU_SOURCE
#include <sys/stat.h>
#include <linux/stat.h>   // struct statx, STATX_*
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

static void pr_ts(const char* k, struct statx_timestamp t){
    printf("%-6s: %lld.%09u\n", k, (long long)t.tv_sec, t.tv_nsec);
}
int main(int argc, char** argv){
    const char* path = (argc>1)?argv[1]:".";
    struct statx stx;
    int rc = statx(AT_FDCWD, path, AT_SYMLINK_NOFOLLOW,
                   STATX_TYPE|STATX_MODE|STATX_SIZE|STATX_NLINK|
                   STATX_UID|STATX_GID|STATX_ATIME|STATX_MTIME|STATX_CTIME|STATX_BTIME,
                   &stx);
    if (rc == 0){
        printf("statx ok: size=%ju nlink=%u mode=%#o\n",
               (uintmax_t)stx.stx_size, stx.stx_nlink, stx.stx_mode & 07777);
        pr_ts("atime", stx.stx_atime);
        pr_ts("mtime", stx.stx_mtime);
        pr_ts("ctime", stx.stx_ctime);
        if (stx.stx_mask & STATX_BTIME) pr_ts("btime", stx.stx_btime);
        else puts("btime : (not supported)");
    } else {
        perror("statx");
        // 폴백 예시
        struct stat st;
        if (lstat(path, &st)==0) printf("fallback lstat size=%jd\n",(intmax_t)st.st_size);
    }
    return 0;
}
```

> 주의: 빌드 환경에 따라 `<linux/stat.h>`/`statx()` 프로토타입 제공이 다를 수 있습니다.  
> 최신 glibc/커널 헤더가 없다면 **시스템콜 직접호출** 또는 헤더 가드 처리가 필요합니다.

---

## 11. 실전 코드 ④ — **희소 파일** 탐색(`SEEK_HOLE/SEEK_DATA`) 예

```c
// sparse_dump.c : 파일의 데이터/홀 구간 나열
#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <inttypes.h>

int main(int argc, char** argv){
    if (argc!=2){ fprintf(stderr,"usage: %s FILE\n",argv[0]); return 2; }
    int fd = open(argv[1], O_RDONLY);
    if (fd<0){ perror("open"); return 1; }
    struct stat st; fstat(fd, &st);
    off_t off = 0;
    while (off < st.st_size){
        off_t data = lseek(fd, off, SEEK_DATA);
        if (data < 0) { data = st.st_size; }              // 더 이상 데이터 없음
        if (data > off) printf("HOLE  [%" PRIdMAX ", %" PRIdMAX ")\n", (intmax_t)off, (intmax_t)data);
        if (data >= st.st_size) break;
        off_t hole = lseek(fd, data, SEEK_HOLE);
        if (hole < 0) hole = st.st_size;
        printf("DATA  [%" PRIdMAX ", %" PRIdMAX ")\n", (intmax_t)data, (intmax_t)hole);
        off = hole;
    }
    close(fd);
    return 0;
}
```

---

## 12. 확장 속성(xattr)·ACL·SELinux 컨텍스트

### 12.1 xattr(확장 속성)

- 키-값 메타데이터: `user.*`, `system.*`, `security.*`, `trusted.*` 네임스페이스.
- API: `listxattr/getxattr/setxattr/removexattr` (`l*`/`f*` 변종 포함).

```c
// xattr_list.c : 확장 속성 나열
#include <sys/xattr.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv){
    const char* p = (argc>1)?argv[1]:".";
    ssize_t n = listxattr(p, NULL, 0);
    if (n < 0){ perror("listxattr"); return 1; }
    if (n == 0){ puts("(no xattr)"); return 0; }
    char* buf = (char*)malloc(n);
    listxattr(p, buf, n);
    for (ssize_t i=0;i<n;){
        printf("%s\n", &buf[i]);
        i += strlen(&buf[i]) + 1;
    }
    free(buf);
    return 0;
}
```

### 12.2 POSIX ACL

- 라이브러리 `<acl/libacl.h>`: `acl_get_file`, `acl_to_text`, `acl_free` …
- 도구: `getfacl/setfacl`.  
- **권한 판정**은 **기본 모드 + (있다면) ACL**이 결합되어 결정됨.

### 12.3 SELinux/AppArmor

- SELinux 컨텍스트는 보통 xattr **`security.selinux`**에 저장.  
- `getxattr`로 읽거나 `ls -Z`로 확인.

---

## 13. 권한·접근 판정 — 모드/UID/GID/마운트 정책

- **접근 판정**: (소유자/그룹/기타) 순으로 `rwx` 매칭.  
- Setuid/Setgid/Sticky bit의 의미를 정확히 이해(특히 디렉터리 sticky).
- **`access()` 사전검사 금지**: **TOCTTOU** 발생 → **바로 열어보고 실패로 판단**.  
  필요한 경우 `faccessat2(…, AT_EACCESS)`(Linux)처럼 **실행 유저** 기준을 명시.

---

## 14. 원격 FS(NFS/SMB)와 타임스탬프/일관성

- **NFS**: 클라이언트 캐시와 **close-to-open** 모델 → **수 ms~초 단위 차이** 가능.  
  `noac`/`actimeo=` 등 마운트 옵션에 따라 **갱신 가시화 지연**.  
  `ctime/mtime` 비교 기반 동기화 시 **여유/재시도** 전략 필요.
- **SMB**: oplock/lease에 따라 클라이언트 캐시 무효화가 지연될 수 있음.  
- **생성 시간**: 파일시스템별 지원 상이. `statx`의 `btime`은 **지원 시에만** 유효.

---

## 15. 성능·보안·정확성 체크리스트

- [ ] **디렉터리 FD + `fstatat`**로 **경로 레이스** 최소화(`AT_SYMLINK_NOFOLLOW` 기본)  
- [ ] 심링크 정보를 원하면 **반드시 `lstat`** 사용(대상은 `stat`)  
- [ ] 대형 디렉터리는 **필터 → 필요한 항목만 `stat`**(모두 `stat`하면 느림)  
- [ ] 희소 파일 용량 추정은 **`st_blocks*512`**(실제 할당), 로그는 `st_size`  
- [ ] `relatime/lazytime` 고려: atime 의존 로직은 신중히(백업/감사)  
- [ ] **`O_PATH`**로 경로 핸들만 얻고, **`fstat`/`linkat`/`renameat`** 수행(권한 최소화)  
- [ ] **`access()`로 선판단하지 말고 “바로 시도”**(에러로 분기)  
- [ ] 원격 FS는 **타임스탬프/갱신 지연** 고려(느슨한 비교, 해시/사이즈 병행)  
- [ ] `statx` 사용 시 **mask로 필요한 필드만** 요청, **폴백** 준비  
- [ ] 로케일/타임존 영향: 로그는 **UTC ISO-8601** 권장

---

## 16. 보너스 — JSON 메타데이터 덤프(간단 버전)

```c
// meta_json.c : 경로 → JSON 1줄, UTC ISO-8601 출력
#define _GNU_SOURCE
#include <sys/stat.h>
#include <time.h>
#include <stdio.h>
#include <string.h>

static void iso_utc(const struct timespec* ts, char out[64]){
    struct tm tm; gmtime_r(&ts->tv_sec, &tm);
    strftime(out, 32, "%Y-%m-%dT%H:%M:%S", &tm);
    snprintf(out+strlen(out), 32, ".%09ldZ", ts->tv_nsec);
}
int main(int argc, char** argv){
    if (argc!=2){ fprintf(stderr,"usage: %s PATH\n",argv[0]); return 2; }
    struct stat st;
    if (lstat(argv[1], &st)<0){ perror("lstat"); return 1; }
    char at[64], mt[64], ct[64];
    iso_utc(&st.st_atim, at); iso_utc(&st.st_mtim, mt); iso_utc(&st.st_ctim, ct);
    printf("{\"path\":\"%s\",\"ino\":%ju,\"mode\":%u,\"nlink\":%ju,"
           "\"uid\":%u,\"gid\":%u,\"size\":%jd,\"blocks\":%ju,"
           "\"blksize\":%jd,\"atime\":\"%s\",\"mtime\":\"%s\",\"ctime\":\"%s\"}\n",
           argv[1], (uintmax_t)st.st_ino, st.st_mode & 07777, (uintmax_t)st.st_nlink,
           st.st_uid, st.st_gid, (intmax_t)st.st_size, (uintmax_t)st.st_blocks,
           (intmax_t)st.st_blksize, at, mt, ct);
    return 0;
}
```

---

## 17. 자주 묻는 질문(FAQ)

**Q1. `ctime`은 생성 시간인가요?**  
A. **아닙니다.** inode 상태(권한/소유자/링크 등)가 바뀐 시간입니다. **생성 시각은 `btime`**이고, **`statx`**로(지원 시) 확인합니다.

**Q2. `st_blksize`는 실제 디스크 블록 크기인가요?**  
A. **아닙니다.** “최적 I/O 크기 힌트”입니다. 실제 할당 추정은 **`st_blocks*512`**.

**Q3. 심링크 목적지의 크기/시간을 보고 싶어요.**  
A. `stat(path, &st)`(링크 따라감). 링크 자체는 `lstat`.

**Q4. FD만 있는 상황에서 경로 없이 메타데이터가 필요합니다.**  
A. `fstat(fd, &st)`. 또는 Linux라면 `fstatat(fd, "", &st, AT_EMPTY_PATH)`.

**Q5. 대규모 트리 스캔에서 빠르게 메타데이터를 모으려면?**  
A. **`opendir/readdir` → `dirfd` + `fstatat`**(필요한 항목만) + 스레드풀(디렉터리 단위) + I/O 바운드 조율.

---

## 18. 마무리

- **메타데이터는 inode에** 있고, 상황에 따라 **경로/FD/디렉터리 FD** 기준으로 질의합니다.  
- **안전성**(심링크/TOCTTOU)은 **`*at` 계열**로, **정밀도/생성시간**은 **`statx`**로.  
- **희소/원격/정책(relatime/lazytime)** 같은 **현대 FS 현실**을 감안해 **판정/동기화/로그 규칙**을 설계하세요.

---
```c
/* 부록: fstatat 헬퍼 — 심링크는 기본 비추적, 필요 시 대상 stat */
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
int meta_query(int dfd, const char* name, struct stat* lst, struct stat* dst){
    if (fstatat(dfd, name, lst, AT_SYMLINK_NOFOLLOW) < 0) return -1; // 링크 자체
    if (S_ISLNK(lst->st_mode)) {
        if (dst) return fstatat(dfd, name, dst, 0); // 대상
        return 0;
    }
    if (dst) memcpy(dst, lst, sizeof *lst);
    return 0;
}
```