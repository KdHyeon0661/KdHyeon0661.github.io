---
layout: post
title: 디지털신호처리 - 샘플링률 변환을 위한 FIR 필터 구조
date: 2025-11-19 20:25:23 +0900
category: 디지털신호처리
---
# 샘플링률 변환을 위한 FIR 필터 구조 — Direct Form에서 Polyphase/다단/특수구조까지

> 목표
> - 앞 글에서 샘플링률 변환을 위한 FIR **사양/차수/계수 설계**를 했다면,
>   이번 글은 그 필터를 **어떤 구조로 구현해야 연산이 낭비되지 않는지**를 다룬다.
> - 대상: **D배 데시메이션(↓D)**, **I배 보간(↑I)**, **유리수 I/D 변환**
> - 핵심 키워드:
>   **Direct Form(나이브 구조), Polyphase(다상 구조), Noble identity(고귀한 항등),
>   Half-band/다단 구조, 선형위상 folding, 시간가변 polyphase(유리수)**
> - 모든 코드는 **GNU Octave**에서 그대로 실행 가능.

---

## 왜 “구조(structure)”가 따로 중요한가

샘플링률 변환은 원리상

```text
x[n] ──▶ (↑I) ──▶ H(z) ──▶ (↓D) ──▶ y[n]
```

으로 끝난다.
그런데 이 블록도를 **그대로** 구현하면 대개 연산이 수십~수백 배 낭비된다.

낭비의 원인은 2가지다.

1. **업샘플링(↑I)** 후의 0 삽입
   - 0에 대해 FIR 곱셈을 해도 결과는 0
   - 즉 “0과 곱하고 더하는 연산”이 불필요

2. **다운샘플링(↓D)** 후에 버려질 샘플
   - FIR가 모든 출력 샘플을 만들고
   - 그중 D-1개를 버리면
   - “버릴 계획인 샘플을 만들기 위해 연산”하는 셈

따라서 구조의 목표는 한 문장으로 요약된다.

> **“어차피 필요하지 않은 샘플에 대한 FIR 연산을 처음부터 하지 말자.”**

그 해법이 **Polyphase 구조**다.

---

## 샘플링률 변환 구조

### 데시메이션의 Direct Form

데시메이션(↓D) 원리:

1) anti-alias FIR
2) D배 다운샘플링

```text
x[n] ──▶ H(z) ──▶ u[n] ──▶ (↓D) ──▶ y[m]
```

Direct Form 계산:

$$
u[n]=\sum_{k=0}^{M}h[k]\,x[n-k]
$$

$$
y[m]=u[mD]
$$

즉, **모든 n에 대해 u[n]을 계산**한 뒤
그중 일부만 취한다.

연산량(입력 샘플 1개당):

- 곱셈: \(M+1\)
- 덧셈: \(M\)

샘플 중 **1/D만 쓰는데도** 매 샘플마다 FIR를 돌린다.
효율이 나쁘다.

---

### 보간의 Direct Form

보간(↑I) 원리:

1) I배 업샘플링(0 삽입)
2) anti-imaging FIR
3) I 이득 보상

```text
x[n] ──▶ (↑I) ──▶ v[n] ──▶ H(z) ──▶ u[n] ──▶ y[n]=Iu[n]
```

Direct Form 계산:

- 업샘플:

$$
v[n]=
\begin{cases}
x[n/I], & n=mI \\
0, & \text{else}
\end{cases}
$$

- FIR:

$$
u[n]=\sum_{k=0}^{M} h[k]\,v[n-k]
$$

여기서 \(v[\cdot]\)의 대부분이 0인데도
매 출력 샘플마다 전체 탭을 곱한다.

효율이 나쁘다.

---

### 유리수 I/D 변환의 Direct Form

유리수 변환도 동일하게

```text
x[n] ──▶ (↑I) ──▶ H(z) ──▶ (↓D) ──▶ y[n]
```

Direct Form으로 구현하면

- (↑I) 후 샘플 수가 I배 증가
- 그 상태에서 길고 빡센 FIR
- 마지막에 (↓D)

즉 연산 폭발.

따라서 **구조 최적화가 필수**다.

---

## 분해의 기본

### Polyphase 분해 정의

FIR 계수 \(h[n]\)을 I 또는 D의 위상(phase)로 재배열한다.

- D-상 분해(데시메이션용):

$$
h[n]=\sum_{r=0}^{D-1} e_r[nD+r]
$$

즉

$$
e_r[m] = h[mD+r]
$$

- I-상 분해(보간용):

$$
h[n]=\sum_{r=0}^{I-1} e_r[nI+r]
$$

즉

$$
e_r[m]=h[mI+r]
$$

**“계수들을 I(또는 D)개 서브필터로 나눠 담는 것”**이 다상 분해다.

---

### 다상 분해의 뜻

예를 들어 D=3이면 h는

```text
h[0], h[1], h[2], h[3], h[4], h[5], ...
```

를

- e0: h[0], h[3], h[6], ...
- e1: h[1], h[4], h[7], ...
- e2: h[2], h[5], h[8], ...

처럼 **3갈래로 찢는다.**

이제 FIR를 한 번에 길게 돌리는 대신
**짧은 FIR 3개를 필요한 타이밍에만** 돌린다.

---

## D배 데시메이션을 위한 FIR 구조

### Polyphase 데시메이터의 수식 유도

Direct Form 출력:

$$
y[m]=u[mD]=\sum_{k=0}^{M} h[k]\,x[mD-k]
$$

지금 \(k\)를 D로 나눠

$$
k = r + D\ell,\quad r=0,\dots,D-1
$$

로 분해하면

$$
y[m]=\sum_{r=0}^{D-1}\sum_{\ell} h[r+D\ell] \, x[mD-(r+D\ell)]
$$

정의 \(e_r[\ell]=h[r+D\ell]\)을 쓰면

$$
y[m]=\sum_{r=0}^{D-1}\sum_{\ell} e_r[\ell]\; x[(m-\ell)D-r]
$$

여기서 \(x[(m-\ell)D-r]\)는
입력을 D배로 **미리 다운샘플한 시퀀스들의 조합**이다.

결론:

> 데시메이션에서는 **D개의 polyphase 서브필터를 느린 속도로만 계산**하면 된다.

---

### 구조 블록도(텍스트)

```text
          ┌─ e0(z) ─┐
x[n] ─▶(↓D, r=0)──▶(FIR)─┐
          ├─ e1(z) ─┤    │
x[n] ─▶(↓D, r=1)──▶(FIR)─┼─▶ (+) ─▶ y[m]
          ├─ ...    ┤    │
x[n] ─▶(↓D, r=D-1)▶(FIR)─┘
```

- 입력을 **D개의 서브시퀀스**로 분리(“커뮤테이터”)
- 각 서브시퀀스를 **느린 속도**에서 FIR 처리
- 결과를 합산

---

### Noble identity(데시메이션 버전)

데시메이션 블록과 FIR의 위치를 바꿔
**빠른 FIR을 느린 FIR로 바꿀 수 있음**:

```text
H(z) ─▶ (↓D)  ≡  (↓D) ─▶ H(z^D)
```

즉,

- 원래 속도 Fs에서 H(z)를 돌리는 대신
- Fs/D 속도에서 H(z^D)를 돌린다

Polyphase 구조는 이 항등을 **실제로 구현한 형태**다.

---

### Octave 예제: Direct Form vs Polyphase 동치 검증

```octave
pkg load signal; clear; close all; clc;

Fs = 48000; D = 4;

% anti-alias FIR (간단 Kaiser)
Wp = 0.17; Ws = 0.25; Rp = 0.01; As = 80;
[M,Wn,beta,ftype] = kaiserord([Wp Ws],[1 0],[Rp 10^(-As/20)]);
M = M + rem(M,2);
h = fir1(M, Wn, kaiser(M+1,beta));

% test input
t = 0:1/Fs:0.02-1/Fs;
x = sin(2*pi*2000*t) + 0.6*sin(2*pi*6000*t);

% (A) Direct form decimation
uA = filter(h,1,x);
yA = uA(1:D:end);

% (B) Polyphase decimation
% D-phase decomposition
E = cell(1,D);
for r=1:D
  E{r} = h(r:D:end);   % e_r
end

% split input into D subsequences
Xsub = cell(1,D);
for r=1:D
  Xsub{r} = x(r:D:end);
end

% filter each subsequence
Ysub = cell(1,D);
for r=1:D
  Ysub{r} = filter(E{r},1,Xsub{r});
end

% sum
len = min(cellfun(@length,Ysub));
yB = zeros(1,len);
for r=1:D
  yB += Ysub{r}(1:len);
end

fprintf("max |yA - yB| = %.3e\n", max(abs(yA(1:len)-yB)));
```

출력의 최대 오차가 거의 0이면
Polyphase 데시메이터 구조가 Direct Form과 동일함이 확인된다.

---

## I배 보간을 위한 FIR 구조

### Polyphase 보간기의 수식 유도

보간 Direct Form:

$$
u[n]=\sum_{k=0}^{M} h[k]\; v[n-k]
$$

v는 0 삽입 시퀀스.
즉 v가 0이 아닌 위치는 \(n=mI\) 뿐.

따라서 u의 출력에서 실제로 기여하는 항은

$$
u[mI+r]=\sum_{k=0}^{M} h[k]\; v[mI+r-k]
$$

여기서 \(mI+r-k\)가 I의 배수일 때만 v가 0이 아니므로
\(k=r+I\ell\)만 남는다.

그러면

$$
u[mI+r]=\sum_{\ell} h[r+I\ell]\; x[m-\ell]
$$

정의 \(e_r[\ell]=h[r+I\ell]\)을 쓰면

$$
u[mI+r]=\sum_{\ell}e_r[\ell]\;x[m-\ell]
$$

즉,

> 보간에서는 **I개의 polyphase 서브필터 중 하나만 골라 돌리면**
> 각 출력 샘플이 만들어진다.

---

### 구조 블록도(텍스트)

```text
x[m] ──▶ 커뮤테이터(회전)
          ├─▶ e0(z) ─┐
          ├─▶ e1(z) ─┼─▶ 출력이 mI+1일 때
          ├─▶ ...    ┤
          └─▶ eI-1(z)┘

각 출력 시점마다
- 커뮤테이터가 다음 위상 필터를 선택
- 그 필터 출력이 곧 y[n]
```

---

### Noble identity(보간 버전)

```text
(↑I) ─▶ H(z)  ≡  H(z^I) ─▶ (↑I)
```

즉,

- 0 삽입된 고속 신호를 필터링하는 대신
- 저속에서 H(z^I)를 필터링하고
- 결과를 I배로 펼친다

Polyphase 보간기는 이 항등을 구현한 구조다.

---

### Octave 예제: Polyphase 보간기 구현

```octave
pkg load signal; clear; close all; clc;

Fs = 12000; I = 3;

% anti-imaging FIR
Wp = 0.30; Ws = 1/I; Rp = 0.01; As = 70;
[M,Wn,beta,ftype] = kaiserord([Wp Ws],[1 0],[Rp 10^(-As/20)]);
M = M + rem(M,2);
h = fir1(M, Wn, kaiser(M+1,beta));

% polyphase decomposition (I-phase)
E = cell(1,I);
for r=1:I
  E{r} = h(r:I:end);
end

% input
t = 0:1/Fs:0.02-1/Fs;
x = sin(2*pi*1000*t) + 0.5*sin(2*pi*3500*t);

% polyphase interpolation
% 출력은 길이가 I배
y = zeros(1, length(x)*I);
state = cell(1,I);
for r=1:I
  state{r} = zeros(1, length(E{r})-1);
end

for m=1:length(x)
  for r=1:I
    [yr, state{r}] = filter(E{r}, 1, x(m), state{r});
    y((m-1)*I + r) = I*yr;   % gain compensation
  end
end

% direct-form interpolation for check
v = zeros(1,length(x)*I); v(1:I:end)=x;
y_dir = I*filter(h,1,v);

fprintf("max |y - y_dir| = %.3e\n", max(abs(y - y_dir)));
```

polyphase 출력과 direct 출력이 일치한다.

---

## 유리수 I/D 변환을 위한 FIR 구조(시간가변 Polyphase)

### 기본 구조

```text
x[n] ─▶ (↑I) ─▶ H(z) ─▶ (↓D) ─▶ y[n]
```

여기서 polyphase의 핵심은

- ↑I에 대해 **I-phase**로 h를 쪼갰을 때
- ↓D가 매번 어떤 위상을 선택하는지가 **시간에 따라 변한다**는 점이다.

즉, 유리수 변환은
**“I개의 polyphase 서브필터를 회전하며 선택하는 시간가변 FIR”**로 구현된다.

---

### 선택 규칙

출력 샘플 k번째가 생성될 때
입력에서 참조되는 위치는

$$
t_k = \frac{kD}{I}
$$

여기서 정수 부분은 입력 인덱스,
소수 부분은 polyphase 위상에 해당한다.

위상 인덱스는

$$
p_k = (kD)\bmod I
$$

즉

- 출력이 한 샘플 증가할 때마다
- phase가 D씩 증가(mod I)

---

### 시간가변 polyphase 수식

I-phase 분해 \(e_r[\ell]=h[r+I\ell]\)일 때
k번째 출력은

$$
y[k] = \sum_{\ell} e_{p_k}[\ell]\; x[n_k-\ell]
$$

여기서

$$
n_k = \left\lfloor \frac{kD}{I}\right\rfloor
$$

즉,

> **매 출력마다 “다른 위상 필터”를 선택해서**
> 입력의 정수 위치 근처를 FIR로 보간한 값이 출력.

이게 현대 SRC(resampler)의 표준 구조다.

---

### 구조 블록도(텍스트)

```text
I개의 polyphase FIR bank: e0, e1, ..., eI-1

입력 x[m]은 느린 속도로 흘러가고,
출력 y[k]를 만들 때마다

phase p_k = (p_{k-1} + D) mod I

에 해당하는 e_{p_k}만 호출한다.
```

---

### Octave 예제: 유리수 polyphase SRC 직접 구현

```octave
pkg load signal; clear; close all; clc;

Fs = 44100;
I  = 5;
D  = 3;

% anti-alias/anti-imaging FIR (교육용으로 짧게)
Wcmax = min(1/I,1/D);
Wp = 0.9*Wcmax; Ws = Wcmax; Rp = 0.01; As = 80;
[M,Wn,beta,ftype] = kaiserord([Wp Ws],[1 0],[Rp 10^(-As/20)]);
M = M + rem(M,2);
h = fir1(M, Wn, kaiser(M+1,beta));

% I-phase decomposition
E = cell(1,I);
for r=1:I
  E{r} = h(r:I:end);
end

% input
t = 0:1/Fs:0.05-1/Fs;
x = sin(2*pi*1000*t) + 0.4*sin(2*pi*7000*t);

% polyphase SRC
p = 0;          % phase
n_in = 1;       % input index (1-based)
buf = zeros(1, max(cellfun(@length,E)));  % simple delay line for x
y = [];

for k=1:ceil(length(x)*I/D)
  % phase update
  p = mod(p + D, I);
  phase_idx = p + 1;  % 1..I

  % required input integer position
  % advance input when phase wraps "past" I
  % 가장 단순한 방식: kD/I의 floor를 직접 계산
  n_req = floor((k-1)*D/I) + 1;  % 1-based

  while n_in <= n_req && n_in <= length(x)
    buf = [x(n_in), buf(1:end-1)];
    n_in += 1;
  end

  e = E{phase_idx};

  % convolution with phase filter
  L = length(e);
  yk = sum(e .* buf(1:L));
  y(end+1) = I * yk;  % gain compensation
end

% compare with resample()
y_ref = resample(x, I, D, h);

len = min(length(y), length(y_ref));
fprintf("max |y - y_ref| = %.3e\n", max(abs(y(1:len)-y_ref(1:len))));
```

이 코드는 구조적 원리를 보여주기 위해
가장 직관적인 delay-line 방식으로 구현했다.
실무는 위상을 훨씬 효율적으로 관리한다.

---

## 샘플링률 변환 FIR 구조의 고급 최적화들

### 선형 위상 + Polyphase Folding(대칭 이용)

FIR가 선형 위상이면

$$
h[k]=h[M-k]
$$

이 대칭을 polyphase 내부에서도 이용할 수 있다.

- Direct Form에서 곱셈기 절반으로 줄이는 “folding”과 동일한 원리
- 각 polyphase 서브필터도 대칭을 가지는 경우가 많음

결과:

> polyphase 구조 + 선형 위상 대칭을 결합하면
> 곱셈기 수가 추가로 약 2배 감소.

---

### Half-band Polyphase(2배 변환에 특화)

2배 보간/2배 데시메이션에서 half-band FIR을 쓰면

- 계수의 절반이 0
- polyphase에서 한 위상 필터가 사실상 **거의 0 필터**가 됨

즉,

```text
연산량이 다시 절반 수준으로 감소
```

실전 2× 멀티스테이지 변환의 핵심 부품.

---

### 다단 Polyphase(대형 비율에서 필수)

큰 I/D에서 단일 FIR은 너무 길어짐.

따라서

$$
\frac{I}{D}=\prod_k \frac{I_k}{D_k}
$$

로 분해한 뒤
각 단계마다 polyphase 필터를 둔다.

장점:

- 전이대역이 완화되어 탭 수 감소
- polyphase 뱅크의 위상 수 감소
- 총 연산량이 대폭 감소

---

### FFT 기반 블록 FIR(초장필터 SRC)

오디오 표준 변환(44.1↔48k)처럼
통과대역이 넓고 stopband가 매우 깊은 경우
탭 수가 수천~수만일 수 있다.

이때는

- polyphase가 있어도 각 위상이 너무 길어
- FFT overlap-save/overlap-add로 블록 컨볼루션을 수행한다.

구조는 FIR 필터 구조의 “계산 방식” 최적화이고,
polyphase와 함께 쓰일 수 있다.

---

## 구조 선택 가이드(요약)

| 상황 | 권장 구조 |
|---|---|
| D가 작고 단순 데시메이션 | D-phase polyphase decimator |
| I가 작고 단순 보간 | I-phase polyphase interpolator |
| I/D 유리수 변환 | 시간가변 polyphase SRC(phase accumulator) |
| 2배 변환 반복 | half-band polyphase + 다단 |
| 매우 큰 비율 | 다단 polyphase |
| 초장 FIR 필요 | polyphase + FFT 블록 FIR |

---

## 전체 정리

1. **Direct Form 구조는 개념적으로만 쓰고 실제 구현은 비효율적이다.**

2. 데시메이션에서는
   $$y[m]=\sum_r e_r * x_r$$
   형태의 **D-phase polyphase decimator**를 써서
   **버릴 샘플에 대한 연산을 제거**한다.

3. 보간에서는
   $$u[mI+r]=\sum_\ell e_r[\ell]x[m-\ell]$$
   형태의 **I-phase polyphase interpolator**로
   **0에 대한 연산을 제거**한다.

4. 유리수 I/D 변환은
   $$p_k=(kD)\bmod I$$
   위상 선택 규칙에 따라
   **polyphase bank를 시간가변으로 호출**하는 구조가 표준이다.

5. 선형 위상 대칭, half-band 특수구조, 다단 분해, FFT 블록 FIR을 조합하면
   **실무용 SRC의 연산량을 현실적으로 만들 수 있다.**

이제 FIR 계수 설계와 구조 설계를 모두 이해했으니
다음 단계에서는

- 다단 고급 분해 전략
- half-band/콤프(Compensation) 설계
- 고정소수점에서 polyphase 상태/스케일링 관리
- 실시간 스트리밍 SRC 최적화(지연, 버퍼, 블록)

같은 실전 운영 이슈로 자연스럽게 넘어갈 수 있다.
