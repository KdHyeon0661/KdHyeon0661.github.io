---
layout: post
title: 논리회로설계 - 상태표 간략화 · 상태할당 (3)
date: 2025-09-08 22:25:23 +0900
category: 논리회로설계
---
# 상태표 간략화·상태할당 — **등가 상태할당**, **상태할당 가이드라인**, **원-핫(one-hot) 상태할당**(예제 포함)

> 표기: 입력 \(x\), 상태 \(S\in\{S_0,\dots,S_{N-1}\}\), 상태코드(상태벡터) \(\mathbf{Q}=(Q_{m-1}\dots Q_0)\), 다음상태 \(\mathbf{Q}^+\), 출력 \(y\).  
> 모델: **클럭형 순서회로**(Mealy/Moore). 수학은 **MathJax**, 코드·파형은 ```로 표기.

---

## 0. 배경 정리 — “상태 최소화” vs “상태할당”

- **상태 최소화**: 등가(동치) 상태 병합으로 **상태 수 자체**를 줄이는 단계(함의 차트/분할정련).  
- **상태할당(State Assignment)**: 최소화로 얻은 상태 집합에 **비트 코드**를 배정하는 단계. 다음상태/출력 로직의 **게이트 수·지연·해저드**를 크게 좌우.

> 실무 순서: **도달성 정리 → 최소화(등가 병합) → 상태할당 → FF 입력식 유도 → 합성/검증**.

---

## 1. 등가 상태할당 (Equivalent State Assignment)

### 1.1 정의와 직관
- **행동 등가**: 서로 다른 코드 배정 \(\mathcal{A}_1,\mathcal{A}_2\)가 **동일 상태표(전이·출력)** 를 구현하면 출력열이 동일 → 동작 등가.  
- **코스트(비용) 등가**: K-맵 최소 커버 관점에서 **항 수·리터럴 수**(또는 표준 셀 수/지연)가 실질적으로 동일.

### 1.2 비용을 보존하는 대표 변환(이진 인코딩)
아래 **축 대칭 변환**은 K-맵에서 **최소 커버 크기**를 보존하는 경우가 대부분이다.
\[
\boxed{
\text{(a) 상태 비트 치환 } Q_i\leftrightarrow Q_j,\quad
\text{(b) 상태 비트 보수 } Q_i\mapsto\overline{Q_i},\quad
\text{(c) 상태 라벨 치환 } S_u\leftrightarrow S_v
}
\]

| 변환 | K-맵 관점 | 기대 효과 |
|---|---|---|
| 비트 치환 | 축 교환 | 묶음(그룹) 구조 보존 |
| 비트 보수 | 축 반전 | 묶음 구조 보존 |
| 라벨 치환 | 셀 재배치 | 동일 패턴 재현 |

#### 수학적 정리(요지): **GF(2) 선형·아핀 변환의 불변성**
상태코드 \(\mathbf{Q}\in\mathbb{F}_2^m\)에 대해,  
\[
\mathbf{Q}' = M\mathbf{Q} \oplus \mathbf{b},\quad M\in GL(m,\mathbb{F}_2),\ \mathbf{b}\in\mathbb{F}_2^m
\]
은 K-맵의 **격자 재정렬(치환/반전)** 에 해당. 이때 **최소 커버의 크기**(SOP 항 수, 리터럴 수)는 보통 불변.  
> 단, 실제 셀 라이브러리·팬인 한계·물리배선 제약에 따라 미세 차이는 날 수 있다.

### 1.3 비(非)등가가 되는 전형적 경우
- **인접성 붕괴**: 잦은 전이가 K-맵상 서로 **멀어지면** 큰 묶음이 깨져 항 수 증가.  
- **플랫폼 효과**: FPGA LUT/캐리체인 vs ASIC AOI/OAI 셀 가용성 차이.  
- **물리 제약**: 팬인 제한·배선拥堵로 인수화/분해 필요 → 비용 차이 발생.

---

## 2. 상태할당 가이드라인(체계적 절차)

### 2.1 절차(체크리스트)
1. **최소화 선행**: 도달성·등가 병합 완료.  
2. **전이 인접 그래프** 작성: 노드=상태, 간선 가중치=전이 빈도/중요도.  
3. **출력 지향(Moore)**: 출력 비트를 **상태코드 비트로 내장** 가능 여부 평가.  
4. **인접성 보존 배정**: 가중치 큰 간선 쌍을 **해밍거리 1**로(그레이-ish).  
5. **플랫폼 고려**: FPGA=원-핫/부분 원-핫, ASIC=이진/그레이.  
6. **해저드·EMI**: Mealy 출력 글리치 방지 위해 **단일비트 전이** 선호.  
7. **검증/선정**: 후보 배정별 **리터럴 수/셀 수/f\_max/전력** 비교.

### 2.2 출력 지향(특히 Moore)
Moore 출력이 상태만의 함수라면, **상태코드 비트에 출력 자체를 매핑**:
\[
\boxed{\text{“출력 비트를 상태코드에 내장 → 출력 조합로직 제거”}}
\]
복수 출력도 동일 원리로 일부 또는 전부 제거 가능.

### 2.3 인접성 지향(Huffman 스타일)
- **주 순환 루프**를 **그레이 코드**로 두르면 \(Q^+\)가 단순화.  
- 희귀 분기보다 **빈번 전이**를 우선 해밍 1로.

---

## 3. 예제 1 — 4상태 Moore FSM: **이진 vs 그레이 vs 등가 변환**

### 3.1 명세
상태: \(A,B,C,D\); 입력 \(x\in\{0,1\}\).  
전이:
- \(A\xrightarrow{x=0}B,\ A\xrightarrow{x=1}C\)
- \(B\xrightarrow{0/1}C\)
- \(C\xrightarrow{x=0}D,\ C\xrightarrow{x=1}A\)
- \(D\xrightarrow{0/1}A\)  
출력: \(y(A)=0,y(B)=0,y(C)=1,y(D)=1\).

### 3.2 세 가지 배정안
1) **이진**: \(A=00,B=01,C=10,D=11\)  
2) **그레이**: \(A=00,B=01,C=11,D=10\)  (사이클 \(A\!\to\!B\!\to\!C\!\to\!D\!\to\!A\) 해밍 1)  
3) **등가 변환**: (2)에서 \(Q_1\) 반전 → \(A=10,B=11,C=01,D=00\)

| 전이 | 해밍(1) | 해밍(2) |
|---|---:|---:|
| A↔B | 1 | 1 |
| A↔C | 2 | 1 |
| C↔D | 1 | 1 |
| D↔A | 1 | 1 |

- (1)에서는 \(A↔C\)가 해밍 2 → \(Q^+\) 묶음 불리.  
- (2)(3)는 **축 반전/치환** 관계로 **코스트 등가** 기대.

### 3.3 \(Q^+\) 식 스케치(그레이의 단순화 경향)
- 그레이 배정에선 종종
\[
Q_0^+ \approx f_0(Q_0,x),\quad Q_1^+ \approx f_1(Q_1,x)
\]
처럼 **분리 가능**(팬인↓). 이진 배정은 **교차항**이 늘어날 수 있음.

---

## 4. 원-핫(one-hot) 상태할당 — 원리·장단·패턴

### 4.1 원리
상태 수 \(N\) → FF도 \(N\). 단 **1비트만 1**. 다음상태식:
\[
\boxed{
S_j^+ = \bigvee_{(i,x):\,\delta(S_i,x)=S_j}\!\left(S_i\land \chi_x\right)
}
\]
여기서 \(\chi_x\)는 입력 판별(예: \(x\) 또는 \(\overline{x}\)).

### 4.2 장단점 요약

| 항목 | 원-핫 | 이진/그레이 |
|---|---|---|
| FF 개수 | 큼(\(N\)) | 작음(\(\lceil\log_2N\rceil\)) |
| 조합식 복잡도 | 아주 단순(팬인 2~3) | K-맵 최소화 필요 |
| 속도(FPGA) | 유리(LUT 친화) | 중간 |
| 면적/전력(ASIC) | 불리(클록 부하↑) | 유리 |
| 디버깅 | 직관적 | 상대적으로 어려움 |
| SEU/불법코드 복구 | 옵션·코딩으로 보완 | 일반적 |

---

## 5. 예제 2 — **원-핫**으로 `1011` Mealy 검출기(중첩 허용)

### 5.1 상태 정의
\(S_0=\epsilon,\ S_1=1,\ S_2=10,\ S_3=101\). 입력 \(x\).

### 5.2 전이/출력(요약)
- \(S_0: 0\to S_0,\ 1\to S_1\)  
- \(S_1: 0\to S_2,\ 1\to S_1\)  
- \(S_2: 0\to S_0,\ 1\to S_3\)  
- \(S_3: 0\to S_2,\ 1\to S_1\) (이때 **Mealy 출력 \(y=1\)**)

### 5.3 다음상태식·출력
\[
\begin{aligned}
S_0^+ &= (S_0\land\overline{x}) \;\vee\; (S_2\land\overline{x})\\
S_1^+ &= (S_0\land x)\ \vee\ (S_1\land x)\ \vee\ (S_3\land x)\\
S_2^+ &= (S_1\land\overline{x}) \;\vee\; (S_3\land\overline{x})\\
S_3^+ &= (S_2\land x)\\
y     &= S_3\land x\quad(\text{글리치 방지를 위해 1클럭 등록 권장})
\end{aligned}
\]

### 5.4 VHDL 스니펫
```vhdl
-- one-hot FSM for 1011 (Mealy overlap), registered y
library ieee; use ieee.std_logic_1164.all;
entity det_1011_oh is
  port (clk,rst,x: in std_logic; y: out std_logic);
end;
architecture rtl of det_1011_oh is
  signal S0,S1,S2,S3, y_i : std_logic := '0';
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        S0<='1'; S1<='0'; S2<='0'; S3<='0'; y_i<='0';
      else
        S0 <= (S0 and not x) or (S2 and not x);
        S1 <= (S0 and x) or (S1 and x) or (S3 and x);
        S2 <= (S1 and not x) or (S3 and not x);
        S3 <= (S2 and x);
        y_i<= (S3 and x); -- register Mealy output
      end if;
    end if;
  end process;
  y <= y_i;
end;
```

### 5.5 Safe FSM 코딩 팁
- 합성 옵션 “safe state machine” or
```vhdl
when others => S0<='1'; S1<='0'; S2<='0'; S3<='0';
```
- **CDC 입력 2단 동기화**, **비동기 리셋의 동기 해제** 준수.

---

## 6. 예제 3 — **동일 FSM**을 이진 배정으로: FF 입력식 유도

동일 `1011` Mealy를 2비트 이진 상태로 가정(예: \(S_0=00,S_1=01,S_2=10,S_3=11\)).  
상태표에서 \(Q_1^+(Q_1,Q_0,x)\), \(Q_0^+(Q_1,Q_0,x)\)을 K-맵으로 최소화:
\[
\boxed{
\begin{aligned}
D_1 &= Q_1^+ = f_1(Q_1,Q_0,x)\\
D_0 &= Q_0^+ = f_0(Q_1,Q_0,x)
\end{aligned}}
\]
그 후 FF 타입별 공식 적용:
\[
T_i = Q_i\oplus Q_i^+,\quad
J_i=\overline{Q_i}Q_i^+,\quad
K_i=Q_i\overline{Q_i^+}
\]
> 일반적으로 원-핫보다 **항 수가 증가**(팬인↑)하지만 FF는 절약.

---

## 7. 예제 4 — **등가 상태할당**의 실제(축 반전/교환)

그레이 배정 (예: §3.2 (2))에서 \(Q_1\mapsto\overline{Q_1}\) 하면 새 배정(§3.2 (3)).

### 7.1 왜 비용(거의) 동일?
- K-맵 상 **축 반전**은 **사각형 묶음 크기**를 바꾸지 않는다.  
- 결과적으로 SOP 최소 항·리터럴 수가 **동일 수준** → 셀 수/지연도 근사.

### 7.2 실무 활용
- 하나의 “좋은 배정”을 얻으면, **축 교환/반전**으로 다수 후보 생성 → **배치·배선/타이밍 여유**를 도와준다.

---

## 8. 상태할당 ↔ FF 입력식: 공식 모음과 미니 워크플로

### 8.1 공식 모음
\[
\boxed{
\begin{aligned}
&\text{D-FF: } D_i = Q_i^+ \\
&\text{T-FF: } T_i = Q_i \oplus Q_i^+ \\
&\text{JK-FF: } J_i = \overline{Q_i}\,Q_i^+,\quad K_i = Q_i\,\overline{Q_i^+} \\
&\text{SR-FF: } S_i = \overline{Q_i}\,Q_i^+,\quad R_i = Q_i\,\overline{Q_i^+}
\end{aligned}}
\]

### 8.2 워크플로
1) 상태할당(이진/그레이/원-핫) 결정.  
2) 상태표에서 \(Q_i^+\)를 K-맵으로 최소화.  
3) 위 공식을 적용해 \(D/T/JK/SR\) 입력식을 산출.  
4) **불법 상태 코드**는 don’t-care로 최소화하되, **others→IDLE**로 Self-start 보장.

---

## 9. 구현 스니펫 — 명시적 인코딩과 등가 검증

### 9.1 VHDL: 명시적 인코딩 지시(이진/원-핫)

```vhdl
library ieee; use ieee.std_logic_1164.all;
entity fsm_enc is
  port (clk,rst,x: in std_logic; y: out std_logic);
end;
architecture rtl of fsm_enc is
  type state_t is (A,B,C,D);
  signal s, ns: state_t := A;

  -- (1) 이진/그레이 예: A=00, B=01, C=11, D=10
  attribute enum_encoding : string;
  attribute enum_encoding of state_t : type is "00 01 11 10";

  -- (2) 원-핫: "0001 0010 0100 1000"
  -- attribute enum_encoding of state_t : type is "0001 0010 0100 1000";
begin
  process(all) begin
    ns <= s;
    case s is
      when A => if x='0' then ns<=B else ns<=C end if;
      when B => ns<=C;
      when C => if x='0' then ns<=D else ns<=A end if;
      when D => ns<=A;
    end case;
  end process;

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then s<=A else s<=ns end if;
    end if;
  end process;

  y <= '1' when (s=C or s=D) else '0';
end;
```

### 9.2 SystemVerilog: Product 관찰자(등가 체크 스텁)

```systemverilog
module fsm_equiv_checker(input logic clk, rst, x);
  logic y1,y2; logic [1:0] s1,s2;
  dut_impl1 u1(.clk, .rst, .x, .y(y1), .state(s1));
  dut_impl2 u2(.clk, .rst, .x, .y(y2), .state(s2));

  // 출력 등가 검증(간단 SVA)
  property outputs_match; @(posedge clk) disable iff (rst) (y1==y2); endproperty
  assert property(outputs_match);

  // 필요 시 전이 등가도 관찰자 FSM으로 확장
endmodule
```

---

## 10. 실무 팁 및 안티패턴

### 10.1 해야 할 일 (Do)
- **빈번 전이** 쌍을 **해밍 1**로(인접성 보존).  
- Moore 출력은 **상태코드에 내장**해 출력 로직 제거.  
- Mealy 출력은 **레지스터** 1단 추가해 글리치 차단.  
- FPGA: **원-핫(또는 부분 원-핫)** 선호, ASIC: **이진/그레이** 우선.  
- **others→IDLE/ERR**로 불법 코드 복구(Self-start).  
- 후보 배정 간 **리터럴 수/셀 수/f\_max/전력** 비교로 객관 선택.

### 10.2 하지 말 것 (Don’t)
- 잦은 전이를 **해밍 2 이상**으로 떨어뜨리는 배정(묶음 분할).  
- Mealy 출력(조합)을 외부 클록/리셋으로 **직결**(글리치 위험).  
- 비동기 리셋 **해제 타이밍** 무시(복구·제거 시간 위반).

---

## 11. 요약 카드

- **등가 상태할당**: 비트 **치환/보수**, 라벨 치환은 K-맵 대칭성으로 **코스트 불변** 경향.  
- **가이드라인**: 인접성(해밍 1), Moore 출력 내장, 플랫폼별 최적화.  
- **원-핫**: “들어오는 간선 OR” → 식 단순·고속(FPGA), 대신 FF↑.  
- **FF 입력식**: \(D=Q^+\), \(T=Q\oplus Q^+\), \(J/K,S/R\)는 세트/리셋 조건.  
- **안전성**: Mealy 출력 **등록**, **others→IDLE**, CDC·리셋 동기화.