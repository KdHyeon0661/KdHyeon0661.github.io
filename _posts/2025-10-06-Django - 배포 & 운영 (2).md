---
layout: post
title: Django - 배포 & 운영 (2)
date: 2025-10-06 15:25:23 +0900
category: Django
---
# 8. 배포 & 운영 (2) — Docker · CI/CD · 클라우드

## A. Docker 컨테이너 — 멀티스테이지 빌드, 헬스체크, 볼륨/네트워크

### A-1. 멀티스테이지 빌드 기본 (Poetry 또는 pip 선택)
슬림 이미지를 만들고, 빌드 종속성과 런타임 종속성을 분리합니다.

```dockerfile
# syntax=docker/dockerfile:1.7

############################
# 1) Base (공통)
############################
FROM python:3.12-slim AS base
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1 PIP_DISABLE_PIP_VERSION_CHECK=1 \
    POETRY_VIRTUALENVS_CREATE=false
WORKDIR /app

# 런타임 기본 패키지(이미지/psycopg 등 필요한 OS deps)
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential curl ca-certificates libpq5 libjpeg62-turbo zlib1g \
  && rm -rf /var/lib/apt/lists/*

############################
# 2) Builder (의존성 설치 전용)
############################
FROM base AS builder
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc libpq-dev libjpeg-dev zlib1g-dev \
  && rm -rf /var/lib/apt/lists/*
# (Poetry)
RUN pip install --no-cache-dir poetry==1.8.3
COPY pyproject.toml poetry.lock /app/
RUN poetry install --no-root --only main

############################
# 3) Final Runtime
############################
FROM base AS runtime
# 보안: 비루트 사용자
RUN useradd -u 10001 -ms /bin/bash appuser
COPY --from=builder /usr/local /usr/local
COPY . /app/
RUN mkdir -p /app/staticfiles /app/media && chown -R appuser:appuser /app
USER appuser

# collectstatic (WhiteNoise 사용 시)
# ENV DJANGO_SETTINGS_MODULE=config.settings.prod
# RUN python manage.py collectstatic --noinput || true

# Gunicorn + UvicornWorker (ASGI)
EXPOSE 8000
HEALTHCHECK --interval=30s --timeout=5s --start-period=20s --retries=3 \
  CMD curl -fsS http://127.0.0.1:8000/healthz || exit 1
CMD ["gunicorn","config.asgi:application","-k","uvicorn.workers.UvicornWorker","-w","4","-b","0.0.0.0:8000","--timeout","60","--graceful-timeout","60","--max-requests","1000","--max-requests-jitter","100"]
```

> 포인트  
> - **builder** 단계에서 **컴파일 도구**를 설치하고 **runtime** 단계에선 제거 → 이미지 슬림화.  
> - **비루트 사용자**로 실행.  
> - **HEALTHCHECK** 로 오케스트레이터의 재시작/드레인 신호에 반응.

#### (선택) pip + requirements.txt
```dockerfile
FROM base AS builder
RUN apt-get update && apt-get install -y --no-install-recommends gcc libpq-dev \
  && rm -rf /var/lib/apt/lists/*
COPY requirements.txt /app/
RUN pip install -r requirements.txt

FROM base AS runtime
COPY --from=builder /usr/local /usr/local
COPY . /app/
USER appuser
CMD ["gunicorn","config.wsgi:application","-w","4","-b","0.0.0.0:8000"]
```

### A-2. 도커 빌드 캐시 최적화 (Buildx)
```bash
docker buildx create --use
docker buildx build \
  --cache-from=type=local,src=.buildxcache \
  --cache-to=type=local,dest=.buildxcache,mode=max \
  -t ghcr.io/you/app:commitsha -f Dockerfile .
```

### A-3. docker-compose 로 로컬 개발 (DB/Redis/볼륨/네트워크)
```yaml
version: "3.9"
services:
  app:
    build: .
    env_file: .env
    command: >
      sh -c "python manage.py migrate &&
             gunicorn config.asgi:application -k uvicorn.workers.UvicornWorker -w 2 -b 0.0.0.0:8000"
    ports: ["8000:8000"]
    volumes:
      - .:/app:delegated
      - static:/app/staticfiles
      - media:/app/media
    depends_on: [db, redis]
    healthcheck:
      test: ["CMD-SHELL","curl -fsS http://127.0.0.1:8000/healthz || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 5
  db:
    image: postgres:16
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: app
      POSTGRES_PASSWORD: secret
    volumes: [dbdata:/var/lib/postgresql/data]
  redis:
    image: redis:7-alpine
volumes:
  dbdata:
  static:
  media:
```

> 포인트  
> - **volumes**: 정적/미디어 분리.  
> - **depends_on + healthcheck**: 의존 서비스 준비 확인.  
> - **env_file**: 로컬에서만 사용. 운영은 오케스트레이터 주입.

### A-4. 도커 보안/운영 체크리스트
- [ ] 루트가 아닌 **비루트 사용자** 실행  
- [ ] **읽기 전용 루트 파일시스템**(오케스트레이터에서 설정)  
- [ ] **HEALTHCHECK** 구현, `/healthz` 엔드포인트 준비  
- [ ] **SIGTERM → graceful shutdown** 확인  
- [ ] 이미지에 **비밀 포함 금지**(ENV 대신 런타임 주입)  
- [ ] **SBOM**/취약점 스캔(Trivy, Grype)

---

## B. CI/CD — GitHub Actions, 테스트/마이그레이션/배포 파이프라인

### B-1. 파이프라인 설계 원칙
1) **PR 빌드**: lint/test/coverage, 이미지 빌드 드라이런.  
2) **main 브랜치 merge**: 이미지 빌드/푸시(GHCR or ECR).  
3) **배포 단계**:  
   - 마이그레이션 **미리보기** → **읽기 전용** 변경 검토  
   - **무중단 배포**(블루-그린/롤링)  
   - **마이그레이션 실행**은 **1회성 잡**으로 (ECS run-task / K8s Job).  
   - **롤백 절차**를 자동화.

### B-2. 공통 워크플로 (Build & Test)
`.github/workflows/ci.yml`
```yaml
name: CI
on:
  pull_request:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_DB: app
          POSTGRES_USER: app
          POSTGRES_PASSWORD: secret
        ports: ["5432:5432"]
        options: >-
          --health-cmd="pg_isready -U app -d app -h 127.0.0.1"
          --health-interval=5s --health-timeout=5s --health-retries=20
      redis:
        image: redis:7-alpine
        ports: ["6379:6379"]
    env:
      DATABASE_URL: postgres://app:secret@localhost:5432/app
      REDIS_URL: redis://localhost:6379/1
      DJANGO_SECRET_KEY: ci-secret
      DJANGO_SETTINGS_MODULE: config.settings.test
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: "3.12" }
      - name: Install deps
        run: |
          pip install -U pip
          pip install -r requirements.txt
      - name: Run tests
        run: |
          python manage.py migrate --noinput
          pytest --cov=apps --cov-report=xml
      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with: { files: ./coverage.xml }
```

### B-3. 컨테이너 빌드 & 레지스트리 푸시 (GHCR)
`.github/workflows/build.yml`
```yaml
name: Build
on:
  push:
    branches: [main]
jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - name: Set tags
        id: meta
        run: |
          echo "sha=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          echo "tag=ghcr.io/${{ github.repository }}:${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          echo "latest=ghcr.io/${{ github.repository }}:latest" >> $GITHUB_OUTPUT
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/build-push-action@v6
        with:
          push: true
          context: .
          file: Dockerfile
          tags: |
            ${{ steps.meta.outputs.tag }}
            ${{ steps.meta.outputs.latest }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

### B-4. AWS ECR/ECS 배포 (OIDC 추천)
**권장**: GitHub → AWS OIDC 연동으로 **키리스** 로그인.

#### 1) AWS IAM: OIDC provider + Role (신뢰 정책: GitHub)
- 역할에 ECR Push, ECS UpdateService, SSM GetParameters 권한.
- 자세한 설정은 AWS 공식 가이드 참고(여기선 요지와 YAML만 제시).

#### 2) Actions 배포 워크플로 — ECS Fargate
`.github/workflows/deploy-ecs.yml`
```yaml
name: Deploy ECS
on:
  workflow_dispatch:
  push:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AWS_REGION: ap-northeast-2
      ECR_REPO: your-ecr-repo
      ECS_CLUSTER: app-cluster
      ECS_SERVICE: app-service
      CONTAINER_NAME: web
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::123456789012:role/github-deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push
        id: bp
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}:${{ github.sha }}
          file: Dockerfile

      - name: Render task definition
        id: taskdef
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: deploy/ecs-task.json
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}:${{ github.sha }}

      - name: Run DB migrations (one-off task)
        run: |
          aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $(jq -r .taskDefinitionArn <<< $(aws ecs register-task-definition --cli-input-json file://deploy/migrate-task.json)) \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[subnet-xxx],securityGroups=[sg-xxx],assignPublicIp=DISABLED}" \
            --overrides '{"containerOverrides":[{"name":"web","command":["python","manage.py","migrate","--noinput"]}]}'
          # (간단 예시: 실제 환경에 맞춰 VPC/서브넷/보안그룹 지정)

      - name: Deploy Service
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          task-definition: ${{ steps.taskdef.outputs.task-definition-arn }}
          wait-for-service-stability: true
```

> 포인트  
> - 마이그레이션은 **서비스 업데이트 전**에 **일회성 태스크**로 수행(스키마 호환성 고려).  
> - ECS 배포 정책(rolling maxSurge/maxUnavailable)로 **무중단**.

### B-5. EC2 SSH 배포(간단/전통식)
- Actions → SSH → **pull + systemd restart**. 간단하나 확장성/보안상 권장도 낮음.

```yaml
- name: Deploy to EC2
  uses: appleboy/ssh-action@v1.0.3
  with:
    host: ${{ secrets.EC2_HOST }}
    username: ubuntu
    key: ${{ secrets.EC2_SSH_KEY }}
    script: |
      cd /srv/app
      sudo docker pull ghcr.io/you/app:${{ github.sha }}
      sudo docker compose up -d --no-deps web
```

### B-6. 마이그레이션/릴리스 안전 전략
- **상하위 호환 스키마**:  
  1) 컬럼 추가(Nullable) → 앱 코드 새 컬럼 쓰기 → 데이터 백필 → NOT NULL 제약  
  2) 컬럼 삭제는 **마지막 단계**  
- **PRG & Feature Flag**: 코드/DB 전환을 플래그로 제어  
- **롤백**: 이전 이미지/태스크 정의를 즉시 재적용 가능하도록 기록

---

## C. 클라우드 — AWS(EC2/ECS/EKS/RDS/S3), 스토리지/로드밸런서 패턴

### C-1. 공통 아키텍처 개요
```
[Route53] → [CloudFront/CDN] → [ALB/ELB] → [App (EC2/ECS/EKS)]
                          ↘  [S3 (정적/미디어)]
[Secrets Manager/SSM] — 비밀/설정 주입
[RDS (PostgreSQL)] — 메인 DB
[ElastiCache (Redis)] — 캐시/Channels Layer
[CloudWatch/Prometheus] — 로그/메트릭/알람
```

### C-2. EC2 패턴 (가장 전통적인 배치)
- **ASG**(Auto Scaling Group) + **ALB** 뒤에 N대의 EC2 인스턴스.  
- 각 인스턴스: **Nginx + Gunicorn(UvicornWorker) + 앱**.  
- 배포: **CodeDeploy** 또는 GitHub Actions SSH.  
- 장점: 유연/세밀 제어. 단점: 서버 관리·스케일링 부하.

**핵 포인트**
- UserData로 **부팅 스크립트**(도커 런/환경변수/업데이트)  
- **ALB 헬스체크** `/healthz`  
- CloudWatch Logs/Agent로 **로그 수집**  
- IAM Role(EC2 Instance Profile)로 **S3/RDS/SSM 접근**

### C-3. ECS Fargate 패턴 (컨테이너 서버리스)
- **작업 정의(Task Definition)** 에 컨테이너 정의.  
- **서비스(Service)** 로 **Desired Count** 유지 + 롤링 업데이트.  
- **ALB Target Group** 으로 HTTP, **NLB** 로 TCP(WebSocket도 ALB OK).  
- 장점: 서버 관리 최소. 단점: 비용/추상화 제약.

**ECS 핵심 설정**
- **awsvpc** 네트워킹: 서브넷/보안그룹 지정  
- **TaskRole**(IRSA 유사 역할): S3, SSM, CloudWatch 권한  
- **시크릿 주입**: Secrets Manager/SSM → 환경변수  
- **Autoscaling**: CPU/메모리/Request Count 기반

**Task Definition 예시 (요약)**
```json
{
  "family": "app-task",
  "networkMode": "awsvpc",
  "cpu": "512",
  "memory": "1024",
  "requiresCompatibilities": ["FARGATE"],
  "executionRoleArn": "arn:aws:iam::...:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::...:role/appTaskRole",
  "containerDefinitions": [
    {
      "name": "web",
      "image": "123456789012.dkr.ecr.ap-northeast-2.amazonaws.com/app:latest",
      "portMappings": [{ "containerPort": 8000, "protocol": "tcp" }],
      "essential": true,
      "environment": [
        {"name":"DJANGO_SETTINGS_MODULE","value":"config.settings.prod"}
      ],
      "secrets": [
        {"name":"DJANGO_SECRET_KEY","valueFrom":"arn:aws:secretsmanager:...:secret:DJANGO_SECRET_KEY"},
        {"name":"DATABASE_URL","valueFrom":"arn:aws:ssm:...:parameter/DATABASE_URL"}
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/app",
          "awslogs-region": "ap-northeast-2",
          "awslogs-stream-prefix": "web"
        }
      },
      "healthCheck": {
        "command": ["CMD-SHELL","curl -fsS http://localhost:8000/healthz || exit 1"],
        "interval": 30, "timeout": 5, "retries": 3, "startPeriod": 20
      }
    }
  ]
}
```

### C-4. EKS(Kubernetes) 패턴 (유연성 최강)
- 컨트롤플레인 관리형(EKS) + 워커 노드(EC2/마네지드 노드 그룹).  
- **Ingress(ALB Ingress Controller)** → **Service** → **Deployment/ReplicaSet**.  
- 시크릿: **Secrets Store CSI Driver** + Secrets Manager.  
- IAM for Service Accounts(IRSA) 로 **Pod 단위 권한**.

**매니페스트 예시**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata: { name: app, labels: { app: app } }
spec:
  replicas: 3
  selector: { matchLabels: { app: app } }
  template:
    metadata: { labels: { app: app } }
    spec:
      serviceAccountName: app-sa
      containers:
        - name: web
          image: 123456789012.dkr.ecr.ap-northeast-2.amazonaws.com/app:latest
          ports: [{ containerPort: 8000 }]
          env:
            - name: DJANGO_SETTINGS_MODULE
              value: config.settings.prod
          envFrom:
            - secretRef: { name: app-secrets }
          readinessProbe:
            httpGet: { path: /healthz, port: 8000 }
            initialDelaySeconds: 10
            periodSeconds: 10
          livenessProbe:
            httpGet: { path: /healthz, port: 8000 }
            initialDelaySeconds: 30
            periodSeconds: 20
---
apiVersion: v1
kind: Service
metadata: { name: app-svc }
spec:
  type: ClusterIP
  selector: { app: app }
  ports: [{ name: http, port: 80, targetPort: 8000 }]
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ing
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
spec:
  rules:
    - host: example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend: { service: { name: app-svc, port: { number: 80 } } }
```

**운영 포인트**
- HPA(Horizontal Pod Autoscaler)로 **CPU/메모리/사용자 커스텀 메트릭** 기반 스케일  
- **롤링 업데이트** + **PodDisruptionBudget**  
- **Job/CronJob** 로 마이그레이션/스케줄 작업

### C-5. 데이터/스토리지 패턴 (S3/RDS/EFS)
- **RDS(PostgreSQL)**: 멀티 AZ, 자동 백업, 파라미터 그룹 튜닝, 최소 권한 보안 그룹  
- **S3**: 정적/미디어 파일 저장 + **CloudFront** 캐시, **서명 URL**(프라이빗)  
- **EFS**: 공유 파일 시스템(권장도 낮음) — 꼭 필요한 경우(공유 업로드)만  
- **ElastiCache Redis**: 캐시/세션/Channel Layer → **단일화** 권장

**Django 설정 예시**
```python
# settings/prod.py
import os, dj_database_url
DATABASES = { "default": dj_database_url.parse(os.environ["DATABASE_URL"], conn_max_age=600) }

CACHES = {
  "default": {
    "BACKEND": "django_redis.cache.RedisCache",
    "LOCATION": os.environ["REDIS_URL"],
    "OPTIONS": { "CLIENT_CLASS": "django_redis.client.DefaultClient" }
  }
}

DEFAULT_FILE_STORAGE = "storages.backends.s3boto3.S3Boto3Storage"
AWS_STORAGE_BUCKET_NAME = os.environ["AWS_STORAGE_BUCKET_NAME"]
AWS_S3_REGION_NAME = os.environ.get("AWS_S3_REGION_NAME","ap-northeast-2")
```

### C-6. 로드밸런서/네트워크 패턴
- **ALB**: L7 HTTP/HTTPS, **WebSocket 지원**, 경로/호스트 기반 라우팅, 헬스체크. 대부분의 웹앱에 적합.  
- **NLB**: L4, 초고성능 TCP/UDP, gRPC/고정 IP 필요 시.  
- **클라이언트 IP**: ALB 뒤에서는 `X-Forwarded-For` 신뢰 → Django `SECURE_PROXY_SSL_HEADER`.  
- **Sticky Session**: 가능하지만 **무상태** 설계 권장. WebSocket은 **ALB로도 OK**.

### C-7. 로깅/모니터링/알림
- **CloudWatch Logs**: 컨테이너 stdout/stderr → 지표/알람  
- **Sentry/APM(OpenTelemetry)**: 애플리케이션 레벨 오류/트레이스  
- **ALB/NLB 액세스 로그**: S3 적재 + Athena/CloudWatch 분석  
- **메트릭**: RDS(커넥션/Buffer/IO), ECS/EKS(CPU/메모리/에러율), 애플리케이션(HTTP 5xx/지연)

### C-8. 백업/복구/DR
- **RDS 스냅샷** 정기화 + **Point-In-Time Recovery**  
- **S3 버전관리 + 수명주기**(아카이브/만료)  
- **인프라 IaC**(Terraform/CloudFormation) 상태로 **재현 가능성** 확보  
- **복구 훈련**(게임데이)로 **RTO/RPO** 확인

---

## D. 종합 배포 시나리오 — “PR → 테스트 → 이미지 빌드 → ECR → ECS 롤링 → 마이그레이션 → 검증/롤백”

1) PR 열림: `CI` 워크플로가 **pytest** + **coverage** 실행, 슬로우 쿼리/린트 검증.  
2) main 병합: `Build` 워크플로가 **이미지 빌드** 후 **ECR 푸시**.  
3) `Deploy ECS` 워크플로:  
   - 새 이미지로 **Task Definition 렌더링**  
   - **마이그레이션 run-task** (읽기 호환성 고려한 선 배포)  
   - **ECS Service 업데이트** → ALB **헬스체크 통과 후 트래픽 전환**  
4) 사후 검증: **헬스/에러율/지연** 모니터링, 문제가 있으면 **이전 Task Definition** 으로 **즉시 롤백**.  
5) 정리: 릴리스 노트/스키마 단계적 변경(다단계 마이그레이션) 마무리.

---

## E. 체크리스트 (요약)

**Docker**
- [ ] 멀티스테이지, 비루트, HEALTHCHECK  
- [ ] 이미지 스캔(SBOM), 비밀 미포함  
- [ ] SIGTERM 처리, `/healthz`

**CI**
- [ ] Test/Lint/Coverage, DB/Redis 서비스 연결  
- [ ] 캐시 최적화(buildx, pip cache)  
- [ ] 실패 빠른 피드백(병렬화)

**CD**
- [ ] OIDC로 클라우드 인증(키리스)  
- [ ] 이미지 태깅(sha/semver), 불변 태그  
- [ ] 마이그레이션 일회성 잡, 무중단 롤링/블루그린  
- [ ] 자동 롤백 버튼/스크립트

**AWS**
- [ ] ALB + 헬스체크, 최소 2 AZ  
- [ ] RDS 백업/모니터링/파라미터 그룹  
- [ ] S3 프라이빗 + 서명 URL, CloudFront 캐시  
- [ ] Secrets Manager/SSM로 비밀 주입  
- [ ] CloudWatch 알람(5xx, 지연, CPU/메모리)

**보안**
- [ ] SG 최소 권한, 퍼블릭/프라이빗 서브넷 분리  
- [ ] HTTPS/HSTS, 보안 헤더  
- [ ] WAF/Shield(필요 시), 관리자 접근 제어

---

## F. 부록 — 실무 유틸/스크립트

### F-1. Makefile (개발자 경험)
```makefile
.PHONY: up down logs test migrate shell

up:
\tdocker compose up -d

down:
\tdocker compose down

logs:
\tdocker compose logs -f --tail=200 app

test:
\tdocker compose exec -T app pytest -q --disable-warnings

migrate:
\tdocker compose exec -T app python manage.py migrate --noinput

shell:
\tdocker compose exec app python manage.py shell
```

### F-2. 배포 전 점검 스크립트 (관리 커맨드)
```python
# apps/core/management/commands/predeploy_check.py
from django.core.management.base import BaseCommand
from django.db import connection
class Command(BaseCommand):
    help = "배포 전 간단 점검(DB 연결/마이그레이션 상태)"
    def handle(self, *args, **kwargs):
        with connection.cursor() as c:
            c.execute("SELECT 1")
        self.stdout.write(self.style.SUCCESS("DB OK"))
        # 여기에 마이그레이션 drift 검사/스토리지 접근 검사 추가
```

### F-3. 롤백 스크립트(예시)
```bash
# 최신-1 태스크 정의로 되돌리기
LAST=$(aws ecs list-task-definitions --family-prefix app-task --sort DESC --max-items 2 --query 'taskDefinitionArns[1]' --output text)
aws ecs update-service --cluster app-cluster --service app-service --task-definition "$LAST"
aws ecs wait services-stable --cluster app-cluster --services app-service
```

---

## 마무리

- **Docker** 는 멀티스테이지·비루트·헬스체크로 **가볍고 안전한 런타임**을 만들고,  
- **CI/CD** 는 테스트→이미지→마이그레이션→무중단 배포의 **표준 파이프라인**으로 **속도와 신뢰성**을 동시에 확보합니다.  
- **AWS** 에서는 ECS/EKS/EC2 각 패턴에서 **ALB + RDS + S3 + Redis + 비밀 주입**을 일관되게 사용하여 **확장성/가용성/보안**을 기본값으로 만듭니다.
