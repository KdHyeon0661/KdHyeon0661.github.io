---
layout: post
title: DB - 성능 데이터 모델링
date: 2025-02-02 19:20:23 +0900
category: DB
---
# 성능 데이터 모델링 개요

## 문제 정의와 원칙

성능 데이터 모델링의 시작은 정규화된 설계입니다. 정규화는 데이터 무결성을 보장하는 기본값이며, 성능 문제는 반드시 실제 측정 지표와 실행 계획 분석을 통해 증명되어야 합니다.

반정규화는 모든 다른 방법이 효과가 없을 때 고려하는 마지막 수단입니다. 반정규화를 적용할 때는 반드시 데이터 정합성을 유지할 수 있는 메커니즘(트리거, 배치 작업, CDC, 애플리케이션 로직 등)을 함께 설계해야 합니다.

성능 최적화는 항상 실제 서비스에서 가장 자주 실행되는 핵심 쿼리 집합을 기준으로 진행되어야 합니다. 또한 시스템의 읽기/쓰기 비율, 서비스 수준 협약(SLA), 그리고 데이터의 접근 빈도(핫/웜/콜드)를 고려한 설계가 필요합니다.

---

## 성능 판단을 위한 비용 모델 이해

### 조인 비용 분석
데이터베이스 성능 튜닝의 핵심은 디스크 I/O를 최소화하는 것입니다. 조인 작업의 비용은 주로 다음과 같은 요소로 근사할 수 있습니다.

- **해시 조인**: 대용량 데이터 분석(OLAP)에 적합하며, 빌드 단계와 프로브 단계의 비용으로 구성됩니다.
- **중첩 루프 조인**: 온라인 트랜잭션 처리(OLTP)에서 자주 사용되며, 인덱스를 활용할 수 있을 때 효율적입니다. 특히 커버링 인덱스가 사용되면 테이블 접근 없이 인덱스만으로 조인이 완료될 수 있습니다.

### 인덱스 선택도와 비용
인덱스의 효과는 인덱스 선두 컬럼의 선택도에 크게 의존합니다. 선택도가 낮을수록(고유한 값이 많을수록) 인덱스의 효율이 높아집니다. 인덱스 스캔의 예상 비용은 루트에서 리프 노드까지의 이동 비용과 선택도에 비례하는 테이블 접근 비용의 합으로 추정할 수 있습니다.

### 반정규화 결정 기준
반정규화를 도입할지 여부는 비용 편익 분석으로 결정할 수 있습니다. 예를 들어, 빈번한 집계 쿼리로 인한 전체 시스템 부하가 크고, 이를 요약 테이블로 대체했을 때의 유지 관리 비용이 상대적으로 낮다면 반정규화가 유리할 수 있습니다. 그러나 이는 실제 벤치마크를 통해 검증해야 합니다.

---

## 성능 튜닝 절차와 가이드라인

효율적인 성능 튜닝을 위해 다음과 같은 체계적인 절차를 따르는 것이 좋습니다.

1. **시스템 분석**: 데이터 성장률, 읽기/쓰기 비율, 핵심 SLA를 파악합니다.
2. **정규화된 모델 설계**: 무결성이 보장된 기본 모델을 먼저 구축합니다.
3. **핵심 쿼리 식별**: 실제 부하를 발생시키는 상위 10~20개의 쿼리를 수집하고 실행 계획을 분석합니다.
4. **기본 최적화 적용**: 인덱스 추가, 통계 업데이트, 데이터베이스 파라미터 조정을 우선 시도합니다.
5. **고급 기법 검토**: 파티셔닝, 샤딩, 캐싱, 요약 테이블 등의 대안을 평가합니다.
6. **반정규화 신중 적용**: 위 모든 방법으로도 해결되지 않을 때만 최소 범위로 반정규화를 적용하고 정합성 유지 방안을 마련합니다.
7. **지속적 모니터링**: 변경 사항에 대한 성능 모니터링과 회귀 테스트를 수행합니다.

**가이드라인**: 반정규화는 반드시 문서화되어야 합니다. 적용 근거, 대상, 정합성 유지 전략, 그리고 롤백 계획을 명확히 기록해야 합니다. 또한 변경 전후의 성능 지표(p95/p99 지연 시간, CPU/IO 사용률, 락 경합)를 비교하여 효과를 검증해야 합니다.

---

## 핵심 성능 기법과 SQL 패턴

### 인덱스 최적화
인덱스는 가장 효과적인 성능 향상 방법 중 하나입니다. 다양한 인덱스 전략을 상황에 맞게 적용할 수 있습니다.

```sql
-- 복합 인덱스: 자주 함께 필터링되고 정렬되는 컬럼 조합
CREATE INDEX idx_order_status_dt ON "order"(status, ordered_at DESC);

-- 부분 인덱스: 특정 조건을 만족하는 행에만 인덱스 생성
CREATE INDEX idx_order_paid ON "order"(ordered_at DESC) WHERE status = 'PAID';

-- 함수 인덱스: 컬럼 값을 가공한 결과에 인덱스 생성 (DBMS별 지원 다름)
CREATE INDEX idx_user_phone_norm ON app_user (regexp_replace(phone, '\D','','g'));
```

인덱스는 쓰기 성능과 저장 공간에 부담을 주므로, 읽기 성능 향상과의 균형을 고려해야 합니다.

### 파티셔닝
대량의 데이터를 물리적으로 분할하여 관리 효율성과 쿼리 성능을 향상시킵니다.

```sql
-- PostgreSQL 선언적 파티셔닝 예시 (날짜 기준)
CREATE TABLE event (
  id BIGSERIAL PRIMARY KEY,
  occurred_at timestamptz NOT NULL,
  payload jsonb NOT NULL
) PARTITION BY RANGE (occurred_at);

CREATE TABLE event_2025_11 PARTITION OF event
  FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
```

파티셔닝의 핵심은 쿼리 조건에 자주 사용되는 컬럼을 파티션 키로 선정하는 것입니다. 또한 오래된 파티션을 주기적으로 아카이빙하거나 삭제하는 정책을 자동화하여 운영 부하를 줄일 수 있습니다.

### 요약 테이블과 물질화 뷰
빈번한 집계 연산의 부하를 줄이기 위해 미리 계산된 결과를 저장하는 방법입니다.

```sql
-- PostgreSQL 물질화 뷰 예시
CREATE MATERIALIZED VIEW daily_sales AS
SELECT order_date::date AS d, SUM(amount) AS revenue
FROM fact_order
GROUP BY 1;

-- 비동기로 데이터 갱신
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_sales;
```

요약 테이블은 트리거를 통해 실시간으로 갱신할 수도 있지만, 이는 고부하 환경에서 락 경합과 성능 저하를 유발할 수 있습니다. 대안으로 Change Data Capture(CDC)를 이용한 비동기 갱신이나 주기적 배치 작업을 고려할 수 있습니다.

### 반정규화 패턴
반정규화에는 여러 구체적인 패턴이 있습니다.

| 패턴 | 설명 | 장점 | 주의사항 |
|---|---|---|---|
| **중복 컬럼 추가** | 조인 대상 테이블의 자주 접근하는 컬럼을 복제 | 조인 회수 감소 | 원본-복사본 동기화 필요 |
| **테이블 병합** | 자주 함께 조회되는 1:1 또는 좁은 1:N 테이블 통합 | I/O 감소 | 쓰기 부하 증가 및 락 경합 가능 |
| **요약 테이블** | 집계 결과를 미리 계산하여 저장 | 복잡한 집계 쿼리 성능 극대화 | 유지 관리 비용 발생 |
| **파생 컬럼 저장** | 계산 비용이 높은 값을 미리 계산하여 저장 | 런타임 계산 부하 감소 | 원본 변경 시 재계산 필요 |

반정규화를 적용하기 전에는 항상 인덱스 최적화, 파티셔닝, 캐싱 등 다른 대안이 충분히 검토되었는지 확인해야 합니다.

---

## 사례 연구: 커머스 시스템 대시보드 성능 향상

### 문제 상황
고객별 최근 30일 주문 합계를 보여주는 대시보드의 응답 시간(p95)이 2.5초로 너무 느렸습니다. 매번 `주문`과 `주문항목` 테이블을 전체 스캔하여 집계하는 것이 원인이었습니다.

### 개선 단계

1. **인덱스 추가**
   - `주문` 테이블에 `(상태, 주문일시 DESC)` 인덱스 추가
   - `주문항목` 테이블에 `주문_ID` 인덱스 추가
   - 결과: p95 2.5초 → 1.2초

2. **파티셔닝 적용**
   - `주문` 테이블을 월별로 파티셔닝
   - 최근 1개월 데이터만 스캔하도록 최적화
   - 결과: p95 1.2초 → 0.7초

3. **요약 테이블 도입**
   - `일별_고객_매출` 요약 테이블 생성
   - 변경 데이터 캡처(CDC)를 이용한 비동기 갱신
   - 대시보드 쿼리가 간단한 SUM 조회로 변경
   - 결과: p95 0.7초 → 60ms

```sql
-- 요약 테이블 생성
CREATE TABLE daily_customer_sales (
  customer_id BIGINT NOT NULL,
  d date NOT NULL,
  revenue numeric(18,2) NOT NULL,
  PRIMARY KEY (customer_id, d)
);

-- 최적화된 대시보드 쿼리
SELECT customer_id, SUM(revenue) AS last30_revenue
FROM daily_customer_sales
WHERE d >= current_date - 30
GROUP BY customer_id
ORDER BY last30_revenue DESC
LIMIT 50;
```

---

## 보고서 및 분석 워크로드 처리

OLTP 시스템에서 대규모 분석 쿼리를 실행하는 것은 적합하지 않습니다. 분석 성 워크로드는 별도의 데이터 웨어하우스나 데이터 레이크로 분리하는 것이 원칙입니다.

- **ETL/ELT 파이프라인**: 운영 데이터를 분석 스토어로 주기적으로 이동
- **SCD(Type 2)**: 차원 데이터의 변경 이력을 유지하여 정확한 시점 조회 지원
- **증분 적재**: `updated_at` 타임스탬프나 CDC를 이용하여 변경된 데이터만 효율적으로 처리

---

## CQRS와 이벤트 소싱 관점

**CQRS(Command Query Responsibility Segregation)**는 명령(쓰기) 모델과 조회(읽기) 모델을 분리하는 패턴입니다. 쓰기 모델은 정규화를 중시하고, 읽기 모델은 성능 최적화를 위해 반정규화된 구조를 가질 수 있습니다.

**이벤트 소싱**은 상태 변경을 이벤트 스트림으로 저장하고, 이를 기반으로 다양한 읽기 모델을 비동기적으로 구축할 수 있습니다. 이 방식은 읽기 성능을 극대화할 수 있지만, 최종 일관성을 수용해야 하며 이벤트 재생과 보정 도구가 필수적입니다.

---

## 데이터베이스별 고려사항

각 데이터베이스 관리 시스템은 고유한 특성과 기능을 가지고 있습니다.

| 항목 | PostgreSQL | MySQL (InnoDB) | Oracle |
|---|---|---|---|
| **인덱스 유형** | B-Tree, GIN, GiST, BRIN | B-Tree | B-Tree 등 다양 |
| **부분 인덱스** | 완전 지원 | 제한적 지원 | 함수 기반 인덱스로 유사 구현 |
| **MVCC 관리** | VACUUM/Autovacuum | Purge/Undo | Undo 세그먼트 |
| **물질화 뷰** | 지원 | 미지원 (뷰 + 테이블로 대체) | 강력한 지원 |
| **파티셔닝** | 선언형 파티셔닝 지원 | RANGE, LIST, HASH | 매우 다양하고 성숙 |

---

## 반정규화 적용 전 점검사항

반정규화를 결정하기 전에 다음 질문들에 답할 수 있어야 합니다.

1. 성능 문제의 원인이 명확히 분석되었으며, 실행 계획과 프로파일링 데이터로 증명되었나요?
2. 인덱스 추가, 파티셔닝, 쿼리 재작성 등 다른 모든 대안이 효과가 없었나요?
3. 데이터 정합성을 유지하기 위한 메커니즘(트리거, 배치, CDC 등)이 설계되었나요?
4. 문제 발생 시 롤백할 수 있는 계획과 방법이 마련되어 있나요?
5. 변경 후 모니터링할 성능 지표(p95, p99, 쓰기 지연, 에러율)와 알림 설정이 준비되었나요?

---

## 마이그레이션과 롤백 전략

### 반정규화 컬럼 추가 예시
주문 테이블에 고객 이름 스냅샷을 추가하는 경우:

```sql
-- 1. 새 컬럼 추가
ALTER TABLE "order" ADD COLUMN customer_name_snapshot TEXT;

-- 2. 기존 데이터 백필
UPDATE "order" o
SET customer_name_snapshot = c.name
FROM customer c
WHERE c.customer_id = o.customer_id;

-- 3. 실시간 동기화 메커니즘 구현 (CDC나 배치 작업 권장)
```

**롤백 계획**: 애플리케이션에서 새 컬럼을 무시하도록 변경한 후, 필요시 컬럼을 제거하고 원래 조인 방식으로 복귀합니다.

### 요약 테이블 도입
요약 테이블을 도입할 때는 다음 단계를 따릅니다: 테이블 생성 → 기존 데이터 백필 → 읽기 전환(피처 플래그 사용) → 실시간 갱신 메커니즘 적용 → 검증 → 기존 경로 제거.

**롤백 계획**: 피처 플래그를 원래 상태로 되돌리고, 요약 테이블을 읽지 않도록 변경합니다.

---

## 동시성과 락 관리

반정규화는 종종 데이터 중복을 수반하므로, 동시에 여러 곳에서 같은 데이터를 갱신할 때 락 경합과 교착 상태가 발생할 수 있습니다. 이를 완화하기 위해:

- 배치 작업을 작은 단위로 나누어 실행
- 갱신 작업의 시간대를 분산
- 적절한 재시도 메커니즘 구현
- 데이터베이스 격리 수준을 신중히 선택

---

## 테스트와 회귀 방지

### 성능 벤치마크
변경 사항의 효과를 정량적으로 평가하기 위해 마이크로 벤치마크를 수행합니다.

```sql
-- 원본 집계 쿼리 성능 측정
EXPLAIN (ANALYZE, BUFFERS)
SELECT c.customer_id, SUM(oi.qty*oi.price_at)
FROM "order" o
JOIN order_item oi ON oi.order_id = o.order_id
JOIN customer c ON c.customer_id = o.customer_id
WHERE o.ordered_at >= now() - interval '30 days'
GROUP BY c.customer_id;
```

측정 지표로는 실행 시간, 버퍼 히트율, 읽은 블록 수, 정렬/해시 메모리 사용량, 임시 디스크 사용량 등을 수집합니다.

### 회귀 방지
스키마 변경 시 CI 파이프라인에 대표적인 쿼리들의 성능 스냅샷 테스트를 포함시켜 성능 회귀를 조기에 발견합니다. 프로덕션 환경에서는 실제 트래픽의 p95/p99 지연 시간 변화를 지속적으로 모니터링합니다.

---

## 실전 패턴 모음

### 커버링 인덱스
쿼리에 필요한 모든 컬럼을 인덱스에 포함시켜 테이블 접근을 완전히 피합니다.

```sql
-- status, ordered_at, amount 컬럼만 필요한 쿼리를 위한 인덱스
CREATE INDEX idx_order_cover ON `order` (status, ordered_at, amount);
```

### BRIN 인덱스 (PostgreSQL)
시간순으로 삽입되는 대용량 테이블에서 범위 검색을 효율적으로 처리하는 경량 인덱스입니다.

```sql
CREATE INDEX idx_event_brin ON event USING brin (occurred_at);
```

### 읽기 모델 분리 (CQRS)
쓰기 모델과 독립적으로 최적화된 읽기 전용 테이블을 유지합니다.

```sql
CREATE TABLE customer_read_model (
  customer_id BIGINT PRIMARY KEY,
  last30_revenue NUMERIC(18,2) NOT NULL,
  updated_at timestamptz NOT NULL DEFAULT now()
);
```

---

## 피해야 할 안티패턴

| 안티패턴 | 문제점 | 대안 |
|---|---|---|
| **조기 반정규화** | 데이터 정합성과 유지보수성 악화 | 인덱스, 파티셔닝, 쿼리 최적화를 먼저 시도 |
| **과도한 트리거** | 락 경합 증가 및 디버깅 어려움 | CDC나 배치 작업을 이용한 비동기 처리 |
| **무분별한 UUID v4 사용** | 인덱스 지역성 저하로 성능 저하 | 시간 정렬형 UUID(v7)나 ULID, 시퀀스 사용 |
| **SELECT *** | 불필요한 I/O 증가 및 커버링 인덱스 효과 감소 | 실제 필요한 컬럼만 명시적으로 선택 |
| **인덱스 과잉** | 쓰기 성능 급감 및 저장 공간 낭비 | 실제 핵심 쿼리 기반으로 인덱스 설계 및 정기 점검 |

---

## 운영 모니터링 쿼리

성능 문제를 사전에 발견하기 위해 정기적으로 모니터링해야 합니다.

```sql
-- PostgreSQL: 가장 느린 쿼리 확인
SELECT query, calls, mean_exec_time, rows
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 잠금 대기 상황 확인
SELECT pid, locktype, relation::regclass, mode, granted, query
FROM pg_locks l JOIN pg_stat_activity a USING (pid)
WHERE NOT granted;

-- 인덱스 사용 통계
SELECT relname, idx_scan, seq_scan
FROM pg_stat_all_tables
ORDER BY (seq_scan + idx_scan) DESC;
```

---

## 결론

성능 데이터 모델링은 정규화된 건강한 데이터 구조를 기반으로, 시스템의 실제 사용 패턴에 맞게 성능을 최적화하는 과학적이면서도 예술적인 작업입니다.

최적화의 우선순위는 명확해야 합니다: 인덱스, 통계, 쿼리 재작성, 파티셔닝, 캐싱을 먼저 충분히 적용한 후, 정말 필요한 경우에만 반정규화를 최소 범위로 적용해야 합니다. 반정규화를 도입할 때는 데이터 정합성 유지, 안전한 마이그레이션, 체계적인 모니터링, 그리고 회귀 방지까지 종합적으로 고려한 운영 시나리오가 반드시 동반되어야 합니다.

성능과 데이터 무결성 사이의 균형을 유지하는 것은 지속 가능한 시스템을 구축하는 핵심입니다. 팀 표준과 자동화 도구를 통해 이 균형을 체계적으로 관리할 때, 장기적으로 안정적이고 효율적인 데이터 시스템을 운영할 수 있습니다.