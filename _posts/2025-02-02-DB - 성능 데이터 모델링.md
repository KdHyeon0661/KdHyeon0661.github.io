---
layout: post
title: DB - 성능 데이터 모델링
date: 2025-02-02 19:20:23 +0900
category: DB
---
# 성능 데이터 모델링 개요

## 문제 정의와 공리(Principles)

- 정규화는 **기본값**이다. 성능 문제는 **측정과 증거**로 제시되어야 한다.
- 반정규화는 **마지막 수단**이며, 적용 시 **정합성 유지 메커니즘**(트리거/잡/CDC/애플리케이션 계층)이 반드시 동반되어야 한다.
- 모든 성능 선택은 **핵심 쿼리 집합(Top-K Queries)**에 의해 주도되어야 한다.
- 설계는 **읽기/쓰기 비율(Load Mix)**, **SLA**, **데이터 온도(Hot/Warm/Cold)**에 직접적으로 대응해야 한다.

---

## 계량적 판단을 위한 간단한 비용 모델

### 조인 비용 근사

조인 시 랜덤 접근(페이지 I/O) 수를 최소화하는 것이 핵심이다. 단순 근사로,

$$
C_{\text{join}} \approx C_{\text{probe}} + C_{\text{lookup}}
$$

- 해시 조인(OLAP):
  $$ C_{\text{build}} \approx O(|R|),\quad C_{\text{probe}} \approx O(|S|) $$
- 중첩 루프(인덱스 조인, OLTP):
  $$ C_{\text{lookup}} \approx |R| \cdot \log(|S|) $$
  인덱스 선택도가 높고 **커버링 인덱스**일수록 실제 페이지 접근 수가 줄어든다.

### 인덱스 선택도(카디널리티)와 비용

선택도가 \( \sigma \) (0~1)일 때, 인덱스 스캔 페이지 수 근사:

$$
\text{pages} \approx \text{root\_to\_leaf} + \sigma \cdot \text{table\_pages}
$$

⇒ **선두 컬럼의 선택도**가 낮으면 복합 인덱스의 효과가 급감한다.

### 반정규화 판단 임계

고가용/고QPS 읽기 패턴에서 집계(예: 일별 합계)로 인한 반복 스캔이 전체 부하의 \(\alpha\)를 차지하고, 요약 테이블 유지 비용이 쓰기당 \(\beta\)일 때,
**요약 테이블의 기대 이득**은:

$$
\Delta = \alpha \cdot C_{\text{full-scan}} - \beta \cdot C_{\text{maint}}
$$

\(\Delta > 0\)이면 반정규화를 검토한다. 실제 값은 A/B 벤치마크로 추정한다.

---

## 절차(리마인드)와 가드레일

1) **용량/트랜잭션 분석**: 데이터 성장률·읽기/쓰기 비율·핵심 SLA.
2) **정규화된 논리/물리 모델** 작성.
3) **핵심 쿼리**(탑 10~20) 수집·실행계획 캡처.
4) **인덱스/통계/파라미터** 튜닝(우선 적용).
5) **파티셔닝/샤딩/캐시/요약 테이블** 등 대안 검토.
6) 대안 무력 시 **반정규화 최소 단위 적용** + 정합성 메커니즘 설계.
7) **모니터링/회귀 테스트**를 통해 지속 개선.

가드레일
- 반정규화는 **명시적 문서화**(근거·대상·정합성 전략·롤백 플랜).
- 적용 전/후 **SLO 메트릭 비교**(p95/99 지연, CPU/IO, 락 경합).

---

## 핵심 기법 카탈로그와 SQL 패턴

### 인덱스 최적화(커버링/함수/부분/복합)

```sql
-- (주문상태, 주문일 내림차순) 자주 조회 → 정렬 포함 복합 인덱스
CREATE INDEX idx_order_status_dt ON "order"(status, ordered_at DESC);

-- 부분 인덱스(선택적) : 상태가 'PAID'인 행만 고속 접근
CREATE INDEX idx_order_paid ON "order"(ordered_at DESC) WHERE status = 'PAID';

-- 함수 인덱스(전화번호 정규화 예: DB별 문법 차이)
-- PostgreSQL 예시
CREATE INDEX idx_user_phone_norm ON app_user (regexp_replace(phone, '\D','','g'));
```

주의
- 인덱스는 **쓰기 비용**↑, **저장 공간**↑. 읽기/쓰기 균형에 맞춘다.
- **선두 컬럼 선택도 > 0.1** 이상일 때 효과적(대략적 감).

### 파티셔닝(시간/범위/해시)

```sql
-- PostgreSQL declarative partitioning (날짜 파티션)
CREATE TABLE event (
  id BIGSERIAL PRIMARY KEY,
  occurred_at timestamptz NOT NULL,
  payload jsonb NOT NULL
) PARTITION BY RANGE (occurred_at);

CREATE TABLE event_2025_11 PARTITION OF event
  FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
```

원칙
- **파티션 키는 실제 필터에 등장**해야 한다.
- 보존 정책(아카이빙/드롭) 자동화로 운영비용 절감.

### 캐싱/물질화 뷰/요약 테이블

```sql
-- 물질화 뷰(일별 매출) - PostgreSQL
CREATE MATERIALIZED VIEW daily_sales AS
SELECT order_date::date AS d, SUM(amount) AS revenue
FROM fact_order
GROUP BY 1;

-- 갱신
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_sales;
```

요약 테이블(트리거 유지):

```sql
CREATE TABLE daily_sales_sum (
  d date PRIMARY KEY,
  revenue numeric(18,2) NOT NULL DEFAULT 0
);

-- 주문 삽입/삭제 시 집계 반영 (DB별 성능/락 고려)
CREATE OR REPLACE FUNCTION f_upsert_daily_sales() RETURNS trigger AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO daily_sales_sum(d, revenue)
    VALUES (NEW.ordered_at::date, NEW.amount)
    ON CONFLICT (d) DO UPDATE SET revenue = daily_sales_sum.revenue + EXCLUDED.revenue;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE daily_sales_sum SET revenue = revenue - OLD.amount
    WHERE d = OLD.ordered_at::date;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_order_daily
AFTER INSERT OR DELETE ON "order"
FOR EACH ROW EXECUTE FUNCTION f_upsert_daily_sales();
```

주의
- 트리거는 **경합/락/복잡성**을 유발할 수 있다. 고QPS 환경에서는 **비동기 CDC/잡**이 유리하다.

### 반정규화 패턴

| 패턴 | 설명 | 장점 | 리스크 |
|---|---|---|---|
| 중복 컬럼 추가 | 조인 대상의 일부 속성 복제(예: 고객명) | 조인 감소 | 정합성 동기화 필요 |
| 테이블 병합 | 자주 조인되는 1:1/좁은 1:N 합치기 | I/O 감소 | 쓰기/잠금 충돌 가능 |
| 요약 테이블 | 집계 결과 저장 | 보고서 고속 | 유지 비용 |
| 프리컴퓨팅 | 파생 열/정규화된 값 저장 | CPU 절감 | 재계산 필요 |
| 컬럼형 스냅샷 | 조회 전용 컬럼화(OLAP) | 스캔 효율 | 동기화 빈도 |

적용 전 반드시 **대안 비교(인덱스, 파티션, 캐시)**를 수행한다.

### 트랜잭션 분리(핫/웜/콜드)

- **핫 테이블**: 최신·자주 갱신. 최소 컬럼·최소 인덱스.
- **웜 테이블**: 주기적 이동(예: 30일 경과 데이터).
- **콜드 테이블**: 아카이브/압축/오브젝트 스토리지.

마이그레이션 배치 예:

```sql
INSERT INTO order_history SELECT * FROM "order" WHERE ordered_at < now() - interval '90 days';
DELETE FROM "order" WHERE ordered_at < now() - interval '90 days';
VACUUM (VERBOSE, ANALYZE) "order"; -- PG 예
```

---

## 케이스 스터디: 커머스 핵심 쿼리 튜닝

### 문제 상황

- `고객 최근 30일 주문 합계` 대시보드가 p95=2.5s.
- 원인: 매번 `order + order_item` 풀스캔/집계.

### 단계적 개선

1) **인덱스 추가**
   - `order(status, ordered_at DESC)`, `order_item(order_id)`
   - p95 2.5s → 1.2s

2) **파티션**(월별)
   - 최근 파티션만 스캔, p95 1.2s → 0.7s

3) **요약 테이블**(`daily_customer_sales(customer_id, d, revenue)`)
   - 트리거 대신 **배치 + CDC**로 반영
   - 대시보드 쿼리: `SUM(revenue) WHERE d BETWEEN now()-30d`
   - p95 0.7s → 60ms

요약 테이블 DDL:

```sql
CREATE TABLE daily_customer_sales (
  customer_id BIGINT NOT NULL,
  d date NOT NULL,
  revenue numeric(18,2) NOT NULL,
  PRIMARY KEY (customer_id, d)
);
```

대시보드 쿼리:

```sql
SELECT customer_id, SUM(revenue) AS last30_revenue
FROM daily_customer_sales
WHERE d >= current_date - 30
GROUP BY customer_id
ORDER BY last30_revenue DESC
LIMIT 50;
```

---

## 보고서/집계성 워크로드 패턴(OLAP-on-OLTP 최소화)

- **분리 원칙**: OLTP 스키마에 과도한 스캔/집계를 강제하지 말고, **ETL/ELT로 별도 스토어**(DW/레이크/컬럼나)로 이동.
- **SCD Type 2**: 차원 변경 이력 유지(분석 정확도).
- **증분 로딩**: CDC(Change Data Capture) 또는 `updated_at` 기준.

간이 SCD2 예:

```sql
CREATE TABLE dim_product (
  sk_product BIGSERIAL PRIMARY KEY,
  product_id BIGINT NOT NULL,
  name TEXT NOT NULL,
  price NUMERIC(12,2) NOT NULL,
  effective_from timestamptz NOT NULL,
  effective_to   timestamptz,
  is_current boolean NOT NULL DEFAULT true,
  UNIQUE (product_id, effective_from)
);
```

---

## CQRS/이벤트 소싱 관점의 모델링

- **CQRS**: 쓰기 모델(정규화 중심)과 읽기 모델(반정규화/요약/검색 인덱스)을 **분리**한다.
- 이벤트 소싱: 이벤트 스트림으로 **파생 읽기 모델**을 **비동기 재구성**.
- 장점: 읽기 SLA에 최적화된 스키마 구성.
- 주의: **최종 일관성** 수용, 리플레이/보정 툴 필수.

---

## DBMS별 고려 포인트 요약

| 항목 | PostgreSQL | MySQL(InnoDB) | Oracle |
|---|---|---|---|
| 기본 인덱스 | B-Tree, GIN/GiST/BRIN | B-Tree | B-Tree |
| 부분 인덱스 | 지원 | 생성 시 조건 인덱스(기능 제한) | 함수 기반 인덱스/파티션 조합 |
| MVCC/청소 | VACUUM/Autovacuum | Purge/Undo | Undo/Segment 관리 |
| 물질화 뷰 | 지원 | 미지원(뷰+요약테이블) | MView 풍부 |
| 파티셔닝 | 선언형/다양 | RANGE/LIST/HASH | 매우 풍부 |
| 병렬 쿼리 | 있음 | 제한적 | 강력 |

---

## 반정규화 적용 체크리스트

- 성능 근거(실행계획·프로파일·락 경합)가 명확한가?
- 대안(인덱스/파티션/캐시/쿼리 재작성)이 실패했는가?
- 정합성 유지 메커니즘(트리거/잡/CDC/애플리케이션)이 설계되었는가?
- 롤백 플랜(DDL/데이터 이관/다운타임 창)이 존재하는가?
- 모니터링 지표(p95, p99, 쓰기 지연, 에러율)·알람이 준비되었는가?

---

## 마이그레이션 시나리오와 롤백

### 반정규화 컬럼 추가(고객명 스냅샷 예)

```sql
-- 1) 컬럼 추가
ALTER TABLE "order" ADD COLUMN customer_name_snapshot TEXT;

-- 2) 일괄 백필
UPDATE "order" o
SET customer_name_snapshot = c.name
FROM customer c
WHERE c.customer_id = o.customer_id;

-- 3) 트리거나 배치 동기화(권장: 배치/CDC)
-- 예: 변경 고객의 최근 30일 주문만 동기화
```

롤백
- 새 컬럼 무시/제거.
- 보고서/쿼리 복구.
- 데이터 정리 스크립트 유지.

### 요약 테이블 도입

- 테이블 생성→백필→읽기 전환(피쳐 플래그)→실시간 반영(잡/CDC)→검증→구 경로 제거.
- 롤백: 플래그 되돌림, 요약 테이블 삭제/중지.

---

## 락/동시성/격리수준과 성능 모델링

- **갱신 경합**이 있는 반정규화는 **행 잠금**과 **교착상태**를 유발 가능.
- 격리수준이 높을수록(예: SERIALIZABLE) **스루풋 저하**.
- **배치 크기/재시도/시간대 분산**으로 영향 완화.

---

## 테스트/벤치마크와 회귀 방지

### 마이크로 벤치마크 스케치

```sql
-- 쿼리 1: 원본 집계
EXPLAIN (ANALYZE, BUFFERS)
SELECT c.customer_id, SUM(oi.qty*oi.price_at)
FROM "order" o
JOIN order_item oi ON oi.order_id = o.order_id
JOIN customer c ON c.customer_id = o.customer_id
WHERE o.ordered_at >= now() - interval '30 days'
GROUP BY c.customer_id;

-- 쿼리 2: 요약 테이블
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, SUM(revenue)
FROM daily_customer_sales
WHERE d >= current_date - 30
GROUP BY customer_id;
```

수집 지표
- 실행시간, 공유버퍼 적중률, 읽은 블록 수, 정렬/해시 메모리 사용, 임시 디스크 사용.

### 회귀 방지

- 스키마 변경 시 **대표 쿼리 스냅샷**을 **CI에 포함**.
- 실사용 트래픽에서 **p95/99 지연** 변화 감시.

---

## 실무 패턴 모음(코드 중심)

### 커버링 인덱스(읽기 전용 핫 경로)

```sql
-- MySQL 예: (status, ordered_at, amount) 커버
CREATE INDEX idx_order_cover ON `order` (status, ordered_at, amount);
-- SELECT status, ordered_at, amount ... → 테이블 접근 회피
```

### BRIN 인덱스(대용량 시간열, PostgreSQL)

```sql
-- 범위 인덱스: 시간순 삽입 대량 테이블에 경량
CREATE INDEX idx_event_brin ON event USING brin (occurred_at);
```

### 읽기 모델 분리(CQRS)

```sql
-- 읽기 모델: 고객의 최근 30일 총액만 보관
CREATE TABLE customer_read_model (
  customer_id BIGINT PRIMARY KEY,
  last30_revenue NUMERIC(18,2) NOT NULL,
  updated_at timestamptz NOT NULL DEFAULT now()
);
```

갱신은 잡/이벤트 구독으로 수행.

---

## 안티패턴과 대안

| 안티패턴 | 문제 | 대안 |
|---|---|---|
| 조기 반정규화 | 정합성·유지보수 악화 | 인덱스/파티션/쿼리 재작성 우선 |
| 과도한 트리거 | 경합·디버깅 어려움 | CDC/배치로 비동기 반영 |
| 만능 UUID v4 PK | 인덱스 지역성 저하 | 시간정렬 UUID v7/ULID/시퀀스 |
| 광범위 SELECT * | I/O 증가, 커버링 무력 | 필요한 컬럼만 선택 |
| 인덱스 남발 | 쓰기 성능 급락 | Top-K 쿼리 기준, 주기 점검 |

---

## 운영 모니터링 쿼리 스니펫

```sql
-- PostgreSQL: 상위 느린 쿼리
SELECT query, calls, mean_exec_time, rows
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 잠금 대기
SELECT pid, locktype, relation::regclass, mode, granted, query
FROM pg_locks l JOIN pg_stat_activity a USING (pid)
WHERE NOT granted;

-- 인덱스 사용률
SELECT relname, idx_scan, seq_scan
FROM pg_stat_all_tables
ORDER BY (seq_scan + idx_scan) DESC;
```

---

## 종합 예제: 성능 중심 리팩토링 시나리오

### 초기(정규화 상태)

```sql
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name  TEXT NOT NULL
);

CREATE TABLE "order" (
  order_id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id),
  ordered_at timestamptz NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('PENDING','PAID','CANCELLED','SHIPPED','COMPLETED'))
);

CREATE TABLE order_item (
  order_id BIGINT NOT NULL REFERENCES "order"(order_id),
  line_no INT NOT NULL,
  product_id BIGINT NOT NULL,
  qty INT NOT NULL CHECK (qty > 0),
  price_at NUMERIC(12,2) NOT NULL,
  PRIMARY KEY (order_id, line_no)
);
```

### 튜닝 단계

1) 인덱스
```sql
CREATE INDEX idx_order_customer_dt ON "order"(customer_id, ordered_at DESC);
CREATE INDEX idx_item_order ON order_item(order_id);
```

2) 파티션(월별)
3) 요약 테이블(`daily_customer_sales`) 도입
4) 읽기 API를 요약 테이블로 전환(피처 플래그)
5) 모니터링으로 회귀 감시

---

## 결론

- **성능 데이터 모델링**은 정규화를 토대로 **핵심 쿼리의 비용을 구조적으로 낮추는 설계 행위**다.
- 우선순위는 **인덱스/통계/파라미터/쿼리 재작성/파티션/캐시**이고, 반정규화는 **측정된 병목**에서만 **최소 단위**로 적용한다.
- 적용 시 **정합성 유지/마이그레이션/모니터링/회귀 방지**까지 포함한 **운영 시나리오**가 반드시 필요하다.
- 성능과 정합성은 **균형의 대상**이다. 팀 표준과 자동화를 통해 **지속 가능한 성능**을 달성하라.
