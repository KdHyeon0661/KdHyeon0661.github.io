---
layout: post
title: JavaScript - 메모리 관리와 가비지 컬렉션
date: 2025-04-28 22:20:23 +0900
category: JavaScript
---
# 자바스크립트의 메모리 관리와 가비지 컬렉션 (GC)

**핵심 요약**  
자바스크립트는 자동 메모리 관리(가비지 컬렉션, GC)를 사용하는 언어입니다. 그러나 “자동”이 곧 “문제 없음”을 뜻하지 않습니다. **도달 가능성(reachability)** 규칙, **세대별/증분/동시 마킹** 같은 최신 GC 기법, **약한 참조(Weak\*) 계열과 파이널라이저**, 그리고 **SPA에서 빈번한 누수 패턴**을 이해해야 실전에서 안전하고 빠른 앱을 만들 수 있습니다.

---

## 1. 메모리 모델과 실행 컨텍스트

### 1.1 스택(Stack)과 힙(Heap)
- **스택**: 고정 크기/수명 짧은 데이터(활성 레코드, 원시값, 참조의 포인터)가 주로 위치합니다.
- **힙**: **객체/배열/함수/클로저 환경**처럼 크기가 가변적인 참조형이 저장됩니다.

```js
let a = 10;                 // 스택: 숫자 자체
let obj = { x: 1 };         // 스택: obj(힙 객체의 참조), 힙: {x:1} 객체
const arr = [1, 2, 3];      // 스택: arr 참조, 힙: 배열·요소
```

### 1.2 실행 컨텍스트와 클로저
- 함수가 호출되면 **실행 컨텍스트**가 생성되고, 변수 환경/렉시컬 환경/this 바인딩이 만들어집니다.
- **클로저**는 렉시컬 환경을 포획해 힙에 보존합니다. 이 구조는 의도치 않게 큰 데이터를 오래 붙잡아 **누수의 뿌리**가 되기 쉽습니다.

```js
function maker() {
  const big = new Array(1_000_000).fill('x'); // 대용량
  return () => big[0]; // big을 캡처 → maker() 결과가 살아있는 동안 해제 불가
}
const f = maker();
// big은 f가 수거될 때까지 GC 불가
```

---

## 2. GC의 근본 규칙과 루트 집합

### 2.1 도달 가능성(Reachability)
**루트(root)** 로부터 **참조 그래프를 따라 도달 가능한 객체**는 살아 있다고 간주됩니다.
- 브라우저: `window`(글로벌), 현재 콜스택의 지역 변수, DOM 루트 등
- Node.js: `global`, 모듈 스코프 변수, 네이티브 핸들 등이 루트

```js
let user = { name: 'Alice' };
user = null;  // 더 이상 어떤 루트에서 참조하지 않음 → GC 후보
```

### 2.2 “참조 카운팅” vs “마크-스위프”
- **참조 카운팅**: 순환 참조 누수 문제가 있음. 현대 JS 엔진의 주력은 아님.
- **마크-스위프(Mark & Sweep)**: 루트에서 그래프를 마킹하고, 도달 불가 객체를 스위프(해제)합니다.

---

## 3. 현대 JS 엔진의 GC 알고리즘(개요)

### 3.1 세대별(Generational) GC
- **Nursery(young)**: 새 객체가 먼저 배치. 대부분 짧은 생명 → **빈번히 수거**(Minor GC).
- **Tenured(old)**: 반복해서 생존하는 객체는 승격(promote) → **덜 자주 수거**(Major GC).
- 장점: 젊은 세대는 작고 포인터 검사도 적어 **짧고 빠른** GC 주기가 가능.

### 3.2 증분(Incremental) & 동시(Concurrent) 마킹
- 한 번에 모든 힙을 멈추는 대신, **작게 쪼개서**(incremental) 또는 **어플리케이션 스레드와 병행**(concurrent)으로 마킹하여 **Stop-the-World** 시간을 줄입니다.

### 3.3 삼색 마킹(Tricolor) 모델(개념)
- **흰색**(미방문) / **회색**(발견됐으나 자식 미처리) / **검정**(완전 처리).
- **write barrier**로 실행 중 참조 변경을 엔진이 추적해 **마킹 정확성**을 유지합니다.

> 구현 세부는 엔진별로 차이가 있지만, 위 개념이 성능-정확성 트레이드오프를 이해하는 기초입니다.

---

## 4. 누수(Leak) 유형과 재현 코드

### 4.1 암묵적 전역
```js
function leak() {
  leaked = "I am global"; // var/let/const 누락 → window.leaked 생성
}
// 전역 루트가 계속 잡고 있어 GC 불가
```
**해결**: 반드시 `use strict` + `let/const` 사용.

### 4.2 이벤트 리스너 누락
```js
const btn = document.getElementById('go');
function onClick() { /* 큰 클로저 캡처 */ }
btn.addEventListener('click', onClick);

// DOM에서 버튼을 제거했지만
// btn 변수/리스너가 살아있으면 메모리 유지
```
**해결**: 컴포넌트 해제 시 `removeEventListener` 또는 **AbortController**로 일괄 취소.

```js
const controller = new AbortController();
btn.addEventListener('click', onClick, { signal: controller.signal });
// 해제
controller.abort();
```

### 4.3 타이머/인터벌 누락
```js
const t = setInterval(() => {/* heavy */}, 1000);
// 화면 전환/언마운트에서 clearInterval 누락 → 누수
```

### 4.4 Detached DOM
```js
let stash = [];
function createAndDrop() {
  const el = document.createElement('div');
  document.body.appendChild(el);
  document.body.removeChild(el);
  stash.push(el); // JS 배열이 참조 유지 → 수거 불가
}
```

### 4.5 클로저가 거대한 컨텍스트 포획
```js
function mount() {
  const big = new ArrayBuffer(10_000_000);
  window.addEventListener('resize', () => {
    // big을 암묵적으로 캡처 → 이벤트 수명만큼 유지
    console.log(big.byteLength);
  });
}
```
**해결**: 콜백에 필요한 **최소 데이터만** 캡처하거나, 바깥을 **약참조(WeakRef)**나 **토큰**으로 들고 필요 시 재획득.

---

## 5. 약한 참조 도구(Weak\*)와 파이널라이저

### 5.1 WeakMap / WeakSet
- 키(WeakMap)·원소(WeakSet)는 **객체 전용**, **약참조**, **열거 불가**.
- 대상이 외부에서 더 이상 참조되지 않으면 **자동 제거** → **메타/캐시** 보관에 적합.

```js
const meta = new WeakMap();

function attach(node, info) { meta.set(node, info); }
function infoOf(node) { return meta.get(node); }

// DOM 노드 수거되면 메타도 자동 해제
```

### 5.2 WeakRef
- **대상 객체를 약하게 가리키는 래퍼**. `deref()`로 살아 있으면 대상 반환, 아니면 `undefined`.
- 캐시/뷰모델 등에서 **소프트 캐시** 패턴에 사용. “언제든 사라질 수 있음”을 항상 전제.

```js
const cache = new Map(); // key -> WeakRef(value)

function getOrCreate(key, make) {
  const ref = cache.get(key);
  const val = ref?.deref();
  if (val) return val;
  const fresh = make();
  cache.set(key, new WeakRef(fresh));
  return fresh;
}
```

### 5.3 FinalizationRegistry
- 대상이 **GC로 수거된 뒤** 언젠가 콜백을 받는 메커니즘. **결정적 시점 보장 X**.
- 로깅/통계/보조 인덱스 정리용. 파일/소켓 같은 **즉시성 자원 해제**에는 부적합.

```js
const reg = new FinalizationRegistry(tag => {
  console.log('collected:', tag);
});

let obj = { };
reg.register(obj, 'obj#1'); // 추적

obj = null; // 수거되면 언젠가 콜백
```

---

## 6. 진단 워크플로(브라우저/Node)

### 6.1 Chrome DevTools — Heap Snapshot
1) **Memory 탭 → Heap snapshot** 촬영  
2) 사용자 시나리오 수행(탭 전환/리스트 스크롤 등)  
3) **비교(Comparison)** 로 새 스냅샷과 차이 확인  
4) **Dominators**로 누수 뿌리, **Retainers**로 보유 체인 추적  
5) `Detached HTMLDivElement` 등 수거 안 되는 DOM 확인

### 6.2 Allocation Instrumentation/Sampling
- **Performance** 또는 **Memory**에서 할당 타임라인 분석 → 누가 얼마를 언제 할당했는지 콜스택과 함께 확인.

### 6.3 강제 GC(테스트 전용)
- `chrome://flags` → **Expose GC** 활성화 후 `window.gc()`로 실험.
- 강제 GC 후에도 힙 사용량이 **계속 상승**하면 구조적 누수 가능성↑.

### 6.4 Node.js
- `node --inspect`로 DevTools 연결 → 스냅샷/프로파일링.
- `heapdump` 모듈로 덤프 저장, 오프라인 분석.

---

## 7. 실전 최적화 레시피와 체크리스트

### 7.1 생명주기 기반 정리(컴포넌트/페이지 전환)
- [ ] 이벤트 리스너: **removeEventListener** 혹은 **AbortSignal**로 일괄 취소
- [ ] 타이머/인터벌: **clearTimeout/clearInterval**
- [ ] 옵저버: `Intersection/Resize/MutationObserver` → **disconnect()**
- [ ] WebSocket/스트림: **close()/abort()**
- [ ] Blob/URL: **URL.revokeObjectURL()**

```js
class Scoped {
  cbs = [];
  on(target, type, fn, opts) {
    target.addEventListener(type, fn, opts);
    this.cbs.push(() => target.removeEventListener(type, fn, opts));
  }
  timer(id) { this.cbs.push(() => clearInterval(id)); }
  clear() { for (const f of this.cbs.splice(0)) f(); }
}
```

### 7.2 클로저 다이어트
- 콜백이 포획하는 캡처 목록을 **필요 최소**로 유지.
- 대형 데이터는 **ID만** 보유하고, 필요 시 **맵/스토어**에서 재조회.

```js
const store = new Map(); // id -> heavy
function handlerFactory(id) {
  return () => {
    const heavy = store.get(id); // 필요시 획득
    // ...
  };
}
```

### 7.3 캐시 정책
- 영구 증가 방지: **TTL/LRU** 또는 **WeakRef 소프트 캐시**.
- 이미지/문서 파싱 캐시는 **키 공간 제한**과 **정기 트림**을 도입.

```js
class LRU {
  constructor(limit=100) { this.limit=limit; this.map=new Map(); }
  get(k){ const v=this.map.get(k); if(v){ this.map.delete(k); this.map.set(k,v); } return v; }
  set(k,v){ if(this.map.has(k)) this.map.delete(k); this.map.set(k,v);
    if(this.map.size>this.limit){ const [old]=this.map.keys(); this.map.delete(old); } }
}
```

### 7.4 DOM/가상 DOM
- 가상 스크롤/리스트에서 **키**를 안정적으로 부여해 **노드 재사용**을 높이고, 떠돌이 참조 방지.
- Portals/외부 DOM 결합 시 **정리 훅**을 명확히.

### 7.5 대량 객체 생성 억제
- 단일 렌더 사이클에서 수만 개 객체/클로저 생성은 피하고 **배치(batch)** 처리.
- 빈번한 문자열 결합 대신 **버퍼/배열 join** 활용.

---

## 8. 성능과 GC 상호작용 이해

### 8.1 Stop-the-World와 프레임 드롭
- 큰 Major GC는 렌더링과 JS 실행을 멈추게 할 수 있음.  
- **할당 폭주**(짧은 시간 대량 객체 생성)는 **GC 압력↑ → 끊김**으로 이어짐.

### 8.2 Minor GC 친화적 코드
- **임시 객체**를 너무 오래 보관하지 않기 → **young 세대에서 사라지도록**.
- 대용량 객체를 반복 재사용(**객체 풀링**)은 JS에서 대체로 **권장되지 않지만**, 특정 핫패스에서만 **측정 후 적용**.

---

## 9. 실습: 메모리 증감 관찰 스니펫

### 9.1 의도적 누수와 수거
```js
let leak = [];
function alloc(n = 10000) {
  for (let i=0;i<n;i++) leak.push({ i, pad: 'x'.repeat(100) });
}
function free() { leak = []; }        // 루트 참조 제거
```

### 9.2 프레임 드롭 유발 패턴(피할 것)
```js
function burst() {
  const arr = [];
  for (let i=0;i<200000;i++) arr.push({ i });
  // 대량 할당 → Minor/때로 Major GC 압박
}
```

---

## 10. 도구별 절차 정리(요약)

| 요구 | 절차 |
|---|---|
| 누수 의심 | Performance로 장시간 레코딩 → 메모리 라인이 회복하지 않으면 의심 |
| 원인 추적 | Memory 탭 Heap Snapshot 2회 비교 → Dominators/Retainers 분석 |
| 시점 파악 | Allocation instrumentation → 어떤 이벤트 후 급증하는지 확인 |
| DOM 누수 | Class filter: `Detached`로 필터, 보유 체인에 남아있는 참조 원인 제거 |
| 회귀 방지 | e2e 스크립트 + 힙 사용량 가드(기준선 초과 알림) |

---

## 11. 체크리스트(프로덕션 준비)

- [ ] 엄격 모드/린트로 **암묵적 전역 금지**
- [ ] 컴포넌트 언마운트에서 **이벤트/타이머/옵저버/스트림** 정리
- [ ] fetch/스트림은 **AbortController**로 취소 경로 확보
- [ ] Blob/미디어 URL은 **revokeObjectURL**
- [ ] 장수 Map/Set 대신 **WeakMap/WeakRef** 또는 **TTL/LRU** 캐시
- [ ] 클로저가 **대형 구조**를 잡지 않도록 설계
- [ ] DevTools **스냅샷 비교**를 정기적으로 수행
- [ ] Third-party 위젯 **destroy/teardown** 호출 경로 검증

---

## 12. 미니 퀴즈

```js
// Q1: 아래에서 GC가 big을 수거할 수 있는 시점은?
function make() {
  const big = new Uint8Array(10_000_000);
  return () => big[0];
}
const f = make();
// A) 즉시  B) f가 도달 불가가 될 때  C) 브라우저를 닫을 때

// Q2: 어떤 줄이 누수 원인?
const el = document.createElement('div');
document.body.appendChild(el);
const meta = new Map();
meta.set(el, { heavy: '...' });
document.body.removeChild(el);
// A) appendChild B) set C) removeChild D) Map가 전역에 살아있음

// Q3: WeakMap/WeakRef 중 열거 가능한 것은?
// A) WeakMap  B) WeakRef  C) 둘 다 불가  D) WeakRef만 가능

// Q4: FinalizationRegistry 용도 적절한 것은?
// A) 파일 핸들 즉시 닫기
// B) 로깅/통계
// C) 데이터 무결성 보장 로직
```

**정답 힌트**  
- Q1: **B** (클로저가 big을 붙잡음 → f가 사라질 때)  
- Q2: **D** (전역의 Map이 el을 붙잡아 Detached DOM이 유지)  
- Q3: **C** (둘 다 열거/크기 파악 불가)  
- Q4: **B** (비결정적 타이밍 → 즉시성/결정성 요구 작업 부적절)

---

## 13. 결론

- JS의 GC는 **도달 가능성**을 기준으로 동작하며, 현대 엔진은 **세대별/증분/동시 마킹**으로 지연을 줄입니다.  
- 누수는 **루트에서 이어진 참조 체인**이 끊어지지 않아 발생합니다. **이벤트/타이머/옵저버/클로저/캐시**가 주범입니다.  
- **WeakMap/WeakRef/FinalizationRegistry**는 “대상 수명에 종속되는 상태/캐시/로깅”에 유용하지만, **결정적 정리**는 **명시적 클린업**이 정답입니다.  
- DevTools의 **스냅샷·할당 타임라인**과 **체크리스트**를 통한 **주기적 검증**이 프로덕션 안정성을 좌우합니다.