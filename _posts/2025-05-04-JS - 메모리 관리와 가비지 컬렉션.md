---
layout: post
title: JavaScript - 메모리 관리와 가비지 컬렉션
date: 2025-04-28 22:20:23 +0900
category: JavaScript
---
# 🧠 자바스크립트의 메모리 관리와 가비지 컬렉션

자바스크립트는 메모리를 **자동으로 할당하고 해제**해주는 **Garbage Collected Language**입니다.  
하지만 자동이라고 해도, 우리가 어떤 식으로 변수를 사용하고 참조하느냐에 따라 **메모리 누수(Memory Leak)**가 발생할 수 있습니다.

이 글에서는 자바스크립트의 **메모리 구조**, **가비지 컬렉션 동작 방식**, **메모리 누수 예시 및 방지법**을 자세히 다룹니다.

---

## 📦 1. 자바스크립트의 메모리 구조

### 🔹 메모리는 크게 두 가지 영역으로 나뉩니다:

| 영역      | 설명 |
|-----------|------|
| **스택(Stack)** | 원시값(Primitive) 저장: `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`, `string` |
| **힙(Heap)**     | 참조형(객체, 배열, 함수 등) 저장. 크기가 동적이거나 복잡한 데이터 |

```js
let a = 10;           // 스택에 저장 (값 자체)
let obj = { x: 1 };   // obj는 스택에, 실제 데이터는 힙에 저장됨
```

---

## 🗑️ 2. 가비지 컬렉션(Garbage Collection)이란?

> 사용하지 않는 메모리를 자동으로 해제하여 메모리 누수를 방지하는 기능입니다.

자바스크립트는 개발자가 직접 메모리를 해제하지 않아도 되도록, **가비지 컬렉터(GC)**가 이를 자동으로 처리합니다.

---

## 🔁 3. 가비지 컬렉션의 동작 원리

### 🔸 📌 기본 원칙: "도달할 수 없는(unreachable)" 객체를 제거

> 더 이상 **어떤 곳에서도 참조되지 않는 객체**는 메모리에서 제거됨

```js
let user = {
  name: "Alice"
};

user = null; // 객체를 참조하는 변수가 사라짐 → GC 대상
```

---

### 🔸 📌 참조 카운트 방식 (과거 방식, 일부 언어에서 사용)

- **객체를 참조하는 횟수**로 판단
- 순환 참조에서 누수가 발생할 수 있음

```js
let a = {};
let b = {};
a.ref = b;
b.ref = a;

// 둘 다 참조되므로 GC되지 않음 → 순환 참조
```

---

### 🔸 📌 마크 앤 스위프(Mark & Sweep) – 현재 JS 엔진의 방식

> 대부분의 브라우저(V8, SpiderMonkey 등)는 **“마크 앤 스위프” 알고리즘**을 사용

1. **루트(Root)**에서 시작 (예: 전역 변수, 실행 중 함수의 지역 변수 등)
2. 루트에서 접근 가능한 모든 객체에 “도달 가능(marked)” 표시
3. 도달하지 못한 객체는 **GC 대상**으로 판단 후 제거

```text
전역 객체 → 참조 객체 A → 참조 객체 B → ... (트리 탐색)
```

---

## 🧪 4. 메모리 누수(Memory Leak)의 예시

### 🔹 전역 변수 사용

```js
function leak() {
  leakedVar = "I'm global"; // var, let, const 없이 선언 → window에 저장
}
```

### 🔹 DOM 요소 참조 유지

```js
const button = document.getElementById("myButton");

button.addEventListener("click", () => {
  console.log("clicked");
});
// 버튼이 DOM에서 제거돼도 참조가 남아있다면 GC되지 않음
```

### 🔹 클로저 사용 시 변수 유지

```js
function create() {
  let bigData = new Array(1000000).fill("🧠");
  return function () {
    console.log(bigData[0]);
  };
}

const keep = create();
// bigData는 계속 참조되므로 GC 대상이 아님
```

---

## ✅ 5. 메모리 누수 방지 전략

| 전략 | 설명 |
|------|------|
| 전역 변수 지양 | `let`, `const` 사용 필수 |
| 이벤트 리스너 해제 | DOM 제거 전 `removeEventListener()` 호출 |
| 타이머/인터벌 해제 | `clearTimeout`, `clearInterval` 호출 |
| 클로저에 불필요한 변수 담지 않기 | 꼭 필요한 데이터만 유지 |
| 객체 참조 해제 | 필요 없어진 참조는 `null` 할당 |

---

## 🔍 6. 개발 도구로 메모리 확인

### 🔸 크롬 개발자 도구

1. `F12 → Memory 탭`
2. Heap Snapshot 찍기
3. Retainers → 어떤 객체가 참조되고 있는지 확인
4. Detached DOM Tree → DOM에서 제거되었지만 메모리에 남은 요소들 탐색 가능

---

## 🧠 7. GC는 언제 발생하나?

- **정확한 시점은 비결정적(nondeterministic)**
- 메모리 사용량, CPU 부하, 힙의 크기 등을 기준으로 **엔진이 판단**
- 수동으로 제어할 수 없음

---

## ✅ 8. 요약

| 항목 | 설명 |
|------|------|
| 스택 vs 힙 | 원시값은 스택, 참조값은 힙 |
| GC 원칙 | 도달할 수 없는 객체 제거 |
| 알고리즘 | 마크 앤 스위프 (Mark & Sweep) |
| 누수 예시 | 전역 변수, 이벤트 미해제, 클로저 남용 |
| 방지법 | 참조 제거, 이벤트 해제, 메모리 분석 도구 활용 |

---

## 📌 마무리

자바스크립트는 자동으로 메모리를 관리해주지만, 개발자의 코드 스타일에 따라 **메모리 누수**가 발생할 수 있습니다.  
**참조를 해제하지 못하거나**, **불필요한 데이터를 계속 유지하는 것**은 GC의 대상이 되지 않기 때문에,  
**코드 구조를 명확히 하고 적절한 참조 해제와 이벤트 정리를 통해 메모리 사용을 최적화**해야 합니다.