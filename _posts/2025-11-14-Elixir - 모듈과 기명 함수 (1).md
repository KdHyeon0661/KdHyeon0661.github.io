---
layout: post
title: Elixir - 모듈과 기명 함수 (1)
date: 2025-11-14 20:25:23 +0900
category: Elixir
---
# 엘릭서 6장 — 모듈 컴파일, 블록, 함수 호출과 패턴 매칭

## 6.1 모듈 컴파일하기

엘릭서의 모듈은 크게 다음 단계로 흐른다.

1. **소스 파일**: `*.ex`, `*.exs`  
2. **컴파일**: `.ex` → `Elixir.MyModule.beam`  
3. **BEAM 코드 경로(Code Path)** 에 `.beam` 이 적재  
4. 런타임에서 `MyModule.function/arity` 호출

간단히 그림으로 나타내면:

```text
my_app/lib/math.ex
        |
        |  (elixirc / mix compile)
        v
_build/dev/lib/my_app/ebin/Elixir.Math.beam
        |
        |  (BEAM VM code path)
        v
런타임에서 Math.add/2, Math.mul/2 호출
```

이 섹션에서는 `.ex` / `.exs`의 차이, 단일 파일 컴파일, Mix 프로젝트에서의 컴파일과 코드 경로, 모듈 속성·가드·매크로, `alias/import/require/use`, 컴파일 타임 vs 런타임을 자세히 본다.

---

### 6.1.1 .ex vs .exs, 단일 파일 컴파일

엘릭서 파일 확장자는 크게 두 가지다.

| 확장자 | 의도/용도 | 특징 |
|--------|-----------|------|
| `.ex`  | 라이브러리/프로덕션 코드 | 컴파일 대상, `.beam` 산출 |
| `.exs` | 스크립트, 테스트, 유틸리티 | 실행 시점에 컴파일 후 바로 버림 |

#### 6.1.1.1 단일 파일 컴파일

`math.ex` 파일이 있다고 하자.

```elixir
# math.ex
defmodule Math do
  @moduledoc "간단 산술 예제"

  def add(a, b), do: a + b
  def mul(a, b), do: a * b
end
```

이걸 직접 컴파일하면:

```bash
elixirc math.ex
```

- 현재 디렉토리에 `Elixir.Math.beam` 파일이 생성된다.
- BEAM VM은 이 디렉토리를 코드 경로에 포함해야 모듈을 찾을 수 있다.

같은 디렉토리에서 IEx를 켠 뒤:

```bash
iex
iex> c("math.ex")          # IEx에서 직접 컴파일
[Math]
iex> Math.add(1, 2)
3
```

- `c/1` 는 IEx에서만 사용 가능한 “컴파일” 헬퍼다. `.beam` 파일을 생성하고 곧바로 로드한다.

#### 6.1.1.2 .exs 스크립트 실행

스크립트 파일 `script.exs`:

```elixir
# script.exs
IO.puts("Hello from script")

defmodule ScriptMath do
  def add(a, b), do: a + b
end

IO.puts("1 + 2 = #{ScriptMath.add(1, 2)}")
```

실행:

```bash
elixir script.exs
```

- `script.exs`는 실행 시 **메모리에서 컴파일 후 즉시 실행**하고,  
  별도의 `.beam` 파일은 남기지 않는다.
- 스크립트 내 모듈은 해당 프로세스 안에서만 유효하다.

실무 관점:

- **라이브러리/앱 코드**: `.ex` (Mix 프로젝트 `lib/` 안)  
- **실험/원오프/툴**: `.exs` (`scripts/`, `priv/` 등에서 `elixir`로 실행)

---

### 6.1.2 Mix 프로젝트에서 컴파일/실행

실제 프로젝트에서는 보통 Mix를 이용한다.

```bash
mix new demo --sup
cd demo
```

생성 구조(요약):

```text
demo/
  lib/
    demo.ex
  mix.exs
  test/
  config/
```

#### 6.1.2.1 컴파일

```bash
mix compile
```

- `lib/**/*.ex` 를 스캔하여 **변경된 파일만 증분 컴파일**한다.
- 산출물은 보통 `_build/dev/lib/앱이름/ebin/*.beam` 에 쌓인다.
- 의존성(deps)도 함께 컴파일된다.

#### 6.1.2.2 실행 + IEx

```bash
iex -S mix
```

- `mix run --no-halt` 는 앱을 실행만 하고 끝내지 않는다.
- `iex -S mix` 는  
  1) `mix run` 으로 앱/의존성 부트  
  2) 그 위에 IEx를 올려 **실행 중인 시스템에 붙는다.**

실무 개발 루프는 보통:

1. 에디터에서 `lib/*.ex` 수정  
2. 터미널의 `iex -S mix` 세션에서  

   ```elixir
   iex> recompile()
   :ok
   ```

3. 새로운 코드 호출

이때 `recompile/0`는 **마지막 컴파일 이후 변경된 모듈만** 다시 컴파일한다.

---

### 6.1.3 코드 경로와 재컴파일, 모듈 로딩 확인

BEAM VM은 “코드 경로(code path)”라 불리는 디렉토리 집합에서 `.beam`을 찾는다.

IEx에서 확인해보자:

```elixir
iex> :code.get_path()
['/usr/local/elixir/lib/.../ebin', ...]
```

특정 모듈이 어디에서 로딩됐는지:

```elixir
iex> :code.which(Math)
:/absolute/path/to/_build/dev/lib/demo/ebin/Elixir.Math.beam
```

단일 파일을 로드할 때:

```elixir
iex> c("math.ex")      # 컴파일 + 로드
[Math]
iex> r Math            # 이미 로드된 모듈 재컴파일 + 재로딩
{:reloaded, Math, [... old_version ...]}
```

- `r/1` 은 IEx 특화 “reload” 헬퍼다. 개발 중 간단한 실험에 자주 사용한다.
- Mix 프로젝트에서는 `recompile/0` 를 통해 **프로젝트 전체의 변경 모듈**을 다시 올리는 것이 일반적이다.

---

### 6.1.4 모듈 속성, 문서, 가드, 매크로 준비

모듈 안에서는 다양한 “속성(attribute)”을 선언할 수 있다.

```elixir
defmodule Guide do
  @moduledoc """
  모듈 설명. ExDoc, IEx h/1, Doctest에 노출된다.
  """

  @version "1.0.0"                   # 컴파일 타임 상수처럼 쓰이는 속성
  @external_resource "data/schema.json"

  @doc "버전을 문자열로 반환"
  def version, do: @version

  defguard is_pos_int(x) when is_integer(x) and x > 0

  @doc """
  양의 정수 제곱을 구한다.

      iex> Guide.square(3)
      9
  """
  def square(x) when is_pos_int(x), do: x * x
end
```

각 속성의 의미:

- `@moduledoc`  
  - 모듈의 전반적인 설명.  
  - IEx에서 `h Guide` 로 확인 가능.
- `@doc`  
  - 특정 함수/매크로에 대한 설명.  
  - ExDoc 문서화, `h Guide.square` 에 노출된다.
- `@version`  
  - 단순 문자열이지만, 컴파일 시점에 고정된 상수처럼 쓰인다.  
  - 여러 함수에서 동일 값 사용할 때 유용.
- `@external_resource`  
  - 이 모듈이 의존하는 외부 파일(예: JSON 스키마, 템플릿 파일)을 나타냄.  
  - 빌드 도구가 이를 보고 외부 파일 변경 시 모듈 재컴파일을 유도할 수 있다.
- `defguard`  
  - 가드에서 재사용 가능한 술어를 정의.  
  - “양의 정수” 같은 개념을 이름 붙여 관리할 수 있다.

Doctest를 쓰면 `@doc` 안의 예제가 실제 테스트로 실행되어  
문서와 구현이 어긋나지 않았는지 검증할 수 있다.

---

### 6.1.5 `alias` / `import` / `require` / `use`

모듈에서 외부 모듈을 사용할 때 네 가지 키워드가 반복해서 나온다.

| 키워드   | 목적 | 주요 대상 |
|----------|------|-----------|
| `alias`  | 긴 모듈 이름 축약 | 모듈 |
| `import` | 모듈 함수/매크로를 현재 스코프로 가져오기 | 주로 함수 |
| `require`| 매크로 호출 전에 “필수” | 매크로 포함 모듈 |
| `use`    | `__using__/1` 매크로를 통해 보일러플레이트 삽입 | 프레임워크/행동 추가 |

예제:

```elixir
defmodule UseLib do
  alias Enum, as: E
  import List, only: [flatten: 1]
  require Logger
  use GenServer

  def flat(xs), do: flatten(xs)
  def twice(xs), do: E.map(xs, &(&1 * 2))

  def log(msg), do: Logger.info(msg)
end
```

- `alias Enum, as: E`  
  - `Enum.map` 대신 `E.map` 등으로 짧게 쓸 수 있다.
- `import List, only: [flatten: 1]`  
  - `List.flatten/1` 을 현재 모듈에서 `flatten/1`로 호출할 수 있다.  
  - 너무 많은 함수를 import하면 “이 함수가 어디서 왔는지” 모호해지므로 주의.
- `require Logger`  
  - `Logger.info/1` 는 사실 매크로이므로, 매크로를 호출하기 전에 `require`가 필요하다.
- `use GenServer`  
  - `GenServer` 모듈이 제공하는 `__using__/1` 매크로가 실행되어  
    기본 콜백/보일러플레이트 코드가 삽입된다.

요약하면:

- **이름 짧게**: `alias`  
- **함수/매크로 직접 사용**: `import`  
- **매크로 강제 로딩**: `require`  
- **행동 입히기/프레임워크 훅**: `use`

---

### 6.1.6 컴파일 타임 vs 런타임, 매크로의 위치

엘릭서는 **컴파일 타임에 실행되는 코드(매크로)** 와  
**런타임에 실행되는 코드(함수)** 를 명확히 구분한다.

#### 6.1.6.1 간단 매크로 예제

```elixir
defmodule M do
  defmacro say(expr) do
    quote do
      IO.puts("=> " <> to_string(unquote(expr)))
    end
  end
end

defmodule App do
  require M

  def run do
    M.say(1 + 2)
    :ok
  end
end
```

- `M.say(1 + 2)` 호출 시,  
  1) 컴파일 타임에 `say/1` 매크로가 실행되고  
  2) `quote` 블록이 “실제 코드”로 확장된다.  
- 즉, 소스 코드가 **변환/생성된 뒤 컴파일**된다.

매크로를 사용하면 DSL 구현이나 반복적인 패턴 제거가 가능하지만:

- 디버깅이 어렵고  
- 코드 흐름 파악이 힘들 수 있다.

실무 팁:

- 가능한 한 **함수/데이터**로 해결한다.  
- “문법을 확장해야만 하는” 경우에만 매크로를 선택한다.

---

### 6.1.7 개발 루프, 컴파일 속도, 테스트 통합

실제 개발 루프는 대략 다음 흐름을 가진다.

1. 에디터에서 `lib/*.ex` 수정  
2. `mix test` 혹은 `mix test test/some_test.exs:42` 로 관련 테스트를 빠르게 실행  
3. 장기 실행 서버를 띄우고 있다면 `iex -S mix` 에서 `recompile/0` 호출  
4. 적절한 평가 코드 실행, `IO.inspect/2` 로 중간값 확인

테스트와 컴파일은 밀접하게 연결되어 있다.

```bash
mix test           # 전체 테스트
mix test test/a.exs test/b.exs
mix test test/a.exs:42    # 특정 라인만
```

테스트 실행 시에도 내부적으로 컴파일이 수행되므로,  
“코드를 바꾼 뒤 아무 것도 컴파일 안 했다”는 상황은 Mix 프로젝트에서는 거의 없다.

---

### 6.1.8 자주 나오는 컴파일 관련 실수

1. **`alias/import/require/use`의 역할 혼동**

   - 매크로 호출인데 `require`를 빼먹는다.  
   - 프레임워크에서 `use` 해야 할 곳에 `import` 만 한다.

2. **`.ex` / `.exs` 혼용**

   - 스크립트용 코드를 `.ex` 로 두고 `mix compile`에 끌려 들어와 의도치 않게 빌드됨.  
   - 반대로, 라이브러리 코드를 `.exs` 로 두어 테스트에서만 동작하고 앱에서는 누락.

3. **외부 리소스 변경에 따른 재컴파일 누락**

   - JSON/템플릿 변경 후에도 모듈이 재컴파일되지 않아,  
     런타임에 예전 데이터가 쓰이는 문제.  
   - `@external_resource` 로 의존성을 명시해 두면 이런 상황을 줄일 수 있다.

4. **매크로 남용**

   - 단순한 반복/패턴 제거도 매크로로 구현해버려  
     코드가 읽기 어려워지는 경우.  
   - “함수로도 충분히 표현 가능한데 굳이 매크로를 썼는지” 항상 점검해야 한다.

---

## 6.2 함수의 본문은 블록이다

엘릭서의 함수 본문은 항상 **블록(do … end)** 이다.

- 세미콜론 대신 **줄바꿈**으로 표현식을 나눈다.
- **마지막 표현식의 값**이 함수의 반환값이 된다.
- `if`/`case`/`cond`/`with` 도 모두 **값을 내는 표현식**이다.

즉, 엘릭서는 “문(statement)”보다는 **표현식(expression)** 중심의 언어다.

---

### 6.2.1 블록 반환 규칙과 `do:` 단축 표기

기본 형태:

```elixir
defmodule Blocks do
  # 단일 표현식일 때: 단축 표기
  def add(a, b), do: a + b

  # 여러 표현식일 때: do ... end
  def describe(n) do
    t =
      if rem(n, 2) == 0 do
        "even"
      else
        "odd"
      end

    "[" <> Integer.to_string(n) <> "] is " <> t
  end
end
```

- `describe/1` 에서 마지막 줄  
  ` "[" <> Integer.to_string(n) <> "] is " <> t`  
  가 곧 반환값이 된다.
- `if` 표현식 역시 `"even"` 혹은 `"odd"` 로 값을 내고,  
  그 값을 `t` 에 바인딩한 뒤 마지막 줄에서 사용한다.

단축 표기 vs 블록 표기:

```elixir
def f(x), do: x * x

def f(x) do
  x * x
end
```

두 정의는 완전히 동일하다.

- 코드가 **한 줄에 표현되기 벅찰 때**는 무조건 `do ... end` 를 쓰고 줄을 나누는 것이 낫다.

---

### 6.2.2 파이프라인과 블록

파이프라인(`|>`)은 “블록의 여러 줄”을 연결하는 구문이다.

```elixir
defmodule Pipe do
  def normalize_email(p) do
    p
    |> Map.update!("email", &String.trim/1)
    |> Map.update!("email", &String.downcase/1)
  end
end
```

이 코드는 사실 다음과 같다.

```elixir
def normalize_email(p) do
  p1 = Map.update!(p, "email", &String.trim/1)
  p2 = Map.update!(p1, "email", &String.downcase/1)
  p2
end
```

- 파이프는 **왼쪽 값을 오른쪽 함수의 첫 인자로** 전달한다.
- 읽을 때는 “위에서 아래”로 흐르지만,  
  실제로는 “하나의 블록 안에 있는 여러 표현식”이다.

파이프는 특히 **데이터 변환 파이프라인**에서 강력하다.

---

### 6.2.3 `case` / `cond` / `with` 도 표현식이다

#### 6.2.3.1 `case` 표현식

```elixir
defmodule Branch do
  def classify(x) do
    case x do
      n when is_integer(n) and n > 0 -> :pos_int
      n when is_integer(n)           -> :int
      _                              -> :other
    end
  end
end
```

- 각 분기에서 `:pos_int`, `:int`, `:other` 등 “값”을 반환한다.
- `case ... end` 전체가 하나의 값이 된다.

#### 6.2.3.2 `cond` 표현식

```elixir
defmodule Branch do
  def label(x) do
    cond do
      is_binary(x) -> :string
      is_list(x)   -> :list
      true         -> :other
    end
  end
end
```

- 위에서부터 조건을 평가하다가,  
  처음 참이 되는 분기의 값을 반환한다.

#### 6.2.3.3 `with` 표현식

```elixir
defmodule Branch do
  def safe_div(a, b) do
    with true <- is_number(a),
         true <- is_number(b),
         false <- b == 0 do
      {:ok, a / b}
    else
      false -> {:error, :div_by_zero}
      _     -> {:error, :bad_arg}
    end
  end
end
```

- `with` 블록 안의 마지막 표현식 `{:ok, a/b}` 가 성공 경로의 반환값.
- `else` 블록의 각 패턴 역시 **값을 반환**한다.
- 전체 `with ... end` 는 하나의 값이다.

---

### 6.2.4 블록과 변수 스코프(요약)

엘릭서의 스코프 규칙(6.4.9에서 더 자세히 다루지만 여기서도 요약해 둔다):

- `if` / `case` / `cond` / `with` 블록 안에서 변수 재바인딩은 **바깥 스코프로 전파**된다.
- **익명 함수 `fn` / 리스트 컴프리헨션 `for`** 안에서 변수 바인딩은 **바깥 스코프로 전파되지 않는다.**

```elixir
defmodule Scope do
  def demo(xs) do
    s = 0

    if xs != [] do
      s = Enum.count(xs)    # if 블록 내부에서 재바인딩
    end

    (fn ->
       s = -1               # 익명 함수 내부 재바인딩 (외부에 영향 없음)
       s
     end).()

    s
  end
end

# Scope.demo([1,2,3]) == 3
```

- `if` 안에서 `s`를 재바인딩하면, 그 값이 블록 바깥에도 반영된다.
- 익명함수 내부의 `s = -1` 은 **새 스코프에서만 유효**하다.

이 차이를 이해해야 **예상치 못한 값 덮어쓰기**를 피할 수 있다.

---

### 6.2.5 가드와 블록

가드는 **블록이 아니다**.  
함수 헤드에 붙는 **제약 표현**이다.

```elixir
defmodule Guardy do
  def positive_int?(x) when is_integer(x) and x > 0, do: true
  def positive_int?(_), do: false
end
```

가드 규칙:

- 가드 안에서는 **가드 허용 함수**만 사용할 수 있다.  
  (타입 검사, 논리 연산, 단순 산술, 비교 등)
- `String.length/1` 같은 일반 함수 호출을 가드에 넣으면 컴파일 오류가 난다.  
  (런타임 예외 가능성 때문)

가드를 깔끔하게 유지하기 위해:

- 복잡한 검사는 본문 안에서 처리한다.
- 자주 쓰는 조건은 `defguard` 로 이름을 붙여 재사용한다.

---

### 6.2.6 블록 디버깅: `IO.inspect/2` 활용

표현식 기반 언어에서는 **중간 값**을 찍는 것이 중요하다.

```elixir
defmodule DebugDemo do
  def normalize(params) do
    params
    |> IO.inspect(label: "before")
    |> Map.update!("email", &String.trim/1)
    |> IO.inspect(label: "after_trim")
    |> Map.update!("email", &String.downcase/1)
    |> IO.inspect(label: "after_downcase")
  end
end
```

`IO.inspect/2` 도 단순히 **값을 반환**하므로,  
파이프라인 도중에 끼워 넣어도 전체 흐름에 영향을 주지 않는다.

---

### 6.2.7 블록, with, 패턴을 결합한 예제

```elixir
defmodule Signup do
  def run(params) do
    with {:ok, email} <- fetch_trim(params, "email"),
         true <- valid_email?(email),
         {:ok, user}  <- insert_user(email) do
      {:ok, user}
    else
      {:error, :missing} -> {:error, :bad_request}
      false              -> {:error, :invalid_email}
      {:error, reason}   -> {:error, reason}
    end
  end

  defp fetch_trim(m, key) do
    case Map.fetch(m, key) do
      {:ok, v} when is_binary(v) ->
        {:ok, String.trim(v)}

      _ ->
        {:error, :missing}
    end
  end

  defp valid_email?(e), do: String.contains?(e, "@")
  defp insert_user(e),  do: {:ok, %{id: 1, email: e}}
end
```

- `fetch_trim/2` 는 `{:ok, value}` 또는 `{:error, reason}` 을 돌려준다.
- `with` 블록은 **성공 흐름**만 “곧장” 읽도록 구성하고,  
  모든 에러 케이스는 `else`에서 처리한다.
- 이 전체가 하나의 블록/표현식으로, 호출부에서는:

  ```elixir
  case Signup.run(params) do
    {:ok, user}   -> ...
    {:error, why} -> ...
  end
  ```

  처럼 다룰 수 있다.

---

## 6.3 함수 호출과 패턴 매칭

함수는 **이름+아리티(arity)**로 식별되며,  
**패턴 매칭**은 다음 두 위치에서 핵심 역할을 한다.

1. **인자 자리(함수 헤드)**: 입력 계약, 유효성 1차 필터  
2. **호출 결과를 받는 자리**: 출력 타입/상태 분기

이 두 지점을 정확히 이해하면,  
코드는 자연스럽게 **계약 중심**의 구조를 갖게 된다.

---

### 6.3.1 호출 규칙 — 인자 평가, 클로즈 선택, 본문 실행

엘릭서에서 함수 호출 `f(a1, …, an)` 의 개념적인 평가 순서는:

1. 인자 `a1` … `an` 을 **평가**한다.  
2. 현재 모듈 혹은 지정 모듈에서 **이름+아리티가 같은 모든 클로즈(본문)** 를 모은다.  
3. 위에서 아래 순으로, 각 클로즈의 **패턴과 가드**가 인자 값과 일치하는지 검사한다.  
4. 처음으로 성공한 클로즈의 본문을 실행하고 그 결과를 반환한다.  
5. 아무 클로즈도 매칭되지 않으면 `FunctionClauseError`.

이를 수식으로 쓰면:

$$
\text{eval}(f(a_1,\dots,a_n)) = \text{eval}(\mathrm{body}_k)
$$

단, 다음을 만족하는 \(k\) 에 대해:

$$
p_k \equiv a \quad \land \quad g_k(a) = \text{true}
$$

- \(p_k\): k번째 클로즈의 인자 패턴  
- \(g_k\): k번째 클로즈의 가드 조건

즉, 함수 호출은 “패턴/가드로 필터링된 클로즈 중 하나를 실행하는 연산”이다.

---

### 6.3.2 인자 자리 패턴 vs 내부 `case`

다음 두 코드를 비교해 보자.

```elixir
defmodule Parse do
  # A) 인자 자리 패턴
  def token("OK:" <> rest),  do: {:ok, String.trim(rest)}
  def token("ERR:" <> rest), do: {:error, String.trim(rest)}
  def token(_),              do: :unknown

  # B) 내부 case
  def token2(s) do
    case s do
      "OK:" <> rest  -> {:ok, String.trim(rest)}
      "ERR:" <> rest -> {:error, String.trim(rest)}
      _              -> :unknown
    end
  end
end
```

두 함수는 동작이 같다.  
그렇지만 스타일 측면에서는:

- `token/1`  
  - 함수 헤드가 곧 **공개된 계약**이다.  
  - “이 함수는 이런 문자열만 특별 취급한다”는 점이 한눈에 보인다.
- `token2/1`  
  - 입력이 단일 인자 `s` 로만 표현되어,  
    내부를 열어보지 않으면 계약이 드러나지 않는다.

실무 가이드:

- **공개 API, 도메인 모델의 중심 함수**:  
  → 인자 자리 패턴으로 계약을 드러낸다.  
- **로컬 분기, 큰 함수 안의 작은 패턴 분해**:  
  → 내부 `case`를 써도 무방하다.

---

### 6.3.3 기본값 인자와 멀티 클로즈

기본값 인자는 컴파일 시 **숨은 함수 헤드**를 생성한다.  
멀티 클로즈와 섞일 때 순서 혼란을 피하려면 **선언을 분리**하는 것이 좋다.

```elixir
defmodule Ping do
  # 기본값 선언용 헤드
  def ping(url, timeout \\ 1000)

  # 실제 구현 클로즈들
  def ping(url, timeout) when is_binary(url) and is_integer(timeout) do
    {:ok, {url, timeout}}
  end

  def ping(_, _), do: {:error, :bad}
end
```

컴파일러는 대략 이렇게 확장한다:

- `ping/1` : `ping(url)` → `ping(url, 1000)` 을 호출하는 클로즈 생성  
- `ping/2` : 위에서 작성한 클로즈 두 개

반면, 다음과 같이 쓰면:

```elixir
def ping(url, timeout \\ 1000) when is_binary(url) and is_integer(timeout), do: ...
def ping(_, _), do: ...
```

- 내부적으로 어떤 순서로 헤드가 확장되는지 헷갈릴 수 있다.
- 특히 가드와 멀티 클로즈가 뒤섞이면 디버깅이 어렵다.

따라서:

- **기본값 선언용 헤드**: `def f(a, b \\ d)`  
- **실제 구현 헤드**: 아래에 `def f(a, b) when ...` 여러 개

로 나누는 패턴을 추천한다.

---

### 6.3.4 호출 결과에서의 패턴 매칭

호출 결과도 마찬가지로 패턴으로 분기한다.

```elixir
defmodule API do
  def decode({200, %{"data" => d}}), do: {:ok, d}

  def decode({code, %{"error" => e}}) when code in 400..599 do
    {:error, {code, e}}
  end

  def decode(_), do: {:error, :unknown}
end

# 호출부
case API.decode({200, %{"data" => 10}}) do
  {:ok, v}      -> v
  {:error, r}   -> {:fail, r}
end
```

패턴 매칭을 도입하면:

- 결과 타입이 **명시적**이 된다. (`{:ok, v}`, `{:error, r}` 등)
- 호출부는 단순히 **패턴별로 분기**하면 된다.
- 예외 흐름 없이 오류를 제어할 수 있다.

이 패턴은 엘릭서/펑셔널 생태계 전체에서 널리 쓰이는 관습이다.

---

### 6.3.5 핀(`^`)과 동적 키/값 고정

함수 헤드에서도 핀 연산자를 활용할 수 있다.

```elixir
defmodule K do
  def fetch(%{^key => v}, key), do: {:ok, v}
  def fetch(_, _), do: :error
end

k = :id
K.fetch(%{id: 10}, k)       # {:ok, 10}
K.fetch(%{name: "x"}, k)    # :error
```

설명:

- `%{^key => v}`  
  - “키가 현재 `key` 변수에 들어 있는 값인 경우에만 일치한다.”
- 핀을 쓰지 않으면 `%{key => v}` 패턴은  
  “새 변수 `key`에 키를 바인딩한다”는 의미가 되어 버린다.

핀 + 맵 패턴의 조합은:

- 라우팅,  
- 권한 체크(특정 역할 키 찾기),  
- 동적 필드 이름 처리

등에서 자주 등장한다.

---

### 6.3.6 바이너리/비트 패턴과 함수 헤드

바이너리 프로토콜을 다룰 때 함수 헤드에서 곧바로 파싱하는 것이 흔하다.

```elixir
defmodule Wire do
  @spec frame(binary()) ::
          {:ok, %{type: non_neg_integer(), body: binary()}, binary()}
          | :incomplete

  def frame(<<t::8, len::16, body::binary-size(len), rest::binary>>) do
    {:ok, %{type: t, body: body}, rest}
  end

  def frame(_), do: :incomplete
end

Wire.frame(<<1, 0, 3, "abc", "tail">>)
# {:ok, %{type: 1, body: "abc"}, "tail"}
```

- `<<t::8, len::16, body::binary-size(len), rest::binary>>`  
  - 1바이트 타입, 16비트 길이, 길이만큼의 본문, 나머지.
- 본문은 단순히 반환하는 역할만 하므로,  
  함수 내부는 매우 깔끔해진다.

이런 스타일은 네트워크 서버, 파일 포맷 파서, 바이너리 로그 분석에서 특히 유용하다.

---

### 6.3.7 원격 호출, 캡처, 파이프라인 괄호

엘릭서에서는 **모듈 이름 + 함수 이름**으로 원격 호출을 많이 한다.

```elixir
String.trim("  x  ")
String.downcase("X")
Integer.to_string(10)
```

함수 캡처:

```elixir
trim = &String.trim/1
trim.("  x  ")            # "x"
```

파이프라인에서 원격 호출을 쓸 때는 괄호 위치에 주의한다.

```elixir
"  A  "
|> String.trim()
|> String.downcase()
```

- `String.trim/1` 을 `String.trim/0`과 혼동하지 않도록  
  **항상 괄호를 붙이는 것이 안전**하다.
- 특히 `|>` 다음에는 **반드시 괄호**를 쓰는 습관을 들이면  
  매크로/연산자 우선순위로 인한 미묘한 버그를 피할 수 있다.

---

### 6.3.8 재귀와 누적기(accumulator) + 패턴

앞에서 본 꼬리 재귀 예제를 다시 보자.

```elixir
defmodule Sum do
  def list(xs), do: do_list(xs, 0)

  defp do_list([h | t], acc), do: do_list(t, acc + h)
  defp do_list([], acc), do: acc
end
```

이 스타일의 장점:

- 패턴으로 **종료 조건**과 **진행 조건**을 분리한다.
- 꼬리 위치에서 자기 자신을 호출하므로  
  BEAM의 **꼬리호출 최적화**에 걸린다.
- 입력 리스트가 길더라도 스택이 증가하지 않는다.

비슷한 패턴으로:

- 필터

  ```elixir
  defmodule Filter do
    def even(xs), do: do_even(xs, [])

    defp do_even([h | t], acc) when rem(h, 2) == 0,
      do: do_even(t, [h | acc])

    defp do_even([_h | t], acc),
      do: do_even(t, acc)

    defp do_even([], acc),
      do: :lists.reverse(acc)
  end
  ```

- 맵, 플랫닝, 폴드, 집계 등  
  대부분의 리스트 연산을 같은 패턴으로 구현할 수 있다.

물론, 실전에서는 `Enum` 모듈을 사용하는 것이 일반적이지만,  
내부 동작을 이해하고 싶다면 위와 같은 스타일을 직접 구현해 보는 것이 좋다.

---

### 6.3.9 `try/rescue` 보다 계약+패턴 우선

예외를 많이 사용하는 스타일보다,  
**계약 + 패턴 매칭 + 태그드 튜플** 을 우선하는 것이 엘릭서다운 스타일이다.

```elixir
defmodule ParseInt do
  def from(s) when is_binary(s) do
    case Integer.parse(s) do
      {n, ""} -> {:ok, n}
      _       -> {:error, :bad}
    end
  end
end
```

호출부:

```elixir
case ParseInt.from("10") do
  {:ok, n}       -> n * 2
  {:error, :bad} -> 0
end
```

예외를 쓴다면:

```elixir
def from!(s) when is_binary(s) do
  case Integer.parse(s) do
    {n, ""} -> n
    _       -> raise ArgumentError, "not an int"
  end
end
```

이 두 함수를 함께 제공하면:

- 안전/패턴 기반 버전: `from/1`  
- 예외 버전: `from!/1`

처럼 “일반/위험” 쌍을 명확히 표현할 수 있다.

---

## 6.3 종합 예제: 모듈·블록·호출/패턴 통합 미니 프레임워크

이제까지 나온 요소를 묶어  
간단한 **프레이밍 서버**를 만들어 보자.

### 6.3.1 프레이밍 규칙

- 요청 바이너리 형식: `<<type:8, len:16, body:len>>`
- 응답 바이너리 형식도 동일.
- `type = 1`: echo (body 그대로 반환)  
- `type = 2`: upper (body를 대문자로 바꿔 반환)  
- 그 외: 오류

### 6.3.2 모듈 분할

```
lib/
  framing.ex
  handlers.ex
  router.ex
```

#### 6.3.2.1 `Framing` — 인코딩/디코딩

```elixir
defmodule Framing do
  @type frame :: %{type: non_neg_integer(), body: binary()}

  @spec decode(binary()) :: {:ok, frame(), binary()} | :incomplete
  def decode(<<t::8, len::16, body::binary-size(len), rest::binary>>) do
    {:ok, %{type: t, body: body}, rest}
  end

  def decode(_), do: :incomplete

  @spec encode(frame()) :: binary()
  def encode(%{type: t, body: b}) when is_integer(t) and is_binary(b) do
    <<t::8, byte_size(b)::16, b::binary>>
  end
end
```

- 함수 헤드의 바이너리 패턴이 곧 **프로토콜 스펙**이다.
- 실패 시 `:incomplete` 를 반환해 호출부에서 처리하도록 한다.

#### 6.3.2.2 `Handlers` — 타입별 핸들러

```elixir
defmodule Handlers do
  @moduledoc """
  type별 프레임 처리.

  * 1: echo
  * 2: upper
  """

  @spec handle(Framing.frame()) :: {:ok, binary()} | {:error, :unknown}
  def handle(%{type: 1, body: b}), do: {:ok, b}
  def handle(%{type: 2, body: b}), do: {:ok, String.upcase(b)}
  def handle(_),                   do: {:error, :unknown}
end
```

- 패턴 매칭으로 타입을 분리한다.
- 반환 타입을 `{:ok, body}` / `{:error, reason}` 으로 통일한다.

#### 6.3.2.3 `Router` — 입력→출력 파이프라인

```elixir
defmodule Router do
  alias Framing, as: F

  @spec serve(binary()) :: binary()
  def serve(payload) do
    with {:ok, frame, _rest} <- F.decode(payload),
         {:ok, out}          <- Handlers.handle(frame) do
      F.encode(%{type: frame.type, body: out})
    else
      :incomplete ->
        F.encode(%{type: 255, body: "incomplete"})

      {:error, :unknown} ->
        F.encode(%{type: 254, body: "unknown"})
    end
  end
end
```

- `with` 블록이 성공 경로를 “곧장” 보여준다.  
- 오류 케이스는 `else`에서 분리 처리한다.
- 전체가 하나의 **표현식 블록**이다.

### 6.3.3 IEx에서 테스트

```elixir
iex -S mix

# type=1, len=3, "hey"
iex> req = <<1, 0, 3, "hey">>
iex> Router.serve(req)
<<1, 0, 3, "hey">>

# type=2, len=3, "hey"
iex> req2 = <<2, 0, 3, "hey">>
iex> Router.serve(req2)
<<2, 0, 3, "HEY">>

# 잘못된 프레임
iex> Router.serve(<<1,0,1,"a">>)
<<255, 0, 10, "incomplete">>  # 길이가 맞지 않아 :incomplete 응답
```

---

## 6.3.4 테스트 스케치 (ExUnit)

```elixir
defmodule Ch6Test do
  use ExUnit.Case, async: true

  test "framing roundtrip" do
    bin = Framing.encode(%{type: 7, body: "ok"})
    assert {:ok, %{type: 7, body: "ok"}, <<>>} = Framing.decode(bin)
  end

  test "handlers echo and upper" do
    assert {:ok, "x"} = Handlers.handle(%{type: 1, body: "x"})
    assert {:ok, "X"} = Handlers.handle(%{type: 2, body: "x"})
    assert {:error, :unknown} = Handlers.handle(%{type: 99, body: "x"})
  end

  test "router sum of numbers" do
    req = <<1, 0, 3, "hey">>
    assert <<1, 0, 3, "hey">> = Router.serve(req)
  end
end
```

---

## 6.3.5 흔한 실수와 교정 요약

1. **기본값 인자 + 멀티 클로즈 혼용**으로 인한 `FunctionClauseError`  
   → 기본값 헤드와 구현 헤드를 분리하여 선언 순서를 명확히 한다.

2. **함수 헤드에서 가드에 일반 함수 호출 사용**  
   → 가드 허용 함수만 사용, 복잡한 검사는 본문에서.

3. **문자열/바이너리 연결 연쇄**로 인한 성능 저하  
   → `iodata`로 누적 후 `:erlang.iolist_to_binary/1` 로 마지막에 선형화.

4. **`if/case/with` 내부 재바인딩 전파를 모른 채 사용**  
   → 스코프 규칙을 이해하고, 외부에 영향 주기 싫으면 익명 함수로 감싼다.

5. **예외에 과도 의존**  
   → 기본적으로는 `{:ok, v} | {:error, r}` 형태의 태그드 튜플을 반환하고,  
     “정말 실패시 바로 터지게 해야 하는” 버전만 `!/1` suffix로 예외 버전 제공.

---

## 6.3.6 요약

- **6.1 모듈 컴파일**  
  - `.ex` / `.exs` 의 차이, `elixirc`, `mix compile`, `iex -S mix`, `recompile/0`.  
  - 코드 경로, 모듈 속성(`@moduledoc`, `@doc`, `@external_resource`), `alias/import/require/use`, 매크로/가드 구분.

- **6.2 함수 본문 = 블록**  
  - `do:` 단축 표기 vs `do ... end`.  
  - 마지막 표현식 반환 규칙, `case/cond/with` 도 모두 표현식.  
  - 파이프라인, 스코프(전파/차단), 가드 역할, `IO.inspect`를 통한 디버깅.

- **6.3 함수 호출 × 패턴 매칭**  
  - 호출 시 인자 평가 → 클로즈 선택 → 본문 실행 과정.  
  - 인자 자리 패턴 vs 내부 `case`, 기본값 인자와 멀티 클로즈 설계.  
  - 핀(`^`), 바이너리 패턴, 꼬리 재귀, 태그드 튜플을 통한 오류 처리.

전체적으로, 엘릭서에서 함수는:

- **헤드(패턴/가드)** 로 입력 계약을 표현하고,  
- **본문 블록**에서 값을 조립하며,  
- **호출 결과 패턴 매칭**을 통해 출력 계약을 소비하는 구조를 가진다.

이 관점을 유지하면서 코드를 작성하면  
모듈 경계가 명확해지고, 테스트와 유지보수가 쉬운 시스템을 만들 수 있다.