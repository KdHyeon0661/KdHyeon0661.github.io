---
layout: post
title: 운영체제 - 운영체제 구조 (1)
date: 2025-10-15 17:25:23 +0900
category: 운영체제
---
# Chapter 2 — Operating-System Structures

이 장은 운영체제가 **무엇을 제공하고(Services)**, 사용자가 **어떻게 상호작용하며(Interfaces)**, 프로그램이 **어떤 경로로 커널 기능에 접근하는지(System Calls)**를 **실행 가능한 예제**와 함께 자세히 서술한다.  
리눅스/유닉스 계열을 기본으로 하되, 윈도우·모바일 관점도 병행해 비교한다.

---

## 2.1 Operating-System Services

운영체제 서비스는 애플리케이션과 사용자가 기대하는 **필수 기능**을 묶은 집합이다.

- **프로그램 실행(Program execution)**: 로더/링커, 주소공간 준비, 엔트리 진입
- **I/O 작업 수행(I/O operations)**: 파일·디바이스 read/write, 버퍼링, 캐싱
- **파일시스템 조작(File-system manipulation)**: 생성/삭제/열기/권한/속성/링크
- **통신(Communications)**: 프로세스 간 통신(파이프/소켓/공유메모리/메시지큐)
- **오류 탐지(Error detection)**: 잘못된 접근, 장치 고장, 파산 프로세스
- **자원 할당(Resource allocation)**: CPU·메모리·디스크·네트워크 스케줄링
- **계정/보안(Accounting & Security)**: 사용량 측정, 인증/인가, 격리

### 실습 A — “서비스 맛보기” (파일+프로세스+통신)
```bash
# 1. 파일 서비스: 생성/쓰기/메타데이터
echo "hello OS" > /var/tmp/os2_demo.txt
stat /var/tmp/os2_demo.txt

# 2. 프로세스 서비스: 실행/상태 관찰
sleep 3 &            # 백그라운드 실행
ps -o pid,ppid,stat,comm | head

# 3. 통신 서비스: 파이프라인(프로세스 간 바이트 스트림)
printf "alpha\nbeta\ngamma\n" | grep 'a' | tr a-z A-Z
```

### 실습 B — 오류 탐지와 보호
```bash
# 읽기 전용 파일에 쓰기 시도 → 권한 오류 확인 (EPERM/EACCES)
chmod 400 /var/tmp/os2_demo.txt
echo "append" >> /var/tmp/os2_demo.txt || echo "write denied"
```

---

## 2.2 User and Operating-System Interface

OS 인터페이스는 크게 **명령 인터프리터(CLI)**, **그래픽 UI(GUI)**, **터치 UI**로 나뉜다.  
각 인터페이스는 **동일한 커널 서비스**를 다양한 상호작용 모델로 노출한다.

### 2.2.1 Command Interpreters (Shell / CLI)

- **bash/zsh/fish**, **PowerShell**, **cmd.exe**  
- 스크립팅/파이프/리다이렉션으로 **작업 자동화**에 강함.

#### 예제 — 파이프, 리다이렉션, 서브셸
```bash
# 현재 디렉터리에서 가장 큰 상위 5개 파일
du -ah . | sort -h | tail -5

# 서브셸에서 임시 변수/경로 조작 후 원복
( cd /var/tmp && echo "pwd in subshell: $(pwd)" )
echo "pwd after subshell: $(pwd)"
```

#### 예제 — 단일 라인 배치
```bash
# 100개의 더미 파일 만들고 합치기
seq 1 100 | xargs -I{} sh -c 'echo "line {}" > /var/tmp/f{}.txt'
cat /var/tmp/f*.txt | wc -l
```

### 2.2.2 Graphical User Interface (GUI)

- **윈도우 관리자/컴포지터**가 **입력 이벤트, 윈도우 버퍼, 합성**을 중재.
- 파일 브라우저/설정 앱은 내부적으로 동일한 **open/read/write/ioctl** 경로를 사용.

#### 관찰 — GUI와 CLI의 공통 커널 경로
```bash
# GUI 에디터로 수정한 파일도 결국 페이지캐시에 적중 → CLI로 읽어도 빠름
/usr/bin/time -f "t=%E" cat /var/tmp/os2_demo.txt > /dev/null
```

### 2.2.3 Touch-Screen Interface

- **제스처 이벤트(탭/스와이프/핀치)** → 이벤트 디스패처 → 앱 위젯 트리
- 모바일 OS는 **포그라운드 우선권**, **백그라운드 제약**, **권한 프롬프트**로 UX와 보안을 맞춘다.

### 2.2.4 Choice of Interface

- **배치·자동화**: CLI 스크립트 유리  
- **탐색·시각화**: GUI/터치 유리  
- **서버 운영**: 비대화형/원격 CLI 필수

---

## 2.3 System Calls

**시스템콜**은 사용자 모드에서 커널 모드로 진입하는 **공식 API**다.  
라이브러리(API)가 **랩핑**하여 이식성과 편의성을 제공한다.

- 사용자 코드 → **C 라이브러리(glibc/msvcrt/Win32 API)** → **syscall 트랩** → 커널 서비스 → 반환

### 2.3.1 Example — 최소 시스템콜 경로 살펴보기

#### C: `write`, `getpid`를 직접 호출
```c
// sys_example.c
#include <unistd.h>
#include <sys/syscall.h>
#include <stdio.h>
int main() {
    long pid = syscall(SYS_getpid);
    const char* msg = "hello via write\n";
    syscall(SYS_write, 1, msg, 16);   // 1=STDOUT
    printf("pid=%ld\n", pid);         // libc 포맷팅 + 내부 write
    return 0;
}
```
```bash
gcc -O2 sys_example.c -o sys_example && strace -o trace.txt ./sys_example
sed -n '1,10p' trace.txt   # 실제 시스템콜 트레이스
```

#### Python: `os.read`/`os.write` (랩퍼 경유)
```python
# py_sys_example.py
import os, sys
os.write(1, b"hello from python\n")
print("pid:", os.getpid())
```

### 2.3.2 Application Programming Interface (API)

- **API**는 **이식성/가독성**을 위해 시스템콜을 **간접화**한다.
- 예: POSIX `fopen`/`fread`/`fwrite`는 내부에서 `open`/`read`/`write`를 사용하며, 버퍼링 등 부가 기능 제공.

#### 예제 — API vs Raw syscall
```c
// api_vs_syscall.c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
int main(){
    // 고수준 API
    FILE* f = fopen("/var/tmp/api.txt","w");
    fputs("API layer\n", f); fclose(f);

    // 저수준 syscall 래핑
    int fd = open("/var/tmp/sys.txt", O_WRONLY|O_CREAT|O_TRUNC, 0644);
    write(fd, "syscall layer\n", 14); close(fd);
}
```

### 2.3.3 Types of System Calls

아래는 대표적인 시스템콜 **군집**과 **핵심 패턴**, **실습 코드**다.

---

#### 2.3.3.1 Process Control

- **생성/종료**: `fork`, `execve`, `exit`, `waitpid`
- **속성/우선순위**: `nice`, `setpriority`, `sched_*`
- **신호/핸들링**: `kill`, `sigaction`, `alarm`
- **메모리**: `brk`, `mmap`, `mprotect`

##### 예제 — `fork+exec` 파이프라인 (ls | wc -l)
```c
// proc_pipe.c
#define _GNU_SOURCE
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>

int main(){
    int p[2]; pipe(p);
    if(fork()==0){                    // child1: ls -> stdout=pipe write
        dup2(p[1],1); close(p[0]); close(p[1]);
        execlp("ls","ls",(char*)NULL);
        _exit(127);
    }
    if(fork()==0){                    // child2: wc -l <- stdin=pipe read
        dup2(p[0],0); close(p[1]); close(p[0]);
        execlp("wc","wc","-l",(char*)NULL);
        _exit(127);
    }
    close(p[0]); close(p[1]);
    wait(NULL); wait(NULL);
}
```
```bash
gcc -O2 proc_pipe.c -o proc_pipe && ./proc_pipe
```

##### 예제 — 신호 처리 (타임아웃/취소)
```c
// proc_signal.c
#define _GNU_SOURCE
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
volatile sig_atomic_t fired=0;
void h(int s){ fired=1; }
int main(){
    struct sigaction sa={0}; sa.sa_handler=h; sigaction(SIGALRM,&sa,NULL);
    alarm(1);
    while(!fired){ /* busy */ }
    puts("timeout!");
}
```

---

#### 2.3.3.2 File Management

- **열기/닫기**: `open`, `close`
- **읽기/쓰기**: `read`, `write`, `pread`, `pwrite`
- **이동/링크**: `rename`, `link`, `symlink`, `unlink`
- **메타데이터**: `stat`, `chmod`, `chown`, `utimensat`
- **메모리 매핑**: `mmap`, `msync`, `munmap`
- **동기화**: `fsync`, `fdatasync`, `sync_file_range`

##### 예제 — 안전한 쓰기 패턴 (tmp + rename 원자화)
```c
// file_atomic.c
#define _GNU_SOURCE
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(){
    const char* path = "/var/tmp/atomic.txt";
    const char* tmpp = "/var/tmp/.atomic.txt.tmp";
    int fd = open(tmpp, O_WRONLY|O_CREAT|O_TRUNC, 0644);
    const char* msg = "atomic replace\n";
    write(fd, msg, strlen(msg));
    fsync(fd); close(fd);
    // rename은 동일 파일시스템 내에서 원자적
    rename(tmpp, path);
    return 0;
}
```

##### 예제 — `mmap`로 빠른 파일 스캔
```c
// file_mmap_scan.c
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc,char**argv){
    if(argc<2){fprintf(stderr,"usage: %s file\n",argv[0]); return 1;}
    int fd=open(argv[1],O_RDONLY);
    struct stat st; fstat(fd,&st);
    char* p=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,fd,0);
    // 첫 64바이트 덤프
    for(size_t i=0;i<64 && i<st.st_size;i++) putchar(p[i]);
    munmap(p,st.st_size); close(fd);
}
```

---

#### 2.3.3.3 Device Management

- **ioctl**(문자/블록 디바이스 제어), **`open`**으로 장치 파일 접근(`/dev/tty`, `/dev/nvme0n1`, …)
- **비블로킹/async I/O**: `fcntl(O_NONBLOCK)`, `select`/`poll`/`epoll`, `io_uring`

##### 예제 — 터미널 속성 제어 (간소화)
```c
// dev_tty_raw.c : canonical 모드 해제(간이)
#define _GNU_SOURCE
#include <termios.h>
#include <unistd.h>
#include <stdio.h>

int main(){
    struct termios t; tcgetattr(0,&t);
    struct termios old=t;
    t.c_lflag &= ~(ICANON|ECHO);  // raw-ish
    tcsetattr(0,TCSANOW,&t);
    printf("type (q to quit): ");
    int c; while((c=getchar())!='q'){ printf("[%d]",c); fflush(stdout); }
    tcsetattr(0,TCSANOW,&old);
}
```

---

#### 2.3.3.4 Information Maintenance

- **시간/시계**: `clock_gettime`, `gettimeofday`, `timerfd_create`
- **시스템 정보**: `uname`, `/proc` 조회, `sysinfo`
- **리소스/한도**: `getrusage`, `getrlimit/setrlimit`

##### 예제 — 고해상도 타이밍
```c
// info_time.c
#define _GNU_SOURCE
#include <time.h>
#include <stdio.h>
int main(){
    struct timespec t0,t1;
    clock_gettime(CLOCK_MONOTONIC,&t0);
    for(volatile long i=0;i<10000000;i++);
    clock_gettime(CLOCK_MONOTONIC,&t1);
    double dt=(t1.tv_sec-t0.tv_sec)+(t1.tv_nsec-t0.tv_nsec)/1e9;
    printf("elapsed=%.6f s\n", dt);
}
```

---

#### 2.3.3.5 Communication

- **익명 파이프**: `pipe`
- **명명 파이프(FIFO)**: `mkfifo`
- **소켓**: `socket`, `bind`, `listen`, `accept`, `connect`, `send/recv`
- **공유 메모리**: `shm_open`, `mmap`, `sem_*`(POSIX 세마포어)

##### 예제 — epoll 기반 다중 클라이언트 에코 (요약)
```c
// comm_epoll_echo.c — 단일 스레드, 비동기 I/O
#define _GNU_SOURCE
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

static int nb(int fd){ int f=fcntl(fd,F_GETFL,0); return fcntl(fd,F_SETFL,f|O_NONBLOCK); }
int main(){
    int s=socket(AF_INET,SOCK_STREAM,0),one=1;
    setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&one,sizeof(one));
    struct sockaddr_in a={.sin_family=AF_INET,.sin_port=htons(9020),.sin_addr={htonl(INADDR_ANY)}};
    bind(s,(struct sockaddr*)&a,sizeof(a)); listen(s,1024); nb(s);

    int ep=epoll_create1(0); struct epoll_event ev={.events=EPOLLIN,.data.fd=s};
    epoll_ctl(ep,EPOLL_CTL_ADD,s,&ev);

    struct epoll_event evs[512]; char buf[4096];
    while(1){
        int n=epoll_wait(ep,evs,512,-1);
        for(int i=0;i<n;i++){
            int fd=evs[i].data.fd;
            if(fd==s){
                for(;;){
                    int c=accept4(s,NULL,NULL,SOCK_NONBLOCK);
                    if(c<0){ if(errno==EAGAIN) break; else break; }
                    struct epoll_event ce={.events=EPOLLIN|EPOLLET,.data.fd=c};
                    epoll_ctl(ep,EPOLL_CTL_ADD,c,&ce);
                }
            }else{
                for(;;){
                    ssize_t r=read(fd,buf,sizeof(buf));
                    if(r>0){ (void)write(fd,buf,r); }
                    else if(r==0){ close(fd); break; }
                    else if(errno==EAGAIN) break; else { close(fd); break; }
                }
            }
        }
    }
}
```

##### 예제 — 공유 메모리 + 세마포 (프로듀서/컨슈머)
```c
// comm_shm_sem.c (요약)
#define _GNU_SOURCE
#include <fcntl.h>
#include <sys/mman.h>
#include <semaphore.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

typedef struct { sem_t empty, full, mtx; char buf[256]; } shm_t;

int main(int argc, char**argv){
    int fd = shm_open("/shm_demo", O_CREAT|O_RDWR, 0600);
    ftruncate(fd, sizeof(shm_t));
    shm_t* s = mmap(NULL,sizeof(shm_t),PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
    if(argc>1 && !strcmp(argv[1],"init")){
        sem_init(&s->empty,1,1); sem_init(&s->full,1,0); sem_init(&s->mtx,1,1);
        return 0;
    }
    if(argc>1 && !strcmp(argv[1],"producer")){
        sem_wait(&s->empty); sem_wait(&s->mtx);
        strcpy(s->buf,"hello via shm");
        sem_post(&s->mtx); sem_post(&s->full); return 0;
    }
    if(argc>1 && !strcmp(argv[1],"consumer")){
        sem_wait(&s->full); sem_wait(&s->mtx);
        puts(s->buf);
        sem_post(&s->mtx); sem_post(&s->empty); return 0;
    }
    return 0;
}
```
```bash
gcc -O2 comm_shm_sem.c -o comm_shm_sem -pthread
./comm_shm_sem init
./comm_shm_sem producer & ./comm_shm_sem consumer
```

---

#### 2.3.3.6 Protection

- **권한/소유권**: `chmod`, `chown`, `umask`
- **프로세스 자격**: UID/GID, capabilities, setuid
- **격리**: 네임스페이스, `chroot`, seccomp-bpf

##### 예제 — setuid 파일의 효과(개념, 루트 필요)
```bash
# setuid 바이너리(루트 소유)를 실행하면 EUID 상승(보안상 매우 주의)
# chown root:root /usr/local/bin/some_tool
# chmod u+s /usr/local/bin/some_tool
# 실행 시 EUID=0 으로 동작하는 지점 체크 필요
```

##### 예제 — seccomp 최소 정책(허용 리스트)
```c
// prot_seccomp.c  (libseccomp 필요)
#include <seccomp.h>
#include <unistd.h>
#include <stdio.h>
int main(){
    scmp_filter_ctx ctx=seccomp_init(SCMP_ACT_KILL);
    seccomp_rule_add(ctx,SCMP_ACT_ALLOW,SCMP_SYS(write),0);
    seccomp_rule_add(ctx,SCMP_ACT_ALLOW,SCMP_SYS(exit),0);
    seccomp_load(ctx);
    write(1,"ok\n",3);
    // getpid();  // 금지됨 → 프로세스 종료
    return 0;
}
```

---

## 부록 1 — 인터페이스 비교 요약

| 인터페이스 | 강점 | 약점 | 주 활용 |
|---|---|---|---|
| CLI | 자동화/조합/원격 제어 | 학습 곡선 | 서버/개발/운영 |
| GUI | 가시성/탐색 | 자동화 약함 | 데스크탑/일반 사용자 |
| 터치 | 휴대성/센서 | 정밀도·입력 제약 | 모바일/임베디드 |

---

## 부록 2 — 시스템콜 비용 직관

시스템콜 평균 비용을 $$C_s$$, 호출 횟수를 $$n$$, 사용자 공간 처리 비용을 $$C_u$$라고 하면 총비용은  
$$
T \approx n\cdot C_s + C_u.
$$
`read()`를 **큰 블록**으로 줄이고, `mmap`을 이용해 **호출 횟수(n)**를 줄이면 **오버헤드**가 감소한다.

---

## 부록 3 — “작은 로그 수집기” 종합 실습

**목표**: 파일 관리 + 프로세스 제어 + 통신 + 보호를 한 번에 체험.

1) **수집기(collector)**: `inotify`(리눅스) 또는 `stat` 폴링으로 디렉터리의 신규 파일을 감지, TCP로 **전송**  
2) **서버(server)**: epoll 에코 서버를 약간 수정해 **파일에 append + fsync**  
3) **보호**: 서버를 **비특권 사용자**로 실행, 디렉터리 권한 최소화 설정

(상세 코드는 앞선 예제 조합으로 구현 가능)

---

## 체크리스트

- **서비스**: 실행, I/O, 파일, 통신, 오류, 보안/계정  
- **인터페이스**: CLI/GUI/터치 — 같은 커널, 다른 UX  
- **시스템콜**: API 래퍼 ↔ 커널 입구. 성능/안전 핵심 경로  
- **타입별 예제**: 프로세스, 파일, 디바이스, 정보, 통신, 보호

---

## 마무리

운영체제 구조의 핵심은 **명확한 인터페이스와 강건한 시스템콜 집합**이다.  
이 장의 예제들을 직접 실행/수정해 **관측 가능한 지표(시간·CPU·시스템콜 트레이스)**를 남기면, 이후 장(프로세스 스케줄링, 가상메모리, 파일시스템 내부)에서 **원리 ↔ 현상**을 자연스럽게 연결할 수 있다.