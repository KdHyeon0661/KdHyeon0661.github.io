---
layout: post
title: 이산수학 - 비둘기집 원리
date: 2025-06-08 19:20:23 +0900
category: 이산수학
---
# 🕊️ 비둘기집 원리 (Pigeonhole Principle)

## 1. 기본 원리 (Basic PHP)

### 정의
상자(집) $$n$$개에 물건(비둘기) $$k$$개를 넣을 때
$$
k>n \;\Rightarrow\; \text{적어도 한 상자에 최소 2개 이상.}
$$

### 가장 간단한 증명(모순법)
모든 상자에 많아야 1개씩이라면 총합은 $$\le n$$. 그런데 실제로는 $$k>n$$ → 모순.

---

## 2. 일반화된 비둘기집 원리 (Generalized PHP)

### 명제
상자 $$n$$개, 물건 $$k$$개이면
$$
\exists \text{상자 } H:\ \ \#H \ge \left\lceil \frac{k}{n}\right\rceil.
$$

### 스케치 증명
평균이 $$k/n$$ 이므로 **최댓값은 평균 이상**. 정수 개수이므로 천장함수 사용.

> 보완: 항상 **최소 한 상자는** $$\ge \lceil k/n\rceil$$,
> **또 최소 한 상자는** $$\le \lfloor k/n\rfloor$$ (평균-최댓값/최솟값 원리).

---

## 3. 강한 비둘기집 원리 (r-형)

### 형식
$$
k>(r-1)\,n \;\Rightarrow\; \text{어떤 상자에는 } \ge r \text{ 개}.
$$

### 대우(contrapositive)
모든 상자에 $$\le r-1$$ 이면 총합 $$\le (r-1)n$$.
원문장은 이의 **대우**.

---

## 4. 무한 비둘기집 원리 (Infinite PHP)

상자가 유한(또는 가산 개)이고 물건이 **무한 개**면, **적어도 한 상자에는 무한히 많이** 들어간다.
(유한 상자에 유한 상한을 두면 총합이 유한 → 무한 개라는 가정과 모순)

---

## 5. 수 이론·조합론 기본 응용

### 5.1 나머지(동치류) 버전
정수 $$m$$에 대해 임의의 정수 $$m+1$$개를 고르면,
두 수는 **같은 나머지**를 갖는다(상자 = 나머지 $$0,\dots,m-1$$).

**추론**: 항상 두 수의 **차**가 $$m$$으로 나누어진다.

---

### 5.2 합이 101 (1–100, 51개 선택)
쌍 상자: $$(1,100),(2,99),\dots,(50,51) \Rightarrow 50 \text{개 상자}$$
정수 51개 선택 ⇒ 어떤 상자에는 **두 수**가 함께 들어감 ⇒ 합이 **101**.

---

### 5.3 생일·요일·끝자리
- 366명(윤년X) ⇒ 같은 생일(상자 365일).
- 8명 ⇒ 같은 요일에 태어난 두 명(상자 7일).
- 11개 정수 ⇒ 같은 일의 자리(상자 10개)인 두 수.

> 📌 **확률적 생일 문제(≈23명)** 과 **결정적 PHP**는 **별개**.
> PHP는 **보장**, 확률 문제는 **높은 확률**을 말함.

---

### 5.4 디오판토스 근사(Dirichlet 유형 간단형)
실수 $$\alpha$$ 와 정수 $$N\ge1$$ 에 대해
$$
\exists\ p,q\ (1\le q\le N):\ \left|q\alpha - p\right| < \frac1N.
$$

**아이디어**: 분수부분 $$\{0\alpha\},\{1\alpha\},\dots,\{N\alpha\}$$ 를
$$N$$ 개 구간 길이 $$1/N$$ 으로 나눈 상자에 넣으면 **두 개가 같은 상자** → 차이가 $$<1/N$$.

---

## 6. 기하 응용

### 6.1 정사각형의 점 사이 거리
단위 정사각형에 점 5개 ⇒ 정사각형을 4등분(각 변 $$1/2$$).
어떤 사분면에 점 2개 존재(4상자에 5점).
그 사분면 대각선 길이는 $$\sqrt{(1/2)^2+(1/2)^2}=\frac{\sqrt2}{2}$$.
따라서 **두 점 사이 거리는 $$\le \frac{\sqrt2}{2}$$**.
(문제에서 “$$<\sqrt2$$”라면 **더 강한 결론**으로 충족)

---

### 6.2 각도·호분할
원 둘레를 $$n$$ 등분한 호에 점 $$n+1$$개 ⇒ 같은 호에 2점 ⇒
그 2점 중심각은 $$\le 2\pi/n$$.

---

## 7. 그래프 이론 응용

### 7.1 동일 차수 정리
정점이 $$n\ge2$$ 개인 단순 그래프에는 **같은 차수**를 가진 정점이 두 개 이상 있다.

**이유**: 가능한 차수는 $$0,1,\dots,n-1$$ 중 **둘(0과 n-1)을 동시에 가질 수 없음**.
즉 상자 수는 최대 $$n-1$$. 그런데 정점은 $$n$$개 ⇒ 같은 차수 둘 존재(PHP).

---

### 7.2 손악수(Handshake) 변형
파티에 $$n$$명. 누가 누구와 악수했는지를 그래프로 보면,
두 사람의 악수 횟수가 같음을 보일 수 있음(바로 위 정리의 특수형).

---

## 8. 컴퓨터 과학·정보이론 응용

### 8.1 해시 충돌 불가피
버킷 $$n$$개에 키 $$k>n$$ ⇒ **충돌 존재**.
따라서 **충돌 처리 전략**(체이닝, 오픈 어드레싱)은 **필수 설계 요소**.

### 8.2 무손실 압축의 보편 한계
길이 $$L$$ 비트 파일의 전체 수는 $$2^L$$.
모든 입력을 **더 짧게**(길이 $$<L$$) 압축하려면 상자 수 $$<2^L$$ 에
물건 $$=2^L$$ 을 넣어야 함 ⇒ **전사 불가**.
즉 **모든 파일을 항상 더 짧게**는 **불가능**(반드시 충돌/손실/비가역 발생).

### 8.3 버스·포트·MAC/UUID 충돌 분석
ID 공간이 유한하면(상자 유한), 대량 배치 시 **충돌 분석**은 PHP + 확률(생일 경계)로 접근.

---

## 9. 자주 나오는 증명 패턴

1) **쌍/묶음 상자**: “합이 일정”, “차가 일정”을 쌍으로 묶어 상자 정의.
2) **나머지 상자**: 모듈러 $$m$$ 의 동치류.
3) **구간 분할**: 실수/각도/둘레를 균등 분할.
4) **평균 초과**: $$\lceil k/n\rceil$$ 상자 존재를 곧장 인용.
5) **불가능성 증명**: “모든 상자에 $$\le r-1$$” 가정 → 총합 한계와 모순.

---

## 10. 자주 하는 실수(함정)

- **상자 정의가 겹치거나 빠짐**: 상자는 **서로배타·전집포함**이어야 함.
- **경계값 누락**: $$k=n$$, $$k=n+1$$ 같은 최소 반례 경계를 점검.
- **확률 문제와 혼동**: PHP는 **결정적 보장**.
- **무한/유한 혼동**: 무한 PHP의 요건(상자 유한/가산)을 분명히.

---

## 11. 연습문제(해설 포함)

### (1) 10개의 정수를 고르면, 두 수의 차가 9의 배수인 쌍이 있다.
**풀이**: 나머지 상자 $$\{0,\dots,8\}$$ 9개에 10개 수 ⇒ 같은 나머지 두 수 ⇒ 차가 9의 배수.

---

### (2) 실수 8개를 $$[0,1]$$ 에서 고르면, 두 수의 차가 $$\le 1/7$$ 인 쌍 존재.
**풀이**: 구간 $$[0,1]$$ 을 길이 $$1/7$$ 로 7개 상자 분할 ⇒ 8개 점 ⇒ 같은 상자 두 점 ⇒ 차 $$\le 1/7$$.

---

### (3) 길이 6의 이진열 $$64$$개 중 임의의 33개를 고르면, 두 개는 해밍거리 $$\le 2$$.
**힌트**: **구(해밍볼)** 로 상자 만들기(반지름 1 또는 2) 후, **서로 겹치지 않는 상자 개수 상한** 추정.

---

## 12. 파이썬 실험 코드

### 12.1 평균 이상 상자 존재(검증)
```python
from math import ceil
from collections import Counter
import random

def pigeon_ceiling(items, n_bins):
    # 무작위 배치
    bins = [i % n_bins for i in items]  # 단순 분배 예시
    c = Counter(bins)
    return c, max(c.values()), ceil(len(items)/n_bins)

# 예: 23개 항목, 7개 상자
c, mx, need = pigeon_ceiling(range(23), 7)
print("분포:", dict(c))
print("최대 개수:", mx, " / 보장 하한:", need)
assert mx >= need
```

### 12.2 해시 충돌 시연(버킷 개수 < 키 개수)
```python
def collisions(keys, n_buckets):
    buckets = {}
    col = []
    for k in keys:
        h = hash(k) % n_buckets
        if h in buckets:
            col.append((k, buckets[h], h))
        else:
            buckets[h] = k
    return col

cols = collisions([f"k{i}" for i in range(50)], 40)
print("충돌 예:", cols[:3], "... 총", len(cols), "건")
assert len(cols) >= 10  # PHP상 최소 10건은 기대(상한은 해시/분포에 따라 달라짐)
```

### 12.3 구간 분할로 근접 쌍 찾기(디오판토스 스타일)
```python
def close_pair_on_unit_interval(xs, parts):
    # xs ∈ [0,1), parts개의 균등 구간
    bins = [[] for _ in range(parts)]
    for x in xs:
        i = min(int(x*parts), parts-1)
        bins[i].append(x)
    for i, b in enumerate(bins):
        if len(b) >= 2:
            b.sort()
            return i, b[0], b[1], abs(b[1]-b[0])  # 같은 구간 내 가장 가까운 두 점
    return None

import random
random.seed(0)
xs = [random.random() for _ in range(8)]
i, a, b, d = close_pair_on_unit_interval(xs, 7)
print(f"구간 {i} 내 근접쌍: {a:.4f}, {b:.4f}, 거리 {d:.4f} ≤ {1/7:.4f}")
assert d <= 1/7 + 1e-12
```

---

## 13. 요약 표

| 형태 | 진술 | 전형 상자 |
|------|------|-----------|
| 기본 | $$k>n \Rightarrow \exists\ H:\#H\ge2$$ | 항목 자체 |
| 일반 | $$\exists\ H:\#H\ge\lceil k/n\rceil$$ | 평균/천장 |
| 강한 | $$k>(r-1)n \Rightarrow \#H\ge r$$ | 대우 논변 |
| 나머지 | $$m+1$$ 정수 ⇒ 같은 나머지 | $$\bmod m$$ |
| 구간 | 점과 거리/각도 근접 | 등분 구간 |
| 그래프 | 같은 차수 정점 존재 | 차수 집합 |
| CS | 해시 충돌/압축 불가 | 버킷/코드공간 |

---

## 14. 마무리

- **핵심은 상자를 어떻게 정의하느냐**: 나머지·쌍·구간·차수·ID공간 등.
- **평균–최댓값/최솟값** 사고로 **천장/바닥**을 즉시 꺼낼 것.
- **불가능성·한계 증명**(충돌·압축·부등식)에서 매우 강력.
- 확률/기하/그래프/수론/알고리즘 전 분야에 등장하므로 **상자 설계 감각**을 꾸준히 연습하자.
