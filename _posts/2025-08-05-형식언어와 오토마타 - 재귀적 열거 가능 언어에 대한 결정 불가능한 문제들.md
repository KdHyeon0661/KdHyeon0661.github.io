---
layout: post
title: 형식언어와 오토마타 - 재귀적 열거 가능 언어에 대한 결정 불가능한 문제들
date: 2025-08-05 22:20:23 +0900
category: 형식언어와 오토마타
---
# 재귀적 열거 가능 언어(RE/c.e.)에 대한 **결정 불가능한 문제들**

**요지**  
- RE(= c.e., 반결정) 언어는 “**예(수용)** 사례를 **열거**할 수 있는” 언어다.  
- RE 언어나 그것을 기술하는 **튜링 기계/무제한 문법/재작성 시스템**에 대해 묻는 많은 자연스러운 결정 문제들이 **결정 불가능**하다.  
- 핵심 도구: **정지 문제(HALT)**, **\(A_{TM}\)**, **Rice 정리**, **many-one 감소**(m-reduction), **도베일링(dovetailing)**.  

---

## 1. 배경: RE(반결정) vs Recursive(결정)

- **RE(= c.e.) 언어 \(L\)**: 어떤 TM \(N\)이 \(w\in L\)이면 **언젠가 수용**(정지)한다. \(w\notin L\)이면 **무한 루프 가능**.  
  동치: “\(L\)의 원소를 **모두 출력**하는 열거기 존재”.
- **Recursive(결정 가능)** 언어 \(L\): 어떤 TM \(D\)가 **모든 입력에서 정지**하며 Yes/No를 낸다.
- 고전 등식:
  $$
  L \ \text{와} \ \overline{L} \ \text{가 모두 RE} \iff L \ \text{는 Recursive}.
  $$

> **직관**: RE는 “**존재적 증거**가 있으면 **언젠가** 잡힌다(수용 계산/증인)”.  
> Recursive는 “**언제나** 유한 시간에 답을 준다”.

---

## 2. 입력 표현(표준 인코딩)

- **튜링 기계** \(\langle M\rangle\): \(L(M)\)은 RE.  
- **무제한(Type-0) 문법** \(\langle G\rangle\): \(L(G)\)은 RE(튜링과 동치).  
- **Post/Thue 재작성**, **레지스터 머신**, **\(\lambda\)-계산** 등도 상호 변환 **가능**.  
→ 한 표현에서의 불가능성은 효과적 변환을 통해 다른 표현으로 **이전**된다.

---

## 3. 대표 **결정 불가능** 문제 지도

### 3.1 \(\Sigma^0_1\)(=RE) 수준의 **RE-완전(Σ¹₀-완전)**

1) **멤버십(\(A_{TM}\))**
\[
A_{TM}=\{\ \langle M\rangle \# w \mid M \text{이 } w \text{를 수용}\ \}
\]
- **RE**이며 **결정 불가능**(고전). **RE-완전**.

2) **정지(HALT)**
\[
HALT=\{\ \langle M\rangle \# w \mid M(w)\ \text{정지}\ \}
\]
- **RE-완전**(수용 대신 “정지” 판별).

3) **비공백성(Non-emptiness)**
\[
NE_{TM}=\{\ \langle M\rangle \mid L(M)\neq\varnothing\ \}
\]
- \(A_{TM}\le_m NE_{TM}\) (아래 §4.2) ⇒ **RE-완전**.

4) **PCP-YES**: 주어진 PCP 인스턴스에 **해가 존재**하는가 — **RE-완전**.

> **해석**: “**존재한다면** 유한한 **증거**(수용 계산/해)를 **언젠가** 찾을 수 있는” 류가 RE-완전.

---

### 3.2 \(\Pi^0_1\)(=co-RE) 수준의 **co-RE-완전**

1) **공백성(Emptiness)**
\[
E_{TM}=\{\ \langle M\rangle \mid L(M)=\varnothing\ \}=\overline{NE_{TM}}
\]
- **co-RE-완전**(결정 불가능).

2) 그 밖의 “**없다**/**절대 일어나지 않는다**” 류의 전역 성질 다수(예: “어떤 문자열도 수용하지 않는다”)가 보통 co-RE에 위치.

---

### 3.3 상위 계층(대개 \(\Pi^0_2, \Sigma^0_2\) 등) — 여전히 **결정 불가능**

1) **보편성(Universality)**
\[
ALL_{TM}=\{\ \langle M\rangle \mid L(M)=\Sigma^*\ \}
\]
- 전형적으로 **\(\Pi^0_2\)-완전**(RE도 co-RE도 아님).

2) **동치/포함/교차공백**
\[
\begin{aligned}
EQ_{TM}&=\{\langle M_1,M_2\rangle \mid L(M_1)=L(M_2)\},\\
SUB_{TM}&=\{\langle M_1,M_2\rangle \mid L(M_1)\subseteq L(M_2)\},\\
DISJ_{TM}&=\{\langle M_1,M_2\rangle \mid L(M_1)\cap L(M_2)=\varnothing\}
\end{aligned}
\]
- 보통 **\(\Pi^0_2\)** 수준(결정 불가능, RE/co-RE 아님).

3) **무한성/유한성**
\[
INF_{TM}=\{\langle M\rangle \mid |L(M)|=\infty\},\quad
FIN_{TM}=\{\langle M\rangle \mid |L(M)|<\infty\}
\]
- 대개 \(INF_{TM}\)은 **\(\Pi^0_2\)-완전**, \(FIN_{TM}\)은 **\(\Sigma^0_2\)-완전**.

4) **총정지성(Totality)** — 모든 입력에서 정지?
\[
TOT=\{\ \langle M\rangle \mid \forall w\, M(w)\downarrow \ \}
\]
- 전형적으로 **\(\Pi^0_2\)-완전**.

---

### 3.4 **Rice 정리**로 한 번에 묶이는 **의미 속성**들

> **Rice 정리**: “TM이 **계산하는 함수/언어의 의미**에 대한 **비자명한 속성**”은 모두 **결정 불가능**.

- “\(L(M)\)이 **정규/문맥자유**인가?” — **결정 불가능**.  
- “\(L(M)\)이 **유한/무한/코유한**인가?” — **결정 불가능**(보통 \(\Sigma^0_2/\Pi^0_2\)).  
- “\(L(M)\)이 **주어진 무한 언어**와 **동일**한가?” — **결정 불가능**.  
- “특정 패턴이 **무한히 많이** 등장하는가?” — **결정 불가능**.

> 예외: “**특정 하나의 문자열** \(w_0\)이 \(L(M)\)에 속하는가?”는 \(A_{TM}\)으로 떨어져 **RE-완전**.

---

## 4. 전형적인 **감소(감수) 스케치 & 레시피**

### 4.1 도베일링으로 “양쪽 RE ⇒ 결정”

\[
L,\ \overline{L} \ \text{둘 다 RE} \ \Rightarrow\ L \ \text{Recursive}
\]

```text
Decide(w):  # M_yes: L 인식기, M_no: 보수 인식기
  for t = 1,2,3,...:
    simulate M_yes(w) for t steps; if accept: return YES
    simulate M_no (w) for t steps; if accept: return NO
```

---

### 4.2 \(A_{TM} \Rightarrow NE_{TM}\) (many-one)

**목표**: \(\langle M\rangle\#w \in A_{TM} \iff \langle N\rangle \in NE_{TM}\).  
**구성**: 입력을 **무시**하고 \(M(w)\)를 시뮬레이션하는 \(N\)을 만든다.

```text
# f(<M>#w) = <N> 을 구축
N(x):
  simulate M(w)
  if M(w) accepts:
     accept         # 모든 x를 수용 → L(N) = Σ*
  else:
     loop forever   # 어떤 x도 수용 안 함 → L(N) = ∅
```

따라서
\[
\langle M\rangle\#w\in A_{TM}\ \iff\ L(N)=\Sigma^*\neq\varnothing\ \iff\ \langle N\rangle\in NE_{TM}.
\]
⇒ \(NE_{TM}\) **RE-완전**.

> 같은 트릭으로 \(A_{TM}\le_m ALL_{TM}\) 도 성립(수용 ⇔ \(L(N)=\Sigma^*\)).  
> 단, \(ALL_{TM}\) 자체는 상위 계층(\(\Pi^0_2\))이지만 **결정 불가능**임을 보이는 데 충분.

---

### 4.3 \(A_{TM} \Rightarrow EQ_{TM}\) (동치성)

- \(N_1\): **입력을 무시**하고 \(M(w)\)가 수용하면 모든 입력을 수용, 아니면 루프  
  → \(L(N_1)=\Sigma^*\) **또는** \(\varnothing\).
- \(N_2\): **항상 수용** → \(L(N_2)=\Sigma^*\).

그러면
\[
M(w)\ \text{수용} \iff L(N_1)=\Sigma^* = L(N_2) \iff \langle N_1,N_2\rangle \in EQ_{TM}.
\]
⇒ **동치성**은 **결정 불가능**(보통 RE/co-RE도 아님).

---

### 4.4 “정규성/문맥자유성 여부” (Rice로 즉시)

속성 \(P(L)\) = “정규(또는 CFL)이다”는 **비자명 의미 속성**.  
Rice 정리 적용 → **결정 불가능** (상세 감소 불요).

---

### 4.5 무한성/유한성 (상위 계층 도식)

- “무한하다”:
  $$
  \exists n\ \forall w\ (|w|>n \Rightarrow \exists t\ \text{(길이 \(t\) 안에 수용)})
  $$
  내부 “\(w\in L(M)\)”가 \(\Sigma^0_1\)이므로 전체가 보통 **\(\Pi^0_2\)**.  
- “유한하다”는 보통 **\(\Sigma^0_2\)**.

---

## 5. **감소 레시피** (재사용 가능한 설계 패턴)

### 5.1 “스위치 머신” 패턴 \(N_{x,P}\)
주어진 \(x=\langle M\rangle\#w\)에 대해, 목표 속성 \(P\)를 만족/불만족시키는 머신을 **입력 무시** 방식으로 생성.

```text
BuildSwitch(<M>#w, P):
  define N:
    on any input y:
      simulate M(w)
      if M(w) accepts:
         behave as Machine_Yes(P)   # P를 '강하게' 만족하는 행동(예: ALL: always accept)
      else:
         behave as Machine_No (P)   # P를 '강하게' 깨는 행동(예: ALL: loop forever)
  return <N>
```

- 예: \(P=\) “비공백” → Yes: always accept, No: loop → §4.2와 동일.

### 5.2 “전이 지역검사” 패턴(문법/PCP/재작성에 유용)
- **구분자(#)** 로 구성 경계를 표시.  
- **문자 일치 타일/규칙**과 **전이 타일/규칙**으로 “합법적 계산 이력”만 통과.  
- 시작/종료 **강제 타일**로 올바른 첫/끝 행만 생성되도록 고정.  
→ PCP-YES, Type-0 문법 속성 등에 광범위하게 사용.

---

## 6. 실전 스니펫(의사코드)

### 6.1 RE 인식기(“예면 언젠가 수용”)

```text
Recognize_ATM(<M>#w):
  simulate M(w) step-by-step
  if M(w) ever accepts:
     ACCEPT
  # else: possibly loop forever
```

### 6.2 RE 열거기(도베일링)

```text
Enumerate_ATM():
  for s = 1,2,3,...:
    for all encodings (<M>, w) with |<M>#w| ≤ s:
       simulate M(w) for s steps
       if acceptance observed within s:
          output <M>#w
```

### 6.3 합/교(두 RE 언어) 인식기 조립

```text
Recognize_Union(w):       # L1 ∪ L2
  for t = 1,2,3,...:
    step M1(w); if M1 accepted: ACCEPT
    step M2(w); if M2 accepted: ACCEPT

Recognize_Intersection(w):  # L1 ∩ L2
  f1 := False; f2 := False
  for t = 1,2,3,...:
    step M1(w); if M1 accepted: f1 := True
    step M2(w); if M2 accepted: f2 := True
    if f1 and f2: ACCEPT
```

### 6.4 “양쪽 RE ⇒ 결정” 도베일링

```text
Decide_if_both_RE(w):   # M_yes recognizes L, M_no recognizes complement
  for t = 1,2,3,...:
    step M_yes(w); if M_yes accepted: return YES
    step M_no (w); if M_no  accepted: return NO
```

---

## 7. 한눈표 — RE 관련 대표 결정 문제 분류

| 문제 | 정의 요약 | 분류(전형) | 비고 |
|---|---|---|---|
| \(A_{TM}\) | \(\langle M\rangle\#w\)이 수용? | **RE-완전** (\(\Sigma^0_1\)) | 멤버십 |
| \(HALT\) | \(\langle M\rangle\#w\)이 정지? | **RE-완전** (\(\Sigma^0_1\)) | 정지 여부 |
| \(NE_{TM}\) | \(L(M)\neq\varnothing\)? | **RE-완전** (\(\Sigma^0_1\)) | §4.2 |
| \(E_{TM}\) | \(L(M)=\varnothing\)? | **co-RE-완전** (\(\Pi^0_1\)) | \(\overline{NE_{TM}}\) |
| \(ALL_{TM}\) | \(L(M)=\Sigma^*\)? | **\(\Pi^0_2\)-완전** | RE/co-RE 아님 |
| \(EQ_{TM}\) | \(L(M_1)=L(M_2)\)? | **\(\Pi^0_2\)-완전** | 〃 |
| \(SUB_{TM}\) | \(L(M_1)\subseteq L(M_2)\)? | **\(\Pi^0_2\)-완전** | 〃 |
| \(DISJ_{TM}\) | 교차공백? | **\(\Pi^0_2\)-완전** | 〃 |
| \(INF_{TM}\) | \(|L(M)|=\infty\)? | **\(\Pi^0_2\)-완전** | 무한성 |
| \(FIN_{TM}\) | \(|L(M)|<\infty\)? | **\(\Sigma^0_2\)-완전** | 유한성 |
| “정규성?” | \(L(M)\in REG\)? | **Undecidable** | Rice |
| “CFL성?” | \(L(M)\in CFL\)? | **Undecidable** | Rice |

> **핵심만 기억**:  
> - **존재적(∃)** 질의는 보통 **RE/RE-완전**.  
> - “없다(∀¬)”는 **co-RE**.  
> - “전역적 ∀∃ 섞임(보편/동치/포함/무한성)**은** 상위 계층(\(\Pi^0_2/\Sigma^0_2\)).

---

## 8. 연습 시나리오(감소 구성 연습)

1) **멤버십 → 보편성**  
   \(f(\langle M\rangle\#w)=\langle N\rangle\) 를 §4.2 방식으로 만들되,  
   \(M(w)\) 수용 ⇒ \(L(N)=\Sigma^*\), 아니면 \(\varnothing\).  
   ⇒ \(\langle M\rangle\#w\in A_{TM}\iff \langle N\rangle\in ALL_{TM}\).

2) **멤버십 → 동치성**  
   \(N_1\): 수용 시 \(\Sigma^*\), else \(\varnothing\). \(N_2\): \(\Sigma^*\).  
   ⇒ \(A_{TM}\le_m EQ_{TM}\).

3) **Rice 적용 확인**  
   속성 \(P\): “\(L(M)\)이 정규”는 비자명 의미 속성.  
   ⇒ 결정 불가능(구체 감소 불요).

---

## 9. 결론

- RE 세계에서 자연스러운 질문들—**멤버십, 정지, 비공백/공백, 보편, 동치/포함, 정규성/CFL성, 유한/무한**—의 상당수가 **결정 불가능**이다.  
- **패턴 인식**:  
  - “**증거가 있으면 나온다(∃)**” → 대개 **RE/RE-완전**.  
  - “**없음을 보이라(∀¬)**” → **co-RE**.  
  - “**∀와 ∃가 얽히면**” → 보통 **\(\Pi^0_2/\Sigma^0_2\)**.  
- **무기**: **Rice 정리**, **many-one 감소**, **도베일링**, **계산 이력 인코딩**.  
- **메시지**: 완전 자동 검증/분석의 한계는 대개 이 **계층의 벽**에서 온다.  
  문제를 **제한된 모델(정규/CFL/유한 상태 등)**로 **재정의**하면 많은 속성이 다시 **결정 가능**해진다.