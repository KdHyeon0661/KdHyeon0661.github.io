---
layout: post
title: 컴퓨터시스템 - 표준 I/O
date: 2025-09-05 19:20:23 +0900
category: 컴퓨터시스템
---
# 표준 I/O(Standard I/O)

## 1. 표준 I/O란 무엇인가 — 개념과 계층

- **표준 I/O(standard I/O)**: OS의 **파일 디스크립터(int fd)** 위에 **`FILE*` 스트림**을 얹어 **버퍼링**과 **포맷 변환**(printf/scanf 계열)을 제공하는 **고수준 I/O 라이브러리**.
- 목적:
  1) **시스템콜 호출 수 감소**(버퍼링으로 성능 향상)
  2) **이식성**(플랫폼이 달라도 동일 API)
  3) **인간 친화적 포맷 변환**(`%d`, `%s`, `%f`, `%zu` 등)

### 1.1 `FILE*` 계층과 커널의 관계(개념도)

```
   사용자 코드      ─────────────→  stdio (FILE*)  ─────→  syscalls(read/write)  ──→ 커널
   printf/fgets/…                          ↑                           ↑
                                           └──────── 버퍼(유저 공간) ───┘
```

- `FILE*`는 내부에 **버퍼 포인터/크기/현재 위치/상태 플래그/연결된 fd** 등을 보관한다.
- 같은 **fd**를 공유해도 **서로 다른 `FILE*` 버퍼**는 **독립** → 혼용 시 **순서 꼬임** 주의(§10.2).

---

## 2. 스트림과 `FILE` — 내부를 이해하면 버그가 줄어든다

### 2.1 스트림의 분류와 기본 스트림 3종
- **텍스트 스트림** vs **바이너리 스트림**
  - POSIX: 차이 없음.
  - Windows: 텍스트 모드에서 `\n` ↔ `\r\n` 변환, `^Z` 처리.
- **표준 스트림**: 프로그램 시작 시 자동 오픈
  | 스트림 | 매크로 | 기본 용도 | 기본 버퍼링(일반적 구현) |
  |---|---|---|---|
  | 표준입력 | `stdin` | 입력 | 터미널: **줄 버퍼링** |
  | 표준출력 | `stdout` | 정상 출력 | 터미널: **줄 버퍼링**, 파일/파이프: **전부 버퍼링** |
  | 표준오류 | `stderr` | 오류/로그 | **버퍼 없음**(즉시 출력) |

> 실제 버퍼링 모드는 구현/연결 대상에 따라 달라질 수 있음(터미널 여부 등). 확정하려면 `setvbuf`로 명시.

### 2.2 `FILE` 내부(개념적)
표준은 `FILE`의 레이아웃을 정의하지 않지만, 개념적으로 다음 상태를 가진다:
- 버퍼 영역(포인터, 크기, 남은 바이트)
- 파일 오프셋(커널 오프셋과 동기화 시점 주의)
- 스트림 모드(읽기/쓰기/업데이트), 에러/EOF 플래그
- 락(스레드 안전 구현 시)

---

## 3. 핵심 API 총정리

### 3.1 열기/닫기/에러
```c
FILE *fopen(const char *path, const char *mode);     // "r", "w", "a", "r+", "w+", "a+" + "b" + (C11+) "x"
FILE *freopen(const char *path, const char *mode, FILE *stream);
int   fclose(FILE *stream);                           // 성공 0, 실패 EOF(-1)
void  clearerr(FILE *stream);
int   feof(FILE *stream);   // EOF 플래그 확인(에러와 구분 필요)
int   ferror(FILE *stream); // 에러 플래그 확인
```
- **`"x"`(C11+)**: **배타적 생성**(이미 존재 시 실패, POSIX `O_EXCL` 유사).
- 실패 시 `errno` 설정. `perror()`/`strerror(errno)`로 진단.

### 3.2 문자/문자열/블록 I/O
```c
int    fgetc(FILE *s);             int fputc(int c, FILE *s);
char  *fgets(char *s, int n, FILE *s);
int    fputs(const char *s, FILE *s);
size_t fread(void *ptr, size_t sz, size_t nmemb, FILE *s);
size_t fwrite(const void *ptr, size_t sz, size_t nmemb, FILE *s);
```
- `fgets`는 최대 `n-1`문자 + `'\0'`, 개행 포함 가능.
- `fread/fwrite`는 **요소 개수**를 반환(바이트 수 아님).

### 3.3 위치 이동/버퍼 제어/플러시
```c
int    fseek(FILE *s, long off, int whence);    // 바이너리에서만 신뢰
long   ftell(FILE *s);
void   rewind(FILE *s);
int    fgetpos(FILE *s, fpos_t *pos);
int    fsetpos(FILE *s, const fpos_t *pos);

int    fflush(FILE *s);  // 출력 버퍼 비움(입력 스트림에 대한 fflush는 표준상 "정의되지 않음")
void   setbuf(FILE *s, char *buf);
int    setvbuf(FILE *s, char *buf, int mode, size_t size); // _IOFBF/_IOLBF/_IONBF
```
- **텍스트 모드에서 `fseek/ftell`은 제약** → **바이너리 모드** 권장(Windows).
- POSIX 대용량: **`fseeko/ftello`**(off_t, 64비트) 사용 권장.

### 3.4 포맷 I/O
```c
int printf(const char *fmt, ...);            int scanf(const char *fmt, ...);
int fprintf(FILE *s, const char *fmt, ...);  int fscanf(FILE *s, const char *fmt, ...);
int snprintf(char *buf, size_t n, const char *fmt, ...);
int vprintf(const char *fmt, va_list ap);    // va_list 계열
```
- **길이 한정 `snprintf`** 사용 습관화(버퍼 오버런 방지).
- 스캔은 실패/부분 매치 주의 → **반환값(매치 개수)** 반드시 확인.

### 3.5 기타(유용/확장)
- **POSIX**: `getline`, `getdelim`(동적 버퍼 자동 확장 — 매우 실용적)
- **POSIX**: `popen/pclose`(파이프를 스트림으로)
- **잠금**: `flockfile/ftrylockfile/funlockfile` + **unlocked API**(`getc_unlocked` 등)
- **Windows**: `_setmode(_fileno(stream), _O_BINARY)`로 텍스트↔바이너리 전환 가능.

---

## 4. 버퍼링 모드와 flush 규칙 — **출력 사라짐**을 막는 법

| 모드 | 의미 | 대표 사례 | flush 시점 |
|---|---|---|---|
| **_IOFBF** (전부 버퍼링) | 버퍼가 **가득** 차면 | 파일/파이프 | 버퍼 full, `fflush`, `fclose`, 정상 종료 |
| **_IOLBF** (줄 버퍼링) | `\n` 만나면 | 터미널 연결 stdout | `\n`, `fflush`, `fclose` |
| **_IONBF** (버퍼 없음) | 즉시 시스템콜 | `stderr` | 매 호출 |

- **프롬프트 출력 후 입력**을 받을 땐 **반드시 `fflush(stdout)`**:
```c
printf("이름: "); fflush(stdout); fgets(name, sizeof name, stdin);
```
- **비정상 종료/`_exit()`** → stdio 버퍼가 **flush되지 않음**. (자식 프로세스에서 `exec` 없이 `exit` 대신 `_exit`하면 버퍼 유실 위험 없음 → 반대로 부모 출력이 flush 되지 않은 상태로 `fork`한 뒤 **부모/자식 둘 다** 같은 버퍼를 출력하면 **중복 출력** 발생. §10.3)

---

## 5. 업데이트 모드(`r+`, `w+`, `a+`) — **읽기와 쓰기의 전환 규칙**

**중요 규칙(표준)**: 업데이트 모드 스트림에서 **입력 뒤 출력**(또는 그 반대)을 하려면 **중간에 위치 이동**이 필요하다.
- 표준 문구: “입력과 출력 연산 사이에는 **`fseek`/`fsetpos`/`rewind`** 중 하나가 있어야 한다(단, 특정 구현에서는 `fflush`가 출력→입력 전환에만 동작).”
- **`fflush(stdin)`은 정의되지 않음**. (POSIX 구현 일부에서 동작할 수 있으나 **의존 금지**)

예: 파일 맨 앞 정수 하나 읽고 이어서 다른 정수 쓰기
```c
FILE *fp = fopen("x.txt","r+");
int x; fscanf(fp, "%d", &x);
fseek(fp, 0, SEEK_END);               // 전환(필수) + 위치 지정
fprintf(fp, " %d\n", x+1);
fclose(fp);
```

**`a`/`a+`의 특수성**: **모든 출력은 파일 끝으로 이동한 뒤 수행**(POSIX). `fseek`로 중간에 위치시켜도 **쓰기 자체는 EOF로**.

---

## 6. 포맷 출력(printf 계열) — 정확한 길이/서식/안전

### 6.1 길이 지정자 요약(자주 쓰는 것)
| 형 | 정수 | 부호 없는 | 포인터/size/ptrdiff |
|---|---|---|---|
| 기본 | `%d`/`%i` | `%u` | `%p` |
| `long` | `%ld` | `%lu` |  |
| `long long` | `%lld` | `%llu` |  |
| `size_t` |  | **`%zu`** |  |
| `ssize_t`/`ptrdiff_t` | **`%zd`** |  |  |
| 고정폭 `<stdint.h>` | `PRId32` 등 매크로(`inttypes.h`) | `PRIu64` 등 |  |

- **정수형/포인터형에 정확한 지정자 사용** 필수. (예: `size_t n; printf("%zu", n);`)
- 부동소수점: `%f` `%.6f` `%.g` `%.a`(16진 float) 등.

### 6.2 `snprintf` 습관화
```c
char buf[64];
int n = snprintf(buf, sizeof buf, "id=%u name=%s", id, name);
if (n < 0 || (size_t)n >= sizeof buf) { /* 잘림 혹은 오류 처리 */ }
```

### 6.3 보안: 포맷 문자열 취약점
- **외부 입력을 절대 포맷 문자열로 직접 사용하지 말 것**:
```c
// 위험!
printf(user_supplied);      // "%n" 악용 등
// 안전
printf("%s", user_supplied);
```

---

## 7. 포맷 입력(scanf 계열) — **반환값 검사**가 생명

### 7.1 필수 규칙
- `scanf`는 **성공적으로 매치·저장한 항목 개수**를 반환.
- 실패/EOF/부분매치 구분을 **반환값으로만** 판단 가능 → **반환값 검사 필수**.
- **공백 문자**(`space`, `\t`, `\n`)는 **토큰 분리자**로 동작. `%c`/`%[]`/`%n` 제외.

### 7.2 안전한 패턴
```c
int x, y; char s[32];
if (scanf("%d %d %31s", &x, &y, s) != 3) { /* 에러 처리 */ }
```
- **필드 폭 지정**으로 오버런 방지(`%31s`).
- 실무에서는 숫자 파싱에 **`strtol/strtoul/strtod`**를 선호(에러 리포팅이 더 명확).

### 7.3 POSIX 확장
- `getline`/`getdelim`: **동적 버퍼** 자동 확장(§9.2).
- GNU 확장 `%m[...]/%ms`: **동적 할당**을 `scanf`가 수행(해제 책임은 호출자) — **이식성 낮음**.

---

## 8. 대용량/성능 최적화 — setvbuf, unlocked, 64비트 오프셋

### 8.1 버퍼 크기/모드
- 대량 순차 I/O: `setvbuf(fp, NULL, _IOFBF, 1<<20);` // 1MiB, 측정 기반 조정 권장
- 줄 지향 로그: 터미널/파이프면 기본 줄 버퍼로 충분. 파일 로그는 명시 flush 또는 `_IONBF` + `writev`(저수준) 고려.

### 8.2 락 비용 회피(unlocked API)
- 단일 스레드/락 보장 환경: `getc_unlocked`, `putc_unlocked`, `fread_unlocked`, `fwrite_unlocked`
  → `flockfile`/`funlockfile`로 구간 잠금+여러 호출 batched.

```c
flockfile(fp);
for (int i=0;i<n;i++) putc_unlocked(buf[i], fp);
funlockfile(fp);
```

### 8.3 64비트 파일 오프셋
- POSIX: **`fseeko/ftello`** 사용(오프셋 타입 `off_t`).
- 컴파일 시 `-D_FILE_OFFSET_BITS=64`로 투명 64비트 활성화(리눅스/glibc).

---

## 9. 실전 팁 — “잘 되는 코드” 레시피

### 9.1 안전한 라인 입력(표준 C만)
```c
int read_line(FILE *in, char *dst, size_t cap) {
    if (cap == 0) return -1;
    if (!fgets(dst, (int)cap, in)) {          // NULL: EOF 또는 에러
        return ferror(in) ? -2 : 0;           // -2: 에러, 0: EOF
    }
    size_t n = strlen(dst);
    if (n && dst[n-1] == '\n') dst[--n] = '\0';  // 개행 제거(선택)
    return (int)n;                              // 길이 반환
}
```

### 9.2 POSIX에서 더 편하게(동적 버퍼)
```c
// getline 예: buf=NULL, cap=0이면 getline이 malloc/resize
char *line = NULL; size_t cap = 0; ssize_t n;
while ((n = getline(&line, &cap, stdin)) != -1) {
    // line[0..n-1], 여기엔 개행 포함될 수 있음
}
free(line);
```

### 9.3 정확한 바이트 수 쓰기
```c
size_t write_all(FILE *out, const void *p, size_t n) {
    const unsigned char* s = p; size_t w = 0;
    while (w < n) {
        size_t k = fwrite(s+w, 1, n-w, out);
        if (k == 0) { if (ferror(out)) return w; } // 에러 발생
        w += k;
    }
    return w;
}
```

### 9.4 업데이트 모드 전환 규칙 **위반하지 않기**
```c
// r+ 예시: 읽고 → 쓰기 전환하려면 fseek/rewind/fsetpos 필요
int x; fscanf(fp, "%d", &x);
if (fseek(fp, 0, SEEK_END) != 0) { /* 에러 */ }
fprintf(fp, "%d\n", x);
```

---

## 10. 혼용·프로세스·스레드 — 미묘하지만 중요한 규칙

### 10.1 stdio vs 저수준 I/O **혼용 금지**
- 같은 fd에 대해 `FILE*`로도 쓰고 `write(2)`도 쓰면 **버퍼 불일치/순서 꼬임**.
- 정말 필요하다면 **`fflush(fp);`** → **`fsync(fd);`** 수준으로 동기화하고 **엄격한 순서 규약**을 둘 것. (권장하지 않음)

### 10.2 여러 `FILE*`가 같은 fd를 공유
- `dup`/`fdopen` 등으로 같은 fd를 둘 이상의 `FILE*`가 감싸면 버퍼가 **각자**라서 순서 붕괴 가능.
- **단일 래퍼만 사용**하거나, **락/프로토콜**로 순서 보장.

### 10.3 `fork()`와 버퍼
- **부모에서 flush 없이 `fork`** → 부모/자식이 **같은 버퍼 내용**을 각자 출력 → **중복**.
- 안전 패턴: `fflush(NULL);` 후 `fork()`, 혹은 자식은 `_exit()` 사용, 또는 `close`/`dup` 설계.

---

## 11. 텍스트 vs 바이너리/로케일/와이드 I/O

### 11.1 Windows 텍스트/바이너리
- `"rt"`/`"wt"`(기본 텍스트), `"rb"`/`"wb"` 권장. 바이너리에서만 파일 오프셋/크기 계산 일관.

### 11.2 로케일과 소수점/숫자 형식
- `setlocale(LC_ALL, "")` 이후 `printf("%f")`의 **소수점 기호**가 `,`가 될 수 있음.
- 로그/프로토콜은 **C 로케일**(기본) 유지 권장. 필요한 곳만 `uselocale`/`locale_t`.

### 11.3 와이드 스트림
```c
#include <wchar.h>
fwide(fp, 1);               // 와이드 지향(>0), 멀티바이트(<0), 아직 미정(0)
wprintf(L"%ls %d\n", L"안녕", 42);
fputwc(L'한', fp); fgetwc(fp);
```
- 한 스트림은 **멀티바이트 지향** 또는 **와이드 지향** 중 하나로 고정됨(처음 관련 호출 시 결정). 섞지 말 것.

---

## 12. 임시 파일과 안전한 생성

| 방법 | 표준 | 안전성 | 비고 |
|---|---|---|---|
| `tmpfile()` | C 표준 | 비교적 안전(자동 삭제) | 파일 시스템/권한 제약 |
| `tmpnam()`/`tempnam()` | C 표준(레거시) | **경쟁 조건** 취약 | **지양** |
| `mkstemp()` | POSIX | **안전**(O_EXCL) | fd 반환 → `fdopen`으로 `FILE*` 변환 |

```c
int fd = mkstemp(tmpl);     // tmpl 예: "logXXXXXX"
FILE *fp = fdopen(fd, "w");
```

---

## 13. 오류 처리 — EOF와 에러 구분

- **읽기**에서 0개 반환은 두 경우:
  1) **EOF**: 더 읽을 데이터 없음
  2) **오류**: `ferror(stream)`가 true
- 판정 패턴:
```c
size_t n = fread(buf, 1, SZ, fp);
if (n < SZ) {
    if (ferror(fp)) { /* 에러 */ }
    else if (feof(fp)) { /* EOF */ }
}
```
- `clearerr(stream)`로 에러/EOF 플래그 리셋.

---

## 14. 사례 연구 — “잘못되기 쉬운” 5가지와 교정

### 14.1 `fflush(stdin)` 사용
- **표준에서 미정의**. 입력 버퍼를 버리고 싶다면 **`fseek`/`rewind`**(파일) 또는 **남은 줄을 `fgets`로 소비**(터미널).

### 14.2 업데이트 모드 전환 누락
- 입력 뒤 곧바로 출력 → **UB**. **`fseek` 등으로 전환**.

### 14.3 `scanf("%s", buf)`에서 폭 미지정
- 버퍼 오버런 위험. **폭 지정**(예 `%31s`) 사용.

### 14.4 `printf(user_input)` 직접 사용
- 포맷 문자열 취약점. **항상 `"%s"`와 함께**.

### 14.5 같은 fd에 stdio + `write(2)`
- 버퍼 경합. **한 계층만** 사용.

---

## 15. 성능 관점: stdio vs RIO/저수준

- **짧은 I/O/EINTR 대응**이 중요한 **소켓/파이프**: 표준 I/O 대신 **RIO(robust I/O)** 또는 **저수준 + 이벤트 루프**가 더 안전(부분쓰기 처리 쉽다).
- **파일 순차 읽기/쓰기**: stdio가 간결하면서 빠름(버퍼링 덕분).
- **헤더+바디** 같이 여러 버퍼: stdio 대신 `writev`(저수준)의 이점 큼.

---

## 16. 확장: POSIX `getline/getdelim`와 “레코드 경계” 처리

```c
char *line = NULL; size_t cap = 0; ssize_t n;
while ((n = getdelim(&line, &cap, '\n', fp)) != -1) {
    // n 바이트 읽었고, line[n-1]이 구분자일 수 있음
}
free(line);
```
- 매우 긴 줄/가변 레코드에 **가장 안전·간단**.
- ISO C가 아님 → **이식성 요구 시** 래퍼를 두고 대체 구현 제공.

---

## 17. 스레드 안전과 파일 잠금

- 대부분 구현에서 `FILE*` 연산은 **내부 락**으로 **thread-safe(함수 단위)**.
- 고성능 멀티스레드에서 락 오버헤드가 문제면 **unlocked API** + **외부 `flockfile` 범위 잠금** 사용.
- 주의: **동일 `FILE*`를 여러 스레드가 읽기/쓰기 혼합**은 순서/전환 규칙 위반 위험 → 프로토콜로 제약.

---

## 18. 로그와 진단 — 줄 원자성과 즉시성

- 다중 작성자 로그: `stderr` 사용(무버퍼) 또는 `stdout`을 **줄 버퍼링** + **한 로그라인=한 번의 `fprintf`**를 지켜 **줄 원자성** 확보.
- 크래시 내구성까지 필요하면 **저수준 I/O + O_APPEND + fsync 주기** 고려.

---

## 19. 예제 모음

### 19.1 안전 프롬프트 + 라인 입력
```c
#include <stdio.h>
#include <string.h>

int main(void){
    char name[64];
    printf("이름을 입력하세요: ");
    fflush(stdout);                          // 프롬프트 즉시 출력
    if (!fgets(name, sizeof name, stdin)) {  // EOF/에러
        if (ferror(stdin)) perror("stdin");  // 에러
        return 1;                            // EOF면 0/1은 설계 선택
    }
    name[strcspn(name, "\n")] = '\0';        // 개행 제거
    printf("안녕하세요, %s\n", name);
    return 0;
}
```

### 19.2 대량쓰기 — 버퍼 크기 조율
```c
#include <stdio.h>
#include <stdlib.h>

int main(void){
    FILE *fp = fopen("big.bin", "wb");
    if (!fp) { perror("fopen"); return 1; }
    if (setvbuf(fp, NULL, _IOFBF, 1<<20) != 0) { /* 에러시 무시/로그 */ }

    const size_t N = 1000000;
    unsigned char *blk = malloc(N); if(!blk) return 2;

    for (int i=0;i<100;i++) {
        size_t w = fwrite(blk, 1, N, fp);
        if (w != N) { perror("fwrite"); break; }
    }
    free(blk);
    if (fclose(fp) != 0) perror("fclose");
    return 0;
}
```

### 19.3 업데이트 모드 전환 사례
```c
#include <stdio.h>

int main(void){
    FILE *fp = fopen("data.txt","r+");
    if (!fp) { perror("fopen"); return 1; }
    long head; if (fscanf(fp, "%ld", &head) != 1) { /* 처리 */ }

    // 입력→출력 전환: fseek 또는 fsetpos/rewind 필요
    if (fseek(fp, 0, SEEK_END) != 0) { perror("fseek"); }
    fprintf(fp, " %ld\n", head+1);

    if (fclose(fp) != 0) perror("fclose");
    return 0;
}
```

### 19.4 `getline`(POSIX)으로 안전하게 파일 읽기
```c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv){
    const char *path = (argc>1)?argv[1]:"/etc/hosts";
    FILE *fp = fopen(path, "r");
    if (!fp) { perror("fopen"); return 1; }

    char *line = NULL; size_t cap = 0; ssize_t n;
    while ((n = getline(&line, &cap, fp)) != -1) {
        // n 바이트, line[n-1] == '\n'일 수 있음
        fwrite(line, 1, (size_t)n, stdout);
    }
    free(line);
    fclose(fp);
    return 0;
}
```

### 19.5 `fdopen`으로 저수준 FD를 스트림으로
```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

int main(void){
    int fd = open("out.log", O_WRONLY|O_CREAT|O_APPEND, 0644);
    if (fd < 0) { perror("open"); return 1; }
    FILE *fp = fdopen(fd, "a");         // fd는 fp가 소유
    if (!fp) { perror("fdopen"); close(fd); return 1; }
    fprintf(fp, "hello\n");             // stdio 버퍼 경유
    fclose(fp);                         // fd도 함께 닫힘
    return 0;
}
```

---

## 20. Annex K(`*_s`)와 C23 동향(요약)

- **Annex K**(bounds-checking interfaces: `fopen_s`, `tmpfile_s` 등)는 **옵션**이며 **보편적이지 않음**. glibc는 미지원.
  → **휴대성 목표**라면 Annex K 사용 **지양**.
- **C23**: 표준 I/O에 **근본적 신설 함수는 없음**(주요 변경은 언어 규약/헤더 세부 정리).
  → 본 문서 내용은 **C11/C17과 동일하게 유효**.
- `gets()`는 **C11부터 제거**, 절대 사용 금지.

---

## 21. 체크리스트 — 배포 전 점검

- [ ] 프롬프트 후 **`fflush(stdout)`** 했는가?
- [ ] `scanf` **반환값**을 모두 점검했는가(필드 폭 포함)?
- [ ] **업데이트 모드 전환**에 `fseek/fsetpos/rewind`를 넣었는가?
- [ ] 같은 fd에 stdio와 `write(2)`를 **혼용하지 않았는가**?
- [ ] 크로스플랫폼이면 **바이너리 모드("b")**를 사용했는가(윈도우 개행 변환 방지)?
- [ ] 대용량이면 **`setvbuf`/`fseeko`/`ftello`** 적용했는가?
- [ ] 멀티스레드에서 **락 전략**(`flockfile`/unlocked)을 설계했는가?
- [ ] 종료 경로에서 **`fclose` 에러**를 확인/로그했는가?

---

## 22. 결론

- 표준 I/O는 **성능(버퍼링)**·**생산성(포맷 변환)**·**이식성**을 제공하는 **만능층**이지만,
  **업데이트 모드 전환 규칙**, **버퍼/flush 타이밍**, **혼용 금지** 같은 **규약을 모르면 미묘한 버그**를 초래한다.
- 파일 중심 순차 작업엔 stdio가 여전히 **최적 해법**.
- 소켓/파이프·이벤트 루프/부분 I/O 요구가 크다면 **RIO 또는 저수준 I/O**로 내려가자.
- 2025년 현재(C23): **기본 규칙은 변하지 않았다**. 올바른 규칙과 패턴을 지키는 것이 가장 큰 최적화다.
