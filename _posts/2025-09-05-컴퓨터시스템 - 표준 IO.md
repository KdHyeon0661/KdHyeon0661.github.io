---
layout: post
title: 컴퓨터시스템 - 표준 I/O
date: 2025-09-05 19:20:23 +0900
category: 컴퓨터시스템
---
# 표준 I/O(Standard I/O) — 버퍼 기반 입출력 라이브러리 완전 정리

> **목표**:  
> `printf`, `scanf`, `fread`, `fwrite` 같은 함수를 제공하는 **C 표준 라이브러리(stdio.h)**의 구조와 동작, 버퍼링 전략, 내부 구현 원리를 깊이 이해하기.

---

## 1. 표준 I/O란?

- **표준 I/O(Standard Input/Output)** 는 C 언어에서 `stdio.h`에 정의된 **고수준(high-level) I/O 인터페이스**입니다.
- **저수준(low-level) I/O**(예: `read()`, `write()` 시스템 콜)를 직접 호출하는 대신, **버퍼를 두어 성능을 향상**시키고,  
  포맷 변환 기능(`%d`, `%s` 등)을 제공합니다.
- 운영체제 레벨의 **파일 디스크립터(FD)**와 달리, 표준 I/O는 **`FILE *` 구조체**로 파일을 다룹니다.

---

## 2. 표준 I/O의 주요 특징

| 항목 | 설명 |
|------|------|
| **추상화 수준** | OS의 파일 디스크립터를 감싸는 `FILE *` 포인터 |
| **버퍼링** | 데이터 입출력 시 중간 버퍼를 두어 시스템 콜 호출 횟수 감소 |
| **이식성** | 운영체제·플랫폼이 달라도 동일한 API (`fopen`, `fprintf` 등) 제공 |
| **형식 변환** | `printf`/`scanf` 계열이 포맷 문자열 기반 데이터 변환 지원 |
| **스트림(Stream)** | 모든 입력/출력을 바이트 흐름(stream)으로 처리 |

---

## 3. 스트림(Stream)과 `FILE` 구조체

### 3.1 스트림 개념
- 스트림: **연속된 바이트 흐름** (파일, 터미널, 네트워크 소켓 등)
- 표준 I/O 함수들은 **스트림 단위**로 데이터를 읽고 씀.

### 3.2 `FILE` 구조체(표준 라이브러리 내부)
- 내부에 **버퍼 포인터, 버퍼 크기, 현재 위치, 파일 디스크립터(FD)** 등을 보관.
- 구현 예(단순화):
```c
typedef struct {
    int fd;           // OS 파일 디스크립터
    char *buf;        // 버퍼 시작 주소
    int buf_size;     // 버퍼 크기
    int buf_pos;      // 현재 버퍼 위치
    int buf_count;    // 버퍼 내 유효 데이터 크기
    int mode;         // 읽기/쓰기/양방향 모드
} FILE;
```

---

## 4. 표준 I/O 함수 분류

### 4.1 파일 열기/닫기
```c
FILE *fopen(const char *path, const char *mode);
int fclose(FILE *stream);
```
- `mode`: `"r"` 읽기 / `"w"` 쓰기 / `"a"` 추가 / `"r+"` 읽기+쓰기
- `"b"` 플래그: 바이너리 모드(Windows에서 CRLF 변환 방지)

### 4.2 문자 단위 I/O
```c
int fgetc(FILE *stream);
int fputc(int c, FILE *stream);
```

### 4.3 문자열 단위 I/O
```c
char *fgets(char *s, int size, FILE *stream);
int fputs(const char *s, FILE *stream);
```

### 4.4 블록 단위 I/O
```c
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
```

### 4.5 포맷 입출력
```c
int fprintf(FILE *stream, const char *fmt, ...);
int fscanf(FILE *stream, const char *fmt, ...);
```

### 4.6 버퍼 조작
```c
void setbuf(FILE *stream, char *buf);
int setvbuf(FILE *stream, char *buf, int mode, size_t size);
```
- `mode`: `_IOFBF`(전부 버퍼링), `_IOLBF`(줄 단위), `_IONBF`(버퍼 없음)

---

## 5. 표준 스트림 3종

C 프로그램 시작 시 자동으로 열림:

| 스트림 | 매크로 | 기본 용도 | 기본 버퍼링 |
|--------|--------|-----------|--------------|
| 표준 입력 | `stdin` | 키보드 입력 | 줄 버퍼링(터미널) |
| 표준 출력 | `stdout` | 화면 출력 | 줄 버퍼링(터미널), 전체 버퍼링(파일) |
| 표준 오류 | `stderr` | 에러 메시지 | 버퍼링 없음 |

> **이유**: `stderr`는 오류 즉시 출력 보장(디버깅 편의)

---

## 6. 버퍼링 방식

| 모드 | 설명 | 예 |
|------|------|---|
| **전부 버퍼링(full buffering)** | 버퍼가 가득 찰 때 flush | 파일 입출력 |
| **줄 버퍼링(line buffering)** | `\n` 출력 시 flush | 터미널 stdout |
| **버퍼 없음(unbuffered)** | 호출 즉시 시스템 콜 | stderr |

### flush의 시점
- 버퍼가 가득 찼을 때
- `\n`이 출력되고, 스트림이 줄 버퍼링 상태이며 터미널 연결 시
- `fflush(FILE*)` 명시 호출 시
- `fclose()` 호출 시
- 프로그램 종료 시(정상종료)

---

## 7. 성능 이점

- 버퍼링 덕분에 `read`/`write` 호출 횟수를 줄여 **시스템 콜 오버헤드 감소**
- 예:  
  - 저수준 I/O: 1바이트 읽기 → `read()` 1000회 호출
  - 표준 I/O: 1KB 버퍼에 모아서 1회 `read()` 호출, 이후 메모리 복사

---

## 8. 표준 I/O vs 저수준 I/O

| 항목 | 표준 I/O(`stdio`) | 저수준 I/O(`read`/`write`) |
|------|-------------------|----------------------------|
| 단위 | 스트림(`FILE*`) | 파일 디스크립터(int) |
| 버퍼 | 사용자 공간 버퍼 존재 | OS 커널 버퍼만 |
| 기능 | 포맷 변환, 문자열 함수 | 바이트 단위 원시 I/O |
| 이식성 | 높음 | 비교적 낮음 |
| 성능 | 버퍼링으로 일반적으로 더 빠름 | 작은 I/O에 비효율적 |

---

## 9. 내부 동작 흐름 예시

```c
FILE *fp = fopen("data.txt", "r");
char buf[100];

fgets(buf, sizeof(buf), fp);
```

1. `fgets()` 호출
2. 버퍼에 읽을 데이터가 없으면 → `read()`로 OS에서 한 번에 여러 바이트 읽어 `FILE` 구조체 버퍼에 저장
3. 버퍼에서 요청한 줄(`\n`까지)을 복사하여 `buf`에 저장
4. 버퍼 포인터를 다음 위치로 이동

---

## 10. 버퍼 모드 제어 예제

```c
#include <stdio.h>

int main() {
    setvbuf(stdout, NULL, _IONBF, 0); // stdout 버퍼링 끄기
    printf("Hello");
    // flush 없이 즉시 출력됨
}
```

---

## 11. 표준 I/O 버그 주의 사항

- **버퍼 flush 누락**  
  - 프로그램 비정상 종료 시 `stdout` 버퍼 미출력 가능
- **`scanf`/`gets` 입력 처리 시 개행문자 남음**
  - `scanf("%d", &x);` 후 개행이 버퍼에 남아 다음 입력에 영향
- **멀티스레드 환경**  
  - 대부분의 구현에서 `FILE`은 쓰레드 안전(thread-safe)이지만 락 오버헤드 있음
- **`fork()` 후 버퍼 중복 출력 문제**  
  - 버퍼가 flush되지 않은 상태에서 `fork()`하면 부모·자식 둘 다 같은 버퍼 출력 → 중복

---

## 12. 요약

- 표준 I/O는 **편의성 + 버퍼링 + 이식성** 제공
- 버퍼 모드(전부/줄/없음)와 flush 타이밍을 이해해야 **성능과 정확성**을 모두 확보 가능
- 저수준 I/O 대비 시스템 콜 횟수를 줄여 성능 개선
- 포맷 변환, 문자열·블록 단위 입출력, 스트림 기반 제어 가능

---

## 13. 간단 예제

```c
#include <stdio.h>

int main() {
    char name[50];
    printf("이름을 입력하세요: "); // stdout 줄버퍼 → '\n' 없이 flush 안 될 수 있음
    fflush(stdout); // 강제 flush
    fgets(name, sizeof(name), stdin); // stdin 줄버퍼
    printf("안녕하세요, %s", name);
    return 0;
}
```

> **포인트**:  
> - 출력 후 입력을 받을 때는 `fflush(stdout)`로 줄 버퍼를 비워 사용자에게 프롬프트가 보이게 함.