---
layout: post
title: flask - 구조/아키텍처 패턴
date: 2025-09-21 20:25:23 +0900
category: flask
---
# 18. 구조/아키텍처 패턴

> 이 장은 Flask 기반 백엔드에서 **서비스/도메인 레이어 분리**, **DTO/스키마 분리**, **헥사고날/클린 아키텍처** 확장, **멀티테넌시(스키마/DB 분리)** 전략을 실전 코드와 함께 정리한다.  
> 모든 코드는 ``` 로 감싸며, 수식이 필요하면 $$...$$ 로 감싼다(본 장은 수식이 거의 없다).

---

## 18.1 왜 “레이어”가 필요한가

- **변경 축 분리**: 웹(프레임워크/라우트), 도메인 규칙, 인프라(DB/캐시/외부 API) 의 변경 주기가 다르다.
- **테스트성**: 핵심 도메인을 **웹/DB 없이** 단위 테스트 가능.
- **치환성**: SQLAlchemy→DynamoDB, REST→gRPC/GraphQL 전환 시 **경계**만 바꾸면 된다.
- **확장성**: 멀티테넌시/샤딩/이벤트(비동기) 등 cross-cutting concern을 **UoW/Repo** 레벨에서 흡수.

> 목표: “**핵심 도메인**은 최대한 **순수 파이썬**으로 유지하고, **Flask/SQLAlchemy/Auth/Cache**는 **어댑터**로 붙인다.”

---

## 18.2 표준 3-레이어 스케치

```
app/
├─ presentation/           # Flask 라우트, 스키마/DTO 직렬화
│  └─ http/
│     ├─ order_routes.py
│     └─ schemas.py       # marshmallow/pydantic
├─ application/            # UseCase/서비스, 트랜잭션 경계
│  ├─ order_service.py
│  └─ uow.py               # Unit of Work 인터페이스
├─ domain/                 # 엔티티/밸류/도메인 서비스/이벤트
│  ├─ models.py
│  ├─ services.py
│  └─ events.py
└─ infrastructure/         # 어댑터: Repo/SQLAlchemy/Cache/Bus
   ├─ repositories.py
   ├─ sqlalchemy_uow.py
   ├─ mappers.py
   └─ cache.py
```

핵심 규칙:
- **presentation → application → domain** 방향만 호출한다(역참조 금지).
- **domain** 은 Flask/SQLAlchemy를 모른다.
- **application** 은 트랜잭션·권한·외부 호출 orchestration을 담당한다.
- **infrastructure** 는 인터페이스 구현체(Repo/UoW/Bus)를 제공한다.

---

## 18.3 도메인/엔티티/밸류/도메인 서비스

### 18.3.1 엔티티/밸류 기본

```python
# app/domain/models.py
from dataclasses import dataclass, field
from decimal import Decimal
from typing import Iterable, Optional
import uuid

class DomainError(Exception): ...

@dataclass(eq=True)
class Money:
    amount: Decimal
    currency: str = "KRW"
    def __post_init__(self):
        if self.amount < 0:
            raise DomainError("negative money")
    def __add__(self, other: "Money") -> "Money":
        assert self.currency == other.currency
        return Money(self.amount + other.amount, self.currency)

@dataclass
class OrderLine:
    sku: str
    qty: int
    price: Money

@dataclass
class Order:
    id: str
    user_id: str
    lines: list[OrderLine] = field(default_factory=list)
    status: str = "draft"  # draft/placed/paid/canceled

    def add_line(self, sku: str, qty: int, price: Money):
        if self.status != "draft":
            raise DomainError("cannot add line after placed")
        self.lines.append(OrderLine(sku, qty, price))

    def total(self) -> Money:
        tot = Money(Decimal("0.00"), self.lines[0].price.currency if self.lines else "KRW")
        for l in self.lines:
            tot = tot + Money(l.price.amount * l.qty, l.price.currency)
        return tot

    def place(self):
        if not self.lines:
            raise DomainError("empty order")
        if self.status != "draft":
            raise DomainError("already placed")
        self.status = "placed"
```

### 18.3.2 도메인 서비스(규칙 캡슐화)

```python
# app/domain/services.py
from .models import Order, Money, DomainError

def apply_coupon(order: Order, code: str) -> None:
    if order.status != "draft":
        raise DomainError("coupon only in draft")
    if code == "WELCOME10":
        # 10% off
        for line in order.lines:
            line.price = Money(line.price.amount * Decimal("0.9"), line.price.currency)
```

도메인 서비스는 **IO 없음**을 원칙으로 한다(외부 호출은 Application 레이어에서).

---

## 18.4 DTO/스키마 분리

**도메인 객체**를 HTTP 요청/응답에 직접 노출하지 말고 **DTO/Schema** 로 변환한다.

### 18.4.1 Pydantic/Marshmallow 스키마

```python
# app/presentation/http/schemas.py
from pydantic import BaseModel, conint, constr, Field
from decimal import Decimal

class OrderLineIn(BaseModel):
    sku: constr(strip_whitespace=True, min_length=1)
    qty: conint(gt=0)
    price: Decimal = Field(gt=0)

class CreateOrderIn(BaseModel):
    user_id: str
    lines: list[OrderLineIn]

class OrderOut(BaseModel):
    id: str
    user_id: str
    total: Decimal
    currency: str
    status: str
```

### 18.4.2 DTO ↔ 도메인 변환

```python
# app/presentation/http/mappers.py
from app.domain.models import Order, Money

def dto_to_order(dto) -> Order:
    o = Order(id=str(uuid.uuid4()), user_id=dto.user_id)
    for l in dto.lines:
        o.add_line(l.sku, l.qty, Money(l.price, "KRW"))
    return o

def order_to_dto(o: Order):
    t = o.total()
    return {
        "id": o.id,
        "user_id": o.user_id,
        "total": str(t.amount),
        "currency": t.currency,
        "status": o.status,
    }
```

> **장점**: (1) 도메인 객체의 내부가 바뀌어도 API 계약은 안정, (2) 외부 입력을 **엄격 검증**.

---

## 18.5 애플리케이션 레이어: Use Case, UoW, Repo

### 18.5.1 Port/Interface

```python
# app/application/ports.py
from typing import Protocol, Optional
from app.domain.models import Order

class OrderRepository(Protocol):
    def get(self, id: str) -> Optional[Order]: ...
    def add(self, order: Order) -> None: ...
    def save(self, order: Order) -> None: ...

class UnitOfWork(Protocol):
    orders: OrderRepository
    def __enter__(self) -> "UnitOfWork": ...
    def __exit__(self, *args) -> None: ...
    def commit(self) -> None: ...
    def rollback(self) -> None: ...
```

### 18.5.2 서비스/유스케이스

```python
# app/application/order_service.py
from .ports import UnitOfWork
from app.domain.services import apply_coupon
from app.domain.models import DomainError

class OrderService:
    def __init__(self, uow: UnitOfWork):
        self.uow = uow

    def create_order(self, order: "Order"):
        with self.uow:
            self.uow.orders.add(order)
            self.uow.commit()

    def place(self, order_id: str):
        with self.uow:
            o = self.uow.orders.get(order_id)
            if not o: raise DomainError("order not found")
            o.place()
            self.uow.orders.save(o)
            self.uow.commit()

    def apply_coupon(self, order_id: str, code: str):
        with self.uow:
            o = self.uow.orders.get(order_id)
            if not o: raise DomainError("order not found")
            apply_coupon(o, code)
            self.uow.orders.save(o)
            self.uow.commit()
```

> 트랜잭션 경계는 **Use Case 단위**로 잡고, DB·메시지 발행을 **commit** 안에서/직후에 처리한다.

---

## 18.6 인프라 레이어: SQLAlchemy 리포지토리/UoW

### 18.6.1 매핑

```python
# app/infrastructure/mappers.py
from sqlalchemy.orm import registry, relationship, mapped_column
from sqlalchemy import Table, Column, String, Integer, ForeignKey, Numeric
from app.domain.models import Order, OrderLine, Money

mapper_registry = registry()
metadata = mapper_registry.metadata

orders = Table(
    "orders", metadata,
    Column("id", String, primary_key=True),
    Column("user_id", String, index=True),
    Column("status", String),
)

order_lines = Table(
    "order_lines", metadata,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("order_id", ForeignKey("orders.id")),
    Column("sku", String),
    Column("qty", Integer),
    Column("price_amount", Numeric(12,2)),
    Column("price_currency", String(3))
)

def start_mappers():
    mapper_registry.map_imperatively(
        Order,
        orders,
        properties={
            "lines": relationship(OrderLine, backref="order", cascade="all, delete-orphan")
        }
    )
    mapper_registry.map_imperatively(
        OrderLine,
        order_lines,
        properties={
            "price": composite(Money, order_lines.c.price_amount, order_lines.c.price_currency)
        }
    )
```

### 18.6.2 리포지토리/UoW 구현

```python
# app/infrastructure/repositories.py
from app.application.ports import OrderRepository
from app.domain.models import Order

class SqlAlchemyOrderRepository(OrderRepository):
    def __init__(self, session):
        self.session = session
    def get(self, id: str):
        return self.session.get(Order, id)
    def add(self, order: Order):
        self.session.add(order)
    def save(self, order: Order):
        # session flush on commit
        pass

# app/infrastructure/sqlalchemy_uow.py
from app.application.ports import UnitOfWork
from .repositories import SqlAlchemyOrderRepository

class SqlAlchemyUnitOfWork(UnitOfWork):
    def __init__(self, session_factory):
        self.session_factory = session_factory
    def __enter__(self):
        self.session = self.session_factory()
        self.orders = SqlAlchemyOrderRepository(self.session)
        return self
    def __exit__(self, *args):
        self.session.close()
    def commit(self): self.session.commit()
    def rollback(self): self.session.rollback()
```

앱 팩토리에서 주입:

```python
# app/__init__.py (발췌)
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.infrastructure.mappers import start_mappers, metadata
from app.infrastructure.sqlalchemy_uow import SqlAlchemyUnitOfWork
from app.application.order_service import OrderService

engine = create_engine(DATABASE_URL, pool_pre_ping=True, future=True)
Session = sessionmaker(bind=engine, expire_on_commit=False, autoflush=False)

start_mappers()
metadata.create_all(engine)

order_service = OrderService(uow=SqlAlchemyUnitOfWork(Session))
```

---

## 18.7 프레젠테이션(Flask) – 얇게 유지

```python
# app/presentation/http/order_routes.py
from flask import Blueprint, request, jsonify
from .schemas import CreateOrderIn, OrderOut
from .mappers import dto_to_order, order_to_dto
from app.application.order_service import OrderService
from app.domain.models import DomainError

bp = Blueprint("orders", __name__, url_prefix="/api/orders")

def _parse(model, data):
    return model.model_validate(data) if hasattr(model, "model_validate") else model(**data)

@bp.post("")
def create_order():
    dto = _parse(CreateOrderIn, request.get_json())
    order = dto_to_order(dto)
    try:
        current_app.order_service.create_order(order)
        out = order_to_dto(order)
        return jsonify(out), 201
    except DomainError as e:
        return {"error": str(e)}, 400

@bp.post("/<id>/place")
def place(id):
    try:
        current_app.order_service.place(id)
        return {}, 204
    except DomainError as e:
        return {"error": str(e)}, 400
```

> 라우트는 **인증/권한 확인**, **입출력 변환**, **서비스 호출**만 한다. 도메인 규칙은 절대 넣지 않는다.

---

## 18.8 헥사고날/클린 아키텍처로 확장

### 18.8.1 용어 정리
- **Ports**: 도메인이 기대하는 **추상 인터페이스** (Repo, Bus, Clock, PaymentGateway).
- **Adapters**: 그 포트를 구현한 **구체적 인프라** (SQLAlchemyRepo, RedisCache, StripeGateway).
- **Use Case**: 입력 DTO → **도메인 명령** → 결과/이벤트.

### 18.8.2 포트 추가 예: PaymentGateway / Clock

```python
# app/application/ports.py
class PaymentGateway(Protocol):
    def charge(self, order_id: str, amount: Decimal, currency: str) -> str: ...

class Clock(Protocol):
    def now(self) -> datetime: ...
```

어댑터:

```python
# app/infrastructure/stripe_gateway.py
import stripe
class StripePaymentGateway:
    def __init__(self, api_key): stripe.api_key = api_key
    def charge(self, order_id, amount, currency):
        res = stripe.PaymentIntent.create(amount=int(amount*100), currency=currency, metadata={"order_id":order_id})
        return res.id

# app/infrastructure/system_clock.py
from datetime import datetime, timezone
class SystemClock:
    def now(self): return datetime.now(timezone.utc)
```

Use case에서 의존성 주입:

```python
class CheckoutService:
    def __init__(self, uow: UnitOfWork, payments: PaymentGateway, clock: Clock):
        self.uow = uow; self.payments = payments; self.clock = clock
    def pay(self, order_id: str):
        with self.uow:
            o = self.uow.orders.get(order_id)
            amt = o.total()
            pid = self.payments.charge(o.id, amt.amount, amt.currency)
            o.status = "paid"
            self.uow.orders.save(o)
            self.uow.commit()
            return pid
```

> 테스트에서 PaymentGateway/Clock은 **Fake/Mock** 으로 대체 가능 → 도메인 테스트가 빠르고 안정적.

### 18.8.3 도메인 이벤트 & 아웃박스

- 도메인에서 `OrderPlaced` 등 **이벤트 객체** 생성
- **트랜잭션 내부**에 아웃박스 테이블에 저장 → 별도 워커가 발행(Exactly-once 근접)

```python
# app/domain/events.py
from dataclasses import dataclass
@dataclass
class OrderPlaced: order_id: str

# app/infrastructure/outbox.py
class OutboxUnitOfWork(SqlAlchemyUnitOfWork):
    def commit(self):
        super().commit()
        self._publish_outbox()  # 커밋 후 안전하게 발행
```

---

## 18.9 CQRS(명령/조회 분리) 간단 패턴

- **명령(Command)**: UoW/도메인 규칙/트랜잭션, **ORM 채널**
- **조회(Query)**: 읽기 최적화 SQL/뷰/캐시, **ORM 또는 Raw SQL**로 직접 DTO 반환

```python
# app/application/queries.py
from sqlalchemy import text
def get_order_summary(session, order_id: str) -> dict:
    row = session.execute(text("""
        SELECT o.id, o.user_id, o.status, SUM(l.qty*l.price_amount) AS total
        FROM orders o JOIN order_lines l ON l.order_id=o.id
        WHERE o.id=:id GROUP BY o.id
    """), {"id": order_id}).mappings().first()
    return dict(row) if row else None
```

---

## 18.10 멀티테넌시 전략

### 18.10.1 세 가지 모델

1) **Row-level(공유 DB/공유 스키마)**: `tenant_id` 컬럼으로 구분  
   - 장점: 단순/저비용, 스케일 쉬움  
   - 단점: **보안 격리 약함**, 잘못된 쿼리로 누출 위험

2) **Schema-per-tenant(공유 DB/분리 스키마)**: `tenant_a.orders`, `tenant_b.orders`  
   - 장점: 적절 분리, 마이그레이션/백업 단위 명확  
   - 단점: 스키마 수가 많아지면 관리 복잡, 커넥션 캐시/풀 영향

3) **DB-per-tenant(분리 DB/커넥션)**  
   - 장점: **최강 격리**, 규제 대응, 스케일 아웃  
   - 단점: 비용↑, 연결/마이그레이션/운영 복잡

> **권장**: 초기에는 **Row-level** 또는 **Schema-per-tenant**, 보안/규모 요구가 높아지면 **DB-per-tenant** 로 일부 VIP 전환(하이브리드).

### 18.10.2 테넌트 컨텍스트 해석기

테넌트 ID를 **서브도메인**, **헤더(X-Tenant)**, **JWT 클레임** 에서 추출:

```python
# app/multitenancy/context.py
from flask import g, request

def resolve_tenant_id() -> str:
    tid = request.headers.get("X-Tenant")
    if not tid and request.host and "." in request.host:
        tid = request.host.split(".")[0]  # acme.example.com → acme
    if not tid:
        tid = "public"
    return tid

@app.before_request
def set_tenant():
    g.tenant_id = resolve_tenant_id()
```

### 18.10.3 Row-level 필터(전역 스코프)

```python
# app/infrastructure/tenant_scoping.py
from sqlalchemy.orm import Session, with_loader_criteria
from flask import g
from app.domain.models import Order

def tenant_session(SessionFactory):
    def _factory():
        s: Session = SessionFactory()
        tid = getattr(g, "tenant_id", None)
        if tid:
            s = s.execution_options(
                orm_load_options=with_loader_criteria(Order, lambda cls: cls.tenant_id == tid, include_aliases=True)
            )
        return s
    return _factory
```

모델에 `tenant_id` 컬럼 추가하고, **INSERT 시 자동 주입**:

```python
# app/infrastructure/listeners.py
from sqlalchemy import event
from flask import g
from app.domain.models import Order

@event.listens_for(Order, "before_insert")
def set_tenant_id(mapper, connection, target):
    if not getattr(target, "tenant_id", None):
        target.tenant_id = getattr(g, "tenant_id", "public")
```

### 18.10.4 Schema-per-tenant: `schema_translate_map`

PostgreSQL은 **search_path** 또는 **schema_translate_map** 으로 스키마 라우팅 가능:

```python
# app/infrastructure/schema_router.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from flask import g

def session_for_tenant(base_engine):
    def factory():
        schema = getattr(g, "tenant_id", "public")
        conn = base_engine.connect().execution_options(
            schema_translate_map={None: schema}
        )
        return sessionmaker(bind=conn, expire_on_commit=False)()
    return factory
```

- 매퍼 정의에서 스키마를 `None` 으로 두고, translate_map 으로 **실 스키마**로 매핑.
- **Alembic** 마이그레이션은 테넌트별로 **반복 실행**(자동화 필요).

### 18.10.5 DB-per-tenant: 커넥션 라우팅

테넌트 → DSN 매핑 테이블/캐시를 두고, 요청 시 세션을 해당 DSN으로 생성:

```python
# app/infrastructure/db_router.py
from functools import lru_cache
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from flask import g

@lru_cache(maxsize=1024)
def engine_for(dsn: str):
    return create_engine(dsn, pool_pre_ping=True, future=True)

def session_factory_resolver():
    dsn = lookup_tenant_dsn(getattr(g, "tenant_id", "public"))
    eng = engine_for(dsn)
    return sessionmaker(bind=eng, expire_on_commit=False)
```

> **주의**: 워커 프로세스 수 × 테넌트 수 만큼 커넥션 풀이 늘 수 있다. **풀 제한/엔진 캐시 정책**을 조정.

### 18.10.6 멀티테넌시와 캐시/스토리지

- **캐시 키**: `tenant:{tid}:key` 프리픽스 필수(서로의 데이터 누출 방지)
- **오브젝트 스토리지**: `s3://bucket/{tid}/...` 경로 분리, 버킷 정책으로 접근 제한
- **검색 인덱스(ES/Meilisearch)**: 인덱스 per tenant 또는 도큐먼트 필터 + API 키별 권한

### 18.10.7 멀티테넌시와 마이그레이션

- **Row-level**: 한 번 실행으로 끝(공유 스키마)  
- **Schema-per-tenant**: 테넌트 목록 iterate 하여 `search_path=schema` 로 Alembic 실행  
- **DB-per-tenant**: 각 DSN 연결하여 `upgrade head` 실행 (Job 병렬화)

간단 자동화 스크립트:

```bash
#!/usr/bin/env bash
set -euo pipefail
TENANTS=$(python - <<'PY'
from app.tenants import list_tenants
print("\n".join(list_tenants()))
PY
)
for t in $TENANTS; do
  echo "Migrating $t..."
  ALEMBIC_CONFIG=alembic.ini \
  TENANT=$t \
  alembic -x tenant=$t upgrade head
done
```

`env.py` 에서 `-x tenant=` 읽어 translate_map 구성.

---

## 18.11 의존성 주입(DI) & 컴포지션 루트

- Flask 앱 생성 시(팩토리), 모든 **어댑터 구현체**를 만들고 **서비스 생성자**에 주입한다.
- 요청 스코프 의존성(세션/UoW)은 **팩토리**를 주입하고, 라우트에서 **생성/폐기**.

```python
# app/boot.py
def build_container(app):
    base_engine = create_engine(app.config["DATABASE_URL"])
    SessionFactory = session_for_tenant(base_engine)  # row/schema/db-per-tenant 전략별
    uow_factory = lambda: SqlAlchemyUnitOfWork(SessionFactory)
    payments = StripePaymentGateway(app.config["STRIPE_KEY"])
    clock = SystemClock()
    app.order_service = OrderService(uow=uow_factory(), payments=payments, clock=clock)
```

---

## 18.12 트랜잭션/동시성/잠금

- **Use Case = 트랜잭션**: 서비스 메서드 하나가 단일 트랜잭션 경계가 되게 설계.
- **낙관적 잠금**: `version` 컬럼으로 동시 수정 감지.
- **비관적 잠금**: `SELECT ... FOR UPDATE` 필요한 경우 Repo 레벨에서 제공.
- **장기 작업**: 큐로 넘기고, 상태머신(도메인)과 이벤트로 비동기 조정.

낙관적 잠금 예:

```python
# SQLAlchemy: version_id_col / version_id_generator
from sqlalchemy.orm import mapper
mapper(Order, orders, version_id_col=orders.c.version)
```

---

## 18.13 테스트 전략(아키텍처 기준)

- **도메인 테스트**: 순수 파이썬, IO 없음 → 빠르게.
- **애플리케이션 테스트**: FakeRepo/FakeUoW 로 서비스 로직 검증.
- **인프라 테스트**: Repo/UoW 를 실제 DB 컨테이너로 검증(testcontainers).
- **계약/통합**: 외부 어댑터(결제/메일/웹훅) 더블 + 일부 샌드박스.

Fake UoW:

```python
class FakeOrderRepo:
    def __init__(self): self.store = {}
    def get(self, id): return self.store.get(id)
    def add(self, o): self.store[o.id] = o
    def save(self, o): self.store[o.id] = o

class FakeUoW:
    def __enter__(self): self.orders = FakeOrderRepo(); return self
    def __exit__(self, *a): ...
    def commit(self): ...
    def rollback(self): ...
```

---

## 18.14 점진적 리팩터링 로드맵

1) **DTO 도입**: 기존 라우트에 입력/출력 스키마 추가  
2) **서비스 분리**: 라우트 로직을 Use Case 로 이동  
3) **Repo/UoW 인터페이스화**: 인프라 경계 도입  
4) **도메인 모델 순수화**: SQLAlchemy 의존 제거(컴포지트/매핑 레이어로 이전)  
5) **이벤트/아웃박스**: 사이드이펙트 분리, 확장 준비  
6) **멀티테넌시 옵션**: Row → Schema → DB per tenant 순으로 필요에 따라 확장

---

## 18.15 체크리스트

- [ ] 도메인 모델이 Flask/SQLAlchemy/HTTP 를 모르는가?
- [ ] DTO/스키마로 외부 입력을 검증하고, 응답 계약을 고정했는가?
- [ ] Use Case 에 **트랜잭션 경계** 가 명확한가?
- [ ] Repo/UoW 포트가 있고, 인프라 구현을 교체 가능하게 했는가?
- [ ] 외부 서비스는 **포트/어댑터** 패턴으로 분리했는가?
- [ ] N+1 방지(DataLoader/조회전용 쿼리)는 Query 경로에서 처리하는가?
- [ ] 멀티테넌시 전략(키/스키마/DB)과 마이그레이션 자동화가 준비됐는가?
- [ ] 캐시/스토리지/검색 키에 **tenant prefix** 를 붙였는가?
- [ ] 테스트 피라미드(도메인/응용/인프라)가 구축됐는가?

---

## 18.16 부록: 간단 샘플 묶음

### 18.16.1 요청 → 서비스 → 도메인 → Repo/UoW 시퀀스

```text
HTTP POST /api/orders
  -> parse CreateOrderIn
  -> dto_to_order (domain)
  -> OrderService.create_order(uow)
     -> uow.orders.add(order)
     -> uow.commit()
  <- 201 OrderOut
```

### 18.16.2 테넌트별 세션 팩토리 패턴(요약)

```python
def get_session():
    if MODE == "row":
        return tenant_session(Session)()
    elif MODE == "schema":
        return session_for_tenant(base_engine)()
    elif MODE == "db":
        return session_factory_resolver()()
```

---

## 18.17 마무리

이 장에서는 Flask를 **헥사고날/클린 아키텍처** 방향으로 정리하며, **서비스/도메인 레이어**, **DTO/스키마 분리**, **UoW/Repo/포트-어댑터** 패턴을 실전 코드로 보여주었다. 또한 **멀티테넌시(행/스키마/DB 분리)** 의 장단점과 SQLAlchemy 기반 구현(스키마 번역, 세션 라우팅, 전역 스코프)을 다뤘다.

이 구조를 따르면:
- 프레임워크/인프라 변경의 충격이 **경계**에서 흡수되고,
- 도메인 테스트가 **가볍고 빠르며**, 
- 멀티테넌시/샤딩/이벤트 드리븐 등 확장 요구에 **유연하게 대응**할 수 있다.
