---
layout: post
title: flask - 구조/아키텍처 패턴
date: 2025-09-21 20:25:23 +0900
category: flask
---
# 구조/아키텍처 패턴

## 아키텍처 레이어링의 필요성

소프트웨어 아키텍처를 레이어로 분리하는 것은 단순히 코드를 정리하는 것이 아니라, 시스템의 유지보수성, 테스트 용이성, 확장성을 보장하는 핵심적인 설계 원칙입니다.

**레이어링의 핵심 가치**:

- **변경의 격리**: 웹 프레임워크, 비즈니스 로직, 데이터베이스와 같은 구성 요소들은 각기 다른 속도로 변화합니다. 아키텍처 레이어를 분리하면 한 부분의 변경이 다른 부분에 미치는 영향을 최소화할 수 있습니다.
- **테스트 용이성**: 핵심 비즈니스 로직을 웹 프레임워크나 데이터베이스 의존성 없이 독립적으로 테스트할 수 있습니다.
- **기술 스택의 유연성**: SQLAlchemy에서 다른 ORM으로, REST API에서 GraphQL로의 전환과 같은 기술적 결정을 애플리케이션의 핵심 로직에 영향을 주지 않고 수행할 수 있습니다.
- **복잡성 관리**: 멀티테넌시, 샤딩, 비동기 이벤트 처리와 같은 복잡한 요구사항을 특정 레이어에서 집중적으로 처리할 수 있습니다.

이 장의 목표는 Flask 애플리케이션에서 **비즈니스 도메인을 순수한 Python 객체로 유지**하고, Flask, SQLAlchemy, 인증, 캐싱과 같은 인프라 요소들을 **어댑터**로서 연결하는 방법을 살펴보는 것입니다.

---

## 표준 3-레이어 아키텍처

전형적인 3-레이어 아키텍처는 프레젠테이션, 애플리케이션, 도메인, 인프라 레이어로 구성됩니다.

```
app/
├─ presentation/           # HTTP 인터페이스, 요청/응답 변환
│  └─ http/
│     ├─ order_routes.py   # Flask 라우트 정의
│     └─ schemas.py        # Pydantic/Marshmallow 스키마
├─ application/            # 유스케이스, 트랜잭션 관리
│  ├─ order_service.py     # 비즈니스 프로세스 조정
│  └─ uow.py               # 작업 단위(Unit of Work) 인터페이스
├─ domain/                 # 핵심 비즈니스 규칙
│  ├─ models.py            # 엔티티, 값 객체
│  ├─ services.py          # 도메인 서비스
│  └─ events.py            # 도메인 이벤트
└─ infrastructure/         # 외부 시스템과의 통합
   ├─ repositories.py      # 데이터 접근 구현
   ├─ sqlalchemy_uow.py    # SQLAlchemy 작업 단위 구현
   ├─ mappers.py           # 도메인-데이터베이스 매핑
   └─ cache.py             # 캐시 구현
```

**각 레이어의 책임과 규칙**:

- **프레젠테이션 레이어**: HTTP 요청/응답 처리, 입력 검증, 인증/인가 등 웹 관련 관심사만 처리합니다.
- **애플리케이션 레이어**: 비즈니스 유스케이스를 조정하고, 트랜잭션 경계를 관리하며, 도메인 객체에 작업을 위임합니다.
- **도메인 레이어**: 순수한 비즈니스 로직을 포함하며, 외부 시스템(데이터베이스, 웹 프레임워크)에 대한 의존성이 없습니다.
- **인프라 레이어**: 데이터베이스, 캐시, 외부 API 등 실제 구현을 제공합니다.

**핵심 원칙**:
1. 의존성 방향은 **프레젠테이션 → 애플리케이션 → 도메인** 순으로만 흐릅니다.
2. 도메인 레이어는 Flask나 SQLAlchemy를 전혀 알지 못합니다.
3. 애플리케이션 레이어는 트랜잭션 관리와 도메인 객체 간의 조정을 담당합니다.
4. 인프라 레이어는 추상 인터페이스의 구체적인 구현을 제공합니다.

---

## 도메인 레이어: 엔티티, 값 객체, 도메인 서비스

도메인 레이어는 애플리케이션의 핵심 비즈니스 규칙을 표현합니다. 이 레이어는 외부 시스템에 대한 의존성을 가지지 않는 순수한 Python 코드로 구성됩니다.

### 엔티티와 값 객체

엔티티는 고유한 식별자를 가지며 시간에 따라 상태가 변화할 수 있는 객체입니다. 값 객체는 식별자가 없고 속성 값으로 동등성이 판단되는 불변 객체입니다.

```python
# app/domain/models.py

from dataclasses import dataclass, field
from decimal import Decimal
from typing import Optional
import uuid

class DomainError(Exception):
    """도메인 규칙 위반 시 발생하는 예외"""
    pass

@dataclass(frozen=True, eq=True)
class Money:
    """값 객체: 금액과 통화"""
    amount: Decimal
    currency: str = "KRW"
    
    def __post_init__(self):
        """금액은 0 이상이어야 합니다."""
        if self.amount < Decimal("0"):
            raise DomainError("금액은 0 이상이어야 합니다.")
    
    def __add__(self, other: "Money") -> "Money":
        """동일 통화의 금액을 더합니다."""
        if self.currency != other.currency:
            raise DomainError("서로 다른 통화는 더할 수 없습니다.")
        return Money(self.amount + other.amount, self.currency)
    
    def __mul__(self, multiplier: int) -> "Money":
        """금액에 정수를 곱합니다."""
        return Money(self.amount * multiplier, self.currency)

@dataclass
class OrderLine:
    """주문 항목"""
    sku: str              # 상품 식별자
    quantity: int         # 수량
    unit_price: Money     # 단가
    
    def __post_init__(self):
        """수량은 0보다 커야 합니다."""
        if self.quantity <= 0:
            raise DomainError("수량은 0보다 커야 합니다.")
    
    def total_price(self) -> Money:
        """항목의 총 가격 계산"""
        return self.unit_price * self.quantity

@dataclass
class Order:
    """주문 엔티티"""
    id: str               # 고유 식별자
    customer_id: str      # 고객 식별자
    lines: list[OrderLine] = field(default_factory=list)
    status: str = "draft"  # draft/confirmed/paid/cancelled
    
    def add_item(self, sku: str, quantity: int, unit_price: Money) -> None:
        """주문에 항목 추가"""
        if self.status != "draft":
            raise DomainError("확인된 주문에는 항목을 추가할 수 없습니다.")
        
        self.lines.append(OrderLine(sku, quantity, unit_price))
    
    def remove_item(self, sku: str) -> None:
        """주문에서 항목 제거"""
        if self.status != "draft":
            raise DomainError("확인된 주문에서 항목을 제거할 수 없습니다.")
        
        self.lines = [line for line in self.lines if line.sku != sku]
    
    def total_amount(self) -> Money:
        """주문 총액 계산"""
        if not self.lines:
            return Money(Decimal("0"))
        
        total = Money(Decimal("0"), self.lines[0].unit_price.currency)
        for line in self.lines:
            total = total + line.total_price()
        return total
    
    def confirm(self) -> None:
        """주문 확인"""
        if self.status != "draft":
            raise DomainError("이미 확인된 주문입니다.")
        
        if not self.lines:
            raise DomainError("빈 주문은 확인할 수 없습니다.")
        
        self.status = "confirmed"
    
    def cancel(self) -> None:
        """주문 취소"""
        if self.status not in ["draft", "confirmed"]:
            raise DomainError("이 상태에서는 주문을 취소할 수 없습니다.")
        
        self.status = "cancelled"
```

### 도메인 서비스

도메인 서비스는 특정 엔티티에 속하기 어려운 도메인 로직을 캡슐화합니다. 도메인 서비스는 순수한 비즈니스 로직만 포함하며, 외부 시스템과의 상호작용은 포함하지 않습니다.

```python
# app/domain/services.py

from decimal import Decimal
from .models import Order, Money, DomainError

class PricingService:
    """가격 정책 적용 서비스"""
    
    @staticmethod
    def apply_discount(order: Order, discount_percentage: Decimal) -> None:
        """주문에 할인 적용"""
        if order.status != "draft":
            raise DomainError("확인된 주문에는 할인을 적용할 수 없습니다.")
        
        if discount_percentage < Decimal("0") or discount_percentage > Decimal("100"):
            raise DomainError("할인율은 0에서 100 사이여야 합니다.")
        
        discount_factor = (Decimal("100") - discount_percentage) / Decimal("100")
        
        for line in order.lines:
            discounted_amount = line.unit_price.amount * discount_factor
            line.unit_price = Money(discounted_amount, line.unit_price.currency)
    
    @staticmethod
    def apply_bulk_discount(order: Order) -> None:
        """대량 구매 할인 적용"""
        if order.status != "draft":
            raise DomainError("확인된 주문에는 할인을 적용할 수 없습니다.")
        
        total_quantity = sum(line.quantity for line in order.lines)
        
        if total_quantity >= 100:
            # 100개 이상 구매 시 10% 할인
            PricingService.apply_discount(order, Decimal("10"))
        elif total_quantity >= 50:
            # 50개 이상 구매 시 5% 할인
            PricingService.apply_discount(order, Decimal("5"))

class InventoryService:
    """재고 관련 도메인 서비스"""
    
    @staticmethod
    def check_availability(order: Order, inventory: dict[str, int]) -> bool:
        """주문 항목의 재고 가용성 확인"""
        for line in order.lines:
            available = inventory.get(line.sku, 0)
            if available < line.quantity:
                return False
        return True
```

---

## DTO와 스키마: 도메인 객체의 프레젠테이션 분리

도메인 객체를 HTTP 요청이나 응답에 직접 노출하지 않고, 전용 데이터 전송 객체(DTO)를 사용하는 것이 중요합니다. 이는 API 계약과 도메인 모델의 변화를 독립적으로 관리할 수 있게 해줍니다.

### Pydantic을 활용한 스키마 정의

```python
# app/presentation/http/schemas.py

from pydantic import BaseModel, Field, validator
from decimal import Decimal
from typing import List
import uuid

class OrderItemCreate(BaseModel):
    """주문 항목 생성 요청"""
    sku: str = Field(..., min_length=1, max_length=50, description="상품 식별자")
    quantity: int = Field(..., gt=0, description="수량")
    unit_price: Decimal = Field(..., gt=0, description="단가")
    
    @validator('unit_price')
    def validate_unit_price(cls, v):
        """단가 검증"""
        if v.as_tuple().exponent < -2:  # 소수점 이하 2자리 초과
            raise ValueError("단가는 소수점 이하 2자리까지 허용됩니다.")
        return v

class OrderCreate(BaseModel):
    """주문 생성 요청"""
    customer_id: str = Field(..., min_length=1, description="고객 식별자")
    items: List[OrderItemCreate] = Field(..., min_items=1, description="주문 항목 목록")

class OrderItemResponse(BaseModel):
    """주문 항목 응답"""
    sku: str
    quantity: int
    unit_price: Decimal
    total_price: Decimal
    
    class Config:
        orm_mode = True

class OrderResponse(BaseModel):
    """주문 응답"""
    id: str
    customer_id: str
    status: str
    items: List[OrderItemResponse]
    total_amount: Decimal
    created_at: str
    updated_at: str
    
    class Config:
        orm_mode = True
```

### DTO와 도메인 객체 간 변환

```python
# app/presentation/http/mappers.py

from app.domain.models import Order, OrderLine, Money
from .schemas import OrderCreate, OrderResponse
from decimal import Decimal
import datetime

class OrderMapper:
    """주문 객체 변환기"""
    
    @staticmethod
    def dto_to_domain(dto: OrderCreate) -> Order:
        """DTO를 도메인 객체로 변환"""
        order = Order(
            id=str(uuid.uuid4()),
            customer_id=dto.customer_id,
            status="draft"
        )
        
        for item in dto.items:
            order.add_item(
                sku=item.sku,
                quantity=item.quantity,
                unit_price=Money(item.unit_price, "KRW")
            )
        
        return order
    
    @staticmethod
    def domain_to_dto(order: Order, created_at: datetime, updated_at: datetime) -> OrderResponse:
        """도메인 객체를 DTO로 변환"""
        items = []
        for line in order.lines:
            items.append(OrderItemResponse(
                sku=line.sku,
                quantity=line.quantity,
                unit_price=line.unit_price.amount,
                total_price=line.total_price().amount
            ))
        
        return OrderResponse(
            id=order.id,
            customer_id=order.customer_id,
            status=order.status,
            items=items,
            total_amount=order.total_amount().amount,
            created_at=created_at.isoformat(),
            updated_at=updated_at.isoformat()
        )
```

**DTO 분리의 장점**:
1. **API 계약의 안정성**: 도메인 객체의 내부 구현이 변경되어도 API 응답 형식은 일관되게 유지됩니다.
2. **보안**: 민감한 도메인 속성을 API 응답에서 제외할 수 있습니다.
3. **유연성**: 클라이언트 요구에 맞는 특화된 응답 형식을 쉽게 제공할 수 있습니다.

---

## 애플리케이션 레이어: 유스케이스와 작업 단위

애플리케이션 레이어는 비즈니스 유스케이스를 조정하고, 트랜잭션 경계를 관리하며, 여러 도메인 객체를 조율하는 역할을 합니다.

### 포트(인터페이스) 정의

포트는 도메인이 기대하는 추상 인터페이스를 정의합니다.

```python
# app/application/ports.py

from typing import Protocol, Optional, List
from abc import ABC, abstractmethod
from app.domain.models import Order
from decimal import Decimal

class OrderRepository(Protocol):
    """주문 저장소 인터페이스"""
    
    def get(self, order_id: str) -> Optional[Order]:
        """ID로 주문 조회"""
        ...
    
    def add(self, order: Order) -> None:
        """주문 추가"""
        ...
    
    def save(self, order: Order) -> None:
        """주문 저장"""
        ...
    
    def list_by_customer(self, customer_id: str, limit: int = 100) -> List[Order]:
        """고객별 주문 목록 조회"""
        ...

class UnitOfWork(Protocol):
    """작업 단위 인터페이스"""
    
    orders: OrderRepository
    
    def __enter__(self) -> "UnitOfWork":
        """컨텍스트 진입"""
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """컨텍스트 종료"""
        ...
    
    def commit(self) -> None:
        """변경사항 커밋"""
        ...
    
    def rollback(self) -> None:
        """변경사항 롤백"""
        ...

class PaymentGateway(Protocol):
    """결제 게이트웨이 인터페이스"""
    
    def charge(self, order_id: str, amount: Decimal, currency: str, 
               customer_token: Optional[str] = None) -> str:
        """결제 처리"""
        ...
    
    def refund(self, payment_id: str, amount: Decimal) -> bool:
        """결제 환불"""
        ...

class NotificationService(Protocol):
    """알림 서비스 인터페이스"""
    
    def send_order_confirmation(self, order: Order) -> None:
        """주문 확인 알림 전송"""
        ...
```

### 서비스(유스케이스) 구현

서비스 클래스는 구체적인 비즈니스 유스케이스를 구현합니다.

```python
# app/application/services/order_service.py

from typing import Optional
from app.domain.models import Order, DomainError
from app.domain.services import PricingService
from .ports import UnitOfWork, PaymentGateway, NotificationService

class OrderService:
    """주문 관련 비즈니스 유스케이스"""
    
    def __init__(
        self, 
        uow: UnitOfWork,
        payment_gateway: Optional[PaymentGateway] = None,
        notification_service: Optional[NotificationService] = None
    ):
        self.uow = uow
        self.payment_gateway = payment_gateway
        self.notification_service = notification_service
    
    def create_order(self, order: Order) -> None:
        """주문 생성"""
        with self.uow as uow:
            # 비즈니스 규칙: 대량 구매 할인 자동 적용
            PricingService.apply_bulk_discount(order)
            
            uow.orders.add(order)
            uow.commit()
    
    def confirm_order(self, order_id: str) -> None:
        """주문 확인"""
        with self.uow as uow:
            order = uow.orders.get(order_id)
            if not order:
                raise DomainError(f"주문을 찾을 수 없습니다: {order_id}")
            
            order.confirm()
            uow.orders.save(order)
            uow.commit()
            
            # 알림 전송 (트랜잭션 외부에서)
            if self.notification_service:
                self.notification_service.send_order_confirmation(order)
    
    def process_payment(self, order_id: str, customer_token: Optional[str] = None) -> str:
        """주문 결제 처리"""
        if not self.payment_gateway:
            raise DomainError("결제 서비스가 구성되지 않았습니다.")
        
        with self.uow as uow:
            order = uow.orders.get(order_id)
            if not order:
                raise DomainError(f"주문을 찾을 수 없습니다: {order_id}")
            
            if order.status != "confirmed":
                raise DomainError("확인되지 않은 주문은 결제할 수 없습니다.")
            
            total = order.total_amount()
            payment_id = self.payment_gateway.charge(
                order_id=order.id,
                amount=total.amount,
                currency=total.currency,
                customer_token=customer_token
            )
            
            # 결제 성공 시 상태 업데이트
            order.status = "paid"
            uow.orders.save(order)
            uow.commit()
            
            return payment_id
    
    def cancel_order(self, order_id: str, reason: Optional[str] = None) -> None:
        """주문 취소"""
        with self.uow as uow:
            order = uow.orders.get(order_id)
            if not order:
                raise DomainError(f"주문을 찾을 수 없습니다: {order_id}")
            
            # 결제된 주문은 환불 처리 필요
            if order.status == "paid" and self.payment_gateway:
                # 실제 구현에서는 환불 내역을 추적해야 함
                pass
            
            order.cancel()
            uow.orders.save(order)
            uow.commit()
```

**애플리케이션 서비스의 책임**:
1. **트랜잭션 관리**: 각 유스케이스 메서드는 논리적 트랜잭션 경계를 정의합니다.
2. **도메인 객체 조율**: 여러 도메인 객체를 조율하여 비즈니스 프로세스를 완성합니다.
3. **외부 서비스 연동**: 결제, 알림, 이메일 등 외부 서비스와의 상호작용을 관리합니다.
4. **권한 검증**: 사용자가 해당 작업을 수행할 권한이 있는지 확인합니다.

---

## 인프라 레이어: 포트의 실제 구현

인프라 레이어는 포트(인터페이스)에 대한 실제 구현을 제공합니다.

### SQLAlchemy를 활용한 리포지토리 구현

```python
# app/infrastructure/repositories/sqlalchemy_order_repository.py

from typing import Optional, List
from sqlalchemy.orm import Session
from app.domain.models import Order
from app.application.ports import OrderRepository

class SqlAlchemyOrderRepository(OrderRepository):
    """SQLAlchemy 기반 주문 저장소 구현"""
    
    def __init__(self, session: Session):
        self.session = session
    
    def get(self, order_id: str) -> Optional[Order]:
        """ID로 주문 조회"""
        return self.session.get(Order, order_id)
    
    def add(self, order: Order) -> None:
        """주문 추가"""
        self.session.add(order)
    
    def save(self, order: Order) -> None:
        """주문 저장 (SQLAlchemy는 변경을 자동 추적)"""
        # SQLAlchemy의 identity map이 변경을 추적하므로
        # 명시적인 save 호출이 필요하지 않을 수 있습니다.
        # 하지만 인터페이스 호환성을 위해 구현합니다.
        if order not in self.session:
            self.session.add(order)
    
    def list_by_customer(self, customer_id: str, limit: int = 100) -> List[Order]:
        """고객별 주문 목록 조회"""
        from app.infrastructure.orm import Order as OrderOrm
        
        query = self.session.query(OrderOrm).filter(
            OrderOrm.customer_id == customer_id
        ).order_by(OrderOrm.created_at.desc()).limit(limit)
        
        # 여기서는 도메인 객체를 직접 반환하지만,
        # 실제로는 ORM 객체를 도메인 객체로 변환해야 할 수 있습니다.
        return query.all()
```

### 작업 단위 구현

```python
# app/infrastructure/uow/sqlalchemy_unit_of_work.py

from sqlalchemy.orm import sessionmaker
from app.application.ports import UnitOfWork
from app.infrastructure.repositories.sqlalchemy_order_repository import SqlAlchemyOrderRepository

class SqlAlchemyUnitOfWork(UnitOfWork):
    """SQLAlchemy 기반 작업 단위 구현"""
    
    def __init__(self, session_factory):
        self.session_factory = session_factory
        self.session = None
    
    def __enter__(self) -> "SqlAlchemyUnitOfWork":
        """컨텍스트 진입 - 세션 시작"""
        self.session = self.session_factory()
        self.orders = SqlAlchemyOrderRepository(self.session)
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """컨텍스트 종료 - 세션 정리"""
        self.rollback()
        self.session.close()
    
    def commit(self) -> None:
        """변경사항 커밋"""
        self.session.commit()
    
    def rollback(self) -> None:
        """변경사항 롤백"""
        self.session.rollback()
```

### 도메인 모델과 데이터베이스 매핑

```python
# app/infrastructure/orm/mapping.py

from sqlalchemy import Column, String, Integer, Numeric, DateTime, ForeignKey, Enum
from sqlalchemy.orm import relationship, composite
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime
import enum

Base = declarative_base()

class OrderStatus(enum.Enum):
    """주문 상태 Enum"""
    DRAFT = "draft"
    CONFIRMED = "confirmed"
    PAID = "paid"
    CANCELLED = "cancelled"

class MoneyComposite:
    """Money 값 객체를 데이터베이스 컬럼에 매핑"""
    
    def __init__(self, amount, currency):
        self.amount = amount
        self.currency = currency
    
    def __composite_values__(self):
        return self.amount, self.currency
    
    def __repr__(self):
        return f"Money(amount={self.amount}, currency={self.currency})"
    
    def __eq__(self, other):
        return isinstance(other, MoneyComposite) and \
               self.amount == other.amount and \
               self.currency == other.currency
    
    def __ne__(self, other):
        return not self.__eq__(other)

class OrderOrm(Base):
    """주문 ORM 모델"""
    __tablename__ = 'orders'
    
    id = Column(String(36), primary_key=True)
    customer_id = Column(String(100), nullable=False, index=True)
    status = Column(Enum(OrderStatus), nullable=False, default=OrderStatus.DRAFT)
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, 
                        onupdate=datetime.utcnow)
    
    # 관계 정의
    items = relationship("OrderItemOrm", back_populates="order", 
                        cascade="all, delete-orphan")
    
    def to_domain(self):
        """ORM 객체를 도메인 객체로 변환"""
        from app.domain.models import Order, OrderLine, Money
        
        order = Order(
            id=self.id,
            customer_id=self.customer_id,
            status=self.status.value
        )
        
        for item in self.items:
            order.add_item(
                sku=item.sku,
                quantity=item.quantity,
                unit_price=Money(item.unit_price_amount, item.unit_price_currency)
            )
        
        return order
    
    @classmethod
    def from_domain(cls, order):
        """도메인 객체를 ORM 객체로 변환"""
        orm_order = cls(
            id=order.id,
            customer_id=order.customer_id,
            status=OrderStatus(order.status)
        )
        
        for line in order.lines:
            orm_item = OrderItemOrm(
                sku=line.sku,
                quantity=line.quantity,
                unit_price_amount=line.unit_price.amount,
                unit_price_currency=line.unit_price.currency
            )
            orm_order.items.append(orm_item)
        
        return orm_order

class OrderItemOrm(Base):
    """주문 항목 ORM 모델"""
    __tablename__ = 'order_items'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    order_id = Column(String(36), ForeignKey('orders.id'), nullable=False)
    sku = Column(String(50), nullable=False)
    quantity = Column(Integer, nullable=False)
    
    # Money 값 객체 매핑
    unit_price_amount = Column(Numeric(12, 2), nullable=False)
    unit_price_currency = Column(String(3), nullable=False, default="KRW")
    unit_price = composite(MoneyComposite, unit_price_amount, unit_price_currency)
    
    # 관계 정의
    order = relationship("OrderOrm", back_populates="items")
```

---

## 헥사고날 아키텍처로의 확장

헥사고날 아키텍처(포트와 어댑터 패턴)는 도메인을 중심으로 하고, 외부 시스템과의 통신은 어댑터를 통해 이루어지는 아키텍처입니다.

### 포트와 어댑터 패턴 이해

- **포트(Port)**: 도메인이 외부 세계와 상호작용하기 위해 정의한 인터페이스입니다. (예: `OrderRepository`, `PaymentGateway`)
- **어댑터(Adapter)**: 포트를 실제로 구현한 클래스입니다. (예: `SqlAlchemyOrderRepository`, `StripePaymentGateway`)
- **도메인(Domain)**: 핵심 비즈니스 로직을 포함하는 영역입니다.
- **애플리케이션(Application)**: 도메인을 사용하여 유스케이스를 구현하는 영역입니다.

### 외부 서비스 어댑터 구현 예시

```python
# app/infrastructure/adapters/stripe_payment_gateway.py

import stripe
from decimal import Decimal
from typing import Optional
from app.application.ports import PaymentGateway

class StripePaymentGateway(PaymentGateway):
    """Stripe 결제 게이트웨이 어댑터"""
    
    def __init__(self, api_key: str):
        stripe.api_key = api_key
    
    def charge(self, order_id: str, amount: Decimal, currency: str, 
               customer_token: Optional[str] = None) -> str:
        """Stripe를 통한 결제 처리"""
        
        # Decimal을 센트 단위 정수로 변환
        amount_in_cents = int(amount * 100)
        
        try:
            payment_intent_data = {
                "amount": amount_in_cents,
                "currency": currency.lower(),
                "metadata": {"order_id": order_id}
            }
            
            if customer_token:
                payment_intent_data["customer"] = customer_token
            
            payment_intent = stripe.PaymentIntent.create(**payment_intent_data)
            return payment_intent.id
            
        except stripe.error.StripeError as e:
            # 도메인 예외로 변환
            from app.domain.models import DomainError
            raise DomainError(f"결제 처리 중 오류 발생: {str(e)}")
    
    def refund(self, payment_id: str, amount: Decimal) -> bool:
        """결제 환불 처리"""
        try:
            refund_amount = int(amount * 100)
            refund = stripe.Refund.create(
                payment_intent=payment_id,
                amount=refund_amount
            )
            return refund.status == "succeeded"
            
        except stripe.error.StripeError:
            return False

# app/infrastructure/adapters/ses_notification_service.py

import boto3
from botocore.exceptions import ClientError
from app.application.ports import NotificationService
from app.domain.models import Order

class SESNotificationService(NotificationService):
    """AWS SES를 활용한 알림 서비스 어댑터"""
    
    def __init__(self, aws_region: str, sender_email: str):
        self.client = boto3.client('ses', region_name=aws_region)
        self.sender_email = sender_email
    
    def send_order_confirmation(self, order: Order) -> None:
        """주문 확인 이메일 전송"""
        # 실제 구현에서는 고객 이메일 주소를 조회해야 함
        recipient = "customer@example.com"  # 예시
        
        subject = f"주문 확인: #{order.id}"
        body_text = f"""
        안녕하세요,
        
        주문 #{order.id}이(가) 확인되었습니다.
        
        총액: {order.total_amount().amount} {order.total_amount().currency}
        상태: {order.status}
        
        감사합니다.
        """
        
        body_html = f"""
        <html>
        <head></head>
        <body>
          <h1>주문 확인</h1>
          <p>주문 #{order.id}이(가) 확인되었습니다.</p>
          <p><strong>총액:</strong> {order.total_amount().amount} {order.total_amount().currency}</p>
          <p><strong>상태:</strong> {order.status}</p>
        </body>
        </html>
        """
        
        try:
            response = self.client.send_email(
                Source=self.sender_email,
                Destination={
                    'ToAddresses': [recipient]
                },
                Message={
                    'Subject': {
                        'Data': subject,
                        'Charset': 'UTF-8'
                    },
                    'Body': {
                        'Text': {
                            'Data': body_text,
                            'Charset': 'UTF-8'
                        },
                        'Html': {
                            'Data': body_html,
                            'Charset': 'UTF-8'
                        }
                    }
                }
            )
            print(f"이메일 전송 성공: {response['MessageId']}")
            
        except ClientError as e:
            print(f"이메일 전송 실패: {e.response['Error']['Message']}")
            # 프로덕션에서는 적절한 로깅과 오류 처리 필요
```

### 의존성 주입 구성

```python
# app/composition_root.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.infrastructure.uow.sqlalchemy_unit_of_work import SqlAlchemyUnitOfWork
from app.infrastructure.adapters.stripe_payment_gateway import StripePaymentGateway
from app.infrastructure.adapters.ses_notification_service import SESNotificationService
from app.application.services.order_service import OrderService
import os

def create_order_service() -> OrderService:
    """OrderService 인스턴스 생성 (의존성 주입)"""
    
    # 데이터베이스 연결 설정
    database_url = os.getenv("DATABASE_URL", "sqlite:///app.db")
    engine = create_engine(database_url, echo=False)
    SessionFactory = sessionmaker(bind=engine, expire_on_commit=False)
    
    # 작업 단위 생성
    uow = SqlAlchemyUnitOfWork(SessionFactory)
    
    # 외부 서비스 어댑터 생성 (환경변수에서 구성)
    stripe_api_key = os.getenv("STRIPE_API_KEY")
    payment_gateway = StripePaymentGateway(stripe_api_key) if stripe_api_key else None
    
    aws_region = os.getenv("AWS_REGION")
    sender_email = os.getenv("SES_SENDER_EMAIL")
    notification_service = None
    
    if aws_region and sender_email:
        notification_service = SESNotificationService(aws_region, sender_email)
    
    # 서비스 인스턴스 생성 및 의존성 주입
    return OrderService(
        uow=uow,
        payment_gateway=payment_gateway,
        notification_service=notification_service
    )
```

---

## 프레젠테이션 레이어: HTTP 컨트롤러

프레젠테이션 레이어는 외부와의 통신(HTTP, CLI, 메시지 큐 등)을 처리합니다.

```python
# app/presentation/http/controllers/order_controller.py

from flask import Blueprint, request, jsonify, current_app
from app.presentation.http.schemas import OrderCreate, OrderResponse
from app.presentation.http.mappers import OrderMapper
from app.domain.models import DomainError

order_bp = Blueprint("orders", __name__, url_prefix="/api/orders")

@order_bp.route("", methods=["POST"])
def create_order():
    """주문 생성 엔드포인트"""
    try:
        # 입력 검증
        request_data = request.get_json()
        if not request_data:
            return jsonify({"error": "요청 본문이 필요합니다"}), 400
        
        # DTO 변환 및 검증
        order_create = OrderCreate(**request_data)
        
        # 도메인 객체 생성
        order = OrderMapper.dto_to_domain(order_create)
        
        # 비즈니스 로직 실행
        order_service = current_app.order_service
        order_service.create_order(order)
        
        # 응답 생성 (실제 구현에서는 저장된 주문을 다시 조회)
        response_data = OrderMapper.domain_to_dto(
            order, 
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        
        return jsonify(response_data.dict()), 201
        
    except ValueError as e:
        # Pydantic 검증 오류
        return jsonify({"error": str(e)}), 400
    except DomainError as e:
        # 도메인 규칙 위반
        return jsonify({"error": str(e)}), 400
    except Exception as e:
        # 기타 예외
        current_app.logger.error(f"주문 생성 중 오류: {str(e)}")
        return jsonify({"error": "내부 서버 오류"}), 500

@order_bp.route("/<order_id>/confirm", methods=["POST"])
def confirm_order(order_id: str):
    """주문 확인 엔드포인트"""
    try:
        order_service = current_app.order_service
        order_service.confirm_order(order_id)
        
        return "", 204  # No Content
        
    except DomainError as e:
        return jsonify({"error": str(e)}), 400
    except Exception as e:
        current_app.logger.error(f"주문 확인 중 오류: {str(e)}")
        return jsonify({"error": "내부 서버 오류"}), 500

@order_bp.route("/<order_id>", methods=["GET"])
def get_order(order_id: str):
    """주문 조회 엔드포인트"""
    try:
        order_service = current_app.order_service
        
        # 실제 구현에서는 리포지토리를 통해 주문 조회
        # 여기서는 간단한 예시를 위해 서비스에 조회 메서드가 있다고 가정
        # with order_service.uow as uow:
        #     order = uow.orders.get(order_id)
        
        # 임시 응답
        return jsonify({
            "id": order_id,
            "message": "주문 조회 기능은 별도로 구현해야 합니다"
        }), 200
        
    except Exception as e:
        current_app.logger.error(f"주문 조회 중 오류: {str(e)}")
        return jsonify({"error": "내부 서버 오류"}), 500
```

---

## 멀티테넌시 아키텍처 패턴

멀티테넌시는 단일 애플리케이션 인스턴스가 여러 고객(테넌트)에게 서비스를 제공하는 아키텍처 패턴입니다.

### 멀티테넌시 모델 비교

1. **데이터베이스 공유, 스키마 공유 (Row-level)**
   - 모든 테넌트의 데이터가 동일한 테이블에 `tenant_id` 컬럼으로 구분되어 저장됩니다.
   - **장점**: 구현이 간단하고 운영 비용이 낮습니다.
   - **단점**: 데이터 격리가 약하고, 잘못된 쿼리로 데이터 누출 위험이 있습니다.

2. **데이터베이스 공유, 스키마 분리 (Schema-per-tenant)**
   - 각 테넌트마다 별도의 데이터베이스 스키마를 사용합니다.
   - **장점**: 적절한 데이터 격리와 관리 용이성을 제공합니다.
   - **단점**: 스키마 수가 많아질수록 관리가 복잡해집니다.

3. **데이터베이스 분리 (Database-per-tenant)**
   - 각 테넌트마다 완전히 분리된 데이터베이스를 사용합니다.
   - **장점**: 최고 수준의 데이터 격리와 보안을 제공합니다.
   - **단점**: 운영 복잡도와 비용이 높아집니다.

**권장 접근법**: 초기에는 Row-level 방식으로 시작하고, 규모와 보안 요구사항이 증가함에 따라 Schema-per-tenant나 Database-per-tenant 방식으로 점진적으로 전환합니다.

### Row-level 멀티테넌시 구현

```python
# app/infrastructure/multitenancy/row_level.py

from flask import g, request
from sqlalchemy import Column, String
from sqlalchemy.orm import Query, with_loader_criteria
from sqlalchemy.event import listens_for

def get_current_tenant_id() -> str:
    """현재 요청의 테넌트 ID 추출"""
    # 헤더에서 추출
    tenant_id = request.headers.get("X-Tenant-ID")
    
    # 또는 서브도메인에서 추출
    if not tenant_id and "." in request.host:
        tenant_id = request.host.split(".")[0]
    
    # 또는 JWT 토큰에서 추출
    if not tenant_id and hasattr(g, "jwt_claims"):
        tenant_id = g.jwt_claims.get("tenant_id")
    
    # 기본값 (개발용)
    if not tenant_id:
        tenant_id = "default"
    
    return tenant_id

# 테넌트 컨텍스트 설정 미들웨어
def setup_tenant_context(app):
    """테넌트 컨텍스트 설정"""
    
    @app.before_request
    def set_tenant_context():
        """요청 전 테넌트 컨텍스트 설정"""
        g.tenant_id = get_current_tenant_id()
    
    # SQLAlchemy 쿼리 필터링
    @listens_for(Query, "before_compile", retval=True)
    def before_compile(query):
        """모든 쿼리에 테넌트 필터 자동 적용"""
        for desc in query.column_descriptions:
            model = desc["type"]
            if model is not None and hasattr(model, "tenant_id"):
                # 테넌트 ID 필터 적용
                tenant_id = getattr(g, "tenant_id", None)
                if tenant_id:
                    query = query.filter(model.tenant_id == tenant_id)
                break
        return query
    
    # INSERT 시 테넌트 ID 자동 설정
    @listens_for(OrderOrm, "before_insert")
    def set_tenant_id_on_insert(mapper, connection, target):
        """엔티티 저장 시 테넌트 ID 자동 설정"""
        if hasattr(target, "tenant_id"):
            target.tenant_id = getattr(g, "tenant_id", "default")

# 테넌트 인식 모델
class TenantAwareMixin:
    """테넌트 인식 모델 믹스인"""
    tenant_id = Column(String(50), nullable=False, index=True)

# 사용 예시
class OrderOrm(Base, TenantAwareMixin):
    __tablename__ = 'orders'
    # ... 기존 필드들 ...
    # tenant_id 필드는 TenantAwareMixin에서 상속됨
```

### Schema-per-tenant 멀티테넌시 구현

```python
# app/infrastructure/multitenancy/schema_per_tenant.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from contextvars import ContextVar
from functools import lru_cache

# 현재 테넌트를 저장하는 컨텍스트 변수
current_tenant = ContextVar("current_tenant", default="public")

@lru_cache(maxsize=128)
def get_engine_for_tenant(base_engine, tenant_schema: str):
    """테넌트별 엔진 생성 (캐싱 적용)"""
    # PostgreSQL의 경우 search_path 설정
    if base_engine.dialect.name == "postgresql":
        return base_engine.execution_options(
            search_path=[tenant_schema, "public"]
        )
    # 다른 데이터베이스의 경우 connection factory 사용
    else:
        return base_engine

class SchemaSessionFactory:
    """스키마별 세션 팩토리"""
    
    def __init__(self, base_engine):
        self.base_engine = base_engine
    
    def __call__(self):
        """현재 테넌트에 맞는 세션 생성"""
        tenant_schema = current_tenant.get()
        
        if tenant_schema == "public":
            # 기본 스키마 사용
            engine = self.base_engine
        else:
            # 테넌트별 스키마 사용
            engine = get_engine_for_tenant(self.base_engine, tenant_schema)
        
        return sessionmaker(bind=engine, expire_on_commit=False)()

# 미들웨어에서 테넌트 설정
def set_tenant_middleware(app):
    """테넌트 설정 미들웨어"""
    
    @app.before_request
    def set_current_tenant():
        """요청 전 테넌트 설정"""
        tenant_id = get_current_tenant_id()  # 이전에 정의한 함수
        current_tenant.set(tenant_id)
```

### 멀티테넌시와 캐싱

멀티테넌시 환경에서 캐싱은 테넌트 간 데이터 격리를 고려해야 합니다.

```python
# app/infrastructure/cache/tenant_aware_cache.py

from typing import Any, Optional
import redis
import pickle

class TenantAwareCache:
    """테넌트 인식 캐시"""
    
    def __init__(self, redis_client: redis.Redis, default_ttl: int = 3600):
        self.redis = redis_client
        self.default_ttl = default_ttl
    
    def _make_key(self, key: str, tenant_id: Optional[str] = None) -> str:
        """테넌트 ID를 포함한 캐시 키 생성"""
        if tenant_id is None:
            # 현재 컨텍스트에서 테넌트 ID 가져오기
            from flask import g
            tenant_id = getattr(g, "tenant_id", "default")
        
        return f"tenant:{tenant_id}:{key}"
    
    def get(self, key: str, tenant_id: Optional[str] = None) -> Optional[Any]:
        """캐시에서 값 조회"""
        cache_key = self._make_key(key, tenant_id)
        data = self.redis.get(cache_key)
        
        if data is None:
            return None
        
        return pickle.loads(data)
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None, 
            tenant_id: Optional[str] = None) -> None:
        """캐시에 값 저장"""
        cache_key = self._make_key(key, tenant_id)
        data = pickle.dumps(value)
        
        expire_time = ttl if ttl is not None else self.default_ttl
        self.redis.setex(cache_key, expire_time, data)
    
    def delete(self, key: str, tenant_id: Optional[str] = None) -> None:
        """캐시에서 값 삭제"""
        cache_key = self._make_key(key, tenant_id)
        self.redis.delete(cache_key)
    
    def clear_tenant(self, tenant_id: str) -> None:
        """특정 테넌트의 모든 캐시 삭제"""
        pattern = f"tenant:{tenant_id}:*"
        
        # Redis 6.2 이상에서는 SCAN과 UNLINK 사용
        cursor = 0
        while True:
            cursor, keys = self.redis.scan(cursor, pattern, 100)
            if keys:
                self.redis.unlink(*keys)
            if cursor == 0:
                break
```

---

## 테스트 전략

계층화된 아키텍처는 각 레이어별로 독립적인 테스트를 가능하게 합니다.

### 도메인 레이어 테스트

도메인 레이어는 외부 의존성이 없으므로 빠르고 간단하게 테스트할 수 있습니다.

```python
# tests/domain/test_order.py

import pytest
from decimal import Decimal
from app.domain.models import Order, OrderLine, Money, DomainError

def test_order_creation():
    """주문 생성 테스트"""
    order = Order(id="order-1", customer_id="customer-1")
    
    assert order.id == "order-1"
    assert order.customer_id == "customer-1"
    assert order.status == "draft"
    assert len(order.lines) == 0

def test_add_item_to_order():
    """주문에 항목 추가 테스트"""
    order = Order(id="order-1", customer_id="customer-1")
    unit_price = Money(Decimal("1000"), "KRW")
    
    order.add_item("sku-001", 2, unit_price)
    
    assert len(order.lines) == 1
    assert order.lines[0].sku == "sku-001"
    assert order.lines[0].quantity == 2
    assert order.lines[0].unit_price == unit_price

def test_cannot_add_item_to_confirmed_order():
    """확인된 주문에는 항목 추가 불가 테스트"""
    order = Order(id="order-1", customer_id="customer-1")
    order.confirm()
    
    unit_price = Money(Decimal("1000"), "KRW")
    
    with pytest.raises(DomainError, match="확인된 주문에는 항목을 추가할 수 없습니다"):
        order.add_item("sku-001", 1, unit_price)

def test_order_total_amount():
    """주문 총액 계산 테스트"""
    order = Order(id="order-1", customer_id="customer-1")
    
    order.add_item("sku-001", 2, Money(Decimal("1000"), "KRW"))
    order.add_item("sku-002", 1, Money(Decimal("2000"), "KRW"))
    
    total = order.total_amount()
    
    assert total.amount == Decimal("4000")  # 1000*2 + 2000*1
    assert total.currency == "KRW"
```

### 애플리케이션 레이어 테스트 (모의 객체 사용)

애플리케이션 레이어 테스트에서는 실제 인프라 대신 모의 객체를 사용합니다.

```python
# tests/application/test_order_service.py

import pytest
from unittest.mock import Mock, MagicMock
from app.domain.models import Order, Money
from app.application.services.order_service import OrderService
from decimal import Decimal

class FakeUnitOfWork:
    """가짜 작업 단위"""
    
    def __init__(self):
        self.orders = FakeOrderRepository()
        self.committed = False
    
    def __enter__(self):
        return self
    
    def __exit__(self, *args):
        pass
    
    def commit(self):
        self.committed = True
    
    def rollback(self):
        pass

class FakeOrderRepository:
    """가짜 주문 저장소"""
    
    def __init__(self):
        self.orders = {}
    
    def get(self, order_id):
        return self.orders.get(order_id)
    
    def add(self, order):
        self.orders[order.id] = order
    
    def save(self, order):
        self.orders[order.id] = order

def test_create_order():
    """주문 생성 서비스 테스트"""
    uow = FakeUnitOfWork()
    service = OrderService(uow)
    
    order = Order(id="order-1", customer_id="customer-1")
    order.add_item("sku-001", 2, Money(Decimal("1000"), "KRW"))
    
    service.create_order(order)
    
    assert "order-1" in uow.orders.orders
    assert uow.committed == True
    assert uow.orders.orders["order-1"].status == "draft"

def test_confirm_order():
    """주문 확인 서비스 테스트"""
    uow = FakeUnitOfWork()
    service = OrderService(uow)
    
    order = Order(id="order-1", customer_id="customer-1")
    order.add_item("sku-001", 1, Money(Decimal("1000"), "KRW"))
    uow.orders.add(order)
    
    service.confirm_order("order-1")
    
    confirmed_order = uow.orders.get("order-1")
    assert confirmed_order.status == "confirmed"
    assert uow.committed == True

def test_order_not_found():
    """존재하지 않는 주문 처리 테스트"""
    uow = FakeUnitOfWork()
    service = OrderService(uow)
    
    with pytest.raises(Exception, match="주문을 찾을 수 없습니다"):
        service.confirm_order("nonexistent-order")
```

### 통합 테스트

통합 테스트는 실제 데이터베이스와 함께 전체 흐름을 검증합니다.

```python
# tests/integration/test_order_flow.py

import pytest
from app import create_app
from app.domain.models import Order, Money
from decimal import Decimal

@pytest.fixture
def client():
    """테스트 클라이언트 생성"""
    app = create_app(testing=True)
    with app.test_client() as client:
        with app.app_context():
            yield client

def test_create_order_flow(client):
    """주문 생성 흐름 통합 테스트"""
    
    # 주문 생성 요청
    order_data = {
        "customer_id": "test-customer-1",
        "items": [
            {
                "sku": "test-sku-001",
                "quantity": 2,
                "unit_price": "1500.00"
            },
            {
                "sku": "test-sku-002",
                "quantity": 1,
                "unit_price": "3000.00"
            }
        ]
    }
    
    response = client.post("/api/orders", json=order_data)
    
    assert response.status_code == 201
    
    response_data = response.get_json()
    assert "id" in response_data
    assert response_data["customer_id"] == "test-customer-1"
    assert response_data["status"] == "draft"
    assert response_data["total_amount"] == "6000.00"  # 1500*2 + 3000*1
    
    # 주문 확인 요청
    order_id = response_data["id"]
    confirm_response = client.post(f"/api/orders/{order_id}/confirm")
    
    assert confirm_response.status_code == 204
    
    # 확인된 주문 조회
    get_response = client.get(f"/api/orders/{order_id}")
    
    assert get_response.status_code == 200
    order_data = get_response.get_json()
    assert order_data["status"] == "confirmed"
```

---

## 점진적 리팩터링 로드맵

기존의 모놀리식 Flask 애플리케이션을 계층화된 아키텍처로 전환하는 과정은 점진적으로 진행할 수 있습니다.

**1단계: DTO 도입**
- 기존 라우트에 Pydantic 스키마를 추가하여 입력 검증을 강화합니다.
- 응답 형식을 표준화하고 문서화합니다.

**2단계: 서비스 레이어 분리**
- 라우트 핸들러에서 비즈니스 로직을 추출하여 서비스 클래스로 이동합니다.
- 서비스 클래스가 트랜잭션 경계를 관리하도록 합니다.

**3단계: 리포지토리 패턴 도입**
- 데이터 접근 로직을 리포지토리 인터페이스 뒤로 숨깁니다.
- 애플리케이션 코드가 구체적인 데이터 저장소 구현에 의존하지 않도록 합니다.

**4단계: 도메인 모델 순수화**
- SQLAlchemy 의존성을 도메인 객체에서 제거합니다.
- 도메인 객체를 순수한 Python 객체로 재구성합니다.

**5단계: 이벤트 기반 아키텍처 도입**
- 도메인 이벤트를 정의하고 발행합니다.
- 아웃박스 패턴을 통해 이벤트의 안정적인 전달을 보장합니다.

**6단계: 멀티테넌시 지원**
- 테넌트 컨텍스트 관리 시스템을 도입합니다.
- 데이터베이스 접근 전략을 테넌트 요구사항에 맞게 조정합니다.

---

## 결론

계층화된 아키텍처는 Flask 애플리케이션의 유지보수성, 테스트 용이성, 확장성을 크게 향상시키는 강력한 접근 방식입니다.

**첫째, 관심사의 분리는 장기적인 생산성을 보장합니다.** 프레젠테이션, 애플리케이션, 도메인, 인프라 레이어를 명확히 분리함으로써, 각 영역의 변경이 다른 부분에 미치는 영향을 최소화할 수 있습니다. 이는 특히 대규모 팀에서 협업하거나 장기적으로 프로젝트를 유지보수할 때 중요한 장점입니다.

**둘째, 테스트 용이성은 품질 보증의 핵심입니다.** 도메인 로직은 외부 의존성 없이 단위 테스트할 수 있고, 애플리케이션 서비스는 모의 객체를 통해 효율적으로 테스트할 수 있습니다. 이는 버그를 조기에 발견하고 리팩터링을 안전하게 수행하는 데 필수적입니다.

**셋째, 기술적 유연성은 미래의 변화에 대비합니다.** 데이터베이스, 캐시, 외부 API와 같은 인프라 구성 요소를 포트와 어댑터 패턴으로 추상화하면, 기술 스택의 변경이 비즈니스 로직에 미치는 영향을 최소화할 수 있습니다.

**넷째, 멀티테네시와 같은 복잡한 요구사항을 체계적으로 처리할 수 있습니다.** 테넌트별 데이터 격리, 캐싱, 인증과 같은 크로스커팅 관심사를 아키텍처 수준에서 일관되게 처리할 수 있습니다.

계층화된 아키텍처는 초기에는 더 많은 설계와 구현 노력이 필요할 수 있지만, 애플리케이션이 성장하고 복잡해짐에 따라 그 가치는 기하급수적으로 증가합니다. 특히 장기적으로 유지보수되고 확장될 애플리케이션의 경우, 이러한 투자는 필수적이라고 할 수 있습니다.

Flask의 유연성은 이러한 아키텍처 패턴을 구현하는 데 이상적인 환경을 제공합니다. 프레임워크가 강제하는 제약이 적기 때문에, 팀의 특정 요구사항과 도메인에 맞춰 아키텍처를 설계할 수 있습니다. 핵심은 아키텍처 원칙을 이해하고, 프로젝트의 규모와 복잡도에 맞는 적절한 수준의 구조화를 적용하는 것입니다.