---
layout: post
title: 디자인패턴 - Iterator
date: 2025-06-30 20:20:23 +0900
category: 디자인패턴
---
# Iterator (반복자 패턴)

## 정의

**반복자 패턴(Iterator Pattern)**은 **컬렉션의 내부 표현을 노출하지 않고** 요소들에 **순차적으로 접근**할 수 있도록 하는 패턴이다.
반복 동작을 별도의 객체(반복자)로 **캡슐화**함으로써 컬렉션(집합체, Aggregate)과 순회 로직을 **분리**한다.

핵심 목표
- 컬렉션 내부 구조 은닉(캡슐화 강화)
- 다양한 순회 전략(정/역방향, 필터링, 병합 등)을 교체 가능
- 언어 전반에 걸친 **일관된 순회 인터페이스** 제공

---

## 구조 (UML/ASCII)

```
┌──────────────────┐         ┌───────────────────┐
│    Iterable      │         │     Iterator      │
│  + iterator()    │◄───────▶│  + hasNext()     │
└───────┬──────────┘         │  + next()        │
        │                     └─────────┬────────┘
        │                               │
┌───────▼──────────┐         ┌──────────▼─────────┐
│ ConcreteIterable │         │ ConcreteIterator   │
└──────────────────┘         └────────────────────┘
```

역할
- **Iterable(Aggregate)**: 반복자를 생성하는 팩토리 역할
- **Iterator**: 순회의 상태를 보유하고 `hasNext()/next()` 혹은 언어별 동등 프로토콜 제공
- **ConcreteIterable/Iterator**: 실제 컬렉션·반복 로직 구현

---

## 핵심 개념 정리

### 외부(External) vs 내부(Internal) 반복자

- **외부 반복자**: 클라이언트가 직접 `next()`를 호출하며 흐름 제어(중단/재개) 가능
- **내부 반복자**: 컬렉션이 콜백/람다를 받아 내부 루프에서 호출(조기 종료가 까다롭지만 구현 단순)

### 풀(Pull) vs 푸시(Push)

- **Pull**: 클라이언트가 원할 때 `next()`로 당겨옴(예: Python iterator, Java Iterator)
- **Push**: 생산자가 소비자에게 밀어넣음(예: Reactive Streams, Observer 패턴과 친연)

### 스냅샷 vs 라이브 뷰

- **스냅샷**: 반복 시작 시점의 고정 뷰(안전하나 메모리/복사 비용)
- **라이브**: 기저 컬렉션 변경이 즉시 반영(성능 유리하나 동시 수정 규칙에 주의)

---

## Python — Iterator/Iterable 프로토콜, 제너레이터, 커스텀 반복자

### 가장 단순한 커스텀 반복자

```python
class BookIterator:
    def __init__(self, books):
        self._books = books
        self._i = 0
    def __iter__(self):
        return self
    def __next__(self):
        if self._i >= len(self._books):
            raise StopIteration
        v = self._books[self._i]
        self._i += 1
        return v

class BookShelf:
    def __init__(self): self._books = []
    def add(self, b): self._books.append(b)
    def __iter__(self):
        return BookIterator(self._books)

s = BookShelf(); s.add("Clean Code"); s.add("Design Patterns"); s.add("Effective Python")
for b in s:
    print(b)
```

### 제너레이터 기반 구현(권장, 간결·지연평가)

```python
class RangeRev:
    def __init__(self, start, stop):
        self.start, self.stop = start, stop
    def __iter__(self):
        for x in range(self.stop - 1, self.start - 1, -1):
            yield x

for x in RangeRev(3, 7):  # 6,5,4,3
    pass
```

### 필터/맵/체이닝(파이프라이닝)

```python
def filter_iter(pred, it):
    for x in it:
        if pred(x):
            yield x

def map_iter(f, it):
    for x in it:
        yield f(x)

def take(n, it):
    for i, x in enumerate(it):
        if i >= n: return
        yield x

data = [1,2,3,4,5,6]
res = take(3, map_iter(lambda x: x*x, filter_iter(lambda x: x%2==0, data)))
print(list(res))  # [4, 16, 36]
```

### 트리 구조 플래튼(Composite 순회)

```python
def flatten(tree):
    # tree: (value, [children...]) 형태
    value, children = tree
    yield value
    for ch in children:
        yield from flatten(ch)

root = ("A", [("B", [("D", [])]), ("C", [("E", []), ("F", [])])])
print(list(flatten(root)))  # ['A','B','D','C','E','F']
```

### 슬라이딩 윈도우, 배칭, 피커블(look-ahead)

```python
from collections import deque

def sliding_window(it, k):
    q = deque(maxlen=k)
    for x in it:
        q.append(x)
        if len(q) == k:
            yield tuple(q)

def batched(it, size):
    batch = []
    for x in it:
        batch.append(x)
        if len(batch) == size:
            yield batch; batch = []
    if batch: yield batch
```

---

## Java — Iterable/Iterator, for-each, 역방향·필터·연결 반복자

### 표준 프로토콜

```java
import java.util.*;

class BookShelf implements Iterable<String> {
    private final List<String> books = new ArrayList<>();
    public void add(String b) { books.add(b); }
    @Override public Iterator<String> iterator() {
        return books.iterator(); // 기본 iterator 위임
    }
}

public class Demo {
    public static void main(String[] args) {
        BookShelf s = new BookShelf();
        s.add("Clean Code"); s.add("Design Patterns");
        for (String b : s) {
            System.out.println(b);
        }
    }
}
```

### 역방향·필터·연결 이터레이터 스케치

```java
class ReverseIterator<T> implements Iterator<T> {
    private final List<T> base; private int i;
    ReverseIterator(List<T> base) { this.base = base; this.i = base.size()-1; }
    public boolean hasNext() { return i >= 0; }
    public T next() { return base.get(i--); }
}

class FilterIterator<T> implements Iterator<T> {
    private final Iterator<T> it; private final java.util.function.Predicate<T> pred;
    private T next; private boolean ready = false;
    FilterIterator(Iterator<T> it, java.util.function.Predicate<T> pred) {
        this.it = it; this.pred = pred;
    }
    private void advance() {
        while (it.hasNext()) {
            T v = it.next();
            if (pred.test(v)) { next = v; ready = true; return; }
        }
        ready = false;
    }
    public boolean hasNext() { if (!ready) advance(); return ready; }
    public T next() { if (!hasNext()) throw new NoSuchElementException(); ready=false; return next; }
}
```

주의: Java 컬렉션은 반복 중 구조적 변경 시 **ConcurrentModificationException**이 발생할 수 있다(스냅샷이 아닌 라이브 뷰).

---

## C# — IEnumerable/IEnumerator, `yield return`, LINQ

### 기본

```csharp
using System;
using System.Collections;
using System.Collections.Generic;

public class BookShelf : IEnumerable<string>
{
    private readonly List<string> _books = new();
    public void Add(string b) => _books.Add(b);

    public IEnumerator<string> GetEnumerator() => _books.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}
```

### 제너레이터(`yield return`)와 커스텀 순회

```csharp
public static IEnumerable<int> ReverseRange(int start, int count)
{
    for (int i = start + count - 1; i >= start; --i)
        yield return i;
}

public static IEnumerable<int> SlidingWindowSums(IEnumerable<int> src, int k)
{
    var q = new Queue<int>(); int sum = 0;
    foreach (var x in src)
    {
        q.Enqueue(x); sum += x;
        if (q.Count == k)
        {
            yield return sum;
            sum -= q.Dequeue();
        }
    }
}
```

C# 규칙: 열거 중 컬렉션 수정은 `InvalidOperationException` 유발 가능. 일부 컬렉션은 읽기 전용 스냅샷을 제공하지 않는다.

---

## C++ — 반복자 카테고리와 무효화 규칙, 범위 기반 for

### 반복자 카테고리

- **Input/Output/Forward/Bidirectional/RandomAccess/Contiguous**
알고리즘 제약을 컴파일타임에 표현(예: `std::sort`는 RandomAccess 요구).

### begin/end, 사용자 컨테이너

```cpp
#include <vector>
#include <iostream>

struct Bag {
    std::vector<int> data;
    auto begin() { return data.begin(); }
    auto end()   { return data.end();   }
    auto begin() const { return data.begin(); }
    auto end()   const { return data.end();   }
};

int main(){
    Bag b; b.data = {1,2,3};
    for (auto x : b) std::cout << x << "\n";
}
```

### 무효화 규칙(예시)

- `std::vector`: 용량 재할당 발생 시 **모든 반복자** 무효화; 중간 erase는 해당 요소 이후 반복자 이동
- `std::list`: 노드 기반이므로 삽입/삭제 시 **다른 반복자 유효**
- 표준 알고리즘 사용 시 카테고리 요구사항을 준수해야 안전/성능 확보

---

## 고급 반복자 레시피

### 역방향, 순환, 건너뛰기

```python
def reversed_iter(it):
    data = list(it)
    for i in range(len(data)-1, -1, -1):
        yield data[i]

def cycle_iter(it):
    data = list(it)
    while True:
        for x in data: yield x

def skip_every(it, step):
    for i, x in enumerate(it, 1):
        if i % step != 0:
            yield x
```

### 병합(정렬 병합), 교차 지퍼(zip), 병렬 이터레이션

```python
def merge_sorted(a, b):
    ax = iter(a); bx = iter(b)
    va = next(ax, None); vb = next(bx, None)
    while va is not None or vb is not None:
        if vb is None or (va is not None and va <= vb):
            yield va; va = next(ax, None)
        else:
            yield vb; vb = next(bx, None)
```

### 트리/그래프 순회(DFS/BFS)

```python
from collections import deque

def dfs(root, children):
    stack = [root]
    while stack:
        v = stack.pop()
        yield v
        stack.extend(reversed(children(v)))

def bfs(root, children):
    q = deque([root])
    while q:
        v = q.popleft()
        yield v
        q.extend(children(v))
```

---

## 성능·메모리 모델 (수식과 함께)

반복자의 장점은 **지연 평가(lazy evaluation)**와 **O(1) 메모리**(상태만 보유)다.
리스트 물질화(materialization)는 \( O(n) \) 메모리가 필요하다.

- 연산 체인의 총 시간 복잡도(단순 직렬, 각 단계 비용 \( c_i \), 항목 수 \( n \)):

$$
T(n) \approx n \cdot \sum_{i=1}^{k} c_i
$$

- 파이프 안에서 **조기 종료**가 가능한 경우(예: `take(m)`):

$$
T(n) \approx m \cdot \sum_{i=1}^{k} c_i \quad (m \ll n)
$$

이는 대용량 데이터 스트림에서 반복자 조합이 **실질적 시간·메모리 절감**을 제공함을 의미한다.

---

## 동시 수정(Concurrent Modification)·스냅샷·락

언어/컬렉션 별 규칙 요약

| 언어/프레임워크 | 규칙 |
|---|---|
| Java | 반복 중 구조적 변경 시 `ConcurrentModificationException` (Fail-Fast). Concurrent 컬렉션은 약한 일관성 제공. |
| C# | 열거 중 수정 시 `InvalidOperationException` 가능. 일부 컬렉션은 허용/스냅샷 제공 아님. |
| Python | 리스트 반복 중 직접 삭제/삽입은 버그 유발. 보통 복사본이나 **역순 인덱스**로 삭제. |
| C++ | 컨테이너 별 **무효화 규칙** 상이. `vector` 재할당 주의, `list`는 비교적 안전. |

실무 권장
- 반복 도중 수정이 필요하면 **수정 목록을 따로 수집** 후 한 번에 반영
- 또는 **불변 컬렉션** 사용, 또는 **스냅샷 뷰** 생성

---

## 실제 시나리오

### 로그 파이프: 필터 → 파싱 → 포맷 → 배치

```python
def read_lines(path):
    with open(path, "rt", encoding="utf-8") as f:
        for line in f: yield line.rstrip("\n")

def grep(substr, it):
    for line in it:
        if substr in line:
            yield line

def parse_nginx(it):
    for line in it:
        parts = line.split()
        if len(parts) >= 9:
            yield {"ip": parts[0], "path": parts[6], "status": int(parts[8])}

def format_tsv(it):
    for rec in it:
        yield f'{rec["ip"]}\t{rec["path"]}\t{rec["status"]}'

pipeline = format_tsv(parse_nginx(grep("GET", read_lines("access.log"))))
for out in pipeline:
    # print(out) 혹은 파일로 배출
    pass
```

### 대용량 CSV 스트리밍 처리(물질화 없이 집계)

```python
import csv

def csv_rows(path):
    with open(path, newline="", encoding="utf-8") as f:
        r = csv.DictReader(f)
        for row in r: yield row

def count_status(rows, target=200):
    cnt = 0
    for r in rows:
        if int(r["status"]) == target: cnt += 1
    return cnt

ok = count_status(csv_rows("nginx.csv"), 200)
```

---

## 테스트 전략

### 프로토콜 준수

- Python: `iter(obj)`가 이터레이터를 반환하고, 이터레이터는 `__iter__`가 자기 자신을 반환해야 한다.
- Java/C#: `Iterable`/`IEnumerable` 계약 준수 확인

### 경계 조건

- 빈 컬렉션, 한 요소, 매우 큰 컬렉션
- 조기 종료 연산(`take`, `any`)과의 상호작용

### 동시 수정 검증

- 언어별 예외 발생 여부/시점 확인
- 스냅샷 전략 적용 시 결과 일관성 테스트

예: Python 빠른 단위 테스트
```python
def test_take_and_map():
    assert list(take(0, map_iter(lambda x:x+1, [1,2,3]))) == []
    assert list(take(2, map_iter(lambda x:x+1, [1,2,3]))) == [2,3]
```

---

## Iterator vs Composite vs Visitor (확장 표)

| 패턴 | 목적 | 공통점 | 차이점/언제 쓰나 |
|---|---|---|---|
| Iterator | 내부 은닉, 순차 접근 | 자료구조와 연산의 분리 | 순회 자체가 목적. 연산은 외부/파이프에 위치 |
| Composite | 트리 구조로 부분-전체 통일 | 계층 자료구조 | 구조 표현에 초점. 순회는 별도 이터레이터로 구현 가능 |
| Visitor | 연산 추가 | 구조+연산 분리 | 구조는 고정, 연산을 쉽게 추가. 이터레이터와 함께 AST 탐색에 활용 |

---

## 안티패턴·체크리스트

체크리스트
- [ ] 컬렉션 **내부 구조를 노출**하지 않았는가?
- [ ] 반복자와 컬렉션의 **책임 분리**가 명확한가?
- [ ] 필요한 순회 전략(역방향/필터/맵/병합/트리)이 **교체 가능**한가?
- [ ] 동시 수정/무효화 규칙을 **문서화**했는가?
- [ ] 긴 체인을 **지연 평가**로 처리해 메모리 사용을 최소화했는가?
- [ ] 테스트에 **빈 입력/조기 종료/대용량** 케이스가 포함되어 있는가?

안티패턴
- 반복자 내부에서 컬렉션의 **비공개 구조에 직접 의존**
- 반복 중 컬렉션을 무분별하게 변경해 **비결정적 동작** 유발
- 지연 평가를 무시하고 매 단계 **물질화(list화)** 하여 메모리 낭비
- 언어 프로토콜(`__iter__`, `Symbol.iterator`, `IEnumerable`)을 **부분 구현**

---

## 요약

- 반복자 패턴은 **내부 은닉**과 **지연 평가**로, 대용량 데이터·스트림 처리에 적합하다.
- 외부/내부, 풀/푸시, 스냅샷/라이브의 **모드 선택**이 설계 품질을 좌우한다.
- 언어별 표준 인터페이스(Python iterator/iterator protocol, Java Iterable/Iterator, C# IEnumerable/IEnumerator, C++ iterator/begin-end)를 준수하라.
- 고급 조합(필터/맵/병합/트리/윈도우/배칭)으로 **간결한 파이프라인**을 구성하고, **동시 수정 규칙**을 엄격히 관리하라.
- 성능은 \( O(1) \) 상태 메모리와 조기 종료로 최적화되며, 필요 시 수식으로 모델링해 병목을 식별하라.
