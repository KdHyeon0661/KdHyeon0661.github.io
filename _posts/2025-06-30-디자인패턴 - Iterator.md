---
layout: post
title: 디자인패턴 - Iterator
date: 2025-06-30 20:20:23 +0900
category: 디자인패턴
---
# Iterator (반복자 패턴)

## ✅ 정의

**반복자 패턴(Iterator Pattern)**은 **컬렉션 내부의 구조를 노출하지 않고**, 그 요소들에 **순차적으로 접근할 수 있도록** 하는 디자인 패턴입니다.  
반복 동작을 객체로 캡슐화하여 **컬렉션과 순회 로직을 분리**합니다.

> “컬렉션의 내부 구조를 숨긴 채, 요소를 하나씩 순회할 수 있는 방법을 제공”

---

## 🎯 의도 (Intent)

- **컬렉션 객체의 내부 구조를 노출하지 않고**
- 외부에서 **일관된 방식으로 요소를 순회**할 수 있도록 함
- 다양한 순회 방식(정방향, 역방향 등)을 독립적으로 구현 가능

---

## 📦 구조 (UML)

```
┌────────────┐     ┌────────────────┐
│ Iterable   │◄────│    Iterator     │
└────┬───────┘     └────────┬───────┘
     ▼                      ▼
┌────────────┐     ┌────────────────┐
│ConcreteCol │     │ConcreteIterator│
└────────────┘     └────────────────┘
```

- `Iterator`: 순회 방식 정의 (`hasNext()`, `next()`)
- `ConcreteIterator`: 실제 반복 로직 구현
- `Iterable` (또는 `Aggregate`): 반복자를 생성하는 인터페이스 (`createIterator()`)
- `ConcreteCollection`: 컬렉션 객체

---

## 🧑‍💻 구현 예시 (Python)

```python
# 반복자 (Iterator)
class BookIterator:
    def __init__(self, books):
        self._books = books
        self._index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self._index < len(self._books):
            book = self._books[self._index]
            self._index += 1
            return book
        raise StopIteration

# 컬렉션 (Iterable)
class BookShelf:
    def __init__(self):
        self._books = []

    def add_book(self, book):
        self._books.append(book)

    def __iter__(self):
        return BookIterator(self._books)

# 사용 예시
shelf = BookShelf()
shelf.add_book("Clean Code")
shelf.add_book("Design Patterns")
shelf.add_book("Effective Python")

for book in shelf:
    print(f"📚 {book}")
```

**출력 예시:**
```
📚 Clean Code
📚 Design Patterns
📚 Effective Python
```

---

## ✅ 장점

- **컬렉션 내부 구현과 반복 로직을 분리** → SRP(단일 책임 원칙) 준수
- 여러 종류의 컬렉션에서도 **일관된 반복 인터페이스 제공**
- 다양한 순회 방법(정방향, 역방향, 필터링 등) 쉽게 구현 가능
- Python의 `for`, Java의 `Iterator`, C#의 `IEnumerator` 등 다양한 언어에서 기본 제공

---

## ⚠️ 단점

- 컬렉션에 따라 **반복자 클래스 수가 증가**할 수 있음
- 단순한 순회에는 **기본 for문보다 복잡**해질 수 있음
- 동시 수정에 대한 문제(concurrent modification) 주의 필요

---

## 📌 사용 사례

| 분야 | 예시 |
|------|------|
| 컬렉션 순회 | 리스트, 맵, 집합 등을 순차 접근 |
| UI 요소 반복 | 메뉴, 버튼, 리스트 아이템 반복 |
| 트리 구조 탐색 | DOM, 파일 시스템 순회 |
| 커스텀 컨테이너 | 반복자를 구현해 `for` 루프 지원 |
| 필터 기반 반복 | 조건에 맞는 요소만 반환하는 필터 이터레이터 |

---

## 🧠 Iterator vs Composite vs Visitor

| 패턴 | 목적 | 공통점 | 차이점 |
|------|------|--------|--------|
| **Iterator** | 순차 순회 | 자료구조에 대한 작업 | 단일 요소 순회 |
| **Composite** | 트리 구조 표현 | 복합 객체 다룸 | 전체 구조를 계층적으로 처리 |
| **Visitor** | 연산 분리 | 구조체를 탐색 | 각 요소에 연산 적용 중심 |

---

## ✅ 실무 팁

- Python에서는 `__iter__`, `__next__`, `yield` 등을 통해 쉽게 반복자 구현 가능
- 커스텀 컬렉션을 만들 때는 반드시 `Iterable` 인터페이스 구현 고려
- 내부 구현 변경 시에도 외부 반복 코드를 **변경 없이 유지**할 수 있음

---

## 🧠 마무리

**Iterator 패턴은 복잡한 자료구조를 클라이언트에 숨기고,**
**일관된 방법으로 순회할 수 있게 해주는 강력한 도구입니다.**

컬렉션과 순회 로직을 분리하고, 다양한 반복 전략을 지원하며  
현대 프로그래밍 언어에서는 거의 모든 컬렉션에 적용되고 있는 **가장 보편적인 디자인 패턴 중 하나**입니다.
