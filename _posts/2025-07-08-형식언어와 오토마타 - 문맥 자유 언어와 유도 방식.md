---
layout: post
title: 형식언어와 오토마타 - 문맥 자유 언어와 유도 방식
date: 2025-07-08 20:20:23 +0900
category: 형식언어와 오토마타
---
# 문맥 자유 언어(CFL)와 유도 방식

> 목표
> 1) **문맥 자유 언어(CFL)**와 **문맥 자유 문법(CFG)**의 형식 정의를 명확히 설명
> 2) **유도(derivation)**의 핵심: 좌측 우선/우측 우선의 차이와 파스 트리(Parse Tree) 연결 고리
> 3) **모호성(ambiguity)**, **정규 언어와의 차이**, **PDA와의 동치**를 직관+수학으로 정리
> 4) 실전용 **파이썬 코드**: 좌/우 유도 시뮬레이터, 파스 트리 생성, CYK 멤버십 판정(CNF)

---

## 큰 그림 한 장

- **정규 언어**: DFA/NFA/정규표현식, “메모리 없는” 인식 — **균형/중첩 구조 불가**
- **문맥 자유 언어(CFL)**: CFG, PDA(스택 1개)로 인식 — **중첩/균형**을 자연스럽게 표현
- **유도(derivation)**: 시작기호에서 규칙을 적용해 터미널 문자열을 만드는 과정
  - **좌측 우선(Leftmost)**: 가장 왼쪽 비터미널부터
  - **우측 우선(Rightmost)**: 가장 오른쪽 비터미널부터
  - **LL 파싱 ↔ 좌측 우선**, **LR 파싱 ↔ 우측 우선(역방향)**

---

## 문맥 자유 언어(CFL)와 문맥 자유 문법(CFG)

### 정의

CFG는 4-튜플:
$$
G=(V,\Sigma,R,S)
$$

- \(V\): 비터미널 집합
- \(\Sigma\): 터미널 집합 (\(V\cap \Sigma=\varnothing\))
- \(R\): 생성 규칙 집합, 각 규칙은 \(A\to \alpha\) 형태
  \(\quad (A\in V,\;\alpha \in (V\cup \Sigma)^\*)\)
- \(S\in V\): 시작 기호

언어:
$$
L(G)=\{\, w\in \Sigma^\* \mid S \Rightarrow^\* w \,\}
$$

> **문맥 자유 언어(CFL)**: 어떤 CFG \(G\)가 있어 \(L=L(G)\)인 언어 \(L\).

---

## 대표 예시와 직관

### 균형 괄호 언어

$$
S \to SS \mid (S) \mid \varepsilon
$$
- “여는 괄호”와 “닫는 괄호”의 균형/중첩을 **재귀 규칙**으로 간결히 표현.

### 동일 개수 언어 \( \{a^n b^n \mid n\ge 0\} \)

$$
S \to aSb \mid \varepsilon
$$
- 정규 언어로는 불가(펌핑 렘마 반례), **CFL**로는 간단.

---

## 유도(Derivation)와 문장형(Sentential Form)

- **유도**: \( \alpha \Rightarrow \beta \) 는 한 번의 규칙 적용,
  \( \Rightarrow^\* \) 는 0회 이상 반복 적용(전이 폐포).

- **문장형(sentential form)**: 파생 중간에 나오는 \( (V\cup\Sigma)^\* \) 문자열

---

## 좌측 우선 / 우측 우선 유도

### 정의

| 방식 | 규칙 적용 순서 |
|---|---|
| **좌측 우선(Leftmost)** | 현재 문장형에서 **가장 왼쪽**의 비터미널을 먼저 치환 |
| **우측 우선(Rightmost)** | 현재 문장형에서 **가장 오른쪽**의 비터미널을 먼저 치환 |

- **LL 파서**는 좌측 우선 유도를 **예측적으로 구성**
- **LR 파서**는 우측 우선 유도의 **역순을 하향식으로 복원**

### 에서 `aabb`

**좌측 우선**
1) \( S \Rightarrow aSb \)
2) \( \Rightarrow aaSbb \)
3) \( \Rightarrow aa\varepsilon bb \)
4) \( \Rightarrow aabb \)

**우측 우선**
1) \( S \Rightarrow aSb \)
2) \( \Rightarrow a(aSb)b \)
3) \( \Rightarrow a(a\varepsilon b)b \)
4) \( \Rightarrow aabb \)

> 두 방식 모두 **같은 문자열**을 얻고, **같은 파스 트리**로 귀결되는 경우가 많음.
> 단, **모호한 문법**은 동일 문자열에 대해 **서로 다른 파스 트리**가 가능.

---

## 파스 트리(Parse Tree)와 유도

- 파스 트리는 **유도 과정을 트리로 시각화**한 것.
- 리프(left-to-right) **yields**가 최종 문자열.
- **좌/우 유도**는 트리의 **방문 순서** 차이일 뿐, **트리 자체는 동일**(문법이 비모호하다면).

### )

```
       S
     / | \
    a  S  b
      /|\
     a S b
       |
       ε
===> 리프 읽기: a a b b
```

---

## 모호성(Ambiguity)와 해결

### 모호한 산술 문법

```
E → E + E | E * E | (E) | id
```
- `id + id * id`에 두 개의 파스 트리(우선순위가 불명확).

### 문법

```
E  → T E'
E' → + T E' | ε
T  → F T'
T' → * F T' | ε
F  → (E) | id
```
- `*`가 `+`보다 높은 우선순위, 둘 다 **좌결합**.

> **사실**: 문법 **모호성 검출은 결정 불가능**(CFG 전반에 대해).
> 실무에선 설계로 **원천 차단**(우선순위/결합법칙을 문법에 코딩).

---

## PDA(푸시다운 오토마타)와의 동치

- **정리**: CFG로 생성되는 언어 ↔ **PDA**로 인식되는 언어 (**CFL**)
- 직관: **스택**이 중첩/균형을 기억(예: `(` 푸시 → `)`에서 팝)

### CFG → PDA (개념 스케치)

- PDA 스택에 시작기호 \(S\)를 push.
- 스택 top이 비터미널 \(A\)이면 규칙 \(A\to \alpha\)로 **치환**하듯 \(\alpha\)를 **역순 push**.
- 스택 top이 터미널이면 입력과 **매칭 후 pop·consume**.
- 입력 소진 + 스택 비우기 성공 시 **수용**.

---

## 정규 vs 문맥 자유 — 폐포·결정 문제(요점만)

- **CFL 폐포**: 합, 연접, Kleene-별, **정규 언어와의 교집합**에는 닫힘
  (그러나 **보완/교집합(서로)**에는 닫히지 않음)
- **결정 문제**:
  - 멤버십(문자열 \(w\in L(G)\)인가?): **CYK**(CNF)로 \(O(n^3)\)
  - 공허(빈 언어?): **결정 가능**
  - 동치/포함/모호성: **일반적으로 결정 불가**

---

## 유도 실습 — 파이썬으로 좌/우 유도와 파스 트리 찍기

아래 코드는 **작은 CFG**에 대해 **좌측/우측 유도**를 시도하고, **파스 트리**를 텍스트로 출력합니다.
(간단한 백트래킹; 실습·교육용. 대형 문법엔 CYK나 전용 파서 권장)

```python
# derivation_playground.py

from collections import deque
from dataclasses import dataclass
from typing import List, Dict, Tuple, Optional, Union

# Grammar 형식:
#   grammar: Dict[str, List[List[str]]]
#   Nonterminal은 대문자(예: "S","E","T" ...), terminal은 소문자나 기호(예: "a","b","(",")","id")
#   ε는 문자열 'ε' 로 표기

EPS = 'ε'

@dataclass
class Node:
    sym: str
    children: List['Node']

def is_nonterminal(x: str) -> bool:
    return x and x[0].isupper()

def expand_leftmost(sentential: List[str], grammar: Dict[str, List[List[str]]]) -> Optional[Tuple[int, str, List[List[str]]]]:
    for i, s in enumerate(sentential):
        if is_nonterminal(s):
            return i, s, grammar.get(s, [])
    return None

def expand_rightmost(sentential: List[str], grammar: Dict[str, List[List[str]]]) -> Optional[Tuple[int, str, List[List[str]]]]:
    for i in range(len(sentential)-1, -1, -1):
        s = sentential[i]
        if is_nonterminal(s):
            return i, s, grammar.get(s, [])
    return None

def derivation(target: List[str], grammar: Dict[str, List[List[str]]], start: str, leftmost=True, max_steps=200) -> Optional[List[List[str]]]:
    # 간단 백트래킹: 좌/우 우선으로만 선택, 분기는 생산 선택에서
    path = []

    def dfs(current: List[str], steps: int) -> bool:
        # prune
        if steps > max_steps: return False
        # EPS 삭제 표준화
        curr = [c for c in current if c != EPS]
        path.append(curr)
        # accept?
        if all(not is_nonterminal(x) for x in curr):
            if curr == target:
                return True
        # choose expansion point
        pick = (expand_leftmost if leftmost else expand_rightmost)(curr, grammar)
        if not pick:
            path.pop()
            return False
        i, A, prods = pick
        for rhs in prods:
            nxt = curr[:i] + (rhs if rhs != [EPS] else []) + curr[i+1:]
            if dfs(nxt, steps+1):
                return True
        path.pop()
        return False

    if dfs([start], 0):
        return path
    return None

def print_derivation(steps: List[List[str]]):
    for i, s in enumerate(steps):
        print(f"{i:02d}: {' '.join(s) if s else EPS}")

# 파스 트리 구성(좌측 우선 파생 경로에 따라 간이 구성)

def build_parse_tree(deriv: List[List[str]], grammar: Dict[str, List[List[str]]], start: str) -> Node:
    # 매우 단순화된 재구성: 단계 간 차이를 추적해 트리 자식 채움(교육용)
    root = Node(start, [])
    # 노드 위치를 (문장형 인덱스)로 추정 관리. 교육용이므로 작은 문법·문자열에서만 권장.
    nodes = [root]
    for t in range(len(deriv)-1):
        cur, nxt = deriv[t], deriv[t+1]
        # find first position where nonterminal was expanded
        i_expand = None
        for i, (c, n) in enumerate(zip(cur, nxt + ['']*(len(cur)-len(nxt)))):
            if is_nonterminal(c):
                # replaced c with something
                # 실제 비교는 까다롭지만, 예제 범위에서 첫 비터미널 확장으로 단순화
                i_expand = i
                break
        if i_expand is None:
            continue
        # 현재 nodes 리스트에서 i_expand 위치의 비터미널 노드를 찾아 확장
        # 실제 구현은 문장형-노드 매핑이 필요하지만, 여기선 간단히 DFS로 미매칭 노드 탐색
        def find_kth_nonterminal(node: Node, k: List[int]) -> Optional[Node]:
            if is_nonterminal(node.sym):
                if k[0] == 0: return node
                k[0] -= 1
            for ch in node.children:
                r = find_kth_nonterminal(ch, k)
                if r: return r
            return None
        target_node = find_kth_nonterminal(root, [i_expand])
        if target_node:
            # next sentential에서 이 노드가 확장된 RHS를 추정(간소화)
            # grammar 매칭
            for rhs in grammar.get(target_node.sym, []):
                # 자식 노드 교체
                cand = [Node(x, []) for x in rhs if x != EPS]
                # 무조건 첫 규칙 매칭으로 단순화(교육용)
                target_node.children = cand
                break
    return root

def pretty(node: Node, indent=0):
    print('  '*indent + node.sym)
    for ch in node.children:
        pretty(ch, indent+1)

if __name__ == "__main__":
    # 예제 1) a^n b^n
    G = {
        'S': [['a','S','b'], [EPS]]
    }
    w = list("aabb")
    print("== Leftmost Derivation ==")
    dL = derivation(w, G, 'S', leftmost=True)
    print_derivation(dL)

    print("\n== Rightmost Derivation ==")
    dR = derivation(w, G, 'S', leftmost=False)
    print_derivation(dR)

    print("\n== Parse Tree (from leftmost derivation) ==")
    T = build_parse_tree(dL, G, 'S')
    pretty(T)
```

**실행 예(개략)**

```
== Leftmost Derivation ==
00: S
01: a S b
02: a a S b b
03: a a b b

== Rightmost Derivation ==
00: S
01: a S b
02: a a S b b
03: a a b b

== Parse Tree ==
S
  a
  S
    a
    S
    b
  b
```

> 주의: 파스 트리 재구성은 **교육용 간이 구현**입니다(작은 예제용).
> 실제 파서는 **LL/LR 테이블** 또는 **Earley/GLR** 등 정식 알고리즘 사용.

---

## )

- **전제**: 문법이 **CNF(Chomsky Normal Form)**
  - \( A \to BC \) 또는 \( A \to a \) (그리고 시작기호의 \(S\to \varepsilon\) 허용)
- **목적**: 길이 \(n\) 문자열 \(w\)가 \(L(G)\)에 속하는지 표 기반 DP로 판정

### \( \{a^n b^n\} \)의 CNF 스케치

원문법: \( S \to aSb \mid \varepsilon \)

CNF로 바꾸기 위해 터미널을 변수로 치환:
- \( A\to a,\; B\to b \)
- 삼변수 분해:
  \( S \to A\,T \mid \varepsilon,\quad T \to S\,B \)

이는 CNF 제약을 만족(\(A\to a\), \(B\to b\), 그리고 이진 변수 규칙).
이 문법도 \(a^n b^n\)을 생성합니다.

### CYK 구현

```python
# cyk_cnf.py

from collections import defaultdict
from typing import Dict, List, Set, Tuple

# CNF Grammar:
#  - A -> BC : ('A', ('B','C'))
#  - A -> a  : ('A', 'a')
#  - S -> ε  : start-epsilon allowed

def cyk_membership(w: str, start: str, cnf_bin: List[Tuple[str, Tuple[str,str]]], cnf_term: List[Tuple[str, str]], allow_eps_start=False) -> bool:
    n = len(w)
    if n == 0:
        return allow_eps_start

    # terminals: inverse map a -> {A | A->a}
    term_map: Dict[str, Set[str]] = defaultdict(set)
    for A, a in cnf_term:
        term_map[a].add(A)

    # binary rules: map (B,C) -> {A | A->BC}
    bin_map: Dict[Tuple[str,str], Set[str]] = defaultdict(set)
    for A, (B,C) in cnf_bin:
        bin_map[(B,C)].add(A)

    # P[i][l] = set of variables that derive substring w[i:i+l]
    P: List[List[Set[str]]] = [[set() for _ in range(n+1)] for _ in range(n)]

    # length 1
    for i, ch in enumerate(w):
        P[i][1] = set(term_map.get(ch, set()))

    # length >= 2
    for l in range(2, n+1):
        for i in range(0, n-l+1):
            cell = P[i][l]
            for k in range(1, l):
                left  = P[i][k]
                right = P[i+k][l-k]
                # combine
                for B in left:
                    for C in right:
                        cell |= bin_map.get((B,C), set())

    return start in P[0][n]

if __name__ == "__main__":
    # CNF for a^n b^n (sketch)
    # S -> A T | ε
    # T -> S B
    # A -> a
    # B -> b
    start = 'S'
    cnf_bin = [('S', ('A','T')), ('T', ('S','B'))]
    cnf_term = [('A','a'), ('B','b')]

    for w in ["", "ab", "aabb", "aaabbb", "aab", "abb"]:
        ok = cyk_membership(w, start, cnf_bin, cnf_term, allow_eps_start=True)
        print(f"{w!r}: {ok}")
```

**출력(예)**

```
'': True
'ab': True
'aabb': True
'aaabbb': True
'aab': False
'abb': False
```

> **해설**: CYK는 **CNF 전처리 + DP**로 **보편적 멤버십 판정**을 제공합니다.
> Earley/GLR 등은 CNF 변환 없이도 동작(실무에서 종종 선호).

---

## 단계별 시나리오 — 좌/우 유도 관찰 팁

1) **균형 괄호** \( S\to SS \mid (S) \mid \varepsilon \)
   - `(())()`의 좌/우 유도를 모두 적어 보고, **문장형 길이 변화**를 비교
   - 파스 트리를 그려 리프가 `(())()`로 나오는지 확인

2) **산술식** 모호문법 vs 비모호문법
   - `id+id*id` 좌/우 유도로부터 **서로 다른 트리**(모호)와 **유일 트리**(비모호)를 비교

3) **LL vs LR 감각**
   - 좌측 우선 파생이 자연스럽게 보이면 **예측(LL) 파싱 감각**
   - 우측 우선 역방향이 자연스럽게 보이면 **축약(LR) 파싱 감각**

---

## 더 깊이: 정규와의 경계, 펌핑 렘마(CFL)

- **정규 X**: \( \{a^n b^n\} \), \( \{ww \mid w\in\{a,b\}^\*\} \), \( \{a^n b^n c^n\} \)
- **CFL 펌핑 렘마(요지)**: 충분히 긴 \(z\in L\)은 \(z=uvwxy\)로 쪼개어
  \( |vwx|\le p, |vx|\ge 1\), 그리고 **모든** \(i\ge 0\)에 대해 \(uv^i w x^i y\in L\).
  → \( \{a^n b^n c^n\} \)가 CFL이 **아님**을 보이는 전형적 도구.

---

## 자주 하는 질문(FAQ)

**Q1. 좌/우 유도로 만든 파스 트리는 왜 같나요?**
A. 문법이 **비모호**라면, 한 문자열의 파스 트리는 **유일**. 좌/우 유도는 방문 순서만 다릅니다.

**Q2. 좌측 재귀가 있으면 왜 LL이 힘든가요?**
A. 예측 파서는 “다음 토큰”을 보고 결정해야 하는데, 좌측 재귀는 **무한재귀**를 초래.
   → **좌재귀 제거**와 **좌측 팩토링**으로 LL 친화 변환.

**Q3. CFG 동치 여부는 판정 가능한가요?**
A. 일반적으로 **결정 불가**. 멤버십(CYK)은 가능하지만, 동치·포함·모호성은 불가.

---

## 실전 체크리스트

- [ ] 문법은 **명료**한가? (우선순위/결합법칙 내장)
- [ ] **좌재귀 제거**/팩토링으로 **LL(1)** 가능한가? (또는 LR 대상인가?)
- [ ] **FIRST/FOLLOW** 충돌 없는가?
- [ ] **멤버십 판정**이 필요하면 CYK/Earley 고려
- [ ] **오류 회복 전략**(panic-mode 등) 준비

---

## 요약

| 항목 | 핵심 메시지 |
|---|---|
| CFL/CFG | CFG가 생성하는 언어가 **CFL**. 중첩/균형 구조를 간결히 표현 |
| 유도 | **좌측/우측 우선**: 파서 전략과 1:1 대응(LL vs LR) |
| 파스 트리 | 유도 과정을 트리로; 비모호 문법이면 트리는 유일 |
| PDA 동치 | CFG ↔ PDA (스택 1개). 정규보다 강하고 튜링보다 약함 |
| 결정성 | 멤버십은 **다항시간(CYK)**, 모호성/동치는 **결정 불가** |
| 실전 코드 | 좌/우 유도 시뮬레이터, 간이 파스 트리, **CYK 구현** 제공 |

---

## 연습 문제

1) \( S\to SS \mid (S) \mid \varepsilon \) 에서 `(())()`의 **좌/우 유도**를 각각 써라.
2) 모호 문법 `E→E+E|E*E|(E)|id`로 `id+id*id`의 **두 파스 트리**를 그리고,
   비모호 문법으로 한 번 더 파생해 **우선순위가 반영됨**을 보이라.
3) \( \{a^n b^n \mid n\ge 0\} \) CNF 스케치(본문)로 CYK를 돌려 `aaabbb`은 수용, `aab`은 거부임을 확인하라.
4) CFG \( S\to aSb \mid SS \mid \varepsilon \)의 **좌측 재귀 제거/팩토링**을 시도해 보고 LL 적합 여부를 논하라.

---

## 부록 — 작은 PDA 실행 스케치(개념)

문법 \( S\to aSb \mid \varepsilon \) 인식 PDA:
- 스택 시작: `S`
- 규칙 적용: `S` → `a S b` (스택 push: `b`, `S`, `a`) 또는 `S` → `ε`(pop)
- 입력 매칭: 스택 top이 터미널이면 **입력과 동일해야** pop+consume
- 입력 소진 + 스택 비면 **accept**

`aabb` 예:
1) stack=`S`, input=`aabb`
2) expand: `S→aSb` → stack=`b S a`
3) match `a` → stack=`b S`, input=`abb`
4) expand `S→aSb` → stack=`b b S a`
5) match `a` → stack=`b b S`, input=`bb`
6) expand `S→ε` → stack=`b b`
7) match `b` → stack=`b`, input=`b`
8) match `b` → stack=∅, input=∅ → **accept**

> PDA는 비결정적 분기(여러 규칙 선택)를 가질 수 있으며, BFS/스택-상태 탐색으로 구현 가능.
