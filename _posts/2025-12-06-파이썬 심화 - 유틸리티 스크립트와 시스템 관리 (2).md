---
layout: post
title: 파이썬 심화 - 유틸리티 스크립트와 시스템 관리 (2)
date: 2025-12-06 20:30:23 +0900
category: 파이썬 심화
---
# 유틸리티 스크립트와 시스템 관리 (2)

## 터미널 다루기: 크기 감지와 대화형 인터페이스

터미널 애플리케이션을 개발할 때는 사용자의 터미널 환경을 적절히 인식하고 대응하는 것이 중요합니다. 다양한 운영체제와 터미널 환경에서 일관된 경험을 제공하기 위한 기법들을 살펴봅니다.

### 터미널 크기 감지와 동적 조정

```python
import os
import shutil
import sys
import struct
import fcntl
import termios
import tty
from typing import Tuple, Optional, Dict
from enum import Enum
import threading
import time
import signal

class TerminalInfo:
    """터미널 정보 수집 및 관리 클래스"""
    
    class ColorSupport(Enum):
        NONE = 0      # 색상 미지원
        BASIC = 1     # 8색
        EXTENDED = 2  # 256색
        TRUE_COLOR = 3 # 1600만색
    
    def __init__(self):
        self._size_cache = None
        self._last_update = 0
        self._cache_timeout = 0.5  # 캐시 유효 시간(초)
        self.color_support = self._detect_color_support()
        self.terminal_type = os.environ.get('TERM', 'unknown')
        self.is_interactive = sys.stdin.isatty()
        
    def get_size(self, force_refresh: bool = False) -> Tuple[int, int]:
        """
        터미널 크기 조회 (행, 열)
        
        Args:
            force_refresh: 캐시 무시하고 강제 새로고침
            
        Returns:
            (rows, columns) 튜플
        """
        current_time = time.time()
        
        # 캐시 확인
        if (not force_refresh and self._size_cache and 
            current_time - self._last_update < self._cache_timeout):
            return self._size_cache
        
        try:
            # 방법 1: shutil 사용 (가장 이식성 좋음)
            size = shutil.get_terminal_size(fallback=(80, 24))
            rows, columns = size.lines, size.columns
            
            # 방법 2: Unix/Linux 시스템에서 더 정확한 방법
            if sys.platform != 'win32':
                try:
                    # ioctl로 직접 터미널 크기 조회
                    fd = sys.stdout.fileno()
                    size = struct.unpack('hh', fcntl.ioctl(
                        fd, termios.TIOCGWINSZ, '1234'
                    ))
                    rows, columns = size[0], size[1]
                except (IOError, OSError, struct.error):
                    pass  # shutil 결과 사용
            
            # 방법 3: 환경 변수 확인 (일부 터미널)
            if rows <= 0 or columns <= 0:
                try:
                    rows = int(os.environ.get('LINES', 24))
                    columns = int(os.environ.get('COLUMNS', 80))
                except ValueError:
                    rows, columns = 24, 80
            
            # 결과 검증
            rows = max(1, rows)
            columns = max(1, columns)
            
            self._size_cache = (rows, columns)
            self._last_update = current_time
            
            return rows, columns
            
        except Exception as e:
            # 모든 방법이 실패한 경우 기본값 반환
            print(f"터미널 크기 조회 실패: {e}", file=sys.stderr)
            return 24, 80
    
    def _detect_color_support(self) -> ColorSupport:
        """터미널 색상 지원 수준 감지"""
        
        # 환경 변수 체크
        color_term = os.environ.get('COLORTERM', '').lower()
        if 'truecolor' in color_term or '24bit' in color_term:
            return self.ColorSupport.TRUE_COLOR
        
        term = os.environ.get('TERM', '').lower()
        
        # 터미널 타입으로 판단
        if 'xterm' in term or 'screen' in term or 'tmux' in term:
            # 일반적으로 256색 지원
            return self.ColorSupport.EXTENDED
        
        # 색상 지원 테스트
        try:
            import curses
            curses.setupterm()
            colors = curses.tigetnum('colors')
            if colors >= 16777216:
                return self.ColorSupport.TRUE_COLOR
            elif colors >= 256:
                return self.ColorSupport.EXTENDED
            elif colors >= 8:
                return self.ColorSupport.BASIC
        except:
            pass
        
        return self.ColorSupport.NONE
    
    def setup_resize_handler(self, callback):
        """
        터미널 크기 변경 감지 핸들러 설정
        
        Args:
            callback: 크기 변경시 호출될 함수 (rows, columns) 매개변수 받음
        """
        if sys.platform == 'win32':
            # Windows에서는 주기적 폴링
            self._setup_windows_resize_monitor(callback)
        else:
            # Unix 계열에서는 시그널 처리
            self._setup_unix_resize_handler(callback)
    
    def _setup_unix_resize_handler(self, callback):
        """Unix/Linux 시스템에서 SIGWINCH 시그널 처리"""
        def handler(signum, frame):
            new_size = self.get_size(force_refresh=True)
            callback(*new_size)
        
        try:
            signal.signal(signal.SIGWINCH, handler)
        except AttributeError:
            pass  # Windows에서는 SIGWINCH 없음
    
    def _setup_windows_resize_monitor(self, callback):
        """Windows에서 주기적 폴링으로 크기 감지"""
        def monitor():
            last_size = self.get_size()
            while True:
                time.sleep(0.5)
                current_size = self.get_size(force_refresh=True)
                if current_size != last_size:
                    callback(*current_size)
                    last_size = current_size
        
        thread = threading.Thread(target=monitor, daemon=True)
        thread.start()
    
    def create_progress_bar(self, width: Optional[int] = None, 
                           description: str = "") -> 'ProgressBar':
        """
        터미널 크기에 맞는 프로그레스 바 생성
        
        Args:
            width: 프로그레스 바 너비 (None이면 터미널 크기에 맞춤)
            description: 진행 상황 설명
        """
        if width is None:
            _, columns = self.get_size()
            width = min(columns - 20, 50)  # 설명 공간 확보
        
        return ProgressBar(width, description, self.color_support)

class ProgressBar:
    """터미널용 프로그레스 바"""
    
    def __init__(self, width: int, description: str, 
                 color_support: TerminalInfo.ColorSupport):
        self.width = width
        self.description = description
        self.color_support = color_support
        self.current = 0
        self.total = 100
        self._start_time = time.time()
        
    def update(self, value: int, total: Optional[int] = None):
        """진행 상태 업데이트"""
        if total is not None:
            self.total = total
        self.current = min(value, self.total)
        
        # 프로그레스 바 그리기
        self._draw()
    
    def _draw(self):
        """프로그레스 바 화면에 표시"""
        percentage = (self.current / self.total) * 100
        filled_width = int(self.width * self.current / self.total)
        
        # 색상 코드 (지원 수준에 따라)
        if self.color_support == TerminalInfo.ColorSupport.NONE:
            color_start, color_end = "", ""
        else:
            color_start = "\033[32m"  # 녹색
            color_end = "\033[0m"
        
        # 프로그레스 바 생성
        bar = "[" + color_start + "=" * filled_width + color_end
        bar += " " * (self.width - filled_width) + "]"
        
        # 진행 정보
        elapsed = time.time() - self._start_time
        if self.current > 0:
            eta = elapsed * (self.total - self.current) / self.current
            eta_str = f"ETA: {eta:.1f}s"
        else:
            eta_str = "ETA: --"
        
        # 전체 출력
        sys.stdout.write(f"\r{self.description}: {bar} {percentage:.1f}% "
                        f"({self.current}/{self.total}) {eta_str}")
        sys.stdout.flush()
    
    def finish(self):
        """프로그레스 바 완료 처리"""
        self.update(self.total)
        sys.stdout.write("\n")
        sys.stdout.flush()

class InteractiveTerminal:
    """대화형 터미널 인터페이스"""
    
    def __init__(self):
        self.terminal = TerminalInfo()
        self._original_terminal_settings = None
        
    def __enter__(self):
        """대화형 모드 시작"""
        if self.terminal.is_interactive:
            self._setup_raw_mode()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """대화형 모드 종료"""
        if self.terminal.is_interactive:
            self._restore_terminal()
    
    def _setup_raw_mode(self):
        """Raw 모드 설정 (문자 단위 입력)"""
        if sys.platform != 'win32':
            fd = sys.stdin.fileno()
            self._original_terminal_settings = termios.tcgetattr(fd)
            tty.setraw(fd)
    
    def _restore_terminal(self):
        """터미널 설정 복원"""
        if self._original_terminal_settings:
            fd = sys.stdin.fileno()
            termios.tcsetattr(fd, termios.TCSADRAIN, 
                            self._original_terminal_settings)
    
    def get_keypress(self) -> str:
        """키 입력 감지 (단일 문자)"""
        if not self.terminal.is_interactive:
            return ''
        
        if sys.platform == 'win32':
            import msvcrt
            return msvcrt.getch().decode('utf-8', errors='ignore')
        else:
            return sys.stdin.read(1)
    
    def clear_screen(self):
        """화면 지우기"""
        if self.terminal.is_interactive:
            sys.stdout.write('\033[2J\033[H')
            sys.stdout.flush()
    
    def move_cursor(self, row: int, col: int):
        """커서 이동"""
        if self.terminal.is_interactive:
            sys.stdout.write(f'\033[{row};{col}H')
            sys.stdout.flush()
```

## 외부 명령 실행과 결과 처리

파이썬에서 외부 명령을 실행할 때는 보안, 안정성, 성능을 모두 고려해야 합니다. 다양한 실행 시나리오에 대응하는 완전한 솔루션을 제공합니다.

```python
import subprocess
import shlex
import threading
import queue
import time
from typing import Dict, List, Optional, Union, Any
from dataclasses import dataclass, field
from enum import Enum
import tempfile
import select
import sys
import signal

class ExecutionStrategy(Enum):
    """명령 실행 전략"""
    BLOCKING = "blocking"      # 동기 실행
    NONBLOCKING = "nonblocking" # 비동기 실행
    STREAMING = "streaming"    # 실시간 스트리밍
    TIMEOUT = "timeout"        # 타임아웃 제한 실행

@dataclass
class CommandResult:
    """명령 실행 결과"""
    returncode: int
    stdout: str
    stderr: str
    execution_time: float
    command: str
    pid: Optional[int] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def success(self) -> bool:
        """실행 성공 여부"""
        return self.returncode == 0
    
    def raise_for_status(self):
        """실패시 예외 발생"""
        if not self.success:
            raise subprocess.CalledProcessError(
                self.returncode, self.command, self.stdout, self.stderr
            )

class CommandExecutor:
    """고급 외부 명령 실행기"""
    
    def __init__(self, timeout: float = 30.0, 
                 encoding: str = 'utf-8',
                 shell: bool = False):
        """
        Args:
            timeout: 기본 실행 제한 시간(초)
            encoding: 출력 인코딩
            shell: 쉘 사용 여부 (보안 주의!)
        """
        self.timeout = timeout
        self.encoding = encoding
        self.shell = shell
        self._processes = {}  # PID -> process 매핑
        
    def execute(self, command: Union[str, List[str]],
                strategy: ExecutionStrategy = ExecutionStrategy.BLOCKING,
                **kwargs) -> CommandResult:
        """
        명령 실행
        
        Args:
            command: 실행할 명령
            strategy: 실행 전략
            
        Returns:
            CommandResult 객체
        """
        start_time = time.time()
        
        # 실행 방법 선택
        if strategy == ExecutionStrategy.BLOCKING:
            result = self._execute_blocking(command, **kwargs)
        elif strategy == ExecutionStrategy.NONBLOCKING:
            result = self._execute_nonblocking(command, **kwargs)
        elif strategy == ExecutionStrategy.STREAMING:
            result = self._execute_streaming(command, **kwargs)
        elif strategy == ExecutionStrategy.TIMEOUT:
            result = self._execute_with_timeout(command, **kwargs)
        else:
            raise ValueError(f"알 수 없는 실행 전략: {strategy}")
        
        result.execution_time = time.time() - start_time
        return result
    
    def _execute_blocking(self, command: Union[str, List[str]], 
                         capture_output: bool = True,
                         cwd: Optional[str] = None,
                         env: Optional[Dict] = None) -> CommandResult:
        """동기 실행"""
        try:
            # 명령어 준비
            if isinstance(command, str) and not self.shell:
                command = shlex.split(command)
            
            # 실행
            result = subprocess.run(
                command,
                shell=self.shell,
                capture_output=capture_output,
                timeout=self.timeout,
                cwd=cwd,
                env=env,
                encoding=self.encoding if capture_output else None
            )
            
            stdout = result.stdout.decode(self.encoding) if isinstance(result.stdout, bytes) else result.stdout
            stderr = result.stderr.decode(self.encoding) if isinstance(result.stderr, bytes) else result.stderr
            
            return CommandResult(
                returncode=result.returncode,
                stdout=stdout or '',
                stderr=stderr or '',
                execution_time=0,  # 상위에서 설정
                command=str(command),
                pid=result.pid
            )
            
        except subprocess.TimeoutExpired as e:
            return CommandResult(
                returncode=-1,
                stdout=e.stdout.decode(self.encoding) if e.stdout else '',
                stderr=e.stderr.decode(self.encoding) if e.stderr else '',
                execution_time=self.timeout,
                command=str(command),
                metadata={'timeout': True}
            )
        except FileNotFoundError as e:
            return CommandResult(
                returncode=-1,
                stdout='',
                stderr=f"명령을 찾을 수 없음: {e}",
                execution_time=0,
                command=str(command),
                metadata={'error': 'command_not_found'}
            )
    
    def _execute_with_timeout(self, command: Union[str, List[str]],
                             custom_timeout: Optional[float] = None,
                             **kwargs) -> CommandResult:
        """타임아웃 제한 실행"""
        timeout = custom_timeout or self.timeout
        
        # 타임아웃이 있는 블로킹 실행
        kwargs['timeout'] = timeout
        return self._execute_blocking(command, **kwargs)
    
    def _execute_nonblocking(self, command: Union[str, List[str]],
                           callback=None,
                           **kwargs) -> CommandResult:
        """비동기 실행 (백그라운드)"""
        # 명령어 준비
        if isinstance(command, str) and not self.shell:
            command = shlex.split(command)
        
        # 백그라운드 실행
        process = subprocess.Popen(
            command,
            shell=self.shell,
            stdout=subprocess.PIPE if kwargs.get('capture_output', True) else None,
            stderr=subprocess.PIPE if kwargs.get('capture_output', True) else None,
            cwd=kwargs.get('cwd'),
            env=kwargs.get('env')
        )
        
        # 프로세스 추적
        self._processes[process.pid] = process
        
        # 비동기 결과 처리 스레드
        def process_thread():
            stdout, stderr = process.communicate()
            
            result = CommandResult(
                returncode=process.returncode,
                stdout=stdout.decode(self.encoding) if stdout else '',
                stderr=stderr.decode(self.encoding) if stderr else '',
                execution_time=0,
                command=str(command),
                pid=process.pid
            )
            
            # 콜백 호출
            if callback:
                callback(result)
            
            # 프로세스 목록에서 제거
            self._processes.pop(process.pid, None)
        
        thread = threading.Thread(target=process_thread, daemon=True)
        thread.start()
        
        # 즉시 반환되는 결과 (실행중 상태)
        return CommandResult(
            returncode=None,
            stdout='',
            stderr='',
            execution_time=0,
            command=str(command),
            pid=process.pid,
            metadata={'status': 'running', 'process': process}
        )
    
    def _execute_streaming(self, command: Union[str, List[str]],
                          output_callback=None,
                          error_callback=None,
                          **kwargs) -> CommandResult:
        """실시간 스트리밍 실행"""
        if isinstance(command, str) and not self.shell:
            command = shlex.split(command)
        
        process = subprocess.Popen(
            command,
            shell=self.shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            cwd=kwargs.get('cwd'),
            env=kwargs.get('env'),
            bufsize=1,  # 라인 버퍼링
            universal_newlines=True
        )
        
        self._processes[process.pid] = process
        stdout_lines = []
        stderr_lines = []
        
        # 출력 스트리밍 스레드
        def stream_reader(stream, callback, storage):
            for line in iter(stream.readline, ''):
                line = line.rstrip('\n')
                storage.append(line)
                if callback:
                    callback(line)
            stream.close()
        
        # stdout 스트리밍
        stdout_thread = threading.Thread(
            target=stream_reader,
            args=(process.stdout, output_callback, stdout_lines),
            daemon=True
        )
        stdout_thread.start()
        
        # stderr 스트리밍
        stderr_thread = threading.Thread(
            target=stream_reader,
            args=(process.stderr, error_callback, stderr_lines),
            daemon=True
        )
        stderr_thread.start()
        
        # 완료 대기
        process.wait()
        stdout_thread.join(timeout=1.0)
        stderr_thread.join(timeout=1.0)
        
        self._processes.pop(process.pid, None)
        
        return CommandResult(
            returncode=process.returncode,
            stdout='\n'.join(stdout_lines),
            stderr='\n'.join(stderr_lines),
            execution_time=0,
            command=str(command),
            pid=process.pid
        )
    
    def execute_pipeline(self, commands: List[Union[str, List[str]]],
                        **kwargs) -> CommandResult:
        """파이프라인 명령 실행"""
        if not commands:
            raise ValueError("명령 목록이 비어있습니다")
        
        # 첫 번째 명령 실행
        if isinstance(commands[0], str):
            commands[0] = shlex.split(commands[0])
        
        # 파이프라인 구성
        processes = []
        prev_process = None
        
        for i, cmd in enumerate(commands):
            stdin = prev_process.stdout if prev_process else None
            
            # 마지막 명령은 stderr 캡처
            stderr = subprocess.PIPE if i == len(commands)-1 else subprocess.STDOUT
            
            process = subprocess.Popen(
                cmd,
                shell=False,
                stdin=stdin,
                stdout=subprocess.PIPE if i < len(commands)-1 else subprocess.PIPE,
                stderr=stderr,
                cwd=kwargs.get('cwd'),
                env=kwargs.get('env')
            )
            
            processes.append(process)
            
            # 이전 프로세스의 출력 닫기 (파이프 정리)
            if prev_process:
                prev_process.stdout.close()
            
            prev_process = process
        
        # 최종 결과 수집
        final_output, final_error = processes[-1].communicate()
        
        # 모든 프로세스 완료 대기
        for process in processes:
            process.wait()
        
        # 전체 반환 코드 (마지막 명령의 코드)
        return_code = processes[-1].returncode
        
        return CommandResult(
            returncode=return_code,
            stdout=final_output.decode(self.encoding) if final_output else '',
            stderr=final_error.decode(self.encoding) if final_error else '',
            execution_time=0,
            command=' | '.join(str(cmd) for cmd in commands),
            pid=processes[-1].pid
        )
    
    def kill_all(self):
        """실행중인 모든 프로세스 종료"""
        for pid, process in list(self._processes.items()):
            try:
                if process.poll() is None:  # 아직 실행중
                    process.terminate()
                    process.wait(timeout=5)
            except (subprocess.TimeoutExpired, OSError):
                try:
                    process.kill()
                except:
                    pass
        
        self._processes.clear()

# 실용적인 예시: 명령 실행 래퍼
class SafeCommandRunner:
    """안전한 명령 실행 래퍼"""
    
    @staticmethod
    def run_with_validation(command: Union[str, List[str]],
                           allowed_commands: List[str] = None,
                           **kwargs) -> CommandResult:
        """
        검증 후 명령 실행
        
        Args:
            command: 실행할 명령
            allowed_commands: 허용된 명령어 목록
        """
        # 명령 검증
        if allowed_commands:
            cmd_str = command if isinstance(command, str) else ' '.join(command)
            base_cmd = cmd_str.split()[0] if cmd_str else ''
            
            if base_cmd not in allowed_commands:
                raise SecurityError(f"허용되지 않은 명령: {base_cmd}")
        
        # 실행
        executor = CommandExecutor(**kwargs)
        return executor.execute(command, **kwargs)
    
    @staticmethod
    def run_with_retry(command: Union[str, List[str]],
                      max_retries: int = 3,
                      retry_delay: float = 1.0,
                      **kwargs) -> CommandResult:
        """재시도 로직이 포함된 명령 실행"""
        last_exception = None
        
        for attempt in range(max_retries):
            try:
                executor = CommandExecutor(**kwargs)
                result = executor.execute(command, **kwargs)
                
                if result.success:
                    return result
                else:
                    print(f"시도 {attempt + 1}/{max_retries} 실패: {result.stderr}")
                    
            except Exception as e:
                last_exception = e
                print(f"시도 {attempt + 1}/{max_retries} 예외: {e}")
            
            if attempt < max_retries - 1:
                time.sleep(retry_delay * (attempt + 1))  # 지수 백오프
        
        if last_exception:
            raise last_exception
        else:
            raise RuntimeError(f"{max_retries}번 재시도 후에도 명령 실패")
```

## 파일과 디렉터리 작업: 복사, 이동, 관리

파일 시스템 작업은 데이터 무결성과 안정성을 보장해야 합니다. 다양한 시나리오를 고려한 완전한 파일 관리 시스템을 구현합니다.

```python
import os
import shutil
import pathlib
import hashlib
import tempfile
import time
from typing import Union, List, Dict, Optional, Callable, Tuple
from dataclasses import dataclass, field
from enum import Enum
import fnmatch
import threading
import concurrent.futures

class FileOperation(Enum):
    """파일 작업 유형"""
    COPY = "copy"
    MOVE = "move"
    DELETE = "delete"
    SYNC = "sync"

@dataclass
class FileInfo:
    """파일 정보"""
    path: pathlib.Path
    size: int
    mtime: float
    mode: int
    checksum: Optional[str] = None
    
    def __post_init__(self):
        if self.checksum is None:
            self.checksum = self._calculate_checksum()
    
    def _calculate_checksum(self, chunk_size: int = 8192) -> str:
        """파일 체크섬 계산"""
        hash_md5 = hashlib.md5()
        try:
            with open(self.path, 'rb') as f:
                for chunk in iter(lambda: f.read(chunk_size), b''):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()
        except (OSError, IOError):
            return ""

class FileManager:
    """고급 파일 관리자"""
    
    def __init__(self, verbose: bool = False, dry_run: bool = False):
        self.verbose = verbose
        self.dry_run = dry_run
        self.operation_log = []
        self._lock = threading.RLock()
    
    def copy(self, src: Union[str, pathlib.Path],
             dst: Union[str, pathlib.Path],
             recursive: bool = False,
             preserve_metadata: bool = True,
             overwrite: bool = False,
             progress_callback: Optional[Callable] = None) -> bool:
        """
        파일/디렉터리 복사
        
        Args:
            src: 원본 경로
            dst: 대상 경로
            recursive: 하위 디렉터리 포함
            preserve_metadata: 메타데이터 보존
            overwrite: 덮어쓰기 허용
            progress_callback: 진행 상황 콜백
        """
        src_path = pathlib.Path(src)
        dst_path = pathlib.Path(dst)
        
        if not src_path.exists():
            self._log(f"원본 경로가 존재하지 않음: {src_path}")
            return False
        
        # 대상 경로 준비
        if src_path.is_file():
            return self._copy_file(src_path, dst_path, preserve_metadata, 
                                 overwrite, progress_callback)
        elif src_path.is_dir() and recursive:
            return self._copy_directory(src_path, dst_path, preserve_metadata,
                                      overwrite, progress_callback)
        else:
            self._log(f"디렉터리 복사는 recursive=True 필요")
            return False
    
    def _copy_file(self, src: pathlib.Path, dst: pathlib.Path,
                  preserve_metadata: bool, overwrite: bool,
                  progress_callback: Optional[Callable]) -> bool:
        """단일 파일 복사"""
        
        # 대상 경로 처리
        if dst.exists():
            if dst.is_dir():
                # 디렉터리 안에 같은 이름으로 복사
                dst = dst / src.name
            elif not overwrite:
                self._log(f"파일이 이미 존재하며 overwrite=False: {dst}")
                return False
        
        if self.dry_run:
            self._log(f"[DRY RUN] 복사: {src} -> {dst}")
            return True
        
        try:
            # 임시 파일로 복사 (원자적 연산)
            temp_dst = dst.with_suffix(dst.suffix + '.tmp')
            
            # 진행 상황 추적
            total_size = src.stat().st_size
            copied_size = 0
            
            # 청크 단위 복사 (대용량 파일 지원)
            with open(src, 'rb') as f_src, open(temp_dst, 'wb') as f_dst:
                chunk_size = 1024 * 1024  # 1MB 청크
                
                while True:
                    chunk = f_src.read(chunk_size)
                    if not chunk:
                        break
                    
                    f_dst.write(chunk)
                    copied_size += len(chunk)
                    
                    # 진행 상황 콜백
                    if progress_callback:
                        progress = (copied_size / total_size) * 100
                        progress_callback(progress, copied_size, total_size)
            
            # 메타데이터 복사
            if preserve_metadata:
                shutil.copystat(src, temp_dst)
            
            # 원자적 이동
            temp_dst.rename(dst)
            
            self._log(f"파일 복사 완료: {src} -> {dst} ({total_size:,} 바이트)")
            
            # 검증
            if self._verify_copy(src, dst):
                return True
            else:
                # 검증 실패 시 원복
                dst.unlink(missing_ok=True)
                return False
                
        except Exception as e:
            self._log(f"파일 복사 실패: {src} -> {dst}: {e}")
            # 임시 파일 정리
            temp_dst.unlink(missing_ok=True)
            return False
    
    def _copy_directory(self, src: pathlib.Path, dst: pathlib.Path,
                       preserve_metadata: bool, overwrite: bool,
                       progress_callback: Optional[Callable]) -> bool:
        """디렉터리 복사"""
        
        # 대상 디렉터리 생성
        if dst.exists():
            if not dst.is_dir():
                self._log(f"대상이 디렉터리가 아님: {dst}")
                return False
        else:
            if not self.dry_run:
                dst.mkdir(parents=True, exist_ok=True)
        
        # 파일 목록 수집
        all_files = []
        for root, dirs, files in os.walk(src):
            root_path = pathlib.Path(root)
            rel_path = root_path.relative_to(src)
            
            # 디렉터리 생성
            for dir_name in dirs:
                target_dir = dst / rel_path / dir_name
                if not self.dry_run:
                    target_dir.mkdir(parents=True, exist_ok=True)
            
            # 파일 복사 준비
            for file_name in files:
                src_file = root_path / file_name
                dst_file = dst / rel_path / file_name
                all_files.append((src_file, dst_file))
        
        # 병렬 복사
        success_count = 0
        total_files = len(all_files)
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
            # 각 파일 복사 작업 준비
            future_to_file = {}
            for src_file, dst_file in all_files:
                future = executor.submit(
                    self._copy_file, src_file, dst_file,
                    preserve_metadata, overwrite,
                    lambda p, c, t: self._update_progress(  # 진행 상황 통합
                        progress_callback, p, c, t, success_count, total_files
                    )
                )
                future_to_file[future] = (src_file, dst_file)
            
            # 결과 수집
            for future in concurrent.futures.as_completed(future_to_file):
                src_file, dst_file = future_to_file[future]
                try:
                    if future.result():
                        success_count += 1
                except Exception as e:
                    self._log(f"파일 복사 실패: {src_file}: {e}")
        
        # 메타데이터 복사
        if preserve_metadata and not self.dry_run:
            shutil.copystat(src, dst)
        
        success_rate = (success_count / total_files) * 100 if total_files > 0 else 100
        self._log(f"디렉터리 복사 완료: {src} -> {dst} "
                 f"({success_count}/{total_files} 파일, {success_rate:.1f}%)")
        
        return success_count == total_files
    
    def _update_progress(self, callback, progress, copied, total, 
                        file_index, total_files):
        """전체 진행 상황 업데이트"""
        if callback:
            # 파일별 진행률을 전체 진행률로 변환
            file_progress = (file_index / total_files) * 100
            current_progress = file_progress + (progress * (1 / total_files))
            callback(current_progress, copied, total)
    
    def move(self, src: Union[str, pathlib.Path],
             dst: Union[str, pathlib.Path],
             overwrite: bool = False) -> bool:
        """
        파일/디렉터리 이동
        
        Args:
            src: 원본 경로
            dst: 대상 경로
            overwrite: 덮어쓰기 허용
        """
        src_path = pathlib.Path(src)
        dst_path = pathlib.Path(dst)
        
        if not src_path.exists():
            self._log(f"원본 경로가 존재하지 않음: {src_path}")
            return False
        
        # 동일한 파일 시스템인지 확인
        try:
            src_dev = src_path.stat().st_dev
            dst_parent_dev = dst_path.parent.stat().st_dev
            same_filesystem = src_dev == dst_parent_dev
        except:
            same_filesystem = False
        
        if self.dry_run:
            action = "이동" if same_filesystem else "복사 후 삭제"
            self._log(f"[DRY RUN] {action}: {src} -> {dst}")
            return True
        
        try:
            if same_filesystem:
                # 같은 파일 시스템: 실제 이동
                if dst_path.exists():
                    if overwrite:
                        if dst_path.is_dir():
                            shutil.rmtree(dst_path)
                        else:
                            dst_path.unlink()
                    else:
                        self._log(f"대상이 이미 존재: {dst_path}")
                        return False
                
                shutil.move(str(src_path), str(dst_path))
                self._log(f"이동 완료: {src} -> {dst}")
            else:
                # 다른 파일 시스템: 복사 후 삭제
                if self.copy(src_path, dst_path, recursive=True, 
                           overwrite=overwrite):
                    if src_path.is_file():
                        src_path.unlink()
                    elif src_path.is_dir():
                        shutil.rmtree(src_path)
                    self._log(f"복사 후 삭제 완료: {src} -> {dst}")
                    return True
                else:
                    return False
            
            return True
            
        except Exception as e:
            self._log(f"이동 실패: {src} -> {dst}: {e}")
            return False
    
    def sync_directories(self, source: Union[str, pathlib.Path],
                         target: Union[str, pathlib.Path],
                         delete_extra: bool = False,
                         exclude_patterns: List[str] = None) -> Dict[str, int]:
        """
        디렉터리 동기화
        
        Args:
            source: 원본 디렉터리
            target: 대상 디렉터리
            delete_extra: 대상에만 있는 파일 삭제
            exclude_patterns: 제외할 패턴 목록
        """
        source_path = pathlib.Path(source)
        target_path = pathlib.Path(target)
        
        if not source_path.is_dir():
            raise ValueError(f"원본이 디렉터리가 아님: {source}")
        
        # 대상 디렉터리 생성
        if not self.dry_run:
            target_path.mkdir(parents=True, exist_ok=True)
        
        stats = {
            'copied': 0,
            'updated': 0,
            'deleted': 0,
            'skipped': 0
        }
        
        # 원본 파일 정보 수집
        source_files = {}
        for root, dirs, files in os.walk(source_path):
            root_path = pathlib.Path(root)
            rel_path = root_path.relative_to(source_path)
            
            # 제외 패턴 적용
            if exclude_patterns:
                dirs[:] = [d for d in dirs if not self._matches_patterns(d, exclude_patterns)]
                files = [f for f in files if not self._matches_patterns(f, exclude_patterns)]
            
            # 디렉터리 생성
            for dir_name in dirs:
                target_dir = target_path / rel_path / dir_name
                if not self.dry_run:
                    target_dir.mkdir(parents=True, exist_ok=True)
            
            # 파일 정보 저장
            for file_name in files:
                src_file = root_path / file_name
                tgt_file = target_path / rel_path / file_name
                
                source_info = FileInfo(
                    path=src_file,
                    size=src_file.stat().st_size,
                    mtime=src_file.stat().st_mtime,
                    mode=src_file.stat().st_mode
                )
                source_files[tgt_file] = source_info
        
        # 대상 파일 검사 및 동기화
        for target_file, source_info in source_files.items():
            if not target_file.exists():
                # 새 파일 복사
                if self.copy(source_info.path, target_file, overwrite=True):
                    stats['copied'] += 1
            else:
                # 파일 비교
                target_info = FileInfo(
                    path=target_file,
                    size=target_file.stat().st_size,
                    mtime=target_file.stat().st_mtime,
                    mode=target_file.stat().st_mode
                )
                
                # 변경 여부 확인 (크기, 수정시간, 체크섬)
                if (source_info.size != target_info.size or
                    source_info.mtime > target_info.mtime or
                    source_info.checksum != target_info.checksum):
                    
                    if self.copy(source_info.path, target_file, overwrite=True):
                        stats['updated'] += 1
                else:
                    stats['skipped'] += 1
        
        # 대상에만 있는 파일 삭제
        if delete_extra:
            for root, dirs, files in os.walk(target_path):
                root_path = pathlib.Path(root)
                rel_path = root_path.relative_to(target_path)
                src_root = source_path / rel_path
                
                for file_name in files:
                    tgt_file = root_path / file_name
                    src_file = src_root / file_name
                    
                    if not src_file.exists():
                        if not self.dry_run:
                            tgt_file.unlink()
                        stats['deleted'] += 1
        
        self._log(f"동기화 완료: {source} -> {target}")
        self._log(f"통계: {stats}")
        
        return stats
    
    def _matches_patterns(self, name: str, patterns: List[str]) -> bool:
        """패턴 매칭 확인"""
        for pattern in patterns:
            if fnmatch.fnmatch(name, pattern):
                return True
        return False
    
    def _verify_copy(self, src: pathlib.Path, dst: pathlib.Path) -> bool:
        """복사 검증"""
        try:
            src_info = FileInfo(
                path=src,
                size=src.stat().st_size,
                mtime=src.stat().st_mtime,
                mode=src.stat().st_mode
            )
            
            dst_info = FileInfo(
                path=dst,
                size=dst.stat().st_size,
                mtime=dst.stat().st_mtime,
                mode=dst.stat().st_mode
            )
            
            return (src_info.size == dst_info.size and
                   src_info.checksum == dst_info.checksum)
        except:
            return False
    
    def _log(self, message: str):
        """작업 로깅"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {message}"
        
        with self._lock:
            self.operation_log.append(log_entry)
        
        if self.verbose:
            print(log_entry)

class BackupManager(FileManager):
    """백업 관리자"""
    
    def create_backup(self, source: Union[str, pathlib.Path],
                      backup_dir: Union[str, pathlib.Path],
                      backup_name: str = None,
                      compression: bool = False) -> pathlib.Path:
        """
        백업 생성
        
        Args:
            source: 백업할 경로
            backup_dir: 백업 디렉터리
            backup_name: 백업 이름 (기본값: timestamp)
            compression: 압축 사용 여부
        """
        source_path = pathlib.Path(source)
        backup_path = pathlib.Path(backup_dir)
        
        if not backup_name:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            backup_name = f"backup_{source_path.name}_{timestamp}"
        
        # 백업 경로 생성
        if compression:
            backup_dst = backup_path / f"{backup_name}.tar.gz"
        else:
            backup_dst = backup_path / backup_name
        
        if not self.dry_run:
            backup_path.mkdir(parents=True, exist_ok=True)
        
        if compression:
            # 압축 백업
            success = self._create_compressed_backup(source_path, backup_dst)
        else:
            # 일반 복사
            success = self.copy(source_path, backup_dst, recursive=True, 
                              preserve_metadata=True, overwrite=False)
        
        if success:
            self._log(f"백업 생성 완료: {source} -> {backup_dst}")
            return backup_dst
        else:
            raise RuntimeError(f"백업 생성 실패: {source}")
    
    def _create_compressed_backup(self, source: pathlib.Path, 
                                target: pathlib.Path) -> bool:
        """압축 백업 생성"""
        import tarfile
        
        try:
            with tarfile.open(target, 'w:gz') as tar:
                tar.add(source, arcname=source.name)
            return True
        except Exception as e:
            self._log(f"압축 백업 생성 실패: {source} -> {target}: {e}")
            return False
```

## 압축 파일 다루기: 생성, 추출, 관리

압축 파일 처리는 효율적인 저장 공간 활용과 데이터 전송에 필수적입니다. 다양한 포맷과 시나리오를 지원하는 완전한 압축 관리 시스템을 구현합니다.

```python
import zipfile
import tarfile
import gzip
import bz2
import lzma
import rarfile  # pip install rarfile 필요
import py7zr    # pip install py7zr 필요
from typing import Union, List, Dict, Optional, BinaryIO
from pathlib import Path
import io
import shutil
import tempfile
import contextlib
from enum import Enum

class CompressionFormat(Enum):
    """압축 포맷"""
    ZIP = "zip"
    TAR_GZ = "tar.gz"
    TAR_BZ2 = "tar.bz2"
    TAR_XZ = "tar.xz"
    GZIP = "gz"
    BZ2 = "bz2"
    XZ = "xz"
    RAR = "rar"
    SEVENZIP = "7z"

class ArchiveManager:
    """압축 파일 관리자"""
    
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.supported_formats = {
            '.zip': self._handle_zip,
            '.tar.gz': self._handle_tar_gz,
            '.tgz': self._handle_tar_gz,
            '.tar.bz2': self._handle_tar_bz2,
            '.tbz2': self._handle_tar_bz2,
            '.tar.xz': self._handle_tar_xz,
            '.txz': self._handle_tar_xz,
            '.gz': self._handle_gzip,
            '.bz2': self._handle_bzip2,
            '.xz': self._handle_lzma,
            '.rar': self._handle_rar,
            '.7z': self._handle_7zip
        }
    
    def detect_format(self, filepath: Union[str, Path]) -> Optional[CompressionFormat]:
        """파일 형식 감지"""
        path = Path(filepath)
        suffix = path.suffix.lower()
        
        # 다중 확장자 체크
        suffixes = ''.join(path.suffixes).lower()
        
        format_map = {
            '.zip': CompressionFormat.ZIP,
            '.tar.gz': CompressionFormat.TAR_GZ,
            '.tgz': CompressionFormat.TAR_GZ,
            '.tar.bz2': CompressionFormat.TAR_BZ2,
            '.tbz2': CompressionFormat.TAR_BZ2,
            '.tar.xz': CompressionFormat.TAR_XZ,
            '.txz': CompressionFormat.TAR_XZ,
            '.gz': CompressionFormat.GZIP,
            '.bz2': CompressionFormat.BZ2,
            '.xz': CompressionFormat.XZ,
            '.rar': CompressionFormat.RAR,
            '.7z': CompressionFormat.SEVENZIP
        }
        
        # 다중 확장자 먼저 체크
        for ext in [suffixes, suffix]:
            if ext in format_map:
                return format_map[ext]
        
        return None
    
    def compress(self, source: Union[str, Path, List[Union[str, Path]]],
                 target: Union[str, Path],
                 format: CompressionFormat = CompressionFormat.ZIP,
                 compression_level: int = 6,
                 **kwargs) -> bool:
        """
        파일/디렉터리 압축
        
        Args:
            source: 압축할 경로(들)
            target: 대상 압축 파일
            format: 압축 포맷
            compression_level: 압축 수준 (1-9)
        """
        source_paths = []
        if isinstance(source, (str, Path)):
            source_paths.append(Path(source))
        else:
            source_paths = [Path(p) for p in source]
        
        target_path = Path(target)
        
        # 소스 검증
        for src in source_paths:
            if not src.exists():
                raise FileNotFoundError(f"소스 파일이 존재하지 않음: {src}")
        
        # 처리기 선택
        handler = self._get_compression_handler(format)
        if not handler:
            raise ValueError(f"지원되지 않는 포맷: {format}")
        
        try:
            return handler(source_paths, target_path, compression_level, **kwargs)
        except Exception as e:
            if self.verbose:
                print(f"압축 실패: {e}")
            return False
    
    def extract(self, archive: Union[str, Path],
                target_dir: Union[str, Path] = None,
                members: List[str] = None,
                password: Optional[str] = None) -> bool:
        """
        압축 파일 해제
        
        Args:
            archive: 압축 파일
            target_dir: 대상 디렉터리 (기본값: 현재 디렉터리)
            members: 해제할 멤버 목록 (전체 해제 시 None)
            password: 암호 (필요한 경우)
        """
        archive_path = Path(archive)
        
        if not archive_path.exists():
            raise FileNotFoundError(f"압축 파일이 존재하지 않음: {archive_path}")
        
        # 대상 디렉터리 설정
        if target_dir is None:
            target_dir = Path.cwd()
        else:
            target_dir = Path(target_dir)
            target_dir.mkdir(parents=True, exist_ok=True)
        
        # 포맷 감지
        format_type = self.detect_format(archive_path)
        if not format_type:
            raise ValueError(f"지원되지 않는 압축 포맷: {archive_path}")
        
        # 처리기 선택
        extractor = self._get_extraction_handler(format_type)
        if not extractor:
            raise ValueError(f"해제를 지원하지 않는 포맷: {format_type}")
        
        try:
            return extractor(archive_path, target_dir, members, password)
        except Exception as e:
            if self.verbose:
                print(f"해제 실패: {e}")
            return False
    
    def list_contents(self, archive: Union[str, Path]) -> List[Dict]:
        """압축 파일 내용 목록"""
        archive_path = Path(archive)
        format_type = self.detect_format(archive_path)
        
        if not format_type:
            raise ValueError(f"지원되지 않는 압축 포맷: {archive_path}")
        
        handler = self._get_listing_handler(format_type)
        if not handler:
            raise ValueError(f"목록 조회를 지원하지 않는 포맷: {format_type}")
        
        return handler(archive_path)
    
    def _get_compression_handler(self, format: CompressionFormat):
        """압축 처리기 선택"""
        handlers = {
            CompressionFormat.ZIP: self._compress_zip,
            CompressionFormat.TAR_GZ: self._compress_tar_gz,
            CompressionFormat.TAR_BZ2: self._compress_tar_bz2,
            CompressionFormat.TAR_XZ: self._compress_tar_xz,
            CompressionFormat.GZIP: self._compress_gzip,
            CompressionFormat.BZ2: self._compress_bzip2,
            CompressionFormat.XZ: self._compress_lzma,
            CompressionFormat.RAR: self._compress_rar,
            CompressionFormat.SEVENZIP: self._compress_7zip
        }
        return handlers.get(format)
    
    def _get_extraction_handler(self, format: CompressionFormat):
        """해제 처리기 선택"""
        handlers = {
            CompressionFormat.ZIP: self._extract_zip,
            CompressionFormat.TAR_GZ: self._extract_tar,
            CompressionFormat.TAR_BZ2: self._extract_tar,
            CompressionFormat.TAR_XZ: self._extract_tar,
            CompressionFormat.GZIP: self._extract_gzip,
            CompressionFormat.BZ2: self._extract_bzip2,
            CompressionFormat.XZ: self._extract_lzma,
            CompressionFormat.RAR: self._extract_rar,
            CompressionFormat.SEVENZIP: self._extract_7zip
        }
        return handlers.get(format)
    
    def _get_listing_handler(self, format: CompressionFormat):
        """목록 조회 처리기 선택"""
        handlers = {
            CompressionFormat.ZIP: self._list_zip,
            CompressionFormat.TAR_GZ: self._list_tar,
            CompressionFormat.TAR_BZ2: self._list_tar,
            CompressionFormat.TAR_XZ: self._list_tar,
            CompressionFormat.GZIP: self._list_gzip,
            CompressionFormat.BZ2: self._list_bzip2,
            CompressionFormat.XZ: self._list_lzma,
            CompressionFormat.RAR: self._list_rar,
            CompressionFormat.SEVENZIP: self._list_7zip
        }
        return handlers.get(format)
    
    # ZIP 처리
    def _compress_zip(self, sources: List[Path], target: Path, 
                     compression_level: int, **kwargs) -> bool:
        """ZIP 압축"""
        try:
            with zipfile.ZipFile(target, 'w', 
                               zipfile.ZIP_DEFLATED,
                               compresslevel=compression_level) as zipf:
                for source in sources:
                    if source.is_file():
                        zipf.write(source, source.name)
                    elif source.is_dir():
                        for file_path in source.rglob('*'):
                            if file_path.is_file():
                                arcname = file_path.relative_to(source.parent)
                                zipf.write(file_path, arcname)
            
            if self.verbose:
                print(f"ZIP 압축 완료: {target}")
            return True
        except Exception as e:
            if self.verbose:
                print(f"ZIP 압축 실패: {e}")
            return False
    
    def _extract_zip(self, archive: Path, target_dir: Path,
                    members: List[str], password: Optional[str]) -> bool:
        """ZIP 해제"""
        try:
            with zipfile.ZipFile(archive, 'r') as zipf:
                if password:
                    zipf.setpassword(password.encode('utf-8'))
                
                if members:
                    zipf.extractall(target_dir, members=members)
                else:
                    zipf.extractall(target_dir)
            
            if self.verbose:
                print(f"ZIP 해제 완료: {archive} -> {target_dir}")
            return True
        except Exception as e:
            if self.verbose:
                print(f"ZIP 해제 실패: {e}")
            return False
    
    def _list_zip(self, archive: Path) -> List[Dict]:
        """ZIP 내용 목록"""
        try:
            with zipfile.ZipFile(archive, 'r') as zipf:
                contents = []
                for info in zipf.infolist():
                    contents.append({
                        'filename': info.filename,
                        'file_size': info.file_size,
                        'compress_size': info.compress_size,
                        'compress_ratio': (1 - info.compress_size/info.file_size) * 100 
                                          if info.file_size > 0 else 0,
                        'date_time': info.date_time,
                        'is_dir': info.filename.endswith('/')
                    })
                return contents
        except Exception as e:
            if self.verbose:
                print(f"ZIP 목록 조회 실패: {e}")
            return []
    
    # TAR 처리 (GZ, BZ2, XZ)
    def _compress_tar_gz(self, sources: List[Path], target: Path,
                        compression_level: int, **kwargs) -> bool:
        """TAR.GZ 압축"""
        return self._compress_tar(sources, target, 'w:gz', compression_level)
    
    def _compress_tar_bz2(self, sources: List[Path], target: Path,
                         compression_level: int, **kwargs) -> bool:
        """TAR.BZ2 압축"""
        return self._compress_tar(sources, target, 'w:bz2', compression_level)
    
    def _compress_tar_xz(self, sources: List[Path], target: Path,
                        compression_level: int, **kwargs) -> bool:
        """TAR.XZ 압축"""
        return self._compress_tar(sources, target, 'w:xz', compression_level)
    
    def _compress_tar(self, sources: List[Path], target: Path,
                     mode: str, compression_level: int) -> bool:
        """TAR 압축 (공통)"""
        try:
            with tarfile.open(target, mode) as tar:
                for source in sources:
                    if source.is_file():
                        tar.add(source, arcname=source.name)
                    elif source.is_dir():
                        tar.add(source, arcname=source.name)
            
            if self.verbose:
                print(f"TAR 압축 완료: {target}")
            return True
        except Exception as e:
            if self.verbose:
                print(f"TAR 압축 실패: {e}")
            return False
    
    def _extract_tar(self, archive: Path, target_dir: Path,
                    members: List[str], password: Optional[str]) -> bool:
        """TAR 해제"""
        try:
            mode = 'r'
            if archive.suffix in ['.gz', '.tgz']:
                mode = 'r:gz'
            elif archive.suffix in ['.bz2', '.tbz2']:
                mode = 'r:bz2'
            elif archive.suffix in ['.xz', '.txz']:
                mode = 'r:xz'
            
            with tarfile.open(archive, mode) as tar:
                if members:
                    tar.extractall(target_dir, members=members)
                else:
                    tar.extractall(target_dir)
            
            if self.verbose:
                print(f"TAR 해제 완료: {archive} -> {target_dir}")
            return True
        except Exception as e:
            if self.verbose:
                print(f"TAR 해제 실패: {e}")
            return False
    
    def _list_tar(self, archive: Path) -> List[Dict]:
        """TAR 내용 목록"""
        try:
            mode = 'r'
            if archive.suffix in ['.gz', '.tgz']:
                mode = 'r:gz'
            elif archive.suffix in ['.bz2', '.tbz2']:
                mode = 'r:bz2'
            elif archive.suffix in ['.xz', '.txz']:
                mode = 'r:xz'
            
            with tarfile.open(archive, mode) as tar:
                contents = []
                for member in tar.getmembers():
                    contents.append({
                        'filename': member.name,
                        'file_size': member.size,
                        'mtime': member.mtime,
                        'is_dir': member.isdir(),
                        'is_file': member.isfile(),
                        'is_link': member.issym() or member.islnk()
                    })
                return contents
        except Exception as e:
            if self.verbose:
                print(f"TAR 목록 조회 실패: {e}")
            return []
    
    # 단일 파일 압축 (GZIP, BZIP2, LZMA)
    def _compress_gzip(self, sources: List[Path], target: Path,
                      compression_level: int, **kwargs) -> bool:
        """GZIP 압축"""
        if len(sources) > 1:
            raise ValueError("GZIP은 단일 파일만 압축 가능")
        
        source = sources[0]
        if not source.is_file():
            raise ValueError("GZIP은 파일만 압축 가능")
        
        try:
            with open(source, 'rb') as f_in:
                with gzip.open(target, 'wb', compresslevel=compression_level) as f_out:
                    shutil.copyfileobj(f_in, f_out)
            
            if self.verbose:
                print(f"GZIP 압축 완료: {source} -> {target}")
            return True
        except Exception as e:
            if self.verbose:
                print(f"GZIP 압축 실패: {e}")
            return False
    
    def _extract_gzip(self, archive: Path, target_dir: Path,
                     members: List[str], password: Optional[str]) -> bool:
        """GZIP 해제"""
        try:
            # 원본 파일명 추정 (.gz 제외)
            original_name = archive.stem
            target_file = target_dir / original_name
            
            with gzip.open(archive, 'rb') as f_in:
                with open(target_file, 'wb') as f_out:
                    shutil.copyfileobj(f_in, f_out)
            
            if self.verbose:
                print(f"GZIP 해제 완료: {archive} -> {target_file}")
            return True
        except Exception as e:
            if self.verbose:
                print(f"GZIP 해제 실패: {e}")
            return False
    
    # BZIP2와 LZMA는 GZIP과 유사한 패턴으로 구현
    # RAR과 7-Zip은 외부 라이브러리 필요
    
    def _handle_rar(self, *args, **kwargs):
        """RAR 처리 (rarfile 라이브러리 필요)"""
        try:
            import rarfile
            # RAR 처리 구현
            pass
        except ImportError:
            if self.verbose:
                print("RAR 지원을 위해 'pip install rarfile' 필요")
            return False
    
    def _handle_7zip(self, *args, **kwargs):
        """7-Zip 처리 (py7zr 라이브러리 필요)"""
        try:
            import py7zr
            # 7-Zip 처리 구현
            pass
        except ImportError:
            if self.verbose:
                print("7-Zip 지원을 위해 'pip install py7zr' 필요")
            return False

class SmartCompressor(ArchiveManager):
    """지능형 압축 관리자"""
    
    def auto_compress(self, source: Union[str, Path, List[Union[str, Path]]],
                      format: Optional[CompressionFormat] = None,
                      target_dir: Optional[Union[str, Path]] = None) -> Path:
        """
        자동 압축 (포맷 자동 선택)
        
        Args:
            source: 압축할 경로
            format: 명시적 포맷 (None이면 자동 선택)
            target_dir: 대상 디렉터리
        """
        if isinstance(source, (str, Path)):
            source = Path(source)
            is_single_file = source.is_file()
        else:
            # 여러 파일인 경우
            is_single_file = False
        
        # 포맷 자동 선택
        if format is None:
            if is_single_file:
                # 단일 파일: GZIP 권장
                format = CompressionFormat.GZIP
            else:
                # 여러 파일/디렉터리: ZIP 권장
                format = CompressionFormat.ZIP
        
        # 대상 경로 결정
        if target_dir is None:
            target_dir = Path.cwd()
        
        target_dir = Path(target_dir)
        target_dir.mkdir(parents=True, exist_ok=True)
        
        # 파일명 생성
        if isinstance(source, Path):
            base_name = source.stem if is_single_file else source.name
        else:
            base_name = f"archive_{int(time.time())}"
        
        extensions = {
            CompressionFormat.ZIP: '.zip',
            CompressionFormat.TAR_GZ: '.tar.gz',
            CompressionFormat.TAR_BZ2: '.tar.bz2',
            CompressionFormat.TAR_XZ: '.tar.xz',
            CompressionFormat.GZIP: '.gz',
            CompressionFormat.BZ2: '.bz2',
            CompressionFormat.XZ: '.xz'
        }
        
        ext = extensions.get(format, '.zip')
        target = target_dir / f"{base_name}{ext}"
        
        # 압축 실행
        if self.compress(source, target, format):
            return target
        else:
            raise RuntimeError(f"자동 압축 실패: {source}")
    
    def compare_formats(self, source: Union[str, Path],
                       formats: List[CompressionFormat] = None) -> Dict:
        """
        압축 포맷별 성능 비교
        
        Returns:
            각 포맷별 크기, 압축 시간, 압축률 정보
        """
        if formats is None:
            formats = [
                CompressionFormat.ZIP,
                CompressionFormat.TAR_GZ,
                CompressionFormat.TAR_BZ2,
                CompressionFormat.TAR_XZ,
                CompressionFormat.GZIP
            ]
        
        results = {}
        source_path = Path(source)
        
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            for format in formats:
                try:
                    target = tmpdir / f"test{self._get_extension(format)}"
                    
                    # 압축 시간 측정
                    start_time = time.time()
                    success = self.compress(source_path, target, format)
                    compress_time = time.time() - start_time
                    
                    if success and target.exists():
                        original_size = self._get_size(source_path)
                        compressed_size = target.stat().st_size
                        ratio = (1 - compressed_size/original_size) * 100
                        
                        results[format.value] = {
                            'original_size': original_size,
                            'compressed_size': compressed_size,
                            'compression_ratio': ratio,
                            'compress_time': compress_time,
                            'success': True
                        }
                    else:
                        results[format.value] = {
                            'success': False,
                            'error': '압축 실패'
                        }
                        
                except Exception as e:
                    results[format.value] = {
                        'success': False,
                        'error': str(e)
                    }
        
        return results
    
    def _get_extension(self, format: CompressionFormat) -> str:
        """포맷별 확장자"""
        extensions = {
            CompressionFormat.ZIP: '.zip',
            CompressionFormat.TAR_GZ: '.tar.gz',
            CompressionFormat.TAR_BZ2: '.tar.bz2',
            CompressionFormat.TAR_XZ: '.tar.xz',
            CompressionFormat.GZIP: '.gz',
            CompressionFormat.BZ2: '.bz2',
            CompressionFormat.XZ: '.xz',
            CompressionFormat.RAR: '.rar',
            CompressionFormat.SEVENZIP: '.7z'
        }
        return extensions.get(format, '')
    
    def _get_size(self, path: Path) -> int:
        """경로 크기 계산 (재귀적)"""
        if path.is_file():
            return path.stat().st_size
        elif path.is_dir():
            total = 0
            for item in path.rglob('*'):
                if item.is_file():
                    total += item.stat().st_size
            return total
        return 0
```

## 결론

### 터미널 프로그래밍의 핵심 원칙
1. **크기 감지와 적응형 UI**: 터미널 크기를 동적으로 감지하고 콘텐츠를 조정해야 합니다. 캐싱과 효율적인 폴링 전략으로 성능을 최적화하세요.
2. **크로스 플랫폼 호환성**: Windows, Linux, macOS 등 다양한 운영체제를 지원하려면 플랫폼별 차이를 이해하고 적절히 처리해야 합니다.
3. **사용자 경험 개선**: 색상 지원 감지, 키보드 입력 처리, 진행 표시줄 등을 통해 전문적인 사용자 경험을 제공하세요.

### 외부 명령 실행의 모범 사례
1. **보안 우선**: 사용자 입력을 통한 명령 실행은 반드시 검증하고, shell=True 사용을 최소화하세요. 허용 목록(allowlist) 방식을 채택하세요.
2. **강건한 오류 처리**: 타임아웃, 메모리 부족, 프로세스 종료 등 다양한 실패 시나리오를 고려한 오류 처리 로직을 구현하세요.
3. **실시간 피드백**: 장시간 실행되는 명령에 대해 진행 상황 피드백을 제공하고, 실시간 출력 스트리밍을 지원하세요.
4. **자원 관리**: 실행 중인 프로세스를 추적하고, 애플리케이션 종료 시 적절히 정리하는 메커니즘을 마련하세요.

### 파일 작업의 무결성 보장
1. **원자적 연산**: 파일 복사/이동 시 임시 파일을 사용한 원자적 연산 패턴을 적용하여 부분적 실패를 방지하세요.
2. **검증 메커니즘**: 복사 후 체크섬 비교나 크기 검증을 통해 데이터 무결성을 보장하세요.
3. **진행 상황 보고**: 대용량 파일이나 많은 수의 파일 처리 시 사용자에게 진행 상황을 투명하게 보고하세요.
4. **병렬 처리**: 다중 코어 시스템에서 파일 작업을 병렬화하여 성능을 향상시키세요.

### 압축 관리의 전략적 접근
1. **용도별 포맷 선택**:
   - **ZIP**: 범용적 호환성, 암호화 지원
   - **TAR.GZ**: Unix/Linux 환경, 보존 속성 유지
   - **7Z**: 높은 압축률, 대용량 파일
   - **단일 파일 압축**: GZIP, BZIP2, LZMA
2. **메모리 효율성**: 대용량 압축 작업 시 청크 단위 처리와 스트리밍을 활용하여 메모리 사용을 최적화하세요.
3. **포맷 감지와 자동 처리**: 파일 확장자와 매직 넘버를 통해 압축 포맷을 자동 감지하고 적절한 처리기를 선택하세요.
4. **포괄적 오류 처리**: 암호화된 아카이브, 손상된 파일, 지원되지 않는 포맷 등 다양한 예외 상황을 처리하세요.

### 통합 운영 전략
1. **통합 로깅**: 모든 시스템 작업에 일관된 로깅 메커니즘을 적용하여 문제 진단과 감사를 용이하게 하세요.
2. **Dry-run 모드**: 실제 변경 전 예상되는 작업을 시뮬레이션할 수 있는 기능을 제공하세요.
3. **구성 가능성**: 시간 초과, 재시도 횟수, 병렬도 등 운영 파라미터를 외부에서 구성할 수 있게 설계하세요.
4. **모니터링과 메트릭**: 작업 성공률, 실행 시간, 처리량 등의 메트릭을 수집하여 시스템 건강 상태를 모니터링하세요.

이러한 원칙들을 준수하면 안정적이고 효율적이며 사용자 친화적인 시스템 도구와 애플리케이션을 개발할 수 있습니다. 실제 운영 환경에서는 이러한 기법들을 조합하여 특정 요구사항에 최적화된 솔루션을 구축해야 합니다.