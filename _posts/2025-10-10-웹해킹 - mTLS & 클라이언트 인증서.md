---
layout: post
title: 웹해킹 - mTLS & 클라이언트 인증서
date: 2025-10-10 23:25:23 +0900
category: 웹해킹
---
# mTLS(서비스 간) & 클라이언트 인증서

**— 설계 철학 · X.509/PKI 기초 · 핸드셰이크 흐름 · 서버/클라이언트 코드 샘플(Go/Node/Spring/Envoy/Nginx/K8s/HAProxy/gRPC) · 운영(발급/회전/폐기/감사) · 트러블슈팅 · SSRF 저감 아키텍처**

> ⚑ 목적
> 서비스-투-서비스 트래픽을 **TLS 계층에서 상호 인증(mTLS)** 하여, ① “**누가** 상대인가”를 증명하고, ② **권한 없는 호출**을 **연결 이전**에 차단합니다. 결과적으로 **SSRF**·자격 증명 탈취·스푸핑에 대한 피해 반경을 크게 줄일 수 있습니다.

---

## 용어·개념 빠르게 잡기

- **TLS vs mTLS**
  - *TLS(단방향)*: **서버만** 인증서로 증명, 클라이언트는 신뢰 저장소로 **서버 인증서** 검증.
  - *mTLS(양방향)*: **서버와 클라이언트 모두** 인증서를 제시·검증 → **상호 신원 확인**.
- **X.509 인증서**: 공개키·유효기간·주체(SAN)·발급자(이전 CA)의 서명이 들어있는 구조화된 문서(PEM/DER).
- **PKI 체계**: Root CA → Intermediate CA → 엔티티(서버/클라이언트) Cert. **체인(trust chain)** 검증.
- **SAN (Subject Alternative Name)**: 도메인/URI/스파이피(SPIFFE) 등 **아이덴티티의 표준 장소**. CN보다 SAN 우선.
- **CRL/OCSP**: 인증서 폐기 목록/온라인 상태 확인. **내부 PKI**에서는 **짧은 수명(예: 24h)** 로 대체하는 추세.

---

## 위협 모델과 mTLS의 효과

### 막는 것

- **자격 증명 탈취/리플레이**: 토큰/쿠키 탈취만으로는 통과 불가(클라이언트 키·증명서 **보유** 필요).
- **SSRF**: 애플리케이션이 내부로 임의 요청을 날려도, **mTLS 게이트**에서 **미등록 아이덴티티**는 차단.
- **스푸핑/중간자**: TLS 자체의 암호화·무결성과 **상호** 인증으로 **엔드포인트 위장** 차단.

### 한계(남는 위험)

- **권한 부여(Authorization)** 는 **별도**입니다. mTLS는 “너 누구냐(인증)”까지만.
- **키 유출/호스트 탈취** 시에는 mTLS도 뚫립니다 → **HSM/TPM·권한 분리**·짧은 수명·자동 회전이 필요.

---

## mTLS 핸드셰이크 한 장 요약

1) ClientHello(암호 스위트·SNI) →
2) ServerHello(+서버 인증서 체인 전송) → **클라가 서버 인증서 검증**(CA/체인/SAN/유효기간) →
3) **서버가 클라이언트 인증서 요구** → 클라가 **클라이언트 인증서 + 증명** 제시 → **서버가 검증** →
4) 키 합의 완료 후 **암호화 채널** 수립.

> **검증 포인트**: 체인 연결, 신뢰 CA, SAN 매칭, 만료·NotBefore, 폐기, 사용 용도(KeyUsage/ExtKeyUsage).

---

## 데모: 내부 CA로 실습용 인증서 발급

> 프로덕션은 **전용 내부 CA(예: Cloud CA/HashiCorp Vault/`step-ca`/SPIRE)** 권장. 아래는 학습/스테이징용.

```bash
# Root CA (데모용)

openssl genrsa -out rootCA.key 4096
openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 3650 \
  -subj "/CN=corp-root" -out rootCA.crt

# 서버 키/CSR (SAN: DNS=api.internal)

openssl genrsa -out server.key 2048
cat > server.cnf <<'EOF'
[ req ]
default_bits = 2048
prompt = no
default_md = sha256
req_extensions = v3_req
distinguished_name = dn
[ dn ]
CN = api.internal
[ v3_req ]
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[ alt_names ]
DNS.1 = api.internal
EOF
openssl req -new -key server.key -out server.csr -config server.cnf

# 클라이언트 키/CSR (SAN: URI=spiffe://svc/payment)

openssl genrsa -out client.key 2048
cat > client.cnf <<'EOF'
[ req ]
default_bits = 2048
prompt = no
default_md = sha256
req_extensions = v3_req
distinguished_name = dn
[ dn ]
CN = payment-svc
[ v3_req ]
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth
subjectAltName = @alt_names
[ alt_names ]
URI.1 = spiffe://svc/payment
EOF
openssl req -new -key client.key -out client.csr -config client.cnf

# CA로 서명

openssl x509 -req -in server.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial \
  -out server.crt -days 365 -sha256 -extensions v3_req -extfile server.cnf

openssl x509 -req -in client.csr -CA rootCA.crt -CAkey rootCA.key \
  -out client.crt -days 180 -sha256 -extensions v3_req -extfile client.cnf

# 체인 번들 (필요 시)

cat server.crt > server-fullchain.crt
# (intermediate가 있다면 cat server.crt > server-fullchain.crt && cat intermediate.crt >> server-fullchain.crt)

```

검증:
```bash
# 서버 인증서 유효성 (클라 관점)

openssl verify -CAfile rootCA.crt server.crt
# 클라이언트 인증서 유효성 (서버 관점)

openssl verify -CAfile rootCA.crt client.crt
```

---

## 서버/클라 레퍼런스 구현

### Go (net/http + tls)

**서버 (클라 인증 요구)**

```go
// server.go
package main
import (
  "crypto/tls"
  "crypto/x509"
  "io/ioutil"
  "log"
  "net/http"
)

func main() {
  // 신뢰할 CA (클라이언트 인증서의 발급자)
  caCert, _ := ioutil.ReadFile("rootCA.crt")
  caPool := x509.NewCertPool()
  caPool.AppendCertsFromPEM(caCert)

  tlsCfg := &tls.Config{
    ClientCAs:  caPool,
    ClientAuth: tls.RequireAndVerifyClientCert, // mTLS 핵심
    MinVersion: tls.VersionTLS13,
  }

  mux := http.NewServeMux()
  mux.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) {
    // 인증된 클라이언트 정보
    state := r.TLS
    if len(state.PeerCertificates) == 0 {
      http.Error(w, "no client cert", http.StatusUnauthorized)
      return
    }
    subj := state.PeerCertificates[0].Subject.String()
    w.Write([]byte("hi " + subj))
  })

  srv := &http.Server{
    Addr:      ":8443",
    Handler:   mux,
    TLSConfig: tlsCfg,
  }
  log.Fatal(srv.ListenAndServeTLS("server.crt", "server.key"))
}
```

**클라이언트 (서버 검증 + 클라 인증서 제시)**

```go
// client.go
package main
import (
  "crypto/tls"
  "crypto/x509"
  "io/ioutil"
  "log"
  "net/http"
)

func main() {
  // 서버 신뢰 CA
  caCert, _ := ioutil.ReadFile("rootCA.crt")
  caPool := x509.NewCertPool()
  caPool.AppendCertsFromPEM(caCert)

  // 클라이언트 인증서
  cert, err := tls.LoadX509KeyPair("client.crt", "client.key")
  if err != nil { log.Fatal(err) }

  tlsCfg := &tls.Config{
    Certificates: []tls.Certificate{cert},
    RootCAs:      caPool,
    ServerName:   "api.internal", // SNI + SAN 검증
    MinVersion:   tls.VersionTLS13,
  }

  tr := &http.Transport{ TLSClientConfig: tlsCfg }
  cli := &http.Client{ Transport: tr }

  resp, err := cli.Get("https://api.internal:8443/hello")
  if err != nil { log.Fatal(err) }
  defer resp.Body.Close()
  b, _ := ioutil.ReadAll(resp.Body)
  log.Println(string(b))
}
```

---

### Node.js (https)

**서버**

```js
// server.mjs
import fs from 'node:fs';
import https from 'node:https';

const options = {
  key: fs.readFileSync('server.key'),
  cert: fs.readFileSync('server.crt'),
  // 클라이언트 인증서 검증용 CA
  ca: fs.readFileSync('rootCA.crt'),
  requestCert: true,
  rejectUnauthorized: true, // 클라 인증서 미제공/미검증 시 거부
  minVersion: 'TLSv1.3',
};

https.createServer(options, (req, res) => {
  if (!req.client.authorized) {
    res.writeHead(401);
    return res.end('client cert required');
  }
  // 인증된 피어 정보
  const cert = req.socket.getPeerCertificate();
  res.end(`hello ${cert.subject.CN || 'unknown'}`);
}).listen(8443, () => console.log('listening 8443'));
```

**클라이언트**

```js
// client.mjs
import fs from 'node:fs';
import https from 'node:https';

const options = {
  hostname: 'api.internal',
  port: 8443,
  path: '/hello',
  method: 'GET',
  key: fs.readFileSync('client.key'),
  cert: fs.readFileSync('client.crt'),
  ca: fs.readFileSync('rootCA.crt'),
  servername: 'api.internal', // SNI
  minVersion: 'TLSv1.3',
};

https.request(options, (res) => {
  res.setEncoding('utf8');
  res.on('data', (d) => process.stdout.write(d + '\n'));
}).end();
```

---

### Spring Boot (서버 & 클라)

**서버 application.yml**

```yaml
server:
  port: 8443
  ssl:
    enabled: true
    key-store: classpath:server.p12
    key-store-password: changeit
    key-store-type: PKCS12
    trust-store: classpath:clients-truststore.p12  # 클라이언트 CA
    trust-store-password: changeit
    trust-store-type: PKCS12
    client-auth: need  # mTLS 요구 (want = 선택)
```

> 키/트러스트스토어 만들기(예시):
```bash
# 서버 키+증명서 PKCS12

openssl pkcs12 -export -in server.crt -inkey server.key -out server.p12 -name "server" -passout pass:changeit

# 클라이언트 CA를 truststore에

keytool -import -noprompt -alias corp-root -file rootCA.crt \
  -keystore clients-truststore.p12 -storetype PKCS12 -storepass changeit
```

**클라이언트 RestTemplate**

```java
// TLSClientConfig.java
@Bean
RestTemplate restTemplate() throws Exception {
  KeyStore keyStore = KeyStore.getInstance("PKCS12");
  try (var in = new ClassPathResource("client.p12").getInputStream()) {
    keyStore.load(in, "changeit".toCharArray());
  }
  KeyStore trustStore = KeyStore.getInstance("PKCS12");
  try (var in = new ClassPathResource("servers-truststore.p12").getInputStream()) {
    trustStore.load(in, "changeit".toCharArray());
  }
  SSLContext sslContext = SSLContexts.custom()
    .loadKeyMaterial(keyStore, "changeit".toCharArray())
    .loadTrustMaterial(trustStore, null)
    .build();
  HttpClient httpClient = HttpClients.custom()
    .setSSLContext(sslContext)
    .build();
  return new RestTemplate(new HttpComponentsClientHttpRequestFactory(httpClient));
}
```

---

### Nginx (다운스트림 mTLS + 업스트림 mTLS)

**클라이언트 → Nginx (mTLS 수신)**

```nginx
server {
  listen 443 ssl;
  server_name api.internal;

  ssl_certificate     /etc/ssl/server.crt;
  ssl_certificate_key /etc/ssl/server.key;
  ssl_client_certificate /etc/ssl/clients-ca.crt; # 클라이언트 CA
  ssl_verify_client on;  # mTLS 요구
  ssl_protocols TLSv1.3;
  ssl_ciphers TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384;

  # (선택) 인증서 정보 헤더로 전달 *주의: 내부 신뢰 네트워크에서만*
  proxy_set_header X-Client-Subject $ssl_client_s_dn;
  proxy_set_header X-Client-SAN     $ssl_client_s_dn;
  # 비신뢰 경계에서는 이 헤더를 절대 신뢰하지 말 것.

  location / {
    proxy_pass https://app_upstream;
  }
}

upstream app_upstream {
  server app:8443;  # 백엔드도 TLS
  # 업스트림 검증 + 클라 인증서 제시
  proxy_ssl_certificate     /etc/ssl/client.crt;
  proxy_ssl_certificate_key /etc/ssl/client.key;
  proxy_ssl_trusted_certificate /etc/ssl/servers-ca.crt;
  proxy_ssl_verify on;
  proxy_ssl_verify_depth 2;
  proxy_ssl_server_name on;  # SNI
}
```

---

### Envoy (다운스트림/업스트림 TLS Context)

```yaml
static_resources:
  listeners:
  - name: https_in
    address: { socket_address: { address: 0.0.0.0, port_value: 8443 } }
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: backend
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                route:
                  cluster: app
          http_filters:
          - name: envoy.filters.http.router
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
          require_client_certificate: true
          common_tls_context:
            tls_certificates:
            - certificate_chain: { filename: "/etc/tls/server.crt" }
              private_key:      { filename: "/etc/tls/server.key" }
            validation_context:
              trusted_ca: { filename: "/etc/tls/clients-ca.crt" }

  clusters:
  - name: app
    type: LOGICAL_DNS
    connect_timeout: 2s
    load_assignment:
      cluster_name: app
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address: { address: app, port_value: 9443 }
    transport_socket:
      name: envoy.transport_sockets.tls
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
        common_tls_context:
          tls_certificates:
          - certificate_chain: { filename: "/etc/tls/client.crt" }
            private_key:      { filename: "/etc/tls/client.key" }
          validation_context:
            trusted_ca: { filename: "/etc/tls/servers-ca.crt" }
        sni: "app.internal"
```

---

### HAProxy

```haproxy
frontend fe_tls
  bind :443 ssl crt /etc/ssl/server.pem ca-file /etc/ssl/clients-ca.crt verify required
  default_backend be_tls

backend be_tls
  server s1 app:9443 ssl verify required \
    ca-file /etc/ssl/servers-ca.crt \
    crt /etc/ssl/client.pem \
    sni str(app.internal)
```

> `server.pem`/`client.pem` 은 `cat cert key` 형태의 PEM 번들.

---

### gRPC (Go)

**서버**

```go
lis, _ := net.Listen("tcp", ":50051")

caCert, _ := os.ReadFile("clients-ca.crt")
caPool := x509.NewCertPool()
caPool.AppendCertsFromPEM(caCert)

cert, _ := tls.LoadX509KeyPair("server.crt", "server.key")
creds := credentials.NewTLS(&tls.Config{
  Certificates: []tls.Certificate{cert},
  ClientCAs:    caPool,
  ClientAuth:   tls.RequireAndVerifyClientCert,
  MinVersion:   tls.VersionTLS13,
})

grpcServer := grpc.NewServer(grpc.Creds(creds))
// pb.RegisterYourServiceServer(grpcServer, &impl{})
grpcServer.Serve(lis)
```

**클라이언트**

```go
rootCA, _ := os.ReadFile("servers-ca.crt")
pool := x509.NewCertPool(); pool.AppendCertsFromPEM(rootCA)
cliCert, _ := tls.LoadX509KeyPair("client.crt", "client.key")

creds := credentials.NewTLS(&tls.Config{
  Certificates: []tls.Certificate{cliCert},
  RootCAs:      pool,
  ServerName:   "app.internal",
})

conn, _ := grpc.Dial("app.internal:50051", grpc.WithTransportCredentials(creds))
defer conn.Close()
```

---

### Kubernetes

#### (1) NGINX Ingress Controller — 클라이언트 인증서 요구(다운스트림)

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api
  annotations:
    nginx.ingress.kubernetes.io/auth-tls-secret: "ns/clients-ca"   # tls.crt=CA
    nginx.ingress.kubernetes.io/auth-tls-verify-client: "on"
    nginx.ingress.kubernetes.io/auth-tls-verify-depth: "2"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
spec:
  tls:
  - hosts: ["api.example.com"]
    secretName: server-cert
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service: { name: api-svc, port: { number: 8443 } }
```

> 업스트림(서비스)도 TLS면 서비스/Pod가 **서버 인증서**를 제공해야 합니다.

#### (2) Service Mesh (Istio) — 내부 mTLS 강제

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata: { name: default, namespace: ns }
spec:
  mtls: { mode: STRICT }
```

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata: { name: allow-payment-to-api, namespace: ns }
spec:
  rules:
  - from:
    - source:
        principals: ["spiffe://cluster.local/ns/ns/sa/payment-sa"]
    to:
    - operation: { ports: ["8443"] }
```

> SPIFFE ID 기반 **서비스 아이덴티티**를 인증서에 매핑하여, **정책(Authorization)** 과 연동.

---

## 운영: 발급·회전(Rotation)·폐기·감사

### 수명 전략

- **짧은 수명(예: 24~72h)** 인증서 + 자동 회전이 **CRL/OCSP 의존**보다 안전·간결.
- **2단계 롤링**:
  1) **서버/클라 새 cert 배포**(겹치는 유효기간) →
  2) **구 cert 폐기**.
  트러스트 CA 교체 시 **구·신 CA 번들 동시 신뢰 기간**을 두어 중단 없이 전환.

### 키 보호

- **권한 최소 파일 권한**(0600), 별도 볼륨/시크릿 스토어(KMS/TPM/HSM).
- **이미지 내 포함 금지**(런타임 주입).
- **메모리만 저장**(Agent/Sidecar).

### 폐기/감사

- 발급/사용 로그(누가/언제/어디서) 수집 → **비정상 패턴(급증/이상 도메인/SAN)** 알림.
- 키 유출 사건 시 **즉시 폐기/로테이션** 및 **접속 기록 역추적**.

---

## SSRF 저감 설계(패턴)

- **Egress mTLS 게이트웨이**: 외부/내부로 나가는 모든 HTTP(S) 요청을 **게이트로 중앙집중**.
  - 게이트는 **허용된 클라이언트 인증서**만 외부로 프록시.
  - 메타데이터/관리 엔드포인트(예: 내부 169.254.*)는 **서버 측에서 클라 cert 필수**로 구성.
  - 애플리케이션이 임의 URL을 호출해도, **mTLS 미제공 → 게이트에서 차단**.

- **서비스 권한 모델**: mTLS의 **아이덴티티 → RBAC/ABAC** 로 매핑.
  예: `spiffe://svc/payment`만 `spiffe://svc/ledger`에 POST 허용.

---

## 디버깅 & 흔한 장애

| 증상 | 원인 | 해결 |
|---|---|---|
| `unknown ca` | 신뢰 CA 번들에 Root/Intermediate 없음 | **체인** 정리(순서도 중요). |
| `certificate expired / not yet valid` | 시간대/만료/NotBefore 문제 | 시간 동기화(NTP), 재발급. |
| `x509: certificate signed by unknown authority` | 잘못된 trust store 경로 | 파일/권한/포맷(PEM/PKCS12) 재확인. |
| `handshake failure / no shared cipher` | 프로토콜/스위트 미스매치 | TLS1.2/1.3·스위트 설정 일치. |
| SAN 불일치 | ServerName(SNI)와 SAN 미매칭 | SAN 재발급/클라 설정 수정. |
| 클라 인증서 안넘어옴 | 서버가 `requestCert`/`Require` 안함 | mTLS 요구 옵션 확인. |
| 중간자 프록시 방해 | TLS Termination 위치 오류 | **어디서 종단하는지** 아키텍처 재점검. |

빠른 진단 명령:
```bash
# 서버 체인 확인

openssl s_client -connect api.internal:8443 -showcerts -CAfile rootCA.crt -servername api.internal

# mTLS 시도(클라이언트 cert 사용)

openssl s_client -connect api.internal:8443 \
  -cert client.crt -key client.key \
  -CAfile rootCA.crt -servername api.internal
```

---

## 보안 체크리스트

- [ ] **서버**: TLS1.3, 강한 스위트, HSTS(외부 노출 시)
- [ ] **클라이언트 인증 요구**: `RequireAndVerify`(프레임워크별 옵션)
- [ ] **SAN 기반 정책**(CN 의존 금지)
- [ ] **짧은 수명 인증서 + 자동 회전**
- [ ] **체인/중간 CA 포함**(서버 체인)
- [ ] **비밀/키 취급**: 시크릿 볼트/KMS/HSM, 0600 퍼미션, 이미지 포함 금지
- [ ] **로깅**: 접속 주체(피어 cert)·SNI·정책 매칭 결과
- [ ] **Egress 게이트**: 미등록 아이덴티티 차단, SSRF 저감
- [ ] **테스트**: 스테이징에서 mTLS 강제, 비호환 3rd-party 정리
- [ ] **문서화**: 발급·회전·폐기 플레이북, 장애 대응 루틴

---

## “막혀야 정상” 자동화 테스트(예)

CI/헬스체크 스크립트:
```bash
set -euo pipefail
host="${1:-api.internal}"
port="${2:-8443}"

# 클라 인증서 없이 접근 → 실패가 정상

if openssl s_client -connect "$host:$port" -servername "$host" -CAfile rootCA.crt </dev/null 2>&1 | grep -qi "Verify return code: 0"; then
  echo "❌ mTLS 미요구로 보임"; exit 1
fi

# 올바른 클라 cert로 접근 → 성공이 정상

if ! openssl s_client -connect "$host:$port" -servername "$host" \
    -CAfile rootCA.crt -cert client.crt -key client.key </dev/null 2>&1 \
    | grep -qi "Verify return code: 0 (ok)"; then
  echo "❌ 유효 cert인데 거부됨"; exit 1
fi

echo "✅ mTLS 정책 동작 OK"
```

---

## 설계 패턴(요약)

- **L4/L7 프록시/사이드카에서 mTLS 일괄 강제**(Envoy/Istio/Linkerd/HAProxy/Nginx)
- **서비스 아이덴티티 = 인증서의 SAN(SPIFFE URI)** → **정책 엔진(RBAC/ABAC)** 과 연동
- **인그레스/이그레스 분리**: 외부는 단방향 TLS(+OIDC 등), 내부는 **mTLS**
- **토큰 기반 인증과 병행**: mTLS로 **기계 신원**, 상층에서 비즈니스 **권한**
- **회전 자동화**: cert-manager/SPIRE/Vault/step-ca + 단명 인증서

---

### 마무리

mTLS는 **네트워크 경계에서의 “신원 증명”** 을 **기본값**으로 바꾸는 전략입니다.
핵심은 **CA/체인/회전 자동화**, **SAN 기반 아이덴티티**, **프록시 레이어 강제**, 그리고 **권한 정책과의 결합**입니다.
사용 중인 스택(클라우드/메시/프록시/프레임워크)을 알려주시면, 해당 환경 전용 **실행 가능한 템플릿(매니페스트/설정/스크립트)** 으로 더 세밀하게 맞춰 드릴게요.
