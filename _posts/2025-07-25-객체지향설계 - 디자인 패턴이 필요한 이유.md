---
layout: post
title: 객체지향설계 - 디자인 패턴이 필요한 이유
date: 2025-07-25 17:20:23 +0900
category: 객체지향설계
---
# 디자인 패턴이 필요한 이유

디자인 패턴은 **자주 발생하는 설계 문제에 대해 검증된 해법(템플릿)을 제공**하는 것입니다. 단순히 코드 스니펫 이상의 가치를 갖습니다. 이유를 정리하면 다음과 같습니다.

- **재사용 가능한 해법**  
  동일한 설계 문제를 매번 처음부터 고민하지 않아도 된다. 검증된 해법을 재사용하면 설계 품질이 안정된다.  
- **공통 언어 제공(Communication)**  
  `Factory`, `Observer`, `Strategy` 같은 이름만으로 설계 의도를 팀원 간에 빠르게 전달할 수 있다.  
- **설계 원칙 촉진**  
  많은 패턴이 SRP, OCP, DIP 등 좋은 설계 원칙을 자연스럽게 따르도록 유도한다.  
- **유연성 & 확장성 향상**  
  런타임에 행동을 바꾸거나(Strategy), 객체 생성 책임을 분리(Factories), 모듈 결합도를 낮추기 쉬워진다.  
- **유지보수·테스트 용이**  
  역할이 분리된 구조는 단위 테스트가 쉽고, 변경이 국소화되어 리팩토링이 용이하다.  
- **문제의식 공유(베스트 프랙티스)**  
  과거 경험(실패와 해결)을 추상화한 해법이므로 새로운 설계에서 실수를 줄여준다.

실무 예시: 결제 로직을 여러 방식으로 바꿔야 한다면 `Strategy`나 `Factory`를 적용하면 런타임 교체・확장이 쉬워진다. 이벤트 전달이 필요하면 `Observer`를 적용해 발신자와 수신자를 느슨하게 결합할 수 있다.

---

# GoF 디자인 패턴 분류 (Creational / Structural / Behavioral)

GoF(“Gang of Four”)가 정리한 23개 패턴은 **세 그룹**으로 분류됩니다. 각 패턴의 핵심 아이디어와 언제 쓰는지 짧게 정리합니다.

## Creational (생성 패턴) — 객체 생성 관련 책임 분리
- **Abstract Factory**  
  관련성 있는 객체들(제품군)을 생성하는 인터페이스를 제공. 서로 연관된 구현 집합을 교체할 때 사용.  
- **Builder**  
  복잡한 객체(여러 구성 옵션)를 단계별로 생성. 생성 과정과 표현을 분리하여 다양한 표현을 만들 때 유용.  
- **Factory Method**  
  객체 생성 코드를 서브클래스로 위임. 어떤 클래스의 인스턴스를 만들지 서브클래스가 결정해야 할 때.  
- **Prototype**  
  기존 인스턴스를 복제(clone)해서 새 객체를 생성. 비용이 큰 생성 작업을 피하려면 사용.  
- **Singleton**  
  시스템 내에 **단일 인스턴스**만 필요할 때(자원 관리 등). (주의: 테스트/병렬 환경에서의 단점 고려)

## Structural (구조 패턴) — 클래스·객체 구성 방식
- **Adapter**  
  기존 클래스 인터페이스를 클라이언트가 기대하는 인터페이스로 변환. 호환성 문제 해결에 사용.  
- **Bridge**  
  추상화와 구현을 분리하여 독립적으로 확장 가능하게 함. 변화가 서로 다른 축(인터페이스 vs 구현)을 가질 때.  
- **Composite**  
  객체들을 트리 구조로 구성해 부분-전체 계층을 동일하게 취급. 재귀적 구조를 표현할 때 유용.  
- **Decorator**  
  객체에 런타임으로 추가 책임(기능)을 동적으로 부여. 서브클래싱보다 유연함.  
- **Facade**  
  복잡한 서브시스템에 대한 단순한 인터페이스 제공. 클라이언트와 서브시스템 결합도 낮춤.  
- **Flyweight**  
  많은 수의 유사 객체가 메모리를 공유하도록 해 메모리 사용을 줄임(상태 분리 필요).  
- **Proxy**  
  실체 객체에 대한 접근을 제어하는 대리자. 접근 제어, 지연 초기화, 로깅 등에 사용.

## Behavioral (행위 패턴) — 객체 간 상호작용과 책임 분배
- **Chain of Responsibility**  
  요청을 처리할 수 있는 객체가 나올 때까지 체인으로 전달. 요청 처리 책임을 동적으로 연결할 때.  
- **Command**  
  실행 가능한 요청을 객체로 캡슐화(undo, 큐잉, 로깅 용이). 요청을 파라미터화하거나 큐에 넣고 싶을 때.  
- **Interpreter**  
  간단한 문법(언어)을 해석하는 인터프리터 구현에 사용. 문법 규칙을 객체 구조로 표현.  
- **Iterator**  
  내부 표현을 노출하지 않고 컬렉션의 요소에 순차 접근하는 표준 방법 제공.  
- **Mediator**  
  객체들 간의 복잡한 상호작용을 중앙 객체(중재자)로 집중시켜 결합도를 낮춤.  
- **Memento**  
  객체의 내부 상태를 외부에 노출하지 않고 저장/복원(undo 기능)할 때 사용.  
- **Observer**  
  객체 상태 변화 시 의존 객체들에게 자동 통보(퍼블리시/서브스크라이브). 이벤트 기반 구조에 적합.  
- **State**  
  객체의 상태에 따라 행동이 달라질 때 상태를 객체로 캡슐화하여 상태전환을 구현.  
- **Strategy**  
  알고리즘군을 캡슐화하여 런타임에 교체 가능하게 함(정렬 알고리즘 등).  
- **Template Method**  
  알고리즘의 골격을 상위 클래스에 정의하고, 세부 단계는 서브클래스에서 구현(재사용 vs 확장).  
- **Visitor**  
  객체 구조를 변경하지 않고 새로운 연산을 추가할 때 사용(객체 구조와 연산을 분리).

---

# 간단한 예 — Strategy 패턴 (Java)

```java
public interface SortStrategy {
    void sort(int[] arr);
}

public class QuickSort implements SortStrategy {
    public void sort(int[] arr) { /* 퀵 정렬 구현 */ }
}

public class BubbleSort implements SortStrategy {
    public void sort(int[] arr) { /* 버블 정렬 구현 */ }
}

public class Sorter {
    private final SortStrategy strategy;
    public Sorter(SortStrategy strategy) { this.strategy = strategy; }
    public void sort(int[] arr) { strategy.sort(arr); }
}

// 사용:
Sorter s = new Sorter(new QuickSort());
s.sort(data);
```

위 예제는 알고리즘(정렬)을 캡슐화해서 런타임에 쉽게 교체할 수 있게 해줍니다. 이는 **OCP(개방-폐쇄 원칙)** 을 만족시키는典型적인 활용 사례입니다.

---

# 학습·적용 팁

1. **문제에 맞게 골라 쓰기**  
   패턴은 레시피이지 의무가 아님. 문제와 비용·복잡도를 고려해 적용하라.  
2. **패턴 이름을 도구로 사용**  
   설계 리뷰에서 패턴 이름으로 의도와 트레이드오프를 빠르게 전달하라.  
3. **과도한 적용(Over-engineering) 주의**  
   간단한 문제에 불필요하게 많은 패턴을 적용하면 복잡성만 늘어난다.  
4. **리팩토링을 통해 적용**  
   처음부터 패턴을 적용하기보다 필요할 때 리팩토링으로 도입하면 안전하다.  
5. **테스트 가능한 구조로 만들기**  
   패턴은 종종 결합도를 낮추므로 단위 테스트를 쉽게 해준다 — 테스트 먼저 고려.

---

원하시면 각 패턴별로 **실전 예제(코드 + UML)**, **적용 시 장단점**, 또는 특정 언어(Java/C#/Python)에서의 구현 모범 사례를 하나씩 상세히 풀어 드릴게요. 어느 패턴부터 보시겠어요?







나의 말:
'계층형 아키텍처와 객체 지향 설계'에 대해 자세하게 작성해줘


ChatGPT의 말:

8s 동안 생각함
markdown
복사
편집
# 계층형 아키텍처와 객체 지향 설계 — 상세 가이드

계층형(Layered) 아키텍처는 시스템을 관심사별로 분리해 **유지보수성·확장성·테스트 용이성**을 높이는 전통적이고 널리 쓰이는 아키텍처 스타일입니다. 아래는 개념, 전형적 계층, 객체지향 설계와의 연계, 구현·테스트·배포 관점의 실전 팁과 예제까지 모아 정리한 내용입니다.

---

## 1. 계층형 아키텍처란 무엇인가? — 핵심 개념
- **정의**: 시스템을 책임(관심사) 단위로 여러 수평 계층(layer)으로 나누는 구조. 각 계층은 명확한 역할을 가지며 상위 계층은 하위 계층의 기능을 사용한다.  
- **목표**: 책임 분리(Separation of Concerns), 결합도 감소, 재사용성·테스트성 향상.  
- **전형적 의존 규칙**: 상위 → 하위로 의존(예: Presentation → Application → Domain → Infrastructure). 하위 계층은 상위 계층을 몰라야 함.

---

## 2. 전형적인 계층 구조와 책임

```
Presentation/UI Layer
  └─ Application / Service Layer
        └─ Domain Layer (Entities, Value Objects, Domain Services)
              └─ Infrastructure / Persistence Layer
```

- **Presentation (UI)**  
  - 역할: 사용자(또는 다른 시스템)와의 입출력 처리(웹 컨트롤러, API 핸들러, UI).  
  - 책임: 요청 파싱, 응답 포맷, 인증 토큰 추출 등. 도메인 로직을 직접 구현하지 않음.

- **Application (Use-case) / Service Layer**  
  - 역할: 유스케이스(시나리오) 조정자 — 트랜잭션 경계 설정, 보안/권한 체크, 여러 도메인 객체 협력 조율.  
  - 책임: 도메인 계층 호출, DTO 변환, 에러 처리, 이벤트 발행.

- **Domain Layer (비즈니스 로직)**  
  - 역할: 핵심 비즈니스 규칙과 상태를 담는 곳(엔터티, 값 객체, 도메인 서비스).  
  - 책임: 비즈니스 규칙 구현, 불변성 유지, 도메인 이벤트 정의. **이 계층은 외부 인프라(프레임워크)에 의존하면 안 됨.**

- **Infrastructure / Persistence Layer**  
  - 역할: DB, 메시지 브로커, 외부 API, 파일시스템 등 기술적 상세 구현.  
  - 책임: 레포지토리 구현, 외부 서비스 클라이언트, ORM 매핑. 도메인에서 정의한 인터페이스(포트)를 구현.

---

## 3. 객체지향 설계와의 연계 (원칙 & 패턴)

- **단일 책임 원칙(SRP)**: 각 계층은 하나의 책임 집합만 갖는다. 클래스 수준에서도 마찬가지.  
- **의존 역전 원칙(DIP)**: 상위(도메인) 계층이 하위(인프라) 계층에 의존하지 않도록, 도메인에서 **인터페이스(포트)**를 정의하고 인프라가 이를 구현하도록 설계. (Hexagonal / Ports & Adapters 스타일 권장)  
- **OCP / LSP / ISP**: 확장성·대체성·인터페이스 가이드에 따라 설계.  
- **테스트 가능성**: 도메인/애플리케이션은 외부 의존을 추상화(인터페이스)해 단위 테스트에서 쉽게 목(Mock) 주입 가능.

---

## 4. 포트와 어댑터(헥사고날)와의 관계
계층형 아키텍처를 진화시킨 형태로 **Hexagonal (Ports & Adapters)** 가 자주 사용됩니다.  
- 도메인은 **포트(interfaces)** 를 정의 → 어댑터(인프라)가 포트를 구현.  
- 장점: 프레임워크 교체/테스트 용이성, 의존 방향이 도메인 중심으로 정렬됨.

---

## 5. 실제 구현 팁 (패키지·의존성 규칙)

### 권장 패키지 레이아웃 (예: Java)
```
com.example.app
 ├─ presentation   (controllers, dto.request/response)
 ├─ application    (usecases/services, input/output ports)
 ├─ domain
 │    ├─ model     (entities, value objects)
 │    └─ service   (domain services, domain events)
 └─ infrastructure
      ├─ persistence (repositories.impl, jpa/entities)
      └─ api         (external service clients)
```

### 의존성 규칙
- `presentation` → `application` → `domain` → (`domain` defines ports) ← `infrastructure` (implements ports).  
- *하위 계층이 상위 계층을 직접 참조하지 않아야 함.*  
- 인터페이스는 가능하면 **더 안쪽 계층(도메인/애플리케이션)** 에 두고, 구현은 인프라에 둔다.

---

## 6. 예제: 은행 이체 시나리오 (간단 코드 스켈레톤)

```java
// domain/model/Money.java (Value Object)
public final class Money {
    private final long cents;
    // constructor, add, subtract, compareTo...
}

// domain/model/BankAccount.java (Entity)
public class BankAccount {
    private final String accountId;
    private Money balance;

    public void debit(Money amount) { /* validation + update */ }
    public void credit(Money amount) { /* validation + update */ }
    public Money getBalance() { return balance; }
}

// application/port/in/TransferUseCase.java
public interface TransferUseCase {
    void transfer(String fromAccountId, String toAccountId, Money amount);
}

// application/service/TransferService.java
public class TransferService implements TransferUseCase {
    private final AccountRepository accounts;
    private final TransactionManager tx; // 트랜잭션 경계

    public void transfer(String from, String to, Money amt) {
        tx.begin();
        BankAccount a = accounts.findById(from);
        BankAccount b = accounts.findById(to);
        a.debit(amt);
        b.credit(amt);
        accounts.save(a);
        accounts.save(b);
        tx.commit();
    }
}

// application/port/out/AccountRepository.java (port)
public interface AccountRepository {
    BankAccount findById(String id);
    void save(BankAccount account);
}

// infrastructure/persistence/AccountRepositoryJpa.java (adapter)
public class AccountRepositoryJpa implements AccountRepository {
    // JPA / JDBC 구현
}
```

- 핵심: 도메인은 인터페이스(레포지토리)를 직접 알고, 인프라는 그 인터페이스를 구현한다.

---

## 7. 트랜잭션 경계와 동시성
- **애플리케이션 서비스**가 보통 트랜잭션 경계를 가진다(한 유스케이스 단위).  
- DB 수준의 동시성은 인프라(레포지토리)에서 처리하거나, 도메인에서 낙관/비관적 락 정책을 모델링.  
- 분산 트랜잭션은 복잡하므로 이벤트·결합 완화(saga pattern)로 대체 권장.

---

## 8. DTO와 매핑
- **Presentation ↔ Application**: 요청/응답 DTO를 사용해 외부 표현과 도메인 모델을 분리.  
- 매핑은 보통 Application Layer에서 수행하거나 별도 Mapper(예: MapStruct) 사용.  
- **주의**: 도메인 모델을 직접 노출하지 말 것(보안·캡슐화 관점).

---

## 9. 테스트 전략
- **도메인 단위 테스트**: 비즈니스 로직(엔터티, 도메인 서비스) 테스트 — 외부 의존성 없음.  
- **애플리케이션 테스트 (단위)**: 포트(레포지토리 등)를 목으로 대체해 유스케이스 검증.  
- **인프라 통합 테스트**: 실제 DB/외부 시스템을 사용해 어댑터 검증(인메모리 DB 또는 Testcontainers 추천).  
- **E2E 테스트**: 전체 스택(프론트→API→DB) 검증.

---

## 10. 교차 관심사(Cross-cutting concerns)
- 로깅, 보안, 트랜잭션, 모니터링 등은 **애플리케이션/인프라 레벨**에서 AOP(Aspect)나 미들웨어로 처리.  
- 도메인 코드에는 교차 관심사를 침투시키지 않도록(도메인 순수성 유지).

---

## 11. 흔한 안티패턴 & 피해야 할 점

- **Anemic Domain Model (빈약한 도메인 모델)**  
  - 엔티티가 단순 데이터(게터/세터)만 가지고 비즈니스 로직이 서비스에 몰리는 경우. → 도메인에 책임을 옮겨 응집도 높이기.
- **God Service / God Object**  
  - 애플리케이션 레이어 또는 단일 서비스가 모든 일을 수행. → 책임 분리, 유스케이스별 서비스로 분해.
- **Leaky Abstractions (프레임워크 의존)**  
  - 도메인이 특정 프레임워크 세부에 의존하면 이식성·테스트성 저하. → 포트/어댑터로 캡슐화.
- **계층 넘나들기**  
  - Presentation이 Infrastructure 세부(예: JPA 엔티티)를 직접 조작하는 것 금지.

---

## 12. 언제 계층형을 선택하고 언제 진화시킬까?
- **적합한 경우**: 전형적인 CRUD·도메인 중심 시스템, 팀이 명확한 책임 분리를 원할 때.  
- **진화/대체**: 복잡한 도메인/마이크로서비스 환경에서는 Hexagonal, CQRS+Event Sourcing 같은 아키텍처로 확장 고려.

---

## 13. 배포·운영 관점
- 계층형 설계는 보통 **단일 애플리케이션(모놀리식)** 에 적합.  
- 마이크로서비스로 분해 시, 서비스 경계는 도메인 경계를 따라 정하고 각 서비스는 자체 계층 스택(각자 Presentation→Application→Domain→Infra)을 가질 수 있음.

---

## 14. 검증 체크리스트 (실무에서 점검할 것)
- [ ] 도메인 로직이 도메인 계층에 들어있는가?  
- [ ] 인프라가 도메인에 의존하지 않는가? (DIP 준수)  
- [ ] DTO가 UI와 도메인을 제대로 분리하고 있는가?  
- [ ] 트랜잭션 경계는 명확한가?  
- [ ] 테스트(단위/통합/E2E) 전략이 계층별로 설계되어 있는가?  
- [ ] 안티패턴(Anemic Model, God Service 등)이 발생하고 있지 않은가?

---

## 15. 요약
계층형 아키텍처는 **책임 분리**, **테스트성**, **유지보수성**을 확보하는 강력한 기본 구조입니다.  
객체지향 설계 원칙(SOLID, GRASP)을 계층 설계에 적용하면 도메인 중심의 유연한 시스템을 만들 수 있으며, 필요시 포트·어댑터(헥사고날) 패턴으로 진화시켜 프레임워크 결합도를 더 낮출 수 있습니다.
