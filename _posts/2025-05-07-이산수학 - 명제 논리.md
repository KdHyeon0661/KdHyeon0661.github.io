---
layout: post
title: 이산수학 - 명제 논리
date: 2025-05-07 19:20:23 +0900
category: 이산수학
---
# 명제 논리(Propositional Logic)

이 글은 기존의 명제 논리 소개를 더 체계적으로, 그리고 이산수학/컴퓨터공학 블로그에서 바로 가져다 쓸 수 있도록 확장한 버전이다.  
요청 조건을 다시 정리하면 다음과 같다.

---

## 0. 이 장의 목표

- "명제"라는 말을 일상적인 문장과 구분해서 정의할 수 있다.
- 기본 논리 연산(부정, 논리곱, 논리합, 조건, 쌍조건)의 뜻을 진리표로 설명할 수 있다.
- 서로 다른 논리식이 항상 같은 값을 낸다는 것을 "논리적 동치"로 설명할 수 있다.
- 조건문, 역, 이, 대우의 관계를 분명하게 말할 수 있다.
- "항진명제(tautology)", "모순(contradiction)", "가능명제(contingency)"의 차이를 말할 수 있다.
- 프로그래밍 언어의 조건문(if, &&, ||)을 명제 논리 관점에서 해석할 수 있다.
- 간단한 추론 규칙(Modus Ponens, Modus Tollens 등)을 명제 논리로 표현할 수 있다.
- CNF(절대합정규형), DNF(절대곱정규형)으로 만드는 이유를 이해한다.

---

## 1. 명제란 무엇인가

**정의**  
명제(Proposition)는 "참(True)" 또는 "거짓(False)" 중 **오직 하나**의 진리값만을 갖는 문장이다.

- "2는 짝수이다."  
  - 수학적으로 참이다. → 명제이다.
- "3은 5보다 크다."  
  - 수학적으로 거짓이다. → 명제이다.
- "오늘은 비가 온다."  
  - 실제 세계에서 참 또는 거짓 중 하나다. → 명제이다.
- "x는 예쁘다."  
  - 참/거짓이 개인마다 달라질 수 있고, 판단 기준이 명확하지 않다 → 이 문장은 여기서는 명제로 보지 않는 것이 일반적이다.
- "문을 열어라."  
  - 명령문은 참/거짓을 갖지 않는다. → 명제가 아니다.
- "다음 페이지를 보시오."  
  - 명제가 아니다.

즉, **명제인지 아닌지 판단하는 핵심 기준**은 "그 문장을 두고 참이냐 거짓이냐를 물을 수 있는가"이다. 그리고 그 값이 딱 하나로 결정되어야 한다.

---

### 1.1 명제의 예와 비예

아래는 명제 예시와 명제가 아닌 예시를 구분한 것이다.

| 문장 | 명제 여부 | 이유 |
|---|---|---|
| 5는 소수이다. | 명제 | 참/거짓 둘 중 하나. 실제로 참. |
| 10은 홀수이다. | 명제 | 참/거짓 둘 중 하나. 실제로 거짓. |
| 2 + 3 = 5 | 명제 | 참. |
| 서울은 한국의 수도이다. | 명제 | 참. |
| 오늘 점심은 맛있다. | 경우에 따라 명제가 아님 | 기준에 따라 달라진다. |
| 너는 숙제를 했니 | 명제가 아님 | 질문문. |
| x + 1 = 3 | 열린 문장(open sentence) | x가 무엇인지에 따라 달라진다. |

열린 문장(open sentence)은 변수에 값이 주어져야 진리값을 알 수 있는 문장이다. 예를 들어 "x > 0" 은 x가 5라면 참, x가 -2라면 거짓이다.  
이 장에서는 우선 "변수가 없는", "이미 닫힌" 문장들로 시작한다.

---

## 2. 명제 논리의 언어

명제 논리는 크게 두 가지로 구성된다.

1. **원자 명제(atomic proposition)**  
   - 더 이상 쪼갤 수 없는 가장 기본 명제  
   - 보통 $$p, q, r, s, \dots$$ 처럼 소문자 로마자로 쓴다.
   - 예:  
     - $$p: \text{2는 짝수이다}$$  
     - $$q: \text{3은 소수이다}$$
2. **논리 연산자(logical connectives)**  
   - 여러 명제를 하나의 큰 명제로 결합하거나, 한 명제를 부정한다.
   - 이 장에서는 다음 연산자를 쓴다.
     - 부정: $$\lnot$$
     - 논리곱: $$\land$$
     - 논리합: $$\lor$$
     - 조건(함의): $$\to$$
     - 쌍조건: $$\leftrightarrow$$

명제 논리는 "원자 명제"를 "논리 연산자"로 묶어 "복합 명제"를 만드는 체계라고 볼 수 있다.

---

### 2.1 논리 연산자의 의미(직관판)

1. 부정  
   - $$\lnot p$$ 는 "p가 아니다"  
   - p가 참이면 $$\lnot p$$ 는 거짓, p가 거짓이면 $$\lnot p$$ 는 참

2. 논리곱  
   - $$p \land q$$ 는 "p이고 q이다"  
   - p와 q가 모두 참일 때만 참

3. 논리합  
   - $$p \lor q$$ 는 "p이거나 q이다"  
   - p가 참이거나 q가 참(또는 둘 다 참)일 때 참  
   - 여기서는 기본적으로 "포함적 or" 이다.

4. 조건(함의)  
   - $$p \to q$$ 는 "p이면 q이다"  
   - p가 참이고 q가 거짓일 때만 거짓, 나머지는 참  
   - 이게 처음 보면 어색하므로 밑에서 진리표로 다시 설명한다.

5. 쌍조건  
   - $$p \leftrightarrow q$$ 는 "p와 q가 같을 때" 참  
   - 즉 두 명제가 항상 같은 진리값을 갖는 경우에 참

---

### 2.2 우선순위와 괄호

파이썬이나 C에서 연산자 우선순위를 정하듯이, 명제 논리에도 우선순위가 있다. 보통 아래처럼 본다.

1. $$\lnot$$ (부정)
2. $$\land$$
3. $$\lor$$
4. $$\to$$
5. $$\leftrightarrow$$

즉  
$$\lnot p \land q \lor r$$  
이 있으면 먼저 $$\lnot p$$ 를 하고, 그 다음 $$\land$$ 를 하고, 그 다음 $$\lor$$ 를 한다.  
헷갈릴 때는 괄호를 적극적으로 써서  
$$((\lnot p) \land q) \lor r$$  
처럼 쓰는 것이 안전하다.

---

## 3. 진리표(Truth Table)

명제 논리는 "가능한 모든 경우"에 대해 진리값을 비교한다.  
진리표는 입력되는 원자 명제들의 모든 조합에 대해 해당 논리식이 참인지 거짓인지 표로 적은 것이다.

예를 들어 원자 명제가 하나일 때 가능한 값은 2개이다.

| p |  
|---|  
| T |  
| F |

원자 명제가 두 개(p, q)일 때 가능한 조합은 4개이다.

| p | q |
|---|---|
| T | T |
| T | F |
| F | T |
| F | F |

원자 명제가 세 개(p, q, r)일 때 가능한 조합은 8개이다. 일반적으로 n개의 명제가 있으면 가능한 경우는 $$2^n$$ 개이다.

---

### 3.1 기본 연산 진리표

1) 부정

$$\lnot p$$ 의 진리표:

| p | $$\lnot p$$ |
|---|-------------|
| T | F           |
| F | T           |

2) 논리곱 $$p \land q$$

| p | q | $$p \land q$$ |
|---|---|---------------|
| T | T | T             |
| T | F | F             |
| F | T | F             |
| F | F | F             |

3) 논리합 $$p \lor q$$

| p | q | $$p \lor q$$ |
|---|---|--------------|
| T | T | T            |
| T | F | T            |
| F | T | T            |
| F | F | F            |

4) 조건 $$p \to q$$

| p | q | $$p \to q$$ |
|---|---|-------------|
| T | T | T           |
| T | F | F           |
| F | T | T           |
| F | F | T           |

여기서 핵심은 "앞이 거짓이면 전체가 참"이라는 점이다.  
이를 "공허한 참(vacuous truth)"라고 부르며, 수학적 증명에서 매우 자주 등장한다.  
"모든 소수는 2보다 크다" 라는 말을 생각해 보면, 만약 소수가 하나도 없다면 이 말은 자동으로 참이 된다. 이런 현상을 생각하면 된다.

5) 쌍조건 $$p \leftrightarrow q$$

| p | q | $$p \leftrightarrow q$$ |
|---|---|-------------------------|
| T | T | T                       |
| T | F | F                       |
| F | T | F                       |
| F | F | T                       |

---

### 3.2 진리표를 이용한 논리식 평가

예를 들어 $$\lnot p \lor q$$ 의 진리표를 만들면 아래와 같다.

| p | q | $$\lnot p$$ | $$\lnot p \lor q$$ |
|---|---|-------------|--------------------|
| T | T | F           | T                  |
| T | F | F           | F                  |
| F | T | T           | T                  |
| F | F | T           | T                  |

이 표만 보면 $$\lnot p \lor q$$ 는 $$p \to q$$ 와 똑같이 나오는 것을 알 수 있다.  
실제로 아래에서 다루겠지만  
$$p \to q \equiv \lnot p \lor q$$  
가 항상 성립한다.

---

## 4. 조건문, 역, 이, 대우

조건문(함의)은 논리에서 자주 헷갈리는 부분이다.

- 조건문: $$p \to q$$  
  - "p이면 q이다"

- 역: $$q \to p$$  
  - 결론과 조건을 뒤집은 것  
  - 원래 조건문과는 일반적으로 동치가 아니다.

- 이: $$\lnot p \to \lnot q$$  
  - 이 또한 원래 조건문과는 일반적으로 동치가 아니다.

- 대우: $$\lnot q \to \lnot p$$  
  - 조건문과 **항상** 동치이다.  
  - 즉  
    $$p \to q \equiv \lnot q \to \lnot p$$

이를 진리표로 확인해 보자.

| p | q | $$p \to q$$ | $$\lnot q \to \lnot p$$ |
|---|---|-------------|-------------------------|
| T | T | T           | T                       |
| T | F | F           | F                       |
| F | T | T           | T                       |
| F | F | T           | T                       |

두 열이 완전히 같으므로 둘은 논리적으로 동치이다.

---

### 4.1 왜 대우가 중요한가

수학 증명에서 "만약 A라면 B이다"를 증명하기보다, "만약 B가 아니라면 A가 아니다"를 증명하는 것이 더 쉬운 경우가 많다.  
예를 들어 "n이 2의 거듭제곱이면 n은 짝수이다"를 직접증명하는 것보다  
"n이 짝수가 아니면(홀수면) n은 2의 거듭제곱이 아니다"를 증명하는 편이 더 명확할 수 있다.

---

## 5. 논리식의 동치(Logical Equivalence)

두 논리식 $$P, Q$$ 가 **모든 경우**에서 같은 진리값을 내면  
$$P \equiv Q$$  
라고 쓴다.

예를 들어

1. $$p \to q \equiv \lnot p \lor q$$
2. $$\lnot (p \lor q) \equiv (\lnot p) \land (\lnot q)$$
3. $$(p \land q) \to r \equiv p \to (q \to r)$$  
   (이것은 증명 규칙과도 관련된다.)

동치인지 확인하는 가장 기초적인 방법은 **진리표를 모두 만들어서 두 열이 같은지 확인하는 것**이다.

---

### 5.1 자주 쓰는 논리 법칙(동치식)

아래 식들은 자주 쓰이는 것이므로 그대로 외워두면 좋다. 전부 진리표로 확인할 수 있다.

1. 항등식  
   - $$p \land \text{True} \equiv p$$  
   - $$p \lor \text{False} \equiv p$$

2. 지배법칙  
   - $$p \land \text{False} \equiv \text{False}$$  
   - $$p \lor \text{True} \equiv \text{True}$$

3. 멱등법칙  
   - $$p \land p \equiv p$$  
   - $$p \lor p \equiv p$$

4. 교환법칙  
   - $$p \land q \equiv q \land p$$  
   - $$p \lor q \equiv q \lor p$$

5. 결합법칙  
   - $$(p \land q) \land r \equiv p \land (q \land r)$$  
   - $$(p \lor q) \lor r \equiv p \lor (q \lor r)$$

6. 분배법칙  
   - $$p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$$  
   - $$p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$$

7. 드모르간 법칙  
   - $$\lnot (p \land q) \equiv (\lnot p) \lor (\lnot q)$$  
   - $$\lnot (p \lor q) \equiv (\lnot p) \land (\lnot q)$$

8. 이중부정  
   - $$\lnot (\lnot p) \equiv p$$

9. 조건식 변환  
   - $$p \to q \equiv \lnot p \lor q$$

10. 쌍조건  
   - $$(p \leftrightarrow q) \equiv (p \to q) \land (q \to p)$$

이 표를 가지고 있으면 복잡한 논리식을 점차 간단한 꼴로 바꿀 수 있다.

---

## 6. 항진명제, 모순, 가능한 명제

명제 논리에서 논리식 하나를 두고 "이 식은 어떤 성질을 가지는가"를 분류할 수 있다.

1. 항진명제(tautology)  
   - 어떤 진리값을 넣어도 항상 참이 되는 논리식  
   - 예: $$p \lor \lnot p$$  
   - 진리표를 만들면 전부 T가 나온다.

2. 모순(contradiction)  
   - 어떤 진리값을 넣어도 항상 거짓이 되는 논리식  
   - 예: $$p \land \lnot p$$  
   - 진리표를 만들면 전부 F가 나온다.

3. 가능한 명제(contingency)  
   - 어떤 경우에는 참, 어떤 경우에는 거짓이 되는 논리식  
   - 대다수 실전 논리식이 여기에 속한다.  
   - 예: $$p \land q$$, $$p \to q$$ 등

이 분류는 **논리적 타당성**을 말할 때 중요하다. 예를 들어 우리가 도출하고 싶은 결론이 항진명제이면, 그 결론은 전제와 상관없이 항상 참이다.

---

### 6.1 항진명제 확인 예제

예를 들어 $$p \to (q \to p)$$ 가 항상 참인지 보자.

| p | q | $$q \to p$$ | $$p \to (q \to p)$$ |
|---|---|-------------|----------------------|
| T | T | T           | T                    |
| T | F | T           | T                    |
| F | T | F           | T                    |
| F | F | T           | T                    |

네 줄이 전부 T이다. 그러므로  
$$p \to (q \to p)$$  
는 항진명제이다.

---

## 7. 정규형(Normal Form) 간단 소개

명제 논리를 컴퓨터가 다루기 편한 꼴로 바꿀 때 "정규형"을 쓴다. 대표적으로 두 가지가 있다.

1. **CNF (Conjunctive Normal Form)**  
   - "절들의 곱" 형태  
   - 절(clause)은 리터럴들의 합  
   - 즉  
     $$(l_{11} \lor l_{12} \lor \dots) \land (l_{21} \lor l_{22} \lor \dots) \land \dots$$  
   - SAT 솔버 등이 이 형식을 쓴다.

2. **DNF (Disjunctive Normal Form)**  
   - "곱들의 합" 형태  
   - 즉  
     $$(l_{11} \land l_{12} \land \dots) \lor (l_{21} \land l_{22} \land \dots) \lor \dots$$

여기서 리터럴(literal)은 "변수" 또는 "그 변수의 부정"을 말한다.  
CNF와 DNF는 진리표에서 직접 만들 수 있다. 예를 들어 어떤 논리식이 참이 되는 행만 골라서 그 행을 만족시키는 리터럴의 곱을 만들고, 그것들을 전부 OR 하면 DNF가 된다.

---

## 8. 추론 규칙(Inference Rules)

명제 논리는 단순히 "식이 같다"를 넘어서서 "이 전제들로부터 이 결론을 뽑아낼 수 있는가"를 다룬다. 이때 쓰는 것이 추론 규칙이다. 대표적인 것만 적어보면 다음과 같다.

1. Modus Ponens (MP)

$$
\begin{aligned}
&1.\ p \to q \\
&2.\ p \\
&\therefore\ q
\end{aligned}
$$

즉 "p이면 q이다"와 "p이다"가 주어졌으면 "q이다"를 결론낼 수 있다.

2. Modus Tollens (MT)

$$
\begin{aligned}
&1.\ p \to q \\
&2.\ \lnot q \\
&\therefore\ \lnot p
\end{aligned}
$$

3. Hypothetical Syllogism (HS)

$$
\begin{aligned}
&1.\ p \to q \\
&2.\ q \to r \\
&\therefore\ p \to r
\end{aligned}
$$

4. Disjunctive Syllogism (DS)

$$
\begin{aligned}
&1.\ p \lor q \\
&2.\ \lnot p \\
&\therefore\ q
\end{aligned}
$$

5. Addition

$$
\begin{aligned}
&1.\ p \\
&\therefore\ p \lor q
\end{aligned}
$$

6. Simplification

$$
\begin{aligned}
&1.\ p \land q \\
&\therefore\ p
\end{aligned}
$$

이러한 규칙들은 "참이면 참으로만" 가게 되어 있어서, 전제가 모두 참일 때 결론이 반드시 참이 된다.

---

## 9. 프로그래밍과 명제 논리

대부분의 프로그래밍 언어는 명제 논리와 거의 같은 연산자를 제공한다.

- C, C++, Java, C#, Go 등:
  - &&  : 논리곱(AND)
  - ||  : 논리합(OR)
  - !   : 부정(NOT)
  - if (cond) { ... } : cond가 참일 때만 실행
- Python:
  - and, or, not

다만 프로그래밍 언어는 "단락 평가(short-circuit evaluation)"를 하는 경우가 많다.  
예를 들어 C에서

```c
if (p && q) {
    ...
}
```

를 평가할 때 p가 거짓이면 q는 아예 평가하지 않는다.  
논리학에서는 진리값만 따지므로 "둘 다 평가된다"는 느낌이지만, 실제 언어에서는 효율과 부작용 때문에 평가 순서를 보장하는 식으로 구현한다.

---

### 9.1 Python 예제: 진리표 만들기

아래는 파이썬으로 임의의 2변수 식에 대해 진리표를 출력하는 코드이다.

```python
from itertools import product

def implies(a, b):
    return (not a) or b

def truth_table_2(expr):
    print("| p | q | value |")
    print("|---|---|-------|")
    for p, q in product([False, True], repeat=2):
        v = expr(p, q)
        print(f"| {str(p)[0]} | {str(q)[0]} | {str(v)[0]} |")

# 예: p -> q
truth_table_2(lambda p, q: implies(p, q))
```

---

### 9.2 C 예제: 조건문과 명제

```c
#include <stdio.h>

int main(void) {
    int x = 10;
    int y = 0;

    if (x > 5 && y == 0) {
        printf("x는 5보다 크고 y는 0이다.\n");
    }

    if (!(x > 5) || y == 0) {
        printf("x가 5보다 크지 않거나, y는 0이다.\n");
    }

    return 0;
}
```

여기서

- `x > 5 && y == 0` 은 논리식으로 쓰면  
  $$ (x > 5) \land (y = 0) $$
- `!(x > 5) || y == 0` 은 논리식으로 쓰면  
  $$ \lnot (x > 5) \lor (y = 0) $$

이다.

---

## 10. 논리적 타당성과 증명

명제 논리에서는 다음과 같은 질문을 자주 한다.

- "이 전제들이 모두 참이라면, 이 결론도 반드시 참인가?"
- "이 논증은 형식적으로 올바른가?"

예를 들어

1. 만약 비가 오면 길이 젖는다.  
2. 비가 온다.  
3. 그러므로 길이 젖는다.

이 논증은 명제 논리로 쓰면

1. $$p \to q$$
2. $$p$$
3. 따라서 $$q$$

이고, 이것은 위에서 본 Modus Ponens로 정당화된다.

반면에

1. 만약 비가 오면 길이 젖는다.  
2. 길이 젖었다.  
3. 그러므로 비가 왔다.

는

1. $$p \to q$$
2. $$q$$
3. 따라서 $$p$$

인데, 이것은 일반적으로 맞지 않다. 다른 이유로 길이 젖었을 수도 있기 때문이다.

---

## 11. 흔한 오류 패턴

1. 결론 긍정의 오류  
   - $$p \to q, q \vdash p$$ 를 정당하다고 생각하는 것  
   - 실제로는 정당하지 않다.

2. 전건 부정의 오류  
   - $$p \to q, \lnot p \vdash \lnot q$$  
   - 이것도 일반적으로 정당하지 않다.

이런 오류를 피하려면 "조건문과 대우만이 동치"라는 사실을 늘 떠올리면 된다.

---

## 12. 연습문제

1) 다음 논리식이 항진명제인지, 모순인지, 가능한 명제인지 분류하라.
- $$p \lor \lnot p$$
- $$(p \land q) \lor (\lnot p \land q) \lor (\lnot q)$$
- $$p \land \lnot p$$

2) 아래 식을 진리표로 만들어라.
- $$\lnot p \lor (p \land q)$$
- $$(p \to q) \land (q \to r)$$

3) 아래 동치식을 진리표로 증명하라.
- $$p \to q \equiv \lnot p \lor q$$
- $$\lnot (p \lor q) \equiv (\lnot p) \land (\lnot q)$$

4) 다음 논증의 타당성을 판별하라.
- 전제: $$p \to q$$, $$q \to r$$, $$p$$  
  결론: $$r$$
- 전제: $$p \lor q$$, $$\lnot p$$  
  결론: $$q$$
- 전제: $$p \to q$$, $$\lnot p$$  
  결론: $$\lnot q$$

5) 다음을 자연어에서 명제 논리로 번역하라.
- "오늘이 금요일이고, 나는 쉬는 날이면, 나는 등산을 간다."
- "나는 공부를 하거나 영화를 본다. 그러나 둘 다 하지는 않는다."
- "철수가 숙제를 했으면 선생님이 기뻐한다."

6) DNF로 바꾸기  
아래 논리식을 진리표로부터 DNF로 바꿔보라.
- $$ (p \lor q) \land \lnot r $$

7) CNF로 바꾸기  
아래 논리식을 등치 변환만으로 CNF로 바꿔보라.
- $$ p \to (q \land r) $$

힌트:
- $$ p \to X \equiv \lnot p \lor X $$
- $$ A \lor (B \land C) \equiv (A \lor B) \land (A \lor C) $$

---

## 13. 마무리

- 명제 논리는 이산수학의 첫 관문이다.
- 여기서 배운 "논리식 다루기"는 이후
  - 집합론(포함, 교집합, 여집합의 항등식)
  - 증명기법(직접증명, 대우증명, 모순증명)
  - 알고리즘 옳음 증명(루프 불변식)
  - 디지털 논리회로(AND, OR, NOT)
  - 형식 명세(Software Spec)
  로 전부 이어진다.
- 진리표를 그릴 수 있으면 거의 모든 "두 식이 같은가" 문제를 해결할 수 있다.
- 프로그래밍 언어의 if, &&, || 가 실제로는 여기서 말한 논리식과 거의 같은 구조라는 점을 기억해 두면, 조건문을 설계할 때 논리학적 사고를 적용할 수 있다.

---

## 부록: 파이썬으로 명제 논리 실험 환경 만들기

아래는 아주 단순화한 "논리식 평가기" 예제이다. 실제로는 파서(parser)가 필요하겠지만 여기서는 간단한 구조만 보여 준다.

```python
def implies(p, q):
    return (not p) or q

def iff(p, q):
    return (p and q) or ((not p) and (not q))

def formula(p, q, r):
    # 예: (p -> q) and (q -> r) -> (p -> r)
    return implies((p and implies(q, r)), implies(p, r))

vals = [False, True]
for p in vals:
    for q in vals:
        for r in vals:
            print(p, q, r, formula(p, q, r))
```

이런 식으로 작은 범위부터 실험해 보면, 논리식의 동치나 항진 여부를 감으로만이 아니라 실제로 확인할 수 있다.