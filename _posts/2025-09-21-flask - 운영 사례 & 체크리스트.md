---
layout: post
title: flask - 운영 사례 & 체크리스트
date: 2025-09-21 22:25:23 +0900
category: flask
---
# 20. 운영 사례 & 체크리스트

> 이 장은 **장애 시나리오(데드락/타임아웃/메모리 누수) 대응**, **비용 최적화(캐시/커넥션 재사용/이미지 슬림화)**, **보안 점검 목록(헤더/의존성/비밀관리/로그 마스킹)** 을 **운영 관점**에서 정리한다.  
> 모든 코드는 ``` 로 감싸며, 필요한 곳에 즉시 붙여 넣어 사용할 수 있는 **플레이북/체크리스트/코드 스니펫**을 제공한다.

---

## 20.1 운영 큰그림 — “예방·탐지·대응·학습”

- **예방(Prevent)**: 타임아웃/재시도/회로차단기, 커넥션 풀, 캐시, 리소스 한도(메모리/FD/CPU), 의존성 잠금
- **탐지(Detect)**: 헬스/레디니스, 로깅(JSON), 메트릭(Prometheus), 트레이스(OTel), 알람(SLO 기반)
- **대응(Respond)**: **런북(Playbook)** + 안전한 롤백/스위치(Blue-Green/카나리), 읽기 전용 모드, 플래그 토글
- **학습(Learn)**: 사후 분석(Postmortem), 근본 원인(RCA)·대응 시나리오 업데이트

> 원칙: **타임아웃은 모든 I/O 경계에 반드시**. “무한 대기”는 장애를 키운다.

---

## 20.2 장애 시나리오 대응

### 20.2.1 DB 데드락(Deadlock)

**증상**
- 트랜잭션이 서로 잠금 대기 → RDBMS가 감지 후 한쪽을 **죽임**(에러 반환)
- PostgreSQL: `deadlock detected` (SQLSTATE `40P01`)  
- MySQL: `ER_LOCK_DEADLOCK` (1213)

**원인 패턴**
- 동일 레코드를 **서로 다른 순서**로 업데이트
- 테이블/인덱스 범위 잠금 + 대량 업데이트
- “재고 차감/이체/정산” 등 **상호 교차 업데이트**

**핵심 대응**
1) **짧은 트랜잭션**: 비즈니스 로직은 트랜잭션 밖, DB I/O만 안에.
2) **잠금 순서 통일**: 항상 **키 오름차순** 등 동일 순서로 업데이트.
3) **격리수준**: 필요 이상 높지 않게(기본은 `READ COMMITTED` 권장).
4) **재시도**: 데드락 예외 시 **지수 백오프 후 재시도**(2~3회).

**SQLAlchemy 재시도 예**:

```python
# app/db/retry.py
import time, random
from sqlalchemy.exc import OperationalError
from contextlib import contextmanager

DEADLOCK_CODES = {"40P01", "1213"}  # PG, MySQL

@contextmanager
def deadlock_retry(session, retries=3, base=0.05, cap=0.8):
    for i in range(retries):
        try:
            yield
            session.commit()
            return
        except OperationalError as e:
            session.rollback()
            code = getattr(e.orig, "pgcode", None) or getattr(getattr(e.orig, "args", None) or [None], 0)
            if str(code) in DEADLOCK_CODES:
                sleep = min(cap, base * (2 ** i)) + random.random() * base
                time.sleep(sleep)
                continue
            raise
    # 마지막 시도 실패 시 재전파
    raise
```

사용:

```python
with deadlock_retry(db.session):
    do_update_logic()
```

**쿼리 레벨 개선**
- “적재적소에 `SELECT … FOR UPDATE`” (단, 범위 잠금 주의)
- **인덱스**로 잠금 범위를 최소화(테이블 스캔 잠금 금물)
- **배치 업데이트**는 청크/큐로 분산

---

### 20.2.2 타임아웃(Timeout)

**경계별 타임아웃**
- **WSGI/Gunicorn**: `--timeout 60 --graceful-timeout 30 --keep-alive 5`
- **DB**(SQLAlchemy → DB 드라이버): 연결/쿼리 타임아웃
- **HTTP 클라이언트**(httpx/requests): connect/read/write 타임아웃
- **리버스 프록시(Nginx/Ingress)**: `proxy_read_timeout`, `proxy_send_timeout`

**httpx 예**:

```python
import httpx
client = httpx.Client(
    timeout=httpx.Timeout(connect=2.0, read=3.0, write=3.0, pool=2.0),
    limits=httpx.Limits(max_keepalive_connections=100, max_connections=200),
)
```

**Flask 레벨**  
- **요청-스코프 작업**만 처리, **장기 작업은 큐**(Celery/RQ)
- **스트리밍 응답**은 진짜 스트리밍(청크)로; 백엔드에서 큰 파일 생성 금지(오브젝트 스토리지 활용)

**타임아웃 발생 시**
- **빠른 실패** + **깊은 로그**(원격 주소, 경로, 상관ID)  
- 자동 **재시도는 안전한 작업만**(멱등/Idempotent)

---

### 20.2.3 메모리 누수(Memory Leak) & OOM

**주요 원인**
- 글로벌 캐시에 무한 추가(키 누락)  
- 큰 응답/이미지/CSV를 메모리에 통째로 적재  
- 이벤트 리스너/콜백 등록 누락  
- `lru_cache` 메모리 제한 미사용

**탐지**
- **Gunicorn `--max-requests`** + `--max-requests-jitter` 로 **워커 재순환**
- **Prometheus**: `process_resident_memory_bytes`, 워커별 메모리 추적
- **tracemalloc** 스냅샷 비교
- **objgraph** 로 객체 그래프

**tracemalloc 예**:

```python
# boot.py
import tracemalloc, atexit
tracemalloc.start(25)

@atexit.register
def dump_top():
    from tracemalloc import take_snapshot
    snap = take_snapshot()
    top = snap.statistics('lineno')[:20]
    for s in top:
        print(s)
```

**큰 응답 스트리밍**:

```python
from flask import Response

def stream_csv(rows_iter):
    def generate():
        yield "id,name\n"
        for r in rows_iter:
            yield f"{r.id},{r.name}\n"
    return Response(generate(), mimetype="text/csv")
```

**캐시 누수 방지**:

```python
from functools import lru_cache
@lru_cache(maxsize=2048)  # 반드시 maxsize 지정
def expensive(x): ...
```

---

### 20.2.4 파일 디스크/FD 고갈

**증상**
- 임시파일/업로드 잔존, 로그 로테이션 실패, “Too many open files”

**대응**
- 업로드는 **스트리밍** + **임시 파일 자동 삭제**
- **uWSGI/Gunicorn** 로그를 **stdout/stderr** 로 → 런타임 수집(로거)
- OS/컨테이너 `nofile` 상한 조정 + **커넥션 풀**로 연결 수 관리

---

### 20.2.5 스레드/프로세스 데드락

- **블로킹 라이브러리**를 이벤트 루프(gevent, asyncio)와 섞어 사용 시 주의
- 파이썬 GIL: CPU 바운드 작업은 **멀티프로세스/워크 큐**로 이동

---

## 20.3 비용 최적화

### 20.3.1 캐시 계층화

- **응답 캐시**(Flask-Caching/Reverse Proxy) → 성능/비용 모두 절감
- **쿼리 캐시/결과 캐시**(Redis) → N+1/빈번한 조회 최소화
- **CDN 캐시**: 정적 자산 및 **캐시 가능한 API**(GET)까지 확장

Flask-Caching:

```python
from flask_caching import Cache
cache = Cache(config={"CACHE_TYPE": "RedisCache", "CACHE_REDIS_URL": "redis://cache:6379/0"})
cache.init_app(app)

@cache.cached(timeout=60, key_prefix=lambda: f"u:{g.user_id}:home")
def load_home():
    ...
```

**캐시 무효화 전략**
- **키 전략**: 명시적 키(엔티티 버전 포함) → 변경 시 키 변경
- **TTL + Soft-Refresh**: 만료 임박 시 백그라운드 갱신

---

### 20.3.2 커넥션 재사용(Keep-Alive)

- DB: SQLAlchemy 엔진 `pool_pre_ping=True`, `pool_size`, `max_overflow` 조정
- HTTP: httpx `Limits` 로 **keepalive** 최대화
- Nginx: `keepalive 64` 로 업스트림 재사용

SQLAlchemy 예:

```python
from sqlalchemy import create_engine
engine = create_engine(
    DATABASE_URL,
    pool_size=10,
    max_overflow=20,
    pool_timeout=10,
    pool_recycle=1800,
    pool_pre_ping=True,
    future=True,
)
```

---

### 20.3.3 Docker 이미지 슬림화

- **멀티 스테이지**: 빌더/런타임 분리, wheel 캐시 활용
- **슬림 베이스**(Debian slim) + **불필요 패키지 제거**
- **non-root** 유저, `.dockerignore` 확실히

`Dockerfile` 핵심:

```dockerfile
FROM python:3.11-slim AS builder
WORKDIR /build
COPY pyproject.toml poetry.lock ./
RUN pip install --upgrade pip && pip wheel --wheel-dir /wheels "."

FROM python:3.11-slim
RUN useradd -m app && mkdir /app && chown app /app
WORKDIR /app
COPY --from=builder /wheels /wheels
RUN pip install --no-deps /wheels/* && rm -rf /wheels
COPY . .
USER app
```

---

### 20.3.4 쿼리/인덱스/읽기복제본

- **핫 쿼리** 식별(`pg_stat_statements`, slowlog), 적절 인덱스
- 읽기 위주 엔드포인트는 **리드 레플리카**로 분리
- 배치/리포트는 **오프라인 워커**로 이동

---

### 20.3.5 오토스케일·리소스 권장치

- **HPA**: CPU/메모리/맞춤 지표(요청율/지연)
- **권장치 튜닝**: 실제 사용량 기반으로 requests/limits 조정 → 과금/스케줄링 최적화
- 야간/비핵심 서비스는 **스케일=0** 스케줄링(크론/플래그)

---

### 20.3.6 전송/압축/캐시 헤더

- 응답 압축: **Gzip/Brotli**(정적은 **사전압축** 파일 사용)
- **ETag**/`Cache-Control` 정확히
- 큰 페이로드는 **필드 최소화**, JSON 대신 **MessagePack**(내부) 고려

Nginx:

```
gzip on;
gzip_types text/plain text/css application/json application/javascript;
```

---

## 20.4 보안 점검 목록

### 20.4.1 보안 헤더

- **HSTS**: `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`
- **CSP**: `Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-...'; object-src 'none'`
- **X-Frame-Options**: `SAMEORIGIN`
- **X-Content-Type-Options**: `nosniff`
- **Referrer-Policy**: `no-referrer-when-downgrade` 또는 `strict-origin-when-cross-origin`
- **Permissions-Policy**: `geolocation=(), microphone=() ...`
- **Cross-Origin**: COEP/COOP/CORP 필요 시 설정

Flask 미들웨어:

```python
@app.after_request
def secure_headers(resp):
    resp.headers.setdefault("X-Frame-Options", "SAMEORIGIN")
    resp.headers.setdefault("X-Content-Type-Options", "nosniff")
    resp.headers.setdefault("Referrer-Policy", "strict-origin-when-cross-origin")
    resp.headers.setdefault("Permissions-Policy", "geolocation=()")
    return resp
```

---

### 20.4.2 의존성 보안

- **잠금 파일**(poetry.lock/requirements.txt) 커밋
- **pip-audit / safety / trivy** CI 통합
- **Renovate**/Dependabot → 정기 업데이트, 자동 PR + 테스트

CI 예(요약):

```yaml
- run: pip install pip-audit
- run: pip-audit -r requirements.txt --strict
```

---

### 20.4.3 비밀(Secret) 관리

- 코드/이미지에 **비밀 하드코딩 금지**
- 런타임은 **Secret Manager/KMS** or K8s **Secret** 마운트
- **주기적 로테이션**, 누출 시 **전면 폐기 + 키 회수**
- 애플리케이션 시작 시 **필수 비밀 유효성 검증**

검사 스크립트(간단):

```bash
#!/usr/bin/env bash
grep -R --line-number -E "(AWS_SECRET|SECRET_KEY|PASSWORD=)" . && echo "Hardcoded secret? abort." && exit 1
```

---

### 20.4.4 로그 마스킹/PII

- 토큰/비밀번호/카드번호/주민번호 → **마스킹**
- JSON 로그 필드 `user_id`, `request_id`, `ip` 등 **최소한만**
- **샘플링**: 고트래픽 엔드포인트 로그는 확률 샘플링

Python 로깅 필터:

```python
import re, logging, json

SECRET_PATTERNS = [
    re.compile(r"(Authorization:\s*Bearer\s+)([A-Za-z0-9\._-]+)", re.I),
    re.compile(r"(\"password\"\s*:\s*\")([^\"]+)(\")", re.I),
    re.compile(r"(api_key=)([^&\s]+)", re.I),
]

class RedactFilter(logging.Filter):
    def filter(self, record):
        msg = record.getMessage()
        for pat in SECRET_PATTERNS:
            msg = pat.sub(r"\1***\3", msg)
        record.msg = msg
        return True

logger = logging.getLogger("app")
logger.addFilter(RedactFilter())
```

---

### 20.4.5 인증/인가/세션

- **세션 쿠키**: `HttpOnly; Secure; SameSite=Lax/None`, 도메인 범위 점검
- **CSRF 보호**(쿠키 세션 시 필수), **Origin/Referer** 검증
- **JWT**: 짧은 AT + RT 쿠키, 로테이션, 블랙리스트
- **관리자 콘솔**: 2FA/MFA, IP 제한/VPN, 임퍼소네이션 감사 로그

---

### 20.4.6 입력 검증/업로드 보안

- 스키마 검증(Pydantic/Marshmallow), **서버 사이드 화이트리스트**
- 파일 업로드: 확장자 + **MIME 스니핑** + **바이러스 스캔** + **격리 버킷**
- 이미지 처리 라이브러리 취약점 점검, 썸네일 워커 샌드박싱

---

## 20.5 관측 & 알람 — SLO 기반

### 20.5.1 SLI/SLO

- SLI: **성공률**, **지연(p95)**, **오류율(5xx)**, **자원(메모리/CPU)**
- SLO 예: “API 성공률 99.9% (30일)”, “p95 < 300ms”

**PromQL 예시**
- 에러율:  
  `sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m]))`
- 레이턴시: 히스토그램 `rate(http_request_duration_seconds_bucket[5m])` → `histogram_quantile(0.95, ...)`

알람(예)
- 5분간 에러율 > 2% → 경고  
- 10분간 p95 > 800ms → 경고  
- 워커 메모리 > 한계치 80% 10분 지속 → 경고

---

## 20.6 런북(Playbook) 템플릿

### 20.6.1 DB 에러율 급증(데드락/타임아웃)

1) **현황**: 대시보드 확인(에러율/쿼리 RT/커넥션/락)  
2) **식별**: 상위 느린 쿼리, 락 대기 ID, 최근 배포/스키마 변경  
3) **조치**:  
   - 애플리케이션 **재시도** 활성화(데드락 한정)  
   - 문제 경로 **롤백/Feature Flag Off**  
   - 인덱스 추가/쿼리 수정(핫패치)  
   - 배치 작업 **일시 중지**  
4) **사후**: RCA, 쿼리 리라이트, 테스트/알람 강화

---

### 20.6.2 메모리 급증/OOM

1) **워커별** 메모리 그래프 확인  
2) 최근 **릴리스 차이**/대용량 요청/업로드 증가 탐지  
3) **Gunicorn `--max-requests`** 임시 낮춰 파동 완화  
4) **Heap 덤프/트레이스** 캡쳐, 누수 코드 패치  
5) 스트리밍 전환/캐시 maxsize 설정

---

### 20.6.3 외부 API 장애(의존성)

1) 에러율/레이턴시 증가, 회로차단기 상태 확인  
2) **폴백**(캐시/큐 적재/읽기 전용) 전환  
3) 재시도 백오프 상향, 타임아웃 단축  
4) 제공자 스테이터스/협력 채널 확인  
5) 사후: 캐시 설계 강화, 공급자 다변화

---

## 20.7 운영 코드 스니펫 묶음

### 20.7.1 요청 ID/코릴레이션 ID 주입

```python
import uuid
from flask import g, request

@app.before_request
def req_id():
    g.request_id = request.headers.get("X-Request-Id") or uuid.uuid4().hex

@app.after_request
def add_req_id(resp):
    resp.headers.setdefault("X-Request-Id", getattr(g, "request_id", ""))
    return resp
```

---

### 20.7.2 전역 타임아웃(소프트 캔슬)

```python
# app/middleware/timeout.py
import signal
from contextlib import contextmanager
from flask import abort

class Timeout(Exception): pass

@contextmanager
def time_limit(seconds):
    def handler(signum, frame): raise Timeout()
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(seconds)
    try: yield
    finally: signal.alarm(0)

@app.before_request
def req_timeout():
    g._timeout = time_limit(55)  # 예: 55s
    g._timeout.__enter__()

@app.after_request
def clear_timeout(resp):
    ctx = getattr(g, "_timeout", None)
    if ctx: ctx.__exit__(None, None, None)
    return resp
```

> 컨테이너/플랫폼에 따라 시그널 사용 제한이 있을 수 있다. 서비스 경계 타임아웃을 우선 고려.

---

### 20.7.3 httpx 회로차단+재시도(운영형)

```python
import time, threading, httpx
from tenacity import retry, wait_exponential_jitter, stop_after_attempt, retry_if_exception_type

class Circuit:
    def __init__(self, threshold=5, reset=20):
        self.fail = 0; self.state="CLOSED"; self.t0=0; self.lock=threading.Lock()
        self.threshold=threshold; self.reset=reset
    def allow(self):
        with self.lock:
            if self.state=="OPEN" and time.time()-self.t0>self.reset:
                self.state="HALF"
            return self.state!="OPEN"
    def ok(self):
        with self.lock:
            self.fail=0; self.state="CLOSED"
    def bad(self):
        with self.lock:
            self.fail+=1
            if self.fail>=self.threshold:
                self.state="OPEN"; self.t0=time.time()

client = httpx.Client(timeout=httpx.Timeout(5.0, connect=2.0))
circuit = Circuit()

class UpstreamTemporary(Exception): ...

@retry(reraise=True,
       wait=wait_exponential_jitter(0.2, 2.0),
       stop=stop_after_attempt(3),
       retry=retry_if_exception_type((httpx.HTTPError, UpstreamTemporary)))
def get_json(url, headers=None):
    if not circuit.allow(): raise UpstreamTemporary("open circuit")
    try:
        r = client.get(url, headers=headers)
        if r.status_code >= 500: raise UpstreamTemporary("5xx")
        r.raise_for_status(); circuit.ok()
        return r.json()
    except Exception:
        circuit.bad(); raise
```

---

## 20.8 감사/규정(감사 로그·보관·삭제)

- **감사 로그**: 관리자/중요 변경/임퍼소네이션 기록(14장)
- **보관 기간**: 법규/내부정책(예: 1년/3년) — **만료 자동 삭제 배치**
- **개인정보 파기**: 탈퇴 시 즉시/지연 삭제 정책, 백업·로그 내 PII 최소화

---

## 20.9 운영 체크리스트(요약)

### (A) 안정성
- [ ] 모든 I/O 경계에 **타임아웃**이 지정되어 있다
- [ ] DB 트랜잭션은 **짧고**, 데드락은 **백오프 재시도** 처리
- [ ] 장기 작업은 **큐**로 분리, 웹 요청은 **빠른 응답**
- [ ] 스트리밍/청크 전송 적용(대용량 응답)
- [ ] 워커는 `--max-requests(+jitter)` 로 주기적 재순환

### (B) 비용
- [ ] 캐시 계층(응답/쿼리/CDN) 구성, 무효화 전략 문서화
- [ ] 커넥션 풀/Keep-Alive 적절, DB/HTTP 설정 최적화
- [ ] 이미지 슬림화/멀티 스테이지/불필요 파일 제외
- [ ] 슬로우 쿼리/인덱스 지속 모니터링, 리드레플리카 활용
- [ ] 오토스케일/권장치 튜닝으로 과금 최적화

### (C) 보안
- [ ] 보안 헤더(HSTS/CSP/xfo/nosniff/referrer/permissions) 적용
- [ ] 비밀은 Secret Manager/KMS, 로테이션 절차 수립
- [ ] 의존성 스캔(pip-audit/safety/trivy) CI에 포함
- [ ] 로그 마스킹/샘플링, PII 최소화
- [ ] CSRF/JWT 로테이션/관리자 MFA/감사 로그

### (D) 관측/알람
- [ ] JSON 로깅 + request_id/trace_id
- [ ] 메트릭: 오류율/지연/자원, SLO 정의
- [ ] 알람은 **소음 방지**(집계·지속·중복 억제), 온콜 핸드북 구비
- [ ] 배포/플래그 변경과 **메트릭 상관** 분석 가능

### (E) 절차/런북
- [ ] 장애 유형별 **런북** 작성(데드락/타임아웃/메모리/OOM/외부API)
- [ ] 롤백/블루-그린 스위치/읽기전용 모드 버튼화
- [ ] 포스트모템/RCA 문화: 비난 금지, 구체적 행동 항목
