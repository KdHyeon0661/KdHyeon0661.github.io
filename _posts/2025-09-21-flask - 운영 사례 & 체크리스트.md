---
layout: post
title: flask - 운영 사례 & 체크리스트
date: 2025-09-21 22:25:23 +0900
category: flask
---
# 운영 사례 & 체크리스트

## 운영 철학 — "예방·탐지·대응·학습"

효율적인 애플리케이션 운영은 단순한 기술적 문제를 넘어 체계적인 접근 방식을 요구합니다. 운영 전략은 "예방, 탐지, 대응, 학습"이라는 네 가지 핵심 축을 중심으로 구성됩니다:

- **예방(Prevent)**: 타임아웃/재시도/회로차단기 설정, 커넥션 풀 구성, 캐시 활용, 리소스 한도(메모리/파일 디스크립터/CPU) 관리, 의존성 버전 잠금
- **탐지(Detect)**: 헬스/레디니스 엔드포인트, JSON 구조화 로깅, Prometheus 메트릭, OpenTelemetry 트레이스, SLO 기반 알람 시스템
- **대응(Respond)**: **런북(Playbook)**과 안전한 롤백/스위치 전략(Blue-Green/카나리 배포), 읽기 전용 모드, 기능 플래그 토글
- **학습(Learn)**: 사후 분석(Postmortem), 근본 원인 분석(RCA)·대응 시나리오 지속적 업데이트

> 핵심 원칙: **모든 I/O 경계에 타임아웃을 반드시 설정**합니다. "무한 대기"는 단순한 지연이 아니라 장애로 확장될 수 있습니다.

---

## 장애 시나리오 대응

### 데이터베이스 데드락(Deadlock)

**증상**
- 트랜잭션이 서로 잠금을 대기하다가 RDBMS가 감지 후 한쪽 트랜잭션을 중단(에러 반환)
- PostgreSQL: `deadlock detected` (SQLSTATE `40P01`)
- MySQL: `ER_LOCK_DEADLOCK` (1213)

**주요 원인 패턴**
- 동일 레코드를 서로 다른 순서로 업데이트
- 테이블/인덱스 범위 잠금과 대량 업데이트 동시 발생
- 재고 차감, 자금 이체, 정산 작업 등 상호 교차 업데이트 시나리오

**핵심 대응 전략**
1. **짧은 트랜잭션 유지**: 비즈니스 로직은 트랜잭션 밖에서 처리, 데이터베이스 I/O만 트랜잭션 내부에 포함
2. **잠금 순서 통일**: 항상 키 오름차순 등 동일한 순서로 레코드 업데이트
3. **격리수준 적절화**: 필요 이상으로 높은 격리수준 사용 지양(기본값 `READ COMMITTED` 권장)
4. **지능적 재시도**: 데드락 예외 발생 시 지수 백오프 후 제한된 재시도(2~3회)

**SQLAlchemy 재시도 구현 예시**

```python
# app/db/retry.py

import time, random
from sqlalchemy.exc import OperationalError
from contextlib import contextmanager

DEADLOCK_CODES = {"40P01", "1213"}  # PostgreSQL, MySQL 데드락 코드

@contextmanager
def deadlock_retry(session, retries=3, base=0.05, cap=0.8):
    for i in range(retries):
        try:
            yield
            session.commit()
            return
        except OperationalError as e:
            session.rollback()
            code = getattr(e.orig, "pgcode", None) or getattr(getattr(e.orig, "args", None) or [None], 0)
            if str(code) in DEADLOCK_CODES:
                sleep = min(cap, base * (2 ** i)) + random.random() * base
                time.sleep(sleep)
                continue
            raise
    # 마지막 시도 실패 시 예외 재전파
    raise
```

**사용 방법**

```python
with deadlock_retry(db.session):
    do_update_logic()
```

**쿼리 레벨 개선 방안**
- 적절한 상황에 `SELECT … FOR UPDATE` 사용(단, 범위 잠금 주의)
- **인덱스 최적화**로 잠금 범위 최소화(테이블 스캔 잠금 금지)
- **배치 업데이트**는 청크 단위나 작업 큐로 분산 처리

---

### 타임아웃(Timeout) 관리

**계층별 타임아웃 설정**
- **WSGI/Gunicorn**: `--timeout 60 --graceful-timeout 30 --keep-alive 5`
- **데이터베이스**(SQLAlchemy → DB 드라이버): 연결/쿼리 타임아웃 설정
- **HTTP 클라이언트**(httpx/requests): 연결/읽기/쓰기 타임아웃 분리 설정
- **리버스 프록시(Nginx/Ingress)**: `proxy_read_timeout`, `proxy_send_timeout` 구성

**httpx 타임아웃 설정 예시**

```python
import httpx
client = httpx.Client(
    timeout=httpx.Timeout(connect=2.0, read=3.0, write=3.0, pool=2.0),
    limits=httpx.Limits(max_keepalive_connections=100, max_connections=200),
)
```

**Flask 애플리케이션 레벨 전략**
- **요청-스코프 작업**만 처리, **장기 실행 작업은 큐**(Celery/RQ)로 분리
- **스트리밍 응답**은 실제 청크 스트리밍 방식 사용; 백엔드에서 큰 파일 생성 금지(오브젝트 스토리지 활용)

**타임아웃 발생 시 조치**
- **빠른 실패**와 **상세한 로깅**(원격 주소, 경로, 상관ID 포함)
- 자동 **재시도는 안전한 작업만**(멱등성 보장 작업) 적용

---

### 메모리 누수와 OOM(Out Of Memory)

**주요 원인**
- 글로벌 캐시에 무제한 항목 추가(키 누락)
- 대용량 응답/이미지/CSV를 메모리에 통째로 적재
- 이벤트 리스너/콜백 등록 누락
- `lru_cache` 메모리 제한 미적용

**탐지 방법**
- **Gunicorn `--max-requests`** + `--max-requests-jitter`로 **워커 주기적 재순환**
- **Prometheus 모니터링**: `process_resident_memory_bytes`, 워커별 메모리 추적
- **tracemalloc** 스냅샷 비교 분석
- **objgraph**로 객체 그래프 시각화

**tracemalloc 메모리 분석 예시**

```python
# boot.py

import tracemalloc, atexit
tracemalloc.start(25)

@atexit.register
def dump_top():
    from tracemalloc import take_snapshot
    snap = take_snapshot()
    top = snap.statistics('lineno')[:20]
    for s in top:
        print(s)
```

**대용량 응답 스트리밍 구현**

```python
from flask import Response

def stream_csv(rows_iter):
    def generate():
        yield "id,name\n"
        for r in rows_iter:
            yield f"{r.id},{r.name}\n"
    return Response(generate(), mimetype="text/csv")
```

**캐시 누수 방지**

```python
from functools import lru_cache
@lru_cache(maxsize=2048)  # 반드시 maxsize 지정
def expensive(x): ...
```

---

### 파일 디스크 및 파일 디스크립터(FD) 고갈

**증상**
- 임시 파일/업로드 파일 잔존, 로그 로테이션 실패, "Too many open files" 에러

**대응 전략**
- 파일 업로드는 **스트리밍 처리** + **임시 파일 자동 삭제**
- **uWSGI/Gunicorn 로그**를 **stdout/stderr**로 출력 → 런타임 로그 수집 시스템 활용
- OS/컨테이너 `nofile` 제한 상향 + **커넥션 풀**로 연결 수 관리

---

### 스레드/프로세스 데드락

- **블로킹 라이브러리**를 이벤트 루프(gevent, asyncio)와 혼용 시 주의
- CPU 집약적 작업은 **멀티프로세스/워크 큐**로 분리(GIL 영향 최소화)

---

## 비용 최적화 전략

### 캐시 계층화 설계

- **응답 캐시**(Flask-Caching/리버스 프록시) → 성능 향상과 비용 절감 동시 달성
- **쿼리 캐시/결과 캐시**(Redis) → N+1 문제와 빈번한 조회 최소화
- **CDN 캐시**: 정적 자산부터 **캐시 가능한 API**(GET 요청)까지 확장 적용

**Flask-Caching 적용 예시**

```python
from flask_caching import Cache
cache = Cache(config={"CACHE_TYPE": "RedisCache", "CACHE_REDIS_URL": "redis://cache:6379/0"})
cache.init_app(app)

@cache.cached(timeout=60, key_prefix=lambda: f"u:{g.user_id}:home")
def load_home():
    ...
```

**캐시 무효화 전략**
- **키 설계 전략**: 명시적 키(엔티티 버전 포함) → 변경 시 키 자체 변경
- **TTL + 소프트 리프레시**: 만료 임박 시 백그라운드 갱신 실행

---

### 커넥션 재사용(Keep-Alive) 최적화

- 데이터베이스: SQLAlchemy 엔진 `pool_pre_ping=True`, `pool_size`, `max_overflow` 적절 조정
- HTTP: httpx `Limits`로 **keepalive 연결 최대화**
- Nginx: `keepalive 64`로 업스트림 연결 재사용

**SQLAlchemy 커넥션 풀 설정**

```python
from sqlalchemy import create_engine
engine = create_engine(
    DATABASE_URL,
    pool_size=10,
    max_overflow=20,
    pool_timeout=10,
    pool_recycle=1800,
    pool_pre_ping=True,
    future=True,
)
```

---

### Docker 이미지 슬림화

- **멀티 스테이지 빌드**: 빌더/런타임 환경 분리, wheel 캐시 활용
- **슬림 베이스 이미지**(Debian slim) + **불필요 패키지 제거**
- **non-root 사용자** 실행, `.dockerignore` 철저히 적용

**Dockerfile 핵심 구성**

```dockerfile
FROM python:3.11-slim AS builder
WORKDIR /build
COPY pyproject.toml poetry.lock ./
RUN pip install --upgrade pip && pip wheel --wheel-dir /wheels "."

FROM python:3.11-slim
RUN useradd -m app && mkdir /app && chown app /app
WORKDIR /app
COPY --from=builder /wheels /wheels
RUN pip install --no-deps /wheels/* && rm -rf /wheels
COPY . .
USER app
```

---

### 쿼리/인덱스 최적화와 읽기 복제본 활용

- **핫 쿼리 식별**(`pg_stat_statements`, 슬로우 쿼리 로그), 적절한 인덱스 구성
- 읽기 위주 엔드포인트는 **리드 레플리카**로 분리
- 배치 처리/리포트 생성은 **오프라인 워커**로 이동

---

### 오토스케일링과 리소스 권장치 설정

- **HPA(Horizontal Pod Autoscaler)**: CPU/메모리/맞춤 지표(요청율/지연) 기반 스케일링
- **권장치 튜닝**: 실제 사용량 기반으로 requests/limits 조정 → 과금/스케줄링 최적화
- 야간/비핵심 서비스는 **스케일=0** 스케줄링(크론/플래그 기반)

---

### 전송 효율화와 압축, 캐시 헤더 관리

- 응답 압축: **Gzip/Brotli**(정적 콘텐츠는 **사전 압축 파일** 사용)
- **ETag**/`Cache-Control` 헤더 정확히 설정
- 대용량 페이로드는 **필드 최소화**, JSON 대신 **MessagePack**(내부 통신용) 고려

**Nginx 압축 설정**

```
gzip on;
gzip_types text/plain text/css application/json application/javascript;
```

---

## 보안 점검 항목

### 보안 헤더 설정

- **HSTS**: `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`
- **CSP**: `Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-...'; object-src 'none'`
- **X-Frame-Options**: `SAMEORIGIN`
- **X-Content-Type-Options**: `nosniff`
- **Referrer-Policy**: `no-referrer-when-downgrade` 또는 `strict-origin-when-cross-origin`
- **Permissions-Policy**: `geolocation=(), microphone=() ...`
- **Cross-Origin**: COEP/COOP/CORP 필요 시 설정

**Flask 보안 헤더 미들웨어**

```python
@app.after_request
def secure_headers(resp):
    resp.headers.setdefault("X-Frame-Options", "SAMEORIGIN")
    resp.headers.setdefault("X-Content-Type-Options", "nosniff")
    resp.headers.setdefault("Referrer-Policy", "strict-origin-when-cross-origin")
    resp.headers.setdefault("Permissions-Policy", "geolocation=()")
    return resp
```

---

### 의존성 보안 관리

- **잠금 파일**(poetry.lock/requirements.txt) 저장소 커밋
- **pip-audit / safety / trivy** CI 파이프라인 통합
- **Renovate**/Dependabot → 정기 업데이트, 자동 PR 생성 + 테스트

**CI 보안 스캔 예시**

```yaml
- run: pip install pip-audit
- run: pip-audit -r requirements.txt --strict
```

---

### 비밀 정보 관리

- 코드/이미지에 **비밀 정보 하드코딩 절대 금지**
- 런타임 비밀은 **Secret Manager/KMS** 또는 Kubernetes **Secret** 마운트 활용
- **정기적 키 로테이션**, 누출 시 **전면 폐기 및 키 회수**
- 애플리케이션 시작 시 **필수 비밀 정보 유효성 검증**

**비밀 정보 하드코딩 검사 스크립트**

```bash
#!/usr/bin/env bash

grep -R --line-number -E "(AWS_SECRET|SECRET_KEY|PASSWORD=)" . && echo "Hardcoded secret detected, aborting." && exit 1
```

---

### 로그 마스킹과 PII 보호

- 토큰/비밀번호/카드번호/주민번호 → **마스킹 처리**
- JSON 로그 필드 `user_id`, `request_id`, `ip` 등 **최소한의 정보만 포함**
- **샘플링 전략**: 고트래픽 엔드포인트 로그는 확률적 샘플링 적용

**Python 로깅 마스킹 필터**

```python
import re, logging, json

SECRET_PATTERNS = [
    re.compile(r"(Authorization:\s*Bearer\s+)([A-Za-z0-9\._-]+)", re.I),
    re.compile(r"(\"password\"\s*:\s*\")([^\"]+)(\")", re.I),
    re.compile(r"(api_key=)([^&\s]+)", re.I),
]

class RedactFilter(logging.Filter):
    def filter(self, record):
        msg = record.getMessage()
        for pat in SECRET_PATTERNS:
            msg = pat.sub(r"\1***\3", msg)
        record.msg = msg
        return True

logger = logging.getLogger("app")
logger.addFilter(RedactFilter())
```

---

### 인증/인가/세션 보안

- **세션 쿠키**: `HttpOnly; Secure; SameSite=Lax/None`, 도메인 범위 점검
- **CSRF 보호**(쿠키 기반 세션 시 필수), **Origin/Referer** 검증
- **JWT**: 짧은 액세스 토큰 + 리프레시 토큰 쿠키, 주기적 로테이션, 블랙리스트 관리
- **관리자 콘솔**: 2FA/MFA, IP 제한/VPN, 임퍼소네이션 감사 로그

---

### 입력 검증과 업로드 보안

- 스키마 검증(Pydantic/Marshmallow), **서버 사이드 화이트리스트** 적용
- 파일 업로드: 확장자 + **MIME 타입 스니핑** + **바이러스 스캔** + **격리 버킷**
- 이미지 처리 라이브러리 취약점 점검, 썸네일 생성 워커 샌드박싱

---

## 관측성과 알람 — SLO 기반 운영

### SLI/SLO 정의

- SLI(서비스 수준 지표): **성공률**, **지연 시간(p95)**, **오류율(5xx)**, **자원 사용량(메모리/CPU)**
- SLO(서비스 수준 목표) 예시: "API 성공률 99.9% (30일 평균)", "p95 응답 시간 < 300ms"

**PromQL 메트릭 예시**
- 에러율 계산:
  `sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m]))`
- 레이턴시 측정: 히스토그램 `rate(http_request_duration_seconds_bucket[5m])` → `histogram_quantile(0.95, ...)`

**알람 조건 예시**
- 5분간 에러율 > 2% → 경고 알람
- 10분간 p95 > 800ms → 경고 알람
- 워커 메모리 사용량 > 한계치 80% 10분 지속 → 경고 알람

---

## 운영 대응 템플릿

### 데이터베이스 에러율 급증(데드락/타임아웃)

1. **현황 파악**: 대시보드 확인(에러율/쿼리 응답 시간/커넥션/락 상태)
2. **근본 원인 식별**: 상위 느린 쿼리, 락 대기 ID, 최근 배포/스키마 변경 사항
3. **즉시 조치**:
   - 애플리케이션 **재시도 로직** 활성화(데드락 상황 한정)
   - 문제 발생 경로 **롤백/기능 플래그 Off**
   - 인덱스 추가/쿼리 수정(핫패치)
   - 배치 작업 **일시 중지**
4. **사후 개선**: 근본 원인 분석, 쿼리 재작성, 테스트/알람 시스템 강화

---

### 메모리 사용량 급증/OOM

1. **워커별 메모리 그래프** 확인
2. 최근 **릴리스 변경사항**/대용량 요청/업로드 증가 탐지
3. **Gunicorn `--max-requests`** 임시 하향 조정으로 파동 완화
4. **Heap 덤프/트레이스** 캡쳐, 메모리 누수 코드 패치
5. 스트리밍 처리 전환/캐시 maxsize 설정

---

### 외부 API 장애(의존성 문제)

1. 에러율/레이턴시 증가, 회로차단기 상태 확인
2. **폴백 메커니즘**(캐시/큐 적재/읽기 전용) 전환
3. 재시도 백오프 상향 조정, 타임아웃 단축
4. 서비스 제공자 상태 페이지/협력 채널 확인
5. 사후 개선: 캐시 설계 강화, 공급자 다변화

---

## 운영 코드 스니펫 모음

### 요청 ID/코릴레이션 ID 주입

```python
import uuid
from flask import g, request

@app.before_request
def req_id():
    g.request_id = request.headers.get("X-Request-Id") or uuid.uuid4().hex

@app.after_request
def add_req_id(resp):
    resp.headers.setdefault("X-Request-Id", getattr(g, "request_id", ""))
    return resp
```

---

### 전역 타임아웃(소프트 캔슬) 구현

```python
# app/middleware/timeout.py

import signal
from contextlib import contextmanager
from flask import abort

class Timeout(Exception): pass

@contextmanager
def time_limit(seconds):
    def handler(signum, frame): raise Timeout()
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(seconds)
    try: yield
    finally: signal.alarm(0)

@app.before_request
def req_timeout():
    g._timeout = time_limit(55)  # 예: 55초 제한
    g._timeout.__enter__()

@app.after_request
def clear_timeout(resp):
    ctx = getattr(g, "_timeout", None)
    if ctx: ctx.__exit__(None, None, None)
    return resp
```

> 컨테이너/플랫폼 환경에 따라 시그널 사용에 제한이 있을 수 있습니다. 서비스 경계 수준의 타임아웃을 우선적으로 고려하세요.

---

### httpx 회로차단기 + 재시도 구현(운영 환경용)

```python
import time, threading, httpx
from tenacity import retry, wait_exponential_jitter, stop_after_attempt, retry_if_exception_type

class Circuit:
    def __init__(self, threshold=5, reset=20):
        self.fail = 0; self.state="CLOSED"; self.t0=0; self.lock=threading.Lock()
        self.threshold=threshold; self.reset=reset
    def allow(self):
        with self.lock:
            if self.state=="OPEN" and time.time()-self.t0>self.reset:
                self.state="HALF"
            return self.state!="OPEN"
    def ok(self):
        with self.lock:
            self.fail=0; self.state="CLOSED"
    def bad(self):
        with self.lock:
            self.fail+=1
            if self.fail>=self.threshold:
                self.state="OPEN"; self.t0=time.time()

client = httpx.Client(timeout=httpx.Timeout(5.0, connect=2.0))
circuit = Circuit()

class UpstreamTemporary(Exception): ...

@retry(reraise=True,
       wait=wait_exponential_jitter(0.2, 2.0),
       stop=stop_after_attempt(3),
       retry=retry_if_exception_type((httpx.HTTPError, UpstreamTemporary)))
def get_json(url, headers=None):
    if not circuit.allow(): raise UpstreamTemporary("open circuit")
    try:
        r = client.get(url, headers=headers)
        if r.status_code >= 500: raise UpstreamTemporary("5xx")
        r.raise_for_status(); circuit.ok()
        return r.json()
    except Exception:
        circuit.bad(); raise
```

---

## 감사 및 규정 준수(감사 로그·보관·삭제)

- **감사 로그**: 관리자 작업/중요 변경/임퍼소네이션 기록(14장 참조)
- **보관 기간**: 법규/내부정책 준수(예: 1년/3년) — **만료 시 자동 삭제 배치 작업**
- **개인정보 파기**: 사용자 탈퇴 시 즉시/지연 삭제 정책 수립, 백업·로그 내 PII 최소화

---

## 운영 핵심 원칙 요약

### 안정성 확보
- 모든 I/O 경계에 적절한 **타임아웃** 설정 필수
- 데이터베이스 트랜잭션은 **최소화**, 데드락 발생 시 **지능적 백오프 재시도** 처리
- 장기 실행 작업은 **작업 큐**로 분리, 웹 요청은 **빠른 응답** 보장
- 대용량 응답 처리는 **스트리밍/청크 전송** 방식 적용
- 워커 프로세스는 `--max-requests(+jitter)`로 주기적 재순환

### 비용 효율화
- 캐시 계층화(응답/쿼리/CDN) 구성, 명확한 무효화 전략 문서화
- 커넥션 풀/Keep-Alive 적절 구성, 데이터베이스/HTTP 설정 최적화
- Docker 이미지 슬림화/멀티 스테이지 빌드/불필요 파일 제외
- 슬로우 쿼리/인덱스 지속적 모니터링, 읽기 복제본 적극 활용
- 오토스케일링/리소스 권장치 튜닝으로 과금 최적화

### 보안 강화
- 필수 보안 헤더(HSTS/CSP/xfo/nosniff/referrer/permissions) 적용
- 비밀 정보는 전문 Secret Manager/KMS 관리, 정기적 로테이션 절차 수립
- 의존성 보안 스캔(pip-audit/safety/trivy) CI 파이프라인 통합
- 로그 마스킹/샘플링 구현, PII 최소화 원칙 준수
- CSRF/JWT 로테이션/관리자 MFA/감사 로그 시스템 구축

### 관측성과 알람 관리
- JSON 구조화 로깅 + request_id/trace_id 전파
- 핵심 메트릭: 오류율/지연 시간/자원 사용량, 명확한 SLO 정의
- 알람 시스템은 **소음 최소화**(집계·지속·중복 억제), 온콜 핸드북 구비
- 배포/기능 플래그 변경과 **메트릭 변화 상관관계** 분석 가능

### 운영 절차 체계화
- 주요 장애 유형별 **실행 가능한 런북** 작성(데드락/타임아웃/메모리/OOM/외부API)
- 안전한 롤백/블루-그린 스위치/읽기전용 모드 버튼화
- 포스트모템/RCA 문화 정착: 비난 회피, 구체적 개선 항목 도출

## 결론

Flask 애플리케이션의 운영은 단순한 서버 관리에서 벗어나 종합적인 엔지니어링 분야로 진화했습니다. 이 장에서는 예방, 탐지, 대응, 학습이라는 네 가지 축을 중심으로 실제 운영 환경에서 마주치는 다양한 시나리오와 그 해결책을 구체적으로 다루었습니다.

성공적인 운영의 핵심은 사고 발생 후 대응하는 수동적 자세에서 벗어나, 시스템이 스스로 회복력을 갖추고 문제를 예측하며 적응하는 능동적 아키텍처로 전환하는 데 있습니다. 이를 위해 체계적인 모니터링, 명확한 SLO 정의, 실행 가능한 런북, 그리고 지속적인 학습 문화가 필수적입니다.

최종적으로, 운영 우수성은 기술적 역량과 프로세스, 문화의 조화에서 비롯됩니다. Flask 애플리케이션이 비즈니스 가치를 지속적으로 제공할 수 있도록 이 모든 요소를 통합적으로 발전시켜 나가는 것이 현대 소프트웨어 엔지니어의 중요한 책임입니다.