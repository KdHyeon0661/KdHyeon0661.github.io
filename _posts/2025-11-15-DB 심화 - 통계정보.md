---
layout: post
title: DB 심화 - 통계정보
date: 2025-11-15 19:25:23 +0900
category: DB 심화
---
# 옵티마이저 통계정보(Statistics)

## 0) 왜 통계가 “실행계획의 90%”를 결정하는가

Oracle CBO는 실행계획을 만들 때 결국 다음을 반복한다.

1) **카디널리티 추정**(각 단계가 몇 행을 만들지)
2) **비용 계산**(IO + CPU 모델)
3) 가능한 조인 순서/액세스 경로/조인 방법 후보를 비교
4) 가장 싼 플랜 선택

이때 **카디널리티 추정의 입력이 통계**다.
통계가 없거나 틀리면, CBO는 “틀린 지도”로 길을 찾고,
잘못된 조인 순서/방법(예: NL vs HASH), 잘못된 스캔 경로(예: 인덱스 vs FTS)를 고른다.

**핵심 공식(개념)**

- 단일 조건:
$$
\text{Card} \approx \text{NUM\_ROWS} \times \text{Selectivity}
$$
- 조인:
$$
\text{Card}(A \bowtie B)\approx \text{Card}(A)\times \text{Card}(B)\times \text{Join Selectivity}
$$

위 “Selectivity”와 “Join Selectivity”를 **현실에 가깝게 만드는 도구가 히스토그램/확장통계/실시간·동적 방식**이다.

---

## 1) 통계의 분류와 데이터 딕셔너리 대응표

Oracle 옵티마이저 통계는 크게 다음으로 나뉜다.

| 분류 | 내용 | 딕셔너리 뷰 |
|---|---|---|
| 테이블 통계 | NUM_ROWS, BLOCKS, AVG_ROW_LEN, 파티션·서브파티션, 샘플링 메타 | USER_TAB_STATISTICS, USER_TABLES |
| 컬럼 통계 | NDV, NULL 비율, LOW/HIGH, DENSITY, 히스토그램 | USER_TAB_COL_STATISTICS, USER_TAB_HISTOGRAMS |
| 인덱스 통계 | BLEVEL, LEAF_BLOCKS, DISTINCT_KEYS, CLUSTERING_FACTOR 등 | USER_INDEXES, USER_IND_STATISTICS |
| 시스템 통계 | CPU/IO 성능, MBRC, SREADTIM/MREADTIM 등 | SYS.AUX_STATS$ |
| 고정 오브젝트 통계 | X$ 등 내부 고정 테이블 통계 | DBMS_STATS.GATHER_FIXED_OBJECTS_STATS |
| 실시간/동적 통계 | 대량 로드/변경 직후의 즉시 통계 | V$SQL_PLAN_STATS, Real-Time Statistics |

---

## 2) 실습 스키마 & 데이터 (사용자 초안 그대로)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

DROP TABLE CUST PURGE;
DROP TABLE ORD  PURGE;
DROP TABLE PROD PURGE;

CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8) NOT NULL,
  TIER    VARCHAR2(8) NOT NULL
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,
  BRAND    VARCHAR2(12) NOT NULL
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  ORDER_DT DATE   NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL
);

CREATE INDEX IX_CUST_REGION ON CUST(REGION, CUST_ID);
CREATE INDEX IX_PROD_CAT    ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_ORD_CUST    ON ORD(CUST_ID);
CREATE INDEX IX_ORD_PROD_DT ON ORD(PROD_ID, ORDER_DT);

BEGIN
  FOR c IN 1..50000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,5) WHEN 0 THEN 'KOR' WHEN 1 THEN 'KOR' WHEN 2 THEN 'APAC'
                    WHEN 3 THEN 'EMEA' ELSE 'AMER' END,
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
                    WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..12000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
                    WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 3000 THEN 'B0' ELSE 'B'||TO_CHAR(MOD(p,50)) END
    );
  END LOOP;

  FOR o IN 1..200000 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,50000)+1,
      MOD(o,12000)+1,
      DATE '2024-01-01' + MOD(o,365),
      1 + MOD(o,5),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;

  COMMIT;
END;
/
```

---

## 3) 테이블 통계(Table Statistics)

### 테이블 통계가 의미하는 것

- **NUM_ROWS**: 테이블 전체 행 수
- **BLOCKS**: 사용 블록 수(Heap 기준)
- **AVG_ROW_LEN**: 평균 행 길이
- **SAMPLE_SIZE / ESTIMATE_PERCENT**: 샘플링 규모
- **STATS_TYPE_LOCKED / STALE_STATS**: 잠금/오래됨 여부
  → 옵티마이저는 이 값으로 **기본 카디널리티**를 만든다.

### 수집 기본형(권장 디폴트)

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname          => USER,
    tabname          => 'ORD',
    cascade          => TRUE,
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE AUTO'
  );
END;
/
```

**왜 AUTO_SAMPLE_SIZE가 “사실상 필수”인가?**

- 12c 이후 도입된 **Top-Frequency/Hybrid 히스토그램은**
  **AUTO_SAMPLE_SIZE로 수집할 때만 생성**될 수 있다.
- 낮은 고정 샘플(예: 1% 고정)은
  스큐/상관관계 컬럼을 못 잡아 **오판을 구조적으로 만든다.**

### 자동 통계(Autotask)와 STALE 판정

Oracle은 유지보수 윈도우에서 자동 통계를 돌리고,
**기본 STALE 기준은 “테이블 변경량 약 10%”**이다.
(버전·옵션에 따라 세부는 다르지만, 기본 정책은 이 ‘변경량 기반 stale’)

- 자동 통계가 싫다면 비활성화 가능:

```sql
BEGIN
  DBMS_AUTO_TASK_ADMIN.DISABLE(
    client_name => 'auto optimizer stats collection',
    operation   => NULL,
    window_name => NULL
  );
END;
/
```

### 파티션 테이블의 증분 통계(Incremental Stats)

대규모 파티션 테이블에서는
매번 전체를 재수집하는 대신

- 변경된 파티션만 수집
- 나머지는 **synopsis(시놉시스)**로 합성해 글로벌 통계를 만든다.

```sql
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','INCREMENTAL','TRUE');
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','GRANULARITY','AUTO');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD', cascade=>TRUE);
END;
/
```

**실전 포인트**
- “파티션 교환(Partition Exchange Load)”이 많은 DW에서 필수.
- INCREMENTAL을 켰다면,
  새 파티션 로드 후 **파티션 통계만 수집하면 글로벌이 자동 합성**된다.

### 조회/검증

```sql
SELECT table_name, num_rows, blocks, avg_row_len,
       sample_size, last_analyzed, stale_stats
FROM   user_tab_statistics
WHERE  table_name IN ('CUST','PROD','ORD');
```

---

## 4) 인덱스 통계(Index Statistics)

### 인덱스 통계의 핵심 필드

- **BLEVEL**: 브랜치 단계 수
- **LEAF_BLOCKS**: 리프 블록 수
- **DISTINCT_KEYS(NDV)**: 서로 다른 키 수
- **CLUSTERING_FACTOR(CF)**:
  “인덱스 키 순서 vs 테이블 물리 순서 일치도”
  → **NL 조인에서 테이블 랜덤 액세스 비용을 좌우**한다.

### 수집/조회

```sql
BEGIN
  DBMS_STATS.GATHER_INDEX_STATS(USER,'IX_ORD_PROD_DT');
END;
/

SELECT index_name, blevel, leaf_blocks, distinct_keys,
       clustering_factor, num_rows, last_analyzed
FROM   user_indexes
WHERE  table_name='ORD';
```

### CF가 실행계획을 바꾸는 이유

**개념**
- NL 조인 비용은 대략
$$
\text{Cost}_{NL} \approx \text{Card}_{outer} \times \text{(index probe + table fetch)}
$$
- **CF가 낮을수록** 테이블 fetch가 **연속 I/O에 가까워져 싸지고**
  CF가 높을수록 **랜덤 I/O로 비싸진다.**

**실전 변화**
- CF가 나쁘면 CBO는 NL을 버리고 HASH를 고른다.
- 반대로 CF가 매우 좋으면
  “FTS보다 인덱스+NL이 싸다”로 판단할 수 있다.

**개선 전략**
1) IOT(인덱스 조직 테이블)로 물리 정렬
2) CTAS+ORDER BY로 재적재 후 인덱스 재생성
3) 파티션 로드 시 정렬 유지
4) 클러스터 테이블/Zone Map(환경에 따라)

---

## 5) 컬럼 통계 & 히스토그램(Columns / Histograms)

### 컬럼 통계가 주는 정보

- **NUM_DISTINCT(NDV)**: 서로 다른 값 수
- **DENSITY**: 균등 가정 기반 선택도
- **NULLS**: NULL 비율
- **LOW_VALUE/HIGH_VALUE**: 분포 범위
- **HISTOGRAM**: 스큐(편중) 구조를 설명하는 추가 모델

### 히스토그램이 필요한 이유(스큐)

우리 데이터는 BRAND='B0'가 다수라 스큐가 크다.
히스토그램 없이 CBO는 **“값이 균등하다”**고 가정해

- 'B0' 값도
- 'B47' 값도

**비슷한 선택도**로 계산해 버린다.
→ 그래서 스캔 경로가 틀어진다.

### 히스토그램 타입(12c+ / 19c/21c/23ai/26)

Oracle은 버전이 올라오며
Height-Balanced 중심에서 **Top-Frequency/Hybrid 중심으로 이동**했다.

| 타입 | 특징 | 언제 생성되는가 |
|---|---|---|
| FREQUENCY | NDV ≤ 버킷 수면 값별 정확 빈도 | AUTO 정책에서 “스큐 강하고 NDV 작음” |
| TOP-FREQUENCY | 최빈값(top-n)을 별도로 정확 기록 | **AUTO_SAMPLE_SIZE일 때만** 가능  |
| HYBRID | 최빈값은 정확 + 나머지는 구간근사 | **AUTO_SAMPLE_SIZE일 때만** 가능  |
| HEIGHT-BALANCED | 구간 균형 기반(구버전 잔재) | Hybrid/Top-Freq 비활성·부족 시 남을 수 있음  |

### 수집/삭제

```sql
-- 특정 컬럼 히스토그램 강제
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR COLUMNS SIZE 254 BRAND'
  );
END;
/

-- 히스토그램 제거(균등 가정 복귀)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 1 BRAND'
  );
END;
/
```

### 확인

```sql
SELECT column_name, num_distinct, histogram, density, last_analyzed
FROM   user_tab_col_statistics
WHERE  table_name='PROD';
```

### 히스토그램 효과 실습

```sql
-- 1) 히스토그램 없이 (균등 가정)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR COLUMNS SIZE 1 BRAND');
END;
/
EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 2) 히스토그램 적용
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR COLUMNS SIZE 254 BRAND');
END;
/
EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**기대 관측**
- B0는 대량값이므로 **FTS/FFS가 더 싸게 나오고**
- 희귀 브랜드는 **인덱스 범위 스캔이 싸게 나올 가능성**이 커진다.

---

## 6) 확장 통계(Extended Stats) — 상관관계 보정

### 왜 필요한가

CUST에서 REGION과 TIER는 **독립이 아닐 수 있다.**
CBO가 독립가정하면

$$
Sel(REGION='KOR' \wedge TIER='VIP')
\approx Sel(REGION='KOR') \times Sel(TIER='VIP')
$$

하지만 현실은 VIP가 KOR에 더 몰려 있을 수 있다.
이 오판은 **조인 순서·방법을 뒤집는 1순위 원인**이다.

### 컬럼 그룹 통계 생성

```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(
    USER, 'CUST', '(REGION, TIER)'
  );
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/

SELECT extension_name, extension, creator, droppable
FROM   user_stat_extensions
WHERE  table_name='CUST';
```

### 효과 실습

```sql
-- 확장 통계 없이
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM CUST
WHERE REGION='KOR' AND TIER='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 확장 통계 적용 후
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM CUST
WHERE REGION='KOR' AND TIER='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## 7) SQL Plan Directive(SPD)와 자동 확장 통계

Oracle은 실행 중 **카디널리티 오판 패턴**을 감지하면
SPD(SQL Plan Directive)를 만들고, 다음 통계 수집 때

- 컬럼 그룹(확장 통계)
- 표현식 통계

생성을 자동 유도할 수 있다.

**실전 의미**
- “내가 확장 통계를 안 만들었는데 어느 날 생겼다”
  → SPD 기반 자동 생성일 가능성이 높다.
- SPD가 너무 많으면 SYSAUX 관리 비용이 커질 수 있어
  **불필요 directive를 점검/정리**하는 운영이 필요할 때도 있다.

---

## 8) 실시간 통계(Real-Time Statistics)와 고빈도 수집

자동 통계는 윈도우 기반이어서
“대량 로드 직후”나 “급격한 데이터 변동 직후”에는 늦을 수 있다.

그래서 Oracle은

- **대량 DML/로드 중에 실시간 통계를 생성**
- 옵티마이저가 “stale한 시점 사이의 공백”을 줄이도록 개선했다.

**실전 포인트**
- ETL/배치가 끝나자마자 그 테이블을 조회하는 DW 시스템에서 특히 중요.
- 환경에 따라 기능의 가용 범위/동작 방식이 다르므로
  “대량 로드 후 플랜이 이상하다”면 **실시간 통계 활성 여부**를 체크한다.

---

## 9) 시스템 통계(System Statistics)

### 시스템 통계가 무엇을 모델링하나

CBO 비용 모델은 “블록 읽기 비용”과 “CPU 비용”으로 구성된다.
시스템 통계는 이 비용을 **실제 서버/스토리지 성능에 맞게 보정**한다.

주요 파라미터(대표)

- **CPUSPEEDNW / CPUSPEED**
- **SREADTIM**: single-block read 시간
- **MREADTIM**: multi-block read 시간
- **MBRC**: multi-block read count

### NOWORKLOAD vs WORKLOAD

- **NOWORKLOAD**: 랜덤 I/O 중심의 짧은 측정, 운영에서 가장 흔한 기본 선택.
- **WORKLOAD**: 실제 워크로드 구간을 대표해 측정(정밀하지만 운영 부담).

```sql
BEGIN
  DBMS_STATS.GATHER_SYSTEM_STATS('NOWORKLOAD');
END;
/

SELECT pname, pval1
FROM   sys.aux_stats$
WHERE  sname='SYSSTATS_MAIN';
```

WORKLOAD(개념 흐름)

```sql
BEGIN DBMS_STATS.GATHER_SYSTEM_STATS('START'); END;
-- 대표 워크로드 시간 동안 운영
BEGIN DBMS_STATS.GATHER_SYSTEM_STATS('STOP'); END;
/
```

### 시스템 통계가 플랜을 바꾸는 패턴

- **MREADTIM이 상대적으로 더 빠른 환경(대형 스캔이 싸다)**
  → FTS/FFS/해시 조인이 더 선호될 수 있음.
- **SREADTIM이 매우 빠른 환경(랜덤이 싸다, NVMe/메모리티어링 등)**
  → 인덱스 기반 NL 계획이 더 선호될 수 있음.

**운영 규칙**
- 스토리지/CPU 교체, VM/클라우드 스펙 변경 시
  시스템 통계 재수집을 반드시 고려한다.

---

## 10) Pending Stats, Publish, Lock, 백업/복구

### Preferences로 운용 정책 고정

```sql
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','STALE_PERCENT','5');
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','NO_INVALIDATE','TRUE');
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','PUBLISH','TRUE');
END;
/
```

- **STALE_PERCENT**: stale 판정 민감도(변경이 잦은 테이블은 낮춤)
- **NO_INVALIDATE=TRUE**: 플랜 무효화 시점을 지연(플랜 출렁임 완화)
- **PUBLISH**: 바로 통계 게시할지 여부

### Pending Stats로 안전 검증

```sql
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'PROD','PUBLISH','FALSE');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE);
END;
/

ALTER SESSION SET optimizer_use_pending_statistics = TRUE;

BEGIN
  DBMS_STATS.PUBLISH_PENDING_STATS(USER,'PROD');
END;
/
```

### Export/Import/Restore/Lock

```sql
EXEC DBMS_STATS.CREATE_STAT_TABLE(USER,'STAT_BACKUP');
EXEC DBMS_STATS.EXPORT_TABLE_STATS(USER,'ORD','STAT_BACKUP');
EXEC DBMS_STATS.IMPORT_TABLE_STATS(USER,'ORD','STAT_BACKUP');

EXEC DBMS_STATS.RESTORE_TABLE_STATS(
  USER,'ORD', SYSTIMESTAMP - INTERVAL '1' HOUR
);

EXEC DBMS_STATS.LOCK_TABLE_STATS(USER,'ORD');
EXEC DBMS_STATS.UNLOCK_TABLE_STATS(USER,'ORD');
```

---

## 11) 통계 유무/정확도가 플랜을 뒤집는 실전 시나리오

### 히스토그램 유무가 스캔을 바꾼다

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt=>'FOR COLUMNS SIZE 1 BRAND'); -- hist off
END;
/
EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt=>'FOR COLUMNS SIZE 254 BRAND'); -- hist on
END;
/
EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 확장 통계가 조인 순서를 바꾼다

```sql
EXPLAIN PLAN FOR
SELECT /* no ext */ COUNT(*)
FROM CUST c JOIN ORD o ON o.cust_id=c.cust_id
WHERE c.region='KOR' AND c.tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
EXPLAIN PLAN FOR
SELECT /* ext */ COUNT(*)
FROM CUST c JOIN ORD o ON o.cust_id=c.cust_id
WHERE c.region='KOR' AND c.tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### CF가 NL vs HASH를 가른다

```sql
SELECT index_name, clustering_factor, num_rows
FROM   user_indexes
WHERE  table_name='ORD';

EXPLAIN PLAN FOR
SELECT SUM(o.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id=c.cust_id
WHERE  c.region='KOR';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## 12) 진단/디버깅 루틴(필수)

```sql
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL,
  'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS +NOTE +ALIAS'
));
```

확인 순서

1) **E-Rows vs A-Rows**
   - 추정 대비 실제가 10배 이상 벌어지면 통계부터 의심
2) **Predicate 이동**
   - 히스토그램/확장통계가 있어야 제대로 푸시/전이됨
3) **조인 순서/방법 비용 근거**
   - CF/NDV/선택도에서 비용이 납득되는지

---

## 13) 실무 베스트프랙티스 체크리스트

### 수집 정책

- [ ] **AUTO_SAMPLE_SIZE 기본 유지**(고정 저샘플 금지)
- [ ] 변경 많은 테이블은 STALE_PERCENT 낮추기
- [ ] 파티션 대형 테이블은 **INCREMENTAL + synopsis** 필수
- [ ] 대량 로드 직후는 실시간/수동 수집으로 공백 제거

### 히스토그램/확장통계

- [ ] 스큐 컬럼은 히스토그램
- [ ] 상관관계는 확장통계
- [ ] “불필요한 히스토그램 남발”은 플랜 변동성만 키움
- [ ] SPD가 만든 자동 확장통계도 주기적으로 점검

### 운용 안전망

- [ ] 핵심 테이블은 Pending → Test → Publish
- [ ] Export/Restore로 회귀 가능성 확보
- [ ] 자동 통계가 깨는 테이블은 LOCK으로 보호

### 언제나 실측

- [ ] 계획은 “추정”일 뿐.
  **ALLSTATS LAST로 입증되지 않으면 믿지 않는다.**

---

## 14) 결론

통계는 옵티마이저의 시야다.
**테이블/인덱스 통계로 크기와 랜덤성을**,
**히스토그램으로 스큐를**,
**확장통계와 SPD로 상관관계를**,
**시스템·실시간 통계로 하드웨어/시간 축의 현실성을** 전달해야
CBO의 비용 모델이 현실과 맞는다.

통계가 정확하면 대부분의 튜닝은 “힌트 없이도” 해결되고,
통계가 틀리면 어떤 힌트도 임시처방에 그친다.

따라서 성능 관리의 1순위는
**정확한 통계의 설계·수집·검증·운용**이다.
