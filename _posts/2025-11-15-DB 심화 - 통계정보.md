---
layout: post
title: DB 심화 - 통계정보
date: 2025-11-15 19:25:23 +0900
category: DB 심화
---
# 통계정보(Statistics)

> 실행 후에는 반드시 **실측 플랜**을 확인하세요.
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'));
```

---

## 0) 실습 스키마 & 데이터 준비
```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

-- 예제 테이블/인덱스
DROP TABLE CUST PURGE;
DROP TABLE ORD  PURGE;
DROP TABLE PROD PURGE;

CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8) NOT NULL,   -- 스큐 유도: 'KOR' 편중
  TIER    VARCHAR2(8) NOT NULL    -- 'VIP','GOLD','SILVER','GEN'
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL, -- 'ELEC','FOOD','TOY','HOME','FASH'
  BRAND    VARCHAR2(12) NOT NULL  -- 스큐 유도: 'B0' 다수
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  ORDER_DT DATE   NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL
);

CREATE INDEX IX_CUST_REGION ON CUST(REGION, CUST_ID);
CREATE INDEX IX_PROD_CAT    ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_ORD_CUST    ON ORD(CUST_ID);
CREATE INDEX IX_ORD_PROD_DT ON ORD(PROD_ID, ORDER_DT);

-- 샘플 데이터(스큐 포함)
BEGIN
  FOR c IN 1..50000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,5) WHEN 0 THEN 'KOR' WHEN 1 THEN 'KOR' WHEN 2 THEN 'APAC'
                    WHEN 3 THEN 'EMEA' ELSE 'AMER' END,
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
                    WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..12000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
                    WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 3000 THEN 'B0' ELSE 'B'||TO_CHAR(MOD(p,50)) END
    );
  END LOOP;

  FOR o IN 1..200000 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,50000)+1,
      MOD(o,12000)+1,
      DATE '2024-01-01' + MOD(o,365),
      1 + MOD(o,5),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;

  COMMIT;
END;
/
```

---

# 1. 테이블 통계(Table Statistics)

## 1.1 테이블 통계란?
- **행 수(NUM_ROWS)**, **블록 수(BLOCKS/AVG_ROW_LEN)**, **샘플링 비율**, 파티션 요약 등.  
- 옵티마이저는 이를 기반으로 **카디널리티**를 추정합니다.  
- 기본 선택도 모델(단일 조건)은 대략:
$$
\text{Card} \approx \text{NUM\_ROWS} \times \text{Selectivity}
$$

## 1.2 수집(GATHER) — 자동/수동/증분
```sql
-- 전체 수집: CASCADE=TRUE → 관련 인덱스도 함께
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORD',
    cascade    => TRUE,
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR ALL COLUMNS SIZE AUTO' -- 히스토그램 자동 판단
  );
END;
/
```
- **AUTO_SAMPLE_SIZE**: 버전별로 샘플링/추정 방식이 개선됨.  
- **CASCADE**로 인덱스 통계도 함께 수집(아래 2절 참고).  
- **method_opt**는 컬럼 통계/히스토그램 정책(3절).

### 파티셔닝 테이블에서의 **증분 통계(Incremental Global Stats)**
- 대규모 파티션 테이블에서 **신규/변경 파티션만** 재수집하고, 글로벌 통계는 **시놉시스**로 합성.
```sql
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','INCREMENTAL','TRUE');
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','GRANULARITY','AUTO');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD', cascade=>TRUE);
END;
/
```

## 1.3 조회/검증
```sql
SELECT table_name, num_rows, blocks, avg_row_len, last_analyzed, stale_stats
FROM   user_tab_statistics
WHERE  table_name IN ('CUST','PROD','ORD');

-- 파티션: USER_TAB_STATISTICS / USER_TAB_PARTITIONS / USER_TAB_SUBPARTITIONS
```

## 1.4 사례: 통계가 없을 때 vs 있을 때
```sql
-- 통계 미수집 가정(혹은 삭제)
EXEC DBMS_STATS.DELETE_TABLE_STATS(USER,'PROD');

EXPLAIN PLAN FOR
SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 다시 수집 + 히스토그램(3절 참고)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt=>'FOR COLUMNS SIZE 254 BRAND');
END;
/
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
- 통계/히스토그램 유무에 따라 **인덱스 vs FFS/풀스캔** 선택이 바뀝니다.

---

# 2. 인덱스 통계(Index Statistics)

## 2.1 인덱스 통계란?
- **BLEVEL, LEAF_BLOCKS, DISTINCT_KEYS(NDV), CLUSTERING_FACTOR, AVG_LEAF_BLOCKS_PER_KEY** 등.  
- 특히 **CLUSTERING_FACTOR(CF)**는 “인덱스 순서와 테이블 물리 순서의 일치도”를 나타내며,  
  **NL 조인 랜덤 액세스 비용** 산정에 **중요**합니다. CF가 낮을수록(=정렬 정도 ↑) 유리.

## 2.2 수집
```sql
BEGIN
  DBMS_STATS.GATHER_INDEX_STATS(USER,'IX_ORD_PROD_DT');
END;
/
```
- **CASCADE=TRUE**로 테이블 수집 시 함께 수집되도록 하는 것이 일반적.

## 2.3 조회
```sql
SELECT index_name, blevel, leaf_blocks, distinct_keys, clustering_factor, num_rows, last_analyzed
FROM   user_indexes
WHERE  table_name='ORD';

SELECT * 
FROM   user_ind_statistics
WHERE  index_name='IX_ORD_PROD_DT';
```

## 2.4 CF의 의미와 튜닝 포인트
- CF가 **NUM_ROWS에 근접(높음)** → **랜덤 I/O 많음**(힙 테이블이 인덱스 키 순으로 흩어짐).  
- 개선책: **IOT**(PK 기반 정렬 저장), **파티션 정렬 로드**, **CTAS+ORDER BY**로 힙 정렬 후 인덱스 생성, **클러스터 테이블**.

---

# 3. 컬럼 통계(Column Statistics) — 히스토그램/확장통계

## 3.1 컬럼 통계란?
- **NDV(서로 다른 값 수), NULL 비율, LOW/HIGH 값** 등.  
- 희소/편중(스큐)이 큰 컬럼은 **히스토그램**으로 반영해야 **선택도 오판**을 줄일 수 있습니다.

## 3.2 히스토그램 유형(버전 의존)
- **Frequency / Top-Frequency**: 최빈값 중심, **카테고리형 스큐**에 적합.  
- **Height-Balanced/Hybrid**: 구간 균형 기반(버전에 따라 구현 차이).  
- 자동 정책(AUTO)은 **필요하다고 판단한 컬럼**에만 생성.

### 수집/삭제
```sql
-- 특정 컬럼 히스토그램 강제
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND'
  );
END;
/

-- 히스토그램 제거(빈도 균등 가정으로 회귀)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 1 BRAND'
  );
END;
/
```

### 확인
```sql
SELECT column_name, num_distinct, histogram, density, last_analyzed
FROM   user_tab_col_statistics
WHERE  table_name='PROD';
```

## 3.3 확장 통계(Extended Stats) — 컬럼 그룹/표현식
- 컬럼 간 **상관관계**가 크면 **그룹 통계**로 결합 선택도를 보정.
```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)'); -- 그룹
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/

SELECT extension_name, extension, creator, droppable
FROM   user_stat_extensions
WHERE  table_name='CUST';
```
- 자주 쓰는 표현식에 대한 **표현식 통계**(가상 컬럼+FBI로 대체하는 방법도 있음).

## 3.4 예제 — 히스토그램/확장 통계 효과
```sql
-- 1) 히스토그램 없이: BRAND='B0' vs 'B47' 같은 플랜일 가능성(균등 가정)
EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 2) 히스토그램 적용
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND');
END;
/
EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 3) 상관관계(확장통계) 없을 때의 오판 vs 있을 때
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   CUST
WHERE  REGION='KOR' AND TIER='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   CUST
WHERE  REGION='KOR' AND TIER='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

# 4. 시스템 통계(System Statistics)

## 4.1 시스템 통계란?
- 옵티마이저가 **CPU/IO 성능**, **멀티블록 읽기 크기**, **싱글/멀티블록 읽기 시간** 등을 알아야 **비용 모델**을 현실화합니다.  
- 예: SSD 환경에서 **랜덤 I/O 비용**이 기존 HDD 대비 낮다면, **인덱스 경로의 비용**을 과대평가하지 않도록 조정.

## 4.2 수집 모드
- **NOWORKLOAD**: DB를 멈추지 않고 대략적인 값(기본 추천).  
- **WORKLOAD**: 실제 워크로드 구간에 대한 측정(운영 환경에서 신중).  

### NOWORKLOAD 예
```sql
BEGIN
  DBMS_STATS.GATHER_SYSTEM_STATS('NOWORKLOAD');
END;
/

SELECT pname, pval1
FROM   sys.aux_stats$
WHERE  sname='SYSSTATS_MAIN';
```
> 주요 파라미터(버전 의존): `CPUSPEEDNW`, `SREADTIM`(single-block read time), `MREADTIM`(multi-block read time), `MBRC`(multi-block read count), `CPUSPEED` 등.

### WORKLOAD 예(개념)
```sql
-- 1) 시작
BEGIN DBMS_STATS.GATHER_SYSTEM_STATS('START'); END;
-- 실제 워크로드를 대표하는 시간 동안 대기
-- 2) 중지/저장
BEGIN DBMS_STATS.GATHER_SYSTEM_STATS('STOP'); END;
```
> 가능한 한 **대표성 있는 타임슬라이스**에서 수행하세요.

## 4.3 시스템 통계의 영향
- **멀티블록 읽기**가 상대적으로 매우 빠르면, **Table Full Scan/Index FFS**가 더 선호.  
- 반대로 **싱글블록 읽기**가 더 빠르면, **인덱스 기반 랜덤 액세스** 선호.  
- 서버/스토리지 교체/구성 변경 후 **반드시 재수집**을 고려하세요.

---

# 5. 통계 운용 고급 — 자동 통계, Pending(대기) 통계, Export/Import/Lock

## 5.1 자동 통계 & STALE_PERCENT
- 자동 통계(집계 작업)가 **변경량(예: 10%)**을 기준으로 **Stale** 판단.  
- 많이 변하는 테이블은 **더 낮은 STALE_PERCENT**로 설정 가능.

```sql
-- 테이블 단위 통계 선호 설정(Preferences)
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','STALE_PERCENT','5'); -- 5%만 변해도 수집
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','NO_INVALIDATE','TRUE'); -- 플랜 무효화 지연
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','PUBLISH','TRUE');       -- 바로 게시
END;
/
```

## 5.2 Pending Stats(검증 후 게시)
- **PUBLISH=FALSE**로 수집 → 테스트 세션에서 **pending stats만 보이도록** → 검증 후 게시.
```sql
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'PROD','PUBLISH','FALSE');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE);
END;
/

-- 테스트 세션에서 pending stats 사용
ALTER SESSION SET optimizer_use_pending_statistics = TRUE;

-- 검증 이후 게시
BEGIN
  DBMS_STATS.PUBLISH_PENDING_STATS(USER,'PROD');
END;
/
```

## 5.3 Export/Import, Restore, Lock
```sql
-- Export
EXEC DBMS_STATS.CREATE_STAT_TABLE(USER,'STAT_BACKUP');
EXEC DBMS_STATS.EXPORT_TABLE_STATS(USER,'ORD','STAT_BACKUP');

-- Import
EXEC DBMS_STATS.IMPORT_TABLE_STATS(USER,'ORD','STAT_BACKUP');

-- Restore(최근 스냅샷 시점으로 복구)
EXEC DBMS_STATS.RESTORE_TABLE_STATS(USER,'ORD', SYSTIMESTAMP - INTERVAL '1' HOUR);

-- Lock(자동 수집 방지)
EXEC DBMS_STATS.LOCK_TABLE_STATS(USER,'ORD');
-- Unlock
EXEC DBMS_STATS.UNLOCK_TABLE_STATS(USER,'ORD');
```

---

# 6. 통계가 실행계획에 미치는 영향 — 실전 시나리오

## 6.1 히스토그램 유무에 따른 플랜 차이
```sql
-- 1) 히스토그램 제거
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', method_opt=>'FOR COLUMNS SIZE 1 BRAND');
END;
/
EXPLAIN PLAN FOR
SELECT /* no hist */ COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 2) 히스토그램 생성
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', method_opt=>'FOR COLUMNS SIZE 254 BRAND');
END;
/
EXPLAIN PLAN FOR
SELECT /* hist on */ COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
- `BRAND='B0'`가 **대량값**이면 풀/FFS가 유리한데, 히스토그램 없으면 **인덱스 스캔**을 잘못 선택할 수 있습니다.

## 6.2 확장 통계로 결합 선택도 보정
```sql
-- 확장 통계 미적용
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM CUST WHERE REGION='KOR' AND TIER='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 확장 통계 적용
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM CUST WHERE REGION='KOR' AND TIER='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
- 상관관계를 반영하면 **카디널리티 추정 정확도**가 올라가 **조인 순서/방법**이 개선됩니다.

## 6.3 인덱스 CF가 조인 방식에 미치는 영향
```sql
-- CF 확인
SELECT index_name, clustering_factor, num_rows
FROM   user_indexes
WHERE  table_name='ORD';

-- CF가 높으면(=랜덤 액세스 많음) NL 조인 비용이 크게 산정 → 해시 조인 선호 증가
EXPLAIN PLAN FOR
SELECT SUM(o.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
WHERE  c.region='KOR';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 6.4 시스템 통계에 따른 스캔 선호 변화(개념)
```sql
-- NOWORKLOAD 수집 후, 같은 쿼리의 FFS/인덱스 선호가 달라질 수 있음
BEGIN
  DBMS_STATS.GATHER_SYSTEM_STATS('NOWORKLOAD');
END;
/
EXPLAIN PLAN FOR SELECT COUNT(*) FROM ORD WHERE ORDER_DT BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

# 7. 실무 체크리스트

## 7.1 테이블/인덱스 통계
- [ ] 변경 많은 테이블은 **짧은 주기**로 수집, 파티션 테이블은 **증분** 활용.  
- [ ] 인덱스 **CF/NDV/LEAF_BLOCKS** 확인 → 조인 방식/경로 납득.  
- [ ] **CASCADE**로 인덱스 통계 누락 방지.

## 7.2 컬럼 통계
- [ ] 스큐 컬럼은 **히스토그램**(`SIZE 254` 등),  
- [ ] 강한 상관관계는 **확장 통계**(컬럼 그룹/표현식).  
- [ ] 불필요한 히스토그램 남발은 **플랜 변동성**↑ → **정말 필요한 곳만**.

## 7.3 시스템 통계
- [ ] 스토리지/CPU 변경 후 **NOWORKLOAD**라도 재수집.  
- [ ] **SREADTIM/MREADTIM/MBRC** 값이 현실과 동떨어지지 않는지 점검.

## 7.4 운용
- [ ] **PENDING STATS**로 검증 후 게시(핵심 테이블).  
- [ ] **EXPORT/IMPORT/RESTORE/LOCK**로 재현성과 안전망 확보.  
- [ ] 자동 통계 정책: `STALE_PERCENT`, `NO_INVALIDATE`, `INCREMENTAL` 등 **Table Prefs**로 조정.

---

# 8. 부록 — 자주 쓰는 DBMS_STATS 스니펫

## 8.1 전체 스키마 한 번에
```sql
BEGIN
  DBMS_STATS.GATHER_SCHEMA_STATS(
    ownname          => USER,
    options          => 'GATHER',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE AUTO',
    cascade          => TRUE
  );
END;
/
```

## 8.2 특정 컬럼만 히스토그램
```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND, FOR ALL COLUMNS SIZE 1'
  );
END;
/
```

## 8.3 파티션 테이블 증분
```sql
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','INCREMENTAL','TRUE');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD',granularity=>'AUTO',cascade=>TRUE);
END;
/
```

## 8.4 Pending → Publish
```sql
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(USER,'ORD','PUBLISH','FALSE');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD',cascade=>TRUE);
END;
/
ALTER SESSION SET optimizer_use_pending_statistics = TRUE;
-- 테스트 후
BEGIN DBMS_STATS.PUBLISH_PENDING_STATS(USER,'ORD'); END; /
```

## 8.5 통계 백업/복구
```sql
EXEC DBMS_STATS.CREATE_STAT_TABLE(USER,'STAT_BKP');
EXEC DBMS_STATS.EXPORT_SCHEMA_STATS(USER,'STAT_BKP');
-- 필요 시
EXEC DBMS_STATS.IMPORT_SCHEMA_STATS(USER,'STAT_BKP');
```

---

## 마무리
- **테이블/인덱스/컬럼/시스템 통계**는 옵티마이저의 **눈과 귀**입니다.  
- **정확한 테이블/인덱스 통계**로 기본 크기/랜덤성, **히스토그램/확장 통계**로 스큐·상관관계를 전달하고,  
  **시스템 통계**로 하드웨어 특성을 알려줘야 **현실적인 비용 모델**이 성립합니다.  
- 자동 통계를 맹신하지 말고, **증분/대기/백업/잠금** 등 운용 도구로 **안정성과 재현성**을 확보하세요.  
- 모든 변경은 **DBMS_XPLAN 실측**과 **AWR/ASH 관측**으로 검증하는 습관이 **성공적인 성능 관리의 정석**입니다.