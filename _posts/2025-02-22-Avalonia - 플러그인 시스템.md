---
layout: post
title: Avalonia - 플러그인 시스템
date: 2025-02-22 20:20:23 +0900
category: Avalonia
---
# Avalonia에서 플러그인 시스템 구현하기

핵심 주제는 다음과 같다.

- 계약(Contract)·메타데이터·수명주기(Lifecycle) 명확화
- 로더 계층(탐색→검증→로드→활성화→언로드) 분리
- DI·메시지버스·권한(역할/권한 정책)과 결합
- UI 확장(메뉴/탭/페이지/설정 패널/커맨드) 모델링
- 버전 호환성·보안·샌드박싱·예외 격리
- 핫 리로드(FileSystemWatcher)와 언로드(collectible `AssemblyLoadContext`)
- 테스트·배포 전략(NuGet/Zip/DLL 폴더) 및 운영 가이드

---

## 목표와 용어

| 용어 | 설명 |
|------|------|
| Host(메인 앱) | Avalonia 실행 프로세스, 플러그인을 관리하는 주체 |
| Plugin | Host 외부의 독립 DLL. 계약을 구현하여 기능/UI 제공 |
| Contract | Host와 Plugin 간 상호작용 규약(인터페이스/DTO/이벤트) |
| Descriptor | 플러그인 메타데이터(이름, 버전, 의존성, 권한 등) |
| Loader | DLL 탐색/검증/로드/활성화/언로드를 담당하는 구성요소 |
| Extension Point | Host가 노출하는 확장 지점(메뉴, 페이지, 커맨드 등) |

---

## 상위 설계: 계약과 수명주기

### 설계

UI를 포함할 수 있는 범용 계약:

```csharp
public interface IPlugin
{
    string Id { get; }            // 고유 ID (e.g., "com.example.report")
    string Name { get; }          // 사용자 표시명
    string Version { get; }       // "1.2.3" (SemVer 권장)
    void Initialize(IPluginContext context);
    void Shutdown();              // 언로드/종료 시 정리
}
```

UI 확장을 위한 선택적 인터페이스:

```csharp
// 하나의 메인 View를 제공하는 플러그인
public interface IViewPlugin
{
    Control GetMainView();
}

// 메뉴/툴바에 항목을 기여하는 플러그인
public interface IMenuContribution
{
    IEnumerable<MenuItemDescriptor> GetMenuItems();
}

// 네비게이션(탭/페이지) 항목을 기여
public interface INavigationContribution
{
    IEnumerable<NavigationItemDescriptor> GetNavigationItems();
}

// 명령(Command)형 기능(비 UI) 제공
public interface ICommandPlugin
{
    IEnumerable<CommandDescriptor> GetCommands();
}
```

Descriptor 예시:

```csharp
public sealed record MenuItemDescriptor(
    string Header, string? IconKey, string? PolicyName, Action OnClick);

public sealed record NavigationItemDescriptor(
    string Title, Func<Control> ViewFactory, string? PolicyName);

public sealed record CommandDescriptor(
    string Name, string? PolicyName, Func<CancellationToken, Task> ExecuteAsync);
```

권한(역할/정책) 연계를 위해 `PolicyName`을 부여하여 Host의 AuthorizationService와 연동한다.

### 플러그인 컨텍스트

플러그인에게 Host의 기능을 주입:

```csharp
public interface IPluginContext
{
    IServiceProvider Services { get; }               // DI Root
    IEventBus EventBus { get; }                      // 메시지 버스(옵션)
    IAuthorizationService Authorization { get; }     // 정책 평가
    ISettingsService Settings { get; }               // 저장소(플러그인 설정)
    ILoggingFactory LoggerFactory { get; }           // 로깅
    CultureInfo UICulture { get; }                   // i18n
}
```

Host에서 `IPluginContext` 구현체를 만들어 `Initialize`에 전달하면 플러그인이 Host의 인프라를 사용할 수 있다.

### 수명주기

1) 탐색(Discover) → 2) 검증(Validate) → 3) 로드(Load) → 4) 활성화(Initialize/등록)
→ 5) 사용(메뉴/뷰/명령 노출) → 6) 언로드(Shutdown + ALC Unload)

---

## 메타데이터와 매니페스트

런타임 반영을 위해 매니페스트(JSON) 파일과 어셈블리 속성 둘 중 하나 혹은 둘 다 지원한다.

### 매니페스트 구조 예시 (`plugin.json`)

```json
{
  "id": "com.example.report",
  "name": "Report Plugin",
  "version": "1.4.0",
  "entryType": "Example.ReportPlugin",
  "targetHostVersion": ">=1.0.0 <2.0.0",
  "dependencies": [
    { "id": "com.example.core", "version": ">=1.2.0" }
  ],
  "policies": ["Reports.View", "Reports.Export"]
}
```

### Host 측 모델

```csharp
public sealed class PluginManifest
{
    public string Id { get; init; } = "";
    public string Name { get; init; } = "";
    public string Version { get; init; } = "";
    public string EntryType { get; init; } = ""; // IPlugin 구현 타입의 정규명
    public string? TargetHostVersion { get; init; } // SemVer range
    public string[]? Policies { get; init; }
    public DependencySpec[]? Dependencies { get; init; }
}

public sealed record DependencySpec(string Id, string Version);
```

---

## 로더 아키텍처(탐색→검증→로드→활성화→언로드)

### 로더 구성요소

```csharp
public interface IPluginLoader
{
    IReadOnlyList<LoadedPlugin> LoadAll(string pluginRoot, IPluginContext context);
    bool TryUnload(string pluginId);
}

public sealed class LoadedPlugin
{
    public PluginManifest Manifest { get; init; } = default!;
    public IPlugin Instance { get; init; } = default!;
    public AssemblyLoadContext LoadContext { get; init; } = default!;
    public Assembly Assembly { get; init; } = default!;
}
```

### Collectible AssemblyLoadContext

.NET 7/8에서 **수거 가능한(collectible)** ALC를 사용하여 **실제 언로드**가 가능하다.

```csharp
public sealed class PluginLoadContext : AssemblyLoadContext
{
    private readonly string _pluginDir;

    public PluginLoadContext(string pluginDir, bool isCollectible = true)
        : base(Path.GetFileName(pluginDir), isCollectible)
    {
        _pluginDir = pluginDir;
    }

    protected override Assembly? Load(AssemblyName assemblyName)
    {
        var candidate = Path.Combine(_pluginDir, assemblyName.Name + ".dll");
        if (File.Exists(candidate))
            return LoadFromAssemblyPath(candidate);

        return null; // 기본 Load 컨텍스트로 위임
    }
}
```

### 로더 구현(요약)

```csharp
public sealed class PluginLoader : IPluginLoader
{
    private readonly Dictionary<string, LoadedPlugin> _loaded = new();

    public IReadOnlyList<LoadedPlugin> LoadAll(string root, IPluginContext ctx)
    {
        var result = new List<LoadedPlugin>();
        if (!Directory.Exists(root)) return result;

        foreach (var dir in Directory.GetDirectories(root))
        {
            var manifestPath = Path.Combine(dir, "plugin.json");
            if (!File.Exists(manifestPath)) continue;

            var manifest = JsonSerializer.Deserialize<PluginManifest>(
                File.ReadAllText(manifestPath));
            if (manifest is null) continue;

            if (!ValidateManifest(manifest)) continue;
            if (!CheckHostVersion(manifest)) continue;

            var mainDll = FindMainAssemblyPath(dir, manifest.EntryType);
            if (mainDll is null) continue;

            try
            {
                var alc = new PluginLoadContext(dir, isCollectible: true);
                var asm = alc.LoadFromAssemblyPath(mainDll);
                var type = asm.GetType(manifest.EntryType, throwOnError: true)!;

                if (Activator.CreateInstance(type) is not IPlugin plugin)
                    throw new InvalidOperationException("Entry type is not IPlugin.");

                // Initialize에 실패하더라도 ALC를 정리할 수 있도록 예외 관리
                plugin.Initialize(ctx);

                var lp = new LoadedPlugin
                {
                    Manifest = manifest,
                    Instance = plugin,
                    LoadContext = alc,
                    Assembly = asm
                };

                _loaded[manifest.Id] = lp;
                result.Add(lp);
            }
            catch (Exception ex)
            {
                // 로깅 및 실패 처리
                // alc?.Unload() 필요시 보장
                Console.WriteLine($"[Plugin Load Failed] {dir}: {ex.Message}");
            }
        }
        return result;
    }

    public bool TryUnload(string pluginId)
    {
        if (!_loaded.TryGetValue(pluginId, out var lp))
            return false;

        try
        {
            lp.Instance.Shutdown();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Plugin Shutdown Error] {pluginId}: {ex.Message}");
        }

        _loaded.Remove(pluginId);

        lp.LoadContext.Unload();
        GC.Collect();
        GC.WaitForPendingFinalizers();

        return true;
    }

    private static bool ValidateManifest(PluginManifest m)
    {
        if (string.IsNullOrWhiteSpace(m.Id)) return false;
        if (string.IsNullOrWhiteSpace(m.EntryType)) return false;
        if (string.IsNullOrWhiteSpace(m.Version)) return false;
        return true;
    }

    private static bool CheckHostVersion(PluginManifest m)
    {
        // 필요 시 SemVer 범위 파서로 Host 버전과 비교
        return true;
    }

    private static string? FindMainAssemblyPath(string dir, string entryType)
    {
        // EntryType의 어셈블리명 추정
        var idx = entryType.IndexOf(',');
        if (idx > 0)
        {
            var asmName = entryType[(idx + 1)..].Trim();
            var path = Path.Combine(dir, asmName + ".dll");
            if (File.Exists(path)) return path;
        }
        // fallback: dir 내 DLL을 순회하며 타입을 찾는 방식(비권장)
        foreach (var dll in Directory.GetFiles(dir, "*.dll"))
        {
            try
            {
                using var asm = AssemblyLoadContext.Default.LoadFromStream(File.OpenRead(dll));
                // 임시 탐색은 권장하지 않음. 매니페스트에 정확히 명시하도록 유도
            }
            catch { }
        }
        return null;
    }
}
```

> 주의: 상기 `FindMainAssemblyPath`의 fallback 탐색은 권장되지 않는다. **반드시 매니페스트에 EntryType 의 어셈블리명을 정확히 명시**하도록 설계하자.

---

## Host와 DI·권한·로깅·설정·버스 통합

### Host 서비스 준비

```csharp
public interface IEventBus
{
    void Publish<T>(T message) where T : class;
    IDisposable Subscribe<T>(Action<T> handler) where T : class;
}

public interface ILoggingFactory
{
    ILogger CreateLogger(string category);
}

public interface ISettingsService
{
    Task<object?> GetAsync(string scope, string key);
    Task SetAsync(string scope, string key, object value);
}
```

Host에서 DI 구성:

```csharp
// App.xaml.cs or bootstrapper
services.AddSingleton<AppAuthState>();
services.AddSingleton<IAuthorizationService, AuthorizationService>();
services.AddSingleton<IEventBus, SimpleEventBus>();
services.AddSingleton<ILoggingFactory, SerilogLoggingFactory>();
services.AddSingleton<ISettingsService, JsonSettingsService>();

services.AddSingleton<IPluginLoader, PluginLoader>();
services.AddSingleton<IPluginContext>(sp =>
    new PluginContext(
        sp,
        sp.GetRequiredService<IEventBus>(),
        sp.GetRequiredService<IAuthorizationService>(),
        sp.GetRequiredService<ISettingsService>(),
        sp.GetRequiredService<ILoggingFactory>(),
        CultureInfo.CurrentUICulture));
```

컨텍스트 구현:

```csharp
public sealed class PluginContext : IPluginContext
{
    public IServiceProvider Services { get; }
    public IEventBus EventBus { get; }
    public IAuthorizationService Authorization { get; }
    public ISettingsService Settings { get; }
    public ILoggingFactory LoggerFactory { get; }
    public CultureInfo UICulture { get; }

    public PluginContext(IServiceProvider services, IEventBus eventBus,
        IAuthorizationService auth, ISettingsService settings,
        ILoggingFactory loggerFactory, CultureInfo uiCulture)
    {
        Services = services;
        EventBus = eventBus;
        Authorization = auth;
        Settings = settings;
        LoggerFactory = loggerFactory;
        UICulture = uiCulture;
    }
}
```

---

## UI 통합: 메뉴/탭/페이지 생성과 바인딩

### 플러그인의 UI 제공 방식

- `IViewPlugin.GetMainView()`로 단일 View 제공(간단)
- `INavigationContribution`으로 여러 페이지 제공(확장성)
- `IMenuContribution`으로 메뉴 항목 제공

Host ViewModel에서 동적으로 수집:

```csharp
public sealed class ShellViewModel : ReactiveUI.ReactiveObject
{
    private readonly ObservableCollection<object> _navigationItems = new();
    public ReadOnlyObservableCollection<object> NavigationItems { get; }

    public ObservableCollection<MenuItem> DynamicMenus { get; } = new();

    public ShellViewModel(IPluginLoader loader, IPluginContext ctx)
    {
        NavigationItems = new(_navigationItems);

        var loaded = loader.LoadAll("Plugins", ctx);
        foreach (var lp in loaded)
        {
            if (lp.Instance is INavigationContribution nav)
            {
                foreach (var item in nav.GetNavigationItems())
                {
                    if (string.IsNullOrEmpty(item.PolicyName) ||
                        ctx.Authorization.Evaluate(item.PolicyName))
                    {
                        _navigationItems.Add(new
                        {
                            item.Title,
                            ViewFactory = item.ViewFactory
                        });
                    }
                }
            }

            if (lp.Instance is IMenuContribution menu)
            {
                foreach (var m in menu.GetMenuItems())
                {
                    if (!string.IsNullOrEmpty(m.PolicyName) &&
                        !ctx.Authorization.Evaluate(m.PolicyName)) continue;

                    var mi = new MenuItem { Header = m.Header };
                    mi.Click += (_, __) => m.OnClick();
                    DynamicMenus.Add(mi);
                }
            }
        }
    }
}
```

### Avalonia XAML 조합

```xml
<DockPanel>
  <Menu DockPanel.Dock="Top">
    <MenuItem Header="플러그인">
      <ItemsControl Items="{Binding DynamicMenus}"/>
    </MenuItem>
  </Menu>

  <TabControl Items="{Binding NavigationItems}">
    <TabControl.ItemTemplate>
      <DataTemplate>
        <TextBlock Text="{Binding Title}" />
      </DataTemplate>
    </TabControl.ItemTemplate>
    <TabControl.ContentTemplate>
      <DataTemplate>
        <ContentControl Content="{Binding ViewFactory, Converter={StaticResource FuncToControlConverter}}" />
      </DataTemplate>
    </TabControl.ContentTemplate>
  </TabControl>
</DockPanel>
```

`FuncToControlConverter`는 `Func<Control>`을 즉시 호출해 `Control` 반환:

```csharp
public sealed class FuncToControlConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
        => value is Func<Control> f ? f() : null;

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
        => throw new NotSupportedException();
}
```

---

## 예시 플러그인 구현

### 매니페스트

```
Plugins/ReportPlugin/
  plugin.json
  ReportPlugin.dll
  ReportView.axaml
  Resources/...
```

```json
{
  "id": "com.example.report",
  "name": "Report Plugin",
  "version": "1.4.0",
  "entryType": "ReportPlugin.ReportPlugin, ReportPlugin",
  "targetHostVersion": ">=1.0.0",
  "policies": ["Reports.View", "Reports.Export"]
}
```

### 코드

```csharp
namespace ReportPlugin;

public sealed class ReportPlugin : IPlugin, INavigationContribution, IMenuContribution
{
    private IPluginContext _ctx = default!;
    private ILogger _log = default!;

    public string Id => "com.example.report";
    public string Name => "Report Plugin";
    public string Version => "1.4.0";

    public void Initialize(IPluginContext context)
    {
        _ctx = context;
        _log = _ctx.LoggerFactory.CreateLogger("ReportPlugin");
        _log.Info("Initialized.");
    }

    public void Shutdown()
    {
        _log.Info("Shutdown.");
    }

    public IEnumerable<NavigationItemDescriptor> GetNavigationItems()
    {
        yield return new NavigationItemDescriptor(
            "보고서",
            ViewFactory: () => new ReportView(),
            PolicyName: "Reports.View");
    }

    public IEnumerable<MenuItemDescriptor> GetMenuItems()
    {
        yield return new MenuItemDescriptor(
            Header: "보고서 내보내기",
            IconKey: null,
            PolicyName: "Reports.Export",
            OnClick: async () => await ExportAsync());
    }

    private async Task ExportAsync()
    {
        try
        {
            // 실제 내보내기 작업
            await Task.Delay(300);
            _log.Info("Report exported.");
        }
        catch (Exception ex)
        {
            _log.Error("Export failed: " + ex.Message);
        }
    }
}
```

`ReportView.axaml`는 플러그인 어셈블리 리소스로 포함 가능: Avalonia는 동일 어셈블리 내 XAML을 로드한다.

---

## 핫 리로드와 언로드

### 파일 변경 감지

```csharp
public sealed class PluginWatcher : IDisposable
{
    private readonly FileSystemWatcher _fsw;
    private readonly IPluginLoader _loader;
    private readonly IPluginContext _ctx;

    public PluginWatcher(string root, IPluginLoader loader, IPluginContext ctx)
    {
        _loader = loader;
        _ctx = ctx;
        _fsw = new FileSystemWatcher(root, "*.*")
        {
            IncludeSubdirectories = true,
            EnableRaisingEvents = true
        };
        _fsw.Created += OnChanged;
        _fsw.Changed += OnChanged;
        _fsw.Renamed += OnChanged;
        _fsw.Deleted += OnChanged;
    }

    private void OnChanged(object sender, FileSystemEventArgs e)
    {
        // 간단한 전략: 짧은 지연 후 전체 리로드(또는 해당 플러그인만 리로드)
        Task.Delay(500).ContinueWith(_ =>
        {
            // 실제 구현: pluginId를 식별해 TryUnload→Load
            _loader.LoadAll("Plugins", _ctx);
        });
    }

    public void Dispose()
    {
        _fsw.Dispose();
    }
}
```

### 언로드 주의점

- 언로드 전에 `Shutdown()` 호출로 플러그인 내부 리소스를 해제
- 이벤트 핸들러, 타이머, 스레드, 네이티브 핸들 정리
- ALC.Unload 후 `GC.Collect()`/`WaitForPendingFinalizers()`로 메모리 회수

---

## 보안과 안정성

### 신뢰 경계

- **서명/해시 검증**: 플러그인 설치/업데이트 시 서명된 패키지를 요구
- **권한 정책**: `PolicyName` 기반으로 UI 표시 여부와 더불어 서버 API 접근 시에도 **서버 재검증**
- **리소스 제한**: 대용량 연산/IO를 백그라운드 큐로 격리, Host UI thread 차단 금지
- **예외 격리**: 플러그인에서 던진 예외는 로깅 후 Host를 죽이지 않도록 try/catch

### 샌드박싱(선택)

- .NET 데스크톱에서 프로세스 격리(Out-of-Process) + IPC 통신(예: gRPC/NamedPipe)로 더 강한 격리 가능
- 단점: 배포 복잡도·IPC 설계 필요. 높은 보안 요구 시 고려

---

## 호환성 및 버전 관리

- Host 버전과 플러그인 `TargetHostVersion` SemVer 범위를 비교
- Plugin 간 의존성(다른 플러그인/공유 SDK)에 대한 버전 충돌 감지
- 공용 계약(인터페이스/DTO)은 **하위 호환성**을 유지하는 방향으로 진화
- 중대한 변경점은 `IPluginV2` 등 새 계약으로 도입

---

## i18n/테마/로깅/설정 연동

- 플러그인은 Host의 `ISettingsService`에 **자신의 scope를 구분**하여 사용: `scope = pluginId`
- i18n: 플러그인 어셈블리 리소스(.resx) 또는 JSON 번역 파일을 병행 지원
- 테마: Host의 ThemeService를 컨텍스트로 제공하여 공용 스타일 활용
- 로깅: Host의 로거 팩토리로 플러그인별 카테고리 로깅

```csharp
await _ctx.Settings.SetAsync("com.example.report", "LastExportPath", path);
var last = await _ctx.Settings.GetAsync("com.example.report", "LastExportPath");
```

---

## 테스트 전략

- **계약 단위 테스트**: DTO/Descriptor 직렬화·역직렬화, Policy 평가
- **로더 통합 테스트**: 임시 폴더에 플러그인 배치→로드→Initialize 호출 검증
- **UI 스냅샷 테스트**: `GetMainView()` 결과의 타입/바인딩 최소 검증
- **에러 주입**: Initialize/Shutdown/메뉴 클릭에서 예외 발생 시 Host가 안전한지

---

## 배포 전략

| 방식 | 장점 | 단점 |
|------|------|------|
| DLL 폴더(Plugins/) | 간단, 빠른 배포 | 서명/무결성 관리 별도 |
| Zip 패키지(해제 시 DLL) | 단일 파일 배포, 버전 메타 포함 | 압축 해제/정리 작업 필요 |
| NuGet 피드 | 버전·의존성 관리 우수 | 사설 피드 인프라 필요 |
| 외부 마켓 연동 | UX 좋음 | 샌드박싱/검증 체인 필수 |

운영에서는 **서명된 Zip + 해시 검증** 또는 **사설 NuGet 피드**를 권장.

---

## MEF/Prism/직접 구현 비교

| 항목 | 직접 구현(Reflection) | MEF | Prism(모듈) |
|------|------------------------|-----|-------------|
| 학습 난이도 | 낮음 | 중간 | 중간 |
| 동적 로드/언로드 | 가능(직접) | 가능 | 가능(설정 필요) |
| 메타데이터/필터 | 직접 설계 | 내장 메커니즘 | Prism 모듈 메타 |
| DI 통합 | 자유(Host DI 연계) | MEF Composition | 보통 DI와 함께 |
| 제어/커스터마이징 | 최고 | 높음 | 높음 |
| 의존성 | 최소 | System.ComponentModel.Composition | Prism 패키지 |

**권장**: 처음엔 **직접 구현**으로 시작하고, 구성 복잡도가 올라가면 MEF/Prism으로 전환을 검토.

---

## 완성 예제(요약 조립)

### Host 부트스트랩

```csharp
var services = new ServiceCollection();
// Host infra
services.AddSingleton<AppAuthState>();
services.AddSingleton<IAuthorizationService, AuthorizationService>();
services.AddSingleton<IEventBus, SimpleEventBus>();
services.AddSingleton<ILoggingFactory, SerilogLoggingFactory>();
services.AddSingleton<ISettingsService, JsonSettingsService>();

// Plugin infra
services.AddSingleton<IPluginLoader, PluginLoader>();
services.AddSingleton<IPluginContext>(sp =>
    new PluginContext(sp, sp.GetRequiredService<IEventBus>(),
        sp.GetRequiredService<IAuthorizationService>(),
        sp.GetRequiredService<ISettingsService>(),
        sp.GetRequiredService<ILoggingFactory>(),
        CultureInfo.CurrentUICulture));

var sp = services.BuildServiceProvider();

// 로드
var loader = sp.GetRequiredService<IPluginLoader>();
var ctx    = sp.GetRequiredService<IPluginContext>();
var loaded = loader.LoadAll("Plugins", ctx);

// Shell에 반영
var shellVm = new ShellViewModel(loader, ctx);
```

### 플러그인 템플릿(스캐폴딩)

```csharp
// MyPlugin.csproj: <TargetFramework>net8.0</TargetFramework>, Avalonia 패키지 참조
public sealed class MyPlugin : IPlugin, IViewPlugin
{
    private IPluginContext _ctx = default!;
    public string Id => "com.example.my";
    public string Name => "My Plugin";
    public string Version => "1.0.0";

    public void Initialize(IPluginContext context)
    {
        _ctx = context;
        _ctx.LoggerFactory.CreateLogger("MyPlugin").Info("Initialized");
    }

    public void Shutdown() { }

    public Control GetMainView() => new TextBlock { Text = "Hello from MyPlugin" };
}
```

`plugin.json`:

```json
{
  "id": "com.example.my",
  "name": "My Plugin",
  "version": "1.0.0",
  "entryType": "MyPlugin.MyPlugin, MyPlugin",
  "targetHostVersion": ">=1.0.0"
}
```

---

## 자주 묻는 질문(FAQ)

**Q1. 플러그인 간 공용 모델을 어떻게 공유하나?**
A. 공용 계약 어셈블리를 Host가 배포하고 플러그인이 참조하도록 한다. 하위 호환성을 최우선으로 유지한다.

**Q2. 플러그인이 외부 NuGet을 사용하면 충돌하지 않나?**
A. 플러그인 디렉터리 내부 사본을 사용하도록 ALC가 우선 로드한다. 그래도 충돌이 난다면 계약을 분리하거나 Out-of-Process로 격리한다.

**Q3. 언로드가 안 된다.**
A. 살아있는 스레드/타이머/이벤트 핸들러/네이티브 핸들이 남아 있으면 ALC가 수거되지 않는다. 플러그인에 `Shutdown`에서 모두 정리하도록 강제.

**Q4. 권한 제어를 UI 숨김으로 끝내도 되나?**
A. 아니다. 서버 API에서 **역할/권한을 재검증**해야 한다.

---

## 결론

- **계약·메타데이터·수명주기**를 분명히 정의하고,
- **Collectible ALC**로 동적 로드/언로드를 구현하며,
- **DI/권한/버스/설정/로깅**을 컨텍스트로 주입해 플러그인을 1급 시민으로 대우하고,
- **UI 확장 포인트**(메뉴/탭/명령)를 일관된 Descriptor로 모델링하면,
- Avalonia 기반 데스크톱에서도 **안정적이고 테스트 가능한 플러그인 아키텍처**를 구축할 수 있다.
