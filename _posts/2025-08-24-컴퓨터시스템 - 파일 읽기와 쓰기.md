---
layout: post
title: 컴퓨터시스템 - 파일 읽기와 쓰기
date: 2025-08-24 23:20:23 +0900
category: 컴퓨터시스템
---
# 파일 **읽기와 쓰기**

## 0. 큰 그림: FD ↔ 커널(페이지 캐시) ↔ 저장장치

- 사용자 공간은 **FD(파일 디스크립터)** 로 `read`/`write`를 호출한다.
- 커널은 **파일 오프셋**과 **페이지 캐시**를 관리하며, 캐시에 없으면 블록 I/O를 발행한다.
- **절대 기억**: `read`와 `write`는 **요청한 바이트 수보다 적게 처리**할 수 있다(부분 I/O).
  → **루프/재시도**는 *정상 동작*의 일부다.

```text
App ── read/write ──► Kernel(page cache, file offset) ──► Block Layer ──► Device
```

---

## 1. 기본 API와 반환값의 정확한 의미

### 1.1 `read(2)`
```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
```
- 반환값
  - `> 0`: 실제 읽은 바이트 수(요청보다 **작을 수 있음**)
  - `0`: EOF(일반 파일) / 반대편 종료(파이프·소켓)
  - `-1`: 오류 (`errno` = `EINTR`, `EAGAIN`, `EIO`, `EBADF` 등)

### 1.2 `write(2)`
```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```
- 반환값
  - `>= 0`: 실제 기록한 바이트 수(요청보다 **작을 수 있음**)
  - `-1`: 오류 (`EINTR`, `EAGAIN`, `ENOSPC`, `EDQUOT`, `EPIPE`, `EFBIG` 등)

> **부분 I/O(Short I/O)** 는 오류가 아니다. 특히 **파이프/소켓/비차단 FD** 에서는 일상적이다.
> 일반 파일도 시그널(`EINTR`)·리소스·장치 특성 탓에 부분 쓰기가 날 수 있다고 가정해야 한다.

---

## 2. 견고한 래퍼: “정확히 N바이트” 읽기/쓰기

```c
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>

ssize_t readn(int fd, void *buf, size_t n) {
    size_t left = n; char *p = buf;
    while (left > 0) {
        ssize_t r = read(fd, p, left);
        if (r > 0) { left -= r; p += r; }
        else if (r == 0) break;                // EOF
        else if (errno == EINTR) continue;     // 시그널 → 재시도
        else if (errno == EAGAIN || errno == EWOULDBLOCK) break; // 비차단
        else return -1;
    }
    return (ssize_t)(n - left);                // 실제 읽은 양(EOF면 n 미만)
}

ssize_t writen(int fd, const void *buf, size_t n) {
    size_t left = n; const char *p = buf;
    while (left > 0) {
        ssize_t w = write(fd, p, left);
        if (w > 0) { left -= w; p += w; }
        else if (w < 0 && errno == EINTR) continue;
        else if (w < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
        else return -1;
    }
    return (ssize_t)n;                          // 모두 썼을 때만 n 반환
}
```

> 이 래퍼는 **텍스트/바이너리** 모두 안전하다.
> 단, 소켓/파이프에서는 **상대 측 종료**(read=0)/`EPIPE`(write 시) 처리까지 함께 고려하라.

---

## 3. 파일 오프셋과 위치 지정 I/O

### 3.1 암묵적 오프셋(일반 `read`/`write`)
- 커널이 **open된 파일마다 유지**하는 오프셋을 사용하며, 호출이 성공하면 자동 증가한다.
- **복제 FD(`dup`)** 는 **같은 open file 엔트리**를 공유하므로 **오프셋도 공유**된다.

### 3.2 `pread`/`pwrite` — 오프셋 고정 I/O
```c
#include <unistd.h>
ssize_t pread (int fd, void *buf, size_t n, off_t off);
ssize_t pwrite(int fd, const void *buf, size_t n, off_t off);
```
- **파일 오프셋을 바꾸지 않는다.** 다중 스레드/프로세스가 **같은 FD** 로도 **경쟁 없이** 랜덤 I/O 수행 가능.
- 빌드 플래그 `-D_FILE_OFFSET_BITS=64` 로 대용량 파일(>2GB) 오프셋 보장.

---

## 4. Scatter/Gather I/O — `readv`/`writev`

여러 버퍼를 한 번에 I/O 하는 **벡터화 I/O**:

```c
#include <sys/uio.h>
ssize_t readv (int fd, struct iovec *iov, int iovcnt);
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
```

- 응용: **헤더+바디** 를 한 번의 `writev`로 송신, 커널 경계 횟수↓
```c
struct iovec iov[2] = {
  { .iov_base = header, .iov_len = hlen },
  { .iov_base = body,   .iov_len = blen }
};
ssize_t n = writev(fd, iov, 2);
```

> Linux에는 `preadv2/pwritev2`(플래그: `RWF_SYNC`, `RWF_DSYNC`, `RWF_NOWAIT`, `RWF_APPEND`)도 있다.
> - `RWF_NOWAIT`: 페이지 캐시에 없으면 **즉시 `-1/EAGAIN`**(블록하지 않음)
> - `RWF_APPEND`: 쓰기를 항상 EOF에(파일 플래그 `O_APPEND`와 유사, 보다 명시적)

---

## 5. 블로킹 vs 비차단 I/O

### 5.1 비차단 설정
```c
#include <fcntl.h>
int flag = fcntl(fd, F_GETFL);
fcntl(fd, F_SETFL, flag | O_NONBLOCK);
```
- **읽을 데이터가 없거나** 송신 버퍼가 가득 차면 `-1/EAGAIN` 즉시 반환.

### 5.2 준비된 FD만 다루기 — `select`/`poll`/`epoll`
- **레벨 트리거**(기본) vs **에지 트리거**(상태 변화를 한번만 통지, drain 루프 필요).
- `epoll` 에지 트리거 예(요약):

```c
#include <sys/epoll.h>
int ep = epoll_create1(0);
struct epoll_event ev = {.events = EPOLLIN|EPOLLET, .data.fd = sock};
epoll_ctl(ep, EPOLL_CTL_ADD, sock, &ev);

for(;;){
  struct epoll_event out[64];
  int n = epoll_wait(ep, out, 64, -1);
  for (int i=0;i<n;i++){
    int fd = out[i].data.fd;
    for(;;){ // 에지 트리거: 버퍼를 비울 때까지
      ssize_t r = read(fd, buf, sizeof buf);
      if (r > 0) process(buf, r);
      else if (r == 0) { close(fd); break; }
      else if (errno == EAGAIN || errno == EWOULDBLOCK) break;
      else { /* 오류 처리 */ break; }
    }
  }
}
```

---

## 6. 텍스트/바이너리 & `stdio` 혼용 주의

- UNIX는 텍스트/바이너리 **구분이 없다**(개행 변환 없음). 인코딩은 응용이 책임진다.
- `FILE*` 버퍼와 `write(2)`를 **같은 FD에서 섞어 쓰면** 순서가 꼬일 수 있다.
  → 한쪽만 쓰거나, **`fflush(fp); fsync(fileno(fp));`** 로 경계 명확화.
- 버퍼링 제어:
```c
setvbuf(fp, NULL, _IONBF/*무버퍼*/|_IOLBF/*라인*/|_IOFBF/*풀*/, 0);
```

---

## 7. 내구성(영속성) — `fsync`/`fdatasync`/원자적 교체

- `write` 성공이 **디스크 안전 기록**을 의미하지는 않는다(전원 장애 시 손실).
- **권장 패턴(원자적 교체)**:
  1) 임시 파일에 전체 쓰기 → `fsync(tmpfd)`
  2) **같은 파일시스템**에서 `rename(tmp, dst)` (원자적 교체)
  3) **부모 디렉터리** `fsync(dirfd)` 로 디렉터리 엔트리까지 안전화

```c
// 안전한 교체(요약). openat/renameat + fsync(dir) 포함
```

- `fdatasync`는 **데이터 중심**(메타 최소), `fsync`는 **메타까지** 포함.
- `O_SYNC`/`O_DSYNC`는 각 `write`를 동기화하지만 **처리량 저하**.
  보통은 **배치 쓰기 후 fsync**가 효율적.

---

## 8. 경쟁·원자성·잠금 규칙

- **정규 파일** 쓰기는 **레코드 원자성**이 보장되지 않는다.
  - `O_APPEND`는 “끝에서 쓰기”의 **오프셋 갱신을 원자적**으로 할 뿐,
    “한 레코드가 잘리지 않음”까지 보장하지 않는다(멀티라이터라면 분절 가능).
- **파이프/UNIX 소켓**은 `PIPE_BUF`(통상 4096) **이하** 한 번의 `write`가 **원자적**.
- **로그 설계**:
  - 방법 A: 파일에 `O_APPEND` + *“한 레코드=한 번의 write”* + (필요 시) 파일 잠금
  - 방법 B: `flock`/`fcntl` **advisory** 잠금으로 임계구역 보호

```c
#include <sys/file.h>
int fd = open("app.log", O_WRONLY|O_CREAT|O_APPEND, 0644);
flock(fd, LOCK_EX);                 // 임계구역 시작
writen(fd, rec, len);               // 한 번의 write로 기록
flock(fd, LOCK_UN);                 // 임계구역 종료
```

> 네트워크/원격 FS(NFS 등)에서는 잠금 의미가 다를 수 있으니 해당 환경 문서 확인.

---

## 9. 성능 레버: 버퍼 크기, readahead, Direct I/O

### 9.1 버퍼 크기 선택
- 4KiB~1MiB 범위에서 워크로드에 맞춰 실험.
  너무 작으면 syscall 오버헤드↑, 너무 크면 페이지 캐시 오염·메모리 압박.

### 9.2 접근 힌트 — `posix_fadvise`/`readahead`
```c
#include <fcntl.h>
posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL); // 순차
posix_fadvise(fd, 0, 0, POSIX_FADV_RANDOM);     // 랜덤
posix_fadvise(fd, off, len, POSIX_FADV_DONTNEED); // 캐시에서 버리기
```

### 9.3 Direct I/O — `O_DIRECT`
- 페이지 캐시를 **우회**. DB/스토리지 엔진에서 흔함.
- **정렬 제약**(일반적 가이드): 버퍼 **주소/크기/오프셋**이 512B 또는 4096B 정렬.

```c
#include <stdlib.h>
#include <fcntl.h>
void *buf;
posix_memalign(&buf, 4096, 4096);            // 4KiB 정렬
int fd = open("file.bin", O_RDONLY|O_DIRECT);
ssize_t n = pread(fd, buf, 4096, 0);
```

> Direct I/O는 커널 버전·파일시스템마다 제약이 다르다. **부분 I/O·정렬 오류** 처리를 반드시 넣어라.

---

## 10. 커널 내 복사 경로(제로카피·오프로드)

- `sendfile`: **파일→소켓**(HTTP 서버 등)
- `splice`/`tee`: 파이프 기반 데이터 이동(한쪽에서 읽어 다른 쪽으로 전달)
- `copy_file_range`: **파일↔파일** 직접 복사(오프로드/클론 최적화 가능)

```c
#include <sys/sendfile.h>
off_t off = 0;
sendfile(sock, filefd, &off, length);
```

---

## 11. `mmap` vs `read/write` — 언제 무엇을?

| 항목 | `read/write` | `mmap` |
|---|---|---|
| 접근 모델 | 명시적 복사/시스템콜 | **페이지 폴트** 기반 메모리 접근 |
| 장점 | 단순·제어 용이·이식성↑ | 랜덤 접근 편의, 공유 메모리, 코드 간결 |
| 단점 | syscall 오버헤드 | **SIGBUS/권한** 주의, 폴트 비용·TLB 압박 |
| 쓰기 동기화 | `write` + `fsync` | dirty page → `msync`/`munmap` |

- **대용량 랜덤 읽기**는 `mmap`이 간결하되 **에러 시맨틱(Segv/Sigbus)** 과 **동시 접근 일관성**을 명확히 설계하라.
- `MAP_SHARED` 쓰기와 `write` 혼용 시 **일관성 규칙**을 준수하거나 **경로를 단일화**하라.

---

## 12. 라인/텍스트 I/O 실전 팁

- 긴 줄 파싱: `getline(3)` 권장(버퍼 자동 확장).
```c
#include <stdio.h>
ssize_t len; char *line = NULL; size_t cap = 0;
FILE *fp = fopen("input.txt", "r");
while ((len = getline(&line, &cap, fp)) != -1) {
    // line[0..len-1]
}
free(line); fclose(fp);
```
- 인코딩/정규화는 응용 계층(예: ICU)을 사용. 커널은 개행/인코딩을 다루지 않는다.

---

## 13. 안전·내구성 패턴 모음(코드)

### 13.1 파일 전체 읽기(문자열 반환)
```c
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>

extern ssize_t readn(int, void*, size_t);

char* slurp(const char *path, size_t *out_len) {
    int fd = open(path, O_RDONLY | O_CLOEXEC);
    if (fd < 0) return NULL;
    struct stat st;
    if (fstat(fd, &st) < 0) { close(fd); return NULL; }
    size_t n = (size_t)st.st_size;
    char *buf = malloc(n + 1);
    if (!buf) { close(fd); return NULL; }
    ssize_t r = readn(fd, buf, n);
    if (r < 0) { free(buf); close(fd); return NULL; }
    buf[r] = '\0';
    if (out_len) *out_len = (size_t)r;
    close(fd);
    return buf;
}
```

### 13.2 원자적 교체 + 내구성(임시→fsync→rename→fsync(dir))
```c
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

extern ssize_t writen(int, const void*, size_t);

int replace_atomic(const char *dir, const char *tmp, const char *dst,
                   const void *data, size_t n)
{
    int dfd = open(dir, O_RDONLY|O_DIRECTORY|O_CLOEXEC);
    if (dfd < 0) return -1;

    int tfd = openat(dfd, tmp, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 0644);
    if (tfd < 0) { close(dfd); return -1; }

    if (writen(tfd, data, n) != (ssize_t)n) { close(tfd); close(dfd); return -1; }
    if (fsync(tfd) < 0) { close(tfd); close(dfd); return -1; }
    if (close(tfd) < 0) { close(dfd); return -1; }

    if (renameat(dfd, tmp, dfd, dst) < 0) { close(dfd); return -1; }
    if (fsync(dfd) < 0) { close(dfd); return -1; }
    return close(dfd);
}
```

### 13.3 다중 스레드 랜덤 I/O — `pread/pwrite`
```c
// 같은 fd를 여러 스레드가 공유해도 안전:
// 각 스레드는 자신만의 offset으로 pread/pwrite 사용
void* worker(void* arg){
    // pread(fd, buf, len, my_off);
    // pwrite(fd, buf, len, my_off);
    return NULL;
}
```

### 13.4 `EPIPE`/`SIGPIPE` 방어(소켓·파이프)
```c
#include <signal.h>
signal(SIGPIPE, SIG_IGN); // write 시 상대가 닫으면 -1/EPIPE 반환(프로세스 종료 방지)
```
- Linux 소켓은 `send(..., MSG_NOSIGNAL)` 로 호출 단위 제어도 가능.

---

## 14. 관찰·디버깅

- **시스템콜 추적**: `strace -e trace=read,write,fsync,open,close ./app`
- **성능 카운터**: `perf stat -e cycles,instructions,cache-misses,page-faults,dTLB-load-misses ./app`
- **IO 통계**: `iostat -xz 1`, `pidstat -d 1`
- **페이지 캐시 영향**: `vmtouch`, `/proc/<pid>/smaps` 확인

---

## 15. 플랫폼/FS 고려 사항(요약)

- **대용량 파일**: `-D_FILE_OFFSET_BITS=64` (glibc 계열에서 64비트 오프셋 확보).
- **네트워크 FS**: 캐시 일관성/내구성 의미가 로컬 FS와 다를 수 있음(NFS mount 옵션·sync语의미 확인).
- **저널링 FS**: `rename` 원자성은 **같은 FS 내**에서만. 전원 장애 대비는 **파일→fsync, 디렉터리→fsync** 까지.

---

## 16. 수식·규칙(간단)

### 16.1 쓰기 처리량 근사
$$
\text{Throughput} \approx \frac{\text{총 유효 바이트}}{\text{Syscall 횟수} \times \text{경계 비용} + \text{디바이스 지연}}
$$
→ **큰 I/O(벡터/배치)**, **커널 내 경로(sendfile/copy\_file\_range)**, **readahead** 로 분모를 줄인다.

### 16.2 umask 적용
$$
\text{final\_mode} = \text{requested\_mode} \;\&\; \sim \text{umask}
$$

---

## 17. 체크리스트

- [ ] **부분 I/O** 루프 처리(`EINTR`/`EAGAIN` 포함)
- [ ] **랜덤 I/O/동시성**은 `pread/pwrite` 사용
- [ ] **벡터 I/O**로 헤더+바디를 한 번에(`writev`)
- [ ] **내구성**: 임시→`fsync(file)`→`rename`→`fsync(dir)`
- [ ] **다중 작성자**: `O_APPEND` + “한 레코드=한 write” 또는 **잠금**
- [ ] **성능**: 버퍼 크기 조정, `posix_fadvise`, 필요 시 `O_DIRECT`(정렬 충족)
- [ ] **stdio 혼용 금지**(또는 명시 동기화)
- [ ] **SIGPIPE 방어**, `close` 반환값까지 확인(지연 오류)

---

## 18. 결론

파일 **읽기/쓰기**는 얼핏 단순해 보이지만, **부분 I/O·오프셋·캐시·동기화·경쟁/원자성**이라는 규칙을 이해할 때 비로소 견고해진다.
**`pread/pwrite`** 로 동시성을, **`readv/writev`** 로 경계비용을, **원자적 교체 패턴**으로 **내구성**을, **적절한 버퍼·힌트·Direct I/O**로 **성능**을 잡아라.
이 문서의 래퍼와 패턴을 “기본 템플릿”으로 삼으면, 다양한 워크로드에서 **신뢰성과 처리량**을 동시에 달성할 수 있다.
