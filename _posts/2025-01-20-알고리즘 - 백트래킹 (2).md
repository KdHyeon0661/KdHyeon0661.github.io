---
layout: post
title: 알고리즘 - 백트래킹 (2)
date: 2025-01-20 20:20:23 +0900
category: 알고리즘
---
# 백트래킹으로 부분집합 탐색하기

## 부분집합(Subset) 기본기

- 원소가 \(n\)개인 집합의 **부분집합 개수**는
  $$
  2^n
  $$
  (각 원소를 “포함/미포함” 두 가지로 결정)
- 예: \([1,2,3]\)의 부분집합
  `[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]`

---

## 부분집합 생성 — 표준 방식 6종

### 포함/미포함 재귀(초안 확장판: 출력 대신 콜백·yield 지원)

```python
def subsets_include_exclude(arr, on_emit):
    n = len(arr)
    path = []
    def dfs(i):
        if i == n:
            on_emit(path)       # 출력 또는 수집
            return
        # 1) 미포함
        dfs(i + 1)
        # 2) 포함
        path.append(arr[i])
        dfs(i + 1)
        path.pop()
    dfs(0)

# 사용 예시

subsets_include_exclude([1,2,3], lambda s: print(s))
```

- 시간: \(O(2^n)\) (각 노드에서 \(O(1)\) 작업이면 총 \(O(2^n)\))
- 공간: 최대 깊이 \(n\) (재귀 스택 + 부분해 버퍼)

### visited 배열 방식(초안 보강: 재할당 최소화)

```python
def subsets_with_visited(arr):
    n = len(arr)
    visited = [False]*n
    def dfs(i):
        if i == n:
            print([arr[k] for k in range(n) if visited[k]])
            return
        visited[i] = False
        dfs(i + 1)
        visited[i] = True
        dfs(i + 1)
    dfs(0)
```

### 비트마스크 열거(빠르고 간결)

```python
def subsets_bitmask(arr):
    n = len(arr)
    for mask in range(1 << n):
        sub = [arr[i] for i in range(n) if mask & (1 << i)]
        print(sub)
```

- 장점: 반복문 하나, 상수 팩터가 작음. 카운팅/조건 체크에 유리.

### 반복(스택) DFS — 재귀 없이

```python
def subsets_iterative_stack(arr):
    n = len(arr)
    out = []
    stack = [(0, [])]  # (index, path)
    while stack:
        i, path = stack.pop()
        if i == n:
            out.append(path)
            continue
        stack.append((i + 1, path))                  # 미포함
        stack.append((i + 1, path + [arr[i]]))       # 포함
    return out
```

### 그레이 코드(한 비트만 바뀌며 순회) — 상태 전이 비용 최소화

```python
def subsets_gray_code(arr):
    n = len(arr)
    subset = [False]*n
    def gray(i): return i ^ (i >> 1)
    prev = 0
    for i in range(1 << n):
        g = gray(i)
        diff = prev ^ g
        if diff:  # 바뀐 비트 하나
            k = (diff & -diff).bit_length() - 1
            subset[k] = not subset[k]
        print([arr[j] for j in range(n) if subset[j]])
        prev = g
```

- 장점: 이전 상태에서 원소 1개만 토글 → “증분 갱신” 코스트가 매우 작음.

### 사전식 **k-조합**(조합 길이를 정해 탐색) — start 인덱스

```python
def k_combinations(arr, k, on_emit):
    n = len(arr)
    path = []
    def dfs(start):
        if len(path) == k:
            on_emit(path)
            return
        # 남은 슬롯보다 원소가 부족하면 중단(프루닝)
        need = k - len(path)
        for i in range(start, n - need + 1):
            path.append(arr[i])
            dfs(i + 1)
            path.pop()
    dfs(0)

k_combinations([1,2,3,4], 2, print)  # [1,2], [1,3], ...
```

---

## **프루닝(pruning)** 설계 — 합/개수/카테고리/중복

백트래킹의 핵심은 “가지치기”이다. **안전한 프루닝**은 “잘라낸 서브트리에서 해가 절대로 나오지 않음”을 보장해야 한다.

### 합 제한형(BOJ 1182 계열) — 상한/하한 컷

- 문제: 부분집합 합이 정확히 \(S\)인 경우의 수, 혹은 \(S\) 이하 최대합 등.
- 기본 컷:
  - 누적합 `sum > S` ⇒ 더 진행해도 불가능.
  - 남은 원소 모두 더해도 `sum + rest_max < S` ⇒ 불가능.
- 전처리: **내림차순 정렬** 및 **prefix/suffix 합**으로 `rest_max` 계산.

```python
def count_sum_equals(arr, S):
    arr = sorted(arr, reverse=True)
    n = len(arr)
    pref = [0]*(n+1)
    for i in range(n):
        pref[i+1] = pref[i] + arr[i]

    ans = 0
    def dfs(i, s):
        nonlocal ans
        if s == S:
            ans += 1
            # 계속 내려가면 중복(0 더하는 원소가 있을 때) 우려 → 그대로 return
            return
        if i == n:
            return
        # 컷 1: 초과
        if s > S:
            return
        # 컷 2: 남은 최대합으로도 못 채우면 종료
        if s + (pref[n] - pref[i]) < S:
            return
        # 선택/비선택
        dfs(i + 1, s + arr[i])
        dfs(i + 1, s)

    dfs(0, 0)
    # 공집합 제외 같은 문제 조건은 호출부에서 따로 조정
    return ans
```

### 개수 제한형(카디널리티) — 선택 수의 상/하한

- 예: “정확히 L개를 선택” 혹은 “최소/최대 개수 제약”
- 프루닝:
  - 남은 원소 수로는 목표 개수를 채울 수 없으면 컷.
  - 이미 선택 수가 상한을 넘으면 컷.

### 카테고리/속성 제약 — 미리 계산·진행 중 누적판정

- 예: 암호(BOJ 1759)에서 **모음 ≥ 1, 자음 ≥ 2**
- 진행 중에 모음·자음 개수 추적, 남은 원소로 조건 충족 불가하면 컷.

```python
def valid_passwords(chars, L):
    chars = sorted(chars)
    vowels = set("aeiou")
    path = []
    v = c = 0  # 모음/자음 카운트

    def dfs(start):
        nonlocal v, c
        if len(path) == L:
            if v >= 1 and c >= 2:
                print(''.join(path))
            return
        need = L - len(path)
        # 남은 길이로 최소 모음/자음 요건을 못 채우면 컷 (간단한 하한형)
        for i in range(start, len(chars) - need + 1):
            ch = chars[i]
            path.append(ch)
            if ch in vowels:
                v += 1
            else:
                c += 1
            dfs(i + 1)
            if ch in vowels:
                v -= 1
            else:
                c -= 1
            path.pop()

    dfs(0)
```

### 중복 원소 처리 — 정렬 + **스킵**이 핵심

- 입력 배열에 **중복 값이 있을 때**, 부분집합 결과에서 **중복 조합**이 생성되지 않도록 정렬 + “동일 값의 첫 진입만 허용”.

```python
def subsets_unique(arr):
    arr.sort()
    n = len(arr)
    path = []
    def dfs(i):
        print(path)  # 또는 수집
        for j in range(i, n):
            if j > i and arr[j] == arr[j-1]:  # 동일 레벨 중복 스킵
                continue
            path.append(arr[j])
            dfs(j + 1)
            path.pop()
    dfs(0)
```

---

## BOJ 실전 — 초안 예제 강화

### 부분수열의 합 — 공집합 제외/Meet-in-the-Middle(대형 N)

기본 해법(초안) + **대형 입력 최적화**:

- \(n \le 20\) 정도면 재귀 가능.
- \(n \approx 40\) 이상이면 **Meet-in-the-Middle(MiM)**: 배열을 반으로 나눠 왼쪽 부분합들, 오른쪽 부분합들을 따로 구한 뒤 **투포인터/이분 탐색**으로 조합.

```python
from bisect import bisect_left, bisect_right

def meet_in_the_middle_count(arr, S):
    n = len(arr)
    L, R = arr[:n//2], arr[n//2:]

    def sums(a):
        out = []
        m = len(a)
        for mask in range(1 << m):
            s = 0
            for i in range(m):
                if mask & (1 << i):
                    s += a[i]
            out.append(s)
        return out

    A = sums(L)
    B = sums(R)
    B.sort()

    ans = 0
    for x in A:
        need = S - x
        lo = bisect_left(B, need)
        hi = bisect_right(B, need)
        ans += (hi - lo)

    # 공집합 제외: S == 0 이면 빈 부분집합(좌우 모두 0 선택)이 1회 포함
    return ans - (1 if S == 0 else 0)
```

- 복잡도: \(O(2^{n/2}\log 2^{n/2})\), \(n=40\)도 실전 가능.

### 암호 만들기 — 조합 + 제약, 프루닝 포함(초안 보강)

- 이미 제시한 조합 + 조건 필터링 해법에 **프루닝**을 추가하면 탐색량 감소.
- 위 3.3 코드 참조(모음/자음 카운트 유지).

---

## “부분집합을 조합처럼” — 길이별로 나눠 탐색

초안의 `itertools.combinations` 접근은 **가장 간단하고 빠른** 방법이다. 직접 백트래킹으로 구현할 때도 **길이별 k-조합**을 사용하면 **중복 제거**와 **사전식 출력**을 자연스럽게 만족한다.

```python
from itertools import combinations

arr = [1,2,3]
for k in range(len(arr)+1):
    for comb in combinations(arr, k):
        print(comb)
```

---

## 최적화/카운팅 변형 — 부분집합의 “값”을 다루는 문제들

### “합 ≤ T의 최대합” — 브랜치&바운드(상한 컷)

```python
def subset_sum_best_leq(arr, T):
    arr.sort(reverse=True)
    n = len(arr)
    prefix = [0]*(n+1)
    for i in range(n):
        prefix[i+1] = prefix[i] + arr[i]

    best = 0
    def dfs(i, s):
        nonlocal best
        # 컷 1: 초과
        if s > T:
            return
        # 컷 2: 남은 최대를 다 더해도 best를 못 넘으면 컷
        upper = s + (prefix[n] - prefix[i])
        if upper <= best:
            return
        best = max(best, s)
        if i == n:
            return
        dfs(i + 1, s + arr[i])  # 선택
        dfs(i + 1, s)           # 비선택
    dfs(0, 0)
    return best
```

### 카운팅: “합이 특정 값” 외에도 모듈러·카테고리 등

- 예: “합 ≡ K (mod M)인 부분집합 개수” → 누적합 % M을 상태로 **DP**가 더 적합하나, \(n\)이 작으면 백트래킹+카운팅 가능.
- 예: “각 색상에서 최대 c_i개까지만 선택” → 카운터 유지 + 컷.

---

## 부분집합 생성 순서/출력 요구 충족

- **사전식**: 입력을 정렬하고, 인덱스 증가 방식으로 탐색.
- **길이 증가 순**: `k=0..n` 조합 루프 사용.
- **그레이 코드 순**: 2.5 참조(증분 변화 최소화).
- **중복 제거**: 정렬 + 동일 레벨 스킵(3.4 참조).

---

## 성능 팁(백준 스타일)

1) **입력**: `import sys; input = sys.stdin.readline`
2) **정렬 1회 + prefix/suffix**: 상한/하한 컷에 필수
3) **분기 순서**: “가능성이 큰 쪽” 혹은 “제약이 빡센 쪽” 먼저
4) **정수 비트마스크**: 방문집합/카테고리 마스크에 효율적
5) **Meet-in-the-Middle**: \(n\ge 35\) 근방의 합/카운팅 문제에 강력
6) **공집합 처리**: 문제 조건(포함/제외)을 마지막에 한 줄로 조정

---

## 정당성 스케치(프루닝이 정확한 이유)

- 컷의 논리는 “해가 존재할 가능성을 부정”해야 한다.
  - 합 초과 컷: 이후 어떤 선택을 해도 더 커질 뿐 \(=S\)에 도달 불가.
  - 상한 컷: “남은 모든 원소를 더한 최선”이 전역 최선/목표를 못 넘음.
  - 개수 컷: 남은 원소 수로 목표 카디널리티 충족 불가.
  - 중복 스킵: 같은 깊이에서 같은 값의 첫 진입만 고려하면 “서로 동일한 조합”이 중복 생성되지 않음(정렬 전제).

---

## 검증·디버깅 체크리스트

- **복원(undo) 누락**: path/카운트/마스크 되돌렸는지?
- **기저 조건**: 종료 시점이 정확한가(공집합/조건 포함)?
- **중복 제거**: 정렬 + 동일 레벨 스킵이 올바른 위치에?
- **경계**: `i` 루프 상한(`n - need + 1`) 오프바이원 확인
- **출력 순서**: 사전식/길이 증가 순 요구 반영?
- **공집합 처리**: 카운팅에서 제외/포함 여부 문제 조건 재확인

---

## 수학 메모

- 전체 부분집합 수:
  $$
  2^n
  $$
- 길이 \(k\) 부분집합 수:
  $$
  {n \choose k}
  $$
- 길이 제한을 두고 모두 합치면:
  $$
  \sum_{k=0}^{n} {n \choose k} = 2^n
  $$

---

## 통합 예제 — “조건 다수”를 한 번에 (합 == S, 길이 ≤ L, 금지 원소 집합 F)

```python
def constrained_subsets(arr, S, L, forbidden):
    arr = sorted(arr, reverse=True)  # 상한 컷 강화
    n = len(arr)
    pref = [0]*(n+1)
    for i in range(n):
        pref[i+1] = pref[i] + arr[i]

    ans = []
    path = []
    def dfs(i, s):
        # 합 조건
        if s == S:
            ans.append(path[:])
            # 더 내려가면 중복/초과 우려 → 여기선 즉시 리턴
            return
        if i == n:
            return
        # 길이 컷
        if len(path) == L:
            return
        # 상한 컷
        if s + (pref[n] - pref[i]) < S:
            return

        # 선택: 금지 원소 아니면
        if arr[i] not in forbidden:
            path.append(arr[i])
            dfs(i + 1, s + arr[i])
            path.pop()

        # 비선택
        dfs(i + 1, s)

    dfs(0, 0)
    return ans

# 사용 예시

print(constrained_subsets([2,3,5,7,11], S=10, L=3, forbidden={11}))
```

---

## 결론

초안의 핵심(정의·기본 구현·대표 문제)을 살리면서, **생성법 6종**, **프루닝 카탈로그**, **중복 원소 처리**, **전처리·바운딩으로의 성능 향상**, **MiM 고급 최적화**까지 연결했다.
실전에서는 다음의 절차로 구조화하라:

1) **출력/카운팅/최적화** 유형 파악
2) **정렬/전처리**로 상·하한 바운딩 근거 준비
3) **탐색 순서와 프루닝**(합/개수/카테고리/중복) 설계
4) \(n\) 크면 **Meet-in-the-Middle** 검토
5) 요구 출력 순서/중복 제거를 **탐색 단계에서 직접 보장**

이렇게 하면 “\(2^n\) 탐색” 문제에서도 **정확성**과 **속도**를 동시에 확보할 수 있다.
