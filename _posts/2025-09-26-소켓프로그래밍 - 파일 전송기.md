---
layout: post
title: 소켓프로그래밍 - 파일 전송기
date: 2025-09-26 20:25:23 +0900
category: 소켓프로그래밍
---
# 파일 전송기 - zero-copy(송신: `sendfile`, 수신: `splice`), 체크섬 검증, 재시도/이어받기

> 목표: “대용량 단일 파일”을 **TCP**로 전송할 때,
> 1) **서버→소켓** 경로는 `sendfile(2)`로, **소켓→파일(클라이언트)** 경로는 `splice(2)` 파이프 경유로 **가능한 한 zero-copy**를 사용,
> 2) **CRC32** 체크섬을 통한 **엔드투엔드 무결성 검증**,
> 3) 연결 끊김 시 **재시도 + 이어받기(resume)** 를 구현한다.
> Linux(glibc/musl) + C++23 기준. TLS가 필요하면(14장) `sendfile` zero-copy는 TLS 레코드 처리 때문에 불가(커널 바깥으로 나와야 함) — 본 예제는 **평문 TCP**를 전제로 한다.

---

## 설계 개요

### 최소 프로토콜 (바이너리 헤더 + 바디)

- 클라이언트가 **파일 경로**와 **오프셋**을 보내고,
- 서버가 **파일 메타**(크기, mtime, CRC32)를 응답한 뒤, **`offset`부터 파일 바디**를 스트리밍.

#### — `ReqV1`

```c
// big-endian
struct ReqV1 {
  u32 magic = 'FTQ1';      // 0x46545131
  u16 path_len;            // 바디의 경로 길이(bytes)
  u16 flags;               // bit0=want_crc(서버가 CRC32 제공)
  u64 offset;              // 이어받기 시작 위치(바이트)
  // 이어서 path_len 바이트의 UTF-8 경로(절대/상대, 서버의 root 내부)
};
```

#### — `RespV1`

```c
// big-endian
struct RespV1 {
  u32 magic = 'FTR1';      // 0x46545231
  u16 status;              // 0=OK, else 오류코드
  u16 reserved;
  u64 file_size;           // 바이트
  u64 mtime_ns;            // 파일 mtime (ns, CLOCK_REALTIME)
  u32 crc32;               // 전체 파일 CRC32(옵션, 0=미제공)
  // 상태가 OK이면, 즉시 offset..EOF 구간의 파일 데이터 스트리밍 시작
};
```

> **CRC32는 “안전한 암호학적 해시”가 아님**(충돌에 강하지 않다).
> 무결성 검증 수준에서 충분하되, 보안적 위조 방지에는 **SHA-256** 등의 해시 + 서명/암호화가 필요.

### zero-copy 경로

- **서버**: `sendfile(sock, file, &offset, len)` — 파일 페이지 캐시 → 소켓 송신 버퍼로 **커널 내부 복사/매핑** (유저 공간 복사 없음).
- **클라이언트**: `splice(sock → pipe)` + `splice(pipe → file)` — **소켓→파이프→파일**로 커널 내에서 데이터 이동.
  (일부 FS/커널 조합에서 최적화 정도가 다르므로 실패 시 **read/write 루프**로 폴백)

### 이어받기/재시도

- **클라이언트**는 로컬 임시 파일(`.part`)을 **열기 + `ftruncate`로 확장** 혹은 **`pwrite`**로 덮어쓰기.
- 전송 중 끊기면 **마지막까지 기록된 바이트 수**를 기준으로 **오프셋 재요청**.
- backoff:
  $$ \text{backoff}(k) = \min(t_{\max}, t_0 \cdot 2^k) $$
  (12장의 정의와 동일)

---

## 공통 유틸 — `ft_common.hpp`

> RAII FD, 엔디안 헬퍼, CRC32, 안전 I/O, 경로 정화(디렉토리 traversal 방지).

```cpp
// ft_common.hpp — 공통 유틸 (C++23, Linux)
#pragma once
#include <array>
#include <bit>
#include <cerrno>
#include <cstdint>
#include <cstring>
#include <expected>
#include <filesystem>
#include <optional>
#include <print>
#include <span>
#include <string>
#include <string_view>
#include <system_error>
#include <vector>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <arpa/inet.h>

// ---------- RAII FD ----------
struct unique_fd {
  int fd{-1};
  unique_fd() = default;
  explicit unique_fd(int f): fd(f) {}
  ~unique_fd(){ if (fd>=0) ::close(fd); }
  unique_fd(const unique_fd&) = delete;
  unique_fd& operator=(const unique_fd&) = delete;
  unique_fd(unique_fd&& o) noexcept : fd(o.fd){ o.fd=-1; }
  unique_fd& operator=(unique_fd&& o) noexcept {
    if (this != &o){ if (fd>=0) ::close(fd); fd=o.fd; o.fd=-1; }
    return *this;
  }
  explicit operator bool() const noexcept { return fd>=0; }
  int get() const noexcept { return fd; }
  int release() noexcept { int t=fd; fd=-1; return t; }
  void reset(int f=-1){ if (fd>=0) ::close(fd); fd=f; }
};

// ---------- endian helpers (big-endian) ----------
inline uint16_t be16(uint16_t x){ return htons(x); }
inline uint32_t be32(uint32_t x){ return htonl(x); }
inline uint64_t be64(uint64_t x){
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__

  return __builtin_bswap64(x);
#else

  return x;
#endif

}
inline uint16_t from_be16(uint16_t x){ return ntohs(x); }
inline uint32_t from_be32(uint32_t x){ return ntohl(x); }
inline uint64_t from_be64(uint64_t x){
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__

  return __builtin_bswap64(x);
#else

  return x;
#endif

}

// ---------- safe IO ----------
inline std::expected<void, std::error_code>
write_all(int fd, std::span<const std::byte> s){
  size_t off=0; while (off<s.size()){
    ssize_t n = ::write(fd, s.data()+off, s.size()-off);
    if (n>0){ off+=size_t(n); continue; }
    if (n==0) continue;
    if (errno==EINTR) continue;
    return std::unexpected(std::error_code(errno, std::generic_category()));
  } return {};
}
inline std::expected<void, std::error_code>
read_exact(int fd, std::span<std::byte> s){
  size_t off=0; while (off<s.size()){
    ssize_t n = ::read(fd, s.data()+off, s.size()-off);
    if (n>0){ off+=size_t(n); continue; }
    if (n==0) return std::unexpected(std::make_error_code(std::errc::connection_reset));
    if (errno==EINTR) continue;
    return std::unexpected(std::error_code(errno, std::generic_category()));
  } return {};
}

// ---------- CRC32 (IEEE 802.3, poly 0xEDB88320) ----------
struct CRC32 {
  uint32_t tab[256];
  CRC32(){
    for (uint32_t i=0;i<256;i++){
      uint32_t c=i;
      for (int j=0;j<8;j++) c = (c&1)? (0xEDB88320u ^ (c>>1)) : (c>>1);
      tab[i]=c;
    }
  }
  uint32_t compute(const void* data, size_t len, uint32_t seed=0xFFFFFFFFu) const {
    uint32_t c=seed;
    auto* p = static_cast<const unsigned char*>(data);
    for (size_t i=0;i<len;i++) c = tab[(c ^ p[i]) & 0xFFu] ^ (c>>8);
    return c ^ 0xFFFFFFFFu;
  }
};
inline const CRC32& crc32(){ static CRC32 C; return C; }

// ---------- path helpers ----------
inline std::optional<std::filesystem::path>
sanitize_and_join(const std::filesystem::path& root, std::string_view req){
  std::filesystem::path p = std::filesystem::path{req}.lexically_normal();
  if (p.is_absolute()) p = p.relative_path();
  auto full = std::filesystem::weakly_canonical(root / p);
  auto can  = std::filesystem::weakly_canonical(root);
  // root 밖으로 나가면 거부
  auto fulls = full.string(), cans = can.string();
  if (fulls.size() < cans.size()) return std::nullopt;
  if (fulls.substr(0, cans.size()) != cans) return std::nullopt;
  return full;
}

// ---------- timespec(ns) ----------
inline uint64_t file_mtime_ns(const std::filesystem::path& p){
  struct stat st{}; if (::stat(p.c_str(), &st)==0){
#ifdef __linux__

    return uint64_t(st.st_mtim.tv_sec)*1000000000ull + st.st_mtim.tv_nsec;
#else

    return uint64_t(st.st_mtime)*1000000000ull; // fallback
#endif

  }
  return 0;
}
```

---

## 서버 — `ft_server.cpp`

> 단일 스레드/단일 연결로도 충분히 이해되지만, 아래 코드는 **스레드-퍼-연결**(간단)로 작성.
> 핵심은: **요청 파싱 → 파일 메타 응답 → `sendfile` 루프**.

```cpp
// ft_server.cpp
#include "ft_common.hpp"
#include <netdb.h>
#include <sys/sendfile.h>
#include <sys/socket.h>
#include <thread>
#include <vector>
#include <atomic>

using namespace std::literals;

struct ReqV1 {
  uint32_t magic;
  uint16_t path_len;
  uint16_t flags;
  uint64_t offset;
  // path bytes...
};
struct RespV1 {
  uint32_t magic;
  uint16_t status;
  uint16_t reserved;
  uint64_t file_size;
  uint64_t mtime_ns;
  uint32_t crc32;
};

static constexpr uint32_t REQ_MAGIC = 0x46545131u; // 'FTQ1'
static constexpr uint32_t RSP_MAGIC = 0x46545231u; // 'FTR1'

struct Options {
  std::string host="0.0.0.0";
  std::string port="9000";
  std::filesystem::path root="./pub";
  bool precompute_crc_if_missing = true; // <file>.crc32 sidecar 사용/생성
} opt;

static std::atomic<bool> g_running{true};

static void compute_and_write_crc_sidecar(const std::filesystem::path& f, uint32_t& out_crc){
  // sidecar 파일이 있으면 사용, 없으면 계산해 저장
  auto sc = f; sc += ".crc32";
  if (std::filesystem::exists(sc)){
    unique_fd fd(::open(sc.c_str(), O_RDONLY|O_CLOEXEC));
    if (fd){
      char buf[32]{}; ssize_t n=::read(fd.get(), buf, sizeof(buf));
      if (n>0){ out_crc = std::strtoul(buf, nullptr, 16); return; }
    }
  }
  // 계산(유저 공간 복사 발생 — zero-copy 경로와는 독립적인 사전 계산이므로 OK)
  unique_fd fd(::open(f.c_str(), O_RDONLY|O_CLOEXEC));
  if (!fd) return;
  uint32_t c=0xFFFFFFFFu;
  std::array<char, 1<<20> b{};
  for (;;) {
    ssize_t n = ::read(fd.get(), b.data(), b.size());
    if (n>0) c = crc32().compute(b.data(), (size_t)n, c);
    else if (n==0) break;
    else if (errno==EINTR) continue;
    else break;
  }
  out_crc = c ^ 0xFFFFFFFFu;
  if (opt.precompute_crc_if_missing){
    unique_fd wf(::open(sc.c_str(), O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0644));
    if (wf){
      char hex[16]; int m = std::snprintf(hex, sizeof(hex), "%08x\n", out_crc);
      (void)::write(wf.get(), hex, m);
    }
  }
}

static std::expected<void, std::error_code>
send_resp(int sock, const RespV1& r){
  RespV1 be = {
    .magic    = be32(r.magic),
    .status   = be16(r.status),
    .reserved = be16(r.reserved),
    .file_size= be64(r.file_size),
    .mtime_ns = be64(r.mtime_ns),
    .crc32    = be32(r.crc32),
  };
  return write_all(sock, {reinterpret_cast<const std::byte*>(&be), sizeof(be)});
}

static std::expected<std::string, std::error_code>
read_req(int sock, ReqV1& out_hdr){
  std::array<std::byte, sizeof(ReqV1)> hb{};
  if (auto r = read_exact(sock, hb); !r) return std::unexpected(r.error());
  std::memcpy(&out_hdr, hb.data(), sizeof(ReqV1));
  out_hdr.magic    = from_be32(out_hdr.magic);
  out_hdr.path_len = from_be16(out_hdr.path_len);
  out_hdr.flags    = from_be16(out_hdr.flags);
  out_hdr.offset   = from_be64(out_hdr.offset);
  if (out_hdr.magic != REQ_MAGIC) return std::unexpected(std::make_error_code(std::errc::protocol_error));
  if (out_hdr.path_len==0 || out_hdr.path_len > 4096) return std::unexpected(std::make_error_code(std::errc::message_size));
  std::string path; path.resize(out_hdr.path_len);
  if (auto r = read_exact(sock, {reinterpret_cast<std::byte*>(path.data()), path.size()}); !r)
    return std::unexpected(r.error());
  return path;
}

static void handle_conn(int sock){
  unique_fd s(sock);
  // 요청 읽기
  ReqV1 h{};
  auto path_e = read_req(s.get(), h);
  if (!path_e){
    std::print(stderr, "[srv] bad request: {}\n", path_e.error().message());
    return;
  }
  auto path = *path_e;

  // path 정화 + root join
  auto full_e = sanitize_and_join(opt.root, path);
  if (!full_e || !std::filesystem::exists(*full_e) || std::filesystem::is_directory(*full_e)){
    RespV1 r{.magic=RSP_MAGIC, .status=2, .reserved=0, .file_size=0, .mtime_ns=0, .crc32=0};
    (void)send_resp(s.get(), r); return;
  }

  struct stat st{}; ::stat(full_e->c_str(), &st);
  uint64_t fsize = st.st_size;
  uint64_t mtime = file_mtime_ns(*full_e);
  uint32_t crc = 0;
  if (h.flags & 0x0001){ compute_and_write_crc_sidecar(*full_e, crc); }

  // offset 검증
  uint64_t off = h.offset;
  if (off > fsize) off = fsize;

  // 응답 헤더 전송
  RespV1 r{.magic=RSP_MAGIC, .status=0, .reserved=0, .file_size=fsize, .mtime_ns=mtime, .crc32=crc};
  if (auto w = send_resp(s.get(), r); !w){ std::print(stderr,"[srv] resp write: {}\n", w.error().message()); return; }

  // 데이터 전송 (sendfile)
  unique_fd fd(::open(full_e->c_str(), O_RDONLY|O_CLOEXEC));
  if (!fd){ std::print(stderr,"[srv] open: {}\n", strerror(errno)); return; }

  off_t so = (off_t)off; // 파일 오프셋(커널이 증가시킴)
  uint64_t remain = fsize - off;
  while (remain > 0){
    // 한 번에 너무 크게 주면 일부 커널에서 -EINVAL → 8~16MB 권장
    size_t chunk = remain > (16<<20) ? (16<<20) : (size_t)remain;
    ssize_t n = ::sendfile(s.get(), fd.get(), &so, chunk);
    if (n > 0){ remain -= (uint64_t)n; continue; }
    if (n==0){ break; } // EOF
    if (errno==EINTR) continue;
    if (errno==EAGAIN || errno==EWOULDBLOCK){ // 비정상 상태(보통 Nagle/윈도 문제) → 살짝 쉼
      ::usleep(1000);
      continue;
    }
    std::print(stderr, "[srv] sendfile: {}\n", strerror(errno));
    break;
  }
}

static unique_fd listen_on(const std::string& host, const std::string& port){
  addrinfo hints{}, *res=nullptr;
  hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG;
  if (getaddrinfo(host=="*" ? nullptr : host.c_str(), port.c_str(), &hints, &res)!=0){
    return unique_fd{-1};
  }
  unique_fd l{-1};
  for (auto* ai=res; ai; ai=ai->ai_next){
    int s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
    if (s<0) continue;
    int yes=1; ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
    if (::bind(s, ai->ai_addr, ai->ai_addrlen)==0 && ::listen(s, 1024)==0){ l.reset(s); break; }
    ::close(s);
  }
  freeaddrinfo(res);
  return l;
}

int main(int argc, char** argv){
  if (argc>=2) opt.host = argv[1];
  if (argc>=3) opt.port = argv[2];
  if (argc>=4) opt.root = argv[3];
  std::filesystem::create_directories(opt.root);

  auto l = listen_on(opt.host, opt.port);
  if (!l){ std::print(stderr,"listen fail on {}:{}\n", opt.host, opt.port); return 1; }
  std::print("[srv] {}:{} root={}\n", opt.host, opt.port, opt.root.string());

  for (;;){
    sockaddr_storage ss{}; socklen_t sl=sizeof(ss);
    int c = ::accept4(l.get(), (sockaddr*)&ss, &sl, SOCK_CLOEXEC);
    if (c<0){ if (errno==EINTR) continue; std::perror("accept"); break; }
    std::thread(handle_conn, c).detach();
  }
  return 0;
}
```

---

## 클라이언트 — `ft_client.cpp`

> 재시도/이어받기 + **가능하면 `splice`-파이프**로 **zero-copy 수신**(커널 내 이동).
> 안 되면 `read`/`pwrite` 루프 폴백.

```cpp
// ft_client.cpp
#include "ft_common.hpp"
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/stat.h>
#include <sys/sendfile.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <sys/epoll.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/limits.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/poll.h>
#include <sys/mount.h>
#include <sys/statvfs.h>
#include <sys/sysinfo.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/statfs.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

using namespace std::literals;

struct ReqV1 { uint32_t magic; uint16_t path_len; uint16_t flags; uint64_t offset; };
struct RespV1 { uint32_t magic; uint16_t status; uint16_t reserved; uint64_t file_size; uint64_t mtime_ns; uint32_t crc32; };
static constexpr uint32_t REQ_MAGIC = 0x46545131u; // 'FTQ1'
static constexpr uint32_t RSP_MAGIC = 0x46545231u; // 'FTR1'

struct Options {
  std::string host="127.0.0.1";
  std::string port="9000";
  std::string remote_path;             // 서버 루트 상대 경로
  std::filesystem::path out="./out.bin";
  bool want_crc=true;
  int max_retry=10;
  int64_t backoff_ms0=200, backoff_max=5000;
} opt;

static int dial(const std::string& host, const std::string& port){
  addrinfo hints{}, *res=nullptr;
  hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_ADDRCONFIG;
  if (getaddrinfo(host.c_str(), port.c_str(), &hints, &res)!=0) return -1;
  int s=-1;
  for (auto* ai=res; ai; ai=ai->ai_next){
    s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
    if (s<0) continue;
    if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0){ freeaddrinfo(res); return s; }
    ::close(s); s=-1;
  }
  freeaddrinfo(res); return -1;
}

static std::expected<void, std::error_code>
send_req(int sock, std::string_view path, uint64_t offset, bool want_crc){
  ReqV1 r{ .magic=be32(REQ_MAGIC), .path_len=be16((uint16_t)path.size()),
           .flags=be16(want_crc?1:0), .offset=be64(offset) };
  if (auto w=write_all(sock, {reinterpret_cast<const std::byte*>(&r), sizeof(r)}); !w) return std::unexpected(w.error());
  return write_all(sock, {reinterpret_cast<const std::byte*>(path.data()), path.size()});
}

static std::expected<RespV1, std::error_code>
recv_resp(int sock){
  RespV1 be{};
  if (auto r = read_exact(sock, {reinterpret_cast<std::byte*>(&be), sizeof(be)}); !r) return std::unexpected(r.error());
  RespV1 v{
    .magic    = from_be32(be.magic),
    .status   = from_be16(be.status),
    .reserved = from_be16(be.reserved),
    .file_size= from_be64(be.file_size),
    .mtime_ns = from_be64(be.mtime_ns),
    .crc32    = from_be32(be.crc32),
  };
  if (v.magic != RSP_MAGIC) return std::unexpected(std::make_error_code(std::errc::protocol_error));
  return v;
}

// zero-copy 수신 시도: socket->pipe, pipe->file (splice). 실패 시 false
static bool recv_to_file_splice(int sock, int outfd, uint64_t start_off, uint64_t total_bytes){
  // 파이프 생성
  int p[2]; if (::pipe2(p, O_CLOEXEC|O_NONBLOCK)<0) return false;
  unique_fd pr(p[0]), pw(p[1]);
  uint64_t remain = total_bytes;
  loff_t off = (loff_t)start_off;

  while (remain>0){
    // 소켓 -> 파이프
    // 최대치 너무 크게 하지 말 것(8MB 권장)
    size_t chunk = remain > (8<<20) ? (8<<20) : (size_t)remain;
    ssize_t n = ::splice(sock, nullptr, pw.get(), nullptr, chunk, SPLICE_F_MOVE|SPLICE_F_MORE);
    if (n>0){
      // 파이프 -> 파일(오프셋 지정)
      ssize_t w = ::splice(pr.get(), nullptr, outfd, &off, n, SPLICE_F_MOVE|SPLICE_F_MORE);
      if (w<0){ if (errno==EINTR) continue; std::print(stderr,"[cli] splice to file: {}\n", strerror(errno)); return false; }
      remain -= (uint64_t)w;
      continue;
    }
    if (n==0){ // EOF
      return (remain==0);
    }
    if (errno==EAGAIN || errno==EWOULDBLOCK){ ::usleep(1000); continue; }
    if (errno==EINTR) continue;
    std::print(stderr,"[cli] splice from sock: {}\n", strerror(errno));
    return false;
  }
  return true;
}

// 폴백: read + pwrite 루프
static bool recv_to_file_readwrite(int sock, int outfd, uint64_t start_off, uint64_t total_bytes){
  std::vector<char> buf(1<<20);
  uint64_t remain = total_bytes;
  uint64_t off = start_off;
  while (remain>0){
    ssize_t n = ::read(sock, buf.data(), (remain>buf.size()? buf.size() : (size_t)remain));
    if (n>0){
      ssize_t w = ::pwrite(outfd, buf.data(), n, (off_t)off);
      if (w<0){ if (errno==EINTR) continue; std::print(stderr,"[cli] pwrite: {}\n", strerror(errno)); return false; }
      off += (uint64_t)w; remain -= (uint64_t)w;
      continue;
    }
    if (n==0) return (remain==0);
    if (errno==EINTR) continue;
    if (errno==EAGAIN || errno==EWOULDBLOCK){ ::usleep(1000); continue; }
    std::print(stderr,"[cli] read: {}\n", strerror(errno));
    return false;
  }
  return true;
}

static uint64_t filesize_or_0(const std::filesystem::path& p){
  struct stat st{}; if (::stat(p.c_str(), &st)==0) return st.st_size; return 0;
}

int main(int argc, char** argv){
  if (argc<4){
    std::print(stderr, "usage: {} <host> <port> <remote-path> [out-path]\n", argv[0]);
    return 2;
  }
  opt.host = argv[1]; opt.port = argv[2]; opt.remote_path = argv[3];
  if (argc>=5) opt.out = argv[4];

  // 출력 파일(.part)에 이어쓰기
  auto out_part = opt.out; out_part += ".part";
  unique_fd of(::open(out_part.c_str(), O_CREAT|O_RDWR|O_CLOEXEC, 0644));
  if (!of){ std::print(stderr,"open out: {}\n", strerror(errno)); return 1; }

  uint64_t have = filesize_or_0(out_part);
  uint64_t expect_size=0, expect_crc=0, expect_mtime=0;

  for (int k=0; k<opt.max_retry; ++k){
    int s = dial(opt.host, opt.port);
    if (s<0){
      int ms = std::min<int64_t>(opt.backoff_max, opt.backoff_ms0<<k);
      std::print(stderr,"dial fail, retry in {}ms\n", ms);
      ::usleep(ms*1000);
      continue;
    }
    unique_fd sock(s);

    // 요청: remote_path, offset=have
    if (auto r=send_req(sock.get(), opt.remote_path, have, opt.want_crc); !r){
      std::print(stderr,"send_req: {}\n", r.error().message()); continue;
    }
    auto resp = recv_resp(sock.get());
    if (!resp){ std::print(stderr,"resp: {}\n", resp.error().message()); continue; }
    if (resp->status != 0){ std::print(stderr,"server status={} (no file?)\n", resp->status); return 3; }

    expect_size  = resp->file_size;
    expect_crc   = resp->crc32;
    expect_mtime = resp->mtime_ns;

    if (have > expect_size) { have = 0; ::ftruncate(of.get(), 0); } // 서버 파일이 더 작아짐 → 처음부터
    uint64_t todo = expect_size - have;
    if (todo==0) { std::print("[cli] already complete {}\n", expect_size); break; }

    // 파일 크기 예약(선택): ftruncate
    ::ftruncate(of.get(), (off_t)expect_size);

    std::print("[cli] recv {} bytes from offset {}\n", todo, have);

    bool ok = recv_to_file_splice(sock.get(), of.get(), have, todo);
    if (!ok) {
      std::print(stderr,"[cli] splice path failed, falling back\n");
      ok = recv_to_file_readwrite(sock.get(), of.get(), have, todo);
    }
    if (ok){
      have = expect_size;
      break;
    } else {
      // 부분만 받았을 수 있음 → 현재 파일 크기 재측정
      have = filesize_or_0(out_part);
      int ms = std::min<int64_t>(opt.backoff_max, opt.backoff_ms0<<k);
      std::print(stderr,"[cli] interrupted; have={} retry in {}ms\n", have, ms);
      ::usleep(ms*1000);
      continue;
    }
  }

  // 완료 검증
  if (have != expect_size){ std::print(stderr,"[cli] fail to complete after retries\n"); return 4; }

  // CRC 검증(옵션)
  if (opt.want_crc && expect_crc!=0){
    // 파일 전체 CRC 계산
    unique_fd rf(::open(out_part.c_str(), O_RDONLY|O_CLOEXEC));
    if (!rf){ std::print(stderr,"open for crc: {}\n", strerror(errno)); return 5; }
    uint32_t c=0xFFFFFFFFu;
    std::vector<char> b(1<<20);
    for(;;){
      ssize_t n = ::read(rf.get(), b.data(), b.size());
      if (n>0) c = crc32().compute(b.data(), (size_t)n, c);
      else if (n==0) break;
      else if (errno==EINTR) continue;
      else { std::print(stderr,"crc read: {}\n", strerror(errno)); return 6; }
    }
    c ^= 0xFFFFFFFFu;
    if (c != expect_crc){
      std::print(stderr,"[cli] CRC mismatch: got={:08x} expect={:08x}\n", c, expect_crc);
      return 7;
    }
  }

  // 원자적 rename
  ::rename(out_part.c_str(), opt.out.c_str());
  std::print("[cli] OK: {} bytes -> {}\n", expect_size, opt.out.string());
  return 0;
}
```

---

## 빌드 & 실행

```bash
g++ -std=c++23 -O2 ft_server.cpp -o ft_server
g++ -std=c++23 -O2 ft_client.cpp -o ft_client

# 서버 준비

mkdir -p pub
cp /path/to/big.iso pub/
./ft_server 0.0.0.0 9000 ./pub

# 클라이언트 (동일 머신 또는 원격)

./ft_client 127.0.0.1 9000 big.iso ./big.iso

# 중간에 강제 종료 후 재시도 시, .part 기준으로 이어받기

```

---

## 동작 원리 & 주의점

### zero-copy의 경계

- **서버**: `sendfile(file→sock)`은 **유저 공간 복사 없음**.
  단, TCP stack/NIC 드라이버가 필요하면 내부에서 **커널 내 복사/세그먼트**가 일어난다.
- **클라이언트**: `socket→pipe→file` **두 번의 `splice`**가 필요하다.
  FS/커널/드라이버 조합에 따라 완전 zero-copy가 아닐 수 있다 → **폴백 구현 필수**.

### 체크섬 시점

- 서버가 **미리 계산된 CRC**(사이드카 파일 `.crc32`)를 제공한다.
  없으면 서버가 계산(유저 공간 복사 발생)하지만 **데이터 송신은 여전히 `sendfile`** 로 전달되어 전송 경로는 zero-copy.
- **클라이언트 측 재확인**: 수신 완료 후 **전체 파일 CRC**를 계산해 **서버 값과 비교**.

### 이어받기 안전성

- 재접속 시 서버가 **파일 크기/mtime/CRC**를 응답 → **변경 감지**에 활용 가능.
  (본 예제는 단순히 **서버 파일이 더 작아졌을 때 0부터 다시** 받음. 실전에서는 `mtime`/`CRC` 변화를 검사해 **에러/중단**을 선택)

### 성능 팁

- `sendfile` chunk 크기는 **8~16MiB** 권장(너무 크면 `-EINVAL` 위험).
- 클라이언트 `splice`도 동일 크기. `SPLICE_F_MORE` 힌트로 TCP coalescing 도움.
- 서버 `TCP_CORK`를 헤더 전송~첫 바디 전까지 켜고 이후 끄면 헤더/바디 묶임 개선(여기선 생략).

### 보안/경로

- 서버는 `sanitize_and_join(root, req_path)`로 **루트 외부 탈출(`..`) 방지**.
- 접근 제어/인증이 필요하면(14장 TLS + 15장 토큰) **헤더에 토큰**을 추가.

---

## 간단한 장애 실험

- **네트워크 끊김**: 클라이언트 실행 중 `ifconfig lo down; up` 혹은 `pkill -9 ft_server`.
  → 클라이언트가 **부분 저장(.part)** 후 **재시도**로 이어받는지 확인.
- **손상 유도**: 전송 완료 직전 `.part` 파일의 일부 바이트를 수정 → **CRC 불일치**로 실패하는지 확인.
- **느린 디스크/RTT**: `tc netem delay 30ms loss 0.2%`로 지연/손실 주입(18장). 전송률과 tail-latency 관측.

---

## 체크리스트(요약)

- [x] 서버: **`sendfile` zero-copy** 전송 루프
- [x] 클라: **`splice` 파이프** 경로 시도 + **read/write 폴백**
- [x] **CRC32** 서버 제공 + 클라 검증
- [x] **이어받기**: 오프셋 재요청, `.part` 파일 유지
- [x] **백오프 재시도**: \( t_0\cdot2^k \) 상한
- [x] **경로 정화**로 루트 이탈 방지

---

## 확장 아이디어

- **SHA-256**로 교체(크립토 무결성) — OpenSSL/mbedTLS 또는 경량 구현.
- **다중 스트림 병렬 전송**: chunk를 범위별로 나눠 N개 연결로 병렬 받기(서버는 `sendfile` 병렬).
  완료 후 **스파스 파일**에 조각 기록.
- **압축/컨텐츠 인코딩**: 느린 네트워크에서 **서버 압축 + 클라 해제**(zero-copy는 포기).
- **TLS**: 14장. TLS를 쓸 땐 `sendfile` zero-copy 불가 → `read`→`SSL_write` 루프.
- **서버 캐시**: 파일 CRC/메타를 **메모리 캐시**(mtime 키)로 가속.

---

### 끝

위 두 바이너리(`ft_server`, `ft_client`)만으로도 **대용량 파일의 빠르고 안정된 전송**을 실습할 수 있다.
핵심은: **전송 경로는 zero-copy**, **무결성은 체크섬**, **현실적 장애엔 재시도/이어받기**.
실무에선 13·16·18장의 관측/튜닝/벤치 지식을 결합해 **일관된 성능과 신뢰성**을 확보하자.
