---
layout: post
title: 운영체제 - 동기화 문제 (2)
date: 2025-10-20 21:25:23 +0900
category: 운영체제
---
# POSIX Synchronization • Synchronization in Java • Alternative Approaches  

## 7.3 POSIX Synchronization

POSIX 스레딩(Pthreads)과 동기화 API는 **C/C++ 런타임 밖**에서 **운영체제 수준**의 블로킹/깨우기(예: futex 기반)를 활용한다. 핵심 도구:

- `pthread_mutex_t` (일반/재귀/에러체크/견고 robust/PI 옵션)
- `pthread_cond_t` (조건변수, 타임아웃/스푸리어스 대응)
- `pthread_rwlock_t` (읽기-쓰기 락)
- `pthread_barrier_t` (배리어)
- `sem_t` (POSIX 세마포어; 프로세스 내/간)
- `pthread_spinlock_t` (스핀락; IRQ 컨텍스트 개념 없는 사용자 공간이므로 **짧은 CS** 전용)
- 원자/메모리 모델(C11 `stdatomic.h` 권장) + **메모리 배리어** 개념

### 7.3.1 뮤텍스: 타입과 특성

- **일반(Normal)**: 데드락 탐지 없음, 동일 스레드 재진입 deadlock
- **재귀(Recursive)**: 동일 스레드 중첩 lock 허용(카운트)
- **에러체크(Error-checking)**: 잘못된 사용(이중 unlock 등)을 에러로 반환
- **견고(Robust, `PTHREAD_MUTEX_ROBUST`)**: **소유자 사망**(크래시) 감지 후 **일관성 복구** 가능
- **PI(우선순위 상속)**: RT 시스템에서 우선순위 역전 완화(`PTHREAD_PRIO_INHERIT`)

#### (예제) 견고(robust) 뮤텍스: 크래시 복구 패턴
```c
// robust_mutex.c
#define _GNU_SOURCE
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

typedef struct Shared {
    pthread_mutex_t m;
    int value;
} Shared;

static void robust_init(Shared* s){
    pthread_mutexattr_t a; pthread_mutexattr_init(&a);
    pthread_mutexattr_setrobust(&a, PTHREAD_MUTEX_ROBUST);
    pthread_mutexattr_setpshared(&a, PTHREAD_PROCESS_PRIVATE);
    pthread_mutex_init(&s->m, &a);
    s->value = 0;
}

int main(){
    Shared s; robust_init(&s);
    pid_t pid = fork();
    if(pid==0){ // child: lock then crash
        int r = pthread_mutex_lock(&s.m);
        if(r==EOWNERDEAD){ pthread_mutex_consistent(&s.m); }
        s.value = 123;
        _exit(1); // crash-like
    }
    sleep(1);
    int r = pthread_mutex_lock(&s.m);
    if(r==EOWNERDEAD){
        // 소유자 사망 → 상태 복구/롤백 후 일관성 표시
        // ex) s.value 롤백 or 재계산 ...
        pthread_mutex_consistent(&s.m);
    }
    printf("value=%d\n", s.value);
    pthread_mutex_unlock(&s.m);
}
```

> **포인트**: robust 락은 **공유 상태 일관성 복구 책임**을 호출자에게 넘긴다.

#### (예제) PI(우선순위 상속) 뮤텍스
```c
// pi_mutex.c (root/RT 권한 필요할 수 있음)
#include <pthread.h>
#include <sched.h>
#include <stdio.h>
int main(){
  pthread_mutexattr_t a; pthread_mutexattr_init(&a);
  pthread_mutexattr_setprotocol(&a, PTHREAD_PRIO_INHERIT);
  pthread_mutex_t m; pthread_mutex_init(&m,&a);
  // H/L 스레드를 만들어 L이 m을 오래 잡고 있고, M이 중간 우선순위로 바쁘게 돌면,
  // H가 대기 시 L이 H의 우선순위를 상속받아 역전을 완화.
  return 0;
}
```

### 7.3.2 조건변수: Mesa 의미론(반드시 while)

- **스푸리어스 웨이크업** 가능 → `while (!pred) pthread_cond_wait(...)`
- **타임아웃**: `pthread_cond_timedwait` (절대시간 `CLOCK_REALTIME` 또는 `CLOCK_MONOTONIC`)

#### (예제) Bounded Buffer — `cond` 두 개로 혼합 대기열 최적화
```c
// bb_cond.c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#define CAP 8
int q[CAP], h=0, t=0, cnt=0;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t not_full = PTHREAD_COND_INITIALIZER;
pthread_cond_t not_empty= PTHREAD_COND_INITIALIZER;

void put(int x){
  pthread_mutex_lock(&m);
  while(cnt==CAP) pthread_cond_wait(&not_full,&m);
  q[h]=x; h=(h+1)%CAP; cnt++;
  pthread_mutex_unlock(&m);
  pthread_cond_signal(&not_empty);
}
int take(){
  pthread_mutex_lock(&m);
  while(cnt==0) pthread_cond_wait(&not_empty,&m);
  int v=q[t]; t=(t+1)%CAP; cnt--;
  pthread_mutex_unlock(&m);
  pthread_cond_signal(&not_full);
  return v;
}
```

### 7.3.3 RW락 & 배리어

```c
// rw_and_barrier.c
#include <pthread.h>
#include <stdio.h>
pthread_rwlock_t rw = PTHREAD_RWLOCK_INITIALIZER;
pthread_barrier_t barrier;

void* reader(void*){
  pthread_rwlock_rdlock(&rw);
  // read shared state...
  pthread_rwlock_unlock(&rw);
  return NULL;
}
void* writer(void*){
  pthread_rwlock_wrlock(&rw);
  // write shared state...
  pthread_rwlock_unlock(&rw);
  return NULL;
}
int main(){
  pthread_barrier_init(&barrier, NULL, 4); // 4 threads rendezvous
  // 쓰레드 생성 후 각자 barrier에서 동시 출발 등...
}
```

### 7.3.4 스핀락 & 메모리 모델

- **스핀락**은 **짧은 임계구역/낮은 경합**에서만 사용.
- C11 원자(`stdatomic.h`)로 CAS/TAS 구현 권장:
```c
// spin_ttas.c
#include <stdatomic.h>
typedef struct { _Atomic int s; } spin_t;
void lock(spin_t* L){
  for(;;){
    while(atomic_load_explicit(&L->s, memory_order_relaxed)) { /* spin read */ }
    int ex=0;
    if(atomic_compare_exchange_weak_explicit(&L->s,&ex,1, memory_order_acquire, memory_order_relaxed))
      return;
  }
}
void unlock(spin_t* L){ atomic_store_explicit(&L->s,0, memory_order_release); }
```

### 7.3.5 세마포어: 프로세스 간 공유

- `sem_init(&sem, pshared=1, value)` 로 **익명** 세마포어를 **프로세스 간** 공유 가능(공유 메모리 상).
- Named 세마포어: `sem_open("/name", O_CREAT, …, value)` → 다른 프로세스에서 열기 가능.

```c
// named_sem_writer.c
#include <semaphore.h>
#include <fcntl.h>
int main(){
  sem_t* s = sem_open("/demo_sema", O_CREAT, 0644, 0);
  // 생산 후
  sem_post(s);
}
```

### 7.3.6 타임아웃·취소·신호

- **취소 안전성**: `pthread_cleanup_push/pop` 으로 unlock 보장
- **시그널**: `pthread_cond_timedwait`는 `EINTR`로 깰 수 있음 → 루프 재시도

```c
// cancel_safe.c
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
void* worker(void*){
  pthread_mutex_lock(&m);
  pthread_cleanup_push((void(*)(void*))pthread_mutex_unlock, &m);
  // 작업 중 취소되더라도 unlock 실행
  // ...
  pthread_cleanup_pop(1); // 1 → cleanup 실행
  return NULL;
}
```

---

## 7.4 Synchronization in Java

Java는 **내장 모니터(synchronized)** 와 **`java.util.concurrent`** 를 통해 **고수준 동기화**와 **스레드풀/큐**를 제공한다. 또한 **Java Memory Model (JMM)** 이 `happens-before` 규칙으로 가시성과 순서를 정의한다.

### 7.4.1 JMM 핵심 정리

- **모니터 락의 해제 → 이후 그 락을 획득한 스레드에게 모든 쓰기가 보임** (release-acquire)
- **`volatile` 쓰기 → 다음 읽기에게 보임** (store-load fence)
- **스레드 시작/조인** 도 `happens-before` 관계를 부여

### 7.4.2 `synchronized` + `wait/notify(All)`

- Mesa 의미론: **`while (!pred) wait()`**
- 혼합 대기열에서는 `notifyAll()` 또는 **조건 분할** 권장

```java
// BoundedBuffer.java (재확인)
public synchronized void put(T x) throws InterruptedException {
    while(count==buf.length) wait();
    buf[head] = x; head=(head+1)%buf.length; count++;
    notifyAll();
}
public synchronized T take() throws InterruptedException {
    while(count==0) wait();
    T v = (T)buf[tail]; tail=(tail+1)%buf.length; count--;
    notifyAll(); return v;
}
```

### 7.4.3 `ReentrantLock` & `Condition`

- **공정 모드(fair=true)** 지원(기아 완화)
- **타임아웃**/**인터럽트 가능 잠금** 제공
- **다중 조건 변수**로 정확한 predicate 분리

```java
// ReentrantLock + Condition
import java.util.concurrent.locks.*;
class BoundedBuffer2<T>{
  final Lock lock = new ReentrantLock(true); // 공정
  final Condition notFull = lock.newCondition();
  final Condition notEmpty= lock.newCondition();
  final Object[] q; int h=0,t=0,cnt=0;
  BoundedBuffer2(int cap){ q=new Object[cap]; }
  void put(T x) throws InterruptedException {
    lock.lock();
    try{
      while(cnt==q.length) notFull.await();
      q[h]=x; h=(h+1)%q.length; cnt++;
      notEmpty.signal();
    } finally { lock.unlock(); }
  }
  @SuppressWarnings("unchecked")
  T take() throws InterruptedException {
    lock.lock();
    try{
      while(cnt==0) notEmpty.await();
      T v=(T)q[t]; t=(t+1)%q.length; cnt--;
      notFull.signal(); return v;
    } finally { lock.unlock(); }
  }
}
```

### 7.4.4 ReadWriteLock / StampedLock

- `ReentrantReadWriteLock`: 읽기 병행 허용, **writer 우선** 옵션
- `StampedLock`: **낙관적 읽기(optimistic read)** → 락 없이 읽고 **유효성 검사** 가능

```java
// StampedLock 낙관적 읽기
import java.util.concurrent.locks.StampedLock;
class Point {
  private double x, y;
  private final StampedLock sl = new StampedLock();
  double distanceFromOrigin(){
    long s = sl.tryOptimisticRead();
    double cx = x, cy = y;
    if(!sl.validate(s)){
      s = sl.readLock();
      try{ cx=x; cy=y; } finally { sl.unlockRead(s); }
    }
    return Math.hypot(cx,cy);
  }
  void move(double dx,double dy){
    long s = sl.writeLock();
    try{ x+=dx; y+=dy; } finally { sl.unlockWrite(s); }
  }
}
```

### 7.4.5 큐/스레드풀: `BlockingQueue` + `ExecutorService`

- 직접 `wait/notify`를 구현하기보다 **검증된 큐**(`ArrayBlockingQueue`, `LinkedBlockingQueue`)와 **스레드풀**을 조합

```java
// Pipeline with Executor + BlockingQueue
import java.util.concurrent.*;
class Pipeline {
  final BlockingQueue<String> q = new ArrayBlockingQueue<>(1024);
  final ExecutorService exec = Executors.newFixedThreadPool(4);
  void start(){
    exec.submit(() -> producer());
    for(int i=0;i<3;i++) exec.submit(() -> consumer());
  }
  void producer() throws Exception {
    for(int i=0;i<10000;i++) q.put("job-"+i);
  }
  void consumer() throws Exception {
    for(;;){
      String j = q.take();
      // process j...
    }
  }
}
```

### 7.4.6 동기화 유틸리티

- **`Semaphore`**: 정량 자원 제한(연결 수 등)
- **`CountDownLatch`**: N개 이벤트 기다렸다가 동시에 출발
- **`CyclicBarrier`**: 반복 배리어(라운드별 실행)
- **`Phaser`**: 파티 동적 변경 가능한 barrier
- **`Exchanger`**: 두 스레드 간 버퍼 교환
- **`LockSupport`**: 저수준 park/unpark (조건변수의 기반)

```java
// CountDownLatch: N-worker 완료 대기
CountDownLatch done = new CountDownLatch(N);
for(int i=0;i<N;i++){
  exec.submit(() -> { try{ /* work */ } finally { done.countDown(); } });
}
done.await(); // 모든 작업 완료까지 대기
```

### 7.4.7 원자/락프리: `Atomic*`, `LongAdder`, `VarHandle`

- `AtomicInteger/Long/Reference` — CAS 기반
- **`LongAdder`** — 고경합 카운터에 최적(셀 분할)
- `VarHandle` — JDK 9+, 저수준 메모리 오더 제어

```java
// LongAdder: 다중 코어에서 카운터 병목 완화
import java.util.concurrent.atomic.LongAdder;
LongAdder counter = new LongAdder();
void inc(){ counter.increment(); }
long snapshot(){ return counter.sum(); }
```

### 7.4.8 CompletableFuture / ForkJoinPool

- **비동기 파이프라인**으로 **락 없이** 흐름 구성(내부적으로 스레드풀/작업 큐)

```java
// CompletableFuture 체인
CompletableFuture
  .supplyAsync(() -> fetch())
  .thenApply(data -> transform(data))
  .thenAccept(out -> store(out));
```

> **주의**: 디폴트 풀은 `ForkJoinPool.commonPool()` — **블로킹 호출 포함 시 별도 풀** 사용.

### 7.4.9 베스트 프랙티스 & 함정

- `synchronized`는 간단한 불변식 관리에 적합, 고수준 동시성은 `java.util.concurrent` 우선
- `notify`보다 `notifyAll`을 기본값으로 고려(혼합 대기열)
- **시간제한 대기**를 습관화(활성 보장/복구 경로)
- **공유 자료**는 **불변(immutable)** 로 설계하여 락 요구 최소화
- **락 순서 규약** 수립(교착 예방)

---

## 7.5 Alternative Approaches  
*(락 외, 또는 락을 최소화하는 전략)*

### 7.5.1 Lock-free & Wait-free (CAS/FAA 기반)

- **장점**: 데드락/우선순위 역전 없음, 높은 병행성
- **단점**: 설계/검증 난이도↑, **ABA 문제**(참조가 같아 보여도 다른 객체) → **스탬프/세그먼트/해저드 포인터** 필요

#### (예제) Treiber Stack (C11 atomics)
```c
// treiber_stack.c — 학습용 단순 구현(ABA/메모리 재활용 문제 미처리)
#include <stdatomic.h>
#include <stdlib.h>
typedef struct Node { int v; struct Node* next; } Node;
_Atomic(Node*) head = NULL;

void push(int x){
  Node* n = malloc(sizeof(*n)); n->v=x;
  Node* h;
  do { h = atomic_load_explicit(&head, memory_order_relaxed);
       n->next = h;
  } while(!atomic_compare_exchange_weak_explicit(&head, &h, n,
            memory_order_release, memory_order_relaxed));
}
int pop(int* out){
  Node* h; Node* nxt;
  do { h = atomic_load_explicit(&head, memory_order_acquire);
       if(!h) return 0;
       nxt = h->next;
  } while(!atomic_compare_exchange_weak_explicit(&head, &h, nxt,
            memory_order_acq_rel, memory_order_relaxed));
  *out = h->v; free(h); return 1;
}
```

> **실무**: 메모리 재활용은 **Hazard Pointers / Epoch Reclamation(요구 시 RCU)** 로 해결.

#### (예제) Michael–Scott Queue (스케치)
- **단일 연결 큐** + **두 포인터(head/tail)** CAS 업데이트  
- 멀티 프로듀서/컨슈머에서 락 없이 선형화 가능

### 7.5.2 RCU (Read-Copy-Update)

- **읽기 다수/쓰기 드묾**: 읽기는 **락 없이** 스냅샷을 보고, 쓰기는 **복제-교체**, **그레이스 기간** 후 해제
- 커널에서 널리 쓰이며, 사용자 공간에도 라이브러리(`userspace RCU`) 존재

```c
// userspace_rcu 스타일 개념
// reader: rcu_read_lock(); p = rcu_dereference(ptr); use(p); rcu_read_unlock();
// writer: n=copy(); rcu_assign_pointer(ptr,n); synchronize_rcu(); free(old);
```

### 7.5.3 STM (Software Transactional Memory)

- **트랜잭션 블록** 내에서 읽기/쓰기 추적 → **커밋 시 충돌 검사**, 실패 시 재시도
- **장점**: 직관적, 데드락 없음  
- **단점**: 오버헤드, I/O/비순수 연산 취약, JVM/언어별 지원 한정
- Java 생태계: **Multiverse**, **JVSTM** 등 연구/실험적 사용(프로덕션 보편 X)

### 7.5.4 Actor / CSP / 메시지 전달

- **Actor 모델(Akka/Orleans)**: 각 Actor는 **자기 상태를 독점**, 메시지 큐로 통신 → 공유 상태 없음
- **CSP(Go 채널)**: 채널을 통해 **동기/비동기 전달**, 백프레셔/구조적 동시성
- **장점**: 락 설계 부담↓, 고수준 구조  
- **주의**: 메시지 순서/흐름제어/배압(backpressure), 큐 병목, 장애 복구 전략 필요

```go
// Go 채널 파이프라인(참고)
jobs := make(chan Job, 1024)
results := make(chan Res, 1024)
go producer(jobs)
for i:=0; i<4; i++ { go worker(jobs, results) }
```

### 7.5.5 불변(Immutable) & 영구(Persistent) 자료구조

- **카피-온-라이트 / 구조적 공유**로 **읽기 병행성↑**, GC 환경(JVM/FP 언어)에 적합
- **장점**: 락 대부분 제거, 스냅샷/버전 관리 용이  
- **단점**: 쓰기 패스 메모리/할당 비용, 대형 구조 업데이트 시 주의

### 7.5.6 데이터 흐름(데이터플로우) / 스트림

- **Reactive Streams** / **Project Reactor**, **RxJava**: **배압**/비동기 파이프라인 표준화  
- **CompletableFuture**와 조합하여 CPU 바운드/IO 바운드 분리

### 7.5.7 수학적 관점 — 직렬화 오버헤드의 상한  
락/동기화의 비용을 **직렬화 비율**로 근사하면, **암달의 법칙**:

$$
S(N) = \frac{1}{(1-P) + \frac{P}{N}}
$$

- \(P\): 병렬화 가능한 비율, \((1-P)\): 직렬(락) 구간  
- 락을 줄여 \((1-P)\)를 낮추는 것이 핵심. **락 분할/샤딩/락프리**가 이를 직접 줄이는 전략.

---

## 종합 실습 시나리오

### 실습 A — POSIX Cond vs BlockingQueue 성능/활성 비교
- **작업**: Producer 1, Consumer 3; 요청 분포(포아송/벌스트) 바꾸어
- **비교**: `bb_cond.c` vs Java `BlockingQueue` 파이프라인
- **지표**: p95 소비자 대기시간, 처리량, 컨텍스트 스위치 수

### 실습 B — RWLock 정책 vs StampedLock 낙관 읽기
- 읽기:쓰기 비율 9:1, 1:1, 1:9에서 **응답시간/처리량** 비교
- 큰 구조: `StampedLock` 낙관적 읽기가 **캐시 친화**인지 관측

### 실습 C — Lock-free vs Mutex 큐
- **MSQueue**(락프리) vs `std::mutex` 보호 큐
- **지표**: 고경합(코어↑)에서 처리량, tail latency, 스핀 시간

---

## 운영 체크리스트

- **정확성**: 모든 대기 `while (predicate)` — 스푸리어스/경쟁에 안전  
- **활성**: 타임아웃/백오프/공정 큐로 기아 방지  
- **성능**: 경합 핫스팟 → **락 분할/샤딩**, 구조적 공유/불변화  
- **플랫폼**: POSIX에선 robust/PI 뮤텍스 옵션 검토, JVM에선 `LongAdder`/`StampedLock`/`BlockingQueue` 우선  
- **관측**: p95/p99, 컨텍스트 스위치, 캐시미스/NUMA 원격 비율, 깨어남 효율(깨운 수 대비 진입 수)

---

## 한눈 요약

- **POSIX(7.3)**: 상황별 도구(robust/PI/cond timedwait/RW/barrier/sem). 반드시 `while` 대기·타임아웃·취소 안전.  
- **Java(7.4)**: JMM의 HB 규칙에 의존. 고수준 `java.util.concurrent`가 기본. `StampedLock`/`LongAdder`로 병목 완화.  
- **Alternative(7.5)**: **락프리/RCU/Actor/STM/불변 자료구조**로 직렬 구간 자체를 줄여 스케일을 확보하라.
