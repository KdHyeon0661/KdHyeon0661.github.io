---
layout: post
title: 운영체제 - 보호 (1)
date: 2025-11-02 14:25:23 +0900
category: 운영체제
---
# Chapter 17 — Protection

## 17.1 Goals of Protection

### 17.1.1 무엇을, 왜 보호하나
운영체제의 **Protection(보호)** 는 서로 다른 주체(사용자·프로세스·커널·장치)가 **공존**하는 환경에서 다음을 보장하는 메커니즘이다.

- **Isolation**: 서로의 메모리·자원 침범 금지(무결성·기밀성).
- **Controlled Sharing**: **정의된 정책** 안에서만 공유(권한·범위·시간 제한).
- **Accountability**: 행동을 **추적**할 수 있어야 함(감사·로깅).
- **Revocation**: 부여한 권한을 **회수**할 수 있어야 함.
- **Flexibility & Usability**: 실제 운영에 부담이 없고 **정책 변경**이 쉬워야 함.
- **Performance**: 보호 때문에 시스템이 **지나치게 느려지지 않도록**.

### 17.1.2 도메인과 객체: 추상 모델
- **Subject(주체)**: 실행하는 엔티티(프로세스/스레드/사용자/커널).
- **Object(객체)**: 접근 대상(파일/디렉터리/소켓/메모리/디바이스/IPC).
- **Operation(권한)**: read, write, execute, append, ioctl…
- **Domain(보호 도메인)**: 주체가 행사할 수 있는 **권한 집합**.

#### Access-Matrix(접근 행렬) 모델
행렬 $$M$$ 의 행은 **주체(또는 도메인)**, 열은 **객체**, 원소는 **권한 집합**이다.
$$
M: S \times O \to 2^{R},\quad M[s,o]\subseteq R
$$
- **Grant/Remove** 연산으로 권한을 추가/철회.
- 행렬을 실제로 저장하는 대신 **객체 중심(ACL)** 또는 **주체 중심(Capabilities)** 으로 **희소 표현**한다.

### 17.1.3 구현 스타일: ACL vs Capability
- **ACL (Access Control List)**: *객체*가 “누가 무엇을 할 수 있는지” 리스트로 보유.
  - 장점: 객체 소유자가 **중앙집중적으로** 관리/철회 쉬움.
  - 단점: **권한 전달**(delegation)·세밀한 Least Privilege 구현이 상대적으로 번거로움.
- **Capability (능력, 토큰)**: *주체*가 “무엇을 할 수 있는지”를 **증표(참조, 핸들)** 로 보유.
  - 장점: **소유=권한**, 최소권한·권한 전파/복제 용이, **참조 투명**.
  - 단점: 분실/도난·**대규모 철회** 어려움 → **간접 테이블/만료/버전**으로 보완.

> Unix에서 **파일 디스크립터(FD)** 는 대표적인 “능력”: *FD를 가진 자만* 해당 객체에 접근 가능(권한은 open 시 결정, 이후는 **경로가 아닌 FD** 로 접근).

### 17.1.4 정책과 메커니즘
- **정책**(Policy): “무엇을 허용/금지할지”(예: 사용자 A는 /srv/log를 읽기만).
- **메커니즘**(Mechanism): 정책을 강제하는 수단(ACL, cap, 라벨, 링 전환, 페이지 권한).
- 분리의 이점: **정책 교체**가 쉬움(회사/규정 요구 반영).

### 17.1.5 실무 목표와 지표
- **Least Privilege** 달성 정도(프로세스가 가진 권한 수/면적).
- **Revocation Latency**(권한 철회→실효까지의 시간).
- **Complete Mediation Coverage**(모든 경로가 참조 모니터를 거치는가).
- **Break-glass** 절차(비상시 권한 상승)와 **감사 가능성**.

---

### 17.1.6 예제 ①—접근 행렬을 ACL로 구현(개념 코드, Python)
```python
# acl_matrix.py — Access Matrix를 ACL(객체 중심)로 희소 표현
from collections import defaultdict

class ACLFS:
    def __init__(self):
        self.acl = defaultdict(lambda: defaultdict(set))  # object -> {subject -> {rights}}
        self.store = {}  # object -> data

    def create(self, obj, owner):
        self.store[obj] = b""
        self.acl[obj][owner] |= {"read","write","grant","revoke"}

    def grant(self, obj, owner, subject, rights):
        assert "grant" in self.acl[obj][owner]
        self.acl[obj][subject] |= set(rights)

    def revoke(self, obj, owner, subject, rights):
        assert "revoke" in self.acl[obj][owner]
        self.acl[obj][subject] -= set(rights)

    def read(self, obj, subject):
        if "read" not in self.acl[obj][subject]: raise PermissionError
        return self.store[obj]

    def write(self, obj, subject, data):
        if "write" not in self.acl[obj][subject]: raise PermissionError
        self.store[obj] = data

fs = ACLFS()
fs.create("/doc","alice")
fs.grant("/doc","alice","bob",["read"])
print(fs.read("/doc","bob"))
```

### 17.1.7 예제 ②—“FD=능력” 패턴으로 최소권한 서버 만들기 (Python)
```python
# cap_dir_server.py — 디렉터리 FD를 "능력(capability)"로 전달하여, 그 아래에서만 파일 조작
# 핵심: openat(디렉터리FD, 상대경로) 패턴으로 경로 탈출/경쟁을 원천 차단
import os, socket, struct

def send_fd(sock, fd):
    sock.sendmsg([b"X"], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, struct.pack("i", fd))])

def recv_fd(sock):
    msg, anc, *_ = sock.recvmsg(1, socket.CMSG_SPACE(struct.calcsize("i")))
    for c in anc:
        if c[0]==socket.SOL_SOCKET and c[1]==socket.SCM_RIGHTS:
            return struct.unpack("i", c[2][:struct.calcsize("i")])[0]

# 서버: /srv/data 디렉터리 FD를 클라이언트에 '능력'으로 전달
if __name__ == "__main__":
    srv_dirfd = os.open("/srv/data", os.O_RDONLY | os.O_DIRECTORY)
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    addr = "/tmp/cap.sock"
    try: os.unlink(addr)
    except FileNotFoundError: pass
    s.bind(addr); s.listen(1)
    c,_ = s.accept()
    with c:
        send_fd(c, srv_dirfd)
        os.close(srv_dirfd)
```

```python
# cap_dir_client.py — 전달받은 "디렉터리 능력"으로만 파일 열기
import os, socket, struct

def recv_fd(sock):
    msg, anc, *_ = sock.recvmsg(1, 256)
    for c in anc:
        if c[0]==socket.SOL_SOCKET and c[1]==socket.SCM_RIGHTS:
            return struct.unpack("i", c[2][:4])[0]

c = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
c.connect("/tmp/cap.sock")
dirfd = recv_fd(c)

# 오직 dirfd 하위에서만 파일 생성/쓰기
fd = os.openat(dirfd, "note.txt", os.O_CREAT|os.O_WRONLY|os.O_TRUNC, 0o644)
os.write(fd, b"Hello, capability!\n"); os.close(fd)
```
> **핵심**: 클라이언트는 **경로 권한**이 아니라 **FD 능력**으로만 작업한다. 서버가 FD를 회수(소켓 종료)하면 **즉시 추가 오픈 불가**(간접 테이블로 **Revocation** 구현 가능).

---

## 17.2 Principles of Protection

Saltzer & Schroeder의 고전 원칙을 **OS 관점**에서 재해석한다.

### 17.2.1 최소권한(Least Privilege)
프로세스는 **필요한 최소 권한**만 갖는다.
- Linux: **capabilities** 로 root 권한을 쪼갠다(예: `CAP_NET_BIND_SERVICE`).

```bash
# 1024 미만 포트 바인드만 필요한 바이너리에 해당 capability 부여
sudo setcap 'cap_net_bind_service=+ep' /usr/local/bin/myweb
```

```c
// bind443.c — root 전체가 아닌 "바인드 권한"만 필요
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
int main(){
  int s=socket(AF_INET,SOCK_STREAM,0);
  struct sockaddr_in a={.sin_family=AF_INET,.sin_port=htons(443),.sin_addr.s_addr=INADDR_ANY};
  bind(s,(struct sockaddr*)&a,sizeof(a)); listen(s,128);
  for(;;){ int c=accept(s,0,0); write(c,"HTTP/1.1 200 OK\r\n\r\nhi\n",24); close(c); }
}
```

### 17.2.2 기본 거부(Fail-Safe Defaults)
명시적으로 허용되지 않으면 **거부**.
- 파일 생성 시 **umask** 설정, 방화벽 **기본 거부**.

```bash
umask 027   # 새 파일은 그룹 읽기/실행만, others는 없음
```

### 17.2.3 완전중재(Complete Mediation)
모든 접근이 **참조 모니터**를 지나야 함.
- 커널의 **VFS**/LSM(SELinux/AppArmor) 훅이 모든 `open/read/write` 를 **중재**.
- 사용자 캐시(dentry cache)라도 **권한 변경** 시 재검증.

### 17.2.4 경제성(Economy of Mechanism)
메커니즘은 **단순**해야 검증·구현·운영이 쉬움.
- 작은 **TCB**: 마이크로커널/유저모드 드라이버가 이상적(검증 용이).

### 17.2.5 개방설계(Open Design)
보안은 **비밀 설계**가 아니라 **검증된 설계**에서 나온다.
- 알고리즘/정책은 공개·검증, **키만 비밀**.

### 17.2.6 권한분리(Separation of Privilege)
두 개 이상의 **독립 조건**이 충족되어야 권한 부여.
- 예: setuid helper + 정책 데몬 승인이 **모두** 필요.

### 17.2.7 공통기제 최소화(Least Common Mechanism)
공유 자원(IPC/전역 상태)을 줄인다.
- `/tmp` 는 **sticky bit** 로 보호, 가능하면 **개별 네임스페이스** 사용.

```bash
# /tmp 는 보통 sticky bit가 설정됨: drwxrwxrwt
ls -ld /tmp
```

### 17.2.8 심리적 수용성(Psychological Acceptability)
보안은 **사용 가능**해야 지켜진다.
- 명확한 오류, 합리적 MFA, 관리 가능한 정책(예: 명시적 권한 요청 프롬프트).

---

### 17.2.9 예제—권한 드롭 & 경로 고정(openat) & seccomp
```c
// sandbox_drop.c — chroot + setuid + openat + seccomp(개념)로 최소권한 샌드박스
#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/prctl.h>
#include <linux/seccomp.h>
#include <linux/filter.h>
#include <linux/audit.h>

static void die(const char* m){perror(m); _exit(1);}

int main(){
  // 1) 작업 디렉터리 고정 (루트 변경: 데모용 — 실제는 pivot_root/명확한 준비 필요)
  if (chroot("/srv/jail")<0 || chdir("/")<0) die("chroot/chdir");

  // 2) 권한 드롭(비특권 사용자 1000으로)
  if (setgid(1000)<0 || setuid(1000)<0) die("setid");

  // 3) openat — 디렉터리 FD 기준으로만 파일 접근
  int dfd = open("/data", O_DIRECTORY|O_RDONLY); if(dfd<0) die("open dir");
  int fd = openat(dfd, "input.txt", O_RDONLY|O_NOFOLLOW|O_CLOEXEC);
  if(fd<0) die("openat"); char buf[64]={0}; read(fd,buf,63); puts(buf);

  // 4) seccomp — read/write/exit만 허용(간략한 BPF 필터 — 실제는 libseccomp 권장)
  // 생략: BPF 바이트코드 설정(정식 필터는 길어짐). 튜토리얼 환경에서 적용.

  return 0;
}
```

---

## 17.3 Protection Rings

### 17.3.1 개념
**Protection Ring** 은 **CPU 특권 수준**을 동심원처럼 구분해 **특권 명령/자원**을 **내부 링에만** 허용하는 모델이다.

```
Ring 0  : 커널 (가장 강한 권한)
Ring 1-2: (x86에서 거의 미사용, 일부 OS/드라이버)
Ring 3  : 사용자 프로그램
```

- **특권 명령**(x86: `cli`, `hlt`, CRx 접근 등)은 **Ring 0** 에서만 가능.
- **모드 전환**: 시스템콜, 예외, 인터럽트 → **게이트**를 통해 **상위 특권**으로 진입.
- **메모리 보호**: 페이지 테이블의 **U/S bit**, **W^X**, **SMEP/SMAP**(커널에서 user 주소 실행/접근 금지).

> 현대 OS는 주로 **Ring 0(커널)/Ring 3(유저)** 2계층을 사용한다. (Ring 1-2는 미활용)

### 17.3.2 x86 보호: CPL/DPL/RPL & 게이트
- **CPL(Current Privilege Level)**: 현재 코드의 링(보통 3 또는 0).
- **DPL(Descriptor Privilege Level)**: 세그먼트/게이트의 필요 권한.
- **RPL(Requester PL)**: 셀렉터에 담긴 요청자 레벨.
- 접근 조건은 대략 $$\max(CPL, RPL) \le DPL$$ 을 만족해야 함.
- **Call Gate** 를 통해 **제한된 진입점**을 제공(현대 Linux는 `syscall/sysenter` 사용).

### 17.3.3 시스템콜: 사용자→커널의 “안전한 문”
- **x86-64**: `syscall`/`sysret` (MSR로 진입/복귀 대상 설정).
- **x86-32**: `sysenter`/`sysexit` 또는 `int 0x80`.
- 커널은 **사용자 포인터 검증**(`copy_from_user`)로 경계 보호.

```c
// syscall_getpid.c — 사용자에서 시스템콜 진입(현대에선 libc가 래핑; 개념용)
#include <unistd.h>
#include <sys/syscall.h>
#include <stdio.h>
int main(){
  long pid = syscall(SYS_getpid); // libc getpid()와 동일 효과
  printf("pid=%ld\n", pid);
}
```

### 17.3.4 ARM/RISC-V의 특권 레벨
- **ARMv8-A**: **EL0(유저) / EL1(OS) / EL2(하이퍼바이저) / EL3(시큐어 모니터: TrustZone)**.
  - 유저→커널: **SVC**(Supervisor Call).
  - 가상화: **EL2**에서 게스트 OS를 **격리**.
- **RISC-V**: **U/S/M**(User/Supervisor/Machine) + **HS** 확장(하이퍼바이저).

### 17.3.5 페이지 보호 & SMEP/SMAP(W^X)
- **U/S bit**: 커널 페이지를 유저 모드에서 접근 금지.
- **SMEP**: 커널이 **유저 공간 코드 실행 금지**.
- **SMAP**: 커널이 **유저 공간 데이터 접근 금지**(명시적 우회 필요).
- **W^X**: 쓰기 가능(Write)인 페이지는 실행(Execute) 금지 → JIT은 별도 페이지 관리.

### 17.3.6 인터럽트·예외: 비의도적 링 전환
- **페이지 폴트** 등 예외 발생 시 커널로 전환 → 처리 후 복귀.
- 커널은 **사용자 유래** 주소를 다룰 때 항상 **검증**.

### 17.3.7 하이퍼바이저(가상화)와 링
- 전통 x86은 게스트 커널을 Ring 1/3에 “**링 압축**” 하여 실행 → 성능·정확성 문제.
- **VT-x/AMD-V** 이후: **루트/논루트 모드** 개념으로 하이퍼바이저가 **게스트의 Ring 0** 을 **가상화**.

### 17.3.8 마이크로커널 vs 모놀리식과 링
- **모놀리식**: OS 서비스(파일/네트워크/드라이버)가 **Ring 0**(TCB 큼).
- **마이크로커널**: 최소 커널만 Ring 0, 나머지는 **유저 공간 서버**(메시지 전달).
  - 장점: **TCB 축소**, 오류 격리.
  - 단점: IPC 비용·설계 복잡성.

---

### 17.3.9 예제—“특권 명령”을 유저 모드에서 실행하면?
다음과 같은 명령(예: `hlt`, `cli`, 제어레지스터 접근)은 **CPL=0** 에서만 가능.
유저 모드에서 시도하면 일반적으로 **#GP(일반 보호 예외)** 가 발생하고 프로세스는 시그널(리눅스: SIGILL/SEGV)을 받는다.

```c
// priv_fault.c — (빌드/실행 환경에 따라) 유저 모드에서 특권 명령 시도 → 실패
int main(){
  __asm__ __volatile__("cli"); // 유저에서 금지 → 예외
  return 0;
}
```
> 실제 실습은 권장하지 않는다(시스템 설정/에뮬레이터에서만). 핵심은 “**링에 의해 명령 자체가 차단**”됨을 이해.

### 17.3.10 예제—SMEP/SMAP & 경계 검증(개념)
커널은 유저 포인터를 받을 때 반드시 **copy_from_user** 류 루틴으로 검증/복사한다.
SMEP/SMAP 활성 시 잘못된 경로로 유저 메모리 실행/접근을 시도하면 **즉시 예외**.

---

## 정리: 설계에서 운영까지

1) **목표(17.1)**: Isolation·Controlled Sharing·Revocation·Audit을 달성하려면 **Access Matrix** 사고와 **ACL/Capability** 의 장단을 숙지해야 한다.
2) **원칙(17.2)**: **Least Privilege** 를 실무에서 구현하는 도구는 **capabilities, openat, seccomp, chroot/namespace, W^X** 이다. **Fail-safe defaults** 와 **Complete mediation** 을 잊지 말라.
3) **링(17.3)**: 하드웨어 **특권 레벨** 은 보안의 물리적 토대다. **시스템콜 게이트** 는 유저→커널의 **유일한 문**이며, **SMEP/SMAP/W^X** 가 경계 오용을 차단한다. 가상화/마이크로커널은 **TCB 축소** 와 **격리 강화**의 전략이다.

---

## 추가 실습 스니펫 모음

### A) Linux capabilities로 “root 없이 80/443 바인드”
```bash
sudo setcap 'cap_net_bind_service=+ep' /usr/local/bin/myweb
getcap /usr/local/bin/myweb
```

### B) Revocation 패턴: 핸들 테이블로 능력 회수(개념)
```python
# revoke_cap.py — capability handle에 "활성 플래그"를 두고 회수
class CapTable:
    def __init__(self): self._table = {}  # id -> (obj, active)
    def issue(self, obj):
        cid = os.urandom(8).hex()
        self._table[cid] = [obj, True]; return cid
    def revoke(self, cid):
        if cid in self._table: self._table[cid][1] = False
    def use(self, cid, op, *a):
        obj, active = self._table[cid]
        if not active: raise PermissionError("revoked")
        return getattr(obj, op)(*a)
```

### C) 최소공유: /tmp 대신 전용 네임스페이스 사용
```bash
unshare -mUf --propagation private bash -c 'mount -t tmpfs tmpfs /tmp && echo isolated >/tmp/x && ls -l /tmp'
```

---

## 수식·개념 요약 카드

- **접근 행렬**: $$M[s,o]\subseteq R, \;\; \text{Grant/Remove}$$
- **권한 전달 안전성**: **권한 단조성** $$\forall s,o:\; M' [s,o] \supseteq M[s,o] \Rightarrow \text{(허용 범위만 증가)}$$ 를 유지하되 **Revocation** 을 위해 **간접 참조** 필요.
- **링 접근 조건**: $$\max(\mathrm{CPL}, \mathrm{RPL}) \le \mathrm{DPL}$$
- **TCB 최소화**: $$\text{Risk} \approx \text{Attack Surface} \times \text{Impact} \;\; \downarrow $$ → 마이크로커널/격리/정적 정책.
