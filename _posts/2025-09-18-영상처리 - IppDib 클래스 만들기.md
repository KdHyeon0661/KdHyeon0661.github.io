---
layout: post
title: 영상처리 - IppDib 클래스
date: 2025-09-18 14:25:23 +0900
category: 영상처리
---
# IppDib 클래스

> 이번 장에서는 Windows GDI 기반의 **DIBSECTION 래퍼**인 **IppDib** 클래스를 처음부터 끝까지 설계/구현합니다.
> 목표:
> 1) **비트맵 생성/소멸/리사이즈**
> 2) **BMP 파일 입출력(불러오기/저장)** — 8/24/32bpp 안전 처리
> 3) **화면 출력** — `SetDIBitsToDevice` / `StretchDIBits` / `BitBlt`
> 4) **클립보드 복사/붙여넣기** — `CF_DIBV5` 우선, `CF_DIB`/`CF_BITMAP` 대응
> 5) **기타 유틸** — 연산자/정보 조회/간단 픽셀 연산 등

---

## 설계 개요 — 내부 표현과 책임 분리

- **내부 포맷**: **Top-Down 32bpp BGRA**(또는 BGRX) — `CreateDIBSection`으로 확보
  - 장점: 행 순서 뒤집기 문제 제거, GDI 출력 단순화, 픽셀 접근 용이
- **소유 자원**: `HBITMAP`(DIBSECTION), `HDC`(메모리 DC), `bits` 포인터
- **기능 경계**
  - **IppDib**: 화면 출력, 클립보드, DIB 핸들 관리, BMP I/O(실습 범위)
  - **IppImage**(이전 장): 알고리즘/타입 일반화. IppDib은 **표시/교환** 중심

> 실무에서는 IppDib을 **뷰어/GUI 계층**에 두고, **핵심 처리**는 IppImage로 수행 후 필요 시 **IppDib.update()** 로 싱크를 맞추는 패턴을 권장합니다.

---

## IppDib 클래스 추가 (헤더)

### 헤더 파일: `IppDib.h`

```cpp
#pragma once
#ifdef _WIN32
#include <windows.h>
#include <cstdint>
#include <string>
#include <vector>
#include <stdexcept>
#include <cstring>
#include <algorithm>

struct IppDib
{
    // 소유 리소스
    HBITMAP  m_hbm   = nullptr;  // DIBSECTION 핸들
    HDC      m_memdc = nullptr;  // 메모리 DC
    void*    m_bits  = nullptr;  // Top-Down BGRA32
    int      m_w = 0, m_h = 0, m_stride = 0;

    // 수명
    IppDib() = default;
    ~IppDib() { destroy(); }
    IppDib(const IppDib&) = delete;
    IppDib& operator=(const IppDib&) = delete;
    IppDib(IppDib&& o) noexcept { move_from(std::move(o)); }
    IppDib& operator=(IppDib&& o) noexcept { if (this!=&o){ destroy(); move_from(std::move(o)); } return *this; }

    // 생성/파괴/리셋
    bool     create(HDC refDC, int w, int h, bool withAlpha = false); // 32bpp BGRA/X, Top-Down
    void     destroy();
    bool     resize(HDC refDC, int w, int h, bool keep = false, bool withAlpha = false); // keep: 보존
    void     clear(uint8_t gray = 0);                        // B=G=R=gray, A=255

    // 상태/정보
    explicit operator bool() const { return m_hbm && m_memdc && m_bits && m_w>0 && m_h>0; }
    int      width()  const { return m_w; }
    int      height() const { return m_h; }
    int      stride() const { return m_stride; }
    HBITMAP  handle() const { return m_hbm; }
    HDC      memdc()  const { return m_memdc; }
    void*    bits()         { return m_bits; }
    const void* bits() const{ return m_bits; }

    // 픽셀 접근 (주의: 범위 체크는 호출자가)
    struct BGRA { uint8_t b,g,r,a; };
    BGRA*       pixel(int x, int y)       { return reinterpret_cast<BGRA*>((uint8_t*)m_bits + (size_t)y*m_stride) + x; }
    const BGRA* pixel(int x, int y) const { return reinterpret_cast<const BGRA*>((const uint8_t*)m_bits + (size_t)y*m_stride) + x; }
    BGRA&       operator()(int x,int y)       { return *pixel(x,y); }
    const BGRA& operator()(int x,int y) const { return *pixel(x,y); }

    // 화면 출력
    void draw(HDC hdc, int x, int y) const;                            // 1:1
    void draw(HDC hdc, const RECT& dst, DWORD rop = SRCCOPY, int stretchMode = HALFTONE) const; // 스케일
    void draw(HDC hdc, const RECT& dst, const RECT& src, DWORD rop = SRCCOPY, int stretchMode = HALFTONE) const; // 부분 스케일

    // BMP I/O (8/24/32bpp BI_RGB, 16bpp BITFIELDS 일부 지원)
    bool loadBMP(const std::wstring& path, HDC refDC = nullptr);       // 내부 BGRA32로 변환
    bool saveBMP(const std::wstring& path, int fileBpp = 24) const;    // 24 또는 32 권장

    // 클립보드 (CF_DIBV5 우선, CF_DIB/CF_BITMAP 대응)
    bool copyToClipboard(HWND owner) const;
    bool pasteFromClipboard(HWND owner, HDC refDC = nullptr);

    // 유틸
    void invert();                      // B,G,R 반전
    void premultiplyAlpha();            // A 기반 pre-mul (옵션)
    std::wstring infoString() const;    // 디버그/툴팁용 정보
private:
    void move_from(IppDib&& o);
};
#endif // _WIN32

```

> **디자인 포인트**
> - **Top-Down**(`biHeight<0`)으로 만들기 때문에, 파일 저장 시엔 **Bottom-Up 변환**을 수행합니다.
> - **draw**는 `BitBlt/StretchBlt` 경로(메모리 DC → 대상 DC)로 처리하고, `StretchDIBits` 경로와 성능 차이는 미미하며 코드가 단순합니다.
> - **클립보드**는 **CF_DIBV5**를 최우선(Top-Down/DPI/알파 친화), 호환성을 위해 **CF_DIB**/`CF_BITMAP`도 수용합니다.

---

## 비트맵 생성과 소멸 (구현)

### 구현 파일: `IppDib.cpp` — 생성/소멸/리사이즈

```cpp
#ifdef _WIN32
#include "IppDib.h"

void IppDib::move_from(IppDib&& o){
    m_hbm=o.m_hbm; m_memdc=o.m_memdc; m_bits=o.m_bits; m_w=o.m_w; m_h=o.m_h; m_stride=o.m_stride;
    o.m_hbm=nullptr; o.m_memdc=nullptr; o.m_bits=nullptr; o.m_w=o.m_h=o.m_stride=0;
}

bool IppDib::create(HDC refDC, int w, int h, bool withAlpha)
{
    destroy();
    if (w<=0 || h<=0) return false;

    // 참조 DC가 없으면 스크린 DC 사용
    HDC hdc = refDC ? refDC : GetDC(nullptr);

    BITMAPINFO bmi{}; // 32bpp Top-Down
    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       = w;
    bmi.bmiHeader.biHeight      = -h;            // Top-Down
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;
    bmi.bmiHeader.biCompression = BI_RGB;        // BGRA(X)
    bmi.bmiHeader.biSizeImage   = (DWORD)(w*4*h);

    void* bits = nullptr;
    HBITMAP hbm = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &bits, nullptr, 0);
    if (!refDC) ReleaseDC(nullptr, hdc);
    if (!hbm || !bits) { if (hbm) DeleteObject(hbm); return false; }

    HDC mem = CreateCompatibleDC(hdc);
    if (!mem) { DeleteObject(hbm); return false; }
    SelectObject(mem, hbm);

    m_hbm=hbm; m_memdc=mem; m_bits=bits; m_w=w; m_h=h; m_stride=w*4;

    // 기본 알파 채널: withAlpha==true면 0xFF로 채움
    if (withAlpha) {
        for (int y=0;y<m_h;++y){
            uint8_t* r = reinterpret_cast<uint8_t*>(m_bits) + (size_t)y*m_stride;
            for (int x=0;x<m_w;++x) r[x*4+3] = 255;
        }
    }
    return true;
}

void IppDib::destroy()
{
    if (m_memdc) { DeleteDC(m_memdc); m_memdc=nullptr; }
    if (m_hbm)   { DeleteObject(m_hbm); m_hbm=nullptr; }
    m_bits=nullptr; m_w=m_h=m_stride=0;
}

bool IppDib::resize(HDC refDC, int w, int h, bool keep, bool withAlpha)
{
    if (w==m_w && h==m_h) return true;
    IppDib newdib;
    if (!newdib.create(refDC, w, h, withAlpha)) return false;

    if (keep && *this) {
        // 기존 내용을 중앙 정렬 복사 (겹치는 영역만)
        int cw = std::min(m_w, w);
        int ch = std::min(m_h, h);
        int sx = (m_w - cw)/2, sy = (m_h - ch)/2;
        int dx = (w - cw)/2,   dy = (h - ch)/2;
        BitBlt(newdib.m_memdc, dx, dy, cw, ch, m_memdc, sx, sy, SRCCOPY);
    }
    *this = std::move(newdib);
    return true;
}

void IppDib::clear(uint8_t gray)
{
    if (!*this) return;
    for (int y=0;y<m_h;++y) {
        uint8_t* r = (uint8_t*)m_bits + (size_t)y*m_stride;
        for (int x=0;x<m_w;++x){
            r[x*4+0]=gray; r[x*4+1]=gray; r[x*4+2]=gray; r[x*4+3]=255;
        }
    }
}
#endif

```

---

## BMP 파일 입출력(불러오기 및 저장하기)

> 학습 편의를 위해 **BI_RGB(무압축)** 8/24/32bpp와 **16bpp(BI_BITFIELDS 565)** 를 지원합니다.
> **팔레트(8bpp)** → 32bpp로 변환 시 `RGBQUAD` 참조, **Bottom-Up → Top-Down** 변환 수행.
> 저장은 **24bpp(권장)** 또는 **32bpp**로 대응합니다.

### 로더/세이버 유틸(로컬) — 구조체/stride 계산

```cpp
#ifdef _WIN32
#include <fstream>

#pragma pack(push,1)

struct BFH { uint16_t bfType; uint32_t bfSize; uint16_t r1; uint16_t r2; uint32_t bfOffBits; };
struct BIH {
    uint32_t biSize; int32_t biWidth; int32_t biHeight; uint16_t biPlanes; uint16_t biBitCount;
    uint32_t biCompression; uint32_t biSizeImage; int32_t biXPelsPerMeter; int32_t biYPelsPerMeter;
    uint32_t biClrUsed; uint32_t biClrImportant;
};
struct RGBQ { uint8_t b,g,r,a; };
#pragma pack(pop)

static inline uint32_t stride4_bits(int w, int bpp) { return ((uint32_t)w * bpp + 31) / 32 * 4; }

bool IppDib::loadBMP(const std::wstring& path, HDC refDC)
{
    std::ifstream f(path, std::ios::binary);
    if (!f) return false;

    BFH bfh{}; f.read((char*)&bfh, sizeof(bfh));
    if (!f || bfh.bfType != 0x4D42) return false;

    BIH bih{}; f.read((char*)&bih, sizeof(bih));
    if (!f || bih.biSize < sizeof(BIH) || bih.biPlanes != 1) return false;

    const int  srcW = bih.biWidth;
    const int  srcH = std::abs(bih.biHeight);
    const bool topDown = (bih.biHeight < 0);
    const int  bpp = bih.biBitCount;
    const uint32_t BI_RGB = 0, BI_RLE8 = 1, BI_RLE4 = 2, BI_BITFIELDS = 3;

    if (!(bpp==8 || bpp==24 || bpp==32 || bpp==16)) return false;
    if (!(bih.biCompression==BI_RGB || bih.biCompression==BI_BITFIELDS)) return false;

    // 팔레트
    uint32_t clrUsed = bih.biClrUsed;
    if (bpp<=8 && clrUsed==0) clrUsed = 1u << bpp;
    std::vector<RGBQ> palette;
    if (bpp<=8) {
        palette.resize(clrUsed);
        f.read((char*)palette.data(), clrUsed*sizeof(RGBQ));
        if (!f) return false;
    }

    // BITFIELDS(16/32bpp) 마스크
    uint32_t rMask=0, gMask=0, bMask=0, aMask=0;
    if (bih.biCompression == BI_BITFIELDS) {
        f.read((char*)&rMask,4); f.read((char*)&gMask,4); f.read((char*)&bMask,4);
        // DIB V4/V5라면 aMask가 있을 수 있으나 생략 가능(필요 시 조건부 read)
        if (!f) return false;
    }

    // 픽셀 위치로 이동
    f.seekg(bfh.bfOffBits, std::ios::beg);
    if (!f) return false;

    // 내부 DIBSECTION 준비
    if (!create(refDC, srcW, srcH, true)) return false;

    // 소스 stride
    const uint32_t sstride = stride4_bits(srcW, bpp);
    std::vector<uint8_t> row(sstride);

    auto toTopY = [&](int fileRow){ return topDown ? fileRow : (srcH-1-fileRow); };

    if (bpp == 8) {
        for (int fy=0; fy<srcH; ++fy) {
            f.read((char*)row.data(), sstride);
            if (!f) return false;
            int ty = fy; // 파일 행은 Bottom-Up, but 우리는 Top-Down 버퍼 → toTopY로 변환
            ty = toTopY(fy);
            uint8_t* d = (uint8_t*)m_bits + (size_t)ty*m_stride;
            for (int x=0;x<srcW;++x){
                uint8_t idx = row[x];
                if (idx >= palette.size()) idx = 0;
                const auto& q = palette[idx];
                d[x*4+0]=q.b; d[x*4+1]=q.g; d[x*4+2]=q.r; d[x*4+3]=255;
            }
        }
    }
    else if (bpp == 24) {
        for (int fy=0; fy<srcH; ++fy) {
            f.read((char*)row.data(), sstride);
            if (!f) return false;
            int ty = toTopY(fy);
            uint8_t* d = (uint8_t*)m_bits + (size_t)ty*m_stride;
            for (int x=0;x<srcW;++x){
                const uint8_t* s = &row[x*3];
                d[x*4+0]=s[0]; d[x*4+1]=s[1]; d[x*4+2]=s[2]; d[x*4+3]=255;
            }
        }
    }
    else if (bpp == 32) {
        for (int fy=0; fy<srcH; ++fy) {
            f.read((char*)row.data(), sstride);
            if (!f) return false;
            int ty = toTopY(fy);
            std::memcpy((uint8_t*)m_bits + (size_t)ty*m_stride, row.data(), (size_t)srcW*4);
        }
    }
    else if (bpp == 16) {
        // 마스크 없으면 565 가정
        uint32_t Rm = rMask ? rMask : 0xF800;
        uint32_t Gm = gMask ? gMask : 0x07E0;
        uint32_t Bm = bMask ? bMask : 0x001F;
        auto lsb = [](uint32_t m){ for (int i=0;i<32;++i) if (m&(1u<<i)) return i; return 0; };
        auto wdt = [](uint32_t m){ int w=0; while(m){ w+= (m&1u); m>>=1; } return w; };
        int Rs=lsb(Rm), Gs=lsb(Gm), Bs=lsb(Bm);
        int Rw=wdt(Rm), Gw=wdt(Gm), Bw=wdt(Bm);
        auto scale = [](uint32_t v, int w)->uint8_t { return (uint8_t)std::lround((double)v * 255.0 / (double)((1u<<w)-1)); };

        for (int fy=0; fy<srcH; ++fy) {
            f.read((char*)row.data(), sstride);
            if (!f) return false;
            int ty = toTopY(fy);
            uint8_t* d = (uint8_t*)m_bits + (size_t)ty*m_stride;
            const uint16_t* s = reinterpret_cast<const uint16_t*>(row.data());
            for (int x=0;x<srcW;++x){
                uint16_t v = s[x];
                uint8_t R = scale((v & Rm) >> Rs, Rw);
                uint8_t G = scale((v & Gm) >> Gs, Gw);
                uint8_t B = scale((v & Bm) >> Bs, Bw);
                d[x*4+0]=B; d[x*4+1]=G; d[x*4+2]=R; d[x*4+3]=255;
            }
        }
    }
    return true;
}

bool IppDib::saveBMP(const std::wstring& path, int fileBpp) const
{
    if (!*this) return false;
    if (!(fileBpp==24 || fileBpp==32)) fileBpp = 24;

    const uint32_t rowStride = stride4_bits(m_w, fileBpp);
    const uint32_t imgSize   = rowStride * m_h;

    BFH bfh{}; bfh.bfType=0x4D42;
    BIH bih{};
    bih.biSize=sizeof(BIH);
    bih.biWidth=m_w;
    bih.biHeight=m_h; // Bottom-Up 저장
    bih.biPlanes=1;
    bih.biBitCount=(uint16_t)fileBpp;
    bih.biCompression=0; // BI_RGB
    bih.biSizeImage=imgSize;

    const uint32_t offBits = sizeof(BFH) + sizeof(BIH);
    bfh.bfOffBits = offBits;
    bfh.bfSize    = offBits + imgSize;

    std::ofstream f(path, std::ios::binary);
    if (!f) return false;
    f.write((char*)&bfh, sizeof(bfh));
    f.write((char*)&bih, sizeof(bih));

    std::vector<uint8_t> row(rowStride, 0);
    for (int y=m_h-1; y>=0; --y) { // Bottom-Up
        const uint8_t* s = (const uint8_t*)m_bits + (size_t)y*m_stride;
        if (fileBpp==32) {
            std::memcpy(row.data(), s, (size_t)m_w*4);
        } else { // 24
            for (int x=0;x<m_w;++x) {
                const uint8_t* p = &s[x*4];
                uint8_t* d = &row[x*3];
                d[0]=p[0]; d[1]=p[1]; d[2]=p[2]; // BGRA → BGR
            }
        }
        f.write((char*)row.data(), rowStride);
        if (!f) return false;
    }
    return true;
}
#endif

```

> **TIP**
> - 저장 시 **24bpp**를 기본으로 두는 이유: 파일 크기↓, 알파 무의미한 경우가 일반적.
> - 32bpp 저장은 편하지만 **알파 채널을 소비자가 해석하지 않을 수도** 있음을 유의.

---

## 비트맵 화면 출력

> DIBSECTION은 **메모리 DC에 SelectObject**하여 **`BitBlt/StretchBlt`**으로 출력하거나, **`SetDIBitsToDevice/StretchDIBits`** 로 직접 메모리 포인터를 넘길 수 있습니다.
> 여기서는 **코드 단순성**과 **재사용성**을 위해 **메모리 DC → 대상 DC** 경로를 기본으로 합니다.

```cpp
#ifdef _WIN32

void IppDib::draw(HDC hdc, int x, int y) const
{
    if (!*this) return;
    BitBlt(hdc, x, y, m_w, m_h, m_memdc, 0, 0, SRCCOPY);
}

void IppDib::draw(HDC hdc, const RECT& dst, DWORD rop, int stretchMode) const
{
    if (!*this) return;
    int dstW = dst.right - dst.left;
    int dstH = dst.bottom - dst.top;
    int old = SetStretchBltMode(hdc, stretchMode);
    if (stretchMode == HALFTONE) {
        // HALFTONE은 브러시 기원 설정 필요
        POINT pt; SetBrushOrgEx(hdc, 0, 0, &pt);
    }
    StretchBlt(hdc, dst.left, dst.top, dstW, dstH, m_memdc, 0, 0, m_w, m_h, rop);
    SetStretchBltMode(hdc, old);
}

void IppDib::draw(HDC hdc, const RECT& dst, const RECT& src, DWORD rop, int stretchMode) const
{
    if (!*this) return;
    int dstW = dst.right - dst.left;
    int dstH = dst.bottom - dst.top;
    int srcW = src.right - src.left;
    int srcH = src.bottom - src.top;
    int old = SetStretchBltMode(hdc, stretchMode);
    if (stretchMode == HALFTONE) {
        POINT pt; SetBrushOrgEx(hdc, 0, 0, &pt);
    }
    StretchBlt(hdc, dst.left, dst.top, dstW, dstH, m_memdc, src.left, src.top, srcW, srcH, rop);
    SetStretchBltMode(hdc, old);
}
#endif

```

> **HALFTONE**은 Windows에서 가장 좋은 스케일링 품질을 제공합니다(선형 보간 유사).
> 고품질이 반드시 필요하면 다음 장에서 **사용자 보간**(Nearest/Bilinear/Box)을 직접 구현하세요.

---

## 클립보드 지원 (복사 및 붙여넣기)

### 개요

- **복사(Copy)**: **CF_DIBV5** 핸들을 만들어 `SetClipboardData(CF_DIBV5, hMem)` 등록
  - 헤더: `BITMAPV5HEADER` (Top-Down/알파/색공간/해상도 기술 가능)
  - 데이터: 헤더 뒤에 **픽셀 배열**(Top-Down이면 `biHeight<0`)
- **붙여넣기(Paste)**: **CF_DIBV5 → CF_DIB → CF_BITMAP** 우선순위로 시도
  - CF_DIB은 `BITMAPINFOHEADER + 팔레트 + 픽셀(Bottom-Up)`
  - CF_BITMAP은 DDB이므로 `GetDIBits`로 DIB 변환이 추가로 필요

### 구현

```cpp
#ifdef _WIN32

// 내부: DIBV5 메모리 블록 만들기 (Top-Down BGRA32)
static HGLOBAL MakeGlobalDIBV5_FromBGRA32(const void* ptr, int w, int h, int stride)
{
    const size_t headerSize = sizeof(BITMAPV5HEADER);
    const size_t imageSize  = (size_t)w * 4 * h; // Top-Down
    const size_t totalSize  = headerSize + imageSize;

    HGLOBAL hMem = GlobalAlloc(GHND | GMEM_SHARE, totalSize);
    if (!hMem) return nullptr;
    auto* p = (uint8_t*)GlobalLock(hMem);
    if (!p) { GlobalFree(hMem); return nullptr; }

    BITMAPV5HEADER* v5 = reinterpret_cast<BITMAPV5HEADER*>(p);
    std::memset(v5, 0, sizeof(*v5));
    v5->bV5Size          = sizeof(BITMAPV5HEADER);
    v5->bV5Width         = w;
    v5->bV5Height        = -h;                 // Top-Down
    v5->bV5Planes        = 1;
    v5->bV5BitCount      = 32;
    v5->bV5Compression   = BI_BITFIELDS;
    v5->bV5RedMask       = 0x00FF0000;
    v5->bV5GreenMask     = 0x0000FF00;
    v5->bV5BlueMask      = 0x000000FF;
    v5->bV5AlphaMask     = 0xFF000000;
    v5->bV5CSType        = LCS_sRGB;
    v5->bV5Intent        = LCS_GM_GRAPHICS;
    v5->bV5SizeImage     = (DWORD)imageSize;
    v5->bV5XPelsPerMeter = 3780;  // ~96 DPI
    v5->bV5YPelsPerMeter = 3780;

    uint8_t* dstBits = p + sizeof(BITMAPV5HEADER);
    // 우리 버퍼는 이미 Top-Down → 행 순서 그대로 복사
    for (int y=0;y<h;++y)
        std::memcpy(dstBits + (size_t)y*w*4, (const uint8_t*)ptr + (size_t)y*stride, (size_t)w*4);

    GlobalUnlock(hMem);
    return hMem;
}

bool IppDib::copyToClipboard(HWND owner) const
{
    if (!*this) return false;
    if (!OpenClipboard(owner)) return false;
    EmptyClipboard();

    // CF_DIBV5 우선
    HGLOBAL hDIBV5 = MakeGlobalDIBV5_FromBGRA32(m_bits, m_w, m_h, m_stride);
    if (hDIBV5) {
        if (!SetClipboardData(CF_DIBV5, hDIBV5)) {
            GlobalFree(hDIBV5);
        }
    }

    // 호환을 위해 CF_DIB도 등록 (Bottom-Up으로 변환 저장)
    // BITMAPINFOHEADER + 픽셀(24bpp 저장)
    const int fileBpp = 24;
    const size_t rowStride = ((size_t)m_w * fileBpp + 31)/32*4;
    const size_t imgSize   = rowStride * m_h;
    const size_t hdrSize   = sizeof(BITMAPINFOHEADER);
    HGLOBAL hDIB = GlobalAlloc(GHND | GMEM_SHARE, hdrSize + imgSize);
    if (hDIB) {
        uint8_t* p = (uint8_t*)GlobalLock(hDIB);
        if (p) {
            BITMAPINFOHEADER* bi = (BITMAPINFOHEADER*)p;
            std::memset(bi,0,sizeof(*bi));
            bi->biSize=sizeof(BITMAPINFOHEADER);
            bi->biWidth=m_w;
            bi->biHeight=m_h; // Bottom-Up
            bi->biPlanes=1;
            bi->biBitCount=fileBpp;
            bi->biCompression=BI_RGB;
            bi->biSizeImage=(DWORD)imgSize;
            uint8_t* dst = p + sizeof(BITMAPINFOHEADER);
            std::vector<uint8_t> row(rowStride,0);
            for (int y=m_h-1; y>=0; --y) {
                const uint8_t* s = (const uint8_t*)m_bits + (size_t)y*m_stride;
                for (int x=0;x<m_w;++x){
                    const uint8_t* q=&s[x*4];
                    uint8_t* d=&row[x*3];
                    d[0]=q[0]; d[1]=q[1]; d[2]=q[2];
                }
                std::memcpy(dst, row.data(), rowStride); dst += rowStride;
            }
            GlobalUnlock(hDIB);
            if (!SetClipboardData(CF_DIB, hDIB)) GlobalFree(hDIB);
        } else GlobalFree(hDIB);
    }

    // 추가로 CF_BITMAP도 줄 수 있음(소비 앱 호환성↑).
    // 단, SetClipboardData에 넘긴 핸들의 소유권은 OS로 이전됨.
    HBITMAP hbmCopy = (HBITMAP)CopyImage(m_hbm, IMAGE_BITMAP, 0,0, 0);
    if (hbmCopy) {
        if (!SetClipboardData(CF_BITMAP, hbmCopy)) DeleteObject(hbmCopy);
    }

    CloseClipboard();
    return true;
}

bool IppDib::pasteFromClipboard(HWND owner, HDC refDC)
{
    if (!OpenClipboard(owner)) return false;

    bool ok = false;

    // 1) CF_DIBV5
    if (IsClipboardFormatAvailable(CF_DIBV5)) {
        HGLOBAL h = GetClipboardData(CF_DIBV5);
        if (h) {
            const BITMAPV5HEADER* v5 = (const BITMAPV5HEADER*)GlobalLock(h);
            if (v5 && v5->bV5Size >= sizeof(BITMAPV5HEADER) && v5->bV5BitCount==32) {
                int w = v5->bV5Width;
                int hgt= v5->bV5Height;
                bool topDown = (hgt<0);
                int hpos = std::abs(hgt);
                const uint8_t* src = (const uint8_t*)(v5+1);
                if (create(refDC, w, hpos, true)) {
                    if (topDown) {
                        for (int y=0;y<hpos;++y)
                            std::memcpy((uint8_t*)m_bits + (size_t)y*m_stride, src + (size_t)y*w*4, (size_t)w*4);
                    } else {
                        for (int y=0;y<hpos;++y)
                            std::memcpy((uint8_t*)m_bits + (size_t)(hpos-1-y)*m_stride, src + (size_t)y*w*4, (size_t)w*4);
                    }
                    ok = true;
                }
            }
            if (v5) GlobalUnlock(h);
        }
    }

    // 2) CF_DIB (8/24/32)
    if (!ok && IsClipboardFormatAvailable(CF_DIB)) {
        HGLOBAL h = GetClipboardData(CF_DIB);
        if (h) {
            const BITMAPINFOHEADER* bi = (const BITMAPINFOHEADER*)GlobalLock(h);
            if (bi && bi->biSize >= sizeof(BITMAPINFOHEADER) && bi->biPlanes==1) {
                int w = bi->biWidth;
                int hpos = std::abs(bi->biHeight);
                bool topDown = (bi->biHeight < 0);
                int bpp = bi->biBitCount;
                const uint8_t* src = (const uint8_t*)(bi+1);
                if (bpp==8 || bpp==24 || bpp==32) {
                    const uint8_t* px = nullptr;
                    std::vector<RGBQ> pal;
                    if (bpp == 8) {
                        uint32_t clrUsed = bi->biClrUsed ? bi->biClrUsed : 256u;
                        pal.resize(clrUsed);
                        const RGBQ* p = (const RGBQ*)(bi+1);
                        for (uint32_t i=0;i<clrUsed;++i) pal[i]=p[i];
                        px = (const uint8_t*)(p + clrUsed);
                    } else px = src;

                    if (create(refDC, w, hpos, true)) {
                        uint32_t sstride = stride4_bits(w, bpp);
                        std::vector<uint8_t> row(sstride);
                        for (int fy=0; fy<hpos; ++fy) {
                            // CF_DIB은 보통 Bottom-Up
                            int ty = topDown? fy : (hpos-1-fy);
                            std::memcpy(row.data(), px + (size_t)fy*sstride, sstride);
                            uint8_t* d = (uint8_t*)m_bits + (size_t)ty*m_stride;
                            if (bpp==8) {
                                for (int x=0;x<w;++x){
                                    uint8_t idx=row[x]; if (idx>=pal.size()) idx=0;
                                    const auto& q=pal[idx];
                                    d[x*4+0]=q.b; d[x*4+1]=q.g; d[x*4+2]=q.r; d[x*4+3]=255;
                                }
                            } else if (bpp==24) {
                                for (int x=0;x<w;++x){
                                    const uint8_t* s=&row[x*3];
                                    d[x*4+0]=s[0]; d[x*4+1]=s[1]; d[x*4+2]=s[2]; d[x*4+3]=255;
                                }
                            } else { // 32
                                std::memcpy(d, row.data(), (size_t)w*4);
                            }
                        }
                        ok = true;
                    }
                }
            }
            if (bi) GlobalUnlock(h);
        }
    }

    // 3) CF_BITMAP — DDB → DIB 변환
    if (!ok && IsClipboardFormatAvailable(CF_BITMAP)) {
        HBITMAP hb = (HBITMAP)GetClipboardData(CF_BITMAP);
        if (hb) {
            BITMAP bm{}; GetObject(hb, sizeof(bm), &bm);
            if (bm.bmBitsPixel==32 || bm.bmBitsPixel==24 || bm.bmBitsPixel==8){
                HDC screen = GetDC(nullptr);
                BITMAPINFO bmi{}; bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
                bmi.bmiHeader.biWidth=bm.bmWidth;
                bmi.bmiHeader.biHeight=-bm.bmHeight; // Top-Down 받기
                bmi.bmiHeader.biPlanes=1;
                bmi.bmiHeader.biBitCount=32;
                bmi.bmiHeader.biCompression=BI_RGB;
                std::vector<uint8_t> temp((size_t)bm.bmWidth*bm.bmHeight*4);
                if (GetDIBits(screen, hb, 0, bm.bmHeight, temp.data(), &bmi, DIB_RGB_COLORS)) {
                    if (create(screen, bm.bmWidth, bm.bmHeight, true)) {
                        for (int y=0;y<m_h;++y)
                            std::memcpy((uint8_t*)m_bits+(size_t)y*m_stride, temp.data()+(size_t)y*m_w*4, (size_t)m_w*4);
                        ok=true;
                    }
                }
                ReleaseDC(nullptr, screen);
            }
        }
    }

    CloseClipboard();
    return ok;
}
#endif

```

> **주의**
> - 클립보드에 올린 핸들(`SetClipboardData`)은 **OS 소유**가 되므로 **해제하면 안 됩니다.**
> - `CF_DIBV5`를 최우선으로 시도하면 **Top-Down/알파/DPI** 정보 전달이 용이합니다.

---

## 기타 유용한 기능

### 단순 픽셀 연산과 알파 전처리

```cpp
#ifdef _WIN32

void IppDib::invert()
{
    if (!*this) return;
    for (int y=0;y<m_h;++y){
        uint8_t* r = (uint8_t*)m_bits + (size_t)y*m_stride;
        for (int x=0;x<m_w;++x){
            uint8_t* p=&r[x*4];
            p[0]=255-p[0]; p[1]=255-p[1]; p[2]=255-p[2];
        }
    }
}

void IppDib::premultiplyAlpha()
{
    if (!*this) return;
    for (int y=0;y<m_h;++y){
        uint8_t* r=(uint8_t*)m_bits + (size_t)y*m_stride;
        for (int x=0;x<m_w;++x){
            uint8_t* p=&r[x*4];
            uint8_t a=p[3];
            p[0] = (uint8_t)((p[0]*a + 127)/255);
            p[1] = (uint8_t)((p[1]*a + 127)/255);
            p[2] = (uint8_t)((p[2]*a + 127)/255);
        }
    }
}

std::wstring IppDib::infoString() const
{
    if (!*this) return L"(empty)";
    wchar_t buf[256]{};
    swprintf(buf, 256, L"%dx%d, stride=%d, 32bpp BGRA Top-Down", m_w, m_h, m_stride);
    return buf;
}
#endif

```

### 연산자/도우미 총정리

- `operator bool()` — 유효성 체크
- `operator()(x,y)` — BGRA 픽셀 참조
- `width/height/stride/handle/memdc/bits` — 직접 접근자
- `clear(invert/premultiplyAlpha)` — 디버그/테스트 유틸
- `infoString()` — 상태 표시/로그 편의

---

## 사용 예시 — Win32 뷰어 루틴 통합

```cpp
// 전역
static IppDib g_dib;

static void EnsureDemo(HDC ref)
{
    if (g_dib) return;
    g_dib.create(ref, 640, 480, true);
    // 그라데이션
    for (int y=0;y<g_dib.height();++y){
        for (int x=0;x<g_dib.width();++x){
            auto& px = g_dib(x,y);
            uint8_t g = (uint8_t)((x + y) & 0xFF);
            px.b=g; px.g=g; px.r=g; px.a=255;
        }
    }
}

static void OnPaint(HWND h)
{
    PAINTSTRUCT ps; HDC hdc = BeginPaint(h,&ps);
    EnsureDemo(hdc);
    RECT rc; GetClientRect(h,&rc);

    // 비율 보존 레터박스
    double sx=(double)(rc.right-rc.left)/g_dib.width();
    double sy=(double)(rc.bottom-rc.top)/g_dib.height();
    double s = std::min(sx, sy);
    int dw=(int)(g_dib.width()*s), dh=(int)(g_dib.height()*s);
    RECT dst{ rc.left+(rc.right-rc.left-dw)/2, rc.top+(rc.bottom-rc.top-dh)/2,
              0,0 };
    dst.right = dst.left+dw; dst.bottom = dst.top+dh;

    g_dib.draw(hdc, dst, SRCCOPY, HALFTONE);
    EndPaint(h,&ps);
}

static void OnKeyDown(HWND h, WPARAM w)
{
    if ((GetKeyState(VK_CONTROL)&0x8000) && w=='C') { g_dib.copyToClipboard(h); return; }
    if ((GetKeyState(VK_CONTROL)&0x8000) && w=='V') { if (g_dib.pasteFromClipboard(h)) InvalidateRect(h,nullptr,FALSE); return; }
    if ((GetKeyState(VK_CONTROL)&0x8000) && w=='O') {
        wchar_t buf[MAX_PATH]=L""; OPENFILENAMEW ofn{ sizeof(ofn) };
        ofn.hwndOwner=h; ofn.lpstrFilter=L"BMP (*.bmp)\0*.bmp\0";
        ofn.lpstrFile=buf; ofn.nMaxFile=MAX_PATH; ofn.Flags=OFN_FILEMUSTEXIST; ofn.lpstrTitle=L"Open BMP";
        if (GetOpenFileNameW(&ofn)) { if (g_dib.loadBMP(buf)) InvalidateRect(h,nullptr,FALSE); }
        return;
    }
    if ((GetKeyState(VK_CONTROL)&0x8000) && w=='S') {
        wchar_t buf[MAX_PATH]=L""; OPENFILENAMEW ofn{ sizeof(ofn) };
        ofn.hwndOwner=h; ofn.lpstrFilter=L"BMP 24bpp (*.bmp)\0*.bmp\0";
        ofn.lpstrFile=buf; ofn.nMaxFile=MAX_PATH; ofn.Flags=OFN_OVERWRITEPROMPT; ofn.lpstrTitle=L"Save BMP";
        if (GetSaveFileNameW(&ofn)) g_dib.saveBMP(buf, 24);
        return;
    }
    if (w == VK_SPACE) { g_dib.invert(); InvalidateRect(h,nullptr,FALSE); }
}
```

---

## 안정성/호환성 체크리스트

- [ ] `CreateDIBSection`은 실패 시 **NULL** 리턴 → 즉시 자원 정리
- [ ] **Top-Down** 내부 버퍼 ↔ **Bottom-Up** BMP 저장 변환 확인
- [ ] 8bpp 팔레트 인덱스 범위 체크(초과 시 0)
- [ ] 16bpp `BI_BITFIELDS` 마스크 기반 스케일링(5/6/5/5-5-5 혼재 방지)
- [ ] `SetStretchBltMode(HALFTONE)` 시 **`SetBrushOrgEx` 호출** 필수
- [ ] 클립보드 핸들 **소유권 이전** 규칙 준수(넘긴 뒤 해제 금지)
- [ ] `CF_DIB`는 보통 **Bottom-Up**임을 전제로 처리
- [ ] 큰 이미지 처리 시 `size_t`/곱셈 오버플로 주의

---

## 성능 팁

1. **메모리 DC 캐시**: `IppDib` 내부에서 DC 지속 재사용(이미 구현)
2. **HALFTONE** 스케일링: 품질↑, 속도↓ → UI 프레임레이트가 중요하면 `COLORONCOLOR` 고려
3. **타일링**: 초대형 이미지는 타일 단위 `StretchBlt`로 분할 출력(클리핑 오버헤드↓)
4. **프리멀티플라이**: 알파 블렌딩이 잦다면 **프리멀티플라이** 후 GDI+ 또는 `AlphaBlend` 사용

---

## 요약

- **IppDib**는 **32bpp Top-Down DIBSECTION**을 캡슐화하여 **생성/출력/교환(파일/클립보드)** 을 일원화합니다.
- **BMP I/O**는 8/24/32bpp(및 16bpp 일부)를 안전하게 다루고, 내부로는 **BGRA32**에 표준화합니다.
- **화면 출력**은 `BitBlt/StretchBlt + HALFTONE` 경로로 단순/안정하게,
- **클립보드**는 **CF_DIBV5 → CF_DIB → CF_BITMAP** 순으로 **광범위한 호환성**을 확보합니다.
