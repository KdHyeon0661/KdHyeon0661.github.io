---
layout: post
title: MFC - 네트워크
date: 2025-09-01 23:25:23 +0900
category: MFC
---
# 네트워크: CAsyncSocket/WinSock 개요, 비동기 패턴, 타임아웃/재시도 설계 (MFC/Win32 C++ 실전 가이드 + 예제 다수)

이 글은 **MFC `CAsyncSocket`** 과 **원시 WinSock2**(Blocking/Non-blocking, `select`, `WSAAsyncSelect`, `WSAEventSelect`, Overlapped/IOCP) 기반으로  
**안정적인 TCP/UDP 클라이언트·서버**를 만드는 방법을 **예제 중심**으로 정리합니다.  
또한 **타임아웃/재시도/백오프/취소/헬스체크**를 체계적으로 설계하는 **실무 패턴**을 제공합니다.

> 환경: Windows 10/11, x64, Unicode, MFC/Win32 C++  
> 사용 API: WinSock2 (`WSAStartup`~), `CAsyncSocket`, `select`, `WSAAsyncSelect`, `WSAEventSelect`, Overlapped/IOCP  
> 범위: TCP 중심(UDP 보충), DNS/IPv6, 프레이밍, 부분 송수신 처리, KeepAlive/Nagle, 재연결/백오프, 로깅/계측

---

## 0) 큰 그림: 윈도우 네트워킹 선택지

| 패턴 | 개요 | 장점 | 단점 | 권장 상황 |
|---|---|---|---|---|
| **CAsyncSocket (MFC)** | 윈도우 메시지 기반 비동기 알림(`OnReceive/OnConnect` 등) | 구현 빠름, MFC 앱과 자연스러움 | UI 스레드 의존/메시지 큐 혼잡 시 지연 | MFC SDI/MDI/대화상자 앱의 **가벼운 클라이언트** |
| **Blocking + 전용 worker thread** | 스레드 안에서 blocking `connect/recv/send` + `select`로 타임아웃 | 직관적, 디버깅 쉬움 | 스레드 비용, 많은 접속 수에 불리 | **소수 연결**, 로직 복잡도 낮음 |
| **Non-blocking + select/WSAPoll** | 소켓을 논블로킹, `select`/`WSAPoll`로 readiness 감지 | 단일 스레드 다중 I/O | 코드 다소 복잡 | **수십~수백 연결** |
| **WSAEventSelect** | 이벤트 오브젝트 + `WSAWaitForMultipleEvents` | 메시지/윈도 핸들 불필요 | 이벤트 수 제한/관리 복잡 | **백그라운드 서비스/라이브러리** |
| **Overlapped + IOCP** | 고성능 커널 큐 기반 완료 통지 | **가장 빠름**, 수천~수만 연결 | 러닝커브 높음 | **고동시성 서버/프록시** |

**요약**  
- MFC 클라이언트: **CAsyncSocket** 또는 **Blocking+스레드**가 가장 생산적.  
- 고성능 서버/게이트웨이: **IOCP** 권장.  
- 과도한 premature optimization은 금물—요건(동시 접속, 지연, 안정성)으로 선택하세요.

---

## 1) WinSock2 필수 기초

### 1-1. 초기화/정리
```cpp
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "Ws2_32.lib")

struct WinSockInit {
    WinSockInit()  { WSADATA wsa{}; if (WSAStartup(MAKEWORD(2,2), &wsa)!=0) throw std::runtime_error("WSAStartup"); }
    ~WinSockInit() { WSACleanup(); }
} g_wsa;
```

### 1-2. DNS/IPv4/IPv6 주소 얻기
```cpp
addrinfoW hints{}; hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM;
addrinfoW* res=nullptr;
if (GetAddrInfoW(L"example.com", L"80", &hints, &res)!=0) {/*에러*/}
for (auto* p=res; p; p=p->ai_next) {
    // p->ai_family: AF_INET/AF_INET6
}
FreeAddrInfoW(res);
```

### 1-3. 소켓 옵션 주요 항목
```cpp
// Nagle 비활성화 (지연 없이 작은 패킷 송신)
BOOL yes=TRUE; setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char*)&yes, sizeof(yes));

// KeepAlive (죽은 연결 탐지: 시스템 레벨 전역값, SIO_KEEPALIVE_VALS로 튜닝 가능)
setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (char*)&yes, sizeof(yes));

// 송수신 버퍼 (자동 조정/OS 기본 권장, 필요시만 조절)
int sz=1<<20; setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char*)&sz, sizeof(sz));
```

---

## 2) CAsyncSocket: MFC 비동기 클라이언트/서버

### 2-1. 핵심 개념
- 내부적으로 **`WSAAsyncSelect`** 사용 → **윈도우 메시지**(`WM_SOCKET`)로 이벤트를 전달.
- 오버라이드 지점:  
  `OnReceive`, `OnSend`, `OnConnect`, `OnClose`, (서버: `OnAccept`)  
- **주의**: 콜백은 **UI 스레드에서** 발생 → 무거운 연산 금지, 필요한 경우 **worker로 Post**.

### 2-2. 최소 HTTP GET 클라이언트 예제 (CAsyncSocket)
```cpp
class CHttpSocket : public CAsyncSocket {
    CStringW m_host; CStringA m_req; CStringA m_buf;
    bool m_connected=false;
public:
    bool Start(LPCWSTR host, UINT port) {
        m_host=host;
        if (!Create()) return false;
        if (!Connect(host, port)) {
            if (GetLastError()!=WSAEWOULDBLOCK) return false; // 비동기 연결 진행 중
        }
        return true;
    }
    void SendRequest(LPCSTR path="/") {
        CStringA s; s.Format("GET %s HTTP/1.1\r\nHost: %S\r\nConnection: close\r\n\r\n", path, m_host.GetString());
        m_req = s;
        TrySend();
    }

protected:
    void OnConnect(int nErrorCode) override {
        if (nErrorCode==0) { m_connected=true; TrySend(); }
        else { AfxMessageBox(L"Connect 실패"); }
        CAsyncSocket::OnConnect(nErrorCode);
    }
    void OnSend(int nErrorCode) override {
        if (nErrorCode==0) TrySend();
        CAsyncSocket::OnSend(nErrorCode);
    }
    void OnReceive(int nErrorCode) override {
        if (nErrorCode!=0) { Close(); return; }
        char buf[4096];
        for (;;) {
            int n = Receive(buf, sizeof(buf));
            if (n==SOCKET_ERROR) {
                int e=GetLastError();
                if (e==WSAEWOULDBLOCK) break;
                Close(); break;
            }
            if (n==0) { // FIN
                // m_buf = 전체 응답
                // TODO: UI에 표시
                break;
            }
            m_buf.append(buf, n);
        }
        CAsyncSocket::OnReceive(nErrorCode);
    }
    void OnClose(int nErrorCode) override {
        Close(); // 자원 정리
        CAsyncSocket::OnClose(nErrorCode);
    }
private:
    void TrySend() {
        if (!m_connected || m_req.IsEmpty()) return;
        while (!m_req.IsEmpty()) {
            int n = Send(m_req.GetString(), (int)m_req.GetLength());
            if (n==SOCKET_ERROR) {
                if (GetLastError()==WSAEWOULDBLOCK) return;
                Close(); return;
            }
            m_req.Delete(0, n);
        }
        // 요청 다 보냈으면 수신대기
    }
};
```

**포인트**  
- `Send/Receive`는 **부분 송수신**이 가능 → **남은 버퍼 관리**가 핵심.  
- `WSAEWOULDBLOCK`이면 **다음 `OnSend/OnReceive`** 때 다시 시도.  
- **타임아웃**은 CAsyncSocket 자체에는 없음 → **타이머**(UI 타이머/`SetTimer`)나 백그라운드 감시로 구현.

### 2-3. 타임아웃/재시도(메시지 기반)
```cpp
// 1) 연결 타임아웃: Connect 후 타이머 시작 → OnConnect가 안 오면 Cancel
// 2) 수신 무응답 타임아웃: 마지막 수신 시각 기록 → 주기적 타이머에서 경과 체크 → Close & Retry

// 예시: 다이얼로그에서 5초 연결 타임아웃
SetTimer(1, 5000, nullptr); // ID=1
void CMainDlg::OnTimer(UINT_PTR id) {
    if (id==1 && !m_sock.IsConnected()) {
        m_sock.Close();
        // 재시도 if 정책 허용
    }
}
```

---

## 3) Blocking + worker thread 패턴(간단/견고)

### 3-1. 장단점
- 장점: 동기 코드로 **읽기 쉬움**, 디버깅 용이.  
- 단점: 연결당 스레드 1개면 비용↑. (소수 연결에는 문제 없음)

### 3-2. 타임아웃 `select`/`poll` 로 구현
```cpp
// 간단 HTTP GET (blocking + select 타임아웃)
bool HttpGet(const std::wstring& host, const std::wstring& path, std::string& out, DWORD msTimeout) {
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    // DNS
    addrinfoW hints{}; hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM;
    addrinfoW* res=nullptr; if (GetAddrInfoW(host.c_str(), L"80", &hints, &res)!=0) return false;

    // 논블로킹 connect + select로 연결 타임아웃
    u_long nb=1; ioctlsocket(s, FIONBIO, &nb);

    bool connected=false;
    for (auto* p=res; p && !connected; p=p->ai_next) {
        if (connect(s, p->ai_addr, (int)p->ai_addrlen)==SOCKET_ERROR) {
            if (WSAGetLastError()!=WSAEWOULDBLOCK) continue;
        }
        fd_set wfds; FD_ZERO(&wfds); FD_SET(s, &wfds);
        timeval tv{ (long)(msTimeout/1000), (long)((msTimeout%1000)*1000) };
        int rc = select(0, nullptr, &wfds, nullptr, &tv);
        if (rc>0 && FD_ISSET(s, &wfds)) {
            int err=0; int len=sizeof(err);
            getsockopt(s, SOL_SOCKET, SO_ERROR, (char*)&err, &len);
            connected=(err==0);
        }
    }
    FreeAddrInfoW(res);
    if (!connected) { closesocket(s); return false; }

    // 블로킹 모드로 되돌림(선택)
    nb=0; ioctlsocket(s, FIONBIO, &nb);

    std::string req = "GET " + std::string(CW2A(path.c_str(), CP_UTF8)) + " HTTP/1.1\r\nHost: "
                    + std::string(CW2A(host.c_str(), CP_UTF8)) + "\r\nConnection: close\r\n\r\n";
    send(s, req.data(), (int)req.size(), 0);

    // 수신 타임아웃
    DWORD start=GetTickCount();
    char buf[4096];
    for (;;) {
        // select로 가용성 검사
        fd_set rfds; FD_ZERO(&rfds); FD_SET(s, &rfds);
        timeval tv{0, 200*1000}; // 200ms tick
        int rc = select(0, &rfds, nullptr, nullptr, &tv);
        if (rc>0 && FD_ISSET(s, &rfds)) {
            int n = recv(s, buf, sizeof(buf), 0);
            if (n==0) break;
            if (n<0) { closesocket(s); return false; }
            out.append(buf, n);
            start=GetTickCount(); // 활동이 있으면 타임아웃 리셋(활동 기준)
        } else {
            if (GetTickCount()-start > msTimeout) { closesocket(s); return false; }
        }
    }
    closesocket(s);
    return true;
}
```

**포인트**  
- 연결과 수신 모두 **활동 기반 타임아웃**으로 처리(지속 스트림에서 유용).  
- `select` 타임슬라이스를 짧게 두고 loop → **취소 플래그** 체크로 그레이스풀 종료.

---

## 4) Non-blocking + `select`/`WSAPoll` (단일 스레드 다중 연결)

- 다수 소켓을 `FD_SET` 또는 `WSAPOLLFD` 목록으로 관리.  
- 각 소켓에 **송신 큐/수신 버퍼**를 붙이고 **부분 송수신** 처리.  
- **프레이밍(메시지 경계)** 은 반드시 설계: **길이 프리픽스(Varint/32bit)** 또는 **구분자(\r\n)**.

```cpp
// 길이-프리픽스 수신 파서 예시
struct Conn {
    SOCKET s{};
    std::vector<char> in;   // 누적 수신 버퍼
    std::deque<std::string> outq; // 송신 큐
    uint32_t expectLen=0; bool readingLen=true;
};

bool ParseMessages(Conn& c, std::vector<std::string>& messages) {
    size_t pos=0;
    while (true) {
        if (c.readingLen) {
            if (c.in.size()-pos < 4) break;
            memcpy(&c.expectLen, &c.in[pos], 4);
            c.expectLen = _byteswap_ulong(c.expectLen); // network->host
            pos+=4; c.readingLen=false;
        } else {
            if (c.in.size()-pos < c.expectLen) break;
            messages.emplace_back(&c.in[pos], &c.in[pos+c.expectLen]);
            pos+=c.expectLen; c.readingLen=true; c.expectLen=0;
        }
    }
    if (pos>0) c.in.erase(c.in.begin(), c.in.begin()+pos);
    return true;
}
```

---

## 5) `WSAEventSelect` 패턴(이벤트 기반)

- 각 소켓에 `WSACreateEvent()`를 매핑 → `WSAEventSelect(s, hEvent, FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT)`  
- 다수 이벤트를 `WSAWaitForMultipleEvents`로 대기(최대 64개/그룹 관리 필요).  
- **윈도우 핸들×** → **서비스/라이브러리**에서 유리.

```cpp
WSAEVENT ev = WSACreateEvent();
WSAEventSelect(s, ev, FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT);

for(;;){
    DWORD i = WSAWaitForMultipleEvents((DWORD)evs.size(), evs.data(), FALSE, 500, FALSE);
    if (i==WSA_WAIT_TIMEOUT) { /* 타임아웃 처리 */ continue; }
    int idx = i - WSA_WAIT_EVENT_0;
    WSANETWORKEVENTS ne{};
    WSAEnumNetworkEvents(sock[idx], evs[idx], &ne);
    if (ne.lNetworkEvents & FD_READ)  { /* recv 루프 */ }
    if (ne.lNetworkEvents & FD_WRITE) { /* send 루프 */ }
    if (ne.lNetworkEvents & FD_CONNECT) { /* connect 완료/실패 */ }
    if (ne.lNetworkEvents & FD_CLOSE) { /* 정리 */ }
}
```

---

## 6) Overlapped/IOCP (개요 + 최소 스니펫)

> **고동시성 서버** 대상. 클라이언트 앱은 생략 가능.  

- 소켓을 `CreateIoCompletionPort`에 등록 → `WSARecv/WSASend`(Overlapped) → 완료 시 `GetQueuedCompletionStatus`  
- **완료 스레드 풀**에서 콜백 처리 → 추가 I/O Post → 파이프라인.

```cpp
// (개념도 수준) IOCP 루프
HANDLE iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
// accept한 소켓/클라 소켓을 iocp에 등록
CreateIoCompletionPort((HANDLE)s, iocp, (ULONG_PTR)connCtx, 0);

// 워커 스레드
for(;;){
    DWORD bytes; ULONG_PTR key; OVERLAPPED* ov;
    BOOL ok = GetQueuedCompletionStatus(iocp, &bytes, &key, &ov, INFINITE);
    auto* ctx = (ConnCtx*)key;
    if (!ok) { /* 에러/종료 */ }
    if (ov == &ctx->readOv) { /* bytes 처리 → 다음 WSARecv */ }
    else if (ov == &ctx->writeOv) { /* 다음 WSASend */ }
}
```

---

## 7) 타임아웃/재시도/백오프/회복 설계

### 7-1. 타임아웃 유형
- **연결 타임아웃**: DNS/Connect 단계 제한(예: 3~5초).  
- **활동 타임아웃**(idle/read): **마지막 수신/송신 이후** 최대 무응답 시간(예: 30초).  
- **요청 타임아웃**: RPC/HTTP 단위 별(예: 5초).  
- **전역/취소**: 사용자 취소/앱 종료 시 즉시 중단.

### 7-2. 재시도 규칙
- **지수 백오프 + Jitter** (예: `base=250ms, max=30s`, `rand(0.5~1.0)` 곱)  
- **Idempotency** 고려: 같은 요청을 다시 보내도 안전한지? (GET/PUT vs POST)  
- **Retry Budget**: 최대 횟수/최대 총 시간 제한  
- **구분**:  
  - 재시도 가치 있음: `ETIMEDOUT`, 연결 끊김, 일시적 오류(5xx).  
  - 재시도 금지: 인증 실패, 4xx, 데이터 형식 오류.

```cpp
// 지수 백오프 with jitter
DWORD NextBackoff(int attempt, DWORD baseMs=200, DWORD maxMs=30'000) {
    double exp = std::min<double>(maxMs, baseMs * std::pow(2.0, attempt));
    double jitter = 0.5 + (rand()/(double)RAND_MAX)*0.5; // 0.5~1.0
    return (DWORD)(exp * jitter);
}
```

### 7-3. 회복/상태 머신
- 상태: **Disconnected → Resolving → Connecting → Connected → Backoff**  
- 이벤트: 성공/실패/타임아웃/취소  
- **Backoff** 상태에서 타이머 경과 시 → 다시 Resolving/Connecting

### 7-4. 헬스 체크/KeepAlive
- **TCP KeepAlive**: 커널 레벨로 장시간 유휴 연결 감지(분 단위).  
- **애플리케이션 Ping**: 수 초~수십 초 주기, 서버 에코.  
- 누락 시 **활동 타임아웃**으로 종료 후 재연결.

---

## 8) 프레이밍/프로토콜 설계(Sticky Packet 대책)

- TCP는 **스트림** → 메시지 경계 없음 → **프레이밍 필요**  
- **길이 프리픽스**(고정 4바이트 big-endian) 또는 **구분자(\r\n)**  
- 압축/암호화/서명은 **프레임 레벨**에서 적용  
- **부분 송수신 처리**(중요!):
  - `send`: 남은 데이터 큐 유지 → `WSAEWOULDBLOCK`이면 `OnSend`에서 재시도  
  - `recv`: 누적 버퍼에 append → 프레이밍 파서로 메시지 추출

---

## 9) 성능/옵션: Nagle, Corking, Buffer, Zero-copy

- **Nagle(TCP_NODELAY)**: 지연 없이 작은 패킷 전송(응답 지연 ↓, 패킷 수 ↑) — **요청/응답 상호작용**에 유리.  
- **Corking(Windows엔 직간접)**: 데이터를 한 덩어리로 모아 보낼 때, 애플리케이션 레벨에서 **버퍼링 후 한 번에 send**.  
- **Send/Recv Buffer**: OS가 자동 튜닝함. 큰 스트림(영상)은 늘릴 가치 있음.  
- **Zero-copy**: WinSock Registered I/O(고급) 등 — 대부분 앱은 과잉 최적화.

---

## 10) UDP 개요(짧게)

- **비연결/신뢰 없음/순서 보장 없음/MTU 주의**  
- 타임아웃/재전송/순서/중복 제거를 **앱 레벨**에서 구현해야 함.  
- DNS/VoIP/게임 상태 전파 등에 적합.  
- IPv6/IPv4 듀얼스택에서 `getaddrinfo`, `AI_V4MAPPED` 옵션 관리.

```cpp
SOCKET s = socket(AF_INET6, SOCK_DGRAM, 0);
// 바인딩, sendto/recvfrom 루프, select로 수신 타임아웃
```

---

## 11) 안전 종료/취소/에러 처리

- **취소 플래그**: worker 루프에서 주기적으로 확인.  
- `shutdown(s, SD_BOTH)` → `closesocket(s)` 순서 (송수신 종료 통지).  
- 예외/에러 시 **로깅**(에러코드/소켓 상태/peer 주소) + **재시도 정책** 판단.  
- CAsyncSocket 이벤트는 **다른 이벤트와 경합** 가능 → 상태 머신으로 일관성 유지.

---

## 12) 예제: 길이-프리픽스 TCP Echo 클라이언트 (CAsyncSocket)

```cpp
class CLenClient : public CAsyncSocket {
    bool m_connected=false;
    std::deque<std::string> m_out;
    std::vector<char> m_in;
    uint32_t m_expect=0; bool m_readingLen=true;
public:
    bool ConnectTo(LPCWSTR host, UINT port) {
        if (!Create()) return false;
        if (!Connect(host, port) && GetLastError()!=WSAEWOULDBLOCK) return false;
        return true;
    }
    void QueueSend(const std::string& msg) {
        uint32_t len = _byteswap_ulong((uint32_t)msg.size());
        std::string frame((char*)&len, (char*)&len+4); frame += msg;
        m_out.push_back(std::move(frame));
        TrySend();
    }
protected:
    void OnConnect(int e) override { m_connected=(e==0); TrySend(); CAsyncSocket::OnConnect(e); }
    void OnSend(int e) override { if (e==0) TrySend(); CAsyncSocket::OnSend(e); }
    void OnReceive(int e) override {
        if (e!=0) { Close(); return; }
        char buf[4096];
        for (;;) {
            int n = Receive(buf, sizeof(buf));
            if (n==SOCKET_ERROR) { if (GetLastError()==WSAEWOULDBLOCK) break; Close(); return; }
            if (n==0) { Close(); break; }
            m_in.insert(m_in.end(), buf, buf+n);
            Parse();
        }
        CAsyncSocket::OnReceive(e);
    }
    void OnClose(int e) override { Close(); CAsyncSocket::OnClose(e); }
private:
    void TrySend() {
        if (!m_connected) return;
        while (!m_out.empty()) {
            auto& top = m_out.front();
            int n = Send(top.data(), (int)top.size());
            if (n==SOCKET_ERROR) {
                if (GetLastError()==WSAEWOULDBLOCK) return;
                Close(); return;
            }
            if (n < (int)top.size()) { top.erase(0, n); return; }
            m_out.pop_front();
        }
    }
    void Parse() {
        size_t pos=0;
        while (true) {
            if (m_readingLen) {
                if (m_in.size()-pos < 4) break;
                memcpy(&m_expect, &m_in[pos], 4);
                m_expect = _byteswap_ulong(m_expect);
                pos+=4; m_readingLen=false;
            } else {
                if (m_in.size()-pos < m_expect) break;
                std::string msg(&m_in[pos], &m_in[pos+m_expect]);
                pos+=m_expect; m_readingLen=true; m_expect=0;
                // TODO: UI에 msg 표시
            }
        }
        if (pos>0) m_in.erase(m_in.begin(), m_in.begin()+pos);
    }
};
```

---

## 13) TLS(간단 개요)

- 보안 필요 시 **SChannel**(WinHTTP/WinINet/Boost.Beast 등 상위 라이브러리도 가능).  
- 수동 구현 시: TCP 연결 후 **TLS 핸드셰이크** → 암호화된 send/recv (복잡).  
- HTTP는 **WinHTTP** / **libcurl** 추천 (타임아웃/리다이렉트/프록시/인증 포함).

---

## 14) DNS/Happy Eyeballs(IPv6/IPv4 빠른 연결)

- `getaddrinfo`로 IPv6/IPv4 주소 모두 획득 후, **짧은 지연을 두고(200ms 등) 병렬 connect**  
- 먼저 성공한 주소로 확정, 나머지는 취소 → 모바일/공용 네트워크에서 연결성 개선.

---

## 15) 로깅/계측/관측성

- 각 연결에 **ConnectionId**(증분 번호/UUID) 부여 → 로그 상관관계 유지  
- 주요 이벤트(Resolve/Connect/Send/Recv bytes/Close/Retry/Timeout) 타임스탬프 기록  
- 통계: 평균 RTT, 재시도 횟수, 타임아웃 비율, 바이트 전송량 → **성능/품질 SLIs** 확보

---

## 16) 종합 체크리스트

- [ ] **부분 송수신** 처리(큐/누적 버퍼)  
- [ ] **프레이밍** 설계(길이 프리픽스/구분자)  
- [ ] **타임아웃**(연결/활동/요청) & **취소**  
- [ ] **재시도**(지수 백오프 + Jitter, Budget, Idempotency)  
- [ ] **상태 머신**(Disconnected/Connecting/Connected/Backoff)  
- [ ] **에러 분류**(재시도 가능/불가)  
- [ ] **KeepAlive/헬스체크**  
- [ ] **IPv6/Happy Eyeballs**  
- [ ] **Nagle/버퍼** 튜닝(필요 시)  
- [ ] **로깅/계측** & 진단(에러코드/원인)  
- [ ] **보안**(TLS 필요 시 상위 라이브러리 고려)  
- [ ] **테스트**(패킷 손실/지연/재전송/서버 다운/네트워크 스위치/대량 메시지)

---

## 17) 부록: 간단 재시도 래퍼 (HTTP GET 예, blocking)

```cpp
bool HttpGetWithRetry(const std::wstring& host, const std::wstring& path,
                      std::string& out, DWORD perAttemptMs=3000, int maxAttempts=5)
{
    for (int a=0; a<maxAttempts; ++a) {
        out.clear();
        if (HttpGet(host, path, out, perAttemptMs))
            return true;
        DWORD backoff = NextBackoff(a);
        Sleep(backoff);
    }
    return false;
}
```

---

## 18) 부록: 서버 스케치(accept + select)

```cpp
class SimpleEchoServer {
    SOCKET m_listen = INVALID_SOCKET;
    std::vector<SOCKET> m_clients;
public:
    bool Start(uint16_t port) {
        m_listen = socket(AF_INET6, SOCK_STREAM, 0);
        if (m_listen==INVALID_SOCKET) return false;
        // v4-mapped 허용
        int v6only=0; setsockopt(m_listen, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&v6only, sizeof(v6only));
        sockaddr_in6 addr{}; addr.sin6_family=AF_INET6; addr.sin6_addr = in6addr_any; addr.sin6_port=htons(port);
        if (bind(m_listen,(sockaddr*)&addr,sizeof(addr))!=0) return false;
        if (listen(m_listen, SOMAXCONN)!=0) return false;
        u_long nb=1; ioctlsocket(m_listen, FIONBIO, &nb);
        return true;
    }
    void Loop() {
        for (;;) {
            fd_set rfds; FD_ZERO(&rfds); FD_SET(m_listen,&rfds);
            SOCKET maxfd=m_listen;
            for (auto s : m_clients) { FD_SET(s,&rfds); if (s>maxfd) maxfd=s; }
            timeval tv{0, 200*1000}; // 200ms
            int rc = select(0, &rfds, nullptr, nullptr, &tv);
            if (rc<=0) continue;
            if (FD_ISSET(m_listen,&rfds)) {
                for (;;) {
                    sockaddr_storage ss; int slen=sizeof(ss);
                    SOCKET c = accept(m_listen,(sockaddr*)&ss,&slen);
                    if (c==INVALID_SOCKET) break;
                    u_long nb=1; ioctlsocket(c, FIONBIO, &nb);
                    m_clients.push_back(c);
                }
            }
            for (size_t i=0;i<m_clients.size();) {
                SOCKET s = m_clients[i];
                if (FD_ISSET(s,&rfds)) {
                    char buf[4096]; int n = recv(s,buf,sizeof(buf),0);
                    if (n<=0) { closesocket(s); m_clients.erase(m_clients.begin()+i); continue; }
                    // echo
                    send(s, buf, n, 0);
                }
                ++i;
            }
        }
    }
};
```

---

### 마무리

- 네트워킹은 **I/O 패턴**(CAsyncSocket/Blocking/Non-blocking/IOCP)과 **프로토콜/타임아웃/재시도**의 **교차 설계**입니다.  
- **부분 송수신/프레이밍/상태 머신**을 제대로 구현하면, 어떤 패턴을 쓰든 **견고한** 클라이언트·서버를 만들 수 있습니다.