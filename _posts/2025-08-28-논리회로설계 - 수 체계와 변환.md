---
layout: post
title: 논리회로설계 - 수 체계와 변환
date: 2025-08-28 14:25:23 +0900
category: 논리회로설계
---
# 수 체계와 변환 — 디지털 시스템/스위칭 회로, 2진 산술, 음수 표현, 2진 코드

> 목표: 디지털 논리 설계의 **숫자 표기·변환·연산**을 한 번에 정리합니다. 수식은 *MathJax*로, 필요 표는 마크다운으로 제시합니다.

---

## 1) 디지털 시스템과 스위칭 회로 개요

### 1.1 디지털 시스템
- **정보 단위:** 이진(0, 1) 신호
- **조합논리**(현재 입력만으로 출력 결정) + **순차논리**(상태/메모리 보유)
- **계층:** 트랜지스터 → 게이트(NAND/NOR 등) → 블록(MUX/가산기) → 서브시스템(FSM, ALU) → 시스템(CPU/FPGA)

### 1.2 스위칭 회로와 부울함수
- **스위칭 함수:** \(\;f:\{0,1\}^n \rightarrow \{0,1\}\)  
- **게이트 구현:** AND(직렬), OR(병렬), NOT(반전)  
- **샤논의 스위칭 대수:** 릴레이·트랜지스터 네트워크 ↔ 부울식 **동등성**

### 1.3 실제 신호와 노이즈 마진
- 로직 레벨은 **전압 범위**로 정의(예: CMOS)  
- 노이즈 마진(개념식):  
  \[
  NM_H = V_{OH(min)} - V_{IH(min)},\quad
  NM_L = V_{IL(max)} - V_{OL(max)}
  \]
- **동기식 설계**(클록 기반)로 시간/메타안정성 문제를 제어

---

## 2) 수 체계와 위치 표기 (Positional Number System)

### 2.1 밑(radix)과 가중치
- 밑 \(r\)에서 숫자 \(\;x=(d_{n-1}\dots d_1 d_0 . d_{-1} d_{-2}\dots)_r\) 의 값:
  \[
  x=\sum_{i=-k}^{n-1} d_i\, r^i,\quad d_i\in\{0,\dots,r-1\}
  \]
- 자주 쓰는 밑: \(r=2\) (이진), \(8\) (팔진), \(10\) (십진), \(16\) (십육진)

### 2.2 실습 예시
- \((1101.101)_2\)  
  \[
  = 1\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^0+1\cdot2^{-1}+0\cdot2^{-2}+1\cdot2^{-3}
  = 13.625_{10}
  \]

---

## 3) 진법 변환(일반/특수 요령)

### 3.1 십진 ↔ 다른 밑
- **정수부**: 새 밑으로 **나눗셈 몫/나머지 반복**(나머지를 역순으로 읽기)  
- **소수부**: 새 밑으로 **곱셈 반복**, 정수부를 순서대로 읽기

### 3.2 2진 ↔ 8진/16진(빠른 변환)
- **2↔8:** 3비트씩 묶기  
- **2↔16:** 4비트씩 묶기  
- 예) \((1011\;0110\;1111)_2 = (5\;6\;F)_{16} = (56F)_{16}\)

### 3.3 예제
- \((101101.011)_2\) 를 10진수:
  \[
  32+8+4+1+0.25+0.125=45.375_{10}
  \]
- 같은 수를 16진수:
  - 정수부 \(101101_2 = 2D_{16}\), 소수부 \(.011_2 = .6_{16}\)  
  - \((2D.6)_{16}\)

---

## 4) 2진 산술 연산

### 4.1 덧셈/뺄셈(기본 규칙)
- 1비트 덧셈 표:  
  \[
  0+0=0,\;0+1=1,\;1+0=1,\;1+1=0\text{ (올림 1)}
  \]
- **뺄셈:** \(\;A-B = A + (\text{B의 2의 보수})\)

### 4.2 올림·차용과 오버플로
- **부호 없는** 덧셈: 최상위 비트에서 **캐리 아웃**이면 범위 초과  
- **2의 보수(부호 있는)** 덧셈:  
  - 최상위 비트 **캐리 인 XOR 캐리 아웃 = 1** → **오버플로**  
  - 직관 규칙: **같은 부호 + 같은 부호 = 다른 부호**가 나오면 오버플로
- 예) 8비트에서 \(+100\,(0110\;0100)_2 + +60\,(0011\;1100)_2 = 0001\;1000\;0000\) (9비트) → 결과 160는 8비트 **부호 있는** 범위 초과

### 4.3 곱셈/나눗셈(개념)
- **이진 곱셈:** 쉬프트-가산(‘곱하는 자리’가 1일 때 더하고 쉬프트)  
- **이진 나눗셈:** 쉬프트-감산(복원/비복원 방식)  
- 고정소수점일 때 **소수 비트 수**를 추적하여 자리 맞추기

### 4.4 BCD 덧셈(참고)
- 8421 BCD에서 **4비트 합 > 9** 또는 **하위 4비트 캐리** 발생 시 **6(0110\_2) 보정**을 더함

---

## 5) 음수의 표현(고정 길이 정수)

### 5.1 부호-크기(Sign-Magnitude)
- 최상위 비트(MSB)가 부호(0=+, 1=−)  
- **단점:** \(+0\)과 \(-0\) 두 가지 0이 존재

### 5.2 1의 보수(One’s Complement)
- 음수: 비트 반전  
- **덧셈 시** 엔드어라운드 캐리(최상위 캐리를 최하위에 더함)
- **단점:** 역시 **±0** 존재

### 5.3 2의 보수(Two’s Complement) — 표준
- 음수: **비트 반전 후 +1**  
  \[
  -x = \overline{x} + 1
  \]
- 장점: **0이 유일**, **뺄셈 = 덧셈**으로 통일, 하드웨어 단순
- \(n\)비트 표기 범위:  
  \[
  -2^{n-1} \le x \le 2^{n-1}-1
  \]
- **부호 확장:** MSB(부호)를 복제하여 상위 비트 채움

### 5.4 바이어스(Excess-K) 표현(참고)
- 저장값 \(= \text{실제값} + K\), 예: **Excess-127**(부동소수점 지수)  
- 비교에 유리(큰 수일수록 비트값도 큼)

---

## 6) 2진 코드 (Binary Codes)

### 6.1 가중 코드(Weighted Codes)
- **8421 BCD:** 각 10진 자릿수를 4비트로(0000~1001)  
- **Excess-3(초과-3):** \( \text{BCD} + 3 \) (0000→0011, …, 1001→1100)  
- **기타 예:** 2421, 5211 등(특정 하드웨어 최적화 용도)

### 6.2 그레이 코드(Gray Code)
- **연속 수 사이**의 **해밍 거리 1**(한 비트만 변함) → **기계적/아날로그 양자화** 오류 감소
- **변환식(이진→그레이):**
  \[
  g_{n-1}=b_{n-1},\quad g_i=b_{i+1}\oplus b_i\;(i<n-1)
  \]
- **그레이→이진:**  
  \[
  b_{n-1}=g_{n-1},\quad b_i=b_{i+1}\oplus g_i
  \]

### 6.3 문자 코드(요약)
- **ASCII(7비트)**, **확장 ASCII(8비트)**, **유니코드/UTF-8**(가변 길이)  
- **패리티 비트**(짝/홀)로 1비트 오류 검출

### 6.4 오류 검출·정정 코드(개념)
- **해밍 거리 \(d\):** 두 코드워드 간 다른 비트 수  
- \(d\ge2\) → 1비트 오류 **검출**, \(d\ge3\) → 1비트 오류 **정정**
- **Hamming(7,4)**: 데이터 4비트 + 패리티 3비트, **시드롬**으로 오류 위치 판정

---

## 7) 변환·연산 예시 모음

### 7.1 10진 → 2진 (정수부)
- 45 → 2진  
  - 45/2=22 R1, 22/2=11 R0, 11/2=5 R1, 5/2=2 R1, 2/2=1 R0, 1/2=0 R1  
  - 역순 읽기 → \(101101_2\)

### 7.2 10진 소수 → 2진 (소수부)
- 0.375 ×2 = 0.75 → 0  
- 0.75 ×2 = 1.5  → 1  
- 0.5  ×2 = 1.0  → 1  
- 순서대로 → \(.011)_2\)

### 7.3 2의 보수 음수 만들기(8비트)
- \(-13\)의 2의 보수: \(+13=0000\;1101\) → 반전 \(1111\;0010\) → +1: **1111 0011**

### 7.4 오버플로 판단(2의 보수)
- \(0101\;1100(+92) + 0100\;1111(+79) = 10010\;1011\)  
- 8비트 결과 **0010 1011(+43)**, **부호 같음(+,+)**인데 결과 부호가 **+**라서?  
  - 캐리 인/캐리 아웃 XOR = 1이면 오버플로. 실제로 **오버플로 발생**(+171은 8비트 부호 범위 초과)

---

## 8) 요약 체크리스트

- [ ] 위치 표기식 \(\sum d_i r^i\)를 자유롭게 사용  
- [ ] 2↔8(3비트), 2↔16(4비트) **그룹 변환** 숙지  
- [ ] 뺄셈을 **2의 보수 덧셈**으로 통일  
- [ ] 2의 보수 **부호 확장**과 **오버플로 규칙** 기억  
- [ ] BCD 보정(+6), 그레이 코드 변환식 숙지  
- [ ] 해밍 거리 개념과 (7,4) 코드 원리 이해

---

## 9) 빠른 참조(공식/규칙)

- \(\displaystyle x=(d_{n-1}\dots d_0.d_{-1}\dots)_r=\sum d_i r^i\)  
- \( -x = \overline{x} + 1\) (2의 보수)  
- 범위: \(n\)비트 2의 보수 \(\Rightarrow [-2^{n-1},\,2^{n-1}-1]\)  
- 오버플로(2의 보수): **캐리\_in(MSB) XOR 캐리\_out(MSB)=1**  
- BCD 보정: **하위 4비트 > 1001\_2** 또는 **캐리 발생** → **+0110\_2**

---

### 부록) 소규모 연습문제 (정답은 숨김)

1. \((1010\,0111.101)_2\) 를 16진수로.  
2. 8비트 2의 보수에서 \((1001\,0101)_2\) 의 10진 값은?  
3. 8421 BCD로 \(59+36\) 덧셈 시 하위 자릿수 보정이 필요한가?  
4. Gray \(g=1011\) → Binary \(b=?\)