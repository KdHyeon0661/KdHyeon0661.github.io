---
layout: post
title: 논리회로설계 - 수 체계와 변환
date: 2025-08-28 14:25:23 +0900
category: 논리회로설계
---
# 수 체계와 변환 — 디지털 시스템/스위칭 회로, 2진 산술, 음수 표현, 2진 코드 (개정판 2025)

## 0. 개요 — 무엇을, 얼마나, 어떤 관점으로 다루는가
이 문서는 기존 초안을 **보강·확장한 개정판**이다. 디지털 시스템에서 실제로 쓰이는 **수 체계/진법 변환**, **2진 산술(고정소수점 포함)**, **음수 표현(1·2의 보수, 부호-크기, 바이어스)**, **2진 코드(BCD/Excess-3/Gray/Hamming)** 를 **정의 → 원리 → 표/공식 → 예제 → 코드**의 흐름으로 정리한다.  
시험/과제 대비뿐 아니라 **하드웨어(Verilog), 소프트웨어(Python/C)** 양쪽 관점에서 실습 가능한 코드와 주의점을 함께 제시한다.

---

## 1. 디지털 시스템과 스위칭 회로 개요

### 1.1 디지털 시스템의 층위와 모델
- **정보 단위:** 이진(0/1) 신호  
- **조합논리**(현재 입력만으로 출력 결정) + **순차논리**(레지스터/상태 포함)  
- **구성 계층:** 트랜지스터 → 게이트(NAND/NOR/INV 등) → 조합 블록(MUX, 디코더, 가산기) → 순차 블록(레지스터, FSM) → 서브시스템(ALU, 캐시) → 시스템(CPU/SoC/FPGA)

### 1.2 스위칭 함수와 부울 대수
- **스위칭 함수:** $$f:\{0,1\}^n \to \{0,1\}$$  
- **게이트 실현:** AND(직렬), OR(병렬), NOT(반전)  
- **샤논 정리:** 릴레이/트랜지스터 네트워크 ↔ 부울식 **동등성** → 논리식 최적화로 하드웨어 최소화 가능

### 1.3 실제 신호, 전압 레벨, 노이즈 마진
- 로직 레벨은 **전압 범위**로 정의(CMOS 예: 공급전압 \(V_{DD}\) 기준).
- 노이즈 마진(개념식):
  $$
  NM_H = V_{OH(\min)} - V_{IH(\min)},\quad
  NM_L = V_{IL(\max)} - V_{OL(\max)}
  $$
- **동기식 설계**(클록 기반)로 타이밍/메타안정성 제어: 클록 주기, 셋업/홀드, 클록 스큐 검토가 필수.

---

## 2. 수 체계와 위치 표기 (Positional Number System)

### 2.1 위치 표기와 가중치
- 밑 \(r\)의 수 \(x=(d_{n-1}\dots d_0.d_{-1}d_{-2}\dots)_r\) 의 값:
  $$
  x=\sum_{i=-k}^{n-1} d_i\, r^i,\quad d_i\in\{0,\dots,r-1\}
  $$
- 자주 쓰는 밑: \(r\in\{2,8,10,16\}\)

### 2.2 예시
- \((1101.101)_2 = 13.625_{10}\)  
  (정수부 \(=8+4+0+1=13\), 소수부 \(=1/2+0/4+1/8=0.625\))

### 2.3 표 — 2·8·16진 자릿값
| 밑 | 자릿가중치(정수부) | 자릿가중치(소수부) |
|---|--------------------|--------------------|
| 2  | \( \dots,2^3,2^2,2^1,2^0 \) | \(2^{-1},2^{-2},2^{-3},\dots\) |
| 8  | \( \dots,8^3,8^2,8^1,8^0 \) | \(8^{-1},8^{-2},8^{-3},\dots\) |
| 16 | \( \dots,16^3,16^2,16^1,16^0 \) | \(16^{-1},16^{-2},16^{-3},\dots\) |

---

## 3. 진법 변환 — 원리·절차·정밀도

### 3.1 10진 ↔ \(r\)진: 정수부/소수부 알고리즘
- **정수부(나눗셈-나머지 반복):**  
  몫이 0이 될 때까지 \(r\)로 나누고 **나머지를 역순**으로 읽는다.
- **소수부(곱셈-정수부 추출 반복):**  
  소수부분에 \(r\)을 곱해 **정수부를 순서대로** 나열한다.

> 소수부는 일반적으로 **유한히 끝나지 않을 수** 있다(예: 10진 0.1은 2진에서 무한반복).  
> 실무에선 **자리수 제한 + 반올림 규칙(은행가 반올림 등)** 을 명시해야 한다.

### 3.2 2진 ↔ 8/16진: 빠른 그룹 변환
- 2↔8: **3비트씩 묶기**  
- 2↔16: **4비트씩 묶기**  
- 예) \((1011\;0110\;1111)_2 = (56F)_{16}\)

### 3.3 예제 모음
- \((101101.011)_2 = 45.375_{10}\)  
- 같은 수의 16진 표현: 정수부 \(101101_2=2D_{16}\), 소수부 \(.011_2=.6_{16}\) → \((2D.6)_{16}\)
- 10진 45의 2진: 나머지 역순 → \(101101_2\)  
- 10진 0.375의 2진: 곱셈 반복 → \(.011_2\)

### 3.4 코드 — 범용 변환 유틸리티(Python)
```python
# 진법 변환 유틸리티: 정수/소수 변환 + 정확도/반올림 제어
from fractions import Fraction

DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def int_to_base(n: int, base: int) -> str:
    if n == 0: return "0"
    neg = n < 0
    n = abs(n)
    out = []
    while n > 0:
        n, r = divmod(n, base)
        out.append(DIGITS[r])
    s = ''.join(reversed(out))
    return '-' + s if neg else s

def frac_to_base(frac: Fraction, base: int, max_digits: int = 32) -> str:
    # frac in [0,1)
    out = []
    x = frac
    for _ in range(max_digits):
        x *= base
        digit = int(x)
        out.append(DIGITS[digit])
        x -= digit
        if x == 0:
            break
    return ''.join(out)

def float10_to_base(x: float, base: int, frac_digits: int = 16) -> str:
    # 주의: 부동소수 → 근사. 정밀 제어가 필요하면 Decimal/Fraction 사용.
    from decimal import Decimal, getcontext
    getcontext().prec = 64
    neg = x < 0
    x = Decimal(str(abs(x)))
    i = int(x)  # 정수부
    f = x - i   # 소수부
    s_int = int_to_base(int(i), base)
    # 소수부를 분수로 근사해 반복/정확도 제어
    f_frac = Fraction(f)  # Decimal → Fraction 근사
    s_frac = frac_to_base(f_frac, base, max_digits=frac_digits)
    s = s_int + (("." + s_frac) if s_frac else "")
    return "-" + s if neg else s

def base_to_float10(s: str, base: int) -> float:
    neg = s.startswith('-')
    if neg: s = s[1:]
    if '.' in s:
        a, b = s.split('.')
    else:
        a, b = s, ''
    # 정수부
    v = 0
    for ch in a:
        v = v * base + DIGITS.index(ch.upper())
    # 소수부
    f = 0.0
    p = 1.0
    for ch in b:
        p /= base
        f += DIGITS.index(ch.upper()) * p
    return - (v + f) if neg else (v + f)

# 사용 예
print(float10_to_base(13.625, 2))
print(base_to_float10("2D.6", 16))
```

---

## 4. 2진 산술 — 덧셈/뺄셈/곱셈/나눗셈과 오버플로

### 4.1 1비트 덧셈과 전가산기(Full Adder)
- 1비트 합:
  $$
  0+0=0,\;0+1=1,\;1+0=1,\;1+1=0\text{ (올림1)}
  $$
- 전가산기 식:
  $$
  \text{SUM} = A \oplus B \oplus C_{in},\quad
  C_{out} = AB + BC_{in} + AC_{in}
  $$

#### 캐리 룩어헤드(CLA) 개념(요약)
- **전파/생성**: \(P_i = A_i \oplus B_i,\; G_i = A_i B_i\)  
- 캐리: \(C_{i+1}=G_i + P_i C_i\)  
- 블록 단위 전개로 지연을 줄인다.

### 4.2 뺄셈 = 2의 보수 덧셈
- \(A - B = A + (\overline{B} + 1)\)
- 하드웨어: **가산기 하나**로 덧셈/뺄셈 겸용.

### 4.3 오버플로(부호 있는 2의 보수)
- 규칙:
  - **같은 부호 + 같은 부호 → 다른 부호**가 나오면 오버플로.
  - MSB에서 **캐리\_in XOR 캐리\_out = 1** 이면 오버플로.
- 범위( \(n\)비트 2의 보수 ):
  $$
  -2^{n-1} \le x \le 2^{n-1}-1
  $$

### 4.4 고정소수점(Q-포맷) 한눈에
- 예: Qm.n 형식은 **정수부 \(m\)비트, 소수부 \(n\)비트**.  
- 덧셈/뺄셈: **정렬 동일**하면 그대로 가능.  
- 곱셈: 결과 소수부가 \(n+n\)이 되므로 **자리 맞춤**(우측 시프트 \(n\)비트).  
- **포화(saturation)** vs **모듈러 wrap-around** 정책을 명확히.

### 4.5 이진 곱셈/나눗셈 개념
- 곱셈: **쉬프트-가산**(피승수의 각 비트가 1일 때만 더함).  
- 나눗셈: **쉬프트-감산**(복원/비복원).  
- 고성능: **Booth 알고리즘**, **어레이 곱셈기**, **월리스 트리** 등.

### 4.6 BCD 덧셈(8421) 보정
- 4비트 합 > 9 또는 **하위 4비트 캐리** 발생 시 **+6(0110₂)** 보정.

#### 코드 — BCD 자리 보정 Verilog(4비트)
```verilog
module bcd_digit_adder(
  input  wire [3:0] a, b,
  input  wire       cin,
  output wire [3:0] sum,
  output wire       cout
);
  wire [4:0] raw = a + b + cin;         // 0..19
  wire       need_fix = (raw[3:0] > 4'd9) | raw[4];
  assign {cout, sum} = need_fix ? (raw + 5'd6) : raw;
endmodule
```

---

## 5. 음수의 표현(고정 길이 정수)

### 5.1 부호-크기(Sign-Magnitude)
- MSB=부호(0=+,1=−), 나머지는 크기  
- **단점:** \(+0\)과 \(-0\) 존재, 덧셈 회로 복잡

### 5.2 1의 보수(One’s Complement)
- 음수는 **비트 반전**  
- 덧셈 시 **엔드어라운드 캐리**(MSB 캐리를 최하위에 더함)  
- **단점:** \(\pm 0\) 문제 여전

### 5.3 2의 보수(Two’s Complement) — 표준
- 음수: \(-x = \overline{x} + 1\)  
- 장점: **0이 유일**, 뺄셈을 덧셈으로 통일, 하드웨어 단순
- 범위: \( -2^{n-1} \le x \le 2^{n-1}-1\)
- **부호 확장:** 상위 비트를 **MSB(부호) 복제**로 채워 의미 유지

#### 코드 — C: 2의 보수 부호 확장·해석
```c
#include <stdint.h>
#include <stdio.h>

int32_t sign_extend(int32_t x, int from_bits) {
    int32_t shift = 32 - from_bits;
    return (x << shift) >> shift; // 산술 시프트로 부호 유지
}

int main(void) {
    // 8비트 패턴 0b11110011(-13)을 32비트로 부호 확장
    uint8_t u = 0xF3; // 243
    int32_t s = sign_extend(u, 8);
    printf("0x%02X as signed = %d\n", u, s); // -13
    return 0;
}
```

### 5.4 바이어스(Excess-K)
- 저장값 \(= \text{실제값} + K\)  
- 예: **Excess-127**(부동소수점 지수) → **숫자 비교가 단순**.

---

## 6. 2진 코드 — BCD/Excess-3/Gray/문자/오류정정

### 6.1 가중 코드(Weighted Codes)
- **8421 BCD:** 10진 한 자리(0~9)를 4비트(0000~1001)로 표현  
- **Excess-3:** \( \mathrm{BCD} + 3\) → 단일 비트 오류 검출 특성 향상(일부 상황)  
- 기타(2421, 5211 등): 하드웨어/검출 목적의 특수 설계

### 6.2 그레이 코드(Gray)
- 인접한 값 간 **해밍 거리 1** → 기계적 위치 센서/양자화 등에서 오류 민감도 감소  
- 변환(이진→그레이):
  $$
  g_{n-1}=b_{n-1},\quad g_i=b_{i+1}\oplus b_i\;(i<n-1)
  $$
- 역변환(그레이→이진):
  $$
  b_{n-1}=g_{n-1},\quad b_i=b_{i+1}\oplus g_i
  $$
- **연속 카운터**에서 전이 시 글리치 최소화

#### 코드 — Python: Gray 변환/역변환
```python
def bin_to_gray(x: int) -> int:
    return x ^ (x >> 1)

def gray_to_bin(g: int) -> int:
    b = 0
    while g:
        b ^= g
        g >>= 1
    return b

for i in range(8):
    g = bin_to_gray(i)
    r = gray_to_bin(g)
    print(i, bin(g), r)
```

### 6.3 문자 코드(개요)
- **ASCII(7비트)**, **확장 ASCII(8비트)**, **유니코드/UTF-8**(가변 길이)  
- 전송/저장에서 **패리티 비트(짝/홀)** 로 1비트 오류 검출 가능

### 6.4 오류 검출·정정 코드(핵심)
- **해밍 거리 \(d\)**: 두 코드워드 간 상이한 비트 수  
  - \(d\ge 2\): 1비트 **검출**  
  - \(d\ge 3\): 1비트 **정정**(SEC), \(d\ge 4\): 1비트 정정+2비트 검출(SECDED)
- **Hamming(7,4)**: 데이터 4 + 패리티 3, 시드롬으로 오류 위치 지정

#### 표 — Hamming(7,4) 비트 배치(관례)
| 위치 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|------|---|---|---|---|---|---|---|
| 종류 | P1 | P2 | D1 | P3 | D2 | D3 | D4 |

- 패리티 집합 예(짝수 패리티):  
  - \(P1\): 비트 1,3,5,7  
  - \(P2\): 비트 2,3,6,7  
  - \(P3\): 비트 4,5,6,7

#### 코드 — Python: Hamming(7,4) 인코딩/디코딩
```python
def hamming74_encode(d):  # d: 4비트 정수(0..15)
    D1 = (d >> 3) & 1
    D2 = (d >> 2) & 1
    D3 = (d >> 1) & 1
    D4 = (d >> 0) & 1
    # 자리: 1..7
    # P1: 1,3,5,7
    P1 = (1 ^ D1 ^ D2 ^ D4) & 1  # 짝수 패리티 맞추기용
    # P2: 2,3,6,7
    P2 = (1 ^ D1 ^ D3 ^ D4) & 1
    # P3: 4,5,6,7
    P3 = (1 ^ D2 ^ D3 ^ D4) & 1
    # 코드워드(1..7) -> 비트열로 7..1
    cw = (D4<<0)|(D3<<1)|(D2<<2)|(P3<<3)|(D1<<4)|(P2<<5)|(P1<<6)
    return cw

def hamming74_decode(cw):
    # cw 비트 위치 매핑(1..7)
    b = [None] + [(cw >> (7-i)) & 1 for i in range(1,8)]  # b[1]..b[7]
    # 시드롬 계산(짝수 패리티)
    s1 = (b[1] ^ b[3] ^ b[5] ^ b[7]) & 1
    s2 = (b[2] ^ b[3] ^ b[6] ^ b[7]) & 1
    s3 = (b[4] ^ b[5] ^ b[6] ^ b[7]) & 1
    syndrome = (s3<<2)|(s2<<1)|s1
    if syndrome:
        # 1..7 위치 뒤집기
        pos = syndrome
        b[pos] ^= 1
    # 데이터 복원 D1..D4 = 3,5,6,7 위치
    D1, D2, D3, D4 = b[3], b[5], b[6], b[7]
    val = (D1<<3)|(D2<<2)|(D3<<1)|D4
    corrected = syndrome != 0
    return val, corrected, syndrome

# 간단 검증
for d in range(16):
    cw = hamming74_encode(d)
    # 1비트 오류 주입
    for flip in [0, 1, 3, 7]:  # 0=무오류
        cw_err = cw ^ (1 << flip) if flip else cw
        dec, corr, syn = hamming74_decode(cw_err)
        assert dec == d
```

---

## 7. 변환·연산 예시 — 단계별 풀이

### 7.1 10진 → 2진 (정수부)
- 45 → 2진:  
  \(45/2=22\) R1, \(22/2=11\) R0, \(11/2=5\) R1, \(5/2=2\) R1, \(2/2=1\) R0, \(1/2=0\) R1  
  역순 → \(101101_2\)

### 7.2 10진 소수 → 2진
- 0.375 ×2 = 0.75 → 0  
- 0.75 ×2 = 1.5  → 1  
- 0.5 ×2  = 1.0  → 1  
- 결과 \(.011_2\)

### 7.3 2의 보수 음수(8비트)
- \(-13\): \(+13=0000\,1101\) → 반전 \(1111\,0010\) → +1 ⇒ **1111 0011**

### 7.4 오버플로 판단(2의 보수)
- \(0101\,1100(+92) + 0100\,1111(+79)\)  
  캐리\_in(MSB) XOR 캐리\_out(MSB)=1 → **오버플로**(+171은 8비트 부호 범위 초과)

### 7.5 BCD 덧셈
- \(59 + 36\) (8421 BCD):
  - 하위 자리 \(9 + 6 = 15 > 9\) → **+6 보정**, 상위 자리로 캐리 전달
  - 상위 자리 \(5 + 3 + \text{캐리1} = 9\)

---

## 8. 실습: 변환/코딩 유틸 — 하나로 묶어서 써보기(Python)

```python
# 기능: (1) 진법 변환 (2) 2의 보수 표현/해석 (3) Gray/BCD/Hamming
from fractions import Fraction

DIG = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def to_base(num: int, base: int) -> str:
    if num == 0: return "0"
    neg = num < 0
    num = abs(num)
    out = []
    while num:
        num, r = divmod(num, base)
        out.append(DIG[r])
    s = ''.join(reversed(out))
    return '-' + s if neg else s

def from_base(s: str, base: int) -> int:
    neg = s.startswith('-')
    if neg: s = s[1:]
    v = 0
    for ch in s:
        v = v*base + DIG.index(ch.upper())
    return -v if neg else v

def fraction_to_base(fr: Fraction, base: int, digits=16) -> str:
    x = fr
    out = []
    for _ in range(digits):
        x *= base
        d = int(x)
        out.append(DIG[d])
        x -= d
        if x == 0: break
    return ''.join(out)

def twos_complement(value: int, bits: int) -> int:
    # value를 bits비트 2의 보수로 표현한 부호 있는 정수로 해석
    mask = (1 << bits) - 1
    v = value & mask
    if v & (1 << (bits-1)):
        return v - (1 << bits)
    return v

def to_twos_repr(x: int, bits: int) -> str:
    return format(x & ((1<<bits)-1), '0{}b'.format(bits))

def bin_to_gray(x: int) -> int:
    return x ^ (x >> 1)

def gray_to_bin(g: int) -> int:
    b = 0
    while g:
        b ^= g
        g >>= 1
    return b

def bcd_add_digit(a: int, b: int, cin: int=0):
    s = a + b + cin
    if s > 9:
        return s + 6, 1  # 보정 + 캐리
    return s, 0

# 데모
if __name__ == "__main__":
    print("45(10) -> 2진:", to_base(45, 2))
    print("2D.6(16) -> 10진:", from_base("2D", 16) + int("6",16)/16)
    print("-13 (8비트 2의 보수):", to_twos_repr(-13, 8), "해석:", twos_complement(int("11110011",2), 8))
    for i in range(8):
        g = bin_to_gray(i)
        r = gray_to_bin(g)
        print(i, format(g, '03b'), r)
```

---

## 9. 정리 체크리스트 (암기 포인트)

- 위치 표기식:  
  $$x=\sum d_i r^i$$
- 2↔8(3비트), 2↔16(4비트) **그룹 변환**
- 뺄셈을 **2의 보수 덧셈**으로 통일:  
  $$A-B = A + (\overline{B}+1)$$
- 2의 보수 범위:  
  $$-2^{n-1} \le x \le 2^{n-1}-1$$
- 오버플로(2의 보수): **MSB 캐리\_in XOR 캐리\_out = 1**
- BCD 보정: 하위 4비트 > \(1001_2\) 또는 자리 캐리 발생 → **+0110₂**
- Gray 변환/역변환 식 숙지
- 해밍 거리 \(d\)와 SEC/SECDED 개념

---

## 10. 고급 주제(요약 레퍼런스)

### 10.1 고정소수점 Q-포맷 예
- Q1.15에서 \(a\cdot b\) 계산 → 32비트 임시 결과의 **하위 15비트 버림/반올림** 규칙 명시.

### 10.2 덧셈기 구조
- 리플 캐리 → CLA(캐리 룩어헤드) → CARRY-SELECT/CSKA → 병렬 프리픽스(Kogge-Stone 등)로 **지연 감소**.

### 10.3 부동소수점(개요만)
- **부호/지수(바이어스)/가수**. 지수 비교 → 가수 정렬 → 가산 → 정규화 → 반올림(IEEE 754: ties-to-even 권장).

---

## 11. 연습문제 (정답은 숨김)

1. \((1010\,0111.101)_2\) 를 16진수로.  
2. 8비트 2의 보수에서 \((1001\,0101)_2\) 의 10진 값은?  
3. 8421 BCD로 \(59+36\) 덧셈 시 하위 자릿수 보정이 필요한가?  
4. Gray \(g=1011\) → Binary \(b=?\)  
5. Q1.7 고정소수점에서 \(0.75 \times 0.5\) 의 표현과 반올림 방법을 서술하라.  
6. Hamming(7,4)에서 시드롬이 \(110_2\)일 때 뒤집어야 할 비트 위치는?

---

## 12. 부록 — 계산 신뢰도와 반올림
- **무한 반복 소수**(예: 10진 0.1 ↔ 2진) → **유한 자리 절단**이 필수 → 반올림 정책(반올림-짝수, 올림/버림) 명시.  
- 고정소수점/부동소수점 모두 **테스트 벡터**로 검증하라.

---

## 13. 요약
이 문서는 디지털 시스템의 실제 구현에 맞춰 **수 체계/변환 절차**, **2진 산술과 오버플로 판정**, **음수 표현과 부호 확장**, **BCD/Excess-3/Gray/Hamming**을 **공식-표-예제-코드** 축으로 재구성했다. 시험 대비 암기 포인트는 **그룹 변환, 2의 보수 규칙·범위, 오버플로 판정, BCD 보정, Gray/Hamming 공리**다. 실무에선 **정밀도·반올림·포화 정책**을 명확히 하고, **테스트 벡터**로 회로/코드를 교차 검증하라.