---
layout: post
title: Java - 날짜와 시간 처리
date: 2025-07-19 23:20:23 +0900
category: Java
---
# 날짜와 시간 처리 — `java.time`

## 한눈에 보는 지도 (무엇을 언제 쓰나)

| 하고 싶은 일 | 권장 타입 | 이유/설명 |
|---|---|---|
| 날짜만 (연·월·일) | `LocalDate` | 시간/시간대 없음, 생일/마감일 등 |
| 시간만 (시·분·초·나노) | `LocalTime` | 알람, 하루 중 특정 시각 |
| 날짜+시간 (시간대 X) | `LocalDateTime` | DB 레코드 스탬프(시간대 별도 관리 시) |
| **절대 시각**(UTC 타임스탬프) | `Instant` | 로그/서버 간 동기화, epoch 기반 |
| **시간대 포함 시각** | `ZonedDateTime` | 회의/영업시간 등 “어느 도시의 몇 시” |
| **오프셋 포함 시각** | `OffsetDateTime` | `+09:00` 같은 오프셋만 있을 때 |
| 기간(년·월·일) | `Period` | 달/년 단위 보전 (달 길이 가변 고려) |
| 지속시간(초·나노) | `Duration` | 정밀 경과 시간(초 기반), 타이머 |
| 포맷/파싱 | `DateTimeFormatter` | 스레드 안전, 로케일/패턴 지원 |
| 시간대 | `ZoneId`, `ZoneOffset` | `"Asia/Seoul"`, `"+09:00"` |
| 조정자 | `TemporalAdjusters` | 다음 월요일, 말일, n번째 요일 등 |

> **원칙**: “사람이 읽는 지역 시각” → `ZonedDateTime`, “서버 간 절대 시각” → `Instant`.

---

## 레거시 API 요약 (`Date`, `Calendar`)

### `Date` (`java.util.Date`)

- 내부는 **epoch milliseconds**(UTC 기준 `long`) 저장.
- 많은 메서드 deprecated. 시간대 개념 미흡, API 직관성 낮음.
```java
import java.util.Date;

Date now = new Date();
System.out.println(now); // Wed Nov 12 05:23:45 KST 2025 (toString 결과)
```

### `Calendar`

- `Calendar.getInstance()`로 생성. 조작/계산 가능하지만 **가변 객체**이고 가독성/스레드 안전성 떨어짐.
```java
import java.util.Calendar;

Calendar cal = Calendar.getInstance();
cal.add(Calendar.DATE, 7);
int year = cal.get(Calendar.YEAR);
int month = cal.get(Calendar.MONTH) + 1; // 0-based
```

> **새 코드**에서는 `java.time` 사용 권장. 레거시는 **변환 후** 사용(§8).

---

## `java.time` 핵심 개념 (Java 8+)

- **불변(Immutable)**, **스레드 안전(Thread-safe)**.
- 타입이 역할별로 분리 → 실수 감소, 의도 명확.
- 표준 **ISO-8601** 기반, **타임존 데이터(TZDB)** 사용.

주요 타입 일람:
- 날짜/시간: `LocalDate`, `LocalTime`, `LocalDateTime`
- 절대 시각: `Instant`
- 시간대/오프셋: `ZoneId`, `ZoneOffset`, `ZonedDateTime`, `OffsetDateTime`
- 기간/지속시간: `Period`(달/년), `Duration`(초/나노)
- 포맷/파싱: `DateTimeFormatter`
- 보조: `DayOfWeek`, `Month`, `Year`, `YearMonth`, `MonthDay`, `TemporalAdjusters`

---

## 기본 사용: 생성/조작/비교

### 생성

```java
import java.time.*;

LocalDate d1 = LocalDate.now();                       // 시스템 기본 시간대 기준 오늘
LocalDate d2 = LocalDate.of(2025, 11, 11);

LocalTime t1 = LocalTime.of(9, 30, 0);
LocalDateTime ldt = LocalDateTime.of(2025, 11, 11, 9, 30);

Instant inst = Instant.now();                         // UTC 절대 시각
ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of("Asia/Seoul"));
OffsetDateTime odt = OffsetDateTime.now(ZoneOffset.of("+09:00"));
```

### 연산 (plus/minus/with)

```java
LocalDate today = LocalDate.now();
LocalDate nextMonth = today.plusMonths(1);
LocalDate firstDay = today.withDayOfMonth(1);

LocalDateTime twoHoursLater = ldt.plusHours(2);
Instant after10s = inst.plusSeconds(10);
```

### 비교

```java
LocalDate a = LocalDate.of(2025, 1, 1);
LocalDate b = LocalDate.of(2025, 12, 31);
boolean before = a.isBefore(b);   // true
```

---

## — 정확한 “현지 시각” 다루기

### 시간대 지정

```java
ZoneId seoul = ZoneId.of("Asia/Seoul");
ZonedDateTime meetingSeoul = ZonedDateTime.of(2025, 11, 11, 9, 0, 0, 0, seoul);
```

### 다른 지역 시각으로 변환

```java
ZoneId ny = ZoneId.of("America/New_York");
ZonedDateTime meetingNY = meetingSeoul.withZoneSameInstant(ny);
// 같은 순간(Instant)을 뉴욕 시간대로 “표현”만 바꿈
```

### 처리

- 봄(서머타임 시작): **존재하지 않는 시각**(gap)이 생김 → `atZone()`은 자동 보정(앞으로 밀림).
- 가을(서머타임 종료): **겹치는 시각**(overlap) 두 번 존재 → 기본은 **이른 오프셋** 채택.
```java
// 겹침 해소
ZonedDateTime base = ZonedDateTime.of(2025, 11, 2, 1, 30, 0, 0, ny); // 가을 겹침 구간 예시
ZonedDateTime earlier = base.withEarlierOffsetAtOverlap();
ZonedDateTime later   = base.withLaterOffsetAtOverlap();
```

> 반복 일정(예: “매주 09:00 뉴욕”)은 **`ZonedDateTime` + 원 지역 `ZoneId`** 로 계산해야 DST 변화를 안전하게 반영합니다.

---

## 포맷/파싱 (`DateTimeFormatter`)

### 기본

```java
import java.time.format.DateTimeFormatter;

LocalDateTime now = LocalDateTime.now();
DateTimeFormatter f = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String s = now.format(f);

LocalDateTime parsed = LocalDateTime.parse("2025-12-25 20:30:00", f);
```

### ISO & 로케일

```java
String iso = Instant.now().toString(); // 2025-11-11T20:30:00.123Z

DateTimeFormatter lf = DateTimeFormatter.ofLocalizedDateTime(
        java.time.format.FormatStyle.FULL)
    .withLocale(java.util.Locale.KOREAN);
String pretty = ZonedDateTime.now(ZoneId.of("Asia/Seoul")).format(lf);
// 예: 2025년 11월 11일 화요일 오후 5시 30분 대한민국 표준시
```

### 패턴 치트시트(일부)

| 기호 | 의미 | 예 |
|---|---|---|
| `y` | 연도 | `yyyy` → 2025 |
| `M` | 월(숫자) | `MM` → 01..12 |
| `d` | 일 | `dd` |
| `E` | 요일 | `EEE`/`EEEE` |
| `H` | 시(0-23) | `HH` |
| `m` | 분 | `mm` |
| `s` | 초 | `ss` |
| `S` | 나노의 ms 자리 | `SSS` |
| `X` | ISO 오프셋 | `X` → `Z`/`+09`/`+09:00` |
| `z` | 시간대 이름 | `z` → `KST`, `PDT` |

> `DateTimeFormatter`는 **스레드 안전**. 레거시 `SimpleDateFormat`은 **스레드 안전하지 않음**.

### 다중 패턴 파싱 (안전)

```java
DateTimeFormatter f1 = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
DateTimeFormatter f2 = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

LocalDateTime dt;
String input = "2025-11-11T09:00:00";
try {
    dt = LocalDateTime.parse(input, f1);
} catch (Exception e) {
    dt = LocalDateTime.parse(input, f2);
}
```

---

## 기간/지속시간: `Period` vs `Duration`

- `Period`: 사람 기준(월/년 단위 보전, 길이 가변). 반복 청구일, 만기일 등.
- `Duration`: 기계 기준(초/나노). 타임아웃, 경과 시간 측정.
```java
import java.time.*;

Period p = Period.ofMonths(1).plusDays(10); // +1개월 10일
Duration d = Duration.ofMinutes(90);        // +90분

LocalDate nextBill = LocalDate.now().plus(p);
Instant expireAt = Instant.now().plus(d);
```

DST 경계에서 차이:
```java
ZoneId ny = ZoneId.of("America/New_York");
ZonedDateTime start = ZonedDateTime.of(2025, 3, 9, 1, 30, 0, 0, ny); // DST 시작일 전후
ZonedDateTime plus2h = start.plusHours(2);   // DST gap 보정 반영
Duration diff = Duration.between(start, plus2h); // 실제 1시간 차이일 수 있음(보정 결과)
```

---

## `TemporalAdjusters` — “다음 월요일 9시”, “말일” 등

```java
import static java.time.temporal.TemporalAdjusters.*;
import java.time.*;

LocalDate nextMon = LocalDate.now().with(nextOrSame(DayOfWeek.MONDAY));
LocalDate lastDay = LocalDate.now().with(lastDayOfMonth());

LocalDate thirdFri = YearMonth.of(2025, 11)
    .atDay(1)
    .with(dayOfWeekInMonth(3, DayOfWeek.FRIDAY));

ZonedDateTime opening = ZonedDateTime.now(ZoneId.of("Asia/Seoul"))
    .withHour(9).withMinute(0).withSecond(0).withNano(0)
    .with(nextOrSame(DayOfWeek.MONDAY));
```

---

## 레거시 변환 (Date/Calendar/JDBC)

### `Date` ↔ `Instant`/`LocalDateTime`

```java
import java.util.Date;
import java.time.*;

Date old = new Date();
Instant i = old.toInstant();

LocalDateTime ldt = i.atZone(ZoneId.systemDefault()).toLocalDateTime();
Date back = Date.from(ldt.atZone(ZoneId.systemDefault()).toInstant());
```

### `Calendar`/`TimeZone`

```java
import java.util.*;
import java.time.*;

Calendar cal = Calendar.getInstance();
Instant ci = cal.toInstant();
ZoneId zid = cal.getTimeZone().toZoneId();
ZonedDateTime cz = ci.atZone(zid);
```

### `java.sql` 계열

- `java.sql.Date`/`Time`/`Timestamp`는 **레거시**.
- **현대 JDBC**는 `LocalDate`, `LocalDateTime`, `Instant` 바인딩 지원(드라이버 의존).
- 권장: DTO/도메인에는 `java.time` 타입을 사용.

---

## Epoch/밀리초/나노 — 숫자 스탬프 변환

```java
long ms = System.currentTimeMillis();      // epoch millis (UTC)
Instant i = Instant.ofEpochMilli(ms);
long ms2 = i.toEpochMilli();

long sec = i.getEpochSecond();
int  nano = i.getNano();

Instant precise = Instant.ofEpochSecond(1700000000L, 123_456_789);
```

---

## 시간 소스 추상화 — `Clock`으로 테스트 가능한 코드

```java
import java.time.*;

class Service {
    private final Clock clock;
    Service(Clock clock) { this.clock = clock; }

    Instant now() { return Instant.now(clock); }
}

Clock fixed = Clock.fixed(Instant.parse("2025-11-11T00:00:00Z"), ZoneOffset.UTC);
Service svc = new Service(fixed);
System.out.println(svc.now()); // 항상 고정 → 테스트 안정
```

> 운영에서는 `Clock.systemDefaultZone()`/`Clock.systemUTC()` 주입.

---

## JSON 직렬화 (Jackson)

- `jackson-datatype-jsr310` 추가 후 등록:
```java
ObjectMapper m = new ObjectMapper()
    .registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule())
    .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
```
- 그러면 `LocalDate/Instant/ZonedDateTime` 등이 ISO-8601 문자열로 직렬화/역직렬화.

---

## 안전한 로케일/시간대 설정

- 서버(OS/컨테이너) 기본 시간대가 예상과 다를 수 있음(예: UTC).
  애플리케이션 로직에서 **명시적으로 `ZoneId` 지정**하거나, 애플리케이션 기동 시 `-Duser.timezone=Asia/Seoul` 고려.

---

## 실전 예제 모음

### “다음 주 월요일 09:00 KST” 스케줄 계산

```java
import static java.time.temporal.TemporalAdjusters.*;
import java.time.*;

ZoneId KST = ZoneId.of("Asia/Seoul");
ZonedDateTime nextMon9 = ZonedDateTime.now(KST)
    .with(next(DayOfWeek.MONDAY))
    .withHour(9).withMinute(0).withSecond(0).withNano(0);
```

### “서울 11월 11일 09:00 회의 → 뉴욕 현지 시각”

```java
ZoneId seoul = ZoneId.of("Asia/Seoul");
ZoneId ny = ZoneId.of("America/New_York");

ZonedDateTime seoulTime = ZonedDateTime.of(2025, 11, 11, 9, 0, 0, 0, seoul);
ZonedDateTime nyTime    = seoulTime.withZoneSameInstant(ny);
```

### 매달 **마지막 영업일**(주말 제외)

```java
import static java.time.temporal.TemporalAdjusters.*;
import java.time.*;

LocalDate lastBizDay(LocalDate anyDay) {
    LocalDate d = anyDay.with(lastDayOfMonth());
    if (d.getDayOfWeek() == DayOfWeek.SATURDAY) return d.minusDays(1);
    if (d.getDayOfWeek() == DayOfWeek.SUNDAY)   return d.minusDays(2);
    return d;
}
```

### 분기 시작/끝

```java
LocalDate date = LocalDate.now();
int q = (date.getMonthValue()-1)/3 + 1;
int startMonth = (q-1)*3 + 1;
LocalDate qStart = LocalDate.of(date.getYear(), startMonth, 1);
LocalDate qEnd   = qStart.plusMonths(3).minusDays(1);
```

### 내 통화 **총 분** 계산 (DST 고려 지역 간)

```java
import java.time.*;
import java.time.temporal.ChronoUnit;

long businessMinutesBetween(ZonedDateTime start, ZonedDateTime end, ZoneId officeZone) {
    ZonedDateTime s = start.withZoneSameInstant(officeZone);
    ZonedDateTime e = end.withZoneSameInstant(officeZone);
    long total = 0;
    for (ZonedDateTime day = s.truncatedTo(ChronoUnit.DAYS);
         day.isBefore(e.truncatedTo(ChronoUnit.DAYS).plusDays(1));
         day = day.plusDays(1)) {
        ZonedDateTime open  = day.withHour(9).withMinute(0);
        ZonedDateTime close = day.withHour(18).withMinute(0);
        ZonedDateTime from  = s.isAfter(open)  ? s : open;
        ZonedDateTime to    = e.isBefore(close)? e : close;
        if (!from.isAfter(to)) total += ChronoUnit.MINUTES.between(from, to);
    }
    return total;
}
```

### 스톱워치(경과 측정)

```java
Instant a = Instant.now();
// ... work ...
Instant b = Instant.now();
long ms = java.time.Duration.between(a, b).toMillis();
```

---

## 흔한 함정 & 예방 체크리스트

| 함정 | 원인 | 대안 |
|---|---|---|
| `LocalDateTime`에 시간대가 없는데 현지 시각으로 오해 | 타입 의미 불명확 | 사람 기준 시각은 **`ZonedDateTime`** 사용 |
| DST 겹침/누락에서 잘못된 시간 계산 | `plusHours`/`atZone` 보정 규칙 미숙지 | **원 지역 `ZoneId` 유지** + `withEarlier/withLaterOffsetAtOverlap` 명시 |
| `SimpleDateFormat` 동시성 버그 | 스레드 비안전 | **`DateTimeFormatter`** 사용 |
| 서버 TZ가 바뀌면서 스케줄 꼬임 | 시스템 기본 TZ 의존 | **명시적 `ZoneId`** 또는 `UTC` + 표현 시 변환 |
| epoch/숫자 스탬프 직접 계산 | 오프셋/윤초/오차 | **`Instant`/`Duration` API** 사용 |
| `Date` ↔ 새 API 뒤섞기 | 의미 혼재 | 경계에서 **즉시 변환**하여 통일 |

---

## 요약 표

| 주제 | 권장 사항 |
|---|---|
| 새 코드 | `java.time` 사용, 불변/스레드 안전 |
| 절대 시각 | `Instant` |
| 지역 시각 | `ZonedDateTime` + 명시적 `ZoneId` |
| 포맷/파싱 | `DateTimeFormatter` (ISO/로케일/패턴) |
| 기간/지속시간 | 달/년: `Period`, 초/나노: `Duration` |
| 조정 | `TemporalAdjusters` (말일/요일 등) |
| 레거시 | 경계에서 변환 후 새 API로만 처리 |
| 테스트 | `Clock` 주입(`fixed`, `offset`) |

---

## `Date`/`Calendar` ↔ `java.time` 치트시트

| 레거시 | 새 API |
|---|---|
| `new Date()` | `Instant.now()` |
| `date.getTime()` | `instant.toEpochMilli()` |
| `new Date(ms)` | `Instant.ofEpochMilli(ms)` |
| `Calendar` → `ZonedDateTime` | `cal.toInstant().atZone(cal.getTimeZone().toZoneId())` |
| `TimeZone` → `ZoneId` | `tz.toZoneId()` |
| `SimpleDateFormat` | `DateTimeFormatter` |

---

## 포맷 패턴 예

```java
DateTimeFormatter KST_STAMP =
    DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS 'KST'");

ZonedDateTime nowKst = ZonedDateTime.now(ZoneId.of("Asia/Seoul"));
System.out.println(nowKst.format(KST_STAMP)); // 2025-11-11 05:12:30.123 KST
```

---

## 결론

- **사람에게 보이는 시각**과 **기계 절대 시각**을 **타입으로 구분**하라.
- 시간대와 DST(서머타임) 규칙은 **API에 맡기되**, 겹침/누락 처리 방식을 이해하고 필요 시 명시.
- 포맷/파싱은 `DateTimeFormatter`로, 레거시는 경계에서 변환.
- 테스트는 `Clock`으로 시간 소스를 주입해 **결정적(Deterministic)** 으로 만들 것.

위 원칙을 따르면, 날짜/시간 도메인에서 흔한 버그의 80% 이상을 선제적으로 차단할 수 있습니다.
