---
layout: post
title: 운영체제 - 스레드와 동시성 (2)
date: 2025-10-20 14:25:23 +0900
category: 운영체제
---
# Thread Libraries • Implicit Threading • Threading Issues • OS Examples

본 장은 실무에서 바로 쓰이는 **스레딩 라이브러리**(4.4), **암묵적 스레딩**(4.5), 현장에서 자주 맞닥뜨리는 **동시성 이슈**(4.6), 그리고 OS별 **구체 예시**(4.7)를 코드 중심으로 정리한다.
예제는 주로 **리눅스(gcc/clang + pthreads/C++), Windows(MSVCRT/Win32), macOS(GCD)** 를 다룬다.

---

## Thread Libraries

스레드 라이브러리는 OS의 커널 스레드와 연동해 **생성·합류·동기화**를 제공한다. 대표는 **POSIX Threads(pthreads)**, **C++ std::thread**, **Java Threads/Executors**, **.NET TPL**, **OpenMP**, **Windows Threads** 등.

### POSIX Threads (pthreads)

- 헤더: `<pthread.h>`
- 주요 API: `pthread_create`, `pthread_join`, `pthread_mutex_*`, `pthread_cond_*`, `pthread_rwlock_*`, `pthread_attr_*`

#### 예제: 기본 생성·합류 + 뮤텍스 보호

```c
// pth_basic.c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#define N 4

static long long counter=0;
static pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

void* worker(void* arg){
  long iters = (long)arg;
  for(long i=0;i<iters;i++){
    pthread_mutex_lock(&m);
    counter++;                 // 보호구역
    pthread_mutex_unlock(&m);
  }
  return NULL;
}
int main(){
  pthread_t th[N];
  for(int i=0;i<N;i++) pthread_create(&th[i],NULL,worker,(void*)500000);
  for(int i=0;i<N;i++) pthread_join(th[i],NULL);
  printf("counter=%lld\n", counter);
}
```
```bash
gcc -O2 pth_basic.c -o pth_basic -lpthread && ./pth_basic
```

#### 예제: 조건변수 — 생산자/소비자(고전)

```c
// pth_cond.c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#define CAP 8

int buf[CAP], head=0, tail=0, cnt=0;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  cv_not_full  = PTHREAD_COND_INITIALIZER;
pthread_cond_t  cv_not_empty = PTHREAD_COND_INITIALIZER;

void* prod(void*){
  for(int x=1;x<=20;x++){
    pthread_mutex_lock(&m);
    while(cnt==CAP) pthread_cond_wait(&cv_not_full, &m);
    buf[head]=x; head=(head+1)%CAP; cnt++;
    pthread_cond_signal(&cv_not_empty);
    pthread_mutex_unlock(&m);
    usleep(20000); // 시연용
  }
  return NULL;
}
void* cons(void*){
  for(int i=0;i<20;i++){
    pthread_mutex_lock(&m);
    while(cnt==0) pthread_cond_wait(&cv_not_empty, &m);
    int x=buf[tail]; tail=(tail+1)%CAP; cnt--;
    pthread_cond_signal(&cv_not_full);
    pthread_mutex_unlock(&m);
    printf("got %d\n", x);
  }
  return NULL;
}
int main(){
  pthread_t p,c;
  pthread_create(&p,NULL,prod,NULL);
  pthread_create(&c,NULL,cons,NULL);
  pthread_join(p,NULL); pthread_join(c,NULL);
}
```

> **관찰 포인트**
> - `while`로 조건 재확인(스퍼리어스 웨이크업 대응).
> - 생산자/소비자가 여러 개여도 동일 패턴.

---

### C++17/20 `std::thread`, `std::mutex`, `std::condition_variable`, `std::future`

- **표준 라이브러리** 기반, 플랫폼 간 이식성↑
- **`std::async`** 로 간단한 비동기 실행, **`std::promise/future`** 로 결과 전달

#### 예제: `std::async`와 타임아웃

```cpp
// stl_async.cpp
#include <future>
#include <iostream>
#include <thread>
#include <chrono>

int slow(int x){ std::this_thread::sleep_for(std::chrono::milliseconds(300)); return x*2; }
int main(){
  auto f = std::async(std::launch::async, slow, 21);
  if(f.wait_for(std::chrono::milliseconds(100))==std::future_status::timeout){
    std::cout<<"still working...\n";
  }
  std::cout<<"ans="<<f.get()<<"\n";
}
```

---

### OpenMP (컴파일러 지시어 기반 병렬화)

- 배열/루프 병렬화 등 **데이터 병렬**에 적합
- **장점**: 코드 변경 최소, **단점**: 세밀한 제어는 제한

```cpp
// omp_pi.cpp : 몬테카를로로 원주율 근사
#include <random>
#include <iostream>
#ifdef _OPENMP
#include <omp.h>
#endif

int main(){
  const long N=10000000; long hit=0;
  #pragma omp parallel
  {
    std::mt19937_64 rng(1234+omp_get_thread_num());
    std::uniform_real_distribution<double> U(0.0,1.0);
    long local=0;
    #pragma omp for
    for(long i=0;i<N;i++){ double x=U(rng), y=U(rng); if(x*x+y*y<=1.0) local++; }
    #pragma omp atomic
    hit+=local;
  }
  std::cout<<"pi≈"<<(4.0*hit/N)<<"\n";
}
```
```bash
g++ -O3 -fopenmp omp_pi.cpp -o omp_pi && ./omp_pi
```

---

### Java — Threads & Executors

- `Thread`, `Runnable/Callable`, `Future`, `ExecutorService`, `CompletableFuture`
- 스레드풀은 **`Executors.newFixedThreadPool()`** 등으로 쉽게 생성

```java
// ExecDemo.java
import java.util.*;
import java.util.concurrent.*;
public class ExecDemo {
  public static void main(String[] args) throws Exception {
    ExecutorService ex = Executors.newFixedThreadPool(4);
    List<Future<Integer>> fs = new ArrayList<>();
    for(int i=0;i<8;i++){
      final int k=i;
      fs.add(ex.submit(() -> { Thread.sleep(100); return k*k; }));
    }
    for(Future<Integer> f: fs) System.out.println(f.get());
    ex.shutdown();
  }
}
```

---

### .NET — TPL(Task Parallel Library) & async/await

```csharp
// Program.cs
using System;
using System.Linq;
using System.Threading.Tasks;
class P {
  static async Task<int> Work(int x){ await Task.Delay(100); return x*x; }
  static async Task Main(){
    var tasks = Enumerable.Range(1,8).Select(Work).ToArray();
    var res = await Task.WhenAll(tasks);
    Console.WriteLine(string.Join(",", res));
  }
}
```

---

### Windows Threads (Win32)

- API: `CreateThread`, `WaitForSingleObject`, `CRITICAL_SECTION`, `SRWLOCK`, `CONDITION_VARIABLE`

```c
// win_thread.c (Windows)
#include <windows.h>
#include <stdio.h>

DWORD WINAPI T(LPVOID p){ Sleep(100); printf("hi\n"); return 0; }
int main(){
  HANDLE h = CreateThread(NULL,0,T,NULL,0,NULL);
  WaitForSingleObject(h, INFINITE);
  CloseHandle(h);
}
```

---

## Implicit Threading (암묵적 스레딩)

프로그래머가 스레드 생명주기를 직접 다루지 않고, **런타임/프레임워크**가 스케줄링을 맡는 방식. 예: **OpenMP**, **Intel TBB**, **Grand Central Dispatch(GCD, macOS/iOS)**, **스레드풀/작업 큐**, **언어 런타임(goroutine, async/await)**.

### 작업 큐(Work Queue) & 스레드풀

- 앱은 “작업(description + closure)”만 제출
- 런타임이 **큐잉·우선순위·스레드 수 조절**

```cpp
// implicit_pool.cpp : 간단 태스크 제출 API
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <functional>
#include <vector>

struct Dispatcher{
  std::vector<std::thread> ws;
  std::queue<std::function<void()>> q;
  std::mutex m; std::condition_variable cv; bool stop=false;
  Dispatcher(int n){
    for(int i=0;i<n;i++)
      ws.emplace_back([&]{ for(;;){
        std::function<void()> f;
        { std::unique_lock<std::mutex> lk(m);
          cv.wait(lk,[&]{return stop||!q.empty();});
          if(stop&&q.empty()) return;
          f=std::move(q.front()); q.pop();
        } f();
      }});
  }
  template<class F> void submit(F&& f){
    { std::lock_guard<std::mutex> lk(m); q.emplace(std::forward<F>(f)); }
    cv.notify_one();
  }
  ~Dispatcher(){ { std::lock_guard<std::mutex> lk(m); stop=true; } cv.notify_all();
    for(auto& t:ws) t.join(); }
};
```

> 사용자는 `submit([=]{ /*작업*/ });` 만 호출 → **암묵적 스레딩** 체감.

### Grand Central Dispatch (GCD, macOS/iOS)

- API: **dispatch queues** (`dispatch_async`, `dispatch_apply`, QoS)
- 동시(queue)는 런타임이 워커 스레드 수를 관리

```c
// gcd_demo.m (Objective-C, macOS)
#import <Foundation/Foundation.h>

int main(){
  dispatch_queue_t q = dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0);
  dispatch_group_t g = dispatch_group_create();
  for(int i=0;i<8;i++){
    dispatch_group_async(g, q, ^{ usleep(100000); printf("task %d\n", i); });
  }
  dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
  return 0;
}
```

### Intel TBB / Cilk / Fork-Join (개념)

- **작업 도둑질(Work-Stealing)** 런타임 → 부하 균형
- 개발자는 `parallel_for`, `parallel_reduce` 같은 **고수준 알고리즘** 호출

---

## Threading Issues (실무 이슈 총정리)

### 경쟁 조건(Race), 원자성, 메모리 가시성

- **데이터 레이스**: 한 변수에 대한 동시 Read/Write가 순서 보장 없이 발생
- 해결: **락/원자 연산**, **메모리 오더**(acquire/release, seq_cst)

```cpp
// vis_issue.cpp : 가시성 문제(의도적) — 최적화로 루프가 제거될 수 있음
#include <atomic>
#include <thread>
#include <iostream>

int main(){
  bool flag=false; int data=0;
  std::thread p([&]{ data=42; flag=true; }); // 비원자 → 가시성 미보장(UB)
  std::thread c([&]{ while(!flag){} std::cout<<data<<"\n"; });
  p.join(); c.join();
}
```
> 위 코드는 **정의되지 않은 동작**. 최소한 `std::atomic<bool>` + `memory_order_acquire/release` 필요.

### 데드락(Deadlock) — 재현과 해결

#### 재현

```cpp
// deadlock.cpp
#include <mutex>
#include <thread>
#include <iostream>

std::mutex A,B;
void t1(){ std::lock_guard<std::mutex> g1(A); std::this_thread::sleep_for(std::chrono::ms(10)); std::lock_guard<std::mutex> g2(B); }
void t2(){ std::lock_guard<std::mutex> g1(B); std::this_thread::sleep_for(std::chrono::ms(10)); std::lock_guard<std::mutex> g2(A); }
int main(){ std::thread x(t1), y(t2); x.join(); y.join(); }
```

#### 해결 1: **일관된 락 순서**

```cpp
// deadlock_fix1.cpp
#include <mutex>
#include <thread>
#include <iostream>

std::mutex A,B;
void safe(){
  std::scoped_lock lk(A,B); // C++17 — 한번에 획득(교착 회피)
}
int main(){ std::thread x(safe), y(safe); x.join(); y.join(); }
```

#### 해결 2: **타임아웃 + 재시도**

- `pthread_mutex_timedlock` / `std::timed_mutex`

### 라이브락(Livelock)과 기아(Starvation)

- **라이브락**: 서로 양보만 하며 진전 없음 → 지수 백오프/우선순위
- **기아**: 낮은 우선순위 스레드가 **영원히 기회**를 얻지 못함 → 에이징, 공정 정책

### 우선순위 역전(Priority Inversion)

- 저우선순위 L이 락을 잡고, 고우선 H가 기다리는데, 중간 M이 CPU를 독점 → H가 **역전**되어 대기
- 해결: **Priority Inheritance/Protect**(뮤텍스 프로토콜), 중요 경로 최소화

```c
// pi_pthread.c (개념) — Linux에서 PTHREAD_PRIO_INHERIT 설정
#include <pthread.h>

pthread_mutex_t m;
int main(){
  pthread_mutexattr_t a; pthread_mutexattr_init(&a);
  pthread_mutexattr_setprotocol(&a, PTHREAD_PRIO_INHERIT);
  pthread_mutex_init(&m, &a);
  // ... 스레드 생성/우선순위 설정(RR/ FIFO 스케줄러 필요) ...
}
```

### 스레드 취소(Thread Cancellation)

- **deferred cancellation**이 안전: 취소 지점에서만 중단(`read`, `pthread_testcancel`)
- **asynchronous cancellation**은 리소스 누수/불변식 깨짐 위험

```c
// cancel_deferred.c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void* worker(void*){
  pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);
  for(;;){
    // 안전한 지점
    pthread_testcancel();
    usleep(1000);
  }
  return NULL;
}
int main(){
  pthread_t t; pthread_create(&t,NULL,worker,NULL);
  sleep(1); pthread_cancel(t); pthread_join(t,NULL);
  puts("done");
}
```

### 신호(시그널)와 스레드

- POSIX: **프로세스 전체**로 배달되며, 커널이 **한 스레드**를 선택
- **전용 시그널 스레드**를 두고 `sigwait()`로 처리하는 패턴이 안전

```c
// sigwait_thread.c
#include <signal.h>
#include <pthread.h>
#include <stdio.h>

void* sigthr(void*){
  sigset_t set; sigemptyset(&set); sigaddsig(&set, SIGINT);
  int sig; sigwait(&set,&sig); printf("got %d\n",sig); return NULL;
}
int main(){
  sigset_t set; sigemptyset(&set); sigaddsig(&set, SIGINT);
  pthread_sigmask(SIG_BLOCK, &set, NULL); // 모든 스레드에서 블록
  pthread_t t; pthread_create(&t,NULL,sigthr,NULL);
  pthread_join(t,NULL);
}
```

### 스레드 로컬 저장소(TLS)

- **`__thread`/`thread_local`** 로 스레드마다 분리된 상태
- 상태 공유가 필요 없을 때 **락을 제거**하는 강력한 수단

```cpp
// tls.cpp
#include <thread>
#include <iostream>

thread_local int tls_counter=0;
void f(){ for(int i=0;i<3;i++) { tls_counter++; std::cout<<tls_counter<<" "; } std::cout<<"\n"; }
int main(){ std::thread a(f), b(f); a.join(); b.join(); }
```

### `fork()` + 스레드 주의

- 다스레드 프로세스에서 `fork()`는 **단 하나의 스레드**(콜러)만 복제
- 락이 잡힌 상태였다면 **교착 위험** → `fork` 직후에는 **exec** 권장
- POSIX: `pthread_atfork`로 정리 훅 제공

### I/O와 스케줄링: 블로킹/논블로킹/async

- **블로킹**: 구현 단순, 스레드 수 증가 시 문맥 스위치/스택 메모리 비용↑
- **논블로킹 + 이벤트 루프**: 고동시성, 복잡성↑ → 스레드풀과 **하이브리드**가 실전 정석
- **io_uring/IOCP**: 커널과 공유 큐로 경계 비용↓, 고성능 서버의 선택지

### False Sharing, 캐시 라인 정렬

- **서로 다른 변수**가 **같은 캐시 라인**에 있으면 쓰기 충돌
- 해결: `alignas(64)`/패딩, 구조체 재배치

### 성능/관측

- **CPU**: `pidstat -w`, `perf stat`
- **락 경쟁**: `perf lock`, bpftrace `kprobe:futex_wait`
- **메모리**: `numactl --hardware`, `perf c2c`(캐시라인 충돌)
- **스레드**: `ps -eL`, `/proc/<pid>/task`

---

## Operating-System Examples

운영체제는 각자의 스레딩 런타임과 스케줄러, 동기화 원시를 제공한다.

### Linux (NPTL, futex, CFS)

- **NPTL**: POSIX 스레드 구현. `clone()`으로 **1:1 OS 스레드** 생성
- **futex**: 사용자 공간 락 대기의 커널 원시 → 경합 없으면 **커널 진입 없이** 빠름
- **CFS(Completely Fair Scheduler)**: vruntime 기반 공정 스케줄러

#### futex 기반 락을 사용하는 라이브러리 이해 포인트

- 경합 없을 때 사용자 공간 CAS로 즉시 획득
- 경합 시 `futex(FUTEX_WAIT/WAKE)`로 **수면/깨우기**

#### 관측

```bash
ps -eLo pid,tid,psr,pri,rtprio,state,comm | head
perf stat -e sched:sched_switch -a -- sleep 2
```

### Windows (Win32 threads, SRWLOCK, IOCP)

- **SRWLOCK**: 가벼운 읽기-쓰기 락
- **IOCP**: 고성능 I/O 완료 포트 — 수만 연결에서도 스레드 수 최소화
- **Windows Thread Pool**: `TrySubmitThreadpoolCallback`, `BindIoCompletionCallback`

```c
// win_iocp_echo.c (개념 골격, 실제 사용 시 에러 처리/OVERLAPPED 관리 필요)
```
> Windows는 **스레드 수 << 소켓 수**가 가능 → **IOCP**가 핵심.

### macOS / iOS (pthreads + GCD + QoS)

- **GCD**: 시스템 전역 풀 & QoS 클래스(사용자 인터랙티브, 유저 이니시에이트드, 유틸리티, 백그라운드)
- **오토튜닝**: 큐 길이/CPU 상황에 따라 워커 스레드 자동 조절

#### QoS 예시

```c
// gcd_qos.m
#import <Foundation/Foundation.h>

int main(){
  dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_BACKGROUND, 0);
  dispatch_queue_t q = dispatch_queue_create("bg", attr);
  dispatch_async(q, ^{ printf("bg task\n"); });
  dispatch_sync(dispatch_get_main_queue(), ^{ /* no-op in CLI */ });
  return 0;
}
```

### Android

- **Binder** 스레드 풀(시스템 서비스 RPC)
- 앱 레벨: `HandlerThread`, `AsyncTask(과거, deprec)`, `Executors`, Kotlin **coroutines**(Dispatchers.Default/IO/Main)

### Java HotSpot & JFR

- **OS 스레드 1:1** 매핑
- **JFR(Java Flight Recorder)**로 스레드/락/GC 이벤트 관측

```bash
# 예: JFR로 30초 프로파일링

java -XX:StartFlightRecording=duration=30s,filename=rec.jfr -jar app.jar
```

### .NET ThreadPool & Work-Stealing

- **Hill Climbing** 알고리즘으로 풀 크기 자동 조절
- **`BlockingCollection`**, **`ConcurrentQueue`** 등 lock-free/low-lock 컨테이너

---

## 종합 실습: “혼합형 서버” 설계

목표: **낮은 지연**과 **높은 처리량**을 동시에 달성.

1) **네트워크**: Linux에서 **`epoll` 이벤트 루프**
2) **CPU 바운드**: `std::thread` 기반 **스레드풀**로 오프로딩
3) **락 설계**: 요청 컨텍스트는 **TLS**에 보관, 공유 상태는 **shard-by-key** 로 락 경쟁 분산
4) **관측**: p95/p99 지연, 큐 길이, 컨텍스트 스위치, `perf`로 L1-dcache miss 확인
5) **튜닝**: 코어 핀(pin), NUMA 로컬 할당, 캐시 라인 패딩 → **false sharing** 제거

스케치:
```cpp
// hybrid_server.cpp (개념, 네트워크/파서/에러 처리 축약)
#include <thread>
#include <vector>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <functional>
#include <atomic>

struct Pool{ /* 4.5.1의 Dispatcher와 유사 */ };

int main(){
  Pool cpu(std::thread::hardware_concurrency());
  // epoll 루프에서 read-ready 이벤트 발생 시:
  // 1) 요청 파싱(소량 CPU) 2) 무거운 작업은 cpu.submit([=]{ ... });
  // 3) 완료 시 write-ready 등록
}
```

---

## 체크리스트 요약

- **4.4 라이브러리**:
  - pthreads(저수준·세밀), C++ std::thread(이식성), OpenMP/TBB(데이터 병렬), Java/.NET(풀·future), Windows(Win32/IOCP)
- **4.5 암묵적 스레딩**:
  - 런타임이 풀/큐/스케줄링 담당(GCD/Executors/TPL/OpenMP) → 생산성↑
- **4.6 이슈**:
  - Race/가시성 → 원자/락/메모리오더
  - Deadlock/Livelock/Starvation → 순서·타임아웃·에이징
  - Priority Inversion → Inheritance/Protect
  - 취소, 신호, TLS, fork+threads 주의
  - False sharing/NUMA/관측 도구 숙지
- **4.7 OS 예시**:
  - Linux(NPTL,futex,CFS), Windows(IOCP,SRWLOCK,ThreadPool), macOS/iOS(GCD,QoS), Android(Binder+coroutines)

---

## 추가 과제

1) **우선순위 역전**을 재현하는 미니 실험을 만들고, `PTHREAD_PRIO_INHERIT` 유무에 따른 p99 지연을 비교하라.
2) OpenMP `schedule(static/dynamic/guided)` 를 바꿔 데이터 스케터가 심한 루프의 성능을 비교하라.
3) TLS를 이용해 **로그 버퍼**를 스레드별로 분리한 뒤, 배치 플러시 타이밍을 조절해 전체 처리량을 측정하라.
4) `perf lock`과 bpftrace로 락 핫스팟을 찾아 **shard-by-key**로 분해하고 성능 향상을 수치화하라.
5) Windows에서 **IOCP 에코 서버**를 작성하고, 같은 시나리오의 epoll 서버와 컨텍스트 스위치/CPU 사용률을 비교하라.
