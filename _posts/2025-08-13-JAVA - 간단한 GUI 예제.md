---
layout: post
title: Java - 간단한 GUI 예제
date: 2025-08-13 22:20:23 +0900
category: Java
---
# 간단한 GUI 예제 (JavaFX vs Swing)

이 글은 **같은 요구사항(텍스트 입력 + 버튼 + 이벤트 처리)**을 **JavaFX**와 **Swing**으로 각각 구현해 보고,
**스레드 모델(EDT/FXAT), 스타일링, 의존성, 배포(jpackage), 상호운용(JFXPanel/SwingNode)**까지 한 번에 정리합니다.
(최신 현황 업데이트: **JDK 25 LTS** GA, **JavaFX 25 GA**, JavaFX는 **JDK 11부터 분리**되어 별도 의존성으로 사용)

> 최신 현황 요약: ① **JDK 25**(LTS) 공개, ② **JavaFX 25** 공개(오픈JFX 릴리스), ③ **JavaFX는 JDK에 포함되지 않음**(JDK 11부터).

---

## 준비 사항 & 프로젝트 설정 (최신)

### JDK & 의존성

- **JDK**: 17+ 권장(최신 LTS는 25)
- **JavaFX(OpenJFX)**: JDK와 분리되어 **의존성 추가 필요** (JDK 11+부터).

**Gradle (Kotlin DSL) 예** — JavaFX 25(예시)
```kotlin
plugins {
    application
}

repositories { mavenCentral() }

dependencies {
    implementation("org.openjfx:javafx-controls:25")
    // 필요 시: javafx-fxml, javafx-graphics, javafx-media ...
}

application {
    mainClass.set("demo.JavaFXGuiExample") // non-module 예
}
```

**Maven 예**
```xml
<dependencies>
  <dependency>
    <groupId>org.openjfx</groupId>
    <artifactId>javafx-controls</artifactId>
    <version>25</version>
  </dependency>
</dependencies>
```

> **중요**: JavaFX는 **모듈 시스템**(JPMS)을 잘 지원합니다. 모듈을 쓰면 `module-info.java`에 `requires javafx.controls;` 등을 명시하세요.

---

## 스레드 모델 핵심 (필수 배경)

### Swing — EDT(Event Dispatch Thread)

- **모든 UI 접근/갱신은 EDT에서**: `SwingUtilities.invokeLater(...)`로 작업 예약.
- 긴 작업은 `SwingWorker` 등 **백그라운드 스레드**로 돌리고, 완료 콜백에서 UI 갱신.
  (Oracle 튜토리얼 *Concurrency in Swing* 참조)

### JavaFX — JavaFX Application Thread(FXAT)

- **모든 UI 접근/갱신은 FXAT에서**: `Platform.runLater(...)`로 작업 예약.
- 긴 작업은 `javafx.concurrent.Task`/`Service`로 백그라운드 수행 → `onSucceeded` 등 콜백에서 UI 갱신.
  (JavaFX 25 Javadoc/가이드라인에 동일 원칙이 명시)

> 규칙 요약: **UI 스레드(EDT/FXAT) 규칙을 어기면 멈춤/예외**가 납니다. I/O·CPU 바운드 작업은 반드시 **백그라운드**로.

---

## 최소 예제 — JavaFX

### 기능

- 라벨·텍스트필드·버튼
- 버튼 클릭 시 라벨 업데이트
- **CSS 스타일**과 **간단 입력 검증** 포함

```java
package demo;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class JavaFXGuiExample extends Application {
    @Override
    public void start(Stage primaryStage) {
        Label label = new Label("이름을 입력하세요:");
        TextField textField = new TextField();
        Button button = new Button("확인");

        // 이벤트 처리 (FXAT에서 실행)
        button.setOnAction(e -> {
            String name = textField.getText().trim();
            if (name.isEmpty()) {
                label.setText("이름이 비었습니다. 다시 입력하세요.");
            } else {
                label.setText("안녕하세요, " + name + "!");
            }
        });

        // 간단 CSS
        VBox root = new VBox(10, label, textField, button);
        root.setStyle("-fx-padding: 20; -fx-font-size: 14px;");

        Scene scene = new Scene(root, 320, 160);
        primaryStage.setTitle("JavaFX 예제");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        // 필수: FX 런타임 시작
        Platform.startup(() -> {}); // Application.launch(args)와 동일 효과 (단일 시작)
        launch(args);
    }
}
```

#### — 반응형으로 문구 동기화

```java
// label.textProperty().bind(Bindings.concat("안녕하세요, ", textField.textProperty(), "!"));
// 바인딩은 setOnAction 없이도 즉시 반영. 검증/트리밍이 필요할 땐 리스너/필터를 별도 적용.
```

#### FXML 버전(선택)

UI를 코드에서 분리하고 싶다면 FXML(+SceneBuilder)을 사용합니다.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<VBox xmlns="http://javafx.com/javafx"
      xmlns:fx="http://javafx.com/fxml"
      fx:controller="demo.HelloController" spacing="10" stylesheets="@style.css">
  <children>
    <Label fx:id="label" text="이름을 입력하세요:"/>
    <TextField fx:id="textField"/>
    <Button text="확인" onAction="#onConfirm"/>
  </children>
</VBox>
```
```java
public class HelloController {
    @FXML private Label label;
    @FXML private TextField textField;
    @FXML private void onConfirm() {
        String name = textField.getText().trim();
        label.setText(name.isEmpty() ? "이름이 비었습니다. 다시 입력하세요." : "안녕하세요, " + name + "!");
    }
}
```

---

## 최소 예제 — Swing

### 기능

- 라벨·텍스트필드·버튼
- 버튼 클릭 시 라벨 업데이트
- **EDT에서 생성/표시**, **Nimbus LAF** 설정 예시

```java
package demo;

import javax.swing.*;
import java.awt.*;

public class SwingGuiExample {
    public static void main(String[] args) {
        // 1) Look&Feel (선택) : Nimbus
        try {
            for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) { UIManager.setLookAndFeel(info.getClassName()); break; }
            }
        } catch (Exception ignore) {}

        // 2) EDT에서 UI 생성/표시
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Swing 예제");
            JLabel label = new JLabel("이름을 입력하세요:");
            JTextField textField = new JTextField(15);
            JButton button = new JButton("확인");

            button.addActionListener(e -> {
                String name = textField.getText().trim();
                label.setText(name.isEmpty() ? "이름이 비었습니다. 다시 입력하세요." : "안녕하세요, " + name + "!");
            });

            JPanel panel = new JPanel(new FlowLayout());
            panel.add(label);
            panel.add(textField);
            panel.add(button);

            frame.setContentPane(panel);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.pack();               // 컴포넌트 크기에 맞춰
            frame.setLocationRelativeTo(null); // 화면 중앙
            frame.setVisible(true);
        });
    }
}
```

> Swing UI는 **반드시 EDT에서 생성/조작**하세요. 긴 작업은 `SwingWorker`로 옮기세요.

---

## 비동기 작업 패턴 (필수)

### JavaFX — `Task`

```java
Task<String> task = new Task<>() {
    @Override protected String call() throws Exception {
        // 무거운 작업(네트워크/DB)… 진행률 updateProgress(...)
        Thread.sleep(1000);
        return "완료";
    }
};
task.setOnSucceeded(e -> /* FXAT에서 안전하게 UI 갱신 */ System.out.println(task.getValue()));
new Thread(task, "bg").start();
```

### Swing — `SwingWorker`

```java
SwingWorker<String, Void> worker = new SwingWorker<>() {
    @Override protected String doInBackground() throws Exception {
        Thread.sleep(1000);
        return "완료";
    }
    @Override protected void done() {
        try { String v = get(); System.out.println(v); } catch (Exception ignore) {}
    }
};
worker.execute();
```

---

## 스타일링/레이아웃/미디어

- **JavaFX**: CSS 전면 지원, `-fx-` 속성 중심. Scene Graph(계층) 기반 레이아웃. 2D/3D/애니메이션/미디어/웹뷰 등 **현대 UI**에 강함.
- **Swing**: `LookAndFeel`/`UIManager`로 테마, `LayoutManager`(Flow/Border/GridBag 등)로 배치. 표준 컴포넌트 중심.
- **HiDPI/스케일링**: 최신 JDK에서 두 기술 모두 HiDPI 개선. OS별 렌더링 특성은 앱에서 테스트 권장.

---

## 상호 운용 (혼합)

### Swing 안에 JavaFX 넣기 — `JFXPanel`

```java
JFXPanel fxPanel = new JFXPanel();     // Swing 컴포넌트
Platform.runLater(() -> {
    Button btn = new Button("FX Button");
    btn.setOnAction(e -> System.out.println("clicked"));
    Scene scene = new Scene(new StackPane(btn), 200, 100);
    fxPanel.setScene(scene);
});
```

### JavaFX 안에 Swing 넣기 — `SwingNode`

```java
SwingNode swingNode = new SwingNode();
Platform.runLater(() -> {
    swingNode.setContent(new JButton("Swing Button"));
});
```

> **주의**: 두 세계의 스레드는 다릅니다(EDT vs FXAT). 상호 호출 경계를 넘을 때는 각각 **`invokeLater`/`runLater`**로 전환하세요. (Swing/JavaFX 상호운용 클래스: `JFXPanel`/`SwingNode`)

---

## 배포: 네이티브 설치 파일 만들기 (jpackage)

JDK 14+의 **`jpackage`**로 Windows/msi, macOS/pkg or app, Linux/deb or rpm을 만들 수 있습니다.
JavaFX 앱은 **런타임 이미지**에 JavaFX 모듈을 포함시키는 구성이 필요합니다.

```bash
jpackage \
  --name HelloFX \
  --input build/distributions \
  --main-jar app.jar \
  --main-class demo.JavaFXGuiExample \
  --icon icons/app.ico
```

- 모듈 기반이라면 `--module-path`, `--add-modules javafx.controls` 등을 추가.
- CI에서 OS별 아티팩트를 자동으로 빌드해 배포하면 편리합니다.

---

## JavaFX vs Swing 비교 (정리)

| 항목 | JavaFX | Swing |
|---|---|---|
| 스레드 | **FXAT**(UI), `Platform.runLater`, `Task/Service` | **EDT**(UI), `SwingUtilities.invokeLater`, `SwingWorker` |
| 스타일 | **CSS 전면 지원**, FXML, Scene Builder | Look&Feel, UIManager |
| 구조 | Stage → Scene → Node (Scene Graph) | JFrame → JPanel → Component |
| 멀티미디어/웹뷰 | **내장 지원**(Media, WebView) | 별도 라이브러리 의존 |
| 학습曲선 | 현대적/선언형(FXML), 바인딩 강력 | 단순하지만 대규모 커스텀은 복잡 |
| 배포 | jpackage + 모듈/런타임 이미지 | jpackage(동일), 모듈 비의존도 가능 |
| 최신성 | **OpenJFX 25**(2025), JDK와 분리 | JDK 표준에 계속 포함(레거시도 안정) |

> **선택 가이드**: 신규·리치 UI·애니메이션·미디어 → **JavaFX**.
> 관리도구·레거시 유지보수·가벼운 폼 → **Swing**도 충분.

---

## 트러블슈팅 체크리스트

- [ ] **UI 스레드 규칙** 준수(EDT/FXAT). 블로킹 작업은 `Task`/`SwingWorker`.
- [ ] **JavaFX 의존성 추가**(JDK 11+부터 분리). 모듈/클래스패스 올바르게 설정.
- [ ] **폰트/HiDPI**: OS별 렌더링 차이 테스트.
- [ ] **국제화**: `ResourcesBundle`/`Locale`로 텍스트 분리.
- [ ] **팩토링**: 컨트롤러(FXML)/뷰-모델(MVVM)로 로직 분리, 테스트 용이.

---

## 결론

- **JavaFX**는 현대 UI 요구(스타일·미디어·애니메이션)에 강하고, **CSS/FXML/바인딩**으로 생산성이 높습니다.
- **Swing**은 여전히 가볍고 안정적이며, 단순한 데스크톱 도구나 레거시 환경에서 유효합니다.
- 2025년 현재, **JDK 25 LTS**와 **OpenJFX 25** 조합을 기준으로 개발/배포 환경을 구성하면 최신 스택을 활용할 수 있습니다.

---

## — 검증 + 바인딩 + 비동기

```java
// 파일: demo/HelloFxAdvanced.java
package demo;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.beans.binding.Bindings;
import javafx.concurrent.Task;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Stage;

public class HelloFxAdvanced extends Application {
    @Override
    public void start(Stage stage) {
        Label title = new Label("이름을 입력하세요:");
        TextField tf = new TextField();
        Label greet = new Label();
        Button ok = new Button("확인");
        Button load = new Button("원격 조회(1s)");

        // 바인딩: 빈 문자열이면 경고 문구
        greet.textProperty().bind(
            Bindings.when(tf.textProperty().isEmpty())
                    .then("이름이 비었습니다. 다시 입력하세요.")
                    .otherwise(Bindings.concat("안녕하세요, ", tf.textProperty(), "!"))
        );

        ok.setOnAction(e -> tf.setText(tf.getText().trim()));

        load.setOnAction(e -> {
            Task<String> task = new Task<>() {
                @Override protected String call() throws Exception {
                    Thread.sleep(1000);
                    return "원격 결과";
                }
            };
            task.setOnSucceeded(ev -> new Alert(Alert.AlertType.INFORMATION, task.getValue()).show());
            new Thread(task, "bg").start();
        });

        VBox root = new VBox(10, title, tf, greet, new HBox(10, ok, load));
        root.setPadding(new Insets(16));
        root.setStyle("-fx-font-size: 14px;");
        stage.setScene(new Scene(root, 360, 180));
        stage.setTitle("JavaFX Advanced");
        stage.show();
    }

    public static void main(String[] args) { launch(args); }
}
```

---

## — 검증 + 백그라운드

```java
// 파일: demo/SwingAdvanced.java
package demo;

import javax.swing.*;
import java.awt.*;

public class SwingAdvanced {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            try { for (UIManager.LookAndFeelInfo i : UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(i.getName())) { UIManager.setLookAndFeel(i.getClassName()); break; }
            }} catch (Exception ignore) {}

            JFrame f = new JFrame("Swing Advanced");
            JLabel title = new JLabel("이름을 입력하세요:");
            JTextField tf = new JTextField(15);
            JLabel greet = new JLabel(" ");
            JButton ok = new JButton("확인");
            JButton load = new JButton("원격 조회(1s)");

            ok.addActionListener(e -> {
                String t = tf.getText().trim();
                tf.setText(t);
                greet.setText(t.isEmpty() ? "이름이 비었습니다. 다시 입력하세요." : "안녕하세요, " + t + "!");
            });

            load.addActionListener(e -> {
                new SwingWorker<String, Void>() {
                    @Override protected String doInBackground() throws Exception {
                        Thread.sleep(1000);
                        return "원격 결과";
                    }
                    @Override protected void done() {
                        try {
                            JOptionPane.showMessageDialog(f, get(), "정보", JOptionPane.INFORMATION_MESSAGE);
                        } catch (Exception ignored) {}
                    }
                }.execute();
            });

            JPanel p = new JPanel(new GridBagLayout());
            GridBagConstraints gc = new GridBagConstraints();
            gc.insets = new Insets(5,5,5,5);
            gc.gridx=0; gc.gridy=0; gc.anchor=GridBagConstraints.WEST; p.add(title, gc);
            gc.gridy=1; p.add(tf, gc);
            gc.gridy=2; p.add(greet, gc);
            gc.gridy=3; p.add(ok, gc);
            gc.gridx=1; p.add(load, gc);

            f.setContentPane(p);
            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}
```
