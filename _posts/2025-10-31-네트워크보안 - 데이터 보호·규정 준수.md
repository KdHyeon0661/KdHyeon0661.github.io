---
layout: post
title: 네트워크보안 - 데이터 보호·규정 준수
date: 2025-10-31 19:25:23 +0900
category: 네트워크보안
---
# 데이터 보호·규정 준수(개요)

> 목표
> - **개인정보/로그 보존·마스킹 정책**을 “데이터 생명주기(수집→저장→이동→활용→파기)” 기준으로 체계화한다.
> - **전송·휴지 암호화와 키 관리(KMS/HSM/회전/분리권한)**를 **아키텍처 다이어그램+운영 룰**로 일관화한다.
> - **네트워크 로그의 개인정보 최소화**를 “수집 최소화 → 현지화/영지(領地)화 → 의도 기반 접근(ABAC) → 익명화/가명화”로 구현한다.
> - **실습**에서는 간단한 **DPIA(개인정보 영향평가) 관점**의 정책 점검 체크리스트/자동화 스크립트를 제공한다.

---

## 개인정보/로그 보존·마스킹 정책

### 데이터 등급 분류(예시 라벨)

- **Public**: 공개 가능 (문서, 공시 자료)
- **Internal**: 사내 한정(민감정보 없음)
- **Confidential**: 식별자(이메일/전화/IP+시간 등), 행동 로그
- **Restricted**: **PII/민감정보**(주민번호/여권/결제수단/건강정보 등)
→ 등급마다 **보존 기간**, **암호화 강도**, **접근 통제**, **전송 제한**이 다르다.

**라벨 메타데이터(데이터 팩토리/ETL 공통 헤더 예)**
```json
{
  "data_class":"Restricted",
  "pii_fields":["email","phone","ip","session_id"],
  "purpose":"fraud_detection",
  "retention_days":90,
  "owner":"security@corp",
  "lawful_basis":"consent",
  "masking":"tokenize(email), hash(ip), redact(session_id)"
}
```

### 보존 정책(샘플 규칙)

- **운영 로그(네트워크/웹)**: 원본 7~30일(고정 IP 환경 7일을 권장), 집계·익명화본 1~12개월
- **애플리케이션 감사 로그**: 90~180일, 접근 사유 필수 기록
- **결제/세금 관련**: 법정 보존(예: 5~10년) – 단 **식별자는 가명화**
- **백업**: 운영 보존과 분리 관리(암호화+키 분리), 장기 보존의 **PII 포함 여부 재검토**

**S3/오브젝트 스토리지 라이프사이클 (예)**
```json
{
  "Rules": [{
    "ID": "raw-logs-retention",
    "Filter": {"Prefix": "logs/raw/"},
    "Status": "Enabled",
    "Expiration": {"Days": 14},
    "AbortIncompleteMultipartUpload": {"DaysAfterInitiation": 7}
  },{
    "ID": "anon-logs-archive",
    "Filter": {"Prefix": "logs/anon/"},
    "Status": "Enabled",
    "Transition": [{"Days": 30, "StorageClass": "STANDARD_IA"}],
    "Expiration": {"Days": 365}
  }]
}
```

### 마스킹/가명화/익명화 기법

- **마스킹(redact)**: UI/로그 상 노출 제거. 예) `user@example.com` → `u***@e*****.com`
- **가명화(tokenization)**: **복원 가능**한 치환(토큰→원문 매핑은 별도 보관/HSM)
- **익명화(hash+salt/pepper)**: 복원 불가. **동일인 식별(집계 목적)**은 가능하도록 **일관된 해시** 사용
- **부분 마스킹**: 국가별 표준 반영(전화/주소/신분).
- **FP/비식별화 주의**: 단독으로 익명이더라도 **조합**으로 재식별 가능 → **K-익명성/ℓ-다양성** 기준 검토.

**로그 마스킹 파이썬 예제(정규식 기반)**
```python
import re, hashlib, hmac, os

EMAIL = re.compile(r'([a-zA-Z0-9._%+-]{1})[a-zA-Z0-9._%+-]*(@[a-zA-Z0-9.-]+\.[A-Za-z]{2,})')
PHONE = re.compile(r'(\+?\d{1,3})[-\s.]?(\d{2,4})[-\s.]?(\d{3,4})[-\s.]?(\d{4})')
IPV4 = re.compile(r'\b(\d{1,3}\.){3}\d{1,3}\b')

PEPPER = os.environ.get("LOG_PEPPER","fixedPepperForDemo")  # 운영에선 HSM/성공적으로 로테이션

def mask_email(s):
    return EMAIL.sub(lambda m: m.group(1)+"***"+m.group(2), s)

def hash_ip(s):
    def repl(m):
        digest = hmac.new(PEPPER.encode(), m.group(0).encode(), hashlib.sha256).hexdigest()[:12]
        return f"iphash:{digest}"
    return IPV4.sub(repl, s)

def mask_phone(s):
    return PHONE.sub(lambda m: f"{m.group(1)}-{m.group(2)}-***-{m.group(4)}", s)

def sanitize_line(line):
    for fn in (mask_email, mask_phone, hash_ip):
        line = fn(line)
    return line

if __name__ == "__main__":
    sample = "user john.doe@corp.com called +82 10 1234 5678 from 203.0.113.10"
    print(sanitize_line(sample))
```

**API 응답 필드 단위 마스킹(Gateway Lua)**
```lua
-- role별로 PII 필드 제거/치환
local function scrub(user_role, body)
  if user_role ~= "auditor" then
    body["email"] = string.gsub(body["email"] or "", ".*@", "***@")
    body["phone"] = "***-****-****"
  end
  body["ip"] = nil  -- 네트워크 로그에서만 보관
  return body
end
```

### 스키마 수준 정책(DDL/뷰/권한)

- **원본 테이블**엔 민감 필드 저장 금지. **가명 테이블**과 **매핑 테이블**을 분리, 키는 KMS 보호.
- **뷰/머티리얼라이즈드 뷰**로 업무별 최소필드만 제공, **Row/Column-Level Security**로 권한 분리.

**PostgreSQL 컬럼 권한 + 뷰 예시**
```sql
CREATE TABLE users(
  id BIGSERIAL PRIMARY KEY,
  email TEXT, phone TEXT, ip INET, created_at TIMESTAMPTZ
);

-- 업무용 가명 뷰(PII 제거)
CREATE VIEW v_users_analytics AS
SELECT id,
       regexp_replace(email,'^(.).+(@.+)$','\1***\2') AS email_masked,
       date_trunc('day', created_at) AS created_day
FROM users;

REVOKE ALL ON users FROM analyst;
GRANT SELECT ON v_users_analytics TO analyst;
```

---

## 전송·휴지 암호화와 키 관리

### 전송 암호화(TLS/mTLS)

- **외부/내부 모두 TLS**(TLS 1.2+ 권장, 1.3 가급적)
- **클라이언트 인증서(mTLS)**: **관리/운영 접속**, **서비스-투-서비스** 경로
- **HSTS/OCSP Stapling**: 다운그레이드/유효성 문제 방지
- **암호스위트 정책**: PFS(ECDHE), AEAD(AES-GCM/ChaCha20-Poly1305)

**Nginx 서버 설정(핵심)**
```nginx
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers   HIGH:!aNULL:!MD5:!RC4;
ssl_prefer_server_ciphers on;
ssl_session_tickets off;

# 내부 구간 mTLS (필요 경로에만)

ssl_client_certificate /etc/ssl/ca.pem;
ssl_verify_client optional;
```

### 휴지 암호화(At-Rest)

- **디스크/블록 암호화**(OS/Cloud KMS) + **DB/오브젝트 레벨 암호화** 동시 고려
- **어플리케이션 레벨 암호화(AE)**: 민감 필드는 앱에서 암호화 후 저장(키는 KMS/HSM)
- **백업/스냅샷**: 동일 정책, 키 분리 보관

**애플리케이션 레벨 암호화(Python; Fernet 예)**
```python
from cryptography.fernet import Fernet
# 키는 KMS에서 받아오는 것으로 가정

FERNET_KEY = Fernet.generate_key()
f = Fernet(FERNET_KEY)

def encrypt_field(plain: bytes) -> bytes:
    return f.encrypt(plain)

def decrypt_field(ct: bytes) -> bytes:
    return f.decrypt(ct)
```

### 키 관리(KMS/HSM/권한 분리)

- **루트키(HSM)** → **데이터키(KMS)** → **필드키(앱)** 계층 분리
- **권한 분리**: **키 관리자**와 **데이터 접근자**가 동일인이 되지 않도록
- **키 회전**: 주기적 회전 + 과거 데이터 복호화 지원(키 버전 관리)
- **감사 로그**: 키 사용 이력/누가/언제/어디서

**키 랩핑(개념)**
```
HSM RootKey(KR) → wrap(KD)  # KD: KMS 데이터키
KD → wrap(KF_email), wrap(KF_phone)  # 필드별 키
ciphertext = AEAD_Encrypt(KF_email, email, AAD=context)
```

**KMS 정책(예: JSON)**
```json
{
  "Version":"2012-10-17",
  "Statement":[{
    "Sid":"AllowAppUseOnly",
    "Effect":"Allow",
    "Principal":{"AWS":"arn:aws:iam::123:role/app-svc"},
    "Action":[ "kms:Encrypt", "kms:Decrypt", "kms:GenerateDataKey" ],
    "Resource":"*",
    "Condition":{"ForAnyValue:StringEquals":{"kms:EncryptionContext:purpose":"pii_field"}}
  }]
}
```

---

## 네트워크 로그의 개인정보 최소화

### 수집 최소화 전략

- **수집 전 설계**: “이 필드 없이도 운영/보안 목적 달성 가능한가?”
- **IP+타임+UA 조합**은 사실상 개인 식별에 준할 수 있음 → **해시/격자화**(예: `/24` 단위)
- **쿼리스트링/헤더**에 PII가 섞이지 않도록 **프런트에서 차단**(입력 유효성/인코딩)

**리버스 프록시 단계 PII 스트리퍼(예: Nginx map)**
```nginx
map $arg_email $qs_email { default ""; ~.+ "***"; }
map $http_authorization $auth { default "redacted"; ~.+ "redacted"; }

log_format netjson escape=json '{ "ts":"$time_iso8601","path":"$uri","qs_email":"$qs_email","auth":"$auth","ip":"$remote_addr" }';
access_log /var/log/nginx/net.json netjson;
```

### 현지화/영지화(Data Residency)

- 로그 저장 **리전 제한**: 국외 반출 금지/계약상 요구 시 **익명화 후만 전송**
- **라우팅/전송 경로**: cross-region 전송 금지, 필요 시 **프록시+암호화+mTLS**로 한정

### & 목적 제한

- **목적(Purpose) 기반 스코프**: “보안 운영”, “성능 분석”, “결함 조사” 등으로 **읽기 권한 분리**
- **세션 녹취/쿼리 기록**: 누가 어떤 목적/티켓으로 어떤 로그를 봤는지 **감사**

**OPA(Rego) – 로그 읽기 권한 예**
```rego
package log.read
default allow=false

allow {
  input.user.role == "soc_analyst"
  input.purpose == "security_ops"
  not contains_pii(input.fields)
}

contains_pii(fields) {
  some f
  f := fields[_]
  f == "email"  # 필드 화이트리스트를 반대로 운영해도 좋다
}
```

### 익명화 파이프라인(Fluent Bit → Processor)

**Fluent Bit 필터 예(정규식 마스킹)**
```ini
[FILTER]
    Name    modify
    Match   net.**
    Rename  user_email  pii_email
[FILTER]
    Name    rewrite_tag
    Match   net.**
    Rule    $pii_email ^(.*)$  net_anon false
```

**Kafka Streams(개념) – PII 필드 제거**
```java
// pseudocode
stream.mapValues(v -> {
  v.remove("email");
  v.put("ip", hash(v.get("ip")));
  return v;
}).to("logs_anon");
```

---

## 실습: DPIA 관점 정책 점검

> **DPIA(Data Protection Impact Assessment)**는 “처리 활동이 개인에게 줄 수 있는 위험”을 평가해
> **회피/경감 조치**를 문서화하는 절차다. 여기서는 간단한 **체크리스트+자동 스코어** 도구를 제공한다.

### DPIA 체크리스트(요약 폼)

| 항목 | 질문 | 점수(0~2) | 비고 |
|---|---|---|---|
| 목적 명확성 | 처리 목적이 구체/측정 가능? | 0/1/2 | |
| 최소 수집 | PII 필드를 줄였는가? | 0/1/2 | |
| 보존 기한 | 목적과 법규에 맞는가? | 0/1/2 | |
| 암호화 | 전송/휴지 암호화 적용/키 분리? | 0/1/2 | |
| 접근 통제 | ABAC/목적 기반 접근? | 0/1/2 | |
| 로그 마스킹 | 수집 지점에서 마스킹/가명화? | 0/1/2 | |
| 권리 보장 | 열람/정정/삭제 대응 프로세스? | 0/1/2 | |
| 국외 이전 | 필요 시 익명화/계약/보호대책? | 0/1/2 | |
| 벤더 관리 | DPA/서브프로세서 점검? | 0/1/2 | |
| 침해 대응 | 탐지/통지/포렌식 계획? | 0/1/2 | |

- **0~7**: **High Risk** (즉시 개선 필요)
- **8~14**: **Medium** (단기 개선 계획 필요)
- **15~20**: **Low** (유지+정기 리뷰)

### DPIA 스코어러(Python CLI)

```python
# dpia_check.py

questions = [
 ("목적 명확성", "처리 목적이 구체/측정 가능합니까?"),
 ("최소 수집", "필요 최소한의 PII만 수집합니까?"),
 ("보존 기한", "명시된 보존 기한을 준수합니까?"),
 ("암호화", "전송/휴지 암호화와 키 분리가 적용되었습니까?"),
 ("접근 통제", "목적 기반 ABAC가 적용되었습니까?"),
 ("로그 마스킹", "수집 지점에서 마스킹/가명화합니까?"),
 ("권리 보장", "열람/정정/삭제 요청에 대응합니까?"),
 ("국외 이전", "국외 이전 시 보호대책/계약이 있습니까?"),
 ("벤더 관리", "DPA/서브프로세서 점검이 있습니까?"),
 ("침해 대응", "탐지/통지/포렌식 계획이 있습니까?")
]

def ask():
    total=0; answers=[]
    for k,q in questions:
        while True:
            try:
                s=int(input(f"[0~2] {k} - {q} : "))
                if s in (0,1,2): break
            except: pass
        answers.append((k,s)); total+=s
    return total,answers

if __name__=="__main__":
    total,ans=ask()
    print("\n=== DPIA 결과 ===")
    for k,s in ans: print(f"{k}: {s}")
    print("총점:", total)
    if total<=7: lvl="HIGH"
    elif total<=14: lvl="MEDIUM"
    else: lvl="LOW"
    print("위험도:", lvl)
```

### 정책 자동 점검(샘플 규칙 파일 → 리포트)

**정책 선언(YAML; 수집/보존/암호화/접근)**
```yaml
dataset: "net_access_logs"
purpose: "security_ops"
pii_fields: ["ip","email","user_agent"]
collection:
  allow_ip: "hash"         # 원문 금지, 해시만
  allow_email: "tokenize"  # 토큰화만 허용
  allow_user_agent: "raw"  # UA는 원문 가능
retention:
  raw_days: 14
  anon_days: 365
encryption:
  in_transit: "tls13"
  at_rest: "kms:aes256"
access:
  purpose_scoped: true
  abac: true
  audit_log: true
```

**검사기(Python)**
```python
import yaml, sys

REQ = {
  "ip": "hash",
  "email": "tokenize"
}

def check(policy):
    issues=[]
    pf = set(policy.get("pii_fields",[]))
    if "ip" in pf and policy["collection"].get("allow_ip") != "hash":
        issues.append("IP는 해시만 허용")
    if "email" in pf and policy["collection"].get("allow_email") not in ("tokenize","redact"):
        issues.append("Email은 토큰화/마스킹 필요")
    if policy["retention"]["raw_days"]>30:
        issues.append("원본 보존 30일 초과")
    if not policy["encryption"]["in_transit"].startswith("tls"):
        issues.append("전송 암호화 미흡")
    if "kms" not in policy["encryption"]["at_rest"]:
        issues.append("휴지 암호화 KMS 미사용")
    for k in ("purpose_scoped","abac","audit_log"):
        if not policy["access"].get(k,False):
            issues.append(f"접근 통제 항목 누락: {k}")
    return issues

if __name__=="__main__":
    pol = yaml.safe_load(sys.stdin.read())
    issues = check(pol)
    if issues:
        print("[DPIA] 불일치/개선 권고:")
        for i in issues: print("-", i)
    else:
        print("[DPIA] 정책 합치 (요건 충족)")
```

**실행 예**
```bash
python3 check.py < policy.yaml
# 또는 개선 항목 목록

```

### 개선 우선순위 로드맵(예시)

1) **수집단 억제**: 프록시·에이전트에서 PII 차단/마스킹을 **선수집지점**으로 이동
2) **키·권한 분리**: KMS/HSM 도입 및 키 관리자/데이터 접근자 분리
3) **보존 단축**: 원본 7~14일, 익명 집계본 장기 보존으로 대체
4) **목적 기반 접근**: OPA/게이트웨이와 연동해 읽기 목적·시간제한·티켓 링크 필수화
5) **감사/회귀 테스트**: 샘플 로그에 마스킹/보존 정책 회귀 테스트(“골든 로그”)

---

## 요약

- **데이터 등급·보존·마스킹**을 “정책으로 코드화”하여 **수집 지점**에서 강제하라.
- **전송·휴지 암호화**는 **mTLS + AEAD + KMS/HSM + 키 분리·회전**이 핵심이다.
- **네트워크 로그**는 **최소 수집**과 **익명화/가명화**가 기본, 접근은 **목적 기반**으로 제한하고 **감사**를 남겨라.
- **DPIA 실습**을 통해 정책 격차를 **정량화**하고, 우선순위 로드맵으로 개선을 추진하라.
