---
layout: post
title: 파이썬 - for 문
date: 2024-08-06 19:20:23 +0900
category: Python
---
# 파이썬 for 문: 반복의 기술

파이썬에서 `for` 문은 시퀀스나 이터러블 객체의 각 요소를 순회하며 코드를 반복 실행하는 핵심 제어 구조입니다. 다른 언어의 `for` 문과 달리, 파이썬의 `for` 문은 "범위 기반 반복"이 아닌 "이터러블 기반 반복"으로 설계되어 더 추상적이고 유연합니다.

## 기본 구조와 사용법

`for` 문의 기본 구조는 간단하면서도 강력합니다:

```python
for 변수 in 이터러블:
    실행할_코드_블록
```

- **변수**: 각 반복마다 이터러블에서 꺼낸 요소가 할당되는 이름
- **이터러블**: 순회 가능한 객체로, 리스트, 튜플, 문자열, 딕셔너리, 집합, 파일 객체 등이 포함됩니다

### 다양한 이터러블 순회 예제

**리스트 순회:**
```python
fruits = ['apple', 'banana', 'cherry']
for fruit in fruits:
    print(fruit)
# 출력: apple / banana / cherry
```

**문자열 순회 (문자 단위):**
```python
message = "Hello"
for char in message:
    print(char)
# 출력: H / e / l / l / o
```

**range 함수를 이용한 숫자 범위 순회:**
```python
# 0부터 4까지 (5는 포함되지 않음)
for i in range(5):
    print(i)
# 출력: 0 / 1 / 2 / 3 / 4

# 시작값, 종료값, 간격 지정
for i in range(1, 10, 2):
    print(i)
# 출력: 1 / 3 / 5 / 7 / 9

# 역순 순회
for i in range(5, 0, -1):
    print(i)
# 출력: 5 / 4 / 3 / 2 / 1
```

> **`range()` 함수의 특징**: `range()`는 실제로 모든 값을 메모리에 저장하지 않는 지연 평가(lazy evaluation) 시퀀스를 생성합니다. 이로 인해 아주 큰 범위(예: `range(1000000)`)를 다룰 때도 메모리 효율이 뛰어납니다.

**딕셔너리 순회:**
```python
person = {"name": "Alice", "age": 25, "city": "Seoul"}

# 키만 순회
for key in person:
    print(key, person[key])
# 출력: name Alice / age 25 / city Seoul

# 키와 값 함께 순회
for key, value in person.items():
    print(f"{key}: {value}")
# 출력: name: Alice / age: 25 / city: Seoul

# 값만 순회
for value in person.values():
    print(value)
# 출력: Alice / 25 / Seoul
```

**중첩된 구조 순회:**
```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# 2차원 리스트 순회
for row in matrix:
    for element in row:
        print(element, end=' ')
    print()  # 줄바꿈
# 출력: 1 2 3 / 4 5 6 / 7 8 9
```

---

## for 문의 동작 원리: 이터러블과 이터레이터 프로토콜

파이썬의 `for` 문이 작동하는 방식은 **이터러블(Iterable)**과 **이터레이터(Iterator)** 프로토콜에 기반합니다. 이 추상화 덕분에 `for` 문은 다양한 데이터 소스(리스트, 파일, 네트워크 스트림, 데이터베이스 커서 등)와 일관된 방식으로 동작할 수 있습니다.

### 이터러블과 이터레이터의 관계

1. **이터러블(Iterable)**: `__iter__()` 메서드를 구현한 객체. `iter()` 함수에 전달될 수 있습니다.
2. **이터레이터(Iterator)**: `__next__()` 메서드를 구현한 객체. 다음 값을 반환하고, 더 이상 값이 없을 때 `StopIteration` 예외를 발생시킵니다.

`for` 문의 내부 동작:
```python
# 다음 코드는 실제 for 문이 작동하는 방식과 동일합니다
iterable = [1, 2, 3]
iterator = iter(iterable)  # iter()는 __iter__()를 호출

while True:
    try:
        item = next(iterator)  # next()는 __next__()를 호출
        print(item)
    except StopIteration:
        break
```

### 커스텀 이터러블 클래스 만들기

이터러블 프로토콜을 이해하면 사용자 정의 객체도 `for` 문에서 사용할 수 있습니다:

```python
class Countdown:
    """카운트다운을 위한 이터러블 클래스"""
    def __init__(self, start):
        self.start = start
    
    def __iter__(self):
        self.current = self.start
        return self  # 자기 자신이 이터레이터 역할도 합니다
    
    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        value = self.current
        self.current -= 1
        return value

# 사용 예시
for number in Countdown(5):
    print(number)
# 출력: 5 / 4 / 3 / 2 / 1
```

이 모델의 강력함은 파일 읽기, 네트워크 스트림 처리, 데이터베이스 결과 순회 등 다양한 컨텍스트에서 일관된 인터페이스를 제공한다는 점입니다.

---

## 실무에서 자주 사용하는 핵심 도구들

### enumerate(): 인덱스와 값을 함께 얻기

리스트를 순회할 때 인덱스가 필요할 때마다 `range(len(리스트))`를 사용하는 것은 파이썬스럽지 않습니다. 대신 `enumerate()`를 사용하세요:

```python
fruits = ['apple', 'banana', 'cherry']

# 비추천 방식
for i in range(len(fruits)):
    print(i, fruits[i])

# 파이썬스러운 방식
for i, fruit in enumerate(fruits):
    print(i, fruit)
# 출력: 0 apple / 1 banana / 2 cherry

# 시작 인덱스 지정 가능
for i, fruit in enumerate(fruits, start=1):
    print(f"{i}번째 과일: {fruit}")
# 출력: 1번째 과일: apple / 2번째 과일: banana / 3번째 과일: cherry
```

### zip(): 여러 시퀀스를 병렬로 순회하기

두 개 이상의 리스트를 동시에 순회해야 할 때 `zip()` 함수가 유용합니다:

```python
names = ['Alice', 'Bob', 'Charlie']
scores = [85, 92, 78]

for name, score in zip(names, scores):
    print(f"{name}: {score}점")
# 출력: Alice: 85점 / Bob: 92점 / Charlie: 78점

# 세 개 이상의 시퀀스도 가능
ids = [101, 102, 103]
for id, name, score in zip(ids, names, scores):
    print(f"ID {id}: {name} - {score}점")
```

**길이가 다른 시퀀스 처리:**
```python
# 기본적으로 짧은 시퀀스에 맞춰 중단
list1 = [1, 2, 3, 4]
list2 = ['a', 'b']
for a, b in zip(list1, list2):
    print(a, b)
# 출력: 1 a / 2 b

# Python 3.10+: strict 모드로 길이 불일치 시 예외 발생
# for a, b in zip(list1, list2, strict=True):
#     print(a, b)  # ValueError (길이 다름)

# itertools.zip_longest를 사용해 부족한 부분 채우기
from itertools import zip_longest
for a, b in zip_longest(list1, list2, fillvalue='없음'):
    print(a, b)
# 출력: 1 a / 2 b / 3 없음 / 4 없음
```

### for-else: 반복문의 특별한 종료 조건

`for` 문에는 `else` 절을 추가할 수 있습니다. 이 `else` 블록은 **반복이 정상적으로 완료되었을 때**(즉, `break`로 중단되지 않았을 때) 실행됩니다:

```python
# 소수 판별 예제
def is_prime(n):
    if n < 2:
        return False
    
    for divisor in range(2, int(n ** 0.5) + 1):
        if n % divisor == 0:
            print(f"{n}은(는) {divisor}로 나누어 떨어집니다")
            break
    else:
        # break가 실행되지 않았으면 소수
        return True
    
    return False

# 테스트
print(is_prime(17))  # True
print(is_prime(15))  # False (3으로 나누어 떨어집니다)
```

> **주의**: `for-else`에서 `else`는 `break`에 의해 반복이 중단되지 않았을 때만 실행됩니다. `continue`는 `else` 실행에 영향을 주지 않습니다. 이 구문은 "요소 검색" 패턴에서 유용하게 사용됩니다.

---

## 반복문 제어: break, continue, pass

### break: 반복 즉시 종료

```python
# 숫자 5를 만나면 반복 종료
for number in range(10):
    if number == 5:
        print("5를 만났습니다. 반복을 종료합니다.")
        break
    print(number)
# 출력: 0 / 1 / 2 / 3 / 4 / "5를 만났습니다. 반복을 종료합니다."
```

### continue: 현재 반복 건너뛰기

```python
# 짝수만 출력
for number in range(10):
    if number % 2 != 0:  # 홀수면 건너뛰기
        continue
    print(number)
# 출력: 0 / 2 / 4 / 6 / 8
```

### pass: 아무 작업도 하지 않음 (자리 표시자)

```python
# 구현은 나중에 하고 구조만 잡아둘 때
for item in collection:
    if condition:
        pass  # TODO: 나중에 구현
    else:
        process(item)
```

---

## 컴프리헨션(Comprehension): 간결한 변환과 필터링

컴프리헨션은 `for` 문을 사용해 새로운 컬렉션을 생성하는 간결한 구문입니다. 리스트, 딕셔너리, 집합 모두 컴프리헨션을 지원합니다.

### 리스트 컴프리헨션

```python
# 기본 형태: [표현식 for 항목 in 이터러블]
numbers = [1, 2, 3, 4, 5]
squares = [n * n for n in numbers]
print(squares)  # [1, 4, 9, 16, 25]

# 조건문 포함: [표현식 for 항목 in 이터러블 if 조건]
evens = [n for n in numbers if n % 2 == 0]
print(evens)  # [2, 4]

# 중첩 컴프리헨션
matrix = [[1, 2], [3, 4], [5, 6]]
flat = [element for row in matrix for element in row]
print(flat)  # [1, 2, 3, 4, 5, 6]

# 조건부 표현식 포함
numbers = [-3, -2, -1, 0, 1, 2, 3]
abs_values = [x if x >= 0 else -x for x in numbers]
print(abs_values)  # [3, 2, 1, 0, 1, 2, 3]
```

### 딕셔너리 컴프리헨션

```python
# {키표현식: 값표현식 for 항목 in 이터러블}
numbers = [1, 2, 3, 4, 5]
square_dict = {n: n*n for n in numbers}
print(square_dict)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# 조건문 포함
even_squares = {n: n*n for n in numbers if n % 2 == 0}
print(even_squares)  # {2: 4, 4: 16}

# 두 리스트로부터 딕셔너리 생성
keys = ['name', 'age', 'city']
values = ['Alice', 25, 'Seoul']
person = {k: v for k, v in zip(keys, values)}
print(person)  # {'name': 'Alice', 'age': 25, 'city': 'Seoul'}
```

### 집합 컴프리헨션

```python
# {표현식 for 항목 in 이터러블}
numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
unique_squares = {n*n for n in numbers}  # 중복 자동 제거
print(unique_squares)  # {16, 1, 4, 9}
```

### 제너레이터 표현식: 메모리 효율적인 대안

대규모 데이터를 처리할 때는 메모리 효율을 위해 제너레이터 표현식을 사용할 수 있습니다:

```python
# 리스트 컴프리헨션 (모든 결과를 메모리에 저장)
big_list = [x * x for x in range(1000000)]  # 모든 제곱값 저장

# 제너레이터 표현식 (필요할 때마다 생성)
big_gen = (x * x for x in range(1000000))  # 값 생성기

# 제너레이터 사용
for value in big_gen:
    if value > 100:
        break
    print(value)
```

> **메모리 비교**: 제너레이터 표현식은 전체 결과를 한 번에 메모리에 저장하지 않으므로 아주 큰 데이터셋을 처리할 때 유용합니다.

---

## 언패킹(Unpacking)과 for 문

### 시퀀스 언패킹

```python
# 리스트나 튜플의 요소를 개별 변수에 할당
point = (10, 20)
x, y = point
print(f"x: {x}, y: {y}")  # x: 10, y: 20

# 확장 언패킹 (Extended Unpacking)
numbers = [1, 2, 3, 4, 5]
first, *middle, last = numbers
print(f"첫번째: {first}, 중간: {middle}, 마지막: {last}")
# 출력: 첫번째: 1, 중간: [2, 3, 4], 마지막: 5

# for 문에서 튜플 언패킹
students = [('Alice', 85), ('Bob', 92), ('Charlie', 78)]
for name, score in students:
    print(f"{name}: {score}점")
```

### 가변 인자 언패킹 (* 연산자)

```python
# 함수 호출 시 언패킹
def add_three(a, b, c):
    return a + b + c

numbers = [1, 2, 3]
result = add_three(*numbers)  # 리스트 언패킹
print(result)  # 6

# 컬렉션 병합
list1 = [1, 2, 3]
list2 = [4, 5, 6]
merged = [*list1, *list2, 7, 8]
print(merged)  # [1, 2, 3, 4, 5, 6, 7, 8]

# 딕셔너리 병합 (** 연산자)
dict1 = {'x': 1, 'y': 2}
dict2 = {'z': 3, 'w': 4}
combined = {**dict1, **dict2, 'extra': 5}
print(combined)  # {'x': 1, 'y': 2, 'z': 3, 'w': 4, 'extra': 5}
```

---

## 실전 패턴과 모범 사례

### 1. 안전한 순회: 순회 중 컬렉션 수정 피하기

반복 중인 컬렉션을 직접 수정하는 것은 위험할 수 있습니다:

```python
# 위험한 예: 리스트 순회 중 요소 삭제
numbers = [1, 2, 3, 4, 5, 6]
# for num in numbers:
#     if num % 2 == 0:
#         numbers.remove(num)  # 예상치 못한 결과 발생 가능

# 안전한 방법 1: 새 리스트 생성
numbers = [1, 2, 3, 4, 5, 6]
filtered = [num for num in numbers if num % 2 != 0]
print(filtered)  # [1, 3, 5]

# 안전한 방법 2: 복사본 순회
numbers = [1, 2, 3, 4, 5, 6]
for num in numbers[:]:  # 슬라이스로 복사본 생성
    if num % 2 == 0:
        numbers.remove(num)
print(numbers)  # [1, 3, 5]
```

### 2. 성능 최적화 팁

```python
# 반복문 내에서 반복적으로 호출하는 함수나 메서드는 지역 변수에 할당
data = []
append_method = data.append  # 메서드를 지역 변수에 할당

for i in range(10000):
    append_method(i)  # data.append(i)보다 약간 빠름

# 루프 불변 코드(Loop-invariant code) 밖으로 빼기
# 비효율적
for item in large_collection:
    result = complex_calculation() * item  # 매 반복마다 complex_calculation() 호출

# 효율적
constant_value = complex_calculation()  # 한 번만 계산
for item in large_collection:
    result = constant_value * item
```

### 3. 파일 처리와 for 문

파일 객체는 이터러블이므로 `for` 문과 자연스럽게 함께 사용할 수 있습니다:

```python
# 파일 전체를 메모리에 로드하지 않고 한 줄씩 처리
with open('large_file.txt', 'r', encoding='utf-8') as file:
    for line_number, line in enumerate(file, start=1):
        line = line.rstrip('\n')  # 줄바꿈 문자 제거
        if line:  # 빈 줄 건너뛰기
            print(f"{line_number}: {line}")
```

### 4. itertools 모듈 활용

복잡한 반복 패턴은 `itertools` 모듈을 사용하면 더 간결하게 표현할 수 있습니다:

```python
from itertools import chain, cycle, islice, permutations, combinations

# 여러 이터러블 연결
list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']
for item in chain(list1, list2):
    print(item)  # 1, 2, 3, 'a', 'b', 'c'

# 제한된 수의 요소만 처리
large_range = range(1000000)
for num in islice(large_range, 10):  # 처음 10개만
    print(num)

# 순열과 조합
items = ['A', 'B', 'C']
print("조합 (2개씩):", list(combinations(items, 2)))
# 출력: [('A', 'B'), ('A', 'C'), ('B', 'C')]

print("순열 (2개씩):", list(permutations(items, 2)))
# 출력: [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]
```

---

## 고급 활용: 센티넬 기반 반복

`iter()` 함수의 두 번째 형태를 사용하면 특정 값(센티넬)이 나타날 때까지 반복을 수행할 수 있습니다:

```python
# 파일을 청크(chunk) 단위로 읽기
from functools import partial

def read_file_in_chunks(filename, chunk_size=1024):
    """파일을 청크 단위로 읽는 제너레이터"""
    with open(filename, 'rb') as file:
        # b'' (빈 바이트)가 나올 때까지 반복
        for chunk in iter(partial(file.read, chunk_size), b''):
            yield chunk

# 사용 예시
for chunk in read_file_in_chunks('large_file.bin', chunk_size=4096):
    process_chunk(chunk)

# 사용자 입력 처리 (빈 문자열 입력 시 종료)
print("메시지를 입력하세요 (종료하려면 빈 줄 입력):")
for line in iter(input, ""):
    print(f"입력받은 내용: {line}")
print("입력 종료")
```

---

## 종합 실전 예제

### 데이터 처리 파이프라인

```python
# 로그 파일 분석 예제
def analyze_log_file(filename):
    """로그 파일을 분석하여 IP별 접속 횟수 계산"""
    ip_counts = {}
    
    with open(filename, 'r', encoding='utf-8') as log_file:
        for line_number, line in enumerate(log_file, start=1):
            line = line.strip()
            if not line or line.startswith('#'):
                continue  # 빈 줄이나 주석 건너뛰기
            
            try:
                # 간단한 파싱 (실제로는 더 정교한 파싱 필요)
                parts = line.split()
                if len(parts) >= 1:
                    ip_address = parts[0]
                    ip_counts[ip_address] = ip_counts.get(ip_address, 0) + 1
            except (IndexError, ValueError) as e:
                print(f"라인 {line_number} 파싱 오류: {e}")
    
    # 결과 정렬 및 출력
    print("IP 주소별 접속 횟수:")
    for ip, count in sorted(ip_counts.items(), key=lambda x: x[1], reverse=True):
        print(f"  {ip}: {count}회")
    
    return ip_counts

# 매트릭스 연산
def matrix_transpose(matrix):
    """2차원 리스트의 전치 행렬 반환"""
    # zip(*matrix)를 활용한 우아한 구현
    return [list(row) for row in zip(*matrix)]

# 사용 예시
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
transposed = matrix_transpose(matrix)
print("원본 행렬:", matrix)
print("전치 행렬:", transposed)
```

### 에라토스테네스의 체 구현

```python
def sieve_of_eratosthenes(limit):
    """에라토스테네스의 체를 사용한 소수 찾기"""
    if limit < 2:
        return []
    
    # 처음에는 모든 수를 소수로 가정 (0과 1 제외)
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    
    # 체 알고리즘 적용
    for number in range(2, int(limit ** 0.5) + 1):
        if is_prime[number]:
            # number의 배수들은 모두 소수가 아님
            for multiple in range(number * number, limit + 1, number):
                is_prime[multiple] = False
    
    # 소수만 추출
    primes = [number for number in range(2, limit + 1) if is_prime[number]]
    return primes

# 사용 예시
primes_up_to_100 = sieve_of_eratosthenes(100)
print(f"100 이하의 소수 ({len(primes_up_to_100)}개):")
print(primes_up_to_100)
```

---

## 결론

파이썬의 `for` 문은 단순한 반복 구조를 넘어서, 파이썬의 "이터러블 프로토콜"이라는 강력한 추상화 위에 구축된 핵심 기능입니다. 이 설계 덕분에 `for` 문은 리스트, 문자열, 파일, 네트워크 스트림, 데이터베이스 결과셋 등 다양한 데이터 소스와 일관된 방식으로 동작할 수 있습니다.

효율적인 `for` 문 사용을 위한 핵심 원칙은 다음과 같습니다:

1. **파이썬스러운 순회**: `range(len(리스트))` 대신 `enumerate()`를, 여러 리스트 동시 순회에는 `zip()`을 사용하세요.
2. **적절한 도구 선택**: 간단한 변환과 필터링에는 컴프리헨션을, 대규모 데이터 처리에는 제너레이터 표현식을 고려하세요.
3. **안전한 코드 작성**: 반복 중인 컬렉션을 직접 수정하지 말고, 필요하다면 복사본을 만들거나 새 컬렉션을 생성하세요.
4. **성능 고려**: 반복문 내에서 불필요한 계산이나 메서드 호출을 반복하지 않도록 주의하세요.
5. **모듈 활용**: 복잡한 반복 패턴은 `itertools` 모듈의 함수들을 활용해 간결하게 표현하세요.

`for` 문은 파이썬 프로그래밍의 근간을 이루는 구조 중 하나로, 그 유연성과 표현력은 파이썬 코드를 간결하고 읽기 쉽게 만드는 데 기여합니다. 이터러블 프로토콜에 대한 이해를 바탕으로 `for` 문을 효과적으로 활용하면, 데이터 처리부터 알고리즘 구현까지 다양한 문제를 우아하게 해결할 수 있습니다.