---
layout: post
title: 파이썬 - for 문
date: 2024-08-06 19:20:23 +0900
category: Python
---
# for 문

## 기본 문법과 개념

```python
for 변수 in 이터러블:
    실행할_코드
```

- **변수**: 각 반복마다 이터러블에서 꺼낸 **원소**를 바인딩합니다.
- **이터러블(iterable)**: `list`, `tuple`, `str`, `dict`, `set`, `range`, **파일 객체**, **사용자 정의 이터러블** 등 **반복 가능한** 모든 것.

### 리스트 순회

```python
numbers = [1, 2, 3, 4, 5]
for n in numbers:
    print(n)
# 5

```

### 문자열 순회

```python
word = "hello"
for ch in word:
    print(ch)
# h e l l o

```

### range 순회

```python
for i in range(5):
    print(i)
# 4

# range(start, stop, step)

for i in range(1, 10, 2):
    print(i)
# 9

```

> `range`는 **지연 시퀀스**(메모리를 거의 쓰지 않음). 음수 step, 큰 구간도 효율적.

### 딕셔너리 순회

```python
person = {"name": "Alice", "age": 25}
for key in person:                # == for key in person.keys():
    print(key, person[key])

for key, value in person.items(): # 키-값 동시
    print(key, value)
```

### 중첩 for

```python
matrix = [[1, 2], [3, 4]]
for row in matrix:
    for item in row:
        print(item)
# 4

```

---

## 이터러블과 이터레이터(프로토콜 이해)

- **이터러블**: `__iter__()`를 제공(혹은 `__getitem__`으로 0부터 인덱싱). `for`는 내부적으로 `iter(obj)`를 호출해 **이터레이터**를 얻습니다.
- **이터레이터**: `__next__()`로 다음 값을 돌려주고, 끝나면 `StopIteration` 예외를 던집니다.

```python
class Countdown:
    def __init__(self, n): self.n = n
    def __iter__(self): return self
    def __next__(self):
        if self.n <= 0:
            raise StopIteration
        self.n -= 1
        return self.n + 1

for x in Countdown(3):
    print(x)
# 1

```

> 이 모델 덕분에 **파일**, **네트워크 스트림**, **무한 시퀀스** 등과 자연스럽게 통합됩니다.

---

## `enumerate`, `zip`, `range` — 실전 3대장

### enumerate: 인덱스와 값 동시

```python
names = ["kim", "lee", "park"]
for i, name in enumerate(names, start=1):
    print(i, name)
# kim / 2 lee / 3 park

```

### zip: 여러 이터러블 병렬 순회

```python
xs = [1, 2, 3]
ys = [10, 20, 30]
for x, y in zip(xs, ys):
    print(x, y)
# / 2 20 / 3 30

```

- 파이썬 3.10+: `zip(..., strict=True)`로 길이 불일치 시 `ValueError` 발생
```python
zip(xs, ys, strict=True)  # 길이가 다르면 예외
```

### range: 반열린 구간(half-open)

```python
for i in range(10, 0, -2):
    print(i)
# 2

```

---

## for-else: **break 없이** 정상 종료 시 else 실행

```python
# 소수 판별: 나눠떨어지는 수 찾으면 break, 끝까지 못 찾으면 else

n = 17
for d in range(2, int(n**0.5) + 1):
    if n % d == 0:
        print("합성수")
        break
else:
    print("소수")  # break가 한 번도 호출되지 않은 경우에만 실행
```

> 흔히 오해되는 부분: **`break`가 실행되면 `else`는 건너뜁니다**. `continue`는 상관없습니다.

---

## 제어문: break / continue / pass

### break: 반복 즉시 중단

```python
for num in range(10):
    if num == 5:
        break
    print(num)
# 4

```

### continue: 현재 반복 건너뛰기

```python
for num in range(5):
    if num == 2:
        continue
    print(num)
# 4

```

### pass: 자리표시(문법상 필요하지만 할 일 없음)

```python
for _ in range(3):
    pass
```

---

## 컴프리헨션(Comprehension)

### 리스트 컴프리헨션

```python
numbers = [1, 2, 3, 4, 5]
squares = [n * n for n in numbers]
evens   = [n for n in numbers if n % 2 == 0]
print(squares, evens)
# [1, 4, 9, 16, 25] [2, 4]

```

### 중첩 컴프리헨션(순서 주의: 바깥 → 안쪽)

```python
list1 = [1, 2, 3]
list2 = ['A', 'B']
pairs = [(x, y) for x in list1 for y in list2]
print(pairs)
# [(1,'A'), (1,'B'), (2,'A'), (2,'B'), (3,'A'), (3,'B')]

```

### 변환·필터링

```python
words = ["hello", "world", "python"]
lens  = [len(w) for w in words]                 # 변환
nums  = [int(s) for s in ["123", "abc", "456"] if s.isdigit()] # 필터링
print(lens, nums)
```

### 딕셔너리/집합 컴프리헨션

```python
# dict

nums = [1, 2, 3, 4]
sq_d = {n: n*n for n in nums}
print(sq_d)  # {1:1, 2:4, 3:9, 4:16}

# set (중복 자동 제거)

unique_sq = {n*n for n in [1, 2, 2, 3, 4, 4]}
print(unique_sq)  # {16, 1, 4, 9}
```

### 제너레이터 표현식(지연 평가)

```python
gen = (n*n for n in range(1_000_000))
print(next(gen), next(gen))  # 1 4
# 메모리 효율이 필요한 큰 파이프라인에 적합

```

---

## — `*` 활용 (확장/할당/인수)

### print/함수 호출에서 언패킹

```python
lst = [1, 2, 3]
print(lst)     # [1, 2, 3]
print(*lst)    # 1 2 3  (요소를 펼쳐서 전달)

def add(a, b, c): return a + b + c
print(add(*lst))  # 6
```

### 여러 시퀀스 병합/확장

```python
a = [1, 2, 3]; b = [4, 5]
merged = [*a, *b, 6]
print(merged)  # [1, 2, 3, 4, 5, 6]

d1 = {"x": 1}; d2 = {"y": 2}
d = {**d1, **d2, "z": 3}  # dict 확장은 ** 사용
print(d)  # {'x':1, 'y':2, 'z':3}
```

### 확장 할당(extended iterable unpacking)

```python
a, *middle, b = [10, 20, 30, 40, 50]
print(a, middle, b)  # 10 [20, 30, 40] 50

head, *_, tail = [1, 2, 3, 4]
print(head, tail)    # 1 4
```

> `*`는 **반드시 하나**만 사용 가능하며, **리스트/튜플 등 이터러블**에만 적용 가능합니다.

### for 루프에서 튜플 언패킹

```python
pairs = [(1, "A"), (2, "B")]
for k, v in pairs:
    print(k, v)
```

---

## 안전/가독성/성능 패턴

### `range(len(seq))` 대신 `enumerate` 사용

```python
seq = ["a", "b", "c"]
for i, val in enumerate(seq):
    print(i, val)
```

### 여러 컬렉션 동시 순회는 `zip`

```python
ids = [101, 102]
names = ["kim", "lee", "park"]  # 더 길다
for i, name in zip(ids, names):
    print(i, name)
# → 길이 불일치 시 ValueError

```

### 순회 중 컬렉션 **수정 금지**

```python
items = [1, 2, 3, 4]
# for x in items:  # 위험: 삭제로 인해 인덱스/순서 꼬임
#     if x % 2 == 0:
#         items.remove(x)

# 안전: 새 리스트 만들기

items = [x for x in items if x % 2]
print(items)  # [1, 3]
```

### 중첩 루프 평탄화/조합은 `itertools`

```python
from itertools import product

for x, y in product([1, 2, 3], ['A', 'B']):
    print(x, y)
```

### 루프당 속도 최적화 — 로컬 바인딩

```python
# 속도가 중요한 루프 내부에서 속성/전역 접근은 지역 변수로 잡아두면 빠름

append = [].append
for i in range(100000):
    append(i)
```

### 파일/스트림은 줄 단위 이터러블

```python
with open("data.txt", encoding="utf-8") as f:
    for line in f:              # 한 줄씩
        line = line.rstrip("\n")
        ...
```

---

## 고급: `iter(callable, sentinel)` — 센티넬 기반 루프

파일에서 **블록 단위**로 읽어 EOF(빈 바이트열)까지 반복:

```python
from functools import partial

with open("data.bin", "rb") as f:
    for chunk in iter(partial(f.read, 4096), b""):
        process(chunk)
```

- `iter(callable, sentinel)`은 `callable()`을 계속 호출하여 값을 얻고, 그 값이 `sentinel`과 같아지면 **반복 종료**.

---

## itertools 주요 구성요소(스트림 처리 강화)

```python
from itertools import islice, takewhile, dropwhile, chain, groupby, permutations, combinations

# islice: 슬라이싱처럼 앞 N개만

for x in islice(range(1000), 5):
    print(x)  # 0..4

# takewhile/dropwhile: 조건이 유지되는 동안/깨질 때까지

nums = [1, 2, 3, -1, 4]
print(list(takewhile(lambda x: x > 0, nums)))  # [1, 2, 3]
print(list(dropwhile(lambda x: x > 0, nums)))  # [-1, 4]

# chain: 여러 이터러블을 하나처럼

for x in chain([1, 2], ("A", "B"), "CD"):
    print(x)  # 1 2 A B C D

# groupby: 정렬된 키 기준 그룹화 (정렬 필수!)

data = ["A", "A", "B", "B", "B", "C"]
for k, grp in groupby(data):
    print(k, list(grp))
# A ['A','A']; B ['B','B','B']; C ['C']

# 조합/순열

print(list(combinations([1, 2, 3], r=2)))  # [(1,2), (1,3), (2,3)]
print(list(permutations([1, 2, 3], r=2))) # [(1,2), (1,3), (2,1), ...]
```

---

## 종합 예제

### 로그 파싱 → 카운팅 → 조건 분기(for-else)

```python
logs = [
    "INFO login alice",
    "INFO logout lee",
    "ERROR timeout alice",
]

# 사용자별 이벤트 카운트

counts = {}
for line in logs:
    level, event, user = line.split()
    counts[user] = counts.get(user, 0) + 1

print(counts)  # {'alice': 2, 'lee': 1}

# 특정 유저가 있었는지 찾기 (for-else)

target = "kim"
for user in counts:
    if user == target:
        print("found", target)
        break
else:
    print("not found", target)
```

### 2차원 리스트 평탄화(중첩 컴프리헨션)

```python
grid = [[1, 2], [3, 4, 5]]
flat = [x for row in grid for x in row]
print(flat)  # [1, 2, 3, 4, 5]
```

### 행렬 전치(zip 활용)

```python
mat = [
    [1, 2, 3],
    [4, 5, 6],
]
transposed = [list(col) for col in zip(*mat)]
print(transposed)  # [[1,4],[2,5],[3,6]]
```

### 확장 언패킹으로 앞/뒤/중간 분리

```python
seq = [10, 20, 30, 40, 50]
head, *mid, tail = seq
print(head, mid, tail)  # 10 [20,30,40] 50
```

---

## 체크리스트 (요약)

- `for x in iterable:`의 **기본 모델**은 **이터레이터 프로토콜**.
- 인덱스가 필요하면 **`enumerate(seq, start=0)`**.
- 병렬 순회는 **`zip`**, 길이 불일치는 **`zip(..., strict=True)`**로 감지.
- **for-else**: `break` 없이 정상 종료될 때만 `else` 실행.
- 변환/필터/평탄화는 **컴프리헨션**(+ 제너레이터 표현식은 메모리 효율).
- **언패킹**: `*`로 확장/합치기/가변 길이 할당, `for`에서 튜플 언패킹.
- 순회 중 **컨테이너 수정 금지** — 새 컨테이너 생성/컴프리헨션/슬라이스 활용.
- 대규모 스트림/무한 시퀀스는 **`iter(callable, sentinel)`**, **`itertools`** 조합.
- 파일/소켓/스트림은 **줄·청크 단위 이터러블**로 자연스럽게 `for`와 결합.
