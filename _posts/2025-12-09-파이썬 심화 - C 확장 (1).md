---
layout: post
title: 파이썬 심화 - C 확장 (1)
date: 2025-12-09 16:30:23 +0900
category: 파이썬 심화
---
# C 확장 (1)

## ctypes를 활용한 C 코드 접근

ctypes는 파이썬의 표준 라이브러리로, C 언어로 작성된 공유 라이브러리(Windows의 DLL, Linux의 .so, macOS의 .dylib)를 직접 호출할 수 있게 해주는 강력한 도구입니다. 이를 통해 기존 C 라이브러리를 파이썬에서 재사용하거나 성능이 중요한 부분을 C로 구현할 수 있습니다.

### 기본적인 ctypes 사용법

```python
import ctypes
import ctypes.util
import sys
import os
from typing import Any, Optional, Union, List
from ctypes import (
    c_int, c_double, c_float, c_char_p, c_void_p,
    Structure, POINTER, CFUNCTYPE, cast
)
from pathlib import Path

class CTypesInterface:
    """
    ctypes를 통한 C 라이브러리 인터페이스
    
    C 함수 호출, 구조체 처리, 콜백 함수 등록 등을 관리
    """
    
    def __init__(self, lib_path: Optional[str] = None):
        """
        C 라이브러리 인터페이스 초기화
        
        Args:
            lib_path: 공유 라이브러리 경로 (None이면 시스템 라이브러리 검색)
        """
        self.lib = None
        self.loaded = False
        
        if lib_path:
            self.load_library(lib_path)
        else:
            # 시스템 수학 라이브러리 자동 로드 (예시)
            self.load_system_library()
    
    def load_library(self, lib_path: str) -> bool:
        """
        공유 라이브러리 로드
        
        Args:
            lib_path: 라이브러리 파일 경로
        
        Returns:
            로드 성공 여부
        """
        try:
            # 절대 경로로 변환
            lib_path = Path(lib_path).resolve()
            
            if not lib_path.exists():
                print(f"라이브러리 파일을 찾을 수 없습니다: {lib_path}")
                return False
            
            # 플랫폼별 라이브러리 로딩
            if sys.platform == "win32":
                self.lib = ctypes.WinDLL(str(lib_path))
            else:
                self.lib = ctypes.CDLL(str(lib_path))
            
            self.loaded = True
            print(f"C 라이브러리 로드 성공: {lib_path}")
            return True
            
        except Exception as e:
            print(f"C 라이브러리 로드 실패: {e}")
            self.lib = None
            self.loaded = False
            return False
    
    def load_system_library(self) -> bool:
        """시스템 라이브러리 로드 (예: libc, libm)"""
        try:
            # C 표준 라이브러리 로드
            if sys.platform == "win32":
                # Windows: msvcrt.dll
                libc_name = "msvcrt.dll"
            else:
                # Unix-like: libc.so
                libc_name = ctypes.util.find_library("c")
            
            if not libc_name:
                print("시스템 C 라이브러리를 찾을 수 없습니다.")
                return False
            
            if sys.platform == "win32":
                self.lib = ctypes.WinDLL(libc_name)
            else:
                self.lib = ctypes.CDLL(libc_name)
            
            self.loaded = True
            print(f"시스템 C 라이브러리 로드: {libc_name}")
            return True
            
        except Exception as e:
            print(f"시스템 라이브러리 로드 실패: {e}")
            return False
    
    def define_function(self, 
                       func_name: str, 
                       argtypes: List[Any] = None,
                       restype: Any = None) -> bool:
        """
        C 함수 시그니처 정의
        
        Args:
            func_name: 함수 이름
            argtypes: 인자 타입 리스트
            restype: 반환 타입
        
        Returns:
            정의 성공 여부
        """
        if not self.loaded or not self.lib:
            print("라이브러리가 로드되지 않았습니다.")
            return False
        
        try:
            func = getattr(self.lib, func_name)
            
            if argtypes:
                func.argtypes = argtypes
            if restype:
                func.restype = restype
            
            print(f"C 함수 정의 완료: {func_name}")
            return True
            
        except AttributeError as e:
            print(f"C 함수를 찾을 수 없습니다: {func_name} - {e}")
            return False
        except Exception as e:
            print(f"C 함수 정의 실패: {func_name} - {e}")
            return False
    
    def call_function(self, func_name: str, *args) -> Any:
        """
        C 함수 호출
        
        Args:
            func_name: 함수 이름
            *args: 함수 인자
        
        Returns:
            함수 실행 결과
        """
        if not self.loaded or not self.lib:
            raise RuntimeError("라이브러리가 로드되지 않았습니다.")
        
        try:
            func = getattr(self.lib, func_name)
            return func(*args)
            
        except AttributeError:
            raise AttributeError(f"C 함수를 찾을 수 없습니다: {func_name}")
        except Exception as e:
            raise RuntimeError(f"C 함수 호출 실패: {func_name} - {e}")

# C 구조체 정의 예시
class Point(Structure):
    """C 구조체에 대응하는 파이썬 클래스"""
    _fields_ = [
        ("x", c_double),
        ("y", c_double)
    ]
    
    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

class Rectangle(Structure):
    """중첩 구조체 예시"""
    _fields_ = [
        ("top_left", Point),
        ("bottom_right", Point),
        ("name", c_char_p)
    ]
    
    def __repr__(self):
        return f"Rectangle({self.top_left}, {self.bottom_right}, name={self.name})"

# 콜백 함수 타입 정의
CallbackFunc = CFUNCTYPE(c_int, c_int, c_int)

def demonstrate_ctypes_basics():
    """
    ctypes 기본 사용법 데모
    """
    print("=" * 60)
    print("ctypes를 활용한 C 코드 접근")
    print("=" * 60)
    
    # C 인터페이스 생성
    c_interface = CTypesInterface()
    
    if not c_interface.loaded:
        print("C 라이브러리 로드에 실패했습니다.")
        return
    
    print("\n1. 기본 C 함수 호출:")
    
    # atoi 함수 정의 및 호출
    c_interface.define_function("atoi", [c_char_p], c_int)
    
    result = c_interface.call_function("atoi", b"12345")
    print(f"  atoi('12345') = {result}")
    print(f"  타입: {type(result)}")
    
    print("\n2. 수학 함수 호출:")
    
    # 수학 라이브러리 로드
    if sys.platform == "win32":
        math_lib = "msvcrt.dll"
    else:
        math_lib = ctypes.util.find_library("m")
    
    if math_lib:
        math_interface = CTypesInterface(math_lib)
        
        # sqrt 함수 정의
        math_interface.define_function("sqrt", [c_double], c_double)
        
        # sqrt 함수 호출
        sqrt_result = math_interface.call_function("sqrt", 25.0)
        print(f"  sqrt(25.0) = {sqrt_result}")
        
        # pow 함수 정의 및 호출
        math_interface.define_function("pow", [c_double, c_double], c_double)
        pow_result = math_interface.call_function("pow", 2.0, 3.0)
        print(f"  pow(2.0, 3.0) = {pow_result}")
    
    print("\n3. 구조체 사용:")
    
    # Point 구조체 생성
    p1 = Point(3.0, 4.0)
    p2 = Point(10.0, 20.0)
    
    print(f"  Point 1: {p1}")
    print(f"  Point 2: {p2}")
    
    # Rectangle 구조체 생성
    rect = Rectangle(p1, p2, b"My Rectangle")
    print(f"  Rectangle: {rect}")
    
    # 구조체 필드 접근
    print(f"  rect.top_left.x = {rect.top_left.x}")
    print(f"  rect.name = {rect.name.decode()}")
    
    print("\n4. 포인터와 배열 작업:")
    
    # 정수 배열 생성
    int_array = (c_int * 5)(1, 2, 3, 4, 5)
    print(f"  정수 배열: {list(int_array)}")
    
    # 배열 요소 접근
    int_array[0] = 100
    print(f"  수정된 배열: {list(int_array)}")
    
    # 포인터 생성
    int_ptr = ctypes.pointer(int_array[0])
    print(f"  첫 번째 요소 포인터: {int_ptr}")
    print(f"  포인터가 가리키는 값: {int_ptr.contents}")
    
    print("\n5. 문자열 작업:")
    
    # C 문자열 생성
    c_string = c_char_p(b"Hello, C World!")
    print(f"  C 문자열: {c_string.value.decode()}")
    
    # 문자열 수정 (주의: 메모리 할당 필요)
    buffer_size = 100
    string_buffer = ctypes.create_string_buffer(buffer_size)
    string_buffer.value = b"New string content"
    print(f"  문자열 버퍼: {string_buffer.value.decode()}")
    
    print("\n6. 콜백 함수 등록:")
    
    # 콜백 함수 정의
    def python_callback(a: int, b: int) -> int:
        """C에서 호출될 파이썬 함수"""
        print(f"  콜백 호출됨: a={a}, b={b}")
        return a + b
    
    # C 콜백 타입으로 변환
    c_callback = CallbackFunc(python_callback)
    
    # 콜백 직접 호출 (실제로는 C 함수에 전달됨)
    callback_result = c_callback(10, 20)
    print(f"  콜백 결과: {callback_result}")
    
    print("\n7. 사용자 정의 C 라이브러리 예시:")
    
    # 간단한 C 코드 컴파일 및 테스트
    demonstrate_custom_c_library()

def compile_and_test_c_library():
    """사용자 정의 C 라이브러리 컴파일 및 테스트"""
    import subprocess
    import tempfile
    
    # 간단한 C 라이브러리 코드
    c_code = """
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// 간단한 수학 연산
double add(double a, double b) {
    return a + b;
}

double multiply(double a, double b) {
    return a * b;
}

// 문자열 처리
void greet(char* name, char* buffer, int buffer_size) {
    snprintf(buffer, buffer_size, "Hello, %s!", name);
}

// 구조체 작업
typedef struct {
    double x;
    double y;
} Point;

double distance(Point p1, Point p2) {
    double dx = p2.x - p1.x;
    double dy = p2.y - p1.y;
    return sqrt(dx*dx + dy*dy);
}

// 콜백 함수를 사용하는 함수
typedef int (*Callback)(int);
int process_with_callback(int value, Callback cb) {
    return cb(value * 2);
}
"""
    
    try:
        # 임시 디렉토리 생성
        temp_dir = tempfile.mkdtemp(prefix="ctypes_test_")
        c_file = Path(temp_dir) / "mylib.c"
        lib_file = None
        
        # C 파일 작성
        with open(c_file, 'w') as f:
            f.write(c_code)
        
        print(f"  C 파일 생성: {c_file}")
        
        # 플랫폼별 컴파일
        if sys.platform == "win32":
            # Windows: DLL 생성
            lib_file = Path(temp_dir) / "mylib.dll"
            compile_cmd = [
                "gcc", "-shared", "-o", str(lib_file),
                str(c_file), "-lm"
            ]
        else:
            # Unix-like: 공유 라이브러리 생성
            lib_file = Path(temp_dir) / "libmylib.so"
            compile_cmd = [
                "gcc", "-shared", "-fPIC", "-o", str(lib_file),
                str(c_file), "-lm"
            ]
        
        # 컴파일 실행
        print(f"  컴파일 명령: {' '.join(compile_cmd)}")
        result = subprocess.run(compile_cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"  컴파일 실패: {result.stderr}")
            return None
        
        print(f"  라이브러리 생성: {lib_file}")
        
        # 생성된 라이브러리 테스트
        if lib_file.exists():
            mylib = CTypesInterface(str(lib_file))
            
            # 함수 정의
            mylib.define_function("add", [c_double, c_double], c_double)
            mylib.define_function("multiply", [c_double, c_double], c_double)
            
            # 함수 호출
            add_result = mylib.call_function("add", 10.5, 20.3)
            mul_result = mylib.call_function("multiply", 3.0, 4.0)
            
            print(f"  add(10.5, 20.3) = {add_result}")
            print(f"  multiply(3.0, 4.0) = {mul_result}")
            
            return lib_file
        
    except Exception as e:
        print(f"  C 라이브러리 테스트 중 오류: {e}")
        return None

if __name__ == "__main__":
    demonstrate_ctypes_basics()
```

## 간단한 C 확장 모듈 작성

파이썬 C 확장 모듈은 C/C++로 작성된 코드를 파이썬 모듈로 만들어 성능이 중요한 연산을 가속화하거나 기존 C 라이브러리를 파이썬에 통합할 때 사용합니다.

### 기본 C 확장 모듈 구조

```c
/* example_module.c - 기본 C 확장 모듈 예시 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <math.h>

/* 함수 1: 두 숫자를 더하는 함수 */
static PyObject* example_add(PyObject* self, PyObject* args) {
    double a, b;
    
    /* 파이썬 인자 파싱 */
    if (!PyArg_ParseTuple(args, "dd", &a, &b)) {
        return NULL;  /* 파이썬 예외 발생 */
    }
    
    /* 연산 수행 */
    double result = a + b;
    
    /* 파이썬 객체로 변환하여 반환 */
    return PyFloat_FromDouble(result);
}

/* 함수 2: 문자열을 반복하는 함수 */
static PyObject* example_repeat(PyObject* self, PyObject* args) {
    const char* str;
    int count;
    
    /* 문자열과 정수 인자 파싱 */
    if (!PyArg_ParseTuple(args, "si", &str, &count)) {
        return NULL;
    }
    
    /* 결과 문자열 생성 */
    size_t len = strlen(str);
    char* result = (char*)malloc(len * count + 1);
    
    if (result == NULL) {
        PyErr_NoMemory();
        return NULL;
    }
    
    /* 문자열 반복 */
    char* ptr = result;
    for (int i = 0; i < count; i++) {
        memcpy(ptr, str, len);
        ptr += len;
    }
    *ptr = '\0';
    
    /* 파이썬 문자열 객체 생성 */
    PyObject* py_result = PyUnicode_FromString(result);
    
    /* 메모리 해제 */
    free(result);
    
    return py_result;
}

/* 함수 3: 리스트의 합계 계산 */
static PyObject* example_sum_list(PyObject* self, PyObject* args) {
    PyObject* list_obj;
    
    /* 리스트 인자 파싱 */
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &list_obj)) {
        return NULL;
    }
    
    Py_ssize_t size = PyList_Size(list_obj);
    double total = 0.0;
    
    /* 리스트 순회 및 합계 계산 */
    for (Py_ssize_t i = 0; i < size; i++) {
        PyObject* item = PyList_GetItem(list_obj, i);
        
        /* 숫자로 변환 시도 */
        if (PyFloat_Check(item)) {
            total += PyFloat_AsDouble(item);
        } else if (PyLong_Check(item)) {
            total += (double)PyLong_AsLong(item);
        } else {
            PyErr_SetString(PyExc_TypeError, 
                          "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
    }
    
    return PyFloat_FromDouble(total);
}

/* 함수 4: 복수 값 반환 (튜플) */
static PyObject* example_minmax(PyObject* self, PyObject* args) {
    PyObject* list_obj;
    
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &list_obj)) {
        return NULL;
    }
    
    Py_ssize_t size = PyList_Size(list_obj);
    if (size == 0) {
        PyErr_SetString(PyExc_ValueError, 
                       "빈 리스트는 최소/최대값을 가질 수 없습니다");
        return NULL;
    }
    
    /* 첫 번째 요소로 초기화 */
    PyObject* first_item = PyList_GetItem(list_obj, 0);
    double min_val, max_val;
    
    if (PyFloat_Check(first_item)) {
        min_val = max_val = PyFloat_AsDouble(first_item);
    } else if (PyLong_Check(first_item)) {
        min_val = max_val = (double)PyLong_AsLong(first_item);
    } else {
        PyErr_SetString(PyExc_TypeError, 
                       "리스트 요소는 숫자여야 합니다");
        return NULL;
    }
    
    /* 최소/최대값 찾기 */
    for (Py_ssize_t i = 1; i < size; i++) {
        PyObject* item = PyList_GetItem(list_obj, i);
        double val;
        
        if (PyFloat_Check(item)) {
            val = PyFloat_AsDouble(item);
        } else if (PyLong_Check(item)) {
            val = (double)PyLong_AsLong(item);
        } else {
            PyErr_SetString(PyExc_TypeError, 
                           "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
        
        if (val < min_val) min_val = val;
        if (val > max_val) max_val = val;
    }
    
    /* 튜플로 결과 반환 */
    return Py_BuildValue("(dd)", min_val, max_val);
}

/* 함수 5: 키워드 인자 지원 */
static PyObject* example_calculate(PyObject* self, 
                                  PyObject* args, 
                                  PyObject* kwargs) {
    static char* keywords[] = {"a", "b", "operation", NULL};
    
    double a = 0.0, b = 0.0;
    const char* operation = "add";
    
    /* 키워드 인자 파싱 */
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "dd|s", keywords,
                                     &a, &b, &operation)) {
        return NULL;
    }
    
    double result;
    
    /* 연산 수행 */
    if (strcmp(operation, "add") == 0) {
        result = a + b;
    } else if (strcmp(operation, "subtract") == 0) {
        result = a - b;
    } else if (strcmp(operation, "multiply") == 0) {
        result = a * b;
    } else if (strcmp(operation, "divide") == 0) {
        if (b == 0.0) {
            PyErr_SetString(PyExc_ZeroDivisionError, 
                           "0으로 나눌 수 없습니다");
            return NULL;
        }
        result = a / b;
    } else {
        PyErr_SetString(PyExc_ValueError, 
                       "지원되지 않는 연산입니다");
        return NULL;
    }
    
    return PyFloat_FromDouble(result);
}

/* 메서드 정의 테이블 */
static PyMethodDef ExampleMethods[] = {
    {"add", example_add, METH_VARARGS, 
     "두 숫자를 더합니다.\n\n"
     "인자:\n"
     "  a (float): 첫 번째 숫자\n"
     "  b (float): 두 번째 숫자\n\n"
     "반환값:\n"
     "  float: a와 b의 합"},
    
    {"repeat", example_repeat, METH_VARARGS,
     "문자열을 지정된 횟수만큼 반복합니다.\n\n"
     "인자:\n"
     "  s (str): 반복할 문자열\n"
     "  count (int): 반복 횟수\n\n"
     "반환값:\n"
     "  str: 반복된 문자열"},
    
    {"sum_list", example_sum_list, METH_VARARGS,
     "숫자 리스트의 합계를 계산합니다.\n\n"
     "인자:\n"
     "  numbers (list): 숫자 리스트\n\n"
     "반환값:\n"
     "  float: 합계"},
    
    {"minmax", example_minmax, METH_VARARGS,
     "리스트의 최소값과 최대값을 찾습니다.\n\n"
     "인자:\n"
     "  numbers (list): 숫자 리스트\n\n"
     "반환값:\n"
     "  tuple: (최소값, 최대값)"},
    
    {"calculate", (PyCFunction)example_calculate, 
     METH_VARARGS | METH_KEYWORDS,
     "두 숫자에 대한 연산을 수행합니다.\n\n"
     "인자:\n"
     "  a (float): 첫 번째 숫자\n"
     "  b (float): 두 번째 숫자\n"
     "  operation (str): 연산 종류 (add, subtract, multiply, divide)\n\n"
     "반환값:\n"
     "  float: 연산 결과"},
    
    {NULL, NULL, 0, NULL}  /* 센티넬 */
};

/* 모듈 정의 구조체 */
static struct PyModuleDef examplemodule = {
    PyModuleDef_HEAD_INIT,
    "example",           /* 모듈 이름 */
    "예시 C 확장 모듈입니다.\n\n"
    "이 모듈은 C로 작성된 파이썬 확장 모듈의 예시입니다.\n"
    "다양한 수학 연산과 문자열 처리를 제공합니다.",  /* 모듈 문서 */
    -1,                 /* 모듈 상태 크기 (-1은 전역 상태 사용) */
    ExampleMethods      /* 메서드 테이블 */
};

/* 모듈 초기화 함수 */
PyMODINIT_FUNC PyInit_example(void) {
    PyObject* module;
    
    /* 모듈 생성 */
    module = PyModule_Create(&examplemodule);
    if (module == NULL) {
        return NULL;
    }
    
    /* 모듈 상수 추가 */
    PyModule_AddStringConstant(module, "__author__", "Your Name");
    PyModule_AddStringConstant(module, "__version__", "1.0.0");
    
    /* 수학 상수 추가 */
    PyModule_AddObject(module, "PI", PyFloat_FromDouble(3.141592653589793));
    PyModule_AddObject(module, "E", PyFloat_FromDouble(2.718281828459045));
    
    return module;
}
```

### setup.py로 확장 모듈 빌드하기

```python
# setup.py - C 확장 모듈 빌드 설정

from setuptools import setup, Extension
import sys

# 컴파일러 플래그 설정
extra_compile_args = []
extra_link_args = []

if sys.platform == "win32":
    # Windows 설정
    extra_compile_args = ["/O2", "/W3"]
elif sys.platform == "darwin":
    # macOS 설정
    extra_compile_args = ["-O3", "-Wall", "-Wextra"]
    extra_link_args = ["-framework", "Python"]
else:
    # Linux/Unix 설정
    extra_compile_args = ["-O3", "-Wall", "-Wextra", "-fPIC"]

# 확장 모듈 정의
example_extension = Extension(
    name="example",  # 모듈 이름
    sources=["example_module.c"],  # 소스 파일
    include_dirs=[],  # 추가 포함 디렉토리
    library_dirs=[],  # 라이브러리 디렉토리
    libraries=[],  # 링크할 라이브러리
    define_macros=[],  # 전처리기 매크로
    undef_macros=[],  # 정의 해제할 매크로
    extra_compile_args=extra_compile_args,
    extra_link_args=extra_link_args,
    language="c",  # 언어 (c, c++, objc 등)
)

setup(
    name="example-extension",
    version="1.0.0",
    description="예시 C 확장 모듈",
    author="Your Name",
    ext_modules=[example_extension],
    python_requires=">=3.6",
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: C",
        "Topic :: Software Development :: Libraries :: Python Modules",
    ],
)
```

## 배열에 동작하는 확장 함수 작성

NumPy와 같은 배열 연산을 위한 고성능 C 확장 함수를 작성하는 방법을 알아봅니다.

### 배열 처리 C 확장 모듈

```c
/* array_module.c - 배열 연산 확장 모듈 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* 배열 합계 계산 함수 */
static PyObject* array_sum(PyObject* self, PyObject* args) {
    PyObject* input_list;
    
    /* 리스트 입력 받기 */
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &input_list)) {
        return NULL;
    }
    
    /* 리스트 크기 확인 */
    Py_ssize_t size = PyList_Size(input_list);
    if (size == 0) {
        return PyFloat_FromDouble(0.0);
    }
    
    /* 합계 계산 */
    double total = 0.0;
    
    for (Py_ssize_t i = 0; i < size; i++) {
        PyObject* item = PyList_GetItem(input_list, i);
        
        /* 숫자 타입 확인 */
        if (PyFloat_Check(item)) {
            total += PyFloat_AsDouble(item);
        } else if (PyLong_Check(item)) {
            total += (double)PyLong_AsLong(item);
        } else if (PyInt_Check(item)) {
            total += (double)PyInt_AsLong(item);
        } else {
            PyErr_SetString(PyExc_TypeError, 
                           "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
    }
    
    return PyFloat_FromDouble(total);
}

/* 배열 평균 계산 함수 */
static PyObject* array_mean(PyObject* self, PyObject* args) {
    PyObject* input_list;
    
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &input_list)) {
        return NULL;
    }
    
    Py_ssize_t size = PyList_Size(input_list);
    if (size == 0) {
        PyErr_SetString(PyExc_ValueError, "빈 리스트의 평균을 계산할 수 없습니다");
        return NULL;
    }
    
    double total = 0.0;
    
    for (Py_ssize_t i = 0; i < size; i++) {
        PyObject* item = PyList_GetItem(input_list, i);
        
        if (PyFloat_Check(item)) {
            total += PyFloat_AsDouble(item);
        } else if (PyLong_Check(item)) {
            total += (double)PyLong_AsLong(item);
        } else if (PyInt_Check(item)) {
            total += (double)PyInt_AsLong(item);
        } else {
            PyErr_SetString(PyExc_TypeError, 
                           "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
    }
    
    return PyFloat_FromDouble(total / size);
}

/* 배열 표준 편차 계산 함수 */
static PyObject* array_std(PyObject* self, PyObject* args) {
    PyObject* input_list;
    
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &input_list)) {
        return NULL;
    }
    
    Py_ssize_t size = PyList_Size(input_list);
    if (size < 2) {
        PyErr_SetString(PyExc_ValueError, 
                       "표준 편차 계산을 위해 최소 2개의 요소가 필요합니다");
        return NULL;
    }
    
    /* 평균 계산 */
    double total = 0.0;
    double* values = (double*)malloc(size * sizeof(double));
    
    if (values == NULL) {
        PyErr_NoMemory();
        return NULL;
    }
    
    for (Py_ssize_t i = 0; i < size; i++) {
        PyObject* item = PyList_GetItem(input_list, i);
        
        if (PyFloat_Check(item)) {
            values[i] = PyFloat_AsDouble(item);
        } else if (PyLong_Check(item)) {
            values[i] = (double)PyLong_AsLong(item);
        } else if (PyInt_Check(item)) {
            values[i] = (double)PyInt_AsLong(item);
        } else {
            free(values);
            PyErr_SetString(PyExc_TypeError, 
                           "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
        
        total += values[i];
    }
    
    double mean = total / size;
    
    /* 분산 계산 */
    double variance = 0.0;
    for (Py_ssize_t i = 0; i < size; i++) {
        double diff = values[i] - mean;
        variance += diff * diff;
    }
    variance /= (size - 1);  /* 표본 분산 */
    
    /* 메모리 해제 */
    free(values);
    
    /* 표준 편차 반환 */
    return PyFloat_FromDouble(sqrt(variance));
}

/* 배열 요소별 제곱 함수 */
static PyObject* array_square(PyObject* self, PyObject* args) {
    PyObject* input_list;
    
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &input_list)) {
        return NULL;
    }
    
    Py_ssize_t size = PyList_Size(input_list);
    
    /* 결과 리스트 생성 */
    PyObject* result_list = PyList_New(size);
    if (result_list == NULL) {
        return NULL;
    }
    
    for (Py_ssize_t i = 0; i < size; i++) {
        PyObject* item = PyList_GetItem(input_list, i);
        double value, squared;
        
        /* 값 추출 */
        if (PyFloat_Check(item)) {
            value = PyFloat_AsDouble(item);
        } else if (PyLong_Check(item)) {
            value = (double)PyLong_AsLong(item);
        } else if (PyInt_Check(item)) {
            value = (double)PyInt_AsLong(item);
        } else {
            Py_DECREF(result_list);
            PyErr_SetString(PyExc_TypeError, 
                           "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
        
        /* 제곱 계산 */
        squared = value * value;
        
        /* 결과 리스트에 추가 */
        PyObject* py_squared = PyFloat_FromDouble(squared);
        if (py_squared == NULL) {
            Py_DECREF(result_list);
            return NULL;
        }
        
        PyList_SetItem(result_list, i, py_squared);
    }
    
    return result_list;
}

/* 두 배열의 내적 계산 함수 */
static PyObject* array_dot(PyObject* self, PyObject* args) {
    PyObject *list1, *list2;
    
    if (!PyArg_ParseTuple(args, "O!O!", 
                         &PyList_Type, &list1,
                         &PyList_Type, &list2)) {
        return NULL;
    }
    
    Py_ssize_t size1 = PyList_Size(list1);
    Py_ssize_t size2 = PyList_Size(list2);
    
    if (size1 != size2) {
        PyErr_SetString(PyExc_ValueError, 
                       "배열 크기가 일치해야 합니다");
        return NULL;
    }
    
    double dot_product = 0.0;
    
    for (Py_ssize_t i = 0; i < size1; i++) {
        PyObject *item1 = PyList_GetItem(list1, i);
        PyObject *item2 = PyList_GetItem(list2, i);
        
        double val1, val2;
        
        /* 첫 번째 값 추출 */
        if (PyFloat_Check(item1)) {
            val1 = PyFloat_AsDouble(item1);
        } else if (PyLong_Check(item1)) {
            val1 = (double)PyLong_AsLong(item1);
        } else if (PyInt_Check(item1)) {
            val1 = (double)PyInt_AsLong(item1);
        } else {
            PyErr_SetString(PyExc_TypeError, 
                           "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
        
        /* 두 번째 값 추출 */
        if (PyFloat_Check(item2)) {
            val2 = PyFloat_AsDouble(item2);
        } else if (PyLong_Check(item2)) {
            val2 = (double)PyLong_AsLong(item2);
        } else if (PyInt_Check(item2)) {
            val2 = (double)PyInt_AsLong(item2);
        } else {
            PyErr_SetString(PyExc_TypeError, 
                           "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
        
        dot_product += val1 * val2;
    }
    
    return PyFloat_FromDouble(dot_product);
}

/* 배열 필터링 함수 (조건에 맞는 요소만 선택) */
static PyObject* array_filter(PyObject* self, PyObject* args) {
    PyObject* input_list;
    double threshold;
    
    if (!PyArg_ParseTuple(args, "O!d", 
                         &PyList_Type, &input_list,
                         &threshold)) {
        return NULL;
    }
    
    Py_ssize_t size = PyList_Size(input_list);
    
    /* 조건에 맞는 요소 수 세기 */
    Py_ssize_t count = 0;
    for (Py_ssize_t i = 0; i < size; i++) {
        PyObject* item = PyList_GetItem(input_list, i);
        double value;
        
        if (PyFloat_Check(item)) {
            value = PyFloat_AsDouble(item);
        } else if (PyLong_Check(item)) {
            value = (double)PyLong_AsLong(item);
        } else if (PyInt_Check(item)) {
            value = (double)PyInt_AsLong(item);
        } else {
            PyErr_SetString(PyExc_TypeError, 
                           "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
        
        if (value > threshold) {
            count++;
        }
    }
    
    /* 결과 리스트 생성 */
    PyObject* result_list = PyList_New(count);
    if (result_list == NULL) {
        return NULL;
    }
    
    /* 조건에 맞는 요소 추가 */
    Py_ssize_t result_index = 0;
    for (Py_ssize_t i = 0; i < size; i++) {
        PyObject* item = PyList_GetItem(input_list, i);
        double value;
        
        if (PyFloat_Check(item)) {
            value = PyFloat_AsDouble(item);
        } else if (PyLong_Check(item)) {
            value = (double)PyLong_AsLong(item);
        } else if (PyInt_Check(item)) {
            value = (double)PyInt_AsLong(item);
        } else {
            Py_DECREF(result_list);
            PyErr_SetString(PyExc_TypeError, 
                           "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
        
        if (value > threshold) {
            PyObject* py_value = PyFloat_FromDouble(value);
            if (py_value == NULL) {
                Py_DECREF(result_list);
                return NULL;
            }
            PyList_SetItem(result_list, result_index++, py_value);
        }
    }
    
    return result_list;
}

/* NumPy 배열 인터페이스를 위한 함수 */
#ifdef WITH_NUMPY
#include <numpy/arrayobject.h>

/* NumPy 배열 합계 계산 */
static PyObject* numpy_sum(PyObject* self, PyObject* args) {
    PyArrayObject* array;
    
    if (!PyArg_ParseTuple(args, "O!", &PyArray_Type, &array)) {
        return NULL;
    }
    
    /* 배열 차원 및 타입 확인 */
    if (PyArray_NDIM(array) != 1) {
        PyErr_SetString(PyExc_ValueError, 
                       "1차원 배열만 지원됩니다");
        return NULL;
    }
    
    npy_intp size = PyArray_DIM(array, 0);
    double total = 0.0;
    
    /* 데이터 타입에 따른 처리 */
    if (PyArray_TYPE(array) == NPY_DOUBLE) {
        double* data = (double*)PyArray_DATA(array);
        for (npy_intp i = 0; i < size; i++) {
            total += data[i];
        }
    } else if (PyArray_TYPE(array) == NPY_FLOAT) {
        float* data = (float*)PyArray_DATA(array);
        for (npy_intp i = 0; i < size; i++) {
            total += data[i];
        }
    } else if (PyArray_TYPE(array) == NPY_INT64) {
        long long* data = (long long*)PyArray_DATA(array);
        for (npy_intp i = 0; i < size; i++) {
            total += data[i];
        }
    } else if (PyArray_TYPE(array) == NPY_INT32) {
        int* data = (int*)PyArray_DATA(array);
        for (npy_intp i = 0; i < size; i++) {
            total += data[i];
        }
    } else {
        PyErr_SetString(PyExc_TypeError, 
                       "지원되지 않는 배열 타입입니다");
        return NULL;
    }
    
    return PyFloat_FromDouble(total);
}
#endif

/* 메서드 정의 테이블 */
static PyMethodDef ArrayMethods[] = {
    {"sum", array_sum, METH_VARARGS, 
     "배열의 합계를 계산합니다."},
    {"mean", array_mean, METH_VARARGS, 
     "배열의 평균을 계산합니다."},
    {"std", array_std, METH_VARARGS, 
     "배열의 표준 편차를 계산합니다."},
    {"square", array_square, METH_VARARGS, 
     "배열의 각 요소를 제곱합니다."},
    {"dot", array_dot, METH_VARARGS, 
     "두 배열의 내적을 계산합니다."},
    {"filter", array_filter, METH_VARARGS, 
     "임계값보다 큰 요소만 필터링합니다."},
    #ifdef WITH_NUMPY
    {"numpy_sum", numpy_sum, METH_VARARGS, 
     "NumPy 배열의 합계를 계산합니다."},
    #endif
    {NULL, NULL, 0, NULL}
};

/* 모듈 정의 */
static struct PyModuleDef arraymodule = {
    PyModuleDef_HEAD_INIT,
    "array_operations",  /* 모듈 이름 */
    "고성능 배열 연산 C 확장 모듈",  /* 모듈 문서 */
    -1,
    ArrayMethods
};

/* 모듈 초기화 함수 */
PyMODINIT_FUNC PyInit_array_operations(void) {
    PyObject* module;
    
    module = PyModule_Create(&arraymodule);
    if (module == NULL) {
        return NULL;
    }
    
    /* NumPy 지원이 활성화된 경우 초기화 */
    #ifdef WITH_NUMPY
    import_array();
    #endif
    
    /* 모듈 속성 설정 */
    PyModule_AddStringConstant(module, "__version__", "1.0.0");
    
    return module;
}
```

## C 확장 모듈에서 불투명한 포인터 관리

불투명한 포인터(opaque pointer)는 C 확장 모듈에서 내부 상태를 유지하면서 파이썬 사용자에게 구현 세부사항을 숨기는 데 사용됩니다.

### 불투명한 포인터 관리 시스템

```c
/* opaque_module.c - 불투명한 포인터 관리 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stdlib.h>
#include <string.h>

/* 내부 데이터 구조체 (파이썬에서 접근 불가) */
typedef struct {
    int id;
    char* name;
    double* data;
    size_t data_size;
    int ref_count;  /* 참조 카운트 */
} InternalData;

/* 파이썬 객체를 위한 래퍼 구조체 */
typedef struct {
    PyObject_HEAD
    InternalData* data;  /* 불투명한 포인터 */
} DataObject;

/* 객체 할당 */
static PyObject* DataObject_new(PyTypeObject* type, 
                               PyObject* args, 
                               PyObject* kwargs) {
    DataObject* self;
    
    self = (DataObject*)type->tp_alloc(type, 0);
    if (self != NULL) {
        self->data = NULL;
    }
    
    return (PyObject*)self;
}

/* 객체 초기화 */
static int DataObject_init(DataObject* self, 
                          PyObject* args, 
                          PyObject* kwargs) {
    static char* keywords[] = {"id", "name", "data_size", NULL};
    int id;
    const char* name;
    int data_size;
    
    /* 인자 파싱 */
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "isi", keywords,
                                     &id, &name, &data_size)) {
        return -1;
    }
    
    /* 내부 데이터 구조체 할당 */
    self->data = (InternalData*)malloc(sizeof(InternalData));
    if (self->data == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    
    /* 초기화 */
    self->data->id = id;
    self->data->ref_count = 1;
    
    /* 이름 복사 */
    self->data->name = strdup(name);
    if (self->data->name == NULL) {
        free(self->data);
        PyErr_NoMemory();
        return -1;
    }
    
    /* 데이터 배열 할당 */
    if (data_size > 0) {
        self->data->data = (double*)calloc(data_size, sizeof(double));
        if (self->data->data == NULL) {
            free(self->data->name);
            free(self->data);
            PyErr_NoMemory();
            return -1;
        }
        self->data->data_size = data_size;
    } else {
        self->data->data = NULL;
        self->data->data_size = 0;
    }
    
    return 0;
}

/* 객체 소멸 */
static void DataObject_dealloc(DataObject* self) {
    if (self->data != NULL) {
        /* 참조 카운트 감소 */
        self->data->ref_count--;
        
        /* 참조 카운트가 0이면 메모리 해제 */
        if (self->data->ref_count == 0) {
            if (self->data->name != NULL) {
                free(self->data->name);
            }
            if (self->data->data != NULL) {
                free(self->data->data);
            }
            free(self->data);
        }
    }
    
    Py_TYPE(self)->tp_free((PyObject*)self);
}

/* 객체 문자열 표현 */
static PyObject* DataObject_str(DataObject* self) {
    char buffer[256];
    
    if (self->data != NULL) {
        snprintf(buffer, sizeof(buffer),
                "DataObject(id=%d, name='%s', data_size=%zu)",
                self->data->id,
                self->data->name,
                self->data->data_size);
    } else {
        snprintf(buffer, sizeof(buffer), "DataObject(NULL)");
    }
    
    return PyUnicode_FromString(buffer);
}

/* 객체 비교 */
static PyObject* DataObject_richcompare(DataObject* self, 
                                       PyObject* other, 
                                       int op) {
    if (!DataObject_Check(other)) {
        Py_RETURN_NOTIMPLEMENTED;
    }
    
    DataObject* other_obj = (DataObject*)other;
    int result;
    
    /* ID 비교 */
    if (self->data == NULL || other_obj->data == NULL) {
        result = (self->data == other_obj->data);
    } else {
        result = (self->data->id == other_obj->data->id);
    }
    
    switch (op) {
        case Py_EQ:
            return PyBool_FromLong(result);
        case Py_NE:
            return PyBool_FromLong(!result);
        default:
            Py_RETURN_NOTIMPLEMENTED;
    }
}

/* 데이터 접근 메서드 */
static PyObject* DataObject_get_id(DataObject* self, void* closure) {
    if (self->data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "데이터가 초기화되지 않았습니다");
        return NULL;
    }
    
    return PyLong_FromLong(self->data->id);
}

static PyObject* DataObject_get_name(DataObject* self, void* closure) {
    if (self->data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "데이터가 초기화되지 않았습니다");
        return NULL;
    }
    
    return PyUnicode_FromString(self->data->name);
}

static PyObject* DataObject_get_data_size(DataObject* self, void* closure) {
    if (self->data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "데이터가 초기화되지 않았습니다");
        return NULL;
    }
    
    return PyLong_FromSize_t(self->data->data_size);
}

/* 데이터 설정 메서드 */
static int DataObject_set_name(DataObject* self, 
                              PyObject* value, 
                              void* closure) {
    if (self->data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "데이터가 초기화되지 않았습니다");
        return -1;
    }
    
    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "이름을 삭제할 수 없습니다");
        return -1;
    }
    
    if (!PyUnicode_Check(value)) {
        PyErr_SetString(PyExc_TypeError, "이름은 문자열이어야 합니다");
        return -1;
    }
    
    /* 새 이름 할당 */
    const char* new_name = PyUnicode_AsUTF8(value);
    if (new_name == NULL) {
        return -1;
    }
    
    char* temp = strdup(new_name);
    if (temp == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    
    /* 이전 이름 해제 */
    free(self->data->name);
    self->data->name = temp;
    
    return 0;
}

/* 메서드: 데이터 요소 설정 */
static PyObject* DataObject_set_item(DataObject* self, 
                                    PyObject* args) {
    int index;
    double value;
    
    if (!PyArg_ParseTuple(args, "id", &index, &value)) {
        return NULL;
    }
    
    if (self->data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "데이터가 초기화되지 않았습니다");
        return NULL;
    }
    
    if (index < 0 || index >= (int)self->data->data_size) {
        PyErr_SetString(PyExc_IndexError, "인덱스가 범위를 벗어났습니다");
        return NULL;
    }
    
    self->data->data[index] = value;
    
    Py_RETURN_NONE;
}

/* 메서드: 데이터 요소 가져오기 */
static PyObject* DataObject_get_item(DataObject* self, 
                                    PyObject* args) {
    int index;
    
    if (!PyArg_ParseTuple(args, "i", &index)) {
        return NULL;
    }
    
    if (self->data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "데이터가 초기화되지 않았습니다");
        return NULL;
    }
    
    if (index < 0 || index >= (int)self->data->data_size) {
        PyErr_SetString(PyExc_IndexError, "인덱스가 범위를 벗어났습니다");
        return NULL;
    }
    
    return PyFloat_FromDouble(self->data->data[index]);
}

/* 메서드: 데이터 배열의 합계 계산 */
static PyObject* DataObject_calculate_sum(DataObject* self, 
                                         PyObject* Py_UNUSED(ignored)) {
    if (self->data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "데이터가 초기화되지 않았습니다");
        return NULL;
    }
    
    double total = 0.0;
    for (size_t i = 0; i < self->data->data_size; i++) {
        total += self->data->data[i];
    }
    
    return PyFloat_FromDouble(total);
}

/* 메서드: 데이터 배열의 평균 계산 */
static PyObject* DataObject_calculate_mean(DataObject* self, 
                                          PyObject* Py_UNUSED(ignored)) {
    if (self->data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "데이터가 초기화되지 않았습니다");
        return NULL;
    }
    
    if (self->data->data_size == 0) {
        PyErr_SetString(PyExc_ValueError, "데이터가 비어 있습니다");
        return NULL;
    }
    
    double total = 0.0;
    for (size_t i = 0; i < self->data->data_size; i++) {
        total += self->data->data[i];
    }
    
    return PyFloat_FromDouble(total / self->data->data_size);
}

/* 메서드: 객체 복사 (깊은 복사) */
static PyObject* DataObject_copy(DataObject* self, 
                                PyObject* Py_UNUSED(ignored)) {
    if (self->data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "데이터가 초기화되지 않았습니다");
        return NULL;
    }
    
    /* 새 객체 생성 */
    PyObject* args = Py_BuildValue("(isi)", 
                                  self->data->id,
                                  self->data->name,
                                  self->data->data_size);
    if (args == NULL) {
        return NULL;
    }
    
    PyObject* kwargs = NULL;
    PyObject* new_obj = PyObject_Call((PyObject*)&DataObjectType, 
                                     args, kwargs);
    Py_DECREF(args);
    
    if (new_obj == NULL) {
        return NULL;
    }
    
    /* 데이터 복사 */
    DataObject* new_data_obj = (DataObject*)new_obj;
    
    if (self->data->data != NULL && new_data_obj->data->data != NULL) {
        memcpy(new_data_obj->data->data, 
               self->data->data,
               self->data->data_size * sizeof(double));
    }
    
    return new_obj;
}

/* 메서드: 참조 카운트 확인 */
static PyObject* DataObject_get_ref_count(DataObject* self, 
                                         PyObject* Py_UNUSED(ignored)) {
    if (self->data == NULL) {
        return PyLong_FromLong(0);
    }
    
    return PyLong_FromLong(self->data->ref_count);
}

/* 속성 정의 */
static PyGetSetDef DataObject_getset[] = {
    {"id", (getter)DataObject_get_id, NULL,
     "객체 ID", NULL},
    {"name", (getter)DataObject_get_name, (setter)DataObject_set_name,
     "객체 이름", NULL},
    {"data_size", (getter)DataObject_get_data_size, NULL,
     "데이터 배열 크기", NULL},
    {NULL}  /* 센티넬 */
};

/* 메서드 정의 */
static PyMethodDef DataObject_methods[] = {
    {"set_item", (PyCFunction)DataObject_set_item, METH_VARARGS,
     "데이터 배열의 특정 인덱스에 값을 설정합니다."},
    {"get_item", (PyCFunction)DataObject_get_item, METH_VARARGS,
     "데이터 배열의 특정 인덱스에서 값을 가져옵니다."},
    {"calculate_sum", (PyCFunction)DataObject_calculate_sum, METH_NOARGS,
     "데이터 배열의 합계를 계산합니다."},
    {"calculate_mean", (PyCFunction)DataObject_calculate_mean, METH_NOARGS,
     "데이터 배열의 평균을 계산합니다."},
    {"copy", (PyCFunction)DataObject_copy, METH_NOARGS,
     "객체의 깊은 복사본을 생성합니다."},
    {"get_ref_count", (PyCFunction)DataObject_get_ref_count, METH_NOARGS,
     "내부 참조 카운트를 확인합니다."},
    {NULL}  /* 센티넬 */
};

/* 타입 객체 정의 */
static PyTypeObject DataObjectType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "opaque_module.DataObject",
    .tp_doc = "불투명한 포인터를 가진 데이터 객체",
    .tp_basicsize = sizeof(DataObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = DataObject_new,
    .tp_init = (initproc)DataObject_init,
    .tp_dealloc = (destructor)DataObject_dealloc,
    .tp_str = (reprfunc)DataObject_str,
    .tp_richcompare = (richcmpfunc)DataObject_richcompare,
    .tp_methods = DataObject_methods,
    .tp_getset = DataObject_getset,
};

/* 모듈 함수: 객체 생성 헬퍼 */
static PyObject* create_data_object(PyObject* self, 
                                   PyObject* args) {
    int id;
    const char* name;
    int data_size;
    
    if (!PyArg_ParseTuple(args, "isi", &id, &name, &data_size)) {
        return NULL;
    }
    
    PyObject* obj_args = Py_BuildValue("(isi)", id, name, data_size);
    if (obj_args == NULL) {
        return NULL;
    }
    
    PyObject* obj = PyObject_CallObject((PyObject*)&DataObjectType, obj_args);
    Py_DECREF(obj_args);
    
    return obj;
}

/* 모듈 함수: 두 객체 병합 */
static PyObject* merge_data_objects(PyObject* self, 
                                   PyObject* args) {
    DataObject *obj1, *obj2;
    
    if (!PyArg_ParseTuple(args, "O!O!", 
                         &DataObjectType, &obj1,
                         &DataObjectType, &obj2)) {
        return NULL;
    }
    
    if (obj1->data == NULL || obj2->data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, 
                       "객체가 초기화되지 않았습니다");
        return NULL;
    }
    
    /* 새 객체 생성 */
    size_t new_size = obj1->data->data_size + obj2->data->data_size;
    char new_name[256];
    snprintf(new_name, sizeof(new_name), 
            "%s_merged_with_%s", 
            obj1->data->name, obj2->data->name);
    
    PyObject* new_obj_args = Py_BuildValue("(isi)", 
                                          obj1->data->id * 1000 + obj2->data->id,
                                          new_name,
                                          (int)new_size);
    if (new_obj_args == NULL) {
        return NULL;
    }
    
    PyObject* new_obj = PyObject_CallObject((PyObject*)&DataObjectType, 
                                           new_obj_args);
    Py_DECREF(new_obj_args);
    
    if (new_obj == NULL) {
        return NULL;
    }
    
    DataObject* new_data_obj = (DataObject*)new_obj;
    
    /* 데이터 병합 */
    if (obj1->data->data != NULL) {
        memcpy(new_data_obj->data->data,
               obj1->data->data,
               obj1->data->data_size * sizeof(double));
    }
    
    if (obj2->data->data != NULL) {
        memcpy(new_data_obj->data->data + obj1->data->data_size,
               obj2->data->data,
               obj2->data->data_size * sizeof(double));
    }
    
    return new_obj;
}

/* 모듈 함수 테이블 */
static PyMethodDef OpaqueModuleMethods[] = {
    {"create_data_object", create_data_object, METH_VARARGS,
     "새 데이터 객체를 생성합니다."},
    {"merge_data_objects", merge_data_objects, METH_VARARGS,
     "두 데이터 객체를 병합합니다."},
    {NULL, NULL, 0, NULL}
};

/* 모듈 정의 */
static struct PyModuleDef opaquemodule = {
    PyModuleDef_HEAD_INIT,
    "opaque_module",
    "불투명한 포인터를 관리하는 C 확장 모듈",
    -1,
    OpaqueModuleMethods
};

/* 모듈 초기화 */
PyMODINIT_FUNC PyInit_opaque_module(void) {
    PyObject* module;
    
    /* 타입 객체 준비 */
    if (PyType_Ready(&DataObjectType) < 0) {
        return NULL;
    }
    
    /* 모듈 생성 */
    module = PyModule_Create(&opaquemodule);
    if (module == NULL) {
        return NULL;
    }
    
    /* 타입 객체 추가 */
    Py_INCREF(&DataObjectType);
    if (PyModule_AddObject(module, "DataObject", 
                          (PyObject*)&DataObjectType) < 0) {
        Py_DECREF(&DataObjectType);
        Py_DECREF(module);
        return NULL;
    }
    
    /* 모듈 상수 */
    PyModule_AddStringConstant(module, "__version__", "1.0.0");
    
    return module;
}
```

## 확장 모듈에서 C API 정의 및 내보내기

파이썬 C 확장 모듈은 다른 확장 모듈에서 사용할 수 있는 C API를 제공할 수 있습니다. 이를 통해 모듈 간의 효율적인 데이터 교환과 공통 기능 재사용이 가능합니다.

### C API 제공 확장 모듈

```c
/* capi_module.c - C API를 제공하는 확장 모듈 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stdlib.h>
#include <string.h>

/* 공개 API 구조체 */
typedef struct {
    int version;
    char* description;
    void* (*create_context)(const char*);
    void (*destroy_context)(void*);
    int (*process_data)(void*, const double*, int, double*);
    double (*calculate)(void*, double, double);
} MathAPI;

/* 내부 컨텍스트 구조체 */
typedef struct {
    char* name;
    double multiplier;
    double* buffer;
    size_t buffer_size;
} MathContext;

/* API 구현 함수들 */

static void* api_create_context(const char* name) {
    MathContext* ctx = (MathContext*)malloc(sizeof(MathContext));
    if (ctx == NULL) {
        return NULL;
    }
    
    ctx->name = strdup(name ? name : "default");
    ctx->multiplier = 1.0;
    ctx->buffer = NULL;
    ctx->buffer_size = 0;
    
    return ctx;
}

static void api_destroy_context(void* context) {
    if (context == NULL) {
        return;
    }
    
    MathContext* ctx = (MathContext*)context;
    
    if (ctx->name != NULL) {
        free(ctx->name);
    }
    
    if (ctx->buffer != NULL) {
        free(ctx->buffer);
    }
    
    free(ctx);
}

static int api_process_data(void* context, 
                           const double* input, 
                           int size, 
                           double* output) {
    if (context == NULL || input == NULL || output == NULL || size <= 0) {
        return -1;
    }
    
    MathContext* ctx = (MathContext*)context;
    
    for (int i = 0; i < size; i++) {
        output[i] = input[i] * ctx->multiplier;
    }
    
    return 0;
}

static double api_calculate(void* context, double a, double b) {
    if (context == NULL) {
        return 0.0;
    }
    
    MathContext* ctx = (MathContext*)context;
    return (a + b) * ctx->multiplier;
}

/* API 인스턴스 */
static MathAPI g_math_api = {
    .version = 1,
    .description = "수학 연산 C API",
    .create_context = api_create_context,
    .destroy_context = api_destroy_context,
    .process_data = api_process_data,
    .calculate = api_calculate,
};

/* API 접근 함수 */
MathAPI* get_math_api(void) {
    return &g_math_api;
}

/* 파이썬 객체 래퍼 */
typedef struct {
    PyObject_HEAD
    void* context;
} MathObject;

/* 객체 생성 */
static PyObject* MathObject_new(PyTypeObject* type, 
                               PyObject* args, 
                               PyObject* kwargs) {
    MathObject* self;
    
    self = (MathObject*)type->tp_alloc(type, 0);
    if (self != NULL) {
        self->context = NULL;
    }
    
    return (PyObject*)self;
}

/* 객체 초기화 */
static int MathObject_init(MathObject* self, 
                          PyObject* args, 
                          PyObject* kwargs) {
    static char* keywords[] = {"name", "multiplier", NULL};
    const char* name = "default";
    double multiplier = 1.0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "|sd", keywords,
                                     &name, &multiplier)) {
        return -1;
    }
    
    MathAPI* api = get_math_api();
    if (api == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "API를 사용할 수 없습니다");
        return -1;
    }
    
    self->context = api->create_context(name);
    if (self->context == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    
    /* 컨텍스트 설정 */
    MathContext* ctx = (MathContext*)self->context;
    ctx->multiplier = multiplier;
    
    return 0;
}

/* 객체 소멸 */
static void MathObject_dealloc(MathObject* self) {
    if (self->context != NULL) {
        MathAPI* api = get_math_api();
        if (api != NULL && api->destroy_context != NULL) {
            api->destroy_context(self->context);
        }
        self->context = NULL;
    }
    
    Py_TYPE(self)->tp_free((PyObject*)self);
}

/* 메서드: 계산 수행 */
static PyObject* MathObject_calculate(MathObject* self, 
                                     PyObject* args) {
    double a, b;
    
    if (!PyArg_ParseTuple(args, "dd", &a, &b)) {
        return NULL;
    }
    
    if (self->context == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "컨텍스트가 초기화되지 않았습니다");
        return NULL;
    }
    
    MathAPI* api = get_math_api();
    if (api == NULL || api->calculate == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "API를 사용할 수 없습니다");
        return NULL;
    }
    
    double result = api->calculate(self->context, a, b);
    return PyFloat_FromDouble(result);
}

/* 메서드: 데이터 처리 */
static PyObject* MathObject_process(MathObject* self, 
                                   PyObject* args) {
    PyObject* input_list;
    
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &input_list)) {
        return NULL;
    }
    
    if (self->context == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "컨텍스트가 초기화되지 않았습니다");
        return NULL;
    }
    
    MathAPI* api = get_math_api();
    if (api == NULL || api->process_data == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "API를 사용할 수 없습니다");
        return NULL;
    }
    
    /* 입력 데이터 변환 */
    Py_ssize_t size = PyList_Size(input_list);
    double* input_data = (double*)malloc(size * sizeof(double));
    double* output_data = (double*)malloc(size * sizeof(double));
    
    if (input_data == NULL || output_data == NULL) {
        free(input_data);
        free(output_data);
        PyErr_NoMemory();
        return NULL;
    }
    
    /* 파이썬 리스트에서 C 배열로 변환 */
    for (Py_ssize_t i = 0; i < size; i++) {
        PyObject* item = PyList_GetItem(input_list, i);
        
        if (PyFloat_Check(item)) {
            input_data[i] = PyFloat_AsDouble(item);
        } else if (PyLong_Check(item)) {
            input_data[i] = (double)PyLong_AsLong(item);
        } else {
            free(input_data);
            free(output_data);
            PyErr_SetString(PyExc_TypeError, 
                           "리스트 요소는 숫자여야 합니다");
            return NULL;
        }
    }
    
    /* 데이터 처리 */
    int result = api->process_data(self->context, input_data, (int)size, output_data);
    
    free(input_data);
    
    if (result != 0) {
        free(output_data);
        PyErr_SetString(PyExc_RuntimeError, "데이터 처리 실패");
        return NULL;
    }
    
    /* 결과를 파이썬 리스트로 변환 */
    PyObject* output_list = PyList_New(size);
    if (output_list == NULL) {
        free(output_data);
        return NULL;
    }
    
    for (Py_ssize_t i = 0; i < size; i++) {
        PyObject* py_value = PyFloat_FromDouble(output_data[i]);
        if (py_value == NULL) {
            free(output_data);
            Py_DECREF(output_list);
            return NULL;
        }
        PyList_SetItem(output_list, i, py_value);
    }
    
    free(output_data);
    return output_list;
}

/* 메서드: 속성 설정 */
static PyObject* MathObject_set_multiplier(MathObject* self, 
                                          PyObject* args) {
    double multiplier;
    
    if (!PyArg_ParseTuple(args, "d", &multiplier)) {
        return NULL;
    }
    
    if (self->context == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "컨텍스트가 초기화되지 않았습니다");
        return NULL;
    }
    
    MathContext* ctx = (MathContext*)self->context;
    ctx->multiplier = multiplier;
    
    Py_RETURN_NONE;
}

/* 메서드: 속성 가져오기 */
static PyObject* MathObject_get_multiplier(MathObject* self, 
                                          PyObject* Py_UNUSED(ignored)) {
    if (self->context == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "컨텍스트가 초기화되지 않았습니다");
        return NULL;
    }
    
    MathContext* ctx = (MathContext*)self->context;
    return PyFloat_FromDouble(ctx->multiplier);
}

/* API 버전 확인 */
static PyObject* get_api_version(PyObject* self, 
                                PyObject* Py_UNUSED(ignored)) {
    MathAPI* api = get_math_api();
    if (api == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "API를 사용할 수 없습니다");
        return NULL;
    }
    
    return PyLong_FromLong(api->version);
}

/* API 설명 가져오기 */
static PyObject* get_api_description(PyObject* self, 
                                    PyObject* Py_UNUSED(ignored)) {
    MathAPI* api = get_math_api();
    if (api == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "API를 사용할 수 없습니다");
        return NULL;
    }
    
    return PyUnicode_FromString(api->description);
}

/* API 포인터 내보내기 (다른 C 확장 모듈에서 사용) */
static PyObject* get_api_pointer(PyObject* self, 
                                PyObject* Py_UNUSED(ignored)) {
    MathAPI* api = get_math_api();
    return PyLong_FromVoidPtr(api);
}

/* API 사용 예시 */
static PyObject* demonstrate_api(PyObject* self, 
                                PyObject* Py_UNUSED(ignored)) {
    MathAPI* api = get_math_api();
    if (api == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "API를 사용할 수 없습니다");
        return NULL;
    }
    
    /* 컨텍스트 생성 */
    void* context = api->create_context("demo");
    if (context == NULL) {
        PyErr_NoMemory();
        return NULL;
    }
    
    /* 계산 수행 */
    double result = api->calculate(context, 10.0, 20.0);
    
    /* 데이터 처리 */
    double input[] = {1.0, 2.0, 3.0, 4.0, 5.0};
    double output[5];
    
    api->process_data(context, input, 5, output);
    
    /* 컨텍스트 정리 */
    api->destroy_context(context);
    
    /* 결과를 파이썬 튜플로 반환 */
    PyObject* output_list = PyList_New(5);
    for (int i = 0; i < 5; i++) {
        PyList_SetItem(output_list, i, PyFloat_FromDouble(output[i]));
    }
    
    return Py_BuildValue("(dO)", result, output_list);
}

/* 모듈 함수 테이블 */
static PyMethodDef CAPIModuleMethods[] = {
    {"get_api_version", get_api_version, METH_NOARGS,
     "API 버전을 반환합니다."},
    {"get_api_description", get_api_description, METH_NOARGS,
     "API 설명을 반환합니다."},
    {"get_api_pointer", get_api_pointer, METH_NOARGS,
     "API 포인터를 반환합니다 (C 확장 모듈 간 공유용)."},
    {"demonstrate_api", demonstrate_api, METH_NOARGS,
     "API 사용 예시를 보여줍니다."},
    {NULL, NULL, 0, NULL}
};

/* MathObject 메서드 테이블 */
static PyMethodDef MathObject_methods[] = {
    {"calculate", (PyCFunction)MathObject_calculate, METH_VARARGS,
     "두 숫자를 계산합니다."},
    {"process", (PyCFunction)MathObject_process, METH_VARARGS,
     "데이터 배열을 처리합니다."},
    {"set_multiplier", (PyCFunction)MathObject_set_multiplier, METH_VARARGS,
     "승수를 설정합니다."},
    {"get_multiplier", (PyCFunction)MathObject_get_multiplier, METH_NOARGS,
     "승수를 가져옵니다."},
    {NULL}  /* 센티넬 */
};

/* MathObject 타입 정의 */
static PyTypeObject MathObjectType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "capi_module.MathObject",
    .tp_doc = "C API를 사용하는 수학 객체",
    .tp_basicsize = sizeof(MathObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = MathObject_new,
    .tp_init = (initproc)MathObject_init,
    .tp_dealloc = (destructor)MathObject_dealloc,
    .tp_methods = MathObject_methods,
};

/* 모듈 초기화 함수 */
PyMODINIT_FUNC PyInit_capi_module(void) {
    PyObject* module;
    
    /* 타입 객체 준비 */
    if (PyType_Ready(&MathObjectType) < 0) {
        return NULL;
    }
    
    /* 모듈 생성 */
    module = PyModule_Create(&(struct PyModuleDef){
        PyModuleDef_HEAD_INIT,
        "capi_module",
        "C API를 제공하는 확장 모듈",
        -1,
        CAPIModuleMethods,
        NULL, NULL, NULL, NULL
    });
    
    if (module == NULL) {
        return NULL;
    }
    
    /* 타입 객체 추가 */
    Py_INCREF(&MathObjectType);
    if (PyModule_AddObject(module, "MathObject", 
                          (PyObject*)&MathObjectType) < 0) {
        Py_DECREF(&MathObjectType);
        Py_DECREF(module);
        return NULL;
    }
    
    /* 모듈 상수 */
    PyModule_AddStringConstant(module, "__version__", "1.0.0");
    
    /* API 버전 상수 */
    MathAPI* api = get_math_api();
    if (api != NULL) {
        PyModule_AddIntConstant(module, "API_VERSION", api->version);
    }
    
    return module;
}

/* 다른 C 확장 모듈에서 사용할 헤더 파일 내용 */
/*
// capi_module.h - 다른 C 확장 모듈용 헤더

#ifndef CAPI_MODULE_H
#define CAPI_MODULE_H

#ifdef __cplusplus
extern "C" {
#endif

#include <Python.h>

typedef struct MathAPI MathAPI;

// API 구조체 정의
typedef struct MathAPI {
    int version;
    char* description;
    void* (*create_context)(const char*);
    void (*destroy_context)(void*);
    int (*process_data)(void*, const double*, int, double*);
    double (*calculate)(void*, double, double);
} MathAPI;

// API 접근 함수
MathAPI* get_math_api(void);

#ifdef __cplusplus
}
#endif

#endif // CAPI_MODULE_H
*/
```

### C API를 사용하는 다른 확장 모듈

```c
/* client_module.c - C API를 사용하는 클라이언트 모듈 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stdio.h>

/* C API 헤더 (가상) */
/* #include "capi_module.h" */

/* 대신 함수 포인터 선언 */
typedef void* (*CreateContextFunc)(const char*);
typedef void (*DestroyContextFunc)(void*);
typedef int (*ProcessDataFunc)(void*, const double*, int, double*);
typedef double (*CalculateFunc)(void*, double, double);

/* 동적 로딩을 위한 API 핸들 */
typedef struct {
    void* handle;
    CreateContextFunc create_context;
    DestroyContextFunc destroy_context;
    ProcessDataFunc process_data;
    CalculateFunc calculate;
} DynamicAPI;

/* 동적 API 로드 */
static int load_dynamic_api(DynamicAPI* api) {
    /* 실제 구현에서는 dlopen/LoadLibrary 사용 */
    /* 여기서는 간단한 예시만 */
    
    /* capi_module을 임포트하여 API 포인터 가져오기 */
    PyObject* capi_module = PyImport_ImportModule("capi_module");
    if (capi_module == NULL) {
        return 0;
    }
    
    PyObject* get_api_pointer = PyObject_GetAttrString(capi_module, 
                                                      "get_api_pointer");
    if (get_api_pointer == NULL) {
        Py_DECREF(capi_module);
        return 0;
    }
    
    PyObject* api_ptr_obj = PyObject_CallObject(get_api_pointer, NULL);
    Py_DECREF(get_api_pointer);
    Py_DECREF(capi_module);
    
    if (api_ptr_obj == NULL) {
        return 0;
    }
    
    /* 실제 구현에서는 API 구조체 포인터를 사용 */
    /* 여기서는 간단한 예시만 */
    
    Py_DECREF(api_ptr_obj);
    return 1;
}

/* 파이썬 함수: API를 통한 계산 */
static PyObject* client_calculate(PyObject* self, PyObject* args) {
    double a, b;
    
    if (!PyArg_ParseTuple(args, "dd", &a, &b)) {
        return NULL;
    }
    
    /* API 로드 */
    DynamicAPI api = {0};
    if (!load_dynamic_api(&api)) {
        PyErr_SetString(PyExc_RuntimeError, "API를 로드할 수 없습니다");
        return NULL;
    }
    
    /* 실제 구현에서는 API 함수 사용 */
    /* double result = api.calculate(context, a, b); */
    
    /* 여기서는 더미 결과 반환 */
    double result = a + b;
    
    return PyFloat_FromDouble(result);
}

/* 모듈 메서드 테이블 */
static PyMethodDef ClientModuleMethods[] = {
    {"calculate", client_calculate, METH_VARARGS,
     "C API를 사용하여 계산합니다."},
    {NULL, NULL, 0, NULL}
};

/* 모듈 정의 */
static struct PyModuleDef clientmodule = {
    PyModuleDef_HEAD_INIT,
    "client_module",
    "C API를 사용하는 클라이언트 모듈",
    -1,
    ClientModuleMethods
};

/* 모듈 초기화 */
PyMODINIT_FUNC PyInit_client_module(void) {
    return PyModule_Create(&clientmodule);
}
```

## 결론

파이썬 C 확장 모듈 개발은 성능이 중요한 작업을 가속화하고 기존 C 라이브러리를 파이썬 생태계에 통합하는 강력한 방법입니다. 이 기술 스택은 여러 레벨로 구성되어 있으며 각 레벨마다 다른 사용 사례와 복잡성이 있습니다.

**ctypes**는 가장 접근하기 쉬운 수준으로, 컴파일된 C 공유 라이브러리를 동적으로 로드하고 호출할 수 있습니다. 이 방법은 별도의 컴파일 과정 없이 기존 C 라이브러리를 빠르게 통합할 때 유용하며, 특히 프로토타이핑이나 간단한 인터페이스 구축에 적합합니다. ctypes는 구조체, 콜백 함수, 포인터 연산 등을 지원하지만 타입 안전성이 떨어지고 오류 처리가 복잡할 수 있습니다.

**기본 C 확장 모듈**은 CPython API를 직접 사용하여 네이티브 파이썬 모듈을 작성하는 방법입니다. 이 접근법은 완전한 통합과 최고의 성능을 제공하며, 파이썬 객체와 C 데이터 구조 사이의 변환을 완벽하게 제어할 수 있습니다. 메모리 관리, 예외 처리, 가비지 컬렉션과의 통합 등 파이썬 런타임의 모든 기능을 활용할 수 있습니다. 하지만 CPython API의 학습 곡선이 가파르고 참조 카운트 관리 등 신경 써야 할 부분이 많습니다.

**배열 처리 확장 모듈**은 수치 연산과 데이터 처리에 특화된 확장으로, 특히 NumPy 배열과의 통합이 중요한 영역입니다. 버퍼 프로토콜을 활용하면 파이썬 리스트나 NumPy 배열과 같은 연속 메모리 영역을 효율적으로 처리할 수 있습니다. SIMD 명령어나 다중 스레딩을 활용한 최적화도 이 수준에서 가능합니다. 대규모 데이터 처리와 과학 계산 애플리케이션에서 필수적인 기술입니다.

**불투명한 포인터 관리**는 C 확장 모듈에서 상태를 유지하면서 파이썬 사용자에게 구현 세부사항을 숨기는 고급 패턴입니다. 이 접근법은 복잡한 데이터 구조나 외부 리소스(파일 핸들, 네트워크 연결, 데이터베이스 연결 등)를 관리할 때 유용합니다. 참조 카운트와 올바른 메모리 관리는 이 패턴에서 특히 중요하며, 객체 지향 인터페이스를 제공하면서 내부 구현을 완전히 캡슐화할 수 있습니다.

**C API 정의 및 내보내기**는 확장 모듈 간의 고성능 상호 운용성을 가능하게 합니다. 잘 정의된 C API를 제공하면 다른 C 확장 모듈이 파이썬 객체를 거치지 않고 직접 데이터를 교환하고 함수를 호출할 수 있어 오버헤드를 크게 줄일 수 있습니다. 이는 대규모 확장 모듈 시스템이나 성능이 중요한 라이브러리 집합을 구축할 때 필수적입니다. 버전 관리, ABI 호환성, 메모리 관리 계약 등의 고려사항이 필요합니다.

실제 프로젝트에서 이러한 기술들을 선택할 때는 다음 사항을 고려해야 합니다:

1. **성능 요구사항**: 최대 성능이 필요하면 C 확장 모듈, 빠른 통합이 필요하면 ctypes
2. **유지보수성**: CPython API는 복잡하지만 강력함, ctypes는 간단하지만 제한적
3. **호환성**: Python 버전 간 호환성, 플랫폼 간 이식성
4. **배포 용이성**: 바이너리 배포의 복잡성 vs 소스 배포의 단순성
5. **생태계 통합**: NumPy, SciPy 등과의 호환성

최근에는 Cython, PyBind11, cffi와 같은 도구들이 이러한 기술들의 복잡성을 추상화하여 더 쉽게 C 확장을 작성할 수 있게 해주지만, 근본적인 개념을 이해하는 것은 여전히 중요합니다. 또한 Rust나 Go와 같은 다른 언어로 파이썬 확장을 작성하는 새로운 접근법들도 등장하고 있어 생태계가 계속 발전하고 있습니다.

성공적인 C 확장 모듈 개발의 핵심은 견고한 메모리 관리, 철저한 오류 처리, 명확한 API 설계, 그리고 포괄적인 테스트입니다. 이러한 기본 원칙들을 준수하면 파이썬의 생산성과 C의 성능을 결합한 강력한 솔루션을 구축할 수 있습니다.