---
layout: post
title: Svelte - 고급 토픽 (1)
date: 2025-10-08 16:30:23 +0900
category: Svelte
---
# 고급 토픽 (1) — **커스텀 Vite 플러그인/프리프로세서 · 웹 컴포넌트(Custom Elements)로 내보내기**

> 이 장에서는 **SvelteKit** 프로젝트에서  
> 1) **커스텀 Vite 플러그인/프리프로세서**를 직접 만들어 Svelte 코드 전처리·빌드 파이프라인을 커스터마이즈하고,  
> 2) **Svelte 컴포넌트를 웹 컴포넌트(Custom Elements)**로 빌드해서 **리액트/바닐라/다른 프레임워크**에서도 재사용하는 법을 다룬다.  
> 모든 예제는 **TypeScript** 기반이며, 실제로 복붙해 실행 가능한 수준으로 제공한다.

---

## 17.1 커스텀 Vite 플러그인 — 개념부터 바로 실전

### 17.1.1 왜 커스텀 플러그인인가?
- **소스 전처리**(예: 특정 지시어 변환, `i18n` 키 인라인, feature-flag)  
- **가상 모듈 제공**(가짜 경로에서 빌드 타임 생성 데이터 노출: `virtual:config`)  
- **리소스 로더/리라이터**(마크다운/데이터 파일 → Svelte 코드로 변환)  
- **빌드 후 결과물 후처리**(메타파일 조작, 번들 스냅샷 생성)

> Vite 플러그인은 Rollup 플러그인 모델을 계승한다. `transform`, `resolveId`, `load`, `configureServer`, `generateBundle` 등의 훅을 제공한다.

---

### 17.1.2 예제 A — **@i18n("key") 지시어를 $t('key') 코드로 치환**
목표: 템플릿/스크립트에서 **경량 i18n 지시어**인 `@i18n("...")`를 **컴파일 시점**에 `$t("...")` 로 치환하고, 필요한 경우 `$lib/i18n` 모듈을 자동 import.

**1) 간단 i18n 유틸**
```ts
// src/lib/i18n.ts
export type Dict = Record<string, string>;
let dict: Dict = {
  'app.hello': '안녕하세요',
  'app.items': '{n}개 항목'
};

export function t(key: string, vars: Record<string, any> = {}) {
  let s = dict[key] ?? key;
  for (const k in vars) s = s.replace(new RegExp(`\\{${k}\\}`, 'g'), String(vars[k]));
  return s;
}

// 런타임에서 사전 교체 가능
export function setDict(next: Dict){ dict = next; }
export const $t = t; // Svelte에서 import 이름 짧게 사용
```

**2) 플러그인 구현**
```ts
// plugins/vite-plugin-i18n-directive.ts
import type { Plugin } from 'vite';

const I18N_RE = /@i18n\s*\(\s*(['"`])([^'"`]+)\1\s*(?:,\s*({[\s\S]*?}))?\s*\)/g;

export function i18nDirective(): Plugin {
  return {
    name: 'i18n-directive',
    enforce: 'pre', // svelte 전처리 전에 동작
    transform(code, id) {
      // svelte/ts/js 파일만
      if (!/\.(svelte|ts|js)$/.test(id)) return;

      let mutated = code;
      let needsImport = false;

      mutated = mutated.replace(I18N_RE, (_, q, key, vars) => {
        needsImport = true;
        return vars ? `$t(${JSON.stringify(key)}, ${vars})` : `$t(${JSON.stringify(key)})`;
      });

      if (needsImport && !mutated.includes("from '$lib/i18n'")) {
        // <script> 블록이 있다면 끝 부분에 import 추가
        if (id.endsWith('.svelte')) {
          // <script> 블록이 없다면 하나 생성
          if (!/<script[\s\S]*?>/.test(mutated)) {
            mutated = `<script lang="ts">import { $t } from '$lib/i18n';</script>\n` + mutated;
          } else {
            mutated = mutated.replace(/<script([\s\S]*?)>([\s\S]*?)<\/script>/, (m, attrs, body) => {
              if (body.includes("from '$lib/i18n'")) return m;
              return `<script${attrs}>import { $t } from '$lib/i18n';\n${body}</script>`;
            });
          }
        } else {
          // ts/js 파일이면 최상단에 import
          mutated = `import { $t } from '$lib/i18n';\n` + mutated;
        }
      }

      if (mutated !== code) {
        return { code: mutated, map: null };
      }
    },
  };
}
```

**3) Vite에 장착**
```ts
// vite.config.ts
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';
import { i18nDirective } from './plugins/vite-plugin-i18n-directive';

export default defineConfig({
  plugins: [i18nDirective(), sveltekit()]
});
```

**4) 사용 예**
```svelte
<!-- src/routes/+page.svelte -->
<h1>{@html @i18n("app.hello")}</h1>
<p>{@html @i18n("app.items", { n: 12 })}</p>
```

> 빌드 결과에서는 `$t('app.hello')`, `$t('app.items', { n:12 })`로 바뀌며, 자동으로 `import { $t } from '$lib/i18n'`가 주입된다.

---

### 17.1.3 예제 B — **가상 모듈(virtual:build-meta) 제공**
목표: **빌드 날짜/브랜치/버전** 같은 메타 정보를 **가상 모듈**로 노출하여 앱에서 쉽게 표시.

```ts
// plugins/vite-plugin-build-meta.ts
import type { Plugin } from 'vite';
import { execSync } from 'node:child_process';

const ID = 'virtual:build-meta';

export function buildMeta(): Plugin {
  let resolvedId = '\0' + ID;
  return {
    name: 'build-meta',
    resolveId(id) {
      if (id === ID) return resolvedId;
    },
    load(id) {
      if (id === resolvedId) {
        const commit = safe(() => execSync('git rev-parse --short HEAD').toString().trim(), 'unknown');
        const branch = safe(() => execSync('git rev-parse --abbrev-ref HEAD').toString().trim(), 'unknown');
        const date = new Date().toISOString();
        // ESM 모듈 소스 리턴
        return `export const BUILD_COMMIT=${JSON.stringify(commit)};
export const BUILD_BRANCH=${JSON.stringify(branch)};
export const BUILD_DATE=${JSON.stringify(date)};`;
      }
    }
  };
}

function safe<T>(fn: ()=>T, fallback:T){
  try { return fn(); } catch { return fallback; }
}
```

```ts
// vite.config.ts
import { defineConfig } from 'vite';
import { sveltekit } from '@sveltejs/kit/vite';
import { buildMeta } from './plugins/vite-plugin-build-meta';
export default defineConfig({
  plugins: [buildMeta(), sveltekit()]
});
```

```svelte
<!-- src/routes/+layout.svelte -->
<script lang="ts">
  import { BUILD_COMMIT, BUILD_BRANCH, BUILD_DATE } from 'virtual:build-meta';
</script>

<footer class="foot">
  <small>Build {BUILD_BRANCH}@{BUILD_COMMIT} • {new Date(BUILD_DATE).toLocaleString()}</small>
</footer>
```

---

### 17.1.4 예제 C — **마크다운을 Svelte 모듈로 변환하는 로더(초간단)**
실전에서는 `mdsvex` 권장. 여기서는 **개념 시연**으로 **Frontmatter + 본문**을 **Svelte 컴포넌트**로 변환하는 플러그인 샘플.

```ts
// plugins/vite-plugin-md-svelte.ts
import type { Plugin } from 'vite';
import matter from 'gray-matter';

export function mdAsSvelte(): Plugin {
  return {
    name: 'md-as-svelte',
    enforce: 'pre',
    transform(code, id) {
      if (!id.endsWith('.md')) return;
      const { content, data } = matter(code);
      // 매우 단순 — 실제로는 마크다운 -> HTML 렌더 필요
      const html = content
        .split('\n')
        .map(line => line ? `<p>${escapeHtml(line)}</p>` : '')
        .join('\n');

      const svelte = `
<script lang="ts">
  export let metadata = ${JSON.stringify(data)};
</script>

<article class="prose">
  ${html}
</article>
`;
      return { code: svelte, map: null };
    }
  };
}
function escapeHtml(s: string){
  return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]!));
}
```

```ts
// vite.config.ts
import { defineConfig } from 'vite';
import { sveltekit } from '@sveltejs/kit/vite';
import { mdAsSvelte } from './plugins/vite-plugin-md-svelte';

export default defineConfig({
  plugins: [mdAsSvelte(), sveltekit()]
});
```

사용:
```svelte
<!-- src/routes/post/+page.svelte -->
<script>
  // 실제로는 import.meta.glob으로 여러 파일 처리
  import Post from '$content/example.md';
</script>

<Post let:metadata>
  <!-- mdAsSvelte는 <slot>은 없지만 metadata prop은 제공 -->
</Post>
```

---

## 17.2 Svelte **프리프로세서** 만들기 — 마크업/스크립트/스타일 조작

Svelte 프리프로세서는 **Svelte 컴파일러 이전**에 **`.svelte` 소스**를 직접 조작한다.  
인터페이스는 다음과 같다:

```ts
type PreprocessorGroup = {
  markup?: (opts: { content: string; filename: string }) => { code: string; map?: any } | Promise<...>;
  script?: (opts: { content: string; attributes: Record<string, any>; filename: string }) => { code: string; map?: any } | Promise<...>;
  style?: (opts: { content: string; attributes: Record<string, any>; filename: string }) => { code: string; map?: any } | Promise<...>;
};
```

### 17.2.1 예제 D — **@feature 블록을 빌드 플래그로 제거/유지**
목표: `<Feature name="beta">...</Feature>` 같은 블록을 **환경 변수**로 토글.

```ts
// preprocess/feature-gate.ts
import type { PreprocessorGroup } from 'svelte/compiler';

export function featureGatePreprocess(flags: Record<string, boolean>): PreprocessorGroup {
  return {
    markup({ content, filename }) {
      // 아주 단순한 문자열 치환(정규식) — 실제로는 파서 기반을 권장
      // <Feature name="beta">...</Feature> 를 flags.beta ? 내용 유지 : 제거
      const re = /<Feature\s+name=["']([\w-]+)["']\s*>([\s\S]*?)<\/Feature>/g;

      const code = content.replace(re, (_, name: string, body: string) => {
        return flags[name] ? body : '';
      });

      return { code };
    }
  };
}
```

`vite.config.ts`에서 장착:
```ts
// svelte.config.js 또는 vite.config.ts의 svelte preprocess에 연결
import preprocess from 'svelte-preprocess';
import { featureGatePreprocess } from './preprocess/feature-gate.js';

export default {
  preprocess: [
    preprocess(),
    featureGatePreprocess({
      beta: process.env.VITE_FEATURE_BETA === 'true',
      // 필요한 플래그 추가
    })
  ],
  // ...
}
```

사용:
```svelte
<!-- src/lib/components/Example.svelte -->
<Feature name="beta">
  <div class="beta-only">이 영역은 beta 플래그에서만 보입니다.</div>
</Feature>
```

빌드 시 `VITE_FEATURE_BETA=false`라면 아예 코드에서 제거되어 번들 크기/분기비용이 줄어든다.

---

### 17.2.2 예제 E — **템플릿 안에서 @@env.VAR → import.meta.env.VAR 치환**
```ts
// preprocess/env-inline.ts
import type { PreprocessorGroup } from 'svelte/compiler';

export function envInline(): PreprocessorGroup {
  const RE = /@@env\.([A-Z0-9_]+)/g;
  return {
    markup({ content }) {
      const code = content.replace(RE, (_, key) => `\${import.meta.env.${key}}`); // 템플릿 위치 대응
      return { code };
    },
    script({ content }) {
      const code = content.replace(RE, (_, key) => `import.meta.env.${key}`);
      return { code };
    }
  };
}
```

템플릿 사용:
```svelte
<script>
  const api = @@env.VITE_PUBLIC_API; // -> import.meta.env.VITE_PUBLIC_API
</script>

<p>API: {@@env.VITE_PUBLIC_API}</p>
```

---

### 17.2.3 프리프로세서 vs Vite 플러그인 — 선택 가이드
- **Svelte 파일 내부 구문을 바꾸는 일** → 프리프로세서가 적합  
- **언어/파일 확장/가상 모듈/번들 후처리** → Vite 플러그인이 적합  
- 경우에 따라 **둘을 조합**: 프리프로세서로 Svelte 소스 변형 → Vite 플러그인으로 나머지 로더·메타 구성

---

## 17.3 **웹 컴포넌트(Custom Elements)** 로 내보내기

### 17.3.1 Svelte에서 Custom Element로 컴파일
Svelte는 **컴파일 옵션**으로 `customElement: true`를 지원한다.  
컴포넌트에서 선언적으로 사용하려면:

```svelte
<!-- src/lib/elements/MyCounter.svelte -->
<svelte:options tag="my-counter" customElement={true} />

<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  const dispatch = createEventDispatcher();

  export let step = 1;            // attribute <-> prop 바인딩됨 (문자열 → 수 변환 주의)
  let count = 0;

  function inc(){ count += Number(step) || 1; dispatch('change', { value: count }); }
  function dec(){ count -= Number(step) || 1; dispatch('change', { value: count }); }
</script>

<style>
:host { display: inline-block; border:1px solid #e5e7eb; border-radius:8px; padding:.4rem .6rem; }
button { margin: 0 .2rem; }
::slotted(strong) { color: #2563eb; } /* 슬롯 content 스타일 */
</style>

<div>
  <slot name="label"><span>Count</span></slot>
  : {count}
  <button on:click={dec}>-</button>
  <button on:click={inc}>+</button>
</div>
```

> 핵심:  
> - `<svelte:options tag="my-counter" customElement>`: 컴파일 결과가 **CustomElement 클래스**가 되고, **shadow DOM**을 사용한다.  
> - `export let step` 같은 **prop**은 **HTML attribute**로도 연동된다. (문자열 → 수 변환 직접 처리)  
> - 이벤트는 `dispatch('change', { value })` → DOM의 `CustomEvent('change', { detail })` 로 발행.

---

### 17.3.2 라이브러리 모드로 빌드(ESM + IIFE 번들)
Vite로 **라이브러리 모드**를 설정해 단일 번들을 만든다.

```ts
// vite.webc.config.ts (웹 컴포넌트 빌드 전용)
import { defineConfig } from 'vite';
import { svelte } from '@sveltejs/vite-plugin-svelte';

// SvelteKit 프로젝트와 별도 config로 분리해도 되고, rollupOptions로 entry만 추가해도 된다.
export default defineConfig({
  build: {
    lib: {
      entry: 'src/lib/elements/MyCounter.svelte',
      name: 'MyCounter',
      fileName: (format) => `my-counter.${format}.js`,
      formats: ['es','iife']
    },
    rollupOptions: {
      // 외부 의존성 제거(없으면 비움)
    },
    sourcemap: true,
    target: 'es2019'
  },
  plugins: [
    svelte({
      compilerOptions: { customElement: true } // 전역 CE 빌드
    })
  ]
});
```

빌드:
```bash
vite build -c vite.webc.config.ts
# dist/my-counter.es.js / my-counter.iife.js 생성
```

**배포/사용**(바닐라 페이지):
```html
<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <script type="module" src="/dist/my-counter.es.js"></script>
  </head>
  <body>
    <my-counter step="2">
      <strong slot="label">Clicks</strong>
    </my-counter>

    <script>
      const el = document.querySelector('my-counter');
      el.addEventListener('change', (e) => console.log('changed:', e.detail.value));
      // JS API
      el.step = 5; // prop으로도 접근 가능
    </script>
  </body>
</html>
```

> **shadow DOM** 덕분에 스타일 격리가 자동으로 된다. 외부 스타일과 충돌이 줄어든다.

---

### 17.3.3 여러 컴포넌트를 하나의 번들로 제공
```ts
// src/lib/elements/index.ts
import Counter from './MyCounter.svelte';
import Toast from './MyToast.svelte';
import Badge from './MyBadge.svelte';

export { Counter, Toast, Badge }; // 개별 import용

// 자동 정의(선택) — 단, CE는 사이드이펙트가 있을 수 있으니 필요 시 주석 처리
customElements.define('my-counter', Counter);
customElements.define('my-toast', Toast);
customElements.define('my-badge', Badge);
```

```ts
// vite.webc.config.ts
import { defineConfig } from 'vite';
import { svelte } from '@sveltejs/vite-plugin-svelte';

export default defineConfig({
  build: {
    lib: {
      entry: 'src/lib/elements/index.ts',
      name: 'MyElements',
      fileName: (format) => `my-elements.${format}.js`,
      formats: ['es','iife']
    },
    sourcemap: true
  },
  plugins: [
    svelte({ compilerOptions: { customElement: true } })
  ]
});
```

사용:
```html
<script type="module" src="/dist/my-elements.es.js"></script>
<my-badge>Hi</my-badge>
<my-toast message="Saved!"></my-toast>
```

---

### 17.3.4 **속성/프로퍼티 변환 규칙 & 타입 주의사항**
- **문자열 속성 → 문자열**: `<el foo="bar">` → `el.foo === 'bar'`  
- **숫자/불리언**: HTML 속성은 문자열이므로, 컴포넌트 내부에서 반드시 `Number(step)` 또는 `step === true || step === 'true'` 같은 **변환**을 수행하자.  
- **객체/배열**: 속성으로 직렬화가 번거롭다. 추천: **JS에서 프로퍼티로 할당**하거나, **JSON 문자열**로 받은 뒤 `JSON.parse` 한다.
- **이벤트**: `dispatch('evt', { a:1 })` → DOM에서는 `new CustomEvent('evt', { detail:{a:1} })`로 수신.

---

### 17.3.5 **슬롯/스타일** — Shadow DOM 팁
- `:host` : 요소 자신 스타일  
- `::slotted(*)` : 외부 슬롯 콘텐츠 스타일  
- `:host([variant="outline"])` : CE의 속성에 따른 변형  
- 글로벌 스타일 주입이 필요하면 **Shadow Parts**(part/::part)나 **CSS 커스텀 프로퍼티**를 제공

예:
```svelte
<style>
:host { --badge-bg: #f1f5f9; --badge-fg: #334155; }
.badge { background: var(--badge-bg); color: var(--badge-fg); }
::slotted(a){ text-decoration: underline; }
</style>
```

---

### 17.3.6 **리액트/뷰/바닐라**에서 사용
- **React**: CE는 기본적으로 동작. 단, **이벤트명**은 `onchange`처럼 **소문자**가 아니라 **커스텀 이벤트**이므로, `onChange` 대신 **`onchange`** 또는 **`ref`로 addEventListener**를 붙인다.  
  또한 React 18에서는 **속성→prop 반영**이 다르게 작동할 수 있으니, **프로퍼티 셋터**를 선호한다.

```tsx
// React 예시
import { useEffect, useRef } from 'react';
import '/dist/my-counter.es.js';

export default function CounterCard(){
  const ref = useRef<any>(null);
  useEffect(() => {
    const el = ref.current;
    function onChange(e:any){ console.log('react change', e.detail.value); }
    el?.addEventListener('change', onChange);
    return () => el?.removeEventListener('change', onChange);
  }, []);
  return <my-counter ref={ref} step={3}></my-counter>;
}
```

- **Vue**: `<my-counter @change="onChange" :step="3"/>` 처럼 커스텀 이벤트와 prop 바인딩을 그대로 사용 가능.  
- **바닐라**: 위 HTML 예제처럼 `<script type="module" ...>` 로 끼워 넣으면 끝.

---

### 17.3.7 번들 크기/퍼포먼스 체크리스트
- `compilerOptions.dev=false`로 빌드  
- 공통 의존성(예: date-fns 등)이 있다면 외부화 옵션 고려(`rollupOptions.external`) — 소비자가 직접 로드  
- 여러 컴포넌트를 **코드 스플리팅**하려면 **각 CE를 개별 entry**로 제공  
- SSR이 필요 없는 순수 CE 패키지는 **Vite 라이브러리 모드**가 간단

---

### 17.3.8 배포 & 타입 제공
- `package.json`에 `types` 필드 제공(컴포넌트 prop 타입 선언)  
- TS 타입은 **Svelte 4/5의 d.ts 생성** 또는 **수동 작성**  
- 예를 들어 `MyCounter.svelte` prop 타입을 노출하고 싶다면:

```ts
// src/lib/elements/MyCounter.svelte.d.ts (간단 수동)
export interface MyCounterProps {
  step?: number | string;
}
export default class MyCounterElement extends HTMLElement {
  step: number | string;
}
```

`package.json`:
```json
{
  "name": "@your-scope/my-elements",
  "version": "0.1.0",
  "type": "module",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/my-elements.es.js",
      "default": "./dist/my-elements.iife.js"
    }
  },
  "types": "./dist/index.d.ts"
}
```

---

## 17.4 종합 예제 — **SvelteKit 앱 + CE 라이브러리 동시 제공**

목표: 하나의 레포에서  
- `/app` : SvelteKit 애플리케이션  
- `/packages/elements` : 웹 컴포넌트 라이브러리(독립 번들)  
구조(모노레포/PNPM 워크스페이스 권장):

```
root/
  apps/web/                # SvelteKit
  packages/elements/       # CE 패키지
  pnpm-workspace.yaml
```

`packages/elements` 내부:
- `src/lib/elements/*.svelte` (CE 컴포넌트)
- `vite.config.ts` (라이브러리 모드)
- `package.json` (exports/types)

`apps/web`에서:
- dev 중에는 `pnpm -F @your-scope/elements build --watch`로 CE 번들을 **로컬 링크**하고,  
- 애플리케이션에서 `<script type="module" src="/node_modules/@your-scope/elements/dist/...">` 혹은 **esm import**로 사용.

---

## 17.5 트러블슈팅

1) **React에서 커스텀 이벤트가 안 잡혀요**  
   - React는 **DOM 커스텀 이벤트 → SyntheticEvent** 변환을 안 해준다.  
   - **`ref + addEventListener`**로 직접 바인딩하거나, **래퍼 컴포넌트**를 만든다.

2) **속성 값 타입이 항상 문자열**  
   - 브라우저 표준이다. 컴포넌트 내부에서 변환(`Number()`, JSON.parse 등).  
   - 또는 **프로퍼티**로만 값을 받을 것을 문서화.

3) **스타일 오버라이드**  
   - Shadow DOM 때문에 외부 CSS가 안 먹는다.  
   - **CSS custom properties**, **::part**/**part** API 제공을 추천.

```svelte
<!-- CE 내부 -->
<div part="label"><slot name="label"/></div>
<style>
  .chip { color: var(--chip-fg, #111); background: var(--chip-bg, #eee); }
</style>
```

```css
/* 소비자 측 */
my-badge::part(label){ font-weight:700; }
my-badge { --chip-bg: #ffe; --chip-fg: #c60; }
```

4) **Svelte 5(룬즈)와 CE**  
   - CE 자체는 **컴파일 옵션**이라 v4/v5 모두 가능.  
   - 단, **룬즈($state 등)** 사용 시 **빌드 타깃 환경**(브라우저만) 고려.

---

## 17.6 보너스 — **수학적(형식적) 템플릿 규칙 정의**(선택)
빌드 타임 치환 규칙을 형식적으로 적으면 유지보수에 도움이 된다.  
예를 들어, i18n 지시어 변환 규칙을 **BNF** 비슷하게:

$$
\begin{aligned}
\text{Directive} &::= @i18n(\ \text{String}\ [,\ \text{Object}]\ ) \\
\text{Transform}(@i18n("k")) &= \$t("k") \\
\text{Transform}(@i18n("k",\ O)) &= \$t("k",\ O)
\end{aligned}
$$

> 위처럼 **정의(Definition)**를 문서에 포함하면 팀 내 합의와 리뷰에 큰 도움이 된다.

---

## 17.7 마무리 요약 & 체크리스트

- **커스텀 Vite 플러그인**
  - [x] 지시어 치환(@i18n → `$t`)  
  - [x] 가상 모듈(virtual:build-meta)  
  - [x] 간이 마크다운 로더

- **프리프로세서**
  - [x] Feature-gate 블록 제거/유지  
  - [x] @@env.VAR 인라인 치환

- **웹 컴포넌트(Custom Elements)**
  - [x] `<svelte:options tag="...">` + `customElement`  
  - [x] 속성/프로퍼티/이벤트/슬롯/스타일 가이드  
  - [x] 라이브러리 모드 번들(ESM/IIFE)  
  - [x] React/Vue/바닐라 통합 팁

---

## 17.8 다음 단계 제안
- **플러그인 테스트**: Vitest로 `transform` 스냅샷 테스트  
- **CE 패키지 배포 자동화**: Changesets + GitHub Actions  
- **MDX/문서 컴포넌트**를 CE로도 공급하여 **프레임워크 불문** 한 번에 배포  
- **SSR 무관 UI 원자들**(Badge/Tooltip/Modal)을 CE로 표준화 → 디자인 시스템 베이스
