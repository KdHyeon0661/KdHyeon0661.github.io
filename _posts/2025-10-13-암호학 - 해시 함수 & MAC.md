---
layout: post
title: 암호학 - 해시 함수 & MAC
date: 2025-10-13 16:30:23 +0900
category: 암호학
---
# 해시 함수 & MAC (🔰→⚙️)

> 이 장은 **해시 보안 속성(충돌·2nd-프리이미지·프리이미지)** → **SHA-2/3(Keccak) 개관 & 길이 확장 공격 직관** → **MAC 실전(HMAC, KMAC, GMAC)과 미스유스 패턴**을 한 번에 정리합니다.
> 코드는 Python 표준 `hashlib`, `hmac`, 그리고 `cryptography`(선택)를 사용합니다. 실무에서는 **직접 구현을 피하고 검증된 라이브러리**만 사용하세요.

---

## ✅ 6.1 해시 함수의 보안 속성

### 정의

- (비암호) **해시 함수** \(h:\{0,1\}^\*\to\{0,1\}^n\)**:** 임의 길이 입력 → 고정 길이 \(n\) 출력.
- **암호학적 해시**는 아래 세 가지에 **현실적으로 강해야** 합니다.

### 세 가지 보안 목표

1) **충돌 저항(Collision resistance)**
   서로 다른 \(x\neq x'\)에 대해 \(h(x)=h(x')\) 를 찾기 **어렵다**.
   - 공격 복잡도: 이상적일 때 **생일 역설**로 **\(\sim 2^{n/2}\)**.
2) **2번째 프리이미지(second preimage) 저항**
   임의의 고정 \(x\)가 주어졌을 때, \(x'\neq x\)이고 \(h(x)=h(x')\)를 찾기 **어렵다**.
   - 이상적일 때 **\(\sim 2^{n}\)**.
3) **프리이미지(preimage) 저항**
   임의의 해시값 \(y\)에 대해 \(h(x)=y\)를 만족하는 \(x\)를 찾기 **어렵다**.
   - 이상적일 때 **\(\sim 2^{n}\)**.

> **주의**: “충돌 난이도는 \(2^{n/2}\)”(생일 한계)라서, **256비트 해시**도 충돌 저항 관점에서는 약 **128비트 등가**로 봅니다.

---

## 개관

### SHA-2 (SHA-224/256/384/512 …)

- 구조: **Merkle–Damgård** 계열(블록 압축 반복).
- 입력을 패딩(‘1’ + 0.. + 길이) → 512/1024비트 블록 단위로 압축 → 마지막 출력.
- 대표: **SHA-256**, **SHA-512**.

**파이썬 예**
```python
import hashlib
m = hashlib.sha256()
m.update(b"hello ")
m.update(b"world")
print("SHA-256:", m.hexdigest())
print("SHA-512:", hashlib.sha512(b"hello world").hexdigest()[:64], "…")
```

### — 스펀지(Sponge) 구조

- **스펀지 함수**: 상태 \(S\)를 ‘흡수(absorb)→짜내기(squeeze)’ 방식으로 운영.
- 보안 분석 기반이 SHA-2와 다르며, **길이 확장 공격**에 대한 동일 취약 모델이 적용되지 않음(§6.3 참고).
- 변형: `sha3_224/256/384/512` + 확장출력 **SHAKE128/256**.

```python
print("SHA3-256:", hashlib.sha3_256(b"hello world").hexdigest())
# XOF 예: 필요 길이만큼 뽑기

shake = hashlib.shake_256(b"hello world")
print("SHAKE-256 32B:", shake.digest(32).hex())
```

---

## 직관

### 왜 발생하나 (Merkle–Damgård)

- SHA-2 같은 **MD 계열**은 “**(이전 상태, 블록)** → 새 상태” 형태로 **반복 압축**합니다.
- **`MAC = H(secret || message)`** 를 쓰면, 공격자는 **`message`와 MAC을 알고 있을 때**
  1) `message`의 **패딩을 추정**하고,
  2) 임의의 `suffix`를 **추가로 흡수**한 상태를 **시뮬레이션**해,
  3) **새로운 MAC**(= 해시값)을 계산할 수 있습니다. **(secret을 몰라도!)**

> 즉, **prefix MAC(비밀||메시지)** 는 MD 구조에서 **길이 확장 취약**.
> **대응**: **HMAC** 사용(§6.4), 또는 SHA-3/KMAC 같은 스펀지 기반 키드 해시 사용.

### 직관 예시(설명용)

- 서버가 `MAC = SHA256(secret || msg)` 를 저장/검증한다고 가정.
- 공격자는 `msg`를 알고 있고 `MAC`도 본 상태에서 `msg || padding || ";admin=1"` 같은 `suffix`를 덧붙여 **유효 MAC**을 위조 가능(길이와 패딩 규칙만 알면 됨).
- 많은 라이브러리가 이 공격을 쉽게 재현하는 도구를 제공(여기서는 원리만 설명).

---

## ✅ 6.4 MAC: HMAC, KMAC, GMAC — 무엇을 언제 쓰나

### MAC란?

- **Message Authentication Code**: **무결성**과 **인증**을 보장하는 태그.
- 키 \(K\)와 메시지 \(M\)으로 태그 \(T=\mathrm{MAC}_K(M)\) 생성.
- 검증은 \(\mathrm{Vrfy}_K(M,T)\to\{\text{accept},\text{reject}\}\).

### — 기본값

- 구조:
  \[
  \mathrm{HMAC}_K(M) = H\big((K\oplus \mathrm{opad})\parallel H((K\oplus \mathrm{ipad})\parallel M)\big)
  \]
  (여기서 \(H\)는 SHA-256 등)
- 특징: MD 구조의 **길이 확장 공격에 안전**하도록 설계됨.
- 키 길이는 해시 블록 크기(예: SHA-256은 64B) 이상이면 내부에서 해시하여 맞춤.

**파이썬 예 (HMAC-SHA256)**
```python
import hmac, hashlib
key = b"\x01"*32
msg = b"pay=1000&to=bob"

tag = hmac.new(key, msg, hashlib.sha256).digest()
print("tag:", tag.hex())

# 검증(상수시간 비교)

cand = hmac.new(key, msg, hashlib.sha256).digest()
ok = hmac.compare_digest(tag, cand)
print("verify:", ok)
```

> **실무 규칙**: MAC 비교는 **`hmac.compare_digest`** 로 **상수시간** 비교. `==` 금지.

---

### — 스펀지 기반 MAC

- 표준: **KMAC128/256** (NIST SP 800-185, cSHAKE 기반).
- 입력: 키/데이터/도메인 문자열(Customization string) → 스펀지로 흡수 → 태그.
- 장점: 스펀지 구조 특성상 MD 계열의 길이 확장 취약성과 **다른 보안 모델**.
- 용도: SHA-3 환경/스펀지 기반 생태를 선호할 때.

> 파이썬 표준 라이브러리에 KMAC가 직접 없으므로(2025 시점 라이브러리 의존), 실무에서는 **공식 구현/라이브러리**를 사용하세요.

---

### GMAC — GCM의 MAC 성분만

- **GMAC** = **GCM**(AES-GCM)의 암호화 부분을 비워두고 **인증만** 수행하는 모드.
- 입력: 키 \(K\), Nonce(IV), AAD. (평문 길이 0) → **태그만** 출력.
- 용도: **메시지는 암호화하지 않고** 헤더/메타데이터의 **무결성만 보장**하고 싶을 때.
- 주의: **Nonce 고유성** 제약은 GCM과 **동일**(재사용 †).

**파이썬 (GMAC처럼 쓰기: AAD만 넣고 데이터는 빈 바이트)**
```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

key   = AESGCM.generate_key(bit_length=128)
aes   = AESGCM(key)
nonce = os.urandom(12)
aad   = b"hdr:route=/v1 amount=1000"

# "GMAC" 스타일: 데이터는 빈 값

tag_only_ciphertext = aes.encrypt(nonce, b"", aad)  # 여기서 반환값은 tag 그 자체(라이브러리 표현상 ct||tag 이지만 ct=공집합)
# 검증

aes.decrypt(nonce, tag_only_ciphertext, aad)        # OK면 무결성 통과
```

> 일부 구현은 **순수 GMAC API**(태그만)를 별도 제공. 핵심은 **Nonce 재사용 금지**와 **태그 길이(128비트 권장)**.

---

## ✅ 6.5 위험한 패턴: “MAC-then-Encrypt” 등

### 세 방식 비교

- **Encrypt-then-MAC (EtM)**: `C=Enc_K1(M)`, `T=MAC_K2(AAD || C)` → **권장**
  - 검증 시 **MAC 먼저** 확인 후 복호. CCA에 강함.
- **Encrypt-and-MAC (E&M)**: `C=Enc_K1(M)`, `T=MAC_K2(AAD || M)` → 조건부 안전(분리/독립 필요).
- **MAC-then-Encrypt (MtE)**: `T=MAC_K2(M)`, `C=Enc_K1(M || T)` → 과거 여러 취약 사례(패딩/서명 오라클 등)
  - CBC와 결합 시 **패딩 오라클**로 이어지기 쉬움.

> **실무 기본**: **AEAD**(GCM, ChaCha20-Poly1305)를 사용하면 내부적으로 “**Enc+Auth**”가 올바른 순서로 묶입니다. 직접 조합하지 마세요.

---

## ✅ 6.6 해시 & MAC 실습 모음

### 간단 해시 API (SHA-256/3)

```python
import hashlib
print(hashlib.sha256(b"abc").hexdigest())
print(hashlib.sha3_256(b"abc").hexdigest())
```

### 스트리밍 해시(조각 업데이트)

```python
m = hashlib.sha256()
for chunk in [b"large ", b"file ", b"parts"]:
    m.update(chunk)
print(m.hexdigest())
```

### HMAC 사용/검증 패턴(상수시간 비교)

```python
import hmac, hashlib
def hmac_tag(key: bytes, msg: bytes) -> bytes:
    return hmac.new(key, msg, hashlib.sha256).digest()

def verify_tag(key: bytes, msg: bytes, tag: bytes) -> bool:
    return hmac.compare_digest(hmac_tag(key, msg), tag)

K = b"\x00"*32
M = b"transfer=1000&to=alice"
T = hmac_tag(K, M)
assert verify_tag(K, M, T)
```

### GMAC 스타일(AES-GCM의 인증만)

```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os
key = AESGCM.generate_key(bit_length=256)
gcm = AESGCM(key)
nonce = os.urandom(12)
aad = b"device=42;ts=1732240000"
# 데이터는 공집합 → 태그만 생성

tag_ct = gcm.encrypt(nonce, b"", aad)
gcm.decrypt(nonce, tag_ct, aad)  # 검증
```

---

## ✅ 6.7 파라미터 & 선택 가이드 (2025 감각)

- **해시 선택**
  - 일반 목적: **SHA-256**(폭넓은 호환).
  - 장문/XOF 필요: **SHAKE256**(출력 길이 가변).
  - SHA-3 생태/스펀지 장점 필요: **SHA3-256/512**.

- **MAC 선택**
  - 기본: **HMAC-SHA256**.
  - SHA-3 생태: **KMAC128/256**.
  - AEAD 환경 헤더 인증: **GMAC**(Nonce 관리 주의, 태그 128b).

- **태그 길이**
  - HMAC: 출력 전부 사용(예: 32바이트).
  - GCM/GMAC/ChaCha20-Poly1305: **128비트** 권장(짧게 자르면 위조 확률↑).

---

## ✅ 6.8 실무 체크리스트

- [ ] **H(secret‖msg)** **금지**(길이 확장 취약). **HMAC/KMAC** 사용
- [ ] **상수시간 비교**(`hmac.compare_digest`)
- [ ] **AEAD 우선**: 암호화+무결성 동시 보장(GCM/ChaCha20-Poly1305)
- [ ] **Nonce 고유성**(GCM/GMAC/ChaCha20-Poly1305) — **재사용 금지**
- [ ] **AAD로 헤더/버전/라우팅** 보호(암호화 X, 무결성 O)
- [ ] **태그/키/Nonce 로그 금지**. 에러 메시지 균일화(태그 실패 시 정보 누설 X)

---

## ✅ 6.9 흔한 함정(미스유스)

1) **MAC-then-Encrypt** + CBC → 패딩/오라클/타이밍 누설
2) **길이 확장 취약** MAC: `SHA256(secret||msg)`을 서명처럼 사용
3) **태그 `==` 비교** → 타이밍 채널
4) **Nonce 재사용(GCM/GMAC)** → 위조/무결성 붕괴
5) **해시로 비밀번호 저장**(단순 SHA-256) → 무차별 대입·레인보우 테이블에 취약
   - 대책: **KDF(Argon2id/scrypt/PBKDF2)** 를 사용(4장 참고)

---

## ✅ 6.10 요약 카드

- **세 속성**: 충돌(\(\sim 2^{n/2}\)) / 2nd-프리이미지(\(\sim 2^n\)) / 프리이미지(\(\sim 2^n\))
- **SHA-2**: MD 구조(길이 확장 공격 주의) / **SHA-3**: 스펀지
- **MAC**: **HMAC**(기본), **KMAC**(SHA-3계), **GMAC**(GCM 인증 성분)
- **길이 확장**: `H(secret‖msg)` 금지 → **HMAC/KMAC**
- **AEAD**: GCM/ChaCha20-Poly1305로 **기밀성+무결성** 동시 달성
- **현실 규칙**: 상수시간 비교, Nonce 고유성, AAD 활용, 로그 최소화

---

## ✅ 6.11 연습문제

1) 충돌/2nd-프리이미지/프리이미지의 **난이도 차이**를 생일 경계 관점에서 설명하라.
2) 왜 `SHA256(secret || msg)`는 길이 확장 공격에 취약한가? **패딩**과 **상태 재사용** 관점에서 직관을 서술하라.
3) HMAC의 `ipad/opad` 구조가 길이 확장 취약을 어떻게 회피하는지 요약하라.
4) GMAC에서 **Nonce 재사용**의 위험이 GCM과 **동일**함을 수학적/직관적으로 설명하라.
5) SHA-3 스펀지 구조가 MD 구조와 달리 갖는 장단점을 요약하고, KMAC의 장점을 예시와 함께 적어라.
