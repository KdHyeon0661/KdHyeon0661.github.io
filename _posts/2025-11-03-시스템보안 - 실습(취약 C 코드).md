---
layout: post
title: 시스템보안 - 실습(취약 C 코드 → PR 게이트 실패 → 수정 → 자동 재검증)
date: 2025-11-03 15:30:23 +0900
category: 시스템보안
---
# 실습: 취약 C 코드 → PR 게이트 실패 → 수정 → 자동 재검증

## 리포 구조(샘플)

```
repo/
 ├─ src/
 │   ├─ unsafe.c        # 취약 코드(의도)
 │   └─ safe.c          # 수정본(후반)
 ├─ include/
 │   └─ unsafe.h
 ├─ tests/
 │   ├─ test_unsafe.c   # 단위테스트(ASan 켜서 실행)
 │   └─ fuzz_unsafe.cc  # libFuzzer 타깃
 ├─ .github/workflows/security-ci.yml   # PR 게이트
 ├─ semgrep-rules/c-insecure.yaml       # 커스텀 SAST 룰
 ├─ Makefile
 └─ SBOM/ (빌드시 생성 산출물 저장 위치)
```

---

## 취약 C 코드(의도적으로 문제 포함)

```c
// src/unsafe.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include "unsafe.h"

/* 취약점 목록
 *  1) strcpy, sprintf 사용으로 버퍼 오버플로우
 *  2) 길이 검증 없는 concat
 *  3) size_t 덧셈 정수 오버플로우
 *  4) 포맷 스트링 취약: printf(userInput) 생으로 출력
 */

int concat_message(const char *user, const char *msg, char *out) {
    // out은 최소 64바이트라고 가정(문제의 씨앗)
    // 1) strcpy: 길이 검증 없음
    strcpy(out, "user=");
    strcat(out, user);              // 길이 검증 없는 strcat
    strcat(out, "; msg=");
    strcat(out, msg);
    return 0;
}

int make_payload(const unsigned char *data, size_t len, unsigned char **out, size_t *outlen) {
    // 2) 정수 오버플로우: len + 16이 SIZE_MAX 넘어가도 체크 안 함
    size_t need = len + 16;
    unsigned char *buf = (unsigned char*)malloc(need);
    if (!buf) return -1;
    sprintf((char*)buf, "len=%zu;", len);  // 3) sprintf, 타입 캐스팅 위험
    memcpy(buf + 16, data, len);           // len < 16이면 오버랩
    *out = buf;
    *outlen = need;
    return 0;
}

void print_line(const char *userInput) {
    // 4) 포맷 스트링 취약: 사용자 입력을 포맷으로 직접 사용
    printf(userInput);
    printf("\n");
}
```

```c
// include/unsafe.h
#ifndef UNSAFE_H
#define UNSAFE_H
#include <stddef.h>

int concat_message(const char *user, const char *msg, char *out);
int make_payload(const unsigned char *data, size_t len, unsigned char **out, size_t *outlen);
void print_line(const char *userInput);
#endif

```

---

## 커스텀 룰

```yaml
# semgrep-rules/c-insecure.yaml

rules:
- id: c-unsafe-strcpy
  message: "Avoid strcpy/strcat/sprintf; use bounded variants (snprintf/strlcpy)."
  severity: ERROR
  languages: [c, cpp]
  pattern-either:
    - pattern: strcpy(...)
    - pattern: strcat(...)
    - pattern: sprintf(...)

- id: c-format-string
  message: "Potential format string: printf(x) with x from user input."
  severity: ERROR
  languages: [c, cpp]
  patterns:
    - pattern: printf($X)
    - pattern-not: printf("...")

- id: c-integer-overflow-add
  message: "Potential size_t addition overflow before allocation."
  severity: WARNING
  languages: [c, cpp]
  pattern: |
    $NEED = $A + $B;
```

---

## 단위 테스트 & Fuzz 타깃

```c
// tests/test_unsafe.c
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "unsafe.h"

int main() {
    char out[64];
    memset(out, 0, sizeof(out));
    // 고의로 긴 입력(오버플로우 유발)
    const char *user = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    const char *msg  = "HELLO";
    concat_message(user, msg, out);
    // ASan이 있으면 여기서 abort 가능
    // 포맷 스트링 취약 확인(크래시 유발 가능해서 disable-stdio-buffering 권장)
    print_line("%x %x %x %n");
    // make_payload 오버플로우 케이스
    unsigned char *buf = NULL; size_t outlen=0;
    unsigned char data[8] = {0};
    make_payload(data, (size_t)-8, &buf, &outlen);  // 의도적 wrap
    free(buf);
    return 0;
}
```

```cpp
// tests/fuzz_unsafe.cc (libFuzzer)
#include <stdint.h>
#include <stddef.h>
#include <string>
#include "unsafe.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
  if (Size < 2) return 0;
  size_t half = Size / 2;
  std::string user((const char*)Data, half);
  std::string msg((const char*)Data + half, Size - half);
  char out[64]; // 의도적으로 작은 버퍼
  concat_message(user.c_str(), msg.c_str(), out);
  print_line(user.c_str());
  unsigned char *buf=nullptr; size_t outlen=0;
  make_payload(Data, Size, &buf, &outlen);
  free(buf);
  return 0;
}
```

---

## Makefile(ASan/UBSan/포트러블 플래그)

```makefile
CC?=clang
CFLAGS=-O1 -g -Wall -Wextra -fno-omit-frame-pointer -fsanitize=address,undefined -D_FORTIFY_SOURCE=2 -fstack-protector-strong
LDFLAGS=-fsanitize=address,undefined

all: test fuzz

lib:
	$(CC) $(CFLAGS) -Iinclude -c src/unsafe.c -o build/unsafe.o
	$(CC) $(CFLAGS) build/unsafe.o -o build/libunsafe.a

test: lib
	$(CC) $(CFLAGS) -Iinclude tests/test_unsafe.c build/unsafe.o -o build/test $(LDFLAGS)

fuzz: lib
	$(CC) $(CFLAGS) -Iinclude tests/fuzz_unsafe.cc build/unsafe.o -o build/fuzz -fsanitize=fuzzer,address,undefined

run-test:
	ASAN_OPTIONS=detect_stack_use_after_return=1:abort_on_error=1:log_path=asan \
	UBSAN_OPTIONS=halt_on_error=1 build/test

run-fuzz:
	build/fuzz -max_total_time=30 -print_final_stats=1

clean:
	rm -rf build/* asan.*
```

---

## GitHub Actions: PR 게이트(실패 → 통과)

```yaml
# .github/workflows/security-ci.yml

name: security-ci
on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  build-sast-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # SAST (semgrep)
      - name: Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: semgrep-rules/
          generateSarif: true
          auditOn: push
      - name: Upload SARIF
        uses: github/codeql-action/upload-sarif@v3
        with: { sarif_file: semgrep.sarif }

      # Build & Test with Sanitizers
      - name: Install deps
        run: sudo apt-get update && sudo apt-get install -y clang make
      - name: Prepare build
        run: mkdir -p build
      - name: Build & test
        run: |
          make all
          make run-test
      - name: Short fuzz smoke
        run: make run-fuzz

      # 게이트 조건: semgrep가 ERROR 보고하면 step이 실패하도록 구성되어 이미 fail
```

**PR 결과(예상)**
- `semgrep`가 `strcpy/strcat/sprintf`, `printf(userInput)` 탐지 → **Job 실패**
- `ASan`이 테스트 중 스택/힙 오버플로우 포착 시 **비정상 종료** → **Job 실패**

---

## 코드 수정(안전한 구현)

```c
// src/safe.c (unsafe.c 대체)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <limits.h>
#include "unsafe.h"

/* 방어 전략
 *  1) 안전한 결합: snprintf + 길이 제한
 *  2) 정수 오버플로우 검사: if (len > SIZE_MAX - 16) fail
 *  3) 포맷 스트링: printf("%s", userInput)
 *  4) 민감 버퍼 길이: 상수 정의/컴파일타임 체크
 */

#define OUT_MAX 256

int concat_message(const char *user, const char *msg, char *out) {
    if (!user || !msg || !out) return -1;
    // 안전 결합
    int written = snprintf(out, OUT_MAX, "user=%.*s; msg=%.*s",
                           120, user, 120, msg); // 단순 클램핑
    if (written < 0 || written >= OUT_MAX) return -2;
    return 0;
}

int make_payload(const unsigned char *data, size_t len, unsigned char **out, size_t *outlen) {
    if (!data || !out || !outlen) return -1;
    if (len > SIZE_MAX - 16) return -2;        // 오버플로우 차단
    size_t need = len + 16;
    unsigned char *buf = (unsigned char*)calloc(1, need);
    if (!buf) return -3;
    // 안전한 헤더 작성
    int hdr = snprintf((char*)buf, 16, "len=%" PRIu64 ";", (uint64_t)len);
    if (hdr < 0 || hdr >= 16) { free(buf); return -4; }
    memcpy(buf + 16, data, len);
    *out = buf;
    *outlen = need;
    return 0;
}

void print_line(const char *userInput) {
    if (!userInput) { puts(""); return; }
    // 포맷 스트링 리터럴 고정
    printf("%s\n", userInput);
}
```

> 변경 포인트:
> - `snprintf` + **길이 제한**으로 버퍼 오버런 제거.
> - `SIZE_MAX - 16` 체크로 **정수 오버플로우** 차단.
> - `printf("%s", …)`로 **포맷 스트링** 제거.
> - `calloc`로 헤더 영역 제로이니셜라이즈.

---

## 테스트 업데이트(오버플로우 대신 동작 확인)

```c
// tests/test_unsafe.c (수정)
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "unsafe.h"

int main() {
    char out[256]={0};
    const char *user = "A_very_long_username_but_clamped";
    const char *msg  = "HELLO";
    int rc = concat_message(user, msg, out);
    assert(rc == 0);
    assert(strstr(out, "user=") && strstr(out, "msg="));

    unsigned char *buf = NULL; size_t outlen=0;
    unsigned char data[8] = {1,2,3,4,5,6,7,8};
    rc = make_payload(data, sizeof(data), &buf, &outlen);
    assert(rc == 0 && buf && outlen == sizeof(data)+16);
    free(buf);

    print_line("SAFE %s"); // %s literal도 그대로 출력됨
    return 0;
}
```

---

## 다시 PR → 자동 재검증(통과)

- **Semgrep**: 더 이상 `strcpy/strcat/sprintf` 탐지 없음, `printf`는 리터럴 포맷만 사용 → **통과**
- **ASan/UBSan**: 런타임 에러 없음 → **통과**
- **Fuzz Smoke 30s**: 크래시 없음 → **통과**
- 파이프라인 **녹색** → 머지 가능

---

# 방어: 서명/검증, 프로비저닝 비밀 회전, 릴리즈 SBOM 공개

## 컨테이너/바이너리 서명 & 검증(cosign, OIDC 키리스)

### 빌드 시 서명 + SBOM 어테스테이션

```yaml
# .github/workflows/release.yml (발췌)

permissions:
  id-token: write   # OIDC for keyless
  contents: read
jobs:
  build-sign:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: docker buildx build --provenance=true --sbom=true -t ghcr.io/acme/unsafe:${{ github.sha }} --load .
      - name: Install cosign
        run: |
          COSIGN_VERSION=v2.4.0
          curl -sSfL -o cosign https://github.com/sigstore/cosign/releases/download/$COSIGN_VERSION/cosign-linux-amd64
          chmod +x cosign
      - name: Sign image (keyless)
        run: ./cosign sign ghcr.io/acme/unsafe:${{ github.sha }} --yes
      - name: Attach SBOM attestation
        run: |
          syft dir:. -o cyclonedx-json > SBOM/sbom.cdx.json
          ./cosign attest --predicate SBOM/sbom.cdx.json --type cyclonedx ghcr.io/acme/unsafe:${{ github.sha }} --yes
```

### 배포 전 검증(Admission or CD 단계)

```bash
cosign verify ghcr.io/acme/unsafe:TAG \
  --certificate-identity-regexp "https://github.com/acme/.+" \
  --certificate-oidc-issuer https://token.actions.githubusercontent.com

cosign verify-attestation --type cyclonedx ghcr.io/acme/unsafe:TAG
```

> **Gate**: “서명 & SBOM 어테스테이션 없는 이미지”는 **거부**(OPA/Kyverno/Policy Controller).

---

## 프로비저닝 비밀 관리 & **회전 전략**

### CI/CD에서 **정적 시크릿 금지**: OIDC + 단기 크레덴셜

- GitHub Actions → **클라우드(예: AWS/GCP/Azure)** 역할로 **OIDC 페더레이션**
- 장점: 저장된 PAT/Access Key 없이 “필요 시점”에 “단기 자격” 발급 → **유출면적 축소**

**AWS 예시(IAM Role for OIDC)**
```bash
# 신뢰 정책 (깃허브 OIDC)

{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {"Federated": "arn:aws:iam::<ACC>:oidc-provider/token.actions.githubusercontent.com"},
    "Action": "sts:AssumeRoleWithWebIdentity",
    "Condition": {
      "StringLike": {"token.actions.githubusercontent.com:sub": "repo:acme/unsafe:*"}
    }
  }]
}
```

```yaml
# Actions에서 AWS 권한 임시 획득

- uses: aws-actions/configure-aws-credentials@v4
  with:
    role-to-assume: arn:aws:iam::<ACC>:role/github-oidc-ci
    aws-region: ap-northeast-2
```

### **Vault**로 동적 비밀·DB 크레덴셜 **자동 회전**

- 앱은 **Vault 토큰**(또는 JWT)으로 **짧은 TTL**의 DB 유저 발급 → 만료 자동 Revoke
- 릴리즈마다 **새 경로/버전** 시크릿을 발급하여 **구버전 무력화**

**Vault Policy(발췌)**
```hcl
path "database/creds/app" {
  capabilities = ["read"]
}
```

**앱 런타임(예: init 컨테이너)**
```bash
vault login -method=jwt role=app
vault read -format=json database/creds/app > /work/creds.json
# creds.json 내 username/password TTL 포함 → 앱 환경변수 주입

```

### **KMS + SOPS**로 Git에 암호화 저장 & **회전 파이프라인**

- 시크릿을 `sops`로 암호화하여 Git에 저장하고, 배포 시 복호화
- 키 회전 시 **KMS 키 바인딩 업데이트** + CI에서 **자동 재암호화**

```bash
sops --encrypt --kms arn:aws:kms:... secret.yaml > secret.enc.yaml
sops --decrypt secret.enc.yaml > secret.yaml   # 배포 시 CI에서만
```

**키 회전 워크플로(요지)**
1) 새 KMS 키 생성 → 2) sops config에 새 키 추가 → 3) `sops updatekeys -r .` → 4) PR 머지 → 5) 구키 폐기 스케줄

---

## 릴리즈 SBOM 공개 & 소비자 신뢰 사슬

### SBOM 생성(CycloneDX/SPDX) – **언어 + 컨테이너**

```bash
# SBOM

syft dir:. -o cyclonedx-json > SBOM/app.cdx.json
# 컨테이너 이미지 SBOM

syft ghcr.io/acme/unsafe:${GIT_SHA} -o cyclonedx-json > SBOM/image.cdx.json
jq -s '.[0] * .[1]' SBOM/app.cdx.json SBOM/image.cdx.json > SBOM/merged.cdx.json
```

### 릴리즈 페이지/아티팩트에 **SBOM 첨부**

```yaml
- name: Create GitHub Release
  uses: softprops/action-gh-release@v2
  with:
    tag_name: v${{ steps.meta.outputs.version }}
    name: "unsafe v${{ steps.meta.outputs.version }}"
    body: |
      - Signed image: ghcr.io/acme/unsafe:${{ github.sha }}
      - Attestations: cosign (cyclonedx)
    files: |
      SBOM/merged.cdx.json
      zap_report.html
      semgrep.sarif
```

### 소비자측 **검증 시나리오**(문서화 체크리스트)

- [ ] 이미지 **서명 검증**(`cosign verify`)
- [ ] **어테스테이션**(cyclonedx) 검증
- [ ] SBOM으로 **금지 라이선스**/취약 컴포넌트 유무 검사
- [ ] Provenance로 **커밋/빌더** 추적

---

## 배포 게이트: “서명·SBOM 없는 이미지는 거부”

**Gatekeeper 템플릿(개념: 필요한 어노테이션/라벨 확인)**

```yaml
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequireimageattest
spec:
  crd:
    spec:
      names:
        kind: K8sRequireImageAttest
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8srequireimageattest
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        ann := input.review.object.metadata.annotations
        not ann["cosign.sigstore.dev/status"] == "verified"
        msg := "Image not cosign-verified"
      }
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        ann := input.review.object.metadata.annotations
        not has_key(ann, "sbom.cyclonedx/attached")
        msg := "SBOM attestation missing"
      }
```

**Constraint**
```yaml
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequireImageAttest
metadata: { name: require-attestations }
spec:
  match:
    kinds: [{ apiGroups: [""], kinds: ["Pod"]}]
```

> 실제 운영에선 **Sigstore Policy Controller** 또는 **Kyverno verifyImages** 사용 시, 레지스트리에서 **실제 시그니처/어테스테이션** 검증을 수행합니다.

---

## 운영 체크리스트(현장용)

**코드 보안/게이트**
- [ ] Semgrep ERROR ≥ 1이면 **Fail**
- [ ] ASan/UBSan 크래시 **Fail**
- [ ] Fuzz Smoke 크래시 **Fail**
- [ ] 린트/테스트 커버리지 기준 유지

**서명/증빙**
- [ ] 모든 이미지는 **cosign keyless 서명**
- [ ] **CycloneDX SBOM 어테스테이션** 부착
- [ ] 배포 전 **verify & verify-attestation** 자동화

**비밀/회전**
- [ ] 정적 키 제거, **OIDC 단기 권한** 사용
- [ ] Vault/Secrets Manager **동적 크레덴셜** 도입, TTL/Lease 관리
- [ ] SOPS+KMS로 Git 내 시크릿 **암호화**, **주기적 키 회전** 파이프라인

**릴리즈 투명성**
- [ ] 릴리즈 자산에 **SBOM**, SAST/DAST 요약 포함
- [ ] 소비자 검증 가이드 문서화

---

## 트러블슈팅

- **Semgrep 오탐**: 조직 룰에 **allowlist** 주되, **만료일**(예: 30~90일) 부여.
- **ASan 메모리 이슈**: 환경변수 `ASAN_OPTIONS=fast_unwind_on_malloc=0` 등 조정, 재현 최소 케이스를 `tests/`로 승격.
- **cosign 검증 실패**: OIDC 권한/Issuer/Subject 조건 재점검, 태그 다이제스트 미스매치 확인.
- **Vault 토큰 문제**: 시간 동기화(NTP), JWT aud/role 매핑, 네트워크 경로/방화벽.
- **SBOM 부피**: 릴리즈에 **압축본** 첨부, 장기보관은 아카이브 스토리지로 오프로드.

---

# 결론

- **취약 C 코드 → PR 게이트 실패 → 수정 → 자동 재검증** 흐름은 개발자가 **즉시 피드백**을 받아 보안 품질을 끌어올리는 **가장 실효적인 루프**입니다.
- **서명/검증**과 **SBOM 공개**로 공급망 **신뢰 사슬**을 만들고, **OIDC/Vault/SOPS**로 **비밀 회전**을 자동화하면, 빌드부터 배포까지 **감사 가능한 보안**을 확보합니다.
