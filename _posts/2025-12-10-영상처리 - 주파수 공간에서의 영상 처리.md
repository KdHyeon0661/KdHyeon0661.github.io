---
layout: post
title: 영상처리 - 주파수 공간에서의 영상 처리 (C#)
date: 2025-12-10 23:30:23 +0900
category: 영상처리
---
# 주파수 공간에서의 영상 처리: 이론, 알고리즘 및 응용

## 주파수 공간 처리의 개념과 중요성

### 주파수 분석의 물리적 의미

주파수 공간 영상 처리는 **영상의 밝기 변화를 공간 좌표가 아닌 주파수 성분으로 분석**하는 방법입니다. 이 접근법은 신호 처리 이론을 영상에 적용하여, 공간 도메인에서는 보기 어려운 특성을 명확히 드러냅니다.

**주파수 성분의 의미**:
- **저주파 성분(Low Frequency)**: 완만한 밝기 변화, 대규모 구조, 배경 정보
- **고주파 성분(High Frequency)**: 급격한 밝기 변화, 에지(edge), 텍스처, 잡음
- **중주파 성분(Mid Frequency)**: 중간 규모의 패턴, 세부 구조

### 주파수 도메인 처리의 장점

| 장점 | 설명 | 응용 예시 |
|------|------|-----------|
| **전역적 특성 분석** | 전체 영상의 주기적 패턴 분석 | 텍스처 분석, 주기적 패턴 검출 |
| **효율적 필터링** | 주파수 선택적 필터링 가능 | 정확한 주파수 대역 제거/강조 |
| **변환 분리** | 복잡한 연산을 단순 곱셈으로 변환 | 회선 정리(Convolution Theorem) 활용 |
| **다중 해상도 분석** | 다양한 스케일에서의 특성 분석 | 웨이블릿 변환, 피라미드 처리 |

### 수학적 기초: 오일러 공식과 복소수

푸리에 변환의 핵심은 오일러 공식입니다:

$$
e^{j\theta} = \cos\theta + j\sin\theta
$$

여기서:
- $$j = \sqrt{-1}$$ (허수 단위)
- $$\theta$$: 위상 각도
- $$e^{j\theta}$$: 복소 평면에서 단위 원 위의 점

**복소수의 극형식(Polar Form)**:
$$
z = re^{j\theta} = r(\cos\theta + j\sin\theta)
$$
- $$r = |z|$$: 크기(magnitude)
- $$\theta = \arg(z)$$: 위상(phase)

---

## 푸리에 변환의 수학적 기초

### 연속 푸리에 변환(Continuous Fourier Transform)

#### 1차원 연속 푸리에 변환

$$
F(\omega) = \int_{-\infty}^{\infty} f(t) e^{-j\omega t} dt
$$

역변환:
$$
f(t) = \frac{1}{2\pi} \int_{-\infty}^{\infty} F(\omega) e^{j\omega t} d\omega
$$

#### 2차원 연속 푸리에 변환

$$
F(u,v) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(x,y) e^{-j2\pi(ux+vy)} dx dy
$$

역변환:
$$
f(x,y) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} F(u,v) e^{j2\pi(ux+vy)} du dv
$$

### 이산 푸리에 변환(Discrete Fourier Transform, DFT)

#### 1차원 DFT

길이 $$N$$인 이산 신호 $$f[n]$$에 대해:

**정방향 변환(Forward DFT)**:
$$
F[k] = \sum_{n=0}^{N-1} f[n] \cdot e^{-j2\pi kn/N}, \quad k = 0, 1, \dots, N-1
$$

**역변환(Inverse DFT)**:
$$
f[n] = \frac{1}{N} \sum_{k=0}^{N-1} F[k] \cdot e^{j2\pi kn/N}, \quad n = 0, 1, \dots, N-1
$$

#### 2차원 DFT

$$M \times N$$ 크기의 영상 $$f[x,y]$$에 대해:

**정방향 변환**:
$$
F[u,v] = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f[x,y] \cdot e^{-j2\pi(ux/M + vy/N)}
$$

**역변환**:
$$
f[x,y] = \frac{1}{MN} \sum_{u=0}^{M-1} \sum_{v=0}^{N-1} F[u,v] \cdot e^{j2\pi(ux/M + vy/N)}
$$

### 푸리에 변환의 주요 성질

| 성질 | 수학적 표현 | 의미 |
|------|-------------|------|
| **선형성** | $$\mathcal{F}\{af + bg\} = a\mathcal{F}\{f\} + b\mathcal{F}\{g\}$$ | 가중 합의 변환 = 변환의 가중 합 |
| **이동성** | $$\mathcal{F}\{f(x-x_0)\} = e^{-j2\pi ux_0}F(u)$$ | 공간 이동 = 위상 변화 |
| **대칭성** | $$F(-u) = F^*(u)$$ (실수 입력 시) | 스펙트럼의 켤레 대칭 |
| **회선 정리** | $$\mathcal{F}\{f \ast g\} = F \cdot G$$ | 공간 회선 = 주파수 곱셈 |
| **파시발 정리** | $$\sum \|f\|^2 = \frac{1}{N}\sum\|F\|^2$$ | 에너지 보존 |

---

## DFT의 상세 구현

### 복소수 구조 및 연산

```csharp
public struct ComplexNumber
{
    public double Real;
    public double Imaginary;
    
    public ComplexNumber(double real, double imaginary)
    {
        Real = real;
        Imaginary = imaginary;
    }
    
    // 크기(Magnitude)
    public double Magnitude => Math.Sqrt(Real * Real + Imaginary * Imaginary);
    
    // 위상(Phase)
    public double Phase => Math.Atan2(Imaginary, Real);
    
    // 켤레 복소수(Conjugate)
    public ComplexNumber Conjugate => new ComplexNumber(Real, -Imaginary);
    
    // 연산자 오버로딩
    public static ComplexNumber operator +(ComplexNumber a, ComplexNumber b)
        => new ComplexNumber(a.Real + b.Real, a.Imaginary + b.Imaginary);
    
    public static ComplexNumber operator -(ComplexNumber a, ComplexNumber b)
        => new ComplexNumber(a.Real - b.Real, a.Imaginary - b.Imaginary);
    
    public static ComplexNumber operator *(ComplexNumber a, ComplexNumber b)
        => new ComplexNumber(
            a.Real * b.Real - a.Imaginary * b.Imaginary,
            a.Real * b.Imaginary + a.Imaginary * b.Real);
    
    public static ComplexNumber operator /(ComplexNumber a, ComplexNumber b)
    {
        double denominator = b.Real * b.Real + b.Imaginary * b.Imaginary;
        return new ComplexNumber(
            (a.Real * b.Real + a.Imaginary * b.Imaginary) / denominator,
            (a.Imaginary * b.Real - a.Real * b.Imaginary) / denominator);
    }
    
    // 오일러 공식으로부터의 변환
    public static ComplexNumber FromPolar(double magnitude, double phase)
        => new ComplexNumber(
            magnitude * Math.Cos(phase),
            magnitude * Math.Sin(phase));
}
```

### 기본 2D DFT 구현 (직접 계산)

```csharp
public class DFTProcessor
{
    // 직접 계산을 통한 2D DFT (교육용, 느림)
    public static ComplexNumber[,] ComputeDFTDirect(MyImage image)
    {
        int width = image.Width;
        int height = image.Height;
        ComplexNumber[,] spectrum = new ComplexNumber[width, height];
        
        // 사전 계산된 회전 인자 (성능 최적화)
        ComplexNumber[,] expTable = PrecomputeExponentialTable(width, height);
        
        // 병렬 처리를 통한 성능 향상
        Parallel.For(0, width, u =>
        {
            for (int v = 0; v < height; v++)
            {
                ComplexNumber sum = new ComplexNumber(0, 0);
                
                for (int x = 0; x < width; x++)
                {
                    for (int y = 0; y < height; y++)
                    {
                        // 회전 인자 계산 (사전 계산된 테이블 사용)
                        ComplexNumber expFactor = expTable[
                            (u * x) % width, 
                            (v * y) % height];
                        
                        // 입력 신호 값 (그레이스케일)
                        double pixelValue = image.GetPixel(x, y);
                        
                        // DFT 누적
                        sum += new ComplexNumber(pixelValue, 0) * expFactor;
                    }
                }
                
                spectrum[u, v] = sum;
            }
        });
        
        return spectrum;
    }
    
    private static ComplexNumber[,] PrecomputeExponentialTable(int width, int height)
    {
        ComplexNumber[,] table = new ComplexNumber[width, height];
        
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < height; j++)
            {
                double angle = -2 * Math.PI * i * j / (width * height);
                table[i, j] = new ComplexNumber(
                    Math.Cos(angle),
                    Math.Sin(angle));
            }
        }
        
        return table;
    }
    
    // 2D 역 DFT
    public static MyImage ComputeInverseDFT(ComplexNumber[,] spectrum)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        MyImage result = new MyImage(width, height);
        
        double scale = 1.0 / (width * height);
        
        Parallel.For(0, width, x =>
        {
            for (int y = 0; y < height; y++)
            {
                ComplexNumber sum = new ComplexNumber(0, 0);
                
                for (int u = 0; u < width; u++)
                {
                    for (int v = 0; v < height; v++)
                    {
                        // 회전 인자 계산 (역변환은 +j)
                        double angle = 2 * Math.PI * (u * x / (double)width + v * y / (double)height);
                        ComplexNumber expFactor = new ComplexNumber(
                            Math.Cos(angle),
                            Math.Sin(angle));
                        
                        sum += spectrum[u, v] * expFactor;
                    }
                }
                
                // 실수부만 취하고 스케일 조정
                double value = sum.Real * scale;
                result.SetPixel(x, y, (byte)Math.Clamp(value, 0, 255));
            }
        });
        
        return result;
    }
}
```

### DFT 계산의 최적화 기법

```csharp
public class OptimizedDFT
{
    // 분리 가능한 2D DFT (행-열 방법)
    public static ComplexNumber[,] ComputeSeparableDFT(MyImage image)
    {
        int width = image.Width;
        int height = image.Height;
        
        // 중간 결과 저장소
        ComplexNumber[,] intermediate = new ComplexNumber[width, height];
        ComplexNumber[,] result = new ComplexNumber[width, height];
        
        // 1. 각 행에 대한 1D DFT
        Parallel.For(0, height, y =>
        {
            ComplexNumber[] row = new ComplexNumber[width];
            
            // 행 데이터 추출
            for (int x = 0; x < width; x++)
            {
                row[x] = new ComplexNumber(image.GetPixel(x, y), 0);
            }
            
            // 1D DFT 계산
            ComplexNumber[] rowDFT = Compute1DDFT(row);
            
            // 결과 저장
            for (int x = 0; x < width; x++)
            {
                intermediate[x, y] = rowDFT[x];
            }
        });
        
        // 2. 각 열에 대한 1D DFT
        Parallel.For(0, width, x =>
        {
            ComplexNumber[] column = new ComplexNumber[height];
            
            // 열 데이터 추출
            for (int y = 0; y < height; y++)
            {
                column[y] = intermediate[x, y];
            }
            
            // 1D DFT 계산
            ComplexNumber[] columnDFT = Compute1DDFT(column);
            
            // 결과 저장
            for (int y = 0; y < height; y++)
            {
                result[x, y] = columnDFT[y];
            }
        });
        
        return result;
    }
    
    // 1D DFT 계산 (FFT 대비 이해를 위해)
    private static ComplexNumber[] Compute1DDFT(ComplexNumber[] input)
    {
        int N = input.Length;
        ComplexNumber[] output = new ComplexNumber[N];
        
        for (int k = 0; k < N; k++)
        {
            ComplexNumber sum = new ComplexNumber(0, 0);
            
            for (int n = 0; n < N; n++)
            {
                double angle = -2 * Math.PI * k * n / N;
                ComplexNumber twiddle = new ComplexNumber(
                    Math.Cos(angle),
                    Math.Sin(angle));
                
                sum += input[n] * twiddle;
            }
            
            output[k] = sum;
        }
        
        return output;
    }
}
```

---

## 고속 푸리에 변환(Fast Fourier Transform, FFT)

### FFT의 필요성과 이점

**DFT의 계산 복잡도 문제**:
- 직접 계산: $$O(N^2)$$ 연산 필요
- 512×512 영상: 약 680억 번의 복소수 연산
- 실시간 처리 불가능

**FFT의 이점**:
- 계산 복잡도: $$O(N \log N)$$
- 512×512 영상: 약 230만 번의 연산 (30,000배 향상)
- 실시간 처리 가능

### Cooley-Tukey FFT 알고리즘

#### 분할 정복(Divide and Conquer) 접근법

N점 DFT를 두 개의 N/2점 DFT로 분해:

$$
X[k] = \sum_{n=0}^{N-1} x[n] W_N^{kn}
= \sum_{m=0}^{N/2-1} x[2m] W_N^{k(2m)} + \sum_{m=0}^{N/2-1} x[2m+1] W_N^{k(2m+1)}
$$

여기서:
- $$W_N = e^{-j2\pi/N}$$ (회전 인자, twiddle factor)
- 짝수 인덱스 항: $$X_e[k] = \sum_{m=0}^{N/2-1} x[2m] W_{N/2}^{km}$$
- 홀수 인덱스 항: $$X_o[k] = \sum_{m=0}^{N/2-1} x[2m+1] W_{N/2}^{km}$$

최종적으로:
$$
X[k] = X_e[k] + W_N^k X_o[k]
$$
$$
X[k+N/2] = X_e[k] - W_N^k X_o[k]
$$

#### 버터플라이 연산(Butterfly Operation)

```
입력 쌍 (a, b)
        │
        ▼
    ┌───────┐
    │  W_N^k │ (회전 인자 곱셈)
    └───┬───┘
        │
        ▼
  ┌─────┴─────┐
  │           │
  ▼           ▼
a + W*b    a - W*b
```

### 1차원 FFT 구현

```csharp
public class FFTProcessor
{
    // 재귀적 FFT 구현 (교육용)
    public static ComplexNumber[] FFTRecursive(ComplexNumber[] input)
    {
        int N = input.Length;
        
        // 기저 사례: 크기가 1이면 그대로 반환
        if (N == 1)
            return new ComplexNumber[] { input[0] };
        
        // N이 2의 거듭제곱인지 확인
        if ((N & (N - 1)) != 0)
            throw new ArgumentException("입력 크기는 2의 거듭제곱이어야 합니다.");
        
        // 짝수/홀수 인덱스 분리
        ComplexNumber[] even = new ComplexNumber[N / 2];
        ComplexNumber[] odd = new ComplexNumber[N / 2];
        
        for (int i = 0; i < N / 2; i++)
        {
            even[i] = input[2 * i];
            odd[i] = input[2 * i + 1];
        }
        
        // 재귀 호출
        ComplexNumber[] evenFFT = FFTRecursive(even);
        ComplexNumber[] oddFFT = FFTRecursive(odd);
        
        // 결과 결합
        ComplexNumber[] result = new ComplexNumber[N];
        
        for (int k = 0; k < N / 2; k++)
        {
            // 회전 인자 계산
            double angle = -2 * Math.PI * k / N;
            ComplexNumber twiddle = new ComplexNumber(
                Math.Cos(angle),
                Math.Sin(angle));
            
            // 버터플라이 연산
            ComplexNumber t = oddFFT[k] * twiddle;
            
            result[k] = evenFFT[k] + t;
            result[k + N / 2] = evenFFT[k] - t;
        }
        
        return result;
    }
    
    // 비재귀적 FFT (더 효율적)
    public static ComplexNumber[] FFTIterative(ComplexNumber[] input)
    {
        int N = input.Length;
        
        // 비트 반전 정렬(Bit-reversal permutation)
        ComplexNumber[] data = BitReverseCopy(input);
        
        // FFT 단계별 계산
        for (int s = 1; s <= Math.Log(N, 2); s++)
        {
            int m = 1 << s;  // 2^s
            ComplexNumber w_m = new ComplexNumber(
                Math.Cos(2 * Math.PI / m),
                -Math.Sin(2 * Math.PI / m));  // W_m = e^{-j2π/m}
            
            for (int k = 0; k < N; k += m)
            {
                ComplexNumber w = new ComplexNumber(1, 0);
                
                for (int j = 0; j < m / 2; j++)
                {
                    // 버터플라이 연산
                    ComplexNumber t = w * data[k + j + m / 2];
                    ComplexNumber u = data[k + j];
                    
                    data[k + j] = u + t;
                    data[k + j + m / 2] = u - t;
                    
                    // 회전 인자 업데이트
                    w = w * w_m;
                }
            }
        }
        
        return data;
    }
    
    // 비트 반전 정렬
    private static ComplexNumber[] BitReverseCopy(ComplexNumber[] input)
    {
        int N = input.Length;
        ComplexNumber[] result = new ComplexNumber[N];
        int bits = (int)Math.Log(N, 2);
        
        for (int i = 0; i < N; i++)
        {
            int reversed = 0;
            int temp = i;
            
            for (int j = 0; j < bits; j++)
            {
                reversed = (reversed << 1) | (temp & 1);
                temp >>= 1;
            }
            
            result[reversed] = input[i];
        }
        
        return result;
    }
    
    // 역 FFT
    public static ComplexNumber[] IFFT(ComplexNumber[] spectrum)
    {
        int N = spectrum.Length;
        
        // 1. 켤레 복소수 취하기
        ComplexNumber[] conjugated = new ComplexNumber[N];
        for (int i = 0; i < N; i++)
        {
            conjugated[i] = spectrum[i].Conjugate;
        }
        
        // 2. FFT 적용
        ComplexNumber[] result = FFTIterative(conjugated);
        
        // 3. 다시 켤레 복소수 취하고 스케일 조정
        for (int i = 0; i < N; i++)
        {
            result[i] = result[i].Conjugate;
            result[i] = new ComplexNumber(
                result[i].Real / N,
                result[i].Imaginary / N);
        }
        
        return result;
    }
}
```

### 2차원 FFT 구현

```csharp
public class FFT2DProcessor
{
    // 2D FFT (행-열 방법)
    public static ComplexNumber[,] FFT2D(MyImage image)
    {
        int width = image.Width;
        int height = image.Height;
        
        // 입력 데이터를 복소수 배열로 변환
        ComplexNumber[,] complexData = new ComplexNumber[width, height];
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                complexData[x, y] = new ComplexNumber(image.GetPixel(x, y), 0);
            }
        }
        
        // 1. 각 행에 대해 1D FFT
        ComplexNumber[,] rowTransformed = new ComplexNumber[width, height];
        
        Parallel.For(0, height, y =>
        {
            ComplexNumber[] row = new ComplexNumber[width];
            for (int x = 0; x < width; x++)
            {
                row[x] = complexData[x, y];
            }
            
            ComplexNumber[] rowFFT = FFTProcessor.FFTIterative(row);
            
            for (int x = 0; x < width; x++)
            {
                rowTransformed[x, y] = rowFFT[x];
            }
        });
        
        // 2. 각 열에 대해 1D FFT
        ComplexNumber[,] result = new ComplexNumber[width, height];
        
        Parallel.For(0, width, x =>
        {
            ComplexNumber[] column = new ComplexNumber[height];
            for (int y = 0; y < height; y++)
            {
                column[y] = rowTransformed[x, y];
            }
            
            ComplexNumber[] columnFFT = FFTProcessor.FFTIterative(column);
            
            for (int y = 0; y < height; y++)
            {
                result[x, y] = columnFFT[y];
            }
        });
        
        return result;
    }
    
    // 2D 역 FFT
    public static MyImage IFFT2D(ComplexNumber[,] spectrum)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        
        // 1. 각 열에 대해 1D 역 FFT
        ComplexNumber[,] columnTransformed = new ComplexNumber[width, height];
        
        Parallel.For(0, width, x =>
        {
            ComplexNumber[] column = new ComplexNumber[height];
            for (int y = 0; y < height; y++)
            {
                column[y] = spectrum[x, y];
            }
            
            ComplexNumber[] columnIFFT = FFTProcessor.IFFT(column);
            
            for (int y = 0; y < height; y++)
            {
                columnTransformed[x, y] = columnIFFT[y];
            }
        });
        
        // 2. 각 행에 대해 1D 역 FFT
        ComplexNumber[,] spatialData = new ComplexNumber[width, height];
        
        Parallel.For(0, height, y =>
        {
            ComplexNumber[] row = new ComplexNumber[width];
            for (int x = 0; x < width; x++)
            {
                row[x] = columnTransformed[x, y];
            }
            
            ComplexNumber[] rowIFFT = FFTProcessor.IFFT(row);
            
            for (int x = 0; x < width; x++)
            {
                spatialData[x, y] = rowIFFT[x];
            }
        });
        
        // 3. 실수부만 취하여 영상으로 변환
        MyImage result = new MyImage(width, height);
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                // 실수부만 사용 (이상적으로는 허수부가 0에 가까워야 함)
                double value = spatialData[x, y].Real;
                result.SetPixel(x, y, (byte)Math.Clamp(value, 0, 255));
            }
        }
        
        return result;
    }
}
```

### FFT 알고리즘 변형 및 최적화

```csharp
public class AdvancedFFT
{
    // 분할 기준 FFT (Split-radix FFT)
    public static ComplexNumber[] SplitRadixFFT(ComplexNumber[] input)
    {
        int N = input.Length;
        if (N == 1) return new ComplexNumber[] { input[0] };
        
        // 크기 분할: N = 4k, 2k, k
        if (N % 4 == 0)
        {
            // 4-way 분할
            return SplitRadixFFT4Way(input);
        }
        else if (N % 2 == 0)
        {
            // Cooley-Tukey 방식
            return StandardRadix2FFT(input);
        }
        else
        {
            // 소수 크기 FFT (Bluestein 알고리즘)
            return BluesteinFFT(input);
        }
    }
    
    // 블루스타인 FFT (임의 크기 지원)
    public static ComplexNumber[] BluesteinFFT(ComplexNumber[] input)
    {
        int N = input.Length;
        
        // 가장 가까운 2의 거듭제곱 찾기
        int M = 1;
        while (M < 2 * N - 1) M <<= 1;
        
        // 컨볼루션을 위한 배열 준비
        ComplexNumber[] a = new ComplexNumber[M];
        ComplexNumber[] b = new ComplexNumber[M];
        
        // 입력 신호와 회전 인자 준비
        for (int n = 0; n < N; n++)
        {
            double angle = -Math.PI * n * n / N;
            ComplexNumber chirp = new ComplexNumber(
                Math.Cos(angle),
                Math.Sin(angle));
            
            a[n] = input[n] * chirp;
            b[n] = chirp.Conjugate;
            
            if (n > 0)
                b[M - n] = chirp.Conjugate;
        }
        
        // FFT를 이용한 컨볼루션
        ComplexNumber[] aFFT = FFTProcessor.FFTIterative(a);
        ComplexNumber[] bFFT = FFTProcessor.FFTIterative(b);
        
        // 주파수 도메인에서 곱셈
        ComplexNumber[] cFFT = new ComplexNumber[M];
        for (int i = 0; i < M; i++)
        {
            cFFT[i] = aFFT[i] * bFFT[i];
        }
        
        // 역 FFT
        ComplexNumber[] c = FFTProcessor.IFFT(cFFT);
        
        // 결과 추출 및 정규화
        ComplexNumber[] result = new ComplexNumber[N];
        for (int k = 0; k < N; k++)
        {
            double angle = -Math.PI * k * k / N;
            ComplexNumber chirp = new ComplexNumber(
                Math.Cos(angle),
                Math.Sin(angle));
            
            result[k] = c[k] * chirp;
        }
        
        return result;
    }
}
```

---

## 주파수 스펙트럼 시각화와 분석

### 스펙트럼 특성 이해

#### 주파수 좌표계 변환 (주파수 셔플링)

원래 DFT 결과에서 저주파 성분은 모서리에, 고주파 성분은 중심에 위치합니다. 시각화를 위해 주파수 셔플링(frequency shifting)을 적용합니다:

```csharp
public class SpectrumVisualizer
{
    // 주파수 셔플링 (저주파를 중심으로 이동)
    public static ComplexNumber[,] ShiftFrequency(ComplexNumber[,] spectrum)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        ComplexNumber[,] shifted = new ComplexNumber[width, height];
        
        int halfWidth = width / 2;
        int halfHeight = height / 2;
        
        // 4개의 사분면 교환
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                // 새로운 좌표 계산
                int newU = (u + halfWidth) % width;
                int newV = (v + halfHeight) % height;
                
                shifted[newU, newV] = spectrum[u, v];
            }
        }
        
        return shifted;
    }
    
    // 스펙트럼 크기 이미지 생성
    public static MyImage CreateMagnitudeImage(ComplexNumber[,] spectrum, bool useLogScale = true)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        MyImage image = new MyImage(width, height);
        
        // 최대값 찾기 (정규화용)
        double maxMagnitude = 0;
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                double mag = spectrum[u, v].Magnitude;
                if (mag > maxMagnitude) maxMagnitude = mag;
            }
        }
        
        // 영상 생성
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                double magnitude = spectrum[u, v].Magnitude;
                
                if (useLogScale)
                {
                    // 로그 스케일: S = log(1 + |F|)
                    magnitude = Math.Log(1 + magnitude);
                }
                
                // 정규화: 0~255 범위로 매핑
                int value = (int)(255 * magnitude / (useLogScale ? Math.Log(1 + maxMagnitude) : maxMagnitude));
                
                image.SetPixel(u, v, (byte)Math.Clamp(value, 0, 255));
            }
        }
        
        return image;
    }
    
    // 위상 스펙트럼 이미지 생성
    public static MyImage CreatePhaseImage(ComplexNumber[,] spectrum)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        MyImage image = new MyImage(width, height);
        
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                // 위상 각도: -π ~ π 범위
                double phase = spectrum[u, v].Phase;
                
                // 0 ~ 2π 범위로 정규화
                if (phase < 0) phase += 2 * Math.PI;
                
                // 0~255 범위로 매핑
                int value = (int)(255 * phase / (2 * Math.PI));
                
                image.SetPixel(u, v, (byte)Math.Clamp(value, 0, 255));
            }
        }
        
        return image;
    }
    
    // 파워 스펙트럼 이미지 생성
    public static MyImage CreatePowerSpectrumImage(ComplexNumber[,] spectrum)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        MyImage image = new MyImage(width, height);
        
        double maxPower = 0;
        double[,] power = new double[width, height];
        
        // 파워 계산: |F|²
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                double mag = spectrum[u, v].Magnitude;
                power[u, v] = mag * mag;
                if (power[u, v] > maxPower) maxPower = power[u, v];
            }
        }
        
        // 로그 스케일 적용 및 정규화
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                double logPower = Math.Log(1 + power[u, v]);
                int value = (int)(255 * logPower / Math.Log(1 + maxPower));
                
                image.SetPixel(u, v, (byte)Math.Clamp(value, 0, 255));
            }
        }
        
        return image;
    }
}
```

### 스펙트럼 패턴 분석

```csharp
public class SpectrumAnalyzer
{
    // 주파수 대역별 에너지 분석
    public static Dictionary<string, double> AnalyzeFrequencyBands(ComplexNumber[,] spectrum)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        int centerX = width / 2;
        int centerY = height / 2;
        
        double totalEnergy = 0;
        Dictionary<string, double> bandEnergies = new Dictionary<string, double>
        {
            ["UltraLow"] = 0,    // 0-10%
            ["VeryLow"] = 0,     // 10-25%
            ["Low"] = 0,         // 25-40%
            ["Mid"] = 0,         // 40-60%
            ["High"] = 0,        // 60-75%
            ["VeryHigh"] = 0,    // 75-90%
            ["UltraHigh"] = 0    // 90-100%
        };
        
        // 주파수 대역별 에너지 계산
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                // 정규화된 거리 계산 (0~1)
                double distance = Math.Sqrt(
                    Math.Pow((u - centerX) / (double)centerX, 2) +
                    Math.Pow((v - centerY) / (double)centerY, 2));
                
                // 에너지 계산
                double energy = spectrum[u, v].Magnitude * spectrum[u, v].Magnitude;
                totalEnergy += energy;
                
                // 대역 분류
                if (distance <= 0.1) bandEnergies["UltraLow"] += energy;
                else if (distance <= 0.25) bandEnergies["VeryLow"] += energy;
                else if (distance <= 0.4) bandEnergies["Low"] += energy;
                else if (distance <= 0.6) bandEnergies["Mid"] += energy;
                else if (distance <= 0.75) bandEnergies["High"] += energy;
                else if (distance <= 0.9) bandEnergies["VeryHigh"] += energy;
                else bandEnergies["UltraHigh"] += energy;
            }
        }
        
        // 정규화 (에너지 비율로 변환)
        foreach (var key in bandEnergies.Keys.ToList())
        {
            bandEnergies[key] /= totalEnergy;
        }
        
        return bandEnergies;
    }
    
    // 방향성 분석 (에지 방향 감지)
    public static Dictionary<string, double> AnalyzeDirectionality(ComplexNumber[,] spectrum)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        int centerX = width / 2;
        int centerY = height / 2;
        
        // 8개 방향으로 분류
        Dictionary<string, double> directionEnergies = new Dictionary<string, double>
        {
            ["Horizontal"] = 0,      // 0°
            ["Diagonal45"] = 0,      // 45°
            ["Vertical"] = 0,        // 90°
            ["Diagonal135"] = 0,     // 135°
            ["Horizontal2"] = 0,     // 180° (대칭)
            ["Diagonal225"] = 0,     // 225°
            ["Vertical2"] = 0,       // 270°
            ["Diagonal315"] = 0      // 315°
        };
        
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                // 중심에서의 상대적 위치
                int dx = u - centerX;
                int dy = v - centerY;
                
                // 거리가 너무 가까운 중심부는 제외
                double distance = Math.Sqrt(dx * dx + dy * dy);
                if (distance < 5) continue;
                
                // 각도 계산 (-π ~ π)
                double angle = Math.Atan2(dy, dx);
                if (angle < 0) angle += 2 * Math.PI;
                
                // 에너지
                double energy = spectrum[u, v].Magnitude;
                
                // 방향 분류
                double deg = angle * 180 / Math.PI;
                
                if ((deg >= 337.5 || deg < 22.5) || (deg >= 157.5 && deg < 202.5))
                    directionEnergies["Horizontal"] += energy;
                else if ((deg >= 22.5 && deg < 67.5) || (deg >= 202.5 && deg < 247.5))
                    directionEnergies["Diagonal45"] += energy;
                else if ((deg >= 67.5 && deg < 112.5) || (deg >= 247.5 && deg < 292.5))
                    directionEnergies["Vertical"] += energy;
                else
                    directionEnergies["Diagonal135"] += energy;
            }
        }
        
        // 정규화
        double total = directionEnergies.Values.Sum();
        foreach (var key in directionEnergies.Keys.ToList())
        {
            directionEnergies[key] /= total;
        }
        
        return directionEnergies;
    }
}
```

---

## 주파수 도메인 필터링

### 기본 개념: 회선 정리(Convolution Theorem)

공간 도메인에서의 회선은 주파수 도메인에서의 곱셈과 동일합니다:

$$
f(x,y) \ast h(x,y) \Leftrightarrow F(u,v) \cdot H(u,v)
$$

이 원리를 이용하면 복잡한 공간 필터링을 단순한 주파수 곱셈으로 변환할 수 있습니다.

### 필터 설계 기본 원리

```csharp
public abstract class FrequencyFilter
{
    // 필터 함수 인터페이스
    public abstract double GetFilterValue(int u, int v, int width, int height);
    
    // 필터 적용 메서드
    public ComplexNumber[,] ApplyFilter(ComplexNumber[,] spectrum)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        ComplexNumber[,] filtered = new ComplexNumber[width, height];
        
        // 주파수 셔플링된 상태에서 필터 적용을 위해 중심 계산
        int centerU = width / 2;
        int centerV = height / 2;
        
        Parallel.For(0, width, u =>
        {
            for (int v = 0; v < height; v++)
            {
                // 중심을 기준으로 한 거리
                int du = u - centerU;
                int dv = v - centerV;
                
                // 필터 값 계산 (0~1 범위)
                double filterValue = GetFilterValue(du, dv, width, height);
                
                // 스펙트럼에 필터 적용
                filtered[u, v] = spectrum[u, v] * filterValue;
            }
        });
        
        return filtered;
    }
}
```

### 다양한 필터 유형 구현

#### 1. 이상적 필터(Ideal Filter)

```csharp
public class IdealFilter : FrequencyFilter
{
    private readonly double _cutoffFrequency;
    private readonly bool _isHighPass;
    
    public IdealFilter(double cutoffFrequency, bool isHighPass = false)
    {
        _cutoffFrequency = cutoffFrequency;
        _isHighPass = isHighPass;
    }
    
    public override double GetFilterValue(int du, int dv, int width, int height)
    {
        // 정규화된 거리 계산 (0~1)
        double maxDistance = Math.Sqrt(width * width / 4.0 + height * height / 4.0);
        double distance = Math.Sqrt(du * du + dv * dv) / maxDistance;
        
        // 이상적 필터 응답
        bool pass = distance <= _cutoffFrequency;
        
        if (_isHighPass)
            return pass ? 0.0 : 1.0;
        else
            return pass ? 1.0 : 0.0;
    }
}
```

#### 2. 버터워스 필터(Butterworth Filter)

```csharp
public class ButterworthFilter : FrequencyFilter
{
    private readonly double _cutoffFrequency;
    private readonly int _order;
    private readonly bool _isHighPass;
    
    public ButterworthFilter(double cutoffFrequency, int order = 2, bool isHighPass = false)
    {
        _cutoffFrequency = cutoffFrequency;
        _order = order;
        _isHighPass = isHighPass;
    }
    
    public override double GetFilterValue(int du, int dv, int width, int height)
    {
        // 정규화된 거리 계산
        double maxDistance = Math.Sqrt(width * width / 4.0 + height * height / 4.0);
        double distance = Math.Sqrt(du * du + dv * dv) / maxDistance;
        
        // 버터워스 필터 응답
        double dOverD0 = distance / _cutoffFrequency;
        double butterworth = 1.0 / (1.0 + Math.Pow(dOverD0, 2 * _order));
        
        return _isHighPass ? 1.0 - butterworth : butterworth;
    }
}
```

#### 3. 가우시안 필터(Gaussian Filter)

```csharp
public class GaussianFilter : FrequencyFilter
{
    private readonly double _sigma;
    private readonly bool _isHighPass;
    
    public GaussianFilter(double sigma, bool isHighPass = false)
    {
        _sigma = sigma;
        _isHighPass = isHighPass;
    }
    
    public override double GetFilterValue(int du, int dv, int width, int height)
    {
        // 정규화된 거리 계산
        double maxDistance = Math.Sqrt(width * width / 4.0 + height * height / 4.0);
        double distance = Math.Sqrt(du * du + dv * dv) / maxDistance;
        
        // 가우시안 필터 응답
        double exponent = -(distance * distance) / (2 * _sigma * _sigma);
        double gaussian = Math.Exp(exponent);
        
        return _isHighPass ? 1.0 - gaussian : gaussian;
    }
}
```

#### 4. 동적 범위 조정 필터

```csharp
public class DynamicRangeFilter : FrequencyFilter
{
    private readonly double _lowCutoff;
    private readonly double _highCutoff;
    private readonly double _boostFactor;
    
    public DynamicRangeFilter(double lowCutoff, double highCutoff, double boostFactor = 1.0)
    {
        _lowCutoff = lowCutoff;
        _highCutoff = highCutoff;
        _boostFactor = boostFactor;
    }
    
    public override double GetFilterValue(int du, int dv, int width, int height)
    {
        double maxDistance = Math.Sqrt(width * width / 4.0 + height * height / 4.0);
        double distance = Math.Sqrt(du * du + dv * dv) / maxDistance;
        
        if (distance < _lowCutoff)
        {
            // 저주파: 약간 감소
            return 0.8;
        }
        else if (distance > _highCutoff)
        {
            // 고주파: 약간 증가
            return 1.2 * _boostFactor;
        }
        else
        {
            // 중주파: 유지
            return 1.0 * _boostFactor;
        }
    }
}
```

### 실제 필터링 파이프라인

```csharp
public class FrequencyDomainFilteringPipeline
{
    public static MyImage ApplyFrequencyFilter(
        MyImage inputImage, 
        FrequencyFilter filter,
        bool visualizeSpectrum = false)
    {
        // 1. 입력 영상을 주파수 도메인으로 변환
        ComplexNumber[,] spectrum = FFT2DProcessor.FFT2D(inputImage);
        
        // 2. 주파수 셔플링 (저주파를 중심으로)
        ComplexNumber[,] shiftedSpectrum = SpectrumVisualizer.ShiftFrequency(spectrum);
        
        // 3. 필터 적용
        ComplexNumber[,] filteredSpectrum = filter.ApplyFilter(shiftedSpectrum);
        
        // 4. 역 셔플링
        ComplexNumber[,] unshiftedSpectrum = SpectrumVisualizer.ShiftFrequency(filteredSpectrum);
        
        // 5. 역 FFT로 공간 도메인으로 변환
        MyImage result = FFT2DProcessor.IFFT2D(unshiftedSpectrum);
        
        // 6. 시각화 옵션
        if (visualizeSpectrum)
        {
            MyImage magnitudeImage = SpectrumVisualizer.CreateMagnitudeImage(filteredSpectrum);
            // 시각화 결과를 별도로 저장하거나 표시
        }
        
        return result;
    }
    
    // 다중 필터 조합
    public static MyImage ApplyMultipleFilters(
        MyImage inputImage, 
        List<FrequencyFilter> filters)
    {
        // 주파수 도메인 변환
        ComplexNumber[,] spectrum = FFT2DProcessor.FFT2D(inputImage);
        ComplexNumber[,] shiftedSpectrum = SpectrumVisualizer.ShiftFrequency(spectrum);
        
        // 모든 필터 순차 적용
        foreach (var filter in filters)
        {
            shiftedSpectrum = filter.ApplyFilter(shiftedSpectrum);
        }
        
        // 역변환
        ComplexNumber[,] unshiftedSpectrum = SpectrumVisualizer.ShiftFrequency(shiftedSpectrum);
        return FFT2DProcessor.IFFT2D(unshiftedSpectrum);
    }
    
    // 적응형 필터링 (영상 내용에 기반)
    public static MyImage ApplyAdaptiveFiltering(MyImage inputImage)
    {
        // 1. 주파수 분석
        ComplexNumber[,] spectrum = FFT2DProcessor.FFT2D(inputImage);
        var bandAnalysis = SpectrumAnalyzer.AnalyzeFrequencyBands(spectrum);
        
        // 2. 분석 결과에 기반한 필터 설계
        FrequencyFilter filter;
        
        if (bandAnalysis["High"] > 0.3)
        {
            // 고주파 잡음이 많음 → 저주파 통과 필터
            filter = new ButterworthFilter(0.3, 2, false);
        }
        else if (bandAnalysis["Low"] > 0.6)
        {
            // 저주파가 지배적 → 고주파 증폭
            filter = new ButterworthFilter(0.2, 2, true);
        }
        else
        {
            // 균형된 스펙트럼 → 동적 범위 조정
            filter = new DynamicRangeFilter(0.1, 0.7, 1.2);
        }
        
        // 3. 필터 적용
        return ApplyFrequencyFilter(inputImage, filter);
    }
}
```

### 필터 성능 비교 테이블

| 필터 유형 | 수학적 표현 | 장점 | 단점 | 적합한 용도 |
|-----------|-------------|------|------|------------|
| **이상적 LPF/HPF** | $$H(u,v) = \begin{cases}1 & D \leq D_0 \\ 0 & \text{otherwise}\end{cases}$$ | 명확한 컷오프 | 링잉 현상, 불연속 | 이론적 연구, 교육 |
| **버터워스** | $$H(u,v) = \frac{1}{1 + (D/D_0)^{2n}}$$ | 부드러운 전이, 링잉 적음 | 컷오프 주파수 주변 감쇠 | 일반적 필터링 |
| **가우시안** | $$H(u,v) = e^{-D^2/(2\sigma^2)}$$ | 최적 주파수-공간 균형, 링잉 없음 | 완만한 감쇠 | 자연 영상 처리 |
| **지수적** | $$H(u,v) = e^{-(D/D_0)^n}$$ | 가변적 기울기 | 계산 복잡 | 맞춤형 필터링 |
| **트랩** | 대역통과/대역저지 | 특정 대역 선택 | 파라미터 설정 복잡 | 주파수 대역 제거 |

---

## 고급 주파수 처리 기법

### 1. 위상만 필터링 (Phase-Only Filtering)

```csharp
public class PhaseOnlyFiltering
{
    // 위상만 유지 (크기는 1로 정규화)
    public static ComplexNumber[,] PhaseOnly(ComplexNumber[,] spectrum)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        ComplexNumber[,] result = new ComplexNumber[width, height];
        
        Parallel.For(0, width, u =>
        {
            for (int v = 0; v < height; v++)
            {
                ComplexNumber value = spectrum[u, v];
                double magnitude = value.Magnitude;
                double phase = value.Phase;
                
                // 크기를 1로 정규화하고 위상만 유지
                result[u, v] = ComplexNumber.FromPolar(1.0, phase);
            }
        });
        
        return result;
    }
    
    // 크기만 유지 (위상은 0으로 설정)
    public static ComplexNumber[,] MagnitudeOnly(ComplexNumber[,] spectrum)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        ComplexNumber[,] result = new ComplexNumber[width, height];
        
        Parallel.For(0, width, u =>
        {
            for (int v = 0; v < height; v++)
            {
                double magnitude = spectrum[u, v].Magnitude;
                
                // 위상은 0, 크기는 원래 값 유지
                result[u, v] = new ComplexNumber(magnitude, 0);
            }
        });
        
        return result;
    }
    
    // 위상-크기 교환 실험
    public static MyImage SwapPhaseAndMagnitude(MyImage image1, MyImage image2)
    {
        // 두 영상의 스펙트럼 계산
        ComplexNumber[,] spectrum1 = FFT2DProcessor.FFT2D(image1);
        ComplexNumber[,] spectrum2 = FFT2DProcessor.FFT2D(image2);
        
        // 크기와 위상 분리
        ComplexNumber[,] magnitude1 = MagnitudeOnly(spectrum1);
        ComplexNumber[,] phase2 = PhaseOnly(spectrum2);
        
        // 결합: image1의 크기 + image2의 위상
        ComplexNumber[,] combined = new ComplexNumber[
            magnitude1.GetLength(0), 
            magnitude1.GetLength(1)];
        
        for (int u = 0; u < combined.GetLength(0); u++)
        {
            for (int v = 0; v < combined.GetLength(1); v++)
            {
                double mag = magnitude1[u, v].Real;  // magnitude는 실수부에 저장됨
                double phase = phase2[u, v].Phase;
                combined[u, v] = ComplexNumber.FromPolar(mag, phase);
            }
        }
        
        // 역변환
        return FFT2DProcessor.IFFT2D(combined);
    }
}
```

### 2. 주파수 도메인에서의 노이즈 제거

```csharp
public class FrequencyDomainDenoising
{
    // 위너 필터 (Wiener Filter) - 주파수 도메인 버전
    public static ComplexNumber[,] ApplyWienerFilter(
        ComplexNumber[,] noisySpectrum,
        double noiseVariance,
        ComplexNumber[,] signalPSD = null)  // Power Spectral Density
    {
        int width = noisySpectrum.GetLength(0);
        int height = noisySpectrum.GetLength(1);
        ComplexNumber[,] result = new ComplexNumber[width, height];
        
        // 신호 PSD가 제공되지 않으면 추정
        if (signalPSD == null)
        {
            signalPSD = EstimateSignalPSD(noisySpectrum);
        }
        
        Parallel.For(0, width, u =>
        {
            for (int v = 0; v < height; v++)
            {
                // 위너 필터: H = P_s / (P_s + P_n)
                double signalPower = signalPSD[u, v].Magnitude;
                double filterValue = signalPower / (signalPower + noiseVariance);
                
                result[u, v] = noisySpectrum[u, v] * filterValue;
            }
        });
        
        return result;
    }
    
    private static ComplexNumber[,] EstimateSignalPSD(ComplexNumber[,] spectrum)
    {
        // 간단한 PSD 추정: 주변 평균 필터링
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        ComplexNumber[,] psd = new ComplexNumber[width, height];
        
        int windowSize = 3;
        int halfWindow = windowSize / 2;
        
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                double sum = 0;
                int count = 0;
                
                for (int du = -halfWindow; du <= halfWindow; du++)
                {
                    for (int dv = -halfWindow; dv <= halfWindow; dv++)
                    {
                        int nu = (u + du + width) % width;
                        int nv = (v + dv + height) % height;
                        
                        double magnitude = spectrum[nu, nv].Magnitude;
                        sum += magnitude * magnitude;
                        count++;
                    }
                }
                
                psd[u, v] = new ComplexNumber(sum / count, 0);
            }
        }
        
        return psd;
    }
    
    // 비국소 평균 (Non-local Means)의 주파수 도메인 버전
    public static ComplexNumber[,] NonLocalMeansFrequency(
        ComplexNumber[,] spectrum, 
        int searchWindow = 7,
        double h = 0.1)
    {
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        ComplexNumber[,] result = new ComplexNumber[width, height];
        
        // 패치 크기
        int patchSize = 3;
        int patchRadius = patchSize / 2;
        
        Parallel.For(0, width, u =>
        {
            for (int v = 0; v < height; v++)
            {
                ComplexNumber weightedSum = new ComplexNumber(0, 0);
                double weightSum = 0;
                
                // 탐색 창
                for (int du = -searchWindow/2; du <= searchWindow/2; du++)
                {
                    for (int dv = -searchWindow/2; dv <= searchWindow/2; dv++)
                    {
                        int nu = (u + du + width) % width;
                        int nv = (v + dv + height) % height;
                        
                        // 패치 유사도 계산 (주파수 도메인에서)
                        double similarity = CalculatePatchSimilarity(
                            spectrum, u, v, nu, nv, patchRadius);
                        
                        // 가중치 계산
                        double weight = Math.Exp(-similarity / (h * h));
                        
                        weightedSum += spectrum[nu, nv] * weight;
                        weightSum += weight;
                    }
                }
                
                result[u, v] = weightedSum / weightSum;
            }
        });
        
        return result;
    }
    
    private static double CalculatePatchSimilarity(
        ComplexNumber[,] spectrum,
        int u1, int v1, int u2, int v2,
        int patchRadius)
    {
        double sumSquaredDiff = 0;
        int count = 0;
        
        for (int du = -patchRadius; du <= patchRadius; du++)
        {
            for (int dv = -patchRadius; dv <= patchRadius; dv++)
            {
                int nu1 = (u1 + du + spectrum.GetLength(0)) % spectrum.GetLength(0);
                int nv1 = (v1 + dv + spectrum.GetLength(1)) % spectrum.GetLength(1);
                
                int nu2 = (u2 + du + spectrum.GetLength(0)) % spectrum.GetLength(0);
                int nv2 = (v2 + dv + spectrum.GetLength(1)) % spectrum.GetLength(1);
                
                double diff = spectrum[nu1, nv1].Magnitude - spectrum[nu2, nv2].Magnitude;
                sumSquaredDiff += diff * diff;
                count++;
            }
        }
        
        return sumSquaredDiff / count;
    }
}
```

### 3. 주파수 도메인에서의 영상 복원

```csharp
public class FrequencyDomainRestoration
{
    // 역필터 (Inverse Filtering)
    public static ComplexNumber[,] ApplyInverseFilter(
        ComplexNumber[,] degradedSpectrum,
        ComplexNumber[,] psfSpectrum,  // Point Spread Function의 스펙트럼
        double regularization = 0.01)   // 정규화 매개변수 (0으로 나눔 방지)
    {
        int width = degradedSpectrum.GetLength(0);
        int height = degradedSpectrum.GetLength(1);
        ComplexNumber[,] result = new ComplexNumber[width, height];
        
        Parallel.For(0, width, u =>
        {
            for (int v = 0; v < height; v++)
            {
                ComplexNumber H = psfSpectrum[u, v];
                ComplexNumber G = degradedSpectrum[u, v];
                
                // 역필터: F = G / H
                // 정규화: F = G * H̅ / (|H|² + λ)
                ComplexNumber H_conj = H.Conjugate;
                double H_mag2 = H.Magnitude * H.Magnitude;
                
                ComplexNumber numerator = G * H_conj;
                double denominator = H_mag2 + regularization;
                
                result[u, v] = numerator / denominator;
            }
        });
        
        return result;
    }
    
    // 블라인드 디콘볼루션 (Blind Deconvolution) 초기화
    public static (ComplexNumber[,] restored, ComplexNumber[,] estimatedPSF) 
        BlindDeconvolution(
            ComplexNumber[,] degradedSpectrum,
            int maxIterations = 50,
            double mu = 0.01)
    {
        int width = degradedSpectrum.GetLength(0);
        int height = degradedSpectrum.GetLength(1);
        
        // 초기 PSF 추정 (디랙 델타 함수)
        ComplexNumber[,] psfSpectrum = new ComplexNumber[width, height];
        psfSpectrum[width/2, height/2] = new ComplexNumber(1, 0);
        psfSpectrum = FFT2DProcessor.FFT2D(
            FFT2DProcessor.IFFT2D(psfSpectrum));  // FFT로 변환
        
        // 초기 영상 추정
        ComplexNumber[,] imageSpectrum = degradedSpectrum.Clone() as ComplexNumber[,];
        
        // 반복적 최적화
        for (int iter = 0; iter < maxIterations; iter++)
        {
            // 1. 현재 PSF로 영상 업데이트 (위너 필터 사용)
            imageSpectrum = ApplyWienerFilter(
                degradedSpectrum, 0.01, imageSpectrum);
            
            // 2. 현재 영상으로 PSF 업데이트
            // (간단한 구현, 실제로는 더 복잡한 알고리즘 필요)
            UpdatePSFEstimation(ref psfSpectrum, degradedSpectrum, imageSpectrum, mu);
            
            // 3. 정규화
            NormalizePSF(ref psfSpectrum);
        }
        
        return (imageSpectrum, psfSpectrum);
    }
    
    private static void UpdatePSFEstimation(
        ref ComplexNumber[,] psfSpectrum,
        ComplexNumber[,] degradedSpectrum,
        ComplexNumber[,] imageSpectrum,
        double mu)
    {
        // 간단한 그래디언트 업데이트
        int width = psfSpectrum.GetLength(0);
        int height = psfSpectrum.GetLength(1);
        
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                ComplexNumber I = imageSpectrum[u, v];
                ComplexNumber I_conj = I.Conjugate;
                ComplexNumber G = degradedSpectrum[u, v];
                
                // 그래디언트: ∇ = I̅ * (G - I * H)
                ComplexNumber residual = G - I * psfSpectrum[u, v];
                ComplexNumber gradient = I_conj * residual;
                
                // 업데이트: H ← H + μ∇
                psfSpectrum[u, v] += gradient * mu;
            }
        }
    }
    
    private static void NormalizePSF(ref ComplexNumber[,] psfSpectrum)
    {
        // PSF의 합이 1이 되도록 정규화
        double sum = 0;
        int width = psfSpectrum.GetLength(0);
        int height = psfSpectrum.GetLength(1);
        
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                sum += psfSpectrum[u, v].Magnitude;
            }
        }
        
        if (sum > 0)
        {
            for (int u = 0; u < width; u++)
            {
                for (int v = 0; v < height; v++)
                {
                    psfSpectrum[u, v] /= sum;
                }
            }
        }
    }
}
```

### 4. 주파수 도메인 텍스처 분석

```csharp
public class FrequencyDomainTextureAnalysis
{
    // Gabor 필터 뱅크 (주파수 도메인 구현)
    public static List<MyImage> ApplyGaborFilterBank(MyImage inputImage, 
        int numOrientations = 8, int numScales = 4)
    {
        List<MyImage> filteredImages = new List<MyImage>();
        
        // 주파수 도메인으로 변환
        ComplexNumber[,] spectrum = FFT2DProcessor.FFT2D(inputImage);
        ComplexNumber[,] shiftedSpectrum = SpectrumVisualizer.ShiftFrequency(spectrum);
        
        // 다양한 방향과 스케일에 대한 Gabor 필터 생성 및 적용
        for (int scale = 0; scale < numScales; scale++)
        {
            double frequency = 0.1 * Math.Pow(2, scale);  // 주파수 증가
            
            for (int orientation = 0; orientation < numOrientations; orientation++)
            {
                double theta = orientation * Math.PI / numOrientations;
                
                // Gabor 필터 생성 (주파수 도메인)
                ComplexNumber[,] gaborFilter = CreateGaborFilterFrequency(
                    inputImage.Width, inputImage.Height,
                    frequency, theta, 0.5, 0.5);
                
                // 필터 적용
                ComplexNumber[,] filteredSpectrum = ApplyFilterToSpectrum(
                    shiftedSpectrum, gaborFilter);
                
                // 역변환
                ComplexNumber[,] unshifted = SpectrumVisualizer.ShiftFrequency(filteredSpectrum);
                MyImage filteredImage = FFT2DProcessor.IFFT2D(unshifted);
                
                filteredImages.Add(filteredImage);
            }
        }
        
        return filteredImages;
    }
    
    private static ComplexNumber[,] CreateGaborFilterFrequency(
        int width, int height,
        double frequency, double theta,
        double sigmaX, double sigmaY)
    {
        ComplexNumber[,] filter = new ComplexNumber[width, height];
        int centerX = width / 2;
        int centerY = height / 2;
        
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                // 중심을 기준으로 한 좌표
                double x = (u - centerX) / (double)width;
                double y = (v - centerY) / (double)height;
                
                // 회전된 좌표계
                double xPrime = x * Math.Cos(theta) + y * Math.Sin(theta);
                double yPrime = -x * Math.Sin(theta) + y * Math.Cos(theta);
                
                // Gabor 함수 (주파수 도메인)
                double gaussian = Math.Exp(-0.5 * (
                    (xPrime * xPrime) / (sigmaX * sigmaX) + 
                    (yPrime * yPrime) / (sigmaY * sigmaY)));
                
                double sinusoid = Math.Cos(2 * Math.PI * frequency * xPrime);
                
                filter[u, v] = new ComplexNumber(gaussian * sinusoid, 0);
            }
        }
        
        return filter;
    }
    
    // 텍스터 에너지 맵 계산
    public static MyImage CalculateTextureEnergyMap(MyImage inputImage, int windowSize = 15)
    {
        // 다양한 방향의 필터 응답 계산
        var gaborResponses = ApplyGaborFilterBank(inputImage, 4, 2);
        
        // 에너지 맵 초기화
        MyImage energyMap = new MyImage(inputImage.Width, inputImage.Height);
        
        // 각 픽셀에서 필터 응답의 에너지 계산
        for (int y = 0; y < inputImage.Height; y++)
        {
            for (int x = 0; x < inputImage.Width; x++)
            {
                double totalEnergy = 0;
                
                foreach (var response in gaborResponses)
                {
                    // 로컬 에너지 계산 (주변 창 평균)
                    double localEnergy = 0;
                    int halfWindow = windowSize / 2;
                    int count = 0;
                    
                    for (int dy = -halfWindow; dy <= halfWindow; dy++)
                    {
                        for (int dx = -halfWindow; dx <= halfWindow; dx++)
                        {
                            int nx = x + dx;
                            int ny = y + dy;
                            
                            if (nx >= 0 && nx < inputImage.Width && 
                                ny >= 0 && ny < inputImage.Height)
                            {
                                double value = response.GetPixel(nx, ny);
                                localEnergy += value * value;
                                count++;
                            }
                        }
                    }
                    
                    localEnergy /= count;
                    totalEnergy += localEnergy;
                }
                
                // 평균 에너지
                double avgEnergy = totalEnergy / gaborResponses.Count;
                
                // 정규화 및 저장
                int intensity = (int)(255 * Math.Tanh(avgEnergy / 1000.0));
                energyMap.SetPixel(x, y, (byte)Math.Clamp(intensity, 0, 255));
            }
        }
        
        return energyMap;
    }
}
```

---

## 성능 최적화 및 실용적 고려사항

### 1. 메모리 최적화

```csharp
public class MemoryOptimizedFFT
{
    // 제자리 FFT (In-place FFT)
    public static void FFTInPlace(ComplexNumber[] data)
    {
        int n = data.Length;
        
        // 비트 반전 정렬 (제자리)
        for (int i = 1, j = 0; i < n; i++)
        {
            int bit = n >> 1;
            for (; (j & bit) != 0; bit >>= 1)
                j ^= bit;
            j ^= bit;
            
            if (i < j)
                (data[i], data[j]) = (data[j], data[i]);
        }
        
        // 제자리 FFT 계산
        for (int len = 2; len <= n; len <<= 1)
        {
            double angle = -2 * Math.PI / len;
            ComplexNumber wlen = new ComplexNumber(Math.Cos(angle), Math.Sin(angle));
            
            for (int i = 0; i < n; i += len)
            {
                ComplexNumber w = new ComplexNumber(1, 0);
                for (int j = 0; j < len / 2; j++)
                {
                    ComplexNumber u = data[i + j];
                    ComplexNumber v = data[i + j + len / 2] * w;
                    
                    data[i + j] = u + v;
                    data[i + j + len / 2] = u - v;
                    
                    w = w * wlen;
                }
            }
        }
    }
    
    // 실수 입력 FFT (Hermitian 대칭 활용)
    public static ComplexNumber[] FFTReal(double[] realInput)
    {
        int n = realInput.Length;
        
        // 복소수 배열로 변환 (허수부는 0)
        ComplexNumber[] complexData = new ComplexNumber[n];
        for (int i = 0; i < n; i++)
            complexData[i] = new ComplexNumber(realInput[i], 0);
        
        // FFT 적용
        FFTInPlace(complexData);
        
        return complexData;
    }
}
```

### 2. 병렬 처리 및 SIMD 최적화

```csharp
public class ParallelFFT
{
    // 다중 스레드 2D FFT
    public static ComplexNumber[,] ParallelFFT2D(MyImage image)
    {
        int width = image.Width;
        int height = image.Height;
        
        // 행 방향 FFT (병렬)
        ComplexNumber[,] rowFFT = new ComplexNumber[width, height];
        
        Parallel.For(0, height, y =>
        {
            ComplexNumber[] row = new ComplexNumber[width];
            for (int x = 0; x < width; x++)
                row[x] = new ComplexNumber(image.GetPixel(x, y), 0);
            
            ComplexNumber[] rowTransformed = FFTProcessor.FFTIterative(row);
            
            for (int x = 0; x < width; x++)
                rowFFT[x, y] = rowTransformed[x];
        });
        
        // 열 방향 FFT (병렬)
        ComplexNumber[,] result = new ComplexNumber[width, height];
        
        Parallel.For(0, width, x =>
        {
            ComplexNumber[] column = new ComplexNumber[height];
            for (int y = 0; y < height; y++)
                column[y] = rowFFT[x, y];
            
            ComplexNumber[] columnTransformed = FFTProcessor.FFTIterative(column);
            
            for (int y = 0; y < height; y++)
                result[x, y] = columnTransformed[y];
        });
        
        return result;
    }
    
    // SIMD 최적화를 위한 벡터화 FFT
    public static unsafe ComplexNumber[] FFTVectorized(ComplexNumber[] input)
    {
        int n = input.Length;
        
        // SIMD 명령어 세트 확인
        if (System.Numerics.Vector.IsHardwareAccelerated && n >= 4)
        {
            return FFTVectorizedSIMD(input);
        }
        else
        {
            // 일반 FFT 폴백
            return FFTProcessor.FFTIterative(input);
        }
    }
    
    private static unsafe ComplexNumber[] FFTVectorizedSIMD(ComplexNumber[] input)
    {
        // SIMD를 이용한 FFT 구현
        // 실제 구현은 하드웨어와 라이브러리에 의존적
        int n = input.Length;
        ComplexNumber[] output = new ComplexNumber[n];
        
        // SIMD 연산을 위한 메모리 정렬
        fixed (ComplexNumber* pInput = input)
        fixed (ComplexNumber* pOutput = output)
        {
            // 벡터화된 FFT 알고리즘 구현
            // (복잡한 구현으로 인해 개요만 제공)
        }
        
        return output;
    }
}
```

### 3. 캐시 친화적 FFT

```csharp
public class CacheFriendlyFFT
{
    // 타일 기반 2D FFT
    public static ComplexNumber[,] TiledFFT2D(MyImage image, int tileSize = 32)
    {
        int width = image.Width;
        int height = image.Height;
        
        // 입력 데이터를 타일로 분할
        int tilesX = (width + tileSize - 1) / tileSize;
        int tilesY = (height + tileSize - 1) / tileSize;
        
        ComplexNumber[,] result = new ComplexNumber[width, height];
        
        // 각 타일에 대해 독립적으로 FFT 적용
        Parallel.For(0, tilesX * tilesY, tileIndex =>
        {
            int tileX = tileIndex % tilesX;
            int tileY = tileIndex / tilesX;
            
            int startX = tileX * tileSize;
            int startY = tileY * tileSize;
            int endX = Math.Min(startX + tileSize, width);
            int endY = Math.Min(startY + tileSize, height);
            
            // 작은 타일에 대한 로컬 FFT
            ProcessTile(image, result, startX, endX, startY, endY);
        });
        
        // 타일 경계 보정 (선택적)
        CorrectTileBoundaries(result, tileSize);
        
        return result;
    }
    
    private static void ProcessTile(
        MyImage image, 
        ComplexNumber[,] result,
        int startX, int endX, 
        int startY, int endY)
    {
        int tileWidth = endX - startX;
        int tileHeight = endY - startY;
        
        // 타일 데이터 추출
        ComplexNumber[,] tileData = new ComplexNumber[tileWidth, tileHeight];
        for (int y = startY; y < endY; y++)
        {
            for (int x = startX; x < endX; x++)
            {
                tileData[x - startX, y - startY] = 
                    new ComplexNumber(image.GetPixel(x, y), 0);
            }
        }
        
        // 타일에 대한 2D FFT (작은 크기라 효율적)
        ComplexNumber[,] tileFFT = ComputeSmall2DFFT(tileData);
        
        // 결과 저장
        for (int y = startY; y < endY; y++)
        {
            for (int x = startX; x < endX; x++)
            {
                result[x, y] = tileFFT[x - startX, y - startY];
            }
        }
    }
    
    private static ComplexNumber[,] ComputeSmall2DFFT(ComplexNumber[,] tile)
    {
        // 작은 크기의 타일에 대해 직접 계산이나 작은 FFT 사용
        int width = tile.GetLength(0);
        int height = tile.GetLength(1);
        
        if (width <= 16 && height <= 16)
        {
            // 작은 크기는 직접 계산이 더 빠를 수 있음
            return DFTProcessor.ComputeDFTDirect(ConvertToImage(tile));
        }
        else
        {
            // 일반 FFT 사용
            return FFT2DProcessor.FFT2D(ConvertToImage(tile));
        }
    }
    
    private static MyImage ConvertToImage(ComplexNumber[,] complexData)
    {
        int width = complexData.GetLength(0);
        int height = complexData.GetLength(1);
        MyImage image = new MyImage(width, height);
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                // 크기만 사용 (실제 구현에서는 적절한 변환 필요)
                double value = complexData[x, y].Magnitude;
                image.SetPixel(x, y, (byte)Math.Clamp(value, 0, 255));
            }
        }
        
        return image;
    }
}
```

---

## 실제 응용 사례

### 1. 의료 영상 주파수 분석

```csharp
public class MedicalImageFrequencyAnalysis
{
    // MRI 영상의 주파수 특성 분석
    public class MRIFrequencyAnalysisResult
    {
        public double TissueHomogeneity { get; set; }
        public double NoiseLevel { get; set; }
        public double EdgeSharpness { get; set; }
        public Dictionary<string, double> FrequencyBands { get; set; }
        public MyImage FrequencyMask { get; set; }
    }
    
    public static MRIFrequencyAnalysisResult AnalyzeMRIImage(MyImage mriImage)
    {
        // 주파수 도메인 변환
        ComplexNumber[,] spectrum = FFT2DProcessor.FFT2D(mriImage);
        ComplexNumber[,] shifted = SpectrumVisualizer.ShiftFrequency(spectrum);
        
        // 주파수 대역 분석
        var bands = SpectrumAnalyzer.AnalyzeFrequencyBands(shifted);
        
        // 조직 균질성 분석 (저주파 대역 에너지 비율)
        double tissueHomogeneity = bands["UltraLow"] + bands["VeryLow"] + bands["Low"];
        
        // 노이즈 수준 분석 (고주파 대역 에너지 비율)
        double noiseLevel = bands["High"] + bands["VeryHigh"] + bands["UltraHigh"];
        
        // 에지 선명도 분석 (중주파 대역 에너지 비율)
        double edgeSharpness = bands["Mid"];
        
        // 병변 탐지를 위한 주파수 마스크 생성
        MyImage frequencyMask = CreateFrequencyMaskForLesionDetection(shifted);
        
        return new MRIFrequencyAnalysisResult
        {
            TissueHomogeneity = tissueHomogeneity,
            NoiseLevel = noiseLevel,
            EdgeSharpness = edgeSharpness,
            FrequencyBands = bands,
            FrequencyMask = frequencyMask
        };
    }
    
    private static MyImage CreateFrequencyMaskForLesionDetection(ComplexNumber[,] spectrum)
    {
        // 병변은 일반적으로 특정 주파수 대역에서 나타남
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        MyImage mask = new MyImage(width, height);
        
        int centerX = width / 2;
        int centerY = height / 2;
        
        for (int u = 0; u < width; u++)
        {
            for (int v = 0; v < height; v++)
            {
                // 중심에서의 거리
                double distance = Math.Sqrt(
                    Math.Pow(u - centerX, 2) + 
                    Math.Pow(v - centerY, 2));
                
                // 병변에 민감한 주파수 대역 (중간 주파수)
                double lowerBound = Math.Min(width, height) * 0.1;
                double upperBound = Math.Min(width, height) * 0.3;
                
                if (distance >= lowerBound && distance <= upperBound)
                {
                    // 해당 주파수 강조
                    double magnitude = spectrum[u, v].Magnitude;
                    int intensity = (int)(255 * Math.Log(1 + magnitude) / 10);
                    mask.SetPixel(u, v, (byte)Math.Clamp(intensity, 0, 255));
                }
                else
                {
                    mask.SetPixel(u, v, 0);
                }
            }
        }
        
        return mask;
    }
}
```

### 2. 위조 방지 및 영상 인증

```csharp
public class ImageForensics
{
    // 주파수 도메인을 이용한 위조 탐지
    public class ForgeryDetectionResult
    {
        public bool IsTampered { get; set; }
        public double TamperingConfidence { get; set; }
        public List<Rectangle> SuspectedRegions { get; set; }
        public string TamperingType { get; set; }
    }
    
    public static ForgeryDetectionResult DetectForgery(MyImage image)
    {
        // 주파수 분석을 통한 위조 탐지
        ComplexNumber[,] spectrum = FFT2DProcessor.FFT2D(image);
        ComplexNumber[,] shifted = SpectrumVisualizer.ShiftFrequency(spectrum);
        
        // 1. JPEG 압축 아티팩트 분석
        double jpegArtifactScore = AnalyzeJPEGArtifacts(shifted);
        
        // 2. 복사-붙여넣기 탐지
        var copyMoveRegions = DetectCopyMoveForgery(spectrum);
        
        // 3. 리샘플링 아티팩트 탐지
        double resamplingScore = DetectResamplingArtifacts(spectrum);
        
        // 종합 판단
        bool isTampered = jpegArtifactScore > 0.8 || 
                         copyMoveRegions.Count > 0 || 
                         resamplingScore > 0.7;
        
        double confidence = Math.Max(jpegArtifactScore, resamplingScore);
        
        return new ForgeryDetectionResult
        {
            IsTampered = isTampered,
            TamperingConfidence = confidence,
            SuspectedRegions = copyMoveRegions,
            TamperingType = DetermineTamperingType(
                jpegArtifactScore, copyMoveRegions.Count, resamplingScore)
        };
    }
    
    private static double AnalyzeJPEGArtifacts(ComplexNumber[,] spectrum)
    {
        // JPEG 압축은 주파수 도메인에서 특정 패턴 생성
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        
        // 8x8 블록 경계에서의 고주파 성분 분석
        double blockArtifactScore = 0;
        int blockCount = 0;
        
        for (int blockY = 0; blockY < height; blockY += 8)
        {
            for (int blockX = 0; blockX < width; blockX += 8)
            {
                // 블록 경계에서의 주파수 응답 분석
                double blockScore = AnalyzeBlockBoundary(spectrum, blockX, blockY);
                blockArtifactScore += blockScore;
                blockCount++;
            }
        }
        
        return blockArtifactScore / blockCount;
    }
    
    private static List<Rectangle> DetectCopyMoveForgery(ComplexNumber[,] spectrum)
    {
        // 복사-붙여넣기 영역은 유사한 주파수 패턴을 가짐
        List<Rectangle> regions = new List<Rectangle>();
        
        // 주파수 도메인에서의 상관관계 분석
        int width = spectrum.GetLength(0);
        int height = spectrum.GetLength(1);
        
        // 주파수 특징 추출 및 비교
        var featureVectors = ExtractFrequencyFeatures(spectrum, 32);
        
        // 유사한 특징 벡터 쌍 찾기
        var similarPairs = FindSimilarFeatureVectors(featureVectors, 0.95);
        
        // 유사한 영역을 사각형으로 변환
        foreach (var pair in similarPairs)
        {
            regions.Add(new Rectangle(pair.Region1));
            regions.Add(new Rectangle(pair.Region2));
        }
        
        return regions;
    }
}
```

### 3. 위성 영상 주파수 분석

```csharp
public class SatelliteImageAnalysis
{
    // 토지 피복 분류를 위한 주파수 분석
    public enum LandCoverType
    {
        Urban,      // 도시 지역 (고주파 성분 많음)
        Forest,     // 산림 지역 (중주파 성분 많음)
        Water,      // 수역 (저주파 성분 많음)
        Agriculture,// 농경지 (주기적 패턴)
        Desert      // 사막 지역 (균일한 스펙트럼)
    }
    
    public static LandCoverType ClassifyLandCover(MyImage satelliteImage)
    {
        // 주파수 분석 수행
        ComplexNumber[,] spectrum = FFT2DProcessor.FFT2D(satelliteImage);
        var bands = SpectrumAnalyzer.AnalyzeFrequencyBands(spectrum);
        var directions = SpectrumAnalyzer.AnalyzeDirectionality(spectrum);
        
        // 특징 추출
        double lowFreqRatio = bands["UltraLow"] + bands["VeryLow"] + bands["Low"];
        double midFreqRatio = bands["Mid"];
        double highFreqRatio = bands["High"] + bands["VeryHigh"] + bands["UltraHigh"];
        
        double directionality = Math.Max(
            directions["Horizontal"],
            Math.Max(directions["Vertical"], directions["Diagonal45"]));
        
        // 분류 규칙
        if (highFreqRatio > 0.4 && directionality > 0.3)
            return LandCoverType.Urban;  // 도시: 고주파 + 방향성
        
        if (midFreqRatio > 0.5 && directionality < 0.2)
            return LandCoverType.Forest;  // 산림: 중주파 + 무방향성
        
        if (lowFreqRatio > 0.7)
            return LandCoverType.Water;  // 수역: 저주파 우세
        
        if (directionality > 0.4 && Math.Abs(directions["Horizontal"] - directions["Vertical"]) < 0.1)
            return LandCoverType.Agriculture;  // 농경지: 규칙적 패턴
        
        return LandCoverType.Desert;  // 사막: 균일한 분포
    }
    
    // 도시 확산 분석
    public static double AnalyzeUrbanSprawl(MyImage timeSeries1, MyImage timeSeries2)
    {
        // 시간에 따른 주파수 변화 분석
        ComplexNumber[,] spectrum1 = FFT2DProcessor.FFT2D(timeSeries1);
        ComplexNumber[,] spectrum2 = FFT2DProcessor.FFT2D(timeSeries2);
        
        var bands1 = SpectrumAnalyzer.AnalyzeFrequencyBands(spectrum1);
        var bands2 = SpectrumAnalyzer.AnalyzeFrequencyBands(spectrum2);
        
        // 고주파 성분 증가량 계산 (도시화 지표)
        double highFreq1 = bands1["High"] + bands1["VeryHigh"] + bands1["UltraHigh"];
        double highFreq2 = bands2["High"] + bands2["VeryHigh"] + bands2["UltraHigh"];
        
        return (highFreq2 - highFreq1) / highFreq1 * 100;  // 변화율 (%)
    }
}
```

---

## 성능 비교 및 선택 가이드

### 알고리즘 성능 비교 표

| 알고리즘 | 시간 복잡도 | 공간 복잡도 | 정확도 | 적합한 크기 | 활용 분야 |
|----------|------------|-------------|--------|-------------|-----------|
| **직접 DFT** | O(N²) | O(1) | 정확 | N ≤ 32 | 교육, 이론 연구 |
| **재귀적 FFT** | O(N log N) | O(N log N) | 정확 | N ≤ 4096 | 일반적 용도 |
| **비재귀적 FFT** | O(N log N) | O(N) | 정확 | 모든 크기 | 실시간 처리 |
| **분할 기준 FFT** | O(N log N) | O(N) | 정확 | N = 4^k | 특수 하드웨어 |
| **블루스타인 FFT** | O(N log N) | O(N) | 정확 | 임의 크기 | 비2의 거듭제곱 |
| **SFFT (희소 FFT)** | O(k log N) | O(k) | 근사적 | k ≪ N | 희소 신호 |

### 주파수 도메인 vs 공간 도메인 필터링 비교

| 기준 | 주파수 도메인 | 공간 도메인 |
|------|---------------|-------------|
| **계산 효율성** | 큰 커널에 유리 (O(N log N)) | 작은 커널에 유리 (O(N·K²)) |
| **정확도** | 정확한 주파수 선택 | 근사적 |
| **구현 복잡도** | 복잡 (FFT 필요) | 간단 |
| **메모리 사용** | 높음 (복소수 스펙트럼) | 낮음 |
| **적합한 필터** | 주파수 선택적 필터 | 지역적 필터 |
| **병렬화** | 용이 (분할 가능) | 제한적 |

### 응용 분야별 추천 기법

```
응용 분야 분석
│
├── 실시간 처리 필요?
│   ├── Yes → 작은 FFT 윈도우 또는 공간 필터링
│   └── No → 고품질 FFT 기반 처리
│
├── 정확한 주파수 제어 필요?
│   ├── Yes → 주파수 도메인 필터링
│   └── No → 공간 도메인 필터링
│
├── 대용량 데이터 처리?
│   ├── Yes → 타일 기반 FFT, 메모리 최적화
│   └── No → 전체 FFT
│
└── 특수 요구사항?
    ├── 의료/과학적 분석 → 고정밀 FFT, 위상 분석
    ├── 실시간 영상 처리 → SIMD 최적화 FFT
    ├── 모바일 장치 → 저전력 FFT, 메모리 최적화
    └── 연구/교육 → 직접 DFT, 다양한 알고리즘 비교
```

### 구현 선택 체크리스트

- [ ] 입력 크기가 2의 거듭제곱인가?
- [ ] 실시간 처리 요구사항 확인
- [ ] 메모리 제약 조건 확인
- [ ] 정밀도 요구사항 확인 (단정밀도/배정밀도)
- [ ] 하드웨어 가속 가능성 확인 (GPU, SIMD)
- [ ] 다중 스레딩 지원 필요 여부
- [ ] 역변환 필요 여부 및 정확도 요구사항
- [ ] 경계 처리 전략 결정

---

## 결론 및 미래 전망

### 핵심 정리

1. **푸리에 변환의 핵심**: 공간 도메인과 주파수 도메인 간의 변환 도구
2. **FFT의 중요성**: DFT의 실용적 구현, 계산 복잡도 대폭 감소
3. **주파수 분석의 강점**: 전역적 특성 분석, 효율적 필터링
4. **적용 분야의 다양성**: 의료 영상, 위성 영상, 위조 탐지, 음성 처리 등

### 구현 모범 사례

1. **알고리즘 선택**: 응용 분야와 제약 조건에 맞는 알고리즘 선택
2. **메모리 관리**: 큰 영상 처리 시 타일 기반 접근법 활용
3. **병렬 처리**: 다중 코어 활용을 위한 Parallel.For 적극 사용
4. **정확도 보장**: 부동소수점 오차 고려, 적절한 데이터 타입 선택
5. **검증 및 테스트**: 역변환을 통한 정확도 검증, 다양한 테스트 케이스

### 미래 발전 방향

1. **양자 푸리에 변환**: 양자 컴퓨팅을 활용한 초고속 변환
2. **신경망 기반 변환**: 딥러닝을 이용한 적응형 주파수 분석
3. **실시간 하드웨어 가속**: FPGA, GPU를 활용한 초고속 처리
4. **3D/4D FFT**: 입체적, 시계열 데이터 처리 확장
5. **압축 센싱**: 희소 신호 복원을 위한 고급 알고리즘
6. **에지 컴퓨팅**: 모바일 장치에서의 효율적 FFT 구현

주파수 공간 영상 처리는 단순한 기술 도구를 넘어, 영상의 본질을 이해하고 다양한 응용 분야에 혁신을 가져올 수 있는 강력한 패러다임입니다. 기본 원리를 이해하고 적절한 알고리즘을 선택하며, 최적화 기법을 적용함으로써 실용적이고 효율적인 영상 처리 시스템을 구축할 수 있습니다.