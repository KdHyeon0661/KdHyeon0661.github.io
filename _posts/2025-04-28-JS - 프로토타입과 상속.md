---
layout: post
title: JavaScript - 프로토타입과 상속
date: 2025-04-28 22:20:23 +0900
category: JavaScript
---
# 프로토타입과 상속

## 프로토타입 핵심 개념

### 프로토타입이란?

- **정의**: 객체가 다른 객체로 **속성 조회를 위임**하기 위해 참조하는 상위 객체.
- **표현**: 내부 슬롯 **`[[Prototype]]`**이 가리키는 객체.
- **효과**: 자신에게 속성이 없으면 **프로토타입 체인**을 따라 위로 올라가며 검색.

```js
const base = {
  greet() { console.log(`Hi, I'm ${this.name}`); }
};

const admin = Object.create(base); // base가 admin의 [[Prototype]]
admin.name = "Bob";
admin.greet(); // "Hi, I'm Bob"  (자기 자신에 greet 없음 → base.greet 위임)
```

체인 구조(개념도):
`admin → base → Object.prototype → null`

### 용어 정리: `[[Prototype]]` vs `__proto__` vs `prototype`

| 용어            | 대상         | 의미/용도                                                               |
|-----------------|--------------|-------------------------------------------------------------------------|
| `[[Prototype]]` | 모든 객체    | 내부 슬롯(표준). 프로토타입이 **실제로 저장**되는 위치. 직접 접근 불가 |
| `__proto__`     | 대부분의 객체| (웹 호환) **접근자 프로퍼티**로 `[[Prototype]]`에 간접 접근(설정/조회) |
| `prototype`     | 함수(객체)   | `new`로 만든 인스턴스의 `[[Prototype]]`가 되는 **연결 지점**           |

```js
function Person(name) { this.name = name; }
Person.prototype.say = function(){ console.log(this.name); };

const p = new Person("Tom");
// p.[[Prototype]] === Person.prototype
p.say(); // "Tom"
```

> 권장: 런타임 조작 시 `Object.getPrototypeOf`/`Object.setPrototypeOf` 사용(호환성과 명세 준수).

---

## 프로토타입 체인과 속성 탐색

### 조회 알고리즘(요약)

```
객체 자체 → 객체의 [[Prototype]] → 그 위의 [[Prototype]] → ... → null 도달 시 중단
```

```js
console.log(p.toString());
// p 자체에 없음 → Person.prototype에 없음 → Object.prototype.toString 사용
```

### 섀도잉(Shadowing)과 오버라이드(Override)

- **섀도잉**: 하위 객체가 **동명 데이터 프로퍼티**를 정의하여 상위의 같은 이름을 가림.
- **오버라이드**: 하위에서 **동명 메서드**로 상위를 대체.

```js
const animal = { speak(){ console.log("Animal"); } };
const dog = Object.create(animal);
dog.speak = function(){ console.log("Dog"); };
dog.speak(); // "Dog"
```

---

## 상속 구현 패턴

### 생성자 함수 기반(ES5 스타일)

```js
function Animal(name){ this.name = name; }
Animal.prototype.speak = function(){ console.log(`${this.name} makes noise`); };

function Dog(name){
  Animal.call(this, name); // super-like: 인스턴스 필드 상속
}
// 핵심: Dog 인스턴스의 [[Prototype]] 체인을 Animal.prototype에 연결
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog; // constructor 복구(관례)
Dog.prototype.speak = function(){ console.log(`${this.name} barks`); };

const d = new Dog("Rex");
d.speak(); // "Rex barks"
```

**포인트**
- `Animal.call(this, ...)`는 **인스턴스 초기화** 상속.
- `Dog.prototype = Object.create(Animal.prototype)`은 **프로토타입 체인 연결**.
- `constructor`를 다시 **Dog**로 설정(디버깅/표시 목적).

### 클래스(ES2015+)

```js
class Animal {
  constructor(name){ this.name = name; }
  speak(){ console.log(`${this.name} makes noise`); }
}
class Dog extends Animal {
  speak(){ console.log(`${this.name} barks`); }
}
new Dog("Max").speak(); // "Max barks"
```
- 내부적으로 여전히 **프로토타입**을 사용.
- `extends`는 `Dog.prototype.[[Prototype]] = Animal.prototype`를 구성.
- 클래스 본문 메서드는 **열거 불가**(enumerable: false), **strict** 모드.

### `Object.create`로 간단 상속(위임)

```js
const animal = { speak(){ console.log("noise"); } };
const dog = Object.create(animal);
dog.speak(); // "noise"
```
- **클래스 없이**도 위임 구조를 만들 수 있어 **조합/위임(Delegation)** 패턴에 적합.
- 디스크립터와 함께 사용하면 더 정교하게 구성 가능:
```js
const base = {};
const child = Object.create(base, {
  x: { value: 1, writable: true, enumerable: true, configurable: true }
});
```

---

## 도구: 프로토타입 접근/설정/검사

### 표준 API

```js
const o = {};
Object.getPrototypeOf(o);      // o의 [[Prototype]]
Object.setPrototypeOf(o, null);// o의 [[Prototype]]을 null로(체인 단절)
Object.prototype.isPrototypeOf(o); // 체인 내 포함 여부 확인
```

### `instanceof`와 `Symbol.hasInstance`

```js
d instanceof Dog;     // true (Dog.prototype이 d의 체인 상에 있음)
d instanceof Animal;  // true

// 사용자 정의 instanceof 동작
class Range {
  static [Symbol.hasInstance](v){ return typeof v === "number" && v>=0 && v<=100; }
}
42 instanceof Range; // true
```

---

## 프로퍼티 디스크립터/접근자와 프로토타입

### 데이터 vs 접근자 프로퍼티

- **데이터 프로퍼티**: `value`, `writable`, `enumerable`, `configurable`
- **접근자 프로퍼티**: `get`, `set`, `enumerable`, `configurable`

```js
const user = {};
Object.defineProperty(user, "score", {
  get(){ return this._s ?? 0; },
  set(v){ this._s = v; },
  enumerable: true, configurable: true
});

const vip = Object.create(user);
vip.score = 10;          // set 호출, this === vip
console.log(vip.score);  // 10  (get 호출)
```

> **주의**: 접근자(get/set)는 **호출 객체의 `this`**로 동작(상위 접근자를 하위가 그대로 사용 가능).

### 디스크립터 상속 효과

- 상위에 정의된 접근자/데이터 프로퍼티는 하위에서 **그대로 사용**.
- 하위에서 **동명 데이터 프로퍼티**를 `defineProperty`로 정의하면 상위 접근자를 가림(섀도잉).

---

## 오버라이딩 규칙과 `super`

### ES5(생성자)에서의 super-like 호출

```js
Dog.prototype.speak = function(){
  Animal.prototype.speak.call(this); // super 호출 효과
  console.log(`${this.name} barks`);
};
```

### 클래스에서 `super`

```js
class A { f(){ console.log("A"); } }
class B extends A {
  f(){
    super.f(); // A.prototype.f 호출
    console.log("B");
  }
}
new B().f(); // A \n B
```

---

## 정적 메서드 vs 인스턴스 메서드(클래스)

```js
class Util {
  static parse(str){ return new Util(str); } // 정적
  constructor(v){ this.v = v; }
  value(){ return this.v; }                  // 인스턴스
}
const u = Util.parse("x");
u.value(); // "x"
```

- `static` 메서드는 **생성자 함수 자체의 프로퍼티**(예: `Array.isArray`).
- 인스턴스 메서드는 **프로토타입**에 존재.

---

## 열거/소유/체인 탐색과 도구 메서드

### 소유 여부/체인 포함

```js
const obj = Object.create({ a:1 });
obj.b = 2;
Object.hasOwn(obj, "a");         // false (상속)
obj.hasOwnProperty("b");         // true (자신의 키)
"a" in obj;                      // true (체인 포함 검사)
```

### 열거 순서/for..in 주의

```js
for (const k in obj) {
  if (Object.hasOwn(obj, k)) { /* 자신의 키만 처리 */ }
}
Object.keys(obj);      // own + enumerable 문자열 키
Object.values(obj);
Object.entries(obj);
Reflect.ownKeys(obj);  // own의 모든 키(문자열+심볼, 열거 여부 무관)
```

---

## `__proto__`와 성능/안전

### 왜 지양하나?

- `__proto__`는 **웹 호환용 비표준 접근자**(현재는 표준화되었지만 역사적 잔존물).
- 속도/최적화 측면에서 `Object.setPrototypeOf`/`getPrototypeOf`가 **명시적이고 안전**.
- **런타임 프로토타입 변경**은 **성능 저하**(엔진 최적화 해제) 가능 → 앱 전체에 영향.

```js
// 성능 민감 코드에서는 피하기
Object.setPrototypeOf(obj, newProto); // 필요할 때 1회 구성 정도만
```

---

## 프로토타입 체인 끊기와 딕셔너리 객체

```js
const dict = Object.create(null); // [[Prototype]] === null
dict.x = 1;
console.log("toString" in dict); // false (상속 없음)
```
- **키-값 맵**(해시 테이블)처럼 쓰기에 안전(상속 키 충돌 방지).
- 단, `toString` 등 상위 유틸리티가 없음 → 필요 시 명시적 사용.

---

## 믹스인(Mixin)과 조합(Composition)

### 믹스인(얕은 복사)

```js
const canLog = { log(){ console.log(this.id); } };
const canToggle = { toggle(){ this.on = !this.on; } };

function assignMixins(target, ...mixins){
  for (const m of mixins) Object.assign(target.prototype ?? target, m);
}

class Switch { constructor(id){ this.id = id; this.on = false; } }
assignMixins(Switch, canLog, canToggle);

const s = new Switch("L1");
s.log();    // "L1"
s.toggle(); // on=true
```
- **프로토타입 체인 없이** 기능 조합(충돌/네이밍 관리 필요).

### 위임(Delegation)로 조합

```js
const mover = { move(){ this.x++; } };
const jumper = { jump(){ this.y += 2; } };

const actor = Object.create(mover);
Object.setPrototypeOf(actor, jumper); // 한 번에 하나만 가능(단일 링크)
```
- 단일 체인만 허용 → 광범위한 조합은 믹스인/합성으로 처리.

---

## 주의

- 외부 입력으로 `__proto__`/`constructor.prototype` 경로에 쓰기 → 전역 오염.
- 안전한 병합:
```js
function safeAssign(target, source){
  for (const k of Object.keys(source)) {
    if (k === "__proto__" || k === "prototype" || k === "constructor") continue;
    target[k] = source[k];
  }
  return target;
}
```
- 라이브러리 사용 시 **보안 공지**/업데이트 확인.

---

## 실전 패턴/레시피

### 안전한 상속 유틸

```js
function inherit(Sub, Super){
  Sub.prototype = Object.create(Super.prototype, { constructor: { value: Sub, writable: true } });
  Object.setPrototypeOf ? Object.setPrototypeOf(Sub, Super) : (Sub.__proto__ = Super); // 정적 상속
  return Sub;
}
```

### 오버라이드 + 상위 호출(ES5)

```js
function override(proto, name, fn){
  const superFn = proto[name];
  proto[name] = function(...args){
    const prev = this._super;
    this._super = superFn;
    try { return fn.apply(this, args); }
    finally { this._super = prev; }
  };
}
```

### `toString` 커스터마이즈

```js
const Point = function(x,y){ this.x=x; this.y=y; };
Point.prototype.toString = function(){ return `(${this.x},${this.y})`; };
String(new Point(1,2)); // "(1,2)"
```

---

## 디버깅/검증 툴킷

```js
function chainOf(obj){
  const chain = [];
  while (obj) { chain.push(obj); obj = Object.getPrototypeOf(obj); }
  return chain;
}
console.log(chainOf(new Date()).map(o => o.constructor && o.constructor.name));
// ["Date", "Object", ... , null] (환경에 따라 다름)
```

- DevTools: 콘솔에서 `__proto__` 트리, `getOwnPropertyDescriptors`, `Reflect.ownKeys` 확인.
- **체인 과도**/잘못된 설정은 성능/버그 원인 → 구성 단계에서 검증.

---

## 퍼포먼스 팁

- **런타임 프로토타입 변경**은 최적화 해제 → **초기화 단계에만** 구성.
- **핫패스**에서는 `hasOwn`/직접 필드 접근 선호, 동적 확장 최소화.
- 거대한 계층보다 **조합(Composition)**을 고려.

---

## 요약 표

| 주제           | 핵심 요약 |
|----------------|-----------|
| 상속 모델      | **위임(Delegation) 기반**. `[[Prototype]]` 링크로 탐색 |
| 구현 방법      | 생성자+프로토타입 / `class` / `Object.create` |
| 체인 탐색      | 자신 → 상위 → … → `null` |
| 섀도잉/오버라이드 | 하위의 동명 프로퍼티/메서드가 상위를 가림 |
| 도구           | `Object.getPrototypeOf/ setPrototypeOf`, `isPrototypeOf`, `instanceof` |
| 디스크립터/접근자 | 상위 접근자는 하위에서 `this` 문맥으로 동작 |
| 보안           | **Prototype Pollution** 방지 필터 |
| 성능           | 프로토타입 변경 최소화, 조합 우선 |

---

## 미니 실습/퀴즈

```js
// Q1) 결과와 이유?
function A(){}
A.prototype.x = 1;
const a = new A();
console.log("x" in a, a.hasOwnProperty("x")); // ?

// Q2) 체인 확인: b → a → Object.prototype → null
const a2 = { p: 7 };
const b2 = Object.create(a2);
console.log(Object.getPrototypeOf(b2) === a2); // ?

// Q3) instanceof 원리: Person.prototype ∈ chain?
function Person(){}
const p3 = Object.create(Person.prototype);
console.log(p3 instanceof Person); // ?

// Q4) 접근자 상속
const base = { get v(){ return this._v ?? 0; }, set v(n){ this._v = n } };
const sub = Object.create(base); sub.v = 10;
console.log(sub.v, base.v); // ?

// Q5) 클래스 상속과 super
class X { f(){ return "X"; } }
class Y extends X { f(){ return super.f() + "Y"; } }
console.log(new Y().f()); // ?

// Q6) 프로토타입 오염 방지
const innocent = {};
const payload = JSON.parse('{"__proto__":{"polluted":true}}');
Object.assign(innocent, payload);
console.log({}.polluted); // ?  (왜 주의해야 하나?)
```

**정답 힌트**
- Q1: `true false` (체인 포함이므로 `in`은 true, own 아님)
- Q2: `true`
- Q3: `true` (`Person.prototype`이 체인 상에 존재)
- Q4: `10 0` (`sub`의 접근자가 자신의 `this`로 동작)
- Q5: `"XY"`
- Q6: 환경/구현에 따라 오염 가능 → 안전 병합 로직 필요

---

## 결론(현업 가이드)

- **프로토타입은 “상속”이 아니라 “위임”**이다: “없으면 위로 물어보기”.
- **구현 선택지**:
  - **간단 위임/플레인 객체** → `Object.create`
  - **전통적 생성자/레거시 호환** → 생성자+프로토타입
  - **현대적 문법/도구** → `class`/`extends`/`super`
- **안전/성능**: 오염 방지, 런타임 변경 최소화, 조합 우선, 체인 얕게 유지.
