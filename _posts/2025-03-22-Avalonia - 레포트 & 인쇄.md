---
layout: post
title: Avalonia - 레포트 & 인쇄
date: 2025-03-22 21:20:23 +0900
category: Avalonia
---
# Avalonia에서 레포트 & 인쇄 기능

## 0. 설계 개요

| 목표 | 구현 축 |
|---|---|
| 보고서 시각화 | HTML 템플릿(표, 차트, 헤더/푸터, 스타일 분리) |
| PDF 변환 | PuppeteerSharp(Headless Chromium) 또는 HtmlRenderer.PdfSharp |
| 인쇄 | OS별 기본 프린터 명령 호출(`print`/`lp`/`lpr`) |
| 미리보기 | WebView(HTML/PDF), 또는 PDF 뷰어(대안) |
| MVVM | `IReportTemplateEngine`·`IPdfRenderer`·`IPrintService` 분리 |
| 크로스플랫폼 | Windows/macOS/Linux Self-contained 배포, 런타임 의존성 문서화 |
| 성능/안정성 | 캐싱/임시파일 관리, 타임아웃/리트라이, 권한 체크 |

> 강력한 인쇄는 **플랫폼 네이티브 API**가 다양하여 통일하기 어렵다. Avalonia는 현재 WPF 수준의 인쇄 API가 없으므로 **HTML→PDF** 중심으로 표준화하는 것이 장기적으로 유지보수가 쉽다.

---

## 1. 프로젝트 구조(예시)

```
MyReports/
├─ Views/
│  └─ ReportView.axaml
├─ ViewModels/
│  └─ ReportViewModel.cs
├─ Services/
│  ├─ IReportTemplateEngine.cs
│  ├─ RazorReportTemplateEngine.cs
│  ├─ IPdfRenderer.cs
│  ├─ PuppeteerPdfRenderer.cs
│  ├─ PdfSharpRenderer.cs
│  ├─ IPrintService.cs
│  ├─ OsPrintService.cs
│  └─ IReportOrchestrator.cs  # 전체 파이프라인 조립
├─ Templates/
│  ├─ report_base.html
│  ├─ report_styles.css
│  └─ partial_row.html
├─ Models/
│  └─ ActivityRow.cs
└─ MyReports.csproj
```

---

## 2. HTML 보고서 템플릿

### 2.1 템플릿(기본 레이아웃)

`Templates/report_base.html`
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>@Model.Title</title>
  <link rel="stylesheet" href="report_styles.css" />
  <style>
    @page {
      size: A4;
      margin: 20mm 15mm 20mm 15mm;
    }
    @media print {
      .no-print { display:none; }
      table { page-break-inside:auto }
      tr { page-break-inside:avoid; page-break-after:auto }
      thead { display:table-header-group }
      tfoot { display:table-footer-group }
    }
  </style>
</head>
<body>
  <header class="page-header">
    <div class="brand">MyReports</div>
    <div class="meta">생성일: @Model.GeneratedAt</div>
  </header>

  <h1 class="title">@Model.Title</h1>
  <p class="subtitle">@Model.Subtitle</p>

  <section class="summary">
    <div>총 사용자: <strong>@Model.TotalUsers</strong></div>
    <div>총 활동 수: <strong>@Model.TotalActivities</strong></div>
  </section>

  <section class="chart">
    <img src="@Model.ChartImageDataUrl" alt="차트" />
  </section>

  <section class="table">
    <table>
      <thead>
        <tr>
          <th>이름</th>
          <th>로그인 시간</th>
          <th>활동</th>
        </tr>
      </thead>
      <tbody>
        @foreach (var row in Model.Rows) {
          @Raw(await IncludeAsync("partial_row.html", row))
        }
      </tbody>
    </table>
  </section>

  <footer class="page-footer">
    <span class="left">@Model.FooterLeft</span>
    <span class="right">페이지 <span class="pageNumber"></span> / <span class="totalPages"></span></span>
  </footer>
</body>
</html>
```

`Templates/partial_row.html`
```html
<tr>
  <td>@Model.Name</td>
  <td>@Model.LoginTime</td>
  <td>@Model.Action</td>
</tr>
```

`Templates/report_styles.css`
```css
body { font-family: Arial, sans-serif; color:#222; }
.title { text-align:center; margin: 0 0 6mm 0; }
.subtitle { text-align:center; color:#666; margin:0 0 10mm 0; }
.page-header, .page-footer { font-size: 11px; color:#555; display:flex; justify-content:space-between; }
.summary { display:flex; gap:12mm; margin:8mm 0; }
.table table { width:100%; border-collapse:collapse; }
.table th, .table td { border:1px solid #ccc; padding:6px 8px; text-align:center; }
.chart img { width: 100%; max-height: 80mm; object-fit:contain; border:1px solid #ddd; padding:3mm; }
```

> 포인트
> - `@page` 및 `thead/tfoot`로 **페이지 헤더/푸터/번호** 등 인쇄 서식을 맞춘다.
> - 헤더/푸터는 Chromium 기반 PDF 출력일 때 **headerTemplate/footerTemplate** 기능을 활용해 더 정밀하게 만들 수도 있다(§4.2).

---

## 3. 템플릿 엔진(RazorLight 예시)

### 3.1 모델

`Models/ActivityRow.cs`
```csharp
public sealed class ActivityRow
{
    public string Name { get; init; } = "";
    public string LoginTime { get; init; } = "";
    public string Action { get; init; } = "";
}

public sealed class ReportModel
{
    public string Title { get; init; } = "사용자 활동 보고서";
    public string Subtitle { get; init; } = "";
    public DateTime GeneratedAt { get; init; } = DateTime.Now;
    public int TotalUsers { get; init; }
    public int TotalActivities { get; init; }
    public string FooterLeft { get; init; } = "Confidential";
    public string ChartImageDataUrl { get; init; } = ""; // data:image/png;base64,...
    public IReadOnlyList<ActivityRow> Rows { get; init; } = Array.Empty<ActivityRow>();
}
```

### 3.2 인터페이스

`Services/IReportTemplateEngine.cs`
```csharp
public interface IReportTemplateEngine
{
    Task<string> RenderAsync(string templateName, object model, CancellationToken ct = default);
}
```

### 3.3 RazorLight 구현

`Services/RazorReportTemplateEngine.cs`
```csharp
using RazorLight;

public sealed class RazorReportTemplateEngine : IReportTemplateEngine
{
    private readonly RazorLightEngine _engine;

    public RazorReportTemplateEngine(string templatesRoot)
    {
        _engine = new RazorLightEngineBuilder()
           .UseFileSystemProject(templatesRoot)
           .UseMemoryCaching()
           .Build();
    }

    public Task<string> RenderAsync(string templateName, object model, CancellationToken ct = default)
        => _engine.CompileRenderAsync(templateName, model);
}
```

> 다른 선택지: Scriban/Handlebars.NET 등. HTML 파트셜/레이아웃이 편한 RazorLight를 예시로 사용.

---

## 4. PDF 생성기 구현

### 4.1 공통 인터페이스

`Services/IPdfRenderer.cs`
```csharp
public interface IPdfRenderer
{
    /// <summary>HTML을 PDF 바이트로 변환</summary>
    Task<byte[]> RenderPdfAsync(string html, PdfRenderOptions? options = null, CancellationToken ct = default);
}

public sealed class PdfRenderOptions
{
    public string? BaseUrlOrPath { get; init; }  // CSS/이미지 상대경로 기준
    public string PageFormat { get; init; } = "A4";
    public double MarginTopMm { get; init; } = 20;
    public double MarginRightMm { get; init; } = 15;
    public double MarginBottomMm { get; init; } = 20;
    public double MarginLeftMm { get; init; } = 15;

    // Puppeteer 전용(선택)
    public string? HeaderTemplateHtml { get; init; }
    public string? FooterTemplateHtml { get; init; }
    public bool DisplayHeaderFooter { get; init; } = true;
}
```

### 4.2 PuppeteerSharp(권장, 정밀 출력)

```bash
dotnet add package PuppeteerSharp
```

`Services/PuppeteerPdfRenderer.cs`
```csharp
using PuppeteerSharp;

public sealed class PuppeteerPdfRenderer : IPdfRenderer, IAsyncDisposable
{
    private Browser? _browser;
    private readonly SemaphoreSlim _sem = new(1,1);

    public async Task<byte[]> RenderPdfAsync(string html, PdfRenderOptions? options = null, CancellationToken ct = default)
    {
        options ??= new();

        await _sem.WaitAsync(ct);
        try
        {
            if (_browser is null || !_browser.IsConnected)
            {
                // Chromium 자동 다운로드(처음 한 번). 배포 시 사전 번들링 고려.
                await new BrowserFetcher().DownloadAsync(BrowserFetcher.DefaultChromiumRevision);
                _browser = await Puppeteer.LaunchAsync(new LaunchOptions
                {
                    Headless = true,
                    Args = new[] { "--no-sandbox", "--disable-gpu" }
                });
            }

            await using var page = await _browser.NewPageAsync();
            if (!string.IsNullOrEmpty(options.BaseUrlOrPath))
            {
                // Base URL 설정 (상대 경로 CSS/이미지 해결)
                await page.GoToAsync("about:blank"); // placeholder
                await page.SetContentAsync(html, new NavigationOptions
                {
                    Timeout = 0,
                    WaitUntil = new[] { WaitUntilNavigation.Networkidle0 }
                });
                // Puppeteer는 SetContentAsync에 base URL 직접 주입 지원 없음.
                // CSS 링크는 절대경로/`file://`로 구성하는 편이 안전하다.
            }
            else
            {
                await page.SetContentAsync(html, new NavigationOptions
                {
                    Timeout = 0,
                    WaitUntil = new[] { WaitUntilNavigation.Networkidle0 }
                });
            }

            // 헤더/푸터 템플릿(페이지 번호 표시 등)
            // {{pageNumber}}, {{totalPages}} placeholder 사용 가능(Chromium 기능)
            var pdfOpts = new PdfOptions
            {
                Format = PaperFormat.A4,
                MarginOptions = new PuppeteerSharp.Media.MarginOptions
                {
                    Top = $"{options.MarginTopMm}mm",
                    Right = $"{options.MarginRightMm}mm",
                    Bottom = $"{options.MarginBottomMm}mm",
                    Left = $"{options.MarginLeftMm}mm"
                },
                PrintBackground = true,
                DisplayHeaderFooter = options.DisplayHeaderFooter
            };

            if (options.DisplayHeaderFooter)
            {
                pdfOpts.HeaderTemplate = options.HeaderTemplateHtml ?? "<div style='font-size:10px; width:100%; text-align:right; padding-right:10px;'>MyReports</div>";
                pdfOpts.FooterTemplate = options.FooterTemplateHtml ?? "<div style='font-size:10px; width:100%; text-align:right; padding-right:10px;'>페이지 <span class='pageNumber'></span> / <span class='totalPages'></span></div>";
            }

            var data = await page.PdfDataAsync(pdfOpts);
            return data;
        }
        finally
        {
            _sem.Release();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_browser is not null) await _browser.DisposeAsync();
        _sem.Dispose();
    }
}
```

> 장점: HTML/CSS 레이아웃·웹 폰트·헤더/푸터 템플릿·SVG/Chart.js 등 **높은 충실도**.
> 단점: Chromium 의존(배포 시 용량/정책 고려), 최초 실행 시 다운로드 시간.

### 4.3 HtmlRenderer.PdfSharp(간단·가벼움)

```bash
dotnet add package HtmlRenderer.PdfSharp
dotnet add package PdfSharpCore
```

`Services/PdfSharpRenderer.cs`
```csharp
using TheArtOfDev.HtmlRenderer.PdfSharp;
using PdfSharpCore.Pdf;

public sealed class PdfSharpRenderer : IPdfRenderer
{
    public Task<byte[]> RenderPdfAsync(string html, PdfRenderOptions? options = null, CancellationToken ct = default)
    {
        options ??= new();
        using var doc = new PdfDocument();
        // HtmlRenderer는 페이지 사이즈/마진 설정이 제한적이므로 CSS/스타일로 최대한 맞춘다.
        PdfGenerator.AddPdfPages(doc, html, PdfSharpCore.PageSize.A4);
        using var ms = new MemoryStream();
        doc.Save(ms);
        return Task.FromResult(ms.ToArray());
    }
}
```

> 장점: 의존성 적고 빠르게 결과 확보.
> 단점: 최신 CSS/레이아웃, 복잡한 표/차트/웹폰트 렌더링은 제한.

---

## 5. 인쇄 서비스(OS 명령)

`Services/IPrintService.cs`
```csharp
public interface IPrintService
{
    Task PrintPdfAsync(string pdfPath, string? printerName = null, CancellationToken ct = default);
}
```

`Services/OsPrintService.cs`
```csharp
using System.Diagnostics;
using System.Runtime.InteropServices;

public sealed class OsPrintService : IPrintService
{
    public Task PrintPdfAsync(string pdfPath, string? printerName = null, CancellationToken ct = default)
    {
        if (!File.Exists(pdfPath))
            throw new FileNotFoundException(pdfPath);

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return PrintWindowsAsync(pdfPath, printerName, ct);
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            return PrintLinuxAsync(pdfPath, printerName, ct);
        if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            return PrintMacAsync(pdfPath, printerName, ct);

        throw new PlatformNotSupportedException();
    }

    private static Task PrintWindowsAsync(string path, string? printer, CancellationToken ct)
    {
        // 간단: ShellExecute Verb=print (기본 프린터)
        var psi = new ProcessStartInfo
        {
            FileName = path,
            Verb = "print",
            UseShellExecute = true,
            CreateNoWindow = true
        };
        Process.Start(psi);
        return Task.CompletedTask;

        // 고급: SumatraPDF/Acrobat Reader 커맨드라인 또는 PrintDialog 연동을 별도 구현 가능.
    }

    private static Task PrintLinuxAsync(string path, string? printer, CancellationToken ct)
    {
        var args = string.IsNullOrEmpty(printer) ? $"{Quote(path)}" : $"-d {Quote(printer)} {Quote(path)}";
        return ProcessEx.RunAsync("lp", args, ct);
    }

    private static Task PrintMacAsync(string path, string? printer, CancellationToken ct)
    {
        var args = string.IsNullOrEmpty(printer) ? $"{Quote(path)}" : $"-d {Quote(printer)} {Quote(path)}";
        return ProcessEx.RunAsync("lpr", args, ct);
    }

    private static string Quote(string s) => $"\"{s}\"";
}

file static class ProcessEx
{
    public static async Task RunAsync(string fileName, string arguments, CancellationToken ct)
    {
        var psi = new ProcessStartInfo(fileName, arguments)
        {
            UseShellExecute = false,
            RedirectStandardError = true,
            RedirectStandardOutput = true,
            CreateNoWindow = true
        };
        using var p = Process.Start(psi)!;
        await p.WaitForExitAsync(ct);
        if (p.ExitCode != 0) throw new Exception($"Print failed: {await p.StandardError.ReadToEndAsync()}");
    }
}
```

> 프린터 선택 UI가 필요하면 OS별 프린터 목록 수집(CUPS `lpstat -p`, Windows WMI/PowerShell) 후 커스텀 대화상자를 제공한다.

---

## 6. 보고서 오케스트레이션(MVVM 연동)

`Services/IReportOrchestrator.cs`
```csharp
public interface IReportOrchestrator
{
    /// <summary>모델 → HTML → PDF → 파일 저장까지 일괄 수행</summary>
    Task<string> GeneratePdfAsync(ReportModel model, CancellationToken ct = default);

    /// <summary>생성 후 즉시 인쇄</summary>
    Task PrintAsync(ReportModel model, string? printerName = null, CancellationToken ct = default);
}
```

`Services/ReportOrchestrator.cs`
```csharp
public sealed class ReportOrchestrator : IReportOrchestrator
{
    private readonly IReportTemplateEngine _tmpl;
    private readonly IPdfRenderer _renderer;
    private readonly IPrintService _printer;
    private readonly string _templatesRoot;
    private readonly string _workDir;

    public ReportOrchestrator(
        IReportTemplateEngine tmpl,
        IPdfRenderer renderer,
        IPrintService printer,
        string templatesRoot,
        string workDir)
    {
        _tmpl = tmpl;
        _renderer = renderer;
        _printer = printer;
        _templatesRoot = templatesRoot;
        _workDir = workDir;
        Directory.CreateDirectory(_workDir);
    }

    public async Task<string> GeneratePdfAsync(ReportModel model, CancellationToken ct = default)
    {
        var html = await _tmpl.RenderAsync("report_base.html", model, ct);

        var pdf = await _renderer.RenderPdfAsync(html, new PdfRenderOptions
        {
            BaseUrlOrPath = _templatesRoot, // CSS 상대경로일 경우 절대 경로/URL로 보완
            PageFormat = "A4",
            MarginTopMm = 20, MarginRightMm = 15, MarginBottomMm = 20, MarginLeftMm = 15,
            HeaderTemplateHtml = "<div style='font-size:10px;width:100%;text-align:right;padding-right:10px;'>MyReports</div>",
            FooterTemplateHtml = "<div style='font-size:10px;width:100%;text-align:right;padding-right:10px;'>페이지 <span class='pageNumber'></span> / <span class='totalPages'></span></div>"
        }, ct);

        var file = Path.Combine(_workDir, $"report_{DateTime.Now:yyyyMMdd_HHmmss}.pdf");
        await File.WriteAllBytesAsync(file, pdf, ct);
        return file;
    }

    public async Task PrintAsync(ReportModel model, string? printerName = null, CancellationToken ct = default)
    {
        var path = await GeneratePdfAsync(model, ct);
        await _printer.PrintPdfAsync(path, printerName, ct);
    }
}
```

---

## 7. ViewModel/뷰 — 예시

### 7.1 ViewModel

`ViewModels/ReportViewModel.cs`
```csharp
using ReactiveUI;
using System.Reactive;
using System.Collections.ObjectModel;

public sealed class ReportViewModel : ReactiveObject
{
    private readonly IReportOrchestrator _orchestrator;

    public ObservableCollection<ActivityRow> Rows { get; } = new();
    public string Title { get; set; } = "사용자 활동 보고서";
    public string Subtitle { get; set; } = "지난 7일";

    private string? _lastPdfPath;
    public string? LastPdfPath { get => _lastPdfPath; private set => this.RaiseAndSetIfChanged(ref _lastPdfPath, value); }

    public ReactiveCommand<Unit, Unit> GenerateCommand { get; }
    public ReactiveCommand<Unit, Unit> PrintCommand { get; }

    public ReportViewModel(IReportOrchestrator orchestrator)
    {
        _orchestrator = orchestrator;

        GenerateCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            var model = BuildModel();
            LastPdfPath = await _orchestrator.GeneratePdfAsync(model);
        });

        PrintCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            var model = BuildModel();
            await _orchestrator.PrintAsync(model);
        });
    }

    private ReportModel BuildModel()
    {
        // 차트를 이미지로 만들어 data URL로 탑재(예: LiveCharts/Skia로 PNG in-memory 후 base64)
        // 여기서는 예시로 빈 data URL
        string chartDataUrl = "data:image/png;base64," + Convert.ToBase64String(new byte[] { });

        return new ReportModel
        {
            Title = Title,
            Subtitle = Subtitle,
            GeneratedAt = DateTime.Now,
            TotalUsers = Rows.Select(r => r.Name).Distinct().Count(),
            TotalActivities = Rows.Count,
            ChartImageDataUrl = chartDataUrl,
            Rows = Rows.ToList(),
            FooterLeft = "Internal Use Only"
        };
    }
}
```

### 7.2 View(미리보기)

`Views/ReportView.axaml`
```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="https://github.com/avaloniaui"
             x:Class="MyReports.Views.ReportView">
  <StackPanel Margin="16" Spacing="8">
    <TextBlock Text="보고서 생성" FontSize="20" />
    <StackPanel Orientation="Horizontal" Spacing="6">
      <Button Content="PDF 생성" Command="{Binding GenerateCommand}" />
      <Button Content="인쇄" Command="{Binding PrintCommand}" />
    </StackPanel>

    <!-- 간단 미리보기: 생성된 PDF 파일을 외부 뷰어로 여는 버튼 또는 WebView로 경로 표시 -->
    <TextBlock Text="{Binding LastPdfPath}" />
  </StackPanel>
</UserControl>
```

> Avalonia에 네이티브 PDF 뷰어는 기본 제공되지 않는다. **옵션**
> - `Avalonia.WebView`로 `file:///.../report.pdf` 열기(플랫폼/엔진 제약 주의)
> - 외부 PDF 뷰어 연동(기본 앱으로 열기)
> - 상용/오픈소스 PDF 렌더러 연동(PDFium 등, 라이선스 검토)

---

## 8. 차트 삽입 전략

### 8.1 캔버스 기반(Chart.js) — Puppeteer 사용 시
- HTML에 `<canvas id="chart">`와 Chart.js 스크립트를 포함하고 `page.SetContentAsync(html)` 후 렌더링 시점에 PNG 스냅샷을 삽입.
- 간단하게는 ViewModel에서 미리 **PNG base64**를 생성해 `<img src="data:image/png;base64,...">`로 삽입(위 예시처럼).

### 8.2 LiveCharts/Skia — 서버/클라이언트 렌더
Skia로 메모리에서 차트를 그려 PNG 바이트 생성 후 `data:` URL로 주입.

```csharp
// chartBmp: Avalonia/Skia 기반으로 생성한 비트맵 바이트
string dataUrl = "data:image/png;base64," + Convert.ToBase64String(chartBmp);
```

---

## 9. XAML → 이미지 보조 경로

> HTML→PDF가 곤란하거나 간단한 라벨·바코드·전표처럼 “픽셀 완전 제어”가 필요할 때 보조로 사용.

```csharp
var bmp = await control.RenderToBitmapAsync(new PixelSize(1024, 768));
// PNG 저장
await using (var fs = File.OpenWrite("report.png"))
    bmp.Save(fs);

// PNG → PDF 합치기(PDFsharp 등으로 한 페이지에 이미지 붙여 넣기)
```

장점: 디자인한 XAML 그대로 출력.
단점: 페이지 나눔, 머리글/꼬리글, 긴 표 자동 분할 등은 직접 구현해야 한다.

---

## 10. 권한/감사 로깅

- 인쇄/내보내기(Export)는 민감하다. **역할(Role)** 기반 제어:

```csharp
public interface IAuthorization
{
    bool CanExportPdf();
    bool CanPrint();
}

if (!_auth.CanPrint()) throw new UnauthorizedAccessException();
```

- 감사 로그: 누가 언제 어떤 필터로 어떤 데이터 범위를 출력했는지 기록(이벤트 버스/DB).

---

## 11. 오류 복구·진행률·취소

- 긴 PDF 생성은 **CancellationToken**과 **타임아웃**을 제공
- UI에 `Progress<double>`를 노출(총 페이지 예상치가 없다면 단계 기반(템플릿→PDF→저장→인쇄)로 구간 가중치)

```csharp
var cts = new CancellationTokenSource(TimeSpan.FromMinutes(2));
try
{
    var path = await _orchestrator.GeneratePdfAsync(model, cts.Token);
}
catch (OperationCanceledException) { /* 사용자 취소 */ }
catch (Exception ex) { /* UI에 상세 메시지 */ }
```

---

## 12. 테스트 전략

- 템플릿 엔진: 고정 입력 → HTML 문자열 스냅샷 테스트
- PDF 렌더러: 결과 바이트 길이/메타데이터/텍스트 추출(가능 시) 검증
- 인쇄 서비스: OS 명령은 **랩퍼 추상화** 후 Mock(호출 파라미터 검증)

---

## 13. 배포/의존성

- **Self-contained** 빌드 권장.
- PuppeteerSharp 사용 시 Chromium 다운로드 정책:
  - 첫 실행 자동 다운로드 → 오프라인/폐쇄망이면 **사전 번들링**(사용자 PC 정책/용량 고려)
  - `PUPPETEER_EXECUTABLE_PATH` 환경변수 또는 설정으로 실행 파일 경로 지정
- Linux 서버/데스크톱: `--no-sandbox` 필요할 수 있음(보안 정책 검토), CUPS 설치 필요(`lp`).
- 폰트: PDF 글꼴 깨짐 방지 위해 **Noto Sans CJK** 등 배포 동반 또는 서버 설치.

---

## 14. 구성 설정(appsettings)

```json
{
  "Report": {
    "TemplatesPath": "Templates",
    "WorkDir": "ReportsOut",
    "Renderer": "puppeteer", // or "pdfsharp"
    "ChromiumExecutable": null
  }
}
```

DI 초기화:

```csharp
services.AddSingleton<IReportTemplateEngine>(sp =>
    new RazorReportTemplateEngine(config["Report:TemplatesPath"]!));

if (config["Report:Renderer"] == "puppeteer")
    services.AddSingleton<IPdfRenderer, PuppeteerPdfRenderer>();
else
    services.AddSingleton<IPdfRenderer, PdfSharpRenderer>();

services.AddSingleton<IPrintService, OsPrintService>();
services.AddSingleton<IReportOrchestrator>(sp =>
    new ReportOrchestrator(
        sp.GetRequiredService<IReportTemplateEngine>(),
        sp.GetRequiredService<IPdfRenderer>(),
        sp.GetRequiredService<IPrintService>(),
        config["Report:TemplatesPath"]!,
        config["Report:WorkDir"]!));
```

---

## 15. 성능 팁

- 대용량 표: 페이지 별로 **그룹 분할**(서버 페이징 후 머리글 반복)
- 이미지/차트: 미리 **캐시**하여 여러 문서에 재사용
- CSS 인쇄 최적화: `page-break-inside: avoid;`로 잘리는 행 방지
- Puppeteer: 브라우저 재사용(싱글톤), 동시성 제한(세마포어)

---

## 16. 보안/무결성

- 출력 파일에 **디지털 서명**(별도 PDF 서명 라이브러리) 고려
- 헤더/푸터에 **기밀 표시/워터마크**
- 파일 저장 경로 화이트리스트, 임시 파일 자동 삭제(백그라운드 청소)

---

## 17. 실제 사용 시나리오(끝→끝)

1) 사용자가 기간/부서/검색어를 선택 → `ReportModel` 구성
2) `IReportOrchestrator.GeneratePdfAsync()` 호출 → HTML 렌더 → PDF 바이트 생성 → 경로 반환
3) UI에 “열기” 버튼(기본 뷰어로 열기) 또는 내부 WebView 미리보기
4) “인쇄” 버튼 → `IReportOrchestrator.PrintAsync()` → OS 프린트 큐로 전달
5) 감사 로그 기록

---

## 18. 대안 기술 간 비교

| 기준 | PuppeteerSharp | HtmlRenderer.PdfSharp |
|---|---|---|
| CSS/레이아웃 충실도 | 매우 높음(웹과 동일) | 제한적 |
| 헤더/푸터/페이지 번호 | Header/Footer Template, placeholder 지원 | CSS/레이아웃으로 보완 필요 |
| 차트/웹폰트 | 우수 | 제한 |
| 의존성/용량 | Chromium 필요 | 가벼움 |
| 도입 난이도 | 중간(배포 고려 필요) | 쉬움 |

---

## 19. 마무리

- Avalonia는 네이티브 인쇄 API가 제한적이므로, **HTML → PDF 파이프라인**을 기본으로 삼는 것이 가장 실용적이다.
- **PuppeteerSharp**는 충실도가 높아 실무 보고서(다단, 표, 차트, 웹폰트) 요구에 가장 안정적으로 대응한다.
  가벼운 용도나 내부 자료에는 **HtmlRenderer.PdfSharp**도 훌륭한 대안이다.
- **MVVM 분리(템플릿 엔진/렌더러/프린터)**를 통해 테스트 가능성과 교체 용이성을 확보하고,
  **권한/감사/배포/폰트/프린터** 등 운영 요소를 초기 설계부터 반영하라.
