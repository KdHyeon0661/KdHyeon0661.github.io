---
layout: post
title: DB 심화 - 병렬 조인
date: 2025-11-25 14:25:23 +0900
category: DB 심화
---
# Oracle 병렬 조인 — Full/Partial Partition-Wise Join, Dynamic Partitioning, Broadcast

## 0) 병렬 조인을 읽는 공통 프레임

### 0.1 QC-PX-TQ, 그리고 IN-OUT

병렬 플랜은 **QC(코디네이터)**와 여러 **PX 서버(슬레이브)**가 **TQ(파이프라인 큐)**로 이어진 그래프다.  
플랜의 `PX SEND <type>` / `PX RECEIVE`가 **TQ를 명시적으로 보여주는 자리**이며, 여기서 `<type>`이 곧 **분배 방식**이다. :contentReference[oaicite:0]{index=0}

`IN-OUT`은 한 오퍼레이션의 입력/출력이 **직렬(S)**인지 **병렬(P)**인지, 그리고 **병렬 간 재분배(P→P)**가 있는지를 나타낸다.  
특히 `PCWP/PCWC`는 **부모-자식 오퍼레이션이 같은 PX 집합에서 “붙어서” 실행**됨을 뜻한다(=TQ를 줄여 통신 비용 감소). :contentReference[oaicite:1]{index=1}

- `S->P` : 직렬 결과를 병렬로 확장  
- `P->S` : 병렬 결과를 QC에서 직렬로 회수  
- `P->P` : **재분배(핵심 비용!)**  
- `PCWP/PCWC` : **같은 PX들의 intra-operation 결합**(TQ 최소)

### 0.2 병렬 조인의 “비용 3요소”

병렬 조인의 총 비용은 대략:

1) **스캔 비용**(각 PX가 읽는 양)  
2) **분배 비용**(TQ로 넘기는 네트워크/버퍼링)  
3) **QC 머지/최종 단계 비용**(stopkey/merge sort 등)

따라서 **허용 가능한 병렬 조인**이 되려면  
**“분배 비용을 줄이거나 없애는 구조”**가 핵심이다.  
이게 바로 Partition-Wise Join과 Broadcast가 중요한 이유다.

---

## 1) 공통 실습 환경(사용자 스키마 + 대용량 확장)

사용자님이 준 스키마는 데모용 소량이므로, 병렬 조인의 차이를 보려면 충분히 크게 만든다.

```sql
-- 병렬 실습 기본
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET parallel_degree_policy = MANUAL;
ALTER SESSION SET workarea_size_policy = AUTO;

-- (선택) 실습용 DOP 기본값
ALTER SESSION FORCE PARALLEL QUERY PARALLEL 16;
```

### 1.1 대용량 적재(권장)

```sql
-- fact_sales 2천만, fact_clicks 2천만 로우 예시
INSERT /*+ APPEND PARALLEL(s 16) */ INTO fact_sales s
SELECT level                         AS sales_id,
       MOD(level, 2000000)           AS cust_id,
       DATE '2025-01-01' + MOD(level, 90) AS sales_dt,
       CASE MOD(level,5)
         WHEN 0 THEN 'US' WHEN 1 THEN 'EU' WHEN 2 THEN 'LATAM'
         WHEN 3 THEN 'APAC' ELSE 'MEA' END AS region_cd,
       DBMS_RANDOM.VALUE(1,1000)     AS amount
FROM dual
CONNECT BY level <= 20000000;

INSERT /*+ APPEND PARALLEL(c 16) */ INTO fact_clicks c
SELECT level                         AS click_id,
       MOD(level, 2000000)           AS cust_id,
       DATE '2025-01-01' + MOD(level, 90) AS click_dt,
       CASE MOD(level,3) WHEN 0 THEN 'AD' WHEN 1 THEN 'SEO' ELSE 'SNS' END AS source_cd,
       DBMS_RANDOM.VALUE(0.1,5)      AS cost
FROM dual
CONNECT BY level <= 20000000;

COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'FACT_SALES');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'FACT_CLICKS');
END;
/
```

---

## 2) Full Partition-Wise Join(FPWJ)

### 2.1 정의와 요건

**정의**: 조인하는 양쪽 테이블이 **조인 키 = 파티션 키**이고,  
**파티션 방식/경계/개수(또는 서브파티션 구조)가 “정렬(equipartition)”**되어 있을 때,  
**동일 파티션 쌍끼리만** 조인하여 **재분배(P→P)를 없애는** 조인이다. :contentReference[oaicite:2]{index=2}

**요건**
1) 조인 조건이 **파티션 키에 대한 동등 조인(equi-join)**  
2) **HASH-HASH / RANGE-RANGE / LIST-LIST / RANGE-INTERVAL 등** “정렬 가능한” 동일 구조 :contentReference[oaicite:3]{index=3}  
3) (강력 추천) **로컬(prefixed) 인덱스**로 파티션 단위 액세스

### 2.2 왜 가장 빠른가

- **큰 집합을 해시로 재분배하지 않아도 됨**  
- PX가 **“내 파티션”만 읽고 조인**하므로  
  네트워크/큐잉/스큐 위험이 극소화  
- RAC이면 파티션-인스턴스 affinity로 **gc 대기 최소화**

### 2.3 FPWJ 실습(사용자 예제 확장)

```sql
EXPLAIN PLAN FOR
SELECT /*+ leading(s) use_hash(c)
           parallel(s 16) parallel(c 16)
           pq_distribute(s PARTITION PARTITION)
           pq_distribute(c PARTITION PARTITION)
           monitor */
       s.cust_id, SUM(s.amount) amt, SUM(c.cost) ad_cost
FROM   fact_sales  s
JOIN   fact_clicks c
  ON   c.cust_id = s.cust_id
GROUP  BY s.cust_id;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +ALIAS +NOTE +PARTITION'));
```

### 2.4 플랜에서 FPWJ를 “한눈에” 찾는 법

Oracle 문서 기준 FPWJ의 **플랜 시그니처**는 다음이 핵심이다. :contentReference[oaicite:4]{index=4}

1) 조인 전에 **`PX PARTITION ...` 오퍼레이션**이 존재  
   - 예: `PX PARTITION HASH ALL` 또는 `PX PARTITION RANGE ALL`
2) `PX SEND HASH/BROADCAST`가 **조인 입력에 크게 보이지 않음**
3) `IN-OUT`이 `PCWP/PCWC`로 붙어 있는 경우가 많음  
   - 같은 PX가 스캔→조인까지 이어 실행

**해석 예시(전형)**

```
PX PARTITION HASH ALL     (파티션 granule)
 HASH JOIN                (같은 파티션끼리 로컬 조인)
```

→ **“파티션 granule 단위의 로컬 해시 조인”** = FPWJ.

### 2.5 FPWJ가 깨지는 대표 원인

1) **조인 조건에 파티션 키가 빠짐**  
   - `ON c.cust_id = s.cust_id`가 아니면 FPWJ 불가
2) **파티션 개수/경계가 미세하게 다름**  
   - HASH 파티션 수는 **정확히 동일**해야 한다.
3) **글로벌 인덱스 기반 경로가 드라이빙되며 파티션 지역성을 무시**  
   - 로컬 인덱스/프루닝이 잘 안 되면 FPWJ가 포기될 수 있음.

### 2.6 “상위 방식이 달라도” FPWJ를 만드는 고급 패턴

Oracle은 **파티션-서브파티션** 수준이 맞으면  
상위 방식이 달라도 **Full PWJ**를 만들 수 있다고 설명한다. :contentReference[oaicite:5]{index=5}

예:  
- customers = HASH(cust_id)  
- sales = RANGE(sales_dt) + **SUBPARTITION BY HASH(cust_id)**

→ **HASH 파티션 ↔ HASH 서브파티션**이 정렬되며 FPWJ 성립.

```sql
-- 예시 구조(개념)
CREATE TABLE sales_rh (
  ...
)
PARTITION BY RANGE (sales_dt)
SUBPARTITION BY HASH (cust_id)
SUBPARTITIONS 8
(
  PARTITION p2025m01 VALUES LESS THAN (DATE '2025-02-01'),
  ...
);
```

이 패턴은 **“시간 프루닝(상위 RANGE)” + “조인 로컬화(하위 HASH)”**를 동시에 얻는 DW 표준 설계다.

### 2.7 FPWJ 대기 이벤트 특성

- `PX Deq Credit: send blkd` **낮음**  
  - 재분배(TQ 통신)가 거의 없기 때문
- `direct path read` 위주로 “순수 스캔+로컬 해시빌드” 패턴
- RAC이면 `gc cr/current request`가 affinity 설계 시 급감

### 2.8 FPWJ 체크리스트

- 조인 키 = 파티션 키인가?  
- 파티션 방식/개수/경계가 동일하거나 **서브파티션 정렬**이 가능한가?  
- 플랜에 `PX PARTITION ...`이 조인 전 나타나는가? :contentReference[oaicite:6]{index=6}  
- 조인 입력에 `PX SEND HASH`가 사라졌는가?  
- 파티션 수보다 DOP가 크지 않은가(DOP>파티션이면 슬레이브 낭비)

---

## 3) Partial Partition-Wise Join(PPWJ)

### 3.1 정의

**정의**: 한쪽만 조인 키로 파티셔닝되고, 다른 쪽은 비파티션(또는 다른 키/구조)일 때,  
**파티션된 “참조(reference) 테이블”을 파티션 granule로 나눠** 병렬 조인하는 기법이다.  
PPWJ는 **병렬에서만 수행 가능**하다고 Oracle이 명시한다. :contentReference[oaicite:7]{index=7}

### 3.2 PPWJ 실습(사용자 예제)

```sql
EXPLAIN PLAN FOR
SELECT /*+ leading(s) use_hash(o)
           parallel(s 16) parallel(o 16)
           monitor */
       s.cust_id, SUM(s.amount) amt, SUM(o.amt) orders
FROM   fact_sales s          -- HASH(cust_id) 파티션
JOIN   orders_np  o          -- 비파티션
  ON   o.cust_id = s.cust_id
GROUP  BY s.cust_id;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +ALIAS +NOTE +PARTITION'));
```

### 3.3 플랜 시그니처

PPWJ는 보통 다음 특징을 가진다. :contentReference[oaicite:8]{index=8}

- 파티션 테이블 쪽에 `PX PARTITION ...`  
- 비파티션 테이블은 `PX BLOCK ITERATOR` 또는 재분배가 동반됨  
- **조인 입력 중 하나에서 `PX SEND HASH`가 여전히 존재**할 가능성

즉, “파티션 granule 이득은 얻되, 재분배가 완전히 사라지진 않는다.”

### 3.4 PPWJ의 “숨은 함정”: 파티션 스큐/아이들 슬레이브

PPWJ에서 실제로 자주 겪는 문제는

- 특정 파티션만 필터에 걸려 **일부 PX만 일**하고  
- 나머지는 놀게 되는 **파티션 스큐**다.

이 경우 DOP를 올려도 **응답이 더 안 좋아진다**(QC는 기다리기만 함).

**대응**

1) **DOP를 “참여 파티션 수”에 맞춰 낮추기**  
2) 필터(프루닝)와 병렬이 충돌하면  
   **동적 재분배**로 바꿔 “일감 균등화”  
3) 작은 쪽이면 **Broadcast**로 전환

### 3.5 PPWJ 체크리스트

- PPWJ는 본질적으로 **P→P가 일부 남는다**는 점을 인정  
- 참여 파티션 수 대비 DOP 과대 금지  
- 조인 키 편중이 심하면 Dynamic/Broadcast로 전환

---

## 4) Dynamic Partitioning / Dynamic Partition-Wise Join

### 4.1 개념

**정의**: 물리 파티션이 맞지 않거나 없는 테이블을  
**조인 키 기준으로 런타임 해시 재분배**하여,  
각 PX가 **자기 해시 구간만** 조인하도록 하는 방식이다.

플랜에서는 양쪽 또는 한쪽 입력에  
`PX SEND HASH` / `PX RECEIVE`가 명시되며,  
이 과정이 바로 **“실행 시 동적(가상) 파티셔닝”**이다. :contentReference[oaicite:9]{index=9}

> 용어 정리  
> - 그냥 “parallel hash join”도 결과적으로 HASH/HASH 재분배를 한다.  
> - Oracle이 말하는 *dynamic partition-wise join*은  
>   **한쪽 파티션 granule에 맞추려고 다른 쪽을 HASH로 재분배**하는 의미로 쓰인다.  
>   실무에서는 둘을 묶어 “동적 파티셔닝”으로 이해해도 된다.

### 4.2 동적 재분배: 양쪽 HASH/HASH(가장 일반적)

```sql
EXPLAIN PLAN FOR
SELECT /*+ leading(s) use_hash(o)
           parallel(s 16) parallel(o 16)
           pq_distribute(s HASH HASH)
           pq_distribute(o HASH HASH)
           monitor */
       s.cust_id, SUM(s.amount) amt, SUM(o.amt) orders
FROM   fact_sales s
JOIN   orders_np  o
  ON   o.cust_id = s.cust_id
GROUP  BY s.cust_id;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +ALIAS +NOTE'));
```

**플랜 해석**

- `PX SEND HASH`가 양쪽 입력에서 1회씩 나타남  
- 이후 `HASH JOIN`이 `PCWP/PCWC`로 붙는 패턴이 전형

→ **가상 파티션 정렬 후 로컬 조인.**

### 4.3 “한쪽만” 동적으로 맞추는 패턴

파티션 테이블을 기준으로  
비파티션 테이블만 HASH 재분배하기.

```sql
EXPLAIN PLAN FOR
SELECT /*+ leading(s) use_hash(o)
           parallel(s 16) parallel(o 16)
           pq_distribute(o HASH HASH)  -- o만 재분배
           monitor */
       s.cust_id, SUM(s.amount) amt, SUM(o.amt) orders
FROM   fact_sales s
JOIN   orders_np o
  ON   o.cust_id = s.cust_id
GROUP  BY s.cust_id;
```

**의도**

- 파티션 테이블은 **기존 granule을 유지**하고  
- 비파티션 쪽을 **같은 키 구간으로 재정렬**  
- PPWJ보다 **통신량·스큐가 줄어드는** 경우가 많다.

### 4.4 동적 파티셔닝의 대기 이벤트/병목

- **재분배 그 자체가 네트워크 비용**  
- 키 편중이 있으면  
  - 어떤 PX는 폭주  
  - 어떤 PX는 놀고  
  - 결과적으로 `PX Deq Credit: send blkd`가 상승

**대응**

1) 조인 키가 편중이면  
   - **SALT 컬럼 추가**(해시 입력을 분산)  
   - 복합 해시 키 사용  
2) 재분배로도 못 버티면  
   - 작은 쪽을 Broadcast  
3) PGA 부족으로 빌드가 TEMP로 스필되면  
   - `direct path write/read temp` 증가 → PGA/DOP 조정

### 4.5 Dynamic 체크리스트

- 플랜에서 `PX SEND HASH`가 몇 번 나오는지  
- `V$PQ_TQSTAT`에서 TQ별 `bytes/num_rows`가 균등한지 :contentReference[oaicite:10]{index=10}  
- 스큐가 강하면 SALT/Broadcast/FPWJ 설계로 회귀

---

## 5) Broadcast 방식

### 5.1 정의

**작은 집합을 모든 PX로 복제**하고  
큰 집합은 재분배 없이 조인하는 방식.  
플랜에서 반드시 `PX SEND BROADCAST`가 나타난다. :contentReference[oaicite:11]{index=11}

### 5.2 Broadcast 실습

```sql
EXPLAIN PLAN FOR
SELECT /*+ leading(d) use_hash(s)
           parallel(s 16) parallel(d 16)
           pq_distribute(d BROADCAST NONE)
           monitor */
       s.cust_id, SUM(s.amount) amt
FROM   dim_customer d
JOIN   fact_sales   s
  ON   s.cust_id = d.cust_id
WHERE  d.grade IN ('GOLD','SILVER')
GROUP  BY s.cust_id;

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +ALIAS +NOTE'));
```

### 5.3 Broadcast가 좋은 조건 / 나쁜 조건

**좋은 조건**

- 브로드캐스트 대상이 **충분히 작다**  
- 스타 스키마에서 차원→사실 조인  
- 큰 사실 테이블을 **재분배 없이 로컬 스캔**할 때 효과 최대

**나쁜 조건**

- 작은 줄 알았는데 실측상 크다  
  → **PX마다 해시 빌드 메모리**가 커져 TEMP 스필로 역전  
- 브로드캐스트 대상이 필터 없이 전체 전송됨  
  → 네트워크가 먼저 죽음

**교정**

- 차원 테이블은 **필터를 선행**해서 “진짜 작은 집합”으로 만든 뒤 broadcast  
- 통계가 틀리면 broadcast 판단도 틀림 → 통계 갱신

---

## 6) 네 패턴을 한 번에 고르는 의사결정 매트릭스

| 상황 | 최우선 선택 | 이유 |
|---|---|---|
| 양쪽 모두 조인키로 동일 파티션 가능 | **Full PWJ** | P→P 제거, 선형 확장 :contentReference[oaicite:12]{index=12} |
| 한쪽만 파티션, 다른쪽 큼 | **Partial PWJ → Dynamic 보완** | 파티션 granule + 재분배 완화 |
| 파티션 구조 불일치/없음 | **Dynamic(HASH 재분배)** | 런타임 가상 파티션 정렬 |
| 작은 차원 vs 큰 사실 | **Broadcast** | 큰 쪽 재분배 제거 |
| RAC에서 gc 대기↑ | **PWJ 계열** | 파티션 지역성 확보 |

---

## 7) 모니터링/트레이스 템플릿(실전 복붙)

```sql
-- 1) 실제 실행 플랜
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
      NULL,NULL,'BASIC +PARALLEL +ALIAS +PREDICATE +NOTE +PARTITION'));

-- 2) TQ별 분배량/스큐
SELECT dfo_number, tq_id, server_type, inst_id, process,
       num_rows, bytes
FROM v$pq_tqstat
ORDER BY dfo_number, tq_id, server_type, inst_id, process;

-- 3) 병렬/재분배/Temp 대기(ASH, 최근 5분)
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSDATE - 1/288
  AND  session_type = 'FOREGROUND'
  AND (event LIKE 'PX Deq%'
       OR event LIKE 'direct path%'
       OR event LIKE 'gc %')
GROUP  BY event
ORDER  BY samples DESC;
```

---

## 8) 최종 한 줄 요약

- **Full PWJ**가 가능하도록 **조인 키 동일 파티션(또는 서브파티션 정렬)**을 맞추는 게 병렬 조인의 최강 설계다.  
- **Partial PWJ**는 파티션 granule 이득을 주지만 **스큐/재분배가 일부 남아** Dynamic/Broadcast로 보완해야 한다.  
- **Dynamic 파티셔닝**은 현실에서 가장 자주 쓰는 절충안이며, **PX SEND HASH와 스큐 지표**를 끝까지 추적해야 한다.  
- **Broadcast**는 작은 집합일 때만 미덕이고, 커지면 즉시 독이 된다.