---
layout: post
title: 정보보안기사 - CSRF
date: 2025-11-12 22:25:23 +0900
category: 정보보안기사
---
# SECTION 08 웹 애플리케이션 취약점 — 03. 크로스 사이트 요청 위조(CSRF: Cross-Site Request Forgery) 완전 정리 (원리·조건·공격 시나리오·현대 방어전략·프레임워크별 코드·REST/SPA·OAuth2 상태값·테스트/모니터링·체크리스트·예상문제)

## 개요 — “내 세션을 남이 쓰게 만들다”
**CSRF**는 사용자가 **이미 인증된 세션/쿠키**를 보유한 상태에서, **공격자가 의도한 요청을 피해자 브라우저로 전송**하게 만들어 서버가 **권한 있는 사용자 요청**으로 오인해 처리하는 취약점이다.
핵심 인식 포인트:

- 브라우저는 **같은 사이트가 아니어도 쿠키를 자동 전송**한다(조건 충족 시).
- 공격은 **피해자 브라우저에서 발원**하므로 IP·User-Agent가 정상이어서 탐지가 어렵다.
- **XSS 없이도** 발생하며, XSS가 있으면 CSRF 방어를 쉽게 우회할 수 있다(복합 위협).

---

## 위협 모델과 성립 조건

### 성립 3요건
1) 피해자 브라우저에 **유효한 인증 상태**(세션 쿠키/토큰)가 있고
2) 서버가 **요청만으로 상태 변경**을 수행하며(추가 확인/토큰 없음)
3) 공격자가 피해자에게 **교차 출처 요청을 일으키는 컨텐츠**를 렌더링시킬 수 있을 때(링크/이미지/폼/스크립트 등)

### 동작 흐름(시퀀스)
```
공격자 사이트                피해자 브라우저                      취약 서버
-------------               -----------------                     ----------
<iframe/폼/이미지>  -->  자동 요청 발생 (쿠키 포함)  -->  /transfer?to=E&amount=1000
                               (SameSite 조건 만족)            ↳ 정상 사용자 요청으로 처리
```

### 수식 직관
피해자의 세션 쿠키가 \( C \), 공격자가 유도하는 요청이 \( R_a \)일 때,
서버가 검증하는 기준이 \( \mathsf{Verify}(C, R_a) = \text{true} \)이면 공격 성공.
방어는 **추가 인자 \(T\)**(CSRF 토큰/Origin 검증 등)로:
\[
\mathsf{Verify}(C, R_a, T) = \text{true} \quad\text{iff}\quad T \approx \text{비밀·세션 귀속·재사용 억제}
\]

---

## 공격 시나리오(현장형 예시)

### 1. GET로 상태 변경(안티패턴)
```http
GET /transfer?to=attacker&amount=100000 HTTP/1.1
Cookie: SESSION=...
```
공격자는 이메일/게시글/DM 등에 다음을 삽입:
```html
<img src="https://bank.example.com/transfer?to=attacker&amount=100000">
```
브라우저는 이미지 로딩 목적이지만 **GET 요청이 발생**하고, 서버가 **GET만으로 송금**을 처리하면 끝.

### 2. 자동 제출 폼 — POST CSRF
```html
<form action="https://bank.example.com/transfer" method="POST">
  <input name="to" value="attacker">
  <input name="amount" value="100000">
</form>
<script>document.forms[0].submit()</script>
```
- 브라우저는 **쿠키를 자동 전송**(SameSite 정책에 따라).
- 서버가 **추가 검증 없이** 처리하면 송금.

### 3. JSON CSRF / CORS 얽힘
- 서버가 `application/json`만 허락하고 CORS를 열지 않았다면, **단순 폼 기반 POST**는 JSON을 보낼 수 없어서 공격 난이도가 상승.
- 그러나 서버가 **와일드카드 CORS(`Access-Control-Allow-Origin: *`)** 또는 **Credential 허용**을 잘못 열면, 스크립트를 통한 **크로스 오리진 XHR/fetch**가 가능해져 CSRF가 아니라 **CORS 인증 우회**로 이어질 수 있다.

### 4. 로그인/로그아웃 CSRF
- **Login CSRF**: 공격자가 자신의 계정으로 피해자를 **강제 로그인**시키면, 이후 행위/저장 데이터가 공격자 계정으로 귀속되어 **정보 노출/권한 혼선**을 유발.
- **Logout CSRF**: 사용자 세션을 끊어 작업 방해.

---

## 취약 패턴(요약 표)

| 패턴 | 위험 |
|---|---|
| **상태 변경을 GET으로 처리** | 링크·이미지 로딩만으로 실행 |
| **CSRF 토큰 미검증** | 모든 폼/POST가 공격 대상 |
| **SameSite=None + Secure 누락** | 제3자 컨텍스트에서 쿠키 전송 |
| **와일드카드 CORS** + `credentials: true` | 교차 오리진 스크립트가 인증 요청 수행 |
| **Origin/Referer 미검증** | CSRF·CORS 오인증 탐지 곤란 |
| **REST/SPA에서 폼 인코딩 허용** | 간단한 폼 제출로 JSON 엔드포인트 오염 |
| **OAuth2 state 미검증** | OIDC/OAuth CSRF(세션 고정, 계정 스와핑) |

---

## 현대 방어전략(다층)

### 1. **동기화 토큰(Synchronizer Token Pattern)**
- **서버가 세션 귀속 비밀 토큰**을 발급 → **폼/요청에 포함** → 서버가 검증.
- 특징: XSS가 없다면 강력. 토큰은 **예측 불가**, **세션/사용자에 묶임**, **재사용/만료 정책**을 가진다.

**서버(예: Express + csurf)**
```js
import express from 'express';
import session from 'express-session';
import csurf from 'csurf';

const app = express();
app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: false }));
app.use(express.urlencoded({ extended: false }));
app.use(csurf()); // req.csrfToken() 제공

app.get('/transfer', (req, res) => {
  res.send(`
    <form method="POST" action="/transfer">
      <input name="to">
      <input name="amount">
      <input type="hidden" name="_csrf" value="${req.csrfToken()}">
      <button>Send</button>
    </form>
  `);
});

app.post('/transfer', (req, res) => {
  // csurf 미들웨어가 토큰 자동 검증
  res.send('OK');
});
```

**Django**

{% raw %}
```python
# settings.py: 'django.middleware.csrf.CsrfViewMiddleware' 기본 활성
# 템플릿
<form method="post">{% csrf_token %} ... </form>

# AJAX (fetch)
fetch('/transfer/', {
  method: 'POST',
  headers: { 'X-CSRFToken': getCookie('csrftoken') },
  body: new URLSearchParams({ to, amount })
});
```
{% endraw %}

**Spring Security**
```java
// build.gradle에 spring-boot-starter-security
// CSRF는 MVC에서 기본 활성 (REST에서는 상황에 따라 커스터마이즈)
@Controller
public class TxController {
  @GetMapping("/transfer")
  public String form(Model m, CsrfToken token) {
    m.addAttribute("_csrf", token); // Thymeleaf: <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}">
    return "transfer";
  }
}

@Configuration
@EnableWebSecurity
class SecConfig {
  @Bean SecurityFilterChain f(HttpSecurity http) throws Exception {
    return http
      .csrf(csrf -> csrf.ignoringRequestMatchers("/webhook/**")) // 예외 정의는 최소화
      .build();
  }
}
```

**ASP.NET Core**
```csharp
// Razor 폼: 자동으로 AntiForgery 토큰 포함 (@Html.AntiForgeryToken())
[ValidateAntiForgeryToken]
public IActionResult Transfer(string to, int amount) { ... }
```

### 2. **더블 서브밋 쿠키(Double-Submit Cookie)**
- 서버가 **CSRF 토큰 쿠키**를 발급(읽기 가능, Non-HttpOnly)하고, 클라이언트가 **폼 필드/헤더**로 같은 값을 다시 전송. 서버는 **쿠키 값 == 폼/헤더 값**을 확인.
- 장점: **세션리스(Stateless)**에도 적용 가능.
- 단점: **XSS가 있으면 우회** 가능(쿠키/DOM에서 토큰 탈취). XSS 방어 병행 필수.

**검증 예**
```js
// 서버측
const tokenFromCookie = req.cookies['csrf'];
const tokenFromForm = req.body['_csrf'] || req.get('X-CSRF-Token');
if (!tokenFromCookie || tokenFromCookie !== tokenFromForm) return res.status(403).end();
```

### 3. **SameSite 쿠키 정책**
- `SameSite=Lax`: **탑내비게이션 GET**은 쿠키 전송(로그인 유지), 대부분의 **크로스 사이트 POST/이미지/iframe**에는 쿠키 **미전송** → CSRF 위험 크게 감소.
- `SameSite=Strict`: **완전 차단**(다만 UX 불편).
- `SameSite=None; Secure`: 제3자 컨텍스트에서 쿠키 전송을 허용하되 **반드시 Secure**(HTTPS 전용) 필요.

**Set-Cookie 예**
```
Set-Cookie: SESSION=...; Path=/; HttpOnly; Secure; SameSite=Lax
```
> SameSite만 믿지 말고 **토큰/Origin 검증**을 병행.

### 4. **Origin/Referer 검증**
- **HTTPS** 환경에서 **Origin** 헤더는 신뢰도 높음(리다이렉트/프록시 등 일부 예외 고려).
- **허용 오리진 화이트리스트**와 정확 비교; 없으면 **Referer**(부분 매칭 금지).

**검증 예(Express)**
```js
const ALLOW = new Set(['https://app.example.com']);
function verifyOrigin(req, res, next) {
  const origin = req.get('Origin') || '';
  const referer = req.get('Referer') || '';
  const good = (o) => ALLOW.has(o);
  if (origin && good(origin)) return next();
  try {
    const r = new URL(referer);
    if (good(`${r.protocol}//${r.host}`)) return next();
  } catch {}
  return res.status(403).send('Bad origin');
}
app.post('/transfer', verifyOrigin, handler);
```

### 5. **컨텐츠 타입/단순 요청 제한(JSON 전용)**
- 서버는 상태 변경 API에 대해 **`Content-Type: application/json`**만 허용하고, **폼 인코딩 거부**.
- 브라우저의 단순 폼 제출은 `application/x-www-form-urlencoded`/`multipart/form-data`/`text/plain`에 묶여 있으므로 **CORS 없이 JSON을 보낼 수 없음** → CSRF 난이도 상승.
- 단, **CORS가 열려 있거나 프리플라이트를 허용**하면 무력화되므로 **보조 수단**으로만 사용.

**필터 예**
```js
app.post('/api/*', (req, res, next) => {
  if (req.is('application/json')) return next();
  res.status(415).send('JSON only');
});
```

### 6. **CORS 안전 구성**
- **와일드카드(`*`) + Credentials** 금지.
- 필요한 오리진만 **정확 매칭** 허용, **메서드/헤더/노출 헤더 최소화**.
- **Preflight 결과 캐시**는 짧게. 민감 엔드포인트는 **CORS 미허용**이 기본.

```js
import cors from 'cors';
const allow = ['https://app.example.com'];
app.use(cors({
  origin: (o, cb) => cb(null, allow.includes(o)),
  credentials: true,
  methods: ['GET','POST'],
  allowedHeaders: ['Content-Type','X-CSRF-Token']
}));
```

### 7. **사용자 상호작용 요구(정책적)**
- 고위험 작업은 추가로 **재인증/2FA/비밀번호 재입력/확인 대화상자**를 요구.

---

## REST/SPA에서의 CSRF

### 쿠키 세션 기반 SPA
- API는 **쿠키 인증 + CSRF 토큰 헤더**를 요구(`X-CSRF-Token`).
- CSRF 토큰은 **메타 태그**·**별도 읽기 가능한 CSRF 쿠키**로 전달 → JS가 헤더로 보냄.
- `fetch(..., { credentials: 'include' })` 사용 시에도 **토큰/Origin 검증**이 필수.

```js
// SPA AJAX 공통
const csrf = getCookie('csrf'); // Non-HttpOnly CSRF 전용 쿠키
await fetch('/api/transfer', {
  method: 'POST',
  credentials: 'include',
  headers: { 'Content-Type':'application/json', 'X-CSRF-Token': csrf },
  body: JSON.stringify({ to, amount })
});
```

### Bearer 토큰 기반
- 엄밀히는 **전통적 CSRF 벡터**에 강함(쿠키 자동 전송이 아니므로).
- 하지만 **토큰 저장 위치(XSS 위험)**가 치명적: **`localStorage` 대신 메모리/HttpOnly 쿠키+CSRF** 등 **XSS 완화** 필수.

---

## OAuth2/OIDC에서의 CSRF (state/nonce)

- **`state` 파라미터**: 클라이언트가 난수 발급 → Authorization 요청에 포함 → **콜백에서 동일 값**을 비교, **CSRF/세션 스와핑** 방지.
- **OIDC `nonce`**: ID 토큰 재생/치환 방지.

```text
1) 클라: state = random()
2) GET /authorize?client_id=...&redirect_uri=...&state=<state>
3) 콜백 /callback?code=...&state=<state’>
4) 서버: state == state’? 아니면 에러
```

---

## 케이스 스터디: “방어 없는 서버” → “다층 방어 서버”

### 초기(취약)
- `/transfer`가 POST이면 처리, **토큰 없음**, **Origin 검증 없음**, **SameSite=None**.

### 개선 단계
1) **SameSite=Lax; Secure; HttpOnly**로 세션 쿠키 강화.
2) **CSRF 토큰**(세션 귀속) + **폼/헤더** 요구.
3) **Origin/Referer 화이트리스트** 검증.
4) **컨텐츠 타입 JSON 전용**, 폼 인코딩 거부.
5) **CORS 최소 허용**: 내부 프론트 오리진만, credentials 필요 시 정확 설정.

---

## 테스트/재현(합법적·격리 랩 전제)

### 1. 공격 페이지(POST 자동 제출)
```html
<!-- attacker.html (테스트용) -->
<form action="https://victim.example.com/transfer" method="POST">
  <input name="to" value="attacker">
  <input name="amount" value="1000">
</form>
<script>document.forms[0].submit()</script>
```
- 피해자가 이 페이지를 열면, 브라우저는 `victim.example.com` 쿠키를 전송하려 시도(SameSite 정책에 따라 다름).
- 서버가 토큰/Origin을 검사하지 않으면 성공.

### 2. 서버에서 차단 로그(예시)
- “**CSRF token mismatch**”
- “**Bad origin: https://evil.example**”
- “**Unsupported Media Type**: require application/json”

---

## 운영 모니터링/탐지 포인트

- **실패율 증가**: 특정 엔드포인트에서 403(토큰 불일치)/415(JSON only) 급증.
- **Origin/Referer 이상**: 외부 도메인에서 오는 **상태 변경 요청** 패턴.
- **CSP/보안헤더**: SameSite 미적용·`None` 비율, Set-Cookie 점검.
- **SIEM 룰 아이디어**
  - 조건: `method in (POST, PUT, DELETE)` ∧ `origin not in allowlist`
  - 조건: `content-type in (x-www-form-urlencoded, multipart/form-data)` ∧ `path matches ^/api/` → 경고

---

## 프록시/서버 구성 팁

### Nginx로 SameSite 재작성(불가피할 때만)
```nginx
# Set-Cookie를 애플리케이션이 못 바꾸는 상황에서 헤더 편집 (주의해서 사용)
proxy_cookie_path / "/; HttpOnly; Secure; SameSite=Lax";
```

### 응답 헤더(권장 세트)
```nginx
add_header X-Content-Type-Options "nosniff" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
# CSP는 XSS 주력 대책 (CSRF 직접 방어 X, 그러나 DOM 삽입 억제로 보조)
add_header Content-Security-Policy "default-src 'self'; object-src 'none'; base-uri 'self'; frame-ancestors 'none';" always;
```

---

## 프레임워크별 “실무 레시피” 요약

| 프레임워크 | 기본 권장 |
|---|---|
| **Django** | `CsrfViewMiddleware` 유지, {% raw %}`{% csrf_token %}`{% endraw %}, `CSRF_TRUSTED_ORIGINS` 최소화, AJAX는 `X-CSRFToken` |
| **Spring** | MVC는 기본 활성, 폼/템플릿에 `_csrf` 주입, REST는 토큰+Origin 검증, WebFlux시 별도 고려 |
| **ASP.NET Core** | `[ValidateAntiForgeryToken]`, Razor TagHelper 자동 주입, API는 토큰 헤더+Origin 검증 |
| **Express** | `csurf` + 세션, JSON only + Origin 검증, CORS 최소화 |
| **Flask** | Flask-WTF CSRF, API는 더블서브밋 또는 세션토큰+헤더 검증 |

---

## 체크리스트(현장용)

- [ ] **상태 변경은 POST/PUT/PATCH/DELETE**로만 (GET 금지)
- [ ] 모든 상태 변경 경로에 **CSRF 토큰 검증**(세션 귀속/난수/만료/재사용 제한)
- [ ] **SameSite=Lax**(기본) / **Secure** / **HttpOnly** 세션 쿠키
- [ ] **Origin/Referer 화이트리스트 검증**(HTTPS 기준, 정확 비교)
- [ ] API는 **`application/json` 전용** + **폼 인코딩 거부**
- [ ] **CORS 최소 허용**: 정확 오리진, 메서드/헤더 최소, credentials 신중
- [ ] 고위험 작업 **재인증/2FA/사용자 확인**
- [ ] **로그/알림**: CSRF 실패·미승인 오리진·415 비율 모니터
- [ ] **OAuth2/OIDC `state`/`nonce`** 올바른 생성·검증
- [ ] **보안 테스트**: SAST(anti-CSRF 미사용 탐지), DAST(폼/헤더/Origin 검사), 회귀 자동화

---

## 예상문제(실기 감각 강화)

1) **문항**: CSRF 방어로서 SameSite=Lax의 한계 2가지를 쓰시오.
   **예시 답**: (1) 탑내비게이션 GET은 여전히 쿠키 전송 → GET 상태 변경 시 위험, (2) 브라우저/레거시 호환성 차이·특정 임베딩 케이스에서 동작 예외가 있을 수 있음.

2) **문항**: 더블 서브밋 쿠키 패턴의 전제 조건과 XSS와의 관계를 설명하시오.
   **예시 답**: 토큰 쿠키는 JS에서 읽을 수 있어야 하므로 Non-HttpOnly로 발급; XSS가 있으면 토큰 탈취 가능 → **XSS 방어와 병행해야** 실효.

3) **문항**: 다음 CORS 설정의 문제를 지적하시오.
```http
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```
   **정답 요지**: 와일드카드와 credentials 동시 사용은 금지. 특정 오리진만 정확 허용해야 함.

4) **문항**: OAuth2에서 CSRF 방지를 위한 필수 파라미터와 검증 절차는?
   **정답**: `state` 랜덤 발급 → 콜백에서 동일성 검증(미일치 즉시 에러). OIDC는 `nonce`도 포함.

5) **문항**: 다음 중 CSRF를 근본적으로 줄이는 API 수신 정책 2가지를 고르시오.
   a) `application/json`만 허용
   b) `text/plain`도 허용
   c) Origin 화이트리스트 검증
   d) 모든 오리진 허용+CORS 자격증명
   **정답**: a, c

---

## 미니 계산 문제(리스크 직관)
리스크 \(R\)를 **발생확률 \(L\)**과 **영향도 \(I\)**, **방어 계수 \(D\)**로 잡자:
\[
R = \frac{L \times I}{D}, \quad
D = D_{\text{Token}} \cdot D_{\text{SameSite}} \cdot D_{\text{Origin}} \cdot D_{\text{CORS}}
\]
- 토큰/Origin/JSON-only/CORS 최소화가 곱셈적으로 위험을 낮춘다.
- XSS가 존재하면 \(D_{\text{Token}}\)의 실효가 낮아질 수 있으므로 **XSS 제거**가 선행되어야 한다.

---

## 결론
- **CSRF는 브라우저의 자동 인증 전송을 악용**한다.
- **토큰(세션 귀속) + SameSite + Origin 검증 + JSON-only + 최소 CORS**의 **다층 방어**가 현대 표준.
- 프레임워크의 내장 **Anti-CSRF**를 **끄지 말고**, REST/SPA에서도 **헤더 토큰·Origin**을 엄격히 적용하라.
- OAuth2/OIDC의 `state/nonce`를 **반드시 검증**하고, 모니터링/로깅으로 **실패 패턴**을 추적하라.
- 본 문서의 코드 스니펫을 템플릿화하여 **팀 공통 보안 게이트**로 정착시키면 재발을 크게 줄일 수 있다.
