---
layout: post
title: 객체지향설계 - SOLID 원칙
date: 2025-07-20 17:20:23 +0900
category: 객체지향설계
---
# 객체 지향 설계의 SOLID 원칙

## 0. SOLID란 무엇인가 — 설계 원리의 목적과 적용 순서

**SOLID**는 객체 지향 설계를 **이해하기 쉽고, 바꾸기 쉽고, 확장에 강한 구조**로 만드는 다섯 원칙의 약어다.

| 약어 | 원칙 | 한 줄 요약 | 주로 푸는 문제 |
|---|---|---|---|
| **S** | 단일 책임 원칙 (SRP) | **하나의 이유로만** 변하는 클래스 | 역할 혼재, 변경 파급 |
| **O** | 개방-폐쇄 원칙 (OCP) | **확장에는 열려**, **변경에는 닫혀** | if-else 폭발, 플러그인 필요 |
| **L** | 리스코프 치환 원칙 (LSP) | 하위 타입은 상위 타입을 **대체 가능** | 잘못된 상속/계약 위반 |
| **I** | 인터페이스 분리 원칙 (ISP) | **작고 구체적** 인터페이스 | 불필요한 구현 강제 |
| **D** | 의존 역전 원칙 (DIP) | **추상**에 의존 / **구체**에 의존 금지 | 교체 불가, 테스트 어려움 |

**실무 적용 순서(권장)**  
1) **SRP**로 역할 쪼개기 → 2) **KISS/DRY**로 단순/공통화 → 3) **OCP**로 확장 지점 만들기 →  
4) **LSP/ISP**로 타입/계약 정제 → 5) **DIP**로 플러그형 의존 구조 확정

> 팁: 원칙은 **절대 규칙**이 아니라 **트레이드오프 지침**이다. **테스트와 계측**이 의사결정을 뒷받침한다.

---

## 1. SRP — 단일 책임 원칙 (Single Responsibility Principle)

### 1.1 정의와 핵심
- **정의**: 클래스(또는 모듈)는 **단 하나의 변경 이유(reason to change)**만 가져야 한다.
- **목표**: 변경 파급을 **지역화**하고, **응집도**를 높인다.

### 1.2 위반 신호(냄새)
- 메서드 목록이 **다른 관심사**를 동시에 다룸(생성/저장/전송이 한곳).
- 작은 요구 변화가 **여러 파일**을 동시에 흔듦(Shotgun Surgery).
- **긴 파라미터 목록**과 **조건 분기**가 섞여 확장 때마다 더 길어짐.

### 1.3 위반 예 → 개선 예
```java
// ❌ 위반: 리포트 생성+저장+전송이 한 클래스
class ReportManager {
    String generateReport() { /* ... */ }
    void saveToFile(String data) { /* ... */ }
    void sendEmail(String data) { /* ... */ }
}
```

```java
// ✅ 개선: 역할 분리(응집도↑, 변경 파급↓)
class ReportGenerator { String generate() { /* ... */ } }
class FileSaver { void save(String data) { /* ... */ } }
class EmailSender { void send(String data) { /* ... */ } }
```

### 1.4 리팩토링 레시피
- **Extract Class/Function**, **Introduce Parameter Object**  
- **도메인 서비스**와 **인프라 어댑터**를 분리(포트/어댑터)

### 1.5 측정 팁
- 한 클래스 **공개 API 수**와 **수정 이력**(git blame/log)을 함께 본다.  
- 변경 이유가 2개 이상이면 분리 후보.

---

## 2. OCP — 개방-폐쇄 원칙 (Open/Closed Principle)

### 2.1 정의와 핵심
- **확장**에는 열려 있고, 기존 코드 **변경**에는 닫혀 있어야 한다.
- **정책/전략**을 **추상화**로 외부화하고, **플러그인 구조**로 수용한다.

### 2.2 위반 예 → 전략 패턴(전형 개선)
```java
// ❌ 위반: 새 결제 수단이 등장할 때마다 조건문 수정
class PaymentProcessor {
    void pay(String type) {
        if ("card".equals(type)) { /* ... */ }
        else if ("cash".equals(type)) { /* ... */ }
        // else if ("kakao") ...
    }
}
```

```java
// ✅ 개선: 전략/플러그인으로 확장, 기존 코드 불변
interface PaymentStrategy { void pay(int amount); }

class CardPayment implements PaymentStrategy { public void pay(int a){ /*...*/ } }
class CashPayment implements PaymentStrategy { public void pay(int a){ /*...*/ } }

class PaymentProcessor {
    void process(PaymentStrategy method, int amount) { method.pay(amount); }
}
```

### 2.3 구현 옵션
- **전략/정책 객체**, **템플릿 메서드**, **규칙(룰) 엔진**, **이벤트/구독**
- **DI 컨테이너**: 런타임 플러그인 주입 / **서비스 로더**(Java `ServiceLoader`)

### 2.4 테스트 전략
- 새 확장은 **기존 테스트**를 깨지 않으면서 **자신만의 테스트**를 추가.
- 회귀를 막는 **계약 테스트**(shared tests) 도입.

---

## 3. LSP — 리스코프 치환 원칙 (Liskov Substitution Principle)

### 3.1 정의(계약 관점)
**하위 타입 S는 상위 타입 T로 대체 가능**해야 한다. 즉 상위 타입을 사용하는 클라이언트가 **행동적 계약**을 깨지 않는다.

수학적(계약) 표현:
- **전제(Precondition)** 약화:  
  $$\text{Pre}_S \subseteq \text{Pre}_T$$  
  (하위는 상위보다 **더 많은 요구**를 해선 안 된다.)
- **사후(Postcondition)** 강화:  
  $$\text{Post}_T \subseteq \text{Post}_S$$  
  (하위는 상위가 보장한 것보다 **적게 보장**해선 안 된다.)
- **불변식(Invariant)** 유지: 상위의 불변 조건은 하위도 항상 만족.

### 3.2 위반 예 → 역할 분리
```java
// ❌ 위반: 모든 Bird가 fly()를 가진다는 거짓 전제
class Bird { void fly() { /* ... */ } }

class Ostrich extends Bird {
    @Override void fly() { throw new UnsupportedOperationException(); }
}
```

```java
// ✅ 개선: 능력 인터페이스 분리
class Bird { /* 공통 성질 */ }
interface Flyable { void fly(); }

class Sparrow extends Bird implements Flyable { public void fly(){ /*...*/ } }
class Ostrich extends Bird { /* fly 능력 없음 */ }
```

### 3.3 실무 체크
- **is-a**가 **행동적**으로 성립하는가? (단순 “속성 공유”가 아님)
- 상위의 **예외/경계값**을 하위가 **강화**하지 않는가?

---

## 4. ISP — 인터페이스 분리 원칙 (Interface Segregation Principle)

### 4.1 정의와 핵심
클라이언트는 **사용하지 않는 메서드**에 의존하면 안 된다.  
→ **작고 응집된 인터페이스**를 여럿으로 분리하라(파셋).

### 4.2 위반 예 → 분리
```java
// ❌ 위반: 먹지 않는 클라이언트에게 eat() 강제
interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work(){ /* ... */ }
    public void eat(){ throw new UnsupportedOperationException(); }
}
```

```java
// ✅ 개선: 능력에 따라 인터페이스 분리
interface Workable { void work(); }
interface Eatable { void eat(); }

class Human implements Workable, Eatable { /* ... */ }
class Robot implements Workable { /* ... */ }
```

### 4.3 실무 팁
- API 공개면을 **작게** 유지(“필요 최소”).
- **Query/Command 분리**(CQRS 사고): 읽기/쓰기를 다른 인터페이스로.

---

## 5. DIP — 의존 역전 원칙 (Dependency Inversion Principle)

### 5.1 정의와 핵심
**고수준** 정책은 **저수준** 구현에 의존하지 않는다. **둘 다 추상화(인터페이스/포트)**에 의존해야 한다.

### 5.2 위반 예 → 의존 역전
```java
// ❌ 위반: Switch가 Light 구체 타입에 결합
class Light { void turnOn(){ /*...*/ } }

class Switch {
    private final Light light = new Light();
    void operate(){ light.turnOn(); }
}
```

```java
// ✅ 개선: 포트(추상)에 의존, 어댑터로 구현 교체 가능
interface Switchable { void turnOn(); }

class Light implements Switchable { public void turnOn(){ /*...*/ } }
class Fan   implements Switchable { public void turnOn(){ /*...*/ } }

class Switch {
    private final Switchable device;
    Switch(Switchable device){ this.device = device; }
    void operate(){ device.turnOn(); }
}
```

### 5.3 구현 패턴
- **포트/어댑터(헥사고널)**, **DI 컨테이너**, **팩토리/추상 팩토리**, **이벤트 드리븐**

---

## 6. 원칙 간 상호작용과 트레이드오프

| 상황 | 충돌/유의 | 권장 판단 |
|---|---|---|
| DRY 추상화가 복잡도를 키움 | DRY vs KISS | **KISS 우선**, 3번째 반복에서 추상화 |
| 미래 확장 대비 추상화 | OCP vs YAGNI | **YAGNI 우선**, 실제 요구 생기면 확장 |
| 타입/상속 남용 | OCP vs LSP | 상속 대신 **합성/역할 인터페이스** 고려 |
| 굵은 인터페이스 | ISP vs SRP | 인터페이스를 **파셋**으로 쪼개기 |

---

## 7. 통합 사례 — “주문 결제” 모듈을 SOLID로

### 7.1 문제(초안)
```java
class CheckoutService {
    int pay(String method, int amount){
        if ("card".equals(method)) { /* ... */ }
        else if ("kakao".equals(method)) { /* ... */ }
        // 저장/로깅/영수증 발송까지 이 안에서 수행
        return 0;
    }
}
```
- **SRP 위반**(결제+저장+알림), **OCP 위반**(분기 폭발), **DIP 위반**(구체 의존)

### 7.2 SOLID로 재설계
```java
// OCP, DIP: 결제 정책을 포트로
public interface PaymentPort { Receipt pay(int amount); }

// 구체 어댑터(저수준)
public final class CardPaymentAdapter implements PaymentPort { /* ... */ }
public final class KakaoPaymentAdapter implements PaymentPort { /* ... */ }

// SRP: 영수증 저장/알림 분리
public interface ReceiptStore { void save(Receipt r); }
public interface Notifier { void notifyPaid(Receipt r); }

// 고수준 도메인 서비스(DIP: 포트 주입)
public final class CheckoutService {
    private final PaymentPort payment;
    private final ReceiptStore store;
    private final Notifier notifier;

    public CheckoutService(PaymentPort payment, ReceiptStore store, Notifier notifier){
        this.payment = payment; this.store = store; this.notifier = notifier;
    }

    public Receipt checkout(int amount){
        Receipt r = payment.pay(amount);   // 확장 지점(OCP)
        store.save(r);                     // SRP
        notifier.notifyPaid(r);            // SRP
        return r;
    }
}
```

- **LSP/ISP**: `PaymentPort`는 **필요 최소 동작**만 노출, 하위 어댑터는 **계약**을 유지.

### 7.3 계약(간단 수식)
- 영수증의 **불변식**:  
  $$ r.\text{amount} > 0 \land r.\text{status} \in \{\text{PAID}\} $$
- 어댑터는 예외 대신 **표준 실패 형태**를 반환하거나 예외 규약을 공유.

### 7.4 테스트 전략
```java
// 계약 테스트(여러 결제 어댑터에 공통 적용)
abstract class PaymentPortContract {
    protected abstract PaymentPort sut();

    @Test void pay_returns_paid_receipt(){
        Receipt r = sut().pay(1000);
        assertEquals(Status.PAID, r.status());
        assertTrue(r.amount() > 0);
    }
}
```
- 어댑터별로 `PaymentPortContract`를 **상속**해 공통 규약 검증.

---

## 8. 리팩토링 체크리스트(코드 리뷰 카드)

- **SRP**: 이 클래스/메서드는 **하나의 이유**로만 변하는가?
- **OCP**: 새 요구가 오면 **확장**으로 대응 가능한가(분기 추가 금지)?
- **LSP**: 상위 타입의 **전제/사후/불변**을 하위가 **존중**하는가?
- **ISP**: 공개 인터페이스가 **작고 응집**되어 있는가?
- **DIP**: 고수준 모듈이 **구체 타입**에 결합되어 있지 않은가?

---

## 9. 패턴 매핑(어디서 무엇을 쓰나)

| 원칙 | 자주 쓰는 패턴 | 효과 |
|---|---|---|
| SRP | 도메인 서비스, 어댑터 분리, 파사드 | 역할 분리, 파급 감소 |
| OCP | 전략, 상태, 규칙 엔진, 템플릿 메서드, 이벤트 | 조건 제거, 플러그인화 |
| LSP | 합성 우선, 역할 인터페이스, 데코레이터 | 안전한 확장 |
| ISP | 파셋 인터페이스, CQRS 분리 | 불필요 의존 제거 |
| DIP | 포트/어댑터, DI 컨테이너, 추상 팩토리 | 교체/테스트 용이 |

---

## 10. 계측과 운영 가드레일

- **정적 분석**: 공개 API 수, 사이클로매틱/인지 복잡도, 중복률
- **아키텍처 린트**: “도메인 → 인프라” 의존만 허용(역방향 금지)
- **테스트**: 계약/스냅샷/회귀 테스트를 CI에서 강제
- **릴리즈 전략**: 새 확장은 **피처 토글**로 배포(기존 코드 무변)

**변경 위험 근사**:
$$
\text{Risk} \approx (\text{PublicSurface}) \times (\text{DuplicationRate}) \times (\text{CognitiveComplexity})
$$
- **SRP/ISP**: PublicSurface↓, **DRY**: Duplication↓, **KISS**: Complexity↓

---

## 11. 자주 묻는 질문(FAQ)

**Q1. SOLID를 모두 지키려다 오히려 복잡해지면?**  
A. **KISS/YAGNI**를 우선. 작게 시작→반복 3회 시점에 추상화(DRY/OCP).

**Q2. 상속으로 OCP를 달성해도 될까?**  
A. 가능하나 **LSP** 위반 위험. 먼저 **합성+역할 인터페이스**를 고려.

**Q3. DIP가 너무 많은 인터페이스를 만든다?**  
A. **경계(외부 I/O)**에만 DIP를 강제하고, 내부는 **구체 타입** 사용도 허용.

---

## 12. 한눈에 요약

| 원칙 | 핵심 | 실전 한 줄 |
|---|---|---|
| SRP | 하나의 변경 이유 | **역할**을 분리해 파급을 가둬라 |
| OCP | 확장/무변 | **분기**를 **전략/플러그인**으로 바꿔라 |
| LSP | 대체 가능 | 상위 **계약**을 하위가 **완화/강화**하지 마라 |
| ISP | 작은 인터페이스 | 클라이언트가 **쓰는 것만** 의존하게 하라 |
| DIP | 추상에 의존 | 경계를 **포트/어댑터**로 끊고 **DI**로 연결하라 |

---

## 13. 마무리

SOLID는 **깨끗한 코드**의 종착지가 아니라 **변화와 확장을 견디는 구조**로 가는 **지도**다.  
작게 쪼개고(SRP), 단순하게 만들고(KISS), 반복될 때 공통화하며(DRY), 꼭 필요할 때만 확장하고(YAGNI),  
그 확장 지점을 **OCP/LSP/ISP/DIP**로 다듬어라.  
그렇게 하면 코드베이스는 **안정적**이면서도 **진화 가능**해진다.