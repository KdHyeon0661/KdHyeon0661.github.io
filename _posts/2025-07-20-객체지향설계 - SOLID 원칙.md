---
layout: post
title: 객체지향설계 - SOLID 원칙
date: 2025-07-20 17:20:23 +0900
category: 객체지향설계
---
# 🧱 객체 지향 설계의 SOLID 원칙 개요

---

## 🔷 SOLID란?

**SOLID 원칙**은 객체지향 설계에서 유지보수성과 확장성을 높이기 위해 제안된 **다섯 가지 설계 원칙**입니다. 이 원칙들은 소프트웨어를 **더 이해하기 쉽게**, **더 유연하게**, **변화에 강하게** 만들기 위한 가이드라인 역할을 합니다.

> SOLID는 다섯 원칙의 머리글자를 딴 약어입니다.

| 약어 | 원칙 이름 | 설명 |
|------|------------|------|
| S | **단일 책임 원칙 (SRP)** | 하나의 클래스는 하나의 책임만 가져야 한다 |
| O | **개방-폐쇄 원칙 (OCP)** | 확장에는 열려 있고, 변경에는 닫혀 있어야 한다 |
| L | **리스코프 치환 원칙 (LSP)** | 하위 타입은 언제나 상위 타입으로 대체할 수 있어야 한다 |
| I | **인터페이스 분리 원칙 (ISP)** | 클라이언트는 사용하지 않는 메서드에 의존하면 안 된다 |
| D | **의존 역전 원칙 (DIP)** | 고수준 모듈은 저수준 모듈에 의존하지 말고, 추상에 의존해야 한다 |

---

## 1️⃣ SRP - 단일 책임 원칙 (Single Responsibility Principle)

### ✔ 정의  
하나의 클래스는 **단 하나의 책임만 가져야 하며**, 그 책임은 **변경의 이유**가 오직 하나뿐이어야 한다.

### 🎯 목적
- 클래스를 더 작고 명확하게 나누어 **유지보수성 향상**
- 변경 시 **영향 범위 최소화**

### ❌ 위반 예제

```java
class ReportManager {
    public String generateReport() { /* ... */ }
    public void saveToFile(String data) { /* ... */ }
    public void sendEmail(String data) { /* ... */ }
}
```

➡ 리포트 생성, 저장, 전송 등 **여러 책임**이 혼합되어 있음.

### ✅ 개선 예제

```java
class ReportGenerator { public String generateReport() { ... } }
class FileSaver { public void saveToFile(String data) { ... } }
class EmailSender { public void sendEmail(String data) { ... } }
```

---

## 2️⃣ OCP - 개방-폐쇄 원칙 (Open/Closed Principle)

### ✔ 정의  
**기능의 확장은 가능하지만**, 기존 코드는 **변경되지 않아야 한다.**

### 🎯 목적
- **변화에 강한 구조**를 만들고
- 기존 시스템의 **안정성 유지**

### ❌ 위반 예제

```java
class PaymentProcessor {
    public void pay(String type) {
        if (type.equals("card")) { ... }
        else if (type.equals("cash")) { ... }
    }
}
```

➡ 새로운 결제 수단이 생길 때마다 조건문을 변경해야 함.

### ✅ 개선 예제 (전략 패턴 활용)

```java
interface PaymentStrategy {
    void pay();
}

class CardPayment implements PaymentStrategy { public void pay() { ... } }
class CashPayment implements PaymentStrategy { public void pay() { ... } }

class PaymentProcessor {
    public void process(PaymentStrategy method) {
        method.pay();
    }
}
```

➡ 새로운 결제 방식은 **클래스 추가만으로 확장** 가능, 기존 코드 건드릴 필요 없음.

---

## 3️⃣ LSP - 리스코프 치환 원칙 (Liskov Substitution Principle)

### ✔ 정의  
**하위 클래스는 상위 클래스의 기능을 대체할 수 있어야 한다.**

> 즉, 부모 타입 객체를 사용하는 코드가 **자식 타입으로 교체되어도 정상 동작**해야 한다.

### 🎯 목적
- **정확한 상속 관계** 유지
- 다형성(Polymorphism)의 안정성 확보

### ❌ 위반 예제

```java
class Bird { public void fly() { ... } }

class Ostrich extends Bird {
    public void fly() {
        throw new UnsupportedOperationException();
    }
}
```

➡ `Bird`는 모두 날 수 있다는 전제를 깨뜨림 → **리스코프 위반**

### ✅ 개선 방향

```java
interface Flyable { void fly(); }

class Bird { }
class Sparrow extends Bird implements Flyable { public void fly() { ... } }
class Ostrich extends Bird { /* can't fly, no fly method */ }
```

---

## 4️⃣ ISP - 인터페이스 분리 원칙 (Interface Segregation Principle)

### ✔ 정의  
클라이언트는 **자신이 사용하지 않는 메서드에 의존하지 않아야 한다.**

### 🎯 목적
- 인터페이스는 **작고 명확하게 나눠야** 한다.
- **불필요한 구현 강제 방지**

### ❌ 위반 예제

```java
interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() { ... }
    public void eat() { throw new UnsupportedOperationException(); }
}
```

➡ `Robot`은 `eat()` 기능이 필요 없음

### ✅ 개선 예제

```java
interface Workable { void work(); }
interface Eatable { void eat(); }

class Human implements Workable, Eatable { ... }
class Robot implements Workable { ... }
```

---

## 5️⃣ DIP - 의존 역전 원칙 (Dependency Inversion Principle)

### ✔ 정의  
**상위 모듈**은 하위 모듈에 의존하면 안 되며, **둘 다 추상화에 의존**해야 한다.

> 추상(Interface)에 의존하고, 구체적인 구현에 의존하지 않게 해야 한다.

### 🎯 목적
- 유연한 코드 구조
- **구현체 교체의 용이성** 확보
- 테스트 및 유지보수 용이

### ❌ 위반 예제

```java
class Light {
    public void turnOn() { ... }
}

class Switch {
    private Light light;
    public Switch() { this.light = new Light(); }
    public void operate() { light.turnOn(); }
}
```

➡ `Switch`는 `Light`라는 **구체 클래스에 강하게 의존**

### ✅ 개선 예제

```java
interface Switchable {
    void turnOn();
}

class Light implements Switchable {
    public void turnOn() { ... }
}

class Switch {
    private Switchable device;
    public Switch(Switchable device) { this.device = device; }
    public void operate() { device.turnOn(); }
}
```

➡ 이제 `Light`, `Fan`, `Heater` 모두 교체 가능

---

## 🔚 마무리 요약

| 원칙 | 핵심 요약 | 키워드 |
|------|----------|--------|
| SRP | 클래스는 하나의 책임만 가져야 함 | 관심사의 분리 |
| OCP | 확장에 열려 있고 변경에 닫혀야 함 | 전략 패턴 |
| LSP | 하위 타입은 상위 타입을 대체할 수 있어야 함 | 안전한 상속 |
| ISP | 작고 구체적인 인터페이스를 분리하라 | 인터페이스 최소화 |
| DIP | 구체가 아닌 추상에 의존하라 | 의존성 주입, IoC |

---

## ✅ 결론

SOLID 원칙은 객체 지향 설계의 핵심 철학을 반영하며, 이를 잘 적용하면 다음과 같은 이점을 얻을 수 있습니다:

- **변경에 유연한 코드**
- **테스트하기 쉬운 구조**
- **모듈화된 설계**
- **재사용성과 확장성 강화**

실무에서는 SOLID 원칙을 **하나하나 엄격하게 지키기보다는**, 상황에 맞춰 유연하게 조합하여 설계에 반영하는 것이 중요합니다.
