---
layout: post
title: 논리회로설계 - 순서회로설계 (2)
date: 2025-09-08 23:30:23 +0900
category: 논리회로설계
---
# 순서회로설계 — **CPLD 기반 설계**, **FPGA 기반 설계**, **시뮬레이션과 검사**, **컴퓨터 이용 설계(CAD) 개요**  
> 코드 블록은 ```…``` 사용, 수식은 MathJax(예: \(T_{CQ}+t_{comb}+T_{SU}\le T_{clk}\)). 가능한 한 실무 예제를 곁들여 “생략 없이” 정리했습니다.

---

## 1) CPLD를 사용한 순서회로 설계

### 1.1 CPLD 아키텍처 빠른 개요
- **매크로셀(Macrocell)**: AND-OR 가산기(PLA 유사) + 선택적 D-FF + 출력 이네이블(3-state).  
- **제품항(Product Term) 공유**: AND 플레인의 항을 여러 매크로셀이 공유. 항(PT) 예산이 **주된 제약**.  
- **클럭/리셋**: 글로벌 클럭, 전역 비동기 Clear/Preset 선 제공이 흔함. **게이티드 클럭 금지**, **Clock Enable** 사용.  
- **I/O**: 버스에 직접 3-state 구동 가능(내장 OE).  
- **장점/용도**: 정형 제어 FSM, 글루 로직, 주소 디코더, 소규모 시퀀서. **레이턴시 짧고 결정론적**.  
- **주의**: 내부 RAM/DSP 없음, 팬인↑(PT↑) 시 쉽게 포화. 조합 경로 길이는 짧으나 **PT 초과**가 설계를 막음.

### 1.2 CPLD 설계 플로우(요약)
1) **명세/상태도** → **상태표**(ISM이면 ‘–’ 표시).  
2) **최소화**(함의 차트/분할정련) → **상태할당**(이진 권장: FF↓, PT 소비 예측 용이).  
3) **코딩**: SOP 친화적 스타일(조건문을 **평탄화**), **공유 항**(공통 곱항) 의식.  
4) **제약**: 핀 고정(QSF/UCF), 타이밍(간단 주기/입출력 지연).  
5) **합성/적합**(fit) → **PT 리포트** 확인 → **리팩토링**(항 합치기, 공통인수 추출).  
6) **기능/타이밍 시뮬** → **프로그램** → **현장 검증**(Logic Analyzer).

### 1.3 예제: **교차로 신호 FSM** (Moore, 2로 방향/보행자 버튼 입력)
- **입력**: `P`(보행 버튼, 비동기), `T`(타이머 완료 펄스)  
- **출력**: `G_NS, Y_NS, R_NS, G_EW, Y_EW, R_EW, WALK` (서로 배타)  
- **상태**: `S0(북남-녹) → S1(북남-황) → S2(동서-녹) → S3(동서-황)`  
- **보행 로직**: 각 녹 시작에서 `P`가 눌린 흔적이 있으면 `WALK=1`으로 \(N\)초 유지. `P`는 **동기화 + 에지검출**.
- **CPLD 코딩 팁**:  
  - `WALK` 활성 조건을 **곱항으로 공유**: `WALK_EN = (S0 or S2) and P_latched`  
  - 출력은 **상태 비트** 직접 사용(PT 절약): 예) `G_NS = S0`, `Y_NS = S1`, …

**(a) 동기화/에지 검출 (2FF + one-shot)**
```vhdl
-- CPLD에서도 반드시 비동기 입력 동기화
process(clk) begin
  if rising_edge(clk) then
    p_d1 <= P; p_d2 <= p_d1;               -- 2단 동기화
    p_edge <= (not p_d2) and p_d1;         -- 상승 에지 검출
  end if;
end process;
```

**(b) FSM (상태=이진 2비트, Moore)**
```vhdl
type S_t is (S0,S1,S2,S3);
signal s, ns: S_t := S0;
signal walk_latch: std_logic := '0';

-- 다음상태
process(all) begin
  ns <= s;
  case s is
    when S0 => if T='1' then ns <= S1; end if;
    when S1 => if T='1' then ns <= S2; end if;
    when S2 => if T='1' then ns <= S3; end if;
    when S3 => if T='1' then ns <= S0; end if;
  end case;
end process;

-- 상태 레지스터 + 보행 latch
process(clk, rst_n) begin
  if rst_n='0' then s<=S0; walk_latch<='0';
  elsif rising_edge(clk) then
    s <= ns;
    if (s=S0 or s=S2) and p_edge='1' then
      walk_latch <= '1';
    elsif T='1' and (s=S1 or s=S3) then
      walk_latch <= '0'; -- 황색 끝에 클리어(예시)
    end if;
  end if;
end process;

-- 출력(PT 절약: 상태비트 사용)
G_NS <= '1' when s=S0 else '0';
Y_NS <= '1' when s=S1 else '0';
R_NS <= not (G_NS or Y_NS);

G_EW <= '1' when s=S2 else '0';
Y_EW <= '1' when s=S3 else '0';
R_EW <= not (G_EW or Y_EW);

WALK <= '1' when ((s=S0) or (s=S2)) and walk_latch='1' else '0';
```

**(c) 핀/타이밍 제약(예: Intel QSF 스타일)**
```tcl
set_location_assignment PIN_A1 -to clk
set_location_assignment PIN_B3 -to P
set_location_assignment PIN_D5 -to T
set_location_assignment PIN_F2 -to G_NS
# 타이밍: 간단 클럭 주기
create_clock -name {clk} -period 20.000 [get_ports clk]  ;# 50MHz
```

**PT 최적화 요령**
- 동일한 조건 묶기: `S0 or S2` 같은 항을 중간 신호로 **재사용**.  
- Mealy 대신 Moore로 출력 붙이면 곱항 수가 줄어드는 경우 다수.  
- 불필요한 else-branch 제거(합성기에게 don’t-care 여지 제공).

---

## 2) FPGA를 이용한 순서회로 설계

### 2.1 FPGA 아키텍처 빠른 개요
- **LUT + FF**가 슬라이스/ALM 단위로 복제.  
- **글로벌 클럭/분배**, **PLL/MMCM**, **Block RAM**, **DSP**(곱셈기), **SRL(시프트 LUT)** 등 풍부한 하드 자원.  
- **장점**: 대규모 파이프라인, FIFO/버퍼, 고속 DSP/인터페이스 적합.  
- **주의**: 클럭 도메인 다중(CDC), 리소스 맵핑(예: BRAM 깊이/폭), 타이밍 폐색.

### 2.2 예제: **UART Rx/Tx + FIFO** (FPGA 표준 교과 예제)

**목표**:  
- 50MHz 입력 클럭에서 `115200bps` UART **Rx/Tx**.  
- Rx는 16× 오버샘플링, FIFO 16×8.  
- Tx는 FIFO 언더런 시 idle.  
- 상위에 간단한 **레지스터 인터페이스**(메모리 맵: 상태/데이터) 제공.

#### (1) 상위 블록
```
[clk, rst] → [baud_gen] → {rx_fsm, tx_fsm}
                       ↘
                        [fifo_rx]→[reg_if]→CPU
CPU→[reg_if]→[fifo_tx]→tx_fsm→TXD
RXD→rx_fsm→fifo_rx
```

#### (2) Baud 생성기 (정수 분주: 50e6/115200≈434)
```vhdl
entity baud_gen is
  port (clk,rst: in std_logic; tick16: out std_logic); -- 16x tick
end;
architecture rtl of baud_gen is
  constant DIV : integer := 50_000_000 / (115_200*16); -- =27
  signal cnt: integer range 0 to DIV-1 := 0;
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then cnt<=0; tick16<='0';
      else
        tick16 <= '0';
        if cnt=DIV-1 then cnt<=0; tick16<='1';
        else cnt<=cnt+1;
        end if;
      end if;
    end if;
  end process;
end;
```

#### (3) UART Rx FSM (오버샘플·다수표본 다수결)
- **상태**: `IDLE`(start 검출) → `START`(중앙 샘플) → `DATA[0..7]` → `STOP`.  
- 각 비트는 16tick 중 중앙 3샘플을 다수결로 결정(잡음 내성).

```vhdl
-- 개략: 핵심 로직만
if tick16='1' then
  case s is
    when IDLE =>
      if rxd='0' then s<=START; sample_cnt<=0; end if;
    when START =>
      if sample_cnt=7 then  -- 중앙 접근
        if rxd='0' then s<=DATA0; bit_idx<=0; sample_cnt<=0;
        else s<=IDLE; end if;
      else sample_cnt<=sample_cnt+1; end if;
    when DATA0|DATA1|... =>
      -- 중앙 부근 3표본 누적 → majority
      if sample_cnt in 7..9 then sum <= sum + (rxd='1');
      end if;
      if sample_cnt=15 then
        data(bit_idx) <= '1' when sum>=2 else '0';
        bit_idx<=bit_idx+1; sum<=0; sample_cnt<=0;
        if bit_idx=7 then s<=STOP; end if;
      else sample_cnt<=sample_cnt+1; end if;
    when STOP =>
      if sample_cnt=15 then
        if rxd='1' then fifo_rx_write(data); else framing_err<='1'; end if;
        s<=IDLE; sample_cnt<=0;
      else sample_cnt<=sample_cnt+1; end if;
  end case;
end if;
```

#### (4) 간단 동기식 FIFO (16×8, 두 포인터 + full/empty)
```vhdl
entity fifo16x8 is
  port (clk,rst: in std_logic;
        wr: in std_logic; din: in std_logic_vector(7 downto 0);
        rd: in std_logic; dout: out std_logic_vector(7 downto 0);
        full, empty: out std_logic);
end;

architecture rtl of fifo16x8 is
  type ram_t is array(0 to 15) of std_logic_vector(7 downto 0);
  signal ram: ram_t; signal wptr,rptr: unsigned(3 downto 0) := (others=>'0');
  signal count: unsigned(4 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then wptr<=(others=>'0'); rptr<=(others=>'0'); count<=(others=>'0');
      else
        if wr='1' and full='0' then ram(to_integer(wptr)) <= din; wptr<=wptr+1; count<=count+1; end if;
        if rd='1' and empty='0' then dout <= ram(to_integer(rptr)); rptr<=rptr+1; count<=count-1; end if;
      end if;
    end if;
  end process;
  full  <= '1' when count=16 else '0';
  empty <= '1' when count=0  else '0';
end;
```

#### (5) Tx FSM
- `idle`에서 FIFO 비었으면 대기, 아니면 start(‘0’)→ 8data LSB→ stop(‘1’).

#### (6) XDC/SDC 타이밍 제약(예: 50MHz)
```tcl
create_clock -name sysclk -period 20.000 [get_ports clk]
set_input_delay  -clock sysclk 2.0 [get_ports rxd]
set_output_delay -clock sysclk 2.0 [get_ports txd]
# false-path 예(동기화 2FF 사이 외부칩 경로 없음)
set_false_path -from [get_ports rxd] -to [get_registers *|sync_ff*]
```

#### (7) CDC·리셋 주의
- `rxd`는 **2FF 동기화** 후 샘플(위 Rx FSM은 16× 내에서 동기화됨).  
- **비동기 리셋 해제**는 **클럭 동기**로(글리치/메타안정 방지).

---

## 3) 순서회로의 **시뮬레이션과 검사(Verification)**

### 3.1 시뮬레이션 수준
1) **기능(Behavioral)**: 합성 전. 빠름. 알고리즘 검증.  
2) **합성 후(넷리스트)**: 맵핑 반영.  
3) **배치배선 후 타이밍**: 실제 지연 SDF 주입. 느리지만 **경계 검증**.  
4) **하드웨어 인서킷 디버깅**: FPGA ILA/SignalTap, 칩 외부 로직아날라이저.

### 3.2 VHDL 테스트벤치 스켈레톤(의사 UART 루프백)
```vhdl
entity tb is end;
architecture sim of tb is
  signal clk: std_logic:='0'; signal rst: std_logic:='1';
  signal rxd, txd: std_logic:='1';
begin
  clk <= not clk after 10 ns;  -- 50MHz
  process begin wait for 100 ns; rst<='0'; wait; end process;

  -- DUT: uart_top (rx/tx/fifo/baud_gen 결합 모듈)
  -- port map (clk=>clk, rst=>rst, rxd=>rxd, txd=>txd, ...);

  -- Stimulus: 프레임 생성기
  process
    procedure send_byte(b: std_logic_vector(7 downto 0)) is
    begin
      rxd <= '0'; wait for 8680 ns; -- start(1/115200)
      for i in 0 to 7 loop
        rxd <= b(i); wait for 8680 ns;
      end loop;
      rxd <= '1'; wait for 8680 ns; -- stop
    end procedure;
  begin
    wait until rst='0';
    send_byte(x"55"); send_byte(x"AA"); send_byte(x"30");
    wait for 2 ms;
    assert false report "SIM DONE" severity failure;
  end process;

  -- 간단 어서션
  -- assert not framing_err report "Framing error" severity error;
end;
```

### 3.3 어서션/커버리지/포멀
- **어서션**(PSL/VHDL-assert): “Rx STOP에서 반드시 ‘1’이어야 한다” 등.  
- **커버리지**: 상태/전이/조건 커버 확인(모든 FSM 전이 타기).  
- **포멀 검증**: 안전성(락아웃 없음), Live(언젠가 IDLE 복귀) 등 속성 증명.

### 3.4 검사(Testing)
- **보드 레벨**: 루프백, 파형 캡처(UART TX→RX 혹은 외부 단말).  
- **온칩 로직 분석기**: 트리거 조건 `start_detect & bit_idx=3`. 내부 신호 추적.  
- **바운더리 스캔(JTAG)**: 핀 단선/단락 검사, 생산 시험.

---

## 4) **컴퓨터 이용 설계(CAD) 개요**

### 4.1 전형적 툴 플로우
```
사양/모델링
   ↓
HDL 코딩(VHDL/Verilog) & Lint
   ↓
시뮬(기능) + 어서션
   ↓
합성(Synthesis)  → 리포트(리소스/경로/클럭도메인)
   ↓
제약(핀/XDC/SDC, 타이밍, 멀티사이클/False Path)
   ↓
배치·배선(P&R)
   ↓
STA(Static Timing Analysis)  → 실패시 반복(리타이밍/파이프라인)
   ↓
비트스트림/JEDEC 생성 → 프로그래밍
   ↓
하드웨어 검증(ILA/SignalTap) + 타이밍 수렴
```

### 4.2 스크립팅/자동화(TCL/Make)
- **재현성**: 동일 결과, CI 연동.  
- **예시**: 빌드 스크립트에서 `set_param general.maxThreads 8` 등 환경 제어, `report_timing -max_paths 10` 저장.  
- **린팅**: clock enable 누락, latch 추론, 비동기 신호 직접 사용 경고.

### 4.3 제약 파일 개념
- **XDC/SDC**: `create_clock`, `set_input_delay`, `set_output_delay`, `set_false_path`, `set_multicycle_path`.  
- **QSF/UCF**: 핀/전기적(전압/드라이브).  
- **Best practice**: 모든 I/O에 **타이밍 모델**(상대 디바이스의 tCO/tSU) 반영.

### 4.4 타이밍 폐색과 개선
- **정수**: \(T_{clk}\ge T_{CQ} + t_{comb} + T_{SU}\).  
- **개선**: 파이프라인 삽입, 경로 분해(팬인↓), 리타이밍, 멀티사이클 선언(합당할 때만), 물리 제약(LOC, Pblock).  
- **FPGA 특화**: BRAM/DSP 매핑으로 일반 LUT 경로 제거, SRL로 시프트 구현.

### 4.5 전력/신뢰성
- **Clock Enable** 적극 사용(불필요 토글 억제).  
- **원-핫 FSM**: FF↑지만 조합 활동↓ → 전력 트레이드오프 평가.  
- **SEU 대응**: 안전 FSM 옵션, TMR(중요 로직), CRC/Watchdog.

---

## 5) CPLD vs FPGA **선택/코딩 스타일 비교**

| 항목 | CPLD | FPGA |
|---|---|---|
| 기본 구조 | AND-OR-FF(PLA 유사) | LUT-FF + BRAM/DSP |
| 강점 | 빠른 핀-핀, 글루/FSM 소형 | 대규모 병렬/파이프라인/메모리 |
| 제약 | Product Term 예산 | 타이밍 폐색·리소스 매핑 |
| 클럭 | 소수 글로벌, CE 권장 | 풍부한 글로벌/지역 클럭 |
| 스타일 | SOP 친화, 공통 곱항 공유 | 파이프라인/원-핫/리소스 지향 |
| 3-state | 내부 OE 풍부 | 내부 버스는 mux로, I/O만 3-state |

**공통 금기**: 게이티드 클럭, 비동기 조합 루프, 비등록 Mealy 출력 외부로 직접 연결.

---

## 6) 종합 체크리스트

- [ ] 비동기 입력 **2FF 동기화**, 에지검출은 동기 영역에서.  
- [ ] 상태표 **완전 기입**, ISM은 **닫힌 커버**·Self-start.  
- [ ] 상태할당: CPLD는 **이진/공유항**, FPGA는 **원-핫/그레이** 우선 고려.  
- [ ] 타이밍 제약(XDC/SDC) **필수**: 클럭/IO 지연/예외경로.  
- [ ] 시뮬: 기능→합성후→타이밍, 어서션/커버리지.  
- [ ] 하드웨어: ILA/SignalTap, 루프백/패턴테스트.  
- [ ] 전력: CE·Idle 처리, 불필요 토글 억제.  
- [ ] 문서화: 상태도/타이밍도/핀맵/제약/리포트 아카이브.

---

## 7) 마무리 요약
- **CPLD**는 PT·OE 중심의 **콤팩트 FSM/글루**에 최적, **SOP와 공통항 공유**가 성패.  
- **FPGA**는 **LUT/BRAM/DSP**를 살린 파이프라인/버퍼/프로토콜 설계가 핵심.  
- **시뮬·검사**는 기능→타이밍→온칩 디버깅의 3단계, 어서션과 커버리지/포멀을 병행.  
- **CAD 플로우**는 제약/스크립팅으로 **재현성과 타이밍 수렴**을 보장한다.
