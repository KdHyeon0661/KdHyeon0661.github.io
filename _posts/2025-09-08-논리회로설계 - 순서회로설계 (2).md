---
layout: post
title: 논리회로설계 - 순서회로설계 (2)
date: 2025-09-08 23:30:23 +0900
category: 논리회로설계
---
# 개요**

> 코드 블록은 ```…``` 사용, 수식은 MathJax(예: \(T_{CQ}+t_{comb}+T_{SU}\le T_{clk}\)). 가능한 한 **실무 예제**를 곁들여 “생략 없이” 정리했습니다.

---

## CPLD를 사용한 순서회로 설계

### CPLD 아키텍처 빠른 개요

- **매크로셀(Macrocell)**: AND-OR 가산기(PLA 유사) + 선택적 D-FF + 출력 이네이블(OE, 3-state).
- **Product Term(PT) 공유**: AND-plane에서 만든 곱항을 다수 매크로셀이 공유. **PT 예산이 주된 제약**.
- **클럭/리셋**: 전역 클럭 / 전역 비동기 Clear·Preset 제공이 흔함. **게이티드 클럭 금지**, **Clock Enable(CE)** 사용 권장.
- **I/O**: 내부 버스도 3-state로 직접 구동 가능(OE).
- **장점**: 짧고 결정론적 지연, 글루 로직·소형 FSM·간단 디코더 최적.
- **주의**: 내부 RAM/DSP 없음, 팬인↑→PT↑→적합(fit) 실패 위험.

**CPLD 내부 개념도(요지)**

```
     [Global CLK] ────────────────▶ [D-FF] ──▶ [I/O Pin]
       ↑                    ▲
AND plane → (Product terms) └→ OR sum ──→ MUX/OE ─→ 3-state buf
```

---

### CPLD 설계 플로우(요약)

1) **명세 → 상태도/표**(ISM이면 `–` 표시)
2) **최소화**(함의 차트/분할 정련) → **상태할당**(이진 권장: FF↓, PT 예상 쉬움)
3) **코딩 스타일**: SOP 친화(조건 **평탄화**, 공통 곱항 **공유**)
4) **제약**: 핀맵(QSF/UCF), 간단 타이밍(클럭 주기, I/O 지연)
5) **합성/적합** → **PT/핀/경로 리포트** 확인 → **리팩토링**(인수화, 공통항)
6) **기능/타이밍 시뮬** → **프로그래밍** → **현장 검증**(Logic Analyzer)

---

### 예제: **교차로 신호 FSM** (Moore, 보행 버튼 포함)

**요구사항**
- 입력: `P`(보행 버튼, 비동기), `T`(현재 신호 종료 타이머 완료 1펄스)
- 출력: `G_NS, Y_NS, R_NS, G_EW, Y_EW, R_EW, WALK`(서로 배타)
- 상태: `S0(북남-녹) → S1(북남-황) → S2(동서-녹) → S3(동서-황)` 반복
- 보행: 녹색 시작 시점에 `P`가 눌렸다면 **해당 녹색 구간 동안** `WALK=1` 유지

**CPLD 코딩 포인트**
- 비동기 입력은 **2FF 동기화 + 에지검출**
- 출력은 **상태비트**를 바로 사용(PT 절약)
- `WALK_EN = (S0 or S2) and P_latched` 같은 **공유 곱항**을 중간 신호로 재사용

**(a) 동기화/에지 검출 (2FF + one-shot)**
```vhdl
signal p_d1, p_d2, p_edge: std_logic := '0';
process(clk) begin
  if rising_edge(clk) then
    p_d1 <= P; p_d2 <= p_d1;        -- 2단 동기화
    p_edge <= (not p_d2) and p_d1;  -- 상승 에지 검출(one-shot)
  end if;
end process;
```

**(b) FSM (이진 상태, Moore)**
```vhdl
type S_t is (S0,S1,S2,S3);
signal s, ns: S_t := S0;
signal walk_latch: std_logic := '0';

-- 다음상태 조합
process(all) begin
  ns <= s;
  case s is
    when S0 => if T='1' then ns <= S1; end if;
    when S1 => if T='1' then ns <= S2; end if;
    when S2 => if T='1' then ns <= S3; end if;
    when S3 => if T='1' then ns <= S0; end if;
  end case;
end process;

-- 상태/보행 latch
process(clk, rst_n) begin
  if rst_n='0' then s<=S0; walk_latch<='0';
  elsif rising_edge(clk) then
    s <= ns;
    if (s=S0 or s=S2) and p_edge='1' then
      walk_latch <= '1';
    elsif T='1' and (s=S1 or s=S3) then
      walk_latch <= '0';  -- 황색 종료 시점 클리어(예)
    end if;
  end if;
end process;

-- 출력(상태 직접 사용: PT 절약)
G_NS <= '1' when s=S0 else '0';
Y_NS <= '1' when s=S1 else '0';
R_NS <= not (G_NS or Y_NS);

G_EW <= '1' when s=S2 else '0';
Y_EW <= '1' when s=S3 else '0';
R_EW <= not (G_EW or Y_EW);

WALK <= '1' when ((s=S0) or (s=S2)) and walk_latch='1' else '0';
```

**(c) 핀/타이밍 제약(예: QSF/TCL)**
```tcl
set_location_assignment PIN_A1 -to clk
set_location_assignment PIN_B3 -to P
set_location_assignment PIN_D5 -to T
set_location_assignment PIN_F2 -to G_NS
create_clock -name {clk} -period 20.000 [get_ports clk]  ;# 50MHz
```

**PT 최적화 요령**
- `S0 or S2` 같은 **반복 조건을 중간 신호로 공유**
- Moore 출력을 선호(간선(Mealy) 출력보다 PT가 적어지는 경우 다수)
- 불필요한 else 분기 제거 → 합성기에 **don’t-care** 여지 제공

---

## FPGA를 이용한 순서회로 설계

### FPGA 아키텍처 빠른 개요

- **LUT+FF**(슬라이스/ALM) + **BRAM**, **DSP**, **SRL(Shift Register LUT)**
- **글로벌/지역 클럭 네트워크**, PLL/MMCM
- **장점**: 대규모 파이프라인, 버퍼/FIFO, DSP, 고속 I/F 최적
- **주의**: 도메인 여럿(CDC), 리소스 맵핑, 타이밍 수렴

---

### 예제: **UART Rx/Tx + FIFO (115200bps @ 50MHz)**

**상위 블록**
```
[clk,rst] → [baud_gen] ──→ {rx_fsm, tx_fsm}
                      ↘
                       [fifo_rx] → [reg_if] → CPU
CPU → [reg_if] → [fifo_tx] → tx_fsm → TXD
RXD → rx_fsm → fifo_rx
```

**(1) Baud 16× Tick 생성 (정수 분주)**
```vhdl
entity baud_gen is
  port (clk,rst: in std_logic; tick16: out std_logic);
end;
architecture rtl of baud_gen is
  constant DIV : integer := 50_000_000 / (115_200*16); -- 27
  signal cnt: integer range 0 to DIV-1 := 0;
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then cnt<=0; tick16<='0';
      else
        tick16 <= '0';
        if cnt=DIV-1 then cnt<=0; tick16<='1';
        else cnt<=cnt+1;
        end if;
      end if;
    end if;
  end process;
end;
```

**(2) UART Rx FSM (16× 오버샘플, 다수결)**
- 상태: `IDLE`(start 감시) → `START` → `DATA[0..7]` → `STOP`
- 중앙 3샘플 다수결로 잡음 내성↑

```vhdl
-- 핵심 로직 스케치(완전 동작 TB와 함께 검증 권장)
-- sample_cnt: 0..15, 중앙 7~9 샘플 합(sum)≥2 → '1'
```

**(3) 동기 FIFO 16×8**
```vhdl
entity fifo16x8 is
  port (clk,rst: in std_logic;
        wr: in std_logic; din: in std_logic_vector(7 downto 0);
        rd: in std_logic; dout: out std_logic_vector(7 downto 0);
        full, empty: out std_logic);
end;
architecture rtl of fifo16x8 is
  type ram_t is array(0 to 15) of std_logic_vector(7 downto 0);
  signal ram: ram_t; signal wptr,rptr: unsigned(3 downto 0) := (others=>'0');
  signal count: unsigned(4 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then wptr<=(others=>'0'); rptr<=(others=>'0'); count<=(others=>'0');
      else
        if wr='1' and full='0' then ram(to_integer(wptr)) <= din; wptr<=wptr+1; count<=count+1; end if;
        if rd='1' and empty='0' then dout <= ram(to_integer(rptr)); rptr<=rptr+1; count<=count-1; end if;
      end if;
    end if;
  end process;
  full  <= '1' when count=16 else '0';
  empty <= '1' when count=0  else '0';
end;
```

**(4) Tx FSM**
- FIFO 비었으면 idle, 아니면 `start(0) → 8 data LSB → stop(1)`

**(5) XDC/SDC 제약(50MHz)**
```tcl
create_clock -name sysclk -period 20.000 [get_ports clk]
set_input_delay  -clock sysclk 2.0 [get_ports rxd]
set_output_delay -clock sysclk 2.0 [get_ports txd]
# CDC 동기화 레지스터 사이 false path

set_false_path -from [get_ports rxd] -to [get_registers *|sync_ff*]
```

**(6) FPGA 특화 팁**
- 시프트는 **SRL**로, 대용량 버퍼는 **BRAM**으로, 곱셈/누산은 **DSP**로 맵핑
- FSM은 **원-핫**(fmax↑) 또는 **그레이**(해밍1 전이, 글리치↓)
- 내부 버스는 **3-state 금지**(MUX로 구현)

---

### CDC(Clock Domain Crossing)와 메타안정성(Metastability)

- **2FF 동기화**: 비동기 단일 비트 신호는 2~3단 플립플롭 직렬
- **토글/펄스 동기화**: 토글 플롭 + 에지 검출
- **비동기 FIFO**: **그레이 코드 포인터** + 듀얼포트 RAM (쓰기/읽기 독립 클럭)

**메타안정성 MTBF 근사**
\[
\mathrm{MTBF} \approx \frac{e^{(T_{\text{resolve}}/\tau)}}{f_{\text{clk}}\cdot f_{\text{data}}\cdot C}
\]
- \(T_{\text{resolve}}\): 동기화 체인의 해결 시간(단 수↑→↑)
- \(\tau\): 공정 상수, \(f_{\text{clk}}, f_{\text{data}}\): 클럭/데이터 토글 주파수
→ **동기화 단계 추가**·**플롭 물리적 근접 배치**로 MTBF↑

**XDC 예(비동기 그룹 선언)**
```tcl
set_clock_groups -asynchronous -group {rx_clk} -group {sysclk}
```

---

## 순서회로의 **시뮬레이션과 검사(Verification)**

### 시뮬레이션 수준

1) **기능(Behavioral)**: 합성 전, 빠름. 알고리즘/FSM 논리 검증.
2) **합성 후(넷리스트)**: 맵핑 반영.
3) **배치·배선 후 타이밍**: SDF 백주입(실제 지연). 경계 케이스 검증.
4) **실장 후 디버깅**: FPGA ILA/SignalTap, 외부 로직아날라이저.

### 테스트벤치 스켈레톤(의사 UART 루프백)

```vhdl
entity tb is end;
architecture sim of tb is
  signal clk: std_logic:='0'; signal rst: std_logic:='1';
  signal rxd, txd: std_logic:='1';
begin
  clk <= not clk after 10 ns;  -- 50MHz
  process begin wait for 100 ns; rst<='0'; wait; end process;

  -- DUT 인스턴스 (rx/tx/fifo/baud_gen 결합)
  -- uart_top_inst: uart_top port map (clk=>clk, rst=>rst, rxd=>rxd, txd=>txd, ...);

  -- Stimulus: 프레임 생성
  process
    procedure send_byte(b: std_logic_vector(7 downto 0)) is
    begin
      rxd <= '0'; wait for 8680 ns; -- start
      for i in 0 to 7 loop
        rxd <= b(i); wait for 8680 ns;
      end loop;
      rxd <= '1'; wait for 8680 ns; -- stop
    end procedure;
  begin
    wait until rst='0';
    send_byte(x"55"); send_byte(x"AA"); send_byte(x"30");
    wait for 2 ms;
    assert false report "SIM DONE" severity failure;
  end process;

  -- 간단 어서션 예
  -- assert (framing_err='0') report "Framing error" severity error;
end;
```

### 어서션·커버리지·포멀

**SVA 예(Stop=1 보장)**
```systemverilog
property p_stop_high;
  @(posedge clk) disable iff (rst)
    (rx_state==STOP && tick16) |-> rxd;
endproperty
assert property(p_stop_high);
```

**커버리지**
- 상태/전이/조건 커버리지 확보(모든 전이 타기)
- 에러 주입(패리티/프레이밍 오류)로 ERR 경로 커버

**포멀 검증 아이디어**
- Safety: “락아웃 상태 없음”, “동시에 G_NS=1 ∧ G_EW=1 금지”
- Liveness: “언젠가 IDLE 복귀”, “TX FIFO 비면 일정 시간 내 idle 진입”

---

## 개요**

### 전형적 툴 플로우

```
사양/모델링
   ↓
HDL 코딩(VHDL/Verilog) & Lint
   ↓
기능 시뮬 + 어서션(SVA/PSL)
   ↓
합성(Synthesis) → 리포트(리소스/경로/CDC)
   ↓
제약(XDC/SDC, 핀/QSF, 전기/IO 표준)
   ↓
배치·배선(P&R)
   ↓
정적 타이밍(STA)  → 실패 시 리타이밍/파이프라인/제약 갱신
   ↓
비트/JEDEC 생성 → 프로그래밍
   ↓
하드웨어 검증(ILA/SignalTap) → 타이밍 수렴
```

### 스크립팅/자동화(TCL/Make/CI)

- **재현성**: 버전고정·배치 모드 빌드
- **예시**:
  ```tcl
  # 빌드 스냅샷/주요 리포트 자동 저장
  report_timing -max_paths 20 -file timing_max.rpt
  report_utilization -file util.rpt
  ```

### 제약 파일 핵심

- **클럭**: `create_clock`, **파생 클럭**: `create_generated_clock`
- **I/O 지연**: `set_input_delay`, `set_output_delay` (상대 디바이스 tCO/tSU 반영)
- **예외 경로**: `set_false_path`, `set_multicycle_path`
- **CDC**: `set_clock_groups -asynchronous`
- **물리 제약**: 핀 LOC, 영역 제약(Pblock)

### 타이밍 폐색과 개선

- **기본 불등식**
  \[
  T_{clk} \ge T_{CQ} + t_{comb} + T_{SU},\qquad  t_{hold} \le t_{CD}
  \]
- **개선책**: 파이프라인 삽입, 리타이밍, 팬인 분해, 멀티사이클(정당할 때만), 물리 근접 배치
- **FPGA 특화**: BRAM/DSP 맵핑, SRL 사용, 긴 버스는 레지스터 슬라이싱

### 전력/신뢰성/안전

- **Clock Enable** 적극 사용(불필요 토글 억제)
- **원-핫 FSM**: FF↑이나 조합 활동↓ → 전력 트레이드오프
- **SEU 대응**: Safe FSM, TMR(핵심 경로), CRC/Watchdog
- **RDC(Reset Domain Crossing)**: 비동기 리셋 **동기 해제**, 리셋 릴리스 타이밍 검사

---

## CPLD vs FPGA **선택/코딩 스타일 비교**

| 항목 | CPLD | FPGA |
|---|---|---|
| 기본 구조 | AND-OR-FF(PLA 유사) | LUT-FF + BRAM/DSP |
| 강점 | 빠른 핀-핀, 글루/FSM 소형 | 대규모 병렬/파이프라인/메모리 |
| 주 제약 | Product Term 예산 | 타이밍 폐색·리소스 맵핑 |
| 클럭 정책 | 소수 글로벌, CE 권장 | 풍부한 글로벌/지역 클럭 |
| 내부 버스 | 3-state(OE) 허용 | 내부는 MUX, I/O만 3-state |
| FSM 스타일 | 이진/공통 곱항 공유 | 원-핫·그레이·파이프라인 |

**공통 금기**: 게이티드 클럭, 비등록 Mealy 출력의 외부 직결, 조합 루프.

---

## 추가 실무 예제 모음

### CPLD: **버스 중재(2마스터)** — PT 절약형

```vhdl
-- 간단 라운드로빈 중재기(요지). OE와 chip-select에 바로 연결하기 좋도록 SOP로 평탄화.
grant0 <= (req0 and not req1) or (req0 and req1 and last='1');
grant1 <= (req1 and not req0) or (req0 and req1 and last='0');
process(clk, rst_n) begin
  if rst_n='0' then last<='0';
  elsif rising_edge(clk) then
    if grant0='1' then last<='0';
    elsif grant1='1' then last<='1';
    end if;
  end if;
end process;
```

### 핵심**

```verilog
// 쓰기/읽기 포인터 Gray 변환
assign wptr_gray = (wptr_bin>>1) ^ wptr_bin;
assign rptr_gray = (rptr_bin>>1) ^ rptr_bin;

// 상대 도메인으로 2FF 동기화
always @(posedge rclk) {wgray_q2,wgray_q1} <= {wgray_q1,wptr_gray};
always @(posedge wclk) {rgray_q2,rgray_q1} <= {rgray_q1,rptr_gray};

// full/empty 판정(상대 포인터 비교)…
```

---

## 종합 체크리스트

- [ ] **비동기 입력** 2FF 동기화, 토글/펄스는 전용 동기화 사용
- [ ] **상태표 완전 기입**, ISM은 **닫힌 커버**·Self-start
- [ ] **상태할당**: CPLD는 이진·공통 곱항 공유, FPGA는 원-핫/그레이 우선 고려
- [ ] **타이밍 제약(XDC/SDC)**: 클럭·I/O 지연·예외 경로 필수
- [ ] **시뮬**: 기능→합성후→타이밍(SDF), 어서션·커버리지·에러 주입
- [ ] **하드웨어**: ILA/SignalTap 트리거, 루프백·패턴테스트
- [ ] **전력**: CE·Idle 처리, 불필요 토글 억제
- [ ] **신뢰성**: 메타안정 MTBF 고려, Safe FSM/TMR, 리셋 동기 해제
- [ ] **문서화**: 상태도/타이밍도/핀맵/제약/리포트 아카이브

---

## 맺음말

- **CPLD**는 PT·OE 중심의 **콤팩트 FSM/글루**에 최적이며, **SOP 평탄화와 공통항 공유**가 성패를 가른다.
- **FPGA**는 **LUT/BRAM/DSP**를 살린 **파이프라인·버퍼·프로토콜** 설계가 핵심이며, **CDC/타이밍 수렴**이 성공의 절반이다.
- **시뮬·검사**는 기능→타이밍→온칩 디버깅의 3단, **어서션/커버리지/포멀**로 품질을 보증한다.
- **CAD 플로우**는 제약과 스크립팅으로 **재현성**과 **타이밍 수렴**을 확보하라.
