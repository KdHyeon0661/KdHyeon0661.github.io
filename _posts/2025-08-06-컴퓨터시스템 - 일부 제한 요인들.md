---
layout: post
title: 컴퓨터시스템 - 일부 제한 요인들
date: 2025-08-06 14:20:23 +0900
category: 컴퓨터시스템
---
# 일부 제한 요인들 (Performance Limiters in Program Optimization)

## 큰그림 요약

- **항상 먼저 측정**: `perf stat` + 샘플링 프로파일(플레임그래프) + I/O/락/GC/페이지 폴트.
- **상한부터 계산**: Amdahl/Little/Roofline → “여기 이상은 불가”를 먼저 안다.
- **핫패스 10%**만 겨냥: 호출 제거·타일링·SoA·락 샤딩·배치 I/O.
- **작게 바꾸고 재측정**: 중앙값+p95, 95% CI, 회귀 알람.
- **병목은 이동한다**: 한 구간 개선 후 다음 구간으로 반복.

---

## 성능 한계 분석 (Performance Bottleneck Analysis)

### 왜 분석이 먼저인가?

직감은 틀리기 쉽다. 전체 시간에서 30%만 차지하는 구간에 **무한대 속도 향상**을 주어도 전체 속도향상은 최대 \(1/(0.7+0) \approx 1.43\times\) (Amdahl).
**증거 기반**으로만 움직인다.

### 제한 요인 표(확장판)

| 제한 요인 | 전형적 원인 | 신호(카운터/지표) | 1차 도구 |
|---|---|---|---|
| **메모리 지연** | DRAM 왕복, TLB 미스 | IPC<1, LLC-miss↑, dTLB-miss↑ | `perf stat`, cachegrind |
| **메모리 대역폭** | 대용량 스트리밍 | BW 포화(STREAM), LLC-miss 높지만 규칙적 | VTune/Advisor, `numastat` |
| **ILP 한계** | 데이터 의존, 포트 압박 | stalled-backend, 포트유틸 불균형 | VTune Port Analysis |
| **분기 미스** | 불규칙 조건/패턴 | branch-misses↑, mispredict%↑ | `perf stat`, `perf record` |
| **레지스터 압박** | 과도한 언롤/인라인 | 스필/필 증가, L1D 로드↑ | 컴파일러 레포트(`-fopt-info`) |
| **프런트엔드 한계** | 디코더 폭, μop 캐시 미스, I$ 미스 | stalled-frontend↑, icache-misses↑ | VTune Frontend |
| **스토어-포워딩 실패** | 치환/정렬 불일치 | ld_block, store_forward_block↑ | VTune Memory |
| **동기화/락** | 핫락/긴 크리티컬 섹션 | `perf lock`, run queue↑ | `perf lock`, bpftrace |
| **폴스 셰어링** | 동일 라인 공유 쓰기 | LLC miss와 코어 간 invalid↑ | VTune/PCM |
| **I/O 병목** | 랜덤 I/O/네트워크 RTT | iowait↑, syscalls↑ | `iostat -xz`, `strace -c` |
| **NUMA** | 원격노드 메모리 | remote access↑, numastat 불균형 | `numastat`, `numactl -H` |
| **링킹/PLT/GOT** | DSO 경유 잦음 | 간접호출 비중↑ | `perf report` 심볼 |
| **보안 완화** | retpoline, L1TF, IBRS | syscall/indirect 비용↑ | `lscpu` flags, `dmesg` |
| **전력/주파수** | 스로틀링, SMT 간섭 | 주파수↓, IPC 변동↑ | `turbostat`, `smt` |

---

## 메모리 접근 지연 (Memory Latency)

### 현상과 모델

- L1 히트: 수~10여 사이클, L3: 수십 사이클, DRAM: 수백 ns.
- 평균 접근 시간(AMAT):
$$
\text{AMAT} = T_{L1} + m_1\big(T_{L2} + m_2\big(T_{L3} + m_3 T_\text{Mem}\big)\big)
$$
\(m_k\): 미스율. 작은 \(m_k\) 상승도 DRAM 페널티로 **폭증**.

### 실전 전략

- **로컬리티**: 행우선 순회, **타일링(블로킹)**.
- **데이터 레이아웃**: AoS→**SoA**, 패딩으로 세트 충돌 완화.
- **프리패치**: 규칙적 패턴에서 `__builtin_prefetch(ptr+d, 0, 1)`.

```c
// 행우선 vs 열우선
int sum_row(int (*a)[N]){int s=0;for(int i=0;i<N;i++)for(int j=0;j<N;j++)s+=a[i][j];return s;}
int sum_col(int (*a)[N]){int s=0;for(int j=0;j<N;j++)for(int i=0;i<N;i++)s+=a[i][j];return s;}
```

---

## 제한된 ILP (Instruction-Level Parallelism)

### 의존성과 포트 압박

- **RAW/WAR/WAW** 의존으로 파이프라인 간격 요구.
- 실행 포트(곱셈/나눗셈/로드/스토어)가 **특정 포트**에 몰리면 **포트 압박** 발생 → 백엔드 스톨.

### 개선

- **의존 체인 단절**: 누적 2개로 **트리 리덕션**.
- **언롤**: 독립 로드·계산을 병렬로.
- **강도 감소**: `x*8` → `x<<3`.

```c
// 누적 2개로 ILP↑
double dot(const double* a,const double* b,int n){
  double s0=0,s1=0; int i=0;
  for(; i+1<n; i+=2){ s0+=a[i]*b[i]; s1+=a[i+1]*b[i+1]; }
  if(i<n) s0+=a[i]*b[i];
  return s0+s1;
}
```

---

## 분기 예측 실패 (Branch Misprediction)

### 비용

최신 코어에서 **미스 1회**는 수십 사이클 손실(파이프라인 플러시).

### 전략

- **브랜치리스**(마스크/테이블), **히트 경로**를 **fall-through**로 정렬.
- **데이터 정렬**: 정렬된 키/분포 기반으로 분기 확률 안정화.

```c
// branchless clamp
static inline int clamp_i32(int x,int lo,int hi){
  int xlo=x-lo, xhi=hi-x; int s1=xlo>>31, s2=xhi>>31;
  return (x&~s1&~s2) | (lo&s1) | (hi&s2);
}
```

---

## 레지스터 압박 (Register Pressure)

### 징후

- 스필/필 증가 → L1 로드/스토어↑, IPC↓.
- 과도한 인라인·언롤·벡터화가 원인일 수 있다.

### 대응

- **언롤 팩터**를 계측 기반으로 선택.
- **불필요 변수 제거**, **스칼라 치환**으로 중복 로드 제거.
- 컴파일러 리포트 확인: `-fopt-info-vec-optimized -fopt-info-vec-missed`.

```c
// 스칼라 치환으로 동일 원소 재사용
for(int i=0;i<n;i++){ float xi=x[i], yi=y[i]; y[i]=yi + a*xi; }
```

---

## 메모리 대역폭 (Memory Bandwidth)

### Roofline

$$
\text{Perf} \le \min(\text{Peak FLOPs},\ \text{AI}\cdot \text{BW}),\quad
\text{AI}=\frac{\text{FLOPs}}{\text{Bytes}}
$$
SAXPY(2 FLOPs / 24B) → \(AI\approx 0.083\ \text{FLOP/B}\) → **메모리 바운드**.

### 전략

- **벡터화/집약도↑**: 같은 바이트로 더 많은 연산.
- **압축/경량 포맷**(실측 필수), **NUMA 병렬 채널 활용**.
- **non-temporal store**: 한 번 쓰고 안 볼 큰 결과 버퍼는 캐시 오염 최소화.

---

## 프런트엔드 한계(Decode/μop Cache/I$)

### 징후

- `stalled-cycles-frontend`↑, `icache-misses`↑, μop 캐시 미스.
- **코드 팽창**(과인라인·과언롤) → I$ 압박.

### 전략

- **핫패스만 인라인**, 콜드 경로 분리(`__attribute__((cold))`).
- **루프 본문 슬림화**, 테이블/상수는 **const restrict** 포인터 전달.
- **LTO+PGO**로 **진짜 핫함수만** 인라인.

---

## 스토어-포워딩 실패(Store Forwarding Fail)

### 현상

- 바로 직전 저장한 데이터를 다른 크기/정렬로 즉시 읽을 때 **정렬 불일치**로 차단.

### 회피

- **정렬 유지**, 같은 크기 타입으로 로드/스토어.
- 구조체 패킹을 피하고 `_Alignas(16/32/64)`로 정렬 보장.

```c
typedef struct { _Alignas(16) float x,y,z,w; } v4f;
```

---

## 동기화 오버헤드 & 폴스 셰어링

### 락 경합

- **샤딩**(파티션 락), **RW락**, **락 범위 축소**, **락 없는 큐**(SPSC).

```c
#define P 64

typedef struct { _Alignas(64) long v; } pad64;
static pad64 cnt[P]; // 스레드별 샤드
void add(int tid,long x){ cnt[tid].v += x; }
long total(){ long s=0; for(int i=0;i<P;i++) s+=cnt[i].v; return s; }
```

### 폴스 셰어링

- 서로 다른 변수가 같은 캐시라인을 공유하여 **무효화 폭주**.
- **패딩**·**라인 정렬**로 격리.

---

## NUMA, TLB, 페이지 폴트

### NUMA

- **First-touch**: 쓰는 스레드가 속한 노드로 페이지 할당.
- `numactl --hardware`, `numastat`로 분포 확인.

```c
#pragma omp parallel for

for (long i=0;i<n;i++) a[i]=0; // 각 스레드가 자기 파티션을 초기화
```

### TLB

- **TLB reach** \(=\text{entries}\times\text{page size}\) < 워킹셋 → dTLB-miss↑.
- **Huge page**(2MB/1GB)로 reach↑, 단편화·권한 고려.

---

## I/O 병목 (디스크·네트워크)

### 진단

- `iostat -xz`, `strace -c`에서 syscalls 증가, iowait↑.

### 전략

- **배치 I/O**: `readv/writev`, **비동기**(io_uring).
- **순차화**: 랜덤 → 머지/버퍼링으로 스트리밍.
- **압축 레벨 실측**: Zstd L6→L3로 CPU↔BW 균형.

```c
// writev: 수천 번 write → 1회
#include <sys/uio.h>

ssize_t flush_many(int fd, struct iovec *iov, int n){ return writev(fd, iov, n); }
```

---

## 링커·PLT/GOT·PIC·인터포지션

- **공유 라이브러리 경유(PLT/GOT)** 간접 비용, 자주 호출되는 심볼은 **정적 링크 or 내부화** 고려.
- **인터포지션**(심볼 교체) 가능성이 꺼지면 인라이닝·최적화 여지가 커진다(환경·정책 확인).
- **PIC** 코드 오버헤드가 민감 루프에 영향을 줄 수 있음(일반적으론 미미, **측정**).

---

## 보안 완화(스펙터·멜트다운) 오버헤드

- **retpoline/IBRS**: 간접분기/시스템콜 비용 증가.
- 민감 워크로드는 완화를 끄는 대신 **대체 설계**(배치 I/O, 콜 수 감소)로 상쇄.
- 시스템 정책상 끄지 못하는 경우가 많으므로 **호출 횟수 자체**를 줄인다.

---

## 컴파일러·링커 최적화(PGO/LTO/옵션)

### 빌드 플래그

- 기본: `-O3 -march=native -flto`
- 레포트: `-fopt-info-vec -fopt-info-inline`
- **PGO**(GCC 예)
```bash
# 프로파일 빌드

gcc -O3 -fprofile-generate -march=native app.c -o app.pgo.gen
./app.pgo.gen <train_input>
# 프로파일 사용 빌드

gcc -O3 -fprofile-use -fprofile-correction -flto -march=native app.c -o app
```
- 헤더 **`static inline`** 도우미 + LTO 로 **TU 간 인라인**.

---

## GPU/가속기 한계(간단히)

- **PCIe 전송**, **커널 런치 지연**, **작은 배치**로 처리량 저하.
- 전략: **배치 키우기**, **파이프라인**(H2D, 커널, D2H 겹치기), **고정버퍼**.

---

## 측정·검증(필수 절차)

### 최소 측정 템플릿(C)

```c
#include <time.h>

double now(){ struct timespec t; clock_gettime(CLOCK_MONOTONIC,&t);
              return t.tv_sec + t.tv_nsec*1e-9; }
```

### 하드웨어 카운터

```bash
perf stat -e cycles,instructions,IPC,branches,branch-misses,\
L1-dcache-loads,L1-dcache-load-misses,LLC-load-misses,\
dTLB-loads,dTLB-load-misses,stalled-cycles-frontend,stalled-cycles-backend \
./program
```

### 플레임그래프(요지)

```bash
perf record -F 997 -g -- ./program
perf report
```

### 결과 보고 양식

- **성능**: `T_old → T_new (−X%)`, p50/p95, 처리량.
- **원인**: “SoA+타일링 → LLC-miss −36%, IPC 0.71→1.12”.
- **증거**: `perf stat/report` 숫자·스택.
- **부수효과**: 이진 크기/메모리/빌드시간 변화.
- **리스크**: 수치 정확·ABI·부동소수점 재배열.

---

## 제한 요인별 “전/후” 미니 예제

### 메모리 지연: 프리패치+타일링

```c
void sum_prefetch(const float *a,int n){
  float s=0;
  for (int i=0;i<n;i+=64){
    __builtin_prefetch(&a[i+256], 0, 1);
    for(int k=0;k<64 && i+k<n;k++) s += a[i+k];
  }
  (void)s;
}
```

### ILP: 독립 누적 두 갈래

```c
double sum2(const double* x,int n){
  double s0=0,s1=0; int i=0;
  for(; i+1<n; i+=2){ s0+=x[i]; s1+=x[i+1]; }
  if(i<n) s0+=x[i];
  return s0+s1;
}
```

### 분기: 브랜치리스 ReLU

```c
static inline int relu_i32(int x){ int m=x>>31; return (x^m)-m; }
```

### 레지스터 압박: 언롤 과다 ↓

```c
// before: 8× 언롤 → 스필↑
// after: 2×로 낮추고 벡터화 유지 → L1 로드↓, IPC↑ (실측으로 결정)
```

### I/O: writev 배치

```c
struct iovec v[NPARTS]; // ... fill
ssize_t n = writev(fd, v, NPARTS);
```

### 락: 샤딩 + 패딩

```c
typedef struct { _Alignas(64) long v; } pad64;
static pad64 sum[64];
```

---

## “증상→추측→5분 확인” 매핑표

증상 | 빠른 추측 | 5분 실험 | 기대 결과
---|---|---|---
IPC<1 & LLC-miss↑ | 메모리 바운드 | 행-주도 순회로 샘플 교체 | 시간↓, LLC-miss↓
branch-miss↑ | 불규칙 분기 | 브랜치리스 한 지점 적용 | mispredict↓, 시간↓
락 대기↑ | 핫락 | 동시성 절반/샤딩 적용 | p95↓
iowait↑ | I/O 병목 | `writev` 배치 경로로 스왑 | syscalls↓, MB/s↑
dTLB-miss↑ | TLB 부족 | Huge page 설정 | dTLB-miss↓, 시간↓

---

## 케이스 스터디(축약)

- **온라인 서비스 p95 −30%**: DAO 합치기(쿼리 7→1), JSON 변환 배치, 60s 캐시.
  p95 320→210ms, DB RPS −55%, CPU −18%.
- **CSV→Parquet 처리량 +2.6×**: SoA 파서+타일 1MB, Zstd 6→3, `writev`.
  120→310MB/s, 압축률 −6%(수용).
- **수치 루프 1.8×**: AoS→SoA, `restrict`, 언롤 2×, 브랜치 제거.
  IPC 0.6→1.3, LLC-miss 30%→11%.

---

## 수식 모음(상한선)

- **Amdahl**
  $$
  \text{Speedup}=\frac{1}{(1-p)+\frac{p}{s}}
  $$
- **Little**
  $$
  L=\lambda W,\quad W_q\approx\frac{\rho}{\mu(1-\rho)}
  $$
- **Roofline**
  $$
  \text{Perf}\le \min(\text{PeakFLOPs},\ \text{AI}\cdot \text{BW}),\quad
  \text{AI}=\frac{\text{FLOPs}}{\text{Bytes}}
  $$

---

## ASCII 다이어그램(개념 정리)

```
[Decode/μop$] --(μops)--> [Sched/Ports] --(exec)--> [L1D/L2] --(miss)--> [LLC] --(miss)--> [DRAM]
   ^   |                        |            |              |                          |
   |   +-- I$ miss              +-- Port압박/의존          +-- 충돌/용량               +-- 대역/지연
```

---

## 실험 자동화 스니펫(셸)

```bash
#!/usr/bin/env bash

APP=${1:-./program}
RUN="$APP ${@:2}"

echo "[perf stat]"
perf stat -e cycles,instructions,IPC,branches,branch-misses,\
L1-dcache-load-misses,LLC-load-misses,dTLB-load-misses,\
stalled-cycles-frontend,stalled-cycles-backend -- $RUN 2>&1 | tee perf.stat.txt

echo "[profile]"
perf record -F 997 -g -- $RUN
perf report --stdio | tee perf.report.txt

echo "[syscalls]"
strace -c $RUN 2>&1 | tee strace.c.txt

echo "[disk]"
(iostat -xz 1 & pid=$!; sleep 5; kill $pid) | tee iostat.txt
```

---

## 체크리스트 (실무용)

- [ ] 목표 지표(p95/처리량/비용) **숫자**로 고정.
- [ ] 플레임 Top 10 함수/경로 확인.
- [ ] Amdahl/Little/Roofline 상한 계산.
- [ ] **메모리 패턴**: 행-주도·타일·SoA?
- [ ] **벡터화**: `restrict`/정렬/분기 제거?
- [ ] **락/큐 경합**: 샤딩/RW락/배압?
- [ ] **I/O**: 배치/비동기/순차화?
- [ ] **NUMA/TLB**: first-touch/Huge page 바인딩?
- [ ] **프런트엔드**: 과인라인/언롤로 I$ 압박?
- [ ] 변경은 **하나씩**, 중앙값+p95·95% CI로 재측정?

---

## 결론

최적화는 **무조건 빨라지는 마법**이 아니라, **현재 시스템의 제한 요인**을 찾아 **증거로 제거**하는 과정이다.
핵심은:
1) **측정**으로 병목을 규명하고,
2) **상한을 계산**해 헛수고를 줄이며,
3) **데이터 이동·경합·프런트엔드/백엔드 정체**를 각각의 기술로 줄이고,
4) **작은 변경→재측정**을 반복하는 것이다.
이 플레이북을 적용하면, 메모리·ILP·분기·레지스터·대역폭·동기화·I/O **어느 병목이든** 원인과 처방을 명확히 연결해 실전에서 **지속적으로** 성능을 높일 수 있다.
