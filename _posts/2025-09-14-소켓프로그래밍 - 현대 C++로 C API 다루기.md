---
layout: post
title: 소켓프로그래밍 - 현대 C++로 C API 다루기
date: 2025-09-14 15:25:23 +0900
category: 소켓프로그래밍
---
# C++23 준비물 — 현대 C++로 C API 다루기

> 목표: POSIX 소켓(C API)을 **C++23 스타일**(RAII, `std::expected`, `std::span<std::byte>`, `std::string_view`, `std::print`, `std::chrono`)로 감싸  
> **안전성·가독성·관측성**을 확보하는 전체 흐름을 단계별로 정리한다.  
> 포인트:  
> - **누수 없는 자원 관리(RAII)**  
> - **명시적 오류 흐름(`std::expected`)**  
> - **바이트/문자열 경계 명확화(`std::byte` / `std::span` / `std::string_view`)**  
> - **시간·로그 표준화(`std::chrono` / `std::print`)**

---

## 0. 전통 C 소켓 코드의 문제와 C++23의 방향

먼저 “왜 굳이 C++23 스타일로 감싸야 하는가?”를 짚고 간다.

### 0.1 전통 C 스타일 소켓 코드의 전형적인 문제

아주 전형적인 C식 TCP 클라이언트 코드를 보자.

```c
// legacy_client.c - 전통 C 스타일 (문제점 설명용)
int legacy_client(const char *host, uint16_t port, const char *msg) {
    int s = socket(AF_INET, SOCK_STREAM, 0);
    if (s < 0) {
        perror("socket");
        return -1;
    }

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof addr);
    addr.sin_family = AF_INET;
    addr.sin_port   = htons(port);
    if (inet_pton(AF_INET, host, &addr.sin_addr) <= 0) {
        perror("inet_pton");
        close(s);
        return -1;
    }

    if (connect(s, (struct sockaddr*)&addr, sizeof addr) < 0) {
        perror("connect");
        close(s);
        return -1;
    }

    size_t len = strlen(msg);
    if (send(s, msg, len, 0) != (ssize_t)len) {
        perror("send");
        close(s);
        return -1;
    }

    char buf[1024];
    ssize_t n = recv(s, buf, sizeof buf, 0);
    if (n < 0) {
        perror("recv");
        close(s);
        return -1;
    }

    fwrite(buf, 1, n, stdout);
    fputc('\n', stdout);
    close(s);
    return 0;
}
```

겉으로는 단순해 보이지만, 실전에서는 문제가 많다.

- **자원 수명 관리가 코드 곳곳에 흩어져 있음**
  - `close(s)` 호출이 여러 곳에 반복된다.
  - 중간에 `return`이 하나만 더 들어가도 누수가 생기기 쉽다.
- **오류 흐름이 `int` 리턴값 + `errno` + `perror`에 의존**
  - 함수 합성이 어렵고, 재사용성이 떨어진다.
  - 호출한 쪽에서 `errno`를 언제 읽어야 하는지 헷갈리기 쉽다.
- **부분 입출력(Partial I/O)을 무시**
  - `send`가 한 번에 모두 보내준다고 가정한다.
  - 네트워크가 느리거나 커널 버퍼가 가득 찬 경우엔 틀린 가정이다.
- **바이트/문자열의 경계가 모호**
  - `char*`를 동시에 “텍스트”이자 “바이트 배열”로 쓰며, 서명/엔디안 문제를 그대로 안고 간다.
- **시간·타임아웃·로그 정책이 제각각**
  - `perror` 기반 로그는 포맷이 일정하지 않다.
  - 타임아웃을 넣으려면 각 함수마다 별도 코드를 작성해야 한다.

C++23에서는 이 모든 부분을 **언어의 기능**으로 강제할 수 있다:

- **RAII**: 파일 디스크립터를 객체 수명에 묶어 누수 방지.
- **`std::expected`**: “성공 값 또는 오류”를 타입 수준에서 표현.
- **`std::span` / `std::byte` / `std::string_view`**: 데이터와 길이를 함께 다루는 뷰.
- **`std::print`**: 타입 안전한 로그 출력.
- **`std::chrono`**: 시간·타임아웃을 타입 안전하게 통합.

이제 이 목표를 향해 전체 구조를 단계별로 만든다.

---

## 1. RAII로 파일 디스크립터 안전화: `unique_fd` 설계

### 1.1 RAII의 핵심

**RAII(Resource Acquisition Is Initialization)** 는 C++의 핵심 철학이다.

- “자원의 획득(Acquisition)”은 **객체의 생성**과 동시에 일어나고,
- “자원의 반납(Release)”은 **소멸자(Destructor)** 에서 자동으로 일어난다.

파일 디스크립터, 소켓, 파이프, epoll FD, timer FD… 모두 **정수**로 표현되지만, 의미적으로는 **커널 자원**이다.  
이들을 C++ 세계에서는 **“핸들 객체”** 로 감싸 관리하는 것이 자연스럽다.

**요구 조건**

| 요구 | 설명 |
|------|------|
| 단일 소유 | 파일 디스크립터는 딱 한 객체만 소유해야 한다. |
| 이동만 허용 | 복사는 금지(`= delete`), 이동만 허용(move-only). |
| 예외 안전 | 소멸자는 `noexcept` 여야 한다. |
| CLOEXEC | 하위 프로세스에 fd가 새지 않도록 `FD_CLOEXEC` 설정. |
| 편의 함수 | `reset()`, `release()`, `get()`, `operator bool()`, 채택 생성(adopt) 등. |

### 1.2 `unique_fd` 전체 구현

아래 구현은 질문에서 제시한 코드에 여러 실전 포인트를 덧붙인 버전이다.

```cpp
// unique_fd.hpp
#pragma once
#include <unistd.h>   // ::close
#include <fcntl.h>    // ::fcntl, FD_CLOEXEC, O_NONBLOCK
#include <utility>    // std::exchange, std::swap
#include <system_error>

struct adopt_fd_t {
    explicit adopt_fd_t() = default;
};
inline constexpr adopt_fd_t adopt_fd{};

class unique_fd {
public:
    using native_handle_type = int;

    // 기본 생성: "없음" 상태
    constexpr unique_fd() noexcept = default;

    // 새 fd를 소유하는 생성자
    explicit unique_fd(native_handle_type f) noexcept : fd_{f} {}

    // 채택 생성자: 이미 열려 있는 fd에 대한 소유권만 가져옴
    unique_fd(adopt_fd_t, native_handle_type f) noexcept : fd_{f} {}

    // 복사 금지
    unique_fd(const unique_fd&) = delete;
    unique_fd& operator=(const unique_fd&) = delete;

    // 이동 생성
    unique_fd(unique_fd&& other) noexcept
        : fd_{std::exchange(other.fd_, invalid())} {}

    // 이동 대입
    unique_fd& operator=(unique_fd&& other) noexcept {
        if (this != &other) {
            reset();  // 기존 자원 반납
            fd_ = std::exchange(other.fd_, invalid());
        }
        return *this;
    }

    // 소멸자: fd가 유효하면 close
    ~unique_fd() {
        reset();
    }

    // 현재 fd를 반납하고 새 fd로 교체 (또는 기본값으로 초기화)
    void reset(native_handle_type f = invalid()) noexcept {
        if (is_valid()) {
            ::close(fd_);
        }
        fd_ = f;
    }

    // 소유권 포기: 내부 fd를 돌려주고, 이 객체는 invalid 상태가 됨
    [[nodiscard]] native_handle_type release() noexcept {
        return std::exchange(fd_, invalid());
    }

    // 내부 fd 읽기 (소유권은 유지)
    [[nodiscard]] native_handle_type get() const noexcept {
        return fd_;
    }

    // 유효 여부
    [[nodiscard]] bool is_valid() const noexcept {
        return fd_ != invalid();
    }

    explicit operator bool() const noexcept {
        return is_valid();
    }

    // swap 지원
    friend void swap(unique_fd& a, unique_fd& b) noexcept {
        std::swap(a.fd_, b.fd_);
    }

    // 정적 헬퍼: invalid 값(플랫폼 종속 가능성 고려 시 이 함수 사용)
    static constexpr native_handle_type invalid() noexcept {
        return -1;
    }

private:
    native_handle_type fd_{invalid()};
};
```

핵심은 “**소멸자에서 무조건 close**” 하고, “**복사는 막고 이동만 허용**”하는 것이다.  
이제 `unique_fd`가 도입된 순간부터는 “누수”를 걱정할 필요가 거의 없다.

### 1.3 CLOEXEC / NONBLOCK 설정 헬퍼

파일 디스크립터에 옵션을 거는 부분은 **반복되는 상용구**이므로 별도 함수로 빼는 게 좋다.

```cpp
// fd_utils.hpp
#pragma once
#include <fcntl.h>
#include <system_error>
#include <cerrno>

inline std::error_code set_cloexec(int fd) {
    int flags = ::fcntl(fd, F_GETFD, 0);
    if (flags == -1)
        return {errno, std::generic_category()};

    if (::fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
        return {errno, std::generic_category()};

    return {};
}

inline std::error_code set_nonblock(int fd) {
    int flags = ::fcntl(fd, F_GETFL, 0);
    if (flags == -1)
        return {errno, std::generic_category()};

    if (::fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1)
        return {errno, std::generic_category()};

    return {};
}
```

Linux 계열에서는 소켓 생성 시 아래와 같이 할 수도 있다.

```cpp
int s = ::socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0);
```

하지만 일부 플랫폼에서는 `_CLOEXEC` 플래그가 없거나 동작이 다를 수 있으므로,  
**“가능하면 생성 시 플래그, 아니면 `fcntl`로 보정”** 이 기본 전략이다.

### 1.4 RAII 사용 예 (누수 방지)

```cpp
#include "unique_fd.hpp"
#include "fd_utils.hpp"
#include <sys/socket.h>
#include <system_error>

unique_fd make_tcp_socket() {
    int s = ::socket(AF_INET, SOCK_STREAM, 0);
    if (s == -1) {
        // 실패: 빈 unique_fd 반환
        return unique_fd{};
    }

    if (auto ec = set_cloexec(s); ec) {
        ::close(s);
        return unique_fd{};
    }

    return unique_fd{adopt_fd, s};
}

void demo_scope() {
    auto s = make_tcp_socket();
    if (!s) {
        // 생성 실패. 별도의 close 필요 없음.
        return;
    }

    // 중간에 여러 return / 예외가 발생해도
    // scope를 벗어나는 시점에 자동으로 close 호출
}
```

이제부터는 “**소켓을 열었는데 close를 빼먹지 않았나?**”를 고민하지 않아도 된다.

---

## 2. 오류 모델 정리: `errno` → `std::error_code` → `std::expected`

### 2.1 `errno`의 한계

전통적인 C API는 실패 시 `-1`을 리턴하고, **전역/스레드 로컬 변수**인 `errno`에 오류 정보를 쌓는다.

문제는 다음과 같다.

- 호출 직후 **바로** `errno`를 읽지 않으면 값이 덮어쓰일 수 있다.
- 함수 조합이 어려워진다.
- “성공 값”과 “오류 값”이 타입 수준에서 분리되어 있지 않다.

C++ 표준 라이브러리에는 이미 두 가지 대표적인 오류 표현이 있다.

- `std::error_code`
- `std::system_error` (예외 기반)

네트워킹에서는 **오류가 흔히 발생하는 정상 흐름**의 일부(EAGAIN, ETIMEDOUT, ECONNRESET 등)라서,  
예외보다는 **값 기반 오류 처리(`std::expected`)** 가 어울린다.

### 2.2 `errno` → `std::error_code` 래핑

```cpp
#include <system_error>
#include <cerrno>

inline std::error_code last_errno() {
    return {errno, std::generic_category()};
}
```

`std::generic_category()`는 POSIX errno에 잘 대응되는 범용 카테고리다.  
플랫폼에 따라 `std::system_category()` 를 쓰기도 하는데, 여기서는 **플랫폼에 독립적인 의미 해석**을 위해 `generic_category`를 사용한다.

### 2.3 네트워크 이름 해석 오류 매핑 예: `getaddrinfo`

`getaddrinfo`는 `errno` 대신 별도의 리턴코드를 사용한다.  
이럴 경우, 간단히 `std::errc`와 매핑하거나, 자체 enum을 만들 수 있다.

```cpp
enum class resolve_errc {
    ok = 0,
    temporary_failure,
    not_found,
    system,
    invalid_argument,
};

inline std::error_code make_resolve_error(int gai_err) {
    using std::errc;

    switch (gai_err) {
    case 0:
        return {};

    case EAI_AGAIN:
        return std::make_error_code(errc::resource_unavailable_try_again);
    case EAI_NONAME:
        return std::make_error_code(errc::host_unreachable);
    case EAI_FAIL:
        return std::make_error_code(errc::io_error);
    case EAI_SYSTEM:
        return last_errno();
    default:
        return std::make_error_code(errc::invalid_argument);
    }
}
```

실무에서는 더 세밀한 매핑이나 **별도 error_category** 를 만들 수도 있지만,  
여기서는 “값 기반 오류로 통합한다”는 흐름을 보여주는 것이 목적이다.

### 2.4 `std::expected` 기초

`std::expected<T, E>` (C++23)는

- **성공 시** `T` 값을 가지고,
- **실패 시** `E` 값을 가진다.

```cpp
#include <expected>
#include <system_error>

std::expected<int, std::error_code> might_fail(bool fail) {
    if (fail) {
        return std::unexpected(std::make_error_code(std::errc::io_error));
    }
    return 42;
}

void example() {
    auto v = might_fail(false);
    if (!v) {
        // 실패
        std::error_code ec = v.error();
        // ...
    } else {
        int x = *v;      // 또는 v.value()
    }
}
```

이 패턴을 소켓 유틸에 그대로 적용하면:

- 반환 타입만 보면 “**성공/오류 여부**”가 명백하다.
- 호출하는 쪽에서도 `if (!res) return std::unexpected(res.error());` 처럼 오류를 **즉시 전파**할 수 있다.

---

## 3. C API를 감싼 소켓 유틸 함수 — `std::expected` 버전

### 3.1 TCP connect 헬퍼: `tcp_connect`

먼저 “주소가 이미 준비되어 있다”는 가정에서 `connect`만 수행하는 유틸을 만든다.

```cpp
// socket_utils.hpp
#pragma once
#include "unique_fd.hpp"
#include "fd_utils.hpp"

#include <expected>
#include <system_error>
#include <sys/socket.h>

inline std::expected<unique_fd, std::error_code>
tcp_connect(const sockaddr* sa, socklen_t len) {
    int s = ::socket(sa->sa_family, SOCK_STREAM, 0);
    if (s == -1)
        return std::unexpected(last_errno());

    if (auto ec = set_cloexec(s); ec) {
        ::close(s);
        return std::unexpected(ec);
    }

    if (::connect(s, sa, len) == -1) {
        auto ec = last_errno();
        ::close(s);
        return std::unexpected(ec);
    }

    return unique_fd{adopt_fd, s};
}
```

이제 `tcp_connect`는 “성공 시 `unique_fd`” 혹은 “실패 시 `std::error_code`”를 돌려준다.

### 3.2 호스트/포트 문자열을 받아 connect: `connect_host_port`

앞서 만든 `make_resolve_error`, `tcp_connect`를 함께 사용해보자.

```cpp
#include <netdb.h>
#include <cstring>   // std::strerror
#include <print>     // C++23 std::print

inline std::expected<unique_fd, std::error_code>
connect_host_port(const char* host, const char* port) {
    addrinfo hints{};
    hints.ai_family   = AF_UNSPEC;   // IPv4/IPv6 모두 허용
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_ADDRCONFIG;

    addrinfo* res = nullptr;
    int rc = ::getaddrinfo(host, port, &hints, &res);
    if (rc != 0) {
        auto ec = make_resolve_error(rc);
        return std::unexpected(ec);
    }

    unique_fd s;
    std::error_code last_ec;

    for (addrinfo* ai = res; ai; ai = ai->ai_next) {
        int fd = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (fd < 0) {
            last_ec = last_errno();
            continue;
        }

        if (auto ec = set_cloexec(fd); ec) {
            ::close(fd);
            last_ec = ec;
            continue;
        }

        if (::connect(fd, ai->ai_addr, ai->ai_addrlen) == 0) {
            s = unique_fd{adopt_fd, fd};
            last_ec.clear();
            break;
        }

        last_ec = last_errno();
        ::close(fd);
    }

    ::freeaddrinfo(res);

    if (!s) {
        if (!last_ec)
            last_ec = std::make_error_code(std::errc::host_unreachable);
        return std::unexpected(last_ec);
    }

    return s;
}
```

사용 예:

```cpp
void connect_example() {
    auto s = connect_host_port("example.com", "80");
    if (!s) {
        std::print(stderr, "[connect] error: {}\n", s.error().message());
        return;
    }

    std::print("[connect] success, fd={}\n", s->get());
}
```

---

## 4. 바이트/문자열 모델: `std::byte`, `std::span`, `std::string_view`

### 4.1 왜 `std::byte`인가?

전통 C 코드에서 바이트 배열은 보통 `char*` 또는 `unsigned char*` 로 표현된다.  
하지만 둘을 섞어서 쓰면 다음과 같은 문제가 생긴다.

- `char`는 부호 여부가 구현체 정의 → **부호 변환 버그** 가능성.
- 문자열과 바이너리 데이터를 모두 `char*`로 다루면 타입 수준에서 차이가 사라진다.

C++17 이후에는 `std::byte`가 있다.

- **산술 연산이 금지**되어, 단순하게 “메모리 블록의 한 바이트” 역할만 한다.
- 텍스트가 아니라 **바이너리 데이터**라는 의도가 명확하다.

```cpp
#include <cstddef>

std::byte b = std::byte{0x41}; // 'A'
```

### 4.2 `std::span` 기초

`std::span<T>`는

- **소유하지 않는 뷰**(view)
- “포인터 + 길이”를 한 번에 표현
- 범위를 벗어난 접근에 대해 디버그 빌드에서는 체크 가능

```cpp
#include <span>
#include <vector>

void process(std::span<const int> xs) {
    for (int x : xs) { /* ... */ }
}

void caller() {
    std::vector<int> v{1, 2, 3};
    process(v);   // 암시적 변환
}
```

바이트 배열에서는 보통 다음 두 형태를 쓴다.

- `std::span<const std::byte>`: 읽기 전용
- `std::span<std::byte>`: 쓰기 가능

### 4.3 `std::span`과 `std::byte` 같이 쓰기

```cpp
#include <span>
#include <cstddef>

void write_packet(std::span<const std::byte> payload);
void read_packet(std::span<std::byte> payload);

// 사용 예
std::vector<std::byte> buf(1024);
read_packet(buf);                         // 읽기
write_packet(std::span{buf.data(), 16});  // 앞 16바이트만 쓰기
```

C++20 이후에는 `std::as_bytes`, `std::as_writable_bytes` 를 이용해 다른 타입 배열을 바이트 뷰로 변환할 수 있다.

```cpp
#include <span>
#include <cstdint>

void example() {
    std::uint32_t arr[4]{1, 2, 3, 4};
    std::span<std::uint32_t> s{arr};

    auto bytes = std::as_bytes(s);  // std::span<const std::byte>
    // bytes.size() == sizeof(arr) == 16
}
```

### 4.4 `std::string_view` — 텍스트 프로토콜에 유용

텍스트 프로토콜(HTTP, SMTP, Telnet 등)을 처리할 때는

- `std::string`은 **소유** + **재할당** 비용이 있고,
- `std::string_view`는 “**이미 존재하는 문자열에 대한 뷰**”로 가볍게 쓸 수 있다.

```cpp
#include <string_view>

void send_line(std::string_view line);

void use_view() {
    std::string s = "GET / HTTP/1.1\r\n";
    send_line(s);        // string -> string_view 암시적 변환
    send_line("PING");   // literal -> string_view
}
```

주의할 점은,

- `std::string_view`는 **수명 관리**를 스스로 하지 않는다.
- 즉, 가리키는 원본 문자열보다 오래 살아 있으면 안 된다.

---

## 5. 블로킹 I/O 유틸: `send_all`, `recv_exact`, `recv_some`

네트워크 I/O의 기본 원칙:

- `send` / `recv` / `write` / `read` 는 모두 **부분 입출력**을 할 수 있다.
- 따라서 “한 번 호출에 다 보내지/읽어지지 않는다”는 가정 아래 utility를 설계해야 한다.

### 5.1 `send_all`: 버퍼 전체를 보낼 때까지 반복

```cpp
// io_utils.hpp
#pragma once
#include <span>
#include <expected>
#include <system_error>
#include <cstddef>   // std::byte
#include <sys/socket.h>
#include <cerrno>

inline std::expected<std::size_t, std::error_code>
send_all(int fd, std::span<const std::byte> buf) {
    std::size_t total = 0;

    while (total < buf.size()) {
        const auto* ptr = buf.data() + total;
        std::size_t left = buf.size() - total;

        ssize_t n = ::send(fd, ptr, left, 0);
        if (n > 0) {
            total += static_cast<std::size_t>(n);
            continue;
        }
        if (n == 0) {
            // TCP에서는 거의 안 나오지만, "더 이상 보낼 수 없음"으로 해석
            break;
        }

        if (errno == EINTR) {
            continue;   // 신호로 끊겼다면 다시 시도
        }

        return std::unexpected(last_errno());
    }

    return total;
}
```

- 성공 시: 실제로 보낸 바이트 수(`total`)
- 실패 시: `std::error_code`

### 5.2 `recv_exact`: 지정한 바이트 수를 얻을 때까지 반복

지정한 크기 `buf.size()` 만큼 정확히 읽어야 하는 상황(예: 프레이밍 헤더)에서는 다음 유틸이 유용하다.

```cpp
inline std::expected<std::size_t, std::error_code>
recv_exact(int fd, std::span<std::byte> buf) {
    std::size_t total = 0;

    while (total < buf.size()) {
        auto* ptr = buf.data() + total;
        std::size_t left = buf.size() - total;

        ssize_t n = ::recv(fd, ptr, left, 0);
        if (n > 0) {
            total += static_cast<std::size_t>(n);
            continue;
        }
        if (n == 0) {
            // 원격이 정상/비정상적으로 종료
            return std::unexpected(
                std::make_error_code(std::errc::connection_reset));
        }
        if (errno == EINTR) {
            continue;
        }

        return std::unexpected(last_errno());
    }

    return total;
}
```

프레이밍에서 “길이 필드”를 읽을 때 특히 자주 쓰게 된다.

### 5.3 `recv_some`: 최대 N바이트까지 읽기

“최대 N바이트까지 읽되, 1바이트라도 읽으면 즉시 반환”하는 유틸도 자주 필요하다.

```cpp
inline std::expected<std::size_t, std::error_code>
recv_some(int fd, std::span<std::byte> buf) {
    ssize_t n = ::recv(fd, buf.data(), buf.size(), 0);
    if (n > 0) {
        return static_cast<std::size_t>(n);
    }
    if (n == 0) {
        return std::unexpected(
            std::make_error_code(std::errc::connection_reset));
    }
    if (errno == EINTR) {
        // 호출한 쪽에서 재시도 여부를 정하도록, "0바이트 읽음"으로 보낼 수도 있다.
        return std::unexpected(last_errno());
    }

    return std::unexpected(last_errno());
}
```

---

## 6. 프레이밍(길이-프리픽스)과 직렬화

네트워크에서 자주 쓰는 패턴: **길이-프리픽스 프레이밍(length-prefixed framing)**

- 메시지 앞에 4바이트(또는 8바이트) 길이 필드를 붙인다.
- 수신자는 먼저 길이를 읽고, 그 길이만큼의 바이트를 다시 읽는다.
- TCP 스트림에서 메시지 경계를 복원하는 가장 일반적인 방식이다.

### 6.1 길이-프리픽스 프레임 송신: `send_frame`

```cpp
#include <vector>
#include <cstdint>
#include <arpa/inet.h>  // htonl, ntohl

inline std::expected<void, std::error_code>
send_frame(int fd, std::span<const std::byte> payload) {
    if (payload.size() > std::numeric_limits<std::uint32_t>::max())
        return std::unexpected(
            std::make_error_code(std::errc::message_size));

    std::uint32_t len = static_cast<std::uint32_t>(payload.size());
    std::uint32_t be  = htonl(len);

    auto header_bytes =
        std::as_bytes(std::span{&be, static_cast<std::size_t>(1)});

    // 길이 먼저 전송
    if (auto r = send_all(fd, header_bytes); !r) {
        return std::unexpected(r.error());
    }

    // 본문 전송
    if (auto r = send_all(fd, payload); !r) {
        return std::unexpected(r.error());
    }

    return {};
}
```

### 6.2 길이-프리픽스 프레임 수신: `recv_frame`

```cpp
inline std::expected<std::vector<std::byte>, std::error_code>
recv_frame(int fd, std::size_t max_size = (1u << 20)) { // 기본 cap: 1 MiB
    std::uint32_t be = 0;
    auto header_bytes =
        std::as_writable_bytes(std::span{&be, static_cast<std::size_t>(1)});

    // 길이 필드 읽기
    if (auto r = recv_exact(fd, header_bytes); !r) {
        return std::unexpected(r.error());
    }

    std::uint32_t len = ntohl(be);
    if (len > max_size) {
        return std::unexpected(
            std::make_error_code(std::errc::message_size));
    }

    std::vector<std::byte> buf(len);
    if (len == 0) {
        return buf; // 빈 메시지
    }

    if (auto r = recv_exact(fd, std::span{buf.data(), buf.size()}); !r) {
        return std::unexpected(r.error());
    }

    return buf;
}
```

여기서 `max_size`는 **방어적 프로그래밍**의 핵심이다.

- 악의적인 클라이언트가 “10GB” 같은 길이를 보내더라도,
- 서버가 그만큼의 메모리를 할당하지 않도록 **상한(cap)** 을 둔다.

### 6.3 텍스트 메시지를 프레임에 태우기

텍스트 메시지의 경우, `std::string` / `std::string_view` 를 **바이트 뷰**로 변환해 프레임을 전송하면 된다.

```cpp
#include <string>
#include <cstring>

inline std::expected<void, std::error_code>
send_text_frame(int fd, std::string_view text) {
    std::vector<std::byte> buf(text.size());
    std::memcpy(buf.data(), text.data(), text.size());
    return send_frame(fd, std::span{buf.data(), buf.size()});
}
```

---

## 7. 텍스트 프로토콜 유틸: 한 줄씩 보내고/받기

길이-프리픽스 대신, **줄 단위 프로토콜**(예: `\n` 또는 `\r\n` 으로 끝나는 라인)을 쓰는 경우도 많다.

### 7.1 한 줄 보내기: `send_text_line`

```cpp
#include <array>
#include <string_view>

inline std::expected<void, std::error_code>
send_text_line(int fd, std::string_view line) {
    auto bytes = std::as_bytes(
        std::span{line.data(), line.size()});

    if (auto r = send_all(fd, bytes); !r)
        return std::unexpected(r.error());

    std::array<std::byte, 1> nl{std::byte{'\n'}};
    if (auto r = send_all(fd, std::span{nl}); !r)
        return std::unexpected(r.error());

    return {};
}
```

### 7.2 라인 리더(line reader)의 개념

라인 기반 프로토콜을 처리하려면 보통 **버퍼를 유지**하면서 `\n` 문자를 찾는다.

```cpp
#include <string>
#include <vector>
#include <optional>

class line_buffer {
public:
    // fd에서 데이터 읽어와 internal buffer에 축적한 후,
    // '\n'이 발견되면 한 줄씩 잘라 반환한다.

    explicit line_buffer(int fd) : fd_{fd} {
        buf_.resize(4096);
    }

    std::expected<std::optional<std::string>, std::error_code>
    read_line() {
        for (;;) {
            // '\n' 탐색
            auto pos = std::find(storage_.begin(), storage_.end(), '\n');
            if (pos != storage_.end()) {
                std::string line(storage_.begin(), pos);
                storage_.erase(storage_.begin(), pos + 1);
                return line;
            }

            // 더 읽어야 함
            std::span<std::byte> dst = std::as_writable_bytes(
                std::span{buf_.data(), buf_.size()});

            auto r = recv_some(fd_, dst);
            if (!r) {
                if (r.error() == std::errc::connection_reset) {
                    if (storage_.empty()) {
                        return std::optional<std::string>{}; // EOF
                    } else {
                        // 마지막 줄(개행 없이 끝나는 경우)
                        std::string line(storage_.begin(), storage_.end());
                        storage_.clear();
                        return line;
                    }
                }
                return std::unexpected(r.error());
            }

            std::size_t n = *r;
            storage_.append(reinterpret_cast<char*>(buf_.data()), n);
        }
    }

private:
    int fd_;
    std::string storage_;
    std::vector<char> buf_;
};
```

- 반환 타입은 `std::expected<std::optional<std::string>, std::error_code>`
  - 오류 시: `unexpected(error)`
  - EOF 시: `std::optional`이 비어 있음
  - 정상적인 한 줄: `std::optional`에 문자열

---

## 8. 시간·타임아웃 처리: `std::chrono`와 소켓 옵션

네트워크에서 **타임아웃**은 필수이다.

- 너무 빨리 포기하면 정상적인 네트워크 지연에도 실패로 간주한다.
- 너무 늦게 포기하면 자원이 묶여서 전체 시스템에 영향을 준다.

C API에서는 대표적으로 두 가지 방법이 있다.

1. `SO_RCVTIMEO` / `SO_SNDTIMEO` 소켓 옵션
2. 논블로킹 + `poll`/`epoll` + **deadline(마감 시간)** 계산

여기서는 두 방법 모두 C++23 스타일로 정리한다.

### 8.1 `std::chrono` → `timeval` 변환

```cpp
#include <chrono>
#include <sys/socket.h>

inline timeval to_timeval(std::chrono::milliseconds ms) {
    timeval tv{};
    tv.tv_sec  = static_cast<long>(ms.count() / 1000);
    tv.tv_usec = static_cast<long>((ms.count() % 1000) * 1000);
    return tv;
}

inline std::error_code
set_timeouts(int fd,
             std::chrono::milliseconds recv_to,
             std::chrono::milliseconds send_to) {
    auto r = to_timeval(recv_to);
    auto s = to_timeval(send_to);

    if (::setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO,
                     &r, sizeof(r)) == -1)
        return last_errno();

    if (::setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO,
                     &s, sizeof(s)) == -1)
        return last_errno();

    return {};
}
```

- 이 방식은 **커널 레벨 타임아웃**이라 간단하다.
- 다만, 플랫폼에 따라 동작이 미묘하게 다를 수 있다.

### 8.2 데드라인 기반 `recv_exact_deadline`

보다 세밀한 제어가 필요하면,

1. 소켓을 **논블로킹**으로 전환한다.
2. `recv`에서 `EAGAIN` / `EWOULDBLOCK` 이 나오면,
3. 남은 시간을 계산해 `poll` 혹은 `epoll_wait`로 기다린다.

```cpp
#include <poll.h>

inline std::expected<std::size_t, std::error_code>
recv_exact_deadline(int fd,
                    std::span<std::byte> buf,
                    std::chrono::steady_clock::time_point deadline) {
    if (auto ec = set_nonblock(fd); ec) {
        return std::unexpected(ec);
    }

    std::size_t total = 0;

    while (total < buf.size()) {
        auto* ptr = buf.data() + total;
        std::size_t left = buf.size() - total;

        ssize_t n = ::recv(fd, ptr, left, 0);
        if (n > 0) {
            total += static_cast<std::size_t>(n);
            continue;
        }
        if (n == 0) {
            return std::unexpected(
                std::make_error_code(std::errc::connection_reset));
        }

        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            if (errno == EINTR) {
                continue;
            }
            return std::unexpected(last_errno());
        }

        // 여기서부터는 "지금은 읽을 수 없음, 나중에 다시" 상황
        auto now = std::chrono::steady_clock::now();
        if (now >= deadline) {
            return std::unexpected(
                std::make_error_code(std::errc::timed_out));
        }

        auto remaining =
            std::chrono::duration_cast<std::chrono::milliseconds>(
                deadline - now);

        pollfd pfd{};
        pfd.fd      = fd;
        pfd.events  = POLLIN;
        pfd.revents = 0;

        int rc = ::poll(&pfd, 1, static_cast<int>(remaining.count()));
        if (rc == 0) {
            return std::unexpected(
                std::make_error_code(std::errc::timed_out));
        }
        if (rc < 0) {
            if (errno == EINTR) {
                continue;
            }
            return std::unexpected(last_errno());
        }
    }

    return total;
}
```

이 함수는 “**데드라인까지 정확히 N바이트를 읽는다**”는 계약을 가진다.

- 데드라인 초과 시: `std::errc::timed_out`
- 연결 리셋 시: `std::errc::connection_reset`
- 그 외 오류 시: `errno` → `std::error_code`

---

## 9. 로깅·관측: `std::print`와 hexdump

### 9.1 `std::print`로 타입 안전한 로그

C++23의 `std::print`는 `printf`와 비슷하지만, **타입 안전**하고 `std::format` 기반 포맷 문자열을 쓴다.

```cpp
#include <print>

void log_connect(const char* host, const char* port, int fd) {
    std::print("[tcp] connected to {}:{} (fd={})\n", host, port, fd);
}

void log_error(const char* tag, std::error_code ec) {
    std::print(stderr, "[{}] error: {} ({})\n",
               tag, ec.message(), ec.value());
}
```

실전에서는 “레이블, 레벨, 타임스탬프, 쓰레드 ID” 등도 포함하는 **자체 로거**를 만들 수 있지만,  
여기서는 핵심인 **타입 안전 + 포맷 일관성**에 초점을 맞춘다.

### 9.2 바이트 덤프(hexdump) 도우미

바이너리 프로토콜 디버깅에는 **hexdump**가 매우 유용하다.

```cpp
#include <print>

inline void hexdump(std::span<const std::byte> s) {
    std::size_t i = 0;

    for (auto b : s) {
        if (i % 16 == 0) {
            std::print("{:08X}  ", static_cast<unsigned>(i));
        }

        auto v = static_cast<unsigned>(
            std::to_integer<unsigned char>(b));
        std::print("{:02X} ", v);

        if (++i % 16 == 0) {
            std::print("\n");
        }
    }

    if (i % 16 != 0) {
        std::print("\n");
    }
}
```

출력 예:

```text
00000000  48 65 6C 6C 6F 20 57 6F 72 6C 64 21 0A
```

이를 로그와 함께 사용하면, 문제 상황을 재현하는 데 큰 도움이 된다.

---

## 10. 통합 예제 1 — 미니 TCP 에코 클라이언트

앞서 만든 조각들을 한데 모아, “연결 → 프레임 전송 → 응답 수신” 흐름을 정리해보자.

### 10.1 전체 코드

```cpp
// mini_client.cpp
#include "unique_fd.hpp"
#include "fd_utils.hpp"
#include "io_utils.hpp"

#include <print>
#include <vector>
#include <string>
#include <chrono>
#include <netdb.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <expected>
#include <cstring>

// errno -> error_code
inline std::error_code last_errno(){ return {errno, std::generic_category()}; }

// 앞에서 정의한 connect_host_port / send_frame / recv_frame 사용
// 여기서는 선언만 재사용한다고 가정

int main(int argc, char** argv) {
    const char* host = (argc > 1) ? argv[1] : "127.0.0.1";
    const char* port = (argc > 2) ? argv[2] : "9000";
    std::string msg  = (argc > 3) ? argv[3] : "hello";

    auto s = connect_host_port(host, port);
    if (!s) {
        std::print(stderr, "[connect] {}\n", s.error().message());
        return 1;
    }

    int fd = s->get();

    if (auto ec = set_timeouts(fd,
                               std::chrono::seconds(3),
                               std::chrono::seconds(3)); ec) {
        std::print(stderr, "[timeout] {}\n", ec.message());
        return 1;
    }

    std::print("[tcp] connected to {}:{} (fd={})\n", host, port, fd);

    // 텍스트 -> 바이트 벡터
    std::vector<std::byte> payload(msg.size());
    std::memcpy(payload.data(), msg.data(), msg.size());

    if (auto ok = send_frame(fd, std::span{payload.data(), payload.size()}); !ok) {
        std::print(stderr, "[send_frame] {}\n", ok.error().message());
        return 2;
    }

    auto echo = recv_frame(fd, 1 << 20);
    if (!echo) {
        std::print(stderr, "[recv_frame] {}\n", echo.error().message());
        return 3;
    }

    std::string echoed(reinterpret_cast<const char*>(echo->data()),
                       echo->size());
    std::print("[echo] {}\n", echoed);
    return 0;
}
```

- `connect_host_port`: 주소 해석 + 소켓 생성 + connect를 `std::expected`로 래핑.
- `send_frame` / `recv_frame`: 길이-프리픽스 프레이밍.
- `set_timeouts`: recv/send 타임아웃 3초 설정.
- `std::print`: 모든 로그/에러를 타입 안전하게 출력.

---

## 11. 통합 예제 2 — 단일 스레드 에코 서버

이제 서버 쪽도 C++23 스타일로 만든다.

### 11.1 리스닝 소켓 생성 유틸

```cpp
#include <netinet/in.h>
#include <cstring>

inline std::expected<unique_fd, std::error_code>
make_listen_socket(std::uint16_t port, int backlog = 128) {
    int s = ::socket(AF_INET, SOCK_STREAM, 0);
    if (s == -1)
        return std::unexpected(last_errno());

    if (auto ec = set_cloexec(s); ec) {
        ::close(s);
        return std::unexpected(ec);
    }

    int yes = 1;
    if (::setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
                     &yes, sizeof(yes)) == -1) {
        auto ec = last_errno();
        ::close(s);
        return std::unexpected(ec);
    }

    sockaddr_in addr{};
    addr.sin_family      = AF_INET;
    addr.sin_port        = htons(port);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (::bind(s, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) == -1) {
        auto ec = last_errno();
        ::close(s);
        return std::unexpected(ec);
    }

    if (::listen(s, backlog) == -1) {
        auto ec = last_errno();
        ::close(s);
        return std::unexpected(ec);
    }

    return unique_fd{adopt_fd, s};
}
```

### 11.2 단일 스레드 에코 서버 루프

```cpp
#include <print>

int main() {
    auto ls = make_listen_socket(9000);
    if (!ls) {
        std::print(stderr, "[listen] {}\n", ls.error().message());
        return 1;
    }
    std::print("[server] listening on port {}\n", 9000);

    for (;;) {
        sockaddr_in cli{};
        socklen_t   cli_len = sizeof(cli);
        int fd = ::accept(ls->get(),
                          reinterpret_cast<sockaddr*>(&cli),
                          &cli_len);
        if (fd < 0) {
            if (errno == EINTR)
                continue;
            std::print(stderr, "[accept] {}\n",
                       last_errno().message());
            continue;
        }

        unique_fd client{adopt_fd, fd};
        std::print("[server] client connected (fd={})\n", fd);

        // 프레임 하나 받고, 그대로 다시 보내는 에코
        auto frame = recv_frame(fd, 1 << 20);
        if (!frame) {
            std::print(stderr, "[recv_frame] {}\n",
                       frame.error().message());
            continue;
        }

        if (auto ok = send_frame(fd, std::span{frame->data(), frame->size()});
            !ok) {
            std::print(stderr, "[send_frame] {}\n",
                       ok.error().message());
            continue;
        }

        std::print("[server] echoed {} bytes\n", frame->size());
    }
}
```

이 서버는

- 한 번에 하나의 연결만 처리하는 **단일 스레드** 서버이다.
- 실전에서는 쓰레드 풀/이벤트 루프와 결합해 확장 가능하다.
- 중요한 것은 “**소켓 수명과 오류 흐름이 모두 RAII + `std::expected` 기반**”이라는 점이다.

---

## 12. 동시성 패턴: 스레드 기반 vs 이벤트 기반

실제 서비스에서는 동시 클라이언트 수가 많아진다. 크게 두 가지 방향이 있다.

1. **스레드 기반(thread-per-connection, thread-pool)**  
2. **이벤트 기반(select/poll/epoll, kqueue 등)**  

여기서는 C++23 스타일을 유지한 채 간단히 개념과 코드를 보여준다.

### 12.1 스레드 기반 패턴 (요지)

스레드 기반 서버의 전형적인 구조:

```cpp
#include <thread>
#include <vector>
#include <print>

void handle_client(unique_fd client) {
    // 클라이언트별 처리 (프레이밍, 요청/응답 등)
    for (;;) {
        auto frame = recv_frame(client.get(), 1 << 20);
        if (!frame) {
            std::print("[client] recv_frame error: {}\n",
                       frame.error().message());
            return; // 소멸자에서 close
        }
        if (frame->empty())
            return;

        if (auto ok = send_frame(client.get(),
                                 std::span{frame->data(), frame->size()});
            !ok) {
            std::print("[client] send_frame error: {}\n",
                       ok.error().message());
            return;
        }
    }
}

int main() {
    auto ls = make_listen_socket(9000);
    if (!ls) {
        std::print(stderr, "[listen] {}\n", ls.error().message());
        return 1;
    }

    std::vector<std::thread> threads;

    for (;;) {
        sockaddr_in cli{};
        socklen_t   cli_len = sizeof(cli);
        int fd = ::accept(ls->get(),
                          reinterpret_cast<sockaddr*>(&cli),
                          &cli_len);
        if (fd < 0) {
            if (errno == EINTR) continue;
            std::print(stderr, "[accept] {}\n",
                       last_errno().message());
            continue;
        }

        unique_fd client{adopt_fd, fd};

        threads.emplace_back([c = std::move(client)]() mutable {
            handle_client(std::move(c));
        });
    }

    for (auto& t : threads) {
        if (t.joinable()) t.join();
    }
}
```

주의할 점:

- 스레드 수가 접속 수에 비례해 늘어나면, 문맥 전환 비용과 메모리가 커진다.
- C++20 이후의 **가벼운 쓰레드(플랫폼/라이브러리 구현에 의존)**와 결합하면 개선 여지가 있다.
- C++23 표준만으로 비동기 IO를 지원하지는 않으므로, 네트워크 IO 자체는 여전히 OS에 의존한다.

### 12.2 이벤트 기반 패턴의 개략

이벤트 기반 서버에서는 하나의 쓰레드가 `epoll`/`kqueue`에 여러 소켓을 등록하고,  
“어느 소켓이 읽을 준비가 되었는가?”를 기반으로 상태 머신을 돌린다.

이 글의 범위를 넘어서는 깊은 구현은 생략하지만,  
개략적인 skeleton 수준의 코드만 보자.

```cpp
// 개략적인 epoll loop skeleton (실제 코드에서는 오류 처리/RAII 보완 필요)
#include <sys/epoll.h>
#include <unordered_map>

struct connection_state {
    unique_fd fd;
    std::vector<std::byte> recv_buf;
    std::vector<std::byte> send_buf;
    // 기타 상태 (파싱 상태, 프로토콜 상태 등)
};

int main() {
    auto ls = make_listen_socket(9000);
    if (!ls) { /* ... */ }

    int ep = ::epoll_create1(EPOLL_CLOEXEC);
    unique_fd epfd{adopt_fd, ep};

    epoll_event ev{};
    ev.events  = EPOLLIN;
    ev.data.fd = ls->get();
    ::epoll_ctl(epfd.get(), EPOLL_CTL_ADD, ls->get(), &ev);

    std::unordered_map<int, connection_state> connections;

    constexpr int MAX_EVENTS = 64;
    epoll_event events[MAX_EVENTS];

    for (;;) {
        int n = ::epoll_wait(epfd.get(), events, MAX_EVENTS, -1);
        if (n < 0) {
            if (errno == EINTR) continue;
            // 오류 처리
        }

        for (int i = 0; i < n; ++i) {
            int fd = events[i].data.fd;
            auto evts = events[i].events;

            if (fd == ls->get()) {
                // 새로운 클라이언트 accept
                // ...
            } else {
                // 기존 클라이언트 fd에 대한 읽기/쓰기
                // connections[fd] 사용
                // ...
            }
        }
    }
}
```

핵심은,

- 여전히 `unique_fd`, `std::expected`, `std::span` 등 **같은 도구**를 쓴다는 점이다.
- 단지 “블로킹 함수 반복 호출”에서 “각 fd의 상태를 저장한 상태 머신”으로 구조가 바뀌었을 뿐이다.

---

## 13. 안정성 체크리스트 (정리)

앞서 설명한 내용을 압축하면 다음과 같이 체크리스트를 만들 수 있다.

### 13.1 RAII와 자원 관리

- [ ] 모든 **소유 자원**(소켓, FD, epoll, timer, 파이프 등)이  
      `unique_fd` 또는 유사한 RAII 래퍼에 묶여 있는가?
- [ ] 복사 생성/대입이 금지되어, 소유권이 **단일화**되어 있는가?
- [ ] 소멸자는 예외를 던지지 않고(`noexcept`), `close`에서 발생한 오류를 조용히 무시해도 괜찮도록 설계되어 있는가?
- [ ] `CLOEXEC`가 기본값으로 적용되어, `exec` 이후에 fd가 누출되지 않는가?

### 13.2 오류 흐름 (`std::expected`)

- [ ] 함수의 반환 타입이 `std::expected<T, std::error_code>` 형태로  
      “성공 값 또는 오류”를 명시적으로 표현하는가?
- [ ] `errno` → `std::error_code` 변환이 **한 곳**(`last_errno`)에 모여 있는가?
- [ ] `getaddrinfo` 등 특수 API의 오류 코드가 일관되게 매핑되는가?
- [ ] 호출하는 쪽에서 `if (!res) return std::unexpected(res.error());` 패턴으로  
      오류 전파가 간결하게 이루어지는가?

### 13.3 I/O 계약

- [ ] `send_all`, `recv_exact`, `recv_some` 등  
      **부분 입출력**을 전제로 한 유틸을 사용하고 있는가?
- [ ] 프레이밍(길이-프리픽스/구분자 기반)이 명시적으로 설계되어 있는가?
- [ ] 메시지 크기 상한(cap)을 두어, 잘못된 입력으로 인한 메모리 고갈을 방지하는가?

### 13.4 시간·타임아웃

- [ ] `std::chrono` 기반의 타임아웃 정책을 사용하고 있는가?
- [ ] 타임아웃이 커널 옵션(`SO_RCVTIMEO`/`SO_SNDTIMEO`)인지,  
      혹은 논블로킹 + `poll`/`epoll` + deadline 방식인지 문서화되어 있는가?
- [ ] 모든 네트워크 연산에 대한 타임아웃이 “무한정 대기”가 아니라  
      합리적인 범위 내에서 설정되어 있는가?

### 13.5 로깅·관측

- [ ] `std::print` 혹은 그 위에 구축한 로거를 사용해,  
      타입 안전하고 일관된 로그 포맷을 유지하고 있는가?
- [ ] 실패 로그에 반드시 `std::error_code`의 메시지와 값이 포함되는가?
- [ ] hexdump 등 바이너리 덤프 도구로 문제 상황을 재현할 수 있는가?

---

## 14. 성능·지연에 대한 직관적 수식

네트워크 성능을 직관적으로 이해하기 위해, 실무에서 자주 쓰이는 세 가지 수식을 정리한다.  
(수식 자체는 이론적 근사이며, 실제 구현에서는 많은 변수의 영향을 받는다.)

### 14.1 지수 백오프(Exponential Backoff)

재시도 정책에서 자주 쓰이는 지수 백오프는 다음과 같이 표현할 수 있다.

$$
t_k = \min\{t_{\max},\ t_0 \cdot 2^k\}
$$

- \(t_0\): 최초 대기 시간(예: 100ms)
- \(t_{\max}\): 최대 대기 시간(예: 수 초 ~ 수십 초)
- \(k\): 재시도 횟수(0, 1, 2, ...)

즉, **재시도가 늘어날수록 대기 시간을 2배씩 늘리되**,  
일정 이상 커지면 \(t_{\max}\)로 상한을 두는 패턴이다.

실전에서는 “**네트워크 장애**”나 “**상대 서버 과부하**” 시에 사용하며,  
C++23에서는 `std::chrono`로 자연스럽게 구현할 수 있다.

### 14.2 대역폭–지연곱(Bandwidth–Delay Product, BDP)

네트워크 링크의 대역폭과 왕복 지연(RTT)을 곱한 값은  
“파이프 안에 동시에 떠 있는 데이터 양”을 나타낸다.

$$
\text{BDP} = \text{Bandwidth} \times \text{RTT}
$$

예를 들어,

- Bandwidth = 100 Mbit/s,
- RTT = 100 ms 라면,

$$
\text{BDP} = 100\,\text{Mbit/s} \times 0.1\,\text{s} = 10\,\text{Mbit}
$$

이는 약 1.25 MiB에 해당한다.  
즉, 송신 측이 최소한 이 정도는 버퍼링/윈도우 크기(TCP 윈도우, 소켓 버퍼 등)를 잡아야  
링크를 **완전히 채워** 최대 처리량을 낼 수 있다.

### 14.3 손실 환경에서 처리량 근사 (TCP Reno)

단순한 근사식이지만, 패킷 손실 확률\(p\)와 RTT, MSS(Maximum Segment Size)를 기반으로  
평균 처리량을 다음과 같이 나타내기도 한다.

$$
\text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}}
$$

- \(p\): 손실 확률
- MSS: TCP 세그먼트의 payload 크기
- RTT: 왕복 지연 시간

손실이 커질수록 \(\sqrt{p}\)가 커지고, 결과적으로 처리량이 떨어진다.  
작은 메시지를 너무 자주 보내면 헤더/ACK 오버헤드와 지연의 영향이 더 커지므로,  
가능하다면 **여러 메시지를 묶어(coalescing)** 보내거나  
Nagle 알고리즘/TCP_NODELAY를 상황에 맞게 설정해야 한다.

---

## 15. 흔한 함정과 방어 전략

마지막으로, C API를 C++23 스타일로 감싸면서 자주 마주치는 함정과  
이에 대한 방어 전략을 정리한다.

### 15.1 구조체 직렬화 함정

- C/C++ 구조체를 그대로 `send`/`recv` 하는 것은 위험하다.
  - 패딩, 정렬, 엔디안 차이 때문에 다른 플랫폼에서 문제가 생긴다.
- 안전한 방법:
  - **명시적인 encode/decode** 함수 작성
  - 길이·엔디안·버전 필드를 포함한 헤더 정의
  - 직렬화 포맷(JSON, protobuf, flatbuffers 등) 도입

### 15.2 SIGPIPE

- 어떤 시스템에서는 끊긴 소켓에 `send`할 때 **SIGPIPE** 신호가 발생해  
  프로세스가 종료될 수 있다.
- 방어 전략:
  - Linux: `send`에 `MSG_NOSIGNAL` 플래그 사용
  - BSD 계열: `SO_NOSIGPIPE` 소켓 옵션
  - 전역적으로 `SIGPIPE`를 무시하도록 설정

예:

```cpp
#include <signal.h>

void ignore_sigpipe() {
    ::signal(SIGPIPE, SIG_IGN);
}
```

### 15.3 `std::string_view` 생명주기

- string literal이나 `std::string`에서 받은 `std::string_view`를  
  **장기간 저장해두면** 원본이 파괴된 이후 뷰가 **댕글링** 된다.
- 방어 전략:
  - 뷰를 멤버로 유지해야 한다면, **원본 문자열을 함께 소유**하거나
  - 필요한 시점에만 뷰를 생성하고 곧바로 사용한다.

### 15.4 논블로킹 전환 누락

- 데드라인 기반 루프에서 `EAGAIN`/`EWOULDBLOCK`을 처리한다고 가정했는데,  
  실제로 소켓은 블로킹 모드라면 이런 오류가 나오지 않는다.
- 방어 전략:
  - `set_nonblock`의 호출과 오류 처리 결과를 반드시 확인.
  - 논블로킹 루틴에서는 `EAGAIN`/`EWOULDBLOCK`만 정상 상황으로 취급하고,  
    나머지 오류는 모두 비정상으로 처리한다.

### 15.5 CLOEXEC 미설정

- 서버가 `fork` + `exec` 패턴을 사용할 때,
  - 자식 프로세스가 부모의 fd를 그대로 물려받으면,  
    의도치 않은 fd 유출로 자원 관리와 보안에 문제가 생긴다.
- 방어 전략:
  - 소켓/파일 생성 직후 `FD_CLOEXEC` 설정을 기본값으로 적용.
  - 생성 시 `_CLOEXEC` 플래그를 사용할 수 있으면 우선 사용하고,  
    안 되는 경우 `fcntl`로 보정.

---

## 16. 마무리 — C++23 스타일 소켓 래핑의 전체 그림

지금까지의 내용을 한 문장씩 정리하면 다음과 같다.

1. **RAII `unique_fd`**  
   - 소켓 및 각종 파일 디스크립터를 “정수”가 아닌 “객체”로 다루고,  
     수명을 C++ 객체의 생성/소멸에 묶음으로써 **자원 누수를 원천 차단**한다.

2. **`std::expected` + `std::error_code`**  
   - 네트워크 API의 반환값을 “성공 값 또는 오류”로 타입 수준에서 분리해,  
     오류 전파 로직을 **짧고 명확하게** 만든다.

3. **`std::span<std::byte>` / `std::string_view`**  
   - 바이트/문자열 데이터를 뷰(view)로 다루면서,  
     길이와 범위를 함께 관리해 **버퍼 오버런 위험을 줄이고** 의도를 명확히 한다.

4. **`std::print` / `std::chrono`**  
   - 타입 안전한 로그와 시간/타임아웃을 표준 라이브러리에 포함된 기능으로 처리해,  
     **관측성과 디버깅 편의성**을 높인다.

5. **프레이밍·직렬화·타임아웃·동시성 패턴**  
   - 길이-프리픽스 프레이밍, 방어적 메시지 크기 상한,  
     커널 옵션 또는 deadline 기반 타임아웃,  
     스레드 기반 또는 이벤트 기반 동시성 패턴을 조합해  
     현실적인 네트워크 서비스 구조를 설계한다.

이 글에서 제시한 코드와 개념은 **POSIX 소켓**을 대상으로 했지만,  
동일한 패턴은 파일, 파이프, 이벤트 FD, 타이머 FD, 프로세스 핸들 등  
다른 커널 자원에도 그대로 확장할 수 있다.

실제 프로젝트에서는 여기에

- TLS(예: OpenSSL, mbedTLS) 래퍼,
- 고수준 프로토콜(HTTP, gRPC, WebSocket),
- 성능 측정/로깅 인프라,

등을 단계적으로 추가해 나가면 된다.  
중요한 것은, **기초를 C++23 스타일로 단단하게 맞추어 두면**,  
이후의 모든 확장이 **일관된 원칙** 위에서 돌아간다는 점이다.