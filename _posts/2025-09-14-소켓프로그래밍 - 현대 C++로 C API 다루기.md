---
layout: post
title: 소켓프로그래밍 - 현대 C++로 C API 다루기
date: 2025-09-14 15:25:23 +0900
category: 소켓프로그래밍
---
## C++23 준비물 — 현대 C++로 C API 다루기

> 목표: POSIX 소켓(C API)을 **C++23 스타일**(RAII, `std::expected`, `std::span<std::byte>`, `std::string_view`, `std::print`/`std::chrono`)로 감싸 **안전성·가독성·관측성**을 확보한다.
> 포인트: **누수 없는 자원 관리**, **명시적 오류 흐름**, **바이트/문자열의 경계 명확화**, **시간·로그 표준화**.

---

### RAII로 자원 안전화: `unique_fd` 설계 포인트

#### 왜 RAII인가?

- 시스템 콜은 성공하면 **커널 자원**(파일 디스크립터, 메모리, 소켓 등)을 돌려준다. 실패·예외 시에 **반드시 반납**되어야 한다.
- C++의 **RAII(Resource Acquisition Is Initialization)** 는 **생성 → 소유 → 파괴**의 **수명 규칙**으로 누수를 원천 차단한다.

#### 설계 목표

- **단일 소유**: 복사 금지, **이동만 허용**(move-only).
- **지연 없는 해제**: 소멸자에서 `close(2)` 호출.
- **예외 안전**: 소멸자는 `noexcept`.
- **CLOEXEC 설정**: 하위 프로세스로 **fd 누출 방지**.
- **유틸**: `reset()`, `release()`, `get()`, `operator bool()`, `adopt_fd`(채택 생성), `set_nonblock()`.

#### 구현(요지)

```cpp
// unique_fd.hpp
#pragma once
#include <unistd.h>
#include <fcntl.h>
#include <utility>

struct adopt_fd_t { explicit adopt_fd_t() = default; };
inline constexpr adopt_fd_t adopt_fd{};

struct unique_fd {
    int fd{-1};

    unique_fd() = default;
    explicit unique_fd(int f) : fd(f) {}
    unique_fd(adopt_fd_t, int f) : fd(f) {}

    unique_fd(const unique_fd&) = delete;
    unique_fd& operator=(const unique_fd&) = delete;

    unique_fd(unique_fd&& o) noexcept : fd(std::exchange(o.fd, -1)) {}
    unique_fd& operator=(unique_fd&& o) noexcept {
        if (this != &o) { reset(); fd = std::exchange(o.fd, -1); }
        return *this;
    }

    ~unique_fd() { reset(); }

    void reset(int f = -1) noexcept {
        if (fd != -1) ::close(fd);
        fd = f;
    }
    [[nodiscard]] int release() noexcept { return std::exchange(fd, -1); }
    [[nodiscard]] int get() const noexcept { return fd; }
    explicit operator bool() const noexcept { return fd != -1; }
};

// CLOEXEC 보장된 소켓/FD 생성 도우미
inline int set_cloexec(int fd) {
    int flags = ::fcntl(fd, F_GETFD, 0);
    if (flags == -1) return -1;
    return ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);
}

inline int set_nonblock(int fd) {
    int flags = ::fcntl(fd, F_GETFL, 0);
    if (flags == -1) return -1;
    return ::fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}
```

> **실무 팁**: Linux에서는 `socket(..., SOCK_CLOEXEC, ...)` 같은 *_CLOEXEC* 플래그가 있으면 **원샷**으로 설정(TOCTOU 방지). 없으면 위처럼 `fcntl`로 보정.

#### 사용 예와 누수 방지

```cpp
#include "unique_fd.hpp"
#include <sys/socket.h>

unique_fd make_tcp_socket() {
    int s = ::socket(AF_INET, SOCK_STREAM /*| SOCK_CLOEXEC*/, 0);
    if (s == -1) return unique_fd{};               // 빈 소유자(무효)
    set_cloexec(s);                                 // 예: CLOEXEC 보정
    return unique_fd{adopt_fd, s};                  // 소유권 이전
}

void demo_scope() {
    auto s = make_tcp_socket();
    if (!s) return;                                 // 실패 시 자동 정리 불필요
    // ... 중간에 여러 return/catch가 있어도 RAII가 close 보장
}
```

---

### `std::expected`로 오류 모델 정리 (`std::error_code` 연결)

#### 왜 `expected`인가?

- 예외 기반/코드 기반 오류 전파 중, 네트워킹은 **에러가 정상 흐름**처럼 자주 발생(EINTR/EAGAIN/ETIMEDOUT…).
- `std::expected<T, std::error_code>`는 “**성공 값** 또는 **명시적 오류**”를 담아 **분기 가독성**과 **조합성**을 높인다.

#### `errno` → `std::error_code` 헬퍼

```cpp
#include <system_error>
#include <cerrno>

inline std::error_code last_errno() {
    return std::error_code(errno, std::generic_category());
}
```

> `getaddrinfo()` 처럼 `errno`를 쓰지 않는 API는 `std::errc::invalid_argument` 등으로 매핑하거나 **별도 enum**으로 포장.

#### 소켓 유틸의 반환 타입

```cpp
#include <expected>

// 예: connect 유틸
std::expected<unique_fd, std::error_code>
tcp_connect(const sockaddr* sa, socklen_t len) {
    int s = ::socket(sa->sa_family, SOCK_STREAM, 0);
    if (s == -1) return std::unexpected(last_errno());
    set_cloexec(s);
    if (::connect(s, sa, len) == -1) {
        auto ec = last_errno();
        ::close(s);
        return std::unexpected(ec);
    }
    return unique_fd{adopt_fd, s};
}
```

#### 조합 사용—명료한 오류 전파

```cpp
auto s = tcp_connect((sockaddr*)&addr, sizeof(addr));
if (!s) {
    std::print(stderr, "[connect] {}\n", s.error().message());
    return; // 명확한 실패 경로
}
```

---

### `std::span<std::byte>` / `std::string_view` 로 바이트/문자열 뷰 다루기

#### 경계가 명확한 바이트 중심 설계

- 네트워크 I/O는 **바이트 배열** 단위가 자연스럽다 → **`std::byte`** 사용 권장(의도 명확·산술 금지).
- `std::span<T>`는 **소유하지 않는 뷰**: 길이·범위를 함께 들고다니며 **범위 오류**를 예방.

#### 안전한 부분 입출력 루틴(블로킹)

```cpp
#include <span>
#include <expected>

std::expected<std::size_t, std::error_code>
send_all(int fd, std::span<const std::byte> buf) {
    std::size_t sent = 0;
    while (sent < buf.size()) {
        ssize_t n = ::send(fd, buf.data() + sent, buf.size() - sent, 0);
        if (n > 0) { sent += static_cast<std::size_t>(n); continue; }
        if (n == 0) break;
        if (errno == EINTR) continue;
        return std::unexpected(last_errno());
    }
    return sent;
}

std::expected<std::size_t, std::error_code>
recv_exact(int fd, std::span<std::byte> buf) {
    std::size_t got = 0;
    while (got < buf.size()) {
        ssize_t n = ::recv(fd, buf.data() + got, buf.size() - got, 0);
        if (n > 0) { got += static_cast<std::size_t>(n); continue; }
        if (n == 0) return std::unexpected(std::make_error_code(std::errc::connection_reset));
        if (errno == EINTR) continue;
        return std::unexpected(last_errno());
    }
    return got;
}
```

#### 프레이밍(길이-프리픽스)에서의 바이트 변환

```cpp
#include <bit>
#include <vector>
#include <cstring>

std::expected<void, std::error_code>
send_frame(int fd, std::span<const std::byte> payload) {
    uint32_t len = static_cast<uint32_t>(payload.size());
    uint32_t be  = htonl(len);
    if (!send_all(fd, std::as_bytes(std::span{&be, 1}))) return std::unexpected(last_errno());
    if (!send_all(fd, payload)) return std::unexpected(last_errno());
    return {};
}

std::expected<std::vector<std::byte>, std::error_code>
recv_frame(int fd, std::size_t cap = (1u<<20)) {
    uint32_t be{};
    if (!recv_exact(fd, std::as_writable_bytes(std::span{&be, 1})))
        return std::unexpected(last_errno());
    uint32_t len = ntohl(be);
    if (len > cap) return std::unexpected(std::make_error_code(std::errc::message_size));
    std::vector<std::byte> buf(len);
    if (!recv_exact(fd, std::span<std::byte>(buf.data(), buf.size())))
        return std::unexpected(last_errno());
    return buf;
}
```

> `std::string_view` 는 **텍스트 프로토콜**(예: CRLF 기반) 처리 시 유용. 단, **생명주기**(원본 문자열 유효 기간)를 엄격히 관리.

#### 문자열 뷰→바이트 뷰

```cpp
#include <string_view>

std::expected<void, std::error_code>
send_text_line(int fd, std::string_view s) {
    // 끝에 '\n' 붙여 전송
    std::array<std::byte, 1> nl{std::byte{'\n'}};
    if (!send_all(fd, std::as_bytes(std::span{s.data(), s.size()}))) return std::unexpected(last_errno());
    if (!send_all(fd, nl)) return std::unexpected(last_errno());
    return {};
}
```

---

### `std::print`, `std::chrono`, `std::format`(선택) 활용 가이드

#### 로깅/관측: `std::print` (C++23)

- `printf`의 포맷 안정성 문제 없이 **타입 안전 + 간결한 문법**.
```cpp
#include <print>

std::print(stderr, "[tcp] connected to {}:{}\n", "203.0.113.10", 9000);
```

#### 시간과 타임아웃: `std::chrono` 중심

- I/O 타임아웃은 **두 방식**이 흔하다.
  1) `SO_RCVTIMEO`/`SO_SNDTIMEO` 소켓 옵션(커널 레벨)
  2) `poll`/`epoll`/deadline 루프(유저 레벨)

##### (a) 소켓 옵션으로 타임아웃 설정

```cpp
#include <chrono>
#include <sys/socket.h>

inline timeval to_timeval(std::chrono::milliseconds ms) {
    timeval tv{};
    tv.tv_sec  = static_cast<long>(ms.count() / 1000);
    tv.tv_usec = static_cast<long>((ms.count() % 1000) * 1000);
    return tv;
}
void set_timeouts(int fd, std::chrono::milliseconds recv_to, std::chrono::milliseconds send_to) {
    auto r = to_timeval(recv_to);
    auto s = to_timeval(send_to);
    ::setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &r, sizeof(r));
    ::setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &s, sizeof(s));
}
```

##### (b) 데드라인 기반 `recv_exact` 변형(요지)

- 소켓을 논블로킹으로 전환 후 **남은 시간**을 계산하면서 `poll`로 이벤트 대기.
```cpp
#include <poll.h>

std::expected<std::size_t, std::error_code>
recv_exact_deadline(int fd, std::span<std::byte> buf, std::chrono::steady_clock::time_point deadline) {
    std::size_t got = 0;
    set_nonblock(fd);
    while (got < buf.size()) {
        ssize_t n = ::recv(fd, buf.data() + got, buf.size() - got, 0);
        if (n > 0) { got += (size_t)n; continue; }
        if (n == 0) return std::unexpected(std::make_error_code(std::errc::connection_reset));
        if (errno != EAGAIN && errno != EWOULDBLOCK) return std::unexpected(last_errno());

        auto now = std::chrono::steady_clock::now();
        if (now >= deadline) return std::unexpected(std::make_error_code(std::errc::timed_out));
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(deadline - now).count();
        pollfd pfd{.fd=fd, .events=POLLIN, .revents=0};
        int rc = ::poll(&pfd, 1, static_cast<int>(ms));
        if (rc == 0) return std::unexpected(std::make_error_code(std::errc::timed_out));
        if (rc < 0 && errno != EINTR) return std::unexpected(last_errno());
    }
    return got;
}
```

> **시간 복잡도 주의**: 데드라인·논블로킹 루프는 **상태 머신**으로 구조화하면 epoll 전환이 수월하다.

#### `std::format`(선택)과 바이너리 덤프

- 대량 로그에는 `std::print`가 충분. 특정 포맷이 필요하면 `std::format` 활용.
- 바이트 덤프(hexdump)는 **관측성**에 매우 유용.

```cpp
#include <print>

inline void hexdump(std::span<const std::byte> s) {
    std::size_t i = 0;
    for (auto b : s) {
        if (i % 16 == 0) std::print("{:08X}  ", (unsigned)i);
        std::print("{:02X} ", (unsigned)std::to_integer<unsigned char>(b));
        if (++i % 16 == 0) std::print("\n");
    }
    if (i % 16) std::print("\n");
}
```

---

### 미니 통합 예제 — “연결 → 프레임 전송 → 응답 수신(타임아웃·로그 포함)”

```cpp
// mini_client.cpp (요지): C++23 스타일 바인딩 + 프레이밍 + 타임아웃 + 관측
#include <print>
#include <vector>
#include <string>
#include <chrono>
#include <netdb.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <expected>
#include <cstring>
#include "unique_fd.hpp"

// errno -> error_code
inline std::error_code last_errno(){ return {errno, std::generic_category()}; }

std::expected<unique_fd, std::error_code>
connect_host_port(const char* host, const char* port) {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_ADDRCONFIG;
    int rc = ::getaddrinfo(host, port, &hints, &res);
    if (rc != 0) return std::unexpected(std::make_error_code(std::errc::invalid_argument));
    unique_fd s;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        int fd = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (fd < 0) continue;
        set_cloexec(fd);
        if (::connect(fd, ai->ai_addr, ai->ai_addrlen) == 0) { s.reset(fd); break; }
        ::close(fd);
    }
    ::freeaddrinfo(res);
    if (!s) return std::unexpected(last_errno());
    return s;
}

// 앞서 정의한 send_all/recv_exact/send_frame/recv_frame를 가정
// (실전에서는 공용 유틸 헤더에 배치)

int main(int argc, char** argv) {
    const char* host = (argc > 1) ? argv[1] : "127.0.0.1";
    const char* port = (argc > 2) ? argv[2] : "9000";
    std::string msg  = (argc > 3) ? argv[3] : "hello";

    auto s = connect_host_port(host, port);
    if (!s) {
        std::print(stderr, "[connect] {}\n", s.error().message());
        return 1;
    }
    set_timeouts(s->get(), std::chrono::seconds(3), std::chrono::seconds(3));
    std::print("[tcp] connected to {}:{}\n", host, port);

    std::vector<std::byte> payload(msg.size());
    std::memcpy(payload.data(), msg.data(), msg.size());
    if (auto ok = send_frame(s->get(), payload); !ok) {
        std::print(stderr, "[send_frame] {}\n", ok.error().message()); return 2;
    }
    auto echo = recv_frame(s->get(), 1<<20);
    if (!echo) {
        std::print(stderr, "[recv_frame] {}\n", echo.error().message()); return 3;
    }
    std::string echoed(reinterpret_cast<const char*>(echo->data()), echo->size());
    std::print("[echo] {}\n", echoed);
    return 0;
}
```

---

### 안정성 체크리스트

- **RAII**
  - [ ] 모든 **소유 자원**은 클래스/스마트핸들에 묶었는가?
  - [ ] **복사 금지 / 이동만 허용**으로 소유권을 단일화했는가?
  - [ ] `CLOEXEC` 기본 적용으로 **fd 누출**을 막았는가?

- **오류 흐름**
  - [ ] 함수 반환은 `std::expected<T, std::error_code>` 로 **명시적**인가?
  - [ ] `errno` → `std::error_code` 변환 일원화되어 있는가?
  - [ ] `getaddrinfo` 류의 특수 에러는 **일관 매핑**했는가?

- **I/O 계약**
  - [ ] **부분 입출력**을 전제로 `send_all`/`recv_exact`를 사용했는가?
  - [ ] **프레이밍**(길이-프리픽스/구분자)을 강제했는가?
  - [ ] **size cap**(예: 16MB)을 둬서 메모리 고갈을 막았는가?

- **시간·로그**
  - [ ] `std::chrono` 기반의 **타임아웃** 정책이 있는가?
  - [ ] `std::print` 로 **일관된 로그 포맷**을 쓰는가(레벨/태그 포함 권장)?
  - [ ] 실패 로그는 반드시 **에러 메시지**를 포함하는가?

---

### 성능·지연에 관한 짧은 수식(직관)

- **지수 백오프**(재시도 정책):
  $$
  t_k = \min\{t_{\max},\ t_0 \cdot 2^k\}
  $$
- **대역폭–지연곱(BDP)**:
  $$
  \text{BDP} = \text{Bandwidth} \times \text{RTT}
  $$
  충분한 버퍼가 없으면 파이프를 **채우지 못해 처리량 손실**.
- **손실 환경 처리량 근사**(TCP Reno 직관):
  $$
  \text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}}
  $$
  \(p\)는 손실 확률. 작은 메시지 난사 시 **헤더·ACK·지연 영향**이 더 커진다 → **coalescing** 또는 `TCP_NODELAY` 선택.

---

### 흔한 함정과 방어

- **구조체 직렬화 함정**: 엔디안·패딩·정렬. → **명시적 encode/decode** 로 해결.
- **SIGPIPE**: 끊긴 소켓에 `send` 시 프로세스가 죽을 수 있음. → `MSG_NOSIGNAL`(Linux) 또는 `SO_NOSIGPIPE`(BSD)/신호 무시.
- **`std::string_view` 생명주기**: 원본 문자열보다 오래 살지 않도록 주의.
- **논블로킹 전환 누락**: 데드라인 루프에서 EAGAIN 처리를 빼먹지 말 것.
- **CLOEXEC 미설정**: `exec` 경로에서 fd 유출 → 보안/기능 장애.

---

### 요약

- **RAII `unique_fd`** 로 누수를 원천 차단하고, **CLOEXEC/논블로킹** 등을 **정책화**한다.
- **`std::expected` + `std::error_code`** 로 **명시적 오류 경로**를 표준화한다.
- **`std::span<std::byte>`/`std::string_view`** 로 **바이트·문자열 경계**를 명확히 한다.
- **`std::print`/`std::chrono`** 로 **관측성**(로그)과 **시간 정책**(타임아웃)을 일관되게 한다.
