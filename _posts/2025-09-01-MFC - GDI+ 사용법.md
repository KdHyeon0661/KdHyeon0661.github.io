---
layout: post
title: MFC - GDI+ 사용법
date: 2025-09-01 16:25:23 +0900
category: MFC
---
# GDI+ 사용법: PNG/JPEG 로드, 안티앨리어싱, 알파 블렌딩 (MFC/Win32 실전 총정리 · 예제 다수)

이 글은 **GDI+**로 **PNG/JPEG 로드**, **안티앨리어싱(도형/텍스트/이미지 스케일)**, **알파 블렌딩(투명도/컬러 매트릭스/합성 모드)**를 **처음 붙이는 단계부터** 실전에 바로 쓰도록 정리했습니다.  
모든 코드는 **복붙 가능한 C++(MFC/Win32)** 스니펫 위주입니다.

> 대상: MFC SDI/MDI/대화상자 앱, Windows 10/11, x64/Unicode 권장  
> 링크: `gdiplus.lib` / 헤더: `<gdiplus.h>` / 네임스페이스: `Gdiplus`

---

## 0) GDI+ 개요 & 스타트업

### 0-1. 무엇이 좋은가
- **PNG 알파**(32bpp) & **JPEG** 등 **코덱 내장** → 파일/메모리/스트림 로딩 간단
- **안티앨리어싱**: 부드러운 선/곡선/텍스트
- **고품질 스케일링**: Bicubic/HighQuality 등
- **알파 블렌딩**: 전역 투명도, 컬러 매트릭스, 합성 모드 제어

### 0-2. 초기화/해제 (RAII 추천)
```cpp
// App or module-level
#include <gdiplus.h>
#pragma comment(lib, "gdiplus.lib")
using namespace Gdiplus;

class CGdiplusInit {
    ULONG_PTR m_token = 0;
public:
    CGdiplusInit() {
        GdiplusStartupInput si;
        GdiplusStartup(&m_token, &si, nullptr);
    }
    ~CGdiplusInit() {
        if (m_token) GdiplusShutdown(m_token);
    }
};

// 예: CWinApp::InitInstance에서 정적/멤버로 보관
// static CGdiplusInit s_gdip;
```
> **중요**: **프로세스 생명주기 전체**에서 1회 초기화/종료. 쓰레드별 초기화는 필요 없음(단, GDI+는 완전한 스레드 안전 아님 → UI 스레드에서 사용 권장).

---

## 1) 이미지 로드: 파일/리소스/메모리/스트림

### 1-1. 파일에서 읽기 (PNG/JPEG)
```cpp
std::unique_ptr<Image> LoadImageFromFile(const wchar_t* path) {
    auto img = std::make_unique<Image>(path);
    if (img->GetLastStatus() != Ok) return nullptr;
    return img;
}

// 사용
auto png = LoadImageFromFile(L"assets\\logo.png");
auto jpg = LoadImageFromFile(L"assets\\photo.jpg");
```

### 1-2. 리소스에서 읽기 (RT_RCDATA or 사용자형)
```cpp
// 1) 리소스 → HGLOBAL 복사 → 2) IStream 생성 → 3) Image::FromStream
std::unique_ptr<Image> LoadImageFromResource(HINSTANCE hInst, UINT id, LPCWSTR type) {
    HRSRC hRes = FindResource(hInst, MAKEINTRESOURCE(id), type);
    if (!hRes) return nullptr;
    DWORD size = SizeofResource(hInst, hRes);
    HGLOBAL hData = LoadResource(hInst, hRes);
    if (!hData) return nullptr;

    void* pRes = LockResource(hData);
    HGLOBAL hBuf = GlobalAlloc(GMEM_MOVEABLE, size);
    if (!hBuf) return nullptr;
    void* pBuf = GlobalLock(hBuf);
    memcpy(pBuf, pRes, size);
    GlobalUnlock(hBuf);

    IStream* pStream = nullptr;
    if (CreateStreamOnHGlobal(hBuf, TRUE, &pStream) != S_OK) { GlobalFree(hBuf); return nullptr; }

    auto img = std::unique_ptr<Image>(Image::FromStream(pStream));
    pStream->Release(); // hBuf는 TRUE로 소유권 이동
    if (!img || img->GetLastStatus() != Ok) return nullptr;
    return img;
}

// 사용: LoadImageFromResource(AfxGetResourceHandle(), IDR_PNG1, L"PNG");
```

### 1-3. 메모리(바이트 배열)에서 읽기
```cpp
std::unique_ptr<Image> LoadImageFromBytes(const BYTE* data, size_t len) {
    HGLOBAL h = GlobalAlloc(GMEM_MOVEABLE, len);
    if (!h) return nullptr;
    void* p = GlobalLock(h);
    memcpy(p, data, len);
    GlobalUnlock(h);
    IStream* s=nullptr;
    if (CreateStreamOnHGlobal(h, TRUE, &s) != S_OK) { GlobalFree(h); return nullptr; }
    auto img = std::unique_ptr<Image>(Image::FromStream(s));
    s->Release();
    return (img && img->GetLastStatus()==Ok) ? std::move(img) : nullptr;
}
```

> **TIP**: `Image`는 내부적으로 코덱을 사용해 디코딩. 매 그리기마다 새로 로드하지 말고 **캐시**하세요.

---

## 2) 그리기 준비: Graphics, DPI, 고품질 옵션

### 2-1. Graphics 생성
```cpp
// MFC OnPaint:
void CMyView::OnPaint() {
    CPaintDC dc(this);
    Graphics g(dc); // 화면 DC 기반
    // ... draw with g ...
}
```

### 2-2. DPI/좌표 단위
- 기본 단위: **픽셀(UnitPixel)**  
- 필요 시: `g.SetPageUnit(UnitPixel/UnitPoint/UnitMillimeter…)`  
- DPI 조회: `g.GetDpiX()`, `g.GetDpiY()`  
- **고DPI**에서 **픽셀 단위**는 스케일링이 명확, **포인트/밀리미터**는 인쇄에 유리.

### 2-3. 고품질 렌더링 옵션(핵심 4종)
```cpp
g.SetSmoothingMode(SmoothingModeAntiAlias);                 // 선/곡선 안티앨리어싱
g.SetInterpolationMode(InterpolationModeHighQualityBicubic);// 이미지 스케일
g.SetPixelOffsetMode(PixelOffsetModeHalf);                  // 1px 라인 정밀
g.SetCompositingQuality(CompositingQualityHighQuality);     // 합성 품질
// 텍스트
g.SetTextRenderingHint(TextRenderingHintClearTypeGridFit);  // 텍스트 AA
```
> **성능**: 상시 HighQuality는 비용 큼 → **필요 구간에만** 올렸다 내리기

---

## 3) PNG/JPEG 그리기: DrawImage

### 3-1. 원본 크기로 그리기
```cpp
if (png) g.DrawImage(png.get(), 10, 10);
```

### 3-2. 크기 지정(스케일)
```cpp
Rect dest(10, 10, 300, 200);
g.DrawImage(png.get(), dest); // InterpolationMode 설정이 품질 좌우
```

### 3-3. 소스 영역 → 목적 영역 (크롭/뷰포트)
```cpp
Rect src(100, 80, 400, 300);  // 이미지 안에서 잘라올 영역
Rect dst(10, 10, 240, 180);   // 그릴 목적 사각형
g.DrawImage(png.get(), dst, src.X, src.Y, src.Width, src.Height, UnitPixel);
```

### 3-4. 레터박스/센터 크롭 유틸
```cpp
Rect ComputeLetterBox(const Size& img, const Rect& box) {
    double sx = (double)box.Width / img.Width;
    double sy = (double)box.Height/ img.Height;
    double s = min(sx, sy);
    int w = int(img.Width * s);
    int h = int(img.Height* s);
    int x = box.X + (box.Width - w)/2;
    int y = box.Y + (box.Height- h)/2;
    return Rect(x, y, w, h);
}
```

---

## 4) 도형/선/텍스트 안티앨리어싱

### 4-1. 펜/브러시(=GDI+ Pen/Brush)
```cpp
Pen pen(Color(255, 0,120,215), 2.0f);
SolidBrush fill(Color(255, 245,250,255));

g.SetSmoothingMode(SmoothingModeAntiAlias);
g.DrawEllipse(&pen, 50.0f, 50.0f, 200.0f, 120.0f);
g.FillEllipse(&fill, 50.0f, 50.0f, 200.0f, 120.0f);
```

### 4-2. 경로(GraphicsPath) + 곡선
```cpp
GraphicsPath path;
path.AddLine(20,20, 80,60);
path.AddBezier(80,60, 120,10, 160,110, 220,40);
Pen p(Color(255,40,40,40), 3.0f);
p.SetStartCap(LineCapRound); p.SetEndCap(LineCapRound);
p.SetLineJoin(LineJoinRound);

g.SetSmoothingMode(SmoothingModeAntiAlias);
g.DrawPath(&p, &path);
```

### 4-3. 텍스트 품질
```cpp
FontFamily ff(L"Segoe UI");
Font font(&ff, 13.0f, FontStyleRegular, UnitPoint);
SolidBrush text(Color(255,30,30,30));
StringFormat fmt; fmt.SetTrimming(StringTrimmingEllipsisCharacter);

g.SetTextRenderingHint(TextRenderingHintClearTypeGridFit);
g.DrawString(L"안녕하세요 GDI+!", -1, &font, PointF(20,20), &fmt, &text);
```

---

## 5) 알파 블렌딩: 전역 투명도/합성 모드/컬러 매트릭스

### 5-1. 전역 투명도(0~255)
- **도형/텍스트**: `Color(a,r,g,b)`의 **a** 값  
- **이미지**: `ImageAttributes` + **ColorMatrix**로 전역 알파

```cpp
// 이미지 전역 투명도
ImageAttributes ia;
ColorMatrix m = {
    1,0,0,0,0,
    0,1,0,0,0,
    0,0,1,0,0,
    0,0,0,0.5f,0,   // A' = A * 0.5
    0,0,0,0,1
};
ia.SetColorMatrix(&m, ColorMatrixFlagsDefault, ColorAdjustTypeBitmap);

Rect d(10,10,300,200);
g.DrawImage(png.get(), d, 0,0,png->GetWidth(),png->GetHeight(), UnitPixel, &ia);
```

### 5-2. 합성 모드(겹치기 방식)
```cpp
// SourceOver(기본): 아래 픽셀과 알파 합성
g.SetCompositingMode(CompositingModeSourceOver);
// SourceCopy: 아래 무시, 소스 그대로 덮음(알파 유지)
g.SetCompositingMode(CompositingModeSourceCopy);
```
> *레이어드 윈도우(투명 창) 합성 등 특별한 경우에 SourceCopy가 필요할 때가 있음.*

### 5-3. 특정 색상 누끼(컬러 치환)
```cpp
ImageAttributes ia;
ColorMap map{};
map.oldColor = Color(255,255,0,255);   // Magenta를
map.newColor = Color(0,0,0,0);         // 투명으로 치환
ia.SetRemapTable(1, &map);

g.DrawImage(png.get(), 10,10, png->GetWidth(), png->GetHeight());
```

### 5-4. 톤/채도 조절(컬러 매트릭스)
```cpp
// 그레이스케일
ColorMatrix gray = {
    0.299f,0.299f,0.299f,0,0,
    0.587f,0.587f,0.587f,0,0,
    0.114f,0.114f,0.114f,0,0,
    0,     0,     0,     1,0,
    0,     0,     0,     0,1
};
ImageAttributes attr;
attr.SetColorMatrix(&gray);
g.DrawImage(png.get(), Rect(10,10,200,150), 0,0,png->GetWidth(),png->GetHeight(), UnitPixel, &attr);
```

---

## 6) 더블 버퍼링(오프스크린) with GDI+ Bitmap

### 6-1. 백버퍼 Bitmap + Graphics::FromImage
```cpp
class CCanvas {
    std::unique_ptr<Bitmap>   m_back; // 32bpp ARGB
    std::unique_ptr<Graphics> m_gg;

public:
    void Resize(int w, int h) {
        m_back.reset(new Bitmap(w, h, PixelFormat32bppPARGB)); // 프레멀티플 권장
        m_gg.reset(Graphics::FromImage(m_back.get()));
        m_gg->SetSmoothingMode(SmoothingModeAntiAlias);
        m_gg->SetInterpolationMode(InterpolationModeHighQualityBicubic);
    }
    Graphics& G() { return *m_gg; }
    Bitmap*   B() { return m_back.get(); }
};

void CMyView::OnSize(UINT, int cx, int cy) {
    m_canvas.Resize(cx, cy);
    Invalidate(FALSE);
}

void CMyView::OnPaint() {
    CPaintDC dc(this);
    Graphics g(dc);
    if (!m_canvas.B()) { CRect rc; GetClientRect(&rc); m_canvas.Resize(rc.Width(), rc.Height()); }

    auto& gg = m_canvas.G();
    gg.Clear(Color(255,255,255,255));
    Pen p(Color(255,0,120,215), 2.0f);
    gg.DrawRectangle(&p, 20,20, 200,120);
    if (png) gg.DrawImage(png.get(), 40,40, 160,100);

    g.DrawImage(m_canvas.B(), 0,0); // 한 번에 화면 복사
}
```
> **플리커 제로**: `OnEraseBkgnd`에서 TRUE 반환하여 배경 지우기 방지(백버퍼에서 채움).

---

## 7) JPEG 저장 품질/PNG 저장

### 7-1. 인코더 CLSID 찾기 헬퍼
```cpp
CLSID GetEncoderClsid(const WCHAR* mime) {
    UINT num=0, size=0;
    GetImageEncodersSize(&num, &size);
    std::unique_ptr<BYTE[]> buf(new BYTE[size]);
    auto p = (ImageCodecInfo*)buf.get();
    GetImageEncoders(num, size, p);
    for (UINT i=0; i<num; ++i) if (wcscmp(p[i].MimeType, mime)==0) return p[i].Clsid;
    return CLSID{};
}
```

### 7-2. JPEG 품질 저장 (0~100)
```cpp
CLSID clsid = GetEncoderClsid(L"image/jpeg");
EncoderParameters ep; ep.Count = 1;
ULONG quality = 90;
ep.Parameter[0].Guid  = EncoderQuality;
ep.Parameter[0].Type  = EncoderParameterValueTypeLong;
ep.Parameter[0].NumberOfValues = 1;
ep.Parameter[0].Value = &quality;

Bitmap out(800,600, PixelFormat32bppPARGB);
// ... 그리기 ...
out.Save(L"out.jpg", &clsid, &ep);
```

### 7-3. PNG 저장
```cpp
CLSID pngClsid = GetEncoderClsid(L"image/png");
out.Save(L"out.png", &pngClsid, nullptr);
```

---

## 8) GDI와의 혼용 팁

- **같은 HDC**에 **GDI+ Graphics**와 **GDI**를 **교대로** 쓰는 건 가능하나, **픽셀 오프셋/클리핑** 차이로 결과가 흔들릴 수 있음.  
- 안전한 패턴:  
  1) GDI+로 백버퍼(Bitmap) 전부 그림  
  2) 마지막에 **GDI**의 `BitBlt`로 화면 복사  
- 또는 한 프레임 내에서 **Graphics g(dc)** 으로만 처리.

---

## 9) 예제 1 — PNG 버튼(호버/클릭 투명도)

```cpp
class CPngButton : public CWnd {
    std::unique_ptr<Image> m_img;
    float m_alpha = 0.7f; // 기본 70%
    bool  m_hot = false, m_down = false;

public:
    BOOL Create(CWnd* p, CRect r, UINT id) {
        CString cls = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW, LoadCursor(nullptr, IDC_HAND));
        return CWnd::CreateEx(0, cls, L"", WS_CHILD|WS_VISIBLE, r, p, id);
    }
    void SetImage(std::unique_ptr<Image> img) { m_img = std::move(img); Invalidate(); }

protected:
    afx_msg void OnPaint() {
        CPaintDC dc(this);
        Graphics g(dc);
        g.SetSmoothingMode(SmoothingModeAntiAlias);
        g.SetInterpolationMode(InterpolationModeHighQualityBicubic);

        CRect rc; GetClientRect(&rc);
        g.Clear(Color(0,0,0,0));

        ImageAttributes ia;
        float a = m_down ? 0.5f : (m_hot ? 1.0f : m_alpha);
        ColorMatrix cm = { 1,0,0,0,0,  0,1,0,0,0,  0,0,1,0,0,  0,0,0,a,0,  0,0,0,0,1 };
        ia.SetColorMatrix(&cm);

        if (m_img) g.DrawImage(m_img.get(), Rect(0,0,rc.Width(),rc.Height()),
                               0,0,m_img->GetWidth(),m_img->GetHeight(), UnitPixel, &ia);
    }
    afx_msg BOOL OnEraseBkgnd(CDC*) { return TRUE; }
    afx_msg void OnMouseMove(UINT, CPoint){ if (!m_hot){ m_hot=true; Invalidate(FALSE);} TRACKMOUSEEVENT t{sizeof(t), TME_LEAVE, m_hWnd, 0}; TrackMouseEvent(&t); }
    afx_msg void OnMouseLeave(){ m_hot=false; Invalidate(FALSE); }
    afx_msg void OnLButtonDown(UINT, CPoint){ m_down=true; SetCapture(); Invalidate(FALSE); }
    afx_msg void OnLButtonUp(UINT, CPoint){ if (m_down){ m_down=false; ReleaseCapture(); Invalidate(FALSE); GetParent()->SendMessage(WM_COMMAND, GetDlgCtrlID()); } }
    DECLARE_MESSAGE_MAP()
};
BEGIN_MESSAGE_MAP(CPngButton, CWnd)
    ON_WM_PAINT()
    ON_WM_ERASEBKGND()
    ON_WM_MOUSEMOVE()
    ON_MESSAGE(WM_MOUSELEAVE, [](WPARAM, LPARAM){ return 0L; })
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
END_MESSAGE_MAP()
```

---

## 10) 예제 2 — 레이어드 윈도우(모서리 둥근 팝업) with UpdateLayeredWindow

> 투명 창에 GDI+로 그려서 **알파 포함 비트맵**으로 한 번에 업데이트

```cpp
class CToast : public CWnd {
    Size m_sz{300,120};
public:
    BOOL Create(CWnd* owner) {
        CString cls = AfxRegisterWndClass(0);
        DWORD ex = WS_EX_TOPMOST|WS_EX_TOOLWINDOW|WS_EX_LAYERED;
        return CWnd::CreateEx(ex, cls, L"", WS_POPUP, CRect(0,0,m_sz.Width,m_sz.Height), owner, 0);
    }
    void ShowAt(CPoint pt) {
        RenderAndApply(pt);
        ShowWindow(SW_SHOWNOACTIVATE);
    }
private:
    void RenderAndApply(CPoint pt) {
        // 1) 백버퍼 (GDI+ Bitmap)
        std::unique_ptr<Bitmap> bmp(new Bitmap(m_sz.Width, m_sz.Height, PixelFormat32bppPARGB));
        std::unique_ptr<Graphics> g(Graphics::FromImage(bmp.get()));
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        g->Clear(Color(0,0,0,0));
        // 2) 배경 말풍선
        SolidBrush bg(Color(220, 30,30,30));
        GraphicsPath path;
        RectF r(0,0,(REAL)m_sz.Width,(REAL)m_sz.Height);
        REAL radius = 12.0f;
        // round rect
        path.AddArc(r.X, r.Y, radius*2, radius*2, 180, 90);
        path.AddArc(r.Width-radius*2, r.Y, radius*2, radius*2, 270, 90);
        path.AddArc(r.Width-radius*2, r.Height-radius*2, radius*2, radius*2, 0, 90);
        path.AddArc(r.X, r.Height-radius*2, radius*2, radius*2, 90, 90);
        path.CloseFigure();
        g->FillPath(&bg, &path);
        // 3) 텍스트
        FontFamily ff(L"Segoe UI");
        Font f(&ff, 10.0f, FontStyleRegular, UnitPoint);
        SolidBrush white(Color(230,255,255,255));
        g->DrawString(L"작업이 완료되었습니다.", -1, &f, PointF(16, 16), &white);

        // 4) UpdateLayeredWindow
        HDC hdcScreen = GetDC(nullptr);
        HDC hdcMem = CreateCompatibleDC(hdcScreen);
        HBITMAP hBmpNative = nullptr;
        bmp->GetHBITMAP(Color(0,0,0,0), &hBmpNative); // ARGB → HBITMAP
        HBITMAP hOld = (HBITMAP)SelectObject(hdcMem, hBmpNative);

        POINT src = {0,0};
        SIZE  sz  = {m_sz.Width, m_sz.Height};
        POINT dst = pt;
        BLENDFUNCTION bf{ AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
        UpdateLayeredWindow(m_hWnd, hdcScreen, &dst, &sz, hdcMem, &src, 0, &bf, ULW_ALPHA);

        SelectObject(hdcMem, hOld);
        DeleteObject(hBmpNative);
        DeleteDC(hdcMem);
        ReleaseDC(nullptr, hdcScreen);
    }
};
```
> 핵심: **PixelFormat32bppPARGB**로 렌더 → `GetHBITMAP` → `UpdateLayeredWindow(ULW_ALPHA)`

---

## 11) 성능/안정성 체크리스트

1. **이미지 캐시**: `Image`/`Bitmap`를 매 그리기마다 다시 로드하지 말 것  
2. **품질 모드 on/off**: 확대/미세 라인에만 HighQuality, 평소는 기본  
3. **더블 버퍼**: GDI+ `Bitmap` + `Graphics::FromImage` 후 화면에 한 번의 `DrawImage`  
4. **픽셀 정렬**: 1px 라인은 `PixelOffsetModeHalf` + 좌표 `+0.5f` 기법 고려  
5. **스레드**: 디코딩/파일 IO는 워커 스레드, **그리기는 UI 스레드**에서  
6. **리소스 누수**: `ImageAttributes`, `Pen/Brush/Font`, `IStream` Release 철저  
7. **컬러관리**: GDI+는 기본 sRGB 가정. 고급 CM 필요하면 별도 라이브러리 고려  
8. **대용량 이미지**: `GetThumbnailImage`/타일링/스트리밍(메모리 폭주 주의)

---

## 12) 문제 해결 가이드

| 증상 | 원인 | 해결 |
|---|---|---|
| PNG 투명 배경이 검정/회색으로 보임 | 알파 미합성 | `CompositingModeSourceOver` + 올바른 대상 배경색에 그리기 |
| DrawImage가 뭉개짐 | Interpolation 기본값 | `SetInterpolationMode(HighQualityBicubic)` |
| 1px 선이 흐릿 | 픽셀 중앙 정렬 문제 | `PixelOffsetModeHalf` + 좌표 0.5f 보정 |
| 깜빡임 | 화면 지우기 → 다시 그림 | **더블 버퍼** + `OnEraseBkgnd=TRUE` |
| 속도 저하 | 매번 고품질 모드/디코딩 | 품질 모드 범위 축소 / 이미지 캐시 |
| 리소스 핸들 누수 | IStream/Bitmap 해제 누락 | 스마트 포인터/`Release()` 확인 |
| 레이어드 윈도우 톱니 | SmoothingMode 미설정 | `SmoothingModeAntiAlias`로 경계 부드럽게 |

---

## 13) “통합 샘플” — 뷰에서 PNG/JPEG/도형/텍스트/알파/스케일

```cpp
class CPhotoView : public CView {
    std::unique_ptr<Image> m_png, m_jpg;
    float m_scale = 1.0f;
protected:
    void OnInitialUpdate() override {
        CView::OnInitialUpdate();
        m_png = LoadImageFromFile(L"assets\\overlay.png");
        m_jpg = LoadImageFromFile(L"assets\\background.jpg");
    }
    afx_msg void OnPaint() {
        CPaintDC dc(this);
        Graphics g(dc);
        g.SetSmoothingMode(SmoothingModeAntiAlias);
        g.SetInterpolationMode(InterpolationModeHighQualityBicubic);
        g.SetCompositingQuality(CompositingQualityHighQuality);
        g.Clear(Color(255,255,255,255));

        CRect rc; GetClientRect(&rc);
        if (m_jpg) {
            Rect dst = ComputeLetterBox(Size(m_jpg->GetWidth(), m_jpg->GetHeight()),
                                        Rect(0,0, rc.Width(), rc.Height()));
            g.DrawImage(m_jpg.get(), dst);
        }

        // 반투명 오버레이
        if (m_png) {
            ImageAttributes ia;
            ColorMatrix cm = { 1,0,0,0,0,  0,1,0,0,0,  0,0,1,0,0,  0,0,0,0.7f,0,  0,0,0,0,1 };
            ia.SetColorMatrix(&cm);

            int w = int(m_png->GetWidth() * m_scale);
            int h = int(m_png->GetHeight()* m_scale);
            Rect d((rc.Width()-w)/2, (rc.Height()-h)/2, w, h);
            g.DrawImage(m_png.get(), d, 0,0,m_png->GetWidth(),m_png->GetHeight(), UnitPixel, &ia);
        }

        // 텍스트
        FontFamily ff(L"Segoe UI");
        Font f(&ff, 12.0f, FontStyleRegular, UnitPoint);
        SolidBrush text(Color(230,255,255,255));
        g.SetTextRenderingHint(TextRenderingHintClearTypeGridFit);
        g.DrawString(L"GDI+ Demo", -1, &f, PointF(12,12), &text);
    }
    afx_msg BOOL OnMouseWheel(UINT, short zDelta, CPoint) {
        m_scale *= (zDelta>0) ? 1.1f : 0.9f;
        m_scale = std::clamp(m_scale, 0.2f, 4.0f);
        Invalidate(FALSE);
        return TRUE;
    }
    DECLARE_MESSAGE_MAP()
};
BEGIN_MESSAGE_MAP(CPhotoView, CView)
    ON_WM_PAINT()
    ON_WM_MOUSEWHEEL()
END_MESSAGE_MAP()
```

---

## 14) 요약

- **초기화 한 번**(Startup/Shutdown), 이미지 **한 번 로드 후 캐시**  
- **고품질 모드**는 **필요할 때만** 켜서 성능 유지  
- **PNG 알파**는 `ImageAttributes`/`ColorMatrix`로 **전역 투명도** 쉽게 적용  
- **더블 버퍼(오프스크린 Bitmap)** → **한 번의 DrawImage**로 깜빡임 제로  
- 텍스트/선을 **반 픽셀 정렬** + **ClearType/AA** 설정으로 선명하게