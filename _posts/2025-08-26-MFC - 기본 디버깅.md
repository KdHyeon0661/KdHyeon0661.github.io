---
layout: post
title: MFC - 기본 디버깅
date: 2025-08-26 16:25:23 +0900
category: MFC
---
# 기본 디버깅: 예외 / 콜스택 / RTTI / 메모리 누수 검출 (MFC · Visual C++ 실전 가이드)

이 글은 **MFC/Win32 네이티브 C++** 환경에서 가장 자주 쓰는 디버깅 축 4가지—  
**① 예외(Structured/C++/MFC) ② 콜스택(Call Stack) ③ RTTI ④ 메모리/핸들/GDI 누수**—를 **설정·도구·코드·체크리스트**까지 “생략 없이” 정리합니다.

---

## 0) 공통 준비 (프로젝트 설정 체크리스트)

- **구성**: `Debug`로 빌드, 최적화 꺼짐(`/Od`)  
- **PDB**: 디버그 정보 생성(`/Zi`), 링커 `/DEBUG`  
- **런타임**: `Multi-threaded Debug DLL (/MDd)` 권장(디버그 CRT 기능 사용)  
- **RTTI**: `/GR`(기본 활성)  
- **예외**: 보통 `/EHsc` (C++만), **SEH도 C++로 번역**하려면 `/EHa`  
- **런타임 체크**: `/RTC1`(스택/정수 오버런, 초기화 안 된 변수 감지)  
- **MFC**: `_DEBUG`에서 `DEBUG_NEW` 자동 활성(소스 라인 추적)

---

## 1) 예외 디버깅: C++ / SEH / MFC

### 1-1. 예외 유형 요약
- **C++ 예외**: `throw SomeError{}` → `catch(...)` / `catch(const std::exception&)`  
- **SEH(Structured Exception Handling)**: Access Violation(0xC0000005), Divide-by-zero 등 **OS 레벨**  
  - `__try/__except` 또는 **SEH→C++ 변환기**로 처리  
- **MFC 예외**: `CException` 계열(예: `CMemoryException`, `CFileException`)  
  - MFC 매크로 `TRY/CATCH/END_CATCH` 또는 `CATCH_ALL` 사용 가능

### 1-2. Visual Studio에서 “던질 때 중단(Break on throw)”
- `Debug > Windows > Exception Settings`  
  - **C++ Exceptions**, **Win32 Exceptions**에서 **Thrown** 체크 → **1차 예외** 발생 지점에서 중단  
  - Access Violation 같은 SEH는 **Win32 Exceptions > Access violation** 활성

### 1-3. MFC 스타일 핸들링
```cpp
// MFC 예외: CException 포인터 사용, 반드시 Delete() 호출
TRY
{
    CFile f(_T("data.bin"), CFile::modeRead);
    // ...
}
CATCH(CFileException, e)
{
    e->ReportError();  // 메시지 박스
    e->Delete();       // ★ 누수 방지
}
END_CATCH
```

### 1-4. SEH → C++ 변환 (모든 예외 잡아야 할 때)
```cpp
#include <eh.h>
void SehTranslator(unsigned, EXCEPTION_POINTERS*) { throw std::runtime_error("SEH"); }

int main() {
    _set_se_translator(SehTranslator); // /EHa 권장
    try {
        int* p = nullptr; *p = 1;      // Access Violation → std::runtime_error
    } catch (const std::exception& e) {
        // 콜스택을 이 위치에서 확인 가능
    }
}
```

> **팁**  
> - `/EHa`는 비용이 있으므로 **광범위 핸들링 구간**에만 사용을 고려.  
> - 라이브러리 경계에서는 **C++ 예외만** 흘러가도록 정책을 일관화하세요.

### 1-5. 전역 크래시 핸들러 & 미니덤프 (선택)
```cpp
// 간단한 Unhandled Filter + 미니덤프 저장
#include <DbgHelp.h>
LONG WINAPI TopLevelFilter(EXCEPTION_POINTERS* p) {
    HANDLE hFile = CreateFile(L"crash.dmp", GENERIC_WRITE,0,nullptr,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,nullptr);
    if (hFile != INVALID_HANDLE_VALUE) {
        MINIDUMP_EXCEPTION_INFORMATION ex{ GetCurrentThreadId(), p, FALSE };
        MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile,
            MiniDumpWithIndirectlyReferencedMemory, &ex, nullptr, nullptr);
        CloseHandle(hFile);
    }
    return EXCEPTION_EXECUTE_HANDLER;
}

int APIENTRY wWinMain(HINSTANCE h, HINSTANCE, LPWSTR, int) {
    SetUnhandledExceptionFilter(TopLevelFilter);
    // ... 앱 시작 ...
}
```
- **주의**: 덤프 저장은 **Release**에도 유용; 반드시 **PDB 보관**(심볼 서버 추천).

---

## 2) 콜스택(Call Stack) 200% 활용

### 2-1. 콜스택 보기
- **중단(Break)** 시 `Debug > Windows > Call Stack`  
- **외부 코드 표시**: “Show External Code” 체크  
- **소스 없는 프레임**: 심볼(`.pdb`)이 필요 → `Tools > Options > Debugging > Symbols`에서  
  - **Microsoft Symbol Servers** + **로컬 캐시 폴더** 설정  
  - 자사 빌드도 **사내 심볼 서버**에 배포해 두면 크래시 재현 불요

### 2-2. 브레이크포인트 기술
- **조건부**: 변수 값/표현식이 참일 때만 타기  
- **히트 카운트**: N번째 호출에서만  
- **함수 브레이크포인트**: 심볼만으로 함수 진입 시 중단  
- **데이터 브레이크포인트**(x64 가능): 메모리 주소 쓰기 감지(Watch → Break when value changes)

### 2-3. “첫 지점으로” 되짚기
- 예외가 최상위에서 잡혔다면, **콜스택에서 아래 프레임으로 더블클릭** → 소스 이동  
- 인라인/최적화로 프레임이 사라지면 **Release 재현 시 어려움** → 최소한 `RelWithDebInfo`(최적화 On + /Zi) 빌드 유지

### 2-4. Just My Code / Step Into Specific
- **Just My Code** 활성 시 서드파티 코드는 스킵  
- **Step Into Specific**(Shift+F11 메뉴)로 원하는 함수만 진입

---

## 3) RTTI: C++ 표준 & MFC 런타임 클래스

### 3-1. C++ RTTI (dynamic_cast / typeid)
- **전제**: **다형적(polymorphic)** 타입(=가상 함수 보유)이어야 `dynamic_cast` 동작
```cpp
struct Base { virtual ~Base(){} };
struct Foo : Base { void f(){} };

Base* p = new Foo;
if (auto* pf = dynamic_cast<Foo*>(p)) { pf->f(); } // 안전 캐스팅
auto& ti = typeid(*p); // "Foo"
```
- **장점**: 표준, 안전. **/GR** 필요(기본 On).  
- **주의**: RTTI 없는 빌드(/GR-) 또는 비다형 타입은 실패.

### 3-2. MFC의 런타임 클래스 정보(CRuntimeClass)
- **매크로**: `DECLARE_DYNAMIC/IMPLEMENT_DYNAMIC` → `IsKindOf` 사용 가능  
- **동적 생성**: `DECLARE_DYNCREATE/IMPLEMENT_DYNCREATE` → `CRuntimeClass::CreateObject()`  
- **패턴**: 문서/뷰/컨트롤 플러그인, 직렬화/복원
```cpp
class CMyView : public CView {
    DECLARE_DYNCREATE(CMyView)
    // ...
};
IMPLEMENT_DYNCREATE(CMyView, CView)

// 사용
CObject* p = RUNTIME_CLASS(CMyView)->CreateObject();
if (p->IsKindOf(RUNTIME_CLASS(CView))) { /* ... */ }
```
- **표준 RTTI vs MFC RTTI**: **혼용 가능**. MFC는 **직렬화/동적 생성**과 특히 궁합이 좋음.

---

## 4) 메모리 / 핸들 / GDI 누수 검출

### 4-1. 디버그 CRT(Visual C++)로 메모리 누수 자동 덤프
```cpp
// stdafx.cpp 혹은 애플리케이션 시작부
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>

int APIENTRY wWinMain(...) {
#ifdef _DEBUG
    // 프로그램 종료 시 자동 누수 덤프
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
    // 리포트 출력 경로 설정(디버그 출력창)
    _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_DEBUG);
#endif
    // ...
}
```
- **결과**: 종료 시 **할당 번호/크기/파일:라인**이 출력  
  - MFC `_DEBUG`에서는 `#define new DEBUG_NEW`가 자동 → **파일/라인 추적** OK

#### 특정 할당 시점에서 중단 (강력)
```cpp
// 누수 로그에 "normal block at 0x..., CRT allocated at ... {12345}"가 보이면
_CrtSetBreakAlloc(12345); // 그 할당이 발생하는 순간 멈춤 (원인 추적)
```

#### 구간별 스냅샷 비교
```cpp
_CrtMemState s1, s2, sDiff;
_CrtMemCheckpoint(&s1);

// 의심 코드 블록 실행

_CrtMemCheckpoint(&s2);
if (_CrtMemDifference(&sDiff, &s1, &s2)) {
    _CrtMemDumpStatistics(&sDiff); // 증가분 요약
    _CrtMemDumpAllObjectsSince(&s1); // 이후 모든 할당 나열
}
```

### 4-2. new/delete 매칭 · 배열 메모
- `new` ↔ `delete` / `new[]` ↔ `delete[]` **쌍 맞추기**  
- MFC 객체를 `new`로 만들고 **부모에 소유권 이전**하지 않으면 **직접 delete** 필요  
- 예외 경로에서 빠져나갈 때 **RAII**(스마트 포인터)로 자동 정리

### 4-3. 스마트 포인터 & RAII
```cpp
#include <memory>
struct HCloser { void operator()(HANDLE h) const { if(h) CloseHandle(h); } };
using unique_handle = std::unique_ptr<std::remove_pointer_t<HANDLE>, HCloser>;

unique_handle h(CreateFile(...));  // 예외/조기 return에도 자동 CloseHandle
```
- **핸들/파일/뮤텍스/매핑** 등에 **전용 RAII 래퍼** 적용(또는 WIL의 `wil::unique_handle`)

### 4-4. GDI/USER 객체 누수
- **CBitmap/CBrush/CPen 등**은 **객체 소멸 시 DeleteObject**가 호출되지만,  
  - `Attach/Detach`를 잘못 쓰면 **소유권이 이동**되어 자동 해제가 안 됨 → 사용 후 `DeleteObject`/`DestroyWindow` 호출 확인  
- **진단**: 작업 관리자 → 열 선택 → **GDI Objects**, **USER Objects** 열 활성화 → 증가 추적  
- **코드 패턴**:
```cpp
// DC 선택/복구 패턴 (리소스 누수·비활성화 방지)
CPaintDC dc(this);
CPen pen(PS_SOLID, 1, RGB(255,0,0));
auto* pOld = dc.SelectObject(&pen);
dc.MoveTo(0,0); dc.LineTo(100,100);
dc.SelectObject(pOld); // ★ 원복 필수
```

### 4-5. VS 진단 도구 / AddressSanitizer
- **Diagnostics Tools**: `Debug > Windows > Show Diagnostic Tools` → **Memory Usage** 스냅샷  
- **AddressSanitizer**(VS 16.9+): `C/C++ > General > Enable Address Sanitizer`  
  - **버퍼 오버런/Use-After-Free** 등 **실시간 탐지**(x64/Win10+), 성능 오버헤드 감수 가치 큼

---

## 5) 현업에서의 디버깅 루틴 (샘플 체크리스트)

1) **예외 중단** 설정: C++/Win32 Thrown → **최초 지점에서 멈춤**  
2) **콜스택 + 로컬/자동/워치**로 원인 변수 확인  
3) **심볼 서버** 연결, 소스 없는 프레임까지 추적  
4) **RTTI**로 안전 다운캐스팅(`dynamic_cast`, `IsKindOf`) → 잘못된 타입 사용 조기 발견  
5) **CRT 누수 플래그** 적용, 종료 로그 확인 → `_CrtSetBreakAlloc(N)`로 역추적  
6) GDI/USER 카운터 모니터링(그림/윈도우 생성-파괴 균형 점검)  
7) 이슈 재현 어려우면 **미니덤프 자동 저장** 배포 → 고객사/운영 환경 로그+덤프 회수  
8) **/RTC1**, **ASan** 등 방어 옵션을 디버그 빌드에 상시 적용

---

## 6) 흔한 문제 · 빠른 처방

| 증상 | 원인 후보 | 처방 |
|---|---|---|
| 크래시, Access Violation | Use-after-free, null/와일드 포인터 | “던질 때 중단”, ASan, 스마트 포인터/RAII 도입 |
| 랜덤 크래시(Release만) | 최적화 영향, 미정의 동작 | `/O2` 유지 + `/Zi` + 릴리즈 PDB, 경계체크 삽입, 초기화 철저 |
| 종료 시 누수 로그 | delete 누락, `Attach/Detach` 남발 | `_CrtSetBreakAlloc`, RAII, 소유권 규칙 문서화 |
| 메뉴/툴바 상태 꼬임 | 예외로 핸들러 조기 탈출 | `try/catch`로 상태 복원, `ON_UPDATE_COMMAND_UI` 최소비용화 |
| GDI Objects 무한 증가 | SelectObject 원복 누락, 윈도우 Destroy 미호출 | “원복 패턴” 필수, `DestroyWindow`/`DeleteObject` 호출 검증 |

---

## 7) 작게 시작해 바로 적용하기 (요약 코드)

```cpp
// 1) 디버그 누수 감지 on (프로그램 시작부)
#ifdef _DEBUG
  #define _CRTDBG_MAP_ALLOC
  #include <crtdbg.h>
  struct DebugHeapInit {
    DebugHeapInit() {
      _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
      _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_DEBUG);
    }
  } _debugHeapInit;
#endif

// 2) 예외 조기 포착(예: main/wWinMain 진입 직후)
SetUnhandledExceptionFilter(TopLevelFilter); // MiniDumpWriteDump 예시 참조

// 3) RTTI 기반 안전 캐스팅 사용
if (auto* pView = dynamic_cast<CMyView*>(pWnd)) { /* ... */ }

// 4) GDI 선택/원복 패턴 습관화
CPaintDC dc(this);
CFont font; font.CreatePointFont(100, _T("Segoe UI"));
auto* old = dc.SelectObject(&font);
dc.TextOut(10,10,_T("Hello"));
dc.SelectObject(old);
```

---

## 8) 결론

- **예외**: “던질 때 중단” + SEH 변환기/전역 필터로 **최초 원인**을 잡아라.  
- **콜스택**: 심볼 서버/PDB 관리가 절반. **프레임 이동**으로 소스 초점까지 당겨라.  
- **RTTI**: 잘못된 다운캐스팅을 **컴파일은 통과해도** 런타임에서 잡아내는 **마지막 안전망**.  
- **누수**: CRT 디버그/ASan/RAII의 삼중 방어. `_CrtSetBreakAlloc`으로 **원점 브레이크**.
