---
layout: post
title: DB - 그룹 함수 (1)
date: 2025-03-14 20:20:23 +0900
category: DB
---
# 집계 함수: 기본 개념과 실무 적용 가이드

## 배경과 SQL의 논리적 실행 순서 이해

집계 함수를 이해하려면 SQL 쿼리의 논리적 실행 순서를 명확히 알아야 합니다. 일반적으로 SQL은 다음과 같은 순서로 처리됩니다:

1. **FROM 및 JOIN**: 테이블에서 데이터를 읽고 필요한 조인을 수행
2. **WHERE**: 개별 행을 기준으로 필터링
3. **GROUP BY**: 행들을 지정된 기준으로 그룹으로 묶음
4. **집계 함수 평가**: 각 그룹에 대해 SUM, AVG, COUNT 등의 집계 연산 수행
5. **HAVING**: 그룹 수준에서 결과를 필터링
6. **SELECT**: 컬럼과 표현식을 계산하고 별칭을 부여
7. **ORDER BY**: 결과를 정렬
8. **LIMIT/OFFSET**: 페이지네이션 적용

이 순서를 이해하면 `WHERE`과 `HAVING`의 차이, 왜 특정 컬럼이 `GROUP BY`에 포함되어야 하는지 같은 중요한 질문들에 정확히 답할 수 있습니다.

---

## 주요 집계 함수와 기본 규칙

### 집계 함수의 공통 특징

- **여러 행을 하나의 값으로 요약**하는 것이 핵심 기능입니다.
- `GROUP BY` 절이 없으면 **전체 테이블을 하나의 그룹**으로 간주합니다.
- 대부분의 집계 함수는 **NULL 값을 무시**하지만, `COUNT(*)`는 예외적으로 모든 행을 셉니다.

### 주요 집계 함수 요약

| 함수 | 의미 | NULL 처리 방식 | 빈 그룹에서의 결과 |
|------|------|---------------|-------------------|
| `COUNT(*)` | 행의 총 개수 | NULL을 포함한 모든 행 | 0 |
| `COUNT(표현식)` | 표현식이 NULL이 아닌 행의 개수 | NULL 값 제외 | 0 |
| `SUM(표현식)` | 표현식 값의 합계 | NULL 값 제외 | NULL |
| `AVG(표현식)` | 표현식 값의 평균 | NULL 값 제외 | NULL |
| `MIN(표현식)` | 표현식의 최소값 | NULL 값 제외 | NULL |
| `MAX(표현식)` | 표현식의 최대값 | NULL 값 제외 | NULL |

**중요한 주의사항**: `SUM`, `AVG`, `MIN`, `MAX` 함수는 빈 입력(WHERE 조건으로 걸러져 아무 행도 없거나 그룹이 비어있는 경우)에서 **NULL을 반환**합니다. 보고서에서 0을 원한다면 `COALESCE` 함수로 명시적으로 처리해야 합니다.

```sql
-- 빈 집계 결과를 방어적으로 처리하는 예시
SELECT
  COALESCE(SUM(sales_amount), 0)  AS total_sales,
  COALESCE(AVG(sales_amount), 0)  AS average_sales,
  COALESCE(MIN(sales_amount), 0)  AS minimum_sales,
  COALESCE(MAX(sales_amount), 0)  AS maximum_sales
FROM daily_sales
WHERE sale_date = DATE '2099-01-01'; -- 미래 날짜로 결과가 비어있을 수 있음
```

---

## 실습을 위한 샘플 데이터 스키마

```sql
-- 공통 예제를 위한 직원 테이블
CREATE TABLE employees (
  employee_id   INT PRIMARY KEY,
  department_id INT,
  job_title     VARCHAR(50),
  employee_name VARCHAR(100),
  salary        DECIMAL(12,2),
  hire_date     DATE,
  email         VARCHAR(200)
);

INSERT INTO employees(employee_id, department_id, job_title, employee_name, salary, hire_date, email) VALUES
(1, 10, 'SALES_REP',   'Alice Johnson',   5000, DATE '2024-01-15', 'alice.j@example.com'),
(2, 10, 'SALES_REP',   'Bob Smith',       6000, DATE '2024-03-01', NULL),
(3, 20, 'HR_SPECIALIST','Carol Davis',     4200, DATE '2023-11-03', 'carol.d@example.com'),
(4, 20, 'HR_MANAGER',  'David Wilson',    NULL, DATE '2022-08-20', NULL),
(5, 30, 'DEV_ENGINEER','Eve Brown',       8000, DATE '2024-07-10', 'eve.b@example.com'),
(6, 30, 'DEV_ENGINEER','Frank Miller',    7700, DATE '2024-07-11', 'frank.m@example.com'),
(7, 30, 'DEV_LEAD',    'Grace Lee',       NULL, DATE '2024-07-12', 'grace.l@example.com');
```

---

## COUNT 함수: 개수 세기의 정확한 사용법

```sql
-- 전체 행 수 계산
SELECT COUNT(*) AS total_employees FROM employees;

-- 급여가 NULL이 아닌 직원 수
SELECT COUNT(salary) AS employees_with_salary FROM employees;

-- 부서별 직원 수
SELECT department_id, COUNT(*) AS employee_count
FROM employees
GROUP BY department_id;

-- 부서별 이메일 등록된 직원 수 (NULL 제외)
SELECT department_id, COUNT(email) AS employees_with_email
FROM employees
GROUP BY department_id;
```

### DISTINCT와 COUNT의 조합

- `COUNT(DISTINCT 표현식)`은 **고유한 값의 개수**를 셉니다.
- **여러 컬럼의 고유 조합 개수**를 세는 방법은 데이터베이스마다 다릅니다.

| 데이터베이스 | `COUNT(DISTINCT 컬럼1, 컬럼2)` 지원 여부 |
|-------------|------------------------------------------|
| MySQL, PostgreSQL | 지원 |
| SQL Server | 단일 표현식만 지원 → `CONCAT`이나 서브쿼리로 우회 |
| Oracle | 전통적으로 단일 표현식만 지원 → 문자열 병합으로 우회 |

```sql
-- MySQL과 PostgreSQL에서의 다중 컬럼 DISTINCT
SELECT COUNT(DISTINCT department_id, job_title) AS unique_department_job_combinations
FROM employees;

-- SQL Server와 Oracle에서의 우회 방법
SELECT COUNT(DISTINCT CONCAT(CAST(department_id AS VARCHAR(10)), '|', job_title)) 
FROM employees;
```

### 대용량 데이터의 근사적 고유값 개수

대규모 데이터셋에서 정확한 고유값 개수를 계산하는 것은 비용이 많이 들 수 있습니다. 일부 데이터베이스는 근사값을 빠르게 계산하는 함수를 제공합니다.

```sql
-- Oracle과 SQL Server의 근사 고유값 개수 함수
SELECT APPROX_COUNT_DISTINCT(email) AS approximate_unique_emails
FROM employees;
```

- **Oracle, SQL Server**: `APPROX_COUNT_DISTINCT()` 함수 제공
- **PostgreSQL**: 확장 기능(`hyperloglog` 등) 또는 기본 `COUNT(DISTINCT)`
- **MySQL**: 기본 제공되지 않음 (플러그인이나 애플리케이션 레벨 구현 필요)

---

## SUM과 AVG 함수: 정밀도와 타입 승격 이해

### 정밀도와 타입 승격 문제

- `AVG(NUMERIC(p, s))` 함수는 데이터베이스에 따라 **정밀도 승격 방식**이 다를 수 있습니다.
- 합산 시 **정수 오버플로**에 주의해야 합니다. 특히 `INT` 타입의 합계는 쉽게 오버플로될 수 있습니다. 필요시 `CAST`로 `DECIMAL` 타입으로 명시적 변환을 해주세요.

```sql
-- 정밀도와 오버플로를 방지하는 안전한 접근법
SELECT
  SUM(CAST(salary AS DECIMAL(18,2))) AS total_salary,
  AVG(CAST(salary AS DECIMAL(18,2))) AS average_salary
FROM employees;
```

### 조건부 평균과 가중 평균

```sql
-- 조건부 평균: 특정 부서의 평균 급여
SELECT AVG(CASE WHEN department_id = 30 THEN salary END) AS average_dev_salary
FROM employees;

-- 가중 평균: 성과 점수와 가중치를 고려한 평균
SELECT
  SUM(score * weight) / NULLIF(SUM(weight), 0) AS weighted_average
FROM performance_scores;
```

> `NULLIF(SUM(weight), 0)`는 0으로 나누는 오류를 방지합니다.

---

## MIN과 MAX 함수: 날짜, 문자열, 숫자 모두에 적용

```sql
-- 전체 최소/최대 급여
SELECT MIN(salary) AS minimum_salary, MAX(salary) AS maximum_salary FROM employees;

-- 부서별 최근 입사일
SELECT department_id, MAX(hire_date) AS latest_hire_date
FROM employees
GROUP BY department_id;
```

**주의사항**:
- 문자열의 `MIN`/`MAX`는 데이터베이스의 **콜레이션(Collation)** 설정에 따라 결과가 달라질 수 있습니다.
- 날짜와 시간대 타입은 세션의 타임존 설정에 영향을 받으므로, 일관된 결과를 위해 명시적으로 처리하는 것이 좋습니다.

---

## 조건부 집계: 모든 데이터베이스에서의 실용적 접근법

대부분의 "필터링된 집계" 요구사항은 **`FILTER` 절(표준 SQL, PostgreSQL 지원)** 또는 **`CASE WHEN` 표현식**으로 해결할 수 있습니다.

```sql
-- PostgreSQL: FILTER 절 사용
SELECT
  COUNT(*)                                                     AS total_employees,
  COUNT(*) FILTER (WHERE department_id = 30)                   AS dev_employee_count,
  SUM(salary) FILTER (WHERE job_title = 'SALES_REP')           AS total_sales_salary,
  AVG(salary) FILTER (WHERE salary >= 7000)                    AS average_high_salary
FROM employees;

-- MySQL, Oracle, SQL Server: CASE WHEN 표현식 사용
SELECT
  COUNT(*)                                                     AS total_employees,
  SUM(CASE WHEN department_id = 30 THEN 1 ELSE 0 END)          AS dev_employee_count,
  SUM(CASE WHEN job_title = 'SALES_REP' THEN salary ELSE 0 END) AS total_sales_salary,
  AVG(CASE WHEN salary >= 7000 THEN salary END)               AS average_high_salary
FROM employees;
```

**이 접근법의 장점**:
- **단일 테이블 스캔**으로 여러 조건의 집계를 동시에 계산할 수 있어 성능이 우수합니다.
- 코드의 가독성이 좋고, 대시보드나 피벗 테이블을 위한 데이터 준비에 유연하게 활용할 수 있습니다.

---

## DISTINCT 집계의 성능 비용과 최적화 전략

`COUNT(DISTINCT x)`, `AVG(DISTINCT x)`, `SUM(DISTINCT x)`와 같은 연산은 내부적으로 **중복 제거(해시 또는 정렬)** 작업을 필요로 하므로 성능 비용이 높을 수 있습니다. 특히 다중 컬럼에 대한 DISTINCT 연산은 더욱 비용이 큽니다.

**최적화 전략**: 가능하면 서브쿼리에서 미리 DISTINCT를 적용하여 데이터를 축소한 후, 주 쿼리에서 집계를 수행하세요.

```sql
-- 사전 축소 전략: 종종 더 빠른 성능을 제공
SELECT COUNT(*) AS unique_department_job_pairs
FROM (
  SELECT DISTINCT department_id, job_title
  FROM employees
) AS distinct_combinations;
```

---

## 분산 및 대규모 환경에서의 집계 최적화

- MPP(대규모 병렬 처리) 및 분산 데이터베이스 시스템은 일반적으로 `부분 집계 → 최종 집계`의 두 단계로 집계 작업을 병렬화합니다.
- DISTINCT 연산이나 ORDER BY가 포함된 집계는 병렬성을 저하시킬 수 있으므로, 파티션 키 설계나 데이터 사전 정규화, 롤업 테이블 사용을 고려하세요.
- **물질화된 뷰(Materialized View)**를 활용한 증분 집계 유지 전략은 실무에서 매우 중요한 최적화 기법입니다.

---

## 집계 함수 vs 윈도우 함수: 핵심 차이점

- **집계 함수**: 여러 행을 그룹당 하나의 행으로 "축소"합니다.
- **윈도우 함수**: 행을 축소하지 않고 각 행 옆에 집계 결과를 "추가"합니다.

```sql
-- 집계 함수: 부서별 평균 급여 (부서당 하나의 행)
SELECT department_id, AVG(salary) AS department_average_salary
FROM employees
GROUP BY department_id;

-- 윈도우 함수: 각 직원 행 옆에 부서 평균 급여 표시 (행 수 유지)
SELECT
  employee_id,
  department_id,
  salary,
  AVG(salary) OVER (PARTITION BY department_id) AS department_average_salary
FROM employees;
```

**적절한 사용 시나리오**: 리포트에서 개별 행과 그룹 평균을 동시에 표시해야 할 때는 **윈도우 함수**를 사용하세요.

---

## 고급 통계 집계: 표준편차, 분산, 백분위수, 최빈값

### 분산과 표준편차 함수

| 데이터베이스 | 제공 함수 |
|-------------|-----------|
| PostgreSQL | `VAR_POP`, `VAR_SAMP`, `STDDEV_POP`, `STDDEV_SAMP` |
| Oracle | `VAR_POP`, `VAR_SAMP`, `STDDEV_POP`, `STDDEV_SAMP` |
| MySQL | `VAR_POP`, `VAR_SAMP`, `STDDEV_POP`, `STDDEV_SAMP` (일부 버전에서는 `STDDEV`, `VARIANCE` 별칭 제공) |
| SQL Server | `VAR`, `VARP`, `STDEV`, `STDEVP` |

```sql
-- 분산과 표준편차 계산
SELECT
  VAR_SAMP(salary)   AS sample_variance,
  STDDEV_SAMP(salary) AS sample_standard_deviation
FROM employees;
```

### 백분위수(Percentile) 계산

- 표준 SQL: `PERCENTILE_CONT`, `PERCENTILE_DISC` ... `WITHIN GROUP (ORDER BY ...)`
- 지원 데이터베이스: Oracle, SQL Server, PostgreSQL(ordered-set aggregate)
- MySQL: 직접 지원하지 않음 (윈도우 함수로 근사치 계산 또는 애플리케이션 레벨 구현 필요)

```sql
-- Oracle, PostgreSQL, SQL Server에서의 백분위수 계산
SELECT
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) AS median_salary,
  PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY salary) AS p90_salary
FROM employees
WHERE salary IS NOT NULL;
```

### 최빈값(Mode) 계산

- 표준 SQL에 내장된 함수가 없으므로 윈도우 함수나 서브쿼리 조합으로 구현해야 합니다.

```sql
-- PostgreSQL 예시: 가장 흔한 급여값(최빈값) 찾기
WITH salary_frequency AS (
  SELECT salary, COUNT(*) AS frequency
  FROM employees
  WHERE salary IS NOT NULL
  GROUP BY salary
)
SELECT salary
FROM salary_frequency
ORDER BY frequency DESC, salary
FETCH FIRST 1 ROW ONLY;
```

---

## Oracle 특수 기능: KEEP (DENSE_RANK LAST/FIRST)

Oracle은 "최대/최소 기준의 관련 값"을 추출할 때 유용한 `KEEP` 구문을 제공합니다.

```sql
-- 가장 높은 급여를 받는 직원의 이름과 급여를 동시에 조회
SELECT
  MAX(employee_name) KEEP (DENSE_RANK LAST ORDER BY salary) AS highest_paid_employee,
  MAX(salary)                                              AS highest_salary
FROM employees;
```

다른 데이터베이스에서는 유사한 기능을 윈도우 함수나 서브쿼리를 조합하여 구현해야 합니다.

---

## MySQL의 ONLY_FULL_GROUP_BY 모드와 함수적 종속성

MySQL에서 `ONLY_FULL_GROUP_BY` 모드가 활성화되면, `SELECT` 절에 나타나는 **모든 비집계 컬럼**은 `GROUP BY` 절에 포함되어야 합니다(표준 SQL 규칙 준수). 함수적 종속성(예: 기본키가 있으면 다른 컬럼이 함수적으로 종속됨)을 안전하게 활용하려면, 명시적으로 `GROUP BY`에 모든 필요한 컬럼을 포함하는 습관을 들이는 것이 좋습니다.

```sql
-- 문제의 소지가 있는 쿼리 (환경에 따라 오류 발생 가능)
SELECT department_id, employee_name, COUNT(*) 
FROM employees 
GROUP BY department_id;

-- 안전한 쿼리
SELECT department_id, COUNT(*) 
FROM employees 
GROUP BY department_id;
```

---

## HAVING 절: 그룹 수준 필터링의 정확한 사용법

```sql
-- 평균 급여가 6000 이상인 부서만 조회
SELECT department_id, AVG(salary) AS average_salary
FROM employees
GROUP BY department_id
HAVING AVG(salary) >= 6000
ORDER BY average_salary DESC;
```

**핵심 구분**:
- `WHERE`: **개별 행**을 필터링 (집계 함수 사용 불가)
- `HAVING`: **그룹 결과**를 필터링 (집계 함수 사용 가능)

**성능 팁**: 가능한 많은 조건을 `WHERE` 절로 이동시켜 그룹화 전에 행 수를 줄이면 성능이 향상됩니다.

---

## 성능 최적화를 위한 체크리스트

1. **필터 푸시다운**: `WHERE` 절을 사용하여 가능한 한 일찍 데이터를 필터링하세요.
2. **사전 집계**: 서브쿼리나 CTE에서 작은 그룹 단위로 미리 집계한 후 상위에서 결합하세요.
3. **DISTINCT 최소화**: `UNION ALL` 후 외부에서 한 번의 `DISTINCT`나 `GROUP BY`를 적용하는 것이 더 빠를 때가 많습니다.
4. **인덱스 활용**: `GROUP BY`에 사용되는 키와 필터링 컬럼에 적절한 인덱스를 생성하세요.
5. **통계 최신화**: 옵티마이저가 올바른 집계 계획을 선택할 수 있도록 정기적으로 통계를 업데이트하세요.
6. **메모리 관리**: 정렬이나 해시 작업을 위한 임시 공간 사용을 모니터링하고 필요시 튜닝하세요.
7. **물질화된 뷰 활용**: 자주 사용하는 집계 쿼리에 대해 물질화된 뷰나 요약 테이블을 생성하세요.

---

## 실무에서 자주 사용하는 집계 패턴

### 부서별 종합 요약 리포트

```sql
-- 모든 데이터베이스에서 동작하는 조건부 집계
SELECT
  department_id,
  COUNT(*)                                                          AS total_employees,
  SUM(CASE WHEN email IS NOT NULL THEN 1 ELSE 0 END)                AS employees_with_email,
  AVG(salary)                                                       AS average_salary,
  MIN(salary)                                                       AS minimum_salary,
  MAX(salary)                                                       AS maximum_salary
FROM employees
GROUP BY department_id
ORDER BY department_id;
```

### 최근 N일 동안의 롤링 집계

```sql
-- 1) 최근 30일 총 매출 (전통적 집계)
SELECT SUM(sales_amount) AS total_sales_last_30_days
FROM sales
WHERE sale_date >= CURRENT_DATE - INTERVAL '30 day';

-- 2) 일별 행 옆에 30일 롤링 합계 표시 (윈도우 함수)
SELECT
  sale_date,
  daily_sales,
  SUM(daily_sales) OVER (
    ORDER BY sale_date
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  ) AS rolling_30_day_sum
FROM daily_sales_data;
```

---

## 정확성과 재현성을 위한 방어적 코딩 요령

1. **NULL 및 빈 집계 처리**: `COALESCE` 함수로 명시적으로 처리하세요.
2. **타입과 정밀도 관리**: `CAST`를 사용하여 의도한 정밀도를 명시하세요.
3. **DISTINCT 의미 명확화**: 값의 종류 수를 세는지, 행 수를 세는지 문서화하세요.
4. **시간대 및 로캘 통일**: 세션 설정을 고정하여 일관된 결과를 보장하세요.
5. **집계 정의 문서화**: 무엇을 어떻게 계산했는지 기록하여 SLA와 재현성을 확보하세요.

---

## 자주 발생하는 실수와 해결책

| 상황 | 문제점 | 해결책 |
|------|--------|--------|
| `COUNT(컬럼)`와 `COUNT(*)` 혼동 | NULL 포함/제외 차이 이해 부족 | 각 함수의 정확한 정의를 문서화하고 필요시 `COALESCE` 사용 |
| `WHERE` 절에서 필터링 누락 | 불필요하게 대량 데이터 집계 | 집계 전에 `WHERE` 절로 데이터 양 축소 |
| DISTINCT 과도 사용 | 성능 저하 | 사전 축소, 해시 키 설계, 필요시만 사용 |
| 빈 집계 결과가 NULL | 리포트에서 0이 필요함 | `COALESCE` 함수로 명시적 0 변환 |
| MySQL에서 다중 컬럼 DISTINCT | 구문 제한 | 문자열 병합, 해시, 서브쿼리 등으로 우회 |
| 백분위수 필요 (MySQL 환경) | 기본 지원 없음 | 윈도우 함수 기반 근사치, 애플리케이션 로직, ETL 사전 계산 |

---

## 종합 예제: 교차 데이터베이스 호환 쿼리 모음

```sql
-- 1) 전체 집계 기본 패턴
SELECT
  COUNT(*)                                AS total_employees,
  COUNT(email)                            AS employees_with_email,
  COALESCE(SUM(salary), 0)                AS total_salary,
  AVG(salary)                             AS average_salary,
  MIN(salary)                             AS minimum_salary,
  MAX(salary)                             AS maximum_salary
FROM employees;

-- 2) 그룹별 집계 + 조건부 집계
SELECT
  department_id,
  COUNT(*)                                                AS employee_count,
  SUM(CASE WHEN email IS NOT NULL THEN 1 ELSE 0 END)      AS email_count,
  AVG(salary)                                             AS average_salary,
  SUM(CASE WHEN job_title LIKE 'DEV%' THEN salary ELSE 0 END) AS total_dev_salary
FROM employees
GROUP BY department_id
HAVING COUNT(*) >= 2
ORDER BY department_id;

-- 3) 고유값 개수 계산
SELECT COUNT(DISTINCT department_id) AS unique_departments
FROM employees;

-- 4) 백분위수 계산 (지원되는 DB에서)
SELECT
  PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) AS p25_salary,
  PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY salary) AS median_salary,
  PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY salary) AS p90_salary
FROM employees
WHERE salary IS NOT NULL;

-- 5) 통계적 집계: 분산과 표준편차
SELECT
  VAR_SAMP(salary)    AS sample_variance,
  VAR_POP(salary)     AS population_variance,
  STDDEV_SAMP(salary) AS sample_standard_deviation,
  STDDEV_POP(salary)  AS population_standard_deviation
FROM employees;

-- 6) 윈도우 함수와의 비교: 행 수 유지하며 집계
SELECT
  employee_id,
  department_id,
  salary,
  AVG(salary) OVER (PARTITION BY department_id)              AS department_average,
  SUM(salary) OVER (
    PARTITION BY department_id 
    ORDER BY employee_id
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) AS department_running_total
FROM employees
ORDER BY department_id, employee_id;
```

---

## 결론: 효과적인 집계 함수 사용을 위한 핵심 원칙

집계 함수는 데이터 분석의 핵심 도구이지만, 정확한 이해 없이 사용하면 잘못된 통찰을 도출할 수 있습니다. 다음 원칙을 기억하세요:

1. **기본 개념 정확히 이해하기**: 각 집계 함수의 NULL 처리 방식, 빈 입력에서의 동작, 데이터 타입에 따른 특성을 명확히 이해해야 합니다.

2. **실행 순서에 따른 최적화**: SQL의 논리적 실행 순서를 이해하고, `WHERE` 절로 가능한 한 일찍 데이터를 필터링하여 집계 부하를 줄이세요.

3. **적절한 도구 선택**: 단순 그룹 요약에는 집계 함수를, 행별 집계 정보 추가에는 윈도우 함수를 사용하세요.

4. **데이터베이스 특성 고려**: 각 DBMS의 집계 함수 구현 차이, 성능 특성, 확장 기능을 이해하고 활용하세요.

5. **정확성과 성능의 균형**: `DISTINCT` 사용을 최소화하고, 대규모 데이터셋에서는 근사치 계산이나 물질화된 뷰를 고려하세요.

6. **방어적 코딩**: NULL 처리, 타입 변환, 0 나누기 방지 등을 명시적으로 처리하여 안정적인 결과를 보장하세요.

집계 함수의 효과적인 사용은 단순한 기술적 숙련도를 넘어, 비즈니스 요구사항을 정확히 이해하고 데이터의 특성을 고려한 설계 능력을 요구합니다. 기본기를 튼튼히 하고 실무 경험을 축적해나가면 복잡한 데이터 분석 요구사항도 효과적으로 해결할 수 있을 것입니다.