---
layout: post
title: DB - 그룹 함수 (1)
date: 2025-03-14 20:20:23 +0900
category: DB
---
# SQL 그룹 함수(Group/Aggregate Functions) (1)

## 배경과 실행 순서

집계는 **논리 실행 순서**에서 보통 다음과 같이 일어난다.

1) `FROM`/`JOIN`
2) `WHERE` (행 필터)
3) `GROUP BY` (그룹 형성)
4) **집계 함수** 평가
5) `HAVING` (그룹 필터)
6) `SELECT` (프로젝션)
7) `ORDER BY` / `LIMIT` (정렬/Top-N)

이 순서를 이해해야 `WHERE` vs `HAVING`, “왜 이 컬럼은 `GROUP BY`에 있어야 하는가” 같은 질문에 정확히 답할 수 있다.

---

## 대표 그룹 함수와 기본 규칙

### 공통 특징

- **여러 행 → 하나의 스칼라**로 요약.
- `GROUP BY`가 없으면 **전체 테이블**을 하나의 그룹으로 본다.
- 대부분 **NULL을 무시**한다(단, `COUNT(*)`는 행 수 자체를 세므로 NULL 포함).

### 대표 함수

| 함수 | 의미 | NULL 처리 | 빈 그룹 결과 |
|---|---|---|---|
| `COUNT(*)` | 행 개수 | 포함 | 0 |
| `COUNT(expr)` | expr이 NULL이 아닌 행 개수 | 제외 | 0 |
| `SUM(expr)` | 합계 | NULL 제외 | NULL |
| `AVG(expr)` | 평균 | NULL 제외 | NULL |
| `MIN(expr)` | 최소 | NULL 제외 | NULL |
| `MAX(expr)` | 최대 | NULL 제외 | NULL |

> **주의**: `SUM/AVG/MIN/MAX`는 **빈 입력**(WHERE로 걸러져 아무 행도 없거나 그룹이 비어있는 경우)에서 **NULL**을 반환한다. 보고서에서 0이 필요하면 `COALESCE` 하라.

```sql
-- 빈 집계의 방어적 처리
SELECT
  COALESCE(SUM(sales), 0)  AS sum_sales,
  COALESCE(AVG(sales), 0)  AS avg_sales,
  COALESCE(MIN(sales), 0)  AS min_sales,
  COALESCE(MAX(sales), 0)  AS max_sales
FROM DailySales
WHERE sale_date = DATE '2099-01-01'; -- 미래 날짜: 결과가 비어 있을 수 있음
```

---

## 스키마와 샘플 데이터

```sql
-- 공통 예시를 위한 스키마
CREATE TABLE Employee (
  emp_id       INT PRIMARY KEY,
  dept_id      INT,
  job          VARCHAR(50),
  name         VARCHAR(100),
  salary       DECIMAL(12,2),
  hire_date    DATE,
  email        VARCHAR(200)
);

INSERT INTO Employee(emp_id, dept_id, job, name, salary, hire_date, email) VALUES
(1, 10, 'SALES',   'Alice',   5000, DATE '2024-01-15', 'alice@ex.com'),
(2, 10, 'SALES',   'Bob',     6000, DATE '2024-03-01', NULL),
(3, 20, 'HR',      'Carol',   4200, DATE '2023-11-03', 'carol@ex.com'),
(4, 20, 'HR',      'Dave',    NULL, DATE '2022-08-20', NULL),
(5, 30, 'DEV',     'Eve',     8000, DATE '2024-07-10', 'eve@ex.com'),
(6, 30, 'DEV',     'Frank',   7700, DATE '2024-07-11', 'frank@ex.com'),
(7, 30, 'DEV',     'Grace',   NULL, DATE '2024-07-12', 'grace@ex.com');
```

---

## COUNT — 개수 세기 정확 가이드

```sql
-- 전체 행 수
SELECT COUNT(*) AS cnt FROM Employee;

-- salary가 NULL이 아닌 행만 카운트
SELECT COUNT(salary) AS cnt_salary FROM Employee;

-- 부서별 인원
SELECT dept_id, COUNT(*) AS cnt
FROM Employee
GROUP BY dept_id;

-- 부서별 이메일 등록자 수(이메일 NULL 제외)
SELECT dept_id, COUNT(email) AS email_cnt
FROM Employee
GROUP BY dept_id;
```

### DISTINCT와 COUNT

- `COUNT(DISTINCT expr)`는 **서로 다른 값의 개수**를 셈.
- **여러 컬럼 DISTINCT 지원 여부**는 DBMS마다 다르다.

| DBMS | `COUNT(DISTINCT a, b)` |
|---|---|
| MySQL / PostgreSQL | 지원 |
| SQL Server | 미지원(단일 expr만) → `COUNT(DISTINCT CONCAT(...))` 또는 서브쿼리 |
| Oracle | 전통적으로 단일 expr. 멀티 expr 필요 시 문자열 병합/복합 키 인코딩으로 우회 |

```sql
-- PostgreSQL / MySQL
SELECT COUNT(DISTINCT dept_id, job) FROM Employee;

-- SQL Server/Oracle 우회(충돌 위험 최소화를 위해 구분자/길이패딩/해시 사용 권장)
SELECT COUNT(DISTINCT CONCAT(CAST(dept_id AS VARCHAR(10)), '|', job)) FROM Employee;
```

### 근사 카운트(대용량 고속)

- Oracle: `APPROX_COUNT_DISTINCT(expr)`
- SQL Server: `APPROX_COUNT_DISTINCT(expr)`
- PostgreSQL: 확장(`hyperloglog` 등) 또는 `COUNT(DISTINCT)` 대비 느릴 수 있으나 확장으로 보완
- MySQL: 기본 내장 없음(HeatWave/플러그인/애플리케이션 레벨 구현)

```sql
-- Oracle / SQL Server
SELECT APPROX_COUNT_DISTINCT(email) AS approx_unique_emails
FROM Employee;
```

---

## SUM, AVG — 정밀도/타입 승격/가중 평균

### 정밀도와 타입 승격

- `AVG(NUMERIC(p, s))`는 DBMS에 따라 **정밀도 승격** 방식이 다르다.
- 합산 시 **정수 오버플로**에 주의(특히 `INT` 합계). 필요 시 **명시적 CAST**로 `DECIMAL` 승격.

```sql
-- 정밀도/오버플로 방지
SELECT
  SUM(CAST(salary AS DECIMAL(18,2))) AS sum_sal,
  AVG(CAST(salary AS DECIMAL(18,2))) AS avg_sal
FROM Employee;
```

### 조건부 평균, 가중 평균

```sql
-- 조건부 평균(모든 DB 공통)
SELECT AVG(CASE WHEN dept_id = 30 THEN salary END) AS avg_dev
FROM Employee;

-- 가중 평균(예: 성과 점수 weights 테이블과 조인)
SELECT
  SUM(score * weight) / NULLIF(SUM(weight), 0) AS weighted_avg
FROM Scores s;
```

> `NULLIF(SUM(weight), 0)`로 0 나누기 방지.

---

## MIN, MAX — 날짜/문자/숫자 공통 패턴

```sql
-- 전체 최소/최대 급여
SELECT MIN(salary) AS min_sal, MAX(salary) AS max_sal FROM Employee;

-- 부서별 최근 입사일
SELECT dept_id, MAX(hire_date) AS latest_hire
FROM Employee
GROUP BY dept_id;
```

- 문자열 MIN/MAX는 **Collation**에 따라 정렬 규칙이 달라진다.
- 날짜/타임존 타입은 **세션 타임존/타입** 동작을 사전에 통제하자.

---

## 조건부 집계(조건별 카운트/합계) — 전 DB 공통 핵심

대부분의 “필터링된 집계”는 **`FILTER` 문법(표준, PostgreSQL)** 또는 **`CASE WHEN`**으로 표현한다.

```sql
-- PostgreSQL: FILTER 문법
SELECT
  COUNT(*)                                                     AS total,
  COUNT(*) FILTER (WHERE dept_id = 30)                         AS dev_cnt,
  SUM(salary) FILTER (WHERE job = 'SALES')                     AS sales_sum
FROM Employee;

-- MySQL / Oracle / SQL Server: CASE WHEN
SELECT
  COUNT(*)                                                     AS total,
  SUM(CASE WHEN dept_id = 30 THEN 1 ELSE 0 END)                AS dev_cnt,
  SUM(CASE WHEN job = 'SALES' THEN salary ELSE 0 END)          AS sales_sum
FROM Employee;
```

장점
- **단일 스캔**으로 여러 조건을 동시에 집계(성능/가독성 모두 우수).
- 대시보드/피벗 전 단계 집계를 유연하게 구성.

---

## DISTINCT 집계의 비용과 최적화

- `COUNT(DISTINCT x)`, `AVG(DISTINCT x)`, `SUM(DISTINCT x)`는
  내부적으로 **중복 제거(해시/정렬)** 비용이 들어간다.
- 다중 컬럼 DISTINCT는 더 비싸다 → 가능하면 **사전 축소(서브쿼리에서 미리 DISTINCT)** 후 집계.

```sql
-- 사전 축소 전략(종종 더 빠름)
SELECT COUNT(*) FROM (
  SELECT DISTINCT dept_id, job
  FROM Employee
) t;
```

---

## 분산/대용량 환경의 집계

- MPP/분산 DB는 `PARTIAL → FINAL` 집계로 **병렬화**한다.
- DISTINCT/ORDERED 집계는 병렬성 저하 요인이므로 **파티션 키 설계**/**사전 정규화**/**롤업 테이블** 고려.
- **물질화된 뷰(Materialized View)**로 **증분 집계**를 유지하는 전략이 실무에서 극히 중요.

---

## 집계 vs 윈도우(분석) 함수

- **집계 함수**: 그룹당 1행으로 “축소”.
- **윈도 함수**: “축소 없이” 각 행 옆에 요약 값을 붙인다(OVER 절).

```sql
-- 집계: 부서별 평균 1행/부서
SELECT dept_id, AVG(salary) AS avg_sal
FROM Employee
GROUP BY dept_id;

-- 윈도: 각 직원 행 옆에 부서 평균이 표시됨(축소 없음)
SELECT
  emp_id, dept_id, salary,
  AVG(salary) OVER (PARTITION BY dept_id) AS avg_sal_by_dept
FROM Employee;
```

- “리포트 표에서 개별 행과 그룹 평균을 동시에 보여줘야” 하면 **윈도 함수**를 사용하라.
- Part 2에서 **ROLLUP/CUBE/GROUPING SETS**와 비교 정리 예정.

---

## 고급 통계 집계: 표준편차, 분산, 백분위수, 최빈값

### 분산/표준편차

| DBMS | 함수 |
|---|---|
| PostgreSQL | `VAR_POP`, `VAR_SAMP`, `STDDEV_POP`, `STDDEV_SAMP` |
| Oracle | `VAR_POP`, `VAR_SAMP`, `STDDEV_POP`, `STDDEV_SAMP` |
| MySQL | `VAR_POP`, `VAR_SAMP`, `STDDEV_POP`, `STDDEV_SAMP` (버전에 따라 `STDDEV`, `VARIANCE` 별칭) |
| SQL Server | `VAR`, `VARP`, `STDEV`, `STDEVP` |

```sql
SELECT
  VAR_SAMP(salary)   AS var_sample,
  STDDEV_SAMP(salary) AS std_sample
FROM Employee;
```

### 백분위수(퍼센타일)

- 표준: `PERCENTILE_CONT`, `PERCENTILE_DISC` … `WITHIN GROUP (ORDER BY ...)`
- 지원: Oracle/SQL Server/PostgreSQL(ordered-set aggregate)
- MySQL: 직접 지원 없음(윈도 함수로 근사/시뮬레이션)

```sql
-- Oracle / PostgreSQL / SQL Server
SELECT
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) AS p50,
  PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY salary) AS p90
FROM Employee
WHERE salary IS NOT NULL;
```

### 최빈값(Mode)

- 표준 내장 없음 → 윈도/서브쿼리 조합으로 구현

```sql
-- PostgreSQL 예: 최빈값 하나
WITH freq AS (
  SELECT salary, COUNT(*) AS c
  FROM Employee
  WHERE salary IS NOT NULL
  GROUP BY salary
)
SELECT salary
FROM freq
ORDER BY c DESC, salary
FETCH FIRST 1 ROW ONLY;
```

---

## Oracle 전용: KEEP (DENSE_RANK LAST/FIRST)

“**최대/최소 기준의 동반 값**”을 뽑을 때 강력하다.

```sql
-- 급여가 가장 높은 직원의 이름/급여를 한 번에
SELECT
  MAX(name)   KEEP (DENSE_RANK LAST ORDER BY salary) AS name_at_max_salary,
  MAX(salary)                                       AS max_salary
FROM Employee;
```

유사 문제를 다른 DB에서는 윈도 함수/서브쿼리로 해결한다.

---

## MySQL ONLY_FULL_GROUP_BY와 함수적 종속

MySQL은 `ONLY_FULL_GROUP_BY`가 켜져 있으면, `SELECT`에 나온 **비집계 컬럼**은 모두 `GROUP BY`에 있어야 한다(표준에 맞춘 더 엄격한 규칙).
함수적 종속성(예: PK가 있으면 다른 컬럼이 함수적으로 종속됨)을 **안전하게** 활용하려면 **명시적**으로 `GROUP BY`에 담는 습관을 추천한다.

```sql
-- 나쁜 예(환경에 따라 에러/허용)
SELECT dept_id, name, COUNT(*) FROM Employee GROUP BY dept_id;

-- 좋은 예
SELECT dept_id, COUNT(*) FROM Employee GROUP BY dept_id;
```

---

## HAVING 절 — 그룹 조건 필터의 정확한 위치

```sql
-- 부서별 평균 급여가 6000 이상인 부서
SELECT dept_id, AVG(salary) AS avg_sal
FROM Employee
GROUP BY dept_id
HAVING AVG(salary) >= 6000
ORDER BY avg_sal DESC;
```

- `WHERE`는 **행 필터**, `HAVING`은 **그룹 필터**.
- 조건을 `WHERE`로 미리 줄이면 **그룹 규모가 줄어** 성능에 유리하다.

---

## 성능 최적화 전략(핵심 체크리스트)

1) **필터 푸시다운**: `WHERE`로 먼저 줄인다(가능하면 조인 전에 세미조인/반조인으로 축소).
2) **사전 집계**: 서브쿼리/CTE에서 소그룹으로 미리 집계 후 상위에서 결합.
3) **DISTINCT 최소화**: `UNION ALL`→바깥 `DISTINCT`/`GROUP BY` 한 번이 빠를 때 많다.
4) **인덱스**: `GROUP BY` 키/필터 컬럼에 인덱스. 해시 집계 vs 정렬 집계 전략 확인.
5) **분포/통계 최신화**: 옵티마이저가 올바른 집계 계획을 고르도록 통계 업데이트.
6) **메모리/워크파일**: 정렬/해시 임시공간 파라미터를 모니터링/튜닝.
7) **물질화된 뷰**: 자주 쓰는 요약은 MV/스냅샷/요약 테이블로 캐시. 증분 갱신을 설계.

---

## 빈번·실무형 예제 모음

### 부서별 요약(조건부 컬럼 포함)

```sql
-- 모든 DB 공통(CASE WHEN)
SELECT
  dept_id,
  COUNT(*)                                            AS emp_cnt,
  SUM(CASE WHEN email IS NOT NULL THEN 1 ELSE 0 END) AS email_cnt,
  AVG(salary)                                        AS avg_sal,
  MIN(salary)                                        AS min_sal,
  MAX(salary)                                        AS max_sal
FROM Employee
GROUP BY dept_id
ORDER BY dept_id;
```

### 다중 조건을 한 번에(포스트그레스 FILTER)

```sql
-- PostgreSQL
SELECT
  COUNT(*)                                                     AS total,
  COUNT(*) FILTER (WHERE dept_id = 30)                         AS dev_cnt,
  SUM(salary) FILTER (WHERE job = 'SALES')                     AS sales_sum,
  AVG(salary) FILTER (WHERE salary >= 7000)                    AS avg_high
FROM Employee;
```

### “최근 N일” 롤링 집계(윈도와 비교)

```sql
-- 1) 최근 30일 총매출(집계)
SELECT SUM(amount) AS sum_30d
FROM Sales
WHERE sale_date >= CURRENT_DATE - INTERVAL '30 day';

-- 2) 일별 행 옆에 30일 롤링합(윈도)
SELECT
  sale_date,
  amount,
  SUM(amount) OVER (ORDER BY sale_date
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW) AS roll_30
FROM DailySales;
```

---

## 단정·정밀·재현성: 보고서 품질을 위한 방어 요령

- **NULL/빈 집계**는 반드시 `COALESCE`로 명시 처리.
- **타입 승격/Cast**로 정밀도 오해를 방지.
- **DISTINCT 의미**(값 종류 수 vs 행 수)를 문서화.
- **시간대/로캘/Collation**을 고정.
- 집계 정의서(“무엇을 어떻게 셌는지”)를 작성해 **SLA/재현성**을 확보.

---

## 수학적 배경(평균/분산/표준편차)

평균:
$$
\operatorname{avg}(X) = \frac{1}{n} \sum_{i=1}^{n} x_i
$$

표본분산/모분산:
$$
s^2 = \frac{1}{n-1}\sum_{i=1}^{n} (x_i - \bar{x})^2,\quad
\sigma^2 = \frac{1}{n}\sum_{i=1}^{n} (x_i - \bar{x})^2
$$

표준편차:
$$
s = \sqrt{s^2}, \quad \sigma = \sqrt{\sigma^2}
$$

DBMS는 위 정의를 구현한 `VAR_SAMP/VAR_POP`, `STDDEV_SAMP/STDDEV_POP`을 제공한다.

---

## 자주 하는 실수와 해결

| 상황 | 문제 | 해결 |
|---|---|---|
| `COUNT(col)`와 `COUNT(*)` 혼동 | NULL 제외/포함 차이 | 정의를 문서화, 필요 시 `COALESCE` |
| `WHERE`에서 필터 안 함 | 불필요 대량 집계 | 먼저 `WHERE`로 축소 |
| DISTINCT 남발 | 성능 저하 | 사전 축소/해시 키 설계 |
| 빈 집계가 NULL | 리포트 0 필요 | `COALESCE`로 0 대체 |
| MySQL 다중 DISTINCT | 구문 제한 | 문자열 병합/해시/서브쿼리 |
| 퍼센타일 필요(MySQL) | 미지원 | 윈도 기반 근사/앱 로직/ETL 사전계산 |

---

## 실전 체크리스트

- [ ] **집계 정의**와 **데이터 출처**가 문서화되어 있는가
- [ ] **NULL/빈 그룹**의 결과값 정책을 합의했는가
- [ ] **타입/정밀도**가 업무 도메인에 맞는가
- [ ] **필터/조인**이 집계 전에 수행되어 행 수가 최소화되는가
- [ ] **DISTINCT/정렬** 비용이 최소화되었는가
- [ ] 대용량은 **물질화/증분 집계**로 전환할 계획이 있는가

---

## 마무리 및 Part 2 예고

본 편(Part 1)은 **기본 집계**의 정확한 의미/동작/차이/성능을 다뤘다.
**Part 2**에서는 다음을 집중적으로 다룬다.

- **ROLLUP / CUBE / GROUPING SETS**: 다차원 요약과 부분합을 한 번에
- **GROUPING()** 함수와 총계/소계 라벨링
- **PIVOT / UNPIVOT**: 행↔열 변환 기반의 요약
- **Ordered-Set Aggregates**: `PERCENTILE_CONT/DISC`, `MODE()` 구현 패턴
- **데이터 큐브/OLAP** 성능·설계 베스트 프랙티스

---

## 부록 A. 종합 예제 스크립트(교차 DB 가급적 호환)

```sql
-- 1) 전체 집계
SELECT
  COUNT(*)                                AS emp_cnt,
  COUNT(email)                            AS email_cnt,      -- NULL 제외
  COALESCE(SUM(salary), 0)                AS sum_salary,     -- 빈 집계 방어
  AVG(salary)                             AS avg_salary,
  MIN(salary)                             AS min_salary,
  MAX(salary)                             AS max_salary
FROM Employee;

-- 2) 그룹 집계 + 조건부 집계
SELECT
  dept_id,
  COUNT(*)                                                AS emp_cnt,
  SUM(CASE WHEN email IS NOT NULL THEN 1 ELSE 0 END)      AS email_cnt,
  AVG(salary)                                             AS avg_salary,
  SUM(CASE WHEN job = 'DEV' THEN salary ELSE 0 END)       AS dev_sum
FROM Employee
GROUP BY dept_id
HAVING COUNT(*) >= 2
ORDER BY dept_id;

-- 3) DISTINCT 집계
-- PostgreSQL/MySQL: 멀티 컬럼 가능
-- SQL Server/Oracle: 우회 필요
SELECT
  COUNT(DISTINCT dept_id) AS uniq_dept
FROM Employee;

-- 4) 백분위수(Oracle/PostgreSQL/SQL Server)
SELECT
  PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) AS p25,
  PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY salary) AS p50,
  PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY salary) AS p90
FROM Employee
WHERE salary IS NOT NULL;

-- 5) 표준편차/분산 예
-- 이름은 DBMS별 상이할 수 있음
SELECT
  VAR_SAMP(salary)    AS var_sample,
  VAR_POP(salary)     AS var_pop,
  STDDEV_SAMP(salary) AS sd_sample,
  STDDEV_POP(salary)  AS sd_pop
FROM Employee;

-- 6) 윈도 함수 비교(축소 없이 행 옆에 집계)
SELECT
  emp_id, dept_id, salary,
  AVG(salary) OVER (PARTITION BY dept_id)              AS avg_by_dept,
  SUM(salary) OVER (PARTITION BY dept_id ORDER BY emp_id
                    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS dept_running_sum
FROM Employee
ORDER BY dept_id, emp_id;
```

---

## 부록 B. MySQL의 FILTER/멀티 DISTINCT 우회 패턴

```sql
-- FILTER(WHERE ...) 대신 CASE WHEN
SELECT
  COUNT(*)                                                    AS total,
  SUM(CASE WHEN dept_id = 30 THEN 1 ELSE 0 END)              AS dev_cnt,
  SUM(CASE WHEN job = 'SALES' THEN salary ELSE 0 END)        AS sales_sum
FROM Employee;

-- 멀티 컬럼 DISTINCT 우회(충돌 최소화를 위한 안전 인코딩 권장)
SELECT COUNT(*) AS uniq_pairs
FROM (
  SELECT DISTINCT CONCAT(dept_id, '|', job) AS key
  FROM Employee
) t;
```

---

## 부록 C. 정확성 테스트(단위 테스트 관점)

- **NULL/빈 집계**: 결과를 명시적으로 검증(`IS NULL`/`= 0`).
- **DISTINCT**: 예상 유니크 집합과 비교(서브쿼리 `SELECT DISTINCT ...`).
- **타입/정밀도**: 의도한 스케일/반올림 확인(`ROUND/CAST`).
- **시간대/Collation**: 세션 파라미터 고정 후 테스트.

---

## 결론

- 그룹 함수는 “한 줄 요약”이지만, **정확한 의미/NULL/정밀도/DBMS 차이**를 모르면 보고서가 틀리기 쉽다.
- **조건부 집계**와 **윈도 함수**의 차이를 이해하고, **성능(사전 축소·DISTINCT 최소화·인덱스)**까지 챙길 때 현업 품질이 올라간다.
- 다음 편(Part 2)에서 **ROLLUP/CUBE/GROUPING SETS/PIVOT** 등 고급 집계를 통해 **다차원 요약**과 **피벗팅**을 완성하자.
