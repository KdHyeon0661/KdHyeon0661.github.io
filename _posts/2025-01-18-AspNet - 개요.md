---
layout: post
title: AspNet - 개요
date: 2025-01-18 19:20:23 +0900
category: AspNet
---
# ASP.NET이란 무엇인가?

## 한눈에 보는 핵심

- **정의**: ASP.NET은 .NET 위에서 동작하는 **오픈 소스 웹 프레임워크**로, **동적 웹사이트/웹앱/웹 API/실시간 통신(SignalR)/gRPC** 등을 개발한다. 특히 **ASP.NET Core**는 경량 호스팅, 단일 파일 배포, 크로스 플랫폼, 컨테이너 친화, 클라우드 네이티브 구성을 지원한다.
- **특징(기존 내용 확장)**
  - 고성능: R2R(ReadyToRun), Native AOT(선택), Kestrel 튜닝, HTTP/2·HTTP/3, 미들웨어 파이프라인 최적화
  - 보안: HTTPS 강제, HSTS, 인증(쿠키/JWT/외부 OAuth), 권한 부여(정책 기반), 데이터 보호
  - 유연성: MVC / Razor Pages / Minimal APIs / SignalR / gRPC / Blazor(서버 · WASM)
  - 크로스 플랫폼: Windows, Linux, macOS, Docker, Kubernetes
  - 클라우드: Azure App Service, Azure Container Apps, AKS, AWS, GCP 등 어디서나 배포
- **구성요소(정리)**:
  ASP.NET Core(핵심) · MVC · Razor Pages · Web API/Minimal API · SignalR · gRPC · Identity · Data Protection · Health Checks · Localization
- **설치(기존 내용 유지 + 점검)**:
  - .NET SDK 설치 후 `dotnet --version`
  - IDE: Visual Studio(ASP.NET 및 웹 개발 워크로드), VS Code(C# 확장)
  - CLI: `dotnet new webapp` / `webapi` / `mvc` / `blazor` 등 템플릿로 빠르게 시작

---

## 프로젝트 구조와 호스팅 모델

### .NET 8 기본 템플릿의 진화

- 상위 수준 문법(Top-level statements)과 `Program.cs` 하나로 **부트스트랩 간소화**.
- **미들웨어 파이프라인**과 **서비스 등록**이 `Program.cs`에서 일원화.

```csharp
// Program.cs (.NET 8, Minimal Hosting)
var builder = WebApplication.CreateBuilder(args);

// 1) 서비스 등록(의존성 주입)
builder.Services.AddControllers();               // MVC 컨트롤러 & Web API
builder.Services.AddRazorPages();                // Razor Pages
builder.Services.AddEndpointsApiExplorer();      // Minimal API/Swagger 탐색기
builder.Services.AddSwaggerGen();                // Swagger(OpenAPI)

// 2) 구성/로깅/옵션 바인딩 예
builder.Services.Configure<MyOptions>(
    builder.Configuration.GetSection("MyOptions"));

var app = builder.Build();

// 3) 파이프라인: 정적파일, 라우팅, 보안, Swagger 등
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

// 4) 엔드포인트 매핑
app.MapControllers();   // /api/* 라우트
app.MapRazorPages();    // /Pages/*.cshtml

// Minimal API 예시
app.MapGet("/ping", () => Results.Ok(new { message = "pong" }));

app.Run();

// Options 바인딩용 POCO
public sealed class MyOptions
{
    public string SiteName { get; init; } = "Demo";
    public int PageSize { get; init; } = 20;
}
```

### Kestrel·IIS·Nginx 호스팅 요약

- **Kestrel**: 기본 교차 플랫폼 웹 서버. 단독/리버스 프록시 뒤에서 모두 사용.
- **IIS(Windows)**: In-Process 호스팅으로 높은 성능.
- **Nginx/Apache(리눅스)**: 리버스 프록시로 TLS 종료, 정적 캐시, 압축, 로드밸런싱 처리.

---

## 개발 방식 비교와 선택 가이드

| 개발 방식 | 용도 | 장점 | 샘플 시작 템플릿 |
|---|---|---|---|
| **Minimal API** | 경량 REST/내부용 API | 코드량 최소, 빠른 부팅 | `dotnet new webapi` (컨트롤러 제거 가능) |
| **Web API + MVC** | 정형 API, 필터/모델 바인딩 풍부 | 필터·모델 유효성·버전관리 용이 | `dotnet new webapi` |
| **Razor Pages** | 서버 렌더링 웹 UI | 페이지 당 모델, 단순한 Razor 파일 구조 | `dotnet new webapp` |
| **MVC (View)** | 전통적 MVC | 복잡 UI/SEO/뷰 재사용 | `dotnet new mvc` |
| **SignalR** | 실시간 양방향 | WebSocket/폴백 포함 | `dotnet add package Microsoft.AspNetCore.SignalR` |
| **gRPC** | 고성능 RPC | HTTP/2 바이너리, 스키마 명확 | `dotnet new grpc` |

---

## 요청 파이프라인과 미들웨어

### 파이프라인 설계 원칙

- 가벼운 미들웨어를 **앞쪽**에 배치(빠른 실패, 정적 처리, 캐싱).
- **예외 처리**는 글로벌(예: `UseExceptionHandler`)로 적용.
- 요청 크기 제한, 압축, CORS, 인증/인가 순서에 유의.

```csharp
// 예외 처리 및 보안 헤더 샘플
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    app.UseHsts(); // HSTS
}

app.UseHttpsRedirection();
app.Use(async (ctx, next) =>
{
    ctx.Response.Headers.TryAdd("X-Content-Type-Options", "nosniff");
    ctx.Response.Headers.TryAdd("X-Frame-Options", "DENY");
    await next();
});

// 정적 파일 → 라우팅 → 인증/인가 → 엔드포인트
app.UseStaticFiles();
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
```

---

## 라우팅, 모델 바인딩, 유효성 검증

### 라우팅(특성 라우팅)

```csharp
[ApiController]
[Route("api/[controller]")]
public sealed class ProductsController : ControllerBase
{
    [HttpGet("{id:int:min(1)}")]
    public ActionResult<ProductDto> Get(int id) => Ok(new ProductDto(id, "Book", 10_000));
}

public record ProductDto(int Id, string Name, int Price);
```

### 모델 바인딩/검증(DataAnnotations)

```csharp
public sealed class CreateProductRequest
{
    [Required, StringLength(50)]
    public string Name { get; init; } = default!;

    [Range(0, int.MaxValue)]
    public int Price { get; init; }
}

[HttpPost]
public IActionResult Create([FromBody] CreateProductRequest req)
{
    if (!ModelState.IsValid) return ValidationProblem(ModelState);
    // 저장 로직...
    return CreatedAtAction(nameof(Get), new { id = 1 }, new { id = 1 });
}
```

---

## Razor Pages 실무 예제

### 페이지 생성

```
dotnet new webapp -n MvcSite
```

### 페이지 모델과 페이지

`/Pages/Products/Index.cshtml.cs`
```csharp
public sealed class IndexModel : PageModel
{
    private readonly IProductService _svc;
    public IReadOnlyList<ProductDto> Items { get; private set; } = [];

    public IndexModel(IProductService svc) => _svc = svc;

    public async Task OnGetAsync()
        => Items = await _svc.GetAllAsync();
}
```

`/Pages/Products/Index.cshtml`
```cshtml
@page
@model IndexModel
<h2>Products</h2>
<ul>
@foreach (var p in Model.Items)
{
    <li>@p.Id - @p.Name (@p.Price)</li>
}
</ul>
```

---

## Minimal API로 빠르게 만드는 REST

```csharp
var group = app.MapGroup("/api/v1/products");
group.WithTags("Products");
group.MapGet("/", async (IProductService svc) => Results.Ok(await svc.GetAllAsync()));
group.MapGet("/{id:int}", async (int id, IProductService svc) =>
    (await svc.GetByIdAsync(id)) is { } p ? Results.Ok(p) : Results.NotFound());
group.MapPost("/", async (CreateProductRequest req, IProductService svc) =>
{
    var id = await svc.CreateAsync(req);
    return Results.Created($"/api/v1/products/{id}", new { id });
});
```

- `MapGroup`으로 버전/공통 미들웨어 묶기, `WithTags`로 Swagger 그룹화.
- 필요 시 입력 검증 미들웨어를 그룹에 붙여 구조적 일관성 확보.

---

## 의존성 주입(DI)과 구성(Configuration)

### 서비스 등록 수명

- `AddSingleton`: 앱 수명 전체 1회
- `AddScoped`: 요청당 1회
- `AddTransient`: 요청 시 매번

```csharp
builder.Services.AddScoped<IProductService, ProductService>();
builder.Services.AddDbContext<AppDbContext>(opt =>
    opt.UseSqlite(builder.Configuration.GetConnectionString("Default")));
```

### 구성 바인딩

`appsettings.json`
```json
{
  "ConnectionStrings": { "Default": "Data Source=app.db" },
  "MyOptions": { "SiteName": "MySite", "PageSize": 50 }
}
```

```csharp
builder.Services.Configure<MyOptions>(builder.Configuration.GetSection("MyOptions"));
```

---

## 데이터 액세스: EF Core 기초

```csharp
public sealed class AppDbContext : DbContext
{
    public DbSet<Product> Products => Set<Product>();
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
}

public sealed class Product
{
    public int Id { get; set; }
    [MaxLength(50)] public string Name { get; set; } = default!;
    public int Price { get; set; }
}
```

마이그레이션:
```
dotnet ef migrations add Init
dotnet ef database update
```

쿼리 최적화 팁:
- Projection(Select)로 필요한 필드만 조회
- `.AsNoTracking()`로 읽기 전용 성능 향상
- 인덱스/제약을 마이그레이션으로 관리

---

## 인증/인가(Identity, JWT, 정책 기반)

### Cookie 기반(서버 렌더링)

```csharp
builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(o => { o.LoginPath = "/Account/Login"; });
builder.Services.AddAuthorization(o =>
{
    o.AddPolicy("AdminOnly", p => p.RequireRole("Admin"));
});
```

```csharp
[Authorize(Policy = "AdminOnly")]
public sealed class AdminController : Controller
{
    public IActionResult Index() => View();
}
```

### 기반(Web API)

```csharp
builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", opt =>
    {
        opt.TokenValidationParameters = new()
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidIssuer = "https://issuer.example",
            ValidAudience = "api",
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]!))
        };
    });
```

권한 부여 정책:
```csharp
builder.Services.AddAuthorization(o =>
{
    o.AddPolicy("PaidUser", p => p.RequireClaim("subscription", "paid"));
});
```

---

## 보안: HTTPS, HSTS, CORS, 데이터 보호

```csharp
app.UseHttpsRedirection();
app.UseHsts();

app.UseCors(policy => policy
    .WithOrigins("https://app.example.com")
    .AllowAnyHeader()
    .AllowAnyMethod()
    .AllowCredentials()); // 필요 시
```

데이터 보호 키(스케일아웃 시 공유):
```csharp
builder.Services.AddDataProtection()
    .PersistKeysToFileSystem(new DirectoryInfo("/keys"))
    .SetApplicationName("MyApp");
```

---

## 성능: 캐싱/압축/Rate Limiting/풀 튜닝

### 응답 압축

```csharp
builder.Services.AddResponseCompression(o =>
{
    o.EnableForHttps = true;
    o.Providers.Add<BrotliCompressionProvider>();
    o.Providers.Add<GzipCompressionProvider>();
});
app.UseResponseCompression();
```

### 메모리 캐시

```csharp
builder.Services.AddMemoryCache();
app.MapGet("/fast", async (IMemoryCache cache) =>
{
    if (!cache.TryGetValue("now", out string? value))
    {
        value = DateTime.UtcNow.ToString("O");
        cache.Set("now", value, TimeSpan.FromSeconds(10));
    }
    return Results.Ok(value);
});
```

### 레이트 리미팅(.NET 8)

```csharp
builder.Services.AddRateLimiter(o =>
{
    o.AddFixedWindowLimiter("api", opt =>
    {
        opt.PermitLimit = 100;
        opt.Window = TimeSpan.FromMinutes(1);
        opt.QueueLimit = 0;
    });
});
app.UseRateLimiter();
app.MapGroup("/api").RequireRateLimiting("api");
```

---

## 실시간 통신: SignalR

```csharp
builder.Services.AddSignalR();
app.MapHub<ChatHub>("/hubs/chat");

public sealed class ChatHub : Hub
{
    public Task Send(string message) => Clients.All.SendAsync("message", message);
}
```

클라이언트(JS):
```html
<script src="/lib/signalr/signalr.min.js"></script>
<script>
  const conn = new signalR.HubConnectionBuilder().withUrl("/hubs/chat").build();
  conn.on("message", m => console.log(m));
  conn.start().then(() => conn.invoke("Send", "hello"));
</script>
```

---

## gRPC 요약

- **고성능 바이너리** RPC, HTTP/2 필요.
- 계약 우선(Proto)로 타입 안전.
- BFF/내부 서비스 통신에 적합, 브라우저 직접 호출은 제한적(Transcoding/JSON 게이트웨이 고려).

---

## 국제화(Localization)와 시간대

```csharp
builder.Services.AddLocalization();
builder.Services.Configure<RequestLocalizationOptions>(opt =>
{
    var supported = new[] { new CultureInfo("ko-KR"), new CultureInfo("en-US") };
    opt.DefaultRequestCulture = new("ko-KR");
    opt.SupportedCultures = supported;
    opt.SupportedUICultures = supported;
});
app.UseRequestLocalization();
```

뷰에서 리소스 사용:
```cshtml
@inject IViewLocalizer L
<h1>@L["Title"]</h1>
```

---

## 로깅/관측성: Serilog, OpenTelemetry, Health Checks

```csharp
builder.Services.AddHealthChecks()
    .AddDbContextCheck<AppDbContext>("db");

app.MapHealthChecks("/health"); // liveness/readiness probe로 사용
```

OpenTelemetry(요지):
- `AddOpenTelemetry()`로 Traces/Metrics/Logs 수집 → OTLP Exporter → Grafana Tempo/Prometheus/Elastic 등.

---

## 테스트(단위/통합/엔드투엔드)

단위 테스트(xUnit):
```csharp
public sealed class ProductServiceTests
{
    [Fact]
    public async Task Create_Assigns_Id()
    {
        var svc = new ProductService(new InMemoryDb());
        var id = await svc.CreateAsync(new CreateProductRequest { Name = "A", Price = 100 });
        Assert.True(id > 0);
    }
}
```

통합 테스트(WebApplicationFactory):
```csharp
public sealed class ApiTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public ApiTests(WebApplicationFactory<Program> f) => _client = f.CreateClient();

    [Fact]
    public async Task Ping_Returns_Pong()
    {
        var r = await _client.GetFromJsonAsync<JsonElement>("/ping");
        Assert.Equal("pong", r.GetProperty("message").GetString());
    }
}
```

---

## 배포: Docker, Nginx, GitHub Actions, Azure

### Dockerfile(.NET 8)

```dockerfile
# 빌드

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY . .
RUN dotnet publish -c Release -o /out

# 런타임

FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /out .
ENV ASPNETCORE_URLS=http://+:8080
EXPOSE 8080
ENTRYPOINT ["dotnet", "MyAspNetApp.dll"]
```

### Nginx 리버스 프록시

```nginx
server {
    listen 80;
    server_name example.com;
    location / {
        proxy_pass         http://localhost:8080;
        proxy_set_header   Host $host;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto $scheme;
    }
}
```

### GitHub Actions(요지)

```yaml
name: ci
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-dotnet@v4
      with: { dotnet-version: '8.0.x' }
    - run: dotnet restore
    - run: dotnet build --configuration Release --no-restore
    - run: dotnet test --no-build
    - run: dotnet publish -c Release -o out
```

---

## 예제 미니 프로젝트: Admin Razor + Public API 결합

### 요구사항

- Public: `/api/v1/products` REST
- Admin: Razor Pages로 CRUD, 쿠키 인증 + `AdminOnly` 정책
- 공통: EF Core Sqlite, Swagger, HealthCheck

### 핵심 코드 조각

`Program.cs`
```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddDbContext<AppDbContext>(o =>
    o.UseSqlite(builder.Configuration.GetConnectionString("Default")));

builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(o => o.LoginPath = "/account/login");
builder.Services.AddAuthorization(o =>
    o.AddPolicy("AdminOnly", p => p.RequireRole("Admin")));

builder.Services.AddRazorPages(o =>
{
    o.Conventions.AuthorizeFolder("/Admin", "AdminOnly");
});
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddHealthChecks().AddDbContextCheck<AppDbContext>();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger(); app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseAuthentication(); app.UseAuthorization();

app.MapControllers();
app.MapRazorPages();
app.MapHealthChecks("/health");

// Minimal API: ping
app.MapGet("/ping", () => Results.Ok(new { message = "pong" }));

app.Run();
```

`Controllers/ProductsController.cs`
```csharp
[ApiController]
[Route("api/v1/[controller]")]
public sealed class ProductsController : ControllerBase
{
    private readonly AppDbContext _db;
    public ProductsController(AppDbContext db) => _db = db;

    [HttpGet]
    public async Task<IReadOnlyList<ProductDto>> Get()
        => await _db.Products.AsNoTracking()
              .Select(p => new ProductDto(p.Id, p.Name, p.Price))
              .ToListAsync();

    [HttpGet("{id:int}")]
    public async Task<ActionResult<ProductDto>> GetById(int id)
    {
        var p = await _db.Products.FindAsync(id);
        return p is null ? NotFound() : new ProductDto(p.Id, p.Name, p.Price);
    }

    [HttpPost]
    public async Task<IActionResult> Create(CreateProductRequest req)
    {
        if (!ModelState.IsValid) return ValidationProblem(ModelState);
        var e = new Product { Name = req.Name, Price = req.Price };
        _db.Add(e); await _db.SaveChangesAsync();
        return CreatedAtAction(nameof(GetById), new { id = e.Id },
            new ProductDto(e.Id, e.Name, e.Price));
    }
}

public record ProductDto(int Id, string Name, int Price);
public sealed class CreateProductRequest
{
    [Required, StringLength(50)] public string Name { get; init; } = default!;
    [Range(0, int.MaxValue)] public int Price { get; init; }
}
```

`Pages/Admin/Products/Index.cshtml.cs`
```csharp
[Authorize(Policy = "AdminOnly")]
public sealed class IndexModel : PageModel
{
    private readonly AppDbContext _db;
    public List<Product> Items { get; private set; } = [];
    public IndexModel(AppDbContext db) => _db = db;

    public async Task OnGet()
        => Items = await _db.Products.AsNoTracking().ToListAsync();
}
```

---

## 필터, 바인더, 결과 실행: 단정한 횡단 관심사 처리

- **예외 필터**: API 예외 → 표준 ProblemDetails
- **액션 필터**: 메트릭/감사 로깅
- **리소스 필터**: 캐시 정책
- **결과 필터**: 결과 변환 혹은 헤더 삽입

```csharp
public sealed class AuditActionFilter : IAsyncActionFilter
{
    private readonly ILogger<AuditActionFilter> _log;
    public AuditActionFilter(ILogger<AuditActionFilter> log) => _log = log;

    public async Task OnActionExecutionAsync(ActionExecutingContext ctx, ActionExecutionDelegate next)
    {
        var sw = Stopwatch.StartNew();
        var executed = await next();
        sw.Stop();
        _log.LogInformation("Action {Action} took {Elapsed}ms", ctx.ActionDescriptor.DisplayName, sw.ElapsedMilliseconds);
    }
}
```

등록:
```csharp
builder.Services.AddControllers(o => o.Filters.Add<AuditActionFilter>());
```

---

## 파일 업로드/스트리밍/대용량 다운로드

```csharp
[HttpPost("upload")]
[RequestSizeLimit(50_000_000)]
public async Task<IActionResult> Upload(IFormFile file)
{
    if (file.Length == 0) return BadRequest("empty");
    await using var s = file.OpenReadStream();
    await using var fs = System.IO.File.Create(Path.Combine("uploads", file.FileName));
    await s.CopyToAsync(fs);
    return Ok();
}

[HttpGet("download/{name}")]
public IActionResult Download(string name)
{
    var path = Path.Combine("uploads", name);
    if (!System.IO.File.Exists(path)) return NotFound();
    var stream = System.IO.File.OpenRead(path);
    return File(stream, "application/octet-stream", name, enableRangeProcessing: true);
}
```

- `enableRangeProcessing`로 재시작/이어받기 지원.
- Nginx/X-Sendfile 계열로 오프로딩 고려.

---

## 구성/비밀 관리: 환경별 설정, User Secrets, KeyVault

- `appsettings.{Environment}.json` 병합
- 로컬 개발 비밀: `dotnet user-secrets init`, `dotnet user-secrets set "Jwt:Key" "..."`
- 운영 비밀: Azure Key Vault, AWS Secrets Manager, GCP Secret Manager로 주입

---

## 흔한 함정과 체크리스트

- `UseAuthentication` 순서가 `UseAuthorization` 앞에 와야 함
- CORS: 프리플라이트(OPTIONS) 허용, 크리덴셜 사용 시 `AllowCredentials`와 `AllowAnyOrigin` 동시 사용 금지
- 모델 검증: `ApiController` 특성 사용 시 자동 400 응답, 커스터마이즈 필요 시 필터
- EF Core N+1: `Include`, Projection, 캐시로 완화
- 응답 캐싱과 사용자별 변형 주의(Vary 헤더)
- Swagger에서 민감 엔드포인트 노출 주의(환경별 제한)

---

## 간단 전략

1) .NET Standard로 비즈니스 로직 분리 → 재사용
2) 인증/권한: OWIN → ASP.NET Core Auth로 변환
3) web.config → appsettings.json + `Program.cs` 구성
4) System.Web 의존 제거 → 미들웨어/엔드포인트로 치환
5) 빌드/배포 파이프라인을 컨테이너/CI로 표준화

---

## 문서화와 버저닝

- OpenAPI(Swagger): 그룹/태그, 예제 스키마, 보안 스키마(JWT) 설정
- API Versioning 패키지로 `api/v1`, `api/v2` 병행 운용
- 변경 정책: SemVer + Deprecation 헤더 + Sunset 문서화

```csharp
builder.Services.AddApiVersioning(o =>
{
    o.DefaultApiVersion = new ApiVersion(1, 0);
    o.AssumeDefaultVersionWhenUnspecified = true;
    o.ReportApiVersions = true;
});
```

---

## 운영 자동화와 무중단

- 헬스 체크 `/health` → L4/L7에서 롤링/블루그린
- 데이터 마이그레이션 → `dotnet ef database update`를 시작 훅에 포함
- 구조적 로깅(JSON) → 중앙 집계(ELK/OpenSearch/Grafana Loki)
- 피처 플래그 → 런타임 토글/실험

---

## 요약: 선택과 집중

- 간단 REST: **Minimal API**
- 풍부한 필터/모델/뷰: **MVC/Web API**
- 서버 렌더링 단순성: **Razor Pages**
- 실시간: **SignalR**
- 고성능 내부 RPC: **gRPC**
- 배포는 **Docker/Kubernetes**를 기본값으로, **클라우드 네이티브** 패턴을 따른다.

---

## 시작을 도와주는 명령 모음

```bash
# 템플릿

dotnet new list
dotnet new webapi -n ApiDemo
dotnet new webapp -n MvcSite

# 개발 서버 실행

dotnet run

# 패키지

dotnet add package Microsoft.EntityFrameworkCore.Sqlite
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package Swashbuckle.AspNetCore

# 마이그레이션

dotnet ef migrations add Init
dotnet ef database update

# 퍼블리시

dotnet publish -c Release -o out
```

---

# 마무리

기존에 제시된 **정의/특징/구성요소/설치/CLI 실행**의 뼈대를 유지하면서, 본 글은 **.NET 8 기준의 실제 코드 예제와 운영 팁**을 확장해 담았습니다.
이제 **Minimal API로 빠르게 프로토타입**을 만들고, 필요에 따라 **MVC/Razor Pages/SignalR/gRPC**로 스케일업하며, **보안/성능/배포 자동화**를 체계화하는 단계를 밟아 보십시오.
프로젝트의 성격과 팀의 역량에 맞춰 **가장 단순한 설계**부터 시작하는 것이, ASP.NET Core에서 성공하는 지름길입니다.
