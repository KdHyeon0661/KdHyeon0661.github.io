---
layout: post
title: MFC - 동기화, 교착상태 방지
date: 2025-09-06 17:25:23 +0900
category: MFC
---
# 동기화(크리티컬 섹션/이벤트/뮤텍스), 교착상태 방지 체크리스트  
(MFC/Win32 C++ 실전 가이드 + 예제 다수)

이 문서는 **Windows/MFC** 환경에서의 동기화 기초부터 실무 패턴, 그리고 **교착(Deadlock) 방지 체크리스트**까지 “빠짐없이” 정리합니다.  
핵심 프리미티브(**크리티컬 섹션 / 이벤트 / 뮤텍스**)을 중심으로, **세마포어 / SRWLock / Condition Variable / Interlocked**도 비교·보완합니다.  
모든 코드는 ```로 감싸 두었고, **바로 컴파일** 가능한 최소 예시 중심입니다.

> 대상: Win32/MFC(Feature Pack 포함), x64, Unicode  
> 빌드: /W4 권장, C++17 이상 가정  
> 용어: *스레드-세이프* = 다중 스레드에서 안전 / *교착* = 상호 대기 / *기아* = 영원히 스케줄 못 받음

---

## 0) 무엇을 언제 쓰나 — 선택표(한 장 요약)

| 상황 | 추천 프리미티브 | 특징/메모 |
|---|---|---|
| **단일 프로세스 내, 가벼운 상호배제** | **CRITICAL_SECTION** / **SRWLock(Exclusive)** | 가장 빠름(유저모드 경합), 스핀 + 커널 진입 최소 |
| **단일 프로세스, 다수 리더·단일 라이터** | **SRWLock (Shared/Exclusive)** | 리더-라이터 패턴, 경합 낮춤 |
| **프로세스 간 공유(IPC)** | **Mutex/Named Mutex**, **Named Semaphore**, **Named Event** | 커널 오브젝트 필수(핸들 상속/네임) |
| **신호/알림(하나 또는 다수 깨우기)** | **Event(Auto/Manual-reset)** | Auto: 1개 스레드 깨움 / Manual: waiting 스레드 모두 깨울 수 있음 |
| **N개 동시 진입 제한(리미터)** | **Semaphore** | 제작자/소비자, 연결 수 제한 |
| **잠깐의 원자적 카운팅/Flag** | **Interlocked APIs** / `std::atomic<T>` | 경량, 락리스 |
| **GUI + 대기 필요** | **MsgWaitForMultipleObjects** | 메시지 펌프와 동시 |
| **시간 제한/취소** | **WaitForSingleObject(…, timeout)**, **Waitable Timer** | 타임아웃·Cancel 이벤트 |

> **일반 원칙**  
> 1) *가능하면 경량(lock-free/Interlocked / SRW / Critical Section)* → 빠르고 컨텍스트 스위치 적음  
> 2) *프로세스 간*이면 커널 오브젝트(뮤텍스/세마/이벤트)를 사용  
> 3) 대기는 **타임아웃**을 항상 고려(교착/행방불명 방지)

---

## 1) CRITICAL_SECTION — 가장 빠른 상호배제(단일 프로세스)

### 1-1. 기본 사용

```cpp
#include <windows.h>
#include <vector>

CRITICAL_SECTION g_cs;
std::vector<int> g_data;

void Init()  { InitializeCriticalSection(&g_cs); }     // 또는 InitializeCriticalSectionEx
void Fini()  { DeleteCriticalSection(&g_cs); }

void Push(int v) {
    EnterCriticalSection(&g_cs);
    g_data.push_back(v);
    LeaveCriticalSection(&g_cs);
}
```

- **빠름**: 경합 없으면 유저모드에서 즉시 획득/해제  
- **단일 프로세스 전용** (핸들을 이름으로 공유 불가)

### 1-2. 예외/조기 반환 안전: RAII

```cpp
class CAutoCS {
    CRITICAL_SECTION& cs_;
public:
    explicit CAutoCS(CRITICAL_SECTION& cs) : cs_(cs) { EnterCriticalSection(&cs_); }
    ~CAutoCS() { LeaveCriticalSection(&cs_); }
};

void SafePush(int v) {
    CAutoCS lock(g_cs);   // 예외/return에도 확실히 Leave
    g_data.push_back(v);
}
```

### 1-3. TryEnter / 타임아웃(대안)
- `TryEnterCriticalSection` → 즉시 실패 가능 (busy wait 회피)
- 타임아웃이 필요하면 **조건**을 Event/Timer로 설계하거나 SRW/Condition Variable을 고려

---

## 2) SRWLock & Condition Variable — 리더-라이터, 조건대기

### 2-1. SRWLock (Slim Reader/Writer Lock)

```cpp
SRWLOCK g_srw = SRWLOCK_INIT;
std::vector<int> g_list;

// 리더(Shared)
void ReadList() {
    AcquireSRWLockShared(&g_srw);
    // 읽기
    ReleaseSRWLockShared(&g_srw);
}

// 라이터(Exclusive)
void WriteList(int v) {
    AcquireSRWLockExclusive(&g_srw);
    g_list.push_back(v);
    ReleaseSRWLockExclusive(&g_srw);
}
```

- **장점**: 읽기 경합이 많은 경우 유리  
- **주의**: SRWLock은 *재귀 불가*, 타임아웃 없음

### 2-2. Condition Variable + SRW/CS — 생산자/소비자

```cpp
#include <windows.h>
#include <queue>

SRWLOCK g_lock = SRWLOCK_INIT;
CONDITION_VARIABLE g_cv = CONDITION_VARIABLE_INIT;
std::queue<int> g_q;
bool g_stop = false;

void Producer() {
    for (int i=0;i<100;i++) {
        AcquireSRWLockExclusive(&g_lock);
        g_q.push(i);
        ReleaseSRWLockExclusive(&g_lock);
        WakeConditionVariable(&g_cv); // 1개 깨움 (여러개면 WakeAll)
    }
}

void Consumer() {
    for(;;){
        AcquireSRWLockExclusive(&g_lock);
        while (g_q.empty() && !g_stop) {
            SleepConditionVariableSRW(&g_cv, &g_lock, INFINITE, 0);
        }
        if (g_stop && g_q.empty()) { ReleaseSRWLockExclusive(&g_lock); break; }
        int v = g_q.front(); g_q.pop();
        ReleaseSRWLockExclusive(&g_lock);
        // 처리 v
    }
}
```

- **조건변수**는 **락을 들고** 대기하며, 깨우면 **락을 재획득**하고 깨어남  
- **스퓨리어스 웨이크** 가능 → while 루프로 조건 재검사 필수

---

## 3) Event — 신호/알림(오토/매뉴얼 리셋)

### 3-1. Auto-reset Event(1개 스레드만 깨움)

```cpp
HANDLE g_evt = CreateEventW(nullptr, FALSE/*auto*/, FALSE/*nonsignaled*/, nullptr);

void Worker() {
    // 대기
    WaitForSingleObject(g_evt, INFINITE); // 한 스레드만 깨어남
    // 처리...
}

void Kick() { SetEvent(g_evt); }  // 하나만 깨움
```

### 3-2. Manual-reset Event(여러 스레드 깨울 수 있음)

```cpp
HANDLE g_evAll = CreateEventW(nullptr, TRUE/*manual*/, FALSE, nullptr);

// N개 스레드가 Wait 중…
void WakeAll() {
    SetEvent(g_evAll);   // 모두 깨어남
    // 필요 시 ResetEvent(g_evAll)로 재무장
}
```

### 3-3. 타임아웃/취소 결합

```cpp
HANDLE hCancel; // Cancel 이벤트
DWORD rc = WaitForSingleObject(hCancel, timeoutMs);
if (rc == WAIT_OBJECT_0) {/*취소*/} 
else if (rc == WAIT_TIMEOUT) {/*시간초과*/}
```

> **팁**  
> - Auto-reset은 하나만, Manual-reset은 **신호 유지** → 새 대기자도 즉시 통과  
> - “한 번만 알림”이면 Auto, “여러개 깨우기/신호 유지”면 Manual

---

## 4) Mutex — 프로세스 간 상호배제

### 4-1. 기본

```cpp
HANDLE g_mx = CreateMutexW(nullptr, FALSE, L"Local\\MyMutex"); // 이름 있으면 프로세스 간 공유

void CrossProcessCritical() {
    DWORD rc = WaitForSingleObject(g_mx, INFINITE);
    if (rc == WAIT_OBJECT_0) {
        __try {
            // 크리티컬 섹션
        } __finally {
            ReleaseMutex(g_mx);
        }
    }
}
```

- **프로세스 간** 락 공유 가능  
- *Critical Section*보다 **무겁고 느림**

### 4-2. SDDL/ACL(보안) — 다계정/서비스 환경

```cpp
#include <sddl.h>

SECURITY_ATTRIBUTES MakeSA_AllUserRW() {
    SECURITY_ATTRIBUTES sa{ sizeof(sa) };
    PSECURITY_DESCRIPTOR psd=nullptr;
    // Everyone RW 예: "D:(A;;0x12019f;;;WD)" 등 정책에 맞게 조정
    ConvertStringSecurityDescriptorToSecurityDescriptorW(L"D:(A;;GA;;;WD)", SDDL_REVISION_1, &psd, nullptr);
    sa.lpSecurityDescriptor = psd;
    sa.bInheritHandle = FALSE;
    return sa; // 사용 후 LocalFree(psd)
}
```

---

## 5) Semaphore — 동시 N개 허용

```cpp
HANDLE g_sem = CreateSemaphoreW(nullptr, /*initial*/3, /*max*/3, nullptr); // 3개 동시 허용

void Enter() {
    WaitForSingleObject(g_sem, INFINITE); // 토큰 하나 획득
}
void Leave() {
    ReleaseSemaphore(g_sem, 1, nullptr);  // 토큰 반환
}
```

- 연결 수 제한, 스레드/작업 동시 처리 개수 제한

---

## 6) Interlocked & Atomics — 초경량

```cpp
volatile LONG g_counter = 0;

void FastInc() {
    InterlockedIncrement(&g_counter);
}

std::atomic<bool> g_stop{false};
void Stop() { g_stop.store(true, std::memory_order_relaxed); }
bool IsStop() { return g_stop.load(std::memory_order_relaxed); }
```

- **락보다 빠름**, 단 **복합 불변식**에는 락 필요  
- ABA 문제/메모리질서 주의(고급)

---

## 7) Wait 계열: 다중 대기 / 메시지 펌프 연계

### 7-1. WaitForMultipleObjects

```cpp
HANDLE hs[2] = { hWorkDone, hCancel };
DWORD rc = WaitForMultipleObjects(2, hs, FALSE/*any*/, 5000);
if (rc == WAIT_OBJECT_0)        { /*work done*/ }
else if (rc == WAIT_OBJECT_0+1) { /*cancel*/ }
else if (rc == WAIT_TIMEOUT)    { /*timeout*/ }
```

### 7-2. MsgWaitForMultipleObjects — GUI에서 “대기+펌프”

```cpp
HANDLE hs[1] = { hDone };
for (;;) {
    DWORD rc = MsgWaitForMultipleObjects(1, hs, FALSE, 1000, QS_ALLINPUT);
    if (rc == WAIT_OBJECT_0) break;       // done
    if (rc == WAIT_OBJECT_0 + 1) {        // message
        MSG msg; while (PeekMessage(&msg,nullptr,0,0,PM_REMOVE)) {
            TranslateMessage(&msg); DispatchMessage(&msg);
        }
    }
}
```

- 긴 동기 작업 중에도 **UI 응답성 유지**(취소 버튼/프로그레스 움직임)

---

## 8) MFC 래퍼(CriticalSection/Event/Mutex/Semaphore/MultiLock)

```cpp
#include <afxmt.h>  // CCriticalSection, CMutex, CEvent, CSemaphore, CMultiLock

CCriticalSection cs;
CEvent ev(FALSE/*manual?*/, FALSE/*initial*/, nullptr/*name*/);
CMutex mx(FALSE, L"Local\\MyMutex");
CSemaphore sem(3,3);

// 다중 대기
CEvent a(FALSE, FALSE), b(FALSE, FALSE);
CHandle* arr[2] = { &a, &b };
CMultiLock lock(arr, 2);
DWORD idx = lock.Lock(INFINITE, FALSE); // FALSE=Any
```

- **RAII**는 직접 래핑해서 쓰는 것을 강력 권장(예외/return 보호)

---

## 9) 교착(Deadlock) — 원인과 방지 전략

### 9-1. 4대 조건 (Coffman)
1) 상호 배제(Mutual Exclusion)  
2) 점유 대기(Hold and Wait)  
3) 비선점(No Preemption)  
4) **원형 대기(Circular Wait)** ← 실전에서 **이걸 깨라**

### 9-2. 전형적 교착 패턴

- **락 순서 역전**: 스레드 A: L1→L2, 스레드 B: L2→L1  
- **락 보유 중 SendMessage**: 상대가 다시 내 락을 요구(재진입)  
- **락 보유 중 I/O/모달**: 오랜 시간 점유  
- **다중 리소스 + 무한 대기**: 타임아웃 없이 영원 대기

### 9-3. 방지 체크리스트(핵심)

1) **전역 락 순서 정의**: L1 < L2 < L3… 항상 **작은 것 → 큰 것**으로만 취득  
2) **락 보유 시간 최소화**: 긴 작업/ I/O / 모달 UI / Format 문자열 조립 등 **락 바깥으로**  
3) **SendMessage 금지 구역**: 락 보유 중 **SendMessage/모달** 금지(필요하면 PostMessage로 디퍼)  
4) **2개 이상 락 동시에 필요?** 가능하면 **락을 쪼개지 말고 하나로 합치기**, 불가 시 **순서 지키기**  
5) **TryEnter/타임아웃 도입**: 실패 시 회피/백오프/재시도  
6) **재귀 락 금지**(가능하면) + SRW는 **재귀 불가**  
7) **교착 탐지 로깅**: Wait가 일정 시간 초과 시 **스레드/스택덤프 로그**  
8) **작업 큐로 전환**: 상호 락 대신 **메시지/작업 큐**로 소유권 전이

> **실무 팁**: “락 보유 중 콜백 호출”은 매우 위험. 콜백이 다시 같은 락을 요구할 수 있습니다.

### 9-4. 락 순서 예제(규약 문서화)

```txt
[LOCK ORDER]
L_DB   < L_CACHE < L_UI
- DB and CACHE never take UI lock.
- UI never calls into DB while holding L_UI (use async message).
```

코드 리뷰에서 **락 순서 위반을 자동 검색**(간단 스크립트/린트)하면 큰 효과.

---

## 10) 타임아웃/백오프/회복 전략

```cpp
DWORD rc = WaitForSingleObject(hMutex, 2000); // 2초 제한
if (rc == WAIT_TIMEOUT) {
    // (1) 포기하고 호출자에 에러 보고
    // (2) 백오프(Sleep(10..50)) 후 재시도(최대 N회)
    // (3) 상태 점검(상대 스레드 dead? 이벤트로 취소?)
}
```

- **무한 대기 금지**: 운영 환경에서 드물게 발생해도 서비스 전체가 멈춤  
- **백오프**: 경합이 높은 구간에서 **짧은 sleep + 재시도**로 경쟁 완화

---

## 11) 실전 패턴 모음

### 11-1. 생산자/소비자(조건변수 기반)

```cpp
SRWLOCK             g_lock = SRWLOCK_INIT;
CONDITION_VARIABLE  g_hasData = CONDITION_VARIABLE_INIT;
std::queue<Job>     g_jobs;
bool                g_quit = false;

void PushJob(Job j){
    AcquireSRWLockExclusive(&g_lock);
    g_jobs.push(std::move(j));
    ReleaseSRWLockExclusive(&g_lock);
    WakeConditionVariable(&g_hasData);
}

void WorkerLoop(){
    for(;;){
        AcquireSRWLockExclusive(&g_lock);
        while(g_jobs.empty() && !g_quit)
            SleepConditionVariableSRW(&g_hasData, &g_lock, INFINITE, 0);
        if (g_quit && g_jobs.empty()) { ReleaseSRWLockExclusive(&g_lock); break; }
        Job j = std::move(g_jobs.front()); g_jobs.pop();
        ReleaseSRWLockExclusive(&g_lock);
        DoJob(j);
    }
}
```

### 11-2. 취소 가능한 대기(이벤트 2개)

```cpp
HANDLE hs[2] = { hWorkEvent, hCancelEvent };
DWORD rc = WaitForMultipleObjects(2, hs, FALSE, 5000);
if (rc == WAIT_OBJECT_0+1) { /*취소*/ }
```

### 11-3. UI + 백그라운드 처리(메시지/락 혼합 최소화)

- Worker는 **데이터만 처리**, UI 갱신은 **PostMessage**로 위임  
- 공유 구조는 **Copy-on-Write** 또는 **스냅샷**으로 락 시간을 줄임

---

## 12) 디버깅/진단

- **Wait Chain Traversal(WCT)**: 교착 체인 추적  
- **ETW/WPA**: 컨텍스트 스위치/락 경합 분석  
- **스레드 덤프**: 일정 시간 대기 초과 시 **스택 덤프** 로깅(미니덤프)  
- **가드 로그**: 락 획득/해제 시점에 TID, 시간, 보유 시간 기록

```cpp
struct LockProfiler {
    CRITICAL_SECTION& cs; ULONGLONG t0;
    LockProfiler(CRITICAL_SECTION& c): cs(c) { t0=GetTickCount64(); EnterCriticalSection(&cs); }
    ~LockProfiler(){ LeaveCriticalSection(&cs); auto t=GetTickCount64()-t0; if (t>50) LogSlow(t); }
};
```

---

## 13) 고급 토픽: 정합성/메모리 모델/락-프리

- **메모리 장벽**: Interlocked 연산은 **풀 펜스** 제공(명시적 순서 보장)  
- **ABA 문제**: 포인터 스와핑 CAS에서 중간 변형 감지 필요(태그/세대 카운트)  
- **Hazard Pointer / Epoch GC**: 고급 락-프리 구조의 메모리 생명주기 관리(범위 밖)

> 실무에서는 **락-프리**보다 **락 최소화 + 구조 분리**가 유지보수/안정성 측면에서 유리한 경우가 많음.

---

## 14) 미니 레퍼런스(요약 시그니처)

- `InitializeCriticalSection`, `Enter/LeaveCriticalSection`, `TryEnterCriticalSection`  
- `Acquire/ReleaseSRWLock(Shared/Exclusive)`  
- `InitializeConditionVariable`, `SleepConditionVariableSRW`, `Wake/WakeAllConditionVariable`  
- `CreateEvent`, `SetEvent`, `ResetEvent`, `PulseEvent(지양)`  
- `CreateMutex`, `ReleaseMutex`  
- `CreateSemaphore`, `ReleaseSemaphore`  
- `WaitForSingleObject/WaitForMultipleObjects/MsgWait…`  
- `InterlockedIncrement/Decrement/CompareExchange/ExchangeAdd`  
- `CreateWaitableTimer/SetWaitableTimer/CancelWaitableTimer`

---

## 15) 실전 체크리스트(최종)

**설계 단계**
- [ ] 공유 데이터 최소화(불변 객체/스냅샷/메시지 패싱 우선)  
- [ ] 락 순서 문서화(L1<L2<… 규약)  
- [ ] 긴 작업은 락 없이(락 밖으로 옮기기)  
- [ ] 대기에는 **타임아웃** 기본 적용  
- [ ] UI 스레드에서 **SendMessage/모달**과 **락**을 함께 쓰지 않기

**구현 단계**
- [ ] RAII로 락/핸들 해제 보장  
- [ ] TryEnter/백오프/재시도 설계  
- [ ] Event는 Auto/Manual 차이 정확히 적용(Reset 타이밍 명확화)  
- [ ] 프로세스 간은 Named + SDDL 고려  
- [ ] 생산자/소비자엔 Condition Variable 또는 Event + 큐

**테스트/운영**
- [ ] 스트레스 테스트(경합/대량) + 결함 주입(지연/타임아웃/취소)  
- [ ] 락 보유 시간 측정 로깅  
- [ ] 교착 추적 도구(WCT) 사용법 숙지  
- [ ] 타임아웃/취소 시 복구 경로 확인

---

## 16) 예제 모음(한눈에)

### 16-1. 크리티컬 섹션 + RAII

```cpp
CRITICAL_SECTION g_cs;
struct AutoCS { CRITICAL_SECTION& c; AutoCS(CRITICAL_SECTION& c):c(c){EnterCriticalSection(&c);} ~AutoCS(){LeaveCriticalSection(&c);} };
void Foo(){ AutoCS _(g_cs); /* 임계 영역 */ }
```

### 16-2. 이벤트(Manual)로 여러 소비자 깨우기

```cpp
HANDLE g_ev = CreateEvent(nullptr, TRUE, FALSE, nullptr);
void StartAll(){ SetEvent(g_ev); }  // 모두 통과
void ResetAll(){ ResetEvent(g_ev); }
```

### 16-3. 뮤텍스(프로세스 간) + 타임아웃

```cpp
HANDLE g_mx = CreateMutex(nullptr, FALSE, L"Local\\MyApp\\Mux");
if (WaitForSingleObject(g_mx, 2000)==WAIT_OBJECT_0) {
    __try { /* 크리티컬 */ } __finally { ReleaseMutex(g_mx); }
} else { /* 점유 중: 실패 처리 */ }
```

### 16-4. SRW + Condition Variable

```cpp
SRWLOCK L = SRWLOCK_INIT; CONDITION_VARIABLE CV = CONDITION_VARIABLE_INIT; bool ready=false;
void Waiter(){ AcquireSRWLockExclusive(&L); while(!ready) SleepConditionVariableSRW(&CV,&L,INFINITE,0); ReleaseSRWLockExclusive(&L); }
void Signal(){ AcquireSRWLockExclusive(&L); ready=true; ReleaseSRWLockExclusive(&L); WakeAllConditionVariable(&CV); }
```

### 16-5. 세마포어(동시 실행 4개 제한)

```cpp
CSemaphore sem(4,4);
void Task(){ sem.Lock(); __try { Work(); } __finally { sem.Unlock(); } }
```

---

### 마무리

- **올바른 프리미티브 선택 + 락 시간 최소화 + 순서 규약**만 지켜도 대다수 동기화 문제는 예방됩니다.  
- “**락 보유 중 Send/모달/IO 금지**”, “**항상 타임아웃**”, “**교착 방지 리스트**”를 팀 규약으로 만들면 품질이 급상승합니다.  
- 필요하시면 현재 코드베이스의 **락/대기 지점**을 스캔해, **교착 잠재 지점**과 **개선 패턴**(RAII/타임아웃/큐 전환)을 문서/패치로 정리해 드릴게요. 🔧
