---
layout: post
title: MFC - ë™ê¸°í™”, êµì°©ìƒíƒœ ë°©ì§€
date: 2025-09-06 17:25:23 +0900
category: MFC
---
# ë™ê¸°í™”(í¬ë¦¬í‹°ì»¬ ì„¹ì…˜/ì´ë²¤íŠ¸/ë®¤í…ìŠ¤), êµì°©ìƒíƒœ ë°©ì§€ ì²´í¬ë¦¬ìŠ¤íŠ¸

(MFC/Win32 C++ ì‹¤ì „ ê°€ì´ë“œ + ì˜ˆì œ ë‹¤ìˆ˜)

ì´ ë¬¸ì„œëŠ” **Windows/MFC** í™˜ê²½ì—ì„œì˜ ë™ê¸°í™” ê¸°ì´ˆë¶€í„° ì‹¤ë¬´ íŒ¨í„´, ê·¸ë¦¬ê³  **êµì°©(Deadlock) ë°©ì§€ ì²´í¬ë¦¬ìŠ¤íŠ¸**ê¹Œì§€ â€œë¹ ì§ì—†ì´â€ ì •ë¦¬í•©ë‹ˆë‹¤.
í•µì‹¬ í”„ë¦¬ë¯¸í‹°ë¸Œ(**í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ / ì´ë²¤íŠ¸ / ë®¤í…ìŠ¤**)ì„ ì¤‘ì‹¬ìœ¼ë¡œ, **ì„¸ë§ˆí¬ì–´ / SRWLock / Condition Variable / Interlocked**ë„ ë¹„êµÂ·ë³´ì™„í•©ë‹ˆë‹¤.
ëª¨ë“  ì½”ë“œëŠ” ```ë¡œ ê°ì‹¸ ë‘ì—ˆê³ , **ë°”ë¡œ ì»´íŒŒì¼** ê°€ëŠ¥í•œ ìµœì†Œ ì˜ˆì‹œ ì¤‘ì‹¬ì…ë‹ˆë‹¤.

> ëŒ€ìƒ: Win32/MFC(Feature Pack í¬í•¨), x64, Unicode
> ë¹Œë“œ: /W4 ê¶Œì¥, C++17 ì´ìƒ ê°€ì •
> ìš©ì–´: *ìŠ¤ë ˆë“œ-ì„¸ì´í”„* = ë‹¤ì¤‘ ìŠ¤ë ˆë“œì—ì„œ ì•ˆì „ / *êµì°©* = ìƒí˜¸ ëŒ€ê¸° / *ê¸°ì•„* = ì˜ì›íˆ ìŠ¤ì¼€ì¤„ ëª» ë°›ìŒ

---

## ë¬´ì—‡ì„ ì–¸ì œ ì“°ë‚˜ â€” ì„ íƒí‘œ(í•œ ì¥ ìš”ì•½)

| ìƒí™© | ì¶”ì²œ í”„ë¦¬ë¯¸í‹°ë¸Œ | íŠ¹ì§•/ë©”ëª¨ |
|---|---|---|
| **ë‹¨ì¼ í”„ë¡œì„¸ìŠ¤ ë‚´, ê°€ë²¼ìš´ ìƒí˜¸ë°°ì œ** | **CRITICAL_SECTION** / **SRWLock(Exclusive)** | ê°€ì¥ ë¹ ë¦„(ìœ ì €ëª¨ë“œ ê²½í•©), ìŠ¤í•€ + ì»¤ë„ ì§„ì… ìµœì†Œ |
| **ë‹¨ì¼ í”„ë¡œì„¸ìŠ¤, ë‹¤ìˆ˜ ë¦¬ë”Â·ë‹¨ì¼ ë¼ì´í„°** | **SRWLock (Shared/Exclusive)** | ë¦¬ë”-ë¼ì´í„° íŒ¨í„´, ê²½í•© ë‚®ì¶¤ |
| **í”„ë¡œì„¸ìŠ¤ ê°„ ê³µìœ (IPC)** | **Mutex/Named Mutex**, **Named Semaphore**, **Named Event** | ì»¤ë„ ì˜¤ë¸Œì íŠ¸ í•„ìˆ˜(í•¸ë“¤ ìƒì†/ë„¤ì„) |
| **ì‹ í˜¸/ì•Œë¦¼(í•˜ë‚˜ ë˜ëŠ” ë‹¤ìˆ˜ ê¹¨ìš°ê¸°)** | **Event(Auto/Manual-reset)** | Auto: 1ê°œ ìŠ¤ë ˆë“œ ê¹¨ì›€ / Manual: waiting ìŠ¤ë ˆë“œ ëª¨ë‘ ê¹¨ìš¸ ìˆ˜ ìˆìŒ |
| **Nê°œ ë™ì‹œ ì§„ì… ì œí•œ(ë¦¬ë¯¸í„°)** | **Semaphore** | ì œì‘ì/ì†Œë¹„ì, ì—°ê²° ìˆ˜ ì œí•œ |
| **ì ê¹ì˜ ì›ìì  ì¹´ìš´íŒ…/Flag** | **Interlocked APIs** / `std::atomic<T>` | ê²½ëŸ‰, ë½ë¦¬ìŠ¤ |
| **GUI + ëŒ€ê¸° í•„ìš”** | **MsgWaitForMultipleObjects** | ë©”ì‹œì§€ íŒí”„ì™€ ë™ì‹œ |
| **ì‹œê°„ ì œí•œ/ì·¨ì†Œ** | **WaitForSingleObject(â€¦, timeout)**, **Waitable Timer** | íƒ€ì„ì•„ì›ƒÂ·Cancel ì´ë²¤íŠ¸ |

> **ì¼ë°˜ ì›ì¹™**
> 1) *ê°€ëŠ¥í•˜ë©´ ê²½ëŸ‰(lock-free/Interlocked / SRW / Critical Section)* â†’ ë¹ ë¥´ê³  ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ ì ìŒ
> 2) *í”„ë¡œì„¸ìŠ¤ ê°„*ì´ë©´ ì»¤ë„ ì˜¤ë¸Œì íŠ¸(ë®¤í…ìŠ¤/ì„¸ë§ˆ/ì´ë²¤íŠ¸)ë¥¼ ì‚¬ìš©
> 3) ëŒ€ê¸°ëŠ” **íƒ€ì„ì•„ì›ƒ**ì„ í•­ìƒ ê³ ë ¤(êµì°©/í–‰ë°©ë¶ˆëª… ë°©ì§€)

---

## CRITICAL_SECTION â€” ê°€ì¥ ë¹ ë¥¸ ìƒí˜¸ë°°ì œ(ë‹¨ì¼ í”„ë¡œì„¸ìŠ¤)

### 1-1. ê¸°ë³¸ ì‚¬ìš©

```cpp
#include <windows.h>
#include <vector>

CRITICAL_SECTION g_cs;
std::vector<int> g_data;

void Init()  { InitializeCriticalSection(&g_cs); }     // ë˜ëŠ” InitializeCriticalSectionEx
void Fini()  { DeleteCriticalSection(&g_cs); }

void Push(int v) {
    EnterCriticalSection(&g_cs);
    g_data.push_back(v);
    LeaveCriticalSection(&g_cs);
}
```

- **ë¹ ë¦„**: ê²½í•© ì—†ìœ¼ë©´ ìœ ì €ëª¨ë“œì—ì„œ ì¦‰ì‹œ íšë“/í•´ì œ
- **ë‹¨ì¼ í”„ë¡œì„¸ìŠ¤ ì „ìš©** (í•¸ë“¤ì„ ì´ë¦„ìœ¼ë¡œ ê³µìœ  ë¶ˆê°€)

### 1-2. ì˜ˆì™¸/ì¡°ê¸° ë°˜í™˜ ì•ˆì „: RAII

```cpp
class CAutoCS {
    CRITICAL_SECTION& cs_;
public:
    explicit CAutoCS(CRITICAL_SECTION& cs) : cs_(cs) { EnterCriticalSection(&cs_); }
    ~CAutoCS() { LeaveCriticalSection(&cs_); }
};

void SafePush(int v) {
    CAutoCS lock(g_cs);   // ì˜ˆì™¸/returnì—ë„ í™•ì‹¤íˆ Leave
    g_data.push_back(v);
}
```

### 1-3. TryEnter / íƒ€ì„ì•„ì›ƒ(ëŒ€ì•ˆ)

- `TryEnterCriticalSection` â†’ ì¦‰ì‹œ ì‹¤íŒ¨ ê°€ëŠ¥ (busy wait íšŒí”¼)
- íƒ€ì„ì•„ì›ƒì´ í•„ìš”í•˜ë©´ **ì¡°ê±´**ì„ Event/Timerë¡œ ì„¤ê³„í•˜ê±°ë‚˜ SRW/Condition Variableì„ ê³ ë ¤

---

## SRWLock & Condition Variable â€” ë¦¬ë”-ë¼ì´í„°, ì¡°ê±´ëŒ€ê¸°

### 2-1. SRWLock (Slim Reader/Writer Lock)

```cpp
SRWLOCK g_srw = SRWLOCK_INIT;
std::vector<int> g_list;

// ë¦¬ë”(Shared)
void ReadList() {
    AcquireSRWLockShared(&g_srw);
    // ì½ê¸°
    ReleaseSRWLockShared(&g_srw);
}

// ë¼ì´í„°(Exclusive)
void WriteList(int v) {
    AcquireSRWLockExclusive(&g_srw);
    g_list.push_back(v);
    ReleaseSRWLockExclusive(&g_srw);
}
```

- **ì¥ì **: ì½ê¸° ê²½í•©ì´ ë§ì€ ê²½ìš° ìœ ë¦¬
- **ì£¼ì˜**: SRWLockì€ *ì¬ê·€ ë¶ˆê°€*, íƒ€ì„ì•„ì›ƒ ì—†ìŒ

### 2-2. Condition Variable + SRW/CS â€” ìƒì‚°ì/ì†Œë¹„ì

```cpp
#include <windows.h>
#include <queue>

SRWLOCK g_lock = SRWLOCK_INIT;
CONDITION_VARIABLE g_cv = CONDITION_VARIABLE_INIT;
std::queue<int> g_q;
bool g_stop = false;

void Producer() {
    for (int i=0;i<100;i++) {
        AcquireSRWLockExclusive(&g_lock);
        g_q.push(i);
        ReleaseSRWLockExclusive(&g_lock);
        WakeConditionVariable(&g_cv); // 1ê°œ ê¹¨ì›€ (ì—¬ëŸ¬ê°œë©´ WakeAll)
    }
}

void Consumer() {
    for(;;){
        AcquireSRWLockExclusive(&g_lock);
        while (g_q.empty() && !g_stop) {
            SleepConditionVariableSRW(&g_cv, &g_lock, INFINITE, 0);
        }
        if (g_stop && g_q.empty()) { ReleaseSRWLockExclusive(&g_lock); break; }
        int v = g_q.front(); g_q.pop();
        ReleaseSRWLockExclusive(&g_lock);
        // ì²˜ë¦¬ v
    }
}
```

- **ì¡°ê±´ë³€ìˆ˜**ëŠ” **ë½ì„ ë“¤ê³ ** ëŒ€ê¸°í•˜ë©°, ê¹¨ìš°ë©´ **ë½ì„ ì¬íšë“**í•˜ê³  ê¹¨ì–´ë‚¨
- **ìŠ¤í“¨ë¦¬ì–´ìŠ¤ ì›¨ì´í¬** ê°€ëŠ¥ â†’ while ë£¨í”„ë¡œ ì¡°ê±´ ì¬ê²€ì‚¬ í•„ìˆ˜

---

## Event â€” ì‹ í˜¸/ì•Œë¦¼(ì˜¤í† /ë§¤ë‰´ì–¼ ë¦¬ì…‹)

### 3-1. Auto-reset Event(1ê°œ ìŠ¤ë ˆë“œë§Œ ê¹¨ì›€)

```cpp
HANDLE g_evt = CreateEventW(nullptr, FALSE/*auto*/, FALSE/*nonsignaled*/, nullptr);

void Worker() {
    // ëŒ€ê¸°
    WaitForSingleObject(g_evt, INFINITE); // í•œ ìŠ¤ë ˆë“œë§Œ ê¹¨ì–´ë‚¨
    // ì²˜ë¦¬...
}

void Kick() { SetEvent(g_evt); }  // í•˜ë‚˜ë§Œ ê¹¨ì›€
```

### 3-2. Manual-reset Event(ì—¬ëŸ¬ ìŠ¤ë ˆë“œ ê¹¨ìš¸ ìˆ˜ ìˆìŒ)

```cpp
HANDLE g_evAll = CreateEventW(nullptr, TRUE/*manual*/, FALSE, nullptr);

// Nê°œ ìŠ¤ë ˆë“œê°€ Wait ì¤‘â€¦
void WakeAll() {
    SetEvent(g_evAll);   // ëª¨ë‘ ê¹¨ì–´ë‚¨
    // í•„ìš” ì‹œ ResetEvent(g_evAll)ë¡œ ì¬ë¬´ì¥
}
```

### 3-3. íƒ€ì„ì•„ì›ƒ/ì·¨ì†Œ ê²°í•©

```cpp
HANDLE hCancel; // Cancel ì´ë²¤íŠ¸
DWORD rc = WaitForSingleObject(hCancel, timeoutMs);
if (rc == WAIT_OBJECT_0) {/*ì·¨ì†Œ*/}
else if (rc == WAIT_TIMEOUT) {/*ì‹œê°„ì´ˆê³¼*/}
```

> **íŒ**
> - Auto-resetì€ í•˜ë‚˜ë§Œ, Manual-resetì€ **ì‹ í˜¸ ìœ ì§€** â†’ ìƒˆ ëŒ€ê¸°ìë„ ì¦‰ì‹œ í†µê³¼
> - â€œí•œ ë²ˆë§Œ ì•Œë¦¼â€ì´ë©´ Auto, â€œì—¬ëŸ¬ê°œ ê¹¨ìš°ê¸°/ì‹ í˜¸ ìœ ì§€â€ë©´ Manual

---

## Mutex â€” í”„ë¡œì„¸ìŠ¤ ê°„ ìƒí˜¸ë°°ì œ

### 4-1. ê¸°ë³¸

```cpp
HANDLE g_mx = CreateMutexW(nullptr, FALSE, L"Local\\MyMutex"); // ì´ë¦„ ìˆìœ¼ë©´ í”„ë¡œì„¸ìŠ¤ ê°„ ê³µìœ 

void CrossProcessCritical() {
    DWORD rc = WaitForSingleObject(g_mx, INFINITE);
    if (rc == WAIT_OBJECT_0) {
        __try {
            // í¬ë¦¬í‹°ì»¬ ì„¹ì…˜
        } __finally {
            ReleaseMutex(g_mx);
        }
    }
}
```

- **í”„ë¡œì„¸ìŠ¤ ê°„** ë½ ê³µìœ  ê°€ëŠ¥
- *Critical Section*ë³´ë‹¤ **ë¬´ê²ê³  ëŠë¦¼**

### â€” ë‹¤ê³„ì •/ì„œë¹„ìŠ¤ í™˜ê²½

```cpp
#include <sddl.h>

SECURITY_ATTRIBUTES MakeSA_AllUserRW() {
    SECURITY_ATTRIBUTES sa{ sizeof(sa) };
    PSECURITY_DESCRIPTOR psd=nullptr;
    // Everyone RW ì˜ˆ: "D:(A;;0x12019f;;;WD)" ë“± ì •ì±…ì— ë§ê²Œ ì¡°ì •
    ConvertStringSecurityDescriptorToSecurityDescriptorW(L"D:(A;;GA;;;WD)", SDDL_REVISION_1, &psd, nullptr);
    sa.lpSecurityDescriptor = psd;
    sa.bInheritHandle = FALSE;
    return sa; // ì‚¬ìš© í›„ LocalFree(psd)
}
```

---

## Semaphore â€” ë™ì‹œ Nê°œ í—ˆìš©

```cpp
HANDLE g_sem = CreateSemaphoreW(nullptr, /*initial*/3, /*max*/3, nullptr); // 3ê°œ ë™ì‹œ í—ˆìš©

void Enter() {
    WaitForSingleObject(g_sem, INFINITE); // í† í° í•˜ë‚˜ íšë“
}
void Leave() {
    ReleaseSemaphore(g_sem, 1, nullptr);  // í† í° ë°˜í™˜
}
```

- ì—°ê²° ìˆ˜ ì œí•œ, ìŠ¤ë ˆë“œ/ì‘ì—… ë™ì‹œ ì²˜ë¦¬ ê°œìˆ˜ ì œí•œ

---

## Interlocked & Atomics â€” ì´ˆê²½ëŸ‰

```cpp
volatile LONG g_counter = 0;

void FastInc() {
    InterlockedIncrement(&g_counter);
}

std::atomic<bool> g_stop{false};
void Stop() { g_stop.store(true, std::memory_order_relaxed); }
bool IsStop() { return g_stop.load(std::memory_order_relaxed); }
```

- **ë½ë³´ë‹¤ ë¹ ë¦„**, ë‹¨ **ë³µí•© ë¶ˆë³€ì‹**ì—ëŠ” ë½ í•„ìš”
- ABA ë¬¸ì œ/ë©”ëª¨ë¦¬ì§ˆì„œ ì£¼ì˜(ê³ ê¸‰)

---

## Wait ê³„ì—´: ë‹¤ì¤‘ ëŒ€ê¸° / ë©”ì‹œì§€ íŒí”„ ì—°ê³„

### 7-1. WaitForMultipleObjects

```cpp
HANDLE hs[2] = { hWorkDone, hCancel };
DWORD rc = WaitForMultipleObjects(2, hs, FALSE/*any*/, 5000);
if (rc == WAIT_OBJECT_0)        { /*work done*/ }
else if (rc == WAIT_OBJECT_0+1) { /*cancel*/ }
else if (rc == WAIT_TIMEOUT)    { /*timeout*/ }
```

### 7-2. MsgWaitForMultipleObjects â€” GUIì—ì„œ â€œëŒ€ê¸°+íŒí”„â€

```cpp
HANDLE hs[1] = { hDone };
for (;;) {
    DWORD rc = MsgWaitForMultipleObjects(1, hs, FALSE, 1000, QS_ALLINPUT);
    if (rc == WAIT_OBJECT_0) break;       // done
    if (rc == WAIT_OBJECT_0 + 1) {        // message
        MSG msg; while (PeekMessage(&msg,nullptr,0,0,PM_REMOVE)) {
            TranslateMessage(&msg); DispatchMessage(&msg);
        }
    }
}
```

- ê¸´ ë™ê¸° ì‘ì—… ì¤‘ì—ë„ **UI ì‘ë‹µì„± ìœ ì§€**(ì·¨ì†Œ ë²„íŠ¼/í”„ë¡œê·¸ë ˆìŠ¤ ì›€ì§ì„)

---

## MFC ë˜í¼(CriticalSection/Event/Mutex/Semaphore/MultiLock)

```cpp
#include <afxmt.h>  // CCriticalSection, CMutex, CEvent, CSemaphore, CMultiLock

CCriticalSection cs;
CEvent ev(FALSE/*manual?*/, FALSE/*initial*/, nullptr/*name*/);
CMutex mx(FALSE, L"Local\\MyMutex");
CSemaphore sem(3,3);

// ë‹¤ì¤‘ ëŒ€ê¸°
CEvent a(FALSE, FALSE), b(FALSE, FALSE);
CHandle* arr[2] = { &a, &b };
CMultiLock lock(arr, 2);
DWORD idx = lock.Lock(INFINITE, FALSE); // FALSE=Any
```

- **RAII**ëŠ” ì§ì ‘ ë˜í•‘í•´ì„œ ì“°ëŠ” ê²ƒì„ ê°•ë ¥ ê¶Œì¥(ì˜ˆì™¸/return ë³´í˜¸)

---

## â€” ì›ì¸ê³¼ ë°©ì§€ ì „ëµ

### 9-1. 4ëŒ€ ì¡°ê±´ (Coffman)

1) ìƒí˜¸ ë°°ì œ(Mutual Exclusion)
2) ì ìœ  ëŒ€ê¸°(Hold and Wait)
3) ë¹„ì„ ì (No Preemption)
4) **ì›í˜• ëŒ€ê¸°(Circular Wait)** â† ì‹¤ì „ì—ì„œ **ì´ê±¸ ê¹¨ë¼**

### 9-2. ì „í˜•ì  êµì°© íŒ¨í„´

- **ë½ ìˆœì„œ ì—­ì „**: ìŠ¤ë ˆë“œ A: L1â†’L2, ìŠ¤ë ˆë“œ B: L2â†’L1
- **ë½ ë³´ìœ  ì¤‘ SendMessage**: ìƒëŒ€ê°€ ë‹¤ì‹œ ë‚´ ë½ì„ ìš”êµ¬(ì¬ì§„ì…)
- **ë½ ë³´ìœ  ì¤‘ I/O/ëª¨ë‹¬**: ì˜¤ëœ ì‹œê°„ ì ìœ 
- **ë‹¤ì¤‘ ë¦¬ì†ŒìŠ¤ + ë¬´í•œ ëŒ€ê¸°**: íƒ€ì„ì•„ì›ƒ ì—†ì´ ì˜ì› ëŒ€ê¸°

### 9-3. ë°©ì§€ ì²´í¬ë¦¬ìŠ¤íŠ¸(í•µì‹¬)

1) **ì „ì—­ ë½ ìˆœì„œ ì •ì˜**: L1 < L2 < L3â€¦ í•­ìƒ **ì‘ì€ ê²ƒ â†’ í° ê²ƒ**ìœ¼ë¡œë§Œ ì·¨ë“
2) **ë½ ë³´ìœ  ì‹œê°„ ìµœì†Œí™”**: ê¸´ ì‘ì—…/ I/O / ëª¨ë‹¬ UI / Format ë¬¸ìì—´ ì¡°ë¦½ ë“± **ë½ ë°”ê¹¥ìœ¼ë¡œ**
3) **SendMessage ê¸ˆì§€ êµ¬ì—­**: ë½ ë³´ìœ  ì¤‘ **SendMessage/ëª¨ë‹¬** ê¸ˆì§€(í•„ìš”í•˜ë©´ PostMessageë¡œ ë””í¼)
4) **2ê°œ ì´ìƒ ë½ ë™ì‹œì— í•„ìš”?** ê°€ëŠ¥í•˜ë©´ **ë½ì„ ìª¼ê°œì§€ ë§ê³  í•˜ë‚˜ë¡œ í•©ì¹˜ê¸°**, ë¶ˆê°€ ì‹œ **ìˆœì„œ ì§€í‚¤ê¸°**
5) **TryEnter/íƒ€ì„ì•„ì›ƒ ë„ì…**: ì‹¤íŒ¨ ì‹œ íšŒí”¼/ë°±ì˜¤í”„/ì¬ì‹œë„
6) **ì¬ê·€ ë½ ê¸ˆì§€**(ê°€ëŠ¥í•˜ë©´) + SRWëŠ” **ì¬ê·€ ë¶ˆê°€**
7) **êµì°© íƒì§€ ë¡œê¹…**: Waitê°€ ì¼ì • ì‹œê°„ ì´ˆê³¼ ì‹œ **ìŠ¤ë ˆë“œ/ìŠ¤íƒë¤í”„ ë¡œê·¸**
8) **ì‘ì—… íë¡œ ì „í™˜**: ìƒí˜¸ ë½ ëŒ€ì‹  **ë©”ì‹œì§€/ì‘ì—… í**ë¡œ ì†Œìœ ê¶Œ ì „ì´

> **ì‹¤ë¬´ íŒ**: â€œë½ ë³´ìœ  ì¤‘ ì½œë°± í˜¸ì¶œâ€ì€ ë§¤ìš° ìœ„í—˜. ì½œë°±ì´ ë‹¤ì‹œ ê°™ì€ ë½ì„ ìš”êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 9-4. ë½ ìˆœì„œ ì˜ˆì œ(ê·œì•½ ë¬¸ì„œí™”)

```txt
[LOCK ORDER]
L_DB   < L_CACHE < L_UI
- DB and CACHE never take UI lock.
- UI never calls into DB while holding L_UI (use async message).
```

ì½”ë“œ ë¦¬ë·°ì—ì„œ **ë½ ìˆœì„œ ìœ„ë°˜ì„ ìë™ ê²€ìƒ‰**(ê°„ë‹¨ ìŠ¤í¬ë¦½íŠ¸/ë¦°íŠ¸)í•˜ë©´ í° íš¨ê³¼.

---

## íƒ€ì„ì•„ì›ƒ/ë°±ì˜¤í”„/íšŒë³µ ì „ëµ

```cpp
DWORD rc = WaitForSingleObject(hMutex, 2000); // 2ì´ˆ ì œí•œ
if (rc == WAIT_TIMEOUT) {
    // (1) í¬ê¸°í•˜ê³  í˜¸ì¶œìì— ì—ëŸ¬ ë³´ê³ 
    // (2) ë°±ì˜¤í”„(Sleep(10..50)) í›„ ì¬ì‹œë„(ìµœëŒ€ NíšŒ)
    // (3) ìƒíƒœ ì ê²€(ìƒëŒ€ ìŠ¤ë ˆë“œ dead? ì´ë²¤íŠ¸ë¡œ ì·¨ì†Œ?)
}
```

- **ë¬´í•œ ëŒ€ê¸° ê¸ˆì§€**: ìš´ì˜ í™˜ê²½ì—ì„œ ë“œë¬¼ê²Œ ë°œìƒí•´ë„ ì„œë¹„ìŠ¤ ì „ì²´ê°€ ë©ˆì¶¤
- **ë°±ì˜¤í”„**: ê²½í•©ì´ ë†’ì€ êµ¬ê°„ì—ì„œ **ì§§ì€ sleep + ì¬ì‹œë„**ë¡œ ê²½ìŸ ì™„í™”

---

## ì‹¤ì „ íŒ¨í„´ ëª¨ìŒ

### 11-1. ìƒì‚°ì/ì†Œë¹„ì(ì¡°ê±´ë³€ìˆ˜ ê¸°ë°˜)

```cpp
SRWLOCK             g_lock = SRWLOCK_INIT;
CONDITION_VARIABLE  g_hasData = CONDITION_VARIABLE_INIT;
std::queue<Job>     g_jobs;
bool                g_quit = false;

void PushJob(Job j){
    AcquireSRWLockExclusive(&g_lock);
    g_jobs.push(std::move(j));
    ReleaseSRWLockExclusive(&g_lock);
    WakeConditionVariable(&g_hasData);
}

void WorkerLoop(){
    for(;;){
        AcquireSRWLockExclusive(&g_lock);
        while(g_jobs.empty() && !g_quit)
            SleepConditionVariableSRW(&g_hasData, &g_lock, INFINITE, 0);
        if (g_quit && g_jobs.empty()) { ReleaseSRWLockExclusive(&g_lock); break; }
        Job j = std::move(g_jobs.front()); g_jobs.pop();
        ReleaseSRWLockExclusive(&g_lock);
        DoJob(j);
    }
}
```

### 11-2. ì·¨ì†Œ ê°€ëŠ¥í•œ ëŒ€ê¸°(ì´ë²¤íŠ¸ 2ê°œ)

```cpp
HANDLE hs[2] = { hWorkEvent, hCancelEvent };
DWORD rc = WaitForMultipleObjects(2, hs, FALSE, 5000);
if (rc == WAIT_OBJECT_0+1) { /*ì·¨ì†Œ*/ }
```

### 11-3. UI + ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬(ë©”ì‹œì§€/ë½ í˜¼í•© ìµœì†Œí™”)

- WorkerëŠ” **ë°ì´í„°ë§Œ ì²˜ë¦¬**, UI ê°±ì‹ ì€ **PostMessage**ë¡œ ìœ„ì„
- ê³µìœ  êµ¬ì¡°ëŠ” **Copy-on-Write** ë˜ëŠ” **ìŠ¤ëƒ…ìƒ·**ìœ¼ë¡œ ë½ ì‹œê°„ì„ ì¤„ì„

---

## ë””ë²„ê¹…/ì§„ë‹¨

- **Wait Chain Traversal(WCT)**: êµì°© ì²´ì¸ ì¶”ì 
- **ETW/WPA**: ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜/ë½ ê²½í•© ë¶„ì„
- **ìŠ¤ë ˆë“œ ë¤í”„**: ì¼ì • ì‹œê°„ ëŒ€ê¸° ì´ˆê³¼ ì‹œ **ìŠ¤íƒ ë¤í”„** ë¡œê¹…(ë¯¸ë‹ˆë¤í”„)
- **ê°€ë“œ ë¡œê·¸**: ë½ íšë“/í•´ì œ ì‹œì ì— TID, ì‹œê°„, ë³´ìœ  ì‹œê°„ ê¸°ë¡

```cpp
struct LockProfiler {
    CRITICAL_SECTION& cs; ULONGLONG t0;
    LockProfiler(CRITICAL_SECTION& c): cs(c) { t0=GetTickCount64(); EnterCriticalSection(&cs); }
    ~LockProfiler(){ LeaveCriticalSection(&cs); auto t=GetTickCount64()-t0; if (t>50) LogSlow(t); }
};
```

---

## ê³ ê¸‰ í† í”½: ì •í•©ì„±/ë©”ëª¨ë¦¬ ëª¨ë¸/ë½-í”„ë¦¬

- **ë©”ëª¨ë¦¬ ì¥ë²½**: Interlocked ì—°ì‚°ì€ **í’€ íœìŠ¤** ì œê³µ(ëª…ì‹œì  ìˆœì„œ ë³´ì¥)
- **ABA ë¬¸ì œ**: í¬ì¸í„° ìŠ¤ì™€í•‘ CASì—ì„œ ì¤‘ê°„ ë³€í˜• ê°ì§€ í•„ìš”(íƒœê·¸/ì„¸ëŒ€ ì¹´ìš´íŠ¸)
- **Hazard Pointer / Epoch GC**: ê³ ê¸‰ ë½-í”„ë¦¬ êµ¬ì¡°ì˜ ë©”ëª¨ë¦¬ ìƒëª…ì£¼ê¸° ê´€ë¦¬(ë²”ìœ„ ë°–)

> ì‹¤ë¬´ì—ì„œëŠ” **ë½-í”„ë¦¬**ë³´ë‹¤ **ë½ ìµœì†Œí™” + êµ¬ì¡° ë¶„ë¦¬**ê°€ ìœ ì§€ë³´ìˆ˜/ì•ˆì •ì„± ì¸¡ë©´ì—ì„œ ìœ ë¦¬í•œ ê²½ìš°ê°€ ë§ìŒ.

---

## ë¯¸ë‹ˆ ë ˆí¼ëŸ°ìŠ¤(ìš”ì•½ ì‹œê·¸ë‹ˆì²˜)

- `InitializeCriticalSection`, `Enter/LeaveCriticalSection`, `TryEnterCriticalSection`
- `Acquire/ReleaseSRWLock(Shared/Exclusive)`
- `InitializeConditionVariable`, `SleepConditionVariableSRW`, `Wake/WakeAllConditionVariable`
- `CreateEvent`, `SetEvent`, `ResetEvent`, `PulseEvent(ì§€ì–‘)`
- `CreateMutex`, `ReleaseMutex`
- `CreateSemaphore`, `ReleaseSemaphore`
- `WaitForSingleObject/WaitForMultipleObjects/MsgWaitâ€¦`
- `InterlockedIncrement/Decrement/CompareExchange/ExchangeAdd`
- `CreateWaitableTimer/SetWaitableTimer/CancelWaitableTimer`

---

## ì‹¤ì „ ì²´í¬ë¦¬ìŠ¤íŠ¸(ìµœì¢…)

**ì„¤ê³„ ë‹¨ê³„**
- [ ] ê³µìœ  ë°ì´í„° ìµœì†Œí™”(ë¶ˆë³€ ê°ì²´/ìŠ¤ëƒ…ìƒ·/ë©”ì‹œì§€ íŒ¨ì‹± ìš°ì„ )
- [ ] ë½ ìˆœì„œ ë¬¸ì„œí™”(L1<L2<â€¦ ê·œì•½)
- [ ] ê¸´ ì‘ì—…ì€ ë½ ì—†ì´(ë½ ë°–ìœ¼ë¡œ ì˜®ê¸°ê¸°)
- [ ] ëŒ€ê¸°ì—ëŠ” **íƒ€ì„ì•„ì›ƒ** ê¸°ë³¸ ì ìš©
- [ ] UI ìŠ¤ë ˆë“œì—ì„œ **SendMessage/ëª¨ë‹¬**ê³¼ **ë½**ì„ í•¨ê»˜ ì“°ì§€ ì•Šê¸°

**êµ¬í˜„ ë‹¨ê³„**
- [ ] RAIIë¡œ ë½/í•¸ë“¤ í•´ì œ ë³´ì¥
- [ ] TryEnter/ë°±ì˜¤í”„/ì¬ì‹œë„ ì„¤ê³„
- [ ] EventëŠ” Auto/Manual ì°¨ì´ ì •í™•íˆ ì ìš©(Reset íƒ€ì´ë° ëª…í™•í™”)
- [ ] í”„ë¡œì„¸ìŠ¤ ê°„ì€ Named + SDDL ê³ ë ¤
- [ ] ìƒì‚°ì/ì†Œë¹„ìì—” Condition Variable ë˜ëŠ” Event + í

**í…ŒìŠ¤íŠ¸/ìš´ì˜**
- [ ] ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸(ê²½í•©/ëŒ€ëŸ‰) + ê²°í•¨ ì£¼ì…(ì§€ì—°/íƒ€ì„ì•„ì›ƒ/ì·¨ì†Œ)
- [ ] ë½ ë³´ìœ  ì‹œê°„ ì¸¡ì • ë¡œê¹…
- [ ] êµì°© ì¶”ì  ë„êµ¬(WCT) ì‚¬ìš©ë²• ìˆ™ì§€
- [ ] íƒ€ì„ì•„ì›ƒ/ì·¨ì†Œ ì‹œ ë³µêµ¬ ê²½ë¡œ í™•ì¸

---

## ì˜ˆì œ ëª¨ìŒ(í•œëˆˆì—)

### 16-1. í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ + RAII

```cpp
CRITICAL_SECTION g_cs;
struct AutoCS { CRITICAL_SECTION& c; AutoCS(CRITICAL_SECTION& c):c(c){EnterCriticalSection(&c);} ~AutoCS(){LeaveCriticalSection(&c);} };
void Foo(){ AutoCS _(g_cs); /* ì„ê³„ ì˜ì—­ */ }
```

### 16-2. ì´ë²¤íŠ¸(Manual)ë¡œ ì—¬ëŸ¬ ì†Œë¹„ì ê¹¨ìš°ê¸°

```cpp
HANDLE g_ev = CreateEvent(nullptr, TRUE, FALSE, nullptr);
void StartAll(){ SetEvent(g_ev); }  // ëª¨ë‘ í†µê³¼
void ResetAll(){ ResetEvent(g_ev); }
```

### + íƒ€ì„ì•„ì›ƒ

```cpp
HANDLE g_mx = CreateMutex(nullptr, FALSE, L"Local\\MyApp\\Mux");
if (WaitForSingleObject(g_mx, 2000)==WAIT_OBJECT_0) {
    __try { /* í¬ë¦¬í‹°ì»¬ */ } __finally { ReleaseMutex(g_mx); }
} else { /* ì ìœ  ì¤‘: ì‹¤íŒ¨ ì²˜ë¦¬ */ }
```

### 16-4. SRW + Condition Variable

```cpp
SRWLOCK L = SRWLOCK_INIT; CONDITION_VARIABLE CV = CONDITION_VARIABLE_INIT; bool ready=false;
void Waiter(){ AcquireSRWLockExclusive(&L); while(!ready) SleepConditionVariableSRW(&CV,&L,INFINITE,0); ReleaseSRWLockExclusive(&L); }
void Signal(){ AcquireSRWLockExclusive(&L); ready=true; ReleaseSRWLockExclusive(&L); WakeAllConditionVariable(&CV); }
```

### 16-5. ì„¸ë§ˆí¬ì–´(ë™ì‹œ ì‹¤í–‰ 4ê°œ ì œí•œ)

```cpp
CSemaphore sem(4,4);
void Task(){ sem.Lock(); __try { Work(); } __finally { sem.Unlock(); } }
```

---

### ë§ˆë¬´ë¦¬

- **ì˜¬ë°”ë¥¸ í”„ë¦¬ë¯¸í‹°ë¸Œ ì„ íƒ + ë½ ì‹œê°„ ìµœì†Œí™” + ìˆœì„œ ê·œì•½**ë§Œ ì§€ì¼œë„ ëŒ€ë‹¤ìˆ˜ ë™ê¸°í™” ë¬¸ì œëŠ” ì˜ˆë°©ë©ë‹ˆë‹¤.
- â€œ**ë½ ë³´ìœ  ì¤‘ Send/ëª¨ë‹¬/IO ê¸ˆì§€**â€, â€œ**í•­ìƒ íƒ€ì„ì•„ì›ƒ**â€, â€œ**êµì°© ë°©ì§€ ë¦¬ìŠ¤íŠ¸**â€ë¥¼ íŒ€ ê·œì•½ìœ¼ë¡œ ë§Œë“¤ë©´ í’ˆì§ˆì´ ê¸‰ìƒìŠ¹í•©ë‹ˆë‹¤.
- í•„ìš”í•˜ì‹œë©´ í˜„ì¬ ì½”ë“œë² ì´ìŠ¤ì˜ **ë½/ëŒ€ê¸° ì§€ì **ì„ ìŠ¤ìº”í•´, **êµì°© ì ì¬ ì§€ì **ê³¼ **ê°œì„  íŒ¨í„´**(RAII/íƒ€ì„ì•„ì›ƒ/í ì „í™˜)ì„ ë¬¸ì„œ/íŒ¨ì¹˜ë¡œ ì •ë¦¬í•´ ë“œë¦´ê²Œìš”. ğŸ”§
