---
layout: post
title: DB 심화 - 비교 연산자·컬럼 순서·인덱스 군집성, 그리고 비효율 해소 전략
date: 2025-11-07 21:25:23 +0900
category: DB 심화
---
# 비교 연산자·컬럼 순서·인덱스 군집성, 그리고 비효율 해소 전략

## 0. 실습 스키마 & 데이터 생성

먼저, 아래 실습 환경을 기준으로 설명을 전개한다.  
(다른 스키마에서 재현하려면 테이블/인덱스 이름만 바꾸면 된다.)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL; -- DBMS_XPLAN ALLSTATS LAST 용

DROP TABLE ix_demo PURGE;

CREATE TABLE ix_demo (
  cust_id    NUMBER        NOT NULL,
  order_dt   DATE          NOT NULL,
  order_id   NUMBER        NOT NULL,
  status     VARCHAR2(8)   NOT NULL,
  amount     NUMBER(12,2)  NOT NULL,
  note       VARCHAR2(100),
  CONSTRAINT pk_ix_demo PRIMARY KEY (order_id)  -- Surrogate PK
);

BEGIN
  -- 데이터: 고객 10만명, 각 15~40건, 2년 치 날짜 분포
  FOR c IN 1..100000 LOOP
    FOR k IN 1..TRUNC(DBMS_RANDOM.VALUE(15, 40)) LOOP
      INSERT INTO ix_demo
      VALUES (
        c,
        DATE '2024-01-01' + TRUNC(DBMS_RANDOM.VALUE(0, 730)),  -- 2년 범위
        c*1000 + k,
        CASE MOD(c+k,5)
          WHEN 0 THEN 'NEW'
          WHEN 1 THEN 'PAID'
          WHEN 2 THEN 'SHIP'
          WHEN 3 THEN 'DONE'
          ELSE 'CANC'
        END,
        ROUND(DBMS_RANDOM.VALUE(10, 200000), 2),
        CASE WHEN MOD(c+k,97)=0 THEN 'gift' END
      );
    END LOOP;
  END LOOP;
  COMMIT;
END;
/

-- 서로 다른 컬럼 순서를 가진 인덱스 2개
CREATE INDEX ix_c_dt ON ix_demo(cust_id, order_dt, order_id);      -- 고객→날짜 (고객 기준 군집)
CREATE INDEX ix_dt_c ON ix_demo(order_dt, cust_id, order_id);      -- 날짜→고객 (날짜 기준 군집)
CREATE INDEX ix_status ON ix_demo(status);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER,
    'IX_DEMO',
    cascade     => TRUE,
    method_opt  => 'for all columns size skewonly'
  );
END;
/
```

실행계획은 아래 템플릿으로 확인할 수 있다.

```sql
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, NULL,
    'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'
  )
);
```

---

## 1. 비교 연산자와 컬럼 순서가 만드는 **인덱스 레코드 군집성**

### 1.1 군집성과 랜덤 I/O 직관

B-tree 인덱스에서 **Leaf 블록**은 인덱스 키에 따라 **사전순으로 정렬된 레코드 집합**이다.  
이때, 하나의 SQL이 읽어야 하는 Row들이

- **인접한 Leaf 블록**에 모여 있으면:  
  → **동일/인접 블록 재사용**이 많아짐 → 랜덤 I/O ↓  
- **멀리 떨어진 Leaf 블록**에 흩어져 있으면:  
  → 매번 다른 블록을 읽어야 함 → 랜덤 I/O ↑

이를 아주 거칠게 수식으로 쓰면,

$$
\text{Random I/O} \propto 
\frac{\text{스캔 중 방문한 인덱스 블록 수}}{\text{각 블록에서 실제 사용한 행 수}}
$$

즉, **같은 블록에서 해결하는 행이 많을수록** 유리하다.  
이 “같은 블록에 얼마나 모여 있느냐”가 바로 **군집성(Clustering)** 이다.

Oracle에서 흔히 보는 **Clustering Factor(CF)** 는

- 인덱스 키 순서대로 테이블 RowID를 따라가면서  
  **블록이 바뀌는 횟수**를 측정해 만든 값이다.
- CF가 **테이블 블록 수에 가까울수록** 군집성이 좋고,  
  CF가 **테이블 행 수에 가까울수록** 군집성이 나쁘다.

이 CF는 **컬럼 순서**, **데이터 로딩 패턴**(삽입 순서), **리빌드 여부** 등에 크게 의존한다.

---

### 1.2 연산자별 “스캔 폭”과 군집성

비교 연산자는 인덱스 상에서 **어느 정도 범위를 스캔할지**에 직접 영향을 준다.

대략적 경향을 표로 정리하면:

| 연산자/패턴                         | 스캔 폭 경향                     | 비고 |
|------------------------------------|----------------------------------|------|
| `col = :v`                         | 가장 좁음 (등치 범위)           | 선행컬럼이면 최고 효율 |
| `col IN (v1, v2, ...)`            | 값 개수만큼 등치 범위 (여러 구간)| 값 수·분포에 따라 효율 변동 |
| `col BETWEEN a AND b`             | a~b 연속 구간 전체               | 구간 길이가 성능 좌우 |
| `col >= a` / `col <= b`           | 테이블 한쪽 끝까지 갈 수 있음    | 편향 분포 시 특히 주의 |
| `col LIKE 'abc%'`                 | `'abc' ~ 'abd'` 사이 범위        | 접두사 길이에 따라 폭 결정 |
| `col LIKE '%abc'`, `'%abc%'` 등   | 범위 정의 불가 → FullScan 경향  | 인덱스 비활성화 위험 |
| `col IS NULL` / `col IS NOT NULL` | 값 분포에 따라 폭 매우 달라짐    | NOT NULL은 폭 넓을 가능성 큼 |
| `함수(col) = 값`                  | 대부분 인덱스 사용 불가         | 함수기반 인덱스 필요 |

이 표에서 **스캔 폭이 좁을수록 군집성이 상대적으로 유지**되기 쉽다.  
반대로, 선행 컬럼이 `>= / <= / BETWEEN / IS NOT NULL` 같은 **넓은 범위**면  
후행 컬럼이 등치/좁은 범위라도 **이미 늦다**는 것이 핵심이다.

---

### 1.3 컬럼 순서가 바뀌면 군집성이 어떻게 달라지는가

실습 환경에는 두 개의 복합 인덱스가 있다.

- `ix_c_dt (cust_id, order_dt, order_id)` : **고객 기준 군집**
- `ix_dt_c (order_dt, cust_id, order_id)` : **날짜 기준 군집**

같은 WHERE 절이라도,  
어떤 인덱스를 타느냐에 따라 **시작 위치**와 **연속 구간 길이**가 완전히 달라진다.

#### 예제 A: “특정 고객의 최근 30일 주문”

```sql
VAR cid NUMBER;
EXEC :cid := 12345;

SELECT /* A_BASE */
       order_id, order_dt, amount, status
FROM   ix_demo
WHERE  cust_id  = :cid
AND    order_dt BETWEEN SYSDATE-30 AND SYSDATE
ORDER  BY order_dt, order_id;
```

- 인덱스 `ix_c_dt` 를 타면  
  - 선행 `cust_id = :cid` 로 **짧은 연속 구간**부터 시작한다.  
  - 그 구간 안에서 `order_dt BETWEEN` 범위를 적용하므로  
    스캔 폭이 “해당 고객의 30일치” 정도로 매우 좁다.
- 인덱스 `ix_dt_c` 를 타면  
  - 날짜 범위 `order_dt BETWEEN ...` 로 **2년 데이터 중 30일치**를 먼저 스캔하고  
  - 그 안에서 `cust_id = :cid` 필터를 적용한다.  
  - 전국 고객 중 해당 고객만 찾으려면 훨씬 많은 블록을 읽게 된다.

실행계획으로 보면:

```sql
SELECT /*+ INDEX(ix_demo ix_c_dt) A_CDT */
       order_id, order_dt, amount, status
FROM   ix_demo
WHERE  cust_id  = :cid
AND    order_dt BETWEEN SYSDATE-30 AND SYSDATE
ORDER  BY order_dt, order_id;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);

SELECT /*+ INDEX(ix_demo ix_dt_c) A_DTCH */
       order_id, order_dt, amount, status
FROM   ix_demo
WHERE  cust_id  = :cid
AND    order_dt BETWEEN SYSDATE-30 AND SYSDATE
ORDER  BY order_dt, order_id;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);
```

두 실행계획의 **Buffers/Reads**를 비교하면

- `ix_c_dt` : 훨씬 적은 블록 방문
- `ix_dt_c` : 더 많은 블록 방문 (날짜·고객이 뒤섞여 있어서 군집성↓)

이라는 것이 숫자로 드러난다.

#### 예제 B: “특정 날짜의 일부 고객 구간”

```sql
VAR d  DATE; 
VAR c1 NUMBER; 
VAR c2 NUMBER;
EXEC :d  := DATE '2025-10-15';
EXEC :c1 := 100;
EXEC :c2 := 1000;

SELECT /* B_BASE */
       order_id, order_dt, cust_id
FROM   ix_demo
WHERE  order_dt = :d
AND    cust_id BETWEEN :c1 AND :c2
ORDER  BY cust_id, order_id;
```

- 인덱스 `ix_dt_c` :
  - 선행 `order_dt = :d` 로 해당 날짜 범위를 짧게 잡고  
    그 안에서 `cust_id BETWEEN` 으로 좁힌다.  
  → 효율적
- 인덱스 `ix_c_dt` :
  - 선행 `cust_id BETWEEN :c1 AND :c2` 로 **거대한 고객 구간**을 훑고  
    그 안에서 `order_dt = :d` 를 필터한다.  
  → 비효율

이처럼 “어디를 선행 컬럼으로 두느냐”가  
**“어디서부터 짧은 구간으로 스캔을 시작할 수 있는지”**를 결정한다.

---

## 2. 선행 컬럼이 등치(=)가 아닐 때 발생하는 비효율

### 2.1 문제의 본질

B-tree 인덱스는 항상 **선행 컬럼** 기준으로 정렬된다.  
따라서 선행 컬럼 조건이

- `=` 이면:  
  → 해당 값에 해당하는 키 구간이 **짧고 연속된 범위**로 존재  
  → 그 구간만 훑으면 됨
- `BETWEEN`, `>=`, `<=` 이면:  
  → 선행 값의 **큰 구간**을 통째로 훑어야 함  
  → 후행 컬럼 조건이 좋아도, 이미 스캔 폭이 넓어진 상태에서 필터만 할 뿐

즉, **선행 컬럼이 등치가 아닐 때**는 후행 컬럼을 잘 써도  
“이미 넓게 훑고 있다”는 점이 치명적이다.

### 2.2 코드 예: 선행 범위 + 후행 등치

```sql
-- 인덱스: ix_c_dt (cust_id, order_dt, order_id)
VAR c1 NUMBER; VAR c2 NUMBER; VAR d DATE;
EXEC :c1 := 1000;
EXEC :c2 := 9000;
EXEC :d  := DATE '2025-10-15';

SELECT /* BAD_LEADING_RANGE */
       order_id
FROM   ix_demo
WHERE  cust_id BETWEEN :c1 AND :c2
AND    order_dt = :d;
```

- `cust_id BETWEEN :c1 AND :c2` 는  
  인덱스 상에서 **널찍한 구간**을 의미.
- 그 넓은 구간에서 Row 들을 읽어가며  
  `order_dt = :d` 를 **Filter** 로만 적용한다.

이 쿼리를 `ix_dt_c` 로 다시 설계하고,

```sql
CREATE INDEX ix_dt_c2 ON ix_demo(order_dt, cust_id, order_id);
```

다음과 같이 실행하면:

```sql
SELECT /* GOOD_LEADING_EQ +INDEX(ix_demo ix_dt_c2) */
       order_id
FROM   ix_demo
WHERE  order_dt = :d
AND    cust_id BETWEEN :c1 AND :c2;
```

이번에는

- `order_dt = :d` 가 선행 등치 → 해당 날짜 구간만 짧게 스캔  
- 그 안에서 `cust_id BETWEEN :c1 AND :c2` 를 적용하므로  
  스캔 범위가 확 줄어든다.

### 2.3 실행계획에서 어떻게 보이는가

위 두 SQL에 대해 `ALLSTATS LAST` 를 보면 대개:

- 둘 다 `INDEX RANGE SCAN` 이라도  
  - **선행 범위**인 경우: A-Rows(스캔된 인덱스 행) 대비 최종 Rows 비율이 낮고 Buffers/Reads ↑  
  - **선행 등치**인 경우: A-Rows 자체가 작고 Buffers/Reads ↓

이라는 차이가 보인다.

**핵심 포인트**

1. **선행 컬럼 조건**이 비용을 결정한다.
2. 후행 컬럼 조건은 선행 컬럼이 제대로 좁혀진 뒤에야 빛을 발한다.
3. WHERE/JOIN/ORDER BY 패턴을 보고  
   “선행에 **등치(=)**가 오게” 인덱스 순서를 조정하는 것이 가장 강력한 튜닝이다.

---

## 3. `BETWEEN`을 `IN` 리스트로 분해하는 전략

### 3.1 왜 `IN` 분해가 의미가 있는가

`BETWEEN a AND b` 는 **연속 구간**을 한 번에 스캔하는 패턴이다.  
이 구간이 좁으면 좋지만, 넓으면 랜덤 I/O가 늘어난다.

만약 그 컬럼이 **이산 값**(예: 날짜를 “일 단위”로만 저장)이고,  
범위 폭이 그리 크지 않다면,

- `BETWEEN` 을
- 여러 개의 **등치 조건 IN (a, a+1, …, b)** 으로 분해하면,

옵티마이저는 내부적으로

- 각 값에 대해 **짧은 등치 범위 스캔**을 수행하거나,
- OR-Expansion/UNION ALL 을 활용해  
  **여러 개의 작은 Range Scan**으로 분해할 수 있다.

### 3.2 예제: 일 단위 날짜에서 BETWEEN vs IN

```sql
-- (가정) order_dt는 TRUNC(order_dt) 형태로만 저장된다고 치자.
VAR cid NUMBER;
EXEC :cid := 12345;

-- (1) BETWEEN
SELECT /* B_BETWEEN */
       COUNT(*)
FROM   ix_demo
WHERE  cust_id  = :cid
AND    order_dt BETWEEN DATE '2025-10-01' AND DATE '2025-10-31';

-- (2) IN 리스트 분해 (실전에서는 PL/SQL/어플리케이션에서 동적 생성)
SELECT /* B_IN */
       COUNT(*)
FROM   ix_demo
WHERE  cust_id = :cid
AND    order_dt IN (
  DATE '2025-10-01', DATE '2025-10-02', DATE '2025-10-03',
  -- ...
  DATE '2025-10-31'
);
```

인덱스 `ix_c_dt (cust_id, order_dt, order_id)` 기준으로 보면,

- `cust_id = :cid` 는 선행 등치 → 해당 고객 인덱스 구간만 스캔
- 그 안에서  
  - `BETWEEN` 은 “10월 한 달”을 **연속 범위**로 훑고,  
  - `IN` 은 “일별”로 **쪼개진 등치 범위** 여러 개를 스캔하는 효과가 있다.

범위를 여러 개로 쪼개는 것이 항상 좋다는 의미는 아니지만,  
일 단위·적당한 일수(예: 7~31일 정도)라면  
**인덱스/통계 상황에 따라 더 좋은 플랜**이 나오는 경우가 있다.

### 3.3 실제 구현 패턴

실무에서는 이렇게 PL/SQL 쪽에서 “IN 리스트”를 만든다.

```plsql
DECLARE
  v_sql   CLOB;
  v_start DATE := DATE '2025-10-01';
  v_end   DATE := DATE '2025-10-31';
  v_day   DATE;
BEGIN
  v_sql := 'SELECT COUNT(*) FROM ix_demo WHERE cust_id = :cid AND order_dt IN (';

  v_day := v_start;
  WHILE v_day <= v_end LOOP
    IF v_day > v_start THEN
      v_sql := v_sql || ',';
    END IF;
    v_sql := v_sql || 'DATE '''||TO_CHAR(v_day,'YYYY-MM-DD')||'''';
    v_day := v_day + 1;
  END LOOP;
  v_sql := v_sql || ')';

  -- 이제 v_sql을 EXECUTE IMMEDIATE 등으로 실행
  DBMS_OUTPUT.PUT_LINE(v_sql);
END;
/
```

물론 이 방식은

- IN 리스트가 너무 길어지면  
  → 파싱 비용/커서 공유에 부정적일 수 있고
- 바인드 변수 활용이 까다로워진다.

그래서 **항상 최선**은 아니고,

- 범위 폭이 크지 않을 때
- 해당 구간 쿼리가 매우 중요할 때

**하나의 도구**로 활용할 수 있다 정도로 이해하면 좋다.

---

## 4. INDEX SKIP SCAN — 선행 컬럼이 없거나 비등치일 때의 “응급 패치”

### 4.1 개념

**Index Skip Scan** 은 복합 인덱스에서

- 선행 컬럼에 조건이 없거나,
- 선행 컬럼 조건이 비등치여서,

원래는 인덱스 활용이 제한적인 상황에서,  
**선행 컬럼의 모든(또는 일부) 가능한 값들을 가정**하여  
후행 컬럼으로 **여러 차례 짧은 Range Scan** 을 수행하는 방식이다.

예를 들어, `(cust_id, order_dt)` 인덱스에서

```sql
SELECT * 
FROM   ix_demo
WHERE  order_dt = DATE '2025-10-15';
```

원래라면 선행 `cust_id` 조건이 없으니 **이 인덱스를 제대로 쓰기 어렵다**.  
하지만 Skip Scan을 쓰면 내부적으로

- `cust_id = 1, order_dt = …`
- `cust_id = 2, order_dt = …`
- `cust_id = 3, order_dt = …`
- …

처럼 선행 컬럼에 가능한 값을 대입해 **짧은 탐색을 반복**한다.

당연히 **선행 컬럼의 distinct 값 개수가 적어야** 효율적이다.

### 4.2 예제: Skip Scan 힌트 사용

```sql
-- 인덱스: ix_c_dt (cust_id, order_dt, order_id)
VAR d DATE;
EXEC :d := DATE '2025-10-15';

-- 원래 설계론 (order_dt, cust_id) 인덱스를 두는 게 정석이지만,
-- 일단 없는 상황에서 Skip Scan을 유도해보자.
SELECT /* SS1 */
       COUNT(*)
FROM   ix_demo
WHERE  order_dt = :d;

SELECT /*+ INDEX_SS(ix_demo ix_c_dt) SS2 */
       COUNT(*)
FROM   ix_demo
WHERE  order_dt = :d;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);
```

- `INDEX_SS` 힌트는 Skip Scan 후보 인덱스에 붙인다.
- `cust_id` distinct 값이 적당히 작다면 (예: 수백 개 수준),  
  Full Scan보다는 나을 수 있다.
- 하지만 이 예제처럼 고객이 10만 명 수준이면,  
  사실 Skip Scan은 **선행 값 10만 개에 대해 반복**하는 꼴이 되어 매우 비싸진다.

### 4.3 선행 비등치 + 후행 등치에서의 Skip Scan

```sql
-- (cust_id BETWEEN) + (order_dt = 특정일) in (cust_id, order_dt)
VAR c1 NUMBER; VAR c2 NUMBER; VAR d DATE;
EXEC :c1 := 1000;
EXEC :c2 := 9000;
EXEC :d  := DATE '2025-10-15';

SELECT /* SS3 */
       order_id
FROM   ix_demo
WHERE  cust_id BETWEEN :c1 AND :c2
AND    order_dt = :d;

SELECT /*+ INDEX_SS(ix_demo ix_c_dt) SS4 */
       order_id
FROM   ix_demo
WHERE  cust_id BETWEEN :c1 AND :c2
AND    order_dt = :d;
```

- `INDEX_SS` 를 추가하면, 옵티마이저가  
  `(cust_id, order_dt)` 인덱스상에서  
  후행 `order_dt = :d` 를 활용하는 Skip Scan 전략을 시도할 수 있다.
- 하지만 여전히 **선행 구간 크기**, **값 분포**, **distinct 값 개수**에 따라  
  효율은 크게 달라진다.

**결론**

- Skip Scan 은 **전용 인덱스를 새로 만들 수 없거나,  
  빠르게 임시 개선이 필요할 때 쓸 수 있는 보조 수단**이다.
- 중·장기적으로는 **WHERE/JOIN/ORDER BY 패턴에 맞는 인덱스를 새로 설계**하는 것이 정석이다.

---

## 5. 범위 검색(BETWEEN/>,<) 남용과 그 비효율

### 5.1 자주 보이는 나쁜 습관

실무 SQL에서 흔히 보이는 패턴:

```sql
WHERE col >= :p_low
  AND col <= :p_high
```

를 **“일단 안전하니까”** 라는 이유로 남발하거나,

```sql
WHERE col1 >= :p1
  AND col1 <= :p2
  AND col2 >= :q1
  AND col2 <= :q2
```

처럼 컬럼별로 넓은 범위를 함께 사용한다.

이런 패턴이 문제인 이유:

1. 선행 컬럼이 범위라면 → 그 다음 컬럼 조건이 아무리 좋아도 이미 늦다.
2. 넓은 범위는 **많은 인덱스 블록**을 읽게 하고,  
   테이블 랜덤 I/O도 증가시킨다.
3. 통계/히스토그램에 따라 **옵티마이저의 선택도 추정**이 어긋날 가능성도 커진다.

### 5.2 증상

- 실행계획상 인덱스를 타고 있음에도,  
  `ALLSTATS LAST` 를 보면
  - `A-Rows` (실제 인덱스 스캔 행 수)가 매우 크고
  - `Buffers`/`Reads` 가 커서 응답시간이 길다.
- 같은 기능을 하는 **다른 인덱스/쿼리 패턴**으로 바꾸면  
  갑자기 Buffers/Reads 가 줄어든다.

### 5.3 개선 전략 정리

1. **선행 등치**가 오도록 인덱스 컬럼 순서를 바꾸기  
   - “가장 자주 쓰는 필터/조인 컬럼”을 선행에,  
     그 컬럼 조건은 WHERE에서 **=`:`** 형태로 고정하는 패턴을 만든다.
2. `BETWEEN` 을 값 분포에 따라 **`IN` / `OR` 분해**  
   - 값이 **이산**이고, 구간 폭이 크지 않을 때  
     등치/소구간으로 쪼개면 오히려 효율적일 수 있다.
3. **파티셔닝 + Pruning**  
   - 기간 기준 Partitioning을 쓰면  
     WHERE 조건으로 **대상 파티션만** 읽게 할 수 있다.
4. **함수 기반 인덱스**(가상 컬럼 포함)  
   - 실제로는 `TRUNC(order_dt)` 로만 조회한다면  
     `(TRUNC(order_dt))` 기반 인덱스를 두어  
     “의도한 범위”만 직접 탐색하게 한다.
5. **정렬 일치 인덱스 + Stopkey**  
   - Top-N/페이지 조회에서 정렬 순서와 인덱스 정렬이 일치하면  
     **앞 블록 몇 개만** 읽고 종료한다.
6. Skip Scan은 **선행 값 종류가 적을 때만** 응급 수단으로 사용.
7. 통계/ACS(Adaptive Cursor Sharing)를 통해  
   **값별 편향**이 심한 컬럼은 적절한 히스토그램을 유지.

---

## 6. 케이스 스터디: 조건·인덱스 조합별 스캔 효율 비교

여기서는 몇 가지 대표적인 시나리오를 통해  
어떤 인덱스/조건이 효율적·비효율적인지 **실험 패턴**까지 포함해 정리한다.

### 6.1 시나리오 ① — “고객=등치 + 기간 범위” (일반적인 OLTP 조회)

```sql
VAR cid NUMBER;
VAR d1  DATE;
VAR d2  DATE;
EXEC :cid := 12345;
EXEC :d1  := SYSDATE - 30;
EXEC :d2  := SYSDATE;

-- (1) 기본 패턴: BETWEEN + (cust, dt) 인덱스
SELECT /* S1_BASE */
       order_id, order_dt, amount
FROM   ix_demo
WHERE  cust_id  = :cid
AND    order_dt BETWEEN :d1 AND :d2
ORDER  BY order_dt, order_id;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);
```

- 인덱스 `ix_c_dt` 는 이 패턴에 잘 맞음  
  → 선행 등치 + 후행 범위 + 정렬 흡수

그리고 같은 쿼리를 `ix_dt_c` 로 강제해 보고 비교한다.

```sql
SELECT /*+ INDEX(ix_demo ix_dt_c) S1_DT_FIRST */
       order_id, order_dt, amount
FROM   ix_demo
WHERE  cust_id  = :cid
AND    order_dt BETWEEN :d1 AND :d2
ORDER  BY order_dt, order_id;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);
```

대개

- `ix_c_dt` 사용 시 Buffers/Reads 훨씬 작음
- `ix_dt_c` 는 날짜 범위부터 잡아서 비효율

이라는 결과가 나온다.

#### 6.1.1 변형 — `BETWEEN → IN` 분해

```sql
-- (가정) order_dt가 일 단위로만 저장된다고 치자
-- 날짜 목록은 어플리케이션/PLSQL에서 동적으로 생성
SELECT /* S1_IN */
       order_id, order_dt, amount
FROM   ix_demo
WHERE  cust_id  = :cid
AND    order_dt IN (:d1, :d1+1, :d1+2, :d1+3, :d1+4, :d1+5, :d1+6)
ORDER  BY order_dt, order_id;
```

실제로 `ALLSTATS LAST` 로 비교하면,

- 상황에 따라 IN 분해가 BETWEEN 보다 조금 더 나은 플랜이 나오기도 하고,
- 반대로 차이가 없거나, 오히려 나빠질 수도 있다.

**이 방식은 “꼭 써야 하는 공식”이 아니라,  
데이터 분포/통계를 고려해 “선택적으로 쓸 수 있는 튜닝 옵션”**으로 이해하면 된다.

#### 6.1.2 변형 — DESC 인덱스 + Stopkey로 Top-N

```sql
CREATE INDEX ix_c_dt_desc ON ix_demo(cust_id, order_dt DESC, order_id DESC);

SELECT /* S1_TOPN */
       order_id, order_dt, amount
FROM   ix_demo
WHERE  cust_id = :cid
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);
```

- 정렬과 인덱스 방향이 일치 → Sort 연산이 사라지거나 크게 줄어든다.
- `FETCH FIRST 50 ROWS ONLY` 는 **Stopkey**로 작동 →  
  앞쪽 몇 개 Leaf 블록만 읽고 종료한다.
- 실무에서 “마이페이지 최근 주문 50건” 같은 API 에서는  
  이 패턴이 거의 **정석**이다.

---

### 6.2 시나리오 ② — “날짜=등치 + 고객 범위” (기간 리포트/배치성)

```sql
VAR d  DATE;
VAR c1 NUMBER;
VAR c2 NUMBER;
EXEC :d  := DATE '2025-10-15';
EXEC :c1 := 1000;
EXEC :c2 := 9000;

SELECT /* S2_BASE */
       COUNT(*)
FROM   ix_demo
WHERE  order_dt = :d
AND    cust_id BETWEEN :c1 AND :c2;
```

이 경우엔,

- 인덱스 `ix_dt_c (order_dt, cust_id, order_id)` 가 최적
- `ix_c_dt` 를 사용할 경우 선행 범위(`cust_id BETWEEN`) 때문에 스캔 폭이 넓다.

직접 인덱스를 만들어 비교해보자.

```sql
CREATE INDEX ix_dt_c2 ON ix_demo(order_dt, cust_id, order_id);

-- ix_dt_c2 사용 강제
SELECT /*+ INDEX(ix_demo ix_dt_c2) S2_DT_FIRST */
       COUNT(*)
FROM   ix_demo
WHERE  order_dt = :d
AND    cust_id BETWEEN :c1 AND :c2;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);
```

- `ix_dt_c2` 를 쓰면 `order_dt = :d` 로 선행 등치 구간을 잡고  
  그 안에서 `cust_id BETWEEN :c1 AND :c2` 를 적용 → 효율적.

만약 `(order_dt, cust_id)` 인덱스를 만들 수 없는 상황이라면,  
**임시로 Skip Scan** 을 고려해 볼 수 있다(그러나 전용 인덱스가 정석이다).

```sql
SELECT /*+ INDEX_SS(ix_demo ix_c_dt) S2_SS */
       COUNT(*)
FROM   ix_demo
WHERE  order_dt = :d
AND    cust_id BETWEEN :c1 AND :c2;
```

- 선행 값 종류(고객 수)가 많으므로 Skip Scan 효과는 제한적일 가능성이 크다.

---

### 6.3 시나리오 ③ — 상태(status)와 낮은 카디널리티

`status` 컬럼은 값 종류가 5개 (`NEW/PAID/SHIP/DONE/CANC`) 정도인 **저카디널리티** 컬럼이다.  

```sql
-- 상태로 필터 + 최근 30일
VAR s VARCHAR2(8); VAR d1 DATE; VAR d2 DATE;
EXEC :s  := 'PAID';
EXEC :d1 := SYSDATE - 30;
EXEC :d2 := SYSDATE;

SELECT /* S3_BASE */
       COUNT(*)
FROM   ix_demo
WHERE  status   = :s
AND    order_dt BETWEEN :d1 AND :d2;
```

인덱스는 `ix_status (status)` 가 있고, 날짜 인덱스는 `ix_dt_c` 등이 있을 수 있다.

옵티마이저는 선택도에 따라

- `ix_status` 를 타고 status='PAID' 인 Row 들을 전부 읽은 뒤  
  날짜 필터 적용 (status 값 분포가 아주 불균형하면 나쁘지 않을 수도 있다)
- `ix_dt_c` 를 타고 날짜 범위를 좁힌 뒤  
  status='PAID' 필터 적용

중 하나를 고른다.

**개선 방향**

1. 이 쿼리가 매우 중요하다면,  
   `(status, order_dt)` 또는 `(order_dt, status)` 의 결합 인덱스를 검토.
2. 분포/용도에 따라  
   - OLTP에선 `(status, order_dt)`  
   - 리포트에선 `(order_dt, status)`  
   등이 더 나을 수 있다.
3. `ix_status` 단독 인덱스는 상태값 필터 강도가 충분치 않다면  
   비용 대비 이득이 적을 수 있으므로,  
   **실측 통계 기반으로 유지/삭제를 결정**해야 한다.

---

## 7. 실무 팁: 선택도(Selectivity)와 비용 모델 감각

### 7.1 선택도와 비용의 관계

선택도(selectivity)는 간단히 말해

$$
\text{Selectivity}(C=v) \approx \frac{1}{\text{num\_distinct}(C)}
$$

정도로 생각할 수 있다 (히스토그램이 없고 균등 분포일 때).

- 선행 컬럼의 `=` 조건 선택도가 **낮을수록** (값이 잘 나뉠수록)  
  Range Scan 의 폭이 좁아진다.
- `BETWEEN a AND b` 의 선택도는  
  $[a,b]$ 범위에 데이터가 얼마나 분포해 있는지에 따라 달라진다.

### 7.2 통계 확인 스크립트

```sql
-- 컬럼 통계
SELECT column_name, num_distinct, density, num_nulls, histogram
FROM   user_tab_col_statistics
WHERE  table_name = 'IX_DEMO';

-- 인덱스 요약
SELECT index_name, blevel, leaf_blocks, distinct_keys, clustering_factor
FROM   user_indexes
WHERE  table_name = 'IX_DEMO';
```

- `num_distinct` ↑ → 해당 컬럼은 선행에 두면 Range Scan 폭이 줄어든다.
- `density` 는 선택도의 역수 느낌 (낮을수록 좋다).
- `clustering_factor` 는 **인덱스 순서와 테이블 물리순서 친화도**의 지표.

### 7.3 히스토그램과 바인드 피킹

값 분포가 크게 치우쳤다면(예: `status='PAID'` 가 80% 이상),  
평균적인 density 로는 선택도를 제대로 추정할 수 없다.

- 히스토그램을 사용하면  
  “특정 값”에 대한 선택도를 따로 추정할 수 있다.
- Adaptive Cursor Sharing(ACS)을 사용하면  
  **바인드 값별로 다른 실행계획**을 선택할 수 있다.

하지만 인덱스 설계 관점에서 중요한 것은,

> “핵심 컬럼의 분포/선택도를 통계로 파악하고,  
>  그에 맞는 선행 컬럼·범위 조건 형태를 잡는 것”

이다.

---

## 8. 인덱스 설계·쿼리 튜닝 체크리스트 (요약)

마지막으로, 지금까지의 내용을 **실무용 체크리스트**로 묶어보자.

### 8.1 인덱스 설계 관점

- [ ] 자주 쓰는 WHERE/JOIN 패턴을 모아서,  
      **선행 컬럼에 등치(=)** 가 오도록 했는가?
- [ ] 정렬/Top-N/페이징이 잦은 컬럼 조합에 대해  
      **정렬 방향(ASC/DESC)까지 맞춘 결합 인덱스**를 설계했는가?
- [ ] 저카디널리티 컬럼(예: status)에 대해서는  
      단독 인덱스가 아닌 **다른 컬럼과의 결합 인덱스**도 검토했는가?
- [ ] 군집성을 위해 데이터 로딩 시 적절한 정렬/CTAS/리빌드 등을 고려했는가?

### 8.2 쿼리 작성 관점

- [ ] 선행 컬럼에 `BETWEEN`, `>=`, `<=`, `IS NOT NULL` 등을 남발하지 않았는가?  
      가능한 `=` 패턴으로 고정할 수 있는가?
- [ ] `BETWEEN` 범위가 넓다면,  
      - 이산 값·작은 범위면 **IN 분해**  
      - 큰 범위면 **파티셔닝** 또는 다른 구조를 검토했는가?
- [ ] 날짜·코드 접두사 검색에서  
      `LIKE 'prefix%'`를 **BETWEEN lower~upper** 로 변환할 수 있는가?
- [ ] `%...` 패턴은 정말 필요한 곳에만 사용하고,  
      필요하다면 **역인덱스/함수기반 인덱스/전문 인덱스**를 설계했는가?
- [ ] `TRUNC(col)` 등 컬럼 함수 사용을 피하거나,  
      **가상 컬럼/함수기반 인덱스**로 SARGability를 확보했는가?

### 8.3 실행계획·통계 검증 관점

- [ ] `DBMS_XPLAN.DISPLAY_CURSOR(...,'ALLSTATS LAST +PREDICATE')` 로  
      **Access Pred / Filter Pred** 를 구분해서 보고 있는가?
- [ ] 인덱스를 타고 있음에도 Buffers/Reads 가 크면,  
      - 선행 컬럼이 범위인지  
      - 스캔 폭이 실제로 얼마나 되는지  
      를 확인했는가?
- [ ] Skip Scan/IN 분해/힌트 적용 전·후에  
      **숫자**가 실제로 좋아졌는지 확인했는가?

---

## 9. 결론

이 글의 핵심을 한 문장으로 요약하면:

> **“비교 연산자의 모양과 인덱스 컬럼 순서가  
>  B-tree 상에서 ‘어디서부터 어디까지’를 읽게 만드는지를 이해하고,  
>  그 범위를 최대한 좁혀라.”**

조금 더 풀어서 정리하면:

1. **비교 연산자**
   - `=` 와 짧은 `IN` 이 가장 강력한 “범위 축소 도구”
   - `BETWEEN` / `>=` / `<=` / `IS NOT NULL` 은 폭이 넓어질 위험이 크다.
   - `LIKE 'prefix%'` 는 사전순 범위를 만들 수 있지만,  
     `%prefix`/`%prefix%` 는 대부분 인덱스를 망친다.
2. **컬럼 순서**
   - 선행 컬럼에 **자주 쓰이는 등치 조건**이 오도록 설계하면  
     인덱스 레코드가 자연스럽게 군집화되고, 랜덤 I/O가 줄어든다.
   - 같은 WHERE 절이라도  
     `(cust_id, order_dt)` vs `(order_dt, cust_id)` 에 따라  
     효율이 크게 달라진다.
3. **군집성과 통계**
   - Clustering Factor, num\_distinct, density, 히스토그램 등  
     통계 값으로 “인덱스가 데이터를 얼마나 잘 붙잡고 있는지”를 파악해야 한다.
4. **보조 도구**
   - `BETWEEN → IN` 분해,  
     Skip Scan, 함수기반 인덱스, 파티셔닝, 정렬 일치 인덱스 + Stopkey 같은 기법으로  
     스캔 범위를 더 줄일 수 있다.
5. **검증**
   - 모든 튜닝의 가치는 **DBMS_XPLAN 의 숫자**로 증명된다.  
     Buffers/Reads, Rows, Access/Filter Predicate, Sort 유무를  
     항상 전·후 비교해야 한다.

이제 이 글에 나온 SQL들을 직접 실행해 보면서,

- **선행 등치 vs 선행 범위**,
- **`BETWEEN` vs `IN` 분해**,
- **Skip Scan 유무**,  
- **서로 다른 인덱스 순서**,

에 따라 실행계획과 Buffers/Reads가 어떻게 달라지는지 체험해 보면,  
실무에서 인덱스를 설계하고 쿼리를 튜닝할 때  
“어디를 어떻게 손대야 하는지”에 대한 감각이 훨씬 단단해질 것이다.