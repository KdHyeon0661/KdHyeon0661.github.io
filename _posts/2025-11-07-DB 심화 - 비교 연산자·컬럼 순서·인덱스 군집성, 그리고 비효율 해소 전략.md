---
layout: post
title: DB 심화 - 비교 연산자·컬럼 순서·인덱스 군집성, 그리고 비효율 해소 전략
date: 2025-11-07 21:25:23 +0900
category: DB 심화
---
# 비교 연산자·컬럼 순서·인덱스 군집성, 그리고 비효율 해소 전략

## 실습 스키마 & 데이터 생성

> 예제는 **주문 테이블**을 사용합니다. 인덱스 컬럼 순서에 따라 **레코드 군집성**과 **스캔 효율**이 어떻게 달라지는지 관찰합니다.

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL; -- ALLSTATS LAST

DROP TABLE ix_demo PURGE;

CREATE TABLE ix_demo (
  cust_id    NUMBER        NOT NULL,
  order_dt   DATE          NOT NULL,
  order_id   NUMBER        NOT NULL,
  status     VARCHAR2(8)   NOT NULL,
  amount     NUMBER(12,2)  NOT NULL,
  note       VARCHAR2(100),
  CONSTRAINT pk_ix_demo PRIMARY KEY (order_id)  -- Surrogate PK
);

BEGIN
  -- 데이터: 고객 10만명, 각 15~40건, 2년 치 날짜 분포
  FOR c IN 1..100000 LOOP
    FOR k IN 1..TRUNC(DBMS_RANDOM.VALUE(15, 40)) LOOP
      INSERT INTO ix_demo
      VALUES (
        c,
        DATE '2024-01-01' + TRUNC(DBMS_RANDOM.VALUE(0, 730)),  -- 2년
        c*1000 + k,
        CASE MOD(c+k,5) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID'
                        WHEN 2 THEN 'SHIP' WHEN 3 THEN 'DONE' ELSE 'CANC' END,
        ROUND(DBMS_RANDOM.VALUE(10, 200000), 2),
        CASE WHEN MOD(c+k,97)=0 THEN 'gift' END
      );
    END LOOP;
  END LOOP;
  COMMIT;
END;
/

-- 서로 다른 컬럼 순서를 가진 인덱스 2개
CREATE INDEX ix_c_dt ON ix_demo(cust_id, order_dt, order_id);      -- 고객→날짜 (고객 기준 군집)
CREATE INDEX ix_dt_c ON ix_demo(order_dt, cust_id, order_id);      -- 날짜→고객 (날짜 기준 군집)
CREATE INDEX ix_status ON ix_demo(status);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'IX_DEMO', cascade => TRUE,
    method_opt => 'for all columns size skewonly');
END;
/
```

---

# 비교 연산자 & 컬럼 순서가 만드는 **인덱스 레코드의 군집성**

## 군집성(Clustering) 직관

- **인덱스 키 순서**와 **테이블(또는 IOT) 물리 순서**가 **가깝게 맞물릴수록**
  한 번 읽어 들인 블록에서 **많은 행**을 해결할 가능성이 커집니다.
- **선행 컬럼**이 **카디널리티 낮음(= 반복값)** + **쿼리가 등치(=)**를 쓸 때,
  **해당 값 범위**가 인덱스 Leaf에서 **연속 구간**으로 뭉쳐 **군집성이 좋아집니다.**

> 감각 공식
> $$ \text{Random I/O} \propto \frac{\text{스캔 중 방문 블록 수}}{\text{블록당 유효 행 수}} $$
> **연속 구간**(군집성↑)이면 같은 블록에서 더 많은 행을 처리 → Random I/O↓.

## **연산자별** 스캔 폭 (대략적 경향)

- `=` (등치): **가장 좁음**. 선행컬럼이 `=`이면 **연속 구간**을 짧게 잡을 수 있음.
- `IN (v1, v2, ...)`: 값별로 여러 개의 **짧은 등치 범위**. 값이 적고 잘 뭉치면 효율적.
- `BETWEEN a AND b`, `>=`, `<=`: **연속 범위**(폭은 조건에 따라). 넓어지면 랜덤 I/O↑.
- `LIKE 'abc%'`: **접두사 범위** → 인덱스 사용 가능(함수/가공 없을 때). 범위폭은 패턴 길이에 좌우.
- `>`/`<`(한쪽 오픈): 대상 값 분포에 따라 **아주 넓어질 수 있음**.
- `IS NULL/IS NOT NULL`: 인덱스 사용 가능하나(값 분포 중요), `IS NOT NULL`은 범위가 넓어 비효율 위험.
- **함수/가공/암시적 형변환**: **SARGability**를 깨면 인덱스 군집성 이전에 **인덱스 미사용/Full Scan**으로 튀어버림.

## **컬럼 순서**가 결과를 바꾼다

- 인덱스 `(cust_id, order_dt, order_id)` vs `(order_dt, cust_id, order_id)`
  동일한 WHERE 절이라도 **선행 컬럼이 무엇인지**에 따라
  **스캔 시작 위치**와 **연속 구간**이 달라져 **블록 재사용률**이 크게 바뀝니다.

### 예제 A: 고객=등치 + 날짜 범위

```sql
-- 고객 12345의 최근 30일 주문
SELECT order_id, order_dt, amount, status
FROM   ix_demo
WHERE  cust_id = 12345
AND    order_dt BETWEEN SYSDATE-30 AND SYSDATE
ORDER  BY order_dt, order_id;
```
- `(cust_id, order_dt, ...)` 인덱스는 선행 `cust_id =`로 **짧은 Leaf 구간**부터 시작 → **군집성↑**.
- 반면 `(order_dt, cust_id, ...)`는 날짜 구간부터 넓게 훑고 그 안에서 cust를 골라내야 → **군집성↓**.

### 예제 B: 날짜=등치 + 고객 범위

```sql
-- 특정 날짜(2025-10-15)에 특정 고객 구간
SELECT order_id, order_dt, cust_id
FROM   ix_demo
WHERE  order_dt = DATE '2025-10-15'
AND    cust_id BETWEEN 100 AND 1000
ORDER  BY cust_id, order_id;
```
- `(order_dt, cust_id, ...)`에서 선행 `order_dt =`가 **짧은 범위**를 보장 → **군집성↑**.
- `(cust_id, order_dt, ...)`는 선행이 범위(`cust_id BETWEEN`)여서 **스캔 폭이 넓어짐**.

**요약**
- **자주 쓰는 조건/정렬**이 **선행 컬럼**에 **등치(=)**로 걸리도록 인덱스 순서를 설계하면
  인덱스 레코드가 **연속 구간으로 모여** 랜덤 I/O가 줄어듭니다.

---

# **선행 컬럼이 등치가 아닐 때** 발생하는 비효율

## 문제의 본질

- B-tree 인덱스는 **선행 컬럼을 먼저 정렬**합니다.
- 선행 컬럼에 `BETWEEN`, `>`, `<`, `LIKE '%'`(접두사 미비), `IS NOT NULL`과 같이 **넓은 범위**가 걸리면
  **후행 컬럼 조건**이 좋아도 **이미 넓은 영역을 스캔**해야 합니다.

```sql
-- 선행이 범위, 후행이 등치 → 선행 범위를 다 훑어야 후행 필터가 적용됨
-- (cust_id BETWEEN) + (order_dt = 특정일) : 인덱스 (cust_id, order_dt)
SELECT /* Bad for (cust_id, order_dt) */
       order_id
FROM   ix_demo
WHERE  cust_id BETWEEN :c1 AND :c2
AND    order_dt = :d;
```

- 반대로 **선행=등치**, 후행=범위면 **선행값 구간** 내에서만 **짧게 범위 탐색** → 효율적.

## 관찰: 실행계획/통계

```sql
-- 실제 수행 통계 관찰
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS'));
```
- `Starts/Rows/Buffers/Reads`를 비교하면 **선행 비등치**에서 **스캔량 붐**이 드러납니다.

## 해법 개요

1) **인덱스 컬럼 순서 변경**: 선행에 `=`가 오게.
2) **필요 시 두 개의 인덱스** 제공(핫 경로별 설계).
3) **BETWEEN→IN 분해**, **SKIP SCAN**, **함수기반 인덱스** 등으로 **유효 범위를 축소**.

---

# `BETWEEN`을 **`IN` 리스트로 분해**했을 때의 효율

> 핵심: `BETWEEN`은 **연속 구간**을 훑습니다.
> 만약 **'날짜 단위' 등 이산 값**일 때, `BETWEEN a AND b`를 **`IN (a, a+1, …, b)`**로 바꾸면
> 옵티마이저가 **여러 개의 “짧은 등치 범위”**로 처리할 기회를 얻습니다.

## 예제: 날짜가 **일 단위**로만 저장될 때

```sql
-- 전제: order_dt가 시분초 없이 DATE 'YYYY-MM-DD'만 사용 (또는 trunc(order_dt))
-- (1) BETWEEN
SELECT /* Baseline */
       COUNT(*)
FROM   ix_demo
WHERE  cust_id = :cid
AND    order_dt BETWEEN DATE '2025-10-01' AND DATE '2025-10-31';

-- (2) IN 리스트 분해
SELECT /* Decompose to IN */
       COUNT(*)
FROM   ix_demo
WHERE  cust_id = :cid
AND    order_dt IN (
  DATE '2025-10-01', DATE '2025-10-02', ..., DATE '2025-10-31'
);
```

### 기대 효과

- 인덱스 `(cust_id, order_dt, order_id)`에서 `cust_id =`로 **짧은 구간 시작** +
  `order_dt IN (...)`가 **여러 개의 등치 소구간**으로 바뀌어 **각각 빠르게** 스캔.
- 옵티마이저는 내부적으로 **“OR-Expansion(UNION ALL)”** 혹은 **Multi-Range Read** 비슷한 전략을 취할 수 있음.

> 주의:
> - **리터럴이 너무 많으면** 파싱 비용/커서 공유 저하.
> - **바인딩**을 유지하면서 `IN` 리스트를 **적절 크기**로 제한하거나,
>   **임시 테이블/컬렉션**을 사용해 **조인**으로 바꾸는 방법도 있음.

## 변형: `BETWEEN` + 정렬 요구

```sql
-- 최신 7일(일 단위) Top-N
SELECT order_id, order_dt, amount
FROM   ix_demo
WHERE  cust_id = :cid
AND    order_dt IN (SYSDATE-6, SYSDATE-5, ..., TRUNC(SYSDATE))
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;
```
- `DESC` 인덱스가 있다면 정렬 제거 + **앞 블록 몇 개만** 읽고 종료(Stopkey) → **IO 최소화**.

---

# **INDEX SKIP SCAN**으로 선행 비등치/누락 문제 보완

> **Skip Scan**: 선행 컬럼에 조건이 없거나 비등치여서 원래는 **인덱스 사용이 약한 상황**에서,
> **인덱스 내부의 선행 컬럼 “가능 값들”을 가정**하여 **후행 컬럼으로** 여러 차례 **짧게 스캔**하는 기법.
> - 전제: **선행 컬럼의 유니크 값 개수**가 **그리 크지 않을수록** 유리.
> - 장점: **인덱스 추가 없이** 후행 컬럼 조건만으로도 인덱스를 활용.
> - 단점: 선행 값별로 **여러 번 스캔**하므로, 값 종류가 많다면 비싸짐.

## 예제: 인덱스 `(cust_id, order_dt)`만 있을 때, `cust_id` 조건이 없음

```sql
-- 고객 조건 없이 특정 날짜만 찾기 (본래는 (order_dt, cust_id) 인덱스가 유리)
-- 그러나 없는 상황에서 Skip Scan으로 후행 order_dt만으로 스캔 유도
SELECT /*+ INDEX_SS(ix_demo ix_c_dt) */ COUNT(*)
FROM   ix_demo
WHERE  order_dt = DATE '2025-10-15';
```
- 힌트 `INDEX_SS(table_alias index_name)`로 Skip Scan 시도.
- 옵티마이저는 **cust_id의 가능한 값들을 가정**하고 `(cust_id=?, order_dt=...)` 형태로 **여러 짧은 탐색**을 수행.
- **cust_id distinct 값 수가 매우 크면** 비효율 가능 → 원래 의도에 맞는 `(order_dt, cust_id)` 인덱스가 최선.

## 예제: 선행 비등치 + 후행 등치

```sql
-- (cust_id BETWEEN) + (order_dt = 특정일) in (cust_id, order_dt)
-- Skip Scan으로 후행 등치를 활용해 (cust,dt) 조합의 "짧은 검색" 반복을 노림
SELECT /*+ INDEX_SS(ix_demo ix_c_dt) */
       order_id
FROM   ix_demo
WHERE  cust_id BETWEEN :s AND :e
AND    order_dt = :d;
```

**적용 판단 기준**
- 선행 컬럼의 **선택도가 낮아** 값 종류가 **작고**,
- 후행 컬럼에 **강한 등치/좁은 범위**가 붙으면 Skip Scan이 이득일 수 있음.
- 그 외 상황에서는 **전용 인덱스 생성**(정답) 또는 **BETWEEN→IN 분해** 등의 다른 수단 고려.

---

# **범위검색 조건을 남용**할 때의 비효율

## 공통 증상

- WHERE 절이 습관적으로 `>=`, `<=`, `BETWEEN`, `LIKE '%'`를 남발 →
  실제로는 **해당 컬럼의 대부분**을 훑게 되어 **선행 등치의 이점 상실**.
- 실행계획상 인덱스 스캔이 잡혀도, `ALLSTATS LAST`에서 **Buffers/Reads 폭증**.

## 악화 요인

- **선행 컬럼이 범위**, 후행 컬럼 등치/좁은 범위라도 **이미 늦음**(§2).
- **데이터 분포 편중**: 특정 구간이 **매우 넓은 범위**와 겹치면 **랜덤 I/O 폭탄**.
- **ORDER BY**까지 별도 → Sort 비용 가중.

## 개선 전략

1) **선행에 등치**를 오도록 **인덱스 컬럼 순서 재설계**.
2) **BETWEEN→IN** 분해(값이 이산·개수 적당할 때).
3) **파티셔닝 + Pruning**으로 대상 파티션만 접근.
4) **함수 기반 인덱스**로 실제 사용 패턴에 맞게 SARGable 확보(`TRUNC(order_dt)` 등).
5) **정렬 일치 인덱스**(ASC/DESC) + **Stopkey**로 앞부분만 읽고 종료.
6) **SKIP SCAN**은 **보조 수단**(선행 값 종류가 적을 때).
7) **통계/바인드 피킹** 주의(선택도 왜곡 시 계획 불안정).

---

# 케이스 스터디 — 조건·인덱스마다 스캔 효율 비교

## 시나리오 ①: “고객=등치 + 기간 범위” (일반적인 OLTP 조회)

```sql
-- Baseline (cust, dt) 인덱스 사용
SELECT /*A*/ order_id, order_dt, amount
FROM   ix_demo
WHERE  cust_id = :cid
AND    order_dt BETWEEN :d1 AND :d2
ORDER  BY order_dt, order_id;

-- 관찰: ix_c_dt가 유리. ix_dt_c는 날짜 범위부터 넓게 → 비효율.
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

### 개선 1: **BETWEEN→IN 분해(일 단위)**

- `:d1`~`:d2`가 **일 단위**일 때만 고려.
```sql
-- IN 분해 (유효하면 Buffers/Reads 추가 감소)
SELECT /*A1*/ order_id, order_dt, amount
FROM   ix_demo
WHERE  cust_id = :cid
AND    order_dt IN (:d1, :d1+1, :d1+2, ...)  -- 적당 개수
ORDER  BY order_dt, order_id;
```

### 개선 2: **DESC 인덱스 + Stopkey** (최신 N건)

```sql
CREATE INDEX ix_c_dt_desc ON ix_demo(cust_id, order_dt DESC, order_id DESC);

SELECT /*A2*/ order_id, order_dt, amount
FROM   ix_demo
WHERE  cust_id = :cid
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;  -- 앞 블록 몇 개만 읽고 종료
```

## 시나리오 ②: “기간=등치/좁은 범위 + 고객 범위”

```sql
-- 날짜가 등치/좁은 범위, 고객은 넓은 범위
SELECT /*B*/ COUNT(*)
FROM   ix_demo
WHERE  order_dt = :d
AND    cust_id BETWEEN :c1 AND :c2;

-- (order_dt, cust_id) 인덱스가 매우 유리.
-- (cust_id, order_dt)는 선행이 BETWEEN이라 넓게 훑음 → 비효율.
```

### 임시 해법: **Skip Scan** (전용 인덱스 없을 때)

```sql
SELECT /*+ INDEX_SS(ix_demo ix_c_dt) */ COUNT(*)
FROM   ix_demo
WHERE  order_dt = :d
AND    cust_id BETWEEN :c1 AND :c2;
```
- 선행 값 종류가 적당히 작을 때만 유효. 궁극적으론 `(order_dt, cust_id)` 제공이 바람직.

## 시나리오 ③: “LIKE 'ABC%'" vs “LIKE '%ABC'”

```sql
-- 접두사 조건(LIKE 'ABC%')은 인덱스 (col)에서 사전순 범위를 잡을 수 있음.
SELECT /*C1*/ COUNT(*)
FROM   some_table
WHERE  prod_code LIKE 'ABC%';

-- 접미사/중간 일치(LIKE '%ABC' or '%ABC%')는 앞이 불명 → 범위를 못 잡음 → 인덱스 비활성화/FullScan 경향.
SELECT /*C2*/ COUNT(*)
FROM   some_table
WHERE  prod_code LIKE '%ABC';
```
- 해결: **역인덱스/함수기반 인덱스**(예: REVERSE, SUBSTR 고정 위치, 표준화된 키) 등으로 SARGable화.

---

# 실무 팁: SELECTIVITY & 비용 모델 감각

- **선행 = 등치**일 때의 **카디널리티(선택도)**가 인덱스 효율의 **절대적 결정자**.
- `BETWEEN`은 데이터 분포에 따라 **선택도가 급변**. 통계/히스토그램 필요.
- `IN`은 원소 수가 커질수록 파싱/플랜 캐시 문제 가능 → **바인드 + 임시테이블**로 전환 검토.
- `SKIP SCAN`은 **임시 봉합**. 장기적으로 **전용 인덱스/컬럼 순서 재설계**가 해법.
- **정렬 요구**가 잦으면 **정렬 일치 인덱스(ASC/DESC)** + **Stopkey**.
- **함수/형변환**으로 SARGability를 깨지 말 것(필요 시 **함수기반 인덱스**).

---

# 점검 체크리스트

- [ ] 자주 쓰는 WHERE가 **선행 컬럼에 등치(=)**로 걸리게 인덱스 순서를 설계했는가?
- [ ] `BETWEEN` 범위가 **너무 넓지** 않은가? → **IN 분해**/파티셔닝/Pruning/통계 개선 검토.
- [ ] 정렬이 잦다면 **정렬 일치 인덱스**(DESC 포함) + **Stopkey** 적용했는가?
- [ ] 선행 비등치로 인해 스캔 폭이 커진다면 **전용 인덱스** 또는 **Skip Scan**(단기) 고려했는가?
- [ ] `LIKE '%…'`, 함수/형변환 등으로 **인덱스 무력화**가 일어나지 않는가? (함수기반 인덱스)
- [ ] `ALLSTATS LAST`의 `Buffers/Reads`가 개선되었는지 **숫자**로 검증했는가?

---

# 종합 요약

- **비교 연산자**는 스캔 폭을 결정합니다. **등치(=)**가 가장 좁고, **범위(BETWEEN/>,<)**는 넓습니다.
- **인덱스 컬럼 순서**는 군집성을 좌우합니다. **선행 = 등치** 구간으로 시작하면 **연속 구간**을 짧게 잡아 **랜덤 I/O**가 줄어듭니다.
- 선행이 **비등치/불명**이면 후행 조건이 좋아도 **이미 넓은 영역**을 스캔합니다.
- `BETWEEN`을 **`IN`으로 분해**(이산·소량일 때)하면 **여러 짧은 등치 구간**이 되어 **효율↑**.
- **INDEX SKIP SCAN**은 전용 인덱스 없이 **후행 컬럼만으로도** 인덱스 스캔을 유도하는 **보조 수단**입니다(선행 값 종류가 작을수록 유효).
- **범위검색 남용**은 **Buffers/Reads 폭증**으로 직결됩니다. 정렬 일치 인덱스/Stopkey/파티셔닝/함수기반 인덱스/통계로 **정밀 제어**하세요.

> 마지막으로, 언제나 **DBMS_XPLAN의 ALLSTATS LAST**로 **전/후 수치 비교**를 하세요.
> 체감이 아닌 **숫자**가 개선을 증명합니다.
