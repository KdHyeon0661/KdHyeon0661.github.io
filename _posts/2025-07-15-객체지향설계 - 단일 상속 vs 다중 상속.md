---
layout: post
title: 객체지향설계 - 단일 상속 vs 다중 상속
date: 2025-07-15 17:20:23 +0900
category: 객체지향설계
---
# 단일 상속 vs 다중 상속

## 개요 — 왜 이 주제가 중요할까

- **단일 상속**은 단순하고 안전하다. 하지만 수평적 기능 조합이 어렵다.
- **다중 상속**은 강력하다. 하지만 **충돌/모호성/레이아웃** 문제가 따라온다.
- 현대 실무는 대체로 **단일 상속 + 인터페이스/트레이트 + 합성(Composition)**을 기본 전략으로 삼는다.

---

## 단일 상속 (Single Inheritance)

하위 클래스가 **하나의 부모**만 상속한다. (Java/C#/Kotlin 등)

```java
class Animal {
    void eat() { System.out.println("먹습니다."); }
}
class Dog extends Animal {
    void bark() { System.out.println("멍멍!"); }
}
```

### 장점

- **모델이 단순**: 계층 및 메서드 탐색 규칙이 직관적
- **충돌 없음**: 동일 시그니처 충돌이 설계상 거의 발생하지 않음
- **생태계 표준**: 대부분의 산출물/프레임워크가 단일 상속 전제

### 단점

- **수평 기능 조합**의 비용: 공통 기능이 여러 계층에 중복될 위험
- **백본 클래스 비대화**: 공통을 상위로 올리다 보면 “신” 상위 클래스가 커짐

---

## 다중 상속 (Multiple Inheritance)

하위 클래스가 **둘 이상의 부모**를 상속한다. (C++/Python 등)

```cpp
#include <iostream>

struct Flyer { void fly()  { std::cout << "날다\n"; } };
struct Swimmer { void swim(){ std::cout << "헤엄치다\n"; } };
struct Duck : Flyer, Swimmer {};
int main(){ Duck d; d.fly(); d.swim(); }
```

### 장점

- **기능 조합**이 직접적(믹스인 스타일)
- “역할 + 역할 + …”을 **한 타입**으로 봉합 가능

### 단점

- **다이아몬드 문제**/이름 충돌/서브오브젝트 중복
- 메모리 레이아웃/가상 상속의 **복잡도**와 성능 트레이드오프
- 유지보수 난이도 증가

---

## 다이아몬드 문제(Diamond Problem)와 해결

```cpp
struct Animal { void eat(){ std::cout << "먹는다\n"; } };
struct Mammal : /* non-virtual */ Animal {};
struct Bird   : /* non-virtual */ Animal {};
struct Bat    : Mammal, Bird {}; // Animal 서브오브젝트가 두 개!

// Bat b; b.eat(); // 모호성 오류
```

**C++ 해결: 가상 상속(virtual inheritance)**

```cpp
struct Animal { void eat(){ std::cout << "먹는다\n"; } };
struct Mammal : virtual Animal {};
struct Bird   : virtual Animal {};
struct Bat    : Mammal, Bird {}; // Animal 하나만 공유
int main(){ Bat b; b.eat(); }     // OK
```

- 가상 상속은 **하나의 공유 베이스 서브오브젝트**를 형성한다.
- 대가: 컴파일러가 **포인터 보정**/추가 간접 참조를 수행(약간의 오버헤드, 구현체에 따라 다름).

**Python 해결: MRO(Method Resolution Order)**

```python
class A:  def f(self): print("A")
class B(A): pass
class C(A): def f(self): print("C")
class D(B, C): pass

d = D(); d.f()  # "C" — C3 MRO에 따라 순서 결정
print(D.mro())  # [D, B, C, A, object]
```

- Python의 **C3 선형화**는 다중 상속 시 메서드 탐색 순서를 **결정적**으로 만든다.
- `super()`는 MRO 기반으로 **다음 후보**를 호출한다.

---

## 언어별 지원·대응 전략

| 언어 | 클래스 다중 상속 | 인터페이스/트레이트 | 충돌/다이아몬드 대응 |
|---|---|---|---|
| **C++** | ✅ | (순수 가상 인터페이스 관용) | **가상 상속**, `using`/명시적 한정, 가상 소멸자 |
| **Python** | ✅ | (추상 베이스 클래스/믹스인 관용) | **C3 MRO**, `super()` |
| **Java** | ❌ | ✅ 인터페이스 + **default 메서드** | default 충돌 시 구현 클래스에서 **명시 해결** |
| **C#** | ❌ | ✅ 인터페이스 + **명시적 인터페이스 구현** | 모호성은 **명시적 구현**으로 해소 |
| **Kotlin** | ❌ | ✅ 인터페이스 + default 구현 | 다중 default 충돌 시 `super<IFace>.m()` 지정 |
| **Scala** | (클래스 단일) | ✅ **trait** 다중 믹스인 | 선형화 규칙 + `super[Trait]` |
| **Swift** | (클래스 단일) | ✅ protocol(+ default) | 충돌 시 구현에서 명시 |
| **Go** | (없음) | 임베딩/인터페이스 | 임베딩으로 위임(합성) |
| **Rust** | (없음) | trait(+ default) 다중 구현 | 충돌 시 fully-qualified syntax |

---

## 인터페이스 기반 다중 상속 대체

### Java: 인터페이스 + default 메서드

```java
interface Flyer { default void move(){ System.out.println("날다"); } }
interface Swimmer { default void move(){ System.out.println("헤엄치다"); } }
class Duck implements Flyer, Swimmer {
    @Override public void move(){
        Flyer.super.move(); // 혹은 Swimmer.super.move(); 선택 or 병합 로직
    }
}
```

### C#: 명시적 인터페이스 구현으로 충돌 해소

```csharp
interface IFlyer { void Move(); }
interface ISwimmer { void Move(); }

class Duck : IFlyer, ISwimmer {
    void IFlyer.Move()  => Console.WriteLine("날다");
    void ISwimmer.Move()=> Console.WriteLine("헤엄치다");

    public void Move()  => Console.WriteLine("걷다"); // 공용 엔트리
}
```

- 호출 측이 인터페이스로 바라볼 때 **각기 다른 구현**이 바인딩된다.

### Kotlin: 다중 default 해결

```kotlin
interface Flyer { fun move() { println("날다") } }
interface Swimmer { fun move() { println("헤엄치다") } }

class Duck : Flyer, Swimmer {
    override fun move() {
        super<Flyer>.move()
        super<Swimmer>.move()
        println("오리 모션")
    }
}
```

---

## 상속 대신 합성(Composition)으로 기능 조합

### 전략(Strategy)로 “역할”을 합성

```java
interface Fly { void fly(); }
interface Swim{ void swim(); }

final class WingFly implements Fly { public void fly(){ System.out.println("날개 비행"); } }
final class PaddleSwim implements Swim{ public void swim(){ System.out.println("오리발 수영"); } }

final class Duck {
    private Fly f; private Swim s;
    Duck(Fly f, Swim s){ this.f=f; this.s=s; }
    void fly(){ f.fly(); }
    void swim(){ s.swim(); }
    void molt(){ this.f = new WingFly(); /* 런타임 교체 등 */ }
}
```

**장점**
- **느슨한 결합**, 런타임 교체, 단위 테스트 용이
- 다중 상속의 충돌/레이아웃 문제 회피

**브리지/데코레이터**로도 동일 철학 구현 가능:
- 브리지: **추상(Abstraction)** 과 **구현(Implementor)** 을 분리
- 데코레이터: 실행 시 **책임을 누적**하여 조합

---

## C++에서의 다중 상속 실전 팁

1) **인터페이스(순수 가상)** 다중 상속 + **구체 구현은 합성**으로 분리
2) 공유 베이스는 **가상 상속**(필요 시)으로 하나만 유지
3) **가상 소멸자**를 꼭 두기
4) 충돌 시 **명시적 한정**으로 해소

```cpp
struct Base1 { virtual void f() = 0; virtual ~Base1() = default; };
struct Base2 { virtual void f() = 0; virtual ~Base2() = default; };

struct Impl : Base1, Base2 {
    void f() override { /* 하나의 구현 */ }
};
```

이름 충돌 해소:

```cpp
struct A { void m(); };
struct B { void m(); };
struct C : A, B {
    void test(){
        A::m(); // 명시 선택
        B::m();
    }
};
```

---

## Python 믹스인(Mixin) 패턴과 MRO

- **규약**: 믹스인은 **상태를 최소화**하고, **협력하는 메서드 이름/계약**만 제공
- 중복 책임은 `super()` 체인을 통해 **합성적**으로 동작

```python
class LogMixin:
    def save(self):
        print("log before save")
        super().save()

class Model:
    def save(self):
        print("save to DB")

class User(LogMixin, Model):
    pass

u = User(); u.save()
# MRO: User -> LogMixin -> Model -> object

```

---

## Rust/Go/Swift의 대안

- **Rust**: 다중 상속 없음. **trait** 다중 구현으로 행위 조합

```rust
trait Fly { fn fly(&self); }
trait Swim{ fn swim(&self); }

struct Duck;
impl Fly for Duck  { fn fly(&self){ println!("fly"); } }
impl Swim for Duck { fn swim(&self){ println!("swim"); } }
```

- **Go**: 임베딩 + 인터페이스로 위임(합성)
```go
type Flyer interface { Fly() }
type Swimmer interface { Swim() }

type Duck struct {
    Flyer
    Swimmer
}
```

- **Swift**: **protocol** 다중 채택 + default 구현으로 믹스인 유사 효과

---

## 메모리·성능 모델(간단 직관)

- **단일 상속**: 일반적으로 객체에 **vptr 1개**(언어/최적화에 따라 상이)
- **다중 상속**: 베이스별 vptr/오프셋 조정이 필요할 수 있음
- **가상 상속(C++)**: 공유 베이스 위치 탐색을 위한 **간접 참조/오프셋**이 추가

성능 직관 모델(개념적):

$$
\text{CallCost} \approx \text{BaseCost} + \alpha \cdot \text{VTableHops} + \beta \cdot \text{PointerAdjust}
$$

- JIT/JVM/CLR는 **디가상화/인라이닝**으로 오버헤드를 줄일 수 있다.
- C++은 핫패스에서 **정적 다형성(CRTP/템플릿)** 으로 비용 제거 가능.

---

## 설계 선택 체크리스트

- [ ] **is-a** 관계가 **자연어**/도메인 규칙에 부합하는가?
- [ ] **LSP**(리스코프 치환)가 깨지지 않는가(전제 강화 금지/사후 약화 금지)?
- [ ] 수평 기능 조합이라면 **합성/전략/데코레이터**가 더 적합하지 않은가?
- [ ] 다중 상속을 써야 한다면, **인터페이스/트레이트 위주**, 상태는 얕게?
- [ ] C++라면 **가상 상속 필요성**과 오버헤드를 검토했는가?
- [ ] Python이라면 **MRO/super 체인**이 의도대로 선형화되는가?
- [ ] Java/C#이라면 **디폴트 메서드/명시적 인터페이스 구현**으로 충돌을 관리했는가?
- [ ] 테스트로 **계약/호환성**(상위 계약 테스트 공유)을 보장하는가?

---

## 리팩토링 레시피

1) **다중 상속 → 합성**
```diff
- class Duck : Flyer, Swimmer { /*...*/ }
+ class Duck {
+   private final Fly fly;
+   private final Swim swim;
+   Duck(Fly f, Swim s){ this.fly=f; this.swim=s; }
+ }
```

2) **공통 로직을 인터페이스 default/트레이트로 승격**
```java
interface Measurable {
    default boolean isPositive(double x){ return x > 0; }
}
```

3) **C++ 공유 베이스 → 가상 상속**(정말 필요할 때만)
4) **Python 믹스인**: `super()` 협력 규약을 문서화(필수)
5) **Java/C# 충돌**: 구현 클래스에서 **명시 해결** + 규약 주석

---

## 테스트: 계약/치환 가능성 검증

상위 계약을 **공유 테스트**로 캡쳐하여 하위/구현이 교체 가능함을 보장한다.

```java
interface Payment { void pay(int amount); }

abstract class PaymentContract {
    protected abstract Payment sut();
    @org.junit.jupiter.api.Test
    void payPositive(){ sut().pay(1000); } // 전제: amount>0 이어야 함
}

final class CardPaymentTest extends PaymentContract {
    protected Payment sut(){ return a -> {/*...*/}; }
}
final class KakaoPaymentTest extends PaymentContract {
    protected Payment sut(){ return a -> {/*...*/}; }
}
```

---

## 예제 모음

### 인터페이스 다중 상속(역할 조합: Java)

```java
interface Auditable { default void audit(){ System.out.println("audit"); } }
interface Versioned { default String version(){ return "v1"; } }
class Document implements Auditable, Versioned {}
```

### C++ 다중 상속 + 충돌 해소

```cpp
struct A { virtual void m(){ std::cout << "A\n"; } virtual ~A()=default; };
struct B { virtual void m(){ std::cout << "B\n"; } virtual ~B()=default; };
struct C : A, B {
    void m() override { A::m(); B::m(); std::cout << "C\n"; }
};
```

### Python 믹스인: 로깅 + 검증

```python
class LogMixin:
    def save(self):
        print("log"); return super().save()
class ValidateMixin:
    def save(self):
        self.validate(); return super().save()
class Model:
    def save(self): print("save")
class User(LogMixin, ValidateMixin, Model):
    def validate(self): pass

User().save()
# MRO: User -> LogMixin -> ValidateMixin -> Model -> object

```

---

## 요약 표

| 항목 | 단일 상속 | 다중 상속 |
|---|---|---|
| 구조 | 단순/명확 | 유연/복잡 |
| 재사용 | 제한적(수직) | 광범위(수평 조합) |
| 충돌/모호성 | 사실상 없음 | 있음(다이아몬드/이름 충돌) |
| 주 사용 언어 | Java/C#/Kotlin/Swift | C++/Python(믹스인 중심) |
| 대안 | 인터페이스/합성/전략/데코레이터 | 가상 상속, MRO, 트레이트 규칙 |
| 실무 권장 | **단일 상속 + 인터페이스 + 합성** | 특수 상황/로우레벨에서만 신중 사용 |

---

## 결론

- **기본 전략**: **단일 상속**으로 수직 개념을 잡고, 수평 기능은 **인터페이스/트레이트 + 합성(전략/데코레이터/브리지)** 로 조합하라.
- **다중 상속**은 **정교한 제어**가 필요할 때(특히 C++ 로우레벨, Python 믹스인)만 신중히 사용하라.
- 어떤 선택이든 **계약(LSP)** 을 테스트로 고정하고, 충돌 규칙(MRO/virtual inheritance/default resolution)을 정확히 이해한 뒤 적용하라.

---

## 부록 A) UML 스케치

```text
        Vehicle
          ▲
   ┌──────┴──────┐
   │             │
  Car          Bike
   ▲             ▲
   │             │
SportsCar    ElectricBike
```

---

## 부록 B) 빠른 결정 트리

1) “X는 Y **이다**(is-a)”가 자연스러운가? → **단일 상속**
2) 수평 책임(로그/검증/알림)을 얹고 싶은가? → **인터페이스 + 합성/믹스인**
3) C++에서 공유 베이스가 중복되는가? → **가상 상속** 고려
4) 충돌을 어떻게 풀 것인가? → Java(default 선택), C#(**명시적 구현**), Python(**MRO/super**), C++(**명시 한정/가상 상속**)

---

## 부록 C) 작은 수식 메모 — 변경 파급 위험

계층 깊이 \(d\), 하위 타입 수 \(n\), 결합 계수 \(c\), 다중 상속 폭 \(w\)라 하면:

$$
\text{ChangeImpact} \approx p \cdot n \cdot c^{\,d} \cdot (1+\gamma w)
$$

- 깊이/결합/폭이 클수록 파급 위험이 증가한다 → **얕고 느슨하게**.
