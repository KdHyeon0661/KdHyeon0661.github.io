---
layout: post
title: 객체지향설계 - 단일 상속 vs 다중 상속
date: 2025-07-15 17:20:23 +0900
category: 객체지향설계
---
# 단일 상속 vs 다중 상속

객체지향 언어는 클래스 간의 관계를 표현하기 위해 상속 기능을 제공합니다. 상속의 형태는 크게 **단일 상속(Single Inheritance)**과 **다중 상속(Multiple Inheritance)**으로 나뉘며, 언어 설계 및 실무 적용 방식에 따라 장단점이 존재합니다.

---

## 1. 단일 상속 (Single Inheritance)

하위 클래스가 **하나의 부모 클래스만 상속**받는 구조입니다.

```java
class Animal {
    void eat() { System.out.println("먹습니다."); }
}

class Dog extends Animal {
    void bark() { System.out.println("멍멍!"); }
}
```

### ✔ 장점
- 계층 구조가 단순하고 이해하기 쉬움
- 메서드 충돌이 발생하지 않음
- 대부분의 객체지향 언어(Java, C#, Kotlin 등)에서 채택

### ✘ 단점
- 여러 클래스의 기능을 동시에 상속받는 것이 불가능
- 코드 중복이 생길 수 있음

---

## 2. 다중 상속 (Multiple Inheritance)

하위 클래스가 **둘 이상의 부모 클래스**로부터 상속을 받을 수 있는 구조입니다. C++, Python이 대표적인 예입니다.

```cpp
class Flyer {
public:
    void fly() { std::cout << "날고 있습니다." << std::endl; }
};

class Swimmer {
public:
    void swim() { std::cout << "헤엄치고 있습니다." << std::endl; }
};

class Duck : public Flyer, public Swimmer {};
```

### ✔ 장점
- 여러 클래스의 기능을 조합하여 풍부한 기능 제공
- 역할 기반 설계나 믹스인(Mixin) 구현에 유리

### ✘ 단점
- **다이아몬드 문제(Diamond Problem)** 발생 가능성
- 이름 충돌, 메서드 충돌 문제
- 구조가 복잡하고 유지보수 어려움

---

## 3. 다이아몬드 문제

```cpp
class Animal {
public:
    void eat() { std::cout << "먹는다"; }
};

class Mammal : public Animal {};
class Bird : public Animal {};
class Bat : public Mammal, public Bird {}; // 충돌 발생
```

- `Bat` 클래스는 `eat()` 메서드를 두 번 상속받음
- 해결 방법: C++에서는 **가상 상속(virtual inheritance)** 사용, Python은 **MRO(Method Resolution Order)** 사용

---

## 4. 언어별 상속 지원 방식

| 언어 | 클래스 다중 상속 | 인터페이스 다중 상속 | 다이아몬드 문제 대응 |
|------|------------------|------------------------|-----------------------|
| C++  | ✅ 지원          | ❌ 없음                | 가상 상속 (virtual)   |
| Python | ✅ 지원       | ❌ 없음                | MRO                   |
| Java | ❌ 금지          | ✅ 지원                | 인터페이스 충돌 해결 필요 |
| C#   | ❌ 금지          | ✅ 지원                | 명시적 인터페이스 구현 |

---

## 5. 인터페이스를 통한 다중 상속 대체

Java, C# 등은 클래스의 다중 상속을 금지하지만, **인터페이스를 통해 역할 기반 다중 상속**을 지원합니다.

```java
interface Flyer {
    void fly();
}

interface Swimmer {
    void swim();
}

class Duck implements Flyer, Swimmer {
    public void fly() { System.out.println("날다"); }
    public void swim() { System.out.println("헤엄치다"); }
}
```

- 구현 충돌이 없고 유연한 조합 가능
- 실무에서 다중 상속보다 안전하게 사용 가능

---

## ✅ 결론

| 항목 | 단일 상속 | 다중 상속 |
|------|------------|------------|
| 구조 | 단순하고 명확 | 복잡하고 유연 |
| 코드 재사용 | 제한적 | 광범위 |
| 충돌 가능성 | 거의 없음 | 충돌 우려 존재 |
| 추천 방식 | 대부분 언어에서 기본 제공 | 일부 언어에서만 제한적으로 사용 |

> 실무에서는 **단일 상속 + 인터페이스 + 합성(Composition)** 조합을 통해 다형성과 코드 재사용을 유연하게 달성하는 것이 바람직합니다.