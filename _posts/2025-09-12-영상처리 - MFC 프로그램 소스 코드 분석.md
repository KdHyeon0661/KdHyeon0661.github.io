---
layout: post
title: 영상처리 - MFC 프로그램 소스 코드 분석
date: 2025-09-12 21:25:23 +0900
category: 영상처리
---
# MFC 프로그램 소스 코드 분석 (MDI 기준)

> 본 장은 **MFC 문서/뷰(MDI)** 프로젝트를 기준으로, 마법사로 생성된 기본 골격을 **실제 코드와 함께** 정밀 해부합니다.  
> 대상 클래스: **`CFirstApp`(CWinAppEx)**, **`CMainFrame`(CMDIFrameWndEx)**, **`CChildFrame`(CMDIChildWndEx)**, **`CFirstDoc`(CDocument)**, **`CFirstView`(CView)**.  
> 모든 **코드는 ```로 감싸고**, 수학식은 필요 시 **MathJax**(`$...$`, `$$...$$`)를 사용합니다.

---

## 0) 큰 그림: 클래스들 간 상관 관계

### 0.1 구조 다이어그램(텍스트)

```
+---------------------------------------------------------+
|                    CFirstApp : CWinAppEx               |
|   - InitInstance() : DocTemplate 등록                   |
|   - ExitInstance()                                      |
|   - OnAppAbout()                                        |
+-------------------------+-------------------------------+
                          |
                          | AddDocTemplate( CMultiDocTemplate )
                          v
+---------------------------------------------------------+
|              CMultiDocTemplate (리소스: IDR_FirstTYPE)  |
|  Doc Class:  CFirstDoc : CDocument                      |
|  Frame:      CChildFrame : CMDIChildWndEx               |
|  View:       CFirstView : CView (또는 CScrollView)       |
+---------+------------------------------+-----------------+
          |                              |
          |                              v
          |                 +-----------------------------+
          |                 | CMainFrame : CMDIFrameWndEx|
          |                 |  - 메뉴/툴바/상태바/도킹     |
          |                 |  - MDI Client 영역          |
          |                 +-----------------------------+
          |
          v
명령/갱신 라우팅 경로 (CCmdTarget):
ActiveView -> Document -> ChildFrame -> MainFrame -> Application
```

### 0.2 메시지/명령 라우팅 핵심

- **명령(Command)**과 **UI 업데이트(CCmdUI)**는 다음 순서로 전달:
  - **Active View → Document → Child Frame → Main Frame → Application**
- 예를 들어 `ID_PROC_INVERT` 같은 메뉴 명령을 구현하면,
  - `CFirstView::OnProcInvert()` → (없으면) `CFirstDoc::OnProcInvert()` → `CChildFrame` → `CMainFrame` → `CFirstApp`
- 툴바/메뉴 항목의 활성화/체크 상태는 `OnUpdate...` 핸들러에서 제어.

---

## 1) MFC 클래스들 간의 상관 관계 (상세)

- **`CFirstApp`**: 앱의 진입점. `InitInstance()`에서 **문서 템플릿 등록**, 프레임/리본/테마 설정, 레지스트리 키 설정.
- **`CMainFrame`**: **MDI 프레임**(상단 메뉴/툴바/상태바/도킹). 클라이언트 영역에 **MDI 클라이언트**가 생성되어 자식 프레임들이 떠다님.
- **`CChildFrame`**: 각 문서 창을 감싸는 **MDI 자식 프레임**. 뷰를 포함.
- **`CFirstDoc`**: 실제 데이터 모델. **영상 버퍼/메타데이터** 보관, **Serialize()**로 저장/불러오기.
- **`CFirstView`**: 데이터를 화면에 그리고 사용자 입력을 받아 문서 또는 컨트롤러에 전달.

> **Doc/View 철칙**: **데이터는 Doc**, **표시는 View**. View에서 데이터를 바꾸면 **문서를 통해** 바꾸고, 변경 후 **`UpdateAllViews()`**로 갱신 통지.

---

## 2) `CFirstApp` 클래스 분석 (CWinAppEx)

### 2.1 헤더(요지)

```cpp
// FirstApp.h
#pragma once
#include "resource.h"       // 주 리소스 ID

class CFirstApp : public CWinAppEx
{
public:
    CFirstApp() noexcept;

    // 재시작 관리자 지원 등
    DWORD m_dwRestartManagerSupportFlags;

    // 재정의
    virtual BOOL InitInstance() override;
    virtual int  ExitInstance() override;

    // 사용자 지정 상태 저장/복원 (선택)
    virtual void PreLoadState();
    virtual void LoadCustomState();
    virtual void SaveCustomState();

    afx_msg void OnAppAbout();
    DECLARE_MESSAGE_MAP()
};
```

### 2.2 구현(핵심)

```cpp
// FirstApp.cpp
#include "pch.h"
#include "framework.h"
#include "FirstApp.h"
#include "MainFrm.h"
#include "ChildFrm.h"
#include "FirstDoc.h"
#include "FirstView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

BEGIN_MESSAGE_MAP(CFirstApp, CWinAppEx)
    ON_COMMAND(ID_APP_ABOUT, &CFirstApp::OnAppAbout)
    // 표준 파일 명령(새로 만들기/열기/인쇄 설정)은 DocTemplate가 처리
    ON_COMMAND(ID_FILE_NEW, &CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, &CWinApp::OnFileOpen)
END_MESSAGE_MAP()

CFirstApp::CFirstApp() noexcept
{
    // Windows Restart Manager 지원 (문서 복구 등)
    m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_ALL_ASPECTS;
    // App ID (COM/JumpList 등)
    SetAppID(L"FirstCompany.FirstProduct.1.0");
}

BOOL CFirstApp::InitInstance()
{
    INITCOMMONCONTROLSEX InitCtrls { sizeof(InitCtrls), ICC_WIN95_CLASSES };
    InitCommonControlsEx(&InitCtrls);

    CWinAppEx::InitInstance();

    // 콘솔이 아닌 GUI 앱에서는 OLE/COM 초기화 필요 시 AfxOleInit
    if (!AfxOleInit())
    {
        AfxMessageBox(L"OLE 초기화 실패");
        return FALSE;
    }
    AfxEnableControlContainer();

    // 비주얼 매니저(현대 테마)
    CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));
    // 레지스트리 키 (설정 저장 위치)
    SetRegistryKey(L"FirstCompany");
    LoadStdProfileSettings(4); // MRU 4개

    // 문서 템플릿 등록 (MDI)
    CMultiDocTemplate* pDocTemplate = new CMultiDocTemplate(IDR_FirstTYPE,
        RUNTIME_CLASS(CFirstDoc),
        RUNTIME_CLASS(CChildFrame),    // MDI Child Frame
        RUNTIME_CLASS(CFirstView));
    if (!pDocTemplate) return FALSE;
    AddDocTemplate(pDocTemplate);

    // 메인 프레임 창 생성
    CMainFrame* pMainFrame = new CMainFrame;
    if (!pMainFrame || !pMainFrame->LoadFrame(IDR_MAINFRAME))
    {
        delete pMainFrame;
        return FALSE;
    }
    m_pMainWnd = pMainFrame;

    // 명령줄 파싱/처리(파일 열기, DDE, 등록 등)
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    pMainFrame->ShowWindow(SW_SHOW);
    pMainFrame->UpdateWindow();
    return TRUE;
}

int CFirstApp::ExitInstance()
{
    AfxOleTerm(FALSE);
    return CWinAppEx::ExitInstance();
}

void CFirstApp::OnAppAbout()
{
    // 간단 About 대화상자
    CDialog(IDD_ABOUTBOX).DoModal();
}
```

#### 2.3 포인트 해설

- **`CMultiDocTemplate`**: MDI에서 **문서/자식 프레임/뷰**의 조합을 등록.
- **`LoadFrame(IDR_MAINFRAME)`**: `CMainFrame` 생성 및 리소스(메뉴/툴바/상태바) 로드.
- **`ProcessShellCommand`**: 커맨드라인으로 파일 열기 등 스위치를 처리.
- **레지스트리 키**: **MRU/윈도우 배치/사용자 설정** 저장 경로.

---

## 3) `CMainFrame` 클래스 분석 (CMDIFrameWndEx)

### 3.1 헤더(요지)

```cpp
// MainFrm.h
#pragma once

class CMainFrame : public CMDIFrameWndEx
{
    DECLARE_DYNAMIC(CMainFrame)
public:
    CMainFrame() noexcept;

    // 구성요소: 메뉴바/툴바/상태바
    CMFCMenuBar   m_wndMenuBar;
    CMFCToolBar   m_wndToolBar;
    CMFCStatusBar m_wndStatusBar;

protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs) override;
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    DECLARE_MESSAGE_MAP()
};
```

### 3.2 구현(핵심)

```cpp
// MainFrm.cpp
#include "pch.h"
#include "framework.h"
#include "FirstApp.h"
#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWndEx)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWndEx)
    ON_WM_CREATE()
END_MESSAGE_MAP()

CMainFrame::CMainFrame() noexcept {}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if (!CMDIFrameWndEx::PreCreateWindow(cs))
        return FALSE;
    // 윈도우 스타일 조정 가능
    // cs.style |= WS_CLIPCHILDREN | WS_CLIPSIBLINGS; // GDI 겹침 방지
    return TRUE;
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CMDIFrameWndEx::OnCreate(lpCreateStruct) == -1)
        return -1;

    // 메뉴 바
    if (!m_wndMenuBar.Create(this))
        return -1;
    m_wndMenuBar.SetPaneStyle(m_wndMenuBar.GetPaneStyle() | CBRS_SIZE_DYNAMIC);

    // 툴바
    if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP |
        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
        return -1;

    // 상태바
    if (!m_wndStatusBar.Create(this))
        return -1;
    m_wndStatusBar.SetIndicators(nullptr, 0); // 필요 시 인디케이터 추가

    // 도킹 활성화
    EnableDocking(CBRS_ALIGN_ANY);
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    DockPane(&m_wndToolBar);

    // MDI 탭/문서 관리(선택)
    CMDITabInfo mdiTabParams;
    mdiTabParams.m_style = CMFCTabCtrl::STYLE_3D_ONENOTE;
    mdiTabParams.m_bActiveTabCloseButton = TRUE;
    mdiTabParams.m_bTabIcons = FALSE;
    mdiTabParams.m_bAutoColor = TRUE;
    EnableMDITabbedGroups(TRUE, mdiTabParams);

    return 0;
}
```

#### 3.3 포인트 해설

- **`CMDIFrameWndEx`**: 최신 MFC 프레임. 탭 그룹/도킹 지원 강화.
- **메뉴/툴바/상태바**: `LoadToolBar(IDR_MAINFRAME)`는 `FirstApp.rc`의 리소스를 사용.
- **도킹/탭 그룹**: 여러 문서를 탭으로 전환할 수 있게 함.

---

## 4) `CChildFrame` 클래스 분석 (CMDIChildWndEx)

### 4.1 헤더(요지)

```cpp
// ChildFrm.h
#pragma once

class CChildFrame : public CMDIChildWndEx
{
    DECLARE_DYNCREATE(CChildFrame)
public:
    CChildFrame() noexcept;

protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs) override;
    DECLARE_MESSAGE_MAP()
};
```

### 4.2 구현(핵심)

```cpp
// ChildFrm.cpp
#include "pch.h"
#include "framework.h"
#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWndEx)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWndEx)
END_MESSAGE_MAP()

CChildFrame::CChildFrame() noexcept {}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if (!CMDIChildWndEx::PreCreateWindow(cs))
        return FALSE;

    // 자식 프레임 스타일 커스터마이징
    cs.style |= FWS_ADDTOTITLE; // 문서 제목을 프레임 타이틀에 포함
    return TRUE;
}
```

#### 4.3 포인트 해설

- **MDI Child 창**은 실제 **뷰**를 포함. 문서당 하나의 ChildFrame이 기본.
- `FWS_ADDTOTITLE`로 문서명이 윈도우 타이틀에 붙도록.

---

## 5) `CFirstDoc` 클래스 분석 (CDocument)

### 5.1 헤더(데이터 보관소 예시)

```cpp
// FirstDoc.h
#pragma once

class CFirstDoc : public CDocument
{
protected:
    CFirstDoc() noexcept;
    DECLARE_DYNCREATE(CFirstDoc)

public:
    // 예: 영상 데이터(그레이 8-bit)
    int m_width = 0;
    int m_height = 0;
    std::vector<uint8_t> m_pixels; // m_width * m_height

public:
    virtual BOOL OnNewDocument() override;
    virtual void Serialize(CArchive& ar) override; // 저장/불러오기

#ifdef _DEBUG
    virtual void AssertValid() const override;
    virtual void Dump(CDumpContext& dc) const override;
#endif

    // 헬퍼: 픽셀 접근
    inline bool IsValid() const { return m_width > 0 && m_height > 0 && m_pixels.size() == (size_t)m_width * m_height; }
    inline uint8_t* RowPtr(int y) { return m_pixels.data() + (size_t)y * m_width; }

    // 처리 예시
    void Invert();
};
```

### 5.2 구현(핵심)

```cpp
// FirstDoc.cpp
#include "pch.h"
#include "framework.h"
#include "FirstApp.h"
#include "FirstDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CFirstDoc, CDocument)

BEGIN_MESSAGE_MAP(CFirstDoc, CDocument)
    // 문서 레벨 명령이 있으면 여기에
END_MESSAGE_MAP()

CFirstDoc::CFirstDoc() noexcept {}

BOOL CFirstDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    // 새 문서: 기본 크기 영상 준비(256x256)
    m_width = 256;
    m_height = 256;
    m_pixels.assign((size_t)m_width * m_height, 0);

    // 간단 그라데이션
    for (int y = 0; y < m_height; ++y) {
        for (int x = 0; x < m_width; ++x) {
            m_pixels[y * m_width + x] = static_cast<uint8_t>((x ^ y) & 0xFF);
        }
    }
    SetModifiedFlag(TRUE);
    return TRUE;
}

void CFirstDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        ar << m_width << m_height;
        if (IsValid())
            ar.Write(m_pixels.data(), (UINT)m_pixels.size());
    }
    else
    {
        ar >> m_width >> m_height;
        m_pixels.assign((size_t)m_width * m_height, 0);
        if (IsValid())
            ar.Read(m_pixels.data(), (UINT)m_pixels.size());
    }
}

#ifdef _DEBUG
void CFirstDoc::AssertValid() const { CDocument::AssertValid(); }
void CFirstDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
    dc << L"Size: " << m_width << L"x" << m_height << L"\n";
}
#endif

void CFirstDoc::Invert()
{
    if (!IsValid()) return;
    for (auto& v : m_pixels) v = 255 - v;
    SetModifiedFlag(TRUE);
}
```

#### 5.3 포인트 해설

- **문서가 데이터의 소유자**. 뷰는 문서의 포인터(`GetDocument()`)를 통해 데이터 접근.
- **`Serialize()`**: 문서 저장/불러오기. 간단한 바이너리 포맷 예시(폭/높이 + 픽셀).
- **`SetModifiedFlag(TRUE)`**: 저장되지 않은 변경 표시(닫기 시 저장 여부 대화 상자).

---

## 6) `CFirstView` 클래스 분석 (CView)

### 6.1 헤더(요지)

```cpp
// FirstView.h
#pragma once
#include "FirstDoc.h"

class CFirstView : public CView
{
protected:
    CFirstView() noexcept;
    DECLARE_DYNCREATE(CFirstView)

public:
    CFirstDoc* GetDocument() const;

    // 그리기
    virtual void OnDraw(CDC* pDC) override;
    virtual void OnInitialUpdate() override; // 문서와 연결된 직후 1회 호출

    // 명령/업데이트
    afx_msg void OnProcInvert();
    afx_msg void OnUpdateProcInvert(CCmdUI* pCmdUI);

protected:
    DECLARE_MESSAGE_MAP()
};
```

### 6.2 구현(핵심)

```cpp
// FirstView.cpp
#include "pch.h"
#include "framework.h"
#include "FirstApp.h"
#include "FirstDoc.h"
#include "FirstView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CFirstView, CView)

BEGIN_MESSAGE_MAP(CFirstView, CView)
    ON_COMMAND(ID_PROC_INVERT, &CFirstView::OnProcInvert)
    ON_UPDATE_COMMAND_UI(ID_PROC_INVERT, &CFirstView::OnUpdateProcInvert)
END_MESSAGE_MAP()

CFirstView::CFirstView() noexcept {}

void CFirstView::OnInitialUpdate()
{
    CView::OnInitialUpdate();
    // 스크롤뷰였다면 SetScrollSizes(MM_TEXT, CSize(...)); 등 설정
}

void CFirstView::OnDraw(CDC* pDC)
{
    CFirstDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    if (!pDoc || !pDoc->IsValid()) return;

    const int W = pDoc->m_width;
    const int H = pDoc->m_height;
    const int bpp = 24;
    const int bytesPerPixel = bpp / 8;
    const int stride = ((W * bytesPerPixel + 3) / 4) * 4;

    std::vector<uint8_t> bgr((size_t)stride * H);
    for (int y = 0; y < H; ++y) {
        const uint8_t* src = pDoc->RowPtr(y);
        uint8_t* row = bgr.data() + (size_t)y * stride;
        for (int x = 0; x < W; ++x) {
            uint8_t g = src[x];
            row[x*3+0] = g; // B
            row[x*3+1] = g; // G
            row[x*3+2] = g; // R
        }
    }

    BITMAPINFO bmi{};
    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       = W;
    bmi.bmiHeader.biHeight      = -H; // top-down
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = bpp;
    bmi.bmiHeader.biCompression = BI_RGB;

    CRect rc;
    GetClientRect(&rc);
    ::StretchDIBits(pDC->m_hDC,
                    rc.left, rc.top, rc.Width(), rc.Height(),
                    0, 0, W, H,
                    bgr.data(), &bmi, DIB_RGB_COLORS, SRCCOPY);
}

void CFirstView::OnProcInvert()
{
    CFirstDoc* pDoc = GetDocument();
    if (!pDoc) return;
    pDoc->Invert();
    pDoc->UpdateAllViews(this); // 다른 뷰도 갱신
}

void CFirstView::OnUpdateProcInvert(CCmdUI* pCmdUI)
{
    // 조건부로 버튼/메뉴 활성화/비활성
    CFirstDoc* pDoc = GetDocument();
    pCmdUI->Enable(pDoc && pDoc->IsValid());
}

#ifdef _DEBUG
void CFirstView::AssertValid() const { CView::AssertValid(); }
void CFirstView::Dump(CDumpContext& dc) const { CView::Dump(dc); }
CFirstDoc* CFirstView::GetDocument() const
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CFirstDoc)));
    return static_cast<CFirstDoc*>(m_pDocument);
}
#endif
```

#### 6.3 포인트 해설

- **`OnDraw`**: 그릴 때마다 문서의 데이터를 **BGR 24-bit**로 변환 후 `StretchDIBits`.
- **명령 핸들러/업데이트 핸들러**: `ID_PROC_INVERT`에 대한 기능/활성화를 뷰에 배치.
- **`UpdateAllViews`**: 문서 변경 후 모든 연결된 뷰에 재그리기 통지.

---

## 7) 리소스와 ID: 메뉴/툴바/가속기 추가

### 7.1 리소스 헤더(일부)

```cpp
// Resource.h
#define IDR_MAINFRAME                  128
#define IDR_FirstTYPE                  129 // DocTemplate용
#define IDD_ABOUTBOX                   100
#define ID_PROC_INVERT                 32771
```

### 7.2 메뉴에 항목 추가 (예: `ID_PROC_INVERT`)

리소스 편집기에서 **IDR_FirstTYPE** 메뉴에 **"Invert"** 항목을 추가하고 ID를 `ID_PROC_INVERT`로 지정.  
툴바 버튼도 동일 ID로 추가하면 **자동으로 같은 명령**을 공유.

### 7.3 가속기(accelerator) (선택)

`ID_PROC_INVERT`에 단축키(예: `Ctrl+I`)를 등록하면, 동일 라우팅으로 뷰의 `OnProcInvert()`가 호출.

---

## 8) 명령 라우팅/업데이트 — 실제 흐름 추적

### 8.1 라우팅 순서

1. **활성 뷰**(`CFirstView`)의 `OnProcInvert`를 찾음  
2. 없으면 **문서**(`CFirstDoc`)에서 찾음  
3. → **ChildFrame** → **MainFrame** → **CFirstApp**

### 8.2 디버깅 팁

- `TRACE`로 `__FUNCTION__` 출력하여 어느 클래스가 핸들링했는지 확인.
- `OnUpdateProcInvert`에 중단점을 걸고 **Enable/Disable** 조건이 의도대로인지 검증.

---

## 9) 파일 입출력 확장(문서 Serialize 응용)

### 9.1 간단한 파일 포맷 연동 (열기/저장)

- 현재 `Serialize()`는 **폭/높이 + raw**를 저장/불러오기.  
- “**열기**” 메뉴로 문서를 생성하면, **`CWinApp::OnFileOpen` → `CDocument::OnOpenDocument`** 순으로 호출.  
  - 기본 구현은 `Serialize(ar)`를 호출해 직렬화.

### 9.2 포맷 식별/확장자 필터

- `IDR_FirstTYPE`의 **문서 문자열**에 확장자/필터를 설정하면, 파일 대화상자에 반영:
  - 예: `"First\nFirst\nFirst Files (*.fst)\n.fst\n..."` (마법사 생성 기본 포맷 참조)

---

## 10) 성능/디자인 선택: CView vs CScrollView vs CFormView

- **`CView`**: 가장 단순. 스스로 스크롤/줌을 구현해야 함.
- **`CScrollView`**: 캔버스 크기를 지정하면 스크롤바를 자동 처리.
- **`CFormView`**: 대화상자 리소스 기반 UI를 뷰로 사용(컨트롤 배치가 쉬움).

영상 뷰어라면 **`CScrollView`**로 큰 이미지를 다루기 편합니다. (추후 확대/축소/좌표계 변환을 추가할 예정)

---

## 11) 예제: 히스토그램 평활화 명령 추가(문서-뷰 협업)

### 11.1 리소스

- 메뉴/툴바에 `ID_PROC_HIST_EQ` 추가.

```cpp
// Resource.h
#define ID_PROC_HIST_EQ                32772
```

### 11.2 문서에 연산 추가

```cpp
// FirstDoc.h
void HistEqualize();
```

```cpp
// FirstDoc.cpp
void CFirstDoc::HistEqualize()
{
    if (!IsValid()) return;

    // 히스토그램
    const int N = 256;
    std::array<uint32_t, N> H{}; H.fill(0);
    for (auto v : m_pixels) ++H[v];

    // 누적분포(CDF)
    std::array<uint32_t, N> C{}; C[0] = H[0];
    for (int i = 1; i < N; ++i) C[i] = C[i-1] + H[i];

    uint32_t total = (uint32_t)m_pixels.size();
    if (total == 0) return;

    // 변환 테이블
    std::array<uint8_t, N> LUT{};
    for (int i = 0; i < N; ++i)
        LUT[i] = (uint8_t)std::round((double)C[i] * 255.0 / (double)total);

    for (auto& v : m_pixels) v = LUT[v];
    SetModifiedFlag(TRUE);
}
```

### 11.3 뷰 핸들러 추가

```cpp
// FirstView.h
afx_msg void OnProcHistEq();
afx_msg void OnUpdateProcHistEq(CCmdUI* pCmdUI);
```

```cpp
// FirstView.cpp (Message map)
ON_COMMAND(ID_PROC_HIST_EQ, &CFirstView::OnProcHistEq)
ON_UPDATE_COMMAND_UI(ID_PROC_HIST_EQ, &CFirstView::OnUpdateProcHistEq)

void CFirstView::OnProcHistEq()
{
    if (auto* pDoc = GetDocument()) {
        pDoc->HistEqualize();
        pDoc->UpdateAllViews(this);
    }
}

void CFirstView::OnUpdateProcHistEq(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}
```

---

## 12) 예제: 파일 → PGM(그레이 8-bit) 열기/저장 연결

> **주의**: 실제 제품에선 에러 처리/헤더 주석/범위 검사 강화가 필요.

### 12.1 도우미(간단 PGM I/O)

```cpp
// PgmIO.h
#pragma once
#include <vector>
#include <string>
#include <fstream>
#include <stdexcept>

inline void LoadPGM(const std::wstring& path, int& w, int& h, std::vector<uint8_t>& pixels)
{
    std::ifstream ifs(path, std::ios::binary);
    if (!ifs) throw std::runtime_error("open failed");

    auto read_token = [&]() {
        std::string tok;
        for (;;) {
            ifs >> tok;
            if (!ifs) throw std::runtime_error("read token failed");
            if (tok.size() && tok[0] == '#') { std::string dummy; std::getline(ifs, dummy); continue; }
            break;
        }
        return tok;
    };

    std::string magic = read_token();
    if (magic != "P5") throw std::runtime_error("not P5");

    w = std::stoi(read_token());
    h = std::stoi(read_token());
    int maxv = std::stoi(read_token());
    if (maxv != 255) throw std::runtime_error("not 8-bit");

    ifs.get(); // consume whitespace
    pixels.assign((size_t)w * h, 0);
    ifs.read(reinterpret_cast<char*>(pixels.data()), (std::streamsize)pixels.size());
    if (!ifs) throw std::runtime_error("payload truncated");
}

inline void SavePGM(const std::wstring& path, int w, int h, const std::vector<uint8_t>& pixels)
{
    std::ofstream ofs(path, std::ios::binary);
    if (!ofs) throw std::runtime_error("open failed");
    ofs << "P5\n" << w << " " << h << "\n255\n";
    ofs.write(reinterpret_cast<const char*>(pixels.data()), (std::streamsize)pixels.size());
}
```

### 12.2 문서에 “열기/저장” 오버라이드 연결(간단)

```cpp
// FirstDoc.h
virtual BOOL OnOpenDocument(LPCTSTR lpszPathName) override;
virtual BOOL OnSaveDocument(LPCTSTR lpszPathName) override;
```

```cpp
// FirstDoc.cpp
#include "PgmIO.h"

BOOL CFirstDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    try {
        int w, h; std::vector<uint8_t> px;
        LoadPGM(lpszPathName, w, h, px);
        m_width = w; m_height = h; m_pixels.swap(px);
        UpdateAllViews(nullptr);
        SetModifiedFlag(FALSE);
        return TRUE;
    } catch (const std::exception& e) {
        CString msg; msg.Format(L"PGM 열기 실패: %S", e.what());
        AfxMessageBox(msg);
        return FALSE;
    }
}

BOOL CFirstDoc::OnSaveDocument(LPCTSTR lpszPathName)
{
    try {
        if (!IsValid()) return FALSE;
        SavePGM(lpszPathName, m_width, m_height, m_pixels);
        SetModifiedFlag(FALSE);
        return TRUE;
    } catch (const std::exception& e) {
        CString msg; msg.Format(L"PGM 저장 실패: %S", e.what());
        AfxMessageBox(msg);
        return FALSE;
    }
}
```

> 이제 **파일 → 열기**로 `.pgm`을 선택하면 **문서**가 해당 이미지를 보유하고, **뷰**가 그립니다.

---

## 13) 메시지 맵/MFC 매크로 해설

- `BEGIN_MESSAGE_MAP(CFirstView, CView)` … `END_MESSAGE_MAP()`  
  - `ON_COMMAND(ID_xxx, &Class::OnXxx)` : 메뉴/툴바/가속기 명령  
  - `ON_UPDATE_COMMAND_UI(ID_xxx, &Class::OnUpdateXxx)` : UI 상태 갱신  
  - `ON_WM_CREATE()` / `ON_WM_SIZE()` 등: 윈도우 메시지(`WM_*`) 핸들러
- **RTTI/런타임 동적 생성**:
  - `DECLARE_DYNCREATE` / `IMPLEMENT_DYNCREATE`
  - 다이얼로그/뷰/프레임이 프레임워크에 의해 **런타임 생성**될 수 있게 함.
- **디버그 어시스트**:
  - `ASSERT_VALID(pDoc)` / `DEBUG_NEW` / `Dump()`

---

## 14) 문서-뷰 동기화 패턴 (권장 습관)

1. **문서 함수**에서 데이터 변경(`Invert`, `HistEqualize`, `Load`)  
2. `SetModifiedFlag(TRUE)` (필요 시)  
3. **갱신 통지**: `UpdateAllViews(nullptr)`  
4. **뷰**는 `OnDraw()`에서 문서의 현재 상태를 반영하여 그리기

> 뷰에서 직접 데이터를 보관/수정하기 시작하면 **동기화 지옥**이 생깁니다. 항상 **문서 단일 소유** 원칙으로.

---

## 15) 예제: 확대/축소(뷰 레벨, 간단 버전)

> 여기선 **뷰**에 단순 배율만 도입(실무에선 `CScrollView` 추천).

### 15.1 뷰 멤버

```cpp
// FirstView.h
double m_zoom = 1.0;
afx_msg void OnViewZoomIn();
afx_msg void OnViewZoomOut();
afx_msg void OnUpdateViewZoom(CCmdUI* pCmdUI);
```

```cpp
// Resource.h
#define ID_VIEW_ZOOMIN   32780
#define ID_VIEW_ZOOMOUT  32781
#define ID_VIEW_ZOOMSTAT 32782 // 상태 표시용(선택)
```

### 15.2 구현

```cpp
// FirstView.cpp (Message map)
ON_COMMAND(ID_VIEW_ZOOMIN, &CFirstView::OnViewZoomIn)
ON_COMMAND(ID_VIEW_ZOOMOUT, &CFirstView::OnViewZoomOut)
ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOMIN, &CFirstView::OnUpdateViewZoom)
ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOMOUT, &CFirstView::OnUpdateViewZoom)

void CFirstView::OnViewZoomIn()
{
    m_zoom = std::min(8.0, m_zoom * 1.25);
    Invalidate(FALSE);
}
void CFirstView::OnViewZoomOut()
{
    m_zoom = std::max(0.125, m_zoom / 1.25);
    Invalidate(FALSE);
}

void CFirstView::OnUpdateViewZoom(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}

void CFirstView::OnDraw(CDC* pDC)
{
    CFirstDoc* pDoc = GetDocument();
    if (!pDoc || !pDoc->IsValid()) return;
    const int W = pDoc->m_width, H = pDoc->m_height;

    // ... (BGR 변환 코드는 동일)

    CRect rc; GetClientRect(&rc);
    int dstW = (int)std::round(W * m_zoom);
    int dstH = (int)std::round(H * m_zoom);

    // 중앙 배치
    int left = rc.left + (rc.Width() - dstW) / 2;
    int top  = rc.top  + (rc.Height() - dstH) / 2;

    // StretchDIBits with dstW/dstH
    // ...
}
```

---

## 16) 프린팅/미리보기(선택)

- MFC 마법사에는 **인쇄** 골격(`OnPreparePrinting`, `OnBeginPrinting`, `OnEndPrinting`)이 포함됨.
- `OnDraw` 코드의 일부를 프린트 DC에 맞게 **스케일링**하여 출력 가능.

---

## 17) 예외/에러 처리 체크리스트

- [ ] 파일 I/O: 존재/권한/크기/포맷 검사  
- [ ] 직렬화: 버전 필드 포함(향후 포맷 변경 대비)  
- [ ] GDI 리소스: `SelectObject` 한 것은 반드시 **원복**  
- [ ] 큰 버퍼: `size_t`/오버플로 확인  
- [ ] 멀티스레드(추가 시): MFC UI 스레드 규칙 준수(뷰/윈도우 접근은 **UI 스레드**)

---

## 18) 흔한 문제와 해결

**Q. 뷰가 갱신되지 않아요.**  
A. 데이터 변경 후 **`UpdateAllViews()`** 또는 `Invalidate(FALSE)` 호출을 잊지 않았는지 확인.

**Q. 이미지가 거꾸로 보입니다.**  
A. `biHeight`를 **음수(top-down)**로 설정했는지 확인.

**Q. 명령 핸들러가 호출되지 않습니다.**  
A. 메뉴/툴바 항목의 **ID**가 핸들러의 ID와 일치하는지, **라우팅 경로** 상의 클래스를 확인하세요.

**Q. SDI인데 `CChildFrame`이 왜 없죠?**  
A. SDI는 `CFrameWndEx`를 사용하고 **ChildFrame**이 없습니다. 본 장은 **MDI** 기준입니다.

---

## 19) 요약

- **`CFirstApp`**: 앱 수명/문서 템플릿/프레임 생성의 **오케스트라**  
- **`CMainFrame`**: 도킹/툴바/메뉴/상태바/MDI 탭의 **무대**  
- **`CChildFrame`**: 각 문서 창의 **컨테이너**  
- **`CFirstDoc`**: 데이터의 **단일 소유자**, 저장/불러기/연산  
- **`CFirstView`**: 데이터의 **표현자**, 사용자 명령의 **첫 수신자**

> 이 골격을 바탕으로 **영상 처리 명령(필터, 변환)**을 **문서에 구현**하고, **뷰에서 트리거/렌더링**하는 방식으로 확장하면 **견고한 데스크톱 영상툴**을 만들 수 있습니다.
