---
layout: post
title: 영상처리 - 트루컬러 비트맵 다루기
date: 2025-09-29 23:25:23 +0900
category: 영상처리
---
# 트루컬러 비트맵 다루기

## 1) 트루컬러 비트맵과 채널 순서

### 1.1 DIB(BGRA32)와 IppImage(RGB24)의 역할 분리
- **IppDib (BGRA32)**: Windows GDI/화면 출력 친화. 픽셀은 `B,G,R,A` 4바이트.  
- **IppImage<T>**: 연산 친화. 예컨대
  - `IppImage<uint8_t>`: 8비트 그레이
  - `IppImage<RGB24>`: 24비트 컬러(메모리 순서 **R,G,B**)

> 왜 분리?  
> - BGRA32는 출력/복사에 유리하고, `IppImage`는 연산(템플릿, 타입 안정성)에 유리합니다.  
> - 변환 함수(4.4절에서 다룬 상호 변환)를 이용해 오가며 처리합니다.

### 1.2 픽셀 접근 핵심 개념(Stride, Row, Index)
- **Stride**: 한 줄의 바이트 수(메모리 정렬 포함).  
- **Row(y)**: y번째 줄의 시작 포인터.  
- **at(y,x)**: (안전/직관) y,x 위치의 픽셀 참조.

---

## 2) IppImage 클래스에서 **컬러 픽셀 참조** 방법

우선 24비트 RGB 픽셀 타입과 `IppImage<T>` 의 필수 인터페이스를 정리합니다.

```cpp
// RGB24.h
#pragma once
#include <cstdint>

struct RGB24 {
    uint8_t r, g, b; // 연산/이해를 위해 R,G,B 순서로 정의
    RGB24() = default;
    RGB24(uint8_t R, uint8_t G, uint8_t B) : r(R), g(G), b(B) {}
};
```

```cpp
// IppImage.h (요점만 발췌)
#pragma once
#include <cstddef>
#include <cstdint>
#include <vector>
#include <cstring>
#include <stdexcept>

template<typename T>
class IppImage {
public:
    IppImage() = default;
    IppImage(int w, int h) { create(w,h); }

    bool   empty()  const { return _w==0 || _h==0 || _data.empty(); }
    int    width()  const { return _w; }
    int    height() const { return _h; }
    size_t stride() const { return _stride; } // 바이트 단위
    const uint8_t* raw() const { return _data.data(); }
    uint8_t*       raw()       { return _data.data(); }

    void create(int w, int h){
        if (w<=0 || h<=0) throw std::runtime_error("IppImage::create invalid size");
        _w=w; _h=h;
        _stride = sizeof(T)*static_cast<size_t>(w);
        _data.resize(_stride*static_cast<size_t>(h));
    }
    T*       row(int y)       { return reinterpret_cast<T*>(_data.data() + _stride*static_cast<size_t>(y)); }
    const T* row(int y) const { return reinterpret_cast<const T*>(_data.data() + _stride*static_cast<size_t>(y)); }

    T&       at(int y, int x)       { return row(y)[x]; }
    const T& at(int y, int x) const { return row(y)[x]; }

private:
    int _w=0, _h=0;
    size_t _stride=0;
    std::vector<uint8_t> _data;
};
```

### 2.1 컬러 픽셀 읽기/쓰기 예시
```cpp
// 예) 모든 픽셀의 G채널을 2배(클램프)
void BoostGreen(IppImage<RGB24>& img) {
    for (int y=0; y<img.height(); ++y) {
        RGB24* p = img.row(y);
        for (int x=0; x<img.width(); ++x) {
            int g = p[x].g * 2;
            p[x].g = (uint8_t)(g>255 ? 255 : g);
        }
    }
}
```

### 2.2 안전한 도우미(클램프, 루마)
```cpp
inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }
inline uint8_t luma_bt601(uint8_t r, uint8_t g, uint8_t b){
    // Y = 0.299R + 0.587G + 0.114B (BT.601)
    int y = (299*r + 587*g + 114*b + 500) / 1000; // 반올림
    return clamp_u8(y);
}
```

---

## 3) **트루컬러 영상의 반전** (Color Inversion)

### 3.1 개념
각 채널에 대해 \(v \leftarrow 255 - v\) 를 적용(알파는 유지).  
- **RGB24(IppImage)**: r,g,b 각각 반전  
- **BGRA32(IppDib)**: B,G,R 반전, A는 그대로

### 3.2 구현 (IppImage<RGB24> 버전)
```cpp
// ColorOps.hpp (발췌)
#pragma once
#include "IppImage.h"
#include "RGB24.h"

inline void InvertRGB(IppImage<RGB24>& img) {
    for (int y=0; y<img.height(); ++y) {
        RGB24* p = img.row(y);
        for (int x=0; x<img.width(); ++x) {
            p[x].r = 255 - p[x].r;
            p[x].g = 255 - p[x].g;
            p[x].b = 255 - p[x].b;
        }
    }
}
```

### 3.3 구현 (IppDib BGRA32, 화면용)
```cpp
// ColorOps_Dib.hpp
#pragma once
#include "IppDib.h"

inline void InvertBGRA(IppDib& dib){
    if (!dib) return;
    const int W = dib.width();
    const int H = dib.height();
    for (int y=0; y<H; ++y){
        uint8_t* d = (uint8_t*)dib.bits() + (size_t)y*dib.stride();
        for (int x=0; x<W; ++x){
            d[x*4+0] = 255 - d[x*4+0]; // B
            d[x*4+1] = 255 - d[x*4+1]; // G
            d[x*4+2] = 255 - d[x*4+2]; // R
            // d[x*4+3] (A)는 유지
        }
    }
}
```

> 성능 팁: 대형 영상은 16바이트 정렬 루프(4픽셀 단위)로 **언롤**하거나, SSE/AVX를 사용하면 수 배 가속됩니다.

---

## 4) **트루컬러 → 그레이스케일 변환**

### 4.1 변환 공식(BT.601)
\[
Y = 0.299R + 0.587G + 0.114B
\]
- **정수 근사**: \(Y \approx (299R + 587G + 114B + 500) / 1000\)  
- **감마 주의**: sRGB(감마 포함)에서 위 선형 결합은 실무의 표준적인 근사. 물리적 정밀도를 원하면 **선형화→가중→재감마** 절차를 사용.

### 4.2 IppImage<RGB24> → IppImage<uint8_t>
```cpp
// ColorToGray.hpp
#pragma once
#include "IppImage.h"
#include "RGB24.h"

inline void ColorToGray(const IppImage<RGB24>& src, IppImage<uint8_t>& dst){
    dst.create(src.width(), src.height());
    for (int y=0; y<src.height(); ++y){
        const RGB24* s = src.row(y);
        uint8_t*     d = dst.row(y);
        for (int x=0; x<src.width(); ++x){
            d[x] = luma_bt601(s[x].r, s[x].g, s[x].b);
        }
    }
}
```

### 4.3 IppDib(BGRA32) 그대로 **회색으로 표시** (출력 전용)
```cpp
// ColorToGray_Dib.hpp
#pragma once
#include "IppDib.h"

inline void ToGrayInPlace_BGRA(IppDib& dib){
    if (!dib) return;
    const int W=dib.width(), H=dib.height();
    for (int y=0; y<H; ++y){
        uint8_t* d = (uint8_t*)dib.bits() + (size_t)y*dib.stride();
        for (int x=0; x<W; ++x){
            uint8_t B=d[x*4+0], G=d[x*4+1], R=d[x*4+2];
            int Y = (114*B + 587*G + 299*R + 500) / 1000;
            uint8_t y8 = (uint8_t)(Y<0?0:(Y>255?255:Y));
            d[x*4+0]=d[x*4+1]=d[x*4+2]=y8; // B=G=R=Y
            // A 유지
        }
    }
}
```

> 파이프라인 선택  
> - **연산 중심**: `IppImage<RGB24> → ColorToGray → IppImage<uint8_t> → IppDib` 로 변환 후 표시  
> - **간편 표시**: `IppDib` 를 **바로 회색화** 후 화면에 그리기(원본 덮어씀)

---

## 5) IppDib ↔ IppImage 상호 변환 스니펫

이미 4.4절에서 다뤘지만, 본 절의 컬러 연산에 필요한 최소 구현을 요약합니다.

```cpp
// DibImageConvert.hpp
#pragma once
#include "IppDib.h"
#include "IppImage.h"
#include "RGB24.h"

// BGRA32 -> IppImage<RGB24> (R,G,B 순서)
inline void DibToImageRGB24(const IppDib& dib, IppImage<RGB24>& img){
    img.create(dib.width(), dib.height());
    for (int y=0; y<dib.height(); ++y){
        const uint8_t* s = (const uint8_t*)dib.bits() + (size_t)y*dib.stride();
        RGB24* d = img.row(y);
        for (int x=0; x<dib.width(); ++x){
            d[x].r = s[x*4+2];
            d[x].g = s[x*4+1];
            d[x].b = s[x*4+0];
        }
    }
}

// IppImage<RGB24> -> BGRA32 (A=255)
inline void ImageRGB24ToDib(const IppImage<RGB24>& img, IppDib& dib){
    dib.create(img.width(), img.height(), 32);
    for (int y=0; y<img.height(); ++y){
        const RGB24* s = img.row(y);
        uint8_t* d = (uint8_t*)dib.bits() + (size_t)y*dib.stride();
        for (int x=0; x<img.width(); ++x){
            d[x*4+0] = s[x].b;
            d[x*4+1] = s[x].g;
            d[x*4+2] = s[x].r;
            d[x*4+3] = 255;
        }
    }
}

// IppImage<uint8_t> (Gray) -> BGRA32 (Y,Y,Y,255)
inline void ImageGrayToDib(const IppImage<uint8_t>& img, IppDib& dib){
    dib.create(img.width(), img.height(), 32);
    for (int y=0; y<img.height(); ++y){
        const uint8_t* s = img.row(y);
        uint8_t* d = (uint8_t*)dib.bits() + (size_t)y*dib.stride();
        for (int x=0; x<img.width(); ++x){
            uint8_t Y = s[x];
            d[x*4+0]=d[x*4+1]=d[x*4+2]=Y; d[x*4+3]=255;
        }
    }
}
```

---

## 6) **메뉴/핸들러** – 반전 및 그레이스케일 변환

### 6.1 리소스 ID
```cpp
// resource.h (추가)
#define ID_MENU_COLOR_INVERT        80010
#define ID_MENU_COLOR_TOGRAY        80011
```

### 6.2 RC(Menu/Accelerator)
```rc
// ImageTool.rc (추가)
POPUP "&Color"
BEGIN
    MENUITEM "Invert Colors\tCtrl+I",    ID_MENU_COLOR_INVERT
    MENUITEM "Convert to Grayscale\tG", ID_MENU_COLOR_TOGRAY
END

IDR_ACCEL ACCELERATORS
BEGIN
    "I", ID_MENU_COLOR_INVERT, VIRTKEY, CONTROL
    "G", ID_MENU_COLOR_TOGRAY, VIRTKEY, NOINVERT
END
```

### 6.3 메시지 핸들러
```cpp
// main_multiwin.cpp (발췌)
#include "ColorOps_Dib.hpp"
#include "ColorToGray_Dib.hpp"
// 필요시 IppImage 경유 변환도 함께 include

// ...
case ID_MENU_COLOR_INVERT:
    if (st && st->dib){
        InvertBGRA(st->dib);                     // 화면용 BGRA32를 직접 반전
        InvalidateRect(hWnd, nullptr, FALSE);
        UpdateStatusBasic(hWnd, st);
    }
    return 0;

case ID_MENU_COLOR_TOGRAY:
    if (st && st->dib){
        // ① 간편: 현재 DIB을 직접 회색화(원본 덮어쓰기)
        ToGrayInPlace_BGRA(st->dib);

        // ② (선택) IppImage 경유: RAM에 그레이를 보관하고 싶다면
        // IppImage<RGB24> rgb; DibToImageRGB24(st->dib, rgb);
        // IppImage<uint8_t> gray; ColorToGray(rgb, gray);
        // ImageGrayToDib(gray, st->dib);

        InvalidateRect(hWnd, nullptr, FALSE);
        UpdateStatusBasic(hWnd, st);
    }
    return 0;
```

> UX 팁  
> - **새 창으로 보기** 옵션을 선호한다면, 변환 결과를 새 도큐먼트로 만들어 띄우고 원본은 그대로 유지할 수 있습니다.  
> - “되돌리기(Undo)” 스택을 운영한다면 `st->dib` 덮어쓰기 전에 스냅샷을 push 하세요.

---

## 7) 사용 예시 & 상황

### 예제 A) **사진 네거티브 효과**
- **상황**: 사진을 네거티브로(필름 느낌).  
- **동작**: `Color → Invert Colors`  
- **결과**: 모든 채널 반전. 하이라이트/섀도우가 뒤바뀐 효과.

### 예제 B) **그레이스케일로 자료 단순화**
- **상황**: 논문/보고서용 차트 이미지를 흑백으로 변환.  
- **동작**: `Color → Convert to Grayscale`  
- **결과**: 색상 제거, 잉크 비용 절감, 대비 중심의 판단에 유리.

### 예제 C) **전처리: 컬러 → 그레이 → 에지**
- **상황**: Canny/Hough 전처리.  
- **동작**: `Convert to Grayscale` → `Edge/Canny` → `Hough Lines`  
- **결과**: 컬러 정보에 덜 민감한 안정적 엣지/선 검출.

---

## 8) 품질/성능/확장 팁

- **감마(sRGB)**  
  - 정확한 “밝기” 보존이 중요하면: `sRGB → 선형화 → 가중합 → sRGB 재적용` 절차 적용.  
  - 본 장의 BT.601 가중합은 **실무 표준 근사**로 충분한 품질을 제공합니다.

- **알파 채널**  
  - BGRA32에서 A는 **유지**(반전/그레이 변환 대상 아님). 프리멀티플라이드 알파를 쓰는 경우 수식이 달라질 수 있습니다.

- **성능**  
  - 큰 영상: **캐시 친화 순회**(row-by-row), **언롤**, **멀티스레딩**.  
  - SIMD(SSE2/AVX2): 4~16픽셀 병렬 처리(특히 회색화는 FMA 없이도 효율적).

- **확장**  
  - LUT(256 엔트리) 기반 회색화: `Y = (a[R]+b[G]+c[B])>>10` 형태로 분리 후 합산.  
  - **HSV/HSL** 변환 후 **V/L** 채널 기반 그레이스케일 등 **스타일 변환** 도입 가능.

---

## 9) 간단 테스트 스니펫

```cpp
// test_color_ops.cpp
#include <cassert>
#include "IppDib.h"
#include "ColorOps_Dib.hpp"
#include "ColorToGray_Dib.hpp"

int main(){
    IppDib dib; dib.create(4,2,32);
    // 라인0: 빨강(255,0,0) 4픽셀, 라인1: 파랑(0,0,255) 4픽셀
    for (int y=0; y<2; ++y){
        uint8_t* d=(uint8_t*)dib.bits()+y*dib.stride();
        for (int x=0; x<4; ++x){
            if (y==0){ d[x*4+0]=0; d[x*4+1]=0;   d[x*4+2]=255; d[x*4+3]=255; }   // R
            else      { d[x*4+0]=255; d[x*4+1]=0; d[x*4+2]=0;   d[x*4+3]=255; } // B
        }
    }

    // 1) 반전
    InvertBGRA(dib);
    {
        // 빨강(255,0,0) 반전 → 시안(0,255,255)
        uint8_t* p=(uint8_t*)dib.bits()+0*dib.stride()+0*4;
        assert(p[0]==255 && p[1]==255 && p[2]==0); // B,G,R
        // 파랑(0,0,255) 반전 → 노랑(255,255,0)
        uint8_t* q=(uint8_t*)dib.bits()+1*dib.stride()+0*4;
        assert(q[0]==0 && q[1]==255 && q[2]==255);
    }

    // 2) 회색화
    ToGrayInPlace_BGRA(dib);
    {
        uint8_t* p=(uint8_t*)dib.bits()+0*dib.stride()+0*4;
        assert(p[0]==p[1] && p[1]==p[2]); // B=G=R
    }
    return 0;
}
```

---

## 10) 요약
- **IppImage<RGB24>** 는 R,G,B 순으로 연산 친화 구조, **IppDib(BGRA32)** 는 출력 친화.  
- **반전**: 각 채널을 \(255-v\) 로, **알파 유지**.  
- **그레이스케일**: BT.601 루마 가중합(간단·표준), 필요시 sRGB 선형화/재감마로 향상.  
- **메뉴/핸들러** 를 추가해 `Invert Colors`, `Convert to Grayscale` 를 즉시 사용 가능.  
- 대용량 영상은 **SIMD/멀티스레드/언롤**로 가속, 품질은 감마 처리로 고급화할 수 있습니다.