---
layout: post
title: DB 심화 - V$SQL
date: 2025-10-24 22:25:23 +0900
category: DB 심화
---
# Oracle `V$SQL`

## 0. 큰 그림: `V$SQL`은 “Child 커서별 실행/리소스 통계”
- 단위: **Child 커서**(statement + 환경/세팅/바인드 패턴이 동일한 공유 가능한 실행체)  
- 범위: **SGA Library Cache** 안의 **현재/최근 유지된 커서들**(Aging/Flush 되면 탈락)  
- 갱신: **실행 시점(부분 누적)**, **커밋과 무관**, 백그라운드 통계 수집/스냅샷과는 별개  
- 주 용도: **Top SQL 식별**, **커서 재사용/Child 폭증 원인 파악**, **리소스(Elapsed/CPU/IO/Temp) 헤비 SQL** 찾기, **실행 계획 조회(Plan hash 라벨)**

> 비슷한 뷰와 비교  
> - `V$SQLAREA`: **SQL_ID 당 집계**(모든 Child 합) → “문장 수준” 요약  
> - `V$SQLSTATS`: 통계 업데이트를 덜 빈번하게(성능 경감) 유지한 **경량 통계**  
> - `V$SQL_PLAN`: 실행계획 라인(Row Source)  
> - `V$SQL_SHARED_CURSOR`: **Child 분기(공유 실패) 이유** 세부 플래그  
> - `V$SQL_MONITOR`: 장수행/병렬/모니터링 대상 실행 단위의 라이브 통계  
> - `DBA_HIST_SQLSTAT/SQLTEXT/SQLPLAN`: **AWR**(과거 스냅샷)

---

## 1. 자주 쓰는 핵심 컬럼 해설(요지)
| 컬럼 | 의미/활용 |
|---|---|
| `SQL_ID` | SQL 텍스트의 식별자(해시). 동일 텍스트는 동일 SQL_ID. |
| `CHILD_NUMBER` | 같은 `SQL_ID` 내 조건/환경 차이로 **분기된 Child** 번호. |
| `PLAN_HASH_VALUE` | 실제 계획을 요약한 해시(계획 “라벨”). Plan 비교/변동 감시에 필수. |
| `PARSE_CALLS` | 파스 횟수(Child 기준). 하드/소프트 합계. |
| `LOADS` | Shared Pool로 적재된 횟수(aging/flush 후 재적재 포함). |
| `EXECUTIONS` | 실행 호출 횟수(Child 기준). |
| `ELAPSED_TIME`, `CPU_TIME` | 누적(마이크로초). `ELAPSED_TIME`은 대기 포함. |
| `BUFFER_GETS`, `DISK_READS`, `DIRECT_WRITES` | 논리/물리 I/O 지표. |
| `ROWS_PROCESSED` | 출력/영향 받은 행수(SELECT면 페치 총행). |
| `SHARABLE_MEM`, `PERSISTENT_MEM`, `RUNTIME_MEM` | 커서가 점유한 라이브러리/UGA/RUNTIME 메모리(바이트). |
| `MODULE`, `ACTION`, `PARSING_SCHEMA_NAME`, `PARSING_USER_ID` | 업무/사용자 차원. |
| `IS_BIND_SENSITIVE`, `IS_BIND_AWARE` | 바인드 값에 민감/어웨어(Adaptive Cursor Sharing). |
| `IS_OBSOLETE`, `INVALIDATIONS` | 무효화/오래됨(통계 변경, DDL 등으로 invalidation). |
| `FETCHES`, `END_OF_FETCH_COUNT` | 페치/완료 카운트. |
| `TYPECHECK_MEM` | 파스 타입체크 메모리. |
| `CHILD_ADDRESS`, `ADDRESS` | 커서 핸들(조인 키로 `V$SQL_PLAN`, `V$SQL_BIND_CAPTURE` 등 연결). |
| `FIRST_LOAD_TIME`, `LAST_ACTIVE_TIME` | 적재 시각, 마지막 활동 시각(노화/청소 판단). |
| `OPTIMIZER_COST`, `OPTIMIZER_ENV_HASH_VALUE` | 비용/옵티마이저 환경(세션 파라미터 조합) 요약. |

> 팁: **성능 분석**에는 `ELAPSED_TIME`, `CPU_TIME`, `BUFFER_GETS`, `DISK_READS`, `ROWS_PROCESSED`, `EXECUTIONS`, `CHILD_NUMBER`, `PLAN_HASH_VALUE`, `LAST_ACTIVE_TIME` 를 최소 세트로 자주 쓴다.

---

## 2. 기본 탐색과 Top-N 실전

### 2.1 텍스트로 특정 SQL 찾기(부분 일치)
```sql
SELECT sql_id, child_number, plan_hash_value, executions, buffer_gets, disk_reads,
       elapsed_time/1e6 elapsed_s, cpu_time/1e6 cpu_s, module
FROM   v$sql
WHERE  LOWER(sql_text) LIKE '%from orders%'
ORDER  BY elapsed_time DESC FETCH FIRST 10 ROWS ONLY;
```

### 2.2 Top Elapsed / CPU / Gets / Reads
```sql
-- 1) 누적 경과시간 상위
SELECT sql_id, child_number, executions,
       ROUND(elapsed_time/1e6,1) AS elapsed_s,
       ROUND(cpu_time/1e6,1)     AS cpu_s,
       buffer_gets, disk_reads, plan_hash_value
FROM   v$sql
ORDER  BY elapsed_time DESC
FETCH FIRST 20 ROWS ONLY;

-- 2) CPU 상위
SELECT sql_id, child_number, executions,
       ROUND(cpu_time/1e6,1) cpu_s, buffer_gets, plan_hash_value
FROM   v$sql
ORDER  BY cpu_time DESC
FETCH FIRST 20 ROWS ONLY;

-- 3) 논리읽기 상위
SELECT sql_id, child_number, buffer_gets, executions, plan_hash_value
FROM   v$sql
ORDER  BY buffer_gets DESC
FETCH FIRST 20 ROWS ONLY;

-- 4) 물리읽기 상위
SELECT sql_id, child_number, disk_reads, executions, plan_hash_value
FROM   v$sql
ORDER  BY disk_reads DESC
FETCH FIRST 20 ROWS ONLY;
```

### 2.3 평균 단가 보기(Elapsed/Exec, Gets/Row 등)
```sql
SELECT sql_id, child_number, executions,
       ROUND(elapsed_time/1e6 / NULLIF(executions,0),3) AS s_per_exec,
       ROUND(buffer_gets / NULLIF(rows_processed,0),1)  AS gets_per_row,
       plan_hash_value, last_active_time
FROM   v$sql
WHERE  executions >= 10
ORDER  BY s_per_exec DESC
FETCH FIRST 20 ROWS ONLY;
```

---

## 3. 실행계획 연결: `DBMS_XPLAN` & `V$SQL_PLAN`
### 3.1 Child 커서의 **실제 라인 통계**(마지막 실행 기준)
```sql
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(
    sql_id => :sql_id,
    child_number => :child,
    format => 'ALLSTATS LAST +PREDICATE +PROJECTION +PEEKED_BINDS +OUTLINE +NOTE'
  )
);
```
- `A-Rows/Starts/Time/TempSpc/Buffers` 로 **병목 라인** 식별  
- `+PEEKED_BINDS`: 바인드 피킹 값 확인(ACS/선택성 오판 진단)

### 3.2 `V$SQL_PLAN` 직접 보기
```sql
SELECT id, parent_id, operation, options, object_owner, object_name,
       cardinality, bytes, plan_hash_value
FROM   v$sql_plan
WHERE  sql_id=:sql_id AND child_number=:child
ORDER  BY id;
```

---

## 4. Child 폭증과 커서 공유 실패 진단

### 4.1 같은 SQL_ID의 Child 개수
```sql
SELECT sql_id, COUNT(*) AS children,
       SUM(executions) execs,
       SUM(elapsed_time)/1e6 elapsed_s
FROM   v$sql
GROUP  BY sql_id
HAVING COUNT(*) > 5
ORDER  BY children DESC FETCH FIRST 20 ROWS ONLY;
```

### 4.2 왜 Child가 분기되었나? — `V$SQL_SHARED_CURSOR`
```sql
SELECT child_address, reason
FROM   v$sql_shared_cursor
WHERE  sql_id=:sql_id AND child_number=:child
  AND  (reason IS NOT NULL AND reason <> 'N');
```
- 예) `BIND_MISMATCH`, `OPTIMIZER_MISMATCH`, `LANGUAGE_MISMATCH`, `AUTH_CHECK_MISMATCH`, `PURGED_CURSOR` …

### 4.3 바인드/리터럴 문제 탐지(리터럴 남발)
```sql
-- 리터럴 사용으로 Child 폭증이 심한 SQL 후보
SELECT sql_id, COUNT(*) children,
       MAX(is_bind_sensitive) bs, MAX(is_bind_aware) ba,
       LISTAGG(child_number, ',') WITHIN GROUP (ORDER BY child_number) child_list
FROM   v$sql
GROUP  BY sql_id
HAVING COUNT(*) > 10
ORDER  BY children DESC FETCH FIRST 20 ROWS ONLY;
```
**대응**:  
- **바인드 사용**(애플리케이션 쿼리 표준화)  
- 공유 기준 강화를 원하면 어쩔 수 없이 **FORCE_MATCHING_SIGNATURE** 기반(리터럴 치환적) 고려(주의: 부작용 가능)  
- `SESSION_CACHED_CURSORS` 조정(소프트 파싱 줄이기)

---

## 5. Adaptive Cursor Sharing(ACS) & 바인드 피킹

### 5.1 상태 확인
```sql
SELECT sql_id, child_number, is_bind_sensitive, is_bind_aware, is_shareable
FROM   v$sql
WHERE  sql_id = :sql_id
ORDER  BY child_number;
```

### 5.2 바인드 값에 따른 플랜 분기 시나리오
- 바인드 분포가 **스큐** → 옵티마이저가 바인드 값을 “피킹”하여 **플랜 결정**  
- ACS가 활성화되면 바인드 범위를 구간화하여 **여러 Child**로 최적 플랜을 유지  
**대응**:  
- 히스토그램 생성으로 **카디널리티 정확화**  
- 특정 범위만 커버하려면 **쿼리 구조/힌트**로 **플랜 고정**  
- 지나친 Child 폭증이면 바인드 설계/필터 순서를 재검토

---

## 6. 플랜 변동 감시(Plan Hash 기반)

### 6.1 동일 SQL_ID, Child별 플랜 라벨 비교
```sql
SELECT sql_id, child_number, plan_hash_value, executions,
       ROUND(elapsed_time/1e6,1) elapsed_s, last_active_time
FROM   v$sql
WHERE  sql_id = :sql_id
ORDER  BY last_active_time DESC;
```

### 6.2 최근 활동 SQL 중 “플랜 번쩍”
```sql
SELECT sql_id, COUNT(DISTINCT plan_hash_value) plans,
       SUM(executions) execs
FROM   v$sql
WHERE  last_active_time > SYSDATE - 1/24  -- 최근 1시간
GROUP  BY sql_id
HAVING COUNT(DISTINCT plan_hash_value) > 1
ORDER  BY plans DESC FETCH FIRST 30 ROWS ONLY;
```
**대응**: 통계/바인드/환경 변화를 점검, 필요시 **SQL Plan Baseline**, **Outline** 등으로 안정화.

---

## 7. 모듈/서비스/사용자 차원으로 국소화

```sql
-- 서비스/모듈별 Elapsed Top-N
SELECT service, module, sql_id,
       ROUND(SUM(elapsed_time)/1e6,1) elapsed_s, SUM(executions) execs
FROM  (
  SELECT NVL((SELECT name FROM v$active_services s WHERE s.service_hash=v$sql.service_hash),'N/A') service,
         module, sql_id, elapsed_time, executions
  FROM   v$sql
)
GROUP  BY service, module, sql_id
ORDER  BY elapsed_s DESC FETCH FIRST 20 ROWS ONLY;

-- 파싱 스키마 기준
SELECT parsing_schema_name, COUNT(*) sqls, SUM(executions) execs,
       ROUND(SUM(elapsed_time)/1e6,1) elapsed_s
FROM   v$sql
GROUP  BY parsing_schema_name
ORDER  BY elapsed_s DESC;
```

---

## 8. 메모리/로딩/에이징 관찰

```sql
-- Shared Pool 메모리 헤비 커서
SELECT sql_id, child_number, sharable_mem, persistent_mem, runtime_mem,
       plan_hash_value, executions
FROM   v$sql
ORDER  BY (sharable_mem + persistent_mem + runtime_mem) DESC
FETCH FIRST 20 ROWS ONLY;

-- 자주 로드되는(aging/flush) 커서
SELECT sql_id, child_number, loads, executions, last_active_time
FROM   v$sql
ORDER  BY loads DESC FETCH FIRST 20 ROWS ONLY;
```
- `LOADS` ↑: Shared Pool 압박/Fragmentation/커서 큰 경우/주기적 Flush 의심  
- 대응: **Shared Pool 튜닝**, 큰 PL/SQL/패키지 핀(pin) 고려, 커서 크기 절감(불필요 힌트/프로젝션 축소)

---

## 9. ASH와 교차: “누가 시간을 태우는가”

```sql
-- 최근 15분, V$SQL 상위 SQL의 ASH 기여
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '15' MINUTE; EXEC :t2 := SYSTIMESTAMP;

WITH top_sql AS (
  SELECT sql_id
  FROM   v$sql
  ORDER  BY elapsed_time DESC
  FETCH FIRST 20 ROWS ONLY
)
SELECT a.sql_id, a.wait_class, a.event, COUNT(*) samples
FROM   v$active_session_history a
JOIN   top_sql t ON t.sql_id=a.sql_id
WHERE  a.sample_time BETWEEN :t1 AND :t2
  AND  a.session_type='FOREGROUND'
GROUP  BY a.sql_id, a.wait_class, a.event
ORDER  BY samples DESC;
```
- **Top SQL ↔ Wait Class/Event** 연결 → 플랜 라인(§3)으로 최종 매핑

---

## 10. 유지/청소/텍스트

### 10.1 텍스트 조회(길이 주의)
```sql
SELECT sql_id, child_number,
       DBMS_LOB.SUBSTR(sql_fulltext, 4000, 1) AS sql_text
FROM   v$sql
WHERE  sql_id=:sql_id AND child_number=:child;
```
> `SQL_FULLTEXT`는 CLOB. UI/도구에서 일부만 보일 수 있다.

### 10.2 라이브러리 캐시 플러시(주의!)
```sql
-- 전 시스템 커서/오브젝트 플러시: 운영 중 주의 (광범위한 하드파싱 유발)
ALTER SYSTEM FLUSH SHARED_POOL;
```

---

## 11. 실전 시나리오

### 11.1 “평균은 정상인데 피크 때만 느림” — 특정 리포트 SQL
1) `V$SQL`에서 `ELAPSED_TIME` 상위 SQL 식별 → `SQL_ID` 확보  
2) `DBMS_XPLAN.DISPLAY_CURSOR('ALLSTATS LAST')`로 라인 통계 확인  
3) `ASH`로 피크 시간대 해당 SQL의 **Wait Class**가 `direct path read temp` 집중 확인  
4) 조치: **히스토그램** + **정렬 회피 인덱스** + **PGA 정책** 조정  
5) 결과: `V$SQL`의 `ELAPSED_TIME/EXECUTIONS` 평균 단가 하락, `ASH` Temp 이벤트 샘플 감소

### 11.2 “Child 폭증(수백개)” — 리터럴 남발
1) `V$SQL`에서 `COUNT(*) BY SQL_ID`로 Child 폭증 SQL 식별  
2) `V$SQL_SHARED_CURSOR`에서 `BIND_MISMATCH`/`OPTIMIZER_MISMATCH` 다수  
3) 조치: **바인드 변수 도입**, 앱 표준화, 필요시 `CURSOR_SHARING=FORCE`(임시 회피; 부작용 주의)  
4) 효과: Child 수 급감, `PARSE_CALLS`↓, `EXECUTIONS/PARSE` 비율↑

### 11.3 “플랜 출렁임” — 같은 SQL_ID, Plan Hash 다양
1) §6.2 쿼리로 **복수 Plan Hash** SQL 확인  
2) 바인드 스큐/통계 갱신 시점/Outline 영향 점검  
3) 조치: **SQL Plan Baseline**으로 안정, 통계 마이너/히스토그램 정비  
4) 효과: Plan 고정 → `V$SQL`에서 특정 Plan Hash만 남음, 성능 안정

---

## 12. 운영 자동화 스니펫(붙여 쓰기)

### 12.1 “지금 당장” 보고용 Top-N(다발)
```sql
-- Elapsed/CPU/Gets/Reads/Rows/Execs 종합 Top-N
WITH ranked AS (
  SELECT sql_id, child_number,
         elapsed_time, cpu_time, buffer_gets, disk_reads, rows_processed, executions,
         DENSE_RANK() OVER (ORDER BY elapsed_time DESC) r_elapsed,
         DENSE_RANK() OVER (ORDER BY cpu_time    DESC) r_cpu,
         DENSE_RANK() OVER (ORDER BY buffer_gets DESC) r_gets,
         DENSE_RANK() OVER (ORDER BY disk_reads  DESC) r_reads
  FROM   v$sql
)
SELECT *
FROM   ranked
WHERE  r_elapsed <= 10 OR r_cpu <= 10 OR r_gets <= 10 OR r_reads <= 10
ORDER  BY r_elapsed, r_cpu, r_gets, r_reads
FETCH FIRST 50 ROWS ONLY;
```

### 12.2 “비싼데 자주 도는” 후보
```sql
SELECT sql_id, child_number, executions,
       ROUND(elapsed_time/1e6 / NULLIF(executions,0),3) s_per_exec,
       plan_hash_value
FROM   v$sql
WHERE  executions >= 100
ORDER  BY s_per_exec DESC
FETCH FIRST 20 ROWS ONLY;
```

### 12.3 “최근 1시간 새로 튄 놈”
```sql
SELECT sql_id, plan_hash_value, last_active_time,
       ROUND(elapsed_time/1e6,2) elapsed_s, executions
FROM   v$sql
WHERE  last_active_time > SYSDATE - 1/24
ORDER  BY elapsed_time DESC
FETCH FIRST 30 ROWS ONLY;
```

---

## 13. 체크리스트(암기 카드)
1) **Top-N**: `ELAPSED/CPU/GETS/READS` 상위 SQL을 `V$SQL`에서 즉시 확보  
2) **라인**: `DISPLAY_CURSOR('ALLSTATS LAST')`로 병목 라인 확인  
3) **Child**: `CHILD_NUMBER`/`V$SQL_SHARED_CURSOR`로 공유 실패 원인 규명  
4) **바인드/ACS**: `IS_BIND_SENSITIVE`/`AWARE` 확인, 히스토그램/ACS/플랜 안정화  
5) **Plan 변동**: `PLAN_HASH_VALUE` 모니터(스냅샷/경보)  
6) **업무 차원**: `MODULE/ACTION/SERVICE`로 문제 범위 좁히기  
7) **교차**: `ASH`(타임라인/Wait), `SQL Monitor`(장수행), `AWR`(역사)와 **삼각 검증**

---

## 14. 수학(간단 지표 정의)
- **실행당 평균 소요시간**  
  $$ \text{sec/exec} = \frac{\text{ELAPSED\_TIME}}{\text{EXECUTIONS}} \div 10^6 $$
- **행당 논리읽기**  
  $$ \text{gets/row} = \frac{\text{BUFFER\_GETS}}{\max(1,\text{ROWS\_PROCESSED})} $$

---

## 15. 결론
- `V$SQL`은 **“지금 메모리에 살아 있는 Child 커서들의 성적표”** 이다.  
- 여기서 **Top-N → Child/Plan → 라인 통계**로 내려가고, **공유 실패 원인**을 `V$SQL_SHARED_CURSOR`로 확인하라.  
- **바인드/통계/플랜 안정화/인덱스/조인/정렬 회피**로 **평균 단가**를 낮추고, **플랜 변동**을 감시하라.  
- 마지막은 항상 **증거 3종**으로 닫는다: `V$SQL`(누적/현재) + **ASH**(타임라인/대기) + **XPLAN/Monitor**(라인).

> 한 줄 정리  
> **V$SQL = 핫 SQL 레이더.** 여기서 잡고, **라인에서 해체**하고, **정책(바인드/플랜/인덱스)** 으로 고정한다. 그게 튜닝의 골든 루프다.