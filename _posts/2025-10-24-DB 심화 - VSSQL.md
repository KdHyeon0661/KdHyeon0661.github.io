---
layout: post
title: DB 심화 - V$SQL
date: 2025-10-24 22:25:23 +0900
category: DB 심화
---
# Oracle `V$SQL` 동적 성능 뷰

## 개요: `V$SQL`의 역할과 위치

Oracle 데이터베이스에서 `V$SQL` 동적 성능 뷰는 현재 SGA(시스템 글로벌 영역)의 라이브러리 캐시에 상주하는 SQL 커서들의 실행 통계를 실시간으로 제공합니다. 이 뷰는 **Child 커서 단위**로 정보를 관리하며, 각 Child 커서는 동일한 SQL 텍스트를 공유하지만 실행 환경(바인드 변수 타입, 옵티마이저 설정 등)이 달라 분기된 실행 단위입니다.

`V$SQL`은 SQL 성능 튜닝의 시작점으로, 시스템에서 가장 많은 자원(시간, CPU, I/O)을 소비하는 SQL을 신속하게 식별하고, 커서 공유 효율성을 분석하며, 실행 계획 변동을 감시하는 데 필수적인 도구입니다.

### 관련 뷰 비교

- **`V$SQLAREA`**: SQL_ID별로 모든 Child 커서의 통계를 집계한 요약 뷰입니다. "문장 수준"의 종합 분석에 유용합니다.
- **`V$SQLSTATS`**: `V$SQL`과 유사한 정보를 제공하지만, 통계 업데이트 빈도가 낮아 성능 오버헤드가 적은 경량 버전입니다.
- **`V$SQL_PLAN`**: 특정 SQL 커서의 실행 계획 라인(row source) 정보를 저장합니다.
- **`V$SQL_SHARED_CURSOR`**: Child 커서가 분기된 구체적인 이유(바인드 불일치, 옵티마이저 설정 차이 등)를 상세한 플래그로 보여줍니다.
- **`V$SQL_MONITOR`**: 장시간 실행되거나 병렬 처리되는 SQL의 실시간 모니터링 정보를 제공합니다.
- **`DBA_HIST_SQLSTAT`**, **`DBA_HIST_SQLTEXT`**, **`DBA_HIST_SQLPLAN`**: AWR(Automatic Workload Repository)에 주기적으로 저장된 과거 SQL 통계, 텍스트, 실행 계획 정보입니다.

---

## `V$SQL`의 핵심 컬럼 심층 분석

`V$SQL` 뷰는 100개가 넘는 컬럼을 포함하고 있으나, 실무에서 가장 자주 사용되고 중요한 컬럼들을 중심으로 이해해야 합니다.

### 식별자 관련 컬럼

| 컬럼 | 설명 및 활용 |
| :--- | :--- |
| **`SQL_ID`** | SQL 텍스트를 해싱하여 생성된 고유 식별자입니다. 동일한 SQL 텍스트는 항상 동일한 `SQL_ID`를 가집니다. |
| **`CHILD_NUMBER`** | 동일한 `SQL_ID` 내에서 실행 환경 차이(바인드 변수 타입, NLS 설정 등)로 인해 생성된 Child 커서의 순차 번호입니다. |
| **`PLAN_HASH_VALUE`** | 실행 계획을 요약한 해시 값입니다. 이 값이 동일하면 실행 계획이 동일함을 의미하므로, 계획 변동 감시에 필수적입니다. |
| **`CHILD_ADDRESS`**, **`ADDRESS`** | 커서의 메모리 주소로, `V$SQL_PLAN`, `V$SQL_BIND_CAPTURE` 등 다른 동적 뷰와 조인할 때 사용하는 키입니다. |

### 실행 통계 컬럼

| 컬럼 | 설명 및 활용 |
| :--- | :--- |
| **`EXECUTIONS`** | 해당 Child 커서가 실행된 총 횟수입니다. |
| **`PARSE_CALLS`** | 파싱이 호출된 총 횟수(하드 파싱과 소프트 파싱 모두 포함)입니다. |
| **`LOADS`** | 라이브러리 캐시에 해당 커서가 적재된 횟수입니다. 에이징(aging out) 후 재적재 시 증가합니다. |
| **`ELAPSED_TIME`**, **`CPU_TIME`** | 각각 마이크로초 단위의 총 경과 시간과 CPU 시간입니다. `ELAPSED_TIME`은 대기 시간을 포함합니다. |
| **`BUFFER_GETS`**, **`DISK_READS`**, **`DIRECT_WRITES`** | 각각 논리적 읽기, 물리적 읽기, 직접 쓰기(Direct Path Write)의 총 횟수입니다. I/O 패턴 분석의 핵심입니다. |
| **`ROWS_PROCESSED`** | 처리된 총 행 수입니다. `SELECT` 문의 경우 페치된 행 수, DML 문의 경우 영향을 받은 행 수입니다. |

### 메모리 및 상태 컬럼

| 컬럼 | 설명 및 활용 |
| :--- | :--- |
| **`SHARABLE_MEM`**, **`PERSISTENT_MEM`**, **`RUNTIME_MEM`** | 커서가 사용하는 라이브러리 캐시 메모리, UGA 지속 메모리, 런타임 메모리의 양(바이트)입니다. |
| **`IS_BIND_SENSITIVE`**, **`IS_BIND_AWARE`** | Adaptive Cursor Sharing(ACS) 관련 플래그입니다. 각각 바인드 값에 민감한지, 바인드 값을 인지하여 최적화되었는지를 나타냅니다. |
| **`IS_OBSOLETE`**, **`INVALIDATIONS`** | 커서가 더 이상 공유 가능하지 않은지(무효화), 무효화된 횟수를 나타냅니다. DDL 또는 통계 갱신 시 증가합니다. |

### 메타데이터 컬럼

| 컬럼 | 설명 및 활용 |
| :--- | :--- |
| **`MODULE`**, **`ACTION`**, **`PARSING_SCHEMA_NAME`** | `DBMS_APPLICATION_INFO`로 설정된 애플리케이션 모듈/액션 정보와 SQL을 파싱한 스키마 이름입니다. 업무 차원 분석에 사용됩니다. |
| **`FIRST_LOAD_TIME`**, **`LAST_ACTIVE_TIME`** | 커서가 처음 라이브러리 캐시에 적재된 시간과 마지막으로 활성화된 시간입니다. 커서 노화 분석에 사용됩니다. |
| **`OPTIMIZER_COST`**, **`OPTIMIZER_ENV_HASH_VALUE`** | 옵티마이저가 계산한 비용과 옵티마이저 환경(세션 파라미터 등)의 해시 값입니다. |

> **실무 팁**: 성능 분석 시 가장 먼저 보아야 할 컬럼 조합은 `SQL_ID`, `CHILD_NUMBER`, `PLAN_HASH_VALUE`, `EXECUTIONS`, `ELAPSED_TIME`, `CPU_TIME`, `BUFFER_GETS`, `DISK_READS`, `ROWS_PROCESSED`, `LAST_ACTIVE_TIME`입니다.

---

## 기본 탐색 및 Top-N 성능 문제 식별

### SQL 텍스트로 특정 쿼리 검색

```sql
-- 'orders' 테이블을 참조하는 SQL 찾기 (대소문자 구분 없이 부분 일치)
SELECT 
    sql_id, 
    child_number, 
    plan_hash_value, 
    executions,
    ROUND(elapsed_time / 1e6, 2) AS elapsed_seconds,
    ROUND(cpu_time / 1e6, 2) AS cpu_seconds,
    buffer_gets,
    disk_reads,
    module,
    last_active_time
FROM v$sql
WHERE LOWER(sql_text) LIKE '%from orders%'
ORDER BY elapsed_time DESC
FETCH FIRST 10 ROWS ONLY;
```

### 시스템 리소스 소비 Top-N SQL 식별

```sql
-- 1. 총 경과 시간(Elapsed Time) 상위 SQL
SELECT 
    sql_id, 
    child_number, 
    executions,
    ROUND(elapsed_time / 1e6, 2) AS total_elapsed_sec,
    ROUND(cpu_time / 1e6, 2) AS total_cpu_sec,
    ROUND(elapsed_time / 1e6 / NULLIF(executions, 0), 4) AS avg_elapsed_per_exec,
    buffer_gets,
    disk_reads,
    plan_hash_value,
    last_active_time
FROM v$sql
ORDER BY elapsed_time DESC
FETCH FIRST 15 ROWS ONLY;

-- 2. CPU 시간 상위 SQL
SELECT 
    sql_id, 
    child_number, 
    executions,
    ROUND(cpu_time / 1e6, 2) AS total_cpu_sec,
    ROUND(cpu_time / 1e6 / NULLIF(executions, 0), 4) AS avg_cpu_per_exec,
    buffer_gets,
    plan_hash_value
FROM v$sql
ORDER BY cpu_time DESC
FETCH FIRST 15 ROWS ONLY;

-- 3. 논리적 읽기(Buffer Gets) 상위 SQL (캐시 효율성 분석)
SELECT 
    sql_id, 
    child_number, 
    buffer_gets,
    executions,
    ROUND(buffer_gets / NULLIF(executions, 0), 1) AS avg_gets_per_exec,
    ROUND(buffer_gets / NULLIF(rows_processed, 0), 1) AS avg_gets_per_row,
    plan_hash_value
FROM v$sql
WHERE executions > 0
ORDER BY buffer_gets DESC
FETCH FIRST 15 ROWS ONLY;

-- 4. 물리적 읽기(Disk Reads) 상위 SQL (I/O 병목 분석)
SELECT 
    sql_id, 
    child_number, 
    disk_reads,
    executions,
    ROUND(disk_reads / NULLIF(executions, 0), 1) AS avg_reads_per_exec,
    plan_hash_value
FROM v$sql
ORDER BY disk_reads DESC
FETCH FIRST 15 ROWS ONLY;
```

### 효율성 지표 분석: "단가"가 높은 SQL 찾기

```sql
-- 실행당 평균 비용이 높은 SQL (효율성이 낮은 SQL)
SELECT 
    sql_id,
    child_number,
    executions,
    ROUND(elapsed_time / 1e6 / NULLIF(executions, 0), 3) AS seconds_per_execution,
    ROUND(buffer_gets / NULLIF(executions, 0), 1) AS buffer_gets_per_execution,
    ROUND(buffer_gets / NULLIF(rows_processed, 0), 1) AS buffer_gets_per_row,
    plan_hash_value,
    last_active_time
FROM v$sql
WHERE executions >= 10  -- 최소 10번 이상 실행된 SQL만 분석
ORDER BY seconds_per_execution DESC
FETCH FIRST 20 ROWS ONLY;
```

---

## 실행 계획 분석과의 연계

### `DBMS_XPLAN`을 이용한 Child 커서의 상세 실행 계획 조회

`V$SQL`에서 식별한 문제 SQL의 `SQL_ID`와 `CHILD_NUMBER`를 사용하여 실제 실행 계획과 라인별 통계를 확인할 수 있습니다.

```sql
-- :sql_id와 :child_number 변수에 값을 바인딩한 후 실행
SELECT * FROM TABLE(
    DBMS_XPLAN.DISPLAY_CURSOR(
        sql_id        => :sql_id,          -- V$SQL에서 확인한 SQL_ID
        cursor_child_no => :child_number,  -- V$SQL에서 확인한 CHILD_NUMBER
        format        => 'ALLSTATS LAST +PREDICATE +PROJECTION +PEEKED_BINDS +OUTLINE +NOTE'
    )
);
```

**출력 옵션 설명**:
- **`ALLSTATS LAST`**: 마지막 실행의 라인별 실제 통계(`A-Rows`, `Starts`, `A-Time`, `Buffers` 등)를 표시합니다.
- **`+PEEKED_BINDS`**: 바인드 변수 피킹(Bind Peeking) 시 사용된 실제 값을 보여줍니다.
- **`+PREDICATE`**: 접근(Access)과 필터(Filter) 조건을 상세히 표시합니다.
- **`+OUTLINE`**: 실행 계획을 재현할 수 있는 힌트 세트를 보여줍니다.
- **`+NOTE`**: 옵티마이저의 결정 사항과 관련 메시지를 표시합니다.

### `V$SQL_PLAN`을 직접 조회

```sql
-- 특정 SQL Child 커서의 실행 계획 라인 보기
SELECT 
    id,
    parent_id,
    LPAD(' ', depth * 2) || operation || ' ' || options AS operation,
    object_owner,
    object_name,
    cardinality,
    bytes,
    cost,
    time
FROM v$sql_plan
WHERE sql_id = :sql_id 
  AND child_number = :child_number
ORDER BY id;
```

---

## 커서 공유 문제와 Child 폭증 진단

### Child 커서 개수로 공유 효율성 분석

```sql
-- Child 커서가 과도하게 많은 SQL 식별 (공유 효율성 낮음)
SELECT 
    sql_id,
    COUNT(*) AS child_count,
    SUM(executions) AS total_executions,
    ROUND(SUM(elapsed_time) / 1e6, 2) AS total_elapsed_sec,
    MIN(first_load_time) AS first_seen,
    MAX(last_active_time) AS last_seen
FROM v$sql
GROUP BY sql_id
HAVING COUNT(*) > 5  -- Child가 5개 이상인 SQL
ORDER BY child_count DESC
FETCH FIRST 20 ROWS ONLY;
```

### `V$SQL_SHARED_CURSOR`를 이용한 분기 원인 분석

Child 커서가 분기된 구체적인 이유를 진단할 때 사용합니다.

```sql
-- 특정 SQL_ID의 Child 커서들이 왜 분기되었는지 상세 원인 조회
SELECT 
    child_number,
    -- 주요 분기 원인 플래그들
    bind_mismatch,
    optimizer_mismatch,
    translation_mismatch,
    row_level_sec_mismatch,
    insuff_privileges,
    bind_awareness_mismatch,
    purge_cursor_mismatch
FROM v$sql_shared_cursor
WHERE sql_id = :sql_id
ORDER BY child_number;
```

**주요 분기 원인**:
- **`BIND_MISMATCH`**: 바인드 변수의 데이터 타입 또는 길이가 일치하지 않음.
- **`OPTIMIZER_MISMATCH`**: 옵티마이저 관련 파라미터(예: `OPTIMIZER_MODE`)가 다름.
- **`TRANSLATION_MISMATCH`**: SQL 변환(Translation) 관련 설정 차이.
- **`LANGUAGE_MISMATCH`**: NLS(국가 언어 지원) 설정이 다름.

### 리터럴 SQL과 바인드 변수 사용 분석

```sql
-- 리터럴 값 사용으로 인한 Child 폭증이 의심되는 SQL 분석
SELECT 
    sql_id,
    COUNT(DISTINCT child_number) AS child_count,
    MAX(is_bind_sensitive) AS bind_sensitive,
    MAX(is_bind_aware) AS bind_aware,
    SUM(executions) AS total_executions,
    LISTAGG(child_number, ',') WITHIN GROUP (ORDER BY child_number) AS child_list
FROM v$sql
GROUP BY sql_id
HAVING COUNT(DISTINCT child_number) > 8  -- Child가 8개 이상
ORDER BY child_count DESC
FETCH FIRST 15 ROWS ONLY;
```

**대응 방안**:
1. **애플리케이션 수정**: 리터럴 값을 바인드 변수로 전환합니다.
2. **세션 설정**: `CURSOR_SHARING = FORCE` 파라미터를 설정하여 리터럴을 시스템 생성 바인드로 대체합니다(주의: 실행 계획 변경 리스크 있음).
3. **커서 캐시**: `SESSION_CACHED_CURSORS` 파라미터 값을 적절히 증가시켜 세션 내 커서 재사용을 촉진합니다.

---

## Adaptive Cursor Sharing(ACS)와 바인드 변수 피킹 분석

### ACS 상태 확인

```sql
-- 특정 SQL의 ACS 관련 상태 확인
SELECT 
    sql_id,
    child_number,
    is_bind_sensitive,  -- Y: 바인드 값에 민감함(처음 하드 파싱 시 피킹 발생)
    is_bind_aware,      -- Y: 바인드 값을 인지하여 최적화됨(ACS 활성화)
    is_shareable,       -- Y: 공유 가능 상태
    executions,
    plan_hash_value
FROM v$sql
WHERE sql_id = :sql_id
ORDER BY child_number;
```

### 바인드 값 캡처 확인

```sql
-- 특정 SQL Child 커서에서 캡처된 바인드 값 확인
SELECT 
    child_number,
    position,
    datatype,
    value_string,
    max_length,
    was_captured
FROM v$sql_bind_capture
WHERE sql_id = :sql_id
ORDER BY child_number, position;
```

**ACS 동작 이해와 대응**:
1. **동작 메커니즘**: 옵티마이저가 처음 SQL을 하드 파싱할 때 바인드 변수의 실제 값을 "엿보고" 이를 기반으로 실행 계획을 생성합니다(`IS_BIND_SENSITIVE = 'Y'`). 이후 다양한 값으로 실행되면서, Oracle은 값의 분포(선택도)를 학습하고 서로 다른 최적 계획을 가진 Child 커서를 생성합니다(`IS_BIND_AWARE = 'Y'`).
2. **문제점**: 지나치게 많은 Child 커서가 생성되면 라이브러리 캐시 메모리를 낭비하고 관리 부하를 증가시킬 수 있습니다.
3. **대응 방안**:
    - 컬럼 **히스토그램 통계**를 적절히 관리하여 옵티마이저의 선택도 추정을 정확하게 합니다.
    - 매우 중요한 SQL의 경우 **SQL Plan Baseline**을 적용하여 안정적인 실행 계획을 유지합니다.
    - 바인드 변수의 데이터 타입과 길이를 애플리케이션 전반에 걸쳐 일관되게 유지합니다.

---

## 실행 계획 변동 감시 및 안정화

### 동일 SQL 내 Plan Hash 변동 확인

```sql
-- 특정 SQL_ID의 Child 커서별 실행 계획 비교
SELECT 
    sql_id,
    child_number,
    plan_hash_value,
    executions,
    ROUND(elapsed_time / 1e6, 2) AS elapsed_seconds,
    last_active_time
FROM v$sql
WHERE sql_id = :sql_id
ORDER BY last_active_time DESC;
```

### 최근 활동 중 Plan이 변경된 SQL 식별

```sql
-- 최근 1시간 동안 실행되었으며, 여러 Plan Hash를 가진 SQL 찾기
SELECT 
    sql_id,
    COUNT(DISTINCT plan_hash_value) AS distinct_plans,
    SUM(executions) AS total_executions,
    MIN(first_load_time) AS first_seen,
    MAX(last_active_time) AS last_seen
FROM v$sql
WHERE last_active_time > SYSDATE - INTERVAL '1' HOUR
GROUP BY sql_id
HAVING COUNT(DISTINCT plan_hash_value) > 1
ORDER BY distinct_plans DESC, total_executions DESC
FETCH FIRST 20 ROWS ONLY;
```

**계획 변동 대응 전략**:
1. **원인 분석**: 통계 갱신 시점, 바인드 값 피킹 변화, 세션/시스템 파라미터 변경 등을 점검합니다.
2. **안정화 수단**:
    - **SQL Plan Baseline**: 검증된 최적의 실행 계획을 고정합니다.
    - **SQL Profile**: 옵티마이저에게 추가적인 통계 정보를 제공합니다.
    - **Stored Outline**: 레거시 호환성을 위한 방법입니다(현재는 Baseline을 권장).
3. **모니터링**: 주요 비즈니스 SQL에 대해 Plan Hash 변동을 정기적으로 모니터링하고 알람을 설정합니다.

---

## 업무 차원 분석: 모듈, 서비스, 사용자별 집계

### 애플리케이션 모듈별 성능 분석

```sql
-- 모듈(Module)별 리소스 소비 Top-N 분석
SELECT 
    module,
    COUNT(DISTINCT sql_id) AS unique_sql_count,
    SUM(executions) AS total_executions,
    ROUND(SUM(elapsed_time) / 1e6, 2) AS total_elapsed_sec,
    ROUND(SUM(cpu_time) / 1e6, 2) AS total_cpu_sec,
    SUM(buffer_gets) AS total_buffer_gets,
    SUM(disk_reads) AS total_disk_reads
FROM v$sql
WHERE module IS NOT NULL
  AND module NOT LIKE 'oracle%'  -- Oracle 내부 모듈 제외
GROUP BY module
ORDER BY total_elapsed_sec DESC
FETCH FIRST 15 ROWS ONLY;
```

### 데이터베이스 서비스별 집계

```sql
-- 데이터베이스 서비스별 SQL 활동 분석
SELECT 
    NVL(s.name, 'DEFAULT') AS service_name,
    COUNT(*) AS cursor_count,
    SUM(v.executions) AS total_executions,
    ROUND(SUM(v.elapsed_time) / 1e6, 2) AS total_elapsed_sec
FROM v$sql v
LEFT JOIN v$active_services s ON v.service_hash = s.service_hash
GROUP BY s.name
ORDER BY total_elapsed_sec DESC;
```

### 파싱 스키마(사용자)별 분석

```sql
-- 사용자별 SQL 활동 분석
SELECT 
    parsing_schema_name,
    COUNT(*) AS sql_count,
    SUM(executions) AS total_executions,
    ROUND(SUM(elapsed_time) / 1e6, 2) AS total_elapsed_sec,
    ROUND(AVG(elapsed_time / 1e6 / NULLIF(executions, 0)), 4) AS avg_sec_per_exec
FROM v$sql
WHERE parsing_schema_name IS NOT NULL
GROUP BY parsing_schema_name
ORDER BY total_elapsed_sec DESC;
```

---

## 메모리 사용량 및 라이프사이클 분석

### 라이브러리 캐시 메모리 점유 Top 커서

```sql
-- Shared Pool 메모리를 가장 많이 사용하는 커서 식별
SELECT 
    sql_id,
    child_number,
    ROUND((sharable_mem + persistent_mem + runtime_mem) / 1024 / 1024, 2) AS total_mb,
    ROUND(sharable_mem / 1024 / 1024, 2) AS sharable_mb,
    ROUND(persistent_mem / 1024 / 1024, 2) AS persistent_mb,
    ROUND(runtime_mem / 1024 / 1024, 2) AS runtime_mb,
    executions,
    loads,
    last_active_time
FROM v$sql
ORDER BY (sharable_mem + persistent_mem + runtime_mem) DESC
FETCH FIRST 20 ROWS ONLY;
```

### 자주 재적재되는 커서 분석

```sql
-- 라이브러리 캐시에서 자주 에이징되어 재적재(LOAD)되는 커서 식별
SELECT 
    sql_id,
    child_number,
    loads,
    executions,
    ROUND((sharable_mem + persistent_mem) / 1024, 2) AS mem_kb,
    first_load_time,
    last_active_time
FROM v$sql
WHERE loads > 1  -- 1번 이상 재적재된 커서
ORDER BY loads DESC, executions DESC
FETCH FIRST 20 ROWS ONLY;
```

**높은 LOADS 값의 의미와 대응**:
- **의미**: Shared Pool 메모리 압박, 커서 크기가 너무 큼, 주기적인 Flush 발생 가능성을 시사합니다.
- **대응**:
    1. **Shared Pool 크기 조정**: `SHARED_POOL_SIZE` 파라미터를 적절히 증가시킵니다.
    2. **큰 객체 핀 고정**: 자주 사용되는 대형 PL/SQL 패키지는 `DBMS_SHARED_POOL.KEEP`으로 고정합니다.
    3. **커서 크기 최적화**: 불필요한 힌트나 컬럼 프로젝션을 제거합니다.

---

## 통합 분석: `V$SQL`과 `V$ACTIVE_SESSION_HISTORY` 연계

`V$SQL`은 누적 통계를, `ASH`는 실시간 샘플링 데이터를 제공합니다. 둘을 결합하면 시간대별 상세 분석이 가능합니다.

```sql
-- 최근 30분 동안 V$SQL 상위 SQL들의 ASH 대기 프로파일 분석
VARIABLE begin_time VARCHAR2(30);
VARIABLE end_time VARCHAR2(30);

BEGIN
    :begin_time := TO_CHAR(SYSDATE - INTERVAL '30' MINUTE, 'YYYY-MM-DD HH24:MI:SS');
    :end_time := TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS');
END;
/

WITH top_sql AS (
    -- 최근 30분 동안 누적 경과 시간 상위 20개 SQL
    SELECT sql_id
    FROM v$sql
    WHERE last_active_time >= SYSDATE - INTERVAL '30' MINUTE
    ORDER BY elapsed_time DESC
    FETCH FIRST 20 ROWS ONLY
)
SELECT 
    a.sql_id,
    a.wait_class,
    a.event,
    COUNT(*) AS ash_sample_count,
    ROUND(COUNT(*) * 10 / 60, 2) AS approx_minutes  -- ASH는 1초에 1회 샘플링
FROM v$active_session_history a
JOIN top_sql t ON a.sql_id = t.sql_id
WHERE a.sample_time >= SYSDATE - INTERVAL '30' MINUTE
  AND a.session_type = 'FOREGROUND'
GROUP BY a.sql_id, a.wait_class, a.event
ORDER BY ash_sample_count DESC;
```

이 분석을 통해, "어떤 SQL이(`V$SQL`)", "어떤 대기 이벤트에서(`ASH`)" 시간을 보냈는지를 연관지어 파악할 수 있습니다. 예를 들어, 특정 SQL의 대기 이벤트가 `direct path read temp`로 집중된다면, 이는 임시 세그먼트 I/O와 관련된 정렬 또는 해시 조인 작업이 병목임을 시사합니다.

---

## 실전 문제 해결 시나리오

### 시나리오 1: 배치 리포트 성능 저하

**증상**: 월말 배치 리포트 실행 시간이 점점 증가하고 있습니다.
**진단 단계**:
1.  `V$SQL`에서 최근 24시간 동안 `ELAPSED_TIME` 상위 SQL을 식별합니다.
2.  해당 SQL의 `DISK_READS`와 `BUFFER_GETS` 비율을 확인하여 I/O 패턴을 분석합니다.
3.  `DBMS_XPLAN.DISPLAY_CURSOR`로 실행 계획을 확인했을 때, `SORT` 또는 `HASH JOIN` 연산에서 `TempSpc` 사용이 많은 것을 발견합니다.
4.  `V$ACTIVE_SESSION_HISTORY`에서 해당 SQL이 `direct path read temp` 대기 이벤트에서 대부분의 시간을 소비함을 확인합니다.
**해결**: 관련 테이블 컬럼에 히스토그램 통계를 생성하고, 정렬을 회피할 수 있는 인덱스를 추가하며, `PGA_AGGREGATE_TARGET`을 조정합니다. 개선 후 `V$SQL`의 `ELAPSED_TIME/EXECUTIONS` 평균 단가 하락으로 효과를 검증합니다.

### 시나리오 2: OLTP 시스템의 예기치 않은 지연

**증상**: 피크 시간대에 특정 트랜잭션의 응답 시간이 불규칙하게 증가합니다.
**진단 단계**:
1.  `V$SQL`에서 해당 모듈(`MODULE`)의 SQL을 필터링하고, `ELAPSED_TIME` 대비 `EXECUTIONS` 비율(실행당 평균 시간)이 높은 SQL을 찾습니다.
2.  해당 SQL을 여러 `CHILD_NUMBER`로 확인하고, `V$SQL_SHARED_CURSOR`에서 `BIND_MISMATCH`가 다수 발견됩니다.
3.  애플리케이션 로그를 확인해보니, 해당 기능에서 문자열 길이가 가변적인 바인드 변수를 사용하고 있습니다.
**해결**: 애플리케이션 코드를 수정하여 바인드 변수의 최대 길이를 고정하고, 데이터 타입을 일관되게 유지합니다. 변경 후 `V$SQL`에서 `CHILD_NUMBER` 개수가 현저히 감소하고 `PARSE_CALLS/EXECUTIONS` 비율이 개선됩니다.

### 시나리오 3: 실행 계획의 불안정성

**증상**: 동일한 쿼리의 성능이 때때로 현저히 저하됩니다.
**진단 단계**:
1.  `V$SQL`에서 문제의 `SQL_ID`를 조회하여 여러 `PLAN_HASH_VALUE`를 가진 `CHILD_NUMBER`들이 있음을 확인합니다.
2.  각 Child 커서의 `LAST_ACTIVE_TIME`과 `OPTIMIZER_ENV_HASH_VALUE`를 비교하여, 특정 세션 설정 변경 시점과 계획 변동 시점이 일치함을 발견합니다.
3.  `V$SQL_BIND_CAPTURE`를 확인하여, 서로 다른 바인드 값 피킹이 서로 다른 실행 계획으로 이어진 것을 확인합니다.
**해결**: 통계의 신선도를 유지하고, 바인드 값의 분포를 대표할 수 있는 히스토그램을 관리합니다. 최종적으로 검증된 최적의 실행 계획을 **SQL Plan Baseline**으로 등록하여 안정성을 확보합니다.

---

## 운영 자동화를 위한 유용한 스크립트

### 종합 Top-N 리포팅 스크립트

```sql
-- 경과 시간, CPU, 논리 읽기, 물리 읽기 각각의 상위 SQL을 하나의 리포트로 통합
WITH ranked_sql AS (
    SELECT 
        sql_id,
        child_number,
        executions,
        elapsed_time,
        cpu_time,
        buffer_gets,
        disk_reads,
        rows_processed,
        plan_hash_value,
        last_active_time,
        -- 각 지표별 순위 부여
        DENSE_RANK() OVER (ORDER BY elapsed_time DESC) AS rnk_elapsed,
        DENSE_RANK() OVER (ORDER BY cpu_time DESC) AS rnk_cpu,
        DENSE_RANK() OVER (ORDER BY buffer_gets DESC) AS rnk_gets,
        DENSE_RANK() OVER (ORDER BY disk_reads DESC) AS rnk_reads
    FROM v$sql
    WHERE last_active_time > SYSDATE - INTERVAL '1' HOUR  -- 최근 1시간 활동 기준
)
SELECT 
    sql_id,
    child_number,
    plan_hash_value,
    executions,
    ROUND(elapsed_time / 1e6, 3) AS elapsed_sec,
    ROUND(cpu_time / 1e6, 3) AS cpu_sec,
    buffer_gets,
    disk_reads,
    rnk_elapsed,
    rnk_cpu,
    rnk_gets,
    rnk_reads,
    last_active_time
FROM ranked_sql
WHERE rnk_elapsed <= 10 
   OR rnk_cpu <= 10 
   OR rnk_gets <= 10 
   OR rnk_reads <= 10
ORDER BY rnk_elapsed, rnk_cpu, rnk_gets, rnk_reads;
```

### 최근에 부하를 유발하기 시작한 SQL 탐지

```sql
-- 지난 1시간 동안 새로 나타나거나 활동이 급증한 SQL 탐지
SELECT 
    sql_id,
    child_number,
    plan_hash_value,
    executions,
    ROUND(elapsed_time / 1e6, 2) AS elapsed_sec,
    buffer_gets,
    disk_reads,
    last_active_time,
    first_load_time
FROM v$sql
WHERE last_active_time > SYSDATE - INTERVAL '1' HOUR  -- 최근 1시간 내 활동
  AND first_load_time > SYSDATE - INTERVAL '2' HOUR   -- 최근 2시간 내 처음 로드
ORDER BY elapsed_time DESC
FETCH FIRST 20 ROWS ONLY;
```

---

## 결론

Oracle `V$SQL` 동적 성능 뷰는 데이터베이스 성능 튜닝의 핵심 출발점입니다. 이 뷰를 효과적으로 활용하기 위한 체계적인 접근법을 요약하면 다음과 같습니다.

1.  **문제 SQL의 신속한 식별**: `ELAPSED_TIME`, `CPU_TIME`, `BUFFER_GETS`, `DISK_READS` 등의 컬럼을 기준으로 시스템 리소스를 가장 많이 소비하는 **Top-N SQL**을 빠르게 찾아냅니다.

2.  **심층 원인 분석**: 식별된 SQL에 대해 `CHILD_NUMBER`와 `V$SQL_SHARED_CURSOR`를 분석하여 커서 공유 실패 원인을 규명합니다. 리터럴 남발, 바인드 변수 불일치, 옵티마이저 설정 차이 등이 주요 원인입니다.

3.  **실행 계획 검증**: `DBMS_XPLAN.DISPLAY_CURSOR`의 `ALLSTATS` 옵션을 활용하여 **실제 실행 통계가 포함된 상세 계획**을 분석합니다. `A-Rows` vs `E-Rows` 비교, `TempSpc` 사용량, 라인별 `A-Time` 등을 통해 병목 지점을 정확히 파악합니다.

4.  **변화 모니터링**: `PLAN_HASH_VALUE`를 통해 실행 계획의 안정성을 감시합니다. 예기치 않은 계획 변동은 성능 저하로 이어질 수 있으므로, `SQL Plan Baseline` 등의 메커니즘으로 안정화합니다.

5.  **통합 관점 확보**: `V$SQL`의 누적 데이터와 `V$ACTIVE_SESSION_HISTORY`의 실시간 샘플 데이터를 연계하여, SQL이 어떤 대기 이벤트에서 시간을 보내는지에 대한 **시간대별 상관관계**를 분석합니다.

궁극적으로 `V$SQL`은 성능 문제의 "증상"을 보여주는 지표입니다. 이 지표에서 출발하여, 실행 계획 분석, 커서 공유 메커니즘 이해, 바인드 변수 관리, 인덱스 설계, 통계 관리 등의 종합적인 접근을 통해 "근본 원인"을 해결해야 지속 가능한 성능 개선이 가능합니다. `V$SQL`을 단순한 모니터링 도구가 아닌, 지속적인 성능 최적화 사이클의 시작점으로 삼을 때, 데이터베이스 시스템의 안정성과 효율성을 한 단계 높일 수 있습니다.