---
layout: post
title: AWS - 비용 예측 및 절감 팁
date: 2025-08-08 14:20:23 +0900
category: AWS
---
# 비용 예측 및 절감 팁

## 빠른 로드맵

1) **가시화**: CUR + Athena/QuickSight, Cost Explorer, Budgets, Anomaly Detection
2) **예측**: 계절성·캠페인·릴리즈 캘린더 반영 + 단기/중기 Forecast
3) **절감 레버**: 스팟(비핵심), Savings Plans/RI(상시부하), 오토스케일·스케줄러(가변부하), 스토리지/네트워크/DB 최적화
4) **자동화**: 예산 경보→티켓/챗알림, 유휴자원 정리, 태그·정책 강제, 정례 리뷰

---

## 비용 **추적** — 데이터부터 곧바로 쌓자

### → Athena/QuickSight

- S3 버킷에 **시간별/서비스별/태그별** 청구 라인아이템 저장
- Glue Crawler로 테이블 생성 후 Athena로 질의

**Athena DDL 예시 (이미 Crawler가 생성했다 가정)**
```sql
-- 일별 서비스/계정/태그별 비용 합계
SELECT
  DATE(from_iso8601_timestamp(line_item_usage_start_date)) AS usage_date,
  line_item_product_code      AS service,
  bill_payer_account_id       AS payer,
  resource_tags_user_costcenter AS cost_center,
  SUM(CAST(line_item_unblended_cost AS DOUBLE)) AS unblended_cost
FROM "aws_cur_db"."cur_line_items"
WHERE year=2025 AND month=11
GROUP BY 1,2,3,4
ORDER BY 1,2;
```

### Cost Explorer API로 빠른 피벗 (boto3)

```python
import boto3, datetime
ce = boto3.client('ce', region_name='us-east-1')

res = ce.get_cost_and_usage(
    TimePeriod={'Start':'2025-11-01','End':'2025-12-01'},
    Granularity='DAILY',
    Metrics=['UnblendedCost','UsageQuantity'],
    GroupBy=[{'Type':'DIMENSION','Key':'SERVICE'},
             {'Type':'TAG','Key':'CostCenter'}]
)
for day in res['ResultsByTime']:
    print(day['TimePeriod'], day['Groups'][:3])  # 샘플 출력
```

### 예산/경보 — 초과 전에 붙잡는다

```bash
# 월간 1000 USD 초과 시 이메일 알림

aws budgets create-budget --account-id 123456789012 --budget '{
  "BudgetName":"Monthly-1000",
  "BudgetLimit":{"Amount":"1000","Unit":"USD"},
  "TimeUnit":"MONTHLY","BudgetType":"COST"
}' --notifications-with-subscribers '[
  {"Notification":{"NotificationType":"FORECASTED","ComparisonOperator":"GREATER_THAN","Threshold":100,"ThresholdType":"PERCENTAGE"},
   "Subscribers":[{"SubscriptionType":"EMAIL","Address":"finops@example.com"}]}
]'
```

### Cost Anomaly Detection — 갑툭튀 제어

```bash
# 서비스 단위 이상징후 탐지

aws ce create-anomaly-monitor --anomaly-monitor \
'{"MonitorName":"ServiceMonitor","MonitorType":"DIMENSIONAL","MonitorDimension":"SERVICE"}'

# 이상징후 알림 구독

aws ce create-anomaly-subscription --anomaly-subscription '{
  "SubscriptionName":"CostSpikeAlert",
  "Frequency":"DAILY",
  "MonitorArnList":["arn:aws:ce:...:anomalymonitor/xxxxxxxx"],
  "Subscribers":[{"Type":"EMAIL","Address":"finops@example.com"}],
  "ThresholdExpression":{"ThresholdType":"ABSOLUTE","Value":50.0}
}'
```

---

## 비용 **예측** — “경향 + 이벤트”를 함께 본다

### 기본 수식(개념)

- **단기 추세선**:
  $$ \hat{C}_{t+1} = \alpha C_t + (1-\alpha)\hat{C}_t, \quad 0<\alpha<1 $$
- **계절 조정**(예: 주간/월간 패턴 계수 \(s_d\))
  $$ \hat{C}_{t+1}^{(adj)} = \hat{C}_{t+1} \times s_{d(t+1)} $$
- **캠페인/릴리즈 이벤트 가산**:
  $$ \hat{C}_{t+1}^{(final)} = \hat{C}_{t+1}^{(adj)} + \sum_k \Delta_k \cdot \mathbb{1}\{t+1 \in \text{event}_k\} $$

### 예측 파이프라인 뼈대(Python)

```python
import pandas as pd
import numpy as np

# df: columns = ['date','service','cost']

df = pd.read_csv('daily_cost.csv', parse_dates=['date']).sort_values('date')
df['dow'] = df['date'].dt.dayofweek

# 간단 지수평활 + 요일 패턴

alpha=0.3
pred=[df['cost'].iloc[0]]
for x in df['cost'].iloc[1:]:
    pred.append(alpha*x + (1-alpha)*pred[-1])
df['trend'] = pred

season = df.groupby('dow')['cost'].mean() / df['cost'].mean()
df['season_factor'] = df['dow'].map(season)
df['forecast'] = df['trend'] * df['season_factor']

# 향후 14일 예측(간단 확장)

last = df.iloc[-1]
future = []
for h in range(1,15):
    dow = (int(last['date'].dayofweek)+h)%7
    f = last['forecast'] * season[dow]
    future.append({'date': last['date'] + pd.Timedelta(days=h), 'forecast': f})
future_df = pd.DataFrame(future)
print(future_df.head())
```

### 구매 계획과 연계

- 장기 **상시부하**는 **Savings Plans/RI**로 커버
- 일시·스파이크는 **온디맨드/스팟**
- **커버리지 비율** 의사결정:
  $$ \text{월비용} \approx c\cdot U\cdot p_c + (1-c)\cdot U\cdot p_o $$
  - \(U\): 예상 사용량, \(p_o\): 온디맨드 단가, \(p_c\): 약정 단가, \(c\): 약정 커버리지(0~1)

---

## 비용 **절감** — 핵심 레버 총정리

### EC2 **스팟 인스턴스** (최대 ~90% 저렴, 중단 내성 필요)

**언제?** 배치/CI 빌드, 데이터 처리, 캐시/워커, 비핵심 백그라운드, EKS/ECS 워크노드

**ASG 혼합 전략(CloudFormation)**
```yaml
Resources:
  AsgMixed:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier: [subnet-a, subnet-b]
      MinSize: 2
      MaxSize: 20
      DesiredCapacity: 4
      MixedInstancesPolicy:
        LaunchTemplate:
          LaunchTemplateSpecification:
            LaunchTemplateId: lt-012345
            Version: 1
          Overrides:
            - InstanceType: m6i.large
            - InstanceType: m6a.large
            - InstanceType: c7g.large   # Graviton
            - InstanceType: r6i.large
        InstancesDistribution:
          OnDemandBaseCapacity: 1
          OnDemandPercentageAboveBaseCapacity: 20
          SpotAllocationStrategy: capacity-optimized-prioritized
```

**EKS 노드그룹(스팟)**
```yaml
apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig
metadata: { name: demo, region: ap-northeast-2 }
managedNodeGroups:
  - name: spot-mix
    desiredCapacity: 4
    minSize: 2
    maxSize: 20
    spot: true
    instanceTypes: ["m6i.large","m6a.large","c7g.large","r6i.large"]
    labels: { lifecycle: spot }
```

**종료 알림 처리(인스턴스 메타데이터 2분 전)**
```bash
#!/usr/bin/env bash

URL="http://169.254.169.254/latest/meta-data/spot/termination-time"
while sleep 5; do
  code=$(curl -s -o /dev/null -w "%{http_code}" $URL)
  if [ "$code" -eq 200 ]; then
    # 안전 종료: 워크 큐 drain, 체크포인트, 로깅
    /usr/local/bin/drain_and_exit.sh
    shutdown -h now
  fi
done
```

> 팁
> - **capacity-optimized**로 용량 많은 풀 우선
> - **다중 AZ·다중 패밀리**로 중단 위험 분산
> - 상태는 **외부화**(S3/RDS/ElastiCache 등), 워커는 교체 가능해야 함

---

### **Reserved Instances(RI)** vs **Savings Plans(SP)**

| 항목 | Standard RI | Convertible RI | Compute Savings Plans | EC2 Instance SP |
|---|---|---|---|---|
| 할인대상 | 특정 인스턴스/리전/플랫폼 | 변경 가능(등가/상향 교환) | EC2+Fargate+Lambda | 특정 인스턴스 패밀리/리전 |
| 유연성 | 낮음 | 중간 | 높음(가장 유연) | 중간 |
| 기간 | 1년/3년 | 1년/3년 | 1년/3년 | 1년/3년 |
| 절감율 | 高 | 中 | 高(최대 ~66%) | 高 |
| 권장 | 고정 워크로드 | 변동·진화 | 조직 기본값 | 특정 패밀리 고정 |

**커밋 계산 개념**
- 월평균 사용량 \(\bar{U}\) 중 **절대 줄지 않는 하한** \(U_{\min}\) 을 커버리지로:
  $$ c = \frac{U_{\min}}{\bar{U}} \quad\Rightarrow\quad \text{Commit} = c\cdot \bar{U} $$
- 처음엔 **6~8주 로데이터**로 \(U_{\min}\) 추정 → **Compute SP 1년 No-Upfront**로 시작 → 안정 시 3년/일부 선납

**구매 단계**
1) 30~60일 사용량 분석(시간당 사용금액 시계열)
2) 하한 구간만큼 **Compute SP** 커밋
3) 남는 고정 패턴은 **EC2 Instance SP** 또는 **Standard/Convertible RI**로 더 절감
4) 분기/반기 **재평가**(스케일·인스턴스 교체·Graviton 전환 반영)

---

### **오토스케일링 & 스케줄링** (가변부하 = 비용절감)

**TargetTracking(지연·요청기반)**
```yaml
Resources:
  AlbReqScale:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyType: TargetTrackingScaling
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ALBRequestCountPerTarget
        TargetValue: 120.0
        ScaleInCooldown: 120
        ScaleOutCooldown: 60
```

**업무시간 스케줄링(개발환경)**
```bash
# 평일 20시 종료, 09시 기동 (EventBridge + Lambda 조합 예)

aws events put-rule --name stop-dev-20 --schedule-expression "cron(0 11 ? * MON-FRI *)"
aws events put-rule --name start-dev-09 --schedule-expression "cron(0 0 ? * MON-FRI *)"
# 타깃은 Lambda로 연결하여 태그 AutoStop=true 인스턴스를 중지/기동

```

---

### **스토리지 최적화** — S3/EBS/EFS

**S3 Lifecycle(7일 후 IA, 90일 후 Glacier)**
```json
{
  "Rules":[
    {"ID":"logs-tiering","Status":"Enabled","Filter":{"Prefix":"logs/"},
     "Transitions":[{"Days":7,"StorageClass":"STANDARD_IA"}],
     "NoncurrentVersionTransitions":[{"NoncurrentDays":30,"StorageClass":"GLACIER"}],
     "Expiration":{"Days":365}}
  ]
}
```

**S3 Intelligent-Tiering 활성화(자주 액세스 불규칙 데이터)**
- 자동 계층 이동, 소액 모니터링 비용 ↔ 대규모/장기 보관 시 유리

**EBS gp2 → gp3 전환(같은 성능 더 저렴)**
```bash
aws ec2 modify-volume --volume-id vol-0abc --volume-type gp3 --iops 3000 --throughput 125
```

**미사용 스냅샷/볼륨 정리(개념 스크립트)**
```bash
# 연결 안 된 EBS

aws ec2 describe-volumes --filters Name=status,Values=available \
  --query 'Volumes[].{Id:VolumeId,Size:Size,Create:CreateTime}'
# 오래된 스냅샷

aws ec2 describe-snapshots --owner-ids self \
  --query 'Snapshots[?StartTime<`2025-08-01`].[SnapshotId,StartTime,VolumeSize]'
```

---

### **네트워크 비용** — “Egress·NAT·데이터경로” 줄이기

- **CloudFront** 캐싱 + **압축(Brotli/Gzip)** + **오브젝트 만료컨트롤**
- **PrivateLink/VPC Endpoint** 로 내부통신 → **NAT 게이트웨이 트래픽 감소**
- **S3 Gateway Endpoint** + 퍼블릭 차단 → NAT/DataTransfer 아끼기
- 멀티AZ 간 과도한 트래픽, 리전 간 동기화 빈도 점검

**S3 VPC 엔드포인트 접근 제한(Endpoint Policy)**
```json
{"Statement":[{"Effect":"Allow","Principal":"*",
  "Action":["s3:GetObject","s3:PutObject"],
  "Resource":["arn:aws:s3:::team-artifacts/*"],
  "Condition":{"StringEquals":{"aws:SourceVpce":"vpce-012345"}}}]}
```

---

### **DB/캐시** — 워크로드별 비용지렛대

- **RDS**: Multi-AZ는 HA 필수일 때만, 스토리지는 **gp3/IO-Optimized** 비용 비교
- **리드부하는** 리드레플리카/ElastiCache로 흡수(상대적으로 저렴)
- **Aurora Serverless v2**: 미세 스케일링으로 비정형 부하 절감
- **DynamoDB On-Demand**: 예측 어려운 초반 PoC, 이후 **Provisioned+AutoScaling** 전환

---

### **서버리스** — 올바른 한도와 관측

- **동시성 제한**(Reserved Concurrency)으로 폭주 차단 → 예산 보호
- **메모리/타임아웃** 튜닝으로 msec 단위 비용 최적화
- 콜드스타트 민감 경로는 **프로비저닝드 컨커런시**와 영향 대비

---

## 자동화/가드레일 — “만들었으면 지워지게”

### 유휴자원 정리(예: 7일간 CPU<3% 인스턴스 중지)

```python
import boto3, datetime
cw = boto3.client('cloudwatch'); ec2 = boto3.client('ec2')
end = datetime.datetime.utcnow(); start = end - datetime.timedelta(days=7)

ids = [i['InstanceId'] for r in ec2.describe_instances()['Reservations']
       for i in r['Instances'] if i['State']['Name']=='running']

def avg_cpu(iid):
    m = cw.get_metric_statistics(Namespace='AWS/EC2',MetricName='CPUUtilization',
        Dimensions=[{'Name':'InstanceId','Value':iid}],StartTime=start,EndTime=end,
        Period=3600,Statistics=['Average'])
    pts = [p['Average'] for p in m['Datapoints']]
    return sum(pts)/len(pts) if pts else 100.0

stop = [iid for iid in ids if avg_cpu(iid)<3.0]
if stop:
    ec2.stop_instances(InstanceIds=stop)
    print("Stopped:", stop)
```

### — 미태깅 생성 거부

```json
{
  "Version":"2012-10-17",
  "Statement":[{
    "Sid":"DenyCreateWithoutTags",
    "Effect":"Deny","Action":["ec2:RunInstances","rds:CreateDBInstance","s3:CreateBucket"],
    "Resource":"*",
    "Condition":{"Null":{"aws:RequestTag/CostCenter":"true","aws:RequestTag/Owner":"true"}}
  }]
}
```

---

## **의사결정 체크리스트**

- [ ] **상시부하** k vCPU, m GB 메모리 → **Compute SP 1년**부터 커밋
- [ ] **패밀리 고정** 워크로드 → **EC2 Instance SP / Standard RI** 비교
- [ ] **배치/CI/ETL** → 스팟 + 다중패밀리 + capacity-optimized
- [ ] Dev/QA **스케줄 중지**(야간/주말)
- [ ] **S3** 수명주기/Intelligent-Tiering/아카이브 룰 적용
- [ ] **NAT 비용**과 내부통신 경로 점검(VPC Endpoint)
- [ ] **Budgets/Anomaly** 경보 + **월간 리뷰**
- [ ] **Graviton** 전환 가능성 평가(동일 성능 대비 비용↓)

---

## 예시: 스팟+온디맨드 혼합 ASG로 CI 파이프라인 비용 60%↓ (시나리오)

1) 기존: 온디맨드 m5.large × 10대를 상시 가동(야간에도 Idle)
2) 개선:
   - **OnDemandBase=2**, 나머지 **Spot 80%**
   - **빌드 큐 길이** 기반 TargetTracking(EC2/ASG + SQS length)
   - 빌드 아티팩트는 S3/ECR에 저장, **워커 무상태**
   - 야간 **스케줄 축소(2대 고정)**
3) 결과: 동일 스루풋에서 **월 비용 ~60% 절감**, 큐가 길어질 때만 자동 확장

---

## 요약

- **가시화가 절감의 전제**: CUR/Cost Explorer/예산·이상탐지부터.
- **예측은 단순명료하게**: 하한 커버리지 산정 → SP/RI 커밋.
- **스팟은 체계적으로**: 다중 인스턴스·AZ·capacity-optimized·무상태.
- **스토리지/네트워크/DB** 는 사용양·경로·계층을 재설계하면 대개 큰 폭 절감.
- **자동화** 로 유휴자원·스케줄·태그·경보를 굴려 “늘 같은 습관”을 만든다.

---

## 자주 쓰는 커맨드 모음

```bash
# Cost Explorer 일일 비용(서비스별)

aws ce get-cost-and-usage --time-period Start=2025-11-01,End=2025-12-01 \
  --granularity DAILY --metrics UnblendedCost \
  --group-by Type=DIMENSION,Key=SERVICE

# 스팟 요청 (기본가=온디맨드 이하 자동)

aws ec2 run-instances --image-id ami-0abc... --count 2 --instance-type m6a.large \
  --instance-market-options '{"MarketType":"spot"}'

# gp2→gp3 전환

aws ec2 modify-volume --volume-id vol-0abc --volume-type gp3 --iops 3000 --throughput 125

# Budgets 생성(월 1,000 USD 경보)

aws budgets create-budget ... (본문 예시 재사용)

# S3 Lifecycle 적용(버킷 정책은 콘솔/CLI로 추가)

aws s3api put-bucket-lifecycle-configuration --bucket my-bucket \
  --lifecycle-configuration file://lifecycle.json
```

---

## “우리 상황에 맞는 커버리지” 빠른 산정 표

| 항목 | 값(예) | 비고 |
|---|---:|---|
| 월평균 사용금액 \(\bar{U}\) | \$10,000 | CE/Forecast 기준 |
| 하한 추정 \(U_{\min}\) | \$7,000 | 주말/야간 포함 하한 |
| 제안 커버리지 \(c=U_{\min}/\bar{U}\) | 0.70 | 70%를 SP로 |
| SP 유형 | Compute, 1y, No-Upfront | 유연성 우선 |
| 추가 최적화 | EC2 Instance SP or RI | 고정 패턴 일부 |
| 스팟 적용 | 배치/CI/ETL 60~80% | 무상태 전제 |

이 표의 숫자를 계정·제품 라인별로 나눠 관리하면 **과·소커밋** 리스크를 줄일 수 있다.
