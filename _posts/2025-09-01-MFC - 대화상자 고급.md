---
layout: post
title: MFC - 대화상자 고급
date: 2025-09-01 14:25:23 +0900
category: MFC
---
# 대화상자 고급: Property Sheet/Page, 모델리스 폼, 파일 드래그&드롭 (MFC 실전 총정리 · 예제 대량)

이 글은 **MFC**에서 흔히 “고급 대화상자”로 묶이는 세 축 —  
**Property Sheet/Page(탭·마법사)**, **모델리스 폼(도구창/패널)**, **파일 드래그&드롭(기본/올레/OLE)** — 을  
**설계·수명주기·메시지 라우팅·DDX/DDV**까지 **생략 없이** 정리합니다.  
모든 코드는 **복붙 가능한 스니펫**으로 구성했고, **체크리스트/문제 해결**도 덧붙였습니다.

---

## 0) 로드맵

1) **Property Sheet/Page**  
   - 고전 탭형/마법사(Wizard/Wizard97/Aero)  
   - 동적 페이지 추가/제거, 페이지 간 데이터 공유  
   - DDV/비동기 검증, “적용(Apply)”/“기본값(Default)” UX  
   - 저장/복원(레지스트리/JSON), DPI/다크 모드

2) **모델리스(Form) 패턴**  
   - `Create` + `ShowWindow`, `DestroyWindow` + `PostNcDestroy`  
   - 부모/소유 관계, 메시지 라우팅/업데이트 UI  
   - 리사이즈/Anchor, 탭순서/Enter/ESC, 비동기 작업과 상태 동기화

3) **파일 드래그&드롭**  
   - 쉬운 버전: `WM_DROPFILES` + `DragAcceptFiles`  
   - 정석: **MFC OLE Drag&Drop** (`COleDropTarget`, `COleDataObject`)  
   - 포맷(CF_HDROP/텍스트/커스텀), Copy/Move/Link 효과, 시 بص각 피드백  
   - 드래그 소스(`COleDataSource`), 내부 재정렬

---

# 1) Property Sheet/Page (탭/마법사)

### 1-1. 핵심 개념

- **CPropertySheet**: 상위 컨테이너(탭/버튼/하단 바)  
- **CPropertyPage**: 각 탭/단계 화면  
- **모드**:  
  - **탭형(Tabbed)** 기본  
  - **마법사(Wizard)**: Next/Back/Finish 버튼 UX  
  - **Wizard97/Aero**: 큰 헤더/왼쪽 이미지를 가진 신형 스타일(리소스/매니페스트 필요)

> 기본 흐름: `CPropertySheet` 생성 → 여러 `CPropertyPage` 추가 → `DoModal()`(모달) 또는 `Create()`(모델리스).

---

### 1-2. 탭형 Property Sheet (모달)

**페이지 구현**

```cpp
// PageGeneral.h
class CPageGeneral : public CPropertyPage {
    DECLARE_DYNAMIC(CPageGeneral)
public:
    CPageGeneral() : CPropertyPage(IDD_PAGE_GENERAL) {}
    CString m_name; BOOL m_autoSave = TRUE;

protected:
    virtual void DoDataExchange(CDataExchange* pDX) {
        CPropertyPage::DoDataExchange(pDX);
        DDX_Text(pDX, IDC_EDIT_NAME, m_name);
        DDX_Check(pDX, IDC_CHK_AUTOSAVE, m_autoSave);
    }
    afx_msg void OnChanged() { SetModified(TRUE); } // Apply 버튼 활성화
    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CPageGeneral, CPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_NAME, &CPageGeneral::OnChanged)
    ON_BN_CLICKED(IDC_CHK_AUTOSAVE, &CPageGeneral::OnChanged)
END_MESSAGE_MAP()
```

```cpp
// PageAdvanced.h
class CPageAdvanced : public CPropertyPage {
public:
    CPageAdvanced() : CPropertyPage(IDD_PAGE_ADVANCED) {}
    int m_cacheMB = 256;
protected:
    virtual void DoDataExchange(CDataExchange* pDX) {
        CPropertyPage::DoDataExchange(pDX);
        DDX_Text(pDX, IDC_EDIT_CACHE, m_cacheMB);
        DDV_MinMaxInt(pDX, m_cacheMB, 0, 65536);
    }
    afx_msg void OnChanged() { SetModified(TRUE); }
    DECLARE_MESSAGE_MAP()
};
BEGIN_MESSAGE_MAP(CPageAdvanced, CPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_CACHE, &CPageAdvanced::OnChanged)
END_MESSAGE_MAP()
```

**시트 구현**

```cpp
// PrefsSheet.h
class CPrefsSheet : public CPropertySheet {
public:
    CPrefsSheet(CWnd* pParent = nullptr) : CPropertySheet(L"환경 설정", pParent) {
        m_psh.dwFlags |= PSH_NOAPPLYNOW; // (옵션) Apply 없애기
        AddPage(&m_pageGeneral);
        AddPage(&m_pageAdvanced);
    }

    CPageGeneral  m_pageGeneral;
    CPageAdvanced m_pageAdvanced;

protected:
    DECLARE_MESSAGE_MAP()
    afx_msg void OnApplyNow();
};

BEGIN_MESSAGE_MAP(CPrefsSheet, CPropertySheet)
    // 필요 시, ID_APPLY_NOW 처리 가능
END_MESSAGE_MAP()
```

**표시**

```cpp
// 어느 메뉴에서든:
void CMainFrame::OnToolsPreferences() {
    CPrefsSheet dlg(this);
    if (dlg.DoModal() == IDOK) {
        // OK → UpdateData(TRUE) 후 페이지의 값 사용
        // 페이지 간 데이터도 여기서 종합 반영
    }
}
```

> `SetModified(TRUE)`를 부르면 **Apply 버튼**이 활성화됩니다.  
> Apply를 눌러 부분 적용하고 **닫지 않는 UX**도 구현 가능(모델리스나 시트 메시지 처리 참고).

---

### 1-3. 마법사(Wizard) 모드

**시트 스타일 변경**

```cpp
class CWizardSheet : public CPropertySheet {
public:
    CWizardSheet(CWnd* pParent=nullptr) : CPropertySheet(L"마법사", pParent) {
        m_psh.dwFlags |= PSH_WIZARD;        // 전통 Wizard
        // m_psh.dwFlags |= PSH_WIZARD97;   // Wizard97(헤더 큰 스타일)
        // m_psh.dwFlags |= PSH_AEROWIZARD; // Aero Wizard(Win7+)
        m_psh.dwFlags |= PSH_HASHELP;       // (옵션) Help 버튼 표시
        AddPage(&m_p1); AddPage(&m_p2); AddPage(&m_finish);
    }
    CPropertyPage m_p1{ IDD_WZ_WELCOME };
    CPropertyPage m_p2{ IDD_WZ_OPTIONS };
    CPropertyPage m_finish{ IDD_WZ_FINISH };
};
```

**페이지에서 Next/Back 제어**

```cpp
BOOL CPropertyPage::OnSetActive() {
    // 버튼 상태 제어
    CPropertySheet* pSheet = (CPropertySheet*)GetParent();
    pSheet->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT); // 마지막이면 PSWIZB_FINISH
    return TRUE;
}

LRESULT CPropertyPage::OnWizardNext() {
    // 검증 실패 시 -1 반환 → 다음 페이지로 이동하지 않음
    if (!UpdateData(TRUE)) return -1; // DDV 검사
    if (m_name.Trim().IsEmpty()) {
        AfxMessageBox(L"이름은 필수입니다.");
        return -1;
    }
    // 동적 분기: 특정 옵션에 따라 다음 페이지 건너뛰기
    // return IDD_WZ_FINISH; // 특정 페이지로 건너뛰기 가능
    return 0; // 정상적으로 다음으로
}
```

> Wizard97/Aero는 **헤더 이미지/아이콘**을 위한 리소스/스타일이 더 있습니다.  
> (리소스 템플릿에서 `PSH_WIZARD97`/`PSH_AEROWIZARD` 플래그, `PropSheetHeader` 이미지 등)

---

### 1-4. 동적 페이지 추가/제거 & 페이지 간 데이터 공유

```cpp
// 런타임 추가/제거
CPropertyPageExtra m_pageExtra(IDD_PAGE_EXTRA);
CPrefsSheet sheet;
sheet.AddPage(&sheet.m_pageGeneral);
sheet.AddPage(&sheet.m_pageAdvanced);

if (NeedExtra()) sheet.AddPage(&m_pageExtra);

// 실행 도중 제거
sheet.RemovePage(&m_pageExtra);
```

**데이터 공유 패턴**

- **공유 모델 객체**를 시트에 보관, 각 페이지는 참조  

```cpp
struct PrefsModel { CString name; BOOL autosave; int cacheMB; };

class CPrefsSheet : public CPropertySheet {
public:
    PrefsModel m_model;
    // 페이지 생성자에 참조 전달하거나, GetParent()->GetModel()로 접근
};

class CPageGeneral : public CPropertyPage {
    PrefsModel* m_pModel = nullptr;
public:
    CPageGeneral(PrefsModel* model) : CPropertyPage(IDD), m_pModel(model) {}
    BOOL OnApply() override {
        UpdateData(TRUE);
        m_pModel->name = m_name; m_pModel->autosave = m_autoSave;
        return CPropertyPage::OnApply();
    }
};
```

> **OnApply**에서 모델로 값을 모으고, 시트의 `OnOK`에서 한 번에 저장(파일/레지스트리)하면 깔끔합니다.

---

### 1-5. “Apply/Default/Reset” UX, 비동기 검증

**Apply:**

```cpp
BOOL CPageAdvanced::OnApply() {
    if (!UpdateData(TRUE)) return FALSE;  // DDV
    // 비동기 검증(예: 서버 연결 확인)은 UI 블록 최소화:
    AfxGetMainWnd()->PostMessage(WM_APP_VALIDATE_CACHE, m_cacheMB);
    SetModified(FALSE);
    return TRUE;
}
```

**Default/Reset 버튼 추가(하단 커맨드 버튼):**

- 하단에 커스텀 버튼을 넣고 싶다면 **시트에 명령 버튼 삽입** 또는 **페이지에 “기본값 복원” 버튼** 둔 뒤 `OnBnClicked`에서 초기 값을 `UpdateData(FALSE)`로 반영.

---

### 1-6. 상태 저장/복원

- **레지스트리**: `CWinApp::GetProfile.../WriteProfile...`  
- **JSON**: 사용자 편집/이식성 필요 시

```cpp
// 저장
theApp.WriteProfileString(L"Prefs", L"Name", m_model.name);
theApp.WriteProfileInt(L"Prefs", L"AutoSave", m_model.autosave);
theApp.WriteProfileInt(L"Prefs", L"CacheMB", m_model.cacheMB);

// 로드
m_model.name = theApp.GetProfileString(L"Prefs", L"Name", L"");
m_model.autosave = theApp.GetProfileInt(L"Prefs", L"AutoSave", TRUE);
m_model.cacheMB = theApp.GetProfileInt(L"Prefs", L"CacheMB", 256);
```

---

### 1-7. DPI/다크/접근성

- **DPI**: 대화상자 템플릿은 DLU 기준이지만, 고해상도에서 컨트롤 잘림 검사  
- **다크**: `CMFCVisualManager` + 사용자 팔레트로 페이지 배경/그리기 통일  
- **접근성**: 탭 순서/단축키(`&`), 키보드 탐색(Alt+N/B) 동작 확인

---

# 2) 모델리스 폼(도구창·패널) — 수명·라우팅·UI 업데이트

### 2-1. 기본 골격: Create + ShowWindow, DestroyWindow + PostNcDestroy

```cpp
// ToolPane.h
class CToolPane : public CDialogEx {
public:
    CToolPane() : CDialogEx(IDD_TOOL_PANE) {}
    void PostNcDestroy() override { delete this; } // DestroyWindow 이후 delete
protected:
    BOOL OnInitDialog() override {
        CDialogEx::OnInitDialog();
        // 초기화
        return TRUE;
    }
    DECLARE_MESSAGE_MAP()
};

// MainDlg/MainFrame에서:
void CMainDlg::OnShowPane() {
    if (!m_pPane) {
        m_pPane = new CToolPane;
        m_pPane->Create(IDD_TOOL_PANE, this); // parent=owner 지정
    }
    m_pPane->ShowWindow(SW_SHOW);
}
```

> **수명 규칙**: 모델리스는 보통 **자기 삭제**(`PostNcDestroy`)를 사용.  
> `DestroyWindow()` 호출 → 창 파괴 → `PostNcDestroy()`에서 `delete this`.

---

### 2-2. 부모/소유(Owner)와 메시지 라우팅

- `Create(IDD, pParent)`의 **pParent**는 대화상자의 **Owner**가 됨  
- **명령 라우팅**: Dialog 기반 앱은 **현재 대화상자 → 소유자 → App** 순  
- 모델리스 자식에서 부모로 이벤트 전달: **SendMessage/PostMessage** 또는 **관찰자/신호** 패턴

```cpp
// 자식 → 부모 알림 (커스텀)
void CToolPane::OnApplyClicked() {
    GetOwner()->SendMessage(WM_APP_PANE_APPLY, 0, 0);
}
```

---

### 2-3. Enter/ESC/PreTranslateMessage, UpdateDialogControls

- 기본 `IDOK/IDCANCEL` 없거나 동작을 변경하려면 **OnOK/OnCancel** 오버라이드  
- **PreTranslateMessage**에서 단축키/ESC 가로채기

```cpp
BOOL CToolPane::PreTranslateMessage(MSG* pMsg) {
    if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE) {
        // ESC로 숨기기만
        ShowWindow(SW_HIDE); return TRUE;
    }
    UpdateDialogControls(this, FALSE); // ON_UPDATE_COMMAND_UI 적용
    return CDialogEx::PreTranslateMessage(pMsg);
}
```

---

### 2-4. 리사이즈/Anchor

- 대화상자는 기본 **자동 Anchor가 없음** → `OnSize`에서 수동 배치

```cpp
void CToolPane::OnSize(UINT nType, int cx, int cy) {
    CDialogEx::OnSize(nType, cx, cy);
    if (!IsWindow(m_btnApply)) return;
    CRect rc; GetClientRect(&rc);
    // 오른쪽 하단 배치
    m_btnApply.MoveWindow(rc.right-100, rc.bottom-32, 90, 24);
    // 리스트/에디트는 나머지 채우기 등
}
```

> **고급**: 앞선 “레이아웃 & 리사이즈” 글의 **Anchor/Resize Manager** 클래스를 재사용하세요.

---

### 2-5. 비동기 작업과 상태 동기화

- 작업 스레드 → UI 스레드에 **PostMessage(WM_APP_xxx)** 로 결과 전달  
- 모델리스가 닫힌 뒤 도착하는 메시지 방지: **수명 플래그** 혹은 **`PostMessage` 대상 null 체크**

```cpp
// 작업 끝
void WorkerThread::OnDone(int result) {
    if (IsWindow(m_hWndOwner)) ::PostMessage(m_hWndOwner, WM_APP_WORK_DONE, result, 0);
}
```

---

### 2-6. 흔한 함정

- **중복 인스턴스**: 이미 열려 있으면 `BringWindowToTop`만  
- **메모리 누수**: `DestroyWindow()` 후 `delete` 누락 → `PostNcDestroy` 필수  
- **모달 띄우기 중복**: 모델리스/모달 간 포커스 꼬임 → **소유 관계** 명확히

---

# 3) 파일 드래그&드롭 (기본/올레, OLE)

## 3-1. 초간단: WM_DROPFILES + DragAcceptFiles

- 탐색기에서 파일을 폼 위로 끌어오면 `WM_DROPFILES` 수신  
- **장점**: 간단, 종속성 없음  
- **단점**: Copy/Move/Link 효과/미리보기/다양 포맷 핸들링이 어렵다

```cpp
BOOL CMainDlg::OnInitDialog() {
    CDialogEx::OnInitDialog();
    DragAcceptFiles(TRUE);
    return TRUE;
}

BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_WM_DROPFILES()
END_MESSAGE_MAP()

void CMainDlg::OnDropFiles(HDROP hDrop) {
    UINT count = DragQueryFile(hDrop, 0xFFFFFFFF, nullptr, 0);
    for (UINT i=0; i<count; ++i) {
        wchar_t path[MAX_PATH]; 
        DragQueryFile(hDrop, i, path, _countof(path));
        OnOpenFile(path); // 파일 열기/리스트 추가 등
    }
    DragFinish(hDrop);
}
```

> **Shift/Ctrl** 상태를 직접 읽어 Copy/Move 등 의미를 유추할 수 있으나, **표준 드롭 효과 제공은 OLE D&D**가 정석.

---

## 3-2. 정석: OLE Drag&Drop — `COleDropTarget` + `COleDataObject`

**준비**

- 앱 시작 시 `AfxOleInit()` 호출  
- 드롭 대상 뷰/대화상자에 `COleDropTarget` 멤버 등록

```cpp
class CDropTargetEx : public COleDropTarget {
public:
    BOOL OnDrop(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point) override;
    DROPEFFECT OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point) override;
    DROPEFFECT OnDragOver (CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point) override;
    void OnDragLeave(CWnd* pWnd) override;
};

class CMainDlg : public CDialogEx {
    CDropTargetEx m_drop;
    BOOL OnInitDialog() override {
        CDialogEx::OnInitDialog();
        AfxOleInit(); // 반드시!
        m_drop.Register(this);
        return TRUE;
    }
};
```

**지원 포맷 검사**

```cpp
static BOOL HasHDrop(COleDataObject* p) {
    return p->IsDataAvailable(CF_HDROP);
}
static BOOL HasText(COleDataObject* p) {
    return p->IsDataAvailable(CF_TEXT) || p->IsDataAvailable(CF_UNICODETEXT);
}
```

**효과 결정(Enter/Over)**

```cpp
DROPEFFECT CDropTargetEx::OnDragEnter(CWnd*, COleDataObject* pData, DWORD key, CPoint) {
    if (HasHDrop(pData)) return (key & MK_CONTROL) ? DROPEFFECT_COPY : DROPEFFECT_MOVE;
    if (HasText(pData))  return DROPEFFECT_COPY;
    return DROPEFFECT_NONE;
}
DROPEFFECT CDropTargetEx::OnDragOver(CWnd*, COleDataObject* pData, DWORD key, CPoint) {
    return OnDragEnter(nullptr, pData, key, { });
}
```

**데이터 추출(OnDrop)**

```cpp
BOOL CDropTargetEx::OnDrop(CWnd*, COleDataObject* pData, DROPEFFECT, CPoint) {
    if (HasHDrop(pData)) {
        HGLOBAL h = pData->GetGlobalData(CF_HDROP);
        if (!h) return FALSE;
        HDROP drop = (HDROP)GlobalLock(h);
        UINT n = DragQueryFile(drop, 0xFFFFFFFF, NULL, 0);
        for (UINT i=0; i<n; ++i) {
            wchar_t path[MAX_PATH]; DragQueryFile(drop, i, path, _countof(path));
            // TODO: 파일 처리
        }
        GlobalUnlock(h);
        return TRUE;
    }
    if (HasText(pData)) {
        HGLOBAL h = pData->GetGlobalData(CF_UNICODETEXT);
        if (h) {
            auto* s = (wchar_t*)GlobalLock(h);
            if (s) {
                // TODO: 텍스트 처리
                GlobalUnlock(h);
                return TRUE;
            }
        }
    }
    return FALSE;
}
```

**시 بص각 피드백(선택):**  
드래그 중 하이라이트, 인서트 마커 표시 → `OnDragEnter/Over/Leave`에서 내부 상태 업데이트 후 `Invalidate()`로 렌더

---

## 3-3. 드래그 **소스** (내부 항목을 밖으로 끌어가기)

```cpp
void CMyListCtrl::BeginDragSelected() {
    // 선택 항목들의 경로를 CF_HDROP로 만들어 Explorer로 Copy
    COleDataSource src;
    // 1) CF_HDROP HGLOBAL 작성
    std::vector<std::wstring> files = GetSelectedPaths();
    SIZE_T bytes = sizeof(DROPFILES);
    for (auto& f : files) bytes += (f.size()+1)*sizeof(wchar_t);
    bytes += sizeof(wchar_t); // 이중 null

    HGLOBAL h = GlobalAlloc(GHND | GMEM_SHARE, bytes);
    auto* df = (DROPFILES*)GlobalLock(h);
    df->pFiles = sizeof(DROPFILES);
    df->fWide = TRUE;
    wchar_t* p = (wchar_t*)((BYTE*)df + sizeof(DROPFILES));
    for (auto& f : files) { wcscpy_s(p, f.size()+1, f.c_str()); p += (f.size()+1); }
    *p = L'\0';
    GlobalUnlock(h);

    src.CacheGlobalData(CF_HDROP, h);
    DROPEFFECT eff = src.DoDragDrop(DROPEFFECT_COPY | DROPEFFECT_MOVE, nullptr);
    // eff 결과로 Copy/Move 후처리(내부 삭제 등)
}
```

> **링크(Link) 드롭**: `CFSTR_SHELLIDLIST`/`CFSTR_FILEDESCRIPTORW`/`CFSTR_FILECONTENTS` 등 고급 포맷으로 **가상 파일** 스트림을 드롭하는 패턴도 있습니다(압축앱/클라우드 드라이브 등). 필요 시 별도 심화 자료 참고.

---

## 3-4. 고급 포인트

- **Copy vs Move**: `MK_CONTROL`(Ctrl) 누르면 Copy, 기본은 Move로 보여주기 (실제 동작은 드랍 후 구현)  
- **Drag Image**: `IDragSourceHelper`로 멋진 미리보기 이미지 제공 가능  
- **내부 재정렬**: 리스트 컨트롤에서 행을 끌어 순서 바꾸기 → 드롭 위치 계산 + 데이터 스왑 + `RedrawItems`

---

# 4) 통합 예제: “환경설정(탭/마법사) + 도구창(모델리스) + 드래그&드롭 입력”

### 4-1. 메뉴

- **도구→환경설정**: 탭형 시트  
- **도구→가이드 마법사**: Wizard  
- **보기→도구창**: 모델리스 패널 토글  
- 파일을 메인 폼으로 **드래그**하면 리스트에 추가

### 4-2. 핵심 스니펫

```cpp
// App.Init
BOOL CMyApp::InitInstance() {
    CWinAppEx::InitInstance();
    AfxOleInit();
    return TRUE;
}

// MainDlg
BOOL CMainDlg::OnInitDialog() {
    CDialogEx::OnInitDialog();
    m_drop.Register(this); // OLE DropTarget
    return TRUE;
}
void CMainDlg::OnToolsPreferences() { CPrefsSheet dlg(this); dlg.DoModal(); }
void CMainDlg::OnToolsWizard()      { CWizardSheet w(this); w.DoModal(); }
void CMainDlg::OnViewPane()         { OnShowPane(); }

// 드롭 OnDrop → 파일 목록 추가
BOOL CDropTargetEx::OnDrop(CWnd* p, COleDataObject* d, DROPEFFECT, CPoint) {
    // CF_HDROP 처리 → p로 캐스팅 후 메소드 호출
    return TRUE;
}
```

---

# 5) 문제 해결 가이드

| 증상 | 원인 | 해결 |
|---|---|---|
| PropertySheet Apply 버튼이 비활성 | `SetModified(TRUE)` 누락 | 변경 핸들러에서 **SetModified(TRUE)** |
| Wizard에서 Next가 안됨 | `OnWizardNext`에서 -1 반환 | `UpdateData(TRUE)` 실패/검증 로직 재확인 |
| 모델리스 닫은 뒤 크래시 | `delete this` 중복 | `DestroyWindow` → **PostNcDestroy에서만 delete** |
| 모델리스 UI가 갱신 안됨 | `UpdateDialogControls` 미호출 | `PreTranslateMessage`나 **State 변할 때 한 번만** 호출 |
| WM_DROPFILES가 안 옴 | `DragAcceptFiles(TRUE)` 누락 | `OnInitDialog`에서 활성화 |
| OLE 드롭이 NONE | `AfxOleInit` 누락 | 앱 시작 시 `AfxOleInit()` |
| 드롭이 느림/깜빡임 | 무거운 처리 동기 수행 | **작업 스레드**로 넘기고 즉시 UI 응답 |
| DPI에서 레이아웃 깨짐 | 고정 좌표 | `OnSize` Anchor/상대 배치, 큰 폰트 테스트 |
| 다크에서 글자 안보임 | 팔레트 미적용 | 컨트롤·커스텀 드로우에 **다크 팔레트** 적용 |

---

# 6) 체크리스트 (요약)

**Property Sheet/Page**
- 페이지마다 **DDX/DDV**, 변경 시 **SetModified(TRUE)**  
- **마법사**: `OnSetActive`에서 버튼, `OnWizardNext/Back`에서 분기/검증  
- **모델 공유** + **OnApply**로 저장/복원 일원화  
- **Wizard97/Aero** 스타일은 리소스/매니페스트 확인

**모델리스**
- `Create`/`ShowWindow`/`DestroyWindow` + **`PostNcDestroy`**  
- 부모/소유 관계 → 메시지 라우팅/활성 제어  
- `PreTranslateMessage`에서 ESC/Enter/UpdateDialogControls  
- Anchor/Resize, 비동기 결과는 **PostMessage**

**드래그&드롭**
- 쉬운 길: `WM_DROPFILES` + `DragAcceptFiles`  
- 정석: **`COleDropTarget` + `COleDataObject`**, CF_HDROP/텍스트 등  
- 고급: **드래그 소스**(`COleDataSource`)·가상 파일 포맷  
- 효과/피드백(복사/이동), 하이라이트/인서트 마커 렌더

---

## 부록 A) 리소스 템플릿 팁

- 페이지 대화상자 템플릿은 **`DS_CONTROL`** 스타일 권장(컨테이너 내 탭에서 자연스러운 포커스)  
- Wizard 헤더/이미지 리소스는 스타일별로 별도 지정  
- 단축키 표기: 라벨에 `&` 포함(예: `&Name:`)

## 부록 B) 커맨드 ID 제안

```cpp
#define ID_TOOLS_PREFERENCES    40001
#define ID_TOOLS_WIZARD         40002
#define ID_VIEW_PANE            40010
#define WM_APP_PANE_APPLY       (WM_APP + 100)
```

---

### 마무리

- **Property Sheet/Page**로 **설정/마법사 UX**를 표준화하고,  
- **모델리스**로 **항상 곁에 있는 패널**을 만들며,  
- **드래그&드롭**으로 **입력과 파일 흐름**을 자연스럽게 연결하면  
MFC 앱의 **현대적 사용성**이 한층 올라갑니다.  

필요하시면 위 스니펫을 묶은 **스타터 프로젝트(탭/마법사/모델리스/드래그&드롭 통합)**도 만들어 드릴게요. 🙂