---
layout: post
title: Java - 함수형 인터페이스
date: 2025-08-04 16:20:23 +0900
category: Java
---
# 함수형 인터페이스 (@FunctionalInterface) — 자세 정리

Java에서 함수형 프로그래밍을 지원하기 위해 중요한 개념인 **함수형 인터페이스(Functional Interface)** 와 이를 명시하는 어노테이션 `@FunctionalInterface`에 대해 자세히 설명합니다.

---

## 1. 함수형 인터페이스란?

- **함수형 인터페이스**는 **추상 메서드가 단 하나만 있는 인터페이스**입니다.
- 람다식이나 메서드 레퍼런스는 바로 이 함수형 인터페이스의 구현체를 만드는 간결한 방법입니다.
- 함수형 인터페이스는 Java 8부터 본격적으로 도입되어, 람다식 문법의 기반이 됩니다.

---

## 2. 문법적 정의

- 함수형 인터페이스는 정확히 **한 개의 추상 메서드(abstract method)** 만 가져야 합니다.
- 그 외에 `default` 메서드나 `static` 메서드는 여러 개 포함할 수 있습니다.
- `@FunctionalInterface` 어노테이션은 함수형 인터페이스임을 명시하며, 컴파일러가 규칙을 체크하도록 합니다.

---

## 3. 예제

```java
@FunctionalInterface
public interface MyFunction {
    void apply();

    // default 메서드는 허용됨
    default void log(String msg) {
        System.out.println("LOG: " + msg);
    }

    // static 메서드도 허용됨
    static void printHello() {
        System.out.println("Hello");
    }
}
```

- 위 인터페이스는 단 하나의 추상 메서드 `apply()`를 가지므로 함수형 인터페이스입니다.
- `default`나 `static` 메서드는 함수형 인터페이스의 조건에 위배되지 않습니다.

---

## 4. 왜 @FunctionalInterface를 쓰는가?

- **명시적 의도 표현**: 이 인터페이스가 함수형 인터페이스임을 명확히 하여, 유지보수자가 쉽게 이해 가능.
- **컴파일 타임 검증**: 만약 추상 메서드가 두 개 이상 있으면 컴파일 오류 발생.
- 어노테이션 없이도 함수형 인터페이스로 사용할 수 있지만, 어노테이션 사용을 권장함.

---

## 5. 대표적인 Java 표준 함수형 인터페이스

`java.util.function` 패키지에는 자주 쓰이는 함수형 인터페이스가 이미 정의되어 있습니다.

| 인터페이스           | 설명                                | 추상 메서드                      |
|----------------------|-----------------------------------|---------------------------------|
| `Predicate<T>`       | T 타입의 인자를 받아 `boolean` 반환 | `boolean test(T t)`              |
| `Function<T,R>`      | T 타입의 인자를 받아 R 타입 반환    | `R apply(T t)`                  |
| `Consumer<T>`        | T 타입의 인자를 받아 처리, 반환 없음 | `void accept(T t)`              |
| `Supplier<T>`        | 인자를 받지 않고 T 타입 반환         | `T get()`                      |
| `UnaryOperator<T>`   | Function<T, T>와 같음              | `T apply(T t)`                 |
| `BinaryOperator<T>`  | BiFunction<T, T, T>와 같음         | `T apply(T t1, T t2)`          |

---

## 6. 람다와 함수형 인터페이스의 관계

- 람다는 **함수형 인터페이스의 구현체**를 간단하게 표현하는 문법입니다.
- 예:

```java
Predicate<String> isEmpty = s -> s.isEmpty();
Function<Integer, Integer> square = x -> x * x;
```

- 위 예제에서 람다는 각각 `Predicate`와 `Function`의 추상 메서드를 구현하는 익명 객체로 컴파일됩니다.

---

## 7. 함수형 인터페이스의 규칙과 예외

- 하나 이상의 추상 메서드를 가지면 함수형 인터페이스가 아님.
- `Object` 클래스의 메서드들은 함수형 인터페이스 추상 메서드 수에 포함하지 않음.
  - 예: `equals()`, `hashCode()`, `toString()` 은 인터페이스에 선언되어 있더라도 함수형 인터페이스 조건에 영향 없음.
- `default`와 `static` 메서드는 추상 메서드가 아니므로 허용.

---

## 8. 사용자 정의 함수형 인터페이스 예제

```java
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
}
```

- 이 인터페이스는 `calculate`라는 단 하나의 추상 메서드를 가지고 있으므로 함수형 인터페이스이다.
- 람다식으로 쉽게 구현 가능:

```java
Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;
```

---

## 9. 인터페이스 상속과 함수형 인터페이스

- 함수형 인터페이스는 다른 인터페이스를 상속받을 수 있고, 상속받은 인터페이스가 가진 추상 메서드까지 포함해 추상 메서드가 **하나여야** 함수형 인터페이스이다.
- 예:

```java
@FunctionalInterface
interface A {
    void methodA();
}

@FunctionalInterface
interface B extends A {
    // methodA() 상속 → 추상 메서드는 1개 → 함수형 인터페이스
}
```

---

## 10. 정리

| 항목                          | 설명                                    |
|-------------------------------|---------------------------------------|
| 함수형 인터페이스 정의          | 추상 메서드가 하나인 인터페이스            |
| @FunctionalInterface 어노테이션 | 함수형 인터페이스임을 명시, 컴파일러 검증 지원 |
| 추상 메서드 개수                | 정확히 하나 (Object 메서드는 제외)          |
| 허용 메서드                    | `default`, `static` 메서드는 여러 개 가능     |
| 람다식과 관계                  | 람다는 함수형 인터페이스의 인스턴스를 생성하는 간결 문법 |
