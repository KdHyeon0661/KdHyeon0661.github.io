---
layout: post
title: Java - 함수형 인터페이스
date: 2025-08-04 16:20:23 +0900
category: Java
---
# 함수형 인터페이스(@FunctionalInterface)

## 0. 한눈에 핵심

- **함수형 인터페이스 = 추상 메서드 1개(SAM; Single Abstract Method)**  
  `default/static` 메서드는 몇 개든 추가 가능, `Object`에서 물려오는 메서드(예: `toString`)는 **추상 메서드 수에 포함되지 않음**.
- `@FunctionalInterface`는 **컴파일 타임 검증**과 **의도 표현**을 위해 **반드시** 붙이자.
- 람다/메서드 참조는 **타깃 타입(함수형 인터페이스)**의 추상 메서드 시그니처와 **호환**되어야 한다(타입 추론·오토박싱 포함).
- **체크 예외**는 표준 `java.util.function` 타입으로는 바로 던질 수 없다 → **Throwing-인터페이스** 또는 **어댑터** 패턴으로 해결.
- 성능은 람다/메서드 참조 모두 `invokedynamic` 기반 → **오버헤드 거의 없음**, 가독성·설계가 우선.

---

## 1. 함수형 인터페이스 정의와 규칙

```java
@FunctionalInterface
public interface MyFunction {
    void apply();                      // 추상 메서드 1개 (SAM)

    default void log(String msg) {     // 허용(default)
        System.out.println("LOG: " + msg);
    }
    static void printHello() {         // 허용(static)
        System.out.println("Hello");
    }

    // Object의 메서드는 SAM 카운트에 포함되지 않음
    boolean equals(Object obj);        // OK: Object에서 상속된 메서드
}
```

**규칙 정리**
- 추상 메서드 **정확히 1개**. (제네릭 포함해도 “논리적으로 하나”여야 함)
- `default`/`static` 메서드는 **무제한** 추가 가능.
- `Object`의 메서드는 **추상 개수 계산에서 제외**.

`@FunctionalInterface`를 붙이지 않아도 사용할 수 있지만, **붙여야** 실수(추상 메서드 2개 이상)를 **컴파일 타임에 방지**한다.

---

## 2. 람다/메서드 참조와의 관계(타깃 타이핑, this/캡처)

### 2.1 타깃 타이핑(Target typing)
람다/메서드 참조는 “**타깃 함수형 인터페이스**”에 **대입/전달되는 순간** 파라미터/반환 타입이 결정된다.

```java
@FunctionalInterface interface Converter<F,T> { T convert(F from); }

Converter<String, Integer> c = Integer::parseInt; // (String)->int/Integer 호환
System.out.println(c.convert("123"));
```

### 2.2 익명클래스와 비교 — `this`의 의미
- 람다 내부의 `this`는 **외부 인스턴스**를 가리킨다.
- 익명 클래스의 `this`는 **자기 자신**을 가리킨다.

```java
class Outer {
    Runnable r1 = () -> System.out.println(this.getClass().getSimpleName()); // Outer
    Runnable r2 = new Runnable() {
        public void run() { System.out.println(this.getClass().getSimpleName()); } // 익명클래스
    };
}
```

### 2.3 캡처와 effectively final
- 람다는 **로컬 변수**를 캡처할 수 있으나, 그 변수는 **final 또는 effectively final**이어야 한다.
- 변경해야 한다면 `Atomic*`/배열/래퍼로 참조형에 값을 담아 변경.

```java
int x = 10;
Runnable ok = () -> System.out.println(x); // OK
// x = 11; // 컴파일 오류

AtomicInteger ai = new AtomicInteger(0);
Runnable r = ai::incrementAndGet; // 가능
```

---

## 3. 표준 함수형 인터페이스 지도(java.util.function)

| 분류 | 인터페이스 | 추상 메서드 | 비고/연산 |
|---|---|---|---|
| 불리언 | `Predicate<T>` | `boolean test(T t)` | `and/or/negate` 조합 제공 |
| 소비 | `Consumer<T>` | `void accept(T t)` | `andThen` |
| 공급 | `Supplier<T>` | `T get()` | 지연 평가(Lazy) |
| 변환 | `Function<T,R>` | `R apply(T t)` | `compose/andThen/identity` |
| 동일형 | `UnaryOperator<T>` | `T apply(T t)` | `Function<T,T>` 단축형 |
| 이항 동일형 | `BinaryOperator<T>` | `T apply(T t1, T t2)` | `minBy/maxBy` |
| 이항 변환 | `BiFunction<T,U,R>` | `R apply(T t, U u)` | — |
| 이항 소비 | `BiConsumer<T,U>` | `void accept(T t, U u)` | `andThen` |
| 이항 불리언 | `BiPredicate<T,U>` | `boolean test(T t, U u)` | `and`/`or`/`negate` |

**프리미티브 특화(오토박싱 회피)**  
- `Int/Long/Double` 전용: `IntPredicate`, `IntSupplier`, `IntUnaryOperator`, `IntFunction<R>`, `ToIntFunction<T>`, `ObjIntConsumer<T>` …  
- 가능하면 **프리미티브 특화 타입**을 사용해 박싱/언박싱 비용 감소.

**조합 예시**

```java
Predicate<String> longName = s -> s.length() >= 5;
Predicate<String> startsWithA = s -> s.startsWith("A");
Predicate<String> ok = longName.and(startsWithA).negate();

Function<String, Integer> len = String::length;
Function<Integer, String> str = Object::toString;
Function<String, String> lenStr = len.andThen(str);

Consumer<String> log = System.out::println;
Consumer<String> logTwice = log.andThen(log);
```

---

## 4. 제네릭/와일드카드(PECS)와 안전한 API

**PECS(Producer Extends, Consumer Super)**를 기억하자.

```java
// 생산자(읽기): extends
static <T> List<T> mapAll(
        List<? extends T> in, UnaryOperator<T> op) {
    return in.stream().map(op).toList();
}

// 소비자(쓰기): super
static <T> void forEachSink(
        List<? super T> out, Supplier<? extends T> src, int n) {
    for (int i = 0; i < n; i++) out.add(src.get());
}
```

함수형 매개변수에도 동일 원칙 적용:
```java
static <T,R> List<R> map(
  List<? extends T> in,
  Function<? super T, ? extends R> f) {
  return in.stream().map(f).toList();
}
```

---

## 5. 체크 예외와 함수형 — 3가지 풀이

### 5.1 Throwing-타입 정의
```java
@FunctionalInterface
public interface ThrowingFunction<T,R,E extends Exception> {
    R apply(T t) throws E;
}
```

### 5.2 어댑터로 감싸기(unchecked 변환)
```java
public final class Unchecked {
    public static <T,R> Function<T,R> fn(ThrowingFunction<T,R,?> f) {
        return t -> {
            try { return f.apply(t); }
            catch (RuntimeException e) { throw e; }
            catch (Exception e) { throw new RuntimeException(e); }
        };
    }
}
```

사용:
```java
Files.lines(Path.of("data.txt"))
     .map(Unchecked.fn(line -> parse(line))) // parse가 throws 할 때
     .forEach(System.out::println);
```

### 5.3 표준 타입만 고집한다면 내부에서 try-catch
```java
Function<String, Integer> safeParse = s -> {
    try { return Integer.parseInt(s); }
    catch (NumberFormatException e) { return -1; }
};
```

---

## 6. 상속/오버라이드 엣지 케이스

### 6.1 상속으로 추상 1개 유지
```java
@FunctionalInterface
interface A { void a(); }

@FunctionalInterface             // OK: 추상 1개(a())
interface B extends A { /* nothing */ }
```

### 6.2 서로 다른 시그니처 2개가 되면 오류
```java
interface A { void a(); }
interface X { void x(); }

// @FunctionalInterface  // 컴파일 오류: SAM이 2개
interface Bad extends A, X {}
```

### 6.3 `Object` 메서드는 제외
```java
@FunctionalInterface
interface Good {
    void run();
    boolean equals(Object o); // 여전히 SAM은 run() 1개
}
```

### 6.4 제네릭 오버로드 중복/소거 문제
서로 다른 제네릭 시그니처가 **소거 후 동일해지면** 컴파일 오류 가능.  
SAM으로 만들 땐 **메서드 명/시그니처를 명확히 한 개**로 유지하라.

---

## 7. 성능 모델 — 람다/메서드 참조는 가볍다

- HotSpot은 람다/메서드 참조를 **`invokedynamic` + 람다 메타팩토리**로 구현한다.  
- **캡처 없는 람다**는 **캐시 가능한 싱글턴**으로 재사용되며, **캡처 람다**도 경량 객체로 필요 시 생성.  
- 대부분의 경우 **가상 호출 비용과 같은 수준**으로, **성능상 불이익 거의 없음**.  
- 성능은 “람다 vs 익명클래스”보다 **알고리즘/자료구조/박싱**의 영향이 압도적으로 크다.

---

## 8. 실전 설계 패턴 — 함수형 인터페이스로 API를 더 선명하게

### 8.1 빌더/옵션 구성에 `Consumer<Builder>` 사용
```java
class SmtpConfig {
    String host; int port; boolean tls;
    static class Builder {
        SmtpConfig cfg = new SmtpConfig();
        Builder host(String h){ cfg.host = h; return this; }
        Builder port(int p){ cfg.port = p; return this; }
        Builder tls(boolean t){ cfg.tls = t; return this; }
        SmtpConfig build(){ return cfg; }
    }
    static SmtpConfig build(Consumer<Builder> c){
        Builder b = new Builder(); c.accept(b); return b.build();
    }
}

// 사용
SmtpConfig conf = SmtpConfig.build(b -> b.host("smtp.example.com")
                                         .port(587).tls(true));
```

### 8.2 리소스 관리 — 안전한 템플릿
```java
@FunctionalInterface interface Using<T,R> { R apply(T t) throws Exception; }

static <T extends AutoCloseable, R> R using(T res, Using<T,R> body) {
    try (res) { return body.apply(res); }
    catch (Exception e) { throw new RuntimeException(e); }
}

// 사용 예
String text = using(Files.newBufferedReader(Path.of("a.txt")),
                    br -> br.readLine());
```

### 8.3 재시도/백오프 정책
```java
@FunctionalInterface interface Attempt<T> { T run() throws Exception; }

static <T> T retry(Attempt<T> a, int max, long backoffMs) {
    int n = 0;
    while (true) {
        try { return a.run(); }
        catch (Exception e) {
            if (++n >= max) throw new RuntimeException(e);
            try { Thread.sleep(backoffMs); } catch (InterruptedException ie) {
                Thread.currentThread().interrupt(); throw new RuntimeException(ie);
            }
        }
    }
}

// 사용
String body = retry(() -> httpGet("https://example.com"), 3, 200);
```

### 8.4 디바운스/스로틀(이벤트 처리)
```java
class Debouncer {
    private final ScheduledExecutorService ses = Executors.newSingleThreadScheduledExecutor();
    private ScheduledFuture<?> pending;

    public synchronized void schedule(Runnable task, long delayMs) {
        if (pending != null) pending.cancel(false);
        pending = ses.schedule(task, delayMs, TimeUnit.MILLISECONDS);
    }
}
```

### 8.5 `Comparator` 구축(함수 합성의 정석)
```java
record Person(String name, int age) {}
Comparator<Person> cmp =
    Comparator.comparing(Person::name)
              .thenComparingInt(Person::age);
```

---

## 9. 메서드 참조와의 시그니처 호환(요약)

- 정적: `Class::staticMethod` → `(args) -> Class.staticMethod(args)`
- 바운드: `instance::method` → `(args) -> instance.method(args)`
- 언바운드: `Class::method` → `(recv, args) -> recv.method(args)`
- 생성자/배열: `Class::new`, `Type[]::new`

**타깃 인터페이스의 SAM 시그니처**와 **참조 메서드 시그니처**가 **호환**되어야 한다(오토박싱/와일드카드 고려).

---

## 10. 안티패턴/주의 사항

1. **SAM 2개 이상**인데 `@FunctionalInterface`를 붙이지 않음 → 나중에 람다 대입이 막힌다. (붙여서 컴파일 오류로 조기 발견)
2. **체크 예외 무시**: 표준 `Function`에 던지는 로직을 강제로 넣지 말고 **Throwing-타입/어댑터**로 명확히.
3. **불필요한 커스텀 타입 남발**: 표준 타입으로 표현 가능하면 그대로 사용. (단, 의미/예외/제네릭 이유로 커스텀이 더 명확하면 커스텀 사용)
4. **박싱 남발**: 프리미티브 특화 인터페이스를 적극 활용.
5. **람다에서 큰 객체 무심코 캡처**: 장수 객체가 단수 수명 객체를 붙잡아 **메모리 누수** 가능. (리스너 해제/약참조 고려)
6. **오버로드 모호성 방치**: **명시적 캐스트**로 타깃 타입을 지정해 가독성·컴파일 안정성을 확보.

---

## 11. 테스트/디버깅 팁

- **명명된 메서드**로 분리한 뒤 **메서드 참조**를 사용하면 스택트레이스/테스트 가독성↑
- 함수 조합(특히 `andThen/compose`)은 **단위 테스트**에서 입력/출력 캐이스를 표로 검증
- 예외 경로(`exceptionally`/`handle`)를 별도 테스트 케이스로 분리

---

## 12. 미니 쿡북

### 12.1 리스트 맵/필터/수집
```java
List<String> names = List.of("Alice","Bob","Charlie","Ann");
List<String> rs = names.stream()
    .filter(((Predicate<String>) String::isEmpty).negate()) // isEmpty 부정
    .filter(s -> s.startsWith("A"))
    .map(String::toUpperCase)
    .toList();
```

### 12.2 함수형 빌더로 옵션 주입
```java
class HttpReq {
    String url; int timeoutMs; Map<String,String> headers = new HashMap<>();
    static HttpReq of(Consumer<HttpReq> c){ var r = new HttpReq(); c.accept(r); return r; }
}
HttpReq req = HttpReq.of(r -> { r.url="https://ex.com"; r.timeoutMs=1500; r.headers.put("A","B"); });
```

### 12.3 캐시 로더(Supplier로 지연 초기화)
```java
class Lazy<T> {
    private final Supplier<T> sup;
    private volatile T value;
    Lazy(Supplier<T> sup){ this.sup = sup; }
    T get(){ T v = value; if (v != null) return v;
        synchronized(this){ if (value == null) value = sup.get(); return value; }
    }
}
```

---

## 13. 종합 요약 표

| 항목 | 핵심 |
|---|---|
| 정의 | **추상 메서드 1개(SAM)** 인터페이스 |
| 어노테이션 | `@FunctionalInterface`로 **검증/의도 표현** |
| 허용 메서드 | `default`/`static` 무제한, `Object` 메서드는 카운트 제외 |
| 표준 타입 | `Predicate/Function/Consumer/Supplier/Unary/Binary/...` + 프리미티브 특화 |
| 제네릭/PECS | `Function<? super T, ? extends R>` 형태로 안전 API |
| 체크 예외 | Throwing-타입·어댑터로 처리(또는 내부 try-catch) |
| 상속 규칙 | 상속 후에도 **논리적 SAM 1개** 유지 필요 |
| 성능 | `invokedynamic` 기반 → **오버헤드 미미**, 가독성 우선 |
| 패턴 | 빌더/리소스 관리/재시도/디바운스/Comparator 조합 등 |

---

## 14. 부록: 실전 예제 모음

### 14.1 사용자 정의 함수형 인터페이스와 람다 구현
```java
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
}
Calculator add = (a, b) -> a + b;
Calculator mul = (a, b) -> a * b;
```

### 14.2 Optional + 함수형 인터페이스
```java
Optional<String> maybe = Optional.of("x");
maybe.map(String::length)
     .filter(n -> n > 0)
     .ifPresent(System.out::println);
```

### 14.3 CompletableFuture와 결합
```java
ExecutorService ex = Executors.newFixedThreadPool(4);
CompletableFuture.supplyAsync(() -> "hi", ex)
                 .thenApply(String::toUpperCase)
                 .thenAccept(System.out::println);
ex.shutdown();
```

### 14.4 Stream Collector with method references
```java
List<String> list = List.of("a","bb","ccc");
String joined = list.stream().collect(Collectors.joining(","));
Map<Integer, List<String>> byLen = list.stream()
    .collect(Collectors.groupingBy(String::length));
```

---

## 15. 결론

- 함수형 인터페이스는 **람다/메서드 참조의 타깃 타입**이자 **함수 합성의 표준 단위**다.  
- `@FunctionalInterface`로 **컴파일 검증**을 걸어 두고, **표준 인터페이스 + 프리미티브 특화**를 우선 사용하자.  
- **체크 예외/제네릭/와일드카드/상속 엣지케이스**만 숙지하면, API 가독성과 유연성, 테스트 용이성이 **크게 향상**된다.

---
```java
// 빠른 참고: 자주 쓰는 표준 인터페이스 한 줄 모음
Predicate<String> p = String::isEmpty;
Function<String,Integer> f = String::length;
Supplier<List<String>> s = ArrayList::new;
Consumer<Object> c = System.out::println;
UnaryOperator<String> u = String::trim;
BinaryOperator<Integer> b = Integer::max;
BiFunction<String,String,Integer> bf = String::compareTo;
IntPredicate ip = x -> x % 2 == 0;
ToIntFunction<String> tif = String::length;
ObjIntConsumer<String> oic = (str, i) -> System.out.println(str + i);
```