---
layout: post
title: HTML - HTML5
date: 2025-03-20 21:20:23 +0900
category: HTML
---
# HTML5

## 1. HTML5란 무엇인가

- HTML의 **5번째 주요 버전**으로, W3C와 WHATWG가 이끌어온 **웹 표준**.
- 문서 마크업을 넘어 **애플리케이션 플랫폼**으로 확장: 멀티미디어, 그래픽, 스토리지, 네트워킹, 스레딩, 오프라인 등.
- **의미론(시맨틱)** 강화와 **호환성**·**단순성** 중시: 간결한 `<!DOCTYPE html>`, 풍부한 기본 API.

---

## 2. 왜 HTML5가 등장했나 — 배경 정리

| 배경 | 핵심 요구 |
|---|---|
| 모바일/멀티 디바이스 시대 | 플러그인 없이도 가볍고 표준적인 멀티미디어·그래픽 |
| 리치 웹앱의 부상 | 오프라인 동작, 빠른 로컬 저장소, 실시간 통신 |
| 문법/표준의 일관성 | XHTML의 엄격성 한계를 보완한 **유연한 문법**과 일관 처리 |
| 접근성/SEO | 시맨틱 태그로 문서 의미 명확화, 보조공학/검색 친화 |

> HTML5는 “웹 문서”가 아니라 **웹 운영체제의 커널**처럼 동작하는 기반을 제공한다.

---

## 3. HTML5 문서 기본 구조

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HTML5 문서</title>
  <meta name="description" content="HTML5 기본 구조와 예제">
  <link rel="manifest" href="/manifest.webmanifest">
</head>
<body>
  <header>
    <h1>내 블로그</h1>
  </header>

  <nav aria-label="주요 메뉴">
    <ul>
      <li><a href="/">홈</a></li>
      <li><a href="/about">소개</a></li>
    </ul>
  </nav>

  <main id="content">
    <section aria-labelledby="s1">
      <h2 id="s1">HTML5 소개</h2>
      <article>
        <h3>개요</h3>
        <p>HTML5는 현대 웹의 표준입니다.</p>
      </article>
    </section>
    <aside>사이드 정보</aside>
  </main>

  <footer>&copy; 2025 Do Hyun Kim</footer>

  <script type="module" src="/app.mjs" defer></script>
</body>
</html>
```

포인트
- **간결한 DOCTYPE**: `<!DOCTYPE html>`
- **언어 속성**: `<html lang="ko">`
- **뷰포트 메타**: 반응형 기반
- **시맨틱 랜드마크**: `header/nav/main/section/article/aside/footer`
- **module 스크립트**: 의존성·스코프 관리 개선

---

## 4. 새로 추가된 시맨틱 태그 — 의미가 보인다

| 태그 | 용도 |
|---|---|
| `<header>` | 페이지/섹션 머릿말 |
| `<nav>` | 주요 탐색 링크 그룹 |
| `<main>` | 문서의 핵심 콘텐츠(문서당 1개 권장) |
| `<section>` | 주제별 구획(제목과 함께) |
| `<article>` | 독립 배포 가능한 콘텐츠 단위 |
| `<aside>` | 보조 정보(사이드바, 참고) |
| `<footer>` | 꼬리말, 저작권/관련 링크 |

접근성 팁
- 랜드마크는 스크린 리더의 **빠른 탐색 포인트**가 된다.
- 섹션에는 **적절한 헤딩 레벨** 사용(계층 보존).

---

## 5. 멀티미디어 — 플러그인 없이 비디오/오디오

```html
<video controls width="480" preload="metadata" poster="/thumb.jpg">
  <source src="/movie.mp4" type="video/mp4">
  해당 브라우저는 비디오 태그를 지원하지 않습니다.
</video>

<audio controls preload="none">
  <source src="/sound.mp3" type="audio/mpeg">
  오디오를 지원하지 않는 브라우저입니다.
</audio>
```

자막/접근성(텍스트 트랙)
```html
<video controls>
  <source src="/lecture.mp4" type="video/mp4">
  <track kind="captions" src="/lecture.ko.vtt" srclang="ko" label="자막(한글)" default>
</video>
```

성능 팁
- `preload="metadata"`로 초기 비용 절감
- 중요한 이미지/폰트/비디오에 **preload**·**media** 속성 활용

---

## 6. 폼(Forms) 강화 — HTML만으로도 많은 유효성 검사

HTML5 입력 타입
- `email`, `url`, `tel`, `number`, `range`, `date/time/datetime-local/month/week`, `color`, `search`

예제
```html
<form action="/signup" method="post" novalidate>
  <label for="email">이메일</label>
  <input id="email" name="email" type="email" required autocomplete="email" placeholder="you@example.com">

  <label for="pw">비밀번호</label>
  <input id="pw" name="pw" type="password" minlength="8" required>

  <label for="age">나이</label>
  <input id="age" name="age" type="number" min="0" max="120" step="1" inputmode="numeric">

  <button type="submit">가입</button>
</form>
```

포인트
- **기본 제약 조건(validation)**: `required/min/max/pattern/minlength` 등
- **서버 측 검증은 필수**(클라이언트 검증은 편의)
- 자동완성 힌트: `autocomplete="email"`, `new-password` 등

---

## 7. 그래픽 — Canvas 2D / SVG / WebGL 개요

### Canvas 2D 기본 드로잉
```html
<canvas id="c" width="300" height="150"></canvas>
<script>
  const ctx = document.getElementById('c').getContext('2d');
  ctx.fillStyle = '#1e88e5';
  ctx.fillRect(10, 10, 120, 80);
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 4;
  ctx.strokeRect(10, 10, 120, 80);
  ctx.beginPath();
  ctx.arc(180, 60, 40, 0, Math.PI * 2);
  ctx.fillStyle = '#ef5350';
  ctx.fill();
</script>
```

### SVG(벡터, DOM과 통합)
```html
<svg viewBox="0 0 200 100" width="300" height="150" role="img" aria-label="원과 사각형">
  <rect x="10" y="10" width="120" height="80" fill="#1e88e5" rx="8" />
  <circle cx="160" cy="50" r="30" fill="#ef5350"/>
</svg>
```

선택 가이드
- **Canvas**: 픽셀 기반, 애니메이션·게임·실시간 차트
- **SVG**: 벡터·반응형·상호작용(이벤트/스타일)·아이콘/도식
- **WebGL/WebGPU**: 3D·고성능 렌더링

---

## 8. 스토리지 — Web Storage와 IndexedDB

### Web Storage
```js
// localStorage: 지속 저장
localStorage.setItem('theme', 'dark');
const t = localStorage.getItem('theme');

// sessionStorage: 탭 수명
sessionStorage.setItem('once', 'true');
```

### IndexedDB(트랜잭션·대용량·구조화 데이터)
```js
const open = indexedDB.open('appdb', 1);
open.onupgradeneeded = () => {
  const db = open.result;
  if (!db.objectStoreNames.contains('notes')) {
    db.createObjectStore('notes', { keyPath: 'id' });
  }
};
open.onsuccess = () => {
  const db = open.result;
  const tx = db.transaction('notes', 'readwrite');
  tx.objectStore('notes').put({ id: 'n1', title: '메모', body: '내용' });
  tx.oncomplete = () => db.close();
};
```

보안/주의
- 민감 데이터는 **암호화/백엔드 저장** 고려.
- 용량/쿼터는 브라우저/기기별 상이.

---

## 9. 네트워킹 — Fetch API / WebSocket / CORS

### Fetch 기본
```js
const res = await fetch('/api/posts', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ title: '새 글' })
});
if (!res.ok) throw new Error('요청 실패');
const data = await res.json();
```

### CORS 개념
- **동일 출처 정책(SOP)**: 프로토콜/호스트/포트 삼중 일치 필요.
- 교차 출처 허용: 서버가 **CORS 헤더**(`Access-Control-Allow-Origin`)로 통제.

### WebSocket(양방향 실시간)
```js
const ws = new WebSocket('wss://example.com/realtime');
ws.onmessage = (e) => console.log('서버:', e.data);
ws.onopen = () => ws.send(JSON.stringify({ ping: Date.now() }));
```

---

## 10. 오프라인과 PWA — Service Worker + Manifest

### 웹 앱 매니페스트
```json
{
  "name": "내 PWA",
  "short_name": "내PWA",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#111111",
  "theme_color": "#111111",
  "icons": [
    { "src": "/icon-192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "/icon-512.png", "sizes": "512x512", "type": "image/png" }
  ]
}
```

### Service Worker(캐시 프록시)
```js
// sw.js
const CACHE = 'app-v1';
const ASSETS = ['/', '/styles.css', '/app.mjs', '/offline.html'];

self.addEventListener('install', e => {
  e.waitUntil(caches.open(CACHE).then(c => c.addAll(ASSETS)));
});

self.addEventListener('activate', e => {
  e.waitUntil(
    caches.keys().then(keys =>
      Promise.all(keys.filter(k => k !== CACHE).map(k => caches.delete(k))))
  );
});

self.addEventListener('fetch', e => {
  e.respondWith(
    caches.match(e.request).then(hit => hit || fetch(e.request).catch(
      () => caches.match('/offline.html')
    ))
  );
});
```

등록
```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js');
}
```

---

## 11. Web Workers — UI 멈춤 없이 백그라운드 작업

```js
// worker.js
self.onmessage = (e) => {
  const n = e.data;
  let sum = 0;
  for (let i = 0; i < n; i++) sum += i;
  self.postMessage(sum);
};

// main
const w = new Worker('/worker.js');
w.postMessage(10_000_000);
w.onmessage = (e) => console.log('합계:', e.data);
```

---

## 12. 히스토리/라우팅 — SPA의 기본 History API

```js
// 클라이언트 라우팅 기본
function go(path) {
  history.pushState({}, '', path);
  render(path);
}
window.addEventListener('popstate', () => render(location.pathname));
```

---

## 13. 접근성(A11y) — 랜드마크·레이블·포커스

체크리스트
- 랜드마크 태그(`header/nav/main/aside/footer`)로 구조 노출
- 폼 요소는 **레이블과 연결**: `<label for>` / `aria-label`
- 키보드 내비게이션: **tab 순서**와 DOM 순서를 일치
- 대비/모션 환경설정: `prefers-color-scheme`, `prefers-reduced-motion`
- 미디어 **대체 텍스트/자막/설명 오디오** 제공

예시: 스킵 링크
```html
<a href="#content" class="skip">본문 바로가기</a>
```

---

## 14. 보안 — 동일출처·CSP·Sandbox·postMessage

- **동일 출처 정책(SOP)**: 스크립트가 임의 출처에 접근 제한.
- **CSP(Content-Security-Policy)**: 스크립트/이미지/프레임 등 로드 출처 화이트리스트.
- **iframe sandbox**: 필요한 권한만 최소 허용.
- **postMessage**: 교차 출처 간 통신 시 **origin 검사** 필수.

CSP 예시(HTTP 응답 헤더)
```
Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.example; object-src 'none'; frame-ancestors 'self';
```

`postMessage` 안전 처리
```js
window.addEventListener('message', (e) => {
  if (e.origin !== 'https://trusted.example') return;
  // 안전한 처리
});
```

---

## 15. 성능 최적화 — 로딩/페인트/인터랙션

- **리소스 힌트**: `preconnect`, `dns-prefetch`, `preload`, `modulepreload`
- **이미지 최적화**: `srcset/sizes`, `loading="lazy"`, `decoding="async"`, `fetchpriority`
- **폰트**: `font-display: swap`, 서브셋, preload
- **CLS 방지**: 이미지/비디오에 고정 `width/height` 또는 `aspect-ratio`
- **HTTP/2+ 병렬성**과 **캐시 정책**(ETag/Cache-Control)

예시: 리소스 힌트
```html
<link rel="preconnect" href="https://cdn.example">
<link rel="preload" as="style" href="/theme.css">
<link rel="preload" as="image" href="/hero.webp" imagesrcset="/hero.webp 1x, /hero@2x.webp 2x">
```

---

## 16. HTML4 vs HTML5 — 차이 요약

| 항목 | HTML4 | HTML5 |
|---|---|---|
| DOCTYPE | DTD 기반, 복잡 | `<!DOCTYPE html>` 단일 |
| 구조 | `<div>` 중심 | 시맨틱 태그 대거 도입 |
| 멀티미디어 | 플러그인 의존 | `<audio>/<video>` 기본 |
| 폼 | 제한적 타입 | 다수 타입·기본 검증 |
| 그래픽 | 외부 플러그인 | `<canvas>`, SVG, WebGL |
| 스토리지 | 쿠키 위주 | Web Storage, IndexedDB |
| 오프라인 | 미비 | Service Worker, 캐시 |
| 실시간 | 제한 | WebSocket 등 |

---

## 17. 마이그레이션 가이드 — 실전 체크

- DOCTYPE·문자셋 선언 단순화: `<!DOCTYPE html>`, `<meta charset="UTF-8">`
- 레이아웃을 시맨틱 태그로 리팩터: 접근성·SEO 개선
- 폼 입력 타입 교체 + 기본 검증 활용(서버 검증은 필수 유지)
- 이미지 `srcset/sizes`·lazy 로딩 적용
- 모듈 스크립트/리소스 힌트로 초기 로딩 최적화
- 점진적 향상(폴리필/feature detection)로 구형 브라우저 대응

---

## 18. 샘플: 반응형 미니 앱(오프라인/저장/라우팅)

```html
<!DOCTYPE html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>HTML5 미니 앱</title>
<link rel="manifest" href="/manifest.webmanifest">
<style>
  body { margin:0; font:16px/1.6 system-ui, sans-serif; }
  header, footer { background:#111; color:#fff; padding:1rem; }
  main { padding:1rem; max-width: 72rem; margin:auto; }
  .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(16rem, 1fr)); gap:1rem; }
  .card { background:#f6f6f6; border-radius:12px; padding:1rem; }
  @media (prefers-color-scheme: dark) {
    body { background:#0e0e0e; color:#e5e5e5; }
    .card { background:#181818; }
  }
</style>
<header><h1>노트</h1></header>
<nav aria-label="메뉴">
  <button id="add">새 노트</button>
  <button onclick="go('/about')">소개</button>
</nav>
<main id="app" role="main"></main>
<footer>&copy; 2025</footer>

<script type="module">
  // 라우팅
  function viewHome() {
    const notes = JSON.parse(localStorage.getItem('notes') || '[]');
    document.getElementById('app').innerHTML = `
      <section aria-labelledby="home">
        <h2 id="home">내 노트</h2>
        <div class="grid">
          ${notes.map(n => `<article class="card"><h3>${n.title}</h3><p>${n.body}</p></article>`).join('') || '<p>아직 노트가 없습니다.</p>'}
        </div>
      </section>`;
  }
  function viewAbout() {
    document.getElementById('app').innerHTML = `
      <section aria-labelledby="about">
        <h2 id="about">소개</h2>
        <p>HTML5 기능을 최소 예제로 묶은 미니 앱입니다.</p>
      </section>`;
  }
  function render(path = location.pathname) {
    if (path === '/about') viewAbout(); else viewHome();
  }
  window.go = (p) => { history.pushState({}, '', p); render(p); };
  window.addEventListener('popstate', () => render());

  // 저장
  document.getElementById('add').addEventListener('click', () => {
    const title = prompt('제목?'); if (!title) return;
    const body  = prompt('내용?') || '';
    const notes = JSON.parse(localStorage.getItem('notes') || '[]');
    notes.unshift({ title, body, id: crypto.randomUUID() });
    localStorage.setItem('notes', JSON.stringify(notes));
    render();
  });

  // SW
  if ('serviceWorker' in navigator) navigator.serviceWorker.register('/sw.js');

  render();
</script>
```

이 예제는 다음을 보여준다:
- 시맨틱 구조 + 반응형 그리드
- LocalStorage를 활용한 간단 저장
- History API를 이용한 클라이언트 라우팅
- Service Worker 등록 훅

---

## 19. 흔한 실수와 대처

| 문제 | 원인 | 해결 |
|---|---|---|
| 레이아웃 시맨틱 부족 | div 남용 | `<main/section/article/aside>`로 구조 표현 |
| CORS 오류 | 서버 헤더 미설정 | 백엔드에서 `Access-Control-Allow-Origin` 등 설정 |
| CLS(레이아웃 흔들림) | 크기 미지정 이미지/광고 | `width/height` 또는 `aspect-ratio` 지정 |
| 접근성 낮음 | 레이블/랜드마크 누락 | `<label for>`, 헤딩 계층, 랜드마크 적용 |
| 오프라인 동작 불가 | SW 미구현/캐시 전략 부재 | Service Worker + Cache API |
| 성능 저하 | 무분별한 스크립트/폰트 | 리소스 힌트, 코드 분할, 폰트 최적화 |

---

## 20. 요약 — HTML5의 가치

- 시맨틱 구조로 **접근성/SEO/유지보수** 향상
- 멀티미디어/그래픽/스토리지/네트워킹/오프라인 등 **앱 수준 기능** 내장
- 표준 기반으로 **브라우저 간 일관성**과 **장기 호환성**
- CSS3, ES 모듈, 웹 API와 결합하면 **완결성 높은 웹 애플리케이션** 구축 가능

---

## 부록 A. HTML5 체크리스트

- [ ] `<!DOCTYPE html>` / `<meta charset="UTF-8">`
- [ ] `<html lang="ko">` / `<meta name="viewport">`
- [ ] 시맨틱 랜드마크와 헤딩 계층
- [ ] 폼 입력 타입/기본 검증 활용, 서버 검증 유지
- [ ] 이미지 `srcset/sizes`, `loading="lazy"`
- [ ] 모듈 스크립트, 리소스 힌트(preconnect/preload)
- [ ] Service Worker + Manifest(PWA)
- [ ] CSP/동일출처/postMessage 검증
- [ ] 접근성(레이블, 키보드, 대비, 자막)
- [ ] 성능(캐시, 폰트, CLS 방지)

---

## 부록 B. 더 나아가기

- ES Modules + Dynamic Import
- Streams API(대용량/점진 처리)
- Payment Request / Web Share / File System Access
- WebGPU(차세대 그래픽)
- WebRTC(실시간 미디어 통신)
