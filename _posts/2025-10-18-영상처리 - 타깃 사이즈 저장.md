---
layout: post
title: 영상처리 - 타깃 사이즈 저장
date: 2025-10-18 22:25:23 +0900
category: 영상처리
---
# 타깃 사이즈 저장 (Target Size Saving)

> **목표**
> - **`jpeg_mem_dest`** 를 이용해 결과를 메모리로 받으면서, **이진 탐색**으로 JPEG **출력 바이트**를 **목표 크기(예: 300KB/600KB)** 에 수렴시킵니다.
> - “사진(4:2:0) 300KB” / “상세(4:4:4) 600KB” 같은 **프리셋**을 쉽게 붙일 수 있는 **재사용 가능한 C++ 구현**을 제공합니다.
> - 코드는 한 번만 ``` 로 감싸며, 필요시 libjpeg-turbo 확장 색공간을 사용합니다.

---

## 설계 개요

### 왜 이진 탐색?

- `jpeg_set_quality(q)`의 **q(0~100)** ↔ **출력 바이트** 간 대응은 **단조 증가** 경향이 강하지만,
  - **허프만 최적화**(`optimize_coding`)나 **프로그레시브 모드**에서는 **완전 단조**가 아닐 수 있습니다.
- 따라서 **상·하한을 잡고 반복**하며,
  1) **목표 이하** 후보 중 **가장 큰 바이트**를 **최선(bestUnder)** 으로 기록,
  2) 혹시 전 구간이 목표를 못 넘기면(=모두 초과) **가장 작은 바이트(bestOverall)** 를 반환합니다.

### 주요 선택지(품질/용량에 영향 큰 항목)

- **샘플링**: 사진은 **4:2:0**, UI·문서·텍스트는 **4:4:4**(엣지 보존).
- **허프만 최적화**: `cinfo.optimize_coding = TRUE` → 일반적으로 용량 감소.
- **프로그레시브**: 저품질 q라도 시각상 계조가 좋아 보일 수 있음(웹 전송에도 우호적).
- **리스타트 마커**: 네트워크/부분 손상 내성 ↑, 용량 소폭 증가.

---

## 사용 예 (요약)

```cpp
// BGRA 8bpc 버퍼 → 사진(420) 300KB 목표
std::vector<uint8_t> jpeg300;
int finalQ300 = 0;
EncodeJPEG_TargetSize_BGRA(
    bgraPtr, width, height, strideBGRA,
    /*targetBytes=*/300*1024,
    /*subsampling=*/JpegSubsampling::YUV420,
    /*progressive=*/true,
    /*optimizeCoding=*/true,
    /*restartIntervalMCUs=*/0, // 0=off
    finalQ300, jpeg300);

// UI/문서(444) 600KB 목표
std::vector<uint8_t> jpeg600;
int finalQ600 = 0;
EncodeJPEG_TargetSize_BGRA(
    bgraPtr, width, height, strideBGRA,
    /*targetBytes=*/600*1024,
    /*subsampling=*/JpegSubsampling::YUV444,
    /*progressive=*/true,
    /*optimizeCoding=*/true,
    /*restartIntervalMCUs=*/0,
    finalQ600, jpeg600);
```

---

## 전체 구현 (안전한 에러 복구 + 메모리 목적지 + 이진 탐색)

```cpp
#include <jpeglib.h>
#include <vector>
#include <cstdint>
#include <cstring>
#include <string>
#include <stdexcept>
#include <algorithm>
#include <csetjmp>
#include <memory>

// ---------- 에러 핸들러(setjmp) ----------
struct JpegErrorMgr {
    jpeg_error_mgr pub;
    jmp_buf jb;
    static void error_exit(j_common_ptr cinfo) {
        JpegErrorMgr* self = (JpegErrorMgr*)cinfo->err;
        // 원하면 로그: (*cinfo->err->output_message)(cinfo);
        longjmp(self->jb, 1);
    }
};

// ---------- 샘플링 프리셋 ----------
enum class JpegSubsampling { YUV420, YUV444 };

static void SetSubsampling(j_compress_ptr cinfo, JpegSubsampling ss) {
    // jpeg_set_defaults 이후, 색공간/컴포넌트 설정이 끝난 뒤 조정
    // comp_info[0]=Y, [1]=Cb, [2]=Cr
    if (cinfo->num_components < 3) return; // grayscale면 skip
    if (ss == JpegSubsampling::YUV420) {
        cinfo->comp_info[0].h_samp_factor = 2;
        cinfo->comp_info[0].v_samp_factor = 2;
        cinfo->comp_info[1].h_samp_factor = 1;
        cinfo->comp_info[1].v_samp_factor = 1;
        cinfo->comp_info[2].h_samp_factor = 1;
        cinfo->comp_info[2].v_samp_factor = 1;
    } else { // 4:4:4
        cinfo->comp_info[0].h_samp_factor = 1;
        cinfo->comp_info[0].v_samp_factor = 1;
        cinfo->comp_info[1].h_samp_factor = 1;
        cinfo->comp_info[1].v_samp_factor = 1;
        cinfo->comp_info[2].h_samp_factor = 1;
        cinfo->comp_info[2].v_samp_factor = 1;
    }
}

// ---------- 한 번 품질 q로 인코드(메모리 목적지) ----------
struct JpegMem {
    unsigned char* buf = nullptr; // libjpeg이 malloc
    unsigned long  len = 0;
    ~JpegMem(){ if (buf) free(buf); }
};

static bool EncodeOnce_BGRA_ToMem(const uint8_t* bgra, int w, int h, int strideBGRA,
                                  int quality, JpegSubsampling ss,
                                  bool progressive, bool optimizeCoding,
                                  int restartIntervalMCUs,
                                  JpegMem& out)
{
    out.buf = nullptr; out.len = 0;

    JpegErrorMgr jerr{};
    jpeg_compress_struct cinfo{};
    cinfo.err = jpeg_std_error(&jerr.pub);
    jerr.pub.error_exit = JpegErrorMgr::error_exit;
    if (setjmp(jerr.jb)) { jpeg_destroy_compress(&cinfo); return false; }

    jpeg_create_compress(&cinfo);
    jpeg_mem_dest(&cinfo, &out.buf, &out.len); // 결과를 메모리로

    // libjpeg-turbo 확장 색공간이 있다면 BGRA/BGRX를 직접 넣기
#ifdef JCS_EXTENSIONS

    cinfo.in_color_space   = JCS_EXT_BGRX; // BGRA와 메모리 호환(알파는 무시)
    cinfo.input_components = 4;
#else

    cinfo.in_color_space   = JCS_RGB;      // 표준 libjpeg이면 RGB로 변환 필요
    cinfo.input_components = 3;
#endif

    cinfo.image_width  = w;
    cinfo.image_height = h;

    jpeg_set_defaults(&cinfo);
    // YCbCr 색공간으로 변환(기본)
    jpeg_set_colorspace(&cinfo, JCS_YCbCr);

    // 샘플링 설정(420/444)
    SetSubsampling(&cinfo, ss);

    // 품질/옵션
    jpeg_set_quality(&cinfo, quality, TRUE /*limit to baseline tables*/);
    cinfo.optimize_coding = optimizeCoding ? TRUE : FALSE;

    if (progressive) jpeg_simple_progression(&cinfo);

    if (restartIntervalMCUs > 0) {
        cinfo.restart_interval = restartIntervalMCUs; // MCU 단위
        cinfo.restart_in_rows  = 0;
    }

    jpeg_start_compress(&cinfo, TRUE);

#ifndef JCS_EXTENSIONS

    // RGB 변환 버퍼(표준 libjpeg일 때만)
    std::vector<uint8_t> rowRGB((size_t)w*3);
#endif

    while (cinfo.next_scanline < cinfo.image_height) {
        const uint8_t* src = bgra + (size_t)strideBGRA * cinfo.next_scanline;
#ifdef JCS_EXTENSIONS

        JSAMPROW row = const_cast<JSAMPROW>(src);
#else

        // BGRA → RGB 변환
        for (int x=0; x<w; ++x) {
            rowRGB[3*x+0] = src[4*x+2]; // R
            rowRGB[3*x+1] = src[4*x+1]; // G
            rowRGB[3*x+2] = src[4*x+0]; // B
        }
        JSAMPROW row = rowRGB.data();
#endif

        jpeg_write_scanlines(&cinfo, &row, 1);
    }

    jpeg_finish_compress(&cinfo);
    jpeg_destroy_compress(&cinfo);
    return true;
}

// ---------- 이진 탐색(목표 바이트 수렴) ----------
struct TargetResult {
    std::vector<uint8_t> bytes;
    int quality = 0;
    bool hit = false; // 목표 이하를 만족했는가
};

bool EncodeJPEG_TargetSize_BGRA(const uint8_t* bgra, int w, int h, int strideBGRA,
                                size_t targetBytes,
                                JpegSubsampling ss,
                                bool progressive,
                                bool optimizeCoding,
                                int restartIntervalMCUs,
                                int& outFinalQuality,
                                std::vector<uint8_t>& outBytes,
                                int minQ = 20, int maxQ = 95,
                                int maxIters = 8,
                                double toleranceRatio = 0.02 /*±2%면 조기 성공*/)
{
    outBytes.clear();
    outFinalQuality = 0;
    if (w<=0 || h<=0 || !bgra) return false;

    // 사전 방어: 너무 작은/큰 목표 방지
    if (targetBytes < 1024) targetBytes = 1024;

    // 경계 평가
    auto tryQ = [&](int q, TargetResult& tr)->bool{
        JpegMem mem;
        if (!EncodeOnce_BGRA_ToMem(bgra, w, h, strideBGRA, q, ss, progressive, optimizeCoding, restartIntervalMCUs, mem))
            return false;
        tr.bytes.assign(mem.buf, mem.buf + mem.len);
        tr.quality = q;
        tr.hit = (tr.bytes.size() <= targetBytes);
        return true;
    };

    TargetResult bestUnder;      // 목표 이내에서 가장 큰 바이트
    TargetResult bestOverall;    // 전체 중 가장 작은 바이트(만약 전부 초과하면 반환)
    bestUnder.quality = -1;
    bestOverall.quality = -1;

    // 먼저 경계 두 점 평가
    TargetResult loRes, hiRes;
    if (!tryQ(minQ, loRes)) return false;
    if (!tryQ(maxQ, hiRes)) return false;

    bestOverall = (loRes.bytes.size() < hiRes.bytes.size()) ? loRes : hiRes;
    if (loRes.hit) bestUnder = loRes;
    if (hiRes.hit && (!bestUnder.hit || hiRes.bytes.size() > bestUnder.bytes.size())) bestUnder = hiRes;

    // 조기 종료 케이스
    auto withinTol = [&](size_t sz){
        double diff = (double)std::llabs((long long)sz - (long long)targetBytes) / (double)targetBytes;
        return diff <= toleranceRatio;
    };
    if (withinTol(loRes.bytes.size())) { outBytes = loRes.bytes; outFinalQuality = loRes.quality; return true; }
    if (withinTol(hiRes.bytes.size())) { outBytes = hiRes.bytes; outFinalQuality = hiRes.quality; return true; }

    int lo = std::min(loRes.quality, hiRes.quality);
    int hi = std::max(loRes.quality, hiRes.quality);

    for (int it=0; it<maxIters && lo<=hi; ++it) {
        int mid = (lo + hi) / 2;
        TargetResult mr;
        if (!tryQ(mid, mr)) break;

        // 전체 최소 갱신
        if (bestOverall.quality < 0 || mr.bytes.size() < bestOverall.bytes.size())
            bestOverall = mr;

        // 목표 이내 최선 갱신
        if (mr.hit && (!bestUnder.hit || mr.bytes.size() > bestUnder.bytes.size()))
            bestUnder = mr;

        if (withinTol(mr.bytes.size())) {
            outBytes = mr.bytes; outFinalQuality = mr.quality; return true;
        }

        // 분기
        if (mr.bytes.size() > targetBytes) {
            // 너무 큼 → 품질 낮춤
            hi = mid - 1;
        } else {
            // 여유 있음 → 품질 올림
            lo = mid + 1;
        }
    }

    // 최종 선택: 목표 이내 후보가 있으면 그것, 없으면 전체 최소
    if (bestUnder.hit) {
        outBytes = bestUnder.bytes;
        outFinalQuality = bestUnder.quality;
        return true;
    } else {
        outBytes = bestOverall.bytes;
        outFinalQuality = bestOverall.quality;
        return true; // 목표를 못 맞췄지만 최선 반환
    }
}
```

### 구현 포인트

- **메모리 목적지**: `jpeg_mem_dest(&cinfo, &buf, &len)` → libjpeg가 할당한 `buf`는 `free()` 로 해제.
- **BGRA 입력**: libjpeg-turbo가 있으면 `JCS_EXT_BGRX`로 **직접** 투입(알파 무시) → 복사/변환 비용 제로.
  - 표준 libjpeg만 쓰면 루프에서 **BGRA→RGB** 변환.
- **프로그레시브/허프만 최적화**는 결과 바이트에 영향을 줍니다.
- **재시도 횟수**: 7~8회면 충분히 수렴(이진 탐색).

---

## 300KB / 600KB 프리셋 헬퍼

```cpp
// 사진(420) 300KB
bool SaveAs_300KB_Photo(const uint8_t* bgra, int w, int h, int stride,
                        std::vector<uint8_t>& outBytes, int& finalQ)
{
    return EncodeJPEG_TargetSize_BGRA(
        bgra, w, h, stride,
        300*1024,
        JpegSubsampling::YUV420,
        /*progressive=*/true,
        /*optimizeCoding=*/true,
        /*restartIntervalMCUs=*/0,
        finalQ, outBytes,
        /*minQ=*/20, /*maxQ=*/95, /*maxIters=*/8, /*tol=*/0.02);
}

// 상세(444) 600KB (UI/문서/일러스트 추천)
bool SaveAs_600KB_Detail(const uint8_t* bgra, int w, int h, int stride,
                         std::vector<uint8_t>& outBytes, int& finalQ)
{
    return EncodeJPEG_TargetSize_BGRA(
        bgra, w, h, stride,
        600*1024,
        JpegSubsampling::YUV444,
        /*progressive=*/true,
        /*optimizeCoding=*/true,
        /*restartIntervalMCUs=*/0,
        finalQ, outBytes,
        /*minQ=*/30, /*maxQ=*/98, /*maxIters=*/8, /*tol=*/0.02);
}
```

> **권장 기본값**
> - 300KB: **420 + Progressive + OptimizeCoding**
> - 600KB: **444 + Progressive + OptimizeCoding**
> (브랜드 컬러/텍스트 보존이 중요하면 444가 유리)

---

## 실전 상황 & 팁

### 목표가 지나치게 작을 때

- **최소 품질(minQ)** 로도 초과 → 함수는 **가장 작은 결과**(bestOverall)를 반환합니다.
- 자동 대안:
  1) **샘플링 다운**(444→420),
  2) **경미한 리사이즈**(예: 긴 변 2048→1600),
  3) **선샤픈→낮은 q**보다 **리사이즈→높은 q**가 시각적으로 좋을 때가 많음.

### 목표를 너무 쉽게 달성(품질 남음)

- **최대 품질(maxQ)** 에도 여유 → **maxQ 결과**가 반환(용량이 목표보다 훨씬 낮을 수도).
- 필요하면 `maxQ` 를 100까지 올려 재탐색(단, baseline 제한 해제 시 호환성 확인).

### 단조 위반(드물지만)

- 프로그레시브 + 허프만 최적화 조합에서 **q1<q2인데 바이트가 역전**될 수 있음.
- 본 구현은 **bestUnder/bestOverall** 로 안전하게 고릅니다.

### 리스타트 마커

- `restartIntervalMCUs` 를 8~16 등으로 주면 **손상 내성**↑, **디코드 평행 처리**에 유리.
- 용량은 약간 ↑ → 타깃 근방에서 q가 한 단계 낮아질 수 있음.

### 메타데이터

- EXIF/ICC/XMP를 **키우면** 결과 바이트가 커집니다.
- “타깃 엄수”가 최우선이면, **썸네일 제거/메타 스트립 옵션**을 두세요.

---

## 간단한 “파일로 저장” 예시

```cpp
#include <cstdio>

bool SaveBytesToFile(const char* path, const std::vector<uint8_t>& bytes) {
    FILE* f = std::fopen(path, "wb"); if (!f) return false;
    size_t n = std::fwrite(bytes.data(), 1, bytes.size(), f);
    std::fclose(f);
    return n == bytes.size();
}

// 사용
// int finalQ; std::vector<uint8_t> out;
// if (SaveAs_300KB_Photo(bgra,w,h,stride,out,finalQ)) SaveBytesToFile("photo_300k.jpg", out);
// if (SaveAs_600KB_Detail(bgra,w,h,stride,out,finalQ)) SaveBytesToFile("detail_600k.jpg", out);
```

---

## UI 통합 아이디어 (ImageTool)

- [파일→내보내기]에 **“크기 타깃(JPEG)”** 서브메뉴 추가
  - 300KB(사진/420), 600KB(상세/444), 사용자 정의(입력 KB)
- 대화상자에 **프로그레시브/허프만 최적화/리스타트 마커** 체크
- 완료 후 **최종 quality** 를 상태바에 표시(기록/회귀 테스트용)

---

## 성능/품질 튜닝 체크리스트

- [x] **libjpeg-turbo** 사용 시 입력 색공간을 `JCS_EXT_BGRX` 로 두어 **행 변환 제거**
- [x] **프로그레시브**: 저대역에서도 체감 화질 좋음(특히 인물/풍경)
- [x] **허프만 최적화**: 보통 **용량↓** (시간↑). 배치에 적합
- [x] **샘플링**: 사진=420, 텍스트/UI=444
- [x] **최대 반복** 7~8회면 충분. 로그로 **최종 바이트/quality/시간**을 남기면 회귀 분석에 유용

---

## 요약

- **`jpeg_mem_dest` + 이진 탐색**으로 JPEG를 **목표 바이트**에 안정적으로 수렴시킬 수 있습니다.
- **300KB(420)/600KB(444)** 프리셋을 제공해 **일관된 결과**를 만들고,
- 프로그레시브/허프만 최적화/리스타트 마커 등 **전송·복원성 옵션**을 상황에 맞게 조합하세요.
- 포스트 프로덕션에서는 **타깃 실패 시 자동 리사이즈** 같은 백오프 정책을 더해 실무 신뢰도를 높일 수 있습니다.
