---
layout: post
title: JavaScript - DOM
date: 2025-05-13 19:20:23 +0900
category: JavaScript
---
# DOM(Document Object Model) 조작

## DOM 기본 개념

### DOM이란

- HTML을 **트리 구조의 객체**로 표현한 것. 각 태그는 **노드**(element/text/comment 등).
- **DOM**(구조/내용)과 **CSSOM**(스타일 규칙)은 별도이며, **렌더 트리**에서 결합되어 레이아웃/페인트가 수행됩니다.

```html
<body>
  <div id="greeting">Hello</div>
</body>
```

```js
document.body;                         // <body> …
document.getElementById("greeting");   // <div id="greeting">…
```

### 노드 타입 간단 표

| 타입                      | 예시                |
|--------------------------|---------------------|
| `Element`                | `<div>`, `<input>`  |
| `Text`                   | 텍스트 노드         |
| `Comment`                | `<!-- … -->`        |
| `Document`               | `document`          |
| `DocumentFragment`       | 임시 컨테이너       |

---

## 요소 선택 (Query)

### 기본 메서드

```js
document.getElementById("title");      // 단일
document.getElementsByClassName("x");  // HTMLCollection(라이브)
document.getElementsByTagName("li");   // HTMLCollection(라이브)
document.querySelector(".item");       // 단일 (정적)
document.querySelectorAll("ul li");    // NodeList(정적, forEach O)
```

**라이브 vs 정적**
- `getElementsBy*` → **라이브**(DOM 변경 시 자동 반영)
- `querySelector(All)` → **정적** 스냅샷

### CSS 선택 팁

- 조합 선택자를 활용하되, **최소한의 범위**(컨테이너 기준 `container.querySelector`)로 좁히면 성능/명확성↑.

### `matches`와 `closest`

```js
el.matches(".btn.primary");  // 현재 요소가 셀렉터와 일치?
el.closest("[data-card]");   // 조상 중 가장 가까운 후보
```

---

## 내용 조작 (Text/HTML)

### `textContent` / `innerText` / `innerHTML`

```js
el.textContent = "문자 그대로";           // 빠름, 안전, 스타일 반영 X
el.innerText   = "보이는 텍스트 기준";     // 스타일/레이아웃 영향(리플로우 가능)
el.innerHTML   = "<b>굵게</b>";           // HTML 파싱(보안 주의)
```

| 속성          | HTML 파싱 | 레이아웃 영향 | 보안 위험 |
|---------------|-----------|---------------|-----------|
| `textContent` | ❌        | ❌            | 낮음      |
| `innerText`   | ❌        | ✅            | 낮음      |
| `innerHTML`   | ✅        | ✅            | 높음(XSS) |

### 안전 삽입 패턴

```js
const msg = document.createTextNode(userInput);
el.textContent = userInput;            // 가장 안전
```

### `insertAdjacentHTML` (부분 삽입)

```js
el.insertAdjacentHTML("beforeend", "<li>항목</li>");
// 위치: "beforebegin" | "afterbegin" | "beforeend" | "afterend"
```

---

## 속성·프로퍼티·dataset

### 속성 vs 프로퍼티

- **속성(Attribute)**: 마크업의 문자열 값
- **프로퍼티(Property)**: DOM 객체의 실제 값(타입 보존)

```js
const input = document.querySelector("input");
input.setAttribute("value", "A"); // 초기 값
input.value = "B";                // 현재 값(프로퍼티)
```

### 불리언 속성

```js
checkbox.checked = true;          // 프로퍼티(권장)
checkbox.setAttribute("checked",""); // 존재=참(HTML)
```

### `dataset` (data-* 커스텀 데이터)

```html
<li data-id="42" data-state-active="yes"></li>
```

```js
el.dataset.id;            // "42"
el.dataset.stateActive;   // "yes" (kebab → camel)
el.dataset.foo = "bar";   // data-foo="bar" 반영
```

---

## 클래스·스타일

### 클래스

```js
el.classList.add("active");
el.classList.remove("active");
el.classList.toggle("active", /*force*/ true);
el.classList.contains("active");
```

### 인라인 스타일과 계산 스타일

```js
el.style.backgroundColor = "tomato";
Object.assign(el.style, { color: "white", padding: "8px" });

getComputedStyle(el).marginLeft;    // 계산된 스타일 읽기(읽기는 성능상 안전)
```

### CSS 변수 제어

```css
:root { --brand: #4f46e5; }
```
```js
document.documentElement.style.setProperty("--brand", "#1e293b");
```

---

## 생성·삽입·삭제

### 기본 API

```js
const li = document.createElement("li");
li.textContent = "새 항목";

// 위치 유연한 메서드
list.append(li);       // 마지막 자식
list.prepend(li);      // 첫 자식
list.before(li);       // 형제 이전
list.after(li);        // 형제 다음
old.replaceWith(li);   // 교체
li.remove();           // 제거
```

### `DocumentFragment`로 배치 삽입(성능)

```js
const frag = document.createDocumentFragment();
for (let i=0; i<1000; i++) {
  const li = document.createElement("li");
  li.textContent = `Item ${i}`;
  frag.append(li);
}
list.append(frag); // 한 번에 삽입 → reflow 최소화
```

### `<template>` 활용

```html
<template id="card-tpl">
  <article class="card">
    <h3 class="title"></h3>
    <p class="body"></p>
  </article>
</template>
```
```js
const tpl = document.getElementById("card-tpl");
const node = tpl.content.cloneNode(true);
node.querySelector(".title").textContent = "제목";
node.querySelector(".body").textContent  = "내용";
container.append(node);
```

### Range API (정교한 삽입/래핑)

```js
const range = document.createRange();
range.setStart(p.firstChild, 0);
range.setEnd(p.firstChild, 5);
const wrap = document.createElement("strong");
range.surroundContents(wrap);  // 선택 영역 감싸기
```

---

## 이벤트 (Event)

### 기본과 옵션

```js
el.addEventListener("click", handler, {
  capture: false,   // 캡처 단계에서 처리할지
  once: true,       // 한 번만
  passive: true     // 스크롤 성능 향상(기본 동작 방지 불가)
});
```

### 버블링/위임(성능·유지보수 최강 패턴)

```js
list.addEventListener("click", (e) => {
  const li = e.target.closest("li");
  if (!li || !list.contains(li)) return;
  // li 클릭 대응
});
```

### `preventDefault` / `stopPropagation`

```js
a.addEventListener("click", (e) => {
  e.preventDefault();    // 기본 동작(네비게이션) 취소
  e.stopPropagation();   // 버블링 중단
});
```

### `CustomEvent`

```js
const ev = new CustomEvent("cart:add", { detail: { id: 42 }});
document.dispatchEvent(ev);
document.addEventListener("cart:add", (e)=>console.log(e.detail.id));
```

---

## 트리 탐색

```js
el.parentElement;
el.children;                 // HTMLCollection(라이브)
el.firstElementChild;
el.lastElementChild;
el.nextElementSibling;
el.previousElementSibling;
```

### 고급 순회기: `TreeWalker`/`NodeIterator`

```js
const walker = document.createTreeWalker(
  document.body,
  NodeFilter.SHOW_ELEMENT,
  { acceptNode: (node) => node.matches(".item") ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP }
);
let cur = walker.nextNode();
while (cur) { /* … */ cur = walker.nextNode(); }
```

---

## 폼(Form) 처리

### `FormData`로 직렬화

```js
form.addEventListener("submit", (e) => {
  e.preventDefault();
  const fd = new FormData(form);
  // fd.get('name'); fd.entries();
  fetch("/api", { method:"POST", body: fd });
});
```

### 브라우저 검증 API

```js
if (!input.checkValidity()) {
  input.reportValidity();
}
input.setCustomValidity("형식을 확인하세요"); // 커스텀 메시지
```

---

## 성능 (Reflow/Repaint/관찰자)

### 레이아웃 스로틀

- **읽기(측정)**와 **쓰기(변경)**를 **배치**하세요. 교차하면 **Layout Thrashing** 발생.

```js
// 나쁨: 읽기-쓰기-읽기-쓰기 반복
const w = el.offsetWidth; el.style.width = (w+10)+"px";
// 좋음: 먼저 읽기 모으고, 그 다음 쓰기
const w = el.offsetWidth;
requestAnimationFrame(()=> { el.style.width = (w+10)+"px"; });
```

### `IntersectionObserver`로 지연 로딩

```js
const io = new IntersectionObserver((entries)=>{
  entries.forEach(e => {
    if (e.isIntersecting) {
      const img = e.target;
      img.src = img.dataset.src;
      io.unobserve(img);
    }
  });
});
document.querySelectorAll("img[data-src]").forEach(img=>io.observe(img));
```

---

## 보안 (XSS/CSP/Trusted Types)

### XSS 방지 핵심

- **사용자 입력 → `textContent`/`createTextNode`**로 삽입
- HTML 필요 시 **화이트리스트 기반 Sanitizer**(예: DOMPurify)

```js
// 위험
el.innerHTML = userInput; // ❌
// 안전
el.textContent = userInput; // ✅
```

### CSP (Content Security Policy)

- 인라인 스크립트 차단, 허용 도메인 제한 → XSS 피해 축소.

### Trusted Types (지원 환경)

- DOM Sink(`innerHTML` 등)에 허용된 팩토리 결과만 전달.

---

## 접근성 (A11y)

### 포커스/키보드

```js
btn.setAttribute("tabindex", "0");
btn.focus();  // 적절한 시점에만
```

- 키보드 내비 지원: `keydown`에서 `Enter`/`Space` 처리.
- `role`/`aria-*`로 의미 전달.

```html
<div role="button" aria-pressed="false" tabindex="0">Toggle</div>
```

### 상태 변경 시 ARIA 업데이트

```js
toggleEl.setAttribute("aria-pressed", String(isOn));
```

---

## Shadow DOM 기초

```js
const host = document.querySelector("#host");
const shadow = host.attachShadow({ mode: "open" });
shadow.innerHTML = `<style>.red{color:red}</style><span class="red"><slot></slot></span>`;
```

- 스타일/구조 **캡슐화**.
- 이벤트는 **리타게팅**되어 외부에선 호스트 기준처럼 보임(`e.target` 주의).

---

## 변경 감시: `MutationObserver`

```js
const mo = new MutationObserver((mutations)=>{
  for (const m of mutations) {
    if (m.type === "childList") { /* 추가/삭제 처리 */ }
    if (m.type === "attributes" && m.attributeName === "class") { /* … */ }
  }
});
mo.observe(container, { childList: true, subtree: true, attributes: true });
```

---

## 유틸: 복제/측정/스크롤

```js
const copy = node.cloneNode(true);          // 깊은 복제
el.getBoundingClientRect();                 // 레이아웃 박스
el.scrollIntoView({ behavior: "smooth" });  // 스크롤
```

---

## 실전 예제: 대량 항목 추가 + 위임 + 배치 렌더

```html
<ul id="list" class="items"></ul>
<button id="add">1000개 추가</button>
```

```js
const list = document.getElementById("list");
const add  = document.getElementById("add");

// 이벤트 위임: li 클릭 시 활성화 토글
list.addEventListener("click", (e) => {
  const li = e.target.closest("li");
  if (!li || !list.contains(li)) return;
  li.classList.toggle("active");
});

// 대량 추가: Fragment + rAF로 배치
add.addEventListener("click", () => {
  const frag = document.createDocumentFragment();
  for (let i = 0; i < 1000; i++) {
    const li = document.createElement("li");
    li.textContent = `Item ${list.children.length + i + 1}`;
    frag.append(li);
  }
  // 다음 프레임에 한 번에 반영(레이아웃 최소화)
  requestAnimationFrame(() => list.append(frag));
});
```

---

## 디버깅 팁 (DevTools)

- **Elements 패널**: 노드 실시간 편집, 이벤트 리스너 확인.
- **Break on** → *Subtree modifications* / *Attribute changes*로 **DOM 변경 시점 브레이크포인트**.
- **Performance**: Recalculate Style/Layout 타임라인 확인.

---

## 체크리스트 (요약)

- [ ] 선택은 **컨테이너 기준**으로 좁혀서 (`container.querySelector`)
- [ ] 텍스트는 `textContent` 사용, HTML 삽입은 **정말 필요할 때만** + Sanitizer
- [ ] 대량 삽입은 **`DocumentFragment`/`<template>`/배치**
- [ ] 이벤트는 **위임** + `once`/`passive` 적절히
- [ ] 레이아웃 **읽기/쓰기 분리** + `requestAnimationFrame`
- [ ] 이미지/섹션 지연 로딩은 `IntersectionObserver`
- [ ] 접근성: **role/aria/tabindex**와 포커스 관리
- [ ] 클린업: **리스너/타이머 해제**로 누수 방지
- [ ] 보안: **XSS/CSP/Trusted Types** 고려

---

## 부록: 미니 퀴즈

```js
// Q1) 다음 중 라이브 컬렉션은?
document.getElementsByClassName("a")
document.querySelectorAll(".a")

// Q2) 아래 코드의 XSS 취약 지점과 수정?
el.innerHTML = `<p>${userInput}</p>`;

// Q3) Layout Thrashing을 줄이려면?
// (힌트: 읽기/쓰기 분리 + rAF)

// Q4) 대량 노드 삽입 성능 최적화 3가지?
// (힌트: Fragment, template, 하나의 append)

// Q5) 버튼 1000개 클릭을 효율적으로 처리하는 패턴?
// (힌트: 이벤트 위임)
```

**힌트**
- Q1: `getElementsByClassName`(라이브), `querySelectorAll`(정적)
- Q2: `textContent`로 안전 삽입(또는 Sanitizer)
- Q3: 측정 후 rAF에서 쓰기 배치
- Q4: Fragment 사용/`<template>` 클론/한 번의 DOM 반영
- Q5: 컨테이너에 `click` 리스너 1개(위임)
