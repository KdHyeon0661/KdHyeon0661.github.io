---
layout: post
title: AspNet - 서버 유효성 검사
date: 2025-02-24 20:20:23 +0900
category: AspNet
---
# ASP.NET Core에서 서버 유효성 검사 완전 정복

## 0. 서버 유효성 검사의 목적과 원리

- 브라우저의 JS 검증은 **편의**일 뿐, 우회 가능하다.  
- 최종 수문장은 **서버**다. 모델 바인딩 → ModelState 채움 → 데이터 주석 및 커스텀 로직으로 검증 → 유효하지 않으면 처리 중단 및 오류 반환.
- 핵심은 다음 두 가지를 명확히 구분하는 것이다.
  1) **형식·제약 검증**: Required, Range, Regex 같은 **스키마 수준** 규칙  
  2) **업무 규칙 검증**: 이메일 중복, 재고 수량, 시점 제약 등 **도메인 규칙**

---

## 1. 요청→모델 바인딩→ModelState→검증 흐름

요약 순서:
1) 폼 POST 또는 JSON 요청 수신  
2) **Model Binding**: 이름 매칭 규칙에 따라 값 → 모델 속성으로 매핑  
3) **Validation**: Data Annotations(속성/객체) + 커스텀 검사  
4) **ModelState**에 오류 누적  
5) `ModelState.IsValid` 체크 → 실패 시 재렌더링 또는 400/ProblemDetails

핵심 규칙:
- 바인딩이 실패해도 ModelState에 항목이 생성될 수 있다.  
- 값 변환 실패(예: "abc"→int)는 **형식 오류**로 ModelState에 들어간다.  
- 검증은 속성 단위 → 객체 단위 순서로 수행된다.

---

## 2. Data Annotations 기본과 확장

### 2.1 기본 예제(개선 버전)

```csharp
public class ContactModel
{
    [Required(ErrorMessage = "이름은 필수입니다.")]
    [StringLength(50, ErrorMessage = "이름은 최대 50자입니다.")]
    public string Name { get; set; } = "";

    [Required(ErrorMessage = "이메일은 필수입니다.")]
    [EmailAddress(ErrorMessage = "이메일 형식이 잘못되었습니다.")]
    public string Email { get; set; } = "";

    [Range(1, 120, ErrorMessage = "나이는 1~120 범위여야 합니다.")]
    public int Age { get; set; }
}
```

주요 특성:
- `[Required]`, `[StringLength]`, `[Range]`, `[RegularExpression]`, `[Compare]`, `[EmailAddress]` 등
- `[DataType]`은 UI 힌트이므로 검증 기능은 아님(단, 일부 태그헬퍼 렌더링에 영향)

### 2.2 컬렉션·중첩 모델

```csharp
public class OrderItem
{
    [Required, StringLength(100)]
    public string ProductName { get; set; } = "";

    [Range(1, int.MaxValue)]
    public int Quantity { get; set; }

    [Range(0, double.MaxValue)]
    public decimal UnitPrice { get; set; }
}

public class OrderInput
{
    [Required]
    public string CustomerName { get; set; } = "";

    [MinLength(1, ErrorMessage = "주문 항목은 1개 이상이어야 합니다.")]
    public List<OrderItem> Items { get; set; } = new();
}
```

검증 결과는 `ModelState` 키로 `Items[0].Quantity` 같은 인덱스 경로에 매핑된다.

### 2.3 객체 수준 검증(IValidatableObject)

속성 간 상관 규칙 같은 **교차 검증**에 적합:

```csharp
using System.ComponentModel.DataAnnotations;

public class DateRangeModel : IValidatableObject
{
    [Required] public DateTime Start { get; set; }
    [Required] public DateTime End { get; set; }

    public IEnumerable<ValidationResult> Validate(ValidationContext context)
    {
        if (End < Start)
        {
            yield return new ValidationResult(
                "종료일은 시작일 이후여야 합니다.",
                new[] { nameof(Start), nameof(End) }
            );
        }
    }
}
```

### 2.4 커스텀 ValidationAttribute

```csharp
public sealed class NotDisposableEmailAttribute : ValidationAttribute
{
    private static readonly string[] Blocked = { "mailinator.com", "guerrillamail.com" };

    protected override ValidationResult? IsValid(object? value, ValidationContext ctx)
    {
        if (value is string email && email.Contains('@'))
        {
            var domain = email.Split('@')[1];
            if (Blocked.Contains(domain, StringComparer.OrdinalIgnoreCase))
                return new ValidationResult("임시 이메일 도메인은 허용되지 않습니다.");
        }
        return ValidationResult.Success;
    }
}

public class RegisterInput
{
    [Required, EmailAddress, NotDisposableEmail]
    public string Email { get; set; } = "";
}
```

주의: `ValidationAttribute`는 **상태를 두지 말 것**. 스레드 안전성 보장.

---

## 3. Razor Pages에서의 적용 패턴

### 3.1 기본 폼과 서버 검증

```cshtml
@page
@model ContactPageModel

<form method="post">
    <div>
        <input asp-for="Contact.Name" />
        <span asp-validation-for="Contact.Name"></span>
    </div>
    <div>
        <input asp-for="Contact.Email" />
        <span asp-validation-for="Contact.Email"></span>
    </div>
    <div>
        <input asp-for="Contact.Age" />
        <span asp-validation-for="Contact.Age"></span>
    </div>
    <button type="submit">전송</button>
</form>

<partial name="_ValidationScriptsPartial" />
```

```csharp
public class ContactPageModel : PageModel
{
    [BindProperty] public ContactModel Contact { get; set; } = new();

    public IActionResult OnPost()
    {
        if (!ModelState.IsValid) return Page();

        // 처리 로직
        return RedirectToPage("Success");
    }
}
```

### 3.2 서버 측 수동 오류 추가

```csharp
if (Contact.Email.Equals("test@test.com", StringComparison.OrdinalIgnoreCase))
{
    ModelState.AddModelError("Contact.Email", "이 이메일은 사용할 수 없습니다.");
}
```

키는 바인딩 경로와 일치해야 화면에 표시된다.

### 3.3 PRG 패턴(Post-Redirect-Get)

중복 제출 방지, 새로고침 안전:

```csharp
public IActionResult OnPost()
{
    if (!ModelState.IsValid) return Page();

    TempData["Notice"] = "정상 처리되었습니다.";
    return RedirectToPage("Result");
}
```

---

## 4. 파일 업로드 검증(IFormFile)

### 4.1 모델과 PageModel

```csharp
public class UploadInput
{
    [Required]
    public IFormFile File { get; set; } = default!;
}

public class UploadModel : PageModel
{
    [BindProperty] public UploadInput Input { get; set; } = new();

    private static readonly string[] AllowedTypes = { "image/png", "image/jpeg" };
    private const long MaxSize = 2 * 1024 * 1024;

    public async Task<IActionResult> OnPostAsync()
    {
        if (!ModelState.IsValid) return Page();

        var f = Input.File;

        if (!AllowedTypes.Contains(f.ContentType))
            ModelState.AddModelError("Input.File", "PNG, JPEG만 허용됩니다.");

        if (f.Length <= 0 || f.Length > MaxSize)
            ModelState.AddModelError("Input.File", "파일 크기는 1바이트 이상 2MB 이하이어야 합니다.");

        if (!ModelState.IsValid) return Page();

        using var stream = new MemoryStream();
        await f.CopyToAsync(stream);
        // 추가 보안 검사: 시그니처 확인 등

        return RedirectToPage("Success");
    }
}
```

주의:
- **ContentType만 신뢰하지 말고** 매직 바이트(시그니처) 확인 고려.
- 업로드 경로를 사용자 입력으로 조합하지 말 것(경로 순회).

---

## 5. ModelState 다루기 고급

### 5.1 값 교체 후 재검증

폼 처리 중 서버 로직으로 값을 수정했다면, ModelState의 **원본 값이 우선**되어 화면에 재표시될 수 있다. 이때는 ModelState 정리가 필요:

```csharp
ModelState.Remove("Contact.Name");
Contact.Name = Normalize(Contact.Name);
TryValidateModel(Contact, nameof(Contact));
```

혹은 전부 초기화:
```csharp
ModelState.Clear();
TryValidateModel(Contact);
```

### 5.2 일부 필드 무시

뷰에 필드를 노출하지 않지만 서버가 채우는 값을 바인딩에서 배제:

```csharp
public class UserInput
{
    [BindNever] public Guid Id { get; set; }  // 클라이언트에서 채우지 못함
    [Required] public string Name { get; set; } = "";
}
```

### 5.3 바인딩 강제

폼 값이 반드시 와야 할 때:
```csharp
public class StrongModel
{
    [BindRequired] public int Quantity { get; set; }
}
```
누락 시 ModelState 오류가 자동으로 추가된다.

---

## 6. Remote 검증(서버 즉시 확인)

중복 사용자명 같은 서버 확인이 필요한 검증에 유용.

### 6.1 Razor Pages 예시

모델:
```csharp
public class RegisterInput
{
    [Required]
    [Remote(pageHandler: "CheckName", HttpMethod = "get", ErrorMessage = "이미 사용 중인 이름입니다.")]
    public string UserName { get; set; } = "";
}
```

PageModel:
```csharp
public class RegisterModel : PageModel
{
    private static readonly HashSet<string> Taken = new() { "admin", "root" };

    public JsonResult OnGetCheckName(string userName)
        => Taken.Contains(userName, StringComparer.OrdinalIgnoreCase)
           ? new JsonResult("이미 사용 중인 이름입니다.")
           : new JsonResult(true);
}
```

뷰에 `_ValidationScriptsPartial`이 포함되어 있어야 동작한다.

---

## 7. API 컨트롤러에서의 검증([ApiController])

### 7.1 자동 400과 ProblemDetails

`[ApiController]`가 붙은 컨트롤러/엔드포인트는 ModelState가 유효하지 않을 때 **자동으로 400**과 **ProblemDetails** 본문을 반환한다.

```csharp
[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase
{
    [HttpPost]
    public IActionResult Create(OrderInput input)
    {
        // ModelState.IsValid 체크 불필요(기본 동작: 잘못되면 자동 400)
        // 도메인 로직 추가 검증만 수동 처리
        if (input.Items.Sum(i => i.Quantity) <= 0)
            return Problem(detail: "수량 합계가 0 이하입니다.", statusCode: 422, title: "도메인 검증 실패");

        return CreatedAtAction(nameof(Get), new { id = 1 }, null);
    }

    [HttpGet("{id:int}")]
    public IActionResult Get(int id) => Ok(new { id });
}
```

### 7.2 JSON 경로의 오류 키

컬렉션/중첩 모델 오류는 `items[0].quantity` 등 **camelCase** 경로로 나타날 수 있다. 클라이언트가 **문제 세부사항(ProblemDetails.Errors)**를 바인딩하기 쉽게 설계하라.

---

## 8. 오류 메시지 지역화와 포맷

### 8.1 ErrorMessageResourceType/Name

```csharp
public class LocalizedInput
{
    [Required(
        ErrorMessageResourceType = typeof(Resources.Validation),
        ErrorMessageResourceName = "Required")]
    public string Name { get; set; } = "";
}
```

리소스 파일:
```
Resources/Validation.resx
Resources/Validation.ko.resx
```

키: `Required` → 언어별 메시지

### 8.2 IStringLocalizer를 이용한 수동 메시지

```csharp
public class PageWithL10n : PageModel
{
    private readonly IStringLocalizer<PageWithL10n> L;
    public PageWithL10n(IStringLocalizer<PageWithL10n> l) => L = l;

    public IActionResult OnPost(string code)
    {
        if (code != "OK")
            ModelState.AddModelError("code", L["InvalidCode"]);
        return Page();
    }
}
```

날짜/숫자 파싱은 현재 Culture의 영향을 받는다. 서버와 클라이언트 문화권 불일치에 유의하고, ISO-8601 형식 같은 표준 포맷을 권장한다.

---

## 9. 보안·무결성 모범 사례

- **서버 검증은 필수**: 클라이언트 검증은 참고용. 서버에서 항상 재검증.
- **화이트리스트**: 정렬 필드/필터 값 등은 허용 목록으로 제한.
- **대용량 입력 제한**: 본문 크기, 업로드 크기, 항목 개수 상한.
- **안티 포저리 토큰**: Razor 폼은 기본 포함. API는 필요시 추가 전략 고려.
- **오류 메시지 과다 정보 노출 금지**: 내부 구조·정책 유출을 막기 위한 일반화 메시지 사용.
- **로그와 PII**: 유효성 오류를 로깅하되, 개인정보는 마스킹.

---

## 10. 성능 팁

- **짧은 ValidationAttribute** 구현: 정규식은 미리 컴파일된 Regex를 재사용.
- **단위 변환**은 검증 앞단에서 일관되게 처리(예: 통화/소수점).
- **대형 컬렉션 검증**은 페이지네이션/서버측 배치로 분할 검증.

---

## 11. 테스트 전략

### 11.1 순수 모델 검증 단위 테스트

```csharp
[Fact]
public void DateRange_EndBeforeStart_Fails()
{
    var m = new DateRangeModel { Start = DateTime.Today, End = DateTime.Today.AddDays(-1) };
    var ctx = new ValidationContext(m);
    var results = new List<ValidationResult>();
    var ok = Validator.TryValidateObject(m, ctx, results, validateAllProperties: true);

    Assert.False(ok);
    Assert.Contains(results, r => r.ErrorMessage!.Contains("이후"));
}
```

### 11.2 Razor Pages 통합 테스트(WebApplicationFactory)

- 폼 제출 → ModelState 오류 렌더링 확인  
- 파일 업로드 제한, ContentType/크기 검사 확인  
- PRG 패턴에서 Redirect와 TempData 전달 확인

### 11.3 API 컨트롤러

- 잘못된 페이로드 → 자동 400 및 ProblemDetails 구조 검증  
- 유효 페이로드 → 201/200 시나리오

---

## 12. 자주 겪는 함정과 해결

| 문제 | 원인 | 해결 |
|---|---|---|
| 값은 바꿨는데 화면에 예전 값 표시 | ModelState가 원본 값을 보유 | `ModelState.Remove(key)` 또는 `ModelState.Clear()` 후 `TryValidateModel` |
| 숫자/날짜 변환 오류 | 문화권 불일치, 잘못된 포맷 | ISO 포맷 사용, 커스텀 바인더/`TryParseExact` |
| 컬렉션 검증 누락 | 항목 인덱스 키 불일치 | 이름 규칙 준수(`Items[0].Property`) |
| Remote 검증 미동작 | 스크립트 누락 | `_ValidationScriptsPartial` 포함 |
| API에서 에러 포맷 제각각 | 수동 처리 혼용 | `[ApiController]` + ProblemDetails 일원화 |

---

## 13. 종합 예제: 주문 폼(중첩 모델 + 파일 + 서버 규칙 + PRG)

### 13.1 모델

```csharp
public class CreateOrderInput : IValidatableObject
{
    [Required, StringLength(80)]
    public string CustomerName { get; set; } = "";

    [MinLength(1, ErrorMessage = "주문 항목은 최소 1개 이상이어야 합니다.")]
    public List<OrderItem> Items { get; set; } = new();

    public IFormFile? Attachment { get; set; }

    public IEnumerable<ValidationResult> Validate(ValidationContext context)
    {
        var total = Items.Sum(i => i.Quantity * i.UnitPrice);
        if (total <= 0)
            yield return new ValidationResult("총액이 0보다 커야 합니다.", new[] { nameof(Items) });
    }
}
```

### 13.2 PageModel

```csharp
public class CreateOrderModel : PageModel
{
    [BindProperty] public CreateOrderInput Input { get; set; } = new();

    private static readonly string[] AllowedTypes = { "application/pdf" };
    private const long MaxSize = 5 * 1024 * 1024;

    public IActionResult OnPost()
    {
        // 파일 검증(옵션)
        if (Input.Attachment is not null)
        {
            if (!AllowedTypes.Contains(Input.Attachment.ContentType))
                ModelState.AddModelError("Input.Attachment", "PDF만 업로드 가능합니다.");

            if (Input.Attachment.Length <= 0 || Input.Attachment.Length > MaxSize)
                ModelState.AddModelError("Input.Attachment", "첨부는 1바이트 이상 5MB 이하여야 합니다.");
        }

        if (!ModelState.IsValid) return Page();

        // 도메인 규칙: 특정 고객명 블락 예시
        if (Input.CustomerName.Equals("blocked", StringComparison.OrdinalIgnoreCase))
        {
            ModelState.AddModelError("Input.CustomerName", "해당 고객은 주문이 제한되어 있습니다.");
            return Page();
        }

        TempData["Notice"] = "주문이 접수되었습니다.";
        return RedirectToPage("OrderResult");
    }
}
```

### 13.3 뷰

```cshtml
@page
@model CreateOrderModel

<form method="post" enctype="multipart/form-data">
  <div>
    <label asp-for="Input.CustomerName"></label>
    <input asp-for="Input.CustomerName" />
    <span asp-validation-for="Input.CustomerName"></span>
  </div>

  <div id="items">
    @for (int i = 0; i < Model.Input.Items.Count; i++)
    {
        <div>
          <input asp-for="Input.Items[i].ProductName" placeholder="상품명" />
          <input asp-for="Input.Items[i].Quantity" placeholder="수량" />
          <input asp-for="Input.Items[i].UnitPrice" placeholder="단가" />
          <span asp-validation-for="Input.Items[i].ProductName"></span>
          <span asp-validation-for="Input.Items[i].Quantity"></span>
          <span asp-validation-for="Input.Items[i].UnitPrice"></span>
        </div>
    }
  </div>

  <div>
    <label asp-for="Input.Attachment"></label>
    <input asp-for="Input.Attachment" type="file" />
    <span asp-validation-for="Input.Attachment"></span>
  </div>

  <validation-summary asp-validation-summary="ModelOnly"></validation-summary>
  <button type="submit">등록</button>
</form>

<partial name="_ValidationScriptsPartial" />
```

---

## 14. 요약

- **Data Annotations**로 스키마 수준 검증을 선언하고, **IValidatableObject/커스텀 Attribute**로 도메인 규칙을 보완한다.
- **ModelState**는 값 변환 실패와 검증 오류를 모두 담는다. 값 변경 시 **ModelState 정리**를 잊지 말라.
- **파일 업로드**는 ContentType·크기·시그니처까지 점검하라.
- **Remote 검증**으로 서버 확정을 빠르게 피드백하되, 최종 판정은 서버에서 반복 수행하라.
- API는 `[ApiController]`로 **자동 400 + ProblemDetails**를 일원화하여 클라이언트 개발 생산성을 높인다.
- 오류 메시지는 **리소스 기반 지역화**로 일관성 있게 제공하라.
- PRG, 화이트리스트, 한도 설정, 정보 노출 억제 등으로 **보안·무결성**을 강화하라.
- 단위/통합 테스트로 핵심 검증 시나리오를 자동화하면, 릴리스 품질과 회귀 안정성이 크게 향상된다.

---

## 15. 다음 읽을거리 제안

- 클라이언트 유효성 검사 흐름과 `_ValidationScriptsPartial` 상세  
- 복잡 폼(탭/동적 컬렉션)의 이름 규칙과 바인딩 전략  
- 커스텀 모델 바인더로 날짜/통화/다국어 파싱 일관화  
- 대형 폼 성능 최적화와 서버 부하 방지 기법