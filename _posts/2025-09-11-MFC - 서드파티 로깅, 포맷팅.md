---
layout: post
title: MFC - 서드파티 로깅, 포맷팅
date: 2025-09-11 20:25:23 +0900
category: MFC
---
# 서드파티 로깅/포맷팅(spdlog / fmt) 연동 관점 — C++17/20 실전 총정리

**대상**: Win32/MFC/콘솔/서버/툴 전반
**목표**
- `fmt`로 안전·고성능 **문자열 포맷팅**을 표준화
- `spdlog`로 **멀티 싱크(파일/콘솔/디버거/네트워크)**, **비동기 로깅**, **회전/일별 로그**, **백트레이스**를 구현
- 빌드/배포(헤더온리, CMake/패키지), **UTF-8/Windows** 케이스, **성능/안정성**까지 빠짐없이

> TL;DR
> - **포맷은 `fmt`**, **로그는 `spdlog`** (내부적으로도 `fmt` 사용).
> - 단일 바이너리면 **헤더온리**로 빠르게, 재사용/버전 고정은 **패키지 매니저**.
> - 운영은 **회전 로그 + 비동기 + 주기적 flush** + **에러 시 즉시 flush**.
> - **소스 위치/스레드 ID/프로세스 ID** 포함 패턴으로 디버깅 속도 ↑.

---

## 0. 설치/연동

### 0-1. 패키지 매니저 (권장)
- **vcpkg**
  ```pwsh
  vcpkg install fmt spdlog
  # CMakeLists.txt
  find_package(fmt CONFIG REQUIRED)
  find_package(spdlog CONFIG REQUIRED)
  target_link_libraries(myapp PRIVATE fmt::fmt spdlog::spdlog)
  ```
- **Conan**
  ```ini
  [requires]
  fmt/10.*
  spdlog/1.*

  [generators]
  CMakeDeps
  CMakeToolchain
  ```
  ```cmake
  find_package(fmt REQUIRED)
  find_package(spdlog REQUIRED)
  target_link_libraries(myapp PRIVATE fmt::fmt spdlog::spdlog)
  ```

### 0-2. FetchContent (외부 의존 최소)
```cmake
include(FetchContent)

FetchContent_Declare(fmt GIT_REPOSITORY https://github.com/fmtlib/fmt.git GIT_TAG 10.2.1)
FetchContent_MakeAvailable(fmt)

set(SPDLOG_FMT_EXTERNAL ON)        # spdlog가 외부 fmt를 쓰도록
FetchContent_Declare(spdlog GIT_REPOSITORY https://github.com/gabime/spdlog.git GIT_TAG v1.13.0)
FetchContent_MakeAvailable(spdlog)

target_link_libraries(myapp PRIVATE fmt::fmt spdlog::spdlog)
```

### 0-3. 헤더 온리(빠른 체험)
- `fmt`: 기본적으로 헤더온리 사용 가능 (단, `FMT_HEADER_ONLY` 정의하면 강제 헤더온리).
- `spdlog`: `#define SPDLOG_HEADER_ONLY` (하나의 컴파일 단위에서만 정의).

---

## 1. fmt — 안전한 포맷팅

### 1-1. 기본 포맷
```cpp
#include <fmt/core.h>
#include <fmt/chrono.h>
#include <fmt/ranges.h>

std::string s = fmt::format("Hello, {}. Pi≈{:.3f}", "world", 3.14159);
// "Hello, world. Pi≈3.142"

fmt::print("Value: {:#x}\n", 48879); // 0xbeef
fmt::print("Now: {:%Y-%m-%d %H:%M:%S}\n", std::chrono::system_clock::now());
```

### 1-2. 이름 있는 인자 / 범위 / join
```cpp
fmt::print("Name={name}, Age={age}\n", fmt::arg("name","Lin"), fmt::arg("age", 28));

std::vector<int> v{1,2,3};
fmt::print("v=[{}]\n", fmt::join(v, ", "));
```

### 1-3. 성능/제로-할당: `memory_buffer` & `format_to`
```cpp
fmt::memory_buffer buf;
fmt::format_to(std::back_inserter(buf), "x={} y={}\n", 10, 20);
auto out = fmt::to_string(buf); // 필요 시 std::string으로
```

### 1-4. 컴파일타임 포맷 문자열(가능하면)
```cpp
using namespace fmt::literals; // "_format" literal은 옛 문법
auto s = fmt::format(FMT_COMPILE("port={} host={}"), 8080, "localhost");
```

### 1-5. 유니코드/Windows
- 내부 문자열은 **UTF-8 권장**. Win32와 상호작용 시 `MultiByteToWideChar/WideCharToMultiByte` 또는 `std::filesystem::path(u8"...")`.
- `fmt`는 UTF-8 문자열 출력/파일 쓰기를 잘 지원(콘솔 인코딩은 OS 설정 영향).

### 1-6. 사용자 타입 포맷터
```cpp
struct Point { int x,y; };

template<> struct fmt::formatter<Point> {
  constexpr auto parse(format_parse_context& ctx) { return ctx.end(); }
  template<class Ctx>
  auto format(const Point& p, Ctx& ctx) const {
    return fmt::format_to(ctx.out(), "({}, {})", p.x, p.y);
  }
};

fmt::print("P={}\n", Point{3,4});
```

---

## 2. spdlog — 싱크/패턴/레벨/비동기

### 2-1. 가장 단순한 사용
```cpp
#include <spdlog/spdlog.h>

int main() {
  spdlog::info("Hello {}", "spdlog");
  spdlog::warn("low disk: {}%", 3);
  spdlog::error("fatal: {}", "something happened");
}
```

### 2-2. 패턴(로그 라인 포맷)
```cpp
// [%Y-%m-%d %H:%M:%S.%e] [pid:tid] [레벨] [로거명] 소스:라인 메시지
spdlog::set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%P:%t] [%^%l%$] [%n] %s:%# %v");
```
- `%Y/%m/%d %H:%M:%S.%e` 날짜/시간,
- `%P` 프로세스, `%t` 스레드,
- `%l` 레벨, `%n` 로거명,
- `%s:%#` 소스 파일/라인(매크로가 소스 위치 전달 시),
- `%v` 메시지 본문, `%^ .. %$`는 컬러 on/off.

### 2-3. 레벨 / 필터링 / flush 정책
```cpp
spdlog::set_level(spdlog::level::info);   // 전역 최소 레벨
spdlog::flush_on(spdlog::level::err);     // 에러 이상 시 즉시 flush
spdlog::flush_every(std::chrono::seconds(3)); // 주기적 flush (백그라운드)
```

### 2-4. 여러 싱크 조합(파일 + 콘솔 + 디버거)
```cpp
#include <spdlog/sinks/basic_file_sink.h>
#include <spdlog/sinks/msvc_sink.h>
#include <spdlog/sinks/stdout_color_sinks.h>

auto file_sink = std::make_shared<spdlog::sinks::basic_file_sink_mt>("logs/app.log", true);
auto dbg_sink  = std::make_shared<spdlog::sinks::msvc_sink_mt>();   // OutputDebugString (Windows)
auto con_sink  = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();

file_sink->set_level(spdlog::level::trace);
dbg_sink ->set_level(spdlog::level::debug);
con_sink ->set_level(spdlog::level::info);

auto logger = std::make_shared<spdlog::logger>("app", spdlog::sinks_init_list{file_sink, dbg_sink, con_sink});
spdlog::register_logger(logger);
spdlog::set_default_logger(logger);
```

### 2-5. 회전/일별 로그
```cpp
#include <spdlog/sinks/rotating_file_sink.h>
#include <spdlog/sinks/daily_file_sink.h>

// 용량 회전: 파일 최대 10MB, 백업 5개
auto rotating = std::make_shared<spdlog::sinks::rotating_file_sink_mt>("logs/run.log", 10*1024*1024, 5);

// 일별 00:00 롤오버, 보존 30일(직접 삭제 로직 필요시 앱에서)
auto daily = std::make_shared<spdlog::sinks::daily_file_sink_mt>("logs/daily.log", 0, 0);
```

### 2-6. 비동기 로깅(고성능)
```cpp
#include <spdlog/async.h>
#include <spdlog/sinks/rotating_file_sink.h>

spdlog::init_thread_pool(/*queue_size*/ 8192, /*threads*/ 1);
auto sink   = std::make_shared<spdlog::sinks::rotating_file_sink_mt>("logs/async.log", 20*1024*1024, 3);

auto async_logger = std::make_shared<spdlog::async_logger>(
  "async", sink, spdlog::thread_pool(),
  spdlog::async_overflow_policy::block);

spdlog::register_logger(async_logger);
spdlog::set_default_logger(async_logger);

SPDLOG_INFO("warm-up {}", 123);
```
- **큐 사이즈/스레드 수**는 워크로드에 맞게.
- 오버플로 정책: `block` 또는 `overrun_oldest`.

### 2-7. 소스 위치 캡처
```cpp
SPDLOG_INFO("no location here"); // 간단

// 소스 위치를 명시적으로
spdlog::log(spdlog::source_loc{__FILE__, __LINE__, SPDLOG_FUNCTION},
            spdlog::level::info, "user={} id={}", name, id);
```
- 매크로 기반 로깅(예: `SPDLOG_INFO`)도 최신 버전에선 소스 위치 포함 가능(컴파일 옵션/매크로 설정에 따름).

### 2-8. 백트레이스(최근 N개 버퍼링 → 문제 시 덤프)
```cpp
spdlog::enable_backtrace(64);   // 최근 64개 보관
// ...
if (fatal_condition) {
  spdlog::critical("fatal error");
  spdlog::dump_backtrace();     // 보관했던 로그 라인들을 한꺼번에 출력
}
```

### 2-9. 에러 핸들러
```cpp
spdlog::set_error_handler([](const std::string& e){
  // 파일 접근 안됨 등 spdlog 내부 오류 대응
  ::OutputDebugStringA(("spdlog error: " + e + "\n").c_str());
});
```

---

## 3. 운영 패턴(Windows/MFC 포함)

### 3-1. 경로 설계(앱 데이터)
```cpp
// %LOCALAPPDATA%\Vendor\App\logs
std::filesystem::path log_dir = LocalAppData() / "Vendor" / "App" / "logs";
std::filesystem::create_directories(log_dir);
auto path = (log_dir / "app.log").string();
auto sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(path, 10*1024*1024, 10);
```

### 3-2. 디버거/릴리즈 동시
- 디버깅 시 `msvc_sink`(OutputDebugString)와 콘솔 컬러 싱크를 함께 활성화.
- 릴리즈는 파일 싱크 레벨↑, 콘솔 레벨↓.

### 3-3. MFC/Win32 통합
- **초기화**: `CWinApp::InitInstance()`에서 로거 구성 → `spdlog::set_default_logger`.
- **TRACE 대체**: `SPDLOG_DEBUG/TRACE` 사용, 빌드형상에 따라 `set_level`.
- **예외 경로**: `SetUnhandledExceptionFilter`/`std::set_terminate` 에서 `flush`, `dump_backtrace`.

```cpp
std::set_terminate([](){
  spdlog::critical("std::terminate called");
  spdlog::dump_backtrace();
  spdlog::default_logger()->flush();
  std::abort();
});
```

### 3-4. UTF-8 파일명/콘텐츠
- spdlog는 기본적으로 **UTF-8 메시지** OK.
- **파일명에 한글**: Windows에서 wide API를 쓰려면 `SPDLOG_WCHAR_FILENAMES` 정의 + `*_sink_mt<wchar_t>` 계열 사용(버전에 따라 다름).
- 실무에선 **ASCII/영문 파일명 + UTF-8 내용** 조합이 안전.

---

## 4. 확장 — 커스텀 싱크/포맷

### 4-1. OutputDebugString 커스텀(필요 시)
```cpp
struct ods_sink : spdlog::sinks::base_sink<std::mutex> {
  void sink_it_(const spdlog::details::log_msg& msg) override {
    spdlog::memory_buf_t formatted;
    formatter_->format(msg, formatted);
#ifdef _WIN32
    std::wstring w = fmt::vformat(fmt::runtime(L"{}"), fmt::make_format_args(
                    fmt::basic_string_view<char>((const char*)formatted.data(), formatted.size())));
    ::OutputDebugStringW(w.c_str());
#else
    fwrite(formatted.data(), 1, formatted.size(), stderr);
#endif
  }
  void flush_() override {}
};
```
- 대부분은 내장 `msvc_sink_mt`로 충분.

### 4-2. JSON 라인 포맷(ELK 등)
```cpp
struct json_formatter : spdlog::formatter {
  std::unique_ptr<formatter> clone() const override {
    return std::make_unique<json_formatter>();
  }
  void format(const spdlog::details::log_msg& msg, spdlog::memory_buf_t& dest) override {
    auto ts = spdlog::details::fmt_helper::time_fraction<std::chrono::milliseconds>(msg.time);
    // 간단 예시: {"t":"...", "lvl":"info", "msg":"..."}
{% raw %}
    fmt::format_to(std::back_inserter(dest),
      R"({{"t":"{:%FT%T}.{:03}","lvl":"{}","logger":"{}","msg":")",
      fmt::localtime(msg.time.time_since_epoch()), ts.count(), spdlog::level::to_string_view(msg.level), msg.logger_name);
{% endraw %}
    // 메시지 본문
    spdlog::memory_buf_t tmp;
    base_formatter_->format(msg, tmp); // or msg.payload
    for (auto c : tmp) {
      if (c == '"') fmt::format_to(std::back_inserter(dest), "\\\"");
      else if (c == '\\') fmt::format_to(std::back_inserter(dest), "\\\\");
      else dest.push_back(c);
    }
{% raw %}
    fmt::format_to(std::back_inserter(dest), "\"}}\n");
{% endraw %}
  }
private:
  std::unique_ptr<spdlog::formatter> base_formatter_ = std::make_unique<spdlog::pattern_formatter>("%v");
};
```
- 포맷터를 싱크에 `set_formatter(std::make_unique<json_formatter>())`.

---

## 5. 성능/안정성 체크리스트

1) **비동기 로깅 + 회전/일별**: I/O 병목 완화
2) **에러 이상 즉시 flush** + **주기 flush**: 데이터 유실 방지
3) **레벨 필터** 적절히: 릴리즈에서 `debug/trace` 비활성
4) **패턴 최소화**: 프로파일링하여 `%!`(함수명) 등 비용 높은 항목은 선택 사용
5) **큐 사이즈/스레드 수** 튜닝: 스파이크 흡수
6) **에러 핸들러**: 파일 열기 실패/권한 문제 진단
7) **백트레이스**: 드문 버그 재현 어려울 때 유용
8) **fmt 컴파일타임 포맷**: 고빈도 경로는 `FMT_COMPILE`로 오버헤드↓
9) **파일 경로**: 사용자 폴더(권한 문제 회피), 경로 길이 제한 주의
10) **유닛테스트**: 싱크에 `spdlog::sinks::ostream_sink_mt` 연결해 검증

---

## 6. 통합 패턴(보일러플레이트)

### 6-1. Logger 초기화 함수
```cpp
namespace logsys {

inline void init_default_logger(const std::string& appname, const std::filesystem::path& log_dir,
                                spdlog::level::level_enum lv = spdlog::level::info,
                                bool async = true) {
  std::filesystem::create_directories(log_dir);
  auto logfile = (log_dir / (appname + ".log")).string();

  std::vector<spdlog::sink_ptr> sinks;
  auto rotating = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(logfile, 10*1024*1024, 10);
  auto console  = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
#ifdef _WIN32
  auto msvc    = std::make_shared<spdlog::sinks::msvc_sink_mt>();
  sinks = {rotating, console, msvc};
#else
  sinks = {rotating, console};
#endif

  std::shared_ptr<spdlog::logger> logger;
  if (async) {
    spdlog::init_thread_pool(8192, 1);
    logger = std::make_shared<spdlog::async_logger>(appname, sinks.begin(), sinks.end(),
        spdlog::thread_pool(), spdlog::async_overflow_policy::block);
  } else {
    logger = std::make_shared<spdlog::logger>(appname, sinks.begin(), sinks.end());
  }

  logger->set_level(lv);
  logger->flush_on(spdlog::level::err);
  spdlog::set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%P:%t] [%^%l%$] [%n] %s:%# %v");
  spdlog::register_logger(logger);
  spdlog::set_default_logger(logger);
  spdlog::flush_every(std::chrono::seconds(5));

  spdlog::info("logger initialized: file='{}' level={}", logfile, spdlog::level::to_string_view(lv));
}

} // namespace
```

### 6-2. 사용 예
```cpp
int main() {
  logsys::init_default_logger("myapp", std::filesystem::path(get_local_appdata()) / "Vendor" / "MyApp" / "logs",
                              spdlog::level::debug, true);

  SPDLOG_INFO("start app ver={} pid={}", "1.2.3", ::GetCurrentProcessId());
  // ...
}
```

---

## 7. 흔한 오류/FAQ

- **콘솔에 한글이 깨져요**
  → Windows 콘솔 코드페이지/UTF-8 설정 확인(`chcp 65001`, Windows Terminal 권장). 로그 파일은 UTF-8로 일관.

- **fmt/spdlog 버전 충돌(링크 에러)**
  → `SPDLOG_FMT_EXTERNAL=ON`으로 spdlog가 외부 fmt를 사용하게 하거나, 동일 버전으로 정렬.

- **비동기 로깅에서 앱 종료가 느림**
  → 남은 큐를 flush/join 중. 종료 전 `spdlog::shutdown()` 호출 또는 큐 사이즈 조절.

- **파일을 잡고 있어서 삭제/갱신 실패**
  → 회전 파일 사용, 또는 종료 시 `shutdown()`으로 싱크 정리. 로거를 전역 static보다 **수명 명시**가 깔끔.

- **소스 위치가 안 찍혀요**
  → 사용하는 매크로/버전 확인. 명시적으로 `spdlog::source_loc{__FILE__,__LINE__,SPDLOG_FUNCTION}` 전달 가능.

---

## 8. 미니 가이드: 팀 컨벤션 제안

- **레벨 규칙**:
  - `trace` 상세(개발 전용), `debug` 개발/스테이징, `info` 기본, `warn` 사용자 영향 가능, `error` 기능 실패, `critical` 프로세스 위험.
- **메시지 형식**: `key=value` 나 JSON(선호)로 파싱 가능하게.
- **컨텍스트**: 요청 ID/세션/사용자/문서 경로 등 **식별자**를 반드시 포함.
- **소스 위치/스레드** 표준 패턴 고정.
- **회전 크기/보존**: 서버 50~200MB/5~20개, 클라이언트 10MB/10개.
- **비동기 기본**, 크래시 가능 구간은 동기/즉시 flush.
- **성능 경로**는 `FMT_COMPILE` 활용.

---

## 9. 부록: 포맷 레퍼런스(즐겨 쓰는 것만)

- 숫자: `{:d} {:x} {:#x} {:08x} {:>8} {:<8} {:^8}`
- 부동소수: `{:.3f} {:g}`
- 문자열: `{:.10}`(최대 길이), `{:<20}`(좌측 정렬 폭)
- 시간: `"{:%Y-%m-%d %H:%M:%S}"` (`<fmt/chrono.h>`)
- 범위: `fmt::join(vec, ", ")`
- 네임드: `fmt::format("a={a} b={b}", fmt::arg("a",1), fmt::arg("b",2))`

---

## 10. 샘플: “진짜” 초기화 + 사용 (복붙)

```cpp
// log_setup.h
#pragma once
#include <filesystem>
#include <spdlog/spdlog.h>

namespace logsetup {
void init(const std::string& name, const std::filesystem::path& dir,
          spdlog::level::level_enum lv = spdlog::level::info, bool async = true);
}

// log_setup.cpp
#include "log_setup.h"
#include <spdlog/async.h>
#include <spdlog/sinks/rotating_file_sink.h>
#include <spdlog/sinks/stdout_color_sinks.h>
#ifdef _WIN32
#include <spdlog/sinks/msvc_sink.h>
#endif

void logsetup::init(const std::string& name, const std::filesystem::path& dir,
                    spdlog::level::level_enum lv, bool async) {
  std::filesystem::create_directories(dir);
  auto file = (dir / (name + ".log")).string();

  std::vector<spdlog::sink_ptr> sinks;
  sinks.push_back(std::make_shared<spdlog::sinks::rotating_file_sink_mt>(file, 10*1024*1024, 10));
  sinks.push_back(std::make_shared<spdlog::sinks::stdout_color_sink_mt>());
#ifdef _WIN32
  sinks.push_back(std::make_shared<spdlog::sinks::msvc_sink_mt>());
#endif

  std::shared_ptr<spdlog::logger> lg;
  if (async) {
    spdlog::init_thread_pool(8192, 1);
    lg = std::make_shared<spdlog::async_logger>(name, sinks.begin(), sinks.end(),
         spdlog::thread_pool(), spdlog::async_overflow_policy::block);
  } else {
    lg = std::make_shared<spdlog::logger>(name, sinks.begin(), sinks.end());
  }
  spdlog::register_logger(lg);
  spdlog::set_default_logger(lg);
  spdlog::set_level(lv);
  spdlog::flush_on(spdlog::level::err);
  spdlog::set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%P:%t] [%^%l%$] [%n] %s:%# %v");
  spdlog::flush_every(std::chrono::seconds(3));

  SPDLOG_INFO("logger ready: {}", file);
}

// main.cpp
#include "log_setup.h"
#include <fmt/chrono.h>

int main() {
  logsetup::init("demo", std::filesystem::temp_directory_path() / "demo-logs",
                 spdlog::level::debug, true);

  SPDLOG_INFO("start t={:%H:%M:%S}", std::chrono::system_clock::now());
  for (int i=0; i<5; ++i) {
    SPDLOG_DEBUG("step {}...", i);
  }
  SPDLOG_WARN("low space remaining: {}MB", 123);
  SPDLOG_ERROR("cannot open {}", "config.json");

  spdlog::shutdown();
}
```

---

### 마무리

- **fmt**로 문자열 포맷을 “타입 안정 + 성능”으로 통일하고,
- **spdlog**로 로그 라우팅/회전/비동기/패턴을 완성하면
  개발/운영/분석 전 과정의 **가시성**이 한층 올라갑니다.
