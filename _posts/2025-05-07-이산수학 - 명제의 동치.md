---
layout: post
title: 이산수학 - 명제의 동치
date: 2025-05-07 20:20:23 +0900
category: 이산수학
---
# 명제의 동치(Logical Equivalence)

## 0. 학습 목표와 로드맵

- 동치의 의미(의미론적 동일성)와 기호 $$\equiv$$ 를 정확히 정의한다.  
- 진리표, 등치법칙(논리 대수), 추론 규칙을 이용해 동치를 검증·유도하는 법을 익힌다.  
- 코드·회로·수학 증명에서 동치를 활용해 식을 간단히 하고 오류 가능성을 줄인다.  
- CNF/DNF 정규화, Tseitin 변환(만족가능성 보존) 등 실전 변환을 구분한다.  
- 자동 확인용 파이썬 스니펫으로 임의의 등식 검증 습관을 만든다.

---

## 1. 동치의 정의와 해석

**정의(의미론적 동치)**  
논리식 $$P, Q$$ 에 대해 가능한 모든 변수 할당에서 같은 진리값을 내면  
$$
P \equiv Q
$$
라고 한다. 즉, 두 식의 진리표 마지막 열이 항상 동일하다.

**비고: 동치 vs 함의**  
- 함의: $$P \models Q$$ 는 모든 해석에서 $$P$$ 가 참이면 $$Q$$ 도 참이라는 뜻(한 방향).  
- 동치: $$P \equiv Q$$ 는 $$P \models Q$$ 이고 동시에 $$Q \models P$$ 인 경우(양방향).

---

## 2. 왜 동치가 중요한가

- **식 단순화**: 조건 최적화, 불필요한 분기 제거.  
- **회로 최적화**: 게이트 수 감소, 지연 시간·전력 절감.  
- **증명 전략**: 다루기 쉬운 꼴로 바꿔 직접증명·대우증명·모순법 등 적용.  
- **자동 추론**: SAT/SMT 솔버, 정리 증명기 입력으로 정규형 사용.  
- **코드 안정성**: 의미를 바꾸지 않고 가독성·성능 개선.

---

## 3. 진리표로 동치 확인

예: $$p \to q \equiv \lnot p \lor q$$

```markdown
| p | q | p → q | ¬p | ¬p ∨ q |
|---|---|--------|----|--------|
| T | T |   T    | F  |   T    |
| T | F |   F    | F  |   F    |
| F | T |   T    | T  |   T    |
| F | F |   T    | T  |   T    |
```

마지막 두 열이 동일하므로 동치가 성립한다.

---

## 4. 자주 쓰는 동치 법칙(핵심 카탈로그)

아래는 대표적 동치식이다. 모든 식은 진리표로 확인 가능하며, 실전에서는 “법칙 이름 → 즉시 적용”으로 익숙해지면 좋다.

1) 기본 항등·지배·멱등
$$
\begin{aligned}
&p \land \top \equiv p,\quad p \lor \bot \equiv p \\
&p \land \bot \equiv \bot,\quad p \lor \top \equiv \top \\
&p \land p \equiv p,\quad p \lor p \equiv p
\end{aligned}
$$

2) 교환·결합
$$
\begin{aligned}
&p \land q \equiv q \land p,\quad p \lor q \equiv q \lor p \\
&(p \land q)\land r \equiv p \land (q \land r) \\
&(p \lor q)\lor r \equiv p \lor (q \lor r)
\end{aligned}
$$

3) 분배
$$
\begin{aligned}
&p \land (q \lor r) \equiv (p \land q)\lor(p \land r) \\
&p \lor (q \land r) \equiv (p \lor q)\land(p \lor r)
\end{aligned}
$$

4) 드모르간·이중부정
$$
\begin{aligned}
&\lnot(p \land q) \equiv (\lnot p)\lor(\lnot q) \\
&\lnot(p \lor q) \equiv (\lnot p)\land(\lnot q) \\
&\lnot\lnot p \equiv p
\end{aligned}
$$

5) 조건·대우·쌍조건
$$
\begin{aligned}
&p \to q \equiv \lnot p \lor q \\
&p \to q \equiv \lnot q \to \lnot p \\
&p \leftrightarrow q \equiv (p \to q)\land(q \to p)
\end{aligned}
$$

6) 흡수·보수
$$
\begin{aligned}
&p \lor (p \land q) \equiv p,\quad p \land (p \lor q) \equiv p \\
&p \lor \lnot p \equiv \top,\quad p \land \lnot p \equiv \bot
\end{aligned}
$$

7) 기타 유용식(Exportation, Implication 제거 등)
$$
\begin{aligned}
&(p \land q) \to r \equiv p \to (q \to r) \\
&\lnot(p \to q) \equiv p \land \lnot q
\end{aligned}
$$

---

## 5. 동치 유도 방법(세 가지 관점)

1) **진리표**: 변수 개수가 적을 때 가장 직접적.  
2) **등치법칙 연쇄 변환**: 위 카탈로그를 이용해 단계적으로 목표 꼴로 변환.  
3) **추론 규칙**: $$\vdash P \leftrightarrow Q$$ 형태의 도출(자연 연역, 힐베르트 체계 등).  

실전에서는 2) 방식이 가장 빈번하다. 복잡할수록 3) 또는 도구(자동 증명기)도 고려한다.

---

## 6. 사례: 드모르간과 조건식 변환 자세히 보기

### 6.1 드모르간(부정의 분배)
```markdown
| p | q | p ∧ q | ¬(p ∧ q) | ¬p | ¬q | ¬p ∨ ¬q |
|---|---|--------|-----------|----|----|---------|
| T | T |   T    |     F     | F  | F  |    F    |
| T | F |   F    |     T     | F  | T  |    T    |
| F | T |   F    |     T     | T  | F  |    T    |
| F | F |   F    |     T     | T  | T  |    T    |
```
모든 행이 일치하므로 $$\lnot(p \land q) \equiv \lnot p \lor \lnot q$$.

### 6.2 조건식 변환과 대우
$$
p \to q \equiv \lnot p \lor q \equiv \lnot q \to \lnot p
$$
첫 동치는 진리표로, 둘째 동치는 대우 정의로 즉시 확인된다.

---

## 7. 동치 변환 실전: 코드 조건 단순화

### 7.1 예제 1: 드모르간 적용
원본:
```python
if not (a and b):
    do_x()
```
동치 변환:
```python
if (not a) or (not b):
    do_x()
```
두 식은 논리적으로 동치다. 단, **단락 평가와 부작용**에 주의해야 한다. 예를 들어 `a()`와 `b()`가 함수이고 호출 부작용이 있다면 평가 순서가 중요하다. 동치 변환은 **순수 불 논리식**일 때 안전하다.

### 7.2 예제 2: 흡수 법칙
```python
# 원본
if cond or (cond and extra):
    ...
# 단순화
if cond:
    ...
```

### 7.3 예제 3: 조건 제거
$$
\lnot(p \to q) \equiv p \land \lnot q
$$
```python
# 원본
if not implies(p, q):
    ...
# 단순화
if p and (not q):
    ...
```

---

## 8. 논리 회로 최적화 관점

- $$A \land \lnot A \equiv \bot$$ → 불필요 게이트 제거 가능  
- $$A \lor (A \land B) \equiv A$$ → AND 게이트 제거  
- $$\lnot(A \land B) \equiv \lnot A \lor \lnot B$$ → NAND 게이트 기반 구현시 편리  

정리된 동치식을 기준으로 **게이트 수**, **팬인**, **크리티컬 경로 지연**을 줄인다.

---

## 9. 정규형과 동치: CNF/DNF, Tseitin

### 9.1 DNF(절대곱정규형) 만들기 — 진리표 기반
논리식 $$F(p,q,r)$$ 가 참이 되는 모든 행을 골라, 각 행을 만족시키는 리터럴 곱을 OR로 잇는다. 예)  
참인 행이  
- $$p=\top, q=\bot, r=\top$$  
- $$p=\bot, q=\top, r=\top$$  
이면
$$
F \equiv (p \land \lnot q \land r)\ \lor\ (\lnot p \land q \land r)
$$

### 9.2 CNF(절대합정규형) 만들기 — 등치 변환
함의 제거, 드모르간, 분배법칙으로 CNF 까지 간다. 예:
$$
p \to (q \land r) \equiv \lnot p \lor (q \land r) \equiv (\lnot p \lor q)\land(\lnot p \lor r)
$$

### 9.3 Tseitin 변환(만족가능성 보존, 동치는 아님)
복잡식을 선형 크기의 CNF로 바꾸되, 보조 변수 도입. 이때 결과는 원식과 **만족가능성이 동일**($$\equiv_{\text{sat}}$$)하나 **진리값이 항상 동일(동치)**인 것은 아니다.  
SAT로 푸는 목적이라면 $$\equiv_{\text{sat}}$$ 만으로 충분하다. 이 장의 **동치**와 구분해 기억할 것.

---

## 10. 동치 검증 자동화(파이썬)

### 10.1 두 식 동치 여부 체크(2~4변수 예시)
```python
from itertools import product

def implies(p, q): 
    return (not p) or q

def iff(p, q):
    return (p and q) or ((not p) and (not q))

def check_equiv(expr1, expr2, vars):
    env = {"implies": implies, "iff": iff}
    for values in product([False, True], repeat=len(vars)):
        local = dict(zip(vars, values))
        v1 = eval(expr1, {"__builtins__": None}, {**env, **local})
        v2 = eval(expr2, {"__builtins__": None}, {**env, **local})
        if v1 != v2:
            return False, local
    return True, None

# 예: p -> q  ≡  (not p) or q
ok, counter = check_equiv("implies(p,q)", "(not p) or q", ["p","q"])
print(ok, counter)  # True, None
```
주의: 블로그 독자 실습용 예제이며, 보안이 필요한 환경에서는 안전한 파서를 사용해야 한다.

### 10.2 진리표 생성기
```python
from itertools import product

def truth_table(expr, vars):
    print("| " + " | ".join(vars) + " | value |")
    print("|" + "|".join("---" for _ in vars) + "|-------|")
    for values in product([False, True], repeat=len(vars)):
        local = dict(zip(vars, values))
        v = eval(expr, {"__builtins__": None}, local)
        row = " | ".join("T" if local[x] else "F" for x in vars)
        print(f"| {row} | {'T' if v else 'F'} |")

# 예: not (p and q)  vs  (not p) or (not q)
truth_table("not (p and q)", ["p","q"])
truth_table("(not p) or (not q)", ["p","q"])
```

---

## 11. 동치 변환 워크드 예제

### 11.1 복합 조건 단순화
문제식:
$$
\lnot(p \lor q) \lor (p \land r)
$$
단계 변환:
$$
\begin{aligned}
\lnot(p \lor q) \lor (p \land r) 
&\equiv (\lnot p \land \lnot q) \lor (p \land r) \quad &\text{(드모르간)}\\
&\equiv [(\lnot p \land \lnot q) \lor p] \land [(\lnot p \land \lnot q) \lor r] \quad &\text{(분배)}\\
&\equiv [(\lnot q) \lor p] \land [(\lnot p \lor r) \land (\lnot q \lor r)] \quad &\text{(흡수·분배)}\\
&\equiv (p \lor \lnot q) \land (\lnot p \lor r) \land (\lnot q \lor r)
\end{aligned}
$$
결과는 CNF 이며, 회로·SAT 입력에 적합한 꼴이다.

### 11.2 조건 중첩 평탄화
문제식:
$$
(p \land q) \to r
$$
해법:
$$
(p \land q)\to r \equiv \lnot(p \land q)\lor r \equiv (\lnot p \lor r)\land(\lnot q \lor r)
$$

---

## 12. 실전 주의: 언어별 의미 차이

- **단락 평가**: 대부분의 언어는 `A and B` 평가 시 A가 거짓이면 B를 평가하지 않는다. 동치 변환이 **부작용 없는 순수 불식**에만 안전한 이유다.
- **SQL의 3값 논리**: `NULL` 이 들어가면 고전 이항 논리의 동치가 깨질 수 있다(예: 드모르간이 항상 보존되지 않음). 이 문서는 고전 2값 논리를 전제로 한다.

---

## 13. 연습문제(풀이 또는 힌트 포함)

1) 분류: 항진·모순·가능  
- $$p \lor \lnot p$$ (항진)  
- $$p \land \lnot p$$ (모순)  
- $$(p \to q)\land(q \to r)\to(p \to r)$$ (항진)

2) 진리표 작성  
- $$\lnot p \lor (p \land q)$$  
- $$(p \leftrightarrow q) \leftrightarrow (q \leftrightarrow p)$$ (항진)

3) 동치 증명  
- $$p \to q \equiv \lnot p \lor q$$ (진리표 또는 등치 변환)  
- $$\lnot(p \lor q) \equiv (\lnot p)\land(\lnot q)$$ (드모르간)

4) 타당성 판별  
전제: $$p \to q, q \to r, p$$  
결론: $$r$$  
해설: 가설삼단논법과 Modus Ponens 연쇄로 타당.

5) DNF로 바꾸기  
$$
(p \lor q)\land \lnot r
$$
힌트: 진리표에서 $$r=\bot$$ 인 행을 골라 구성.

6) CNF로 바꾸기  
$$
p \to (q \land r)
$$
정답: $$(\lnot p \lor q)\land(\lnot p \lor r)$$

7) 단계 단순화  
식 $$\lnot(p \land \lnot q)\lor(q \land r)$$ 를 CNF로.  
힌트: 드모르간 → 분배.

---

## 14. 블로그 독자용 “개념 체크 퀴즈”

다음 중 서로 동치인 것을 고르라.

A. $$p \lor \lnot p$$  
B. $$p \land \lnot p$$  
C. $$p \land (p \lor q)$$  
D. $$p \lor (p \land q)$$  
E. $$\lnot(p \lor q)$$ 과 $$(\lnot p)\land(\lnot q)$$

정답: A(항진), C $$\equiv p$$, D $$\equiv p$$, E(드모르간).

---

## 15. 실무 미니 사례 모음

1) **플래그 가드**  
원본: `if feature_on and (expensive() or debug): ...`  
동치 변환: `if feature_on and (debug or expensive()): ...` (교환법칙)  
주의: 평가 순서 때문에 비용 측면은 달라질 수 있다. 동치와 성능은 별개.

2) **전처 조건 묶기**  
`if not ready or (ready and ok): ...`  
흡수로 `if not ready or ok: ...` 로 단순화.

3) **회로 NAND 최적화**  
$$\lnot(A \land B) \equiv \lnot A \lor \lnot B$$  
NAND 게이트만으로 설계 시 구현 경로가 단순해진다.

---

## 16. 부록: 등치법칙 요약표(한 장 정리)

- 항등: $$p \land \top \equiv p,\ p \lor \bot \equiv p$$  
- 지배: $$p \land \bot \equiv \bot,\ p \lor \top \equiv \top$$  
- 멱등: $$p \land p \equiv p,\ p \lor p \equiv p$$  
- 교환: $$p \land q \equiv q \land p,\ p \lor q \equiv q \lor p$$  
- 결합: $$(p \land q)\land r \equiv p \land (q \land r)$$ 등  
- 분배: $$p \land (q \lor r) \equiv (p \land q)\lor(p \land r)$$ 등  
- 드모르간: $$\lnot(p \land q) \equiv \lnot p \lor \lnot q$$ 등  
- 이중부정: $$\lnot\lnot p \equiv p$$  
- 조건 변환: $$p \to q \equiv \lnot p \lor q$$  
- 대우: $$p \to q \equiv \lnot q \to \lnot p$$  
- 흡수: $$p \lor (p \land q) \equiv p,\ p \land (p \lor q) \equiv p$$  
- 쌍조건: $$p \leftrightarrow q \equiv (p \to q)\land(q \to p)$$

---

## 17. 마무리

- **동치**는 의미를 바꾸지 않는 변형을 보장한다.  
- 진리표·등치법칙·추론규칙을 모두 사용할 줄 알면 설계·증명·최적화가 수월해진다.  
- CNF/DNF, Tseitin 변환의 목적 차이를 기억하라(동치 vs 만족가능성 보존).  
- 습관화: 작은 예제라도 코드로 확인해 보고, 변환 과정을 주석으로 남겨라.

---

## 18. 추가 실습 코드: CNF 변환(순수 등치 기반 소형 예제)

아래는 함의 제거 → 부정 이동(드모르간) → 분배를 통한 간단 CNF 변환기의 뼈대다. 완전한 파서는 아니며, 실습용으로 핵심 아이디어만 담았다.

```python
# 매우 단순화된 토이 구현: 식을 파이썬 구조로 직접 만든 뒤 변환
# 노드 타입: ('var','p'), ('not',sub), ('and',a,b), ('or',a,b), ('imp',a,b)

def elim_imp(node):
    t = node[0]
    if t == 'imp':
        a = elim_imp(node[1]); b = elim_imp(node[2])
        return ('or', ('not', a), b)  # p->q ≡ ¬p ∨ q
    elif t in ('and','or'):
        return (t, elim_imp(node[1]), elim_imp(node[2]))
    elif t == 'not':
        return ('not', elim_imp(node[1]))
    else:
        return node

def push_not(node):
    t = node[0]
    if t == 'not':
        sub = node[1]
        st = sub[0]
        if st == 'not':
            return push_not(sub[1])  # ¬¬p ≡ p
        if st == 'and':
            return ('or', push_not(('not',sub[1])), push_not(('not',sub[2])))  # ¬(a∧b) ≡ ¬a ∨ ¬b
        if st == 'or':
            return ('and', push_not(('not',sub[1])), push_not(('not',sub[2])))  # ¬(a∨b) ≡ ¬a ∧ ¬b
        return ('not', push_not(sub))  # ¬var
    elif t in ('and','or'):
        return (t, push_not(node[1]), push_not(node[2]))
    else:
        return node

def distrib(a, b):  # 분배: a ∨ (b ∧ c) = (a∨b) ∧ (a∨c)
    if a[0] == 'and':
        return ('and', distrib(a[1], b), distrib(a[2], b))
    if b[0] == 'and':
        return ('and', distrib(a, b[1]), distrib(a, b[2]))
    return ('or', a, b)

def to_cnf(node):
    node = elim_imp(node)
    node = push_not(node)
    if node[0] == 'or':
        left = to_cnf(node[1]); right = to_cnf(node[2])
        if left[0] == 'and' or right[0] == 'and':
            return distrib(left, right)
        return ('or', left, right)
    if node[0] == 'and':
        return ('and', to_cnf(node[1]), to_cnf(node[2]))
    if node[0] in ('not','var'):
        return node
    raise ValueError("unknown")

# 예: p -> (q and r) 의 CNF
ast = ('imp', ('var','p'), ('and', ('var','q'), ('var','r')))
print(to_cnf(ast))
# 예상: ('and', ('or', ('not', ('var','p')), ('var','q')), ('or', ('not', ('var','p')), ('var','r')))
```

이 예제는 “등치를 유지하는 변환”의 핵심 단계를 코드로 체험하게 한다(함의 제거, 드모르간, 분배).