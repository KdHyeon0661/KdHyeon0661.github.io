---
layout: post
title: C++ - STL (1)
date: 2024-09-12 19:20:23 +0900
category: Cpp
---
# STL 1 — STL이란 무엇인가?

## 왜 STL인가? — “자료구조/알고리즘의 표준 ‘부품화’”

STL(Standard Template Library)은 **제네릭 프로그래밍**을 구현하는 C++ 표준 라이브러리의 핵심 축이다.
핵심 사상은 **컨테이너(데이터) ↔ 이터레이터(접근 수단) ↔ 알고리즘(행동)** 의 **느슨한 결합**:

- **컨테이너**: `vector`, `list`, `map`, `unordered_map` … (저장 구조)
- **이터레이터**: 포인터 유사 인터페이스(탐색/증감/역참조)
- **알고리즘**: `sort`, `find`, `accumulate`, `partition`, `unique` 등 (컨테이너 몰라도 동작)

> 설계 덕분에 **알고리즘은 컨테이너와 독립**이며, 이터레이터만 맞으면 **모든 컨테이너**에 재사용된다.

---

## STL을 쓰면 뭐가 좋은가?

- **생산성**: 검증된 자료구조/알고리즘 재사용
- **성능**: 인라인/템플릿 기반 정적 다형성 + 구현체 최적화
- **안전성**: 예외 보장, 반복자 범위 기반 API, RAII
- **일관성**: 컨테이너/알고리즘 인터페이스 패턴 통일

---

## 큰 지도: STL 구성 요소

| 요소 | 역할 | 예 |
|---|---|---|
| 컨테이너 | 저장/수명 관리 | `vector`, `deque`, `list`, `forward_list`, `array`, `string`, `map`, `set`, `unordered_map`, `unordered_set`, `stack`, `queue`, `priority_queue` |
| 이터레이터 | 요소 접근/이동 | `begin()`, `end()`로 획득, `++it`, `*it` |
| 알고리즘 | 범용 연산 | `sort`, `stable_sort`, `nth_element`, `accumulate`, `copy`, `remove_if`, `unique`, `partition`, `find`, `lower_bound` |
| 함수 객체(Functor)/람다 | 알고리즘의 “전략” | `std::less<>`, 사용자 람다 |
| 어댑터/뷰 | 인터페이스 변환 | 컨테이너 어댑터(`stack` 등), C++20 ranges 뷰 |
| 할당자(Allocator) | 메모리 전략 교체 | `std::allocator`, 커스텀 풀 할당자 |

---

## 컨테이너 한눈 분류 (노드 기반 vs 배열 기반)

### 순차 컨테이너 (Sequence)

| 컨테이너 | 내부 구조 | 강점 | 약점 | 대표 복잡도(평균) |
|---|---|---|---|---|
| `vector<T>` | 동적 배열 (contiguous) | 임의접근 O(1), 캐시 친화, 대부분의 경우 기본 선택 | 중간 삽입/삭제 O(n), 재할당 시 반복자 무효화 | `push_back` amortized O(1), `insert(pos)` O(n) |
| `deque<T>` | 분절 배열(block list) | 양끝 삽입/삭제 O(1) | 중간 삽입/삭제 O(n) | 임의접근 O(1) (하지만 캐시 지역성↓) |
| `list<T>` | 이중 연결 리스트 | 어디서든 삽입/삭제 O(1) (노드 포인터만 있음) | 임의접근 불가, 캐시 비우호, 메모리 오버헤드 | 이동/`splice` O(1) |
| `forward_list<T>` | 단방향 리스트 | 초경량, O(1) 삽입 | 역방향 불가 | 단일 링크 제한 |
| `array<T, N>` | 고정 크기 배열 | 스택/정적 할당, 오버헤드 0 | 크기 고정 | 임의접근 O(1) |

> **연속 메모리(Contiguous)**: `vector`, `string`, `array`는 C API와 궁합이 좋고 SIMD/프리패치 유리.

### 연관 컨테이너 (정렬 트리 기반)

| 컨테이너 | 내부 구조 | 특징 | 복잡도 |
|---|---|---|---|
| `set<T>`, `map<K,V>` | 균형 이진트리(RB-tree) | 자동 정렬/유일키(`set`), 키-값(`map`) | 탐색/삽입/삭제 O(log n) |
| `multiset`, `multimap` | 동일 | 중복 허용 | 동일 |

> **이진트리 기반**이라 순회가 정렬 순서, **범위 쿼리(lower/upper_bound)** 강력.

### 비정렬 연관 컨테이너 (해시 기반)

| 컨테이너 | 구조 | 특징 | 복잡도(평균) |
|---|---|---|---|
| `unordered_set<T>`, `unordered_map<K,V>` | 해시 + 버킷 | 키 해시, 순서 없음 | 탐색/삽입/삭제 평균 O(1), 최악 O(n) |
| `unordered_multi*` | 동일 | 중복 허용 | 동일 |

> **해시 품질/로드 팩터**가 성능을 좌우. **재해시(rehash)** 시 반복자 무효화 주의.

### 어댑터 (인터페이스 변환자)

| 어댑터 | 기반 | 의미 |
|---|---|---|
| `stack` | 기본 `deque` | LIFO |
| `queue` | 기본 `deque` | FIFO |
| `priority_queue` | 기본 `vector` + 힙 | 우선순위 큐 (최댓값/최솟값 pop) |

---

## 이터레이터 5계급 (알고리즘 적용 범위의 열쇠)

| 카테고리 | 연산 | 예시 컨테이너 |
|---|---|---|
| **Input** | `++`, `*`(읽기) | 입력 스트림 이터레이터 |
| **Output** | `++`, `*`(쓰기) | 출력 스트림 이터레이터 |
| **Forward** | 다회 통과 + 읽기/쓰기 | `forward_list`, `unordered_*` |
| **Bidirectional** | `++`, `--` | `list`, `set/map` |
| **RandomAccess** | `+/-`, `it[n]`, 비교 | `vector`, `deque`, `array`, 포인터 |

> 예: `sort`는 **RandomAccess** 필수 → `vector`/`deque`/배열에서만 호출 가능.
> `stable_sort`도 동일. `list`는 `list::sort()`를 제공.

---

## 알고리즘(algorithm) — 컨테이너 독립 범용 도구

대표 패턴과 복잡도(평균):

| 알고리즘 | 설명 | 복잡도 |
|---|---|---|
| `sort(first,last,cmp)` | 불안정 정렬 (IntroSort) | O(n log n) |
| `stable_sort` | 안정 정렬 | O(n log n) |
| `nth_element` | n번째 원소 기준 파티션 | 평균 O(n) |
| `partial_sort` | 앞쪽 k개만 정렬 | O(n log k) |
| `partition`/`stable_partition` | 조건에 따라 분할 | O(n) / O(n log n) |
| `lower_bound`/`upper_bound` | 정렬 구간에서 이분 탐색 | O(log n) |
| `unique` | 인접 중복 제거(정렬 필요 X) | O(n) |
| `accumulate` | 누적 합/임의 연산 | O(n) |
| `remove`/`remove_if` | “지우지 않고 앞으로 땡김” | O(n) |

### 예시: `erase-remove` 관용구 (vector에서 조건 삭제)

```cpp
#include <vector>
#include <algorithm>

std::vector<int> v{1,2,3,4,5,6};
// 홀수만 남기고 싶다 → 짝수 제거
v.erase(std::remove_if(v.begin(), v.end(), [](int x){ return x%2==0; }), v.end());
```

- `remove_if`는 원소를 **뒤에서 앞으로 당겨 배치**만 하고, 실제 지우지는 않음 → `erase`로 꼬리 구간 제거 필요.

---

## **반복자 무효화(Iterator Invalidation)** — 실전 오류 1순위

| 컨테이너 | 언제 무효화? | 안전 규칙 |
|---|---|---|
| `vector` | 용량 초과 재할당 시 **전부**, 중간 `erase/insert` 이후 **해당 지점 이후** | 재할당 가능성 있는 `push_back` 후 반복자 재획득 |
| `deque` | 양끝 삽입/삭제 시 일부 구간, 중간 삽입/삭제 시 복잡 | 일반적으로 조작 후 반복자 갱신 |
| `list` | 노드 기반 → **다른 노드 영향 없음** | 지운 노드의 반복자만 무효 |
| `map/set` | 트리 회전에도 개별 노드 반복자 대부분 유지 | 지운 노드의 반복자만 무효 |
| `unordered_*` | **rehash** 시 전부, 개별 erase는 그 노드만 | 로드 팩터 변화 전후 반복자 재획득 |

> 안전 패턴: 변경이 일어난 **컨테이너 조작 직후** 반복자/포인터/참조는 **다시 얻어라**.

---

## 예외 안전(Strong/Basic/No-throw) & 이동 시맨틱스

- **기본 보장(Basic)**: 예외 시 리소스 누수 없음, 객체는 유효하지만 값은 변경 가능.
- **강한 보장(Strong)**: 예외 시 **연산 전 상태 유지**.
- **No-throw 이동**이 가능한 타입(`noexcept` move)일수록 `vector` 재할당 시 강한 보장 달성 쉬움.

> 컨테이너는 대체로 **삽입/재배치 시 move**를 사용. 사용자 타입에 **예외를 던지지 않는 move**를 제공하면 전체가 안전·빠름.

---

## “언제 무엇을 고를까?” — 선택 가이드

- **기본은 `vector`**: 캐시 지역성/단순성/표준 알고리즘 호환 최고.
- **중간 삽입/삭제가 많고 반복자 안정성 중요** → `list`/`map`/`unordered_map`(키 접근 패턴에 따라).
- **정렬된 데이터에 범위 쿼리** → `map`/`set` + `lower_bound` 류.
- **키로 빠른 접근/순서 불필요** → `unordered_map`.

---

## STL 사용 확장: 투명 비교자/이종 조회/커스텀 해시

### 투명 비교자(heterogeneous lookup)

```cpp
#include <set>
#include <string>
#include <string_view>

struct TransparentLess {
    using is_transparent = void;
    template<class L, class R>
    bool operator()(const L& l, const R& r) const { return l < r; }
};

int main(){
    std::set<std::string, TransparentLess> s{"abc","xyz"};
    // 이종 타입 string_view로 조회
    auto it = s.find(std::string_view{"xyz"});
}
```

- `is_transparent` 가 있으면 `find`, `lower_bound`에 **다른 타입 키** 전달 가능 → **복사/할당 비용 절감**.

### 커스텀 해시 + equal_to

```cpp
#include <unordered_map>
#include <string>
#include <string_view>

struct SvHash {
    using is_transparent = void;
    size_t operator()(std::string_view s) const noexcept {
        return std::hash<std::string_view>{}(s);
    }
};
struct SvEq {
    using is_transparent = void;
    using is_transparent_key_equal = void; // 구현에 따라 선택적
    bool operator()(std::string_view a, std::string_view b) const noexcept { return a==b; }
};

int main(){
    std::unordered_map<std::string, int, SvHash, SvEq> m;
    m.emplace("alice", 10);
    // string_view로 이종 조회
    auto it = m.find(std::string_view{"alice"});
}
```

---

## `emplace` 계열과 `piecewise_construct`

- `insert`는 **객체를 만든 뒤** 복사/이동하여 넣음.
- `emplace`는 **컨테이너 내부에서 직접 생성**(생성자 인자를 전달).
- `map/emplace`는 키/값을 별도 인자로 받아 **불필요한 임시**를 줄여 성능↑.

```cpp
#include <map>
#include <string>

int main(){
    std::map<std::string, int> m;
    m.emplace("alice", 1);                 // 내부에서 직접 생성
    m.insert(std::make_pair("bob", 2));    // 임시 pair 후 이동
}
```

복합 생성자에는 `piecewise_construct`:

```cpp
#include <map>
#include <tuple>
#include <string>

int main(){
    std::map<std::string, std::pair<int,int>> m;
    m.emplace(std::piecewise_construct,
              std::forward_as_tuple("key"),
              std::forward_as_tuple(1,2));
}
```

---

## `vector` 빠른 맛보기 (예제)

```cpp
#include <vector>
#include <iostream>
#include <algorithm>

int main(){
    std::vector<int> v{1,2,3};
    v.reserve(10);          // 재할당 최소화
    v.push_back(4);         // amortized O(1)
    std::rotate(v.begin(), v.begin()+1, v.end()); // [2,3,4,1]
    v.erase(std::remove(v.begin(), v.end(), 3), v.end()); // 3 제거
    for(int x: v) std::cout << x << ' '; // 2 4 1
}
```

---

## `map`/`unordered_map` 핵심 API 패턴

### `map` (트리, 정렬/범위 쿼리)

```cpp
#include <map>
#include <string>
#include <iostream>

int main(){
    std::map<std::string, int> m;
    auto [it, inserted] = m.emplace("alice", 10);
    it->second += 5; // 15

    auto lb = m.lower_bound("a"); // 첫 "a" 이상
    auto ub = m.upper_bound("az"); // "az" 초과 첫 위치
    for(auto iter = lb; iter != ub; ++iter)
        std::cout << iter->first << ":" << iter->second << "\n";
}
```

### `unordered_map` (해시, 평균 O(1))

```cpp
#include <unordered_map>
#include <string>
#include <iostream>

int main(){
    std::unordered_map<std::string,int> m;
    m.reserve(128); // rehash 최소화
    m["bob"] = 7;
    m.emplace("alice", 10);
    if(auto it = m.find("alice"); it != m.end()){
        std::cout << it->second << "\n";
    }
}
```

---

## C++20 Ranges와의 연결

- **뷰(View)**: 원본 데이터 소유하지 않는 지연 평가 파이프라인.

```cpp
#include <ranges>
#include <vector>
#include <iostream>

int main(){
    std::vector<int> v{1,2,3,4,5,6};
    auto rng = v
             | std::views::filter([](int x){ return x%2==0; })
             | std::views::transform([](int x){ return x*x; });

    for(int x: rng) std::cout << x << ' '; // 4 16 36
}
```

---

## 비소유 문자열/메모리 뷰: `string_view`, `span`

```cpp
#include <string_view>
#include <iostream>

int main(){
    std::string s = "hello";
    std::string_view sv = s;      // 복사 X, 포인터+길이
    std::cout << sv.substr(1,3);  // "ell"
}
```

```cpp
#include <span>
#include <vector>
#include <iostream>

void dump(std::span<const int> a){
    for(int x: a) std::cout << x << ' ';
}

int main(){
    std::vector<int> v{1,2,3};
    dump(v); // 복사 없이 범위 전달
}
```

> **수명** 주의: `string_view`/`span`는 원본이 살아있는 동안만 유효.

---

## STL + 수학적 복잡도 감각

- 정렬 알고리즘 평균 복잡도: $$O(n \log n)$$
- `nth_element` 평균: $$O(n)$$ (선택 문제)
- 해시 기반 평균 탐색: $$O(1)$$, 최악 $$O(n)$$ (해시 충돌/버킷 편향 시)
- 트리 기반 탐색/삽입/삭제: $$O(\log n)$$

> 빅오만 보지 말고 **상수 인자/캐시 지역성**을 고려하라. 실전에서 `vector`가 `list`보다 빠른 이유.

---

## 코딩 규범/함정 체크리스트

1) **컨테이너 선택 기본값은 `vector`**
2) **`erase-remove`** 패턴 암기 (순차 컨테이너 조건 삭제)
3) 반대로 **연관 컨테이너에는 `remove` 없음** → `erase(key)`/`erase(it)`
4) 반복자 무효화 규칙에 민감할 것 (`vector` 재할당/`unordered` rehash)
5) **`emplace` 선호**, 복사/이동 줄이기
6) **범위 기반 for** / `auto` / 람다 적극 활용
7) **예외 안전**: 사용자 타입의 **noexcept move** 검토
8) **성능**: `reserve`/`shrink_to_fit` 전략적 사용, `unordered`의 `reserve`로 rehash 비용 억제
9) **키 비교/해시**는 **투명 비교자/이종 조회**로 할당/복사 줄이기
10) **뷰/비소유 뷰(string_view/span)**: 수명 관리에 더욱 신중

---

## 실습 과제(짧고 강력)

1) **로그 집계기**: `unordered_map<string,int>`로 단어 카운트, `string_view` 이종 조회 적용.
2) **Top-K**: `partial_sort` vs `nth_element` 성능 비교(큰 N, 작은 k).
3) **범위 쿼리**: 정렬된 `map`에서 `lower_bound`/`upper_bound`로 구간 합(누적 벡터와 비교).
4) **대량 삽입**: `vector::reserve` 유무에 따른 시간 차이 측정.
5) **삭제 패턴**: `vector`/`list`에서 중간 다량 삭제 시 성능 차이 측정.

---

## 간단 예제 모음 (당장 가져다 쓰기)

### 정렬 + 사용자 비교자

{% raw %}
```cpp
#include <vector>
#include <string>
#include <algorithm>

struct User { int id; std::string name; };

int main(){
    std::vector<User> v{{2,"bob"},{1,"alice"},{3,"zoe"}};
    std::sort(v.begin(), v.end(), [](const User& a, const User& b){
        if (a.name == b.name) return a.id < b.id; // 보조키
        return a.name < b.name;
    });
}
```
{% endraw %}

### `map`에서 존재 확인/삽입

```cpp
#include <map>
#include <string>
#include <iostream>

int main(){
    std::map<std::string,int> m;
    if (auto [it, inserted] = m.emplace("kim", 1); inserted)
        std::cout << "new\n";
    else
        std::cout << "exists:" << it->second << "\n";
}
```

### `unordered_map`에서 재해시 고려

```cpp
#include <unordered_map>
#include <string>

int main(){
    std::unordered_map<std::string,int> m;
    m.reserve(10000); // 사전 확보로 rehash 회수↓
    for(int i=0;i<10000;i++) m.emplace(std::to_string(i), i);
}
```

### 범위 알고리즘 (C++20)

```cpp
#include <ranges>
#include <vector>
#include <algorithm>
#include <iostream>

int main(){
    std::vector<int> v{1,2,3,4,5,6,7,8};
    auto odds_squared = v
      | std::views::filter([](int x){ return x%2; })
      | std::views::transform([](int x){ return x*x; });

    // 복사하여 벡터로 물질화
    std::vector<int> out;
    std::ranges::copy(odds_squared, std::back_inserter(out));
    for(int x: out) std::cout << x << ' '; // 1 9 25 49
}
```

---

## 마무리 — 다음 장을 위한 발판

이 글에서 **STL의 전반 지도**를 깔았다:

- 핵심 분해(컨테이너/이터레이터/알고리즘)와 **설계 철학**
- **컨테이너 분류/선택 기준**과 **반복자 무효화/예외 안전** 규칙
- 실전 필수 관용구(`erase-remove`, `emplace`, 이종 조회, `reserve`, ranges)

다음 글에서는 **순차 컨테이너별 심화**(특성·복잡도·실전 패턴), `vector/list/deque`부터 들어간다.
그 전에, **실습 과제**를 최소 하나 이상 직접 측정/검증해 볼 것을 권한다. **감으로 느낀 성능은 종종 틀린다.**
