---
layout: post
title: C++ - STL (1)
date: 2024-09-12 19:20:23 +0900
category: Cpp
---
# STL 1 — STL이란 무엇인가?

## 왜 STL인가? — 자료구조와 알고리즘의 표준화된 부품 창고

STL(Standard Template Library)은 C++ 표준 라이브러리의 핵심으로, **제네릭 프로그래밍** 철학을 구현합니다. 핵심 설계 아이디어는 **데이터(컨테이너)**, **데이터 접근 수단(이터레이터)**, **연산(알고리즘)** 이라는 세 요소를 **느슨하게 결합**하는 것입니다.

이 덕분에 알고리즘은 특정 컨테이너에 종속되지 않고, 일관된 인터페이스(이터레이터)를 제공하는 모든 컨테이너에서 재사용될 수 있습니다. 마치 서로 호환되는 표준 나사와 렌치처럼 말이죠.

---

## STL의 장점: 생산성, 성능, 안전성의 조화

*   **생산성**: 검증된 최적의 자료구조와 알고리즘을 바로 사용할 수 있습니다. 바퀴를 다시 발명할 필요가 없죠.
*   **성능**: 템플릿 기반의 정적 다형성으로 인라인화가 쉬우며, 각 구현체는 해당 자료구조에 맞게 심도 있게 최적화되어 있습니다.
*   **안전성**: 예외 안전성 보장, RAII(Resource Acquisition Is Initialization)를 통한 자동 자원 관리, 반복자 범위 검사 등 안전한 프로그래밍을 지원합니다.
*   **일관성**: 모든 컨테이너와 알고리즘이 통일된 패턴(`begin()`, `end()`, 이터레이터)을 따르므로 학습과 사용이 용이합니다.

---

## STL의 큰 그림: 구성 요소

| 요소 | 역할 | 주요 예시 |
|---|---|---|
| **컨테이너** | 데이터를 저장하고 수명을 관리 | `vector`, `list`, `map`, `set`, `string` |
| **이터레이터** | 컨테이너 내 요소에 접근하고 순회하는 포인터와 유사한 객체 | `begin()`, `end()`로 얻어 `++it`, `*it`로 사용 |
| **알고리즘** | 데이터에 대한 범용적인 연산을 수행 | `sort`, `find`, `copy`, `accumulate` |
| **함수 객체 / 람다** | 알고리즘의 동작 방식을 제어하는 '전략' | `std::less`, 사용자 정의 비교 함수, `[](int x){ return x>0; }` |
| **어댑터** | 기존 컨테이너의 인터페이스를 변환 | `stack`(LIFO), `queue`(FIFO), `priority_queue` |
| **할당자** | 컨테이너의 메모리 할당 방식을 커스터마이즈 | 기본 `std::allocator`, 커스텀 메모리 풀 |

---

## 컨테이너 선택 가이드: 상황에 맞는 도구 선택

### 순차 컨테이너 (데이터의 순서가 중요할 때)
*   **`vector<T>`**: **기본 선택입니다.** 연속된 메모리에 저장되어 캐시 효율이 뛰어나고 임의 접근이 빠릅니다(O(1)). 뒤에서의 추가/삭제는 빠르나, 중간에서의 작업은 비용이 큽니다(O(n)). 재할당 시 반복자가 무효화될 수 있습니다.
*   **`deque<T>`**: 앞과 뒤에서의 추가/삭제가 모두 빠릅니다(O(1)). 연속된 메모리처럼 동작하지만 내부는 분할된 배열로 구성되어 있어 `vector`보다 캐시 효율이 약간 낮을 수 있습니다.
*   **`list<T>`**: **양방향 연결 리스트입니다.** 중간 삽입/삭제가 빠르고(O(1)), 반복자 무효화에 강합니다. 하지만 임의 접근이 불가능하며, 메모리 오버헤드가 있고 캐시 효율이 낮습니다.
*   **`forward_list<T>`**: 단방향 연결 리스트로, `list`보다 더 가볍지만 역방향 순회가 불가능합니다.
*   **`array<T, N>`**: **크기가 컴파일 타임에 고정된 배열**입니다. 가장 가볍고 빠르지만, 크기 조절이 불가능합니다.

### 연관 컨테이너 (빠른 검색과 정렬이 필요할 때)
*   **`set<T>`, `map<K,V>`**: **균형 이진 탐색 트리(보통 레드-블랙 트리)** 기반입니다. 키 기반으로 자동 정렬되며, 탐색/삽입/삭제가 O(log n)입니다. 정렬된 순서로 순회하거나 범위 검색(`lower_bound`)에 유리합니다.
*   **`multiset`, `multimap`**: 동일한 구조이지만 중복 키를 허용합니다.

### 비정렬 연관 컨테이너 (최고의 평균 검색 속도)
*   **`unordered_set<T>`, `unordered_map<K,V>`**: **해시 테이블** 기반입니다. 순서가 없지만 평균적으로 O(1)의 매우 빠른 탐색/삽입/삭제를 제공합니다. 해시 함수의 품질과 재해시 시점이 성능을 좌우합니다.

---

## 알고리즘과 이터레이터: 컨테이너를 넘어선 협업

이터레이터는 알고리즘과 컨테이너를 연결하는 다리 역할을 합니다. 알고리즘은 특정 종류의 이터레이터를 요구하며, 이는 해당 알고리즘이 어떤 컨테이너에서 작동할 수 있는지를 결정합니다.

*   **`sort`, `stable_sort`**: **임의 접근(RandomAccess)** 이터레이터가 필요합니다. 따라서 `vector`, `deque`, `array`에서만 사용 가능합니다. `list`는 자체 `sort()` 멤버 함수를 제공합니다.
*   **`find`, `accumulate`, `remove_if`**: **순방향(Forward)** 이터레이터만 필요하므로, 대부분의 STL 컨테이너에서 사용할 수 있습니다.

**실전 패턴: `erase-remove` 관용구**
`vector`에서 조건에 맞는 여러 요소를 효율적으로 삭제하는 방법입니다.
```cpp
std::vector<int> v{1,2,3,4,5,6};
// 홀수만 남기기: remove_if는 삭제할 요소를 뒤로 모으고, 유효 범위의 끝 이터레이터를 반환한다.
auto new_end = std::remove_if(v.begin(), v.end(), [](int x){ return x%2==0; });
// erase를 통해 실제로 불필요한 뒷부분을 제거한다.
v.erase(new_end, v.end());
```

---

## 주의사항: 반복자 무효화와 수명 관리

컨테이너를 변경하는 연산을 수행할 때, 기존에 얻은 반복자, 포인터, 참조가 더 이상 유효하지 않게 되는 경우가 있습니다. 이는 흔한 오류 원인입니다.

*   **`vector`/`string`**: **재할당이 발생하면 모든 반복자가 무효화됩니다.** `push_back`, `resize` 등으로 용량이 넘칠 때 발생할 수 있습니다. `reserve()`를 미리 호출하여 재할당을 방지할 수 있습니다.
*   **`deque`**: 양끝이 아닌 위치에서 삽입/삭제 시 대부분의 반복자가 무효화됩니다.
*   **`list`/`map`/`set`**: **노드 기반**이므로, 다른 노드를 가리키는 반복자는 일반적으로 안전합니다. 지워진 노드를 가리키는 반복자만 무효화됩니다.
*   **`unordered_map`/`unordered_set`**: **재해시가 발생하면 모든 반복자가 무효화됩니다.** `reserve()`로 재해시 횟수를 줄일 수 있습니다.

**안전한 습관:** 컨테이너를 수정한 후에는 필요한 반복자를 다시 얻는 것이 좋습니다.

---

## 현대적인 활용법

**투명 비교자(Heterogeneous Lookup)**
`map`이나 `set`에서 키와 다른 타입(예: `string_view`)으로 검색하여 불필요한 임시 객체 생성을 막습니다.
```cpp
std::set<std::string, std::less<>> transparentSet; // std::less<> 사용
transparentSet.find("key"sv); // std::string_view로 검색 가능
```

**`string_view`와 `span`: 비소유 뷰**
데이터의 복사 없이 읽기 전용 또는 읽기-쓰기 범위를 참조할 때 사용합니다. 원본 데이터의 수명 관리에 주의해야 합니다.
```cpp
std::string original = "Hello World";
std::string_view view(original);
std::cout << view.substr(0,5); // "Hello"
```

**C++20 Ranges**
더 선언적이고 안전한 방식으로 알고리즘을 적용할 수 있게 해줍니다.
```cpp
auto result = data | std::views::filter(is_even) | std::views::transform(square);
```

---

## 결론: STL은 생각의 틀을 제공한다

STL은 단순한 라이브러리 그 이상입니다. 이는 C++로 효율적이고 안전하며 우아한 소프트웨어를 구축하기 위한 **철학과 도구 상자**입니다. 처음에는 다양한 컨테이너와 알고리즘의 구체적인 사용법을 익히는 것이 중요하지만, 궁극적으로는 **각 도구의 특성(복잡도, 캐시 영향, 반복자 안정성)을 이해**하고, 문제에 맞는 최적의 도구를 선택하는 안목을 키우는 것이 핵심입니다.

`vector`가 만능은 아니지만, 그럼에도 불구하고 기본 선택으로 삼는 이유를, `map`과 `unordered_map`의 근본적인 차이를, 그리고 알고리즘을 컨테이너와 독립적으로 설계한 지혜를 곱씹어보세요. 이러한 이해는 단순한 코드 작성에서 한 차원 높은 소프트웨어 설계로 나아가는 디딤돌이 될 것입니다. 다음 글에서는 이 넓은 지도에서 첫 번째 탐험지로, 가장 기본적이면서도 강력한 순차 컨테이너들의 세계로 깊이 들어가 보겠습니다.