---
layout: post
title: 컴퓨터시스템 - Y86-64 인스트럭션 집합 구조
date: 2025-07-26 19:20:23 +0900
category: 컴퓨터시스템
---
# Y86-64 인스트럭션 집합 구조

## 1. 설계 목표와 개요

- **교육 목적**: 실제 x86-64의 복잡도를 줄이고, **기계 수준 관점**(레지스터, 메모리, 분기, 호출/반환, 조건 코드, 파이프라인)을 학습하기 위해 고안된 축소 ISA.  
- **통일된 인코딩 규칙**: 모든 명령의 **첫 바이트**는 상위 4비트 `icode` + 하위 4비트 `ifun`. 디코더 구현이 단순해진다.  
- **핵심 개념 유지**: 64비트 일반 레지스터, 리틀 엔디안 메모리, 조건 코드(ZF/SF/OF), `call`/`ret` 기반 스택 호출 등 **본질은 실 아키텍처와 유사**.  
- **학습 포인트**:  
  1) **바이트 인코딩**을 직접 다뤄보기, 2) **조건 분기**의 플래그 논리, 3) **스택 프레임**과 호출 규약, 4) **파이프라인 해저드**(stall/bubble/forwarding) 이해.

---

## 2. 레지스터 집합과 레지스터 id

Y86-64는 64비트 일반 레지스터를 사용하며, 인코딩 시 **4비트 id**로 표현한다. `0xF`는 **REG_NONE**(레지스터 없음).

| 레지스터 | id | 비고 |
|---|---:|---|
| `%rax` | 0x0 | 반환값/범용 |
| `%rcx` | 0x1 | 범용 |
| `%rdx` | 0x2 | 범용 |
| `%rbx` | 0x3 | 범용 |
| `%rsp` | 0x4 | 스택 포인터 |
| `%rbp` | 0x5 | 프레임 포인터 |
| `%rsi` | 0x6 | 범용 |
| `%rdi` | 0x7 | 범용 |
| `%r8`  | 0x8 | 범용 |
| `%r9`  | 0x9 | 범용 |
| `%r10` | 0xA | 범용 |
| `%r11` | 0xB | 범용 |
| `%r12` | 0xC | 범용 |
| `%r13` | 0xD | 범용 |
| `%r14` | 0xE | 범용 |
| `NONE` | 0xF | 없음(placeholder) |

---

## 3. 메모리 모델과 바이트 순서

- **주소 단위 = 바이트**.  
- **리틀 엔디안**: 다바이트(예: 8B) 값 저장 시 **하위 바이트가 낮은 주소**.  
- 프로그램은 `.text/.data/.bss/stack/heap` 개념으로 배치되며, 어셈블러 지시어 `.pos`, `.align`, `.quad` 등을 사용한다.

간단 예시:

```asm
.pos 0x0
irmovq $0x1122334455667788, %rax   # 메모리에는 88 77 66 55 44 33 22 11 순으로 저장
```

---

## 4. 명령어 형식(공통 규칙)

모든 명령의 **첫 바이트**: `[icode:4][ifun:4]`.

추가 필드:

1) **reg 바이트(선택)**: 1바이트 `[regA:4][regB:4]`  
2) **즉치 V(선택)**: 8바이트 리틀 엔디안  
3) **목적지/오프셋 D(선택)**: 점프/호출 목적지 또는 메모리 유효주소 계산용(8B)

길이 패턴(암기):

- **1B**: `halt`, `nop`, `ret`  
- **2B**: `rrmovq/cmovXX`, `OPq`, `pushq`, `popq`  
- **9B**: `jXX`, `call`  (1 + 8)  
- **10B**: `irmovq`, `rmmovq`, `mrmovq`  (1 + 1 + 8)

---

## 5. 명령 집합 일람(icode/ifun)

| icode | 명령 | ifun | 형식 |
|---:|---|---|---:|
| 0x0 | `halt` | 0 | 1 |
| 0x1 | `nop`  | 0 | 1 |
| 0x2 | `rrmovq`/`cmovXX` | 0:rr, 1:le, 2:l, 3:e, 4:ne, 5:ge, 6:g | 2 |
| 0x3 | `irmovq` | 0 | 10 |
| 0x4 | `rmmovq` | 0 | 10 |
| 0x5 | `mrmovq` | 0 | 10 |
| 0x6 | `OPq` | 0:addq, 1:subq, 2:andq, 3:xorq | 2 |
| 0x7 | `jXX` | 0:jmp,1:jle,2:jl,3:je,4:jne,5:jge,6:jg | 9 |
| 0x8 | `call` | 0 | 9 |
| 0x9 | `ret` | 0 | 1 |
| 0xA | `pushq` | 0 | 2 |
| 0xB | `popq` | 0 | 2 |

> 첫 바이트는 `(icode<<4)|ifun`. 예: `addq` → `0x60`, `je` → `0x73`.

---

## 6. 개별 명령 인코딩과 예제

### 6.1 `halt`
- 바이트: `00`
- 길이: 1B

### 6.2 `nop`
- 바이트: `10`
- 길이: 1B

### 6.3 `rrmovq`/`cmovXX`  (icode=2)
- 형식: `2ifun  regA/regB`
- 효과: (조건 만족 시) `R[regB] ← R[regA]`
- 예: `rrmovq %rax, %rbx`  
  - 첫 바이트: `0x20`, reg: `0x03` → `20 03`

### 6.4 `irmovq V, rB`  (icode=3, ifun=0)
- 형식: `30  reg(F/rB)  V(8B LE)`  
- 관례: reg 바이트 상위 nibble은 `F`(NONE), 하위가 목적 레지스터  
- 예: `irmovq $0x10, %rax` → `30 f0 10 00 00 00 00 00 00 00`

### 6.5 `rmmovq rA, D(rB)`  (icode=4)
- 형식: `40  reg(rA/rB)  D(8B)`  
- 효과: `M[R[rB]+D] ← R[rA]`
- 예: `rmmovq %rax, 8(%rbp)` → `40 05 08 00 00 00 00 00 00 00`

### 6.6 `mrmovq D(rB), rA`  (icode=5)
- 형식: `50  reg(rA/rB)  D(8B)`  
- 효과: `R[rA] ← M[R[rB]+D]`
- 예: `mrmovq 8(%rbp), %rax` → `50 05 08 00 00 00 00 00 00 00`

### 6.7 `OPq rA, rB`  (icode=6)
- 형식: `6ifun  reg(rA/rB)`  
- 효과: `R[rB] ← R[rB] OP R[rA]`  
- 플래그 설정(ZF/SF/OF)
- 예: `addq %rbx, %rax`  
  - ifun=0 → `0x60`, reg= `0x30` → `60 30`

### 6.8 `jXX D`  (icode=7)
- 형식: `7ifun  D(8B)`  
- 예: `je 0x400` → `73 00 04 00 00 00 00 00 00`

### 6.9 `call D`  (icode=8)
- 형식: `80  D(8B)`  
- 효과: `R[%rsp]-=8; M[R[%rsp]] ← return_pc; PC ← D`

### 6.10 `ret`  (icode=9)
- 형식: `90`  
- 효과: `PC ← M[R[%rsp]]; R[%rsp]+=8`

### 6.11 `pushq rA`  (icode=A)
- 형식: `A0  reg(rA/F)`  
- 효과: `R[%rsp]-=8; M[R[%rsp]]←R[rA]`
- 예: `pushq %rax` → `A0 0F`

### 6.12 `popq rA`  (icode=B)
- 형식: `B0  reg(F/rA)`  
- 효과: `R[rA]←M[R[%rsp]]; R[%rsp]+=8`
- 예: `popq %rax` → `B0 F0`

---

## 7. 조건 코드와 분기 논리

Y86-64는 **ZF(Zero)**, **SF(Sign)**, **OF(Overflow)** 3개 플래그를 사용한다.  
`OPq` 연산 후 플래그 갱신, `irmovq/mrmovq/rmmovq` 등은 플래그에 영향 없음.

대표 조건의 논리(부호 있는 비교):

- $$\mathrm{eq}: ZF=1$$
- $$\mathrm{ne}: ZF=0$$
- $$\mathrm{lt}: SF \oplus OF = 1$$
- $$\mathrm{le}: (SF \oplus OF) \lor ZF = 1$$
- $$\mathrm{ge}: SF \oplus OF = 0$$
- $$\mathrm{gt}: (SF \oplus OF)=0 \land ZF=0$$

예: `jle`는 “작거나 같다” → $$ (SF \oplus OF)\ \lor\ ZF $$

---

## 8. 호출 규약과 스택 프레임(간단 규칙)

- **인자 전달**: 단순화를 위해 **스택에 push** 하여 전달(교육용 관례).  
- **반환값**: `%rax`.  
- **호출자(caller)**: 인자 push, `call`, 반환값 사용.  
- **피호출자(callee)**: 필요 시 스택 프레임 구성, 보존 레지스터 저장/복구, `ret` 로 복귀.

전형적 프레임 예(표기식):

```asm
# 프로로그
pushq %rbp
rrmovq %rsp, %rbp
# ... 필요시 지역공간 확보: iaddq 같은 확장 없으면, 스택 쓰기는 rmmovq로 직접 수행 ...

# 에필로그
rrmovq %rbp, %rsp
popq %rbp
ret
```

---

## 9. 어셈블리 지시어와 간단 프로그램

Y86 어셈블러(yas)는 다음 지시어를 지원한다(대표):

- `.pos addr`  : 로드 위치 지정  
- `.align k`   : 정렬(k의 배수)  
- `.quad imm`  : 8바이트 상수 배치

### 예제: 두 수 합산 후 종료

```asm
# sum.ys
.pos 0x0
    irmovq $8, %rax         # rax = 8
    irmovq $5, %rbx         # rbx = 5
    addq   %rbx, %rax       # rax = rax + rbx (=13)
    halt
```

바이트(헥사):

```
30 f0 08 00 00 00 00 00 00 00
30 f3 05 00 00 00 00 00 00 00
60 30
00
```

### 예제: 메모리에 쓰고 읽기

```asm
# mem.ys
.pos 0x0
    irmovq $16, %rbp
    irmovq $0x1122, %rax
    rmmovq %rax, 8(%rbp)
    mrmovq 8(%rbp), %rcx
    halt
```

핵심 바이트:

```
30 f5 10 00 00 00 00 00 00 00
30 f0 22 11 00 00 00 00 00 00
40 05 08 00 00 00 00 00 00 00
50 15 08 00 00 00 00 00 00 00
00
```

---

## 10. 분기/호출 예제와 주소 계산

분기/호출은 **절대 목적지 주소 D(8B)** 를 사용한다(교육용 단순화).

```asm
# branch_call.ys
.pos 0x0
    irmovq $0, %rax
    jmp  loop

.pos 0x20
loop:
    addq %rdi, %rax
    jg   loop
    call finish

finish:
    halt
```

- `jmp loop` 는 목적지 D=0x20, 바이트: `70 20 00 00 00 00 00 00 00`  
- `jg loop`  는 `76 20 00 00 00 00 00 00 00`  
- `call finish` 는 finish의 주소를 D에 리틀엔디안으로 배치

---

## 11. 시뮬레이터/어셈블러 사용법

- `yas`: Y86 어셈블리(.ys) → 바이너리(.yo)  
- `y86sim`: 실행/디버깅(레지스터/메모리/PC 관찰)

전형 워크플로:

```bash
yas sum.ys           # sum.yo 생성
y86sim sum.yo        # 실행, 상태 출력
```

디버깅 팁:

- 명령 길이(1/2/9/10B)와 **reg 바이트의 nibble 순서**를 정확히.  
- 리틀 엔디안 즉치/주소는 **낮은 바이트부터**.  
- `pushq r` = `A0 (r<<4|F)`, `popq r` = `B0 (F<<4|r)` 외우기.

---

## 12. 파이프라인 관점(SEQ → PIPE)

### 12.1 단계 개요

Y86-64 프로세서는 교육용으로 **단일 사이클(SEQ)** 모델과 **5단계 파이프라인(PIPE)** 모델이 제시된다.

- **F**etch: 메모리에서 명령어 바이트 인출(icode/ifun/레지스터/즉치)  
- **D**ecode: 레지스터 읽기  
- **E**xecute: ALU 연산/조건 평가/유효주소 계산  
- **M**emory: 데이터 메모리 접근(load/store)  
- **W**rite-back: 결과 레지스터 기록  
- **PC update**: 다음 PC 선택(분기/호출/복귀 반영)

파이프라인 레지스터: **F/D/E/M/W** 단계 사이에 버퍼를 둔다.

### 12.2 포워딩과 해저드 제어

- **데이터 해저드**: 이전 단계 결과가 다음 명령에 필요.  
  → **forwarding**(E/M/W 단계 결과를 D/E 입력으로 우회 전달)로 대부분 해결.  
- **load/use 해저드**: `mrmovq` 결과가 바로 다음 명령에 필요할 때, 메모리 단계 후에야 값이 유효.  
  → **stall**(D/F 정지) + **bubble**(E에 버블 삽입) 규칙.  
- **제어 해저드**: 분기/return  
  - 분기: 보통 **예측**(예: not-taken) + 오판 시 **bubble**로 정정.  
  - `ret`: 반환 주소를 메모리에서 읽어야 하므로 다음 PC 불확정 → **stall** 필요.

대표 규칙(개념 요약):

1) **로드-유즈**: 다음 명령이 E 단계에서 로드된 레지스터를 즉시 사용  
   → F/D **stall**, E **bubble**  
2) **분기 오판**: E 단계에서 조건 판정 실패(또는 taken)로 잘못 인출됨  
   → D/E **bubble**  
3) **ret**: 반환 대상 PC를 알 때까지  
   → F **stall** (상황에 따라 D bubble)

파이프라인 설계에서 **정확한 조건식**(icode/ifun/레지스터 의존성/분기결과)을 코딩하는 것이 핵심 실습 포인트다.

---

## 13. 디코더/인코더를 손수 만들어보며 확인할 포인트

- 첫 바이트의 `icode/ifun` 조합이 **명령 클래스/변형**을 정의.  
- `reg` 바이트는 **상위 nibble=regA, 하위 nibble=regB**.  
  - `pushq r` → `(r, F)`, `popq r` → `(F, r)`  
- 즉치/주소는 **8바이트 리틀 엔디안**.  
- 실행 의미:  
  - `OPq`: `R[rB] ← R[rB] OP R[rA]`  
  - `rmmovq`: `M[R[rB]+D] ← R[rA]`  
  - `mrmovq`: `R[rA] ← M[R[rB]+D]`  
  - `cmovXX`: 조건 만족할 때만 **move** 수행  
  - `jXX`: 조건 만족 시 `PC ← D`  
  - `call`: `push return_pc; PC ← D`  
  - `ret`: `PC ← pop`  

---

## 14. 실전형 예제: 최소 함수와 호출

### 14.1 문제: `min(a,b)`를 호출해 결과 반환

C 개념을 Y86으로 구성(스택 전달 관례 가정):

```asm
# min.ys
.pos 0x0
    # caller: a=7, b=3
    irmovq $7, %rax
    pushq %rax
    irmovq $3, %rax
    pushq %rax
    call min
    addq %rsp, %rsp     # 인자 정리: 여기서는 간단히 16을 더해야 하지만
                        # iaddq(확장) 부재이므로 pop 두 번으로 정리하는 등으로 처리
    popq %rdi
    popq %rdi
    halt

# callee
.pos 0x100
min:
    # 스택에서 b, a를 읽어 비교 후 작은 값 반환
    mrmovq 16(%rsp), %rsi   # a (호출 직후 ret주소 위에 b,a)
    mrmovq 8(%rsp),  %rdi   # b
    rrmovq %rsi, %rax       # rax <- a
    subq   %rdi, %rax       # rax = a - b (플래그 설정)
    jle    .Lret_b_le_a     # a <= b 이면 a가 최소
    mrmovq 8(%rsp), %rax    # 최소 = b
    ret
.Lret_b_le_a:
    mrmovq 16(%rsp), %rax   # 최소 = a
    ret
```

핵심 포인트:

- 비교는 별도 `cmp`가 없으므로 **`subq` 결과 플래그**를 사용.  
- 인자 레이아웃/정리는 교육 환경/과제 규칙에 맞춰 조정(여기서는 간략히 표현).

---

## 15. Y86-64 vs x86-64 차이 요약

| 항목 | Y86-64 | x86-64 |
|---|---|---|
| 명령어 수 | 교육용 최소 | 매우 방대 |
| 인코딩 | icode/ifun 고정 프리픽스, 길이 패턴 단순 | 가변 길이, 프리픽스/ModR/M/SIB 등 복잡 |
| 주소지정 | `reg + disp` 기본 | 수많은 변형(SIB/scale/index) |
| 조건/플래그 | ZF/SF/OF 중심 | 더 많은 플래그/명령 |
| 시스템/특권 | 없음(교육용) | 시스템 콜/세그먼트/모드 전환 등 |

---

## 16. 흔한 실수와 디버깅 체크리스트

- `pushq`/`popq` reg 바이트 nibble 순서 혼동:  
  - push: `(r, F)` → `A0 (r<<4|F)`  
  - pop : `(F, r)` → `B0 (F<<4|r)`  
- `OPq` 연산 방향: `R[rB] ← R[rB] OP R[rA]`  
- 즉치/주소 8바이트 **리틀 엔디안** 주의  
- 분기 목적지 D는 **절대 주소**(교육용 규칙)  
- `cmovXX`/`jXX`의 플래그 논리 정확히 외우기  
- 파이프라인 실습에서 **load/use**와 **ret** 처리 시 stall/bubble 조건 수식 정확히 코딩

---

## 17. 연습 문제

1) 다음을 바이트로 인코딩하라(헥사):  
   a) `irmovq $0x1234, %rbx`  
   b) `rmmovq %rbx, 16(%rsp)`  
   c) `popq %r10`  
   d) `jg 0x400`

2) `subq %rax, %rax` 실행 시 ZF/SF/OF는 어떻게 되는가?  
   - `R[%rax]`의 선행값이 0, 양수, 음수인 경우를 나눠 기술.

3) 다음 코드에서 **load/use** 해저드가 발생하는지 파이프라인 관점에서 설명하라.  
   ```
   mrmovq 0(%rbp), %rax
   addq   %rax, %rcx
   ```

4) `cmovle`와 `jle`의 차이를 동작과 사용 맥락에서 비교하라.

---

## 18. 빠른 참조(요약표)

- 첫 바이트: `[icode:4][ifun:4]`  
- reg 바이트: `[regA:4][regB:4]`  
- 길이:  
  - 1B: `00,10,90`  
  - 2B: `2x,6x, A0, B0`  
  - 9B: `7x,80`  
  - 10B: `30,40,50`  
- 대표 첫 바이트:  
  - `00` halt, `10` nop, `90` ret  
  - `20..26` rrmovq/cmovXX  
  - `30` irmovq, `40` rmmovq, `50` mrmovq  
  - `60..63` add/sub/and/xor  
  - `70..76` jXX, `80` call, `A0` pushq, `B0` popq

---

## 19. 결론

Y86-64는 **기계 수준 프로그램의 핵심**(바이트 인코딩, 조건 코드, 스택 호출, 파이프라인 제어)을 **현미경으로 들여다보듯 학습**하도록 돕는 교육용 ISA다.  
다음 순서로 연습하면 이해가 급격히 빨라진다.

1) 간단한 .ys 코드를 **직접 바이트로 인코딩**해본다.  
2) `yas/y86sim` 으로 실행하며 **레지스터/메모리/PC** 변화를 관찰한다.  
3) 분기/호출/스택/조건 코드의 상호작용을 **디버깅 로그**로 확인한다.  
4) 파이프라인 규칙(stall/bubble/forwarding)을 **조건식으로 코딩**해 해저드를 해결한다.

이 과정을 수차례 반복하면, 실제 x86-64나 다른 ISA를 볼 때에도 **기계 수준 직관**과 **성능/정확성 감각**이 자연스레 생긴다.