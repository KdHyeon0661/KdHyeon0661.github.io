---
layout: post
title: 컴퓨터시스템 - Y86-64 인스트럭션 집합 구조
date: 2025-07-26 19:20:23 +0900
category: 컴퓨터시스템
---
# Y86-64 인스트럭션 집합 구조 (상세 정리)

Y86-64는 **교육용 간이 ISA**로, Bryant & O'Hallaron의 *CS:APP* 교재 및 실습에서 사용되는 단순화된 x86-64 모델입니다. 실제 x86-64의 복잡성을 제거하고 핵심 개념(레지스터, 메모리, 명령어 인코딩, 조건 분기, 스택 기반 호출 등)을 이해하기 쉽게 만든 것이 목적입니다. 이 문서는 Y86-64의 설계 의도부터 레지스터/메모리 모델, 명령어 형식과 바이트 인코딩, 조건 코드, 실행 모델, 실제 예제 및 도구(assembler/simulator) 사용법까지 가능한 한 자세하게 정리합니다.

> ⚠️ 주의: Y86-64는 교육용 단순 모델입니다. 실무의 x86-64와 1:1 대응하지는 않으니, 차이점을 항상 염두에 두세요.

---

## 1. 설계 목표와 개요

- **교육 목적**: 복잡한 실제 아키텍처 대신 핵심 개념을 가르치기 위해 설계됨.  
- **x86-64의 축소판**: 레지스터, 메모리 모델, 호출/복귀, 조건 분기 등 유사한 구조를 유지하되 명령어 집합을 크게 단순화.  
- **명령어 인코딩 규칙 통일**: 모든 명령어는 첫 바이트에 `icode`(상위 4비트)와 `ifun`(하위 4비트)를 담음 → 디코딩을 단순화.  
- **학습 포인트**: 기계 수준의 프로그램 구조(스택 프레임, 메모리 접근, 제어 흐름)를 이해하는 데 최적.

---

## 2. 레지스터 집합

Y86-64는 64비트 레지스터들(실제 x86-64와 유사한 이름)을 사용합니다. 각 레지스터는 4비트 식별자(register id)로 인코딩됩니다. `0xF` (15)는 **REG_NONE** (레지스터 없음)을 뜻합니다.

| 레지스터 이름 | id (4비트) | 역할(표준) |
|---------------|-----------:|-----------|
| `%rax`        | 0x0        | 일반 목적 / 반환값 |
| `%rcx`        | 0x1        | 일반 목적 |
| `%rdx`        | 0x2        | 일반 목적 |
| `%rbx`        | 0x3        | 일반 목적 |
| `%rsp`        | 0x4        | 스택 포인터 |
| `%rbp`        | 0x5        | 프레임 포인터 |
| `%rsi`        | 0x6        | 일반 목적 / src |
| `%rdi`        | 0x7        | 일반 목적 / dest |
| `%r8`         | 0x8        | 일반 목적 |
| `%r9`         | 0x9        | 일반 목적 |
| `%r10`        | 0xA        | 일반 목적 |
| `%r11`        | 0xB        | 일반 목적 |
| `%r12`        | 0xC        | 일반 목적 |
| `%r13`        | 0xD        | 일반 목적 |
| `%r14`        | 0xE        | 일반 목적 |
| `NONE`        | 0xF        | 레지스터 필드 없음 (예: immediate instructions) |

> 메모: CS:APP 실습에서 `r15`는 정의되어 있지 않고 `0xE`까지 사용합니다. `0xF`는 레지스터가 필요없음을 나타냅니다.

---

## 3. 메모리와 바이트 순서

- **주소는 바이트 단위**. 모든 메모리 접근은 바이트 주소를 사용합니다.  
- **리틀 엔디안**: 다중 바이트 값(예: 8바이트 즉 64비트 즉 `V`)은 **리틀 엔디안**(least-significant byte 먼저)으로 메모리에 저장됩니다.  
- **메모리 모델**: 프로그램 텍스트(.text), 데이터(.data/.bss), 스택, 힙 등 단순화된 모델을 사용합니다(실제 시뮬레이터는 .pos/.align/.quad 같은 지시어 지원).

---

## 4. 명령어 형식(일반 규칙)

모든 Y86-64 명령은 **첫 바이트**에 다음을 담습니다:

- 상위 4비트: `icode` (instruction code)  
- 하위 4비트: `ifun`  (function / variant)

그 뒤에 오는 바이트들은 명령어 종류에 따라 달라집니다. 일반적으로 다음 3개의 추가 필드가 사용됩니다.

1. **reg byte (optional)**  
   - 하나의 바이트 (8비트)로, 상위 4비트 = `regA`, 하위 4비트 = `regB`  
   - 레지스터들을 지정하거나 `F`(0xF)로 비워둘 수 있음.

2. **V (8-byte immediate, optional)**  
   - 8바이트(64비트) 즉시값(리틀 엔디안)

3. **주소/거리(D)**  
   - rmmovq/mrmovq 등의 메모리-레지스터 명령은 V를 주소 오프셋으로 사용.

명령어는 다음과 같이 분류됩니다.

- 1 바이트만 차지하는 명령: `halt`, `nop`, `ret` 등
- 2 바이트: 1바이트(icode/ifun) + 1바이트(regA/regB)
- 10 바이트: 1바이트 + 1바이트(regs) + 8바이트(imm V)
- 9 바이트: 1바이트 + 8바이트(immediate 주소) for jmp/call

---

## 5. 전체 명령어 목록 (icode/ifun 표)

아래 표는 CS:APP의 Y86-64에서 일반적으로 정의된 명령어들과 icode/ifun 구분입니다.

| icode (hex nibble) | 이름 | ifun 의미(하위 4비트) | 형식 (bytes) |
|--------------------:|------|-----------------------|--------------:|
| 0x0 | `halt` | 0 | 1 |
| 0x1 | `nop`  | 0 | 1 |
| 0x2 | `cmovXX / rrmovq` | 0:rrmovq, 1:cmovle, 2:cmovl, 3:cmove, 4:cmovne, 5:cmovge, 6:cmovg | 2 (reg) |
| 0x3 | `irmovq` | 0 (imm → regB) | 10 (reg + V) |
| 0x4 | `rmmovq` | 0 (regA → M[regB + D]) | 10 (reg + V) |
| 0x5 | `mrmovq` | 0 (M[regB + D] → regA) | 10 (reg + V) |
| 0x6 | `OPq` (ALU ops) | 0:addq, 1:subq, 2:andq, 3:xorq (기본) | 2 (reg) |
| 0x7 | `jXX` (jmp, conditional jump) | 0:jmp,1:jle,2:jl,3:je,4:jne,5:jge,6:jg | 9 (D) |
| 0x8 | `call` | 0 | 9 (D) |
| 0x9 | `ret` | 0 | 1 |
| 0xA | `pushq` | 0 | 2 (reg) |
| 0xB | `popq` | 0 | 2 (reg) |
<!-- CS:APP의 Y86 정의는 보통 여기까지가 기본 집합 -->

> 설명: 한 명령의 수치는 `(icode << 4) | ifun` 형태로 첫 바이트에 들어갑니다. 예: `addq`는 `icode=6(0x6)`, `ifun=0` → 첫 바이트 `0x60`.

---

## 6. 각 명령어의 상세 인코딩과 예제

아래에 핵심 명령어군별 인코딩과 예제를 정리합니다.

### 6.1 `halt` (종료)
- **설명**: 프로그램 종료.
- **icode/ifun**: `0x0` / `0x0` → 첫 바이트 `0x00`.
- **길이**: 1 바이트.
- **예**: `00` (hex)

### 6.2 `nop` (no-op)
- **icode/ifun**: `0x1` / `0x0` → `0x10`.
- **길이**: 1 바이트.
- **예**: `10`

### 6.3 조건 이동 `rrmovq` / `cmovXX` (icode = 2)
- **형식**: `2ifun  regA/regB`
- `reg` 바이트: upper=regA, lower=regB
- `ifun` 코드:
  - 0 : `rrmovq` (unconditional move)  
  - 1 : `cmovle`  
  - 2 : `cmovl`  
  - 3 : `cmove` (== `cmovz`)  
  - 4 : `cmovne` (!=)  
  - 5 : `cmovge`  
  - 6 : `cmovg`
- **동작**: (조건 만족 시) `R[regB] <- R[regA]` (일부 표현은 반대로 보기도 함 — CS:APP 표기 확인 필요; 여기서는 `regA -> regB` 규칙 사용)
- **예**: `rrmovq %rax, %rbx`  
  - regA = `%rax` = 0x0, regB = `%rbx` = 0x3  
  - first byte `0x20` (2<<4 | 0)  
  - reg byte `0x03` (0x0 <<4 | 0x3)  
  - machine bytes: `20 03`

### 6.4 `irmovq V, rB` (Immediate → register) (icode = 3)
- **형식**: `0x3 0x0` first byte = `0x30` then reg byte then 8-byte immediate V.
- reg byte: upper = `0xF` (REG_NONE), lower = dest register id.
- **동작**: `R[regB] <- V`.
- **예**: `irmovq $0x10, %rax`  
  - bytes: `30 f0 10 00 00 00 00 00 00 00`  
    (0x30, 0xF0, V (little endian 8 bytes = 0x10 ... 0x00))

### 6.5 `rmmovq rA, D(rB)` (store) (icode = 4)
- **형식**: first byte `0x40`, reg byte (regA/regB), V (8 bytes)
- 동작: `M[R[regB] + D] <- R[regA]`
- 예: `rmmovq %rax, 8(%rbp)`  
  - regA=0x0, regB=0x5 → reg byte `0x05`  
  - bytes: `40 05 08 00 00 00 00 00 00 00` (V=8 little-endian)

### 6.6 `mrmovq D(rB), rA` (load) (icode = 5)
- **형식**: `0x50`, reg byte, V
- 동작: `R[regA] <- M[R[regB] + D]`
- 예: `mrmovq 8(%rbp), %rax`  
  - bytes: `50 05 08 00 00 00 00 00 00 00`

### 6.7 ALU 연산 `OPq rA,rB` (icode = 6)
- **형식**: `0x60`..`0x6f`, reg byte
- **ifun mapping (예시)**:
  - 0: `addq`  
  - 1: `subq`  
  - 2: `andq`  
  - 3: `xorq`
- 동작: `R[regB] <- R[regB] OP R[regA]` (즉 `regB op= regA`) — CS:APP 표기 사용.
- 플래그: 연산 후 ZF, SF, OF 등을 설정.
- 예: `addq %rax, %rbx`  
  - first byte `0x60` (6<<4 | 0)  
  - reg byte `0x03` (regA=0, regB=3)  
  - bytes: `60 03`

### 6.8 분기 `jXX D` (icode = 7)
- **형식**: `0x70`..`0x7f` (ifun 0..6), 다음 8바이트은 목적지 주소 `D`.
- **ifun mapping**:
  - 0: `jmp` (무조건)  
  - 1: `jle`  
  - 2: `jl`  
  - 3: `je`  
  - 4: `jne`  
  - 5: `jge`  
  - 6: `jg`
- 동작: 조건 만족 시 `PC <- D`.
- 예: `je .L1` (addr 0x400) → bytes: `30??`? (정확한 첫 바이트: `0x73` for je?) Wait: For je: icode=7 (0x7) ifun=3 → first byte = `0x73`. Then 8-byte dest.

### 6.9 `call D` (icode = 8)
- **형식**: first byte `0x80` (8<<4|0), then 8-byte dest (D).
- 동작: push return address (PC next), PC <- D.
- 예: `call foo` at PC 0x200, foo at 0x400: bytes `80 00 04 00 00 00 00 00 00 00` (little-endian address 0x400)

### 6.10 `ret` (icode = 9)
- **형식**: `0x90` (9<<4|0), 단일 바이트
- 동작: pop return address into PC

### 6.11 `pushq rA` (icode = A (0xA))
- **형식**: first byte `0xA0`, reg byte upper=regA, lower=0xF (REG_NONE)
- 동작: `R[%rsp] -= 8; M[R[%rsp]] <- R[regA]`
- 예: `pushq %rax` → bytes `A0 0F`? Wait reg byte is (regA<<4 | regB). For pushq regA=0x0, regB=0xF => reg byte `0x0F`. So full: `A0 0F`.

### 6.12 `popq rA` (icode = B (0xB))
- **형식**: first byte `0xB0`, reg byte with upper=regA? Convention in CS:APP: reg byte upper regA = dest, lower = 0xF? There is slight notation difference between push/pop encodings. Typical CS:APP encoding: pushq uses regA=reg, regB=F; popq uses regA=F, regB=reg (because popq pops into regA?). But many references adopt popq: regA/regB where regA = destination? To be precise and safe: CS:APP uses reg byte upper=regA, lower=regB. For pushq, regB is F; for popq, regA is F and regB is destination. (This is how the official lab defines it.)  
  - So `pushq r` : reg byte = (r << 4) | 0xF  
  - `popq r`  : reg byte = (0xF << 4) | r

- 예: `popq %rax` → bytes `B0 F0`? Wait compute: first byte `0xB0` then reg byte `0xF0 | 0x0 = 0xF0`. So `B0 F0`.

> 요약: pushq: `A0 rF`, popq: `B0 Fr` (r is 4-bit reg id)

---

## 7. 조건 코드(Flags)와 분기(조건 판정)

Y86-64는 **세 가지 조건 코드**를 사용합니다:

- **ZF (Zero Flag)**: 연산 결과가 0이면 1
- **SF (Sign Flag)**: 결과가 음수이면 1 (most-significant bit)
- **OF (Overflow Flag)**: 산술 오버플로우 발생 시 1 (signed overflow)

이들은 주로 `OPq` (add/sub/and/xor) 명령 이후에 설정됩니다. `cmovXX`와 `jXX`는 이 플래그들을 검사하여 조건을 판정합니다.

> 조건 판정 (예시):
- `je` (equal) 는 `ZF == 1`
- `jl` (less) 는 `SF ^ OF == 1` (signed less)
- `jle` 는 `(ZF == 1) || (SF ^ OF == 1)` 등

정확한 불리언 표현은 CS:APP에 제시된 표를 참조하세요.

---

## 8. 호출/반환과 스택 사용 규칙 (Y86 호출 규약)

Y86는 x86-64와는 달리 아주 단순한 호출 규약을 가집니다(교재 실습에 맞춘 규약).

- **인자 전달**: CS:APP의 Y86 예제에서는 주로 **스택에 인자들을 쌓아(pushq)** 넘깁니다. (즉, 레지스터를 통한 인자 전달은 생략된 간단한 규약)  
- **리턴 값**: `%rax`에 저장 (일반 규약과 동일)  
- **호출자(caller)**: 인자 푸시와 반환값 사용, 필요 시 caller-saved 레지스터 보존  
- **피호출자(callee)**: 지역 변수와 저장 레지스터를 위해 스택 프레임 생성 (`pushq %rbp` / `rrmovq %rsp,%rbp` 등)  
- **call**: 링커/어셈블러가 목적지 주소로 PC를 이동시키며 리턴 주소를 스택에 push  
- **ret**: 스택에서 리턴 주소를 pop 하여 PC에 복귀

### 스택 프레임 관례 (간단 예)
```
pushq %rbp
rrmovq %rsp, %rbp  ; 또는 movq %rsp,%rbp (표기 차이)
subq $N, %rsp      ; 지역 변수 공간 확보
...
movq %rbp, %rsp
popq %rbp
ret
```

(위는 x86 스타일이지만 Y86의 스택 연산으로 동일 구조 재현)

---

## 9. 어셈블리 & 기계어 예제 (상세)

아래는 작은 Y86 프로그램과 그 기계 바이트 인코딩 예시입니다. (주소/오프셋 값은 설명 목적의 임의 값임)

### 예제 1: 간단한 `irmovq`와 `addq`
```asm
# y86 assembly (pseudo)
    .pos 0x0
    irmovq $0x8, %rax     # RAX = 8
    irmovq $0x4, %rbx     # RBX = 4
    addq %rbx, %rax       # RAX = RAX + RBX
    halt
```

인코딩:
- `irmovq $8, %rax` → `30 f0 08 00 00 00 00 00 00 00`  
  - 0x30 (icode=3,ifun=0), reg byte 0xF0 (F -> rB=0), imm 8 bytes little endian
- `irmovq $4, %rbx` → `30 f3 04 00 00 00 00 00 00 00` (regB = 0x3)
- `addq %rbx, %rax` → `60 30`? Wait: regA=%rbx (0x3), regB=%rax (0x0) → reg byte = (3<<4 | 0) = 0x30, first byte `0x60` → `60 30`
- `halt` → `00`

전체 바이트 시퀀스 (hex):
```
30 f0 08 00 00 00 00 00 00 00
30 f3 04 00 00 00 00 00 00 00
60 30
00
```

### 예제 2: 메모리 접근과 스택 (rmmovq/mrmovq/pushq/popq)
```asm
    irmovq $16, %rbp       # rbp = 16
    rmmovq %rax, 8(%rbp)   # mem[rbp+8] = rax
    mrmovq 8(%rbp), %rcx   # rcx = mem[rbp+8]
```
인코딩 샘플 (유사 형식):
- `irmovq` → `30 f5 10 00 00 00 00 00 00 00` (regB = rbp=0x5)
- `rmmovq %rax, 8(%rbp)` → `40 05 08 00 00 00 00 00 00 00` (regA=rax=0x0, regB=rbp=0x5, D=8)
- `mrmovq 8(%rbp), %rcx` → `50 15 08 00 00 00 00 00 00 00` (regA=rcx=0x1, regB=rbp=0x5)

> 바이트 인코딩을 직접 실습하면 어떤 필드가 어떤 의미인지 감이 잘 옵니다.

---

## 10. 어셈블러/시뮬레이터 도구와 디버깅

CS:APP 환경에는 보통 다음 도구가 제공됩니다.

- **yas (Y86 assembler)**: y86 텍스트를 바이너리(.yo)로 어셈블
- **y86sim**: y86 바이너리를 실행/시뮬레이션 하는 도구
- **objdump 같은 도구**: 기계 코드 디스어셈블

간단한 워크플로:
1. `yas program.ys` → `program.yo` (바이너리)
2. `y86sim program.yo` → 실행 및 레지스터/메모리 상태 관찰

디버깅 팁:
- 각 명령의 바이트 수를 항상 계산: 1, 2, 9, 10 바이트 규칙을 기억.
- `irmovq`와 같은 immediate 명령은 항상 10바이트(1 + 1 + 8).
- `rmmovq`/`mrmovq` 도 10바이트.
- `call`/`jXX`는 9바이트(1 + 8).
- `pushq`/`popq`는 2바이트.
- `OPq`와 `cmov`은 2바이트.

---

## 11. Y86-64와 x86-64의 주요 차이

- **명령어 수의 축소**: 실제 x86-64는 수백개의 명령과 복잡한 주소 지정 모드가 있지만, Y86-64는 핵심만 남김.  
- **간단한 인코딩 규칙**: 모든 명령이 icode/ifun의 동일한 첫 바이트 구조를 가짐. x86은 매우 다양한 인코딩과 가변 길이를 가짐.  
- **주소 지정 모드 제한**: Y86는 기본적으로 `reg + displacement` 형태만 제공. x86은 다양한 SIB(base,index,scale) 형식을 가짐.  
- **조건 처리 단순화**: 조건 코드와 분기만 있으며 복잡한 플래그 집합을 단순화함.  
- **시스템 콜 / 인터럽트 미포함**: 교육 목적상 간단화되어 시스템 콜/OS 인터페이스는 교재 실습에서 별도 처리.

---

## 12. 연습 문제 (학습용)

1. `irmovq $0x1234, %rbx` 다음에 `rmmovq %rbx, 16(%rsp)` 를 인코딩하고 바이트 시퀀스를 작성하라.  
2. `pushq %rax` 후 `popq %rcx` 를 실행했을 때 `%rsp`의 변화와 메모리 변화를 설명하라.  
3. `subq %rax, %rax` 명령이 수행되면 어떤 플래그(ZF, SF, OF)가 설정되는가? (rax가 0이었거나 1이었을 때 등 여러 경우를 따져라)  
4. `jle`와 `jl`의 논리적 차이를 플래그 관점에서 설명하라.

---

## 부록: 빠른 참조 테이블 (요약)

- Byte fields:
  - 1 byte: `[icode:4][ifun:4]`
  - Optional: 1 byte reg: `[regA:4][regB:4]`
  - Optional: 8 byte V (little-endian)
- Common first-byte values (예시):
  - `0x00` = halt
  - `0x10` = nop
  - `0x20`..`0x26` = cmovXX variants
  - `0x30` = irmovq (ifun=0)
  - `0x40` = rmmovq
  - `0x50` = mrmovq
  - `0x60`..`0x63` = add/sub/and/xor
  - `0x70`..`0x76` = jXX
  - `0x80` = call
  - `0x90` = ret
  - `0xA0` = pushq
  - `0xB0` = popq

---

## 결론 및 학습 팁

- **바이트 인코딩을 직접 만들어 보는 것**이 Y86-64의 이해에 가장 큰 도움이 됩니다. `irmovq`/`rmmovq`/`mrmovq` 같은 명령어들의 고정 길이 규칙을 외우면 디코더를 손수 구현해 볼 수도 있습니다.  
- **시뮬레이터(y86sim)를 사용하여 단계별 실행**하면서 레지스터 및 메모리 변화를 관찰하세요. 스택 프레임 생성/소멸, 호출/복귀, 조건 분기 동작을 눈으로 확인하면 개념이 빠르게 정립됩니다.  
- CS:APP 실습 문제를 그대로 따라 하며 어셈블리→바이트→시뮬레이션을 반복하는 것을 권장합니다.
