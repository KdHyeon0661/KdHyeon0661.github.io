---
layout: post
title: AWS - AWS란 무엇인가
date: 2025-07-12 17:20:23 +0900
category: AWS
---
# AWS란 무엇인가?

## 시작 전 체크리스트

- AWS 계정 · MFA 활성화
- 루트 계정 **비사용**(대신 IAM 관리형 사용자/역할)
- 프로파일 설정

```bash
aws configure --profile blog-dev
# AWS Access Key ID [None]: AKIA...
# AWS Secret Access Key [None]: ...
# Default region name [None]: ap-northeast-2
# Default output format [None]: json

```

---

## 클라우드 컴퓨팅이란?

클라우드 컴퓨팅은 **인터넷을 통해 서버·스토리지·DB·네트워크·소프트웨어 등 IT 자원을 필요할 때마다 제공**받는 모델이다.
사용자는 물리 서버를 구매/유지하지 않고, **필요한 만큼 쓰고 사용량만큼 지불**한다.

### 주요 특징 (정리 및 확장)

- 온디맨드(Self-Service): 콘솔/CLI/API로 즉시 자원 생성
- 탄력성(Elasticity): 트래픽에 따라 자동 확장/축소 (ASG, ECS Service, Lambda Concurrency)
- 종량제 요금(Pay-as-you-go): 사용량 기반 과금 + 예약/절감플랜
- 고가용성(HA): 다중 AZ/리전 설계
- 글로벌 인프라: 다수 Region/Availability Zone, 엣지 네트워크(CloudFront)

#### 클라우드 서비스 계층 (IaaS/PaaS/SaaS)

| 분류 | 설명 | 사용자 책임 | 대표 AWS 서비스 |
|---|---|---|---|
| IaaS | 인프라 제공 | OS, 런타임, 미들웨어, 앱 | EC2, EBS, VPC |
| PaaS | 플랫폼 제공 | 애플리케이션 코드 | Elastic Beanstalk, RDS, Lambda(런타임 관리형) |
| SaaS | 완제품 소프트웨어 | 최소 설정 및 사용 | Chime, WorkMail, WorkDocs |

**관리 책임 스택(확장 도식)**

```
┌─────────────────────┐
│ 애플리케이션        │  ← 고객
├─────────────────────┤
│ 런타임/미들웨어     │
├─────────────────────┤
│ OS                   │
├─────────────────────┤
│ 가상화/컨테이너      │
├─────────────────────┤
│ 서버 하드웨어        │  ← 클라우드 제공자
├─────────────────────┤
│ 네트워크/스토리지    │
└─────────────────────┘
```

---

## AWS란?

**AWS(Amazon Web Services)**는 2006년 공개된 **세계 최대 규모의 상용 클라우드**다.
전 세계 리전/가용영역(AZ) 위에 **컴퓨팅·스토리지·DB·AI/ML·보안·네트워킹·운영** 등 **200+ 서비스**를 제공한다.

### 글로벌 인프라 개념 확장

- **Region**: 지리적 독립 데이터센터 묶음 (예: `ap-northeast-2` 서울)
- **Availability Zone (AZ)**: 한 리전 내 **물리적으로 분리된 데이터센터**. 다중 AZ 배치로 장애 격리
- **Local Zone / Wavelength**: 초저지연 엣지 컴퓨팅 지점
- **Edge Location**: CloudFront/Route 53 등 엣지 서비스 POP

---

## 계정·조직·보안(Shared Responsibility Model)

- **Shared Responsibility**:
  - **AWS**: 물리 시설, 하이퍼바이저, 일부 관리형 서비스의 보안
  - **고객**: 데이터 분류, IAM 권한, 네트워크 설계, 애플리케이션 보안

### AWS Organizations & 여러 계정 전략

- **Landing Zone**: `Security`, `Log Archive`, `Shared Services`, `Dev/Stage/Prod` 다계정 분리
- SCP(Service Control Policy)로 상위 제한
- Cross-Account IAM Role로 중앙 운영

---

## IAM 기초 — 사용자/그룹/역할/정책

### 최소 권한 정책 예제(JSON)

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "ReadOnlyS3InSpecificBucket",
      "Effect": "Allow",
      "Action": ["s3:GetObject","s3:ListBucket"],
      "Resource": [
        "arn:aws:s3:::my-blog-bucket",
        "arn:aws:s3:::my-blog-bucket/*"
      ]
    }
  ]
}
```

### 역할 기반 접근 (EC2 → S3 읽기)

- EC2 인스턴스 프로파일에 역할을 연결 → 애플리케이션은 **키 없이** 메타데이터 서비스(IMDSv2)로 임시 자격증명 사용

```bash
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/
```

---

## 네트워킹 — VPC 설계 핵심

### VPC 구성요소

- **VPC**: 사설 네트워크
- **Subnets**: Public(IGW 경로) / Private(NAT 통해 아웃바운드) 분리
- **Route Tables** / **IGW** / **NAT Gateway**
- **Security Group(SG)**: 상태 저장, 인스턴스/ENI 단위
- **NACL**: 서브넷 단위, 무상태

#### 베이직 3-서브넷 토폴로지(ASCII)

```
VPC 10.0.0.0/16
├─ Public Subnet A 10.0.1.0/24  ─┐
│   - ALB                       │
│   - NAT GW                    │─ Internet Gateway
├─ Private App Subnet A 10.0.11.0/24
│   - ECS/EC2/Lambda ENI
└─ Private DB Subnet A 10.0.21.0/24
    - RDS Multi-AZ
```

### CloudFormation으로 VPC 스켈레톤

```yaml
AWSTemplateFormatVersion: '2010-09-09'
Resources:
  Vpc:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
  InternetGateway:
    Type: AWS::EC2::InternetGateway
  AttachIgw:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref Vpc
      InternetGatewayId: !Ref InternetGateway
```

---

## 컴퓨팅 — EC2/ASG/ALB

### 인스턴스 타입·가격 모델

- 타입: 범용(T), 컴퓨팅 최적(C), 메모리 최적(R), 저장소(I), GPU(P/G)
- 가격: **온디맨드**, **예약 인스턴스(RI)**, **Savings Plans**, **스팟(Spot)**

### EC2 빠른 시작(CLI)

```bash
aws ec2 run-instances \
  --profile blog-dev \
  --image-id ami-xxxxxxxx \
  --count 1 \
  --instance-type t3.micro \
  --key-name my-key \
  --security-group-ids sg-xxxx \
  --subnet-id subnet-xxxx
```

### 오토스케일링 + ALB 기본 개념

- **ASG**: 최소/최대/기대 용량, 스케일 아웃 정책(CPU, ReqCount)
- **ALB**: L7 라우팅, 대상 그룹(health check)

---

## 스토리지 — S3/EBS/EFS/Glacier

### S3 핵심

- 버킷/오브젝트, 스토리지 클래스(Standard, IA, One Zone, Glacier 등)
- **버전관리**, **수명주기(라이프사이클)**, **암호화(SSE-S3/KMS)**

```bash
aws s3 mb s3://my-blog-bucket --profile blog-dev
aws s3 cp ./site s3://my-blog-bucket --recursive --profile blog-dev
```

### 서버사이드 암호화(KMS) 예시

```bash
aws s3 cp data.csv s3://my-blog-bucket/secure/data.csv \
  --sse aws:kms \
  --sse-kms-key-id alias/my-blog-key \
  --profile blog-dev
```

---

## 데이터베이스 — RDS/Aurora/DynamoDB/Redshift

### RDS (MySQL/PostgreSQL 등)

- **Multi-AZ**, 자동 백업, 파라미터 그룹
- 읽기 부하는 **리드 리플리카**

```sql
-- 예: 인덱스 튜닝 예시
CREATE INDEX idx_orders_created_at ON orders (created_at);
```

### Aurora

- 분산 스토리지(6-way), 빠른 장애조치, 글로벌 데이터베이스

### DynamoDB (NoSQL 키-값/문서)

- 파티션키/정렬키 설계, GSI/LSI, 온디맨드/프로비저닝 모드

```bash
aws dynamodb create-table \
  --table-name BlogPosts \
  --attribute-definitions AttributeName=PK,AttributeType=S AttributeName=SK,AttributeType=S \
  --key-schema AttributeName=PK,KeyType=HASH AttributeName=SK,KeyType=RANGE \
  --billing-mode PAY_PER_REQUEST
```

---

## 서버리스 — Lambda / API Gateway / EventBridge / SQS / SNS / Step Functions

### Python Lambda 핸들러 예시

```python
def handler(event, context):
    post_id = event.get("pathParameters", {}).get("id")
    # ... fetch from DynamoDB ...
    return {"statusCode": 200, "body": f"Post {post_id} served"}
```

### SAM 템플릿(서버리스 API)

```yaml
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Resources:
  GetPost:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/
      Handler: app.handler
      Runtime: python3.12
      Policies:
        - DynamoDBReadPolicy:
            TableName: BlogPosts
      Events:
        ApiEvent:
          Type: Api
          Properties:
            Path: /posts/{id}
            Method: get
```

---

## 컨테이너 — ECS/Fargate, EKS

### ECS Fargate 서비스 빠른 개념

- EC2 관리 없이 **Fargate**로 컨테이너 실행
- ALB 대상 그룹과 연동, Auto-healing

#### Task Definition 스니펫(JSON)

```json
{
  "family": "blog-web",
  "networkMode": "awsvpc",
  "cpu": "256",
  "memory": "512",
  "requiresCompatibilities": ["FARGATE"],
  "containerDefinitions": [
    {
      "name": "app",
      "image": "public.ecr.aws/xxxx/blog-web:latest",
      "portMappings": [{ "containerPort": 3000 }]
    }
  ]
}
```

---

## 모니터링/로깅 — CloudWatch, X-Ray, CloudTrail

### 지표/알람

```bash
aws cloudwatch put-metric-alarm \
  --alarm-name HighCPU \
  --metric-name CPUUtilization \
  --namespace AWS/EC2 \
  --statistic Average \
  --period 60 \
  --threshold 80 \
  --comparison-operator GreaterThanThreshold \
  --dimensions Name=InstanceId,Value=i-xxxx \
  --evaluation-periods 3 \
  --alarm-actions arn:aws:sns:ap-northeast-2:1234:ops
```

- **CloudTrail**: 계정 API 감사 로그(보안/감사 기본)
- **X-Ray**: 분산 추적(마이크로서비스 병목 분석)

---

## 보안 — KMS/Secrets Manager/WAF/Shield

### KMS 키 정책 예시

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowAccountUseOfKey",
      "Effect": "Allow",
      "Principal": {"AWS": "arn:aws:iam::123456789012:root"},
      "Action": ["kms:*"],
      "Resource": "*"
    }
  ]
}
```

### WAF 간단 룰

- SQLi/XSS 매니지드 룰 활성화
- /login 레이트 리밋(예: 100 req/5min/IP)

---

## 배포 — CI/CD (CodePipeline·CodeBuild·GitHub Actions)

### 정적 사이트: S3 + CloudFront + OAC

- **OAC(Origin Access Control)**로 S3 프라이빗 + CloudFront만 접근
- 캐시 무효화

```bash
aws cloudfront create-invalidation \
  --distribution-id E1ABCDEF \
  --paths "/*"
```

### GitHub Actions로 S3 배포

```yaml
name: deploy-static
on: [push]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2
      - run: aws s3 sync ./public s3://my-blog-bucket --delete
```

---

## 비용 추정·최적화(핵심 수식 포함)

### 단순 월 비용 추정

- 인스턴스(온디맨드) 시간당 단가를 \(c_{\text{EC2}}\), 월 사용 시간을 \(H\), 수량을 \(N\)이라 두면

$$
\text{EC2 월 비용} = c_{\text{EC2}} \times H \times N
$$

- S3(GB·월)를 \(c_{\text{S3}}\), 저장용량 \(G\)로 두면

$$
\text{S3 월 비용} = c_{\text{S3}} \times G
$$

- 합산:

$$
\text{총 월 비용} \approx \sum_i c_i \cdot q_i
$$

### 최적화 팁

- 장기 워크로드: **Reserved Instances/Savings Plans**
- 무상태·일시적: **Spot 인스턴스**
- S3 **수명주기 정책**으로 Glacier 아카이빙
- CloudWatch로 **미사용 리소스 탐지**(Idle 알람)

---

## 가용성·내결함성(HA/DR) — RTO/RPO, 다중 AZ/리전

- **RTO**(복구시간목표): 서비스 복구까지 허용 시간
- **RPO**(복구시점목표): 허용 가능한 데이터 손실 시간

### 가용성 계산(독립 가정 단순화)

- 구성요소 가용성을 \(A_1, A_2, ..., A_n\)이라 할 때 **직렬 연쇄**

$$
A_{\text{system}} = \prod_{k=1}^{n} A_k
$$

- **다중 AZ 이중화(병렬)**로 가용성 상승:
  예를 들어 AZ A, B 각각 가용성 \(A, B\)일 때, 중복 활성-활성 구성이면 다운 확률은 \((1-A)\cdot(1-B)\), 가용성은

$$
A_{\text{dual}} = 1 - (1 - A)(1 - B)
$$

---

## 아키텍처 패턴(블루프린트)

### 3-Tier Web (ALB → App → RDS)

```
Client → CloudFront → ALB → EC2/ECS → RDS Multi-AZ
                      ↘  S3(정적)  ↙
                      CloudWatch/Logs
```

- 장점: 친숙한 LAMP/스프링 환경, 점진적 전환 용이
- 주의: 커넥션 풀·오토스케일·세션 공유(ElastiCache/Sticky/외부세션) 설계

### 순수 서버리스 Web

```
CloudFront
   ├─ S3(정적)
   └─ API Gateway → Lambda → DynamoDB
                    ↘ EventBridge/SQS
```

- 장점: 관리부담↓, 자동 스케일, 유휴비용↓
- 주의: 콜드스타트·DDB 스키마 설계

### 데이터 파이프라인

```
Producers → Kinesis Data Streams → Lambda → S3(Data Lake)
                                           ↘ Glue → Athena
```

- Athena 예제 쿼리

```sql
SELECT country, COUNT(*) cnt
FROM logs
WHERE dt BETWEEN DATE '2025-11-01' AND DATE '2025-11-10'
GROUP BY country
ORDER BY cnt DESC;
```

---

## 실전 랩 ① — “블로그 글 API” (API GW + Lambda + DynamoDB)

### 시나리오

- 경로: `GET /posts/{id}` / `POST /posts`
- 저장: DynamoDB `BlogPosts(PK=POST#<id>, SK=METADATA)`

### IaC(SAM) 템플릿 요약

```yaml
Transform: AWS::Serverless-2016-10-31
Resources:
  PostsTable:
    Type: AWS::Serverless::SimpleTable
    Properties:
      PrimaryKey:
        Name: PK
        Type: String
      SecondaryIndexes:
        - IndexName: GSI1
          KeySchema:
            - AttributeName: SK
              KeyType: HASH
  GetPostFn:
    Type: AWS::Serverless::Function
    Properties:
      Handler: app.get_post
      Runtime: python3.12
      Policies:
        - DynamoDBReadPolicy:
            TableName: !Ref PostsTable
      Events:
        Get:
          Type: Api
          Properties: { Path: /posts/{id}, Method: get }
  CreatePostFn:
    Type: AWS::Serverless::Function
    Properties:
      Handler: app.create_post
      Runtime: python3.12
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref PostsTable
      Events:
        Post:
          Type: Api
          Properties: { Path: /posts, Method: post }
```

### Lambda 구현(Python)

```python
import json, os, boto3
dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table(os.environ.get("POSTS_TABLE", "PostsTable"))

def get_post(event, context):
    pid = event["pathParameters"]["id"]
    resp = table.get_item(Key={"PK": f"POST#{pid}"})
    return {"statusCode": 200, "body": json.dumps(resp.get("Item", {}))}

def create_post(event, context):
    body = json.loads(event["body"])
    pid  = body["id"]
    item = {"PK": f"POST#{pid}", "SK": "METADATA", **body}
    table.put_item(Item=item)
    return {"statusCode": 201, "body": json.dumps({"id": pid})}
```

### 배포

```bash
sam build && sam deploy --guided
```

---

## 실전 랩 ② — “컨테이너 웹앱” (ECS Fargate + ALB)

### 시나리오

- 프론트: Nginx로 정적 파일
- 백엔드: Node.js API 컨테이너
- ALB 라우팅: `/api/*` → 백엔드, `/` → 프론트

### Dockerfile(백엔드)

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev
COPY . .
EXPOSE 3000
CMD ["node", "server.js"]
```

### server.js

```javascript
import express from "express";
const app = express();
app.get("/api/health", (_, res) => res.json({ ok: true }));
app.listen(3000);
```

- ECR 푸시 → ECS 서비스 생성(Fargate, awsvpc, 3000 포트) → ALB 타겟 그룹 연결

---

## 실전 랩 ③ — “정적 블로그” (S3 + CloudFront + OAC + Route 53)

### 빌드 & 업로드

```bash
npm run build
aws s3 sync ./dist s3://my-blog-bucket --delete --profile blog-dev
```

### 배포 최적화 팁

- 캐시 정책: 정적 자산 장기 캐시 + 파일명 해시
- OAC로 S3 퍼블릭 차단
- WAF로 OWASP 매니지드 룰 적용

---

## 운영 체크리스트 (초급 → 중급)

- IAM: 루트 차단, MFA, 액세스 키 주기적 교체, 정책 최소권한
- 네트워크: Public/Private 분리, SG Ingress 최소화, NACL 기본거부
- 데이터: S3 버전관리/암호화, RDS 백업/스냅샷, DDB PITR
- 관측성: CloudWatch 대시보드/알람, CloudTrail 통합, 로그 중앙집중(Logs, OpenSearch)
- 비용: 태그 표준화(`Env`,`Owner`,`Project`), 비용 탐색기, 예약/절감 플랜 검토
- 재해복구: RTO/RPO 목표 정의, 복구 연습(GameDay)

---

## IaC 비교 빠른 가이드

### CloudFormation 스니펫(EC2)

```yaml
Resources:
  WebServer:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: t3.micro
      ImageId: ami-xxxxxxxx
```

### Terraform 스니펫(EC2)

```hcl
resource "aws_instance" "web" {
  ami           = "ami-xxxxxxxx"
  instance_type = "t3.micro"
  tags = { Name = "web" }
}
```

### CDK 스니펫(TypeScript, S3)

```ts
const bucket = new s3.Bucket(this, "SiteBucket", {
  versioned: true,
  encryption: s3.BucketEncryption.S3_MANAGED,
});
```

---

## 개발자 SDK 예제

### Python(boto3) S3 업로드

```python
import boto3
s3 = boto3.client("s3")
s3.upload_file("report.pdf", "my-blog-bucket", "docs/report.pdf")
```

### Node.js v3 SDK DynamoDB Put

```javascript
import { DynamoDBClient, PutItemCommand } from "@aws-sdk/client-dynamodb";
const ddb = new DynamoDBClient({ region: "ap-northeast-2" });
await ddb.send(new PutItemCommand({
  TableName: "BlogPosts",
  Item: { PK: { S: "POST#123" }, SK: { S: "METADATA" }, title: { S: "Hello" } }
}));
```

---

## 자주 겪는 함정과 솔루션

- **S3 정적 사이트 403**: 버킷 퍼블릭 차단 상태에서 CloudFront OAC 미구성 → **OAC 설정** 후 버킷 정책 업데이트
- **Lambda 타임아웃**: VPC 내 배치 시 NAT/엔드포인트 미설정 → **VPC 엔드포인트(S3/DDB 등)** 구성
- **DynamoDB 핫 파티션**: 편향된 파티션키 → **키 설계 재검토/GSI 사용**
- **ECS 서비스 불건강**: 헬스체크 경로 오류 → ALB Target Group 경로/코드 200 확인
- **비용 폭증**: CloudWatch Logs 무한 저장 → **보존기간 설정**(예: 30일)

---

## 마무리 — “AWS는 통합 플랫폼이다”

당신의 초안처럼 AWS는 단순 가상 서버 공급자가 아니라, **컴퓨팅 전체 스펙트럼**을 커버하는 **글로벌 플랫폼**이다.
이 문서는 초안의 구조를 보강해 **예제·코드·수식·설계·랩**으로 연결했다.
다음 단계로는 **당신의 실제 프로젝트(블로그·라이브러리·도커 모니터링 등)** 스택에 맞춰 **Landing Zone·네트워크·보안·CI/CD**를 맞춤 설계하면 된다.

---

## 부록 A) 빠른 실습 명령 모음

```bash
# 프로파일 환경변수

export AWS_PROFILE=blog-dev

# S3 버킷 생성 + 정적 배포

aws s3 mb s3://my-blog-bucket
aws s3 sync ./public s3://my-blog-bucket --delete

# DynamoDB 테이블

aws dynamodb create-table --table-name BlogPosts \
  --attribute-definitions AttributeName=PK,AttributeType=S AttributeName=SK,AttributeType=S \
  --key-schema AttributeName=PK,KeyType=HASH AttributeName=SK,KeyType=RANGE \
  --billing-mode PAY_PER_REQUEST

# Lambda 배포(SAM)

sam build && sam deploy --guided

# 비용 조회 예(월별)

aws ce get-cost-and-usage \
  --time-period Start=2025-11-01,End=2025-12-01 \
  --granularity MONTHLY \
  --metrics "UnblendedCost"
```

---

## 부록 B) 용어집(요약)

- **AZ**: 한 리전 내 격리된 데이터센터
- **OAC**: CloudFront가 프라이빗 S3에 접근하도록 하는 구성
- **PITR**: 시점 복구
- **SCP**: 상위 조직 정책 제약
- **Spot**: 남는 컴퓨트 경매식 할인 인스턴스
