---
layout: post
title: 논리회로설계 - 부울 대수의 기본 연산 · 부울식과 진리표 · 기본 정리
date: 2025-08-28 15:25:23 +0900
category: 논리회로설계
---
# — 기본 연산 · 부울식↔진리표 변환 · 핵심 정리·단순화

## 부울 대수의 기본

### 집합과 기호

- **원소:** \(\{0,1\}\)
- **변수:** \(A,B,C,\dots\) (각각 0 또는 1)
- **리터럴(literal):** 변수 또는 그 보수(예: \(A,\ \overline{A}\))
- **항(term):** 리터럴의 AND 곱(예: \(A\overline{B}C\))
- **합(sum):** 항들의 OR 합(예: \(A\overline{B}C + \overline{A}B\))

### 연산자 우선순위

1) NOT \(\overline{(\cdot)}\) → 2) AND \((\cdot)\) → 3) OR \((+)\)
괄호가 있으면 괄호 우선.

### 정의

- **NOT:** \(\overline{A}\) — 0↦1, 1↦0
- **AND:** \(AB\) — 두 입력 모두 1일 때 1
- **OR:** \(A+B\) — 둘 중 하나라도 1이면 1
- **XOR:** \(A\oplus B = \overline{A}B + A\overline{B}\)
- **XNOR:** \(\overline{A\oplus B}\)
- **NAND:** \(\overline{AB}\) (보편 게이트)
- **NOR:** \(\overline{A+B}\) (보편 게이트)

---

## 표현 형식 — SOP/POS 정규형과 추가 표기

### 최소항/최대항

- **최소항(minterm) \(m_i\)**: 모든 변수를 **한 번씩** 포함하는 AND 항(보수 포함) — 해당 행에서만 1.
- **최대항(maxterm) \(M_i\)**: 모든 변수를 한 번씩 포함하는 OR 항(보수 포함) — 해당 행에서만 0.

### SOP/POS 정규형

- **SOP 정규형**(Sum of Products):
  $$F(A,B,\dots) = \sum m(i)\quad(\text{출력=1인 인덱스 }i\text{의 합})$$
  즉, \(F=1\) 인 행의 \(m_i\)를 OR로 합친다.
- **POS 정규형**(Product of Sums):
  $$F(A,B,\dots) = \prod M(i)\quad(\text{출력=0인 인덱스 }i\text{의 곱})$$
  즉, \(F=0\) 인 행의 \(M_i\)를 AND로 곱한다.

### — 참고

- GF(2) 상에서의 다항식(AND는 곱, XOR는 덧셈) 형식. 일부 하드웨어·암호회로에서 유리.

---

## 부울식 ↔ 진리표 — 양방향 변환 절차

### 부울식 → 진리표

- 모든 입력 조합에 대해 식을 계산하면 된다.

예) \(F(A,B,C)=\overline{A}B + A\overline{C}\)

```
A B C | F = A'B + A C'
----------------------
0 0 0 | 0*0 + 0*1 = 0
0 0 1 | 0*0 + 0*0 = 0
0 1 0 | 1*1 + 0*1 = 1
0 1 1 | 1*1 + 0*0 = 1
1 0 0 | 0*0 + 1*1 = 1
1 0 1 | 0*0 + 1*0 = 0
1 1 0 | 0*1 + 1*1 = 1
1 1 1 | 0*1 + 1*0 = 0
```

### 진리표 → 부울식

- **SOP:** \(F=1\) 인 행의 **최소항**들을 OR.
  예: \(A=0,B=1,C=0 \Rightarrow m_2=\overline{A}B\overline{C}\).
- **POS:** \(F=0\) 인 행의 **최대항**들을 AND.
  예: \(A=0,B=1,C=0 \Rightarrow M_2=(A+B+\overline{C})\).

### 활용

- \(X\)는 **1로 취급하거나 0으로 취급**해 단순화가 가장 좋아지도록 선택.

---

## — 단순화의 무기

### 항등/지배/멱등/보수/이중부정

$$
A+0=A,\quad A\cdot 1=A,\quad
A+1=1,\quad A\cdot 0=0
$$
$$
A+A=A,\quad A\cdot A=A,\quad
A+\overline{A}=1,\quad A\cdot\overline{A}=0,\quad
\overline{\overline{A}}=A
$$

### 교환/결합/분배(두 가지 형태 모두)

$$
A+B=B+A,\quad AB=BA,\quad
(A+B)+C=A+(B+C),\quad (AB)C=A(BC)
$$
$$
A(B+C)=AB+AC,\quad A+BC=(A+B)(A+C)
$$

### 흡수·합의(컨센서스)·드모르간

- **흡수(Absorption)**
  $$A+AB=A,\quad A(A+B)=A$$
- **합의(Consensus)**
  $$AB+\overline{A}C+BC=AB+\overline{A}C$$
  (합의항 \(BC\) 제거 — 정적 해저드 제거에도 등장)
- **드모르간(De Morgan)**
  $$\overline{A+B}=\overline{A}\,\overline{B},\quad \overline{AB}=\overline{A}+\overline{B}$$

### 이중성(Duality)과 샤논 전개

- **이중성:** \(+\leftrightarrow\cdot,\; 0\leftrightarrow1\) 동시 교환 시 참식 ↔ 참식.
- **샤논 전개:**
  $$F = x\cdot F|_{x=1} + \overline{x}\cdot F|_{x=0}$$
  (정규형 도출·재귀적 합성에 유용)

> **자주 쓰는 등식**
> \(A+\overline{A}B = A+B\), \quad \(A(\overline{A}+B)=AB\).

---

## 단순화 기법 — 대수, K-맵, Q–M

### 대수적 단순화(알지브라)

- 정리들을 결합해 항을 제거/흡수/팩터링.

**예)** \(F=(A+B)(A+\overline{B}) = A + B\overline{B} = A\)

### 요약(2~4변수)

- **인접 칸은 그레이 코드 순서**로 배치(한 비트만 다름).
- **1의 덩어리(사각형) 묶기:** 크기 \(1,2,4,8,\dots\)(2의 거듭제곱) — 크기가 클수록 변수 수가 줄어든다.
- **엣지 래핑** 허용(가장자리와 반대편 가장자리는 인접).
- don’t care \(X\)는 묶기 보조요소.

3변수 K-맵(예시, 행=AB 그레이 00,01,11,10 / 열=C=0,1)

```
      C
      0 1
AB 00 0 1
   01 1 1
   11 1 0
   10 0 0
```

- 묶기 결과를 SOP로 읽어낸다(0 묶으면 POS).

### 개요

- **단계1**: 1의 개수로 그룹화, 한 비트만 다른 항을 **병합**(‘–’로 표시)해 **소화소(implicant)** 생성.
- **단계2**: 더 이상 병합되지 않는 항이 **소수합항(prime implicant)**.
- **단계3**: **필수 소수합항(essential)** 선택 + 나머지 커버를 최소로 선택.
- **장점**: 기계적/알고리즘화 가능(소변수에 적합); 대수보다 절차가 명확.

---

## 예제 — 정리로 단순화

### 합의 정리 예

$$
F=AB+\overline{A}C+BC \;\Rightarrow\; F=AB+\overline{A}C \quad (\text{합의 }BC\text{ 제거})
$$

### 분배·흡수 예

$$
F=(A+B)(A+\overline{B}) = A + B\overline{B} = A
$$

### 드모르간·흡수 결합

$$
\overline{A(B+C)}=\overline{AB+AC}=\overline{AB}\cdot \overline{AC}=(\overline{A}+\overline{B})(\overline{A}+\overline{C})=\overline{A}+\overline{B}\,\overline{C}
$$

### XOR의 등가식들

$$
A\oplus B=(A+B)(\overline{A}+\overline{B})=\overline{AB}+\overline{A}B
$$

---

## 실전: 진리표→SOP/POS, don’t care 포함

### 문제

\(F(A,B,C)=\sum m(1,3,4,6)\) (don’t care 없음)

- 3변수 인덱스(ABC의 이진값):
  \(m_1=\overline{A}\overline{B}C,\ m_3=\overline{A}BC,\ m_4=A\overline{B}\overline{C},\ m_6=AB\overline{C}\).

**SOP 정규형**
$$
F=\overline{A}\overline{B}C + \overline{A}BC + A\overline{B}\overline{C} + AB\overline{C}
$$

**K-맵 묶기**
- \(\overline{A}C\)로 2칸 묶기(\(m_1,m_3\)),
- \(A\overline{C}\)로 2칸 묶기(\(m_4,m_6\)).

**최소 SOP**
$$
F=\overline{A}C + A\overline{C} = A\oplus C
$$

**POS** (0인 인덱스 \(0,2,5,7\)의 \(M_i\) 곱)로도 도출 가능.

---

## 해저드(글리치)와 합의항 — 실무 관점

### 정적 해저드(Static Hazard)

- **문제**: 물리 게이트 지연 때문에 입력이 한 비트 바뀌는 순간 출력이 잠시 뒤집히는 현상.
- **예**: \(F=AB+\overline{A}C\). \(A\)가 0→1 변할 때, 두 곱항이 모두 0이 되는 **짧은 순간**이 생길 수 있다.
- **해결**: 합의항 \(BC\)를 추가해 \(F=AB+\overline{A}C+BC\)로 **커버 영역 연결**.

### 동적 해저드(Dynamic Hazard)

- 두 비트 이상 전이 시 여러 경로 간 지연 차이로 출력이 여러 번 튀는 현상. **균등 지연 설계/동기화**로 완화.

---

## NAND/NOR의 보편성 — 게이트 레벨 합성

### NAND-only

- \(\overline{A}=A\) NAND \(A\)
- \(AB=\overline{(A\ \text{NAND}\ B)}\)
- \(A+B=\overline{\overline{A}\cdot \overline{B}}\) (NAND만으로 NOT·AND·OR 모두 구현)

### NOR-only

- \(\overline{A}=A\) NOR \(A\)
- \(A+B=\overline{(A\ \text{NOR}\ B)}\)
- \(AB=\overline{\overline{A}+\overline{B}}\)

**Verilog 스니펫(예: NAND로 NOT/AND/OR)**
```verilog
module nand_not(input a, output y);
  nand (y, a, a);
endmodule

module nand_and(input a, b, output y);
  wire t;
  nand (t, a, b);
  nand (y, t, t);
endmodule

module nand_or(input a, b, output y);
  wire na, nb;
  nand (na, a, a);
  nand (nb, b, b);
  nand (y, na, nb);
endmodule
```

---

## 실습 코드 — 진리표 생성, SOP/POS 생성, 동치 검사

### Python: 변수 집합에 대한 진리표와 SOP/POS 생성

{% raw %}
```python
from itertools import product

def truth_table(vars_, f):
    """vars_: ['A','B',...], f: dict-like or callable mapping tuple of bits -> 0/1"""
    rows = []
    for bits in product([0,1], repeat=len(vars_)):
        val = f(bits) if callable(f) else f[bits]
        rows.append((*bits, int(bool(val))))
    return rows

def minterm_literal(var, bit):
    return var if bit==1 else f'\\overline{{{var}}}'

def minterm(vars_, bits):
    return ''.join(minterm_literal(v,b) for v,b in zip(vars_, bits))

def maxterm_literal(var, bit):
    return f'({var})' if bit==0 else f'(\\overline{{{var}}})'

def maxterm(vars_, bits):
    # (A + B + C) 형태를 LaTeX 없이 간단히 반환하려면 아래로 변경 가능
    terms = [ (var if b==1 else f'\\overline{{{var}}}') for var,b in zip(vars_, bits) ]
    return '(' + ' + '.join(terms) + ')'

def sop_from_tt(vars_, tt_rows):
    idx, terms = [], []
    for r,bits in enumerate(product([0,1], repeat=len(vars_))):
        # tt_rows는 동일 순서라고 가정
        val = tt_rows[r][-1]
        if val==1:
            idx.append(r)
            terms.append(minterm(vars_, bits))
    return idx, ' + '.join(terms)

def pos_from_tt(vars_, tt_rows):
    idx, terms = [], []
    for r,bits in enumerate(product([0,1], repeat=len(vars_))):
        val = tt_rows[r][-1]
        if val==0:
            idx.append(r)
            terms.append(maxterm(vars_, bits))
    return idx, ' '.join(terms)

# 사용 예: F(A,B,C)=A'B + A C'

def F_ABC(bits):
    A,B,C = bits
    return ( (1-A)*B ) or ( A*(1-C) )

vars_ = ['A','B','C']
tt = truth_table(vars_, F_ABC)
idx_sop, sop = sop_from_tt(vars_, tt)
idx_pos, pos = pos_from_tt(vars_, tt)

print("Truth table:")
for row in tt: print(row)
print("SOP indices:", idx_sop, "=>", sop)
print("POS indices:", idx_pos, "=>", pos)
```
{% endraw %}

### Python: 두 식(또는 람다)의 **동치 검증**

```python
from itertools import product

def equivalent(vars_, f, g):
    for bits in product([0,1], repeat=len(vars_)):
        if bool(f(bits)) != bool(g(bits)):
            return False, bits
    return True, None

# + (A'B C) (임의의 비교)

def F(bits):
    A,B,C = bits
    return (1-A)*B or (A*(1-C))

def G(bits):
    A,B,C = bits
    return (A^C) or ((1-A)*B*C)

ok, witness = equivalent(['A','B','C'], F, G)
print("Equivalent?", ok, "counterexample:", witness)
```

> **팁**: 소규모 변수(≤6)라면 전수검사로 동치성을 빠르게 확인할 수 있다.
> 대규모 회로는 BDD/탄소화 또는 SAT 방식이 필요(범위 밖).

---

## 추가 예제 — 단계별 풀이

### 단순화

분배:
$$
F = A\overline{A} + AC + B\overline{A} + BC
  = 0 + AC + B\overline{A} + BC
  = AC + \overline{A}B + BC
$$
합의 정리(\(AC + \overline{A}B + BC = AC + \overline{A}B\)):
$$
F = AC + \overline{A}B
$$

### 합의 적용

합의항은 \(BC\) 또는 \(\overline{A}\overline{B}\) 형태를 찾는다.
여기서 \(\overline{B}C\)는 \(\overline{A}C\)와 함께 \(C\)를 강화하는 항.
K-맵으로 확인하면 **최소**는 \(F=AB+\overline{A}C+\overline{B}C\) 자체(더 못 줄이는 경우가 많다).
단, don’t care가 있으면 추가 축약 가능.

### \(F(A,B,C)=\sum m(1,3,4,6)\)의 POS

0인 인덱스 \(\{0,2,5,7\}\)의 최대항 곱:
- \(M_0=(A+B+C)\)
- \(M_2=(A+\overline{B}+C)\)
- \(M_5=(\overline{A}+B+\overline{C})\)
- \(M_7=(\overline{A}+\overline{B}+\overline{C})\)

따라서
$$
F=\prod M(0,2,5,7)=(A+B+C)(A+\overline{B}+C)(\overline{A}+B+\overline{C})(\overline{A}+\overline{B}+\overline{C})
$$
(이후 K-맵으로 최소형 \(F=\overline{A}C+A\overline{C}\) 확인 가능)

### 조건별 SOP 작성

> “\(F=1\) 인 경우: \(A=1,B=0\)(\(C\) 무관), \(A=0,B=1,C=1\)”

- \(A=1,B=0\) (C 무관) → \(A\overline{B}\)
- \(A=0,B=1,C=1\) → \(\overline{A}BC\)

따라서
$$
F = A\overline{B} + \overline{A}BC
$$

---

## 흔한 오류와 빠른 교정

- **우선순위 착각**: \(A+BC = A + (BC)\) 이며 \((A+B)C\)가 아니다.
- **부분 반전 오용**: \(\overline{A+B}\neq \overline{A}+\overline{B}\) (오른쪽은 AND로 바꿔야 함).
- **정체성 오해**: \(A+\overline{A}B = A+B\) **는 참**(분배/흡수로 증명).
- **K-맵 묶기 누락**: 가능한 가장 큰 2의 거듭제곱 크기로 묶어야 최소 항수.

---

## 요약 포켓 카드

- **정규형**: \(F=\sum m(i)\) (SOP), \(F=\prod M(i)\) (POS)
- **핵심 등식**: 항등/지배/멱등/보수/이중부정, 교환/결합/분배, 흡수, 합의, 드모르간
- **샤논 전개**: \(F=xF|_{1}+\overline{x}F|_{0}\)
- **해저드 회피**: 커버가 끊기면 정적 해저드 → **합의항** 추가
- **보편 게이트**: NAND/NOR만으로 모든 논리 합성 가능

---

## 연습문제 (정답은 숨김)

1) \(F=(A+B)(\overline{A}+C)\) 를 가능한 한 간단히 하라.
2) \(F=AB+\overline{A}C + \overline{B}C\) 에 합의 정리를 적용해 최소형을 논하라.
3) \(F(A,B,C)=\sum m(1,3,4,6)\) 의 **POS 정규형**을 쓰고, K-맵으로 최소형을 구하라.
4) 진리표에서 \(F=1\) 인 경우가 \(A=1,B=0\)(\(C\) 무관), \(A=0,B=1,C=1\) 일 때 **SOP**를 쓰라.
5) \(F=\overline{A}B + A\overline{C}\) 의 **NAND-only** 구현을 게이트 수준으로 그려라.
6) \(F=AB+\overline{A}C\) 에서 \(A\)가 0→1로 바뀔 때 정적 해저드 가능성을 설명하고, 제거식을 제시하라.

---

## 마무리

이 글은 부울 대수의 **문법·정규형·정리**를 연결해 **식↔진리표** 변환과 **최소형 도출**까지 실전에 맞게 정리했다.
작은 문제는 **대수/K-맵**으로, 체계적 절차가 필요하면 **Q–M**을, 구현은 **NAND/NOR**로 표준화하라.
물리 회로에서는 **해저드**를 항상 점검하고, 필요 시 **합의항**으로 커버를 이어주는 것이 안전하다.
