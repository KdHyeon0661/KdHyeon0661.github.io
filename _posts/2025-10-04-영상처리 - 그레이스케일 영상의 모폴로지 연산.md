---
layout: post
title: 영상처리 - 그레이스케일 영상의 모폴로지 연산
date: 2025-10-04 21:25:23 +0900
category: 영상처리
---
# 그레이스케일 영상의 모폴로지 연산

## 1) 모폴로지(그레이스케일) 기본 정의

### 1.1 평탄(Flat) vs 비평탄(Non-Flat) 구조 요소(SE)
- **평탄 SE \(B\)**: 구조요소가 단지 **모양**(이웃 좌표 집합)만 지정.  
- **비평탄 SE \(B_h\)**: 모양 + 각 위치의 **높이(가중)** \(h(\mathbf{b})\) 를 가짐.

### 1.2 그레이스케일 **침식/팽창** (Flat SE 기준)
영상 \(f:\mathbb{Z}^2\to [0,255]\), 평탄 SE \(B\subset\mathbb{Z}^2\).  
- **침식**:
\[
(f\ominus B)(\mathbf{x}) = \min_{\mathbf{b}\in B} f(\mathbf{x}+\mathbf{b})
\]
- **팽창**:
\[
(f\oplus B)(\mathbf{x}) = \max_{\mathbf{b}\in B} f(\mathbf{x}-\mathbf{b})
\]
> 구현에서는 좌표 반사 포함 표기 차이를 피하려고, **양쪽 모두 “이웃 집합”의 min/max** 로 작성합니다.

### 1.3 **열기/닫기**
\[
f\circ B = (f\ominus B)\oplus B,\qquad
f\bullet B = (f\oplus B)\ominus B
\]
- **열기(Opening)**: 밝은 작은 돌기 제거(노이즈 억제), **형태 보존**.  
- **닫기(Closing)**: 어두운 작은 구멍 메움, 끊김 연결.

### 1.4 경계 조건(바깥 픽셀 취급)
- **복제(Replicate)**: 가장자리 값을 **복제** → 경계 인공효과 적음(기본 권장).  
- **상수(Constant)**: 바깥을 0(팽창에서 불리), 255(침식에서 불리) 등으로 고정.

---

## 2) 구현 — **그레이스케일 모폴로지 핵심 모듈**

> 일반(모양별) 구현 + **정사각 SE** 최적화(슬라이딩 최소/최대, Deque) 포함.  
> UI 연동을 위해 **DIB↔GRAY** 변환과 **고수준 API** 까지 제공합니다.

```cpp
// GrayMorphology.hpp
#pragma once
#include <vector>
#include <deque>
#include <cstdint>
#include <cmath>
#include <algorithm>
#include <string>
#include "IppDib.h"
#include "IppImage.h"

// ===== 공통 유틸 =====
inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }
inline int clampi(int v,int lo,int hi){ return v<lo?lo:(v>hi?hi:v); }

// DIB(BGRA32) -> Gray8 (BT.601 근사)
inline void DibToGray8(const IppDib& dib, IppImage<uint8_t>& g){
    g.create(dib.width(), dib.height());
    for (int y=0; y<dib.height(); ++y){
        const uint8_t* s=(const uint8_t*)dib.bits() + (size_t)y*dib.stride();
        uint8_t* d=g.row(y);
        for (int x=0; x<dib.width(); ++x){
            uint8_t B=s[x*4+0], G=s[x*4+1], R=s[x*4+2];
            int Y=(114*B + 587*G + 299*R + 500)/1000;
            d[x]=clamp_u8(Y);
        }
    }
}
// Gray8 -> DIB(BGRA32)
inline IppDib Gray8ToDib(const IppImage<uint8_t>& g){
    IppDib d; d.create(g.width(), g.height(), 32);
    for (int y=0; y<g.height(); ++y){
        const uint8_t* s=g.row(y);
        uint8_t* dd=(uint8_t*)d.bits() + (size_t)y*d.stride();
        for (int x=0; x<g.width(); ++x){
            dd[x*4+0]=dd[x*4+1]=dd[x*4+2]=s[x]; dd[x*4+3]=255;
        }
    }
    return d;
}

// ===== 경계 모드 =====
enum class BorderMode { Replicate, Constant };

struct Border {
    BorderMode mode = BorderMode::Replicate;
    uint8_t valueForDilate = 0;   // Constant일 때 팽창용 바깥값(보통 0)
    uint8_t valueForErode  = 255; // Constant일 때 침식용 바깥값(보통 255)
};

// 샘플링(경계 처리)
inline uint8_t sampleGray(const IppImage<uint8_t>& src, int x,int y, bool forDilate, const Border& bd){
    const int W=src.width(), H=src.height();
    if ((unsigned)x<(unsigned)W && (unsigned)y<(unsigned)H) return src.row(y)[x];
    if (bd.mode==BorderMode::Replicate){
        x=clampi(x,0,W-1); y=clampi(y,0,H-1); return src.row(y)[x];
    }
    return forDilate? bd.valueForDilate : bd.valueForErode;
}

// ===== 구조 요소(평탄) =====
enum class SE_Shape { Square, Disk, Diamond, Cross };

struct StructuringElementFlat {
    SE_Shape shape=SE_Shape::Square;
    int radius=1;               // Square: half-size; Disk: 픽셀반경; Diamond: L1; Cross: 십자 L1
    std::vector<int> dx, dy;    // (0,0) 포함 — 평탄(가중X)
};

inline StructuringElementFlat MakeSEFlat(SE_Shape shape, int radius){
    radius = std::max(0, radius);
    StructuringElementFlat se; se.shape=shape; se.radius=radius;
    auto push=[&](int i,int j){ se.dx.push_back(i); se.dy.push_back(j); };
    if (radius==0){ push(0,0); return se; }

    switch(shape){
    case SE_Shape::Square:
        for (int j=-radius;j<=radius;++j)
            for (int i=-radius;i<=radius;++i) push(i,j);
        break;
    case SE_Shape::Disk: {
        int r2=radius*radius;
        for (int j=-radius;j<=radius;++j)
            for (int i=-radius;i<=radius;++i)
                if (i*i + j*j <= r2) push(i,j);
        break;
    }
    case SE_Shape::Diamond: // L1 ball
        for (int j=-radius;j<=radius;++j)
            for (int i=-radius;i<=radius;++i)
                if (std::abs(i)+std::abs(j) <= radius) push(i,j);
        break;
    case SE_Shape::Cross:
        for (int k=-radius;k<=radius;++k){ push(k,0); if (k!=0) push(0,k); }
        break;
    }
    return se;
}

// ===== 기본(일반형) 침식/팽창 (평탄 SE, 경계모드 반영) =====
inline void GrayErodeFlat(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst,
                          const StructuringElementFlat& se, const Border& bd)
{
    const int W=src.width(), H=src.height(); dst.create(W,H);
    for (int y=0;y<H;++y){
        uint8_t* d=dst.row(y);
        for (int x=0;x<W;++x){
            int m=255;
            for (size_t k=0;k<se.dx.size();++k){
                int xx=x+se.dx[k], yy=y+se.dy[k];
                uint8_t v = sampleGray(src,xx,yy,false,bd);
                if (v<m) m=v;
            }
            d[x]=(uint8_t)m;
        }
    }
}
inline void GrayDilateFlat(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst,
                           const StructuringElementFlat& se, const Border& bd)
{
    const int W=src.width(), H=src.height(); dst.create(W,H);
    for (int y=0;y<H;++y){
        uint8_t* d=dst.row(y);
        for (int x=0;x<W;++x){
            int M=0;
            for (size_t k=0;k<se.dx.size();++k){
                int xx=x+se.dx[k], yy=y+se.dy[k];
                uint8_t v = sampleGray(src,xx,yy,true,bd);
                if (v>M) M=v;
            }
            d[x]=(uint8_t)M;
        }
    }
}

// ===== 정사각 SE 최적화(Deque 기반 슬라이딩 min/max) =====
// 1D 슬라이딩 최소/최대 (윈도우 크기 = 2r+1)
template<typename T, bool isMin>
static void slidingMinMax1D(const T* s, T* d, int N, int r){
    std::deque<int> dq; const int K=2*r+1;
    auto worse=[&](T a,T b){ return isMin? (a>=b) : (a<=b); }; // pop 조건
    for (int i=0;i<N;++i){
        // push i
        while(!dq.empty() && worse(s[dq.back()], s[i])) dq.pop_back();
        dq.push_back(i);
        // remove out-of-window
        int left = i-K+1;
        if (dq.front()<left) dq.pop_front();
        // write
        if (i>=K-1) d[left + r] = s[dq.front()];
    }
    // 앞부분(pad) 처리: 가장 처음 유효창 이전 구간을 replicate 의미로 처리
    for(int i=0;i<r;++i) d[i]=s[dq.empty()?0:dq.front()];
    // 뒷부분(pad)
    for(int i=N-r;i<N;++i) d[i]=s[dq.empty()?N-1:dq.front()];
}

// 정사각 SE(r) 침식/팽창 = 수평 1D -> 수직 1D (min/max)
inline void GrayErodeSquareFast(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst, int r){
    const int W=src.width(), H=src.height();
    IppImage<uint8_t> tmp(W,H);
    // 수평 min
    for (int y=0;y<H;++y){
        const uint8_t* s=src.row(y); std::vector<uint8_t> t(W);
        slidingMinMax1D<uint8_t,true>(s, t.data(), W, r);
        std::copy(t.begin(), t.end(), tmp.row(y));
    }
    // 수직 min
    dst.create(W,H);
    std::vector<uint8_t> col(H), out(H);
    for (int x=0;x<W;++x){
        for (int y=0;y<H;++y) col[y]=tmp.row(y)[x];
        slidingMinMax1D<uint8_t,true>(col.data(), out.data(), H, r);
        for (int y=0;y<H;++y) dst.row(y)[x]=out[y];
    }
}
inline void GrayDilateSquareFast(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst, int r){
    const int W=src.width(), H=src.height();
    IppImage<uint8_t> tmp(W,H);
    // 수평 max
    for (int y=0;y<H;++y){
        const uint8_t* s=src.row(y); std::vector<uint8_t> t(W);
        slidingMinMax1D<uint8_t,false>(s, t.data(), W, r);
        std::copy(t.begin(), t.end(), tmp.row(y));
    }
    // 수직 max
    dst.create(W,H);
    std::vector<uint8_t> col(H), out(H);
    for (int x=0;x<W;++x){
        for (int y=0;y<H;++y) col[y]=tmp.row(y)[x];
        slidingMinMax1D<uint8_t,false>(col.data(), out.data(), H, r);
        for (int y=0;y<H;++y) dst.row(y)[x]=out[y];
    }
}

// ===== 열기/닫기/그래디언트/탑햇 =====
inline void GrayOpen(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst,
                     const StructuringElementFlat& se, const Border& bd, bool tryFast=true){
    IppImage<uint8_t> t;
    if (tryFast && se.shape==SE_Shape::Square){
        GrayErodeSquareFast(src, t, se.radius);
        GrayDilateSquareFast(t, dst, se.radius);
    }else{
        GrayErodeFlat(src, t, se, bd);
        GrayDilateFlat(t, dst, se, bd);
    }
}
inline void GrayClose(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst,
                      const StructuringElementFlat& se, const Border& bd, bool tryFast=true){
    IppImage<uint8_t> t;
    if (tryFast && se.shape==SE_Shape::Square){
        GrayDilateSquareFast(src, t, se.radius);
        GrayErodeSquareFast(t, dst, se.radius);
    }else{
        GrayDilateFlat(src, t, se, bd);
        GrayErodeFlat(t, dst, se, bd);
    }
}
inline void GrayGradient(const IppImage<uint8_t>& src, IppImage<uint8_t>& grad,
                         const StructuringElementFlat& se, const Border& bd, bool tryFast=true){
    IppImage<uint8_t> er, di;
    if (tryFast && se.shape==SE_Shape::Square){
        GrayErodeSquareFast(src, er, se.radius);
        GrayDilateSquareFast(src, di, se.radius);
    }else{
        GrayErodeFlat(src, er, se, bd);
        GrayDilateFlat(src, di, se, bd);
    }
    grad.create(src.width(), src.height());
    for (int y=0;y<src.height();++y){
        const uint8_t* a=di.row(y); const uint8_t* b=er.row(y); uint8_t* d=grad.row(y);
        for (int x=0;x<src.width();++x){ int v=a[x]-b[x]; d[x]=(uint8_t)clampi(v,0,255); }
    }
}
inline void TopHat(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst,
                   const StructuringElementFlat& se, const Border& bd, bool white=true, bool tryFast=true){
    // white-top-hat: src - open(src), black-top-hat: close(src) - src
    IppImage<uint8_t> t;
    if (white){
        GrayOpen(src, t, se, bd, tryFast);
        dst.create(src.width(), src.height());
        for (int y=0;y<src.height();++y){
            const uint8_t* s=src.row(y), *o=t.row(y); uint8_t* d=dst.row(y);
            for (int x=0;x<src.width();++x){ int v=s[x]-o[x]; d[x]=(uint8_t)clampi(v,0,255); }
        }
    }else{
        GrayClose(src, t, se, bd, tryFast);
        dst.create(src.width(), src.height());
        for (int y=0;y<src.height();++y){
            const uint8_t* c=t.row(y), *s=src.row(y); uint8_t* d=dst.row(y);
            for (int x=0;x<src.width();++x){ int v=c[x]-s[x]; d[x]=(uint8_t)clampi(v,0,255); }
        }
    }
}

// ===== 반복 적용(침식/팽창/열기/닫기) =====
inline void GrayErodeN(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst,
                       const StructuringElementFlat& se, const Border& bd, int n, bool tryFast=true){
    IppImage<uint8_t> cur=src,tmp;
    for(int i=0;i<n;++i){
        if (tryFast && se.shape==SE_Shape::Square) GrayErodeSquareFast(cur,tmp,se.radius);
        else GrayErodeFlat(cur,tmp,se,bd);
        cur.swap(tmp);
    }
    dst.swap(cur);
}
inline void GrayDilateN(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst,
                        const StructuringElementFlat& se, const Border& bd, int n, bool tryFast=true){
    IppImage<uint8_t> cur=src,tmp;
    for(int i=0;i<n;++i){
        if (tryFast && se.shape==SE_Shape::Square) GrayDilateSquareFast(cur,tmp,se.radius);
        else GrayDilateFlat(cur,tmp,se,bd);
        cur.swap(tmp);
    }
    dst.swap(cur);
}
inline void GrayOpenN(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst,
                      const StructuringElementFlat& se, const Border& bd, int n, bool tryFast=true){
    IppImage<uint8_t> cur=src,tmp;
    for(int i=0;i<n;++i){ GrayOpen(cur,tmp,se,bd,tryFast); cur.swap(tmp); }
    dst.swap(cur);
}
inline void GrayCloseN(const IppImage<uint8_t>& src, IppImage<uint8_t>& dst,
                       const StructuringElementFlat& se, const Border& bd, int n, bool tryFast=true){
    IppImage<uint8_t> cur=src,tmp;
    for(int i=0;i<n;++i){ GrayClose(cur,tmp,se,bd,tryFast); cur.swap(tmp); }
    dst.swap(cur);
}

// ===== 고수준 API (DIB 입출력) =====
enum class GrayMorphOp { Erode, Dilate, Open, Close, Gradient, WhiteTopHat, BlackTopHat };

struct GrayMorphOptions {
    GrayMorphOp op = GrayMorphOp::Open;
    SE_Shape shape = SE_Shape::Disk;
    int radius = 1;
    int iterations = 1;
    Border border{};      // 기본: Replicate
    bool tryFastSquare = true; // Square일 때 빠른 경로 사용
};

inline bool RunGrayMorphology(const IppDib& in, IppDib& out, const GrayMorphOptions& opt){
    if (!in) return false;
    IppImage<uint8_t> g; DibToGray8(in, g);
    StructuringElementFlat se = MakeSEFlat(opt.shape, opt.radius);

    IppImage<uint8_t> dst;
    switch(opt.op){
    case GrayMorphOp::Erode:        GrayErodeN(g,dst,se,opt.border,opt.iterations,opt.tryFastSquare); break;
    case GrayMorphOp::Dilate:       GrayDilateN(g,dst,se,opt.border,opt.iterations,opt.tryFastSquare); break;
    case GrayMorphOp::Open:         GrayOpenN(g,dst,se,opt.border,opt.iterations,opt.tryFastSquare);   break;
    case GrayMorphOp::Close:        GrayCloseN(g,dst,se,opt.border,opt.iterations,opt.tryFastSquare);  break;
    case GrayMorphOp::Gradient:     GrayGradient(g,dst,se,opt.border,opt.tryFastSquare);               break;
    case GrayMorphOp::WhiteTopHat:  TopHat(g,dst,se,opt.border,true,opt.tryFastSquare);                break;
    case GrayMorphOp::BlackTopHat:  TopHat(g,dst,se,opt.border,false,opt.tryFastSquare);               break;
    }
    out = Gray8ToDib(dst);
    return true;
}
```

> 구현 포인트  
> - **정사각 SE 최적화**: 수평/수직 **슬라이딩 min/max**(Deque)로 \(\mathcal{O}(WH)\) 시간에 동작 → 반경이 커질수록 효과 큼.  
> - **경계 모드**: 기본 Replicate. 문서/자연영상에 흔한 경계 링잉을 줄임.  
> - **화이트/블랙 톱햇**: 밝은 얇은 구조 강조 / 어두운 얇은 구조 강조(배경 보정에 매우 유용).

---

## 3) UI — **그레이스케일 모폴로지** 대화 상자 & 메뉴

### 3.1 리소스 ID

```cpp
// resource.h (추가)
#define ID_MENU_GRAY_MORPH              88010

#define IDD_GRAY_MORPH_DLG              4500
#define IDC_RAD_GM_ERODE                4501
#define IDC_RAD_GM_DILATE               4502
#define IDC_RAD_GM_OPEN                 4503
#define IDC_RAD_GM_CLOSE                4504
#define IDC_RAD_GM_GRAD                 4505
#define IDC_RAD_GM_WTH                  4506
#define IDC_RAD_GM_BTH                  4507

#define IDC_CMB_GM_SHAPE                4510
#define IDC_EDIT_GM_RADIUS              4511
#define IDC_EDIT_GM_ITERS               4512

#define IDC_CMB_GM_BORDER               4513
#define IDC_EDIT_GM_BDDIL               4514
#define IDC_EDIT_GM_BDERO               4515
#define IDC_CHK_GM_NEWWIN               4516
#define IDC_STC_GM_SUMMARY              4517
```

### 3.2 RC

```rc
// ImageTool.rc (추가)
POPUP "&Gray"
BEGIN
    MENUITEM "Grayscale Morphology...\tCtrl+G", ID_MENU_GRAY_MORPH
END

IDD_GRAY_MORPH_DLG DIALOGEX 0,0, 320, 196
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Grayscale Morphology"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Operation", -1, 12, 8, 136, 106
    AUTORADIOBUTTON "Erode",        IDC_RAD_GM_ERODE, 22, 22, 60, 10, WS_TABSTOP
    AUTORADIOBUTTON "Dilate",       IDC_RAD_GM_DILATE,22, 36, 60, 10
    AUTORADIOBUTTON "Open",         IDC_RAD_GM_OPEN,  22, 50, 60, 10
    AUTORADIOBUTTON "Close",        IDC_RAD_GM_CLOSE, 22, 64, 60, 10
    AUTORADIOBUTTON "Gradient",     IDC_RAD_GM_GRAD,  22, 78, 60, 10
    AUTORADIOBUTTON "White Top-hat",IDC_RAD_GM_WTH,   22, 92, 90, 10
    AUTORADIOBUTTON "Black Top-hat",IDC_RAD_GM_BTH,   22, 106,90, 10

    LTEXT "SE shape:", -1, 164, 18, 50, 10
    COMBOBOX IDC_CMB_GM_SHAPE, 224, 16, 80, 72, CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "Radius:",   -1, 164, 38, 40, 10
    EDITTEXT IDC_EDIT_GM_RADIUS, 224, 36, 36, 14, ES_NUMBER
    LTEXT "Iterations:",-1, 164, 56, 50, 10
    EDITTEXT IDC_EDIT_GM_ITERS,  224, 54, 36, 14, ES_NUMBER

    LTEXT "Border:", -1, 164, 78, 40, 10
    COMBOBOX IDC_CMB_GM_BORDER, 224, 76, 80, 56, CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT "B(dilate):", -1, 164, 96, 50, 10
    EDITTEXT IDC_EDIT_GM_BDDIL,  224, 94, 36, 14, ES_NUMBER
    LTEXT "B(erode):",  -1, 164, 114, 50, 10
    EDITTEXT IDC_EDIT_GM_BDERO,  224, 112, 36, 14, ES_NUMBER

    AUTOCHECKBOX "Open in new window", IDC_CHK_GM_NEWWIN, 164, 134, 120, 12

    LTEXT "Summary:", -1, 12, 146, 50, 10
    LTEXT "", IDC_STC_GM_SUMMARY, 62, 146, 242, 26

    DEFPUSHBUTTON "Run", IDOK,  188, 166, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 238, 166, 44, 16
END
```

### 3.3 대화 상자 코드 & 메뉴 핸들러

```cpp
// GrayMorphDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "GrayMorphology.hpp"

// 앱 공용
HWND CreateDocWindowFromDib(const IppDib& dib, const std::wstring& title);

class GrayMorphDlg {
public:
    GrayMorphDlg(HWND owner, IppDib& target) : owner_(owner), target_(target) {}
    INT_PTR DoModal();
private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);

    GrayMorphOptions ReadOptions(HWND h) const;

private:
    HWND owner_{};
    IppDib& target_;
};
```

```cpp
// GrayMorphDlg.cpp
#include "GrayMorphDlg.h"

INT_PTR GrayMorphDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_GRAY_MORPH_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK GrayMorphDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((GrayMorphDlg*)l)->OnInit(h); }
    auto* self=(GrayMorphDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
INT_PTR GrayMorphDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_GM_ERODE, IDC_RAD_GM_BTH, IDC_RAD_GM_OPEN);
    // Shape
    SendDlgItemMessageW(h, IDC_CMB_GM_SHAPE, CB_ADDSTRING, 0, (LPARAM)L"Square");
    SendDlgItemMessageW(h, IDC_CMB_GM_SHAPE, CB_ADDSTRING, 0, (LPARAM)L"Disk");
    SendDlgItemMessageW(h, IDC_CMB_GM_SHAPE, CB_ADDSTRING, 0, (LPARAM)L"Diamond");
    SendDlgItemMessageW(h, IDC_CMB_GM_SHAPE, CB_ADDSTRING, 0, (LPARAM)L"Cross");
    SendDlgItemMessageW(h, IDC_CMB_GM_SHAPE, CB_SETCURSEL, 1, 0); // Disk
    // Radius/Iterations
    SetDlgItemInt(h, IDC_EDIT_GM_RADIUS, 1, FALSE);
    SetDlgItemInt(h, IDC_EDIT_GM_ITERS,  1, FALSE);
    // Border
    SendDlgItemMessageW(h, IDC_CMB_GM_BORDER, CB_ADDSTRING, 0, (LPARAM)L"Replicate");
    SendDlgItemMessageW(h, IDC_CMB_GM_BORDER, CB_ADDSTRING, 0, (LPARAM)L"Constant");
    SendDlgItemMessageW(h, IDC_CMB_GM_BORDER, CB_SETCURSEL, 0, 0);
    SetDlgItemInt(h, IDC_EDIT_GM_BDDIL, 0, FALSE);
    SetDlgItemInt(h, IDC_EDIT_GM_BDERO, 255, FALSE);

    CheckDlgButton(h, IDC_CHK_GM_NEWWIN, BST_CHECKED);
    SetDlgItemTextW(h, IDC_STC_GM_SUMMARY, L"(ready)");
    return TRUE;
}
GrayMorphOptions GrayMorphDlg::ReadOptions(HWND h) const{
    GrayMorphOptions opt;
    if (IsDlgButtonChecked(h, IDC_RAD_GM_ERODE)==BST_CHECKED) opt.op=GrayMorphOp::Erode;
    else if (IsDlgButtonChecked(h, IDC_RAD_GM_DILATE)==BST_CHECKED) opt.op=GrayMorphOp::Dilate;
    else if (IsDlgButtonChecked(h, IDC_RAD_GM_OPEN)==BST_CHECKED) opt.op=GrayMorphOp::Open;
    else if (IsDlgButtonChecked(h, IDC_RAD_GM_CLOSE)==BST_CHECKED) opt.op=GrayMorphOp::Close;
    else if (IsDlgButtonChecked(h, IDC_RAD_GM_GRAD)==BST_CHECKED) opt.op=GrayMorphOp::Gradient;
    else if (IsDlgButtonChecked(h, IDC_RAD_GM_WTH)==BST_CHECKED) opt.op=GrayMorphOp::WhiteTopHat;
    else opt.op=GrayMorphOp::BlackTopHat;

    int si=(int)SendDlgItemMessageW(h, IDC_CMB_GM_SHAPE, CB_GETCURSEL, 0, 0);
    opt.shape = (si==0)? SE_Shape::Square : (si==1)? SE_Shape::Disk : (si==2)? SE_Shape::Diamond : SE_Shape::Cross;

    BOOL ok=FALSE; int v;
    v=GetDlgItemInt(h, IDC_EDIT_GM_RADIUS, &ok, FALSE); opt.radius= ok? std::max(0,v):1;
    v=GetDlgItemInt(h, IDC_EDIT_GM_ITERS,  &ok, FALSE); opt.iterations= ok? std::max(1,v):1;

    int bi=(int)SendDlgItemMessageW(h, IDC_CMB_GM_BORDER, CB_GETCURSEL, 0, 0);
    opt.border.mode = (bi==0)? BorderMode::Replicate : BorderMode::Constant;
    v=GetDlgItemInt(h, IDC_EDIT_GM_BDDIL, &ok, FALSE); opt.border.valueForDilate= ok? (uint8_t)clampi(v,0,255) : 0;
    v=GetDlgItemInt(h, IDC_EDIT_GM_BDERO, &ok, FALSE); opt.border.valueForErode = ok? (uint8_t)clampi(v,0,255) : 255;

    opt.tryFastSquare = true; // 고정 사용(성능 향상)
    return opt;
}
INT_PTR GrayMorphDlg::OnCommand(HWND h, WPARAM w){
    switch(LOWORD(w)){
    case IDOK: {
        GrayMorphOptions opt=ReadOptions(h);
        IppDib out;
        if (!RunGrayMorphology(target_, out, opt)){
            MessageBoxW(h, L"실행 실패: 입력 영상을 확인하세요.", L"Gray Morphology", MB_ICONERROR);
            return TRUE;
        }
        wchar_t sum[160];
        wsprintfW(sum, L"%ls, shape=%d, r=%d, it=%d, border=%ls",
            (opt.op==GrayMorphOp::Erode?L"Erode": opt.op==GrayMorphOp::Dilate?L"Dilate":
             opt.op==GrayMorphOp::Open?L"Open": opt.op==GrayMorphOp::Close?L"Close":
             opt.op==GrayMorphOp::Gradient?L"Gradient": opt.op==GrayMorphOp::WhiteTopHat?L"WhiteTopHat":L"BlackTopHat"),
            (int)opt.shape, opt.radius, opt.iterations,
            (opt.border.mode==BorderMode::Replicate?L"Replicate":L"Constant"));
        SetDlgItemTextW(h, IDC_STC_GM_SUMMARY, sum);

        if (IsDlgButtonChecked(h, IDC_CHK_GM_NEWWIN)==BST_CHECKED){
            CreateDocWindowFromDib(out, L"Gray Morphology");
        }else{
            target_ = out; InvalidateRect(owner_, nullptr, FALSE);
        }
        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

```cpp
// main_multiwin.cpp (발췌)
#include "GrayMorphDlg.h"

// ...
case ID_MENU_GRAY_MORPH:
    if (st && st->dib){
        GrayMorphDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            UpdateStatusBasic(hWnd, st); // 상태바: op/shape/radius/iters/border
        }
    }
    return 0;
```

---

## 4) 예제 & 상황

### 예제 A) **문서 스캔: 배경 보정 + 글자 강조(화이트 톱햇)**
- **상황**: 스캔 문서가 불균일한 배경(그레이 캐스트)을 가짐.  
- **절차**:  
  1) `Gray → Grayscale Morphology…`  
  2) **White Top-hat**, SE=Disk, **radius=8~12**, Iter=1, Border=Replicate, 새 창 출력  
- **결과**: 배경 저주파를 제거하고 **밝은 글자/획**이 상대적으로 강조 → 이진화(13.1) 품질 상승.

### 예제 B) **자연영상: 작은 하이라이트 제거(열기)**
- **상황**: 표면 반사점(밝은 소금 노이즈) 제거 필요.  
- **절차**: **Open**, SE=Disk, r=2~3 → 필요 시 2회 반복.  
- **결과**: 작은 밝은 점이 사라지고 윤곽은 보존.

### 예제 C) **끊긴 잉크 라인 연결(닫기)**
- **상황**: 얇은 어두운 선이 부분적으로 끊김.  
- **절차**: **Close**, SE=Cross(십자), r=1~2 → 가는 선 연결성이 향상.  
- **결과**: 라인 추적/외곽선(13.3) 성공률 증가.

### 예제 D) **엣지 근사(모폴로지 그래디언트)**
- **상황**: 빠르게 윤곽 강도를 얻고 싶음.  
- **절차**: **Gradient**, SE=Square, r=1  
- **결과**: \((f\oplus B)-(f\ominus B)\) 로 **밝기 범위**를 근사 → 간단 엣지 맵.

---

## 5) 정확성 · 성능 · 확장 팁

- **SE 선택**  
  - **Disk**: 회전 대칭, 자연스러운 형태 보존.  
  - **Square**: 최적화(슬라이딩 min/max) 가능 → 큰 반경도 빠름.  
  - **Diamond/Cross**: 격자 방향성 반영(선 구조에 유리).
- **반복 vs 반경**: 큰 반경 한 번 ↔ 작은 반경 여러 번은 결과가 다릅니다(특히 non-Linear). 시각적 목표에 맞게 실험.  
- **경계모드**: 문서/자연영상은 Replicate 추천. 패턴 합성 시 Constant로 실험해 의도적 가장자리 억제 가능.  
- **비평탄 SE**: 필요하면 `StructuringElementFlat` 대신 **높이 배열**(int8/float)을 추가해  
  \((f\oplus B_h)(x)=\max_{\mathbf{b}\in B} \left( f(x+\mathbf{b})+h(\mathbf{b}) \right)\),  
  \((f\ominus B_h)(x)=\min_{\mathbf{b}\in B} \left( f(x+\mathbf{b})-h(\mathbf{b}) \right)\) 로 확장하세요.

---

## 6) 빠른 자가 테스트

```cpp
// test_gray_morph.cpp
#include <cassert>
#include "IppDib.h"
#include "GrayMorphology.hpp"

int main(){
    // 128x96 그라디언트 + 하이라이트 점
    const int W=128,H=96;
    IppDib dib; dib.create(W,H,32);
    for(int y=0;y<H;++y){
        uint8_t* d=(uint8_t*)dib.bits()+y*dib.stride();
        for(int x=0;x<W;++x){
            uint8_t g=(uint8_t)((x*255)/(W-1));
            d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
        }
    }
    // 밝은 점 20개 추가
    auto poke=[&](int x,int y,uint8_t v){ uint8_t* p=(uint8_t*)dib.bits()+y*dib.stride()+x*4; p[0]=p[1]=p[2]=v; };
    for(int i=0;i<20;++i){ poke((i*11)%W, (i*7)%H, 255); }

    // (1) Open(Disk r=2): 하이라이트 제거
    GrayMorphOptions opt; opt.op=GrayMorphOp::Open; opt.shape=SE_Shape::Disk; opt.radius=2; opt.iterations=1;
    IppDib out; bool ok = RunGrayMorphology(dib, out, opt); assert(ok);

    // (2) Gradient(Square r=1): 엣지 근사
    opt.op=GrayMorphOp::Gradient; opt.shape=SE_Shape::Square; opt.radius=1;
    ok = RunGrayMorphology(dib, out, opt); assert(ok);

    // (3) White Top-hat(Disk r=8): 밝은 얇은 구조 강조
    opt.op=GrayMorphOp::WhiteTopHat; opt.shape=SE_Shape::Disk; opt.radius=8;
    ok = RunGrayMorphology(dib, out, opt); assert(ok);
    return 0;
}
```

---

## 7) 요약
- 그레이스케일 모폴로지의 **침식/팽창**은 **이웃의 min/max** 로 정의되어,  
  **열기/닫기**를 통해 밝은 점/어두운 구멍을 효과적으로 제어합니다.  
- 제공한 모듈은 **경계모드(Replicate/Constant)**, **SE 모양**(Square/Disk/Diamond/Cross),  
  **반경/반복**, **정사각 SE 최적화**(슬라이딩 min/max)까지 갖춘 **실전용**입니다.  
- “Grayscale Morphology…” 대화 상자에서 손쉽게 조절하여  
  문서 보정, 반사점 제거, 라인 연결, 간단 엣지 생성(모폴로지 그래디언트/톱햇) 등 다양한 작업에 바로 활용하세요.