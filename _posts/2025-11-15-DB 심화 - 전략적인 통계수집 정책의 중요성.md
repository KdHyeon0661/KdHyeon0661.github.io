---
layout: post
title: DB 심화 - 전략적인 통계수집 정책의 중요성
date: 2025-11-15 23:25:23 +0900
category: DB 심화
---
# Oracle DBMS_STATS 실전 가이드: 전략적인 통계 수집 정책

옵티마이저의 정확한 판단을 위해서는 통계 정보의 정확성과 적시성이 가장 중요합니다. 무분별한 통계 수집은 성능 문제를 초래할 수 있으며, 전략적인 접근이 필요합니다. 이 가이드는 Oracle 데이터베이스에서 효과적인 통계 관리 전략을 체계적으로 설명합니다.

## 실습 환경 설정

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;
```

실행 계획 분석을 위한 표준 템플릿:
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL,
  'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'
));
```

## 기본 데이터 모델 구성

차원-팩트 모델을 기반으로 한 실습 환경을 구성합니다:

```sql
-- 기존 테이블 정리
BEGIN
  FOR t IN (SELECT table_name FROM user_tables
            WHERE table_name IN ('D_CUSTOMER','D_PRODUCT','F_SALES')) LOOP
    EXECUTE IMMEDIATE 'DROP TABLE '||t.table_name||' PURGE CASCADE CONSTRAINTS';
  END LOOP;
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

-- 고객 차원 테이블
CREATE TABLE D_CUSTOMER(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8) NOT NULL,
  TIER    VARCHAR2(8) NOT NULL
);

-- 제품 차원 테이블
CREATE TABLE D_PRODUCT(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,
  BRAND    VARCHAR2(12) NOT NULL
);

-- 월별 파티션 판매 팩트 테이블
CREATE TABLE F_SALES(
  SALES_ID NUMBER,
  CUST_ID  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  SALES_DT DATE   NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_F_SALES PRIMARY KEY (SALES_ID)
)
PARTITION BY RANGE (SALES_DT) (
  PARTITION P202401 VALUES LESS THAN (DATE '2024-02-01'),
  PARTITION P202402 VALUES LESS THAN (DATE '2024-03-01'),
  PARTITION P202403 VALUES LESS THAN (DATE '2024-04-01'),
  PARTITION P_FUTURE VALUES LESS THAN (MAXVALUE)
);

-- 인덱스 생성
CREATE INDEX IX_CUST_REGION ON D_CUSTOMER(REGION, CUST_ID);
CREATE INDEX IX_PROD_CAT_BRAND ON D_PRODUCT(CATEGORY, BRAND, PROD_ID);
CREATE INDEX IX_FS_CUST_DT ON F_SALES(CUST_ID, SALES_DT) LOCAL;
CREATE INDEX IX_FS_PROD_DT ON F_SALES(PROD_ID, SALES_DT) LOCAL;
```

## 샘플 데이터 생성

비즈니스 시나리오에 맞는 샘플 데이터를 생성합니다:

```sql
-- 고객 데이터 (5만 건)
BEGIN
  FOR c IN 1..50000 LOOP
    INSERT INTO D_CUSTOMER VALUES(
      c,
      CASE MOD(c,6) 
        WHEN 0 THEN 'KOR' WHEN 1 THEN 'KOR'  -- KOR 고객이 2/6 (약 33%)
        WHEN 2 THEN 'APAC' WHEN 3 THEN 'EMEA'
        WHEN 4 THEN 'AMER' ELSE 'JPN'
      END,
      CASE MOD(c,100) 
        WHEN 0 THEN 'VIP'    -- VIP: 1%
        WHEN 1 THEN 'GOLD'   -- GOLD: 1%
        WHEN 2 THEN 'SILVER' -- SILVER: 1%
        ELSE 'STANDARD'      -- STANDARD: 97%
      END
    );
  END LOOP;
  COMMIT;
END;
/

-- 제품 데이터 (2만 건, 브랜드 분포에 편향 있음)
BEGIN
  FOR p IN 1..20000 LOOP
    INSERT INTO D_PRODUCT VALUES(
      p,
      CASE MOD(p,5) 
        WHEN 0 THEN 'ELECTRONICS'
        WHEN 1 THEN 'FOOD'
        WHEN 2 THEN 'TOYS'
        WHEN 3 THEN 'HOME'
        ELSE 'FASHION'
      END,
      CASE 
        WHEN p <= 6000 THEN 'BRAND_A'      -- 30%: BRAND_A
        WHEN p <= 12000 THEN 'BRAND_B'     -- 30%: BRAND_B
        WHEN p <= 18000 THEN 'BRAND_C'     -- 30%: BRAND_C
        ELSE 'OTHER_BRAND'                 -- 10%: 기타 브랜드
      END
    );
  END LOOP;
  COMMIT;
END;
/

-- 판매 데이터 (월별 15만 건씩, 3개월 분)
BEGIN
  FOR month_offset IN 0..2 LOOP  -- 1월, 2월, 3월
    FOR i IN 1..150000 LOOP
      INSERT INTO F_SALES VALUES(
        (month_offset * 150000) + i,
        MOD(i, 50000) + 1,  -- 고객 ID (1~50000)
        MOD(i, 20000) + 1,  -- 제품 ID (1~20000)
        DATE '2024-01-01' + (month_offset * INTERVAL '1' MONTH) + MOD(i, 28),
        1 + MOD(i, 5),      -- 수량 (1~5)
        CASE 
          WHEN MOD(i, 100) = 0 THEN 10000.00  -- 대규모 거래 (1%)
          ELSE ROUND(DBMS_RANDOM.VALUE(10, 500), 2)  -- 일반 거래
        END
      );
    END LOOP;
  END LOOP;
  COMMIT;
END;
/
```

## 기본 통계 수집

초기 통계를 수집합니다:

```sql
BEGIN
  -- 차원 테이블 통계 수집 (히스토그램 제외)
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'D_CUSTOMER',
    cascade    => TRUE,
    method_opt => 'FOR ALL COLUMNS SIZE 1'
  );
  
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'D_PRODUCT',
    cascade    => TRUE,
    method_opt => 'FOR ALL COLUMNS SIZE 1'
  );
  
  -- 팩트 테이블 통계 수집 (파티션 단위)
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname          => USER,
    tabname          => 'F_SALES',
    cascade          => TRUE,
    method_opt       => 'FOR ALL COLUMNS SIZE 1',
    granularity      => 'ALL',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE
  );
END;
/
```

## 전략적 통계 관리 원칙

### 1. 테이블 선호 설정 관리

각 테이블의 특성에 맞는 통계 수집 정책을 설정합니다:

```sql
-- 고객 차원 테이블: 안정적인 테이블
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(
    ownname => USER,
    tabname => 'D_CUSTOMER',
    pname   => 'STALE_PERCENT',
    pvalue  => '10'  -- 10% 이상 변경 시만 stale 처리
  );
END;
/

-- 제품 차원 테이블: 편향된 분포를 가진 테이블
BEGIN
  DBMS_STATS.SET_TABLE_PREFS(
    ownname => USER,
    tabname => 'D_PRODUCT',
    pname   => 'STALE_PERCENT',
    pvalue  => '5'  -- 5% 변경 시 stale 처리
  );
  
  -- 히스토그램 활성화 (브랜드 컬럼)
  DBMS_STATS.SET_TABLE_PREFS(
    ownname => USER,
    tabname => 'D_PRODUCT',
    pname   => 'METHOD_OPT',
    pvalue  => 'FOR COLUMNS SIZE 254 BRAND, FOR ALL COLUMNS SIZE 1'
  );
END;
/

-- 판매 팩트 테이블: 대용량 파티션 테이블
BEGIN
  -- 증분 통계 활성화
  DBMS_STATS.SET_TABLE_PREFS(
    ownname => USER,
    tabname => 'F_SALES',
    pname   => 'INCREMENTAL',
    pvalue  => 'TRUE'
  );
  
  -- Pending 통계 사용 (검증 후 게시)
  DBMS_STATS.SET_TABLE_PREFS(
    ownname => USER,
    tabname => 'F_SALES',
    pname   => 'PUBLISH',
    pvalue  => 'FALSE'
  );
  
  -- 변경 임계값 설정
  DBMS_STATS.SET_TABLE_PREFS(
    ownname => USER,
    tabname => 'F_SALES',
    pname   => 'STALE_PERCENT',
    pvalue  => '5'
  );
  
  -- 플랜 무효화 지연
  DBMS_STATS.SET_TABLE_PREFS(
    ownname => USER,
    tabname => 'F_SALES',
    pname   => 'NO_INVALIDATE',
    pvalue  => 'TRUE'
  );
END;
/
```

### 2. 히스토그램 관리 전략

히스토그램은 선택적으로 사용해야 합니다:

```sql
-- 컬럼 사용 분석 활성화
EXEC DBMS_STATS.SEED_COL_USAGE(NULL, NULL, 300);  -- 5분간 모니터링

-- 모니터링 후 실제 사용 패턴 확인
SELECT DBMS_STATS.REPORT_COL_USAGE(USER, 'F_SALES') AS usage_report FROM dual;

-- 선택적 히스토그램 수집 (실제 사용 패턴 기반)
BEGIN
  -- 금액 컬럼에 히스토그램 (대규모 거래 검출용)
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname          => USER,
    tabname          => 'F_SALES',
    partname         => 'P202401',  -- 특정 파티션만
    method_opt       => 'FOR COLUMNS SIZE 254 AMOUNT, FOR ALL COLUMNS SIZE 1',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    cascade          => TRUE
  );
END;
/

-- 히스토그램 정보 확인
SELECT table_name, column_name, histogram, num_distinct, num_buckets
FROM user_tab_col_statistics
WHERE table_name = 'F_SALES'
AND histogram != 'NONE';
```

### 3. 파티션 테이블 통계 관리

대용량 파티션 테이블은 증분 통계를 활용합니다:

```sql
-- 월별 파티션 교체 시나리오
-- 1. 스테이징 테이블 생성 및 데이터 로드
CREATE TABLE F_SALES_STAGE 
AS SELECT * FROM F_SALES WHERE 1=0;

-- 2. 새 월 데이터 로드 (시뮬레이션)
INSERT INTO F_SALES_STAGE
SELECT 
  (SELECT MAX(sales_id) FROM F_SALES) + ROWNUM,
  MOD(ROWNUM, 50000) + 1,
  MOD(ROWNUM, 20000) + 1,
  DATE '2024-04-01' + MOD(ROWNUM, 30),
  1 + MOD(ROWNUM, 5),
  ROUND(DBMS_RANDOM.VALUE(10, 500), 2)
FROM dual
CONNECT BY LEVEL <= 150000;

-- 3. 스테이징 테이블 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname          => USER,
    tabname          => 'F_SALES_STAGE',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE 1',
    cascade          => TRUE
  );
END;
/

-- 4. 파티션 추가 (실제 운영환경에서는 EXCHANGE PARTITION 사용)
ALTER TABLE F_SALES 
ADD PARTITION P202404 
VALUES LESS THAN (DATE '2024-05-01');

-- 5. 데이터 이동
INSERT INTO F_SALES PARTITION (P202404)
SELECT * FROM F_SALES_STAGE;

-- 6. 새 파티션 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname          => USER,
    tabname          => 'F_SALES',
    partname         => 'P202404',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE 1',
    cascade          => TRUE
  );
END;
/

-- 글로벌 통계 자동 갱신 확인
SELECT partition_name, num_rows, last_analyzed,
       global_stats, user_stats
FROM user_tab_partitions
WHERE table_name = 'F_SALES'
ORDER BY partition_position;
```

### 4. 샘플링 전략

데이터 크기와 정확도 요구사항에 따른 샘플링 전략:

```sql
-- 다양한 샘플링 전략 비교
DECLARE
  PROCEDURE gather_with_sampling(p_percent NUMBER) IS
  BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(
      ownname          => USER,
      tabname          => 'D_PRODUCT',
      estimate_percent => p_percent,
      method_opt       => 'FOR ALL COLUMNS SIZE 1',
      cascade          => TRUE
    );
    
    DBMS_OUTPUT.PUT_LINE('Sampling ' || p_percent || '% complete');
  END;
BEGIN
  -- 1. AUTO 샘플링 (권장)
  gather_with_sampling(DBMS_STATS.AUTO_SAMPLE_SIZE);
  
  -- 2. 낮은 샘플링 (빠름, 정확도 낮음)
  gather_with_sampling(5);
  
  -- 3. 높은 샘플링 (느림, 정확도 높음)
  gather_with_sampling(30);
  
  -- 4. 전체 샘플링 (매우 느림, 가장 정확)
  gather_with_sampling(100);
END;
/

-- 샘플링 효과 비교 쿼리
SELECT 'AUTO' as sampling_type, num_rows, blocks, sample_size
FROM user_tables WHERE table_name = 'D_PRODUCT'
UNION ALL
SELECT '5%' as sampling_type, num_rows, blocks, sample_size
FROM user_tables WHERE table_name = 'D_PRODUCT';
```

### 5. Pending 통계를 활용한 안전한 배포

```sql
-- Pending 통계 활성화
ALTER SESSION SET optimizer_use_pending_statistics = TRUE;

-- Pending 통계로 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname          => USER,
    tabname          => 'F_SALES',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE AUTO',
    cascade          => TRUE,
    no_invalidate    => FALSE
  );
END;
/

-- Pending 통계로 테스트 쿼리 실행
EXPLAIN PLAN FOR
SELECT p.category, SUM(s.amount) as total_sales
FROM F_SALES s
JOIN D_PRODUCT p ON p.prod_id = s.prod_id
WHERE s.sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
GROUP BY p.category;

-- 실행 계획 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 성능 비교
SET TIMING ON
SELECT p.category, SUM(s.amount) as total_sales
FROM F_SALES s
JOIN D_PRODUCT p ON p.prod_id = s.prod_id
WHERE s.sales_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31'
GROUP BY p.category;
SET TIMING OFF

-- 문제 없으면 통계 게시
BEGIN
  DBMS_STATS.PUBLISH_PENDING_STATS(
    ownname => USER,
    tabname => 'F_SALES'
  );
END;
/

-- Pending 통계 비활성화
ALTER SESSION SET optimizer_use_pending_statistics = FALSE;
```

## 운영 자동화 스크립트

### 일일 통계 수집 작업

```sql
-- 통계 수집 작업 생성
BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name        => 'DAILY_STATS_COLLECTION',
    job_type        => 'PLSQL_BLOCK',
    job_action      => '
    DECLARE
      v_start_time TIMESTAMP := SYSTIMESTAMP;
    BEGIN
      -- 변경 모니터링 정보 Flush
      DBMS_STATS.FLUSH_DATABASE_MONITORING_INFO;
      
      -- Stale 상태인 테이블만 수집
      DBMS_STATS.GATHER_SCHEMA_STATS(
        ownname          => USER,
        options          => ''GATHER STALE'',
        estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
        method_opt       => ''FOR ALL COLUMNS SIZE AUTO'',
        cascade          => TRUE,
        degree           => DBMS_STATS.AUTO_DEGREE
      );
      
      -- 로깅
      INSERT INTO stats_collection_log (
        collection_time, duration_seconds, 
        tables_collected, status
      ) VALUES (
        SYSTIMESTAMP, 
        EXTRACT(SECOND FROM (SYSTIMESTAMP - v_start_time)),
        SQL%ROWCOUNT, ''SUCCESS''
      );
      
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        INSERT INTO stats_collection_log (
          collection_time, duration_seconds, 
          tables_collected, status, error_message
        ) VALUES (
          SYSTIMESTAMP, 
          EXTRACT(SECOND FROM (SYSTIMESTAMP - v_start_time)),
          0, ''ERROR'', SQLERRM
        );
        COMMIT;
        RAISE;
    END;',
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY; BYHOUR=2; BYMINUTE=0',
    enabled         => TRUE
  );
END;
/

-- 통계 수집 로그 테이블
CREATE TABLE stats_collection_log (
  log_id            NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  collection_time   TIMESTAMP NOT NULL,
  duration_seconds  NUMBER NOT NULL,
  tables_collected  NUMBER NOT NULL,
  status            VARCHAR2(20) NOT NULL,
  error_message     VARCHAR2(4000)
);
```

### 주간 정밀 통계 수집

```sql
BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name        => 'WEEKLY_DETAILED_STATS',
    job_type        => 'PLSQL_BLOCK',
    job_action      => '
    BEGIN
      -- 핵심 테이블 정밀 히스토그램 수집
      DBMS_STATS.GATHER_TABLE_STATS(
        ownname          => USER,
        tabname          => ''D_PRODUCT'',
        estimate_percent => 30,  -- 높은 샘플링
        method_opt       => ''FOR COLUMNS SIZE 254 BRAND CATEGORY, FOR ALL COLUMNS SIZE 1'',
        cascade          => TRUE
      );
      
      -- 팩트 테이블 상세 통계
      DBMS_STATS.GATHER_TABLE_STATS(
        ownname          => USER,
        tabname          => ''F_SALES'',
        estimate_percent => 20,
        method_opt       => ''FOR COLUMNS SIZE 254 AMOUNT, FOR ALL COLUMNS SIZE 1'',
        cascade          => TRUE,
        granularity      => ''ALL''
      );
    END;',
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=WEEKLY; BYDAY=SUN; BYHOUR=3',
    enabled         => TRUE
  );
END;
/
```

## 모니터링과 문제 진단

### 통계 현황 모니터링

```sql
-- 통계 수집 현황 리포트
WITH table_stats AS (
  SELECT 
    t.table_name,
    t.num_rows,
    t.blocks,
    t.last_analyzed,
    CASE 
      WHEN t.stale_stats = 'YES' THEN 'STALE'
      ELSE 'FRESH'
    END as stats_status,
    (SELECT COUNT(*) FROM user_tab_col_statistics c 
     WHERE c.table_name = t.table_name AND c.histogram != 'NONE') as hist_count
  FROM user_tables t
  WHERE t.table_name IN ('D_CUSTOMER', 'D_PRODUCT', 'F_SALES')
),
partition_stats AS (
  SELECT 
    table_name,
    COUNT(*) as partition_count,
    SUM(num_rows) as total_rows,
    MAX(last_analyzed) as latest_analyzed
  FROM user_tab_partitions
  GROUP BY table_name
)
SELECT 
  s.table_name,
  s.num_rows,
  s.blocks,
  s.last_analyzed,
  s.stats_status,
  s.hist_count,
  p.partition_count,
  p.total_rows as partitioned_rows
FROM table_stats s
LEFT JOIN partition_stats p ON p.table_name = s.table_name
ORDER BY s.table_name;
```

### 통계 변경 영향 분석

```sql
-- 통계 변경 전후 비교
CREATE TABLE stats_snapshot AS
SELECT table_name, num_rows, blocks, last_analyzed
FROM user_tables
WHERE table_name IN ('D_CUSTOMER', 'D_PRODUCT', 'F_SALES');

-- 통계 수집 후
SELECT 
  s.table_name,
  s.num_rows as old_rows,
  t.num_rows as new_rows,
  ROUND(ABS(t.num_rows - s.num_rows) / NULLIF(s.num_rows, 0) * 100, 2) as change_pct,
  s.blocks as old_blocks,
  t.blocks as new_blocks
FROM stats_snapshot s
JOIN user_tables t ON t.table_name = s.table_name
WHERE ABS(t.num_rows - s.num_rows) / NULLIF(s.num_rows, 0) > 0.1;  -- 10% 이상 변화
```

### 실행 계획 비교 도구

```sql
-- 통계 변경 전후 실행 계획 비교
CREATE TABLE plan_comparison (
  test_id      NUMBER,
  sql_text     CLOB,
  plan_table   CLOB,
  stats_source VARCHAR2(20),  -- 'BEFORE' or 'AFTER'
  created_time TIMESTAMP
);

-- 통계 변경 전 실행 계획 저장
INSERT INTO plan_comparison VALUES (
  1,
  'SELECT p.category, SUM(s.amount) FROM F_SALES s JOIN D_PRODUCT p ON p.prod_id = s.prod_id WHERE s.sales_dt BETWEEN DATE ''2024-03-01'' AND DATE ''2024-03-31'' GROUP BY p.category',
  NULL,
  'BEFORE',
  SYSTIMESTAMP
);
COMMIT;

-- 통계 수집 후 실행 계획 저장
INSERT INTO plan_comparison VALUES (
  1,
  'SELECT p.category, SUM(s.amount) FROM F_SALES s JOIN D_PRODUCT p ON p.prod_id = s.prod_id WHERE s.sales_dt BETWEEN DATE ''2024-03-01'' AND DATE ''2024-03-31'' GROUP BY p.category',
  NULL,
  'AFTER',
  SYSTIMESTAMP
);
COMMIT;

-- 실행 계획 비교 분석
SELECT 
  stats_source,
  SUBSTR(sql_text, 1, 100) as sql_snippet,
  created_time
FROM plan_comparison
WHERE test_id = 1
ORDER BY created_time;
```

## 확장 통계와 고급 기법

### 컬럼 그룹 통계

```sql
-- 확장 통계 생성 (상관 관계 있는 컬럼들)
BEGIN
  -- 1. 확장 통계 생성
  DBMS_STATS.CREATE_EXTENDED_STATS(
    ownname => USER,
    tabname => 'D_CUSTOMER',
    extension => '(REGION, TIER)'  -- 지역과 등급의 조합
  );
  
  -- 2. 확장 통계 수집
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'D_CUSTOMER',
    method_opt => 'FOR ALL COLUMNS SIZE AUTO',
    cascade    => TRUE
  );
END;
/

-- 확장 통계 정보 확인
SELECT extension_name, extension
FROM user_stat_extensions
WHERE table_name = 'D_CUSTOMER';
```

### 표현식 통계

```sql
-- 표현식 기반 통계 생성
BEGIN
  -- 월별 판매액 합계에 대한 통계
  DBMS_STATS.CREATE_EXTENDED_STATS(
    ownname => USER,
    tabname => 'F_SALES',
    extension => '(EXTRACT(YEAR FROM SALES_DT), EXTRACT(MONTH FROM SALES_DT))'
  );
  
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'F_SALES',
    method_opt => 'FOR ALL COLUMNS SIZE AUTO',
    cascade    => TRUE
  );
END;
/
```

## 통계 백업과 복구

### 통계 백업

```sql
-- 통계 백업 테이블 생성
BEGIN
  DBMS_STATS.CREATE_STAT_TABLE(
    ownname => USER,
    stattab => 'STATS_BACKUP',
    tblspace => NULL
  );
END;
/

-- 통계 백업
BEGIN
  DBMS_STATS.EXPORT_SCHEMA_STATS(
    ownname => USER,
    stattab => 'STATS_BACKUP',
    statid  => 'BACKUP_' || TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MI')
  );
END;
/

-- 특정 테이블 통계 백업
BEGIN
  DBMS_STATS.EXPORT_TABLE_STATS(
    ownname => USER,
    tabname => 'F_SALES',
    stattab => 'STATS_BACKUP',
    statid  => 'F_SALES_BACKUP'
  );
END;
/
```

### 통계 복구

```sql
-- 통계 복구 (문제 발생 시)
BEGIN
  DBMS_STATS.IMPORT_TABLE_STATS(
    ownname => USER,
    tabname => 'F_SALES',
    stattab => 'STATS_BACKUP',
    statid  => 'F_SALES_BACKUP',
    no_invalidate => TRUE
  );
END;
/

-- 특정 시점 통계 복구
BEGIN
  DBMS_STATS.RESTORE_TABLE_STATS(
    ownname => USER,
    tabname => 'F_SALES',
    as_of_timestamp => SYSTIMESTAMP - INTERVAL '1' HOUR,
    no_invalidate => TRUE
  );
END;
/
```

## 성능 모니터링과 튜닝

### 통계 품질 모니터링

```sql
-- 통계 품질 분석 리포트
SELECT 
  t.table_name,
  t.num_rows as estimated_rows,
  (SELECT COUNT(*) FROM user_tables WHERE table_name = t.table_name) as actual_rows_count,
  ROUND(ABS(t.num_rows - (SELECT COUNT(*) FROM user_tables WHERE table_name = t.table_name)) / 
        NULLIF(t.num_rows, 0) * 100, 2) as estimation_error_pct,
  t.last_analyzed,
  t.stale_stats
FROM user_tables t
WHERE t.table_name IN ('D_CUSTOMER', 'D_PRODUCT', 'F_SALES')
ORDER BY estimation_error_pct DESC NULLS LAST;
```

### 카디널리티 추정 정확도 분석

```sql
-- 실제 행 수 vs 예상 행 수 비교
WITH query_stats AS (
  SELECT 
    sql_id,
    child_number,
    plan_hash_value,
    executions,
    buffer_gets,
    disk_reads,
    rows_processed
  FROM v$sql
  WHERE sql_text LIKE '%F_SALES%'
  AND last_active_time > SYSDATE - 1
),
plan_stats AS (
  SELECT 
    s.sql_id,
    s.child_number,
    p.object_name,
    p.cardinality as estimated_rows,
    p.last_output_rows as actual_rows,
    ABS(p.cardinality - p.last_output_rows) / 
      NULLIF(GREATEST(p.cardinality, p.last_output_rows), 0) * 100 as error_pct
  FROM v$sql_plan_statistics_all p
  JOIN query_stats s ON s.sql_id = p.sql_id 
                     AND s.child_number = p.child_number
  WHERE p.operation = 'TABLE ACCESS'
  AND p.options IN ('FULL', 'BY INDEX ROWID')
)
SELECT 
  object_name,
  AVG(estimated_rows) as avg_estimated,
  AVG(actual_rows) as avg_actual,
  AVG(error_pct) as avg_error_pct,
  COUNT(*) as sample_count
FROM plan_stats
GROUP BY object_name
ORDER BY avg_error_pct DESC;
```

## 결론

효과적인 통계 관리는 Oracle 데이터베이스 성능 최적화의 핵심 요소입니다. 전략적인 통계 수집 정책을 통해 다음과 같은 이점을 얻을 수 있습니다:

### 핵심 성공 요인

1. **변화 기반 관리**: STALE_PERCENT를 활용하여 변경된 데이터에 대해서만 통계를 수집함으로써 불필요한 오버헤드를 줄입니다.

2. **파티션 테이블 최적화**: 증분 통계를 활용하여 대용량 파티션 테이블의 통계 관리를 효율화합니다.

3. **선택적 히스토그램**: 실제 쿼리 패턴을 분석하여 필요한 컬럼에만 히스토그램을 적용합니다.

4. **안전한 배포**: Pending 통계를 통해 테스트 후 프로덕션에 배포하는 안전한 방식을 채택합니다.

5. **체계적인 모니터링**: 통계 품질과 실행 계획 정확도를 지속적으로 모니터링합니다.

### 실무 적용 가이드라인

1. **일상적 관리**: 일일 자동화 작업으로 변경된 테이블에 대한 기본 통계를 유지합니다.

2. **주간 정밀 분석**: 주말에 상세한 히스토그램과 샘플링을 적용하여 통계 정확도를 높입니다.

3. **사전 테스트**: 모든 주요 통계 변경 전 Pending 통계로 테스트하여 성능 영향을 평가합니다.

4. **백업과 복구**: 정기적인 통계 백업과 문제 발생 시 신속한 복구 체계를 마련합니다.

5. **지속적 개선**: 실행 계획의 예상/실제 행 수 차이를 분석하여 통계 정확도를 지속적으로 개선합니다.

통계 관리는 단순한 유지보수 작업이 아니라 데이터베이스 성능을 결정하는 전략적 활동입니다. 비즈니스 요구사항, 데이터 특성, 시스템 리소스를 고려한 맞춤형 전략이 장기적인 성능 안정성과 효율성을 보장합니다.