---
layout: post
title: MFC - 서브클래싱, 메시지 훅으로 레거시 컨트롤 개선
date: 2025-09-11 23:25:23 +0900
category: MFC
---
# 서브클래싱 / 메시지 훅으로 레거시 컨트롤 개선 — MFC/Win32 완전 가이드

**대상**: MFC·Win32 기반 앱에서 **기존(레거시) 컨트롤**의 기능/UX를 손대지 않고 **확장/수정**하고 싶은 팀  
**핵심 키워드**: `SubclassDlgItem`, `SetWindowSubclass`, `SetWindowLongPtr(GWLP_WNDPROC)`, `WH_GETMESSAGE`, `WH_CALLWNDPROC`, `WH_CBT`, `CBTProc`, `ComCtl6`, `WM_NCDESTROY`, `DefSubclassProc`

---

## 0) 왜 서브클래싱(Subclassing)과 메시지 훅인가?

- **레거시 바이너리/서드파티 컨트롤**의 **소스 수정을 못 할 때**, 메시지 경로를 가로채 **동작을 추가/수정**한다.
- 화면 교체 없이 **UX 개선**, **호환성 수정**, **접근성**/**IME**/**DPI** 문제 해결에 강력.
- **스레드/수명/재진입**에 주의하면 **안정적**이며, 기존 코드에 **침습 최소**.

> 원칙: **가능하면 로컬(해당 윈도우/스레드)만** 가로채고, **해제(언후킹)** 를 명확히 한다.

---

## 1) 용어/방식 한 장 정리

| 기법 | 핵심 API | 장점 | 주의 |
|---|---|---|---|
| **MFC 서브클래싱** | `SubclassDlgItem`, `SubclassWindow` | 간단, 메시지 맵 사용 | 컨트롤 핸들 고정 전제 |
| **Old-school WndProc 교체** | `SetWindowLongPtr(GWLP_WNDPROC)` | 공용, 의존 최소 | 복수 서브클래스 충돌·해제 타이밍 주의 |
| **ComCtl Subclass** | `SetWindowSubclass/DefSubclassProc` | 안전(중첩 가능), 정석 | `comctl32 v5+/6` 필요 |
| **메시지 훅(후킹)** | `SetWindowsHookEx(WH_*)` | **코드 수정 없이** 광역 적용 | 시스템/전역 훅은 DLL/권한/안전성 이슈 |
| **대화상자 Hook(공용파일/컬러 등)** | `OPENFILENAME hook`, etc. | 공용 대화상자 커스터마이즈 | 구조/스타일 한정됨 |

**권장 우선순위**  
1) `SetWindowSubclass` (가능하면)  
2) MFC `SubclassDlgItem` (내 코드의 다이얼로그/뷰 안)  
3) `SetWindowsHookEx` (스레드-로컬)  
4) 시스템 전역 훅(극히 예외적)

---

## 2) 베이스라인: MFC SubclassDlgItem로 “가벼운 확장”

### 2-1. 예: `CEdit`에 플레이스홀더 + Select-All-on-Focus

```cpp
// EditEx.h
class CEditEx : public CEdit {
public:
    void SetCue(LPCWSTR text) { m_cue = text ? text : L""; UpdateCue(); }
protected:
    CString m_cue;
    void UpdateCue() {
        // Vista+ EM_SETCUEBANNER (없으면 WM_PAINT로 직접 그리기)
        SendMessageW(EM_SETCUEBANNER, TRUE, (LPARAM)m_cue.GetString());
    }
    afx_msg void OnSetFocus(CWnd* pOldWnd) {
        CEdit::OnSetFocus(pOldWnd);
        // 지연 SelectAll: IME 포커스/마우스 업 충돌 회피
        PostMessageW(WM_APP + 100);
    }
    afx_msg LRESULT OnPostSelectAll(WPARAM, LPARAM) {
        SetSel(0, -1);
        return 0;
    }
    afx_msg void OnChange() {
        // 길이 제한/실시간 유효성의 "가벼운" 처리만
        CString s; GetWindowText(s);
        if (s.GetLength() > 50) {
            s = s.Left(50); SetWindowText(s); SetSel(50, 50);
        }
    }
    DECLARE_MESSAGE_MAP()
};

// EditEx.cpp
BEGIN_MESSAGE_MAP(CEditEx, CEdit)
    ON_WM_SETFOCUS()
    ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
    ON_MESSAGE(WM_APP + 100, OnPostSelectAll)
END_MESSAGE_MAP()
```

```cpp
// 다이얼로그에서 사용
BOOL CMyDlg::OnInitDialog() {
    CDialogEx::OnInitDialog();
    m_editName.SubclassDlgItem(IDC_EDIT_NAME, this);
    m_editName.SetCue(L"이름을 입력하세요");
    return TRUE;
}
```

> **Tip**: `ON_CONTROL_REFLECT`로 **컨트롤 자신**에게 통지를 반사하면 부모와의 결합 감소.

---

## 3) 정석: `SetWindowSubclass` (중첩/해제 안전)

**장점**  
- 서로 다른 모듈이 **동일 윈도우를 여러 번 서브클래싱**해도 안전(체인).  
- `WM_NCDESTROY` 시 **자동 해제**.  
- `DefSubclassProc`로 체인 호출.

### 3-1. 공통 헬퍼

```cpp
// SubclassHelpers.h
#pragma once
#include <commctrl.h> // SetWindowSubclass, DefSubclassProc
#pragma comment(lib, "comctl32.lib")

struct EditSubclassData {
    std::wstring cue;
    bool selectAllOnFocus = true;
};

inline LRESULT CALLBACK EditSubclassProc(HWND hWnd, UINT msg, WPARAM w, LPARAM l,
                                         UINT_PTR id, DWORD_PTR refData) {
    auto* data = reinterpret_cast<EditSubclassData*>(refData);
    switch (msg) {
    case WM_SETFOCUS:
        if (data->selectAllOnFocus) PostMessageW(hWnd, WM_APP + 1, 0, 0);
        break;
    case WM_APP + 1:
        SendMessageW(hWnd, EM_SETSEL, 0, -1); // SelectAll
        break;
    case WM_NCDESTROY:
        RemoveWindowSubclass(hWnd, EditSubclassProc, id);
        delete data;
        break;
    }
    return DefSubclassProc(hWnd, msg, w, l);
}

inline void SubclassEdit(HWND hEdit, std::wstring cueText) {
    auto* data = new EditSubclassData{};
    data->cue = std::move(cueText);
    SendMessageW(hEdit, EM_SETCUEBANNER, TRUE, (LPARAM)data->cue.c_str());
    SetWindowSubclass(hEdit, EditSubclassProc, 0xED17 /*unique*/, (DWORD_PTR)data);
}
```

```cpp
// 사용: 컨트롤 핸들만 있으면 모듈 경계 넘어도 적용 가능
SubclassEdit(GetDlgItem(m_hWnd, IDC_EDIT_NAME), L"이름을 입력");
```

> **주의**: `RemoveWindowSubclass`는 보통 **`WM_NCDESTROY`에서** 호출. 직접 해제 시점이 필요하면 호출자에서 별도로 관리.

---

## 4) Old-school: `SetWindowLongPtr(GWLP_WNDPROC)` 직접 교체

- 가장 단순한 **고전 서브클래싱**.  
- **단점**: 여러 모듈이 서로 덮어쓰면 충돌, 해제 순서 꼬이면 크래시.

```cpp
struct ClassicSubclass {
    WNDPROC oldProc{};
    static LRESULT CALLBACK Proc(HWND h, UINT m, WPARAM w, LPARAM l) {
        auto* self = (ClassicSubclass*)GetPropW(h, L"ClassicSubclass");
        if (m == WM_NCDESTROY) {
            SetWindowLongPtrW(h, GWLP_WNDPROC, (LONG_PTR)self->oldProc);
            RemovePropW(h, L"ClassicSubclass");
            delete self;
        }
        // 원하는 메시지 처리…
        return CallWindowProcW(self->oldProc, h, m, w, l);
    }
};

void SubclassClassic(HWND h) {
    auto* s = new ClassicSubclass{};
    s->oldProc = (WNDPROC)SetWindowLongPtrW(h, GWLP_WNDPROC, (LONG_PTR)ClassicSubclass::Proc);
    SetPropW(h, L"ClassicSubclass", (HANDLE)s);
}
```

**가능하면** `SetWindowSubclass` 사용을 권장.

---

## 5) 메시지 훅: 컨트롤 소스 수정 없이 **광역 개선**

### 5-1. 스레드-로컬 훅(권장)

- 동일 프로세스/현재 UI 스레드의 메시지 흐름을 한곳에서 관찰/수정.  
- 적용 예: **모든 `EDIT`에 공통 플레이스홀더/IME 정책/휠 동작 보정**.

```cpp
// Hooks.h
struct ThreadHooks {
    HHOOK hGetMsg = nullptr;
    HHOOK hCallWnd = nullptr;
};

LRESULT CALLBACK GetMsgProc(int code, WPARAM wParam, LPARAM lParam) {
    if (code >= 0) {
        MSG* pMsg = reinterpret_cast<MSG*>(lParam);
        if (pMsg->message == WM_MOUSEWHEEL) {
            HWND h = pMsg->hwnd;
            // 리스트박스 휠 가속 보정(예시): delta 축소
            int delta = GET_WHEEL_DELTA_WPARAM(pMsg->wParam);
            pMsg->wParam = MAKEWPARAM(GET_KEYSTATE_WPARAM(pMsg->wParam), delta/2);
        }
    }
    return CallNextHookEx(nullptr, code, wParam, lParam);
}

LRESULT CALLBACK CallWndProc(int code, WPARAM wParam, LPARAM lParam) {
    if (code >= 0) {
        auto* p = reinterpret_cast<CWPSTRUCT*>(lParam);
        if (p->message == WM_CREATE) {
            wchar_t cls[32]{};
            GetClassNameW(p->hwnd, cls, 32);
            if (_wcsicmp(cls, L"Edit") == 0) {
                // 새로 만들어지는 모든 Edit에 서브클래스 자동 적용
                SubclassEdit(p->hwnd, L"입력");
            }
        }
    }
    return CallNextHookEx(nullptr, code, wParam, lParam);
}

inline void InstallThreadHooks(ThreadHooks& th) {
    DWORD tid = GetCurrentThreadId();
    th.hGetMsg  = SetWindowsHookExW(WH_GETMESSAGE,  GetMsgProc,  nullptr, tid);
    th.hCallWnd = SetWindowsHookExW(WH_CALLWNDPROC, CallWndProc, nullptr, tid);
}

inline void UninstallThreadHooks(ThreadHooks& th) {
    if (th.hGetMsg)  { UnhookWindowsHookEx(th.hGetMsg);  th.hGetMsg = nullptr; }
    if (th.hCallWnd) { UnhookWindowsHookEx(th.hCallWnd); th.hCallWnd = nullptr; }
}
```

```cpp
// 예: MFC App에서 UI 스레드에 설치
ThreadHooks g_hooks;
BOOL CMyApp::InitInstance() {
    CWinApp::InitInstance();
    InstallThreadHooks(g_hooks);
    return TRUE;
}
int CMyApp::ExitInstance() {
    UninstallThreadHooks(g_hooks);
    return CWinApp::ExitInstance();
}
```

> **장점**: **폼 코드를 건드리지 않고** 공통 정책을 한 번에 적용.  
> **주의**: 훅 프로시저는 **가벼워야** 하며, **재진입/교착** 주의.

### 5-2. CBT 훅(생성 시점 개입)

**WH_CBT**로 **창 생성/활성/포커스** 이벤트를 조기에 가로채 스타일 보정/서브클래스.

```cpp
HHOOK g_hCbt{};
LRESULT CALLBACK CbtProc(int nCode, WPARAM w, LPARAM l) {
    if (nCode == HCBT_CREATEWND) {
        HWND h = (HWND)w;
        wchar_t cls[32]; GetClassNameW(h, cls, 32);
        if (_wcsicmp(cls, L"ComboBox") == 0) {
            // 드롭다운 길이 보정
            auto* pcw = reinterpret_cast<LPCBT_CREATEWNDW>(l);
            auto* cs  = pcw->lpcs;
            cs->cy = max(cs->cy, 200);
        }
    }
    return CallNextHookEx(g_hCbt, nCode, w, l);
}
```

> **팁**: CBT는 생성 직전/직후를 잡아 **스타일/크기 교정**에 최적.

### 5-3. 전역 훅(가급적 지양)

- 모든 프로세스에 주입하려면 **DLL** 필요, **서명/호환/안정성** 이슈 큼.  
- 진짜 필요할 때(회사 공용 **보조 접근성 도구** 등)만.

---

## 6) 실전 패턴 모음

### 6-1. 에디트: “숫자만 + 천단위 + IME Off on focus”

```cpp
// 숫자 전용 에디트 서브클래스
struct NumberEditData {
    bool thousandSep = true;
    bool imeOffOnFocus = true;
};

LRESULT CALLBACK NumberEditProc(HWND h, UINT m, WPARAM w, LPARAM l,
                                UINT_PTR id, DWORD_PTR ref) {
    auto* d = (NumberEditData*)ref;
    switch (m) {
    case WM_SETFOCUS:
        if (d->imeOffOnFocus) {
            HIMC imc = ImmGetContext(h);
            if (imc) { ImmSetOpenStatus(imc, FALSE); ImmReleaseContext(h, imc); }
        }
        break;
    case WM_CHAR:
        if (!(iswdigit((wchar_t)w) || w == VK_BACK)) {
            MessageBeep(MB_ICONWARNING);
            return 0; // 차단
        }
        break;
    case WM_KILLFOCUS:
        if (d->thousandSep) {
            wchar_t buf[128]; GetWindowTextW(h, buf, 128);
            // 단순 포맷(실무는 엣지 케이스 보강)
            long long v = _wtoll(buf);
            wchar_t out[128]; swprintf_s(out, L"%,lld", v);
            SetWindowTextW(h, out);
        }
        break;
    case WM_NCDESTROY:
        RemoveWindowSubclass(h, NumberEditProc, id);
        delete d;
        break;
    }
    return DefSubclassProc(h, m, w, l);
}

void SubclassNumberEdit(HWND h) {
    auto* d = new NumberEditData{};
    SetWindowSubclass(h, NumberEditProc, 0xNUMB, (DWORD_PTR)d);
}
```

### 6-2. 리스트박스: 마우스 휠 가속 + Auto-Scroll Into View

```cpp
LRESULT CALLBACK ListboxProc(HWND h, UINT m, WPARAM w, LPARAM l, UINT_PTR id, DWORD_PTR ref) {
    switch (m) {
    case WM_MOUSEWHEEL: {
        int delta = GET_WHEEL_DELTA_WPARAM(w);
        int steps = max(1, abs(delta) / WHEEL_DELTA) * 3; // 가속
        int top = (int)SendMessageW(h, LB_GETTOPINDEX, 0, 0);
        top += (delta < 0) ? steps : -steps;
        top = max(0, top);
        SendMessageW(h, LB_SETTOPINDEX, top, 0);
        return 0; }
    case LB_SETCURSEL: // 선택 바뀌면 보이도록
        {
            LRESULT r = DefSubclassProc(h, m, w, l);
            int cur = (int)SendMessageW(h, LB_GETCURSEL, 0, 0);
            SendMessageW(h, LB_SETTOPINDEX, cur, 0);
            return r;
        }
    case WM_NCDESTROY:
        RemoveWindowSubclass(h, ListboxProc, id);
        break;
    }
    return DefSubclassProc(h, m, w, l);
}

void SubclassListbox(HWND h) {
    SetWindowSubclass(h, ListboxProc, 0xLBX1, 0);
}
```

### 6-3. 콤보: 드롭다운 폭 자동 확장(아이템 가장 긴 문자열 기준)

```cpp
void AutoWidthComboDropDown(HWND hCombo) {
    HDC hdc = GetDC(hCombo);
    HFONT hFont = (HFONT)SendMessageW(hCombo, WM_GETFONT, 0, 0);
    HFONT hOld = (HFONT)SelectObject(hdc, hFont);
    int count = (int)SendMessageW(hCombo, CB_GETCOUNT, 0, 0);
    int maxw = 0;
    for (int i=0; i<count; ++i) {
        wchar_t buf[256]; SendMessageW(hCombo, CB_GETLBTEXT, i, (LPARAM)buf);
        SIZE sz{}; GetTextExtentPoint32W(hdc, buf, (int)wcslen(buf), &sz);
        maxw = max(maxw, sz.cx);
    }
    SelectObject(hdc, hOld); ReleaseDC(hCombo, hdc);
    RECT rc; GetWindowRect(hCombo, &rc);
    // 여유 + 스크롤바/마진 보정
    int newW = max((int)(rc.right - rc.left), maxw + 40);
    SetWindowPos(hCombo, nullptr, 0,0, newW, rc.bottom-rc.top, SWP_NOMOVE|SWP_NOZORDER);
}

LRESULT CALLBACK ComboProc(HWND h, UINT m, WPARAM w, LPARAM l, UINT_PTR id, DWORD_PTR) {
    if (m == CB_SHOWDROPDOWN && w) {
        AutoWidthComboDropDown(h);
    } else if (m == WM_NCDESTROY) {
        RemoveWindowSubclass(h, ComboProc, id);
    }
    return DefSubclassProc(h, m, w, l);
}
void SubclassCombo(HWND h) { SetWindowSubclass(h, ComboProc, 0xC0M1, 0); }
```

### 6-4. 툴팁 없는 컨트롤에 **풍선 도움말**(마우스 hover)

```cpp
struct HoverTipData {
    HWND hTip{};
    std::wstring text;
};

LRESULT CALLBACK HoverTipProc(HWND h, UINT m, WPARAM w, LPARAM l, UINT_PTR id, DWORD_PTR ref) {
    auto* d = (HoverTipData*)ref;
    switch (m) {
    case WM_MOUSEMOVE:
        TRACKMOUSEEVENT tme{ sizeof(tme), TME_LEAVE, h, 0 };
        TrackMouseEvent(&tme);
        if (!d->hTip) {
            d->hTip = CreateWindowExW(WS_EX_TOPMOST, TOOLTIPS_CLASS, nullptr,
                                      WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                                      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, h, nullptr, GetModuleHandleW(nullptr), 0);
            SetWindowPos(d->hTip, HWND_TOPMOST, 0, 0, 0, 0,
                         SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);
            TOOLINFOW ti{ sizeof(ti), TTF_SUBCLASS, h, 1 };
            GetClientRect(h, &ti.rect);
            ti.hinst = GetModuleHandleW(nullptr);
            ti.lpszText = const_cast<LPWSTR>(d->text.c_str());
            SendMessageW(d->hTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
        }
        break;
    case WM_MOUSELEAVE:
        if (d->hTip) { DestroyWindow(d->hTip); d->hTip = nullptr; }
        break;
    case WM_NCDESTROY:
        if (d->hTip) DestroyWindow(d->hTip);
        RemoveWindowSubclass(h, HoverTipProc, id);
        delete d;
        break;
    }
    return DefSubclassProc(h, m, w, l);
}
void SubclassHoverTip(HWND h, std::wstring tip) {
    auto* d = new HoverTipData{}; d->text = std::move(tip);
    SetWindowSubclass(h, HoverTipProc, 0xH0V1, (DWORD_PTR)d);
}
```

### 6-5. DPI/폰트 자동 스케일

```cpp
LRESULT CALLBACK DpiAwareProc(HWND h, UINT m, WPARAM w, LPARAM l, UINT_PTR id, DWORD_PTR) {
    static int lastDpi = 96;
    if (m == WM_DPICHANGED) {
        int dpi = HIWORD(w);
        if (dpi != lastDpi) {
            lastDpi = dpi;
            // 폰트 리스케일
            LOGFONTW lf{}; SystemParametersInfoW(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, 0);
            lf.lfHeight = -MulDiv(9, dpi, 72); // 9pt
            HFONT hf = CreateFontIndirectW(&lf);
            SendMessageW(h, WM_SETFONT, (WPARAM)hf, TRUE);
        }
    } else if (m == WM_NCDESTROY) {
        RemoveWindowSubclass(h, DpiAwareProc, id);
    }
    return DefSubclassProc(h, m, w, l);
}
void SubclassDpiAware(HWND h) { SetWindowSubclass(h, DpiAwareProc, 0xDPI1, 0); }
```

---

## 7) 공용 대화상자(파일 열기 등) 커스터마이즈

- **Explorer 스타일**(OFN_EXPLORER)에서 `OFN_ENABLEHOOK` + HookProc → 내부 컨트롤 핸들 획득 후 **SetWindowSubclass**.

```cpp
UINT_PTR CALLBACK FileOpenHook(HWND hDlg, UINT msg, WPARAM w, LPARAM l) {
    if (msg == WM_INITDIALOG) {
        // 예: "파일 이름" 에디트에 큐 배너
        HWND hEdit = GetDlgItem(GetParent(hDlg), 0x480); // 탐색기 파일 대화상자의 "File name:" ID(버전에 따라 다를 수 있음; FindWindowEx 패턴 권장)
        if (hEdit) SubclassEdit(hEdit, L"파일 이름 또는 패턴");
    }
    return 0;
}

bool ShowOpenDialog(HWND owner) {
    wchar_t buf[MAX_PATH]{};
    OPENFILENAMEW ofn{ sizeof(ofn) };
    ofn.hwndOwner = owner;
    ofn.lpstrFile = buf; ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_EXPLORER | OFN_ENABLEHOOK;
    ofn.lpfnHook = FileOpenHook;
    return GetOpenFileNameW(&ofn);
}
```

> **주의**: 내부 컨트롤 ID/구조는 OS 버전에 따라 바뀔 수 있어, **FindWindowEx(클래스/순서)** 기반이 더 안전.

---

## 8) 수명/해제/재진입 — 안전 체크리스트

1. **해제 시점**: 서브클래스는 **`WM_NCDESTROY`**에서 해제 (`RemoveWindowSubclass`).  
2. **재진입**: 서브클래스 프로시저 내에서 **자기 자신에게 보내는 메시지**는 **`PostMessage`**로 지연(즉시 `SendMessage`는 재귀/순환 위험).  
3. **스레드 규칙**: 서브클래싱/훅 설치는 **해당 윈도우가 속한 스레드**에서만.  
4. **공용 리소스**: 폰트/브러시 생성 시 **수명 관리**(파괴 누수 주의).  
5. **호환성**: `SetWindowLongPtr` 기반과 **혼용 금지**. 체인이 꼬인다.  
6. **64-bit**: 훅/서브클래스 프로시저 시그니처/정수 크기 주의 (`LONG_PTR`, `WPARAM/LPARAM`).  
7. **IME/유니코드**: `W` API 사용을 기본으로(조합문자/서로게이트 대응).  
8. **성능**: 훅/서브클래스는 **핫패스**다. 무거운 작업/IO 금지.

---

## 9) 디버깅/진단 팁

- **동적 설치 로그**: 어느 컨트롤에 무엇을 서브클래싱했는지 로깅(클래스명/윈도우 텍스트/ID/스레드ID).  
- **메시지 트레이스**: 특정 컨트롤에만 **선택적** `WM_*` 로깅(과도 방지).  
- **GDI 핸들/메모리**: 서브클래스 해제 후 **누수 검사**.  
- **크래시**: `WM_NCDESTROY` 경로/해제 순서 오류가 빈번. 미니덤프로 **메시지/스택** 확인.

---

## 10) 접근성/키보드/국제화 개선 사례

- **Space로 체크**(체크박스 아닌 커스텀 뷰): `WM_KEYDOWN VK_SPACE` 처리.  
- **Alt 키 표식 제어**: `WM_UPDATEUISTATE` 반응으로 UI 힌트 표시/숨김.  
- **RTL 레이아웃**: `WS_EX_LAYOUTRTL` 추가/제거(생성 시점 CBT hook로 적용).  
- **스크린리더 호환**: `WM_GETOBJECT`에서 `IAccessible` 노출(고급).  
- **단축키 힌트 Tooltip**: Hover 시 `Ctrl+S` 등 표시.

---

## 11) MFC 클래스 기반 서브클래스(확장 컨트롤 라이브러리화)

### 11-1. 공통 베이스

```cpp
// MfcSubclassBase.h
template<class Base, UINT_PTR SubclassId, WNDPROC Fallback = ::DefWindowProcW>
class CMfcSubclassBase : public Base {
public:
    BOOL Subclass(CWnd* parent, UINT id) {
        return __super::SubclassDlgItem(id, parent);
    }
    BOOL Subclass(HWND h) {
        return __super::SubclassWindow(h);
    }
    // 필요한 공통 유틸…
};
```

### 11-2. 예: `CComboEx` 오토 드롭다운 폭

```cpp
class CComboAutoWidth : public CMfcSubclassBase<CComboBox, 0xC0M2> {
    DECLARE_MESSAGE_MAP()
    afx_msg void OnDropdown() {
        AutoWidthComboDropDown(GetSafeHwnd());
    }
};
BEGIN_MESSAGE_MAP(CComboAutoWidth, CComboBox)
    ON_CONTROL_REFLECT(CBN_DROPDOWN, OnDropdown)
END_MESSAGE_MAP()
```

사용:
```cpp
m_combo.Subclass(this, IDC_COMBO_COLOR);
```

---

## 12) 실무 적용 전략

- **Low-risk부터**: Edit/Combo/Tooltip 같은 **순한 컨트롤**로 시작 → 버그 적음.  
- **기능별 묶음**: “입력 UX 패키지(플레이스홀더/숫자/IME)”, “리스트 UX 패키지(휠/오토스크롤/핫트래킹)”.  
- **토글 가능**: 문제 발생 시 **레지스트리/INI**로 **즉시 끄기**.  
- **문서화**: 어떤 메시지를 왜 가로채는지 **주석 + 운영 문서**.  
- **테스트**: DPI 100/150/200, IME 켜짐/꺼짐, High Contrast, 스크린리더, Win10/11 빌드.

---

## 13) 빠른 스타터(복붙 세트)

**1) Init**  
```cpp
BOOL CMyApp::InitInstance() {
    CWinApp::InitInstance();
    InitCommonControls(); // comctl32 v6 매니페스트 권장
    InstallThreadHooks(g_hooks);
    return TRUE;
}
```

**2) Dialog OnInit**  
```cpp
BOOL CMainDlg::OnInitDialog() {
    CDialogEx::OnInitDialog();
    SubclassEdit(GetDlgItem(m_hWnd, IDC_EDIT_NAME), L"이름");
    SubclassNumberEdit(GetDlgItem(m_hWnd, IDC_EDIT_AGE));
    SubclassListbox(GetDlgItem(m_hWnd, IDC_LIST_ITEMS));
    SubclassCombo(GetDlgItem(m_hWnd, IDC_COMBO_COLOR));
    SubclassHoverTip(GetDlgItem(m_hWnd, IDC_BTN_HELP), L"도움말 열기");
    SubclassDpiAware(GetSafeHwnd());
    return TRUE;
}
```

**3) Exit**  
```cpp
int CMyApp::ExitInstance() {
    UninstallThreadHooks(g_hooks);
    return CWinApp::ExitInstance();
}
```

---

## 14) 체크리스트(요약)

- [ ] **SetWindowSubclass** 우선, `WM_NCDESTROY`에서 **Remove**  
- [ ] **PostMessage**로 자기 재진입 회피  
- [ ] **스레드-로컬 훅**(WH_GETMESSAGE/WH_CALLWNDPROC) 최소화, **가볍게**  
- [ ] **IME/DPI/유니코드** 고려한 W API 사용  
- [ ] 폰트/브러시 **누수 없음**  
- [ ] **로그**: 설치/해제/예외 기록  
- [ ] 문제 시 **토글 옵션**으로 롤백  
- [ ] 공용 대화상자 Hook는 **버전 의존** → 방어적 탐색  
- [ ] 시스템 전역 훅은 **최후의 수단**  

---

### 마무리

서브클래싱/메시지 훅은 레거시 UI를 **교체 없이** 되살리는 비밀병기입니다.  
안전한 체인(`SetWindowSubclass`)과 **명확한 수명 관리**, **가벼운 훅** 원칙만 지키면  
- **입력 UX(플레이스홀더/필터/IME)**,  
- **리스트 UX(휠/오토스크롤/하이라이트)**,  
- **DPI/접근성/툴팁**  
을 한 세대 끌어올릴 수 있습니다.