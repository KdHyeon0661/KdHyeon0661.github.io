---
layout: post
title: 컴퓨터시스템 - 목적 파일을 조작하는 도구
date: 2025-08-11 22:20:23 +0900
category: 컴퓨터시스템
---
# 목적 파일을 조작하는 도구 — ELF 중심 실전 가이드(검사·편집·링크·배포)

> 대상: 리눅스/ELF를 기본으로 하되, Windows(PE/COFF), macOS(Mach-O) 도구도 곁들임.  
> 목표: **심볼/섹션/재배치/의존성**을 확인·수정·최적화·배포하기 위한 도구와 사용 패턴를 한 번에 정리.

---

## 0) 한눈 요약(무엇을 하고 싶은가 → 어떤 도구?)

작업 | 권장 도구(리눅스/ELF)
---|---
헤더/섹션/재배치/동적섹션 **검사** | `readelf`, `objdump`, `file`, `nm`, `size`, `strings`
**디스어셈블/주석** | `objdump -d/-D/-drwC`, `llvm-objdump`
**심볼 나열/약·강/가시성 확인** | `nm -C`, `readelf -Ws`, `objdump --syms --dynamic-syms`
**섹션/심볼 편집·삭제·추가** | `objcopy`, `strip`
**디버그 정보 분리/합치기** | `objcopy --only-keep-debug/--add-gnu-debuglink`, `eu-strip`
**아카이브(.a) 관리** | `ar`, `ranlib`, `llvm-ar`
**RPATH/RUNPATH·NEEDED 수정** | `patchelf`, `chrpath`, `elfedit`
**ELF 정합성 검증** | `readelf -a`, `elflint`(elfutils)
**링크/맵파일/GC 섹션** | `ld.bfd`/`gold`/`lld`, `-Wl,-Map=…`, `--gc-sections`
**런타임 의존성/바인딩 로그** | `ldd`, `LD_DEBUG=libs,reloc,bindings …`
(참고) Windows | `dumpbin`, `link.exe`, `editbin`, `llvm-objdump`
(참고) macOS | `otool -hvlL`, `install_name_tool`, `codesign`, `lipo`

---

## 1) 검사 도구(읽기 전용)

### 1.1 `readelf` (elfutils)
```bash
readelf -h a.o           # ELF 헤더
readelf -S a.o           # 섹션 헤더 테이블(이름/플래그/오프셋/크기)
readelf -s a.o           # 심볼 테이블(.symtab / .dynsym)
readelf -r a.o           # 재배치(.rel[a].*)
readelf -l a.out         # 프로그램 헤더(세그먼트) — 로더 관점
readelf -d libx.so       # .dynamic (DT_NEEDED, RPATH/RUNPATH, SONAME 등)
```

### 1.2 `objdump` (binutils/LLVM)
```bash
objdump -h a.o                 # 섹션 목록
objdump -d app | less          # 디스어셈블(소스 매핑은 -S)
objdump -drwC a.o              # 디스어셈+재배치 주석+C++ demangle
objdump -T libx.so             # 동적 심볼 테이블
objdump -R app                 # PLT/GOT 관련 재배치(JUMP_SLOT/GLOB_DAT)
objdump -x app                 # 종합 헤더 요약
```

### 1.3 심볼/크기/문자열
```bash
nm -C a.o                      # 정적 심볼(지역/전역/약/강)
nm -D libx.so                  # 동적 심볼(.dynsym)
size a.o                       # 텍스트/데이터/비스 크기
strings -n 6 app | grep token  # 내장/평문 문자열 탐색
file a.o                       # 포맷/아키 확인
```

---

## 2) 편집/변환 도구(objcopy/strip)

### 2.1 `objcopy` 핵심 옵션
```bash
# 디버그 정보만 분리 → 별도 .debug 파일 생성
objcopy --only-keep-debug app app.debug

# 실행 파일에서 디버그 제거(런타임 경량화)
objcopy --strip-debug app app.stripped
# 또는 완전 제거
strip --strip-all app

# 디버그 파일 연결(빌드 아이디/경로 사용)
objcopy --add-gnu-debuglink=app.debug app.stripped

# 특정 심볼만 보존/삭제/약화/이름변경
objcopy --keep-global-symbol foo app
objcopy --strip-symbol secret_fn app
objcopy --weaken-symbol plugin_api app         # STB_WEAK으로 약화
objcopy --redefine-sym old_name=new_name app

# 섹션 추가/갱신/플래그 설정(커스텀 메타·리소스 탑재)
objcopy --add-section .note.my=note.bin app
objcopy --set-section-flags .note.my=alloc,readonly app
objcopy --remove-section .comment app
```

> 주의: 심볼 이름 변경/약화는 **링커/로더 의미론**에 영향. ABI 공개 심볼은 신중히.

### 2.2 디버그 분리 베스트 프랙티스
```bash
# 1) 빌드 산출물에서 디버그만 추출
objcopy --only-keep-debug app app.debug
# 2) 실행 바이너리 경량화
strip --strip-unneeded app
# 3) 런타임 바이너리에 디버그 연결 정보 삽입
objcopy --add-gnu-debuglink=app.debug app
```
- 배포: `app`만 배포, 사고 시 `app.debug`로 정확한 스택트레이스 재현.

---

## 3) 아카이브(.a) 관리 — `ar`/`ranlib`

```bash
ar rcs libmylib.a a.o b.o c.o   # 새 아카이브 생성/갱신
ar t libmylib.a                 # 멤버 나열
ar x libmylib.a b.o             # 특정 멤버 추출
ranlib libmylib.a               # 심볼 인덱스 재생성(일부 환경)
```

- **thin archive**(gold/lld 지원): 오브젝트 복사 대신 **경로 참조** → 링크 빠르고 공간 절약.
  ```bash
  ar rcsT libthin.a a.o b.o
  ```

---

## 4) 동적 속성 편집 — RPATH/RUNPATH/NEEDED

### 4.1 `patchelf`
```bash
patchelf --print-rpath app
patchelf --set-rpath '$ORIGIN/../lib' app       # RUNPATH 교체(신규)
patchelf --remove-rpath app
patchelf --set-soname libx.so.1 libx.so
patchelf --replace-needed libold.so libnew.so app
```

### 4.2 `chrpath`/`elfedit`
```bash
chrpath -l app                                   # 현 RPATH/RUNPATH
chrpath -r '$ORIGIN/lib' app
elfedit --output-osabi GNU app
```

> 실무 팁: 배포 디렉터리 상대 경로는 **`$ORIGIN`** 을 사용. `RPATH`는 구식, **RUNPATH** 권장.

---

## 5) 링커와 맵파일, 섹션 GC

### 5.1 링커 선택
- **`ld.bfd`**(기본), **`gold`**(빠름, C++ 대규모), **`lld`**(LLVM 진영, 크로스플랫폼).  
- 선택은 `-fuse-ld=gold`/`lld` 로.

### 5.2 옵션 모음
```bash
# 쓰지 않는 섹션 제거(함수/데이터를 섹션 단위로 분리해둔 경우)
gcc -ffunction-sections -fdata-sections …
ld  -Wl,--gc-sections

# 맵파일(심볼 배치·해석 경로 추적)
gcc main.o -Wl,-Map=link.map -o app

# 버전 스크립트로 내보낼 심볼/버전 제어
-Wl,--version-script=exports.map
```

`exports.map` 예:
```ld
LIBX_1.0 {
  global: x_public_*;
  local:  *;
};
```

---

## 6) ELF 정합성·품질 검증

```bash
elflint app                 # 포맷/필드 정합성 검사(elfutils)
readelf -a app | less       # 전체 필드 스캔
ldd app                     # 런타임 의존성/해석 경로
LD_DEBUG=libs,bindings ./app 2>&1 | less  # 로딩/바인딩 로그 추적
```

---

## 7) DWARF/디버깅 도구

```bash
objdump --dwarf=info,aranges,frames app   # DWARF 개요
dwarfdump app                              # (llvm-dwarfdump)
addr2line -e app 0x40123a                  # PC→파일:행 변환
eu-addr2line -e app -fC 0x40123a           # 함수명 demangle 포함
```

- 빌드ID로 심볼 서버 운영: `-Wl,--build-id` 기본 활성 → `/usr/lib/debug/.build-id/…` 경로에서 자동 검색.

---

## 8) 재배치·심볼 조작 레시피

### 8.1 “이 .o가 외부에 무엇을 요구/내보내나?”
```bash
nm -uC a.o                 # 미정(Undefined) 심볼 (무엇이 더 필요한가)
nm -C a.o | grep ' [TD] '  # 정의된 코드/데이터 심볼(무엇을 제공하나)
readelf -r a.o             # 재배치 리스트(어디를 패치해야 하나)
```

### 8.2 심볼의 **가시성**·바인딩 바꾸기
```bash
# 공개 API 최소화: 내부 심볼을 숨기거나 약화
objcopy --localize-symbol _ZL10internalv libx.so      # LOCAL로 강등
objcopy --weaken-symbol  plugin_api libplugin.so      # WEAK으로 변경
```
> 가시성 축소는 **최적화(인라이닝/직접호출)** 와 **보안(인터포지션 차단)** 모두에 이득.

### 8.3 특정 섹션만 추출·교체
```bash
# .text만 덤프
objcopy -O binary --only-section=.text app text.bin
# 외부 생성한 .rodata 교체
objcopy --update-section .rodata=new_rodata.bin app
```

---

## 9) 플랫폼 별 도구 한 컷

### 9.1 Windows(PE/COFF)
```bat
dumpbin /headers /imports /exports app.exe
link /MAP:app.map …
editbin /SUBSYSTEM:CONSOLE app.exe
```
- 아카이브: `lib.exe`, 서명: `signtool.exe`.

### 9.2 macOS(Mach-O)
```bash
otool -hvL app                 # 헤더/로드명령/의존성
install_name_tool -change @rpath/libx.dylib @loader_path/libx.dylib app
codesign -s "Developer ID" app # 서명
lipo -create x86_64 arm64 -output fatbin   # 유니버설 바이너리
```

---

## 10) 실전 미니 시나리오

### 10.1 “런타임 의존 경로를 배포 디렉토리로 고정”
```bash
patchelf --set-rpath '$ORIGIN/lib' app
patchelf --print-rpath app
```

### 10.2 “죽은 코드/디버그 제거로 크기 절감”
```bash
CFLAGS="-O2 -ffunction-sections -fdata-sections"
LDFLAGS="-Wl,--gc-sections"
strip --strip-unneeded app
size app
```

### 10.3 “아카이브에서 필요한 .o만 꺼내 재링크”
```bash
ar t libfoo.a | grep json.o
ar x libfoo.a json.o
gcc main.o json.o -o app_min
```

### 10.4 “스택트레이스에 라인번호 복구”
```bash
objcopy --only-keep-debug app app.debug
strip app
objcopy --add-gnu-debuglink=app.debug app
addr2line -e app.debug 0x40123a
```

### 10.5 “심볼 이름 충돌 완화(임시 대응)”
```bash
objcopy --redefine-sym old_alloc=my_alloc libthirdparty.a
```

---

## 11) 안전 가이드(함정과 주의)

- `strip --strip-all` 은 디버깅/프로파일링/프로브(kprobe, eBPF) 불가 → **배포 전 단계**에서만.
- `--redefine-sym`/`--localize-symbol` 은 **ABI/링커 스크립트/버전 스크립트**와 충돌 가능.
- RPATH보다 **RUNPATH** 선호(상속 규칙 차이). `patchelf` 가 자동으로 RUNPATH로 설정.
- 보안 정책(suid/SELinux/AppArmor) 환경에서는 `LD_LIBRARY_PATH`/RPATH 영향이 제한될 수 있음.
- PE/Mach-O는 각자 규칙(서명/코드블록) → 임의 편집 시 **서명 무효**.

---

## 12) 체크리스트

- [ ] 포맷/아키/엔디안 확인: `file`, `readelf -h`  
- [ ] 섹션/심볼/재배치/동적 정보 확인: `readelf -S/-s/-r/-d`  
- [ ] 필요 시 디스어셈블: `objdump -drwC`  
- [ ] RPATH/RUNPATH/NEEDED 검토·수정: `patchelf`  
- [ ] 디버그 분리·보존: `objcopy --only-keep-debug` + `--add-gnu-debuglink`  
- [ ] 배포 크기/보안: `--gc-sections`, `strip`(주의), SONAME/버전 스크립트  
- [ ] 문제 시 로더 로그: `LD_DEBUG=libs,bindings,reloc`  

---

## 13) 한 줄 결론
**목적 파일 조작**은 “**보는(readelf/objdump)** → **고치는(objcopy/patchelf)** → **검증하는(ldd/LD_DEBUG/elflint)**”의 순서다.  
핵심은 **심볼/섹션/재배치/동적 속성**을 정확히 파악하고, **최소한의 변경**으로 **ABI·보안·성능**을 동시에 만족시키는 것이다.