---
layout: post
title: 컴퓨터시스템 - 목적 파일을 조작하는 도구
date: 2025-08-11 22:20:23 +0900
category: 컴퓨터시스템
---
# 목적 파일을 조작하는 도구 — ELF 중심

## 한눈 요약 — “무엇을 하고 싶은가?” → “어떤 도구?”

작업 | 대표 도구(ELF) | 한 줄 설명/팁
---|---|---
**헤더·섹션·재배치 검사** | `readelf`, `objdump`, `file`, `size` | `readelf -aW`로 전부, `objdump -x` 요약, `file`로 아키/엔디안
**심볼·버전·가시성 확인** | `nm -C`, `readelf -Ws`, `objdump -T`, `readelf --version-info` | `GLOBAL/WEAK/LOCAL`, `GNU version` 테이블
**디스어셈·재배치 주석** | `objdump -drwC`, `llvm-objdump -d` | `-r`로 재배치 주석, `-C`로 C++ demangle
**섹션/심볼 편집·삭제·추가** | `objcopy`, `strip`, `eu-strip` | 디버그 분리 `--only-keep-debug`, `--add-gnu-debuglink`
**RPATH/RUNPATH/NEEDED 편집** | `patchelf`, `chrpath`, `elfedit` | `$ORIGIN` 적극 사용, RUNPATH 권장
**링커/맵/섹션 GC/해시** | `ld.bfd`/`gold`/`lld`, `-Wl,-Map=…`, `--gc-sections`, `--hash-style=` | `-ffunction/data-sections`와 짝
**런타임 의존·바인딩 로그** | `ldd`, `LD_DEBUG=libs,reloc,bindings` | 로더의 실제 검색/바인딩 경로 추적
**정합성/보안 점검** | `elflint`, `checksec` | PIE/RELRO/CANARY/FORTIFY 상태 확인
**DWARF/주소↔소스 변환** | `dwarfdump`, `addr2line`, `eu-addr2line` | Build-ID/gnu_debuglink 기반 심볼 서버
(Windows) | `dumpbin`, `link.exe`, `editbin`, `signtool` | Imports/Exports/서명/ASLR/CFG
(macOS) | `otool`, `install_name_tool`, `codesign`, `lipo` | LC_ID_DYLIB/RPATH/서명/유니버설 바이너리

---

## 기본 정리 — ELF를 *변경하기 전에* 읽는 법

### 전체 구조 한 번에 훑기

```bash
file app                # 포맷/아키/엔디안/PIE 여부 힌트
readelf -hW app         # ELF 헤더(클래스/엔디안/OSABI/엔트리/형태)
readelf -lW app         # Program Header(로더 관점: LOAD/INTERP/DYNAMIC/NOTE)
readelf -SW app         # Section Header(링커 관점: 이름/플래그/정렬)
objdump -x app | less   # 종합 요약(섹션/심볼/동적/재배치 일부)
```

### 심볼/버전/동적 항목

```bash
readelf -dW app                         # DT_NEEDED/SONAME/RPATH/RUNPATH
objdump -T app                          # 동적 심볼(.dynsym)과 버전 태그
readelf --version-info app              # GNU verdef/verneed/veridx(심볼 버전)
nm -D app | sed -n '1,50p'              # 동적 심볼 빠른 확인
```

### 재배치·PLT/GOT 포커스

```bash
readelf -rW app                         # .rel[a].* 항목(어디를 패치?)
objdump -R app                          # PLT/GOT 재배치(JUMP_SLOT/GLOB_DAT 등)
objdump -drwC app | less                # 디스어셈+재배치 주석+demangle
```

---

## 읽기 전용 검사 — 사고를 “수치/로그”로 재현

### 런타임 해석/바인딩 경로

```bash
ldd ./app                                # 해석된 NEEDED와 실경로
LD_DEBUG=libs,reloc,bindings ./app 2>&1 | less
```

### 보안 하드닝 상태

```bash
checksec --file=./app 2>/dev/null || true  # PIE/RELRO/CANARY/NX/FORTIFY
readelf --notes ./app | grep -A2 'GNU_PROPERTY'  # CET/BTI 등 GNU property
```

---

## 편집/변환 — objcopy/strip의 “안전한” 사용법

### 디버그 분리/결합(권장 루틴)

```bash
# 디버그만 따로 보관

objcopy --only-keep-debug app app.debug
# 런타임 바이너리 경량화

strip --strip-unneeded app
# 디버그 링크 부착(경로/CRC 기록)

objcopy --add-gnu-debuglink=app.debug app
```

> **팁**: 배포는 `app`만. 사고/프로파일 필요 시 `app.debug`로 정확한 스택·소스라인 복구.
> **주의**: `--strip-all`은 업프로브/eBPF/프로파일러·언와인더에 치명적일 수 있음.

### 심볼/섹션 조작 스니펫

```bash
# 내부 심볼 숨기기(가시성 축소 → 최적화/보안 이득)

objcopy --localize-symbol _ZL12internalFoo libx.so

# → 대체 가능하게

objcopy --weaken-symbol plugin_hook libplugin.so

# 심볼 이름 교체(충돌/일시 대응)

objcopy --redefine-sym old_alloc=my_alloc libthirdparty.a

# 커스텀 노트/리소스 삽입

objcopy --add-section .note.team=meta.bin --set-section-flags .note.team=alloc,readonly app

# 불필요 섹션 제거(안전 영역 위주)

objcopy --remove-section .comment --remove-section .note.gnu.gold-version app
```

> **금지/주의**: `.eh_frame(_hdr)`, `.init_array/.fini_array`, `.gcc_except_table`, TLS 섹션, IFUNC, `.gnu.hash`/`.hash` 임의 변조.

---

## RPATH/RUNPATH·NEEDED — 배포 디렉터리에 “고정”

### patchelf 기본

```bash
patchelf --print-rpath app
patchelf --set-rpath '$ORIGIN/lib' app    # DT_RUNPATH로 설정(권장)
patchelf --replace-needed libold.so libnew.so app
patchelf --set-soname libx.so.2 libx.so
patchelf --print-needed app               # DT_NEEDED 나열
```

**권장 규칙**
- `$ORIGIN` 상대 경로로 *자족 배포* 가능하게.
- `RPATH`보다 **RUNPATH** 선호(상속/우선순위 차이).
- SUID/보안 정책/컨테이너 베이스 이미지에서 **LD_LIBRARY_PATH/RUNPATH 무시** 가능 → 이미지 내 경로 일치 필수.

### chrpath/elfedit(보조)

```bash
chrpath -l app
chrpath -r '$ORIGIN/../lib' app
elfedit --output-osabi GNU app
```

---

## 링크 단계 제어 — 맵/GC/버전/해시

### 섹션 GC/불필요 의존 제거

```bash
# 컴파일: 함수/데이터를 섹션 단위로 분리

CFLAGS="-O2 -ffunction-sections -fdata-sections"
# 링크: 도달성 없는 섹션 삭제

LDFLAGS="-Wl,--gc-sections -Wl,--as-needed"
gcc $CFLAGS main.o ... $LDFLAGS -o app
```

### 맵 파일로 배치/해석 경로 추적

```bash
gcc main.o ... -Wl,-Map=link.map -o app
```

### 심볼 버전 스크립트

```ld
# exports.map

LIBX_1.0 {
  global: x_public_*;    # 공개
  local:  *;             # 나머지는 숨김
};
```
```bash
gcc -shared -Wl,--version-script=exports.map -o libx.so *.o
```

### 해시/ICF/LTO(선택)

```bash
# GNU 해시 테이블(로더 성능)

-Wl,--hash-style=gnu                 # 또는 both
# 동일 코드 폴딩(링커 단계, gold/lld)

-Wl,--icf=all
# LTO/ThinLTO

-flto -fuse-ld=lld -Wl,--plugin-opt=O3
```

---

## DWARF/주소 변환/프로파일 협업

```bash
dwarfdump app | sed -n '1,80p'                 # DWARF 개요
objdump --dwarf=frames,info app | less         # 프레임/언와인드
addr2line -e app 0x40123a                      # PC → 파일:행
eu-addr2line -e app -fC 0x40123a               # 함수명 demangle 포함
```

**Build-ID 기반 심볼 서버**
```bash
# -Wl,--build-id

eu-readelf -n app | grep -A1 'Build ID'
# 심볼 서버 경로: /usr/lib/debug/.build-id/xx/yyy.debug

```

---

## 재배치/심볼 진단 레시피

### “이 .o가 무엇을 요구/제공하는가?”

```bash
nm -uC a.o                     # 미정(Undefined) 심볼 목록(외부 의존)
nm -C a.o | grep ' [TD] '      # 정의된 함수/데이터 심볼
readelf -rW a.o                # 재배치 항목(패치 대상)
```

### IFUNC/TLS/고급 항목 감지

```bash
readelf -Ws libx.so | egrep 'IFUNC|TLS'
objdump -R app | egrep 'IRELATIVE|TLS'
```

> IFUNC는 `R_*_IRELATIVE`가 생성됨. 임의 편집 금지.

---

## 한 컷 요약

### Windows

```bat
dumpbin /headers /imports /exports app.exe
link /MAP:app.map ...
editbin /SUBSYSTEM:CONSOLE app.exe
signtool verify /pa app.exe
```
- **주의**: `.reloc` 제거 → /DYNAMICBASE(ASLR) 불가. 서명 변경 시 **재서명 필수**. Delay-Load/IAT 가공 시 로딩 실패.

### macOS

```bash
otool -hvL app
install_name_tool -change @rpath/libx.dylib @loader_path/libx.dylib app
codesign -s "Developer ID Application: YOUR NAME" app
lipo -create x86_64 arm64 -output fatbin
```
- LC_ID_DYLIB/LC_RPATH 수정 후 **codesign 재서명**. Hardened Runtime/arm64e(PAC) 주의.

---

## 실전 미니 실험 5종 — “보는→고치는→검증”

### 배포 디렉토리 고정(RUNPATH)

```bash
patchelf --set-rpath '$ORIGIN/lib' app
patchelf --print-rpath app
LD_DEBUG=libs ./app 2>&1 | grep -E 'searching|trying'
```

### 죽은 코드 제거 + 크기 측정

```bash
CFLAGS="-O2 -ffunction-sections -fdata-sections"
LDFLAGS="-Wl,--gc-sections"
gcc $CFLAGS *.c $LDFLAGS -o app
size app
```

### 디버그 분리→문제 발생 시 라인 복구

```bash
objcopy --only-keep-debug app app.debug
strip --strip-unneeded app
objcopy --add-gnu-debuglink=app.debug app
addr2line -e app.debug 0x40123a
```

### NEEDED 교체(라이브러리 대체)

```bash
patchelf --print-needed app
patchelf --replace-needed libold.so libnew.so app
LD_DEBUG=libs ./app | less
```

### 특정 .o만 꺼내 재링크(슬림)

```bash
ar t libfoo.a | grep codec.o
ar x libfoo.a codec.o
gcc main.o codec.o -o app_min
```

---

## 안전 가이드 — 함정 회피 체크리스트

- [ ] **포맷/아키/엔디안**: `file`, `readelf -hW`
- [ ] **섹션/심볼/재배치/동적**: `readelf -S/-s/-r/-d`
- [ ] **심볼 버전/가시성**: `readelf --version-info`, `objdump -T`
- [ ] **보안 하드닝**: `checksec`, GNU property(CET/BTI), RELRO/BIND_NOW
- [ ] **RPATH→RUNPATH** 전환 영향/보안 정책(SUID/컨테이너)
- [ ] **디버그 분리**: `--only-keep-debug` + `--add-gnu-debuglink` (Build-ID 일치)
- [ ] **섹션 제거 금지**: `.eh_frame(_hdr)`, `.init_array`, `.gcc_except_table`, TLS
- [ ] **IFUNC/TLS/gnu.hash** 변조 금지
- [ ] **링커 옵션**: `--gc-sections`, `--as-needed`, 버전 스크립트
- [ ] **런타임 검증**: `LD_DEBUG=libs,reloc,bindings`, `ldd`
- [ ] **SBOM/서명/정책**: (PE/Mach-O) 변경 후 **재서명**, 배포 메타 갱신

---

## CI 자동 점검 스니펫(참고)

```bash
#!/usr/bin/env bash

set -euo pipefail

bin="$1"

echo "== basic =="
file "$bin"
readelf -hW "$bin" | egrep 'Class|Data|Machine|Type'

echo "== dynamic =="
readelf -dW "$bin" | egrep 'NEEDED|RPATH|RUNPATH|SONAME' || true

echo "== symbols =="
readelf --dyn-syms -W "$bin" | egrep 'GLOBAL|WEAK' | head -n 30
readelf --version-info "$bin" | sed -n '1,80p' || true

echo "== security =="
checksec --file="$bin" 2>/dev/null || true
readelf --notes "$bin" | grep -A2 'GNU_PROPERTY' || true

echo "== size/hash =="
size "$bin" || true
eu-readelf -n "$bin" | grep -A1 'Build ID' || true
```

---

## — “버전/해시 테이블 감도”

> ELF에서 로더의 심볼 탐색 비용을 개념식으로 표현하면

$$
T_{\text{lookup}} \approx T_{\text{hash}} + T_{\text{chain}}(L) + T_{\text{version\_check}}
$$

- \(T_{\text{hash}}\): 해시 계산(체계: SysV vs GNU)
- \(L\): 체인 길이(충돌 시) — **GNU 해시**는 Bloom 필터로 \(L\)을 크게 줄임
- \(T_{\text{version\_check}}\): `verneed/verdef` 비교 비용

**실무 결론**: `--hash-style=gnu`(또는 `both`) + **버전 스크립트로 공개 심볼 최소화**가 로더 효율과 ABI 안정에 유리.

---

## 부록 — 자주 쓰는 옵션/명령 모음

### readelf/objdump 즐겨찾기

```bash
readelf -aW app | less
objdump -drwC app | less
objdump -R app | egrep 'JUMP_SLOT|GLOB_DAT'
readelf --version-info app | less
```

### patchelf 즐겨찾기

```bash
patchelf --print-rpath app
patchelf --set-rpath '$ORIGIN/lib' app
patchelf --print-needed app
patchelf --replace-needed libssl.so.1.1 libssl.so.3 app
```

### 링크 최적화

```bash
CFLAGS="-O2 -ffunction-sections -fdata-sections -fvisibility=hidden"
LDFLAGS="-Wl,--gc-sections -Wl,--as-needed -Wl,--hash-style=gnu"
```

---

## 결론 — “작게 고치고, 크게 검증하라”

1) **읽기**: `readelf/objdump`로 **정확히** 구조 파악
2) **고치기**: `objcopy/patchelf`로 **최소 변경**
3) **링크/배포**: 맵/버전/해시/섹션GC로 깔끔하게
4) **검증**: `ldd`, `LD_DEBUG`, `elflint`, `checksec`, DWARF/Build-ID
5) **반복**: CI로 자동 점검·회귀 차단

바이너리 조작은 바이트 편집이 아니라 **로더·링커·디버거·보안 하드닝**을 동시에 다루는 운영 작업이다.
**정확한 관찰(로그/수치)**과 **최소 침습 변경**, **충분한 검증**이 가장 강력한 안전장치다.
