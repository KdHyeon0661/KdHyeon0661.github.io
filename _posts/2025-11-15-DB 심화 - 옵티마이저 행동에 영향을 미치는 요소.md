---
layout: post
title: DB 심화 - 옵티마이저 행동에 영향을 미치는 요소
date: 2025-11-15 17:25:23 +0900
category: DB 심화
---
# 옵티마이저 행동에 영향을 미치는 요소: 원인 분석과 대응 전략

옵티마이저는 SQL 쿼리의 실행 계획을 결정하는 핵심 엔진입니다. 동일한 SQL이 다른 실행 계획을 생성하는 이유를 이해하기 위해서는 옵티마이저의 의사결정에 영향을 미치는 다양한 요소들을 체계적으로 분석해야 합니다. 이 문서에서는 옵티마이저의 행동 패턴을 결정하는 주요 요소들을 실제 예제와 함께 상세히 살펴보겠습니다.

## 실습 환경 설정

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;
```

실행 계획 분석 템플릿:
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL,
  'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS +NOTE +ALIAS'
));
```

## 기본 데이터 모델 구성

```sql
-- 기존 테이블 제거
DROP TABLE CUST PURGE;
DROP TABLE ORD  PURGE;
DROP TABLE PROD PURGE;

-- 고객 테이블
CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  NAME    VARCHAR2(50) NOT NULL,
  REGION  VARCHAR2(8),
  TIER    VARCHAR2(8)
);

-- 주문 테이블
CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  ORDER_DT DATE   NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL
);

-- 제품 테이블
CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,
  BRAND    VARCHAR2(12) NOT NULL
);

-- 샘플 데이터 입력
BEGIN
  -- 고객 10,000명
  FOR c IN 1..10000 LOOP
    INSERT INTO CUST VALUES(
      c, 'N'||c,
      CASE MOD(c,5)
        WHEN 0 THEN 'KOR'
        WHEN 1 THEN 'APAC'
        WHEN 2 THEN 'EMEA'
        WHEN 3 THEN 'AMER'
        ELSE 'JPN'
      END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP'
        WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER'
        ELSE 'GEN'
      END
    );
  END LOOP;

  -- 주문 60,000건
  FOR o IN 1..60000 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,10000)+1,
      DATE '2024-01-01' + MOD(o,180),
      ROUND(DBMS_RANDOM.VALUE(1,9999),2)
    );
  END LOOP;

  -- 제품 10,000개
  FOR p IN 1..10000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC'
        WHEN 1 THEN 'FOOD'
        WHEN 2 THEN 'TOY'
        WHEN 3 THEN 'HOME'
        ELSE 'FASH'
      END,
      CASE WHEN p <= 2500 THEN 'B0'
           ELSE 'B'||TO_CHAR(MOD(p,50))
      END
    );
  END LOOP;
  
  COMMIT;
END;
/

-- 인덱스 생성
CREATE INDEX IX_CUST_REGION ON CUST(REGION, CUST_ID);
CREATE INDEX IX_ORD_CUST_DT ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_PROD_CAT    ON PROD(CATEGORY, PROD_ID);

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE,
    method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD', cascade=>TRUE,
    method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE,
    method_opt=>'for all columns size skewonly');
END;
/
```

## 1. SQL 구문 형태와 SARGability

SQL의 구문 형태는 옵티마이저의 인덱스 사용 결정에 직접적인 영향을 미칩니다. SARGable(Search ARGument-able) 조건은 인덱스를 효과적으로 활용할 수 있는 형태를 의미합니다.

### SARGable vs Non-SARGable 예제

```sql
-- Non-SARGable: 컬럼에 함수 적용
EXPLAIN PLAN FOR
SELECT * FROM ORD
WHERE TO_CHAR(order_dt,'YYYYMM') = '202403';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- SARGable: 범위 조건 사용
EXPLAIN PLAN FOR
SELECT * FROM ORD
WHERE order_dt >= DATE '2024-03-01'
AND    order_dt <  DATE '2024-04-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

첫 번째 쿼리는 컬럼에 함수를 적용하여 인덱스 사용이 어렵습니다. 두 번째 쿼리는 인덱스 범위 스캔을 활용할 수 있는 형태입니다.

### 암시적 형 변환 문제

데이터 타입 불일치로 인한 암시적 형 변환은 성능 문제를 일으킬 수 있습니다:

```sql
-- order_id는 NUMBER 타입, :b는 VARCHAR2 타입인 경우
EXPLAIN PLAN FOR
SELECT * FROM ORD WHERE order_id = :b;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 명시적 형 변환으로 해결
EXPLAIN PLAN FOR
SELECT * FROM ORD WHERE order_id = TO_NUMBER(:b);
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 2. 인덱스 구조와 성능 특성

인덱스의 물리적 구조는 옵티마이저의 비용 계산에 직접적인 영향을 미칩니다.

### 클러스터링 팩터(Clustering Factor)

클러스터링 팩터는 인덱스 순서와 테이블 물리적 순서의 일치 정도를 나타내며, NL 조인의 성능에 결정적인 영향을 미칩니다:

```sql
-- 인덱스 통계 확인
SELECT index_name, 
       clustering_factor,
       num_rows,
       ROUND(clustering_factor/num_rows*100, 2) as cf_ratio
FROM user_indexes
WHERE table_name='ORD';

-- 클러스터링 팩터 개선을 위한 테이블 재구성
CREATE TABLE ORD_REORG AS
SELECT * FROM ORD ORDER BY cust_id, order_dt;

-- 재구성 후 인덱스 생성
CREATE INDEX IX_ORD_REORG_CUST_DT ON ORD_REORG(cust_id, order_dt);

-- 통계 비교
SELECT '원본' as type, clustering_factor, num_rows
FROM user_indexes WHERE index_name='IX_ORD_CUST_DT'
UNION ALL
SELECT '재구성' as type, clustering_factor, num_rows
FROM user_indexes WHERE index_name='IX_ORD_REORG_CUST_DT';
```

### 함수 기반 인덱스(Function-Based Index)

비 SARGable 조건을 SARGable로 변환하기 위해 함수 기반 인덱스를 활용할 수 있습니다:

```sql
-- 함수 기반 인덱스 생성
CREATE INDEX IX_CUST_NAME_UPPER ON CUST(UPPER(name));

-- 함수 기반 인덱스 활용 쿼리
EXPLAIN PLAN FOR
SELECT * FROM CUST
WHERE UPPER(name) = 'N100';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 3. 파티셔닝과 성능 최적화

파티셔닝은 대용량 데이터 처리에서 성능을 크게 향상시킬 수 있는 중요한 기술입니다.

### 파티션 프루닝(Partition Pruning)

```sql
-- 파티션된 주문 테이블 생성
DROP TABLE ORD_PARTITIONED PURGE;

CREATE TABLE ORD_PARTITIONED (
  ORDER_ID NUMBER,
  CUST_ID  NUMBER,
  ORDER_DT DATE,
  AMOUNT   NUMBER(12,2)
)
PARTITION BY RANGE (ORDER_DT) (
  PARTITION p_2024_q1 VALUES LESS THAN (DATE '2024-04-01'),
  PARTITION p_2024_q2 VALUES LESS THAN (DATE '2024-07-01'),
  PARTITION p_2024_q3 VALUES LESS THAN (DATE '2024-10-01'),
  PARTITION p_2024_q4 VALUES LESS THAN (DATE '2025-01-01'),
  PARTITION p_future VALUES LESS THAN (MAXVALUE)
);

-- 파티션 프루닝 효과 확인
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM ORD_PARTITIONED
WHERE order_dt >= DATE '2024-03-01'
AND   order_dt < DATE '2024-04-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 파티션 와이즈 조인(Partition-Wise Join)

동일한 파티션 키를 가진 테이블 간 조인에서 성능 향상을 기대할 수 있습니다:

```sql
-- 파티션된 고객 테이블
CREATE TABLE CUST_PARTITIONED (
  CUST_ID NUMBER,
  REGION  VARCHAR2(8),
  TIER    VARCHAR2(8)
)
PARTITION BY LIST (REGION) (
  PARTITION p_kor VALUES ('KOR'),
  PARTITION p_apac VALUES ('APAC'),
  PARTITION p_emea VALUES ('EMEA'),
  PARTITION p_amer VALUES ('AMER'),
  PARTITION p_jpn VALUES ('JPN'),
  PARTITION p_other VALUES (DEFAULT)
);

-- 파티션 와이즈 조인
EXPLAIN PLAN FOR
SELECT c.region, SUM(o.amount)
FROM CUST_PARTITIONED c
JOIN ORD_PARTITIONED o ON o.cust_id = c.cust_id
WHERE c.region = 'KOR'
AND o.order_dt >= DATE '2024-01-01'
GROUP BY c.region;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 4. 통계 정보의 중요성

통계 정보는 옵티마이저의 비용 계산과 실행 계획 선택의 기초가 됩니다.

### 히스토그램(Histogram)

데이터 분포가 불균일할 때 히스토그램이 중요합니다:

```sql
-- 브랜드별 데이터 분포 확인
SELECT brand, COUNT(*) as cnt
FROM PROD
GROUP BY brand
ORDER BY cnt DESC;

-- 히스토그램 생성
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER, 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND'
  );
END;
/

-- 히스토그램 효과 확인
EXPLAIN PLAN FOR
SELECT * FROM PROD WHERE brand = 'B0';  -- 25%의 데이터
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT * FROM PROD WHERE brand = 'B47'; -- 소량 데이터
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 확장 통계(Extended Statistics)

상관 관계가 있는 컬럼들의 조합에 대한 통계 정보:

```sql
-- 확장 통계 생성
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(
    USER, 'CUST', '(REGION, TIER)'
  );
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'CUST');
END;
/

-- 확장 통계 확인
SELECT extension_name, extension
FROM user_stat_extensions
WHERE table_name = 'CUST';
```

## 5. 적응형 쿼리 최적화(Adaptive Query Optimization)

Oracle 12c부터 도입된 적응형 최적화 기능은 실행 중 통계를 기반으로 실행 계획을 동적으로 조정합니다.

### 적응형 플랜(Adaptive Plans)

```sql
-- 적응형 플랜 활성화
ALTER SESSION SET optimizer_adaptive_plans = TRUE;

-- 복잡한 조인 쿼리
EXPLAIN PLAN FOR
SELECT c.region, p.category, SUM(o.amount)
FROM CUST c
JOIN ORD o ON o.cust_id = c.cust_id
JOIN PROD p ON p.prod_id = MOD(o.order_id, 10000) + 1
WHERE c.region IN ('KOR', 'APAC')
AND o.order_dt >= DATE '2024-01-01'
GROUP BY c.region, p.category;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 통계 피드백(Statistics Feedback)

실행 중 수집된 통계 정보를 다음 실행에 반영합니다:

```sql
-- 통계 피드백 확인
SELECT sql_id, child_number,
       is_reoptimizable,
       is_resolved_adaptive_plan
FROM v$sql
WHERE sql_text LIKE '%CUST c JOIN ORD o%';
```

## 6. 옵티마이저 모드와 목표 설정

옵티마이저의 목표 모드는 실행 계획 선택에 큰 영향을 미칩니다.

```sql
-- 전체 처리량 최적화 모드
ALTER SESSION SET optimizer_mode = ALL_ROWS;
EXPLAIN PLAN FOR
SELECT * FROM CUST WHERE region = 'KOR';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 빠른 응답 시간 모드
ALTER SESSION SET optimizer_mode = FIRST_ROWS_100;
EXPLAIN PLAN FOR
SELECT * FROM CUST WHERE region = 'KOR';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 7. 힌트(Hints)를 통한 실행 계획 제어

힌트는 옵티마이저의 결정을 명시적으로 제어하는 강력한 도구입니다.

### 조인 순서 및 방법 제어

```sql
-- 조인 순서와 방법을 명시적으로 지정
EXPLAIN PLAN FOR
SELECT /*+ LEADING(c o) USE_NL(o) INDEX(c IX_CUST_REGION) */
       c.cust_id, c.name, SUM(o.amount) as total_amount
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
WHERE  c.region = 'KOR'
AND    o.order_dt >= DATE '2024-01-01'
GROUP  BY c.cust_id, c.name;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 병렬 처리 힌트

```sql
-- 병렬 처리 힌트
EXPLAIN PLAN FOR
SELECT /*+ PARALLEL(4) */
       c.region, COUNT(*) as customer_count,
       SUM(o.amount) as total_sales
FROM CUST c
JOIN ORD o ON o.cust_id = c.cust_id
GROUP BY c.region;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 8. 데이터베이스 제약 조건의 영향

제약 조건은 옵티마이저에게 데이터 관계에 대한 중요한 정보를 제공합니다.

```sql
-- 외래 키 제약 조건 추가
ALTER TABLE ORD ADD CONSTRAINT fk_ord_cust 
FOREIGN KEY (cust_id) REFERENCES CUST(cust_id);

-- 제약 조건 기반 조인 제거(Join Elimination)
EXPLAIN PLAN FOR
SELECT o.order_id, o.order_dt, o.amount
FROM ORD o
JOIN CUST c ON c.cust_id = o.cust_id
WHERE o.order_id = 100;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 9. 자동 인덱싱(Automatic Indexing)

Oracle 19c부터 도입된 자동 인덱싱 기능:

```sql
-- 자동 인덱싱 상태 확인
SELECT * FROM dba_auto_index_config;

-- 자동 생성된 인덱스 확인
SELECT index_name, table_name, auto
FROM user_indexes
WHERE auto = 'YES';
```

## 10. 실시간 통계(Real-Time Statistics)

```sql
-- 실시간 통계 활성화
ALTER TABLE ORD INMEMORY;
ALTER TABLE CUST INMEMORY;

-- 실시간 통계 확인
SELECT table_name, stale_stats
FROM user_tab_statistics
WHERE table_name IN ('ORD', 'CUST');
```

## 11. 실행 계획 안정화를 위한 전략

### SQL 계획 관리(SQL Plan Management)

```sql
-- SQL 계획 기준선(SQL Plan Baseline) 활성화
EXEC DBMS_SPM.CONFIGURE('AUTO_CAPTURE_SQL_PLAN_BASELINES', 'TRUE');

-- 현재 SQL의 계획 기준선 확인
SELECT sql_handle, plan_name, enabled, accepted
FROM dba_sql_plan_baselines
WHERE sql_text LIKE '%SELECT c.region%';
```

### SQL 프로파일(SQL Profile)

```sql
-- SQL 튜닝 세션 실행
DECLARE
  tuning_task VARCHAR2(30);
BEGIN
  tuning_task := DBMS_SQLTUNE.CREATE_TUNING_TASK(
    sql_text => 'SELECT c.region, SUM(o.amount) FROM CUST c JOIN ORD o ON o.cust_id = c.cust_id WHERE c.region = :1 GROUP BY c.region',
    bind_list => sql_binds(anydata.ConvertVarchar2('KOR')),
    scope => 'COMPREHENSIVE',
    time_limit => 60
  );
  DBMS_SQLTUNE.EXECUTE_TUNING_TASK(tuning_task);
END;
/

-- 튜닝 결과 확인
SELECT dbms_sqltune.report_tuning_task('튜닝_태스크_이름') FROM dual;
```

## 12. 종합 성능 분석 리포트

```sql
-- 종합 성능 분석 쿼리
WITH sql_stats AS (
  SELECT sql_id, child_number,
         executions,
         buffer_gets,
         disk_reads,
         elapsed_time/1000000 as elapsed_sec,
         ROW_NUMBER() OVER (ORDER BY elapsed_time DESC) as rank
  FROM v$sql
  WHERE last_active_time > SYSDATE - 1
  AND executions > 0
),
plan_stats AS (
  SELECT s.sql_id, s.child_number,
         p.operation, p.options, p.object_name,
         p.cardinality as estimated_rows,
         p.last_output_rows as actual_rows
  FROM v$sql_plan_statistics_all p
  JOIN sql_stats s ON s.sql_id = p.sql_id 
                    AND s.child_number = p.child_number
  WHERE p.id = 0  -- 최상위 연산자
)
SELECT s.rank,
       s.sql_id,
       s.executions,
       ROUND(s.buffer_gets/s.executions) as buffers_per_exec,
       ROUND(s.elapsed_sec/s.executions, 3) as sec_per_exec,
       p.estimated_rows,
       p.actual_rows,
       CASE 
         WHEN p.actual_rows = 0 THEN 0
         ELSE ROUND(ABS(p.estimated_rows - p.actual_rows)/p.actual_rows*100, 1)
       END as estimation_error_percent
FROM sql_stats s
JOIN plan_stats p ON p.sql_id = s.sql_id 
                   AND p.child_number = s.child_number
WHERE s.rank <= 10
ORDER BY s.rank;
```

## 13. 일반적인 문제 진단 및 해결 절차

### 문제 진단 체크리스트

1. **SQL 구문 검토**
   - SARGable 조건 사용 여부
   - 암시적 형 변환 존재 여부
   - 비효율적인 함수 사용 확인

2. **인덱스 분석**
   - 적절한 인덱스 존재 여부
   - 클러스터링 팩터 값 확인
   - 인덱스 통계 현황 점검

3. **통계 정보 검증**
   - 테이블 통계 최신성 확인
   - 히스토그램 필요성 판단
   - 확장 통계 적용 여부

4. **실행 계획 비교**
   - 예상 행 수 vs 실제 행 수 비교
   - 비용 계산 정확성 평가
   - 적응형 플랜 영향 분석

5. **시스템 환경 점검**
   - 옵티마이저 모드 설정 확인
   - 파라미터 설정 적절성 평가
   - 병렬 처리 설정 검토

## 결론

옵티마이저의 행동을 이해하고 효과적으로 관리하기 위해서는 다각적인 접근이 필요합니다. 성공적인 데이터베이스 성능 관리를 위한 핵심 원칙을 정리하면 다음과 같습니다:

### 1. 통계 정보 관리의 중요성
옵티마이저는 정확한 통계 정보를 기반으로 최적의 실행 계획을 선택합니다. 자동 통계 수집을 기본으로 하되, 특수한 경우에는 수동 통계 관리를 통해 정확성을 보장해야 합니다. 히스토그램과 확장 통계는 데이터 분포가 불균일하거나 컬럼 간 상관 관계가 있을 때 필수적입니다.

### 2. SQL 구문 최적화
SARGable 조건을 사용하고, 불필요한 형 변환을 피하며, 적절한 조인 방법을 선택하는 것이 기본입니다. SQL의 형태 자체가 옵티마이저의 선택을 제한할 수 있음을 인지해야 합니다.

### 3. 물리적 데이터 구조 설계
인덱스, 파티셔닝, IOT(인덱스 구성 테이블) 등 물리적 구조는 성능의 기초를 형성합니다. 클러스터링 팩터와 같은 세부적인 특성까지 고려한 설계가 필요합니다.

### 4. 적응형 기능의 현명한 활용
적응형 쿼리 최적화, 자동 인덱싱, 실시간 통계 등 최신 기능들은 성능을 크게 향상시킬 수 있지만, 올바른 이해와 관리가 필요합니다. 이러한 기능들을 블랙박스로 사용하기보다는 동작 원리를 이해하고 모니터링해야 합니다.

### 5. 실행 계획 안정화
프로덕션 환경에서는 실행 계획의 안정성이 매우 중요합니다. SQL 계획 관리, 프로파일, 패치 등을 활용하여 예측 가능한 성능을 유지해야 합니다.

### 6. 체계적인 모니터링과 분석
실행 계획 분석, 실제 성능 측정, 문제 패턴 인식을 통한 지속적인 개선이 필요합니다. 옵티마이저의 결정을 이해하고, 필요할 때는 힌트를 통해 적절히 유도할 수 있는 능력이 중요합니다.

옵티마이저는 복잡한 시스템이지만, 체계적인 접근과 지속적인 학습을 통해 효과적으로 관리할 수 있습니다. 각 요소들이 서로 어떻게 상호작용하는지 이해하고, 실제 성능 데이터를 기반으로 한 과학적인 접근이 성공적인 데이터베이스 성능 관리의 핵심입니다.