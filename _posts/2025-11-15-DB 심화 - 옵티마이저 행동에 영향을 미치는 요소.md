---
layout: post
title: DB 심화 - 옵티마이저 행동에 영향을 미치는 요소
date: 2025-11-15 17:25:23 +0900
category: DB 심화
---
# 옵티마이저 행동에 영향을 미치는 요소 (Oracle 기준 종합 가이드)

모든 예제는 **Oracle** 기준이며, 실행 후에는 다음으로 **실측 플랜**을 확인하세요.

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'));
```

---

## 0) 공통 실습 스키마 (간단)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

-- 기초 테이블
DROP TABLE CUST PURGE;
DROP TABLE ORD  PURGE;
DROP TABLE PROD PURGE;

CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  NAME    VARCHAR2(50) NOT NULL,
  REGION  VARCHAR2(8),
  TIER    VARCHAR2(8)  -- 'VIP','GOLD','SILVER','GEN'
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  ORDER_DT DATE   NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,
  BRAND    VARCHAR2(12) NOT NULL
);

-- 샘플 데이터
BEGIN
  FOR c IN 1..10000 LOOP
    INSERT INTO CUST VALUES(
      c, 'N'||c,
      CASE MOD(c,5) WHEN 0 THEN 'KOR' WHEN 1 THEN 'APAC' WHEN 2 THEN 'EMEA' WHEN 3 THEN 'AMER' ELSE 'JPN' END,
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR o IN 1..60000 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,10000)+1,
      DATE '2024-01-01' + MOD(o,180),
      ROUND(DBMS_RANDOM.VALUE(1,9999),2)
    );
  END LOOP;

  FOR p IN 1..10000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD' WHEN 2 THEN 'TOY' WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 2500 THEN 'B0' ELSE 'B'||TO_CHAR(MOD(p,50)) END
    );
  END LOOP;
  COMMIT;
END;
/

-- 인덱스
CREATE INDEX IX_CUST_REGION ON CUST(REGION, CUST_ID);
CREATE INDEX IX_ORD_CUST_DT ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_PROD_CAT    ON PROD(CATEGORY, PROD_ID);

-- 통계
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# **SQL과 연산자 형태**: SARGability(인덱스 사용 가능성)와 변환

옵티마이저는 **표현식 형태**에 매우 민감합니다. 같은 의미라도 **인덱스 사용 가능성(SARGability)**, **선택도 추정**이 크게 달라집니다.

## SARGable vs Non-SARGable 패턴

- **좋음**: `col = :b`, `col BETWEEN :b1 AND :b2`, `col >= :b`, `col LIKE 'ABC%'`
- **나쁨**: `FUNCTION(col) = :b`, `TO_CHAR(date_col, 'YYYYMM') = :b`, `col + 1 = :b`, `LIKE '%XYZ'` (앞 와일드카드)

### 예제: 함수 가공을 컬럼 쪽이 아닌 상수 쪽으로 이동

```sql
-- 나쁨(인덱스 무력화 가능성 높음)
SELECT *
FROM   ORD
WHERE  TO_CHAR(order_dt,'YYYYMM') = '202403';

-- 좋음(범위조건으로 변환)
SELECT *
FROM   ORD
WHERE  order_dt >= DATE '2024-03-01'
AND    order_dt <  DATE '2024-04-01';
```

### 예제: 묵시적 형변환(Implicit Conversion) 주의

```sql
-- :b 가 VARCHAR2이고 ORDER_ID는 NUMBER일 때
-- 나쁨: WHERE order_id = :b  -- 문자열→숫자 변환 방식에 따라 함수 적용으로 인덱스 무력화
-- 좋음: WHERE order_id = TO_NUMBER(:b)
```

### 예제: NOT IN(NULL) vs NOT EXISTS

```sql
-- 위험: 서브쿼리 결과에 NULL이 있으면 항상 FALSE
SELECT *
FROM   CUST c
WHERE  c.cust_id NOT IN (SELECT o.cust_id FROM ORD o);

-- 안전: NOT EXISTS
SELECT *
FROM   CUST c
WHERE  NOT EXISTS (SELECT 1 FROM ORD o WHERE o.cust_id = c.cust_id);
```

## OR → UNION ALL, IN-LIST, OR-Expansion

```sql
-- OR 조건으로 인덱스 못 타는 경우 → UNION ALL 로 분해
SELECT /*+ NO_MERGE */ * FROM CUST WHERE region = 'KOR'
UNION ALL
SELECT /*+ NO_MERGE */ * FROM CUST WHERE tier   = 'VIP';
```
- 옵티마이저가 자동으로 **OR-Expansion** 할 수도 있지만, 명시 분해가 명확할 때도 있음.

## 스칼라 서브쿼리 vs 조인

- 스칼라 서브쿼리는 **캐시**될 수 있어 반복 참조에 유리.
- 하지만 대량이면 **조인**이 더 유리할 수 있음 → **실측**으로 결정.

---

# **인덱스**: 구조, 클러스터링 팩터, 함수기반 인덱스, Skip Scan
## 기본/결합/커버링

```sql
-- 결합 인덱스: (CUST_ID, ORDER_DT)
CREATE INDEX IX_ORD_CUST_DT ON ORD(CUST_ID, ORDER_DT);

-- 커버링: 필요한 컬럼이 인덱스에 모두 있으면 Table Access 생략 가능
```

## 클러스터링 팩터(Clustering Factor, CF)

- **CF가 낮을수록**(인덱스 순서 ≈ 테이블 물리 순서) **랜덤 I/O 감소** → NL Random Access 비용↓.
- 대량 랜덤 액세스가 있으면 **CF 개선**(리빌드/CTAS, IOT, 파티션 정렬 로드 등) 고려.

## 함수 기반 인덱스(FBI)로 SARGability 확보

```sql
-- 전화번호 표준화 비교를 위한 FBI
CREATE INDEX IX_CUST_PHONE_NORM ON CUST( REGEXP_REPLACE(name,'[^0-9]') );

-- 쿼리
SELECT /*+ INDEX_FFS(c IX_CUST_PHONE_NORM) */
       *
FROM   CUST c
WHERE  REGEXP_REPLACE(name,'[^0-9]') = '01012345678';
```

## Index Skip Scan (선행 컬럼이 등치가 아닐 때)

```sql
-- 인덱스 (REGION, CUST_ID)만 있어도 REGION 조건 없이 CUST_ID만으로 Skip Scan 시도 가능
EXPLAIN PLAN FOR
SELECT * FROM CUST WHERE cust_id BETWEEN 100 AND 200;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
- **선행 컬럼의 NDV가 낮고** 후행 조건이 튼튼하면 Skip Scan이 선택될 수도 있음.

---

# **IOT/클러스터링**: 저장 구조가 비용에 미치는 영향
## IOT(Index-Organized Table)

- PK 순서로 **데이터 자체가 인덱스 리프에 저장** → **PK 기반 랜덤 액세스가 매우 싸짐**.
- **세컨더리 인덱스**는 Logical Rowid(키 기반)로 다시 PK를 찾아감.

```sql
DROP TABLE ORD_IOT PURGE;
CREATE TABLE ORD_IOT(
  ORDER_ID NUMBER,
  CUST_ID  NUMBER,
  ORDER_DT DATE,
  AMOUNT   NUMBER(12,2),
  CONSTRAINT PK_ORD_IOT PRIMARY KEY(ORDER_ID)
) ORGANIZATION INDEX;

-- PK 기반 조회 비교
SELECT * FROM ORD     WHERE order_id = 123;  -- 힙
SELECT * FROM ORD_IOT WHERE order_id = 123;  -- IOT(더 유리)
```

**언제 유리?**
- PK 기반 조회 많음, **좁은 로우**, 업데이트 적음(리프 split 비용 고려).

## 클러스터 테이블(Index/Hash Cluster)

- **Cluster Key**로 **물리적 근접성** 제공 → **동일 키 다건 조회**에 유리.
- 인덱스 클러스터는 키당 체인(블록 그룹), 해시 클러스터는 O(1) 접근 기대(버킷 관리 필요).

---

# **파티셔닝**: Pruning/Local Index/병렬
## 파티션 프루닝

```sql
-- RANGE 파티션 예시 (개략)
-- CREATE TABLE ORD_PART (...) PARTITION BY RANGE(ORDER_DT) (PARTITION p202401 VALUES LESS THAN (...), ...)

-- 프루닝 유도: 파티션 키를 SARGable 범위로
SELECT SUM(amount)
FROM   ORD_PART
WHERE  order_dt >= DATE '2024-03-01'
AND    order_dt <  DATE '2024-04-01';
```

## 글로벌/로컬 인덱스

- **로컬 인덱스**: 파티션별 관리 쉬움, 프루닝과 동일 정렬 → **병렬/관리성 우수**.
- **글로벌 인덱스**: 범위를 넘어선 질의가 많을 때 유리하나 **재빌드 관리 비용**.

## 파티션 조인/병렬

- 동일 키 파티셔닝이면 **Partition-Wise Join** → **데이터 재분배 없이** 조인.
- 해시/리스트/컴포짓 파티셔닝으로 확장성 확보.

---

# **MV(Materialized View) & Query Rewrite**
## MV로 집계/조인 결과 캐시

```sql
-- 월/카테고리 집계를 MV로
DROP MATERIALIZED VIEW SALES_MV;
CREATE MATERIALIZED VIEW SALES_MV
BUILD IMMEDIATE
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE
AS
SELECT TRUNC(o.order_dt,'MM') AS mon,
       p.category,
       SUM(o.amount) AS amt
FROM   ORD o
JOIN   PROD p ON p.prod_id = MOD(o.order_id,10000)+1   -- 데모용 매핑
GROUP  BY TRUNC(o.order_dt,'MM'), p.category;

-- 쿼리 리라이트 사용
ALTER SESSION SET query_rewrite_enabled = TRUE;
ALTER SESSION SET query_rewrite_integrity = TRUSTED;

-- 원본 쿼리(기본 테이블 대상)라도 MV로 Rewrite 가능
SELECT TRUNC(order_dt,'MM') mon, category, SUM(amount)
FROM   ORD o JOIN PROD p ON p.prod_id = MOD(o.order_id,10000)+1
GROUP  BY TRUNC(order_dt,'MM'), category;
```
- **조건**: MV 로그/동등 집계/함수 결정성 등. **REFRESH FAST**가 되면 갱신 비용↓.

---

# **제약(Constraint)**: 카디널리티 추정/조인 제거/전개
## NOT NULL/UNIQUE/PK → **선택도/전개**

- `col IS NOT NULL`은 불필요(컬럼이 NOT NULL이면 필터 제거).
- PK/UK는 **유일성** → **카디널리티 1** 가정 → **Index Unique Scan** 선호.

## 외래키(FK)로 **조인 제거(Join Elimination)**

- 특정 컬럼만 필요하면 **FK/UK**에 의해 **불필요 조인** 제거 가능.

```sql
-- ORD.cust_id -> CUST.cust_id FK 가정 시
SELECT /* Join Elimination 가능 */ o.order_id
FROM   ORD o
JOIN   CUST c ON c.cust_id = o.cust_id
WHERE  o.order_id = 123;  -- c.* 참조가 없으면 조인 제거 후보
```

## 체크 제약(Check) → 범위 추정 도움

- 값 범위를 명확히 하면 선택도 추정 정확도 ↑.

---

# **옵티마이저 힌트**: 탐색공간 제어 도구

> 모드는 성향, **힌트는 명령**. 핵심만 고정할 때 사용.

### 조인 순서/메소드/액세스

```sql
SELECT /*+ ORDERED LEADING(c o) USE_NL(o) INDEX(c IX_CUST_REGION) */
       o.order_id
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
WHERE  c.region='KOR';
```

### 변환 제어

```sql
SELECT /*+ NO_MERGE(v) MATERIALIZE */ *
FROM (
  SELECT prod_id FROM PROD WHERE category='ELEC'
) v
JOIN ORD o ON o.order_id = v.prod_id; -- 데모용 매핑
```

### 카디널리티/선택도 힌트(최후수단)

```sql
SELECT /*+ CARDINALITY(c 10) */ * FROM CUST c WHERE c.region='KOR';
```
- 잘못 쓰면 악영향. 일시 대응으로만.

---

# **통계정보**: 객체/컬럼/히스토그램/확장/시스템
## 정기 수집

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE);
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE);
END;
/
```

## 히스토그램(스큐 반영)

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND'
  );
END;
/
```

## 확장 통계(컬럼 그룹/표현식)

```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'ORD','(CUST_ID, ORDER_DT)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD');
END;
/
```

## 시스템 통계

- CPU/IO 속성 반영. 스토리지/서버 교체 시 재수집 권장.

---

# **옵티마이저 관련 파라미터**: 행동 성향과 한계

> 일부는 버전별 의미/기본값이 다릅니다. 전역 변경은 신중히.

| 파라미터 | 요지/영향 |
|---|---|
| `optimizer_mode` | `ALL_ROWS`(처리량) vs `FIRST_ROWS_n`(초기응답) |
| `optimizer_dynamic_sampling` | 통계 불충분 시 샘플 수준 |
| `optimizer_features_enable` | **버전별 옵티마이저 기능 묶음**(회귀 회피용) |
| `cursor_sharing` | `EXACT`/`FORCE`/`SIMILAR`(바인드 치환 행동; 플랜 안정성/선택도 영향) |
| `parallel_degree_policy` | AUTO/ADAPTIVE 등 병렬 자동화 |
| `result_cache_mode` | FORCE/MANUAL(결과 캐시) |
| `query_rewrite_enabled` | MV Query Rewrite 활성화 |
| `statistics_level` | BASIC/TYPICAL/ALL (구체 통계/추적 수준) |

### 예제: 모드 전환

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;
-- 또는
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;
```

### 예제: Dynamic Sampling

```sql
ALTER SESSION SET optimizer_dynamic_sampling = 4;
```

### 예제: Cursor Sharing(주의)

```sql
ALTER SYSTEM SET cursor_sharing = FORCE;  -- 전역 영향 매우 큼(신중)
```

---

# **DBMS 버전/에디션/종류**: 기능/코스트모델/적응성 차이

- **버전 차이**:
  - **Query Transformation** 범위(뷰 머지, OR-Expansion),
  - **Adaptive Plans / Statistics Feedback**,
  - **Auto DOP/병렬 코스트** 변화,
  - **JSON, In-Memory, Zone Maps, Automatic Indexing** 등 **새 기능**의 코스트 모델 반영.
- **에디션/옵션**: Partitioning, Advanced Compression, In-Memory, Advanced Analytics, Real Application Clusters(RAC)… 사용 가능 여부에 따라 옵티마이저 선택지 자체가 달라짐.
- **타 DBMS**(Oracle vs PostgreSQL vs MySQL 등): 용어/코스트 모델/통계/플랜 안정화 메커니즘 상이. (본 문서는 Oracle 전제)

**운영 팁**
- 업그레이드 시 **`optimizer_features_enable`**로 **구버전 호환 모드**를 사용해 **플랜 회귀 테스트** → 점진 전환.
- 주요 SQL은 **Baseline/Profile/Patch**로 **플랜 고정/유도**.

---

# 종합 실습: 요소별 영향 관찰

## SQL 형태(함수/형변환) 수정 효과

```sql
-- A) 형변환/함수 적용
EXPLAIN PLAN FOR
SELECT /* bad */ COUNT(*) FROM ORD WHERE TO_CHAR(order_dt,'YYYYMM')='202403';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- B) 범위조건으로 변환
EXPLAIN PLAN FOR
SELECT /* good */ COUNT(*) FROM ORD
WHERE order_dt >= DATE '2024-03-01' AND order_dt < DATE '2024-04-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 히스토그램에 따른 플랜 변화

```sql
-- 빈도 높은 BRAND=B0 vs 낮은 BRAND=B47 비교
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', method_opt=>'FOR COLUMNS SIZE 254 BRAND');
END;
/

EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 모드 변화

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;
SELECT /* all_rows */ COUNT(*) FROM CUST WHERE region='KOR';

ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;
SELECT /* first_rows */ COUNT(*) FROM CUST WHERE region='KOR';
```

## 힌트로 핵심만 고정

```sql
SELECT /*+ ORDERED LEADING(c o) USE_NL(o) INDEX(c IX_CUST_REGION) */
       SUM(o.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
WHERE  c.region='KOR'
AND    o.order_dt >= DATE '2024-03-01'
AND    o.order_dt <  DATE '2024-04-01';
```

## 파티션 프루닝(개념 시연)

```sql
-- 파티션 테이블이라 가정: 프루닝 유도 범위
SELECT SUM(amount)
FROM   ORD_PART
WHERE  order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
```

## MV Query Rewrite(개념 시연)

```sql
ALTER SESSION SET query_rewrite_enabled = TRUE;
SELECT TRUNC(order_dt,'MM') mon, category, SUM(amount)
FROM   ORD o JOIN PROD p ON p.prod_id = MOD(o.order_id,10000)+1
GROUP  BY TRUNC(order_dt,'MM'), category;
```

---

# 체크리스트(현업용)

- [ ] **SQL 형태**: 함수/형변환을 **상수 쪽**에, **범위/등치**로 SARGability 확보.
- [ ] **인덱스 설계**: 결합 순서·커버링·FBI·Skip Scan 가능성·**클러스터링 팩터** 점검.
- [ ] **IOT/클러스터**: PK 랜덤 액세스가 핵심이면 IOT 검토.
- [ ] **파티셔닝**: 프루닝/로컬 인덱스/Partition-Wise Join/병렬.
- [ ] **MV/Rewrite**: 빈번 집계/조인을 MV로 캐시, FAST REFRESH 설계.
- [ ] **제약**: NOT NULL/PK/UK/FK를 **정확히 선언**해 Join Elimination/카디널리티 정확화.
- [ ] **힌트**: 조인 순서/메소드/액세스만 **최소한** 고정, 변환 제어는 **정확히 이해하고 사용**.
- [ ] **통계**: 정기 수집 + **히스토그램/확장통계**로 스큐/상관관계 반영, 시스템 통계 최신화.
- [ ] **파라미터**: `optimizer_mode`, `optimizer_dynamic_sampling`, `cursor_sharing` 등은 **세션 단위**로 실험 후 반영.
- [ ] **버전 차이**: 업그레이드 시 **플랜 회귀 테스트**, Baseline/Profile로 주요 SQL 보호.

---

## 결론

옵티마이저의 선택은 **식의 형태**, **저장/물리 구조**, **통계**, **업무 목표(모드)**, **버전 기능**에 의해 달라집니다.
정답은 하나가 아니라 **데이터/워크로드/목표 응답**에 따라 다릅니다.
**SARGable SQL + 올바른 인덱스/파티션 + 최신 통계**를 기본으로, 필요 시 **힌트/Rewrite/MV/구조적 개선**을 더해
**I/O 최소화와 안정적 플랜**을 달성하세요.
