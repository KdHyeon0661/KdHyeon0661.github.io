---
layout: post
title: DB 심화 - 옵티마이저 행동에 영향을 미치는 요소
date: 2025-11-15 17:25:23 +0900
category: DB 심화
---
# 옵티마이저 행동에 영향을 미치는 요소

> 목표: “같은 SQL인데 왜 플랜이 다르지?”를 **원인별로 분해**하고,
> 각 원인이 **CBO(비용 기반 옵티마이저)** 의 의사결정(카디널리티/비용/변환/조인 선택)에
> 어떻게 연결되는지 **재현 가능한 예제**로 끝까지 설명한다.
>
> 아래 모든 예제는 Oracle 기준. 실행 후에는 **실측 플랜**으로 반드시 검증한다.
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS +NOTE +ALIAS'
));
```

---

## 0) 공통 실습 스키마(사용자 초안 유지)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

DROP TABLE CUST PURGE;
DROP TABLE ORD  PURGE;
DROP TABLE PROD PURGE;

CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  NAME    VARCHAR2(50) NOT NULL,
  REGION  VARCHAR2(8),
  TIER    VARCHAR2(8)  -- 'VIP','GOLD','SILVER','GEN'
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  ORDER_DT DATE   NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,
  BRAND    VARCHAR2(12) NOT NULL
);

BEGIN
  FOR c IN 1..10000 LOOP
    INSERT INTO CUST VALUES(
      c, 'N'||c,
      CASE MOD(c,5)
        WHEN 0 THEN 'KOR'
        WHEN 1 THEN 'APAC'
        WHEN 2 THEN 'EMEA'
        WHEN 3 THEN 'AMER'
        ELSE 'JPN'
      END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP'
        WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER'
        ELSE 'GEN'
      END
    );
  END LOOP;

  FOR o IN 1..60000 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,10000)+1,
      DATE '2024-01-01' + MOD(o,180),
      ROUND(DBMS_RANDOM.VALUE(1,9999),2)
    );
  END LOOP;

  FOR p IN 1..10000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC'
        WHEN 1 THEN 'FOOD'
        WHEN 2 THEN 'TOY'
        WHEN 3 THEN 'HOME'
        ELSE 'FASH'
      END,
      CASE WHEN p <= 2500 THEN 'B0'
           ELSE 'B'||TO_CHAR(MOD(p,50))
      END
    );
  END LOOP;
  COMMIT;
END;
/

CREATE INDEX IX_CUST_REGION ON CUST(REGION, CUST_ID);
CREATE INDEX IX_ORD_CUST_DT ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_PROD_CAT    ON PROD(CATEGORY, PROD_ID);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE,
    method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE,
    method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE,
    method_opt=>'for all columns size skewonly');
END;
/
```

---

## 1) SQL/연산자 형태 — SARGability, 변환, 의미 보존

옵티마이저는 **“의미가 같아도 형태가 다르면 비용이 달라진다”**는 전제에서 움직인다.
형태가 달라지면 다음이 바뀐다:

1) **인덱스 사용 가능성(SARGability)**
2) **선택도/카디널리티 추정(히스토그램·NDV·확장통계 소재)**
3) **쿼리 변환 가능성(언네스트, OR-EXPAND, 프레디킷 이동, 조인 제거 등)**
4) **Adaptive 계획/통계 피드백 개입 가능성**

### SARGable vs Non-SARGable

**SARGable(S**earch **ARG**ument-able)**:**
인덱스가 “범위/등치”로 직접 잡힐 수 있는 형태.

- 좋음:
  `col = :b`, `col BETWEEN :b1 AND :b2`, `col >= :b`, `col LIKE 'ABC%'`
- 나쁨:
  `FUNCTION(col)=:b`, `col+1=:b`, `TO_CHAR(date_col,'YYYYMM')=:b`, `LIKE '%XYZ'`

#### 예: 컬럼 가공 → 상수 가공으로 이동

```sql
-- Non-SARGable: 컬럼에 함수 적용
EXPLAIN PLAN FOR
SELECT *
FROM   ORD
WHERE  TO_CHAR(order_dt,'YYYYMM') = '202403';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- SARGable: 범위 조건
EXPLAIN PLAN FOR
SELECT *
FROM   ORD
WHERE  order_dt >= DATE '2024-03-01'
AND    order_dt <  DATE '2024-04-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**관찰 포인트**
- 첫 쿼리는 종종 **INDEX RANGE SCAN 불가 → FTS/FFS**로 기운다.
- 둘째는 **ORDER_DT가 인덱스 후행**이더라도
  `IX_ORD_CUST_DT`의 범위/필터 결합 가능성이 생긴다.

### 형 변환과 암묵적 함수

Oracle은 타입이 안 맞으면 **암묵적 변환(implicit conversion)** 을 한다.
이때 변환이 “컬럼 쪽”에 붙으면 **함수 적용 컬럼**이 되어 인덱스를 못 탄다.

```sql
-- :b 가 VARCHAR2, ORDER_ID가 NUMBER라 가정
-- 위험: 컬럼쪽 변환이 발생할 수 있음
EXPLAIN PLAN FOR
SELECT * FROM ORD WHERE order_id = :b;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 안전: 상수 바인드를 숫자로 변환
EXPLAIN PLAN FOR
SELECT * FROM ORD WHERE order_id = TO_NUMBER(:b);
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### NOT IN vs NOT EXISTS (3-valued logic)

```sql
-- 위험: 서브쿼리에 NULL 포함 시 전체가 FALSE가 될 수 있음
SELECT *
FROM   CUST c
WHERE  c.cust_id NOT IN (SELECT o.cust_id FROM ORD o);

-- 안전
SELECT *
FROM   CUST c
WHERE  NOT EXISTS (SELECT 1 FROM ORD o WHERE o.cust_id = c.cust_id);
```

옵티마이저는 의미상 안전한 쪽으로
**Anti-Join(NOT EXISTS)** 변환을 더 잘 수행한다.

### OR 조건, IN-LIST, OR-Expansion

OR는 “인덱스 경로를 막는” 대표 패턴이지만,
Oracle은 조건에 따라 OR-Expansion(UNION ALL 분해)을 자동 수행한다.

```sql
-- 자동 OR-EXPAND가 안 뜨면 명시 분해
EXPLAIN PLAN FOR
SELECT * FROM CUST WHERE region='KOR' OR tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT /*+ NO_MERGE */ * FROM CUST WHERE region='KOR'
UNION ALL
SELECT /*+ NO_MERGE */ * FROM CUST WHERE tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**언제 분해가 유리한가**
- 각 OR 분기에서 **서로 다른 인덱스**가 강하게 효율적일 때
- 분기별 선택도가 낮아 **각각 인덱스 범위 스캔이 싼** 구조일 때

### 스칼라 서브쿼리 vs 조인

스칼라 서브쿼리는 **결과 캐시(Scalar Subquery Caching)** 로
반복 참조가 있으면 유리할 수 있다.
하지만 대량 매칭에서는 조인이 낫다.

```sql
-- 스칼라 서브쿼리
SELECT o.order_id,
       (SELECT c.tier FROM CUST c WHERE c.cust_id=o.cust_id) AS tier
FROM ORD o;

-- 조인
SELECT o.order_id, c.tier
FROM ORD o JOIN CUST c ON c.cust_id=o.cust_id;
```

**결론은 실측**.
카디널리티가 폭증하면 스칼라 캐시가 깨진다.

---

## 2) 인덱스 — 구조, CF, FBI, Skip Scan, In-Memory/자동 인덱싱

인덱스는 단순 “빠른 길”이 아니라
**CBO 탐색공간을 바꾸는 구조물**이다.

### 결합 인덱스와 “선행컬럼 조건”의 의미

```sql
-- (CUST_ID, ORDER_DT)
CREATE INDEX IX_ORD_CUST_DT ON ORD(CUST_ID, ORDER_DT);
```

- 선행 컬럼(CUST_ID)에 등치가 있으면
  후행 컬럼 ORDER_DT까지 **정교한 범위 스캔**이 가능.
- 선행 조건이 없으면 후행만으로 RANGE SCAN이 어렵다.
  대신 **Skip Scan/Index FFS**가 후보가 된다.

### Clustering Factor(CF)

CF는 “인덱스 순서가 테이블 물리 순서와 얼마나 맞는가”를 나타내며,
NL 조인에서 테이블 랜덤 액세스 비용을 결정하는 핵심 통계다.

```sql
SELECT index_name, clustering_factor, num_rows
FROM user_indexes
WHERE table_name='ORD';
```

- **CF ≈ NUM_ROWS** (나쁨)
  → 인덱스로 찍는 행들이 테이블 여기저기 흩어짐
  → 테이블 fetch가 **랜덤 I/O**
  → 옵티마이저는 NL 비용을 크게 보고 HASH로 기운다.
- **CF ≪ NUM_ROWS** (좋음)
  → fetch가 연속에 가깝게 모여서 싸다
  → NL/인덱스 경로가 훨씬 유리해질 수 있다.

**개선 전략**
1) CTAS + ORDER BY로 물리 정렬 후 인덱스 생성
2) IOT(아래 3절)
3) 파티션 정렬 로드
4) 클러스터 테이블

### 함수 기반 인덱스(FBI)

SARGability를 회복하려고 **FBI**를 쓰는 패턴.

```sql
CREATE INDEX IX_CUST_NAME_NORM ON CUST( UPPER(NAME) );

EXPLAIN PLAN FOR
SELECT /*+ INDEX(c IX_CUST_NAME_NORM) */
       *
FROM   CUST c
WHERE  UPPER(c.name) = 'N100';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**주의**
- FBI에 쓰는 함수는 **DETERMINISTIC**(같은 입력→같은 출력)이어야 의미가 성립.
- NLS 설정/시간대/세션 파라미터에 의존하는 함수면 플랜·결과가 흔들린다.

### Index Skip Scan

선행 컬럼 조건이 없더라도
**선행 NDV가 낮고 후행 조건이 강하면** Skip Scan을 선택할 수 있다.

```sql
EXPLAIN PLAN FOR
SELECT * FROM CUST WHERE cust_id BETWEEN 100 AND 200;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Automatic Indexing(19c+)

Oracle 19c부터 **자동 인덱싱**이 도입되어
워크로드를 보고 인덱스를 만들고, 효과 없으면 제거한다.

- 성능이 튀는 시스템에서
  “내가 만든 적 없는 인덱스가 생겼다”면 자동 인덱싱을 확인.
- 자동 인덱싱은 **CBO 탐색공간 자체를 바꾼다**는 점이 핵심.

---

## 3) 저장 구조(IOT/Cluster/Heap) — 랜덤 비용의 근본

### IOT(Index-Organized Table)

PK 순서로 데이터가 리프 블록에 저장된다.
→ PK 기반 랜덤 액세스가 “인덱스+테이블 fetch”가 아니라
**인덱스 리프만 읽고 끝**.

```sql
DROP TABLE ORD_IOT PURGE;

CREATE TABLE ORD_IOT(
  ORDER_ID NUMBER,
  CUST_ID  NUMBER,
  ORDER_DT DATE,
  AMOUNT   NUMBER(12,2),
  CONSTRAINT PK_ORD_IOT PRIMARY KEY(ORDER_ID)
) ORGANIZATION INDEX;

EXPLAIN PLAN FOR SELECT * FROM ORD     WHERE order_id=123;
EXPLAIN PLAN FOR SELECT * FROM ORD_IOT WHERE order_id=123;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**언제 쓰나**
- PK 단건/소수건 랜덤 조회가 핵심
- 로우가 좁고 업데이트가 적은 테이블

### Index/Hash Cluster

Cluster Key로 물리적 근접성을 제공
→ 동일 키 다건 조회, 스타 조인 패턴에서 유리.

---

## 4) 파티셔닝 — Pruning/Local Index/Partition-Wise Join/병렬

파티셔닝은 단순 관리 기능이 아니라
**CBO 비용 모델의 “입력 크기”를 직접 줄이는 장치**다.

### 프루닝(Partition Pruning)

가장 중요한 규칙은
**파티션 키를 SARGable 범위로 써야 프루닝이 된다**.

```sql
-- RANGE 파티션된 ORD_PART라 가정
EXPLAIN PLAN FOR
SELECT SUM(amount)
FROM   ORD_PART
WHERE  order_dt >= DATE '2024-03-01'
AND    order_dt <  DATE '2024-04-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Local vs Global Index

- **Local Index**
  - 각 파티션에 1:1 대응
  - 프루닝과 “같이 잘린다”
  - 관리/병렬/재빌드가 쉬움
- **Global Index**
  - 전체 범위를 커버
  - 파티션 경계 넘어가는 질의에 강함
  - 파티션 유지보수 때 인덱스 unusable 위험

### Partition-Wise Join

두 테이블이 같은 키로 파티셔닝돼 있으면
**각 파티션끼리 독립 조인** 가능 → 데이터 재분배 비용이 크게 줄어든다.

---

## 5) MV/Query Rewrite — “같은 의미의 더 싼 답”

MV는 “사전 계산된 결과”다.
Query Rewrite를 켜면, 옵티마이저는
**원본 테이블을 읽지 않고 MV로 대체**할 수 있다.

```sql
DROP MATERIALIZED VIEW SALES_MV;

CREATE MATERIALIZED VIEW SALES_MV
BUILD IMMEDIATE
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE
AS
SELECT TRUNC(o.order_dt,'MM') AS mon,
       p.category,
       SUM(o.amount) AS amt
FROM   ORD o
JOIN   PROD p ON p.prod_id = MOD(o.order_id,10000)+1
GROUP  BY TRUNC(o.order_dt,'MM'), p.category;

ALTER SESSION SET query_rewrite_enabled = TRUE;
ALTER SESSION SET query_rewrite_integrity = TRUSTED;

EXPLAIN PLAN FOR
SELECT TRUNC(o.order_dt,'MM') mon, p.category, SUM(o.amount)
FROM   ORD o JOIN PROD p ON p.prod_id = MOD(o.order_id,10000)+1
GROUP  BY TRUNC(o.order_dt,'MM'), p.category;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**Rewrite가 성공하려면**
- 동등 집계/조인 형태
- 결정적(deterministic) 함수
- 무결성 수준(TRUSTED/ENFORCED) 조건 충족

---

## 6) 제약(Constraints) — 카디널리티·조인 제거·변환의 기반

제약은 단순 무결성 체크가 아니라
옵티마이저에게 **“논리적 사실”을 알려주는 통계급 정보**다.

### NOT NULL/PK/UK

- NOT NULL이면 `col IS NOT NULL` 조건은 제거 후보.
- PK/UK는 유일성
  → 조인 카디널리티를 1로 예측
  → Index Unique Scan/Join Elimination에 결정적.

### Join Elimination (FK/UK 기반)

```sql
-- ORD.cust_id -> CUST.cust_id FK 존재 가정
EXPLAIN PLAN FOR
SELECT o.order_id
FROM   ORD o JOIN CUST c ON c.cust_id=o.cust_id
WHERE  o.order_id = 123;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

c 컬럼을 안 쓰면
옵티마이저가 FK/UK를 근거로 **조인을 제거**할 수 있다.

### RELY / NOVALIDATE

DW에서 흔한 패턴:

- 데이터는 믿지만(ETL 보증)
- 운영 검증 비용은 아까워서

`RELY DISABLE NOVALIDATE`로 제약을 “힌트처럼” 준다.
→ 옵티마이저는 믿고 변환/조인 제거를 할 수 있다.

---

## 7) 통계(Statistics) — 객체/히스토그램/확장/시스템/실시간

통계는 CBO 의사결정의 입력이다.
자세한 내용은 앞선 통계 가이드와 동일 원리다.

### AUTO_SAMPLE_SIZE가 중요한 이유

AUTO_SAMPLE_SIZE일 때만
**Top-Frequency/Hybrid 히스토그램이 생성**될 수 있다.

### 확장 통계(Extended Stats)

컬럼 상관관계를 반영해 결합 선택도를 교정한다.

```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
```

### Dynamic Statistics / OPTIMIZER_DYNAMIC_SAMPLING

통계가 부족하거나 복잡한 조건일 때
파스 시점에 샘플을 떠서 선택도를 보정한다.

```sql
ALTER SESSION SET optimizer_dynamic_sampling = 4;

EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM ORD
WHERE amount BETWEEN 10 AND 20
  AND order_dt >= DATE '2024-03-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Real-Time Statistics & High-Frequency Stats Gathering (19c+)

대량 DML/로드 직후 통계 공백을 줄이기 위해

- **Real-Time Statistics**: DML 중 즉시 통계 생성
- **High-Frequency Stats Task**: 자동 통계 수집 빈도 증가

가 도입되었다.

실전에서
“배치 직후 플랜이 틀어졌다”가 줄어드는 이유가 여기 있다.

---

## 8) Adaptive Query Optimization — 실행 중 플랜 조정

Oracle은 **Adaptive Plans/Statistics Feedback**으로
실행 중 실제 행(A-Rows)이 추정보다 크게 빗나가면
남은 단계의 결정을 바꿀 수 있다.

- Adaptive Plan: 실행 중 조인 방법/분기 선택
- Statistics Feedback(카디널리티 피드백): 다음 하드파스에 추정을 보정
- SQL Plan Directives(SPD): 반복 오판 패턴을 기록해 차후 통계 수집을 유도

**제어**
```sql
-- (버전별로 일부는 통합/대체됨)
ALTER SESSION SET optimizer_adaptive_statistics = FALSE;
```
이 파라미터를 끄면
SPD/조인 피드백/적응 샘플링 일부가 비활성화된다.
(현업에서는 “문제 진단/회귀 대응” 목적 외 장기 OFF는 신중)

---

## 9) 힌트(Hints) — 탐색공간을 ‘명령’으로 자르는 도구

힌트는 “성향”이 아니라 **강제**다.

```sql
SELECT /*+ LEADING(c o) USE_NL(o) INDEX(c IX_CUST_REGION) */
       SUM(o.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id=c.cust_id
WHERE  c.region='KOR';
```

### 변환 제어 힌트

- `MERGE / NO_MERGE`
- `INLINE / MATERIALIZE`
- `NO_QUERY_TRANSFORMATION`

이들은 **쿼리 변환 단계 자체를 막거나 강제**한다.

---

## 10) SQL Plan Management / Profiles / Patches — 플랜 안정화

“좋은 플랜을 **고정**하거나,
나쁜 플랜을 **자동 회피**”하는 메커니즘.

### SQL Plan Baseline(SPM)

- 검증된 플랜만 사용
- 새 플랜은 “accepted” 될 때만 교체

### SQL Profile

- SQL 단위의 보조 통계/힌트 세트
- 카디널리티 오판 교정 목적

### SQL Patch

- 작은 힌트 묶음으로 플랜만 조정

### Real-Time SPM (23ai)

23ai에서는 플랜 회귀를 실시간 감지해
**자동으로 baseline을 만들고 회귀를 복구**하는 RT-SPM이 강화됐다.

---

## 11) 병렬(Parallel) — DOP 정책이 플랜 후보를 바꾼다

병렬은 비용 산정과 전략이 완전히 바뀐다.

- 테이블/인덱스 Parallel Degree
- `parallel_degree_policy=AUTO/MANUAL`
- `PQ_DISTRIBUTE`, `PARALLEL`, `NO_PARALLEL` 힌트

AUTO면
옵티마이저가 “혼자 병렬이 이득이다”라고 판단하면
사용자 의도 없이도 병렬 플랜이 나올 수 있다.

```sql
ALTER SESSION SET parallel_degree_policy = AUTO;

EXPLAIN PLAN FOR
SELECT SUM(amount) FROM ORD WHERE order_dt >= DATE '2024-03-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## 12) 옵티마이저 파라미터 — ‘성향’과 ‘가드레일’

전역 변경은 매우 위험하다.
가능하면 **세션에서 실험 → 근거 확보 후 제한적 적용**.

| 파라미터 | 요지 | 주의 |
|---|---|---|
| `optimizer_mode` | ALL_ROWS(처리량) / FIRST_ROWS_n(초기응답) | 목표가 바뀌면 조인/인덱스 선택도 바뀜 |
| `optimizer_dynamic_sampling` | Dynamic Statistics 수준 | 과하면 파스 비용↑  |
| `optimizer_features_enable` | 버전별 옵티마이저 기능 묶음 | 회귀 대응용. 상시 고정은 지양  |
| `cursor_sharing` | EXACT / FORCE | 바인드 치환으로 선택도/플랜 흔들림 가능  |
| `statistics_level` | BASIC/TYPICAL/ALL | 진단/실측과 직결 |
| `query_rewrite_enabled` | MV Rewrite on/off | MV 기반 성능 전략과 연결 |
| `result_cache_mode` | FORCE/MANUAL | 결과 캐시가 비용 모델에 반영 |

예:

```sql
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;
ALTER SESSION SET optimizer_dynamic_sampling = 4;
```

---

## 13) 버전/옵션 차이 — “같은 SQL이 다른 이유”의 큰 축

Oracle은 버전이 바뀔 때마다

- 쿼리 변환 범위(뷰 머징, 언네스트, OR-Expansion)
- Adaptive 최적화
- 히스토그램 내부 모델
- Real-Time/High-Frequency 통계
- Automatic Indexing/Automatic SPM

이 달라진다.

업그레이드 시
- 테스트 없이 OFE를 구버전으로 고정하는 건 최후수단이며,
- **SPM/Baseline으로 핵심 SQL을 보호**하면서 점진 전환하는 게 정석이다.

---

## 14) 종합 실습 시나리오 — 요소별로 플랜이 어떻게 바뀌는지 “연쇄” 관찰

### SQL 형태 → 경로 변화

```sql
EXPLAIN PLAN FOR
SELECT /* bad */ COUNT(*)
FROM ORD
WHERE TO_CHAR(order_dt,'YYYYMM')='202403';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT /* good */ COUNT(*)
FROM ORD
WHERE order_dt >= DATE '2024-03-01'
  AND order_dt <  DATE '2024-04-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 히스토그램 → 선택도 변화

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt=>'FOR COLUMNS SIZE 254 BRAND');
END;
/

EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
EXPLAIN PLAN FOR SELECT COUNT(*) FROM PROD WHERE BRAND='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 모드 변화 → 목표 응답 변화

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;
EXPLAIN PLAN FOR SELECT COUNT(*) FROM CUST WHERE region='KOR';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;
EXPLAIN PLAN FOR SELECT COUNT(*) FROM CUST WHERE region='KOR';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 힌트로 핵심만 고정

```sql
EXPLAIN PLAN FOR
SELECT /*+ LEADING(c o) USE_NL(o) INDEX(c IX_CUST_REGION) */
       SUM(o.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id=c.cust_id
WHERE  c.region='KOR'
AND    o.order_dt >= DATE '2024-03-01'
AND    o.order_dt <  DATE '2024-04-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## 15) 실무 체크리스트(원인→조치)

1) **SQL 형태**
   - 함수/형변환은 상수 쪽으로
   - 파티션 키는 범위조건으로
   - OR는 필요시 UNION ALL 분해
2) **인덱스**
   - 선행 컬럼 설계
   - CF/NDV/Leaf Blocks를 보고 NL vs HASH 판단 근거 확보
   - FBI로 SARGability 복구
   - 자동 인덱싱 켜져 있으면 영향 범위를 파악
3) **저장 구조**
   - PK 랜덤 단건이 핵심이면 IOT 검토
4) **파티셔닝**
   - 프루닝/로컬 인덱스/Partition-Wise Join/증분 통계
5) **MV/Rewrite**
   - 반복 집계/조인은 MV로 치환
6) **제약**
   - PK/UK/FK/NOT NULL을 정확히 선언(조인 제거·추정 개선)
7) **통계**
   - AUTO_SAMPLE_SIZE
   - 스큐: 히스토그램
   - 상관: 확장 통계
   - 배치 직후: Real-Time/수동 보강
8) **Adaptive/플랜 안정화**
   - 오판이 반복되면 SPD/Adaptive 확인
   - 핵심 SQL은 Baseline/Profile/Patch로 보호
9) **파라미터**
   - 전역 변경은 최후수단
   - 세션 실험→근거→제한적 적용
10) **항상 실측**
   - E-Rows와 A-Rows가 맞지 않으면 모든 추론이 무너진다.

---

## 맺음말

옵티마이저는 **통계와 SQL 형태를 바탕으로 “탐색공간”을 만들고**,
그 안에서 **가장 싼 비용의 플랜을 고르는 엔진**이다.
따라서 성능을 지배하는 것은 힌트 한 줄이 아니라,

- **SARGable한 SQL**
- **올바른 인덱스/저장/파티션 구조**
- **현실을 반영한 통계(AUTO_SAMPLE_SIZE, 히스토그램, 확장, 실시간)**
- **버전/Adaptive 메커니즘 이해와 플랜 안정화(SPM/Profile)**

이 네 축이다.
이 축을 먼저 정비하고, 힌트는 마지막에 “핵심만” 고정하는 도구로 쓰는 게
가장 재현성 있고 안전한 튜닝 방법이다.
