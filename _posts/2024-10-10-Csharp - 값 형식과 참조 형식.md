---
layout: post
title: C# - 값 형식과 참조 형식
date: 2024-10-10 18:20:23 +0900
category: Csharp
---
# 값 형식과 참조 형식

기존에 작성한 값 형식과 참조 형식(struct vs class) 섹션을 더욱 정확하고 깊이 있게 보강했습니다. 특히 `struct`의 메모리 할당 위치가 변수에 따라 달라진다는 점, 최신 C# 기능(`readonly struct`, `ref struct`, 매개변수 없는 생성자), `string`의 불변성, 제네릭과 박싱의 관계 등을 추가하여 실무와 면접 대비에 부족함이 없도록 했습니다.

---

## 6. 값 형식과 참조 형식 (struct vs class)

C#에서 모든 타입은 **값 형식(Value Type)** 과 **참조 형식(Reference Type)** 으로 구분됩니다. 이 차이는 메모리 할당 위치, 복사 방식, 성능, 그리고 객체의 동작 방식에 큰 영향을 미칩니다. 클래스(`class`)는 참조 형식이고, 구조체(`struct`)는 값 형식입니다.

### 값 형식 (struct)

- `struct`, `enum`, 그리고 기본 타입(`int`, `bool`, `double` 등)이 값 형식에 속합니다.
- **변수에는 실제 값이 직접 저장**됩니다.
- 다른 변수에 할당하면 **값이 복사**됩니다. 즉, 완전히 독립적인 복사본이 생성됩니다.
- **메모리 위치는 변수가 선언된 위치에 따라 결정**됩니다.  
  - 지역 변수나 매개변수로 선언되면 **스택(Stack)** 에 저장됩니다.  
  - 클래스의 필드로 선언되면 해당 클래스 인스턴스와 함께 **힙(Heap)** 에 저장됩니다.  
  ➔ “struct는 항상 스택에 저장된다”는 오해를 피해야 합니다. 저장 위치는 변수의 수명과 종속성에 따라 달라집니다.

```csharp
public struct Point
{
    public int X;
    public int Y;
    
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
}

// 지역 변수: 스택에 저장
Point p1 = new Point(10, 20);

// 클래스 필드: 힙에 저장
class Wrapper
{
    public Point P; // 이 struct 인스턴스는 힙에 존재함
}
```

### 참조 형식 (class)

- `class`, `interface`, `delegate`, `string`, 배열 등이 참조 형식입니다.
- 변수에는 **힙에 할당된 객체의 참조(주소)** 가 저장됩니다.
- 다른 변수에 할당하면 **참조가 복사**됩니다. 두 변수는 동일한 객체를 가리키게 됩니다.
- 객체 자체는 항상 **힙(Heap)** 에 할당됩니다.

```csharp
public class PointClass
{
    public int X;
    public int Y;
    
    public PointClass(int x, int y)
    {
        X = x;
        Y = y;
    }
}

PointClass pc1 = new PointClass(10, 20);
PointClass pc2 = pc1; // 참조 복사 → 같은 객체
pc2.X = 99;
Console.WriteLine(pc1.X); // 99
```

### 메모리 위치: Stack vs Heap

| 구분 | Stack | Heap |
|------|-------|------|
| 할당 방식 | 함수 호출 시 생성, 반환 시 자동 해제 (LIFO) | `new`로 동적 할당, 가비지 컬렉터가 관리 |
| 속도 | 매우 빠름 | 상대적으로 느림 (할당/해제 비용) |
| 저장 대상 | 값 형식의 지역 변수, 참조 형식의 참조(주소) | 실제 객체 데이터, `static` 변수, 문자열 등 |
| 범위 | 스코프({ })를 벗어나면 즉시 해제 | 참조가 없어지면 GC가 수집 |

> 💡 `static` 변수는 힙의 특별한 영역(High Frequency Heap 등)에 저장되지만, 일반적으로 “힙에 저장된다”고 표현해도 무방합니다. 중요한 것은 `static` 필드가 프로그램 종료까지 유지된다는 점입니다.

### Boxing과 Unboxing

값 형식을 참조 형식(`object` 또는 인터페이스)으로 변환하거나 그 반대 과정에서 발생합니다.

- **Boxing**: 값 형식을 `object` 타입으로 변환하면 힙에 객체가 생성되고 값이 복사됩니다.
- **Unboxing**: 박싱된 객체에서 다시 값 형식으로 변환합니다.

```csharp
int number = 123;
object obj = number;   // Boxing: number가 힙에 복사됨
int unboxed = (int)obj; // Unboxing: 힙에서 값 추출
```

**박싱/언박싱은 성능 저하를 유발**하므로, 빈번한 변환이 필요한 경우 제네릭을 사용해야 합니다.  
✅ **제네릭 컬렉션(`List<T>`)은 박싱을 방지**합니다. `ArrayList` 같은 비제네릭 컬렉션은 값 형식을 추가할 때마다 박싱이 발생합니다.

```csharp
// 박싱 발생
ArrayList list = new ArrayList();
list.Add(10);          // int → object 박싱
int value = (int)list[0]; // 언박싱

// 박싱 없음
List<int> list2 = new List<int>();
list2.Add(10);         // 값 형식 그대로 저장
int value2 = list2[0]; // 언박싱 없음
```

### string은 참조 형식이지만 불변(immutable)하다

`string`은 참조 형식이지만, 한 번 생성된 문자열은 변경할 수 없는 **불변(immutable)** 객체입니다. 문자열을 변경하는 것처럼 보이는 연산은 실제로는 새로운 문자열 객체를 생성합니다. 또한 `string`은 값 형식처럼 동작하는 특성이 있어, 문자열 비교 시 내용을 비교합니다.

```csharp
string a = "Hello";
string b = a;          // 참조 복사 (같은 문자열 객체)
b = "World";           // 새 객체 생성 → a는 여전히 "Hello"
Console.WriteLine(a == b); // 내용 비교: false
```

### 메서드 매개변수와의 관계

값 형식을 매개변수로 전달할 때 기본적으로 **복사본**이 전달됩니다. 호출자 변수를 수정하려면 `ref`, `out`, `in` 키워드를 사용해야 합니다.

```csharp
public void ModifyValue(ref int x)
{
    x = 100;
}

int a = 10;
ModifyValue(ref a); // a는 100
```

`in` 매개변수는 읽기 전용 참조를 전달하여 값 형식의 복사를 방지합니다. 특히 큰 구조체에서 유용합니다.

```csharp
public double CalculateDistance(in Point p1, in Point p2)
{
    // p1, p2는 복사되지 않고 참조로 전달되며 읽기 전용
    return Math.Sqrt((p2.X - p1.X) * (p2.X - p1.X) + (p2.Y - p1.Y) * (p2.Y - p1.Y));
}
```

### 고급 struct 기능 (C# 7.0 이상)

#### readonly struct
구조체를 불변(immutable)으로 만들고 싶다면 `readonly struct`로 선언합니다. 모든 필드가 `readonly`여야 하며, 컴파일러가 최적화에 활용할 수 있습니다.

```csharp
public readonly struct Point
{
    public int X { get; }
    public int Y { get; }
    
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
}
```

#### ref struct
`ref struct`는 스택에만 존재할 수 있는 구조체입니다. 힙에 할당될 수 없으며, 클래스의 필드로 사용할 수 없습니다. `Span<T>`와 `ReadOnlySpan<T>`이 대표적인 예입니다.

```csharp
public ref struct MyRefStruct
{
    public int Value;
}

Span<int> span = stackalloc int[10]; // 스택에 배열 메모리 할당
```

#### C# 10: 구조체에 매개변수 없는 생성자 허용
C# 10부터 구조체에서 명시적인 매개변수 없는 생성자를 정의할 수 있습니다. 이 생성자는 `new StructType()` 호출 시 실행됩니다.

```csharp
public struct Point
{
    public int X;
    public int Y;
    
    public Point() // C# 10 가능
    {
        X = 0;
        Y = 0;
    }
    
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
}
```

### struct 사용 시 고려사항

- **크기가 작은**(보통 16바이트 이하) 데이터에 적합합니다. (`Point`, `Color`, `Complex` 등)
- **불변성**을 유지하면 예기치 않은 변경을 방지하고 안전성이 높아집니다. (`readonly struct` 권장)
- 상속이 불가능하며, `new` 없이도 생성 가능합니다. (단, 생성자를 정의하지 않아도 기본값 0으로 초기화)
- **메서드 내에서 변경해도 호출자에 영향을 주지 않음** (값 복사 특성) – 의도에 따라 장점이 될 수도, 단점이 될 수도 있습니다.

### class vs struct 선택 기준

| 상황 | class | struct |
|------|-------|--------|
| 크기가 큰 데이터 (수십 바이트 이상) | ✔️ (참조 복사 저렴) | ❌ (복사 비용 큼) |
| 상속이 필요한 경우 | ✔️ | ❌ (상속 불가) |
| 자주 변경되는 데이터 | ✔️ (참조 전달) | ⚠️ (복사 오버헤드) |
| 짧은 수명의 작은 데이터 | ❌ (GC 부하) | ✔️ (스택 할당 가능) |
| 다형성이 필요한 경우 | ✔️ | ❌ |
| 불변성이 중요한 작은 값 | △ (가능) | ✔️ (값 의미에 적합) |

### 성능 팁

- 구조체는 스택 할당으로 GC 부담이 없지만, **크기가 크면 복사 비용**이 증가합니다. 크기가 16바이트를 넘으면 성능이 오히려 나빠질 수 있습니다.
- `in` 매개변수로 값 형식을 전달하면 복사를 방지하여 성능을 개선할 수 있습니다.
- 박싱을 유발하는 코드(`ArrayList`, `Hashtable`) 대신 **제네릭 컬렉션**(`List<T>`, `Dictionary<TKey, TValue>`)을 사용하세요.
- `readonly struct`는 컴파일러가 방어적 복사를 생략할 수 있어 추가 최적화가 가능합니다.
- `ref struct`를 활용하면 스택 메모리를 안전하게 다룰 수 있어 고성능 시나리오에 유리합니다.