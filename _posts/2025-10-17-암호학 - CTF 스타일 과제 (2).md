---
layout: post
title: 암호학 - CTF 스타일 과제 (2)
date: 2025-10-17 18:30:23 +0900
category: 암호학
---
# 실습 랩 & CTF 스타일 과제 (2)
## 해시/충돌 놀이: 생일공격 시뮬, SHA-1 충돌 사례 읽기

> 목표: **(1)** 생일공격을 손으로 시뮬레이션하며 “충돌이 왜 생각보다 빨리 나오는지”를 **정량**으로 체감,
> **(2)** SHA-1 충돌/선택접두(CP) 충돌 사례를 **사례 연구**로 읽고, **운영 보안 규칙**(마이그레이션·정책)을 정리합니다.
> 환경은 **로컬 노트북**(Python 3.10+ 권장) 기준이며, Go/Rust 대체 코드도 함께 제공합니다.
> ⚠️ 모든 코드는 **교육용**. 실서비스는 6·12·13·17·18장에서 정리한 **표준 라이브러리/안전 레시피**만 사용하세요.

---

## ✅ A. 준비물 & 체크리스트

- 언어/도구: Python 3.10+ (또는 Go 1.21+ / Rust 1.77+), `pip install matplotlib tqdm` (선택)
- CPU가 1~2분 내 끝나는 **난이도 스케일**을 기본값으로 제시합니다. (비트 수를 늘리면 오래 걸립니다.)
- 공통 유틸(파이썬):
```python
import os, hashlib, secrets, time, math, random
def sha1(b: bytes) -> bytes: return hashlib.sha1(b).digest()
def sha256(b: bytes) -> bytes: return hashlib.sha256(b).digest()
def trunc(b: bytes, bits: int) -> int:
    n_bytes = (bits + 7) // 8
    x = int.from_bytes(b[:n_bytes], 'big')
    if bits % 8: x >>= (8 - (bits % 8))
    return x
```

---

## ✅ B. 이론 스케치: 왜 “루트(공간크기)” 수준에서 부딪히는가?

- 해시 출력 공간 크기가 \(N=2^b\)일 때, **서로 다른 임의 입력**을 던지다 보면
  **첫 충돌까지의 기대 시도 횟수**는
  \[
    \mathbb{E}[T] \approx \sqrt{\frac{\pi N}{2}} \approx 1.253 \cdot 2^{b/2}.
  \]
- 성공 확률이 \(p\)가 되려면 대략
  \[
    q \approx \sqrt{2N \ln\frac{1}{1-p}} \quad (\text{예: }p=0.5 \Rightarrow q\approx 1.177\sqrt{N}).
  \]
- 직관: “**서랍장 원리** + **확률적 중복**” → **b비트 보안**을 얻으려면 충돌 관점에서는 **2b비트 키**가 필요해 보일 수 있음.
  그래서 **128비트 충돌 저항**을 원하면 **SHA-256** 같은 **≥256비트** 해시를 씁니다.

---

## ✅ C. 랩 1 — 생일공격 시뮬레이터(트렁케이션)

### C-1. 목표

- `SHA-256`을 `b`비트로 **잘라** 쓰면서(예: 16/20/24/28/32 bit),
  **실제 소요 시도 횟수 분포**를 실험하고 **이론값**과 비교합니다.

### C-2. 파이썬 코드

```python
from collections import defaultdict
def birthday_experiment(bits=24, trials=30, seed=None):
    rnd = random.Random(seed)
    stats = []
    for _ in range(trials):
        seen = {}
        attempts = 0
        while True:
            attempts += 1
            m = rnd.randbytes(16)  # 임의 128비트 입력
            h = trunc(sha256(m), bits)
            if h in seen:
                stats.append(attempts)
                break
            seen[h] = m
    return stats

def summary(stats, bits):
    avg = sum(stats)/len(stats)
    theo = math.sqrt(math.pi/2) * (2**(bits/2))
    return {
        "bits": bits,
        "trials": len(stats),
        "avg_attempts": avg,
        "theory": theo,
        "ratio_avg_over_theory": avg/theo
    }

for b in [16,20,24,28,32]:
    s = birthday_experiment(bits=b, trials=20, seed=42+b)
    print(summary(s, b))
```

### C-3. 분석 포인트

- `avg_attempts / theory`가 **≈1** 근처로 수렴하는지 확인.
- 분산이 큼(“운빨”) → **CTF 설계 시 시간 제한/시드 고정**이 중요.

### C-4. 선택: 분포 시각화

```python
import matplotlib.pyplot as plt
stats = birthday_experiment(bits=24, trials=200, seed=2025)
plt.hist(stats, bins=30); plt.title("Attempts until first collision (24-bit)"); plt.show()
```

---

## ✅ D. 랩 2 — **실제 충돌 찾기**: Truncated SHA-1/256 32비트

### D-1. 목표

- **32비트 트렁케이션**에서 **두 문자열 충돌**을 직접 찾습니다.
- 기대 시도 ≈ \(1.25 \cdot 2^{16} \approx 82\,k\) (메모리 맵 기반이면 수초~수십초대).

### D-2. 파이썬 코드 (해시: SHA-1 또는 SHA-256 선택)

```python
def find_collision(bits=32, algo="sha1", prefix=b"LAB2|"):
    H = sha1 if algo=="sha1" else sha256
    seen = {}
    attempts = 0
    while True:
        attempts += 1
        m = prefix + secrets.token_bytes(16)
        t = trunc(H(m), bits)
        if t in seen and seen[t] != m:
            return attempts, seen[t], m, t
        seen[t] = m

for algo in ["sha1","sha256"]:
    attempts, m1, m2, t = find_collision(bits=32, algo=algo, prefix=b"LAB2|")
    print(f"[{algo}] bits=32 attempts={attempts} tag=0x{t:08x}")
    # 검증
    assert trunc((sha1 if algo=="sha1" else sha256)(m1), 32) == \
           trunc((sha1 if algo=="sha1" else sha256)(m2), 32)
```

### D-3. CTF 과제 템플릿

- 제출: `m1.hex()`, `m2.hex()`, `bits=32`, `algo=sha1|sha256`, `tag_hex`.
- 채점: 서버가 **재해시**하여 `trunc(h(m1))==trunc(h(m2))` 확인.
- 보너스: **의미 있는 프레이즈**(ASCII)로 충돌 만들기(예: `b"pay=100"` vs `b"pay=200"`).
  → 이건 사실상 **선택접두 충돌** 난이도라 **bits를 더 낮춰(24-28)** 시도하세요.

---

## ✅ E. 랩 3 — 조우(Joux) 멀티충돌(토이 MD 해시)

> **아이디어**: Merkle–Damgård 구조 해시는 **한 번 충돌**을 만들면,
> 그 뒤엔 **각 라운드마다 한 쌍씩 충돌**을 더해 **\(2^k\)개 메시지를 같은 해시로** 만들 수 있습니다.
> (실제 SHA-1/256은 k가 커질수록 어렵지만, **토이 해시**로 원리를 체험.)

### E-1. 토이 해시 정의 (SHA-256 압축을 16~24비트로 잘라 MD처럼 사용)

```python
def toy_compress(h: int, block: bytes, bits=24) -> int:
    return trunc(sha256(h.to_bytes(4,'big') + block), bits)

def toy_md(msg: bytes, iv=0, bits=24, block_size=8) -> int:
    h = iv
    for i in range(0, len(msg), block_size):
        block = msg[i:i+block_size].ljust(block_size, b'\x00')
        h = toy_compress(h, block, bits=bits)
    return h
```

### E-2. 한 라운드 충돌 찾기

```python
def compress_collision(h, bits=24):
    seen = {}
    while True:
        b = secrets.token_bytes(8)
        t = toy_compress(h, b, bits)
        if t in seen and seen[t]!=b:
            return (seen[t], b, t)
        seen[t] = b

def joux_multicollision(k=6, bits=24):
    h = 0
    pairs = []  # [(b0,b1), (c0,c1), ...]
    for _ in range(k):
        b0, b1, h_next = compress_collision(h, bits)
        pairs.append((b0,b1))
        h = h_next
    # 모든 조합을 연결해 2^k개의 메시지 생성
    msgs = [b""]
    for (x,y) in pairs:
        msgs = [m+x for m in msgs] + [m+y for m in msgs]
    return h, msgs
```

### E-3. 실험

```python
h, msgs = joux_multicollision(k=6, bits=24)
print("final digest:", h, " #msgs:", len(msgs))
assert len(set(toy_md(m, bits=24) for m in msgs)) == 1
```

**토론 포인트**
- 멀티충돌은 **충돌 저항성**을 약화시켜 **구성(proof-of-work 변형, 인증 구조)**에 **연쇄 영향**을 줍니다.
- **실제 SHA-1/256**에서 이런 공격은 **현대 파라미터에서는 어려움**이지만,
  설계시 “MD계열의 구조적 위험”을 알고 **HAIFA/샐팅·도메인분리** 등을 적용합니다.

---

## ✅ F. 사례 연구 — SHA-1 충돌 & 선택접두(CP) 충돌

> **핵심 메시지**: **SHA-1은 충돌 안전하지 않음**.
> 일반 충돌(identical-prefix)도, 더 강한 **선택접두(Chosen-Prefix) 충돌**도 **현실적 공격**이 입증됐습니다.
> 운영 규칙: **서명·무결성·커밋 식별** 등 충돌 저항이 필요한 곳에서 **SHA-1 사용 금지**.
> (단, **HMAC-SHA-1**은 목적·모델상 여전히 안전하다고 평가되나, **새 설계는 SHA-256/3 권장**.)

### F-1. 일반 충돌(Identical-Prefix collision)

- 아이디어: **동일한 접두부** 뒤에 **두 개의 특수 블록열**을 붙여 **동일 SHA-1**을 만들기.
- 공개 사례: 서로 다른 PDF 두 개가 **같은 SHA-1**을 가지도록 생성된 데모(“비트 플립된 페이지”).

**교훈**
- **파일 지문**으로 SHA-1을 쓰면 **위조 가능**. 저장소(아티팩트)·무결성 검증에 위험.

### F-2. 선택접두(Chosen-Prefix) 충돌

- 더 강함: 공격자가 **서로 다른 접두부 \(P, P'\)** 를 **임의로 선택**한 뒤, 각각에 **보정 블록 \(S, S'\)** 를 붙여
  \(\mathrm{SHA1}(P \parallel S) = \mathrm{SHA1}(P' \parallel S')\) 를 달성.
- 응용 공격: **X.509 인증서 템플릿** 두 종류, **PGP 키**, **Git 객체** 등 “**프리앰블이 다른**” 구조에서도 **악의적 동일 해시**로 혼란 유발 가능.
  (현대 Git은 **SHA-256 전환/방어 로직**을 포함해 대응 중. 새 저장소는 **SHA-256** 권장.)

**교훈**
- “서명이 해시에 의존”하는 시스템(코드사인/PKI/커밋ID)은 **SHA-1 금지**.
- 마이그레이션: **SHA-256/384/512 or SHA-3**로 단계적 이전, **객체 포맷 전환 플랜** 마련.

---

## ✅ G. 랩 4 — “작은” 선택접두 충돌의 감각(토이 해시)

> 실제 SHA-1 CP 충돌은 고난도 연구 성과입니다. 대신 **토이 해시(24-28bit)**로 **개념 실습**만 해봅니다.

### G-1. 목표

- 서로 다른 접두 `P, P'`를 임의로 고르고, 뒤에 붙일 꼬리 `S, S'`를 탐색해
  `toy_md(P || S) == toy_md(P' || S')` 달성.

### G-2. meet-in-the-middle(미티M) 스케치

```python
def prefix_state(prefix: bytes, bits=24): return toy_md(prefix, bits=bits)

def chosen_prefix_collision(bits=24, budget=1_000_000):
    P  = b"Alice: pay=100"
    Pp = b"Bob:   pay=200"
    hL = prefix_state(P, bits)
    hR = prefix_state(Pp, bits)

    L = {}
    for _ in range(budget//2):
        s = secrets.token_bytes(8)
        L[toy_compress(hL, s, bits)] = s

    for _ in range(budget//2):
        s = secrets.token_bytes(8)
        y = toy_compress(hR, s, bits)
        if y in L:
            return (P, L[y], Pp, s, y)
    return None

res = chosen_prefix_collision(bits=24, budget=2_000_000)
if res:
    P, S, Pp, Sp, h = res
    assert toy_md(P+S, bits=24)==toy_md(Pp+Sp, bits=24)==h
```

**토론**
- 실제 SHA-1 CP 충돌은 **차분 경로·메시지 수정 자유도**·GPU 병렬화 등 복잡한 기법이 필요.
- 그러나 개념적으로 **“서로 다른 접두부에서 같은 내부 상태에 수렴”**시키는 관점은 동일.

---

## ✅ H. CTF 세트 (자동 채점 아이디어 포함)

### H-1. CHAL-01 “빠른 손” — 24-bit 충돌

- **입력**: 서버가 `ctx`(임의 8바이트)를 준다.
- **목표**: 60초 내 `m1 != m2` 이면서 `trunc(SHA-256(ctx||m1), 24) == trunc(SHA-256(ctx||m2), 24)`.
- **풀이 힌트**: 해시 테이블 2^12~2^13개 시도면 평균 히트.

### H-2. CHAL-02 “의미 있는 충돌” — 28-bit, ASCII

- **목표**: 사람이 읽히는 `b"from=alice&to=bob&amt=XXX"` vs `amt=YYY` 충돌.
- **힌트**: 고정 필드를 두고 **패딩 필드**(`&pad=...`)에 난수; bits를 24로 낮추면 체감 쉽고, 28로 도전 난이도↑.

### H-3. CHAL-03 “멀티충돌 데모”

- **목표**: 토이 MD(24bit)에서 **k=6** 멀티충돌(64개 메시지 동해시) 생성, 모든 메시지와 최종 해시 제출.
- **채점**: 서버가 `toy_md` 재계산.

### H-4. (보너스) “짧은 CP-Collision”

- **목표**: G-2 코드 변형으로 서로 다른 두 접두 문자열에 대해 24bit CP 충돌 제출.

---

## ✅ I. 운영 보안 가이드(바로 적용)

- **SHA-1 금지**: 파일/커밋/서명/메시지 무결성에 **SHA-1 더 이상 사용하지 않기**.
  - 해시 지문: **SHA-256/384/512 또는 SHA-3**.
  - Git/아티팩트: **SHA-256 리포지토리/인덱스** 전환 플랜.
- **HMAC-SHA-1**: 설계 상 안전하지만 **신규는 SHA-256**로. 수명/호환 때문에 남겨야 한다면 **명시적 예외 관리**.
- **길이 확장 공격 방지**: “해시만으로 MAC 만들지 않기(6장: HMAC/KMAC)”.
- **도메인 분리**: 같은 해시를 커밋·널리파이어·머클 등 여러 목적에 **재사용 금지**(prefix/tag 부여).
- **증거 가능한 마이그레이션**: 해시 함수 전환 시 **해시+메타데이터 동시 저장**(구/신 해시 병행) 기간 운영.

---

## ✅ J. 결과 제출 양식(샘플)

```json
{
  "team": "crypto-cats",
  "chal": "CHAL-02",
  "hash": "sha256",
  "bits": 28,
  "ctx_hex": "61b2...",
  "m1_hex": "666f726d3d616c69636526746f3d626f6226616d743d313030267061643d...",
  "m2_hex": "666f726d3d616c69636526746f3d626f6226616d743d323030267061643d...",
  "tag_hex": "0x0badbeef"
}
```
- 채점 서버는 `trunc(SHA-256(ctx||m1), bits) == trunc(SHA-256(ctx||m2), bits)` 확인.

---

## ✅ K. Go / Rust 대체 스니펫

### K-1. Go (충돌 탐색 32bit)

```go
package main
import ("crypto/sha1"; "crypto/sha256"; "crypto/rand"; "fmt")
func trunc32(b []byte) uint32 { return uint32(b[0])<<24 | uint32(b[1])<<16 | uint32(b[2])<<8 | uint32(b[3]) }
func find(bits uint, useSHA1 bool) (int, []byte, []byte, uint32) {
    seen := map[uint32][]byte{}
    attempts := 0
    for {
        m := make([]byte, 16); rand.Read(m); attempts++
        var t uint32
        if useSHA1 { t = trunc32(sha1.Sum(m)[:]) } else { t = trunc32(sha256.Sum256(m)[:]) }
        if v, ok := seen[t]; ok && string(v) != string(m) { return attempts, v, m, t }
        seen[t] = m
    }
}
func main() {
    a, m1, m2, t := find(32, true)
    fmt.Printf("[sha1] attempts=%d tag=%08x\n", a, t)
    _, _, _ = m1, m2, t
}
```

### K-2. Rust (멀티충돌 토이)

```rust
use sha2::{Digest, Sha256};
use rand::RngCore;
fn trunc24(h: &[u8]) -> u32 { ((h[0] as u32)<<16)|((h[1] as u32)<<8)|(h[2] as u32) }
fn toy_compress(state: u32, block: &[u8]) -> u32 {
    let mut hasher = Sha256::new();
    hasher.update(state.to_be_bytes());
    hasher.update(block);
    trunc24(&hasher.finalize())
}
fn main() {
    let mut rng = rand::thread_rng();
    let mut h: u32 = 0;
    let mut pairs: Vec<(Vec<u8>,Vec<u8>)> = vec![];
    for _ in 0..6 {
        use std::collections::HashMap;
        let mut seen: HashMap<u32,Vec<u8>> = HashMap::new();
        loop {
            let mut b = vec![0u8;8]; rng.fill_bytes(&mut b);
            let t = toy_compress(h, &b);
            if let Some(prev)=seen.get(&t) {
                pairs.push((prev.clone(), b.clone())); h = t; break;
            }
            seen.insert(t, b);
        }
    }
    // 조합 메시지 생략 (원리 동일)
    println!("final state={:06x}, pairs={}", h, pairs.len());
}
```

---

## ✅ L. 리뷰 질문(자기 점검)

1) `b=32` 트렁케이션에서 충돌을 찾는 평균 시도 횟수는? **근거**와 함께.
2) 멀티충돌(Joux)의 아이디어를 한 문단으로 설명하고, 왜 “구성에 취약점”이 되는지 예를 들어라.
3) **선택접두 충돌**의 위력이 일반 충돌과 다른 이유는 무엇인가? 현실 시스템 예를 하나 들어라.
4) 조직의 **SHA-1 제거 플랜**을 5단계로 요약하고, **이행 증적**은 무엇을 남길지 써라.
5) HMAC-SHA-1과 SHA-1(순수 해시)의 보안 의미 차이를 간단 비교하라.

---

## ✅ M. 요약 카드

- **생일경계**: 충돌은 **≈1.25·2^{b/2}** 시도면 나온다 — 체감 실험으로 확인.
- **트렁케이션**은 데모용일 뿐이며, **실서비스에선 충분히 긴 해시**(SHA-256/3) 사용.
- **SHA-1**: **충돌/선택접두 충돌** 모두 **현실적** — 무결성/서명에 **금지**, 마이그레이션 필수.
- **운영**: 도메인 분리·길이 확장 방지·해시 전환 **증거화**.
