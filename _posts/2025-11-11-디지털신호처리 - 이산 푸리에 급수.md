---
layout: post
title: 디지털신호처리 - 이산 푸리에 급수
date: 2025-11-11 16:25:23 +0900
category: 디지털신호처리
---
# 이산 푸리에 급수(DFS)

## 0. 맥락과 목표
앞서 정리한 **DTFT**, **차분방정식/LTI**, **양측 Z-변환·역 Z-변환**을 바탕으로, 이번 글은 **주기적 이산 신호**의 완전한 스펙트럼 표현인 **이산 푸리에 급수(DFS)**를 정리한다. 한 주기(길이 \(N\))의 표본들만 알면, 신호는 **정확히 \(N\)개의 복소지수 기저**로 표현된다. 본 글은 수식과 **GNU Octave** 코드로 모든 정리를 검증한다.

---

## 1. 정의와 기본 등식(복소지수형)

### 1.1 가정과 표기
- \(x[n]\)은 정수 \(N\)에 대해 **주기적**: \(x[n]=x[n+N]\).
- 기저: \(\phi_k[n]=e^{j\frac{2\pi}{N}kn}\), \(k=0,\dots,N-1\).

### 1.2 합성(전개)
$$
x[n]=\sum_{k=0}^{N-1} c_k\, e^{j\frac{2\pi}{N}kn},\qquad n\in\mathbb{Z}.
$$

### 1.3 분석(계수)
$$
c_k=\frac{1}{N}\sum_{n=0}^{N-1} x[n]\; e^{-j\frac{2\pi}{N}kn},\qquad k=0,\dots,N-1.
$$

> **DFT와의 스케일**: DFT \(X[k]=\sum_{n=0}^{N-1} x[n]e^{-j\frac{2\pi}{N}kn}\) 이므로
> $$c_k=\frac{1}{N}X[k].$$

### 1.4 직교성(핵심 항등)
$$
\sum_{n=0}^{N-1} e^{j\frac{2\pi}{N}(k-\ell)n}=
\begin{cases}
N, & k\equiv \ell\;(\mathrm{mod}\ N),\\
0, & k\not\equiv \ell\;(\mathrm{mod}\ N).
\end{cases}
$$
이로부터 **분석/합성의 역관계**와 **직교 정규 기저** 성질이 즉시 따른다.

---

## 2. 실수 신호의 켤레대칭·실수형 전개

### 2.1 켤레대칭
실수 \(x[n]\)이면
$$
c_k=c^\ast_{(-k)\ (\mathrm{mod}\ N)}.
$$
따라서 스펙트럼 크기는 대칭, 위상은 부호 반전된다.

### 2.2 코사인/사인 전개(짝수 \(N\))
\(k=0\)과 \(k=N/2\)는 실수항(DC·Nyquist):
$$
x[n]=a_0+a_{N/2}(-1)^n+\sum_{k=1}^{N/2-1}\big(A_k\cos\tfrac{2\pi k}{N}n + B_k\sin\tfrac{2\pi k}{N}n\big),
$$
계수 관계:
\[
c_k=\tfrac{1}{2}(A_k-jB_k),\quad c_{N-k}=\tfrac{1}{2}(A_k+jB_k).
\]

---

## 3. DFS의 기본 성질(시간/주파수 연산)

### 3.1 선형성
$$
x=\alpha u+\beta v\ \Rightarrow\ c^{(x)}_k=\alpha c^{(u)}_k+\beta c^{(v)}_k.
$$

### 3.2 시간 시프트(원형)
$$
y[n]=x[(n-n_0)\ \mathrm{mod}\ N]\ \Rightarrow\ c^{(y)}_k=c^{(x)}_k e^{-j\frac{2\pi}{N}kn_0}.
$$

### 3.3 주파수 시프트(지수 곱)
$$
y[n]=x[n]\,e^{j\frac{2\pi}{N}m_0 n}\ \Rightarrow\ c^{(y)}_k=c^{(x)}_{(k-m_0)\ (\mathrm{mod}\ N)}.
$$

### 3.4 시간 반전
$$
y[n]=x[-n\ (\mathrm{mod}\ N)]\ \Rightarrow\ c^{(y)}_k=c^{(x)}_{(-k)\ (\mathrm{mod}\ N)}.
$$

### 3.5 Parseval(평균 에너지 보존)
$$
\frac{1}{N}\sum_{n=0}^{N-1}|x[n]|^2=\sum_{k=0}^{N-1}|c_k|^2.
$$

### 3.6 원형 컨볼루션 정리
주기 \(N\) 원형 컨볼루션 \(y=x\overset{N}{\circledast}h\)에 대해
$$
c^{(y)}_k=N\,c^{(x)}_k\,c^{(h)}_k.
$$
(DFT 관점에서는 \(Y[k]=X[k]H[k]\)와 동일; 단 \(X[k]=N c_k\).)

---

## 4. DTFT·DFT·Z-변환과의 연결

### 4.1 DFT ↔ DFS
$$
X[k]=\sum_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N}kn},\qquad c_k=\frac{1}{N}X[k].
$$
**DFT는 DFS 계수의 비정규화**일 뿐이며, 한 주기 데이터를 쓰면 재구성이 정확하다.

### 4.2 DTFT(라인 스펙트럼)
\(x\)가 \(N\)-주기라면
$$
X(e^{j\omega})=2\pi\sum_{m=-\infty}^{\infty} c_{(m\ \mathrm{mod}\ N)}\,\delta\!\Big(\omega-\frac{2\pi m}{N}\Big).
$$
DFS 계수=DTFT의 **라인 진폭/위상**.

### 4.3 Z-변환
단위원 \(z=e^{j\omega}\)에서의 샘플이 DTFT이며, DFS/DFT는 단위원의 **등간격 샘플**로 해석된다.

---

## 5. 행렬 관점과 고유벡터 해석

### 5.1 DFT 행렬
크기 \(N\)의 행렬 \(F\)를
\[
F_{k,n}=e^{-j\frac{2\pi}{N}kn},\quad 0\le k,n\le N-1
\]
로 두면 \(X=Fx\), \(x=\frac{1}{N}F^\ast X\). \(F/\sqrt{N}\)은 단위행렬에 유사(unitary).

### 5.2 원형 시프트의 대각화
원형 시프트 연산자는 \(F\)로 **대각화**되며, 고유값이 \(e^{-j2\pi k/N}\). 따라서 **원형 LTI**는 DFS(=DFT)에서 대각선 상수배가 되어 조화별 독립 작동을 보인다.

---

## 6. 대표 신호의 DFS 계수(폐형식)

### 6.1 직사 펄스(폭 \(M\), 주기 \(N\))
\[
x[n]=\begin{cases}
1,& 0\le n\le M-1\\
0,&\text{else}
\end{cases},\quad x[n+N]=x[n].
\]
계수:
\[
c_k=\frac{1}{N}\sum_{n=0}^{M-1}e^{-j\frac{2\pi}{N}kn}
=\frac{1}{N}\,e^{-j\frac{\pi}{N}k(M-1)}\frac{\sin\big(\frac{\pi k M}{N}\big)}{\sin\big(\frac{\pi k}{N}\big)},\quad
c_0=\frac{M}{N}.
\]

### 6.2 임펄스열(주기 \(N\))
한 주기에서 \(x[0]=1\) 외 0 → \(c_k=\frac{1}{N}\) (평탄 스펙트럼).

### 6.3 복소지수
\(x[n]=e^{j\frac{2\pi}{N}m_0 n}\Rightarrow c_k=\delta[k-m_0\ (\mathrm{mod}\ N)]\).

---

## 7. GNU Octave 유틸(DFS 분석/합성)

```octave
function c = dfs_analyze(x)
  % x: length-N one-period row/col vector
  x = x(:).'; N = numel(x);
  n = 0:N-1; k = 0:N-1;
  W = exp(-1j*2*pi/N);
  c = zeros(1,N);
  for kk = 1:N
    c(kk) = (1/N) * sum( x .* (W.^((kk-1)*n)) );
  end
end

function xr = dfs_synthesize(c)
  c = c(:).'; N = numel(c);
  n = 0:N-1; k = 0:N-1;
  W = exp(1j*2*pi/N);
  xr = zeros(1,N);
  for nn = 1:N
    xr(nn) = sum( c .* (W.^((nn-1)*k)) );
  end
end
```

---

## 8. 기본 실습: 펄스열 — 수치/폐형식/재구성

```octave
clear; close all; clc
N=32; M=8; k=0:N-1;
x=zeros(1,N); x(1:M)=1;

c_num = dfs_analyze(x);
c_clo = zeros(1,N);
for kk=1:N
  if k(kk)==0
    c_clo(kk)=M/N;
  else
    c_clo(kk)=(1/N)*exp(-1j*pi*k(kk)*(M-1)/N)*sin(pi*k(kk)*M/N)/sin(pi*k(kk)/N);
  end
end
x_rec = dfs_synthesize(c_num);

subplot(2,2,1); stem(0:N-1,x,'filled'); grid on; title('x[n] (one period)');
subplot(2,2,2); stem(0:N-1,real(x_rec),'.'); grid on; title('Reconstruction');
subplot(2,2,3); stem(k,abs(c_num),'filled'); hold on; stem(k,abs(c_clo),'r.'); grid on
legend('|c_{num}|','|c_{closed}|'); title('Magnitude');
subplot(2,2,4); plot(k,angle(c_num),'o-'); grid on; title('Phase');

printf("Recon RMS = %.3e\n", rms(x - x_rec));
printf("Coeff RMS = %.3e\n", rms(c_num - c_clo));
```

**Parseval 확인**
```octave
E_t = (1/N)*sum(abs(x).^2);
E_f = sum(abs(c_num).^2);
printf("Parseval diff = %.3e\n", abs(E_t - E_f));
```

---

## 9. DFS–DFT 동일성 및 원형 컨볼루션

### 9.1 DFT로 DFS 계수 구하기
```octave
X = fft(x);
c_fft = X / N;                       % = c_num
printf("DFS via fft RMS = %.3e\n", rms(c_fft - c_num));
```

### 9.2 원형 컨볼루션 정리 검증
```octave
h = hamming(N)';                     % 예제 주기 필터
y = ifft( fft(x).*fft(h) );          % 원형 컨볼루션 결과
cx = dfs_analyze(x); ch = dfs_analyze(h); cy = dfs_analyze(y);
lhs = cy; rhs = N*cx.*ch;
printf("Circular conv DFS check RMS = %.3e\n", rms(lhs - rhs));
```

---

## 10. 실수 신호의 켤레대칭·실수형 전개 확인

```octave
clear; close all; clc
N=64; xr = randn(1,N); c = dfs_analyze(xr);
maxdev=0;
for k=0:N-1
  km = mod(-k,N);
  maxdev=max(maxdev, abs(c(k+1) - conj(c(km+1))));
end
printf("Conjugate symmetry max dev = %.2e\n", maxdev);
```

- 실무에서는 복소 계수 그대로 운용하는 것이 편리하며, 실수형 전개가 필요하면 \(A_k=2\Re c_k\), \(B_k=-2\Im c_k\)를 사용한다(짝수 \(N\)에서 \(k=0, N/2\)는 실수).

---

## 11. 부분합 재구성·Gibbs 현상 관찰

경계불연속(구형/펄스)을 **유한 조화수**로만 재구성하면 경계 근방 오버슈트/립플이 생긴다.

```octave
clear; close all; clc
N=128; M=32; n=0:N-1;
x=zeros(1,N); x(1:M)=1;
c=fft(x)/N;

Klist = [3,7,15,31];
for i=1:numel(Klist)
  K=Klist(i);
  cK = zeros(1,N);
  cK(1)=c(1);
  cK(2:K+1)=c(2:K+1);
  cK(end-K+1:end)=c(end-K+1:end);
  xK = dfs_synthesize(cK);
  subplot(numel(Klist),1,i);
  plot(n,x,'k'); hold on; plot(n,real(xK),'r'); grid on
  title(sprintf('Partial sum with K=%d',K));
end
```

---

## 12. 시간/주파수 시프트·반전 — 수치 검증

```octave
clear; close all; clc
N=64; x=randn(1,N); n0=5;
c=fft(x)/N;
xs=circshift(x,[0 n0]); cs=fft(xs)/N;
angdiff = unwrap(angle(cs)) - unwrap(angle(c));
plot(0:N-1, angdiff, 'o-'); grid on
title('Phase shift vs k ≈ -2πkn0/N');
```

주파수 시프트(지수 곱)과 시간 반전도 같은 방식으로 확인할 수 있다.

---

## 13. DFS로 보는 주기 LTI 시스템(대각화)

주기 \(N\) 원형 LTI \(y=x\overset{N}{\circledast}h\):
- DFS에서 조화별로 **스칼라 배율**:
  \[
  c_y[k]=N\,c_x[k]\,c_h[k],\quad \text{또는 } Y[k]=X[k]H[k].
  \]
- 조화 \(k\)는 서로 **간섭하지 않음**. 설계/분석이 단순해진다.

```octave
clear; close all; clc
N=64; n=0:N-1;
x = cos(2*pi*5*n/N) + 0.5*cos(2*pi*12*n/N);
h = fir1(15,0.3); h = [h zeros(1,N-numel(h))];
y = ifft( fft(x).*fft(h) );

cx=fft(x)/N; ch=fft(h)/N; cy=fft(y)/N;
printf("Diagonalization check RMS = %.3e\n", rms(N*cx.*ch - cy));
```

---

## 14. DFS ↔ DTFT 직관(주기화 ↔ 라인화)

- **시간 주기화** ↔ **주파수 라인 스펙트럼**:
  주기 \(N\)이면 DTFT가 \(\omega=2\pi m/N\)의 임펄스열로만 존재하고, 그 계수가 **DFS \(c_k\)**다.
- 반대로 **주파수 주기화**(라인 반복)는 시간영역에서의 **샘플링/디지털화**와 연결된다.

---

## 15. 실무 팁·자주 하는 실수

1) **스케일**: DFS \(c_k\)와 DFT \(X[k]\)는 \(c_k=X[k]/N\).
2) **인덱싱**: 음수 \(k\)는 \(k\equiv k+N\). `mod`를 일관되게.
3) **원형 vs 선형 컨볼루션**: DFT 곱은 **원형**. 선형 컨볼루션은 제로패딩으로 근사.
4) **Nyquist(짝수 \(N\))**: \(k=N/2\)는 실수, 켤레대칭 쌍이 없다.
5) **Gibbs**: 조화수 증가로 폭은 줄지만 최대 오버슈트는 완전히 사라지지 않는다.
6) **주기 불일치**: 데이터가 \(N\)-주기 가정과 맞지 않으면(DFT 창) 누설(leakage)이 생기나, **DFS 자체는 정확 주기 가정** 하에 완전 재구성된다.

---

## 16. 연습문제(풀이 스케치/Octave)

### 문제 1 — 펄스열 폐형식 검증
\(N=40, M=9\)에 대해 §6.1 공식과 수치 DFS를 비교하라.
```octave
clear; close all; clc
N=40; M=9; x=zeros(1,N); x(1:M)=1; k=0:N-1;
c_num=fft(x)/N; c_clo=zeros(1,N);
for kk=1:N
  if k(kk)==0, c_clo(kk)=M/N;
  else
    c_clo(kk)=(1/N)*exp(-1j*pi*k(kk)*(M-1)/N)*sin(pi*k(kk)*M/N)/sin(pi*k(kk)/N);
  end
end
printf("RMS err=%.3e\n", rms(c_num - c_clo));
```

### 문제 2 — 시간 시프트 위상 법칙
원형 시프트 \(n_0=5\)에서 위상이 \(-2\pi kn_0/N\)만큼 선형 이동함을 수치로 보이라(§12 코드).

### 문제 3 — Parseval 등식
랜덤 실수 \(x\)에 대해 시간/주파수 에너지 차이를 출력하라.
```octave
N=100; x=randn(1,N); c=fft(x)/N;
Et=(1/N)*sum(abs(x).^2); Ef=sum(abs(c).^2);
printf("Parseval diff=%.3e\n", abs(Et-Ef));
```

### 문제 4 — 원형 컨볼루션 = 주파수 곱
```octave
N=50; x=randn(1,N); h=randn(1,N);
y1 = ifft(fft(x).*fft(h));
cx=fft(x)/N; ch=fft(h)/N; y2 = dfs_synthesize(N*cx.*ch);
printf("RMS=%.3e\n", rms(y1 - y2));
```

### 문제 5 — 켤레대칭 증명 스케치
실수 \(x\)의 분석식을 켤레취해 \(\sum x[n]e^{+j2\pi kn/N}\)로 만들고 인덱스 치환으로 \(c^\ast_{-k}\)를 도출하라. 수치 최대 편차로 확인(§10).

### 문제 6 — 지정 조화 합성
\(x[n]=\sum_{m\in\{3,7,11\}}A_me^{j2\pi mn/N}\)를 합성하고 DFS 피크가 해당 \(m\)에만 서는지 확인.
```octave
N=64; n=0:N-1; A=zeros(1,N);
A(3+1)=1.2*exp(1j*0.2); A(7+1)=0.7*exp(-1j*0.5); A(11+1)=0.9;
x = ifft(N*A); c = fft(x)/N;
stem(0:N-1, abs(c), 'filled'); grid on; title('Peaks at 3,7,11');
```

### 문제 7 — Gibbs 관찰
§11의 K 리스트를 늘려 오버슈트 크기·폭 변화를 관찰하라.

---

## 17. 요약
- **DFS**는 길이 \(N\) 주기 이산 신호를 \(N\)개의 **직교 복소지수 기저**로 완전 분해한다.
- 분석/합성은 간단한 **내적/기저 합**이며, **DFT와 스케일 하나**만 다르다.
- **Parseval**·**시프트**·**원형 컨볼루션** 등 기본 성질은 모두 **선형대수/직교성**에서 나온다.
- **DTFT**에서는 **라인 스펙트럼**, **Z-변환**에서는 **단위원 샘플**로 연결된다.
- 주기 LTI는 DFS(DFT)에서 **대각화**되어 조화별 스칼라 배율만 남는다.
- 본문 Octave 코드로 계수의 폐형식, Parseval, 원형 컨볼루션, Gibbs 등을 **직접 검증**하라.
