---
layout: post
title: 논리회로설계 - 순서논리의 VHDL (2)
date: 2025-09-13 15:25:23 +0900
category: 논리회로설계
---
# 모델화**, **VHDL 코드의 합성 포인트**, **프로세스·순서문 심화**

> 표기: `clk`(클럭), `rst`(리셋; 별도 표기 없으면 동기), `CE`(Clock Enable), 신호는 `std_logic(_vector)`, 산술은 `ieee.numeric_std` 사용.
> 목표: **합성 가능한** 코딩을 전제로, *FSM 모델화 템플릿*과 *합성기 관점의 주의점*, *프로세스/순서문 심화*를 **예제와 함께** 정리.

---

## 공통 준비

```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
```
- **규칙**:
  - 클럭 동작은 `if rising_edge(clk) then` 내부에서만 상태 갱신.
  - 조합 프로세스는 `process(all)` + **기본값**으로 래치 방지.
  - 비동기 입력은 **2FF 동기화** 후 사용.
  - 산술은 `unsigned/signed`로 변환해 사용.

---

## 순서머신(FSM)의 **모델화** — 패턴과 예제

### Moore vs Mealy

- **Moore**: 출력 = **현재 상태**의 함수. 글리치에 강함, 1클럭 지연 가능.
- **Mealy**: 출력 = **상태+입력**의 함수. 즉시 반응, 글리치 위험 → **출력 등록** 권장.

### FSM 설계 3가지 템플릿

- **1-프로세스**(권장X): 상태/출력/다음상태를 한 프로세스에 혼합 → 초보자 오류↑.
- **2-프로세스**(권장): `조합(ns,y)` + `순차(state reg)`
- **3-프로세스**: `조합(ns)` + `순차(state reg)` + `순차(출력 레지스터)`(Mealy 글리치 방지)

아래는 **2-프로세스 Moore FSM**(열거형 상태, 명시적 인코딩 옵션 포함).

#### [예제 A] Moore FSM (IDLE→LOAD→RUN→DONE)

```vhdl
entity fsm_moore is
  port (clk,rst    : in  std_logic;
        start,done : in  std_logic;
        y_done     : out std_logic);
end;
architecture rtl of fsm_moore is
  type S_t is (IDLE, LOAD, RUN, DONE);
  signal s, ns : S_t := IDLE;

  -- (옵션) 상태 인코딩 명시: 도구별 키워드 상이
  -- Xilinx:  attribute fsm_encoding : string;
  -- attribute fsm_encoding of s : signal is "sequential"; -- or "onehot","gray"
  -- 공통:   attribute enum_encoding : string;
  -- attribute enum_encoding of S_t : type is "00 01 10 11";
begin
  -- 1) 조합: 다음상태/출력
  process(all) is
  begin
    ns     <= s;
    y_done <= '0';
    case s is
      when IDLE =>
        if start='1' then ns <= LOAD; end if;
      when LOAD =>
        ns <= RUN;
      when RUN  =>
        if done='1' then ns <= DONE; end if;
      when DONE =>
        y_done <= '1';
        ns     <= IDLE;
    end case;
  end process;

  -- 2) 순차: 상태 레지스터
  process(clk) is
  begin
    if rising_edge(clk) then
      if rst='1' then s <= IDLE; else s <= ns; end if;
    end if;
  end process;
end;
```

#### [예제 B] Mealy FSM (출력 **등록** 포함: 3-프로세스)

`valid/ready` 스트림에서 **바이트 카운트**를 한 프레임(SOP..EOP) 동안 누적.
```vhdl
entity fsm_mealy_reg is
  port (clk,rst      : in  std_logic;
        sop,eop      : in  std_logic;       -- frame markers
        valid, ready : in  std_logic;       -- from/to upstream
        byte_ticked  : in  std_logic;       -- when one byte accepted
        pulse_count  : out std_logic);      -- 1clk pulse when EOP seen
end;
architecture rtl of fsm_mealy_reg is
  type S_t is (IDLE, INFR);
  signal s, ns : S_t := IDLE;
  signal pulse_i : std_logic := '0';
begin
  -- (a) 조합: 다음상태
  process(all) begin
    ns <= s;
    case s is
      when IDLE =>
        if sop='1' and valid='1' and ready='1' then ns <= INFR; end if;
      when INFR =>
        if eop='1' and valid='1' and ready='1' then ns <= IDLE; end if;
    end case;
  end process;

  -- (b) 순차: 상태
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then s <= IDLE; else s <= ns; end if;
    end if;
  end process;

  -- (c) 순차: Mealy 출력 **등록** (글리치 방지)
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then pulse_i <= '0';
      else
        pulse_i <= '0';
        if (s=INFR) and (eop='1') and (valid='1') and (ready='1') then
          pulse_i <= '1';
        end if;
      end if;
    end if;
  end process;
  pulse_count <= pulse_i;
end;
```

### **원-핫(one-hot)** FSM

- 상태수 \(N\) → FF \(N\)개, 각 상태 비트가 바로 출력/제어에 연결되어 **조합식 단순**. FPGA에 유리.
```vhdl
entity fsm_onehot is
  port (clk,rst,x: in std_logic; y: out std_logic);
end;
architecture rtl of fsm_onehot is
  signal S0,S1,S2 : std_logic := '0'; -- 3상태 예
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then S0<='1'; S1<='0'; S2<='0';
      else
        -- next-state: 들어오는 간선들의 OR
        S0 <= (S0 and not x) or (S2 and x);
        S1 <= (S0 and x)     or (S1 and not x);
        S2 <= (S1 and x);
      end if;
    end if;
  end process;
  y <= S2;  -- Moore 출력처럼 간단
end;
```
- **Safe FSM**: `when others => S0<=’1’; S1<=’0’; S2<=’0’;`로 불법 상태 복구.

### ISM(불완전 명세)·Self-start

- 미정 전이는 **IDLE 복귀** 등으로 **닫힌 커버**를 보장.
- 합성 옵션의 *safe state machine* 활성화 검토(도구별 명칭 상이).

---

## **VHDL 코드의 합성** — 무엇이 어떻게 하드웨어가 되는가

### “합성 가능”과 “불가”의 경계

- **가능(대표)**: `if/case`, 산술 `+ - *`(폭 제한), 시프트(`sll/srl`), 비교, `with-select/when-else`, 정적 범위 `for` 루프, 함수/프로시저(합성 가능한 코드로 구성).
- **불가/지양**: `wait for`, `after` 지연, 파일 I/O, 텍스트IO(대개 TB 전용), 동적 메모리, 무한 루프/데드코드.

### **자원 추론(Resource Inference)**

- **레지스터**: `rising_edge(clk)` 안의 신호 할당.
- **래치**: **조합 프로세스에서** 일부 경로에 할당이 없을 때 **암묵 추론**(방지!).
- **RAM/ROM**: 배열/블록을 특정 패턴으로 코딩하면 BRAM/ROM으로 추론.
- **SRL(Shift Register LUT)**: 일정 패턴의 시프트 → FPGA에서 자동 매핑.
- **DSP**: 폭이 큰 `*`, `MAC` → DSP 블록 자동 매핑(폭/옵션 확인).

### 타이밍 관점

- 경로 제약: \(T_{clk} \ge t_{CQ} + t_{comb} + t_{SU}\).
- **개선책**: 파이프라인 삽입, 팬인 축소(인수화), 리타이밍 허용, 멀티사이클 경로(합당할 때만).
- **Mealy 출력**은 **레지스터**로 외부에 내보내기(글리치·타이밍 안정).

### CDC/리셋

- 비동기 입력은 **2FF 동기화**, 펄스는 **동기 영역에서** one-shot.
- 비동기 리셋은 **해제 동기화**(release sync) 권장.

### 시퀀서** — FSM + 데이터패스

```vhdl
entity gcd_seq is
  port (clk,rst: in std_logic;
        start: in std_logic;
        a_in,b_in: in unsigned(15 downto 0);
        busy: out std_logic;
        y: out unsigned(15 downto 0); valid: out std_logic);
end;
architecture rtl of gcd_seq is
  type S_t is (IDLE, LOAD, LOOP, OUT);
  signal s, ns : S_t := IDLE;
  signal A,B : unsigned(15 downto 0);
begin
  -- 조합: 다음상태/출력(busy/valid)
  process(all) begin
    ns    <= s;
    busy  <= '0'; valid <= '0';
    case s is
      when IDLE => if start='1' then ns<=LOAD; end if;
      when LOAD => ns<=LOOP; busy<='1';
      when LOOP =>
        busy<='1';
        if A=B then ns<=OUT;
      when OUT  => valid<='1'; ns<=IDLE;
    end case;
  end process;

  -- 순차: 상태 & 데이터패스
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then s<=IDLE; A<= (others=>'0'); B<= (others=>'0');
      else
        s <= ns;
        case s is
          when LOAD => A<=a_in; B<=b_in;
          when LOOP =>
            if A>B then A<=A-B;
            elsif B>A then B<=B-A;
            end if;
          when others => null;
        end case;
      end if;
    end if;
  end process;
  y <= A; -- OUT일 때 A=B=GCD
end;
```
- 단순하지만 **상태/데이터패스 분해**와 **합성 친화 코드**의 전형.

---

## **프로세스와 순서문** 심화 — 의미·함정·예제

### 프로세스의 감도 리스트 & 델타 사이클

- **조합 프로세스**는 `process(all)`(VHDL-2008) 권장. (구형 합성기는 모든 사용 신호 명시)
- **순차 프로세스**는 클럭/리셋만 감도에 넣기.
- **델타 사이클**: 신호 할당은 **다음 델타**에 반영. 조합 프로세스에서 **변수**를 이용하면 한 사이클 내 임시 계산 가능.

```vhdl
process(all) -- 조합
  variable t: unsigned(8 downto 0);
begin
  t := ('0' & a) + ('0' & b); -- 변수로 누적
  sum <= std_logic_vector(t(7 downto 0));
  carry <= t(8);
end process;
```

### 변수 vs 신호

- **변수**: 프로세스 내부에서 **즉시 갱신**(동일 감도 평가 내).
- **신호**: 델타 지연 후 갱신. 순차 로직에서는 레지스터로 합성.
- **권장**: 조합 계산에는 **변수**, 레지스터에는 **신호**.

### if / case — 우선순위 vs 평행

- `if-elsif`는 **우선순위 인코딩**.
- `case`는 **평행 선택**(모두 배타). 모든 경우를 **커버**하거나 `when others` 필수.

```vhdl
-- 우선순위 인코더(8→3)
process(all) begin
  y<="000"; v<='0';
  if    d(7)='1' then y:="111"; v<='1';
  elsif d(6)='1' then y:="110"; v<='1';
  -- ...
  elsif d(0)='1' then y:="000"; v<='1';
  end if;
end process;
```

### 루프(합성 가능 조건)

- **정적 범위**의 `for` 루프는 펼쳐져 합성됨(반복 수만큼 하드웨어).
- `while`은 대개 합성 불가(일부 도구 특정 조건 하에서만).
- **예: Popcount(1 비트 수 합계)**
```vhdl
function popcount(d: std_logic_vector) return unsigned is
  variable c: unsigned(15 downto 0) := (others=>'0'); -- 폭은 충분히
begin
  for i in d'range loop
    if d(i)='1' then c := c + 1; end if;
  end loop;
  return c;
end;
```

### 함수/프로시저

- **함수**: 결과를 반환(조합식 모듈화). `pure`(권장, 부작용 없음) / `impure`(메모리 접근 등).
- **프로시저**: 여러 출력/부작용 허용(조합 또는 순차 블록 내 재사용).

```vhdl
function gray4(b: std_logic_vector(3 downto 0)) return std_logic_vector is
begin
  return b(3) & (b(3) xor b(2)) & (b(2) xor b(1)) & (b(1) xor b(0));
end;
```

### generate 문

- 파라미터화된 복제/배치.
```vhdl
gen_ff: for i in 0 to N-1 generate
  ff_i: entity work.dff_ce port map(clk=>clk, rst=>rst, ce=>ce, d=>din(i), q=>q(i));
end generate;
```

### 래치 방지 패턴 (중요)

- 조합 프로세스에서 **기본값**을 먼저 할당.
```vhdl
process(all) begin
  next_a <= a;  -- 기본 유지
  if en='1' then next_a <= b; end if;
end process;
```

### “wait” 구문

- 합성에서 **지양**. TB에서는 유용(`wait for 10 ns;`).
- 합성 가능한 `wait until rising_edge(clk);` 지원 도구도 있으나, **표준·가독성** 측면에서 `if rising_edge(clk)` 권장.

### 레코드/패키지 — 인터페이스 정리

```vhdl
package stream_pkg is
  type axis_t is record
    tdata: std_logic_vector(31 downto 0);
    tvalid,tready,tlast: std_logic;
  end record;
end;
```
- 레코드 포트는 도구 지원 여부 확인(대부분 최신 도구 OK).

---

## 종합 예제 — **프레임 길이 측정 FSM**(Mealy 출력 등록, 합성·검증 친화)

**기능**: `in_valid/in_data` 스트림에서 `SOP(0xAA)` 시작 ~ `EOP(0x55)` 종료까지 **바이트 수** 카운트. `count_valid` 1클럭 펄스와 함께 결과 출력.

```vhdl
entity frame_len is
  port (clk,rst       : in  std_logic;
        in_valid      : in  std_logic;
        in_data       : in  std_logic_vector(7 downto 0);
        out_count     : out unsigned(15 downto 0);
        count_valid   : out std_logic);
end;
architecture rtl of frame_len is
  type S_t is (IDLE, INFR);
  signal s, ns : S_t := IDLE;
  signal cnt, cnt_n : unsigned(15 downto 0) := (others=>'0');
  signal cv_i : std_logic := '0';
begin
  -- 조합: ns & cnt_n
  process(all) begin
    ns    <= s;
    cnt_n <= cnt;
    case s is
      when IDLE =>
        if in_valid='1' and in_data=x"AA" then
          ns    <= INFR;
          cnt_n <= (others=>'0');
        end if;
      when INFR =>
        if in_valid='1' then
          cnt_n <= cnt + 1;
          if in_data=x"55" then ns <= IDLE; end if;
        end if;
    end case;
  end process;

  -- 순차: 상태/카운터
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then s<=IDLE; cnt<=(others=>'0');
      else s<=ns; cnt<=cnt_n; end if;
    end if;
  end process;

  -- 순차: Mealy 성격의 출력 **등록**
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then cv_i<='0';
      else
        cv_i <= '0';
        if s=INFR and in_valid='1' and in_data=x"55" then
          cv_i <= '1'; -- 종료 순간 1클럭 펄스
        end if;
      end if;
    end if;
  end process;

  out_count   <= cnt;
  count_valid <= cv_i;
end;
```

**시뮬 요약**: SOP, 데이터 10바이트, EOP 순으로 입력하면 `count_valid` 펄스와 함께 `out_count=10`이 나옴.

---

## 합성·디버그 실무 포인트

### 인코딩·프라그마(도구별)

- 상태 인코딩:
  - 공통: `attribute enum_encoding : string;`
  - Xilinx: `attribute fsm_encoding : string; -- "onehot","sequential","gray"`
  - Intel:  `(* syn_encoding = "onehot" *)` 등(도구 문서 확인)
- 보존/디버그:
  - Xilinx: `attribute mark_debug : string; attribute mark_debug of signal_name : signal is "true";`
  - Intel : `attribute preserve : boolean;` 등.

### 타이밍 제약(개념)

- `create_clock -period ... [get_ports clk]`
- I/O 지연: `set_input_delay / set_output_delay`
- 예외: `set_false_path`, `set_multicycle_path` (합당한 경우에만)

### CDC

- 단일 비트: **2FF 동기화**.
- 다비트/버스: **비동기 FIFO** 또는 **토글/핸드셰이크**.
- Mealy 출력은 **등록 후** 도메인 외부로.

### 흔한 경고·에러

- **래치 추론**: 조합 블록에서 모든 경로 할당 누락.
- **게이티드 클럭**: 클럭을 AND/OR로 만들지 말 것(CE로 대체).
- **’U’/’X’**: TB에서 초기화 누락. 합성 후에는 하드웨어가 ‘0/1’ 중 하나로 수렴.

---

## 스케치 — 위 예제 검증

```vhdl
entity tb is end;
architecture sim of tb is
  signal clk: std_logic:='0'; signal rst: std_logic:='1';
  signal v: std_logic:='0'; signal d: std_logic_vector(7 downto 0):=(others=>'0');
  signal outc: unsigned(15 downto 0); signal cv: std_logic;
begin
  clk <= not clk after 5 ns;
  dut: entity work.frame_len
    port map(clk=>clk, rst=>rst, in_valid=>v, in_data=>d, out_count=>outc, count_valid=>cv);

  process begin
    wait for 50 ns; rst<='0';
    -- SOP
    v<='1'; d<=x"AA"; wait for 10 ns;
    -- 10 bytes
    for i in 0 to 9 loop d<=std_logic_vector(to_unsigned(i,8)); wait for 10 ns; end loop;
    -- EOP
    d<=x"55"; wait for 10 ns;
    v<='0';  wait for 50 ns;
    assert cv='1' and outc=to_unsigned(10,16)
      report "Count mismatch" severity error;
    assert false report "SIM DONE" severity failure;
  end process;
end;
```

---

## 체크리스트(요약)

- [ ] **2/3-프로세스 FSM** 패턴 준수, Mealy 출력은 **등록**.
- [ ] 조합 프로세스에 **기본값** 할당(래치 방지).
- [ ] 비동기 입력은 **2FF 동기화**, 비동기 리셋 **해제 동기화**.
- [ ] 상태 인코딩·safe FSM 옵션 필요 시 명시.
- [ ] 합성 리포트로 **자원/경로** 확인, 타이밍 제약 충실.
- [ ] TB에서 정상/경계/오류 시나리오와 **어서션**으로 검증.

---

### 마무리

- FSM 모델화는 **명확한 템플릿**(2/3-프로세스)과 **안전한 출력 처리**(등록)가 핵심.
- 합성 관점에선 **자원 추론**과 **타이밍/CDC**를 앞단에서 고려하면 시행착오를 크게 줄인다.
- 프로세스/순서문은 **변수 vs 신호**, **if vs case**, **루프의 정적 전개**를 이해하면 **읽기 쉽고 빠른** RTL을 만들 수 있다.
