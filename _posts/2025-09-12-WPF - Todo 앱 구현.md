---
layout: post
title: WPF - Todo 앱 구현
date: 2025-09-12 17:25:23 +0900
category: WPF
---
# ✅ WPF **Todo 앱 구현 (MVVM 기반)** 완전 가이드
*(프로젝트 구조 → MVVM 설계 → 명령/바인딩 → 검색/필터/정렬 → 유효성 검사 → 파일 영속화(JSON) → DI/호스팅 → 단위 테스트 → 키보드/접근성 → 성능 최적화까지 “빠짐없이”)*

> 목표: **WPF(.NET 7/8)**에서 MVVM 패턴으로 **실무 품질의 Todo 앱**을 끝까지 구현합니다.  
> 핵심은 **깨끗한 분리(MVVM)**, **테스트 가능성**, **반응성 UI**, **안전한 영속화**입니다.  
> (DB가 필요하면 EF Core/SQLite로 쉽게 교체할 수 있는 구조도 함께 제시합니다.)

---

## 0) 완성 화면 개요

- 상단: **검색/필터(전체·진행·완료)**, 정렬(기한/우선순위/생성일), “완료 정리” 버튼
- 중앙: **가상화된 ListView** — 체크박스(완료), 제목 인라인 편집, 기한/우선순위/메모
- 하단: 상태바(총 건수/필터 건수/오류), 진행 애니메이션(저장 중)
- 키보드: **Enter** 추가, **Delete** 삭제, **Ctrl+F** 검색, **Ctrl+Z/Y** Undo/Redo

---

## 1) 솔루션 구조

```
TodoApp/
  TodoApp.App/               # WPF UI (Views, ViewModels, Styles, Converters, Behaviors)
  TodoApp.Domain/            # 모델, 계약(인터페이스), DTO, Validation
  TodoApp.Storage/           # 저장소 구현(JSON File; (선택) EF Core/SQLite)
  TodoApp.Tests/             # 단위 테스트 (ViewModel/도메인)
```

---

## 2) 패키지 설치

```bash
# MVVM/DI
dotnet add TodoApp.App package CommunityToolkit.Mvvm
dotnet add TodoApp.App package Microsoft.Extensions.Hosting
dotnet add TodoApp.App package Microsoft.Extensions.DependencyInjection

# JSON 저장
dotnet add TodoApp.Storage package System.Text.Json

# (선택) EF Core/SQLite을 쓸 경우
# dotnet add TodoApp.Storage package Microsoft.EntityFrameworkCore
# dotnet add TodoApp.Storage package Microsoft.EntityFrameworkCore.Sqlite

# 테스트
dotnet add TodoApp.Tests package xunit
dotnet add TodoApp.Tests package xunit.runner.visualstudio
dotnet add TodoApp.Tests package FluentAssertions
```

---

## 3) 도메인(모델/계약/검증)

### 3.1 모델
```csharp
// TodoApp.Domain/Models/TodoItem.cs
namespace TodoApp.Domain.Models;

public enum Priority { Low = 0, Normal = 1, High = 2 }

public sealed class TodoItem
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Title { get; set; } = "";
    public bool IsCompleted { get; set; }
    public DateTimeOffset? Due { get; set; }
    public Priority Priority { get; set; } = Priority.Normal;
    public string? Notes { get; set; }
    public DateTimeOffset CreatedAt { get; set; } = DateTimeOffset.UtcNow;
    public DateTimeOffset? UpdatedAt { get; set; }
}
```

### 3.2 저장소 계약
```csharp
// TodoApp.Domain/Contracts/ITodoStore.cs
using TodoApp.Domain.Models;

namespace TodoApp.Domain.Contracts;

public interface ITodoStore
{
    Task<IReadOnlyList<TodoItem>> LoadAsync(CancellationToken ct = default);
    Task SaveAsync(IReadOnlyList<TodoItem> items, CancellationToken ct = default);
}
```

### 3.3 간단 검증 도우미
```csharp
// TodoApp.Domain/Validation/TodoValidator.cs
using TodoApp.Domain.Models;

namespace TodoApp.Domain.Validation;

public static class TodoValidator
{
    public static string? ValidateTitle(string? title)
        => string.IsNullOrWhiteSpace(title) ? "제목은 비워둘 수 없습니다." :
           title!.Length > 200 ? "제목은 200자 이하여야 합니다." : null;

    public static string? ValidateDue(DateTimeOffset? due)
        => (due.HasValue && due.Value < DateTimeOffset.UtcNow.AddDays(-1))
            ? "기한은 과거로 설정하지 않는 것을 권장합니다." : null;
}
```

---

## 4) 저장소 구현(JSON 파일 기반)

### 4.1 경로/포맷
- 위치: `%LOCALAPPDATA%\TodoApp\todos.json`
- 포맷: `System.Text.Json` (CamelCase, UTC 보존)

```csharp
// TodoApp.Storage/JsonTodoStore.cs
using System.Text.Json;
using TodoApp.Domain.Contracts;
using TodoApp.Domain.Models;

namespace TodoApp.Storage;

public sealed class JsonTodoStore : ITodoStore
{
    private readonly string _path;
    private static readonly JsonSerializerOptions Options = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        WriteIndented = true
    };

    public JsonTodoStore()
    {
        var dir = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
            "TodoApp");
        Directory.CreateDirectory(dir);
        _path = Path.Combine(dir, "todos.json");
    }

    public async Task<IReadOnlyList<TodoItem>> LoadAsync(CancellationToken ct = default)
    {
        if (!File.Exists(_path)) return Array.Empty<TodoItem>();
        await using var fs = File.OpenRead(_path);
        var items = await JsonSerializer.DeserializeAsync<List<TodoItem>>(fs, Options, ct)
                    ?? new List<TodoItem>();
        return items;
    }

    public async Task SaveAsync(IReadOnlyList<TodoItem> items, CancellationToken ct = default)
    {
        // 임시파일 → 원자적 교체로 데이터 손상 방지
        var tmp = _path + ".tmp";
        await using (var fs = File.Create(tmp))
        {
            await JsonSerializer.SerializeAsync(fs, items, Options, ct);
        }
        File.Copy(tmp, _path, overwrite: true);
        File.Delete(tmp);
    }
}
```

> **TIP**: 나중에 EF Core/SQLite 도입 시에도 `ITodoStore`만 교체하면 VM/뷰는 그대로 유지됩니다.

---

## 5) 앱 부트스트랩(DI/Generic Host)

```csharp
// TodoApp.App/App.xaml.cs
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System.Windows;
using TodoApp.Domain.Contracts;
using TodoApp.Storage;
using TodoApp.App.ViewModels;

namespace TodoApp.App;

public partial class App : Application
{
    public static IHost HostApp { get; } = Host.CreateDefaultBuilder()
        .ConfigureServices((ctx, s) =>
        {
            s.AddSingleton<ITodoStore, JsonTodoStore>();
            s.AddSingleton<MainViewModel>();
        })
        .Build();

    protected override async void OnStartup(StartupEventArgs e)
    {
        await HostApp.StartAsync();
        var vm = HostApp.Services.GetRequiredService<MainViewModel>();
        var win = new MainWindow { DataContext = vm };
        win.Show();
        base.OnStartup(e);
    }

    protected override async void OnExit(ExitEventArgs e)
    {
        await HostApp.StopAsync();
        HostApp.Dispose();
        base.OnExit(e);
    }
}
```

`App.xaml`
```xml
<Application x:Class="TodoApp.App.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
    <Application.Resources/>
</Application>
```

---

## 6) ViewModel 설계 (CommunityToolkit.Mvvm)

### 6.1 TodoItemViewModel (단일 아이템)
```csharp
// TodoApp.App/ViewModels/TodoItemViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using TodoApp.Domain.Models;
using TodoApp.Domain.Validation;

namespace TodoApp.App.ViewModels;

public partial class TodoItemViewModel : ObservableObject
{
    [ObservableProperty] private Guid id;
    [ObservableProperty] private string title = "";
    [ObservableProperty] private bool isCompleted;
    [ObservableProperty] private DateTimeOffset? due;
    [ObservableProperty] private Priority priority;
    [ObservableProperty] private string? notes;
    [ObservableProperty] private DateTimeOffset createdAt;
    [ObservableProperty] private DateTimeOffset? updatedAt;

    public string? TitleError => TodoValidator.ValidateTitle(Title);
    public string? DueWarning => TodoValidator.ValidateDue(Due);

    public TodoItemViewModel() { }

    public TodoItemViewModel(TodoItem m)
    {
        Id = m.Id; Title = m.Title; IsCompleted = m.IsCompleted; Due = m.Due;
        Priority = m.Priority; Notes = m.Notes; CreatedAt = m.CreatedAt; UpdatedAt = m.UpdatedAt;
    }

    public TodoItem ToModel() => new()
    {
        Id = Id, Title = Title, IsCompleted = IsCompleted, Due = Due,
        Priority = Priority, Notes = Notes, CreatedAt = CreatedAt, UpdatedAt = UpdatedAt
    };

    partial void OnTitleChanged(string value) => OnPropertyChanged(nameof(TitleError));
    partial void OnDueChanged(DateTimeOffset? value) => OnPropertyChanged(nameof(DueWarning));

    [RelayCommand]
    private void ToggleComplete() => IsCompleted = !IsCompleted;
}
```

### 6.2 MainViewModel (목록/검색/필터/정렬/저장)
```csharp
// TodoApp.App/ViewModels/MainViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Data;
using TodoApp.Domain.Contracts;
using TodoApp.Domain.Models;

namespace TodoApp.App.ViewModels;

public enum FilterMode { All, Active, Completed }
public enum SortMode { Created, Due, Priority, Title }

public partial class MainViewModel : ObservableObject
{
    private readonly ITodoStore _store;

    public ObservableCollection<TodoItemViewModel> Items { get; } = new();
    public ICollectionView View { get; }

    [ObservableProperty] private string? query;
    [ObservableProperty] private FilterMode filter = FilterMode.All;
    [ObservableProperty] private SortMode sort = SortMode.Created;
    [ObservableProperty] private bool isBusy;
    [ObservableProperty] private string? error;
    [ObservableProperty] private string? newTitle;

    [ObservableProperty] private TodoItemViewModel? selected;

    private readonly Stack<IReadOnlyList<TodoItem>> _undo = new();
    private readonly Stack<IReadOnlyList<TodoItem>> _redo = new();

    public MainViewModel(ITodoStore store)
    {
        _store = store;
        View = CollectionViewSource.GetDefaultView(Items);
        View.Filter = FilterPredicate;
        ApplySort(); // 초기 정렬
    }

    bool FilterPredicate(object o)
    {
        if (o is not TodoItemViewModel t) return false;
        if (!string.IsNullOrWhiteSpace(Query) &&
            !(t.Title?.Contains(Query, StringComparison.CurrentCultureIgnoreCase) ?? false)) return false;

        return Filter switch
        {
            FilterMode.Active => !t.IsCompleted,
            FilterMode.Completed => t.IsCompleted,
            _ => true
        };
    }

    partial void OnQueryChanged(string? _) => View.Refresh();
    partial void OnFilterChanged(FilterMode _) => View.Refresh();

    partial void OnSortChanged(SortMode _)
    {
        ApplySort();
        View.Refresh();
    }

    private void ApplySort()
    {
        using (View.DeferRefresh())
        {
            View.SortDescriptions.Clear();
            switch (Sort)
            {
                case SortMode.Created:
                    View.SortDescriptions.Add(new SortDescription(nameof(TodoItemViewModel.CreatedAt), ListSortDirection.Descending)); break;
                case SortMode.Due:
                    View.SortDescriptions.Add(new SortDescription(nameof(TodoItemViewModel.Due), ListSortDirection.Ascending)); break;
                case SortMode.Priority:
                    View.SortDescriptions.Add(new SortDescription(nameof(TodoItemViewModel.Priority), ListSortDirection.Descending)); break;
                case SortMode.Title:
                    View.SortDescriptions.Add(new SortDescription(nameof(TodoItemViewModel.Title), ListSortDirection.Ascending)); break;
            }
        }
    }

    // 상태 스냅샷 (Undo/Redo용)
    private IReadOnlyList<TodoItem> Snapshot() => Items.Select(i => i.ToModel()).ToList();
    private void PushUndo() { _undo.Push(Snapshot()); _redo.Clear(); }

    private void Restore(IReadOnlyList<TodoItem> snap)
    {
        Items.Clear();
        foreach (var m in snap) Items.Add(new TodoItemViewModel(m));
        View.Refresh();
    }

    [RelayCommand]
    public async Task LoadAsync()
    {
        try
        {
            IsBusy = true; Error = null;
            Items.Clear();
            foreach (var m in await _store.LoadAsync())
                Items.Add(new TodoItemViewModel(m));
            View.Refresh();
        }
        catch (Exception ex) { Error = ex.Message; }
        finally { IsBusy = false; }
    }

    [RelayCommand(CanExecute = nameof(CanSave))]
    public async Task SaveAsync()
    {
        try
        {
            IsBusy = true; Error = null;
            await _store.SaveAsync(Items.Select(i => i.ToModel()).ToList());
        }
        catch (Exception ex) { Error = ex.Message; }
        finally { IsBusy = false; }
    }
    private bool CanSave() => !IsBusy;

    [RelayCommand]
    private void Add()
    {
        if (string.IsNullOrWhiteSpace(NewTitle)) return;
        var err = Domain.Validation.TodoValidator.ValidateTitle(NewTitle);
        if (err is not null) { Error = err; return; }

        PushUndo();
        var vm = new TodoItemViewModel(new TodoItem
        {
            Title = NewTitle!.Trim(),
            CreatedAt = DateTimeOffset.UtcNow,
            Priority = Priority.Normal
        });
        Items.Insert(0, vm);
        NewTitle = "";
        View.Refresh();
    }

    [RelayCommand]
    private void Toggle(TodoItemViewModel? item)
    {
        if (item is null) return;
        PushUndo();
        item.IsCompleted = !item.IsCompleted;
        item.UpdatedAt = DateTimeOffset.UtcNow;
        View.Refresh();
    }

    [RelayCommand]
    private void Remove(TodoItemViewModel? item)
    {
        if (item is null) return;
        PushUndo();
        Items.Remove(item);
        View.Refresh();
    }

    [RelayCommand]
    private void ClearCompleted()
    {
        PushUndo();
        foreach (var c in Items.Where(i => i.IsCompleted).ToList())
            Items.Remove(c);
        View.Refresh();
    }

    [RelayCommand]
    private void Undo()
    {
        if (_undo.Count == 0) return;
        _redo.Push(Snapshot());
        Restore(_undo.Pop());
    }

    [RelayCommand]
    private void Redo()
    {
        if (_redo.Count == 0) return;
        _undo.Push(Snapshot());
        Restore(_redo.Pop());
    }
}
```

---

## 7) 뷰(XAML)

### 7.1 메인 윈도우
```xml
<!-- TodoApp.App/MainWindow.xaml -->
<Window x:Class="TodoApp.App.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Todo" Width="900" Height="620"
        Loaded="{Binding LoadCommand}">
    <DockPanel Margin="14">
        <!-- 상단 바: 새 항목, 필터/정렬, 검색 -->
        <StackPanel Orientation="Horizontal" DockPanel.Dock="Top" Spacing="8">
            <TextBox Width="360" Height="28"
                     x:Name="NewBox"
                     Text="{Binding NewTitle, UpdateSourceTrigger=PropertyChanged}"
                     ToolTip="새 할 일을 입력하고 Enter를 누르세요."/>
            <Button Content="추가" Height="28" Padding="14,0"
                    Command="{Binding AddCommand}"/>

            <Separator Margin="8,0"/>

            <ComboBox Width="120" SelectedItem="{Binding Filter}">
                <ComboBoxItem Content="All"/>
                <ComboBoxItem Content="Active"/>
                <ComboBoxItem Content="Completed"/>
            </ComboBox>

            <ComboBox Width="140" SelectedItem="{Binding Sort}">
                <ComboBoxItem Content="Created"/>
                <ComboBoxItem Content="Due"/>
                <ComboBoxItem Content="Priority"/>
                <ComboBoxItem Content="Title"/>
            </ComboBox>

            <TextBox Width="220" Height="28" Margin="8,0,0,0"
                     Text="{Binding Query, UpdateSourceTrigger=PropertyChanged}"
                     ToolTip="검색 (Ctrl+F)"/>

            <Button Content="완료 정리" Margin="8,0,0,0"
                    Command="{Binding ClearCompletedCommand}"/>

            <StackPanel Orientation="Horizontal" Margin="16,0,0,0">
                <ProgressBar Width="120" Height="10" IsIndeterminate="True"
                             Visibility="{Binding IsBusy, Converter={StaticResource BoolToVisibility}}"/>
                <TextBlock Margin="8,0" VerticalAlignment="Center"
                           Text="{Binding Error}" Foreground="#D00"/>
            </StackPanel>
        </StackPanel>

        <!-- 목록 -->
        <ListView ItemsSource="{Binding View}"
                  Name="TodoList"
                  VirtualizingStackPanel.IsVirtualizing="True"
                  VirtualizingStackPanel.VirtualizationMode="Recycling"
                  ScrollViewer.CanContentScroll="True">
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem">
                    <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                </Style>
            </ListView.ItemContainerStyle>

            <ListView.ItemTemplate>
                <DataTemplate DataType="{x:Type vm:TodoItemViewModel}">
                    <Grid Margin="6" SnapsToDevicePixels="True">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="160"/>
                            <ColumnDefinition Width="120"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>

                        <!-- 완료 체크 -->
                        <CheckBox Grid.Column="0" Margin="6,0" VerticalAlignment="Center"
                                  IsChecked="{Binding IsCompleted, Mode=TwoWay}"
                                  Command="{Binding ToggleCompleteCommand}"/>

                        <!-- 제목 (인라인 편집) -->
                        <TextBox Grid.Column="1" Margin="6,0" VerticalAlignment="Center"
                                 Text="{Binding Title, UpdateSourceTrigger=PropertyChanged}"
                                 ToolTip="{Binding TitleError}">
                            <TextBox.Style>
                                <Style TargetType="TextBox">
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
                                            <Setter Property="BorderBrush" Value="#888"/>
                                        </DataTrigger>
                                        <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"  >
                                            <!-- no-op -->
                                        </DataTrigger>
                                        <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
                                            <!-- keep default -->
                                        </DataTrigger>
                                        <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
                                        </DataTrigger>
                                        <DataTrigger Binding="{Binding TitleError}" Value="">
                                        </DataTrigger>
                                        <DataTrigger Binding="{Binding TitleError}" Value="{x:Static sys:String.Empty}">
                                        </DataTrigger>
                                        <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
                                        </DataTrigger>
                                    </Style.Triggers>
                                </Style>
                            </TextBox.Style>
                        </TextBox>

                        <!-- 기한 -->
                        <DatePicker Grid.Column="2" Margin="6,0"
                                    SelectedDate="{Binding Due, Mode=TwoWay}"
                                    ToolTip="{Binding DueWarning}"/>

                        <!-- 우선순위 -->
                        <ComboBox Grid.Column="3" Margin="6,0"
                                  SelectedItem="{Binding Priority}">
                            <ComboBoxItem Content="Low"/>
                            <ComboBoxItem Content="Normal"/>
                            <ComboBoxItem Content="High"/>
                        </ComboBox>

                        <!-- 삭제 -->
                        <Button Grid.Column="4" Content="삭제" Margin="6,0"
                                Command="{Binding DataContext.RemoveCommand, RelativeSource={RelativeSource AncestorType=ListView}}"
                                CommandParameter="{Binding}"/>
                    </Grid>
                </DataTemplate>
            </ListView.ItemTemplate>
        </ListView>

        <!-- 상태바 -->
        <StatusBar DockPanel.Dock="Bottom" Height="26" VerticalAlignment="Bottom">
            <StatusBarItem>
                <TextBlock>
                    <Run Text="전체: "/><Run Text="{Binding Items.Count}"/>
                    <Run Text="  ·  필터 후: "/><Run Text="{Binding View.Cast0.Count, FallbackValue=—}"/>
                </TextBlock>
            </StatusBarItem>
            <StatusBarItem HorizontalAlignment="Right">
                <TextBlock Text="Ctrl+N:추가  Del:삭제  Ctrl+F:검색  Ctrl+Z/Y:Undo/Redo"/>
            </StatusBarItem>
        </StatusBar>
    </DockPanel>
</Window>
```

> 위의 `View.Cast0.Count`는 단순 예시용(실사용에선 `CollectionView`의 `Count`를 바인딩하는 별도 프록시/컨버터를 두세요).

### 7.2 리소스/컨버터
```xml
<!-- App.xaml 또는 MainWindow.Resources -->
<Application.Resources xmlns:sys="clr-namespace:System;assembly=mscorlib"
                      xmlns:local="clr-namespace:TodoApp.App"
                      xmlns:conv="clr-namespace:TodoApp.App.Converters">
    <conv:BoolToVisibilityConverter x:Key="BoolToVisibility"/>
</Application.Resources>
```

```csharp
// TodoApp.App/Converters/BoolToVisibilityConverter.cs
using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace TodoApp.App.Converters;
public class BoolToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type t, object p, CultureInfo c)
        => (value is bool b && b) ? Visibility.Visible : Visibility.Collapsed;
    public object ConvertBack(object v, Type t, object p, CultureInfo c) => Binding.DoNothing;
}
```

---

## 8) 키보드/제스처 (InputBindings)

```xml
<Window.InputBindings>
    <KeyBinding Key="Enter" Modifiers="None" Command="{Binding AddCommand}"/>
    <KeyBinding Key="Delete" Command="{Binding RemoveCommand}" CommandParameter="{Binding Selected}"/>
    <KeyBinding Key="F" Modifiers="Control" Command="{Binding FocusSearchCommand}"/>
    <KeyBinding Key="Z" Modifiers="Control" Command="{Binding UndoCommand}"/>
    <KeyBinding Key="Y" Modifiers="Control" Command="{Binding RedoCommand}"/>
</Window.InputBindings>
```

검색 상자 포커스 커맨드는 간단한 인터랙션(Behavior)로:
```csharp
// TodoApp.App/Behaviors/FocusElementBehavior.cs
using System.Windows;
using System.Windows.Input;

namespace TodoApp.App.Behaviors;

public static class FocusHelper
{
    public static void Focus(FrameworkElement e) => _ = e?.Focus();
}
```
(실무에서는 `ICommand`로 `FindName("NewBox")` 후 `Focus()` 같은 구현을 MainWindow code-behind에 최소화하여 두어도 무방)

---

## 9) 유효성/경고 UX 개선 (간단 스타일)

```xml
<!-- 제목 오류 시 테두리 색 변경 -->
<Style TargetType="TextBox" x:Key="TitleBoxStyle">
  <Style.Triggers>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
      <Setter Property="BorderBrush" Value="#888"/>
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
      <Setter Property="ToolTip" Value="{x:Null}"/>
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Static sys:String.Empty}">
      <Setter Property="BorderBrush" Value="#888"/>
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
      <Setter Property="BorderBrush" Value="#888"/>
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
      <Setter Property="BorderBrush" Value="#888"/>
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"/>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"/>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"/>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"/>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"/>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"/>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"/>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"/>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"/>
    <!-- 오류가 있는 경우 -->
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"  >
      <!-- placeholder -->
    </DataTrigger>
  </Style.Triggers>
</Style>
```

> **참고**: 위 스타일 블록은 길어 보이지만, 실제로는 `TitleError != null`이면 붉은 테두리/툴팁을 주면 됩니다.  
> 문서 길이 제한상 최소화 버전으로 쓰셔도 됩니다:
```xml
<Style TargetType="TextBox" x:Key="TitleBoxStyle">
  <Style.Triggers>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
      <Setter Property="BorderBrush" Value="#888"/>
      <Setter Property="ToolTip" Value="{x:Null}"/>
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}"  >
      <!-- no-op -->
    </DataTrigger>
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}" />
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}" />
    <!-- 오류가 있는 경우 -->
    <DataTrigger Binding="{Binding TitleError}" Value="{x:Null}">
      <!-- keep -->
    </DataTrigger>
  </Style.Triggers>
</Style>
```

(실무에선 `ValidationRules`/`INotifyDataErrorInfo`를 쓰면 더욱 깔끔합니다.)

---

## 10) 성능 최적화 포인트

- 목록은 **가상화 + 리사이클**(이미 적용)
- 이미지/아이콘이 많다면 **Freezable.Freeze**·`BitmapCache`
- 필터/정렬 변경 시 `View.DeferRefresh()`로 배치
- 대량 추가/삭제는 **Undo 스냅샷** 후 **한 번에 UI 갱신**
- 저장은 비동기, 저장 중 진행 표시(`IsBusy`)

---

## 11) 단위 테스트 (ViewModel)

```csharp
// TodoApp.Tests/MainViewModelTests.cs
using FluentAssertions;
using TodoApp.App.ViewModels;
using TodoApp.Domain.Contracts;
using TodoApp.Domain.Models;

public class FakeStore : ITodoStore
{
    public List<TodoItem> Memory { get; } = new();
    public Task<IReadOnlyList<TodoItem>> LoadAsync(CancellationToken ct = default) 
        => Task.FromResult((IReadOnlyList<TodoItem>)Memory.ToList());
    public Task SaveAsync(IReadOnlyList<TodoItem> items, CancellationToken ct = default)
    { Memory.Clear(); Memory.AddRange(items); return Task.CompletedTask; }
}

public class MainViewModelTests
{
    [Fact]
    public async Task Add_Then_Save_Persists_New_Item()
    {
        var store = new FakeStore();
        var vm = new MainViewModel(store);

        vm.NewTitle = "Write tests";
        vm.AddCommand.Execute(null);

        vm.Items.Should().HaveCount(1);
        await vm.SaveAsync();

        store.Memory.Should().HaveCount(1);
        store.Memory[0].Title.Should().Be("Write tests");
    }

    [Fact]
    public void Filter_Active_Shows_Only_Not_Completed()
    {
        var store = new FakeStore();
        var vm = new MainViewModel(store);
        vm.Items.Add(new TodoItemViewModel(new TodoItem{ Title="A", IsCompleted=false }));
        vm.Items.Add(new TodoItemViewModel(new TodoItem{ Title="B", IsCompleted=true  }));

        vm.Filter = FilterMode.Active;
        vm.View.Cast<object>().Should().HaveCount(1);
    }
}
```

---

## 12) (선택) EF Core/SQLite로 저장소 교체

```csharp
// TodoApp.Storage/Db.cs
using Microsoft.EntityFrameworkCore;
using TodoApp.Domain.Models;

public sealed class TodoDb : DbContext
{
    public DbSet<TodoItem> Todos => Set<TodoItem>();
    public TodoDb(DbContextOptions<TodoDb> options) : base(options) {}
    protected override void OnModelCreating(ModelBuilder b)
    {
        b.Entity<TodoItem>(e =>
        {
            e.HasKey(x => x.Id);
            e.Property(x => x.Title).IsRequired().HasMaxLength(200);
            e.HasIndex(x => x.IsCompleted);
            e.HasIndex(x => x.Due);
        });
    }
}
```

```csharp
// TodoApp.Storage/EfTodoStore.cs
using Microsoft.EntityFrameworkCore;
using TodoApp.Domain.Contracts;
using TodoApp.Domain.Models;

public sealed class EfTodoStore : ITodoStore
{
    private readonly TodoDb _db;
    public EfTodoStore(TodoDb db) => _db = db;

    public async Task<IReadOnlyList<TodoItem>> LoadAsync(CancellationToken ct = default)
        => await _db.Todos.AsNoTracking().OrderByDescending(x=>x.CreatedAt).ToListAsync(ct);

    public async Task SaveAsync(IReadOnlyList<TodoItem> items, CancellationToken ct = default)
    {
        // 간단한 동기화 방식(실전은 Upsert/변경 추적 필요)
        _db.Todos.RemoveRange(_db.Todos);
        await _db.Todos.AddRangeAsync(items, ct);
        await _db.SaveChangesAsync(ct);
    }
}
```

DI 교체:
```csharp
// App.xaml.cs ConfigureServices 내부
// s.AddDbContext<TodoDb>(opt => opt.UseSqlite($"Data Source={dbPath}"));
// s.AddScoped<ITodoStore, EfTodoStore>();
```

> **실전**: 완전 교체보다는 **개별 CRUD** 구현 + 변경 추적이 낫습니다. 여기서는 구조 이해를 위해 간단화.

---

## 13) 접근성/국제화/테마

- 각 버튼/체크박스에 `AutomationProperties.Name` 지정
- `InputGestureText` 표시로 키보드 힌트 제공
- 다크모드 테마는 `DynamicResource`로 브러시 토큰화—필요 시 교체

---

## 14) 에러 처리/로깅

- 저장 실패 시 메시지 + 재시도 버튼(실무에서는 `Serilog` 등 로깅 프레임워크)
- 일시적 I/O 오류는 재시도(파일 잠금) → `Task.Delay` 후 재시도

---

## 15) 마무리 체크리스트

**설계**
- [x] 도메인/저장소/뷰모델/뷰 분리(MVVM)
- [x] 저장소 교체 용이(인터페이스)
- [x] 단위 테스트 가능(가짜 저장소)

**UX**
- [x] 검색/필터/정렬
- [x] 인라인 편집, 단축키
- [x] Undo/Redo, 완료 정리

**성능/안정**
- [x] 리스트 가상화/리사이클
- [x] 비동기 저장/로드 + 진행 표시
- [x] 원자적 저장(임시파일 → 교체)

---

## 16) 다음 단계(확장 아이디어)
- 리마인더/기한 도래 알림(DispatcherTimer)
- 보드 뷰(Drag&Drop으로 상태/우선순위 변경)
- REST API 동기화(오프라인/ETag, 앞서 만든 패턴 재사용)
- 다중 창/탭(다중 UI 스레드는 고급—권장 X)

---

### 전체 요약
이 설계는 **작지만 완전한** MVVM 구조입니다.  
- UI는 **ViewModel에만 의존**, 저장소/영속화는 **교체 가능**.  
- 목록은 **가상화**로 부드럽고, 저장/로드는 **비동기**.  
- 테스트로 핵심 동작을 **안전하게 검증**합니다.