---
layout: post
title: 컴퓨터시스템 - 재배치
date: 2025-08-11 15:20:23 +0900
category: 컴퓨터시스템
---
# 재배치(Relocation)

## 0. 한눈 요약

- **언제 일어나나**: (1) **정적 링크** 시 링커가 대부분의 재배치를 해결. (2) **동적 로딩** 시 로더(ld.so)가 남은 동적 재배치를 해결.  
- **왜 필요하나**: 컴파일 타임에는 함수/전역의 **최종 주소 미정**, **PIC/PIE+ASLR** 로 로드 베이스는 런타임마다 다르다.  
- **핵심 구조**:  
  - **RELA**(x86-64 주류) / **REL**(아키텍처에 따라 사용)  
  - **GOT/PLT**(외부 데이터/함수 간접 참조), **RELATIVE**(베이스+가산)  
- **성능/보안 요지**:  
  - `R_*_RELATIVE`는 **대량·빠름**(루프 최적화 가능).  
  - `COPY`/TEXTREL(텍스트 재배치)은 **회피**.  
  - 보안은 **PIE + RELRO(+NOW)** 를 기본으로.

---

## 1. 재배치가 필요한 이유

- 최종 주소는 **링크 전에는 불명**: 여러 .o를 합치고 주소 배치(layout) 후에야 결정된다.  
- **PIC/PIE + ASLR**: 로드 베이스가 실행 시 결정. 코드에는 절대주소를 박지 않고 상대/간접으로 접근.  
- **모듈성**: 외부 .so에 정의된 심볼을 **런타임까지 미뤄** 결속한다(업데이트/공유/감축).

---

## 2. 전체 흐름 — 컴파일 → 정적 링크 → 동적 로딩

```
소스 C/ASM
  │  (컴파일/어셈)
  ▼
.obj(.o) ──┐   각 .o의 .text/.data와 함께
            └─► .rela.text/.rela.data ... 에 "패치 목록" 기록
  │
  │ (정적 링크, 심볼 해석/배치)
  ▼
ELF 실행파일(PIE/EXEC) 또는 DSO(.so)
  │          └ 일부 재배치는 남겨두고(.dynsym/.rela.dyn 등)
  │
  │ (exec/ld.so 로드)
  ▼
메모리 매핑 + 동적 재배치 처리 + (지연 바인딩)
```

- **정적 링크**: 링커가 **내부/상수**는 다 채우고, **외부/가변**은 GOT/PLT 기반으로 남긴다.  
- **동적 로딩**: 로더가 **DT_RELA/DT_REL** 목록을 순회, **GOT/PLT/RELATIVE** 등을 패치.

---

## 3. ELF 재배치 엔트리: REL vs RELA, 필드 의미

### 3.1 REL vs RELA
- **REL**: `{ r_offset, r_info }` — 덧셈값(addend)은 코드/데이터 내에 **인라인**.  
- **RELA**: `{ r_offset, r_info, r_addend }` — 덧셈값을 **명시 필드**로 보유.  
- **x86-64는 RELA가 표준**(가독성/이식성↑).

### 3.2 필드
| 필드      | 의미 |
|-----------|------|
| `r_offset`| 패치할 **장소(place)** 의 파일 오프셋/가상주소(세그먼트 맥락에서) |
| `r_info`  | `(심볼 인덱스, 재배치 타입)` 묶음 |
| `r_addend`| (RELA만) 추가 상수 A |
| `sym`     | (논리) 재배치가 참조하는 **심볼 S** |

---

## 4. 재배치 계산의 표준 기호와 수식

ELF 문헌에서 즐겨 쓰는 기호:
- \( S \): 심볼의 값(주소)  
- \( P \): 재배치 **장소(place)** 의 주소(= `r_offset`가 가리키는 대상의 주소)  
- \( A \): addend(덧셈 값, RELA의 `r_addend` 또는 코드 내 인라인)  
- \( B \): 로드 베이스(PIE/DSO의 베이스)  
- \( G \): 심볼의 GOT 엔트리 주소  
- \( GOT \_ offset \): GOT 내 특정 엔트리까지의 오프셋

**대표 공식**
- **PC상대**: \(\text{Result} = S + A - P\)  
- **절대**: \(\text{Result} = S + A\)  
- **RELATIVE**(베이스 상대): \(\text{Result} = B + A\)  
- **GOTPCREL**: \(\text{Result} = G + A - P\)  (RIP 상대로 GOT 엔트리 주소를 얻음)

---

## 5. x86-64 대표 재배치 타입과 의미

| 타입 | 의미(요지) | 수식/행동 | 흔한 사용 |
|---|---|---|---|
| `R_X86_64_PC32` | 32비트 **PC상대** | \(S + A - P\) | 근거리 call/jmp(링크타임 확정) |
| `R_X86_64_PLT32` | PLT 엔트리 상대 | \(S_{PLT} + A - P\) | 외부 함수 호출(PLT 경유) |
| `R_X86_64_64` | 절대 64비트 | \(S + A\) | 절대주소 상수/테이블 |
| `R_X86_64_GOTPCREL` | GOT 엔트리 주소(RIP상대) | \(G + A - P\) | 외부 전역 데이터 주소 간접 |
| `R_X86_64_GLOB_DAT` | GOT 엔트리 채움 | GOT\[sym] ← \(S\) | 동적 로더가 채움 |
| `R_X86_64_JUMP_SLOT` | 함수 GOT/PLT 엔트리 채움 | GOT\[func] ← \(S\) | 동적 로더/지연 바인딩 |
| `R_X86_64_RELATIVE` | 베이스+가산 | *(P)* ← \(B + A\) | PIE/DSO 대량 초기화 |
| `R_X86_64_COPY` | 실행파일로 **전역 데이터 복사** | *(dest)* ← *(src from DSO)* | 구호환(권장X) |

> **메모**: `COPY`는 전역 데이터의 **인터포지션** 유산. 현대 설계에서는 **회피** 권장(섹션 배치/가시성 관리).

---

## 6. GOT/PLT와 지연 바인딩(Lazy Binding)

### 6.1 흐름(함수)
1) 코드: `call foo@PLT`  
2) `PLT0` → 로더 바인더 진입 → **심볼 foo 해석**  
3) `GOT[foo]`에 **진짜 주소** 저장  
4) 이후 호출은 `GOT[foo]`를 통해 **직행**

### 6.2 흐름(데이터 전역)
- 코드: `[rip + ext@GOTPCREL]` 로 **GOT 엔트리 주소**를 얻어, 그곳이 가리키는 실제 전역을 로드.  
- 로더: `R_X86_64_GLOB_DAT` 로 **GOT 엔트리**에 실제 주소를 써넣는다.

---

## 7. 실습 ① — 소스·옵션별로 어떤 재배치가 나오나

### 7.1 외부 함수 호출(PLT)
```c
// use.c
extern int foo(int);
int use(int x){ return foo(x) + 1; }
```
```bash
gcc -fPIC -c use.c
readelf -r use.o
objdump -drwC use.o | sed -n '1,120p'
```
- `R_X86_64_PLT32 foo` 혹은 상황에 따른 `PC32`(툴체인 버전에 따라 PLT32 사용 선호).  
- 최종 DSO/PIE에선 `R_X86_64_JUMP_SLOT`으로 GOT/PLT 엔트리 채움.

### 7.2 외부 전역 데이터(GOTPCREL)
```c
// g.c
extern int ext;
int g(void){ return ext; }
```
- 어셈: `mov rax, qword ptr [rip + ext@GOTPCREL]` → `mov eax, [rax]`  
- 재배치: `R_X86_64_GOTPCREL` (오브젝트 단계), DSO/PIE에서는 `GLOB_DAT`로 채움.

### 7.3 로컬 read-only 데이터(RIP-relative)
```c
// ro.c
static const char msg[] = "hi";
const char* get_msg(void){ return msg; }
```
- `lea rax, [rip + .Lmsg]` — 외부 노출이 아니므로 **GOT 불필요**.  
- 산출물 확인: `objdump -d ro.o`

### 7.4 RELATIVE 대량 초기화 확인(PIE)
```bash
gcc -fpie -pie app.c -o app
readelf -r app | grep RELATIVE | head
```
- `RELATIVE`가 많다면 **빠른 초기화 루프**로 처리됨(로더 최적화 포인트).

---

## 8. 실습 ② — 동적 바인딩 로그/맵핑 관찰

```bash
LD_DEBUG=libs,reloc,bindings ./app 2>&1 | less
readelf -dW libx.so         # .dynamic(NEEDED, RUNPATH, SONAME)
objdump -R ./app            # GOT/PLT 재배치 테이블
```

- `bindings`에서 어떤 심볼이 **어느 DSO**로 결속되었는지 확인.  
- `reloc`은 `GLOB_DAT/JUMP_SLOT/RELATIVE` 처리 상황을 보여준다.

---

## 9. 정적 재배치 vs 동적 재배치 — 성능·특성

### 9.1 정적 재배치(링크 타임)
- 장점: 실행 시 오버헤드 **0**(이미 패치 완료).  
- 단점: 주소 배치가 **고정**되기 쉬움(PIE/PIC 이점 상실), 모듈성↓.

### 9.2 동적 재배치(로드 타임)
- 장점: **PIE/PIC/ASLR/공유** 를 통해 보안·메모리 이득.  
- 단점: 시작 비용(재배치 루프 + 페이지 폴트), 첫 호출 지연(지연 바인딩).

**간단 모델**  
초기 지연 기대시간:
$$
T_\text{start} \approx N_{\text{RELATIVE}}\cdot c_r + N_{\text{SYMBOL}}\cdot c_s,
$$
여기서 \(c_r\)는 RELATIVE 1건 코스트(아주 작음), \(c_s\)는 심볼 해석 코스트(해시/gnu-hash 탐색·의존 트리).

---

## 10. 텍스트 재배치(TEXTREL)와 `R_*_COPY` — 반드시 피하기

- **TEXTREL**: 코드(.text)에 **쓰기 재배치**가 필요 → 페이지를 R/W/X로 열거나 **공유 깨짐**. 보안/성능 모두 악영향.  
- **`R_X86_64_COPY`**: 실행파일로 전역 데이터를 **복사**하여 인터포지션을 흉내내는 유산. 데이터 일관성/성능 문제.  
**대응**: `-fPIC` 준수, 전역 가시성 관리(`hidden/protected`), `COPY` 유발 패턴 회피.

---

## 11. TLS(Thread-Local Storage) 재배치 (개요)

- TLS 심볼 접근은 모델에 따라 다르다: **LE/IE/LD/GD**.  
- 동적 로딩에서 로더는 TLS 블록을 준비하고 `R_X86_64_TPOFF32/64`, `DTPMOD64`, `DTPOFF64` 등 처리.  
- **성능**: 가능하면 **IE(Local Exec 초기화 시 고정)** 모델을 쓰면 빠르다(배치 제약 수용 시).  
- **API 설계 팁**: TLS 변수 주소를 `dlsym`으로 직접 주고받기보다 **함수 래퍼**로 추상화.

---

## 12. IFUNC와 `IRELATIVE`

- **IFUNC(Indirect Function)**: 해석 시 **리졸버 함수**가 최적 구현 주소를 반환(예: AVX2 가능 시 고속 루틴).  
- 재배치: `R_X86_64_IRELATIVE` — \(*(P) ← resolver(B + A))* 형태.  
- 주의: 초기화 순서/스레드 안전·결정성 요구(리졸버는 순수 함수가 바람직).

---

## 13. 보안 연동 — PIE/RELRO/NOW

- **PIE**: 실행파일도 **DYN** 타입(DT_RELA 등 포함), ASLR로 베이스 무작위.  
- **RELRO**: GOT 등 재배치 후 **읽기 전용 잠금**.  
  - `-Wl,-z,relro -Wl,-z,now` → Full RELRO(지연 바인딩 해제).  
- **효과**: 인터포지션/PLT 하이재킹 난이도↑, 안정성↑.

---

## 14. ARM64(간단 비교)

- 주소 형성: `ADRP + ADD` 페어로 **페이지 베이스** + 오프셋.  
- 외부 함수: `adrp/ldr` 로 GOT 엔트리 로드 후 `blr xN`.  
- 재배치 타입: `R_AARCH64_ADR_PREL_PG_HI21`, `R_AARCH64_ADD_ABS_LO12_NC`, `R_AARCH64_JUMP_SLOT`, `R_AARCH64_GLOB_DAT`, `R_AARCH64_RELATIVE` 등.

---

## 15. 실전 레시피 — 특정 재배치 유도/회피하기

| 목표 | 소스/옵션 | 결과 |
|---|---|---|
| 외부 함수 호출을 PLT 경유 | `extern int foo(int); foo(x);` + DSO/PIE | `PLT32`(오브젝트) → `JUMP_SLOT`(런타임) |
| 외부 전역 데이터 간접 | `extern int ext; return ext;` | `GOTPCREL`(오브젝트) → `GLOB_DAT`(런타임) |
| 내부 상수는 RIP상대 | `static const char s[]` | **GOT 불필요**, `RELATIVE`만 남음 |
| TEXTREL 회피 | 전역 절대주소 상수 금지, `-fPIC`, ASM에서 RIP상대 사용 | 텍스트 R/W 방지 |
| COPY 회피 | 실행파일에 대형 전역 노출 피하기, 가시성 제한 | 데이터 일관성 유지 |

---

## 16. 디버깅 명령 요약

```bash
# 재배치 테이블
readelf -r a.o
readelf -r app
readelf -r libx.so

# 디스어셈+재배치 주석
objdump -drwC app | less

# 동적 로더 로그
LD_DEBUG=reloc,bindings ./app 2>&1 | less

# GOT/PLT 관찰
objdump -R app
objdump -T libx.so | less

# 전체 상태 스냅샷
readelf -aW app | less
```

---

## 17. 미니 워크스루 — `RELATIVE/GLOB_DAT/JUMP_SLOT` 눈으로 보기

```c
// libx.c
#include <stdio.h>
int ext = 7;
__attribute__((visibility("hidden")))
static const char msg[] = "hello";
void x_hello(void){ puts(msg); }
int  x_add(int a){ return a + ext; }
```
```c
// app.c
#include <stdio.h>
void x_hello(void);
int  x_add(int);
int main(){
  x_hello();
  printf("%d\n", x_add(10));
}
```

```bash
gcc -fPIC -shared libx.c -o libx.so
gcc -fpie -pie app.c -L. -lx -Wl,-rpath,. -o app

readelf -r app | egrep 'RELATIVE|JUMP_SLOT|GLOB_DAT'
objdump -d libx.so | less      # msg는 RIP상대(내부), GOT 불필요
objdump -R app | less          # x_add JUMP_SLOT / ext GLOB_DAT
```

- **관찰 포인트**:  
  - `x_hello`의 `msg` 접근은 **RIP상대** → `RELATIVE`로만 해결, 빠름.  
  - `x_add` 호출은 **PLT/GOT** 경유 → `JUMP_SLOT`.  
  - `ext`는 **GLOB_DAT** 로 GOT 엔트리 채움.

---

## 18. 흔한 오류와 처방

| 증상 | 원인 | 처방 |
|---|---|---|
| `TEXTREL` 경고/실패 | 절대주소 상수/ASM 실수 | `-fPIC`, RIP상대 사용, ASM 수정 |
| `R_*_COPY` 다수 | 실행파일 전역 데이터 인터포지션 | 가시성 축소/설계 변경 |
| 첫 호출 급정지 | 지연 바인딩 미스 | `-Wl,-z,now` 또는 스타트업 워밍 |
| 데이터 값 미일치 | COPY/인터포지션 부작용 | COPY 회피, DSO 내부 고정(`-Bsymbolic`) |
| 성능 저하 | PLT 간접/인터포지션 | `-fno-semantic-interposition`, `hidden/protected`, RELRO+NOW |

---

## 19. 체크리스트

- [ ] **산출물 점검**: `readelf -r/-d`, `objdump -drwC/-R/-T`  
- [ ] **PIE** 사용(보안): `-fpie -pie`  
- [ ] **RELRO(+NOW)**: `-Wl,-z,relro -Wl,-z,now`  
- [ ] **TEXTREL**/`COPY` 없는지 확인  
- [ ] 가시성 관리: `-fvisibility=hidden` + 공개 API만 `default`  
- [ ] 핫경로 PLT 최소화: `-fno-semantic-interposition` / 내부 호출 고정  
- [ ] TLS/IFUNC 사용 시 초기화 순서·스레드안전 점검  
- [ ] 문제 나면 **LD_DEBUG** 로그로 결속 경로 확인

---

## 20. 부록 — `readelf` 출력 읽는 법(샘플)

```
Relocation section '.rela.plt' at offset 0x... contains 1 entries:
  Offset          Info           Type           Sym.Value  Sym.Name + Addend
000000401018  000300000007 R_X86_64_JUMP_SLOT  00000000   x_add + 0
```
- **`.rela.plt`**: 함수 호출용 GOT/PLT 재배치.  
- **`JUMP_SLOT`**: 로더가 GOT\[x_add]에 실제 주소 기록.

```
Relocation section '.rela.dyn' at offset 0x... contains N entries:
  Offset          Info           Type             Sym.Value  Sym.Name + Addend
000000402000  ...               R_X86_64_RELATIVE           + 0x1234
000000403008  ...               R_X86_64_GLOB_DAT 000...    ext + 0
```
- **RELATIVE**: 베이스+가산(빠른 루프 처리).  
- **GLOB_DAT**: 전역 데이터용 GOT 엔트리.

---

## 21. 맺음말

재배치는 **“미정 참조를 실제 주소로 바꾸는 패치”**다.  
x86-64/ELF 세계에서 **RIP-상대 + GOT/PLT + RELATIVE** 조합은 **ASLR 보안과 성능**을 함께 잡는다.  
현대 빌드는 **PIE + RELRO(+NOW)** 를 기본으로, **TEXTREL/COPY 회피**, **가시성 제어**로  
**최소 재배치·빠른 초기화·안전한 결속**을 이루는 것이 정석이다.