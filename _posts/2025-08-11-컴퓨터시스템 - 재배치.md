---
layout: post
title: 컴퓨터시스템 - 재배치
date: 2025-08-11 15:20:23 +0900
category: 컴퓨터시스템
---
# 재배치(Relocation) — 링커와 로더의 주소 결속 과정

**재배치(Relocation)**는 목적 파일(.o) 또는 실행 파일/공유 라이브러리(.so)에서  
아직 확정되지 않은 **주소/오프셋 참조**를 실제 메모리 주소로 **패치**하는 과정이다.  
이 작업은 **정적 링크 시점**과 **동적 로딩 시점** 모두에서 일어나며,  
컴파일러·어셈블러·링커·로더가 모두 관여한다.

---

## 1) 재배치가 필요한 이유
- **컴파일 시점**에는 함수나 전역변수의 최종 주소를 알 수 없음.
- **PIC/PIE 코드**에서는 로드 주소가 매 실행마다 달라질 수 있음.
- 외부 모듈(다른 .o/.so)에 정의된 심볼의 위치를 런타임까지 미룰 수 있음.
- 코드와 데이터의 위치를 변경하더라도 참조가 깨지지 않게 함.

---

## 2) 재배치의 기본 흐름

### 2.1 컴파일러 단계
- 참조 위치를 **임시 값(0)** 또는 **심볼 기반 참조**로 기록.
- 어셈블러는 `.text`, `.data`, `.rodata` 등에 기계어와 함께  
  **재배치 엔트리(Relocation Entry)** 를 `.rel.text`, `.rela.text` 등 섹션에 기록.

### 2.2 정적 링크(Offline)
- 링커는 모든 목적 파일과 라이브러리를 합치면서 심볼 해석을 수행.
- 각 재배치 엔트리에 대해 **해당 심볼의 실제 주소**를 계산 후 패치.
- 실행 파일 또는 DSO 내부 참조는 **완전한 절대주소**로 대체 가능.
- 외부 심볼(동적 링크 대상)은 `.plt`, `.got` 등을 통해 간접 참조하도록 남김.

### 2.3 동적 로딩(Runtime)
- **ld.so**(동적 로더)는 실행 시 DSO를 로드하고 남아 있는 재배치를 처리.
- `R_X86_64_GLOB_DAT`, `R_X86_64_JUMP_SLOT` 등 **동적 재배치 타입**에 따라 GOT/PLT에 실제 주소 기록.
- **지연 바인딩(lazy binding)**을 쓰면, 함수 주소는 첫 호출 때 채워짐.

---

## 3) ELF에서 재배치 엔트리 구조

### 3.1 REL / RELA
- **REL**: 오프셋(offset) + 타입(type) + 심볼 인덱스(symbol index)  
  → 패치할 위치와 심볼만 지정, 별도 addend는 코드/데이터에 포함.
- **RELA**: REL + addend(덧셈 값) 필드 포함.
- x86-64에서는 주로 **RELA** 사용.

### 3.2 필드 의미
| 필드        | 설명 |
|-------------|------|
| r_offset    | 재배치할 대상의 파일 오프셋 |
| r_info      | 심볼 인덱스 + 재배치 타입 |
| r_addend    | (RELA 전용) 추가 상수 값 |
| sym         | 심볼 테이블에서 참조할 엔트리 |

---

## 4) 재배치 타입 예시(x86-64)

| 타입 | 설명 | 용도 |
|------|------|------|
| `R_X86_64_PC32` | 32비트 상대 주소 | 분기/호출 |
| `R_X86_64_64`   | 절대 64비트 주소 | 전역 변수 참조 |
| `R_X86_64_GOTPCREL` | GOT 엔트리 상대 참조 | PIC 데이터 접근 |
| `R_X86_64_PLT32` | PLT 엔트리 상대 참조 | PIC 함수 호출 |
| `R_X86_64_GLOB_DAT` | GOT 엔트리 채움 | 전역 데이터 |
| `R_X86_64_JUMP_SLOT` | PLT 엔트리 채움 | 함수 호출 |
| `R_X86_64_RELATIVE` | 베이스 주소 + addend | PIE 재배치 |
| `R_X86_64_COPY` | 실행파일로 전역 데이터 복사 | DSO 데이터 인터포지션 |

---

## 5) 정적 재배치 vs 동적 재배치

### 5.1 정적 재배치
- **정적 링크**에서 처리 → 실행 파일에 남지 않음.
- 성능 이점: 실행 시 재배치 비용 없음.
- 단점: 실행 파일의 코드·데이터 위치가 고정됨(PIC/PIE 아님).

### 5.2 동적 재배치
- 실행 시 로더가 처리.
- PIC/PIE를 지원하고 라이브러리 공유 가능.
- 단점: 실행 초기에 추가 오버헤드, 캐시 미스 유발.

---

## 6) 성능 관점의 재배치
- **R_X86_64_RELATIVE** 재배치는 빠르고 대량 적용 가능(주소 = 베이스 + 상수).
- **GOT/PLT** 경유 호출은 분기 예측 실패 가능.
- **지연 바인딩**은 첫 호출 지연이 크지만 이후는 캐시됨.
- `LD_BIND_NOW=1`로 미리 바인딩하면 성능 안정성을 높일 수 있음(대신 초기 로드 느림).

---

## 7) 디버깅/분석 명령어

```bash
# ELF 재배치 목록 보기
readelf -r main.o
readelf -r app
readelf -r libx.so

# 디스어셈블에서 재배치 표시
objdump -drwC app

# 동적 바인딩 로그
LD_DEBUG=reloc ./app
```

---

## 8) 예제 — 정적 재배치

```c
// foo.c
extern int x;
int foo(void) { return x + 1; }
```

```bash
gcc -c foo.c -o foo.o
readelf -r foo.o
```

출력 예:
```
Relocation section '.rela.text' at offset 0x... contains 1 entries:
  Offset          Info           Type           Sym.Value  Sym.Name + Addend
0000000000000000  0000000300000002 R_X86_64_PC32 00000000   x -4
```
→ `x`의 주소가 링크 시점에 패치됨.

---

## 9) 결론
재배치는 **"아직 주소를 모르는 참조에 주소를 채워 넣는 작업"**이다.  
정적 재배치로 실행 시 오버헤드를 줄일 수 있지만 유연성이 떨어지고,  
동적 재배치는 모듈성·보안(ASLR)·공유성을 높이지만 초기화 비용이 있다.  
따라서 빌드 목표와 배포 환경에 맞춰 **PIC 여부, 재배치 최소화, 가시성 제어**를 조합해야 한다.