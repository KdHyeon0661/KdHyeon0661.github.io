---
layout: post
title: Elixir - 모듈과 기명 함수 (1)
date: 2025-11-14 22:25:23 +0900
category: Elixir
---
# 모듈, 속성, 얼랭 연동, 라이브러리 탐색 완전 정리

## 모듈 (Modules)

### 모듈 정의·네임스페이스·중첩

```elixir
defmodule MyApp.Math do
  @moduledoc "수학 유틸"

  def add(a, b), do: a + b
end

defmodule MyApp.Web.Controller.User do
  def index(params), do: {:ok, params}
end
```

- 모듈명은 **대문자 시작의 CamelCase**, 점(`.`)으로 **네임스페이스**를 구분한다.
- 파일명은 보통 `lib/my_app/math.ex`, `lib/my_app/web/controller/user.ex` 처럼 **snake_case 경로**로 매핑한다(관례).

#### 모듈 이름과 디렉터리 구조 매핑

일반적인 매핑 관례를 표로 정리하면:

| 모듈 이름                        | 권장 파일 경로                         |
|----------------------------------|----------------------------------------|
| `MyApp`                          | `lib/my_app.ex`                        |
| `MyApp.Math`                     | `lib/my_app/math.ex`                   |
| `MyApp.Web.Controller.User`      | `lib/my_app/web/controller/user.ex`    |
| `MyApp.Accounts.Normalize`       | `lib/my_app/accounts/normalize.ex`     |
| `MyApp.Accounts.Persist`         | `lib/my_app/accounts/persist.ex`       |

이 관례를 따르지 않아도 **동작은** 하지만, 다음 문제들이 생긴다.

- 새로 합류한 사람이 **코드 위치를 추적하기 어려움**
- `mix xref`, `mix compile` 경고 메시지에서 나오는 경로와 실제 파일 구조가 어긋남
- 에디터/IDE의 “Go to Definition” 기능이 엉뚱한 곳을 가리킬 수 있음

#### 중첩 모듈 vs 한 파일에 여러 모듈

엘릭서에서는 한 파일에 **여러 모듈을 정의**할 수도 있다.

```elixir
# lib/my_app/math.ex

defmodule MyApp.Math do
  def add(a, b), do: a + b
end

defmodule MyApp.Math.Vector2D do
  def add({x1, y1}, {x2, y2}), do: {x1 + x2, y1 + y2}
end
```

하지만 실무에서는 다음 가이드가 안정적이다.

- “**작은 유틸리티 모듈**”은 한 파일에 여러 개 있어도 괜찮지만
- **컨텍스트(Accounts, Billing, Web 등)** 역할을 하는 모듈은
  보통 **한 파일에 한 모듈**로 두고,
  하위 모듈은 **디렉터리 분할**로 관리한다.

예:

```text
lib/my_app/accounts.ex              # MyApp.Accounts (공개 API)
lib/my_app/accounts/normalize.ex    # MyApp.Accounts.Normalize
lib/my_app/accounts/persist.ex      # MyApp.Accounts.Persist
```

---

### `alias/import/require/use` 의도 구분

```elixir
defmodule MyApp.Controller do
  alias MyApp.Math, as: M         # 이름 축약
  import Kernel, only: [tap: 2]   # 함수 직접 사용
  require Logger                  # 매크로 호출 위해 필요
  use GenServer                   # 보일러플레이트 주입(__using__/1)

  def run(xs) do
    xs
    |> Enum.map(&M.add(&1, 1))
    |> tap(&Logger.debug("mapped=#{inspect(&1)}"))
  end
end
```

- **alias**: 긴 모듈 이름 단축(충돌 주의).
- **import**: 함수 심벌을 현재 스코프로 가져옴(남용 금지, `only/except` 사용).
- **require**: **매크로**를 쓰기 전 필요.
- **use**: 상대 모듈이 제공하는 **매크로 기반 초기화** 실행.

#### alias — 길고 중복되는 모듈 이름 줄이기

```elixir
defmodule MyApp.Billing.Invoice do
  alias MyApp.Accounts.User
  alias MyApp.Payments.{Gateway, Currency}

  def charge(%User{} = user, amount) do
    amount
    |> Currency.to_cents()
    |> Gateway.charge(user)
  end
end
```

- `alias MyApp.Accounts.User` → `User` 로 단축
- `alias MyApp.Payments.{Gateway, Currency}` → 여러 모듈 한 줄 alias

권장 패턴:

- 파일 상단에서 alias를 정리하여 **한눈에 의존성을 파악**하게 한다.
- 단, 같은 이름(`Repo`, `User` 등)을 다른 모듈에서 alias하면 **충돌**하므로 주의.

안티패턴:

```elixir
alias MyApp.Accounts.User, as: U
alias MyApp.Payments.Gateway, as: G
alias MyApp.Orders.Order, as: O
```

- 한 글자 축약은 읽는 사람이 **의미를 바로 짐작하기 어렵다.**
  (`Repo`, `User` 정도는 예외적으로 자주 쓰이지만, 너무 축약하지 않는 편이 낫다.)

#### import — 함수 이름을 현재 스코프로 끌어오기

```elixir
defmodule MyApp.Text do
  import String, only: [trim: 1, downcase: 1]

  def normalize_email(email) do
    email |> trim() |> downcase()
  end
end
```

장점:

- `String.trim/1`, `String.downcase/1` 대신 `trim/1`, `downcase/1`로 간결하게 쓸 수 있다.

주의점:

- **많이 import 하면** “이 이름이 어느 모듈에서 온 것인지” 찾기 어려워진다.
- 따라서 다음 가이드가 좋다.

  - 한 모듈에서 import 하는 함수는 **몇 개 안 되도록** 제한
  - `only: [f1: arity1, f2: arity2]` 로 **명시적**으로 범위 제한
  - `Kernel` 조차도 필요하면 `only/except` 로 정제해서 import

#### require — 매크로 호출 전 필수

```elixir
defmodule MyApp.Logging do
  require Logger

  def debug_map(map) when is_map(map) do
    Logger.debug("map=#{inspect(map)}")
  end
end
```

- `Logger.debug/1` 는 **매크로**이므로,
  단순히 `alias Logger` 만으로는 부족하다.
- `require Logger` 를 통해 컴파일러가
  “이 모듈이 **매크로를 제공**한다”는 사실을 알게 된다.

실수 예:

```elixir
defmodule MyApp.Bad do
  alias Logger
  def log(msg), do: Logger.debug(msg)   # 컴파일 에러
end
```

- `alias`만 있으면 `Logger.debug/1` 매크로를 찾지 못한다.
- 매크로를 쓰는 모듈은 반드시 `require` 해야 한다.

#### use — 보일러플레이트 주입(__using__/1)

```elixir
defmodule MyApp.Worker do
  use GenServer

  def start_link(init_arg) do
    GenServer.start_link(__MODULE__, init_arg, name: __MODULE__)
  end

  @impl true
  def init(state), do: {:ok, state}
end
```

- `use GenServer` 는 `GenServer.__using__/1` 매크로를 호출하여
  필요한 behavior, 기본 구현, 콜백 등을 모듈에 주입한다.

직접 `use`를 정의하는 예:

```elixir
defmodule MyApp.Controller do
  defmacro __using__(_opts) do
    quote do
      import Plug.Conn
      alias MyApp.Router.Helpers, as: Routes

      def put_json(conn, data) do
        conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, Jason.encode!(data))
      end
    end
  end
end

defmodule MyApp.UserController do
  use MyApp.Controller

  def index(conn, _params) do
    put_json(conn, %{users: []})
  end
end
```

- `use MyApp.Controller` 한 줄로
  공통 import/alias/helper 함수를 주입할 수 있다.
- `use`는 매우 강력하지만,
  “보이지 않는 코드”를 주입한다는 점에서 **주의해서 설계**해야 한다.

---

### 모듈 분할과 공개 API

```elixir
# lib/my_app/accounts.ex

defmodule MyApp.Accounts do
  alias MyApp.Accounts.{Normalize, Persist}

  def signup(params) do
    params |> Normalize.email() |> Persist.user()
  end
end

# lib/my_app/accounts/normalize.ex

defmodule MyApp.Accounts.Normalize do
  def email(%{"email" => e} = p), do: Map.put(p, "email", String.trim(e))
end

# lib/my_app/accounts/persist.ex

defmodule MyApp.Accounts.Persist do
  def user(p), do: Map.put(p, :id, System.unique_integer([:positive]))
end
```

- **표면적 API**는 `MyApp.Accounts.signup/1` 정도로 **얇게 노출**, 내부는 세분화.
- 테스트는 **공개 API 중심**으로 시나리오를 검증한다.

#### 컨텍스트 모듈 패턴

위 예는 컨텍스트 모듈 패턴의 전형이다.

- `MyApp.Accounts`
  - “계정/사용자 도메인”의 **진입점**
- `MyApp.Accounts.Normalize`, `MyApp.Accounts.Persist`
  - 실제 구현을 담는 **내부 모듈**

장점:

- 외부에서 사용하는 모듈은 `MyApp.Accounts` **하나**만 기억하면 된다.
- 내부 구현 세부사항(정규화 방식, 저장소 종류 등)을
  **나중에 얼마든지 바꾸기 쉬움**.
- 테스트 코드:

  ```elixir
  defmodule MyApp.AccountsTest do
    use ExUnit.Case, async: true

    alias MyApp.Accounts

    test "signup trims email and sets id" do
      {:ok, user} = Accounts.signup(%{"email" => "  x@example.com  "})
      assert user.email == "x@example.com"
      assert is_integer(user.id)
    end
  end
  ```

  - 내부 모듈을 직접 테스트하지 않고,
    공개 API 기준으로 시나리오를 검증한다.

---

### 동적 모듈 이름 합성

```elixir
iex> Module.concat(MyApp, "Dynamic" <> "Mod")
MyApp.DynamicMod

iex> name = Module.concat(["MyApp", "Feature", "V1"])
MyApp.Feature.V1
```

- 런타임에 모듈명을 합성해야 할 때(플러그인, 버전 라우팅 등) 유용.

#### 플러그인 구조 예시

```elixir
defmodule MyApp.PluginRunner do
  def run(plugin_name, payload) when is_binary(plugin_name) do
    module = Module.concat(MyApp.Plugins, plugin_name)

    if Code.ensure_loaded?(module) and function_exported?(module, :run, 1) do
      module.run(payload)
    else
      {:error, :unknown_plugin}
    end
  end
end
```

- `plugin_name` 에 `"ImageResize"` 가 들어오면
  `MyApp.Plugins.ImageResize` 모듈을 찾아서 실행
- 새 플러그인은 그저 `MyApp.Plugins.SomeName` 모듈로 만들어
  `run/1` 함수를 구현하면 된다.

안전장치:

- `Code.ensure_loaded?/1` 로 모듈이 로드 가능한지 확인
- `function_exported?/3` 로 기대하는 함수가 있는지 확인

---

### 모듈과 behaviour, 프로토콜(개요)

모듈은 다음과 같은 역할들을 겸한다.

1. **일반 모듈**: 함수들의 묶음
2. **behaviour 정의**: “이 인터페이스를 구현하는 모듈은 이런 콜백을 가져야 한다”는 규약
3. **behaviour 구현 모듈**: 콜백을 실제로 구현
4. **프로토콜 구현 모듈**: 특정 타입에 대한 프로토콜 구현

간단 behaviour 예:

```elixir
defmodule MyApp.Storage do
  @callback put(key :: binary(), value :: binary()) :: :ok | {:error, term()}
  @callback get(key :: binary()) :: {:ok, binary()} | :not_found
end

defmodule MyApp.Storage.InMemory do
  @behaviour MyApp.Storage

  @impl true
  def put(key, value) do
    :ets.insert(:storage, {key, value})
    :ok
  end

  @impl true
  def get(key) do
    case :ets.lookup(:storage, key) do
      [{^key, value}] -> {:ok, value}
      []              -> :not_found
    end
  end
end
```

- `@behaviour` 로 “이 모듈은 이 인터페이스를 구현한다”고 선언
- `@impl true` 로 콜백 구현을 명확히 표시

---

## 모듈 속성 (Module Attributes)

모듈 속성은 크게 **(A) 문서/타입/스펙 메타데이터**, **(B) 컴파일러 지시자/옵션**, **(C) 컴파일 타임 상수/누적 버퍼** 용도로 쓰인다.

### 문서·타입·스펙

```elixir
defmodule MyApp.API do
  @moduledoc """
  공개 API 모듈.
  """

  @doc "합"
  @spec add(number, number) :: number
  def add(a, b), do: a + b
end
```

- `@moduledoc`, `@doc`은 ExDoc/Doctest에 노출.
- `@spec`은 Dialyzer 등 정적 분석 도구와 문서화를 돕는다.

#### Doctest 예시

```elixir
defmodule MyApp.Math do
  @moduledoc """
  수학 유틸.

  ## Examples

      iex> MyApp.Math.add(1, 2)
      3
  """

  @doc """
  두 수를 더한다.
  """
  @spec add(number(), number()) :: number()
  def add(a, b), do: a + b
end
```

- `mix test` 시 Doctest가 자동 실행되어
  문서에 있는 예제 코드가 실제로 동작하는지 검증한다.

---

### 컴파일러 지시자·옵션

```elixir
defmodule MyApp.Schema do
  @external_resource "priv/schema.json"    # 이 파일이 바뀌면 재컴파일 힌트
  @enforce_keys [:id, :name]               # 구조체 필수 키 강제
  defstruct [:id, :name, meta: %{}]

  @derive {Jason.Encoder, only: [:id, :name]}
  @compile {:inline, id: 1}                # 단순 위임 인라이닝 힌트(선택)
  @behaviour Access                        # 콜백 기대 명시(옵션)
end
```

- `@external_resource`: 외부 파일 의존성 표시.
- `@enforce_keys`: `%__MODULE__{}` 생성 시 필수 필드 강제.
- `@derive`: 프로토콜 구현 자동 파생.
- `@compile`: 컴파일러 최적화 옵션.
- `@behaviour`: 콜백 집합 준수 선언.

#### @external_resource

```elixir
defmodule MyApp.Template do
  @external_resource "priv/email_welcome.txt"
  @template File.read!("priv/email_welcome.txt")

  def render(name) do
    String.replace(@template, "{{name}}", name)
  end
end
```

- 템플릿 파일이 바뀌면 빌드 시스템이
  이 모듈을 **다시 컴파일해야 한다**는 힌트를 제공
- `File.read!`는 컴파일 시에 한 번 실행되어 `@template` 상수에 들어간다.

#### @enforce_keys

```elixir
defmodule MyApp.User do
  @enforce_keys [:id, :email]
  defstruct [:id, :email, :name]
end

# 정상

%MyApp.User{id: 1, email: "a@a"}

# 런타임 예외 발생 (필수 키 누락)

%MyApp.User{name: "no id"}
```

- 구조체의 **필수 필드**를 강제하여
  “부분만 채워진 구조체”가 돌아다니는 것을 방지한다.

#### @derive

```elixir
defmodule MyApp.User do
  @derive {Jason.Encoder, only: [:id, :email]}
  defstruct [:id, :email, :password_hash]
end
```

- `Jason.Encoder` 프로토콜 구현을 자동으로 파생
- 민감 정보(`:password_hash`)는 직렬화에서 제외

---

### 컴파일 타임 상수·누적 버퍼

```elixir
defmodule MyApp.Const do
  @version "1.2.3"
  def version, do: @version
end

defmodule MyApp.Router do
  @routes []
  @routes [{"GET", "/health", :health}]
  @routes [{"POST", "/login",  :login} | @routes]
  def routes, do: Enum.reverse(@routes)
end
```

- 속성은 **컴파일 시 평가**되며, 단순 상수/누적 버퍼로 쓰기 좋다.
- 동적 환경값은 **런타임**에 `Application.fetch_env!/2` 등으로 읽어라(속성에 굳히지 말 것).

#### 환경값을 속성에 굳히면 안 되는 이유

나쁜 예:

```elixir
defmodule MyApp.BadConfig do
  @port Application.fetch_env!(:my_app, :port)
  def port, do: @port
end
```

- 컴파일 시점에 읽힌 포트 값이 **코드에 박혀 버린다.**
- 런타임에 환경 변수를 바꿔도 **이미 컴파일된 릴리스**에는 반영되지 않는다.

좋은 예:

```elixir
defmodule MyApp.Config do
  def port do
    Application.fetch_env!(:my_app, :port)
  end
end
```

- 매 호출마다 설정을 읽으므로, 런타임에서 변경 가능한 설정에 적합하다.

---

### `@impl`로 콜백 구현 의도 명시

```elixir
defmodule MyApp.Worker do
  use GenServer

  @impl true
  def init(arg), do: {:ok, arg}
end
```

- behaviour에서 기대하는 콜백을 구현할 때 `@impl true` 를 붙이면
  오타/서명 불일치 시 컴파일러가 경고를 내준다.

예:

```elixir
defmodule MyApp.BadWorker do
  use GenServer

  @impl true
  def init(), do: {:ok, :no_arg}   # GenServer.init/1과 서명 불일치
end
```

- 이런 경우 컴파일러가 “콜백과 서명이 다르다”는 경고를 준다.

---

### 모듈 속성 안티패턴

1. **동적 설정을 속성에 캐싱**

   - 이미 살펴본 것처럼 환경/설정 값은 속성보다는
     `Application.fetch_env!/2` 로 읽는 것이 바람직하다.

2. **큰 데이터를 속성에 넣기**

   ```elixir
   @huge_map File.read!("big.json") |> Jason.decode!()
   ```

   - 컴파일 시간이 늘어나고, .beam 파일 크기도 커진다.
   - 필요한 시점에 `File.read!/1` 을 하는 편이 나을 때가 많다.

3. **모든 상수를 속성으로 만드는 경우**

   - `PI = 3.14` 처럼 간단한 상수는 `def pi, do: 3.14` 로 함수로 두어도 충분하다.
   - 속성은 정말 **컴파일 시점에만 필요하거나 누적 패턴이 필요할 때** 사용하는 것이 깔끔하다.

---

## 모듈의 이름: 엘릭서, 얼랭, 아톰

핵심 규칙:

1. **엘릭서 모듈 이름은 사실 아톰(atom)** 이다. 내부 표현은 항상 **`:"Elixir.Mod.Name"`** 형식.
2. **얼랭 모듈**은 **소문자 아톰**(예: `:lists`, `:ets`, `:gen_tcp`).
3. 아톰 리터럴 표기: `:atom`, 또는 따옴표로 묶은 `:"weird atom"`.

### 이름 매핑 관찰

```elixir
iex> is_atom(MyApp.Math)
true
iex> to_string(MyApp.Math)
"Elixir.MyApp.Math"
iex> :"Elixir.MyApp.Math" == MyApp.Math
true

iex> :lists  # 얼랭 모듈은 소문자 아톰
:lists
```

- **엘릭서 모듈**과 **얼랭 모듈** 모두 **아톰**이지만,
  네이밍 컨벤션과 내부 prefix만 다르다.

#### 아톰과 메모리

- 아톰은 **VM이 종료될 때까지 GC 되지 않는다.**
- 너무 많은 아톰(특히 동적으로 생성된 아톰)을 만들면
  **아톰 테이블이 꽉 차서 VM이 죽을 수 있다.**

안전한 패턴:

- 입력값(HTTP 헤더, JSON 필드 이름 등)을 문자열로 처리하고,
  아톰으로 변환할 필요가 있을 때만
  `String.to_existing_atom/1` 을 사용해
  **이미 존재하는 아톰만 허용**한다.

```elixir
case String.to_existing_atom(key_string) do
  key -> handle_known_key(key)
rescue
  ArgumentError -> {:error, :unknown_key}
end
```

---

### 특이한 이름/동적 합성

```elixir
iex> weird = :"Elixir.MyApp.Foo-Bar"    # 특수문자 포함 아톰도 가능(권장X)
:"Elixir.MyApp.Foo-Bar"

iex> Module.concat("Elixir.MyApp", "Users")
MyApp.Users
```

- 특수문자 아톰은 **필요할 때만**.
  팀 코드에서는 관례(알파벳/숫자, 점으로 네임스페이스)를 지키는 편이 안전하다.

동적 합성의 일반적인 패턴:

```elixir
defmodule MyApp.Versioned do
  def module_for(version) when is_integer(version) do
    Module.concat([MyApp.API, "V#{version}"])
  end
end
```

---

## 얼랭 라이브러리의 함수 호출하기 (Erlang Interop)

엘릭서는 **BEAM 위 언어**이므로 **얼랭 표준 라이브러리/OTP**를 그대로 호출할 수 있다.
핵심 차이: **문자열=바이너리(binary)**, **차리스트(charlist)=[integer]**.

### 대표 모듈 예시

```elixir
# lists

iex> :lists.map(fn x -> x * 2 end, [1,2,3])
[2,4,6]

# maps

iex> :maps.get(:a, %{a: 1})
1

# binary

iex> :binary.part("abcdef", 2, 3)
"cde"

# os / timer

iex> :os.type()
{:win32, :nt} # 예시
iex> :timer.sleep(10)
:ok
```

- 얼랭 함수는 **:`module`.function(args)** 로 호출한다.

#### 엘릭서 래퍼 모듈 만들기

얼랭 API는 종종 “끼리끼리” 쓰기가 어렵기 때문에, 엘릭서 스타일의 래퍼를 많이 만든다.

```elixir
defmodule MyApp.Time do
  def now_millis do
    System.system_time(:millisecond)
  end

  def sleep(ms) when is_integer(ms) and ms >= 0 do
    :timer.sleep(ms)
  end
end
```

- 내부에서 얼랭 모듈을 쓰되,
  외부 인터페이스는 엘릭서 스타일로 맞춘다.

---

### 문자열 vs 차리스트

얼랭 I/O 계열은 종종 **차리스트(charlist)** 를 기대한다.

```elixir
iex> :io.format("Num=~p~n", [123])             # 차리스트 포맷 문자열
:ok
iex> :io.format(~c"Str=~s~n", [~c"hello"])     # ~c 시그릴: 차리스트 리터럴
:ok

iex> to_charlist("한글")
[54620,44544]
iex> to_string([104,101,108,108,111])
"hello"
```

- 엘릭서에서 `"문자열"`은 바이너리이고,
  `~c"문자열"`은 차리스트다.
- 얼랭 함수가 차리스트를 기대하면 `to_charlist/1` 로 변환한다.

---

### 사용

```elixir
defmodule MyApp.Cache do
  def start_link do
    tid = :ets.new(:cache, [:set, :public, read_concurrency: true])
    {:ok, tid}
  end

  def put(key, value) do
    :ets.insert(:cache, {key, value})
    :ok
  end

  def get(key) do
    case :ets.lookup(:cache, key) do
      [{^key, value}] -> {:ok, value}
      []              -> :not_found
    end
  end
end
```

- ETS는 **공유·가변** 상태를 관리할 수 있는
  매우 빠른 인메모리 테이블이다.
- 주의: **트랜잭션/롤백** 개념은 없다.

실무 패턴:

- **읽기 횟수가 매우 많은** 데이터(캐시, 룩업 테이블 등)에 적합
- `:public`, `read_concurrency: true` 옵션으로
  멀티 코어에서 읽기 병렬성을 높일 수 있다.

---

### 파일/소켓(간단 스케치)

```elixir
# 파일

{:ok, f} = :file.open('sample.txt', [:write])  # 차리스트 경로
:ok = :file.write(f, 'hello\n')
:ok = :file.close(f)

# TCP 클라이언트(간략)

{:ok, sock} = :gen_tcp.connect('example.com', 80, [:binary, active: false])
:ok = :gen_tcp.send(sock, "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")
{:ok, bin} = :gen_tcp.recv(sock, 0, 5000)
:gen_tcp.close(sock)
```

- 얼랭의 파일/소켓 API는 강력하지만, 사용 시
  차리스트/바이너리 구분에 항상 신경 써야 한다.
- 소켓은 옵션(`:binary`, `active: false`)에 따라
  메시지가 프로세스 메일박스로 들어오는 방식이 달라진다.

---

### 암호·해시

```elixir
iex> :crypto.hash(:sha256, "abc") |> Base.encode16(case: :lower)
"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
```

- 해시/암호화는 대부분 `:crypto` 모듈이 제공한다.
- Mix 프로젝트에서는 `extra_applications: [:logger, :crypto]` 를
  `mix.exs` 의 `application/0`에서 명시하는 습관이 안전하다.

---

## 라이브러리 찾기 (Code Path · Mix/Hex · priv · 런타임 탐색)

라이브러리를 “찾는다”는 것은 크게 다음 세 층으로 나뉜다.

1. **코드 경로에 모듈이 로드/상주하는가**
2. **Mix/Hex 의존성으로 프로젝트에 포함되어 있는가**
3. **리소스(파일/데이터)를 어디서 찾는가**

### 코드 경로 살펴보기

```elixir
iex> :code.get_path() |> Enum.take(3)
['/usr/lib/erlang/lib/kernel-.../ebin', ...]
iex> :code.which(:lists)
'/usr/lib/erlang/lib/stdlib-.../ebin/lists.beam'
iex> Code.ensure_loaded?(MyApp.Math)
true
iex> function_exported?(MyApp.Math, :add, 2)
true
```

- **`:code.which/1`** 로 특정 모듈의 **.beam 위치**를 확인한다.
- `Code.ensure_loaded?/1` / `Code.ensure_compiled?/1` 로 **가용성**을 점검.
- `function_exported?/3` 로 특정 함수가 있는지 확인 가능.

#### 코드 경로에 .beam 추가하기

```elixir
Code.append_path("/tmp/custom_ebin")

# 이후 /tmp/custom_ebin 내의 모듈을 사용할 수 있다.

```

- 커스텀 빌드/툴링에서 동적으로 컴파일된 .beam을
  추가로 로드할 때 사용한다.

---

### Mix/Hex 의존성 추가·검색

`mix.exs`:

```elixir
defp deps do
  [
    {:jason, "~> 1.4"},
    {:finch, "~> 0.18"}  # HTTP 클라이언트 예
  ]
end
```

명령:

```bash
mix deps.get
mix deps.compile
mix hex.search jason
```

- **Hex**는 엘릭서 패키지 레지스트리.
- 의존성 추가 후 `mix compile`, `iex -S mix`에서 바로 사용 가능.

#### 의존성 분류

간단히 분류하면:

- **런타임 의존성**: 실제 코드에서 사용하는 라이브러리 (예: `jason`, `finch`)
- **테스트/개발 의존성**: `only: :test`, `only: :dev` 옵션으로 제한
  (예: 테스트용 라이브러리, 코드 포맷터 등)

```elixir
{:ex_doc, "~> 0.30", only: :dev, runtime: false}
```

- 문서 생성용 도구처럼 런타임에 필요 없는 의존성은
  `runtime: false` 로 표시해 릴리스 크기를 줄일 수 있다.

---

### 런타임 환경/설정 탐색

```elixir
# mix.exs

def application do
  [
    extra_applications: [:logger],
    mod: {MyApp, []}
  ]
end

# config/config.exs

import Config
config :my_app, endpoint: [port: 4000]

# 런타임 접근

port = Application.fetch_env!(:my_app, :endpoint)[:port]
```

- 애플리케이션 이름(`:my_app`)은 보통 Mix 프로젝트 이름에서 온다.
- `Application.get_env/3` / `fetch_env!/2` 로 앱 설정을 읽는다.

---

### 찾기

```elixir
# 디렉터리: priv/geo/cities.csv

path = :code.priv_dir(:my_app) |> Path.join("geo/cities.csv")
{:ok, bin} = File.read(path)
```

- `:code.priv_dir(app_atom)` 은 **릴리즈/개발** 모두에서 안전하게 동작한다.
- 직접 상대 경로(`"priv/..."`)를 쓰면, 릴리스 시 디렉터리 구조가 바뀔 수 있어 깨지기 쉽다.

---

### IEx에서 문서/타입/소스 탐색

```elixir
iex> h Enum.map/2           # 문서
iex> t Enum                 # 타입 정보(스펙)
iex> i "abc"                # 타입/프로토콜 구현 등
```

- `h/1`: 모듈/함수/매크로 문서를 보여준다.
- `t/1`: 타입/스펙을 요약해서 보여준다.
- `i/1`: 값의 타입, 프로토콜 구현, 구조 등 자세한 정보를 보여준다.

실전 예:

```elixir
iex> h MyApp.Accounts.signup/1
# signup/1의 사용법과 예제 확인

iex> t MyApp.Accounts
# 모듈의 타입 정의 살펴보기

```

---

### 동적 확인·폴백

```elixir
mod =
  cond do
    Code.ensure_loaded?(Finch) -> Finch
    Code.ensure_loaded?(:hackney) -> MyApp.HTTP.HackneyWrapper
    true -> MyApp.HTTP.Fallback
  end

apply(mod, :get, ["https://example.com"])
```

- **기능 감지(feature detection)** 로 선택적으로 외부 라이브러리를 사용
- 릴리스 환경에 따라 Finch, hackney, Fallback 중 하나를 선택하는 패턴

---

### 라이브러리 검색 순서 요약

코드 경로·앱·hex 의존성을 추상화해서 보면, 대략 다음의 합으로 라이브러리를 찾는다:

$$
\text{available\_modules} \approx
\text{OTP\_lib} \cup
\text{Mix\_deps} \cup
\text{Project\_ebin} \cup
\text{Paths\_added}
$$

- **`OTP_lib`**: 얼랭/엘릭서 런타임이 기본 제공하는 라이브러리
- **`Mix_deps`**: `mix.exs` 의 `deps` 로 추가된 의존성
- **`Project_ebin`**: `mix compile` 결과물(.beam)
- **`Paths_added`**: `Code.append_path/1` 등으로 수동 추가한 경로

---

## 실전 스니펫 모음

아래 스니펫들은 6.8~6.12에서 설명한 개념들을 묶어 보여준다.

### 엘릭서↔얼랭 혼합 라우팅

```elixir
defmodule Interop.Router do
  def normalize_host(host) when is_binary(host),
    do: host |> String.trim() |> String.downcase()

  def dns_query(host) do
    # :inet_res.gethostbyname/1은 차리스트를 사용
    case :inet_res.gethostbyname(to_charlist(host)) do
      {:ok, {:hostent, _h, _aliases, _type, _len, addrs}} -> {:ok, addrs}
      {:error, r} -> {:error, r}
    end
  end
end
```

### 컴파일 타임 상수·누적 속성으로 라우트 테이블

```elixir
defmodule Mini.Router do
  @routes []
  @routes [{"GET", "/health", :health}]
  @routes [{"POST", "/echo", :echo} | @routes]

  def routes, do: Enum.reverse(@routes)
end
```

### priv 파일 읽어 구조체로 적재

```elixir
defmodule Geo.Cities do
  @enforce_keys [:name, :lat, :lon]
  defstruct [:name, :lat, :lon]

  def load() do
    :code.priv_dir(:my_app)
    |> Path.join("geo/cities.csv")
    |> File.stream!()
    |> Stream.drop(1)
    |> Stream.map(&String.trim_trailing/1)
    |> Stream.reject(&(&1 == ""))
    |> Stream.map(&String.split(&1, ","))
    |> Enum.map(fn [name, lat, lon] ->
      %__MODULE__{
        name: name,
        lat: String.to_float(lat),
        lon: String.to_float(lon)
      }
    end)
  end
end
```

### 라이브러리 가용성에 따른 분기

```elixir
defmodule MyApp.JSON do
  @moduledoc """
  런타임에 사용 가능한 JSON 인코더를 선택한다.
  """

  def encode!(term) do
    cond do
      Code.ensure_loaded?(Jason) ->
        Jason.encode!(term)

      Code.ensure_loaded?(:jsx) ->
        :jsx.encode(term) |> IO.iodata_to_binary()

      true ->
        raise "no JSON encoder found"
    end
  end
end
```

---

## 체크리스트 (6.8~6.12)

- [ ] 모듈은 **얇은 공개 API + 내부 세분화**로 구성했는가
- [ ] `alias/import/require/use` 를 **의도에 맞게** 사용했는가
- [ ] 모듈 속성은 **문서/스펙/지시자/상수/누적** 용도에 맞게 썼는가
- [ ] 동적 환경값을 **속성에 굳히지 않았는가** (`Application.get_env/3`로 처리)
- [ ] 엘릭서 모듈과 얼랭 모듈(소문자 아톰)을 **명확히 구분**하고 있는가
- [ ] 얼랭 라이브러리 호출 시 **문자열/차리스트 차이**를 처리했는가
- [ ] ETS/파일/소켓 등 얼랭 API를 사용할 때, 엘릭서 래퍼로 감싸 **도메인 친화적 인터페이스**를 제공하는가
- [ ] 라이브러리/리소스는 `:code.which/1`, `:code.priv_dir/1`, `Application.fetch_env!/2` 등으로 **안전하게 탐색**했는가
- [ ] IEx의 `h/t/i` 를 적극 활용해 **문서/타입**을 탐색하고 있는가
- [ ] Hex 의존성은 `mix.exs` 에 **명시**, `mix deps.get/compile` 로 관리하고 있는가
- [ ] 필요한 경우 `Code.ensure_loaded?/1`, `function_exported?/3` 로 **동적 확인/폴백**을 구현했는가

---

## 마무리

- **모듈(6.8)**
  - 모듈 이름은 네임스페이스이자 설계 개념이다.
  - `alias/import/require/use` 를 명확한 의도로 사용하면,
    코드 구조와 의존성이 눈에 잘 들어온다.
  - 얇은 컨텍스트 모듈 + 내부 세부 구현 모듈 패턴은
    테스트성과 유지보수성을 크게 높인다.

- **모듈 속성(6.9)**
  - 문서/타입/지시자/상수/누적에 맞게 사용하면
    코드와 메타데이터를 한곳에서 관리할 수 있다.
  - 동적 환경값을 속성에 굳히지 않고,
    런타임 설정은 `Application.*` 계열로 처리하는 것이 핵심이다.

- **모듈 이름과 아톰(6.10)**
  - 엘릭서 모듈은 내부적으로 `:"Elixir.Mod.Name"` 아톰이며,
    얼랭 모듈은 소문자 아톰이다.
  - 이 구조를 이해하면 동적 모듈 합성, 플러그인 구조,
    얼랭/엘릭서 상호운용을 훨씬 자연스럽게 설계할 수 있다.

- **얼랭 라이브러리 호출(6.11)**
  - ETS, 파일, 소켓, 암호화 등 강력한 기능을 그대로 활용할 수 있다.
  - 문자열/차리스트 차이만 주의하면,
    엘릭서 앱에서도 얼랭 OTP 인프라를 자연스럽게 사용할 수 있다.

- **라이브러리 찾기(6.12)**
  - 코드 경로, Mix/Hex 의존성, priv 리소스, 앱 설정, IEx 탐색 도구를
    함께 이해하면 “이 기능이 어디서 오는지, 어디서 설정되는지”
    빠르게 추적할 수 있다.
  - 이는 개발뿐 아니라 배포/운영 단계에서 문제를 빠르게 찾는 데도 중요하다.

전체적으로, 이 장은 “**코드를 어떻게 조직하고, 외부 세계와 어떻게 연결할 것인가**”에 대한 이야기다.
함수/패턴/가드만 잘 다뤄도 작은 프로그램은 만들 수 있지만,
실제 서비스 규모에서는 **모듈·속성·라이브러리 구조**를 제대로 잡아야
장기적으로 견디는 시스템을 만들 수 있다.
