---
layout: post
title: 영상처리 - 캐니 엣지 검출기
date: 2025-09-29 20:25:23 +0900
category: 영상처리
---
# 캐니 엣지 검출기

## 캐니 엣지 검출 방법(이론 요약)

캐니의 목표: **얇고 연속적인 엣지**, **정확한 위치**, **노이즈 강건성**.

### 처리 파이프라인

1) **노이즈 억제**: 가우시안 필터 \((\sigma)\)
2) **그래디언트**: \(G_x, G_y\) → 크기/방향
   \[
   M=\begin{cases}
   \sqrt{G_x^2 + G_y^2} & (\text{L2})\\
   |G_x| + |G_y| & (\text{L1})
   \end{cases},
   \quad
   \theta=\mathrm{atan2}(G_y,G_x)
   \]
3) **NMS(비최대 억제)**: \(\theta\) 방향으로 이웃 2픽셀과 비교해 **로컬 최대**만 남김
4) **이중 임계(Double thresholds)**:
   - High(강 엣지) \(\ge T_H\)
   - Low(약 엣지) \(T_L \le \cdot < T_H\)
5) **히스테리시스(연결성 추적)**: **강 엣지**에 **연결된 약 엣지**만 살림(8-이웃)

### 방향 양자화(Quantization)

NMS 효율을 위해 \(\theta\) 를 **4방향(0°, 45°, 90°, 135°)** 로 양자화:
- 0°: 좌↔우
- 45°: 좌하↔우상
- 90°: 상↔하
- 135°: 좌상↔우하

이웃 비교는 **해당 방향의 2픽셀**과 수행.

---

## Canny 구현 설계

- **스무딩**: 1D 가우시안 **분리 합성**(separable) \(\Rightarrow\) 빠르고 정확.
- **그래디언트**: 흔히 **Sobel**(3×3)로 충분. (DoG(가우시안 미분)로 합칠 수도 있음)
- **크기 정규화**: NMS 결과를 **0..255** 로 선형 스케일링 후 임계 적용(사용자 TH/ TL은 0..255 기준).
- **히스테리시스**: 재귀 대신 **큐(BFS)** 로 오버플로 방지.
- **경계 처리**: 기본 **Replicate**(모서리 값 복제), 옵션으로 0패딩.
- **디버그/교육**: **Magnitude / NMS / Edges(최종)** 3종 출력 모드 제공.

---

## 코드 — 캐니 엣지 코어

```cpp
// Canny.hpp
#pragma once
#include <vector>
#include <cmath>
#include <cstdint>
#include <algorithm>
#include <queue>
#include "IppDib.h"

enum class CannyOut { Edges, Magnitude, NMS };

struct CannyOptions {
    double sigma = 1.2;       // 가우시안 표준편차
    int    ksize = 0;         // 홀수(>1). 0이면 자동(ksize = 2*ceil(3*sigma)+1)
    int    low   = 50;        // 이중 임계(0..255)
    int    high  = 120;       //   "
    bool   L2    = true;      // true: sqrt(Gx^2+Gy^2), false: |Gx|+|Gy|
    bool   replicateBorder = true;
    CannyOut out = CannyOut::Edges;
};

// ------------------------- 공통 유틸 -------------------------
inline void DibToGrayF32(const IppDib& src, std::vector<float>& Y, int& W, int& H){
    if (!src){ W=H=0; Y.clear(); return; }
    W=src.width(); H=src.height();
    Y.resize((size_t)W*H);
    for (int y=0;y<H;++y){
        const uint8_t* s=(const uint8_t*)src.bits() + (size_t)y*src.stride();
        for (int x=0;x<W;++x){
            int B=s[x*4+0], G=s[x*4+1], R=s[x*4+2];
            Y[(size_t)y*W+x] = 0.114f*B + 0.587f*G + 0.299f*R;
        }
    }
}
inline int clampi(int v, int lo, int hi){ return (v<lo)?lo:((v>hi)?hi:v); }
inline float sampleF(const std::vector<float>& A, int W,int H,int x,int y, bool repl){
    if (repl){ x=clampi(x,0,W-1); y=clampi(y,0,H-1); return A[(size_t)y*W+x]; }
    if ((unsigned)x>=(unsigned)W || (unsigned)y>=(unsigned)H) return 0.f;
    return A[(size_t)y*W+x];
}
static inline uint8_t toU8(double v){
    if (v<0) v=0; else if (v>255) v=255;
    return (uint8_t)std::lround(v);
}

// ------------------------- 가우시안(분리) -------------------------
inline std::vector<float> gaussianKernel1D(double sigma, int& radius){
    if (sigma <= 0) { radius = 0; return {1.f}; }
    radius = (int)std::ceil(3.0 * sigma);
    int ksize = 2*radius + 1;
    std::vector<float> k(ksize);
    double sum=0.0, s2=2.0*sigma*sigma;
    for (int i=-radius;i<=radius;++i){
        double v = std::exp(-(i*i)/s2);
        k[i+radius] = (float)v; sum += v;
    }
    for (auto& v:k) v = (float)(v/sum);
    return k;
}
inline void convolveSeparable(const std::vector<float>& src, int W,int H,
                              const std::vector<float>& k, int radius,
                              std::vector<float>& dst, bool repl)
{
    dst.assign((size_t)W*H, 0.f);
    std::vector<float> tmp((size_t)W*H, 0.f);

    // X방향
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            double acc=0.0;
            for (int i=-radius;i<=radius;++i){
                float p = sampleF(src,W,H, x+i,y, repl);
                acc += (double)p * k[i+radius];
            }
            tmp[(size_t)y*W+x] = (float)acc;
        }
    }
    // Y방향
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            double acc=0.0;
            for (int j=-radius;j<=radius;++j){
                float p = sampleF(tmp,W,H, x,y+j, repl);
                acc += (double)p * k[j+radius];
            }
            dst[(size_t)y*W+x] = (float)acc;
        }
    }
}

// ------------------------- Sobel 그래디언트 -------------------------
inline void sobelGrad(const std::vector<float>& S, int W,int H,
                      std::vector<float>& Gx, std::vector<float>& Gy, bool repl)
{
    Gx.assign((size_t)W*H,0.f); Gy.assign((size_t)W*H,0.f);
    // Sobel 3x3
    // Gx = [-1 0 1; -2 0 2; -1 0 1], Gy = Gx^T
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            float p00=sampleF(S,W,H,x-1,y-1,repl), p10=sampleF(S,W,H,x,y-1,repl), p20=sampleF(S,W,H,x+1,y-1,repl);
            float p01=sampleF(S,W,H,x-1,y  ,repl), p11=sampleF(S,W,H,x,y  ,repl), p21=sampleF(S,W,H,x+1,y  ,repl);
            float p02=sampleF(S,W,H,x-1,y+1,repl), p12=sampleF(S,W,H,x,y+1,repl), p22=sampleF(S,W,H,x+1,y+1,repl);

            float gx = (-p00 + p20) + (-2.f*p01 + 2.f*p21) + (-p02 + p22);
            float gy = (-p00 - 2.f*p10 - p20) + (p02 + 2.f*p12 + p22);
            Gx[(size_t)y*W+x]=gx; Gy[(size_t)y*W+x]=gy;
        }
    }
}

// ------------------------- 방향 양자화(0,45,90,135) -------------------------
inline uint8_t quantizeDir(float gx, float gy){
    // atan2 없이 근사: |gy/gx| vs tan(22.5°)=0.4142, tan(67.5°)=2.4142
    float agx = std::fabs(gx), agy = std::fabs(gy);
    if (agx > agy){
        float r = agy / (agx + 1e-6f);
        if (r < 0.4142f) return 0;    // 0°
        else             return 1;    // 45°
    } else {
        float r = agx / (agy + 1e-6f);
        if (r < 0.4142f) return 2;    // 90°
        else             return 3;    // 135°
    }
}

// ------------------------- NMS (비최대 억제) -------------------------
inline void nonMaxSuppression(const std::vector<float>& Gx, const std::vector<float>& Gy,
                              int W,int H, bool L2,
                              std::vector<float>& Mthin)
{
    Mthin.assign((size_t)W*H, 0.f);
    auto mag = [&](float gx,float gy)->float{
        return L2 ? std::sqrt(gx*gx+gy*gy) : (std::fabs(gx)+std::fabs(gy));
    };

    for (int y=1;y<H-1;++y){
        for (int x=1;x<W-1;++x){
            float gx=Gx[(size_t)y*W+x], gy=Gy[(size_t)y*W+x];
            float m0 = mag(gx,gy);
            if (m0<=0.f){ Mthin[(size_t)y*W+x]=0.f; continue; }

            uint8_t dir = quantizeDir(gx,gy);
            float m1=0.f, m2=0.f; // 이웃 두 점의 크기
            switch(dir){
                case 0: // 0°: 좌/우
                    m1 = mag(Gx[(size_t)y*W + (x-1)], Gy[(size_t)y*W + (x-1)]);
                    m2 = mag(Gx[(size_t)y*W + (x+1)], Gy[(size_t)y*W + (x+1)]);
                    break;
                case 1: // 45°: 좌하/우상
                    m1 = mag(Gx[(size_t)(y+1)*W + (x-1)], Gy[(size_t)(y+1)*W + (x-1)]);
                    m2 = mag(Gx[(size_t)(y-1)*W + (x+1)], Gy[(size_t)(y-1)*W + (x+1)]);
                    break;
                case 2: // 90°: 상/하
                    m1 = mag(Gx[(size_t)(y-1)*W + x], Gy[(size_t)(y-1)*W + x]);
                    m2 = mag(Gx[(size_t)(y+1)*W + x], Gy[(size_t)(y+1)*W + x]);
                    break;
                case 3: // 135°: 좌상/우하
                    m1 = mag(Gx[(size_t)(y-1)*W + (x-1)], Gy[(size_t)(y-1)*W + (x-1)]);
                    m2 = mag(Gx[(size_t)(y+1)*W + (x+1)], Gy[(size_t)(y+1)*W + (x+1)]);
                    break;
            }
            Mthin[(size_t)y*W+x] = (m0 >= m1 && m0 >= m2) ? m0 : 0.f;
        }
    }
    // 가장자리: 단순 0(간단화). 필요하면 복제로 이웃 비교 구현 가능.
}

// ------------------------- 히스테리시스 -------------------------
inline void hysteresis(const std::vector<float>& Mthin, int W,int H,
                       int Tlow, int Thigh, std::vector<uint8_t>& edges)
{
    edges.assign((size_t)W*H, 0);
    std::deque<int> q;

    auto idx=[&](int x,int y){ return (int)((size_t)y*W+x); };

    // 1) strong seed
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            int v = (int)std::lround(Mthin[(size_t)y*W+x]);
            if (v >= Thigh){
                edges[(size_t)idx(x,y)] = 255;
                q.push_back(idx(x,y));
            }
        }
    }
    // 2) BFS: strong과 연결된 weak(>=Tlow)를 살림
    const int dx[8]={-1,0,1,-1,1,-1,0,1};
    const int dy[8]={-1,-1,-1,0,0,1,1,1};
    while(!q.empty()){
        int p=q.front(); q.pop_front();
        int x = p % W, y = p / W;
        for (int k=0;k<8;++k){
            int nx=x+dx[k], ny=y+dy[k];
            if ((unsigned)nx>=(unsigned)W || (unsigned)ny>=(unsigned)H) continue;
            int j = idx(nx,ny);
            if (edges[(size_t)j]==255) continue; // 이미 strong으로 방문
            int v = (int)std::lround(Mthin[(size_t)j]);
            if (v>=Tlow){
                edges[(size_t)j]=255;
                q.push_back(j);
            }
        }
    }
    // 그 외는 0(배경)
}

// ------------------------- 최종 API -------------------------
inline bool CannyEdge(const IppDib& src, IppDib& dst, const CannyOptions& opt)
{
    if (!src) { dst=src; return false; }
    int W,H; std::vector<float> Y; DibToGrayF32(src, Y, W, H);

    // 1) 가우시안
    int radius, K = opt.ksize;
    if (K<=1){
        auto k = gaussianKernel1D(opt.sigma, radius);
        std::vector<float> S; convolveSeparable(Y,W,H, k, radius, S, opt.replicateBorder);
        Y.swap(S);
    } else {
        // 사용자가 ksize를 직접 준 경우: sigma가 0일 수도 있으므로 ksize 기반으로 재생성
        if (!(K&1)) K++; // 홀수 보정
        radius = K/2;
        // sigma 재계산(선택) 대신 "정규화된 가우시안 근사"를 ksize와 sigma로 생성
        auto k = gaussianKernel1D(opt.sigma>0?opt.sigma:std::max(0.6, (K-1)/6.0), radius);
        std::vector<float> S; convolveSeparable(Y,W,H, k, radius, S, opt.replicateBorder);
        Y.swap(S);
    }

    // 2) 그래디언트
    std::vector<float> Gx, Gy; sobelGrad(Y, W,H, Gx,Gy, opt.replicateBorder);

    // 3) NMS
    std::vector<float> Mthin; nonMaxSuppression(Gx,Gy, W,H, opt.L2, Mthin);

    // 4) 스케일(0..255) → 임계
    double mmax=0.0;
    for (float v : Mthin) if (v>mmax) mmax=v;
    double scale = (mmax>1e-6)? (255.0/mmax) : 1.0;

    // 디버그 출력 모드
    if (opt.out == CannyOut::Magnitude){
        // NMS 전 magnitude를 보고 싶다면 여기에 M = sqrt(gx^2+gy^2) 생성 가능.
        // 여기서는 NMS 결과를 스케일하여 '얇은 엣지 강도 맵'을 제공.
        IppDib out; out.create(W,H,32);
        for (int y=0;y<H;++y){
            uint8_t* d=(uint8_t*)out.bits()+(size_t)y*out.stride();
            for (int x=0;x<W;++x){
                uint8_t g = toU8(Mthin[(size_t)y*W+x] * scale);
                d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
            }
        }
        dst = out; return true;
    }
    if (opt.out == CannyOut::NMS){
        IppDib out; out.create(W,H,32);
        for (int y=0;y<H;++y){
            uint8_t* d=(uint8_t*)out.bits()+(size_t)y*out.stride();
            for (int x=0;x<W;++x){
                uint8_t g = toU8(Mthin[(size_t)y*W+x] * scale);
                d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
            }
        }
        dst = out; return true;
    }

    // 5) 히스테리시스(Edges)
    std::vector<float> M8((size_t)W*H);
    for (size_t i=0;i<M8.size();++i) M8[i] = (float)(Mthin[i]*scale);
    std::vector<uint8_t> E; hysteresis(M8, W,H, opt.low, opt.high, E);

    IppDib out; out.create(W,H,32);
    for (int y=0;y<H;++y){
        uint8_t* d=(uint8_t*)out.bits()+(size_t)y*out.stride();
        for (int x=0;x<W;++x){
            uint8_t g = E[(size_t)y*W+x];
            d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
        }
    }
    dst = out; return true;
}
```

---

## UI — **캐니 엣지 검출 대화 상자**

### 리소스 ID

```cpp
// resource.h (추가)
#define IDD_CANNY_DLG                3500
#define IDC_EDIT_CANNY_SIGMA         3501
#define IDC_EDIT_CANNY_KSIZE         3502
#define IDC_EDIT_CANNY_LOW           3503
#define IDC_EDIT_CANNY_HIGH          3504
#define IDC_CHK_CANNY_L2             3505
#define IDC_CHK_CANNY_REPL           3506
#define IDC_RAD_CANNY_OUT_EDGES      3507
#define IDC_RAD_CANNY_OUT_MAG        3508
#define IDC_RAD_CANNY_OUT_NMS        3509

// 메뉴
#define ID_MENU_CANNY                74000

```

### RC(대화 상자 & 메뉴/가속키)

```rc
// ImageTool.rc (추가)
IDD_CANNY_DLG DIALOGEX 0,0, 240, 156
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Canny Edge Detector"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Sigma:", -1, 14, 16, 40, 10
    EDITTEXT IDC_EDIT_CANNY_SIGMA, 60, 14, 36, 14, ES_AUTOHSCROLL
    LTEXT "Kernel:", -1, 104, 16, 36, 10
    EDITTEXT IDC_EDIT_CANNY_KSIZE, 146, 14, 26, 14, ES_NUMBER
    LTEXT "(odd, 0=auto)", -1, 176, 16, 58, 10

    LTEXT "Low T:", -1, 14, 36, 40, 10
    EDITTEXT IDC_EDIT_CANNY_LOW, 60, 34, 36, 14, ES_NUMBER
    LTEXT "High T:", -1, 104, 36, 40, 10
    EDITTEXT IDC_EDIT_CANNY_HIGH, 146, 34, 36, 14, ES_NUMBER

    AUTOCHECKBOX "L2 magnitude (sqrt)", IDC_CHK_CANNY_L2, 14, 58, 110, 12
    AUTOCHECKBOX "Replicate border",    IDC_CHK_CANNY_REPL, 128, 58, 100, 12

    GROUPBOX "Output", -1, 14, 74, 220, 38
    AUTORADIOBUTTON "Edges",     IDC_RAD_CANNY_OUT_EDGES, 24, 86, 48, 10, WS_TABSTOP
    AUTORADIOBUTTON "Magnitude", IDC_RAD_CANNY_OUT_MAG,   84, 86, 60, 10
    AUTORADIOBUTTON "NMS",       IDC_RAD_CANNY_OUT_NMS,  156, 86, 40, 10

    DEFPUSHBUTTON "OK", IDOK,  120, 124, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 170, 124, 44, 16
END

// 메뉴 & 가속키
POPUP "&Spatial"
BEGIN
    MENUITEM "Canny Edge...\tCtrl+Alt+E", ID_MENU_CANNY
END

IDR_ACCEL ACCELERATORS
BEGIN
    "E", ID_MENU_CANNY, VIRTKEY, CONTROL, ALT
END
```

### 대화 상자 코드

```cpp
// CannyDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "Canny.hpp"

class CannyDlg {
public:
    CannyDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM, LPARAM);

    double ReadDouble(HWND h, int id, double def) const;
    int    ReadInt   (HWND h, int id, int def) const;
    bool   IsChecked (HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }

private:
    HWND owner_{};
    IppDib& dib_;
};
```

```cpp
// CannyDlg.cpp
#include "CannyDlg.h"

INT_PTR CannyDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_CANNY_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK CannyDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(CannyDlg*)l; return self->OnInit(h); }
    auto* self=(CannyDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w,l);
    return FALSE;
}
INT_PTR CannyDlg::OnInit(HWND h){
    SetDlgItemTextW(h, IDC_EDIT_CANNY_SIGMA, L"1.2");
    SetDlgItemInt  (h, IDC_EDIT_CANNY_KSIZE, 0, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_CANNY_LOW,   50, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_CANNY_HIGH, 120, FALSE);
    CheckDlgButton (h, IDC_CHK_CANNY_L2,   BST_CHECKED);
    CheckDlgButton (h, IDC_CHK_CANNY_REPL, BST_CHECKED);
    CheckRadioButton(h, IDC_RAD_CANNY_OUT_EDGES, IDC_RAD_CANNY_OUT_NMS, IDC_RAD_CANNY_OUT_EDGES);
    return TRUE;
}
double CannyDlg::ReadDouble(HWND h, int id, double def) const{
    wchar_t buf[64]; if (!GetDlgItemTextW(h, id, buf, 63)) return def;
    try{
        return std::stod(std::wstring(buf));
    } catch(...) { return def; }
}
int CannyDlg::ReadInt(HWND h, int id, int def) const{
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    return ok? v : def;
}
INT_PTR CannyDlg::OnCommand(HWND h, WPARAM w, LPARAM){
    switch(LOWORD(w)){
    case IDOK: {
        CannyOptions opt;
        opt.sigma = ReadDouble(h, IDC_EDIT_CANNY_SIGMA, 1.2);
        opt.ksize = ReadInt(h, IDC_EDIT_CANNY_KSIZE, 0);
        opt.low   = clampi(ReadInt(h, IDC_EDIT_CANNY_LOW, 50), 0, 255);
        opt.high  = clampi(ReadInt(h, IDC_EDIT_CANNY_HIGH, 120), 0, 255);
        if (opt.low > opt.high) std::swap(opt.low, opt.high);
        opt.L2    = IsChecked(h, IDC_CHK_CANNY_L2);
        opt.replicateBorder = IsChecked(h, IDC_CHK_CANNY_REPL);
        if (IsDlgButtonChecked(h, IDC_RAD_CANNY_OUT_MAG)==BST_CHECKED) opt.out = CannyOut::Magnitude;
        else if (IsDlgButtonChecked(h, IDC_RAD_CANNY_OUT_NMS)==BST_CHECKED) opt.out = CannyOut::NMS;
        else opt.out = CannyOut::Edges;

        IppDib out;
        if (CannyEdge(dib_, out, opt)) dib_ = out;

        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

### 메뉴 핸들러

```cpp
// main_multiwin.cpp (발췌)
#include "CannyDlg.h"

// ...
case ID_MENU_CANNY:
    if (st && st->dib){
        CannyDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 튜닝 가이드(실전 팁)

- **σ(시그마)**
  - 텍스트/선명: 0.8~1.2
  - 노이즈 많음: 1.2~2.0 (커질수록 얇은 엣지가 사라질 수 있음)
- **임계값**
  - 일반적으로 \(T_L \approx 0.4\,T_H\) 권장.
  - 너무 낮으면 노이즈 연결, 너무 높으면 끊김.
- **L2 vs L1**
  - L2는 정확하나 느림(루트); L1은 빠르며 약간 더 두꺼울 수 있음.
- **경계 처리**
  - `Replicate=true` 가 일반적으로 더 자연스러운 결과.
  - 타일형 데이터면 0패딩이 낫기도 함.
- **성능**
  - 가우시안은 **분리 합성**으로 O(WH·K) (이미 구현)
  - 멀티스레딩: 행/타일 분할이 쉽고 이득 큼(특히 4K 이상).

---

## 예제 시나리오

### **문서 가장자리 추출(스캔 자동 보정)**

- **상황**: 스캔 이미지에서 문서 경계 사다리꼴 검출
- **설정**: σ=1.0, High=120, Low=60, L2=ON
- **결과**: 종이 경계가 깨끗한 단일 픽셀 엣지로 추출 → 허프 변환/사각 근사에 바로 사용.

### **노이즈 많은 야간 촬영**

- **상황**: ISO가 높아 점 잡음 다수
- **설정**: σ=1.6, High=150, Low=70 (L2=ON), Replicate=ON
- **결과**: 노이즈 엣지는 억제, 물체 윤곽은 유지.

### **도로 차선 검출(전처리)**

- **상황**: 전방 카메라 프레임에서 차선 후보 추출
- **설정**: σ=1.2, High=100, Low=50, L1=ON(속도 우선), 출력=NMS(디버그)
- **결과**: 얇은 라인 확보 → ROI+허프 라인으로 연결성 확인.

### **세포 경계(현미경)**

- **상황**: 약한 얇은 엣지, 잡음 존재
- **설정**: σ=1.4, High=80, Low=40, L2=ON
- **결과**: 끊김 적고 연속적인 엣지 맵.

---

## 정확성 체크리스트

- [ ] 단색 이미지 → 결과 **전부 0**
- [ ] 계단형 경계(좌 0, 우 255) → 경계선 **1픽셀** 두께
- [ ] \(T_L \le T_H\) 유지 및 스왑 처리
- [ ] 가장자리 행/열에서 **Out-of-bounds** 접근 없음(Replicate/0패딩 동작)
- [ ] NMS 후 강도 스케일링(0..255) 일관성

---

## 수학 메모(요약)

- **NMS 비교 방향**:
  \[
  \text{keep if } M(x,y)\ge M(x+\Delta_1, y+\Delta_2)\ \text{and}\ M(x,y)\ge M(x-\Delta_1, y-\Delta_2)
  \]
  여기서 \((\Delta_1,\Delta_2)\)는 \(\theta\) 양자화(0/45/90/135)에 따라 선택.

- **히스테리시스**:
  강 엣지 집합 \(S=\{M\ge T_H\}\) 에서 시작, 8-이웃을 통해 약 엣지 \(\{T_L\le M<T_H\}\) 중 **연결 성분**을 합류.

---

## 간단 테스트 스니펫

```cpp
// test_canny.cpp
#include <cassert>
#include "Canny.hpp"

int main(){
    IppDib img; img.create(64,64,32);
    // 좌/우 절반 스텝
    for (int y=0;y<64;++y){
        uint8_t* d=(uint8_t*)img.bits()+y*img.stride();
        for (int x=0;x<32;++x) d[x*4+0]=d[x*4+1]=d[x*4+2]=0,   d[x*4+3]=255;
        for (int x=32;x<64;++x) d[x*4+0]=d[x*4+1]=d[x*4+2]=255, d[x*4+3]=255;
    }
    CannyOptions opt; opt.sigma=1.0; opt.low=30; opt.high=80; opt.L2=true;
    IppDib edges; bool ok=CannyEdge(img, edges, opt); assert(ok);

    // 경계 근처가 255인지 대략 점검
    uint8_t* p=(uint8_t*)edges.bits() + 32*edges.stride() + 31*4;
    assert(p[0]==255);
    return 0;
}
```

---

## 요약

- Canny는 **스무딩→그래디언트→NMS→이중 임계+히스테리시스** 로 **얇고 연속적인 엣지**를 제공.
- 본 구현은 **분리 가우시안, Sobel, 4방향 NMS, BFS 히스테리시스**, **0..255 임계**를 갖춤.
- UI(대화 상자/메뉴)로 σ/커널/임계/L2/경계/출력모드를 조절하며, **Magnitude/NMS/최종 엣지**를 비교할 수 있습니다.
- 속도·정밀 모두 준수하며, 멀티스레딩/DoG 통합으로 쉽게 고도화 가능.
