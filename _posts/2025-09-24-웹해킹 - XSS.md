---
layout: post
title: 웹해킹 - XSS
date: 2025-09-24 16:25:23 +0900
category: 웹해킹
---
# XSS - Stored · Reflected · DOM-Based 완전 가이드

## 무엇이 XSS인가? (요지)

- **XSS**는 *신뢰할 수 없는 입력*이 브라우저에서 **스크립트**로 실행되게 만들어, **세션 탈취·사용자 가장·데이터 유출** 등으로 이어지는 취약점입니다. 현대 방어의 핵심은 **컨텍스트별 출력 인코딩**·**신뢰 가능한 HTML만 허용(정화/샌드박스)**·**엄격한 CSP/Trusted Types**·**프레임워크 기본 보호 준수**입니다.

- **세 가지 유형**
  - **Stored(저장형)**: 악성 입력이 **서버/DB에 저장**된 뒤 여러 사용자에게 재노출.
  - **Reflected(반사형)**: 요청 파라미터가 즉시 응답에 반사되어 실행.
  - **DOM-Based**: **클라이언트 스크립트**가 URL 등에서 읽은 값을 **위험한 DOM sink**(예: `innerHTML`)로 주입하여 발생.

---

## 위협 모델과 안전 불변식

- **세션·크리덴셜 영향**: XSS는 `document.cookie` 획득·요청 위조·DOM 읽기 등을 가능케 함. `HttpOnly` 쿠키는 JS 접근을 차단하지만, **XSS 자체를 막지는 못함**(장기 피해 완화용). 또한 `SameSite`는 **CSRF 완화**에 유용하지만, **XSS가 있으면 토큰 읽기/행위 실행**으로 무력화될 수 있음—즉 **근본 대책은 XSS 제거**입니다.

- **방어 4대 원칙(요약)**
  1) **출력 인코딩(컨텍스트별)**, 2) **HTML Sanitization**(정말 HTML이 필요할 때만), 3) **강력한 CSP + Trusted Types**, 4) **프레임워크 자동 이스케이프 규칙 준수**.

---

## Stored XSS — “댓글이 곧 스크립트가 될 때”

### 취약 시나리오 (Node/Express + 템플릿 없는 문자열 결합)

```javascript
// ❌ 취약: 사용자가 올린 코멘트를 그대로 뿌림
app.post("/comments", async (req, res) => {
  await db.insert({ author: req.body.name, body: req.body.body }); // 저장
  res.redirect("/comments");
});

app.get("/comments", async (req, res) => {
  const comments = await db.findAll();
  // 문자열로 HTML을 직접 구성 → body에 <script>가 들어오면 실행됨
  let html = "<ul>";
  for (const c of comments) {
    html += `<li><b>${c.author}</b>: ${c.body}</li>`; // ❌ context 인코딩 없음
  }
  html += "</ul>";
  res.send(html);
});
```

**공격 예**: 악성 사용자가 `body="<img src=x onerror=alert(1)>"` 를 저장 → 모든 방문자 브라우저에서 실행.

### 안전한 렌더링(서버 템플릿의 **자동 이스케이프** 사용)

{% raw %}
```javascript
// ✅ 예: Pug/Nunjucks/Jinja2류 템플릿은 {{ ... }} 기본 이스케이프
// 템플릿: comment.pug
// ul
//   each c in comments
//     li
//       b= c.author           // 텍스트 컨텍스트 인코딩
//       | : #{c.body}         // 텍스트 컨텍스트 인코딩 (HTML로 해석되지 않음)

// 라우트
app.get("/comments", async (req, res) => {
  const comments = await db.findAll();
  res.render("comment", { comments });
});
```
{% endraw %}

- **원칙**: “HTML을 허용하지 않는” 화면은 **무조건 텍스트 컨텍스트**로 출력(템플릿 기본 이스케이프). **HTML이 꼭 필요**한 경우엔 **표준 Sanitizer(예: DOMPurify)**로 **화이트리스트** 기반 정화 후 제한적으로 주입.

### 사용자 HTML 허용이 필요한 제품(예: CMS)에서의 안전 패턴

```html
<!-- ✅ DOMPurify 예시 (클라이언트 측) -->
<div id="viewer"></div>
<script type="module">
  import DOMPurify from "https://cdn.skypack.dev/dompurify";
  // 서버에서 내려준 userHtml은 신뢰 불가 전제로 처리
  const safe = DOMPurify.sanitize(userHtml, { ALLOWED_TAGS: ['p','b','i','a','ul','li'], ALLOWED_ATTR: ['href'] });
  document.getElementById("viewer").innerHTML = safe; // sanitize 후 주입
</script>
```
- DOMPurify는 **HTML/SVG/MathML**도 정화 가능. 서버·클라 양측에서 적용 가능.

---

## Reflected XSS — “검색어에 스크립트가 섞여 돌아오는 경우”

### 취약 시나리오 (Flask)

```python
# ❌ 취약: 검색어를 문자열로 직접 삽입

@app.get("/search")
def search():
    q = request.args.get("q", "")
    return f"<p>검색어: {q}</p>"  # q="</p><script>alert(1)</script><p>"
```

### 안전한 출력(템플릿 자동 이스케이프)

{% raw %}
```python
# ✅ 안전: 템플릿 엔진 사용 (Jinja2는 기본 autoescape)

@app.get("/search-safe")
def search_safe():
    q = request.args.get("q", "")
    return render_template("search.html", q=q)
# search.html: <p>검색어: {{ q }}</p>  ← 텍스트 컨텍스트 인코딩

```
{% endraw %}

### **속성/URL 컨텍스트** 주의

{% raw %}
```html
<!-- ❌ 취약: 속성 컨텍스트 (href)에 직접 삽입 -->
<a id="go" href="?q={{ q }}">link</a>

<!-- ✅ 안전: 속성 컨텍스트 인코딩 & URL 인코딩 조합 -->
<a id="go" href="?q={{ q | urlencode }}">link</a>
```
{% endraw %}
- **컨텍스트별 인코딩**(HTML 텍스트/속성/JS/URL/CSS)은 각각 규칙이 다릅니다. 자동 이스케이프를 기본으로 하고, 링크·속성·JS 리터럴 등은 **해당 컨텍스트 전용 인코딩**을 적용하세요.

---

## DOM-Based XSS — “프런트 코드가 직접 사고를 만든다”

### 취약 시나리오

```html
<!-- ❌ 해시를 그대로 innerHTML에 주입 -->
<div id="output"></div>
<script>
  // URL: https://site/page#<img src=x onerror=alert(1)>
  document.getElementById('output').innerHTML = location.hash.substring(1); // ❌
</script>
```

### 안전한 패턴

```html
<!-- ✅ 텍스트 컨텍스트로 출력 -->
<div id="output"></div>
<script>
  document.getElementById('output').textContent = location.hash.substring(1);
</script>
```

- **DOM-XSS 핵심**: **신뢰할 수 없는 데이터**를 `innerHTML`, `insertAdjacentHTML`, `Range#createContextualFragment`, `document.write`, jQuery `.html()` 등의 **스크립트 실행 가능 sink**에 넣지 말 것. **`textContent`/`setAttribute`** 등 안전 API를 우선 사용.

### Sanitization이 필요한 경우(정말로 HTML을 보여줘야 한다면)

```html
<script type="module">
  import DOMPurify from "https://cdn.skypack.dev/dompurify";
  const raw = new URL(location.href).searchParams.get("content") || "";
  const safe = DOMPurify.sanitize(raw);
  document.body.insertAdjacentHTML("beforeend", safe); // sanitize 후 제한적 사용
</script>
```
- DOM-XSS 예방 원칙과 소스/싱크 목록은 **OWASP DOM-XSS Cheat Sheet**에서 체계적으로 확인하세요.

### **Trusted Types + CSP**(Chrome 등)으로 DOM-XSS 강제 차단

```http
Content-Security-Policy:
  trusted-types default; require-trusted-types-for 'script';
  script-src 'self' 'nonce-r4Nd0m' 'strict-dynamic'
```
```javascript
// 애플리케이션 초기화 시 정책 정의
// window.trustedTypes는 브라우저 지원 필요(폴리필 가능)
trustedTypes.createPolicy('default', {
  createHTML: (s) => DOMPurify.sanitize(s, { RETURN_TRUSTED_TYPE: true })
});
```
- **Trusted Types**: `innerHTML` 등 위험 sink에 **문자열** 전달을 **차단**하고, 오직 **정책을 통과한 SafeHTML 객체**만 허용. **CSP `require-trusted-types-for 'script'`**와 함께 쓰면 DOM-XSS를 구조적으로 줄일 수 있습니다.

---

## 프레임워크별 주의점(React/Angular/Vue)

### React

- 기본 바인딩(`{value}`)은 자동 이스케이프. 단, **`dangerouslySetInnerHTML` 사용 시** 반드시 **사전 Sanitization** 필요.
{% raw %}
```jsx
// ❌ 취약 (raw HTML 직접 주입)
<div dangerouslySetInnerHTML={{ __html: userHtml }} />

// ✅ 권장 (사전 정화 후 주입)
import DOMPurify from 'dompurify';
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(userHtml) }} />
```
{% endraw %}

### Angular

- Angular는 기본적으로 **템플릿 자동 이스케이프/바인딩 컨텍스트 검증**을 제공. **DomSanitizer**는 검증·정화를 도와주며, `bypassSecurityTrustHtml` 남용은 금지.

### Vue

- 기본 보간({% raw %}`{{ }}`{% endraw %})은 자동 이스케이프. **`v-html`은 신중하게**: *오직 Sanitization 거친 콘텐츠만* 허용. ESLint의 `vue/no-v-html` 규칙으로 사용을 경고/차단할 수 있습니다.

---

## 컨텍스트별 “출력 인코딩” 핵심 표

| 컨텍스트 | 안전 API/전략 | 비고 |
|---|---|---|
| **HTML 텍스트** | 템플릿 자동 이스케이프 / `textContent` | `<`, `>`, `&`, `"` 등 인코딩 |
| **HTML 속성 값** | 템플릿 속성 이스케이프 / `setAttribute` | URL은 추가로 **프로토콜 화이트리스트**(http/https 등) |
| **URL/쿼리** | 적절한 URL 인코딩(`encodeURIComponent`) | `javascript:` 등 **위험 스킴 금지** |
| **JS 문자열 리터럴** | 템플릿/라이브러리의 JS-context 이스케이프 | 가능하면 **내장 바인딩만** 사용 |
| **CSS** | 인라인 스타일 금지, 클래스 토글로 대체 | 필요 시 CSP `style-src` 최소화

> 프레임워크 기본 보호 + **OWASP XSS Cheat Sheet**의 컨텍스트별 가이드를 항상 병행하세요. **입력 필터링만으로는 부족**합니다.

---

## — “실수의 비용을 줄이는 안전망”

### 엄격 CSP의 골격(Nonce/Hash 기반)

```http
Content-Security-Policy:
  default-src 'none';
  script-src 'self' 'nonce-ABC123' 'strict-dynamic';
  base-uri 'none'; object-src 'none';
  style-src 'self';
  img-src 'self' data:;
```
- **핵심**: `script-src`는 **Nonce/Hash** 기반으로 *허용 스크립트만* 실행. `strict-dynamic`은 **nonce가 부여된 루트 스크립트가 동적으로 로드하는 스크립트**까지 신뢰를 전파(목록 유지 부담↓). 단, 잘못 사용하면 3rd-party 스크립트에 의해 완화될 수 있으니 주의.
- CSP 작성 지침·모범 사례는 **OWASP CSP Cheat Sheet** 참고.

### Trusted Types와의 결합

- CSP만으로 **DOM-XSS**까지 완벽 방어하긴 어려움 → **Trusted Types**로 위험 sink에 **문자열 전달 자체**를 막아 *개발 실수*를 구조적으로 억제.

---

## 쿠키 보안(영향 완화)

- **`HttpOnly`**: JS에서 쿠키 접근 차단(세션 탈취 난이도↑). 그러나 **XSS 자체를 차단하지는 않음**—반드시 **XSS 예방**이 1순위.
- **`SameSite`**: 교차 사이트 전송 제한으로 **CSRF 위험 완화**. `None`을 쓸 경우 `Secure` 필수. (XSS와는 별개 층의 대책)

---

## “위험한 DOM sink / API” 단축표

- `innerHTML`, `outerHTML`, `insertAdjacentHTML`, `document.write`,
- `eval`, `new Function`, `setTimeout("string")`, `setInterval("string")`,
- jQuery: `.html()`, `.append("<string>")` 등 문자열 기반 삽입.
→ **대안**: `textContent`, `createElement` + `setAttribute`, 안전 바인딩, 사전 Sanitization. (DOM-XSS Cheat Sheet 참조)

---

## 실제 코드로 보는 유형별 “취약 → 수정” 레시피

### Stored XSS (블로그 댓글)

```php
<!-- ❌ (PHP) 취약: 저장한 코멘트를 그대로 출력 -->
<ul>
<?php foreach ($comments as $c): ?>
  <li><b><?= $c["author"] ?></b>: <?= $c["body"] ?></li>
<?php endforeach; ?>
</ul>

<!-- ✅ 안전: 이스케이프 함수 사용 -->
<ul>
<?php foreach ($comments as $c): ?>
  <li><b><?= htmlspecialchars($c["author"], ENT_QUOTES, 'UTF-8') ?></b>:
      <?= htmlspecialchars($c["body"], ENT_QUOTES, 'UTF-8') ?></li>
<?php endforeach; ?>
</ul>
```
> **팁**: HTML 허용이 목적이라면 서버 저장 **직전**과 표시 **직전**에 **이중 Sanitization(보수적 정책)**을 고려하고, **원본/정화본**을 분리 저장해 감사와 롤백을 쉽게 합니다. (Sanitizer로 DOMPurify를 널리 사용)

### Reflected XSS (검색창)

```java
// ❌ (Spring MVC) 취약: 파라미터를 JSP에 그대로 노출
@GetMapping("/search")
public String s(@RequestParam String q, Model m) {
  m.addAttribute("q", q); // JSP에서 <%= q %>로 출력하면 XSS
  return "search";
}

// ✅ JSP에서 EL/태그라이브러리로 이스케이프 출력 (${q})
// 또는 Thymeleaf: <span th:text="${q}"></span> (기본 이스케이프)
```

### DOM-Based XSS (해시/쿼리 → innerHTML)

```html
<!-- ❌ -->
<div id="greet"></div>
<script>
  const name = new URL(location.href).searchParams.get("name") || "";
  greet.innerHTML = `Hello, ${name}`; // <script>alert(1)</script>
</script>

<!-- ✅ -->
<script>
  const name = new URL(location.href).searchParams.get("name") || "";
  greet.textContent = `Hello, ${name}`;
</script>
```

### React/Vue/Angular에서의 사용자 HTML 표시

{% raw %}
```jsx
// React ✅ (사전 정화 + dangerouslySetInnerHTML)
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(userHtml) }} />
```
{% endraw %}
```html
<!-- Vue ✅ (v-html 사용 시 정화 필수) -->
<div v-html="sanitizedHtml"></div>
```
```ts
// Angular ✅
constructor(private sanitizer: DomSanitizer) {}
safeHtml = this.sanitizer.bypassSecurityTrustHtml(DOMPurify.sanitize(userHtml));
```
- 각 프레임워크의 **보안 가이드/경고**를 숙지하고, “위험 API는 최소화 + 정화” 원칙을 지키세요.

---

## 테스트 & 운영 체크리스트

### 스모크 페이로드(개발/QA 환경 전용)

- `"><script>alert(1)</script>` · `<img src=x onerror=alert(1)>` · `<svg onload=alert(1)>` 등
→ **기대 결과**: *그냥 텍스트로 보이거나* Sanitizer에 의해 제거.

> **주의**: 필터 회피 페이로드는 *방어 검증용으로만* 사용하세요. **입력 필터링만으로는 방어 불가**하다는 점을 보여주는 OWASP 자료도 참고.

### 자동 점검 루틴

- **정적 점검**: 금지 API(예: `innerHTML`) 탐지 규칙. 프레임워크별 Lint(예: Vue `no-v-html`).
- **동적 점검**: “미러링된 입력이 스크립트로 실행되는지”를 중심으로 DAST/프록시 테스트.

### 운영 설정

- **CSP 엄격 모드**(Nonce/Hash, `strict-dynamic`) + **Trusted Types 강제**
- 세션 쿠키 **`HttpOnly`**, 필요 시 `SameSite`로 CSRF 완화
- 서드파티 스크립트 최소화/서브리소스 무결성(SRI) 병행
- 모든 경계에서 **로그/알림**: 에러율 급증, CSP 위반 보고서 등.

---

## 요약

- **Stored/Reflected/DOM-Based** 모두의 공통분모는 “**신뢰할 수 없는 데이터가 코드가 되지 않게**” 하는 것.
- **기본 전략**: 컨텍스트별 **출력 인코딩** → “정말 필요할 때만” **Sanitization** → **CSP + Trusted Types**로 실수의 여지 차단 → **프레임워크 권장 규칙** 고수.
- **쿠키 보안 속성**은 XSS의 **영향을 줄이는 보조책**이며, **예방책의 대체재가 아닙니다**.

---

### 참고(핵심 문서)

- **OWASP XSS Prevention Cheat Sheet / DOM-Based XSS Cheat Sheet / CSP Cheat Sheet**.
- **MDN CSP & Trusted Types**(지시어·사용법), **XSS 개요**, **쿠키 보안 가이드**.
- **Trusted Types 소개(web.dev)**, **DOMPurify 문서/사이트**.
- **프레임워크 보안 가이드**: Angular, Vue, React 관련 주의사항.
\
