---
layout: post
title: 이산수학 - 점화관계의 응용
date: 2025-06-21 19:20:23 +0900
category: 이산수학
---
# 점화관계의 응용 (Applications of Recurrence Relations)

## 0. 왜 점화관계인가?

- **모델링**: “큰 문제 = 작은 문제들의 조합”을 수식으로 표현 → **정확한 의미**와 **경계조건**을 갖춤.
- **분석**: 시간복잡도·정확성·수렴성 등을 **귀납적**으로 증명 가능.
- **구현**: 점화식 = 동적계획법(DP) 코드 설계도.

---

## 1. 점화관계의 형태 및 해석 관점

| 관점 | 일반형 | 용도 | 해석 도구 |
|---|---|---|---|
| 수열형 | $$a_n=f(a_{n-1},\dots,a_{n-k})$$ | 수학적 수열·조합 | 특성방정식·생성함수 |
| 복잡도형 | $$T(n)=\sum_i a_i\,T(n/b_i)+f(n)$$ | 분할정복 알고리즘 | 마스터 정리·재귀트리·Akra–Bazzi |
| DP형(최적화) | $$\text{OPT}[s]=\min/\max_{t\in \text{choices}(s)}\{\text{cost}(s,t)+\text{OPT}[\text{next}(s,t)]\}$$ | 최적화·경로·편집거리 | 최적 부분구조·중복 부분문제 |
| 그래프형 | $$dp[v]=\operatorname{combine}\{dp[u] : (u\rightarrow v)\}$$ | DAG 경로·개수 | 위상정렬·트리DP |
| 확률형 | $$E[X]=p\cdot f(E[\cdot])+\dots$$ | 기대값·흡수시간 | 선형 방정식계 |

---

## 2. 알고리즘 복잡도: 분할정복 점화식

### 2.1 머지소트
- 점화식:
  $$
  T(n)=2T(n/2)+cn
  $$
- 마스터 정리 $$a=2,b=2,d=1\Rightarrow a=b^d$$
  $$
  T(n)=\Theta(n\log n)
  $$

### 2.2 퀵소트(평균)
- 평균 분할이 균형이라는 가정:
  $$
  T(n)=T(n/2)+T(n/2)+\Theta(n)=2T(n/2)+\Theta(n)\Rightarrow \Theta(n\log n)
  $$
- 최악분할: $$T(n)=T(n-1)+\Theta(n)=\Theta(n^2)$$

### 2.3 Karatsuba 곱셈
- 점화식:
  $$
  T(n)=3T(n/2)+\Theta(n)\Rightarrow \Theta(n^{\log_2 3})\approx \Theta(n^{1.585})
  $$

### 2.4 비균등 분할 (Akra–Bazzi)
- 예:
  $$
  T(n)=T(n/3)+T(2n/3)+n\Rightarrow \Theta(n\log n)
  $$
  (지수 $$p$$가 1이 되어 적분항이 $$\log n$$을 만든다)

---

## 3. 동적 계획법(최적화)에서의 점화관계

### 3.1 계단 오르기(1,2칸)
- 문제: $$n$$칸을 1칸 또는 2칸씩.
- 점화:
  $$
  a_n=a_{n-1}+a_{n-2},\quad a_1=1,\ a_2=2
  $$
- 구현(바텀업):
```python
def climb_stairs(n: int) -> int:
    if n <= 2: return n
    a, b = 1, 2
    for _ in range(3, n+1):
        a, b = b, a + b
    return b
```

### 3.2 2×n 도미노 타일링
- 점화:
  $$
  T(n)=T(n-1)+T(n-2),\quad T(1)=1,T(2)=2
  $$
  (왼쪽 1×2 세로 타일 or 2×1 두 개 가로 타일)

### 3.3 코인 체인지(경우의 수: 무한중복 허용)
- 상태: $$dp[i] = i$$ 금액을 만드는 방법 수
- 점화(동전 집합 $$C$$):
  $$
  dp[0]=1,\quad dp[x]\mathrel{+}=dp[x-c]\ (\forall c\in C,\ x\ge c)
  $$
- 구현:
```python
def coin_change_count(amount: int, coins: list[int]) -> int:
    dp = [0]*(amount+1)
    dp[0] = 1
    for c in coins:
        for x in range(c, amount+1):
            dp[x] += dp[x - c]
    return dp[amount]
```

### 3.4 편집거리(Edit Distance, Levenshtein)
- 상태: $$dp[i][j]$$ = 첫 문자열 앞 $$i$$글자 → 두 번째 앞 $$j$$글자 최소 연산
- 점화:
  $$
  dp[i][j]=\min\begin{cases}
  dp[i-1][j]+1 & (\text{삭제})\\
  dp[i][j-1]+1 & (\text{삽입})\\
  dp[i-1][j-1]+[s_i\neq t_j]
  \end{cases}
  $$
- 구현:
```python
def edit_distance(a: str, b: str) -> int:
    n, m = len(a), len(b)
    dp = [[0]*(m+1) for _ in range(n+1)]
    for i in range(n+1): dp[i][0] = i
    for j in range(m+1): dp[0][j] = j
    for i in range(1, n+1):
        for j in range(1, m+1):
            cost = 0 if a[i-1]==b[j-1] else 1
            dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost)
    return dp[n][m]
```

### 3.5 행렬 연쇄 곱셈(Matrix Chain)
- 차원: 행렬 $$A_i: p_{i-1}\times p_i$$
- 점화:
  $$
  m[i][j] = \min_{i\le k<j}\{m[i][k]+m[k+1][j]+p_{i-1}p_k p_j\}
  $$
- 구현:
```python
def matrix_chain_mult(dims: list[int]) -> int:
    n = len(dims) - 1
    INF = 10**18
    m = [[0]*(n+1) for _ in range(n+1)]
    for L in range(2, n+1):
        for i in range(1, n-L+2):
            j = i+L-1
            m[i][j] = INF
            for k in range(i, j):
                cost = m[i][k] + m[k+1][j] + dims[i-1]*dims[k]*dims[j]
                if cost < m[i][j]: m[i][j] = cost
    return m[1][n]
```

### 3.6 LIS(최장 증가 부분수열) — DP 점화
- 단순 DP:
  $$
  dp[i]=1+\max_{j<i,\ a_j<a_i} dp[j],\quad \text{정답}=\max_i dp[i]
  $$
- $$O(n^2)$$, 이분탐색 개선은 별도 테크닉.

---

## 4. 조합·수학적 구조에서의 점화

### 4.1 카탈란 (올바른 괄호/이진 트리/평면경로)
- 점화:
  $$
  C_{n+1}=\sum_{i=0}^{n} C_i C_{n-i},\quad C_0=1
  $$
- 닫힌형:
  $$
  C_n=\frac{1}{n+1}\binom{2n}{n}
  $$
- 구현:
```python
def catalan(n: int) -> int:
    C = [0]*(n+1)
    C[0] = 1
    for m in range(1, n+1):
        C[m] = sum(C[i]*C[m-1-i] for i in range(m))
    return C[n]
```

### 4.2 이항계수(파스칼 삼각형)
- 점화:
  $$
  \binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1},\quad \binom{n}{0}=\binom{n}{n}=1
  $$

### 4.3 타일링·분해·분할
- 2×n 도미노: $$T(n)=T(n-1)+T(n-2)$$
- 1,2,3 합 분해(Tribonacci):
  $$
  a_n=a_{n-1}+a_{n-2}+a_{n-3}
  $$

---

## 5. 그래프·트리 점화: DAG·트리 DP

### 5.1 DAG에서 경로 수
- 위상순서 $$v_1,\dots,v_n$$ 에 대해:
  $$
  ways[s]=1,\quad ways[v]=\sum_{(u\to v)} ways[u]
  $$
- 구현:
```python
from collections import defaultdict, deque

def count_paths_dag(n, edges, s, t):
    G = defaultdict(list); indeg = [0]*n
    for u,v in edges:
        G[u].append(v); indeg[v]+=1
    q=deque(i for i in range(n) if indeg[i]==0)
    topo=[]
    while q:
        x=q.popleft(); topo.append(x)
        for y in G[x]:
            indeg[y]-=1
            if indeg[y]==0: q.append(y)
    ways=[0]*n; ways[s]=1
    for v in topo:
        for w in G[v]:
            ways[w]+=ways[v]
    return ways[t]
```

### 5.2 트리 최대 독립집합(Maximum Independent Set on Tree)
- 정의: 인접 정점 동시에 선택 금지. 루트드 트리에서
  $$
  dp[v][0]=\sum_{u\in child(v)} \max(dp[u][0],dp[u][1]),\quad
  dp[v][1]=1+\sum_{u\in child(v)} dp[u][0]
  $$
- 구현(루트 0 가정):
```python
import sys
sys.setrecursionlimit(1_000_000)

def tree_mis(n, edges):
    g=[[] for _ in range(n)]
    for u,v in edges:
        g[u].append(v); g[v].append(u)
    dp=[[0,0] for _ in range(n)]
    vis=[False]*n
    def dfs(v: int, p: int):
        vis[v]=True
        dp[v][0]=0; dp[v][1]=1
        for w in g[v]:
            if w==p: continue
            dfs(w, v)
            dp[v][0]+=max(dp[w][0], dp[w][1])
            dp[v][1]+=dp[w][0]
    dfs(0, -1)
    return max(dp[0][0], dp[0][1])
```

---

## 6. 확률·기대값에서의 점화

### 6.1 랜덤 워크(간단 예: 기대 흡수시간)
- 1D 선분에서 0, N이 흡수 상태, 내부 i에서 좌/우 1/2 이동. 기대 시간 $$E[i]$$:
  $$
  E[0]=E[N]=0,\quad E[i]=1+\tfrac12 E[i-1]+\tfrac12 E[i+1]
  $$
  → 선형 연립점화로 풀이(해: $$E[i]=i(N-i)$$).

### 6.2 기대 재귀의 전형
- 상태에서 “한 단계 후” 기대식을 세우고 선형 방정식으로 정리:
  $$
  E[X]=\sum_{s'} P(s\to s')\big( c(s\to s')+E[X\mid s']\big)
  $$

---

## 7. 수치해석·최적화의 점화

### 7.1 뉴턴 방법
- 점화:
  $$
  x_{k+1}=x_k-\frac{f(x_k)}{f'(x_k)}
  $$
- 수렴분석 또한 점화로.

### 7.2 점근 전개·오차 점화
- 오차 $$e_{k+1}\approx C e_k^p$$ 등으로 수렴 차수 파악.

---

## 8. 설계 체크리스트 (DP/점화 잘 세우는 법)

1) **상태 정의**: 무엇을 최소/최대/계산할지 **명확히**.
2) **경계조건**: 가장 작은 입력에서 값은?
3) **전이(점화)**: 현재 상태를 어떻게 작은 상태로 분해?
4) **무모순성**: 중복/누락/순환참조 없음.
5) **계산 순서**: 위상·인덱스 증가·길이 증가 등으로 **의존성 보장**.
6) **복잡도**: 상태 개수 × 전이비용.
7) **검증**: 작은 입력에 대한 **직관·브루트포스**와 비교.

---

## 9. **케이스 스터디** (문제 → 점화 → 증명 → 구현)

### 9.1 타일링: 2×n 보드, 1×2/2×1 도미노
- 점화: $$T(n)=T(n-1)+T(n-2)$$, $$T(1)=1,T(2)=2$$
- 귀납증명: 각 칸의 가장 왼쪽 열 배치(세로 1개 or 가로 2개) 분해로 충족.
- 구현:
```python
def tiling_2xn(n: int) -> int:
    if n<=2: return n
    a,b=1,2
    for _ in range(3,n+1):
        a,b=b,a+b
    return b
```

### 9.2 코인 체인지(최소 동전 수)
- 점화:
  $$
  dp[0]=0,\quad dp[x]=\min_{c\le x}\{dp[x-c]+1\}
  $$
- 구현:
```python
def coin_change_min(amount: int, coins: list[int]) -> int:
    INF=10**9
    dp=[INF]*(amount+1); dp[0]=0
    for x in range(1, amount+1):
        for c in coins:
            if c<=x and dp[x-c]+1<dp[x]:
                dp[x]=dp[x-c]+1
    return dp[amount] if dp[amount]!=INF else -1
```

### 9.3 LCS(최장 공통 부분수열)
- 점화:
  $$
  dp[i][j]=\begin{cases}
  dp[i-1][j-1]+1 & (s_i=t_j)\\
  \max(dp[i-1][j],dp[i][j-1]) & \text{otherwise}
  \end{cases}
  $$
- 구현:
```python
def lcs(a: str, b: str) -> int:
    n,m=len(a),len(b)
    dp=[[0]*(m+1) for _ in range(n+1)]
    for i in range(1,n+1):
        for j in range(1,m+1):
            if a[i-1]==b[j-1]:
                dp[i][j]=dp[i-1][j-1]+1
            else:
                dp[i][j]=max(dp[i-1][j], dp[i][j-1])
    return dp[n][m]
```

### 9.4 최단경로 DAG
- 점화(가중치 $$w(u,v)$$):
  $$
  dist[s]=0,\quad dist[v]=\min_{(u\to v)}\{dist[u]+w(u,v)\}
  $$
- 구현(위상정렬 후 릴랙스):
```python
def dag_shortest_path(n, edges, s):
    from collections import defaultdict, deque
    G=defaultdict(list); indeg=[0]*n
    for u,v,w in edges:
        G[u].append((v,w)); indeg[v]+=1
    q=deque(i for i in range(n) if indeg[i]==0); topo=[]
    while q:
        x=q.popleft(); topo.append(x)
        for y,_ in G[x]:
            indeg[y]-=1
            if indeg[y]==0: q.append(y)
    INF=10**15
    dist=[INF]*n; dist[s]=0
    for v in topo:
        for w,c in G[v]:
            if dist[v]+c<dist[w]:
                dist[w]=dist[v]+c
    return dist
```

### 9.5 BST 개수(노드 n개): 카탈란
- 재귀적 분할(루트 왼쪽 i개·오른쪽 n-1-i개):
  $$
  G_n=\sum_{i=0}^{n-1} G_i G_{n-1-i},\quad G_0=1
  $$
- $$G_n=C_n$$ (카탈란). DP로 구현 가능(§4.1 참조).

### 9.6 하노이의 탑
- 점화:
  $$
  M(n)=2M(n-1)+1,\quad M(1)=1\Rightarrow M(n)=2^n-1
  $$
- 귀납으로 닫힌형 증명 가능.
- 이동 순서도 재귀로 출력:
```python
def hanoi(n, a='A', b='B', c='C', moves=None):
    if moves is None: moves=[]
    if n==1:
        moves.append((a,c)); return moves
    hanoi(n-1, a, c, b, moves); moves.append((a,c))
    hanoi(n-1, b, a, c, moves); return moves
```

---

## 10. 점화관계 설계·증명 패턴

1) **분해 규칙 세우기**: 입력을 어떻게 나누면 하위문제가 본질적으로 같나?
2) **중복/순서 고려**: 경우의 수인지 최적값인지 확인 후, 합/최솟값/최댓값으로 결합.
3) **경계 설정**: 최소 입력에서 값이 무엇인지 명확히.
4) **증명**:
   - **정확성**: 귀납(하위문제 정답 ⇒ 전체 정답).
   - **복잡도**: 점화식 해석(마스터·재귀트리·아크라–바지).
5) **구현 순서**: 의존성이 충족되는 순서(길이, 위상, 차원 증가)로 루프 구성.
6) **메모리 최적화**: 1차/2차 배열의 의존만 있으면 슬라이딩 윈도우로 축소.

---

## 11. 디버깅·함정 리스트

- **잘못된 베이스**: $$dp[0]$$, 빈 문자열, 빈 집합 상태를 빠뜨림.
- **중복 카운트/누락**: 경우의 수 점화에서 순서/중복 허용 여부 혼동.
- **공진/중복근 간과**: 해석형 점화(특수해 추측)에서 $$n^s$$ 곱 누락.
- **순환 의존**: 계산 순서가 점화 의존과 불일치.
- **정수 오버플로**: 큰 조합 수는 모듈러(예: $$10^9+7$$) 사용.
- **부동소수 오차**: 확률·수치 점화는 정규화/로그/고정소수 고려.

---

## 12. 추가 예제 모음 (빠른 레시피)

### 12.1 부분집합 합(불린)
- 점화:
  $$
  dp[i][s]=dp[i-1][s]\ \text{or}\ dp[i-1][s-w_i]
  $$
- 1차원 최적화 가능(역순 루프).

### 12.2 구간 DP (팰린드롬 분할 최소 컷)
- 상태: $$dp[i][j]$$, 전이: 중간 분할 $$k$$ 시도 또는 “끝 문자가 같고 내부가 팔린드롬”.
- 계산 순서: 구간 길이 증가.

### 12.3 문자열 정렬 최소 비용(삽입/삭제/교체 가중)
- 편집거리 변형: 가중치만 다른 동일 점화.

### 12.4 기대 동작 횟수(확률 DP)
- 상태기대: $$E[s]=1+\sum p(s\to s')E[s']$$, 경계는 흡수상태 $$E=0$$.

---

## 13. 실전 미니 프로젝트: “문자열 3문제 한 파일로”

- **문제**: LCS 길이, 편집거리, 공통부분문자열 길이를 한 번에 제공
- **핵심 점화**:
  - LCS: §9.3
  - Edit: §3.4
  - Longest Common Substring:
    $$
    dp[i][j]=\begin{cases}
    dp[i-1][j-1]+1 & (s_i=t_j)\\
    0 & \text{else}
    \end{cases}
    $$
- 구현:
```python
def lcs_len(a, b):
    n,m=len(a),len(b)
    dp=[[0]*(m+1) for _ in range(n+1)]
    for i in range(1,n+1):
        for j in range(1,m+1):
            dp[i][j]=dp[i-1][j-1]+1 if a[i-1]==b[j-1] else max(dp[i-1][j], dp[i][j-1])
    return dp[n][m]

def edit_dist(a,b):
    n,m=len(a),len(b)
    dp=[[0]*(m+1) for _ in range(n+1)]
    for i in range(n+1): dp[i][0]=i
    for j in range(m+1): dp[0][j]=j
    for i in range(1,n+1):
        for j in range(1,m+1):
            dp[i][j]=min(
                dp[i-1][j]+1,
                dp[i][j-1]+1,
                dp[i-1][j-1]+(a[i-1]!=b[j-1])
            )
    return dp[n][m]

def lcs_substring_len(a,b):
    n,m=len(a),len(b)
    dp=[[0]*(m+1) for _ in range(n+1)]
    best=0
    for i in range(1,n+1):
        for j in range(1,m+1):
            if a[i-1]==b[j-1]:
                dp[i][j]=dp[i-1][j-1]+1
                if dp[i][j]>best: best=dp[i][j]
            else:
                dp[i][j]=0
    return best
```

---

## 14. 연습문제(힌트 포함)

1) **분할정복 합**: $$T(n)=2T(n/2)+n/\log n$$ 의 점근해는?
   - 힌트: 재귀트리 합계가 $$n\log\log n$$.

2) **코인 체인지(경우의 수)**: 순서 상관 **있음**(예: 1+2와 2+1 구분)일 때 점화는?
   - 힌트: $$order\_dp[x]=\sum_{c\le x} order\_dp[x-c]$$, 코인 루프를 **밖**으로.

3) **클러스터링 DP**: 1차 수열을 k구간으로 나눠 구간 비용 합 최소화.
   - 힌트: $$dp[i][t]=\min_{p<i}\{dp[p][t-1]+cost(p+1,i)\}$$, 분할정복/Knuth 최적화 조건 조사.

4) **트리 경로 수**: 루트에서 리프까지 합이 S인 경로 수.
   - 힌트: $$cnt[v](s)=\sum_{u\in child(v)} cnt[u](s-w(u))$$.

5) **랜덤 게임 기대 턴**: 성공확률 p, 실패 시 초기화되는 게임의 기대 턴 수.
   - 힌트: $$E=1\cdot p + (1+E)\cdot(1-p) \Rightarrow E=\frac{1}{p}$$.

---

## 15. 요약

- 점화관계 = **모델링·증명·구현**의 공통 언어.
- 알고리즘: 분할정복 복잡도(마스터·Akra–Bazzi), DP 최적화.
- 조합: 카탈란·이항계수·타일링·분해.
- 그래프/트리: DAG·트리 DP로 전이 정의.
- 확률/수치: 기대값·흡수시간·수렴 분석.
- **체크리스트**와 **패턴**을 지키면 대부분의 문제를 안정적으로 점화→DP로 전환 가능.

---

## 16. 부록: 작은 검증 유틸

```python
# 피보나치/타일링류 빠른 검증
def fib_dp(n):
    a,b=0,1
    for _ in range(n): a,b=b,a+b
    return a

def equal_small(f, g, upto=30):
    for n in range(upto+1):
        if f(n)!=g(n):
            return False, n, f(n), g(n)
    return True, None, None, None

# 예: tiling_2xn vs fib_dp shifted
def tiling_ref(n):  # T(1)=1,T(2)=2 → T(n)=F_{n+1}
    return fib_dp(n+1)

ok,*rest = equal_small(tiling_2xn, tiling_ref, 20)
print("tiling==ref ?", ok, rest if not ok else "")
```
