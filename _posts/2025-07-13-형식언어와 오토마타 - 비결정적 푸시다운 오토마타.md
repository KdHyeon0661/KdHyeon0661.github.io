---
layout: post
title: 형식언어와 오토마타 - 비결정적 푸시다운 오토마타
date: 2025-07-13 21:20:23 +0900
category: 형식언어와 오토마타
---
# 비결정적 푸시다운 오토마타 (NPDA)

> **핵심 요약**  
> - **PDA**는 스택을 가진 유한 오토마타.  
> - **NPDA**는 한 구성에서 **여러 전이**가 가능(비결정성). **문맥 자유 언어(CFL)** 전체를 인식.  
> - **수용 방식**: *최종 상태 수용* ↔ *빈 스택 수용* (서로 변환 가능).  
> - **DPDA ⊊ NPDA**: DPDA는 **결정적 문맥 자유 언어(DCFL)**만 인식.  
> - **예제**: \( \{a^n b^n\} \) (DPDA/NPDA 가능), \( \{ww^R\} \) (NPDA로 자연스럽게), \( \{a^n b^n c^n\} \) **비-CFL**(NPDA로도 불가).  
> - **구현**: 파이썬으로 **NPDA 시뮬레이터**(ε-전이, 빈 스택/최종상태 수용 모두) + 실제 오토마타 정의/검증.

---

## 1. PDA의 형식적 정의

PDA는 7-튜플로 정의한다.

$$
M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)
$$

- \(Q\): 유한 상태 집합
- \(\Sigma\): 입력 알파벳
- \(\Gamma\): 스택 알파벳
- \(\delta: Q \times (\Sigma \cup \{\varepsilon\}) \times \Gamma \to \mathcal{P}(Q \times \Gamma^*)\)  
  현재 상태/입력(또는 ε)/스택상단을 보고, **다음 상태**와 **대체할 스택 문자열**(pop 후 push할 시퀀스)들의 **집합**을 반환
- \(q_0\): 시작 상태
- \(Z_0\): 초기 스택 기호(바닥표식)
- \(F\): 최종 상태 집합

**구성(configuration)**은 \((q, i, \gamma)\)로 표현:
- \(q \in Q\): 현재 상태
- \(i\): 입력에서 읽은 위치(접두사의 길이)
- \(\gamma \in \Gamma^*\): 현재 스택(맨 왼쪽이 맨 위라고 가정하거나, 맨 오른쪽이 위라고 가정 — 구현에서 통일)

**전이** \((q,a,X) \vdash (p,\beta)\)의 의미:
- 입력 심볼 \(a\) (또는 \(a=\varepsilon\))를 소비(소비하지 않을 수도)
- 스택 상단의 \(X\)를 pop 후 \(\beta \in \Gamma^*\)를 **상단부터** push
- 상태 \(p\)로 이동

---

## 2. 비결정성: NPDA

**NPDA**는 동일한 \((q,a,X)\)에서 **여러 개의 전이**가 허용된다(δ의 값이 집합).  
수용 기준:
- **최종 상태 수용**: 입력 전부를 소비하고 \(F\)에 속한 상태에 도달하는 경로가 **하나라도** 있으면 수용
- **빈 스택 수용**: 입력 전부 소비 + 스택이 빈다(바닥표식만 남거나 완전 비움)

> 두 수용 방식은 **서로 변환 가능**:  
> - 빈 스택 수용 PDA → 최종상태 수용 PDA: “스택이 바닥만 남았다”를 인지하면 전용 **수용상태**로 ε-이동  
> - 최종상태 수용 PDA → 빈 스택 수용 PDA: 수용상태에서 **스택을 깨끗이 비우는 ε-사다리**를 붙여 빈 스택으로 종결

---

## 3. DPDA vs NPDA (정확한 비교)

| 구분 | DPDA(결정적 PDA) | NPDA(비결정적 PDA) |
|---|---|---|
| 전이 | 각 \((q,a,X)\)에 **최대 1개** | **복수 가능** |
| 수용 | 보통 **최종상태 수용**로 다루면 안전 | 최종상태/빈스택 모두 자연스러움 |
| 표현력 | **DCFL**만 인식 | **CFL 전체** 인식 |
| 예시 | \( \{a^n b^n\} \), well-nested parentheses 등 | \( \{ww^R \mid w\in\{a,b\}^*\} \), \( \{a^i b^j c^k \mid i=j \text{ 또는 } j=k\} \) 등 |
| 주의 | ε-전이와 입력전이가 같은 \((q,X)\)에서 **동시정의 금지** 등 결정성 제약 | 제약 없음 (대신 시뮬레이션은 상태폭발 관리 필요) |

> ⚠️ **정정**: \( \{a^n b^n c^n\} \)은 **문맥 자유 언어가 아니므로** NPDA로도 인식할 수 없다(펌핑보조정리/오그던 보조정리로 증명).  

---

## 4. 대표 예제 설계

### 4.1 \( L_1 = \{ a^n b^n \mid n \ge 0 \} \)

**아이디어**:  
- \(a\)를 읽을 때마다 스택에 \(A\) push  
- \(b\)를 읽을 때마다 \(A\) pop  
- 입력 종료 시 바닥만 남으면 수용

**최종상태 수용** NPDA (스택 바닥기호 \(Z_0\)):

- 상태: \(Q=\{q_{\text{push}}, q_{\text{pop}}, q_f\}\)
- 시작: \(q_{\text{push}}\), 스택 \(Z_0\)
- 전이(개략):
  - \( (q_{\text{push}}, a, Z_0) \to (q_{\text{push}}, A Z_0) \)  
    \( (q_{\text{push}}, a, A) \to (q_{\text{push}}, A A) \)
  - “b-영역 진입”을 **비결정적으로** 선택:  
    \( (q_{\text{push}}, \varepsilon, Z_0) \to (q_{\text{pop}}, Z_0) \)  
    (또는 첫 b를 읽을 때 pop모드로 바꾸는 전이)
  - pop 단계:  
    \( (q_{\text{pop}}, b, A) \to (q_{\text{pop}}, \varepsilon) \)
  - 입력소비 완료 + \(Z_0\)만:  
    \( (q_{\text{pop}}, \varepsilon, Z_0) \to (q_f, Z_0) \)

- 주의: \(a\)-영역에서 \(b\)가 오면 pop 모드로 전환되도록 전이를 설계(결정적으로도 구현 가능).

### 4.2 \( L_2 = \{ ww^R \mid w \in \{a,b\}^* \} \) (짝수 길이 팰린드롬)

**아이디어**:  
- 입력 전반부를 스택에 push  
- **중간 지점**을 ε-전이로 **비결정**적으로 “지금부터 pop단계”라 가정  
- 이후 문자를 읽을 때마다 **스택 top과 일치**해야 pop하며 진행 → 끝까지 맞으면 수용

- 상태: \( \{q_{\text{push}}, q_{\text{pop}}, q_f\} \)
- 전이(개략):
  - push 모드:  
    \( (q_{\text{push}}, a, X) \to (q_{\text{push}}, aX) \), \( (q_{\text{push}}, b, X) \to (q_{\text{push}}, bX) \)
  - 중간점 가정(ε-전이):  
    \( (q_{\text{push}}, \varepsilon, X) \to (q_{\text{pop}}, X) \)
  - pop 모드:  
    \( (q_{\text{pop}}, a, a) \to (q_{\text{pop}}, \varepsilon) \), \( (q_{\text{pop}}, b, b) \to (q_{\text{pop}}, \varepsilon) \)
  - 입력 종료 + 스택 바닥:  
    \( (q_{\text{pop}}, \varepsilon, Z_0) \to (q_f, Z_0) \)

> 홀수 길이 팰린드롬 \( \{ w x w^R \}\) 은 **중앙 문자 하나**를 건너뛰는 ε-전이를 한 번 더 설계하면 된다.

### 4.3 균형 괄호 \( L_3 = \) well-formed parentheses

- '(' → push, ')' → pop  
- 입력 끝에 바닥만 남으면 수용. (DPDA로도 가능)

---

## 5. NPDA 시뮬레이터 (Python)

- **ε-전이 지원**
- **최종상태 수용**/ **빈 스택 수용** 모두 가능
- **구성 탐색**은 BFS로 하며 **방문 집합**으로 ε-loop 방지
- 스택은 **리스트 맨 오른쪽이 top**으로 구현

```python
# -*- coding: utf-8 -*-
from collections import defaultdict, deque
from typing import Dict, Tuple, List, Set, Optional

EPS = None  # ε을 None으로 표현

TransitionKey = Tuple[str, Optional[str], str]    # (state, symbol or None, stack_top)
TransitionVal = List[Tuple[str, List[str]]]       # [(next_state, push_list_top_last), ...]

class NPDA:
    def __init__(self,
                 states: Set[str],
                 input_alpha: Set[str],
                 stack_alpha: Set[str],
                 start_state: str,
                 start_stack: str,
                 finals: Set[str],
                 accept_by: str = "final"):  # "final" or "empty"
        self.Q = set(states)
        self.Sigma = set(input_alpha)
        self.Gamma = set(stack_alpha)
        self.q0 = start_state
        self.Z0 = start_stack
        self.F = set(finals)
        assert accept_by in ("final", "empty")
        self.accept_by = accept_by

        self.delta: Dict[TransitionKey, TransitionVal] = defaultdict(list)

    def add(self, q: str, a: Optional[str], X: str, p: str, gamma_push: List[str]):
        # gamma_push: pop X 후 push할 시퀀스 (리스트의 끝이 스택 top)
        assert q in self.Q and p in self.Q
        assert (a in self.Sigma) or (a is None)
        assert X in self.Gamma
        for s in gamma_push:
            assert s in self.Gamma
        self.delta[(q, a, X)].append((p, gamma_push))

    def _next_configs(self, q: str, i: int, stack: List[str], w: str) -> List[Tuple[str,int,List[str]]]:
        res = []
        if not stack:
            return res
        X = stack[-1]

        # 1) consume input symbol if possible
        if i < len(w):
            a = w[i]
            for (p, push_seq) in self.delta.get((q, a, X), []):
                new_stack = stack[:-1] + push_seq  # pop + push
                res.append((p, i+1, new_stack))

        # 2) epsilon transitions
        for (p, push_seq) in self.delta.get((q, EPS, X), []):
            new_stack = stack[:-1] + push_seq
            res.append((p, i, new_stack))
        return res

    def accepts(self, w: str, max_steps: int = 200000) -> bool:
        # BFS over configurations
        start = (self.q0, 0, [self.Z0])
        Q = deque([start])
        # visited uses (state, input_pos, stack_prefix_capped)
        # naive cap: keep last K of stack to avoid infinite variants (heuristic)
        K = 32
        visited: Set[Tuple[str,int,Tuple[str,...]]] = set()

        def cap_stack(stk: List[str]) -> Tuple[str,...]:
            return tuple(stk[-K:])

        visited.add((start[0], start[1], cap_stack(start[2])))

        steps = 0
        while Q:
            q, i, stack = Q.popleft()
            steps += 1
            if steps > max_steps:
                # 안전 차단(무한루프 방지); 필요시 늘리세요.
                return False

            end_of_input = (i == len(w))

            # Acceptance check
            if self.accept_by == "final":
                if end_of_input and q in self.F:
                    return True
            else:  # empty stack
                if end_of_input and len(stack) == 1 and stack[-1] == self.Z0:
                    # 바닥만 남는 것을 빈 스택 수용으로 간주(혹은 바닥까지 비우도록 정의해도 됨)
                    return True

            for cfg in self._next_configs(q, i, stack, w):
                t = (cfg[0], cfg[1], cap_stack(cfg[2]))
                if t not in visited:
                    visited.add(t)
                    Q.append(cfg)
        return False
```

---

## 6. 예제 1: \( \{a^n b^n\} \) NPDA 정의 & 테스트

**오토마타 구상(최종상태 수용)**  
- push 모드에서 \(a\)를 읽는 동안 \(A\) push  
- ε-전이로 pop 모드에 진입  
- pop 모드에서 \(b\) 하나를 읽을 때마다 \(A\) pop  
- 입력이 끝나고 스택 바닥이면 \(q_f\)로 ε-이동

```python
def make_anbn_npda_final() -> NPDA:
    states = {"qpush", "qpop", "qf"}
    Sigma  = {"a", "b"}
    Gamma  = {"A", "Z0"}
    M = NPDA(states, Sigma, Gamma, "qpush", "Z0", {"qf"}, accept_by="final")

    # push a's
    M.add("qpush", "a", "Z0", "qpush", ["A", "Z0"])
    M.add("qpush", "a", "A",  "qpush", ["A", "A"])

    # guess switch to pop-mode (epsilon)
    M.add("qpush", EPS, "Z0", "qpop", ["Z0"])
    M.add("qpush", "b", "A",  "qpop", [])  # 첫 b에서 pop모드로 넘어가며 pop

    # pop b's
    M.add("qpop", "b", "A", "qpop", [])

    # end: if input done and only Z0 remains → final
    M.add("qpop", EPS, "Z0", "qf", ["Z0"])
    return M

if __name__ == "__main__":
    M = make_anbn_npda_final()
    tests = ["", "ab", "aabb", "aaabbb", "aab", "abb", "aaabbbb"]
    for s in tests:
        print(s, "=>", M.accepts(s))
```

**결과 기대**  
- `""` : \(n=0\) 허용 → True  
- `"ab","aabb","aaabbb"` : True  
- `"aab","abb","aaabbbb"` : False

> 같은 언어를 **DPDA**로도 설계 가능(비결정성 없이 “영역 전환”을 상태로 결정).

---

## 7. 예제 2: \( \{ww^R\} \) (짝수 길이 팰린드롬) NPDA

**아이디어**:  
- push 모드에서 전반부를 push  
- **어느 시점이든 ε-전**으로 pop 모드 진입(가운데 경계 가정)  
- pop 모드에서는 입력 문자가 스택 top과 **일치**해야 pop

```python
def make_even_pal_npda() -> NPDA:
    states = {"qpush", "qpop", "qf"}
    Sigma  = {"a", "b"}
    Gamma  = {"a", "b", "Z0"}
    M = NPDA(states, Sigma, Gamma, "qpush", "Z0", {"qf"}, accept_by="final")

    # push-phase: push read symbol
    M.add("qpush", "a", "Z0", "qpush", ["a", "Z0"])
    M.add("qpush", "b", "Z0", "qpush", ["b", "Z0"])
    M.add("qpush", "a", "a",  "qpush", ["a", "a"])
    M.add("qpush", "b", "a",  "qpush", ["b", "a"])
    M.add("qpush", "a", "b",  "qpush", ["a", "b"])
    M.add("qpush", "b", "b",  "qpush", ["b", "b"])

    # guess middle (epsilon): switch to pop-phase
    M.add("qpush", EPS, "Z0", "qpop", ["Z0"])
    M.add("qpush", EPS, "a",  "qpop", ["a"])
    M.add("qpush", EPS, "b",  "qpop", ["b"])

    # pop-phase: must match
    M.add("qpop", "a", "a", "qpop", [])
    M.add("qpop", "b", "b", "qpop", [])

    # accept when input ends and only Z0 present
    M.add("qpop", EPS, "Z0", "qf", ["Z0"])
    return M

if __name__ == "__main__":
    M = make_even_pal_npda()
    tests = ["", "aa", "abba", "abab", "aba", "aabb"]
    for s in tests:
        print(s, "=>", M.accepts(s))
```

**결과 기대**  
- `""`, `"aa"`, `"abba"`: True (짝수 길이 팰린드롬)  
- `"abab"`: False (역순 아님)  
- `"aba"`: False (홀수 길이는 여기 정의에서 제외)  
- `"aabb"`: False

> **홀수 길이** \( \{w x w^R\} \)를 원하면, push→pop 전환 시 **한 글자를 건너뛰는 ε-전이**를 하나 더 넣으면 됨.

---

## 8. CFG ↔ NPDA 변환 (개요)

### 8.1 CFG → NPDA (표준 Top-Down 시뮬레이션)

- 스택에 **시작기호 \(S\)** push  
- 반복:  
  - 스택 top이 **비터미널 \(A\)**이면, **임의의 규칙** \(A\to \alpha\)를 선택해 \(A\)를 pop하고 \(\alpha\)를 **역순으로 push**  
  - 스택 top이 **터미널 \(a\)**이면, 입력 다음 문자가 \(a\)인지 확인 후 **소비** + pop  
- 입력/스택 동시 소진 → 수용

> 이 방식은 규칙 선택에서 **비결정성**을 사용하므로 **NPDA**로 자연스럽게 구현 가능.

### 8.2 NPDA → CFG (요지)

- 상태쌍/스택기호를 추상화한 변수를 도입하는 전형적 구성  
  - 예: \(V_{pXq}\): 상태 \(p\)에서 스택 \(X\)를 결국 “잘 소거”하여 상태 \(q\)로 갈 수 있음을 의미  
- PDA 전이를 문법 규칙으로 풀어 써서 **동치 CFG**를 얻는다.

> 실제 구현은 다소 장황하므로 여기서는 스케치만.

---

## 9. NPDA 관련 결정 문제/폐포성 (간단)

- **멤버십**(입력 \(w\)가 인식되는가?): 결정 가능(문법으로 바꿔 **CYK** \(O(n^3)\) 등)  
- **공허성**(언어가 공집합인가?): CFG로 변환해 도달/생성성 검사로 결정 가능  
- CFL은 **합집합, 연결, Kleene*에 대해 폐포**.  
- **교집합/여집합에 대해서는 폐포가 아님**(단, **정규언어와의 교집합**은 폐포).

---

## 10. 실패 사례: \( \{a^n b^n c^n\} \) (비-CFL)

- **직관**: 하나의 스택으로 **세 구간의 동일 개수**를 동시에 강제하기 어렵다.  
- **증명**: CFL 펌핑 보조정리/오그던 보조정리로 비정규성보다 까다로운 비-CFL 증명을 수행.

---

## 11. 실전 팁

- **DPDA로도 충분**한 설계(식별 가능한 영역 전환, 문법이 LL/LR인 경우)가 많음.  
- **NPDA 시뮬레이션**은 상태폭발을 부르므로,  
  - ε-폐쇄를 빠르게,  
  - 방문 집합/깊이 제한/휴리스틱(스택 캡) 등으로 **탐색 제어**.  
- 학습/검증 단계에서는 **CFG→CNF→CYK**로 멤버십을 확인하는 것도 좋다.

---

## 12. 빠른 테스트 스크립트 (종합)

```python
if __name__ == "__main__":
    print("=== L1 = { a^n b^n } ===")
    M1 = make_anbn_npda_final()
    for s in ["", "ab", "aabb", "aaabbb", "aab", "abb", "aaabbbb"]:
        print(f"{s!r} -> {M1.accepts(s)}")

    print("\n=== L2 = { ww^R } (even length) ===")
    M2 = make_even_pal_npda()
    for s in ["", "aa", "abba", "abab", "aba", "aabb", "baab", "bbaa"]:
        print(f"{s!r} -> {M2.accepts(s)}")
```

---

## 마무리 정리

- **NPDA = CFL 인식기**: CFG와 **언어적으로 동치**  
- **비결정성**은 “중간 경계 추측, 규칙 선택” 같은 본질적 작업을 쉽게 만든다  
- **DPDA**는 더 제한적(DCFL)  
- 예제/구현을 통해 **스택 조작**과 **수용 조건**을 손에 익히면,  
  파서/컴파일러 이론과 실무(LL/LR, Earley, CYK)로 자연스럽게 이어진다.