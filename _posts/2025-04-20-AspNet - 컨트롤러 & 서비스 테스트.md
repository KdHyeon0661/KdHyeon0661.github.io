---
layout: post
title: AspNet - 컨트롤러 & 서비스 테스트
date: 2025-04-10 21:20:23 +0900
category: AspNet
---
# ASP.NET Core 컨트롤러 & 서비스 테스트

## 0. 테스트 전략 큰 그림

| 레벨 | 질문 | 도구/기술 | 핵심 포인트 |
|---|---|---|---|
| 서비스 단위(Unit) | “비즈니스 규칙이 맞나?” | xUnit, FluentAssertions | 외부 의존성 제거(순수 함수/POCO 우선) |
| 컨트롤러 단위(Unit) | “API 응답이 올바른가?” | Moq, xUnit | 서비스/저장소를 Mock 주입 |
| 통합(End-to-End) | “실제 요청-응답이 기대대로 도는가?” | WebApplicationFactory, TestServer, EF InMemory | 라우팅/모델바인딩/필터/미들웨어/인증 포함 |

> 경험칙
> - **핵심 도메인 규칙**은 “서비스 단위 테스트”로 빠르고 견고하게 커버
> - **계약(응답 모양/상태 코드)**은 컨트롤러 단위 테스트로 가볍게 검증
> - **경로/미들웨어/권한**은 통합 테스트로 최종 보증

---

## 1. 서비스 단위 테스트 (순수 로직 우선)

### 1.1 예시 도메인/서비스

```csharp
public interface IUserService
{
    string GetUserName(int userId);
    decimal ApplyDiscount(decimal price, string grade);
}

public sealed class UserService : IUserService
{
    public string GetUserName(int userId)
    {
        if (userId <= 0) throw new ArgumentException("Invalid ID", nameof(userId));
        return $"User_{userId}";
    }

    public decimal ApplyDiscount(decimal price, string grade)
    {
        if (price < 0) throw new ArgumentOutOfRangeException(nameof(price));
        return grade switch
        {
            "VIP" => Math.Round(price * 0.8m, 2),
            "GOLD" => Math.Round(price * 0.9m, 2),
            _ => price
        };
    }
}
```

### 1.2 xUnit + FluentAssertions로 단정 가독성 높이기

```csharp
public sealed class UserServiceTests
{
    private readonly IUserService _sut = new UserService();

    [Theory]
    [InlineData(1, "User_1")]
    [InlineData(42, "User_42")]
    public void GetUserName_Should_Return_Formatted(int id, string expected)
    {
        var name = _sut.GetUserName(id);
        name.Should().Be(expected);
    }

    [Fact]
    public void GetUserName_InvalidId_Should_Throw()
    {
        Action act = () => _sut.GetUserName(0);
        act.Should().Throw<ArgumentException>()
           .WithParameterName("userId");
    }

    [Theory]
    [InlineData(100, "VIP", 80)]
    [InlineData(100, "GOLD", 90)]
    [InlineData(100, "NONE", 100)]
    public void ApplyDiscount_Should_Compute(decimal price, string grade, decimal expected)
    {
        _sut.ApplyDiscount(price, grade).Should().Be(expected);
    }
}
```

> 팁
> - **FluentAssertions**는 실패 메시지가 읽기 좋아 유지보수에 유리
> - **Theory**로 입력 조합을 빠르게 늘려 회귀 방지

### 1.3 Bogus/AutoFixture로 테스트 데이터 자동 생성

```csharp
using AutoFixture;
using Bogus;

public sealed class DataGenTests
{
    [Fact]
    public void Faker_Should_Create_Usernames()
    {
        var faker = new Faker();
        var name = faker.Internet.UserName();
        name.Should().NotBeNullOrWhiteSpace();
    }

    [Fact]
    public void AutoFixture_Should_Build_Pojo()
    {
        var fixture = new Fixture();
        var dto = fixture.Build<(int Id, string Name)>()
                         .With(x => x.Id, 10)
                         .Create();
        dto.Id.Should().Be(10);
        dto.Name.Should().NotBeNull();
    }
}
```

---

## 2. 컨트롤러 단위 테스트 — Moq로 의존성 격리

### 2.1 간단 컨트롤러

```csharp
[ApiController]
[Route("api/[controller]")]
public sealed class UserController : ControllerBase
{
    private readonly IUserService _service;
    public UserController(IUserService service) => _service = service;

    [HttpGet("{id:int}")]
    public IActionResult GetUserName(int id)
    {
        try
        {
            var name = _service.GetUserName(id);
            return Ok(new { name });
        }
        catch (ArgumentException)
        {
            return BadRequest("잘못된 사용자 ID입니다.");
        }
    }

    [HttpGet("{id:int}/discount")]
    public IActionResult GetPrice([FromQuery] decimal price, int id, [FromQuery] string grade = "NONE")
    {
        var discounted = _service.ApplyDiscount(price, grade);
        return Ok(new { id, price, grade, discounted });
    }
}
```

### 2.2 Moq로 서비스 모킹 + 응답 검증

```csharp
using Moq;
using Microsoft.AspNetCore.Mvc;

public sealed class UserControllerTests
{
    private readonly Mock<IUserService> _mock = new();
    private readonly UserController _sut;

    public UserControllerTests()
    {
        _sut = new UserController(_mock.Object);
    }

    [Fact]
    public void GetUserName_Valid_Should_Return_Ok()
    {
        _mock.Setup(s => s.GetUserName(1)).Returns("User_1");

        var result = _sut.GetUserName(1) as OkObjectResult;

        result.Should().NotBeNull();
        result!.StatusCode.Should().Be(200);
        result.Value.Should().BeEquivalentTo(new { name = "User_1" });
        _mock.Verify(s => s.GetUserName(1), Times.Once);
    }

    [Fact]
    public void GetUserName_Invalid_Should_Return_BadRequest()
    {
        _mock.Setup(s => s.GetUserName(0)).Throws<ArgumentException>();

        var result = _sut.GetUserName(0) as BadRequestObjectResult;

        result.Should().NotBeNull();
        result!.StatusCode.Should().Be(400);
        (result.Value as string).Should().Contain("잘못된");
        _mock.Verify(s => s.GetUserName(0), Times.Once);
    }

    [Fact]
    public void GetPrice_Should_Return_Discounted()
    {
        _mock.Setup(s => s.ApplyDiscount(100, "VIP")).Returns(80);
        var res = _sut.GetPrice(100, 3, "VIP") as OkObjectResult;

        res.Should().NotBeNull();
        res!.Value.Should().BeEquivalentTo(new { id = 3, price = 100m, grade = "VIP", discounted = 80m });
    }
}
```

> 체크리스트
> - **예외 → 상태 코드 매핑**을 테스트한다(도메인 예외가 컨트롤러에서 어떻게 변환되는지)
> - `Verify`로 **호출 횟수/조건**을 검증하여 “진짜 호출됐는지” 보장

---

## 3. 통합 테스트 — WebApplicationFactory로 E2E

### 3.1 프로젝트 구성 힌트

```
MyApp/          # ASP.NET Core 앱(Program.cs, Controllers, Services)
MyApp.Tests/    # xUnit 테스트
```

### 3.2 간단 API(실행용) — Program.cs (예시)

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();

// 예: 운영에선 DB/외부 의존성, 테스트에선 대체할 것
builder.Services.AddSingleton<IUserService, UserService>();

var app = builder.Build();
app.MapControllers();
app.Run();

public partial class Program {} // 테스트에서 TEntryPoint로 인식
```

### 3.3 통합 테스트 기본형

```csharp
using System.Net;
using Microsoft.AspNetCore.Mvc.Testing;

public sealed class UserIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;

    public UserIntegrationTests(WebApplicationFactory<Program> factory)
        => _client = factory.CreateClient();

    [Fact]
    public async Task GetUserName_Should_OK()
    {
        var res = await _client.GetAsync("/api/user/1");
        res.StatusCode.Should().Be(HttpStatusCode.OK);
        var json = await res.Content.ReadAsStringAsync();
        json.Should().Contain("User_1");
    }
}
```

### 3.4 DI 재정의(테스트 전용 스텁/모킹 교체)

```csharp
public sealed class CustomWebAppFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(services =>
        {
            var descriptor = services.Single(x => x.ServiceType == typeof(IUserService));
            services.Remove(descriptor);
            services.AddSingleton<IUserService>(new FakeUserService());
        });
    }

    private sealed class FakeUserService : IUserService
    {
        public decimal ApplyDiscount(decimal price, string grade) => 1m;
        public string GetUserName(int userId) => "Fake";
    }
}

public sealed class SwapDiIntegrationTests : IClassFixture<CustomWebAppFactory>
{
    private readonly HttpClient _client;
    public SwapDiIntegrationTests(CustomWebAppFactory f) => _client = f.CreateClient();

    [Fact]
    public async Task Should_Use_Fake_Service()
    {
        var res = await _client.GetAsync("/api/user/123");
        var s = await res.Content.ReadAsStringAsync();
        s.Should().Contain("Fake");
    }
}
```

> 포인트
> - 운영의 무거운 의존성(실DB/메시지브로커)을 **테스트 대체 구현**으로 교체
> - `ConfigureWebHost`에서 `services.Remove` → `AddSingleton` 패턴이 표준

---

## 4. EF Core InMemory/Sqlite로 데이터 계층 테스트

### 4.1 간단한 Repository + DbContext

```csharp
public sealed class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> opt) : base(opt) { }
    public DbSet<UserEntity> Users => Set<UserEntity>();
}

public sealed class UserEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = "";
}

public interface IUserRepository
{
    Task<UserEntity?> FindAsync(int id);
}

public sealed class UserRepository : IUserRepository
{
    private readonly AppDbContext _db;
    public UserRepository(AppDbContext db) => _db = db;
    public Task<UserEntity?> FindAsync(int id) => _db.Users.FindAsync(id).AsTask();
}
```

### 4.2 InMemory 테스트(빠름, 제약 많음)

```csharp
public sealed class RepoTests
{
    private static AppDbContext CreateContext()
    {
        var opt = new DbContextOptionsBuilder<AppDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
        var db = new AppDbContext(opt);
        db.Users.Add(new UserEntity { Id = 1, Name = "Alice" });
        db.SaveChanges();
        return db;
    }

    [Fact]
    public async Task FindAsync_Should_Return_User()
    {
        await using var db = CreateContext();
        var repo = new UserRepository(db);

        var u = await repo.FindAsync(1);
        u.Should().NotBeNull();
        u!.Name.Should().Be("Alice");
    }
}
```

> 주의: InMemory는 **관계형 제약/동작**이 실제와 다를 수 있음(쿼리 최적화/동작 차이). 더 현실성 필요 시 **Sqlite In-Memory** 추천.

### 4.3 Sqlite In-Memory(현실성↑)

```csharp
using Microsoft.Data.Sqlite;

public sealed class SqliteRepoTests
{
    [Fact]
    public async Task Sqlite_InMemory_Should_Act_Like_Rdbms()
    {
        var conn = new SqliteConnection("Filename=:memory:");
        await conn.OpenAsync();

        var opt = new DbContextOptionsBuilder<AppDbContext>()
            .UseSqlite(conn)
            .Options;

        await using (var db = new AppDbContext(opt))
        {
            await db.Database.EnsureCreatedAsync();
            db.Users.Add(new UserEntity { Id = 1, Name = "Bob" });
            await db.SaveChangesAsync();
        }

        await using (var db = new AppDbContext(opt))
        {
            var repo = new UserRepository(db);
            var u = await repo.FindAsync(1);
            u!.Name.Should().Be("Bob");
        }
    }
}
```

---

## 5. 컨트롤러 + 필터 + ProblemDetails + 모델 검증

### 5.1 모델 & 검증

```csharp
public sealed class CreateUserDto
{
    [Required, StringLength(50)]
    public string Name { get; set; } = "";
}
```

### 5.2 자동 400/ProblemDetails 활성화 (`[ApiController]`)

```csharp
[ApiController]
[Route("api/users")]
public sealed class UsersController : ControllerBase
{
    [HttpPost]
    public IActionResult Create([FromBody] CreateUserDto dto)
    {
        // 유효성 실패 시 자동 400 + RFC7807 ProblemDetails
        return Created($"/api/users/1", new { id = 1, name = dto.Name });
    }
}
```

### 5.3 통합 테스트로 검증

```csharp
public sealed class ValidationIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public ValidationIntegrationTests(WebApplicationFactory<Program> f) => _client = f.CreateClient();

    [Fact]
    public async Task Post_Invalid_Should_Return_400_ProblemDetails()
    {
        var res = await _client.PostAsJsonAsync("/api/users", new { Name = "" });
        res.StatusCode.Should().Be(HttpStatusCode.BadRequest);
        var json = await res.Content.ReadAsStringAsync();
        json.Should().Contain("title").And.Contain("errors");
    }
}
```

---

## 6. 인증/권한 포함 테스트 (쿠키/JWT)

### 6.1 테스트 인증 핸들러(가짜 사용자)

```csharp
using Microsoft.AspNetCore.Authentication;
using System.Security.Claims;
using System.Text.Encodings.Web;

public sealed class TestAuthHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    public const string Scheme = "TestScheme";
    public TestAuthHandler(
        IOptionsMonitor<AuthenticationSchemeOptions> options,
        ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock)
        : base(options, logger, encoder, clock) { }

    protected override Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var identity = new ClaimsIdentity(new[] {
            new Claim(ClaimTypes.Name, "test-user"),
            new Claim(ClaimTypes.Role, "Admin")
        }, Scheme);

        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, Scheme);
        return Task.FromResult(AuthenticateResult.Success(ticket));
    }
}
```

### 6.2 앱에 테스트 스키마 삽입

```csharp
// Program.cs (테스트 전용 환경에서만)
builder.Services.AddAuthentication(TestAuthHandler.Scheme)
    .AddScheme<AuthenticationSchemeOptions, TestAuthHandler>(TestAuthHandler.Scheme, null);
```

### 6.3 권한 보호 컨트롤러

```csharp
[Authorize(Roles = "Admin", AuthenticationSchemes = TestAuthHandler.Scheme)]
[ApiController, Route("api/secure")]
public sealed class SecureController : ControllerBase
{
    [HttpGet]
    public IActionResult Get() => Ok(new { user = User.Identity!.Name, ok = true });
}
```

### 6.4 통합 테스트(권한)

```csharp
public sealed class AuthIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public AuthIntegrationTests(WebApplicationFactory<Program> f) => _client = f.CreateClient();

    [Fact]
    public async Task Authorized_Should_OK()
    {
        var res = await _client.GetAsync("/api/secure");
        res.StatusCode.Should().Be(HttpStatusCode.OK);
    }
}
```

> 주의: 실제 JWT/Cookie 미들웨어를 통과시키려면 해당 스키마 구성과 헤더/쿠키 주입이 필요. 위 예시는 **테스트 전용 인증 스키마**로 간단히 권한 경로를 검증한다.

---

## 7. 미들웨어/필터 테스트

### 7.1 전역 예외 미들웨어(간단)

```csharp
public sealed class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _log;

    public GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> log)
    {
        _next = next; _log = log;
    }

    public async Task InvokeAsync(HttpContext ctx)
    {
        try { await _next(ctx); }
        catch (Exception ex)
        {
            _log.LogError(ex, "Unhandled");
            ctx.Response.StatusCode = StatusCodes.Status500InternalServerError;
            await ctx.Response.WriteAsJsonAsync(new { message = "server error" });
        }
    }
}
```

등록:

```csharp
app.UseMiddleware<GlobalExceptionMiddleware>();
```

### 7.2 통합 테스트로 확인

```csharp
public sealed class MiddlewareIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public MiddlewareIntegrationTests(WebApplicationFactory<Program> f) => _client = f.CreateClient();

    [Fact]
    public async Task When_Exception_Should_Return_500_Json()
    {
        var res = await _client.GetAsync("/api/throw"); // 일부러 예외 던지는 경로 준비
        res.StatusCode.Should().Be(HttpStatusCode.InternalServerError);
        var s = await res.Content.ReadAsStringAsync();
        s.Should().Contain("server error");
    }
}
```

---

## 8. 설정 주입(IOptions) 테스트

### 8.1 옵션 객체/서비스

```csharp
public sealed class FeatureOptions
{
    public bool Enabled { get; set; }
}

public sealed class FeatureService
{
    private readonly IOptions<FeatureOptions> _opt;
    public FeatureService(IOptions<FeatureOptions> opt) => _opt = opt;
    public bool IsEnabled() => _opt.Value.Enabled;
}
```

### 8.2 단위 테스트(직접 옵션 인스턴스 구성)

```csharp
using Microsoft.Extensions.Options;

public sealed class FeatureServiceTests
{
    [Fact]
    public void IsEnabled_Should_Reflect_Options()
    {
        var options = Options.Create(new FeatureOptions { Enabled = true });
        var svc = new FeatureService(options);
        svc.IsEnabled().Should().BeTrue();
    }
}
```

### 8.3 통합 테스트(환경 변수/환경별 appsettings로 교체)

- `WebApplicationFactory`에서 `ConfigureAppConfiguration`를 이용해 테스트용 설정 주입
- 또는 `appsettings.Test.json` 파일을 추가하고 테스트 시 로드

---

## 9. 테스트 구성 확장 — Fixtures/Collection Fixtures

### 9.1 클래스 Fixture (`IDisposable`)

```csharp
public sealed class DbFixture : IDisposable
{
    public AppDbContext Context { get; }

    public DbFixture()
    {
        var opt = new DbContextOptionsBuilder<AppDbContext>()
            .UseInMemoryDatabase("shared")
            .Options;
        Context = new AppDbContext(opt);
        Context.Users.Add(new UserEntity { Id = 100, Name = "Seed" });
        Context.SaveChanges();
    }

    public void Dispose() => Context.Dispose();
}

public sealed class UsingDbFixtureTests : IClassFixture<DbFixture>
{
    private readonly DbFixture _fx;
    public UsingDbFixtureTests(DbFixture fx) => _fx = fx;

    [Fact]
    public void Seed_Should_Exist()
    {
        _fx.Context.Users.Find(100)!.Name.Should().Be("Seed");
    }
}
```

### 9.2 컬렉션 Fixture(여러 테스트 클래스 공유)

```csharp
[CollectionDefinition("db-collection")]
public sealed class DbCollection : ICollectionFixture<DbFixture> {}

[Collection("db-collection")]
public sealed class AnotherTest
{
    private readonly DbFixture _fx;
    public AnotherTest(DbFixture fx) => _fx = fx;

    [Fact]
    public void Shared_Db_Should_Work()
    {
        _fx.Context.Users.Any().Should().BeTrue();
    }
}
```

---

## 10. 테스트 이름/구조/패턴

- **이름 규칙**: `MethodName_Scenario_ExpectedBehavior`
  예: `GetUserName_InvalidId_Should_Throw`
- **AAA 패턴**: Arrange → Act → Assert
- **SRP**: 테스트는 한 가지 검증에 집중(여러 Assertions 가능하되, 한 시나리오)
- **독립성**: 테스트 간 상태 공유 금지(공유 시 Fixture로 통제)
- **속도**: 단위 테스트는 빠르게(100ms 내), 느린 I/O는 통합으로 한정

---

## 11. 성능/안정성/운영 실무 팁

- **고립성**: 단위 테스트에서 네트워크/파일/DB 금지(인터페이스화 후 Mock/Fake)
- **동시성**: 병렬 실행 시 상태 충돌 주의(InMemory DB 이름 랜덤화)
- **회귀 방지**: Bug 재현 테스트 추가(실패 케이스를 먼저 작성)
- **커버리지**: Coverlet로 측정, “수치”보단 **중요 경로/에러 처리**를 커버
- **로깅 캡처**: `ILogger<T>`를 Moq로 Verify하거나 `Serilog.Sinks.InMemory`로 수집
- **문서화**: 통합 테스트는 **API 계약의 산 증인**(예상 응답 구조 명시)

---

## 12. Minimal API/Endpoint 테스트(선택)

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/hello/{name}", (string name) => Results.Ok(new { greet = $"Hello, {name}" }));
app.Run();

public partial class Program {}
```

통합 테스트:

```csharp
public sealed class MinimalApiTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public MinimalApiTests(WebApplicationFactory<Program> f) => _client = f.CreateClient();

    [Fact]
    public async Task Hello_Should_Respond_Json()
    {
        var res = await _client.GetAsync("/hello/Alice");
        res.EnsureSuccessStatusCode();
        var json = await res.Content.ReadAsStringAsync();
        json.Should().Contain("Hello, Alice");
    }
}
```

---

## 13. 컨트롤러 필터/액션 필터 테스트

### 13.1 권한/검증/로깅 필터 예

```csharp
public sealed class HeaderRequiredAttribute : ActionFilterAttribute
{
    private readonly string _header;
    public HeaderRequiredAttribute(string header) => _header = header;

    public override void OnActionExecuting(ActionExecutingContext context)
    {
        if (!context.HttpContext.Request.Headers.ContainsKey(_header))
        {
            context.Result = new BadRequestObjectResult($"Missing header: {_header}");
        }
        base.OnActionExecuting(context);
    }
}

[ApiController, Route("api/h")]
public sealed class HeaderController : ControllerBase
{
    [HttpGet, HeaderRequired("X-Req-Id")]
    public IActionResult Get() => Ok("done");
}
```

통합 테스트:

```csharp
public sealed class FilterIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public FilterIntegrationTests(WebApplicationFactory<Program> f) => _client = f.CreateClient();

    [Fact]
    public async Task Missing_Header_Should_400()
    {
        var res = await _client.GetAsync("/api/h");
        res.StatusCode.Should().Be(HttpStatusCode.BadRequest);
    }

    [Fact]
    public async Task With_Header_Should_Ok()
    {
        var req = new HttpRequestMessage(HttpMethod.Get, "/api/h");
        req.Headers.Add("X-Req-Id", "abc");
        var res = await _client.SendAsync(req);
        res.StatusCode.Should().Be(HttpStatusCode.OK);
    }
}
```

---

## 14. 문제상황과 해법 요약

| 문제 | 원인 | 해법 |
|---|---|---|
| 컨트롤러 테스트에서 모델 바인딩이 안 됨 | 단위 테스트는 바인딩/필터 미동작 | **통합 테스트**로 검증 |
| InMemory DB와 실DB 차이 | InMemory는 제약/거래 동작 상이 | Sqlite In-Memory 또는 Testcontainers |
| 인증 경로 실패 | 실제 스키마/토큰 필요 | **테스트 인증 핸들러**로 단순화 |
| 느린 통합 테스트 | 실 의존성/네트워크 | DI 교체(페이크/스텁), 필요한 경로만 검증 |
| 무의미한 Mock 남발 | 내부 구현 검증 | **계약 중심**으로 상태 코드/응답 모델만 검증 |

---

## 15. 최종 체크리스트

- [ ] 서비스 단위 테스트: 예외/경계조건 포함
- [ ] 컨트롤러 단위 테스트: 성공/실패/예외 매핑 검증, Moq Verify
- [ ] 통합 테스트: 라우팅/모델검증/필터/미들웨어/권한/ProblemDetails
- [ ] 데이터 계층: InMemory/Sqlite로 빠르게, 필요시 Testcontainers
- [ ] 설정/옵션: IOptions 테스트 포함
- [ ] 인증/권한: 테스트 스키마로 보호 경로 보증
- [ ] 성능/안정성: 병렬 충돌/공유 상태 제거
- [ ] 명명/구조: AAA, 시나리오 명확화, 실패 메시지 가독성

---

## 부록 A) 패키지 모음

```bash
dotnet add <test-project>.csproj package xunit
dotnet add <test-project>.csproj package xunit.runner.visualstudio
dotnet add <test-project>.csproj package FluentAssertions
dotnet add <test-project>.csproj package Moq
dotnet add <test-project>.csproj package Bogus
dotnet add <test-project>.csproj package AutoFixture
dotnet add <test-project>.csproj package Microsoft.AspNetCore.Mvc.Testing
dotnet add <test-project>.csproj package Microsoft.EntityFrameworkCore.InMemory
dotnet add <test-project>.csproj package Microsoft.EntityFrameworkCore.Sqlite
```

---

## 결론

- **서비스 단위 테스트**로 도메인 규칙을 빠르게 고정하고,
- **컨트롤러 단위 테스트**로 API 계약을 가볍게 검증하며,
- **통합 테스트**로 실제 실행 경로(라우팅/검증/필터/권한/미들웨어)를 보증하라.

이 삼각 편대가 있으면, 리팩터링·새 기능 추가·보안/검증 강화에도 **안전한 속도**를 유지할 수 있다.
