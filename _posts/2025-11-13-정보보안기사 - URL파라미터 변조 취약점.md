---
layout: post
title: 정보보안기사 - URL/파라미터 변조 취약점
date: 2025-11-13 10:25:23 +0900
category: 정보보안기사
---
# 완전 정리

## 개요 — “사용자 입력이 ‘권한·리소스·가격’을 바꾸는 순간”

**URL/파라미터 변조(Parameter Tampering)**는 클라이언트가 **URL 쿼리·경로 변수·POST/JSON 바디·쿠키·헤더·숨김필드** 등의 값을 고쳐서 **권한이 없는 리소스 접근**, **가격/수량/할인 조작**, **역할(권한) 상승**, **흐름 우회** 등을 유발하는 취약점이다. 대표 유형은 다음과 같다.

- **IDOR/BOLA**: `/users/123`를 `/users/124`로 바꿔 타인의 데이터를 열람/수정
- **Business Logic Tampering**: `price=100` → `price=1`, `discount=100`, `role=admin`
- **Mass Assignment(과다 바인딩)**: JSON 바디에 `isAdmin:true` 필드 주입
- **HTTP Parameter Pollution(HPP)**: `amount=1&amount=999`처럼 **같은 이름**을 여러 번
- **Open Redirect**: `returnUrl=https://evil.com` 변조로 리디렉션 악용
- **Method Override**: `_method=DELETE` 등으로 의도치 않은 메소드 수행
- **Session/Flow Param**: `sessionid`를 URL로 받아 세션 고정·가로채기
- **Locale/Feature Flags/Hidden Fields** 조작으로 보안 경계 우회

핵심 원칙: **“클라이언트 입력은 절대 신뢰하지 않는다.”**
권한·가격·소유·상태와 같은 **보안/비즈니스 결정값은 서버가 계산/검증**해야 한다.

---

## 위협 모델과 분류

| 분류 | 예시 | 전형적 영향 |
|---|---|---|
| IDOR/BOLA | `/api/order/1001` → `1002` | 타인 주문 조회/수정 |
| 가격/수량 조작 | `price=1000` → `1`, `qty=1` → `999` | 재무 손실, 재고 교란 |
| 권한 플래그 조작 | `role=user` → `admin` | 권한 상승 |
| Mass Assignment | JSON Body에 `isVip:true`, `balance:999999` | 임의 필드 오염 |
| HPP | `coupon=A&coupon=B` | 우선순위/병합 혼선 악용 |
| Open Redirect | `returnUrl=https://evil.com` | 피싱/토큰 탈취 체인 |
| Method Override | `_method=DELETE` | 데이터 삭제, 설정 변경 |
| 세션/흐름 파라미터 | `sid=...`, `step=3` | 인증 우회, 세션 고정 |

---

## 필수 개념 요약

- **인증 vs 인가**: 로그인(인증)만 확인하고 **소유/역할/테넌트 인가**를 안 하면 **IDOR/BOLA**
- **서버 기준 진실(SoT)**: 금액/할인/배송비/재고는 **서버에서 산정**하고 **클라이언트 값 무시**
- **화이트리스트 바인딩**: 모델 자동 바인딩 시 **허용 필드만** 맵핑(과다 바인딩 방지)
- **정형/스키마 검증**: 타입·범위·허용값·포맷을 **서버에서** 검증
- **정규화/대조**: 정규화된 파라미터를 **서버의 정책(소유/조직/테넌트)**과 대조
- **일관 파싱**: **중복 파라미터(HPP)**, 배열·객체 파라미터를 “한 가지 방식”으로만 해석
- **서명/무결성**: 불가피한 클라이언트 상태는 **서명 토큰(HMAC, 만료/Nonce)** 으로 보호
- **로깅/모니터링**: 실패 사유·정규화 결과·역할/테넌트 컨텍스트를 함께 기록

---

## 실전 시나리오 1 — IDOR/BOLA (객체 레벨 인가 실패)

### 취약 예 (Node/Express)

```js
// 공격자: /api/users/124 로 바꾸면 타인의 정보 열람 가능
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id); // ❌ 소유/테넌트 확인 없음
  if (!user) return res.sendStatus(404);
  res.json(user); // 민감정보 노출
});
```

### 안전 패턴 (소유/테넌트 인가 + 최소 노출)

```js
app.get('/api/users/:id', async (req, res) => {
  const caller = req.user; // 미들웨어에서 인증된 주체(tenantId/roles 포함)
  const user = await db.users.findOne({ _id: req.params.id, tenantId: caller.tenantId }); // ✅ 테넌트 경계
  if (!user) return res.sendStatus(404);
  if (user._id.toString() !== caller.userId && !caller.roles.includes('Admin')) {
    return res.sendStatus(403); // ✅ 소유/역할 인가
  }
  const safe = pick(user, ['id','name','email']); // ✅ 최소 필드
  res.json(safe);
});
```

### 예 (EF Core)

```csharp
// DbContext OnModelCreating
modelBuilder.Entity<Order>()
  .HasQueryFilter(o => o.TenantId == _tenantContext.TenantId); // ✅ 전역 테넌트 필터
```

---

## 실전 시나리오 2 — 가격/수량/할인 조작

### 취약 예 (서버가 클라 값을 신뢰)

```js
// /checkout?price=1000&discount=100
app.post('/checkout', async (req, res) => {
  const { items, price, discount } = req.body; // ❌ 신뢰
  const total = price - discount;              // ❌ 조작 가능
  await charge(req.user, total);
  res.json({ ok: true, total });
});
```

### 안전 패턴 (서버 계산, 클라 값 무시)

```js
app.post('/checkout', async (req, res) => {
  const caller = req.user;
  const items = validateItems(req.body.items);        // ✅ 스키마 검증
  const catalog = await db.products.findManyByIds(items.map(i=>i.id));
  const pricing = priceEngine.quote(catalog, items, caller.segment); // ✅ 서버 산정

  // 세금·배송·쿠폰·프로모션도 서버 규칙으로
  const total = pricing.subtotal + pricing.tax + pricing.shipping - pricing.promo;

  await payment.charge(caller.customerId, total, { currency: 'KRW' });
  res.json({ ok: true, total, breakdown: pricing });
});
```

수식 관점(서버 산정의 원칙):
$$
\textstyle T = \sum_i p_i^{(server)} \cdot q_i\;+\;\text{tax}^{(server)}\;+\;\text{shipping}^{(server)}\;-\;\text{promo}^{(server)}
$$
클라이언트가 제출한 \(p_i\)·할인값은 **무시**하고 서버에서 결정한다.

---

## 실전 시나리오 3 — 권한 플래그/역할 조작 + Mass Assignment

### 취약 예 (과다 바인딩)

```js
// Mongoose/Sequelize 등: req.body 전체를 모델에 머지하면 위험
app.post('/api/profile', async (req, res) => {
  const user = await db.users.findByPk(req.user.id);
  Object.assign(user, req.body);   // ❌ isAdmin, balance 등 민감 필드 주입 위험
  await user.save();
  res.json(user);
});
```

### 안전 패턴 (허용 필드 화이트리스트)

```js
const ALLOWED = ['displayName','phone','avatarUrl'];
app.post('/api/profile', async (req, res) => {
  const user = await db.users.findByPk(req.user.id);
  for (const k of Object.keys(req.body)) {
    if (!ALLOWED.includes(k)) continue;       // ✅ 허용된 필드만
    user[k] = req.body[k];
  }
  await user.save();
  res.json(pick(user, ['id','displayName','phone','avatarUrl']));
});
```

### .NET (과다 바인딩 방지)

```csharp
public class ProfileUpdateDto {
  public string DisplayName { get; set; }
  public string Phone { get; set; }
  [BindNever] public bool IsAdmin { get; set; } // ❌ 클라에서 못 바꿈
}

[HttpPost("profile")]
public IActionResult Update([FromBody] ProfileUpdateDto dto) { ... } // ✅ DTO로 제한
```

### Spring Boot (Jackson/Validator)

```java
@JsonIgnoreProperties(ignoreUnknown = true) // ✅ 알 수 없는 필드 무시
class ProfileDto {
  @NotBlank String displayName;
  @Pattern(regexp="^\\+?[0-9]{8,15}$") String phone;
  @JsonIgnore Boolean isAdmin; // ✅ 무시
}
```

---

## 실전 시나리오 4 — Open Redirect

### 취약 예

```js
app.get('/login/callback', (req, res) => {
  // 로그인 후 돌아갈 URL
  res.redirect(req.query.returnUrl); // ❌ 외부 도메인 허용
});
```

### 방어 (동일 오리진·화이트리스트·상대경로만)

```js
const ALLOW = new Set(['/dashboard','/orders','/']);
app.get('/login/callback', (req, res) => {
  const u = String(req.query.returnUrl || '/');
  const url = new URL(u, 'https://example.com');     // 기준 오리진 결합
  if (url.origin !== 'https://example.com') return res.redirect('/');
  if (!ALLOW.has(url.pathname)) return res.redirect('/');
  res.redirect(url.pathname + url.search);
});
```

---

## 실전 시나리오 5 — HTTP Parameter Pollution(HPP)

- **문제**: `?role=user&role=admin` 같이 **중복 키**가 들어오면, 프레임워크마다 **첫 값/마지막 값/배열** 처리 방식이 다름 → 우회 여지
- **위험**: WAF/프록시·백엔드가 **다르게 파싱**하면 정책 우회

### 안전 파서(한 가지 규칙으로 고정)

```js
function parseOnce(req) {
  // 마지막 값만 허용(또는 첫 값만 허용) 같은 단일 규칙 고정
  const out = {};
  for (const [k, v] of Object.entries(req.query)) {
    if (Array.isArray(v)) out[k] = v[v.length - 1]; // 마지막 값만
    else out[k] = v;
  }
  return out;
}
```

### 검증 시 “단일/배열” 명시

- 스키마 검증(Joi/Zod/Pydantic/Bean Validation)으로 **단일 필드인지, 배열인지** 명확히 선언
- 중복 키 발견 시 **즉시 400** 반환

---

## 실전 시나리오 6 — Method Override 남용

### 취약 예

```js
app.use(require('method-override')('_method')); // ❌ 누구나 _method=DELETE 사용 가능
```

### 방어

- 오직 **폼 전송 + CSRF 통과 + 특정 경로**에서만 허용
- API는 **X-HTTP-Method-Override** 등 **비활성화**

---

## 실전 시나리오 7 — 세션/흐름 파라미터 변조

- **세션 ID를 URL로 받지 말 것**(북마크/로그 등으로 누출)
- 다중 스텝 플로우(`step=2→3`)는 **서버 세션/서명 토큰**으로 상태 관리
- 리셋/재발급 로직은 **서명·만료·1회성(Nonce)** 포함

---

## 서버측 입력 검증 — 언어별 템플릿

### Node + Zod

```ts
import { z } from "zod";
const OrderId = z.string().regex(/^[a-f0-9]{24}$/i); // MongoID 예
const Qty = z.number().int().min(1).max(99);
const CreateSchema = z.object({ productId: z.string().uuid(), qty: Qty });

app.post('/api/orders', (req, res) => {
  const parsed = CreateSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error);
  // ✅ 여기서부터 서버 계산/인가
});
```

### Python + Pydantic

```python
from pydantic import BaseModel, Field, UUID4, conint
class CreateOrder(BaseModel):
    product_id: UUID4
    qty: conint(ge=1, le=99)

@app.post("/orders")
def create(o: CreateOrder):
    # ✅ o가 검증됨
    ...
```

### Spring Boot + Bean Validation

```java
record CreateOrder(@NotNull UUID productId, @Min(1) @Max(99) int qty) {}

@PostMapping("/orders")
public ResponseEntity<?> create(@Valid @RequestBody CreateOrder req) { ... }
```

---

## 불가피한 클라이언트 상태 — 서명/HMAC로 보호

- **용례**: 페이지네이션 커서, 정렬 토큰, 일시적 할인 토큰 등
- **원칙**: 파라미터를 **정규화된 형태로 정렬/직렬화 → HMAC-SHA256**으로 서명 → **만료/Nonce** 포함

### 서명 생성 (Node)

```js
import crypto from "node:crypto";

function signPayload(payload, secret) {
  const canonical = JSON.stringify(payload); // 정렬된 직렬화 사용 권장
  const sig = crypto.createHmac('sha256', secret).update(canonical).digest('base64url');
  return { payload, sig };
}

function verify({ payload, sig }, secret) {
  const canonical = JSON.stringify(payload);
  const exp = crypto.createHmac('sha256', secret).update(canonical).digest('base64url');
  // ✅ 상수시간 비교
  return crypto.timingSafeEqual(Buffer.from(sig), Buffer.from(exp));
}
```

- **반드시**: (1) **정렬/정규화** 동일하게, (2) **만료(ts)** 와 **nonce/jti**로 **재사용 방지**, (3) **서버측 검증**

---

## 로깅·모니터링·탐지

- **로그 항목**: 원본 파라미터/정규화 결과, 인가 컨텍스트(tenant/user/roles), 실패 사유(400/403), 요청 ID/세션/클라이언트 IP
- **탐지 룰 예**:
  - `id`, `userId`, `orderId` 등 **식별자 파라미터**를 초당/분당 **다른 값으로 스윕**
  - `role`, `isAdmin`, `price`, `discount` 같은 민감 키 출현
  - HPP 패턴(동일 키 반복), Open Redirect 키(`returnUrl`, `next`)에 외부 도메인

---

## 운영·아키텍처 가이드

- **멀티테넌트**: 전역 RLS(쿼리필터/정책)로 테넌트 경계 **강제**
- **업무 규칙 엔진화**: 가격/할인/재고를 서비스화하여 **서버 단일 출처**로 계산
- **프록시/게이트웨이**: 파라미터 크기/키 수, 중복 키, 금지 키를 선제 차단
- **캐시/프론트**: Vary/Cache-Key에 **권한/테넌트/사용자 컨텍스트** 반영
- **클라이언트**: 숨김필드나 JS 변수로 **보안결정값을 배포하지 않음**

---

## 테스트 전략(실습·리그레션)

### Fuzz 목록(합법적 랩·사전 허가 환경)

```
id=1 -> id=2, id=999999999
price=1000 -> price=1, price=-1, price=0, price=1e9
qty=1 -> qty=0, qty=-5, qty=999
role=user -> role=admin
returnUrl=https://evil.com
_method=DELETE
coupon=A&coupon=A&coupon=B
```

### 체크 포인트

- [ ] **인증 후 인가**(소유/역할/테넌트) 확인
- [ ] **서버 계산**: 금액/할인/배송/세금/재고
- [ ] **화이트리스트 바인딩**(DTO) + **알 수 없는 필드 무시/거부**
- [ ] **HPP 처리 규칙 고정**, 중복 키 발견 시 400
- [ ] **Open Redirect 차단**: 동일 오리진·화이트리스트
- [ ] **Method Override 제한/비활성화**
- [ ] **세션을 URL로 안 받음**, 상태는 서명 토큰
- [ ] **로깅**: 원본/정규화 값, 인가 컨텍스트, 실패 사유

---

## 요약 테이블 — 취약점 ↔ 방어

| 취약점 | 핵심 방어 |
|---|---|
| IDOR/BOLA | 소유/역할/테넌트 인가, RLS, 최소 노출 |
| 가격/수량 조작 | 서버 계산(SoT), 클라 값 무시 |
| Mass Assignment | DTO/허용필드, 민감필드 Ignore/BindNever |
| HPP | 단일 파싱 규칙, 중복 키 400 |
| Open Redirect | 동일 오리진·화이트리스트·상대경로 |
| Method Override | 제한적 허용/비활성화 |
| 세션/흐름 파라미터 | 서명/만료/Nonce, URL 세션 금지 |

---

## 실기 예상문제 (서술/코드 수정형)

**문제 1**
다음 코드는 어떤 취약점이 있는가? 안전하게 수정하라.
```js
app.get('/order/:id', async (req, res) => {
  const order = await db.orders.findById(req.params.id); // 문제점?
  res.json(order);
});
```
**모범 요지**
- **IDOR/BOLA**: 소유/테넌트 인가 없음.
- 수정: `findOne({ _id:req.params.id, userId:req.user.id })` + **역할/테넌트 검증**, 최소 필드만 반환.

---

**문제 2**
아래 결제 코드의 문제를 쓰고 수정 방향 제시.
```js
const total = req.body.total; // 클라이언트 계산값 사용
await charge(user, total);
```
**모범 요지**
- **Business Logic Tampering**: 금액 조작 가능.
- 수정: **서버가** 카탈로그/장바구니 기반으로 total 계산, 클라 값 무시.

---

**문제 3**
Mass Assignment 방지 방법을 언어 1가지 이상으로 코드와 함께 설명하라.

**모범 요지**
- DTO/허용 필드만 매핑(**화이트리스트**), 민감필드 Ignore/BindNever.
- (예시: .NET DTO, Node 수동 화이트리스트, Spring `@JsonIgnoreProperties`)

---

**문제 4**
Open Redirect를 방지하는 두 가지 기법을 쓰라.

**모범 요지**
- **동일 오리진** 검사, **화이트리스트 경로만** 허용(상대경로).
- 불일치 시 기본 경로(`/`)로 리디렉트.

---

**문제 5**
HPP가 왜 위험한가? 서버에서 어떻게 완화할 수 있는가?

**모범 요지**
- 프록시/백엔드 파서 불일치로 **정책 우회**.
- 단일 파싱 규칙 고정(첫/마지막 값만), 중복 키 발견 시 400, 스키마로 단일/배열 명시.

---

## 부록 — 미들웨어 스니펫 모음

### Express: 권한/테넌트 미들웨어

```js
function requireOwnerOrAdmin(fetchById) {
  return async (req, res, next) => {
    const caller = req.user;
    const obj = await fetchById(req.params.id);
    if (!obj) return res.sendStatus(404);
    if (obj.tenantId !== caller.tenantId) return res.sendStatus(404);
    if (obj.userId !== caller.userId && !caller.roles.includes('Admin')) {
      return res.sendStatus(403);
    }
    req.resource = obj;
    next();
  };
}
```

### Express: HPP 조기 차단

```js
app.use((req, res, next) => {
  for (const [k, v] of Object.entries(req.query)) {
    if (Array.isArray(v) && v.length > 1) return res.status(400).send('HPP');
  }
  next();
});
```

---

## 결론

URL/파라미터 변조는 “**클라이언트가 보내는 값으로 서버의 보안/비즈니스 결정을 해버리는**” 순간 발생한다.
**인가(소유/역할/테넌트), 서버 주도 계산, DTO 화이트리스트, 서명 토큰, 일관 파싱, 로깅**을 기본기로 체화하면, IDOR/BOLA·가격 조작·Mass Assignment·HPP·Open Redirect 등 핵심 취약점 대부분을 근본적으로 차단할 수 있다.
