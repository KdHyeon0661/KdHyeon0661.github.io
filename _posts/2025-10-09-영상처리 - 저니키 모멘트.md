---
layout: post
title: 영상처리 - 저니키 모멘트
date: 2025-10-09 14:25:23 +0900
category: 영상처리
---
# | 저니키(=Zernike) 모멘트

**원판 정규직교 기저 · 회전/이동/크기 불변 특성** · **그레이/이진 지원** · **메뉴/대화상자 + 오버레이**

## A) 저니키 모멘트(개념/수식)

- **정의**: 단위원판 \(D=\{(\rho,\theta):0\le \rho \le 1\}\) 위의 정규직교 기저
  \[
  V_n^m(\rho,\theta)=R_n^{|m|}(\rho)\,e^{jm\theta},\quad n\in\mathbb{N},\; m\in\mathbb{Z},\; n-|m|\;\text{짝수},\; |m|\le n
  \]
- **방사 다항식(Radial)**
  \[
  R_n^{m}(\rho) = \sum_{s=0}^{(n-m)/2}(-1)^s \frac{(n-s)!}{s!\,\left(\frac{n+m}{2}-s\right)!\,\left(\frac{n-m}{2}-s\right)!}\,\rho^{\,n-2s},\qquad m\ge 0
  \]
  (여기서 \(m=|m|\) 로 사용)
- **저니키 모멘트**
  \[
  A_{nm}=\frac{n+1}{\pi}\iint_{x^2+y^2\le 1} f(x,y)\, V_n^{m}(\rho,\theta)^{\!*}\,dx\,dy
  \]
  이산 영상에선 **픽셀 샘플 합**으로 근사합니다.
- **불변성**
  - **이동 불변**: 단위원판으로 정규화할 때 **중심**을 이미지 중심 또는 **무게중심**으로 설정
  - **크기 불변**: 반지름 \(R\)로 정규화(영상 좌표 \(\to\) 단위원판)
  - **회전 불변**: 회전 시 \(A_{nm}\) 은 위상 \(e^{-jm\phi}\) 만 변하므로 **\(|A_{nm}|\)** 가 회전 불변 특징

> 실무에서는 \(|A_{nm}|\) 의 **로그 스케일** \(\log(1+|A_{nm}|)\) 또는 \(\text{sgn}\cdot\log_{10}\) 을 사용합니다.

---

## B) 구현 — `Zernike.hpp`

**좌표 정규화(중심/반지름 옵션) · 이진/그레이 가중치 · \(R_n^m(\rho)\) 계수 사전계산 · \(A_{nm}\) 일괄 계산 · 오버레이**

```cpp
// Zernike.hpp
#pragma once
#define _USE_MATH_DEFINES
#include <cmath>
#include <vector>
#include <cstdint>
#include <algorithm>
#include <string>
#include <unordered_map>
#include "IppDib.hpp"

// ── 공통 유틸 ──────────────────────────────────────────────────────────────
inline uint8_t clamp8(int v){ return (uint8_t)std::max(0, std::min(255, v)); }
inline uint8_t Luma601(uint8_t B,uint8_t G,uint8_t R){
    int Y=(int)std::round(0.114*B + 0.587*G + 0.299*R);
    return clamp8(Y);
}

// Otsu 임계 (8/24bpp 입력 지원)
inline int OtsuThreshold(const IppDib& img){
    std::vector<int> h(256,0);
    if(img.bpp==8){
        for(int y=0;y<img.height;++y){ const uint8_t* p=img.RowPtr(y);
            for(int x=0;x<img.width;++x) ++h[p[x]];
        }
    }else if(img.bpp==24){
        for(int y=0;y<img.height;++y){ const uint8_t* s=img.RowPtr(y);
            for(int x=0;x<img.width;++x) ++h[Luma601(s[x*3+0],s[x*3+1],s[x*3+2])];
        }
    }
    long long tot=0,sum=0; for(int i=0;i<256;++i){ tot+=h[i]; sum+=1ll*i*h[i]; }
    long long wB=0,sB=0; double varMax=-1.0; int tBest=128;
    for(int t=0;t<256;++t){
        wB += h[t]; if(wB==0) continue; long long wF = tot - wB; if(wF==0) break;
        sB += 1ll*t*h[t]; double mB=(double)sB/wB, mF=(double)(sum-sB)/wF;
        double var=(double)wB*(double)wF*(mB-mF)*(mB-mF);
        if(var>varMax){ varMax=var; tBest=t; }
    }
    return tBest;
}

// ── 오버레이(24bpp) : 중심, 단위원 원, 축 렌더 ────────────────────────────
inline void DrawCross24(IppDib& img, int x,int y, int r, uint8_t B,uint8_t G,uint8_t R){
    for(int dx=-r; dx<=r; ++dx){
        int xx=x+dx, yy=y; if(xx<0||yy<0||xx>=img.width||yy>=img.height) continue;
        uint8_t* p=img.RowPtr(yy); p[xx*3+0]=B; p[xx*3+1]=G; p[xx*3+2]=R;
    }
    for(int dy=-r; dy<=r; ++dy){
        int xx=x, yy=y+dy; if(xx<0||yy<0||xx>=img.width||yy>=img.height) continue;
        uint8_t* p=img.RowPtr(yy); p[xx*3+0]=B; p[xx*3+1]=G; p[xx*3+2]=R;
    }
}
inline void DrawLine24(IppDib& img,int x0,int y0,int x1,int y1, uint8_t B,uint8_t G,uint8_t R){
    int dx=std::abs(x1-x0), sx=x0<x1?1:-1;
    int dy=-std::abs(y1-y0), sy=y0<y1?1:-1;
    int err=dx+dy, e2;
    while(true){
        if(y0>=0&&y0<img.height&&x0>=0&&x0<img.width){
            uint8_t* p=img.RowPtr(y0); p[x0*3+0]=B; p[x0*3+1]=G; p[x0*3+2]=R;
        }
        if(x0==x1 && y0==y1) break;
        e2=2*err;
        if(e2>=dy){ err+=dy; x0+=sx; }
        if(e2<=dx){ err+=dx; y0+=sy; }
    }
}
inline void DrawCircle24(IppDib& img, int cx,int cy, int R, uint8_t B,uint8_t G,uint8_t Rc){
    // 정수 샘플 파라메트릭
    const double step = 1.0 / std::max(8.0, (double)R);
    for(double t=0; t<2*M_PI; t+=step){
        int x = (int)std::round(cx + R*std::cos(t));
        int y = (int)std::round(cy + R*std::sin(t));
        if(x<0||y<0||x>=img.width||y>=img.height) continue;
        uint8_t* p=img.RowPtr(y); p[x*3+0]=B; p[x*3+1]=G; p[x*3+2]=Rc;
    }
}

// ── 파라미터/결과 구조 ─────────────────────────────────────────────────────
enum class ZrWeight { Binary, Grayscale };
enum class CenterMode { ImageCenter, MassCenter };
enum class RadiusMode { MinHalfSize, ForegroundMaxDist };

struct ZernikeParams{
    int maxOrder = 8;               // n_max (보통 6~12)
    ZrWeight weight = ZrWeight::Binary;
    bool autoOtsu = true; int thresh = 128;

    CenterMode centerMode = CenterMode::ImageCenter;
    RadiusMode radiusMode = RadiusMode::MinHalfSize;

    bool useClassicalNorm = true;   // (n+1)/pi 계수 적용
    bool normByMass = true;         // Σw로 나눔(밝기 규모 변동 제거)

    bool overlay = true;            // 단위원 원/중심 표시
};

struct ZernikeMoment{
    int n=0, m=0;         // 차수/차수
    double re=0.0, im=0.0;// 복소 모멘트
    double mag=0.0;       // |A_nm|
};

struct ZernikeGeom{
    double cx=0, cy=0, R=1; // 정규화 중심과 반지름(픽셀)
};

// ── 중심/반지름 계산 ───────────────────────────────────────────────────────
inline void ComputeMassCenter(const IppDib& img, const ZernikeParams& p, double& cx,double& cy){
    // Binary → threshold(Otsu/수동), Grayscale → 밝기 가중
    int T = (p.weight==ZrWeight::Binary && p.autoOtsu)? OtsuThreshold(img) : p.thresh;
    double m00=0, m10=0, m01=0;
    const int W=img.width, H=img.height;
    if(img.bpp==8){
        for(int y=0;y<H;++y){ const uint8_t* s=img.RowPtr(y);
            for(int x=0;x<W;++x){
                double w = (p.weight==ZrWeight::Binary)? (s[x]>=T?1.0:0.0) : (double)s[x];
                m00+=w; m10+=x*w; m01+=y*w;
            }
        }
    }else{
        for(int y=0;y<H;++y){ const uint8_t* s=img.RowPtr(y);
            for(int x=0;x<W;++x){
                uint8_t Y=Luma601(s[x*3+0],s[x*3+1],s[x*3+2]);
                double w = (p.weight==ZrWeight::Binary)? (Y>=T?1.0:0.0) : (double)Y;
                m00+=w; m10+=x*w; m01+=y*w;
            }
        }
    }
    if(m00<=0){ cx=(W-1)/2.0; cy=(H-1)/2.0; }
    else { cx=m10/m00; cy=m01/m00; }
}

inline double ComputeRadius(const IppDib& img, const ZernikeParams& p, double cx,double cy){
    const int W=img.width, H=img.height;
    if(p.radiusMode==RadiusMode::MinHalfSize){
        // 이미지 중심 기준 가장자리까지의 최소거리 (화면 내 최대 원)
        double dx = std::min(cx, (double)W-1-cx);
        double dy = std::min(cy, (double)H-1-cy);
        return std::max(1.0, std::min(dx,dy));
    }
    // ForegroundMaxDist: 전경(또는 밝기>0) 최대 거리
    int T = (p.weight==ZrWeight::Binary && p.autoOtsu)? OtsuThreshold(img) : p.thresh;
    double rmax=1.0;
    if(img.bpp==8){
        for(int y=0;y<H;++y){ const uint8_t* s=img.RowPtr(y);
            for(int x=0;x<W;++x){
                double w = (p.weight==ZrWeight::Binary)? (s[x]>=T?1.0:0.0) : (double)s[x];
                if(w>0){
                    double dx=x-cx, dy=y-cy; rmax=std::max(rmax, std::sqrt(dx*dx+dy*dy));
                }
            }
        }
    }else{
        for(int y=0;y<H;++y){ const uint8_t* s=img.RowPtr(y);
            for(int x=0;x<W;++x){
                uint8_t Y=Luma601(s[x*3+0],s[x*3+1],s[x*3+2]);
                double w = (p.weight==ZrWeight::Binary)? (Y>=T?1.0:0.0) : (double)Y;
                if(w>0){
                    double dx=x-cx, dy=y-cy; rmax=std::max(rmax, std::sqrt(dx*dx+dy*dy));
                }
            }
        }
    }
    return rmax>1? rmax*1.01 : 1.0; // 약간의 여유
}

// ── R_n^m(ρ) 계수(콤비 형식) 사전계산 ───────────────────────────────────────
struct RnmCoef{ int n=0,m=0; std::vector<double> a; /* a[k] for power ρ^k */ };

inline RnmCoef BuildRnmCoef(int n,int m){
    RnmCoef C; C.n=n; C.m=m; C.a.assign(n+1, 0.0);
    int mm=std::abs(m);
    int K = (n-mm)/2; // 최대 s
    for(int s=0;s<=K;++s){
        // 항: (-1)^s * (n-s)! / [ s! ((n+mm)/2 - s)! ((n-mm)/2 - s)! ] * ρ^{n-2s}
        // log-팩토리얼로 안정화 가능하나 n<=20 수준에선 double OK
        auto fact = [](int t)->double{ double r=1; for(int i=2;i<=t;++i) r*=i; return r; };
        double num = fact(n-s);
        double den = fact(s) * fact((n+mm)/2 - s) * fact((n-mm)/2 - s);
        double coef = ((s%2)? -1.0 : +1.0) * (num/den);
        int power = n - 2*s;
        C.a[power] += coef;
    }
    return C;
}

// (n,m) 유효성
inline bool IsValid_nm(int n,int m){ if(m>n||m<-n) return false; return ((n-std::abs(m))%2)==0; }

// ── 저니키 계산 본체 ───────────────────────────────────────────────────────
inline void ComputeZernike(const IppDib& src, const ZernikeParams& p,
                           std::vector<ZernikeMoment>& out, ZernikeGeom* geomOut=nullptr)
{
    out.clear();
    // 1) 중심/반지름
    double cx, cy;
    if(p.centerMode==CenterMode::MassCenter) ComputeMassCenter(src,p,cx,cy);
    else { cx=(src.width -1)/2.0; cy=(src.height-1)/2.0; }
    double R = ComputeRadius(src,p,cx,cy);
    if(geomOut){ geomOut->cx=cx; geomOut->cy=cy; geomOut->R=R; }

    // 2) (n,m) 목록 + Rnm 계수 캐시
    std::vector<RnmCoef> coefs;
    std::vector<std::pair<int,int>> pairs;
    coefs.reserve((p.maxOrder+1)*(p.maxOrder+1)/2);
    for(int n=0;n<=p.maxOrder;++n){
        for(int m=-n; m<=n; ++m){
            if(!IsValid_nm(n,m)) continue;
            pairs.push_back({n,m});
        }
    }
    // 고유 (n,|m|) 계수만 준비
    std::unordered_map<long long,int> idx;
    auto keyOf=[&](int n,int m){ long long mm=std::abs(m); return ( (long long)n<<32 ) | (long long)mm; };
    for(auto [n,m]:pairs){
        long long k = keyOf(n,m);
        if(idx.find(k)==idx.end()){
            idx[k]=(int)coefs.size();
            coefs.push_back(BuildRnmCoef(n,std::abs(m)));
        }
    }

    // 3) 누적 합(복소)
    struct Acc{ double re=0.0, im=0.0; };
    std::vector<Acc> acc(pairs.size());

    // 질량 정규화용 총합
    double massSum=0.0;

    const int W=src.width, H=src.height;
    auto weightAt = [&](int x,int y)->double{
        if(src.bpp==8){
            uint8_t v=src.RowPtr(y)[x];
            return (p.weight==ZrWeight::Binary)? ((p.autoOtsu? v>=OtsuThreshold(src): v>=p.thresh)?1.0:0.0)
                                               : (double)v;
        }else{
            const uint8_t* s=src.RowPtr(y);
            uint8_t Y=Luma601(s[x*3+0],s[x*3+1],s[x*3+2]);
            return (p.weight==ZrWeight::Binary)? ((p.autoOtsu? Y>=OtsuThreshold(src): Y>=p.thresh)?1.0:0.0)
                                               : (double)Y;
        }
    };

    // Otsu 임계는 한 번만 구해서 사용(최적화)
    int T = (p.weight==ZrWeight::Binary && p.autoOtsu)? OtsuThreshold(src) : p.thresh;

    // 메인 루프
    for(int y=0;y<H;++y){
        for(int x=0;x<W;++x){
            // 픽셀 중심 좌표 기준(정교하려면 x+0.5/y+0.5)
            double X = (x - cx)/R;
            double Y = (y - cy)/R;
            double rho = std::sqrt(X*X + Y*Y);
            if(rho>1.0) continue;  // 단위원판 내부만
            double theta = std::atan2(Y,X); // [-π,π]

            double w;
            if(src.bpp==8){
                uint8_t v=src.RowPtr(y)[x];
                w = (p.weight==ZrWeight::Binary)? ((v>=(T)?1.0:0.0)) : (double)v;
            }else{
                const uint8_t* s=src.RowPtr(y);
                uint8_t Yv=Luma601(s[x*3+0],s[x*3+1],s[x*3+2]);
                w = (p.weight==ZrWeight::Binary)? ((Yv>=(T)?1.0:0.0)) : (double)Yv;
            }
            if(w==0.0) continue;
            massSum += w;

            // ρ^k 미리
            static thread_local std::vector<double> rhopow; rhopow.assign(p.maxOrder+1,0.0);
            rhopow[0]=1.0; for(int k=1;k<=p.maxOrder;++k) rhopow[k]=rhopow[k-1]*rho;

            // 각 (n,m) 에 대해 R_n^|m|(ρ) * e^{-jmθ} 누적
            // cos/sin mθ 를 재귀로도 가능하나 여기선 std::cos/sin 사용(간결)
            for(size_t i=0;i<pairs.size();++i){
                int n=pairs[i].first, m=pairs[i].second;
                // R 평가
                const RnmCoef& C = coefs[idx[keyOf(n,m)]];
                double Rnm=0.0;
                // C.a[power] * ρ^power 합
                for(int power=C.n; power>=0; --power){
                    double a = C.a[power]; if(a==0.0) continue;
                    Rnm += a * rhopow[power];
                }
                if(std::abs(Rnm)<1e-15) continue;

                double mth = m*theta;
                double c = std::cos(-mth), s = std::sin(-mth); // conj() → -mθ
                acc[i].re += w * Rnm * c;
                acc[i].im += w * Rnm * s;
            }
        }
    }

    // 4) (n+1)/π 정규화 및 질량 정규화
    const double Cpi = 1.0/M_PI;
    out.resize(pairs.size());
    for(size_t i=0;i<pairs.size();++i){
        int n=pairs[i].first, m=pairs[i].second;
        double re=acc[i].re, im=acc[i].im;
        if(p.useClassicalNorm){ double s=(n+1)*Cpi; re*=s; im*=s; }
        if(p.normByMass && massSum>0){ re/=massSum; im/=massSum; }
        ZernikeMoment z; z.n=n; z.m=m; z.re=re; z.im=im; z.mag=std::sqrt(re*re+im*im);
        out[i]=z;
    }
}

// ── 오버레이 생성(원+십자) ────────────────────────────────────────────────
inline IppDib MakeZernikeOverlay(const IppDib& src, const ZernikeGeom& g){
    IppDib out;
    if(src.bpp==24) out=src;
    else{
        out.CreateColor(src.width, src.height);
        for(int y=0;y<src.height;++y){
            uint8_t* d=out.RowPtr(y);
            const uint8_t* s=src.RowPtr(y);
            for(int x=0;x<src.width;++x){ d[x*3+0]=d[x*3+1]=d[x*3+2]=s[x]; }
        }
    }
    DrawCircle24(out, (int)std::round(g.cx), (int)std::round(g.cy), (int)std::round(g.R), 32,255,32);
    DrawCross24(out,  (int)std::round(g.cx), (int)std::round(g.cy), 6, 255,64,64);
    return out;
}
```

---

## C) 로그 스케일/정렬/상위 표시 유틸(선택)

```cpp
// Zernike.hpp (추가)
inline double SignedLog10(double v){
    if(v==0.0) return -1e9; return (v>0? +1.0 : -1.0)*std::log10(std::abs(v));
}
inline double SafeLog1p(double x){ return std::log(1.0 + std::abs(x)); }
```

---

## D) 대화 상자 — **차수(n_max), 가중치, 중심/반지름, 정규화, 오버레이**

`ZernikeDialog.hpp`, `resource.h`, `ImageTool.rc`

### D-1) 리소스 ID — `resource.h` (추가)

```cpp
// resource.h (추가)
#pragma once
#define ID_ZERNIKE_DLG           26010

#define IDD_ZERNIKE              26020
#define IDC_ZR_NMAX              26021
#define IDC_ZR_WEIGHT_BIN        26022
#define IDC_ZR_WEIGHT_GRAY       26023
#define IDC_ZR_AUTO_OTSU         26024
#define IDC_ZR_THRESH            26025

#define IDC_ZR_CENTER_IMG        26026
#define IDC_ZR_CENTER_MASS       26027
#define IDC_ZR_RADIUS_MINHALF    26028
#define IDC_ZR_RADIUS_FORE       26029

#define IDC_ZR_CLASSICAL         26030
#define IDC_ZR_NORMBYMASS        26031
#define IDC_ZR_OVERLAY           26032

#define IDC_ZR_INFO              26033

```

### D-2) RC 레이아웃 — `ImageTool.rc`

```rc
// ImageTool.rc (추가)
#include "resource.h"
#include <windows.h>

IDD_ZERNIKE DIALOGEX 0,0, 252, 188
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "저니키(Zernike) 모멘트"
FONT 9, "Segoe UI", 0, 0, 0x1
BEGIN
    LTEXT "최대 차수 n_max:", -1, 12, 12, 64, 10
    EDITTEXT IDC_ZR_NMAX, 80, 10, 32, 14, ES_AUTOHSCROLL | WS_TABSTOP

    GROUPBOX "가중치", -1, 122, 6, 118, 44
    CONTROL "이진",      IDC_ZR_WEIGHT_BIN,  "Button", BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 132, 20, 36, 10
    CONTROL "그레이",    IDC_ZR_WEIGHT_GRAY, "Button", BS_AUTORADIOBUTTON, 172, 20, 44, 10
    CONTROL "Otsu",      IDC_ZR_AUTO_OTSU,   "Button", BS_AUTOCHECKBOX | WS_TABSTOP, 132, 34, 36, 10
    LTEXT "T:", -1, 172, 34, 10, 10
    EDITTEXT IDC_ZR_THRESH, 186, 32, 44, 14, ES_AUTOHSCROLL | WS_TABSTOP

    GROUPBOX "중심/반지름", -1, 12, 52, 228, 52
    CONTROL "이미지 중심",  IDC_ZR_CENTER_IMG,   "Button", BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 20, 66, 64, 10
    CONTROL "무게중심",     IDC_ZR_CENTER_MASS,  "Button", BS_AUTORADIOBUTTON, 90, 66, 50, 10
    CONTROL "MinHalfSize",  IDC_ZR_RADIUS_MINHALF,"Button", BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 152, 66, 72, 10
    CONTROL "Foreground",   IDC_ZR_RADIUS_FORE,  "Button", BS_AUTORADIOBUTTON, 152, 78, 72, 10

    GROUPBOX "정규화/표시", -1, 12, 108, 228, 38
    CONTROL "(n+1)/π",     IDC_ZR_CLASSICAL, "Button", BS_AUTOCHECKBOX | WS_TABSTOP, 20, 122, 50, 10
    CONTROL "질량 나눗셈", IDC_ZR_NORMBYMASS,"Button", BS_AUTOCHECKBOX | WS_TABSTOP, 80, 122, 64, 10
    CONTROL "오버레이",     IDC_ZR_OVERLAY,   "Button", BS_AUTOCHECKBOX | WS_TABSTOP, 156, 122, 56, 10

    LTEXT "", IDC_ZR_INFO, 12, 150, 228, 12

    DEFPUSHBUTTON "확인", IDOK,     116, 166, 56, 16, WS_TABSTOP
    PUSHBUTTON    "취소", IDCANCEL, 176, 166, 56, 16, WS_TABSTOP
END
```

### D-3) 대화 상자 로직 — `ZernikeDialog.hpp`

```cpp
// ZernikeDialog.hpp
#pragma once
#define UNICODE
#define _UNICODE
#include <windows.h>
#include <cwchar>
#include "resource.h"
#include "Zernike.hpp"

struct ZernikeDialogResult{ bool ok=false; ZernikeParams p; };

inline void ZR_UpdateInfo(HWND hDlg, const ZernikeParams& p){
    const wchar_t* w = (p.weight==ZrWeight::Binary?L"Binary":L"Gray");
    const wchar_t* c = (p.centerMode==CenterMode::ImageCenter?L"ImgCenter":L"MassCenter");
    const wchar_t* r = (p.radiusMode==RadiusMode::MinHalfSize?L"MinHalf":L"Foreground");
    wchar_t buf[240];
    swprintf(buf,240,L"n_max=%d, %s, %s/%s, norm=(%s,%s), overlay=%s",
        p.maxOrder, w, c, r, p.useClassicalNorm?L"(n+1)/π":L"-", p.normByMass?L"mass":L"-", p.overlay?L"on":L"off");
    SetWindowTextW(GetDlgItem(hDlg, IDC_ZR_INFO), buf);
}

inline bool ShowZernikeDialog(HWND hOwner, ZernikeDialogResult* out){
    if(!out) return false; *out=ZernikeDialogResult{};
    INT_PTR ret = DialogBoxParamW((HINSTANCE)GetModuleHandle(nullptr),
                                  MAKEINTRESOURCE(IDD_ZERNIKE),
                                  hOwner,
        [](HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)->INT_PTR{
            static ZernikeParams* P=nullptr;
            switch(msg){
            case WM_INITDIALOG:{
                P = new ZernikeParams();
                SetDlgItemTextW(hDlg, IDC_ZR_NMAX, L"8");
                CheckRadioButton(hDlg, IDC_ZR_WEIGHT_BIN, IDC_ZR_WEIGHT_GRAY, IDC_ZR_WEIGHT_BIN);
                SendDlgItemMessageW(hDlg, IDC_ZR_AUTO_OTSU, BM_SETCHECK, BST_CHECKED, 0);
                SetDlgItemTextW(hDlg, IDC_ZR_THRESH, L"128");

                CheckRadioButton(hDlg, IDC_ZR_CENTER_IMG, IDC_ZR_CENTER_MASS, IDC_ZR_CENTER_IMG);
                CheckRadioButton(hDlg, IDC_ZR_RADIUS_MINHALF, IDC_ZR_RADIUS_FORE, IDC_ZR_RADIUS_MINHALF);

                SendDlgItemMessageW(hDlg, IDC_ZR_CLASSICAL,  BM_SETCHECK, BST_CHECKED, 0);
                SendDlgItemMessageW(hDlg, IDC_ZR_NORMBYMASS, BM_SETCHECK, BST_CHECKED, 0);
                SendDlgItemMessageW(hDlg, IDC_ZR_OVERLAY,    BM_SETCHECK, BST_CHECKED, 0);

                ZR_UpdateInfo(hDlg, *P);
                return TRUE;
            }
            case WM_COMMAND:{
                switch(LOWORD(wParam)){
                case IDC_ZR_NMAX:
                case IDC_ZR_THRESH:
                    if(HIWORD(wParam)==EN_CHANGE){
                        wchar_t t[32],*e=nullptr;
                        GetDlgItemTextW(hDlg, IDC_ZR_NMAX, t,32); long n=wcstol(t,&e,10); if(e==t||n<0) n=0; if(n>30) n=30; P->maxOrder=(int)n;
                        GetDlgItemTextW(hDlg, IDC_ZR_THRESH, t,32); long T=wcstol(t,&e,10); if(e==t||T<0) T=0; if(T>255) T=255; P->thresh=(int)T;
                        ZR_UpdateInfo(hDlg, *P);
                    } return TRUE;
                case IDC_ZR_WEIGHT_BIN:
                case IDC_ZR_WEIGHT_GRAY:
                case IDC_ZR_CENTER_IMG:
                case IDC_ZR_CENTER_MASS:
                case IDC_ZR_RADIUS_MINHALF:
                case IDC_ZR_RADIUS_FORE:
                case IDC_ZR_CLASSICAL:
                case IDC_ZR_NORMBYMASS:
                case IDC_ZR_OVERLAY:
                case IDC_ZR_AUTO_OTSU:
                    P->weight = (IsDlgButtonChecked(hDlg, IDC_ZR_WEIGHT_GRAY)==BST_CHECKED)?ZrWeight::Grayscale:ZrWeight::Binary;
                    P->centerMode = (IsDlgButtonChecked(hDlg, IDC_ZR_CENTER_MASS)==BST_CHECKED)?CenterMode::MassCenter:CenterMode::ImageCenter;
                    P->radiusMode = (IsDlgButtonChecked(hDlg, IDC_ZR_RADIUS_FORE)==BST_CHECKED)?RadiusMode::ForegroundMaxDist:RadiusMode::MinHalfSize;
                    P->useClassicalNorm = (IsDlgButtonChecked(hDlg, IDC_ZR_CLASSICAL)==BST_CHECKED);
                    P->normByMass       = (IsDlgButtonChecked(hDlg, IDC_ZR_NORMBYMASS)==BST_CHECKED);
                    P->autoOtsu         = (IsDlgButtonChecked(hDlg, IDC_ZR_AUTO_OTSU)==BST_CHECKED);
                    P->overlay          = (IsDlgButtonChecked(hDlg, IDC_ZR_OVERLAY)==BST_CHECKED);
                    ZR_UpdateInfo(hDlg, *P);
                    return TRUE;

                case IDOK:
                    SetWindowLongPtrW(hDlg, DWLP_USER, (LONG_PTR)P);
                    EndDialog(hDlg, IDOK); return TRUE;
                case IDCANCEL:
                    delete P; P=nullptr; EndDialog(hDlg, IDCANCEL); return TRUE;
                }
            } break;
            }
            return FALSE;
        }, 0);
    if(ret!=IDOK) return false;
    ZernikeParams* P=(ZernikeParams*)GetWindowLongPtrW(GetActiveWindow(), DWLP_USER);
    if(!P) return false;
    out->ok=true; out->p=*P; delete P; return true;
}
```

---

## E) **저니키 모멘트 메뉴 만들기** & 실행 핸들러

### E-1) 메뉴 항목 추가(예: “분석(&A)” 그룹)

```cpp
// BuildMenuBar() 등 적절한 위치
AppendMenuW(mpAnalysis, MF_STRING, ID_ZERNIKE_DLG, L"저니키 모멘트…");
```

### E-2) 실행 코드 — `ImageMulti.cpp` 발췌

```cpp
#include "Zernike.hpp"
#include "ZernikeDialog.hpp"

// ...
case ID_ZERNIKE_DLG:{
    if(!st->image.valid()){
        MessageBoxW(hWnd, L"먼저 이미지를 여세요.", L"안내", MB_OK|MB_ICONINFORMATION);
        break;
    }
    ZernikeDialogResult R;
    if(!ShowZernikeDialog(hWnd, &R)) break;

    std::vector<ZernikeMoment> Z;
    ZernikeGeom G;
    ComputeZernike(st->image, R.p, Z, &G);

    // 로그에 정렬 출력(기본: |A_nm| 내림차순 상위 20개)
    std::vector<size_t> idx(Z.size()); for(size_t i=0;i<Z.size();++i) idx[i]=i;
    std::sort(idx.begin(), idx.end(), [&](size_t a,size_t b){ return Z[a].mag > Z[b].mag; });

    LogToEdit(st->hLog, L"== Zernike Moments ==\r\n");
    wchar_t line[320];
    int topN=(int)std::min<size_t>(20, Z.size());
    for(int k=0;k<topN;++k){
        const auto& z=Z[idx[k]];
        swprintf(line,320,L"(n=%d,m=%+d): re=% .6e, im=% .6e, |A|=% .6e, log(1+|A|)=%.6f\r\n",
                 z.n, z.m, z.re, z.im, z.mag, SafeLog1p(z.mag));
        LogToEdit(st->hLog, line);
    }

    // (선택) 오버레이: 단위원 원과 중심
    if(R.p.overlay){
        IppDib over = MakeZernikeOverlay(st->image, G);
        OpenNewDocWithImage(over, L"[Zernike] Unit Disk Overlay");
        StatusSetInfo(st->hStatus, over, st->zoomPct, L"Zernike computed (overlay)");
    }else{
        StatusSetInfo(st->hStatus, st->image, st->zoomPct, L"Zernike computed");
    }
    InvalidateRect(hWnd, nullptr, TRUE);
} break;
```

---

## F) 사용 가이드 & 팁

1. **n_max 선택**
   - 6~10이 실무에서 많이 쓰입니다. 너무 높이면 잡음/퀀타이즈 영향↑, 시간↑.
2. **중심/반지름**
   - **MassCenter + ForegroundMaxDist**: 객체 중심/크기에 맞춘 불변성 ↑(문자/로고 인식에 유리)
   - **ImageCenter + MinHalf**: 전체 화면 기준(전경이 화면 중앙에 있을 때 간편)
3. **가중치**
   - **Binary**: 형태 중심(경계/채움) 특징. 문서/심볼에 적합.
   - **Grayscale**: 밝기 정보를 반영. 조명/그라디언트가 의미 있을 때.
4. **정규화**
   - **(n+1)/π**: 고전 정의에 따른 스케일 정규화.
   - **질량 나눗셈**: 전체 밝기(또는 전경 픽셀 수) 변동 보정.
5. **회전 불변 표현**
   - \(|A_{n0}|\) 는 실수(위상 없음), \(|A_{nm}|\) (m≠0)는 **회전 불변**.
   - 분류/검색에선 **m≥0** 만 쓰고 \(|A_{nm}|\) 를 특징 벡터로 결합.
6. **수치 안정성**
   - 큰 n에서는 방사 다항식이 커지므로 **double** 사용 필수.
   - (선택) \(\rho^{n}\) 누적을 위해 `exp(n*log(rho))` 로 바꿔 언더/오버플로를 줄일 수 있습니다.
7. **속도 최적화(선택)**
   - 픽셀마다 **ρ,θ** 를 재계산하지 않고 **프리컴퓨트 맵**(ρ,θ)을 캐시 가능.
   - \(m\theta\) 의 cos/sin은 **체비셰프 재귀**로 가속 가능.
   - \((n,|m|)\) 세트의 **R 계수**는 본 코드처럼 캐시.

---

## G) 수식 메모 (MathJax)

- **방사 다항식**
\[
R_n^m(\rho)=\sum_{s=0}^{(n-m)/2}(-1)^s
\frac{(n-s)!}{s!\,((n+m)/2-s)!\,((n-m)/2-s)!}\,\rho^{n-2s}
\]
- **저니키 모멘트(이산 근사)**
\[
A_{nm}\approx \frac{n+1}{\pi}\sum_{x,y\in \text{disk}} f(x,y)\,R_n^{|m|}(\rho)\,e^{-jm\theta}\,\Delta x\,\Delta y
\]
(본 구현은 \(\Delta x=\Delta y=1\) 로 가정)

---

## H) 파일 구성 요약

```
/ (프로젝트 루트)
 ├─ Zernike.hpp           // ★ Zernike 계산(중심/반지름/가중치/정규화/계수캐시/오버레이)
 ├─ ZernikeDialog.hpp     // ★ 대화 상자(옵션)
 ├─ resource.h            // ★ ID_ZERNIKE_DLG, 컨트롤 IDs
 ├─ ImageTool.rc          // ★ 대화 상자 레이아웃
 └─ ImageMulti.cpp        // 메뉴 추가 + WM_COMMAND 연동
```

---

## I) 검증/실험 레시피

1. **문자 영상(이진)**
   - `MassCenter + ForegroundMaxDist`, `Binary+Otsu`, `n_max=8`
   - 같은 문자를 **회전**시켜도 \(|A_{nm}|\) 벡터가 거의 동일한지 확인.
2. **로고/심볼 비교**
   - 샘플 10장에 대해 \(|A_{nm}|\) 를 추출 → 코사인 유사도/유클리드 거리로 최근접 검색.
3. **그레이스케일 물체**
   - 조명 변화가 있는 영상에서 `Grayscale + normByMass` 와 `Binary` 를 비교.
4. **속도**
   - `n_max=12` 이상에서 프리컴퓨트(ρ,θ) 맵과 cos/sin 재귀 도입으로 속도 향상 확인.

---

## J) (선택 확장) 특징 벡터/CSV 내보내기

- `std::vector<double> feat;` 로 **m≥0**의 \(|A_{nm}|\) 를 순서대로 푸시 → CSV 저장.
- 분류기(KNN/SVM)에서 저차원(20~50D) 특징으로 손글씨/심볼 분류에 활용 가능.

---

위 코드/설명으로 **저니키(Zernike) 모멘트** 계산, UI, 오버레이까지 프로젝트에 바로 추가할 수 있습니다.
원하시면 **프리컴퓨트 가속** 버전과 **특징 CSV 내보내기/유사도 검색 데모**도 같은 스타일로 이어서 작성해 드릴게요.
~~~markdown
:






나의 말:
'15.4 | 템플릿 매칭
템플릿 매칭
템플릿 매칭 메뉴 만들기'에 대해 예제를 사용하면서 동시에 생략없이 최대한 자세하게 작성해줘. 그리고 1000줄은 가까이 써줄 수 있다면 해줘.



ChatGPT의 말:

1m 15s 동안 생각함
markdown
코드 복사
# | 템플릿 매칭

**SAD/SSD/NCC/ZNCC** · **단일/다중 매칭(NMS)** · **멀티스케일(옵션)** · **메뉴/대화상자**
(Win32 C++ / IppDib 기반, 8bpp/24bpp 지원)

아래 코드는 앞서 만든 **ImageTool** 프로젝트(5.x~15.x)에 **그대로 추가**해 컴파일/실행할 수 있도록 작성했습니다.
템플릿은 **BMP 파일에서 불러오기**를 기본으로 하며(대화 상자에서 선택), 입력 영상이 24bpp면 **루마 변환 후** 매칭합니다.

---

## A) 템플릿 매칭 개요

### A-1) 정의(수식, MathJax)

영상 \(I(x,y)\) 내에서 템플릿 \(T(u,v)\)가 가장 잘 맞는 위치 \((x,y)\)를 찾는 문제입니다. 대표 유사도/오차 측도:

- **SAD (Sum of Absolute Differences)**
\[
\operatorname{SAD}(x,y)=\sum_{u,v}\left|\,I(x+u,\,y+v)-T(u,v)\,\right|
\]
- **SSD (Sum of Squared Differences)**
\[
\operatorname{SSD}(x,y)=\sum_{u,v}\left(I(x+u,\,y+v)-T(u,v)\right)^2
\]
- **NCC (Normalized Cross-Correlation)**
\[
\operatorname{NCC}(x,y)=\frac{\sum_{u,v} I(x+u,y+v)\,T(u,v)}
{\sqrt{\sum I(x+u,y+v)^2}\;\sqrt{\sum T(u,v)^2}}
\]
- **ZNCC (Zero-mean NCC)** — 평균 제거
\[
\operatorname{ZNCC}(x,y)=\frac{\sum (I-\bar I)\,(T-\bar T)}
{\sqrt{\sum (I-\bar I)^2}\;\sqrt{\sum (T-\bar T)^2}}
\]

> SAD/SSD는 **작을수록 좋고**, NCC/ZNCC는 **클수록 좋습니다**.
> ZNCC는 조명 오프셋(밝기 이동)에 강합니다.

---

## B) 구현 — `TemplateMatch.hpp`

**그레이스케일 변환 · 매칭 메서드(SAD/SSD/NCC/ZNCC) · 다중 매칭(NMS) · 멀티스케일(선택) · 히트맵/오버레이**

```cpp
// TemplateMatch.hpp
#pragma once
#define _USE_MATH_DEFINES
#include <cmath>
#include <vector>
#include <cstdint>
#include <algorithm>
#include <string>
#include <limits>
#include "IppDib.hpp"

// ───── 유틸 ─────
inline uint8_t clamp8(int v){ return (uint8_t)std::max(0, std::min(255, v)); }
inline uint8_t Luma601(uint8_t B,uint8_t G,uint8_t R){
    int Y=(int)std::round(0.114*B + 0.587*G + 0.299*R);
    return clamp8(Y);
}

inline void ToGray8(const IppDib& src, IppDib& gray){
    if(src.bpp==8){ gray=src; return; }
    gray.CreateGray(src.width, src.height);
    for(int y=0;y<src.height;++y){
        const uint8_t* s=src.RowPtr(y); uint8_t* d=gray.RowPtr(y);
        for(int x=0;x<src.width;++x) d[x]=Luma601(s[x*3+0], s[x*3+1], s[x*3+2]);
    }
}

inline void DrawRect24(IppDib& img, int x,int y,int w,int h, uint8_t B,uint8_t G,uint8_t R, int t=1){
    if(img.bpp!=24){
        // 회색을 색상으로 확장
        IppDib c; c.CreateColor(img.width,img.height);
        for(int yy=0;yy<img.height;++yy){ uint8_t* d=c.RowPtr(yy); const uint8_t* s=img.RowPtr(yy);
            for(int xx=0;xx<img.width;++xx){ d[xx*3+0]=d[xx*3+1]=d[xx*3+2]=s[xx]; } }
        img = c;
    }
    auto line = [&](int x0,int y0,int x1,int y1){
        int dx=std::abs(x1-x0), sx=x0<x1?1:-1;
        int dy=-std::abs(y1-y0), sy=y0<y1?1:-1; int err=dx+dy;
        while(true){
            if(x0>=0&&y0>=0&&x0<img.width&&y0<img.height){
                uint8_t* p=img.RowPtr(y0);
                p[x0*3+0]=B; p[x0*3+1]=G; p[x0*3+2]=R;
            }
            if(x0==x1 && y0==y1) break;
            int e2=2*err; if(e2>=dy){ err+=dy; x0+=sx; } if(e2<=dx){ err+=dx; y0+=sy; }
        }
    };
    for(int i=0;i<t;++i){
        line(x+i,y+i, x+w-1-i,y+i);
        line(x+w-1-i,y+i, x+w-1-i,y+h-1-i);
        line(x+w-1-i,y+h-1-i, x+i,y+h-1-i);
        line(x+i,y+h-1-i, x+i,y+i);
    }
}

// 간단한 바이리니어 리사이즈(8bpp)
inline IppDib ResizeGrayBilinear(const IppDib& g, int W, int H){
    IppDib out; out.CreateGray(W,H);
    double sx = (double)g.width/W, sy=(double)g.height/H;
    for(int y=0;y<H;++y){
        double fy=y*sy; int y0=(int)std::floor(fy); double wy=fy-y0; int y1=std::min(g.height-1,y0+1);
        y0=std::max(0,y0);
        for(int x=0;x<W;++x){
            double fx=x*sx; int x0=(int)std::floor(fx); double wx=fx-x0; int x1=std::min(g.width-1,x0+1);
            x0=std::max(0,x0);
            uint8_t p00=g.RowPtr(y0)[x0], p01=g.RowPtr(y0)[x1];
            uint8_t p10=g.RowPtr(y1)[x0], p11=g.RowPtr(y1)[x1];
            double a = p00*(1-wx)+p01*wx;
            double b = p10*(1-wx)+p11*wx;
            out.RowPtr(y)[x] = (uint8_t)std::round(a*(1-wy)+b*wy);
        }
    }
    return out;
}

// ───── 매칭 메서드/파라미터/결과 ─────
enum class TM_Method { SAD, SSD, NCC, ZNCC };

struct TM_Params{
    TM_Method method = TM_Method::ZNCC;
    bool multiScale = false;
    double scaleMin = 0.5, scaleMax = 1.5, scaleStep = 0.1; // 템플릿 스케일(배)
    int topK = 1;                // 상위 K개 결과
    int nmsRadius = 8;           // NMS 반경(픽셀)
    double scoreThresh = 0.0;    // NCC/ZNCC: 최소 스코어, SAD/SSD: 최대 허용 오차(0이면 사용 안 함)
    bool makeHeatmap = true;     // 히트맵 생성 여부
};

struct TM_Result{
    int x=0, y=0, w=0, h=0;
    double scale=1.0;
    double score=0.0; // 메서드에 따라 "좋음" 방향 다름(SSD/SAD=작을수록, NCC/ZNCC=클수록)
};

// ───── 내부: 응답맵 계산(단일 스케일) ─────
struct ResponseMap{
    int W=0,H=0;                   // 유효 위치 맵 크기 (srcW-tplW+1, srcH-tplH+1)
    std::vector<double> r;         // 크기 W*H
    inline double& at(int x,int y){ return r[(size_t)y*W + x]; }
    inline const double& at(int x,int y) const { return r[(size_t)y*W + x]; }
};

inline ResponseMap MatchSingle(const IppDib& src8, const IppDib& tpl8, TM_Method m){
    ResponseMap M; if(!src8.valid()||!tpl8.valid()) return M;
    const int SW=src8.width, SH=src8.height, TW=tpl8.width, TH=tpl8.height;
    if(TW>SW || TH>SH) return M;
    M.W = SW - TW + 1; M.H = SH - TH + 1; M.r.assign((size_t)M.W*M.H, 0.0);

    // 템플릿 사전 통계
    double sumT=0, sumT2=0;
    for(int v=0; v<TH; ++v){ const uint8_t* t=tpl8.RowPtr(v);
        for(int u=0; u<TW; ++u){ double tv=t[u]; sumT+=tv; sumT2+=tv*tv; } }
    double meanT = sumT/(TW*TH);
    double normT = std::sqrt(std::max(1e-12, sumT2));                   // NCC용
    double varT  = std::max(1e-12, sumT2 - (sumT*sumT)/(TW*TH));        // ZNCC용(분산)

    for(int y=0;y<M.H;++y){
        for(int x=0;x<M.W;++x){
            double sum=0, sumI=0, sumI2=0, sumIT=0;
            for(int v=0; v<TH; ++v){
                const uint8_t* s=src8.RowPtr(y+v);
                const uint8_t* t=tpl8.RowPtr(v);
                for(int u=0; u<TW; ++u){
                    double iv=s[x+u], tv=t[u];
                    if(m==TM_Method::SAD) sum += std::abs(iv-tv);
                    else if(m==TM_Method::SSD){ double d=iv-tv; sum += d*d; }
                    else{
                        sumI  += iv;
                        sumI2 += iv*iv;
                        sumIT += iv*tv;
                    }
                }
            }
            double& R = M.at(x,y);
            if(m==TM_Method::SAD || m==TM_Method::SSD){ R = sum; }
            else if(m==TM_Method::NCC){
                double denom = std::sqrt(std::max(1e-12, sumI2)) * normT;
                R = (denom>0)? (sumIT/denom) : 0.0;
            }else{ // ZNCC
                double meanI = sumI/(TW*TH);
                double num = sumIT - meanI*sumT - meanT*sumI + (TW*TH)*meanI*meanT; // Σ(I-μI)(T-μT)
                double varI = std::max(1e-12, sumI2 - (sumI*sumI)/(TW*TH));
                double denom = std::sqrt(varI*varT);
                R = (denom>0)? (num/denom) : 0.0;
            }
        }
    }
    return M;
}

// ───── NMS(비최대 억제)로 다중 피크 선택 ─────
inline std::vector<TM_Result> SelectTopK(const ResponseMap& M, TM_Method m, int tw,int th, int K, int nmsR,
                                         double scoreThresh=0.0){
    struct Node{ int x,y; double s; };
    std::vector<Node> nodes; nodes.reserve((size_t)M.W*M.H);
    for(int y=0;y<M.H;++y){
        for(int x=0;x<M.W;++x){
            double v=M.at(x,y);
            if(m==TM_Method::SAD || m==TM_Method::SSD){
                // 낮을수록 좋음 → 스코어 임계가 0이면 무시, 양수면 v<=thresh 통과
                if(scoreThresh>0.0 && v>scoreThresh) continue;
            }else{
                // 클수록 좋음 → v>=thresh
                if(v<scoreThresh) continue;
            }
            nodes.push_back({x,y,v});
        }
    }
    // 정렬 방향
    if(m==TM_Method::SAD || m==TM_Method::SSD)
        std::sort(nodes.begin(), nodes.end(), [](const Node&a,const Node&b){ return a.s < b.s; });
    else
        std::sort(nodes.begin(), nodes.end(), [](const Node&a,const Node&b){ return a.s > b.s; });

    std::vector<TM_Result> out;
    auto tooClose=[&](int x,int y){
        for(auto& r:out){ int cx=r.x, cy=r.y;
            if(std::abs(cx-x)<=nmsR && std::abs(cy-y)<=nmsR) return true; }
        return false;
    };
    for(auto &nd : nodes){
        if((int)out.size()>=K) break;
        if(tooClose(nd.x, nd.y)) continue;
        TM_Result r; r.x=nd.x; r.y=nd.y; r.w=tw; r.h=th; r.scale=1.0; r.score=nd.s;
        out.push_back(r);
    }
    return out;
}

// ───── 최상위 API (멀티스케일까지) ─────
inline bool MatchTemplate(const IppDib& src, const IppDib& tpl, const TM_Params& p,
                          std::vector<TM_Result>& results, IppDib* heatmapOut=nullptr)
{
    results.clear(); if(!src.valid()||!tpl.valid()) return false;
    IppDib Sg,Tg; ToGray8(src,Sg); ToGray8(tpl,Tg);

    auto oneScale=[&](const IppDib& gS,const IppDib& gT, double scale){
        ResponseMap M = MatchSingle(gS, gT, p.method);
        if(M.W<=0||M.H<=0) return;
        // 히트맵(선택)
        if(heatmapOut){
            IppDib HM; HM.CreateGray(M.W, M.H);
            // 정규화
            double mn=+std::numeric_limits<double>::infinity(), mx=-mn;
            for(double v: M.r){ mn=std::min(mn,v); mx=std::max(mx,v); }
            if(p.method==TM_Method::SAD || p.method==TM_Method::SSD){
                // 낮을수록 좋음 → 뒤집어 밝게
                double rng = (mx-mn>1e-12? mx-mn : 1.0);
                for(int y=0;y<M.H;++y){ uint8_t* d=HM.RowPtr(y);
                    for(int x=0;x<M.W;++x){ double v=(M.at(x,y)-mn)/rng; d[x]=(uint8_t)std::round((1.0-v)*255); } }
            }else{
                double rng = (mx-mn>1e-12? mx-mn : 1.0);
                for(int y=0;y<M.H;++y){ uint8_t* d=HM.RowPtr(y);
                    for(int x=0;x<M.W;++x){ double v=(M.at(x,y)-mn)/rng; d[x]=(uint8_t)std::round(v*255); } }
            }
            *heatmapOut = HM; // 마지막 스케일 히트맵 보관(필요시 합성 가능)
        }
        // Top-K with NMS
        auto cur = SelectTopK(M, p.method, gT.width, gT.height, std::max(1,p.topK), std::max(0,p.nmsRadius), p.scoreThresh);
        for(auto& r:cur){ r.scale=scale; results.push_back(r); }
    };

    if(!p.multiScale){
        oneScale(Sg,Tg,1.0);
    }else{
        for(double sc=p.scaleMin; sc<=p.scaleMax+1e-12; sc+=p.scaleStep){
            int TW=(int)std::round(Tg.width*sc), TH=(int)std::round(Tg.height*sc);
            if(TW<5 || TH<5) continue; // 너무 작으면 스킵
            if(TW>Sg.width || TH>Sg.height) continue;
            IppDib Tr = ResizeGrayBilinear(Tg, TW, TH);
            oneScale(Sg, Tr, sc);
        }
        // 여러 스케일 결과 → 전역 Top-K로 다시 정리
        if(!results.empty()){
            if(p.method==TM_Method::SAD || p.method==TM_Method::SSD)
                std::sort(results.begin(), results.end(), [](const TM_Result&a,const TM_Result&b){ return a.score<b.score; });
            else
                std::sort(results.begin(), results.end(), [](const TM_Result&a,const TM_Result&b){ return a.score>b.score; });
            if((int)results.size()>p.topK) results.resize(p.topK);
        }
    }
    return !results.empty();
}

// ───── 오버레이(결과 박스/순위 라벨) ─────
inline IppDib MakeTMOverlay(const IppDib& src, const std::vector<TM_Result>& rs){
    IppDib out;
    if(src.bpp==24) out=src;
    else{
        out.CreateColor(src.width, src.height);
        for(int y=0;y<src.height;++y){
            uint8_t* d=out.RowPtr(y); const uint8_t* s=src.RowPtr(y);
            for(int x=0;x<src.width;++x){ d[x*3+0]=d[x*3+1]=d[x*3+2]=s[x]; }
        }
    }
    for(size_t i=0;i<rs.size();++i){
        uint8_t B=32,G=255,R=64;
        if(i==0){ B=255;G=64;R=64; } // 1위: 빨강
        DrawRect24(out, rs[i].x, rs[i].y, rs[i].w, rs[i].h, B,G,R, 2);
    }
    return out;
}
```

---

## C) 대화 상자 — **템플릿 파일 선택 · 메서드/탑K/NMS/멀티스케일/임계값**

`TemplateMatchDialog.hpp`, `resource.h`, `ImageTool.rc`

### C-1) 리소스 ID — `resource.h` 추가

```cpp
// resource.h (추가)
#pragma once
#define ID_TMATCH_DLG          27010

#define IDD_TMATCH             27020
#define IDC_TM_FILE            27021
#define IDC_TM_BROWSE          27022
#define IDC_TM_METHOD          27023
#define IDC_TM_TOPK            27024
#define IDC_TM_NMSR            27025
#define IDC_TM_THRESH          27026
#define IDC_TM_HEATMAP         27027

#define IDC_TM_MS_ENABLE       27028
#define IDC_TM_MS_MIN          27029
#define IDC_TM_MS_MAX          27030
#define IDC_TM_MS_STEP         27031

#define IDC_TM_INFO            27032

```

### C-2) RC 레이아웃 — `ImageTool.rc`

```rc
// ImageTool.rc (추가)
#include "resource.h"
#include <windows.h>

IDD_TMATCH DIALOGEX 0,0, 276, 178
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "템플릿 매칭"
FONT 9, "Segoe UI", 0, 0, 0x1
BEGIN
    LTEXT  "템플릿 파일:", -1, 8, 12, 56, 10
    EDITTEXT IDC_TM_FILE, 64, 10, 154, 14, ES_AUTOHSCROLL | WS_TABSTOP
    PUSHBUTTON "찾기…",   IDC_TM_BROWSE, 222, 10, 46, 14, WS_TABSTOP

    LTEXT  "메서드:", -1, 8, 34, 36, 10
    COMBOBOX IDC_TM_METHOD, 64, 32, 80, 70, CBS_DROPDOWNLIST | WS_TABSTOP

    LTEXT  "TopK:", -1, 152, 34, 24, 10
    EDITTEXT IDC_TM_TOPK, 180, 32, 28, 14, ES_AUTOHSCROLL | WS_TABSTOP

    LTEXT  "NMS 반경:", -1, 212, 34, 44, 10
    EDITTEXT IDC_TM_NMSR, 258, 32, 10, 14, ES_AUTOHSCROLL | WS_TABSTOP

    LTEXT  "임계값:", -1, 8, 56, 30, 10
    EDITTEXT IDC_TM_THRESH, 64, 54, 46, 14, ES_AUTOHSCROLL | WS_TABSTOP
    CONTROL "히트맵 생성", IDC_TM_HEATMAP, "Button", BS_AUTOCHECKBOX | WS_TABSTOP, 120, 56, 64, 10

    GROUPBOX "멀티스케일", -1, 8, 76, 260, 48
    CONTROL "사용", IDC_TM_MS_ENABLE, "Button", BS_AUTOCHECKBOX | WS_TABSTOP, 16, 90, 28, 10
    LTEXT  "min:", -1, 48, 90, 18, 10
    EDITTEXT IDC_TM_MS_MIN, 68, 88, 34, 14, ES_AUTOHSCROLL | WS_TABSTOP
    LTEXT  "max:", -1, 108, 90, 18, 10
    EDITTEXT IDC_TM_MS_MAX, 128, 88, 34, 14, ES_AUTOHSCROLL | WS_TABSTOP
    LTEXT  "step:", -1, 168, 90, 22, 10
    EDITTEXT IDC_TM_MS_STEP, 192, 88, 34, 14, ES_AUTOHSCROLL | WS_TABSTOP

    LTEXT "", IDC_TM_INFO, 8, 130, 260, 12

    DEFPUSHBUTTON "확인", IDOK,     152, 152, 56, 16, WS_TABSTOP
    PUSHBUTTON    "취소", IDCANCEL, 212, 152, 56, 16, WS_TABSTOP
END
```

### C-3) 대화 상자 로직 — `TemplateMatchDialog.hpp`

```cpp
// TemplateMatchDialog.hpp
#pragma once
#define UNICODE
#define _UNICODE
#include <windows.h>
#include <commdlg.h>
#include <cwchar>
#include "resource.h"
#include "TemplateMatch.hpp"

struct TMatchDialogResult{
    bool ok=false; TM_Params p; std::wstring path;
};

inline void TM_UpdateInfo(HWND hDlg, const TMatchDialogResult& D){
    const wchar_t* m=L"";
    switch(D.p.method){
        case TM_Method::SAD:  m=L"SAD"; break;
        case TM_Method::SSD:  m=L"SSD"; break;
        case TM_Method::NCC:  m=L"NCC"; break;
        case TM_Method::ZNCC: m=L"ZNCC"; break;
    }
    wchar_t buf[280];
    swprintf(buf,280,L"%s, TopK=%d, NMS=%d, Th=%.3f, MS=%s(%.2f~%.2f:%.2f), Heatmap=%s",
        m, D.p.topK, D.p.nmsRadius, D.p.scoreThresh,
        D.p.multiScale?L"On":L"Off", D.p.scaleMin, D.p.scaleMax, D.p.scaleStep,
        D.p.makeHeatmap?L"On":L"Off");
    SetWindowTextW(GetDlgItem(hDlg, IDC_TM_INFO), buf);
}

inline bool BrowseTemplateFile(HWND hDlg, std::wstring& outPath){
    wchar_t buf[MAX_PATH]=L"";
    OPENFILENAMEW ofn{}; ofn.lStructSize=sizeof(ofn);
    ofn.hwndOwner=hDlg;
    ofn.lpstrFilter=L"BMP Files (*.bmp)\0*.bmp\0All Files (*.*)\0*.*\0\0";
    ofn.nFilterIndex=1;
    ofn.lpstrFile=buf; ofn.nMaxFile=MAX_PATH;
    ofn.Flags=OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY;
    if(GetOpenFileNameW(&ofn)){ outPath=buf; return true; }
    return false;
}

inline bool ShowTMatchDialog(HWND hOwner, TMatchDialogResult* out){
    if(!out) return false; *out=TMatchDialogResult{};
    INT_PTR ret = DialogBoxParamW((HINSTANCE)GetModuleHandle(nullptr),
                                  MAKEINTRESOURCE(IDD_TMATCH),
                                  hOwner,
        [](HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)->INT_PTR{
            static TMatchDialogResult* P=nullptr;
            switch(msg){
            case WM_INITDIALOG:{
                P = new TMatchDialogResult(); P->p = TM_Params{};
                // 메서드 콤보
                HWND c=GetDlgItem(hDlg, IDC_TM_METHOD);
                SendMessageW(c, CB_ADDSTRING, 0, (LPARAM)L"SAD");
                SendMessageW(c, CB_ADDSTRING, 0, (LPARAM)L"SSD");
                SendMessageW(c, CB_ADDSTRING, 0, (LPARAM)L"NCC");
                SendMessageW(c, CB_ADDSTRING, 0, (LPARAM)L"ZNCC");
                SendMessageW(c, CB_SETCURSEL, 3, 0); // 기본 ZNCC
                SetDlgItemTextW(hDlg, IDC_TM_TOPK, L"1");
                SetDlgItemTextW(hDlg, IDC_TM_NMSR, L"8");
                SetDlgItemTextW(hDlg, IDC_TM_THRESH, L"0.8"); // NCC/ZNCC 기준
                SendDlgItemMessageW(hDlg, IDC_TM_HEATMAP, BM_SETCHECK, BST_CHECKED, 0);
                // 멀티스케일
                SendDlgItemMessageW(hDlg, IDC_TM_MS_ENABLE, BM_SETCHECK, BST_UNCHECKED, 0);
                SetDlgItemTextW(hDlg, IDC_TM_MS_MIN,  L"0.7");
                SetDlgItemTextW(hDlg, IDC_TM_MS_MAX,  L"1.3");
                SetDlgItemTextW(hDlg, IDC_TM_MS_STEP, L"0.1");
                TM_UpdateInfo(hDlg, *P);
                return TRUE;
            }
            case WM_COMMAND:{
                switch(LOWORD(wParam)){
                case IDC_TM_BROWSE:{
                    std::wstring p; if(BrowseTemplateFile(hDlg,p)){ SetDlgItemTextW(hDlg, IDC_TM_FILE, p.c_str()); }
                    return TRUE;
                }
                case IDC_TM_METHOD:
                case IDC_TM_TOPK:
                case IDC_TM_NMSR:
                case IDC_TM_THRESH:
                case IDC_TM_HEATMAP:
                case IDC_TM_MS_ENABLE:
                case IDC_TM_MS_MIN:
                case IDC_TM_MS_MAX:
                case IDC_TM_MS_STEP:
                    if(LOWORD(wParam)==IDC_TM_METHOD && HIWORD(wParam)!=CBN_SELCHANGE) break;
                    // 읽어오기
                    int sel=(int)SendMessageW(GetDlgItem(hDlg, IDC_TM_METHOD), CB_GETCURSEL, 0,0);
                    P->p.method=(sel==0?TM_Method::SAD: sel==1?TM_Method::SSD: sel==2?TM_Method::NCC: TM_Method::ZNCC);
                    wchar_t t[32],*e=nullptr;
                    GetDlgItemTextW(hDlg, IDC_TM_TOPK, t,32); long k=wcstol(t,&e,10); if(e==t||k<1) k=1; P->p.topK=(int)k;
                    GetDlgItemTextW(hDlg, IDC_TM_NMSR, t,32); long r=wcstol(t,&e,10); if(e==t||r<0) r=0; P->p.nmsRadius=(int)r;
                    GetDlgItemTextW(hDlg, IDC_TM_THRESH, t,32); double th=wcstod(t,&e); if(e==t) th=0.0; P->p.scoreThresh=th;
                    P->p.makeHeatmap = (IsDlgButtonChecked(hDlg, IDC_TM_HEATMAP)==BST_CHECKED);
                    P->p.multiScale  = (IsDlgButtonChecked(hDlg, IDC_TM_MS_ENABLE)==BST_CHECKED);
                    GetDlgItemTextW(hDlg, IDC_TM_MS_MIN,  t,32); double mn=wcstod(t,&e); if(e==t||mn<=0) mn=1.0; P->p.scaleMin=mn;
                    GetDlgItemTextW(hDlg, IDC_TM_MS_MAX,  t,32); double mx=wcstod(t,&e); if(e==t||mx<mn) mx=mn; P->p.scaleMax=mx;
                    GetDlgItemTextW(hDlg, IDC_TM_MS_STEP, t,32); double st=wcstod(t,&e); if(e==t||st<=0) st=0.1; P->p.scaleStep=st;
                    TM_UpdateInfo(hDlg, *P);
                    return TRUE;

                case IDOK:{
                    wchar_t path[MAX_PATH]; GetDlgItemTextW(hDlg, IDC_TM_FILE, path, MAX_PATH);
                    if(wcslen(path)==0){ MessageBoxW(hDlg, L"템플릿 BMP 파일을 선택하세요.", L"안내", MB_OK|MB_ICONINFORMATION); return TRUE; }
                    P->path=path;
                    SetWindowLongPtrW(hDlg, DWLP_USER, (LONG_PTR)P);
                    EndDialog(hDlg, IDOK); return TRUE;
                }
                case IDCANCEL:{
                    delete P; P=nullptr; EndDialog(hDlg, IDCANCEL); return TRUE;
                }
                }
            } break;
            }
            return FALSE;
        }, 0);
    if(ret!=IDOK) return false;
    TMatchDialogResult* P=(TMatchDialogResult*)GetWindowLongPtrW(GetActiveWindow(), DWLP_USER);
    if(!P) return false;
    *out=*P; delete P; return true;
}
```

---

## D) 템플릿 매칭 메뉴 만들기 & 실행 핸들러

### D-1) 메뉴 항목 추가

```cpp
// BuildMenuBar() 등 "분석(&A)" 그룹에 추가
AppendMenuW(mpAnalysis, MF_STRING, ID_TMATCH_DLG, L"템플릿 매칭…");
```

### D-2) 실행 코드 — `ImageMulti.cpp` 발췌

```cpp
#include "TemplateMatch.hpp"
#include "TemplateMatchDialog.hpp"

// ...
case ID_TMATCH_DLG:{
    if(!st->image.valid()){
        MessageBoxW(hWnd, L"먼저 이미지를 여세요.", L"안내", MB_OK|MB_ICONINFORMATION);
        break;
    }
    TMatchDialogResult D;
    if(!ShowTMatchDialog(hWnd, &D)) break;

    IppDib tpl;
    if(!tpl.Load(D.path.c_str()) || !tpl.valid()){
        MessageBoxW(hWnd, L"템플릿을 불러오지 못했습니다.", L"오류", MB_OK|MB_ICONERROR);
        break;
    }

    // 매칭
    std::vector<TM_Result> hits;
    IppDib heat; IppDib* pHeat = D.p.makeHeatmap? &heat : nullptr;
    if(!MatchTemplate(st->image, tpl, D.p, hits, pHeat)){
        MessageBoxW(hWnd, L"매칭 결과가 없습니다(조건을 완화해 보세요).", L"결과", MB_OK|MB_ICONINFORMATION);
        break;
    }

    // 결과 로그
    LogToEdit(st->hLog, L"== Template Matching ==\r\n");
    const wchar_t* m=L""; switch(D.p.method){
        case TM_Method::SAD: m=L"SAD"; break; case TM_Method::SSD: m=L"SSD"; break;
        case TM_Method::NCC: m=L"NCC"; break; case TM_Method::ZNCC: m=L"ZNCC"; break;
    }
    wchar_t line[256];
    for(size_t i=0;i<hits.size();++i){
        swprintf(line,256,L"[%zu] (%d,%d) size=(%d×%d) scale=%.2f  score=% .6e\r\n",
                 i+1, hits[i].x, hits[i].y, hits[i].w, hits[i].h, hits[i].scale, hits[i].score);
        LogToEdit(st->hLog, line);
    }

    // 오버레이/히트맵 표시
    IppDib overlay = MakeTMOverlay(st->image, hits);
    OpenNewDocWithImage(overlay, L"[TM] Overlay");
    if(pHeat && heat.valid()) OpenNewDocWithImage(heat, L"[TM] Heatmap");

    StatusSetInfo(st->hStatus, overlay, st->zoomPct, L"Template matching done");
    InvalidateRect(hWnd, nullptr, TRUE);
} break;
```

---

## E) 사용 가이드 & 팁

1. **메서드 선택**
   - **ZNCC**: 일반적으로 가장 견고(밝기 오프셋/스케일 변화에 강함).
   - **NCC**: 조명 변화가 크지 않을 때 빠르고 안정적.
   - **SAD/SSD**: 간단/빠름(소규모 템플릿에서 유리) — **값이 낮을수록 일치**.
2. **임계값(Threshold)**
   - **ZNCC/NCC**: 0.7~0.9 정도부터 후보로 보기 좋음.
   - **SAD/SSD**: 템플릿 크기에 따라 값이 커지므로 보정 어려움(보통 **TopK만** 사용).
3. **TopK + NMS**
   - **겹치는 후보**가 많은 경우 **NMS 반경**을 템플릿 폭/높이의 10~30%로 설정.
4. **멀티스케일**
   - 피사체 크기 변화가 예상되면 활성화하고, `min/max/step`을 좁게 잡아 시간 절약.
5. **속도 향상**
   - 작은 템플릿 사용 / 탐색 ROI 제한 / 템플릿 및 영상 **전처리(블러, 정규화)**.
   - SSD/NCC는 이론상 **컨볼루션/FFT**나 **적분영상(∑I, ∑I²)**로 가속 가능(본 예제는 이해를 위해 범용 루프 제공).

---

## F) 간단 테스트 시나리오

- 로고/아이콘 템플릿(BMP)을 선택 → **ZNCC**, `TopK=5`, `NMS=10`, `Th=0.85` → Overlay 창에서 상위 후보 박스 확인.
- 크기가 다른 물체 → **멀티스케일 On**(`0.8~1.2:0.05`) → 가장 높은 스코어 후보가 실제 위치에 있는지 확인.
- 명암이 다른 상황 → **ZNCC**로 전환해 강인성 비교.

---

## G) 파일 구성 요약

```
/ (프로젝트 루트)
 ├─ TemplateMatch.hpp        // ★ 매칭 코어(SAD/SSD/NCC/ZNCC) + NMS + 히트맵/오버레이
 ├─ TemplateMatchDialog.hpp  // ★ 옵션 대화 상자(파일/메서드/TopK/NMS/멀티스케일/임계/히트맵)
 ├─ resource.h               // ★ ID_TMATCH_DLG, 컨트롤 IDs
 ├─ ImageTool.rc             // ★ 대화 상자 레이아웃
 └─ ImageMulti.cpp           // 메뉴 추가 + WM_COMMAND 처리
```

---

## H) (부록) 정확도/안정성 메모

- **ZNCC 수치 안정성**: 분모(분산)가 0에 가까우면 0으로 처리(코드에 1e-12 가드).
- **좌표 오프셋**: 정교한 서브픽셀 정합은 응답맵 주변을 2차 보간하여 최대/최소를 재추정(추가 구현 가능).
- **컬러 템플릿**: 현재는 그레이로 변환 후 사용. 필요하면 채널별 NCC 후 평균하는 방식으로 확장.
