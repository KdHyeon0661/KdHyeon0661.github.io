---
layout: post
title: 영상처리 - 비트 평면 분할
date: 2025-09-23 16:25:23 +0900
category: 영상처리
---
# 비트 평면 분할

_목표: 8-bit 채널을 **비트 평면(bit-plane)** 으로 쪼개서(0~7레벨) 단일 평면 또는 전체 8장을 새 창으로 띄우는 기능을 구현하고, 메뉴/이벤트로 연동합니다. 또한 **모든 창 닫기(Close All)** 를 안전하게 구현합니다._

> 전제  
> - Win32(비-MFC) 기반 **ImageTool** 프로젝트  
> - 영상은 `IppDib` (Top-Down BGRA32) 사용  
> - 다중 문서(다중 프레임) 구조, `DocRegistry`(열린 문서 레지스트리) 사용  
> - 수식은 **MathJax**, 코드는 **한 번만** ``` 로 감쌉니다.

---

## 1) 비트 평면이란?

8-bit 픽셀(그레이스케일 값 또는 B/G/R 채널 값) \(v\in\{0,\dots,255\}\) 는 8개의 비트로 표현됩니다.

\[
v=\sum_{k=0}^{7} b_k\,2^k,\qquad b_k\in\{0,1\}
\]

- \(k=0\): 최하위 비트(LSB, **bit 0**). 미세한 노이즈·질감 보유.  
- \(k=7\): 최상위 비트(MSB, **bit 7**). 전체 밝기/형태에 가장 큰 영향.

**비트 평면 분할(bit-plane slicing)** 은 각 \(b_k\) 를 **독립 영상**으로 분리합니다.  
각 평면 이미지는 \(b_k\) 를 **0→0, 1→255** 로 확장해 시각화합니다.

- 컬러(BGRA32)는 보통 **B/G/R 개별 평면** 또는 **휘도(Luma)** \(\,Y\approx 0.299R+0.587G+0.114B\,\) 의 평면을 사용합니다.

---

## 2) 핵심 API 설계

- **채널 선택**: B, G, R, Luma  
- **평면 선택**: 0~7  
- **출력 옵션**: 선택 평면 1장 / 전체 8장  
- **출력 형식**: BGRA32 그레이(0/255) 이미지 (R=G=B=0 또는 255, A=255)

아래는 **실제 구현 코드**입니다.

```cpp
// BitPlane.h
#pragma once
#include <cstdint>
#include <algorithm>
#include <vector>
#include <string>
#include "IppDib.h"

enum class BitPlaneChannel { Blue, Green, Red, Luma };

// 0..255 정수 클램프
inline uint8_t clamp_u8(int v){ return (uint8_t)std::min(255, std::max(0, v)); }

// 한 픽셀에서 채널 값 얻기(BGRA32)
inline int get_channel_BGRA32(const uint8_t* p, BitPlaneChannel ch) {
    switch (ch) {
    case BitPlaneChannel::Blue:  return p[0];
    case BitPlaneChannel::Green: return p[1];
    case BitPlaneChannel::Red:   return p[2];
    case BitPlaneChannel::Luma: {
        int B=p[0], G=p[1], R=p[2];
        int Y = (int)std::lround(0.299*R + 0.587*G + 0.114*B);
        return clamp_u8(Y);
    }}
    return 0;
}

// 선택 비트 평면 추출 → dst는 BGRA32 그레이(0/255)
inline bool ExtractBitPlane(const IppDib& src, IppDib& dst,
                            BitPlaneChannel ch, int bit /*0..7*/)
{
    if (!src || bit<0 || bit>7) return false;
    dst.create(src.width(), src.height(), 32);
    for (int y=0; y<src.height(); ++y) {
        const uint8_t* rs = (const uint8_t*)src.bits() + (size_t)y*src.stride();
        uint8_t*       rd = (uint8_t*)dst.bits() + (size_t)y*dst.stride();
        for (int x=0; x<src.width(); ++x) {
            const uint8_t* ps = &rs[x*4];
            uint8_t*       pd = &rd[x*4];
            int v = get_channel_BGRA32(ps, ch);
            int b = ( (v >> bit) & 1 ) ? 255 : 0;
            pd[0]=pd[1]=pd[2]=(uint8_t)b; // Gray
            pd[3]=255;
        }
    }
    return true;
}

// 전체 8개 평면(0..7) 추출
inline bool ExtractAllBitPlanes(const IppDib& src, BitPlaneChannel ch,
                                std::vector<IppDib>& out8)
{
    out8.clear(); out8.resize(8);
    if (!src) return false;
    for (int bit=0; bit<8; ++bit) {
        if (!ExtractBitPlane(src, out8[bit], ch, bit)) return false;
    }
    return true;
}
```

**설명**  
- `ExtractBitPlane` 은 입력 `src` 에서 채널 값을 읽고, 선택한 **bit** 만 추출해 `0/255` 로 만든 BGRA32를 `dst`에 씁니다.  
- `ExtractAllBitPlanes` 는 **0..7** 전부를 `std::vector<IppDib>` 으로 반환합니다.

---

## 3) 비트 평면 분할 대화 상자

- **채널**: B/G/R/Luma (Radio)  
- **비트**: 0~7 (트랙바 + 에디트)  
- **동작 버튼**:  
  - “Extract Selected (New window)”  
  - “Extract All 8 (New windows)”

### 3.1 리소스 ID/RC

```cpp
// resource.h (추가)
#define IDD_BITPLANE_DIALOG           520
#define IDC_RADIO_BP_B                1301
#define IDC_RADIO_BP_G                1302
#define IDC_RADIO_BP_R                1303
#define IDC_RADIO_BP_LUMA             1304
#define IDC_SLIDER_BIT                1310
#define IDC_EDIT_BIT                  1311
#define IDC_BTN_EXTRACT_SELECTED      1320
#define IDC_BTN_EXTRACT_ALL           1321
#define IDC_STAT_BP_INFO              1330

// 메뉴 명령
#define ID_IMAGE_BITPLANE_DIALOG      480

// (추가) File → Close All
#define ID_FILE_CLOSEALL              31010
```

```rc
// ImageTool.rc (추가)
IDD_BITPLANE_DIALOG DIALOGEX 0,0, 300, 160
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Bit-Plane Slicing"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Channel", -1, 10, 10, 120, 60
    AUTORADIOBUTTON "Blue",  IDC_RADIO_BP_B,    18, 24, 80, 10, WS_TABSTOP
    AUTORADIOBUTTON "Green", IDC_RADIO_BP_G,    18, 38, 80, 10
    AUTORADIOBUTTON "Red",   IDC_RADIO_BP_R,    18, 52, 80, 10
    AUTORADIOBUTTON "Luma",  IDC_RADIO_BP_LUMA, 18, 66, 80, 10

    LTEXT "Bit (0..7):", -1, 150, 16, 50, 10
    CONTROL "", IDC_SLIDER_BIT, TRACKBAR_CLASS, WS_TABSTOP | TBS_AUTOTICKS, 150, 28, 120, 16
    EDITTEXT IDC_EDIT_BIT, 205, 48, 30, 14, ES_NUMBER | WS_TABSTOP

    PUSHBUTTON "Extract Selected", IDC_BTN_EXTRACT_SELECTED, 150, 76, 120, 14
    PUSHBUTTON "Extract All 8",    IDC_BTN_EXTRACT_ALL,      150, 94, 120, 14

    LTEXT "", IDC_STAT_BP_INFO, 10, 120, 280, 12, SS_LEFT

    DEFPUSHBUTTON "Close", IDCANCEL, 220, 138, 50, 14
END

// 메뉴 (일부)
POPUP "&File"
BEGIN
    MENUITEM "Close All Windows\tCtrl+Shift+W", ID_FILE_CLOSEALL
    MENUITEM SEPARATOR
    // ... (기존 항목)
END

POPUP "&Image"
BEGIN
    MENUITEM "Bit-Plane Slicing...\tCtrl+P", ID_IMAGE_BITPLANE_DIALOG
    // ... (기존 항목)
END

IDR_ACCEL ACCELERATORS
BEGIN
    "P", ID_IMAGE_BITPLANE_DIALOG, VIRTKEY, CONTROL
    "W", ID_FILE_CLOSEALL,         VIRTKEY, CONTROL, SHIFT
END
```

### 3.2 대화 상자 클래스

```cpp
// BitPlaneDlg.h
#pragma once
#include <windows.h>
#include <commctrl.h>
#include "resource.h"
#include "BitPlane.h"
#include "DocRegistry.h" // 새 창 등록/갱신 용
#include "IppDib.h"

// 새 창 생성 & DIB 복사(여러분의 CreateFrame/Update 로직에 맞게 조정)
HWND OpenNewFromDIB(const IppDib& src);

class BitPlaneDlg {
public:
    BitPlaneDlg(HWND owner, IppDib& src) : owner_(owner), src_(src) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);
    INT_PTR OnHScroll(HWND h, WPARAM, LPARAM l);

    BitPlaneChannel Channel(HWND h) const;
    int  BitIndex(HWND h) const;
    void SetBit(HWND h, int k);
    void UpdateInfo(HWND h);

    void ExtractSelected(HWND h);
    void ExtractAll(HWND h);

private:
    HWND owner_ = nullptr;
    HWND hDlg_  = nullptr;
    IppDib& src_;
};
```

```cpp
// BitPlaneDlg.cpp
#include "BitPlaneDlg.h"

INT_PTR BitPlaneDlg::DoModal() {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_BITPLANE_DIALOG),
                           owner_, DlgProc, (LPARAM)this);
}

INT_PTR CALLBACK BitPlaneDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m==WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self = (BitPlaneDlg*)l;
        self->hDlg_ = h;
        return self->OnInit(h);
    }
    auto* self = (BitPlaneDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;

    switch (m) {
    case WM_COMMAND: return self->OnCommand(h, w, l);
    case WM_HSCROLL: return self->OnHScroll(h, w, l);
    default: return FALSE;
    }
}

INT_PTR BitPlaneDlg::OnInit(HWND h) {
    // 기본 채널: Luma, 기본 비트: 7 (MSB)
    CheckRadioButton(h, IDC_RADIO_BP_B, IDC_RADIO_BP_LUMA, IDC_RADIO_BP_LUMA);
    SendDlgItemMessageW(h, IDC_SLIDER_BIT, TBM_SETRANGE, TRUE, MAKELPARAM(0,7));
    SendDlgItemMessageW(h, IDC_SLIDER_BIT, TBM_SETPOS, TRUE, 7);
    SetDlgItemInt(h, IDC_EDIT_BIT, 7, FALSE);
    UpdateInfo(h);
    return TRUE;
}

BitPlaneChannel BitPlaneDlg::Channel(HWND h) const {
    if (IsDlgButtonChecked(h, IDC_RADIO_BP_B)==BST_CHECKED) return BitPlaneChannel::Blue;
    if (IsDlgButtonChecked(h, IDC_RADIO_BP_G)==BST_CHECKED) return BitPlaneChannel::Green;
    if (IsDlgButtonChecked(h, IDC_RADIO_BP_R)==BST_CHECKED) return BitPlaneChannel::Red;
    return BitPlaneChannel::Luma;
}
int BitPlaneDlg::BitIndex(HWND h) const {
    BOOL ok=FALSE; int k=GetDlgItemInt(h, IDC_EDIT_BIT, &ok, FALSE);
    if (!ok) k=(int)SendDlgItemMessageW(h, IDC_SLIDER_BIT, TBM_GETPOS, 0, 0);
    if (k<0) k=0; if (k>7) k=7; return k;
}
void BitPlaneDlg::SetBit(HWND h, int k) {
    if (k<0) k=0; if (k>7) k=7;
    SendDlgItemMessageW(h, IDC_SLIDER_BIT, TBM_SETPOS, TRUE, k);
    SetDlgItemInt(h, IDC_EDIT_BIT, k, FALSE);
    UpdateInfo(h);
}
void BitPlaneDlg::UpdateInfo(HWND h) {
    wchar_t buf[256];
    swprintf(buf, 256, L"Source: %dx%d  |  Bit: %d", src_.width(), src_.height(), BitIndex(h));
    SetDlgItemTextW(h, IDC_STAT_BP_INFO, buf);
}

INT_PTR BitPlaneDlg::OnHScroll(HWND h, WPARAM, LPARAM l) {
    if ((HWND)l == GetDlgItem(h, IDC_SLIDER_BIT)) {
        int k = (int)SendDlgItemMessageW(h, IDC_SLIDER_BIT, TBM_GETPOS, 0, 0);
        SetDlgItemInt(h, IDC_EDIT_BIT, k, FALSE);
        UpdateInfo(h);
        return TRUE;
    }
    return FALSE;
}

void BitPlaneDlg::ExtractSelected(HWND) {
    int k = BitIndex(hDlg_);
    BitPlaneChannel ch = Channel(hDlg_);
    IppDib out; 
    if (!ExtractBitPlane(src_, out, ch, k)) {
        MessageBoxW(hDlg_, L"추출 실패", L"Bit-Plane", MB_OK|MB_ICONERROR);
        return;
    }
    HWND hNew = OpenNewFromDIB(out);
    if (!hNew) {
        MessageBoxW(hDlg_, L"새 창 생성 실패", L"Bit-Plane", MB_OK|MB_ICONERROR);
    }
}
void BitPlaneDlg::ExtractAll(HWND) {
    BitPlaneChannel ch = Channel(hDlg_);
    std::vector<IppDib> planes;
    if (!ExtractAllBitPlanes(src_, ch, planes)) {
        MessageBoxW(hDlg_, L"추출 실패", L"Bit-Plane", MB_OK|MB_ICONERROR);
        return;
    }
    for (int k=0;k<8;++k) {
        HWND hNew = OpenNewFromDIB(planes[k]);
        if (!hNew) { MessageBoxW(hDlg_, L"일부 창 생성 실패", L"Bit-Plane", MB_OK|MB_ICONWARNING); break; }
        // 창 제목 업데이트(선택): "Bit k"
        std::wstring title = L"Bit-plane " + std::to_wstring(k);
        SetWindowTextW(hNew, title.c_str());
        // DocRegistry 갱신은 OpenNewFromDIB 내부 또는 여기서 수행
    }
}

INT_PTR BitPlaneDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)) {
    case IDC_EDIT_BIT:
        if (HIWORD(w)==EN_CHANGE) {
            BOOL ok=FALSE; int k=GetDlgItemInt(h, IDC_EDIT_BIT, &ok, FALSE);
            if (!ok) return TRUE;
            SetBit(h, k);
            return TRUE;
        }
        break;
    case IDC_BTN_EXTRACT_SELECTED:
        ExtractSelected(h);
        return TRUE;
    case IDC_BTN_EXTRACT_ALL:
        ExtractAll(h);
        return TRUE;
    case IDCANCEL:
        EndDialog(h, IDCANCEL);
        return TRUE;
    }
    return FALSE;
}
```

### 3.3 “새 창 열기” 헬퍼

여러분 프로젝트의 프레임 생성기를 활용해, **결과 DIB** 를 새 프레임에 복사합니다.

```cpp
// NewWindowFromDIB.h / .cpp  (예시)
// 기존 CreateFrame(), ViewState{IppDib dib; ...} 가 있다고 가정
#include "IppDib.h"
#include "DocRegistry.h"

// 외부 제공(프로젝트 함수)
HWND CreateFrame(); // 프레임 생성 (ViewState 할당/문서 등록까지)

// src를 복사하여 새 창에 표시
HWND OpenNewFromDIB(const IppDib& src) {
    HWND h = CreateFrame();
    if (!h) return nullptr;
    auto* st = (decltype((ViewState*)nullptr))GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!st) return nullptr;

    st->dib.create(src.width(), src.height(), 32);
    for (int y=0; y<src.height(); ++y) {
        const uint8_t* s = (const uint8_t*)src.bits() + (size_t)y*src.stride();
        uint8_t*       d = (uint8_t*)st->dib.bits() + (size_t)y*st->dib.stride();
        std::memcpy(d, s, (size_t)st->dib.stride());
    }
    // 타이틀/레지스트리 갱신
    SetWindowTextW(h, L"ImageTool - (bit-plane)");
    DocRegistry::Update(h, L"ImageTool - (bit-plane)", st->dib.width(), st->dib.height());

    InvalidateRect(h, nullptr, FALSE);
    UpdateWindow(h);
    return h;
}
```

---

## 4) 메뉴 및 이벤트 처리기 추가

메뉴/단축키는 이미 RC에 추가했습니다. 이제 **WndProc** 에서 명령을 처리합니다.

```cpp
// main_multiwin.cpp (발췌)
#include "BitPlaneDlg.h"

// ...
case ID_IMAGE_BITPLANE_DIALOG:
    if (st && st->dib) {
        BitPlaneDlg dlg(hWnd, st->dib);
        dlg.DoModal();
        // 비트 평면은 새 창으로 출력하므로 현재 창 수정 없음.
    }
    return 0;
```

---

## 5) “모든 창 닫기” 기능

여러 프레임을 **안전하게** 닫으려면, 닫는 동안 레지스트리가 변하므로 **사본 목록**을 먼저 만든 뒤 `PostMessage(h, WM_CLOSE, ...)` 를 보냅니다.

### 5.1 DocRegistry: 전체 나열 API

```cpp
// DocRegistry.h (추가)
namespace DocRegistry {
    std::vector<HWND> ListAllHWNDs(); // 모든 HWND 반환
}
```

```cpp
// DocRegistry.cpp (추가)
std::vector<HWND> DocRegistry::ListAllHWNDs() {
    std::lock_guard<std::mutex> lk(g_mtx);
    std::vector<HWND> out; out.reserve(g_docs.size());
    for (auto& d : g_docs) if (d.hwnd) out.push_back(d.hwnd);
    return out;
}
```

### 5.2 메뉴 핸들러

```cpp
// main_multiwin.cpp (발췌)
#include "DocRegistry.h"

// ...
case ID_FILE_CLOSEALL:
{
    // 사본 목록
    auto list = DocRegistry::ListAllHWNDs();
    // 현재 메시지 루프가 있는 창부터 닫히면 자기 자신도 사라짐 → PostMessage로 비동기 요청
    for (HWND w : list) {
        if (IsWindow(w)) PostMessageW(w, WM_CLOSE, 0, 0);
    }
    return 0;
}
```

> 팁  
> - 저장/변경 확인(“Save changes?”) 등이 있다면, 각 프레임의 `WM_CLOSE` 처리에서 묻도록 합니다.  
> - 문서가 많을 때 사용자 확인 다이얼로그(“정말 모두 닫을까요?”)를 추가해도 좋습니다.

---

## 6) 동작 예제 & 상황

### 예제 1: 로고 이미지의 비트 평면 관찰
- **상황**: 흰 배경 위 검정 로고(B/W)에 약간의 JPEG 노이즈가 섞인 이미지.  
- **동작**: `Image → Bit-Plane Slicing…` → 채널 **Luma**, **bit 7** 선택 → *Extract Selected*  
  - **결과**: MSB(7)는 로고 형태가 또렷이 나타남.  
  - **bit 0~2** 를 추가로 추출하면 배경 노이즈 점들이 눈에 띄며, 원본의 미세 노이즈가 **LSB** 평면에 집중됨을 확인.

### 예제 2: 컬러 사진의 채널별 평면 비교
- **상황**: 푸른 하늘, 초록 숲, 빨간 간판이 있는 풍경.  
- **동작**: 채널 **Blue** 선택 후 *Extract All 8* → 8개 창. 같은 과정으로 **Green**, **Red** 도 비교.  
  - **결과**:  
    - Blue 채널 상위 비트 평면에는 하늘 구조가 더 강조.  
    - Red 채널 상위 비트 평면에는 간판의 구조가 뚜렷.  
    - 저위 비트 평면들은 텍스처/노이즈가 주로 보임.

### 예제 3: 마스크 제작
- **상황**: 문서 스캔(텍스트 대비 낮음).  
- **동작**: **Luma** 채널에서 **bit 7/6** 을 추출해 두 창을 살펴본 뒤, 문자인식(Threshold) 전처리 마스크로 활용.  
  - **결과**: 특정 비트 평면을 마스크로 쓰면 **균등화/스트레치** 없이도 글자 영역이 선명하게 분리될 때가 있음.

### 예제 4: 모든 창 닫기
- **상황**: 비트 평면 8장을 여러 세트로 띄워 난잡해진 상태.  
- **동작**: `File → Close All Windows (Ctrl+Shift+W)`  
  - **결과**: 열린 모든 프레임이 차례로 닫히며 깔끔하게 정리.

---

## 7) 정확성/성능/UX 노트

- **정확성**  
  - BGRA32에서 **알파는 무시**하고 **B/G/R** 또는 **Luma** 만 사용. Luma는 \(\,0.299R+0.587G+0.114B\,\).  
  - 비트 인덱스: **0=LSB**, **7=MSB**.  
  - 출력은 **0/255** 그레이(시각화 목적). 필요하면 **0/1** 로 저장하는 8-bpp DIB 팔레트도 가능.

- **성능**  
  - 한 바퀴 루프(O(width×height))로 매우 빠름.  
  - 8개 평면 추출 시에도 8배 연산이지만 실시간에 가깝게 동작.

- **UX**  
  - 기본 비트는 **7(MSB)** 로 시작해 형태 파악이 쉽도록 함.  
  - *Extract All 8* 은 창이 많이 생기므로 상황에 따라 확인 대화 상자를 둘 수 있음.  
  - 새 창 제목에 **“Bit-plane k”** 를 넣어 구분.

---

## 8) 확장 아이디어

- **다중 채널 격자 뷰**: 하나의 대화 상자에서 8평면 썸네일 미리보기(커스텀 컨트롤로 그리드).  
- **팔레트 8-bpp 저장**: 0/1 이진으로 저장(파일 용량↓).  
- **평면 조작**: 특정 평면을 0으로 만들거나(노이즈 제거), 특정 평면만 합성해 새 이미지 만들기.  
- **ROI 적용**: 영역 선택 후 해당 영역만 비트 평면 추출.

---

## 9) 마무리

- 비트 평면 분할은 **채널 값의 이진 구조**를 직접 들여다보는 강력한 도구입니다.  
- 본 글의 구현은 **채널/비트 선택 → 새 창 출력**까지 완결되고,  
- **Close All** 로 작업 환경을 한 번에 정리할 수 있게 했습니다.
