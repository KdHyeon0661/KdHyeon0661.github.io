---
layout: post
title: 컴퓨터시스템 - I/O 다중화를 이용한 동시성 프로그래밍
date: 2025-09-10 18:20:23 +0900
category: 컴퓨터시스템
---
# I/O 다중화를 이용한 동시성 프로그래밍

## 1. 동시성 & I/O 다중화 — 한 장 요약

- **동시성**: 작업들을 **겹쳐서** 진행. 단일 코어에서도 인터리빙으로 동시처럼 보이게 한다.
- **I/O 다중화**: 하나(또는 소수)의 스레드가 **여러 FD(소켓·파이프·TTY 등)**의 **준비 상태**를 **한 번에** 감시하고, **준비된 것만** 즉시 처리.
- **리액터 패턴**: 커널이 “**준비됨(ready)**”을 알려주면, 이벤트 루프가 등록된 **핸들러**를 호출해 **실제 I/O**를 수행.
- **프로액터(완료 기반)**과의 대비:
  - **레디니스(Ready)**: *지금 읽어도/써도 블록 안 됨* → **select/poll/epoll/kqueue**
  - **컴플리션(Completion)**: *요청해 둔 I/O가 끝남* → **IOCP(Windows)**, **io_uring(Completion 모드)**

> 본 가이드는 **레디니스 기반(epoll/kqueue)**을 실무 기준으로 파고든다.

---

## 2. API 스펙트럼과 선택

| API | 플랫폼 | 복잡도 | 스케일 | 비고 |
|---|---|---|---|---|
| `select` | POSIX 전반 | 낮음 | 낮음 | FD 개수 제한(`FD_SETSIZE`), O(N) 재구성 |
| `poll` | POSIX 전반 | 낮음 | 중간 | 동적 배열, 여전히 O(N) 스캔 |
| **`epoll`** | **Linux** | 중간 | **높음** | 준비된 이벤트 수만큼 처리, **레벨/엣지/원샷/EXCLUSIVE** |
| `kqueue` | BSD/macOS | 중간 | 높음 | 범용 이벤트(파일/시그널/타이머/프로세스) |

- 보조 FD: **`timerfd`**(타이머), **`signalfd`**(시그널), **`eventfd`**(스레드 간 깨우기) — epoll과 **자연스럽게 통합**된다.

---

## 3. 논블로킹 I/O 규율 — **절대법칙**

모든 소켓/파이프에 **`O_NONBLOCK`**:
```c
int fl = fcntl(fd, F_GETFL);
fcntl(fd, F_SETFL, fl | O_NONBLOCK);
```

반드시 지킬 규칙:
- **부분 I/O**: `read`/`write`는 요청 바이트보다 **적게** 처리 가능 → **루프**로 보충.
- **`EAGAIN`/`EWOULDBLOCK`**: 지금은 불가 → **이벤트 루프로 복귀**해 다음 알림 대기.
- **`EINTR`**: 시그널 중단 → 동일 호출을 **재시도**.
- **`SIGPIPE`**: 닫힌 피어로 `write` 시 시그널 → **무시**하거나 `MSG_NOSIGNAL`/`SO_NOSIGPIPE` 사용.

---

## 4. epoll 핵심 — 레벨/엣지/원샷/EXCLUSIVE

```c
int ep = epoll_create1(EPOLL_CLOEXEC);

// 등록
struct epoll_event ev = { .events = EPOLLIN, .data.fd = listenfd };
epoll_ctl(ep, EPOLL_CTL_ADD, listenfd, &ev);

// 대기
for(;;) {
  struct epoll_event out[1024];
  int n = epoll_wait(ep, out, 1024, timeout_ms);
  // out[i].events & (EPOLLIN|EPOLLOUT|EPOLLRDHUP|EPOLLERR|EPOLLHUP) ...
}
```

- **레벨 트리거(LT)**: 읽을 게 남아 있으면 반복적으로 **계속** 알림.
- **엣지 트리거(ET, `EPOLLET`)**: **상태 변동 시 한 번**만 알림 → **EAGAIN까지** 버퍼를 **완전히** 비우거나 채워야 한다.
- **원샷(`EPOLLONESHOT`)**: 알림 후 **자동 비활성화**. 스레드 풀과 조합해 **중복 처리 방지**에 탁월.
- **EXCLUSIVE(`EPOLLEXCLUSIVE`)**: 동일 리스너를 **여러 epoll**에서 감시할 때 **깨어나는 하나만** 이벤트를 받게 해 **쓰던링**(thundering herd) 완화(리눅스 신형 커널).

---

## 5. 리액터 아키텍처(정석) — 단일 스레드

1) 리스너: `accept4(SOCK_NONBLOCK|SOCK_CLOEXEC)`  
2) 새 연결: `EPOLLIN`으로 등록  
3) **읽기 핸들러**:  
   - 읽고(**루프/EAGAIN까지**), **파싱/프레이밍**, **업무 처리**  
   - 응답 생성 시 **송신 버퍼**에 적재하고 **`EPOLLOUT` 활성화**  
4) **쓰기 핸들러**:  
   - 송신 버퍼를 **EAGAIN까지** 밀어냄  
   - 다 보냈으면 **`EPOLLOUT` 해제**(불필요 wakeup 차단)  
5) 타임아웃: `timerfd`/힙/휠로 **유휴·지연 연결 정리**  
6) **백프레셔**: 수신/송신 버퍼가 상한을 넘으면 **상대 이벤트를 일시 비활성화**

---

## 6. 실전 예제 ① — **EPOLLET(엣지 트리거) 에코 서버**(C, 단일 스레드)

> 포인트: **모든 FD 논블로킹**, **EAGAIN까지 반복**, **EPOLLOUT 토글**, **accept 루프**.

```c
// build: gcc -O2 -Wall -Wextra -o echo_et epoll_echo_et.c
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <unistd.h>

#define PORT 9000
#define MAXEV 1024
#define BSZ   8192

typedef struct Conn {
    int fd;
    char in[BSZ];  size_t in_used;
    char out[BSZ]; size_t out_used, out_sent;
} Conn;

static int set_nb(int fd){ int fl=fcntl(fd,F_GETFL); return fcntl(fd,F_SETFL,fl|O_NONBLOCK); }
static void die(const char *m){ perror(m); exit(1); }

static int mk_listener(void){
    int s = socket(AF_INET6, SOCK_STREAM|SOCK_CLOEXEC, 0);
    if (s<0) die("socket");
    int on=1, v6only=0;
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
    setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
    struct sockaddr_in6 a = {0};
    a.sin6_family = AF_INET6; a.sin6_addr = in6addr_any; a.sin6_port = htons(PORT);
    if (bind(s,(struct sockaddr*)&a,sizeof(a))<0) die("bind");
    if (listen(s, 512)<0) die("listen");
    return s;
}

static void ep_mod(int ep, int fd, uint32_t evs, void*ptr){
    struct epoll_event ev = { .events=evs, .data.ptr=ptr };
    if (epoll_ctl(ep, EPOLL_CTL_MOD, fd, &ev)<0) perror("epoll MOD");
}
static void ep_add(int ep, int fd, uint32_t evs, void*ptr){
    struct epoll_event ev = { .events=evs, .data.ptr=ptr };
    if (epoll_ctl(ep, EPOLL_CTL_ADD, fd, &ev)<0) perror("epoll ADD");
}
static void ep_del(int ep, int fd){ epoll_ctl(ep, EPOLL_CTL_DEL, fd, NULL); }

int main(void){
    signal(SIGPIPE, SIG_IGN);
    int ep = epoll_create1(EPOLL_CLOEXEC);
    if (ep<0) die("epoll_create1");
    int ls = mk_listener();
    set_nb(ls);
    ep_add(ep, ls, EPOLLIN|EPOLLET, NULL); // 리스너는 ET + accept 루프

    for (;;) {
        struct epoll_event evs[MAXEV];
        int n = epoll_wait(ep, evs, MAXEV, -1);
        if (n<0) { if (errno==EINTR) continue; die("epoll_wait"); }
        for (int i=0;i<n;i++) {
            if (evs[i].data.ptr == NULL) {
                // 리스너: 대기열 비울 때까지 accept
                for (;;) {
                    struct sockaddr_storage ss; socklen_t sl = sizeof(ss);
                    int c = accept4(ls, (struct sockaddr*)&ss, &sl, SOCK_NONBLOCK|SOCK_CLOEXEC);
                    if (c<0) { if (errno==EAGAIN || errno==EWOULDBLOCK) break; perror("accept4"); break; }
                    Conn *co = calloc(1,sizeof(*co)); co->fd=c;
                    ep_add(ep, c, EPOLLIN|EPOLLET|EPOLLRDHUP, co);
                }
            } else {
                Conn *co = (Conn*)evs[i].data.ptr;
                uint32_t e = evs[i].events;

                if (e & (EPOLLERR|EPOLLHUP|EPOLLRDHUP)) { // 에러/반쯤 닫힘 포함
                    ep_del(ep, co->fd); close(co->fd); free(co); continue;
                }
                if (e & EPOLLIN) {
                    // EAGAIN까지 읽기
                    for (;;) {
                        ssize_t r = read(co->fd, co->in + co->in_used, BSZ - co->in_used);
                        if (r > 0) {
                            co->in_used += (size_t)r;
                            // 에코: in -> out
                            size_t can = BSZ - co->out_used;
                            size_t take = co->in_used < can ? co->in_used : can;
                            memcpy(co->out + co->out_used, co->in, take);
                            co->out_used += take;
                            memmove(co->in, co->in + take, co->in_used - take);
                            co->in_used -= take;
                        } else if (r == 0) { // FIN
                            ep_del(ep, co->fd); close(co->fd); free(co); goto next;
                        } else {
                            if (errno==EAGAIN || errno==EWOULDBLOCK) break;
                            if (errno==EINTR) continue;
                            ep_del(ep, co->fd); close(co->fd); free(co); goto next;
                        }
                    }
                    if (co->out_used > co->out_sent)
                        ep_mod(ep, co->fd, EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP, co);
                }
                if (e & EPOLLOUT) {
                    while (co->out_sent < co->out_used) {
                        ssize_t w = write(co->fd, co->out + co->out_sent, co->out_used - co->out_sent);
                        if (w > 0) co->out_sent += (size_t)w;
                        else if (w < 0 && (errno==EAGAIN || errno==EWOULDBLOCK)) break;
                        else if (w < 0 && errno==EINTR) continue;
                        else { ep_del(ep, co->fd); close(co->fd); free(co); goto next; }
                    }
                    if (co->out_sent == co->out_used) {
                        co->out_used = co->out_sent = 0;
                        ep_mod(ep, co->fd, EPOLLIN|EPOLLET|EPOLLRDHUP, co);
                    }
                }
            }
        next: ;
        }
    }
}
```

**검증 체크**  
- 리스너는 **ET + `accept` 루프**로 대기열을 비운다.  
- `read`/`write`는 **EAGAIN까지 반복**.  
- **`EPOLLOUT`는 필요할 때만** 켠다(모두 보냈으면 끈다).  
- **`EPOLLRDHUP`**으로 **반쪽 종료(half-close)** 감지.

---

## 7. 실전 예제 ② — **EPOLLONESHOT + 스레드 풀**(중복 처리 방지)

원샷은 이벤트 1회 후 자동 비활성화되므로, **워커 스레드**가 안전하게 FD를 독점 처리 가능.

핵심 흐름:
1) 메인 루프: `EPOLLONESHOT`으로 FD 등록  
2) `epoll_wait`에서 FD가 준비되면 → **작업 큐**에 전달  
3) 워커: **EAGAIN까지** I/O 수행 후  
   - 더 할 일 있으면 **`epoll_ctl(…MOD, EPOLLONESHOT)`**로 재무장  
   - 없으면 읽기만 켜서 대기

워커에서의 재무장:
```c
struct epoll_event ev = { .events = EPOLLIN|EPOLLONESHOT|EPOLLRDHUP, .data.ptr = conn };
epoll_ctl(ep, EPOLL_CTL_MOD, conn->fd, &ev);
```

> 동시성 모델을 혼합할 때 **“한 FD를 동시에 두 스레드가 만지지 않음”**이 최우선 설계 원칙.

---

## 8. 타이머/시그널/스레드 이벤트의 **FD화** — 리액터에 끼워넣기

### 8.1 타이머(`timerfd`)
- 주기틱(예: 10ms) 혹은 단일 만료 등록 → **epoll에 그대로 등록**해 “타임아웃 스캔” 트리거로 사용.

```c
#include <sys/timerfd.h>
int tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK|TFD_CLOEXEC);
struct itimerspec it = { .it_interval = {0, 10*1000*1000}, .it_value = {0, 10*1000*1000} }; // 10ms 주기
timerfd_settime(tfd, 0, &it, NULL);
```

### 8.2 시그널(`signalfd`)
- 비동기 시그널을 **동기 이벤트**로: `sigprocmask`로 블록 → `signalfd` 생성 → epoll 등록.

### 8.3 스레드 간 알림(`eventfd`)
- 워커 완료/관리 명령을 메인 루프로 통지하는 **가벼운 깨어움** 용도.

---

## 9. 프로토콜 처리 — **프레이밍과 상태기계**

TCP는 **바이트 스트림**. 메시지 경계가 없다 → **프레이밍** 필요:

- **길이 프리픽스**: [4바이트 길이][payload]… → `readn` 스타일 상태기계
- **델리미터 기반**: `\r\n` 또는 `\n` → `getline` 유사 라인 파서
- **고정 길이 헤더 + 가변 본문**: HTTP/Redis/자체 프로토콜에서 보편적

상태기계 예(의사코드):
```
state = READ_HDR;
while (have data) {
  if (state == READ_HDR && inbuf >= HDRLEN) { parse hdr; need = body_len; state=READ_BODY; }
  if (state == READ_BODY && inbuf >= need) { handle; state=READ_HDR; }
}
```

> **입력 과잉** 시 **샌드박스/상한**(헤더 최대 크기, 총 요청 크기)을 두고, 악성/버그로 인한 OOM을 방지.

---

## 10. 백프레셔 & 타임아웃 — 폭주 억제의 핵심

- **송신 상한(high-water mark)**: `out_buf`가 임계치 넘으면 **EPOLLIN(수신) 비활성화** → 상대가 더 보내지 못하게 **자연 백프레셔** 유도.
- **수신 상한**: 너무 빠르게 들어오면 연결을 **일시 정지**하거나 **드롭**.
- **아이들 타임아웃**: `last_active` 갱신, 타이머 틱에서 **유휴 연결 제거**.
- **응답 지연 타임아웃**: 서비스가 밀릴 때 **백엔드 보호** 목적.

---

## 11. 성능 최적화 — 2025 기준 **현행 팁**

- 소켓:
  - `SO_REUSEADDR`(재시작 편의), **`SO_REUSEPORT`(코어별 리스너 분산)**  
  - `TCP_NODELAY`(지연 Ack/Nagle 상호작용 줄이기), `SO_KEEPALIVE`(좀비 감지)
- **배치 I/O**:
  - `sendmmsg` / `recvmmsg`(UDP/일부 패턴에서 유용), TCP에서도 **응답 묶음**이 가능할 때 성능↑
- **제로카피**:
  - 파일→소켓: **`sendfile`**, 파이프 경유: `splice`  
  - 큰 정적 파일 서비스에 탁월
- **멀티 루프**:
  - 프로세스 N개 + **`SO_REUSEPORT`**로 커넬 레벨 분산  
  - 또는 스레드 N개가 **자신만의 epoll**을 돌리되, FD 파티셔닝을 명확히
- **리스너 경쟁 완화**:
  - 여러 epoll에서 같은 리스너를 감시한다면 **`EPOLLEXCLUSIVE`** 고려
- **FD 상한**:
  - `ulimit -n`(프로세스 FD 상한) 적절 확대

---

## 12. TLS/HTTP 통합 — 논블로킹과의 **마찰 포인트**

- TLS는 **사용자 공간 버퍼**(OpenSSL 등)와 **커널 소켓 버퍼** 사이에서 **추가 상태**가 생긴다.
- `SSL_read`/`SSL_write`는 `SSL_ERROR_WANT_READ/WRITE`를 반환할 수 있음 → **epoll 이벤트와 매핑**:
  - `WANT_READ` → `EPOLLIN` 대기
  - `WANT_WRITE` → `EPOLLOUT` 대기
- HTTP/1.1 파이프라인/청크 인코딩/헤더 파싱:
  - 검증된 파서(예: llhttp 계열)를 쓰면 **보안/성능/경계처리**가 훨씬 안정

---

## 13. 테스트 & 관찰

```bash
# 포트 리스닝/큐 상태
ss -tlnp

# 부하 테스트(HTTP라면)
wrk -t4 -c200 -d30s http://127.0.0.1:9000/

# 패킷 관찰
tcpdump -i lo -n tcp port 9000
```

지표:
- **큐 길이**(accept backlog, SYN backlog)
- **에러율**(RST, 타임아웃)
- **지연 분포**(평균이 아니라 p95/p99)
- **GC/메모리**(언어 런타임 사용 시)

---

## 14. `select`/`poll` 비교 스니펫 — 학습/디버깅용

```c
/* select: 간단하지만 대규모에는 비효율(FD 세트 매회 재구성, O(N)) */
fd_set rset, wset;
int maxfd = listenfd;
for(;;) {
  FD_ZERO(&rset); FD_ZERO(&wset);
  FD_SET(listenfd, &rset);
  for (각 fd) {
    if (읽을수있음) FD_SET(fd, &rset);
    if (쓸게있음)   FD_SET(fd, &wset);
    if (fd > maxfd) maxfd = fd;
  }
  int n = select(maxfd+1, &rset, &wset, NULL, &tv);
  // FD_ISSET 체크 후 처리...
}
```

---

## 15. BSD/macOS — kqueue 초간단

```c
int kq = kqueue();
struct kevent ev;
EV_SET(&ev, listenfd, EVFILT_READ, EV_ADD, 0, 0, NULL);
kevent(kq, &ev, 1, NULL, 0, NULL);

for(;;){
  struct kevent out[1024];
  int n = kevent(kq, NULL, 0, out, 1024, NULL);
  for (int i=0;i<n;i++){
    if (out[i].filter == EVFILT_READ) {
      if (out[i].ident == (uintptr_t)listenfd) { /* accept */ }
      else { /* read EAGAIN까지 */ }
    } else if (out[i].filter == EVFILT_WRITE) { /* write EAGAIN까지 */ }
  }
}
```

- kqueue는 **타이머/시그널/프로세스**도 동일 메커니즘으로 다룬다(범용성 우수).

---

## 16. 안정성 체크리스트(필수)

- [ ] **모든 FD `O_NONBLOCK`**  
- [ ] **엣지 트리거(EPOLLET)** 사용 시 **EAGAIN까지 drain/fill**  
- [ ] **부분 I/O 루프**와 **`EINTR` 재시도**  
- [ ] **`EPOLLOUT`는 있을 때만**  
- [ ] **수신/송신 상한**과 **아이들/응답 타임아웃**  
- [ ] **`SIGPIPE` 무시** 또는 `MSG_NOSIGNAL`  
- [ ] 리스너는 **accept 루프**(ET에서 필수)  
- [ ] **원샷 + 워커** 설계 시 **재무장(MOD+ONESHOT)**  
- [ ] **프로토콜 프레이밍**(길이/델리미터/상태기계)  
- [ ] **메모리 상한**(헤더/본문 크기 제한)으로 악성 입력 방지

---

## 17. 자주 겪는 함정과 교정

- **문제**: EPOLLET에서 `read` 한 번만 호출 → 버퍼가 남았는데 이벤트가 안 옴 → 연결 정지  
  **해결**: **EAGAIN까지** 루프
- **문제**: 항상 `EPOLLOUT` 켬 → CPU 낭비  
  **해결**: **쓸 게 있을 때만** 켜고, 다 보내면 끈다
- **문제**: 한 FD를 두 스레드가 동시에 처리  
  **해결**: **`EPOLLONESHOT`** 또는 사용자 락으로 **단독 처리 보장**
- **문제**: 백엔드 느림 → 소켓 버퍼가 가득 → 서버 OOM/지연  
  **해결**: **백프레셔**(수신 비활성), **큐 상한**, **타임아웃/드롭 정책**
- **문제**: TLS에서 `WANT_READ/WRITE`를 무시  
  **해결**: 해당 이벤트만 켜고 **재시도 타이밍**을 epoll로 제어

---

## 18. 성능 수학(간단 관점)

**이벤트 루프 처리량(대략)**  
$$
\text{Throughput} \approx \frac{N_\text{events}}{T_\text{iteration} + T_\text{syscall} + T_\text{handler}}
$$
- **배치 처리**(한 번의 `epoll_wait`에서 **많은 이벤트** 처리)와 **핫 루프 내 분기 최소화**가 핵심.
- **시스템콜 수**를 줄이는 전략: `EPOLLOUT` 토글, 배치 응답(sendmmsg), zero-copy.

---

## 19. 미니 프레임워크 스켈레톤(확장용)

```c
struct Conn {
  int fd; int want_read, want_write;
  // in/out ring buffers, state machine fields, deadlines...
};

static void arm(int ep, struct Conn* c) {
  uint32_t ev = 0;
  if (c->want_read)  ev |= EPOLLIN;
  if (c->want_write) ev |= EPOLLOUT;
  struct epoll_event ee = { .events = ev | EPOLLET | EPOLLRDHUP, .data.ptr = c };
  epoll_ctl(ep, EPOLL_CTL_MOD, c->fd, &ee);
}

static void on_read(struct Conn* c) { /* EAGAIN까지 읽고 상태기계 진전, want_write 갱신 */ }
static void on_write(struct Conn* c){ /* EAGAIN까지 쓰고 버퍼 소진 시 want_write=0 */ }
```

- 핵심은 **연결 객체에 “필요 이벤트”를 플래그로 보관**하고, I/O 후 **arm() 한 번**으로 epoll 상태를 **일관** 갱신하는 것.

---

## 20. 보안·신뢰성 — 반드시 포함할 것

- **입력 상한**: 라인/헤더/메시지/총 요청 크기 제한
- **타임아웃**: 아이들/응답/최대 수명
- **리소스 상한**: **FD 누수** 방지(예외 시 `close`/`epoll_ctl DEL` 보장)
- **로깅/관측**: 연결 수, 큐 길이, 지연 p95/p99, 에러 코드, 드롭 이유
- **업데이트 전략**: 무중단 재시작(리스너 FD 핸드오버 or `SO_REUSEPORT` 롤링)

---

## 21. 결론

- **I/O 다중화 + 논블로킹**은 **소수 스레드로 대규모 동시 접속**을 처리하는 **표준 해법**이다.
- **epoll**의 레벨/엣지/원샷/EXCLUSIVE와 `timerfd/signalfd/eventfd`를 이해하면 **견고·예측 가능한 리액터**를 만들 수 있다.
- **규율(부분 I/O/EAGAIN/EINTR), 백프레셔, 타임아웃, 프레이밍, EPOLLOUT 토글** — 이 다섯 가지만 지켜도 **대부분의 장애**를 피한다.
- CPU 바운드가 크면 **하이브리드(리액터 + 워커)**, 정적 파일은 **zero-copy**, 코어 확장은 **REUSEPORT/다중 epoll**로.  
  올바른 설계가 **성능 튜닝보다 더 큰 이득**을 준다.

---
```bash
# 빠른 실험 루틴(요약)
ulimit -n 1048576              # FD 상한(환경 허용 범위 내)
./echo_et &                    # 서버 실행
wrk -t8 -c2000 -d30s http://127.0.0.1:9000/
ss -t state established '( sport = :9000 )'
```