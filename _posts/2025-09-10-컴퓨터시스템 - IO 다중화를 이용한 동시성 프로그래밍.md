---
layout: post
title: 컴퓨터시스템 - I/O 다중화를 이용한 동시성 프로그래밍
date: 2025-09-10 18:20:23 +0900
category: 컴퓨터시스템
---
# I/O 다중화를 이용한 동시성 프로그래밍(리액터 패턴 중심 심층 가이드)

---

## 0) 동시성 프로그래밍, 그리고 I/O 다중화란?

- **동시성(Concurrency)**: 여러 작업을 *겹쳐서* 진행하도록 구성하는 것. (한 코어에서도 인터리빙으로 동시처럼 보이게 실행 가능)
- **I/O 다중화(IO multiplexing)**: **하나의(혹은 적은 수의) 스레드/프로세스**가 **여러 파일 디스크립터(FD)**(소켓/파이프/터미널 등)의 **읽기/쓰기 가능 상태**를 **한 번에 감시**하고, 준비된 것만 처리하는 기법.
- 이 방식의 대표 아키텍처가 **리액터(Reactor) 패턴**: 이벤트 루프가 "준비됨(ready)" 신호를 받고, 등록된 핸들러가 실제 I/O를 수행.

> 반대 개념으로 **프로액터(Proactor)**(완료 통지 기반)가 있습니다. 리눅스는 전통적으로 리액터(레디니스 기반: epoll/kqueue), 윈도우는 IOCP(완료 기반) 중심입니다.

---

## 1) 준비 모델: 레디니스 vs 완료

| 모델 | 커널이 알려주는 것 | 대표 기술 |
|---|---|---|
| **레디니스(ready)** | “이 FD는 **지금** read/write 하면 블록되지 않을 것 같아” | `select`, `poll`, **`epoll`**, **`kqueue`** |
| **완료(completion)** | “요청해 둔 I/O가 **끝났어**. 결과 여기” | Windows **IOCP**, Linux io_uring(컴플리션 큐 모드) |

본 문서는 **레디니스 기반**에 초점(서버 다수에서 쓰는 일반 해법).

---

## 2) 핵심 API 스펙트럼

- **`select`**: 가장 오래됨. `fd_set` 비트마스크, **FD 개수 제한(FD_SETSIZE)**, O(N) 스캔.
- **`poll`**: 동적 배열, 제한 완화. 여전히 O(N).
- **`epoll`(Linux)**: **O(준비된 이벤트 수)** 수준. 등록/변경은 `epoll_ctl`, 대기는 `epoll_wait`.
  - 트리거: **레벨(기본)** / **엣지(EPOLLET)** / **원샷(EPOLLONESHOT)**
- **`kqueue`(BSD/macOS)**: 범용 이벤트 큐(파일, 프로세스, 시그널, 타이머 등).
- **보완 FD**: `timerfd`(타이머), `signalfd`(시그널), `eventfd`(스레드·프로세스 간 깨우기)

---

## 3) 논블로킹 I/O와 에러 규율

- 모든 소켓을 **논블로킹**으로:
  ```c
  int fl = fcntl(fd, F_GETFL);
  fcntl(fd, F_SETFL, fl | O_NONBLOCK);
  ```
- 읽기/쓰기 루틴은 아래 규율을 **반드시** 지킵니다.
  - **부분 전송(partial I/O)**: `read`/`write`가 요청 바이트보다 적을 수 있음 → **루프**로 보충.
  - **`EAGAIN`/`EWOULDBLOCK`**: 지금은 못함 → 이벤트 루프로 **돌아가 재대기**.
  - **`EINTR`**: 시그널로 중단 → **재시도**.
  - **`SIGPIPE`**(닫힌 피어로 write): 무시하거나 `MSG_NOSIGNAL` 플래그 사용.

---

## 4) epoll 사용 개요 (Linux)

```c
int ep = epoll_create1(EPOLL_CLOEXEC);

/* 리스닝 소켓 준비 후 등록 */
struct epoll_event ev = { .events = EPOLLIN, .data.fd = listenfd };
epoll_ctl(ep, EPOLL_CTL_ADD, listenfd, &ev);

/* 이벤트 루프 */
for (;;) {
  struct epoll_event out[1024];
  int n = epoll_wait(ep, out, 1024, timeout_ms); // 타임아웃: 타이머/하트비트 등
  for (int i=0;i<n;i++) {
    int fd = out[i].data.fd;
    uint32_t evs = out[i].events;
    // fd 종류/상태에 따라 accept/read/write/close 등 처리
  }
}
```

### 트리거 모드
- **레벨-트리거**(기본): “아직 읽을 게 남아있다면 계속 EPOLLIN 울림”
- **엣지-트리거(EPOLLET)**: “상태가 **변할 때만** 한 번 울림” → **버퍼를 EAGAIN까지 ‘완전히’ 비우거나 채워야** 함.
- **원샷(EPOLLONESHOT)**: 한 번 이벤트 후 자동 비활성화 → 스레드 풀과 조합해 **중복 처리 방지**에 유용.

---

## 5) 최소/정석 아키텍처: 단일 스레드 리액터

1. **리스너**: `accept4(SOCK_NONBLOCK|SOCK_CLOEXEC)`  
2. **새 연결 등록**: `EPOLLIN` (읽기 이벤트)  
3. **읽기 핸들러**: 수신 → 파싱 → 응답 생성  
   - 보내야 할 데이터가 생기면 **송신 버퍼**에 적재하고 **EPOLLOUT** 활성화  
4. **쓰기 핸들러**: 송신 버퍼를 **EAGAIN까지** 비움  
   - 버퍼가 0이 되면 **EPOLLOUT 해제**(불필요한 wakeup 방지)  
5. **타임아웃**: `timerfd`/휠/힙으로 **빈 커넥션 정리**  
6. **백프레셔(Backpressure)**: 수신/송신 상한(High-water) 넘으면 **읽기/쓰기 이벤트를 일시 비활성화**하여 폭주 억제

---

## 6) 예제: EPOLLET(엣지 트리거) 에코 서버 (C, 단일 스레드)

> 포인트: 모든 FD **논블로킹**, **EAGAIN까지 반복**, **EPOLLOUT 토글**, **부분 I/O 루프**.

```c
// epoll_echo_et.c : 엣지 트리거 기반 에코 서버 (학습용)
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <unistd.h>

#define PORT 9000
#define MAXEV  1024
#define BSZ    8192

typedef struct Conn {
    int fd;
    char in[BSZ];
    size_t in_used;
    char out[BSZ];
    size_t out_used, out_sent;
} Conn;

static int nb(int fd){ int fl=fcntl(fd,F_GETFL); return fcntl(fd,F_SETFL,fl|O_NONBLOCK); }

static int listen_socket(void){
    int s = socket(AF_INET6, SOCK_STREAM|SOCK_CLOEXEC, 0);
    int on=1, v6only=0;
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
    setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
    struct sockaddr_in6 a = {0};
    a.sin6_family = AF_INET6; a.sin6_addr = in6addr_any; a.sin6_port = htons(PORT);
    if (bind(s,(struct sockaddr*)&a,sizeof(a))<0) { perror("bind"); exit(1); }
    if (listen(s, 512)<0) { perror("listen"); exit(1); }
    return s;
}

static void mod_epoll(int ep, int fd, uint32_t evs, void* ptr){
    struct epoll_event ev = { .events = evs, .data.ptr = ptr };
    if (epoll_ctl(ep, EPOLL_CTL_MOD, fd, &ev) < 0) perror("epoll_ctl MOD");
}
static void add_epoll(int ep, int fd, uint32_t evs, void* ptr){
    struct epoll_event ev = { .events = evs, .data.ptr = ptr };
    if (epoll_ctl(ep, EPOLL_CTL_ADD, fd, &ev) < 0) perror("epoll_ctl ADD");
}
static void del_epoll(int ep, int fd){ epoll_ctl(ep, EPOLL_CTL_DEL, fd, NULL); }

int main(void){
    signal(SIGPIPE, SIG_IGN);
    int ep = epoll_create1(EPOLL_CLOEXEC);
    int ls = listen_socket();
    nb(ls);

    add_epoll(ep, ls, EPOLLIN | EPOLLET, NULL); // 리스너는 EPOLLET + 루프 accept

    for (;;) {
        struct epoll_event evs[MAXEV];
        int n = epoll_wait(ep, evs, MAXEV, -1);
        for (int i=0;i<n;i++){
            if (evs[i].data.ptr == NULL) {
                // 리스너
                for (;;) {
                    struct sockaddr_storage ss; socklen_t sl=sizeof(ss);
                    int c = accept4(ls, (struct sockaddr*)&ss, &sl, SOCK_NONBLOCK|SOCK_CLOEXEC);
                    if (c < 0) { if (errno==EAGAIN || errno==EWOULDBLOCK) break; perror("accept4"); break; }
                    Conn *co = calloc(1,sizeof(Conn)); co->fd=c;
                    add_epoll(ep, c, EPOLLIN | EPOLLET, co);
                }
            } else {
                Conn *co = (Conn*)evs[i].data.ptr;
                uint32_t e = evs[i].events;

                if (e & (EPOLLHUP | EPOLLERR)) { goto CLOSE; }

                if (e & EPOLLIN) {
                    // EAGAIN까지 계속 읽기
                    for (;;) {
                        ssize_t r = read(co->fd, co->in + co->in_used, BSZ - co->in_used);
                        if (r > 0) {
                            co->in_used += (size_t)r;
                            // 에코: 입력을 out 버퍼로 옮김 (실전은 파서/프로토콜 처리)
                            size_t can = BSZ - co->out_used;
                            size_t take = (co->in_used < can) ? co->in_used : can;
                            memcpy(co->out + co->out_used, co->in, take);
                            co->out_used += take;
                            memmove(co->in, co->in + take, co->in_used - take);
                            co->in_used -= take;
                        } else if (r == 0) { goto CLOSE; } // FIN
                        else {
                            if (errno==EAGAIN || errno==EWOULDBLOCK) break;
                            if (errno==EINTR) continue;
                            goto CLOSE;
                        }
                    }
                    // 보낼 게 생겼으면 EPOLLOUT 켜기
                    if (co->out_used > co->out_sent)
                        mod_epoll(ep, co->fd, EPOLLIN | EPOLLOUT | EPOLLET, co);
                }

                if (e & EPOLLOUT) {
                    // EAGAIN까지 계속 쓰기
                    while (co->out_sent < co->out_used) {
                        ssize_t w = write(co->fd, co->out + co->out_sent, co->out_used - co->out_sent);
                        if (w > 0) co->out_sent += (size_t)w;
                        else if (w < 0 && (errno==EAGAIN || errno==EWOULDBLOCK)) break;
                        else if (w < 0 && errno==EINTR) continue;
                        else goto CLOSE;
                    }
                    // 모두 보냈으면 버퍼 정리 & EPOLLOUT 끄기
                    if (co->out_sent == co->out_used) {
                        co->out_used = co->out_sent = 0;
                        mod_epoll(ep, co->fd, EPOLLIN | EPOLLET, co);
                    }
                }
                continue;
            CLOSE:
                del_epoll(ep, co->fd);
                close(co->fd);
                free(co);
            }
        }
    }
}
```

**핵심 검증 포인트**
- 리스너에서 **accept 루프**: EPOLLET에서는 한 번의 알림 후 **더 이상 대기열이 빌 때까지** 반복 `accept`.
- `read`/`write`는 **EAGAIN까지 루프**. 한 번만 호출하면 **이벤트가 다시 안 온 채** 소켓이 굳을 수 있음.
- **EPOLLOUT 토글**: 쓸 게 있을 때만 켜기(항상 켜두면 CPU 소모).

---

## 7) 타이머·시그널·스레드와의 결합

### 7.1 타임아웃 관리
- 단일 타이머면 **`timerfd_create`**를 epoll에 등록:
  ```c
  int tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK|TFD_CLOEXEC);
  struct itimerspec it = { .it_interval = {1,0}, .it_value = {1,0} }; // 1s 주기
  timerfd_settime(tfd, 0, &it, NULL);
  add_epoll(ep, tfd, EPOLLIN, TIMER_PTR);
  ```
- 수만 커넥션별 타임아웃은 **최소 힙(만료시간)** 또는 **타이밍 휠**을 써서 이벤트 루프 틱에서 처리(필요 시 `timerfd`로 틱 생성).

### 7.2 signalfd
- `SIGCHLD`, `SIGTERM` 등을 **파일 디스크립터로 이벤트화** → epoll에 등록해 동기 처리.

### 7.3 eventfd
- 워커 스레드가 **메인 이벤트 루프를 깨울 때** 쓰기 좋음(락-경량).

---

## 8) 성능·스케일링 팁

- **소켓 옵션**
  - `SO_REUSEADDR`(재시작 편의), `SO_REUSEPORT`(리눅스: **코어별 리스너**로 분산)
  - `TCP_NODELAY`(대화형 딜레이 감소), `SO_KEEPALIVE`(좀비 연결 감지)
- **수 커넥션**
  - `ulimit -n`(열 수 있는 FD 상향), 적절한 커널 파라미터(somaxconn 등)
- **다중 루프**
  - **N개의 프로세스/스레드**가 각자 **자신만의 epoll 인스턴스**를 돌리거나,
  - `SO_REUSEPORT`로 리스너를 **코어별**로 쪼개면 락 경합↓
- **리스닝 분배**
  - 커널 4.5+: 리스너를 `EPOLLEXCLUSIVE`로 등록하면 **쓰던링 헤드** 완화(여러 워커 epoll에서 동일 리스너 감시 시).
- **제로카피**
  - 정적 파일 전송: `sendfile` / `splice`(파이프 경유) / `mmap+write`.
- **백프레셔**
  - 송신 큐가 커지면 **읽기 이벤트(EPOLLIN) 잠시 끄기**(상대가 계속 보낼 수 없게 조절).

---

## 9) 오류/함정 체크리스트

- [ ] 모든 소켓 **O_NONBLOCK** 설정  
- [ ] 엣지-트리거 사용 시 **EAGAIN까지 drain/fill**  
- [ ] **부분 I/O**와 **EINTR** 처리 루프  
- [ ] `EPOLLOUT`는 **필요할 때만**  
- [ ] **수신/송신 버퍼 상한**과 **연결 타임아웃**(유휴, 응답 지연)  
- [ ] `SIGPIPE` 무시 또는 `MSG_NOSIGNAL`  
- [ ] 리스너 `accept` 루프(EPOLLET일 때 필수)  
- [ ] 연결 종료 조건: `read=0`, `HUP/ERR`, 어플리케이션 프로토콜 종료 처리

---

## 10) select/poll 비교용 짧은 스니펫

```c
/* select 기반 요약: 학습/디버깅용. 대규모 연결엔 비효율 */
fd_set rset, wset; int maxfd = listenfd;
for (;;) {
  FD_ZERO(&rset); FD_ZERO(&wset);
  FD_SET(listenfd, &rset);
  for (각 연결 fd) {
    if (읽을 가능) FD_SET(fd, &rset);
    if (쓸 데이터)   FD_SET(fd, &wset);
    if (fd > maxfd) maxfd = fd;
  }
  int n = select(maxfd+1, &rset, &wset, NULL, &tv);
  // FD_ISSET로 확인 후 처리…
}
```

**한계**: FD 수가 커질수록 O(N) 스캔, FD_SETSIZE 제한, 재설정 비용.

---

## 11) 리액터 vs 스레드풀 하이브리드

- **CPU-바운드** 작업이 길다면?
  - 이벤트 루프는 **I/O만** 처리하고, **작업 큐**에 넘겨 워커 스레드가 수행.
  - 완료 시 `eventfd`로 루프를 깨우고 `EPOLLOUT` 활성화 → 응답 전송.
- **멀티프로세스**와 결합
  - `SO_REUSEPORT`로 여러 프로세스가 **같은 포트**를 각자 수신 → 간섭 최소.

---

## 12) 프로토콜 처리 실무 팁

- **프레이밍**: TCP는 스트림(메시지 경계 X). **길이 프리픽스** 또는 **델리미터(\r\n)** 로 구분. 파서는 **상태기계(state machine)** 로.
- **헤더/본문**: HTTP/redis 등은 **파서 라이브러리**(llhttp 등)를 쓰면 안전.
- **대용량 응답**: 청크로 분할, `sendfile`/파일 매핑 고려.
- **TLS**: 소켓 FD 위에 라이브러리(OpenSSL 등) 레이어. **버퍼링/이벤트 연동** 필요(SSL_ERROR_WANT_READ/WRITE).

---

## 13) 관찰·테스트

```bash
# 연결/큐 상태
ss -tlnp
# 간단 부하 테스트
wrk -t4 -c200 -d30s http://127.0.0.1:9000/
# 패킷 캡처
tcpdump -i lo -n tcp port 9000
```

---

## 14) 요약

- **I/O 다중화 + 논블로킹**은 소수의 스레드로 **대량 동시 접속**을 처리하는 표준 해법입니다.
- **epoll(리눅스)** 의 레벨/엣지 트리거, `EPOLLONESHOT`, `EPOLLEXCLUSIVE`, `timerfd/signalfd/eventfd`를 이해하면 **안정·확장 가능한 리액터**를 만들 수 있습니다.
- 핵심 규율: **EAGAIN까지 drain/fill**, **부분 I/O 루프**, **EPOLLOUT 토글**, **타임아웃·백프레셔**.  
  이를 지키면 단일 스레드에서도 수만 커넥션 수준의 서버를 **예측 가능하고 효율적으로** 운영할 수 있습니다.
