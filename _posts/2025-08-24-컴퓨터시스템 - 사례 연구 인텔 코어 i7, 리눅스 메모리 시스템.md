---
layout: post
title: 컴퓨터시스템 - 사례 연구 - 인텔 코어 i7, 리눅스 메모리 시스템
date: 2025-08-24 15:20:23 +0900
category: 컴퓨터시스템
---
# 사례 연구: 인텔 코어 i7 / 리눅스 메모리 시스템

이 장에서는 **인텔 Core i7** 프로세서와 **리눅스** 운영체제를 기반으로 한 **메모리 시스템**을 사례로 들어, 하드웨어·운영체제·프로그램이 어떻게 메모리를 협력적으로 관리하고 성능을 최적화하는지를 분석합니다.

---

## 1) 인텔 Core i7 메모리 하드웨어 구조

### 1.1 캐시 계층 구조
Core i7(Nehalem 이후) 아키텍처는 다음과 같은 캐시 계층을 가집니다.

| 레벨 | 크기 | 공유 범위 | 접근 지연 |
|------|------|----------|-----------|
| L1D  | 32KB | 코어 전용 | ~4 cycle |
| L1I  | 32KB | 코어 전용 | ~4 cycle |
| L2   | 256KB | 코어 전용 | ~12 cycle |
| L3   | 수 MB | 모든 코어 공유 | ~40 cycle |

- **L1/L2는 VIPT**, L3는 **PIPT**로 구현
- **하드웨어 prefetcher**가 순차 접근 패턴 예측 및 캐시 라인 선로딩

### 1.2 TLB 구조
- L1 DTLB: 4KB 페이지 64엔트리, 2MB 페이지 32엔트리
- L2 TLB(공유): 수백 엔트리, 모든 페이지 크기 지원
- **PCID**(Process Context Identifier) 지원: TLB flush 없이 컨텍스트 전환 가능

### 1.3 메모리 채널 & NUMA
- DDR4/DDR5 다중 채널(2~4채널)
- 멀티 소켓 환경에선 NUMA(Node Local Memory) 특성이 성능에 영향

---

## 2) 리눅스 가상 메모리 관리 방식

### 2.1 주소공간 배치 (x86-64, 48-bit VA)
```
0x0000_0000_0000_0000 ─────────► [사용자 영역]
~ 128TB
──────────────────────────────► [커널 영역: 0xffff_8000_0000_0000 ~]
```
- 사용자 영역: 스택, 힙, 코드, mmap 라이브러리, 파일 매핑 등
- 커널 영역: 커널 코드/데이터, I/O 매핑, 페이지 캐시

### 2.2 페이지 크기와 Huge Page
- 기본 4KB 페이지
- Transparent Huge Page(THP)로 2MB 페이지 자동 활용
- 명시적 `hugepages` 설정 가능(1GB 지원 시도 포함)

### 2.3 페이지 폴트 처리
- **Demand Paging**: 접근 시 PTE 미존재 → 페이지 할당/로드 후 재시도
- **Copy-On-Write**: fork 시 페이지 공유, 쓰기 시 복사
- **메모리 매핑 파일 접근**: 페이지 폴트로 디스크 블록 읽기

---

## 3) 하드웨어-리눅스 상호작용

### 3.1 주소 변환 과정
1. CPU는 VA를 TLB에서 검색
2. TLB 히트 시 물리 주소로 변환 → 캐시 접근
3. TLB 미스 시 하드웨어 페이지 워커가 페이지 테이블 탐색
4. PTE에 없으면 페이지 폴트 → 커널로 트랩

### 3.2 NUMA 최적화
- 리눅스 **first-touch** 정책: 페이지 처음 접근한 CPU의 로컬 노드 메모리에 할당
- `numactl`, `mbind`로 정책 제어 가능

### 3.3 캐시와 동기화
- 다중 코어에서 동일한 캐시 라인을 수정 시 MESI 프로토콜로 일관성 유지
- 과도한 false sharing 방지를 위해 데이터 구조 패딩 적용

---

## 4) 성능 및 문제 사례

### 4.1 TLB 미스와 성능 저하
- 데이터셋 크기가 TLB 커버리지를 초과 시 페이지 워크 증가
- 해결책: Huge Page 사용, 데이터 구조 재배치

### 4.2 페이지 폴트 폭주
- 메모리 부족 또는 I/O 병목 시 Major Fault 증가
- 모니터링: `vmstat`, `perf stat -e page-faults`

### 4.3 NUMA 비지역성 접근
- 원격 노드 메모리 접근 시 지연 증가(~100ns → ~200ns)
- 해결책: NUMA 바인딩, 스레드-데이터 지역성 유지

---

## 5) 실전 분석 명령어 예시

```bash
# CPU 캐시·TLB 미스 측정
perf stat -e cycles,instructions,cache-misses,dTLB-load-misses ./myprog

# NUMA 메모리 사용 현황
numastat -p <pid>

# 페이지 매핑 확인
cat /proc/<pid>/maps
cat /proc/<pid>/smaps

# Transparent Huge Page 상태
cat /sys/kernel/mm/transparent_hugepage/enabled
```

---

## 6) 요약

- **Core i7**은 깊은 캐시 계층, 다단 TLB, NUMA 메모리 채널로 구성
- **리눅스**는 페이지 기반 가상 메모리 관리, COW, THP 등으로 성능·효율성을 추구
- TLB, NUMA, 페이지 폴트는 메모리 성능의 핵심 병목 요소
- 최적화는 **지역성 유지, Huge Page 활용, NUMA 바인딩, 캐시 친화적 구조 설계**가 중심

> 이 구조와 동작 원리를 이해하면, 대규모 데이터 처리, HPC, 서버 애플리케이션에서 **메모리 병목 제거**와 **성능 극대화**를 달성할 수 있습니다.