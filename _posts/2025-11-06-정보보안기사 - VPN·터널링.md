---
layout: post
title: 정보보안기사 - VPN·터널링
date: 2025-11-06 22:25:23 +0900
category: 정보보안기사
---
# VPN·터널링(IPsec, SSL/TLS VPN, Zero Trust 개요)

## 0) 한눈에 보는 개념 지도

- **VPN = 캡슐화 + 암호화 + 인증 + 키 교환**  
  - **IPsec**: 네트워크 계층(L3) 보호. IKEv2로 SA 협상 → ESP로 데이터 암호화(Transport/Tunnel 모드).  
  - **SSL/TLS VPN**: 전송/응용 계층(L4/L7)에서 TLS를 터널로 활용(UDP 1194 등). 프록시·FW 환경 **우회성/친화성** 좋음.  
  - **Zero Trust(ZTNA)**: “네트워크=신뢰”를 버리고 **사용자·기기·컨텍스트** 기반으로, **어플리케이션 단위** 최소권한 접근. VPN은 선택지 중 하나.
- **터널 MTU**: 캡슐화 오버헤드만큼 MTU↓ → **MSS 클램핑**/PMTUD 고려.  
- **Split vs Full Tunnel**: 일부 경로만 터널(업무) vs 모든 트래픽(보안·감사).

**오버헤드 근사식(ESP/NAT-T, IPv4 터널 모드)**  
$$
\text{Overhead} \approx 20\;(\text{IP}) + 8\;(\text{UDP}) + 8\;(\text{ESP hdr}) + 16\;(\text{IV/nonce}) + 2\;(\text{trailer}) + 16\;(\text{ICV}) \approx 70\ \text{bytes}
$$
(정확치는 알고리즘/패딩/모드에 따라 다름. IPv6는 대략 +20B)

---

# 1) 필수 원리: 캡슐화·인증·키교환

## 1.1 캡슐화·보호 계층
- **IPsec(ESP)**: L3 보호(패킷 단위 암호화). **Transport**(IP payload만) / **Tunnel**(원래 IP 전체 재포장).  
- **SSL/TLS VPN**: TLS 레코드 위에 가상 인터페이스(TUN/TAP) 바인딩 → L3/L2 터널.

## 1.2 인증/키교환
- **IKEv2**: SA 협상(암호군·수명·PFS), EAP/증명서 인증, DPD·MOBIKE(이동성).  
- **TLS**: X.509(서버·클라이언트), PSK 가능(권장 X). TLS1.3 우선.

---

# 2) IPsec 실전 — strongSwan 기준 (Linux)

> 토폴로지(사이트-투-사이트): `SiteA 10.0.1.0/24 ↔ SiteB 10.0.2.0/24`  
> 게이트웨이: `A: 198.51.100.10` / `B: 203.0.113.20` (NAT 없음 가정)

## 2.1 방화벽·커널 준비
```bash
# (양측) ESP/IKE 허용
sudo nft add table inet edge
sudo nft add chain inet edge input { type filter hook input priority 0; policy drop; }
sudo nft add rule inet edge input ct state established,related accept
sudo nft add rule inet edge input iif lo accept
sudo nft add rule inet edge input udp dport {500,4500} accept   # IKEv2 + NAT-T
sudo nft add rule inet edge input esp accept                    # ESP 패킷 허용
```

## 2.2 strongSwan(IKEv2) 설치
```bash
sudo apt-get update && sudo apt-get install -y strongswan strongswan-pki
```

## 2.3 인증서(테스트용) 생성(자체 CA)
```bash
# CA 키/증명서
ipsec pki --gen --type rsa --size 4096 --outform pem > ca.key
ipsec pki --self --ca --lifetime 3650 --in ca.key --type rsa \
  --dn "CN=Lab IPsec CA" --outform pem > ca.crt

# GW A/B용 키/서버 cert (CN=공인IP 또는 FQDN)
ipsec pki --gen --type rsa --size 3072 --outform pem > a.key
ipsec pki --pub --in a.key --type rsa | ipsec pki --issue --lifetime 1825 \
  --cacert ca.crt --cakey ca.key --dn "CN=198.51.100.10" --san 198.51.100.10 \
  --flag serverAuth --flag ikeIntermediate --outform pem > a.crt

ipsec pki --gen --type rsa --size 3072 --outform pem > b.key
ipsec pki --pub --in b.key --type rsa | ipsec pki --issue --lifetime 1825 \
  --cacert ca.crt --cakey ca.key --dn "CN=203.0.113.20" --san 203.0.113.20 \
  --flag serverAuth --flag ikeIntermediate --outform pem > b.crt

sudo install -m 600 a.key /etc/ipsec.d/private/
sudo install -m 644 a.crt ca.crt /etc/ipsec.d/certs/
# B도 동일
```

## 2.4 ipsec.conf(ipsec.secrets) — 사이트-투-사이트(IKEv2, AES-GCM)
```conf
# /etc/ipsec.conf (A측)
config setup
  uniqueids = never

conn s2s
  keyexchange = ikev2
  left        = 198.51.100.10
  leftcert    = a.crt
  leftid      = 198.51.100.10
  leftsubnet  = 10.0.1.0/24
  right       = 203.0.113.20
  rightid     = 203.0.113.20
  rightsubnet = 10.0.2.0/24
  ike         = aes256gcm16-prfsha384-ecp256,aes256-sha256-modp2048
  esp         = aes256gcm16,aes256-sha256
  dpdaction   = restart
  dpddelay    = 30s
  lifetime    = 8h
  rekeymargin = 3m
  mobike      = no
  auto        = start
```
```conf
# /etc/ipsec.secrets (A측)
: RSA a.key
```
> B측은 `left/right`를 반대로, `leftcert=b.crt`, `leftsubnet=10.0.2.0/24`로 대칭.

### 서비스 시작/검증
```bash
sudo systemctl enable --now strongswan
sudo journalctl -u strongswan -f
sudo ipsec statusall
ping -c3 10.0.2.10
```

## 2.5 (선택) swanctl 방식(신규 구문)
```conf
# /etc/swanctl/swanctl.conf (개요)
connections {
  s2s {
    local_addrs  = 198.51.100.10
    remote_addrs = 203.0.113.20
    local {
      auth = pubkey
      certs = a.crt
      id = 198.51.100.10
    }
    remote { auth = pubkey; id = 203.0.113.20; }
    children {
      net {
        local_ts  = 10.0.1.0/24
        remote_ts = 10.0.2.0/24
        esp_proposals = aes256gcm16
      }
    }
    version = 2
    proposals = aes256gcm16-prfsha384-ecp256
    rekey_time = 8h
    dpd_delay  = 30
  }
}
secrets { private-keys { akey { file = /etc/ipsec.d/private/a.key } } }
```
```bash
sudo swanctl --load-all
sudo swanctl --initiate --child net
```

## 2.6 NAT 환경 주의(NAT-T)
- **UDP 500/4500 허용**(IKE, NAT-T), **ESP**가 NAT 뒤면 자동 **UDP-Encap(4500)**  
- 경계 FW에 **동일 정책** 양방향 적용.

## 2.7 MTU/MSS 클램핑(블랙홀 방지)
```bash
# 터널 인터페이스 경유 TCP SYN에 MSS 1360 강제(환경에 맞게 조정)
sudo iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN SYN -j TCPMSS --set-mss 1360
# nftables
sudo nft add table inet mangle
sudo nft add chain inet mangle forward { type filter hook forward priority -150; }
sudo nft add rule inet mangle forward tcp flags syn tcp option maxseg size set 1360
```

## 2.8 원격접속(로드워리어) — IKEv2 EAP-TLS(요지)
```conf
# A측 게이트웨이 (서버)
conn rw
  keyexchange=ikev2
  left=%any
  leftid=vpn.example.com
  leftcert=a.crt
  leftsubnet=0.0.0.0/0
  right=%any
  rightauth=eap-tls
  rightsourceip=10.10.10.0/24
  eap_identity=%identity
  ike=aes256gcm16-prfsha384-ecp256
  esp=aes256gcm16
  auto=add
```
- 클라이언트에 사용자 인증서 발급 → IKEv2 프로파일로 접속(Windows 10+ 네이티브 지원).

---

# 3) SSL/TLS VPN — OpenVPN 기준

> **장점**: FW/프록시 친화(443/UDP or TCP), TLS1.3, 플러그인/SSO, L7 장비와 공존 쉬움.  
> **단점**: L3/L2 터널을 유저 공간에서 처리 → 고성능엔 튜닝 필요.

## 3.1 서버 구성(server.conf)
```conf
port 1194
proto udp                            # UDP 권장(지연/혼잡제어 유리)
dev tun
topology subnet

server 10.8.0.0 255.255.255.0        # 가상 서브넷
push "redirect-gateway def1 bypass-dhcp"   # Full Tunnel (Split 사용 시 삭제)
push "dhcp-option DNS 10.8.0.1"

tls-version-min 1.2
tls-cipher TLS-AES-256-GCM-SHA384:TLS-CHACHA20-POLY1305-SHA256
cipher AES-256-GCM
auth SHA256
tls-crypt ta.key                     # 제어 채널 암호화(메타데이터 은닉/탐지회피 향상)

verify-client-cert require
remote-cert-tls client

client-config-dir ccd                # 사용자별 경로/정책
keepalive 10 60
persist-key
persist-tun
user nobody
group nogroup
explicit-exit-notify 1
```

## 3.2 클라이언트(client.ovpn)
```conf
client
dev tun
proto udp
remote vpn.example.com 1194
resolv-retry infinite
nobind
persist-key
persist-tun

remote-cert-tls server
cipher AES-256-GCM
auth SHA256
verb 3

<ca>
# CA PEM
</ca>
<cert>
# client cert PEM
</cert>
<key>
# client key PEM
</key>
<tls-crypt>
# ta.key 내용
</tls-crypt>
```

## 3.3 (선택) Split Tunnel 정책
- 서버에서 `push "route 10.0.0.0 255.255.0.0"` 등 **업무 대역만** 푸시.  
- 클라이언트 정책 라우팅/방화벽으로 **비업무 트래픽은 로컬 회선** 유지.

## 3.4 방화벽·성능 팁
```bash
# Linux 커널 튜닝(예)
sudo sysctl -w net.ipv4.ip_forward=1
sudo sysctl -w net.core.rmem_max=2500000
sudo sysctl -w net.core.wmem_max=2500000
# nft: OpenVPN 포트 허용
sudo nft add rule inet edge input udp dport 1194 accept
```

---

# 4) 비교 요약: IPsec vs SSL/TLS VPN (＋참고: WireGuard)

| 항목 | IPsec(IKEv2/ESP) | SSL/TLS VPN(OpenVPN 등) | WireGuard(참고) |
|---|---|---|---|
| 계층 | L3 | L4/L7 | L3 |
| 통과성 | 중간 | 우수(443/TCP/UDP) | 우수(UDP) |
| 표준화 | 매우 성숙 | 성숙 | 비교적 최신(Noise) |
| 성능 | 커널/하드웨어 오프로드 유리 | 유저 공간, 튜닝 필요 | 고성능(커널/단순성) |
| 운영 난이도 | 정책·암호군 다양 | 비교적 단순 | 키 배포/정책 설계 필요 |
| 모빌리티 | MOBIKE | TLS 재협상 | Roaming 우수 |

> 실제 선택은 **장비·FW 환경·운영 역량**을 고려한 복합 의사결정.

---

# 5) Zero Trust(ZTNA) 개요 — “네트워크가 아니라 **식별자**를 신뢰”

## 5.1 원칙
- **명시적 검증**: 사용자·기기·위치·시간·리스크 스코어  
- **최소 권한**: 앱·API **단위** 접근(네트워크 전체/대역 허용 금지)  
- **짧은 수명 권한**: 짧은 세션, 지속 **재평가**  
- **가시성/정책 중앙화**: 감사/로깅 우선

## 5.2 구성 요소
- **IdP(OIDC/SAML)**: 신원·MFA  
- **Device Posture**: EDR/암호화/패치 상태  
- **ZTNA 게이트웨이/프록시**: L7 접근 제어(정책 엔진)  
- **mTLS/토큰(JWT)**: 서비스 간/사용자→앱 간 신뢰

## 5.3 예제: Envoy 프록시로 OIDC + JWT 검증(요지)
```yaml
# envoy.yaml (발췌) - JWT 검증 후 백엔드로 라우팅
static_resources:
  listeners:
  - name: https
    address: { socket_address: { address: 0.0.0.0, port_value: 443 } }
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          route_config:
            virtual_hosts:
            - name: app
              domains: ["app.example.com"]
              routes:
              - match: { prefix: "/api" }
                route: { cluster: app }
          http_filters:
          - name: envoy.filters.http.jwt_authn
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
              providers:
                oidc:
                  issuer: "https://idp.example.com"
                  audiences: ["app-api"]
                  remote_jwks: { http_uri: { uri: "https://idp.example.com/jwks.json", cluster: idp }, cache_duration: { seconds: 600 } }
              rules:
              - match: { prefix: "/api" }
                requires: { provider_name: "oidc" }
          - name: envoy.filters.http.router
  clusters:
  - name: app
    load_assignment: { cluster_name: app, endpoints: [{ lb_endpoints: [{ endpoint: { address: { socket_address: { address: 127.0.0.1, port_value: 8080 } } } }] }] }
  - name: idp
    type: LOGICAL_DNS
    load_assignment: { cluster_name: idp, endpoints: [{ lb_endpoints: [{ endpoint: { address: { socket_address: { address: idp.example.com, port_value: 443 } } } }] }] }
    transport_socket:
      name: envoy.transport_sockets.tls
      typed_config: { "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext }
```
- **정책**: JWT의 `aud/scope/claim`로 **세분화**(예: `/api/orders`는 `role=sales`).  
- **mTLS**: 서비스 간 통신은 **고객/서버 상호 인증**으로 MITM 방지.

## 5.4 SSH Zero Trust(짧은 수명 인증서)
```bash
# 조직 CA로 OpenSSH cert 발급(1시간 만료 예)
ssh-keygen -f user_ed25519 -t ed25519
ssh-keygen -s ca_user -I user1@corp -n user1 -V +1h user_ed25519.pub
# 서버는 TrustedUserCAKeys로 CA 공개키 등록 → 패스워드·장기 키 없이 단기 cert만 허용
```

---

# 6) 운영·모니터링

## 6.1 IPsec
```bash
sudo ipsec statusall
sudo swanctl --list-sas
ip xfrm state; ip xfrm policy
```

## 6.2 OpenVPN
```bash
# 실시간 상태
sudo journalctl -u openvpn@server -f
# 관리 인터페이스(활성 시)
echo "status" | sudo nc 127.0.0.1 7505
```

## 6.3 가시성
- **로그 합치기**: IPsec(daemon), OpenVPN(status/log), Envoy(Access Log), FW conntrack  
- **지표**: 세션 수, 재키 비율, DPD 이벤트, 재전송률, 평균 RTT, 실패 인증 원인(top-n)

---

# 7) 트러블슈팅 베스트 프랙티스

- **IPsec SA 불일치**: 양측 `ike/esp proposal` 정확히 일치? PFS 그룹? 수명?  
- **NAT-T 실패**: 4500/UDP 차단? 중간 FW에서 ESP 차단?  
- **오버랩 서브넷**: `10.0.0.0/8` 등 충돌 → **정교한 프리픽스**/정책 라우팅.  
- **PMTU 블랙홀**: ping 큰 패킷 + DF로 확인 → **MSS 클램핑**.  
- **OpenVPN TCP/443 종속**: 프록시 경유 시 지연↑ → UDP 우선 검토.  
- **ZTNA 오탐**: JWT 클레임 매핑/시계 오차(NTP), JWK 캐시 만료 확인.

---

# 8) 보안 강화 체크리스트

- **암호군**: AES-256-GCM(or ChaCha20-Poly1305), PRF SHA-2, PFS(modp2048+/ecp256+).  
- **수명**: IKE/Child SA 8~12h, 세션 재키 **중첩** 허용(무중단).  
- **인증**: 서버·클라이언트 **상호 인증**, CRL/OCSP, 단기 cert.  
- **방화벽**: 최소 포트(500/4500/ESP or 1194/443), **대역폭 보호**(RateLimit).  
- **로깅**: 성공/실패 인증, SA 이벤트, 정책 Hit, 알림 임계.  
- **ZTNA**: IdP MFA, 디바이스 상태 필수, 짧은 수명 토큰, 세션 종료/재평가.

---

# 9) 시나리오별 빠른 레시피

## 9.1 온프레 ↔ 클라우드 IPsec(Site-to-Site)
1) **클라우드 게이트웨이**에서 IPsec 파라미터(암호군/수명) 확인.  
2) 온프레 strongSwan의 `ike/esp`를 **클라우드 권장값**과 일치.  
3) NAT-T, 정적 경로(또는 BGP 기반 동적) 구성.  
4) 관측: `ipsec statusall`/클라우드 모니터링, 터널 헬스 알람.

## 9.2 재택근무(원격 사용자)
- 기본: **OpenVPN IKEv2 둘 다** 제공. 기업망은 Split Tunnel로 **업무 도메인/서브넷만** 통과.  
- MFA(OTP/Web SSO), 단말 상태 검사 후 **접속 허용**.

## 9.3 단계적 ZTNA 전환
- 1단계: 인바운드 앱 **Reverse Proxy + OIDC**(JWT 정책) 앞세움.  
- 2단계: 내부 서비스 **mTLS** + 서비스 단위 정책.  
- 3단계: VPN은 **레거시/특정 트래픽**만 유지.

---

# 10) 실습 과제(채점 포인트 포함)

### 과제 A) strongSwan S2S 구축(20점)
- (12) IKE/ESP 제안 AES-GCM+PFS, SA 수명 8h  
- (4) NAT-T/방화벽 허용  
- (4) ping 시험 + `ip xfrm`/`statusall` 캡처

### 과제 B) OpenVPN Split Tunnel(15점)
- (6) 서버 푸시 라우트만(업무 대역)  
- (5) DNS 푸시/누수 방지  
- (4) 클라이언트 라우팅 테이블 캡처

### 과제 C) Envoy JWT 정책(15점)
- (8) `/api/*` JWT 필수, `aud=app-api`  
- (4) 만료/서명 실패 401  
- (3) 성공/실패 로그 캡처

---

## 부록: 스니펫 모음

### (1) nftables — IKE/IPsec/OVPN 허용
```bash
sudo nft add table inet vpn
sudo nft add chain inet vpn input { type filter hook input priority 0; policy drop; }
sudo nft add rule inet vpn input ct state established,related accept
sudo nft add rule inet vpn input iif lo accept
sudo nft add rule inet vpn input udp dport {500,4500,1194} accept
sudo nft add rule inet vpn input tcp dport 443 accept   # TLS VPN 대안
sudo nft add rule inet vpn input meta l4proto esp accept
sudo nft add rule inet vpn input counter log prefix "VPN_DROP " drop
```

### (2) OpenVPN 사용자별 정책(예: `ccd/user1`)
```conf
ifconfig-push 10.8.0.10 255.255.255.0
push "route 10.0.1.0 255.255.255.0"
iroute 10.0.1.0 255.255.255.0
```

### (3) strongSwan DPD/MOBIKE 팁
```conf
dpdaction=restart
dpddelay=30s
mobike=yes    # 이동성 필요 시
```

---

# 마무리 요약

- **IPsec**은 **네트워크 계층** 보호에 강하고, **SSL/TLS VPN**은 **통과성·유연성**이 강점.  
- **MTU/MSS·NAT-T·제안 일치**가 실무 안정화의 3대 관건.  
- **Zero Trust**는 VPN을 대체/보완하는 **정책·아이덴티티 중심** 모델: **OIDC+JWT+mTLS**로 **앱 단위** 접근 제어.  
- 모든 선택은 **가시성(로그/지표)**과 **짧은 수명·최소권한** 원칙으로 운영하세요.
