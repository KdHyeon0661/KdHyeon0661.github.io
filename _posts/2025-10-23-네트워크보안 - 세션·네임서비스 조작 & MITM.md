---
layout: post
title: 네트워크보안 - 세션·네임서비스 조작 & MITM
date: 2025-10-23 20:25:23 +0900
category: 네트워크보안
---
# 세션·네임서비스 조작 & MITM

## 세션 하이재킹 개념과 전제조건(쿠키·HSTS·H2/H3 고려)

### 무엇이 “세션 하이재킹”인가

- **정의**: 합법 사용자의 **세션 식별자(session id / token / 쿠키)**를 탈취·재사용해 사용자로 위장.
- **전제조건**(임의 조합)
  1) 세션 토큰이 **전송 중 노출**(평문 HTTP, 약한 TLS, 중간자)
  2) 토큰이 **저장 중 노출**(로컬스토리지·XSS·디버깅 로그)
  3) **세션 고정(Session Fixation)**: 공격자가 지정한 토큰으로 로그인 유도
  4) **재사용 허용**: 서버가 토큰의 **바인딩·수명·재사용 방지**가 약함

> **TLS/HSTS가 기본**인 환경에서는 “전송 중 탈취”가 대폭 어려워지지만, **XSS/클라이언트 측 보안**이 허술하면 여전히 하이재킹이 가능.

---

### 쿠키·토큰 안전 설계 체크리스트

- **쿠키 플래그**
  - `Secure`: 오직 HTTPS에서만 전송
  - `HttpOnly`: JS로 접근 불가(XSS 완화)
  - `SameSite=Lax/Strict`: 크로스 사이트 전송 제한(CSRF 완화)
- **수명/회전**
  - **짧은 만료** + **활동성 기반 연장**
  - 로그인·권한 변경·중요 행동 이후 **토큰 재발급/회전**
- **바인딩**
  - 기기/클라이언트 지문(합리 수준)·IP 대역(선택적)·TLS 채널 바인딩(가능한 범위)
  - **1회용/단발성 토큰**(특수 액션)
- **보관 위치**
  - 인증 **쿠키** 우선(브라우저 보안 기능 활용), **로컬스토리지**에 bearer 저장 지양
- **서버측 정책**
  - 동시 세션 수 제한·비정상 Geo/ASN·JA3/JA4 지문 급변 시 재인증

#### 서버 예시 — Set-Cookie (Nginx 리버스 프록시)

```nginx
# 인증 후 백엔드가 Set-Cookie: session=... 만 보낸다고 가정하고, 보안 속성 추가/강제

proxy_hide_header Set-Cookie;
proxy_cookie_path / "/; Secure; HttpOnly; SameSite=Lax";
# HSTS는 4.5.2에 상세. 여기선 요지만 표시.

```

#### 앱 예시 — Express(개념용)

```js
app.use(session({
  name: "sid",
  secret: process.env.SESSION_SECRET,
  cookie: {
    secure: true,       // HTTPS only
    httpOnly: true,     // no JS
    sameSite: "lax",    // or "strict" if UX OK
    maxAge: 15 * 60 * 1000
  },
  rolling: true,        // 활동 시 연장
  resave: false,
  saveUninitialized: false
}));
```

---

### HSTS와 HTTP/2, HTTP/3(QUIC) 고려

- **HSTS**: 첫 방문부터 **HTTPS 고정**(preload 권장). “초회 평문 한 번”도 차단.
- **H2**: 단일 TCP 위 **다중 스트림**—세션과 무관하지만 **헤더 압축(HPACK)** 관점에서 **중간자 난이도↑**.
- **H3/QUIC(UDP)**: **TLS 1.3 내장** + **연결 마이그레이션**(네트워크 바뀌어도 세션 유지)—전송 중 탈취 난이도↑, **0-RTT 재전송**에 대한 **재사용 방어(리플레이 보호)** 필요.

#### HSTS 간단 점검 스니펫(테스트용)

```bash
curl -sI https://example.com | grep -i strict-transport-security
# 출력이 없으면 HSTS 미적용

```

---

### 세션 고정(Fixation)·JWT 재사용

- **Fixation**: 로그인 전 고정된 세션 id로 로그인 후에도 동일 id 유지 → **로그인 직후 토큰 재발급**으로 차단.
- **JWT**: 편의성↑ vs **탈취 시 재사용** 위험. **짧은 exp, jti(고유 id), 서버측 denylist, audience/issuer/nbf 검증** 필수.
- **민감행위는 재인증**(MFA/비밀번호 확인).

---

## DNS 스푸핑/캐시 포이즈닝, Split-Horizon·DoH/DoT와 정책

### 위협 모델

- **캐시 포이즈닝**: 재귀 리졸버의 캐시에 **거짓 레코드 삽입**(TXID·포트 추측, 응답 위조, 0x20 case 등)
- **스푸핑/MITM**: 로컬망·게이트웨이에서 **DNS 트래픽 가로채기**
- **Split-Horizon**: 내부/외부 **다른 응답**—운영/정책 혼선, **오픈 리졸버** 노출 시 위험

### 방어: 리졸버/권한서버 보안

- **DNSSEC 검증**(리졸버): 서명·체인 검증 실패 시 거부
- **소스포트 랜덤화/0x20 랜덤화**
- **권한 서버**: **서명(zone signing)**, **NSEC3**, **bailiwick** 준수, **오픈 리커전 금지**
- **정책**: **사내 전용 리졸버 강제**(e.g., DHCP 옵션), **외부 DoH/DoT 우회 차단**(허용 목록만)

#### Unbound(리졸버) — DNSSEC+DoT 포워딩(학습용)

```yaml
# /etc/unbound/unbound.conf.d/lab.conf

server:
  auto-trust-anchor-file: "/var/lib/unbound/root.key"
  cache-min-ttl: 60
  qname-minimisation: yes
  harden-below-nxdomain: yes

forward-zone:
  name: "."
  forward-tls-upstream: yes
  forward-addr: 9.9.9.9@853    # 예시(조직 정책에 맞게)
  forward-addr: 1.1.1.1@853
```

#### BIND(권한 서버) — zone 서명(요지)

```bash
# 키 생성(테스트)

dnssec-keygen -a ECDSAP256SHA256 -n ZONE example.internal
# named.conf에 auto-dnssec maintain / inline-signing 구성

```

#### RPZ(정책 존) — 도메인 차단/리다이렉트

- 악성 도메인 **차단** 또는 **싱크홀**(내부 IP)
- **주의**: 오탐/업무 영향—**감시 → 차단** 단계적

---

### DoH/DoT 정책

- 엔터프라이즈: **허용된 엔드포인트(프록시/게이트웨이)**만 사용, 임의 DoH 차단
- **탐지**:
  - **SNI/JA3**로 **알려진 공용 DoH**(ex. `mozilla.cloudflare-dns.com`) 식별
  - **고정 IP(DoH CDN)** 기반 egress 감시
- **차단**: 프록시 경유 강제, **L7 FW**로 비인가 DoH 차단(허용목록 기반)

---

### 탐지 룰(개념)

- **동일 쿼리에 상이 IP가 짧은 시간 연속**(서버 다름/TTL 비정상) → 의심
- **내부 단말이 외부 DoH에 직접 연결**(목록 외) → 경보
- **권한 서버 없는 구간에서 Authority 추가 정보**(bailiwick 위반) → 경보

#### Zeek 의사스크립트 — “다중 응답/서버”

```zeek
@load protocols/dns
global recent_answers: table[string] of set[addr] &create_expire=10secs;

event dns_A_reply(c: connection, msg: dns_msg, ans: dns_answer)
{
  local q = msg$qname;
  local a = ans$addr;
  add recent_answers[q][a];
  if ( |recent_answers[q]| > 3 ) {
    print fmt("[ALERT] DNS many distinct A for %s in 10s: %s", q, recent_answers[q]);
  }
}
```

---

## IPv6 특화: ND 스푸핑, SLAAC 악용, RA 가짜 주입

### 개념 요약

- **ND(Neighbor Discovery)**: ARP 대체(IPv6). MAC 해석, 이웃 탐색
- **SLAAC**: 라우터 광고(RA) 기반 **자동 주소 구성**
- **공격면**: **가짜 RA**로 **기본 라우터/프리픽스** 바꾸기, ND 캐시 혼란

### 방어 기술

- **RA Guard**(스위치): **비인가 포트의 RA 차단**
- **DHCPv6 Guard**: DHCPv6 서버 위장 차단
- **ND Inspection/SAVI**: ND 바인딩 검증(벤더 종속)
- **호스트**: 라우터/서버에서 **accept_ra=0**(라우터 역할 장비), 필요 시 IPv6 사용 정책 정리
- **무선**: WIDS로 **RA 폭주/출처 이상** 탐지

#### Linux 라우터(accept_ra 비활성화)

```bash
sysctl -w net.ipv6.conf.all.accept_ra=0
sysctl -w net.ipv6.conf.default.accept_ra=0
# 실제 라우터/서버는 RA를 수용하지 않도록 기본 템플릿화

```

#### 스위치(개념 CLI)

```text
ipv6 nd raguard policy RA-POL
  device-role router
!
interface Gi1/0/1
  ipv6 nd raguard attach-policy RA-POL
!
ipv6 dhcp guard policy D6-POL
  device-role server
interface Gi1/0/2
  ipv6 dhcp guard attach-policy D6-POL
```

### 탐지 아이디어

- 짧은 시간 **RA 프레임 급증**, **새 라우터 MAC** 관측
- 단말에 **기본 라우터 변경 이벤트**(Syslog/ND 테이블 변화)
- ND 캐시에서 **같은 IPv6 ↔ MAC 매핑 변동**(Zeek/스위치 로그)

---

## 실습: 합법 샌드박스에서 MITM→탐지 룰·차단 전략 수립

> **실제 MITM 공격 수행 금지.** 대신 **pcap 재생·합성 이벤트**로 **탐지→차단** 체인을 검증.

### 랩 아키텍처(컨테이너/네임스페이스)

```
client ─(labnet)─ proxy(gw) ─(labnet)─ server
             └─ observer(패시브 캡처: Zeek/Suricata/tcpdump)
```
- `proxy(gw)`: **정상 프록시/게이트웨이 역할**만 수행(악성 행위 X)
- `observer`: pcap 저장 → TShark/Zeek/Suricata로 후처리

### 합성 이벤트 생성기(“MITM 의심 상황”을 공격 없이 시뮬레이션)

#### (A) DNS “의심 응답 다양성” 합성

```python
# synth_dns_many_answers.py
# 목적: 동일 질의에 서로 다른 A 레코드가 연속 나타난 로그를 생성(공격 없이 탐지 파이프라인 실험)

import time, json, random
qname = "login.example.com"
answers = ["203.0.113.10","203.0.113.11","203.0.113.12","203.0.113.13"]
for i,a in enumerate(answers,1):
    evt = {
      "ts": int(time.time())+i,
      "event":"DNS_ANSWER_SYNTH",
      "qname": qname,
      "type": "A",
      "answer": a,
      "ttl": random.choice([10,20,30])  # 비정상적으로 낮은 TTL 흉내
    }
    print(json.dumps(evt))
# → SIEM 테스트 인제스트 후, “짧은 창에 다수 distinct A” 룰이 울려야 정상.

```

#### (B) “게이트웨이 MAC 변경” 합성 (IPv4/IPv6 공통 개념)

```python
# synth_gateway_mac_change.py

import time, json
gw_ip  = "10.10.0.1"
macs   = ["00:11:22:33:44:55","00:11:22:33:44:66"]
for i, m in enumerate(macs):
    print(json.dumps({"ts":int(time.time())+i, "event":"ARP_REPLY_SYNTH", "ip":gw_ip, "mac":m}))
# → 전/후 MAC 다르면 경보. 실제 ARP 위조 없이도 룰 검증 가능.

```

#### (C) “외부 DoH 직결” 합성

```python
# synth_doh_egress.py
# 허용 목록 밖의 DoH IP/도메인을 접속한 것처럼 이벤트 생성

targets = [
 {"dst_ip":"104.16.248.249","sni":"mozilla.cloudflare-dns.com"},
 {"dst_ip":"8.8.8.8","sni":"dns.google"}
]
for t in targets:
  print(json.dumps({"event":"DOH_OUTBOUND_SYNTH",**t}))
```

> 위 세 합성은 **네트워크 교란 없이** “탐지 로직이 제대로 동작하는지”를 검증하는 안전한 방법.

---

### pcap 재생으로 세션 보안 헤더·쿠키 검증(무해)

- `tcpreplay`로 **샘플 HTTP pcap** 재생 → `observer`에서 캡처
- **TShark**로 **Set-Cookie/HSTS/리다이렉트** 확인

```bash
# HSTS 유무

tshark -r sample.pcap -Y 'http.response and http.header.name == "Strict-Transport-Security"' \
  -T fields -e http.header.value | head

# 쿠키 보안 속성 점검(단순 문자열 검색 예)

tshark -r sample.pcap -Y 'http.set_cookie' -T fields -e http.set_cookie \
 | grep -E 'Secure;.*HttpOnly' | wc -l
```

> 운영망 pcap은 **헤더만 스냅샷**하고 **민감값 마스킹**이 원칙.

---

### 차단·완화 전략(정책 예시)

#### (1) 세션/웹

- **HSTS 전면화**(preload 대상 도메인 검토), **쿠키 보안속성 표준 템플릿**
- **민감행위 재인증**(MFA), **토큰 회전** + **로그인 직후 세션 id 교체**
- CSP/Trusted Types로 XSS 표면 축소 → **세션 탈취 간접경로 차단**

#### (2) DNS

- **사내 리졸버 강제**(DHCP 옵션, 프록시 PAC), **외부 DoH/DoT 차단**(허용 목록 이외 경보/차단)
- **DNSSEC 검증+서명**, **RPZ 운영**(관찰→차단 단계)
- Split-Horizon 사용 시 **문서화/테스트**(캐시 상호작용/TTL)

#### (3) IPv6

- **RA Guard/DHCPv6 Guard** 기본, **라우터 역할 기기는 accept_ra=0**
- ND/RA 이상치 탐지(WIDS/NDR), **IPv6 미사용 구간은 명시적 비활성화**

#### (4) Egress/프록시

- **프록시/게이트웨이 우회 금지**(투명 프록시+인증), **비인가 외부 암호화 터널(임의 DoH/VPN)** 탐지·차단
- TLS 메타(SNI/JA3/JA4) 기반 **허용목록 중심** 모니터링

---

### Suricata/Zeek/SIEM 룰(개념)

**[Suricata] 외부 DoH 후보(허용목록 외 SNI)**
```json
# EVE JSON 후단에서 처리: event_type=="tls" && tls.sni IN doh_known AND not in allowlist -> alert

```

**[Zeek] 동일 qname 다중 A 관찰**
```zeek
# 예제를 활용. distinct answers > N within T => notice

```

**[SIEM] 게이트웨이 MAC 변경**
```
if event=="ARP_REPLY" and ip==GATEWAY_IP:
  group by 1h; alert when distinct(mac) > 1
```

---

### 회귀(Regression) 테스트 자동화(개념)

```bash
# 합성 이벤트 생성 → 테스트 인제스트

python3 synth_dns_many_answers.py  | curl -X POST http://siem.test/ingest
python3 synth_gateway_mac_change.py| curl -X POST http://siem.test/ingest
python3 synth_doh_egress.py        | curl -X POST http://siem.test/ingest

# 기대 알림 수 비교

siemctl query "alerts where rule='DNS Many Answers' and ts >= now()-5m" | jq length
```

---

## 마무리 요약

- **세션 하이재킹은 전송+저장+재사용 조건이 겹칠 때 성립**—TLS/HSTS/쿠키 보안속성/토큰 회전으로 전제조건을 깨라.
- **DNS는 DNSSEC·정책 리졸버 강제·DoH/DoT 허용목록**으로 보호하고, **다중 응답/TTL 이상**을 탐지하라.
- **IPv6**에서는 **RA/DHCPv6 Guard, ND 검증, 호스트 accept_ra 정책**이 필수.
- **실습**은 **합성 이벤트·pcap 재생**으로 **탐지→차단** 체인을 검증—실제 공격 재현 없이도 충분히 운영 품질을 끌어올릴 수 있다.
