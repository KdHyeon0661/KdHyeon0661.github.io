---
layout: post
title: MFC - 업데이트, 배포
date: 2025-09-22 22:25:23 +0900
category: MFC
---
# 업데이트/배포 심화  
**MSIX(앱 데이터 마이그레이션/Capabilities), Squirrel/WinSparkle 자동 업데이트, 코드 서명·타임스탬프 전략**

> 목표: **Win32/MFC 앱**을 최신 배포·업데이트 체계로 전환/유지하면서  
> **데이터 손실 없이**(마이그레이션), **원클릭 업데이트**(자동화), **신뢰도 높은 서명**(EV/타임스탬프)까지 한 번에 정리.

---

## 0) 로드맵 개요

- **MSIX 패키징**  
  - 장점: 깨끗한 설치/제거, 파일/레지스트리 가상화, 기업 배포 친화, 자동 업데이트(앱 설치 관리자/App Installer)  
  - 핵심: **AppData 마이그레이션(기존 MSI/Zip → MSIX)**, **Capabilities/정책**, **AppInstaller로 자동 업데이트**
- **Squirrel.Windows** (클라이언트 PC 사용자권한 설치에 유리)  
  - 장점: 사용자 프로필에 설치, 델타 업데이트, Shortcut 관리, 이탈율 낮음  
  - 핵심: **releases 폴더** 구조, **Update.exe** 사용법, 채널/롤백
- **WinSparkle** (C++ 앱에 가볍게 붙는 AppCast 기반)  
  - 장점: 심플한 RSS(AppCast) + DSA/Ed25519 서명 검증, UI 친화  
  - 핵심: **피드 설계**, **서명/검증**, **무중단 업데이트 UX**
- **코드서명 & 타임스탬프**  
  - EV 인증서/서버 보관(KMS/HSM), **SHA-256** 서명, **RFC 3161 타임스탬프**, **재현성/신뢰도**  
  - SmartScreen 평판, 이중 서명(레거시 필요 시), 파이프라인 자동화

---

# 1. MSIX: 패키징·Capabilities·데이터 마이그레이션

## 1.1 무엇이 바뀌나?

- 설치 경로: `C:\Program Files\WindowsApps\<패키지>` (읽기 전용 컨테이너)  
- 앱 데이터: `%LOCALAPPDATA%\Packages\<PackageFamilyName>\LocalState` (RoamingState/TempState 유사)  
- 레지스트리 가상화: HKCU/HKLM의 일부가 **컨테이너 스토어**(Registry.dat)로 리다이렉트  
- 실행: **runFullTrust** 를 선언한 **데스크톱 브릿지/Win32** 가능 (UWP API 일부 병용)

## 1.2 최소 Manifest(발췌)

`Package.appxmanifest` (핵심 파트만)
```xml
<Package
  xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
  xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
  IgnorableNamespaces="uap rescap">
  <Identity Name="com.acme.myapp"
            Publisher="CN=ACME Company, O=ACME, C=US"
            Version="1.2.3.0" />
  <Properties>
    <DisplayName>Acme MyApp</DisplayName>
    <PublisherDisplayName>ACME</PublisherDisplayName>
    <Logo>Assets\StoreLogo.png</Logo>
  </Properties>
  <Dependencies>
    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.19041.0" MaxVersionTested="10.0.22621.0" />
  </Dependencies>

  <Applications>
    <Application Id="App" Executable="VFS\ProgramFilesX64\Acme\MyApp\MyApp.exe" EntryPoint="Windows.FullTrustApplication">
      <uap:VisualElements DisplayName="MyApp" Square150x150Logo="Assets\Logo.png" Description="Acme Editor" />
      <!-- Win32 실행 허용 -->
      <Extensions>
        <uap:Extension Category="windows.fullTrustProcess" />
      </Extensions>
    </Application>
  </Applications>

  <!-- 파일 연계/프로토콜/시작작업 등은 <Extensions> 추가 선언 -->

  <!-- Capabilities (필요 최소만) -->
  <Capabilities>
    <!-- 일반 데스크톱 브릿지는 전통적 파일 접근 가능. UWP API 일부 쓸 땐 다음 고려 -->
    <uap:Capability Name="internetClient" />
    <!-- 고급: 전체 파일 시스템 접근(테스트/특수 배포에서만, 정책 필요) -->
    <!-- <rescap:Capability Name="broadFileSystemAccess"/> -->
  </Capabilities>
</Package>
```

> **주의**  
> - **broadFileSystemAccess** 는 Windows 설정/정책 허용이 필요하고 스토어 정책에 제한됩니다.  
> - 가능한 한 **AppData(패키지 컨테이너)** 를 기본 저장소로 쓰고, 외부 폴더는 `IFileDialog`/`KnownFolder`로 **사용자가 선택**하게 하세요.

## 1.3 App Installer(.appinstaller)로 자동 업데이트

사용자가 **ms-appinstaller://** 링크(또는 웹 URL의 `.appinstaller`)를 통해 설치하면, **Windows App Installer**가 **지속적 업데이트**를 관리합니다.

예시 `MyApp.appinstaller`:
```xml
<AppInstaller
    xmlns="http://schemas.microsoft.com/appx/appinstaller/2017/2"
    Uri="https://cdn.acme.com/releases/MyApp.appinstaller"
    Version="1.2.3.0">
  <MainPackage
      Name="com.acme.myapp"
      Publisher="CN=ACME Company"
      Version="1.2.3.0"
      Uri="https://cdn.acme.com/releases/MyApp_1.2.3.0_x64.msix" />
  <UpdateSettings>
    <OnLaunch HoursBetweenUpdateChecks="6" ShowPrompt="true" />
    <!-- 또는 BackgroundTask="true" 로 자동, Prompt 없이도 가능(정책/UX에 맞게) -->
  </UpdateSettings>
</AppInstaller>
```

- **CDN에 .msix + .appinstaller** 를 올리고, 배포 링크는 `.appinstaller`로 제공  
- 사용자는 시작/주기적 체크 때 **자동 업데이트** 경험

## 1.4 기존 데이터 마이그레이션(핵심 전략)

문제: 기존 설치(MSI/Zip)에서  
- 설정: `HKCU\Software\Acme\MyApp\...`  
- 데이터: `%APPDATA%\Acme\MyApp\config\settings.json`, `%LOCALAPPDATA%\Acme\MyApp\cache\...`

MSIX 전환 시 기본 저장 경로는  
`%LOCALAPPDATA%\Packages\<PFN>\LocalState` (및 RoamingState).

### 전략 A) **첫 실행 마이그레이션 코드** (권장)

1. **기존 경로 검사** → 발견 시 **패키지 컨테이너로 Copy**  
2. **원본 보존/백업**(안전 모드), **Idempotent**(중복 실행해도 OK)

도우미 함수(C++/Win32):
```cpp
#include <shlobj.h>     // SHGetKnownFolderPath
#include <appmodel.h>   // GetCurrentPackageFamilyName
#include <filesystem>
#include <fstream>

std::filesystem::path PackageLocalState() {
    // LocalState = %LOCALAPPDATA%\Packages\<PFN>\LocalState
    wchar_t pfw[PACKAGE_FAMILY_NAME_MAX_LENGTH+1] = {};
    UINT32 len = _countof(pfw);
    if (GetCurrentPackageFamilyName(&len, pfw) != ERROR_SUCCESS)
        throw std::runtime_error("not packaged?");
    PWSTR localAppData = nullptr;
    SHGetKnownFolderPath(FOLDERID_LocalAppData, KF_FLAG_DEFAULT, nullptr, &localAppData);
    std::filesystem::path p = std::filesystem::path(localAppData) / L"Packages" / pfw / L"LocalState";
    CoTaskMemFree(localAppData);
    std::filesystem::create_directories(p);
    return p;
}

void MigrateIfNeeded() {
    // 원래 위치들
    PWSTR roam = nullptr, local = nullptr;
    SHGetKnownFolderPath(FOLDERID_RoamingAppData, 0, nullptr, &roam);
    SHGetKnownFolderPath(FOLDERID_LocalAppData, 0, nullptr, &local);
    std::filesystem::path oldCfg = std::filesystem::path(roam)  / L"Acme\\MyApp\\config\\settings.json";
    std::filesystem::path oldDat = std::filesystem::path(local) / L"Acme\\MyApp\\data";
    CoTaskMemFree(roam); CoTaskMemFree(local);

    auto dst = PackageLocalState();
    bool migrated = false;

    std::error_code ec;
    if (std::filesystem::exists(oldCfg, ec)) {
        std::filesystem::create_directories(dst / L"config");
        std::filesystem::copy_file(oldCfg, dst / L"config\\settings.json",
            std::filesystem::copy_options::overwrite_existing, ec);
        migrated = true;
    }
    if (std::filesystem::exists(oldDat, ec)) {
        std::filesystem::create_directories(dst / L"data");
        for (auto& e : std::filesystem::recursive_directory_iterator(oldDat))
            if (e.is_regular_file()) {
                auto rel = std::filesystem::relative(e.path(), oldDat, ec);
                std::filesystem::create_directories((dst/L"data")/rel.parent_path());
                std::filesystem::copy_file(e.path(), (dst/L"data")/rel,
                    std::filesystem::copy_options::overwrite_existing, ec);
            }
        migrated = true;
    }
    if (migrated) {
        // 마이그레이션 플래그 기록
        std::ofstream((dst / L"migrated.flag").string());
    }
}
```

> **팁**  
> - 마이그레이션은 **한 번만** 실행되도록 플래그 파일/레지스트리(패키지 컨테이너 내)로 기록  
> - 권한 문제로 실패할 수 있으니 **에러는 로깅 + 유저 가이드** 제공

### 전략 B) **Package Support Framework(PSF) Fixup** 활용

- 레거시 앱이 **하드코딩 경로**(Program Files, HKLM 등)에 쓰려는 시도를 **자동 리다이렉트**  
- `FileRedirectionFixup`/`RegLegacyFixups` 등 설정을 `config.json` 으로 선언  
- **장점**: 코드 수정 최소화  
- **단점**: 앱 내부 구조 모르고 쓰면 예기치 않은 부작용(권장: 마이그레이션 코드 + 최소 Fixup)

`config.json`(예시, PSF):
```json
{
  "applications": [
    { "id": "App", "executable": "VFS\\ProgramFilesX64\\Acme\\MyApp\\MyApp.exe", "arguments": "" }
  ],
  "processes": [
    {
      "executable": "MyApp.exe",
      "fixups": [
        { "dll": "FileRedirectionFixup.dll",
          "config": {
            "redirectedPaths": {
              "packageRelative": [
                { "base": "PackageDrive", "pattern": "VFS\\ProgramFilesX64\\Acme\\MyApp\\config\\*" }
              ],
              "knownFolders": [
                { "id": "FOLDERID_RoamingAppData", "relative": "Acme\\MyApp\\config\\*" }
              ]
            }
          }
        }
      ]
    }
  ]
}
```

> **실무**: 처음엔 **A)** 직접 복사(1회) + 코드에서 **ApplicationData.Current.LocalFolder**/`PackageLocalState()` 를 적극 사용.  
> PSF는 **마지막 수단**으로 필요한 경로만 명시적으로.

## 1.5 차별 배포: Stable/Beta/Canary

- `.appinstaller` 파일을 **채널별**로 분리  
  - `https://cdn/acme/MyApp_Stable.appinstaller`  
  - `https://cdn/acme/MyApp_Beta.appinstaller`  
- 앱 내부에 **채널 전환 메뉴** 제공(링크 교체 → App Installer가 새 소스 따라감)

---

# 2. Squirrel.Windows: 사용자 프로필 설치·델타 업데이트

## 2.1 개념 요약

- **Setup.exe** 로 설치 → `%LocalAppData%\MyApp` 아래 **app-{version}** 폴더 관리  
- 자동 업데이트 **Update.exe** 가 담당 (앱 실행 시 백그라운드로 체크)  
- **releases/** 폴더(HTTP/파일 공유)에서 `.nupkg`(NuGet) 패키지로 **풀/델타** 제공

## 2.2 빌드 파이프라인(간단)

### 1) 앱 빌드 후 `Squirrel --releasify`

PowerShell:
```powershell
# 1) nupkg 준비 (Squirrel-aware)
nuget pack MyApp.nuspec -Version 1.2.3 -OutputDirectory artifacts

# 2) releasify: Setup.exe + RELEASES + delta 패키지 생성
& .\Squirrel.exe --releasify artifacts\MyApp.1.2.3.nupkg `
   --releaseDir .\releases `
   --setupIcon .\assets\setup.ico `
   --no-msi
```

`MyApp.nuspec`(발췌)
```xml
<package >
  <metadata>
    <id>MyApp</id>
    <version>1.2.3</version>
    <authors>ACME</authors>
    <description>Acme Editor</description>
  </metadata>
  <files>
    <file src="bin\Release\*" target="" />
  </files>
</package>
```

### 2) 배포
- `releases/` 폴더 전체를 CDN/웹 서버에 올림  
- 첫 설치는 `Setup.exe` 를 배포(서명 필수)

## 2.3 앱 내부 업데이트 체크(C# 예)

```csharp
using Squirrel;
using System;
using System.Threading.Tasks;

static class Updater
{
    public static async Task CheckAndApply(string updateUrl)
    {
        using var mgr = await UpdateManager.GitHubUpdateManager(updateUrl); // or new UpdateManager(updateUrl)
        try
        {
            var result = await mgr.UpdateApp();
            // result: 업데이트 적용 여부
        }
        catch (Exception ex)
        {
            // 로깅 후 무시(앱 실행 지속)
            Console.WriteLine("Update failed: " + ex);
        }
    }
}
```

- **권장 UX**: 백그라운드로 다운로드·적용, 다음 실행 시 새 버전  
- **롤백**: `Update.exe --rollback` 지원(이벤트/스위치로 제공)

## 2.4 채널/롤아웃

- `releases` 루트에 `beta/`, `canary/` 서브 경로를 운영  
- 앱 설정에서 URL 전환(예: `https://cdn/acme/releases-beta/`)  
- 점진적 롤아웃: 퍼센트로 샘플링하여 채널을 **임시로** 바꿔 체크

---

# 3. WinSparkle: AppCast 기반 가벼운 자동 업데이트

## 3.1 개요

- **AppCast (RSS/Atom + `enclosure` 링크)** 를 주기적으로 체크  
- 업데이트 패키지(보통 `.exe`/`.msi`/`.zip`)에 대해 **DSA/Ed25519** 서명 검증  
- C/C++ 앱에 **간단 초기화 코드**만 추가

## 3.2 코드(최소)

```cpp
#include <winsparkle.h>

void InitWinSparkle()
{
    // 앱캐스트 URL
    win_sparkle_set_appcast_url(L"https://cdn.acme.com/appcast.xml");

    // 앱 정보 (SmartScreen/Telemetry 대비로 버전/회사 설정)
    win_sparkle_set_app_details(L"ACME", L"MyApp", L"1.2.3");

    // 자동체크 간격(초)
    win_sparkle_set_update_check_interval(60 * 60 * 6); // 6시간
    // 시작시 체크
    win_sparkle_set_automatic_check_for_updates(1);

    win_sparkle_init();
}

// 종료 시
// win_sparkle_cleanup();
```

`appcast.xml` 예시(Ed25519/DSA는 라이브러리 버전에 따라):
```xml
<rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle">
  <channel>
    <title>MyApp Updates</title>
    <item>
      <title>Version 1.2.3</title>
      <enclosure url="https://cdn.acme.com/downloads/MyApp-1.2.3-Setup.exe"
                 sparkle:version="1.2.3"
                 length="45678901"
                 type="application/octet-stream"
                 sparkle:edSignature="base64_sig_here" />
      <sparkle:releaseNotesLink>https://acme.com/releases/1.2.3.html</sparkle:releaseNotesLink>
    </item>
  </channel>
</rss>
```

> **포인트**  
> - 설치 파일(Setup.exe/MSI)은 **코드 서명** 필수  
> - AppCast 내용은 **HTTPS** 제공, 시그니처 검증 켜기

---

# 4. 코드 서명 & 타임스탬프 전략

## 4.1 왜 중요한가

- SmartScreen/AV 오탐 방지, 기업 정책 통과, 드라이버/서비스 설치 권한  
- **MSIX**: 패키지 자체가 **서명 필수**  
- 자동 업데이트 체계(Squirrel/WinSparkle)도 **서명 + 타임스탬프**가 안정성 확보

## 4.2 인증서 선택

- **EV Code Signing** 권장(하드웨어 토큰/HSM) → SmartScreen 초기 신뢰 빠르게  
- 일반 코드 서명(OV)도 가능하나 초기 배포 시 경고 가능

## 4.3 서명 명령(signtool)

### (A) 일반 파일(EXE/DLL/Setup.exe)
```powershell
# RFC 3161 타임스탬프(우선), SHA-256
signtool sign /fd SHA256 /td SHA256 `
  /tr http://timestamp.digicert.com `
  /a /sm /n "ACME Company" `
  "dist\Setup.exe"

# 검증
signtool verify /pa /v "dist\Setup.exe"
```

> **대체 TSA** 준비(장애 대비): `/tr http://timestamp.sectigo.com` 등  
> 자동화에선 **재시도/백오프** 로버스트하게.

### (B) MSIX 서명

- **MakeAppx** → **SignTool** (또는 `signtool /fd SHA256 /a /f cert.pfx /p ... MyApp.msix`)
```powershell
signtool sign /fd SHA256 /td SHA256 /tr http://timestamp.digicert.com `
  /a /sm /n "ACME Company" "out\MyApp_1.2.3_x64.msix"
```

### (C) 이중 서명(레거시 호환 필요 시)

> 2025 기준 Win7은 EOL, 대부분 **SHA-256 단독**이면 충분.  
> 과거 Win7(패치 미적용) 지원이 절대 필요하면 **SHA-1 + SHA-256** 이중 서명 고려(권장 X).

## 4.4 비밀 키 보호

- **HSM/클라우드 코드 서명**(Azure Key Vault Sign, Google CAS, DigiCert Keylocker 등)  
- GitHub Actions → **OIDC + SignServer** 연계(서명 요청만, 키는 밖에)  
- 로컬 개발 PC에 PFX 저장 금지, 비번/토큰 노출 주의

## 4.5 재현성 & 신뢰

- 동일 바이너리에서 **서명만 달라지는** 빌드 변수 최소화  
- 서명 후 `sigcheck -q -m`(Sysinternals) 로 서명 체인·타임스탬프 점검  
- 릴리스 아티팩트에 **SBOM/해시(SHA-256)** 함께 공개

---

# 5. 채널/롤백/정책

## 5.1 점진 배포

- **MSIX(App Installer)**: 채널 별 `.appinstaller` , 내부에 `<UpdateSettings>` 로 주기 제어  
- **Squirrel**: 특정 퍼센트 사용자에만 **beta URL** 노출  
- **WinSparkle**: AppCast에 **프리릴리스 항목** 별도 채널 분리

## 5.2 롤백 전략

- **MSIX**: 이전 패키지 버전(.msix) 유지 → App Installer에서 **downgrade 불가** 기본.  
  - 필요 시 **ForceUpdateFromAnyVersion** 옵션(엔터프라이즈 시나리오에서)  
- **Squirrel**: `--rollback` 스위치, 이전 `app-<ver>` 선택  
- **WinSparkle**: AppCast를 **이전 버전**으로 되돌려 제공

## 5.3 프록시/오프라인

- **서명/다운로드** 모두 **HTTP(S) 프록시** 고려(시스템/WinHTTP)  
- 오프라인 배포: MSIX **오프라인 설치 패키지** + 내부 AppInstaller URL(인트라넷)

---

# 6. 실제 프로젝트 워크플로(샘플)

```
[main]
 ├─ app/ (Win32/MFC)
 ├─ packaging/msix/
 │   ├─ Package.appxmanifest
 │   ├─ Assets/...
 │   ├─ PSF/config.json (옵션)
 │   └─ MyApp.appinstaller
 ├─ packaging/squirrel/
 │   ├─ MyApp.nuspec
 │   └─ assets/setup.ico
 ├─ tools/signing/
 │   └─ sign.ps1 (signtool + 재시도)
 └─ .github/workflows/release.yml
```

`release.yml` (핵심 단계)
{% raw %}
```yaml
name: Release
on:
  workflow_dispatch:
    inputs:
      version:
        required: true
jobs:
  build:
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v4
    - name: Build
      run: |
        cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
        cmake --build build --config Release --parallel
    - name: Package MSIX
      run: |
        # makeappx.exe pack ...
        # or use MSIX Packaging Tool CLI
    - name: Sign (Azure Key Vault)
      uses: azure/trusted-signing-action@v0
      with:
        files: |
          out\MyApp_*.msix
          dist\Setup.exe
        timestamp-rfc3161: http://timestamp.digicert.com
    - name: Squirrel Releasify
      run: |
        .\Squirrel.exe --releasify artifacts\MyApp.${{ inputs.version }}.nupkg --releaseDir releases
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: releases
        path: releases/**
```
{% endraw %}

---

# 7. 보안/신뢰 체킹리스트

- [ ] 모든 배포물(EXE/DLL/MSIX/Setup.exe/update.exe) **서명 + 타임스탬프**  
- [ ] 릴리스 파이프라인에서 **서명 실패 시 즉시 중단**  
- [ ] 릴리스 페이지에 **SHA-256 해시**/변경로그  
- [ ] 업데이트 통신 **HTTPS 강제**, 인증서핀(선택)  
- [ ] WinSparkle의 AppCast에 **서명(enclosure signature)** 사용  
- [ ] MSIX 일괄 배포(GPO/Intune)는 **Publisher** 일치 필수

---

# 8. UX 베스트 프랙티스

- **조용한 업데이트** 기본 + “재시작 필요”만 안내  
- **변경 로그**는 **요약 카드**로 짧게, 상세 페이지 링크  
- **데이터 마이그레이션** 진행 표시(큰 데이터 시), 실패 시 **원복**/가이드  
- 업데이트 실패 시 **재시도**·**오프라인 패키지 경로** 노출

---

# 9. 문제 해결 가이드

| 증상 | 원인 | 해결 |
|---|---|---|
| MSIX 설치 시 “서명 오류” | 인증서 체인/루트 미설치 | 신뢰 루트 확인, EV/OV 체인 점검, `signtool verify /pa /all` |
| 업데이트 안 됨(App Installer) | `.appinstaller` Uri/버전 불일치 | `Version` 증가, CDN 캐시 무효화, URL 유효성 확인 |
| Squirrel 업데이트 실패 | `RELEASES` 손상/델타 불가 | 풀 패키지 재배포, `--no-deltas` 임시 |
| WinSparkle 경고창 | AppCast 또는 서명 누락 | enclosure URL/시그니처 점검, HTTPS 여부 |
| 데이터 사라짐 | 마이그레이션 미실행 | 첫 실행 코드/PSF 설정 재확인, 로그 수집 |

---

# 10. 결정 가이드(어떤 방식을 쓸까?)

| 상황 | 권장 |
|---|---|
| 엔터프라이즈/스토어/IT 관리 | **MSIX + App Installer** |
| 개인 사용자 대상, 설치권한 최소화 | **Squirrel.Windows** |
| C++ 순수 앱, 가벼운 업데이트 | **WinSparkle** |
| 기존 고객 데이터 많음 | **첫 실행 마이그레이션 코드** + (필요시) **PSF** |

---

## 부록 A) AppInstaller 고급 옵션

```xml
<UpdateSettings>
  <AutomaticBackgroundTask>true</AutomaticBackgroundTask>
  <ForceUpdateFromAnyVersion>true</ForceUpdateFromAnyVersion> <!-- 다운그레이드 포함(신중) -->
  <HoursBetweenUpdateChecks>4</HoursBetweenUpdateChecks>
  <ShowPrompt>false</ShowPrompt>
  <UpdateBlocksActivation>true</UpdateBlocksActivation> <!-- 앱 실행 차단 후 업데이트(강제) -->
</UpdateSettings>
```

> 엔터프라이즈 내부 배포에서 **강제 최신 상태**가 필요할 때만 사용.

## 부록 B) SmartScreen/평판 빨리 쌓는 팁

- **EV 서명** 사용, **다운로드 수** 쌓기(웹사이트/배포 채널 일관)  
- 변경 빈번한 **Update.exe/Setup.exe** 는 버전 고정/재활용(해시 자주 안 바뀌게)

## 부록 C) Win32에서 패키지 경로/상태 접근 요약

```cpp
// 패키지 여부 확인
UINT32 len=0; LONG rc = GetCurrentPackageFullName(&len, nullptr);
bool isPackaged = (rc != APPMODEL_ERROR_NO_PACKAGE);

// 패밀리/로컬 상태 경로 얻기 → PackageLocalState() 참조
```

---

# 마무리

- **MSIX** 로 **설치/제거의 청결 + 자동 업데이트** 를 얻고,  
- **첫 실행 마이그레이션 코드**로 **기존 데이터**를 안전히 옮기며,  
- 상황에 따라 **Squirrel/WinSparkle** 로 **경량/유연한 자동 업데이트**를 선택,  
- 끝으로 **EV 서명 + RFC3161 타임스탬프**로 **신뢰/내구성**을 확보하세요.