---
layout: post
title: 웹해킹 - XS-Leaks
date: 2025-10-05 18:25:23 +0900
category: 웹해킹
---
# 12. XS-Leaks(측채널: 히스토리·타이밍·프레임)

## 0) 한눈에 보기

- **XS-Leaks란?**  
  *교차 오리진 상태*(로그인 여부·개인화 유무·리소스 존재 등)를 **직접 읽지 않고**,  
  **타이밍/이벤트/리다이렉션/프레임 수/리소스 크기** 같은 부수 신호를 통해 **추측**하는 기법들의 총칭.

- **대표 벡터**
  1) **타이밍/리다이렉션 기반**: 로그인과 비로그인일 때 **로드 시간/리다이렉션 단계**가 다름.  
  2) **프레임/창 상태 기반**: 페이지 구조 차이(내부 iframe 수 등), `window.opener`/`window.length` 같은 메타 정보.  
  3) **리소스 크기·이벤트 기반**: `/avatar`의 **이미지 크기/`onload`/`onerror`** 차이로 유무/권한 추정.  
  4) **캐시/네비게이션 힌트**: 캐시 히트/미스, bfcache/프리로드 렌더링 여부로 상태 노출.

- **핵심 방어**
  - **쿠키 SameSite**(교차 사이트 서브리소스 요청에 세션 쿠키 미전송)  
  - **프레임 금지**(`X-Frame-Options`/`CSP frame-ancestors`)  
  - **교차 오리진 포함 자체를 막기**: `Cross-Origin-Resource-Policy`(CORP)·`COOP/COEP`  
  - **Fetch Metadata 헤더 기반 정책**(Sec-Fetch-Site/Mode/Dest)  
  - **타이밍/크기 등 신호 최소화**(상태 무관 **동일 응답코드/길이/캐시/지연**)  
  - **상태 노출 페이지 보호**(인증/동일 출처 전용/캐시 금지)

---

## 1) 위협 모델 & 왜 위험한가

브라우저 SOP(동일출처정책)는 **응답 본문 접근**만 막습니다.  
하지만 **“접근은 못해도 관찰은 가능”**한 현상(이벤트/타이밍/레이아웃/상태머신)을 통해  
공격자는 **사용자의 현재 로그인 상태, 특정 자원 존재 여부, 계정 특성**을 유추할 수 있습니다.

- 예: `/avatar`가 **로그인 시 200x200 PNG**, **비로그인 시 1x1 투명**으로 리다이렉션 된다면,  
  공격자는 `<img src="https://victim/avatar">`의 **onload + naturalWidth**로 **로그인 여부**를 추정할 수 있습니다.

---

## 2) 대표 XS-Leaks 벡터 & “안전 재현” 점검 포인트

> 아래는 **차단 확인용** *방어 중심 체크리스트* 입니다(스테이징에서만).

### 2.1 타이밍/리다이렉션 기반
- **패턴**: `/account`(로그인) → 200(대용량); 비로그인 → 302→302→200(작음).  
- **점검**: 스테이징에서 두 상태의 **네비게이션/리소스 로드 시간 분포**가 *유의미하게* 달라지지 않게 설계(동일 길이/캐시/지연).

### 2.2 프레임/창 상태 기반
- **패턴**: 로그인 시 `/home` 내부에 광고 iframe 3개, 비로그인 1개 → `window.length` 차이.  
- **점검**: **교차 오리진에서 프레임 삽입 자체**를 막는지(`frame-ancestors`), `COOP: same-origin`으로 탭 간 참조 격리하는지.

### 2.3 리소스 크기/이벤트 기반
- **패턴**: `/user/badge.svg`의 **픽셀 크기/`onload` vs `onerror`**가 상태에 따라 달라짐.  
- **점검**: **항상 같은 사이즈/타입**으로 응답하거나, **교차 오리진 포함 자체를 CORP로 금지**.

### 2.4 캐시·네비게이션 힌트
- **패턴**: 상태별로 캐시 히트율 차이→응답시간 차이.  
- **점검**: 민감 페이지 `Cache-Control: no-store`, 또는 상태를 **쿼리/헤더로 keying**해 **교차 사이트**에서 히트/미스 추정 불가.

---

## 3) 방어 전략(요약 → 상세)

### 3.1 쿠키: SameSite + Secure + Path/Scope 최소화
- 세션 쿠키는 기본 **`SameSite=Lax; Secure; HttpOnly`**.  
- 교차 사이트 서브리소스 요청(`<img>`, `<script>`, `<link>`)에서 **세션 쿠키 전송이 차단**되어,  
  “로그인 상태에 따라 응답이 달라지는” 리소스의 XS-Leaks면을 **근본 축소**.

**Node/Express**
```js
res.cookie("sid", token, {
  httpOnly: true,
  secure: true,
  sameSite: "lax",  // 가능하면 'strict'
  path: "/",
});
```

**Spring Boot**
```java
// application.yml
server:
  servlet:
    session:
      cookie:
        http-only: true
        secure: true
        same-site: lax
```

### 3.2 프레임 금지(Clickjacking + Frame-Leaks 동시 완화)
- **X-Frame-Options: DENY|SAMEORIGIN**(레거시)  
- **CSP `frame-ancestors`**: 권장. 누가 우리 페이지를 **iframe** 할 수 있는지 통제.

**Nginx**
```nginx
add_header X-Frame-Options "SAMEORIGIN" always;
add_header Content-Security-Policy "frame-ancestors 'self' https://console.example.com" always;
```

### 3.3 교차 오리진 포함 자체 차단(CORP/COEP/COOP)
- **CORP (Cross-Origin-Resource-Policy)**: **다른 오리진**에서 **no-cors**로 우리 리소스를 끼우는 걸 차단.  
  - `Cross-Origin-Resource-Policy: same-origin|same-site`
- **COOP (Cross-Origin-Opener-Policy)**: 탭 간 **opener** 참조 분리 → 창/탭 기반 XS-Leaks 완화.  
  - `Cross-Origin-Opener-Policy: same-origin`
- **COEP (Cross-Origin-Embedder-Policy)**: 교차 포함 제약 강화(특히 SharedArrayBuffer 등).

**Nginx**
```nginx
# JSON/이미지/아바타 등 상태 의존 리소스
add_header Cross-Origin-Resource-Policy "same-origin" always;
add_header Cross-Origin-Opener-Policy "same-origin" always;
# (필요 시) add_header Cross-Origin-Embedder-Policy "require-corp" always;
```

> ⚠️ **주의**: COEP는 외부 리소스들도 CORP/TAO 대응을 해야 하므로, 앱·CDN·서드파티 자산 전체를 점검하세요.

### 3.4 Fetch Metadata 기반 차단
- 브라우저가 보내는 **`Sec-Fetch-*`** 헤더(`Site/Mode/Dest`)로 **교차 사이트에서 온 서브리소스 포함**을 식별해 **민감 경로 차단**.

**Express 미들웨어**
```js
export function fetchMetadataGuard(req, res, next) {
  const site = req.get("Sec-Fetch-Site");     // same-origin | same-site | cross-site | none
  const mode = req.get("Sec-Fetch-Mode");     // cors | no-cors | navigate | same-origin | ...
  const dest = req.get("Sec-Fetch-Dest");     // image | script | document | ...
  const sensitive = req.path.startsWith("/profile") || req.path.startsWith("/avatar");

  if (sensitive && site === "cross-site" && dest !== "document") {
    // 교차 사이트에서 서브리소스 형태로 접근 → 차단
    return res.sendStatus(403);
  }
  next();
}
```

### 3.5 타이밍/크기 신호 최소화(응답 균질화)
- **HTTP status/길이/타입**을 **상태와 무관하게 통일**  
- **리다이렉션 단계** 제거/통일  
- **지연 랜덤화**(필요 시 소량) — 과도한 랜덤은 UX 저하·통계로 상쇄 가능  
- **Cache-Control**: 민감 페이지 `no-store, private` / 아바타는 *항상 같은 크기*의 플레이스홀더로

**예: 아바타 엔드포인트 통일**
```js
app.get("/avatar", (req, res) => {
  // 로그인 여부와 무관하게 항상 같은 크기의 PNG를 200으로 반환
  const img = req.user?.avatar ?? default200x200PngBuffer;
  res.set({
    "Content-Type": "image/png",
    "Cache-Control": "no-store",
    "Cross-Origin-Resource-Policy": "same-origin" // 교차 포함 자체 제한
  });
  res.send(img);
});
```

### 3.6 민감 페이지 보호
- **/account, /billing, /inbox** 같은 상태 노출 페이지는:
  - **프레임 금지**, **캐시 금지**, **COOP same-origin**, **Referrer-Policy 최소화**  
  - **로그인 상태에 상관없이 동일한 리다이렉션 패턴**으로 응답(예: 항상 `/login?next=...`으로 한 번만 302)

**Nginx**
```nginx
location /account/ {
  add_header Cache-Control "no-store" always;
  add_header Cross-Origin-Opener-Policy "same-origin" always;
  add_header X-Frame-Options "SAMEORIGIN" always;
}
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
add_header X-Content-Type-Options "nosniff" always;
```

---

## 4) 케이스별 “취약 → 수정” 미니 시나리오

### 4.1 아바타 크기 누설(이미지 onload/크기)

**❌ 취약 설계**
```js
// 로그인: 200(200x200 PNG)
// 비로그인: 302 → /img/blank-1x1.png
app.get("/avatar", (req, res) => {
  if (!req.user) return res.redirect(302, "/img/blank-1x1.png");
  return res.sendFile("/data/avatars/" + req.user.id + ".png");
});
```
- 교차 사이트 `<img src="https://victim/avatar">`에서 **onload + naturalWidth** 차이로 로그인 여부 유출.

**✅ 수정**
```js
app.get("/avatar", (req, res) => {
  const png = req.user ? userAvatarOrDefault(req.user.id) : defaultAvatarSameSize();
  res.set({
    "Content-Type": "image/png",
    "Content-Length": png.length,
    "Cache-Control": "no-store",
    "Cross-Origin-Resource-Policy": "same-origin",
  });
  res.status(200).send(png); // 항상 200 + 동일 크기/타입
});
```

### 4.2 `/account` 네비게이션 타이밍 누설

**❌ 취약 설계**
- 로그인: `/account` → 200 (대용량)  
- 비로그인: `/account` → 302 → `/login?next=/account` → 200 (소용량)  
- **리다이렉션 단계/크기 차이**로 타이밍 누설.

**✅ 수정**
- **항상 302 한 번**만: `/account` → 302 → `/account/gateway` →  
  게이트웨이는 **동일 사이즈의 스켈레톤 HTML**로 응답, 내부에서 JS가 상태 파악 후 hydrate.  
- 또는 **SameSite 쿠키 + Fetch Metadata**로 교차 사이트 네비게이션에서 **정적 Placeholder**만 응답.

---

## 5) 브라우저/플랫폼 정책과 연계

- **Resource Timing API**: 우리 리소스의 상세 타이밍 노출은 **TAO(Timing-Allow-Origin)** 설정 필요.  
  → 민감 리소스에는 **TAO 미부여**(기본), 타이밍 세부정보 노출 금지.  
- **`window.opener` 격리**: `Cross-Origin-Opener-Policy: same-origin` + 링크에 `rel="noopener"`  
  → 탭/창 기반 XS-Leaks 약화.  
- **Permissions-Policy**: `document-domain=()`로 구형 동일출처 취약화 완화, `unload=()`로 히스토리 타이밍 악용 억제(브라우저별).  
- **Referrer-Policy**: `strict-origin-when-cross-origin` 또는 더 엄격히 `no-referrer`.

---

## 6) Fetch Metadata 방어 — 언어별 예시

**Express**
```js
app.use((req, res, next) => {
  const site = req.get("Sec-Fetch-Site") || "none";
  const mode = req.get("Sec-Fetch-Mode") || "";
  const dest = req.get("Sec-Fetch-Dest") || "";

  const sensitive = /^\/(account|billing|inbox|avatar)/.test(req.path);

  // 교차 사이트에서 document 이외(이미지/스クリپ트 등)로 접근 → 차단
  if (sensitive && site === "cross-site" && dest !== "document") {
    return res.sendStatus(403);
  }
  // same-site/no-cors 등 세분화는 서비스에 맞게 조정
  next();
});
```

**Spring (서블릿 필터)**
```java
@Component
public class FetchMetadataFilter implements Filter {
  @Override public void doFilter(ServletRequest sreq, ServletResponse sres, FilterChain chain)
      throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) sreq;
    HttpServletResponse res = (HttpServletResponse) sres;
    String site = req.getHeader("Sec-Fetch-Site");
    String dest = req.getHeader("Sec-Fetch-Dest");
    String path = req.getRequestURI();

    boolean sensitive = path.startsWith("/account") || path.startsWith("/avatar");
    if (sensitive && "cross-site".equals(site) && !"document".equals(dest)) {
      res.sendError(403); return;
    }
    chain.doFilter(sreq, sres);
  }
}
```

---

## 7) 로깅/모니터링 & 테스트 자동화

### 7.1 로깅 필드
- `ts`, `path`, `status`, `len`, `redirects`, `secFetchSite`, `secFetchDest`,  
  `corp`, `coop`, `coep` 적용 여부, `frameBlocked(boolean)`

### 7.2 경보 룰
- `/avatar` 등 민감 리소스에 **cross-site 서브리소스 접근 시도** 급증  
- **프레임 차단**(XFO/CSP) 위반 탐지 증가  
- COOP/COEP 미적용 응답 비율 증가

### 7.3 “안전 재현” 하니스(로컬 두 오리진)
- `http://localhost:3000`(피해자) · `http://localhost:4000`(테스터) 두 서버로,  
  4000 쪽에서 `<img src="http://localhost:3000/avatar">` 로드/타이밍을 측정했을 때 **항상 동일 이벤트/크기**인지 확인.  
- 프레임 삽입: 4000 쪽에서 `<iframe src="http://localhost:3000/account">` → **XFO/CSP로 차단** 되어야 정상.

---

## 8) Nginx/CDN 레시피 모음

```nginx
# 공통 하드닝
add_header X-Frame-Options "SAMEORIGIN" always;
add_header Content-Security-Policy "frame-ancestors 'self'" always;
add_header Cross-Origin-Resource-Policy "same-origin" always;
add_header Cross-Origin-Opener-Policy "same-origin" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
add_header X-Content-Type-Options "nosniff" always;

# 민감 페이지
location /account/ {
  add_header Cache-Control "no-store" always;
}

# 아바타/프로필 리소스
location /avatar {
  add_header Cache-Control "no-store" always;
  add_header Cross-Origin-Resource-Policy "same-origin" always;
  try_files $uri =404; # 존재 유무로 404/200 차이 나지 않게 앱에서 통일해야 함
}
```

CDN(CloudFront/Cloudflare/Fastly)에서도 **원본 헤더를 그대로 보존**하고,  
오리진별 응답이 다르면 **`Vary: Cookie`/`Vary: Origin`** 등 적절한 키 분리를 적용하세요.

---

## 9) 안티패턴 요약

- 로그인 여부에 따라 **status/리다이렉션 단계/컨텐츠 길이/이미지 크기**가 달라지는 설계  
- `/exists?id=...` 로 **존재/부재**를 200/404 등으로 노골히 구분  
- 민감 페이지에 **프레임 허용**  
- 세션 쿠키를 **`SameSite=None`**로 폭넓게 사용  
- 민감 리소스에 **CORP 미적용**(교차 포함 허용)  
- **Fetch Metadata 미활용**(교차 사이트 서브리소스 접근을 그대로 수락)

---

## 10) 체크리스트

- [ ] 세션 쿠키 **SameSite=Lax/Strict; Secure; HttpOnly**  
- [ ] **X-Frame-Options / CSP frame-ancestors** 적용  
- [ ] **CORP same-origin**(민감 리소스), **COOP same-origin**(창/탭 격리)  
- [ ] **Fetch Metadata** 기반 교차 사이트 서브리소스 차단  
- [ ] 민감 리소스/페이지 **응답 균질화**: 상태 무관 **동일 코드/길이/타입/리다이렉션 단계**  
- [ ] **Cache-Control: no-store** (상태 노출 가능 페이지)  
- [ ] **Referrer-Policy** 최소화  
- [ ] 로깅: `secFetch*`, 프레임 차단, CORP/COOP 헤더, 응답 길이  
- [ ] E2E: 교차 오리진에서 이미지/iframe 접근 **항상 차단 또는 동일 이벤트/크기** 확인  
- [ ] 문서화: “상태 의존 경로” 목록과 **균질화/차단 규칙** 유지

---

### 맺음말

XS-Leaks는 **본문 접근을 막아도 새는 정보**를 다룹니다.  
**SameSite 쿠키**, **프레임 금지**, **CORP/COOP**, **Fetch Metadata**, **응답 균질화**를 조합하면  
대부분의 실전 XS-Leaks를 **구조적으로 완화**할 수 있습니다.  