---
layout: post
title: 데이터 통신 4장 - Digital Transmission (3)
date: 2024-07-19 19:20:23 +0900
category: DataCommunication
---
## 4.1.3 Block Coding

- 블록코딩은 보통 mB/nB 코딩(각 m비트 그룹과 n비트 그룹이 교체된다.)을 선호한다. 
- 블록코딩은 Clocking을 위해 m비트를 n비트로 변환시키게 된다. (m<n)
- 블록코딩은 division(분해), substitution(치환), combination(결합)
- 0000과 같이 Clocking이 힘든 코드들을 00100과 같이 인코딩한다 (테이블이 있다)
- 4bit가 5bit로 변해서 쓸모없는 데이터가 들어가기 때문에 전송 효율은 떨어진다
- 필요한 Bandwidth가 증가하고, 전체 신호를 보면 평균 0이 보장되지 않아서 DC가 발생할 수 있다.
- 4B/5B 기준으로 보면 16개의 신호만 필요한데 만들어지는 신호의 종류는 25개가 만들어진다.
- 이 때, Clocking에 유용한 비트패턴들은 데이터로 사용하고, 00000, 11111, 00001과 같이 Clocking이 어려운 비트패턴은 오류검출과 같은 특수 목적으로 사용하게 된다.

### 4B/5B (four binary/five binary)

- NRZ-I의 결합을 위해 디자인되었다. 알다시피 NRZ-I는 biphase의 신호 전송률이 1/2로 좋다. 그러나 동기화 문제가 있다. 그래서 비트스트림에서 0이 길게 나오는 것을 막으려고 사용된다.

- `0` 또는 `1`이 길게 연속되어 전송되지 않도록, 사전에 블록 코드(4B -> 5B)화한다.
- 4 비트 -> 5 비트로 블록코드화에서 강조된 사항:
  - 5 비트 블록코드 내부에 반드시 1 이상의 전이가 있도록 함
  - 3 이상 `0`이 연속되지 않도록 함
  - 전체적으로 `0`과 `1` 사이에 균형 있게 함
- NRZI는 연속되는 긴 `0`이 있으면, 수신측이 비트동기화를 잃을 위험성이 있어 이를 개선하기 위해 같이 사용된다.
- NRZ-I의 DC 요소 문제를 해결하지는 못한다. 해결하려면 biphase나 bipolar 인코딩이 필요하다.
- FDDI, 100BASE-FX 또는 100BASE-TX: 4B/5B + NRZI에서 사용한다.
- 4 -> 5 비트로 블록코드하면서, 100 Mbps 비트율이 125 Mbaud 보율로 된다.

### 8B/10B (eight binary/ten binary)

- 8비트 -> 10비트로 블록코드화하는 것이다. 5B/6B + 3B/4B의 조합이다.
- 28=256개의 데이터코드 이외, 210-28=788개 중 12개를 특수코드(제어)로 할당한다. 25% 정도가 오버헤드로써 이들을 통해 제어 및 오류검출 등에 활용.
- 비트 동기화에 유리:
  - 비트 반전이 충분히 많게 한다.
  - 연속적으로 같은 비트가 나오는 것을 최소화시켜 비트 동기를 도와줌.
  - `1` 또는 `0` 비트가 연속으로 최대 4번까지만 발생 가능토록 함.
- 1024개 가능 코드 중 비트 반전이 많은 260여개의 코드들만 유효한 코드로 활용.
- DC Balance 코드:
  - `0`과 `1` 발생비율을 평균적으로 같게 함.
  - 코드그룹화된 10 비트 중 다른 비트 갯수가 최소한 1개 차이 만 같게한다. 즉, `0`과 `1` 갯수가 같거나(각 5개씩), 최소한 1개 차이(4개 및 6개).
- 코드 그룹 간 경계 구분 용이하게 하는데 특수코드그룹을 사용한다.
- 1 이상의 비트 오류 검출 가능해서 여분의 특수 코드를 많이 사용할 수 있음.

## 4.1.4 Scrambling

- Biphase는 LAN에 적합하며 넓은 대역폭이 필요하기 때문이다. NRZ와 블록 코딩의 결합은 DC 요소 때문에 장거리 전송에 적합하지 않다. Bipolar AMI 인코딩은 반면에 근처 대역폭과 DC요소를 만들지 않는다. Bipolar AMI 인코딩을 장거리 전송에 쓰면 일련의 0으로 된 문장 신호의 동기화가 문제가 된다. 이를 해결하는 방법이 있다.
- Scrambling은 추가비트 없이 기존 데이터를 섞어서(Scramble) 자동으로 Clocking하는 방식으로 현재 장거리 통신의 표준인 B8SZ(미국)와 HDB3(유럽)이 있다.(즉, 현재 현역으로 쓰이는 방식이다)
- Bi-Polar는 1이 나올 때 신호가 계속 위아래로 변하므로 0이 지속될 때만 처리해주면 된다.
- 스크램블 된 데이터를 다시 원래대로 돌려야 제대로 신호를 복구할 수 있기 때문에 디스크램블링 (Descrambling) 알고리즘도 존재한다.

### B8ZS (Bipolar with 8-zero substitution)

- B8SZ는 미국의 표준화 방법으로, 8개의 0을 만나면 의도적으로 Violation을 2번 일으키면서 신호를 섞는다. 그래서 수신측에서는 의도적인 2번의 Violation이 관측되면 그 것을 0이 Scramble되었음을 파악할 수 있다.
- 만약 가장 최근에 찍힌 0이 아닌 신호가 +였다면 (+ - 0 - +)로 의도적으로 2번의 Violation을 일으키고, 가장 최근에 찍힌 0이 아닌 신호가 -였다면 (- + 0 + -)로 의도적으로 2번의 Violation을 일으켜서 섞는다. 이렇게 해서 가장 긴 0의 시퀀스가 최대 7개까지만 허용된다. 8개부터는 Scramble해버린다.
- `V` : violation  
- `B` : bipolar

### HDB3 (High-density bipolar 3-zero)

- HDB는 4개의 0이 지속되면 의도적으로 Violation을 일으키는데 신호에 따라서 000V혹은 B00V로 변환한다. 이렇게 하는 이유는 0이 아닌 준위 (+ 혹은 -)의 개수를 일정하게 짝수개로 유지하여 DC성분을 잡기 위함이다.
- 직전 Scrambling (Substitution) 이후에 0이 아닌 펄스의 개수가 짝수이면 H00V로 대체한다.
  - 위 그림처럼 첫 Substitution 전에 1의 개수가 2개이다. 이 때, 0이 4번 지속되면 신호를 B00V로 바꿔서 0이 아닌 성분이 짝수개가 되었다. (11B00V로 11BV : 4개)
- 직전 Scrambling (Substitution) 이후에 0이 아닌 펄스의 개수가 홀수이면 000V로 대체한다.
  - 위 그림처럼 두번째 Substitution이 일어나기 전 0이 아닌 펄스의 개수가 5개이다. 이 때, 0이 4번 지속되면 신호를 000V로 맞춰서 0이 아닌 성분이 짝수개가 되었다 (11B00V10000이 11B00V1000V로 11BV1V : 6개)
- HDB3는 조금 더 복잡하지만, 4개의 연속된 0비트가 나올 때 바로 섞어버리기 때문에 Clocking에 더욱 강력하다. 위 그림을 보면 앞선 8개의 0신호 시퀀스에선 둘다 스크램블링 했지만, 뒤쪽 5개의 연속된 0시퀀스에서는 B8SZ는 그대로 놔뒀지만, HDB3는 스크램블해주었다. 따라서 HDB3는 최대로 허용되는 연속 0신호가 3개이다.