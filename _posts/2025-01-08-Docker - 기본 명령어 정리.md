---
layout: post
title: Docker - 기본 명령어 정리
date: 2025-01-08 19:20:23 +0900
category: Docker
---
# Docker 기본 명령어 정리

Docker를 효과적으로 사용하기 위해 알아야 할 핵심 명령어와 실무 패턴을 정리했습니다. 초보자부터 실무 개발자까지 참고할 수 있도록 기본 흐름부터 고급 팁까지 단계별로 설명합니다.

## Docker 핵심 작업 흐름

Docker의 기본 사용 흐름을 단계별로 시각화하면 다음과 같습니다:

```
이미지 다운로드(pull)
  └─> 컨테이너 실행(run)
        ├─> 상태/로그/내부접속(ps/logs/exec/inspect/stats)
        └─> 정지(stop) ─> 삭제(rm)
             └─> 이미지 정리(rmi/prune) [옵션]
```

이제 각 단계별로 필요한 명령어를 상세히 알아보겠습니다.

---

## 1. 이미지 다운로드: `docker pull`

Docker 이미지는 애플리케이션과 그 실행 환경을 포함한 패키지입니다. 레지스트리에서 로컬로 가져올 때 사용합니다.

### 기본 사용법
```bash
docker pull [레지스트리/]이미지[:태그]
```

### 실무 예제
```bash
# 공식 Ubuntu 20.04 이미지 다운로드
docker pull ubuntu:20.04

# 최신 Nginx 이미지 다운로드 (태그 생략 시 'latest' 자동 적용)
docker pull nginx

# GitHub Container Registry에서 비공개 이미지 다운로드
docker pull ghcr.io/내조직/내앱:1.2.3
```

### 이미지 관리 명령어
```bash
# 다운로드된 이미지 목록 확인
docker images

# 특정 이미지의 상세 정보 조회
docker image inspect nginx:latest | jq '.[0].RepoDigests'

# 이미지 레이어 구조 확인
docker history nginx:latest
```

**실무 팁**: 운영 환경에서는 특정 버전의 태그 대신 다이제스트(해시값)를 사용하는 것이 좋습니다. 태그는 재할당될 수 있지만, 다이제스트는 이미지 내용에 기반한 고유 식별자이므로 항상 동일한 이미지를 보장합니다.

---

## 2. 컨테이너 실행: `docker run`

이미지를 기반으로 격리된 실행 환경인 컨테이너를 생성하고 시작합니다. Docker에서 가장 다양하게 사용되는 핵심 명령어입니다.

### 기본 형식
```bash
docker run [옵션] 이미지[:태그|@다이제스트] [명령어]
```

### 필수 옵션 분류

#### 실행 모드 설정
- **`-it`**: 대화형 모드로 실행 (터미널 입력/출력 가능)
  ```bash
  docker run -it ubuntu bash  # Ubuntu 컨테이너의 bash 셸에 접속
  ```
- **`-d`**: 백그라운드 데몬 모드로 실행
  ```bash
  docker run -d --name webserver nginx  # 백그라운드에서 Nginx 서버 실행
  ```
- **`--rm`**: 컨테이너 종료 시 자동 삭제
  ```bash
  docker run --rm alpine echo "Hello, Docker!"  # 일회성 작업 후 자동 정리
  ```

#### 네트워킹 설정
- **`-p 호스트포트:컨테이너포트`**: 포트 포워딩 설정
  ```bash
  docker run -d -p 8080:80 nginx  # 호스트의 8080포트를 컨테이너 80포트에 연결
  ```
- **`--network 네트워크이름`**: 사용자 정의 네트워크 사용
  ```bash
  docker run -d --network app-network --name api myapi:latest
  ```

#### 저장소 설정
- **`-v 호스트경로:컨테이너경로[:옵션]`**: 볼륨 마운트
  ```bash
  # 호스트 디렉터리를 컨테이너에 읽기 전용으로 마운트
  docker run -v /home/user/data:/app/data:ro myapp
  ```

#### 리소스 관리
- **`--memory`**: 메모리 사용량 제한
  ```bash
  docker run --memory="512m" myapp  # 최대 512MB 메모리 사용 제한
  ```
- **`--cpus`**: CPU 사용량 제한
  ```bash
  docker run --cpus="1.5" myapp  # 최대 1.5개 코어 사용 제한
  ```

#### 보안 설정
- **`--user UID:GID`**: 특정 사용자 권한으로 실행
  ```bash
  docker run --user 1000:1000 myapp  # 일반 사용자 권한으로 실행
  ```
- **`--read-only`**: 루트 파일시스템을 읽기 전용으로 설정
  ```bash
  docker run --read-only --tmpfs /tmp alpine  # /tmp 디렉터리만 쓰기 가능
  ```

### 다이제스트를 사용한 정확한 버전 실행

{% raw %}
```bash
# 이미지의 다이제스트 확인
docker inspect --format='{{index .RepoDigests 0}}' nginx:alpine
# 출력 예시: nginx@sha256:abcdef123456...

# 다이제스트로 컨테이너 실행 (항상 동일한 이미지 보장)
docker run --rm nginx@sha256:abcdef123456...
```
{% endraw %}

---

## 3. 컨테이너 상태 확인 및 모니터링

### 실행 중인 컨테이너 목록
```bash
docker ps          # 실행 중인 컨테이너만 표시
docker ps -a       # 모든 컨테이너 표시 (중지된 것 포함)
docker ps -q       # 컨테이너 ID만 표시
```

### 컨테이너 로그 확인
```bash
docker logs [컨테이너명]               # 기본 로그 출력
docker logs -f [컨테이너명]            # 실시간 로그 스트림 모니터링
docker logs --tail=50 [컨테이너명]     # 최근 50줄만 확인
docker logs --since=10m [컨테이너명]   # 최근 10분간의 로그 확인
```

### 실행 중인 컨테이너에 접속
```bash
docker exec -it [컨테이너명] sh    # Alpine/BusyBox 기반 컨테이너
docker exec -it [컨테이너명] bash  # Ubuntu/Debian 기반 컨테이너
```

**참고**: `docker attach`는 컨테이너의 주 프로세스에 직접 연결하므로, 대부분의 경우 `docker exec`를 사용하는 것이 더 안전하고 유연합니다.

### 리소스 사용량 모니터링
```bash
docker stats                    # 모든 컨테이너의 실시간 리소스 사용량
docker stats [컨테이너명]       # 특정 컨테이너만 모니터링
docker top [컨테이너명]         # 컨테이너 내부에서 실행 중인 프로세스 목록
```

### 컨테이너 상세 정보 조회
```bash
# 모든 정보를 JSON 형식으로 출력
docker inspect [컨테이너명]

# 특정 정보만 추출 (jq 필요)
docker inspect [컨테이너명] | jq '.[0].NetworkSettings.IPAddress'
```

---

## 4. 컨테이너 정지 및 정리

### 컨테이너 생명주기 관리
```bash
docker stop [컨테이너명]      # 정상 종료 요청 (SIGTERM 전송)
docker kill [컨테이너명]      # 강제 종료 (SIGKILL 전송)
docker start [컨테이너명]     # 중지된 컨테이너 시작
docker restart [컨테이너명]   # 컨테이너 재시작
```

### 컨테이너 삭제
```bash
docker rm [컨테이너명]           # 중지된 컨테이너 삭제
docker rm -f [컨테이너명]        # 실행 중인 컨테이너 강제 삭제
docker rm $(docker ps -aq)       # 모든 컨테이너 삭제 (주의 필요)
```

### 이미지 삭제
```bash
docker rmi [이미지명:태그]        # 특정 이미지 삭제
docker rmi $(docker images -q)    # 모든 이미지 삭제 (주의 필요)
```

### 시스템 정리
```bash
docker system df                  # Docker 디스크 사용량 통계
docker system prune               # 사용하지 않는 모든 Docker 객체 정리
docker system prune -a            # 사용하지 않는 이미지까지 모두 정리
```

---

## 5. 실전 통합 예제

### 기본 웹 서버 배포 및 관리
```bash
# 1. 이미지 다운로드
docker pull nginx:alpine

# 2. 컨테이너 실행 (포트 매핑, 이름 지정)
docker run -d --name my-website -p 8080:80 nginx:alpine

# 3. 서비스 확인
docker ps
curl http://localhost:8080

# 4. 로그 확인 및 컨테이너 내부 점검
docker logs my-website
docker exec -it my-website sh -c "nginx -v && ls -la /usr/share/nginx/html"

# 5. 리소스 사용량 확인
docker stats my-website

# 6. 정리
docker stop my-website
docker rm my-website
docker rmi nginx:alpine
```

### 파일 복사 및 백업
```bash
# 호스트 파일을 컨테이너로 복사
docker cp ./index.html my-website:/usr/share/nginx/html/

# 컨테이너 파일을 호스트로 백업
docker cp my-website:/etc/nginx/nginx.conf ./nginx-backup.conf
```

### 네트워크 및 볼륨 관리
```bash
# 사용자 정의 네트워크 생성
docker network create app-network

# 볼륨 생성 (데이터 영속성 보장)
docker volume create app-data

# 네트워크와 볼륨을 사용하여 데이터베이스 실행
docker run -d \
  --name database \
  --network app-network \
  -v app-data:/var/lib/postgresql/data \
  postgres:latest
```

---

## 6. 자주 발생하는 문제와 해결 방법

### 권한 오류 (리눅스)
**증상**: `permission denied while trying to connect to the Docker daemon socket`
**해결**: 사용자를 docker 그룹에 추가
```bash
sudo usermod -aG docker $USER
# 변경사항 적용을 위해 로그아웃 후 다시 로그인
```

### 포트 충돌
**증상**: `port is already allocated`
**해결**: 다른 포트 사용 또는 기존 프로세스 확인
```bash
# Linux/macOS에서 포트 점유 프로세스 확인
lsof -i :8080

# Windows에서 포트 점유 프로세스 확인
netstat -ano | findstr :8080
```

### 이미지 다운로드 실패 (프록시 환경)
**해결**: Docker 데몬 프록시 설정
```bash
# 프록시 설정 파일 생성
sudo mkdir -p /etc/systemd/system/docker.service.d
sudo tee /etc/systemd/system/docker.service.d/proxy.conf << EOF
[Service]
Environment="HTTP_PROXY=http://proxy.example.com:3128"
Environment="HTTPS_PROXY=http://proxy.example.com:3128"
Environment="NO_PROXY=localhost,127.0.0.1,.internal"
EOF

# 변경사항 적용
sudo systemctl daemon-reload
sudo systemctl restart docker
```

---

## 7. 실무 모범 사례

### 보안 강화를 위한 컨테이너 실행
```bash
docker run --rm \
  --read-only \                      # 루트 파일시스템 읽기 전용
  --tmpfs /tmp --tmpfs /run \        # 필요한 임시 디렉터리만 쓰기 가능
  --cap-drop ALL \                   # 모든 특권 제거
  --security-opt no-new-privileges \ # 새 권한 획득 방지
  --user 65532:65532 \               # 비root 사용자로 실행
  --pids-limit 128 \                 # 최대 프로세스 수 제한
  --cpus 0.5 \                       # CPU 사용량 제한
  --memory 256m \                    # 메모리 사용량 제한
  nginx:alpine
```

### 일회성 작업 자동화
```bash
# 데이터베이스 백업 예제
docker run --rm \
  -v /backup:/backup \
  -v app-data:/data \
  alpine tar czf /backup/db-backup-$(date +%Y%m%d).tar.gz -C /data .
```

### 개발 환경 구성 (Docker Compose)
```yaml
# docker-compose.yml
version: '3.8'
services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
    volumes:
      - ./html:/usr/share/nginx/html
  
  api:
    build: ./api
    ports:
      - "3000:3000"
    environment:
      - DB_HOST=database
  
  database:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: example-password
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```

```bash
# 서비스 시작
docker compose up -d

# 서비스 중지 및 정리
docker compose down
```

---

## 8. 실습 과제

### 과제 1: 정적 웹사이트 호스팅
```bash
# 1. 웹사이트 디렉터리 생성
mkdir -p my-website
echo "<h1>Hello Docker!</h1>" > my-website/index.html

# 2. Nginx 컨테이너 실행
docker run -d --name web \
  -p 8080:80 \
  -v $(pwd)/my-website:/usr/share/nginx/html:ro \
  nginx:alpine

# 3. 접속 테스트
curl http://localhost:8080

# 4. 정리
docker stop web && docker rm web
```

### 과제 2: 일회성 데이터 처리
```bash
# CSV 파일의 라인 수 계산
echo "id,name,age
1,Alice,30
2,Bob,25
3,Charlie,35" > data.csv

docker run --rm -v $(pwd):/data alpine \
  sh -c "wc -l /data/data.csv && echo '총 레코드 수: $(($(wc -l < /data/data.csv)-1))'"
```

---

## 결론

Docker 명령어를 효과적으로 사용하는 핵심은 **기본 흐름을 이해하고, 점진적으로 옵션을 추가해 나가는 것**입니다. 처음에는 `pull → run → ps → stop → rm`의 기본 사이클을 반복 연습하고, 익숙해지면 네트워크, 볼륨, 리소스 제한 등의 고급 기능을 하나씩 적용해보세요.

실무에서는 다음과 같은 원칙을 지키는 것이 좋습니다:

1. **재현성 보장**: 운영 환경에서는 항상 특정 버전 태그나 다이제스트를 사용
2. **최소 권한 원칙**: 필요한 권한만 부여하고, 가능한 경우 비root 사용자로 실행
3. **리소스 관리**: 적절한 CPU/메모리 제한을 설정하여 호스트 시스템 보호
4. **데이터 분리**: 애플리케이션 데이터는 볼륨을 사용하여 컨테이너와 분리
5. **자동화**: 반복적인 작업은 스크립트나 Docker Compose로 자동화

문제가 발생했을 때는 `docker logs`로 로그를 확인하고, `docker inspect`로 설정을 점검하며, `docker stats`로 리소스 사용량을 모니터링하는 습관을 기르세요. 이러한 디버깅 프로세스를 체득하면 Docker를 더욱 자신 있게 다룰 수 있을 것입니다.