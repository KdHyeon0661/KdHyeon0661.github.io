---
layout: post
title: Docker - 기본 명령어 정리
date: 2025-01-08 19:20:23 +0900
category: Docker
---
# Docker 기본 명령어 정리 — 흐름·옵션·실전 시나리오·트러블슈팅까지 확장

본 글은 기존 정리( **이미지 다운로드 → 컨테이너 실행 → 상태 확인 → 정지 → 삭제** )를 유지하면서,
각 명령의 **의미/옵션/동작 차이**, **현장에서 자주 쓰는 패턴**, **보안·성능 팁**, **트러블슈팅**까지 예제 중심으로 확장했습니다.
모든 코드는 ``` 코드펜스로, 수식이 필요한 경우에만 $$...$$ 로 표기합니다.

---

## 0. 큰 흐름 한눈에

```
이미지 다운로드(pull)
  └─> 컨테이너 실행(run)
        ├─> 상태/로그/내부접속(ps/logs/exec/inspect/stats)
        └─> 정지(stop) ─> 삭제(rm)
             └─> 이미지 정리(rmi/prune) [옵션]
```

---

# 1. 이미지 다운로드: `docker pull`

```bash
docker pull [레지스트리/]이미지[:태그]
```

### 예시
```bash
docker pull ubuntu:20.04
docker pull nginx                   # :latest 생략
docker pull ghcr.io/acme/app:1.2.3  # GHCR(사설/공용 레지스트리 예)
```

### 확인/점검
```bash
docker images
docker image inspect nginx:latest | jq '.[0].RepoDigests'
docker history nginx:latest
```

- **tag**(가변) vs **digest**(불변) 구분: 운영/CI에서 재현성 필요 시 digest 고정이 유리.

---

# 2. 컨테이너 실행: `docker run`

```bash
docker run [옵션] 이미지[:태그|@digest] [명령/인자...]
```

## 2.1 자주 쓰는 옵션 표

| 옵션 | 의미 | 비고/팁 |
|---|---|---|
| `-it` | 대화형(표준입력 + TTY) | 셸 접속/디버깅 |
| `--rm` | 종료 시 컨테이너 자동 삭제 | 일회성 작업에 적합 |
| `-d` | 백그라운드(detached) 실행 | 서버형 프로세스 |
| `--name` | 컨테이너 이름 지정 | 추후 exec/logs/stop 편리 |
| `-p H:C` | 포트 매핑(host:container) | `-p 8080:80` |
| `-v SRC:DST[:옵션]` | 볼륨/바인드 마운트 | `:ro`, SELinux `:Z` |
| `--env K=V` / `-e` | 환경변수 주입 | .env/Compose로 대체 가능 |
| `--cpus N` | CPU 제한 | cgroups v2 |
| `--memory SIZE` | 메모리 제한 | OOM 유의 |
| `--restart=always` | 재시작 정책 | 데몬성 서비스 |
| `--network NET` | 네트워크 지정 | 사용자 브릿지/overlay |
| `--user UID:GID` | 실행 사용자 | 권한 최소화 |
| `--read-only` | 루트 FS 읽기 전용 | `--tmpfs`와 함께 사용 |

## 2.2 기본 예제
```bash
docker run -it ubuntu bash             # Ubuntu 컨테이너 셸
docker run --rm alpine echo hello      # 일회성 실행 후 자동 삭제
docker run -d -p 8080:80 nginx         # Nginx 백그라운드 실행
```

## 2.3 digest 고정(재현성 강화)
{% raw %}
```bash
docker pull nginx:alpine
docker inspect --format='{{index .RepoDigests 0}}' nginx:alpine
# 예: nginx@sha256:abc...
docker run --rm -p 8080:80 nginx@sha256:abc...
```
{% endraw %}

---

# 3. 상태/로그/내부 접속: `ps` / `logs` / `exec` (+ 보조)

## 3.1 컨테이너 목록: `docker ps`
```bash
docker ps        # 실행 중
docker ps -a     # 종료 포함 전체
```

## 3.2 로그: `docker logs`
```bash
docker logs web
docker logs -f --tail=100 web    # 실시간 + 최근 100줄
docker logs --since=10m web      # 최근 10분
```

## 3.3 내부 접속: `docker exec`
```bash
docker exec -it web bash      # Debian/Ubuntu 계열
docker exec -it web sh        # Alpine/BusyBox
```

> 주의: `docker attach` 는 PID 1의 표준입출력에 붙습니다(대개 권장 X). 셸 접속은 `exec`.

## 3.4 상세/리소스/프로세스: `inspect` / `stats` / `top`
```bash
docker inspect web | jq '.[0].State, .[0].NetworkSettings.Ports'
docker stats
docker top web
```

---

# 4. 정지/삭제/정리: `stop` / `rm` / `rmi` / `prune`

## 4.1 정지/시작/재시작
```bash
docker stop web
docker start web
docker restart web
```

## 4.2 삭제
```bash
docker rm web             # 정지된 컨테이너 삭제
docker rm -f web          # 강제(실행 중인 컨테이너 kill 후 삭제)
docker rmi nginx:latest   # 이미지 삭제(참조 컨테이너 없을 때)
```

## 4.3 청소(주의)
```bash
docker system df
docker system prune -f             # 미사용 자원 일괄 정리
docker image prune -a -f           # 미사용 이미지 전부 삭제(주의)
docker volume prune -f             # 미사용 볼륨 삭제(데이터 유실 주의)
```

---

# 5. 실전 흐름 예시(기본판 → 확장판)

## 5.1 기본판(원문 흐름)
```bash
docker pull nginx
docker run -d --name web_server -p 8080:80 nginx
docker ps
docker stop web_server
docker rm web_server
docker rmi nginx
```

## 5.2 확장판(포트/볼륨/네트워크/접속/로그)
```bash
# 네트워크/정적 파일 준비
docker network create appnet
mkdir -p site && echo "ok" > site/index.html

# Nginx 실행(정적 파일 바인드 마운트)
docker run -d --name web \
  --network appnet \
  -p 8080:80 \
  -v $(pwd)/site:/usr/share/nginx/html:ro \
  nginx:alpine

# 상태/로그/내부 탐색
docker ps
curl http://localhost:8080
docker logs -f web
docker exec -it web sh -lc 'nginx -v; ls -al /usr/share/nginx/html'

# 정리
docker stop web
docker rm web
docker network rm appnet
```

---

# 6. 보너스 명령(현장에서 유용)

## 6.1 파일 복사: `docker cp`
```bash
# 호스트 → 컨테이너
docker cp ./index.html web:/usr/share/nginx/html/

# 컨테이너 → 호스트
docker cp web:/etc/nginx/nginx.conf ./nginx.conf
```

## 6.2 포트·이름·업데이트: `port` / `rename` / `update`
```bash
docker port web              # 포트 매핑 조회
docker rename web web-prod   # 이름 변경
docker update --cpus=1 --memory=512m web-prod  # 자원 제한 조정
```

## 6.3 분리형 생성/시작: `create` + `start`
```bash
docker create --name web -p 8080:80 nginx
docker start web
```
> `run = create + start (+ attach)` 의 축약형입니다.

## 6.4 저장/로드·내보내기/가져오기
```bash
docker save -o nginx.tar nginx:alpine
docker load -i nginx.tar

docker export web -o web_rootfs.tar
cat web_rootfs.tar | docker import - web-rootfs:latest
```

---

# 7. 네트워크/볼륨 기초(명령만 빠르게)

## 7.1 네트워크
```bash
docker network ls
docker network create appnet
docker network inspect appnet | jq '.[0].Containers'
docker network rm appnet
```
- 동일 네트워크의 컨테이너끼리는 **컨테이너명으로 DNS** 접근 가능.

## 7.2 볼륨
```bash
docker volume ls
docker volume create data1
docker run -d --name db -v data1:/var/lib/postgresql/data postgres:16-alpine
docker volume inspect data1 | jq '.[0].Mountpoint'
docker rm -f db && docker volume rm data1
```
- **상태 데이터**는 볼륨으로 분리(컨테이너 교체/업그레이드에 유리).

---

# 8. 보안·운영 팁(짧고 강력)

```bash
docker run --rm \
  --read-only \
  --tmpfs /tmp --tmpfs /run \
  --cap-drop ALL --security-opt no-new-privileges \
  --user 65532:65532 \
  --pids-limit 128 --cpus 0.5 --memory 256m \
  nginx:alpine
```

- **읽기 전용 루트FS**, **tmpfs로 최소 쓰기 경로 제공**
- **capabilities 제거**, **비root 사용자**, **프로세스 수/CPU/메모리 제한**
- 실서비스에 권장되는 “기본 방어선”

---

# 9. 자주 겪는 오류와 해결(현장형)

| 증상/에러 | 원인 | 해결 |
|---|---|---|
| `permission denied while trying to connect to the Docker daemon socket` | 도커 소켓 권한(리눅스) | `sudo usermod -aG docker $USER` 후 재로그인 |
| `port is already allocated` | 포트 충돌 | `lsof -i :8080` 또는 `netstat -ano | findstr :8080` 로 점유 확인 후 해제/포트 변경 |
| `Get https://registry-1.docker.io/v2/: ...` | 프록시/사설 CA | 데몬 프록시/CA 설정(아래 예시), 컨테이너 내부 `-e HTTP(S)_PROXY` |
| 파일 변경 반영 느림(Windows/WSL2) | 호스트↔WSL 경계 I/O 병목 | 프로젝트를 **WSL2 내부 경로**에서 빌드/마운트 |
| SELinux 마운트 실패(RHEL/Fedora 계열) | 컨텍스트 라벨 문제 | `-v /path:/path:Z` 또는 정책 라벨 조정 |
| 컨테이너 즉시 종료 | 일회성 커맨드/ENTRYPOINT 차이 | `logs` 확인, 장기 실행용 이미지를 사용(Nginx 등) |

프록시/사설 CA(리눅스 데몬 예):
```bash
sudo mkdir -p /etc/systemd/system/docker.service.d
cat <<'EOF' | sudo tee /etc/systemd/system/docker.service.d/proxy.conf
[Service]
Environment="HTTP_PROXY=http://proxy.local:3128"
Environment="HTTPS_PROXY=http://proxy.local:3128"
Environment="NO_PROXY=localhost,127.0.0.1,.svc,.internal"
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

---

# 10. 미니 실습 3선(손에 익히기)

## 10.1 일회성 잡 + 자동 삭제 + 결과 확인
```bash
docker run --rm alpine sh -c 'date && echo done'
```

## 10.2 정적 사이트 제공(Nginx + 바인드 마운트)
```bash
mkdir -p site && echo "hello" > site/index.html
docker run -d --name web -p 8080:80 -v $(pwd)/site:/usr/share/nginx/html:ro nginx:alpine
curl http://localhost:8080
docker rm -f web
```

## 10.3 네임스페이스 감각(내부 셸에서 확인)
```bash
docker run --rm -it alpine sh
# 컨테이너 내부
hostname
ip addr
ps -ef
exit
```

---

# 11. 요약 명령어 표(보강)

| 목적 | 기본 명령 | 보강/심화 |
|---|---|---|
| 이미지 다운로드 | `docker pull 이미지[:태그]` | `docker image inspect`, `docker history` |
| 컨테이너 실행 | `docker run [옵션] 이미지` | `--rm`, `-d`, `-p`, `-v`, `--env`, `--user`, `--read-only` |
| 컨테이너 목록 | `docker ps [-a]` | `docker stats`, `docker top` |
| 로그 확인 | `docker logs [--since --tail -f] 이름` | `docker events` |
| 내부 접속 | `docker exec -it 이름 sh|bash` | `docker cp`, `docker port` |
| 정지/삭제 | `docker stop 이름` / `docker rm [-f] 이름` | `docker rmi 이미지`, `docker system prune` |
| 네트워크/볼륨 | `docker network/volume ...` | `inspect` 로 상세 점검 |
| 재현성 | — | digest 고정: `image@sha256:...` |

---

## 부록) 짧은 수학 메모(선택): 캐시 적중 직관
레이어별 캐시 적중률을 \(p_i\), 각 레이어 빌드 비용을 \(c_i\) 라 하면 기대 빌드 시간 근사는
$$
\mathbb{E}[T] \approx \sum_{i=1}^{n} (1 - p_i)\,c_i
$$
입니다. 변경이 적은 단계(의존성 설치)를 앞쪽에 배치해 \(p_i\) 를 키우면 전체 빌드 시간이 줄어듭니다.

---

## 마무리
- **핵심 흐름**(pull → run → ps/logs/exec → stop → rm)을 먼저 손에 익히고,
- 포트/볼륨/네트워크/자원·권한 옵션을 점차 추가하며 실습 범위를 넓히세요.
- 문제 발생 시 `logs/inspect/stats/events`로 “관찰 → 가설 → 확인” 루프를 빠르게 돌리는 습관이 실전에서 가장 중요합니다.
