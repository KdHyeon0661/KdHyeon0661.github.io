---
layout: post
title: DB 심화 - 인덱스 스캔 방식
date: 2025-11-07 15:25:23 +0900
category: DB 심화
---
# Oracle 인덱스 스캔 방식

## 0. 실습 환경 및 기본 세션 설정

실습은 Oracle 19c/23c급을 가정한다(미국/유럽권에서 현재 가장 널리 사용하는 LTS/장기지원 버전 기준).  
버전에 따라 옵티마이저 힌트/통계 디폴트는 조금씩 다르지만, **인덱스 스캔 방식 자체는 10g 이후 큰 틀은 동일**하다.

```sql
ALTER SESSION SET nls_date_format  = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;
```

- `statistics_level = ALL`  
  → `DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +IOSTATS +MEMSTATS')`로  
  **실제 수행 통계(실행 후)**를 볼 수 있다.

---

## 1. 실습 스키마 준비

기본 스키마는 기존 글에서 사용한 `scan_demo`를 그대로 활용한다.  
**고객 20만 건**, 등급, 가입일, 금액, 메모를 가진다.

```sql
-- 깨끗이
DROP TABLE scan_demo PURGE;

-- 샘플 테이블: 고객, 등급, 가입일, 금액, 메모
CREATE TABLE scan_demo (
  cust_id     NUMBER        NOT NULL,
  grade       VARCHAR2(10)  NOT NULL,
  created_at  DATE          NOT NULL,
  total_amt   NUMBER(12,2)  NOT NULL,
  note        VARCHAR2(100),
  CONSTRAINT pk_scan_demo PRIMARY KEY (cust_id)
);

-- 데이터 20만 건
BEGIN
  FOR i IN 1..200000 LOOP
    INSERT INTO scan_demo
    VALUES (
      i,
      CASE MOD(i,6)
        WHEN 0 THEN 'VIP'
        WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER'
        WHEN 3 THEN 'BRONZE'
        WHEN 4 THEN 'BASIC'
        ELSE 'NEW'
      END,
      DATE '2024-01-01' + MOD(i, 400),
      ROUND(DBMS_RANDOM.VALUE(0, 100000), 2),
      CASE WHEN MOD(i,97)=0 THEN 'gift' END
    );
  END LOOP;
  COMMIT;
END;
/

-- 인덱스들
CREATE INDEX ix_scan_demo_g_dt_id ON scan_demo(grade, created_at, cust_id);
CREATE INDEX ix_scan_demo_dt_amt  ON scan_demo(created_at, total_amt);
CREATE INDEX ix_scan_demo_note    ON scan_demo(note);    -- LIKE 실험용(텍스트 인덱스 아님)

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER, 'SCAN_DEMO',
    cascade    => TRUE,
    method_opt => 'for all columns size skewonly'
  );
END;
/
```

실습 전에는 항상:

```sql
ALTER SESSION SET statistics_level = ALL;
```

---

## 2. B-Tree 인덱스 기본 구조와 용어

### 2.1 B-Tree 인덱스 구조

Oracle B-Tree 인덱스는 다음과 같이 구성된다.

- **Root Block**  
  상위 분기 노드
- **Branch Blocks**  
  키 범위에 따라 **다음 Branch/Leaf** 로 내려가는 포인터를 가진 중간 노드
- **Leaf Blocks**  
  정렬된 `(키값, ROWID)` 목록을 가진 끝 노드

논리적으로는 다음과 같이 그릴 수 있다.

```text
Root
 ├─ Branch (grade='BASIC' ~ 'GOLD')
 │    ├─ Leaf: ('BASIC', rowid1), ('BASIC', rowid2), ...
 │    └─ Leaf: ('GOLD', rowidX), ...
 └─ Branch (grade>'GOLD')
      ├─ Leaf: ('SILVER', ...)
      └─ Leaf: ('VIP', ...)
```

### 2.2 ROWID와 클러스터링 팩터

- **ROWID**  
  테이블 블록과 그 안의 행 위치를 가리키는 **물리적 주소**  
  $$ \text{ROWID} = (\text{data\_object}, \text{file}, \text{block}, \text{row\_slot}) $$

- **클러스터링 팩터(Clustering Factor, CF)**  
  인덱스의 **키 순서**와 실제 테이블 행의 **물리적 저장 순서**가 얼마나 비슷한지를 나타내는 지표.

  - CF가 **테이블 블록 수에 가깝다**  
    → 인덱스 키 순서대로 읽으면 **각 블록을 한두 번만 방문**, 범위 스캔 효율 ↑
  - CF가 **행 수에 가깝다**  
    → 인덱스 키 순서대로 읽으면 **블록을 거의 매 행마다 새로 읽는 수준**, 랜덤 I/O ↑

  직관적으로:

  $$
  \text{CF} \approx
  \begin{cases}
  \text{#blocks} & \text{(물리 순서와 거의 동일)} \\
  \text{#rows}   & \text{(완전 랜덤)}
  \end{cases}
  $$

  Oracle은 **인덱스 Range/Full Scan 비용**을 추정할 때 CF를 강하게 사용한다.

  ```sql
  SELECT index_name, blevel, leaf_blocks, clustering_factor
  FROM   user_indexes
  WHERE  table_name = 'SCAN_DEMO';
  ```

---

## 3. 인덱스 스캔 방식 전체 지도

Oracle에서 대표적인 B-Tree 인덱스 스캔 방식은 다음과 같다.

| 스캔 방식                  | 실행계획 키워드             | 특징                                                            |
|---------------------------|-----------------------------|-----------------------------------------------------------------|
| **Index Unique Scan**     | `INDEX UNIQUE SCAN`         | 유니크 키 1건 찾기. 가장 빠름.                                 |
| **Index Range Scan**      | `INDEX RANGE SCAN`          | Start/Stop 키가 있는 범위 탐색. 가장 자주 쓰임.                |
| **Index Full Scan**       | `INDEX FULL SCAN`           | 리프 블록을 키 순서대로 끝까지 싱글블록 I/O로 탐색. 정렬 보장. |
| **Index Fast Full Scan**  | `INDEX FAST FULL SCAN`      | 키 순서 무시, 멀티블록 I/O, 병렬 친화. 정렬 보장 X.            |
| **Index Skip Scan**       | `INDEX SKIP SCAN`           | 선행 컬럼 조건 없이 복합 인덱스를 “쪼개서” 탐색.               |

추가적으로:

- **Index Join / Combine**  
  서로 다른 여러 인덱스를 **JOIN**하거나, 비트맵으로 **COMBINE**하여  
  테이블 방문을 최소화하는 전략이 있다. (뒤에서 개념만 간단히 짚는다.)

이제 각 스캔 방식을 예제와 함께 살펴보자.

---

## 4. Index Range Scan (범위 스캔)

### 4.1 개념

- **선행 컬럼**으로 **Start Key**를 찾고,  
  **Stop Key**까지 Leaf 체인을 **왼쪽 → 오른쪽** 방향으로 순차 탐색한다.
- 조건이 **연속 구간**을 만들 때 최적:
  - `=`, `>`, `>=`, `<`, `<=`, `BETWEEN`
  - `LIKE 'prefix%'`
- `ORDER BY`가 인덱스 정렬과 **일치**하면:
  - **정렬 생략**
  - `FETCH FIRST n ROWS ONLY` 같은 Stopkey로 **앞부분만 읽고 종료** 가능

### 4.2 기본 예제 — 고정 + 범위

```sql
-- 등급=VIP, 2024-03 한 달 범위
SELECT /* RANGE */ cust_id, created_at, total_amt
FROM   scan_demo
WHERE  grade = 'VIP'
AND    created_at >= DATE '2024-03-01'
AND    created_at <  DATE '2024-04-01'
ORDER  BY created_at, cust_id;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS')
);
```

**예상 계획(핵심)**

- `INDEX RANGE SCAN IX_SCAN_DEMO_G_DT_ID`
- `TABLE ACCESS BY INDEX ROWID SCAN_DEMO`
- 별도의 `SORT ORDER BY` 없음 → 인덱스 정렬이 ORDER BY를 충족

### 4.3 Top-N / Keyset 페이징 (Stopkey 활용)

#### 4.3.1 단순 Top-N

```sql
-- grade = :g, 최신 50건
SELECT /*+ index(scan_demo ix_scan_demo_g_dt_id) */
       cust_id, created_at, total_amt
FROM   scan_demo
WHERE  grade = :g
ORDER  BY created_at, cust_id
FETCH FIRST 50 ROWS ONLY;   -- Stopkey
```

- 인덱스는 `(grade, created_at, cust_id)` 순서이므로  
  `grade=:g` 이후의 `(created_at, cust_id)` 구간을 **앞에서부터 50건만** 읽으면 된다.
- `ALLSTATS LAST`에서 **Buffers / A-Rows / Starts**가 매우 작게 나온다.

#### 4.3.2 Keyset Pagination

OFFSET 기반 페이징은 비효율적이다.

```sql
-- ❌ OFFSET 기반
SELECT cust_id, created_at
FROM   scan_demo
WHERE  grade='VIP'
ORDER  BY created_at, cust_id
OFFSET 100000 ROWS FETCH NEXT 50 ROWS ONLY;
```

- 앞의 10만 건을 읽고 버려야 하므로, 인덱스/테이블을 **불필요하게 많이 읽는다**.

Keyset 페이징으로 바꾸면:

```sql
-- ✅ Keyset: 마지막 키 기억
SELECT /* KEYSET */ cust_id, created_at, total_amt
FROM   scan_demo
WHERE  grade = :g
  AND (created_at > :last_dt
       OR (created_at = :last_dt AND cust_id > :last_id))
ORDER  BY created_at, cust_id
FETCH FIRST 50 ROWS ONLY;
```

- 항상 **“마지막으로 본 키 이후”**만 인덱스에서 읽기 때문에  
  페이지가 뒤로 갈수록 성능 저하가 거의 없다.

### 4.4 SARGable 리라이트 (날짜 함수 제거)

비용이 큰 대표적인 안티패턴:

```sql
-- ❌ 인덱스 비사용 유발 (컬럼 가공)
SELECT COUNT(*) FROM scan_demo
WHERE TRUNC(created_at) = DATE '2024-03-01';
```

- `TRUNC(created_at)`로 인해 인덱스 컬럼에 함수가 적용 → **비-SARGable**

SARGable하게 바꾸면:

```sql
-- ✅ 범위로 재작성
SELECT COUNT(*) FROM scan_demo
WHERE created_at >= DATE '2024-03-01'
  AND created_at <  DATE '2024-03-02';
```

- 인덱스 `(grade, created_at, cust_id)`의 **created_at 부분**이 그대로 사용 가능 → Range Scan

### 4.5 LIKE 접두사와 범위 스캔

```sql
-- 접두사만 인덱스 범위 스캔 가능
SELECT /* RANGE */ *
FROM   scan_demo
WHERE  note LIKE 'gif%';    -- OK: Start='gif', Stop='gig' 직전
```

- 문자열 인덱스에서 `LIKE 'gif%'`는  
  $$ ['gif...', 'gig...') $$  
  과 같은 **연속 키 범위**를 만들어 인덱스 Range Scan이 가능하다.

반면:

```sql
-- 후방/부분일치: '%gift%' → 범위 스캔 불가
SELECT *
FROM   scan_demo
WHERE  note LIKE '%gift%';  -- 인덱스를 쓰지 못하고 Full Table Scan / Filter
```

- 접두사가 없으므로 **Start/Stop Key를 만들 수 없다**.
- 이 경우에는 **텍스트 인덱스(Oracle Text)** 같은 별도 인덱스를 설계하는 것이 일반적이다.

### 4.6 튜닝 포인트 요약

- 복합 인덱스에서 **선행 컬럼**은 **선택도 높은 컬럼**을 두는 것이 Range Scan에 유리.
- 자주 사용하는 `ORDER BY`와 인덱스 컬럼 순서를 **정렬에 맞게 정렬**한다.
- **커버링 인덱스**(SELECT-LIST가 전부 인덱스에 포함되도록) 설계하면  
  `TABLE ACCESS BY INDEX ROWID`를 제거할 수 있다.
- **클러스터링 팩터**가 좋은 인덱스는 Range Scan 시 **블록 재사용도가 높아** 훨씬 빠르다.

---

## 5. Index Unique Scan (유니크 스캔)

### 5.1 개념

- **유니크 인덱스**의 **모든 키 컬럼이 등호(=)** 조건으로 주어졌을 때 가능한 스캔 방식.
- 딱 **1건(또는 0건)** 의 ROWID를 찾으면 끝난다.
- Oracle의 인덱스 스캔 방식 중 **가장 비용이 낮다**.

$$
\text{Cost}_{UniqueScan} \approx
\text{IndexRootToLeaf} + \text{1 Block Table Access}
$$

### 5.2 PK = Unique Scan 예제

```sql
-- PK 인덱스는 유니크. cust_id=12345 → Unique Scan
SELECT /* UNIQUE */ grade, created_at, total_amt
FROM   scan_demo
WHERE  cust_id = 12345;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);
```

- 계획에서 `INDEX UNIQUE SCAN PK_SCAN_DEMO`를 확인할 수 있다.
- `TABLE ACCESS BY INDEX ROWID`로 실제 행을 1건만 가져온다.

### 5.3 유니크 스캔이 깨지는 대표 패턴

#### 5.3.1 형변환/함수 사용

```sql
-- ❌ 컬럼에 함수/형변환
SELECT * FROM scan_demo
WHERE TO_CHAR(cust_id) = '12345';
```

- **컬럼에 함수**가 걸렸기 때문에, 옵티마이저가 인덱스를 그대로 이용하기 어렵다.
- 실행계획에서 `INDEX RANGE SCAN` 또는 아예 인덱스를 못 쓰고 Full Scan이 나올 수 있다.

올바른 형태:

```sql
-- ✅ 바인드 타입을 NUMBER로
SELECT * FROM scan_demo
WHERE cust_id = :cust_id_num;
```

JDBC 예:

```java
// ❌ 문자열 바인드로 cust_id 비교
ps.setString(1, "12345");

// ✅ 숫자 바인드
ps.setLong(1, 12345L);
```

#### 5.3.2 모든 키 컬럼이 채워지지 않음

복합 유니크 인덱스 예:

```sql
CREATE UNIQUE INDEX ux_demo ON scan_demo(cust_id, grade);
```

조건이 다음과 같으면:

```sql
-- ❌ grade 조건이 없다 → Unique Scan 불가
WHERE cust_id = 12345

-- ✅ 두 컬럼 모두 등호 → Unique Scan 가능
WHERE cust_id = 12345 AND grade = 'VIP'
```

- 유니크 인덱스의 **모든 키 컬럼**에 대해 **등호**가 들어가야 `INDEX UNIQUE SCAN`이 가능하다.

---

## 6. Index Full Scan (인덱스 전체 순차 스캔)

### 6.1 개념: IFS vs IFFS

**중요한 구분**:

- **Index Full Scan (IFS)**  
  - 실행계획: `INDEX FULL SCAN`  
  - 리프 블록을 **키 순서대로** 읽는다.  
  - 주로 **싱글블록 I/O** (1 block씩 읽는 방식)  
  - **정렬 순서 보장** → ORDER BY를 생략할 수 있음.
- **Index Fast Full Scan (IFFS)**  
  - 실행계획: `INDEX FAST FULL SCAN`  
  - 인덱스 세그먼트를 **테이블처럼** 취급, 블록을 **멀티블록 I/O**로 읽는다.  
  - 키 순서는 보장하지 않는다.  
  - 병렬 쿼리와 궁합이 좋다.  
  - 보통 **정렬이 필요 없는 집계/COUNT(*)/커버링**에서 쓰기 좋다.

### 6.2 언제 Index Full Scan이 쓰이나?

주로 다음 조건에서 IFS가 등장한다.

1. WHERE 조건이 **약하거나 거의 없음**
2. `ORDER BY`가 인덱스 순서와 **정확히 일치**
3. 인덱스가 **커버링**이면 테이블을 안 가도 되므로, 전체를 인덱스로 훑는 게 이득일 수 있다.

### 6.3 예제 — 정렬 일치로 IFS 선택

```sql
-- 조건 약함(등급 여러 개), 정렬 일치
SELECT /* IFS 후보 */ cust_id, created_at
FROM   scan_demo
WHERE  grade IN ('VIP','GOLD','SILVER')
ORDER  BY grade, created_at, cust_id;

-- 힌트로 유도
SELECT /*+ index_asc(scan_demo ix_scan_demo_g_dt_id) */
       cust_id, created_at
FROM   scan_demo
WHERE  grade IN ('VIP','GOLD','SILVER')
ORDER  BY grade, created_at, cust_id;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);
```

- WHERE 선택도가 애매하면 옵티마이저가
  - `INDEX RANGE SCAN` + `SORT`
  - 또는 `INDEX FULL SCAN` without `SORT`
  중 하나를 택한다.
- IFS가 선택되면, `SORT ORDER BY`가 사라지는 것을 확인할 수 있다.

### 6.4 커버링 인덱스 + IFS

```sql
-- 인덱스가 (grade, created_at, cust_id)만으로 충분한 질의
SELECT /* COVERING IFS */ cust_id
FROM   scan_demo
WHERE  grade = 'VIP'
ORDER  BY created_at, cust_id;
```

- SELECT-LIST가 모두 인덱스에 있으므로 `TABLE ACCESS BY INDEX ROWID`가 생략 가능.
- **랜덤 테이블 I/O 제거** → 인덱스만 훑는 것이 훨씬 유리할 수 있다.

---

## 7. Index Fast Full Scan (IFFS)

### 7.1 개념

`INDEX FAST FULL SCAN`은 인덱스 세그먼트를 **테이블처럼** 처리하여,  
정렬 순서는 무시하고 **멀티블록 I/O**(한 번에 여러 블록 읽기)로 빠르게 스캔한다.

- 흔히 **테이블 Full Scan의 인덱스 버전**이라고 생각하면 편하다.
- 정렬 순서를 보장하지 않기 때문에, ORDER BY를 맞추려면 별도 정렬이 필요하다.

### 7.2 언제 유리한가

- **COUNT(*)** 또는 집계에서
  - 테이블 보다 인덱스가 훨씬 작고,
  - 인덱스만으로 계산이 가능한 경우
- **병렬 쿼리**에서 인덱스를 여러 프로세스가 나눠 읽을 때
- SELECT-LIST가 **인덱스 컬럼만**으로 구성될 때

### 7.3 예제 — IFFS 강제

```sql
-- IFFS(빠른 풀스캔): 병렬/멀티블록 I/O, 정렬 보장 X
SELECT /*+ index_ffs(scan_demo ix_scan_demo_g_dt_id) */ COUNT(*)
FROM   scan_demo
WHERE  grade IN ('VIP','GOLD');  -- 집계/커버링이면 IFFS가 유리할 수 있음

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);
```

- 실행계획에서 `INDEX FAST FULL SCAN`을 확인.
- `Buffers`, `Read Requests`가 테이블 Full Scan에 비해 어떤지 비교해 보자.

### 7.4 IFS vs IFFS 비교

```sql
-- IFS: 키 순서 보장, 싱글블록 위주 → ORDER BY 제거, Top-N/Stopkey에 적합
SELECT /*+ index_asc(scan_demo ix_scan_demo_g_dt_id) */
       cust_id
FROM   scan_demo
ORDER  BY grade, created_at, cust_id
FETCH FIRST 100 ROWS ONLY;

-- IFFS: 키 순서 무시, 멀티블록 I/O → 집계/전량 훑기에 적합
SELECT /*+ index_ffs(scan_demo ix_scan_demo_g_dt_id) */
       COUNT(*)
FROM   scan_demo;
```

정리하면:

- **IFS**:  
  정렬 보장 / Top-N / 커버링 / 싱글블록 I/O  
- **IFFS**:  
  정렬 보장 X / 집계/COUNT / 병렬 / 멀티블록 I/O

---

## 8. Index Skip Scan (스킵 스캔)

### 8.1 개념

복합 인덱스에서 **선행 컬럼 조건이 없을 때**도,  
선행 컬럼의 가능한 값들을 **가상으로 대입**하여 **여러 Range Scan**을 합친 것처럼 동작하는 스캔 방식이다.

- 인덱스: `(grade, created_at, cust_id)`
- 조건: `created_at BETWEEN :from AND :to`
- 내부적으로는 대략:

$$
\bigcup_{g \in \{\text{BASIC},\dots,\text{VIP}\}}
\text{RangeScan}(grade = g, created\_at \in [\text{from},\text{to}))
$$

처럼 여러 Range Scan을 합친 것과 비슷한 효과.

### 8.2 예제 — 선행 컬럼 없이 날짜만

```sql
-- 인덱스: (grade, created_at, cust_id)
-- 조건: created_at만 (선행 grade 없음) → Skip Scan 후보
SELECT /* SKIP CAND */ cust_id, grade, created_at
FROM   scan_demo
WHERE  created_at >= DATE '2024-06-01'
AND    created_at <  DATE '2024-07-01';

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST')
);
```

- 계획에서 `INDEX SKIP SCAN IX_SCAN_DEMO_G_DT_ID`를 볼 수 있다.
- 내부적으로는 grade 각 값(VIP/GOLD/SILVER/BRONZE/BASIC/NEW)에 대해  
  `(grade=?, created_at between …)` 범위를 여러 번 스캔하는 것과 유사하다.

### 8.3 언제 유리/불리한가

- **유리**
  - 선행 컬럼의 **카디널리티가 작을 때** (예: 5~10개의 등급)
  - 후행 컬럼 조건이 **매우 선택적**일 때(좁은 날짜 범위 등)
- **불리**
  - 선행 컬럼의 도메인이 매우 클 때 (수천/수만)
  - 후행 컬럼 조건도 넓어서 **사실상 인덱스 대부분**을 읽게 되는 경우

### 8.4 힌트로 제어

- `INDEX_SS`, `INDEX_SS_ASC`, `INDEX_SS_DESC` 힌트로 Skip Scan을 유도하거나 막을 수 있다.

```sql
-- Skip Scan 유도
SELECT /*+ index_ss(scan_demo ix_scan_demo_g_dt_id) */
       cust_id, grade, created_at
FROM   scan_demo
WHERE  created_at >= DATE '2024-06-01'
AND    created_at <  DATE '2024-07-01';

-- Skip Scan 방지 (다른 인덱스 또는 Full Scan 유도)
SELECT /*+ no_index_ss(scan_demo ix_scan_demo_g_dt_id) */
       cust_id, grade, created_at
FROM   scan_demo
WHERE  created_at >= DATE '2024-06-01'
AND    created_at <  DATE '2024-07-07';
```

### 8.5 Skip Scan의 한계와 인덱스 설계 대안

Skip Scan은 “없느니보다는 나은 차선책”이다.  
근본적으로는 다음과 같은 설계를 통해 해결하는 편이 낫다.

- 자주 쓰이는 조건이 선행에 오도록 **인덱스 컬럼 순서 재설계**  
  예: `(created_at, grade, cust_id)` 인덱스를 추가
- 자주 쓰이는 조합이 다른 인덱스에 더 잘 맞으면 **별도 인덱스** 설계

---

## 9. Index Join / Index Combine (간단 개념)

이 글의 주제는 “스캔 방식”이므로 깊게 들어가지는 않지만,  
실무에서 흔히 마주치는 **여러 인덱스 결합 전략**을 개념적으로만 짚고 간다.

### 9.1 Index Join

- 서로 다른 B-Tree 인덱스 **두 개 이상**에서 **ROWID**를 가져와 조인하여,
- 테이블 방문 없이 **인덱스들만으로** SELECT-LIST를 만족시키는 전략.

예:

- 인덱스 A: `(grade, cust_id)`
- 인덱스 B: `(created_at, cust_id)`

쿼리:

```sql
SELECT cust_id, grade, created_at
FROM   scan_demo
WHERE  grade = 'VIP'
AND    created_at >= DATE '2024-06-01';
```

옵티마이저는 상황에 따라:

- 인덱스 A에서 `grade='VIP'`인 ROWID를 가져오고,
- 인덱스 B에서 `created_at>=…`인 ROWID를 가져와,
- **ROWID 교집합**을 구한 뒤, 그 결과로 테이블을 읽는 방식을 택할 수 있다.

실행계획에서는 `INDEX JOIN` 또는 `NESTED LOOPS` + 여러 인덱스 스캔 조합으로 보인다.

### 9.2 Index Combine (Bitmap + B-Tree 조합)

다수의 B-Tree 인덱스를 **비트맵으로 변환**한 뒤:

- `BITMAP AND`, `BITMAP OR`, `BITMAP MINUS`로 결합하여  
  최종 비트맵을 **ROWID 집합으로 변환**한 뒤 테이블을 방문하는 전략.

예:

```sql
WHERE grade IN ('VIP','GOLD')
  AND created_at >= DATE '2024-06-01'
  AND total_amt >= 50000
```

- 각각의 조건이 독립적인 B-Tree 인덱스에 걸려 있으면,  
  옵티마이저가 **Bitmap Conversion + Bitmap AND** 전략을 택할 수 있다.

실행계획에서 `BITMAP CONVERSION FROM ROWIDS`, `BITMAP AND`, `BITMAP CONVERSION TO ROWIDS` 등을 확인할 수 있다.

---

## 10. SARGable vs 비-SARGable 패턴 정리

**SARGable(“Search ARGument able”)**  
→ 인덱스 컬럼이 WHERE 절에서 **그대로** 사용되어, Start/Stop Key를 만들 수 있는 형태

### 10.1 대표 비-SARGable 패턴

1. 컬럼에 함수 적용

```sql
-- TRUNC, TO_CHAR, SUBSTR 등을 컬럼에 적용
TRUNC(created_at) = DATE '2024-03-01'
TO_CHAR(cust_id) = '123'
SUBSTR(note,1,3) = 'gif'
```

2. 컬럼 기준 연산

```sql
created_at + 1 = DATE '2024-03-02'
total_amt * 1.1 > 10000
```

3. 암시적 형변환

```sql
cust_id = '12345'   -- cust_id NUMBER, 바인드/리터럴이 문자열
created_at = '2024-03-01' -- DATE 컬럼에 문자열 리터럴
```

### 10.2 SARGable 리라이트 패턴 예

1. 날짜/시간

```sql
-- ❌
WHERE TRUNC(created_at) = DATE '2024-03-01';

-- ✅
WHERE created_at >= DATE '2024-03-01'
  AND created_at <  DATE '2024-03-02';
```

2. 문자열 접두사

```sql
-- ❌
WHERE SUBSTR(note,1,3) = 'gif';

-- ✅
WHERE note >= 'gif'
  AND note <  'gig';  -- ASCII/Collation 순서 기준
```

3. 숫자 연산

```sql
-- ❌
WHERE total_amt * 1.1 > 10000;

-- ✅
WHERE total_amt > 10000 / 1.1;
```

4. 형변환

```sql
-- ❌ 컬럼에 함수
WHERE TO_CHAR(cust_id) = '12345';

-- ✅ 상수/바인드를 변환
WHERE cust_id = TO_NUMBER(:cust_id_str); -- 하지만 더 좋은 건 애초에 NUMBER 타입 바인드
```

---

## 11. 드라이버/코딩 레벨 주의사항

인덱스 스캔 방식은 **쿼리 텍스트**뿐 아니라,  
JDBC/ODP.NET 등 **드라이버가 실제로 DB에 보내는 SQL과 바인드 타입**에도 직접 영향을 받는다.

### 11.1 바인드 타입

- NUMBER 컬럼에 문자열 바인드 → 암시적 형변환 → 컬럼에 함수 적용 효과 → 인덱스 스캔 저하

```java
// ❌
PreparedStatement ps = conn.prepareStatement(
  "SELECT grade FROM scan_demo WHERE cust_id = ?");
ps.setString(1, "12345");

// ✅
ps.setLong(1, 12345L);
```

### 11.2 Literal vs Bind

- Literal(리터럴)을 항상 직접 넣으면:
  - 파싱된 SQL이 전부 다름 → Shared Pool 오염
  - 옵티마이저가 값별 히스토그램을 활용하기 좋을 때도 있지만,  
    일반적으로는 **바인드 + Adaptive Cursor Sharing**을 활용하는 것이 안정적이다.
- 바인드 사용 시:
  - `statistics_level=ALL`, `+PEEKED_BINDS`로 실제 바인드 값을 확인하며 튜닝할 수 있다.

---

## 12. 반복 실험 템플릿 (비교 실습)

아래 템플릿을 그대로 써서 각 스캔 방식의 특징을 눈으로 확인해 볼 수 있다.

```sql
ALTER SESSION SET statistics_level = ALL;

-- A) RANGE
SELECT /*A*/ cust_id
FROM   scan_demo
WHERE  grade='VIP'
AND    created_at BETWEEN DATE '2024-09-01' AND DATE '2024-09-30'
ORDER  BY created_at, cust_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- B) IFS
SELECT /*B*/ cust_id
FROM   scan_demo
WHERE  grade IN ('VIP','GOLD','SILVER')
ORDER  BY grade, created_at, cust_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- C) UNIQUE
SELECT /*C*/ grade, created_at
FROM   scan_demo
WHERE  cust_id = 77777;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- D) SKIP
SELECT /*D*/ cust_id, grade
FROM   scan_demo
WHERE  created_at BETWEEN DATE '2024-06-01' AND DATE '2024-06-15';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

각 경우에 대해:

- `INDEX RANGE SCAN`, `INDEX FULL SCAN`, `INDEX FAST FULL SCAN`, `INDEX UNIQUE SCAN`, `INDEX SKIP SCAN` 등  
  어떤 오퍼레이터가 사용되었는지.
- `A-Rows`, `Buffers`, `Read Requests`, `Starts` 값.
- `TABLE ACCESS BY INDEX ROWID` 존재 여부(커버링 여부).
- `SORT ORDER BY` 유무(IFS/Range Scan으로 정렬이 제거되었는지).

---

## 13. 인덱스 스캔 방식 선택 로직 (직관 모델)

실전에서 옵티마이저가 스캔 방식을 고르는 논리를 **대략적으로** 요약하면 다음과 같다.

1. **유니크 조건**이 있는가?
   - 유니크 인덱스 + 모든 키 컬럼 등호 → **Index Unique Scan**
2. **등가/범위 조건**으로 Start/Stop Key를 만들 수 있는가?
   - 선행 컬럼부터 순서대로 조건이 잘 걸려 있다 → **Index Range Scan**
3. 선행 컬럼은 없지만 복합 인덱스가 있고, 선행 컬럼 도메인이 작나?
   - 그렇다면 **Index Skip Scan** 후보
4. WHERE가 약하거나 거의 없고, 정렬/커버링 조건이 맞는가?
   - 정렬 필요 없으면 → **Index Fast Full Scan**
   - 정렬 필요 + 인덱스 순서가 맞으면 → **Index Full Scan**
5. 인덱스를 써도 범위가 넓어져서 비용이 크다면?
   - **Full Table Scan** 또는 **다른 인덱스 조합**(Index Join/Bitmap Combine) 고려

옵티마이저의 내부 비용 계산 모델은 훨씬 복잡하지만,  
실무 튜닝 시에는 위와 같은 “마음가짐”으로 접근하면 플랜을 읽고 수정하기 쉬워진다.

---

## 14. 케이스 스터디 요약

### 14.1 리스트 API 느릴 때: RANGE + Stopkey

```sql
-- OFFSET 기반 페이지네이션 (비추)
SELECT cust_id, created_at
FROM   scan_demo
WHERE  grade='VIP'
ORDER  BY created_at, cust_id
OFFSET 100000 ROWS FETCH NEXT 50 ROWS ONLY;

-- Keyset 기반 페이지네이션 (권장)
SELECT cust_id, created_at
FROM   scan_demo
WHERE  grade='VIP'
  AND (created_at > :last_dt
       OR (created_at = :last_dt AND cust_id > :last_id))
ORDER  BY created_at, cust_id
FETCH FIRST 50 ROWS ONLY;
```

- `DBMS_XPLAN`으로 비교하면 OFFSET 쿼리의 `Buffers/Reads`가 훨씬 크다.

### 14.2 ORDER BY 제거를 위한 IFS

```sql
-- 등급/날짜 순으로 전체 정렬이 꼭 필요한 보고서
SELECT /* 보고서 */ cust_id, grade, created_at
FROM   scan_demo
ORDER  BY grade, created_at, cust_id;
```

- 인덱스 `(grade, created_at, cust_id)`와 정확히 일치하면  
  옵티마이저가 `INDEX FULL SCAN`을 사용하여 정렬을 생략할 수 있다.

### 14.3 선행 컬럼 없는 조건: Skip Scan or 별도 인덱스

```sql
-- ❌ created_at만으로 찾으면 SKIP SCAN 또는 Full Scan 상황
SELECT * FROM scan_demo
WHERE  created_at BETWEEN SYSDATE-1 AND SYSDATE;

-- ✅ 선행 컬럼을 합리적으로 추가
SELECT * FROM scan_demo
WHERE  grade IN ('VIP','GOLD')
AND    created_at BETWEEN SYSDATE-1 AND SYSDATE;

-- ✅ 아예 created_at 선행 인덱스를 별도로 설계
CREATE INDEX ix_scan_demo_dt ON scan_demo(created_at, cust_id);
```

- Skip Scan은 임시 방편일 뿐,  
  많이 쓰이는 조건 조합에는 별도의 인덱스 설계가 근본적인 해결책이다.

---

## 15. 최종 요약 체크리스트

### 15.1 스캔 방식별 정리

- **Index Unique Scan**
  - 유니크 인덱스 + 모든 키 등호
  - 가장 빠른 스캔 방식
  - 바인드 타입/함수 사용에 특히 주의

- **Index Range Scan**
  - Start/Stop Key가 명확한 범위
  - 정렬 일치 + Stopkey → Top-N/Keyset 페이징에 최적
  - 날짜/문자/숫자 조건을 SARGable하게 유지

- **Index Full Scan**
  - 인덱스 전체를 키 순서대로 스캔
  - ORDER BY 제거/커버링에 유리
  - 보통 싱글블록 I/O, 대량일 때는 주의(클러스터링 팩터 중요)

- **Index Fast Full Scan**
  - 인덱스를 테이블처럼 멀티블록 I/O로 전체 스캔
  - 정렬 보장 X, 집계/COUNT/병렬에 적합
  - 인덱스가 테이블보다 훨씬 작을 때 유리

- **Index Skip Scan**
  - 선행 컬럼 조건 없이 복합 인덱스를 활용하는 차선책
  - 선행 컬럼 도메인이 작을수록 OK
  - 자주 쓰면 인덱스 설계를 다시 보자

### 15.2 설계/코딩 관점 체크 포인트

- 인덱스 컬럼 순서:
  - **선행: 선택도 높은 필터**
  - **후행: 자주 쓰는 범위/정렬 컬럼**
- 커버링 인덱스:
  - 랜덤 테이블 I/O를 제거할 수 있어 중요 API/리포트에 큰 효과
- SARGable:
  - 컬럼에 함수/연산 금지
  - 바인드/상수를 변환하는 방식으로 재작성
- 드라이버:
  - 바인드 타입 정확히
  - 필요 시 힌트/Plan Baseline으로 플랜 안정화

---

## 16. 결론

- **인덱스 스캔 방식**은 단순히 “인덱스를 쓴다/안 쓴다”의 문제가 아니라,  
  **어떤 방식으로, 어느 정도 범위를, 어떤 순서로 읽느냐**의 문제다.
- 이 글에서 다룬 **Range / Unique / Full / Fast Full / Skip Scan**을  
  **실행계획과 DBMS_XPLAN 통계**로 직접 비교해 보면,
  - 왜 특정 경우에는 IFFS가,  
  - 다른 경우에는 IFS 또는 Range/Unique가,  
  - 가끔 Skip Scan이 등장하는지를  
  수치로 체감할 수 있다.
- 항상 마지막은 **숫자**다.
  - `A-Rows`, `Buffers`, `Reads`, `TempSpc`, `Elapsed`  
  를 보고, **쿼리 / 인덱스 / 코딩 방식** 중 무엇을 바꿀지 결정하자.

이 글의 스크립트를 로컬/테스트 DB에 그대로 실행해 보고,  
각 스캔 방식이 실제로 어떻게 동작하고, 어떤 상황에서 유리/불리한지  
직접 “눈으로 확인”하는 것이 가장 좋은 학습이다.