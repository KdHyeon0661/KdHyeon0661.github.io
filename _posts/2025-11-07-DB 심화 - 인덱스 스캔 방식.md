---
layout: post
title: DB 심화 - 인덱스 스캔 방식
date: 2025-11-07 15:25:23 +0900
category: DB 심화
---
# Oracle 인덱스 스캔 방식 총정리

## 0. 실습 스키마 준비

```sql
-- 깨끗이
DROP TABLE scan_demo PURGE;

-- 샘플 테이블: 고객, 등급, 가입일, 금액, 메모
CREATE TABLE scan_demo (
  cust_id     NUMBER        NOT NULL,
  grade       VARCHAR2(10)  NOT NULL,
  created_at  DATE          NOT NULL,
  total_amt   NUMBER(12,2)  NOT NULL,
  note        VARCHAR2(100),
  CONSTRAINT pk_scan_demo PRIMARY KEY (cust_id)
);

-- 데이터 20만 건
BEGIN
  FOR i IN 1..200000 LOOP
    INSERT INTO scan_demo
    VALUES (
      i,
      CASE MOD(i,6)
        WHEN 0 THEN 'VIP'
        WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER'
        WHEN 3 THEN 'BRONZE'
        WHEN 4 THEN 'BASIC'
        ELSE 'NEW'
      END,
      DATE '2024-01-01' + MOD(i, 400),
      ROUND(DBMS_RANDOM.VALUE(0, 100000), 2),
      CASE WHEN MOD(i,97)=0 THEN 'gift' END
    );
  END LOOP;
  COMMIT;
END;
/

-- 인덱스들
CREATE INDEX ix_scan_demo_g_dt_id ON scan_demo(grade, created_at, cust_id);
CREATE INDEX ix_scan_demo_dt_amt  ON scan_demo(created_at, total_amt);
-- 메모 텍스트 인덱스(접두사 실험용)
CREATE INDEX ix_scan_demo_note    ON scan_demo(note);

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'SCAN_DEMO', cascade => TRUE, method_opt => 'for all columns size skewonly');
END;
/
```

> 관찰 팁: 실습 전후로
```sql
ALTER SESSION SET statistics_level = ALL;  -- 이후 DBMS_XPLAN으로 실제 수행통계 확인
```

---

# 1. Index Range Scan (범위 스캔)

## 1.1 개념
- **선행 컬럼**으로 **Start Key**를 찾고, **Stop Key**까지 **Leaf 체인**을 **좌→우로 순차** 탐색.  
- **조건이 등호/부등호/Between/LIKE 'prefix%’** 같은 **연속 구간**을 만들 때** 최적.  
- **ORDER BY**가 인덱스 정렬과 **일치**하면 **정렬 생략** + **Stopkey**로 **앞부분만 읽고 종료** 가능.

## 1.2 기본 예제 — 고정 + 범위
```sql
-- 등급=VIP, 2024-03 한 달 범위
SELECT /* RANGE */ cust_id, created_at, total_amt
FROM   scan_demo
WHERE  grade='VIP'
AND    created_at >= DATE '2024-03-01'
AND    created_at <  DATE '2024-04-01'
ORDER  BY created_at, cust_id;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS'));
```
**기대 계획(핵심 라인)**
- `INDEX RANGE SCAN IX_SCAN_DEMO_G_DT_ID`
- `TABLE ACCESS BY INDEX ROWID SCAN_DEMO`
- `Sort` 없음(정렬 일치 시)

## 1.3 Top-N/Keyset 페이징 (Stopkey)
```sql
-- 정렬 일치 + 앞에서 50개만
SELECT /*+ index(scan_demo ix_scan_demo_g_dt_id) */
       cust_id, created_at, total_amt
FROM   scan_demo
WHERE  grade=:g
ORDER  BY created_at, cust_id
FETCH FIRST 50 ROWS ONLY;   -- Stopkey

-- 다음 페이지(키셋): 마지막 커서 키를 들고 다음 구간만
SELECT /* KEYSET */ cust_id, created_at, total_amt
FROM   scan_demo
WHERE  grade=:g
  AND (created_at > :last_dt
       OR (created_at = :last_dt AND cust_id > :last_id))
ORDER  BY created_at, cust_id
FETCH FIRST 50 ROWS ONLY;
```
> **Keyset**은 OFFSET보다 훨씬 적은 범위를 읽습니다.

## 1.4 SARGable 리라이트(날짜 함수 제거)
```sql
-- ❌  인덱스 비사용 유발 (컬럼 가공)
SELECT COUNT(*) FROM scan_demo
WHERE TRUNC(created_at) = DATE '2024-03-01';

-- ✅  범위로 재작성
SELECT COUNT(*) FROM scan_demo
WHERE created_at >= DATE '2024-03-01'
  AND created_at <  DATE '2024-03-02';
```

## 1.5 LIKE 접두사
```sql
-- 접두사만 인덱스 범위 스캔 가능
SELECT /* RANGE */ *
FROM   scan_demo
WHERE  note LIKE 'gif%';    -- OK (Start='gif', Stop='gig' 직전)

-- 후방/부분일치: '%gift%' → 범위 스캔 불가(Full Scan/Filter). 전문(텍스트) 인덱스 고려.
```

## 1.6 튜닝 포인트
- 선행 컬럼 **선택도** 높게 설계.  
- 정렬과 **컬럼 순서** 맞추기.  
- **커버링 인덱스**(SELECT-LIST가 인덱스에 있고 테이블 미방문).  
- **클러스터링 팩터(CF)** 좋게(물리순서 정렬 재적재).

---

# 2. Index Full Scan (인덱스 전체 순차 스캔)

> **Index Full Scan**(IFS)과 **Index Fast Full Scan**(IFFS)은 다릅니다.  
> - **IFS**: **인덱스 키 순서**로 **싱글블록 I/O** 위주. **정렬 순서 보장**.  
> - **IFFS**: **키 순서 무관**, **멀티블록 I/O**로 대량 처리. 정렬 보장 X. (아래 2.4에서 비교)

## 2.1 언제 쓰나
- WHERE 조건이 **약하거나 없음** + **ORDER BY**가 **인덱스 정렬과 일치** → **정렬 없이** 결과 뽑기.  
- 또는 인덱스가 **커버링**이라 테이블을 전혀 안 가도 될 때.

## 2.2 예제 — 정렬 일치로 IFS 선택
```sql
-- 조건 약함(등급 여러 개), 정렬 일치
SELECT /* IFS 후보 */ cust_id, created_at
FROM   scan_demo
WHERE  grade IN ('VIP','GOLD','SILVER')
ORDER  BY grade, created_at, cust_id;

-- 힌트로 유도 (상황에 따라 INDEX_ASC가 IFS를 선택하게 도움)
SELECT /*+ index_asc(scan_demo ix_scan_demo_g_dt_id) */
       cust_id, created_at
FROM   scan_demo
WHERE  grade IN ('VIP','GOLD','SILVER')
ORDER  BY grade, created_at, cust_id;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```
**핵심**
- `INDEX FULL SCAN IX_SCAN_DEMO_G_DT_ID`
- 정렬 연산자가 사라지면 IFS가 유리할 수 있음.

## 2.3 커버링으로 IFS 선택
```sql
-- 인덱스가 (grade, created_at, cust_id)만으로 충분한 질의
SELECT /* COVERING IFS */ cust_id
FROM   scan_demo
WHERE  grade='VIP'
ORDER  BY created_at, cust_id;
```
- 테이블 BY ROWID 방문이 없어 **랜덤 I/O 제거**.

## 2.4 IFS vs IFFS(비교)
```sql
-- IFFS(빠른 풀스캔): 병렬/멀티블록 I/O, 정렬 보장 X
SELECT /*+ index_ffs(scan_demo ix_scan_demo_g_dt_id) */ COUNT(*)
FROM   scan_demo
WHERE  grade IN ('VIP','GOLD');  -- 집계/커버링이면 IFFS가 유리

-- IFS: 키 순서 보장, 싱글블록 위주 → ORDER BY 제거 목적, Top-N과 친함
SELECT /*+ index_asc(scan_demo ix_scan_demo_g_dt_id) */
       /* IFS 후보 */
       cust_id
FROM   scan_demo
ORDER  BY grade, created_at, cust_id
FETCH FIRST 100 ROWS ONLY;
```
**요약**  
- **IFS**: 정렬 보장·Top-N/Stopkey·커버링에 적합(대개 싱글블록 I/O).  
- **IFFS**: 집계/전량 훑기/병렬 처리에 적합(멀티블록 I/O).

---

# 3. Index Unique Scan (유니크 스캔)

## 3.1 개념
- **유니크 인덱스**에 **모든 키 컬럼**이 **등호(=)** 로 주어졌을 때, **ROWID 1개**만 바로 찾음.  
- 비용 최소, **가장 빠른 형태**의 인덱스 접근.

## 3.2 PK = Unique Scan
```sql
-- PK 인덱스는 유니크. cust_id=12345 → Unique Scan
SELECT /* UNIQUE */ grade, created_at, total_amt
FROM   scan_demo
WHERE  cust_id = 12345;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```
**핵심**
- `INDEX UNIQUE SCAN PK_SCAN_DEMO`  
- `TABLE ACCESS BY INDEX ROWID SCAN_DEMO` (커버링이면 생략 가능)

## 3.3 유니크 스캔이 안 되는 흔한 이유
- **모든 키 컬럼**에 대해 **등호**가 아니거나, **함수/형변환**이 걸린 경우.  
- **NULL 비교**(유니크 인덱스는 전체 NULL을 키로 저장하지 않음; 유니크 제약에서도 NULL은 중복 허용).

**예**
```sql
-- ❌ 형변환/함수 사용으로 Unique Scan이 깨짐
SELECT * FROM scan_demo WHERE cust_id = TO_NUMBER(:cust_str); -- 드라이버가 문자열로 보내면?
-- → 바인드 타입을 NUMBER로 맞추자.
```

---

# 4. Index Skip Scan (스킵 스캔)

## 4.1 개념
- 복합 인덱스에서 **선행 컬럼 조건이 없을 때**, 선행 컬럼의 **가능한 값들**을 **가상으로 대입**하여  
  **여러 작은 Range Scan**을 합친 것처럼 동작.  
- 선행 컬럼의 **카디널리티(도메인)** 가 **작을수록** 유리.

> 내부적으로 “(grade=?1, created_at between …) OR (grade=?2, …) OR …” 를 묵시적으로 수행하는 것과 유사.

## 4.2 예제 — 선행 컬럼 없이 날짜만
```sql
-- 인덱스: (grade, created_at, cust_id)
-- 조건: created_at만 (선행 grade 없음) → Skip Scan 후보
SELECT /* SKIP CAND */ cust_id, grade, created_at
FROM   scan_demo
WHERE  created_at >= DATE '2024-06-01'
AND    created_at <  DATE '2024-07-01';

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```
**가능한 계획**
- `INDEX SKIP SCAN IX_SCAN_DEMO_G_DT_ID`
- 선행 `grade`의 서로 다른 값(VIP/GOLD/… NEW 등)을 **루프** 돌며 **여러 Range Scan**을 수행.

## 4.3 언제 유리/불리한가
- **유리**: 선행 컬럼 도메인이 **작다**(예: 5~10개 등급), **후행 컬럼** 조건 **좋음**(좁은 날짜 범위).  
- **불리**: 선행 컬럼 도메인이 **크다**(수천/수만), 후행 컬럼 조건 **약함** → 사실상 많은 범위를 여러 번 읽는 꼴 → **Full Scan**이나 다른 인덱스가 낫다.

## 4.4 스킵 스캔을 피하거나 선택하게 하는 법
- **피하기**: 선행 컬럼을 **명시적으로 제공**(바인드/필터)하거나, **다른 인덱스**(선행을 필요한 컬럼으로) 설계.  
- **활용**: 복합 인덱스 설계가 제한될 때 **임시 방편**으로 유용.

---

# 5. 스캔 방식 선택 로직(직관 모델)

1) **유니크 조건**이 있나? → **Index Unique Scan**  
2) **등가/범위로 Start/Stop Key**가 명확? → **Index Range Scan**  
3) **선행 컬럼이 빠졌지만 도메인이 작나?** → **Index Skip Scan** 고려  
4) WHERE 약/無 + **정렬 일치/커버링**? → **Index Full Scan**  
5) **대량 집계/전량 훑기/병렬**? → **Index Fast Full Scan**(참고)

---

# 6. 케이스 스터디

## 6.1 리스트 API가 느릴 때: RANGE + Stopkey
```sql
-- ❌ OFFSET 기반
SELECT cust_id, created_at
FROM   scan_demo
WHERE  grade='VIP'
ORDER  BY created_at, cust_id
OFFSET 100000 ROWS FETCH NEXT 50 ROWS ONLY;  -- 앞에서 10만 행을 지나쳐야…

-- ✅ Keyset (마지막 키를 기억)
SELECT cust_id, created_at
FROM   scan_demo
WHERE  grade='VIP'
  AND (created_at > :last_dt
       OR (created_at=:last_dt AND cust_id > :last_id))
ORDER  BY created_at, cust_id
FETCH FIRST 50 ROWS ONLY;
```
- **Buffers/Reads**를 DBMS_XPLAN으로 비교해보면 차이가 분명합니다.

## 6.2 ORDER BY 제거를 위한 IFS
```sql
-- 등급별/날짜순 정렬이 꼭 필요한 보고서
SELECT /* 보고서 */ cust_id, grade, created_at
FROM   scan_demo
ORDER  BY grade, created_at, cust_id;

-- 인덱스 정렬과 일치 → IFS 선택되면 SORT 제거
-- (필요하면 index_asc 힌트로 유도)
```

## 6.3 선행 컬럼 없는 조건: 스킵 스캔 대안
```sql
-- ❌ (스킵 스캔 후보이나 도메인이 크면 비효율)
SELECT * FROM scan_demo
WHERE  created_at BETWEEN SYSDATE-1 AND SYSDATE;

-- ✅ 선행 컬럼을 합리적으로 추가(업무 규칙 반영)
SELECT * FROM scan_demo
WHERE  grade IN ('VIP','GOLD')
AND    created_at BETWEEN SYSDATE-1 AND SYSDATE;

-- ✅ 아예 created_at 선행 인덱스를 별도로 설계
CREATE INDEX ix_scan_demo_dt ON scan_demo(created_at, cust_id);
```

---

# 7. 드라이버/코딩 레벨 주의 (스캔 방식에 직접 영향)

- **바인드 타입 일치**: NUMBER 컬럼에 문자열 바인드 → 묵시적 변환/컬럼 가공 → 스캔 저하.  
- **SARGable**: 컬럼에 함수/계산 금지, **상수/바인드**를 변환.  
- **정렬·선행 컬럼 맞춤**: 필요한 ORDER BY 순서에 맞춰 **인덱스 컬럼 순서**를 설계.  
- **커버링**: 테이블 랜덤 I/O 제거.

**JDBC 예**
```java
// ❌ 문자열 바인드로 cust_id 비교
ps.setString(1, "12345");

// ✅ 숫자 바인드
ps.setLong(1, 12345L);
```

---

# 8. 반복 실험 템플릿

```sql
ALTER SESSION SET statistics_level = ALL;

-- A) RANGE
SELECT /*A*/ cust_id
FROM scan_demo
WHERE grade='VIP'
AND   created_at BETWEEN DATE '2024-09-01' AND DATE '2024-09-30'
ORDER BY created_at, cust_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- B) IFS
SELECT /*B*/ cust_id
FROM scan_demo
WHERE grade IN ('VIP','GOLD','SILVER')
ORDER BY grade, created_at, cust_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- C) UNIQUE
SELECT /*C*/ grade, created_at FROM scan_demo WHERE cust_id = 77777;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- D) SKIP
SELECT /*D*/ cust_id, grade
FROM scan_demo
WHERE created_at BETWEEN DATE '2024-06-01' AND DATE '2024-06-15';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

관찰 포인트:  
- 오퍼레이터(`INDEX RANGE/UNIQUE/FULL/…`, `INDEX SKIP SCAN`, `INDEX FAST FULL SCAN`)  
- `Rows (A-Rows)`, `Buffers`, `Reads`, `Starts`  
- SORT 유무(IFS면 제거될 수 있음), 테이블 BY ROWID 방문 여부(커버링이면 0)

---

# 9. 요약 체크리스트

- **Range Scan**: Start/Stop Key를 만들자(컬럼 가공 금지, 날짜는 범위). 정렬 일치+Stopkey로 빠르게.  
- **Full Scan(IFS)**: 정렬 보장·Top-N/커버링 시 유리. (IFFS와 다름)  
- **Unique Scan**: 모든 키 컬럼 등가 비교. 바인드 타입 정확히.  
- **Skip Scan**: 선행 컬럼이 없을 때 “차선”. 선행 도메인이 작을수록 OK.  
- **설계**: 인덱스 컬럼 순서=필터(선행 선택도)→범위→정렬, 필요 시 커버링.  
- **코딩**: 묵시적 변환 금지, 바인드 타입 일치, 컬럼 가공 금지(SARGable).

> 결론: 스캔 방식은 “**조건의 모양**”과 “**인덱스 설계**”가 함께 결정합니다.  
> 실행계획과 실제 수행통계를 **항상** 확인해, 예상과 다르면 **쿼리/인덱스/바인드/정렬** 중 어디가 어긋났는지 바로잡으세요. 숫자가 답을 알려줍니다.