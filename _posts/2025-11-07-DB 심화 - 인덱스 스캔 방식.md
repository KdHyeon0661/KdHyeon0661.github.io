---
layout: post
title: DB 심화 - 인덱스 스캔 방식
date: 2025-11-07 15:25:23 +0900
category: DB 심화
---
# Oracle 인덱스 스캔 방식

## 0. 실습 환경 및 기본 세션 설정

실습은 Oracle 19c/23c급을 가정한다. 버전에 따라 옵티마이저 힌트와 통계 기본값은 다를 수 있지만, **인덱스 스캔 방식 자체는 10g 이후 큰 틀은 동일**하다.

```sql
ALTER SESSION SET nls_date_format  = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;
```

`statistics_level = ALL`로 설정하면 쿼리 실행 후 `DBMS_XPLAN.DISPLAY_CURSOR`를 사용하여 **실제 수행 통계**(예: 버퍼 I/O, 실제 반환 행 수)를 확인할 수 있다. 이는 예상 실행 계획이 아닌, 실제 실행 결과를 분석하는 데 필수적이다.

---

## 1. 실습 스키마 준비

다음은 인덱스 스캔 방식을 실습하기 위한 기본 테이블과 데이터이다.

```sql
-- 테이블 생성
DROP TABLE scan_demo PURGE;

CREATE TABLE scan_demo (
  cust_id     NUMBER        NOT NULL,
  grade       VARCHAR2(10)  NOT NULL,
  created_at  DATE          NOT NULL,
  total_amt   NUMBER(12,2)  NOT NULL,
  note        VARCHAR2(100),
  CONSTRAINT pk_scan_demo PRIMARY KEY (cust_id)
);

-- 20만 건 샘플 데이터 삽입
BEGIN
  FOR i IN 1..200000 LOOP
    INSERT INTO scan_demo
    VALUES (
      i,
      CASE MOD(i,6)
        WHEN 0 THEN 'VIP'
        WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER'
        WHEN 3 THEN 'BRONZE'
        WHEN 4 THEN 'BASIC'
        ELSE 'NEW'
      END,
      DATE '2024-01-01' + MOD(i, 400),
      ROUND(DBMS_RANDOM.VALUE(0, 100000), 2),
      CASE WHEN MOD(i,97)=0 THEN 'gift' END
    );
  END LOOP;
  COMMIT;
END;
/

-- 인덱스 생성
CREATE INDEX ix_scan_demo_g_dt_id ON scan_demo(grade, created_at, cust_id);
CREATE INDEX ix_scan_demo_dt_amt  ON scan_demo(created_at, total_amt);
CREATE INDEX ix_scan_demo_note    ON scan_demo(note);

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER, 'SCAN_DEMO',
    cascade    => TRUE,
    method_opt => 'for all columns size skewonly'
  );
END;
/
```

실습 전에는 항상 다음 설정을 적용한다.

```sql
ALTER SESSION SET statistics_level = ALL;
```

---

## 2. B-Tree 인덱스 기본 구조와 용어

### B-Tree 인덱스 구조

Oracle B-Tree 인덱스는 Root Block, Branch Blocks, Leaf Blocks의 계층 구조로 이루어져 있다. Leaf Block에는 인덱스 키 값과 해당 행의 물리적 주소인 ROWID가 정렬되어 저장된다.

### ROWID와 클러스터링 팩터

- **ROWID**는 데이터 파일, 블록, 행 슬롯을 지정하는 물리적 주소이다.
- **클러스터링 팩터(CF)**는 인덱스의 논리적 순서와 테이블 행의 물리적 저장 순서가 얼마나 일치하는지를 나타내는 지표이다. CF가 테이블 블록 수에 가까우면 인덱스 범위 스캔 효율이 좋고, 테이블 행 수에 가까우면 랜덤 I/O가 증가하여 성능이 저하된다.

```sql
SELECT index_name, blevel, leaf_blocks, clustering_factor
FROM   user_indexes
WHERE  table_name = 'SCAN_DEMO';
```

---

## 3. 인덱스 스캔 방식 전체 지도

Oracle의 주요 B-Tree 인덱스 스캔 방식은 다음과 같다.

- **Index Unique Scan**: 유니크 인덱스를 이용해 정확히 한 행을 찾는 가장 빠른 스캔.
- **Index Range Scan**: 시작과 종료 키를 기준으로 리프 블록을 순차 탐색. 가장 일반적.
- **Index Full Scan**: 인덱스 전체를 키 순서대로 싱글블록 I/O로 읽음. 정렬 보장.
- **Index Fast Full Scan**: 인덱스 전체를 멀티블록 I/O로 빠르게 읽음. 정렬 보장 안 됨.
- **Index Skip Scan**: 복합 인덱스의 선행 컬럼 조건이 없을 때 사용하는 차선책.

이외에도 여러 인덱스를 결합하는 Index Join이나 Bitmap 변환을 이용한 Index Combine 등의 전략이 있다.

---

## 4. Index Range Scan (범위 스캔)

### 개념

선행 컬럼으로 시작 키(Start Key)를 찾고, 종료 키(Stop Key)까지 리프 블록의 체인을 따라 순차적으로 스캔한다. 등호(`=`), 부등호(`>`, `<`), `BETWEEN`, `LIKE 'prefix%'`와 같은 연속 구간 조건에 적합하다. 인덱스 정렬과 `ORDER BY`가 일치하면 정렬 작업을 생략할 수 있으며, `FETCH FIRST n ROWS ONLY`와 함께 사용하면 필요한 최소한의 행만 읽고 중단(Stopkey)할 수 있어 매우 효율적이다.

### 기본 예제 — 고정 조건과 범위 조건

```sql
SELECT /* RANGE */ cust_id, created_at, total_amt
FROM   scan_demo
WHERE  grade = 'VIP'
AND    created_at >= DATE '2024-03-01'
AND    created_at <  DATE '2024-04-01'
ORDER  BY created_at, cust_id;
```
이 쿼리는 `(grade, created_at, cust_id)` 인덱스를 이용해 `grade='VIP'`인 구간에서 `created_at`이 2024년 3월인 범위를 스캔한다. `ORDER BY` 절은 인덱스 순서와 일치하므로 별도 정렬이 발생하지 않는다.

### Top-N 및 Keyset 페이징

`OFFSET` 페이징은 앞선 행을 모두 읽고 버리므로 비효율적이다. 대신 마지막으로 조회한 키 값을 기억하는 **Keyset 페이징**을 사용하면 이후 페이지 조회 시 성능 저하가 거의 없다.

```sql
-- Keyset 페이징 예시
SELECT cust_id, created_at, total_amt
FROM   scan_demo
WHERE  grade = :g
  AND (created_at > :last_dt
       OR (created_at = :last_dt AND cust_id > :last_id))
ORDER  BY created_at, cust_id
FETCH FIRST 50 ROWS ONLY;
```

### SARGable 리라이트

인덱스 컬럼에 함수를 적용하면 옵티마이저가 Start/Stop Key를 생성할 수 없어 범위 스캔을 사용하지 못한다. 항상 컬럼 자체를 조건의 좌변에 두어야 한다.

```sql
-- 비효율적: 컬럼 가공
SELECT COUNT(*) FROM scan_demo WHERE TRUNC(created_at) = DATE '2024-03-01';

-- 효율적: 범위 재작성
SELECT COUNT(*) FROM scan_demo
WHERE created_at >= DATE '2024-03-01'
  AND created_at <  DATE '2024-03-02';
```

### LIKE와 범위 스캔

`LIKE 'gif%'`와 같은 접두사 일치는 문자열 정렬 순서에 따라 `['gif...', 'gig...')` 구간으로 변환 가능하므로 인덱스 범위 스캔이 가능하다. 그러나 `LIKE '%gift%'`와 같은 패턴은 시작 키를 특정할 수 없어 인덱스 스캔에 불리하다.

---

## 5. Index Unique Scan (유니크 스캔)

### 개념

유니크 인덱스(기본 키 포함)의 **모든 키 컬럼**에 대해 등호(`=`) 조건이 주어졌을 때 사용된다. Root에서 Leaf까지 트리를 타고 내려가 정확히 한 건의 ROWID를 찾는 가장 효율적인 스캔 방식이다.

### 기본 예제

```sql
SELECT /* UNIQUE */ grade, created_at, total_amt
FROM   scan_demo
WHERE  cust_id = 12345;
```
`cust_id`는 기본 키이므로 `INDEX UNIQUE SCAN`이 수행된다.

### 주의사항

유니크 스캔이 동작하려면 모든 키 컬럼이 조건에 포함되어야 하며, 컬럼에 함수가 적용되거나 암시적 형변환이 발생하면 스캔 방식이 달라질 수 있다.

```sql
-- ❌ 형변환으로 인해 유니크 스캔 실패 가능성 높음
SELECT * FROM scan_demo WHERE TO_CHAR(cust_id) = '12345';

-- ✅ 컬럼 타입에 맞는 바인드 변수 사용
SELECT * FROM scan_demo WHERE cust_id = :cust_id_num;
```

---

## 6. Index Full Scan (인덱스 전체 순차 스캔)

### 개념

인덱스의 모든 리프 블록을 **키 순서대로** 처음부터 끝까지 읽는 방식이다. 싱글블록 I/O를 주로 사용하며, 인덱스의 정렬 순서를 보장한다. 따라서 `ORDER BY` 절이 인덱스 순서와 일치할 경우 정렬 작업을 생략할 수 있다. 대량의 데이터를 순차적으로 읽어야 할 때, 특히 커버링 인덱스(조회하는 컬럼이 모두 인덱스에 포함됨)인 경우 테이블 액세스 없이 빠르게 처리될 수 있다.

### 예제 — 정렬 생략

```sql
SELECT /* IFS */ cust_id, created_at
FROM   scan_demo
WHERE  grade IN ('VIP','GOLD','SILVER')
ORDER  BY grade, created_at, cust_id;
```
인덱스 `(grade, created_at, cust_id)`의 순서와 `ORDER BY`가 정확히 일치하므로, 옵티마이저는 `INDEX FULL SCAN`을 선택해 `SORT ORDER BY` 작업을 생략할 수 있다.

### 커버링 인덱스 활용

```sql
SELECT /* COVERING IFS */ cust_id
FROM   scan_demo
WHERE  grade = 'VIP'
ORDER  BY created_at, cust_id;
```
SELECT 목록의 `cust_id`가 인덱스에 포함되어 있으므로(`(grade, created_at, cust_id)`), 테이블 액세스 없이 인덱스만 스캔하여 결과를 반환한다. 이는 랜덤 I/O를 제거하여 성능을 크게 향상시킨다.

---

## 7. Index Fast Full Scan (인덱스 고속 전체 스캔)

### 개념

인덱스 세그먼트를 테이블처럼 간주하여, **멀티블록 I/O**를 사용해 가능한 한 빠르게 전체를 스캔하는 방식이다. 디스크의 물리적 저장 순서대로 읽히기 때문에 **키의 논리적 정렬 순서는 보장되지 않는다**. `ORDER BY`가 필요 없고, 전체 행 수를 세거나(`COUNT(*)`), 간단한 집계를 수행할 때 유리하다. 병렬 처리와도 잘 결합된다.

### 예제

```sql
SELECT /*+ index_ffs(scan_demo ix_scan_demo_g_dt_id) */ COUNT(*)
FROM   scan_demo
WHERE  grade IN ('VIP','GOLD');
```
`INDEX FAST FULL SCAN` 힌트를 사용하여 이 스캔 방식을 유도할 수 있다. 실행 계획에서 `INDEX FAST FULL SCAN` 오퍼레이션을 확인한다.

### Index Full Scan vs Index Fast Full Scan

- **IFS (Index Full Scan)**: 정렬 보장, 싱글블록 I/O 위주, Top-N/정렬 쿼리에 적합.
- **IFFS (Index Fast Full Scan)**: 정렬 보장 안 함, 멀티블록 I/O, 집계/전체 카운트/병렬 쿼리에 적합.

선택은 쿼리의 목적(정렬 필요 여부)과 데이터량, 인덱스의 크기에 따라 달라진다.

---

## 8. Index Skip Scan (인덱스 건너뛰기 스캔)

### 개념

복합 인덱스에서 **선행 컬럼이 WHERE 조건에 없을 때** 사용할 수 있는 차선책이다. 옵티마이저는 선행 컬럼의 각 고유 값을 가상으로 대입한 뒤, 그 각각에 대해 후행 컬럼 조건으로 범위 스캔을 수행하는 것과 같은 효과를 낸다. 즉, 하나의 인덱스를 여러 번 스캔하는 것처럼 동작한다.

### 예제

인덱스 `(grade, created_at, cust_id)`가 있을 때:
```sql
SELECT /* SKIP */ cust_id, grade, created_at
FROM   scan_demo
WHERE  created_at >= DATE '2024-06-01'
AND    created_at <  DATE '2024-07-01';
```
선행 컬럼 `grade`에 조건이 없지만, 옵티마이저는 `grade`의 각 값('VIP','GOLD',...,'NEW')에 대해 `created_at` 조건을 만족하는 범위를 별도로 스캔한 후 결과를 합쳐서 반환한다. 실행 계획에 `INDEX SKIP SCAN`이 나타난다.

### 적용 조건과 한계

Skip Scan은 선행 컬럼의 **카디널리티(고유 값 개수)가 낮고**, 후행 컬럼 조건의 **선택도가 높을수록** 유리하다. 예를 들어 성별(`gender`)처럼 값의 종류가 적은 컬럼이 선행이고, 날짜처럼 선택적인 조건이 후행일 때 효과적이다. 반대로 선행 컬럼의 값이 너무 다양하거나, 후행 컬럼 조건이 넓어 인덱스의 대부분을 읽어야 한다면 성능상 불리할 수 있다. 근본적인 해결책은 자주 사용되는 조합에 맞는 새로운 인덱스를 생성하는 것이다.

---

## 9. Index Join / Index Combine (간단 개념)

여러 인덱스를 동시에 사용하여 테이블 액세스를 최소화하는 고급 기법이다.

- **Index Join**: 두 개 이상의 인덱스에서 ROWID를 조회한 후, 이 ROWID들을 결합(조인)하여 최종 결과 집합을 만든다. 각 인덱스가 쿼리의 일부 조건을 커버할 때 유용하다.
- **Index Combine (Bitmap)**: B-Tree 인덱스를 비트맵으로 변환한 후, `BITMAP AND` 또는 `BITMAP OR` 연산으로 결합한다. 많은 수의 인덱스를 결합하는 복잡한 필터 조건에 강점이 있다. 실행 계획에 `BITMAP CONVERSION` 관련 오퍼레이션이 나타난다.

이러한 기법들은 옵티마이저가 자동으로 선택할 수 있지만, 인덱스 설계와 통계 정보의 정확성이 매우 중요하다.

---

## 10. SARGable vs 비-SARGable 패턴 정리

**SARGable**이란 Search Argument Able의 약자로, WHERE 조건이 인덱스의 Start/Stop Key 생성에 활용될 수 있는 형태를 말한다. 비-SARGable 조건은 인덱스 스캔 효율을 떨어뜨린다.

### 비-SARGable 패턴 예시 및 개선

```sql
-- ❌ 컬럼에 함수 적용
WHERE TRUNC(created_at) = DATE '2024-03-01';
-- ✅ 범위 조건으로 재작성
WHERE created_at >= DATE '2024-03-01' AND created_at < DATE '2024-03-02';

-- ❌ 컬럼 산술 연산
WHERE total_amt * 1.1 > 10000;
-- ✅ 상수 측에서 연산
WHERE total_amt > 10000 / 1.1;

-- ❌ 암시적 형변환 (NUMBER 컬럼에 문자열 비교)
WHERE cust_id = '12345';
-- ✅ 명시적 형변환 (바인드 변수 사용이 최선)
WHERE cust_id = TO_NUMBER('12345'); -- Or better, use a NUMBER bind variable
```

애플리케이션 레벨에서도 JDBC/ODP.NET 등의 드라이버를 사용할 때 **바인드 변수의 데이터 타입**을 정확히 맞추는 것이 중요하다. `NUMBER` 컬럼에 문자열 타입 바인드를 설정하면 데이터베이스 내부에서 암시적 형변환이 발생해 SARGable 조건이 깨질 수 있다.

---

## 11. 실습 템플릿 및 성능 분석 방법

다음 템플릿을 사용하여 각 스캔 방식의 성능 차이를 직접 관찰해 보자.

```sql
ALTER SESSION SET statistics_level = ALL;

-- 1. Range Scan
SELECT /* RANGE_TEST */ cust_id
FROM   scan_demo
WHERE  grade='VIP'
AND    created_at BETWEEN DATE '2024-09-01' AND DATE '2024-09-30';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- 2. Full Scan (정렬 포함)
SELECT /* FULL_SCAN_TEST */ cust_id
FROM   scan_demo
ORDER  BY grade, created_at, cust_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- 3. Unique Scan
SELECT /* UNIQUE_TEST */ grade
FROM   scan_demo
WHERE  cust_id = 77777;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

-- 4. Skip Scan
SELECT /* SKIP_TEST */ cust_id, grade
FROM   scan_demo
WHERE  created_at BETWEEN DATE '2024-06-01' AND DATE '2024-06-15';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

`DBMS_XPLAN` 출력에서 다음 항목에 주목한다:
- **오퍼레이션**: `INDEX RANGE SCAN`, `INDEX FULL SCAN` 등 실제 스캔 방식 확인.
- **A-Rows**: 실제 반환된 행 수. Stopkey 동작 여부를 판단.
- **Buffers**: 논리적 I/O 횟수. 값이 적을수록 캐시 효율이 좋음.
- **Reads**: 물리적 I/O 횟수.
- **Starts**: 오퍼레이션 실행 횟수.
- **TempSpc**: 디스크 정렬 발생 여부.

---

## 결론

Oracle 인덱스 스캔 방식을 이해하는 것은 SQL 성능 튜닝의 핵심이다. 각 스캔 방식은 고유의 동작 원리와 적절한 적용 시나리오를 가진다. 단순히 '인덱스를 태운다'는 것 이상으로, **어떤 방식으로, 얼마나 많은 범위를, 어떤 순서로 읽는가**가 성능을 결정한다.

효율적인 인덱스 활용을 위한 핵심 원칙은 다음과 같다.
1.  **인덱스 설계**: 자주 사용되고 선택도가 높은 필터 조건을 선행 컬럼으로, 자주 정렬되는 컬럼을 후행 컬럼으로 구성한다. 커버링 인덱스를 활용하면 테이블 랜덤 액세스 비용을 제거할 수 있다.
2.  **SARGable 쿼리 작성**: 인덱스 컬럼을 가공하지 말고, 조건의 좌변에 두어 옵티마이저가 Start/Stop Key를 생성할 수 있게 한다.
3.  **실행 계획 분석 습관**: `DBMS_XPLAN`을 활용해 예상이 아닌 **실제 실행 통계**를 확인한다. `A-Rows`, `Buffers` 같은 수치를 보며 비효율의 원인을 찾는다.
4.  **적절한 스캔 방식 유도**: 옵티마이저가 최적의 선택을 하지 못할 때는 힌트 등을 신중하게 사용하여 `INDEX RANGE SCAN`, `INDEX FULL SCAN` 등 적합한 스캔 방식을 유도할 수 있다. 그러나 힌트 사용 전 통계 정보의 최신성과 인덱스 설계를 점검하는 것이 우선이다.

이 문서의 실습 스크립트를 직접 실행하고, 다양한 조건과 힌트를 변경해가며 실행 계획과 성능 수치의 변화를 관찰하는 것이 가장 효과적인 학습 방법이다. 결국 데이터의 분포, 시스템 부하, 비즈니스 요구사항을 종합적으로 고려한 상황 판단이 최적의 접근 방식을 이끌어낸다.