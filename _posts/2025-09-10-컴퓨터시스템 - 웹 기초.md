---
layout: post
title: 컴퓨터시스템 - 웹 기초
date: 2025-09-10 15:20:23 +0900
category: 컴퓨터시스템
---
# 웹 기초 ↔ 웹 컨텐츠 ↔ HTTP 트랜잭션 ↔ 동적 컨텐츠 처리(끝판정리)

> 목표: **웹이 어떻게 작동하는지**를 OS/네트워크/언어에 중립적으로 이해하기.  
> 범위: **웹 기본 요소 → 컨텐츠의 종류와 표현 → HTTP 트랜잭션의 전체 수명주기 → 동적 컨텐츠 처리(서버 내부)**.  
> 형식: 전체는 `~~~markdown`으로 감싸고, 코드/프로토콜 예시는 모두 ``` 코드펜스 사용.

---

## 1) 웹 기초: 주소·이름·연결

### 1.1 URL/URI 구조
```
scheme://user:pass@host:port/path?query#fragment
例) https://example.com:443/articles/42?print=1#comments
```
- **scheme**: `http`, `https`, `ws`, `wss`, `ftp`…
- **host**: 도메인(예 `www.example.com`) 또는 IP
- **port**: HTTP=80, HTTPS=443 (생략 시 기본값)
- **path/query**: 리소스 식별 + 파라미터
- **fragment**: 클라이언트 측 참조(서버 미전송)

### 1.2 웹 트랜잭션이 시작되기까지
1) **URL 입력**
2) **DNS 조회**: 도메인 → IP(권한·재귀 DNS)
3) **전송 계층 연결**
   - HTTP/1.1, HTTP/2: 주로 **TCP**(3-way handshake)
   - HTTPS: **TLS handshake**(서버 인증서 검증, 암호화 매김)
   - HTTP/3: **QUIC(UDP 기반)** + TLS 1.3 내장
4) **HTTP 요청** 송신 → **HTTP 응답** 수신
5) (옵션) **연결 재사용**: keep-alive, HTTP/2 멀티플렉싱, HTTP/3 스트림

---

## 2) 웹 컨텐츠: 정적·동적·하이브리드

### 2.1 정적 컨텐츠(Static)
- **그대로 제공되는 파일**: HTML, CSS, JS, 이미지, 폰트, 동영상…
- 장점: 빠름(캐시/CDN 친화), 예측 가능  
- 전송 최적화: **gzip/br 압축**, **HTTP/2 서버푸시(과거)/프리로드**, **ETag/Cache-Control**, **sendfile**, **mmap**

### 2.2 동적 컨텐츠(Dynamic)
- **요청마다 생성**: 템플릿 렌더링, DB 조회, 개인화, API 응답(JSON)
- 구현: **CGI/FastCGI/WSGI/PSGI/Rack/ASGI**, 프레임워크(Django, Spring, Express 등)
- 장점: 유연, 개인화/권한  
- 비용: 계산/DB/캐시 설계 필요

### 2.3 하이브리드/현대 패턴
- **SSR(Server-Side Rendering)**: 초기 HTML 서버 렌더 → CSR 보강
- **SPA(Client-Side Rendering)**: 초기 HTML + JS 앱이 API 호출
- **SSG(Static Site Generation)**: 빌드 타임 정적화 + 동적 섹션만 API
- **Edge/Functions**: CDN 경계에서 경량 동적 처리

---

## 3) HTTP 트랜잭션: 요청 ↔ 응답의 해부학

### 3.1 요청(Request) 메시지 형식
```
<METHOD> <REQUEST-TARGET> HTTP/1.1\r\n
Host: example.com\r\n
Header-Name: value\r\n
...\r\n
\r\n
[optional body]
```
- **메서드**: `GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `OPTIONS`
- **타겟**: 절대경로(`/path?query`) 또는 `*`/절대URI(프록시)
- **Host**: HTTP/1.1 필수(가상호스팅)

#### 예: GET
```
GET /images/logo.png HTTP/1.1
Host: www.example.com
Accept: image/avif,image/webp,*/*
If-None-Match: "abc123"
```

#### 예: POST(JSON)
```
POST /api/todo HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 27

{"title":"buy milk","done":false}
```

### 3.2 응답(Response) 메시지 형식
```
HTTP/1.1 <STATUS-CODE> <REASON>\r\n
Header-Name: value\r\n
...\r\n
\r\n
[optional body]
```
- **상태 코드**(주요):
  - 1xx: 정보(`100 Continue`)
  - 2xx: 성공(`200 OK`, `201 Created`, `204 No Content`)
  - 3xx: 리다이렉트(`301/302/303/307/308`)
  - 4xx: 클라이언트 오류(`400`, `401`, `403`, `404`, `429`)
  - 5xx: 서버 오류(`500`, `502`, `503`, `504`)

#### 예: 200 OK (정적 파일)
```
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 1256
Cache-Control: public, max-age=86400
ETag: "abc123"
Last-Modified: Wed, 14 Aug 2025 09:07:00 GMT

<html>...</html>
```

#### 예: 304 Not Modified(조건부 GET)
```
HTTP/1.1 304 Not Modified
ETag: "abc123"
```

### 3.3 핵심 헤더 따라잡기
- **식별/프레이밍**
  - `Host`, `Content-Length`, `Transfer-Encoding: chunked`, `Connection: keep-alive/close`
- **콘텐츠 협상**
  - `Accept`, `Accept-Language`, `Accept-Encoding(gzip, br)`, `Content-Type`
- **캐싱**
  - `Cache-Control`(public/private, max-age, no-store), `ETag`, `If-None-Match`, `Last-Modified`, `If-Modified-Since`, `Vary`
- **보안/쿠키**
  - `Set-Cookie`(Secure, HttpOnly, SameSite), `Cookie`, `Authorization`, `WWW-Authenticate`, `Strict-Transport-Security`
- **범위 전송**
  - `Range: bytes=0-1023` ↔ `206 Partial Content`, `Content-Range`

### 3.4 청크(Chunked) 인코딩 예시(스트리밍/길이 미지)
```
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Content-Type: text/plain

B\r\n
Hello World\r\n
0\r\n
\r\n
```
- 16진수 길이 `B(=11)` → 본문 → 마지막 `0` 청크로 종료

### 3.5 버전별 특징
- **HTTP/1.1**: 기본 keep-alive, 파이프라이닝(현실에선 제한)
- **HTTP/2**: 하나의 TCP 연결에서 **멀티플렉싱**, HPACK 헤더 압축, 서버 푸시(사양 유지·권장 축소)
- **HTTP/3(QUIC)**: UDP 기반 전송 + TLS 1.3, 연결이동/핸드셰이크 지연↓, HOL 블로킹 해소

---

## 4) 웹 캐싱·압축·국제화

### 4.1 캐시 전략
- **강한 캐시**: `Cache-Control: max-age=...`(만료 전 재검사 없음)
- **재검사**: `ETag`/`If-None-Match` 또는 `Last-Modified`/`If-Modified-Since`
- **무효화**: 배포 시 **파일 지문(versioning)**: `app.7f3a8.css` + `Cache-Control: immutable`

### 4.2 압축
- 요청: `Accept-Encoding: gzip, br`  
- 응답: `Content-Encoding: br`  
- **주의**: 바이너리(이미지/영상)는 이미 압축 → 재압축 비효율

### 4.3 국제화/문자셋
- `Content-Type: text/html; charset=UTF-8`
- HTML 메타도 병행: `<meta charset="utf-8">`

---

## 5) 상태·세션·보안

### 5.1 쿠키와 세션
- 서버 → 클라:  
  ```
  Set-Cookie: sid=abc...; Path=/; Secure; HttpOnly; SameSite=Lax; Max-Age=3600
  ```
- 클라 → 서버:
  ```
  Cookie: sid=abc...
  ```
- 세션 저장소: 메모리/Redis/DB, 또는 **JWT**(서명 기반 토큰; 쿠키나 Authorization 헤더로 전달)

### 5.2 CORS & 동일 출처 정책(SOP)
- SOP: 스크립트는 기본적으로 **같은 origin**(scheme+host+port)만 접근
- CORS 허용 응답 헤더(서버):
  ```
  Access-Control-Allow-Origin: https://app.example.com
  Access-Control-Allow-Credentials: true
  Access-Control-Allow-Methods: GET,POST,OPTIONS
  Access-Control-Allow-Headers: Content-Type, Authorization
  ```

### 5.3 TLS(HTTPS) 한 줄 요약
- **암호화/무결성/서버 인증** 확보
- HSTS: `Strict-Transport-Security: max-age=...; includeSubDomains`

---

## 6) 동적 컨텐츠 처리(서버 내부의 일)

### 6.1 CGI (Common Gateway Interface)
- **요청마다 프로세스 실행** → 표준입력/환경변수로 전달, 표준출력으로 응답
- 간단하지만 **프로세스 생성 비용↑**

**예: C CGI(쿼리 파싱 후 HTML 출력)**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    const char* qs = getenv("QUERY_STRING"); // 예: "x=2&y=3"
    int x=0,y=0;
    if (qs) sscanf(qs, "x=%d&y=%d", &x, &y);

    printf("Content-Type: text/html; charset=UTF-8\r\n\r\n");
    printf("<html><body><h1>%d + %d = %d</h1></body></html>\n", x, y, x+y);
    return 0;
}
```

### 6.2 FastCGI/SCGI
- **상주 프로세스** 유지(프로세스 풀) → 소켓으로 웹서버와 통신  
- Nginx + php-fpm(=FastCGI) 같은 조합이 대표적

### 6.3 언어별 인터페이스
- **WSGI**(Python), **Rack**(Ruby), **PSGI**(Perl), **ASGI**(Python async), **Servlet**/JSP(Java)
- 프레임워크가 **라우팅 → 미들웨어 → 컨트롤러 → 뷰(템플릿) → 응답** 파이프라인 구성

### 6.4 리버스 프록시 & 애플리케이션 서버
- **웹 서버(Nginx/Apache)**: 정적/SSL/리버스프록시/로드밸런싱  
- **애플리케이션 서버(uWSGI, Gunicorn, Unicorn, Passenger, Node 런타임)**: 동적 처리
- **장점**: 보안/성능/스케일 아웃, **프로세스·스레드 풀**로 동시성 향상

---

## 7) HTTP 트랜잭션 단계별 상세 타임라인

1. **DNS**: `A/AAAA` 조회(브라우저/OS 캐시, DNS 캐시, DoH/DoT 가능)  
2. **연결**: TCP SYN/ACK(HTTP/2라면 하나의 연결로 멀티 리소스), TLS 1.3 1-RTT/0-RTT  
3. **요청 전송**: 헤더 + (필요 시) 바디(Expect: 100-continue 활용 가능)  
4. **서버 라우팅**: 가상호스트, 경로→핸들러 매핑, 정적/동적 분기  
5. **동적 처리**: 인증/권한 → 캐시 조회 → DB/서비스 호출 → 렌더링  
6. **응답 생성**: 상태코드, 헤더(캐시/콘텐츠/보안), 바디  
7. **전송 최적화**: 체킹(`ETag/304`), 압축, 청크/스트림, Range/부분응답  
8. **연결 재사용/종료**: keep-alive 타임아웃, HTTP/2 스트림 종료, HTTP/3 스트림 FIN

---

## 8) 실용 스니펫(빠른 실험용)

### 8.1 `curl`로 트랜잭션 관찰
```bash
# 헤더만 보기
curl -I https://example.com

# 상세 핸드셰이크/타이밍
curl -w "@- " -o /dev/null -s https://example.com <<'EOF'
  dns:%{time_namelookup} connect:%{time_connect} tls:%{time_appconnect}
  ttfb:%{time_starttransfer} total:%{time_total} size:%{size_download}\n
EOF
```

### 8.2 파이썬: 최소 정적 서버(HTTP/1.1, 단일 스레드)
```python
from http.server import SimpleHTTPRequestHandler, HTTPServer
HTTPServer(('0.0.0.0', 8000), SimpleHTTPRequestHandler).serve_forever()
```

### 8.3 파이썬: 초간단 동적 라우팅
```python
from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import parse_qs, urlparse

class App(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path.startswith("/add"):
            qs = parse_qs(urlparse(self.path).query)
            x = int(qs.get('x',[0])[0]); y = int(qs.get('y',[0])[0])
            body = f"<h1>{x}+{y}={x+y}</h1>".encode()
            self.send_response(200)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self.send_header("Content-Length", str(len(body)))
            self.end_headers()
            self.wfile.write(body)
        else:
            self.send_response(404); self.end_headers()

HTTPServer(('0.0.0.0', 8001), App).serve_forever()
```

---

## 9) 성능·확장·신뢰성 핀포인트

- **커넥션 관리**: keep-alive, HTTP/2/3, 백엔드 풀(스레드/프로세스), 커넥션 한도
- **캐시 계층**: CDN → 리버스 프록시 캐시(Nginx/ATS/Varnish) → 앱 캐시(메모리/Redis)
- **압축/이미지 최적화**: br/avif/webp, `Accept-*` 기반 협상
- **보안 헤더**: `HSTS`, `X-Content-Type-Options: nosniff`, `Content-Security-Policy`, `Referrer-Policy`
- **관찰성**: 구조화 로그, 분산 트레이싱(Traceparent), 메트릭(한도·에러율·백로그)
- **오류 복원**: Circuit Breaker, 재시도/backoff, 제한(429), 정적 폴백

---

## 10) 체크리스트(현업용)

- [ ] **정적/동적** 경로 분리, 캐시 정책 명시  
- [ ] `Content-Type`/`charset`/`Content-Length or chunked` 정확  
- [ ] 조건부 요청(ETag/Last-Modified) 지원  
- [ ] 압축/국제화/언어 협상 고려  
- [ ] 세션/쿠키 보안 속성(Secure/HttpOnly/SameSite) 설정  
- [ ] CORS 정책 명확화(필요 최소)  
- [ ] HTTPS/TLS 강제(HSTS), 최신 프로토콜(HTTP/2/3) 점진 도입  
- [ ] 로깅/모니터링/트레이싱 배선

---

## 11) 한 줄 결론
웹은 **HTTP 트랜잭션**이라는 표준화된 교환 규약 위에, **정적 파일**과 **동적 계산**을 섞어 전달하는 시스템입니다.  
URL→DNS→연결(TCP/TLS)→요청→라우팅→정적/동적→응답→캐시/압축의 **일관된 파이프라인**을 이해하면,  
프런트엔드·백엔드·인프라 어디서든 **예측 가능하고 빠르며 안전한** 서비스를 설계할 수 있습니다.