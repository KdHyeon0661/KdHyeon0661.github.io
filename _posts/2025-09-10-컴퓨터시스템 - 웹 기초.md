---
layout: post
title: 컴퓨터시스템 - 웹 기초
date: 2025-09-10 15:20:23 +0900
category: 컴퓨터시스템
---
# 웹 기초 ↔ 웹 컨텐츠 ↔ HTTP 트랜잭션 ↔ 동적 컨텐츠 처리

## → HTTP 요청/응답 → 렌더/캐시 → 재사용/종료”

아래 표는 한 번의 네비게이션이 지나가는 **핵심 단계**를 축약한 것이다.

| 단계 | 핵심 컴포넌트 | 구현/프로토콜 포인트 |
|---|---|---|
| 1. 주소 해석 | URL/URI | `scheme://user:pass@host:port/path?query#frag` |
| 2. 이름 → IP | DNS(A/AAAA, CNAME), DoH/DoT | 브라우저/OS/DNS 캐시, EDNS Client Subnet(캐시 로케이션 최적화) |
| 3. 연결 | TCP 3-way, TLS 1.3, QUIC(HTTP/3) | HTTP/2: 단일 TCP 멀티플렉싱 / HTTP/3: UDP+TLS, 연결이동, HOL 해소 |
| 4. 요청 전송 | HTTP/1.1·2·3 | 메서드/경로/헤더/바디, `Host`, `Content-Length` 또는 `chunked` |
| 5. 서버 라우팅 | 가상호스트, 리버스 프록시 | 정적/동적 분기, 백엔드(WSGI/ASGI, Servlet, Node 등) |
| 6. 동적 처리 | 인증/권한/캐시/DB/렌더 | 템플릿, JSON API, 캐시 계층, 비즈니스 로직 |
| 7. 응답 전송 | 상태코드/헤더/바디 | `Cache-Control/ETag/Last-Modified`, `Content-Encoding`, `Vary` |
| 8. 재사용/종료 | Keep-Alive, H2/H3 스트림 | 커넥션/스트림 정리, `Connection: close`, idle timeout |

---

## 웹 기초: 주소·이름·연결

### URL/URI 구조

```
scheme://user:pass@host:port/path?query#fragment
예) https://example.com:443/articles/42?print=1#comments
```

- **scheme**: `http`, `https`, `ws`, `wss`, `ftp` …
- **host**: 도메인(예 `www.example.com`) 또는 IP(IPv4/IPv6)
- **port**: 기본포트 생략 가능(HTTP=80, HTTPS=443)
- **path/query**: 리소스 경로 + 파라미터
- **fragment**: **클라이언트 전용**(#이후는 서버로 전송되지 않음)

### 이름 해석과 연결

1) **DNS 조회**: 브라우저/OS 캐시 → 재귀 DNS → 권한 DNS
2) **연결 수립**
   - HTTP/1.1, HTTP/2: **TCP** (3-way)
   - HTTPS: **TLS 1.3**(서버 인증서 검증, ALPN으로 H1/H2/H3 결정)
   - HTTP/3: **QUIC(UDP 기반)** + TLS 1.3 내장, **연결 이동**/HOL 해소, 빠른 핸드셰이크
3) **요청/응답 교환** → (가능 시) **연결 재사용**
   - H1: keep-alive
   - H2: 단일 TCP 연결에서 **멀티플렉스 스트림**
   - H3: UDP 기반 스트림(손실에도 스트림 독립)

---

## 웹 컨텐츠: 정적·동적·하이브리드

### 정적 컨텐츠(Static)

- **파일 그대로 전송**: HTML, CSS, JS, 이미지, 폰트, 동영상 등
- 강점: **캐시/CDN 친화**, 예측 가능, `sendfile`/`mmap`/zero-copy로 고성능
- 최적화: `Cache-Control`, `ETag`, `Last-Modified`, `Content-Encoding: gzip/br`, `Vary`, `Accept-*`

### 동적 컨텐츠(Dynamic)

- **요청마다 생성**: 템플릿 렌더, DB 조회, 사용자 맞춤, API(JSON)
- 인터페이스: CGI(구식), **FastCGI/php-fpm**, **WSGI/ASGI(Python)**, **Rack(Ruby)**, **Servlet(Java)**, **Node(Express)**
- 트레이드오프: 유연성 ↔ 계산/DB 비용 → **캐시(메모리/Redis)**, **템플릿 프리컴파일**, **쿼리 튜닝**

### 현대 패턴

- **SSR(Server-Side Rendering)**: 초기 HTML 서버 렌더 → CSR로 상호작용 보강
- **SPA(Client-Side)**: JS 앱이 API 호출, 초기 페인트 최적화 필요
- **SSG(Static Site Generation)**: 빌드 시 생성 + 동적 일부만 API
- **Edge Functions/CDN Workers**: 경계에서 **경량 동적** 처리, `Vary`/`cache key` 주의

---

## HTTP 트랜잭션: 요청 ↔ 응답 구조

### 요청(Request)

```
<METHOD> <REQUEST-TARGET> HTTP/1.1\r\n
Host: example.com\r\n
Header-Name: value\r\n
...\r\n
\r\n
[optional body]
```

- **메서드**: `GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `OPTIONS`
  - **안전(safe)**: `GET`, `HEAD` (서버 상태 변경 X)
  - **멱등(idempotent)**: `PUT`, `DELETE` 등(같은 요청 반복해도 결과 동일)
- **Host**: H1.1에서 필수(가상호스팅)

**예: GET(조건부 요청)**

```
GET /images/logo.png HTTP/1.1
Host: www.example.com
Accept: image/avif,image/webp,*/*
If-None-Match: "abc123"
```

**예: POST(JSON)**

```
POST /api/todo HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 27

{"title":"buy milk","done":false}
```

### 응답(Response)

```
HTTP/1.1 <STATUS-CODE> <REASON>\r\n
Header-Name: value\r\n
...\r\n
\r\n
[optional body]
```

- **주요 상태 코드**
  - 2xx: `200 OK`, `201 Created`, `204 No Content`
  - 3xx: `301/308`(영구), `302/303/307`(임시)
  - 4xx: `400`, `401`, `403`, `404`, `409`, `429`
  - 5xx: `500`, `502`, `503`, `504`

**예: 304 Not Modified**

```
HTTP/1.1 304 Not Modified
ETag: "abc123"
```

### 핵심 헤더(실무 관점)

- **프레이밍/연결**: `Content-Length`, `Transfer-Encoding: chunked`, `Connection`, `Trailer`
- **콘텐츠 협상**: `Accept`, `Accept-Language`, `Accept-Encoding(gzip, br)`, `Content-Type`
- **캐시**: `Cache-Control(public, private, max-age, s-maxage, no-store, no-cache, stale-while-revalidate, stale-if-error)`, `ETag`, `Last-Modified`, `Vary`
- **보안/쿠키**: `Set-Cookie`(Secure, HttpOnly, SameSite), `Cookie`, `Authorization`, `WWW-Authenticate`, `Strict-Transport-Security`
- **범위 전송**: `Range` ↔ `206 Partial Content`, `Content-Range`

### 청크 인코딩(길이 미지/스트리밍)

```
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Content-Type: text/plain

B\r\n
Hello World\r\n
0\r\n
\r\n
```

### H1/H2/H3 비교

| 항목 | HTTP/1.1 | HTTP/2 | HTTP/3 |
|---|---|---|---|
| 전송 | TCP | TCP | QUIC(UDP) |
| 멀티플렉싱 | 제한(파이프라이닝 문제) | **스트림 멀티플렉싱** | **스트림 멀티플렉싱**(패킷 손실에도 스트림 독립) |
| 헤더 | 텍스트 | HPACK(압축) | QPACK(HTTP/3용) |
| 서버 푸시 | 비권장(사양 유지) | 사양 존재(브라우저 지원 축소) | 유사(대부분 비권장) |
| HOL 블로킹 | 큼 | TCP 레벨에서 존재 | **완화(스트림 독립)** |

---

## 캐싱·압축·국제화

### 캐시 전략

- **강한 캐시**: `Cache-Control: max-age=31536000, immutable` + **파일 지문**(`app.7f3a8.css`)
- **재검사**: `ETag`/`If-None-Match`, `Last-Modified`/`If-Modified-Since`
- **프락시/공용 캐시**: `s-maxage`, `stale-while-revalidate`, `stale-if-error`
- **변이 키**: `Vary: Accept-Encoding, Accept`(협상 헤더와 함께 써야 캐시 오염 방지)

### 압축

- 요청: `Accept-Encoding: gzip, br`
- 응답: `Content-Encoding: br` (텍스트/JSON/HTML/CSS/JS에 효과적)
- **이미지/영상은 재압축 비권장**(이미 자체 포맷 압축)

### 국제화

- `Content-Type: text/html; charset=UTF-8` + `<meta charset="utf-8">`
- 언어 협상: `Accept-Language: ko, en;q=0.8`

---

## 상태·세션·보안

### 쿠키·세션

- 서버 → 클라:

```
Set-Cookie: sid=abc...; Path=/; Secure; HttpOnly; SameSite=Lax; Max-Age=3600
```

- 클라 → 서버:

```
Cookie: sid=abc...
```

- **SameSite**: 크로스사이트 전송 기본 제한 강화(Lax 기본).
  크로스사이트 필요 시 **`SameSite=None; Secure`** 필수.
- 세션 저장: 메모리/Redis/DB or **JWT**(서명/만료 관리, 회수 전략 주의)

### SOP & CORS

- **동일 출처 정책(SOP)**: 스크립트는 **origin**(scheme+host+port) 일치에만 접근
- **CORS 응답 예**:

```
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: GET,POST,OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization
Vary: Origin
```

### TLS(HSTS 포함)

- HTTPS는 **암호화/무결성/서버 인증** 제공.
- **HSTS**:

```
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

- 최신 설정은 TLS 1.3 중심, 취약 스위트 비활성화, ALPN으로 H2/H3 협상.

---

## 동적 컨텐츠 처리(서버 내부)

### CGI → FastCGI/SCGI

- **CGI**: 요청마다 **프로세스 생성** → 표준입력/환경변수, 출력으로 응답(간단하지만 비용↑)
- **FastCGI**: 상주 프로세스/풀(php-fpm 등), 웹서버와 **소켓 통신** → 고성능

**CGI 예(C, 쿼리 파싱 후 HTML)**

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    const char* qs = getenv("QUERY_STRING"); // "x=2&y=3"
    int x=0,y=0; if (qs) sscanf(qs, "x=%d&y=%d", &x, &y);

    printf("Content-Type: text/html; charset=UTF-8\r\n\r\n");
    printf("<html><body><h1>%d + %d = %d</h1></body></html>\n", x, y, x+y);
    return 0;
}
```

### 언어별 런타임 인터페이스

- **WSGI/ASGI(Python)**, **Rack(Ruby)**, **PSGI(Perl)**, **Servlet(Java)**, **Node(Express/Fastify)**
- 파이프라인: **라우팅 → 미들웨어(로깅/CORS/auth) → 핸들러 → 뷰/JSON → 응답**

**ASGI(uvicorn/Starlette) 초간단 예**

```python
# asgi_app.py

async def app(scope, receive, send):
    assert scope["type"] == "http"
    body = b'{"hello":"world"}'
    await send({"type":"http.response.start","status":200,
                "headers":[(b"content-type", b"application/json")]})
    await send({"type":"http.response.body","body": body})
```

```bash
uvicorn asgi_app:app --host 0.0.0.0 --port 8000
```

### 리버스 프록시(정석 구조)

- **Nginx/Apache**: TLS 종료, 정적 캐시/압축, 리버스 프록시/로드밸런싱
- **애플리케이션 서버**: uWSGI/Gunicorn(WSGI), uvicorn(ASGI), php-fpm(FastCGI), Node 런타임 등

**Nginx → uvicorn 프록시 예**

```nginx
server {
  listen 443 ssl http2;
  server_name api.example.com;

  # TLS 설정(HSTS는 서버 블록 또는 상단 공통에)
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

  location / {
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_pass http://127.0.0.1:8000;
  }
}
```

---

## HTTP 트랜잭션 단계별 상세 타임라인

1) **DNS**: A/AAAA, 캐시/프리페치, DoH/DoT 가능
2) **연결 수립**:
   - TCP: SYN→SYN/ACK→ACK
   - TLS 1.3: **1-RTT**(키 교환/서버 인증서/ALPN), 조건에 따라 0-RTT(재전송/재주입 취약 주의)
   - QUIC: 핸드셰이크 내장, **연결 ID**로 네트워크 변경에도 세션 유지
3) **요청 송신**: `Expect: 100-continue`로 바디 큰 경우 최적화 가능
4) **서버 라우팅**: 가상호스트 → 경로/메서드 매핑 → **정적/동적 분기**
5) **동적 처리**: 인증/세션 → 캐시 조회 → DB/서비스 → 렌더/직렬화(JSON)
6) **응답 생성**: 상태/헤더/바디, 압축·청크·범위전송
7) **전송 최적화**: H2/H3 멀티플렉싱, 우선순위(실서버별 정책 상이)
8) **재사용/종료**: keep-alive 타임아웃, 스트림 FIN, 커넥션 close

---

## 실전 스니펫: 관측·도구·미니 서버

### `curl` 관찰

```bash
# 헤더만 확인

curl -I https://example.com

# 타이밍 지표 출력

curl -w "@- " -o /dev/null -s https://example.com <<'EOF'
 dns:%{time_namelookup} connect:%{time_connect} tls:%{time_appconnect} \
 ttfb:%{time_starttransfer} total:%{time_total} size:%{size_download}\n
EOF
```

### 파이썬: 최소 정적 서버(학습용)

```python
from http.server import SimpleHTTPRequestHandler, HTTPServer
HTTPServer(("0.0.0.0", 8000), SimpleHTTPRequestHandler).serve_forever()
```

### Node(Express): JSON API + 캐시 헤더

```javascript
const express = require("express");
const app = express();
app.get("/api/time", (req,res)=>{
  res.set("Cache-Control","no-store");
  res.json({ now: new Date().toISOString() });
});
app.listen(8080);
```

### — Nginx

```nginx
location /video/ {
  types { video/mp4 mp4; }
  # Nginx는 기본적으로 Range 지원, 큰 파일 전송 최적화는 sendfile/open_file_cache 사용
  sendfile on;
}
```

---

## 성능·확장·신뢰성 포인트

### 커넥션 관리

- **Keep-Alive**: 재사용으로 핸드셰이크 비용 절감
- **동시성 제어**: 백엔드 풀(프로세스/스레드 수), 큐 한도, 타임아웃(헤더/바디/유휴)
- **HTTP/2/3**: 멀티플렉싱으로 **리소스 동시성** 향상(우선순위/흐름제어 정책 고려)

### 캐시 계층

- **CDN** → **리버스 프록시 캐시(Nginx/ATS/Varnish)** → **애플리케이션 캐시(메모리/Redis)**
- 캐시키/`Vary` 정확히, 쿠키와 캐시 상호작용 주의, **s-maxage**로 공용 캐시 제어

### 압축/이미지

- 텍스트에 `gzip`/`br`, 이미지 포맷(AVIF/WebP) 협상, **리사이즈/품질** 파이프라인(서버/에지)

### 보안 헤더/정책

- `HSTS`, `Content-Security-Policy`, `X-Content-Type-Options: nosniff`, `Referrer-Policy`
- 쿠키: `Secure; HttpOnly; SameSite` 기본 세팅

### 관찰성

- **구조화 로그**(trace id), **분산 트레이싱**(W3C Trace Context: `traceparent`), **메트릭**(QPS, 오류율, 백로그, p95 지연)
- 오류 복원: 재시도/backoff, 서킷브레이커, **stale-if-error** 폴백

---

## 안정성·취약점·한도

- **요청 스머글링(H1↔H2, CL vs TE 불일치)**: 프록시/백엔드 간 파싱 불일치 방지(엄격 파서/정책/헤더 정규화)
- **Host 헤더 주입**: 프록시에서 `proxy_set_header Host $host;` 지정 및 허용 도메인 화이트리스트
- **CRLF 인젝션**: 헤더 값 검증/인코딩
- **Slowloris/슬로우 POST**: 헤더/바디 읽기 타임아웃, 최소 전송률 제한
- **리소스 한도**: 요청 헤더 크기/바디 크기/오픈 파일 FD/워커 수

---

## 동적 처리—아키텍처 선택 가이드(요약)

| 상황 | 권장 구조 |
|---|---|
| 소형 정적/간단 API | 단일 H2/H3 서버(프레임워크 내장) |
| 이미지/대용량 정적 | CDN + Nginx(정적) + 애플리케이션 서버 분리 |
| 고QPS 읽기 API | CDN 캐시 + 프록시 캐시 + 백엔드 캐시 + DB 리드레플리카 |
| 복잡한 권한/트랜잭션 | 리버스프록시 + 앱 서버(스레드/이벤트) + DB/큐 |
| 글로벌 | Anycast CDN, 엣지 함수(저지연), 오리진 페일오버 |

---

## 프로토콜·코드 예시 모음

### H1 원시 요청/응답(학습용)

```
# 요청

GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: demo/1.0
Accept: text/html

# 응답

HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 15

Hello, Web World
```

### 조건부 요청 흐름(ETag)

```
# 1차 요청

GET /app.js HTTP/1.1
If-None-Match: "W/\"v7f3a8\""

# 캐시 유효

HTTP/1.1 304 Not Modified
ETag: W/"v7f3a8"
```

### Nginx 정적 + 캐시/압축

```nginx
server {
  listen 443 ssl http2;
  server_name static.example.com;

  gzip on; gzip_types text/plain text/css application/javascript application/json;
  brotli on; brotli_comp_level 5;

  location /assets/ {
    root /var/www;
    add_header Cache-Control "public, max-age=31536000, immutable";
    try_files $uri =404;
  }
}
```

### Express: ETag/Last-Modified 제어

```javascript
const express = require("express");
const app = express();
app.disable("etag"); // 프레임워크 기본 ETag를 끌 수도 있음
app.get("/data", (req,res)=>{
  const body = JSON.stringify({t: Date.now()});
  res.set("Content-Type","application/json");
  res.set("Cache-Control","no-store");
  res.send(body);
});
app.listen(8080);
```

---

## 범위 전송·다운로드 재개

- 요청:

```
Range: bytes=0-1048575
```

- 응답:

```
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1048575/5000000
Content-Length: 1048576
```

- **대용량** 파일은 `sendfile`, 커널 버퍼 튜닝, `X-Accel-Redirect`(Nginx 내부 리다이렉트) 등 활용.

---

## REST·RPC·GraphQL 간단 비교

| 항목 | REST(HTTP 자원) | RPC(gRPC/JSON-RPC) | GraphQL |
|---|---|---|---|
| 모델 | 리소스/표현 | 메서드 호출 | 질의 기반 스키마 |
| 전송 | HTTP 표준 동사 | HTTP/2+Protobuf(주: gRPC) | HTTP POST(일반적) |
| 장점 | 캐시·상태코드·간결 | IDL/강타입/스트리밍 | over/under-fetch 해결 |
| 주의 | 일관성 설계 | 브라우저 직접 접근 제약 | 캐시/보안/복잡성 |

---

## 체크리스트(현업용)

- [ ] **정적/동적** 경로 분리, 정적은 장기 캐시 + 파일 지문
- [ ] `Content-Type/charset`, `Content-Length`(또는 `chunked`) 정확
- [ ] 조건부 요청(ETag/Last-Modified)·범위 전송 지원
- [ ] 압축(gzip/br), 언어/인코딩 협상(`Vary`)
- [ ] 세션/쿠키 보안(`Secure; HttpOnly; SameSite`)
- [ ] CORS 정책 최소 허용, `Vary: Origin`
- [ ] HTTPS 강제(HSTS), 최신 프로토콜(H2/H3) 점진 도입
- [ ] 타임아웃/한도(헤더/바디/연결/동시성)
- [ ] 관찰성(구조화 로그, 트레이싱, 지표)
- [ ] 리버스 프록시/앱 서버 구성, 백엔드 풀/큐 역압

---

## 부록 A — 흔한 함정과 해법

- **부분 전송(읽기/쓰기)**: `read/write`/`send/recv`는 **요청 길이 전부 처리 보장 없음** → 루프 처리
- **`EINTR`**: 시그널로 중단 → 재시도
- **`EAGAIN/EWOULDBLOCK`**: 논블로킹 → 이벤트 대기
- **`SIGPIPE`**: 닫힌 피어로 쓰기 시 프로세스 종료 위험 → `MSG_NOSIGNAL` 또는 `SIGPIPE` 무시
- **Server Push**: 사양은 남았지만 **브라우저/서버 대부분 비권장** → **Early Hints(103)**, preconnect/preload를 활용
- **H2 우선순위**: 구현 간 상이, 실제 성능 이득은 제한적 → 리소스 자체 최적화가 우선

---

## 부록 B — 미니 에코 서버(학습용, C/epoll, H1만)

```c
// gcc -O2 -Wall -Wextra -o echo echo.c
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#define PORT 9000
#define MAXE 1024

static int nb(int fd){ int fl=fcntl(fd,F_GETFL); return fcntl(fd,F_SETFL,fl|O_NONBLOCK); }

int main(){
  int ls = socket(AF_INET6, SOCK_STREAM, 0);
  int on=1,v6only=0; setsockopt(ls,SOL_SOCKET,SO_REUSEADDR,&on,sizeof on);
  setsockopt(ls,IPPROTO_IPV6,IPV6_V6ONLY,&v6only,sizeof v6only);
  struct sockaddr_in6 a={0}; a.sin6_family=AF_INET6; a.sin6_addr=in6addr_any; a.sin6_port=htons(PORT);
  bind(ls,(struct sockaddr*)&a,sizeof a); listen(ls,128); nb(ls);

  int ep=epoll_create1(0); struct epoll_event ev={.events=EPOLLIN,.data.fd=ls}; epoll_ctl(ep,EPOLL_CTL_ADD,ls,&ev);
  for(;;){
    struct epoll_event out[MAXE]; int n=epoll_wait(ep,out,MAXE,-1);
    for(int i=0;i<n;i++){
      int fd=out[i].data.fd;
      if (fd==ls){
        int c=accept4(ls,NULL,NULL,SOCK_NONBLOCK|SOCK_CLOEXEC);
        if (c>=0){ struct epoll_event evc={.events=EPOLLIN|EPOLLET,.data.fd=c}; epoll_ctl(ep,EPOLL_CTL_ADD,c,&evc); }
      }else if(out[i].events&EPOLLIN){
        char buf[4096]; for(;;){
          ssize_t r=read(fd,buf,sizeof buf);
          if (r>0){ ssize_t w=0; while(w<r){ ssize_t k=write(fd,buf+w,(size_t)(r-w)); if(k<0){ r=-1; break;} w+=k; } }
          if (r==0){ close(fd); break; }
          if (r<0){ if (errno==EAGAIN||errno==EWOULDBLOCK) break; close(fd); break; }
        }
      }
    }
  }
}
```

> 교육용으로 최소 구현만 담았다. 실제 서비스는 **타임아웃/백프레셔/에러로깅/헤더 파싱/HTTP 상태** 등을 추가해야 한다.

---

## 한 줄 결론

웹은 **HTTP 트랜잭션**이라는 표준 교환 규약 위에 **정적 파일**과 **동적 연산**을 섞어 전달하는 체계다.
**URL→DNS→연결(TCP/TLS/QUIC)→요청→라우팅→정적/동적→응답→캐시/압축**의 파이프라인을 정확히 이해하고,
캐시·보안·관찰성·성능(멀티플렉싱, 압축, 범위 전송)을 체계화하면, 프런트/백엔드/인프라 어디서든
**예측 가능하고 빠르며 안전한** 서비스를 설계·운영할 수 있다.
