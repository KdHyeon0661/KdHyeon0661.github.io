---
layout: post
title: 파이썬 심화 - 클래스와 객체 (7)
date: 2025-11-30 21:25:23 +0900
category: 파이썬 심화
---
# 클래스와 객체 (7)

## 순환 참조 자료구조에서의 메모리 관리

순환 참조(circular reference)는 두 개 이상의 객체가 서로를 참조할 때 발생하며, 파이썬의 참조 카운트 기반 가비지 컬렉션으로는 자동으로 해제되지 않을 수 있습니다. 이러한 상황을 효과적으로 관리하기 위한 여러 기법이 있습니다.

### 순환 참조의 문제 이해와 기본 해법

```python
def circular_reference_basics():
    """순환 참조의 기본 개념과 문제점"""
    
    print("=== 순환 참조 이해하기 ===")
    
    # 1. 순환 참조의 기본 예제
    print("1. 순환 참조 생성 예제:")
    
    class Node:
        """단순 연결 노드"""
        def __init__(self, value):
            self.value = value
            self.next = None
            print(f"  Node({value}) 생성됨")
        
        def __del__(self):
            print(f"  Node({self.value}) 삭제됨")
    
    # 순환 참조 생성
    node1 = Node(1)
    node2 = Node(2)
    node3 = Node(3)
    
    node1.next = node2
    node2.next = node3
    node3.next = node1  # 순환 참조 생성!
    
    print("  순환 참조가 생성되었습니다")
    
    # 명시적으로 참조 해제
    del node1
    del node2
    del node3
    
    print("  객체 참조는 해제되었지만, 순환 참조로 인해 메모리에서 즉시 삭제되지 않을 수 있습니다")
    
    # 2. 가비지 컬렉션 강제 실행
    print("\n2. 가비지 컬렉션 강제 실행:")
    
    import gc
    import sys
    
    class CircularExample:
        def __init__(self, name):
            self.name = name
            self.ref = None
            print(f"  CircularExample({name}) 생성됨")
        
        def __del__(self):
            print(f"  CircularExample({self.name}) 삭제됨")
    
    def create_circular_reference():
        """순환 참조를 생성하는 함수"""
        obj1 = CircularExample("객체1")
        obj2 = CircularExample("객체2")
        
        obj1.ref = obj2
        obj2.ref = obj1  # 순환 참조
        
        return obj1, obj2
    
    # 가비지 컬렉션 비활성화 (일시적)
    gc.disable()
    
    print("  가비지 컬렉션 비활성화 상태에서 순환 참조 생성")
    obj1, obj2 = create_circular_reference()
    
    print(f"  obj1 참조 카운트: {sys.getrefcount(obj1)}")
    print(f"  obj2 참조 카운트: {sys.getrefcount(obj2)}")
    
    # 명시적 참조 해제
    del obj1
    del obj2
    
    print("  명시적 참조 해제 후")
    
    # 가비지 컬렉션 활성화 및 실행
    gc.enable()
    collected = gc.collect()
    
    print(f"  가비지 컬렉션 실행: {collected}개의 객체 수집됨")
    
    # 3. weakref를 이용한 순환 참조 방지
    print("\n3. weakref를 이용한 약한 참조:")
    
    import weakref
    
    class TreeNode:
        """약한 참조를 사용하는 트리 노드"""
        def __init__(self, value):
            self.value = value
            self._parent = None  # 부모 노드 (약한 참조)
            self.children = []   # 자식 노드들
            print(f"  TreeNode({value}) 생성됨")
        
        @property
        def parent(self):
            """부모 노드 접근"""
            return self._parent() if self._parent else None
        
        @parent.setter
        def parent(self, node):
            """부모 노드 설정 (약한 참조로 저장)"""
            if node is None:
                self._parent = None
            else:
                self._parent = weakref.ref(node)
        
        def add_child(self, child):
            """자식 노드 추가"""
            child.parent = self
            self.children.append(child)
        
        def __del__(self):
            print(f"  TreeNode({self.value}) 삭제됨")
        
        def __repr__(self):
            parent_val = self.parent.value if self.parent else None
            return f"TreeNode(value={self.value}, parent={parent_val}, children={len(self.children)})"
    
    # 트리 구조 생성
    root = TreeNode("루트")
    child1 = TreeNode("자식1")
    child2 = TreeNode("자식2")
    
    root.add_child(child1)
    root.add_child(child2)
    
    grandchild = TreeNode("손자")
    child1.add_child(grandchild)
    
    print(f"  트리 구조:")
    print(f"    {root}")
    print(f"    {child1}")
    print(f"    {child2}")
    print(f"    {grandchild}")
    
    # 루트 참조 해제
    print("\n  루트 참조 해제 시도:")
    del root
    
    # 자식들은 여전히 참조 중
    print(f"  child1.parent: {child1.parent}")
    
    # 모든 참조 해제
    del child1
    del child2
    del grandchild
    
    print("  모든 참조 해제 완료")

circular_reference_basics()
```

### 고급 순환 참조 관리 기법

```python
def advanced_circular_reference_management():
    """고급 순환 참조 관리 기법"""
    
    print("\n=== 고급 순환 참조 관리 ===")
    
    # 1. 컨텍스트 관리자를 이용한 자동 정리
    print("1. 컨텍스트 관리자를 이용한 자동 정리:")
    
    class CyclicGraph:
        """순환 그래프 관리 클래스"""
        
        def __init__(self, name):
            self.name = name
            self.neighbors = []
            self._visited = False
            print(f"  CyclicGraph({name}) 생성됨")
        
        def add_neighbor(self, neighbor):
            """이웃 노드 추가"""
            if neighbor not in self.neighbors:
                self.neighbors.append(neighbor)
                neighbor.neighbors.append(self)  # 양방향 연결
        
        def break_cycles(self):
            """순환 참조 해제"""
            if self._visited:
                return
            
            self._visited = True
            for neighbor in self.neighbors[:]:  # 복사본으로 순회
                # 단방향 연결만 남기기
                if self in neighbor.neighbors:
                    neighbor.neighbors.remove(self)
                neighbor.break_cycles()
            
            self.neighbors.clear()
        
        def __enter__(self):
            return self
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            """컨텍스트 종료 시 순환 참조 정리"""
            self.break_cycles()
            print(f"  CyclicGraph({self.name}) 컨텍스트 종료, 순환 참조 정리됨")
        
        def __del__(self):
            print(f"  CyclicGraph({self.name}) 삭제됨")
    
    # 컨텍스트 관리자 사용 예제
    with CyclicGraph("A") as node_a:
        node_b = CyclicGraph("B")
        node_c = CyclicGraph("C")
        
        # 순환 그래프 생성
        node_a.add_neighbor(node_b)
        node_b.add_neighbor(node_c)
        node_c.add_neighbor(node_a)  # 순환 참조 생성
        
        print(f"  순환 그래프 생성 완료")
    
    print("  컨텍스트를 벗어나면 자동으로 순환 참조가 정리됩니다")
    
    # 2. 객체 풀 패턴을 이용한 메모리 관리
    print("\n2. 객체 풀 패턴:")
    
    class ObjectPool:
        """객체 풀을 관리하는 클래스"""
        
        def __init__(self, max_size=10):
            self.max_size = max_size
            self._pool = []
            self._in_use = set()
        
        def acquire(self):
            """객체 획득"""
            if self._pool:
                obj = self._pool.pop()
            else:
                if len(self._in_use) >= self.max_size:
                    raise RuntimeError("객체 풀이 가득 찼습니다")
                obj = self._create_object()
            
            self._in_use.add(id(obj))
            print(f"  객체 획득: {id(obj)} (사용 중: {len(self._in_use)}, 풀: {len(self._pool)})")
            return obj
        
        def release(self, obj):
            """객체 반환"""
            obj_id = id(obj)
            if obj_id in self._in_use:
                self._in_use.remove(obj_id)
                # 객체 재설정
                self._reset_object(obj)
                self._pool.append(obj)
                print(f"  객체 반환: {obj_id} (사용 중: {len(self._in_use)}, 풀: {len(self._pool)})")
            else:
                print(f"  경고: 관리되지 않는 객체 {obj_id}")
        
        def _create_object(self):
            """새 객체 생성"""
            obj = PooledObject()
            obj._pool = weakref.ref(self)  # 약한 참조로 풀 연결
            return obj
        
        def _reset_object(self, obj):
            """객체 상태 초기화"""
            obj.data = None
            obj.connections = []
        
        def __del__(self):
            """풀 삭제 시 모든 객체 정리"""
            print(f"  객체 풀 삭제, 총 객체 수: {len(self._pool) + len(self._in_use)}")
    
    class PooledObject:
        """풀에서 관리되는 객체"""
        
        def __init__(self):
            self.data = None
            self.connections = []
            self._pool = None
        
        def connect_to(self, other):
            """다른 객체 연결"""
            if other not in self.connections:
                self.connections.append(other)
                other.connections.append(self)  # 양방향 연결
        
        def release(self):
            """풀로 반환"""
            if self._pool:
                pool = self._pool()
                if pool:
                    pool.release(self)
        
        def __del__(self):
            print(f"  PooledObject({id(self)}) 삭제됨")
    
    # 객체 풀 사용 예제
    print("  객체 풀 생성 및 사용:")
    pool = ObjectPool(max_size=5)
    
    objects = []
    for i in range(3):
        obj = pool.acquire()
        obj.data = f"데이터{i}"
        objects.append(obj)
    
    # 객체들 간 연결 생성 (순환 참조 가능성)
    objects[0].connect_to(objects[1])
    objects[1].connect_to(objects[2])
    
    # 객체 반환
    for obj in objects:
        obj.release()
    
    print("  객체들이 풀로 반환되었습니다")
    
    # 3. 그래프 알고리즘을 활용한 순환 감지
    print("\n3. 그래프 알고리즘을 활용한 순환 감지:")
    
    class GraphNode:
        """그래프 노드 - 순환 감지 기능 포함"""
        
        def __init__(self, name):
            self.name = name
            self.edges = []
            self._id = id(self)
            print(f"  GraphNode({name}) 생성됨")
        
        def add_edge(self, node):
            """간선 추가"""
            if node not in self.edges:
                self.edges.append(node)
                print(f"    {self.name} -> {node.name} 간선 추가")
        
        def has_cycle(self, visited=None, recursion_stack=None):
            """순환 존재 여부 확인 (DFS 기반)"""
            if visited is None:
                visited = set()
            if recursion_stack is None:
                recursion_stack = set()
            
            visited.add(self._id)
            recursion_stack.add(self._id)
            
            for neighbor in self.edges:
                if neighbor._id not in visited:
                    if neighbor.has_cycle(visited, recursion_stack):
                        return True
                elif neighbor._id in recursion_stack:
                    # 순환 발견
                    return True
            
            recursion_stack.remove(self._id)
            return False
        
        def find_cycles(self):
            """모든 순환 찾기"""
            cycles = []
            visited = set()
            
            def dfs(node, path):
                node_id = node._id
                
                if node_id in path:
                    # 순환 발견
                    cycle_start = path.index(node_id)
                    cycle = path[cycle_start:] + [node_id]
                    cycles.append(cycle)
                    return
                
                if node_id in visited:
                    return
                
                visited.add(node_id)
                path.append(node_id)
                
                for neighbor in node.edges:
                    dfs(neighbor, path.copy())
            
            dfs(self, [])
            return cycles
        
        def break_all_cycles(self):
            """모든 순환 참조 제거"""
            cycles = self.find_cycles()
            
            for cycle in cycles:
                print(f"    순환 발견: {cycle}")
                # 간단히 첫 번째 간선 제거로 순환 깨기
                if len(cycle) > 1:
                    node1_id = cycle[0]
                    node2_id = cycle[1]
                    
                    # 실제 객체 찾기 (간단한 구현)
                    for node in [self] + self.edges:
                        if node._id == node1_id:
                            for edge in node.edges:
                                if edge._id == node2_id:
                                    node.edges.remove(edge)
                                    print(f"      간선 제거: {node1_id} -> {node2_id}")
                                    break
        
        def __del__(self):
            print(f"  GraphNode({self.name}) 삭제됨")
    
    # 순환 그래프 생성 및 감지
    print("  순환 그래프 생성:")
    nodes = []
    for i in range(4):
        nodes.append(GraphNode(f"Node{i}"))
    
    # 간선 추가 (순환 포함)
    nodes[0].add_edge(nodes[1])
    nodes[1].add_edge(nodes[2])
    nodes[2].add_edge(nodes[3])
    nodes[3].add_edge(nodes[0])  # 순환 생성
    nodes[2].add_edge(nodes[0])  # 추가 순환
    
    # 순환 감지
    print(f"\n  순환 존재 여부: {nodes[0].has_cycle()}")
    
    cycles = nodes[0].find_cycles()
    print(f"  발견된 순환 수: {len(cycles)}")
    
    # 순환 제거
    print("\n  순환 제거 실행:")
    nodes[0].break_all_cycles()
    
    # 순환 제거 확인
    print(f"  순환 제거 후 존재 여부: {nodes[0].has_cycle()}")

advanced_circular_reference_management()
```

### 실전: 복잡한 데이터 구조에서의 메모리 관리

```python
def practical_memory_management():
    """실전: 복잡한 데이터 구조에서의 메모리 관리"""
    
    print("\n=== 실전 메모리 관리 ===")
    
    # 1. 이중 연결 리스트(Doubly Linked List) 구현
    print("1. 이중 연결 리스트 구현 (약한 참조 활용):")
    
    import weakref
    
    class DoublyLinkedList:
        """약한 참조를 사용하는 이중 연결 리스트"""
        
        class Node:
            """내부 노드 클래스"""
            __slots__ = ['data', 'next', 'prev_ref']  # 메모리 최적화
            
            def __init__(self, data):
                self.data = data
                self.next = None
                self.prev_ref = None  # 약한 참조로 이전 노드 저장
            
            @property
            def prev(self):
                """이전 노드 접근"""
                return self.prev_ref() if self.prev_ref else None
            
            @prev.setter
            def prev(self, node):
                """이전 노드 설정 (약한 참조)"""
                if node is None:
                    self.prev_ref = None
                else:
                    self.prev_ref = weakref.ref(node)
            
            def __repr__(self):
                prev_data = self.prev.data if self.prev else None
                next_data = self.next.data if self.next else None
                return f"Node(data={self.data}, prev={prev_data}, next={next_data})"
        
        def __init__(self):
            self.head = None
            self.tail = None
            self._length = 0
            self._node_cache = weakref.WeakValueDictionary()  # 노드 캐시
        
        def append(self, data):
            """리스트 끝에 데이터 추가"""
            new_node = self.Node(data)
            node_id = id(new_node)
            self._node_cache[node_id] = new_node
            
            if not self.head:
                self.head = new_node
                self.tail = new_node
            else:
                new_node.prev = self.tail
                self.tail.next = new_node
                self.tail = new_node
            
            self._length += 1
            return new_node
        
        def prepend(self, data):
            """리스트 앞에 데이터 추가"""
            new_node = self.Node(data)
            node_id = id(new_node)
            self._node_cache[node_id] = new_node
            
            if not self.head:
                self.head = new_node
                self.tail = new_node
            else:
                new_node.next = self.head
                self.head.prev = new_node
                self.head = new_node
            
            self._length += 1
            return new_node
        
        def remove(self, node):
            """노드 제거"""
            if node.prev:
                node.prev.next = node.next
            else:
                self.head = node.next
            
            if node.next:
                node.next.prev = node.prev
            else:
                self.tail = node.prev
            
            # 명시적 참조 제거
            node.next = None
            node.prev = None
            
            self._length -= 1
        
        def clear(self):
            """리스트 비우기"""
            # 모든 참조를 명시적으로 제거
            current = self.head
            while current:
                next_node = current.next
                current.next = None
                current.prev = None
                current = next_node
            
            self.head = None
            self.tail = None
            self._length = 0
            self._node_cache.clear()
        
        def __len__(self):
            return self._length
        
        def __iter__(self):
            current = self.head
            while current:
                yield current.data
                current = current.next
        
        def __repr__(self):
            items = list(self)
            return f"DoublyLinkedList({items})"
    
    # 이중 연결 리스트 사용 예제
    dll = DoublyLinkedList()
    
    # 데이터 추가
    nodes = []
    for i in range(5):
        node = dll.append(f"데이터{i}")
        nodes.append(node)
    
    print(f"  리스트 생성: {dll}")
    print(f"  리스트 길이: {len(dll)}")
    
    # 노드 제거
    dll.remove(nodes[2])
    print(f"  중간 노드 제거 후: {list(dll)}")
    
    # 리스트 비우기
    dll.clear()
    print(f"  리스트 비운 후: {list(dll)}, 길이: {len(dll)}")
    
    # 2. 캐시 시스템에서의 메모리 관리
    print("\n2. 캐시 시스템 메모리 관리:")
    
    class SmartCache:
        """지능형 메모리 관리 캐시 시스템"""
        
        def __init__(self, max_size=100, cleanup_threshold=0.8):
            self.max_size = max_size
            self.cleanup_threshold = cleanup_threshold
            self._cache = {}
            self._access_count = {}
            self._size = 0
        
        def get(self, key):
            """캐시에서 데이터 가져오기"""
            if key in self._cache:
                # 접근 횟수 증가
                self._access_count[key] = self._access_count.get(key, 0) + 1
                
                # LRU(Least Recently Used) 정책: 접근 시간 업데이트
                value = self._cache[key]
                
                # 약한 참조 확인
                if isinstance(value, weakref.ref):
                    dereferenced = value()
                    if dereferenced is None:
                        # 참조가 끊어진 경우 제거
                        del self._cache[key]
                        del self._access_count[key]
                        self._size -= 1
                        return None
                    return dereferenced
                
                return value
            return None
        
        def set(self, key, value, use_weakref=False):
            """캐시에 데이터 저장"""
            # 메모리 정리 필요 여부 확인
            if self._size >= self.max_size * self.cleanup_threshold:
                self._cleanup()
            
            if use_weakref and hasattr(value, '__weakref__'):
                # 약한 참조로 저장
                value = weakref.ref(value)
            
            if key in self._cache:
                # 기존 값 교체
                old_value = self._cache[key]
                if isinstance(old_value, weakref.ref):
                    self._size -= 1  # 약한 참조는 크기 계산에서 제외
            else:
                self._size += 1
            
            self._cache[key] = value
            self._access_count[key] = self._access_count.get(key, 0) + 1
        
        def _cleanup(self):
            """캐시 정리"""
            print(f"  캐시 정리 실행 (현재 크기: {self._size}/{self.max_size})")
            
            # 1. 접근 횟수가 낮은 항목 제거
            sorted_items = sorted(
                self._access_count.items(),
                key=lambda x: x[1]
            )
            
            items_to_remove = sorted_items[:max(1, len(sorted_items) // 4)]  # 하위 25%
            
            for key, _ in items_to_remove:
                if key in self._cache:
                    del self._cache[key]
                    del self._access_count[key]
                    self._size -= 1
            
            # 2. 약한 참조가 끊어진 항목 제거
            keys_to_remove = []
            for key, value in self._cache.items():
                if isinstance(value, weakref.ref):
                    if value() is None:
                        keys_to_remove.append(key)
            
            for key in keys_to_remove:
                del self._cache[key]
                del self._access_count[key]
                self._size -= 1
            
            print(f"  정리 후 크기: {self._size}/{self.max_size}")
        
        def clear(self):
            """캐시 비우기"""
            self._cache.clear()
            self._access_count.clear()
            self._size = 0
        
        def get_stats(self):
            """캐시 통계"""
            weakref_count = sum(
                1 for v in self._cache.values() 
                if isinstance(v, weakref.ref)
            )
            
            return {
                'size': self._size,
                'max_size': self.max_size,
                'usage_percentage': (self._size / self.max_size) * 100,
                'weakref_count': weakref_count,
                'item_count': len(self._cache)
            }
    
    # 캐시 시스템 사용 예제
    print("  캐시 시스템 테스트:")
    cache = SmartCache(max_size=10, cleanup_threshold=0.7)
    
    class LargeData:
        def __init__(self, id, size=100):
            self.id = id
            self.data = [i for i in range(size)]
            print(f"    LargeData({id}) 생성됨")
        
        def __del__(self):
            print(f"    LargeData({self.id}) 삭제됨")
    
    # 데이터 캐싱
    for i in range(8):
        data = LargeData(i)
        cache.set(f"data{i}", data, use_weakref=(i % 2 == 0))  # 짝수는 약한 참조
    
    print(f"  캐시 통계: {cache.get_stats()}")
    
    # 일부 데이터 참조 해제
    print("  일부 데이터 참조 해제...")
    for i in [0, 2, 4]:
        cache.set(f"data{i}", None)
    
    # 캐시 접근 (정리 유발)
    for i in range(10, 15):
        cache.set(f"new_data{i}", f"value{i}")
    
    print(f"  최종 캐시 통계: {cache.get_stats()}")

practical_memory_management()
```

## 비교 연산을 지원하는 클래스 만들기

파이썬에서는 `__eq__`, `__lt__`, `__gt__` 등의 특수 메서드를 구현하여 객체의 비교 연산을 정의할 수 있습니다. `functools.total_ordering` 데코레이터를 사용하면 더 적은 메서드로 완전한 비교 연산을 구현할 수 있습니다.

### 기본 비교 연산 구현

```python
def comparison_operations_basics():
    """비교 연산의 기본 구현"""
    
    print("=== 비교 연산 기본 ===")
    
    # 1. 기본적인 비교 연산자 구현
    print("1. 기본 비교 연산자:")
    
    class Version:
        """버전 번호 비교 클래스"""
        
        def __init__(self, major, minor, patch=0):
            self.major = major
            self.minor = minor
            self.patch = patch
        
        # 문자열 표현
        def __repr__(self):
            return f"Version({self.major}.{self.minor}.{self.patch})"
        
        def __str__(self):
            return f"{self.major}.{self.minor}.{self.patch}"
        
        # 비교 연산자
        def __eq__(self, other):
            """동등 비교 =="""
            if not isinstance(other, Version):
                return NotImplemented
            return (self.major, self.minor, self.patch) == (
                other.major, other.minor, other.patch
            )
        
        def __lt__(self, other):
            """미만 비교 <"""
            if not isinstance(other, Version):
                return NotImplemented
            return (self.major, self.minor, self.patch) < (
                other.major, other.minor, other.patch
            )
        
        def __le__(self, other):
            """이하 비교 <="""
            return self == other or self < other
        
        # __gt__와 __ge__는 __lt__와 __le__로부터 유추 가능
        def __gt__(self, other):
            """초과 비교 >"""
            if not isinstance(other, Version):
                return NotImplemented
            return not (self <= other)
        
        def __ge__(self, other):
            """이상 비교 >="""
            if not isinstance(other, Version):
                return NotImplemented
            return not (self < other)
        
        # 해시 지원 (집합이나 딕셔너리 키로 사용 가능)
        def __hash__(self):
            return hash((self.major, self.minor, self.patch))
    
    # 버전 비교 테스트
    v1 = Version(1, 0, 0)
    v2 = Version(1, 1, 0)
    v3 = Version(2, 0, 0)
    
    print(f"  v1 = {v1}, v2 = {v2}, v3 = {v3}")
    print(f"  v1 == v2: {v1 == v2}")
    print(f"  v1 < v2: {v1 < v2}")
    print(f"  v1 <= v2: {v1 <= v2}")
    print(f"  v2 > v3: {v2 > v3}")
    print(f"  v3 >= v1: {v3 >= v1}")
    
    # 정렬 테스트
    versions = [v3, v1, v2]
    sorted_versions = sorted(versions)
    print(f"  정렬된 버전들: {sorted_versions}")
    
    # 집합 사용 (해시 가능해야 함)
    version_set = {v1, v2, v3}
    print(f"  버전 집합: {version_set}")
    
    # 2. functools.total_ordering 사용
    print("\n2. functools.total_ordering 사용:")
    
    from functools import total_ordering
    
    @total_ordering
    class Money:
        """통화 금액 비교 클래스"""
        
        def __init__(self, amount, currency="KRW"):
            self.amount = amount
            self.currency = currency
        
        def __repr__(self):
            return f"Money({self.amount}, '{self.currency}')"
        
        # total_ordering을 위해 __eq__와 __lt__만 구현하면 충분
        def __eq__(self, other):
            if not isinstance(other, Money):
                return NotImplemented
            return (self.amount, self.currency) == (other.amount, other.currency)
        
        def __lt__(self, other):
            if not isinstance(other, Money):
                return NotImplemented
            if self.currency != other.currency:
                raise ValueError("다른 통화는 비교할 수 없습니다")
            return self.amount < other.amount
        
        # __hash__도 구현하여 해시 가능하게
        def __hash__(self):
            return hash((self.amount, self.currency))
    
    m1 = Money(1000, "KRW")
    m2 = Money(2000, "KRW")
    m3 = Money(1000, "USD")
    
    print(f"  m1 = {m1}, m2 = {m2}, m3 = {m3}")
    print(f"  m1 == m2: {m1 == m2}")
    print(f"  m1 < m2: {m1 < m2}")
    print(f"  m1 <= m2: {m1 <= m2}")  # total_ordering이 자동 생성
    print(f"  m1 > m2: {m1 > m2}")    # total_ordering이 자동 생성
    print(f"  m1 >= m2: {m1 >= m2}")  # total_ordering이 자동 생성
    
    try:
        print(f"  m1 < m3: {m1 < m3}")  # 다른 통화 비교 시도
    except ValueError as e:
        print(f"  통화 비교 오류: {e}")
    
    # 3. 복합 비교 (여러 기준)
    print("\n3. 복합 비교 기준:")
    
    class Student:
        """여러 기준으로 비교 가능한 학생 클래스"""
        
        def __init__(self, name, score, age):
            self.name = name
            self.score = score
            self.age = age
        
        def __repr__(self):
            return f"Student('{self.name}', score={self.score}, age={self.age})"
        
        def __eq__(self, other):
            if not isinstance(other, Student):
                return NotImplemented
            return (self.name, self.score, self.age) == (
                other.name, other.score, other.age
            )
        
        def __lt__(self, other):
            """점수(내림차순), 나이(오름차순), 이름(오름차순) 순으로 비교"""
            if not isinstance(other, Student):
                return NotImplemented
            
            # 1. 점수 높은 순 (내림차순)
            if self.score != other.score:
                return self.score > other.score  # 점수가 높을수록 "작은" 것으로 처리
            
            # 2. 나이 어린 순 (오름차순)
            if self.age != other.age:
                return self.age < other.age
            
            # 3. 이름 사전순 (오름차순)
            return self.name < other.name
        
        def __hash__(self):
            return hash((self.name, self.score, self.age))
    
    students = [
        Student("김철수", 85, 20),
        Student("이영희", 90, 21),
        Student("박지원", 85, 19),
        Student("최민수", 90, 20),
    ]
    
    print("  학생들:")
    for student in students:
        print(f"    {student}")
    
    sorted_students = sorted(students)
    print("\n  정렬된 학생들 (점수 높은순 → 나이 어린순 → 이름순):")
    for student in sorted_students:
        print(f"    {student}")
    
    # 4. 사용자 정의 정렬 키
    print("\n4. 사용자 정의 정렬 키:")
    
    class SortableByMultiple:
        """다양한 방식으로 정렬 가능한 클래스"""
        
        def __init__(self, value, priority=0, timestamp=None):
            self.value = value
            self.priority = priority
            self.timestamp = timestamp or time.time()
        
        def __repr__(self):
            return f"SortableByMultiple(value={self.value}, priority={self.priority})"
        
        # 정렬 키 프로퍼티들
        @property
        def by_value(self):
            return self.value
        
        @property
        def by_priority(self):
            return self.priority
        
        @property
        def by_timestamp(self):
            return self.timestamp
        
        @property
        def by_length(self):
            return len(str(self.value))
        
        @property
        def by_priority_then_timestamp(self):
            """복합 정렬 키"""
            return (self.priority, self.timestamp)
    
    items = [
        SortableByMultiple("apple", priority=2),
        SortableByMultiple("banana", priority=1),
        SortableByMultiple("cherry", priority=3),
        SortableByMultiple("date", priority=2, timestamp=time.time()-1000),
    ]
    
    print("  다양한 정렬 방식:")
    print(f"    값 기준: {sorted(items, key=lambda x: x.by_value)}")
    print(f"    우선순위 기준: {sorted(items, key=lambda x: x.by_priority)}")
    print(f"    길이 기준: {sorted(items, key=lambda x: x.by_length)}")
    print(f"    우선순위 → 시간순: {sorted(items, key=lambda x: x.by_priority_then_timestamp)}")

comparison_operations_basics()
```

### 고급 비교 연산 패턴

```python
def advanced_comparison_patterns():
    """고급 비교 연산 패턴"""
    
    print("\n=== 고급 비교 연산 패턴 ===")
    
    # 1. 퍼지 비교(Fuzzy Comparison)
    print("1. 퍼지 비교 (Fuzzy Comparison):")
    
    class FuzzyNumber:
        """근사값 비교를 지원하는 숫자 클래스"""
        
        def __init__(self, value, tolerance=1e-9):
            self.value = value
            self.tolerance = tolerance
        
        def __repr__(self):
            return f"FuzzyNumber({self.value}, tolerance={self.tolerance})"
        
        def __eq__(self, other):
            """근사적 동등 비교"""
            if isinstance(other, FuzzyNumber):
                return abs(self.value - other.value) <= max(
                    self.tolerance, other.tolerance
                )
            elif isinstance(other, (int, float)):
                return abs(self.value - other) <= self.tolerance
            return NotImplemented
        
        def __lt__(self, other):
            """엄격한 작음 비교 (근사값 제외)"""
            if isinstance(other, FuzzyNumber):
                return self.value < other.value - max(
                    self.tolerance, other.tolerance
                )
            elif isinstance(other, (int, float)):
                return self.value < other - self.tolerance
            return NotImplemented
        
        def __hash__(self):
            """해시는 정확한 값을 사용"""
            return hash(self.value)
    
    # 퍼지 비교 테스트
    num1 = FuzzyNumber(1.0, tolerance=0.1)
    num2 = FuzzyNumber(1.05, tolerance=0.1)
    num3 = FuzzyNumber(1.2, tolerance=0.1)
    
    print(f"  num1 = {num1}")
    print(f"  num2 = {num2}")
    print(f"  num3 = {num3}")
    print(f"  num1 == num2 (퍼지): {num1 == num2}")
    print(f"  num1 == 1.05 (퍼지): {num1 == 1.05}")
    print(f"  num1 < num3 (엄격): {num1 < num3}")
    print(f"  num1 < 1.05 (엄격): {num1 < 1.05}")
    
    # 2. 다차원 비교
    print("\n2. 다차원 비교:")
    
    class Vector:
        """다차원 벡터 비교"""
        
        def __init__(self, *components):
            self.components = components
            self.dimension = len(components)
        
        def __repr__(self):
            return f"Vector{self.components}"
        
        def __eq__(self, other):
            """차원과 모든 성분이 일치해야 동등"""
            if not isinstance(other, Vector):
                return NotImplemented
            return (self.dimension == other.dimension and 
                    self.components == other.components)
        
        def __lt__(self, other):
            """사전식 비교 (lexicographical comparison)"""
            if not isinstance(other, Vector):
                return NotImplemented
            if self.dimension != other.dimension:
                raise ValueError("다른 차원의 벡터는 비교할 수 없습니다")
            
            return self.components < other.components
        
        def magnitude(self):
            """벡터의 크기"""
            import math
            return math.sqrt(sum(x**2 for x in self.components))
        
        @property
        def by_magnitude(self):
            """크기 기준 정렬 키"""
            return self.magnitude()
    
    vectors = [
        Vector(1, 2, 3),
        Vector(3, 2, 1),
        Vector(1, 1, 1),
        Vector(2, 2, 2),
    ]
    
    print("  벡터들:")
    for v in vectors:
        print(f"    {v} (크기: {v.magnitude():.2f})")
    
    print("\n  사전식 정렬:")
    for v in sorted(vectors):
        print(f"    {v}")
    
    print("\n  크기 기준 정렬:")
    for v in sorted(vectors, key=lambda x: x.by_magnitude):
        print(f"    {v} (크기: {v.magnitude():.2f})")
    
    # 3. 사용자 정의 비교 함수
    print("\n3. 사용자 정의 비교 함수:")
    
    class CustomComparable:
        """동적으로 비교 방법을 변경할 수 있는 클래스"""
        
        def __init__(self, value, compare_func=None):
            self.value = value
            self._compare_func = compare_func or self._default_compare
        
        def _default_compare(self, other):
            """기본 비교: 값의 길이"""
            if isinstance(other, CustomComparable):
                return len(self.value) - len(other.value)
            elif isinstance(other, str):
                return len(self.value) - len(other)
            return NotImplemented
        
        def set_compare_func(self, func):
            """비교 함수 설정"""
            self._compare_func = func
        
        # 비교 연산자 오버로딩
        def __eq__(self, other):
            result = self._compare_func(other)
            if result == 0:
                return True
            return False
        
        def __lt__(self, other):
            result = self._compare_func(other)
            if result is NotImplemented:
                return NotImplemented
            return result < 0
        
        def __le__(self, other):
            result = self._compare_func(other)
            if result is NotImplemented:
                return NotImplemented
            return result <= 0
        
        def __repr__(self):
            return f"CustomComparable('{self.value}')"
    
    items = [
        CustomComparable("apple"),
        CustomComparable("banana"),
        CustomComparable("cherry"),
        CustomComparable("date"),
    ]
    
    print("  기본 비교 (길이 기준):")
    for item in sorted(items):
        print(f"    {item}")
    
    # 비교 함수 변경
    print("\n  대소문자 무시 비교:")
    case_insensitive_compare = lambda self, other: (
        self.value.lower() < other.value.lower() if isinstance(other, CustomComparable) else NotImplemented
    )
    
    for item in items:
        item.set_compare_func(
            lambda other, self=item: case_insensitive_compare(self, other)
        )
    
    for item in sorted(items):
        print(f"    {item}")
    
    # 4. 비교 데코레이터
    print("\n4. 비교 데코레이터 패턴:")
    
    def comparable_by(*attributes):
        """지정된 속성들로 비교 가능하게 만드는 데코레이터"""
        def decorator(cls):
            # __eq__ 메서드 추가
            def eq_method(self, other):
                if not isinstance(other, cls):
                    return NotImplemented
                
                for attr in attributes:
                    if getattr(self, attr) != getattr(other, attr):
                        return False
                return True
            
            # __lt__ 메서드 추가
            def lt_method(self, other):
                if not isinstance(other, cls):
                    return NotImplemented
                
                for attr in attributes:
                    self_val = getattr(self, attr)
                    other_val = getattr(other, attr)
                    
                    if self_val != other_val:
                        return self_val < other_val
                
                return False  # 모든 속성이 같으면 작지 않음
            
            # 메서드 설정
            cls.__eq__ = eq_method
            cls.__lt__ = lt_method
            
            # 해시 메서드
            def hash_method(self):
                return hash(tuple(getattr(self, attr) for attr in attributes))
            
            cls.__hash__ = hash_method
            
            return cls
        return decorator
    
    @comparable_by('last_name', 'first_name', 'age')
    class Person:
        def __init__(self, first_name, last_name, age):
            self.first_name = first_name
            self.last_name = last_name
            self.age = age
        
        def __repr__(self):
            return f"Person({self.first_name} {self.last_name}, {self.age})"
    
    people = [
        Person("John", "Doe", 30),
        Person("Jane", "Doe", 25),
        Person("John", "Smith", 30),
        Person("John", "Doe", 25),
    ]
    
    print("  사람들 (성 → 이름 → 나이 순 정렬):")
    for person in sorted(people):
        print(f"    {person}")

advanced_comparison_patterns()
```

## 캐시 인스턴스 생성

객체 생성 비용이 높은 경우, 캐싱을 통해 동일한 파라미터로 생성된 객체를 재사용할 수 있습니다. 이는 메모리 사용량을 줄이고 성능을 향상시키는 데 도움이 됩니다.

### 기본적인 캐싱 패턴

```python
def caching_instances_basics():
    """캐시 인스턴스 생성 기본"""
    
    print("=== 캐시 인스턴스 생성 기본 ===")
    
    # 1. 단순한 클래스 레벨 캐시
    print("1. 클래스 레벨 캐시:")
    
    class CachedProduct:
        """생성된 인스턴스를 캐시하는 제품 클래스"""
        
        _cache = {}  # 클래스 변수로 캐시 저장
        
        def __new__(cls, product_id, name, price):
            # 생성자 호출 전에 캐시 확인
            cache_key = (product_id, name, price)
            
            if cache_key in cls._cache:
                print(f"  캐시 히트: {cache_key}")
                return cls._cache[cache_key]
            
            print(f"  캐시 미스: {cache_key}, 새로 생성")
            instance = super().__new__(cls)
            cls._cache[cache_key] = instance
            return instance
        
        def __init__(self, product_id, name, price):
            # __init__은 캐시 히트 시에도 호출되므로 주의 필요
            # 이미 초기화된 인스턴스인지 확인
            if not hasattr(self, '_initialized'):
                self.product_id = product_id
                self.name = name
                self.price = price
                self._initialized = True
                print(f"  인스턴스 초기화: {self}")
        
        def __repr__(self):
            return f"CachedProduct(id={self.product_id}, name={self.name}, price={self.price})"
        
        @classmethod
        def clear_cache(cls):
            """캐시 비우기"""
            cls._cache.clear()
            print("  캐시 비움")
    
    # 캐시 테스트
    print("  동일한 파라미터로 여러 번 생성:")
    p1 = CachedProduct(1, "노트북", 1500000)
    p2 = CachedProduct(1, "노트북", 1500000)  # 캐시에서 반환
    p3 = CachedProduct(2, "스마트폰", 800000)  # 새로 생성
    
    print(f"  p1 is p2: {p1 is p2}")  # 같은 객체
    print(f"  p1 is p3: {p1 is p3}")  # 다른 객체
    
    # 캐시 비우기
    CachedProduct.clear_cache()
    
    # 2. LRU 캐시 데코레이터 활용
    print("\n2. functools.lru_cache 사용:")
    
    from functools import lru_cache
    
    class ExpensiveObject:
        """생성 비용이 높은 객체"""
        
        def __init__(self, config):
            self.config = config
            print(f"  ExpensiveObject 생성 중... (config: {config})")
            time.sleep(0.1)  # 비용이 높은 초기화 시뮬레이션
        
        def process(self):
            return f"처리 완료: {self.config}"
        
        def __repr__(self):
            return f"ExpensiveObject(config={self.config})"
    
    class ExpensiveObjectFactory:
        """LRU 캐시를 사용하는 객체 팩토리"""
        
        @staticmethod
        @lru_cache(maxsize=3)
        def create(config):
            """캐시된 객체 생성"""
            return ExpensiveObject(config)
        
        @classmethod
        def cache_info(cls):
            """캐시 정보 출력"""
            return cls.create.cache_info()
    
    print("  LRU 캐시 테스트:")
    
    # 첫 번째 생성 (캐시 미스)
    obj1 = ExpensiveObjectFactory.create("config1")
    obj2 = ExpensiveObjectFactory.create("config2")
    obj3 = ExpensiveObjectFactory.create("config3")
    
    # 캐시 히트
    obj1_again = ExpensiveObjectFactory.create("config1")
    
    # 캐시 용량 초과 (config4 추가 시 가장 오래된 config1이 제거됨)
    obj4 = ExpensiveObjectFactory.create("config4")
    obj1_third = ExpensiveObjectFactory.create("config1")  # 다시 새로 생성
    
    print(f"  캐시 정보: {ExpensiveObjectFactory.cache_info()}")
    
    # 3. weakref를 사용한 캐시
    print("\n3. WeakValueDictionary를 사용한 캐시:")
    
    import weakref
    
    class WeakCachedObject:
        """약한 참조 캐시를 사용하는 객체"""
        
        _cache = weakref.WeakValueDictionary()
        
        def __new__(cls, key, data):
            if key in cls._cache:
                print(f"  캐시 히트: {key}")
                return cls._cache[key]
            
            print(f"  캐시 미스: {key}")
            instance = super().__new__(cls)
            cls._cache[key] = instance
            return instance
        
        def __init__(self, key, data):
            if not hasattr(self, '_initialized'):
                self.key = key
                self.data = data
                self._initialized = True
                print(f"  초기화: key={key}, data={data}")
        
        def __repr__(self):
            return f"WeakCachedObject(key={self.key}, data={self.data})"
        
        @classmethod
        def cache_size(cls):
            """캐시 크기"""
            return len(cls._cache)
    
    print("  약한 참조 캐시 테스트:")
    
    obj1 = WeakCachedObject("key1", "데이터1")
    obj2 = WeakCachedObject("key2", "데이터2")
    
    print(f"  캐시 크기: {WeakCachedObject.cache_size()}")
    
    # obj2 참조 해제
    del obj2
    
    # 가비지 컬렉션 실행
    import gc
    gc.collect()
    
    print(f"  obj2 삭제 후 캐시 크기: {WeakCachedObject.cache_size()}")
    
    # 여전히 캐시에 남아있는 obj1 접근
    obj1_again = WeakCachedObject("key1", "새데이터")  # 캐시 히트 (초기화되지 않음)
    print(f"  obj1_again: {obj1_again}")

caching_instances_basics()
```

### 고급 캐싱 패턴

```python
def advanced_caching_patterns():
    """고급 캐싱 패턴"""
    
    print("\n=== 고급 캐싱 패턴 ===")
    
    # 1. 시간 기반 캐시 (TTL)
    print("1. 시간 기반 캐시 (Time-to-Live):")
    
    class TTLCache:
        """TTL(Time-to-Live)을 지원하는 캐시"""
        
        def __init__(self, ttl_seconds=60):
            self.ttl = ttl_seconds
            self._cache = {}
            self._timestamps = {}
        
        def get(self, key):
            """캐시에서 값 가져오기"""
            if key in self._cache:
                timestamp = self._timestamps[key]
                if time.time() - timestamp < self.ttl:
                    print(f"  캐시 히트 (유효): {key}")
                    return self._cache[key]
                else:
                    print(f"  캐시 만료: {key}")
                    del self._cache[key]
                    del self._timestamps[key]
            
            return None
        
        def set(self, key, value):
            """캐시에 값 저장"""
            self._cache[key] = value
            self._timestamps[key] = time.time()
            print(f"  캐시 저장: {key}")
        
        def cleanup(self):
            """만료된 항목 정리"""
            current_time = time.time()
            keys_to_remove = []
            
            for key, timestamp in self._timestamps.items():
                if current_time - timestamp >= self.ttl:
                    keys_to_remove.append(key)
            
            for key in keys_to_remove:
                del self._cache[key]
                del self._timestamps[key]
            
            if keys_to_remove:
                print(f"  {len(keys_to_remove)}개의 만료된 항목 정리됨")
    
    class TTLCachedObject:
        """TTL 캐시를 사용하는 객체"""
        
        _cache = TTLCache(ttl_seconds=5)  # 5초 TTL
        
        def __new__(cls, key, value):
            # 캐시 확인
            cached = cls._cache.get(key)
            if cached is not None:
                return cached
            
            # 새 객체 생성
            print(f"  새 객체 생성: {key}")
            instance = super().__new__(cls)
            cls._cache.set(key, instance)
            return instance
        
        def __init__(self, key, value):
            if not hasattr(self, '_initialized'):
                self.key = key
                self.value = value
                self.created_at = time.time()
                self._initialized = True
        
        def __repr__(self):
            age = time.time() - self.created_at
            return f"TTLCachedObject(key={self.key}, value={self.value}, age={age:.1f}s)"
    
    print("  TTL 캐시 테스트:")
    
    obj1 = TTLCachedObject("key1", "값1")
    print(f"  생성 직후: {obj1}")
    
    # 바로 다시 접근 (캐시 히트)
    obj1_again = TTLCachedObject("key1", "값1")
    print(f"  캐시 히트: {obj1 is obj1_again}")
    
    print("  6초 대기 후...")
    time.sleep(6)
    
    # 만료 후 접근
    obj1_expired = TTLCachedObject("key1", "값1")
    print(f"  만료 후: {obj1_expired}")
    print(f"  새 객체인가? {obj1 is not obj1_expired}")
    
    # 2. 크기 제한 캐시 (Size-limited Cache)
    print("\n2. 크기 제한 캐시:")
    
    class SizeLimitedCache:
        """크기 제한이 있는 캐시"""
        
        def __init__(self, max_size=3):
            self.max_size = max_size
            self._cache = {}
            self._access_order = []  # LRU 구현을 위한 접근 순서
        
        def get(self, key):
            """캐시에서 값 가져오기"""
            if key in self._cache:
                # 접근 순서 업데이트 (가장 최근으로 이동)
                self._access_order.remove(key)
                self._access_order.append(key)
                print(f"  캐시 히트: {key}")
                return self._cache[key]
            return None
        
        def set(self, key, value):
            """캐시에 값 저장"""
            if key in self._cache:
                # 기존 키 업데이트
                self._cache[key] = value
                self._access_order.remove(key)
                self._access_order.append(key)
            else:
                # 새 키 추가
                if len(self._cache) >= self.max_size:
                    # 가장 오래된 항목 제거 (LRU)
                    oldest = self._access_order.pop(0)
                    del self._cache[oldest]
                    print(f"  LRU 제거: {oldest}")
                
                self._cache[key] = value
                self._access_order.append(key)
            
            print(f"  캐시 저장: {key} (크기: {len(self._cache)}/{self.max_size})")
        
        def clear(self):
            """캐시 비우기"""
            self._cache.clear()
            self._access_order.clear()
    
    class SizeCachedObject:
        """크기 제한 캐시를 사용하는 객체"""
        
        _cache = SizeLimitedCache(max_size=3)
        
        def __new__(cls, key, data):
            cached = cls._cache.get(key)
            if cached is not None:
                return cached
            
            instance = super().__new__(cls)
            cls._cache.set(key, instance)
            return instance
        
        def __init__(self, key, data):
            if not hasattr(self, '_initialized'):
                self.key = key
                self.data = data
                self._initialized = True
        
        def __repr__(self):
            return f"SizeCachedObject({self.key}, {self.data})"
    
    print("  크기 제한 캐시 테스트 (최대 3개):")
    
    objects = []
    for i in range(5):
        obj = SizeCachedObject(f"key{i}", f"data{i}")
        objects.append(obj)
        print(f"  생성: {obj}")
    
    # 첫 번째 객체에 다시 접근 (순서 업데이트)
    print(f"\n  key0 다시 접근:")
    obj0_again = SizeCachedObject("key0", "data0")
    
    # 새 객체 추가 (이제 key1이 제거될 것)
    print(f"\n  key5 추가:")
    obj5 = SizeCachedObject("key5", "data5")
    
    # 3. 계층적 캐시 (Hierarchical Cache)
    print("\n3. 계층적 캐시 (L1 + L2):")
    
    class HierarchicalCache:
        """계층적 캐시 시스템 (L1: 메모리, L2: 파일/DB 등)"""
        
        def __init__(self):
            self.l1_cache = {}  # 빠른 캐시 (메모리)
            self.l2_cache = {}  # 느린 캐시 (시뮬레이션)
            self.l1_hits = 0
            self.l2_hits = 0
            self.misses = 0
        
        def get(self, key):
            """캐시에서 값 가져오기"""
            # L1 캐시 확인
            if key in self.l1_cache:
                self.l1_hits += 1
                print(f"  L1 캐시 히트: {key}")
                return self.l1_cache[key]
            
            # L2 캐시 확인
            if key in self.l2_cache:
                self.l2_hits += 1
                print(f"  L2 캐시 히트: {key}")
                
                # L1 캐시로 승격
                value = self.l2_cache[key]
                self.l1_cache[key] = value
                
                return value
            
            self.misses += 1
            print(f"  캐시 미스: {key}")
            return None
        
        def set(self, key, value, level=1):
            """캐시에 값 저장"""
            if level >= 1:
                self.l1_cache[key] = value
            if level >= 2:
                self.l2_cache[key] = value
            
            print(f"  캐시 저장 (L{level}): {key}")
        
        def get_stats(self):
            """캐시 통계"""
            total = self.l1_hits + self.l2_hits + self.misses
            if total == 0:
                hit_rate = 0
            else:
                hit_rate = (self.l1_hits + self.l2_hits) / total * 100
            
            return {
                'l1_hits': self.l1_hits,
                'l2_hits': self.l2_hits,
                'misses': self.misses,
                'total': total,
                'hit_rate': f"{hit_rate:.1f}%",
                'l1_size': len(self.l1_cache),
                'l2_size': len(self.l2_cache),
            }
    
    class HierarchicalCachedObject:
        """계층적 캐시를 사용하는 객체"""
        
        _cache = HierarchicalCache()
        
        def __new__(cls, key, data, expensive=False):
            # 캐시 확인
            cached = cls._cache.get(key)
            if cached is not None:
                return cached
            
            # 새 객체 생성
            print(f"  새 객체 생성: {key}")
            instance = super().__new__(cls)
            
            # 비용이 높은 객체는 L2 캐시에 저장
            cache_level = 2 if expensive else 1
            cls._cache.set(key, instance, level=cache_level)
            
            return instance
        
        def __init__(self, key, data, expensive=False):
            if not hasattr(self, '_initialized'):
                self.key = key
                self.data = data
                self.expensive = expensive
                self._initialized = True
        
        def __repr__(self):
            return f"HierarchicalCachedObject({self.key}, {self.data})"
    
    print("  계층적 캐시 테스트:")
    
    # 일반 객체 (L1 캐시)
    obj1 = HierarchicalCachedObject("key1", "data1")
    obj1_again = HierarchicalCachedObject("key1", "data1")
    
    # 비용이 높은 객체 (L2 캐시)
    obj2 = HierarchicalCachedObject("key2", "data2", expensive=True)
    obj2_again = HierarchicalCachedObject("key2", "data2", expensive=True)
    
    # L1 캐시 비우기 (시뮬레이션)
    print("\n  L1 캐시 비우기 (시뮬레이션)...")
    HierarchicalCachedObject._cache.l1_cache.clear()
    
    # 다시 접근 (L2에서 L1으로 승격)
    obj1_third = HierarchicalCachedObject("key1", "data1")
    obj2_third = HierarchicalCachedObject("key2", "data2", expensive=True)
    
    print(f"\n  캐시 통계: {HierarchicalCachedObject._cache.get_stats()}")

advanced_caching_patterns()
```

### 실전: 완전한 캐싱 시스템 구현

```python
def practical_caching_system():
    """실전: 완전한 캐싱 시스템 구현"""
    
    print("\n=== 실전 캐싱 시스템 ===")
    
    # 1. 완전한 캐싱 시스템 클래스
    print("1. 완전한 캐싱 시스템:")
    
    class CompleteCacheSystem:
        """완전한 기능의 캐싱 시스템"""
        
        def __init__(self, max_size=100, ttl_seconds=3600, enable_stats=True):
            self.max_size = max_size
            self.ttl = ttl_seconds
            self.enable_stats = enable_stats
            
            self._cache = {}
            self._metadata = {}  # 메타데이터 저장
            self._lru_queue = []  # LRU 구현
            
            # 통계
            self.stats = {
                'hits': 0,
                'misses': 0,
                'evictions': 0,
                'expirations': 0,
                'total_requests': 0
            }
        
        def get(self, key):
            """캐시에서 값 가져오기"""
            self.stats['total_requests'] += 1
            
            if key in self._cache:
                metadata = self._metadata[key]
                
                # TTL 확인
                if time.time() - metadata['timestamp'] > self.ttl:
                    self._expire_key(key)
                    self.stats['misses'] += 1
                    self.stats['expirations'] += 1
                    return None
                
                # LRU 업데이트
                self._update_lru(key)
                
                self.stats['hits'] += 1
                return self._cache[key]
            
            self.stats['misses'] += 1
            return None
        
        def set(self, key, value, priority=1):
            """캐시에 값 저장"""
            # 공간이 필요하면 LRU 항목 제거
            while len(self._cache) >= self.max_size:
                self._evict_lru()
            
            # 캐시 저장
            self._cache[key] = value
            self._metadata[key] = {
                'timestamp': time.time(),
                'priority': priority,
                'size': self._estimate_size(value),
                'access_count': 0
            }
            
            # LRU 큐에 추가
            self._lru_queue.append(key)
        
        def delete(self, key):
            """캐시에서 항목 삭제"""
            if key in self._cache:
                del self._cache[key]
                del self._metadata[key]
                if key in self._lru_queue:
                    self._lru_queue.remove(key)
                return True
            return False
        
        def clear(self):
            """캐시 비우기"""
            self._cache.clear()
            self._metadata.clear()
            self._lru_queue.clear()
        
        def cleanup(self):
            """만료된 항목 정리"""
            current_time = time.time()
            expired_keys = []
            
            for key, metadata in self._metadata.items():
                if current_time - metadata['timestamp'] > self.ttl:
                    expired_keys.append(key)
            
            for key in expired_keys:
                self._expire_key(key)
            
            return len(expired_keys)
        
        def _update_lru(self, key):
            """LRU 순서 업데이트"""
            if key in self._lru_queue:
                self._lru_queue.remove(key)
            self._lru_queue.append(key)
            
            # 접근 카운트 증가
            self._metadata[key]['access_count'] += 1
        
        def _evict_lru(self):
            """LRU 항목 제거"""
            if self._lru_queue:
                key_to_evict = self._lru_queue.pop(0)
                del self._cache[key_to_evict]
                del self._metadata[key_to_evict]
                self.stats['evictions'] += 1
        
        def _expire_key(self, key):
            """만료된 키 제거"""
            self.delete(key)
        
        def _estimate_size(self, value):
            """값의 크기 추정"""
            import sys
            return sys.getsizeof(value)
        
        def get_info(self, key):
            """항목 정보 조회"""
            if key in self._cache:
                metadata = self._metadata[key].copy()
                metadata['age'] = time.time() - metadata['timestamp']
                metadata['is_expired'] = metadata['age'] > self.ttl
                return metadata
            return None
        
        def get_stats(self):
            """캐시 통계"""
            stats = self.stats.copy()
            
            if stats['total_requests'] > 0:
                stats['hit_rate'] = stats['hits'] / stats['total_requests'] * 100
            else:
                stats['hit_rate'] = 0
            
            stats['current_size'] = len(self._cache)
            stats['max_size'] = self.max_size
            stats['usage_percentage'] = len(self._cache) / self.max_size * 100
            
            return stats
    
    # 캐싱 시스템 사용 예제
    cache_system = CompleteCacheSystem(max_size=5, ttl_seconds=10)
    
    print("  캐싱 시스템 테스트:")
    
    # 데이터 저장
    for i in range(7):
        cache_system.set(f"key{i}", f"value{i}")
        print(f"  저장: key{i}")
    
    print(f"  캐시 크기: {len(cache_system._cache)}")
    
    # 데이터 조회
    for i in range(3):
        value = cache_system.get(f"key{i}")
        print(f"  조회 key{i}: {'히트' if value else '미스'}")
    
    print(f"  통계: {cache_system.get_stats()}")
    
    # 2. 캐시 데코레이터 구현
    print("\n2. 캐시 데코레이터 구현:")
    
    def cached_method(ttl=60, maxsize=128):
        """메서드 결과를 캐싱하는 데코레이터"""
        def decorator(func):
            cache = CompleteCacheSystem(max_size=maxsize, ttl_seconds=ttl)
            
            def wrapper(*args, **kwargs):
                # 캐시 키 생성 (인자를 기반으로)
                cache_key = (func.__name__, args, tuple(sorted(kwargs.items())))
                
                # 캐시 확인
                cached_result = cache.get(cache_key)
                if cached_result is not None:
                    return cached_result
                
                # 실제 함수 실행
                result = func(*args, **kwargs)
                
                # 결과 캐싱
                cache.set(cache_key, result)
                
                return result
            
            # 캐시 접근을 위한 속성 추가
            wrapper.cache = cache
            wrapper.clear_cache = cache.clear
            wrapper.get_stats = cache.get_stats
            
            return wrapper
        return decorator
    
    class DataProcessor:
        """데이터 처리 클래스"""
        
        def __init__(self):
            self.process_count = 0
        
        @cached_method(ttl=30, maxsize=10)
        def process_data(self, data_id, algorithm="default"):
            """비용이 높은 데이터 처리 메서드"""
            self.process_count += 1
            print(f"    데이터 처리 중: id={data_id}, algorithm={algorithm}")
            time.sleep(0.05)  # 처리 시간 시뮬레이션
            
            # 복잡한 계산 시뮬레이션
            result = hash(f"{data_id}_{algorithm}") % 1000
            return result
        
        @cached_method(ttl=60)
        def calculate_statistics(self, dataset, method="mean"):
            """통계 계산 메서드"""
            print(f"    통계 계산: dataset={dataset[:10]}..., method={method}")
            time.sleep(0.1)
            
            if method == "mean":
                return sum(dataset) / len(dataset) if dataset else 0
            elif method == "max":
                return max(dataset) if dataset else 0
            elif method == "min":
                return min(dataset) if dataset else 0
    
    print("  캐시 데코레이터 테스트:")
    processor = DataProcessor()
    
    # 첫 번째 실행 (캐시 미스)
    result1 = processor.process_data(1, "algorithm1")
    print(f"  결과1: {result1}, 처리 횟수: {processor.process_count}")
    
    # 같은 파라미터로 다시 실행 (캐시 히트)
    result1_again = processor.process_data(1, "algorithm1")
    print(f"  결과1 다시: {result1_again}, 처리 횟수: {processor.process_count}")
    
    # 다른 파라미터 (캐시 미스)
    result2 = processor.process_data(2, "algorithm2")
    print(f"  결과2: {result2}, 처리 횟수: {processor.process_count}")
    
    # 통계 캐시 테스트
    dataset = [1, 2, 3, 4, 5]
    stats1 = processor.calculate_statistics(dataset, "mean")
    stats1_again = processor.calculate_statistics(dataset, "mean")
    
    print(f"  통계 결과: {stats1} (캐시 히트: {stats1 == stats1_again})")
    
    # 캐시 통계 확인
    print(f"\n  process_data 캐시 통계:")
    stats = processor.process_data.get_stats()
    for key, value in stats.items():
        print(f"    {key}: {value}")

practical_caching_system()
```

## 결론

순환 참조 자료구조에서의 메모리 관리는 파이썬 개발자가 반드시 이해해야 할 중요한 개념입니다. `weakref` 모듈을 사용하면 참조 카운트 기반 가비지 컬렉션의 한계를 극복할 수 있으며, 약한 참조는 순환 참조 문제를 해결하는 가장 효과적인 방법 중 하나입니다. 객체 풀 패턴이나 컨텍스트 관리자를 활용하면 메모리 사용을 더욱 효율적으로 관리할 수 있습니다. 특히 대규모 데이터 구조나 장기 실행 애플리케이션에서는 메모리 누수를 방지하기 위해 이러한 기법들이 필수적입니다.

비교 연산을 지원하는 클래스를 만들 때는 `__eq__`, `__lt__`, `__gt__` 등의 특수 메서드를 구현해야 합니다. `functools.total_ordering` 데코레이터를 사용하면 최소한의 메서드 구현으로 완전한 비교 연산을 제공할 수 있습니다. 복합 비교 기준이나 사용자 정의 정렬 로직이 필요한 경우, `__lt__` 메서드를 적절히 구현하거나 `key` 함수를 사용하는 것이 좋습니다. 퍼지 비교나 다차원 비교와 같은 고급 패턴은 특정 도메인에서 매우 유용하게 활용될 수 있습니다.

캐시 인스턴스 생성은 객체 생성 비용이 높을 때 성능을 크게 향상시킬 수 있는 기술입니다. 단순한 클래스 레벨 캐시부터 시작하여 `functools.lru_cache`, `weakref.WeakValueDictionary`와 같은 표준 라이브러리를 활용할 수 있습니다. TTL(Time-to-Live), 크기 제한, 계층적 캐시와 같은 고급 기능을 추가하면 더욱 강력한 캐싱 시스템을 구축할 수 있습니다. 특히 데이터베이스 연결, 네트워크 리소스, 무거운 계산 결과와 같이 생성 비용이 높은 객체들은 캐싱의 훌륭한 후보입니다.

이 세 가지 기술은 각각 독립적으로 중요하지만, 함께 사용하면 더욱 강력한 시너지를 발휘합니다. 순환 참조를 피하면서도 효율적인 캐싱 시스템을 구축하고, 캐시된 객체들에 대해 의미 있는 비교 연산을 제공할 수 있습니다. 이러한 고급 기술들을 적절히 조합하면 메모리 효율성, 성능, 코드 유지보수성 모두를 잡는 우아한 파이썬 애플리케이션을 개발할 수 있습니다.