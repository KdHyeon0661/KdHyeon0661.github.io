---
layout: post
title: 시스템보안 - 실습(교육용 취약 드라이버 PrivEsc 체인 모델링)
date: 2025-10-22 22:30:23 +0900
category: 시스템보안
---
# 6.4 실습: 교육용 취약 드라이버(HEVD 등)로 PrivEsc 체인 **모델링**하기
> 목표: 취약 드라이버(예: HEVD, HackSysExtremeVulnerableDriver)의 **버그 표면**을 이해하고, **권한 상승 체인이 어떤 가정**에 의존하는지 “구성요소 수준”으로 분해·점검한다.  
> 주의: 실제로 SYSTEM 권한을 획득하는 페이로드·가젯·주소·R/W 프리미티브 조합 등은 제공하지 않는다. **대신** 안전한 “대체·모의(Mock)” 실습을 통해 **동등 개념**을 익힌다.

## 6.4.1 랩 설계(안전 가드레일)
- **VM**: Windows 10/11 + 스냅샷 `B0-Clean`, `B1-HEVD`  
- **네트워크**: Host-only(외부 차단)  
- **도구**: WinDbg Preview, Sysmon, Event Viewer, Windows Driver Kit(WDK)  
- **정책**: ASR/AppLocker/WDAC는 **감사(Audit)**로 시작 → 동작 영향 파악 후 점진적 강화

## 6.4.2 취약 드라이버 표면 이해(개념 맵)
일반적으로 교육용 취약 드라이버는 아래 유형의 버그를 **의도적으로** 노출한다.
- **Arbitrary Read/Write**: 임의 커널 주소 읽기/쓰기
- **Buffer Overflow / UAF**: 풀 오브젝트, 스택 버퍼, 객체 수명 결함
- **Type Confusion / Pointer Validation 결함**
- **IOCTL 검증 부재**: 길이/버전/태그/권한 체크 없이 사용자 입력 신뢰

> **체인 개념**(개발·방어 관점)
> 1) **취약 엔드포인트**(IOCTL) 식별  
> 2) **프리미티브 분류**(Read/Write/Call)  
> 3) **커널 보호 상태 가정**(SMEP/SMAP/CFG/HVCI/KASLR/PG)  
> 4) 보호 우회가 아니라 **보호가 막는 지점** 기록  
> 5) 운영 정책으로 동일 유형을 **선제 차단**(서명, WDAC, ASR, ETW 규칙 등)

## 6.4.3 “모의(Mock) PrivEsc 체인” — **권한 상승 없는** 동작 관찰
실제 권한 상승 대신, 아래와 같이 “**체인의 중간 단계**가 되기 쉬운 행동”을 **로그·이벤트**로 관찰한다.

### A) IOCTL 호출/길이 경계 시험(사용자모드)
```powershell
# safe-ioctl.ps1 — 드라이버 IOCTL 호출의 "경계값"만 자극 (권한 상승 없음)
param([string]$Device="\\.\HEVD")  # 예시 이름; 실제 장치명으로 교체
$fs = New-Object System.IO.FileStream($Device, [System.IO.FileMode]::Open, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::ReadWrite)
$bw = New-Object System.IO.BinaryWriter($fs)
$br = New-Object System.IO.BinaryReader($fs)

# 임의 IOCTL 코드 예시(실습 대상 문서 스펙에 맞게 대체)
$IOCTL_ECHO = 0x222003

function Send-IOCTL([int]$code, [byte[]]$inBuf, [int]$outLen){
  $in = New-Object byte[] (8 + $inBuf.Length)
  # [개념] 헤더(길이/버전) → 안전 실패 유도
  [BitConverter]::GetBytes([int]$inBuf.Length).CopyTo($in, 0)
  [BitConverter]::GetBytes(1).CopyTo($in, 4) # version=1
  $inBuf.CopyTo($in, 8)

  $out = New-Object byte[] ($outLen)
  $overlapped = New-Object byte[] 0
  $r = [System.IO.File]::IOControl($fs.SafeFileHandle, $code, $in, $out)
  # 실패/성공 코드가 아닌 "동작 패턴" 관찰(이벤트/드라이버 로그)
  return $out
}

# 1. len=0
[void](Send-IOCTL $IOCTL_ECHO ([byte[]]@()) 0)
# 2. len=정상 경계
[void](Send-IOCTL $IOCTL_ECHO ([byte[]](0x41..0x51)) 64)
# 3. len=과도 → -STATUS_INVALID_PARAMETER 기대
[void](Send-IOCTL $IOCTL_ECHO (New-Object byte[] 4096) 4096)

$fs.Close()
```

**관찰 포인트**
- 드라이버가 **길이/버전/태그**를 검증하며 **안전 실패(Status 0xC000000D 등)**로 떨어지는지  
- ETW/Sysmon/Driver Verifier가 **이상 호출 패턴**을 기록하는지

### B) ETW/Sysmon로 “권한 상승에서 흔한 흐름” 감시
- **프로세스 생성(1)**, **이미지 로드(7)**, **프로세스 핸들 접근(10)**, **레지스트리(12~14)**  
- 의심 신호(예시):  
  - 드라이버 IOCTL 호출 직후 **lsass.exe**에 대한 **PROCESS\_VM\_READ/WRITE 핸들 요청**  
  - **legacy 해석기**(wscript, regsvr32, rundll32) 실행  
  - **SYSTEM 컨텍스트**에서 사용자 쓰기 경로의 실행 이미지 로드

### C) “커널 보호”가 체인을 어떻게 막는지 기록
- SMEP/SMAP/CFG/HVCI(또는 Device Guard) 활성 시점에서 **체인의 어디에서 실패하는지**를 이벤트로 남김  
- 운영 리포트 예시:
  - “**SMEP=ON** → 사용자 공간 페이로드 실행 시도 차단(로그 O)”  
  - “**CFG=ON** → 비서명/비허용 타깃 주소 간접 호출 차단(예외 O)”  
  - “**HVCI=ON** → 미서명 드라이버 로드 실패(코드 무결성 거부 O)”

---

## 6.4.4 드라이버 측 “방어 스켈레톤” (KMDF)
**의도**: 같은 IOCTL 스펙이라도 **안전 실패**와 **감사 로그**를 잘 남기는 구조를 제시.
```c
// KMDF: IOCTL 수신부 안전 스케치 (권한 상승 없음, 교육용)
#include <ntddk.h>
#include <wdf.h>
#define IOCTL_HEVD_ECHO CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _ECHO_REQ {
  ULONG Length;
  ULONG Version;
  UCHAR Data[256];
} ECHO_REQ, *PECHO_REQ;

VOID EvtIoDeviceControl(
  WDFQUEUE Queue, WDFREQUEST Request,
  size_t OutLen, size_t InLen, ULONG Ioctl)
{
  UNREFERENCED_PARAMETER(Queue);
  NTSTATUS st = STATUS_INVALID_DEVICE_REQUEST;
  if (Ioctl == IOCTL_HEVD_ECHO) {
    if (InLen < sizeof(ECHO_REQ)) { st = STATUS_BUFFER_TOO_SMALL; goto done; }
    PECHO_REQ req = NULL;
    st = WdfRequestRetrieveInputBuffer(Request, sizeof(ECHO_REQ), (PVOID*)&req, NULL);
    if (!NT_SUCCESS(st)) goto done;

    if (req->Version != 1 || req->Length > 256) { st = STATUS_INVALID_PARAMETER; goto done; }
    // [중요] 사용자 버퍼를 커널 포인터로 사용하지 말 것
    //       길이 체크 후 내부 고정 버퍼로만 처리
    UCHAR out[256] = {0};
    RtlCopyMemory(out, req->Data, req->Length);

    PVOID pOut = NULL; size_t cbOut = 0;
    st = WdfRequestRetrieveOutputBuffer(Request, req->Length, &pOut, &cbOut);
    if (!NT_SUCCESS(st)) goto done;

    RtlCopyMemory(pOut, out, req->Length);
    WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, req->Length);
    return;
  }
done:
  // 이벤트 로그(ETW) 남기기 권장: 실패 이유/호출자 세션
  WdfRequestComplete(Request, st);
}
```

> 방어 체크리스트  
> - 사용자 제공 **커널 주소**를 절대 신뢰하지 않기  
> - **핸들/ID**만 받고, 커널 포인터는 **서버 측 테이블**에서만 해석  
> - **길이·버전** 단언 + 보수적 상한  
> - 실패 시 **감사 로그/ETW**로 흔적 남기기

---

## 6.4.5 “체인”을 방어 관점으로 문서화하는 템플릿
- **공격 가정**: 교육용 취약 드라이버 X, IOCTL Y에서 길이 검증 부재  
- **가능 프리미티브**: Arbitrary Write(이론상)  
- **차단 요인**: CFG=ON(간접 호출 제약), SMEP/SMAP=ON(유저 공간 실행 차단), HVCI/WDAC=ON(미서명 코드 로드 차단)  
- **가시성**: Sysmon(1/7/10), ETW(드라이버 이벤트), AppLocker/WDAC 감사 이벤트  
- **개선안**: 드라이버 패치(검증/경계/권한), 운영 정책(서명/허용목록), 탐지 규칙(핸들 요청/이미지 로드)

---

# 6.5 방어: CFG, SMEP/SMAP, KASLR, PatchGuard(Windows) — 개념·검증·운영 적용

## 6.5.1 CFG(Control Flow Guard)
- **개념**: 간접 호출 대상이 **사전 계산된 유효 엔트리**가 아니면 차단하는 사용자·커널 모드 **제어 흐름 무결성**(커널은 KCFG 계열).  
- **효과**: 임의 쓰기 후 **함수 포인터/가상 테이블 변조**로 간접 호출을 시도하는 체인을 차단.  
- **빌드**: /guard:cf, 최신 컴파일러/링커 필요.  
- **확인(사용자 앱)**: `dumpbin /loadconfig`에서 CFG 플래그, ETW로 예외 모니터링.

**운영 팁**
- 벤더 바이너리/드라이버가 **CFG/CFI 계열**로 빌드되었는지 공급망 점검  
- WDAC와 결합하면 **미서명+비CFI** 바이너리 사용을 크게 제한

## 6.5.2 SMEP/SMAP (x86)
- **SMEP**: 커널이 **사용자 공간 페이지 실행** 금지  
- **SMAP**: 커널이 **사용자 공간 주소 접근** 자체를 강화(명시적 우회 필요)  
- **효과**: 커널 ROP/페이로드가 유저 공간 코드를 실행하는 “빠른 길”을 차단.

**검증(개념)**
- 커널 디버거에서 CR4 레지스터의 SMEP/SMAP 비트 확인(랩에서 WinDbg, 리눅스는 `/proc/cpuinfo`/MSR 등).  
- 하이퍼바이저/펌웨어 설정으로 비활성화되었는지 확인(운영은 항상 **활성** 권장).

## 6.5.3 KASLR
- **커널/드라이버 베이스 주소 랜덤화**로 가젯/테이블의 고정 주소 의존 체인을 어렵게 함.  
- **함정**: **정보 누출**이 있으면 무력화. → 로그/오류 메시지/NT 경로 노출 등 **주소 유출** 경로 제거가 필수.

**운영 팁**
- 운영 이미지 빌드/부팅 정책에서 `nointegritychecks`, `testsigning`, `nokaslr` 등을 **사용 금지**  
- 크래시 덤프/로그의 **주소 마스킹**과 접근 통제

## 6.5.4 PatchGuard(커널 무결성 보호, Windows)
- **개념**: 커널 핵심 구조/코드(SSDT, IDT, GDT, 페이지 테이블, 커널 코드 섹션 등) **변조 탐지** → 위반 시 **버그체크**로 강제 보호.  
- **의미**: “임의 쓰기 체인”이 **핵심 테이블**을 건드리는 공격을 **장기적으로 지속**하기 어렵게 함.  
- **운영 포인트**:
  - **서명된 드라이버**와 **공식 API** 사용(서드파티 보안 제품도 우회 대신 공식 Extension 포인트 사용)  
  - PatchGuard 무력화 시도는 **안정성/법적 리스크** 큼 → 금지

---

## 6.5.5 운영 점검 스크립트(안전)

### A) 장치/드라이버 서명 & CI 정책(요약)
```powershell
# 서명·CI 상태 요약
Get-CimInstance Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, IsSigned | ft -AutoSize
# WDAC(AppControl) 상태 보기 (Windows 11+ 일부 커맨드; 환경에 따라 방법 상이)
Get-MpComputerStatus | Select-Object -Property DeviceControl_EnforcementLevel, ExploitGuard_ConfigurationVersion
```

### B) Sysmon 룰 힌트(요지)
- ID 1: `ImageLoaded` 경로가 사용자 쓰기 영역이면 경고  
- ID 7: **비서명 DLL** 또는 **비정상 경로**에서 로드 시 경고  
- ID 10: `TargetImage=lsass.exe`에 대한 접근(권한 세부 포함) 경고  
- ID 12~14: 서비스/Run 키/드라이버 등록 변경 경고

(*실제 규칙 XML은 조직 환경에 맞춰 커스터마이즈*)

### C) AppLocker/WDAC 운영 루틴
1. **감사 모드**로 2~4주 수집 → 정상 사용 화이트리스트 작성  
2. 서명자 규칙(파일 퍼블리셔) 위주로 허용  
3. 업데이트/패치 채널 경로를 **고정 디렉터리**로 통일 → 운영 마찰 최소화  
4. 점진적 **Enforce** 전환, 예외 티켓 흐름 운영

---

## 6.5.6 개발 팀을 위한 “안전한 커널 인터페이스 체크리스트”
- [ ] IOCTL: **매직/버전/길이** 모두 검증, **상한/정렬** 강제  
- [ ] 사용자 포인터 금지: 내부 ID/핸들 → 커널 포인터는 서버 측에서만 해석  
- [ ] 수명: refcount/kref 사용, 교체는 RCU/락, 해제는 동기화 후  
- [ ] CFG/CFI로 빌드, 최신 컴파일러와 /guard 옵션 사용  
- [ ] 서명: 드라이버 서명·배포 파이프라인 표준화, 테스트 서명은 **랩 전용**  
- [ ] 런타임 보호: HVCI(가능 시), Driver Verifier로 사전 검증  
- [ ] 로깅: ETW/이벤트 트레이싱 삽입(실패 원인/호출자 정보)

---

# 요약
- HEVD 같은 교육용 취약 드라이버는 **버그 표면을 설명하는 교보재**일 뿐, **운영 환경**에서는 같은 패턴을 **사전에 차단**하는 게 목적이다.  
- **CFG/SMEP/SMAP/KASLR/PatchGuard/HVCI/WDAC/ASR**를 겹겹이 적용하면, 임의 쓰기·간접 호출·유저 공간 코드 실행 의존 체인을 **현저히** 깨뜨린다.  
- 본 문서의 스크립트/스켈레톤은 **권한 상승 없이**도 “체인의 어디가 막히는지”를 **가시화**한다. 이를 **Runbook**과 **GPO/MDM**으로 제도화하면 지속적인 방어가 가능하다.
