---
layout: post
title: flask - 라우팅 & 요청, 응답 (1)
date: 2025-09-15 22:25:23 +0900
category: flask
---
# 1. 라우팅 & 요청/응답 (1)

> 이 장은 **URL 라우팅(변수 규칙·타입 컨버터·우선순위·리다이렉트)과 Request 객체(form/json/files/headers/cookies)**를, **예제 + 체크리스트 + 안티패턴** 중심으로 깊게 파고든다.  
> 코드 블록은 모두 ```로 감싸며, 수식이 있으면 $$…$$로 표기한다(본 장은 수식이 거의 없다).

---

## 1.1 라우팅 기본: URL → View 함수

Flask는 내부적으로 **Werkzeug 라우터**를 사용한다. 핵심은 세 가지다.

1) **규칙(rule)**: URL 패턴(예: `/users/<int:user_id>`)  
2) **메서드(methods)**: 허용 HTTP 메서드(예: `GET`, `POST`)  
3) **엔드포인트(endpoint)**: 내부 식별자(기본은 함수명), `url_for()`에서 사용

### 1.1.1 가장 작은 예제

```python
# app/blueprints/main/views.py
from flask import Blueprint, jsonify

main_bp = Blueprint("main", __name__)

@main_bp.get("/hello")
def hello():
    return jsonify(message="hello")
```

- `.get()` 데코레이터는 `methods=["GET"]`의 축약형.
- 동일한 경로라도 메서드별로 **다른 뷰**를 둘 수 있다.

```python
@main_bp.post("/hello")
def hello_post():
    # form/json 처리 등
    return jsonify(ok=True), 201
```

---

## 1.2 URL 변수 규칙 & 타입 컨버터

경로의 일부를 변수로 캡처할 수 있다.

- 기본: `<name>` → 문자열
- 타입 컨버터:
  - `<int:id>`: 10진 정수
  - `<float:x>`: 부동소수
  - `<path:subpath>`: 슬래시 포함 경로
  - `<uuid:uid>`: UUID4 형식

```python
@main_bp.get("/users/<int:user_id>")
def get_user(user_id):
    # user_id는 int로 변환되어 들어온다
    return jsonify(user_id=user_id)
```

### 1.2.1 커스텀 컨버터(고급)

정규식 등으로 세밀하게 제한하고 싶다면 **커스텀 컨버터**를 등록한다.

```python
# app/converters.py
from werkzeug.routing import BaseConverter

class Hex24Converter(BaseConverter):
    # 24자리 16진 (예: 몽고 ObjectId 비슷한 포맷)
    regex = r"[0-9a-fA-F]{24}"
```

```python
# app/__init__.py (앱 팩토리 내)
from .converters import Hex24Converter

def create_app(config_name=None):
    app = Flask(__name__)
    app.url_map.converters["hex24"] = Hex24Converter
    ...
    return app
```

```python
# 사용
@main_bp.get("/docs/<hex24:doc_id>")
def get_doc(doc_id):
    return {"doc_id": doc_id}
```

---

## 1.3 라우트 우선순위, 트레일링 슬래시, strict_slashes

### 1.3.1 라우트 매칭 순서

- **정적 → 동적** 순서가 아니다. Flask는 **등록 순서**와 **정규식 특성** 등을 종합해 매칭한다.
- **더 구체적인 규칙**이 먼저 매칭되도록 **등록 순서**를 조정하는 습관을 들이자.

```python
@main_bp.get("/users/me")     # 더 구체적
def me(): ...
@main_bp.get("/users/<int:id>")
def get_user(id): ...
```

### 1.3.2 트레일링 슬래시(`/`) 관례

- `/users`와 `/users/`는 **다른 경로**다.
- 기본 동작: `/users`에 등록하면 `/users/`로 들어왔을 때 **자동 리다이렉트**(308) 발생.
- API 서버는 **리소스 관례**를 지켜 일관되게 정의하자.
  - **컬렉션**: `/users` (GET 목록, POST 생성)
  - **개별**: `/users/<id>` (GET/PUT/PATCH/DELETE)
  - **서브리소스**: `/users/<id>/posts`

```python
# 엄격 제어(블루프린트 단위)
main_bp = Blueprint("main", __name__, url_prefix="", strict_slashes=False)
```

- `strict_slashes=False`면 `/path/`와 `/path`를 둘 다 허용.

### 1.3.3 URL 빌딩: url_for

- **하드코딩 대신 항상 `url_for` 사용** → 리팩토링/리버스 프록시 환경에서 안전.

```python
from flask import url_for

@main_bp.get("/links")
def links():
    return {
        "self": url_for("main.links", _external=True),
        "user": url_for("main.get_user", user_id=42),
    }
```

- `_external=True`는 **절대 URL**을 생성(호스트/스킴 포함).
- 프록시/Nginx 환경에서 **`APPLICATION_ROOT`, `PREFERRED_URL_SCHEME`, `X-Forwarded-*` 헤더**를 정확히 처리하도록 설정하라(프록시 미들웨어 또는 Nginx 설정 필요).

---

## 1.4 HTTP 메서드: GET/POST/PUT/PATCH/DELETE/OPTIONS

### 1.4.1 선언

```python
@main_bp.route("/articles", methods=["GET", "POST"])
def articles():
    if request.method == "POST":
        ...
    ...
```

또는 축약:

```python
@main_bp.get("/articles")
def list_articles(): ...

@main_bp.post("/articles")
def create_article(): ...
```

### 1.4.2 멱등성/안전성(REST 규약 핵심)

- **GET**: 안전(safe), 멱등(idempotent).
- **POST**: **생성**, 멱등 아님(보통).
- **PUT**: 전체 대치(멱등).
- **PATCH**: 부분 수정(멱등 보장 X가 일반적).
- **DELETE**: 멱등(성공 후 다시 지워도 상태 동일).
- **OPTIONS**: CORS 프리플라이트 등.

> 체크리스트: **서버 부작용이 없는 조회는 GET**, **생성은 POST**, **전체 업데이트는 PUT**, **부분만 PATCH**, **삭제는 DELETE**— 문서화에 명확히 박아두자.

---

## 1.5 리다이렉트: 301/302/303/307/308

### 1.5.1 코드 차이(요약)

- **301 Moved Permanently**: 영구 이전, 브라우저 캐시 강함(주의).
- **302 Found**: 전통적 임시 리다이렉트(과거 POST → GET 변환 등 혼선).
- **303 See Other**: **POST 후 GET으로** 리다이렉트 표준(폼 제출 후 결과 페이지).
- **307 Temporary Redirect**: **메서드 유지**(POST→POST, 안전).
- **308 Permanent Redirect**: **영구 + 메서드 유지**.

### 1.5.2 Flask에서 리다이렉트

```python
from flask import redirect, url_for

@main_bp.post("/login")
def login():
    # 인증 로직...
    return redirect(url_for("main.dashboard"), code=303)

@main_bp.get("/move")
def move():
    return redirect("https://example.com", code=302)
```

> API 서버에서는 **307/308**을 선호(클라이언트가 메서드/본문을 유지). 웹 폼 패턴은 **303**이 자연스럽다.

---

## 1.6 Request 객체: form, json, files, headers, cookies

`flask.request`는 **요청 컨텍스트**가 활성일 때 접근 가능하다.

```python
from flask import request
```

### 1.6.1 쿼리스트링 & 경로 변수

```python
@main_bp.get("/search")
def search():
    q = request.args.get("q", default="", type=str)
    page = request.args.get("page", default=1, type=int)
    # /search?q=flask&page=2
    return {"q": q, "page": page}
```

- `request.view_args`에 **경로 변수**가 들어있다.

```python
@main_bp.get("/users/<int:user_id>")
def get_user(user_id):
    # user_id == request.view_args["user_id"]
    ...
```

### 1.6.2 폼 데이터(form) — `application/x-www-form-urlencoded`, `multipart/form-data`

```python
@main_bp.post("/submit-form")
def submit_form():
    username = request.form.get("username", "")
    interests = request.form.getlist("interests")  # 체크박스 다중값
    return {"username": username, "interests": interests}
```

- HTML `<form>` 기본 전송은 `application/x-www-form-urlencoded`
- 파일 업로드는 **반드시** `multipart/form-data`

### 1.6.3 JSON 바디 — `application/json`

```python
@main_bp.post("/api/items")
def create_item():
    data = request.get_json(silent=False, force=False)  # 권장: silent=False
    # Content-Type이 application/json 아니면 None 또는 오류
    name = data["name"]
    price = data.get("price", 0)
    return {"id": 123, "name": name, "price": price}, 201
```

- `request.is_json`으로 헤더 검사 가능.
- **안티패턴**: `force=True` 남발(잘못된 Content-Type 전송을 조용히 허용 → 디버깅 어렵다).  
  개발 초반부터 **클라이언트에 Content-Type 준수**를 요구하라.

**유효성 검증**: Marshmallow/Pydantic을 써서 스키마 기반 검증을 붙이면 좋다(다음 장에서 확장).

### 1.6.4 파일 업로드(files)

```python
from werkzeug.utils import secure_filename
from pathlib import Path

UPLOAD_DIR = Path("/tmp/uploads")

@main_bp.post("/upload")
def upload():
    file = request.files.get("file")  # type: FileStorage | None
    if not file or file.filename == "":
        return {"error": "no file"}, 400

    filename = secure_filename(file.filename)  # 경로 traversal 방지
    dest = UPLOAD_DIR / filename
    file.save(dest)
    return {"filename": filename}, 201
```

- **보안**: 사용자 제공 파일명은 **반드시** `secure_filename()`으로 정제.
- **용량 제한**: Flask 설정 `MAX_CONTENT_LENGTH`로 전체 요청 크기 제한.

```python
# app/config.py
class BaseConfig:
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB
```

- **대용량 스트리밍**: 기본 `FileStorage`는 임계값 넘어가면 임시파일로 스풀(spool). 더 큰 스트리밍 흐름이 필요하면 **reverse proxy + 백엔드 chunking** 전략을 설계한다.

### 1.6.5 헤더(headers)

```python
@main_bp.get("/whoami")
def whoami():
    ua = request.headers.get("User-Agent")
    accept = request.headers.get("Accept", "*/*")
    has_gzip = "gzip" in request.headers.get("Accept-Encoding", "")
    return {"ua": ua, "accept": accept, "gzip_ok": has_gzip}
```

- Flask의 헤더는 **대소문자 무시** 매핑.
- **다중 헤더**(예: `Set-Cookie`)는 Framework가 합쳐서 응답에 싣는다. 요청 헤더의 **동일 키 다중값**은 `request.headers.getlist("X-Header")`로 조회 가능.

### 1.6.6 쿠키(cookies)

```python
from datetime import timedelta
from flask import make_response

@main_bp.post("/login")
def login():
    # 인증 성공 가정
    resp = make_response({"ok": True})
    resp.set_cookie(
        "session_id",
        value="abc123",
        max_age=int(timedelta(days=7).total_seconds()),
        httponly=True,
        secure=True,      # HTTPS에서만
        samesite="Lax",   # 'Strict' | 'Lax' | 'None'('None'은 secure=True 필수)
        path="/",
    )
    return resp

@main_bp.post("/logout")
def logout():
    resp = make_response({"ok": True})
    resp.delete_cookie("session_id")
    return resp

@main_bp.get("/me")
def me():
    sid = request.cookies.get("session_id")
    return {"session_id": sid or "-"}
```

- **보안 속성**: `Secure`(HTTPS), `HttpOnly`(JS 접근 금지), `SameSite`(CSRF 억제)
- `SameSite=None`은 **반드시** `Secure=True`와 함께 사용.

---

## 1.7 클래스 기반 뷰 & 메서드 분기(선택)

함수형 라우트 대신 **클래스 기반 뷰**로 메서드별 로직을 분리할 수 있다.

```python
from flask.views import MethodView
from flask import request, jsonify

class ItemAPI(MethodView):
    def get(self, item_id=None):
        if item_id is None:
            return jsonify(items=[{"id": 1}, {"id": 2}])
        return jsonify(id=item_id)

    def post(self):
        data = request.get_json()
        return jsonify(id=123, **data), 201

    def patch(self, item_id):
        data = request.get_json()
        return jsonify(id=item_id, **data)

    def delete(self, item_id):
        return "", 204
```

```python
# 라우팅 등록
item_view = ItemAPI.as_view("items")
main_bp.add_url_rule("/items", defaults={"item_id": None}, view_func=item_view, methods=["GET"])
main_bp.add_url_rule("/items", view_func=item_view, methods=["POST"])
main_bp.add_url_rule("/items/<int:item_id>", view_func=item_view, methods=["GET", "PATCH", "DELETE"])
```

- 장점: **메서드별 명확한 분기**, 재사용 쉬움.
- 단점: 간단한 엔드포인트엔 과할 수 있음.

---

## 1.8 요청/응답 보조: 리퀘스트 훅, 애프터 훅, 에러 핸들러

### 1.8.1 before_request / after_request

```python
from flask import g, request

@main_bp.before_app_request
def inject_correlation_id():
    g.corr = request.headers.get("X-Request-ID", "gen-123")

@main_bp.after_app_request
def add_tracing_headers(resp):
    resp.headers["X-Request-ID"] = getattr(g, "corr", "-")
    return resp
```

- **관측**(로깅·트레이싱)·**로케일 결정**·**권한 프리체크** 등 공통로직 탑재 위치.

### 1.8.2 에러 핸들러

```python
from werkzeug.exceptions import BadRequest, NotFound
from flask import jsonify

@main_bp.app_errorhandler(BadRequest)
def handle_bad_request(e):
    return jsonify(error="bad-request", detail=str(e)), 400

@main_bp.app_errorhandler(NotFound)
def handle_nf(e):
    return jsonify(error="not-found"), 404
```

- **사용자 정의 예외**를 만들어 비즈니스 에러 → HTTP로 맵핑하는 패턴을 추천.

---

## 1.9 실전 예제 모음

### 1.9.1 변수 규칙 + 타입 컨버터 + url_for

```python
@main_bp.get("/projects/<uuid:pid>")
def project_detail(pid):
    # pid는 uuid.UUID 인스턴스로 변환되어 들어옴
    return {
        "self": url_for("main.project_detail", pid=pid),
        "tasks": url_for("main.project_tasks", pid=pid),
    }

@main_bp.get("/projects/<uuid:pid>/tasks")
def project_tasks(pid):
    page = request.args.get("page", 1, int)
    return {"project": str(pid), "page": page}
```

### 1.9.2 POST JSON + 303 리다이렉트(웹 폼 결과 페이지)

```python
from flask import request, redirect, url_for

@main_bp.post("/signup")
def signup():
    data = request.get_json()
    # 유효성 검사/생성...
    user_id = 42
    # 결과 페이지로 GET 리다이렉트(폼-패턴)
    return redirect(url_for("main.user_page", user_id=user_id), code=303)

@main_bp.get("/users/<int:user_id>")
def user_page(user_id):
    return {"id": user_id, "name": "Alice"}
```

### 1.9.3 파일 업로드 + 용량 제한 + 저장

```python
# config.py
class BaseConfig:
    MAX_CONTENT_LENGTH = 20 * 1024 * 1024  # 20MB
```

```python
@main_bp.post("/assets")
def upload_asset():
    f = request.files.get("asset")
    if not f or f.filename == "":
        return {"error": "no file"}, 400
    name = secure_filename(f.filename)
    (UPLOAD_DIR / name).parent.mkdir(parents=True, exist_ok=True)
    f.save(UPLOAD_DIR / name)
    return {"name": name}, 201
```

### 1.9.4 쿠키 로그인 + HttpOnly/SameSite 보안 설정

```python
from flask import make_response

@main_bp.post("/sessions")
def create_session():
    # idp 검증 성공했다고 가정
    sid = "s-abc123"
    resp = make_response({"ok": True})
    resp.set_cookie("sid", sid, httponly=True, secure=True, samesite="Lax", path="/")
    return resp
```

---

## 1.10 테스트(요청/응답 관점) — pytest

### 1.10.1 클라이언트 픽스처

```python
# tests/conftest.py
import pytest
from app import create_app

@pytest.fixture()
def client():
    app = create_app("testing")
    return app.test_client()
```

### 1.10.2 라우팅/메서드/리다이렉트/쿠키 테스트

```python
def test_get_user(client):
    r = client.get("/users/123")
    assert r.status_code == 200
    assert r.get_json()["user_id"] == 123

def test_post_json(client):
    r = client.post("/api/items", json={"name": "book", "price": 80})
    assert r.status_code == 201
    data = r.get_json()
    assert data["name"] == "book"

def test_redirect_303(client):
    r = client.post("/signup", json={"email": "a@b.com"}, follow_redirects=False)
    assert r.status_code == 303
    assert "/users/" in r.headers["Location"]

def test_cookies(client):
    r = client.post("/sessions")
    assert r.status_code == 200
    # Set-Cookie 확인
    assert "sid=" in r.headers.get("Set-Cookie", "")
```

---

## 1.11 운영·보안 체크리스트(요청/응답 관점)

- [ ] **URL 설계 일관성**: 컬렉션/개별/서브리소스 패턴 유지  
- [ ] **타입 컨버터**: `<int>`, `<uuid>` 적극 사용(유효하지 않은 URL은 404)  
- [ ] **메서드语의**: GET 안전/멱등, POST 생성, PUT/PATCH/DELETE 규약 준수  
- [ ] **리다이렉트 코드**: 폼 → 303, API 메서드 유지 → 307/308 선호  
- [ ] **JSON Content-Type**: `application/json` 강제, `get_json(silent=False)`  
- [ ] **파일 업로드**: `secure_filename`, `MAX_CONTENT_LENGTH`, 확장자·MIME 점검  
- [ ] **헤더 처리**: `X-Request-ID`, `X-Forwarded-*` 신뢰 경계 정의(프록시 설정 포함)  
- [ ] **쿠키 보안**: `Secure`, `HttpOnly`, `SameSite` 적절 설정  
- [ ] **에러 응답 규약**: 일관된 JSON 스키마(코드/메시지/필드 오류 등)  
- [ ] **테스트**: 라우팅/메서드/리다이렉트/파일/쿠키/헤더 케이스 포함  

---

## 1.12 흔한 안티패턴

- **하드코딩 URL**: 템플릿·코드에서 문자열로 경로를 직접 쓰기 → `url_for()`로 치환  
- **모든 POST를 302로**: 폼 제출 후 302 → 의도치 않은 메서드 변환 문제. 303을 사용  
- **`force=True`로 JSON 파싱**: 클라이언트 버그 은닉. 개발 초반부터 Content-Type 준수  
- **파일명을 그대로 저장**: 경로 traversal/덮어쓰기 위험 → `secure_filename()` 필수  
- **쿠키 SameSite=None + Secure 미설정**: 최신 브라우저에서 차단됨  
- **라우트 충돌**: `/users/me` vs `/users/<id>` 등록 순서/우선순위 미고려  

---

## 1.13 cURL로 로컬 확인(스니펫)

```bash
# 1) GET
curl -i http://127.0.0.1:5000/hello

# 2) POST JSON
curl -i -X POST http://127.0.0.1:5000/api/items \
  -H "Content-Type: application/json" \
  -d '{"name":"book","price":80}'

# 3) 파일 업로드
curl -i -X POST http://127.0.0.1:5000/upload \
  -F "file=@/path/to/image.png"

# 4) 쿠키 확인
curl -i -X POST http://127.0.0.1:5000/sessions
```

---

## 1.14 마무리

이 섹션에서는 **라우팅(변수 규칙·컨버터·트레일링 슬래시·URL 빌딩) → 메서드 규약 → 리다이렉트 의미 → Request(form/json/files/headers/cookies)**를 깊이 다뤘다.  