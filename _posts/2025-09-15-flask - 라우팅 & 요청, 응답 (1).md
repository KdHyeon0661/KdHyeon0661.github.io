---
layout: post
title: flask - 라우팅 & 요청, 응답 (1)
date: 2025-09-15 22:25:23 +0900
category: flask
---
# 라우팅 & 요청/응답 (1)

## 라우팅 기본: URL → View 함수

Flask는 내부적으로 **Werkzeug 라우터**를 사용하며, 핵심 요소는 세 가지입니다.

1) **규칙(rule)**: URL 패턴(예: `/users/<int:user_id>`)
2) **메서드(methods)**: 허용 HTTP 메서드(예: `GET`, `POST`)
3) **엔드포인트(endpoint)**: 내부 식별자(기본은 함수명), `url_for()`에서 사용

### 간단한 예제

```python
# app/blueprints/main/views.py

from flask import Blueprint, jsonify

main_bp = Blueprint("main", __name__)

@main_bp.get("/hello")
def hello():
    return jsonify(message="hello")
```

- `.get()` 데코레이터는 `methods=["GET"]`의 축약형입니다.
- 동일한 경로라도 메서드별로 **다른 뷰**를 정의할 수 있습니다.

```python
@main_bp.post("/hello")
def hello_post():
    # form/json 처리 등
    return jsonify(ok=True), 201
```

---

## URL 변수 규칙 & 타입 컨버터

경로의 일부를 변수로 캡처할 수 있습니다.

- 기본: `<name>` → 문자열
- 타입 컨버터:
  - `<int:id>`: 10진 정수
  - `<float:x>`: 부동소수
  - `<path:subpath>`: 슬래시 포함 경로
  - `<uuid:uid>`: UUID4 형식

```python
@main_bp.get("/users/<int:user_id>")
def get_user(user_id):
    # user_id는 int로 변환되어 들어옵니다.
    return jsonify(user_id=user_id)
```

### 커스텀 컨버터(고급)

정규식 등으로 세밀하게 제한하고 싶다면 **커스텀 컨버터**를 등록할 수 있습니다.

```python
# app/converters.py

from werkzeug.routing import BaseConverter

class Hex24Converter(BaseConverter):
    # 24자리 16진 (예: 몽고 ObjectId 비슷한 포맷)
    regex = r"[0-9a-fA-F]{24}"
```

```python
# app/__init__.py (앱 팩토리 내)

from .converters import Hex24Converter

def create_app(config_name=None):
    app = Flask(__name__)
    app.url_map.converters["hex24"] = Hex24Converter
    ...
    return app
```

```python
# 사용

@main_bp.get("/docs/<hex24:doc_id>")
def get_doc(doc_id):
    return {"doc_id": doc_id}
```

---

## 라우트 우선순위, 트레일링 슬래시, strict_slashes

### 라우트 매칭 순서

Flask는 **등록 순서**와 **정규식 특성** 등을 종합해 매칭합니다. 더 구체적인 규칙이 먼저 매칭되도록 **등록 순서**를 신경써야 합니다.

```python
@main_bp.get("/users/me")     # 더 구체적
def me(): ...
@main_bp.get("/users/<int:id>")
def get_user(id): ...
```

### 관례

- `/users`와 `/users/`는 **다른 경로**입니다.
- 기본 동작: `/users`에 등록하면 `/users/`로 들어왔을 때 **자동 리다이렉트**(308)가 발생합니다.
- API 서버는 **리소스 관례**를 지켜 일관되게 정의하는 것이 좋습니다.
  - **컬렉션**: `/users` (GET 목록, POST 생성)
  - **개별**: `/users/<id>` (GET/PUT/PATCH/DELETE)
  - **서브리소스**: `/users/<id>/posts`

```python
# 엄격 제어(블루프린트 단위)

main_bp = Blueprint("main", __name__, url_prefix="", strict_slashes=False)
```

- `strict_slashes=False`면 `/path/`와 `/path`를 둘 다 허용합니다.

### URL 빌딩: url_for

- **하드코딩 대신 항상 `url_for` 사용**하는 것이 좋습니다. 이렇게 하면 리팩토링이나 리버스 프록시 환경에서 안전합니다.

```python
from flask import url_for

@main_bp.get("/links")
def links():
    return {
        "self": url_for("main.links", _external=True),
        "user": url_for("main.get_user", user_id=42),
    }
```

- `_external=True`는 **절대 URL**을 생성합니다(호스트/스킴 포함).
- 프록시/Nginx 환경에서 **`APPLICATION_ROOT`, `PREFERRED_URL_SCHEME`, `X-Forwarded-*` 헤더**를 정확히 처리하도록 설정해야 합니다(프록시 미들웨어 또는 Nginx 설정 필요).

---

## HTTP 메서드: GET/POST/PUT/PATCH/DELETE/OPTIONS

### 선언

```python
@main_bp.route("/articles", methods=["GET", "POST"])
def articles():
    if request.method == "POST":
        ...
    ...
```

또는 축약형으로 표현할 수 있습니다:

```python
@main_bp.get("/articles")
def list_articles(): ...

@main_bp.post("/articles")
def create_article(): ...
```

### 멱등성/안전성(REST 규약 핵심)

- **GET**: 안전(safe), 멱등(idempotent).
- **POST**: **생성**, 멱등 아님(보통).
- **PUT**: 전체 대치(멱등).
- **PATCH**: 부분 수정(멱등 보장하지 않음이 일반적).
- **DELETE**: 멱등(성공 후 다시 지워도 상태 동일).
- **OPTIONS**: CORS 프리플라이트 등.

---

## 리다이렉트: 301/302/303/307/308

### 코드 차이(요약)

- **301 Moved Permanently**: 영구 이전, 브라우저 캐시 강함(주의 필요).
- **302 Found**: 전통적 임시 리다이렉트(과거 POST → GET 변환 등 혼선).
- **303 See Other**: **POST 후 GET으로** 리다이렉트 표준(폼 제출 후 결과 페이지).
- **307 Temporary Redirect**: **메서드 유지**(POST→POST, 안전).
- **308 Permanent Redirect**: **영구 + 메서드 유지**.

### Flask에서 리다이렉트

```python
from flask import redirect, url_for

@main_bp.post("/login")
def login():
    # 인증 로직...
    return redirect(url_for("main.dashboard"), code=303)

@main_bp.get("/move")
def move():
    return redirect("https://example.com", code=302)
```

API 서버에서는 **307/308**을 선호하고(클라이언트가 메서드/본문을 유지), 웹 폼 패턴은 **303**이 자연스럽습니다.

---

## Request 객체: form, json, files, headers, cookies

`flask.request`는 **요청 컨텍스트**가 활성일 때 접근 가능합니다.

```python
from flask import request
```

### 쿼리스트링 & 경로 변수

```python
@main_bp.get("/search")
def search():
    q = request.args.get("q", default="", type=str)
    page = request.args.get("page", default=1, type=int)
    # /search?q=flask&page=2
    return {"q": q, "page": page}
```

- `request.view_args`에 **경로 변수**가 들어있습니다.

```python
@main_bp.get("/users/<int:user_id>")
def get_user(user_id):
    # user_id == request.view_args["user_id"]
    ...
```

### 폼 데이터 — `application/x-www-form-urlencoded`, `multipart/form-data`

```python
@main_bp.post("/submit-form")
def submit_form():
    username = request.form.get("username", "")
    interests = request.form.getlist("interests")  # 체크박스 다중값
    return {"username": username, "interests": interests}
```

- HTML `<form>` 기본 전송은 `application/x-www-form-urlencoded`입니다.
- 파일 업로드는 **반드시** `multipart/form-data`여야 합니다.

### JSON 바디 — `application/json`

```python
@main_bp.post("/api/items")
def create_item():
    data = request.get_json(silent=False, force=False)  # 권장: silent=False
    # Content-Type이 application/json 아니면 None 또는 오류
    name = data["name"]
    price = data.get("price", 0)
    return {"id": 123, "name": name, "price": price}, 201
```

- `request.is_json`으로 헤더 검사 가능합니다.
- **안티패턴**: `force=True` 남발(잘못된 Content-Type 전송을 조용히 허용하면 디버깅이 어려워집니다). 개발 초반부터 **클라이언트에 Content-Type 준수**를 요구하는 것이 좋습니다.

**유효성 검증**: Marshmallow/Pydantic을 사용해 스키마 기반 검증을 붙이면 좋습니다.

### 파일 업로드(files)

```python
from werkzeug.utils import secure_filename
from pathlib import Path

UPLOAD_DIR = Path("/tmp/uploads")

@main_bp.post("/upload")
def upload():
    file = request.files.get("file")  # type: FileStorage | None
    if not file or file.filename == "":
        return {"error": "no file"}, 400

    filename = secure_filename(file.filename)  # 경로 traversal 방지
    dest = UPLOAD_DIR / filename
    file.save(dest)
    return {"filename": filename}, 201
```

- **보안**: 사용자 제공 파일명은 **반드시** `secure_filename()`으로 정제해야 합니다.
- **용량 제한**: Flask 설정 `MAX_CONTENT_LENGTH`로 전체 요청 크기를 제한할 수 있습니다.

```python
# app/config.py

class BaseConfig:
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB
```

### 헤더(headers)

```python
@main_bp.get("/whoami")
def whoami():
    ua = request.headers.get("User-Agent")
    accept = request.headers.get("Accept", "*/*")
    has_gzip = "gzip" in request.headers.get("Accept-Encoding", "")
    return {"ua": ua, "accept": accept, "gzip_ok": has_gzip}
```

- Flask의 헤더는 **대소문자 무시** 매핑입니다.
- **다중 헤더**(예: `Set-Cookie`)는 Framework가 합쳐서 응답에 싣습니다. 요청 헤더의 **동일 키 다중값**은 `request.headers.getlist("X-Header")`로 조회 가능합니다.

### 쿠키(cookies)

```python
from datetime import timedelta
from flask import make_response

@main_bp.post("/login")
def login():
    # 인증 성공 가정
    resp = make_response({"ok": True})
    resp.set_cookie(
        "session_id",
        value="abc123",
        max_age=int(timedelta(days=7).total_seconds()),
        httponly=True,
        secure=True,      # HTTPS에서만
        samesite="Lax",   # 'Strict' | 'Lax' | 'None'('None'은 secure=True 필수)
        path="/",
    )
    return resp

@main_bp.post("/logout")
def logout():
    resp = make_response({"ok": True})
    resp.delete_cookie("session_id")
    return resp

@main_bp.get("/me")
def me():
    sid = request.cookies.get("session_id")
    return {"session_id": sid or "-"}
```

- **보안 속성**: `Secure`(HTTPS), `HttpOnly`(JS 접근 금지), `SameSite`(CSRF 억제)
- `SameSite=None`은 **반드시** `Secure=True`와 함께 사용해야 합니다.

---

## 클래스 기반 뷰 & 메서드 분기(선택)

함수형 라우트 대신 **클래스 기반 뷰**로 메서드별 로직을 분리할 수 있습니다.

```python
from flask.views import MethodView
from flask import request, jsonify

class ItemAPI(MethodView):
    def get(self, item_id=None):
        if item_id is None:
            return jsonify(items=[{"id": 1}, {"id": 2}])
        return jsonify(id=item_id)

    def post(self):
        data = request.get_json()
        return jsonify(id=123, **data), 201

    def patch(self, item_id):
        data = request.get_json()
        return jsonify(id=item_id, **data)

    def delete(self, item_id):
        return "", 204
```

```python
# 라우팅 등록

item_view = ItemAPI.as_view("items")
main_bp.add_url_rule("/items", defaults={"item_id": None}, view_func=item_view, methods=["GET"])
main_bp.add_url_rule("/items", view_func=item_view, methods=["POST"])
main_bp.add_url_rule("/items/<int:item_id>", view_func=item_view, methods=["GET", "PATCH", "DELETE"])
```

장점은 **메서드별 명확한 분기**와 재사용이 쉽다는 점이며, 단점은 간단한 엔드포인트에는 과할 수 있다는 점입니다.

---

## 요청/응답 보조: 리퀘스트 훅, 애프터 훅, 에러 핸들러

### before_request / after_request

```python
from flask import g, request

@main_bp.before_app_request
def inject_correlation_id():
    g.corr = request.headers.get("X-Request-ID", "gen-123")

@main_bp.after_app_request
def add_tracing_headers(resp):
    resp.headers["X-Request-ID"] = getattr(g, "corr", "-")
    return resp
```

**관측**(로깅·트레이싱)·**로케일 결정**·**권한 프리체크** 등 공통 로직을 탑재하기 좋은 위치입니다.

### 에러 핸들러

```python
from werkzeug.exceptions import BadRequest, NotFound
from flask import jsonify

@main_bp.app_errorhandler(BadRequest)
def handle_bad_request(e):
    return jsonify(error="bad-request", detail=str(e)), 400

@main_bp.app_errorhandler(NotFound)
def handle_nf(e):
    return jsonify(error="not-found"), 404
```

**사용자 정의 예외**를 만들어 비즈니스 에러 → HTTP로 맵핑하는 패턴을 추천합니다.

---

## 실전 예제 모음

### 변수 규칙 + 타입 컨버터 + url_for

```python
@main_bp.get("/projects/<uuid:pid>")
def project_detail(pid):
    # pid는 uuid.UUID 인스턴스로 변환되어 들어옴
    return {
        "self": url_for("main.project_detail", pid=pid),
        "tasks": url_for("main.project_tasks", pid=pid),
    }

@main_bp.get("/projects/<uuid:pid>/tasks")
def project_tasks(pid):
    page = request.args.get("page", 1, int)
    return {"project": str(pid), "page": page}
```

### POST JSON + 303 리다이렉트(웹 폼 결과 페이지)

```python
from flask import request, redirect, url_for

@main_bp.post("/signup")
def signup():
    data = request.get_json()
    # 유효성 검사/생성...
    user_id = 42
    # 결과 페이지로 GET 리다이렉트(폼-패턴)
    return redirect(url_for("main.user_page", user_id=user_id), code=303)

@main_bp.get("/users/<int:user_id>")
def user_page(user_id):
    return {"id": user_id, "name": "Alice"}
```

### 파일 업로드 + 용량 제한 + 저장

```python
# config.py

class BaseConfig:
    MAX_CONTENT_LENGTH = 20 * 1024 * 1024  # 20MB
```

```python
@main_bp.post("/assets")
def upload_asset():
    f = request.files.get("asset")
    if not f or f.filename == "":
        return {"error": "no file"}, 400
    name = secure_filename(f.filename)
    (UPLOAD_DIR / name).parent.mkdir(parents=True, exist_ok=True)
    f.save(UPLOAD_DIR / name)
    return {"name": name}, 201
```

### 쿠키 로그인 + HttpOnly/SameSite 보안 설정

```python
from flask import make_response

@main_bp.post("/sessions")
def create_session():
    # idp 검증 성공했다고 가정
    sid = "s-abc123"
    resp = make_response({"ok": True})
    resp.set_cookie("sid", sid, httponly=True, secure=True, samesite="Lax", path="/")
    return resp
```

---

## pytest 테스트

### 클라이언트 픽스처

```python
# tests/conftest.py

import pytest
from app import create_app

@pytest.fixture()
def client():
    app = create_app("testing")
    return app.test_client()
```

### 라우팅/메서드/리다이렉트/쿠키 테스트

```python
def test_get_user(client):
    r = client.get("/users/123")
    assert r.status_code == 200
    assert r.get_json()["user_id"] == 123

def test_post_json(client):
    r = client.post("/api/items", json={"name": "book", "price": 80})
    assert r.status_code == 201
    data = r.get_json()
    assert data["name"] == "book"

def test_redirect_303(client):
    r = client.post("/signup", json={"email": "a@b.com"}, follow_redirects=False)
    assert r.status_code == 303
    assert "/users/" in r.headers["Location"]

def test_cookies(client):
    r = client.post("/sessions")
    assert r.status_code == 200
    # Set-Cookie 확인
    assert "sid=" in r.headers.get("Set-Cookie", "")
```

---

## 흔한 안티패턴

- **하드코딩 URL**: 템플릿·코드에서 문자열로 경로를 직접 쓰기 → `url_for()`로 치환
- **모든 POST를 302로**: 폼 제출 후 302 → 의도치 않은 메서드 변환 문제. 303을 사용
- **`force=True`로 JSON 파싱**: 클라이언트 버그 은닉. 개발 초반부터 Content-Type 준수
- **파일명을 그대로 저장**: 경로 traversal/덮어쓰기 위험 → `secure_filename()` 필수
- **쿠키 SameSite=None + Secure 미설정**: 최신 브라우저에서 차단됨
- **라우트 충돌**: `/users/me` vs `/users/<id>` 등록 순서/우선순위 미고려

---

## cURL로 로컬 확인(스니펫)

```bash
# GET

curl -i http://127.0.0.1:5000/hello

# POST JSON

curl -i -X POST http://127.0.0.1:5000/api/items \
  -H "Content-Type: application/json" \
  -d '{"name":"book","price":80}'

# 파일 업로드

curl -i -X POST http://127.0.0.1:5000/upload \
  -F "file=@/path/to/image.png"

# 쿠키 확인

curl -i -X POST http://127.0.0.1:5000/sessions
```

---

## 결론

이번 섹션에서는 Flask 애플리케이션의 핵심인 라우팅과 요청/응답 처리를 다루었습니다. URL 패턴 정의부터 타입 컨버터 사용, HTTP 메서드의 적절한 활용, 다양한 리다이렉트 코드의 의미, 그리고 Flask의 Request 객체를 통해 폼 데이터, JSON, 파일, 헤더, 쿠키를 어떻게 처리하는지 살펴보았습니다.

실무에서 중요한 것은 일관된 API 설계와 보안을 고려한 구현입니다. URL 설계 시 RESTful 원칙을 따르고, 사용자 입력은 항상 검증하며, 보안 취약점을 방지하기 위해 `secure_filename()` 같은 유틸리티를 활용해야 합니다. 또한 테스트를 통해 라우팅과 요청 처리가 예상대로 동작하는지 확인하는 것이 안정적인 애플리케이션 개발에 필수적입니다.

이러한 기초를 잘 다져두면 더 복잡한 비즈니스 로직을 구현하거나 성능 최적화를 진행할 때 훨씬 수월하게 진행할 수 있을 것입니다.