---
layout: post
title: 파이썬 - while 문
date: 2024-08-07 19:20:23 +0900
category: Python
---
# while 문

## 1. 기본 문법과 동작

```python
while 조건:
    실행할_코드
```

- **조건**: 매 반복마다 평가. `True`면 본문 실행 후 다시 조건 검사 / `False`면 종료.
- **본문**: 조건이 `True`인 동안 반복 실행되는 코드 블록.

### 예제: 1부터 5까지 출력
```python
i = 1
while i <= 5:
    print(i)
    i += 1
# 1 2 3 4 5
```

> **핵심**: 반복 변수 갱신(여기서는 `i += 1`)을 잊으면 **무한 루프**가 됩니다.

---

## 2. 사용자 입력으로 종료

```python
while True:
    user = input("종료하려면 'exit' 입력: ")
    if user == "exit":
        print("반복 종료!")
        break
```

- 사용자 인터랙션에서 가장 흔한 패턴: **무한 루프 + `break`로 종료**.

---

## 3. `while-else`의 정확한 의미

- `while`이 **조건이 거짓이 되어 정상 종료**하면 `else` 블록 실행.
- 반복 **도중 `break`를 만나면** `else`는 **실행되지 않음**.

```python
count = 0
while count < 3:
    print("반복 중:", count)
    count += 1
else:
    print("조건이 거짓이라 반복 종료")
# 반복 중: 0 / 1 / 2
# 조건이 거짓이라 반복 종료
```

```python
# 소수 찾기 예: 처음 발견하면 break, 못 찾고 끝나면 else
n = 17
d = 2
while d * d <= n:
    if n % d == 0:
        print("합성수")
        break
    d += 1
else:
    print("소수")
```

> `for-else`와 동일 규칙. **`break`가 한 번도 실행되지 않았을 때만 `else`가 실행**됩니다.

---

## 4. 무한 루프와 종료 조건

### 기본 무한 루프
```python
while True:
    # 작업
    break  # 특정 조건에서 종료
```

### 종료 조건(센티넬 값)로 끊기
```python
total = 0
while True:
    num = int(input("숫자 입력(0 종료): "))
    if num == 0:
        break
    total += num
print("합계:", total)
```

---

## 5. 제어 키워드: `break` / `continue`

### `break`: 즉시 루프 탈출
```python
i = 0
while i < 10:
    if i == 5:
        break
    print(i)
    i += 1
# 0 1 2 3 4
```

### `continue`: 현재 회차 건너뛰기
```python
i = 0
while i < 5:
    i += 1
    if i == 3:
        continue
    print(i)
# 1 2 4 5
```

> `continue`는 **아래 코드를 건너뛰고 조건 검사로 되돌아갑니다**.

---

## 6. 센티넬 루프(EOF/빈 값/특정 토큰)

**센티넬(sentinel)**: “여기서 끝!”을 나타내는 값.

```python
lines = []
while True:
    s = input("한 줄 입력(빈 줄로 종료): ").rstrip("\n")
    if s == "":           # 빈 줄이 센티넬
        break
    lines.append(s)
print(lines)
```

파일에서 **빈 바이트열**을 센티넬로 사용:

```python
from functools import partial

with open("data.bin", "rb") as f:
    for chunk in iter(partial(f.read, 4096), b""):
        process(chunk)   # b""(EOF) 나오면 자동 종료
```

> `iter(callable, sentinel)`은 **`callable()`을 계속 호출**하며 **반환값이 `sentinel`과 같아지면 종료**하는 고급 패턴입니다. `while`로도 구현 가능하지만 이 방식이 간결/안전.

---

## 7. 파일/스트림/네트워크 루프 패턴

### 7.1 파일 줄 단위 처리(권장: for-in)
```python
with open("log.txt", encoding="utf-8") as f:
    for line in f:                # 내부적으로 이터레이터 사용
        handle(line.rstrip("\n"))
```

### 7.2 while로 구현(명시적 읽기)
```python
with open("log.txt", encoding="utf-8") as f:
    while True:
        line = f.readline()
        if not line:              # EOF
            break
        handle(line.rstrip("\n"))
```

### 7.3 폴링(polling) + 휴식 간격
```python
import time, os

path = "queue"
while True:
    try:
        files = os.listdir(path)
        if files:
            process(files.pop())
        else:
            time.sleep(0.1)  # 과도한 폴링 방지
    except KeyboardInterrupt:
        print("사용자 종료")
        break
```

> **레이트 리밋**과 **백오프**(지수/선형)를 적절히 넣어 CPU 점유를 줄이세요.

---

## 8. 안전한 종료 · 예외 처리 · 리소스 정리

### 8.1 `try/finally`로 정리 보장
```python
resource = acquire()
try:
    while should_run():
        work(resource)
finally:
    release(resource)   # 예외/중단에도 실행
```

### 8.2 `KeyboardInterrupt` 핸들링
```python
try:
    while True:
        tick()
except KeyboardInterrupt:
    print("사용자 Ctrl+C, 종료 정리 중...")
    cleanup()
```

### 8.3 타임아웃/데드라인과 함께
```python
import time

deadline = time.monotonic() + 5.0  # 5초 제한
while time.monotonic() < deadline:
    if ready():
        do_work()
        break
else:
    print("타임아웃")
```

---

## 9. 성능 · 가독성 팁: `while` vs `for`

- **시퀀스/이터러블**을 순회할 땐 **`for`가 가독성·안전성·성능 모두 우수**.
- **조건 기반 반복**(예: “ready가 참일 동안”)엔 **`while`**이 자연스럽습니다.
- 루프 내부에서 **상태 갱신/탈출 조건**을 명확히 드러내세요(가드 변수/함수).

### 상태 갱신을 함수로 분리
```python
def step(state):
    state["i"] += 1
    return state["i"] < 10

state = {"i": 0}
while step(state):
    pass
```

---

## 10. 흔한 함정과 예방

### 10.1 반복 변수 갱신 누락 → 무한 루프
```python
i = 0
while i < 3:
    print(i)
    # i += 1 누락 시 영원히 0 출력
    i += 1
```

### 10.2 부동소수점 누적 비교
```python
# 위험: 부동소수점 오차로 종료 조건이 안 맞을 수 있음
x = 0.0
while x != 1.0:
    x += 0.1
    if x > 2: break  # 안전 장치
```
**대안**: 정수 카운터로 전환 후 스케일링
```python
i = 0
while i <= 10:
    x = i / 10
    print(x)
    i += 1
```

### 10.3 `while len(seq)` + 내부에서 seq 수정
- 인덱스/길이 변화로 논리 오류 가능 → **명확한 조건** 또는 **명시적 `break`** 사용.

### 10.4 `while`로 리스트 순회하며 삭제
```python
# 위험: 인덱스가 당겨져 일부 요소 건너뜀
i = 0
arr = [1,2,3,4]
while i < len(arr):
    if arr[i] % 2 == 0:
        del arr[i]
    else:
        i += 1
# 안전: 새 리스트 만들기
arr = [x for x in arr if x % 2]
```

### 10.5 바쁜 대기(busy wait)
- `while not ready(): pass` → CPU 100%
  **해결**: `time.sleep(…)`, 이벤트, 조건 변수, 큐 사용.

---

## 11. `while` + 할당표현식(월러스 연산자 `:=`)

**읽기→검사→사용**을 한 줄로 결합할 수 있습니다(3.8+).

```python
while (line := input(">> ").strip()):
    print("echo:", line)
print("빈 줄로 종료")
```

파일에서도 유용:
```python
with open("data.txt", encoding="utf-8") as f:
    while (line := f.readline()):
        consume(line.rstrip("\n"))
```

---

## 12. 루프 불변식(Loop Invariant)으로 검증하기

루프 불변식은 **루프 진입 전/각 반복 전후에 항상 참**이어야 하는 성질입니다.
예를 들어, 아래 루프는 **누적합**을 계산합니다.

```python
nums = [1,2,3,4]
i = 0
acc = 0
while i < len(nums):
    acc += nums[i]
    i += 1
print(acc)  # 10
```

이때 불변식:
$$
\text{반복 시작 시 } acc = \sum_{k=0}^{i-1} \text{nums}[k]
$$
- 초기: \(i=0\) → \(acc=0\) 참.
- 반복: 한 스텝에서 `acc += nums[i]` 후 `i += 1` → 여전히 성립.
- 종료: \(i = \text{len(nums)}\) → \(acc = \sum_{k=0}^{n-1} \text{nums}[k]\).

> 불변식으로 루프의 **정확성**을 사고하면, 경계/탈출 조건 버그를 줄일 수 있습니다.

---

## 13. 실전 예제 모음

### 13.1 입력 검증 + 재시도 + 제한
```python
import time

MAX_TRIES = 3
tries = 0
while tries < MAX_TRIES:
    s = input("정수 입력: ")
    try:
        n = int(s)
        print("OK:", n)
        break
    except ValueError:
        print("정수가 아닙니다. 다시 시도.")
        tries += 1
        time.sleep(0.1)
else:
    print("시도 초과")
```

### 13.2 진행률 표시(바쁜 대기 방지)
```python
import time, sys

total = 20
done = 0
while done < total:
    time.sleep(0.05)
    done += 1
    sys.stdout.write(f"\r진행률: {done}/{total}")
    sys.stdout.flush()
print("\n완료")
```

### 13.3 간단한 작업 큐(리스트 기반)
```python
queue = [1,2,3,4,5]
while queue:
    task = queue.pop(0)  # O(n) 주의. deque가 더 적합
    handle(task)
```

### 13.4 deque로 효율 개선
```python
from collections import deque

queue = deque([1,2,3,4,5])
while queue:
    task = queue.popleft()  # O(1)
    handle(task)
```

### 13.5 비동기/이벤트 대용(폴링 + 백오프)
```python
import time, random

delay = 0.1
while True:
    if random.random() < 0.2:  # 20% 확률로 일이 생겼다고 치자
        print("이벤트 처리!")
        break
    time.sleep(delay)
    delay = min(delay * 1.5, 2.0)  # 지수 백오프 (최대 2초)
```

### 13.6 안전한 자원 처리(try/finally)
```python
conn = open_connection()
try:
    while True:
        msg = conn.recv()
        if msg is None:
            break
        handle(msg)
finally:
    conn.close()
```

---

## 14. 요약 체크리스트

- **조건 기반 반복**에 적합: “~인 동안”
- **반복 변수 갱신**을 잊지 말 것(무한 루프 방지).
- **`while-else`**: `break` 없이 정상 종료될 때만 `else` 실행.
- **센티넬 패턴**: 빈 값/특정 토큰/EOF로 종료.
- **바쁜 대기 금지**: `sleep`, 이벤트/큐/조건변수 활용.
- 파일/스트림은 **이터러블**이므로 가능하면 `for`…`in` 사용.
- **예외/정리 보장**: `try/finally` 또는 컨텍스트 매니저.
- **부동소수점 종료 조건 주의**: 정수 카운터로 재구성.
- 큰 데이터/큐: **`deque`**로 팝/푸시 O(1) 보장.
- 단순 시퀀스 순회는 `for`, **상태/조건 반복은 `while`**이 자연스러움.
