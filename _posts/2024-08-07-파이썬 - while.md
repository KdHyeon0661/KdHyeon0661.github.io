---
layout: post
title: 파이썬 - while 문
date: 2024-08-07 19:20:23 +0900
category: Python
---
# while 문

`while` 문은 파이썬의 핵심 반복 구조 중 하나로, 주어진 조건이 참(`True`)인 동안 코드 블록을 반복적으로 실행합니다. `for` 문이 시퀀스나 이터러블 객체의 요소를 순회하는 데 적합하다면, `while` 문은 반복 횟수를 사전에 알 수 없는 조건 기반 반복에 특히 유용합니다.

## 기본 구조와 동작 원리

```python
while 조건:
    실행할_코드
```

`while` 문의 동작은 다음과 같습니다:
1. 조건을 평가하여 참(`True`)인지 확인합니다.
2. 조건이 참이면 코드 블록을 실행합니다.
3. 코드 블록 실행 후 다시 조건을 평가합니다.
4. 조건이 거짓(`False`)이 될 때까지 1-3단계를 반복합니다.

### 기본 예제: 카운터를 사용한 반복

```python
# 1부터 5까지 출력
i = 1
while i <= 5:
    print(i)
    i += 1  # 반복 변수 갱신 (중요!)
# 출력: 1 2 3 4 5
```

`while` 문을 사용할 때 가장 중요한 점은 **조건이 언젠가는 거짓이 되어야 한다**는 것입니다. 위 예제에서 `i += 1`을 생략하면 `i`는 항상 1이므로 조건 `i <= 5`는 항상 참이 되어 무한 루프에 빠집니다.

### 사용자 입력을 통한 반복 제어

```python
# 사용자가 '종료'를 입력할 때까지 계속 실행
while True:
    user_input = input("메시지를 입력하세요 (종료하려면 '종료' 입력): ")
    
    if user_input.lower() == "종료":
        print("프로그램을 종료합니다.")
        break
    
    print(f"입력한 메시지: {user_input}")
```

이 패턴은 사용자와 상호작용하는 프로그램에서 흔히 사용됩니다. 무한 루프(`while True`)로 시작하여 특정 조건(`break`)에서 탈출하는 방식입니다.

---

## while-else 구문의 의미와 활용

`while` 문에는 `else` 절을 추가할 수 있으며, 이는 특별한 의미를 가집니다:
- `while` 블록이 **정상적으로 종료**되었을 때(조건이 거짓이 되어서) `else` 블록이 실행됩니다.
- `while` 블록 안에서 **`break` 문에 의해 강제 종료**되었을 때는 `else` 블록이 실행되지 않습니다.

```python
# while-else의 기본 동작
count = 0
while count < 3:
    print(f"반복 중: {count}")
    count += 1
else:
    print("조건이 거짓이 되어 반복이 종료되었습니다.")
# 출력:
# 반복 중: 0
# 반복 중: 1
# 반복 중: 2
# 조건이 거짓이 되어 반복이 종료되었습니다.

# break로 종료하는 경우
count = 0
while count < 5:
    if count == 3:
        print("조건에 따라 반복을 중단합니다.")
        break
    print(count)
    count += 1
else:
    print("이 메시지는 출력되지 않습니다.")
# 출력:
# 0
# 1
# 2
# 조건에 따라 반복을 중단합니다.
```

### 실용적 예제: 소수 판별

```python
def is_prime(n):
    """주어진 수가 소수인지 판별"""
    if n < 2:
        return False
    
    divisor = 2
    while divisor * divisor <= n:
        if n % divisor == 0:
            return False  # 합성수 발견
        divisor += 1
    
    return True  # 모든 검사를 통과하면 소수

# 테스트
numbers = [2, 3, 4, 17, 20, 29]
for num in numbers:
    if is_prime(num):
        print(f"{num}은(는) 소수입니다.")
    else:
        print(f"{num}은(는) 소수가 아닙니다.")
```

---

## 반복 제어 키워드: break와 continue

### break: 반복 즉시 종료

`break` 문은 현재 실행 중인 반복문을 즉시 종료하고, 반복문 다음의 코드로 이동합니다.

```python
# 10보다 큰 첫 번째 숫자 찾기
numbers = [5, 8, 12, 3, 15, 7]
index = 0

while index < len(numbers):
    if numbers[index] > 10:
        print(f"10보다 큰 첫 번째 숫자: {numbers[index]}")
        break
    index += 1
else:
    print("10보다 큰 숫자를 찾지 못했습니다.")
```

### continue: 현재 반복 건너뛰기

`continue` 문은 현재 반복의 나머지 코드를 건너뛰고, 다음 반복으로 바로 이동합니다.

```python
# 홀수만 출력하기
count = 0
while count < 10:
    count += 1
    
    if count % 2 == 0:  # 짝수인 경우
        continue        # 나머지 코드 건너뛰기
    
    print(count)        # 홀수만 출력
# 출력: 1 3 5 7 9
```

**주의사항**: `while` 문에서 `continue`를 사용할 때는 반복 변수의 갱신 위치에 주의해야 합니다. 만약 `continue`가 반복 변수 갱신 전에 실행되면 무한 루프에 빠질 수 있습니다.

```python
# 올바른 사용
count = 0
while count < 5:
    count += 1        # 먼저 갱신
    if count == 3:
        continue
    print(count)

# 위험한 사용 (count == 3에서 무한 루프)
# count = 0
# while count < 5:
#     if count == 3:
#         continue    # 갱신되지 않아서 count는 계속 3
#     print(count)
#     count += 1
```

---

## 센티넬 값 패턴을 활용한 반복 제어

센티넬(sentinel) 값은 "여기서 끝"을 나타내는 특별한 값으로, 반복의 종료 조건으로 자주 사용됩니다.

### 사용자 입력에서의 센티넬 패턴

```python
# 빈 문자열을 센티넬 값으로 사용
lines = []
print("텍스트를 입력하세요 (빈 줄에서 종료):")

while True:
    line = input()
    if line == "":  # 빈 줄 = 센티넬 값
        break
    lines.append(line)

print(f"\n입력한 내용 ({len(lines)}줄):")
for i, line in enumerate(lines, 1):
    print(f"{i}: {line}")
```

### 파일 처리에서의 센티넬 패턴

```python
# iter() 함수와 센티넬을 활용한 우아한 파일 읽기
from functools import partial

def process_file(filename, chunk_size=4096):
    """대용량 파일을 청크 단위로 처리"""
    with open(filename, 'rb') as file:
        # b''(빈 바이트열)이 나올 때까지 파일 읽기 반복
        for chunk in iter(partial(file.read, chunk_size), b''):
            process_chunk(chunk)  # 각 청크 처리
```

---

## while 문의 다양한 활용 패턴

### 조건 기반 폴링(Polling)

```python
import time
import random

# 외부 상태 변화를 주기적으로 확인하는 패턴
def wait_for_condition(timeout=30, check_interval=0.5):
    """특정 조건이 충족될 때까지 대기"""
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        # 조건 확인 (예: 파일 존재, 네트워크 응답 등)
        if condition_is_met():
            return True
        
        # CPU 사용을 줄이기 위한 대기
        time.sleep(check_interval)
    
    return False  # 타임아웃

# 시뮬레이션: 무작위 조건
def condition_is_met():
    """랜덤으로 조건 충족 여부 결정 (실제로는 특정 상태 확인)"""
    return random.random() > 0.8  # 20% 확률로 True
```

### 작업 큐 처리

```python
from collections import deque

def process_task_queue(tasks):
    """작업 큐를 처리하는 일반적인 패턴"""
    task_queue = deque(tasks)
    processed_count = 0
    
    while task_queue:  # 큐가 비어있지 않은 동안
        task = task_queue.popleft()  # 다음 작업 가져오기
        
        try:
            result = execute_task(task)
            print(f"작업 '{task}' 완료: {result}")
            processed_count += 1
        except Exception as e:
            print(f"작업 '{task}' 실패: {e}")
            # 실패한 작업 재시도 또는 로깅
    
    print(f"총 {processed_count}개 작업 처리 완료")

def execute_task(task):
    """작업 실행 (시뮬레이션)"""
    import time
    time.sleep(0.1)  # 작업 소요 시간 시뮬레이션
    return f"결과_{task}"
```

### 실시간 모니터링

```python
import time
import psutil  # 시스템 모니터링 라이브러리

def monitor_system(duration=60):
    """시스템 자원 사용량 모니터링"""
    print("시스템 모니터링 시작... (Ctrl+C로 종료)")
    
    try:
        end_time = time.time() + duration
        while time.time() < end_time:
            # CPU 사용률
            cpu_percent = psutil.cpu_percent(interval=1)
            
            # 메모리 사용률
            memory = psutil.virtual_memory()
            
            # 디스크 사용률
            disk = psutil.disk_usage('/')
            
            print(f"CPU: {cpu_percent:.1f}% | "
                  f"메모리: {memory.percent:.1f}% | "
                  f"디스크: {disk.percent:.1f}%")
            
    except KeyboardInterrupt:
        print("\n모니터링 사용자 종료")
```

---

## 흔한 실수와 모범 사례

### 1. 무한 루프 방지

가장 흔한 실수는 반복 조건이 영원히 참이 되어 무한 루프에 빠지는 경우입니다.

```python
# 잘못된 예: 갱신 누락
# i = 0
# while i < 10:
#     print(i)  # i는 항상 0, 무한 루프!

# 올바른 예
i = 0
while i < 10:
    print(i)
    i += 1  # 반드시 갱신
```

### 2. 부동소수점 비교 문제

부동소수점 숫자를 반복 조건으로 사용할 때는 정밀도 문제를 고려해야 합니다.

```python
# 위험한 예: 부동소수점 오차로 무한 루프 가능성
# x = 0.0
# while x != 1.0:  # 정확히 1.0이 될 수 없음
#     x += 0.1

# 안전한 예: 정수 카운터 사용
steps = 10
i = 0
while i <= steps:
    x = i / steps  # 0.0, 0.1, 0.2, ..., 1.0
    print(f"{i}/{steps}: {x:.1f}")
    i += 1
```

### 3. 리스트 순회 중 수정

`while` 문으로 리스트를 순회하면서 동시에 수정하는 것은 위험합니다.

```python
# 위험한 예: 인덱스 문제 발생 가능
numbers = [1, 2, 3, 4, 5, 6]
i = 0
while i < len(numbers):
    if numbers[i] % 2 == 0:  # 짝수인 경우
        del numbers[i]       # 삭제하면 인덱스가 당겨짐
    else:
        i += 1               # 홀수일 때만 인덱스 증가
# 결과 예측 불가!

# 안전한 예 1: 새 리스트 생성
numbers = [1, 2, 3, 4, 5, 6]
filtered = [x for x in numbers if x % 2 != 0]
print(filtered)  # [1, 3, 5]

# 안전한 예 2: 뒤에서부터 처리
numbers = [1, 2, 3, 4, 5, 6]
i = len(numbers) - 1
while i >= 0:
    if numbers[i] % 2 == 0:
        del numbers[i]
    i -= 1
print(numbers)  # [1, 3, 5]
```

### 4. 바쁜 대기(Busy Waiting) 피하기

조건이 충족될 때까지 CPU를 100% 사용하는 바쁜 대기는 피해야 합니다.

```python
# 나쁜 예: CPU 자원 낭비
# while not is_ready():
#     pass  # CPU를 100% 사용

# 좋은 예: 적절한 대기 시간
import time

while not is_ready():
    time.sleep(0.1)  # CPU 부하 줄이기
```

---

## 고급 패턴과 기법

### 할당 표현식 활용 (Python 3.8+)

월러스 연산자(`:=`)를 사용하면 조건 평가와 변수 할당을 한 줄로 결합할 수 있습니다.

```python
# 파일에서 줄 단위 읽기
with open('data.txt', 'r', encoding='utf-8') as file:
    while (line := file.readline().rstrip('\n')):
        print(f"> {line}")

# 사용자 입력 처리
while (command := input("명령어 입력 (종료: quit) > ")) != "quit":
    print(f"실행: {command}")
print("프로그램 종료")
```

### 루프 불변식(Loop Invariant)을 활용한 코드 검증

루프 불변식은 반복문의 정확성을 이해하고 검증하는 데 도움이 되는 개념입니다.

```python
def binary_search(arr, target):
    """
    이진 검색 알고리즘
    불변식: target이 존재한다면 arr[left..right] 구간에 존재
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid  # 찾음
        elif arr[mid] < target:
            left = mid + 1  # 오른쪽 반으로 좁힘
        else:
            right = mid - 1  # 왼쪽 반으로 좁힘
    
    return -1  # 찾지 못함

# 불변식 확인:
# 1. 초기: left=0, right=n-1이므로 전체 배열 검색
# 2. 유지: 매 반복마다 검색 범위를 절반으로 줄이면서 불변식 유지
# 3. 종료: 범위가 비거나(target 찾음) left > right(못 찾음)
```

### 컨텍스트 매니저와 함께 사용

```python
import sqlite3

# 데이터베이스 작업 패턴
def process_records(db_path, batch_size=100):
    """대량의 데이터베이스 레코드 처리"""
    with sqlite3.connect(db_path) as conn:
        cursor = conn.cursor()
        
        # 더 처리할 레코드가 있는 동안 반복
        has_more = True
        while has_more:
            cursor.execute(
                "SELECT id, data FROM records WHERE processed = 0 LIMIT ?",
                (batch_size,)
            )
            batch = cursor.fetchall()
            
            if not batch:
                has_more = False
                continue
            
            # 배치 처리
            for record_id, data in batch:
                process_record(data)
                cursor.execute(
                    "UPDATE records SET processed = 1 WHERE id = ?",
                    (record_id,)
                )
            
            conn.commit()  # 주기적 커밋
            print(f"{len(batch)}개 레코드 처리 완료")
```

---

## while vs for: 적절한 선택 가이드

### while 문이 더 적합한 경우

1. **반복 횟수를 사전에 알 수 없는 경우**
   ```python
   # 사용자 입력 기반 반복
   while True:
       response = input("계속하시겠습니까? (y/n): ")
       if response.lower() == 'n':
           break
   ```

2. **복잡한 조건에 의존하는 경우**
   ```python
   # 여러 조건의 조합
   attempts = 0
   success = False
   while attempts < 3 and not success:
       success = try_operation()
       attempts += 1
   ```

3. **상태 기반 반복이 필요한 경우**
   ```python
   # 게임 루프
   game_running = True
   while game_running:
       handle_input()
       update_game_state()
       render_graphics()
       game_running = check_game_over()
   ```

### for 문이 더 적합한 경우

1. **시퀀스나 이터러블의 모든 요소를 순회할 때**
   ```python
   # 리스트 순회
   for item in my_list:
       process(item)
   
   # 범위 순회
   for i in range(10):
       print(i)
   ```

2. **반복 횟수가 명확한 경우**
   ```python
   # 정해진 횟수만큼 반복
   for _ in range(5):
       print("Hello")
   ```

3. **컬렉션의 요소에만 관심이 있는 경우**
   ```python
   # 딕셔너리 순회
   for key, value in my_dict.items():
       print(f"{key}: {value}")
   ```

### 하이브리드 접근법

때로는 두 방식을 조합하는 것이 가장 효과적입니다.

```python
def find_pattern_in_files(filenames, pattern):
    """여러 파일에서 패턴 검색"""
    for filename in filenames:          # for: 파일 목록 순회
        try:
            with open(filename, 'r') as file:
                line_number = 1
                while (line := file.readline()):  # while: 파일 끝까지 줄 읽기
                    if pattern in line:
                        print(f"{filename}:{line_number}: {line.strip()}")
                    line_number += 1
        except FileNotFoundError:
            print(f"파일을 찾을 수 없음: {filename}")
```

---

## 결론

`while` 문은 파이썬에서 조건 기반 반복을 구현하는 강력한 도구입니다. 올바르게 사용하면 유연하고 효율적인 코드를 작성할 수 있지만, 잘못 사용하면 무한 루프나 예측하기 어려운 버그를 초래할 수 있습니다.

**핵심 요약**:

1. **조건의 변화를 보장하라**: 모든 `while` 루프에는 조건이 거짓이 될 가능성이 있어야 합니다. 반복 변수의 갱신이나 외부 조건 변화를 통해 이를 보장하세요.

2. **적절한 도구 선택**: 시퀀스 순회에는 `for`를, 조건 기반 반복에는 `while`을 선택하세요. 때로는 두 가지를 조합하는 것이 최선입니다.

3. **리소스 관리에 신경 쓰라**: 무한 루프를 방지하고, 바쁜 대기를 피하며, 예외 상황에서도 자원이 정리되도록 하세요.

4. **가독성을 우선시하라**: 복잡한 `while` 루프는 함수로 분리하거나 주석을 추가하여 의도를 명확히 하세요.

5. **패턴을 익혀라**: 센티넬 값, 폴링, 작업 큐 처리 등 일반적인 패턴을 익히면 유사한 문제에 효율적으로 접근할 수 있습니다.

`while` 문을 마스터하는 것은 반복적인 작업을 자동화하고, 복잡한 논리를 구현하며, 다양한 문제를 해결하는 데 필수적입니다. 조건 설정, 반복 제어, 예외 처리 등을 신중히 고려하여 견고하고 효율적인 코드를 작성하세요.