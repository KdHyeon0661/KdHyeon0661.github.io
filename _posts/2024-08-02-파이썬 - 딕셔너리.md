---
layout: post
title: 파이썬 - 딕셔너리
date: 2024-08-02 19:20:23 +0900
category: Python
---
# 딕셔너리(Dictionary)

파이썬의 **딕셔너리(dict)**는 **키(key)–값(value)** 쌍을 저장하는 **가변(mutable)·해시 기반 매핑 타입**입니다.  
중괄호 `{}` 혹은 `dict()`로 생성하며, **키는 고유**해야 하고 **불변(해시 가능)** 이어야 합니다.

> 파이썬 3.7+에서 딕셔너리는 **삽입 순서를 보존**합니다(사양 보장).  
> 즉, 반복(`for k in d`)하면 **넣은 순서대로** 나옵니다.

```python
my_dict = {
    "name": "John",
    "age": 30,
    "city": "New York",
}
```

---

## 1. 핵심 개념 요약

- **키 고유성**: 같은 키를 두 번 넣으면 **나중 값이 덮어씀**.
- **순서 보존(3.7+)**: 삽입 순서대로 순회/`popitem()`은 기본적으로 **마지막**을 꺼냄(LIFO).
- **가변**: 값 변경/추가/삭제 가능. 키 자체는 변경 불가(키는 불변형이어야 함).
- **시간 복잡도(평균)**: 조회/삽입/삭제 **평균 O(1)**. (해시 충돌 많으면 최악 O(n))

---

## 2. 생성과 기본 조작

### (1) 생성
```python
d1 = {}                                   # 빈 딕셔너리
d2 = dict()                               # 빈 딕셔너리
d3 = {"a": 1, "b": 2}                     # 리터럴
d4 = dict([("a", 1), ("b", 2)])           # (키,값) 시퀀스
d5 = dict(a=1, b=2)                       # 키가 식별자일 때만
```

### (2) 조회 / 추가 / 수정
```python
person = {"name": "Alice", "age": 25}
print(person["name"])         # 'Alice' (키 없으면 KeyError)

# 안전 조회
print(person.get("job"))                  # None
print(person.get("job", "N/A"))           # 'N/A'

# 추가/수정(동일 문법)
person["job"] = "Engineer"                # 추가
person["age"] = 26                        # 수정
```

### (3) 삭제
```python
person.pop("job")             # 값 반환하며 제거 (없으면 KeyError)
person.pop("job", None)       # 안전 제거 (없으면 None 반환)
last_kv = person.popitem()    # (키, 값) 한 쌍 제거 — 기본 LIFO
del person["age"]             # 키로 삭제
person.clear()                # 전체 비우기
```

---

## 3. 딕셔너리 뷰와 반복

뷰는 **동적**입니다(원본 변경이 뷰에 반영).

```python
d = {"x": 1, "y": 2, "z": 3}
print(d.keys())               # dict_keys(['x','y','z'])
print(d.values())             # dict_values([1,2,3])
print(d.items())              # dict_items([('x',1), ...])

for k in d:                   # 기본은 키
    print(k, d[k])

for k, v in d.items():
    print(k, v)
```

---

## 4. 주요 메서드 총정리(+ 주의점)

| 메서드/연산 | 설명 | 예시 |
|---|---|---|
| `get(k, default=None)` | 안전 조회 | `d.get("k", 0)` |
| `setdefault(k, default=None)` | 키 없으면 `default`로 추가하고 그 값을 반환 | `counts.setdefault(w, 0); counts[w]+=1` |
| `update(other, **kw)` | 다른 매핑/키워드로 병합 (덮어씀) | `d.update({"a":1}, b=2)` |
| `pop(k[, default])` | 키 제거+값 반환 | `d.pop("a", None)` |
| `popitem()` | 마지막 (키,값) 제거+반환(LIFO) | `k, v = d.popitem()` |
| `clear()` | 전부 삭제 | `d.clear()` |
| `keys()/values()/items()` | 동적 뷰 반환 | `for k in d.keys(): ...` |
| `copy()` | 얕은 복사 | `d2 = d.copy()` |
| `fromkeys(keys, value=None)` | 동일 값으로 초기화 | `dict.fromkeys(['a','b'], 0)` |

> **`setdefault` 패턴**은 카운팅/그룹핑에 유용하지만, 성능은 `defaultdict`가 더 좋습니다.

---

## 5. 병합 연산자(PEP 584, 3.9+)

- **`|`**: 새 딕셔너리 반환(우측이 우선)
- **`|=`**: 제자리 병합

```python
a = {"x": 1, "y": 2}
b = {"y": 9, "z": 3}
c = a | b             # {'x':1, 'y':9, 'z':3}  (a는 불변)
a |= b                 # a가 {'x':1, 'y':9, 'z':3} 로 변경
```

> 기존 `update()`와 동일한 덮어쓰기 규칙. `|`는 **새 객체**를 돌려준다는 점이 편리합니다.

---

## 6. 키(해시 가능성)와 불변성

- 키는 **해시 가능(hashable)** 해야 합니다.  
  즉, **불변**이며 `__hash__`가 정의되고, `__eq__` 일관성을 유지해야 함.
- 숫자·문자열·불변 튜플(내부까지 불변) 등 OK. 리스트/딕셔너리/집합 **불가**.

```python
good = {("row", 1): "ok"}     # 튜플 키 OK
# bad = {[1,2]: "x"}          # TypeError: 리스트는 키 불가
# bad = { (1, [2,3]): "x"}    # 내부에 리스트가 있어도 불가
```

> **커스텀 객체를 키로** 쓰려면 `__hash__`/`__eq__`를 올바르게 구현해야 합니다.

---

## 7. 얕은 복사 vs 깊은 복사

```python
import copy

d = {"a": [1, 2], "b": {"x": 1}}
shallow = d.copy()             # 얕은 복사 (내부 참조 공유)
deep    = copy.deepcopy(d)     # 깊은 복사 (내부까지 새 객체)

d["a"].append(99)
print(shallow["a"])            # [1, 2, 99]  ← 영향 받음
print(deep["a"])               # [1, 2]
```

---

## 8. 순서 보존과 연산 동작(3.7+)

- **삽입 순서 보존**: `for k in d`는 넣은 순서대로.
- **`popitem()`**: 마지막 쌍을 꺼냄(스택처럼).
- **정렬 필요**: 별도로 `sorted(d.items(), key=...)`를 사용.

```python
d = {}
for c in "dbca":
    d[c] = ord(c)
print(list(d))                 # ['d','b','c','a']
print(sorted(d))               # ['a','b','c','d'] — 키 정렬
```

---

## 9. 딕셔너리 내포(dict comprehension)

```python
squares = {x: x*x for x in range(5)}              # {0:0, 1:1, 2:4, ...}
filtered = {k: v for k, v in squares.items() if v % 2 == 0}
inverse  = {v: k for k, v in squares.items()}     # 값→키 역매핑 (값 유일해야 안전)
```

---

## 10. 컬렉션스와의 연계

### (1) `defaultdict` — 기본값 자동 할당
```python
from collections import defaultdict

# 리스트로 그룹핑
group = defaultdict(list)
for name, klass in [("kim","A"), ("lee","B"), ("park","A")]:
    group[klass].append(name)

print(group["A"])   # ['kim','park'] (없던 키 접근 시 자동으로 빈 리스트 생성)
```

### (2) `Counter` — 빈도수 집계
```python
from collections import Counter
cnt = Counter("bananaban")
print(cnt.most_common(2))   # [('a',4), ('b',2)] 등
```

### (3) `OrderedDict` — (과거) 순서가 중요한 dict
> 3.7+에서는 기본 dict가 삽입 순서를 보존하므로 대부분 불필요.  
> 다만 **동등성/비교 의미** 차이가 필요할 때만 사용.

---

## 11. 패턴 모음(실전)

### 11.1 안전 조회/증가(카운팅)
```python
words = ["a","b","a","c","a","b"]
count = {}
for w in words:
    count[w] = count.get(w, 0) + 1
```
> 대규모면 `Counter(words)`가 더 간결/빠름.

### 11.2 다중 레벨 중첩 구조 초기화
```python
from collections import defaultdict
tree = lambda: defaultdict(tree)
d = tree()
d["users"]["kim"]["score"] = 10
# 중간 레벨 자동 생성
```

### 11.3 설정 레이어 병합(기본→환경→사용자)
```python
base = {"timeout": 30, "retry": 2, "host": "localhost"}
env  = {"retry": 5}
user = {"host": "db.example.com"}

cfg = base | env | user
# {'timeout':30, 'retry':5, 'host':'db.example.com'}
```

### 11.4 역인덱스(값→키 목록)
```python
data = {"alice": "A", "bob": "B", "charlie": "A"}
index = {}
for name, klass in data.items():
    index.setdefault(klass, []).append(name)
# {'A':['alice','charlie'], 'B':['bob']}
```

### 11.5 키 존재 체크 vs 진리값 체크
```python
d = {"count": 0}
print("count" in d)         # True (키 존재)
print(bool(d.get("count"))) # False (값이 0 → Falsy)
```
> “0도 유효”라면 `in`을 쓰세요.

### 11.6 JSON 직렬화 시 주의(키는 문자열 권장)
```python
import json
d = {1: "one"}              # 숫자 키
s = json.dumps(d)           # '{"1":"one"}'  ← 문자열화됨
print(json.loads(s))        # {'1': 'one'}   ← 키가 문자열로 바뀜
```

---

## 12. 성능 팁과 내부 동작 감각

- 해시 테이블 기반: 평균 O(1) 조회/삽입/삭제. **해시 충돌**이 많으면 성능 저하.
- 키로 자주 쓰는 객체는 **불변/짧은 비교**가 유리. 문자열은 **인터닝**을 활용하면 키 비교 비용 감소.
- 반복 병합은 `update`/`|=`가 `for` 루프보다 빠름(내부 최적화).
- 필요 시 **딕셔너리 크기**는 키/값 객체 크기를 포함하지 않음(`sys.getsizeof(d)`).

```python
import sys
d = {i: str(i) for i in range(1000)}
print(sys.getsizeof(d))      # 구현/플랫폼에 따라 상이
```

---

## 13. 오류/엣지 케이스

```python
d = {"a": 1}
# d["x"]           # KeyError
print(d.get("x"))  # None

# 존재 확인 후 삭제
if "a" in d:
    del d["a"]

# pop 안전 사용
d.pop("missing", None)       # 존재하지 않아도 예외 없음
```

---

## 14. 타입 힌트(PEP 585)

```python
def fetch(ids_to_name: dict[int, str]) -> None:
    for i, name in ids_to_name.items():
        ...
```

가변 길이 키/값 형태는 `dict[KT, VT]`.  
중첩 구조는 `dict[str, dict[str, int]]`처럼 기술.

---

## 15. 종합 예제

### 15.1 로그 파싱 → 구조화 → 통계
```python
logs = [
    "ts=2025-11-10 level=INFO user=alice action=login",
    "ts=2025-11-10 level=INFO user=bob action=login",
    "ts=2025-11-10 level=ERROR user=alice action=timeout",
]

def parse_kv(line: str) -> dict[str, str]:
    out: dict[str, str] = {}
    for part in line.split():
        if "=" in part:
            k, v = part.split("=", 1)
            out[k] = v
    return out

parsed = [parse_kv(x) for x in logs]

from collections import Counter, defaultdict
by_user = defaultdict(int)
by_level = Counter(p["level"] for p in parsed)
for p in parsed:
    by_user[p["user"]] += 1

print(by_level)  # Counter({'INFO':2, 'ERROR':1})
print(dict(by_user))  # {'alice':2, 'bob':1}
```

### 15.2 데이터 정규화(키 표준화 + 병합)
```python
raw = [
    {"User": "kim", "Age": 30},
    {"user": "lee", "age": 25, "city": "Seoul"},
]

def canonicalize(d: dict) -> dict:
    map_key = {"User":"user", "Age":"age"}  # 매핑 테이블
    return { map_key.get(k, k).lower(): v for k, v in d.items() }

canon = [canonicalize(r) for r in raw]
merged = {}
for r in canon:
    key = r["user"]
    merged[key] = merged.get(key, {}) | r

print(merged)
# {'kim': {'user': 'kim', 'age': 30},
#  'lee': {'user': 'lee', 'age': 25, 'city': 'Seoul'}}
```

---

## 16. 보안/신뢰성 메모

- **민감 토큰 비교**는 `==` 대신 **상수시간 비교** `hmac.compare_digest()` 사용.
- 신뢰할 수 없는 입력을 `eval`로 딕셔너리 변환 금지.  
  JSON은 `json.loads()`, 리터럴은 `ast.literal_eval()` 사용.

```python
import hmac
print(hmac.compare_digest("abc", "abd"))  # False
```

---

## 17. 요약 체크리스트

- **키는 해시 가능**(불변): 숫자/문자열/불변 튜플 등만.
- **안전 조회**: `get`, **카운트/그룹핑**: `defaultdict`/`Counter`.
- **병합**: 3.9+ `|`/`|=`, 기존 `update`와 동일 규칙(우측 우선).
- **순서 보존**(3.7+), `popitem()`은 기본 **마지막**을 꺼냄.
- **얕은/깊은 복사** 구분: 중첩 구조에는 `deepcopy`.
- **성능**: 평균 O(1), 키/해시/충돌에 유의. 대량 병합은 내장 메서드 사용.

---

# 부록: 빠른 레퍼런스

```python
# 생성
d = {"a":1}; d = dict(a=1); d = dict([("a",1)])

# 조회
v = d["a"]; v = d.get("a", default)

# 추가/수정
d["x"] = 10

# 삭제
d.pop("x", None); del d["a"]; d.clear()

# 뷰/반복
for k in d.keys(): ...
for v in d.values(): ...
for k, v in d.items(): ...

# 병합
d3 = d1 | d2; d1 |= d2; d1.update(d2, z=3)

# 내포
inv = {v:k for k, v in d.items()}

# 기본값 패턴
d.setdefault("k", []).append(1)

# 깊은 복사
import copy
deep = copy.deepcopy(d)
```