---
layout: post
title: 파이썬 - 딕셔너리
date: 2024-08-02 19:20:23 +0900
category: Python
---
# 딕셔너리(Dictionary)

파이썬의 **딕셔너리(dict)**는 **키(key)-값(value)** 쌍을 저장하는 유연하고 강력한 자료구조입니다. 다른 프로그래밍 언어에서는 해시맵, 연관 배열, 맵 등으로 불리는 이 구조는 데이터를 이름으로 접근하고 조직화하는 데 탁월한 성능을 발휘합니다. 파이썬 3.7 이상에서는 삽입 순서가 보장되어 예측 가능한 순회가 가능하며, 내부 해시 테이블 구현으로 평균 O(1) 시간 복잡도의 빠른 조회를 제공합니다.

```python
# 딕셔너리의 기본 구조
person = {
    "name": "김철수",
    "age": 30,
    "city": "서울",
    "hobbies": ["독서", "등산", "사진"]
}
```

## 딕셔너리의 생성과 기본 특징

딕셔너리를 생성하는 방법은 여러 가지가 있으며, 상황에 따라 적절한 방법을 선택할 수 있습니다.

```python
# 다양한 생성 방법
empty_dict = {}                    # 빈 딕셔너리
empty_dict2 = dict()               # dict() 생성자 사용
user = {"name": "이영희", "age": 25}  # 리터럴 직접 선언
config = dict(host="localhost", port=8080)  # 키워드 인자 사용
pairs = [("a", 1), ("b", 2), ("c", 3)]
from_pairs = dict(pairs)           # (키, 값) 쌍의 시퀀스로 생성

# zip을 활용한 생성
keys = ["name", "age", "city"]
values = ["박지민", 28, "부산"]
zipped_dict = dict(zip(keys, values))
```

딕셔너리의 핵심 특징은 다음과 같습니다:

1. **키는 고유해야 함**: 동일한 키를 가진 항목이 여러 개일 경우 마지막 값이 저장됩니다.
2. **키는 불변해야 함**: 문자열, 숫자, 튜플(내부 요소도 불변인 경우) 등 해시 가능한 객체만 키로 사용할 수 있습니다.
3. **값은 어떤 타입도 가능**: 숫자, 문자열, 리스트, 다른 딕셔너리, 사용자 정의 객체 등 모든 파이썬 객체를 값으로 저장할 수 있습니다.
4. **가변 객체**: 생성 후에도 항목을 추가, 수정, 삭제할 수 있습니다.

## 딕셔너리의 기본 연산과 메서드

### 항목 접근과 수정

```python
# 기본 접근
student = {"name": "홍길동", "score": 85}
print(student["name"])        # "홍길동"

# 존재하지 않는 키 접근 시 (주의)
# print(student["grade"])     # KeyError 발생

# 안전한 접근 방법
grade = student.get("grade")          # 키가 없으면 None 반환
grade = student.get("grade", "A")     # 키가 없으면 기본값 "A" 반환

# 항목 추가와 수정
student["grade"] = "A+"               # 새 항목 추가
student["score"] = 90                 # 기존 항목 수정

# in 연산자로 키 존재 확인
if "name" in student:
    print("이름 정보가 있습니다.")

# setdefault: 키가 없으면 설정 후 반환
counts = {}
for word in ["apple", "banana", "apple", "orange"]:
    counts.setdefault(word, 0)
    counts[word] += 1
print(counts)  # {'apple': 2, 'banana': 1, 'orange': 1}
```

### 항목 삭제와 관리

```python
inventory = {"apple": 10, "banana": 5, "orange": 8}

# pop: 키로 항목 삭제 (값 반환)
apple_count = inventory.pop("apple")
print(f"사과 {apple_count}개 제거, 남은 항목: {inventory}")

# popitem: 마지막 항목 삭제 (파이썬 3.7+에서는 삽입 순서)
last_item = inventory.popitem()
print(f"마지막 항목 제거: {last_item}, 남은 항목: {inventory}")

# del 문으로 삭제
del inventory["banana"]

# clear: 모든 항목 삭제
inventory.clear()
print(f"빈 딕셔너리: {inventory}")
```

### 딕셔너리 뷰 객체

딕셔너리의 `keys()`, `values()`, `items()` 메서드는 뷰 객체를 반환합니다. 이 뷰 객체는 원본 딕셔너리의 실시간 뷰를 제공합니다.

```python
data = {"a": 1, "b": 2, "c": 3}

# 뷰 객체 생성
keys_view = data.keys()
values_view = data.values()
items_view = data.items()

print(list(keys_view))   # ['a', 'b', 'c']
print(list(values_view)) # [1, 2, 3]
print(list(items_view))  # [('a', 1), ('b', 2), ('c', 3)]

# 뷰 객체의 동적 특성
data["d"] = 4
print(list(keys_view))   # ['a', 'b', 'c', 'd'] (자동 업데이트)

# 효율적인 순회
for key in data:                     # keys() 생략 가능
    print(f"{key}: {data[key]}")

for key, value in data.items():      # 키와 값 함께 순회
    print(f"{key} = {value}")
```

## 딕셔너리 병합과 업데이트

파이썬 3.9부터는 딕셔너리 병합 연산자가 도입되어 더욱 직관적인 병합이 가능해졌습니다.

```python
# 딕셔너리 병합 방법들
defaults = {"theme": "dark", "language": "ko"}
user_prefs = {"language": "en", "font_size": 14}
system_config = {"timeout": 30}

# 방법 1: update() 메서드 (기존 방식)
config = defaults.copy()
config.update(user_prefs)
config.update(system_config)

# 방법 2: 언패킹 연산자 (Python 3.5+)
config = {**defaults, **user_prefs, **system_config}

# 방법 3: 병합 연산자 (Python 3.9+, 권장)
config = defaults | user_prefs | system_config

# 방법 4: 제자리 병합 연산자 (Python 3.9+)
defaults |= user_prefs  # defaults를 직접 수정

print(config)
# {'theme': 'dark', 'language': 'en', 'font_size': 14, 'timeout': 30}
# 주의: 중복 키는 뒤에 오는 딕셔너리의 값으로 덮어씌워짐
```

## 딕셔너리 내포 (Dictionary Comprehension)

리스트 내포와 유사하게 딕셔너리도 간결한 구문으로 생성할 수 있습니다.

```python
# 기본 딕셔너리 내포
squares = {x: x*x for x in range(1, 6)}
print(squares)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# 조건문이 포함된 딕셔너리 내포
even_squares = {x: x*x for x in range(10) if x % 2 == 0}
print(even_squares)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

# 두 딕셔너리를 결합하며 변환
prices = {"apple": 1000, "banana": 500, "orange": 800}
sale_prices = {item: price * 0.9 for item, price in prices.items()}
print(sale_prices)  # 10% 할인 가격

# 키와 값의 위치를 바꾸기 (값이 고유한 경우)
inverse = {price: item for item, price in prices.items()}
print(inverse)  # {1000: 'apple', 500: 'banana', 800: 'orange'}
```

## collections 모듈의 유용한 딕셔너리 클래스

### defaultdict - 기본값이 있는 딕셔너리

```python
from collections import defaultdict

# 기본값을 리스트로 설정
group_by_category = defaultdict(list)
items = [("fruit", "apple"), ("fruit", "banana"), 
         ("vegetable", "carrot"), ("fruit", "orange")]

for category, item in items:
    group_by_category[category].append(item)

print(dict(group_by_category))
# {'fruit': ['apple', 'banana', 'orange'], 'vegetable': ['carrot']}

# 기본값을 정수로 설정 (카운팅)
word_counts = defaultdict(int)
text = "apple banana apple orange banana apple"
for word in text.split():
    word_counts[word] += 1

print(dict(word_counts))  # {'apple': 3, 'banana': 2, 'orange': 1}
```

### Counter - 요소 개수 세기

```python
from collections import Counter

# 다양한 초기화 방법
words = ["apple", "banana", "apple", "orange", "banana", "apple"]
word_counter = Counter(words)
print(word_counter)  # Counter({'apple': 3, 'banana': 2, 'orange': 1})

# 문자열 직접 카운팅
letter_counter = Counter("abracadabra")
print(letter_counter)  # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

# 가장 흔한 요소 찾기
print(word_counter.most_common(2))  # [('apple', 3), ('banana', 2)]

# Counter 연산
c1 = Counter({"a": 3, "b": 2})
c2 = Counter({"a": 1, "b": 3, "c": 1})
print(c1 + c2)  # Counter({'a': 4, 'b': 5, 'c': 1})
print(c1 - c2)  # Counter({'a': 2}) (음수 값은 제거됨)
```

### OrderedDict - 순서가 중요한 딕셔너리

파이썬 3.7부터 기본 딕셔너리가 삽입 순서를 유지하므로, 대부분의 경우 OrderedDict는 필요하지 않습니다. 하지만 특별한 순서 제어나 LRU 캐시 구현 등에는 여전히 유용합니다.

```python
from collections import OrderedDict

# 삽입 순서 기억 (3.7 이전 버전 호환성)
od = OrderedDict()
od["z"] = 1
od["a"] = 2
od["m"] = 3
print(list(od.keys()))  # ['z', 'a', 'm']

# 특정 위치로 항목 이동
od.move_to_end("z")     # 끝으로 이동
od.move_to_end("a", last=False)  # 처음으로 이동
print(list(od.keys()))  # ['a', 'm', 'z']
```

## 딕셔너리의 성능 특성과 최적화

딕셔너리는 내부적으로 해시 테이블을 사용하므로 대부분의 연산이 평균 O(1) 시간 복잡도를 가집니다. 하지만 몇 가지 주의사항이 있습니다:

```python
# 키의 해시 가능성 확인
print(hash("string"))      # 해시 가능
print(hash(123))           # 해시 가능
print(hash((1, 2, 3)))     # 해시 가능 (튜플의 모든 요소가 불변)
# print(hash([1, 2, 3]))   # TypeError: 리스트는 해시 불가능

# 딕셔너리 크기 확인
import sys
d = {i: i*2 for i in range(1000)}
print(f"항목 수: {len(d)}")
print(f"메모리 사용량: {sys.getsizeof(d)} bytes")

# 성능 비교: get() vs in 검사 후 접근
import timeit

setup = "d = {i: str(i) for i in range(10000)}"
stmt1 = "value = d.get(9999)"
stmt2 = """
if 9999 in d:
    value = d[9999]
else:
    value = None
"""

time1 = timeit.timeit(stmt1, setup, number=100000)
time2 = timeit.timeit(stmt2, setup, number=100000)
print(f"get() 시간: {time1:.5f}초")
print(f"in 검사 후 접근 시간: {time2:.5f}초")
```

## 실전 활용 패턴

### 데이터 변환과 정제

```python
# 데이터 정규화
raw_data = [
    {"Name": "KIM", "AGE": "30", "CITY": "SEOUL"},
    {"name": "Lee", "age": "25", "City": "Busan"},
    {"NAME": "Park", "Age": "35", "city": "Incheon"}
]

# 키 표준화 함수
def normalize_keys(data_dict):
    key_mapping = {
        "Name": "name", "NAME": "name", "name": "name",
        "AGE": "age", "Age": "age", "age": "age",
        "CITY": "city", "City": "city", "city": "city"
    }
    return {key_mapping.get(k, k): v for k, v in data_dict.items()}

normalized = [normalize_keys(item) for item in raw_data]
print(normalized)
# [{'name': 'KIM', 'age': '30', 'city': 'SEOUL'}, ...]
```

### 설정 관리

```python
# 계층적 설정 관리
import json

# 기본 설정
base_config = {
    "database": {
        "host": "localhost",
        "port": 5432,
        "name": "app_db"
    },
    "server": {
        "port": 8080,
        "debug": False
    }
}

# 환경별 설정 오버라이드
dev_config = {
    "database": {"host": "dev-db.example.com"},
    "server": {"debug": True}
}

# 사용자 설정
user_config = {"server": {"port": 9000}}

# 설정 병합 (깊은 병합 필요)
def deep_merge(base, override):
    result = base.copy()
    for key, value in override.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = deep_merge(result[key], value)
        else:
            result[key] = value
    return result

config = deep_merge(base_config, dev_config)
config = deep_merge(config, user_config)

print(json.dumps(config, indent=2, ensure_ascii=False))
```

### 캐시 구현

```python
# 간단한 캐시 구현
from functools import lru_cache
import time

# LRU 캐시 데코레이터 사용
@lru_cache(maxsize=128)
def expensive_calculation(n):
    """시간이 오래 걸리는 계산을 가정"""
    time.sleep(0.1)
    return n * n

# 사용자 정의 캐시
class SimpleCache:
    def __init__(self, max_size=100):
        self.cache = {}
        self.max_size = max_size
        self.access_order = []
    
    def get(self, key):
        if key in self.cache:
            # 접근 순서 업데이트
            self.access_order.remove(key)
            self.access_order.append(key)
            return self.cache[key]
        return None
    
    def set(self, key, value):
        if len(self.cache) >= self.max_size:
            # 가장 오래전에 접근된 항목 제거
            oldest = self.access_order.pop(0)
            del self.cache[oldest]
        
        self.cache[key] = value
        self.access_order.append(key)

# 캐시 사용 예제
cache = SimpleCache(max_size=3)
for i in [1, 2, 3, 1, 4, 2]:
    result = cache.get(i)
    if result is None:
        result = expensive_calculation(i)
        cache.set(i, result)
    print(f"f({i}) = {result}")
```

## 딕셔너리와 JSON

딕셔너리는 JSON 데이터와 자연스럽게 호환됩니다.

```python
import json

# 딕셔너리를 JSON으로 변환
data = {
    "name": "홍길동",
    "scores": {"math": 90, "english": 85, "science": 92},
    "active": True,
    "tags": ["student", "top-performer"]
}

json_str = json.dumps(data, ensure_ascii=False, indent=2)
print(json_str)

# JSON을 딕셔너리로 변환
parsed = json.loads(json_str)
print(type(parsed))  # <class 'dict'>
print(parsed["name"])  # 홍길동

# 파일로 저장 및 읽기
with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data, f, ensure_ascii=False, indent=2)

with open("data.json", "r", encoding="utf-8") as f:
    loaded_data = json.load(f)
```

## 주의사항과 모범 사례

1. **키의 불변성**: 리스트나 딕셔너리 등 가변 객체는 키로 사용할 수 없습니다.
2. **순서 보장**: 파이썬 3.7 이전 버전에서는 딕셔너리 순서가 보장되지 않습니다.
3. **메모리 사용**: 많은 양의 데이터를 저장할 때는 메모리 사용량을 고려하세요.
4. **해시 충돌**: 많은 키가 동일한 해시 값을 가지면 성능이 저하될 수 있습니다.
5. **스레드 안전성**: 여러 스레드에서 동일한 딕셔너리를 수정할 때는 적절한 동기화가 필요합니다.

```python
# 안전한 딕셔너리 사용 예제
def safe_dict_access(dictionary, key, default=None):
    """여러 방법으로 안전하게 딕셔너리 접근"""
    # 방법 1: get() 메서드 사용
    value = dictionary.get(key, default)
    
    # 방법 2: try-except 블록
    try:
        value = dictionary[key]
    except KeyError:
        value = default
    
    # 방법 3: 삼항 연산자
    value = dictionary[key] if key in dictionary else default
    
    return value

# 딕셔너리 비교 시 주의
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 2, "a": 1}
print(dict1 == dict2)  # True (내용 기준 비교)
print(dict1 is dict2)   # False (객체 식별자 기준 비교)
```

## 결론

파이썬의 딕셔너리는 데이터를 키-값 쌍으로 조직화하는 강력하고 유연한 도구입니다. 기본적인 CRUD 연산부터 고급 패턴까지 다양한 활용이 가능하며, 파이썬 3.7 이상에서는 삽입 순서가 보장되어 더욱 예측 가능한 동작을 제공합니다. `collections` 모듈의 `defaultdict`, `Counter`, `OrderedDict` 등 특수한 목적의 딕셔너리 클래스들은 일반적인 딕셔너리로 구현하기 번거로운 기능들을 편리하게 제공합니다.

실무에서는 데이터 구조화, 설정 관리, 캐싱, JSON 처리 등 다양한 상황에서 딕셔너리를 활용하게 됩니다. 딕셔너리의 내부 동작 원리(해시 테이블)를 이해하면 더 효율적인 코드를 작성할 수 있으며, 대규모 데이터를 다룰 때는 메모리 사용과 성능 특성을 고려하는 것이 중요합니다.

딕셔너리의 강력한 기능과 직관적인 문법은 파이썬 프로그래밍의 생산성을 크게 높여주는 요소 중 하나입니다. 다양한 메서드와 연산자를 익히고, 실제 프로젝트에서 적극적으로 활용해 보는 것이 가장 좋은 학습 방법입니다.