---
layout: post
title: C# - 가상 함수와 상속 제어 키워드
date: 2024-10-13 19:20:23 +0900
category: Csharp
---
# C# 가상 함수와 상속 제어 키워드 (virtual, override, new, abstract, sealed)

## 핵심 요약: 언제 무엇을 사용할까

| 목표 | 추천 키워드/구성 | 주요 특징 |
|---|---|---|
| 런타임 다형성 확장 지점 제공 | `virtual`(부모) + `override`(자식) | 필요한 지점만 가상화하는 것이 중요 |
| 더 이상 재정의 방지 | `sealed override` | 구현 고정, 버전 안정성, 최적화 가능성 향상 |
| 단순히 이름만 가리기 | `new` | 다형성 미적용(정적 바인딩). 혼란을 줄 수 있어 사용 자제 권장 |
| 강제 계약 + 공통 로직 혼합 | `abstract`(메서드/클래스) | 인스턴스화 불가, 파생 클래스에서 반드시 구현 필요 |
| 상속 자체 금지 | `sealed class` | API 안정성, 보안, 코드 추론성 향상 |

---

## virtual & override — 런타임 다형성의 핵심

### 기본 예제

```csharp
class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("동물이 소리를 냅니다");
    }
}

class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("멍멍");
    }
}

Animal a = new Dog();
a.Speak(); // 멍멍
```

`virtual`과 `override`의 조합은 동적 디스패치를 활성화하여 런타임에 실제 객체 타입의 구현을 호출합니다. 이는 객체지향 프로그래밍의 핵심인 다형성을 구현하는 기본적인 방법입니다.

### 가상 멤버의 다양성

C#에서는 메서드뿐만 아니라 속성, 인덱서, 이벤트도 가상화할 수 있습니다:

```csharp
abstract class Meter
{
    public virtual string Unit => "raw";        // 가상 속성
    public virtual int this[int i] => i * 2;    // 가상 인덱서
    public virtual event EventHandler? Changed; // 가상 이벤트
    public virtual void Raise() => Changed?.Invoke(this, EventArgs.Empty);
}
```

### `base` 키워드를 활용한 확장

```csharp
class TimeLogger : Logger
{
    public override void Write(string msg)
    {
        base.Write($"[{DateTime.UtcNow:O}] {msg}");
    }
}
```

부모 클래스의 기능을 확장하거나 수정할 때 `base` 호출을 통해 기존 구현을 재사용할 수 있습니다. 이는 코드 재사용성과 유지보수성을 높이는 중요한 패턴입니다.

---

## new — 이름 숨김의 함정

### 실질적인 차이

```csharp
class Foo
{
    public void Print() => Console.WriteLine("Foo");
}

class Bar : Foo
{
    public new void Print() => Console.WriteLine("Bar");
}

Foo f = new Bar();
f.Print(); // Foo (정적 바인딩)
```

`new` 키워드는 다형성을 제공하지 않습니다. 컴파일 타임에 참조 변수의 타입에 따라 호출할 메서드가 결정되는 정적 바인딩을 사용합니다. 이는 API 사용자에게 예상치 못한 동작을 초래할 수 있어 신중하게 사용해야 합니다.

### `new`의 제한된 사용 사례

- **우연한 시그니처 충돌**: 부모 클래스의 리팩토링으로 인해 파생 클래스의 메서드와 시그니처가 우연히 일치하게 된 경우
- **레거시 API 호환성**: 기존 코드와의 호환성을 유지하면서 새로운 구현을 제공해야 할 때

> 가능한 경우 다른 메서드 이름을 선택하거나 인터페이스를 통해 명확한 계약을 정의하는 것이 더 나은 설계입니다.

---

## abstract — 계약의 강제와 유연성의 균형

### 추상 클래스와 메서드

```csharp
abstract class Shape
{
    public abstract double Area();         // 구현 없음 → 파생 클래스에서 반드시 구현
    public virtual string Name => "Shape"; // 공통 기본 구현 제공 가능
}

class Circle : Shape
{
    public double Radius { get; }
    public Circle(double radius) => Radius = radius;
    public override double Area() => Math.PI * Radius * Radius;
    public override string Name => "Circle";
}
```

추상 클래스는 인스턴스화할 수 없지만, 구체적인 구현과 추상 계약을 함께 정의할 수 있습니다. 이는 템플릿 메서드 패턴을 구현하는 데 이상적입니다.

### 다양한 추상 멤버

```csharp
abstract class Repository<T>
{
    public abstract int Count { get; }      // 추상 속성
    public abstract T this[int i] { get; }  // 추상 인덱서
}
```

---

## sealed — 확장의 경계 설정

### 클래스 수준의 봉인

```csharp
sealed class Utility
{
    public static string FormatData(object data) { /* ... */ }
}
// class ExtendedUtility : Utility { } // ❌ 컴파일 오류
```

클래스를 `sealed`로 선언하면 상속을 완전히 방지하여 API의 안정성을 보장하고, 보안 취약점을 줄이며, 런타임 최적화 기회를 제공합니다.

### 메서드 수준의 봉인: `sealed override`

```csharp
class Animal
{
    public virtual void Speak() { }
}

class Dog : Animal
{
    public sealed override void Speak()
    {
        Console.WriteLine("멍멍");
    }
}

class Bulldog : Dog
{
    // public override void Speak() { } // ❌ 금지
}
```

특정 메서드의 재정의를 봉인함으로써 해당 동작이 더 이상 변경되지 않음을 보장합니다. 이는 라이브러리 설계 시 하위 호환성을 유지하는 데 중요하며, JIT 컴파일러가 devirtualization을 통해 성능 최적화를 수행할 수 있는 기회를 제공합니다.

---

## 오버라이딩의 세부 사항

### 시그니처와 접근성

오버라이딩할 때는 반환형, 이름, 매개변수 목록이 정확히 일치해야 합니다. 접근성은 부모 메서드와 동일하거나 더 넓어질 수 있습니다(일반적으로 동일하게 유지).

### 공변 반환 타입

```csharp
abstract class Factory { public abstract object Create(); }
class Product { }
class ProductFactory : Factory
{
    public override Product Create() => new(); // object → Product (공변 반환)
}
```

C# 9.0부터 공변 반환 타입이 지원되어, 오버라이드 메서드가 더 구체적인 반환 타입을 가질 수 있습니다.

---

## 오버로딩 vs 오버라이딩

```csharp
class A
{
    public virtual void Process(int x)  => Console.WriteLine("A:int");
    public       void Process(double x) => Console.WriteLine("A:double");
}

class B : A
{
    public override void Process(int x) => Console.WriteLine("B:int");
    public new      void Process(double x) => Console.WriteLine("B:double");
}

A a = new B();
a.Process(1);    // B:int   (오버라이드: 런타임 다형성)
a.Process(1.0);  // A:double (오버로드: 정적 바인딩)
```

**오버라이딩**은 동일한 시그니처를 가진 메서드를 재정의하여 런타임 다형성을 구현하는 반면, **오버로딩**은 동일한 이름을 가졌지만 다른 시그니처를 가진 메서드를 정의하는 컴파일 타임 다형성입니다.

---

## 설계 원칙: 명확성과 최소화

1. **기본은 봉인**: 명시적인 이유 없이 클래스를 상속 가능하게 만들지 마세요.
2. **의도적인 확장 지점**: 모든 메서드를 가상으로 만들지 말고, 실제로 확장이 예상되는 지점만 가상으로 만드세요.
3. **템플릿 메서드 패턴**: 알고리즘의 골격을 제공하면서 특정 단계를 파생 클래스에서 구현하도록 유도하세요.
4. **문서화**: 오버라이드 가능한 메서드의 계약, 사전/사후 조건, 예상 동작을 명확히 문서화하세요.

---

## 실전 패턴: 유연성과 안정성의 조화

```csharp
abstract class DataProcessor
{
    public void Process(string input)
    {
        var cleaned = Clean(input);
        var parsed = Parse(cleaned);
        Output(parsed);
    }

    protected virtual string Clean(string s) => s.Trim();
    protected abstract object Parse(string s);
    protected virtual void Output(object result)
    {
        Console.WriteLine($"Result: {result}");
    }
}

class CsvProcessor : DataProcessor
{
    // Clean 메서드를 더 이상 변경하지 못하도록 고정
    protected sealed override string Clean(string s)
    {
        return s.Replace("\r\n", "\n").Trim();
    }

    protected override object Parse(string s)
    {
        return s.Split(',').Select(x => x.Trim()).ToList();
    }
}
```

이 패턴은 상위 클래스에서 처리 흐름을 제어하면서, 하위 클래스에서 구체적인 구현을 제공할 수 있는 유연성을 제공합니다. 동시에 `sealed override`를 통해 특정 단계의 구현을 고정함으로써 안정성을 확보합니다.

---

## 성능 고려사항

가상 메서드 호출은 일반 메서드 호출보다 간접 참조를 한 번 더 거치기 때문에 약간의 오버헤드가 있습니다. 그러나 현대 JIT 컴파일러는 다음과 같은 상황에서 최적화를 수행합니다:

- 수신자 타입이 `sealed`로 명확히 알려진 경우
- 실제 타입이 정적 분석으로 파악 가능한 경우
- 핫스팟에서 빈번히 호출되는 가상 메서드

성능이 중요한 코드에서는 `sealed` 키워드를 적극적으로 활용하고, 가상 호출을 필요한 경우로 제한하세요.

---

## 인터페이스 기본 구현과의 관계

C# 8.0부터 인터페이스도 기본 구현을 가질 수 있게 되었습니다:

```csharp
public interface ILogger
{
    void Log(string message);
    void LogError(string error) => Log($"ERROR: {error}"); // 기본 구현
}
```

인터페이스 기본 구현은 클래스 상속과 달리 다중 상속의 복잡성을 가지지만, 기존 인터페이스에 새로운 메서드를 추가할 때 하위 호환성을 유지하는 데 유용합니다.

---

## 결론

C#의 상속 제어 키워드들은 객체지향 설계에 있어 다양한 수준의 유연성과 제어력을 제공합니다. `virtual`과 `override`는 런타임 다형성의 기초를 제공하며, `abstract`는 강제적인 구현 계약을 정의합니다. `sealed`는 안정성과 성능을 고려한 설계 결정을 가능하게 하며, `new` 키워드는 주의 깊게 사용해야 하는 특수한 경우의 도구입니다.

효율적인 설계를 위해 다음 원칙을 기억하세요: **명시적인 이유 없이 가상화하지 말고, 필요한 만큼만 확장 지점을 제공하며, 안정성이 필요한 부분은 적극적으로 봉인하라**. 이러한 접근 방식은 유지보수성, 성능, API 안정성의 균형을 이루는 견고한 소프트웨어 아키텍처를 구축하는 데 도움이 될 것입니다.

---

## 심화 학습을 위한 과제

1. **템플릿 메서드 패턴 구현**: `DocumentExporter` 추상 클래스를 설계하고, `PrepareData()`, `FormatContent()`, `FinalizeExport()` 메서드 중 일부는 가상, 일부는 추상으로 정의해보세요. `PDFExporter`와 `CSVExporter`에서 이를 구현하면서 `sealed override`의 적절한 사용처를 고려하세요.

2. **성능 비교 실험**: 가상 메서드 호출과 정적 메서드 호출의 성능 차이를 벤치마킹하는 작은 프로그램을 작성해보세요. `sealed` 키워드가 최적화에 어떤 영향을 미치는지 관찰하세요.

3. **API 설계 연습**: 다른 개발자가 사용할 라이브러리를 설계한다고 가정하고, 어떤 클래스와 메서드를 `sealed`로 만들지, 어떤 메서드를 `virtual`로 제공할지 결정하는 연습을 해보세요. 각 결정의 근거를 문서화하세요.