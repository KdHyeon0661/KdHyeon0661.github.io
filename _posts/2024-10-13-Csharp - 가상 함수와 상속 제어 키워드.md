---
layout: post
title: C# - 가상 함수와 상속 제어 키워드
date: 2024-10-13 19:20:23 +0900
category: Csharp
---
# C# 가상 함수와 상속 제어 키워드 (virtual, override, new, abstract, sealed)

## 핵심 요약: 언제 무엇을 사용할까

| 목표 | 추천 키워드/구성 | 주요 특징 |
|---|---|---|
| 런타임 다형성 확장 지점 제공 | `virtual`(부모) + `override`(자식) | 필요한 지점만 가상화하는 것이 중요 |
| 더 이상 재정의 방지 | `sealed override` | 구현 고정, 버전 안정성, 최적화 가능성 향상 |
| 단순히 이름만 가리기 | `new` | 다형성 미적용(정적 바인딩). 혼란을 줄 수 있어 사용 자제 권장 |
| 강제 계약 + 공통 로직 혼합 | `abstract`(메서드/클래스) | 인스턴스화 불가, 파생 클래스에서 반드시 구현 필요 |
| 상속 자체 금지 | `sealed class` | API 안정성, 보안, 코드 추론성 향상 |

---

## virtual & override — 런타임 다형성의 핵심

### 기본 예제

```csharp
class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("동물이 소리를 냅니다");
    }
}

class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("멍멍");
    }
}

Animal a = new Dog();
a.Speak(); // 멍멍
```

`virtual`과 `override`의 조합은 동적 디스패치를 활성화하여 런타임에 실제 객체 타입의 구현을 호출합니다. 이는 객체지향 프로그래밍의 핵심인 다형성을 구현하는 기본적인 방법입니다.

### 가상 멤버의 다양성

C#에서는 메서드뿐만 아니라 속성, 인덱서, 이벤트도 가상화할 수 있습니다:

```csharp
abstract class Meter
{
    public virtual string Unit => "raw";        // 가상 속성
    public virtual int this[int i] => i * 2;    // 가상 인덱서
    public virtual event EventHandler? Changed; // 가상 이벤트
    public virtual void Raise() => Changed?.Invoke(this, EventArgs.Empty);
}
```

### `base` 키워드를 활용한 확장

```csharp
class TimeLogger : Logger
{
    public override void Write(string msg)
    {
        base.Write($"[{DateTime.UtcNow:O}] {msg}");
    }
}
```

부모 클래스의 기능을 확장하거나 수정할 때 `base` 호출을 통해 기존 구현을 재사용할 수 있습니다. 이는 코드 재사용성과 유지보수성을 높이는 중요한 패턴입니다.

### ⚠️ 생성자에서 가상 메서드 호출의 위험성

**생성자 내에서 가상 메서드를 호출하면 예측 불가능한 동작이 발생할 수 있습니다.** 이는 파생 클래스의 생성자가 아직 완전히 실행되지 않은 상태에서 재정의된 메서드가 호출되기 때문입니다. 즉, **부분적으로만 초기화된 객체(partially constructed object)** 에 대해 메서드가 실행되는 위험이 있습니다.

```csharp
class Base
{
    public Base()
    {
        Console.WriteLine("Base 생성자 시작");
        DoSomething(); // 위험: 가상 메서드 호출
        Console.WriteLine("Base 생성자 종료");
    }

    protected virtual void DoSomething()
    {
        Console.WriteLine("Base.DoSomething");
    }
}

class Derived : Base
{
    private string _data = "초기화됨";
    
    public Derived()
    {
        Console.WriteLine("Derived 생성자 시작");
        _data = "Derived에서 설정";
        Console.WriteLine("Derived 생성자 종료");
    }

    protected override void DoSomething()
    {
        Console.WriteLine($"Derived.DoSomething: _data = '{_data}'");
    }
}

// 실행 결과:
// Base 생성자 시작
// Derived.DoSomething: _data = ''        ← _data가 아직 초기화되지 않음!
// Base 생성자 종료
// Derived 생성자 시작
// Derived 생성자 종료
```

`Derived` 객체를 생성하면 `Base` 생성자가 먼저 실행되고, 그 안에서 `DoSomething()`을 호출합니다. 이때 `Derived`의 `_data` 필드는 아직 초기화되지 않은 상태(null 또는 기본값)입니다. 이러한 문제는 디버깅하기 어려운 미묘한 버그를 만듭니다.

**✅ 안전한 대안**: 생성자에서는 가상 메서드를 호출하지 말고, 필요한 초기화 로직은 팩토리 메서드나 별도의 초기화 메서드를 통해 수행하세요.

---

## 🧠 가상 메서드의 내부 동작: vtable (가상 함수 테이블)

C#에서 가상 메서드 호출이 런타임에 올바른 구현을 찾을 수 있는 이유는 **vtable(가상 함수 테이블)** 이라는 내부 메커니즘 덕분입니다.

- 각 클래스는 자신의 가상 메서드 주소를 담은 **vtable**을 가지고 있습니다.
- 각 객체는 생성 시 자신의 클래스에 해당하는 vtable을 가리키는 숨겨진 포인터(**vptr**)를 가집니다.
- 가상 메서드 호출은 다음과 같은 단계로 이루어집니다:
  1. 객체의 vptr을 통해 vtable에 접근
  2. vtable에서 해당 메서드의 오프셋 위치에 저장된 실제 함수 포인터를 가져옴
  3. 그 포인터를 통해 메서드 호출

```csharp
// 컴파일러가 내부적으로 처리하는 대략적인 개념
// animal.Speak() 호출은 다음과 유사하게 동작
animal.vptr[0](); // vtable의 첫 번째 슬롯에 있는 Speak 메서드 호출
```

vtable은 상속 계층에서 `override`할 때마다 업데이트됩니다. 파생 클래스에서 메서드를 `override`하면 vtable의 해당 슬롯이 새 주소로 교체됩니다. 이로 인해 런타임에 정확한 메서드가 호출되는 **동적 디스패치**가 가능해집니다.

---

## new — 이름 숨김의 함정

### 실질적인 차이

```csharp
class Foo
{
    public void Print() => Console.WriteLine("Foo");
}

class Bar : Foo
{
    public new void Print() => Console.WriteLine("Bar");
}

Foo f = new Bar();
f.Print(); // Foo (정적 바인딩)
```

`new` 키워드는 다형성을 제공하지 않습니다. 컴파일 타임에 참조 변수의 타입에 따라 호출할 메서드가 결정되는 정적 바인딩을 사용합니다. 이는 API 사용자에게 예상치 못한 동작을 초래할 수 있어 신중하게 사용해야 합니다.

### 🔍 `new`의 핵심: **override 체인을 끊는다**

`new`의 중요한 특징은 **가상 메서드 체인을 차단**한다는 점입니다. 즉, `new`로 선언된 메서드는 이후 파생 클래스에서 아무리 `override`해도, 기본 클래스 참조를 통해 호출할 때는 절대 호출되지 않습니다.

```csharp
class A
{
    public virtual void Method() => Console.WriteLine("A");
}

class B : A
{
    public override void Method() => Console.WriteLine("B");
}

class C : B
{
    public new virtual void Method() => Console.WriteLine("C (new)");
}

class D : C
{
    public override void Method() => Console.WriteLine("D");
}

A obj = new D();
obj.Method(); // 출력: B (C와 D의 Method는 가상 체인에서 단절됨)
```

이 예제에서:
- `A` → `B`는 정상적인 `override` 체인 유지
- `C`에서 `new`로 체인 단절
- `D`에서 `override`해도 `A` 타입 참조로는 `B`의 구현까지만 접근 가능

이런 동작은 의도하지 않으면 큰 혼란을 초래할 수 있습니다.

### `new`의 제한된 사용 사례

- **우연한 시그니처 충돌**: 부모 클래스의 리팩토링으로 인해 파생 클래스의 메서드와 시그니처가 우연히 일치하게 된 경우
- **레거시 API 호환성**: 기존 코드와의 호환성을 유지하면서 새로운 구현을 제공해야 할 때

> 가능한 경우 다른 메서드 이름을 선택하거나 인터페이스를 통해 명확한 계약을 정의하는 것이 더 나은 설계입니다.

---

## abstract — 계약의 강제와 유연성의 균형

### 추상 클래스와 메서드

```csharp
abstract class Shape
{
    public abstract double Area();         // 구현 없음 → 파생 클래스에서 반드시 구현
    public virtual string Name => "Shape"; // 공통 기본 구현 제공 가능
}

class Circle : Shape
{
    public double Radius { get; }
    public Circle(double radius) => Radius = radius;
    public override double Area() => Math.PI * Radius * Radius;
    public override string Name => "Circle";
}
```

추상 클래스는 인스턴스화할 수 없지만, 구체적인 구현과 추상 계약을 함께 정의할 수 있습니다. 이는 템플릿 메서드 패턴을 구현하는 데 이상적입니다.

### 다양한 추상 멤버

```csharp
abstract class Repository<T>
{
    public abstract int Count { get; }      // 추상 속성
    public abstract T this[int i] { get; }  // 추상 인덱서
}
```

---

## sealed — 확장의 경계 설정

### 클래스 수준의 봉인

```csharp
sealed class Utility
{
    public static string FormatData(object data) { /* ... */ }
}
// class ExtendedUtility : Utility { } // ❌ 컴파일 오류
```

클래스를 `sealed`로 선언하면 상속을 완전히 방지하여 API의 안정성을 보장하고, 보안 취약점을 줄이며, 런타임 최적화 기회를 제공합니다.

### 메서드 수준의 봉인: `sealed override`

```csharp
class Animal
{
    public virtual void Speak() { }
}

class Dog : Animal
{
    public sealed override void Speak()
    {
        Console.WriteLine("멍멍");
    }
}

class Bulldog : Dog
{
    // public override void Speak() { } // ❌ 금지
}
```

특정 메서드의 재정의를 봉인함으로써 해당 동작이 더 이상 변경되지 않음을 보장합니다.

### ⚡ sealed와 성능 최적화

`sealed` 클래스는 JIT(Just-In-Time) 컴파일러의 **최적화 기회를 향상시킵니다**. 그 이유는 다음과 같습니다:

- `sealed` 클래스는 더 이상 상속될 수 없으므로, 메서드 호출 시 어떤 파생 클래스가 나타날지 고려할 필요가 없습니다.
- JIT 컴파일러는 **호출 대상이 명확**해지므로, 가상 메서드 호출을 **직접 호출(direct call)** 로 변환하거나 **인라인(inline)** 할 수 있는지 더 쉽게 판단합니다.
- 이는 특히 성능에 민감한 코드에서 유의미한 차이를 만듭니다.

```csharp
// JIT 최적화 예시
public class Test
{
    public void NonSealedCall(NonSealedType obj) => obj.Method(); // 가상 호출 필요
    public void SealedCall(SealedType obj) => obj.Method();       // 직접 호출 가능
}

internal class BaseType    { public virtual void Method() { } }
internal class NonSealedType : BaseType { public override void Method() { } }
internal sealed class SealedType : BaseType { public override void Method() { } }
```

실제 벤치마크에 따르면 `sealed` 클래스의 메서드 호출이 비봉인 클래스보다 최대 98% 빠를 수 있습니다. 배열 할당이나 타입 변환(`is`/`as`)에서도 유사한 최적화가 적용됩니다.

---

## 오버라이딩의 세부 사항

### 시그니처와 접근성

오버라이딩할 때는 반환형, 이름, 매개변수 목록이 정확히 일치해야 합니다. 접근성은 부모 메서드와 동일하거나 더 넓어질 수 있습니다(일반적으로 동일하게 유지).

### 공변 반환 타입

```csharp
abstract class Factory { public abstract object Create(); }
class Product { }
class ProductFactory : Factory
{
    public override Product Create() => new(); // object → Product (공변 반환)
}
```

C# 9.0부터 공변 반환 타입이 지원되어, 오버라이드 메서드가 더 구체적인 반환 타입을 가질 수 있습니다.

---

## 오버로딩 vs 오버라이딩

```csharp
class A
{
    public virtual void Process(int x)  => Console.WriteLine("A:int");
    public       void Process(double x) => Console.WriteLine("A:double");
}

class B : A
{
    public override void Process(int x) => Console.WriteLine("B:int");
    public new      void Process(double x) => Console.WriteLine("B:double");
}

A a = new B();
a.Process(1);    // B:int   (오버라이드: 런타임 다형성)
a.Process(1.0);  // A:double (오버로드: 정적 바인딩)
```

**오버라이딩**은 동일한 시그니처를 가진 메서드를 재정의하여 런타임 다형성을 구현하는 반면, **오버로딩**은 동일한 이름을 가졌지만 다른 시그니처를 가진 메서드를 정의하는 컴파일 타임 다형성입니다.

---

## 설계 원칙: 명확성과 최소화

1. **기본은 봉인**: 명시적인 이유 없이 클래스를 상속 가능하게 만들지 마세요.
2. **의도적인 확장 지점**: 모든 메서드를 가상으로 만들지 말고, 실제로 확장이 예상되는 지점만 가상으로 만드세요.
3. **템플릿 메서드 패턴**: 알고리즘의 골격을 제공하면서 특정 단계를 파생 클래스에서 구현하도록 유도하세요.
4. **문서화**: 오버라이드 가능한 메서드의 계약, 사전/사후 조건, 예상 동작을 명확히 문서화하세요.
5. **🔷 LSP(리스코프 치환 원칙)**: `override`는 반드시 **부모 클래스의 계약을 깨지 않아야 합니다**. 즉, 자식 클래스는 부모 클래스가 할 수 있는 일을 모두 할 수 있어야 하며, 기대하는 동작을 변경하면 안 됩니다. 이 원칙을 위반하면 다형성이 무너지고 예측 불가능한 버그가 발생합니다.

---

## 실전 패턴: 유연성과 안정성의 조화

```csharp
abstract class DataProcessor
{
    public void Process(string input)
    {
        var cleaned = Clean(input);
        var parsed = Parse(cleaned);
        Output(parsed);
    }

    protected virtual string Clean(string s) => s.Trim();
    protected abstract object Parse(string s);
    protected virtual void Output(object result)
    {
        Console.WriteLine($"Result: {result}");
    }
}

class CsvProcessor : DataProcessor
{
    // Clean 메서드를 더 이상 변경하지 못하도록 고정
    protected sealed override string Clean(string s)
    {
        return s.Replace("\r\n", "\n").Trim();
    }

    protected override object Parse(string s)
    {
        return s.Split(',').Select(x => x.Trim()).ToList();
    }
}
```

이 패턴은 상위 클래스에서 처리 흐름을 제어하면서, 하위 클래스에서 구체적인 구현을 제공할 수 있는 유연성을 제공합니다. 동시에 `sealed override`를 통해 특정 단계의 구현을 고정함으로써 안정성을 확보합니다.

---

## 성능 고려사항

가상 메서드 호출은 일반 메서드 호출보다 간접 참조를 한 번 더 거치기 때문에 약간의 오버헤드가 있습니다. 그러나 현대 JIT 컴파일러는 다음과 같은 상황에서 최적화를 수행합니다:

- 수신자 타입이 `sealed`로 명확히 알려진 경우
- 실제 타입이 정적 분석으로 파악 가능한 경우
- 핫스팟에서 빈번히 호출되는 가상 메서드

성능이 중요한 코드에서는 `sealed` 키워드를 적극적으로 활용하고, 가상 호출을 필요한 경우로 제한하세요.

---

## 인터페이스 기본 구현과의 관계

C# 8.0부터 인터페이스도 기본 구현을 가질 수 있게 되었습니다:

```csharp
public interface ILogger
{
    void Log(string message);
    void LogError(string error) => Log($"ERROR: {error}"); // 기본 구현
}
```

인터페이스 기본 구현은 클래스 상속과 달리 다중 상속의 복잡성을 가지지만, 기존 인터페이스에 새로운 메서드를 추가할 때 하위 호환성을 유지하는 데 유용합니다.

---

## 결론

C#의 상속 제어 키워드들은 객체지향 설계에 있어 다양한 수준의 유연성과 제어력을 제공합니다. `virtual`과 `override`는 런타임 다형성의 기초를 제공하며, `abstract`는 강제적인 구현 계약을 정의합니다. `sealed`는 안정성과 성능을 고려한 설계 결정을 가능하게 하며, `new` 키워드는 주의 깊게 사용해야 하는 특수한 경우의 도구입니다.

효율적인 설계를 위해 다음 원칙을 기억하세요: **명시적인 이유 없이 가상화하지 말고, 필요한 만큼만 확장 지점을 제공하며, 안정성이 필요한 부분은 적극적으로 봉인하라**. 특히 생성자에서 가상 메서드 호출을 피하고, `new` 키워드가 다형성 체인을 끊는다는 점을 항상 인식해야 합니다. 이러한 접근 방식은 유지보수성, 성능, API 안정성의 균형을 이루는 견고한 소프트웨어 아키텍처를 구축하는 데 도움이 될 것입니다.

---

## 심화 학습을 위한 과제

1. **템플릿 메서드 패턴 구현**: `DocumentExporter` 추상 클래스를 설계하고, `PrepareData()`, `FormatContent()`, `FinalizeExport()` 메서드 중 일부는 가상, 일부는 추상으로 정의해보세요. `PDFExporter`와 `CSVExporter`에서 이를 구현하면서 `sealed override`의 적절한 사용처를 고려하세요.

2. **성능 비교 실험**: 가상 메서드 호출과 정적 메서드 호출의 성능 차이를 벤치마킹하는 작은 프로그램을 작성해보세요. `sealed` 키워드가 최적화에 어떤 영향을 미치는지 관찰하세요.

3. **API 설계 연습**: 다른 개발자가 사용할 라이브러리를 설계한다고 가정하고, 어떤 클래스와 메서드를 `sealed`로 만들지, 어떤 메서드를 `virtual`로 제공할지 결정하는 연습을 해보세요. 각 결정의 근거를 문서화하세요.