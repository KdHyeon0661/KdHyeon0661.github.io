---
layout: post
title: C# - 가상 함수와 상속 제어 키워드
date: 2024-10-13 19:20:23 +0900
category: Csharp
---
# C# 가상 함수와 상속 제어 키워드 (virtual, override, new, abstract, sealed)

## 0. 한눈 요약: 언제 무엇을 쓰나

| 목표 | 추천 키워드/구성 | 메모 |
|---|---|---|
| 런타임 다형성 확장 지점 제공 | `virtual`(부모) + `override`(자식) | 필요한 지점만 가상화(최소 공개 원칙) |
| 더 이상 재정의 못 하게 | `sealed override` | 구현 고정·버전 안정·최적화(devirtualization) |
| 단순히 이름만 가리기 | `new` | 다형성 아님(정적 바인딩). 지양(혼란 유발) |
| 강제 계약 + 공통 로직 혼합 | `abstract`(메서드/클래스) | 인스턴스화 불가, 자식에서 반드시 구현 |
| 아예 상속 금지 | `sealed class` | API 안정·보안·추론 용이 |

---

## 1. virtual & override — 런타임 다형성의 기본

### 1.1 기본 예제

```csharp
class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("동물이 소리를 냅니다");
    }
}

class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("멍멍");
    }
}

Animal a = new Dog();
a.Speak(); // 멍멍
```

- 부모에 **`virtual`**, 자식에 **`override`**가 있어야 **동적 디스패치**가 일어나 **자식 구현**이 호출됩니다.

### 1.2 가상 멤버 종류

가상화할 수 있는 대상: **메서드, 속성, 인덱서, 이벤트**

```csharp
abstract class Meter
{
    public virtual string Unit => "raw";        // 속성
    public virtual int this[int i] => i * 2;    // 인덱서
    public virtual event EventHandler? Changed;  // 이벤트
    public virtual void Raise() => Changed?.Invoke(this, EventArgs.Empty);
}
```

### 1.3 `base`와의 조합

```csharp
class TimeLogger : Logger
{
    public override void Write(string msg)
    {
        base.Write($"[{DateTime.UtcNow:O}] {msg}");
    }
}
```

- 부모 동작을 **확장**하고 싶다면 `base` 호출로 조합합니다.

---

## 2. new — “숨김”은 재정의가 아니다

### 2.1 차이 확인

```csharp
class Foo
{
    public void Print() => Console.WriteLine("Foo");
}

class Bar : Foo
{
    public new void Print() => Console.WriteLine("Bar");
}

Foo f = new Bar();
f.Print(); // Foo (정적 바인딩)
```

- `new`는 **다형성 비적용**. 참조 타입에 따라 **정적 바인딩**됩니다.
- API 소비자에게 혼란을 주기 쉬워 **지양**. 정말 필요한 경우에만, **문서로 명확화**하세요.

### 2.2 `new`가 필요한 경우

- **멤버 시그니처가 우연히 충돌**했으나 의도적으로 다른 의미를 부여해야 할 때
- 레거시 API와의 **이름 충돌 회피**
> 그래도 가능하면 **다른 이름**을 선택하는 게 낫습니다.

---

## 3. abstract — 강제 계약과 공통 로직

### 3.1 추상 메서드/클래스

```csharp
abstract class Shape
{
    public abstract double Area();         // 구현 없음 → 자식이 반드시 override
    public virtual string Name => "Shape"; // 공통 디폴트는 제공 가능
}

class Circle : Shape
{
    public double R { get; }
    public Circle(double r) => R = r;
    public override double Area() => Math.PI * R * R;
    public override string Name => "Circle";
}
```

- **추상 클래스**는 **인스턴스화 불가**.
- **추상 멤버**는 **자식에서 구현 의무**가 있어 **일관된 계약**을 강제합니다.

### 3.2 추상 속성/인덱서도 가능

```csharp
abstract class Repository<T>
{
    public abstract int Count { get; }      // 추상 속성
    public abstract T this[int i] { get; }  // 추상 인덱서
}
```

---

## 4. sealed — 더 이상 확장 금지

### 4.1 클래스 봉인

```csharp
sealed class Tool
{
    public void Use() { /* ... */ }
}
// class Hammer : Tool { } // ❌ 컴파일 오류
```

- **API 안정성**, **보안**, **코드 추론성** 향상.

### 4.2 `sealed override` — 재정의 고정

```csharp
class Animal
{
    public virtual void Speak() { }
}

class Dog : Animal
{
    public sealed override void Speak()
    {
        Console.WriteLine("멍멍");
    }
}

class Bulldog : Dog
{
    // public override void Speak() { } // ❌ 금지
}
```

- 파생형에 **더 이상의 변경을 허용하지 않음**.
- JIT이 **devirtualization**을 하여 **인라이닝** 등 최적화 여지가 커짐(상황 의존).

---

## 5. 오버라이딩 세부 규칙 — 알아두면 덜 당황

### 5.1 시그니처 일치 & 접근성

- **반환형, 이름, 매개변수 목록**은 동일해야 합니다.
- 접근성은 부모와 **동일하거나 더 넓힐 수 있음**(일반적으로 동일 유지).

### 5.2 공변 반환(Covariant Return)

```csharp
abstract class Maker { public abstract object Create(); }
class User { }
class UserMaker : Maker
{
    public override User Create() => new(); // object → User (공변 반환 허용)
}
```

### 5.3 예외 시그니처

- C#은 **체크 예외**가 없으므로, 예외 시그니처 제한은 없습니다.
- 하지만 **계약 상의 예외 정책**은 문서로 **명시**하세요.

### 5.4 가상 소멸자(종료자)와 `IDisposable`

- 종료자는 `virtual`이 아닙니다. 자원 해제는 **`IDisposable` 패턴**으로 관리하고, 필요 시 `protected virtual void Dispose(bool)`를 둬서 **확장 지점**을 열어두세요.

```csharp
public class Base : IDisposable
{
    private bool _disposed;
    protected virtual void Dispose(bool disposing)
    {
        if (_disposed) return;
        // managed/unmanaged clean-up
        _disposed = true;
    }
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}
```

---

## 6. 오버로드 vs 오버라이드 — 자주 혼동하는 포인트

```csharp
class A
{
    public virtual void F(int x)  => Console.WriteLine("A:int");
    public       void F(double x) => Console.WriteLine("A:double");
}

class B : A
{
    public override void F(int x) => Console.WriteLine("B:int");
    public new      void F(double x) => Console.WriteLine("B:double");
}

A a = new B();
a.F(1);    // B:int   (오버라이드: 다형성)
a.F(1.0);  // A:double (double 버전은 비가상, new 숨김도 아님 → 정적 바인딩)
```

- **오버라이드**: 같은 시그니처, **virtual/override**로 **런타임 다형성**
- **오버로드**: 같은 이름, **매개변수 시그니처가 다름**(정적 선택)

---

## 7. 설계 지침 — 최소 가상화, 명확한 경계

1. **기본은 sealed**: 상속이 정말 필요할 때만 열어두세요.
2. **확장 지점만 virtual**: 모든 메서드를 가상화하지 마세요(오버라이드 비용·안정성 저하).
3. **템플릿 메서드 패턴**: 상위에서 알고리즘 윤곽을 제공하고, 세부 훅만 virtual로.
4. **문서화**: 오버라이드 시 **불변조건**과 **사이드이펙트 규약**을 명확히.
5. **`new`는 최후의 수단**: 사용자 혼란(다형성 기대 붕괴)을 초래.

---

## 8. 실전 예제 — 가상 훅 + `sealed override` 고정

```csharp
abstract class Processor
{
    public void Run(string input)
    {
        var normalized = Normalize(input);
        var tokens = Tokenize(normalized);
        Emit(tokens);
    }

    protected virtual string Normalize(string s) => s.Trim();
    protected abstract IEnumerable<string> Tokenize(string s);
    protected virtual void Emit(IEnumerable<string> tokens)
    {
        Console.WriteLine(string.Join("|", tokens));
    }
}

class CsvProcessor : Processor
{
    // 확장: Normalize 고정(더 못 바꾸게)
    protected sealed override string Normalize(string s)
    {
        return s.Replace("\r\n", "\n");
    }

    protected override IEnumerable<string> Tokenize(string s)
    {
        return s.Split(',').Select(x => x.Trim());
    }

    // Emit은 그대로 사용(필요 시 재정의 가능)
}
```

- 상위는 **알고리즘 뼈대**, 하위는 **핵심 훅**만 구현.
- 특정 훅은 `sealed override`로 **행동 고정**.

---

## 9. 성능/런타임 메모

- **가상 호출**은 일반 호출보다 **약간의 오버헤드**가 있습니다(가상 테이블 탐색).
- JIT은 경우에 따라 **devirtualization**을 수행해 인라이닝할 수 있습니다.
  - 예: 수신자 타입이 정적 분석으로 **sealed**임이 확실할 때
- **핫 패스**에서 가상 호출이 병목이라면:
  1) **sealed**/`sealed override` 적용
  2) **전략 객체**를 생성 시 분기(런타임 분기 제거)
  3) 구조체 + 인터페이스 호출은 **박싱/가상 호출**에 주의

---

## 10. 상호작용: 기본 인터페이스 구현과의 관계

C# 8+ 인터페이스는 **기본 구현(디폴트 메서드)**을 가질 수 있습니다.

```csharp
public interface IClock
{
    DateTime Now { get; }
    string FormatNow(string fmt = "O") => Now.ToString(fmt); // 기본 구현
}

public class SystemClock : IClock
{
    public DateTime Now => DateTime.UtcNow;
}
```

- 인터페이스 기본 구현은 **상속 대체 수단**이 될 수 있지만, **복잡도/다이아몬드 문제**를 유의하세요.
- 클래스 가상 메서드와 달리 **명시적 override 키워드 없이** 구현됩니다.

---

## 11. 예제 모음 — 헷갈리는 케이스 4종

### 11.1 `override` + `sealed override` + `new`

```csharp
class A { public virtual void F() => Console.WriteLine("A"); }
class B : A { public sealed override void F() => Console.WriteLine("B"); }
class C : B
{
    public new void F() => Console.WriteLine("C"); // 숨김만 가능
}

A x = new C();
x.F(); // B (B에서 sealed override로 고정)
```

### 11.2 추상 속성과 오버라이드

```csharp
abstract class Base
{
    public abstract int Count { get; }
}

class Impl : Base
{
    private readonly List<int> _xs = new();
    public override int Count => _xs.Count;
}
```

### 11.3 가상 인덱서

```csharp
abstract class Bag<T>
{
    public abstract T this[int i] { get; set; }
}

class ListBag<T> : Bag<T>
{
    private readonly List<T> _inner = new();
    public override T this[int i]
    {
        get => _inner[i];
        set => _inner[i] = value;
    }
}
```

### 11.4 이벤트 가상화

```csharp
abstract class Notifier
{
    public virtual event EventHandler? Changed;
    protected void OnChanged() => Changed?.Invoke(this, EventArgs.Empty);
}

class BufferedNotifier : Notifier
{
    private bool _buffering;
    public void Start() => _buffering = true;
    public void Stop() { _buffering = false; OnChanged(); }
}
```

---

## 12. 수학적 직관 — 다형성의 비용 vs 이득

가상 호출은 간단히 말해 **간접 참조 1회**의 비용을 추가합니다.
핫 루프 내 호출 횟수가 \(N\)이고, 가상 호출 오버헤드를 \(c\)라 할 때, 추가 비용은:

$$
\Delta T \approx N \cdot c
$$

- \(c\)는 대개 **작지만 0이 아님**.
- **인라이닝/분기 제거**로 상수 \(c\)를 0에 가깝게 만들 수 있습니다(상황·JIT 최적화 의존).

---

## 13. 체크리스트

- 가상화는 **정말 필요한가?** (확장 지점만)
- 오버라이드 시 **불변조건** 유지되는가?
- `sealed override`로 **행동 고정**이 필요한가?
- `new`로 숨기기보다 **이름 변경/다른 API**가 낫지 않은가?
- 문서/주석으로 **오버라이드 가이드**를 제공했는가?

---

## 14. 연습 과제

1) `abstract class Vehicle`을 만들고 `Start()`를 추상으로, `Describe()`를 가상으로 정의.
   - `Car`, `Bike`에서 구현하고 `Car.Describe()`는 `sealed override`로 고정하세요.
2) `Formatter` 기본 클래스에서 `virtual string Format(string)`을 정의하고,
   - `JsonFormatter`, `CompactFormatter` 파생형을 만들되, `CompactFormatter.Format`은 `sealed override`로.
3) `new`와 `override`의 호출 차이를 보여주는 미니 프로젝트 작성:
   - 같은 이름 `Run()`을 가진 `virtual`·비가상 조합을 만들어 **정적/동적 바인딩** 로그 출력.

---

## 15. 요약

- **`virtual` + `override`**: 런타임 다형성.
- **`new`**: 단순 숨김(정적 바인딩) — **가급적 회피**.
- **`abstract`**: 강제 계약, 공통 로직과 조합해 **템플릿** 설계.
- **`sealed`/`sealed override`**: 확장 금지로 **안정성**·**성능 최적화** 여지 확보.
- **설계 원칙**: 최소 가상화, 상속보다 **컴포지션 우선**, 오버라이드 지점의 **불변조건**을 문서화.
