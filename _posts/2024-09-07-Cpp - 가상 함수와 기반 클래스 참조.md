---
layout: post
title: C++ - 가상 함수와 기반 클래스 참조
date: 2024-09-07 19:20:23 +0900
category: Cpp
---
# 가상 함수 원리와 `this`, `friend`, 기반 클래스 참조(super 대용)

## 0. 한눈 요약

- **가상 함수**는 **vptr(객체 당)** → **vtable(클래스 당)** 을 통해 **런타임 디스패치**한다.  
- **생성자·소멸자 내부**에서는 **정적 타입(현재 생성/소멸 중인 클래스)** 으로 가상 호출이 **정지**된다(주의).  
- **`this`**: 현재 객체 포인터. `const`/`volatile`/ref-qualifier에 따라 타입이 변한다(`T* const`, `const T* const`, `T&&` 등).  
- **기반 클래스 호출(super 대용)**: `Base::func()`로 **명시적 한정**. `using Base::func;`로 오버로드 숨김 해결.  
- **`friend`**: 캡슐화를 뚫고 접근 허용(필요 최소한, 좁은 범위). 테스트, 연산자, PImpl, 빌더 등에서 제한적으로 쓴다.

---

## 1. 가상 함수의 내부: vptr & vtable

### 1.1 개념·구조

- **각 객체**는 보통 **vptr**(숨은 포인터) 1개를 가진다.  
- **각 폴리모픽 클래스**(가상 함수 보유)마다 **vtable**이 있고, **슬롯**에 가상 함수(들) 주소가 배치된다.  
- 호출 시점에 `obj->vptr`이 가리키는 vtable에서 적절한 슬롯을 **간접 참조**하여 함수를 호출한다.

#### 개념적 메모리 스케치(아키텍처 의존, 단순화)
```
Dog object
 ├─ [data...]
 └─ [vptr] ─────────┐
                     ↓
           +--------------------+
 Dog vtable: | &Dog::speak      |
             | &Animal::eat     |  // 재정의 안 한 슬롯은 기반 것 유지 가능
             | &Dog::~Dog       |
           +--------------------+
```

```cpp
#include <iostream>
struct Animal {
    virtual void speak(){ std::cout << "동물 소리\n"; }
    virtual ~Animal() = default; // 폴리모픽 베이스는 가상 소멸자 필수
};
struct Dog : Animal {
    void speak() override { std::cout << "멍멍!\n"; }
};
int main(){
    Animal* a = new Dog;   // vptr → Dog vtable
    a->speak();            // Dog::speak()
    delete a;              // 가상 소멸자 → Dog→Animal 순 소멸
}
```

> **시간복잡도**: 디스패치 한 번은 보통 $$\mathcal{O}(1)$$ 간접 분기. 분기 예측 실패가 핫루프에서 영향 가능.

### 1.2 생성자/소멸자에서의 가상 호출 제한 (중요)

- **생성자**에서 **가상 호출**은 **현재 생성 중인 클래스의 버전**으로 **고정**된다.  
- **소멸자**도 마찬가지로 **현재 소멸 중인 클래스의 버전**으로 고정.

```cpp
#include <iostream>
struct B {
    B(){ f(); }              // 가상 호출처럼 보이지만 B::f 고정
    virtual void f(){ std::cout<<"B::f\n"; }
    virtual ~B(){ f(); }     // 여기서도 B::f
};
struct D : B {
    void f() override { std::cout<<"D::f\n"; }
};
int main(){ D d; }  // 출력: B::f (생성자), B::f (소멸자)
```

> **규칙**: 생성자/소멸자에서 가상 호출을 의도하면 안 된다. NVI(§6) 패턴 등으로 설계를 바꿔라.

### 1.3 순수 가상 호출의 함정

- 생성자/소멸자에서 **순수 가상 함수**가 호출되면 **UB**(정의되지 않은 동작) 가능.  
- 추상 타입의 내부 초기화/정리는 **비가상** 경로로 설계.

---

## 2. `virtual`·`override`·`final`·공변 반환·가상 소멸자

```cpp
struct Base {
    virtual void g() {}
    virtual Base* clone() const = 0; // 순수가상
    virtual ~Base() = default;       // 가상 소멸자
};
struct Der : Base {
    void g() override {}             // 시그니처 불일치 시 컴파일 에러
    Der* clone() const override {    // 공변 반환(covariant): 파생* 허용
        return new Der(*this);
    }
    void h() final {}                // 더 이상 재정의 금지
};
```

- **`override`**: 오타/서명 불일치를 **컴파일 타임**에 잡는다.  
- **`final`**: 더 이상 파생(또는 해당 멤버 재정의) 금지.  
- **가상 소멸자**: `delete Base*`가 파생 소멸자를 호출하도록 **항상** 선언.

---

## 3. 다중 상속, 가상 상속, ‘숨은’ 보정(thunk)

다중 상속·가상 상속에서는 **vtable 레이아웃**과 **this 보정(thunk)** 이 추가될 수 있다.  
즉, 한 베이스에서 다른 베이스로 스텝 이동 시 **오프셋 보정**이 필요해지고, 컴파일러가 **랩퍼(트램펄린)** 를 넣는다.

```cpp
struct Printable { virtual void print() const = 0; virtual ~Printable()=default; };
struct Loggable  { virtual void log()   const = 0; virtual ~Loggable()=default; };

struct Widget : Printable, Loggable {
    void print() const override {}
    void log()   const override {}
};

struct Base { int id{0}; };
struct L : virtual Base {};
struct R : virtual Base {};
struct X : L, R { void set(int v){ id = v; } }; // Base는 1회만 존재(가상 상속)
```

> **지침**:  
> - 데이터 멤버 없는 **순수 인터페이스 다중 상속**은 비교적 안전.  
> - 공통 베이스가 중복되는 경우에만 **가상 상속**을 신중히 사용.

---

## 4. `this` 포인터 — 타입, 체이닝, 한정자(ref/cv)

### 4.1 `this`의 타입

- 비-`const` 멤버: `T* const this`  
- `const` 멤버: `const T* const this`  
- `volatile`/`const volatile`도 동일 원리.

```cpp
class S {
    int x{};
public:
    S& set(int v){ this->x = v; return *this; }        // 체이닝
    int value() const { return x; }                    // const 멤버
};
```

### 4.2 ref-qualifier로 lvalue/rvalue 구분

```cpp
struct Str {
    std::string s;
    std::string&  get() &  { return s; }        // lvalue 객체에서
    std::string&& get() && { return std::move(s);} // rvalue 객체에서
};
Str make();
auto a = Str{}.get();     // rvalue → && 오버로드 선택(이동)
```

- 플루언트 API에서 **불필요한 복사**/**dangling**을 피할 수 있다.

---

## 5. 기반 클래스 참조(super 대용) — 범위 지정과 은닉 해제

### 5.1 `Base::func()`로 명시적 호출

```cpp
#include <iostream>
struct Animal { virtual void speak(){ std::cout<<"동물\n"; } };
struct Dog : Animal {
    void speak() override {
        Animal::speak();   // super 대용
        std::cout << "멍멍!\n";
    }
};
```

### 5.2 이름 숨김(name hiding) 해소 — `using`

```cpp
struct B {
    void f(int){}
};
struct D : B {
    using B::f;        // B::f 오버로드 집합을 다시 노출
    void f(double){}
};
int main(){ D d; d.f(1); d.f(1.0); } // 둘 다 보인다
```

- `D`에서 `f(double)`을 정의하면 `B::f(int)`가 **숨겨진다**. `using`으로 오버로드 세트 복원.

---

## 6. NVI(Non-Virtual Interface): 생성/소멸 가상호출 함정 회피

```cpp
struct Algo {
    void run(){ pre(); step(); post(); } // public 비가상
private:
    void pre(){ /*검증·로그*/ }
    virtual void step() = 0;             // 재정의 지점
    void post(){ /*정리*/ }
};
```

- 외부에 **비가상** API를 제공하고 내부 **가상 지점**만 열어 **계약 위반**을 줄인다.  
- 생성자/소멸자에서 가상 호출을 피하고, **호출 순서/불변식**을 통제.

---

## 7. `friend` — 어디까지 허용할 것인가

### 7.1 friend 함수/클래스

```cpp
#include <iostream>

class Secret {
    int code{1234};
    friend void show(const Secret&); // 함수 friend
public:
    int masked() const { return code % 100; }
};
void show(const Secret& s){ std::cout << s.code << "\n"; }

class Box {
    int w{1}, h{1};
    friend class BoxTester; // 클래스 friend
public:
    int area() const { return w*h; }
};
class BoxTester {
public:
    static void dump(const Box& b){ std::cout<< b.w <<"x"<< b.h <<"\n"; }
};
```

- **양방향 아님**: A가 B를 friend로 주면 **B→A** 접근만 허용.  
- **제한적 사용**: 테스트, 빌더, 연산자 오버로딩(특히 대칭형 `operator<<`, `operator==`), PImpl 내부 등.

### 7.2 템플릿과 friend

```cpp
template <class T> class Vec2;
template <class T>
std::ostream& operator<<(std::ostream&, const Vec2<T>&);

template <class T>
class Vec2 {
    T x{}, y{};
    friend std::ostream& operator<< <T>(std::ostream&, const Vec2&);
public:
    Vec2(T a,T b):x(a),y(b){}
};
```

- 선언과 정의 순서·템플릿 인자 일치에 주의한다.

---

## 8. 객체 슬라이싱, `dynamic_cast`, RTTI 최소화

```cpp
struct B { virtual ~B()=default; };
struct D : B { int extra{}; };

void bad(B b) {}   // ❌ 슬라이싱: D 부분이 잘려 B만 복사
void ok (B& b) {}  // ✅ 참조/포인터

void use(B* pb){
    if (auto pd = dynamic_cast<D*>(pb)) { /* D로 안전 다운캐스트 */ }
}
```

- **LSP** 위반 가능성이 큰 다운캐스트는 **설계로 회피**(가상 행동 노출).  
- RTTI 비용·복잡성 고려해 **최소화**.

---

## 9. 실전 예제 1 — 다형 플러그인 + super 호출 + 테스트 friend

```cpp
#include <iostream>
#include <memory>
#include <vector>

struct Plugin {
    virtual void init()    { std::cout<<"Plugin::init\n"; }
    virtual void process() = 0;
    virtual ~Plugin() = default;
};

struct Echo : Plugin {
    void init() override {
        Plugin::init();          // super 대용
        std::cout<<"Echo::init\n";
    }
    void process() override {
        std::cout<<"echo...\n";
    }
};

class Engine {
    std::vector<std::unique_ptr<Plugin>> plugs_;
    friend struct EngineTester;          // 테스트 도우미에만 제한 공개
public:
    void add(std::unique_ptr<Plugin> p){ plugs_.push_back(std::move(p)); }
    void run(){
        for(auto& p: plugs_){ p->init(); p->process(); }
    }
};
struct EngineTester {
    static size_t count(const Engine& e){ return e.plugs_.size(); } // 검사용
};

int main(){
    Engine e;
    e.add(std::make_unique<Echo>());
    std::cout << "n="<< EngineTester::count(e) << "\n";
    e.run();
}
```

- **소유권**: `unique_ptr`  
- **super 호출**: `Plugin::init()`  
- **friend**: 테스트 헬퍼에 **좁은** 접근 허용

---

## 10. 실전 예제 2 — `this` ref-qualifier로 체이닝 안전화

```cpp
#include <string>
#include <utility>

class Query {
    std::string sql_;
public:
    Query& where(std::string w) &  { sql_ += " WHERE " + w; return *this; }
    Query&& where(std::string w) && { sql_ += " WHERE " + w; return std::move(*this); }

    Query& order(std::string o) &  { sql_ += " ORDER BY " + o; return *this; }
    Query&& order(std::string o) && { sql_ += " ORDER BY " + o; return std::move(*this); }

    const std::string& str() const & { return sql_; }
    std::string        str() &&      { return std::move(sql_); } // 이동 출력
};

int main(){
    Query q;
    auto s = (q.where("x>0").order("x DESC")).str(); // lvalue 체이닝
    auto t = Query{}.where("y<10").order("y").str(); // rvalue 체이닝(이동)
}
```

- lvalue/rvalue **구분**으로 임시 체이닝이 **효율적이고 안전**해진다.

---

## 11. 성능·안전 체크리스트

- [ ] 베이스가 **폴리모픽**이면 **가상 소멸자** 선언  
- [ ] 생성자/소멸자의 **가상 호출 금지**(NVI 도입)  
- [ ] **객체 슬라이싱 금지**(참조/포인터 사용)  
- [ ] 오버라이드엔 **`override`**/필요시 **`final`**  
- [ ] **RTTI 최소화**, 다운캐스트 대신 **가상 인터페이스**  
- [ ] 다중 상속은 **순수 인터페이스** 위주, 공통 베이스는 **가상 상속** 필요 시만  
- [ ] **`friend` 최소화**(테스트·연산자 등 꼭 필요한 경우에만)  
- [ ] 핫 루프에서 가상 호출 과다 → **정적 다형성(CRTP/템플릿 전략)** 고려

---

## 12. 비용 모델(개념)

가상 디스패치의 추정 비용(개념적):
$$
T_{\text{call}} \approx T_{\text{indirect\_load}} + T_{\text{branch\_predict}} + T_{\text{target\_icache}} + T_{\text{func}}
$$
- 핫 경로에서 반복 호출이라면 **CRTP/인라인**으로 대체 고려.

---

## 13. FAQ

- **Q. 왜 `Base`에 가상 소멸자가 꼭 필요한가?**  
  A. `delete Base*`가 파생 소멸자를 호출하지 않아 **자원 누수**가 발생한다.

- **Q. 생성자에서 가상 호출이 안 되는 이유는?**  
  A. 객체가 **아직 파생 부분으로 완성 전**이기 때문이다. vptr이 **현재 단계**로 설정되어 있다.

- **Q. `friend`는 나쁜가?**  
  A. 도구일 뿐이다. **좁게, 명확한 이유로, 최소화**해서 사용하면 유용하다.

- **Q. super는 왜 없나?**  
  A. C++은 **정확한 한정**을 선호한다. `Base::func()`/`using Base::func;`가 의도를 더 분명히 드러낸다.

---

## 14. 실수 모음과 교정

1) **가상 소멸자 누락**
```cpp
struct Base { ~Base(){} };  // ❌
```
→
```cpp
struct Base { virtual ~Base() = default; }; // ✅
```

2) **생성자에서 가상 호출 사용**
```cpp
struct B { B(){ f(); } virtual void f(); }; // ❌
```
→ NVI로 구조 변경.

3) **오버라이드 키워드 누락**
```cpp
struct D: B { void f(){ /*...*/ } }; // 오타/서명 불일치 잡기 어려움
```
→ `void f() override`.

4) **이름 숨김으로 인한 오버로드 소실**
```cpp
struct B{ void f(int); };
struct D: B{ void f(double); }; // B::f 숨김
```
→ `using B::f;`.

---

## 15. 컴파일 권장 옵션

```bash
g++ -std=c++20 -O2 -Wall -Wextra -Werror -pedantic -fsanitize=address,undefined main.cpp -o app
```

---

# 결론

- **vptr/vtable**을 이해하면 가상 호출의 **동작·비용·제약**이 명확해진다.  
- **`this`**와 **ref-qualifier**로 **체이닝/수명/효율**을 세밀하게 통제하라.  
- **super 대용**은 `Base::name`으로, **이름 숨김**은 `using`으로 해결.  
- **`friend`**는 신중하게 **좁게** 사용하라.  
- 핫경로·생성/소멸·다중 상속 등 **함정 지대**에서는 **NVI/CRTP/구성** 같은 패턴으로 **안전성·성능·가독성**을 동시에 챙겨라.