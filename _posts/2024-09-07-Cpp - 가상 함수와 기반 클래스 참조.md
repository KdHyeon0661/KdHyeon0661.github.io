---
layout: post
title: C++ - 가상 함수와 기반 클래스 참조
date: 2024-09-07 19:20:23 +0900
category: Cpp
---
# 가상 함수와 this, friend, 기반 클래스 참조 이해하기

## 개요: C++의 객체 지향 핵심 메커니즘

C++에서 객체 지향 프로그래밍의 핵심은 가상 함수를 통한 다형성입니다. 이 메커니즘은 런타임에 객체의 실제 타입에 따라 적절한 함수를 호출할 수 있게 해주며, `this` 포인터, `friend` 선언, 기반 클래스 접근과 같은 관련 개념들과 함께 사용되어 복잡한 상속 계층을 효과적으로 관리할 수 있도록 합니다. 이 글에서는 이러한 개념들의 내부 동작 원리와 실제 사용 패턴을 심층적으로 살펴보겠습니다.

---

## 가상 함수의 내부 동작 원리

### vptr과 vtable: 런타임 다형성의 기반

가상 함수의 핵심 메커니즘은 두 가지 주요 구성 요소로 이루어집니다: vptr(가상 함수 테이블 포인터)과 vtable(가상 함수 테이블). 각 객체는 자신의 타입에 해당하는 vtable을 가리키는 vptr을 내부적으로 가지고 있으며, vtable에는 해당 클래스의 가상 함수들의 실제 구현 주소가 저장되어 있습니다.

```cpp
#include <iostream>

class Animal {
public:
    virtual void speak() const {
        std::cout << "동물 소리\n";
    }
    virtual ~Animal() = default;  // 가상 소멸자는 필수
};

class Dog : public Animal {
public:
    void speak() const override {
        std::cout << "멍멍!\n";
    }
};

int main() {
    Animal* myPet = new Dog();
    myPet->speak();  // 런타임에 Dog::speak() 호출
    delete myPet;
}
```

위 예제에서 `myPet->speak()` 호출 시, 컴파일러는 다음과 같은 작업을 수행합니다:
1. 객체의 vptr을 통해 vtable에 접근
2. speak 함수에 해당하는 슬롯에서 함수 주소를 가져옴
3. 해당 주소로 점프하여 함수 실행

### 생성자와 소멸자에서의 가상 함수 호출 제한

가상 함수의 중요한 제한 사항 중 하나는 생성자와 소멸자 내부에서의 동작입니다. 이들은 객체의 수명 주기 중 특별한 단계에 있기 때문에 가상 함수가 일반적인 방식으로 동작하지 않습니다.

```cpp
#include <iostream>

class Base {
public:
    Base() {
        // 생성자 내부: 아직 파생 클래스 부분이 초기화되지 않음
        print();  // Base::print() 호출 (가상 함수 아님)
    }
    
    virtual void print() const {
        std::cout << "Base::print()\n";
    }
    
    virtual ~Base() {
        // 소멸자 내부: 파생 클래스 부분이 이미 소멸됨
        print();  // Base::print() 호출 (가상 함수 아님)
    }
};

class Derived : public Base {
public:
    void print() const override {
        std::cout << "Derived::print()\n";
    }
};

int main() {
    Derived d;  // 출력: "Base::print()" (생성자)
               // 객체 소멸 시: "Base::print()" (소멸자)
}
```

생성자와 소멸자에서 가상 함수를 호출하면, 객체가 아직 완전히 생성되거나 이미 부분적으로 소멸된 상태이기 때문에 항상 현재 클래스의 버전이 호출됩니다. 이는 중요한 설계 제약으로, 생성자와 소멸자에서는 가상 함수에 의존하는 로직을 배치하지 않는 것이 좋습니다.

---

## this 포인터: 현재 객체에 대한 접근

### this의 다양한 형태

`this` 포인터는 현재 객체에 대한 포인터로, 멤버 함수 내부에서 암시적으로 사용 가능합니다. `this`의 타입은 멤버 함수의 한정자에 따라 변화합니다.

```cpp
class Example {
    int value;
    
public:
    // 비 const 멤버 함수: Example* const this
    void setValue(int v) {
        this->value = v;  // 명시적 this 사용
        value = v;        // 암시적 this 사용 (동일)
    }
    
    // const 멤버 함수: const Example* const this
    int getValue() const {
        // this->value = 10;  // 오류: const 멤버 함수에서 수정 불가
        return this->value;
    }
    
    // 참조 한정자와 함께 사용
    Example& increment() & {      // lvalue 객체에서 호출
        ++value;
        return *this;            // 체이닝 지원
    }
    
    Example&& increment() && {    // rvalue 객체에서 호출
        ++value;
        return std::move(*this); // 이동 의미론
    }
};
```

### ref-qualifier를 활용한 효율적인 API 설계

C++11에서 도입된 ref-qualifier를 사용하면 객체가 lvalue인지 rvalue인지에 따라 다른 동작을 구현할 수 있습니다.

```cpp
class StringBuilder {
    std::string buffer;
    
public:
    // lvalue 객체에 대한 연산
    StringBuilder& append(const std::string& str) & {
        buffer += str;
        return *this;
    }
    
    // rvalue 객체에 대한 연산 (이동 가능)
    StringBuilder&& append(const std::string& str) && {
        buffer += str;
        return std::move(*this);
    }
    
    // lvalue 객체: 복사 반환
    std::string build() const & {
        return buffer;
    }
    
    // rvalue 객체: 이동 반환
    std::string build() && {
        return std::move(buffer);
    }
};

void example() {
    StringBuilder sb;
    sb.append("Hello").append(" World");
    auto s1 = sb.build();          // 복사 발생
    
    auto s2 = StringBuilder{}
                 .append("Hello")
                 .append(" World")
                 .build();         // 이동만 발생, 효율적
}
```

---

## 기반 클래스 메서드 호출하기

C++에는 Java나 C#의 `super` 키워드와 같은 직접적인 키워드가 없습니다. 대신 범위 지정 연산자를 사용하여 기반 클래스의 메서드를 명시적으로 호출합니다.

### 기본적인 기반 클래스 메서드 호출

```cpp
#include <iostream>

class Logger {
public:
    virtual void log(const std::string& message) {
        std::cout << "[LOG] " << message << "\n";
    }
    
    virtual ~Logger() = default;
};

class TimestampLogger : public Logger {
public:
    void log(const std::string& message) override {
        // 기반 클래스의 log 메서드 호출 (super 대신)
        Logger::log("[" + getTimestamp() + "] " + message);
    }
    
private:
    std::string getTimestamp() const {
        // 시간 정보 반환 (간략화)
        return "2023-10-05 14:30:00";
    }
};
```

### using 선언으로 이름 숨김 문제 해결

파생 클래스에서 기반 클래스의 메서드를 재정의할 때, 동일한 이름의 다른 시그니처를 가진 메서드들이 숨겨지는 문제가 발생할 수 있습니다. 이는 `using` 선언으로 해결할 수 있습니다.

```cpp
class DataProcessor {
public:
    void process(int value) {
        std::cout << "정수 처리: " << value << "\n";
    }
    
    void process(double value) {
        std::cout << "실수 처리: " << value << "\n";
    }
};

class AdvancedProcessor : public DataProcessor {
public:
    // using 선언으로 기반 클래스의 모든 process 오버로드를 노출
    using DataProcessor::process;
    
    // 새로운 오버로드 추가
    void process(const std::string& value) {
        std::cout << "문자열 처리: " << value << "\n";
    }
};

void example() {
    AdvancedProcessor proc;
    proc.process(10);        // DataProcessor::process(int) 호출
    proc.process(3.14);      // DataProcessor::process(double) 호출
    proc.process("text");    // AdvancedProcessor::process(string) 호출
}
```

---

## friend 선언: 제한적인 접근 허용

`friend` 선언은 클래스의 캡슐화를 의도적으로 깨고 특정 함수나 클래스에게 비공개 멤버에 대한 접근 권한을 부여합니다. 이 기능은 신중하게 사용해야 하며, 일반적으로 다음과 같은 경우에 한정적으로 활용됩니다.

### friend의 적절한 사용 사례

```cpp
// 1. 연산자 오버로딩 (특히 대칭적인 연산자)
class Complex {
    double real, imag;
    
public:
    Complex(double r, double i) : real(r), imag(i) {}
    
    // friend 선언으로 대칭적인 operator+ 구현
    friend Complex operator+(const Complex& lhs, const Complex& rhs);
    
    // 비멤버 함수에 private 멤버 접근 권한 부여
    friend std::ostream& operator<<(std::ostream& os, const Complex& c);
    
private:
    double getReal() const { return real; }
    double getImag() const { return imag; }
};

// friend 함수 구현
Complex operator+(const Complex& lhs, const Complex& rhs) {
    return Complex(lhs.real + rhs.real, lhs.imag + rhs.imag);
}

std::ostream& operator<<(std::ostream& os, const Complex& c) {
    return os << c.real << " + " << c.imag << "i";
}

// 2. 테스트를 위한 접근
class Database {
    int connectionCount = 0;
    
    // 테스트 클래스에만 접근 허용
    friend class DatabaseTest;
    
public:
    bool connect() {
        // 연결 로직...
        ++connectionCount;
        return true;
    }
};

// 테스트 클래스
class DatabaseTest {
public:
    static int getConnectionCount(const Database& db) {
        return db.connectionCount;  // private 멤버 접근 가능
    }
};

// 3. 밀접하게 연관된 클래스들 간의 접근
class Window;  // 전방 선언

class WindowManager {
    std::vector<Window*> windows;
    
public:
    void addWindow(Window* win);
    // ...
};

class Window {
    WindowManager* manager = nullptr;
    
    // WindowManager가 Window의 내부 상태에 접근할 수 있도록
    friend class WindowManager;
    
private:
    void setManager(WindowManager* mgr) {
        manager = mgr;
    }
};

void WindowManager::addWindow(Window* win) {
    windows.push_back(win);
    win->setManager(this);  // friend 덕분에 private 메서드 호출 가능
}
```

### friend 사용 지침

1. **최소 권한 원칙**: 필요한 최소한의 함수나 클래스에만 friend 권한 부여
2. **명확한 의도**: friend 관계가 명확히 문서화되어야 함
3. **대안 검토**: friend 대신 public 접근자 메서드나 프로퍼티 패턴을 먼저 고려
4. **테스트 제한**: 테스트 목적의 friend는 가능한 한 제한적으로 사용

---

## NVI 패턴: 가상 함수 호출의 안전한 관리

Non-Virtual Interface(NVI) 패턴은 가상 함수 호출을 보다 안전하게 관리하기 위한 설계 패턴입니다. 공개 인터페이스는 비가상 함수로 제공하고, 실제 가상 함수는 private 또는 protected로 숨겨 확장 포인트를 제공합니다.

```cpp
class Shape {
public:
    // 공개 인터페이스 - 비가상, 불변식 보장
    void draw() const {
        preDraw();          // 사전 조건 검증
        doDraw();           // 실제 그리기 작업 (가상)
        postDraw();         // 사후 정리
    }
    
    virtual ~Shape() = default;

protected:
    // 파생 클래스가 재정의할 수 있는 확장 포인트
    virtual void doDraw() const = 0;
    
private:
    // 내부 헬퍼 함수들
    void preDraw() const {
        // 공통 전처리: 리소스 확인, 로깅 등
        std::cout << "그리기 시작...\n";
    }
    
    void postDraw() const {
        // 공통 후처리: 상태 정리, 로깅 등
        std::cout << "그리기 완료.\n";
    }
};

class Circle : public Shape {
protected:
    void doDraw() const override {
        std::cout << "원 그리기\n";
    }
};

class Square : public Shape {
protected:
    void doDraw() const override {
        std::cout << "사각형 그리기\n";
    }
};
```

NVI 패턴의 장점:
- 가상 함수 호출의 전후에 공통 로직 실행 보장
- 생성자/소멸자에서 가상 함수 호출 문제 회피
- 인터페이스 일관성 유지

---

## 실제 적용 예제: 플러그인 시스템

실제 시나리오에서 이러한 개념들이 어떻게 결합되는지 살펴보기 위해 간단한 플러그인 시스템을 구현해 보겠습니다.

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <string>

// 기반 플러그인 인터페이스
class Plugin {
public:
    virtual ~Plugin() = default;
    
    // NVI 패턴 적용: 공개 인터페이스는 비가상
    void initialize() {
        if (!isInitialized) {
            preInitialize();
            doInitialize();      // 가상 함수 호출
            postInitialize();
            isInitialized = true;
        }
    }
    
    void execute() {
        if (!isInitialized) {
            throw std::runtime_error("플러그인이 초기화되지 않았습니다");
        }
        preExecute();
        doExecute();            // 가상 함수 호출
        postExecute();
    }
    
    const std::string& getName() const {
        return name;
    }

protected:
    explicit Plugin(std::string pluginName) 
        : name(std::move(pluginName)), isInitialized(false) {}
    
    // 파생 클래스가 구현해야 할 가상 함수들
    virtual void doInitialize() = 0;
    virtual void doExecute() = 0;
    
    // 선택적 재정의 가능한 훅 함수들
    virtual void preInitialize() {}
    virtual void postInitialize() {}
    virtual void preExecute() {}
    virtual void postExecute() {}
    
private:
    std::string name;
    bool isInitialized;
};

// 실제 플러그인 구현
class CalculatorPlugin : public Plugin {
public:
    CalculatorPlugin() : Plugin("Calculator") {}
    
protected:
    void doInitialize() override {
        // 기반 클래스 메서드 호출 패턴
        std::cout << Plugin::getName() << " 플러그인 초기화 중...\n";
        cachedValue = 0;
    }
    
    void doExecute() override {
        std::cout << "계산 수행: " << cachedValue << " + 10 = " 
                  << (cachedValue + 10) << "\n";
        cachedValue += 10;
    }
    
    void postExecute() override {
        std::cout << "계산 완료. 현재 값: " << cachedValue << "\n";
    }
    
private:
    int cachedValue;
    
    // 테스트를 위한 friend 선언
    friend class PluginTester;
};

// 플러그인 관리자
class PluginManager {
    std::vector<std::unique_ptr<Plugin>> plugins;
    
public:
    template<typename T, typename... Args>
    void registerPlugin(Args&&... args) {
        auto plugin = std::make_unique<T>(std::forward<Args>(args)...);
        plugins.push_back(std::move(plugin));
    }
    
    void initializeAll() {
        for (auto& plugin : plugins) {
            plugin->initialize();
        }
    }
    
    void executeAll() {
        for (auto& plugin : plugins) {
            plugin->execute();
        }
    }
    
    // 테스트를 위한 제한적 friend 접근
    friend class PluginTester;
};

// 테스트 헬퍼 클래스
class PluginTester {
public:
    static int getCachedValue(const CalculatorPlugin& plugin) {
        return plugin.cachedValue;  // friend 덕분에 private 멤버 접근
    }
    
    static size_t getPluginCount(const PluginManager& manager) {
        return manager.plugins.size();  // friend 덕분에 private 멤버 접근
    }
};

int main() {
    PluginManager manager;
    
    // 플러그인 등록
    manager.registerPlugin<CalculatorPlugin>();
    
    // 테스트
    std::cout << "등록된 플러그인 수: " 
              << PluginTester::getPluginCount(manager) << "\n";
    
    // 플러그인 실행
    manager.initializeAll();
    manager.executeAll();
    manager.executeAll();
    
    return 0;
}
```

이 예제에서는 다음과 같은 개념들이 활용되었습니다:
1. 가상 함수를 통한 다형성
2. NVI 패턴을 통한 안전한 가상 함수 호출
3. 기반 클래스 메서드 호출(`Plugin::getName()`)
4. 테스트를 위한 제한적인 `friend` 사용
5. `this` 포인터의 암시적 사용

---

## 성능 고려사항과 최적화 전략

가상 함수는 강력한 다형성 기능을 제공하지만, 일부 성능 오버헤드를 수반합니다. 이러한 오버헤드를 이해하고 필요한 경우 최적화하는 것이 중요합니다.

### 가상 함수 호출 비용

가상 함수 호출은 일반적으로 다음과 같은 비용을 가집니다:
1. vtable을 통한 간접 호출 (1회의 포인터 역참조)
2. 분기 예측 실패 가능성
3. 인라인 최적화 제한

```cpp
// 성능이 중요한 루프에서의 가상 함수 호출
class Processor {
public:
    virtual void process(int& value) = 0;
};

void processData(std::vector<int>& data, Processor& processor) {
    // 각 반복마다 가상 함수 호출 발생
    for (int& value : data) {
        processor.process(value);  // 가상 함수 호출
    }
}
```

### 최적화 기법

1. **CRTP (Curiously Recurring Template Pattern)**: 컴파일 타임 다형성

```cpp
template <typename Derived>
class ProcessorBase {
public:
    void process(int& value) {
        // 정적 다형성: 컴파일 타임에 함수 결정
        static_cast<Derived*>(this)->processImpl(value);
    }
};

class Multiplier : public ProcessorBase<Multiplier> {
    friend class ProcessorBase<Multiplier>;  // 부모가 자식의 메서드 호출 필요
    
private:
    void processImpl(int& value) {
        value *= 2;
    }
};

// 사용: 인라인 최적화 가능
Multiplier multiplier;
int x = 5;
multiplier.process(x);  // 정적 바인딩, 인라인 가능
```

2. **함수 포인터 기반 전략 패턴**: 가상 함수 대체

```cpp
class FastProcessor {
    using ProcessFunc = void(*)(int&);
    ProcessFunc strategy;
    
public:
    explicit FastProcessor(ProcessFunc func) : strategy(func) {}
    
    void process(int& value) {
        strategy(value);  // 직접 함수 포인터 호출 (가상 함수보다 빠름)
    }
};

void doubleValue(int& value) { value *= 2; }
void incrementValue(int& value) { ++value; }
```

---

## 모범 사례와 주의사항

### 반드시 지켜야 할 규칙들

1. **가상 소멸자 사용**: 다형적 기반 클래스는 반드시 가상 소멸자를 가져야 합니다.
   ```cpp
   // 잘못된 예
   class Base { public: ~Base() {} };  // 비가상 소멸자
   
   // 올바른 예
   class Base { public: virtual ~Base() = default; };  // 가상 소멸자
   ```

2. **override 키워드 사용**: 의도하지 않은 오버라이딩 실수를 방지합니다.
   ```cpp
   class Derived : public Base {
   public:
       void process() override;  // 컴파일 타임에 오류 검출
   };
   ```

3. **생성자/소멸자에서 가상 함수 호출 금지**: 예측 불가능한 동작을 초래합니다.

4. **객체 슬라이싱 방지**: 값으로 전달보다는 참조나 포인터를 사용합니다.
   ```cpp
   // 잘못된 예 (슬라이싱 발생)
   void processAnimal(Animal animal) { ... }
   
   // 올바른 예
   void processAnimal(const Animal& animal) { ... }
   ```

5. **friend의 신중한 사용**: 캡슐화를 깨는 것이므로 정당한 이유가 있을 때만 사용합니다.

### 설계 권장사항

1. **인터페이스 분리**: 작고 집중된 인터페이스를 설계합니다.
2. **구현 상속보다 인터페이스 상속**: 가능하면 비가상 상속을 사용합니다.
3. **다중 상속의 신중한 사용**: 특히 다이아몬드 상속 문제에 주의합니다.
4. **RTTI 최소화**: `dynamic_cast`보다는 가상 함수를 통한 다형성을 활용합니다.

---

## 결론

C++의 가상 함수 메커니즘과 관련 개념들은 객체 지향 설계의 핵심을 이루는 강력한 도구들입니다. vptr과 vtable을 이해하면 가상 함수의 동작 원리와 성능 특성을 파악할 수 있으며, `this` 포인터의 다양한 형태와 ref-qualifier를 활용하면 더 안전하고 효율적인 API를 설계할 수 있습니다.

기반 클래스의 메서드를 호출할 때는 명시적인 범위 지정(`Base::method()`)을 사용하고, `friend` 선언은 최소한으로 제한적으로 적용해야 합니다. 생성자와 소멸자에서의 가상 함수 호출 제한을 이해하고, NVI 패턴 같은 설계 기법을 활용하면 더 견고한 클래스 계층을 구축할 수 있습니다.

이러한 개념들을 효과적으로 조합하면 복잡한 상속 관계에서도 명확하고 유지보수 가능한 코드를 작성할 수 있으며, 성능 요구사항에 맞게 적절한 수준의 추상화와 최적화를 달성할 수 있습니다. 각 도구의 장단점을 이해하고 상황에 맞게 적절히 적용하는 것이 숙련된 C++ 개발자의 역량입니다.