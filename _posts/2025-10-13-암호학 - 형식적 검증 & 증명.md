---
layout: post
title: 암호학 - 형식적 검증 & 증명
date: 2025-10-13 22:30:23 +0900
category: 암호학
---
# 형식적 검증 & 증명 (🚀)

> 이 장은 **계산적(컴퓨테이셔널) 보안의 게임 기반 증명** 직관과 **감쇠 인자(advantage bound)** 를 먼저 익히고,
> **프로토콜 검증 도구(ProVerif, Tamarin, EasyCrypt)** 의 관점/표현력/출력 해석법을 살핀 뒤,
> **구현 수준 검증(Coq, F*/EverCrypt)** 사례와 워크플로까지 연결합니다.
> 목표: “이 프로토콜/코드가 정말 안전한가?”를 **문서화 가능한 주장 + 기계 검증 산출물**로 답하는 법.

---

## ✅ 14.1 두 세계: 상징적(Symbolic) vs 계산적(Computational)

- **상징적(도레브-야오, DY)**
  - 암호는 “**이상적 블랙박스**”: 공격자는 **열쇠 없이는 해제/변조 불가**.
  - 메시지는 **용어(term)**, 규칙은 **재작성/추론**.
  - 장점: **모델링 빠름**, 자동 증명/반례 찾기.
  - 한계: **패딩 구체**, **길이/타이밍/비트 수준**은 추상화됨.
- **계산적(게임 기반)**
  - 공격자는 **다항시간 알고리즘**, 보안은 **확률적**/**경계(advantage)** 로 서술.
  - 장점: **실제 안전성(구체적 경계)**, 암호학적 가정(PRF, LWE 등) 직접 다룸.
  - 한계: 증명은 **수작업/반자동**(EasyCrypt, CryptoVerif 등으로 보조).

> 실무 팁: **프로토콜 레벨**은 상징적 도구(ProVerif/Tamarin)로 **빠른 피드백**,
> **암호 구성/구현**은 계산적/EasyCrypt·Coq·F*로 **타이트한 보증**을 병행.

---

## ✅ 14.2 게임 기반 증명 직관 & 감쇠 인자

### “게임-호핑(Game-Hopping)” 패턴

1) **Game 0**: 실제 실험(예: IND-CPA: 암호문이 진짜-무작위 구분).
2) **Game 1**: 난수 ↔ PRF 교체, 또는 키/노스/태그 분리… 작은 변형.
3) **Game 2** … 최종적으로 **공격자가 구분할 수 없게**(0.5 또는 무시 가능).

각 단계의 변화는 **가정(예: PRF)** 에 근거한 **감쇠 인자**(advantage 증가분)로 상계:
\[
\mathrm{Adv}_{\mathrm{Game0}}(\mathcal{A}) \le
\mathrm{Adv}_{\mathrm{Game1}}(\mathcal{A}) + \underbrace{\mathrm{Adv}^{\mathrm{PRF}}_F(\mathcal{B})}_{\text{교체 비용}} \le \cdots \le \varepsilon
\]

- **타이트함(tightness)**: 감쇠가 작을수록 파라미터 선택이 **경제적**(키 길이, 태그 길이).
- **감쇠의 원인**:
  - 로슈-네그리 장난감 경계, **유니온 바운드**(여러 나쁜 이벤트 합),
  - **포징/콜리전 확률**, **패딩/Nonce 충돌** 등.

### 예: CTR 모드 IND-CPA 스케치

- **가정**: 블록암호 \(E_K\)가 **PRF**.
- **Game 0→1**: 키스트림 \(E_K(\mathrm{ctr})\)을 **진짜 PRF**에서 **완전 난수**로 교체 → **PRF Adv** 만큼 손실.
- **Game 1→2**: Nonce/카운터 충돌이 없다고 가정 → 충돌 확률 \(\le q^2/2^{n+1}\) 만큼 손실.
- **결론**: \(\mathrm{Adv}^{\mathrm{IND\text{-}CPA}}_{\mathrm{CTR}} \le \mathrm{Adv}^{\mathrm{PRF}}_{E} + q^2/2^{n+1}\).

> 핵심: **증명은 설계 규칙(Nonce 고유성)** 을 **정량**으로 만들어 **운영 규칙**(충돌 불가 정책)로 연결.

---

## ✅ 14.3 ProVerif — 자동 추론으로 빠른 위반 찾기

### 관점

- 상징적 모델(피상식적 기법/ Horn clause)로 **기밀성/무결성/상호인증/익명성** 등을 자동 분석.
- **Dolev–Yao** 공격자: 네트워크 완전 제어(주고받기, 합성, 분해).

### 핵심 개념

- **process**(Pi-calculus 유사): `in`, `out`, `event`, `let`, `if`.
- **equational theory**: 해시/암복호/서명 연산의 추상 규칙.
- **query**: `query attacker(x).` (기밀성), `query event(e1) ==> event(e2).` (상호인증).

### 예: 고전 Needham–Schroeder Public-Key (NSPK) & Lowe 수정

> NSPK는 미인증 **반사 공격**으로 깨짐. 수정(NSL)은 **수신자 신원 바인딩** 추가.

**모형(간략)**
```prolog
(* 암호 프리미티브 *)
fun pk(sk): pubkey.
fun senc(bitstring, pubkey): bitstring.
reduc sdec(senc(m, pk(sk)), sk) = m.

free c: channel.       (* 공개 채널 *)
free A,B: name.        (* 에이전트 *)
private free skA, skB: skey.

let P_A =
  new Na: nonce;
  out(c, senc( (A,Na), pk(skB) ));
  in(c, x);
  let (Na1, Nb) = sdec(x, skA) in
  if Na1 = Na then
    out(c, senc(Nb, pk(skB)))
  else 0.

let P_B =
  in(c, y);
  let (A1, Na) = sdec(y, skB) in
  new Nb: nonce;
  out(c, senc( (Na,Nb), pk(skA) ));
  in(c, z);
  let Nb1 = sdec(z, skB) in
  if Nb1 = Nb then event auth(B,A1) else 0.

process
  ( (!P_A) | (!P_B) | (* 공격자 *) 0 )

(* 공격자 비밀 *)
query attacker(skA).  (* false 여야 함 *)
(* 인증 *)
query event(auth(B,A)) ==> event(start(A,B)).
```

- **결과**: 원본 NSPK는 인증 쿼리 **위반**(공격 트레이스 제공).
- **Lowe 수정**: B의 응답에 **B의 신원**을 포함해 바인딩하면 쿼리 만족.

**출력 해석**
- “**RESULT not proved** + counterexample” → 자동 생성된 공격 시나리오(메시지 흐름).
- “**RESULT proved**” → 모델 내에서 속성 보장(현실 구현과의 **모델 일치**는 별도 작업).

> 팁: ProVerif는 **추상화가 과감**하다. **길이/서브정합성/암호강도** 같은 계산적 세부는 별도 점검이 필요.

---

## ✅ 14.4 Tamarin — 현대 프로토콜(예: TLS 1.3, Signal) 분석 강자

### 관점

- **다이어그램/규칙 기반 재작성 시스템** + **상징적 모델**,
- **상호인증, 전진기밀성, 키 갱신**, **상태/키지속성**, **시간/주기 조건**까지 잘 다룸.
- 산출물: **Interactive Proof**(수동 보조), **자동 증명/반례**.

### 문법 감각

- **Rules**: `Premises --> Conclusions` 형식, 메시지 송수신/키유출/이벤트 기록.
- **Lemmas**: `All-Trace`(항상), `Exist-Trace`(가능), **correspondence**/**secrecy**.

### 예: 간단 AKE 스케치(요지)

```tamarin
theory MiniAKE

builtins: hashing, diffie-hellman

rules

  (* Init: A picks x, sends g^x with idA *)
  Init_A:
    [ Fr(x) ]
    --[ Start(A,B,x) ]->
    [ Out( <'gx', exp(g,x), A, B> ), StA(A,B,x) ]

  (* Resp: B picks y, replies with g^y and MAC over transcript *)
  Resp_B:
    [ Fr(y), In( <'gx', GX, A, B> ) ]
    --[ Start(B,A,y) ]->
    [ Out( <'gy', exp(g,y), B, A, h(GX,exp(g,y),A,B)> ), StB(A,B,y,GX) ]

  (* A finishes: checks MAC, derives key *)
  Finish_A:
    [ StA(A,B,x), In( <'gy', GY, B, A, T> ) ]
    --[ AuthA(A,B), Key(A,B,h(exp(GY,x))) ]->
    [ ]

  (* B finishes: record key *)
  Finish_B:
    [ StB(A,B,y,GX) ]
    --[ AuthB(B,A), Key(A,B,h(exp(GX,y))) ]->
    [ ]

lemmas

  secrecy:
    "All A B k #i. Key(A,B,k)@i ==> not (K(k))"

  agreement:
    "All A B #i. AuthA(A,B)@i
      ==> (Ex #j. AuthB(B,A)@j)"
```

- 실제론 **인증자(서명/AEAD)**, **키확인(finished)**, **replay 방지** 등 더 많은 규칙/조건이 필요.
- Tamarin은 **키 갱신(레코드 롤링)**, **재개/PSK**, **포워드-시크릿** 속성 표현에 강함.

> 팁: **증명 의존성 그래프**를 살펴 “어떤 가정이 어떤 성질을 뒷받침하는지” 추적하라.

---

## ✅ 14.5 EasyCrypt — 계산적 게임 증명 보조

### 관점

- **pWhile**(확률적 명령형) 프로그램, **확률/기대값 로직**, **동등성 기반 증명**으로
  **PRF/PRP/IND-CPA** 같은 **정량 증명**을 **반자동**으로 지원.
- **CryptoVerif**도 유사 목적(통계 인자 산출), 여기서는 EasyCrypt 감각으로 예시.

### 예: “PRF를 난수로 교체” 게임 호핑 스케치

```easycrypt
theory CTR_INDCPA.

require import AllCore Distr.

module type PRF = {
  proc F(k:bitstring, x:bitstring) : bitstring
}.

module Game0(PRFImpl:PRF) = {
  var k : bitstring
  proc init() = { k <$ {0,1}^κ; }
  proc enc(n:bitstring, m:bitstring) : bitstring = {
    var ks = PRFImpl.F(k, n);   (* keystream *)
    return m ⊕ ks;
  }
  proc chall(n:bitstring, m0:bitstring, m1:bitstring, b:bool) : bitstring = {
    var ks = PRFImpl.F(k, n);
    return (if b then m0 else m1) ⊕ ks;
  }
}.

module Game1 = {
  (* PRF 대신 랜덤함수 RF을 사용 *)
}.

lemma hop_PRF :
  `|Adv_Game0(A) - Adv_Game1(A)| <= Adv_PRF(B)`.
```

- **요지**: Game0(실제) ↔ Game1(난수) 차이는 **PRF 어드밴티지**로 상계.
- 이후 Nonce 충돌 이벤트를 **테일 바운드**로 처리해 최종 경계를 얻음.

> 팁: EasyCrypt는 **증명 스크립트**를 남겨 **재현 가능한 산출물**을 만든다 — 보고/감사에 적합.

---

## ✅ 14.6 구현 수준 검증: Coq, F* & EverCrypt

### 큰 그림

- **사양(수학적)** → **정제(refinement)** → **실행 코드 추출**.
- 목표: “이 C/asm 라이브러리가 **정확한 수학 의미**를 구현했고, **상수시간/메모리 안전**이며,
  **암호학적 보안 가정**에 따라 **계산적 안전**을 이끈다.”

### F* / Low* / HACL* / EverCrypt

- **F***: 종속 타입/정리 증명/효과 시스템(상태, 메모리)으로 **함수형 + ML** 스타일.
- **Low\***: C 추출 가능한 **시스템 서브셋**.
- **HACL\***: F*로 검증된 **암호 원시(AES/Chacha/Poly1305/HMAC/Curve25519)** → C로 추출.
- **EverCrypt**: **런타임 선택(가속/플랫폼)** + **검증된 백엔드** 조합.

**F* 예: 상수시간 비교 규약(개념)**
```fstar
module Ct

open LowStar.Buffer

val ct_eq: b:Bytes.t -> c:Bytes.t -> Tot bool
(* spec: length b == length c /\ 시간 독립 *)
let ct_eq b c =
  let n = Bytes.length b in
  if n <> Bytes.length c then false
  else
    let acc = ref 0uy in
    for i=0ul to (uint_to_t n - 1ul) do
      acc := (!acc) lor (Bytes.index b i ^^^ Bytes.index c i)
    done;
    (!acc = 0uy)
```
- 실제로는 **비밀-의존 분기/메모리 접근 금지**를 **효과/추적**으로 보장.

### Coq — 순수 수학/구조적 증명 + 추출

- **비트/워드/행렬** 수준 정의로 **S-box/Perm** 정확성, **정렬·파서** 등.
- **CompCert**: C 컴파일러 자체를 증명 — **사양→어셈까지 의미보존**.
- **Fiat-Crypto**: 큰 정수 연산을 **소스 레벨로 생성/검증**(예: Curve25519 필드).

**Coq 예: 간단 정리(교육용)**
```coq
Require Import Coq.ZArith.ZArith.
Open Scope Z.

Lemma xor_self_zero : forall x, Z.lxor x x = 0%Z.
Proof.
  intro. rewrite Z.lxor_nilpotent. reflexivity.
Qed.
```

### 사례 하이라이트

- **miTLS**: TLS 1.3 프로토콜 **사양/구현**(F*)을 **기계 검증**.
- **HACL\*** / **EverCrypt**: 주요 원시들의 **정확성/상수시간/메모리 안전** 보장, 상용 브라우저/OS에 통합.
- **Vale/KaRaMeL**: 검증된 어셈블리(AVX2, NEON) 경로.

> 교훈: **검증된 레퍼런스 + 고품질 추상화**를 **엔진**으로 삼아, 제품 코드에 “검증된 경로”를 꽂는다.

---

## ✅ 14.7 계산적 사운드니스(Computational Soundness)와 모델 간 간극

- **상징적 → 계산적 사운드니스**: 특정 연산 이론(암복호, 서명, 해시)을 가진 DY 모델의 안전성 결과가,
  **적절한 구현** 및 **표준 암호 가정** 하에 **계산적 보안**으로 **들어맞는** 정리들.
- **전제**: 키 길이 충분, 충돌 불가능, Nonce 고유성, 오라클 접근 제한 등.
- 의미: ProVerif/Tamarin의 결과를 **그대로 현실에 투사**하진 말고,
  **사운드니스 정리**의 **전제**가 코드/운영에서 **충족**되는지 체크.

---

## ✅ 14.8 성공적인 검증 프로젝트를 위한 워크플로

1) **명세부터**: 공격자 모델, 보안 속성(기밀성/인증/FS/바인딩/익명성), 신뢰 루트를 **텍스트 명세**로 고정.
2) **모델 계층화**:
   - 상층: ProVerif/Tamarin(역할/메시지/상호인증/키생성·분배·갱신).
   - 하층: EasyCrypt/Coq/F*(암호 원시/조합/감쇠 경계/상수시간).
3) **자동도구 구동**: 반례가 나오면 **프로토콜/명세/가정** 재검토(반례 우선).
4) **증명 산출물**:
   - Tamarin/ProVerif 세션 파일 + 로그,
   - EasyCrypt 스크립트 + 경계 수치,
   - Coq/F* 증명 + CI에서 **재현 빌드**.
5) **코드 연결**: 구현이 **명세와 동형**인지(메시지 포맷/키 파생/Nonce 정책), “**검증된 라이브러리**”를 **직접 참조**.
6) **회귀 방지**: CI에 **증명 재실행**, 문서/버전 라벨링, 승인 절차.

---

## ✅ 14.9 도구별 미니 치트시트

| 도구 | 모델 | 주된 용도 | 장점 | 주의 |
|---|---|---|---|---|
| **ProVerif** | 상징적 | 기밀/인증/익명성 빠른 점검 | 자동화 강력, 사용 쉬움 | 과-추상화(거짓 양성/음성), 이퀘이션 설계 중요 |
| **Tamarin** | 상징적(규칙) | AKE/TLS/Signal 등 복잡 흐름 | 상태/FS/키갱신/시간 조건 표현력 | 학습 곡선, 증명 보조 필요 |
| **EasyCrypt** | 계산적 | 게임 호핑/경계 산출 | 정량 증명, 스크립트 관리 | 모델링 비용, 라이브러리 이해 필요 |
| **Coq** | 계산/수학 | 구현/사양 정밀 증명 | 강력, 생태계(CompCert/Fiat) | 증명 비용 높음 |
| **F*** / **HACL\*** | 구현 | 상수시간·메모리 안전·정확성 | C 추출/고성능, 산업 채택 | 생태 학습, 파이프라인 이해 필요 |

---

## ✅ 14.10 실무 체크리스트

- [ ] **위협/속성 명세**(IND-CPA? FS? KCI? 위장 공격?)를 문서로 고정
- [ ] **Nonce/키 수명** 규칙을 **수학적 가정**으로 명시(충돌/유출 이벤트 경계)
- [ ] **ProVerif/Tamarin** 모델을 **최소·보수적으로** 작성(필수 이벤트 바인딩)
- [ ] **반례**가 나오면 프로토콜/명세/가정 재검토(도구 버그로 치부하지 않기)
- [ ] **EasyCrypt/계산적 경계**로 운영 파라미터(태그 길이, Nonce 도메인) 도출
- [ ] **구현**은 **검증된 라이브러리**를 사용(EverCrypt/HACL*, libsodium 등)
- [ ] **상수시간/직렬화/에러 균일화**(13장)와 **형식 증명**을 함께 본다
- [ ] **CI에 증명** 포함(버전 고정, 재현 가능 아티팩트)

---

## ✅ 14.11 미니 예제 모음

### (A) ProVerif — 간단한 AEAD 래핑 모델

```prolog
fun enc(bitstring, key, nonce, aad): bitstring.
fun dec(bitstring, key, nonce, aad): bitstring.

reduc dec(enc(m,k,n,a), k, n, a) = m.

free c: channel.
private free k: key.

process
  new n: nonce;
  let ct = enc("PAYLOAD", k, n, "v=1") in
  out(c, (n, ct));
  in(c, (n2, ct2));
  let m = dec(ct2, k, n2, "v=1") in  (* 잘못된 aad면 복호 불가 *)
  0.

query attacker(k).                 (* 비밀 *)            (* false 기대 *)
query attacker("PAYLOAD").         (* 기밀성 *)          (* false 기대 *)
```

### (B) Tamarin — 간단한 FS(Forward Secrecy) 속성

```tamarin
lemma fs:
  "All A B k i j. Key(A,B,k)@i & RevealLongTerm(A)@j & j > i ==> not K(k)"
```
- 의미: 세션 후 장기키 유출이 있어도 **세션키**는 안전.

### (C) EasyCrypt — 충돌 이벤트 경계(스케치)

```easycrypt
lemma nonce_collision_bound:
  Pr[RandNonce(q).collide] <= q * (q-1) / (2^96).
```

### (D) F* — HMAC 사양 단서(개념)

```fstar
val hmac: key:bytes -> msg:bytes -> Tot bytes
(* spec: PRF assuming SHA256 modeled as random oracle; constant-time w.r.t secret key *)
```

---

## ✅ 14.12 흔한 함정(안티-패턴)

1) **상징적 모델에서 안전** → 곧바로 “현실 안전”으로 오독
   - 길이/패딩/타이밍/Nonce 규칙이 **추상화**로 사라졌을 수 있음.
2) **증명 산출물 미관리**
   - 논문/슬라이드만 남고, 세션/스크립트/버전이 없어 **재현 불가**.
3) **모델–구현 불일치**
   - 구현이 다른 메시지 포맷/오류/Nonce 생성을 사용.
4) **감쇠 인자 무시**
   - “이론상 안전”이라도 **q²/2ⁿ** 항이 큰데 q가 매우 큼 → 운영 파라미터 재설정 필요.

---

## ✅ 14.13 학습 로드맵(실전 중심)

1) **게임 기반**: IND-CPA/CCA, EUF-CMA, KEM/AEAD 정의 + **게임-호핑** 연습.
2) **ProVerif**: NSPK→NSL→간단 AKE; `query`, `event`, `equational theory` 익히기.
3) **Tamarin**: 키 갱신/FS/재개 모델; **interactive proof** 맛보기.
4) **EasyCrypt**: PRF→IND-CPA CTR, GCM 태그 충돌 경계; 스크립트로 보고서 산출.
5) **F*/Coq**: 상수시간 비교, 파서 안전성, 작은 모듈부터 **CI 추출/테스트**.

---

## ✅ 14.14 요약 카드

- **게임 기반 증명**: 현실 보안 = **어드밴티지 경계** + **운영 파라미터**.
- **상징적 도구**: 빠른 반례 & 구조 점검(ProVerif/Tamarin).
- **계산적 도구**: 정량 경계/EasyCrypt, 구현 정합/Coq/F* 검증.
- **성공 포인트**: **모델–구현 일치**, **Nonce/키 규칙**을 **정량 명세**, **증명 아티팩트의 CI화**.

---

## ✅ 14.15 연습문제

1) CTR-모드 IND-CPA 증명에서 **PRF 가정**과 **Nonce 충돌 이벤트**가 각각 어떤 **감쇠 항**을 만드는지 수식으로 정리하라.
2) ProVerif에서 `query event(e1) ==> event(e2)` 의 의미를 **상호인증** 관점으로 설명하고, 왜 `event` 삽입 위치가 중요한지 논하라.
3) Tamarin의 **Forward Secrecy** 정식을 당신의 AKE 모델에 맞게 작성하고, 장기키 유출 타이밍 가정을 명확히 하라.
4) EasyCrypt 스크립트에서 **Game0→Game1** 호핑의 안전성 손실 값을 어떻게 산출/조합하는지, **유니온 바운드** 예시로 설명하라.
5) F*/HACL* 경로에서 “**상수시간 보장**”을 언어 차원에서 강제하는 방법(효과/타입 추적)을 찾아 간단 예제로 요약하라.
6) 형식적 산출물(세션/스크립트/증명)을 CI에 통합할 때 **재현성**과 **버전 고정**의 모범 사례를 기술하라.
