---
layout: post
title: 논리회로설계 - 카노맵 심화
date: 2025-08-28 22:25:23 +0900
category: 논리회로설계
---
# 카노맵 심화 — **5변수 K-map**, **카노맵의 다른 사용법**, **다른 형태(변형) K-map**

> 표기: \(+\)=OR, \(\cdot\) 또는 생략=AND, \(\overline{A}\)=NOT \(A\).
> 행·열 라벨은 **그레이 코드(00, 01, 11, 10)** 를 사용합니다.
> 목표: 4변수를 넘어 **5변수 K-map**을 정확히 다루고, **설계·검증**에 쓰이는 다양한 사용법, 그리고 **변형 K-map**까지 체계적으로 정리합니다.

---

## 5변수 카노맵 (K-map for 5 Variables)

### 배치 원리(두 장으로 분해)

5번째 변수 \(E\)를 분리해 **4변수 K-map 두 장**으로 나눕니다.

- 왼쪽 판: \(E=0\), 오른쪽 판: \(E=1\)
- 각 판은 \(AB\) (행), \(CD\) (열) 4×4, 그레이 코드 배치

```
          E=0                           E=1
AB\CD | 00  01  11  10        AB\CD | 00  01  11  10
------+----------------        ------+----------------
 00   | m0  m1  m3  m2           00 | m16 m17 m19 m18
 01   | m4  m5  m7  m6           01 | m20 m21 m23 m22
 11   | m12 m13 m15 m14          11 | m28 m29 m31 m30
 10   | m8  m9  m11 m10          10 | m24 m25 m27 m26
```

> 인덱스 규약(관례): **인덱스 = \(16E + 8A + 4B + 2C + D\)**.
> K-map의 **셀 위치**는 그레이 코드지만, 미니텀 인덱스는 **이진수**입니다.

### 인접성 규칙(5변수)

- **판 내부**: 상·하·좌·우 인접 + **테두리 래핑**(좌↔우, 상↔하)
- **판 간**: 두 판의 **동일 좌표(같은 AB·CD)** 는 \(E\)만 다르므로 **인접**
  \[
  E\cdot X + \overline{E}\cdot X = X \quad(\Rightarrow\ E\ \text{소거})
  \]

### 묶음(그룹) 크기

- \(1,2,4,8,16\) **셀 단위**(2의 거듭제곱)
- 5변수에서 가능한 최대 묶음: **16셀**(예: \(AB\) 2행 × \(CD\) 2열 × \(E\) 2판)

### 절차 요약

1) 두 판에 **1**(또는 **\(X\)**)를 채운다.
2) **가장 큰 묶음**부터 찾는다(판 **내부** + **판 간**).
3) 묶음에서 **변하지 않는 변수**만 남겨 **곱항**을 쓴다.
4) **필수 주항(EPI)** 을 우선 선택하고, 남은 1은 **최소 개수**의 주항으로 덮는다.

### 예시 ① — **세로 열×두 판** 묶음( \(E\) 소거 )

가령 두 판에서 **열 \(CD=10\)** 의 **모든 행(AB 4행)** 이 1이라면, 다음 8셀(왼 4 + 오 4)을 하나로 묶을 수 있습니다.

- 고정: \(C=1,\ D=0\)
- 변함: \(A,B,E\)
\[
\boxed{F \supset C\overline{D}}
\]

### 예시 ② — **실전 최소화**

\[
F(A,B,C,D,E)=\sum m(1,3,5,7,\,17,19,21,23)
\]

- 두 판에 표시(1만 표기):

```
E=0                               E=1
AB\CD  00  01  11  10            AB\CD  00  01  11  10
00      .   1   1   .            00      .   1   1   .
01      .   1   1   .            01      .   1   1   .
11      .   .   .   .            11      .   .   .   .
10      .   .   .   .            10      .   .   .   .
```

- 관찰: **열 01, 11** × **행 00, 01** × **두 판(E=0,1)** → **8셀 묶음** 1개
  - 고정: \(A=0\), \(D=1\)
  - 변함: \(B,C,E\)
\[
\boxed{F=\overline{A}D}
\]
→ \(\overline{A}D\) **하나의 주항**으로 8개 미니텀을 모두 덮음(E 소거).

---

## 카노맵의 **다른 사용법** (설계·검증 도구로 활용)

### **POS 최소화(0-묶기)**

SOP는 1을 묶지만, **POS는 0을 묶어 합항**을 얻습니다. 규칙·배치는 동일합니다.

\[
\overline{F}=\sum m(\text{0인 인덱스})
\quad\Rightarrow\quad
F=\prod M(\text{0인 인덱스})
\]

> **팁**: 5변수에서도 0-묶음을 **판 간**으로 만들면 \(E\)가 소거된 **합항**을 얻습니다.

### **don’t care(\(X\)) 적극 활용**

- \(X\)는 0/1 **임의 할당** 가능 → **묶음 크기**를 늘리는 방향으로 포함
- 단, 시스템 상 **실제 미발생**이 보장된 조합만 \(X\)로 둘 것(안전성)

### **해저드(글리치) 분석/완화**

- **정적-1 해저드**: 이론상 1이어야 하는 전이 동안 **잠깐 0**이 튀는 현상
- K-map에서 **인접 1**이 **서로 다른 묶음으로만** 덮여 **중첩이 없을 때** 발생 가능
- **해결**: 합의항(중첩되는 제3 묶음) 추가
\[
F=AB+\overline{A}C \;\Rightarrow\; F'=AB+\overline{A}C+BC
\]

### **다중 출력 공유(PLA/공유 임플리컨트)**

- 여러 출력 K-map을 **겹쳐보고**, 동일 묶음(곱항)을 **공유 블록**으로 구현 → 게이트/PLA 면적 절감

### **상태 부호화/그레이 할당**

- 순차회로 상태 전이를 **1비트 변화**로 만들면 해저드에 유리
- K-map의 그레이 배치가 그 직관을 제공(상·하·좌·우만 인접)

### **MUX/디코더 매핑**

- 묶음이 **열 전체**(또는 **행 전체**)를 덮으면 해당 변수 집합을 **선택선**으로 하는 **MUX/디코더** 구현이 쉬워집니다.
  예) \(C,D\) 가 선택선인 4→1 MUX, 데이터 입력에 \(AB,E\) 함수 배치 등.

---

## 카노맵의 **다른 형태(변형)**

### **Variable-Entered K-map (VEK / VEM)**

- 셀에 0/1 대신 **변수(혹은 보수)** 를 직접 적어 **지도 자체가 식**이 되도록 구성
- 장점: 5~6변수도 **지도 크기 유지**, **인수화/공통인수**가 눈에 잘 보임
- 예) \(F=A(B+C)+\overline{A}C\) 를 VEK로 놓으면, 열 단위로 \(C\) 가 반복되어
  \[
  F=A(B+C)+\overline{A}C = AB + AC + \overline{A}C = AB + C
  \]
  가 **즉시** 보임

### **6변수 이상**

- 6변수: **4변수 K-map 4장**(예: \(E,F\) 조합이 판 선택)
- 7변수: 8장(2×2×2), 8변수: 16장 …
- 실무: 6변수 이상은 K-map보다 **퀘인–맥클러스키** + **Petrick’s method**, 또는 **ESPRESSO**류 알고리즘적 최소화를 병행

### **접힌(folded)/원통·토러스 표현**

- 테두리 래핑을 시각화하려 **좌우를 붙여 원통**, 상하까지 붙여 **토러스**로 그리기도 함(인접성 오류 감소)

### **Veitch 다이어그램/대수 격자**

- K-map의 전신 표기. **샤논 전개**와 **인수화** 대응을 격자 위에서 직관적으로 파악

### **ESOP / Reed–Muller 관점(참고)**

- **체커보드** 패턴(1과 0이 번갈아)은 SOP로 큰 묶음이 어려움 → XOR/XNOR 기반의 **ESOP 전개**가 유리
- VEK와 혼합하면 더 간결한 식을 얻는 경우가 많음

---

## **EPI 기반 최소식 결정(5변수 포함)**

### 용어

- **PI(소수 주항)**: 더 확장 불가능한 최대 크기 묶음
- **EPI(필수 주항)**: 특정 1셀을 **오직 자신만** 덮는 PI

### 절차(5변수에서도 동일)

1) **모든 PI** 찾기(판 **내부/경계/판 간** 묶음)
2) **커버링 차트** 작성(각 1셀이 어느 PI에 덮이는지)
3) **EPI 우선 선택**
4) 잔여 1은 **최소 개수의 PI**로 커버(큰 묶음·많이 덮는 PI 우선)

### 소규모 예(요약)

위 1.6의 \(F=\sum m(1,3,5,7,17,19,21,23)\) 에서,
PI 후보는 **8셀 묶음 1개**(\(\overline{A}D\))가 사실상 전부이며, 이 PI가 모든 1을 **유일**하게 커버 → **EPI**.
\[
\boxed{F=\overline{A}D}
\]

---

## 5변수 **POS 최소화** 한눈에

- 1-묶음과 동일 규칙으로 **0-묶음**을 만들면 **합항**을 얻음
- **판 간 0-묶음**으로 \(E\)를 소거한 **합항**을 구성 → POS 최소화
- 필요 시 \(\overline{F}\) 를 SOP 최소화 후 **드모르간**으로 POS 변환

---

## 프로그램 예제(검증/최소화)

> 아래 코드는 **5변수 두 판 K-map 렌더**, `sympy`를 이용한 **최소화**(SOP/POS), **동치 검증** 예를 보여줍니다.

### 5변수 K-map(두 판) ASCII 렌더

```python
# 5변수(ABCD:E) K-map 두 판 렌더 (그레이 코드 00,01,11,10)

from itertools import product

gray = ['00','01','11','10']

def panel_indices(E):
    """Return 4x4 table of minterm indices for a fixed E (0/1)."""
    tbl = [[None]*4 for _ in range(4)]
    for r,ab in enumerate(gray):
        for c,cd in enumerate(gray):
            A,B = int(ab[0]), int(ab[1])
            C,D = int(cd[0]), int(cd[1])
            idx  = (E<<4) + (A<<3) + (B<<2) + (C<<1) + D  # 16E+8A+4B+2C+D
            tbl[r][c] = idx
    return tbl

def render_panels(ones=set(), xs=set()):
    for E in (0,1):
        tbl = panel_indices(E)
        print(f"E={E}")
        print("AB\\CD  00  01  11  10")
        for r,ab in enumerate(gray):
            row = []
            for c,_ in enumerate(gray):
                m = tbl[r][c]
                row.append('X' if m in xs else ('1' if m in ones else '.'))
            print(f"{ab}    {'  '.join(row)}")
        print()

# 예시: F = Σm(1,3,5,7,17,19,21,23)

render_panels({1,3,5,7,17,19,21,23})
```

### `sympy`로 최소화(SOP/POS) & 동치 검증

```python
# pip install sympy

from sympy import symbols
from sympy.logic.boolalg import SOPform, POSform, simplify_logic, Equivalent

A,B,C,D,E = symbols('A B C D E')

mins = [1,3,5,7,17,19,21,23]
F_sop  = SOPform([E,A,B,C,D], mins)      # 변수 순서는 인덱스 규약에 맞춰 지정
F_dnf  = simplify_logic(F_sop, form='dnf')
F_cnf  = simplify_logic(F_sop, form='cnf')

print("SOP (DNF):", F_dnf)   # 기대: ~A & D
print("POS (CNF):", F_cnf)   # 기대: (D) & (~A) => 동치 형태

# 동치 검증 예(해저드 완화 전/후)

from sympy import Or, And, Not
F0 = Or(And(A,B), And(Not(A),C))         # AB + A' C
F1 = Or(F0, And(B,C))                    # + BC (합의항)
print("F0 vs F1 equivalent?", Equivalent(F0, F1))  # False (해저드 완화 목적)
```

---

## 실무 체크리스트

- [ ] **그레이 코드** 순서를 **일관**되게 사용(01↔11 착각 금지)
- [ ] 5변수는 **두 판의 동일 좌표 인접**을 항상 고려(큰 묶음 기회)
- [ ] **X(don’t care)** 는 묶음 확장에만 포함(안전성 확보)
- [ ] **EPI 먼저** 고정 → 잔여는 **최소 개수의 PI**로 커버
- [ ] SOP·POS **양쪽**을 함께 구해 교차 검증
- [ ] 비동기/CDC 경로는 **합의항 추가** 등 해저드 완화 고려
- [ ] 6변수 이상은 K-map + **알고리즘 최소화**(QM/ESPRESSO) 병행

---

## 연습문제

1) **5변수**: \(F=\sum m(1,3,5,7,\,17,19,21,23)\).
   - (a) 두 판 K-map에 표시하고,
   - (b) **판 간 묶음**을 이용해 최소식을 구하라. (힌트: \(E\)가 소거됨)

2) **해저드 완화**: \(F=AB+\overline{A}C\).
   - (a) 4변수 K-map에서 **정적-1 해저드**가 생길 수 있는 경계(인접 1의 **비중첩**)를 표시하고,
   - (b) 합의항을 **추가**해 해저드를 제거한 식을 쓰라.

3) **VEK 표현**: \(F=A(B+C)+\overline{A}C\).
   - (a) 4변수 **VEK**로 표현하고,
   - (b) 인수화로 최소식( \(AB+C\) )을 유도하라.

4) **POS 최소화(0-묶기)**: 5변수 \(F\)의 0-셋이 주어졌을 때,
   - (a) 0-묶기로 **POS 최소식**을 구하고,
   - (b) \(\overline{F}\) 를 SOP로 최소화한 뒤 **드모르간**으로 동치임을 보이라.

---

## 핵심 요약

- **5변수 K-map**은 \(E=0/1\) **두 판**으로 나누고, **동일 좌표** 간도 **인접**으로 처리한다.
- **판 간 묶음**은 \(E\)를 소거해 **리터럴 수**를 크게 줄인다.
- **EPI**를 우선 선택하고, 남은 1은 **최소 개수 PI**로 커버한다.
- **POS(0-묶기)**, **VEK**, **해저드 분석**, **MUX/PLA 매핑** 등 카노맵은 **설계·검증**의 범용 도구다.
- 6변수 이상은 **K-map + 알고리즘 최소화**(QM/ESPRESSO)를 병행하는 것이 실무적이다.
