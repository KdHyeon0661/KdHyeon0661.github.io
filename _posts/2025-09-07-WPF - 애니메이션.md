---
layout: post
title: WPF - 애니메이션
date: 2025-09-07 17:25:23 +0900
category: WPF
---
# WPF 애니메이션 완전 정복 — Storyboard, Triggers, KeyFrames, Easing, VSM, 코드 제어, 성능·트러블슈팅까지

이 문서는 WPF에서 애니메이션을 구현할 때 알아야 할 모든 핵심 개념과 기법을 체계적으로 설명합니다. **Timeline → Animation → Storyboard → Trigger/VSM → 코드 제어**의 흐름으로 설명하며, 성능과 안정성 팁, 실전 스니펫을 풍부하게 제공합니다.

## 애니메이션 계층 구조 개요

*   **Timeline**: 시간 축의 기본 단위입니다. `Duration`, `BeginTime`, `RepeatBehavior`, `AutoReverse`, `SpeedRatio`, `FillBehavior` 등의 속성을 가집니다.
*   **AnimationTimeline**: 특정 **의존 속성(DependencyProperty)**의 값을 시간에 따라 변화시키는 타입들의 기반 클래스입니다.
    *   `DoubleAnimation`, `ColorAnimation`, `ThicknessAnimation`, `PointAnimation`, `ObjectAnimationUsingKeyFrames` 등이 있습니다.
    *   **KeyFrame** 변형: `DoubleAnimationUsingKeyFrames`, `ColorAnimationUsingKeyFrames` 등이 있습니다.
*   **Storyboard**: 여러 AnimationTimeline을 **묶어서** 대상과 속성에 적용하고 제어하는 컨테이너 역할을 합니다.
*   **Trigger / EventTrigger / VisualStateManager**: 특정 상태나 이벤트에서 **Storyboard를 실행**시키는 선언적 메커니즘입니다.
*   **Code-behind 제어**: `Storyboard.Begin/Stop/Pause/Resume/Seek/Remove` 메서드와 동적으로 Target/Property를 지정하는 방법입니다.

**핵심 원칙**: **애니메이션의 대상은 반드시 DependencyProperty 여야 합니다.** 예를 들어, `Opacity`, `Width`, `RenderTransform.(TranslateTransform.X)`, `BorderBrush.(SolidColorBrush.Color)` 등이 있습니다.

## 필수 문법 빠르게 익히기

### 가장 간단한 애니메이션 (Opacity 페이드)
```xml
<Button Content="Fade Me" x:Name="Btn" Opacity="1">
  <Button.Triggers>
    <EventTrigger RoutedEvent="Button.Click">
      <BeginStoryboard>
        <Storyboard>
          <DoubleAnimation Storyboard.TargetName="Btn"
                           Storyboard.TargetProperty="Opacity"
                           To="0" Duration="0:0:0.3" AutoReverse="True"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Button.Triggers>
</Button>
```

### 이동 애니메이션
```xml
<Button Content="Move" x:Name="MoveBtn">
  <Button.RenderTransform>
    <TranslateTransform x:Name="MoveTT" X="0" Y="0"/>
  </Button.RenderTransform>
  <Button.Triggers>
    <EventTrigger RoutedEvent="Button.Click">
      <BeginStoryboard>
        <Storyboard>
          <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(TranslateTransform.X)"
                           To="120" Duration="0:0:0.4" AutoReverse="True"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Button.Triggers>
</Button>
```

**경로 표기법**:
*   단일 속성: `Opacity`
*   첨부 속성(Attached Property): `(UIElement.RenderTransform).(TranslateTransform.X)`
*   브러시 색상: `(Border.Background).(SolidColorBrush.Color)`

## Storyboard 속성 및 제어 포인트
*   `BeginTime`: 시작 지연 시간 (예: `0:0:0.2` → 200ms 늦게 시작)
*   `Duration`: 총 길이 (예: `0:0:1.2` → 1.2초)
*   `RepeatBehavior`: 반복 설정 (`Forever`, `3x`, `0:0:2` 동안)
*   `AutoReverse`: 왕복 재생 여부
*   `SpeedRatio`: 속도 배수 (2.0 → 2배 빠름)
*   `FillBehavior`:
    *   `HoldEnd` (기본값): 애니메이션 종료 시 마지막 값을 유지
    *   `Stop`: 애니메이션 종료 후 값을 원래 상태로 복귀

### 예제: 반복 왕복 로딩 펄스
```xml
<Ellipse Width="18" Height="18" Fill="#3B82F6" x:Name="Dot">
  <Ellipse.Triggers>
    <EventTrigger RoutedEvent="FrameworkElement.Loaded">
      <BeginStoryboard>
        <Storyboard RepeatBehavior="Forever" AutoReverse="True">
          <DoubleAnimation Storyboard.TargetName="Dot"
                           Storyboard.TargetProperty="Opacity"
                           From="0.4" To="1" Duration="0:0:0.6"/>
          <DoubleAnimation Storyboard.TargetName="Dot"
                           Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleX)"
                           From="0.9" To="1.1" Duration="0:0:0.6"/>
          <DoubleAnimation Storyboard.TargetName="Dot"
                           Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleY)"
                           From="0.9" To="1.1" Duration="0:0:0.6"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Ellipse.Triggers>
  <Ellipse.RenderTransform>
    <ScaleTransform ScaleX="1" ScaleY="1" CenterX="9" CenterY="9"/>
  </Ellipse.RenderTransform>
</Ellipse>
```

## Triggers를 사용한 실행

### Property Trigger (상태 변화에 반응)
```xml
<Style TargetType="Button">
  <Setter Property="RenderTransform">
    <Setter.Value><ScaleTransform ScaleX="1" ScaleY="1"/></Setter.Value>
  </Setter>
  <Style.Triggers>
    <Trigger Property="IsMouseOver" Value="True">
      <Trigger.EnterActions>
        <BeginStoryboard x:Name="GrowSB">
          <Storyboard>
            <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleX)"
                             To="1.05" Duration="0:0:0.08"/>
            <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleY)"
                             To="1.05" Duration="0:0:0.08"/>
          </Storyboard>
        </BeginStoryboard>
      </Trigger.EnterActions>
      <Trigger.ExitActions>
        <StopStoryboard BeginStoryboardName="GrowSB"/>
        <BeginStoryboard>
          <Storyboard>
            <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleX)"
                             To="1" Duration="0:0:0.08"/>
            <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleY)"
                             To="1" Duration="0:0:0.08"/>
          </Storyboard>
        </BeginStoryboard>
      </Trigger.ExitActions>
    </Trigger>
  </Style.Triggers>
</Style>
```

### EventTrigger (주의: WPF의 EventTrigger는 Storyboard 실행 전용)
```xml
<Button Content="Pulse">
  <Button.Triggers>
    <EventTrigger RoutedEvent="Button.Click">
      <BeginStoryboard>
        <Storyboard>
          <DoubleAnimation Storyboard.TargetProperty="Opacity"
                           To="0.3" AutoReverse="True" Duration="0:0:0.12"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Button.Triggers>
</Button>
```

**참고**: 동작이나 명령 실행은 `EventTrigger`가 아니라 **InputBindings, Behaviors, ICommand**를 사용하여 처리하세요.

## KeyFrame 애니메이션 (복잡한 타이밍과 곡선)
`*AnimationUsingKeyFrames`와 `Discrete/Linear/Spline/Easing` keyframe을 사용하여 여러 구간을 시간으로 나누고 각 구간에 다른 보간 방식을 적용할 수 있습니다.

### DoubleAnimationUsingKeyFrames 예제
```xml
<Border x:Name="Panel" Background="#111827" Width="200" Height="6">
  <Border.Triggers>
    <EventTrigger RoutedEvent="Loaded">
      <BeginStoryboard>
        <Storyboard RepeatBehavior="3x">
          <DoubleAnimationUsingKeyFrames
              Storyboard.TargetName="Panel"
              Storyboard.TargetProperty="Width" Duration="0:0:1.5">
            <LinearDoubleKeyFrame Value="200" KeyTime="0:0:0.0"/>
            <SplineDoubleKeyFrame Value="380" KeyTime="0:0:0.6" KeySpline="0.25,0.1 0.25,1"/>
            <EasingDoubleKeyFrame Value="260" KeyTime="0:0:1.5">
              <EasingDoubleKeyFrame.EasingFunction>
                <CubicEase EasingMode="EaseOut"/>
              </EasingDoubleKeyFrame.EasingFunction>
            </EasingDoubleKeyFrame>
          </DoubleAnimationUsingKeyFrames>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Border.Triggers>
</Border>
```

### ColorAnimationUsingKeyFrames 예제
```xml
<Border x:Name="Chip" CornerRadius="12" Padding="6">
  <Border.Background>
    <SolidColorBrush Color="#2563EB"/>
  </Border.Background>
  <Border.Triggers>
    <EventTrigger RoutedEvent="MouseEnter">
      <BeginStoryboard>
        <Storyboard>
          <ColorAnimationUsingKeyFrames
              Storyboard.TargetProperty="(Border.Background).(SolidColorBrush.Color)">
            <DiscreteColorKeyFrame Value="#2563EB" KeyTime="0:0:0"/>
            <LinearColorKeyFrame Value="#1D4ED8"   KeyTime="0:0:0.12"/>
            <LinearColorKeyFrame Value="#1E40AF"   KeyTime="0:0:0.22"/>
          </ColorAnimationUsingKeyFrames>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Border.Triggers>
</Border>
```

**중요**: 공유 리소스(StaticResource)로 정의된 브러시에 애니메이션을 적용하면 **모든 참조자가 영향을 받을 수 있습니다**. 개별 컨트롤 전용 애니메이션은 **로컬 브러시 인스턴스**(또는 `x:Shared="False"` 설정)를 사용하세요.

## Easing 함수를 활용한 자연스러운 모션
`QuadraticEase`, `CubicEase`, `QuarticEase`, `QuinticEase`, `SineEase`, `CircleEase`, `BackEase`, `BounceEase`, `ElasticEase` 등의 함수와 `EaseIn`, `EaseOut`, `EaseInOut` 모드를 사용할 수 있습니다.

```xml
<DoubleAnimation Storyboard.TargetProperty="Opacity" From="0" To="1" Duration="0:0:0.45">
  <DoubleAnimation.EasingFunction>
    <SineEase EasingMode="EaseOut"/>
  </DoubleAnimation.EasingFunction>
</DoubleAnimation>
```

## VisualStateManager(VSM)를 활용한 상태 관리
컨트롤 템플릿에서 상태 전환을 **그룹**으로 명확하게 표현할 수 있습니다.

```xml
<ControlTemplate TargetType="Button">
  <Grid x:Name="Root">
    <Border x:Name="Chrome" Background="{TemplateBinding Background}" CornerRadius="10"/>
    <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
  </Grid>
  <VisualStateManager.VisualStateGroups>
    <VisualStateGroup x:Name="CommonStates">
      <VisualState x:Name="Normal"/>
      <VisualState x:Name="MouseOver">
        <Storyboard>
          <DoubleAnimation Storyboard.TargetName="Chrome"
                           Storyboard.TargetProperty="Opacity"
                           To="0.92" Duration="0:0:0.08"/>
        </Storyboard>
      </VisualState>
      <VisualState x:Name="Pressed">
        <Storyboard>
          <DoubleAnimation Storyboard.TargetName="Root"
                           Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleY)"
                           To="0.98" Duration="0:0:0.06"/>
        </Storyboard>
      </VisualState>
      <VisualState x:Name="Disabled">
        <Storyboard>
          <DoubleAnimation Storyboard.TargetName="Root" Storyboard.TargetProperty="Opacity"
                           To="0.55" Duration="0:0:0.0"/>
        </Storyboard>
      </VisualState>
    </VisualStateGroup>
  </VisualStateManager.VisualStateGroups>
  <Grid.RenderTransform>
    <ScaleTransform ScaleX="1" ScaleY="1"/>
  </Grid.RenderTransform>
</ControlTemplate>
```

**코드에서 상태 전환**: `VisualStateManager.GoToState(this, "Pressed", useTransitions: true);`

## 코드에서 동적 Storyboard 생성 및 제어

### 동적 생성 및 타겟 바인딩
```csharp
var storyboard = new Storyboard { Duration = TimeSpan.FromSeconds(0.4) };
var animation = new DoubleAnimation { To = 1.0, Duration = storyboard.Duration, 
                                      EasingFunction = new CubicEase { EasingMode = EasingMode.EaseOut } };

Storyboard.SetTarget(animation, MyGrid);
Storyboard.SetTargetProperty(animation, new PropertyPath(UIElement.OpacityProperty));
storyboard.Children.Add(animation);

storyboard.Begin(); // 제어: Pause/Resume/Stop/Seek/Remove 가능
```

### BeginStoryboard 이름으로 제어
```xml
<Grid>
  <Grid.Triggers>
    <EventTrigger RoutedEvent="Loaded">
      <BeginStoryboard x:Name="FadeInSB">
        <Storyboard>
          <DoubleAnimation Storyboard.TargetProperty="Opacity" From="0" To="1" Duration="0:0:0.3"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Grid.Triggers>
</Grid>
```
```csharp
// XAML 트리거로 시작된 Storyboard를 Stop/Seek 하려면 찾기:
var fadeIn = (Storyboard)Resources["FadeIn"]; // 별도 리소스로 선언했을 때
// 트리거 내부 BeginStoryboard 이름으로는 XAML에서 <StopStoryboard BeginStoryboardName="FadeInSB"/>로만 제어 가능.
// 동적으로 제어하려면 Storyboard를 리소스 또는 필드로 보관하는 편이 낫습니다.
```

## 레이아웃 변환 vs 렌더 변환
*   **RenderTransform**: **그리기 단계**에서만 변형을 적용합니다. 빠르며 레이아웃에 영향을 주지 않습니다.
*   **LayoutTransform**: **배치/측정** 단계를 다시 수행합니다. 상대적으로 느리지만, 텍스트 회전이나 측정이 필요한 경우에 유용합니다.
*   **애니메이션**은 가능하면 `RenderTransform`을 사용하는 것을 권장합니다.

## 자주 사용하는 타겟 속성 목록
*   **불투명도**: `Opacity`
*   **색상**: `(Border.Background).(SolidColorBrush.Color)`, `(Shape.Fill).(SolidColorBrush.Color)`
*   **크기/위치**: `(FrameworkElement.Width/Height)`, `RenderTransform.(TranslateTransform.X/Y)`
*   **스케일/회전**: `RenderTransform.(ScaleTransform.ScaleX/Y)`, `RenderTransform.(RotateTransform.Angle)`
*   **두께/여백**: `Margin`, `BorderThickness` (ThicknessAnimation)
*   **포인트/패스**: `PointAnimation`, `PointAnimationUsingKeyFrames`
*   **패널 정렬/붙임**: `Canvas.Left/Top`, `Panel.ZIndex`

## 객체 및 가시성 애니메이션

### ObjectAnimationUsingKeyFrames (리소스 교체 등)
```xml
<ObjectAnimationUsingKeyFrames Storyboard.TargetProperty="Visibility" Duration="0:0:0">
  <DiscreteObjectKeyFrame KeyTime="0:0:0.0" Value="{x:Static Visibility.Visible}"/>
</ObjectAnimationUsingKeyFrames>
```

### Visibility와 페이드 동시 제어
WPF는 **Visibility에 직접 더블 애니메이션을 적용할 수 없습니다**. **Opacity**로 페이드 효과를 주고 애니메이션 완료 콜백에서 **Visibility**를 변경하거나, 키프레임을 조합하여 처리해야 합니다.

```xml
<Grid x:Name="Panel" Opacity="0" Visibility="Collapsed">
  <Grid.Triggers>
    <EventTrigger RoutedEvent="Loaded">
      <BeginStoryboard>
        <Storyboard>
          <ObjectAnimationUsingKeyFrames Storyboard.TargetProperty="Visibility">
            <DiscreteObjectKeyFrame KeyTime="0:0:0" Value="{x:Static Visibility.Visible}"/>
          </ObjectAnimationUsingKeyFrames>
          <DoubleAnimation Storyboard.TargetProperty="Opacity" To="1" Duration="0:0:0.25"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Grid.Triggers>
</Grid>
```

## 패턴: 뷰 전환 애니메이션
```xml
<Grid x:Name="Host">
  <ContentPresenter x:Name="ViewA"/>
  <ContentPresenter x:Name="ViewB" Opacity="0">
    <ContentPresenter.RenderTransform>
      <TranslateTransform X="40"/>
    </ContentPresenter.RenderTransform>
  </ContentPresenter>
</Grid>

<!-- 전환 시 -->
<BeginStoryboard>
  <Storyboard FillBehavior="Stop">
    <DoubleAnimation Storyboard.TargetName="ViewA" Storyboard.TargetProperty="Opacity"
                     To="0" Duration="0:0:0.18"/>
    <DoubleAnimation Storyboard.TargetName="ViewB" Storyboard.TargetProperty="Opacity"
                     To="1" Duration="0:0:0.25"/>
    <DoubleAnimation Storyboard.TargetName="ViewB"
                     Storyboard.TargetProperty="(UIElement.RenderTransform).(TranslateTransform.X)"
                     From="40" To="0" Duration="0:0:0.25"/>
  </Storyboard>
</BeginStoryboard>
```

**참고**: `FillBehavior="Stop"`을 사용하면 애니메이션 종료 후 속성이 원래 상태로 복귀합니다. 전환이 완료된 후 상태를 고정하려면 애니메이션 종료 이벤트에서 속성 값을 수동으로 고정하거나, `HoldEnd`로 설정하고 다음 상태의 애니메이션으로 덮어쓰는 방법을 사용하세요.

## 성능 및 안정성 팁
1.  **RenderTransform 우선**: 레이아웃 변화를 최소화하기 위해 가능하면 `RenderTransform`을 사용하세요.
2.  **Freezable 객체 주의**: Brush나 Geometry와 같은 `Freezable` 객체를 공유 리소스로 사용하면서 애니메이션을 적용하면 안 됩니다. 개별 인스턴스를 사용하세요 (`x:Shared="False"` 또는 로컬 인스턴스).
3.  **트리거 복잡도 관리**: 너무 잦은 트리거 실행이나 복잡한 트리 구조는 성능 저하를 초래할 수 있습니다. VSM으로 상태를 그룹화하여 관리하세요.
4.  **애니메이션 프레임 관리**: WPF는 기본적으로 가변 렌더링을 사용합니다. 과도하게 많은 애니메이션을 동시에 실행하는 것을 피하고, 가능한 한 경량화하세요.
5.  **BitmapCache 활용**: 복잡한 시각 요소에 `CacheMode="BitmapCache"`를 설정하여 래스터라이즈할 수 있습니다. (상황에 따라 품질과 메모리 사용량 간의 트레이드오프 고려)
6.  **CompositionTarget.Rendering 이벤트**: 이 이벤트는 매 프레임 호출되므로 남용하지 마세요.
7.  **FillBehavior와 최종 상태**: `FillBehavior` 설정과 최종 상태 간의 충돌을 명확히 이해하고 적절히 설정하세요.

## MVVM 친화적 패턴
*   **ViewModel → 상태 변경** → View의 **Triggers**/**VSM**가 Storyboard 실행
*   또는 **Blend Behaviors**(System.Windows.Interactivity 또는 Microsoft.Xaml.Behaviors.Wpf) 사용:
    ```xml
    <i:Interaction.Triggers>
      <i:EventTrigger EventName="SomeEventFromVM">
        <i:ControlStoryboardAction Storyboard="{StaticResource SlideIn}"/>
      </i:EventTrigger>
    </i:Interaction.Triggers>
    ```
*   순수 WPF만으로도 충분하지만, Behaviors를 사용하면 명령이나 조건 조합을 XAML만으로 구성하기 편리합니다.

## Seek 및 Skip 제어
*   `Storyboard.Seek`로 특정 시점으로 점프하거나, `SeekAlignedToLastTick`, `SkipToFill` 등을 사용할 수 있습니다.
*   여러 Storyboard의 **동기화**가 필요하다면 **동일한 Duration/KeyTime**을 적용하고 이벤트를 통해 동작을 묶으세요.

```csharp
storyboard.Begin(this, true);        // isControllable: true
storyboard.Seek(this, TimeSpan.FromSeconds(0.5), TimeSeekOrigin.BeginTime);
storyboard.Pause(this);
storyboard.Resume(this);
storyboard.Stop(this);
```

## 일반적인 오류/함정 및 해결 방법
*   **TargetProperty 경로 오타**: `(UIElement.RenderTransform).(TranslateTransform.X)`에서 괄호 누락이나 타입 오타가 발생하면 애니메이션이 무시됩니다.
*   **Freezable 객체 동결**: 공유 브러시에 Color 애니메이션을 적용할 때 동작하지 않을 수 있습니다. 로컬 브러시 인스턴스를 사용하세요.
*   **Visibility 애니메이션 오해**: `Visibility` 자체는 연속적인 값이 아닙니다. `Opacity`로 페이드 효과를 주고 `ObjectAnimation`으로 토글하세요.
*   **FillBehavior 충돌**: `Stop`으로 설정했는데 최종 값을 유지하려고 한다면, `HoldEnd`를 사용하거나 애니메이션 종료 시 값을 수동으로 고정하세요.
*   **EventTrigger 남용**: `EventTrigger`는 Storyboard 실행 전용입니다. 다른 로직 실행은 명령이나 코드를 사용하세요.

## 실전에서 바로 사용 가능한 스니펫 모음

### FadeIn/FadeOut 리소스
```xml
<Window.Resources>
  <Storyboard x:Key="FadeIn">
    <DoubleAnimation Storyboard.TargetProperty="Opacity" From="0" To="1" Duration="0:0:0.22"/>
  </Storyboard>
  <Storyboard x:Key="FadeOut">
    <DoubleAnimation Storyboard.TargetProperty="Opacity" To="0" Duration="0:0:0.18"/>
  </Storyboard>
</Window.Resources>
```

### SlideUp 알림 패널
```xml
<Grid x:Name="Toast" Opacity="0" RenderTransformOrigin="0.5,0.5">
  <Grid.RenderTransform><TranslateTransform Y="20"/></Grid.RenderTransform>
  <Grid.Triggers>
    <EventTrigger RoutedEvent="Loaded">
      <BeginStoryboard>
        <Storyboard>
          <DoubleAnimation Storyboard.TargetProperty="Opacity" To="1" Duration="0:0:0.18"/>
          <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(TranslateTransform.Y)"
                           From="20" To="0" Duration="0:0:0.2"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Grid.Triggers>
</Grid>
```

### ProgressBar 컬러 스윕
```xml
<ProgressBar x:Name="Bar" Minimum="0" Maximum="100" Value="60" Height="10">
  <ProgressBar.Foreground>
    <SolidColorBrush Color="#22C55E"/>
  </ProgressBar.Foreground>
  <ProgressBar.Triggers>
    <EventTrigger RoutedEvent="Loaded">
      <BeginStoryboard>
        <Storyboard RepeatBehavior="Forever">
          <ColorAnimationUsingKeyFrames Storyboard.TargetProperty="(ProgressBar.Foreground).(SolidColorBrush.Color)">
            <LinearColorKeyFrame Value="#22C55E" KeyTime="0:0:0"/>
            <LinearColorKeyFrame Value="#F59E0B" KeyTime="0:0:0.6"/>
            <LinearColorKeyFrame Value="#EF4444" KeyTime="0:0:1.2"/>
          </ColorAnimationUsingKeyFrames>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </ProgressBar.Triggers>
</ProgressBar>
```

### 버튼 클릭 "리플" 효과 (단순 버전)
```xml
<Button Content="Ripple" Padding="12,7">
  <Button.Template>
    <ControlTemplate TargetType="Button">
      <Grid>
        <Border x:Name="Chrome" Background="{TemplateBinding Background}" CornerRadius="10"/>
        <Ellipse x:Name="Ripple" Width="0" Height="0" Fill="#40FFFFFF" Opacity="0"
                 HorizontalAlignment="Center" VerticalAlignment="Center"/>
        <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center" Margin="{TemplateBinding Padding}"/>
      </Grid>
      <ControlTemplate.Triggers>
        <EventTrigger RoutedEvent="Button.Click">
          <BeginStoryboard>
            <Storyboard>
              <DoubleAnimation Storyboard.TargetName="Ripple" Storyboard.TargetProperty="Opacity"
                               From="0.0" To="0.6" Duration="0:0:0.08" AutoReverse="True"/>
              <DoubleAnimation Storyboard.TargetName="Ripple" Storyboard.TargetProperty="Width"
                               To="260" Duration="0:0:0.25"/>
              <DoubleAnimation Storyboard.TargetName="Ripple" Storyboard.TargetProperty="Height"
                               To="260" Duration="0:0:0.25"/>
            </Storyboard>
          </BeginStoryboard>
        </EventTrigger>
      </ControlTemplate.Triggers>
    </ControlTemplate>
  </Button.Template>
</Button>
```

## 결론
WPF 애니메이션은 **선언적(XAML) 접근**과 **코드 제어**가 균형을 이루는 강력한 도구입니다. **간단한 효과**는 Storyboard와 Trigger를 사용하여 쉽게 구현할 수 있고, **복잡한 상태 머신**이나 **동적 구성**이 필요한 경우에는 코드나 VSM을 활용하면 관리가 용이합니다. 위에서 제시한 스니펫과 패턴을 조합하여 **페이지 전환, 로딩 인디케이터, 사용자 피드백, 시각적 집중 유도** 등 다양한 사용자 경험을 향상시키는 데 활용해 보세요. 핵심은 적절한 도구를 적절한 상황에 사용하고, 성능과 유지보수성을 고려한 설계를 하는 것입니다.