---
layout: post
title: WPF - 애니메이션
date: 2025-09-07 17:25:23 +0900
category: WPF
---
# 🎞️ WPF 애니메이션 완전 정복 — Storyboard, Triggers, KeyFrames, Easing, VSM, 코드 제어, 성능·트러블슈팅까지

> 이 문서는 WPF에서 **애니메이션**을 구현할 때 알아야 할 거의 모든 것을 “빠짐없이” 다룹니다.  
> **Timeline → Animation → Storyboard → Trigger/VSM → 코드 제어** 흐름으로 설명하고,  
> **성능/안정성 팁**과 **실전 스니펫**을 풍부하게 제공합니다.

---

## 0) 큰 그림: 애니메이션 계층 구조

- **Timeline**: 시간 축의 기본 단위. `Duration`, `BeginTime`, `RepeatBehavior`, `AutoReverse`, `SpeedRatio`, `FillBehavior` 등을 가짐.  
- **AnimationTimeline**: 특정 **의존 속성(DependencyProperty)** 값을 시간에 따라 변화시키는 타입들의 기반.
  - `DoubleAnimation`, `ColorAnimation`, `ThicknessAnimation`, `PointAnimation`, `ObjectAnimationUsingKeyFrames`, …
  - *KeyFrame* 변형: `DoubleAnimationUsingKeyFrames`, `ColorAnimationUsingKeyFrames` 등.
- **Storyboard**: 여러 AnimationTimeline을 **묶어** 대상/속성에 적용하고 제어하는 컨테이너.
- **Trigger / EventTrigger / VisualStateManager**: 특정 상태/이벤트에서 **Storyboard를 실행**시키는 선언적 메커니즘.
- **Code-behind 제어**: `Storyboard.Begin/Stop/Pause/Resume/Seek/Remove` + 동적으로 Target/Property 지정.

> 핵심: **애니메이션 대상은 반드시 DependencyProperty** 여야 합니다.  
> 예) `Opacity`, `Width`, `RenderTransform.(TranslateTransform.X)`, `BorderBrush.(SolidColorBrush.Color)` 등

---

## 1) 필수 문법 빠르게 보기

### 1.1 가장 간단한 애니메이션 (Opacity 페이드)
```xml
<Button Content="Fade Me" x:Name="Btn" Opacity="1">
  <Button.Triggers>
    <EventTrigger RoutedEvent="Button.Click">
      <BeginStoryboard>
        <Storyboard>
          <DoubleAnimation Storyboard.TargetName="Btn"
                           Storyboard.TargetProperty="Opacity"
                           To="0" Duration="0:0:0.3" AutoReverse="True"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Button.Triggers>
</Button>
```

### 1.2 변환(Transform) 애니메이션
```xml
<Button Content="Move" x:Name="MoveBtn">
  <Button.RenderTransform>
    <TranslateTransform x:Name="MoveTT" X="0" Y="0"/>
  </Button.RenderTransform>

  <Button.Triggers>
    <EventTrigger RoutedEvent="Button.Click">
      <BeginStoryboard>
        <Storyboard>
          <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(TranslateTransform.X)"
                           To="120" Duration="0:0:0.4" AutoReverse="True"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Button.Triggers>
</Button>
```

> **경로 표기**:  
> - 단일 속성: `Opacity`  
> - 첨자(첨자/첨부): `(UIElement.RenderTransform).(TranslateTransform.X)`  
> - 브러시 색상: `(Border.Background).(SolidColorBrush.Color)`

---

## 2) Storyboard 속성 & 제어 포인트

- `BeginTime`: 시작 지연 (`0:0:0.2` → 200ms 늦게 시작)
- `Duration`: 총 길이 (`0:0:1.2` → 1.2초)
- `RepeatBehavior`: 반복 (`Forever`, `3x`, `0:0:2` 동안)
- `AutoReverse`: 왕복 재생 여부
- `SpeedRatio`: 속도 배수 (2.0 → 2배 빠름)
- `FillBehavior`:
  - `HoldEnd`(기본): 끝 값 유지
  - `Stop`: 종료 후 값을 원상 복귀

### 2.1 예: 반복+왕복 로딩 펄스
```xml
<Ellipse Width="18" Height="18" Fill="#3B82F6" x:Name="Dot">
  <Ellipse.Triggers>
    <EventTrigger RoutedEvent="FrameworkElement.Loaded">
      <BeginStoryboard>
        <Storyboard RepeatBehavior="Forever" AutoReverse="True">
          <DoubleAnimation Storyboard.TargetName="Dot"
                           Storyboard.TargetProperty="Opacity"
                           From="0.4" To="1" Duration="0:0:0.6"/>
          <DoubleAnimation Storyboard.TargetName="Dot"
                           Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleX)"
                           From="0.9" To="1.1" Duration="0:0:0.6"/>
          <DoubleAnimation Storyboard.TargetName="Dot"
                           Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleY)"
                           From="0.9" To="1.1" Duration="0:0:0.6"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Ellipse.Triggers>
  <Ellipse.RenderTransform>
    <ScaleTransform ScaleX="1" ScaleY="1" CenterX="9" CenterY="9"/>
  </Ellipse.RenderTransform>
</Ellipse>
```

---

## 3) Triggers로 실행하기

### 3.1 Property Trigger (상태 변화에 반응)
```xml
<Style TargetType="Button">
  <Setter Property="RenderTransform">
    <Setter.Value><ScaleTransform ScaleX="1" ScaleY="1"/></Setter.Value>
  </Setter>

  <Style.Triggers>
    <Trigger Property="IsMouseOver" Value="True">
      <Trigger.EnterActions>
        <BeginStoryboard x:Name="GrowSB">
          <Storyboard>
            <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleX)"
                             To="1.05" Duration="0:0:0.08"/>
            <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleY)"
                             To="1.05" Duration="0:0:0.08"/>
          </Storyboard>
        </BeginStoryboard>
      </Trigger.EnterActions>
      <Trigger.ExitActions>
        <StopStoryboard BeginStoryboardName="GrowSB"/>
        <BeginStoryboard>
          <Storyboard>
            <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleX)"
                             To="1" Duration="0:0:0.08"/>
            <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleY)"
                             To="1" Duration="0:0:0.08"/>
          </Storyboard>
        </BeginStoryboard>
      </Trigger.ExitActions>
    </Trigger>
  </Style.Triggers>
</Style>
```

### 3.2 EventTrigger (주의: WPF의 EventTrigger는 **Storyboard 전용**)
```xml
<Button Content="Pulse">
  <Button.Triggers>
    <EventTrigger RoutedEvent="Button.Click">
      <BeginStoryboard>
        <Storyboard>
          <DoubleAnimation Storyboard.TargetProperty="Opacity"
                           To="0.3" AutoReverse="True" Duration="0:0:0.12"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Button.Triggers>
</Button>
```

> 동작/명령 실행은 `EventTrigger`가 아니라 **InputBindings, Behaviors, ICommand**로 처리하세요.

---

## 4) KeyFrame 애니메이션 (복잡한 타이밍·곡선)

- `*AnimationUsingKeyFrames` + `Discrete/Linear/Spline/Easing` keyframe
- **여러 구간**을 시간으로 나누고 각 구간에 다른 보간을 적용

### 4.1 DoubleAnimationUsingKeyFrames
```xml
<Border x:Name="Panel" Background="#111827" Width="200" Height="6">
  <Border.Triggers>
    <EventTrigger RoutedEvent="Loaded">
      <BeginStoryboard>
        <Storyboard RepeatBehavior="3x">
          <DoubleAnimationUsingKeyFrames
              Storyboard.TargetName="Panel"
              Storyboard.TargetProperty="Width" Duration="0:0:1.5">
            <LinearDoubleKeyFrame Value="200" KeyTime="0:0:0.0"/>
            <SplineDoubleKeyFrame Value="380" KeyTime="0:0:0.6" KeySpline="0.25,0.1 0.25,1"/>
            <EasingDoubleKeyFrame Value="260" KeyTime="0:0:1.5">
              <EasingDoubleKeyFrame.EasingFunction>
                <CubicEase EasingMode="EaseOut"/>
              </EasingDoubleKeyFrame.EasingFunction>
            </EasingDoubleKeyFrame>
          </DoubleAnimationUsingKeyFrames>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Border.Triggers>
</Border>
```

### 4.2 ColorAnimationUsingKeyFrames
```xml
<Border x:Name="Chip" CornerRadius="12" Padding="6">
  <Border.Background>
    <SolidColorBrush Color="#2563EB"/>
  </Border.Background>
  <Border.Triggers>
    <EventTrigger RoutedEvent="MouseEnter">
      <BeginStoryboard>
        <Storyboard>
          <ColorAnimationUsingKeyFrames
              Storyboard.TargetProperty="(Border.Background).(SolidColorBrush.Color)">
            <DiscreteColorKeyFrame Value="#2563EB" KeyTime="0:0:0"/>
            <LinearColorKeyFrame Value="#1D4ED8"   KeyTime="0:0:0.12"/>
            <LinearColorKeyFrame Value="#1E40AF"   KeyTime="0:0:0.22"/>
          </ColorAnimationUsingKeyFrames>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Border.Triggers>
</Border>
```

> **브러시 주의**: 공유 리소스(StaticResource) 브러시에 애니메이션을 걸면 **모든 참조자**가 바뀔 수 있습니다.  
> 개별 컨트롤 전용 애니메이션은 **로컬 브러시 인스턴스**(또는 `x:Shared="False"`)를 사용하세요.

---

## 5) Easing 함수로 자연스러운 모션

- `QuadraticEase`, `CubicEase`, `QuarticEase`, `QuinticEase`, `SineEase`, `CircleEase`, `BackEase`, `BounceEase`, `ElasticEase`  
- `EasingMode`: `EaseIn`, `EaseOut`, `EaseInOut`

```xml
<DoubleAnimation Storyboard.TargetProperty="Opacity" From="0" To="1" Duration="0:0:0.45">
  <DoubleAnimation.EasingFunction>
    <SineEase EasingMode="EaseOut"/>
  </DoubleAnimation.EasingFunction>
</DoubleAnimation>
```

---

## 6) VisualStateManager(VSM)로 상태 관리

컨트롤 템플릿에서 상태 전환을 **그룹**으로 명확하게 표현할 수 있습니다.

```xml
<ControlTemplate TargetType="Button">
  <Grid x:Name="Root">
    <Border x:Name="Chrome" Background="{TemplateBinding Background}" CornerRadius="10"/>
    <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
  </Grid>

  <VisualStateManager.VisualStateGroups>
    <VisualStateGroup x:Name="CommonStates">
      <VisualState x:Name="Normal"/>
      <VisualState x:Name="MouseOver">
        <Storyboard>
          <DoubleAnimation Storyboard.TargetName="Chrome"
                           Storyboard.TargetProperty="Opacity"
                           To="0.92" Duration="0:0:0.08"/>
        </Storyboard>
      </VisualState>
      <VisualState x:Name="Pressed">
        <Storyboard>
          <DoubleAnimation Storyboard.TargetName="Root"
                           Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleY)"
                           To="0.98" Duration="0:0:0.06"/>
        </Storyboard>
      </VisualState>
      <VisualState x:Name="Disabled">
        <Storyboard>
          <DoubleAnimation Storyboard.TargetName="Root" Storyboard.TargetProperty="Opacity"
                           To="0.55" Duration="0:0:0.0"/>
        </Storyboard>
      </VisualState>
    </VisualStateGroup>
  </VisualStateManager.VisualStateGroups>

  <Grid.RenderTransform>
    <ScaleTransform ScaleX="1" ScaleY="1"/>
  </Grid.RenderTransform>
</ControlTemplate>
```

> 코드에서 상태 전환:  
> `VisualStateManager.GoToState(this, "Pressed", useTransitions: true);`

---

## 7) 코드에서 동적 Storyboard 생성/제어

### 7.1 동적 생성 + 타겟 바인딩
```csharp
var sb = new Storyboard { Duration = TimeSpan.FromSeconds(0.4) };
var da = new DoubleAnimation { To = 1.0, Duration = sb.Duration, EasingFunction = new CubicEase { EasingMode = EasingMode.EaseOut } };

Storyboard.SetTarget(da, MyGrid);
Storyboard.SetTargetProperty(da, new PropertyPath(UIElement.OpacityProperty));
sb.Children.Add(da);

sb.Begin(); // 제어: Pause/Resume/Stop/Seek/Remove 가능
```

### 7.2 BeginStoryboard 이름으로 제어
```xml
<Grid>
  <Grid.Triggers>
    <EventTrigger RoutedEvent="Loaded">
      <BeginStoryboard x:Name="FadeInSB">
        <Storyboard>
          <DoubleAnimation Storyboard.TargetProperty="Opacity" From="0" To="1" Duration="0:0:0.3"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Grid.Triggers>
</Grid>
```
```csharp
// XAML 트리거로 시작된 Storyboard를 Stop/Seek 하려면 찾기:
var fadeIn = (Storyboard)Resources["FadeIn"]; // 별도 리소스로 선언했을 때
// 트리거 내부 BeginStoryboard 이름으로는 XAML에서 <StopStoryboard BeginStoryboardName="FadeInSB"/>로만 제어 가능.
// 동적으로 제어하려면 Storyboard를 리소스 또는 필드로 보관하는 편이 낫습니다.
```

---

## 8) 레이아웃 vs 렌더 변환

- **RenderTransform**: **그리기 단계**에서만 변형(빠름, 레이아웃에 영향 없음).  
- **LayoutTransform**: **배치/측정** 다시 함(느림). 텍스트 회전·측정 필요 시에만.  
- **애니메이션**은 가능하면 `RenderTransform` 사용 권장.

---

## 9) 자주 쓰는 타겟 속성 목록

- **불투명도**: `Opacity`
- **색상**: `(Border.Background).(SolidColorBrush.Color)`, `(Shape.Fill).(SolidColorBrush.Color)`
- **크기/위치**: `(FrameworkElement.Width/Height)`, `RenderTransform.(TranslateTransform.X/Y)`
- **스케일/회전**: `RenderTransform.(ScaleTransform.ScaleX/Y)`, `RenderTransform.(RotateTransform.Angle)`
- **두께/여백**: `Margin`, `BorderThickness` (ThicknessAnimation)
- **포인트/패스**: `PointAnimation`, `PointAnimationUsingKeyFrames`
- **패널 정렬/붙임**: `Canvas.Left/Top`, `Panel.ZIndex`

---

## 10) 객체/가시성 애니메이션

### 10.1 ObjectAnimationUsingKeyFrames (리소스 교체 등)
```xml
<ObjectAnimationUsingKeyFrames Storyboard.TargetProperty="Visibility" Duration="0:0:0">
  <DiscreteObjectKeyFrame KeyTime="0:0:0.0" Value="{x:Static Visibility.Visible}"/>
</ObjectAnimationUsingKeyFrames>
```

### 10.2 Visibility와 페이드 동시 제어
- WPF는 **Visibility에 직접 더블 애니메이션** 불가.  
- **Opacity**로 페이드하고 완료 콜백에서 **Visibility**를 바꾸거나, 키프레임으로 조합.

```xml
<Grid x:Name="Panel" Opacity="0" Visibility="Collapsed">
  <Grid.Triggers>
    <EventTrigger RoutedEvent="Loaded">
      <BeginStoryboard>
        <Storyboard>
          <ObjectAnimationUsingKeyFrames Storyboard.TargetProperty="Visibility">
            <DiscreteObjectKeyFrame KeyTime="0:0:0" Value="{x:Static Visibility.Visible}"/>
          </ObjectAnimationUsingKeyFrames>
          <DoubleAnimation Storyboard.TargetProperty="Opacity" To="1" Duration="0:0:0.25"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Grid.Triggers>
</Grid>
```

---

## 11) 페이지 전환(슬라이드/페이드) 패턴

```xml
<Grid x:Name="Host">
  <ContentPresenter x:Name="ViewA"/>
  <ContentPresenter x:Name="ViewB" Opacity="0">
    <ContentPresenter.RenderTransform>
      <TranslateTransform X="40"/>
    </ContentPresenter.RenderTransform>
  </ContentPresenter>
</Grid>

<!-- 전환 시 -->
<BeginStoryboard>
  <Storyboard FillBehavior="Stop">
    <DoubleAnimation Storyboard.TargetName="ViewA" Storyboard.TargetProperty="Opacity"
                     To="0" Duration="0:0:0.18"/>
    <DoubleAnimation Storyboard.TargetName="ViewB" Storyboard.TargetProperty="Opacity"
                     To="1" Duration="0:0:0.25"/>
    <DoubleAnimation Storyboard.TargetName="ViewB"
                     Storyboard.TargetProperty="(UIElement.RenderTransform).(TranslateTransform.X)"
                     From="40" To="0" Duration="0:0:0.25"/>
  </Storyboard>
</BeginStoryboard>
```

> `FillBehavior="Stop"` 사용 시 애니메이션 종료 후 속성이 원복되므로,  
> 전환 완료시 상태를 고정하려면 종료 이벤트에서 속성 값을 수동 고정하거나, `HoldEnd`로 두고 다음 상태로 덮어씁니다.

---

## 12) 성능·안정성 팁

1. **RenderTransform** 우선, Layout 변화를 최소화  
2. **Freezable**(Brush/Geometry)은 공유 애니메이션 금지 — 개별 인스턴스 사용 (`x:Shared="False"` 또는 로컬)  
3. **너무 잦은 트리거/복잡한 트리**는 비용↑ — VSM로 그룹화  
4. **초당 프레임**: 디폴트로 WPF는 가변 렌더. 과도한 애니메이션 동시 실행을 피하고, 초경량화  
5. **BitmapCache**: 복잡한 시각 요소에 `CacheMode="BitmapCache"`로 래스터라이즈(상황에 따라 품질/메모리 트레이드오프)  
6. **CompositionTarget.Rendering** 이벤트 남용 금지(매 프레임 호출)  
7. **FillBehavior**와 최종 상태 충돌 주의(원복/유지 선택 명확화)

---

## 13) MVVM 친화 패턴

- **ViewModel → 상태 변경** → View의 **Triggers**/**VSM**가 Storyboard 실행  
- 또는 **Blend Behaviors**(System.Windows.Interactivity or Microsoft.Xaml.Behaviors.Wpf) 사용:
  ```xml
  <i:Interaction.Triggers>
    <i:EventTrigger EventName="SomeEventFromVM">
      <i:ControlStoryboardAction Storyboard="{StaticResource SlideIn}"/>
    </i:EventTrigger>
  </i:Interaction.Triggers>
  ```
- 순수 WPF만으로도 충분하나, Behaviors는 명령/조건 조합을 XAML만으로 구성하기 편리.

---

## 14) 고급: 애니메이션 클록(Clock) & Seek/Skip

- `Storyboard.Seek`로 특정 시점으로 점프, `SeekAlignedToLastTick`, `SkipToFill` 등
- 복수 Storyboard의 **동기화**가 필요하다면 **같은 Duration/KeyTime**을 적용하고 이벤트로 동작 묶기

```csharp
sb.Begin(this, true);        // isControllable: true
sb.Seek(this, TimeSpan.FromSeconds(0.5), TimeSeekOrigin.BeginTime);
sb.Pause(this);
sb.Resume(this);
sb.Stop(this);
```

---

## 15) 흔한 에러/함정 & 해결

- **TargetProperty 경로 오타**: `(UIElement.RenderTransform).(TranslateTransform.X)`에서 괄호 누락/타입 오타 → 애니메이션 무시  
- **Freezable Frozen**: 공유 브러시에 Color 애니메이션 시 동작 안 함 → 로컬 브러시 인스턴스 사용  
- **Visibility 애니메이션 오해**: `Visibility` 자체는 연속값 아님 → `Opacity`로 페이드 + `ObjectAnimation`로 토글  
- **FillBehavior 충돌**: `Stop`인데 최종 값 기대 → `HoldEnd` 또는 종료 시 값 고정  
- **EventTrigger 남용**: Storyboard 외 로직 기대 → `EventTrigger`는 Storyboard 전용. 로직은 명령/코드로.

---

## 16) “붙여 넣어 바로 쓰는” 스니펫 모음

### 16.1 FadeIn/FadeOut 리소스
```xml
<Window.Resources>
  <Storyboard x:Key="FadeIn">
    <DoubleAnimation Storyboard.TargetProperty="Opacity" From="0" To="1" Duration="0:0:0.22"/>
  </Storyboard>
  <Storyboard x:Key="FadeOut">
    <DoubleAnimation Storyboard.TargetProperty="Opacity" To="0" Duration="0:0:0.18"/>
  </Storyboard>
</Window.Resources>
```

### 16.2 SlideUp 알림 패널
```xml
<Grid x:Name="Toast" Opacity="0" RenderTransformOrigin="0.5,0.5">
  <Grid.RenderTransform><TranslateTransform Y="20"/></Grid.RenderTransform>
  <Grid.Triggers>
    <EventTrigger RoutedEvent="Loaded">
      <BeginStoryboard>
        <Storyboard>
          <DoubleAnimation Storyboard.TargetProperty="Opacity" To="1" Duration="0:0:0.18"/>
          <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(TranslateTransform.Y)"
                           From="20" To="0" Duration="0:0:0.2"/>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Grid.Triggers>
</Grid>
```

### 16.3 ProgressBar 컬러 스윕
```xml
<ProgressBar x:Name="Bar" Minimum="0" Maximum="100" Value="60" Height="10">
  <ProgressBar.Foreground>
    <SolidColorBrush Color="#22C55E"/>
  </ProgressBar.Foreground>
  <ProgressBar.Triggers>
    <EventTrigger RoutedEvent="Loaded">
      <BeginStoryboard>
        <Storyboard RepeatBehavior="Forever">
          <ColorAnimationUsingKeyFrames Storyboard.TargetProperty="(ProgressBar.Foreground).(SolidColorBrush.Color)">
            <LinearColorKeyFrame Value="#22C55E" KeyTime="0:0:0"/>
            <LinearColorKeyFrame Value="#F59E0B" KeyTime="0:0:0.6"/>
            <LinearColorKeyFrame Value="#EF4444" KeyTime="0:0:1.2"/>
          </ColorAnimationUsingKeyFrames>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </ProgressBar.Triggers>
</ProgressBar>
```

### 16.4 버튼 클릭 “리플” (단순 버전)
```xml
<Button Content="Ripple" Padding="12,7">
  <Button.Template>
    <ControlTemplate TargetType="Button">
      <Grid>
        <Border x:Name="Chrome" Background="{TemplateBinding Background}" CornerRadius="10"/>
        <Ellipse x:Name="Ripple" Width="0" Height="0" Fill="#40FFFFFF" Opacity="0"
                 HorizontalAlignment="Center" VerticalAlignment="Center"/>
        <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center" Margin="{TemplateBinding Padding}"/>
      </Grid>
      <ControlTemplate.Triggers>
        <EventTrigger RoutedEvent="Button.Click">
          <BeginStoryboard>
            <Storyboard>
              <DoubleAnimation Storyboard.TargetName="Ripple" Storyboard.TargetProperty="Opacity"
                               From="0.0" To="0.6" Duration="0:0:0.08" AutoReverse="True"/>
              <DoubleAnimation Storyboard.TargetName="Ripple" Storyboard.TargetProperty="Width"
                               To="260" Duration="0:0:0.25"/>
              <DoubleAnimation Storyboard.TargetName="Ripple" Storyboard.TargetProperty="Height"
                               To="260" Duration="0:0:0.25"/>
            </Storyboard>
          </BeginStoryboard>
        </EventTrigger>
      </ControlTemplate.Triggers>
    </ControlTemplate>
  </Button.Template>
</Button>
```

---

## 17) 체크리스트 (실무용)

- [ ] 대상 속성은 **DependencyProperty**인가?  
- [ ] **RenderTransform** 우선, 레이아웃 변동 최소화  
- [ ] **KeyFrame + Easing**으로 자연스러운 모션  
- [ ] **VSM로 상태**를 그룹화하고 선언적으로 유지  
- [ ] **공유 브러시 애니메이션 금지** — 로컬 인스턴스 또는 `x:Shared="False"`  
- [ ] **FillBehavior/최종 상태** 명확히  
- [ ] **Trigger 남용 금지** — 로직은 명령/코드, 트리거는 Storyboard 실행 전용  
- [ ] 성능: 동시 실행 애니메이션 수/복잡도 제한

---

## 18) 맺음말

WPF 애니메이션은 **선언적(XAML) 접근**과 **코드 제어**가 균형을 이룹니다.  
**간단한 효과**는 Storyboard/Trigger로, **상태 머신**/동적 구성은 코드·VSM로 풀면 관리가 쉽습니다.  
위 스니펫을 조합해 **페이지 전환, 로딩, 피드백, 집중 유도** 등 사용자 경험을 한 단계 끌어올려 보세요. 🚀
