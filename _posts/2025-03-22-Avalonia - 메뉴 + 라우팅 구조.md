---
layout: post
title: Avalonia - 메뉴 + 라우팅 구조
date: 2025-03-22 19:20:23 +0900
category: Avalonia
---
# Avalonia 앱에서 메뉴 + 라우팅(Navigation) 구조 설계

## 0. 목표와 전체 설계

| 목표 | 내용 |
|---|---|
| 메뉴/탐색 UI | 좌측(ListBox)/상단(Menu)로 항목 선택, ContentControl 영역에서 View 전환 |
| DI 기반 라우팅 | `INavigationService`가 ViewModel을 DI로 만들고 ViewLocator로 View 매핑 |
| 파라미터/히스토리 | `Navigate<TVm>(param)` + Back/Forward 스택, 상태 보존 |
| 가드/권한 | 전환 전 `INavigationGuard`로 권한/Dirty 상태 확인 |
| 모듈 확장 | 모듈(`IModule`)이 메뉴/라우트 자동 제공 |
| 애니메이션 | `Transitions`로 Fade/Slide 전환 |
| 복원/딥링크 | 마지막 라우트 복원, 커맨드라인/딥링크 매핑 |
| 테스트/성능 | 서비스 분리, View 캐싱/스코프, Dispose/Deactivation 관리 |

---

## 1. 기본 UI 레이아웃

```xml
<!-- MainWindow.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="clr-namespace:MyApp.ViewModels"
        xmlns:local="clr-namespace:MyApp"
        x:Class="MyApp.MainWindow"
        Width="1200" Height="800">

  <DockPanel>

    <!-- 상단 바(선택) -->
    <Border DockPanel.Dock="Top" Height="48" Background="#1e1e1e">
      <Grid ColumnDefinitions="Auto,*,Auto,Auto" Margin="12,0">
        <TextBlock Text="MyApp" VerticalAlignment="Center" Foreground="White" FontSize="18"/>
        <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="8" VerticalAlignment="Center">
          <Button Content="뒤로" Command="{Binding BackCommand}"/>
          <Button Content="앞으로" Command="{Binding ForwardCommand}"/>
        </StackPanel>
      </Grid>
    </Border>

    <!-- 좌측 메뉴 -->
    <ListBox DockPanel.Dock="Left"
             Width="220"
             Items="{Binding MenuItems}"
             SelectedItem="{Binding SelectedMenuItem}">
      <ListBox.ItemTemplate>
        <DataTemplate>
          <TextBlock Text="{Binding Title}" Margin="12,6"/>
        </DataTemplate>
      </ListBox.ItemTemplate>
    </ListBox>

    <!-- 콘텐츠 영역 -->
    <ContentControl Content="{Binding CurrentView}">
      <ContentControl.Transitions>
        <Transitions>
          <PageSlide Duration="0:0:0.25" SlideDirection="Left"/>
        </Transitions>
      </ContentControl.Transitions>
    </ContentControl>

  </DockPanel>
</Window>
```

> 핵심: `ContentControl.Content = CurrentView`에 전환 애니메이션을 부착.

---

## 2. 메뉴 아이템과 라우트 모델

### 2.1 MenuItem (ViewModel 타입 연결)

```csharp
public sealed class MenuItem
{
    public string Title { get; init; } = "";
    public Type ViewModelType { get; init; } = typeof(object);
    public object? DefaultParameter { get; init; } // 필요 시 초기 파라미터
}
```

### 2.2 Route / RouteEntry (히스토리용)

```csharp
public sealed class Route
{
    public Type ViewModelType { get; }
    public object? Parameter { get; }

    public Route(Type vmType, object? parameter = null)
    {
        ViewModelType = vmType;
        Parameter = parameter;
    }
}

public sealed class RouteEntry
{
    public Route Route { get; }
    public object? ViewModel { get; }
    public IControl? View { get; }

    public RouteEntry(Route route, object? vm, IControl? view)
    {
        Route = route;
        ViewModel = vm;
        View = view;
    }
}
```

---

## 3. ViewLocator (명명 규칙 + DataTemplate 대체)

### 3.1 단순 규칙 기반

```csharp
public static class ViewLocator
{
    public static IControl ResolveView(object viewModel)
    {
        var vmType = viewModel.GetType();
        var viewTypeName = vmType.FullName!.Replace("ViewModel", "View");
        var viewAsm = vmType.Assembly;
        var viewType = viewAsm.GetType(viewTypeName)
                       ?? Type.GetType(viewTypeName); // cross-asm fallback
        if (viewType == null)
            return new TextBlock { Text = $"View Not Found for {vmType.Name}" };

        return (IControl)Activator.CreateInstance(viewType)!;
    }
}
```

> 대안: Avalonia의 `DataTemplates`로 VM-View 자동 매핑도 가능하나, 여기서는 라우팅 서비스가 직접 View를 만들어 넣는 전략을 사용한다.

---

## 4. Navigation Guard (권한/Dirty 확인)

### 4.1 인터페이스

```csharp
public interface INavigationGuard
{
    /// true면 전환 허용, false면 차단
    Task<bool> CanNavigateAsync(Route from, Route to, CancellationToken ct = default);
}
```

### 4.2 예: 저장 안 된 변경사항 확인

```csharp
public interface IDirtyAware
{
    bool IsDirty { get; }
}

public sealed class DirtyGuard : INavigationGuard
{
    private readonly Func<Task<bool>> _confirm; // 메시지 박스 추상화

    public DirtyGuard(Func<Task<bool>> confirm)
    {
        _confirm = confirm;
    }

    public async Task<bool> CanNavigateAsync(Route from, Route to, CancellationToken ct = default)
    {
        if (from.Parameter is null && from.ViewModelType == typeof(object)) return true;

        // from VM에 접근하려면 호스트가 현재 VM을 알려주도록 구성하거나,
        // NavigationService가 현재 RouteEntry를 보관해야 한다.
        // 여기서는 NavigationService가 CurrentEntry를 노출한다고 가정.
        var current = NavigationService.CurrentEntry?.ViewModel;
        if (current is IDirtyAware d && d.IsDirty)
        {
            // "저장하지 않은 변경이 있습니다. 이동하시겠습니까?"
            return await _confirm();
        }
        return true;
    }
}
```

---

## 5. INavigationService — 설계

### 5.1 인터페이스(확장)

```csharp
public interface INavigationService
{
    RouteEntry? CurrentEntry { get; }
    bool CanGoBack { get; }
    bool CanGoForward { get; }

    Task NavigateAsync<TViewModel>(object? parameter = null, bool clearForward = true, CancellationToken ct = default);
    Task NavigateAsync(Type viewModelType, object? parameter = null, bool clearForward = true, CancellationToken ct = default);

    Task<bool> BackAsync(CancellationToken ct = default);
    Task<bool> ForwardAsync(CancellationToken ct = default);

    // 복원/딥링크용
    Task<bool> NavigateRouteAsync(Route route, bool clearForward = true, CancellationToken ct = default);
}
```

### 5.2 구현 — 히스토리 스택 + DI + Guard + Dispose

```csharp
public sealed class NavigationService : INavigationService
{
    private readonly IServiceProvider _sp;
    private readonly IEnumerable<INavigationGuard> _guards;
    private readonly SynchronizationContext _ui;
    private readonly Func<IControl?, Task> _present; // ContentControl.Content 교체 함수
    private readonly Stack<RouteEntry> _back = new();
    private readonly Stack<RouteEntry> _forward = new();

    public RouteEntry? CurrentEntry { get; private set; }

    public bool CanGoBack => _back.Count > 0;
    public bool CanGoForward => _forward.Count > 0;

    public NavigationService(
        IServiceProvider sp,
        IEnumerable<INavigationGuard> guards,
        Func<IControl?, Task> present,
        SynchronizationContext ui)
    {
        _sp = sp;
        _guards = guards;
        _present = present;
        _ui = ui;
    }

    public Task NavigateAsync<TViewModel>(object? parameter = null, bool clearForward = true, CancellationToken ct = default)
        => NavigateAsync(typeof(TViewModel), parameter, clearForward, ct);

    public async Task NavigateAsync(Type viewModelType, object? parameter = null, bool clearForward = true, CancellationToken ct = default)
        => await NavigateRouteAsync(new Route(viewModelType, parameter), clearForward, ct);

    public async Task<bool> NavigateRouteAsync(Route route, bool clearForward = true, CancellationToken ct = default)
    {
        var from = CurrentEntry?.Route ?? new Route(typeof(object));
        foreach (var g in _guards)
        {
            if (!await g.CanNavigateAsync(from, route, ct))
                return false;
        }

        // DI 스코프(페이지 수명)에 따라 VM 생성
        using var scope = _sp.CreateScope();
        var vm = scope.ServiceProvider.GetRequiredService(route.ViewModelType);

        // 파라미터 주입(옵션)
        if (vm is IAcceptParameter ap) ap.ApplyParameter(route.Parameter);

        var view = ViewLocator.ResolveView(vm);

        await PresentOnUiAsync(view, ct);

        if (CurrentEntry is not null) _back.Push(CurrentEntry);
        if (clearForward) ClearForward();

        CurrentEntry = new RouteEntry(route, vm, view);
        return true;
    }

    public async Task<bool> BackAsync(CancellationToken ct = default)
    {
        if (!CanGoBack) return false;
        var target = _back.Pop();

        var from = CurrentEntry?.Route ?? new Route(typeof(object));
        foreach (var g in _guards)
        {
            if (!await g.CanNavigateAsync(from, target.Route, ct))
                return false;
        }

        if (CurrentEntry is not null) _forward.Push(CurrentEntry);

        await PresentOnUiAsync(target.View, ct);
        CurrentEntry = target;
        return true;
    }

    public async Task<bool> ForwardAsync(CancellationToken ct = default)
    {
        if (!CanGoForward) return false;
        var target = _forward.Pop();

        var from = CurrentEntry?.Route ?? new Route(typeof(object));
        foreach (var g in _guards)
        {
            if (!await g.CanNavigateAsync(from, target.Route, ct))
                return false;
        }

        if (CurrentEntry is not null) _back.Push(CurrentEntry);

        await PresentOnUiAsync(target.View, ct);
        CurrentEntry = target;
        return true;
    }

    private void ClearForward()
    {
        while (_forward.Count > 0)
        {
            var e = _forward.Pop();
            TryDispose(e.ViewModel);
            TryDispose(e.View);
        }
    }

    private static void TryDispose(object? o)
    {
        switch (o)
        {
            case IAsyncDisposable a: a.DisposeAsync().AsTask().GetAwaiter().GetResult(); break;
            case IDisposable d: d.Dispose(); break;
        }
    }

    private Task PresentOnUiAsync(IControl? view, CancellationToken ct)
    {
        var tcs = new TaskCompletionSource();
        _ui.Post(async _ =>
        {
            await _present(view);
            tcs.SetResult();
        }, null);
        return tcs.Task;
    }
}
```

> `present` 델리게이트는 `ContentControl.Content = view;`를 UI 스레드에서 수행하는 함수.
> ViewModel에 파라미터를 전달하려면 `IAcceptParameter` 등으로 표준화한다.

### 5.3 파라미터 주입 표준

```csharp
public interface IAcceptParameter
{
    void ApplyParameter(object? parameter);
}
```

예: `UserDetailViewModel : IAcceptParameter` → `parameter`에 `userId` 전달.

---

## 6. MainViewModel — 메뉴/명령/히스토리 바인딩

```csharp
using ReactiveUI;
using System.Reactive;
using System.Collections.ObjectModel;

public sealed class MainViewModel : ReactiveObject
{
    private readonly INavigationService _nav;

    public ObservableCollection<MenuItem> MenuItems { get; } = new();

    private MenuItem? _selectedMenuItem;
    public MenuItem? SelectedMenuItem
    {
        get => _selectedMenuItem;
        set
        {
            this.RaiseAndSetIfChanged(ref _selectedMenuItem, value);
            if (value is not null) _ = NavigateFromMenuAsync(value);
        }
    }

    private IControl? _currentView;
    public IControl? CurrentView
    {
        get => _currentView;
        set => this.RaiseAndSetIfChanged(ref _currentView, value);
    }

    public ReactiveCommand<Unit, Unit> BackCommand { get; }
    public ReactiveCommand<Unit, Unit> ForwardCommand { get; }

    public MainViewModel(INavigationService nav, IEnumerable<IModule> modules)
    {
        _nav = nav;

        foreach (var m in modules)
            foreach (var mi in m.GetMenuItems())
                MenuItems.Add(mi);

        BackCommand = ReactiveCommand.CreateFromTask(async () => await _nav.BackAsync());
        ForwardCommand = ReactiveCommand.CreateFromTask(async () => await _nav.ForwardAsync());

        // 초기 화면
        SelectedMenuItem = MenuItems.FirstOrDefault();
    }

    private async Task NavigateFromMenuAsync(MenuItem item)
    {
        await _nav.NavigateAsync(item.ViewModelType, item.DefaultParameter);
        // 화면 갱신 (선택) — NavigationService의 present에서 처리해도 됨
        CurrentView = _nav.CurrentEntry?.View;
    }
}
```

> `present` 델리게이트를 `MainWindowViewModel` 혹은 코드비하인드에서 `ContentControl`에 바인딩되도록 전달한다.

---

## 7. DI 등록(Program.cs/App)

```csharp
var services = new ServiceCollection();

// 라우팅 의존성
services.AddSingleton<INavigationGuard, DirtyGuard>();
services.AddSingleton<INavigationService>(sp =>
{
    // ContentControl.Content 교체 함수 연결
    Func<IControl?, Task> present = async view =>
    {
        var shell = sp.GetRequiredService<ShellViewHost>(); // ContentControl holder
        shell.Content = view;
        await Task.CompletedTask;
    };

    var ui = SynchronizationContext.Current ?? new SynchronizationContext();
    return new NavigationService(sp, sp.GetServices<INavigationGuard>(), present, ui);
});

// 모듈
services.AddSingleton<IModule, DashboardModule>();
services.AddSingleton<IModule, UserModule>();
services.AddSingleton<IModule, SettingsModule>();

// VM/뷰 등록
services.AddTransient<DashboardViewModel>();
services.AddTransient<UserViewModel>();
services.AddTransient<SettingsViewModel>();

// 기타 서비스들...
services.AddSingleton<ShellViewHost>(); // ContentControl 호스트(예: MainWindow의 code-behind가 주입)

var sp = services.BuildServiceProvider();
```

`ShellViewHost`는 단순히 현재 콘텐츠를 보관하는 연결 지점:

```csharp
public sealed class ShellViewHost
{
    public IControl? Content { get; set; }
}
```

MainWindow 코드비하인드에서 `ContentControl.Content = host.Content`를 관찰하거나,
`present`가 직접 MainWindow의 인스턴스를 알고 있다면 바로 교체해도 된다(더 간단).

---

## 8. 모듈 자동 등록

```csharp
public interface IModule
{
    IEnumerable<MenuItem> GetMenuItems();
}

public sealed class DashboardModule : IModule
{
    public IEnumerable<MenuItem> GetMenuItems()
    {
        yield return new MenuItem
        {
            Title = "대시보드",
            ViewModelType = typeof(DashboardViewModel)
        };
    }
}
```

> 각 모듈은 자신이 제공하는 메뉴/라우트를 **자기완결적**으로 정의.
> 권한 기반 필터링은 MainViewModel에서 AuthState를 참조하여 `MenuItems` 채울 때 걸러주면 된다.

---

## 9. 파라미터 전달 예 — 사용자 상세

### 9.1 ViewModel

```csharp
public sealed class UserDetailParameter
{
    public required int UserId { get; init; }
}

public sealed class UserDetailViewModel : ReactiveObject, IAcceptParameter
{
    private readonly IUserRepository _repo;

    public string? UserName { get; private set; }
    public string? Email { get; private set; }

    public UserDetailViewModel(IUserRepository repo) => _repo = repo;

    public void ApplyParameter(object? parameter)
    {
        if (parameter is not UserDetailParameter p) return;
        var user = _repo.GetById(p.UserId);
        UserName = user.Name;
        Email = user.Email;
        this.RaisePropertyChanged(nameof(UserName));
        this.RaisePropertyChanged(nameof(Email));
    }
}
```

### 9.2 사용

```csharp
await _nav.NavigateAsync<UserDetailViewModel>(new UserDetailParameter { UserId = 123 });
```

---

## 10. 탐색 가드 — 권한 기반

```csharp
public interface IAuthState
{
    bool IsAdmin { get; }
}

public sealed class RoleGuard : INavigationGuard
{
    private readonly IAuthState _auth;

    public RoleGuard(IAuthState auth) => _auth = auth;

    public Task<bool> CanNavigateAsync(Route from, Route to, CancellationToken ct = default)
    {
        if (to.ViewModelType == typeof(SettingsViewModel) && !_auth.IsAdmin)
            return Task.FromResult(false);
        return Task.FromResult(true);
    }
}
```

> `DirtyGuard`와 함께 등록하면 전환 시 두 가드가 모두 확인된다.

---

## 11. 애니메이션 전환

이미 `ContentControl.Transitions`에 `PageSlide`를 적용했다.
상황에 따라 `CrossFade`, `PageFade`를 조합할 수 있다.

```xml
<ContentControl.ContentTransitions>
  <Transitions>
    <CrossFade Duration="0:0:0.2"/>
  </Transitions>
</ContentControl.ContentTransitions>
```

---

## 12. 딥링크/재실행 복원

### 12.1 라우트 직렬화

```csharp
public interface IRouteSerializer
{
    string Serialize(Route route);
    Route? Deserialize(string s);
}

public sealed class SimpleRouteSerializer : IRouteSerializer
{
    // 매우 단순: "Namespace.VMType?userId=123" 형태(예시)
    public string Serialize(Route route)
    {
        var typeName = route.ViewModelType.AssemblyQualifiedName!;
        var param = route.Parameter is null ? "" : Uri.EscapeDataString(JsonSerializer.Serialize(route.Parameter));
        return $"{typeName}|{param}";
    }

    public Route? Deserialize(string s)
    {
        var parts = s.Split('|');
        if (parts.Length == 0) return null;
        var type = Type.GetType(parts[0]);
        if (type is null) return null;
        object? param = null;
        if (parts.Length > 1 && !string.IsNullOrEmpty(parts[1]))
            param = JsonSerializer.Deserialize<object>(Uri.UnescapeDataString(parts[1]));
        return new Route(type, param);
    }
}
```

### 12.2 마지막 라우트 저장/복원

앱 종료 시:

```csharp
var ser = sp.GetRequiredService<IRouteSerializer>();
var last = _nav.CurrentEntry?.Route;
if (last is not null)
{
    File.WriteAllText("last.route", ser.Serialize(last));
}
```

앱 시작 시:

```csharp
if (File.Exists("last.route"))
{
    var s = File.ReadAllText("last.route");
    var route = ser.Deserialize(s);
    if (route is not null)
        await _nav.NavigateRouteAsync(route);
}
```

### 12.3 커맨드라인/URL 딥링크

앱 시작 파라미터를 파싱하여 `Route`로 변환 후 `NavigateRouteAsync` 호출.

---

## 13. 테스트 전략

- **ViewLocator**: VM → View 타입명 규칙 매핑 테스트
- **NavigationService**:
  - 가드 허용/차단 시나리오
  - Back/Forward 스택 동작
  - 파라미터 전달 확인( `IAcceptParameter` Mock )
  - `present` 델리게이트를 Test double로 바꾸어 **UI 의존 제거**
- **Serializer**: 라우트 직렬화 왕복 테스트

예: xUnit 간단 테스트 스켈레톤

```csharp
[Fact]
public async Task Navigate_Adds_Back_Entry_And_Clears_Forward()
{
    var sp = BuildServiceProviderForTests();
    var presented = new List<IControl?>();
    var svc = new NavigationService(
        sp, Array.Empty<INavigationGuard>(),
        v => { presented.Add(v); return Task.CompletedTask; },
        new SynchronizationContext());

    await svc.NavigateAsync(typeof(DashboardViewModel));
    await svc.NavigateAsync(typeof(UserViewModel));

    Assert.True(svc.CanGoBack);
    Assert.False(svc.CanGoForward);
}
```

---

## 14. 성능/메모리/수명

- **페이지 스코프 DI**: `CreateScope()`로 페이지별 수명 격리. Back/Forward 보존 시 View/VM 캐싱을 유지하므로, 메모리 용량 고려해 **최대 히스토리 길이**를 제한하거나, Back/Forward 시 매번 재생성하도록 정책화.
- **Dispose**: 히스토리 청소 시 `IDisposable/IAsyncDisposable` 호출. 장시간 열린 리소스(소켓, 타이머)는 페이지 **Deactivation** 시 정지.
- **가벼운 View**: 무거운 데이터는 VM에서 비동기 로딩, View는 단순 표시.
- **Virtualized 메뉴**: 메뉴가 방대하면 `ListBox` 가상화(템플릿 최소화).

---

## 15. 고급 주제

### 15.1 지역(Region) 기반 다영역 라우팅
- 메인 콘텐츠 외에 우측 패널/하단 패널 등 **여러 Region**에 각기 다른 View를 라우팅.
- `INavigationService`를 **RegionId**별로 분리하거나, 단일 서비스가 `RegionHost` 사전을 받아서 지역별 전환 수행.

```csharp
public interface IRegionHost { Func<IControl?, Task> Present { get; } }

public sealed class RegionManager
{
    private readonly Dictionary<string, IRegionHost> _regions = new();
    public void Register(string key, IRegionHost host) => _regions[key] = host;
    public IRegionHost Get(string key) => _regions[key];
}
```

### 15.2 커맨드 기반 내비게이션
- `ReactiveCommand<Type, Unit>` 패턴(이미 초안에 제시) + `CommandParameter`로 라우팅.

### 15.3 저장 전환/라우팅 잠금
- **전역 Busy/Modal 상태**일 때 라우팅 차단(파일 동기화 중 등).

---

## 16. 예시 뷰들

```xml
<!-- Views/DashboardView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="MyApp.Views.DashboardView">
  <StackPanel Margin="16" Spacing="8">
    <TextBlock Text="대시보드" FontSize="22"/>
    <TextBlock Text="요약 지표/그래프 등을 배치"/>
  </StackPanel>
</UserControl>
```

```xml
<!-- Views/UserView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="MyApp.Views.UserView">
  <StackPanel Margin="16">
    <TextBlock Text="사용자 목록" FontSize="22"/>
  </StackPanel>
</UserControl>
```

```xml
<!-- Views/SettingsView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="MyApp.Views.SettingsView">
  <StackPanel Margin="16" Spacing="8">
    <TextBlock Text="설정" FontSize="22"/>
    <TextBlock Text="환경/테마/업데이트 등"/>
  </StackPanel>
</UserControl>
```

---

## 17. 단축키/내비게이션 UX

- 뒤로/앞으로: `Alt+Left/Right` 혹은 `Ctrl+[ / Ctrl+]`
- 검색/명령 팔레트: `Ctrl+K`로 라우트 검색 → 이동
- 포커스 컨텍스트에 따라 특정 Region 라우팅(에디터 탭 전환 등)

---

## 18. 예외 처리와 Fallback

- View 생성 실패: `View Not Found` 대신 **FallbackView**를 표시.
- 저장 실패/권한 오류: `INotificationService`로 상단 토스트/다이얼로그.
- 가드 차단 사유를 사용자에게 피드백(“관리자만 접근 가능”).

---

## 19. 정리

| 요소 | 핵심 |
|---|---|
| 메뉴/라우팅 | `MenuItem` + `INavigationService` + `ViewLocator` |
| 히스토리 | Back/Forward 스택 + View/VM 수명 관리 |
| 파라미터 | `IAcceptParameter`로 표준화 |
| 가드 | Dirty/권한/Busy 상태에서 전환 차단 |
| 모듈 | `IModule.GetMenuItems()`로 자동 조립, 권한 필터 |
| 애니메이션 | `Transitions`로 자연스러운 페이지 전환 |
| 복원/딥링크 | `IRouteSerializer` 직렬화/역직렬화 |
| 테스트/성능 | 서비스 분리, Dispose, Scope, 최대 히스토리 제한 |

> Avalonia는 프레임 내비게이션이 내장되어 있지 않지만, 본 구조로 **실용적이고 확장 가능**한 라우팅을 확보할 수 있다.
> 이후 단계로 **Region 라우팅**, **탭/다중 창**, **상태 보존(폼 상태/스크롤)**, **URL 스키마 핸들러**까지 확장하면 복잡한 데스크톱 앱에서도 웹 수준의 탐색 경험을 제공할 수 있다.
