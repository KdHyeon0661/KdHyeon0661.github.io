---
layout: post
title: DB 심화 - 오라클 파티셔닝
date: 2025-11-24 18:25:23 +0900
category: DB 심화
---
# 오라클 파티셔닝 — **11g 신규 유형**과 **이후 버전 확장**

## 0) 파티셔닝이 필요한 이유(11g “신규 유형”의 탄생 배경)

오라클 파티셔닝은 단순히 테이블을 잘게 쪼개는 기능이 아니다. **대용량을 “운영 가능하게” 만드는 핵심 인프라**다.

- **성능(Pruning / Partition-wise)**  
  - 파티션 키 조건이 있으면 스캔 대상 자체가 줄어든다(정적/동적 프루닝).  
  - 부모-자식이 같은 전략으로 정렬되면 **Partition-Wise Join**이 가능해져 조인 비용이 급격히 줄어든다.
- **유지보수(ILM / Data Lifecycle)**  
  - 오래된 파티션만 **TRUNCATE / DROP / EXCHANGE** 같은 DDL로 통째로 치울 수 있다.  
  - 인덱스/통계/압축/티어링을 **파티션 단위로만** 바꿔도 운영이 된다.
- **동시성/IO 분산**  
  - 서로 다른 파티션은 서로 다른 세그먼트/블록을 쓰므로 경합이 자연스럽게 완화된다.

11g에서 Interval/Reference/System/Virtual Column 파티셔닝이 나온 건 “**성능은 자연스럽게 얻되, 운영/모델링 부담을 줄이기**” 위한 흐름이었다. 

---

## 1) 11g 이전의 기본/복합 파티셔닝(간단 복습)

### 1.1 기본 3종
- **Range / List / Hash**  
  - Range: 시간축(일/월/분기)  
  - List: 코드/리전/상태 값  
  - Hash: 키 값 분산(균등)  

### 1.2 복합(Composite)
- 11g 이전에도 `range-hash`, `range-list` 같은 조합이 존재했지만,  
  **11gR2에서 가능한 조합이 크게 확대**되면서 사실상 “복합 조합의 시대”가 열렸다. 

---

## 2) 11g에서 새로 추가/강화된 파티셔닝 “유형/전략”

### 2.1 Interval Partitioning — 자동으로 늘어나는 Range

#### 2.1.1 왜 필요한가?
기존 Range 파티션은 **미리 파티션을 만들어 둬야** 했다.

- 월 단위 파티션 테이블이면 매달 DDL을 준비해야 한다.
- DDL이 누락되면 적재가 실패한다.
- 중앙 관리가 필요한 배치/ETL 환경에서 관리 포인트가 늘어난다.

Interval 파티션은 이런 운영 부담을 없애기 위해 도입됐다. 11g에서 공식 도입. 

#### 2.1.2 동작 원리(정확히)
- **첫 파티션은 Range로 “전이점(transition point)”**을 만든다.
- 그 이후 경계는 `INTERVAL` 값에 따라 필요한 순간 자동 생성.

```sql
-- 월 단위 Interval-Range
DROP TABLE sales PURGE;
CREATE TABLE sales (
  sales_id     NUMBER PRIMARY KEY,
  sales_date   DATE   NOT NULL,
  amount       NUMBER
)
PARTITION BY RANGE (sales_date)
INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
  PARTITION p0 VALUES LESS THAN (DATE '2023-01-01')  -- transition point
);

INSERT INTO sales VALUES (1, DATE '2023-02-15', 1000);
INSERT INTO sales VALUES (2, DATE '2023-03-05', 2000);

SELECT partition_name, high_value
FROM   user_tab_partitions
WHERE  table_name = 'SALES'
ORDER  BY high_value;
```

#### 2.1.3 제약/주의
- **지원 키**: `DATE/TIMESTAMP` 또는 숫자 Range에서 사용.  
- **전이점 이전 데이터(과거 백필)**가 많이 들어오면,
  Interval 자동 생성이 아니라 p0 Range 파티션쪽으로 몰릴 수 있으니
  **초기 전이점을 실제 운영 시작 시점 근처로 잡는 게 중요**.
- Interval로 자동 생성된 파티션도 **Split/Merge/Exchange/Move** 같은
  파티션 유지보수는 동일하게 가능하다. 

#### 2.1.4 11gR2 확장: Interval-Composite
11gR2에선 Interval을 상위 파티션으로 두고 하위를 List/Hash로 나누는 **Interval-Composite**가 공식 지원된다. 

```sql
-- Interval-List Composite: 상위 월 Interval + 하위 리전 List
DROP TABLE sales_regioned PURGE;
CREATE TABLE sales_regioned (
  id         NUMBER,
  sales_date DATE,
  region     VARCHAR2(10),
  amount     NUMBER
)
PARTITION BY RANGE(sales_date)
INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
SUBPARTITION BY LIST (region) SUBPARTITION TEMPLATE
(
  SUBPARTITION sp_emea  VALUES ('EMEA'),
  SUBPARTITION sp_amer  VALUES ('AMER'),
  SUBPARTITION sp_other VALUES (DEFAULT)
)
(
  PARTITION p0 VALUES LESS THAN (DATE '2023-01-01')
);
```

#### 2.1.5 실무 패턴
- **시간축 ILM이 명확한 대다수 VLDB**에서 표준.
- 분기/월 기준 적재가 자주 있는 배치에서는 Interval이 “기본값”이다.

---

### 2.2 Reference Partitioning — 부모의 파티션을 자식이 상속

#### 2.2.1 왜 필요한가?
부모-자식 모델에서 자식에도 파티션 키를 **중복 컬럼으로 넣어야** Range/List를 맞출 수 있었다.

- 논리 모델이 오염된다.
- 키 중복 저장으로 공간/오류 위험 증가.
- 부모-자식 파티션 유지보수의 불일치(부모만 교체/삭제) 문제.

Reference 파티셔닝은 FK 관계만으로 자식이 부모의 파티션 전략을 상속하게 만든다. 11g 신규 유형. 

#### 2.2.2 요구 조건
- 부모 테이블은 파티션 테이블.
- 자식 테이블에는 부모 PK/UK를 참조하는 **FK가 존재 + ENABLE 상태**.
- 자식은 그 FK를 `PARTITION BY REFERENCE`로 지정.

```sql
-- 부모: 월 Interval
DROP TABLE orders PURGE;
CREATE TABLE orders (
  order_id     NUMBER PRIMARY KEY,
  order_date   DATE   NOT NULL,
  customer_id  NUMBER NOT NULL
)
PARTITION BY RANGE (order_date)
INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
  PARTITION p0 VALUES LESS THAN (DATE '2023-01-01')
);

-- 자식: Reference Partitioning
DROP TABLE order_items PURGE;
CREATE TABLE order_items (
  order_id     NUMBER NOT NULL,
  line_no      NUMBER NOT NULL,
  product_id   NUMBER NOT NULL,
  qty          NUMBER,
  CONSTRAINT pk_order_items PRIMARY KEY (order_id, line_no),
  CONSTRAINT fk_oi_orders
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
)
PARTITION BY REFERENCE (fk_oi_orders);
```

#### 2.2.3 얻는 효과
- 부모/자식 파티션이 **항상 1:1로 정렬 → Partition-Wise Join 최적**.  
- **TRUNCATE/DROP/EXCHANGE가 부모 기준으로 연쇄 적용** → 유지보수 단순화.  
- 자식에 파티션 키 중복 컬럼이 없어서 모델 순수성 유지. 

#### 2.2.4 주의점
- FK 무결성 관리가 느슨하면(Disable/Validate 문제) 상속이 꼬인다.
- 부모 파티션 유지보수는 자식에 **강하게 영향**하므로
  운영 절차(교체/아카이브/삭제) 단위를 **부모 기준으로 통일**해야 한다.

---

### 2.3 System Partitioning — 애플리케이션이 “파티션을 찍어서” 저장

#### 2.3.1 왜 필요한가?
DB에 파티션 경계를 맡기는 대신, **애플리케이션이 라우팅 로직을 가진** 환경이 있다.

- Hot/Warm/Cold 스토리지로 명확하게 분리해 적재하고 싶다.
- 자체 샤딩/라우팅 레이어가 있고 DB는 그 결과만 저장한다.
- 특정 테이블스페이스/디스크/스토리지 클래스에 강제 배치해야 한다.

System 파티셔닝은 이런 상황을 위해 11g에서 제공됐다. 

#### 2.3.2 사용법
```sql
DROP TABLE session_log PURGE;
CREATE TABLE session_log (
  sid        NUMBER,
  log_time   DATE,
  payload    VARCHAR2(4000)
)
PARTITION BY SYSTEM
(
  PARTITION p_hot,
  PARTITION p_warm,
  PARTITION p_cold
);

-- INSERT 시 파티션을 명시적으로 지정
INSERT INTO session_log PARTITION(p_hot)
VALUES (1001, SYSDATE, 'hot path');

INSERT INTO session_log PARTITION(p_cold)
VALUES (1002, ADD_MONTHS(SYSDATE,-6), 'cold path');
```

#### 2.3.3 운영 포인트
- 파티션 선택 실수는 곧 데이터 재배치 비용.
- 따라서 **애플리케이션 라우팅 로직에 대한 검증/감사 체계**가 같이 들어가야 한다.
- “DB가 자동으로 나눠줘야 한다”면 System은 부적합.

---

### 2.4 Virtual Column-based Partitioning — 가상 컬럼을 키로 쓰기

#### 2.4.1 배경
11g에서 Virtual Column이 도입되면서,
아래 같은 모델링 요구를 깔끔히 풀 수 있게 됐다.

- 원본 키에 의미가 내포됨(예: 지점 코드/국가 코드/상품군 prefix)
- 물리 컬럼을 늘리지 않고도 파티션 키를 만들고 싶음
- 파티션 키를 “계산식”으로 정의하고 싶음

11g에서 **가상 컬럼을 파티션 키로 사용 가능**해졌다. 

#### 2.4.2 예제
```sql
DROP TABLE accounts PURGE;
CREATE TABLE accounts (
  account_id   VARCHAR2(10) NOT NULL,
  opened_on    DATE         NOT NULL,
  amount       NUMBER,
  branch_code  GENERATED ALWAYS AS (SUBSTR(account_id,1,3)) VIRTUAL
)
PARTITION BY LIST (branch_code)
(
  PARTITION p_001 VALUES ('001'),
  PARTITION p_002 VALUES ('002'),
  PARTITION p_def VALUES (DEFAULT)
);
```

#### 2.4.3 실무 포인트
- **원본 컬럼은 그대로 두고 “분해한 의미”로 파티션**할 수 있어 모델이 단정해진다.
- 가상 컬럼 식이 비싸면 DML 비용이 올라갈 수 있으니,
  식은 가능한 **단순/결정적(deterministic)** 이어야 한다.

---

### 2.5 11gR2에서의 “복합 조합” 대확장

11gR2는 **Composite 조합의 폭을 사실상 완성한 버전**이다.

- 상위 Range/List/Hash × 하위 Range/List/Hash의 대부분 조합을 지원.
- 특히 **Hash-Hash(11.2 신규)** 가 추가되며 “완전 해시 분산” 설계가 가능해졌다. 

```sql
-- Hash-Hash Composite (11gR2)
DROP TABLE meter_event PURGE;
CREATE TABLE meter_event (
  id        NUMBER,
  device_id NUMBER,
  event_ts  DATE,
  payload   VARCHAR2(100)
)
PARTITION BY HASH (device_id)
PARTITIONS 8
SUBPARTITION BY HASH (id)
SUBPARTITIONS 4
ENABLE ROW MOVEMENT;
```

**언제 쓰나?**
- 상위 해시로 “큰 그룹 분산”, 하위 해시로 “그룹 내부 추가 분산”이 필요할 때.
- 키 분포가 심하게 스큐(skew) 될 가능성이 있는 대형 로그/이벤트 계열.

---

## 3) 11g 이후 버전에서 추가·확장된 유형/전략

### 3.1 12cR1: Interval Reference Partitioning(확장)

12c에서 **Interval 부모 + Reference 자식** 조합이 자연스럽게 운영되도록 확장됐다.  
즉, 부모의 Interval이 자동으로 늘어나면 자식 Reference도 동일하게 자동 생성/정렬된다.  
(이 항목은 12c 파티셔닝 가이드의 Interval/Reference 동시 지원 흐름에 근거한 실무적 결론이다.) 

---

### 3.2 12cR2(12.2): Auto-List / Multi-Column List / Partitioned External Tables

#### 3.2.1 Auto-List Partitioning
List 파티션의 고질적인 운영 문제는 “**새 값이 들어올 때 DDL이 필요**”하다는 점이었다.  
12.2에서 **LIST … AUTOMATIC**이 도입되어 새로운 값이 등장하면 **해당 값 파티션이 자동 생성**된다. 

```sql
-- Auto-List (12.2)
DROP TABLE events PURGE;
CREATE TABLE events (
  sensor_type VARCHAR2(50),
  channel     VARCHAR2(50),
  created_at  DATE
)
PARTITION BY LIST (sensor_type) AUTOMATIC;

INSERT INTO events VALUES ('LIDAR','A1',SYSDATE); -- LIDAR 파티션 자동 생성
```

**주의**
- Auto-List는 **DEFAULT 파티션이 있으면 자동 전환/자동 생성이 제한**될 수 있다.  
  운영 전 DEFAULT 정책을 명확히 해야 한다. 

#### 3.2.2 Multi-Column List
12.2부터 List 파티션 키를 **다중 컬럼**으로 지정 가능해졌다.  
예: `(country_code, channel)` 같은 “조합 값” 단위 분할.

```sql
DROP TABLE evt_mc PURGE;
CREATE TABLE evt_mc (
  country_code VARCHAR2(3),
  channel      VARCHAR2(10),
  evt_dt       DATE,
  payload      VARCHAR2(100)
)
PARTITION BY LIST (country_code, channel)
(
  PARTITION p_us_a VALUES (('USA','A')),
  PARTITION p_us_b VALUES (('USA','B')),
  PARTITION p_eu_a VALUES (('GBR','A')),
  PARTITION p_def  VALUES (DEFAULT)
);
```

**쓰는 이유**
- 단일 코드로는 파티션 수가 너무 커질 때,
- “조합으로 묶여야 프루닝이 자연스럽게 된다”는 요구가 있을 때.

#### 3.2.3 Partitioned External Tables
12.2에서 **External Table 자체에 파티션을 붙일 수 있게** 되면서,
파일/오브젝트 스토리지 쪽의 대형 데이터도 **파티션 단위로 프루닝/관리**할 수 있게 됐다. 

```sql
-- 개념 예시: 외부 파일을 Range 파티션으로 논리 분할
CREATE TABLE ext_sales (
  sales_dt DATE,
  amount   NUMBER
)
ORGANIZATION EXTERNAL
( TYPE ORACLE_LOADER DEFAULT DIRECTORY ext_dir
  ACCESS PARAMETERS (FIELDS TERMINATED BY ',')
  LOCATION ('sales_2024_01.csv')
)
PARTITION BY RANGE (sales_dt)
(
  PARTITION p202401 VALUES LESS THAN (DATE '2024-02-01')
);
```

---

### 3.3 19c: Hybrid Partitioned Tables(HPT)

#### 3.3.1 개념
한 테이블에서
- **Hot/Active 데이터는 Internal 파티션(오라클 세그먼트)**  
- **Cold/Archive 데이터는 External 파티션(파일/오브젝트/HDFS 등)**  
로 **혼합 저장**하는 전략이다. 19c에서 공식 지원. 

#### 3.3.2 핵심 문법(내부+외부 혼합)
```sql
-- 외부 파일 위치 디렉터리
CREATE OR REPLACE DIRECTORY ext_dir AS '/u01/data/ext';

DROP TABLE cust_orders_hpt PURGE;
CREATE TABLE cust_orders_hpt (
  country_code  VARCHAR2(3),
  order_id      NUMBER,
  order_date    DATE,
  amount        NUMBER
)
PARTITION BY LIST (country_code)
(
  -- 내부 파티션
  PARTITION p_usa VALUES ('USA'),

  -- 외부 파티션
  PARTITION p_gbr VALUES ('GBR')
    EXTERNAL PARTITION ATTRIBUTES
      (TYPE ORACLE_LOADER DEFAULT DIRECTORY ext_dir
       ACCESS PARAMETERS (FIELDS TERMINATED BY ','))
    LOCATION ('gbr_orders_2023.csv')
);
```

#### 3.3.3 장점/제약
- **장점**
  - “비싼 내부 스토리지”에는 핫 데이터만,  
    “저렴한 외부 스토리지”에 콜드 데이터를 두는 **티어링**을 DB 레벨에서 해결.
  - 동일 SQL로 내부/외부를 **투명하게 조회**하면서 프루닝이 동작.
- **제약**
  - 외부 파티션은 **제약 강제/일부 인덱스 기능에 제한**이 있고,  
  - 외부 파일 포맷/권한/디렉터리 관리가 운영 리스크가 된다. 

#### 3.3.4 실무 운영 흐름(가장 흔한 패턴)
1) Interval/Auto-List로 내부 파티션을 자연스럽게 늘림  
2) “기간이 지난 내부 파티션”을 **EXCHANGE로 외부 파티션에 이관**  
3) 콜드 파티션은 파일/오브젝트로 관리하며 비용 절감

---

## 4) 버전 타임라인 한 장 요약

| 버전 | 추가/확장 포인트 |
|---|---|
| **11g / 11gR2** | **Interval**, **Reference**, **System**, **Virtual Column-based**. 복합 확대(`range-range`, `list-list`, `list-hash`, `list-range`, …) + **hash-hash(11.2)** + Interval-Composite.  |
| **12cR1** | Interval-Reference 조합 운영 확장(부모 자동 증가를 자식이 상속).  |
| **12cR2(12.2)** | **Auto-List**, **Multi-Column List**, **Partitioned External Tables**.  |
| **19c** | **Hybrid Partitioned Tables**(내부+외부 혼합).  |

---

## 5) 실전 설계 가이드(“유형 선택”을 의사결정으로 바꾸기)

1) **시간축 ILM이 선명하다**  
   → **Interval(상위) + 필요 시 List/Hash 하위**  
2) **부모-자식 정규 모델 유지 + 파티션 일치가 핵심이다**  
   → **Reference Partitioning**  
3) **라우팅 로직이 앱에 있고 데이터 온도/배치가 명확하다**  
   → **System Partitioning**  
4) **키 안에 의미가 내포(prefix, 코드 분해 등)**  
   → **Virtual Column-based Partitioning**  
5) **리스트 값이 계속 늘어난다(운영 DDL 최소화)**  
   → **Auto-List(12.2+)**  
6) **핫/콜드 저장소 혼합 · 비용 최적화가 필요하다**  
   → **HPT(19c+) + EXCHANGE 기반 티어링**  

---

## 6) 종합 실습 시나리오(현장형)

### 6.1 “월별 자동 생성 + 리전 서브파티션 + 자식 상속”

```sql
-- 1) 상위: Interval(월), 하위: 리전 List
DROP TABLE sales_all PURGE;
CREATE TABLE sales_all (
  sales_id    NUMBER PRIMARY KEY,
  sales_date  DATE NOT NULL,
  region      VARCHAR2(10),
  amount      NUMBER
)
PARTITION BY RANGE (sales_date)
INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
SUBPARTITION BY LIST (region) SUBPARTITION TEMPLATE
(
  SUBPARTITION emea  VALUES ('EMEA'),
  SUBPARTITION amer  VALUES ('AMER'),
  SUBPARTITION other VALUES (DEFAULT)
)
(
  PARTITION p0 VALUES LESS THAN (DATE '2023-01-01')
);

-- 2) 자식: Reference
DROP TABLE sales_detail PURGE;
CREATE TABLE sales_detail (
  sales_id    NUMBER NOT NULL,
  line_no     NUMBER NOT NULL,
  product_id  NUMBER,
  qty         NUMBER,
  CONSTRAINT pk_sales_detail PRIMARY KEY (sales_id, line_no),
  CONSTRAINT fk_sd_sa FOREIGN KEY (sales_id) REFERENCES sales_all(sales_id)
)
PARTITION BY REFERENCE (fk_sd_sa);

-- 3) 적재
INSERT INTO sales_all VALUES (1001, DATE '2023-02-03', 'EMEA', 1200);
INSERT INTO sales_detail VALUES (1001, 1, 501, 2);

-- 4) 파티션 확인
SELECT partition_name, subpartition_count
FROM   user_tab_partitions
WHERE  table_name = 'SALES_ALL';
```

**결과적으로**
- 2월 파티션 자동 생성(Interval)  
- 그 파티션 안에 리전 서브파티션 생성(List template)  
- 자식도 동일 파티션 자동 상속(Reference)

---

### 6.2 “Auto-List로 값 확장 → 오래된 국가 파티션을 외부로 티어링(HPT)”

```sql
-- Auto-List (12.2+)
DROP TABLE country_events PURGE;
CREATE TABLE country_events (
  country_code  VARCHAR2(3),
  event_time    DATE,
  payload       VARCHAR2(100)
)
PARTITION BY LIST (country_code) AUTOMATIC;

INSERT INTO country_events VALUES ('USA', SYSDATE, 'hot events');
INSERT INTO country_events VALUES ('GBR', SYSDATE, 'first GBR event'); -- GBR 자동 파티션

-- 19c HPT로 콜드 파티션 외부화(개념)
ALTER TABLE country_events
  ADD PARTITION p_gbr_2023 VALUES ('GBR')
    EXTERNAL PARTITION ATTRIBUTES
      (TYPE ORACLE_LOADER DEFAULT DIRECTORY ext_dir
       ACCESS PARAMETERS (FIELDS TERMINATED BY ','))
    LOCATION ('gbr_events_2023.csv');
```

운영에선 “과거 파티션을 EXCHANGE로 파일로 뽑아낸 뒤 HPT 외부 파티션으로 교체”하는 흐름이 가장 흔하다.

---

## 7) 운영/튜닝 체크리스트

- [ ] **프루닝이 잘 되는 키인가?** (조건이 WHERE에 자연스럽게 들어오는가)  
- [ ] **파티션 수가 과도하지 않은가?**  
  - 지나치게 많으면 **Global Index 관리/통계/DDL 비용**이 커진다.  
- [ ] **Partition-Wise Join이 가능한 모델인가?**  
  - Reference나 동일 파티션 키 정렬 여부 점검  
- [ ] **유지보수 단위가 명확한가?**  
  - EXCHANGE/ DROP/ TRUNCATE 정책이 파티션 단위로 설계됐는가  
- [ ] **Auto(Interval/Auto-List) 전략이면 “전이점, DEFAULT 정책”이 안전한가?**  
- [ ] **HPT를 쓰면 외부 파티션 제약/권한/파일 품질을 주기적으로 검증하는가?**  

---

## 결론

- 11g는 파티셔닝을 **“성능 기능”에서 “운영 자동화 기능”으로 확장**시킨 버전이다.  
  - Interval로 시간축 파티션 운영을 자동화하고,  
  - Reference로 부모-자식 모델의 파티션 일치를 구조적으로 강제하며,  
  - System/Virtual Column으로 라우팅·모델링 자유도를 크게 늘렸다.   
- 12cR2는 **“자동 생성 + 다중 키 + 외부 데이터까지 파티션”**으로 확장했고,   
- 19c는 HPT로 **“하나의 테이블에서 내부/외부 티어링”**을 구현해 파티셔닝이 ILM/비용 최적화의 중심 축이 되었다.   

이 흐름을 이해하면 “어떤 파티션 유형을 쓰는가”가 아니라  
“**우리 데이터의 라이프사이클/조인 패턴/운영 자동화 목표를 어떻게 파티션 설계로 구현할 것인가**”로 문제를 바꿀 수 있다.