---
layout: post
title: DB 심화 - 오라클 파티셔닝
date: 2025-11-24 18:25:23 +0900
category: DB 심화
---
# 오라클 파티셔닝: 11g 신규 유형과 버전별 발전

오라클 파티셔닝은 단순히 테이블을 분할하는 기술이 아닌, 대용량 데이터를 효과적으로 관리하고 운영하는 핵심 인프라입니다. 특히 11g 버전에서는 파티셔닝 기능이 획기적으로 발전하여 운영 부담을 크게 줄이고 자동화를 강화하였습니다. 이 문서에서는 11g에서 새롭게 도입된 파티셔닝 유형들과 이후 버전에서의 확장 기능을 심층적으로 분석합니다.

## 파티셔닝의 필요성과 핵심 가치

파티셔닝을 도입하는 주요 이유는 성능 향상, 유지보수 효율화, 리소스 관리의 세 가지 측면에서 설명할 수 있습니다:

### 성능 최적화
- **파티션 프루닝**: 쿼리 조건에 맞는 파티션만 접근하여 스캔 범위를 축소합니다.
- **파티션-와이즈 조인**: 동일한 파티션 키를 가진 테이블 간의 조인 성능을 극대화합니다.

### 운영 효율성
- **데이터 라이프사이클 관리**: 오래된 데이터를 파티션 단위로 쉽게 아카이빙하거나 삭제할 수 있습니다.
- **파티션 단위 작업**: 인덱스 재구성, 통계 수집, 압축 등을 파티션 단위로 수행할 수 있습니다.

### 리소스 관리
- **IO 분산**: 서로 다른 파티션을 다른 디스크에 저장하여 IO 병목을 완화합니다.
- **동시성 향상**: 다른 파티션에 대한 작업은 서로 블로킹되지 않습니다.

## 11g 이전의 기본 파티셔닝 유형

11g 이전에도 오라클은 세 가지 기본 파티셔닝 방식을 제공했습니다:

1. **Range 파티셔닝**: 날짜나 숫자 범위를 기준으로 분할 (예: 월별, 분기별)
2. **List 파티셔닝**: 명시적인 값 목록을 기준으로 분할 (예: 지역코드, 상태값)
3. **Hash 파티셔닝**: 해시 함수를 적용하여 균등하게 분할

또한 이러한 기본 유형을 조합한 복합 파티셔닝도 지원되었습니다.

## 11g에서 새롭게 도입된 파티셔닝 유형

### Interval 파티셔닝: 자동 확장되는 범위 파티셔닝

#### 도입 배경
기존 Range 파티셔닝은 모든 파티션을 사전에 정의해야 했습니다. 이는 운영 부담을 증가시키고, 새로운 파티션이 필요한 시점을 놓칠 경우 데이터 삽입이 실패하는 문제가 있었습니다.

#### 작동 원리
Interval 파티셔닝은 초기 "전이점(transition point)" 파티션을 Range로 정의한 후, 지정된 간격으로 새로운 파티션을 자동 생성합니다.

```sql
-- 월 단위 Interval 파티셔닝 예제
CREATE TABLE sales (
    sales_id     NUMBER PRIMARY KEY,
    sales_date   DATE   NOT NULL,
    amount       NUMBER
)
PARTITION BY RANGE (sales_date)
INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
    PARTITION p_initial VALUES LESS THAN (DATE '2023-01-01')
);
```

#### 실무 적용 시 고려사항
- 초기 전이점은 실제 운영 시작 시점에 가깝게 설정하는 것이 중요합니다.
- 과거 데이터 대량 적재 시 전이점 이전 파티션에 데이터가 집중될 수 있습니다.
- 자동 생성된 파티션도 수동으로 관리(분할/병합/이동)할 수 있습니다.

### Reference 파티셔닝: 부모-자식 테이블의 파티션 상속

#### 도입 배경
부모-자식 관계의 테이블에서 자식 테이블에도 파티션 키 컬럼을 중복으로 추가해야 했습니다. 이는 데이터 중복을 초래하고 모델의 정규화를 훼손하는 문제가 있었습니다.

#### 작동 원리
외래키 관계를 통해 자식 테이블이 부모 테이블의 파티션 구성을 자동으로 상속받습니다.

```sql
-- 부모 테이블 (월별 파티셔닝)
CREATE TABLE orders (
    order_id     NUMBER PRIMARY KEY,
    order_date   DATE   NOT NULL,
    customer_id  NUMBER NOT NULL
)
PARTITION BY RANGE (order_date)
INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
(
    PARTITION p_initial VALUES LESS THAN (DATE '2023-01-01')
);

-- 자식 테이블 (Reference 파티셔닝)
CREATE TABLE order_items (
    order_id     NUMBER NOT NULL,
    line_no      NUMBER NOT NULL,
    product_id   NUMBER NOT NULL,
    qty          NUMBER,
    CONSTRAINT pk_order_items PRIMARY KEY (order_id, line_no),
    CONSTRAINT fk_oi_orders
        FOREIGN KEY (order_id) REFERENCES orders(order_id)
)
PARTITION BY REFERENCE (fk_oi_orders);
```

#### 장점
- 데이터 모델의 정규화 유지
- 파티션-와이즈 조인 최적화 자동 적용
- 부모 파티션 관리 작업이 자식에게 자동으로 전파

#### 주의사항
- 외래키 제약 조건이 항상 유효한 상태로 유지되어야 합니다.
- 부모 파티션의 DDL 작업이 자식에 미치는 영향을 고려해야 합니다.

### System 파티셔닝: 애플리케이션 주도 파티셔닝

#### 도입 배경
데이터베이스가 아닌 애플리케이션 레벨에서 파티션 라우팅 로직을 가지는 경우, 해당 로직에 맞는 파티션 선택이 필요했습니다.

#### 작동 원리
파티션을 사전에 정의만 해두고, 데이터 삽입 시 애플리케이션이 명시적으로 파티션을 지정합니다.

```sql
CREATE TABLE session_log (
    sid        NUMBER,
    log_time   DATE,
    payload    VARCHAR2(4000)
)
PARTITION BY SYSTEM
(
    PARTITION p_hot,
    PARTITION p_warm,
    PARTITION p_cold
);

-- 파티션 명시적 지정
INSERT INTO session_log PARTITION(p_hot)
VALUES (1001, SYSDATE, '핫 데이터 경로');
```

#### 적용 시나리오
- 핫/웜/콜드 데이터의 명확한 분리 저장
- 특정 스토리지 클래스에의 강제 배치
- 샤딩 아키텍처와의 통합

### 가상 컬럼 기반 파티셔닝

#### 도입 배경
원본 컬럼 값을 변형하거나 조합하여 파티션 키로 사용하고 싶은 경우가 많았습니다.

#### 작동 원리
가상 컬럼(Virtual Column)을 파티션 키로 사용합니다.

```sql
CREATE TABLE accounts (
    account_id   VARCHAR2(10) NOT NULL,
    opened_on    DATE         NOT NULL,
    amount       NUMBER,
    branch_code  GENERATED ALWAYS AS (SUBSTR(account_id, 1, 3)) VIRTUAL
)
PARTITION BY LIST (branch_code)
(
    PARTITION p_001 VALUES ('001'),
    PARTITION p_002 VALUES ('002'),
    PARTITION p_def VALUES (DEFAULT)
);
```

#### 장점
- 물리적 컬럼 추가 없이 파티션 키 생성 가능
- 데이터 모델의 간결성 유지
- 복잡한 파티션 키 로직 구현 가능

## 11gR2의 복합 파티셔닝 확장

11gR2에서는 다양한 복합 파티셔닝 조합이 지원되기 시작했습니다. 특히 Hash-Hash 복합 파티셔닝이 도입되어 다중 수준의 해시 분산이 가능해졌습니다.

```sql
-- Hash-Hash 복합 파티셔닝
CREATE TABLE meter_event (
    id        NUMBER,
    device_id NUMBER,
    event_ts  DATE,
    payload   VARCHAR2(100)
)
PARTITION BY HASH (device_id)
PARTITIONS 8
SUBPARTITION BY HASH (id)
SUBPARTITIONS 4;
```

이러한 확장으로 인해 더욱 정교한 데이터 분산 전략을 수립할 수 있게 되었습니다.

## 12c 이후 버전의 파티셔닝 발전

### 12cR2(12.2)의 주요 개선사항

#### Auto-List 파티셔닝
새로운 값이 삽입될 때 해당 값을 가진 파티션이 자동으로 생성됩니다.

```sql
CREATE TABLE events (
    sensor_type VARCHAR2(50),
    channel     VARCHAR2(50),
    created_at  DATE
)
PARTITION BY LIST (sensor_type) AUTOMATIC;
```

#### 다중 컬럼 List 파티셔닝
여러 컬럼의 조합을 기준으로 파티셔닝이 가능해졌습니다.

```sql
CREATE TABLE evt_mc (
    country_code VARCHAR2(3),
    channel      VARCHAR2(10),
    evt_dt       DATE,
    payload      VARCHAR2(100)
)
PARTITION BY LIST (country_code, channel)
(
    PARTITION p_us_a VALUES (('USA', 'A')),
    PARTITION p_us_b VALUES (('USA', 'B')),
    PARTITION p_eu_a VALUES (('GBR', 'A'))
);
```

#### 파티션된 외부 테이블
외부 테이블에도 파티셔닝을 적용할 수 있게 되었습니다.

### 19c: Hybrid Partitioned Tables(HPT)

#### 개념
하나의 테이블에서 활성 데이터는 내부 파티션으로, 아카이브 데이터는 외부 파티션으로 혼합 저장하는 방식입니다.

```sql
CREATE TABLE cust_orders_hpt (
    country_code  VARCHAR2(3),
    order_id      NUMBER,
    order_date    DATE,
    amount        NUMBER
)
PARTITION BY LIST (country_code)
(
    -- 내부 파티션 (활성 데이터)
    PARTITION p_usa VALUES ('USA'),
    
    -- 외부 파티션 (아카이브 데이터)
    PARTITION p_gbr VALUES ('GBR')
        EXTERNAL PARTITION ATTRIBUTES
            (TYPE ORACLE_LOADER DEFAULT DIRECTORY ext_dir
             ACCESS PARAMETERS (FIELDS TERMINATED BY ','))
        LOCATION ('gbr_orders_2023.csv')
);
```

#### 운영 시나리오
1. 활성 데이터는 내부 파티션으로 고성능 처리
2. 일정 기간이 지난 데이터는 외부 파일로 이동
3. 외부 파티션은 저렴한 스토리지에 저장하여 비용 최적화

## 실전 파티셔닝 설계 가이드

### 파티셔닝 전략 선택 기준

1. **시간 기반 데이터 관리가 주된 요구사항일 때**
   - Interval 파티셔닝 + 필요시 하위 파티셔닝
   - 예: 월별 Interval + 지역별 List 서브파티션

2. **부모-자식 테이블 간의 파티션 정렬이 중요한 경우**
   - Reference 파티셔닝
   - 예: 주문(Orders)과 주문상품(Order_Items) 테이블

3. **애플리케이션에서 명시적인 파티션 라우팅이 필요한 경우**
   - System 파티셔닝
   - 예: 핫/웜/콜드 데이터 스토리지 분리

4. **파티션 키가 원본 데이터에서 유도되어야 하는 경우**
   - 가상 컬럼 기반 파티셔닝
   - 예: 계좌번호에서 지점코드 추출

5. **파티션 값이 동적으로 증가하는 경우**
   - Auto-List 파티셔닝 (12.2+)
   - 예: 새로 등록되는 센서 타입별 파티션

6. **스토리지 비용 최적화가 필요한 경우**
   - Hybrid Partitioned Tables (19c+)
   - 예: 최신 데이터는 SSD, 오래된 데이터는 객체 스토리지

### 종합 실습 예제: 월별 자동 생성 + 지역 서브파티션 + 자식 상속

```sql
-- 1. 상위: 월별 Interval, 하위: 지역별 List
CREATE TABLE sales_all (
    sales_id    NUMBER PRIMARY KEY,
    sales_date  DATE NOT NULL,
    region      VARCHAR2(10),
    amount      NUMBER
)
PARTITION BY RANGE (sales_date)
INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'))
SUBPARTITION BY LIST (region) SUBPARTITION TEMPLATE
(
    SUBPARTITION sp_emea  VALUES ('EMEA'),
    SUBPARTITION sp_amer  VALUES ('AMER'),
    SUBPARTITION sp_other VALUES (DEFAULT)
)
(
    PARTITION p_initial VALUES LESS THAN (DATE '2023-01-01')
);

-- 2. 자식: Reference 파티셔닝
CREATE TABLE sales_detail (
    sales_id    NUMBER NOT NULL,
    line_no     NUMBER NOT NULL,
    product_id  NUMBER,
    qty         NUMBER,
    CONSTRAINT pk_sales_detail PRIMARY KEY (sales_id, line_no),
    CONSTRAINT fk_sd_sa FOREIGN KEY (sales_id) 
        REFERENCES sales_all(sales_id)
)
PARTITION BY REFERENCE (fk_sd_sa);
```

이 설계의 장점:
- 월별 파티션이 자동으로 생성됨 (Interval)
- 각 월별 파티션 내에 지역별 서브파티션이 생성됨 (List Template)
- 자식 테이블이 부모의 파티션 구성을 자동 상속함 (Reference)
- 파티션-와이즈 조인이 최적화됨

## 파티셔닝 운영 모범 사례

### 모니터링과 관리

```sql
-- 파티션 정보 조회
SELECT table_name, partition_name, high_value, num_rows
FROM user_tab_partitions
WHERE table_name = 'SALES_ALL'
ORDER BY partition_position;

-- 파티션 통계 확인
SELECT partition_name, blocks, empty_blocks, num_rows
FROM user_tab_statistics
WHERE table_name = 'SALES_ALL';

-- 파티션 단위 인덱스 상태 확인
SELECT index_name, partition_name, status
FROM user_ind_partitions
WHERE index_name = 'IDX_SALES_DATE';
```

### 파티션 유지보수 작업

```sql
-- 파티션 추가 (Interval이 아닌 경우)
ALTER TABLE sales ADD PARTITION p202401 
    VALUES LESS THAN (DATE '2024-02-01');

-- 파티션 병합
ALTER TABLE sales MERGE PARTITIONS p202301, p202302 
    INTO PARTITION p2023_q1;

-- 파티션 분할
ALTER TABLE sales SPLIT PARTITION p2023_q1 
    AT (DATE '2023-02-01')
    INTO (PARTITION p202301, PARTITION p202302);

-- 파티션 이동 (다른 테이블스페이스로)
ALTER TABLE sales MOVE PARTITION p202301 
    TABLESPACE ts_archive;
```

### 성능 모니터링

```sql
-- 파티션 프루닝 확인
EXPLAIN PLAN FOR
SELECT * FROM sales_all 
WHERE sales_date >= DATE '2023-02-01'
  AND sales_date < DATE '2023-03-01'
  AND region = 'EMEA';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 파티션 접근 통계
SELECT partition_name, physical_reads, logical_reads
FROM v$segment_statistics
WHERE owner = USER
  AND object_name = 'SALES_ALL'
  AND object_type = 'TABLE PARTITION';
```

## 결론

오라클 파티셔닝은 11g 버전에서 획기적인 발전을 이루었으며, 이후 버전에서도 지속적으로 기능이 확장되고 있습니다. 효과적인 파티셔닝 설계를 위해서는 다음 원칙을 기억하세요:

### 핵심 설계 원칙

1. **비즈니스 요구사항에 기반한 설계**: 데이터 접근 패턴, 보관 정책, 성능 요구사항을 고려하여 파티셔닝 전략을 수립하세요.

2. **자동화 활용**: Interval, Auto-List 등 자동 파티셔닝 기능을 적극 활용하여 운영 부담을 줄이세요.

3. **계층적 접근**: 복합 파티셔닝을 통해 다중 수준의 데이터 분할 전략을 구현하세요.

4. **성능과 관리의 균형**: 파티션 수가 지나치게 많아지지 않도록 설계하고, 파티션 단위 작업이 효율적으로 수행될 수 있도록 구성하세요.

5. **모니터링과 최적화**: 파티션 프루닝 효율성, 파티션-와이즈 조인 활용도, 파티션 단위 통계 품질을 정기적으로 점검하세요.

### 버전별 전략 선택 가이드

- **11g 이상**: Interval 파티셔닝으로 시간 기반 데이터 관리 자동화
- **부모-자식 관계**: Reference 파티셔닝으로 모델 정규화 유지
- **동적 값 증가**: Auto-List 파티셔닝으로 운영 단순화
- **비용 최적화**: Hybrid Partitioned Tables로 스토리지 티어링 구현

파티셔닝은 단순한 기술 선택이 아니라 데이터 아키텍처의 핵심 구성 요소입니다. 시스템의 규모가 커질수록 올바른 파티셔닝 전략의 중요성은 더욱 커집니다. 본 문서에서 소개한 원리와 패턴을 바탕으로 조직의 데이터 특성에 맞는 최적의 파티셔닝 전략을 수립하시기 바랍니다.