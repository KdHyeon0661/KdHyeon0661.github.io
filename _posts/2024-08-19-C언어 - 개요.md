---
layout: post
title: C - 개요
date: 2024-08-19 19:20:23 +0900
category: C
---
# C 언어 소개 및 개발 환경 설정

## 0) 왜 지금 C인가?

- **시스템 프로그래밍의 표준**: 운영체제/드라이버/런타임/임베디드 펌웨어의 토대.
- **하드웨어 친화적 제어**: 비트/바이트 레벨 접근, 메모리 레이아웃 가시성.
- **성능과 이식성의 절충**: 적절한 추상화 + 얕은 오버헤드.
- **후속 언어의 기원**: C++/Objective-C/Java/C#/Rust(상호운용)/Python(확장 모듈) 등에 영향.

---

## 1) C 언어란?

- 1972년 벨 연구소 **Dennis M. Ritchie**가 UNIX 개발 과정에서 설계.
- **절차지향 · 정적 타입 · 컴파일 언어**.
- **표준화**: C89/90 → C99 → C11 → C17(기술정정) → C23(최신 기능 추가).
- **메모리 모델**에 대한 직접 제어(포인터, 수동 메모리 관리) + **UB(Undefined Behavior)** 개념 중요.

> 핵심 관점: C는 “안전 장치가 적은 파워툴”. **자유**와 **책임**이 함께 옵니다.

---

## 2) C의 특징 (정리)

| 특징 | 설명 | 실무 메모 |
|---|---|---|
| 절차지향 | 함수(프로시저) 중심 흐름 | 모듈화·헤더 분리·링킹 구조로 대형 프로젝트 구성 |
| 컴파일 | `.c` → 오브젝트 → 링킹 → 실행파일 | 최적화 레벨(`-O0..-O3`, LTO), 디버그 심볼(`-g`) |
| 저수준 접근 | 포인터, 비트 연산, 메모리 직접 제어 | 성능·임베디드 필수, UB·메모리 오류 위험 동반 |
| 이식성 | 표준 라이브러리 + 컴파일러 의존성 | `#ifdef`와 빌드 스크립트로 플랫폼 구분 |
| 속도 | 얇은 추상화 → 예측 가능한 비용 | 벡터화, 캐시 친화 레이아웃, 구조체 패킹 고려 |

---

## 3) 표준/컴파일러/툴체인 간단 지도

### 3.1 표준 버전 한눈에

- **C89/C90**: 가장 오래된 광범위 호환.
- **C99**: 가변 길이 배열(VLA), `//` 주석, `inline`, `stdint.h`.
- **C11**: 원자성/스레딩(`stdatomic.h`, `threads.h`), `static_assert`.
- **C17**: 결함 정정판(본질적 변화 적음).
- **C23**: `typeof` 표준화, `nullptr` 키워드, 속성 등 다수 품목.

> 실전 권장: **C11(이상)** 또는 **C23** 기능을 점진적으로 사용. `-std=c11` / `-std=c23`.

### 3.2 컴파일러

- **GCC**: 리눅스/윈도우(MinGW-w64)/맥에서 광범위 사용.
- **Clang/LLVM**: 빠른 빌드, 친절한 진단 메시지, 분석기/도구 생태계 풍부.
- **MSVC**: Windows 네이티브, 최신 표준 지원 지속 향상.

---

## 4) 개발 환경 구성

### 4.1 Windows

#### (A) MSYS2 + MinGW-w64 (권장)

1) **MSYS2** 설치 → `MSYS2 MSYS` 터미널 실행  
2) 업데이트:
```bash
pacman -Syu
# 터미널 재시작 후
pacman -Syu
```
3) 툴체인 설치:
```bash
pacman -S --needed mingw-w64-ucrt-x86_64-toolchain
```
4) **VS Code** + C/C++ 확장 설치 → `ucrt64` 터미널에서 사용  
5) 확인:
```bash
gcc --version
clang --version
```

#### (B) Visual Studio/Build Tools + MSVC

- Visual Studio Installer에서 **C++ 데스크톱 개발** 워크로드 추가.  
- 터미널: **x64 Native Tools Command Prompt** → `cl`, `link` 사용.

### 4.2 Linux (Debian/Ubuntu 예시)

```bash
sudo apt update
sudo apt install build-essential gdb clang lldb cmake ninja-build
gcc --version
clang --version
```

### 4.3 macOS

- Xcode Command Line Tools:
```bash
xcode-select --install
clang --version
```
- CMake/Ninja(Homebrew):
```bash
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
brew install cmake ninja
```

---

## 5) 첫 프로그램: Hello, World!

```c
#include <stdio.h>

int main(void) {
    printf("Hello, World!\n");
    return 0;
}
```

### GCC/Clang 빌드 & 실행

```bash
gcc hello.c -o hello          # 또는 clang hello.c -o hello
./hello
```

### MSVC (Windows)

```bat
cl /W4 /EHsc hello.c
hello.exe
```

---

## 6) C 프로그램 구조 미세 해부

```c
#include <stdio.h>   // 표준 입출력 선언

int main(void) {     // 프로그램 진입점, 서명은 관례적으로 int main(void)
    // 실행 코드
    return 0;        // 0 = 정상 종료
}
```

- **헤더**(`.h`): 선언(함수 원형, 구조체/열거형/상수) 제공.
- **소스**(`.c`): 정의(함수 본문) 포함 → 개별 컴파일 → 링크 단계에서 결합.
- **링커**: 외부 심볼 해결(라이브러리 결합).

---

## 7) 빌드 시스템 빠른 정착(CMake)

### 7.1 프로젝트 구조

```
c-intro/
├─ CMakeLists.txt
└─ src/
   └─ main.c
```

### 7.2 CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.20)
project(c_intro C)

set(CMAKE_C_STANDARD 11)            # C11
set(CMAKE_C_STANDARD_REQUIRED ON)
set(CMAKE_C_EXTENSIONS OFF)         # -std=c11

add_executable(c_intro src/main.c)

# 컴파일 옵션 (GCC/Clang일 때)
if (CMAKE_C_COMPILER_ID MATCHES "GNU|Clang")
  target_compile_options(c_intro PRIVATE -Wall -Wextra -Wpedantic -O2)
endif()

# MSVC일 때
if (MSVC)
  target_compile_options(c_intro PRIVATE /W4)
endif()
```

### 7.3 빌드

```bash
cmake -S . -B build -G Ninja
cmake --build build
./build/c_intro
```

---

## 8) 변수·자료형·리터럴·상수

### 8.1 기본 자료형

| 범주 | 예 | 비고 |
|---|---|---|
| 정수형 | `char` `short` `int` `long` `long long` | 부호/무부호(`signed`/`unsigned`) |
| 실수형 | `float` `double` `long double` | 부동소수점 |
| 기타 | `_Bool`(C99) | 논리(0/1) |

> 크기는 **플랫폼·ABI** 의존. 고정폭은 `stdint.h`의 `int32_t`, `uint64_t`, `intptr_t` 사용 권장.

### 8.2 선언/초기화 예제

```c
#include <stdint.h>

int main(void) {
    int a = 42;
    unsigned b = 300u;
    int32_t x = -10;
    uint64_t mask = 0xffULL;
    float pi = 3.1415926f;
    double e = 2.718281828;
    _Bool ok = 1; // <stdbool.h> 없이도 가능 (0/1)
    return ok ? 0 : 1;
}
```

### 8.3 상수/매크로/열거형

```c
#include <stdio.h>

#define BUF_SIZE 1024             // 전처리 상수
const int MAX_USER = 100;         // const 변수

enum ErrorCode {                  // 열거형 상수
    ERR_OK = 0,
    ERR_IO = 1,
    ERR_INVALID = 2
};

int main(void) {
    printf("%d %d %d\n", BUF_SIZE, MAX_USER, ERR_INVALID);
    return 0;
}
```

---

## 9) 연산자·표현식·우선순위

- 카테고리: 산술, 대입, 비교, 논리, 비트, 포인터, 삼항, 쉼표.  
- **정수 승격(Integer Promotion)**, **Usual Arithmetic Conversions** 숙지 필요.

간단 예:
```c
#include <stdio.h>
int main(void) {
    unsigned int u = 1;
    int i = -1;
    // 주의: 혼합 연산 시 부호 변환 → 예기치 않은 결과 가능
    printf("%u\n", u + i); // 구현에 따라 큰 값이 될 수 있음
    return 0;
}
```

> 정교한 산술의 정의는 표준에 따르며, 부호 있는 overflow는 **UB**.

**수식 예(우선순위 설명용):**

$$
a + b \times c \quad\text{에서 곱셈이 덧셈보다 먼저 결합}
$$

---

## 10) 제어문

```c
if (cond) { ... } else { ... }
for (init; cond; step) { ... }
while (cond) { ... }
do { ... } while (cond);
switch (expr) {
  case 1: ...; break;
  default: ...;
}
```

실전 예 — 입력 검증 루프:
```c
#include <stdio.h>

int main(void) {
    int n = 0;
    while (1) {
        printf("Enter 1..10: ");
        if (scanf("%d", &n) != 1) {
            int ch;
            while ((ch = getchar()) != '\n' && ch != EOF) {} // flush
            puts("Invalid input"); 
            continue;
        }
        if (n < 1 || n > 10) {
            puts("Out of range");
            continue;
        }
        break;
    }
    printf("OK: %d\n", n);
    return 0;
}
```

---

## 11) 함수·링크·헤더 분리

### 11.1 헤더/소스 분리

```
math/
├─ add.h
└─ add.c
```

`add.h`
```c
#ifndef ADD_H
#define ADD_H
int add(int a, int b);
#endif
```

`add.c`
```c
#include "add.h"
int add(int a, int b) { return a + b; }
```

`main.c`
```c
#include <stdio.h>
#include "add.h"

int main(void) {
    printf("%d\n", add(2, 3));
    return 0;
}
```

빌드:
```bash
gcc -c math/add.c -o add.o
gcc -c main.c -o main.o
gcc add.o main.o -o app
```

### 11.2 내부/외부 연결

- `static` 함수/변수: **파일 내부 연결**.
- 비정적 전역: **외부 연결** → 다른 번역단위에서 참조 가능.
- `extern` 선언으로 외부 심볼 사용.

---

## 12) 배열·포인터·문자열 (핵심 난제 정리)

### 12.1 배열 기본

```c
int a[4] = {1,2,3,4};
int *p = a;              // a는 대부분의 표현식에서 int*로 decay
printf("%d\n", p[2]);    // 3
```

### 12.2 포인터 산술·주의점

```c
int v[] = {10,20,30};
int *q = v;        // q -> v[0]
q++;               // q -> v[1]
printf("%d\n", *q); // 20
// 유효 범위 밖 포인터 연산은 UB
```

### 12.3 C 문자열

- **널 종료('\0')** 규약.
- `#include <string.h>`: `strlen`, `strcpy`, `strncpy`, `strcat`, `memcmp`, `memcpy`, …

예:
```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char buf[8] = "Hi";
    strncat(buf, "!!!", sizeof(buf)-strlen(buf)-1); // 안전 결합
    printf("%s (%zu)\n", buf, strlen(buf));
    return 0;
}
```

---

## 13) 구조체·공용체·열거형·비트필드

```c
#include <stdio.h>
#include <stdint.h>

typedef struct {
    uint16_t year;
    uint8_t  month, day;
} Date;

typedef union {
    float f;
    uint32_t u;
} FloatBits;

typedef enum { RED, GREEN, BLUE } Color;

struct Flags {
    unsigned ready:1;
    unsigned error:1;
    unsigned reserved:6;
};

int main(void) {
    Date d = {2025, 11, 10};
    FloatBits fb = {.f = 1.0f};
    struct Flags fl = { .ready=1, .error=0 };
    printf("%u-%02u-%02u, bits=%u\n", d.year, d.month, d.day, fb.u);
    return 0;
}
```

> **비트필드**의 메모리 배치·엔디언·폭은 구현 정의. **직렬화/네트워크** 용도로는 **명시적 마스킹/시프트** 권장.

---

## 14) 동적 메모리·소유권

- `malloc/calloc/realloc/free` (`<stdlib.h>`)
- **소유권** 규율: 할당자=해제자, 복사/이동 시 책임 명확화.
- 널체크, 크기 추적, 해제 후 포인터 무효화(`p=NULL`).

```c
#include <stdio.h>
#include <stdlib.h>

int* make_array(size_t n) {
    int *p = malloc(n * sizeof *p);
    if (!p) { return NULL; }
    for (size_t i = 0; i < n; ++i) p[i] = (int)i;
    return p;
}

int main(void) {
    size_t n = 5;
    int *arr = make_array(n);
    if (!arr) return 1;
    for (size_t i = 0; i < n; ++i) printf("%d ", arr[i]);
    puts("");
    free(arr); arr = NULL;
    return 0;
}
```

---

## 15) 파일 I/O (텍스트·바이너리)

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    FILE *fp = fopen("data.txt", "w");
    if (!fp) return 1;
    fprintf(fp, "answer=%d\n", 42);
    fclose(fp);

    fp = fopen("data.txt", "r");
    if (!fp) return 1;
    int ans = 0;
    if (fscanf(fp, "answer=%d", &ans) == 1) {
        printf("Read: %d\n", ans);
    }
    fclose(fp);
    return 0;
}
```

바이너리:
```c
#include <stdio.h>
#include <stdint.h>

int main(void) {
    uint32_t buf[3] = {1,2,3};
    FILE *fp = fopen("out.bin", "wb");
    fwrite(buf, sizeof(buf[0]), 3, fp);
    fclose(fp);

    uint32_t in[3] = {0};
    fp = fopen("out.bin", "rb");
    fread(in, sizeof(in[0]), 3, fp);
    fclose(fp);

    printf("%u %u %u\n", in[0], in[1], in[2]);
    return 0;
}
```

---

## 16) 전처리기(Preprocessor)

- `#include`, `#define`, 조건부 컴파일(`#if/#ifdef/#ifndef/#elif/#endif`)
- **주의**: 매크로는 단순 치환 → 괄호/부작용 고려.

```c
#define SQR(x) ((x)*(x))
```

플랫폼 분기:
```c
#ifdef _WIN32
  #define PATH_SEP '\\'
#else
  #define PATH_SEP '/'
#endif
```

---

## 17) 모듈·라이브러리 구성(작은 샘플)

### 17.1 인터페이스 설계

`vector.h`
```c
#ifndef VECTOR_H
#define VECTOR_H
#include <stddef.h>

typedef struct {
    size_t size, cap;
    int   *data;
} Vector;

int  vec_init(Vector *v);
void vec_free(Vector *v);
int  vec_push(Vector *v, int value);
int  vec_get(const Vector *v, size_t i, int *out);
size_t vec_size(const Vector *v);

#endif
```

`vector.c`
```c
#include "vector.h"
#include <stdlib.h>
#include <string.h>

int vec_init(Vector *v) {
    v->size = 0; v->cap = 4;
    v->data = malloc(v->cap * sizeof *v->data);
    return v->data ? 0 : -1;
}
void vec_free(Vector *v) {
    free(v->data); v->data = NULL; v->size = v->cap = 0;
}
static int vec_reserve(Vector *v, size_t newcap) {
    if (newcap <= v->cap) return 0;
    int *p = realloc(v->data, newcap * sizeof *p);
    if (!p) return -1;
    v->data = p; v->cap = newcap; return 0;
}
int vec_push(Vector *v, int value) {
    if (v->size == v->cap && vec_reserve(v, v->cap * 2)) return -1;
    v->data[v->size++] = value; return 0;
}
int vec_get(const Vector *v, size_t i, int *out) {
    if (i >= v->size) return -1;
    *out = v->data[i]; return 0;
}
size_t vec_size(const Vector *v) { return v->size; }
```

`main.c`
```c
#include <stdio.h>
#include "vector.h"

int main(void) {
    Vector v;
    if (vec_init(&v)) return 1;
    for (int i = 0; i < 10; ++i) vec_push(&v, i*i);
    for (size_t i = 0; i < vec_size(&v); ++i) {
        int x; vec_get(&v, i, &x);
        printf("%d ", x);
    }
    puts("");
    vec_free(&v);
    return 0;
}
```

---

## 18) 디버깅·분석·테스트

### 18.1 gdb/lldb 기본

디버그 빌드:
```bash
gcc -g -O0 main.c -o app
gdb ./app
# run, bt, frame, print x, next(n), step(s), continue(c), break main
```

### 18.2 Address/UB/Thread Sanitizer (GCC/Clang)

```bash
clang -g -fsanitize=address,undefined -fno-omit-frame-pointer main.c -o app_asan
./app_asan
```

### 18.3 정적 분석

- `clang-tidy`, `cppcheck` 등:
```bash
clang-tidy main.c -- -std=c11
```

### 18.4 단위 테스트 예(소형 프레임워크 없이)

`test.c`
```c
#include <stdio.h>
#include <assert.h>
int add(int a, int b) { return a + b; }
int main(void) {
    assert(add(2,3) == 5);
    puts("OK");
    return 0;
}
```

---

## 19) 문자열·버퍼 안전 패턴

- 입력은 항상 **길이 제한**.
- 포맷 지정자 유의(`%s` vs `%[^\n]` vs `fgets`).

```c
#include <stdio.h>

int main(void) {
    char line[64];
    if (fgets(line, sizeof line, stdin)) {
        printf("Got: %s", line);
    }
    return 0;
}
```

---

## 20) 컴파일·링크 고급 옵션

- 경고 엄격화: `-Wall -Wextra -Wpedantic` (GCC/Clang), `/W4` (MSVC)
- 표준: `-std=c11` / `-std=c23`
- 최적화: `-O2` (균형), `-O3`(공격적), `-Os`(사이즈), `-Og`(디버그 친화)
- LTO: `-flto` (링크 시 최적화)
- 링커: `-Wl,option` 전달

---

## 21) 크로스 플랫폼 포터빌리티 체크리스트

- **정수 폭**: `int`/`long` 크기 가정 금지 → `stdint.h`.
- **엔디언**: 직렬화/네트워크 시 바이트 순서 명시.
- **파일 경로 구분자**: `\\` vs `/`.
- **소켓/스레드**: POSIX vs Win32 API → 추상화 계층, 조건부 컴파일.
- **타이밍/수면**: `sleep` vs `Sleep`, `clock_gettime` 등.

---

## 22) 흔한 버그·UB(Undefined Behavior) 모음

- **배열 경계 초과** 접근
- **해제 후 사용(UAF)**, **중복 해제**
- **정수 오버플로**(부호 있는 정수의 overflow는 UB)
- **미초기화 읽기**
- **널 포인터 역참조**
- **`memcpy` 오버랩** (겹치면 `memmove` 사용)
- **`printf` 포맷 불일치**
- **엄격 별칭(Strict Aliasing) 위반**: 서로 다른 타입 포인터로 같은 메모리 접근

---

## 23) 미니 프로젝트: 로그 파서(텍스트 → 통계)

### 요구
- 로그 파일(`access.log`)에서 **상태코드**별 건수를 집계하여 출력.
- 라인은 `"TIMESTAMP METHOD PATH STATUS BYTES"` 형태로 가정.

`log.h`
```c
#ifndef LOG_H
#define LOG_H
#include <stddef.h>

typedef struct {
    unsigned count_2xx;
    unsigned count_3xx;
    unsigned count_4xx;
    unsigned count_5xx;
} Stats;

int update_stats_line(Stats *st, const char *line);
void print_stats(const Stats *st);

#endif
```

`log.c`
```c
#include "log.h"
#include <stdio.h>
#include <stdlib.h>

static int classify(int status) {
    if (status >= 200 && status < 300) return 2;
    if (status >= 300 && status < 400) return 3;
    if (status >= 400 && status < 500) return 4;
    if (status >= 500 && status < 600) return 5;
    return 0;
}

int update_stats_line(Stats *st, const char *line) {
    // TIMESTAMP METHOD PATH STATUS BYTES
    char ts[64], method[16], path[256];
    int status = 0; long bytes = 0;
    if (sscanf(line, "%63s %15s %255s %d %ld", ts, method, path, &status, &bytes) != 5)
        return -1;
    switch (classify(status)) {
        case 2: st->count_2xx++; break;
        case 3: st->count_3xx++; break;
        case 4: st->count_4xx++; break;
        case 5: st->count_5xx++; break;
        default: break;
    }
    return 0;
}

void print_stats(const Stats *st) {
    printf("2xx=%u 3xx=%u 4xx=%u 5xx=%u\n",
           st->count_2xx, st->count_3xx, st->count_4xx, st->count_5xx);
}
```

`main.c`
```c
#include <stdio.h>
#include <string.h>
#include "log.h"

int main(int argc, char **argv) {
    const char *file = (argc > 1) ? argv[1] : "access.log";
    FILE *fp = fopen(file, "r");
    if (!fp) { perror("fopen"); return 1; }

    Stats st = {0};
    char line[1024];
    while (fgets(line, sizeof line, fp)) {
        update_stats_line(&st, line);
    }
    fclose(fp);
    print_stats(&st);
    return 0;
}
```

빌드:
```bash
gcc -std=c11 -Wall -Wextra -O2 main.c log.c -o logstat
./logstat access.log
```

---

## 24) 성능 팁(초급→중급 브리지)

- **데이터 지역성**: 구조체 정렬/패딩 고려, SoA/ AoS 변환.
- **분기 예측**: 뜨거운 경로/차가운 경로 분리, 조기 탈출.
- **I/O 배치**: 버퍼링(`setvbuf`, 큰 `fread/fwrite`).
- **빌드 최적화**: `-O2` 기본, 프로파일링 기반 최적화(PGO) 검토.
- **수학 연산 근사**: 필요 시 `-ffast-math`(정확도·규약 영향 주의).

---

## 25) 멀티스레딩(C11 Threading 개요)

```c
#include <stdio.h>
#include <threads.h>

int worker(void *arg) {
    puts("hello from thread");
    return 0;
}

int main(void) {
    thrd_t t;
    if (thrd_create(&t, worker, NULL) == thrd_success) {
        thrd_join(t, NULL);
    }
    return 0;
}
```

- 원자 연산: `<stdatomic.h>` (`atomic_int`, `atomic_load`, `atomic_store` 등)
- 메모리 질서: `memory_order_relaxed/acquire/release/seq_cst`

---

## 26) 안전한 스타일·코드 규약

- **경고=에러**: `-Werror`(팀 합의 후)
- **초깃값 명시**: 모든 변수 초기화
- **짧은 함수·명확한 소유권**: 해제 책임 문서화
- **헤더 가드·단일 책임**: 한 헤더=한 모듈 인터페이스
- **테스트·예외 경로 커버**: 실패 흐름 유닛 테스트

---

## 27) 학습 로드맵(이 글 이후)

1. **기초 문법**: 변수/형/연산자/제어문/함수  
2. **메모리/포인터**: 배열/문자열/구조체/동적 메모리  
3. **모듈화**: 헤더/링킹/라이브러리  
4. **I/O·파일 처리**  
5. **빌드·디버깅·분석기**  
6. **멀티스레딩/원자성**  
7. **네트워크/시스템 호출**(POSIX/Win32)  
8. **임베디드/마이크로컨트롤러**(레지스터 매핑, 링커 스크립트)  
9. **성능/프로파일링**(perf, VTune, Instruments)  
10. **표준 심화(C23 변화점)**

---

## 28) 요약

- C는 **속도·제어·이식성**의 삼박자를 갖춘 언어.
- 이 글에서는 **개발 환경 → 빌드 시스템 → 언어 핵심 → 안전/성능/테스트 → 미니 프로젝트**까지 **빈틈 없이 확장**했다.
- 다음 편에서는 **변수/자료형/연산자**를 더 깊게 파고들며, **정수 승격·부동소수 정밀도·UB 사례**를 코드와 함께 분해한다.
