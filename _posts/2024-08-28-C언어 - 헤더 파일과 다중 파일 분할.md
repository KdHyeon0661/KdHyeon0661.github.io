---
layout: post
title: C - 헤더 파일과 다중 파일 분할
date: 2024-08-28 19:20:23 +0900
category: C
---
# 헤더 파일과 다중 파일 분할

## 핵심만 10줄 요약

```c
// 헤더(.h)는 "선언/타입/매크로", 소스(.c)는 "정의/구현"
#ifndef MOD_H
#define MOD_H

int add(int, int);           // 선언
#endif

// 소스(.c) — 정확히 한 TU(translation unit)에서만 "정의"
#include "mod.h"

int add(int a,int b){ return a+b; }

// 빌드: gcc -c mod.c; gcc -c main.c; gcc mod.o main.o -o app
```

---

## vs 정의(Definition)

- **선언**: “존재/형태만 알림”. 컴파일러가 **타입·시그니처**를 알게 함. (메모리 X)
- **정의**: “실체 제공”. 링커가 **기호(symbol)와 본체**를 묶음. (메모리 O)

### 함수

```c
// mod.h (선언만)
int add(int a, int b);

// mod.c (정의)
int add(int a, int b) { return a + b; }
```

### 전역 변수 (`extern`)

```c
// cfg.h
#ifndef CFG_H
#define CFG_H

extern int g_verbose;   // 선언(여러 TU에서 볼 수 있음)
#endif

// cfg.c
#include "cfg.h"

int g_verbose = 0;      // 정의(단 하나만!)
```

> **같은 심볼을 여러 .c에서 정의**하면 링크 오류(중복 정의)가 납니다.

---

## 내부 링크와 외부 링크 — `static`

- **외부 링크(external linkage)**: 다른 TU에서도 보이는 기호(기본 함수/전역).
- **내부 링크(internal linkage)**: **이 .c 안에서만 보임** → `static` 사용.

```c
// file.c
static int s_counter;          // 이 파일 내부에서만 보임
static void tick(void){ s_counter++; } // 내부 헬퍼
```

> 라이브러리/모듈 내부 구현은 **가능하면 static**으로 감춰 ABI 노출 최소화.

---

## 헤더 가드 vs `#pragma once`

### Include Guard(전통/이식성 최고)

```c
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int add(int a,int b);
int multiply(int a,int b);
#endif

```

- 네이밍 관례: **PROJECT_PATH_NAME_H** (충돌 방지).

### `#pragma once`

```c
#pragma once

int add(int, int);
```

- 간결. 대부분 컴파일러 지원. **아주 오래된 컴파일러**만 예외.

---

## — 반드시 지킬 것

1) **자기완결성(Self-contained)**: 헤더를 **단독**으로 포함해도 컴파일 가능해야 함.
2) **최소 포함(Minimal include)**: 필요한 것만 `#include`. 불필요한 전이 의존 줄이기.
3) **전방 선언(Forward declaration)**: 포인터로만 참조할 타입은 전방 선언으로 대체.

```c
// good.h
#ifndef GOOD_H
#define GOOD_H

struct Foo;                // 전방 선언
void use_foo(struct Foo*); // 포인터만 쓰면 정의 불필요
#endif

```

> 구조체 **크기나 멤버**에 접근해야 한다면 **정의가 필요**(전방 선언 불가).

---

## — 공개 API 설계

**public 헤더는 타입의 내부를 감추고 포인터만 노출**:

```c
// api.h  (공개)
#ifndef API_H
#define API_H
#include <stddef.h>

typedef struct db_conn db_conn;             // 내부 미공개
db_conn* db_open(const char* uri);
void     db_close(db_conn*);
int      db_exec(db_conn*, const char* sql);
#endif

// api.c  (구현)
#include "api.h"
#include <stdlib.h>

struct db_conn { int fd; char *cache; /* 내부 디테일 */ };
db_conn* db_open(const char* uri){ /* ... */ }
void     db_close(db_conn* c){ /* ... */ }
```

장점: **ABI 안정**, 내부 교체 쉬움, 의존성/빌드 시간 단축.

---

## 예제 프로젝트 1 — 기본 분리와 빌드

```
project/
├─ include/
│  └─ math_utils.h
├─ src/
│  ├─ math_utils.c
│  └─ main.c
└─ Makefile
```

**include/math_utils.h**
```c
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int add(int a,int b);
int multiply(int a,int b);
#endif

```

**src/math_utils.c**
```c
#include "math_utils.h"

int add(int a,int b){ return a+b; }
int multiply(int a,int b){ return a*b; }
```

**src/main.c**
```c
#include <stdio.h>
#include "math_utils.h"

int main(void){
    printf("%d\n", add(3,4));
    printf("%d\n", multiply(3,4));
    return 0;
}
```

**Makefile(패턴 규칙)**
```make
CC      := gcc
CFLAGS  := -std=c11 -O2 -Wall -Wextra -Iinclude
LDFLAGS :=
SRC     := $(wildcard src/*.c)
OBJ     := $(SRC:src/%.c=build/%.o)
BIN     := build/app

$(BIN): $(OBJ)
	$(CC) $(OBJ) -o $@ $(LDFLAGS)

build/%.o: src/%.c | build
	$(CC) $(CFLAGS) -c $< -o $@

build:
	mkdir -p build

clean:
	rm -rf build
```

빌드:
```bash
make
./build/app
```

---

## 깨부수기

문제 예:
```
A.h → B.h 포함, B.h → A.h 포함  → 재귀 포함/불완전 타입 접근
```

해결:
- 헤더에서 **전방 선언**을 쓰고, **정의는 .c**에서 포함.
- “헤더가 헤더를 많이 포함하는 설계”를 지양, **인터페이스 최소화**.

```c
// a.h
#ifndef A_H
#define A_H

struct B;               // 전방 선언
typedef struct { struct B* b; } A;
void a_use(A*);
#endif

// b.h
#ifndef B_H
#define B_H

struct A;               // 전방 선언
typedef struct { struct A* a; } B;
void b_use(B*);
#endif

// a.c
#include "a.h"
#include "b.h" // 여기서 정의 필요 시 포함

void a_use(A* a){ /* ... */ }
```

---

## `inline` 함수와 헤더-온리 유틸

- **작고 빈번한 함수**는 `inline`로 헤더에 넣어 오버헤드를 줄임.
- C99의 `inline` 규칙(링키지) 유의: 보통 **헤더에는 `static inline`** 권장.

```c
// mathx.h
#ifndef MATHX_H
#define MATHX_H

static inline int clamp(int x,int lo,int hi){
    return x<lo?lo : x>hi?hi : x;
}
#endif

```

> `static inline`은 TU마다 내부 링크로 정의되어 **중복 정의 없이** 안전.

---

## 전역 상태 설계 — `extern` vs Getter

- 간단: `extern` 전역 → 접근 쉬우나 **결합↑/테스트↓**.
- 개선: **Getter/Setter** 함수로 캡슐화.
- 모듈 내부 상태는 `static` 전역으로 감추고 API 제공.

```c
// log.h
#ifndef LOG_H
#define LOG_H

void log_set_level(int lv);
int  log_get_level(void);
void log_printf(int lv,const char* fmt,...);
#endif

// log.c
static int s_level = 0;
void log_set_level(int lv){ s_level=lv; }
int  log_get_level(void){ return s_level; }
```

---

## 컴파일/링크 — GCC/Clang/MSVC

### GCC/Clang

```bash
# 개별 컴파일

gcc -std=c11 -Wall -Wextra -Iinclude -c src/math_utils.c -o build/math_utils.o
gcc -std=c11 -Wall -Wextra -Iinclude -c src/main.c -o build/main.o
# 링크

gcc build/math_utils.o build/main.o -o build/app
```

### MSVC (Developer Command Prompt)

```bat
cl /std:c11 /W4 /I include src\math_utils.c src\main.c /Fe:app.exe
```

> 경고 레벨: GCC/Clang `-Wall -Wextra -Wpedantic`, MSVC `/W4`.

---

## 외부 라이브러리 포함 — `<…>` vs `"…"`와 검색 경로

```c
#include <stdio.h>      // 시스템 헤더(컴파일러의 표준 경로)
#include "myheader.h"   // 프로젝트/로컬 우선

```

- 빌드 시 `-I include/` 로 사용자 헤더 검색 경로 추가.
- 패키지: `pkg-config --cflags --libs sdl2` 등으로 플래그 주입.

```bash
gcc main.c -o app $(pkg-config --cflags --libs sdl2)
```

---

## vs 동적(.so/.dll)

### 정적 라이브러리

```bash
ar rcs build/libmathx.a build/math_utils.o
gcc build/main.o build/libmathx.a -o build/app
```
- 장점: 배포 간편, 실행 시 의존도 낮음.
- 단점: 바이너리 크기↑, 재빌드 필요.

### 동적 라이브러리(리눅스)

```bash
gcc -fPIC -shared src/math_utils.c -o build/libmathx.so
gcc src/main.c -Lbuild -lmathx -o build/app
LD_LIBRARY_PATH=build ./build/app
```
- 장점: 공유/업데이트 용이, 메모리 공유.
- 단점: 배포/로더 경로 관리 필요.

---

## — 대형 프로젝트 빌드 가속

- GCC/Clang: `-Winvalid-pch` / `.gch`.
- MSVC: `/Yc"pch.h"`(생성), `/Yu"pch.h"`(사용).
- **변동 적은 무거운 헤더**를 PCH에 넣고, 나머지는 가볍게.

---

## 헤더 테스트와 의존 그래프

- **단독 포함 컴파일 테스트**:
```bash
gcc -std=c11 -Wall -Wextra -Iinclude -c include/math_utils.h -o /dev/null
```
- **의존 시각화**: `gcc -H` 또는 `clang -M` 계열로 포함 트리 확인.

---

## 예제 프로젝트 2 — 모듈 3개와 순환 회피, 단위 테스트

```
proj2/
├─ include/
│  ├─ user.h
│  ├─ store.h
│  └─ test.h
├─ src/
│  ├─ user.c
│  ├─ store.c
│  └─ test.c
└─ Makefile
```

**include/user.h**
```c
#ifndef USER_H
#define USER_H
#include <stddef.h>

typedef struct user user;
user* user_new(const char* name, int age);
void  user_free(user*);
const char* user_name(const user*);
int   user_age(const user*);
#endif

```

**include/store.h**
```c
#ifndef STORE_H
#define STORE_H
#include <stddef.h>

struct user;                       // 전방 선언(포인터만 보유)
typedef struct store store;
store* store_new(void);
void   store_free(store*);
int    store_add(store*, struct user*);  // user.h 완전 정의 불필요
size_t store_count(const store*);
#endif

```

**src/user.c**
```c
#include "user.h"
#include <stdlib.h>
#include <string.h>

struct user { char *name; int age; };
user* user_new(const char* n,int age){
    user* u = malloc(sizeof *u);
    if(!u) return NULL;
    u->name = n? strdup(n): NULL;
    u->age  = age;
    return u;
}
void user_free(user* u){
    if(!u) return;
    free(u->name);
    free(u);
}
const char* user_name(const user* u){ return u?u->name:NULL; }
int user_age(const user* u){ return u?u->age:0; }
```

**src/store.c**
```c
#include "store.h"
#include "user.h"     // 여기서만 user의 실제 정의 필요
#include <stdlib.h>

typedef struct { struct user** a; size_t len, cap; } arr;
struct store { arr v; };
static int grow(arr* z,size_t need){
    if(need<=z->cap) return 0;
    size_t ncap = z->cap? z->cap*2: 8;
    while(ncap<need) ncap*=2;
    struct user** tmp = realloc(z->a, ncap*sizeof *tmp);
    if(!tmp) return -1;
    z->a=tmp; z->cap=ncap; return 0;
}
store* store_new(void){ return calloc(1,sizeof(struct store)); }
void   store_free(store* s){ if(!s) return; free(s->v.a); free(s); }
int    store_add(store* s, struct user* u){
    if(!s||!u) return -1;
    if(grow(&s->v, s->v.len+1)) return -1;
    s->v.a[s->v.len++] = u; return 0;
}
size_t store_count(const store* s){ return s? s->v.len:0; }
```

**src/test.c**
```c
#include <stdio.h>
#include "user.h"
#include "store.h"

int main(void){
    store* s = store_new();
    user* a = user_new("Alice",30);
    user* b = user_new("Bob",25);
    store_add(s,a);
    store_add(s,b);
    printf("%zu users: %s, %s\n",
           store_count(s), user_name(a), user_name(b));
    // 소유권 정책: 여기선 user는 외부가 free
    user_free(a); user_free(b); store_free(s);
    return 0;
}
```

빌드:
```bash
gcc -std=c11 -Wall -Wextra -Iinclude -c src/user.c -o build/user.o
gcc -std=c11 -Wall -Wextra -Iinclude -c src/store.c -o build/store.o
gcc -std=c11 -Wall -Wextra -Iinclude -c src/test.c -o build/test.o
gcc build/*.o -o build/test
./build/test
```

---

## 테스트 가능한 API와 링크 에러 예방 체크리스트

- [ ] **선언/정의 불일치**(함수 시그니처, `const` 누락) 방지.
- [ ] 전역 변수는 **정확히 1 TU**에서만 정의(`extern`는 헤더).
- [ ] **헤더는 구현 포함 X**(필요하면 `static inline`).
- [ ] **순환 의존**은 전방 선언 + .c에서만 실제 정의 포함.
- [ ] **경고 모두 켜기**: CI에서 `-Werror`로 격파.
- [ ] **유닛 테스트**: 모듈 경계마다 독립 검증 가능하도록 API 설계.

---

## 자주 겪는 빌드/링크 문제와 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| `undefined reference to foo` | 선언만 있고 정의가 없음 | 해당 .c를 **링크**했는지 확인 |
| `multiple definition of bar` | 동일 전역을 여러 .c에서 정의 | 한 곳만 정의, 나머지는 `extern` |
| `redefinition of struct` | 동일 타입을 중복 정의 | 하나의 헤더만 진실, 나머지는 포함 제거 |
| 순환 include로 컴파일 폭주 | A.h ↔ B.h 서로 포함 | 전방 선언 + .c에서만 정의 포함 |
| inline 함수 중복 기호 | 헤더에 `inline`만 사용 | `static inline`로 내부 링크화 |

---

## 헤더 파일 포함 순서(권장 패턴)

1) **해당 파일의 자신 헤더**(구현-헤더 불일치 조기 발견)
2) C 표준 헤더 `<…>`
3) 제3자 외부 라이브러리 헤더
4) 프로젝트 내부 다른 헤더

```c
#include "module.h"
#include <stdio.h>
#include <string.h>
#include "thirdparty_x.h"
#include "utils.h"

```

---

## 수식으로 보는 빌드 시간/의존 최소화 감각

헤더 하나가 **평균 포함 횟수**를 $$k$$, 크기를 $$S$$라 하면
전처리/파싱 비용은 대략 $$O(k \cdot S)$$.
**전방 선언**과 **미니멀 include**로 $$S$$를 줄이면 전체 빌드 시간이 선형으로 감소.

---

## 마무리 정리

| 주제 | 핵심 요약 |
|---|---|
| 선언 vs 정의 | 헤더=선언/타입, 소스=정의/구현. 전역 변수는 **한 곳**에서만 정의 |
| 링크 | 외부/내부 링크 구분(`static`). ODR은 C++개념이지만 **중복 정의**는 C에서도 금지 |
| 가드 | include guard가 표준, `#pragma once`도 실무에서 흔함 |
| 전방 선언 | 포인터 매개엔 충분. 크기/멤버 접근엔 정의 필요 |
| Opaque 포인터 | 공개 API에서 내부 은닉, ABI 안정 |
| inline | 헤더에는 **`static inline`** 권장 |
| 순환 의존 | 전방 선언 + .c로 이동, 헤더 최소 포함 |
| 빌드 | 개별 컴파일(`-c`)→링크, Makefile 패턴 규칙로 확장 |
| 라이브러리 | 정적(.a) vs 동적(.so/.dll) 장단 비교 |
| 위생 | 자기완결 헤더, 최소 포함, 경고 최대, 단위 테스트 |
