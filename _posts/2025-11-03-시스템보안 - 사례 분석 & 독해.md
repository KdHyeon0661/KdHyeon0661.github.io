---
layout: post
title: 시스템보안 - 사례 분석 & 독해
date: 2025-11-03 17:30:23 +0900
category: 시스템보안
---
# 사례 분석 & 독해(사고 보고서/블로그 리딩)

## 전체 로드맵

1) **문헌 수집**: 사고 보고서, 벤더 블로그, 패치 노트, CVE 기록(변경 이력 포함).
2) **표준화 읽기**: (a) **초기접근→실행→권한상승→영속화→측면이동→목표**로 요약, (b) **ATT&CK 매핑**.
3) **정형화 산출물**: **타임라인 표**, **IOC 목록**, **TTP 체크리스트**, **공격 그래프**(자산/자격/경로), **방어 갭 분석**.
4) **랩 복기**: **무해 로그 시뮬레이터**로 동일 신호를 발생 → **탐지 쿼리** 회귀 테스트.
5) **개선안 우선순위화**: 예방/탐지/대응을 **측정 가능 KPI**로 도출.

---

## 유명 CVE 타임라인 재구성(초기 접근→권한 상승→영속화)

> 사례 A·B·C는 **역사적으로 널리 알려진 공격군**이며, 본문은 **공격 목적의 세부 절차**가 아닌 **“독해·재구성 틀”**을 제공합니다.

### 사례 A: Log4Shell 계열(원격 입력 → JNDI 문자열 처리 → 원치 않는 로딩)

**초기 접근(Initial Access)**
- 웹 요청의 헤더/파라미터/경로에 **특정 패턴 문자열** 삽입 → 서버 로그에 입력 반사.
- 지표: 웹 액세스 로그에 `${jndi:` 같은 **시그널 토큰**.

**실행/로딩(Execution/Defense Evasion)**
- 과거 취약 버전에서 원격 참조를 시도(현 문서는 **무해 시뮬레이션**만 수행).
- 지표: 특이한 DNS 질의(무해 도메인), 애플리케이션 예외 스택 트레이스.

**권한 상승/영속화**
- (공격 서술 생략) — 방어 관점에서 **이상 프로세스/스레드**, **신규 파일 드롭**, **탐지 로그**를 추적.

**타임라인 복원(예시 쿼리; KQL/Elastic 스타일)**
```kusto
// 1) 웹 요청에서 의심 토큰 빈도
WebServerLogs
| where TimeGenerated between (ago(24h) .. now())
| where UrlOriginal has_any ("${jndi:", "${${lower:", "${env:")
   or HttpRequestHeader has "${jndi:"
| summarize cnt = count() by ClientIP, bin(TimeGenerated, 10m)
| order by cnt desc

// 2) 동일 창구에서 앱 예외/에러 상관
let suspicious = toscalar(WebServerLogs
  | where UrlOriginal has "${jndi:"
  | summarize makeset(ClientIP));
AppLogs
| where ClientIP in (suspicious)
| where Level in ("Error","Fatal") or Message has_any ("JNDI","lookup","classloader")
| project TimeGenerated, Logger, Message, ClientIP
```

**IOC 예시(형식)**
- **문자열 토큰**: `"${jndi:"`, `"${${lower:"`
- **로그 패턴**: `ClassCastException`, `JndiLookup` 관련 스택 토막
- **도메인**: (무해 도메인/랩 싱크) `sim-lab.local`

**ATT&CK 매핑(예시)**
- T1190 Exploit Public-Facing Application (검증용 시뮬)
- T1056 Input Capture (로그 반사 관찰 수준)
- T1041 Exfiltration Over C2 Channel (미실행, 로그 신호로 대체)

---

### 사례 B: ProxyLogon/ProxyShell 계열(메일 서버 전단 취약점 연계 체인)

**초기 접근**
- **전단 프록시/프론트엔드** 입력 경로를 악용(세부 생략) → 백엔드로 비정상 요청 유도.
- 지표: 서버 역할 교환(프론트→백엔드) 구간의 **특이 경로/헤더**.

**권한 상승**
- (세부 생략) — 보안 로그 기준으로 **프로세스 생성(4688)**, **이상 Parent/Child 관계**.

**영속화**
- 타스크 스케줄/가상 디렉터리/웹셸 유사 파일(이 문서에서는 **유사명 무해 파일**) 생성.

**타임라인 복원(예시)**
```kusto
let tspan = 48h;
let hosts = dynamic(["MAIL-FE-01","MAIL-BE-01"]);

// 1) 프론트엔드에서 백엔드로 향하는 내부 호출 급증
ReverseProxy
| where host in (hosts) and TimeGenerated > ago(tspan)
| summarize cnt = count() by backendRoute, bin(TimeGenerated, 5m)
| where cnt > 200
| order by cnt desc

// 2) 이어지는 서버 측 프로세스 생성(비정형 부모/자식)
SecurityEvent
| where EventID == 4688 and Computer in (hosts)
| extend Image = tostring(TargetFileName), Parent = tostring(ParentProcessName)
| where Image endswith "w3wp.exe" or Parent has "w3wp" // 웹 워커 관련
| order by TimeGenerated asc
```

**IOC**
- **파일명**: `aspnet_client`, `.aspx` 유사 이름이나 **무해 테스트 파일**
- **HTTP 로그**: 내부 프록시 경로 특정 패턴

**ATT&CK 매핑(요지)**
- T1190, T1059(스케줄러/스크립트 실행), T1053(스케줄링) 등(감지 신호만 활용)

---

### 사례 C: EternalBlue 계열(SMB 취약 경로 → 내부 확산)

**초기 접근**
- 외부 노출 SMB, 혹은 내부 피봇 지점에서 SMB 트래픽 특이치.
- 지표: 짧은 시간 내 **445/TCP** 스캔 급증, SMB 네고시에이션 에러 패턴.

**권한 상승/내부 이동**
- (세부 생략) — **새 서비스 설치(7045)**, **프로세스 스폰(4688)** 등 측정.

**타임라인 복원(예시; Splunk)**
```spl
(index=netflow dest_port=445) OR (index=win System EventCode=7045)
| bin _time span=5m
| stats count by _time, src_ip, dest_ip, dest_port EventCode Image
| sort _time
```

**IOC**
- **네트워크**: 445/TCP 고빈도 연결, 특정 TTL/창 크기(고전적 특징) — 최신 환경에선 **행동 기반 상관** 권장.
- **시스템**: 서비스 생성, 드라이버 로드 이벤트.

---

## 벤더 패치 노트에서 힌트 뽑기, PoC 재현(격리 환경)

> 목적: **패치 노트/커밋 메시지/변경 이력**을 읽어 **취약 유형·영향 범위 힌트**를 도출하고,
> **실제 악성 동작 없이**도 **탐지 신호**를 만드는 무해 PoC(로그 시뮬) 설계.

### 패치 노트 독해 체크리스트

- **요약 키워드**: *Bounds check*, *Use-after-free*, *Double free*, *Integer overflow*, *Race condition*, *Improper neutralization* 등
- **영향 범위**: **버전/플랫폼/기본 설정**(on/off), **권한**(로컬/원격), **공격 전제**(인증 필요/불요).
- **완화책**: 구성 변경, 위험 기능 비활성화, 임시 정책(파일/레지스트리/Flag).
- **로그 가능 지점**: 실패 로그/에러 코드/쿼런틴 메시지/콜스택 키워드.

**예: Diff 메시지 해석 — “Add length check before copy”**
- 힌트: **버퍼/길이 검증 누락** → 대량 입력/경계값에서 예외/에러 발생 패턴 확인.
- PoC 방향: **경계값 인접 길이**의 **무해 요청**으로 **에러 코드**와 **로그 문자열**만 유도.

### “힌트→무해 PoC” 변환 절차

1) **입력 채널** 파악(HTTP 헤더/파라미터, 파일 포맷, 환경변수, 프로토콜 필드).
2) **경계값** 설정(n-1, n, n+1) 크기의 **Benign Payload** 생성.
3) **관찰 지표**:
   - 서버 에러 코드(4xx/5xx),
   - 애플리케이션 예외 메시지(스택 키워드),
   - OS 이벤트(프로세스 크래시 X; 크래시 유발 금지).
4) **로그 컬렉터**로 수집 → **시그널 규칙** 작성(Sigma/KQL).

**무해 PoC 스켈레톤(HTTP, Python)**
```python
import requests, string, random

def benign_boundary_payload(n: int) -> str:
    # 제어 문자/특수 페이로드 금지, 안전한 알파벳만
    return "A" * n

def try_lengths(url: str, header: str, base: int = 1024):
    for n in [base-1, base, base+1, base*2]:
        v = benign_boundary_payload(n)
        r = requests.get(url, headers={header: v}, timeout=5)
        print(n, r.status_code, len(r.text))

if __name__ == "__main__":
    try_lengths("https://lab-app.local/ping", "X-Demo")
```

> 위 코드는 **경계값 로그만 유도**(정상/경고/에러)하며, **취약점 유발 동작**을 하지 않습니다.

### 로그 시그널 규칙(예시: 애플리케이션 경계값 에러)

**Sigma**
```yaml
title: Boundary Error Spike (Benign PoC)
id: cve-reading-boundary-sim
status: test
logsource:
  product: application
  service: web
detection:
  sel:
    level: error
    message|contains:
      - "length exceeded"
      - "boundary check"
  timeframe: 5m
  condition: sel | count() by host > 10
level: low
tags: [simulation, detection-quality]
```

---

## 실습: “한 건 완전 복기” — IOC/공격 그래프/방어 개선안 도출

> 주제: **Log4Shell 계열 블로그/보고서를 읽었다**고 가정하고, **실제 익스플로잇 없이** **완전 복기 절차**를 수행합니다.
> 입력: (1) 웹 로그, (2) 앱 로그, (3) Sysmon 프로세스/파일, (4) DNS 로그(옵션).
> 출력: **정규화 타임라인**, **IOC 리스트**, **공격 그래프**, **개선안 로드맵**.

### 데이터 모델

```text
Event {
  ts, host, src_ip, dst_ip, user, kind(process|file|web|dns|app),
  action, object(path|url|name), details, rule, severity
}
```

### 시뮬 로그 생성기(무해)

```python
# gen_log4shell_sim.py — JSONL 로그(무해 시그널용)

import json, time, datetime as dt, random

def jnow(): return dt.datetime.utcnow().isoformat()+"Z"

def web_req(ip, path, header):
    return {"ts": jnow(), "host":"WEB-01", "src_ip":ip, "dst_ip":"10.0.0.10",
            "kind":"web", "action":"GET", "object":path,
            "details":{"UA":"curl/8.0","X-Demo":header}}

def app_log(level, msg):
    return {"ts": jnow(), "host":"WEB-01", "kind":"app", "action":"log",
            "details":{"level":level, "msg":msg}}

def sysmon_file(p):
    return {"ts": jnow(), "host":"WEB-01", "kind":"file", "action":"create",
            "object":p, "details":{"proc":"java.exe"}}

ips = ["203.0.113.5","198.51.100.23"]
evts = []
evts.append(web_req(ips[0], "/search", "${jndi:sim-lab}"))
time.sleep(0.1)
evts.append(app_log("warn","Received pattern ${jndi:...} - benign sink"))
time.sleep(0.1)
evts.append(sysmon_file("C:\\App\\logs\\jndi_marker.log"))
time.sleep(0.1)
evts.append(web_req(ips[1], "/info", "normal"))
evts.append(app_log("error","boundary check failed (benign test)"))

with open("sim.jsonl","w",encoding="utf8") as f:
    for e in evts: f.write(json.dumps(e)+"\n")
print("Wrote sim.jsonl")
```

### 타임라인 재구성 파이프라인(파서 + 그룹)

```python
# timeline.py — JSONL → 타임라인 표

import json, itertools
from datetime import datetime

def parse(line):
    e = json.loads(line)
    e["ts"] = datetime.fromisoformat(e["ts"].replace("Z","+00:00"))
    return e

def load(fp):
    with open(fp,"r",encoding="utf8") as f:
        return [parse(l) for l in f if l.strip()]

def group_by_minute(evts):
    evts.sort(key=lambda e:e["ts"])
    buckets = {}
    for e in evts:
        k = e["ts"].replace(second=0, microsecond=0)
        buckets.setdefault(k, []).append(e)
    return buckets

if __name__ == "__main__":
    evts = load("sim.jsonl")
    buckets = group_by_minute(evts)
    for k, g in buckets.items():
        print("---", k.isoformat(), "UTC ---")
        for e in g:
            print(f"{e['ts'].isoformat()} {e['kind']:>5} {e.get('src_ip','-'):>15} {e.get('action',''):>6} {e.get('object','-')} {e.get('details',{})}")
```

**출력(예)**

```
--- 2025-11-01T12:34:00+00:00 UTC ---
2025-11-01T12:34:10+00:00   web    203.0.113.5   GET /search {'UA': 'curl/8.0', 'X-Demo': '${jndi:sim-lab}'}
2025-11-01T12:34:10+00:00   app                log - {'level': 'warn', 'msg': 'Received pattern ${jndi:...} - benign sink'}
2025-11-01T12:34:10+00:00  file                create C:\App\logs\jndi_marker.log {'proc': 'java.exe'}
2025-11-01T12:34:11+00:00   web   198.51.100.23   GET /info {'UA': 'curl/8.0', 'X-Demo': 'normal'}
2025-11-01T12:34:11+00:00   app                log - {'level': 'error', 'msg': 'boundary check failed (benign test)'}
```

> 이 타임라인으로 **(1) 의심 토큰 유입 → (2) 앱 경고 → (3) 파일 기록** 순서를 확인.

### 생성(무해 관계 그래프)

```python
# graph.py — 네트워크x 기반 공격 그래프(무해)

import json, networkx as nx

G = nx.DiGraph()
for line in open("sim.jsonl","r",encoding="utf8"):
    e = json.loads(line)
    host = e.get("host","?")
    kind = e.get("kind","evt")
    if kind == "web":
        ip = e.get("src_ip")
        G.add_node(ip, type="client")
        G.add_node(host, type="server")
        G.add_edge(ip, host, label="web->")
        if "${jndi:" in e.get("details",{}).get("X-Demo",""):
            G.add_edge(ip, host, label="pattern:${jndi}")
    elif kind == "file":
        p = e.get("object")
        G.add_node(p, type="file")
        G.add_edge(host, p, label="create")

# 간단 경로 요약

for u, v, d in G.edges(data=True):
    print(u, "->", v, d.get("label",""))

# (시각화는 별도; .dot로 내보내 그래프 도구에서 열기)

nx.drawing.nx_pydot.write_dot(G, "sim.dot")
print("Wrote sim.dot")
```

**의미**
- **노드**: 외부 IP(클라이언트), 서버, 파일(로그/마커).
- **엣지**: 요청 → 서버, 서버 → 파일 생성.
- **라벨**: `${jndi}` 패턴/생성 이벤트 등.

### IOC/시그널 표준화

| 종류 | 항목 | 비고 |
|---|---|---|
| 문자열 | `${jndi:` | 단어 분절 우회(`$ { j n d i :`) 변형 고려 |
| 파일 | `C:\App\logs\jndi_marker.log` | **랩 전용 마커 파일** |
| IP | `203.0.113.5`, `198.51.100.23` | **TEST-NET** 주소 범위 |
| 로그 | `boundary check failed` | 패치노트 힌트 기반 경계값 알람 |

### 탐지 쿼리/규칙(회귀 테스트용)

**KQL — 연속 신호 상관(1분 창)**

```kusto
let win = 1m;
let jndi_web = WebServerLogs
  | where UrlOriginal has "${jndi:" or HttpRequestHeader has "${jndi:"
  | project TimeGenerated, ClientIP, host=Computer;
let app_warn = AppLogs
  | where Level in ("Warn","Warning") and Message has "jndi"
  | project TimeGenerated, host=Computer, msg=Message;
let file_mark = Sysmon
  | where EventID == 11 and TargetFilename endswith "jndi_marker.log"
  | project TimeGenerated, Computer, TargetFilename;

jndi_web
| join kind=inner (app_warn) on host
| where app_warn_TimeGenerated between (TimeGenerated .. TimeGenerated + win)
| join kind=inner (file_mark) on $left.host == $right.Computer
| where file_mark_TimeGenerated between (TimeGenerated .. TimeGenerated + win)
| project TimeGenerated, host, ClientIP, msg, TargetFilename
```

**Sigma — 웹 패턴 + 앱 경계 에러 스파이크**

```yaml
title: JNDI Pattern + Boundary Error Spike (Benign Regression)
id: sim-jndi-boundary
logsource:
  product: application
detection:
  sel1:
    message|contains: '${jndi:'
  sel2:
    level: error
    message|contains: 'boundary check'
  timeframe: 1m
  condition: sel1 and sel2
level: low
```

### 방어 개선안 도출(우선순위)

1) **입력 검증/로그 마스킹**
   - `${` 포함 입력 **로그 마스킹**(PII와 동일 레벨), **헤더 길이 제한**.
2) **라이브러리 업데이트 가드레일**
   - 취약 라이브러리 **버전 범위 자동 알림**(SCA), **릴리즈 게이트**(High 이상 Fail).
3) **탐지 품질 향상**
   - `웹 패턴 → 앱 경고 → 파일마커` **연속 상관 룰** 기본 제공.
   - **토큰 분절** 우회 탐지(문자열 정규화).
4) **대응 자동화**
   - 규칙 히트 시 **간이 앱 방화벽 Rule** 삽입(해당 IP 10분 레이트 리밋/차단).
5) **회귀 테스트**
   - `sim.jsonl`을 이용해 **SIEM 오프라인 재플레이** → “치명 탐지 1+ 발생” 검증 CI.

### KPI/리포트 템플릿

- **탐지 지연(MTTD)**: `jndi_web` 발생 ~ 상관 경보까지 **P50/P95**
- **탐지 정밀도**: 랩 시나리오 n회 중 경보 m회(목표 ≥ 0.95)
- **업데이트 속도**: 패치 공지 ~ 배포까지 **리드타임**(목표 ≤ 7일)
- **오탐률**: 정상 트래픽 대비 경보 비율(목표 ≤ 0.1%)

**자동 생성 리포트(요지; Python)**
```python
from collections import Counter
import json, datetime as dt

def report(fp="sim.jsonl"):
    evts=[json.loads(l) for l in open(fp)]
    t0=min(e["ts"] for e in evts)
    kinds=Counter(e["kind"] for e in evts)
    print("Earliest:", t0, "Kinds:", kinds)

if __name__=="__main__":
    report()
```

---

## 부록 A. 문헌 독해 가이드(체크리스트)

- [ ] **문맥 요약**: 사건의 배경(노출 자산, 인증 유무, 구성)
- [ ] **타임라인 핵심 5행**: 초기 신호, 실행 신호, 권한/영속 힌트, 내부 이동 힌트, 목표 달성 근거
- [ ] **ATT&CK 매핑 표**: 전술/기술/하위기술 + 관측 로그 소스
- [ ] **IOC 표준화**: 문자열/파일/레지스트리/네트워크/클라우드 리소스
- [ ] **패치노트 힌트**: 취약 유형, 구성 플래그, 임시 완화책
- [ ] **탐지/대응 갭**: 수집 누락 채널, 오탐 원인, 상관 실패 지점
- [ ] **개선안 KPI**: 배포 가능 설정/정책/룰 + 목표 수치
- [ ] **회귀 테스트**: 시뮬 로그/쿼리/룰을 저장소에 코드로 유지

---

## 부록 B. 안전 수칙(랩/교육 전용)

- **외부 네트워크 전송 금지**: 모든 도메인·IP는 **TEST-NET** 또는 **로컬 싱크**.
- **크래시 유발 금지**: PoC는 **경계값 에러/로그**만 유도, 비정상 종료 X.
- **식별 마커**: 모든 파일/로그에 `SAFE-LAB`/`SIM` 텍스트 삽입 → 프로덕션 필터 가능.
- **권한·데이터**: 실제 자격증명/PII 금지, 더미 데이터 사용.

---

# 결론

- **사례 독해**의 핵심은 “공격 절차”를 그대로 따라 하는 게 아니라, **문헌에서 관찰 가능한 신호**를 추출해 **타임라인·그래프·탐지 규칙**으로 **재구성**하는 것입니다.
- **패치 노트 힌트 → 무해 PoC(로그 시그널) → 탐지 회귀 테스트**가 **지속 가능한 품질 루프**를 만듭니다.
- 본 장의 **코드 스니펫(시뮬 로그, 타임라인 파서, 그래프, Sigma/KQL)** 을 저장소에 넣고 CI로 돌리면, “**읽고(리딩) → 재현(시뮬) → 개선(룰/플레이북)**”의 선순환을 구축할 수 있습니다.
