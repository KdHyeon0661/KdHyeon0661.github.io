---
layout: post
title: 영상처리 - ICC 프로파일
date: 2025-10-09 20:25:23 +0900
category: 영상처리
---
# ICC 프로파일(색관리) **보존/적용**

## 0) 왜 ICC인가?

- 사진/디자인 파일은 **색 공간**이 제각각입니다(AdobeRGB, Display P3, ProPhoto 등).  
- JPEG에는 APP2(**ICC_PROFILE**) 마커로 **ICC 프로파일**을 넣어 색 공간을 명시합니다.  
- **ICC를 무시**하면, sRGB로 가정한 디스플레이에서 **색이 틀어집니다**(채도/톤 어긋남).  
- 해법: **임베디드 프로파일**을 읽고, 표시용 **sRGB**로 변환하여 렌더링하거나, 저장 시 **프로파일을 보존/부착**합니다.

---

## 1) APP2(ICC) 구조 한 눈에

- 마커: **APP2 = 0xFFE2**  
- **헤더**: `"ICC_PROFILE\0"` (12바이트) + **seqNo**(1바이트, 1..N) + **count**(1바이트, 전체 청크 수 N)  
- **페이로드**: ICC 바이너리의 **조각**. 여러 APP2로 **분할 저장**됨.  
- 복원: **count** 확인 → **seqNo=1..N**를 **정렬/연결** → **완전한 ICC** 확보.

> 안전 규칙  
> - 헤더/길이/seq 범위 **꼼꼼히 검사**(손상/악성 파일 방지)  
> - 여러 세트가 있으면(드묾) **일관성 있는 세트**(같은 count)만 채택

---

## 2) 빌드 세팅 (VS2022 + vcpkg)

### 2.1 패키지 설치
```powershell
# vcpkg 통합(최초 1회)
git clone https://github.com/microsoft/vcpkg
.\vcpkg\bootstrap-vcpkg.bat
.\vcpkg\vcpkg integrate install

# 라이브러리 설치
.\vcpkg\vcpkg install libjpeg-turbo:x64-windows
.\vcpkg\vcpkg install lcms:x64-windows   # lcms2 포트명은 vcpkg에서 'lcms'
```

### 2.2 CMake 예시
```cmake
cmake_minimum_required(VERSION 3.25)
project(ImageToolICC CXX)

find_package(JPEG REQUIRED)
find_package(lcms2 REQUIRED)

add_library(imgcore
  IccProfileUtil.cpp IccProfileUtil.hpp
  JpegIO.cpp JpegIO.hpp
  IppDib.cpp IppDib.hpp
)

target_link_libraries(imgcore PRIVATE JPEG::JPEG lcms2::lcms2)
```

> 수동 프로젝트라면  
> - **추가 포함 디렉터리**: `...\vcpkg\installed\x64-windows\include`  
> - **라이브러리 디렉터리**: `...\vcpkg\installed\x64-windows\lib`  
> - **링크**: `jpeg.lib`, `lcms2.lib`

---

## 3) 구현 — **ICC 수집/결합 → sRGB 변환 → 저장 시 재부착**

### 3.1 헤더
```cpp
// IccProfileUtil.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <string>
#include <jpeglib.h>
#include "IppDib.h"

// 저장된 JPEG 마커(앞서 EXIF에서도 썼던 구조)를 재사용하거나 별도 정의
struct SavedMarker {
    int marker = 0;                // e.g., JPEG_APP0 + 2 (APP2)
    std::vector<uint8_t> data;     // 전체 payload
};

// 0) JPEG 디코더에 ICC 저장 활성화
void EnableSaveICC(j_decompress_ptr cinfo);

// 1) libjpeg의 marker_list에서 APP2(ICC) 청크들을 추출 → 단일 ICC로 결합
bool ExtractICCProfileFromMarkers(j_decompress_ptr cinfo, std::vector<uint8_t>& outICC);
bool ExtractICCProfileFromSaved(const std::vector<SavedMarker>& markers, std::vector<uint8_t>& outICC);

// 2) IppDib(BGRA8) 를 임베디드 ICC → sRGB 로 변환(lcms2)
enum class ICCIntent { Perceptual=0, Relative=1, Saturation=2, Absolute=3 };
bool TransformToSRGB_WithICC(IppDib& inoutBGRA, const std::vector<uint8_t>& icc,
                             ICCIntent intent=ICCIntent::Perceptual, bool blackPointComp=true);

// 3) JPEG 저장 시 ICC 부착 (원본 보존 또는 sRGB 새 프로파일 생성/부착)
bool AttachICCProfileToCompressor(j_compress_ptr cinfo, const std::vector<uint8_t>& icc);

// 4) 유틸: sRGB ICC 바이너리 확보(lcms2로 생성)
bool MakeSRGB_ICC(std::vector<uint8_t>& outICC);
```

### 3.2 ICC 유틸 구현
```cpp
// IccProfileUtil.cpp
#include "IccProfileUtil.hpp"
#include <algorithm>
#include <cstring>
#include <lcms2.h>

// ---------------------- 0) 저장 활성화 ----------------------
void EnableSaveICC(j_decompress_ptr cinfo){
    // APP2 전체 저장 (ICC)
    jpeg_save_markers(cinfo, JPEG_APP0 + 2, 0xFFFF);
}

// ---------------------- 도우미 ----------------------
static inline bool StartsWithICC(const uint8_t* p, size_t n){
    // "ICC_PROFILE\0" (12 bytes)
    static const char sig[] = "ICC_PROFILE\0";
    return n >= sizeof(sig)-1 && std::memcmp(p, sig, sizeof(sig)-1) == 0;
}
struct ICCChunk { int seq=0, cnt=0; std::vector<uint8_t> payload; };

// APP2 marker payload 파싱 → (seq, cnt, payload)
static bool ParseICCChunk(const uint8_t* data, size_t len, ICCChunk& out){
    // 최소: 12(sig)+1(seq)+1(cnt) = 14
    if (len < 14) return false;
    if (!StartsWithICC(data, len)) return false;
    int seq = data[12];
    int cnt = data[13];
    if (seq < 1 || cnt < 1 || seq > cnt) return false;
    const uint8_t* payload = data + 14;
    size_t plen = len - 14;
    out.seq = seq; out.cnt = cnt; out.payload.assign(payload, payload+plen);
    return true;
}

// 여러 APP2(ICC)에서 단일 ICC를 복원
static bool CombineICC(const std::vector<ICCChunk>& chunks, std::vector<uint8_t>& outICC){
    if (chunks.empty()) return false;
    int cnt = chunks[0].cnt;
    // 모든 청크가 같은 cnt를 가져야 함
    for (auto& c : chunks) if (c.cnt != cnt) return false;

    std::vector<const ICCChunk*> table(cnt, nullptr);
    for (auto& c : chunks){
        int idx = c.seq - 1;
        if (idx < 0 || idx >= cnt) return false;
        if (table[idx] != nullptr) return false; // dup
        table[idx] = &c;
    }
    // 모두 존재?
    for (int i=0;i<cnt;++i) if (!table[i]) return false;

    // 연결
    size_t total = 0;
    for (int i=0;i<cnt;++i) total += table[i]->payload.size();
    outICC.clear(); outICC.reserve(total);
    for (int i=0;i<cnt;++i)
        outICC.insert(outICC.end(), table[i]->payload.begin(), table[i]->payload.end());
    return true;
}

// ---------------------- 1) 추출 ----------------------
bool ExtractICCProfileFromMarkers(j_decompress_ptr cinfo, std::vector<uint8_t>& outICC){
    std::vector<ICCChunk> chunks;
    for (jpeg_saved_marker_ptr m=cinfo->marker_list; m; m=m->next){
        if (m->marker == JPEG_APP0 + 2){
            ICCChunk c;
            if (ParseICCChunk(m->data, m->data_length, c))
                chunks.push_back(std::move(c));
        }
    }
    return CombineICC(chunks, outICC);
}

bool ExtractICCProfileFromSaved(const std::vector<SavedMarker>& markers, std::vector<uint8_t>& outICC){
    std::vector<ICCChunk> chunks;
    for (auto& m : markers){
        if (m.marker == JPEG_APP0 + 2){
            ICCChunk c;
            if (ParseICCChunk(m.data.data(), m.data.size(), c))
                chunks.push_back(std::move(c));
        }
    }
    return CombineICC(chunks, outICC);
}

// ---------------------- 2) lcms2 변환 ----------------------
static cmsUInt32Number IntentToLCMS(ICCIntent i){
    switch(i){
        default:
        case ICCIntent::Perceptual: return INTENT_PERCEPTUAL;
        case ICCIntent::Relative:   return INTENT_RELATIVE_COLORIMETRIC;
        case ICCIntent::Saturation: return INTENT_SATURATION;
        case ICCIntent::Absolute:   return INTENT_ABSOLUTE_COLORIMETRIC;
    }
}

bool TransformToSRGB_WithICC(IppDib& inoutBGRA, const std::vector<uint8_t>& icc,
                             ICCIntent intent, bool blackPointComp){
    if (!inoutBGRA || icc.empty()) return false;

    cmsHPROFILE src = cmsOpenProfileFromMem(icc.data(), (cmsUInt32Number)icc.size());
    if (!src) return false;
    cmsHPROFILE dst = cmsCreate_sRGBProfile();
    if (!dst){ cmsCloseProfile(src); return false; }

    cmsUInt32Number flags = cmsFLAGS_COPY_ALPHA; // 알파 그대로
    if (blackPointComp) flags |= cmsFLAGS_BLACKPOINTCOMPENSATION;

    cmsHTRANSFORM xfm = cmsCreateTransform(src, TYPE_BGRA_8, dst, TYPE_BGRA_8,
                                           IntentToLCMS(intent), flags);
    if (!xfm){ cmsCloseProfile(src); cmsCloseProfile(dst); return false; }

    // 안전하게 새 버퍼에 변환 후 교체
    IppDib out; out.create(inoutBGRA.width(), inoutBGRA.height(), 32);
    for (int y=0; y<inoutBGRA.height(); ++y){
        const uint8_t* s = (const uint8_t*)inoutBGRA.bits() + (size_t)y*inoutBGRA.stride();
        uint8_t*       d = (uint8_t*)out.bits() + (size_t)y*out.stride();
        cmsDoTransform(xfm, s, d, (cmsUInt32Number)inoutBGRA.width());
    }
    inoutBGRA = std::move(out);

    cmsDeleteTransform(xfm);
    cmsCloseProfile(dst);
    cmsCloseProfile(src);
    return true;
}

// ---------------------- 3) 저장 시 ICC 부착 ----------------------
bool AttachICCProfileToCompressor(j_compress_ptr cinfo, const std::vector<uint8_t>& icc){
    if (!cinfo || icc.empty()) return false;

    // 한 APP2에 넣을 최대 페이로드(여유있게)
    const size_t kMaxPerMarker = 65500; // 64KB - 헤더 여유

    // 헤더 14B: "ICC_PROFILE\0"(12) + seq(1)+count(1)
    const char sig[] = "ICC_PROFILE\0";
    const size_t hdr = sizeof(sig)-1 + 2; // 14

    // 청크 수
    int count = (int)((icc.size() + kMaxPerMarker - 1) / kMaxPerMarker);
    if (count < 1) count = 1;

    size_t off = 0;
    for (int seq=1; seq<=count; ++seq){
        size_t left = icc.size() - off;
        size_t piece = std::min(left, kMaxPerMarker);

        std::vector<uint8_t> payload; payload.reserve(hdr + piece);
        payload.insert(payload.end(), sig, sig + (sizeof(sig)-1));
        payload.push_back((uint8_t)seq);
        payload.push_back((uint8_t)count);
        payload.insert(payload.end(), icc.begin()+off, icc.begin()+off+piece);

        jpeg_write_marker(cinfo, JPEG_APP0 + 2, payload.data(), (unsigned int)payload.size());
        off += piece;
    }
    return true;
}

// ---------------------- 4) sRGB ICC 바이너리 만들기 ----------------------
bool MakeSRGB_ICC(std::vector<uint8_t>& outICC){
    outICC.clear();
    cmsHPROFILE s = cmsCreate_sRGBProfile();
    if (!s) return false;
    cmsUInt32Number need=0;
    cmsSaveProfileToMem(s, nullptr, &need);
    if (need == 0){ cmsCloseProfile(s); return false; }
    outICC.resize(need);
    if (!cmsSaveProfileToMem(s, outICC.data(), &need)){
        cmsCloseProfile(s); outICC.clear(); return false;
    }
    cmsCloseProfile(s);
    return true;
}
```

### 3.3 JPEG IO와의 연결 (로드/저장)

```cpp
// JpegIO.hpp
#pragma once
#include <vector>
#include <string>
#include "IppDib.h"
#include "IccProfileUtil.hpp"

struct JpegLoadMeta {
    std::vector<SavedMarker> markers;   // 원본 마커(APP1/APP2 등)
    std::vector<uint8_t> icc;           // 결합된 ICC (없으면 empty)
};

bool JpegDecode_WithICC(const std::wstring& path, IppDib& outBGRA, JpegLoadMeta& meta,
                        bool applyICCtoSRGB /*=true*/,
                        ICCIntent intent = ICCIntent::Perceptual,
                        bool blackPointComp = true);

bool JpegEncode_WithICC(const std::wstring& path, const IppDib& bgra,
                        int quality,
                        const std::vector<SavedMarker>& passThroughMarkers,
                        const std::vector<uint8_t>* attachICC /*=nullptr*/);
```

```cpp
// JpegIO.cpp
#include "JpegIO.hpp"
#include <cstdio>
#include <jpeglib.h>

static std::vector<SavedMarker> CollectAllMarkers(j_decompress_ptr cinfo){
    std::vector<SavedMarker> out;
    for (jpeg_saved_marker_ptr m=cinfo->marker_list; m; m=m->next){
        SavedMarker sm; sm.marker = m->marker;
        sm.data.assign(m->data, m->data + m->data_length);
        out.push_back(std::move(sm));
    }
    return out;
}

bool JpegDecode_WithICC(const std::wstring& path, IppDib& outBGRA, JpegLoadMeta& meta,
                        bool applyICCtoSRGB, ICCIntent intent, bool blackPointComp){
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"rb");
    if (!fp) return false;

    jpeg_decompress_struct cinfo{}; jpeg_error_mgr jerr{};
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_stdio_src(&cinfo, fp);

    // ICC + (원하면 EXIF도) 저장 활성화
    EnableSaveICC(&cinfo);
    // jpeg_save_markers(&cinfo, JPEG_APP0 + 1, 0xFFFF); // EXIF도 보존하고 싶다면

    if (jpeg_read_header(&cinfo, TRUE) != JPEG_HEADER_OK){ jpeg_destroy_decompress(&cinfo); fclose(fp); return false; }

    // 마커 백업
    meta.markers = CollectAllMarkers(&cinfo);

    // ICC 결합
    ExtractICCProfileFromMarkers(&cinfo, meta.icc);

    cinfo.out_color_space = JCS_RGB;
    jpeg_start_decompress(&cinfo);
    outBGRA.create(cinfo.output_width, cinfo.output_height, 32);

    std::vector<uint8_t> row(outBGRA.width()*3);
    while (cinfo.output_scanline < cinfo.output_height){
        JSAMPROW rp=row.data();
        jpeg_read_scanlines(&cinfo, &rp, 1);
        uint8_t* dst=(uint8_t*)outBGRA.bits() + (size_t)(cinfo.output_scanline-1)*outBGRA.stride();
        for (int x=0;x<outBGRA.width();++x){
            uint8_t R=row[x*3+0], G=row[x*3+1], B=row[x*3+2];
            dst[x*4+0]=B; dst[x*4+1]=G; dst[x*4+2]=R; dst[x*4+3]=255;
        }
    }
    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);
    fclose(fp);

    // 필요 시: 임베디드 ICC → sRGB 변환
    if (applyICCtoSRGB && !meta.icc.empty()){
        // 실패해도 무시(프로파일 손상 등)
        TransformToSRGB_WithICC(outBGRA, meta.icc, intent, blackPointComp);
    }
    return true;
}

bool JpegEncode_WithICC(const std::wstring& path, const IppDib& bgra,
                        int quality,
                        const std::vector<SavedMarker>& passThroughMarkers,
                        const std::vector<uint8_t>* attachICC){
    if (!bgra) return false;
    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"wb"); if (!fp) return false;

    jpeg_compress_struct cinfo{}; jpeg_error_mgr jerr{};
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_compress(&cinfo);
    jpeg_stdio_dest(&cinfo, fp);

    cinfo.image_width = bgra.width();
    cinfo.image_height= bgra.height();
    cinfo.input_components = 3;
    cinfo.in_color_space = JCS_RGB;

    jpeg_set_defaults(&cinfo);
    jpeg_set_quality(&cinfo, std::clamp(quality,1,100), TRUE);
    jpeg_set_colorspace(&cinfo, JCS_YCbCr);

    // 스캔 시작 전에 메타 쓰기
    jpeg_start_compress(&cinfo, TRUE);

    // 1) 통과시키고 싶은 기존 마커 재주입(필요시 필터링)
    for (auto& m : passThroughMarkers){
        // 예: XMP/EXIF만 유지하고 싶으면 marker 코드를 선택적으로
        jpeg_write_marker(&cinfo, m.marker, m.data.data(), (unsigned int)m.data.size());
    }

    // 2) 지정된 ICC 부착(있는 경우)
    if (attachICC && !attachICC->empty()){
        AttachICCProfileToCompressor(&cinfo, *attachICC);
    }

    // 3) 스캔라인 작성(BGRA → RGB)
    std::vector<uint8_t> row(bgra.width()*3);
    while (cinfo.next_scanline < cinfo.image_height){
        const uint8_t* s=(const uint8_t*)bgra.bits() + (size_t)cinfo.next_scanline*bgra.stride();
        for (int x=0;x<bgra.width();++x){
            row[x*3+0]=s[x*4+2]; // R
            row[x*3+1]=s[x*4+1]; // G
            row[x*3+2]=s[x*4+0]; // B
        }
        JSAMPROW rp=row.data();
        jpeg_write_scanlines(&cinfo, &rp, 1);
    }

    jpeg_finish_compress(&cinfo);
    jpeg_destroy_compress(&cinfo);
    fclose(fp);
    return true;
}
```

---

## 4) **상황별 사용 시나리오**

### 시나리오 A — **iPhone(디스플레이 P3) 사진이 창백하게 보임**

- **증상**: 붉은/주황 톤이 **옅게** 보임.  
- **원인**: JPEG 임베디드 ICC가 **Display P3**인데, 뷰어가 sRGB로 가정해 표시.  
- **해결 흐름**:
  1) `JpegDecode_WithICC(..., applyICCtoSRGB=true)` 로 디코드  
     - APP2에서 ICC 결합 → lcms2로 **P3 → sRGB** 변환 → `IppDib` 갱신  
  2) 저장:  
     - “sRGB 픽셀”을 유지할 거라면 `MakeSRGB_ICC()`로 만든 **sRGB ICC를 부착**하여 `JpegEncode_WithICC`  
     - 또는 원본 ICC 그대로 유지하고 **픽셀은 원공간**(P3)으로 재인코딩(→ 이 경우 표시 앱이 색관리를 해야 함)

```cpp
// 예: P3 → sRGB 변환 후 sRGB 프로파일 부착 저장
IppDib img; JpegLoadMeta meta;
JpegDecode_WithICC(L"in_p3.jpg", img, meta, /*applyICCtoSRGB*/true);

std::vector<uint8_t> srgb;
MakeSRGB_ICC(srgb);
JpegEncode_WithICC(L"out_srgb.jpg", img, 90, /*passThrough=*/{}, &srgb);
```

### 시나리오 B — **브랜드 컬러 엄격함(AdobeRGB 원본 유지)**

- **목표**: 원본(AdobeRGB) 색 공간을 **그대로 유지**하고 메타만 보존.  
- **표시**: 뷰에서는 임시로 sRGB로 변환해 보여주되(화면 일관성), 파일 저장은 **원 ICC 그대로** 포함.

```cpp
// 표시용(임시 변환)
IppDib display = img; // 복사
if (!meta.icc.empty()) TransformToSRGB_WithICC(display, meta.icc);

// 저장은 원본 ICC 그대로 (픽셀은 원공간 값)
JpegEncode_WithICC(L"kept_adobergb.jpg", img, 92, meta.markers, /*attachICC=*/nullptr);
```

### 시나리오 C — **프로파일 없음(무태깅) → sRGB 강제 정책**

- **증상**: ICC가 없고 EXIF ColorSpace도 “Uncalibrated”.  
- **정책**: 팀 규칙으로 **sRGB 간주** 후 sRGB ICC를 **부착**해 저장(색 해석의 모호성 제거).

```cpp
// 로드 후 meta.icc 비었으면 sRGB ICC 생성·부착
std::vector<uint8_t> srgb;
MakeSRGB_ICC(srgb);
JpegEncode_WithICC(L"tagged_srgb.jpg", img, 90, meta.markers, &srgb);
```

---

## 5) **품질/성능/안정성 체크리스트**

- [ ] **ICC 조각**: `"ICC_PROFILE\0"` 시그니처, **seq(1..N)**, **cnt 일치**  
- [ ] **중복/누락**: 같은 seq가 두 번 오거나, 일부 누락 시 **무시/실패 처리**  
- [ ] **lcms2 플래그**: `cmsFLAGS_BLACKPOINTCOMPENSATION`(권장), `cmsFLAGS_COPY_ALPHA`(BGRA 알파 유지)  
- [ ] **렌더링 인텐트**: 사진은 **Perceptual** 또는 **Relative**(BPC 함께) 추천  
- [ ] **대용량 성능**: 행 단위 변환(현재 코드) → 필요 시 **OpenMP/TBB**로 행 병렬화  
- [ ] **저장 정책**:  
  - 픽셀을 sRGB로 **변환했다면 sRGB ICC를 부착**(일관성)  
  - 픽셀을 원공간으로 유지한다면 **원 ICC를 그대로 재주입**  
- [ ] **다른 메타와의 상호작용**: EXIF Orientation을 **이미 적용**했다면 저장 시 Orientation=1로 패치(중복 회전 방지)  
- [ ] **보안**: APP 길이/오프셋 **철저 검증**(손상/악성 파일 방지)

---

## 6) (선택) 수학/개념 메모

ICC 기반 색변환은 **PCS(Profile Connection Space)**(보통 CIE XYZ 혹은 Lab)를 경유합니다.  
소스 RGB → (소스 ICC) → **PCS** → (목적 ICC) → 목적 RGB(sRGB).  
감마/원색/백점, 적응, BPC 등이 매트릭스/룩업 형태로 **비선형 매핑**됩니다.

---

## 7) 흔한 문제 & 디버그 팁

- **색이 여전히 이상**  
  - 실제 디스플레이가 하드웨어적으로 sRGB가 아닌데 OS 색관리가 비활성일 수 있습니다.  
  - 우리는 **픽셀을 sRGB로 변환**했으므로, 일반적 sRGB 가정 하에서는 일관됩니다.
- **ICC 있지만 lcms2 변환 실패**  
  - 손상/희귀 프로파일(멀티로컬)일 수 있음 → 실패 시 변환을 **건너뛰고** 경고만 띄우세요.  
- **용량 증가**  
  - ICC는 수~수십 KB. 필요 시 저장 옵션에서 **ICC 제거/보존 토글** 제공.

---

## 8) 요약

- JPEG의 **정확한 색 표시**를 위해서는 **APP2(ICC)** 를 **읽고**, 필요하면 **sRGB로 변환**해 그리는 것이 안전합니다.  
- 본문 코드는 **ICC 조각 재조립**, **lcms2 변환**, **저장 시 ICC 부착**까지 **엔드투엔드** 예제를 제공합니다.  
- 실무 기본 프리셋:  
  - **표시**: 임베디드 ICC → **sRGB** 변환 후 렌더  
  - **저장**:  
    - sRGB로 바꾼 픽셀 ⇒ **sRGB ICC 부착**  
    - 원공간 유지 ⇒ **원 ICC 보존**
