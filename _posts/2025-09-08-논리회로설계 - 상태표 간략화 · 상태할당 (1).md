---
layout: post
title: 논리회로설계 - 상태표 간략화 · 상태할당 (1)
date: 2025-09-08 20:25:23 +0900
category: 논리회로설계
---
# 상태표 간략화 · 상태할당 — **중복상태 제거**, **등가상태(동치/구별 가능 상태)**, **함의(임플리케이션) 차트**

## 준비 — 핵심 개념과 흐름

- **도달 가능 상태(Reachable)**: 리셋 상태 \(q_{\mathrm{rst}}\)에서 유한 입력열로 도달 가능한 상태. 도달 불가능 상태는 **즉시 삭제**.
- **등가 상태(Equivalent)**
  - **Moore**: \(p\equiv q \iff \big(y(p)=y(q)\big)\land\big(\forall x\in\mathcal{X},\ \delta(p,x)\equiv\delta(q,x)\big)\).
  - **Mealy**: \(p\equiv q \iff \big(\forall x,\ \lambda(p,x)=\lambda(q,x)\big)\land\big(\forall x,\ \delta(p,x)\equiv\delta(q,x)\big)\).
- **구별 가능(Distinguishable)**: 등가가 **아닌** 상태 쌍. 어떤 입력열 \(\alpha\)가 두 상태의 출력열을 다르게 만든다.
- **상태 최소화** = (1) 도달성 정리 → (2) 등가 병합.
- **상태할당(State assignment)**: 최소화된 추상 상태를 **비트 코드**로 배당(이진/그레이/원-핫/Johnson 등)하여 **다음상태·출력** 로직을 최소화.

---

## 중복상태 제거 — **도달성 분석**

### 알고리즘(그래프 BFS)

1. \(R\leftarrow\{q_{\mathrm{rst}}\}\).
2. 모든 \(q\in R\), \(x\in\mathcal{X}\)에 대해 \(q'=\delta(q,x)\)를 계산하여 \(R\leftarrow R\cup\{q'\}\).
3. 더 이상 커지지 않으면 종료. \(S\setminus R\)는 **삭제**.

### 주의와 실무 팁

- **Mealy/Moore 동일**.
- **Self-start 설계**: 실제 하드웨어는 전원 인가/SEU로 **불법 코드**에 들어갈 수 있음 → `when others => IDLE` 같은 **동기 복구** 경로를 반드시 둔다.
- 시뮬 TB에서 무작위 초기 상태로 시작해 **루프 수렴** 어서션을 건다.

**VHDL 스니펫(불법 상태 복구)**
```vhdl
case s is
  when A => ns <= (x='0') ? B : C;
  when B => ns <= (x='0') ? B : D;
  when C => ns <= (x='0') ? B : C;
  when D => ns <= (x='0') ? B : D;
  when others => ns <= A; -- 동기 복구(Self-start)
end case;
```

---

## 등가/구별 — **정의와 빠른 판정 감각**

### 수학적 정의(암기용)

\[
\boxed{
\begin{aligned}
\text{Moore: } & p\equiv q \iff \big(y(p)=y(q)\big)\land\big(\forall x,\ \delta(p,x)\equiv\delta(q,x)\big)\\
\text{Mealy: } & p\equiv q \iff \big(\forall x,\ \lambda(p,x)=\lambda(q,x)\big)\land\big(\forall x,\ \delta(p,x)\equiv\delta(q,x)\big)
\end{aligned}}
\]

### 실무 감각

- **Moore**: 먼저 **출력값**으로 큰 덩어리 분할(다르면 절대 등가 아님).
- **Mealy**: 먼저 **모든 입력에서의 즉시 출력**이 같은지 확인(다르면 탈락).
- 동등 후보쌍만 남겨 **다음상태 쌍**을 재귀적으로 비교 → 두 방법: **연쇄 분할**(특히 Moore 효율적), **함의 차트**(Mealy/Moore 공용, 수작업 친화).

---

## 연쇄 분할(Partition refinement) — **Moore 표준**

### 절차

1) **초기 분할** \(P_0\): 동일 출력 상태끼리 묶기.
2) **세분화** \(P_{k+1}=\mathrm{refine}(P_k)\): 같은 블록의 두 상태 \(p,q\)가 모든 입력 \(x\)에 대해 \(\delta(p,x)\)과 \(\delta(q,x)\)가 **동일 블록**으로 향하지 않으면 분리.
3) 고정점에 도달하면 각 블록이 **등가 클래스**.

### 예제(간단 Moore)

- 상태/출력: \(A,B,C:0,\ D:1\). 입력 \(x\in\{0,1\}\).
- 전이:
  \(A:0\to B,1\to C\)
  \(B:0\to B,1\to D\)
  \(C:0\to B,1\to C\)
  \(D:0\to B,1\to D\)

**Step 1 — 초기 분할**: \(\{A,B,C\} \mid \{D\}\)
**Step 2 — 세분화**:
- \(A\)와 \(C\): `0→B,1→C`로 **동일 패턴** → 같은 블록 유지
- \(B\): `1→D`가 **다른 블록** → 분리
**결과**: \(\{A,C\} \mid \{B\} \mid \{D\}\) → \(A\equiv C\).

### 파이썬 도구 스니펫(붙여넣기용)

```python
# Moore FSM partition refinement (교육용, 소형 FSM)
# states: dict[name] = {'y':0/1/..., 'delta':{x: next_name}}

def minimize_moore(states, inputs):
    from collections import defaultdict
    # 초기 분할: 출력값 기준
    blocks = {}
    for s,(k,_) in ((n,(v['y'],v)) for n,v in states.items()):
        blocks.setdefault(k,set()).add(s)
    P = list(blocks.values())
    changed = True
    while changed:
        changed = False
        newP = []
        for B in P:
            # 서브블록 분할
            buckets = defaultdict(set)
            for s in B:
                sig = tuple(next((i for i,b in enumerate(P) if states[states[s]['delta'][x]] in ({t for t in b})) , -1) for x in inputs)
                buckets[sig].add(s)
            if len(buckets) == 1:
                newP.append(B)
            else:
                changed = True
                newP.extend(buckets.values())
        P = newP
    # 등가 클래스 대표자 매핑
    rep = { s: next(iter(B)) for B in P for s in B }
    return P, rep
```

> 실제 합성/산업용 도구는 훨씬 많은 예외와 최적화를 포함하지만, 위 스니펫으로 **분할 고정점** 과정을 확인하기 충분합니다.

---

## 함의(임플리케이션) 차트 — **수작업에 강한 표준 도구**

### 개념

- 표의 셀 = **정렬된 상태쌍** \((p,q)\), \(p>q\).
- 초기 마크:
  - **Moore**: \(y(p)\ne y(q)\Rightarrow\) **×**.
  - **Mealy**: \(\exists x:\lambda(p,x)\ne\lambda(q,x)\Rightarrow\) **×**.
- 각 셀에 **함의**를 적음:
  \[
  (p,q)\Rightarrow\big(\delta(p,x),\delta(q,x)\big)\quad\forall x
  \]
  (쌍 정렬 후 기록)
- **전파**: 참조하는 쌍이 ×이면 **자기도 ×**(귀류). 변동 없을 때까지 반복.

### Worked Example — **Mealy**(중첩 허용 `1011`의 부분 FSM)

**상태·전이·출력(간략)**

| 현재 | x=0 → (다음/출력) | x=1 → (다음/출력) |
|:--:|:--:|:--:|
| A | A /0 | B /0 |
| B | C /0 | B /0 |
| C | A /0 | D /0 |
| D | C /0 | B /**1** |

- 상태쌍 목록(정렬): (A,B),(A,C),(A,D),(B,C),(B,D),(C,D).

**초기 마크(Mealy)**:
- 간선 출력이 즉시 다르면 ×. (D는 x=1에서 1을 내므로, D와 A/B/C의 조합은 거의 ×)

**함의 기록 예**
- (A,B): x=0 ⇒ (A,C), x=1 ⇒ (B,B)
- (B,C): x=0 ⇒ (C,A)=(A,C), x=1 ⇒ (B,D)
- (A,D): x=1 ⇒ (B,B) OK, x=0 ⇒ (A,C) → (A,D) 자체는 초기 ×(x=1 출력 다름)로 표기
- …

**전파**: (B,D)×가 확정되면 이를 참조하는 (B,C)도 ×, 이어 (A,B)도 × …
**결론**: 남는 비× 셀 = 등가 가능 쌍(이 예에선 **없음**). → 상태 병합 없음.

> 동일 예제를 **Moore**로 바꾸면 초기 마크 기준이 달라져 등가 후보가 생길 수 있습니다.

**차트(요지, ‘→’는 함의)**
```
(A,B): → {(A,C),(B,B)}  ; (B,B)=trivial, (A,C) 판정 필요
(A,C): → {(A,A),(B,D)}  ; (B,D)=× ⇒ (A,C)=×
(A,D): 초기× (출력 다름)
(B,C): → {(C,A),(B,D)} ; (B,D)=× ⇒ (B,C)=×
(B,D): 초기×
(C,D): 초기×
```

---

## 비완전 명세(ISM) — **호환·합병과 닫힌 커버**

- **호환(compatible)**: 정의된 입력에 한해 출력 동일·다음상태 쌍이 **재귀적으로 호환**. 미정(`–`)은 제약 없음.
- **최대 호환집합**을 구해 **닫힌 커버(closed cover)** 를 선택(커버 내부 전이가 **커버 안**으로 닫히도록) → 상태 합병.
- 합병 후 **미정 전이 채움**: **IDLE/ERR로 귀결**을 기본값으로 두어 **Self-start**·락아웃 방지.

**Moore ISM 예(요약)**

| 현재 | x=0 → | x=1 → | y |
|:--:|:--:|:--:|:--:|
| A | B | – | 0 |
| B | C | D | 0 |
| C | – | A | 0 |
| D | D | – | 1 |

→ 호환 후보 (A,C). 닫힌 커버 \{AC,B,D\}로 축약. (자세한 전개는 “ISM 심화” 글 참고)

---

## 상태할당(State Assignment) — **로직을 줄이는 코딩**

### 목표·전략

- 다음상태/출력 로직의 **게이트 수·팬인·지연·해저드** 최소화.
- 플랫폼별 선택:
  - **원-핫**(FPGA): 상태수 \(N\)개의 FF, 조합 로직 단순/고속.
  - **이진**(ASIC): \(\lceil\log_2 N\rceil\) FF로 면적 최소.
  - **그레이**: 인접 전이 해밍거리 1 → 해저드/EMI↓.
  - **Johnson/링**: 순환/토큰형 FSM에 적합.

### 휴프만(인접) 휴리스틱

1) **인접 그래프**: 전이가 잦은 상태쌍에 **가중치**.
2) **하이퍼큐브 임베딩**: 가중치가 큰 쌍을 **해밍거리 1**로 배정.
3) **Moore 출력 비트화**: 상태코드의 일부 비트를 출력으로 **직결**해 출력 로직 제거.

### 작은 예 — 축약 FSM \(\{AC,B,D\}\) 2비트 배정

- 출력: \(y(AC)=0,\ y(B)=0,\ y(D)=1\) → **MSB를 출력비트**로: \(D\to 1\*,\ AC,B\to 0\*\).
- 전이 잦음: \(AC\leftrightarrow B\), \(B\to D\).
- 배정: \(AC=00,\ B=01,\ D=10\) (그레이형).
- K-맵으로 \(D_1,D_0\) 최소화 가능(팬인 2~3).

**VHDL(명시적 인코딩)**
```vhdl
library ieee; use ieee.std_logic_1164.all;
entity fsm_moore is
  port (clk,rst,x: in std_logic; y: out std_logic);
end;
architecture rtl of fsm_moore is
  type state_t is (AC,B,D);
  signal s, ns : state_t := AC;
  attribute enum_encoding : string;
  attribute enum_encoding of state_t : type is "00 01 10"; -- AC=00,B=01,D=10
begin
  process(all) begin
    case s is
      when AC => ns <= (x='0') ? B : AC;
      when B  => ns <= (x='0') ? AC : D;
      when D  => ns <= D;
    end case;
  end process
  ;
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then s<=AC; else s<=ns; end if;
    end if;
  end process;
  y <= '1' when s=D else '0'; -- MSB 직접 배정의 효과
end;
```

**Verilog(원-핫도 간단)**

```verilog
typedef enum logic [2:0] {AC=3'b001, B=3'b010, D=3'b100} state_t;
state_t s, ns;
always_comb begin
  ns = s;
  unique case (s)
    AC: ns = (x==1'b0) ? B : AC;
    B : ns = (x==1'b0) ? AC : D;
    D : ns = D;
  endcase
end
always_ff @(posedge clk) if (rst) s<=AC; else s<=ns;
assign y = (s==D);
```

---

## 실전 예제(끝까지) — **Moore FSM 최소화 → 상태할당 → 논리 도출**

### 초기 FSM

| 상태 | x=0 → | x=1 → | y |
|:--:|:--:|:--:|:--:|
| A | B | C | 0 |
| B | B | D | 0 |
| C | B | C | 0 |
| D | B | D | 1 |

- **도달성**: 네 상태 모두 도달 가능(간단 확인).
- **연쇄 분할**: \(\{A,C\}\mid\{B\}\mid\{D\}\).

### 상태할당(이진 2비트)

- \(A\equiv C\) → 대표 \(AC=00\), \(B=01\), \(D=10\) (그레이).
- **다음상태 테이블(코드 기준)**

| 코드(s) | x | ns 코드 |
|:--:|:--:|:--:|
| 00 (AC) | 0 | 01 (B) |
| 00 (AC) | 1 | 00 (AC) |
| 01 (B)  | 0 | 00 (AC) |
| 01 (B)  | 1 | 10 (D) |
| 10 (D)  | 0 | 10 (D) |
| 10 (D)  | 1 | 10 (D) |

- **K-맵/식 도출(한눈 요약)**
  \[
  \begin{aligned}
  D_1(s_1,s_0,x) &= s_1 \;\lor\; (s_0\land x)\\
  D_0(s_1,s_0,x) &= \overline{s_1}\,\overline{s_0}\,\overline{x} \;\lor\; \overline{s_1}\,s_0\,\overline{x}\\
                 &= \overline{s_1}\,\overline{x} \quad(\text{단순화})
  \end{aligned}
  \]
  출력 \(y=s_1\).

> 도출 과정에서 **인접 배정** 덕분에 \(D_0=\overline{s_1}\,\overline{x}\)처럼 **팬인 2**의 매우 단순한 식을 얻는다.

---

## 검증과 체크리스트

- [ ] **도달성**으로 죽은 상태 제거.
- [ ] Moore/Mealy에 맞는 **등가 정의**로 최소화.
- [ ] **함의 차트**: 초기 ×(출력 불일치/간선 출력 불일치) → 함의 전파.
- [ ] ISM이면 **호환/닫힌 커버** 준수, 미정 전이는 IDLE/ERR로 채움.
- [ ] 상태할당: 잦은 전이를 **해밍거리 1**로, Moore 출력은 **상태코드 비트화**.
- [ ] **Self-start** 경로(when others), Mealy 출력은 **레지스터**.
- [ ] 합성 결과(셀 수/팬인/지연) 비교 후 코드 확정.

---

## 연습문제(원하면 해설 제공)

1) Mealy FSM(상태 6개, 입력 2비트)의 **함의 차트**를 작성해 등가쌍을 찾고 최소화하라.
2) 위 §7 FSM을 **원-핫**으로 다시 배정하고, 다음상태식 \(S_j^+=\bigvee S_i\land \chi_x\) 형태로 써 보라.
3) ISM Moore FSM에서 최대 호환집합을 구하고 **닫힌 커버**를 구성하라.
4) 상태할당에서 인접 그래프의 **가중치**를 실제 트래픽 빈도로 잡았을 때와 균등으로 잡았을 때의 합성 결과를 비교하라.
5) 최소화된 FSM에 **비동기 리셋 해제**로 인한 메타안정 가능성을 줄이는 레지스터링 패턴을 제시하라.

---

### 포켓 요약

- **중복상태 제거**: 도달성 분석이 1순위.
- **등가판정**: Moore는 **연쇄 분할**, Mealy/혼합 상황은 **함의 차트**가 수작업에 강함.
- **ISM**: 호환/닫힌커버로 최소화, 미정은 안전 귀결.
- **상태할당**: 인접(그레이)·출력비트화·원-핫/이진 선택으로 로직을 **눈에 띄게** 줄일 수 있다.
