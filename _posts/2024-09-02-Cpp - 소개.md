---
layout: post
title: C++ - 소개
date: 2024-09-02 19:20:23 +0900
category: Cpp
---
# C++ 소개 및 C 언어와의 차이점

## C++란 무엇인가?

C++는 C 언어의 저수준 제어력과 성능을 유지하면서 객체지향 프로그래밍, 제네릭 프로그래밍, 예외 처리, 풍부한 표준 라이브러리 등 현대적인 기능을 추가한 범용 시스템 프로그래밍 언어입니다.

중요한 점은 C++가 C의 단순한 "상위 호환"이 아니라는 사실입니다. 두 언어는 별개의 언어로서, 암시적 변환 규칙, 링키지, 키워드, 예약어, 함수 오버로딩 등 여러 측면에서 차이가 있습니다. 모든 C 코드가 C++에서 그대로 컴파일되는 것은 아닙니다.

---

## C vs C++ 핵심 비교

| 항목 | C | C++ |
|---|---|---|
| **기본 패러다임** | 절차지향 프로그래밍 | 다중 패러다임 (절차, 객체지향, 제네릭, 함수형) |
| **타입 시스템** | 비교적 느슨함, 암시적 변환 빈번 | 엄격함, 명시적 변환 권장 |
| **메모리 관리** | 수동 (`malloc`/`free`) | RAII 패턴, 스마트 포인터, 컨테이너 |
| **오류 처리** | 반환값, `errno` 전역 변수 | 예외 처리 (`try`/`catch`), `std::optional` 등 |
| **표준 라이브러리** | C 표준 라이브러리 | STL (컨테이너, 알고리즘, 반복자), 파일 시스템, 스레드 등 |

---

## 객체지향 프로그래밍: struct와 class

C++에서 `struct`와 `class`의 유일한 차이는 **기본 접근 제어자**입니다:
- `struct`: 기본 접근 제어자가 `public`
- `class`: 기본 접근 제어자가 `private`

```cpp
// C++에서의 struct - 함수 멤버 포함 가능
struct Point {
    int x = 0;
    int y = 0;
    
    void move(int dx, int dy) {
        x += dx;
        y += dy;
    }
};

// C++에서의 class - 정보 은닉 지원
class BankAccount {
private:
    double balance = 0.0;
    
public:
    void deposit(double amount) {
        if (amount > 0) balance += amount;
    }
    
    double getBalance() const {
        return balance;
    }
};
```

### 강력한 열거형 (enum class)

C의 열거형보다 타입 안전성이 뛰어난 `enum class`:

```cpp
// C 스타일 enum - 전역 범위, 암시적 정수 변환
enum Color { RED, GREEN, BLUE };
int colorValue = RED;  // 암시적 변환 허용

// C++ enum class - 범위 한정, 명시적 변환만 허용
enum class TrafficLight { Red, Yellow, Green };
TrafficLight light = TrafficLight::Red;
// int value = light;  // 컴파일 오류: 암시적 변환 불가
int value = static_cast<int>(light);  // 명시적 변환 필요
```

---

## 함수와 호출 가능 객체

C++에서는 함수 포인터 외에도 다양한 방식으로 함수를 표현하고 전달할 수 있습니다:

### 1. 함수 포인터 (C와 동일)
```cpp
int add(int a, int b) { return a + b; }

int main() {
    int (*funcPtr)(int, int) = add;
    std::cout << funcPtr(3, 4) << std::endl;  // 7
}
```

### 2. 함수 객체 (Functor)
```cpp
struct Multiplier {
    int factor;
    
    int operator()(int x) const {
        return x * factor;
    }
};

int main() {
    Multiplier timesTwo{2};
    std::cout << timesTwo(5) << std::endl;  // 10
}
```

### 3. 람다 표현식 (C++11)
```cpp
int main() {
    // 기본 람다
    auto square = [](int x) { return x * x; };
    std::cout << square(5) << std::endl;  // 25
    
    // 캡처를 사용하는 람다
    int base = 10;
    auto addBase = [base](int x) { return x + base; };
    std::cout << addBase(5) << std::endl;  // 15
}
```

### 4. std::function (유연한 함수 래퍼)
```cpp
#include <functional>
#include <iostream>

int main() {
    std::function<int(int, int)> operation;
    
    operation = [](int a, int b) { return a + b; };
    std::cout << operation(3, 4) << std::endl;  // 7
    
    operation = [](int a, int b) { return a * b; };
    std::cout << operation(3, 4) << std::endl;  // 12
}
```

**성능 고려사항**:
- 최고 성능이 필요하면 템플릿을 사용하여 호출 가능 객체를 인라인화
- 런타임 다형성이 필요하면 `std::function` 사용 (약간의 오버헤드 있음)

---

## 안전한 형 변환

C 스타일 캐스트(`(type)value`) 대신 의도를 명확히 하는 C++ 스타일 캐스트를 사용하세요:

| 캐스트 | 용도 | 예제 |
|---|---|---|
| `static_cast` | 컴파일 타임에 안전성이 확인된 변환 | `double d = 3.14; int i = static_cast<int>(d);` |
| `const_cast` | `const`나 `volatile` 한정자 제거/추가 | `const int* p = &x; int* q = const_cast<int*>(p);` |
| `reinterpret_cast` | 비트 단위 재해석 (위험) | `int i = 42; float f = reinterpret_cast<float&>(i);` |
| `dynamic_cast` | 다형적 타입의 안전한 다운캐스트 | `Base* b = new Derived(); Derived* d = dynamic_cast<Derived*>(b);` |

---

## RAII와 스마트 포인터

RAII(Resource Acquisition Is Initialization)는 C++의 핵심 디자인 패턴으로, 자원 관리를 객체 수명과 결합합니다.

### 스마트 포인터 종류

```cpp
#include <memory>
#include <iostream>

// 1. std::unique_ptr - 독점 소유권
std::unique_ptr<int> createUnique() {
    return std::make_unique<int>(42);
}

void uniquePtrExample() {
    auto ptr = createUnique();
    std::cout << *ptr << std::endl;  // 42
    // 소멸 시 자동으로 메모리 해제
}

// 2. std::shared_ptr - 공유 소유권
void sharedPtrExample() {
    auto ptr1 = std::make_shared<int>(100);
    {
        auto ptr2 = ptr1;  // 참조 카운트 증가
        std::cout << *ptr2 << std::endl;  // 100
    }  // ptr2 소멸, 참조 카운트 감소
    // ptr1이 여전히 객체를 소유
}

// 3. std::weak_ptr - 약한 참조 (순환 참조 방지)
struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;  // 약한 참조로 순환 참조 방지
};

void weakPtrExample() {
    auto node1 = std::make_shared<Node>();
    auto node2 = std::make_shared<Node>();
    
    node1->next = node2;
    node2->prev = node1;  // 약한 참조 사용
}
```

### Rule of Zero/Three/Five
- **Rule of Zero**: 클래스가 자원을 직접 관리하지 않으면 복사/이동 연산자를 명시적으로 정의하지 마세요.
- **Rule of Three**: 소멸자, 복사 생성자, 복사 대입 연산자를 함께 정의하세요.
- **Rule of Five**: 이동 생성자와 이동 대입 연산자도 추가 정의하세요.

---

## 표준 템플릿 라이브러리 (STL)

STL은 컨테이너, 알고리즘, 반복자로 구성된 C++의 핵심 라이브러리입니다.

### 주요 컨테이너 선택 가이드

| 사용 목적 | 권장 컨테이너 | 설명 |
|---|---|---|
| 일반적인 동적 배열 | `std::vector` | 임의 접근, 끝에서 삽입/삭제 효율적 |
| 키-값 저장소 (정렬) | `std::map` | 레드-블랙 트리 기반, 키 순서 보장 |
| 키-값 저장소 (해시) | `std::unordered_map` | 해시 테이블 기반, 평균 O(1) 접근 |
| 빠른 검색 집합 | `std::set` / `std::unordered_set` | 중복 없는 요소 저장 |
| 양방향 접근 리스트 | `std::deque` | 앞뒤에서 삽입/삭제 효율적 |
| 데이터 뷰 | `std::span` (C++20) | 연속 메모리 뷰, 소유권 없음 |

### 알고리즘 사용 예제

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3};
    
    // 정렬
    std::sort(numbers.begin(), numbers.end());
    
    // 검색
    auto it = std::find(numbers.begin(), numbers.end(), 8);
    if (it != numbers.end()) {
        std::cout << "Found: " << *it << std::endl;
    }
    
    // 조건부 제거 (erase-remove 관용구)
    numbers.erase(
        std::remove_if(numbers.begin(), numbers.end(),
                       [](int x) { return x % 2 == 0; }),  // 짝수 제거
        numbers.end()
    );
    
    // 변환
    std::transform(numbers.begin(), numbers.end(), numbers.begin(),
                   [](int x) { return x * 2; });  // 모든 요소 2배
    
    // 출력
    for (int n : numbers) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

---

## 현대 C++ 기능 (C++11 이후)

### 1. 범위 기반 for 루프
```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (int n : numbers) {
    std::cout << n << " ";
}
```

### 2. 자동 타입 추론 (auto)
```cpp
auto x = 42;           // int
auto y = 3.14;         // double
auto z = std::make_unique<int>(10);  // std::unique_ptr<int>
```

### 3. 구조적 바인딩 (C++17)
```cpp
std::map<std::string, int> scores = {{"Alice", 95}, {"Bob", 87}};
for (const auto& [name, score] : scores) {
    std::cout << name << ": " << score << std::endl;
}
```

### 4. 옵셔널 값 (std::optional, C++17)
```cpp
#include <optional>

std::optional<int> findValue(const std::vector<int>& vec, int target) {
    for (int val : vec) {
        if (val == target) return val;
    }
    return std::nullopt;  // 값 없음
}

void example() {
    std::vector<int> data = {1, 2, 3, 4, 5};
    auto result = findValue(data, 3);
    
    if (result.has_value()) {
        std::cout << "Found: " << result.value() << std::endl;
    } else {
        std::cout << "Not found" << std::endl;
    }
}
```

### 5. 컨셉 (Concepts, C++20)
```cpp
#include <concepts>
#include <iostream>

// 정수 타입만 허용하는 템플릿
template<std::integral T>
T add(T a, T b) {
    return a + b;
}

// 사용자 정의 컨셉
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::same_as<T>;
};

template<Addable T>
T multiply(T a, T b) {
    return a * b;
}
```

---

## C와의 상호 운용성

C++ 코드에서 C 라이브러리를 사용할 때 주의점:

### 1. C 헤더 포함
```cpp
// C++에서 C 헤더를 포함하는 올바른 방법
#include <cstdio>    // <stdio.h> 대신
#include <cstdlib>   // <stdlib.h> 대신
#include <cmath>     // <math.h> 대신
```

### 2. C 함수 링크 지정
```cpp
extern "C" {
    // C 함수 선언
    void c_function(int arg);
    int c_variable;
}

// 또는 헤더 전체를 감쌀 수 있습니다
#ifdef __cplusplus
extern "C" {
#endif

// C 헤더 내용...

#ifdef __cplusplus
}
#endif
```

### 3. 메모리 관리 주의사항
```cpp
// C 스타일 할당을 C++에서 사용할 때
void* c_memory = malloc(100 * sizeof(int));
// 사용 후
free(c_memory);

// C++ 스타일 할당 (권장)
int* cpp_memory = new int[100];
// 사용 후
delete[] cpp_memory;

// 더 나은 방법: 스마트 포인터 사용
auto smart_memory = std::make_unique<int[]>(100);
// 자동 해제
```

---

## 결론: C에서 C++로의 전환 핵심

C++는 C의 장점을 유지하면서 더 안전하고 표현력 있는 프로그래밍을 가능하게 합니다. 효과적인 전환을 위해 다음 원칙들을 기억하세요:

1. **안전성 우선**
   - 원시 포인터 대신 스마트 포인터 사용
   - C 스타일 캐스트 대신 C++ 스타일 캐스트 사용
   - 배열 대신 STL 컨테이너 사용

2. **추상화 활용**
   - 함수 포인터 대신 함수 객체, 람다, `std::function` 사용
   - 절차적 코드 대신 객체지향 설계 적용
   - 템플릿으로 제네릭 프로그래밍 구현

3. **자원 관리**
   - RAII 패턴으로 자동 자원 관리 구현
   - Rule of Zero를 지향하여 직접 자원 관리 최소화

4. **현대적 기능 도입**
   - `auto`로 타입 추론 활용
   - 범위 기반 for 루프로 간결한 반복문 작성
   - `std::optional`로 선택적 값 표현

5. **점진적 전환**
   - 기존 C 코드를 한 번에 모두 변환하지 말고 점진적으로 개선
   - C++ 기능을 새로 작성하는 코드부터 도입
   - 중요한 성능 병목 지점에서만 C 스타일 최적화 유지

C++는 C의 제어력과 성능을 유지하면서도 더 높은 수준의 추상화와 안전성을 제공합니다. 이러한 장점들을 활용하면 더 견고하고 유지보수하기 쉬운 시스템 소프트웨어를 개발할 수 있습니다.