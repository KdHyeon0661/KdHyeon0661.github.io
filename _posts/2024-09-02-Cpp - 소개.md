---
layout: post
title: C++ - 소개
date: 2024-09-02 19:20:23 +0900
category: Cpp
---
# C++ 소개 및 C 언어와의 차이점

## C++란 무엇인가? (요약 복습)

- C의 저수준 제어력에 **객체지향·제네릭·예외·표준 라이브러리**를 더한 **범용 시스템 언어**.
- “상위 호환”처럼 보이지만, **엄밀히는 다른 언어**: 암시적 변환/링키지/키워드/예약어/오버로딩 규칙 등 차이로 **모든 C 코드가 C++에서 그대로 컴파일되는 것은 아님**.

### C vs C++ 핵심 비교 (보강)

| 항목 | C | C++ |
|---|---|---|
| 패러다임 | 절차지향 | 절차 + OOP + 제네릭 + 함수형 스타일(람다/알고리즘) |
| 타입 시스템 | 약간 약함(암시 캐스트 빈번) | 강함(오버로딩·템플릿·명시 캐스트) |
| 메모리 관리 | 수동(`malloc/free`) | RAII + 스마트 포인터 + 컨테이너 |
| 오류 처리 | 리턴값, `errno` | 예외(`try/catch`), 선택적 대안(`expected` 스타일) |
| 표준 라이브러리 | C 표준 라이브러리 | 컨테이너/알고리즘/스마트 포인터/동시성/파일시스템 등 풍부 |

---

## 콜백의 진화: 함수 포인터 → 함수 객체(functor) → `std::function` → 람다

### C 스타일 함수 포인터

```c
#include <stdio.h>

void hello(void){ printf("Hello, C!\n"); }

int main(){
    void (*fp)(void) = hello;
    fp();
}
```

### C++에서의 대안들

```cpp
#include <functional>
#include <iostream>

int add(int a, int b){ return a + b; }

struct Adder {
    int operator()(int a, int b) const { return a + b; } // 함수 객체
};

int main(){
    // 1) 함수 포인터
    int (*fp)(int,int) = add;
    std::cout << fp(2,3) << "\n";

    // 2) std::function (형태 소거)
    std::function<int(int,int)> f = add;
    std::cout << f(2,3) << "\n";

    // 3) 람다
    auto lam = [](int a, int b){ return a + b; };
    std::cout << lam(2,3) << "\n";

    // 4) 함수 객체
    Adder ad;
    std::cout << ad(2,3) << "\n";
}
```

**팁**
- **최고의 성능**: 템플릿 매개변수로 “호출 가능 객체(auto/템플릿)”를 받기 (인라인 최적화 기대).
- **런타임 다형성/저장 필요**: `std::function` (약간의 오버헤드 감수).

---

## `struct` vs `class`, 열거형

- C++에서 `struct`와 `class`의 차이는 **기본 접근 제어** 뿐: `struct`는 `public`, `class`는 `private`.
- 멤버 함수/상속/템플릿 가능.
- **강력한 열거형**: `enum class` (스코프/암시 캐스트 차단)

```cpp
struct Point {
    int x{}, y{};
    void translate(int dx, int dy){ x+=dx; y+=dy; }
};

class Widget {
    int secret_{42}; // 기본 private
public:
    int value() const { return secret_; }
};

enum class Color { Red, Green, Blue }; // 스코프 강제, int로의 암시적 변환 금지
```

---

## 형 변환: C 캐스트 ↔ C++ 캐스트

| 캐스트 | 용도 |
|---|---|
| `static_cast<T>(e)` | 정적(컴파일 타임) 확인 가능 변환 (숫자/상속 upcast 등) |
| `const_cast<T>(e)` | `const`/`volatile` 제거/부여 |
| `reinterpret_cast<T>(e)` | 비트 수준/포인터 재해석(위험) |
| `dynamic_cast<T>(p)` | 다형 베이스→파생 다운캐스트 (RTTI 필요, 실패시 `nullptr`/예외) |

**가이드**: C 캐스트 대신 **의도를 드러내는 C++ 캐스트**를 사용.

---

## 헤더/링키지/ODR/네임스페이스/모듈

- **ODR(One Definition Rule)**: 같은 엔티티는 **프로그램 전체에 단 하나의 정의**. 헤더엔 선언, 소스 하나에 정의가 원칙.
- **내부 링키지**: `static` 또는 **익명 네임스페이스**로 번역 단위에 한정.
- **네임스페이스**: 이름 충돌 회피/모듈화.
- **모듈(C++20)**: 대규모 프로젝트에서 **빌드 시간을 단축**하고 **ODR 문제/매크로 누수** 최소화.

```cpp
// header.hpp
#pragma once

namespace app { void run(); }

// header.cpp
#include "header.hpp"
#include <iostream>

namespace app { void run(){ std::cout<<"run\n"; } }
```

**모듈 스케치**
```cpp
// math.ixx
export module math;
export int add(int a, int b){ return a+b; }
```

---

## 값 범주와 이동语义

- **lvalue**: 이름이 있고 주소를 취할 수 있는 것.
- **xvalue/rvalue**: 임시/소모될 값.
- **이동语义**: 리소스를 “복사” 대신 “이전”하여 비용 절감.

```cpp
#include <string>
#include <vector>

std::vector<std::string> make(){
    std::vector<std::string> v;
    v.emplace_back("large payload");
    return v; // NRVO + move
}

int main(){
    auto v = make(); // 이동(복사 억제)
}
```

- `std::move(x)`는 **“이동 대상으로 캐스트”** (실제 이동은 해당 타입의 move ctor/assign이 결정).

---

## RAII & 스마트 포인터

**RAII(Resource Acquisition Is Initialization)**: 객체 수명과 자원 수명 동기화.

| 스마트 포인터 | 소유권 | 사용 |
|---|---|---|
| `std::unique_ptr<T>` | 단일 소유 | 가장 기본. 팩토리 함수에서 반환 |
| `std::shared_ptr<T>` | 참조 카운트 | 공유 소유, 사이클 주의 |
| `std::weak_ptr<T>` | 비소유 관찰자 | 순환 참조 끊기/상태 확인 |

```cpp
#include <memory>

std::unique_ptr<int> make_int(){
    return std::make_unique<int>(42);
}
```

**규칙**: **Rule of Zero/Three/Five**
- 자원 직접 관리 대신 컨테이너/스마트 포인터 사용 → **Rule of Zero**를 지향.

---

## 오류 처리 전략

### 예외

```cpp
int f(){
    if(/*error*/) throw std::runtime_error("fail");
    return 0;
}

int main(){
    try { f(); }
    catch(const std::exception& e){ /*복구/로그*/ }
}
```

- 성능·예측 가능성·API 철학에 따라 **예외를 끄고** (game/low-latency) **리턴 타입 기반** 처리(`std::optional`/`expected`류)도 대안.
- 함수를 `noexcept`로 지정하면 스택 언와인딩 비용 예측/최적화 가능.

---

## 컨테이너/이터레이터/알고리즘 (STL 핵심)

자주 쓰는 컨테이너 선택 가이드:

| 목적 | 추천 |
|---|---|
| 동적 배열, 캐시 친화 | `std::vector` |
| 키-값 정렬 트리 | `std::map`/`std::set` |
| 키-값 해시 | `std::unordered_map`/`set` |
| 양끝 삽입/삭제 | `std::deque` |
| 엄격 불변, 보기 전용 | `std::span` (뷰) |

### 알고리즘은 “**컨테이너보다 알고리즘을 먼저 떠올리자**”

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main(){
    std::vector<int> v{1,2,3,4,5,6};
    v.erase(std::remove_if(v.begin(), v.end(), [](int x){return x%2==0;}), v.end()); // 홀수만
    std::for_each(v.begin(), v.end(), [](int x){ std::cout<<x<<" "; });
}
```

**복잡도 표기 예시**
$$
\text{std::sort}:\ \mathcal{O}(n\log n),\quad
\text{std::find}:\ \mathcal{O}(n)
$$

---

## Ranges, `span`, 구조적 바인딩, `constexpr`

```cpp
#include <ranges>
#include <vector>
#include <iostream>

int main(){
    std::vector<int> v{1,2,3,4,5,6};
    for(int x : v | std::views::filter([](int x){return x%2;})
                  | std::views::transform([](int x){return x*x;})){
        std::cout << x << " "; // 1 9 25
    }
}
```

```cpp
#include <array>
#include <span>

void print(std::span<const int> s){
    for(int x : s) std::cout<<x<<" ";
}

int main(){
    std::array<int,4> a{1,2,3,4};
    print(a);
}
```

- `constexpr`로 **컴파일 타임 계산**을 적극 활용.

---

## 템플릿·SFINAE·컨셉(Concepts)

### 기본 템플릿

```cpp
template<typename T>
T add(T a, T b){ return a+b; }
```

### 컨셉(C++20)

```cpp
#include <concepts>

template<std::integral I>
I sum(I a, I b){ return a+b; } // 정수형에만 허용
```

- **컨셉**은 제약을 명시해 에러 메시지를 단순화하고 오용을 방지.

---

## 입출력 & 파일시스템

- 간단 출력: iostream
- 포맷팅 가독성/성능: `<format>` (C++20)
- 파일/디렉토리: `std::filesystem`

```cpp
#include <filesystem>
#include <iostream>

namespace fs = std::filesystem;

int main(){
    for(auto& p : fs::directory_iterator(".")){
        std::cout << p.path().string() << "\n";
    }
}
```

---

## 시간/동시성: `chrono`, `thread`, `mutex`, 병렬 알고리즘

```cpp
#include <thread>
#include <mutex>
#include <vector>
#include <iostream>

int main(){
    int counter{};
    std::mutex m;
    std::vector<std::thread> ts;

    for(int i=0;i<4;++i){
        ts.emplace_back([&]{
            for(int k=0;k<100000;++k){
                std::scoped_lock lock(m);
                ++counter;
            }
        });
    }
    for(auto& t: ts) t.join();
    std::cout << counter << "\n"; // 400000
}
```

- **병렬 알고리즘** (`<execution>`)로 데이터 병렬화:
```cpp
#include <algorithm>
#include <execution>
#include <vector>

int main(){
    std::vector<int> v(1'000'000, 1);
    std::for_each(std::execution::par, v.begin(), v.end(), [](int& x){ x*=2; });
}
```

---

## 테스트/툴링

- **컴파일러 경고 극대화**: `-Wall -Wextra -Werror -Wpedantic` (GCC/Clang), `/W4` 또는 `/Wall`(MSVC 일부 과도 경고 필터)
- **정적 분석**: clang-tidy, cppcheck
- **Sanitizer**: Address/Undefined/Thread Sanitizer
- **빌드**: CMake(표준), vcpkg/Conan(패키지)

---

## 성능/메모리 모델/정렬/엄격 별칭/UB

- **엄격 별칭(strict aliasing)**: 서로 다른 타입 포인터로 같은 객체에 접근 금지(예외: `char`/표준 레이아웃 등).
- **정렬(Alignment)**: `alignas`, `std::hardware_constructive_interference_size` 활용.
- **UB(Undefined Behavior)** 회피: 초기화/범위검사/수명규칙 준수/미정의 시맨틱 의존 금지.
- **데이터 지역성**: `std::vector` 선호(연속 메모리), SoA/인접 배치 고려.

---

## C 상호운용

- C 헤더는 C++에선 `<cstdio>`와 같은 **c-접두사** 버전 사용 권장(네임스페이스 안전).
- C 함수와 링크:
```cpp
extern "C" {
    void c_api(int);
}
```
- POD/ABI 차이에 주의(가상함수/패딩/정렬 등).

---

## 작은 종합 예제 — **Safe Plugin Loader**

> 목표: **RAII + 파일시스템 + 예외 대신 대안 리턴**을 결합한 안전한 작은 구성.
> 상황: `plugins/` 폴더에서 확장자 `.so`(리눅스)/`.dll`(윈도) 파일을 찾아 로드(개념적 의사 코드).
> 포인트: 예외를 쓰지 않는 API 표면, **소유권 명확화**, 실패 전파.

```cpp
// plugin_loader.hpp
#pragma once
#include <string>
#include <optional>
#include <vector>

struct Plugin {
    std::string name;
    // 핸들 등 실자원은 PIMPL로 숨기는 것을 권장
};

struct LoadError {
    std::string message;
};

struct LoadResult {
    std::vector<Plugin> plugins;
    std::vector<LoadError> errors; // 일부 실패 누적
};

LoadResult load_plugins(const std::string& directory);
```

```cpp
// plugin_loader.cpp
#include "plugin_loader.hpp"
#include <filesystem>
#include <utility>

namespace fs = std::filesystem;

LoadResult load_plugins(const std::string& directory){
    LoadResult r{};
    std::error_code ec;
    if(!fs::exists(directory, ec)){
        r.errors.push_back({"directory not found: " + directory});
        return r;
    }
    for(auto& entry : fs::directory_iterator(directory, ec)){
        if(ec){ r.errors.push_back({"iter error: "+ec.message()}); break; }
        const auto& p = entry.path();
#if defined(_WIN32)

        const bool is_plugin = p.extension()==".dll";
#else

        const bool is_plugin = p.extension()==".so";
#endif

        if(!is_plugin) continue;

        // 실제 로드 대신 성공했다고 가정한 mock:
        r.plugins.push_back(Plugin{p.filename().string()});
        // 실패라면: r.errors.push_back({"failed to load: " + p.string()});
    }
    return r;
}
```

```cpp
// main.cpp
#include "plugin_loader.hpp"
#include <iostream>

int main(){
    auto res = load_plugins("./plugins");
    for(auto& p : res.plugins) std::cout << "Loaded: " << p.name << "\n";
    for(auto& e : res.errors)  std::cerr << "Error : " << e.message << "\n";
}
```

**해설**
- **예외 대신** “결과 + 에러 목록”을 반환 → 호출자가 **정책 결정**(로그, 재시도, 무시).
- 실제 환경에선 **플랫폼별 동적 로더**(`LoadLibrary`/`dlopen`)를 **RAII 래퍼 클래스로 감싸기**.

---

## 체크리스트 요약

- [ ] C 스타일 캐스트 지양 → `static_cast` 등 사용
- [ ] 원시 포인터 소유 금지 → `unique_ptr`/`shared_ptr`
- [ ] 값 반환 선호 (RVO/Move)
- [ ] 예외 정책 문서화(사용/불사용, 경계 정의)
- [ ] 컨테이너 선택 기준 명확화 (`vector` 우선)
- [ ] 알고리즘 우선 접근 (remove-erase 관용구 등)
- [ ] 동시성: `scoped_lock`, 데이터 경합 테스트, TSAN
- [ ] 정적분석/경고최대/Sanitizer로 안전망 구축
- [ ] 모듈/컨셉/Ranges 등 현대 기능 점진 도입
- [ ] C 상호운용부는 ABI/정렬/호출규약 명시

---

# 부록 A. 네임스페이스와 스코프 (보강 예제)

```cpp
#include <iostream>

int value = 0; // 전역

namespace A { int value = 1; }
namespace B { int value = 2; }

int main(){
    int value = 100; // 지역
    std::cout << value    << "\n"; // 100
    std::cout << ::value  << "\n"; // 0
    std::cout << A::value << "\n"; // 1
    std::cout << B::value << "\n"; // 2
}
```

---

# 부록 B. 조건문/반복문/함수 (기본 복습)

```cpp
#include <iostream>

int main(){
    int age = 20;
    if(age >= 18) std::cout << "성인\n";
    else          std::cout << "미성년\n";

    for(int i=0;i<5;++i) std::cout<<i<<" ";

    return 0;
}
```

```cpp
#include <iostream>

void say(){ std::cout<<"안녕하세요!\n"; }
int main(){ say(); }
```

---

# 부록 C. iostream vs `<cstdio>` 간단 비교

| 항목 | iostream | `<cstdio>` |
|---|---|---|
| 타입 안전 | 높음(오버로드) | 낮음(포맷 문자열 의존) |
| 현지화 | 강함 | 보통 |
| 성능 | 상황따라 다름 (동기화 해제 `ios::sync_with_stdio(false)`) | 간단 포맷에서 종종 빠름 |
| 포맷 | 스트림/`<format>` | `printf` 패턴 |

---

# 부록 D. 컴파일/빌드 스니펫

```bash
# g++ 예시

g++ -std=c++20 -O2 -Wall -Wextra -Werror -fsanitize=address,undefined main.cpp -o app
```

```cmake
# CMakeLists.txt (요지)

cmake_minimum_required(VERSION 3.22)
project(app LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 20)
add_executable(app main.cpp)
target_compile_options(app PRIVATE -Wall -Wextra -Wpedantic)
```

---

# 결론

- C++는 C의 장점을 보존하면서 **안전성과 추상화 도구**를 제공해 **복잡한 시스템을 더 견고하게** 만들 수 있습니다.
- 핵심은 **소유권(Ownership)**, **수명(Lifetime)**, **예외/오류 정책**, **알고리즘 우선 사고**입니다.
- 본 확장판을 기반으로 **템플릿 메타프로그래밍, 코루틴, 네트워킹(TS), GPU/SIMD** 등으로 확장 학습을 이어가면 실전 역량을 빠르게 끌어올릴 수 있습니다.
