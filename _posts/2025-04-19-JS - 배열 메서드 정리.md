---
layout: post
title: JavaScript - 배열 메서드 정리
date: 2025-04-19 20:20:23 +0900
category: JavaScript
---
# 배열 메서드 총정리

## 0) 공통 사전 지식

### 0.1 콜백 시그니처(공통)
```js
arr.method((value, index, array) => { /* ... */ }, thisArg?);
```
- `value`: 현재 요소 값
- `index`: 현재 인덱스
- `array`: 원본 배열(참조)
- `thisArg`: 콜백 내부 `this`로 바인딩할 값(화살표 함수는 무시됨)

### 0.2 희소 배열(holes)과 순회
- `map/filter/reduce/forEach/find/some/every`는 **존재하는 인덱스만** 순회한다.  
  즉, `[, 2, , 4]`에서 비어 있는 슬롯은 건너뛴다(값이 `undefined`로 설정된 경우와 다름).
- 단, `reduce`는 **초기값 없이** 시작할 때 “첫 **존재하는** 요소”를 초기 누산값으로 사용.

```js
const a = [,2,,4];
a.map(x => x);           // [ <1 empty item>, 2, <1 empty item>, 4 ]
a.filter(Boolean);       // [2, 4]
a.forEach(console.log);  // index 1 → 2, index 3 → 4 만 호출
```

### 0.3 원본 불변 여부
- 7개 모두 **원본 배열을 변경하지 않는다.**  
  다만 **콜백 내부에서 원본을 변경**하면 그 변경은 **이후 순회에 반영될 수 있음**(권장 X).

---

## 1) `forEach` — 단순 반복(반환값 없음, 중단 불가)

### 1.1 정의/반환
- 반환: `undefined`
- **중간 종료 불가**(`break`/`return`으로 탈출 못함)

```js
[1,2,3].forEach((v,i)=>{ console.log(i, v); });
// 0 1, 1 2, 2 3
```

### 1.2 사용처
- **사이드 이펙트** 목적(로그, DOM 조작, 외부 상태 변경)
- 결과를 생성하려면 `map/filter/reduce`를 택하라.

### 1.3 대안
- 중간 종료 필요: 전통 `for`/`for...of`/`some`/`find`.

---

## 2) `map` — 변환(동형 매핑, 새 배열 반환)

### 2.1 정의/반환
- 각 요소를 변환하여 **동일 길이**의 새 배열 반환(holes는 유지)

```js
const nums = [1, 2, 3];
const doubled = nums.map(n => n * 2); // [2, 4, 6]
```

### 2.2 실전 패턴
- **속성 추출**
```js
const names = users.map(u => u.name);
```
- **인덱스 병용**
```js
const labeled = nums.map((n,i)=> `${i}:${n}`);
```
- **안전 변환(널 가드)**
```js
const titles = posts.map(p => p?.title ?? "(untitled)");
```

### 2.3 흔한 함정
- `map`에서 **조건 분기 후 `undefined`가 잔뜩** 생기면 `filter`+`map` 분리 또는 `flatMap` 고려.
```js
// 안좋은 예
const r = xs.map(x => x.ok ? x.val : undefined);
// 대안
const r2 = xs.filter(x=>x.ok).map(x=>x.val);
```

---

## 3) `filter` — 선별(조건 통과 요소만, 새 배열 반환)

### 3.1 정의/반환
- 콜백이 truthy인 요소만 남김. 길이는 **같거나 줄어든다**.

```js
const even = [1,2,3,4,5].filter(n => n % 2 === 0); // [2,4]
```

### 3.2 실전 패턴
- **안전성 검사/검증**
```js
const valid = items.filter(x => x != null && x.id != null);
```
- **중복 제거(간단)**
```js
const dedup = arr.filter((v,i,a) => a.indexOf(v) === i);
```

### 3.3 성능 팁
- 조건이 무거우면 **사전 캐싱**하거나 필터 조건을 여러 번 쓰지 않도록 추출.

---

## 4) `reduce` — 누산(단일 값/객체/배열/Map 등 생성)

### 4.1 정의/반환
```js
arr.reduce((acc, cur, idx, arr) => nextAcc, initialAcc?);
```
- 초기값 미제공 시: 첫 **존재 요소**가 `acc`, 순회는 그 다음 인덱스부터.

### 4.2 총합/평균/최댓값
```js
const sum = [1,2,3,4].reduce((a,c)=>a+c, 0);        // 10
const avg = [10,20,30].reduce((a,c,_,arr)=>a+c/arr.length, 0); // 20
const max = nums.reduce((m,c)=> c>m?c:m, -Infinity);
```

### 4.3 그룹화/인덱싱(색인 만들기)
```js
const items = [
  { type: "fruit", name: "apple" },
  { type: "vegetable", name: "carrot" },
  { type: "fruit", name: "banana" }
];

// 그룹화 → { fruit:[...], vegetable:[...] }
const grouped = items.reduce((acc, it) => {
  (acc[it.type] ??= []).push(it.name);
  return acc;
}, {});

// 키로 인덱스 맵 → { apple:{...}, carrot:{...}, ... }
const byName = items.reduce((acc, it) => (acc[it.name]=it, acc), {});
```

### 4.4 다중 누산(여러 통계 동시에)
```js
const stats = [1,2,3,4,5].reduce((s,x)=>({
  count: s.count+1,
  sum:   s.sum+x,
  min:   Math.min(s.min, x),
  max:   Math.max(s.max, x)
}), {count:0, sum:0, min:Infinity, max:-Infinity});
```

### 4.5 불변 업데이트(배열/객체 생성)
```js
const ids   = items.reduce((a,x)=> (a.push(x.id), a), []);
const flags = items.reduce((a,x)=> ({...a, [x.id]:true}), {});
```

### 4.6 고급: 체이닝 대체(한 번만 순회)
- `filter(...).map(...)`처럼 **여러 번 순회**하는 대신, `reduce`로 **단일 패스**.
```js
const out = xs.reduce((a,x)=>{
  if (!x.ok) return a;
  a.push(x.val * 2);
  return a;
}, []);
```
> 가독성과 성능을 **상황에 맞게** 선택(읽기 쉬운 체이닝 vs 단일 패스).

### 4.7 흔한 함정
- **초기값 생략**으로 빈 배열에 `reduce` 호출 시 TypeError.
```js
[].reduce((a,c)=>a+c); // TypeError
```

---

## 5) `find` — 조건을 만족하는 **첫 요소** 반환(없으면 `undefined`)

### 5.1 정의/반환/중단
- **첫 매칭 시 즉시 종료**(성능상 이점)
```js
const found = users.find(u => u.id === 2);
```

### 5.2 변형/보조
- 인덱스 필요: `findIndex`
- 뒤에서부터: `findLast`/`findLastIndex`(지원 환경에 따라)

### 5.3 실전
```js
const user = users.find(u => u.email?.endsWith("@example.com"));
if (!user) { /* graceful fallback */ }
```

---

## 6) `some` — 하나라도 조건 통과? (단락 평가)

### 6.1 정의/반환/중단
- **매칭 발견 즉시 `true`** 반환, 나머지 검사하지 않음.

```js
const hasAdult = [13,15,22].some(age => age >= 18); // true
```

### 6.2 실전
- **권한 검사/특정 속성 보유** 여부 체크
```js
const allowed = roles.some(r => r === "admin" || r === "owner");
```

---

## 7) `every` — 모두 조건 통과? (단락 평가)

### 7.1 정의/반환/중단
- **하나라도 실패하면 즉시 `false`**, 전부 통과 시 `true`.

```js
const allAdult = [20,21,25].every(age => age >= 18); // true
```

### 7.2 실전
- **입력 유효성** 일괄 검사, 폼 필드 전부 통과?
```js
const ok = fields.every(f => f.value?.trim().length > 0);
```

---

## 8) 체이닝(연쇄) vs 단일 패스 — 선택 가이드

### 8.1 가독성 우선(권장)
```js
const result = items
  .filter(x => x.enabled)
  .map(x => ({ id: x.id, size: x.size * 2 }))
  .find(x => x.size > 100);
```

### 8.2 단일 패스(성능/대용량)
```js
const result2 = items.reduce((acc,x)=>{
  if (!x.enabled) return acc;
  const transformed = { id: x.id, size: x.size * 2 };
  if (!acc && transformed.size > 100) return transformed; // 첫 매칭 저장
  return acc;
}, null);
```
> 프로파일링으로 병목을 확인하고 선택하자. 대부분의 프런트엔드/일반 규모에서는 **체이닝 가독성**이 더 큰 이득이다.

---

## 9) thisArg — 문맥 바인딩

```js
const ctx = { mul: 10 };
const out = [1,2,3].map(function(v){ return v * this.mul; }, ctx);
console.log(out); // [10,20,30]
```
- 화살표 함수는 렉시컬 `this`이므로 `thisArg`가 무시된다.

---

## 10) 실전 레시피 모음

### 10.1 빈도수(히스토그램)
```js
const hist = words.reduce((acc,w)=> (acc[w]=(acc[w]??0)+1, acc), {});
```

### 10.2 태그 기반 역색인
```js
const posts = [
  { id:1, tags:["js","web"] },
  { id:2, tags:["js","node"] },
  { id:3, tags:["web"] },
];
const indexByTag = posts.reduce((acc,p)=>{
  p.tags.forEach(tag => (acc[tag] ??= []).push(p.id));
  return acc;
}, {});
```

### 10.3 평탄화(`flatMap` 대체)
```js
const nested = [[1,2],[3],[4,5]];
const flat = nested.reduce((a,x)=> (a.push(...x), a), []);
```

### 10.4 안전 파싱 + 필터 + 집계
```js
const logs = ["42","x","7","-1"];
const sumPos = logs
  .map(s => Number(s))
  .filter(n => Number.isFinite(n) && n>0)
  .reduce((a,c)=>a+c, 0); // 49
```

### 10.5 폼 검증(메시지 수집)
```js
const fields = [
  { key:"email",  value:"a@b.com", rule:v=>v.includes("@") },
  { key:"age",    value:"17",      rule:v=>+v>=18 }
];
const errors = fields
  .filter(f => !f.rule(f.value))
  .map(f => `${f.key} invalid`);
```

### 10.6 첫 유효값 탐색(`find`)
```js
const providers = [
  () => null,
  () => ({token:"abc"}),
  () => ({token:"zzz"})
];
const token = providers.map(fn=>fn()).find(v=>v?.token)?.token;
```

### 10.7 일부 충족 검사(`some`) / 전부 검사(`every`)
```js
const hasLarge  = arr.some(n => n>1000);
const allNumber = arr.every(n => typeof n === "number");
```

---

## 11) 흔한 함정과 회피

1. **`forEach` 중단 불가** → 중단 필요 시 `for...of`/`some`/`find`.
2. **`reduce` 초기값 미지정 + 빈 배열** → TypeError. 초기값을 주자.
3. **희소 배열 기대와 다름**: holes는 순회되지 않는다.  
   필요 시 `Array.from(arr)` 등으로 명시적 채우기/정제.
4. **콜백에서 원본 수정**은 예측 어려운 버그 유발(특히 동시 체이닝).
5. **객체 비교/중복 제거** 시 `indexOf`/`includes`는 레퍼런스 비교임에 주의(깊은 비교 아님).
6. **thisArg + 화살표**: 화살표는 `thisArg` 무시 → 일반 함수 쓰기.

---

## 12) 성능·가독성 체크리스트

- [ ] 데이터가 **매우 크고** 체이닝 단계가 많나? → 단일 패스 `reduce` 고려.
- [ ] 사이드 이펙트만? → `forEach`(그러나 중단 필요하면 `for...of`).
- [ ] **변환**이면 `map`, **선별**이면 `filter`, **검색**이면 `find`, **존재 검사**면 `some/every`.
- [ ] **불변성** 유지: 결과는 새 구조로 만들고 원본 수정 금지.
- [ ] **희소 배열** 정제 필요 시 `Array.from`/`flat`/명시 초기화.

---

## 13) 미니 퀴즈

```js
// Q1: 결과는?
[1,2,3].forEach((v,i,arr) => { if (v===2) return; console.log(v); });

// Q2: 아래 두 결과의 차이는?
[1,2,3,4].filter(n => n%2).map(n => n*10);
[1,2,3,4].reduce((a,n)=> (n%2 && a.push(n*10), a), []);

// Q3: TypeError가 나는 코드를 고쳐라.
// [].reduce((a,c)=>a+c);

// Q4: holes 처리
const a = [,2,,4];
a.map(x=>x);       // 결과 배열 모양은?

// Q5: 첫 매칭 검색(뒤에서부터)을 한 줄로(환경이 최신이라면)
const idx = [1,3,7,3].findLastIndex(n => n===3);
```

**해설 힌트**  
- Q1: `return`은 콜백만 종료, 루프는 계속 → 1, 3 출력.  
- Q2: 1) 두 번 순회(가독성↑), 2) 한 번 순회(성능 이점 가능). 결과 동일: `[10,30]`.  
- Q3: 초기값 제공: `[].reduce((a,c)=>a+c, 0)`.  
- Q4: `[ <1 empty item>, 2, <1 empty item>, 4 ]` — holes 유지.  
- Q5: `findLastIndex`/`findLast`가 있으면 그대로 사용.

---

## 14) 빠른 레퍼런스 표(확장)

| 메서드    | 반환                | 중단 | 희소 배열 | 원본 변경 | 주 용도 |
|-----------|---------------------|------|-----------|-----------|--------|
| `forEach` | `undefined`         | X    | 건너뜀    | X         | 부수 효과(로그, DOM) |
| `map`     | 새 배열(동일 길이)  | X    | 유지      | X         | 변환/투영 |
| `filter`  | 새 배열(부분집합)   | X    | 건너뜀    | X         | 선별 |
| `reduce`  | 단일 값/구조        | X    | 건너뜀    | X         | 누산/집계/구조 생성 |
| `find`    | 요소/`undefined`    | O    | 건너뜀    | X         | 첫 매칭 검색 |
| `some`    | `true/false`        | O    | 건너뜀    | X         | 하나라도? |
| `every`   | `true/false`        | O    | 건너뜀    | X         | 모두? |

---

## 15) 결론

배열 고차 함수는 **짧고 선언적인 데이터 파이프라인**을 만든다.  
- 변환/선별/누산/검색/검증의 역할을 **명확히 분리**하고,  
- **희소 배열 규칙**과 **중단 조건**, **초기값**을 정확히 이해하며,  
- 상황에 따라 **가독성(체이닝)** vs **성능(단일 패스)**를 선택하라.  

이 가이드의 패턴을 코드베이스에 점진 도입하면, **버그 가능성↓**, **유지보수성↑**, **성능 고려의 자유도↑**를 동시에 얻을 수 있다.