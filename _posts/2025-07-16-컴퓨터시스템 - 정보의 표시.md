---
layout: post
title: 컴퓨터시스템 - 정보의 표시
date: 2025-07-16 21:20:23 +0900
category: 컴퓨터시스템
---
# 정보의 표시: 비트는 어떻게 의미를 갖는가?

컴퓨터는 모든 데이터를 0과 1로 저장하지만, **단순한 비트 나열만으로는 의미를 전달할 수 없다.**  
우리가 읽는 숫자, 문자, 소수점, 음수 등은 **비트를 해석하는 규칙**에 따라 각각 다른 의미를 가진다.  
이 글에서는 "정보의 표시"라는 관점에서 **정수, 부호, 실수, 문자** 등이 어떻게 비트로부터 나타나는지를 살펴본다.

---

## 1. 정수(integer)의 표현

컴퓨터는 고정된 수의 비트를 사용해 정수를 저장한다.  
가장 단순한 방법은 **양의 정수의 이진 표현**이다.

### 예: 8비트 정수 (unsigned)
| 십진수 | 이진수 |
|--------|--------|
| 0      | 00000000 |
| 1      | 00000001 |
| 255    | 11111111 |

### 표현 범위
- **n비트 unsigned** 정수는 \( 0 \)부터 \( 2^n - 1 \)까지 표현 가능

---

## 2. 부호 있는 정수: 2의 보수 표현

음수를 표현하려면, 단순 이진수만으로는 부족하다.  
컴퓨터는 **2의 보수(Two's Complement)**라는 방법으로 부호를 표현한다.

### 원리
- 가장 왼쪽 비트(MSB)를 **부호 비트**로 사용
  - `0`: 양수, `1`: 음수
- 음수는 \( 2^n - |x| \)로 표현됨

### 예: 8비트에서 -5 표현
1. +5 → `00000101`  
2. 반전 → `11111010`  
3. +1 → `11111011` (== -5)

| 십진수 | 이진수 (8비트 2의 보수) |
|--------|-------------------------|
| 5      | 00000101 |
| -5     | 11111011 |

### 표현 범위
- **n비트 signed** 정수는 \( -2^{n-1} \) ~ \( 2^{n-1} - 1 \) 까지 표현 가능  
  예: 8비트 → -128 ~ 127

---

## 3. 부동소수점(Floating Point) 표현

정수 표현만으로는 실수(소수점)가 불가능하다.  
이를 위해 컴퓨터는 **IEEE 754 부동소수점 표준**을 사용한다.

### 예: 32비트 float 구성

| 비트수 | 용도 | 설명 |
|--------|------|------|
| 1비트  | 부호비트 | 0(양수), 1(음수) |
| 8비트  | 지수 | \( E \), 실제 지수는 \( e = E - 127 \) |
| 23비트 | 가수 | 1.f 형태로 표현됨 |

### 수식 표현

\[
x = (-1)^s \times 1.f \times 2^{e}
\]

예: `1.25` →  
- 이진: `1.01`  
- 지수: \( e = 0 \) → \( E = 127 \) → `01111111`  
- 가수: `01000000000000000000000`

결과: `0 01111111 01000000000000000000000`

---

## 4. 문자와 문자열의 표현

문자도 비트로 저장된다. 대표적으로 **ASCII**와 **UTF-8**이 있다.

### ASCII (7비트 또는 8비트)
| 문자 | 코드 | 이진수 |
|------|------|--------|
| A    | 65   | 01000001 |
| a    | 97   | 01100001 |
| 0    | 48   | 00110000 |

### UTF-8
- 유니코드 문자 표현 방식 (가변 길이)
- ASCII 문자와 호환
- 한글, 이모지 등도 표현 가능  
  예: '가' → UTF-8: `0xEA B0 80`

---

## 5. 논리형(Boolean)의 표현

논리값 `True`, `False`는 일반적으로 1비트로 표현되지만, 실제 저장 시는 1바이트로 처리되는 경우가 많다.

- False → `00000000` (0)
- True → `00000001` 또는 `00000010` 등 (0이 아니면 모두 True로 해석하는 경우도 있음)

---

## 6. 열거형(Enum), 포인터, 주소 등

### 열거형(Enum)
- 내부적으로는 정수로 매핑됨
```c
enum Color { RED = 0, GREEN = 1, BLUE = 2 };
```

### 포인터
- 메모리 주소를 나타냄
- 32비트 시스템: 4바이트, 64비트 시스템: 8바이트  
  예: 주소 `0x00400000` → 이진수로 저장됨

---

## 7. 요약: 비트의 해석은 문맥(Context)에 따라 달라진다

같은 4바이트 데이터라도 해석 방식이 다르면 전혀 다른 의미를 가진다:

| 데이터 (16진수) | 해석 방법 | 의미 |
|-----------------|-----------|------|
| `0x3F800000` | float | `1.0` |
| `0x3F800000` | 정수 | `1,060,110,336` |
| `0x3F800000` | 문자 | 의미 없음 |

**즉, 비트는 저장된 그 자체로는 아무 의미가 없다.**  
그 **해석 규칙**, 즉 **표현 방식**이 주어져야만 데이터로서 의미를 가진다.

---

## 마무리

정보의 "표시"는 **비트를 해석하는 방식의 문제**다.  
이진수의 구조, 부호 유무, 실수 표현, 문자 인코딩, 그리고 포인터와 주소까지…  
이해 없이 다룬다면 오류와 혼란이 생기고, 구조를 이해하면 **디버깅, 성능 최적화, 시스템 설계**에 강력한 무기가 된다.

비트는 언어가 아니지만, 해석하는 순간 의미를 갖는다.  
그 해석의 문법이 바로 "정보의 표시"다.