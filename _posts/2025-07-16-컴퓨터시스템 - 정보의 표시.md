---
layout: post
title: 컴퓨터시스템 - 정보의 표시
date: 2025-07-16 21:20:23 +0900
category: 컴퓨터시스템
---
# 정보의 표시: 비트는 어떻게 의미를 갖는가?

## = 의미”

비트는 그 자체로 **무의미한 패턴**이다. 의미는 **해석 규칙**(표현 형식, 부호 규약, 스케일, 문자집합, 엔디안 등)을 합성할 때 생성된다.
이 글은 아래의 8가지 표현 층위를 통해 **비트→의미**를 추적한다.

1. **정수(부호 없음)**: 자리값·범위·오버플로(모듈러)
2. **부호 있는 정수(2의 보수)**: 범위·부호확장·오버플로 주의
3. **부동소수점(IEEE 754)**: 정규/서브노멀/±0/∞/NaN/반올림/ULP
4. **고정소수점(Q 형식)**: 정밀도·스케일·포화
5. **문자·문자열(ASCII/UTF-8/UTF-16)**: 코드포인트·그래프·인코딩
6. **불리언**: 0/비0 컨벤션, 메모리 배치
7. **열거형·비트플래그**: 심벌↔정수, 조합 플래그
8. **포인터/주소**: “숫자지만 수학적 덧셈과 동일하지 않은” 값

마지막으로 **“같은 4바이트를 다르게 해석”**하는 실험으로 맺는다.

---

## — 자리값과 모듈러 산술

### 자리값과 범위

n비트 부호 없는 정수의 해석:

$$
\text{Value} = \sum_{i=0}^{n-1} b_i \cdot 2^i
\quad\Rightarrow\quad
\text{범위} = [0, 2^n-1]
$$

예: 8비트 → 0..255, 32비트 → 0..\(2^{32}-1\).

### 오버플로 = 모듈러 래핑

$$
(x + y) \bmod 2^n,\quad (x - y) \bmod 2^n
$$

- 하드웨어는 **하위 n비트만 남김**(캐리/보로우는 플래그 레지스터).
- C/C++에서 **부호 없는 정수의 오버플로는 정의됨**(모듈러). 반면 **부호 있는 정수는 UB**(§2.4).

```c
#include <stdint.h>
#include <stdio.h>

int main(){
    uint8_t a=250, b=20;
    uint8_t c = a + b;          // 270 → 14 (모듈러 256)
    printf("%u\n", c);          // 14
}
```

---

## — 동일한 덧셈기로 +/−을

### 정의와 범위

n비트 2의 보수:

$$
\text{Value} = -b_{n-1}\cdot 2^{n-1} + \sum_{i=0}^{n-2} b_i \cdot 2^i
\quad\Rightarrow\quad
[-2^{n-1}, 2^{n-1}-1]
$$

- 음수 생성: **비트 반전 + 1**.

### 예: 8비트에서 −5

```
+5 : 0000 0101
반전: 1111 1010
+1 : 1111 1011  ← −5
```

| 십진 | 8비트 2의 보수 |
|---:|:-------------|
| +5 | 0000 0101    |
| −5 | 1111 1011    |

### 부호 확장(Sign Extension)

좁은 폭 → 넓은 폭으로 확장 시, **최상위 비트(MSB)를 복제**:

$$
\text{sx}_{n\to m}(x) =
\begin{cases}
x, & \text{if } x \text{ 양수}\\
x + 2^m - 2^n, & \text{if } x \text{ 음수}
\end{cases}
$$

```c
#include <stdint.h>
#include <stdio.h>

int main(){
    int8_t  s8  = -1;            // 0xFF
    int32_t s32 = (int32_t)s8;   // 0xFFFFFFFF == -1
    printf("%d %d\n", s8, s32);
}
```

### 주의: C/C++ 서명 오버플로 = UB

아래는 **정의되지 않은 동작**(컴파일러 최적화가 가정 깨뜨림):

```c
int add(int a, int b){
    return a + b; // a,b가 큰 값이면 오버플로 → UB
}
```

안전이 필요하면
- 부호 없는로 계산 후 범위 검사, 또는
- 컴파일러 내장 포화/체크 함수를 사용.

---

## — 0도 ±가 있다

### 형식과 해석

| 형식 | 부호 s | 지수 e(바이어스) | 가수 f |
|---|---:|---:|---:|
| binary32(float) | 1 | 8(127)  | 23 |
| binary64(double)| 1 | 11(1023)| 52 |

정규화 수:

$$
(-1)^s \cdot (1.f)_2 \cdot 2^{(E-\text{bias})}
$$

서브노멀:

$$
(-1)^s \cdot (0.f)_2 \cdot 2^{(1-\text{bias})}
$$

특수: `E=all1, f=0 → ±∞`, `E=all1, f≠0 → NaN`.

### 반올림·연산 성질

- 기본 모드: **Round to nearest, ties to even**.
- 연산은 일반적으로 **비결합적**: \((a+b)+c \ne a+(b+c)\).
- **±0** 존재: `+0.0`, `-0.0` (부호비트만 다름). \(\frac{1}{+0} = +\infty\), \(\frac{1}{-0} = -\infty\).

```c
#include <stdint.h>
#include <stdio.h>

typedef union { float f; uint32_t u; } U;
int main(){
    U x; x.f = 0.1f;
    printf("0.1f bits = 0x%08X\n", x.u); // 이진 유한표현 불가 → 근사
}
```

### ULP·머신 엡실론

- **ULP(Unit in Last Place)**: 인접 표현 가능한 실수 간 간격.
- **ε(machine epsilon)**: \(1.0 + \epsilon \ne 1.0\)인 최소 양수(표현계).

---

## — 실수의 정수화

Q\(m.n\): 총 \(m+n\)비트 중 **정수부 m**, **소수부 n**. 저장값 \(X\)는 실제값 \(X/2^n\).

$$
\text{Real} = \frac{X}{2^n},\quad
\text{곱셈 결과} = \frac{X\_a X\_b}{2^n}
$$

```c
#include <stdint.h>

static inline int16_t q15_mul(int16_t a, int16_t b){
    int32_t t = (int32_t)a*b; // 32b
    t += 1<<14;               // 반올림
    t >>= 15;
    if(t> 32767) t= 32767;
    if(t<-32768) t=-32768;    // 포화
    return (int16_t)t;
}
```

- 장점: **결정적**, 빠른 정수연산.
- 단점: 범위/정밀도 설계 필요(스케일 관리).

---

## 문자·문자열 — 코드포인트와 그래프는 다르다

### ASCII와 UTF-8, UTF-16

| 인코딩 | 단위 | 특징 | 주의 |
|---|---|---|---|
| ASCII | 7비트 | 영문·제어 문자 | 제한적 |
| UTF-8 | 1~4B 가변 | ASCII 호환, 웹 표준 | **문자 길이≠바이트 길이** |
| UTF-16 | 2/4B | BMP 2B, 보조평면 서러게이트 | 엔디안/BOM/조합문자 |

UTF-8 바이트 패턴(요약):

| 코드포인트 범위 | 바이트 수 | 패턴(2진) |
|---|---:|---|
| U+0000..007F | 1 | 0xxxxxxx |
| U+0080..07FF | 2 | 110xxxxx 10xxxxxx |
| U+0800..FFFF | 3 | 1110xxxx 10xxxxxx 10xxxxxx |
| U+10000..10FFFF | 4 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

```python
s = "A가á"  # 'a' + 결합 악센트
print("codepoints:", len(s))
print("utf8 bytes:", len(s.encode("utf-8")))
# 수는 또 다를 수 있음

```

- “문자 슬라이스”는 **코드포인트** 또는 **그래프 클러스터** 단위 라이브러리를 사용.

---

## — 저장은 1비트, 정렬은 1바이트

- 이론상 1비트면 충분. 실제 메모리에서는 **정렬/편의** 때문에 보통 **1바이트** 이상.
- 많은 API에서 **0=거짓, 비0=참** 컨벤션.

```c
#include <stdbool.h>

bool ok = 5;        // 비0 → true
printf("%d\n", ok); // 1
```

---

## 열거형·비트플래그 — 기호적 정수와 조합

### 열거형(Enum)

```c
enum Color { RED=0, GREEN=1, BLUE=2 };
enum Color c = GREEN; // 내부 표현은 정수
```

### 비트플래그(집합)

```c
enum Perm { R=1<<0, W=1<<1, X=1<<2 };
unsigned p = R|W;                 // {R,W}
int canx = (p & X) != 0;          // 테스트
p &= ~W;                          // W 해제
```

- **여러 상태 조합**에 적합, 공간·연산 효율 높음.

---

## 포인터/주소 — “숫자” 같지만 다른 의미론

- 32비트 시스템: 4바이트, 64비트: 8바이트.
- **산술**은 타입 크기 기반(예: `int* p; p+1`은 바이트 +4/8이 아님).
- 숫자로 캐스팅해 덧셈하는 것은 **의미론적으로 다름**(UB/정렬 문제 가능).

```c
#include <stdint.h>
#include <stdio.h>

int main(){
    int x=42; int* p=&x;
    uintptr_t addr = (uintptr_t)p;   // 수치화
    printf("addr=0x%zx\n", (size_t)addr);
}
```

---

## 엔디안과 재해석 — “같은 4바이트”의 다중 의미

### 예시 비트열: `0x3F800000`

| 해석 | 결과 |
|---|---|
| **float**(IEEE 754) | `1.0` |
| **부호 없는 32b 정수** | `1060110336` |
| **문자 4개(ASCII)** | `?` `\x80` `\x00` `\x00` (의미 없음) |

- **의미는 해석 규칙**에 의해 부여된다.

### 안전한 타입 재해석(별칭 문제 회피)

C에서 유니온 기반 별칭은 구현의존. **`memcpy`를 이용**하면 표준적으로 안전.

```c
#include <stdint.h>
#include <string.h>
#include <stdio.h>

int main(){
    uint32_t u = 0x3F800000u;
    float f;
    memcpy(&f, &u, sizeof f);  // 안전한 재해석
    printf("as uint=%u, as float=%f\n", u, f); // 1060110336, 1.000000
}
```

---

## 숫자 표현의 대안들 — 부호/지수의 다른 선택지

### 부호/크기(Sign-Magnitude), 1의 보수(One’s Complement)

- **Sign-Magnitude**: MSB는 부호, 나머지 절대값(장점: 대칭, 단점: ±0 존재, 덧셈 회로 복잡).
- **1의 보수**: 음수 = 반전(장점: 간단, 단점: ±0, 보정 필요).
- 2의 보수가 오늘날 **사실상 표준**.

### 지수 바이어스(Excess-N)

- IEEE 754의 지수는 **바이어스**를 더해 저장(예: binary32의 bias=127).
- 역사적으로 **Excess-127/1023** 등 용어로도 등장.

### 십진 부동소수점(Decimal Float)·BCD

- 금융/회계에서는 **십진 정확도**가 중요 → **BCD/Decimal128** 등 채택.
- 이 글의 초점은 이진 표현이지만, “해석 규칙”의 다양성 사례로 언급.

---

## 실험: ‘표시’가 바뀌면 결과가 달라진다

### 같은 바이트, 다른 의미(파이썬)

```python
import struct
raw = bytes.fromhex("3F800000")
u = struct.unpack(">I", raw)[0]      # big-endian 32b uint
f = struct.unpack(">f", raw)[0]      # big-endian float
print(u, f)                          # 1060110336 1.0
```

### 부동소수점의 비결합성을 눈으로

```python
xs = [1e-10]*1_000_000 + [1.0]
s1 = sum(xs)                     # (많은 작은 것)→큰 것
s2 = 1.0 + sum([1e-10]*1_000_000) # 큰 것→(많은 작은 것)
print(s1, s2)                    # 보통 서로 약간 다름
```

- **반올림 순서**가 결과를 바꾼다.

---

## 디버깅 체크리스트 — 표시·해석 관련 버그를 막는 법

1. **비트 폭과 범위**를 명시(문서·코드 코멘트).
2. **부호 있는 오버플로 금지**: 부호 없는로 연산 후 검사/포화.
3. **엔디안 표기**: 파일/네트워크 포맷에 *반드시* “big/little” 명시.
4. **정렬/패딩 고려**: `#pragma pack` 남용 금지, 필요 시 **수동 직렬화**.
5. **부동 비교**: 허용 오차/ULP, 또는 정규화된 비교 함수.
6. **문자열**: UTF-8 권장, “문자 길이≠바이트 길이”; 슬라이스는 코드포인트/그래프 기준 API 사용.
7. **재해석**: 유니온 별칭 대신 **`memcpy`/전용 API** 사용.
8. **포인터 수치화 자제**: 표준이 허용한 연산 범위 내에서만.

---

## 표/도해 모음

### 8비트 정수 표현 범위

| 형식 | 최소 | 최대 |
|---|---:|---:|
| Unsigned | 0 | 255 |
| 2’s Complement | −128 | 127 |

### IEEE 754 binary32 배치

```
s eeeeeeee fffffffffffffffffffffff
0 1......8 9.....................31  (총 32비트)
```

값:
$$
(-1)^s \times
\begin{cases}
(1.f)_2 \cdot 2^{E-127}, & 0<E<255 \\
(0.f)_2 \cdot 2^{-126},  & E=0 \ (\text{subnormal})\\
\infty/\text{NaN},       & E=255
\end{cases}
$$

### UTF-8 인코딩 패턴(요약 재현)

| 범위 | 바이트 | 패턴 |
|---|---:|---|
| U+0000..007F | 1 | 0xxxxxxx |
| U+0080..07FF | 2 | 110xxxxx 10xxxxxx |
| U+0800..FFFF | 3 | 1110xxxx 10xxxxxx 10xxxxxx |
| U+10000..10FFFF | 4 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

---

## 연습 문제(자가 점검)

1) 16비트 2의 보수에서 `1000 0000 0000 0000₂`의 값은?
2) 8비트 부호 없는에서 `250 + 20`의 결과와 이유는?
3) `0xBF800000`을 **float**로 해석하면? 정수로 해석하면?
4) UTF-8에서 U+AC00(“가”)의 바이트열을 쓰고, 바이트 수를 답하라.
5) Q1.15에서 0.5×0.5의 저장·반올림·포화 후 결과는?
6) `+0.0`과 `-0.0`의 차이를 판별하는 방법을 코드로 제시하라.

---

## 부록 A — 안전한 “비트 시각화/재해석” 유틸

```c
// C: 안전한 재해석(memcpy) + 부동의 부호/지수/가수 출력
#include <stdio.h>
#include <stdint.h>
#include <string.h>

static void bits32(uint32_t u){
    for(int i=31;i>=0;i--) putchar((u>>i)&1 ? '1':'0');
}

int main(){
    uint32_t u = 0x3F800000u; // 1.0f
    float f; memcpy(&f, &u, sizeof f);
    printf("u=0x%08X, f=%f\n", u, f);
    printf("bits: "); bits32(u); puts("");
    unsigned s = (u>>31)&1, E=(u>>23)&0xFF, F=u&0x7FFFFF;
    printf("s=%u E=%u F=0x%06X\n", s, E, F);
    return 0;
}
```

```python
# Python: 바이트열을 다양한 형식으로 해석

import struct, math

raw = bytes.fromhex("BF800000")  # -1.0f
u   = struct.unpack(">I", raw)[0]
f   = struct.unpack(">f", raw)[0]
print("u=", u, "f=", f, "isnegzero=", (math.copysign(1.0, -0.0) < 0))
```

---

## 요약 — “표시는 계약이다”

- **정수**는 모듈러 산술, **2의 보수**는 자연스러운 +/−,
- **부동**은 ±0/∞/NaN/서브노멀/반올림이라는 규약,
- **문자열**은 UTF-8/UTF-16 규약,
- **불리언/열거형/플래그**는 관례와 문서,
- **포인터**는 주소라는 별도의 의미론을 갖는다.

같은 비트열도 **계약(해석 규칙)**이 달라지면 **다른 의미**가 된다.
안전하고 빠른 시스템은 **표시 규약을 명확히 문서화**하고, **코드로 검증**한다.
비트는 언어가 아니지만, **규약을 만나는 순간 언어가 된다** — 그것이 “정보의 표시”다.
