---
layout: post
title: DB 심화 - 인덱스 설계
date: 2025-11-07 23:25:23 +0900
category: DB 심화
---
# 인덱스 설계 완전정리

## 0. 공통 준비

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;  -- ALLSTATS LAST 보기
```

---

# 1. “가장 중요한 두 가지” 선택 기준

인덱스 설계는 **공식**이 아니라 **전략과 선택**입니다. 하지만 어디서 시작할지 막막하다면, 다음 **두 가지**로 출발하세요.

### 기준 ①: **핫 경로(핵심 쿼리)의 Access Path를 가장 싸게 만들 것**
- “**가장 자주 호출**되고 **가장 느리면 곤란**한 쿼리”들의 **WHERE/ORDER BY/JOIN** 패턴을 점검한다.
- 그 패턴을 **인덱스 선두 컬럼(=)**로 **직접 조준**해 **짧은 범위**에서 시작하도록 만든다.
- 힙 테이블이라면 “**TABLE ACCESS BY INDEX ROWID**”로 이어지는 **랜덤 I/O** 양을 최소화하고, 가능하면 **커버링**으로 **테이블 미방문**(index only)까지 노린다.

### 기준 ②: **정렬·Top-N·그룹화·중복제거의 소트를 인덱스로 흡수할 것**
- ORDER BY, GROUP BY, DISTINCT, 윈도우 정렬 등 **소트 연산**은 CPU·TEMP·I/O에 큰 비용.
- **인덱스 정렬 방향(ASC/DESC)**과 **컬럼 순서**를 질의의 **정렬 요구**와 일치시키면 **소트가 사라지고 Stopkey**가 작동한다.
- 결과적으로 **“앞 블록 몇 개만” 읽고 종료**하는 쿼리를 양산하게 된다.

> 감각 공식
> $$ \text{응답시간} \approx \text{(랜덤 I/O)} + \text{(소트 비용)} + \epsilon $$
> 인덱스 설계는 **랜덤 I/O**와 **소트**를 **동시에** 깎는 데 초점을 둔다.

---

# 2. 인덱스 설계는 “공식”이 아니라 **전략 & 선택**

- **업무 패턴**(OLTP vs DW), **DML 양**, **데이터 분포(스큐)**, **파티셔닝**, **RAC** 등 맥락에 따라 최적이 바뀐다.
- 같은 테이블에도 **서로 다른 쿼리들**이 **상충된 요구**(정렬/선두컬럼)를 낸다 → **복수 인덱스**로 **핫 경로** 위주 타협.
- **커버링 인덱스**는 읽기에는 빠르지만 변경 비용·공간을 늘린다 → 자주 읽히는 질의에만 제한 적용.
- “좋은 인덱스 하나”보다 “**핫 쿼리마다 가장 싼 진입로**를 여럿 만드는 것”이 현실적인 해법.

---

# 3. 실습 스키마 (주문 도메인)

```sql
DROP TABLE so PURGE;

CREATE TABLE so (
  order_id   NUMBER       PRIMARY KEY,
  cust_id    NUMBER       NOT NULL,
  order_dt   DATE         NOT NULL,
  status     VARCHAR2(8)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL,
  note       VARCHAR2(200)
);

BEGIN
  FOR i IN 1..300000 LOOP
    INSERT INTO so
    VALUES(
      i,
      MOD(i,60000)+1,
      DATE '2024-01-01' + MOD(i, 540),
      CASE MOD(i,5) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP'
                    WHEN 3 THEN 'DONE' ELSE 'CANC' END,
      ROUND(DBMS_RANDOM.VALUE(10, 200000), 2),
      CASE WHEN MOD(i,97)=0 THEN 'gift' END
    );
  END LOOP;
  COMMIT;
END;
/
BEGIN DBMS_STATS.GATHER_TABLE_STATS(USER,'SO', cascade=>TRUE,
       method_opt=>'for all columns size skewonly'); END;
/
```

---

# 4. 결합 인덱스 컬럼 순서 결정 — 실전 전략

## 4.1 기본 원칙(OLTP 기준)
1) **선두에 등치(=)**가 오도록: **가장 자주 쓰는 필터** 또는 **조인 키**를 **선두**로.
2) 그 다음에 **정렬/범위**가 오도록: ORDER BY/GROUP BY를 **인덱스 순서/방향**과 일치.
3) **선택도(카디널리티)**가 높은 컬럼을 앞쪽에 두어 **스캔 폭을 좁힘**(단, 1)과 상충 시 1) 우선 검토).
4) **커버링**이 크게 이득인 경우, **SELECT-LIST 컬럼**을 **키 뒤**에 추가(Oracle은 INCLUDE 없음 → 키 뒤에 넣음).

> 충돌 시 우선순위 예시
> **(핫 경로의 선두 등치)** > **정렬·Top-N 흡수** > **선택도 최적화** > **커버링** > **인덱스 수 절약**

## 4.2 예제 A: 고객의 **최근 주문 Top-N** (정렬 흡수)
```sql
-- 쿼리
SELECT order_id, order_dt, amount
FROM   so
WHERE  cust_id = :cid
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;

-- 인덱스 설계안1: (cust_id, order_dt DESC, order_id DESC)  ← 정렬 흡수 + Stopkey
CREATE INDEX so_c_dt_desc ON so(cust_id, order_dt DESC, order_id DESC);

-- 검증
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```
- **소트 제거**, **앞블록 몇 개만** 읽고 종료 → **랜덤 I/O 최소화**.

## 4.3 예제 B: 기간 + 상태 요약 (선두 등치 + 범위)
```sql
-- 쿼리
SELECT status, COUNT(*)
FROM   so
WHERE  cust_id = :cid
AND    order_dt BETWEEN :d1 AND :d2
GROUP  BY status;

-- 인덱스 설계안: (cust_id, order_dt, status)
CREATE INDEX so_c_dt_s ON so(cust_id, order_dt, status);

-- 기대: cust_id =  → 짧은 구간 시작, 그 안에서 order_dt 범위 스캔, GROUP BY에 status 키 활용(소트 감소)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

## 4.4 예제 C: 고객 없이 **기간+상태** 중심 화면 (선택도와 정렬의 타협)
```sql
-- 쿼리
SELECT order_id, cust_id, amount
FROM   so
WHERE  order_dt >= SYSDATE - 1
AND    status   = 'PAID'
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 100 ROWS ONLY;

-- 설계안1: (status, order_dt DESC, order_id DESC)  ← status=등치 + 정렬흡수
CREATE INDEX so_s_dt_desc ON so(status, order_dt DESC, order_id DESC);

-- 설계안2: (order_dt DESC, status, order_id DESC)  ← 날짜가 더 선별적이면 이쪽
CREATE INDEX so_dt_desc_s ON so(order_dt DESC, status, order_id DESC);
```
- **업무 프로파일**(최근 1일 데이터량, status 분포)에 따라 승자가 바뀜 → **실측**으로 결정.

---

# 5. 선택도(카디널리티) 이슈 — 왜 “숫자”가 답인가

## 5.1 선택도 체크 스크립트
```sql
-- 컬럼 통계
SELECT column_name, num_distinct, density, num_nulls, histogram
FROM   user_tab_col_statistics
WHERE  table_name = 'SO';

-- 인덱스 요약
SELECT index_name, blevel, leaf_blocks, distinct_keys, clustering_factor
FROM   user_indexes
WHERE  table_name = 'SO';
```

- **num_distinct**↑이면 해당 컬럼은 **선택도↑**. 선두로 올리면 범위가 확 좁아짐.
- **density**는 선택도의 역수 감각(낮을수록 선택도↑).
- **clustering_factor**는 **인덱스 순서와 테이블 물리 순서의 친화도**: 낮을수록 **랜덤 I/O 덜 발생**.

## 5.2 스큐(편향)·바인드 피킹·ACS
- 값 분포가 **극단적으로 치우친 컬럼**은 평균 선택도가 **틀리다**.
- **히스토그램**·**Adaptive Cursor Sharing**(ACS)로 값별 계획 분기 가능.
- 인덱스 설계 자체로 모든 편향을 흡수할 수 없다면 **값 별 전략**(힌트/SQL 분리/플랜 관리)을 고려.

---

# 6. 소트 오퍼레이션 **생략**하기 (정렬·Top-N·집계)

## 6.1 ORDER BY 정렬 제거 + Stopkey
```sql
-- 최신 20건
SELECT order_id, order_dt, amount
FROM   so
WHERE  cust_id = :cid
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 20 ROWS ONLY;

-- 인덱스: (cust_id, order_dt DESC, order_id DESC)
-- 효과: Sort 제거 + 소량 블록만 읽고 종료(Stopkey)
```

## 6.2 GROUP BY / DISTINCT 소트 제거
```sql
-- 고객의 상태별 집계
SELECT status, COUNT(*)
FROM   so
WHERE  cust_id = :cid
GROUP  BY status;

-- 인덱스: (cust_id, status) 또는 (cust_id, status, order_dt)
-- 계획: INDEX RANGE SCAN으로 status가 index order라면 Sort Group By가 Hash Group By로 바뀌거나 소트량 급감
```

## 6.3 “커버링”으로 테이블 미방문
```sql
-- 커버링 인덱스 설계
CREATE INDEX so_c_dt_sel ON so(cust_id, order_dt, order_id, amount, status);

-- 커버링 쿼리
SELECT order_id, order_dt, status, amount
FROM   so
WHERE  cust_id = :cid
AND    order_dt >= SYSDATE - 7
ORDER  BY order_dt, order_id;
```
- **TABLE ACCESS BY INDEX ROWID**가 사라지거나 최소화 → **랜덤 I/O** 대폭 절감.
- 단, **DML 비용/공간** 증가. **핫 리포트**에만 선별 적용.

## 6.4 함수기반/가상컬럼으로 SARGability 확보
```sql
-- 일자 기준 조회를 위해 TRUNC(order_dt)를 자주 쓰는 경우
ALTER TABLE so ADD (order_day AS (TRUNC(order_dt)));
CREATE INDEX so_c_day_desc ON so(cust_id, order_day DESC, order_id DESC);

SELECT order_id
FROM   so
WHERE  cust_id  = :cid
AND    order_day = DATE '2025-10-15'
ORDER  BY order_day DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;
```
- 컬럼에 함수 적용 대신 **가상 컬럼 + 함수기반 인덱스**로 **access predicate**화.

---

# 7. 실전 비교: 서로 다른 설계안의 숫자 비교

## 7.1 시나리오: “최근 7일, 고객의 결제 완료 주문 Top-N”
```sql
-- 공통 쿼리
VAR cid NUMBER; EXEC :cid := 12345;
SELECT order_id, order_dt, amount
FROM   so
WHERE  cust_id  = :cid
AND    order_dt >= SYSDATE - 7
AND    status   = 'PAID'
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;

-- 설계안A: (cust_id, order_dt DESC, order_id DESC, status) ← 정렬흡수, status 필터는 filter
CREATE INDEX so_A ON so(cust_id, order_dt DESC, order_id DESC, status);

-- 설계안B: (cust_id, status, order_dt DESC, order_id DESC) ← status= 등치를 앞에
CREATE INDEX so_B ON so(cust_id, status, order_dt DESC, order_id DESC);

-- 각각 실행 → DBMS_XPLAN으로 Buffers/Reads/Starts/Predicate 비교
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +PEEKED_BINDS'));
```
- **데이터 분포**에 따라 A/B 승자가 바뀔 수 있다(최근 7일에 데이터가 몰려 있나? status=‘PAID’ 비율은?).
- 실측 숫자를 기준으로 의사결정(“공식”이 아닌 “선택”).

---

# 8. 인덱스 수를 관리하는 법(과유불급 방지)

- **과잉 인덱스**는 DML 할 때마다 **중복 갱신/락 경합**을 부른다.
- 비슷한 형태의 인덱스가 여러 개라면 **상위 호환** 인덱스 하나로 합칠 수 없는지 점검.
- **사용 빈도**가 낮거나 **계획에 안 쓰이는 인덱스**는 후보 제거.
- 주기적으로 **사용 통계/계획**을 모아 인덱스 목록을 리팩터링.

```sql
-- 최근 실행 SQL이 어떤 인덱스를 썼는지 개략 확인(간이)
SELECT sql_id, child_number, plan_hash_value, operation, options, object_name
FROM   v$sql_plan
WHERE  object_owner = USER
AND    object_name IN (SELECT index_name FROM user_indexes)
ORDER  BY last_change_time DESC FETCH FIRST 50 ROWS ONLY;
```

---

# 9. 인덱스 설계도(템플릿) — 팀 내 합의 문서로 쓰세요

아래 **문서 템플릿**은 신규/리팩터링 시 필수 항목만 모았습니다.
(**굵은 글씨**는 꼭 채울 것)

### 9.1 워크로드 인벤토리
- **비즈니스 시나리오**: (예) 주문목록, 최근주문 Top-N, 고객상세, 집계리포트 …
- **핫 쿼리 TOP N**: **SQL 텍스트**, 호출 빈도, 평균/최대 응답시간, SLA.
- **데이터 프로파일**: **행 수**, 증가율, **핵심 컬럼의 num_distinct/히스토그램**, **클러스터링 팩터**.

### 9.2 후보 인덱스 설계안
- 설계안#1: 컬럼/순서/방향, 의도(선두=등치, 정렬 흡수, 커버링).
- 설계안#2: (대안)
- **충돌 관계**: 어떤 쿼리와 정렬/선두가 상충하는지.

### 9.3 비용-편익 평가(실측)
- 각 설계안별로 **핫 쿼리** 실행 → `ALLSTATS LAST`
  - **Buffers/Reads/Starts/Rows**, Sort 유무, **access/filter predicates**
  - DML 부하(INSERT/UPDATE/DELETE 1만건 측정 시 인덱스 유지 비용)
- **결정**: 채택/보류/대체.

### 9.4 운영 정책
- **통계 수집**(주기/히스토그램 정책), **ACS/바인드** 가이드.
- **인덱스 수명주기**: 사용률 낮으면 폐기, 중복·상위호환 정리.
- **재구성**: COALESCE/REBUILD 기준(blevel/leaf_blocks/del_lf_rows).
- **모니터링**: 대기 이벤트, logical/physical reads, buffer busy, row lock 등.

---

# 10. 빠른 체크리스트

- [ ] **핫 경로**의 WHERE/JOIN/ORDER BY를 **선두 등치 + 정렬 흡수**로 맞췄는가?
- [ ] **Top-N**은 **DESC/ASC** 인덱스로 **Stopkey**를 쓰게 했는가?
- [ ] **BETWEEN**은 가능한 **IN 분해**(이산값·소량) 또는 **좌포우개 범위**로 안전화했는가?
- [ ] **SARGability**(함수·형변환 제거)를 확보했는가? 필요 시 **가상 컬럼/함수기반 인덱스**.
- [ ] **커버링**은 **핫 리포트**에만 선별 적용했는가(공간·DML 비용 감안)?
- [ ] **선택도/스큐**를 통계로 확인했는가(히스토그램/ACS 고려)?
- [ ] **소트/해시 집계**를 인덱스로 대체할 수 있는가(순서/방향 일치)?
- [ ] **인덱스 수**는 적정한가(중복/미사용 제거)?
- [ ] 변경 후 **ALLSTATS LAST**로 **숫자**가 좋아졌는지 검증했는가?

---

# 11. 부록 — 자주 쓰는 패턴 모음

## 11.1 키-셋 페이징 (이전/다음 페이지)
```sql
-- 다음 페이지: 마지막 커서 (:last_dt, :last_id) 기준
SELECT order_id, order_dt, amount
FROM   so
WHERE  cust_id = :cid
AND   (order_dt < :last_dt
       OR (order_dt = :last_dt AND order_id < :last_id))
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;

-- 인덱스: (cust_id, order_dt DESC, order_id DESC)
```

## 11.2 DISTINCT 제거
```sql
-- 고객이 주문한 서로 다른 상태
SELECT DISTINCT status
FROM   so
WHERE  cust_id = :cid;

-- 인덱스: (cust_id, status)
-- 인덱스 순서대로 스캔 시 중복 최소, Sort/Hash Distinct 부담 감소
```

## 11.3 부분범위처리(OLTP 목록)
```sql
SELECT order_id, order_dt, amount
FROM   so
WHERE  cust_id = :cid
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 200 ROWS ONLY;  -- 화면 분할 로딩

-- 정렬흡수 인덱스와 결합하면 I/O가 소량 블록에 국한
```

---

## 마무리

- **두 축**: (1) **핫 쿼리**의 **선두 등치**로 **짧은 진입로**, (2) **정렬/Top-N/집계**를 **인덱스로 흡수**해 **소트 제거**.
- 그 외는 **선택도/스큐/커버링/DML 비용**의 **트레이드오프**이며, **정답은 실측**에 있다.
- 인덱스는 **한 방의 공식**이 아니라 **업무 패턴을 데이터 구조로 번역**하는 **설계 행위**다.
- 변경 전/후 `DBMS_XPLAN`의 **Buffers/Reads/Sort 유무**를 **숫자**로 확인하고, 팀의 **인덱스 설계도**에 기록하라.

> **숫자가 답입니다.**
> 좋은 인덱스는 **읽기·정렬의 비용을 구조적으로 없애는** 선택에서 시작됩니다.
