---
layout: post
title: DB 심화 - 인덱스 설계
date: 2025-11-07 23:25:23 +0900
category: DB 심화
---
# 인덱스 설계: 원리, 전략, 실무적 접근법

> **핵심 원리**
> 효과적인 인덱스 설계는 데이터 접근 패턴의 깊은 이해와 성능 목표 사이의 균형을 찾는 과정입니다. 핵심은 가장 중요한 쿼리의 접근 경로를 최적화하고, 정렬 작업을 인덱스로 흡수하는 것입니다.

---

## 실습 환경 설정

```sql
-- 세션 설정
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;  -- 상세 실행 계획 확인용

-- 실습용 테이블 생성
DROP TABLE sales_orders PURGE;

CREATE TABLE sales_orders (
  order_id   NUMBER        PRIMARY KEY,
  customer_id NUMBER       NOT NULL,
  order_date DATE          NOT NULL,
  status     VARCHAR2(8)   NOT NULL,
  amount     NUMBER(12,2)  NOT NULL,
  notes      VARCHAR2(200),
  created_at TIMESTAMP     DEFAULT SYSTIMESTAMP,
  updated_at TIMESTAMP     DEFAULT SYSTIMESTAMP
);

-- 샘플 데이터 생성 (약 30만 건)
BEGIN
  FOR i IN 1..300000 LOOP
    INSERT INTO sales_orders
    VALUES(
      i,
      MOD(i, 60000) + 1,                    -- 약 6만 명의 고객
      DATE '2024-01-01' + MOD(i, 540),      -- 약 1.5년 범위
      CASE MOD(i,5)
        WHEN 0 THEN 'NEW'
        WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP'
        WHEN 3 THEN 'DONE'
        ELSE 'CANC'
      END,
      ROUND(DBMS_RANDOM.VALUE(10, 200000), 2),
      CASE WHEN MOD(i,97) = 0 THEN 'special order' END,
      SYSTIMESTAMP,
      SYSTIMESTAMP
    );
  END LOOP;
  COMMIT;
END;
/

-- 통계 정보 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER,
    'SALES_ORDERS',
    cascade => TRUE,
    method_opt => 'for all columns size skewonly'
  );
END;
/
```

---

## 인덱스 설계의 기본 원칙

### 핵심 성과 지표 이해
효과적인 인덱스 설계는 다음 성과 지표를 개선하는 것을 목표로 합니다:

1. **응답 시간**: 쿼리 실행 시간 최소화
2. **처리량**: 단위 시간당 처리 가능한 쿼리 수 증가
3. **자원 효율성**: CPU, 메모리, I/O 자원의 최적화된 사용
4. **확장성**: 데이터 증가에 따른 성능 저하 최소화

### 설계 결정의 기반 요소
인덱스 설계 결정은 다음 요소들을 종합적으로 고려해야 합니다:

- **워크로드 특성**: OLTP, DW, 하이브리드 시스템 구분
- **데이터 접근 패턴**: 빈번한 쿼리와 조인 패턴
- **데이터 특성**: 데이터 분포, 증가율, 수명 주기
- **시스템 환경**: 하드웨어 사양, 스토리지 특성
- **비즈니스 요구사항**: 성능 SLA, 가용성 요구사항

---

## 인덱스 설계 전략

### 선두 컬럼 선택 전략
인덱스의 첫 번째 컬럼은 가장 중요한 성능 결정 요소입니다:

```sql
-- 효율적인 선두 컬럼 선택 예시
-- 고객별 조회가 빈번한 경우
CREATE INDEX idx_customer_date ON sales_orders(customer_id, order_date DESC);

-- 날짜별 조회가 빈번한 경우  
CREATE INDEX idx_date_customer ON sales_orders(order_date, customer_id);

-- 상태별 모니터링이 필요한 경우
CREATE INDEX idx_status_date ON sales_orders(status, order_date DESC);
```

**선두 컬럼 선택 기준**:
1. 가장 높은 선택도를 가진 컬럼
2. 가장 빈번하게 등치 조건으로 사용되는 컬럼
3. 조인 조건으로 자주 사용되는 컬럼
4. 비즈니스적으로 중요한 필터 조건

### 정렬 요구사항 반영
쿼리의 정렬 요구사항을 인덱스 설계에 반영하세요:

```sql
-- 정렬 흡수를 위한 인덱스 설계
CREATE INDEX idx_customer_date_amount ON sales_orders(
  customer_id,
  order_date DESC,
  amount DESC,
  order_id
);

-- 해당 인덱스를 활용하는 쿼리
SELECT order_id, order_date, amount, status
FROM sales_orders
WHERE customer_id = :cust_id
ORDER BY order_date DESC, amount DESC
FETCH FIRST 100 ROWS ONLY;
```

### 커버링 인덱스 설계
자주 실행되는 쿼리의 성능을 극대화하기 위한 접근법:

```sql
-- 커버링 인덱스 설계 예시
CREATE INDEX idx_order_covering ON sales_orders(
  customer_id,
  order_date DESC,
  order_id,
  status,
  amount,
  notes
);

-- 커버링 인덱스를 활용한 쿼리
SELECT order_id, order_date, status, amount
FROM sales_orders
WHERE customer_id = :cust_id
  AND order_date >= SYSDATE - 30
ORDER BY order_date DESC;
```

---

## 성능 분석과 최적화

### 통계 기반 설계 결정
데이터 특성을 분석하여 정보에 기반한 설계 결정을 내리세요:

```sql
-- 컬럼별 통계 분석
SELECT column_name,
       num_distinct,
       density,
       num_nulls,
       histogram,
       ROUND((num_rows - num_nulls) / NULLIF(num_distinct, 0)) as avg_rows_per_value
FROM user_tab_col_statistics
WHERE table_name = 'SALES_ORDERS'
ORDER BY num_distinct DESC;

-- 인덱스 효율성 분석
SELECT index_name,
       blevel,
       leaf_blocks,
       distinct_keys,
       clustering_factor,
       ROUND(clustering_factor / num_rows * 100, 2) as cf_percentage
FROM user_indexes
WHERE table_name = 'SALES_ORDERS';
```

### 실행 계획 분석
실제 실행 계획을 분석하여 설계 결정을 검증하세요:

```sql
-- 성능 테스트 쿼리
ALTER SESSION SET statistics_level = ALL;

SELECT order_id, order_date, amount, status
FROM sales_orders
WHERE customer_id = 12345
  AND order_date >= SYSDATE - 90
ORDER BY order_date DESC
FETCH FIRST 50 ROWS ONLY;

-- 실행 계획 분석
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL,
  'ALLSTATS LAST +PREDICATE +PEEKED_BINDS'
));
```

---

## 실전 설계 시나리오

### 시나리오 1: 고객 포털 애플리케이션

**요구사항**:
- 고객별 주문 내역 조회 (최근 순 정렬)
- 상태별 필터링 기능
- 빠른 페이지네이션

**인덱스 설계**:
```sql
-- 핵심 인덱스: 고객별 최근 주문 조회
CREATE INDEX idx_cust_portal ON sales_orders(
  customer_id,
  order_date DESC,
  status,
  order_id
) COMPRESS 2;

-- 상태별 모니터링을 위한 보조 인덱스
CREATE INDEX idx_status_monitoring ON sales_orders(
  status,
  order_date DESC,
  customer_id
);
```

### 시나리오 2: 운영 대시보드

**요구사항**:
- 실시간 매출 모니터링
- 상태별 트랜드 분석
- 대량 데이터 집계

**인덱스 설계**:
```sql
-- 날짜 기반 분석을 위한 인덱스
CREATE INDEX idx_dashboard_analysis ON sales_orders(
  order_date,
  status,
  amount,
  customer_id
);

-- 빠른 집계를 위한 함수 기반 인덱스
CREATE INDEX idx_daily_summary ON sales_orders(
  TRUNC(order_date),
  status
);
```

### 시나리오 3: 배치 처리 시스템

**요구사항**:
- 대량 데이터 처리
- 상태 전이 작업
- 역사적 데이터 보관

**인덱스 설계**:
```sql
-- 배치 작업을 위한 인덱스
CREATE INDEX idx_batch_processing ON sales_orders(
  status,
  order_date
) COMPRESS;

-- 파티션 인덱스 (대용량 데이터)
CREATE INDEX idx_partitioned_local ON sales_orders(
  customer_id,
  order_date
) LOCAL;
```

---

## 고급 최적화 기법

### 함수 기반 인덱스
비 SARGable 조건을 최적화하기 위한 접근법:

```sql
-- 함수 기반 인덱스 생성
CREATE INDEX idx_order_year_month ON sales_orders(
  EXTRACT(YEAR FROM order_date),
  EXTRACT(MONTH FROM order_date),
  customer_id
);

-- 함수 기반 인덱스 활용 쿼리
SELECT COUNT(*), SUM(amount)
FROM sales_orders
WHERE EXTRACT(YEAR FROM order_date) = 2025
  AND EXTRACT(MONTH FROM order_date) = 10
  AND customer_id = :cust_id;
```

### 파티셔닝과 인덱스 통합
대용량 테이블에서의 효율적인 인덱스 설계:

```sql
-- 파티션 테이블 생성
CREATE TABLE sales_orders_partitioned (
  order_id     NUMBER,
  customer_id  NUMBER,
  order_date   DATE,
  status       VARCHAR2(8),
  amount       NUMBER(12,2),
  notes        VARCHAR2(200)
)
PARTITION BY RANGE (order_date) (
  PARTITION p2024 VALUES LESS THAN (DATE '2025-01-01'),
  PARTITION p2025_q1 VALUES LESS THAN (DATE '2025-04-01'),
  PARTITION p2025_q2 VALUES LESS THAN (DATE '2025-07-01'),
  PARTITION p_future VALUES LESS THAN (MAXVALUE)
);

-- 로컬 인덱스 생성
CREATE INDEX idx_local_cust_date ON sales_orders_partitioned(customer_id, order_date)
LOCAL;
```

### 비트맵 인덱스 활용
저카디널리티 컬럼에 대한 효율적인 접근:

```sql
-- 비트맵 인덱스 생성 (DW 환경)
CREATE BITMAP INDEX idx_bitmap_status ON sales_orders(status);

-- 비트맵 인덱스 활용 쿼리
SELECT customer_id, COUNT(*) as order_count
FROM sales_orders
WHERE status IN ('PAID', 'SHIP')
GROUP BY customer_id
HAVING COUNT(*) > 10;
```

---

## 성능 테스트와 검증

### A/B 테스트 프레임워크
```sql
-- 인덱스 성능 비교 테스트
ALTER SESSION SET statistics_level = ALL;

-- 테스트 케이스 A: 기존 인덱스
SELECT /*+ TEST_A INDEX(sales_orders idx_old) */ 
       order_id, order_date, amount
FROM sales_orders
WHERE customer_id = 12345
  AND order_date >= DATE '2025-01-01'
ORDER BY order_date DESC;

-- 테스트 케이스 B: 새로운 인덱스
SELECT /*+ TEST_B INDEX(sales_orders idx_new) */ 
       order_id, order_date, amount
FROM sales_orders
WHERE customer_id = 12345
  AND order_date >= DATE '2025-01-01'
ORDER BY order_date DESC;

-- 성능 결과 비교
SELECT sql_id,
       plan_hash_value,
       executions,
       buffer_gets,
       disk_reads,
       elapsed_time/1000000 as elapsed_seconds,
       SUBSTR(sql_text, 1, 100) as sql_snippet
FROM v$sql
WHERE sql_text LIKE '%TEST_%'
ORDER BY sql_id;
```

### 장기 성능 모니터링
```sql
-- 인덱스 사용 현황 모니터링
CREATE TABLE index_usage_monitor (
    monitor_date DATE DEFAULT SYSDATE,
    index_name VARCHAR2(30),
    table_name VARCHAR2(30),
    scans_since_start NUMBER,
    rows_per_scan NUMBER,
    buffer_gets_per_scan NUMBER
);

-- 주기적 모니터링 프로시저
CREATE OR REPLACE PROCEDURE monitor_index_usage AS
BEGIN
  INSERT INTO index_usage_monitor
  SELECT SYSDATE,
         i.index_name,
         i.table_name,
         u.total_access_count,
         ROUND(u.total_row_count / NULLIF(u.total_access_count, 0), 2),
         ROUND(u.total_buffer_gets / NULLIF(u.total_access_count, 0), 2)
  FROM   v$object_usage u
  JOIN   user_indexes i ON u.index_name = i.index_name;
  
  COMMIT;
END;
/
```

---

## 일반적인 문제와 해결책

### 문제 1: 인덱스 과다 생성
**증상**: 너무 많은 인덱스로 인한 DML 성능 저하

**해결책**:
```sql
-- 사용되지 않는 인덱스 식별
SELECT index_name,
       table_name,
       uniqueness,
       status
FROM user_indexes
WHERE table_name = 'SALES_ORDERS'
  AND index_name NOT IN (
    SELECT object_name
    FROM v$sql_plan
    WHERE object_owner = USER
      AND operation LIKE '%INDEX%'
  );

-- 중복 인덱스 식별
WITH index_columns AS (
  SELECT index_name,
         LISTAGG(column_name, ',') WITHIN GROUP (ORDER BY column_position) as cols
  FROM user_ind_columns
  WHERE table_name = 'SALES_ORDERS'
  GROUP BY index_name
)
SELECT a.index_name as index_a,
       b.index_name as index_b,
       a.cols
FROM index_columns a
JOIN index_columns b ON a.cols LIKE b.cols || ',%'
WHERE a.index_name != b.index_name;
```

### 문제 2: 잘못된 선두 컬럼 선택
**증상**: 인덱스가 있지만 여전히 풀 스캔 발생

**해결책**:
```sql
-- 인덱스 사용 패턴 분석
SELECT sql_id,
       SUBSTR(sql_text, 1, 100) as sql_snippet,
       plan_hash_value,
       executions,
       buffer_gets,
       disk_reads
FROM v$sql
WHERE sql_text LIKE '%SALES_ORDERS%'
  AND executions > 100
ORDER BY buffer_gets DESC
FETCH FIRST 10 ROWS ONLY;

-- 실행 계획에서 인덱스 사용 여부 확인
EXPLAIN PLAN FOR
SELECT * FROM sales_orders
WHERE customer_id = 12345
  AND order_date >= SYSDATE - 30;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 문제 3: 클러스터링 팩터 저하
**증상**: 인덱스 범위 스캔이 비효율적

**해결책**:
```sql
-- 클러스터링 팩터 개선을 위한 테이블 재구성
CREATE TABLE sales_orders_reorganized AS
SELECT * FROM sales_orders
ORDER BY customer_id, order_date, order_id;

-- 인덱스 재생성
CREATE INDEX idx_reorg_cust_date ON sales_orders_reorganized(customer_id, order_date);

-- 통계 재수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER,
    'SALES_ORDERS_REORGANIZED',
    cascade => TRUE
  );
END;
/
```

---

## 결론: 효과적인 인덱스 설계를 위한 종합적 접근법

인덱스 설계는 단순한 기술적 결정을 넘어 비즈니스 요구사항, 데이터 특성, 시스템 아키텍처를 종합적으로 고려한 균형 잡힌 접근이 필요합니다.

### 1. 체계적 설계 프로세스 수립
효과적인 인덱스 설계를 위해 다음 프로세스를 수립하세요:

1. **요구사항 분석**: 비즈니스 시나리오와 성능 목표 정의
2. **데이터 프로파일링**: 데이터 분포, 접근 패턴, 성장률 분석
3. **인덱스 후보 설계**: 다양한 접근법에 기반한 설계안 개발
4. **성능 테스트**: 실제 데이터와 워크로드로 성능 검증
5. **운영 배포**: 안전한 배포와 지속적 모니터링

### 2. 상황별 최적화 전략
다양한 상황에 맞는 최적화 전략을 적용하세요:

**OLTP 시스템**:
- 선두 등치 조건 최적화
- 정렬 흡수와 Stopkey 활용
- 외래 키 인덱스 필수 적용
- 인덱스 수 적정화로 DML 성능 보장

**데이터 웨어하우스**:
- 파티셔닝과 로컬 인덱스 활용
- 비트맵 인덱스 적극적 사용
- 대량 스캔 최적화
- 집계 쿼리 성능 우선

**하이브리드 시스템**:
- 워크로드 분리 전략
- 핫 데이터와 콜드 데이터 차별적 관리
- 적응적 인덱스 전략

### 3. 지속적 관리와 개선
인덱스 설계는 일회성 작업이 아닌 지속적인 과정입니다:

1. **정기적 모니터링**: 인덱스 사용률, 효율성, 성능 추적
2. **사용 패턴 분석**: 변화하는 워크로드에 대한 적응적 조정
3. **주기적 최적화**: 재구성, 재생성, 통계 갱신
4. **문서화와 지식 공유**: 설계 결정과 성과 체계적 기록

### 4. 조직적 협업과 표준화
효과적인 인덱스 관리를 위한 조직적 접근:

1. **설계 표준 수립**: 인덱스 설계 원칙과 가이드라인 문서화
2. **교육 프로그램**: 개발자 대상 최적화 기법 교육
3. **코드 리뷰 프로세스**: 인덱스 관련 코드 체계적 검토
4. **성과 측정 체계**: 개선 효과 정량적 평가

### 5. 기술적 혁신 수용
새로운 기술과 접근법을 적극적으로 수용하세요:

1. **자동화 도구 활용**: 인덱스 튜닝 자동화 도구 검토
2. **AI/ML 기반 최적화**: 예측 분석을 통한 사전 최적화
3. **클라우드 네이티브 접근**: 클라우드 환경에 최적화된 설계
4. **실시간 분석**: 실시간 모니터링과 즉각적 조정

### 최종 원칙: 데이터 중심 의사결정
모든 인덱스 설계 결정은 실제 성능 데이터에 기반해야 합니다. 직관이나 경험에만 의존하지 말고, 측정 가능한 성과 지표를 통해 개선 효과를 검증하세요. 효과적인 인덱스 설계는 더 빠른 응답 시간, 더 높은 처리량, 더 낮은 운영 비용으로 이어지며, 궁극적으로 비즈니스 가치 창출에 기여합니다.

지속적인 학습, 실험, 개선을 통해 데이터베이스 시스템의 최적 성능을 유지하고, 변화하는 비즈니스 요구사항에 효과적으로 대응하는 인덱스 설계 역량을 확보하세요.