---
layout: post
title: DB 심화 - 인덱스 설계
date: 2025-11-07 23:25:23 +0900
category: DB 심화
---
# 인덱스 설계

## 0. 공통 준비 + 실습 환경

```sql
ALTER SESSION SET nls_date_format  = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;  -- DBMS_XPLAN ALLSTATS LAST 필수
```

실습은 모두 **개발/로컬 인스턴스**에서 진행한다.  
실제 IOPS·지연 특성은 **디스크/SSD·스토리지**에 따라 달라지는데,  
최근 북미·유럽권 벤치마크를 보면 **랜덤 I/O와 순차 I/O의 성능 격차**,  
HDD와 SSD의 IOPS 차이가 여전히 수십~수백 배에 이르는 것이 일반적이다. :contentReference[oaicite:0]{index=0}  

→ 인덱스 설계는 여전히 **“랜덤 I/O를 얼마나 줄일 수 있느냐”**가 핵심 축이다.

---

## 1. “가장 중요한 두 가지” 선택 기준 다시 쓰기

이 글의 출발점은 이미 적어둔 아래 두 가지 기준이다:

1. **핫 경로(핵심 쿼리)의 Access Path를 가장 싸게 만들 것**
2. **정렬·Top-N·그룹화·중복제거의 소트를 인덱스로 흡수할 것**

여기에 몇 가지를 더 추가해서 정리하자.

### 1.1 기준 ①: 핫 경로 Access Path 최소화

- “**가장 자주 호출**되고, **느려지면 곤란**한 쿼리” 목록을 만든다.
- 이 쿼리들의

  - `WHERE` 조건
  - `JOIN` 조건
  - `ORDER BY` / `GROUP BY` / `DISTINCT`

  패턴을 추출한다.
- 이 패턴을 **인덱스의 선두(Leading Column)** 에 **직접 대응되도록** 설계한다.

> 직관적인 비용 모델(개념식):

$$
\text{Cost} \approx
(\text{랜덤 I/O 개수}) + \alpha\cdot (\text{소트 크기}) + \epsilon
$$

- **랜덤 I/O**: `TABLE ACCESS BY INDEX ROWID`에서 **서로 다른 블록**을 들락날락하는 횟수.
- **소트 크기**: `SORT ORDER BY`, `SORT GROUP BY`, `SORT UNIQUE` 등에서 발생하는 **PGA/TEMP 사용량**.
- 인덱스 설계는 이 둘을 동시에 줄이는 방향으로 움직인다.

### 1.2 기준 ②: 소트 제거 + Stopkey

- `ORDER BY`, `GROUP BY`, `DISTINCT`, 윈도우 함수의 `ORDER BY` 등은 모두 내부적으로 **소트**를 유발한다.
- 인덱스의 컬럼 순서·정렬 방향이 쿼리의 `ORDER BY`와 **정확히 일치**하면:

  - **소트 연산자 자체가 사라지거나 축소**되고,
  - `FETCH FIRST N ROWS`, Top-N 서브쿼리, 키셋 페이징 등에서 **Stopkey**가 작동하여
  - **“앞 블록 몇 개만 읽고 종료”**라는 이상적인 패턴을 얻는다.

이를 한 줄로 요약하면:

> **선두 등치 + 정렬흡수** = 핵심 쿼리에 대한 **가장 싸고 짧은 진입로**

---

## 2. 인덱스 설계는 공식이 아니라 “전략 & 선택”

**중요한 오해 방지**:  
“선택도 높은 컬럼을 항상 앞에 둬라” 같은 **단일 공식**은 현실에서 잘 안 맞는다.

현장의 변수:

- OLTP vs DW vs 하이브리드(HTAP) :contentReference[oaicite:1]{index=1}
- DML 양(초당 트랜잭션·배치 패턴)
- 데이터 분포(스큐, 극단적인 인기 값)
- 파티셔닝 유무, RAC/클러스터 아키텍처
- 리포트/배치 vs 인터랙티브 API 비율
- SSD/HDD, 스토리지 계층 구조

그리고 같은 테이블에서:

- A 쿼리는 `WHERE cust_id = :cid ORDER BY order_dt DESC`
- B 쿼리는 `WHERE order_dt BETWEEN :d1 AND :d2`
- C 쿼리는 `WHERE status = 'PAID' ORDER BY order_dt DESC, amount DESC`

→ **서로 다른 인덱스를 요구**한다. 모두 만족하는 인덱스 하나는 **존재하지 않을** 수 있다.

그래서 현실적인 전략은:

1. **핫 쿼리 TOP N**을 뽑고,
2. 각 쿼리에 대해
   - 가장 중요한 필터(등치)를 선두로,
   - 정렬이 중요하면 정렬 흡수를 우선 고려하고,
   - 그 다음에 선택도·커버링·인덱스 수를 트레이드오프해서
3. **복수 인덱스**로 타협하는 것이다.

---

## 3. 실습 스키마 재정리 (주문 도메인)

기존에 만든 주문 테이블을 다시 정리한다.

```sql
DROP TABLE so PURGE;

CREATE TABLE so (
  order_id   NUMBER       PRIMARY KEY,
  cust_id    NUMBER       NOT NULL,
  order_dt   DATE         NOT NULL,
  status     VARCHAR2(8)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL,
  note       VARCHAR2(200)
);

BEGIN
  FOR i IN 1..300000 LOOP
    INSERT INTO so
    VALUES(
      i,
      MOD(i,60000)+1,                      -- 고객 6만명 정도
      DATE '2024-01-01' + MOD(i, 540),     -- 약 1.5년 범위
      CASE MOD(i,5)
        WHEN 0 THEN 'NEW'
        WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP'
        WHEN 3 THEN 'DONE'
        ELSE 'CANC'
      END,
      ROUND(DBMS_RANDOM.VALUE(10, 200000), 2),
      CASE WHEN MOD(i,97)=0 THEN 'gift' END
    );
  END LOOP;
  COMMIT;
END;
/
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    USER,'SO', cascade=>TRUE,
    method_opt=>'for all columns size skewonly'
  );
END;
/
```

이 테이블을 가지고 **몇 가지 대표적인 인덱스 설계안**을 전개해 보면서,  
**선두 컬럼·정렬방향·커버링·선택도**를 실감하는 식으로 진행한다.

---

## 4. 결합 인덱스 컬럼 순서 결정 — 전략 세분화

### 4.1 OLTP 기준 기본 원칙 (정리 + 확장)

1. **선두에 등치(=)** 조건이 오도록 한다.
   - 특히 **자주 쓰이는 필터나 조인 키**(예: `cust_id`, `order_id`, `user_id`).
2. 그 다음에 **정렬/범위** 조건이 오도록 한다.
   - `ORDER BY order_dt DESC` → 인덱스 `(cust_id, order_dt DESC, ...)`.
3. 그 이후에 **GROUP BY/Distinct**를 도와줄 컬럼, 선택도가 높은 컬럼 순서로 배치.
4. **커버링**이 큰 가치를 가진다면, SELECT-LIST에 있는 컬럼을 뒤에 붙인다.
5. DML 코스트를 고려해 **핫 리포트/핫 API** 위주로만 커버링을 허용한다.

정리하면:

> **(선두 등치) → (정렬/범위) → (그룹/선택도) → (커버링)**

### 4.2 DW/리포트 기준 원칙

DW·데이터 마트·리포트 용도에서는 조금 다르다.

- 팩트 테이블은 보통 **파티션 + 로컬 인덱스**로 설계한다.
- 인덱스 컬럼 순서는

  1. **파티션 키(예: 날짜)**와 **조인 FK**(예: `cust_key`, `prod_key`)를 우선한다.
  2. 집계·정렬에 필요한 컬럼을 뒤에 둔다.
  3. OLTP처럼 개별 ROW 조회보다는 **범위/집계** 효율이 더 중요하다.

예:

```sql
-- 월별 RANGE 파티션 + 로컬 인덱스 예시(개념)
CREATE TABLE sales_fact (
  sales_key   NUMBER       PRIMARY KEY,
  sales_dt    DATE         NOT NULL,
  cust_key    NUMBER       NOT NULL,
  prod_key    NUMBER       NOT NULL,
  amount      NUMBER(12,2) NOT NULL,
  qty         NUMBER       NOT NULL
)
PARTITION BY RANGE (sales_dt) (
  PARTITION p2025m01 VALUES LESS THAN (DATE '2025-02-01'),
  PARTITION p2025m02 VALUES LESS THAN (DATE '2025-03-01')
  -- ...
);

-- 로컬 B-Tree 인덱스: (cust_key, sales_dt, sales_key)
CREATE INDEX sales_fact_cust_dt
ON sales_fact(cust_key, sales_dt, sales_key)
LOCAL;
```

---

## 5. 선택도·카디널리티·클러스터링 팩터 제대로 보기

### 5.1 통계 뽑기

```sql
-- 컬럼 통계
SELECT column_name, num_distinct, density, num_nulls, histogram
FROM   user_tab_col_statistics
WHERE  table_name = 'SO';

-- 인덱스 요약
SELECT index_name, blevel, leaf_blocks, distinct_keys, clustering_factor
FROM   user_indexes
WHERE  table_name = 'SO';
```

각 의미를 정리하면:

- `num_distinct` : **서로 다른 값 개수**. 클수록 선택도(high selectivity)↑.
- `density` : 대략 $$ \frac{1}{\text{num\_distinct}} $$ 정도의 느낌(히스토그램 있으면 달라질 수 있음).
- `clustering_factor` : 인덱스 순으로 테이블을 읽었을 때,  
  **얼마나 자주 다른 블록으로 점프하는지**를 간접적으로 보여주는 값.

### 5.2 선택도와 예상 카디널리티

Oracle의 카디널리티 추정은 단순화하면 다음과 비슷한 구조를 가진다.

- **단일 조건**: `col = :b`

  $$ \text{cardinality} \approx N \times \text{sel(col=)} $$

  여기서 \( N \)은 테이블 행 수, \(\text{sel} \)은 선택도.

- **독립 가정(AND)**: `c1 = :b1 AND c2 = :b2`

  $$ \text{cardinality} \approx N \times \text{sel(c1=)} \times \text{sel(c2=)} $$

스큐가 심한 컬럼에서는 이 **독립 가정**이 깨지므로, 히스토그램과 Adaptive Cursor Sharing이 중요해진다.

### 5.3 클러스터링 팩터(CF)의 의미

- \( \text{CF} \approx \) “인덱스 순으로 읽을 때, 테이블 블록이 얼마나 자주 바뀌는지”.
- 이상적인 경우:  
  $$ \text{CF} \approx \text{table blocks 수} $$
- 최악의 경우:  
  $$ \text{CF} \approx \text{rows 수} $$

CF가 크면:

- 인덱스 스캔 시 **랜덤 I/O**가 많이 발생.
- 옵티마이저는 같은 선택도라도  
  **CF가 큰 인덱스를 덜 선호**하게 된다 (비용 계산 시 반영).

→ **재적재(CTAS + rename)** 등으로 물리 순서를 인덱스 순서와 맞추면 CF를 개선할 수 있다.

---

## 6. 대표 패턴별 인덱스 설계

### 6.1 패턴 1: 고객별 최근 주문 Top-N

```sql
SELECT order_id, order_dt, amount
FROM   so
WHERE  cust_id = :cid
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

#### 인덱스 설계안

```sql
CREATE INDEX so_c_dt_desc
ON so(cust_id, order_dt DESC, order_id DESC);
```

**효과**

- `WHERE cust_id = :cid` → `Index Range Scan` 선두 등치.
- 인덱스 정렬과 `ORDER BY`가 일치 → **SORT ORDER BY 제거**.
- `FETCH FIRST 50 ROWS` → **Stopkey**로 앞부분만 읽고 종료.

**실습**

```sql
VAR cid NUMBER; EXEC :cid := 12345;

SELECT order_id, order_dt, amount
FROM   so
WHERE  cust_id = :cid
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS')
);
```

관찰 포인트:

- Access Path: `INDEX RANGE SCAN SO_C_DT_DESC`
- `SORT ORDER BY`가 없는지.
- `Predicate Information`에 `access("CUST_ID"=:CID)`만 있는지.
- Buffers/Reads가 작은지.

---

### 6.2 패턴 2: 고객의 상태별 집계

```sql
SELECT status, COUNT(*)
FROM   so
WHERE  cust_id = :cid
GROUP  BY status;
```

#### 설계안

```sql
CREATE INDEX so_c_s ON so(cust_id, status);
```

**위치 관계**

- 선두 `cust_id = :cid` → **좁은 범위** 시작.
- 그 범위 안에서 `status`가 인덱스 순서로 정렬되어 있으므로,
- 옵티마이저는 `HASH GROUP BY` 대신 `SORT GROUP BY`, 또는 **인덱스 순서 이용**으로 소트량을 줄일 수 있다.

실제 계획은 환경마다 다르지만, 핵심은:

- `INDEX RANGE SCAN SO_C_S`
- `GROUP BY` 소트 비용이 **적게** 나온다.

---

### 6.3 패턴 3: 기간 + 상태 Top-N

```sql
SELECT order_id, cust_id, amount
FROM   so
WHERE  order_dt >= SYSDATE - 1
AND    status   = 'PAID'
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 100 ROWS ONLY;
```

여기서 선택도는 환경에 따라 다르다.

- `order_dt >= SYSDATE - 1`: **최근 1일**이라면 전체의 극히 일부 (예: 1~2%).
- `status = 'PAID'`: 전체의 30~40%라면, 사실상 **많은 행**을 잡을 수 있다.

#### 설계안 후보

1. (status, order_dt DESC, order_id DESC)

   ```sql
   CREATE INDEX so_s_dt_desc
   ON so(status, order_dt DESC, order_id DESC);
   ```

2. (order_dt DESC, status, order_id DESC)

   ```sql
   CREATE INDEX so_dt_desc_s
   ON so(order_dt DESC, status, order_id DESC);
   ```

#### 어떤 게 유리?

- `order_dt` 조건이 **훨씬 더 선별적**이면 2번이 더 나을 수 있다.
- 반대로 `status='PAID'`가 매우 희소하다면 1번이 나을 수 있다.
- 즉, 아래 값들을 실제로 보고 판단해야 한다.

```sql
SELECT column_name, num_distinct, density
FROM   user_tab_col_statistics
WHERE  table_name = 'SO'
AND    column_name IN ('STATUS','ORDER_DT');
```

그리고 두 인덱스를 각각 만들어서 같은 쿼리를 실행:

```sql
-- A안
CREATE INDEX so_A ON so(status, order_dt DESC, order_id DESC);

-- B안
CREATE INDEX so_B ON so(order_dt DESC, status, order_id DESC);

VAR d1 DATE; VAR d2 DATE;
EXEC :d1 := SYSDATE - 1; EXEC :d2 := SYSDATE;

SELECT /*+ INDEX(so so_A) */
       order_id, cust_id, amount
FROM   so
WHERE  order_dt >= :d1
AND    status   = 'PAID'
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 100 ROWS ONLY;

SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE')
);

-- 동일 쿼리, B 인덱스로 다시 실행
```

→ **Buffers/Reads/Elapsed**를 비교해서 실제 승자를 결정한다.  
(“선택도” 공식보다 **숫자**가 우선이다.)

---

## 7. 커버링 인덱스 제대로 사용하기

### 7.1 개념

- 인덱스만으로 SELECT-LIST와 필터 조건을 모두 충족하는 경우,
  **테이블을 전혀 방문하지 않고** 결과를 만들 수 있다.
- 이때 `TABLE ACCESS BY INDEX ROWID`가 사라지거나 최소화되며,
  **랜덤 I/O가 크게 줄어든다**.

### 7.2 예제 – 커버링 리포트

```sql
-- 최근 7일 고객별 주문 목록
SELECT order_id, order_dt, amount, status
FROM   so
WHERE  cust_id  = :cid
AND    order_dt >= SYSDATE - 7
ORDER  BY order_dt DESC, order_id DESC;
```

#### 커버링 인덱스 설계

```sql
CREATE INDEX so_c_dt_cover
ON so(cust_id, order_dt DESC, order_id DESC, amount, status);
```

실행 계획을 보면:

- `INDEX RANGE SCAN SO_C_DT_COVER`
- `TABLE ACCESS BY INDEX ROWID`가 **없거나 최소**가 되는지 확인.

**주의**

- DML마다 **인덱스 키를 더 많이 업데이트**해야 한다 → 쓰기 비용 증가.
- 인덱스 세그먼트 크기가 상당히 커진다.
- 따라서 **핫 리포트/핫 API**에만 적용해야 한다.

---

## 8. 함수기반 인덱스 & 가상 컬럼으로 SARGability 맞추기

### 8.1 문제 패턴

```sql
-- (나쁜 예) 컬럼에 함수 적용
SELECT COUNT(*)
FROM   so
WHERE  TRUNC(order_dt) = DATE '2025-10-15';
```

- `TRUNC(order_dt)` 때문에 `order_dt` 컬럼이 **가공**되어,
  인덱스 `so(order_dt)` 등이 있어도 **Access Predicate로 사용하기 어렵다**.

### 8.2 해결 – 가상 컬럼 + 함수기반 인덱스

```sql
ALTER TABLE so ADD (
  order_day AS (TRUNC(order_dt))
);

CREATE INDEX so_c_day_desc
ON so(cust_id, order_day DESC, order_id DESC);
```

```sql
SELECT order_id, order_dt, amount
FROM   so
WHERE  cust_id  = :cid
AND    order_day = DATE '2025-10-15'
ORDER  BY order_day DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

- 이제 `order_day`는 **실제 컬럼**처럼 인덱스에 걸려 있고,
- `=` 조건이므로 **정확한 Start/Stop Key**를 만들 수 있다.

---

## 9. OLTP vs DW/분석에서의 인덱스 전략 차이

### 9.1 OLTP

- 목표: **응답시간 최소**, **동시성**, **락 경합 최소화**.
- 특징:
  - 읽기/쓰기 비율이 **읽기 우세**인 경우가 많지만,
    쓰기도 무시할 수 없고 **초당 수백~수천 트랜잭션**이 발생한다는 연구들이 많다. :contentReference[oaicite:2]{index=2}  
  - 작은 트랜잭션 + 짧은 쿼리.
- 전략:
  - **핫 쿼리**별로 인덱스를 최적화 (선두 등치 + 정렬 흡수).
  - 인덱스 수 과다로 인한 DML 비용 폭증을 제어.
  - **B-Tree 인덱스** 위주, Bitmap은 지양.

### 9.2 DW/리포트

- 목표: **대량 집계**, **스캔 최적화**, **복잡한 필터**.
- 특징:
  - 배치성 긴 쿼리, 기간/다차원 필터.
- 전략:
  - **파티션 + 로컬 인덱스**.
  - **비트맵 인덱스**(저/중복수), **Bitmap Join Index**.
  - 인덱스 수가 많아도 DML 적으면 감당 가능.

---

## 10. 잘못된 인덱스 설계 패턴과 리팩터링

### 10.1 “모든 WHERE/ORDER BY 조합마다 인덱스”

- 결과:
  - 인덱스 수가 수십 개 이상으로 폭발.
  - DML마다 업데이트해야 하는 인덱스가 너무 많아져 성능 저하.
- 리팩터링:
  - **핫 쿼리 TOP N**만 남기고,  
    나머지는 비슷한 패턴을 **상위 호환 인덱스**로 통합.
  - `user_indexes`, `v$sql_plan`으로 실제 사용 여부를 확인.

```sql
SELECT index_name
FROM   user_indexes
WHERE  table_name = 'SO';

SELECT sql_id, plan_hash_value, object_name, operation, options
FROM   v$sql_plan
WHERE  object_owner = USER
AND    object_name IN (SELECT index_name FROM user_indexes)
ORDER  BY last_change_time DESC
FETCH FIRST 50 ROWS ONLY;
```

### 10.2 선두 컬럼이 항상 날짜

- 모든 인덱스를 `(order_dt, ...)`로 시작하게 해 버리는 패턴.
- `cust_id = :cid` 같은 **고객 중심 쿼리**에서 인덱스를 제대로 활용 못 함.
- 해결:
  - **업무 흐름**에 맞춰 `cust_id 선두`, `order_dt 선두` 인덱스를 **각각** 설계.
  - 하나의 만능 인덱스를 만들려 하지 않는다.

### 10.3 WHERE 없는 인덱스 설계

- “나중에 쓸지도 몰라서” `note`, `amount` 등에 인덱스를 남발.
- WHERE 조건에서 거의 쓰이지 않으니 **계획에 잘 안 등장**.
- 정리:
  - `v$sql_plan` 기준으로 **실제 3~6개월간 거의 쓰이지 않은 인덱스**는 후보 제거.

---

## 11. FK, PK, Unique 제약과 인덱스

### 11.1 PK

- PK 제약은 자동으로 **유니크 인덱스**를 생성한다(명시하지 않으면).
- 설계 시:

  - PK 인덱스를 **실제 Access Path**로도 잘 활용할 수 있게 디자인하면 좋다.
  - 예: `so(order_id)`만 PK로 쓰기보다, 필요하면 **재정의**해서 `(order_id, something)`로 바꿀지 검토.

### 11.2 Unique 제약

- Unique 제약도 비슷하게 **유니크 인덱스**를 요구한다.
- BUT, 인덱스 설계를 위해 **Non-Unique 인덱스 + Unique 제약** 조합을 선택하는 경우도 있다.
  - 예: 복합 컬럼 유니크인데, 일부 컬럼만 인덱스로 자주 써야 한다면 설계를 분리.

### 11.3 FK 인덱스

- FK 컬럼에 인덱스가 없으면:
  - 부모 행 삭제/업데이트 시 자식 테이블에서 **Full Scan**이 발생.
  - 잠금 경합이 심해질 수 있다.
- 원칙:
  - **중요 FK**는 반드시 인덱스를 둔다.
  - 예: `orders(cust_id)`는 고객 삭제/머지/이관 시 매우 중요.

```sql
-- 고객 테이블
CREATE TABLE customer (
  cust_id   NUMBER PRIMARY KEY,
  cust_name VARCHAR2(100) NOT NULL
);

-- 주문 테이블 (FK 인덱스 필수)
CREATE TABLE orders (
  order_id  NUMBER PRIMARY KEY,
  cust_id   NUMBER NOT NULL REFERENCES customer(cust_id),
  order_dt  DATE   NOT NULL
);

CREATE INDEX orders_cust_fk ON orders(cust_id);
```

---

## 12. 파티셔닝 + 인덱스 설계

### 12.1 RANGE 파티션 + 로컬 인덱스

```sql
CREATE TABLE so_p (
  order_id   NUMBER       NOT NULL,
  cust_id    NUMBER       NOT NULL,
  order_dt   DATE         NOT NULL,
  status     VARCHAR2(8)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL,
  CONSTRAINT pk_so_p PRIMARY KEY (order_id)
)
PARTITION BY RANGE (order_dt) (
  PARTITION p2024m01 VALUES LESS THAN (DATE '2024-02-01'),
  PARTITION p2024m02 VALUES LESS THAN (DATE '2024-03-01'),
  PARTITION pmax     VALUES LESS THAN (MAXVALUE)
);

CREATE INDEX so_p_cust_dt
ON so_p(cust_id, order_dt)
LOCAL;
```

- 장점:
  - `WHERE order_dt BETWEEN :d1 AND :d2` → **파티션 프루닝**으로 범위 축소.
  - 파티션별 **로컬 인덱스** 크기가 작아지고, 재구성/삭제가 쉬워진다.

### 12.2 Global vs Local 인덱스

- **Global** 인덱스:
  - 전체 파티션에 걸쳐 하나의 인덱스.
  - 파티션 추가/삭제 시 인덱스 유지 비용.
- **Local** 인덱스:
  - 파티션마다 별도의 인덱스.
  - 파티션 교체/드롭 시 인덱스를 같이 관리하기 쉬움.
- 설계:
  - **파티션 키가 WHERE/OJB**에서 매우 중요한 경우, 로컬 인덱스 선호.
  - 일부 특정 Access Path를 위해 Global 인덱스를 추가로 둘 수 있다(조심스럽게).

---

## 13. B-Tree vs Bitmap – 설계 레벨에서의 선택

(비트맵 인덱스 글에서 이미 상세히 다뤘으므로 인덱스 설계 관점 포인트만 정리.)

### 13.1 B-Tree 인덱스 선택 기준

- OLTP·동시성 높은 환경.
- 카디널리티가 중~고, DML 빈번.
- 범위/정렬/Top-N/조인 키 등 전반적인 Access Path.

### 13.2 Bitmap 인덱스 선택 기준

- DW/리포트, 읽기 위주.
- **저/중복수 컬럼** (수십~수백 distinct 수준).
- 다차원 필터(AND/OR/NOT)를 비트 연산으로 빠르게 결합해야 할 때.

### 13.3 혼합 전략

- 날짜/키 범위 탐색은 B-Tree.
- 카테고리·지역·상태 등의 저카디널리티 컬럼은 Bitmap.
- Star Schema에서는 **Bitmap Join Index**까지 고려.

---

## 14. 모니터링·리팩터링 절차

### 14.1 인덱스 사용도 파악

```sql
-- 어떤 인덱스가 실제로 자주 쓰이는지 살펴보기(간이)
SELECT object_name, COUNT(*) AS used_in_plans
FROM   v$sql_plan
WHERE  object_owner = USER
AND    object_name IN (SELECT index_name FROM user_indexes)
GROUP  BY object_name
ORDER  BY used_in_plans DESC;
```

### 14.2 인덱스 품질 점검

```sql
SELECT index_name, blevel, leaf_blocks, distinct_keys,
       clustering_factor, num_rows, leaf_blocks - DISTINCT_KEYS AS approx_dup
FROM   user_indexes
WHERE  table_name = 'SO';
```

- `blevel`이 지나치게 큰지.
- `clustering_factor`가 `num_rows`에 너무 근접하지는 않는지.
- 필요 시 `ALTER INDEX ... COALESCE`(B-Tree) 또는 `REBUILD`로 재구성.

### 14.3 인덱스 수 관리

- **유사한 인덱스**를 찾아 통합.

```sql
SELECT index_name, column_position, column_name
FROM   user_ind_columns
WHERE  table_name = 'SO'
ORDER  BY index_name, column_position;
```

- `(cust_id, order_dt)`와 `(cust_id, order_dt, status)`가 동시에 있다면,
  후자가 전자를 어느 정도 **상위 호환**할 수 있는지 검토.

---

## 15. 케이스 스터디 – 단계별 인덱스 설계

### 15.1 요구사항

1. 고객 상세 화면:
   - 최근 6개월 주문 내역 (Top-N 50).
   - 고객별 상태별 집계(NEW/PAID/SHIP/…).
2. 운영 모니터링 화면:
   - 최근 1일 동안 PAID 주문 100건.
   - 날짜/상태별 집계.

### 15.2 핫 쿼리 추출

```sql
-- Q1: 고객 상세 최근 주문
SELECT order_id, order_dt, amount, status
FROM   so
WHERE  cust_id  = :cid
AND    order_dt >= ADD_MONTHS(TRUNC(SYSDATE), -6)
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 50 ROWS ONLY;

-- Q2: 고객 상태별 집계
SELECT status, COUNT(*)
FROM   so
WHERE  cust_id = :cid
GROUP  BY status;

-- Q3: 최근 1일 PAID Top-N
SELECT order_id, cust_id, amount
FROM   so
WHERE  order_dt >= SYSDATE - 1
AND    status   = 'PAID'
ORDER  BY order_dt DESC, order_id DESC
FETCH FIRST 100 ROWS ONLY;

-- Q4: 날짜/상태별 집계
SELECT TRUNC(order_dt) AS d, status, COUNT(*), SUM(amount)
FROM   so
WHERE  order_dt >= TRUNC(SYSDATE) - 7
GROUP  BY TRUNC(order_dt), status;
```

### 15.3 설계안 만들기

- Q1, Q2는 `cust_id`가 선두로 필요.
- Q3, Q4는 `order_dt` / `status` 조합이 중요.

#### 인덱스 후보

1. `so_c_dt_desc_stat`  
   `(cust_id, order_dt DESC, order_id DESC, status, amount)`  
   → Q1, Q2, 일부 Q4 활용 가능.

2. `so_dt_desc_stat`  
   `(order_dt DESC, status, order_id DESC, cust_id)`  
   → Q3, Q4에 유리.

결국:

```sql
CREATE INDEX so_c_dt_desc_stat
ON so(cust_id, order_dt DESC, order_id DESC, status, amount);

CREATE INDEX so_dt_desc_stat
ON so(order_dt DESC, status, order_id DESC, cust_id);
```

### 15.4 검증

각 쿼리를 실행하고, `ALLSTATS LAST`로:

- Buffers
- Reads
- TempSpc
- Sort 유무
- Access/Filter Predicates

등을 비교한다.

Q1/Q2에서 `so_c_dt_desc_stat`가 잘 쓰이고,  
Q3/Q4에서 `so_dt_desc_stat`가 잘 쓰이며,  
두 인덱스를 추가했을 때 DML 성능에 큰 영향이 없다면 채택한다.

---

## 16. 팀용 인덱스 설계 기준 템플릿(정리)

### 16.1 워크로드 인벤토리

- **비즈니스 시나리오**: 주문 목록, 상세, 대시보드, 배치 리포트 등.
- **핫 쿼리 TOP N**: SQL, 호출 빈도, SLA.
- **데이터 프로파일**:
  - 행 수, 증가율,
  - 핵심 컬럼 `num_distinct`, `histogram`,
  - 인덱스 `clustering_factor`.

### 16.2 인덱스 설계안

- 설계안#1:
  - 컬럼/순서/방향
  - 의도: 선두 등치, 정렬 흡수, 커버링 등.
- 설계안#2:
  - 대안 패턴.
- 상충 관계: 어떤 쿼리와 충돌하는지 서술.

### 16.3 실측 평가

- 각 설계안별로 핫 쿼리를 실행:
  - Buffers/Reads
  - TempSpc
  - Elapsed
  - DML 1만건 수행 시 비용
- 채택 / 보류 / 폐기 결정.

### 16.4 운영 정책

- 통계 수집 주기, 히스토그램 정책.
- 바인드 사용 방식, ACS(Adaptive Cursor Sharing) 사용 여부.
- 인덱스 REBUILD/COALESCE 기준.
- 미사용 인덱스 정리 주기.

---

## 17. 빠른 체크리스트 요약

- [ ] **핫 경로** WHERE/JOIN/ORDER BY를 **선두 등치 + 정렬 흡수**로 맞췄는가?
- [ ] Top-N/페이징은 **DESC/ASC 인덱스**와 결합해 **Stopkey**를 쓰게 했는가?
- [ ] `TRUNC`, `TO_CHAR`, `TO_NUMBER` 등 **컬럼 가공**을 피했는가? 필요 시 가상 컬럼/함수기반 인덱스를 썼는가?
- [ ] 커버링 인덱스는 **핫 리포트/핫 API**에만 제한적으로 적용했는가?
- [ ] `num_distinct`, `density`, `clustering_factor`를 확인했는가?
- [ ] GROUP BY / DISTINCT / ORDER BY 소트가 인덱스로 대체 가능한지 검토했는가?
- [ ] FK 컬럼에 필요한 인덱스를 모두 만들었는가(삭제/머지 고려)?
- [ ] 인덱스 수가 과도하지 않은가(유사 인덱스 통합/미사용 제거)?
- [ ] 변경 전/후 `DBMS_XPLAN.DISPLAY_CURSOR(...,'ALLSTATS LAST +IOSTATS +MEMSTATS')`로 **숫자가 좋아졌는지** 확인했는가?

---

## 18. 마무리

- 인덱스 설계의 두 축:

  1. **핫 쿼리**의 선두 등치로 **짧은 진입로** 만들기.
  2. **정렬·Top-N·집계**를 인덱스로 흡수해 **소트 제거**하기.

- 나머지는

  - 선택도·스큐,
  - 커버링의 가치 vs DML 비용,
  - OLTP vs DW,
  - 파티셔닝/Bitmap/병렬

  사이의 **트레이드오프**다.

- “공식”이 아니라 **업무 패턴을 데이터 구조로 번역하는 설계 행위**이며,
  그 결과의 옳고 그름은 항상 **숫자(실제 실행통계)**가 말해 준다.

> 좋은 인덱스는 “운”이 아니라  
> **핫 쿼리의 패턴을 정확히 읽고, 랜덤 I/O와 소트를 구조적으로 없애는 선택**에서 시작된다.  
> 튜닝의 마지막은 언제나 `ALLSTATS LAST`다.