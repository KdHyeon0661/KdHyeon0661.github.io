---
layout: post
title: 영상처리 - 외곽선 추적
date: 2025-10-04 19:25:23 +0900
category: 영상처리
---
# 외곽선 추적 (Contour Tracing)

## 1) 외곽선 추적 기법(개념 정리)

### 1.1 정의와 표기
이진 영상 \(B(x,y)\in\{0,255\}\) 에서 전경 픽셀 집합의 경계 곡선을 **연속 순서의 점** \(\{p_0,p_1,\dots,p_{n-1}\}\)로 얻습니다.  
방향을 양방향 중 하나로 고정하면(시계/반시계), 외곽선은 **폐곡선**(시작점으로 귀환)입니다.

### 1.2 연결성(4/8)과 체인 코드
- **4-연결**: 상/하/좌/우 이웃(Manhattan)  
- **8-연결**: 대각 포함(상하좌우 + 4대각)  
프리먼 8-방향 체인 코드: 아래와 같이 방향 인덱스를 둡니다(시계방향 +1):
\[
\begin{array}{c|c}
\text{dir} & (\Delta x,\Delta y) \\ \hline
0 & ( +1, 0)~E \\
1 & ( +1,+1)~SE \\
2 & ( 0,+1)~S \\
3 & (-1,+1)~SW \\
4 & (-1, 0)~W \\
5 & (-1,-1)~NW \\
6 & ( 0,-1)~N \\
7 & ( +1,-1)~NE
\end{array}
\]

### 1.3 고전적 외곽선 추적(요지)
대표적인 방법은 **Moore-Neighborhood tracing**(무어 이웃 추적):  
1) 래스터 스캔(좌→우, 상→하)으로 **시작점**을 찾습니다.  
   - **외곽(outer)**: \(B(x,y)=255\) 이면서 \(B(x-1,y)=0\) (왼쪽이 배경)  
2) 시작점 \(p_0\)의 “직전 위치” \(q_0\) 를 \(p_0\)의 서쪽으로 둡니다(\(q_0=(x-1,y)\)).  
3) 현재 점 \(p\), 직전 점 \(q\)에서, \(p\)의 8-이웃을 **\(q\to p\) 방향 바로 다음 이웃부터 시계로** 검사하여 _처음 만나는 전경 이웃_ \(r\)을 다음 점으로 삼습니다.  
4) \((q,p)\leftarrow(p,r)\) 로 갱신하고 \(p\)를 외곽선에 push.  
5) \((p,q)==(p_0,q_0)\) 로 돌아오면 종료.  
6) 같은 방식으로 나머지 시작점을 계속 추적.

> **특징**: 간단·빠름, **정렬된(contiguous) 경계 점열**과 **체인 코드**를 함께 얻기 쉬움.  
> **참고**: OpenCV의 `findContours`는 Suzuki–Abe(1985)를 구현(홀 외곽/내부 외곽까지 완전 처리). 본 장의 구현은 직관적 **Moore 추적(외곽 위주)** 로, 실전 사용에 충분하고 코드가 짧습니다.

---

## 2) 구현 — **Moore 외곽선 추적 + 체인 코드 + 오버레이**

```cpp
// ContourTracing.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <cmath>
#include <algorithm>
#include <string>
#include <limits>
#include <windows.h>
#include "IppDib.h"
#include "IppImage.h"

// ===== 공통 유틸 =====
inline uint8_t clamp_u8(int v){ return (uint8_t)(v<0?0:(v>255?255:v)); }
inline int clampi(int v,int lo,int hi){ return v<lo?lo:(v>hi?hi:v); }

// BGRA32 → 8비트 이진(0/255). 이미 이진이면 그대로, 아니면 >0 => 255 처리.
inline void DibToBinary8(const IppDib& dib, IppImage<uint8_t>& bin){
    bin.create(dib.width(), dib.height());
    for (int y=0; y<dib.height(); ++y){
        const uint8_t* s=(const uint8_t*)dib.bits() + (size_t)y*dib.stride();
        uint8_t* d=bin.row(y);
        for (int x=0; x<dib.width(); ++x){
            uint8_t B=s[x*4+0], G=s[x*4+1], R=s[x*4+2];
            d[x] = (uint8_t)((R|G|B) ? 255 : 0);
        }
    }
}

// ===== 외곽선 자료구조 =====
struct Contour {
    std::vector<POINT> points;     // 순서 있는 경계 픽셀 좌표(정수)
    std::vector<uint8_t> chain;    // Freeman 8-dir chain code(0..7)
    bool clockwise = true;         // 시계/반시계(참고용)
    bool isHole   = false;         // (본 구현은 기본 false; 확장은 가능)
    int length() const { return (int)points.size(); }
};

struct ContourSet {
    std::vector<Contour> contours;
};

// ===== 드로잉(Bresenham) =====
inline void DrawLineOnDib(IppDib& d, int x0,int y0,int x1,int y1, uint8_t R=255,uint8_t G=64,uint8_t B=64){
    auto P=[&](int x,int y){
        if ((unsigned)x>=(unsigned)d.width() || (unsigned)y>=(unsigned)d.height()) return;
        uint8_t* p=(uint8_t*)d.bits() + (size_t)y*d.stride() + x*4;
        p[0]=B; p[1]=G; p[2]=R; p[3]=255;
    };
    int dx=std::abs(x1-x0), sx=x0<x1?1:-1;
    int dy=-std::abs(y1-y0), sy=y0<y1?1:-1;
    int err=dx+dy;
    while(true){
        P(x0,y0);
        if (x0==x1 && y0==y1) break;
        int e2=2*err;
        if (e2>=dy){ err+=dy; x0+=sx; }
        if (e2<=dx){ err+=dx; y0+=sy; }
    }
}
inline void DrawPolylineOnDib(IppDib& d, const std::vector<POINT>& pts,
                              uint8_t R=255,uint8_t G=64,uint8_t B=64, bool closed=true){
    if (pts.size()<2) return;
    for (size_t i=1;i<pts.size();++i)
        DrawLineOnDib(d, pts[i-1].x, pts[i-1].y, pts[i].x, pts[i].y, R,G,B);
    if (closed) DrawLineOnDib(d, pts.back().x, pts.back().y, pts.front().x, pts.front().y, R,G,B);
}

// ===== Moore 외곽선 추적 핵심 =====
enum class Connectivity { C4, C8 };

struct TraceOptions {
    Connectivity conn = Connectivity::C8; // 8-연결 기본
    int minLen = 10;                      // 너무 짧은 외곽선 제거
    bool overlay = true;                  // 결과 오버레이
    uint8_t R=255,G=64,B=64;              // 오버레이 색
};

// 8방향(시계): 0E,1SE,2S,3SW,4W,5NW,6N,7NE
static const int DX8[8]={+1,+1,0,-1,-1,-1,0,+1};
static const int DY8[8]={ 0,+1,+1,+1, 0,-1,-1,-1};

// dir(p->q) 구하기
inline int DirFromTo(int x0,int y0,int x1,int y1){
    int dx = x1-x0, dy=y1-y0;
    for(int k=0;k<8;++k) if (DX8[k]==dx && DY8[k]==dy) return k;
    return 0; // fallback
}

// Moore 이웃에서 다음 전경 이웃 r을 찾는 루프
inline bool NextForegroundFrom(const IppImage<uint8_t>& bin, int W,int H,
                               int px,int py,int& qx,int& qy,
                               int& nx,int& ny, int& outDir, Connectivity conn)
{
    // p->q 방향
    int dir = DirFromTo(px,py,qx,qy);
    // 검사 시작 방향: (dir+1)%m (q를 기준으로 다음 이웃부터 시계 검사)
    const int m = (conn==Connectivity::C8)? 8 : 4;
    auto stepK=[&](int k)->std::pair<int,int>{
        if (m==8){ return {DX8[k],DY8[k]}; }
        // 4-연결 {0,2,4,6}만 사용
        static const int K4[4]={0,2,4,6};
        int kk=K4[k&3];
        return {DX8[kk],DY8[kk]};
    };
    auto toK4=[&](int d8)->int{ // 8방향을 0,2,4,6 중 가장 가까운 4방향 인덱스로 정규화
        static const int near4[8]={0,0,2,2,4,4,6,6};
        return near4[d8];
    };

    int k0 = (m==8)? ( (dir+1)&7 ) : ( ((toK4(dir)/2)+1)&3 ); // 시작 인덱스
    for (int i=0;i<m;++i){
        int ki = (k0 + i) % m;
        auto [dx,dy] = stepK(ki);
        int tx=px+dx, ty=py+dy;
        if ((unsigned)tx<(unsigned)W && (unsigned)ty<(unsigned)H && bin.row(ty)[tx]){
            // 발견
            nx=tx; ny=ty;
            // 출력용 dir(8방향 체인코드)
            int dir8 = DirFromTo(px,py,tx,ty);
            outDir = dir8;
            // q <- p
            qx=px; qy=py;
            return true;
        }
    }
    return false; // 주변에 전경 없음(단절) → 실패
}

// 외곽선 하나 추적
inline Contour TraceOneContour(const IppImage<uint8_t>& bin, int W,int H, int sx,int sy, Connectivity conn)
{
    Contour c; c.clockwise=true; c.isHole=false;
    // 시작점 p0, q0(서쪽 배경)
    int px=sx, py=sy;
    int qx=sx-1, qy=sy; // west
    if (qx<0) { qx=px; qy=py; } // 이미지 왼쪽 경계에 붙은 경우 방어
    c.points.push_back(POINT{px,py});

    int nx,ny,dir;
    // 첫 이동
    if (!NextForegroundFrom(bin,W,H,px,py,qx,qy,nx,ny,dir,conn)){
        // 고립 픽셀: 점 1개로 보고 종료
        return c;
    }
    px=nx; py=ny; c.points.push_back(POINT{px,py}); c.chain.push_back((uint8_t)dir);

    const int sx0=sx, sy0=sy, qx0=qx, qy0=qy;
    // 반복
    for (int guard=0; guard<W*H*4; ++guard){
        if (!NextForegroundFrom(bin,W,H,px,py,qx,qy,nx,ny,dir,conn)) break;
        // 종료조건: p==p0 && q==q0
        if (nx==sx0 && ny==sy0 && px==sx0 && py==sy0 && qx==qx0 && qy==qy0){
            // 마지막 스텝 기록(폐곡)
            c.chain.push_back((uint8_t)dir);
            break;
        }
        px=nx; py=ny;
        c.points.push_back(POINT{px,py});
        c.chain.push_back((uint8_t)dir);
        // 안전 종료: 너무 길면 끊기
        if ((int)c.points.size() > W*H*2) break;
    }
    return c;
}

// 시작점 후보: B(x,y)=255 && B(x-1,y)=0 (왼쪽이 배경) → 외곽 시작
inline bool IsOuterStart(const IppImage<uint8_t>& bin, int x,int y){
    if (!bin.row(y)[x]) return false;
    if (x==0) return true; // 좌측 경계면 시작으로 간주
    return bin.row(y)[x-1]==0;
}

// 메인: 전체 외곽선 추적(outer 위주)
inline ContourSet TraceContours(const IppImage<uint8_t>& bin, const TraceOptions& opt){
    const int W=bin.width(), H=bin.height();
    // 이미 시작으로 처리한 픽셀 체크(outer start 기준)
    IppImage<uint8_t> started(W,H); started.fill(0);
    ContourSet out;

    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            if (!IsOuterStart(bin,x,y)) continue;
            if (started.row(y)[x]) continue;
            // 추적
            Contour c = TraceOneContour(bin,W,H,x,y,opt.conn);
            if (c.length() >= opt.minLen){
                out.contours.push_back(c);
                // 동일 외곽선에서 다시 시작하지 않도록 경계 픽셀들에 started=1 표시
                for (auto& p : c.points) started.row(p.y)[p.x]=1;
            }
        }
    }
    return out;
}

// 체인 코드 길이 기반 주변 길이(대략, 8방향: 직선=1, 대각=√2)
inline double ChainPerimeter(const std::vector<uint8_t>& chain){
    double L=0.0;
    for (auto d: chain) L += (d%2==0)? 1.0 : 1.41421356237;
    return L;
}

// shoelace(정수 좌표 근사) — 경계 다각형 면적
inline double PolygonArea(const std::vector<POINT>& P){
    if (P.size()<3) return 0.0;
    long long s=0;
    for (size_t i=0;i<P.size();++i){
        auto& a=P[i]; auto& b=P[(i+1)%P.size()];
        s += 1LL*a.x*b.y - 1LL*b.x*a.y;
    }
    return 0.5*std::fabs((double)s);
}

// 오버레이 생성(원본 위에 외곽선 폴리라인)
inline IppDib OverlayContours(const IppDib& src, const ContourSet& cs, uint8_t R,uint8_t G,uint8_t B){
    IppDib out = src; // 복사
    for (auto& c : cs.contours){
        DrawPolylineOnDib(out, c.points, R,G,B, /*closed=*/true);
    }
    return out;
}

// 고수준 API: DIB → 외곽선 → (선택) 오버레이 DIB
inline bool RunContourTracing(const IppDib& in, IppDib& outOverlay,
                             ContourSet& contours, const TraceOptions& opt)
{
    if (!in) return false;
    IppImage<uint8_t> bin; DibToBinary8(in, bin);
    contours = TraceContours(bin, opt);
    if (opt.overlay){
        outOverlay = OverlayContours(in, contours, opt.R,opt.G,opt.B);
    }
    return true;
}
```

> 구현 포인트  
> - **시작점 판정**을 “왼쪽이 배경인 전경 픽셀”로 두면 **한 외곽선당 하나의 고유 시작점**을 얻습니다(래스터 순서).  
> - `NextForegroundFrom`은 \(q\to p\) 방향 바로 다음 이웃부터 시계로 검사(무어 규칙).  
> - 체인 코드로 **둘레(직선=1, 대각=√2)** 를 근사하고, 점열로 **shoelace 면적**을 구합니다(픽셀 중심 근사).  
> - 본 구현은 **외곽(outer) 위주**입니다. “내부 구멍(hole)” 외곽은 **레이블링(13.2절)** 과 조합해 배경-라벨 기반으로 손쉽게 확장할 수 있습니다(확장 팁 참조).

---

## 3) UI — **외곽선 추적** 메뉴/대화 상자

### 3.1 리소스 ID

```cpp
// resource.h (추가)
#define ID_MENU_CONTOUR_TRACE          86010

#define IDD_CONTOUR_TRACE_DLG          4300
#define IDC_RAD_CT_4                   4301
#define IDC_RAD_CT_8                   4302
#define IDC_EDIT_CT_MINLEN             4303
#define IDC_CHK_CT_OVERLAY             4304
#define IDC_EDIT_CT_R                  4305
#define IDC_EDIT_CT_G                  4306
#define IDC_EDIT_CT_B                  4307
#define IDC_STC_CT_SUMMARY             4308
```

### 3.2 RC

```rc
// ImageTool.rc (추가)
POPUP "&Analyze"
BEGIN
    MENUITEM "Trace Contours...\tCtrl+T", ID_MENU_CONTOUR_TRACE
END

IDD_CONTOUR_TRACE_DLG DIALOGEX 0,0, 280, 160
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Contour Tracing (Moore)"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Connectivity", -1, 12, 10, 120, 40
    AUTORADIOBUTTON "4-connected", IDC_RAD_CT_4,  22, 24, 70, 10, WS_TABSTOP
    AUTORADIOBUTTON "8-connected", IDC_RAD_CT_8,  22, 36, 70, 10

    LTEXT "Min length:", -1, 150, 18, 54, 10
    EDITTEXT IDC_EDIT_CT_MINLEN, 210, 16, 40, 14, ES_NUMBER

    AUTOCHECKBOX "Overlay on image", IDC_CHK_CT_OVERLAY, 12, 58, 100, 12
    LTEXT "Color (R,G,B):", -1, 130, 58, 60, 10
    EDITTEXT IDC_EDIT_CT_R, 196, 56, 18, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_CT_G, 218, 56, 18, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_CT_B, 240, 56, 18, 14, ES_NUMBER

    LTEXT "Summary:", -1, 12, 86, 50, 10
    LTEXT "", IDC_STC_CT_SUMMARY, 62, 86, 188, 32

    DEFPUSHBUTTON "Run", IDOK,  164, 126, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 214, 126, 44, 16
END
```

### 3.3 대화 상자 코드 & 메뉴 핸들러

```cpp
// ContourTraceDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "ContourTracing.hpp"

// 앱 제공 헬퍼(여타 장과 동일 스타일)
struct DocRef { HWND hwnd; IppDib* dib; std::wstring title; };
std::vector<DocRef> GetOpenDocs();
HWND CreateDocWindowFromDib(const IppDib& dib, const std::wstring& title);

class ContourTraceDlg {
public:
    ContourTraceDlg(HWND owner, IppDib& target) : owner_(owner), target_(target) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM);

    void Run(HWND h);

private:
    HWND owner_{};
    IppDib& target_;
};
```

```cpp
// ContourTraceDlg.cpp
#include "ContourTraceDlg.h"

INT_PTR ContourTraceDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_CONTOUR_TRACE_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK ContourTraceDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        return ((ContourTraceDlg*)l)->OnInit(h); }
    auto* self=(ContourTraceDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w);
    return FALSE;
}
INT_PTR ContourTraceDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_CT_4, IDC_RAD_CT_8, IDC_RAD_CT_8);
    SetDlgItemInt(h, IDC_EDIT_CT_MINLEN, 10, FALSE);
    CheckDlgButton(h, IDC_CHK_CT_OVERLAY, BST_CHECKED);
    SetDlgItemInt(h, IDC_EDIT_CT_R, 255, FALSE);
    SetDlgItemInt(h, IDC_EDIT_CT_G, 64,  FALSE);
    SetDlgItemInt(h, IDC_EDIT_CT_B, 64,  FALSE);
    SetDlgItemTextW(h, IDC_STC_CT_SUMMARY, L"(ready)");
    return TRUE;
}
void ContourTraceDlg::Run(HWND h){
    BOOL ok=FALSE;
    int minLen = GetDlgItemInt(h, IDC_EDIT_CT_MINLEN, &ok, FALSE); if (!ok || minLen<1) minLen=1;
    int R = GetDlgItemInt(h, IDC_EDIT_CT_R, &ok, FALSE); R=clampi(R,0,255);
    int G = GetDlgItemInt(h, IDC_EDIT_CT_G, &ok, FALSE); G=clampi(G,0,255);
    int B = GetDlgItemInt(h, IDC_EDIT_CT_B, &ok, FALSE); B=clampi(B,0,255);

    TraceOptions opt;
    opt.conn = (IsDlgButtonChecked(h, IDC_RAD_CT_4)==BST_CHECKED)? Connectivity::C4 : Connectivity::C8;
    opt.minLen = minLen;
    opt.overlay = (IsDlgButtonChecked(h, IDC_CHK_CT_OVERLAY)==BST_CHECKED);
    opt.R=(uint8_t)R; opt.G=(uint8_t)G; opt.B=(uint8_t)B;

    ContourSet cs; IppDib out;
    if (!RunContourTracing(target_, out, cs, opt)){
        MessageBoxW(h, L"실행 실패: 입력 영상을 확인하세요.", L"Contour", MB_ICONERROR);
        return;
    }
    // 요약 표시
    int n=(int)cs.contours.size();
    double avgL=0.0; for (auto& c:cs.contours) avgL+=c.length(); if (n) avgL/=n;
    wchar_t buf[128]; wsprintfW(buf, L"%d contours, avgLen=%.1f", n, avgL);
    SetDlgItemTextW(h, IDC_STC_CT_SUMMARY, buf);

    // 결과 반영
    if (opt.overlay){
        CreateDocWindowFromDib(out, L"Contours (overlay)");
    }else{
        // 오버레이 없이도 새 창으로 원본을 복제하고 통계만 확인할 때 사용
        CreateDocWindowFromDib(target_, L"Contours (no overlay)");
    }

    // (선택) 상위 몇 개 통계 출력
    if (!cs.contours.empty()){
        std::wstring msg=L"Perimeter / Area (approx):\n";
        int cnt=0;
        for (auto& c: cs.contours){
            double peri = ChainPerimeter(c.chain);
            double area = PolygonArea(c.points);
            wchar_t line[160];
            wsprintfW(line, L" - C%d: L=%d, P=%.2f, A=%.1f\n", ++cnt, (int)c.points.size(), peri, area);
            msg+=line; if (cnt>=10) break;
        }
        MessageBoxW(owner_, msg.c_str(), L"Contour Stats", MB_OK|MB_ICONINFORMATION);
    }
}
INT_PTR ContourTraceDlg::OnCommand(HWND h, WPARAM w){
    switch(LOWORD(w)){
    case IDOK:    Run(h); EndDialog(h, IDOK); return TRUE;
    case IDCANCEL: EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

```cpp
// main_multiwin.cpp (발췌)
#include "ContourTraceDlg.h"

// ...
case ID_MENU_CONTOUR_TRACE:
    if (st && st->dib){
        ContourTraceDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            UpdateStatusBasic(hWnd, st); // 상태바에 contour 개수/평균 길이 등
        }
    }
    return 0;
```

---

## 4) 예제와 현장 시나리오

### 예제 A) **동전 외곽선 추출 → 둘레/면적 측정**
- **상황**: 균일 배경, 잘 이진화된 동전 여러 개.  
- **절차**:  
  1) `Binary → Binarize…`(13.1) 로 전경=동전(255), 배경=0 확보  
  2) `Analyze → Trace Contours…` → **8-connected**, **Min length=50**, Overlay=ON  
  3) `Run` → 새 창에 외곽선 폴리라인이 **빨간색**으로 오버레이  
- **결과**: 각 동전 외곽선의 **둘레/면적**을 목록으로 확인. 외곽선 품질 저하 시 **미디언/가우시안**(8.5/8.2)으로 전처리.

### 예제 B) **문서 블롭에서 외곽선만 필요(벡터화 전처리)**
- **상황**: 도면/스캔에서 객체 경계의 **윤곽선 폴리라인**을 얻어 SVG/측정에 사용.  
- **동작**: 4-connected, Min length=20, Overlay=ON → 경계가 직교망에 더 근접(사각형 계열에 유리).  
- **결과**: 후속 RDP(랭–더글라스–퍼커; 단순화) 적용하기 쉬운 **순서 있는 점열** 확보.

### 예제 C) **PCB/패턴 검사 — 최외곽만 분석**
- **상황**: 작은 내부 구멍(홀)은 무시하고 **최외곽**만(브리지 여부 평가).  
- **동작**: 8-connected, Min length를 크게(잡음 배제), Overlay=ON.  
- **결과**: 최외곽만 따서 **연속성/간극** 평가 가능.

---

## 5) 정확성·성능·확장 팁

### 5.1 정확성
- **시작점 판정**(왼쪽 배경)은 래스터 순서에서 외곽당 **유일한 엔트리**가 되어 중복 추적을 방지합니다.  
- **홀(내부 경계)** 까지 필요하면:  
  - (간단) 13.2절 **레이블링**으로 객체별 라벨을 얻은 뒤, 각 라벨 마스크에 대해 **배경=0/전경=해당 라벨**로 외곽 추적을 반복하면 외곽/내부 경계를 모두 뽑을 수 있습니다.  
  - (정석) Suzuki–Abe(Border following)를 구현하면 외곽/홀을 한 번의 패스로 조직적으로 탐지합니다(구현량↑).

### 5.2 성능
- Moore 추적은 보통 **경계 픽셀 수에 비례**. 큰 영상이라도 외곽선이 적으면 매우 빠릅니다.  
- **캐시 친화적**: 시작점 탐색은 래스터 1패스, 추적은 국소 8-이웃 접근.  
- 멀티스레딩은 시작점 탐색을 타일로 분할할 수 있으나, 같은 컴포넌트의 여러 시작점 충돌에 주의(현재 구현은 한 외곽당 하나의 시작점이므로 안전).

### 5.3 후처리
- **폴리라인 단순화**(RDP)로 점 수를 줄여 벡터화/표시 성능 개선.  
- **서브픽셀 세분화**(Marching Squares)로 픽셀 경계 중간 좌표(0.5 보정)를 사용하면 더 매끄러운 둘레/면적 근사 가능.

---

## 6) 빠른 자가 테스트

```cpp
// test_contour_tracing.cpp
#include <cassert>
#include "IppDib.h"
#include "ContourTracing.hpp"

int main(){
    // 64x48: 두 개의 사각형 전경
    IppDib dib; dib.create(64,48,32);
    // 배경 0
    for(int y=0;y<48;++y){
        uint8_t* d=(uint8_t*)dib.bits() + y*dib.stride();
        for(int x=0;x<64;++x){ d[x*4+0]=d[x*4+1]=d[x*4+2]=0; d[x*4+3]=255; }
    }
    auto fill=[&](int x0,int y0,int x1,int y1){
        for(int y=y0;y<=y1;++y){
            uint8_t* d=(uint8_t*)dib.bits() + y*dib.stride();
            for(int x=x0;x<=x1;++x){ d[x*4+0]=d[x*4+1]=d[x*4+2]=255; }
        }
    };
    fill(6,6,22,22); fill(30,10,52,28);

    TraceOptions opt; opt.conn=Connectivity::C8; opt.minLen=10; opt.overlay=false;
    ContourSet cs; IppDib ov;
    bool ok = RunContourTracing(dib, ov, cs, opt); assert(ok);
    // 사각형 2개 → 외곽 2개
    assert((int)cs.contours.size()==2);
    // 체인코드 길이/면적이 양수
    for (auto& c:cs.contours){
        assert(!c.chain.empty());
        assert(ChainPerimeter(c.chain)>0.0);
        assert(PolygonArea(c.points)>0.0);
    }
    return 0;
}
```

---

## 7) 요약
- **Moore 이웃 추적**은 간단하면서도 강력한 **외곽선 순서화** 방법으로, 프리먼 **체인 코드**까지 동시에 얻을 수 있습니다.  
- 본 장의 코드는 **외곽(outer)** 위주이며, 필요 시 13.2절 레이블링과 결합해 **내부 경계(holes)** 도 쉽게 확장 가능합니다.  
- UI(연결성/최소 길이/오버레이 색)를 통해 즉시 실무에 적용할 수 있으며, 둘레·면적 등 **형상 측정**의 기본 발판을 제공합니다.