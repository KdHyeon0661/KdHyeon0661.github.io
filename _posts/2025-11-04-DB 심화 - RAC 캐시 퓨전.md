---
layout: post
title: DB 심화 - RAC 캐시 퓨전
date: 2025-11-04 20:25:23 +0900
category: DB 심화
---
# Oracle RAC 캐시 퓨전: 전송 시나리오 완전 해부

> **핵심 요약**  
> Oracle RAC의 캐시 퓨전(Cache Fusion)은 디스크 I/O 대신 인스턴스 간 네트워크(인터커넥트)를 통해 블록을 직접 주고받아 데이터 일관성과 성능을 보장하는 핵심 메커니즘입니다. 효율적인 RAC 운영을 위해서는 다양한 전송 시나리오를 이해하고 최적화하는 것이 중요합니다.

---

## 테스트 환경 구성

### 기본 용어 정리
- **CR 블록(Consistent Read Block)**: 특정 시점(SCN)의 읽기 일관성을 보장하는 블록 버전
- **Current 블록**: 최신 버전의 블록으로, 클러스터 전체에 단 하나만 존재
- **PI(Past Image)**: Current 블록을 다른 인스턴스로 전송할 때 보내는 쪽에 남기는 이전 버전 스냅샷
- **마스터 인스턴스**: 특정 블록의 리소스 메타데이터를 관리하는 인스턴스

### 테스트 테이블 생성
```sql
-- RAC 환경에서 동시 액세스 테스트용 테이블
DROP TABLE rac_orders PURGE;

CREATE TABLE rac_orders (
  order_id   NUMBER PRIMARY KEY,
  cust_id    NUMBER NOT NULL,
  amount     NUMBER(10,2),
  status     VARCHAR2(8),
  pad        VARCHAR2(200)
);

-- 샘플 데이터 삽입 (100만 건)
INSERT /*+ APPEND */ INTO rac_orders
SELECT level, MOD(level, 50000)+1, ROUND(DBMS_RANDOM.VALUE(1,9999),2),
       CASE MOD(level,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'OK'
                         WHEN 2 THEN 'CXL' ELSE 'HOLD' END,
       RPAD('x',200,'x')
FROM dual CONNECT BY level <= 1000000;
COMMIT;

-- 인덱스 생성
CREATE INDEX ix_rac_orders_cust ON rac_orders(cust_id, order_id);

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'RAC_ORDERS', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

### 모니터링 쿼리
```sql
-- 현재 인스턴스 확인
SELECT inst_id, instance_name FROM gv$instance;

-- GC 이벤트 모니터링
SELECT inst_id, event, COUNT(*) samples
FROM   gv$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
AND    session_type = 'FOREGROUND'
AND    event LIKE 'gc %'
GROUP  BY inst_id, event
ORDER  BY samples DESC;

-- SQL 성능 분석
SELECT inst_id, sql_id, plan_hash_value,
       disk_reads, buffer_gets, executions
FROM   gv$sql
ORDER  BY disk_reads DESC FETCH FIRST 30 ROWS ONLY;
```

---

## 전송 없는 읽기 (No-Transfer Read)

### 개념 설명
세션이 필요한 블록을 자신이 속한 인스턴스의 버퍼 캐시에서 바로 찾을 수 있는 경우입니다. 인터커넥트를 통한 전송이 전혀 발생하지 않으므로 성능상 가장 이상적인 시나리오입니다.

### 구현 예시
```sql
-- 인스턴스 I1에서만 반복 조회
CONNECT app_user/password@svc1

-- 동일 범위 반복 조회로 버퍼 캐시 적재
SELECT /* I1 전용 액세스 */ COUNT(*)
FROM   rac_orders
WHERE  cust_id BETWEEN 100 AND 200;
```

### 성능 특징
- GC 관련 대기 이벤트(`gc cr block %`, `gc current block %`)가 거의 발생하지 않습니다
- `consistent gets`는 증가하지만 네트워크 전송 비용이 없습니다
- 단일 인스턴스 데이터베이스와 유사한 성능 특성을 보입니다

### 최적화 전략
- **서비스 기반 라우팅**: 읽기 전용 서비스와 쓰기 서비스를 분리합니다
- **파티셔닝 활용**: 데이터를 인스턴스별로 물리적으로 분리합니다
- **애플리케이션 설계**: 관련 트랜잭션을 가능한 동일 인스턴스에서 처리하도록 설계합니다

---

## 읽기/읽기 전송 (Read/Read Transfer)

### 개념 설명
한 인스턴스(I2)가 특정 블록을 읽기 위해 요청할 때, 해당 블록의 CR 버전이나 Current 버전을 보유한 다른 인스턴스(I1)로부터 전송받는 시나리오입니다.

### 작동 메커니즘
```
I2(요청자) → 마스터 인스턴스: "블록 X의 CR 버전이 필요합니다"
마스터 → I1(보유자): "블록 X의 CR 버전을 I2에 전송하세요"
I1 → I2: 블록 X의 CR 버전 전송
```

### 구현 예시
```sql
-- I1: 특정 범위 데이터를 캐시에 적재
CONNECT app_user/password@svc1
SELECT /* I1 워밍업 */ SUM(amount)
FROM   rac_orders
WHERE  cust_id BETWEEN 10000 AND 12000;

-- I2: 동일 범위 데이터 조회 (I1으로부터 전송 받음)
CONNECT app_user/password@svc2
SELECT /* I2에서 조회 */ SUM(amount)
FROM   rac_orders
WHERE  cust_id BETWEEN 10000 AND 12000;
```

### 관찰 포인트
```sql
-- 요청자(I2)의 GC 이벤트 확인
SELECT event, total_waits, time_waited_micro/1e6 as seconds
FROM   v$session_event
WHERE  sid = SYS_CONTEXT('USERENV','SID')
AND    event IN ('gc cr block 2-way','gc cr block 3-way','gc cr request','gc cr grant busy')
ORDER BY seconds DESC;
```

### 최적화 전략
- **데이터 로컬리티 강화**: 자주 함께 읽히는 데이터를 동일 인스턴스에 배치합니다
- **쿼리 최적화**: 불필요한 전체 테이블 스캔을 피하고 인덱스를 효과적으로 활용합니다
- **클러스터링 팩터 개선**: 물리적 데이터 배치를 최적화합니다

---

## 읽기/쓰기 전송 (Read/Write Transfer)

### 개념 설명
한 인스턴스(I2)가 블록을 읽기 위해 요청할 때, 해당 블록의 Current 버전을 보유한 다른 인스턴스(I1)가 변경 중인 상태여서 CR 버전을 생성하여 전송해야 하는 시나리오입니다.

### 작동 메커니즘
```
I2(요청자) → 마스터: "블록 X의 CR 버전이 필요합니다"
마스터 → I1(Current 보유자): "블록 X의 CR 버전을 생성하여 I2에 전송하세요"
I1: Current 버전에서 CR 버전 생성 (Undo 데이터 활용)
I1 → I2: 생성된 CR 버전 전송
```

### 구현 예시
```sql
-- I1: 데이터 변경 후 커밋 지연
CONNECT app_user/password@svc1
BEGIN
  UPDATE rac_orders
  SET    amount = amount * 1.01
  WHERE  cust_id BETWEEN 15000 AND 15010;
  -- 의도적으로 커밋 지연
END;
/

-- I2: 변경 중인 동일 범위 데이터 조회
CONNECT app_user/password@svc2
SELECT /* I2에서 변경 중인 데이터 조회 */ COUNT(*), SUM(amount)
FROM   rac_orders
WHERE  cust_id BETWEEN 15000 AND 15010;
```

### 성능 영향
- `gc cr block 2-way` 또는 `gc cr block 3-way` 이벤트가 증가합니다
- I1에서 CR 버전 생성에 추가적인 CPU와 시간이 소요됩니다
- 변경 직후의 빈번한 읽기 요청은 성능 저하를 유발할 수 있습니다

### 최적화 전략
- **트랜잭션 설계**: 변경 작업 후 가능한 빨리 커밋하여 Current 버전 보유 시간을 최소화합니다
- **읽기/쓰기 분리**: 변경 작업과 조회 작업을 다른 인스턴스에서 처리하도록 설계합니다
- **배치 처리**: 관련 없는 읽기 작업을 변경 작업과 분리하여 스케줄링합니다

---

## 쓰기/쓰기 전송 (Write/Write Transfer)

### 개념 설명
두 개 이상의 인스턴스가 동일한 블록을 수정하려고 할 때 발생하는 시나리오로, Current 블록의 소유권이 인스턴스 간에 빈번하게 이동합니다.

### 작동 메커니즘
```
I2(요청자) → 마스터: "블록 X의 Current 버전이 필요합니다(쓰기)"
마스터 → I1(현재 보유자): "블록 X의 Current 버전을 I2에 전송하세요"
I1 → I2: Current 버전 전송, I1은 PI(Past Image) 보관
I2: Current 버전 획득 후 데이터 수정
```

### 구현 예시
```sql
-- I1: 특정 범위 데이터 수정
CONNECT app_user/password@svc1
BEGIN
  FOR i IN 1..10 LOOP
    UPDATE rac_orders
    SET    status = 'OK'
    WHERE  cust_id BETWEEN 20000 AND 20005;
    COMMIT;
  END LOOP;
END;
/

-- I2: 동일 범위 데이터 동시 수정
CONNECT app_user/password@svc2
BEGIN
  FOR i IN 1..10 LOOP
    UPDATE rac_orders
    SET    status = 'HOLD'
    WHERE  cust_id BETWEEN 20000 AND 20005;
    COMMIT;
  END LOOP;
END;
/
```

### 성능 영향
- `gc current block 2-way` 또는 `gc current block 3-way` 이벤트가 빈번하게 발생합니다
- `gc current grant busy`와 같은 경합 이벤트가 증가할 수 있습니다
- PI(Past Image)가 누적되어 메모리 사용량이 증가합니다

### 최적화 전략
- **핫 블록 분산**: 자주 수정되는 데이터를 물리적으로 분산시킵니다
- **파티셔닝 전략**: 수정 패턴에 맞는 파티셔닝 방식을 채택합니다
- **애플리케이션 설계**: 동일한 데이터 블록에 대한 동시 수정을 최소화합니다
- **트랜잭션 관리**: 트랜잭션 크기를 적절히 조정하여 락 경합을 완화합니다

---

## 쓰기/읽기 전송 (Write/Read Transfer)

### 개념 설명
한 인스턴스(I1)가 블록을 수정 중일 때, 다른 인스턴스(I2)가 동일한 블록을 읽기 위해 요청하는 시나리오입니다.

### 작동 메커니즘
```
I2(요청자) → 마스터: "블록 X의 CR 버전이 필요합니다"
마스터 → I1(Current 보유자): "현재 보유 중인 블록 X의 CR 버전을 생성하여 I2에 전송하세요"
I1: 현재 수정 중인 블록에서 CR 버전 생성
I1 → I2: 생성된 CR 버전 전송
```

### 구현 예시
```sql
-- I1: 장시간 데이터 수정 작업 수행
CONNECT app_user/password@svc1
BEGIN
  UPDATE rac_orders
  SET    amount = amount * 1.02
  WHERE  cust_id BETWEEN 22000 AND 22050;
  
  -- 장시간 작업 시뮬레이션
  DBMS_LOCK.SLEEP(5);
  
  -- 커밋 지연
END;
/

-- I2: 수정 중인 동일 범위 데이터 조회
CONNECT app_user/password@svc2
SELECT /* I2에서 수정 중인 데이터 조회 */ SUM(amount)
FROM   rac_orders
WHERE  cust_id BETWEEN 22000 AND 22050;
```

### 성능 영향
- `gc cr block 2-way` 또는 `gc cr block 3-way` 이벤트가 발생합니다
- `gc buffer busy acquire` 이벤트가 함께 발생할 수 있습니다
- I1의 CR 버전 생성 작업으로 인해 I2의 대기 시간이 증가할 수 있습니다

### 최적화 전략
- **트랜잭션 크기 최적화**: 수정 작업의 범위와 지속 시간을 최소화합니다
- **읽기/쓰기 분리**: 실시간 조회 작업과 배치 수정 작업을 분리합니다
- **쿼리 최적화**: 조회 범위를 최소화하여 필요한 블록 수를 줄입니다
- **스케줄링**: 중요 조회 작업과 대규모 수정 작업의 시간대를 분리합니다

---

## 성능 모니터링과 트러블슈팅

### GC 이벤트 분석
```sql
-- 시스템 레벨 GC 이벤트 분석
SELECT inst_id, event, total_waits, time_waited_micro/1e6 as seconds
FROM   gv$system_event
WHERE  event LIKE 'gc %'
ORDER  BY seconds DESC FETCH FIRST 30 ROWS ONLY;
```

### 핫 오브젝트 식별
```sql
-- GC 이벤트와 연관된 오브젝트 분석
SELECT ash.inst_id, ash.event, ash.sql_id, ash.current_obj# as object_id
FROM   gv$active_session_history ash
WHERE  ash.sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
AND    ash.event LIKE 'gc %';

-- 오브젝트 상세 정보
SELECT owner, object_name, object_type
FROM   dba_objects
WHERE  object_id = :object_id;
```

### 세그먼트 통계 분석
```sql
-- 세그먼트별 GC 관련 통계
SELECT owner, object_name, statistic_name, value
FROM   gv$segment_statistics
WHERE  statistic_name IN ('gc buffer busy','gc cr blocks received','gc current blocks received')
ORDER  BY value DESC FETCH FIRST 30 ROWS ONLY;
```

### SQL 성능 프로파일링
```sql
-- 상위 SQL 식별
SELECT inst_id, sql_id, plan_hash_value,
       executions, buffer_gets, disk_reads
FROM   gv$sql
ORDER  BY executions DESC FETCH FIRST 50 ROWS ONLY;

-- 특정 SQL의 실행 계획 분석
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&sql_id', NULL, 'ALLSTATS LAST'));
```

---

## 아키텍처적 이해

### GCS와 GES
- **GCS(Global Cache Service)**: 데이터 블록의 Current/CR 버전 관리
- **GES(Global Enqueue Service)**: 라이브러리 캐시 락 등 엔큐 자원 관리
- **리소스 마스터링**: 각 블록 리소스의 마스터 인스턴스를 동적으로 관리

### 블록 상태 관리
- **SCN(시스템 변경 번호)**: 읽기 일관성을 보장하는 시간적 기준점
- **ITL(Interest Transaction List)**: 트랜잭션 정보 관리
- **Undo 관리**: CR 버전 생성에 필요한 이전 상태 정보

### 전송 방식
- **2-Way 전송**: 요청자와 보유자가 직접 블록을 주고받는 방식
- **3-Way 전송**: 마스터 인스턴스를 경유하는 방식으로 추가 홉 발생

---

## 최적화 전략 요약

### 데이터 설계 최적화
1. **파티셔닝 전략**: 핫스팟을 분산시키기 위한 효과적인 파티셔닝 설계
2. **인덱스 설계**: 자주 액세스되는 컬럼을 포함한 효율적인 인덱스 구성
3. **테이블 설계**: 관련 데이터의 물리적 군집화를 통한 로컬리티 향상

### 애플리케이션 설계 최적화
1. **서비스 기반 라우팅**: 읽기/쓰기 트래픽을 서비스별로 분리
2. **세션 풀 관리**: 인스턴스 로컬리티를 고려한 연결 관리
3. **트랜잭션 설계**: 락 경합을 최소화하는 트랜잭션 패턴

### 인프라 구성 최적화
1. **인터커넥트 최적화**: 대역폭, 지연 시간, MTU 설정 최적화
2. **메모리 관리**: 버퍼 캐시와 PGA 크기 적절히 조정
3. **I/O 최적화**: 디스크 레이아웃과 스토리지 성능 최적화

---

## 결론

Oracle RAC의 캐시 퓨전 메커니즘은 분산 데이터베이스 환경에서 데이터 일관성과 성능을 동시에 보장하는 핵심 기술입니다. 다양한 전송 시나리오를 이해하고 각 시나리오별 특성을 파악하는 것은 RAC 환경의 성능 최적화에 필수적입니다.

### 핵심 원칙
1. **로컬리티 최대화**: 가능한 한 전송 없는 읽기를 달성하도록 데이터와 트래픽을 구성합니다.
2. **트래픽 분리**: 읽기와 쓰기 트래픽을 논리적/물리적으로 분리하여 불필요한 전송을 최소화합니다.
3. **경합 최소화**: 동일한 데이터 블록에 대한 동시 액세스 패턴을 분석하고 경합을 완화합니다.

### 지속적인 관리
RAC 환경의 성능 관리는 일회성 작업이 아닌 지속적인 프로세스입니다. 정기적인 모니터링, 성능 분석, 그리고 적시의 튜닝을 통해 시스템이 최적의 상태를 유지하도록 관리해야 합니다. AWR/ASH 리포트를 활용한 체계적인 성능 분석과, 실제 운영 데이터를 기반으로 한 과학적인 의사결정이 성공적인 RAC 운영의 핵심입니다.

### 최종 목표
궁극적인 목표는 캐시 퓨전의 오버헤드를 최소화하면서도 데이터 일관성과 시스템 가용성을 유지하는 것입니다. 이를 통해 확장성 높고 성능이 우수한 데이터베이스 인프라를 구축하여 비즈니스 요구사항을 효과적으로 지원할 수 있습니다.