---
layout: post
title: DB 심화 - RAC 캐시 퓨전
date: 2025-11-04 20:25:23 +0900
category: DB 심화
---
# RAC 캐시 퓨전(Cache Fusion) 완전 해부

**— 전송 없는 읽기, 읽기/읽기 전송, 읽기/쓰기 전송, 쓰기/쓰기 전송, 쓰기/읽기 전송 (예제·트레이스·튜닝 포함)**

> **핵심 요약**
> - Oracle RAC의 **캐시 퓨전**은 **디스크가 아닌 인스턴스 간 인터커넥트(네트워크)** 로 **블록을 직접 주고받아** 일관성과 성능을 보장한다.
> - 블록은 **CR(Consistent Read)** 과 **Current** 두 모드로 다뤄지며, **Current 버전은 클러스터 전체에 1개**만 존재한다(독점 변경권).
> - 전송 시나리오별 대표 대기 이벤트
>   - **읽기용 전송**: `gc cr block 2-way/3-way`, `gc cr request`, `gc cr grant busy`
>   - **쓰기용 전송**: `gc current block 2-way/3-way`, `gc current request`, `gc current grant busy`
>   - 경합/혼잡: `gc buffer busy acquire`, `gc read wait`, `gc write wait` 등
> - **PI(Past Image)**: Current 블록을 다른 인스턴스에 넘겨줄 때 **보낸 쪽에 남기는 과거 이미지**(복구·일관성 보조). **쓰기/쓰기 이동이 잦으면 PI 증가**.
> - 튜닝의 축: **(1) 블록 공유 줄이기(데이터 핫셋 분리·파티셔닝·서비스 라우팅)**, **(2) CR/Current 경합 완화(인덱스/SQL/커밋 배치)**, **(3) 인터커넥트 품질(대역폭·지연·버퍼)**.

---

## 준비: 용어·모형·관찰 포인트

### 블록 상태와 역할

- **CR 블록**: 특정 시점(SCN)으로 **Undo**를 적용해 **읽기 일관성**을 만든 사본(여러 인스턴스에 공존 가능).
- **Current 블록**: **최신 버전, 단 1곳**(한 인스턴스)에서만 보유. 변경(UPDATE/DELETE/INSERT)은 Current에서만 가능.
- **Master(자원 마스터)**: 특정 블록의 **리소스(락) 메타데이터**를 담당하는 인스턴스(GCS/GES). 필요 시 **리매스터링**됨.
- **PI(Past Image)**: Current를 넘겨준 **보내는 쪽**이 남기는 **이전 버전 스냅샷**. 장애 복구·일관성에 활용.

### 2-Way vs 3-Way 전송

- **2-Way**: 요청자 ↔ 보유자(또는 마스터)가 **직접** 블록 전달. 지연·홉 수 적어 유리.
- **3-Way**: **마스터 ≠ 보유자**, 또는 재전송이 필요한 경우 → **마스터 안내 + 보유자 전송**으로 홉이 1번 더 늘어남.

### 대표 대기 이벤트(버전에 따라 이름 다소 차이)

- **읽기(CR)**: `gc cr block 2-way`, `gc cr block 3-way`, `gc cr request`, `gc cr grant busy`
- **쓰기(Current)**: `gc current block 2-way`, `gc current block 3-way`, `gc current request`, `gc current grant busy`
- **혼잡/경합**: `gc buffer busy acquire`, `gc read wait`, `gc write wait`, `gc remaster`

---

## 실습 환경(개념적) & 공통 스크립트

> 아래 예제는 **RAC 2노드**(Instance **I1**, **I2**)를 가정한다.
> 각 노드로 라우팅되는 **서비스**를 분리해 시나리오를 재현한다.

```sql
-- (DBA) 서비스/선호 인스턴스 예시
-- 서비스 SVC1은 I1 선호, SVC2는 I2 선호
-- 실제 구성은 srvctl 또는 DBMS_SERVICE로 관리
```

**세션 접속 예**
```sql
-- I1로 고정 접속
CONNECT app_user/password@svc1

-- I2로 고정 접속
CONNECT app_user/password@svc2
```

**관찰용 공통 뷰**
```sql
-- 현재 세션/인스턴스 확인
SELECT inst_id, instance_name FROM gv$instance;

-- 최근 10분 gc 이벤트 분포(세션별/시스템별로 변형)
SELECT inst_id, event, COUNT(*) samples
FROM   gv$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
AND    session_type = 'FOREGROUND'
AND    event LIKE 'gc %'
GROUP  BY inst_id, event
ORDER  BY samples DESC;

-- SQL별 gc 블록 수신 통계(버전별 칼럼명 차이 가능)
SELECT inst_id, sql_id, plan_hash_value,
       disk_reads, buffer_gets, executions
FROM   gv$sql
ORDER  BY disk_reads DESC FETCH FIRST 30 ROWS ONLY;
```

테스트 테이블(단순화):
```sql
-- 양 인스턴스에서 동시에 액세스할 “공유” 테이블
DROP TABLE rac_orders PURGE;

CREATE TABLE rac_orders (
  order_id   NUMBER PRIMARY KEY,
  cust_id    NUMBER NOT NULL,
  amount     NUMBER(10,2),
  status     VARCHAR2(8),
  pad        VARCHAR2(200)
);

-- 대략 100만 건 (데모 규모는 환경에 맞게)
INSERT /*+ APPEND */ INTO rac_orders
SELECT level, MOD(level, 50000)+1, ROUND(DBMS_RANDOM.VALUE(1,9999),2),
       CASE MOD(level,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'OK'
                         WHEN 2 THEN 'CXL' ELSE 'HOLD' END,
       RPAD('x',200,'x')
FROM dual CONNECT BY level <= 1000000;
COMMIT;

CREATE INDEX ix_rac_orders_cust ON rac_orders(cust_id, order_id);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'RAC_ORDERS', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## **전송 없는 읽기(No-Transfer Read)**

### 정의

- 세션이 필요한 블록을 **자기 인스턴스의 버퍼 캐시**에서 **바로** 찾는 경우.
- **인터커넥트 전송이 전혀 없다.** (RAC라도 로컬 히트면 단일 인스턴스와 동일한 비용)
- 유형
  - **로컬 CR 히트**: Undo만으로 **CR 블록**을 **로컬에서 구성** 가능.
  - **로컬 Current 히트(읽기)**: 현재 블록이 이미 로컬에 있으며 쓰기는 하지 않음.

### 예제(단순 조회: I1 단독)

```sql
-- I1
CONNECT app_user/password@svc1

-- I1에서만 반복 조회(같은 범위) → 버퍼 캐시에 적재 → 이후엔 전송 없음
SELECT /* I1만 액세스 */ COUNT(*)
FROM   rac_orders
WHERE  cust_id BETWEEN 100 AND 200;
```

**관찰**
- I1의 세션/시스템 이벤트에 `gc %` 이벤트가 **거의 없음**.
- `consistent gets` 는 증가하지만 `gc cr block %` 는 미미.

### 포인트

- **핫셋을 인스턴스별로 분리**(서비스/파티션/해시 파티셔닝 키 분배)를 잘하면 **전송 없는 읽기 비율↑** → RAC 효율 극대화.

---

## **읽기/읽기 전송(Read/Read Transfer)**

### 정의

- **I2**가 어떤 블록을 **읽기(=CR)** 로 필요로 하는데, 그 블록의 **CR 또는 Current 기반 CR 생성권**이 **I1**에 있다.
- I2가 마스터에게 요청 → 마스터가 **보유자(I1)** 를 지목 → I1이 **CR 블록**(필요 시 Current에서 CR 생성)을 **I2로 전송**.
- 대기 이벤트(요청자): **`gc cr block 2-way`**, 경우에 따라 **`3-way`**.

### 흐름(텍스트 시퀀스)

```
I2(Session) → Master: "블록 X CR 주세요"
Master → I1(Current/CR holder): "X를 CR로 I2에 보내라"
I1 → I2: "X(CR)을 전송"   ← gc cr block 2-way (I2에서 관찰)
```

### 예제(범위 조회를 I2에서, 직전에 I1이 읽어서 따끈한 상태)

```sql
-- I1: 먼저 특정 범위를 읽어 캐시 적재
CONNECT app_user/password@svc1
SELECT /* warmup on I1 */ SUM(amount)
FROM   rac_orders
WHERE  cust_id BETWEEN 10000 AND 12000;

-- I2: 같은 범위를 바로 조회 → I1 → I2로 CR 전송 발생 가능
CONNECT app_user/password@svc2
SELECT /* I2 triggers CR transfer */ SUM(amount)
FROM   rac_orders
WHERE  cust_id BETWEEN 10000 AND 12000;
```

**관찰(요청자=I2)**
```sql
SELECT event, total_waits, time_waited_micro/1e6 sec
FROM   v$session_event
WHERE  sid = SYS_CONTEXT('USERENV','SID')
AND    event IN ('gc cr block 2-way','gc cr block 3-way','gc cr request','gc cr grant busy')
ORDER BY sec DESC;
```

### 튜닝 포인트

- **같은 범위를 여러 인스턴스가 번갈아 읽지 않도록** 서비스/파티션을 **분할**.
- **정렬 일치 인덱스 + Stopkey** 로 **읽는 양 자체를 축소** → 전송 횟수↓.
- **클러스터링 팩터** 개선으로 범위 스캔의 비용/블록수 감소.

---

## **읽기/쓰기 전송(Read/Write Transfer)**

### 정의

- **요청자(I2)는 읽기(CR)만 필요**하지만, 블록의 **Current 소유자가 I1**이고 그 블록이 **최근 변경된 상태**라면
  I1이 **현재 버전에서 CR을 만들어** I2에 **전송**해야 한다(또는 이미 보유한 CR을 전송).
- 요청자 이벤트: **`gc cr block 2-way/3-way`**.
- 전송 직전에 **I1이 “커밋 클린아웃”/CR 생성**이 필요하면 **추가 CPU/시간** 발생.

### 시나리오

```
시점 T1: I1이 ROW R을 UPDATE(미커밋 또는 방금 커밋)
시점 T2: I2가 R을 SELECT → CR이 필요
  - Master는 I1이 Current를 갖고 있음을 알고 I1에 지시
  - I1은 Current에서 CR을 생성(필요 시 Undo/블록 클린아웃) → I2에 전송
```

### 예제

```sql
-- I1: 특정 키 범위를 UPDATE(커밋은 일부러 지연)
CONNECT app_user/password@svc1
BEGIN
  UPDATE rac_orders
  SET    amount = amount * 1.01
  WHERE  cust_id BETWEEN 15000 AND 15010;
  -- COMMIT 지연(또는 소량만 커밋)
END;
/

-- I2: 같은 범위를 SELECT → I1이 CR 만들어 I2에 전송
CONNECT app_user/password@svc2
SELECT COUNT(*), SUM(amount)
FROM   rac_orders
WHERE  cust_id BETWEEN 15000 AND 15010;
```

**관찰(I2)**
- `gc cr block 2-way/3-way` 증가
- 경우에 따라 `gc cr grant busy`(락/메타데이터 경합)도 보일 수 있음.

### 튜닝 포인트

- **변경 직후 곧바로 타 인스턴스가 읽지 않도록** 트래픽 분리.
- **커밋 배치 + 지연 클린아웃 최소화**(OLTP 패턴 개선, 인덱스/SQL 재구성).
- **읽기 부하가 많은 범위**를 **한 인스턴스로 귀속**시키는 라우팅.

---

## **쓰기/쓰기 전송(Write/Write Transfer)**

### 정의

- **I1**이 블록 **X의 Current** 를 보유 중 **UPDATE** 를 하고 있는데,
  **I2**도 **같은 블록 X를 UPDATE** 하려면 **Current 소유권을 I2로 이전**해야 한다.
- 이때 **I1 → I2** 로 Current 전송, **I1에는 PI(Past Image)** 가 남는다.
- 이벤트: **`gc current block 2-way/3-way`**, 경합 심하면 `gc current grant busy`, `gc buffer busy acquire`.

### 흐름

```
I2(Session) → Master: "블록 X Current 주세요(쓰기)"
Master 확인:
  - Current holder = I1
  - I1에게 Current를 I2로 보내라고 지시
I1 → I2: "X(Current) 전송", I1은 X에 대한 PI 유지
I2: Current 획득 후 UPDATE 진행
```

### 예제(동일 블록을 두 인스턴스가 번갈아 UPDATE)

```sql
-- 공통 타깃(같은 cust_id 범위) 선택
-- I1
CONNECT app_user/password@svc1
UPDATE rac_orders
SET    status = 'OK'
WHERE  cust_id BETWEEN 20000 AND 20005;
-- 커밋 지연으로 경합 유도
-- (실제 실험에선 loop로 반복 UPDATE)

-- I2
CONNECT app_user/password@svc2
UPDATE rac_orders
SET    status = 'HOLD'
WHERE  cust_id BETWEEN 20000 AND 20005;
```

**관찰(양쪽)**
```sql
SELECT event, total_waits, time_waited_micro/1e6 sec
FROM   v$session_event
WHERE  sid = SYS_CONTEXT('USERENV','SID')
AND    event LIKE 'gc current%';

-- ASH상 'gc buffer busy acquire', 'gc current grant busy' 샘플 확인
SELECT event, COUNT(*) FROM v$active_session_history
WHERE sample_time > SYSTIMESTAMP - INTERVAL '5' MINUTE
AND   event IN ('gc buffer busy acquire','gc current grant busy')
GROUP BY event;
```

### 영향·튜닝

- **PI 증가 → 전송·정리 비용 증가**. 쓰기/쓰기 이동이 **동일 블록**(좁은 해시/인덱스 핫셋)에서 잦으면 병목.
- **해결책**
  - **데이터 파티션/해시 키 설계**로 **업데이트 대상 분산**(인스턴스 로컬리티 강화)
  - **시퀀스/키 채번**의 **캐시·버스트** 지양(같은 블록에 집중된 HOT ROW 회피)
  - **서비스 라우팅**: 쓰기 트랜잭션을 **지정 인스턴스**로 몰아 **소유권 이동** 최소화
  - **배치 커밋**(너무 잦은 소유권 왕복 방지), **짧은 트랜잭션**

---

## **쓰기/읽기 전송(Write/Read Transfer)**

### 정의

- **I1**이 블록 X를 **Current(쓰기)** 로 잡고 변경 중인데,
  **I2**가 같은 블록 X를 **읽기(CR)** 로 요구.
- I1은 **CR 버전 생성**(Undo/클린아웃 필요 시 수행) 후 **I2에 CR 전송**.
- 읽는 쪽(I2) 이벤트: **`gc cr block 2-way/3-way`**, 때로는 **`gc buffer busy acquire`**(I1이 잠시 블록 가공/락 소요).

### 예제

```sql
-- I1: 긴 트랜잭션(여러 row update)으로 Current 오래 보유
CONNECT app_user/password@svc1
BEGIN
  UPDATE rac_orders SET amount = amount * 1.02
  WHERE  cust_id BETWEEN 22000 AND 22050;
  DBMS_LOCK.SLEEP(3);  -- 일부러 길게 유지(데모)
  -- COMMIT 지연
END;
/

-- I2: 같은 범위 SELECT(읽기)
CONNECT app_user/password@svc2
SELECT /* read while other writes */ SUM(amount)
FROM   rac_orders
WHERE  cust_id BETWEEN 22000 AND 22050;
```

**관찰(I2)**
- `gc cr block 2-way/3-way` 대기
- I1에서 **CR 생성/클린아웃** 시간이 길면 I2에서 **대기시간 증가**
- 혼잡 시 `gc buffer busy acquire` 동반

### 튜닝

- **쓰기 보유 시간 최소화**(짧은 트랜잭션, 배치·로직 분할).
- **읽기 트래픽 분리**(읽기 인스턴스/서비스, 읽기 전용 리포팅 노드).
- **필요 컬럼만 읽고 Stopkey**로 범위 축소 → 전송량↓.

---

## 관찰·트러블슈팅 스크립트

### gc 이벤트 Top-N

```sql
-- 인스턴스별 gc 대기 상위
SELECT inst_id, event, total_waits, time_waited_micro/1e6 sec
FROM   gv$system_event
WHERE  event LIKE 'gc %'
ORDER  BY sec DESC FETCH FIRST 30 ROWS ONLY;
```

### ASH로 (블록) 핫 오브젝트 및 SQL 확인

```sql
-- 최근 10분 gc 이벤트·오브젝트
SELECT ash.inst_id, ash.event, ash.sql_id, ash.current_obj# obj#
FROM   gv$active_session_history ash
WHERE  ash.sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
AND    ash.event LIKE 'gc %';

-- 오브젝트 번호 → 이름
SELECT owner, object_name, object_type
FROM   dba_objects
WHERE  object_id = :obj#;
```

### 세그먼트 통계에서 경합 징후

```sql
SELECT owner, object_name, statistic_name, value
FROM   gv$segment_statistics
WHERE  statistic_name IN ('gc buffer busy','gc cr blocks received','gc current blocks received')
ORDER  BY value DESC FETCH FIRST 30 ROWS ONLY;
```

### SQL 프로파일(전송 유발자 찾기)

```sql
SELECT inst_id, sql_id, plan_hash_value,
       executions, buffer_gets, disk_reads
FROM   gv$sql
ORDER  BY executions DESC FETCH FIRST 50 ROWS ONLY;

-- 특정 sql_id의 실행계획(인스턴스별 비교)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&&sql_id', NULL, 'ALLSTATS LAST'));
```

---

## 아키텍처 메커니즘(조금 더 깊게)

### GCS/GES와 리소스 마스터링

- **GCS(Global Cache Service)**: 데이터 블록 리소스(Current/CR 권한) 관리.
- **GES(Global Enqueue Service)**: 라이브러리 캐시 락 등 **엔큐(Enqueue)** 자원 관리.
- **마스터링**: 블록 리소스의 **마스터** 인스턴스를 정하고, 접근 패턴에 따라 **리매스터링(재배치)** 하여 핫 리소스의 **소유권 이동 빈도↓**.

### SCN·ITL·Undo·PI

- **SCN 일관성**: 읽기는 **요청 SCN**에 맞춰 **CR** 생성.
- **ITL/락바이트**: Current에서 변경 시 **ITL 슬롯** 사용, 전송 전 **클린아웃**이 필요할 수 있음.
- **PI**: Current 전송 시 **이전 이미지를 보존** → 장애 시 복구/롤백에 활용.

### “2-Way ↔ 3-Way”가 되는 이유

- **마스터와 보유자가 동일**하면 2-Way,
- **다르면** 마스터 → 보유자 안내 → 보유자 → 요청자 경로의 **3-Way**.

---

## 시나리오별 튜닝 전략 요약

| 시나리오 | 주요 대기 | 근본 원인 | 해법(우선순위) |
|---|---|---|---|
| 전송 없는 읽기 | (없음) | 로컬 히트 | **서비스/파티션 분리·로컬리티 강화** 유지 |
| 읽기/읽기 전송 | `gc cr block 2/3-way` | 다중 노드가 같은 범위 읽음 | **리포트 서비스 분리**, **프루닝/Stopkey**, **클러스터링 팩터** |
| 읽기/쓰기 전송 | `gc cr block 2/3-way` | 갓 변경된 블록을 타 노드가 바로 읽음 | **쓰기·읽기 트래픽 분리**, **커밋 배치**, **읽기 로컬리티** |
| 쓰기/쓰기 전송 | `gc current block 2/3-way`, `gc current grant busy` | Current 소유권 왕복 | **핫 블록 분산(파티션·키 해시)**, **쓰기 서비스 집중**, **짧은 트랜잭션** |
| 쓰기/읽기 전송 | `gc cr block 2/3-way`, `gc buffer busy acquire` | Writer가 보유 중인 블록을 Reader가 요구 | **읽기 전용 노드**, **읽기 범위 축소**, **Writer 보유 시간 단축** |

---

## 실전 체크리스트

- [ ] **서비스·인스턴스 라우팅**으로 **업데이트·조회** 성격 분리(예: SVC_WRITE@I1, SVC_READ@I2).
- [ ] **파티셔닝/샤딩/해시** 키로 **핫 블록** 분산(동일 블록에 쓰기 몰림 방지).
- [ ] **리포트 쿼리**는 **프루닝 + 해시 조인 + 멀티블록** 경로로 설계(불필요 블록 공유↓).
- [ ] **시퀀스/채번**: 너무 작은 캐시/단일 세그먼트 집중 지양(중앙 핫 블록 회피).
- [ ] **짧은 트랜잭션/커밋 배치**로 Current 보유 시간↓, 클린아웃 비용↓.
- [ ] **인터커넥트**: 전용 네트워크, MTU/버퍼/대역폭 확인(패킷 드롭·재전송 최소화).
- [ ] **AWR/ASH**로 `gc %` 이벤트의 **비중**·**오브젝트**·**SQL**을 상시 관찰.

---

## 부록: 재현용 미니 랩(개념 시나리오)

> 실제 RAC 환경이 필요하며, 아래는 **개념 시나리오**를 SQL로 요약했다.

### 읽기/읽기 전송 랩

```sql
-- I1에서 범위를 먼저 워밍업(캐시 적재)
CONNECT app_user/password@svc1
SELECT /* warmup */ COUNT(*) FROM rac_orders WHERE cust_id BETWEEN 30000 AND 31000;

-- I2에서 동일 범위 조회 → gc cr block 2-way/3-way 관찰
CONNECT app_user/password@svc2
SELECT COUNT(*) FROM rac_orders WHERE cust_id BETWEEN 30000 AND 31000;
```

### 쓰기/쓰기 전송 랩

```sql
-- I1: 같은 범위 UPDATE 반복
CONNECT app_user/password@svc1
BEGIN
  FOR i IN 1..50 LOOP
    UPDATE rac_orders SET status='OK' WHERE cust_id BETWEEN 40000 AND 40010;
    COMMIT;
  END LOOP;
END;
/

-- I2: 교차로 같은 범위 UPDATE
CONNECT app_user/password@svc2
BEGIN
  FOR i IN 1..50 LOOP
    UPDATE rac_orders SET status='HOLD' WHERE cust_id BETWEEN 40000 AND 40010;
    COMMIT;
  END LOOP;
END;
/
-- 양쪽에서 gc current block 2-way/3-way, gc current grant busy 관찰
```

### 쓰기/읽기 전송 랩

```sql
-- I1: 긴 업데이트 보유
CONNECT app_user/password@svc1
BEGIN
  UPDATE rac_orders SET amount = amount * 1.05
  WHERE cust_id BETWEEN 50000 AND 50050;
  DBMS_LOCK.SLEEP(5); -- 보유 시간 늘림
  -- COMMIT 지연
END;
/

-- I2: 같은 범위 SELECT
CONNECT app_user/password@svc2
SELECT SUM(amount) FROM rac_orders WHERE cust_id BETWEEN 50000 AND 50050;
-- I2: gc cr block 2/3-way, 때로 gc buffer busy acquire 대기
```

---

## 결론

- **캐시 퓨전**의 본질은 “**디스크가 아닌 인터커넥트로 블록을 섞어 일관성을 맞춘다**”이다.
- 시나리오별 핵심:
  - **전송 없는 읽기**: 최선. **로컬리티**를 극대화하라.
  - **읽기/읽기 전송**: 동일 범위를 여러 노드가 읽지 않게 **업무 분리**.
  - **읽기/쓰기 전송**: 방금 변경한 블록을 곧바로 다른 노드가 읽지 않도록 **라우팅/설계**.
  - **쓰기/쓰기 전송**: **핫 블록 분산**과 **쓰기 집중화**로 Current 왕복을 최소화.
  - **쓰기/읽기 전송**: Writer 보유 시간 단축, Reader 범위 축소/분리.
- 언제나 **AWR/ASH/세그먼트 통계**로 `gc %` 이벤트를 **숫자**로 확인하고,
  **서비스·파티션·SQL/인덱스 설계**와 **인터커넥트 품질**을 함께 조율하라.
- 목표는 “**전송을 없애거나 줄이고**, 불가피한 전송은 **2-Way·저지연**으로 만들며, **PI/경합**을 **폭발시키지 않는 것**”.
