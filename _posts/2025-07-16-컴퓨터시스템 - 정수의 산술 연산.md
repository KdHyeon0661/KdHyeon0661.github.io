---
layout: post
title: 컴퓨터시스템 - 정수의 산술 연산
date: 2025-07-16 22:20:23 +0900
category: 컴퓨터시스템
---
# 정수의 산술 연산: 컴퓨터는 어떻게 덧셈과 뺄셈을 수행하는가?

## 0. 개요 — 정수 산술을 설계/디버깅 관점에서 본다면

- 표현: **2의 보수**(Two’s complement) 고정 폭 \(n\)비트
- 연산: 실제로는 모두 **모듈러 \(2^n\) 산술**
- 결과 해석: **부호 없는/부호 있는** 해석 규칙으로 의미 부여
- 핵심 이슈: **오버플로/언더플로**, **시프트의 의미**, **형 변환/승격**
- 하드웨어 키워드: **반가산기/전가산기**, **리플 캐리/캐리 룩어헤드**, **시프트-가산 곱셈**, **복원/비복원 나눗셈**

---

## 1. 덧셈(Addition) — 전가산기에서 CPU까지

### 1.1 반가산기/전가산기

- **반가산기(HA)**: 입력 \(a,b\) → 합 \(s=a\oplus b\), 캐리 \(c=a\land b\)
- **전가산기(FA)**: 입력 \(a,b,c_{in}\) →  
  \(s=a\oplus b \oplus c_{in}\),  
  \(c_{out}= (a\land b) \lor (c_{in}\land(a\oplus b))\)

여러 전가산기를 직렬로 연결하면 **리플 캐리 가산기(RCA)**.  
고속화는 **캐리 룩어헤드(CLA)**:  
생성 \(G_i=a_i b_i\), 전파 \(P_i=a_i\oplus b_i\),  
\(c_{i+1}=G_i \lor (P_i \land c_i)\) 를 계층적으로 전개.

### 1.2 2의 보수 덧셈의 수학

고정 폭 \(n\)비트에서:

$$
\boxed{S = (A + B) \bmod 2^n}
$$

- **부호 없는 관점**: 그대로 \(0..2^n-1\)
- **부호 있는(2의 보수) 관점**: \(S\)를 \([-2^{n-1},2^{n-1}-1]\)로 해석

### 1.3 예시(8비트): \(5 + 3 = 8\)

```
  0000 0101
+ 0000 0011
-----------
  0000 1000   (8)
```

### 1.4 음수 포함 예: \(5 + (-3) = 2\)

\(-3\)의 2의 보수: `1111 1101`

```
  0000 0101
+ 1111 1101
-----------
  0000 0010   (2)  ; 캐리 아웃은 버림
```

### 1.5 오버플로 검출(부호 있는)

부호 있는 덧셈 오버플로는  
**피연산자 부호가 같고, 결과 부호가 달라질 때** 발생.

수식으로는:

$$
\text{OF} = \neg(a_{MSB} \oplus b_{MSB}) \land (a_{MSB} \oplus s_{MSB})
$$

부호 없는 오버플로는 **최상위 캐리 아웃(CF)** 로 검출.

```c
#include <stdint.h>
#include <stdbool.h>
static inline bool add_overflow_s32(int32_t a, int32_t b, int32_t* out){
    int32_t s = a + b; // 주: 서명 오버플로는 C에서 UB, 실전은 빌트인 사용 권장
    *out = s;
    return ((a ^ s) & (b ^ s)) < 0; // 부호 같은데 결과 부호가 다르면 OF
}
```

> 실무 C/C++에서는 **`__builtin_add_overflow`**(GCC/Clang) 같은 **체크드 산술** 내장을 권장.

---

## 2. 뺄셈(Subtraction) — 덧셈으로 구현된다

### 2.1 정체: \(A - B = A + (\sim B + 1)\)

2의 보수에서 음수 \(-B\)는 **비트 반전 + 1**.

```
  A
+ (~B + 1)
-----------
  A - B
```

### 2.2 예: \(5-3=2\)

`~3 + 1 = 1111 1100 + 1 = 1111 1101`

```
  0000 0105 (5)
+ 1111 1101 (~3+1)
-----------
  0000 0010 (2)
```

### 2.3 부호 있는 뺄셈 오버플로

$$
\text{OF} = (a_{MSB} \oplus b_{MSB}) \land (a_{MSB} \oplus s_{MSB})
$$

- **서로 다른 부호를 빼서** 결과 부호가 피감수와 달라지면 OF.

---

## 3. 곱셈(Multiplication) — 시프트와 가산의 합성

### 3.1 기본 알고리즘(시프트-가산)

곱셈 \(A\times B\)를, \(B\)의 각 비트가 1인 자리마다 \(A \ll i\) 를 더해 구성.

```c
#include <stdint.h>
uint32_t mul_u32_shiftadd(uint32_t a, uint32_t b){
    uint64_t acc = 0;                   // 누산은 넓게
    for(unsigned i=0;i<32;i++)
        if(b & (1u<<i)) acc += (uint64_t)a << i;
    return (uint32_t)acc;               // 하위 32비트만 반환(모듈러 2^32)
}
```

- 실하드웨어: **부스(Booth) 알고리즘**, **월러스 트리** 등으로 가속.

### 3.2 부호와 폭

- 32×32 → **64비트 결과**가 **정확**. 32비트로 잘라내면 **래핑**.
- 언어/ISA: 예) x86 `IMUL`(부호), `MUL`(무부호), 결과는 \(2n\)비트(상·하위).

```c
// 32x32 -> 64를 안전히 얻고, 범위 검사
#include <stdint.h>
#include <stdbool.h>
bool mul_s32_checked(int32_t a, int32_t b, int32_t* out){
    int64_t p = (int64_t)a * (int64_t)b; // 넓은 중간결과
    if(p > INT32_MAX || p < INT32_MIN) return false; // 오버플로
    *out = (int32_t)p; return true;
}
```

### 3.3 상수 곱 최적화(Strength Reduction)

- \(x\cdot 10 = (x\ll 3) + (x\ll 1)\)
- 나눗셈/곱셈을 **시프트+덧셈** 조합으로 대체(컴파일러가 자동 수행하는 경우 多)

---

## 4. 나눗셈(Division) — 몫/나머지와 “반올림 규칙”

### 4.1 정의(정수 나눗셈)

정수 \(a,b\,(b\neq 0)\)에 대해

$$
a = q \cdot b + r
$$

- C 계열(C99+, C++, Java) 정수 나눗셈은 **0을 향해 절단(truncation toward 0)**:
  - 예) \(-7/2 = -3\), \(-7\%2 = -1\)
- 파이썬 `//`는 **바닥 함수(floor)**:
  - \(-7//2 = -4\), \(-7\%2 = 1\)

> 같은 수학식, **언어마다 몫/나머지의 규약이 다를 수 있음**.

### 4.2 하드웨어 알고리즘 개요

- **복원(Restoring)** / **비복원(Non-restoring)** 나눗셈: 시프트-뺄셈 기반의 장기 나눗셈
- 고성능: **SRT**(여러 비트씩 몫 산출), **뉴턴-랩슨**으로 역수 근사 후 곱셈

### 4.3 2의 거듭제곱으로 나누기

- 무부호: \(x \gg k\)
- 부호 있는 **절단 몫**: 보통 **산술 우시프트**로 근사  
  (C의 서명 우시프트는 구현정의지만 대부분 산술)

**바닥 몫**을 원하면 음수에 **바이어스**:

```c
// floor_div_power2: b=2^k로 나눠 바닥 몫을 얻기
int32_t floor_div_pow2(int32_t x, unsigned k){
    int32_t bias = ((x >> 31) & ((1u<<k)-1)); // x<0이면 (2^k-1), 아니면 0
    return (x + bias) >> k;
}
```

---

## 5. 오버플로/언더플로 — 정의·검출·정책

### 5.1 정의

- **무부호**: 항상 **모듈러 \(2^n\)** 래핑.  
- **부호 있는(C/C++)**: 오버플로는 **정의되지 않음(UB)** → 최적화가 가정.

### 5.2 검출(실전)

- GCC/Clang: `__builtin_add_overflow`, `__builtin_sub_overflow`, `__builtin_mul_overflow`
- MSVC: `_addcarry_u32`, `_addcarry_u64` 등 인트린식
- 언어 레벨: Rust `checked_*/wrapping_*/saturating_*`, Java `Math.addExact`

```c
#include <stdbool.h>
#include <stdint.h>
bool add_checked_s32(int32_t a, int32_t b, int32_t* out){
#if defined(__has_builtin)
#  if __has_builtin(__builtin_add_overflow)
    return __builtin_add_overflow(a,b,out);
#  endif
#endif
    int32_t s = a + b; *out = s;
    return ((a ^ s) & (b ^ s)) < 0; // 폴백(개념용)
}
```

### 5.3 정책

- **래핑**: 암호·해시 등 모듈러 산술이 본질일 때
- **포화**: DSP/미디어(최소/최대에 고정)
- **예외/에러**: 금융·안전 크리티컬

```c
// int32 포화 덧셈
#include <stdint.h>
int32_t saturating_add_s32(int32_t a, int32_t b){
    int64_t s = (int64_t)a + (int64_t)b;
    if(s > INT32_MAX) return INT32_MAX;
    if(s < INT32_MIN) return INT32_MIN;
    return (int32_t)s;
}
```

---

## 6. 시프트(Shift) — 곱셈/나눗셈/마스크의 기초

### 6.1 종류

- **논리 좌/우(<<, >>>)**: 빈자리를 0으로
- **산술 우**: 최상위 비트 복제(부호 유지)
- C/C++: **부호 있는 우시프트는 구현정의**, 좌시프트 오버플로는 **UB**

### 6.2 2의 거듭제곱 곱셈/나눗셈

```c
int x = 3 << 2;   // 12 (3*4)
int y = 16 >> 2;  // 4  (16/4)
```

- 좌시프트로 **부호 있는 값을 넘치게** 하면 UB.  
- **무부호 형으로 승격** 후 시프트하면 모듈러 의미가 분명해짐.

```c
int32_t a = -2;
uint32_t m = ((uint32_t)a) << 1; // 정의: 모듈러 2^32에서 시프트
```

---

## 7. 형 변환과 승격(Usual Integer Promotions) — “계산은 더 넓게, 저장할 때 잘림”

### 7.1 일반 승격

- `char`, `short` 등 **작은 정수형**은 연산 전에 **int/unsigned int**로 승격
- 따라서 `uint8_t` 덧셈도 실제론 **int 폭**에서 수행 후, 저장 시 **잘림**

```c
#include <stdint.h>
uint8_t a=200, b=100;
uint8_t c = a + b;  // 계산은 int로: 300, 저장 시 8비트 잘림 → 44
```

### 7.2 서명/무부호 혼합

- 피연산자 중 **무부호**가 더 “랭크”가 높으면, **부호 있는 값이 무부호로 변환**
- 유명한 함정: `-1 < 1u` 는 **거짓**(좌변이 거대한 무부호로 변환)

```c
#include <stdio.h>
int main(){
    printf("%s\n", (-1 < 1u) ? "true":"false"); // 보통 false
}
```

### 7.3 안전한 패턴

- **명시적 캐스팅**으로 의도를 드러내기
- 중간 계산 폭을 **넓혀** 오버플로 회피: `(int64_t)a*b`
- 부호 비교 전 **범위 점검** 또는 **형 일치** 후 비교

---

## 8. 플래그(하드웨어 관점) — CF/OF/ZF/SF/PF

- **CF**(Carry): 무부호 덧셈 캐리/뺄셈 보로우
- **OF**(Overflow): 서명 오버플로
- **ZF**(Zero): 결과가 0
- **SF**(Sign): 결과 MSB
- **PF**(Parity): 하위 바이트의 패리티

언어 차원에서는 직접 노출하지 않지만, **인트린식** 또는 **어셈블리**로 접근 가능.

---

## 9. 시각화/검증 유틸 — 비트/진법/연산 확인

```c
#include <stdio.h>
#include <stdint.h>

static void bits_u32(uint32_t x){
    for(int i=31;i>=0;i--) putchar((x>>i)&1 ? '1':'0');
}

int main(){
    uint8_t  a=200, b=100, c=a+b;
    printf("a=%u b=%u a+b=%u\n", a,b,c);
    printf("a: "); bits_u32(a); puts("");
    printf("b: "); bits_u32(b); puts("");
    printf("c: "); bits_u32(c); puts("");
    return 0;
}
```

---

## 10. 자주 묻는 실수와 처방

1. **서명 덧셈 오버플로를 이용한 로직**: C/C++에선 UB → **체크드 내장** 사용.  
2. **부호 있는 우시프트**: 구현정의 → **무부호로 캐스팅**하여 명확히.  
3. **음수 나눗셈 규칙 혼동**: C는 **0 절단**, Python `//`는 **floor**.  
4. **형 혼합 비교**: 서명↔무부호 → **명시적 캐스트** 또는 범위 검사.  
5. **곱셈 중간 오버플로**: 중간을 **더 넓은 형**으로 캐스팅.  
6. **2의 거듭제곱 나눗셈의 반올림**: 목적(절단/바닥/올림)에 맞춘 **바이어스** 추가(§4.3).

---

## 11. 표/요약

### 11.1 오버플로 판정 요약(덧셈)

| 관점 | 판정 |
|---|---|
| 무부호 | 캐리 아웃(CF)=1 |
| 부호 있는 | \(\neg(a_{MSB}\oplus b_{MSB}) \land (a_{MSB}\oplus s_{MSB})\) |

### 11.2 나눗셈 규약(언어별 요지)

| 언어 | 몫 | 나머지 부호 |
|---|---|---|
| C/C++/Java | **0 절단** | 피제수(a)의 부호 따름 |
| Python `//,%` | **floor** | \(0 \le r < |b|\) 유지(부호 조정) |

---

## 12. 연습 문제(자가 점검)

1) 8비트에서 \(127+1\)을 2의 보수로 계산하고, 오버플로 여부를 판정하라.  
2) 16비트에서 \(-2 - 5\)를 2의 보수 덧셈으로 수행하고 결과를 이진/십진으로 쓰라.  
3) 32×32 곱셈에서 중간 오버플로 없이 정확한 결과를 얻는 C 코드를 작성하라.  
4) \(x\)를 \(2^k\)로 나누어 **바닥 몫**을 얻는 산술식을 작성하라(§4.3 응용).  
5) `-1 < 1u`가 거짓인 이유를, 변환 규칙 관점에서 한 줄로 설명하라.  
6) 복원 나눗셈에서 한 스텝의 “시프트-뺄셈-복원” 절차를 의사코드로 써 보라.

---

## 13. 참고 코드 모음 — 안전/포화/래핑/체크드

```c
// (A) 래핑 덧셈/뺄셈/곱셈(무부호) — 모듈러 2^n
#include <stdint.h>
static inline uint32_t add_wrap_u32(uint32_t a, uint32_t b){ return a + b; }
static inline uint32_t sub_wrap_u32(uint32_t a, uint32_t b){ return a - b; }
static inline uint32_t mul_wrap_u32(uint32_t a, uint32_t b){ return a * b; }

// (B) 포화 덧셈(서명 32비트)
#include <limits.h>
int32_t add_sat_s32(int32_t a, int32_t b){
    int64_t s = (int64_t)a + (int64_t)b;
    if(s > INT32_MAX) return INT32_MAX;
    if(s < INT32_MIN) return INT32_MIN;
    return (int32_t)s;
}

// (C) 체크드 덧셈(가능하면 빌트인 사용)
int add_checked(int a, int b, int* out){
#if defined(__has_builtin)
#  if __has_builtin(__builtin_add_overflow)
    return __builtin_add_overflow(a,b,out);
#  endif
#endif
    long long s = (long long)a + (long long)b;
    if(s > INT_MAX || s < INT_MIN) return 1;
    *out = (int)s; return 0;
}
```

---

## 마무리 — “모듈러 세계에서 의미는 해석으로 생긴다”

컴퓨터의 정수 산술은 **항상 \(2^n\) 모듈러 세계**에서 수행됩니다.  
그 결과를 **부호 있는/없는** 규약으로 **해석**하고,  
언어의 **나눗셈/시프트/형 변환 규칙**을 명확히 알면,  
오버플로·부호·반올림·성능 최적화를 둘러싼 대부분의 버그를 사전에 차단할 수 있습니다.

> 덧셈/뺄셈은 **2의 보수 가산기**, 곱셈은 **시프트-가산**, 나눗셈은 **시프트-뺄셈**.  
> 그리고 실무에서는 **체크드/포화/래핑** 전략을 **명시적**으로 선택하십시오.