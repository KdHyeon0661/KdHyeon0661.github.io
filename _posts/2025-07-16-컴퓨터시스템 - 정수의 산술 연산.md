---
layout: post
title: 컴퓨터시스템 - 정수의 산술 연산
date: 2025-07-16 22:20:23 +0900
category: 컴퓨터시스템
---
# 정수의 산술 연산: 컴퓨터는 어떻게 덧셈과 뺄셈을 수행하는가?

컴퓨터는 정수를 이진수로 표현하고, **논리회로**를 통해 산술 연산을 수행한다. 이때 고려해야 할 핵심은 다음과 같다:

- 정수는 **2의 보수**로 표현됨
- 연산은 **고정된 비트 크기** 내에서 수행됨
- 오버플로우 및 언더플로우 발생 가능
- 나눗셈은 **정수 나눗셈(몫)**만 수행됨

---

## 1. 덧셈 (Addition)

컴퓨터의 정수 덧셈은 이진수 자리올림(carry)을 기반으로 수행된다.

### 예제: 8비트에서 5 + 3
- 5 → `00000101`  
- 3 → `00000011`  
- 합 → `00001000` (8)

```text
  00000101
+ 00000011
-----------
  00001000
```

### 음수 덧셈 예: 5 + (-3)
- -3 → 2의 보수로 `11111101`  
- 5 → `00000101`

```text
  00000101
+ 11111101
-----------
  00000010  (2)
```

---

## 2. 뺄셈 (Subtraction)

뺄셈은 `A - B`를 `A + (-B)`로 처리한다. 즉, **2의 보수를 이용한 덧셈**이다.

### 예: 5 - 3
- 3의 2의 보수: `11111101`  
- 5: `00000101`

```text
  00000101
+ 11111101
-----------
  00000010  (2)
```

### 예: 3 - 5 → 결과는 -2
- -2 → `11111110`  
- 확인: `00000011 + 11111101 = 11111110`

---

## 3. 곱셈 (Multiplication)

이진수 곱셈은 **자리수를 밀며 덧셈을 반복**하는 방식으로 수행된다.  
하드웨어적으로는 **시프트 + 누적 덧셈**을 사용한다.

### 예: 3 × 5
- 3: `00000011`
- 5: `00000101`

```text
  00000011  (3)
× 00000101  (5)
-----------
  00000011  (3)       ← 1비트: 그대로
 00000000   (0)       ← 0비트: 0
00011000    (24)      ← 1비트: 3 << 2 = 12

합: 00001111 (15)
```

---

## 4. 나눗셈 (Division)

정수 나눗셈은 **몫만 반환**하고, **소수점 이하는 버림**한다.

### 예: 7 / 2
- 결과: `3` (소수점 아래 버림)

```c
int a = 7 / 2; // a = 3
```

### 나머지 연산: `%`
```c
int r = 7 % 2; // r = 1
```

---

## 5. 오버플로우와 언더플로우

정수형은 **고정된 비트 수**로 표현되기 때문에, 연산 결과가 범위를 벗어나면 **오버플로우(overflow)** 또는 **언더플로우(underflow)**가 발생한다.

### 예: 8비트 정수 (signed) 범위: -128 ~ 127

#### 오버플로우 예
```c
int8_t x = 127;
int8_t y = x + 1; // -128이 됨!
```

- 127: `01111111`  
- +1 → `10000000` → -128 (2의 보수 해석)

#### 언더플로우 예
```c
int8_t x = -128;
int8_t y = x - 1; // 127이 됨!
```

---

## 6. 비트 시프트 연산과 곱셈/나눗셈

곱셈과 나눗셈은 **2의 거듭제곱 연산**일 경우 **시프트**로 대체할 수 있어 빠르다.

### 곱셈
```c
int x = 3 << 2; // 3 * 4 = 12
```

### 나눗셈
```c
int x = 16 >> 2; // 16 / 4 = 4
```

---

## 7. 캐스팅과 타입 변화 주의

정수 연산 시 **타입이 다른 피연산자끼리 연산**하면, **자동 형 변환**이 발생하고 결과가 예기치 않을 수 있다.

```c
uint8_t a = 200;
uint8_t b = 100;
uint8_t c = a + b; // 300 → 44 (오버플로우)
```

- 300 → `00000001 00101100` → 하위 8비트만 저장 → `44`

---

## 8. 요약: 정수 산술의 핵심

| 항목 | 설명 |
|------|------|
| 덧셈/뺄셈 | 2의 보수 기반 덧셈으로 처리됨 |
| 곱셈/나눗셈 | 반복적 덧셈·시프트를 이용함 |
| 오버플로우 | 결과가 표현 범위를 벗어나면 wrap-around |
| 타입 캐스팅 | 암시적 형 변환 시 주의 필요 |
| 시프트 최적화 | 곱셈/나눗셈보다 빠르게 연산 가능 |

---

## 참고: C 코드 예시

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    int8_t a = 127;
    int8_t b = 1;
    int8_t result = a + b; // 오버플로우

    printf("127 + 1 = %d\n", result); // 출력: -128

    int x = 8;
    int y = x << 1; // x * 2
    printf("8 << 1 = %d\n", y); // 16

    int z = x >> 1; // x / 2
    printf("8 >> 1 = %d\n", z); // 4

    return 0;
}
```

---

## 마무리

정수 연산은 단순히 덧셈 기호를 쓰는 것처럼 보이지만,  
컴퓨터 내부에서는 **2의 보수**, **비트 크기**, **시프트 연산**, **오버플로우 처리** 등  
정교한 원리와 주의사항을 내포하고 있다.

정수 연산을 정확히 이해하는 것은, **시스템 레벨 디버깅**, **성능 최적화**, **버그 회피**의 첫걸음이다.