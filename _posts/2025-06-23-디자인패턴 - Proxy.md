---
layout: post
title: 디자인패턴 - Proxy
date: 2025-06-23 20:20:23 +0900
category: 디자인패턴
---
# Proxy (프록시 패턴)

## 정의

**프록시 패턴(Proxy Pattern)**은 **어떤 객체에 대한 접근을 제어**하기 위해 **대리 객체(Proxy)**를 두는 **구조 패턴**이다.  
프록시는 실제 객체(RealSubject)에 대한 **참조를 보유**하며, **접근 통제, 지연 로딩, 캐싱, 로깅, 원격 호출** 등 부가기능을 투명하게 제공한다.

> “다른 객체에 대한 접근을 **대신하거나 제어**하는 대리인 역할”

---

## 의도 (Intent)

- 실제 객체에 대한 **접근을 통제**한다(권한, 속도 제한, 격리).  
- **생성 비용이 큰 객체/원격 자원**은 **프록시를 통해 늦게(필요 시점에) 생성/접속**한다.  
- 클라이언트는 **동일한 인터페이스**를 통해 프록시/실제 객체를 **구분 없이 사용**한다.

---

## 구조 (UML)

사용자 제공 UML을 **보존**한다.

```
         ┌──────────────┐
         │   Client     │
         └─────┬────────┘
               │
         ┌─────▼────────┐
         │   Subject    │◄────┐  (공통 인터페이스)
         └─────▲────────┘     │
         ┌─────┴────────┐     │
         │ RealSubject  │     │
         └──────────────┘     │
         ┌──────────────────┐ │
         │     Proxy        │─┘
         └──────────────────┘
```

- `Subject`: 공통 인터페이스  
- `RealSubject`: 실제 구현  
- `Proxy`: RealSubject에 대한 접근을 **대리/조절**  
- `Client`: `Subject` 타입으로 **투명하게** 사용

---

## 구현 예시 1 — Virtual Proxy(지연 로딩, Python)

초안의 예시를 **살리되**, 로깅/시간 측정/스레드 안전(간단 잠금)을 추가한다.

```python
from abc import ABC, abstractmethod
import time, threading

# Subject 인터페이스
class Image(ABC):
    @abstractmethod
    def display(self):
        ...

# 실제 객체 (무거운 리소스 로딩)
class RealImage(Image):
    def __init__(self, filename: str):
        self.filename = filename
        self._loaded = False
        self._load_from_disk()

    def _load_from_disk(self):
        print(f"[디스크에서 {self.filename} 로딩 중...]")
        time.sleep(0.5)  # 시뮬레이션
        self._loaded = True

    def display(self):
        print(f"{self.filename} 표시")

# 프록시: 지연 로딩 + 간단한 계측/락
class ProxyImage(Image):
    def __init__(self, filename: str):
        self._filename = filename
        self._real: RealImage | None = None
        self._lock = threading.Lock()

    def display(self):
        if self._real is None:
            with self._lock:
                if self._real is None:  # double-check
                    t0 = time.time()
                    self._real = RealImage(self._filename)
                    print(f"[프록시] 최초 로딩 시간: {time.time()-t0:.3f}s")
        self._real.display()

# 사용
img = ProxyImage("cat_photo.jpg")
print("프록시 생성만으로는 로딩하지 않음")

print("\n=== 첫 번째 표시 ===")
img.display()

print("\n=== 두 번째 표시 ===")
img.display()
```

**핵심**  
- 프록시가 **RealImage 생성을 지연**시켜 첫 사용 시점에만 비용 발생.  
- 락으로 다중 스레드에서 **중복 초기화 방지**.  
- 클라이언트는 `Image` 인터페이스만 알면 된다.

---

## 프록시 패턴의 종류

| 종류               | 목적/용도                                           | 포인트 |
|--------------------|------------------------------------------------------|--------|
| **Virtual Proxy**  | 고비용 자원 **지연 로딩**                            | 최초 접근 시 생성 |
| **Protection Proxy** | **권한/역할 기반 접근 제어**, 감사 로그             | 보안·감사 |
| **Remote Proxy**   | **원격 객체**에 대한 로컬 대표                        | 네트워크 경계 |
| **Smart Reference**| **참조 부가기능**(로깅/레퍼런스 카운트/락/트랜잭션)  | 횡단 관심사 |
| **Caching Proxy**  | 동일 요청 결과 **캐싱/무효화**                       | 성능·비용 절감 |

---

## 구현 예시 2 — Protection Proxy(권한·역할 기반 접근 제어, Python)

```python
from abc import ABC, abstractmethod

# 도메인 서비스 인터페이스
class ReportService(ABC):
    @abstractmethod
    def generate(self, user: str, kind: str) -> str:
        ...

# 실제 서비스
class RealReportService(ReportService):
    def generate(self, user: str, kind: str) -> str:
        return f"[{kind}] report content for {user}"

# 보안 프록시
class SecureReportProxy(ReportService):
    def __init__(self, real: ReportService, rbac: dict[str, set[str]]):
        self._real = real
        self._rbac = rbac  # {"alice":{"FIN","OPS"}, ...}

    def generate(self, user: str, kind: str) -> str:
        roles = self._rbac.get(user, set())
        if kind not in roles:
            raise PermissionError(f"user={user} not allowed for {kind}")
        print(f"[AUDIT] user={user} generate {kind}")
        return self._real.generate(user, kind)

# 사용
rbac = {"alice":{"FIN"}, "bob":{"OPS","FIN"}}
svc  = SecureReportProxy(RealReportService(), rbac)
print(svc.generate("bob", "FIN"))
# print(svc.generate("alice", "OPS"))  # PermissionError
```

**핵심**  
- 프록시에서 **권한 확인/AUDIT 로그** 수행 → RealSubject는 **핵심 로직만** 담당.  
- 보안 규칙 변경 시 프록시만 교체/수정.

---

## 🧑‍💻 구현 예시 3 — Caching/Smart-Ref Proxy(Python)

```python
import functools, time
from typing import Callable

# 캐싱 가능한 비싼 함수(예: 외부 API)
def expensive_fetch(key: str) -> str:
    time.sleep(0.3)  # 비용 시뮬레이션
    return f"data:{key}"

# 프록시: 캐싱 + 간단 로깅
class CachingProxy:
    def __init__(self, fetch: Callable[[str], str], ttl_sec: float = 1.0):
        self._fetch = fetch
        self._ttl = ttl_sec
        self._cache: dict[str, tuple[float, str]] = {}

    def get(self, key: str) -> str:
        now = time.time()
        if key in self._cache:
            ts, val = self._cache[key]
            if now - ts <= self._ttl:
                print("[cache hit]", key)
                return val
        print("[cache miss]", key)
        val = self._fetch(key)
        self._cache[key] = (now, val)
        return val

proxy = CachingProxy(expensive_fetch, ttl_sec=2.0)
print(proxy.get("A"))
print(proxy.get("A"))  # cache hit
time.sleep(2.1)
print(proxy.get("A"))  # cache miss (만료)
```

**핵심**  
- 프록시 외부에서 본질 계약은 `get(key)->data` 그대로 유지.  
- 내부에서 **캐싱/만료/로깅**을 투명하게 처리.

---

## 🧑‍💻 구현 예시 4 — Remote Proxy(원격 호출, Python 모형)

```python
import json, time, random

# Subject
class Payment:
    def pay(self, amount: int) -> str: ...

# RealSubject (서버 쪽에 있다고 가정)
class RealPayment(Payment):
    def pay(self, amount: int) -> str:
        # 실제 결제 처리 (여기선 모형)
        return json.dumps({"status":"OK","amount":amount,"tx":random.randint(1000,9999)})

# Remote Proxy (클라이언트 측)
class PaymentRemoteProxy(Payment):
    def __init__(self, endpoint: str, timeout: float = 1.0):
        self._endpoint = endpoint
        self._timeout = timeout
        self._real = RealPayment()  # 실제론 네트워크 RPC 호출로 대체

    def pay(self, amount: int) -> str:
        t0 = time.time()
        # 실제론 gRPC/HTTP 클라이언트 사용 + 재시도/서킷브레이커
        resp = self._real.pay(amount)
        elapsed = time.time() - t0
        if elapsed > self._timeout:
            raise TimeoutError("remote timeout")
        print(f"[remote] {self._endpoint} {elapsed:.3f}s")
        return resp

# 사용
client = PaymentRemoteProxy("https://pay.example.com")
print(client.pay(4500))
```

**핵심**  
- 프록시는 **네트워크 경계**에서 **타임아웃/재시도/서킷브레이커/로그** 등 **비기능 요구**를 담당.  
- 클라이언트는 `Payment` 인터페이스만 본다.

---

## 성능 모델(간단 수식)

프록시 경유 호출의 평균 지연

\[
T_{\text{proxy}} \;=\; T_{\text{overhead}} \;+\; T_{\text{real}}
\]

- \(T_{\text{overhead}}\): 접근 제어/캐시 조회/로깅/직렬화 등  
- \(T_{\text{real}}\): 실제 작업(디스크/네트워크/CPU)

**캐싱 프록시**에서, 히트율 \(h\), 미스 비용 \(C_m\), 히트 비용 \(C_h\)이면

\[
\mathbb{E}[T] \;=\; h \cdot C_h \;+\; (1-h)\cdot C_m
\]

- \(h↑\)일수록 이득↑. 단, **일관성/무효화 정책** 비용 고려 필요.

---

## 테스트 전략

- **계약 테스트**: `Subject` 인터페이스 기준으로 프록시/실체가 **동일 동작**하는지 확인.  
- **행동 테스트**: 권한 없는 입력 → `PermissionError` 등 **정확한 예외**.  
- **성능/캐시 테스트**: 동일 입력 반복 시 **히트율/지연** 기대 충족.  
- **동시성 테스트**: 지연 로딩 시 **중복 초기화 방지**(락/원자 접근) 검증.  
- **원격/장애 테스트**: 타임아웃/재시도/폴백 경로.

간단 PyTest 스케치:

```python
def test_virtual_proxy_lazy_init(monkeypatch):
    created = {"n":0}
    class Real:
        def __init__(self): created["n"] += 1
        def f(self): return 42
    class P:
        def __init__(self): self.r=None
        def f(self):
            if self.r is None: self.r = Real()
            return self.r.f()

    p = P()
    assert created["n"] == 0
    assert p.f() == 42
    assert created["n"] == 1
    assert p.f() == 42
    assert created["n"] == 1  # 중복 초기화 방지
```

---

## 주의점·안티패턴

- **중복 로직**: 프록시/실체에 같은 검증/로깅이 **중복**되면 유지보수 악화. → **프록시는 횡단 관심사**만.  
- **상태 동기화 문제**: 프록시가 내부 캐시/상태를 가질 때 **무효화 규칙** 명확화.  
- **프록시 남용**: 단순한 경우에도 일괄 프록시 투입 → 복잡도↑. **필요한 경계에만 배치**.  
- **보안 착각**: Protection Proxy는 **코드 내부 보조책**. 외부 공격면(네트워크/스토리지)은 **별도 보안** 필요.  
- **원격 경계 투명성 함정**: 로컬처럼 보이지만 **네트워크 실패/지연** 존재 → 타임아웃/재시도/아이들포킵 얼라이브.

---

## 리팩토링 가이드: “직접 접근 난립” → Proxy 경계로 모으기

1) **비용 큰 의존성/원격 자원/보안 요구**가 드러나는 호출 식별.  
2) 해당 의존성 앞에 **Subject 인터페이스** 정의.  
3) **RealSubject**(핵심 기능)와 **Proxy**(지연·보안·캐시·계측)를 분리.  
4) 상위 계층은 **Subject 타입만 의존**하도록 변경(DI/팩토리).  
5) 성능/보안/장애 시나리오 테스트/관측지표 추가.

---

## 다른 패턴과의 비교/조합

### Proxy vs Decorator vs Adapter vs Facade (확장 표)

| 패턴         | 목적                  | 중심 역할         | 변경 여부             | 전형 위치        |
|--------------|-----------------------|-------------------|-----------------------|------------------|
| **Proxy**    | 접근 제어/지연/캐시   | **대리자**        | **기능 유지(투명)**   | 경계 앞          |
| **Decorator**| 기능 추가/확장        | **확장자**        | **행동 확장**         | 동일 인터페이스  |
| **Adapter**  | 인터페이스 호환       | **변환기**        | **시그니처 변환**     | 경계 사이        |
| **Facade**   | 단순화/오케스트레이션 | **진입점**        | **복합 호출 묶음**    | 서브시스템 바깥  |

**조합 예**  
- **Proxy + Facade**: Facade 앞단에 **Protection/Remote Proxy** 배치.  
- **Proxy + Decorator**: Proxy를 지나간 뒤 로깅/메트릭 **데코레이터 체인** 추가.  
- **Proxy + Adapter**: 원격 API **어댑팅** + 경계에서 **접근 제어**.

---

## 스레드 안전/동시성

- **지연 초기화**는 다중 스레드에서 **중복 생성** 방지(락/원자적 캐시).  
- **캐시 프록시**는 **ConcurrentDictionary/락** 등으로 보호(C#) / `threading.Lock`(Python).  
- **RealSubject**가 스레드 안전하지 않다면 프록시에서 **시리얼라이즈**하거나 **풀링**.

---

## 실전 체크리스트

- 프록시를 도입할 **명확한 이유**(지연/보안/캐시/원격)가 있는가?  
- 인터페이스(Subject) 계약은 명확/안정적인가?  
- 타임아웃/재시도/서킷브레이커/로그/트레이싱을 표준화했는가?  
- 캐시 일관성/만료/무효화 규칙은 무엇인가?  
- 프록시 남용을 피하고, **경계별 최소 개수**로 관리되는가?  
- 테스트: 계약/성능/동시성/장애 주도 시나리오가 갖춰졌는가?

---

## 사용 사례(보강)

| 사용 사례         | 설명 |
|------------------|------|
| **ORM 지연 로딩** | 엔티티 참조가 프록시로 대체되어 필요 시 DB 조회 |
| **이미지/파일 뷰어** | 첫 표시 시 로딩(가상 프록시), 이후 캐시 |
| **보안 시스템**   | 역할 기반 접근 제어(Protection) + 감사 로그 |
| **원격 서비스 호출** | gRPC/HTTP 클라이언트 래퍼(타임아웃/재시도) |
| **결제/송신 게이트웨이** | 호출 전 검증/속도 제한/서킷브레이커 |
| **비용 큰 변환/분석** | 동일 파라미터에 대한 캐싱 프록시 |

---

## 마무리

프록시 패턴은 **“동일 인터페이스”** 아래서 **접근 제어/지연 로딩/캐싱/원격화/계측** 등 **비기능 요구**를 경계에서 흡수한다.  
덕분에 **RealSubject**는 핵심 로직에 집중하고, 클라이언트는 **투명하고 단순한 계약**을 유지한다.  
남용은 복잡성을 부르므로, **명확한 목적이 있는 경계**에만 배치하고, **타임아웃·재시도·캐시·보안**을 표준 정책으로 묶어라.  
그럴 때 프록시는 **성능·안정성·보안**을 동시에 끌어올리는 가장 경제적인 구조적 해법이 된다.