---
layout: post
title: 디자인패턴 - Proxy
date: 2025-06-23 20:20:23 +0900
category: 디자인패턴
---
# Proxy (프록시 패턴)

## ✅ 정의

**프록시 패턴(Proxy Pattern)**은 **어떤 객체에 대한 접근을 제어**하기 위해 **대리 객체(Proxy)**를 사용하는 **구조 패턴(Structural Pattern)**입니다.  
프록시는 실제 객체에 대한 **참조 역할**을 하며, **접근 통제, 지연 로딩, 캐싱, 로깅, 원격 호출 등 다양한 부가기능**을 수행할 수 있습니다.

> “다른 객체에 대한 접근을 대신하거나 제어하는 대리인 역할”

---

## 🎯 의도 (Intent)

- 실제 객체에 대한 접근을 제어
- 객체 생성 비용이 크거나, 외부 시스템에 접근하는 경우 **프록시를 통해 처리**
- 클라이언트는 프록시를 사용하더라도 실제 객체와 **동일한 인터페이스로 작업 가능**

---

## 📦 구조 (UML)

```
         ┌──────────────┐
         │   Client     │
         └─────┬────────┘
               │
         ┌─────▼────────┐
         │   Subject    │◄────┐  (공통 인터페이스)
         └─────▲────────┘     │
         ┌─────┴────────┐     │
         │ RealSubject  │     │
         └──────────────┘     │
         ┌──────────────────┐ │
         │     Proxy        │─┘
         └──────────────────┘
```

- `Subject`: 공통 인터페이스
- `RealSubject`: 실제로 동작하는 객체
- `Proxy`: RealSubject를 대리하여 접근을 제어
- `Client`: Proxy나 RealSubject와 동일한 방식으로 상호작용

---

## 🧑‍💻 구현 예시 (Python)

```python
from abc import ABC, abstractmethod
import time

# Subject 인터페이스
class Image(ABC):
    @abstractmethod
    def display(self):
        pass

# 실제 객체 (리소스가 무거운 작업을 포함)
class RealImage(Image):
    def __init__(self, filename):
        self.filename = filename
        self.load_from_disk()

    def load_from_disk(self):
        print(f"[디스크에서 {self.filename} 로딩 중...]")
        time.sleep(1)  # 로딩 시간 시뮬레이션

    def display(self):
        print(f"{self.filename} 표시")

# 프록시 객체
class ProxyImage(Image):
    def __init__(self, filename):
        self.filename = filename
        self.real_image = None

    def display(self):
        if self.real_image is None:
            self.real_image = RealImage(self.filename)
        self.real_image.display()

# 사용 예시
print("이미지 프록시 생성")
img = ProxyImage("cat_photo.jpg")
print("이미지를 실제로 표시하는 시점까지 로딩 안됨")

print("\n=== 첫 번째 표시 ===")
img.display()  # 실제로 로딩 발생

print("\n=== 두 번째 표시 ===")
img.display()  # 캐싱된 이미지 재사용
```

**출력 예:**
```
이미지 프록시 생성
이미지를 실제로 표시하는 시점까지 로딩 안됨

=== 첫 번째 표시 ===
[디스크에서 cat_photo.jpg 로딩 중...]
cat_photo.jpg 표시

=== 두 번째 표시 ===
cat_photo.jpg 표시
```

---

## ✅ 장점

- **접근 제어**가 가능함 (권한 확인, 로깅 등)
- **리소스 지연 로딩(Lazy Loading)** 가능
- **캐싱, 성능 향상** 등의 부가기능을 유연하게 확장 가능
- 실제 객체를 **필요할 때만 생성** 가능 (메모리 절약)

---

## ⚠️ 단점

- 구조가 복잡해질 수 있으며, **클래스 수 증가**
- 프록시와 실제 객체 간 **상태 동기화 주의 필요**
- 부적절한 설계 시 **중복 로직이나 퍼포먼스 저하** 유발 가능

---

## 📌 프록시 패턴의 종류

| 종류 | 설명 |
|------|------|
| **Virtual Proxy** | 실제 객체 생성을 지연시키기 위한 프록시 (지연 로딩) |
| **Protection Proxy** | 접근 권한을 제어하는 프록시 (보안용) |
| **Remote Proxy** | 다른 네트워크에 있는 객체에 대한 대리자 (예: RPC, gRPC) |
| **Smart Reference** | 참조 횟수 카운트, 로깅, 캐싱 등을 포함하는 프록시 |
| **Caching Proxy** | 동일 요청에 대한 결과를 캐시해 성능 향상 |

---

## 📌 사용 사례

| 사용 사례 | 설명 |
|-----------|------|
| **ORM (지연 로딩)** | 실제 엔티티를 DB에서 불러오기 전에 프록시 객체 제공 |
| **이미지/파일 뷰어** | 파일을 열기 전에 미리보기 프록시 제공 |
| **보안 시스템** | 관리자 권한이 있는 사용자인지 프록시에서 확인 |
| **원격 서비스** | gRPC, SOAP, RMI 같은 분산 객체 프레임워크에서 사용 |
| **가상 프록시** | 객체 생성 비용이 큰 경우 실제 사용 시점까지 생성 보류 |

---

## 🧠 Proxy vs Decorator vs Adapter vs Facade

| 패턴       | 목적 | 중심 역할 | 변경 여부 |
|------------|------|-----------|-----------|
| **Proxy**   | 접근 제어 | 대리자 | 기능 유지 |
| **Decorator** | 기능 추가 | 확장자 | 기능 확장 |
| **Adapter** | 호환성 | 변환기 | 인터페이스 변경 |
| **Facade**  | 단순화 | 인터페이스 | 시스템 단순화 |

---

## 🧠 마무리

**프록시 패턴은 실제 객체와 동일한 인터페이스를 제공하면서도,**  
**접근 제어, 지연 로딩, 로깅, 보안, 캐싱 등 다양한 부가기능을 유연하게 처리**할 수 있게 해줍니다.  

리소스를 아끼고, 복잡한 객체 생성을 통제하거나 보안을 강화하고 싶을 때 매우 유용한 패턴입니다.  
단, **프록시 남용으로 설계가 과도하게 복잡해지지 않도록 주의해야 합니다.**