---
layout: post
title: 형식언어와 오토마타 - 문맥 자유 언어의 폐포 성질과 결정 가능한 성질들
date: 2025-07-30 16:20:23 +0900
category: 형식언어와 오토마타
---
# 문맥 자유 언어(CFL)의 **폐포 성질**과 **결정 알고리즘** (총정리 + 예제 코드)

## 0) 표기와 준비

- 입력 알파벳: \( \Sigma \), 모든 문자열 집합: \( \Sigma^* \)  
- CFG \( G=(V,\Sigma,R,S) \): 비단말 \(V\), 터미널 \( \Sigma \), 생성규칙 \(R\), 시작기호 \(S\)  
- PDA: Pushdown Automaton, DCFL: Deterministic CFL  
- 문자열 역순: \( w^R \), 언어 역순: \( L^R=\{w^R\mid w\in L\} \)

---

## 1) CFL의 **폐포 성질(Closure)**

### 1.1 닫혀 **있다(Yes)**

아래 성질들은 **CFL에 대해 보존**됩니다. 각 항목 옆에 **구성법**과 짧은 **스케치**를 함께 둡니다.

1) **합집합** \(L_1 \cup L_2\) — **Yes**  
   - **구성**: 새 시작기호 \(S\) 추가, \(S\to S_1 \mid S_2\). (단, 두 문법의 비단말은 이름 충돌 없도록 리네임)  
   - **직관**: “시작에서 어느 쪽을 쓸지”만 선택하면 끝.

2) **연접(Concatenation)** \(L_1 L_2\) — **Yes**  
   - **구성**: \(S\to S_1 S_2\).  
   - **직관**: \(S_1\)로 전반부, \(S_2\)로 후반부 생성.

3) **Kleene 스타** \(L^*\) — **Yes**  
   - **구성**: 새 시작 \(S\)에서 \(S\to S S \mid \varepsilon \mid S_0\) (안전하게는 중간 비단말 도입).  
   - **직관**: “0번 이상 반복”을 문법적으로 재귀.

4) **역순(Reverse)** \(L^R\) — **Yes**  
   - **구성**: 규칙 \(A\to X_1 X_2\cdots X_k\)를 \(A\to X_k \cdots X_2 X_1\)로 뒤집기(터미널/비단말 순서 반전).  
   - **직관**: 파스 트리를 좌우 반전.

5) **호모모르피즘** \(h(L)\) — **Yes**  
   - **구성**: 각 터미널 \(a\)를 \(h(a)\in\Sigma'^*\)로 치환한 규칙군을 구성(필요시 CNF/GNF 변환).  
   - **직관**: 터미널을 문자열로 바꾸는 “후처리”.

6) **역(逆)호모모르피즘** \(h^{-1}(L)\) — **Yes**  
   - **구성**: “입력 전처리”로 \(h\)를 모사. PDA/CFG 앞단에서 \(h\)가 만들어낼 스트림만 허용.  
   - **직관**: \(w\in h^{-1}(L) \iff h(w)\in L\).

7) **정규언어와의 교집합** \(L_{\text{CFL}}\cap R_{\text{REG}}\) — **Yes**  
   - **구성**: **PDA×DFA 제품**. PDA의 상태와 스택은 유지하면서 DFA 상태를 함께 추적.  
   - **직관**: “정규 필터”를 통과한 입력만 인정.

8) **정규언어와의 몫(Quotient)** — **Yes**  
   - 우몫 \(L/R=\{x\mid \exists y\in R: xy\in L\}\), 좌몫 \(R\backslash L=\{y\mid \exists x\in R: xy\in L\}\)  
   - **스케치**: 정규는 NFA/DFA로 다룰 수 있으므로 “앞/뒤에 정규를 붙여도 가능한가?”를 PDA와 동기화하여 비결정 추적으로 처리 가능.

9) **Prefix/Suffix/Factor(부분문자열) 집합** — **Yes**  
   - \( \mathrm{Pref}(L)=L/\Sigma^*,\ \mathrm{Suff}(L)=\Sigma^*\backslash L,\ \mathrm{Substr}(L)=\Sigma^*\backslash L/\Sigma^* \)  
   - **직관**: 위 8) 몫 닫힘에 의해 귀결.

10) **대치(Substitution)** — **Yes**  
    - 각 문자 \(a\)를 **CFL \(L_a\)** 로 치환하는 치환 \(s\)에 대해 \(s(L)\)은 CFL.  
    - **스케치**: 치환을 PDA 합성으로 모사(각 \(a\)를 읽을 때 \(L_a\)의 PDA 실행을 삽입).

> **요약**: “정규와의 상호작용(교집합/몫)”, “문자 치환(호모·역호모·대치)”, “합·연접·스타·역순”은 **안전**.

---

### 1.2 닫혀 **있지 않다(No)**

1) **CFL과 CFL의 교집합** — **No**  
   - **반례**:  
     \(L_1=\{a^i b^i c^j\mid i,j\ge 0\}\) (CFL),  
     \(L_2=\{a^i b^j c^j\mid i,j\ge 0\}\) (CFL).  
     그러면 \(L_1\cap L_2=\{a^n b^n c^n\mid n\ge 0\}\) — **비CFL**.

2) **여집합/차집합** — **No** (일반 CFL)  
   - **귀결**: 차집합도 닫히지 않음.  
   - (단, **DCFL**은 **보수에 닫힘**.)

3) **Shuffle(섞기)** — **No**  
   - 두 문자열을 인터리브한 모든 결과를 허용하는 연산은 CFL에서 일반적으로 안정적이지 않음.

4) **CFL과의 몫(상호 몫)** — **No** (정규와의 몫만 **Yes**)

> **팁**: **정규**가 끼면 대개 잘 된다. **CFL끼리** 조합(교집합/보수/차)은 위험.

---

## 2) **결정 가능(Decidable)** 한 것들

### 2.1 **멤버십(소속성)** \( w\stackrel{?}{\in}L(G) \) — **Decidable**

- **CYK**: CFG를 **CNF**로 바꾸고 \(O(n^3)\)에서 판정.  
- **Earley**: 임의 CFG, 최악 \(O(n^3)\) (실무에서 평균적으로 우수).  

#### (요약) CYK 의사코드
```text
Input: CNF G, w=a1...an
P[i][j] = { 비단말 | w[i..j]를 유도 }
for i=1..n:    P[i][i] ← { A | A→ai }
for len=2..n:
  for i=1..n-len+1:
    j=i+len-1
    P[i][j] ← ⋃_{k=i..j-1} { A | A→BC, B∈P[i][k], C∈P[k+1][j] }
return (S ∈ P[1][n])
```

#### (실습) **간단 CYK 파서 (교육용)**
```python
# CNF-like CYK (교육용 소형 구현)
from collections import defaultdict

def cyk_membership(w, cnf, start='S'):
    """
    cnf: dict with keys tuple of symbols on RHS
         ex) ('a',) -> ['A']; ('B','C') -> ['S', ...]
    """
    n = len(w)
    if n == 0:
        # 빈 문자열 처리: 'ε' 키에 start가 있으면 True
        return 'ε' in cnf and start in cnf['ε']

    # P[i][l] = set of variables deriving w[i:i+l]
    P = [[set() for _ in range(n+1)] for _ in range(n)]
    # length 1
    for i,ch in enumerate(w):
        for A in cnf.get((ch,), []):
            P[i][1].add(A)
    # length >=2
    for l in range(2, n+1):
        for i in range(0, n-l+1):
            cell = P[i][l]
            for k in range(1, l):
                L = P[i][k]
                R = P[i+k][l-k]
                if not L or not R: 
                    continue
                for B in L:
                    for C in R:
                        cell.update(cnf.get((B,C), []))
    return start in P[0][n]

# 예: a^+ b^+ 를 대충 표현하는 '교육용 CNF 사전'
cnf_demo = {
    ('a',): ['A'],
    ('b',): ['B'],
    ('A','A'): ['A'],   # A -> A A
    ('B','B'): ['B'],   # B -> B B
    ('A','B'): ['S'],   # S -> A B
}
print("aabb :", cyk_membership("aabb", cnf_demo, 'S'))   # True (a^+ b^+)
print("aaab :", cyk_membership("aaab", cnf_demo, 'S'))   # True
print("abaa :", cyk_membership("abaa", cnf_demo, 'S'))   # False
```

> 주의: 위 사전은 **엄밀한 CNF 변환**이 아닌 교육용 근사입니다. 실무는 정식 CNF 변환기를 사용하세요.

---

### 2.2 **Emptiness(공백성)** \( L(G)=\varnothing? \) — **Decidable**

- **아이디어**: “**생성 가능(terminating)**”한 비단말을 먼저 마킹하고, 그로부터 **도달 가능(reachable)**한 비단말만 남긴다. 시작기호 \(S\)가 생성 가능/도달 가능이 아니면 공백.

```python
def cfg_emptiness(variables, terminals, rules, start):
    """
    rules: dict A -> list of RHS (each RHS is tuple of symbols)
    1) generating 마킹
    2) reachable 마킹
    """
    gen = set()
    changed = True
    while changed:
        changed = False
        for A, rhss in rules.items():
            if A in gen: 
                continue
            for rhs in rhss:
                if all(sym in terminals or sym in gen for sym in rhs):
                    gen.add(A); changed = True; break

    # generating 아닌 비단말/규칙 제거
    rules2 = {A:[rhs for rhs in rhss if all(sym in terminals or sym in gen for sym in rhs)]
              for A,rhss in rules.items() if A in gen}

    # reachable
    reach = set([start])
    changed = True
    while changed:
        changed = False
        for A,rhss in rules2.items():
            if A not in reach: 
                continue
            for rhs in rhss:
                for sym in rhs:
                    if sym in rules2 and sym not in reach:
                        reach.add(sym); changed = True

    return not (start in reach)
```

---

### 2.3 **유한성(Finiteness)** — **Decidable**

- **절차**:  
  1) 위처럼 **생성 가능** + **도달 가능** 비단말만 유지.  
  2) 남은 규칙 그래프(비단말 간 이동)에 **터미널을 생성하는 순환(cycle)** 가 있으면 **무한**, 없으면 **유한**.
- **직관**: 아무리 돌아도 터미널 길이가 증가하지 않는다면 유한. 길이를 증가시키는 루프가 존재하면 무한.

```python
def cfg_finiteness(variables, terminals, rules, start):
    # 1) generating + reachable 필터 (위 함수 변형해서 사용했다고 가정)
    # 2) 비단말 그래프에서 cycle 탐지 + "길이 증가" 여부 체크
    from collections import defaultdict, deque

    # 간단화: 비단말 그래프 에지 A->B (RHS에 B가 있으면)
    graph = defaultdict(set)
    inc = defaultdict(bool)  # A에서 한 번 규칙 적용 시 길이 증가 가능성

    for A, rhss in rules.items():
        for rhs in rhss:
            added_len = sum(1 for s in rhs if s in terminals)
            if added_len > 0: inc[A] = True
            for s in rhs:
                if s in rules: graph[A].add(s)

    # cycle 검출(BFS/DFS) + cycle 내에서 'inc'가 닿으면 무한
    color = {A:0 for A in rules}  # 0:unseen 1:visiting 2:done
    infinite = False

    def dfs(u, stack):
        nonlocal infinite
        color[u] = 1
        stack.append(u)
        for v in graph[u]:
            if color[v] == 0: dfs(v, stack)
            elif color[v] == 1:
                # cycle 발견: stack에서 v..u 구간 확인
                idx = len(stack)-1
                cyc = set([v])
                while idx>=0 and stack[idx]!=v:
                    cyc.add(stack[idx]); idx -= 1
                # cycle 내에서 길이 증가가 가능한 비단말이 있으면 무한
                if any(inc[x] for x in cyc):
                    infinite = True
        color[u] = 2
        stack.pop()

    if start in rules:
        dfs(start, [])

    return (not infinite)  # True면 유한, False면 무한
```

---

### 2.4 **정규와의 교차 공백성** \( L(G)\cap R = \varnothing? \) — **Decidable**

- **방법**: PDA×DFA 제품으로 PDA’를 만들고 **Emptiness**로 판정.  
- **직관**: “정규 필터” 통과 여부를 PDA 상태에 동기화.

#### (개념) PDA×DFA 제품 의사코드
```text
Input: PDA M=(Q,Σ,Γ,δ,q0,Z0,F), DFA A=(Q_A,Σ,δ_A,qA0,F_A)
Product PDA M' states: Q' = Q × Q_A
Initial: (q0, qA0), stack Z0
Transition:
  - if δ(q, a or ε, X) contains (q', γ) then
    for DFA part:
      if a∈Σ: qA' = δ_A(qA, a)
      if ε:    qA' = qA (stay)
    add transition ((q,qA), a or ε, X) -> ((q', qA'), γ)
Accept:
  - final-by-state: (q∈F and qA∈F_A)  (또는 empty-stack 방식과 조합)
```

---

### 2.5 **Undecidable** (일반 CFL)

- **포함** \(L(G_1)\subseteq L(G_2)\) — Undecidable  
- **동치성** \(L(G_1)=L(G_2)\) — Undecidable  
- **보편성** \(L(G)=\Sigma^*\) — Undecidable  
- **교집합 공백성(두 CFL 사이)** — Undecidable  
- **모호성(Grammar ambiguity)** — Undecidable  
- **정규성 판정**(주어진 CFG가 정규인지) — Undecidable  

> (참고) **DCFL**의 보수는 **결정 가능**(닫힘). DCFL 간 **동치성**은 이론적으로 **결정 가능**(Sénizergues),  
> 다만 실용 복잡도는 현실적으로 매우 큽니다.

---

## 3) 구성/증명 **스케치** (핵심 몇 가지)

### 3.1 \( \mathbf{CFL}\cap\mathbf{REG} \) 닫힘 (PDA×DFA)

- **핵심**: PDA 한 스텝마다 DFA도 같은 입력 심볼(또는 ε일 땐 정지)을 따라가도록 **제품 상태**에서 동기화.

### 3.2 호모·역호모

- **호모**: 터미널 치환을 문법 우변에 직접 **합성**.  
- **역호모**: “\(h\)로 전처리된 입력만 받아들인다”는 장치를 PDA/CFG 앞단에 둔다.

### 3.3 Prefix/Suffix/Factor = 정규와의 몫

- Prefix = \( L/\Sigma^* \), Suffix = \( \Sigma^*\backslash L \), Factor = \( \Sigma^*\backslash L/\Sigma^* \).  
- 정규와의 몫에 닫힘 ⇒ 모두 CFL.

---

## 4) **예제·상황**으로 보는 폐포와 결정 절차

### 4.1 “정규 필터로 거르기” (현업 Tip)

**상황**: 로그에서 “\<expr\>”가 **문법적으로 올바르면서** 정규 패턴(예: 특정 Prefix를 갖는)인 것만 추출.  
- 해결: CFG(또는 PDA)로 **구문성**을 보장 + 정규식으로 **패턴 필터**.  
- 이때 결과 언어는 \( \text{CFL}\cap\text{REG} \) 이므로 **여전히 CFL**이고, **Emptiness/멤버십**을 결정할 수 있음.

### 4.2 “합/연접/스타로 조립”

**상황**: 작은 문법 조각(숫자, 식별자, 괄호표현 등)을  
- **합**으로 선택지를 모으고,  
- **연접**으로 순서를 결합,  
- **스타**로 반복을 허용.  
→ 최종적으로도 **CFL** 보장.

### 4.3 “교집합 함정”

**상황**: 두 가지 구조 제약을 **동시에** 만족시키게 하려 \(\cap\)을 쓰고 싶은데 둘 다 CFL.  
- 주의: **일반적으로 No**. 반례 패턴(세 블록 균형) 떠올리기.  
- 우회: 한쪽을 **정규**로 제한(리팩토링)하거나, **결정적 파서(DCFL)** 구조로 재설계.

---

## 5) **코드 데모** — 정규와의 교차 멤버십(CYK 확장 아이디어)

**목적**: CNF-기반 CYK를 **DFA 상태 추적**과 결합해  
\( w\in L(G)\cap R \) 여부를 점검(교육용, 축약 표현).

> 아이디어: DP 셀에 “비단말 A가 \(w[i..j]\)를 유도” 뿐 아니라  
> “**DFA가 상태 p에서 시작해 q로 간다**”를 함께 저장해 조합.

```python
from collections import defaultdict

def cyk_with_dfa(w, cnf, dfa, start='S'):
    """
    cnf: ('a',)->[A], ('B','C')->[A] 형식의 CNF-like dict
    dfa: { 'states': set, 'start': q0, 'finals': set, 'delta': {(q,a):q'} }
    반환: w ∈ L(G) ∩ L(DFA) ?
    """
    n = len(w)
    Q = dfa['states']; q0 = dfa['start']; F = dfa['finals']; D = dfa['delta']

    # 프리컴퓨트: DFA에서 substring 이동
    # dfa_step[i][j] = { (p,q) | a_i..a_j 읽으면 p->q }
    dfa_step = [[set() for _ in range(n+1)] for _ in range(n)]
    for i in range(n):
        for p in Q:
            q = p
            q = D.get((q, w[i]), None)
            if q is not None:
                dfa_step[i][1].add((p,q))
    for l in range(2, n+1):
        for i in range(0, n-l+1):
            for k in range(1, l):
                left = dfa_step[i][k]
                right = dfa_step[i+k][l-k]
                for (p,m) in left:
                    for (m2,q) in right:
                        if m == m2:
                            dfa_step[i][l].add((p,q))

    # CYK with DFA states: P[i][l] = set of (A,p,q)
    P = [[set() for _ in range(n+1)] for _ in range(n)]

    # 길이 1
    for i,ch in enumerate(w):
        for A in cnf.get((ch,), []):
            # 한 글자 읽는 DFA 이동 페어 삽입
            for (p,q) in dfa_step[i][1]:
                P[i][1].add((A,p,q))

    # 길이 >=2
    for l in range(2, n+1):
        for i in range(0, n-l+1):
            cell = P[i][l]
            for k in range(1, l):
                L = P[i][k]
                R = P[i+k][l-k]
                if not L or not R: 
                    continue
                for (B,p,m) in L:
                    for (C,m2,q) in R:
                        if m != m2: 
                            continue
                        for A in cnf.get((B,C), []):
                            cell.add((A,p,q))

    # 시작기호 + DFA 전체소비: q0 -> qf ∈ F
    for (A,p,q) in P[0][n]:
        if A==start and p==q0 and q in F:
            return True
    return False

# 간단 DFA: 정규 a* b* (즉, a만 읽다가 b만 읽는 패턴)
Q = {'q0','q1','dead'}
dfa = {'states':Q,'start':'q0','finals':{'q0','q1'},
       'delta':{
           ('q0','a'):'q0', ('q0','b'):'q1',
           ('q1','a'):'dead', ('q1','b'):'q1',
           ('dead','a'):'dead', ('dead','b'):'dead'
       }}

# CNF-like for a^+ b^+  (교육용)
cnf_demo = {
    ('a',): ['A'], ('b',): ['B'],
    ('A','A'): ['A'], ('B','B'): ['B'], ('A','B'): ['S']
}

print("aabb in L(G)∩a*b* ?", cyk_with_dfa("aabb", cnf_demo, dfa, 'S')) # True
print("abab in L(G)∩a*b* ?", cyk_with_dfa("abab", cnf_demo, dfa, 'S')) # False
```

- **의미**: “문법적 올바름”과 “정규 패턴 적합”을 동시에 확인.  
- **활용**: “CFL 문법으로 파싱 + 정규로 화이트리스트/블랙리스트” 같은 실무 시나리오.

---

## 6) **결론 요약표**

### 6.1 폐포 성질

| 연산 | CFL 닫힘? | 스케치/메모 |
|---|---|---|
| 합집합 \(\cup\) | **Yes** | \(S\to S_1\mid S_2\) |
| 연접 \( \cdot \) | **Yes** | \(S\to S_1 S_2\) |
| Kleene 스타 \(^*\) | **Yes** | 반복 규칙 |
| 역순 \( ^R \) | **Yes** | 규칙 뒤집기 |
| 호모모르피즘 \(h\) | **Yes** | 터미널 치환 |
| 역호모 \(h^{-1}\) | **Yes** | 전처리 모사 |
| 대치(Substitution) | **Yes** | 문자→CFL 치환 |
| 정규와의 교집합 | **Yes** | PDA×DFA 제품 |
| 정규와의 몫(좌/우) | **Yes** | 비결정 추적 |
| Prefix/Suffix/Factor | **Yes** | 정규 몫 조합 |
| **CFL∩CFL** | **No** | 고전 반례 |
| 보수/차집합 | **No** | DCFL 보수=Yes |
| Shuffle | **No** |  |

### 6.2 결정 가능 성질

| 성질 | CFL | 비고 |
|---|---|---|
| 멤버십 \(w\in L\) | **Decidable** | CYK/Earley |
| 공백성 \(L=\varnothing\) | **Decidable** | generating/reachable |
| 유한성 | **Decidable** | 길이 증가 루프 |
| \(L\cap R=\varnothing\) (정규 \(R\)) | **Decidable** | PDA×DFA→Emptiness |
| 포함/동치/보편성/모호성 | **Undecidable** | 일반 CFL |
| 정규성 판정 | **Undecidable** |  |
| (참고) DCFL 보수 | **Decidable** | DCFL은 보수 닫힘 |
| (참고) DCFL 동치성 | **Decidable** | 이론적(매우 난해) |

---

## 7) 공부·실무 팁

- **정규 필터** 적극 활용: \( \text{CFL}\cap\text{REG} \)는 여전히 CFL ⇒ **결정 절차**(Emptiness 등)로 접근 가능.  
- **CNF+CYK**는 기본기: 멤버십/파싱의 표준 레퍼런스. 모호한 문법은 **Earley/GLR**도 고려.  
- **Undecidable 회피**: 포함/동치/모호성은 일반적으로 불가. **정규** 또는 **결정적(DCFL)** 제약으로 설계를 리팩토링하거나 **근사**로 운영.  
- **반례 패턴** 암기: \(a^n b^n c^n\), \(\{ww\}\)류는 “CFL 한계를 드러내는 현판” 역할.

---

## 8) 미니 연습

1) \(L=\{a^n b^{2n}\mid n\ge 0\}\). CFL인가? 정규인가?  
   - 힌트: \(S\to a S b b \mid \varepsilon\) 로 CFG 가능 ⇒ **CFL**(정규는 아님).  

2) \(L=\{a^i b^j c^k \mid i=j \text{ or } j=k\}\). CFL인가?  
   - 힌트: \(L=L_1\cup L_2\) 로, \(L_1=\{i=j\}\), \(L_2=\{j=k\}\) 는 각각 CFL ⇒ 합으로 **CFL**.  

3) \(L=\{a^n b^n c^m d^m\}\) 의 정규와 교차 공백성 판정은?  
   - 힌트: 정규 \(R\)과 제품 구성 → PDA’ Emptiness.

---

### (부록) 수식 리마인더

- CYK 핵심 점화:
$$
P[i,j] \;=\; \bigcup_{k=i}^{j-1}\{\,A \mid A\to B C,\; B\in P[i,k],\; C\in P[k+1,j]\,\}.
$$

- 정규와의 교집합(제품 상태):
$$
Q' \;=\; Q_{\text{PDA}}\times Q_{\text{DFA}},\quad
\delta'((q,p),a,X)\ni \bigl((q',\delta_A(p,a)),\gamma\bigr).
$$

---

**요약 한 줄**:  
> **CFL**은 **정규와의 상호작용**(교집합/몫)과 **치환류/합·연접·스타·역순**에 **닫혀** 있으며,  
> **멤버십/공백/유한/정규교차공백**은 **결정 가능**. 반면 **CFL∩CFL/보수/차/Shuffle**은 일반적으로 **No**,  
> 포함/동치/모호성 등은 **Undecidable**이다. 실무에서는 **정규 필터+CYK/Earley** 전략이 강력하다.