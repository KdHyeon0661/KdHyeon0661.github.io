---
layout: post
title: 디자인패턴 - 개요
date: 2025-06-09 19:20:23 +0900
category: 디자인패턴
---
# 디자인 패턴이란?

## 0. 왜 디자인 패턴인가

1) **반복 문제의 재사용 해법**
동일·유사한 설계 문제를 **짧은 시간**에, **품질 손상 없이** 재해결한다.

2) **유지보수성/확장성 향상**
SOLID 원칙(단일책임, 개방폐쇄, 리스코프 치환, 인터페이스 분리, 의존성 역전)에 부합하는 구조를 암묵적으로 강제한다.

3) **공통 언어**
“데코레이터로 감싸자”, “여긴 전략으로 분리” 같은 **압축 의사소통**이 가능하다.

4) **느슨한 결합과 응집도 개선**
관심사 분리, 캡슐화, 다형성, 위임을 **실전 구조**로 구현한다. (예: 옵저버는 느슨한 결합의 대표적 구현)

5) **일관성과 가독성**
역할이 명확해져 온보딩과 코드 리뷰가 쉬워진다.

> 남용은 금물: 불필요한 추상화는 복잡도·학습비용을 급증시킨다. **“현재의 구체적 문제”**에 꼭 맞는 패턴만 적용하라.

---

## 1. 분류 지도(GoF + 실무 확장)

| 분류 | 패턴 |
|---|---|
| **생성(Creational)** | 싱글턴, 팩토리 메서드, **추상 팩토리**, 빌더, 프로토타입 |
| **구조(Structural)** | 어댑터, 브리지, 컴포지트, 데코레이터, 퍼사드, 플라이웨이트, 프록시 |
| **행위(Behavioral)** | 책임 연쇄, 커맨드, 인터프리터, 이터레이터, 미디에이터, 메멘토, 옵저버, 상태, 전략, 템플릿 메서드, 비지터 |
| **동시성/리액티브(실무)** | 스레드 풀, **퓨처/프로미스**, 리액터, 파이프-필터, 액티브 오브젝트, 가드 서스펜션/볼킹 |

---

## 2. SOLID ↔ 패턴 매핑(현업 감각)

- **SRP**: 퍼사드(복잡한 서브시스템을 한 책임으로 노출), 빌더(생성과 표현 분리)
- **OCP**: 전략·데코레이터(새 기능/알고리즘을 **확장**으로 수용)
- **LSP**: 템플릿 메서드/상속 기반 프레임(치환 가능한 서브클래스 계약)
- **ISP**: 어댑터(좁은 인터페이스로 수축), 인터페이스 분해+추상 팩토리
- **DIP**: 팩토리 계열/DI 컨테이너(상위-하위 의존 역전)

---

## 3. 공통 표기와 읽는 법

- **의도(Intent)**: 패턴이 해결하려는 문제의 한 줄 요약
- **문제/맥락(Context)**: 언제·왜 필요한가
- **구조(Structure)**: 역할/협력 다이어그램(텍스트로 간단 표기)
- **구현·예제**: Python/C# 중심(간결하지만 실제 적용 가능한 수준)
- **검증(Test Points)**: 단위·통합 테스트 관점
- **리팩토링 레시피**: 기존 코드에서 이 패턴으로 **가는 경로**
- **주의·안티패턴**: 남용/함정

---

## 4. 패턴별 정리

### 4.1 싱글턴(Singleton)

**의도**: 인스턴스를 정확히 **하나**만 보장하고, 전역 접근점을 제공.
**문제**: 구성/캐시/레지스트리 등 **공유 리소스**를 한 곳에서 관리.

**구조**
```
Client -> Singleton.getInstance() -> Singleton
```

**Python (게으른 초기화)**
```python
class Config:
    _inst = None
    def __new__(cls):
        if cls._inst is None:
            cls._inst = super().__new__(cls)
            cls._inst._load()
        return cls._inst
    def _load(self):
        self.items = {"region": "ap-northeast-2"}
```

**C# (Lazy<T> 안전)**
```csharp
public sealed class Config
{
    private static readonly Lazy<Config> _inst = new(() => new Config());
    public static Config Instance => _inst.Value;
    private Config() { /* load */ }
}
```

**검증**: **동일 참조** 여부, 멀티스레드 경쟁 없음.
**리팩토링**: 전역 변수 → 생성자 주입 + Singleton(또는 DI 컨테이너로 대체).
**주의**: 테스트 어려움(전역 상태), 수명/순서 의존. 가능하면 **DI**로 대체.

---

### 4.2 팩토리 메서드(Factory Method)

**의도**: 객체 생성을 서브클래스에 위임(**새 타입 추가에 열려**).
**문제**: 생성 로직이 분기/조건으로 오염.

**구조**
```
Creator.factoryMethod() -> Product
ConcreteCreatorA -> ConcreteProductA
ConcreteCreatorB -> ConcreteProductB
```

**C#**
```csharp
abstract class LoggerFactory
{
    public abstract ILogger Create();
}
class FileLoggerFactory : LoggerFactory
{
    public override ILogger Create() => new FileLogger("app.log");
}
class ConsoleLoggerFactory : LoggerFactory
{
    public override ILogger Create() => new ConsoleLogger();
}
```

**검증**: 새 타입 추가 시 **기존 코드 수정 최소**.
**리팩토링**: switch-분기 생성 → Creator 계층으로 이전.
**주의**: 과도한 계층화 지양. 간단하면 **단순 함수/DI**로 충분.

---

### 4.3 추상 팩토리(Abstract Factory)

**의도**: **관련된 객체 군**을 일관되게 생성. (테마/플랫폼)
**예**: DarkTheme 위젯 세트 vs LightTheme 세트.

**구조**
```
AbstractFactory -> CreateButton(), CreateTextbox()
ConcreteFactoryDark -> DarkButton, DarkTextbox
ConcreteFactoryLight -> LightButton, LightTextbox
```

**C#**
```csharp
interface IWidgetFactory { IButton Button(); ITextbox Textbox(); }
class DarkFactory : IWidgetFactory { public IButton Button()=>new DarkButton(); public ITextbox Textbox()=>new DarkTextbox(); }
class LightFactory : IWidgetFactory { public IButton Button()=>new LightButton(); public ITextbox Textbox()=>new LightTextbox(); }
```

**검증**: **교체 가능**한 공장으로 **일관 UI** 생성.
**주의**: 제품군 폭발 시 복잡. **조합이 많다면** → 빌더/프로퍼티 설정 고려.

---

### 4.4 빌더(Builder)

**의도**: 복잡한 객체의 **구성 단계를 분리**하여 다양한 표현 생성.
**예**: HTTP 요청/SQL 쿼리/문서 생성.

**Python**
```python
class SqlBuilder:
    def __init__(self): self._s=["SELECT * FROM users"]
    def where(self, cond): self._s.append("WHERE " + cond); return self
    def order(self, col): self._s.append("ORDER BY " + col); return self
    def build(self): return " ".join(self._s)

q = SqlBuilder().where("age>=18").order("name").build()
```

**검증**: 단계 순서 유연, 불완전 객체 방지.
**리팩토링**: 생성자 매개변수 과다 → 빌더 도입.
**주의**: 과도한 Fluent API는 **가독성 저하**.

---

### 4.5 프로토타입(Prototype)

**의도**: **복제**로 새 인스턴스 생성(런타임 타입 보존).
**예**: UI 컴포넌트/설정 템플릿 복제.

**Python**
```python
import copy
class Node:
    def __init__(self, text, style): self.text=text; self.style=style
    def clone(self): return copy.deepcopy(self)
```

**주의**: 얕은/깊은 복사 경계, 식별자 재사용 금지.

---

### 4.6 어댑터(Adapter)

**의도**: **호환되지 않는 인터페이스**를 맞춘다.
**예**: 레거시 API 포맷 ↔ 신규 인터페이스.

**C#**
```csharp
interface INewPayment { void Pay(decimal amount); }
class OldGateway { public void Send(int cents) { /* ... */ } }

class PaymentAdapter : INewPayment
{
    private readonly OldGateway _old = new();
    public void Pay(decimal amount) => _old.Send((int)(amount * 100));
}
```

**검증**: 클라이언트는 **새 인터페이스만** 의존.
**주의**: 변환 비용/에러 매핑 명확히.

---

### 4.7 브리지(Bridge)

**의도**: 추상(Abstraction)과 구현(Implementation)을 **독립적으로 변형**.
**예**: 도형(원/사각) ↔ 렌더러(벡터/래스터).

**C#**
```csharp
interface IRenderer { void DrawCircle(float x, float y, float r); }
class VectorRenderer : IRenderer { public void DrawCircle(float x,y,r){ /* ... */ } }

abstract class Shape { protected IRenderer R; protected Shape(IRenderer r){R=r;} public abstract void Draw();}
class Circle : Shape { float x,y,r; public Circle(IRenderer r,float x,float y,float r):base(r){this.x=x;this.y=y;this.r=r;} public override void Draw()=>R.DrawCircle(x,y,r); }
```

**장점**: 조합 폭발 억제(상속 대신 합성).
**주의**: 과도하면 이해 난이도↑.

---

### 4.8 컴포지트(Composite)

**의도**: 개별 객체와 **그룹을 동일하게** 취급(트리).
**예**: 파일시스템, GUI 컨테이너.

**Python**
```python
class Component:
    def render(self): raise NotImplementedError
class Leaf(Component):
    def __init__(self, text): self.text=text
    def render(self): return self.text
class Composite(Component):
    def __init__(self): self.children=[]
    def add(self,c): self.children.append(c)
    def render(self): return "".join(ch.render() for ch in self.children)
```

**검증**: 클라이언트는 Leaf/Composite 구분 불필요.
**주의**: 순환 참조, 부모 포인터 관리.

---

### 4.9 데코레이터(Decorator)

**의도**: 객체에 **동적으로 책임 추가**(상속 대안).
**예**: 스트림 압축/암호화/버퍼링 체인.

**C#**
```csharp
interface IService { string Get(); }
class Core : IService { public string Get()=>"data"; }
class Logging : IService { private readonly IService _next; public Logging(IService n){_next=n;} public string Get(){ Console.WriteLine("call"); return _next.Get(); } }
class Caching : IService { /* wrap _next with cache */ }
```

**검증**: 기능 조합이 런타임에 유연.
**주의**: 디버깅/순서 의존성.

---

### 4.10 퍼사드(Facade)

**의도**: 복잡한 서브시스템에 **단순한 진입점** 제공.
**예**: 미디어 처리 파이프라인을 `MediaFacade.Process()`로 감싼다.

**장점**: 클라이언트 단순화, 결합도 감소.
**주의**: 과도한 퍼사드=신규 God Object 주의.

---

### 4.11 플라이웨이트(Flyweight)

**의도**: **공유 가능한 내재 상태**를 캐싱해 메모리 절감.
**예**: 문자 글리프/아이콘 풀.

**Python**
```python
class IconFactory:
    _pool={}
    @classmethod
    def get(cls, name):
        if name not in cls._pool: cls._pool[name]=load_icon(name)
        return cls._pool[name]
```

**주의**: 외재 상태(좌표·색상 등) 분리 필요.

---

### 4.12 프록시(Proxy)

**의도**: 대리 객체로 접근 제어/지연로딩/원격 호출.
**예**: Virtual Proxy(썸네일), Protection Proxy(권한), Remote Proxy(RPC).

**C#**
```csharp
class LazyImage : IImage {
    private RealImage _real;
    public void Draw(){
        _real ??= new RealImage("a.png");
        _real.Draw();
    }
}
```

---

### 4.13 전략(Strategy)

**의도**: 알고리즘군을 **교체 가능**하게 캡슐화.
**예**: 정렬/압축/가격정책 교체.

**C#**
```csharp
interface ICompression { byte[] Compress(byte[] src); }
class ZipCompression : ICompression { /* ... */ }
class GzipCompression : ICompression { /* ... */ }

class Archiver { private ICompression _algo; public Archiver(ICompression a){_algo=a;} public void Set(ICompression a)=>_algo=a; public byte[] Run(byte[] s)=>_algo.Compress(s); }
```

**검증**: 런타임 교체 테스트, 동일 계약 준수.
**리팩토링**: 거대한 switch-case(알고리즘 분기) → 전략 분리.

---

### 4.14 옵저버(Observer)

**의도**: 한 객체 상태 변화 → 다수 **구독자**에 통지(느슨한 결합).
**예**: 이벤트 버스, GUI 이벤트.

**C# (event)**
```csharp
class Publisher {
    public event Action<int> Changed;
    public void Set(int v){ /* ... */ Changed?.Invoke(v); }
}
class Subscriber {
    public void OnChanged(int v){ /* ... */ }
}
```

**검증**: 구독/해지, 메모리 누수(핸들러 유지) 점검.

---

### 4.15 커맨드(Command)

**의도**: 요청을 **객체**로 캡슐화(큐잉/로그/UNDO).
**예**: 에디터 편집 명령, 작업 대기열.

**Python**
```python
class Command:
    def execute(self): ...
    def undo(self): ...
class Insert(Command):
    def __init__(self, buf, text): self.buf=buf; self.text=text
    def execute(self): self.buf.append(self.text)
    def undo(self): self.buf.pop()

hist=[]; cmd=Insert(buf:=[], "A"); cmd.execute(); hist.append(cmd)
# undo
hist.pop().undo()
```

**검증**: 무해(idempotent)·undo 가능 여부.

---

### 4.16 책임 연쇄(Chain of Responsibility)

**의도**: 요청을 **연결된 처리자**들에 전달해 적합한 곳에서 처리.
**예**: 로거 레벨 체인, HTTP 미들웨어.

**C#**
```csharp
abstract class Handler {
    protected Handler Next;
    public Handler SetNext(Handler n){Next=n; return n;}
    public virtual void Handle(Request r){ Next?.Handle(r); }
}
```

**주의**: 디버깅 난이도, 누락 시 무처리.

---

### 4.17 상태(State)

**의도**: 객체의 **내부 상태**에 따라 행위를 바꾼다(분기 제거).
**예**: TCP 연결, 주문 라이프사이클.

**Python**
```python
class State:
    def pay(self, order): raise NotImplementedError
class New(State):
    def pay(self,o): o.state=Paid()
class Paid(State):
    def pay(self,o): raise Exception("already")
class Order:
    def __init__(self): self.state=New()
    def pay(self): self.state.pay(self)
```

---

### 4.18 템플릿 메서드(Template Method)

**의도**: 알고리즘의 **골격**을 정의하고, 일부 단계를 서브클래스에 위임.
**예**: 데이터 파이프라인 공통 흐름.

**C#**
```csharp
abstract class Pipeline {
    public void Run(){ Load(); Transform(); Save(); }
    protected abstract void Load(); protected abstract void Transform(); protected abstract void Save();
}
```

**주의**: 상속 과다 → 합성/전략 고려.

---

### 4.19 이터레이터(Iterator)

**의도**: 내부 표현을 노출하지 않고 **순회** 제공.
언어 내장(파이썬 `__iter__`, C# `IEnumerable`) 선호.

**Python**
```python
class Range:
    def __init__(self,n): self.n=n
    def __iter__(self):
        for i in range(self.n): yield i
```

---

### 4.20 미디에이터(Mediator)

**의도**: 객체 상호작용을 **중재자**가 조정(상호참조 제거).
**예**: 채팅 룸, 폼 위젯 상호작용.

**Python**
```python
class Bus:
    def __init__(self): self._subs={}
    def on(self, evt, fn): self._subs.setdefault(evt,[]).append(fn)
    def emit(self, evt, *a): [fn(*a) for fn in self._subs.get(evt,[])]
```

---

### 4.21 메멘토(Memento)

**의도**: 캡슐화 깨지 않고 **스냅샷/복원**.
**예**: Undo 히스토리.

**주의**: 스냅샷 용량/빈도 관리.

---

### 4.22 인터프리터(Interpreter)

**의도**: 간단한 언어의 문법을 **해석기**로 표현.
**예**: 규칙 엔진, 검색 필터.

**Python (아주 단순)**
```python
def eval_expr(expr):
    # "1+2*3" -> 7 (실전은 파서 필요)
    return eval(expr)  # 실제 서비스에서는 안전하지 않음
```

**주의**: 복잡해지면 파서/컴파일러 도메인.

---

### 4.23 비지터(Visitor)

**의도**: 구조는 고정, **새 연산**을 쉽게 추가.
**예**: AST에 대한 다양한 패스(검증/코드생성/포맷팅).

**주의**: 새 노드 타입 추가는 어려움(더블 디스패치).

---

## 5. 동시성/리액티브 패턴(실무 보강)

### 5.1 스레드 풀(Thread Pool) / 작업 큐
- **의도**: 스레드 생성/파괴 오버헤드 감소, 큐 기반 작업 처리.
- **C#**: `Task.Run`, `IHostedService`(백그라운드 워커), 채널(Channel)로 생산자-소비자.

```csharp
var ch = System.Threading.Channels.Channel.CreateUnbounded<Func<Task>>();
_ = Task.Run(async () => { while (await ch.Reader.WaitToReadAsync()) { while (ch.Reader.TryRead(out var job)) await job(); }});
await ch.Writer.WriteAsync(() => DoWorkAsync());
```

### 5.2 Futures/Promises
- **의도**: 비동기 결과를 **미래 값**으로 다루기.
- **C#**: `Task<T>` / **Python**: `asyncio.Future`.

### 5.3 리액터(Reactor) / 이벤트 루프
- **의도**: I/O 멀티플렉싱(논블로킹 I/O + 콜백/프로미스).
- **Python**: `asyncio` 루프, **C#**: `async/await` + `Sockets`(EPoll/KQueue는 런타임 추상화).

### 5.4 액티브 오브젝트(Active Object)
- **의도**: 메서드 호출을 **큐잉→비동기 실행**으로 분리(스레드 격리).
- 배우자: 커맨드·미디에이터.

### 5.5 가드 서스펜션/볼킹(Balking)
- **의도**: 조건 불충족 시 **즉시 중단**하거나 대기.

**테스트 포인트**: 스레드 안정성, 경합, 데드락 회피, 취소 토큰, 백프레셔.

---

## 6. 선택 가이드(결정 트리)

- **생성 복잡/다양?** → 빌더(구성 단계), 추상 팩토리(제품군), 팩토리 메서드(형식별)
- **인터페이스 불일치?** → 어댑터
- **기능을 런타임 조합?** → 데코레이터
- **서브시스템 단순화?** → 퍼사드
- **메모리 많다? 동일 객체 반복?** → 플라이웨이트
- **원격/지연/권한?** → 프록시
- **알고리즘 교체?** → 전략
- **상태에 따른 행위 변화?** → 상태
- **이벤트 알림?** → 옵저버
- **요청 캡슐화/Undo/큐?** → 커맨드
- **분기 체인?** → 책임 연쇄
- **공통 골격+훅?** → 템플릿 메서드
- **트리 구조?** → 컴포지트
- **새 연산을 자주 추가?** → 비지터

---

## 7. 리팩토링 레시피(현 코드 → 패턴)

- **거대한 switch/if로 알고리즘 분기** → **전략** 도입, DI로 주입
- **생성자 인자 10개** → **빌더** + 합리적 기본값
- **레거시 타입 호환 이슈** → **어댑터**
- **영속/원격 접근/지연로딩** → **프록시**
- **측면 기능(로깅/캐시/권한)** → **데코레이터**
- **복잡한 서브시스템 초기화 코드가 곳곳에** → **퍼사드**
- **상태 분기 폭발** → **상태**
- **동일 서브트리 연산** → **컴포지트/비지터**
- **명령 실행/취소 기록** → **커맨드 + 메멘토**

---

## 8. 테스트 전략(패턴 친화적 TDD)

- **전략/상태/커맨드**: 인터페이스 계약 테스트(동일 입력→기대 출력)
- **데코레이터**: **기저 동작 유지** + 부가효과 검증(스파이/프록시 객체)
- **옵저버**: 구독/해지, 메모리 누수(약한 참조), 멀티캐스트 순서
- **팩토리 계열**: **구상 타입 교체** 시 테스트 영향 최소화(의존성 역전)
- **프록시/어댑터**: 실패 케이스/예외 매핑 테스트
- **동시성**: 레이스·데드락 재현(스트레스 테스트), 타임아웃/취소 토큰

---

## 9. 언어별 구현 메모

- **Python**: 덕 타이핑이 강해 과한 인터페이스 계층은 불필요. **프로토콜/ABC**로 최소 계약만.
  싱글턴은 모듈 전역/팩토리 함수가 더 간단한 경우 많다.
- **C#/.NET**: `interface` + **DI 컨테이너**(Microsoft.Extensions.DependencyInjection)로 전략/팩토리 교체 용이. `Lazy<T>`로 게으른 초기화·스레드 안전 확보.
- **C++**: 비용·수명 관리가 중요. 스마트 포인터(`unique_ptr`, `shared_ptr`)와 **pImpl**로 의존성/빌드 타임 감소. 가상 호출 비용 vs CRTP/템플릿 전략 패턴 고려.

---

## 10. 안티패턴(경계석)

- **싱글턴 남용**: 전역 상태 → 테스트 지옥.
- **추상화 과다**: “패턴을 위한 패턴”. KISS 원칙 위배.
- **데코레이터 폭발**: 조합 순서·개수로 복잡도 급상승(구성 관리 필요).
- **옵저버 누수**: 해지/약한 참조 미흡으로 메모리 유지.
- **프록시로 모든 문제 해결**: 레이어링 과다 → 지연/디버깅 비용↑.

---

## 11. 실전 시나리오 3개(설계→코드)

### 11.1 웹 API 클라이언트 SDK
- **문제**: 다수 엔드포인트, 인증/재시도/로깅/캐시 조합 필요.
- **설계**: 퍼사드(`ApiClient`) + 데코레이터(로깅/캐시/리트라이) + 전략(서명 알고리즘).
- **C# 스니펫**
```csharp
IService core = new HttpService(http);
IService svc = new Caching(new Retry(new Logging(core)));
```

### 11.2 플러그인 아키텍처
- **문제**: 런타임 알고리즘 추가/교체.
- **설계**: 전략 + 팩토리 메서드(반사/DI로 로드) + 미디에이터(이벤트 라우팅).

### 11.3 에디터 Undo/Redo
- **문제**: 명령 기록/복원/스냅샷.
- **설계**: 커맨드(실행/취소) + 메멘토(상태 스냅샷) + 책임 연쇄(유효성 필터).

---

## 12. 예제 모음(간단·자급자족 실행)

### 12.1 싱글턴 vs DI(비교)
```python
# singleton_config.py
class Config: ...
CFG = Config()  # 모듈 단일 인스턴스

# di_config.py
class Service:
    def __init__(self, cfg): self.cfg = cfg
```

### 12.2 데코레이터 체인(파이썬)
```python
class Svc:
    def get(self): return "data"
class Log(Svc):
    def __init__(self, nxt): self.nxt=nxt
    def get(self): print("log"); return self.nxt.get()
class Cache(Svc):
    def __init__(self, nxt): self.nxt=nxt; self.v=None
    def get(self):
        if self.v is None: self.v = self.nxt.get()
        return self.v
svc = Cache(Log(Svc()))
print(svc.get()); print(svc.get())
```

### 12.3 전략 교체(C#)
```csharp
services.AddSingleton<ICompression, ZipCompression>();
// 이후 구성 변경 시 GzipCompression으로 한 줄 교체
```

---

## 13. 체크리스트(적용 전 자문)

- 문제는 **복잡한가? 재사용 가능한가?**
- 단순한 함수/구성으로 충분한가(**YAGNI**)?
- 계약(인터페이스)와 수명/의존성 그래프가 명확한가?
- 테스트 용이성은 ↑, 결합도는 ↓ ?
- 성능/메모리/동시성 제약에서 안전한가?

---

## 14. 결론

디자인 패턴은 “코드 기교”가 아니라 **협력 구조의 어휘**다.
패턴은 **문제의 본질**을 정확히 파악했을 때만 가치가 있다. 요구사항과 제약을 정밀히 분석하고, 가장 **간결한 구조**로 해결하라. 필요할 때 **정확한 패턴을 최소한으로** 끼워 넣는 것이 가장 실용적이다.

---

## 부록 A. 간단 UML 텍스트 표기 팁

- `A --> B` : 의존/사용, `A -|> B` : 상속/구현, `A o-- B` : 집합(집약)
- 시퀀스: `Client -> Facade : Do()` / `Facade -> Sub1 : op()` …

---

## 부록 B. 스레드 안전 싱글턴 체크리스트(C#)

- 정적 초기화 또는 `Lazy<T>` 사용
- 이중 검사 잠금(Double-checked locking)은 C#에선 필요 드묾(정적 초기화가 안전)
- 파괴/리스타트 시 수명 관리(호스팅 라이프사이클) 주의

---

## 부록 C. 자주 묻는 질문(FAQ)

- **Q. 항상 패턴을 써야 하나?**
  A. 아니다. **패턴 없는 코드가 더 명확**하면 쓰지 않는다.

- **Q. 여러 패턴을 섞어도 되나?**
  A. 된다. 단, **역할 경계**를 명확히 하고 테스트로 검증하라.

- **Q. 함수형/리액티브에서도 유효한가?**
  A. 많은 개념이 그대로 적용(전략=함수 값, 옵저버=스트림, 커맨드=이벤트/메시지).

---

## 간단한 시작 예시: 제공한 코어 내용을 반영한 싱글턴

```python
class Singleton:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

a = Singleton(); b = Singleton()
print(a is b)  # True
```

이 예시는 **“하나만 만들고 싶다”**는 요구에 대한 가장 단순한 구현이다.
실전에서는 **테스트 용이성/전역 상태 최소화**를 위해 가능하면 **DI로 대체**하고, 꼭 필요할 때만 싱글턴을 채택하라.
