---
layout: post
title: 운영체제 - 컴퓨터 시스템의 기초 (2)
date: 2025-10-12 23:25:23 +0900
category: 운영체제
---
# 운영체제의 동작과 자원 관리 (Operations & Resource Management)

운영체제(OS)는 **모드 전환(유저/커널)**, **타이머/인터럽트**, **멀티프로그램·멀티태스킹**, 그리고 **자원(프로세스·메모리·파일·대용량 저장장치·캐시·I/O)**를 관리하며 전체 시스템을 **안전·효율·예측 가능**하게 만든다. 이 장에서는 각 항목을 **실행 가능한 예제와 실험 시나리오**로 상세하게 설명한다.

---

## Operating-System Operations

운영체제의 “동작”은 크게 다음 축으로 이해할 수 있다.

- **CPU 시분할과 동시성**: 다수의 작업을 교대로 실행(멀티프로그램·멀티태스킹)
- **모드 전환**: 사용자 모드 ↔ 커널 모드(시스템콜/예외/인터럽트)
- **타이머**: 선점 스케줄링과 무한 루프 방지, 시간 자원 배분

### Multiprogramming and Multitasking

- **Multiprogramming**: 메모리에 여러 프로그램을 적재하여 CPU 유휴시간을 줄이는 기법(초기 배치 시스템에서 I/O 대기 동안 다른 작업을 실행).
- **Multitasking(Time-sharing)**: 사용자/프로세스 간 CPU를 **타임 슬라이스**로 빠르게 전환하여 동시에 실행되는 것처럼 보이게 함(선점 스케줄링).

#### [실습] CPU 바운드 vs I/O 바운드의 스케줄링 체감

```bash
# 터미널 A - CPU 바운드 작업(파이 연산 흉내)

python3 - <<'PY'
import math
s=0.0
for k in range(1, 200_000_000):
    s += 1.0/(k*k)
print(s)
PY
```

```bash
# 터미널 B - I/O 바운드 작업(여러 파일 순차 읽기)

python3 - <<'PY'
import os, time
p = "/var/tmp/io_demo"
os.makedirs(p, exist_ok=True)
# 100MB 더미 파일 3개

for i in range(3):
    f = os.path.join(p, f"f{i}")
    if not os.path.exists(f):
        with open(f,"wb") as w: w.write(os.urandom(100*1024*1024))
# 차례대로 읽기

for i in range(3):
    with open(os.path.join(p,f"f{i}"),"rb") as r:
        while r.read(1024*1024):
            pass
    print("done", i); time.sleep(0.3)
PY
```

관찰 포인트:

- `top`/`vmstat 1`으로 보면 CPU 바운드는 **us% 상승**, I/O 바운드는 **iowait 증가** 경향.
- 선점형 커널에서 두 작업이 **타임 슬라이스** 단위로 번갈아 실행되어 전체 인터랙티브 응답성을 유지.

#### [실습] 간단한 “멀티태스킹” 맛보기(리눅스 cgroups + nice)

```bash
# 같은 CPU에서 경쟁시키되 우선순위/limit을 달리해 효과 비교

yes > /dev/null & echo $! > /tmp/p1.pid
yes > /dev/null & echo $! > /tmp/p2.pid

# 프로세스 하나를 낮은 우선순위로

sudo renice +10 -p $(cat /tmp/p2.pid)

# 혹은 cgroups로 CPU share 제한(환경에 맞게 조정)

sudo cgcreate -g cpu:/grp1
echo 256 | sudo tee /sys/fs/cgroup/cpu/grp1/cpu.shares
sudo cgclassify -g cpu:grp1 $(cat /tmp/p2.pid)

top -H -p $(cat /tmp/p1.pid),$(cat /tmp/p2.pid)
```

---

### Dual-Mode and Multimode Operation

현대 OS는 최소 **두 가지 모드**를 가진다.

- **사용자 모드(User Mode)**: 제한된 권한. 일반 앱이 실행.
- **커널 모드(Kernel Mode)**: 특권 명령 가능. I/O, 메모리 관리, 스케줄러 등 핵심 기능 수행.

**모드 전환 경로**:
1) 사용자 → 커널: **시스템콜**(소프트웨어 트랩), **예외**(페이지 폴트 등), **인터럽트**
2) 커널 → 사용자: **시스템콜 리턴**, 스케줄러에 의한 **컨텍스트 스위치 후 복귀**

**Multimode**는 하이퍼바이저 모드, 보안 확장(ARM EL0/EL1/EL2/EL3, Intel VT-x 등)까지 포함.

#### [실습] 시스템콜 트레이스(strace)로 모드 전환 관찰

```bash
cat > syscalls.c <<'C'
#include <unistd.h>
#include <sys/syscall.h>
#include <stdio.h>

int main() {
    write(1,"hello\n",6);        // write -> 커널 모드 진입
    getpid();                    // getpid -> 커널 모드 진입
    return 0;
}
C
gcc -O2 syscalls.c -o syscalls && strace -o trace.txt ./syscalls
sed -n '1,20p' trace.txt
```

- `write`, `getpid` 호출 시 **유저→커널 모드**로 전환되는 흔적(시스템콜)이 출력됨.

---

### Timer

**타이머**는 선점형 스케줄링의 핵심이다. 주기적으로 **타이머 인터럽트**가 발생하여 커널이 실행 중인 스레드를 **선점(preempt)**하고 **스케줄러**를 호출, 다음 실행 대상을 선택한다. 또한 **타임아웃/슬립/지연 실행** 등의 시간 기반 기능을 지원한다.

#### [실습] 사용자 공간 타이머(시그널/`setitimer`)

{% raw %}
```c
// timer_tick.c : 10ms 간격으로 타이머 틱을 발생시켜 작업을 슬라이스로 나눠 실행
#define _GNU_SOURCE
#include <signal.h>
#include <sys/time.h>
#include <stdio.h>
#include <unistd.h>

volatile sig_atomic_t tick=0;
void h(int s){ tick=1; }
int main(){
    struct sigaction sa={0}; sa.sa_handler=h; sigaction(SIGALRM,&sa,NULL);
    struct itimerval it={{0,10000},{0,10000}}; // 10ms
    setitimer(ITIMER_REAL,&it,NULL);
    unsigned long work=0;
    while(work<2000000){
        if(tick){ tick=0; /* 타임슬라이스 경계 */ }
        // 바쁜 일 흉내(짧게)
        for(int i=0;i<1000;i++) work++;
    }
    printf("done work=%lu\n",work);
}
```
{% endraw %}

```bash
gcc -O2 timer_tick.c -o timer_tick && ./timer_tick
```

포인트:

- 실제 커널은 **타이머 인터럽트**를 이용해 선점한다.
- 사용자 공간에서도 시그널 기반 타이밍으로 **슬라이스 개념**을 체험할 수 있다.

---

## Resource Management

운영체제는 **자원(Resource)**을 추상화·모델링하고, **할당/회수**하며, **격리/보호**하고, **관측/조정**한다. 핵심 영역:

- **프로세스 관리**
- **메모리 관리**
- **파일시스템 관리**
- **대용량 저장장치 관리(블록 I/O)**
- **캐시 관리**
- **I/O 시스템 관리(장치/드라이버/네트워킹 포함)**

### 성능 직관(큐잉 모델)

- 평균 도착률을 $$\lambda$$, 평균 서비스율을 $$\mu$$라 하면 이용률 $$\rho = \lambda/\mu$$.
- 대기시간은 대체로 $$\rho \to 1$$에 가까워질수록 급증:
  $$
  W \propto \frac{1}{1-\rho}
  $$
- OS는 **스케줄링·스로틀링·캐싱**으로 $$\rho$$와 **변동성(지터)**을 관리해 **지연폭주**를 피한다.

---

### Process Management

**프로세스**는 실행 중인 프로그램의 인스턴스다. OS는 다음을 책임진다.

- **생성·종료**: `fork/exec/exit`, `CreateProcess/ExitProcess`
- **스케줄링**: 우선순위, 타임 슬라이스, 클래스(CFS, RT 등)
- **동기화·통신**: 파이프/소켓/공유메모리/시그널/메시지큐
- **격리/보안**: 권한, 네임스페이스, cgroups

#### [실습] `fork + exec` 파이프라인

```c
// fork_exec_pipe.c : 부모가 파이프를 만들고 자식 두 개를 연결 (ls | wc -l)
#define _GNU_SOURCE
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>

int main(){
    int fds[2]; pipe(fds);
    pid_t c1=fork();
    if(c1==0){ // child1: writer (ls)
        dup2(fds[1],1); close(fds[0]); close(fds[1]);
        execlp("ls","ls",(char*)NULL);
        _exit(127);
    }
    pid_t c2=fork();
    if(c2==0){ // child2: reader (wc -l)
        dup2(fds[0],0); close(fds[1]); close(fds[0]);
        execlp("wc","wc","-l",(char*)NULL);
        _exit(127);
    }
    close(fds[0]); close(fds[1]);
    waitpid(c1,NULL,0); waitpid(c2,NULL,0);
}
```

```bash
gcc -O2 fork_exec_pipe.c -o fork_exec_pipe && ./fork_exec_pipe
```

#### [실습] 좀비/고아 프로세스 관찰(정리의 중요성)

```bash
# 자식이 종료해도 부모가 wait하지 않으면 'Zombie' (STAT=Z) 남을 수 있음
# 테스트 스니펫(주의: 시스템에 잔류하지 않게 금방 종료되게 설계)

python3 - <<'PY'
import os, time
pid = os.fork()
if pid==0:
    # child
    os._exit(0)
else:
    # parent intentionally sleeps without wait
    time.sleep(2)
    os.waitpid(pid, 0)      # 정리
PY
```

---

### Memory Management

**가상 메모리**(Virtual Memory)는 **프로세스별 주소 공간**을 제공해 **격리/보호**와 **큰 연속 공간의 추상화**를 구현한다.

- **페이지/프레임**: 보통 4KB 페이지(대페이지도 존재)
- **TLB**: 주소 변환 캐시
- **페이지 폴트**: 없는 페이지 접근 → 디스크에서 적재 또는 예외
- **메모리 매핑**: `mmap`으로 파일/익명 메모리 매핑
- **할당기**: 커널 슬랩/슬랩슬랩, 사용자 `malloc`(brk/mmap)

#### [실습] `mmap` 익명 메모리 & 터치 패턴에 따른 페이지 폴트

```c
// vm_touch.c : 큰 익명 메모리를 할당하고 접근 패턴에 따른 비용 관찰
#define _GNU_SOURCE
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

int main(int argc, char**argv){
    size_t MB = (argc>1? (size_t)atol(argv[1]):256);
    size_t N = MB*1024*1024;
    char* p = mmap(NULL, N, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if(p==MAP_FAILED){perror("mmap");return 1;}
    struct timespec t0,t1; clock_gettime(CLOCK_MONOTONIC,&t0);
    // 순차 터치
    for(size_t i=0;i<N;i+=4096) p[i]=1;
    clock_gettime(CLOCK_MONOTONIC,&t1);
    double seq=(t1.tv_sec-t0.tv_sec)+(t1.tv_nsec-t0.tv_nsec)/1e9;
    // 랜덤 터치(간단 흉내: 큰 stride)
    clock_gettime(CLOCK_MONOTONIC,&t0);
    for(size_t i=0;i<N;i+=4096*32) p[i]=2;
    clock_gettime(CLOCK_MONOTONIC,&t1);
    double rnd=(t1.tv_sec-t0.tv_sec)+(t1.tv_nsec-t0.tv_nsec)/1e9;
    printf("MB=%zu seq=%.3fs rand=%.3fs\n",MB,seq,rnd);
    munmap(p,N);
}
```

```bash
gcc -O2 vm_touch.c -o vm_touch && ./vm_touch 512
```

- 순차 접근은 **프리페치/지역성** 덕분에 유리.
- 랜덤 접근은 TLB/캐시 미스 및 페이지 폴트 비용 증가 가능.

#### [실습] 메모리 매핑 파일과 공유

```c
// mmap_file_share.c : 부모-자식이 같은 파일을 MAP_SHARED로 쓰면 커널 페이지 캐시를 통해 공유
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(){
    int fd=open("/var/tmp/mmap_demo.bin",O_RDWR|O_CREAT,0644);
    ftruncate(fd,4096);
    char* p=mmap(NULL,4096,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
    if(p==MAP_FAILED){perror("mmap");return 1;}
    pid_t c=fork();
    if(c==0){
        strcpy(p,"child says hi");
        msync(p,4096,MS_SYNC);
        _exit(0);
    } else {
        sleep(1);
        printf("parent sees: %s\n", p);
    }
    munmap(p,4096); close(fd);
}
```

```bash
gcc -O2 mmap_file_share.c -o mmap_file_share && ./mmap_file_share
```

---

### File-System Management

**파일시스템(FS)**는 파일/디렉터리를 **이름공간**, **보안(권한)**, **영속성**, **일관성**으로 관리한다.

- **VFS** 추상화: 다양한 실제 FS(ext4, xfs, btrfs 등)를 공통 인터페이스로
- **메타데이터**: inode, 디렉터리 엔트리, 권한/소유/타임스탬프
- **저널링**: 정전/크래시 후 일관성 회복
- **동기/비동기 쓰기**: `fsync`, `O_DIRECT`, 쓰기 캐시

#### [실습] 링크/퍼미션/저널링 관찰

```bash
# 하드링크와 심볼릭 링크

echo "data" > a.txt
ln a.txt a.hard          # 같은 inode
ln -s a.txt a.sym        # 경로 별칭
ls -li a.*

# 권한 관리

chmod 600 a.txt
ls -l a.txt

# fsync로 강제 영속화(작은 벤치)

python3 - <<'PY'
import os
f=os.open("fsync_demo.bin", os.O_WRONLY|os.O_CREAT)
os.write(f,b"x"*1024*1024)
os.fsync(f); os.close(f)
PY
```

#### [실습] 디렉터리 엔트리/메타데이터 캐시 효과

```bash
# 많은 작은 파일 생성 후 ls 성능 비교(캐시 드랍은 관리자 주의)

mkdir -p /var/tmp/dir_demo && cd /var/tmp/dir_demo
for i in $(seq 1 5000); do echo hi > f$i; done
/usr/bin/time -f "ls1 %E" ls > /dev/null
sudo sh -c "echo 3 > /proc/sys/vm/drop_caches"
/usr/bin/time -f "ls2 %E" ls > /dev/null
```

---

### Mass-Storage Management

**대용량 저장장치**(HDD/SSD/NVMe)는 **블록 장치**로 노출된다. OS는 다음을 수행:

- **스케줄링**: 요청 병합/정렬, 다중 큐(NVMe), 우선순위
- **파티션/파일시스템**: mkfs, mount, quota
- **수명/내구성 고려**: SSD TRIM, GC, wear-leveling(장치 내부)
- **I/O 경로 최적화**: DMA, `O_DIRECT`, 큐뎁스, 배치

#### [실습] `fio`로 읽기/쓰기 패턴 성능 비교

```bash
# 무작위/순차 성능 측정 예 (환경에 설치 필요: sudo apt-get install fio)

cat > job.fio <<'F'
[global]
ioengine=libaio
direct=1
time_based
runtime=10
iodepth=32
size=1g
filename=/var/tmp/fio.bin

[randread]
rw=randread
bs=4k

[seqread]
rw=read
bs=128k
F
fio job.fio
```

- **순차 큰 블록**이 일반적으로 높은 처리량.
- **무작위 작은 블록**은 IOPS에 민감하며 레이턴시 증가.

#### [실습] TRIM(SSD) 효과(파일 삭제 후 공간 회수 힌트)

```bash
# fstrim (마운트 포인트에 대해 디스크에 free 블록 힌트)

sudo fstrim -v /
```

---

### Cache Management

OS는 다양한 **캐시 계층**을 운용한다.

- **페이지 캐시(Page Cache)**: 파일 데이터 캐시
- **버퍼 캐시(Buffer Cache)**: 메타데이터/블록 레벨
- **디렉터리엔트리(dentry)/inode 캐시**: 경로 해석 가속
- **네트워크 스택 캐시**: 라우팅, ARP/ND, 연결 추적
- **DNS/네임서비스 캐시**: 시스템/라이브러리 레벨

목표: **참조 지역성**을 활용해 **I/O 레이턴시↓ 처리량↑**. 단, **일관성/영속성** 균형이 중요.

#### [실습] 페이지 캐시 재사용 관찰

```bash
dd if=/dev/urandom of=/var/tmp/big2.bin bs=1M count=256 status=progress
/usr/bin/time -f "1st %E %MKB" cat /var/tmp/big2.bin > /dev/null
/usr/bin/time -f "2nd %E %MKB" cat /var/tmp/big2.bin > /dev/null
sudo sh -c "echo 3 > /proc/sys/vm/drop_caches"
/usr/bin/time -f "after-drop %E %MKB" cat /var/tmp/big2.bin > /dev/null
```

- 두 번째 읽기가 **현저히 빠르다면** 페이지 캐시 효과.
- 캐시 드랍 후 다시 느려지면 **디스크 I/O** 수행 증거.

#### [실습] `mmap` vs `read`의 캐시적 관점

```bash
# read() 루프 vs mmap() 접근으로 동일 파일을 스캔하는 시간 비교
# (앞 절의 mmap_read.c 참조) 빌드 후 같은 파일에 대해 각각 측정

```

---

### I/O System Management

I/O 시스템은 **장치 드라이버**, **커널 I/O 서브시스템**, **이벤트/중단 처리**, **전달 큐(softirq/workqueue)**로 구성된다.

- **블록/문자 장치**: 디스크(NVMe/SATA), 터미널/시리얼, 랜카드 등
- **동기 vs 비동기**: `read/write` vs `aio/io_uring`
- **대기 모델**: 블로킹, non-blocking, **I/O 다중화**(`select/poll/epoll/kqueue`)
- **네트워크**: NIC → NAPI/인터럽트 완화 → 소켓 버퍼 → TCP/IP → `send/recv`

#### [실습] epoll 기반 다중 I/O 에코 서버(리눅스)

```c
// epoll_echo.c : 단일 스레드로 다수 클라이언트를 처리하는 간단한 에코 서버
#define _GNU_SOURCE
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

static int make_nonblock(int fd){
    int fl=fcntl(fd,F_GETFL,0);
    return fcntl(fd,F_SETFL, fl|O_NONBLOCK);
}

int main(){
    int s=socket(AF_INET,SOCK_STREAM,0);
    int yes=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(yes));
    struct sockaddr_in a={.sin_family=AF_INET,.sin_port=htons(9090),.sin_addr={htonl(INADDR_ANY)}};
    bind(s,(struct sockaddr*)&a,sizeof(a));
    listen(s,128);
    make_nonblock(s);

    int ep=epoll_create1(0);
    struct epoll_event ev={.events=EPOLLIN,.data.fd=s};
    epoll_ctl(ep,EPOLL_CTL_ADD,s,&ev);

    char buf[4096];
    struct epoll_event evs[128];

    while(1){
        int n=epoll_wait(ep,evs,128,-1);
        for(int i=0;i<n;i++){
            int fd=evs[i].data.fd;
            if(fd==s){
                // accept loop
                while(1){
                    int c=accept(s,NULL,NULL);
                    if(c<0){ if(errno==EAGAIN||errno==EWOULDBLOCK) break; else perror("accept"); }
                    make_nonblock(c);
                    struct epoll_event cev={.events=EPOLLIN|EPOLLET,.data.fd=c};
                    epoll_ctl(ep,EPOLL_CTL_ADD,c,&cev);
                }
            }else{
                // read-echo
                while(1){
                    ssize_t r=read(fd,buf,sizeof(buf));
                    if(r>0){
                        ssize_t w=write(fd,buf,r);
                        (void)w;
                    }else if(r==0){
                        close(fd); break;
                    }else{
                        if(errno==EAGAIN||errno==EWOULDBLOCK) break;
                        close(fd); break;
                    }
                }
            }
        }
    }
}
```

```bash
gcc -O2 epoll_echo.c -o epoll_echo && ./epoll_echo
# 다른 터미널에서:

nc 127.0.0.1 9090
# 여러 클라이언트를 동시에 붙여서 echo 동작이 비동기적으로 처리되는지 확인

```

#### [실습] `io_uring` 맛보기(개념 스니펫)

> 환경 의존성이 있어 여기서는 개념만: **서밋 큐(SQ)**와 **컴플리션 큐(CQ)**를 공유 메모리로 두고 **시스템콜 수를 줄여** 고성능 비동기 I/O를 달성.
> 실제 코드는 `liburing` 예제를 참고(설치 필요). `epoll` 대비 **컨텍스트 스위치·커널 경로 단축** 이점.

---

## 종합 실전 시나리오: “가벼운 정적 파일 서버”의 전 스택 관찰

**목표**: OS 자원 관리의 상호작용을 한 번에 확인한다.

```bash
# 파이썬 스레드형 정적 서버

python3 - <<'PY'
from http.server import SimpleHTTPRequestHandler, ThreadingHTTPServer
import os, threading
os.chdir("/var/tmp")  # 정적 파일 루트
print("serving at :8081, pid=",os.getpid())
ThreadingHTTPServer(("0.0.0.0",8081), SimpleHTTPRequestHandler).serve_forever()
PY
```

```bash
# 부하: 동시 64개의 클라이언트가 10초 동안 요청 (wrk 필요)
# 설치: sudo apt-get install wrk (또는 소스 빌드)

wrk -t8 -c64 -d10s http://127.0.0.1:8081/big2.bin
```

**관찰 체크리스트**:

- **프로세스/스레드**: `top -H -p <pid>`로 쓰레드 수, CPU 사용
- **메모리**: `pmap <pid>`, `smaps`, 페이지 캐시 히트율(두 번째 요청이 빨라지는지)
- **파일시스템**: `iostat -xz 1` 로 디스크 큐/처리량, `vmstat 1`의 **iowait**
- **네트워크**: `sar -n TCP,DEV 1` 패킷/초, 재전송 여부
- **스케줄링**: `ps -eo pid,psr,pri,ni,stat,comm | grep python` 로 어떤 CPU에 스레드가 붙는지
- **타이머**: 커널 타이머 틱에 따라 문맥전환이 일어남(직접 관찰은 어렵지만 전체 지표 변화를 통해 추론)

---

## 마무리 요약

- **1.4**: OS는 **멀티프로그램/멀티태스킹**으로 CPU를 공유하고, **듀얼/멀티 모드**로 특권을 관리하며, **타이머**로 선점/시간기반 기능을 구현한다.
- **1.5**: OS는 **프로세스/메모리/파일/대용량 저장/캐시/I/O**를 **추상화·격리·스케줄링·관측**한다.
- 실습들을 통해 **캐시 적중**, **I/O 패턴별 처리량/지연**, **모드 전환(시스템콜)**, **스케줄러의 공정성** 등을 체감할 수 있다.
