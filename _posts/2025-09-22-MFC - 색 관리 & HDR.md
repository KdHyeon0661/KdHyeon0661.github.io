---
layout: post
title: MFC - 색 관리 & HDR
date: 2025-09-22 17:25:23 +0900
category: MFC
---
# 색 관리 & HDR 완전 가이드  
**ICC 프로파일 · sRGB/Display P3 · WIC 색 공간 · HDR 모니터 톤매핑/SDR 폴백 (Win32/MFC/Direct2D/Direct3D 11/12)**

> 목표: *“내가 로드한 이미지/그린 색을, 사용자의 모니터에서 의도한 색으로 보여주기”*  
> - **ICC/WCS**: 모니터·이미지의 색 특성을 읽고 변환  
> - **WIC**(Windows Imaging Component): 임베디드 프로파일/EXIF 메타로 **색 변환**  
> - **Direct2D/Effects**: **런타임 색 관리**(Color Management 이펙트)  
> - **HDR(Rec.2020+PQ/scRGB)**: **HDR10 출력**, **SDR 톤매핑 폴백** 전략

---

## 0) 큰 그림 (의사결정 트리)

1) **이미지/벡터/UI의 원 색 공간**은?  
   - sRGB? Display P3? AdobeRGB? 카메라 RAW?  
   - 파일에 **ICC 임베드**가 있나? (JPEG/TIFF/PNG의 iCCP 등)

2) **출력 대상 디스플레이**는?  
   - **SDR sRGB** 가정(모든 곳에서 안전)  
   - **광색역(예: P3)** sRGB보다 넓음  
   - **HDR** (HDR10: BT.2020 + PQ, 또는 **scRGB**: 선형 sRGB 확장)

3) **파이프라인**을 정한다  
   - 로드(WIC) → **색 컨텍스트(ICC)** 읽기 → **표준 작업공간**(주로 sRGB 또는 linear sRGB/scRGB)으로 **변환** → 렌더  
   - 출력 앞단에서 **디스플레이 프로파일**(최종 타깃)로 변환 (SDR)  
   - HDR이면 **DXGI Color Space**/HDR 메타데이터 설정 → 톤매핑/우선순위 결정

---

## 1) 기본 용어 & 좌표
- **ICC Profile**: 색 공간 정의(primaries/transfer curve + 매트릭스/LUT).  
- **sRGB**: 사실상 기본 SDR 표준(Rec.709 primaries + sRGB OETF).  
- **Display P3**: P3 primaries + sRGB 전송(일반적으로) → **P3-D65** (D65 백색점).  
- **BT.2020**: HDR에서 흔히 쓰는 광색역.  
- **PQ(ST 2084)**: HDR10의 전송 함수(감마 대신 **절대 휘도** 기반).  
- **HLG**: 방송 HDR 곡선, 이 문서에선 HDR10(PQ) 중심.  
- **scRGB**: **Linear sRGB** 의 확장(**Float16**), 1.0을 넘어 최대 ~7.5 정도로 밝기를 담음.  
- **WCS**: Windows Color System, ICC를 포괄/호환하는 Windows 색 관리 프레임워크.

---

## 2) 모니터(최종 타깃) ICC 프로파일 얻기

### 2.1 WCS/ICC 경로(권장)
```cpp
#include <icm.h>
#pragma comment(lib, "Mscms.lib")

std::wstring GetDefaultMonitorProfile(HWND hwnd) {
    HMONITOR hm = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
    MONITORINFOEXW mi{ sizeof(mi) };
    GetMonitorInfoW(hm, &mi);

    DWORD dwSize = 0;
    WCS_PROFILE_MANAGEMENT_SCOPE scope = WCS_PROFILE_MANAGEMENT_SCOPE_SYSTEM_WIDE; // 또는 CURRENT_USER
    // 디스플레이 프로파일(기본) 이름 길이 쿼리
    BOOL ok = WcsGetDefaultColorProfileSizeW(scope, NULL, CLASS_MONITOR, NULL,
        COLORSPACE_SIGNATURE_PROFILE_LINKED, 0, &dwSize);
    if (!ok || !dwSize) { // 대체 경로: GetICMProfileW
        HDC hdc = CreateDCW(mi.szDevice, mi.szDevice, NULL, NULL);
        DWORD len = 0; GetICMProfileW(hdc, &len, NULL);
        std::wstring p; p.resize(len);
        if (GetICMProfileW(hdc, &len, p.data())) {
            DeleteDC(hdc); p.resize(wcslen(p.c_str()));
            return p;
        }
        DeleteDC(hdc);
        return L"";
    }
    std::wstring path; path.resize(dwSize);
    ok = WcsGetDefaultColorProfileW(scope, NULL, CLASS_MONITOR, NULL,
        COLORSPACE_SIGNATURE_PROFILE_LINKED, 0, dwSize, path.data());
    if (!ok) return L"";
    path.resize(wcslen(path.c_str()));
    return path;
}
```
- **주의**: 다중 모니터/EDID에 따라 **각 모니터 프로파일**이 다를 수 있음. **렌더 대상**이 어느 모니터인지 기준을 잡는다.

---

## 3) WIC로 이미지 로드 + 임베디드 프로파일 → 변환

### 3.1 기본 로드
```cpp
#include <wincodec.h>
#pragma comment(lib, "windowscodecs.lib")

ComPtr<IWICImagingFactory> g_wic;

IWICBitmapSource* LoadWicSource(const wchar_t* path) {
    ComPtr<IWICBitmapDecoder> dec;
    g_wic->CreateDecoderFromFilename(path, nullptr, GENERIC_READ,
        WICDecodeMetadataCacheOnDemand, &dec);
    ComPtr<IWICBitmapFrameDecode> frame;
    dec->GetFrame(0, &frame);
    return frame.Detach();
}
```

### 3.2 색 컨텍스트(ICC) 가져오기
```cpp
ComPtr<IWICColorContext> GetEmbeddedColorContext(IWICBitmapFrameDecode* frame) {
    UINT count = 0;
    frame->GetColorContexts(0, nullptr, &count);
    if (!count) return nullptr;
    std::vector<ComPtr<IWICColorContext>> ctxs(count);
    frame->GetColorContexts(count, reinterpret_cast<IWICColorContext**>(ctxs.data()), &count);
    return ctxs[0]; // 보통 첫 번째가 임베디드 ICC
}
```

### 3.3 디스플레이(타깃) 컬러 컨텍스트 만들기
```cpp
ComPtr<IWICColorContext> CreateColorContextFromIcc(const std::wstring& iccPath) {
    ComPtr<IWICColorContext> cc;
    g_wic->CreateColorContext(&cc);
    cc->InitializeFromFilename(iccPath.c_str());
    return cc;
}

ComPtr<IWICColorContext> CreateSRgbContext() {
    ComPtr<IWICColorContext> cc;
    g_wic->CreateColorContext(&cc);
    cc->InitializeFromExifColorSpace(1); // 1 == sRGB
    return cc;
}

ComPtr<IWICColorContext> CreateDisplayP3Context() {
    // WIC은 Display P3에 대한 “표준 ICC” 파일을 필요로 함(직접 제공)
    // OS 내장 프로파일(예: "Display P3.icc")을 로드하거나, 앱에 번들.
    auto p3icc = L"C:\\Windows\\System32\\spool\\drivers\\color\\Display P3 D65.icc"; // 예시
    return CreateColorContextFromIcc(p3icc);
}
```

### 3.4 색 변환(IWICColorTransform)
```cpp
IWICBitmapSource* ConvertColor(
    IWICBitmapSource* src,
    IWICColorContext* srcCC,
    IWICColorContext* dstCC,
    REFGUID dstPixelFormat = GUID_WICPixelFormat32bppPBGRA) // D2D 친화
{
    ComPtr<IWICBitmapSource> convSrc = src; // ref

    // (1) 필요 시 픽셀 형식 변환(정밀도 등)
    if (/*src fmt != 32bppPBGRA*/) {
        ComPtr<IWICFormatConverter> f;
        g_wic->CreateFormatConverter(&f);
        f->Initialize(src, GUID_WICPixelFormat32bppPRGBA, WICBitmapDitherTypeNone, nullptr, 0.0, WICBitmapPaletteTypeCustom);
        convSrc = f;
    }

    // (2) 컬러 변환
    ComPtr<IWICColorTransform> xform;
    g_wic->CreateColorTransformer(&xform);
    xform->Initialize(convSrc.Get(), srcCC, dstCC, dstPixelFormat);
    return xform.Detach();
}
```

- **패턴**  
  - *로드* → **임베디드 ICC** 또는 “없으면 sRGB 가정”  
  - *작업 공간*을 **sRGB(또는 Linear sRGB/scRGB)** 로 정해 통일  
  - *화면 출력 직전*에 **모니터 ICC**로 변환(정밀) 혹은 **sRGB 출력을 신뢰**(대부분 SDR 환경은 sRGB 가정도 OK, 정확도 요구 시 모니터 ICC로)

---

## 4) Direct2D 색 관리 이펙트 (실시간 렌더)

D2D 1.1+에 **Color Management Effect**가 있다.  
- CLSID: `CLSID_D2D1ColorManagement`  
- 입력/출력 **색 공간 메타**를 지정하면, **GPU에서 색 변환**(LUT/Lab 매핑 등) 수행.

### 4.1 파이프라인(예)
```
IWICBitmapSource (sRGB/DisplayP3/AdobeRGB …)
   └─ D2D1Bitmap (source space tag) ─→ ColorManagementEffect ─→ D2D RenderTarget
                                               │
                                               └─ OutputColorProfile = sRGB/DisplayICC
```

### 4.2 사용 예
```cpp
ComPtr<ID2D1DeviceContext> dc;
ComPtr<ID2D1Effect> colorFx;

dc->CreateEffect(CLSID_D2D1ColorManagement, &colorFx);

// 1) 입력 프로파일: sRGB (또는 커스텀 ICC)
D2D1_COLOR_CONTEXT_PROPERTIES inProps{};
inProps.type = D2D1_COLOR_CONTEXT_TYPE_ICC; // or DXGI
// sRGB는 D2D1_COLOR_CONTEXT_TYPE_SRGB로 간단히 지정 가능
ComPtr<ID2D1ColorContext> inCtx;
dc->CreateColorContext(D2D1_COLOR_CONTEXT_TYPE_SRGB, nullptr, 0, &inCtx);

// 2) 출력(타깃) 프로파일: 모니터 ICC
auto monICC = GetDefaultMonitorProfile(hwnd);
std::vector<BYTE> iccBytes = LoadFileBytes(monICC); // 파일 읽기
ComPtr<ID2D1ColorContext> outCtx;
dc->CreateColorContext(D2D1_COLOR_CONTEXT_TYPE_ICC, iccBytes.data(), (UINT32)iccBytes.size(), &outCtx);

// 3) 프로퍼티 설정
colorFx->SetValue(D2D1_COLORMANAGEMENT_PROP_QUALITY, D2D1_COLORMANAGEMENT_QUALITY_BEST);
colorFx->SetValue(D2D1_COLORMANAGEMENT_PROP_SOURCE_COLOR_CONTEXT, inCtx.Get());
colorFx->SetValue(D2D1_COLORMANAGEMENT_PROP_DESTINATION_COLOR_CONTEXT, outCtx.Get());
colorFx->SetValue(D2D1_COLORMANAGEMENT_PROP_ALPHA_MODE, D2D1_COLORMANAGEMENT_ALPHA_MODE_PREMULTIPLIED);

// 4) 입력 비트맵을 이펙트에 넣고 DrawImage
colorFx->SetInput(0, srcBitmap); // ID2D1Bitmap*
dc->BeginDraw();
dc->DrawImage(colorFx.Get());
dc->EndDraw();
```

- **장점**: 텍스처가 **P3/AdobeRGB** 라도 **실시간 변환**하여 올바르게 표시.  
- **주의**: 픽셀/알파 방식(PreMultiplied vs Straight)을 맞춘다.

---

## 5) HDR 출력(Direct3D 11/12 + DXGI)

### 5.1 핵심 개념
- **HDR10**:  
  - **컬러 공간**: BT.2020  
  - **전송 함수**: PQ(ST2084)  
  - **메타데이터**: Mastering/Content Light Level  
  - **DXGI ColorSpace**: `DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020`
- **scRGB**:  
  - 선형 sRGB 확장, **FP16** (`DXGI_FORMAT_R16G16B16A16_FLOAT`)  
  - `DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709` (scRGB)로 쓰기도 함.  
  - Windows 데스크톱 구성(Advanced Color)에서 **HDR 디스플레이 + scRGB**가 흔한 경로.

### 5.2 HDR 지원 확인 & 스왑체인 설정 (DXGI 1.5+)
```cpp
ComPtr<IDXGISwapChain1> sc1;
ComPtr<IDXGISwapChain4> sc4;
DXGI_SWAP_CHAIN_DESC1 desc{};
desc.Width = width; desc.Height = height;
desc.Format = DXGI_FORMAT_R16G16B16A16_FLOAT;     // scRGB/HDR-friendly
desc.SampleDesc = {1,0};
desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
desc.BufferCount = 3;
desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
desc.Scaling = DXGI_SCALING_STRETCH;

factory->CreateSwapChainForHwnd(device, hwnd, &desc, nullptr, nullptr, &sc1);
sc1.As(&sc4);

// 출력이 HDR을 지원하는지 확인
ComPtr<IDXGIOutput> out;
sc4->GetContainingOutput(&out);
ComPtr<IDXGIOutput6> out6; out.As(&out6);
DXGI_OUTPUT_DESC1 od{};
out6->GetDesc1(&od);
bool hdrCapable = (od.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) ||
                  (od.ColorSpace == DXGI_COLOR_SPACE_RGB_STUDIO_G2084_NONE_P2020) ||
                  (od.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709); // scRGB 지원환경

// 컬러 공간 설정 시도
auto TrySetCS = [&](DXGI_COLOR_SPACE_TYPE cs) {
    UINT sup = 0; sc4->CheckColorSpaceSupport(cs, &sup);
    if (sup & DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT)
        return SUCCEEDED(sc4->SetColorSpace1(cs));
    return false;
};

bool okHDR10 = TrySetCS(DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020);
bool okscRGB = TrySetCS(DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709); // scRGB

// HDR 메타데이터 설정(HDR10)
if (okHDR10) {
    DXGI_HDR_METADATA_HDR10 md{};
    // Mastering primaries (BT.2020), 백색점, 최대/최소 닛츠
    md.RedPrimary[0]   = 34000; md.RedPrimary[1]   = 16000;
    md.GreenPrimary[0] = 13250; md.GreenPrimary[1] = 34500;
    md.BluePrimary[0]  = 7500;  md.BluePrimary[1]  = 3000;
    md.WhitePoint[0]   = 15635; md.WhitePoint[1]   = 16450; // D65 (x=0.3127,y=0.3290)
    md.MinMasteringLuminance = 50;    // 0.005 nit 단위 → 50 = 0.05 nit
    md.MaxMasteringLuminance = 1000000; // 1 nit 단위 → 1000000 = 1000 nits
    md.MaxContentLightLevel  = 1000;     // MaxCLL
    md.MaxFrameAverageLightLevel = 400;  // MaxFALL
    sc4->SetHDRMetaData(DXGI_HDR_METADATA_TYPE_HDR10, sizeof(md), &md);
}
```

### 5.3 렌더 경로
- **HDR10 경로**:  
  1) **씬을 선형 공간(linear)** 에서 누적 → **BT.2020 primaries** 로 변환 (필요 시 매트릭스)  
  2) **PQ OETF(ST2084)** 로 인코딩 → 스왑체인에 **FP16** 텍스처로 쓰기  
  3) 위 컬러 스페이스/메타데이터 설정과 함께 Present  
- **scRGB 경로**:  
  - 씬을 **선형 sRGB** 로 유지, 밝은 값은 1.0 초과 **FP16** 범위 사용  
  - OS/디스플레이가 **톤매핑**. (간편하지만 컨트롤이 제한)

### 5.4 PQ 인코딩(셰이더 개념)
```hlsl
// EOTF^-1 (Linear scene -> PQ code)
float3 LinearToPQ(float3 L) {
    // L in cd/m^2 normalized by mastering (depending on pipeline)
    // Practical approximation: use ST2084 constants
    const float m1 = 2610.0/16384.0;
    const float m2 = 2523.0/32.0;
    const float c1 = 3424.0/4096.0;
    const float c2 = 2413.0/128.0;
    const float c3 = 2392.0/128.0;
    float3 Lm = clamp(L, 0.0, 10000.0); // 0~10000 nits
    float3 Lp = pow(Lm/10000.0, m1);
    float3 num = c1 + c2 * Lp;
    float3 den = 1.0 + c3 * Lp;
    return pow(num/den, m2);
}
```
> 실제 구현에선 **색 변환(BT.709 ↔ BT.2020)** 매트릭스, **화이트밸런스** 포함.  
> scRGB → PQ 전환 시 **씬 레퍼런스**의 휘도 스케일(노출)을 적절히 잡는다.

---

## 6) SDR 폴백(톤매핑)

HDR을 지원하지 않는 모니터/OS 설정인 경우 **SDR**로 내려간다.  
- **옵션 A**: scRGB로 렌더 → 톤매핑 셰이더로 **sRGB 0~1** 범위에 압축  
- **옵션 B**: HDR10 목표 렌더 → **PQ→sRGB 톤매핑** (Hable/Reinhard/ACES 등)

### 6.1 재빠른 톤매퍼(Hable Filmic 근사)
```hlsl
float3 ToneMapFilmic(float3 x) {
    // Hable filmic curve parameters (cinematic look)
    const float A=0.15; const float B=0.50; const float C=0.10;
    const float D=0.20; const float E=0.02; const float F=0.30;
    float3 num = ((x*(A*x+C*B))+D*E);
    float3 den = ((x*(A*x+B))+D*F) - E;
    return saturate(num/den);
}
```
- 출력 전에 **γ 2.2** 또는 **sRGB OETF** 적용.  
- UI/텍스트는 **톤매핑 전** 밝기 보호(Separate UI Composition) 또는 **SDR 레이어**로 합성.

---

## 7) Display P3 지원(광색역 SDR)

- P3는 **sRGB보다 넓은 원색**. 전송 곡선은 **sRGB와 동일**인 경우가 많다(P3-D65).  
- **작업공간**을 sRGB로 유지하면 **컷오프** 발생 →  
  - **작업공간**을 **linear sRGB** 대신 **linear P3**로 유지하거나,  
  - 콘텐츠가 P3 태그라면 **표시 전 변환**만 하지 말고 **처음부터 P3 작업공간으로 변환**해서 편집.

### 7.1 WIC: P3 ICC → sRGB 변환(예)
```cpp
auto src = LoadWicSource(L"p3_image.png");
auto srcCC = GetEmbeddedColorContext((IWICBitmapFrameDecode*)src); // P3 ICC
auto dstCC = CreateSRgbContext(); // sRGB
auto out = ConvertColor(src, srcCC.Get(), dstCC.Get(), GUID_WICPixelFormat32bppPBGRA);
// out → D2D Bitmap → 렌더
```

### 7.2 D2D ColorManagement로 런타임 변환
- 입력에 **P3 ICC**를 붙이고, 출력에 **모니터 ICC**를 붙여 **실시간 변환**.

---

## 8) UI/텍스트와 색 관리

- **텍스트/아이콘**: 보통 **sRGB에서 디자인**됨. HDR 톤매핑과 섞이면 **회색/흐릿**해질 수 있음.  
- **권장**:  
  1) 씬(콘텐츠) 렌더 타깃과 **UI 레이어 분리**  
  2) UI는 **sRGB SDR 공간**에 그린 후, 최종 합성 시 **적절한 게인**을 적용  
  3) HDR 디스플레이에서도 UI는 **SDR로 유지**(OS의 **Advanced Color** 모드 기본 UX와 일치)

---

## 9) GDI/GDI+ 경고 (SDR 한계)

- **GDI**: 색 관리 **가능**하지만 고급 변환은 제한적, HDR 경로 **미지원**.  
- **GDI+**: 임베디드 ICC를 **기본 사용** 하나, 고성능/정밀 컨트롤은 WIC/D2D가 유리.  
- **투명 창/레이어드 윈도우**: DWM 합성 경로에서 **색 공간**이 sRGB로 강제될 수 있음 → HDR 앱은 **전화면/플립 모델** 권장.

---

## 10) QA/테스트 체크리스트

- [ ] sRGB/JPEG(임베드X) vs P3 PNG(임베드O) → **색 차이**가 정상인지  
- [ ] AdobeRGB 사진 → 모니터 ICC로 정확 변환(스킨톤 자연)  
- [ ] HDR 모니터: OS **“HDR 사용” ON/OFF** 상태 모두 테스트  
- [ ] **DXGI Color Space** 전환 성공/실패 분기 처리  
- [ ] SDR 폴백 톤매핑: 하이라이트 **클리핑/컬러 쉬프트** 없는지  
- [ ] 다중 모니터: **서로 다른 ICC** 에 맞게 창 이동 시 **재설정**  
- [ ] DPI/스케일: 후보창/픽셀 정렬, 글자색 변환 일관성  
- [ ] 스크린샷/썸네일: **sRGB로 내보내기**(HDR 장면은 톤매핑)

---

## 11) 실전 샘플 묶음

### 11.1 “임베디드 ICC → sRGB → D2D 렌더” (SDR)
```cpp
ComPtr<IWICBitmapSource> src(LoadWicSource(L"input.jpg"));
ComPtr<IWICBitmapFrameDecode> f; src.As(&f);
auto embedCC = GetEmbeddedColorContext(f.Get());
if (!embedCC) embedCC = CreateSRgbContext(); // 태그 없으면 sRGB 가정
auto dstCC = CreateSRgbContext();

ComPtr<IWICBitmapSource> out(ConvertColor(src.Get(), embedCC.Get(), dstCC.Get()));
// D2D bitmap으로 만들어 그리기
ComPtr<ID2D1Bitmap> d2dbmp;
dc->CreateBitmapFromWicBitmap(out.Get(), &d2dbmp);
dc->DrawBitmap(d2dbmp.Get());
```

### 11.2 “P3 원본 → 모니터 ICC 직접” (정확 표시)
```cpp
auto monIcc = GetDefaultMonitorProfile(hwnd);
auto monCC  = CreateColorContextFromIcc(monIcc);
auto out = ConvertColor(src.Get(), embedCC.Get(), monCC.Get());
```

### 11.3 “HDR10 경로 + SDR 폴백”
```cpp
bool isHDR = okHDR10 || okscRGB;
if (okHDR10) {
    // PQ 파이프라인: Linear scene → BT.2020 → PQ → Present
} else if (okscRGB) {
    // scRGB 파이프라인: Linear sRGB → FP16 Present (OS 톤매핑)
} else {
    // SDR 폴백: Linear → sRGB 톤매핑 → 8/10bit BGRA
}
```

---

## 12) 색 변환 매트릭스 (참고)

### 12.1 Primaries 변환
- sRGB(Rec.709) ↔ BT.2020 / P3 변환은 3×3 매트릭스(색도 좌표에서 계산).  
- 예) **Rec.709 → BT.2020** (근사):
```
| 0.6274  0.3293  0.0433 |
| 0.0691  0.9195  0.0114 |
| 0.0164  0.0880  0.8956 |
```
> 정확 값은 색도좌표와 적분 상수에 따라 **미세 차이**. LUT 기반(ICC)이 가장 안전.

### 12.2 sRGB OETF/EOTF
- **sRGB OETF**: low region linear, high region gamma 2.4 근사.  
- 선형/감마 변환은 **정밀하게**(D3D에서 half float 권장).

---

## 13) 저장/내보내기 (WIC)

- **sRGB PNG/JPEG**: iCCP를 **sRGB**로 저장하거나 **없음**(sRGB 가정).  
- **P3/AdobeRGB**: iCCP **임베드** 필수(편집/재표시 때 색 유지).  
- **HDR 스틸**: JPEG XL/AVIF/HEIF/HDR PNG(half float) 등 포맷 고려(Windows 코덱 가용성 확인).  
- **썸네일**: SDR 소비가 대부분이므로 **톤매핑된 sRGB** 썸네일을 **추가 저장**.

---

## 14) 성능 팁

- 변환이 많다면 **공유 LUT**(3D LUT)로 묶어 **GPU 샘플링** 비용 절약.  
- 동일 ICC 변환 반복 시 **IWICColorTransform 재사용**.  
- D2D ColorManagement 이펙트는 **플립 모델 + GPU 가속** 조합에서 매우 빠름.  
- HDR10은 **더블/트리플 버퍼** + **Flip** 스왑체인 필수.  
- 톤매퍼는 **한 패스**(compute/pixel)로 구현.

---

## 15) 흔한 문제와 해결

| 문제 | 원인 | 해결 |
|---|---|---|
| P3 이미지가 “쨍함/과포화” | sRGB로 가정하고 그냥 그림 | **임베디드 ICC** 읽어 **모니터 혹은 sRGB**로 변환 |
| HDR 모니터에서 색이 바래 보임 | SDR 파이프라인 | **DXGI Color Space**를 HDR10/scRGB로 설정 |
| HDR에서 텍스트가 흐림 | 톤매핑에 포함되어 콘트라스트 저하 | **UI 레이어 분리**, SDR 공간에서 합성 |
| 다중 모니터 이동 시 색 변화 | 다른 ICC | **WM_DISPLAYCHANGE / monitor change** 감지 → **컨텍스트 재설정** |
| 스크린샷이 실제보다 어둠 | HDR 프레임 캡처를 SDR로 저장 | **톤매핑 후 sRGB**로 저장 |

---

## 16) 최소 예제 묶음(요약 코드 나열)

### 16.1 WIC + D2D: 색 변환 후 표시
```cpp
auto frame = (IWICBitmapFrameDecode*)LoadWicSource(L"in.jpg");
auto srcCC = GetEmbeddedColorContext(frame);
if (!srcCC) srcCC = CreateSRgbContext();
auto dstCC = CreateSRgbContext(); // 또는 모니터 ICC
ComPtr<IWICBitmapSource> x(ConvertColor(frame, srcCC.Get(), dstCC.Get()));
ComPtr<ID2D1Bitmap> bmp;
dc->CreateBitmapFromWicBitmap(x.Get(), &bmp);
dc->DrawBitmap(bmp.Get());
```

### 16.2 D2D Color Management 이펙트
```cpp
dc->CreateEffect(CLSID_D2D1ColorManagement, &fx);
fx->SetValue(D2D1_COLORMANAGEMENT_PROP_SOURCE_COLOR_CONTEXT, inCtx.Get());
fx->SetValue(D2D1_COLORMANAGEMENT_PROP_DESTINATION_COLOR_CONTEXT, outCtx.Get());
fx->SetInput(0, srcBitmap);
dc->DrawImage(fx.Get());
```

### 16.3 HDR10 설정 핵심
```cpp
bool okHDR10 = TrySetCS(DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020);
if (okHDR10) {
  DXGI_HDR_METADATA_HDR10 md = {/* primaries/whitepoint/max/min/MaxCLL/MaxFALL */};
  sc4->SetHDRMetaData(DXGI_HDR_METADATA_TYPE_HDR10, sizeof(md), &md);
}
```

### 16.4 SDR 톤매핑(픽셀 셰이더)
```hlsl
float3 color = ReadHDR();     // linear HDR
color = ToneMapFilmic(color); // compress
color = pow(color, 1.0/2.2);  // gamma encode
return float4(color, 1);
```

---

## 17) 결론

- **정확함**: 임베디드/모니터 **ICC**로 색을 관리 → P3/AdobeRGB도 정확 표시  
- **현대성**: Direct2D **ColorManagement** 이펙트로 실시간 변환, WIC로 디코딩  
- **HDR**: **HDR10/scRGB 경로**를 갖추고, **SDR 톤매핑** 폴백을 항상 준비  
- **다중 모니터/ICC/OS 설정** 변화에 **동적으로 적응**(핫 리로드)  
- 이 가이드를 템플릿으로 삼아 **정확·일관·부드러운** 색을 사용자에게 제공하세요.