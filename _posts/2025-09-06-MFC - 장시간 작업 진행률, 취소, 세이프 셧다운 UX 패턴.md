---
layout: post
title: MFC - 장시간 작업 진행률, 취소, 세이프 셧다운 UX 패턴
date: 2025-09-06 19:25:23 +0900
category: MFC
---
# 장시간 작업 진행률 / 취소 / 세이프 셧다운 UX 패턴

(MFC/Win32: 진행 대화상자, 취소/일시정지, 체크포인트, 안전 저장, 종료 시그널, 복구까지)

장시간 작업을 **안전하고 중단 가능하게** 만들면 사용자 신뢰가 올라가고, 장애 대응 비용이 줄어듭니다.
이 글은 **MFC/Win32** 기준으로 **UX·스레딩·동기화·파일 안전성**을 한 번에 설계하는 방법을 **예제 중심**으로 정리합니다.

> 대상: C++17 이상, Unicode, x64, MFC(Feature Pack 포함)
> 핵심 키워드: **모델리스 진행 대화상자**, **협력적 취소(Cooperative Cancellation)**, **세이프 셧다운(Safe Shutdown)**, **체크포인트/재개(Resume)**, **원자적 저장/백업**

---

## 큰 그림 (아키텍처 한 장 요약)

```
[UI Thread]
  ├─ Modeless Progress Dialog (진행률/취소/일시정지)
  ├─ PostMessage로 상태 반영 (WM_APP_PROGRESS 등)
  └─ 종료 요청 처리(WM_CLOSE/WM_QUERYENDSESSION) → Cancel 이벤트 세팅

[Worker Thread]
  ├─ 긴 작업 수행 (I/O/연산)
  ├─ 주기적으로 Cancel/Paused 이벤트 확인
  ├─ 체크포인트 저장(원자적 저장: tmp→replace)
  ├─ 진행률 보고(비동기 PostMessage or Thread-Safe 큐)
  └─ 종료 시 리소스 정리/중간 결과 flush

[Persistence]
  ├─ 중간 상태 파일(.chk) + 최종 출력(.out)
  ├─ Atomic Save (tmp -> replace, .bak 롤링)
  └─ 재시작 시 체크포인트 로드 후 Resume
```

---

## UX 원칙 (사람이 느끼는 신뢰)

1. **항상 취소 가능**: “취소” 버튼은 **항상 보이고 즉시 반응**해야 함
2. **피드백은 2초 이내**: 시작 후 2초 내에 **상태 텍스트** 또는 **불확정(progress marquee)** 표시
3. **예상치 제공**: 전체 퍼센트, 남은 시간(ETA), 처리 속도(개/초)
4. **중단 안전**: 취소/종료/절전에도 데이터가 깨지지 않도록 **체크포인트+원자적 저장**
5. **복구 제안**: 앱 재실행 시 “중단된 작업 복구”를 **자동 감지/제안**
6. **로그/상세**: 실패/취소 시 **무엇이 되었고, 어디까지 했는지**를 남김 (문제 재현/지원 용이)

---

## 기본 골격: 모델리스 진행 대화상자 + 워커 스레드

### 2-1. 메시지 정의

```cpp
// WM_APP 파생 사용자 메시지 (UI 스레드만 처리)
constexpr UINT WM_APP_PROGRESS = WM_APP + 1; // wParam=0..100, lParam=(LPARAM)taskId
constexpr UINT WM_APP_STATUS   = WM_APP + 2; // lParam=LPCTSTR(ptr) 또는 문자열 핸들
constexpr UINT WM_APP_DONE     = WM_APP + 3; // 성공/실패 코드 보고
```

### 2-2. 진행 대화상자(모델리스) 스켈레톤

```cpp
class CProgressDlg : public CDialogEx {
public:
    CProgressDlg() : CDialogEx(IDD_PROGRESS) {}
    BOOL Create(CWnd* pParent) { return CDialogEx::Create(IDD_PROGRESS, pParent); }

    void SetRange(int max) { m_max = max; m_prog.SetRange(0, max); }
    void SetCancelable(bool b) { GetDlgItem(IDC_BTN_CANCEL)->EnableWindow(b); }
    void SetPausable(bool b)   { GetDlgItem(IDC_BTN_PAUSE)->EnableWindow(b); }

    void UpdatePercent(int v) { m_prog.SetPos(v); }
    void UpdateText(const CString& s) { SetDlgItemText(IDC_STATIC_STATUS, s); }

    bool IsCanceled() const { return m_canceled; }
    bool IsPaused()   const { return m_paused;  }

protected:
    CProgressCtrl m_prog;
    bool m_canceled=false, m_paused=false;

    BOOL OnInitDialog() override {
        CDialogEx::OnInitDialog();
        m_prog.SubclassDlgItem(IDC_PROGRESS1, this);
        m_prog.SetMarquee(TRUE, 0); // 시작은 불확정
        return TRUE;
    }

    afx_msg void OnBnClickedCancel() { m_canceled = true; }
    afx_msg void OnBnClickedPause()  { m_paused = !m_paused;
      SetDlgItemText(IDC_BTN_PAUSE, m_paused? _T("재개") : _T("일시정지")); }

    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CProgressDlg, CDialogEx)
    ON_BN_CLICKED(IDC_BTN_CANCEL, &CProgressDlg::OnBnClickedCancel)
    ON_BN_CLICKED(IDC_BTN_PAUSE,  &CProgressDlg::OnBnClickedPause)
END_MESSAGE_MAP()
```

### 2-3. 워커 스레드(CWinThread) + 협력적 취소

```cpp
struct TaskCtx {
    HWND  hUi{};
    HANDLE hCancel{}; // Manual-reset event
    HANDLE hPause{};  // Manual-reset event (signaled = paused)
    int   total=0;
    CString input, output;
    // 체크포인트/상태 파일 경로 등
};

UINT AFX_CDECL TaskThreadProc(LPVOID p) {
    std::unique_ptr<TaskCtx> ctx((TaskCtx*)p);
    const int n = ctx->total;

    auto PostStatus = [&](const CString& s) {
        ::PostMessage(ctx->hUi, WM_APP_STATUS, 0, (LPARAM)new CString(s));
    };
    auto PostProgress = [&](int percent) {
        ::PostMessage(ctx->hUi, WM_APP_PROGRESS, (WPARAM)percent, 0);
    };

    PostStatus(_T("초기화 중…"));
    // (1) 입력/출력 준비, 체크포인트 로드
    int startIndex = LoadCheckpointOr0(ctx->input); // 예: 0 또는 복구 지점
    PostStatus(CString().Format(_T("재개 위치: %d/%d"), startIndex, n));

    for (int i = startIndex; i < n; ++i) {

        // (2) 취소/일시정지 확인
        HANDLE hs[2] = { ctx->hCancel, ctx->hPause };
        for (;;) {
            DWORD rc = WaitForMultipleObjects(2, hs, FALSE, 0);
            if (rc == WAIT_OBJECT_0) { // 취소
                SaveCheckpoint(ctx->input, i);
                PostStatus(_T("사용자 취소. 진행 내역 저장 완료."));
                ::PostMessage(ctx->hUi, WM_APP_DONE, FALSE, 0);
                return 0;
            } else if (rc == WAIT_OBJECT_0+1) { // 일시정지 상태
                // Paused: 메시지 펌프와 함께 대기 (CPU 낭비 없음)
                DWORD r2 = MsgWaitForMultipleObjects(2, hs, FALSE, INFINITE, QS_ALLINPUT);
                if (r2 == WAIT_OBJECT_0 || r2 == WAIT_OBJECT_0+1) continue; // cancel/pause 변화
                // 메시지 펌프
                MSG msg; while (PeekMessage(&msg, nullptr, 0,0, PM_REMOVE)) {
                    TranslateMessage(&msg); DispatchMessage(&msg);
                }
                continue;
            } else break; // 진행
        }

        // (3) 실제 작업 (I/O/연산)
        if (!ProcessItem(ctx->input, ctx->output, i)) {
            SaveCheckpoint(ctx->input, i);
            PostStatus(CString().Format(_T("오류: %d번째 항목 처리 실패"), i));
            ::PostMessage(ctx->hUi, WM_APP_DONE, FALSE, 0);
            return 0;
        }

        // (4) 주기적 체크포인트/진행률
        if ((i % 100)==0) SaveCheckpoint(ctx->input, i);   // 100개마다
        int percent = (int)((i+1) * 100.0 / n + 0.5);
        PostProgress(percent);
        if ((i % 20)==0) PostStatus(CString().Format(_T("%d/%d 처리중…"), i+1, n));
    }

    // (5) 마무리/원자적 저장
    if (!FinalizeAndAtomicSave(ctx->output)) {
        PostStatus(_T("최종 저장 실패(원자적 교체 실패)."));
        ::PostMessage(ctx->hUi, WM_APP_DONE, FALSE, 0);
        return 0;
    }

    PostStatus(_T("완료!"));
    ::PostMessage(ctx->hUi, WM_APP_DONE, TRUE, 0);
    return 0;
}
```

> 핵심: **Cancel/Pause 이벤트**를 루프에서 **자주 확인**하고, 취소 시 **체크포인트 저장** 후 종료합니다.
> 메시지 보고는 **PostMessage**(비동기)로 UI 스레드에서 안전하게 처리합니다.

---

## UI와 워커 연결: 시작/취소/종료 시퀀스

```cpp
class CMainDlg : public CDialogEx {
public:
    CProgressDlg m_prog;
    CWinThread*  m_pThread=nullptr;
    HANDLE       m_hCancel=nullptr, m_hPause=nullptr;

    BOOL OnInitDialog() override {
        CDialogEx::OnInitDialog();
        m_prog.Create(this);
        m_prog.ShowWindow(SW_HIDE);
        m_hCancel = CreateEvent(nullptr, TRUE, FALSE, nullptr); // manual
        m_hPause  = CreateEvent(nullptr, TRUE, FALSE, nullptr); // manual; signaled=paused
        ResetEvent(m_hPause); // 초기에는 진행중
        return TRUE;
    }

    void StartTask(const CString& input, const CString& output, int total) {
        m_prog.ShowWindow(SW_SHOW);
        m_prog.SetRange(100);
        m_prog.SetCancelable(TRUE); m_prog.SetPausable(TRUE);

        auto ctx = std::make_unique<TaskCtx>();
        ctx->hUi = m_hWnd;
        ctx->hCancel = m_hCancel;
        ctx->hPause  = m_hPause;
        ctx->input = input;
        ctx->output = output;
        ctx->total = total;

        m_pThread = AfxBeginThread(TaskThreadProc, ctx.release(), THREAD_PRIORITY_BELOW_NORMAL);
    }

    void StopTask() {
        if (m_hCancel) SetEvent(m_hCancel); // 협력적 중단
    }

protected:
    afx_msg LRESULT OnAppProgress(WPARAM w, LPARAM) {
        int p = (int)w;
        if (p >= 0) {
            if (p==0) m_prog.m_prog.SetMarquee(TRUE, 0);
            else      m_prog.m_prog.SetMarquee(FALSE, 0);
            m_prog.UpdatePercent(p);
            SetDlgItemInt(IDC_STATIC_PERCENT, p);
        }
        return 0;
    }

    afx_msg LRESULT OnAppStatus(WPARAM, LPARAM l) {
        std::unique_ptr<CString> ps((CString*)l);
        m_prog.UpdateText(*ps);
        return 0;
    }

    afx_msg LRESULT OnAppDone(WPARAM ok, LPARAM) {
        m_prog.UpdateText(ok? _T("완료") : _T("실패/취소"));
        m_prog.ShowWindow(SW_HIDE);
        ResetEvent(m_hCancel);
        ResetEvent(m_hPause);
        m_pThread = nullptr;
        return 0;
    }

    afx_msg void OnBnClickedCancel() { StopTask(); }
    afx_msg void OnBnClickedPause()  {
        // UI 버튼은 progress dlg에 있고, 여기서 이벤트만 토글
        DWORD s = WaitForSingleObject(m_hPause, 0);
        if (s == WAIT_TIMEOUT) SetEvent(m_hPause);   // 일시정지 시작
        else                   ResetEvent(m_hPause); // 재개
    }

    // 앱 종료/윈도우 닫기 시 안전 셧다운
    void OnClose() override {
        if (m_pThread) {
            if (AfxMessageBox(_T("진행 중인 작업이 있습니다. 안전하게 중단할까요?"),
                              MB_ICONQUESTION|MB_YESNO) == IDYES) {
                StopTask();
                // UI 펌프와 함께 기다림
                WaitWorkerFinishWithPump();
            } else return;
        }
        CDialogEx::OnClose();
    }

    void WaitWorkerFinishWithPump() {
        HANDLE h = m_pThread? m_pThread->m_hThread : nullptr;
        if (!h) return;
        for (;;) {
            DWORD rc = MsgWaitForMultipleObjects(1, &h, FALSE, 50, QS_ALLINPUT);
            if (rc == WAIT_OBJECT_0) break;
            MSG msg; while (PeekMessage(&msg, nullptr, 0,0, PM_REMOVE)) {
                TranslateMessage(&msg); DispatchMessage(&msg);
            }
        }
    }

    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_MESSAGE(WM_APP_PROGRESS, &CMainDlg::OnAppProgress)
    ON_MESSAGE(WM_APP_STATUS,   &CMainDlg::OnAppStatus)
    ON_MESSAGE(WM_APP_DONE,     &CMainDlg::OnAppDone)
    ON_BN_CLICKED(IDC_BTN_CANCEL, &CMainDlg::OnBnClickedCancel)
    ON_BN_CLICKED(IDC_BTN_PAUSE,  &CMainDlg::OnBnClickedPause)
    ON_WM_CLOSE()
END_MESSAGE_MAP()
```

> 포인트
> - **종료 시** 작업이 있으면 **취소 신호 → 펌프 동반 대기**(프리즈 방지)
> - 진행률 0%일 때는 **Marquee(불확정)**, 전체 수가 파악되면 **확정 진행 바**로 전환

---

## 체크포인트 & 재개(Resume) 설계

### 4-1. 체크포인트 구조 (JSON 예)

```json
{
  "format": 1,
  "inputPath": "C:\\data\\in",
  "outputPath": "C:\\data\\out.tmp",
  "nextIndex": 2345,
  "total": 100000,
  "lastSavedUtc": "2025-10-25T07:21:33Z"
}
```

- **nextIndex**: 다음에 처리할 인덱스
- **outputPath**: 아직 최종 파일로 교체 전의 임시 출력 경로
- **원자적 저장**: `checkpoint.tmp`에 쓴 뒤 `MoveFileEx(checkpoint.tmp, checkpoint.json, MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)`

### 4-2. 세이프 저장(Atomic Save) 함수

```cpp
bool AtomicReplaceFile(const CString& tmp, const CString& final) {
    // Windows 7+: ReplaceFileW 사용 검토(백업 경로, EFS/ACL 유지 등)
    if (::ReplaceFileW(final, tmp, nullptr, REPLACEFILE_WRITE_THROUGH, nullptr, nullptr))
        return true;
    // 폴백: MoveFileEx
    return !!::MoveFileExW(tmp, final, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
}
```

### 4-3. 재개 로직

```cpp
int LoadCheckpointOr0(const CString& input) {
    CString chk = MakeCheckpointPath(input);
    if (!PathFileExists(chk)) return 0;
    // JSON 파싱 후 nextIndex 반환 (예외/손상 보호: .bak 백업 허용)
    return ParseJsonNextIndex(chk);
}
```

---

## 취소/일시정지 UX 디테일

- **즉시 반응**: 취소 클릭 → 버튼 **즉시 비활성화** + “취소 중…” 텍스트, 실제 종료까지 시간 걸릴 수 있음
- **일시정지**: 일시정지 중에는 **대기 이벤트**로 스레드가 Sleep 상태(낮은 CPU/전력)
- **복수 작업**: 작업마다 **독립 취소 토큰**(Event 핸들) 보유, 상위 “모두 취소”에서 전부 SetEvent
- **취소 시 데이터**: “중단 지점까지의 산출물은 유지/폐기?” 옵션 제공(기본: 유지 + 다음에 재개)

---

## 종단(Exit) 시나리오 — WM_QUERYENDSESSION/WM_ENDSESSION

```cpp
BOOL CMainDlg::OnQueryEndSession() {
    if (m_pThread) {
        // 시스템 종료/로그오프 전: 즉시 취소 신호
        StopTask();
        WaitWorkerFinishWithPump();
    }
    return CDialogEx::OnQueryEndSession();
}

void CMainDlg::OnEndSession(BOOL bEnding) {
    if (bEnding && m_pThread) {
        // 이중 안전장치: 체크포인트 강제 저장 요청(가능한 범위)
        StopTask();
    }
    CDialogEx::OnEndSession(bEnding);
}
```

> 시스템 종료는 시간이 제한됨(수초). **짧은 작업만 수행**하고, 체크포인트/임시 파일로 **복구 가능**하게 설계합니다.

---

## 파일 I/O 성능 & 안정성 팁

- **버퍼링**: 대형 파일은 **버퍼링/블록 단위**(예: 1~4MB)
- **쓰기 순서**: “쓰기 → FlushFileBuffers → Close → AtomicReplace”
- **로그 롤링**: `app-YYYYMMDD.log`, 오류/취소 시 **스택/상태** 기록
- **권한/경로**: 사용자 폴더(AppData) 기본, Program Files 쓰기 금지

---

## 에러/예외 처리 UX

- **사용자 메시지**: 무엇이 실패했는지(경로/권한/디스크 부족), 해결책(다른 경로, 관리자 권한, 여유 공간)
- **자동 재시도**: 일시적 오류(네트워크/잠금) → 지수 백오프(0.5s, 1s, 2s, … 최대 N회)
- **부분 실패**: 실패 항목 목록을 **CSV/로그로 Export** 버튼 제공
- **지원 패키지**: “진단 정보 복사하기”(버전, 입력/출력 경로, 로그 위치)

---

## 성능/응답성 (배압, 샘플링, 쓰로틀)

- **진행률 빈도**: 매 항목마다 Post하면 큐가 포화 → **샘플링(100ms마다 1회)**
- **속도/ETA 계산**: 마지막 N초 평균(Exponential Moving Avg)
- **CPU 제한**: 백그라운드 우선순위, I/O 쓰로틀(대기 삽입)
- **대량 Post 방지**: 최근 값만 유지하는 **lock-free single-producer single-consumer 큐** or “마지막 값만 갱신” 플래그

```cpp
std::atomic<DWORD> g_lastTick{0};
void ReportProgressThrottled(HWND h, int pct) {
    DWORD now = GetTickCount();
    DWORD prev = g_lastTick.load();
    if (now - prev >= 100) {
        if (g_lastTick.compare_exchange_strong(prev, now)) {
            ::PostMessage(h, WM_APP_PROGRESS, pct, 0);
        }
    }
}
```

---

## 멀티 작업(큐) 설계: 스케줄러 + 작업 카드

- **작업 큐**: std::deque<Job>, **스레드풀 타이머**로 디스패치
- **동시 실행 제한**: 세마포어(동시 N개), 작업별 **취소 이벤트**
- **UI 카드**: 각 작업 행에 ProgressBar/Cancel/Pause 버튼 → **행별 이벤트 핸들**을 보유

```cpp
struct Job {
    UINT id;
    CString in, out;
    HANDLE hCancel, hPause;
    CWinThread* thr{};
};

class JobManager {
    std::map<UINT, Job> jobs;
    CSemaphore sem{2,2}; // 동시 2개
public:
    void Enqueue(Job j) { jobs[j.id]=std::move(j); TryDispatch(); }
    void TryDispatch() {
        for (auto& [id, job] : jobs) {
            if (!job.thr) {
                if (sem.Lock(0) == WAIT_OBJECT_0) {
                    job.thr = AfxBeginThread(TaskThreadProc, MakeCtx(job));
                }
            }
        }
    }
    void OnJobDone(UINT id) {
        sem.Unlock();
        // 정리, UI 업데이트
    }
};
```

---

## 접근성/국제화

- **진행률 텍스트**는 스크린리더가 읽을 수 있도록 **Static Text** 업데이트
- **숫자 포맷/단위**(천단위 구분자, 소수점, locale)
- **메시지 길이**(독일어/프랑스어 등 장문 대비), 줄바꿈/트렁크 처리
- **키보드**: Esc=취소, Space=일시정지/재개, Enter=백그라운드 전환(선택)

---

## 테스트 시나리오 체크리스트

1. **즉시 취소**: 시작 100ms 내 취소 → 예외 없이 종료/체크포인트 기록
2. **중간 취소**: 50% 지점 취소 → 재실행 시 **그 지점부터 재개**
3. **디스크 부족**: 임시 파일 쓰기 중 실패 → 에러 메시지/복구
4. **경로 잠김**: 다른 프로세스 파일 잠금 → 재시도/실패 처리
5. **네트워크 흔들림**: 10% 패킷 손실 시나리오 → 백오프/재시도
6. **시스템 종료**: `WM_QUERYENDSESSION`에서 취소 → 체크포인트 남기고 종료
7. **절전/복귀**: 슬립 5분 후 복귀 → 지연 시간 감지/보정
8. **대량 데이터**: 10만+ 항목 처리, UI 프리즈/누수 확인(GDI/핸들/메모리)
9. **다국어/고DPI**: 레이아웃 깨짐/글자 잘림 여부
10. **로그 검증**: 모든 경로에서 **무엇을 했는지** 남는가?

---

## “한 파일로 끝나는” 미니 샘플 (핵심만 모음)

> 아래는 앞서 만든 조각들을 단순화해 **핵심 흐름**만 모은 예입니다.

```cpp
// Messages
constexpr UINT WM_APP_PROGRESS = WM_APP + 1;
constexpr UINT WM_APP_STATUS   = WM_APP + 2;
constexpr UINT WM_APP_DONE     = WM_APP + 3;

// Task
struct TaskCtx {
    HWND hUi{};
    HANDLE hCancel{}, hPause{};
    int total=50000;
};

static int  LoadCheckpoint() { return 0; }
static void SaveCheckpoint(int i) {}
static bool Process(int i) { /* 실제 일 */ Sleep(1); return true; }

UINT AFX_CDECL TaskThreadProc(LPVOID p) {
    std::unique_ptr<TaskCtx> ctx((TaskCtx*)p);
    int start = LoadCheckpoint();

    for (int i=start; i<ctx->total; ++i) {
        // cancel/pause 확인
        HANDLE hs[2] = { ctx->hCancel, ctx->hPause };
        for (;;) {
            DWORD rc = WaitForMultipleObjects(2, hs, FALSE, 0);
            if (rc == WAIT_OBJECT_0) { SaveCheckpoint(i); PostMessage(ctx->hUi, WM_APP_DONE, FALSE, 0); return 0; }
            if (rc == WAIT_OBJECT_0+1) {
                DWORD r2 = MsgWaitForMultipleObjects(2, hs, FALSE, INFINITE, QS_ALLINPUT);
                if (r2 == WAIT_OBJECT_0 || r2 == WAIT_OBJECT_0+1) continue;
                MSG msg; while (PeekMessage(&msg,nullptr,0,0,PM_REMOVE)){TranslateMessage(&msg);DispatchMessage(&msg);}
                continue;
            }
            break;
        }
        if (!Process(i)) { SaveCheckpoint(i); PostMessage(ctx->hUi, WM_APP_DONE, FALSE, 0); return 0; }
        if ((i%100)==0) SaveCheckpoint(i);
        if ((i%50)==0) PostMessage(ctx->hUi, WM_APP_STATUS, 0, (LPARAM)new CString(CString().Format(_T("%d/%d..."), i, ctx->total)));
        if ((i%10)==0)  PostMessage(ctx->hUi, WM_APP_PROGRESS, (WPARAM)((i+1)*100/ctx->total), 0);
    }
    PostMessage(ctx->hUi, WM_APP_DONE, TRUE, 0);
    return 0;
}
```

---

## 실패/취소 이후의 “사용자 선택지” 구성

- **재개**: “이어서 계속(추천)” / “처음부터 다시”
- **부분 결과**: “지금까지 결과를 내보내기” / “삭제하고 종료”
- **자동화 설정**: “다음부터 자동 재개” 체크박스
- **로그 보기**: 열기 버튼(메모장으로)

---

## 최종 베스트 프랙티스 요약

1. **모델리스 진행 창 + 워커 스레드**: UI는 가볍게, 작업은 백그라운드
2. **협력적 취소/일시정지**: `Event`로 신호, 루프에서 **자주 확인**
3. **체크포인트/재개**: `nextIndex`, 임시 출력, **원자적 저장**
4. **안전한 종료**: `WM_CLOSE`/`WM_QUERYENDSESSION`에서 **취소→펌프대기**
5. **진행률 샘플링**: 100ms 주기, 과도한 Post 방지
6. **오류 복구력**: 재시도/백오프, 부분 결과/로그 제공
7. **국제화/접근성**: 텍스트·단위·키보드 접근 고려
8. **테스트 자동화**: 취소/절전/디스크 부족/대량/다국어 시나리오

---

### 마무리

장시간 작업은 **UX·스레드·I/O 안정성**이 얽혀 있습니다.
위의 **패턴 조합(모델리스 진행 + 이벤트 기반 취소 + 체크포인트 + 원자적 저장 + 안전 셧다운)**만 지켜도
“**중단해도 안심되는 앱**”을 만들 수 있습니다.
