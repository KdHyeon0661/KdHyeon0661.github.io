---
layout: post
title: 영상처리 - 마스크를 이용한 엣지 검출
date: 2025-09-29 19:25:23 +0900
category: 영상처리
---
# 마스크를 이용한 엣지 검출

## 1) 엣지와 함수 그래디언트

### 1.1 엣지(Edge)
엣지는 영상의 **밝기 함수** \(f(x,y)\)가 급격히 변하는 위치(경계)입니다. 엣지의 강도는 변화량의 크기, 방향은 변화의 최대 증가 방향입니다.

### 1.2 그래디언트(Gradient)
\[
\nabla f(x,y) = \left[\frac{\partial f}{\partial x},\ \frac{\partial f}{\partial y}\right]^\top
\]
- **크기**(강도): \(\ |\nabla f| = \sqrt{f_x^2 + f_y^2}\ \) (또는 근사 \( |f_x|+|f_y| \))  
- **방향**: \(\ \theta = \operatorname{atan2}(f_y, f_x)\) (라디안)

### 1.3 유한 차분 근사와 마스크
연속 미분 대신 **컨볼루션 마스크**(3×3)를 사용해 \(\partial/\partial x, \partial/\partial y\) 를 근사합니다.

- **Prewitt**
  - \(G_x=\begin{bmatrix}-1&0&1\\-1&0&1\\-1&0&1\end{bmatrix}\), \(G_y=G_x^\top\)
- **Sobel**
  - \(G_x=\begin{bmatrix}-1&0&1\\-2&0&2\\-1&0&1\end{bmatrix}\), \(G_y=G_x^\top\)
- **Scharr** (수평·수직 응답의 등방성 향상)
  - \(G_x=\begin{bmatrix}-3&0&3\\-10&0&10\\-3&0&3\end{bmatrix}\), \(G_y=G_x^\top\)

> 최대 양의 가중치 합(수평 마스크 기준): Prewitt=3, Sobel=4, Scharr=16.  
> 이 값은 **정규화 스케일**을 결정할 때 중요합니다(아래 구현 참고).

---

## 2) 마스크 기반 엣지 검출 파이프라인

1) **그레이스케일 변환** \(Y=0.299R+0.587G+0.114B\)  
2) (선택) **스무딩**(가우시안) — 본 절에서는 생략, 필요시 8.2절 가우시안 재사용  
3) **컨볼루션**: \(g_x = Y * G_x,\ g_y = Y * G_y\)  
4) **크기/방향** 계산: \(m=\sqrt{g_x^2+g_y^2}\) 또는 \(m=|g_x|+|g_y|\)  
5) **정규화**: 0–255 범위(연산자별 최대 응답 기반)  
6) (선택) **임계값**(Binary) 또는 **각도 맵**(0–π → 0–255)

---

## 3) 마스크 기반 엣지 검출기 구현

### 3.1 코어 헤더 — 커널/옵션/헬퍼

```cpp
// EdgeMasks.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <cmath>
#include <algorithm>
#include "IppDib.h"

enum class EdgeOperator { Prewitt, Sobel, Scharr };
enum class MagnitudeMode { L2_Sqrt, L1_AbsSum };
enum class OutputMode   { Magnitude8U, Binary, Direction };

struct EdgeOptions {
    EdgeOperator  op         = EdgeOperator::Sobel;
    MagnitudeMode magMode    = MagnitudeMode::L2_Sqrt;
    OutputMode    outMode    = OutputMode::Magnitude8U;
    int           threshold  = 80;     // Binary에 사용(0..255)
    bool          replicateBorder = true; // true: 복제, false: 0 패딩
};

struct EdgeKernels {
    int kx[3][3], ky[3][3];
    int posSum; // 양의 가중치 합 (정규화용)
};

inline void GetKernels(EdgeOperator op, EdgeKernels& K){
    if (op==EdgeOperator::Prewitt){
        int Gx[3][3]={{-1,0,1},{-1,0,1},{-1,0,1}};
        int Gy[3][3]={{-1,-1,-1},{0,0,0},{1,1,1}};
        std::copy(&Gx[0][0], &Gx[0][0]+9, &K.kx[0][0]);
        std::copy(&Gy[0][0], &Gy[0][0]+9, &K.ky[0][0]);
        K.posSum=3;
    } else if (op==EdgeOperator::Sobel){
        int Gx[3][3]={{-1,0,1},{-2,0,2},{-1,0,1}};
        int Gy[3][3]={{-1,-2,-1},{0,0,0},{1,2,1}};
        std::copy(&Gx[0][0], &Gx[0][0]+9, &K.kx[0][0]);
        std::copy(&Gy[0][0], &Gy[0][0]+9, &K.ky[0][0]);
        K.posSum=4;
    } else { // Scharr
        int Gx[3][3]={{-3,0,3},{-10,0,10},{-3,0,3}};
        int Gy[3][3]={{-3,-10,-3},{0,0,0},{3,10,3}};
        std::copy(&Gx[0][0], &Gx[0][0]+9, &K.kx[0][0]);
        std::copy(&Gy[0][0], &Gy[0][0]+9, &K.ky[0][0]);
        K.posSum=16;
    }
}

inline void DibToGray8(const IppDib& src, std::vector<uint8_t>& Y, int& W, int& H){
    if (!src){W=H=0; Y.clear(); return;}
    W=src.width(); H=src.height();
    Y.resize((size_t)W*H);
    for (int y=0;y<H;++y){
        const uint8_t* s=(const uint8_t*)src.bits()+(size_t)y*src.stride();
        for (int x=0;x<W;++x){
            int B=s[x*4+0], G=s[x*4+1], R=s[x*4+2];
            int y8 = ( 114*B + 587*G + 299*R + 500 )/1000; // +0.5
            Y[(size_t)y*W+x]=(uint8_t)std::clamp(y8,0,255);
        }
    }
}

inline int clampi(int v, int lo, int hi){ return (v<lo)?lo:((v>hi)?hi:v); }
```

### 3.2 코어 구현 — 컨볼루션/정규화/출력

```cpp
// EdgeMasks.cpp
#include "EdgeMasks.hpp"

static inline uint8_t toU8(double v){
    if (v<0) v=0; else if (v>255) v=255;
    return (uint8_t)std::lround(v);
}

static inline int sampleGray(const std::vector<uint8_t>& Y, int W, int H,
                             int x, int y, bool repl){
    if (repl){
        x=clampi(x,0,W-1); y=clampi(y,0,H-1);
        return Y[(size_t)y*W+x];
    } else {
        if ((unsigned)x>=(unsigned)W || (unsigned)y>=(unsigned)H) return 0;
        return Y[(size_t)y*W+x];
    }
}

static void computeGradients(const std::vector<uint8_t>& Y, int W, int H,
                             const EdgeKernels& K,
                             std::vector<int>& Gx, std::vector<int>& Gy,
                             bool replBorder)
{
    Gx.assign((size_t)W*H,0); Gy.assign((size_t)W*H,0);
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            int sx=0, sy=0;
            for (int j=-1;j<=1;++j){
                for (int i=-1;i<=1;++i){
                    int p = sampleGray(Y, W,H, x+i,y+j, replBorder);
                    sx += K.kx[j+1][i+1]*p;
                    sy += K.ky[j+1][i+1]*p;
                }
            }
            Gx[(size_t)y*W+x]=sx;
            Gy[(size_t)y*W+x]=sy;
        }
    }
}

static void writeMagnitude8(const std::vector<int>& Gx, const std::vector<int>& Gy,
                            int W, int H, const EdgeOptions& opt, int posSum,
                            IppDib& out)
{
    out.create(W,H,32);
    // nom: 최대 응답 기반 정규화 (L1 기준: 2*posSum*255, L2 기준: posSum*255*sqrt2)
    const double max1 = 255.0 * (double)posSum * 2.0;
    const double max2 = 255.0 * (double)posSum * std::sqrt(2.0);
    const double denom = (opt.magMode==MagnitudeMode::L1_AbsSum) ? max1 : max2;
    const double scale = (denom>1e-9) ? 255.0/denom : 1.0;

    for (int y=0;y<H;++y){
        uint8_t* d=(uint8_t*)out.bits()+(size_t)y*out.stride();
        for (int x=0;x<W;++x){
            int gx=Gx[(size_t)y*W+x], gy=Gy[(size_t)y*W+x];
            double m = (opt.magMode==MagnitudeMode::L1_AbsSum)
                        ? (std::abs(gx)+std::abs(gy))
                        : std::sqrt((double)gx*gx + (double)gy*gy);
            uint8_t g = toU8(m*scale);
            d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
        }
    }
}

static void writeBinary(const std::vector<int>& Gx, const std::vector<int>& Gy,
                        int W, int H, const EdgeOptions& opt, int posSum,
                        IppDib& out)
{
    out.create(W,H,32);
    const double max1 = 255.0 * (double)posSum * 2.0;
    const double max2 = 255.0 * (double)posSum * std::sqrt(2.0);
    const double denom = (opt.magMode==MagnitudeMode::L1_AbsSum) ? max1 : max2;
    const double scale = (denom>1e-9) ? 255.0/denom : 1.0;

    const int T = clampi(opt.threshold, 0, 255);

    for (int y=0;y<H;++y){
        uint8_t* d=(uint8_t*)out.bits()+(size_t)y*out.stride();
        for (int x=0;x<W;++x){
            int gx=Gx[(size_t)y*W+x], gy=Gy[(size_t)y*W+x];
            double m = (opt.magMode==MagnitudeMode::L1_AbsSum)
                        ? (std::abs(gx)+std::abs(gy))
                        : std::sqrt((double)gx*gx + (double)gy*gy);
            int v = (int)std::lround(m*scale);
            uint8_t g = (v>=T)? 255 : 0;
            d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
        }
    }
}

static void writeDirection8(const std::vector<int>& Gx, const std::vector<int>& Gy,
                            int W, int H, IppDib& out)
{
    // 방향(0..pi) → 0..255 맵핑 (절대 방향)
    out.create(W,H,32);
    for (int y=0;y<H;++y){
        uint8_t* d=(uint8_t*)out.bits()+(size_t)y*out.stride();
        for (int x=0;x<W;++x){
            int gx=Gx[(size_t)y*W+x], gy=Gy[(size_t)y*W+x];
            double ang = std::atan2((double)gy,(double)gx); // -pi..pi
            if (ang<0) ang += M_PI;                         // 0..pi
            uint8_t g = (uint8_t)std::lround( ang * (255.0/M_PI) );
            d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
        }
    }
}

// ---------- 외부 API ----------
inline bool EdgeDetect(const IppDib& src, IppDib& dst, const EdgeOptions& opt)
{
    if (!src){ dst=src; return false; }
    int W,H; std::vector<uint8_t> Y; DibToGray8(src, Y, W,H);
    EdgeKernels K; GetKernels(opt.op, K);

    std::vector<int> Gx, Gy;
    computeGradients(Y, W,H, K, Gx, Gy, opt.replicateBorder);

    switch (opt.outMode){
    case OutputMode::Magnitude8U:
        writeMagnitude8(Gx,Gy,W,H,opt,K.posSum,dst); break;
    case OutputMode::Binary:
        writeBinary(Gx,Gy,W,H,opt,K.posSum,dst); break;
    case OutputMode::Direction:
        writeDirection8(Gx,Gy,W,H,dst); break;
    }
    return true;
}
```

> 구현 포인트  
> - **정규화**: 마스크의 **양의 합(posSum)** 기반으로 L1/L2에 맞춘 상한을 가정해 0–255 스케일. 데이터마다 최대값을 찾는 적응형 정규화보다 **일관된 보기**가 가능합니다.  
> - **경계 처리**: 기본 **복제(Replicate)**. 0패딩을 원하면 옵션으로 전환.  
> - **Binary**: L1/L2 정규화 후 입력 `threshold`와 비교.

---

## 4) UI — **마스크 기반 엣지 검출 대화 상자**

### 4.1 리소스 ID

```cpp
// resource.h (추가)
#define IDD_EDGE_DLG                 3400
#define IDC_RAD_EDGE_PREWITT         3401
#define IDC_RAD_EDGE_SOBEL           3402
#define IDC_RAD_EDGE_SCHARR          3403
#define IDC_RAD_MAG_L2               3404
#define IDC_RAD_MAG_L1               3405
#define IDC_RAD_OUT_MAG              3406
#define IDC_RAD_OUT_BIN              3407
#define IDC_RAD_OUT_DIR              3408
#define IDC_EDIT_EDGE_THR            3409
#define IDC_CHK_EDGE_REPL            3410

// 메뉴
#define ID_MENU_EDGE_DETECT          73000
```

### 4.2 RC (대화 상자 & 메뉴)

```rc
// ImageTool.rc (추가)
IDD_EDGE_DLG DIALOGEX 0,0, 260, 156
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Edge Detection"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Operator", -1, 10, 10, 88, 44
    AUTORADIOBUTTON "Prewitt", IDC_RAD_EDGE_PREWITT, 16, 24, 50, 10, WS_TABSTOP
    AUTORADIOBUTTON "Sobel",   IDC_RAD_EDGE_SOBEL,   16, 36, 50, 10
    AUTORADIOBUTTON "Scharr",  IDC_RAD_EDGE_SCHARR,  16, 48, 50, 10

    GROUPBOX "Magnitude", -1, 102, 10, 72, 44
    AUTORADIOBUTTON "L2 (sqrt)", IDC_RAD_MAG_L2, 108, 24, 60, 10, WS_TABSTOP
    AUTORADIOBUTTON "L1 (|x|+|y|)", IDC_RAD_MAG_L1, 108, 36, 70, 10

    GROUPBOX "Output", -1, 182, 10, 70, 56
    AUTORADIOBUTTON "Magnitude", IDC_RAD_OUT_MAG, 188, 24, 60, 10, WS_TABSTOP
    AUTORADIOBUTTON "Binary",    IDC_RAD_OUT_BIN, 188, 36, 60, 10
    AUTORADIOBUTTON "Direction", IDC_RAD_OUT_DIR, 188, 48, 60, 10

    LTEXT "Threshold:", -1, 16, 70, 48, 10
    EDITTEXT IDC_EDIT_EDGE_THR, 66, 68, 32, 14, ES_NUMBER

    AUTOCHECKBOX "Replicate border", IDC_CHK_EDGE_REPL, 108, 70, 90, 12

    DEFPUSHBUTTON "OK", IDOK,  146, 116, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 196, 116, 44, 16
END

// 메뉴 & 가속키
POPUP "&Spatial"
BEGIN
    MENUITEM "Edge Detection...\tCtrl+Shift+E", ID_MENU_EDGE_DETECT
END

IDR_ACCEL ACCELERATORS
BEGIN
    "E", ID_MENU_EDGE_DETECT, VIRTKEY, CONTROL, SHIFT
END
```

### 4.3 대화 상자 코드

```cpp
// EdgeDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "EdgeMasks.hpp"

class EdgeDlg {
public:
    EdgeDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM, LPARAM);

    bool IsChecked(HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }
    int  ReadInt(HWND h, int id, int def) const;

private:
    HWND   owner_{};
    IppDib& dib_;
};
```

```cpp
// EdgeDlg.cpp
#include "EdgeDlg.h"

INT_PTR EdgeDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_EDGE_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK EdgeDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(EdgeDlg*)l; return self->OnInit(h); }
    auto* self=(EdgeDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w,l);
    return FALSE;
}
INT_PTR EdgeDlg::OnInit(HWND h){
    CheckRadioButton(h, IDC_RAD_EDGE_PREWITT, IDC_RAD_EDGE_SCHARR, IDC_RAD_EDGE_SOBEL);
    CheckRadioButton(h, IDC_RAD_MAG_L2, IDC_RAD_MAG_L1, IDC_RAD_MAG_L2);
    CheckRadioButton(h, IDC_RAD_OUT_MAG, IDC_RAD_OUT_DIR, IDC_RAD_OUT_MAG);
    SetDlgItemInt(h, IDC_EDIT_EDGE_THR, 80, FALSE);
    CheckDlgButton(h, IDC_CHK_EDGE_REPL, BST_CHECKED);
    return TRUE;
}
int EdgeDlg::ReadInt(HWND h, int id, int def) const{
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    return ok? v : def;
}
INT_PTR EdgeDlg::OnCommand(HWND h, WPARAM w, LPARAM){
    switch (LOWORD(w)){
    case IDOK: {
        EdgeOptions opt;
        if (IsDlgButtonChecked(h, IDC_RAD_EDGE_PREWITT)==BST_CHECKED) opt.op=EdgeOperator::Prewitt;
        else if (IsDlgButtonChecked(h, IDC_RAD_EDGE_SOBEL)==BST_CHECKED) opt.op=EdgeOperator::Sobel;
        else opt.op=EdgeOperator::Scharr;

        opt.magMode = (IsDlgButtonChecked(h, IDC_RAD_MAG_L2)==BST_CHECKED)
                        ? MagnitudeMode::L2_Sqrt : MagnitudeMode::L1_AbsSum;

        if (IsDlgButtonChecked(h, IDC_RAD_OUT_MAG)==BST_CHECKED) opt.outMode=OutputMode::Magnitude8U;
        else if (IsDlgButtonChecked(h, IDC_RAD_OUT_BIN)==BST_CHECKED) opt.outMode=OutputMode::Binary;
        else opt.outMode=OutputMode::Direction;

        opt.threshold = ReadInt(h, IDC_EDIT_EDGE_THR, 80);
        opt.replicateBorder = (IsDlgButtonChecked(h, IDC_CHK_EDGE_REPL)==BST_CHECKED);

        IppDib out;
        if (EdgeDetect(dib_, out, opt)) dib_ = out;

        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

### 4.4 메뉴 메시지 처리

```cpp
// main_multiwin.cpp (발췌)
#include "EdgeDlg.h"

// ...
case ID_MENU_EDGE_DETECT:
    if (st && st->dib){
        EdgeDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 5) 실전 예제 & 상황

### 예제 A) **문서 스캔 엣지 추출**
- **상황**: 흐릿한 문서 스캔에서 글자 윤곽만 보고 싶다.  
- **동작**: `Spatial → Edge Detection…`  
  - Operator: **Sobel**, Magnitude: **L2**, Output: **Binary**, Threshold=**90**, Border=Replicate  
- **결과**: 문자의 스트로크를 중심으로 깔끔한 엣지 맵. 필요시 Threshold 70–120 범위 탐색.

### 예제 B) **텍스처 경계 관찰(방향 맵)**
- **상황**: 섬유/우드 패턴의 **주된 방향**을 관찰.  
- **동작**: Operator **Scharr**, Output **Direction**.  
- **결과**: 0..π가 0..255로 매핑된 방향 영상. 특정 회색 레벨이 **결 정방향**을 의미.

### 예제 C) **약한 엣지까지 보되 링 잔상 최소화**
- **상황**: 얼굴 이미지에서 미세 윤곽을 보고 싶지만 노이즈가 걱정.  
- **동작**: Operator **Prewitt**, Magnitude **L1**, Output **Magnitude**, Border **Replicate**.  
- **결과**: Sobel/Scharr보다 민감도는 낮지만 링/노이즈가 상대적으로 덜 강조.

### 예제 D) **라인 아트 바이너리화 전처리**
- **상황**: 스케치 사진을 라인 아트처럼.  
- **동작**: Sobel L2 Magnitude → Binary(Threshold 100) → (선택) 1–2픽셀 굵게(모폴로지 팁).  
- **결과**: 라인 강조된 흑백 윤곽.

---

## 6) 정확성·성능·확장 팁

- **정확성**
  - 입력이 매우 **노이즈**일 경우, 8.2절 **가우시안 스무딩**(σ=1~1.5)을 먼저 적용하면 엣지가 깔끔.  
  - **Direction** 맵은 \([0,\pi]\) 를 사용(반대 방향 동일). 벡터 방향(부호 포함)을 원하면 \([-\pi,\pi]\) 활용.

- **성능**
  - 3×3 컨볼루션은 메모리 대역폭 지배 → **행 버퍼 3줄**을 굴리면 캐시 효율상 유리.  
  - 다중 창 처리 시 멀티스레딩(행 블록 분할)이 쉽고 효과적.

- **확장**
  - **NMS(비최대 억제)**, **이중 임계+히스테리시스**를 더하면 **Canny**로 확장 가능(다음 절 아이디어).  
  - 마스크 크기 5×5/7×7로 확장해 **더 부드러운** 미분 근사 가능.

---

## 7) 수학 메모 (정규화 직관)

- 단순 스텝(edge)에서, 예: Sobel \(G_x\) 의 양의 계수 합은 4 → 최댓 응답 \(\approx 4\times 255\).  
- L1 크기 상한: \( |g_x|+|g_y| \le 2\cdot 255 \cdot \text{posSum} \).  
- L2 크기 상한: \( \sqrt{g_x^2+g_y^2} \le 255 \cdot \text{posSum}\cdot \sqrt{2} \).  
→ 이를 255로 맵핑하여 **영상 간 일관성** 확보.

---

## 8) 간단 테스트 스니펫

```cpp
// test_edges.cpp
#include <cassert>
#include "EdgeMasks.hpp"

int main(){
    // 1) 단색 이미지 → 0 응답
    IppDib img; img.create(64,64,32);
    for (int y=0;y<64;++y){
        uint8_t* d=(uint8_t*)img.bits()+y*img.stride();
        for (int x=0;x<64;++x) d[x*4+0]=d[x*4+1]=d[x*4+2]=128, d[x*4+3]=255;
    }
    EdgeOptions opt; opt.op=EdgeOperator::Sobel; opt.outMode=OutputMode::Magnitude8U;
    IppDib out; EdgeDetect(img,out,opt);
    // 중앙 샘플이 0(또는 근사 0)인지 확인
    uint8_t* p=(uint8_t*)out.bits() + 32*out.stride() + 32*4;
    assert(p[0]==0 && p[1]==0 && p[2]==0);

    // 2) 절반 스텝(좌 0, 우 255) → 수직 에지 검출
    for (int y=0;y<64;++y){
        uint8_t* d=(uint8_t*)img.bits()+y*img.stride();
        for (int x=0;x<32;++x) d[x*4+0]=d[x*4+1]=d[x*4+2]=0;
        for (int x=32;x<64;++x) d[x*4+0]=d[x*4+1]=d[x*4+2]=255;
    }
    EdgeDetect(img,out,opt);
    // 경계 열 부근 밝기가 큰지 대략 점검
    uint8_t* q=(uint8_t*)out.bits() + 32*out.stride() + 31*4;
    assert(q[0]>200);
    return 0;
}
```

---

## 9) 요약
- 엣지는 **그래디언트**의 크기/방향으로 정의되며, **3×3 마스크**(Prewitt/Sobel/Scharr)로 근사합니다.  
- 본 구현은 **경계 처리**, **정규화**, **임계**(Binary), **방향 맵**을 제공.  
- UI(대화 상자/메뉴)로 손쉽게 **연산자/크기모드/출력모드**를 바꾸어 시도할 수 있습니다.  
- 더 정교한 엣지(얇게·연속성 보장)는 **NMS/히스테리시스**(Canny)로 확장하세요.