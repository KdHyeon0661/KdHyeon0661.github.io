---
layout: post
title: DB 심화 - 비용 모델
date: 2025-11-15 22:25:23 +0900
category: DB 심화
---
# 비용 모델 완전 가이드
---

## 0) 항상 실측부터 (E-Rows/A-Rows, IO/CPU/Temp)

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'
));
```

- **Row Source별 E-Rows vs A-Rows**가 Cost 모델의 입력(카디널리티) 품질을 말해준다.
- **IOSTATS/MEMSTATS**는 Cost 모델이 “예상한 자원 소모”와 “실제 자원 소모”의 차이를 알려준다.
- Cost 모델을 이해하는 이유는 결국 **“예상 vs 실제가 어디서 갈라지는지”** 찾기 위해서다. :contentReference[oaicite:2]{index=2}

---

## 1) Cost 모델 큰 그림

Oracle Optimizer는 통계에 기반해 다음을 수행한다. :contentReference[oaicite:3]{index=3}

1. **Selectivity → Cardinality(E-Rows)** 추정  
2. 각 후보 플랜의 **I/O 비용 + CPU 비용 (+ 병렬/네트워크 보정)** 계산  
3. Cost가 최소인 플랜 선택

정리하면:

- **카디널리티가 Cost의 절반**이고,
- **시스템 통계가 Cost의 다른 절반**이다.

---

## 2) 시스템 통계(System Statistics) = Cost 감각(눈금)

### 2.1 NOWORKLOAD vs WORKLOAD

Oracle은 시스템 통계를 아래 모드로 수집한다. :contentReference[oaicite:4]{index=4}

- **NOWORKLOAD**: 무작위 I/O로 “기본 I/O 특성” 측정  
- **WORKLOAD**: 실제 부하 구간에서 “실제 워크로드 기반 I/O/CPU 특성” 측정  
- 기본은 NOWORKLOAD 기반 CPU Costing Model 사용. :contentReference[oaicite:5]{index=5}

```sql
BEGIN
  DBMS_STATS.GATHER_SYSTEM_STATS('NOWORKLOAD'); -- 기본/무부하
  -- 또는
  DBMS_STATS.GATHER_SYSTEM_STATS('WORKLOAD');   -- 대표 부하 구간
END;
/
```

### 2.2 대표 상수

AUX_STATS$/V$SYSSTAT 기반으로 다음을 사용한다. :contentReference[oaicite:6]{index=6}

- `SREADTIM` : Single-Block Read Time(ms)
- `MREADTIM` : Multi-Block Read Time(ms)
- `MBRC`     : 평균 Multi-Block Read Count(블록)
- `CPUSPEEDNW` 또는 `CPUSPEED` : CPU 속도

> NOWORKLOAD에서는 `IOSEEKTIM`/`IOTFRSPEED`를 먼저 측정하고  
> `SREADTIM/MREADTIM`을 내부식으로 **유도 계산**하는 구조다.  
> WORKLOAD는 `SREADTIM/MREADTIM/MBRC`를 직접 측정해 더 현실적이다. :contentReference[oaicite:7]{index=7}

### 2.3 Cost의 단위(정규화)

Cost는 대략

> **(예상 SBR 시간 + 예상 MBR 시간 + 예상 CPU 시간)**  
> 를 **SBR 시간 단위로 나눈 값**

즉

$$
\text{Cost} \approx 
\frac{T_{sbr} + T_{mbr} + T_{cpu}}{SREADTIM}
$$

이라는 관점으로 읽으면 된다. :contentReference[oaicite:8]{index=8}

---

## 3) I/O 비용 모델

### 3.1 기본 개념식

싱글/멀티블록 read 호출 수를 추정해 시간으로 바꾼다.

$$
\text{IO Time} \approx N_{sbr}\cdot SREADTIM + N_{mbr}\cdot MREADTIM
$$

멀티블록 호출 수는

$$
N_{mbr} \approx \left\lceil \frac{B}{MBRC}\right\rceil
$$

(B=읽을 블록 수). :contentReference[oaicite:9]{index=9}

---

### 3.2 Full Table Scan(FTS)

블록 수를 멀티블록으로 읽는다고 가정한다.

- 기본 형태(정규화된 Cost 관점):

$$
\text{Cost}_{FTS} \approx
\left\lceil\frac{B}{MBRC}\right\rceil\cdot\frac{MREADTIM}{SREADTIM} + 1
$$

(+1은 시작/오버헤드 상수). :contentReference[oaicite:10]{index=10}

**실습(의도적 FTS 후보)**

```sql
EXPLAIN PLAN FOR
SELECT /* fs */ COUNT(*)
FROM   OI
WHERE  AMOUNT >= 0;   -- 사실상 전량
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

관찰: `TABLE ACCESS FULL`의 Cost가 **MBRC/MREADTIM** 변화에 민감하게 움직인다.

---

### 3.3 Index Range Scan + Table Rowid access

Index 비용은 크게

1) **루트→브랜치→리프 트리 탐색**  
2) **선택된 리프 범위 읽기**  
3) **ROWID로 테이블 블록 랜덤 접근**

으로 쪼개진다.

#### (1) 트리 탐색 비용

대략

$$
N_{sbr}^{index\_traverse} \approx BLEVEL + 1
$$

(실제로는 캐싱/핫블록 보정이 들어간다).

#### (2) 리프 범위 비용

선택도·카디널리티에 따라 리프 블록 범위를 예측.

#### (3) 테이블 랜덤 접근 비용과 **클러스터링 팩터(CF)**

CF는 인덱스 순서와 테이블 물리 순서가 얼마나 맞는지의 지표다. :contentReference[oaicite:11]{index=11}

- CF ≈ **테이블 블록 수**면 “잘 정렬”  
- CF ≈ **테이블 행 수**면 “매우 랜덤”

CF가 높으면 같은 행 수를 가져와도  
**읽어야 할 테이블 블록 추정치가 증가** → Index 경로 Cost가 튀어 오른다. :contentReference[oaicite:12]{index=12}

**실습(스큐 값 vs 희소 값)**

```sql
-- 대량값: 리프 범위 + 테이블 랜덤 I/O 증가 → FTS/FFS로 기울 수 있음
EXPLAIN PLAN FOR
SELECT /* brand heavy */ COUNT(*)
FROM   PROD
WHERE  BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 희소값: Range Scan 유리
EXPLAIN PLAN FOR
SELECT /* brand rare */ COUNT(*)
FROM   PROD
WHERE  BRAND='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## 4) CPU 비용 모델

### 4.1 기본 개념식

Oracle은 각 단계(row source)에서

- “행 수 × 연산량 계수”  
을 CPU time으로 환산한다.

$$
\text{CPU Time} \approx 
\sum_k \big(\text{Rows}_k \cdot \text{CPUops/row}_k\big) \cdot \frac{1}{CPUSPEED}
$$

그리고 이 CPU Time을 SBR 단위 Cost로 정규화한다. :contentReference[oaicite:13]{index=13}

### 4.2 CPU가 커지는 대표 연산

- 복잡한 predicate/스칼라 함수 평가
- Hash Join/Hash Group By의 해시 계산·버킷 탐색
- Sort의 비교/교환(대략 \(n\log n\))
- DISTINCT/ORDER BY/윈도 함수

CPU 중심 작업이 많거나 MBR이 빠른 스토리지일수록  
Optimizer는 **CPU가 적은 플랜**을 선호할 수 있다.

---

## 5) 조인 비용 모델

조인 비용은

- **입력 카디널리티**
- **접근 경로(랜덤 vs 순차)**
- **Workarea(메모리)**
- **Spill(TEMP I/O) 가능성**

의 곱이다. :contentReference[oaicite:14]{index=14}

---

### 5.1 Nested Loops(NL)

#### 비용 직관

- Outer에서 나온 행마다 Inner를 반복 탐색  
- Inner가 index access라면 Outer 행 수만큼 **랜덤 SBR**이 발생

#### 개념식

$$
\text{Cost}_{NL} \approx
\text{Cost}_{outer}
+
\text{Card}_{outer}\cdot \text{Cost}_{inner\_per\_key}
$$

여기서 `inner_per_key`는 보통

- 인덱스 탐색(트리+리프)
- 테이블 ROWID 접근

의 합이며, CF가 높을수록 증가한다. :contentReference[oaicite:15]{index=15}

**실습**

```sql
EXPLAIN PLAN FOR
SELECT /* nl */ SUM(i.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
WHERE  c.region='KOR' AND c.tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

관찰:

- `c`의 E-Rows가 작게 나오면 NL이 급격히 유리해진다.
- E-Rows가 실제보다 과소 추정되면 **NL 오판(=랜덤 I/O 폭탄)** 이 흔하다.

---

### 5.2 Hash Join(HJ)

#### 비용 직관

1) Build 입력을 읽어 해시 테이블 생성  
2) Probe 입력 전체를 스캔하며 해시 탐색  
3) Build/Probe가 메모리를 넘으면 TEMP로 Spill

#### 개념식

$$
\text{Cost}_{HJ} \approx
\text{Cost}_{build\_scan}
+
\text{Cost}_{probe\_scan}
+
\text{Cost}_{spill\_temp}
$$

- `spill_temp`는 Workarea 크기, 입력 크기(카디널리티×rowlen)에 따라 추정된다. :contentReference[oaicite:16]{index=16}

**실습**

```sql
EXPLAIN PLAN FOR
SELECT /* hash */ SUM(i.amount)
FROM   OI i
JOIN   ORD o ON o.order_id = i.order_id
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

관찰:

- `HASH JOIN` 아래 `TEMP` 사용이 보이면 Spill이 난 것.
- Spill이 예측되면 HJ Cost가 급격히 올라 NL로 기울 수 있다.

---

### 5.3 Sort-Merge Join(SMJ)

- 기본적으로 **두 입력을 정렬한 뒤 병합**  
- 정렬 비용 + 병합 스캔 비용(순차 MBR)이 합산된다.

SMJ는

- 정렬이 이미 되어 있거나(인덱스/ORDER BY 제거)
- 매우 큰 입력이며 랜덤 I/O를 극도로 피해야 할 때

후보로 남는다.

---

## 6) Sort / Group By 비용 모델

### 6.1 Workarea가 충분할 때

- 비용은 거의 CPU(메모리 정렬) 중심
- Sort 단계의 I/O는 미미

### 6.2 Workarea가 부족할 때(Spill)

- TEMP로 run 파일 생성  
- multi-pass merge 발생  
- direct path read/write temp가 모델에 반영되며 Cost가 폭증한다. :contentReference[oaicite:17]{index=17}

**실습**

```sql
EXPLAIN PLAN FOR
SELECT /* sort */ c.region, COUNT(*)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
GROUP  BY c.region
ORDER  BY COUNT(*) DESC;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

관찰:

- `SORT GROUP BY` 또는 `SORT ORDER BY` 단계의 **E-Rows/A-Rows**, `TempSpc` 여부 확인.

---

## 7) 병렬(Parallel) Cost 보정

Oracle은 병렬 후보에 대해

- **데이터 분배 비용(Producer/Consumer, PX SEND/RECEIVE)**
- **PX Granule(블록/파티션 단위)**
- **DOP에 따른 wall-clock 단축 기대치**

를 Cost에 보정한다. :contentReference[oaicite:18]{index=18}

포인트:

- DOP가 높아도 **분배/동기화 오버헤드가 커지면** Cost가 오히려 증가할 수 있다.
- **카디널리티 오판이 있으면 병렬 여부 판단도 틀린다.**

---

## 8) 적응형/동적 기능이 Cost 모델에 끼치는 영향

### 8.1 Dynamic Statistics(구 Dynamic Sampling)

통계가 없거나 오판 위험이 크면  
Optimizer가 하드파스 중 샘플링으로 카디널리티를 보정한다. :contentReference[oaicite:19]{index=19}

- 장점: E-Rows 정확도↑ → Cost 품질↑  
- 단점: 하드파스 오버헤드↑

`NOTE`에서 Dynamic Statistics 사용 여부 확인 가능.

### 8.2 Adaptive Query Optimization / Statistics Feedback

실행 중 E-Rows≠A-Rows가 크면  
다음 실행에서 **통계 피드백/재최적화**로 Cost를 수정한다. :contentReference[oaicite:20]{index=20}

- 12c~19c에서 기능/범위/기본값이 여러 차례 조정되었다.
- 피드백이 계속 쌓이며 플랜이 요동하면  
  **근본 통계/SQL 구조 문제**를 먼저 해결해야 한다.

### 8.3 SQL Plan Directives(SPD)

Optimizer가 반복 오판을 감지하면  
SPD로 “이 컬럼/조인에 더 정교한 통계를 수집하라”는 지시를 남긴다.  
(Adaptive 통계 기능의 일부로 연결됨) :contentReference[oaicite:21]{index=21}

---

## 9) What-if 실험: 시스템 통계로 감각 바꾸기

> 학습/튜닝 실험용. 운영에선 실측 수집이 원칙.

```sql
-- (A) 멀티블록이 빠른 환경: FTS/Hash 선호
BEGIN
  DBMS_STATS.SET_SYSTEM_STATS('SREADTIM', 12);
  DBMS_STATS.SET_SYSTEM_STATS('MREADTIM', 6);
  DBMS_STATS.SET_SYSTEM_STATS('MBRC',     64);
END;
/

EXPLAIN PLAN FOR SELECT COUNT(*) FROM OI;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- (B) 싱글블록이 빠른 환경: Index/NL 선호
BEGIN
  DBMS_STATS.SET_SYSTEM_STATS('SREADTIM', 6);
  DBMS_STATS.SET_SYSTEM_STATS('MREADTIM', 12);
  DBMS_STATS.SET_SYSTEM_STATS('MBRC',     16);
END;
/

EXPLAIN PLAN FOR SELECT COUNT(*) FROM OI;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

관찰:

- 같은 SQL도 시스템 통계에 따라  
  **FFS/Index**, **HJ/NL** 선호가 바뀌는 것을 볼 수 있다. :contentReference[oaicite:22]{index=22}

---

## 10) Cost 모델을 흔드는 전역 파라미터(조심!)

대표적으로 다음이 Cost 감각을 바꾼다.

- `OPTIMIZER_INDEX_COST_ADJ`  
  - 인덱스 I/O 비용을 상대적으로 낮춰 **인덱스 선호**
- `OPTIMIZER_INDEX_CACHING`  
  - 캐시 히트 가정을 올려 랜덤 I/O를 덜 아프게 봄

전역 파라미터는 **전체 SQL의 Cost 눈금을 바꾸는 위험한 수술**이니  
가능하면

1) 통계/SQL 구조 교정  
2) 국지 힌트  
3) SQL Patch/Profile/Baseline

순으로 접근한다. :contentReference[oaicite:23]{index=23}

---

## 11) 플랜 안정화 도구와 Cost 모델의 관계

- **SQL Profile**: 카디널리티/Cost를 보정하는 힌트 집합
- **SQL Patch**: 특정 SQL에만 힌트를 주입
- **SQL Plan Baseline(SPM)**: 허용 플랜 집합을 관리해 Cost 변동에도 플랜을 고정 :contentReference[oaicite:24]{index=24}

Cost 모델은 항상 변할 수 있다(통계/시스템 변화).  
**안정화 도구는 그 변동을 “통제”하는 장치**다.

---

## 12) 당신의 스키마로 보는 “Cost가 갈라지는 지점” 종합 실습

### 12.1 선택도(스큐) → 경로 결정

```sql
EXPLAIN PLAN FOR
SELECT /* heavy brand */ COUNT(*)
FROM   PROD
WHERE  BRAND='B0';

EXPLAIN PLAN FOR
SELECT /* rare brand */ COUNT(*)
FROM   PROD
WHERE  BRAND='B47';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 히스토그램 덕분에 **값별 E-Rows가 달라지고**
- 그에 따라 Range Scan ↔ FTS가 갈린다.

### 12.2 카디널리티 → NL vs HJ 결정

```sql
-- 희소 Outer(고선택) 가정
EXPLAIN PLAN FOR
SELECT /* drive cust */ SUM(i.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
WHERE  c.region='KOR' AND c.tier='VIP';

-- 대량 조인 가정
EXPLAIN PLAN FOR
SELECT /* drive oi */ SUM(i.amount)
FROM   OI i
JOIN   ORD o ON o.order_id = i.order_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 첫 쿼리에서 `c` E-Rows가 작으면 NL 후보  
- 두 번째는 대량 입력이라 HJ 후보  
- **E-Rows 오판이 있으면 여기서 플랜이 뒤집힌다.**

### 12.3 Sort Spill 경계 확인

```sql
EXPLAIN PLAN FOR
SELECT /* sort test */ o.status, COUNT(*)
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
GROUP  BY o.status
ORDER  BY COUNT(*) DESC;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- `TempSpc`, `IOSTATS`, `MEMSTATS`로 Spill 여부 확인

---

## 13) 실전 진단–보정 루프(최종)

1. **실측 플랜**에서 E-Rows/A-Rows 괴리 지점 찾기  
2. 그 지점이  
   - 스큐(EQ 값별) → 히스토그램  
   - 상관(AND 결합) → 확장 통계  
   - 범위/시계열/파티션 → 파티션/증분/실시간 통계  
   - 조인 NDV 변화 → 통계/SQL 구조 재검토  
   - 통계 부재/복잡 술어 → Dynamic Statistics 허용  
   인지 분해  
3. **근본 교정 후**에도 남는 문제만  
   - CARDINALITY/OPT_ESTIMATE  
   - SQL Profile/Patch  
   - Baseline  
   로 국지 봉합

이 순서가 Cost 모델을 “정직하게” 만드는 가장 안전한 방법이다. :contentReference[oaicite:25]{index=25}

---

## 요약

- Oracle Cost는 **I/O 시간 + CPU 시간**을 **SBR 시간 단위로 정규화한 상대 지표**다. :contentReference[oaicite:26]{index=26}
- **시스템 통계(SREADTIM/MREADTIM/MBRC/CPUSPEED)** 가 Cost 눈금이고,  
  **카디널리티(E-Rows)** 가 Cost 입력량이다. :contentReference[oaicite:27]{index=27}
- **클러스터링 팩터(CF)** 는 인덱스 경로의 랜덤 I/O 추정치를 결정해  
  Index vs FTS, NL vs HJ 선택을 좌우한다. :contentReference[oaicite:28]{index=28}
- Workarea 부족으로 정렬/해시가 **Spill(TEMP I/O)** 하면 Cost가 폭증한다.
- 동적/적응형 기능은 Cost 오판을 “사후 교정”하지만,  
  **근본 통계/SQL 품질이 먼저**다. :contentReference[oaicite:29]{index=29}
- 전역 파라미터로 Cost 감각을 강제로 바꾸기 전에  
  **통계 정확화 → SQL 구조 개선 → 국지 힌트/안정화** 순으로 접근하라. :contentReference[oaicite:30]{index=30}