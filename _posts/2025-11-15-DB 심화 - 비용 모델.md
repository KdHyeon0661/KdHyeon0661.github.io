---
layout: post
title: DB 심화 - 비용 모델
date: 2025-11-15 22:25:23 +0900
category: DB 심화
---
# 비용(Cost) 모델 완전 가이드 — Oracle 기준

> 실행 후에는 항상 **실측 플랜/통계**로 확인하세요.
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'
));
```

---

## 0) 실습 데이터 & 기본 통계
```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

-- 깨끗이
BEGIN FOR t IN (SELECT table_name FROM user_tables
                WHERE table_name IN ('CUST','PROD','ORD','OI')) LOOP
  EXECUTE IMMEDIATE 'DROP TABLE '||t.table_name||' PURGE';
END LOOP; END;
/

-- 테이블
CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8),
  TIER    VARCHAR2(8)
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12),
  BRAND    VARCHAR2(12)
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  ORDER_DT DATE   NOT NULL,
  STATUS   VARCHAR2(8)
);

CREATE TABLE OI(
  ORDER_ID NUMBER NOT NULL,
  LINE_NO  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, LINE_NO)
);

-- 인덱스
CREATE INDEX IX_CUST_REGION      ON CUST(REGION, CUST_ID);
CREATE INDEX IX_PROD_CAT_BRAND   ON PROD(CATEGORY, BRAND, PROD_ID);
CREATE INDEX IX_ORD_CUST_DT      ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_OI_PROD          ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER         ON OI(ORDER_ID);

-- 데이터(스큐/분포)
BEGIN
  FOR c IN 1..30000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,6)
        WHEN 0 THEN 'KOR' WHEN 1 THEN 'KOR'
        WHEN 2 THEN 'APAC' WHEN 3 THEN 'EMEA'
        WHEN 4 THEN 'AMER' ELSE 'JPN' END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..12000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
                    WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 4000 THEN 'B0' ELSE 'B'||TO_CHAR(MOD(p,60)) END
    );
  END LOOP;

  FOR o IN 1..90000 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,30000)+1,
      DATE '2024-01-01' + MOD(o,240),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID'
                    WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR i IN 1..220000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,90000)+1,
      1 + MOD(i,3),
      MOD(i,12000)+1,
      1 + MOD(i,5),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;
  COMMIT;
END;
/

-- 기본 통계 + 스큐 컬럼 히스토그램
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'FOR COLUMNS SIZE 254 BRAND');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
END;
/
```

---

# 1. 비용 모델 큰 그림

Oracle의 **코스트**는 절대 시간(초)이 아니라 **상대 비용 지표**입니다. 옵티마이저는 각 실행계획 대안의
- **I/O 비용**(싱글블록/멀티블록/임시영역 I/O 기대량 × 시간),
- **CPU 비용**(행 처리·비교·해시·정렬 연산량 × CPU 주기),
- (필요 시 **네트워크/병렬** 보정)

을 합성해 **가장 작은 비용**의 플랜을 선택합니다.

핵심 입력은 **통계정보**와 **시스템 통계**입니다.

---

# 2. I/O 비용 모델

## 2.1 시스템 통계(System Stats)와 I/O 상수
`DBMS_STATS.GATHER_SYSTEM_STATS`(NOWORKLOAD/WORKLOAD)로 다음 값들을 채웁니다(버전에 따라 달리 보일 수 있음).

- `SREADTIM` : **Single-Block Read Time** (ms)  
- `MREADTIM` : **Multi-Block Read Time** (ms)  
- `MBRC`     : **평균 Multi-Block Read Count** (블록 수)  
- `CPUSPEEDNW` 또는 `CPUSPEED` : CPU 속도(백만 cycles/sec) — CPU 비용 섹션에서 사용

Oracle은 예상 **싱글블록 읽기 횟수**와 **멀티블록 읽기 횟수**를 추정해 각각 `SREADTIM`, `MREADTIM/MBRC`로 시간 비용을 만들고 더합니다.

### 간단한 개념식
$$
\text{IO Cost} \approx N_{sbr} \cdot \text{SREADTIM} \;+\; N_{mbr} \cdot \text{MREADTIM}
$$
여기서 \(N_{sbr}\)은 **싱글블록 read 호출 수**, \(N_{mbr}\)은 **멀티블록 read 호출 수**에 대한 옵티마이저의 추정입니다.
멀티블록 read 호출 수는 대략:
$$
N_{mbr} \approx \frac{\text{읽을 블록 수}}{\text{MBRC}}
$$

> 참고: 최신 버전은 내부적으로 더 정교한 상수/보정(스토리지/버퍼 캐시/병렬)도 가집니다.

## 2.2 액세스 경로별 I/O 호출 추정

### (1) **Table Full Scan**
- 블록 수 \(B\)를 **멀티블록**으로 읽는다고 가정:
  $$N_{mbr} \approx \lceil B / \text{MBRC} \rceil$$
- 비용 ~ \(N_{mbr} \cdot \text{MREADTIM}\)

**실습: Full Scan 후보**
```sql
EXPLAIN PLAN FOR
SELECT /* fs */ COUNT(*)
FROM   OI
WHERE  AMOUNT >= 0;  -- 모든 행 대상(조건 무의미)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### (2) **Index Range Scan + Table Access by ROWID**
- 인덱스 트리 탐색 비용(루트→브랜치→리프) + 선택된 **리프 범위** 읽기
- **테이블 랜덤 접근**(ROWID) **싱글블록** 읽기 횟수는 **카디널리티**와 **클러스터링 팩터(CF)**에 의존  
  - CF가 **높을수록**(테이블 물리 순서가 인덱스 순서와 **불일치**) 랜덤 접근 블록 수가 **증가**

**개념**
- Index traversal: 대략 **BLEVEL + ε** 싱글블록
- Table random I/O: 대략 **min(선택 행수, 테이블 블록 수 × CF 계수)** 싱글블록

**실습: 대량값 vs 희소값**
```sql
EXPLAIN PLAN FOR
SELECT /* brand heavy */ COUNT(*)
FROM   PROD
WHERE  BRAND='B0';   -- 대량값 → 리프 범위 큼 → 테이블 랜덤 I/O 급증 → FFS 유리 가능
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT /* brand rare */ COUNT(*)
FROM   PROD
WHERE  BRAND='B47';  -- 희소값 → 인덱스 유리
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### (3) **Nested Loops Join (NL)**
- **Outer**에서 나온 각 키마다 **Inner**를 인덱스로 찾아 **싱글블록** 랜덤 I/O 발생  
- Inner 인덱스 CF가 높으면 랜덤 블록 증가 → NL 비용 ↑

**실습**
```sql
EXPLAIN PLAN FOR
SELECT /* nl */ SUM(i.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
WHERE  c.region='KOR' AND c.tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### (4) **Hash Join (HJ)**
- **Build 입력**을 읽어 해시 테이블 생성, **Probe 입력**으로 조인 탐색  
- 메모리가 부족하면 **TEMP**에 **Spill** → **direct path read/write temp** 비용 반영  
- I/O 비용은 **입력 읽기 + Spill I/O**가 주

**실습**
```sql
EXPLAIN PLAN FOR
SELECT /* hash */ SUM(i.amount)
FROM   OI i
JOIN   ORD o ON o.order_id = i.order_id
WHERE  o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### (5) **Sort / Group By**
- Workarea(정렬영역)가 충분하면 메모리에서 수행(거의 CPU 비용)  
- 부족하면 **TEMP**로 **run** 파일을 만들고 **multi-pass merge** → I/O 비용 급증

**실습**
```sql
ALTER SESSION SET workarea_size_policy = AUTO;
-- (환경에 따라) 큰 정렬 유도
EXPLAIN PLAN FOR
SELECT /* sort */ c.region, COUNT(*)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
GROUP  BY c.region
ORDER  BY COUNT(*) DESC;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 2.3 시스템 통계 조작으로 “FFS 선호 vs 인덱스 선호” 느껴보기

> 아래 값은 **실험용**입니다. 실제 운영에서는 NOWORKLOAD/WORKLOAD로 측정 값을 사용하세요.

```sql
-- ① 멀티블록 읽기(MREADTIM)가 상대적으로 매우 빠른 환경(FFS 선호)
BEGIN
  DBMS_STATS.SET_SYSTEM_STATS('SREADTIM', 12);  -- ms(예)
  DBMS_STATS.SET_SYSTEM_STATS('MREADTIM', 6);   -- 멀티블록이 더 빠르다
  DBMS_STATS.SET_SYSTEM_STATS('MBRC',     64);  -- 평균 멀티블록 크기
END;
/

EXPLAIN PLAN FOR SELECT COUNT(*) FROM OI;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- ② 싱글블록 읽기가 상대적으로 빠른 환경(인덱스 선호)
BEGIN
  DBMS_STATS.SET_SYSTEM_STATS('SREADTIM', 6);
  DBMS_STATS.SET_SYSTEM_STATS('MREADTIM', 12);
  DBMS_STATS.SET_SYSTEM_STATS('MBRC',     16);
END;
/

EXPLAIN PLAN FOR SELECT COUNT(*) FROM OI;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**관찰 포인트**  
- 같은 쿼리라도 시스템 통계에 따라 **FFS ↔ 인덱스** 선택이 바뀔 수 있습니다.  
- 조인에서도 **HJ ↔ NL** 선호가 변할 수 있습니다(랜덤 I/O 비용 상대값 변화).

---

# 3. CPU 비용 모델

## 3.1 시스템 통계와 CPU 상수
- `CPUSPEEDNW`(또는 `CPUSPEED`)는 초당 CPU 사이클(백만 cycles/sec) 추정값.  
- Oracle은 **연산량**(행수 × 연산계수)을 **CPU 사이클**로 환산해 CPU 시간 비용을 근사합니다.

**개념식**
$$
\text{CPU Cost} \approx \sum_{k} \big(\text{Rows}_k \times \text{CPU\_ops\_per\_row}_k\big) \cdot \frac{1}{\text{CPUSPEED}}
$$

여기서 \(k\)는 Row Source 단계(필터, 조인, 정렬, 해시 등)입니다.

## 3.2 연산별 대략의 CPU 작업
- **Predicate 평가**: 각 행마다 비교/함수 계산(스칼라 함수일수록 CPU↑)  
- **Hash Join/Group**: 해시 함수 계산 + 버킷/체인 탐색  
- **Sort**: 비교/교환 → 대략 \(O(n \log n)\) 비교  
- **Projection**: 표현식/함수 계산  
- **Row Source 사이 전달**: 오버헤드

## 3.3 CPU 비용이 플랜에 미치는 영향
I/O가 비슷한 대안이라면, CPU가 더 적은 플랜이 선택됩니다. 예를 들어,
- 매우 작은 집합끼리의 조인에서 **NL**이 CPU상 유리  
- 대용량 집합 정렬 vs 해시 집계에서 **Hash Group By**가 CPU상 유리(분포/충돌에 좌우)

**실습: 해시 vs 소트 집계**
```sql
-- 환경/버전에 따라 다르지만, 해시 집계가 선호될 때가 많다
EXPLAIN PLAN FOR
SELECT /* hash grp */ PROD_ID, SUM(QTY)
FROM   OI
GROUP  BY PROD_ID;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 3.4 정렬 영역과 CPU/I-O 상호작용
- 메모리가 충분하면 정렬은 거의 **CPU 비용**(메모리 내)  
- 부족하면 **TEMP I/O**가 발생해 I/O 비용까지 급증 → 옵티마이저는 “예상 메모리”로 어느 정도 반영

**팁**: `PGA_AGGREGATE_TARGET`/`PGA_AGGREGATE_LIMIT`/`workarea_size_policy`가 빡빡하면 **정렬/해시**가 자주 디스크로 넘어가 비용이 커집니다.

---

# 4. “I/O vs CPU” 비용의 상호작용 — 대표 시나리오

## 4.1 **대량 스캔 보고서**
- 후보A: **FFS + Hash Group By** (멀티블록 I/O + 해시 CPU)  
- 후보B: **Index Range Scan + NL** (랜덤 I/O 다수 + 비교 CPU 증가)  
→ **MREADTIM 낮고 MBRC 큰** 환경이면 A가, **SREADTIM 낮은** 환경이면 B가 유리

**실습**
```sql
-- 전체 라인 집계
EXPLAIN PLAN FOR
SELECT /* rpt */ p.category, SUM(i.amount)
FROM   OI i
JOIN   PROD p ON p.prod_id = i.prod_id
GROUP  BY p.category;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 4.2 **선택도 높은 OLTP 조회**
- 후보A: 인덱스 접근 + 소수 행만 테이블 랜덤 I/O  
- 후보B: 풀스캔  
→ 조건이 “희소”이고 CF가 낮으면 A가 유리(랜덤 I/O 적음 + CPU 적음)

**실습**
```sql
EXPLAIN PLAN FOR
SELECT /* oltp */ order_id, order_dt
FROM   ORD
WHERE  cust_id = 12345
AND    order_dt >= DATE '2024-05-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 4.3 **정렬/해시 Spill 경계**
- 메모리가 애매하면 옵티마이저가 **Spill 가능성**을 반영해 HJ/Hash Group By를 덜 선호할 수 있음  
- 이런 케이스는 **workarea** 관련 설정을 조정하거나 **통계/카디널리티**를 정확히 만들어 해결

---

# 5. 비용 감각을 조정하는 도구

## 5.1 시스템 통계 수집/설정
```sql
-- 실측 기반(권장)
BEGIN
  DBMS_STATS.GATHER_SYSTEM_STATS('NOWORKLOAD'); -- 또는 WORKLOAD(운영 대표 구간)
END;
/

-- 실험/학습용 What-if
BEGIN
  DBMS_STATS.SET_SYSTEM_STATS('SREADTIM', 8);
  DBMS_STATS.SET_SYSTEM_STATS('MREADTIM', 5);
  DBMS_STATS.SET_SYSTEM_STATS('MBRC',     64);
  DBMS_STATS.SET_SYSTEM_STATS('CPUSPEEDNW', 2500);
END;
/

SELECT sname, pname, pval1
FROM   sys.aux_stats$
WHERE  sname IN ('SYSSTATS_MAIN','SYSSTATS_INFO')
ORDER  BY sname, pname;
```

## 5.2 옵티마이저 튜닝 파라미터(주의깊게)
- `OPTIMIZER_INDEX_COST_ADJ` : 인덱스 경로의 **I/O 비용 가중치**를 낮춰 **인덱스 선호**  
- `OPTIMIZER_INDEX_CACHING`  : 인덱스/테이블 블록 **캐시 히트 가정**을 상향 → **랜덤 I/O 비용 축소**  
> 운영 전체를 흔드는 전역 파라미터입니다. **특정 SQL**엔 힌트/프로파일/베이스라인으로 국지적으로 조정하는 편이 안전합니다.

## 5.3 힌트로 국지 제어(최소 사용)
```sql
-- 해시 vs NL vs SMJ
SELECT /*+ USE_HASH(p) */ ...
SELECT /*+ USE_NL(p)   */ ...
SELECT /*+ USE_MERGE(p)*/ ...

-- 스캔 경로 제어
SELECT /*+ FULL(t)      */ ...
SELECT /*+ INDEX(t idx) */ ...
SELECT /*+ INDEX_FFS(t) */ ...

-- 조인 순서
SELECT /*+ ORDERED LEADING(c o i p) */ ...
```

---

# 6. 비용 모델을 눈으로 보기 — 체계적 실습

## 6.1 FFS ↔ 인덱스 경계
```sql
-- (A) 대량값: FFS/Index FFS 쪽일 가능성
EXPLAIN PLAN FOR
SELECT /* heavy */ COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- (B) 희소값: Range Scan 유리
EXPLAIN PLAN FOR
SELECT /* rare */ COUNT(*) FROM PROD WHERE BRAND='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 시스템 통계를 바꾸고 다시 실행(2.3절 스니펫 활용)
```

## 6.2 NL ↔ HJ 경계(랜덤 I/O vs 순차 I/O + CPU)
```sql
-- 선택도 높은 Outer + 좋은 인덱스 Inner → NL 유리
EXPLAIN PLAN FOR
SELECT /* nl test */ SUM(i.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
WHERE  c.region='KOR' AND c.tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 대량 집합 조인 + 정렬/해시 메모리 충분 → HJ 유리
EXPLAIN PLAN FOR
SELECT /* hj test */ SUM(i.amount)
FROM   OI i
JOIN   ORD o ON o.order_id = i.order_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## 6.3 Sort Spill 경계(메모리 부족 시 I/O 전환)
```sql
-- 환경에 따라 TEMP I/O가 생기는지 +IOSTATS로 확인
EXPLAIN PLAN FOR
SELECT /* big sort */ o.status, COUNT(*)
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
GROUP  BY o.status
ORDER  BY COUNT(*) DESC;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

# 7. 실전 체크리스트

### 통계/카디널리티
- [ ] 히스토그램(도수/Top-Frequency/Hybrid)로 **스큐 반영**  
- [ ] 확장 통계(컬럼 그룹)로 **결합 선택도** 보정  
- [ ] 인덱스 **CLUSTERING_FACTOR** 확인(랜덤 I/O 예측)

### 시스템 통계
- [ ] 하드웨어/스토리지 변경 후 **NOWORKLOAD/WORKLOAD 수집**  
- [ ] `SREADTIM/MREADTIM/MBRC/CPUSPEED` 값이 현실적인지 점검

### Workarea/메모리
- [ ] `workarea_size_policy=auto` + `PGA_AGGREGATE_TARGET` 적절성  
- [ ] 정렬/해시 Spill 징후(Temp I/O 증가) 관찰

### 플랜 제어
- [ ] 힌트는 **최소한/국지적**으로만  
- [ ] 중요 SQL은 **SQL Plan Baseline/Profile**로 **안정화**

### 파라미터
- [ ] `OPTIMIZER_INDEX_COST_ADJ/OPTIMIZER_INDEX_CACHING` 전역 조정은 신중  
- [ ] 필요 시 **세션/SQL Patch**로 제한 적용

---

# 8. 부록 — 자주 쓰는 관찰 SQL

```sql
-- 1) 시스템 통계 확인
SELECT sname, pname, pval1
FROM   sys.aux_stats$
WHERE  sname IN ('SYSSTATS_MAIN','SYSSTATS_INFO')
ORDER  BY sname, pname;

-- 2) 인덱스 지표(리프/CF/NDV)
SELECT index_name, blevel, leaf_blocks, distinct_keys, clustering_factor, num_rows, last_analyzed
FROM   user_indexes
WHERE  table_name IN ('ORD','OI','PROD');

-- 3) 실행 계획 실측(행/IO/메모리)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```

---

## 요약
- **I/O 비용**은 **예상 싱글/멀티블록 읽기 호출 수** × **SREADTIM/MREADTIM**의 합, **CPU 비용**은 각 Row Source의 **연산량 × 1/CPUSPEED**의 합으로 근사합니다.  
- **히스토그램/확장 통계**로 **카디널리티**를 바로잡아야 **I/O 호출 수 추정**이 정확해집니다.  
- **시스템 통계**(SREADTIM/MREADTIM/MBRC/CPUSPEED)가 **하드웨어 현실**과 어긋나면 플랜 선택이 뒤틀립니다.  
- **정렬/해시 메모리**는 CPU 비용을 I/O 비용으로 바꿔버릴 수 있는 **전환점**입니다.  
- 전역 파라미터로 억지로 비용 감각을 바꾸기보다, **통계 정확화 → SQL 구조 개선 → 최소 힌트/베이스라인** 순으로 접근하는 것이 **안정적인 고성능**의 정석입니다.