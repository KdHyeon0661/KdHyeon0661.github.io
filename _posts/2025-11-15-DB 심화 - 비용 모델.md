---
layout: post
title: DB 심화 - 비용 모델
date: 2025-11-15 22:25:23 +0900
category: DB 심화
---
# Oracle 비용 모델 완전 분석: 옵티마이저가 선택을 내리는 법칙

## 항상 실제 실행 통계부터 시작하라

비용 모델을 이해하기 위한 첫걸음은 추상적인 이론이 아닌, 구체적인 실행 통계를 관찰하는 것입니다.

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'
));
```

이 쿼리는 실행 계획에서 가장 중요한 두 가지 대조를 보여줍니다:

1. **예상 행 수(E-Rows) vs 실제 행 수(A-Rows)**: 비용 모델이 데이터 분포를 얼마나 정확히 이해하고 있는지 나타냅니다. 두 수치가 크게 다르다면 통계 정보가 부정확하거나 옵티마이저가 데이터 상관관계를 놓치고 있을 가능성이 큽니다.

2. **예상 자원 사용량 vs 실제 자원 사용량**: I/O와 메모리 소비량의 차이는 비용 모델이 시스템 특성을 올바르게 반영하고 있는지 알려줍니다. 특히 디스크 I/O 대신 메모리에서 처리되는 작업이나, 예상치 못한 임시 공간 사용은 비용 계산의 근본적 오류를 의미할 수 있습니다.

실제 데이터와의 이 간극을 이해하는 것이 비용 모델 학습의 진정한 목적입니다. 비용 모델은 결국 예측 도구이며, 그 예측이 현실과 얼마나 부합하는지가 핵심입니다.

## 비용 모델의 전체적 구조: 세 가지 결정 단계

Oracle 옵티마이저는 질의 처리 계획을 선택할 때 세 단계의 논리적 계산을 거칩니다:

1. **선택도와 카디널리티 추정**: 각 연산 단계에서 처리될 행의 수를 예측합니다. 이는 통계 정보와 조건식의 특성을 기반으로 계산됩니다.

2. **자원 소비 비용 계산**: 예상된 작업량을 처리하는 데 필요한 I/O, CPU, 메모리 사용량을 산정합니다. 이때 시스템 통계가 기준이 됩니다.

3. **최적 계획 선택**: 가능한 모든 실행 경로의 비용을 비교하여 가장 효율적인 하나를 선택합니다.

이 과정에서 가장 중요한 통찰은 **카디널리티 추정의 정확성이 전체 비용 계산의 절반을 결정한다**는 점입니다. 나머지 절반은 시스템의 물리적 특성(I/O 속도, CPU 성능 등)을 얼마나 정확히 반영하는지에 달려 있습니다.

## 시스템 통계: 비용의 눈금을 조정하는 척도

시스템 통계는 추상적인 '비용' 숫자에 실제 물리적 의미를 부여합니다. Oracle은 두 가지 방식으로 시스템 성능 특성을 측정합니다:

```sql
-- 무부하 상태에서의 기본 성능 측정
BEGIN
  DBMS_STATS.GATHER_SYSTEM_STATS('NOWORKLOAD');
END;
/

-- 실제 운영 부하 하에서의 성능 측정 (권장)
BEGIN
  DBMS_STATS.GATHER_SYSTEM_STATS('WORKLOAD');
END;
/
```

NOWORKLOAD 방식은 인위적인 테스트를 통해 기본 I/O 특성을 측정하는 반면, WORKLOAD 방식은 실제 운영 환경에서의 성능 데이터를 수집합니다. WORKLOAD 통계는 실제 사용 패턴과 시스템 부하를 반영하므로 더 정확한 비용 예측을 가능하게 합니다.

### 핵심 시스템 통계 값들:

- **SREADTIM**: 단일 블록 읽기에 걸리는 평균 시간(밀리초)
- **MREADTIM**: 다중 블록 읽기(풀스캔)에 걸리는 평균 시간
- **MBRC**: 한 번의 다중 블록 읽기 작업에서 읽는 평균 블록 수
- **CPUSPEED**: CPU 처리 속도(초당 처리할 수 있는 표준 연산 수)

이 값들이 모여 비용의 단위를 정의합니다. Oracle의 비용은 기본적으로 **"SREADTIM 시간 단위로 표준화된 총 예상 실행 시간"** 으로 이해할 수 있습니다:

```
총 비용 ≈ (예상 단일블록 I/O 시간 + 예상 다중블록 I/O 시간 + 예상 CPU 처리 시간) / SREADTIM
```

이 공식은 비용이 절대적인 시간이 아니라, 시스템의 기본 I/O 단위에 상대적인 값임을 보여줍니다.

## I/O 비용 모델: 디스크 접근의 경제학

### 전체 테이블 스캔(Full Table Scan) 비용

전체 테이블 스캔의 비용은 주로 다중 블록 읽기 효율에 의해 결정됩니다:

```
FTS 비용 ≈ (테이블 블록 수 / MBRC) × (MREADTIM / SREADTIM) + 고정 오버헤드
```

이 공식에서 MBRC 값이 크고 MREADTIM이 SREADTIM에 비해 작을수록(즉, 순차 읽기가 랜덤 읽기에 비해 매우 빠를수록) 전체 테이블 스캔의 비용은 낮아집니다. 반대로 SSD 기반 시스템처럼 랜덤 읽기가 빠른 환경에서는 인덱스 스캔이 상대적으로 유리해집니다.

**실습: 시스템 특성에 따른 스캔 방식 변화**

```sql
-- SSD 환경 설정 (랜덤 I/O가 빠른 경우)
BEGIN
  DBMS_STATS.SET_SYSTEM_STATS('SREADTIM', 2);   -- 단일 블록 읽기 2ms
  DBMS_STATS.SET_SYSTEM_STATS('MREADTIM', 10);  -- 다중 블록 읽기 10ms
  DBMS_STATS.SET_SYSTEM_STATS('MBRC', 32);      -- 한 번에 32블록 읽음
END;
/

EXPLAIN PLAN FOR 
SELECT COUNT(*) FROM 대용량_테이블 WHERE 조건;
-- 결과: 인덱스 스캔 선호

-- HDD 환경 설정 (순차 I/O가 상대적으로 빠른 경우)  
BEGIN
  DBMS_STATS.SET_SYSTEM_STATS('SREADTIM', 8);   -- 단일 블록 읽기 8ms
  DBMS_STATS.SET_SYSTEM_STATS('MREADTIM', 15);  -- 다중 블록 읽기 15ms
  DBMS_STATS.SET_SYSTEM_STATS('MBRC', 128);     -- 한 번에 128블록 읽음
END;
/

EXPLAIN PLAN FOR
SELECT COUNT(*) FROM 대용량_테이블 WHERE 조건;
-- 결과: 전체 테이블 스캔 선호
```

### 인덱스 범위 스캔 비용

인덱스를 통한 데이터 접근 비용은 세 가지 요소로 구성됩니다:

1. **인덱스 트리 탐색**: B-Tree의 루트에서 리프 노드까지 내려가는 비용
2. **리프 노드 범위 스캔**: 조건에 맞는 키 값을 찾기 위해 리프 노드를 스캔하는 비용
3. **테이블 랜덤 접근**: 인덱스에서 찾은 ROWID로 테이블 블록을 접근하는 비용

이 중에서 가장 변동성이 크고 중요한 요소가 **클러스터링 팩터(Clustering Factor)** 입니다. 클러스터링 팩터는 인덱스 키의 논리적 순서와 테이블 행의 물리적 저장 순서가 얼마나 일치하는지를 나타내는 지표입니다.

- **클러스터링 팩터 ≈ 테이블 블록 수**: 인덱스 순서대로 테이블을 읽을 때 대부분의 블록을 한 번씩만 방문함 (효율적)
- **클러스터링 팩터 ≈ 테이블 행 수**: 인덱스 순서대로 테이블을 읽을 때 거의 매 행마다 다른 블록을 방문함 (비효율적)

클러스터링 팩터가 나쁘면 인덱스 스캔의 테이블 접근 비용이 급격히 증가하여, 전체 테이블 스캔보다도 비효율적일 수 있습니다.

## CPU 비용 모델: 숨은 연산 비용 계산

I/O 비용이 눈에 띄는 반면, CPU 비용은 종종 간과되지만 같은 중요성을 가집니다. Oracle은 각 연산 단계에서의 CPU 처리 비용을 다음과 같이 모델링합니다:

```
CPU 비용 ≈ Σ(각 단계의 처리 행 수 × 행당 CPU 연산량) / CPUSPEED
```

CPU 비용이 크게 증가하는 대표적인 작업들:

1. **복잡한 조건식 평가**: 정규표현식, 사용자 정의 함수, 복잡한 CASE 문
2. **해시 기반 연산**: 해시 조인, 해시 그룹 바이의 해시 함수 계산
3. **정렬 작업**: ORDER BY, GROUP BY, 윈도우 함수의 정렬 단계
4. **데이터 변환**: 암시적 형변환, 문자 집합 변환

CPU 성능이 우수하거나 I/O가 상대적으로 느린 시스템에서는 옵티마이저가 CPU 집약적인 연산을 선호할 수 있습니다. 예를 들어, 메모리 내 해시 조인이 디스크 I/O를 줄여주는 경우가 많습니다.

## 조인 비용 모델: 데이터 결합의 경제학

### 중첩 루프 조인(Nested Loops)

중첩 루프 조인의 비용 모델은 직관적입니다:

```
NL 비용 ≈ 외부 테이블 접근 비용 + (외부 테이블 행 수 × 내부 테이블 단일 키 접근 비용)
```

이 모델에서 핵심은 **외부 테이블의 행 수 추정 정확도**입니다. 외부 테이블 행 수가 적게 추정되면 NL 조인이 과도하게 선호되어, 실제 실행 시 '랜덤 I/O 폭탄'이 될 수 있습니다. 반대로 외부 테이블 행 수가 실제보다 많이 추정되면 NL 조인이 불필요하게 회피될 수 있습니다.

**NL 조인 최적화 사례:**

```sql
-- 잘 설계된 NL 조인: 외부 테이블이 작고 선택적 인덱스가 있는 경우
SELECT /*+ LEADING(c) USE_NL(o) USE_NL(i) */ 
       SUM(i.amount)
FROM   고객 c
JOIN   주문 o ON o.고객번호 = c.고객번호
JOIN   주문상세 i ON i.주문번호 = o.주문번호
WHERE  c.지역 = '서울' 
AND    c.등급 = 'VIP'
AND    c.가입일 >= DATE '2023-01-01';
```

### 해시 조인(Hash Join)

해시 조인 비용은 더 복잡한 요소들을 고려합니다:

```
해시 조인 비용 ≈ 빌드 입력 스캔 비용 + 프로브 입력 스캔 비용 + 해시 테이블 생성 비용 + 임시 공간 사용 비용
```

해시 조인의 가장 큰 변수는 **워크에리아(Workarea) 메모리 크기**입니다. 메모리가 충분하면 모든 작업이 메모리에서 이루어지지만, 메모리가 부족하면 임시 테이블스페이스로 스필(spill)이 발생하며 비용이 급증합니다.

해시 조인이 선호되는 조건:
- 조인 입력이 크고 정렬되지 않은 경우
- 등가 조인(=) 조건인 경우
- 충분한 메모리가 확보될 수 있는 경우

### 정렬 병합 조인(Sort-Merge Join)

정렬 병합 조인은 두 입력을 모두 정렬한 후 병합하는 방식입니다:

```
SMJ 비용 ≈ 첫 번째 입력 정렬 비용 + 두 번째 입력 정렬 비용 + 병합 스캔 비용
```

정렬 병합 조인의 비용은 주로 정렬 작업의 효율성에 의해 결정됩니다. 이미 정렬된 데이터(인덱스 스캔 결과)를 사용하거나 정렬이 불필요한 경우에 효율적입니다.

## 정렬 및 그룹화 비용 모델

정렬 작업의 비용은 사용 가능한 메모리 양에 크게 의존합니다:

1. **메모리 내 정렬**: 충분한 워크에리아 메모리가 있을 때는 주로 CPU 비용만 발생
2. **디스크 정렬(스필)**: 메모리가 부족할 때는 임시 테이블스페이스 사용으로 인한 추가 I/O 비용 발생

```
정렬 비용 ≈ 행 수 × log(행 수) × 행당 비교 비용 + 스필 I/O 비용
```

스필이 발생하면 비용이 급격히 증가하므로, 옵티마이저는 가능한 한 메모리 내 정렬을 시도합니다. `PGA_AGGREGATE_TARGET` 파라미터를 적절히 설정하는 것이 중요합니다.

**정렬 최적화 실습:**

```sql
-- 메모리 부족으로 스필 발생 가능성 있는 쿼리
EXPLAIN PLAN FOR
SELECT 고객지역, COUNT(*) as 주문수, SUM(금액) as 총금액
FROM   주문
WHERE  주문일자 >= DATE '2024-01-01'
GROUP  BY 고객지역
ORDER  BY 총금액 DESC;

-- 실행 계획에서 다음 확인:
-- 1. TempSpc 예상 사용량
-- 2. Sort 단계의 E-Rows 정확도
-- 3. 실제 실행 시 메모리 사용량
```

## 병렬 처리 비용 모델

병렬 실행의 비용 모델은 단일 스레드 실행과 몇 가지 중요한 차이점이 있습니다:

1. **데이터 분배 오버헤드**: 생산자(Producer)와 소비자(Consumer) 간 데이터 전송 비용
2. **동기화 오버헤드**: 병렬 작업자 간 조정에 필요한 추가 비용
3. **처리 시간 단축 효과**: 다중 CPU 코어를 활용한 시간 단축

```
병렬 비용 ≈ (단일 스레드 비용 / 병렬도) + 분배/동기화 오버헤드
```

병렬도가 높을수록 이론적 처리 시간은 줄어들지만, 분배와 동기화 오버헤드가 증가합니다. 최적의 병렬도는 데이터 크기, 시스템 리소스, 쿼리 특성에 따라 달라집니다.

## 적응형 최적화 기능이 비용 모델에 미치는 영향

### 동적 통계(Dynamic Statistics)

통계 정보가 부족하거나 오래된 경우, 옵티마이저는 실행 계획 수립 시점에 샘플링을 수행하여 보다 정확한 카디널리티를 추정할 수 있습니다:

```sql
-- 동적 통계 사용 확인
EXPLAIN PLAN FOR
SELECT /*+ DYNAMIC_SAMPLING(4) */ *
FROM   대용량_테이블
WHERE  복잡한_조건식;

-- 실행 계획의 NOTE 섹션에서 확인:
-- - dynamic statistics used: ...
```

동적 통계는 하드 파싱 시간을 증가시키지만, 부정확한 통계로 인한 비용 추정 오류를 줄여줍니다.

### 적응형 쿼리 최적화

12c부터 도입된 적응형 최적화 기능들은 실행 중 수집된 정보를 활용하여 비용 모델을 보정합니다:

1. **통계 피드백(Statistics Feedback)**: 실제 실행 결과(E-Rows vs A-Rows)를 다음 실행 시 반영
2. **적응형 조인 방법(Adaptive Join Methods)**: 실행 중 조인 방법을 동적으로 변경
3. **적응형 병렬 처리(Adaptive Parallelism)**: 데이터 분포에 따라 병렬도를 조정

이러한 기능들은 옵티마이저의 학습 능력을 향상시키지만, 지나치게 자주 실행 계획이 변경되는 '플랜 불안정성'을 초래할 수도 있습니다.

## 비용 모델 조정 파라미터: 신중한 사용이 필요

Oracle은 비용 모델의 특정 측면을 조정할 수 있는 파라미터들을 제공하지만, 이들은 전역적 영향을 미치므로 신중하게 사용해야 합니다:

```sql
-- 인덱스 비용 조정 (값이 작을수록 인덱스 선호도 증가)
ALTER SESSION SET OPTIMIZER_INDEX_COST_ADJ = 50;

-- 인덱스 캐싱 가정 조정 (값이 클수록 인덱스 블록 캐시 히트율을 높게 가정)
ALTER SESSION SET OPTIMIZER_INDEX_CACHING = 90;
```

이러한 파라미터 조정은 일시적인 해결책일 뿐, 근본적인 문제(부정확한 통계, 비효율적인 스키마 설계, 비효율적인 SQL)를 해결하지는 못합니다. 가능하면 통계 정확성 향상과 SQL 최적화를 우선시해야 합니다.

## 실행 계획 안정화 도구와의 관계

비용 모델의 변화로 인한 실행 계획 불안정성을 해결하기 위한 도구들:

1. **SQL 프로파일(SQL Profile)**: 특정 SQL에 대한 통계/비용 보정 정보
2. **SQL 패치(SQL Patch)**: SQL에 힌트를 주입하는 메타데이터
3. **SQL 계획 관리(SQL Plan Management)**: 허용된 실행 계획 집합을 관리

이들 도구는 비용 모델의 불완전성을 보완하는 안전장치 역할을 합니다. 특히 운영 환경에서 예상치 못한 실행 계획 변경으로 인한 성능 저하를 방지하는 데 유용합니다.

## 종합 진단 프레임워크: 실제 문제 해결을 위한 체계적 접근

비용 모델 관련 문제를 진단하고 해결하는 체계적인 접근법:

### 1단계: 문제 식별

```sql
-- 문제가 의심되는 SQL의 실제 실행 통계 수집
VAR rc REFCURSOR

BEGIN
    DBMS_SQL_MONITOR.REPORT_SQL_MONITOR(
        sql_id => '문제_SQL_ID',
        type => 'ACTIVE',
        report_level => 'ALL',
        cursor => :rc
    );
END;
/

PRINT rc
```

### 2단계: 근본 원인 분석

실행 계획에서 E-Rows와 A-Rows의 괴리가 발생하는 지점을 찾아 근본 원인을 분류합니다:

- **데이터 스큐 문제**: 특정 값의 분포가 극단적일 때 → 히스토그램 통계 필요
- **컬럼 상관관계 문제**: 여러 컬럼 조건이 통계적으로 상관관계 있을 때 → 확장 통계 필요
- **복잡 조건식 문제**: 함수 기반 조건이나 복잡한 표현식 → 동적 통계나 함수 기반 인덱스 고려
- **조인 카디널리티 문제**: 조인 결과 행 수 오판 → 조인 통계 재수집 또는 SQL 재작성

### 3단계: 표적 치료

```sql
-- 히스토그램 통계 수집 (스큐 문제 해결)
BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(
        ownname => '스키마명',
        tabname => '테이블명',
        method_opt => 'FOR COLUMNS SIZE 254 문제컬럼명',
        degree => DBMS_STATS.AUTO_DEGREE
    );
END;
/

-- 확장 통계 생성 (상관관계 문제 해결)
BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(
        ownname => '스키마명',
        tabname => '테이블명',
        method_opt => 'FOR COLUMNS (컬럼1, 컬럼2) SIZE 254',
        degree => DBMS_STATS.AUTO_DEGREE
    );
END;
/

-- 동적 통계 활용 (일시적 해결)
SELECT /*+ DYNAMIC_SAMPLING(4) */ ...
FROM   테이블
WHERE  복잡한_조건;
```

### 4단계: 지속적 모니터링

```sql
-- 비용 모델 관련 성능 문제 모니터링
SELECT 
    sql_id,
    plan_hash_value,
    executions,
    buffer_gets,
    disk_reads,
    cpu_time,
    elapsed_time,
    ROUND(elapsed_time/executions/1000, 2) as avg_ms_per_exec
FROM v$sql
WHERE sql_text LIKE '%문제_쿼리_패턴%'
ORDER BY elapsed_time DESC;
```

## 결론: 비용 모델은 예술과 과학의 조화

Oracle의 비용 모델은 데이터베이스 최적화의 핵심 엔진입니다. 이 모델은 통계 과학과 시스템 공학의 복잡한 조합으로, 다음과 같은 교훈을 제공합니다:

1. **비용은 예측일 뿐입니다**: 비용 숫자는 절대적 진리가 아니라, 제한된 정보를 기반으로 한 최선의 예측입니다. 실제 실행 통계와의 비교가 항상 필요합니다.

2. **카디널리티가 왕입니다**: 비용 계산의 절반 이상은 처리할 데이터 양의 정확한 추정에 달려 있습니다. 정확한 통계 수집이 최우선 과제입니다.

3. **시스템 특성을 반영해야 합니다**: 추상적인 비용 숫자에 실제 시스템의 I/O 및 CPU 특성을 반영하는 시스템 통계가 필수적입니다.

4. **간단함이 효과적입니다**: 복잡한 파라미터 조정보다는 정확한 통계, 효율적인 스키마 설계, 최적화된 SQL이 더 근본적이고 지속 가능한 해결책입니다.

5. **학습과 적응이 필요합니다**: 옵티마이저도 계속 발전하고 있습니다. 적응형 기능들을 이해하고 활용하면, 변화하는 데이터와 워크로드에 더 잘 대응할 수 있습니다.

비용 모델을 이해한다는 것은 단순히 숫자 계산법을 아는 것이 아니라, 옵티마이저의 사고 방식을 이해하고, 그 한계를 인정하며, 인간의 지혜로 보완하는 방법을 터득하는 것입니다. 이는 데이터베이스 성능 최적화에서 이론과 실무, 과학과 예술이 만나는 지점입니다.