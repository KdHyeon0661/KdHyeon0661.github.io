---
layout: post
title: 객체지향설계 - 함수형 프로그래밍과의 비교
date: 2025-07-31 17:20:23 +0900
category: 객체지향설계
---
# 함수형 프로그래밍(Functional Programming)과의 비교 — 상세 정리

객체지향 프로그래밍(OOP)과 함수형 프로그래밍(FP)은 서로 다른 설계 철학과 기법을 가진 패러다임입니다. 둘은 상호 배타적이지 않고 오늘날의 실무에서는 **혼합(hybrid)** 해서 쓰는 경우가 많습니다. 아래는 핵심 개념, 설계·구현·테스트·성능 관점에서의 비교, 코드 예시, 변환·적용 팁과 결론까지 실무적으로 유용한 관점으로 정리한 내용입니다.

---

## 1. 핵심 철학 한 줄 요약
- **OOP**: 상태ful 객체(데이터 + 행위)를 **캡슐화**하고 메시지(메서드 호출)로 협력시켜 시스템을 모델링한다.  
- **FP**: 프로그램을 **순수 함수의 조합**으로 보고, 부수효과(side effect)를 경계(외부계층)로 밀어내며 불변성을 기본으로 한다.

---

## 2. 핵심 개념 비교 (요점 정리)

| 관점 | 객체지향 (OOP) | 함수형 (FP) |
|------|----------------|-------------|
| 기본 단위 | 객체(상태 + 행위) | 함수(입력 → 출력, 순수 함수 선호) |
| 상태 | 보통 가변(mutable) | 불변(immutable) 권장 |
| 부수효과 | 객체 내부/외부에서 흔함 | 최소화, 외부와의 상호작용은 분리(선언) |
| 추상화 수단 | 클래스, 상속, 인터페이스 | 고차 함수, 클로저, 타입(ADT), 모나드 등 |
| 다형성 | 서브타입(상속)과 인터페이스 기반 | 매개형(제네릭)·형식 클래스(typeclasses)·패턴 매칭 |
| 복잡성 관리 | 캡슐화, 계층, 디자인 패턴 | 함수 합성, 파이프라인, 불변 데이터 구조 |
| 동시성 | 동기적 공유 상태 → 락 필요 | 불변성 덕분에 안전성이 높음 (병렬화 쉬움) |
| 테스트성 | 의존성 주입 필요 | 순수 함수는 테스트가 매우 쉬움 |
| 학습 곡선 | 직관적(모델링) — OO 개념 학습 필요 | 함수형 사고(고차 함수, 불변성, 모나드 등) 학습 필요 |

---

## 3. 상태와 부수효과(사이드 이펙트)

- **OOP**는 객체가 상태(필드)를 내부에 갖고, 메서드가 그 상태를 변형한다. 캡슐화를 통해 내부 상태를 숨기지만 **공유 가변 상태(shared mutable state)** 는 동시성·테스트·버그의 큰 원인이다.
- **FP**는 상태 변경 대신 **새로운 값(복사본)** 을 반환하거나 상태 변화를 명시적으로 표현(예: State 모나드, 이벤트 소싱)한다. 부수효과(로그·IO·네트워크)는 순수 함수 바깥으로 격리한다.

**실무 팁**: 순수 함수로 핵심 비즈니스 로직을 작성하고, I/O와 상태 관리는 애플리케이션/인프라 계층에서 핸들링하면 테스트와 병렬처리에 유리.

---

## 4. 추상화와 재사용

- **OOP**: `클래스/상속/인터페이스`로 타입과 행위를 묶는다. 코드 재사용은 상속(또는 합성)으로 이루어지고, 디자인 패턴(Factory, Strategy 등)을 자주 사용한다.
- **FP**: **함수 합성(composition)** 과 **고차 함수(HOF)** 로 재사용을 달성한다. 데이터 변환 파이프라인(맵/필터/리듀스)과 작은 함수들의 조합이 핵심이다.

---

## 5. 다형성(Polymorphism)

- **OOP**: 서브타입 다형성(상속 / implements)과 오버라이딩. 런타임 다형성(동적 바인딩).
- **FP**: **파라메트릭 다형성**(제네릭), **애드혹 다형성**(오버로딩), **형식 클래스(typeclasses)**(Haskell/Scala) 등을 통해 동작을 추상화. 패턴 매칭으로 케이스에 따라 분기 처리.

---

## 6. 동시성 & 병렬성

- **OOP**: 공유 상태 기반이므로 락, 뮤텍스, 동기화 트릭이 필요. 이는 데드락·경쟁상태를 초래하기 쉬움.
- **FP**: 불변성 덕분에 데이터 경합이 적어 병렬처리가 안전. 순수 함수는 아무 스레드에서나 실행 가능. 하지만 리액티브 스트림, 이뮬레이트된 상태 관리(Actor 모델) 등도 조합해 사용.

---

## 7. 테스트와 디버깅

- **FP**: 순수 함수는 입력→출력으로 테스트가 쉽고 결정적이며, 단위 테스트용 더블이 거의 필요 없다. 그러나 복잡한 고차 함수 조합이나 모나드/컨테이너에는 학습 부담이 있다.
- **OOP**: 의존성 주입(DI) 및 목(mock) 사용으로 테스트 가능. 상태 기반 검증과 통합 테스트가 중요. 디버깅은 객체 상태 추적 방식으로 친숙한 경우가 많다.

---

## 8. 성능·메모리

- **OOP**: 가변 객체로 인한 성능 이점(복사 비용 없음). 하지만 병렬화 시 락 비용 등으로 성능 저하 가능.
- **FP**: 불변 데이터 구조는 불필요한 복사 비용을 초래할 가능성 있지만, **구조적 공유(structural sharing)**(예: persistent data structures)로 이를 완화. JIT 최적화와 함수 인라이닝이 성능을 개선한다. 문제는 가비지 컬렉션 부담 증가 가능성.

---

## 9. 코드 예제 — 같은 문제(은행 계좌 입금/출금) 구현 비교

### OOP (Java 스타일)
```java
public class BankAccount {
    private long balanceCents;

    public BankAccount(long initial) { this.balanceCents = initial; }

    public synchronized void deposit(long cents) {
        if (cents <= 0) throw new IllegalArgumentException();
        balanceCents += cents;
    }

    public synchronized void withdraw(long cents) {
        if (cents <= 0) throw new IllegalArgumentException();
        if (balanceCents < cents) throw new IllegalStateException("Insufficient funds");
        balanceCents -= cents;
    }

    public long getBalance() { return balanceCents; }
}
```

### FP (JavaScript / 순수 함수 스타일 — 불변)
```javascript
// 상태를 불변하게 다뤄 함수가 새로운 상태를 반환
function deposit(account, cents) {
  if (cents <= 0) throw new Error('amount>0');
  return { ...account, balance: account.balance + cents };
}

function withdraw(account, cents) {
  if (cents <= 0) throw new Error('amount>0');
  if (account.balance < cents) throw new Error('insufficient');
  return { ...account, balance: account.balance - cents };
}

// 사용
const acc0 = { id: 'A', balance: 1000 };
const acc1 = deposit(acc0, 300); // acc0은 불변
```

> FP 예제는 상태를 직접 변경하지 않고 새 객체를 반환하므로 테스트·병렬화에 유리하다.

---

## 10. 디자인 패턴 관점의 대응

많은 OO 패턴은 FP에서는 다른 방식으로 표현된다:

- **Strategy** → 고차 함수(함수를 인자로 전달)
- **Visitor** → 패턴 매칭(ADT) 또는 고차 함수
- **Decorator** → 함수 래핑(고차 함수) 또는 컴포지션
- **Factory** → 함수(클로저)로 대체
- **Observer** → 리액티브 스트림(Observable)/이벤트 스트림

즉, FP에서는 **패턴이 '데이터 변환·합성'으로 자연스럽게 녹아들어** 별도의 복잡한 설계가 필요 없을 때가 많다.

---

## 11. 실무에서의 선택 기준

- **도메인 모델링(복잡한 상태와 행위가 결합된 객체를 표현)** → OOP가 직관적일 수 있음. (예: GUI, 게임 객체, 계좌 도메인 등)
- **데이터 흐름·변환 파이프라인, 병렬 처리, 수학적/통계적 계산** → FP가 더 자연스럽고 안전함. (예: ETL, 스트림 처리, 복잡한 알고리즘)
- **팀의 역량과 생태계**: 기존 코드베이스·팀 역량·라이브러리 생태계 고려. Java 기반 기업에서는 OOP + 일부 함수형 기법(람다, 스트림) 혼용이 현실적.
- **성능 요구**: 가변 상태가 유리한 핫스팟에서는 OOP적 기법이나 mutable local state를 사용. 그러나 병렬·분산 부하에선 FP의 불변성이 이점.

---

## 12. 혼합(Hybrid) 전략 — 현실적 접근법

대부분 실무 프로젝트는 **혼합**한다:
- 핵심 비즈니스 로직은 **순수 함수(또는 함수형 스타일)** 로 작성해 테스트·추론을 쉽게 하고,
- 외부 경계(데이터베이스, 네트워크, UI)는 **객체/어댑터(OO 스타일)** 로 감싼다. (Hexagonal / Ports & Adapters와 궁합이 좋음)
- 언어 지원: Scala, Kotlin, JavaScript, C# 등은 OOP와 FP를 모두 지원하므로 상황에 따라 패러다임을 선택.

---

## 13. 장단점 요약

### OOP 장점
- 현실 세계 모델링이 직관적
- 넓은 채택·라이브러리·도구 생태계
- 캡슐화로 코드 이해와 분리 용이

### OOP 단점
- 공유 가변 상태로 인한 동시성 문제
- 상속 남용·고착된 계층화 문제

### FP 장점
- 순수성으로 인한 높은 테스트성·병렬 안전성
- 작은 구성요소(함수)의 조합으로 예측 가능성 향상
- 부수효과 격리로 추론 가능성 상승

### FP 단점
- 불변성·고차함수·모나드 등 학습 곡선
- 일부 문제에서 성능/메모리 부담(그러나 구조적 공유로 완화 가능)
- 디버깅이 익숙하지 않을 수 있음(특히 point-free 스타일)

---

## 14. 마이그레이션 / 실무 적용 팁

1. **작은 부분부터 도입**: 핵심 비즈니스 로직이나 데이터 변환 파이프라인을 먼저 순수 함수로 리팩토링.  
2. **경계 만들기**: I/O (DB/HTTP) 코드와 비즈니스 로직을 분리 — 비즈니스는 순수 함수로.  
3. **불변성 전략**: 성능 핫스팟을 제외하고는 불변 객체를 기본으로. 필요 시 persistent collections 사용.  
4. **교육과 규칙**: 팀에 함수형 개념(고차함수, 순수성, 부수효과 분리)을 교육하고 코드 스타일 규칙을 마련.  
5. **도구 활용**: 언어별 Linter/Static analysis로 함수형/불변성 규칙을 체크.  
6. **테스트 우선**: TDD를 활용하면 함수형 코드가 자연스럽게 설계됨.  

---

## 15. 참고 주제 / 학습 권장서
- *Structure and Interpretation of Computer Programs (SICP)* — 함수형 사고 기초  
- *Functional Programming in Scala* — Scala로 배우는 FP 실무  
- *Domain Modeling Made Functional* — DDD + FP 결합  
- *Clean Architecture*, *Refactoring* — 설계·리팩토링 관점 보완

---

## 16. 결론 (핵심 메시지)
OOP와 FP는 서로 보완적입니다.  
- 도메인 모델이 복잡하게 상태와 행위를 결합한다면 OOP의 캡슐화가 유리하고,  
- 데이터 변환, 동시성, 테스트 용이성을 중시한다면 FP의 순수 함수와 불변성이 강력합니다.  
