---
layout: post
title: 컴퓨터시스템 - 프로세스 조작을 위한 도구
date: 2025-08-16 18:20:23 +0900
category: 컴퓨터시스템
---
# 프로세스 조작을 위한 도구 — 리눅스 중심 실전 가이드(발견→관찰→제어→추적→격리→자원관리)

> 목표: “지금 시스템에서 **무슨 프로세스가 무엇을 하고 있는지** 빠르게 파악하고, **자원/스케줄/네임스페이스**를 조정하며, 이상 증상 시 **추적·디버깅**하고, 필요하면 **격리/제한**까지 걸 수 있게” 하는 도구들을 한 번에 정리합니다.  
> 범위: Linux/ELF 기준. (Windows/macOS 유사 도구는 말미에 요약)

---

## 0) 한눈 지도(무엇을 하고 싶은가 → 어떤 도구?)

작업 | 대표 도구
---|---
프로세스 **찾기/목록** | `ps`, `pgrep`, `pidof`, `pstree`
**상태/부하 모니터** | `top`, `htop`, `atop`, `pidstat`, `vmstat`, `iostat`, `mpstat`, `sar`
열린 파일/소켓 확인 | `lsof`, `ss`, `fuser`, `pfiles`(일부 OS)
프로세스 **세부 정보** | `/proc/<pid>/*`, `pmap`, `readlink`, `cat`
**신호/종료/정지/재개** | `kill`, `pkill`, `killall`, `stop/cont`
우선순위/스케줄링 | `nice`, `renice`, `chrt`(RT), `ionice`
CPU/NUMA 바인딩 | `taskset`, `numactl`
리소스 제한 | `prlimit`, `ulimit`, **cgroup v2**(`systemd-run -p …`, `cgexec`)
네임스페이스/격리 | `unshare`, `nsenter`, `bwrap`, `firejail`, `chroot`
동적 추적/후킹 | `strace`, `ltrace`, `perf`, `bcc/bpftrace`, `ftrace`, `systemtap`
디버깅/크래시 | `gdb`, `core dump`(ulimit/coredumpctl), `rr`(record&replay)
서비스/단위 관리 | `systemctl`, `systemd-run`, `journalctl`
컨테이너/네임스페이스 진입 | `docker exec`, `podman exec`, `nsenter`

---

## 1) 프로세스 **발견/검색**: 빠르게 PID를 잡자
```bash
ps aux | less                   # 전 프로세스 요약
ps -eo pid,ppid,stat,ni,pri,psr,cmd --sort=-%cpu | head   # CPU 상위
pgrep -a nginx                  # 이름으로 PID + 커맨드 표시
pidof sshd                      # 데몬 PID
pstree -ap                      # 트리(부모-자식, 인자 표시)
```
- 팁: `ps -L -p <pid>` 로 **스레드별** 상태, `ps -o pid,cmd --ppid <ppid>` 로 **자식만** 보기.

---

## 2) **상태/부하 모니터링**: 실시간으로 무엇이 병목인가
```bash
top -H                             # 스레드 단위 보기
htop                                # 직관적 인터페이스, F2로 컬럼/정렬 튜닝
pidstat -d -r -u -h 1              # PID별 I/O/메모리/CPU(매 1초)
vmstat 1                           # 시스템 전체 메모리/스왑/런큐
iostat -xz 1                       # 디스크 대역/큐
mpstat -P ALL 1                    # 코어별 CPU 사용률
sar -n DEV 1 10                    # 네트워크 인터페이스 통계
```

---

## 3) **열린 파일/포트/락**: 누가 무엇을 잡고 있나
```bash
lsof -p <pid>                      # PID가 연 파일/소켓/매핑
lsof -i :8080                      # 8080 포트 점유자
ss -ltnp                           # LISTEN 소켓 + 프로세스
fuser -mv /path/to/file            # 파일/마운트를 사용하는 PID
```

---

## 4) `/proc`로 **깊게 파보기**: 커널이 보는 그 모습
```bash
cat /proc/<pid>/status             # 상태/메모리/권한/스레드 수
cat /proc/<pid>/cmdline | tr '\0' ' '  # 인자
readlink /proc/<pid>/exe           # 실행 파일
ls -l /proc/<pid>/fd               # FD 목록(파이프/소켓/파일)
cat /proc/<pid>/smaps              # 메모리 매핑/NUMA/Anon/Shared 상세
cat /proc/<pid>/limits             # RLIMIT (nofile, stack 등)
pmap -x <pid>                      # 주소공간 요약
```

---

## 5) **신호와 제어**: 종료/정지/재개/리로드
```bash
kill -TERM <pid>                   # 정상 종료 요청(우선 권장)
kill -KILL <pid>                   # 강제 종료(최후의 수단)
kill -STOP <pid>; kill -CONT <pid> # 정지/재개(디버깅, 일시 중지)
pkill -HUP nginx                   # 구성 리로드(HUP 관례)
```
- **규칙**: `TERM` → `INT` → `QUIT`(코어덤프) → `KILL` 순으로 **점진적** 시도.

---

## 6) **우선순위/스케줄러/디스크 I/O 클래스**
```bash
nice -n 10 ./job                   # 낮은 우선순위로 실행
renice -n -5 -p <pid>              # 실행 중인 프로세스 NI 조정(-20..19)
chrt -f -p 80 <pid>                # RT(FIFO) 80으로(주의!)
ionice -c2 -n7 -p <pid>            # I/O 우선순위 Idle/Best-effort/RT
```
- RT 스케줄(FIFO/RR)은 **시스템 응답성에 영향** 크므로 관리 환경에서만 신중히.

---

## 7) **CPU/NUMA 바인딩**: 캐시·대역 최적화
```bash
taskset -c 0-3,8 ./worker          # 특정 코어에 바인딩
taskset -pc 2-5 <pid>              # 실행 중인 PID 바인딩 변경
numactl --cpunodebind=0 --membind=0 ./app   # NUMA 노드 고정
numactl --hardware                 # NUMA 토폴로지 확인
```
- **현상**: 코어/NUMA 분산으로 캐시 미스/원격 메모리 증가 → **지역성** 유도.

---

## 8) **리소스 제한**: RLIMIT + cgroup v2(systemd)
```bash
prlimit --pid <pid> --nofile=4096          # FD 한도 변경
ulimit -n 8192                              # 셸/자식에 적용

# systemd cgroup으로 즉시 제한/실행
systemd-run -p MemoryMax=1G -p CPUQuota=50% --scope -- pid_of_app
systemd-run --user -p IOReadBandwidthMax=/dev/nvme0n1:50M mycmd
```
- cgroup v2는 CPU/메모리/I/O/PID/네트워크 등 **정교한 제한**과 **계층 관리** 제공.

---

## 9) **네임스페이스/격리**: 최소한의 샌드박스
```bash
unshare --mount --uts --ipc --net --pid --fork --mount-proc bash
nsenter --target <pid> --mount --uts --ipc --net --pid  # 해당 PID의 ns로 진입
bwrap --ro-bind / / --tmpfs /tmp --unshare-net --proc /proc --dev /dev bash
firejail --private --net=none myapp
```
- PID/NET/UTS/MNT/USER 네임스페이스로 **실행 환경 격리**. 간단 실험·테스트에 유용.

---

## 10) **동적 추적/후킹**: 시스템 콜/라이브러리 호출/커널 이벤트
```bash
strace -f -o trace.log -ttT -s 128 -p <pid>        # 시스템 콜/errno/지연
ltrace -f -p <pid>                                  # 라이브러리 호출(printf 등)
perf stat -p <pid>                                  # IPC, LLC-miss 등 카운터
perf record -p <pid> -- sleep 10; perf report       # 프로파일(플레임그래프 기반)
bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf("%d %s\n", pid, str(args->filename)); }'
```
- `bcc` 예제들: `execsnoop`, `opensnoop`, `tcplife`, `runqlat` 등 **원클릭 관찰기**.  
- `ftrace/trace-cmd` 는 커널 함수 트레이싱; **오버헤드 낮고 강력**.

---

## 11) **디버깅/크래시 핸들링**
```bash
gdb -p <pid>                                  # 라이브 attach
ulimit -c unlimited                           # 코어덤프 허용
sysctl kernel.core_pattern='|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %e'
coredumpctl list; coredumpctl gdb <pid|EXE>   # 발생 코어 분석
rr record ./app ; rr replay                   # 재현 가능한 디버깅
```
- **ASLR/PIE/strip** 상태를 확인하고 심볼(.debug) 준비가 중요.

---

## 12) **서비스/로그/재시작 정책(systemd)**
```bash
systemctl status my.service
journalctl -u my.service -f                # 실시간 로그
systemctl restart my.service
systemd-run --unit=tmp.scope --scope sleep 60
```
- 서비스 단위에 **Restart=on-failure**, **Resource limits**, **Capability**/**Sandbox** 정책을 부여 가능.

---

## 13) **일상 업무용 미니 레시피**

### 13.1 “포트 8080을 누가 쓰나? 죽이고 다시 띄워”
```bash
sudo lsof -i :8080
sudo fuser -k 8080/tcp
```

### 13.2 “CPU 100% 먹는 놈 원인 추적”
```bash
top -H -p <pid>                   # 핫 스레드 찾기
perf top -p <pid>                 # 심볼 기준 핫 함수
strace -f -p <pid>                # 시스템콜 대기/루프 확인
```

### 13.3 “디스크 I/O 때문에 느려”
```bash
pidstat -d 1 -p <pid>
ionice -c2 -n7 -p <pid>           # 우선순위 낮추기
```

### 13.4 “락/파일 점유 때문에 배포 실패”
```bash
lsof /path/to/app.bin
fuser -mv /path/to/app.bin
```

### 13.5 “NUMA 원격 메모리로 느려”
```bash
numactl --show --hardware
numactl --cpunodebind=0 --membind=0 -- <cmd>
```

### 13.6 “좀비/고아 프로세스 청소”
```bash
ps -o pid,ppid,stat,cmd | grep ' Z '   # Z(좀비)
# 부모에게 SIGCHLD 핸들링/ wait() 누락 수정이 근본해결
```

---

## 14) **보안/권한/격리 관련 보조 도구**
```bash
capsh --print                         # 프로세스 권한(Capabilities)
setcap cap_net_bind_service+ep ./app  # 1024 미만 포트 바인딩 권한 부여
aa-status / seinfo -a                 # AppArmor/SELinux 상태
seccomp-tools dump ./app              # seccomp 정책 확인(배포별)
```
- **ptrace 제한**: `/proc/sys/kernel/yama/ptrace_scope` 값에 따라 `strace/gdb`가 제한될 수 있음.

---

## 15) **Windows/macOS 참고(짧게)**
- Windows: **Process Explorer**, **Process Monitor**, `tasklist/taskkill`, `wmic`, `Get-Process/Stop-Process`, **ProcDump**, **wpa/wpr**, **xperf**, `schtasks`, **Process Hacker**.
- macOS: `ps`, `top`, `Activity Monitor`, `fs_usage`, `dtruss`(DTrace), `lldb`, `launchctl`, `leaks`, `spindump`.

---

## 16) 안전 가이드(함정)
- `kill -KILL` 남발 금지(코어/임시파일/락 **정리 불가**). 우선 `TERM/HUP`.
- RT 스케줄러(`chrt`)는 **시스템 전체 응답성 저하** 위험 → 제한된 환경에서.
- `taskset/numactl` 무분별 사용은 오히려 **스케줄러 최적화**를 방해할 수 있음.
- `strace`/`ltrace`/`perf record` 는 **오버헤드**가 있으니 생산계에서는 기간·대상 **제한**.
- 네임스페이스/격리는 **권한/마운트** 정책과 상호작용. `unshare --map-root-user` 등 사용자 네임스페이스 지식 필요.

---

## 17) 치트시트(자주 쓰는 명령)

```bash
# 최다 CPU 프로세스/스레드
ps -eLo pid,ppid,psr,pcpu,stat,cmd --sort=-pcpu | head

# 특정 PID의 콜스택(심볼 필요)
gdb -q -p <pid> -ex "thread apply all bt" -ex detach -ex quit

# 한 번에 CPU 바인딩+우선순위
chrt -r 10 taskset -c 2-3 ionice -c2 -n7 nice -n5 ./job

# cgroup v2로 즉시 리소스 제한(현재 셸 프로세스에 적용)
systemd-run -p CPUQuota=40% -p MemoryMax=2G --scope --pid $$

# 네임스페이스 들어가서 디버깅(컨테이너 PID=1234)
nsenter --target 1234 --mount --uts --ipc --net --pid bash
```

---

## 18) 한 줄 결론
프로세스 조작은 **발견(ps/pgrep) → 관찰(top/pidstat/lsof/ss) → 제어(kill/nice/chrt/taskset/numactl) → 추적(strace/perf/bpf) → 격리/제한(unshare/cgroup)** 의 단계로 체계화하면 쉽습니다.  
도구를 조합해 **원인 파악 → 최소 침습 제어 → 재현 가능한 추적/디버깅** 순서로 접근하면, 운영·개발·성능튜닝 모두에서 안정적이고 재현 가능한 결과를 얻을 수 있습니다.