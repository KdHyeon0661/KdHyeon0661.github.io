---
layout: post
title: 컴퓨터시스템 - 프로세스 조작을 위한 도구
date: 2025-08-16 18:20:23 +0900
category: 컴퓨터시스템
---
# 프로세스 조작을 위한 도구

## 0. 한눈 지도(무엇을 하고 싶은가 → 어떤 도구?)

작업 | 대표 도구
---|---
프로세스 **찾기/목록** | `ps`, `pgrep`, `pidof`, `pstree`
**상태/부하 모니터** | `top`, `htop`, `pidstat`, `vmstat`, `iostat`, `mpstat`, `sar`
열린 파일/소켓/락 | `lsof`, `ss`, `fuser`
프로세스 **세부 정보** | `/proc/<pid>/*`, `pmap`, `readlink`
**신호/종료/정지/재개** | `kill`, `pkill`, `killall`, `stop/cont`
우선순위/스케줄링 | `nice`, `renice`, `chrt`(RT), `ionice`
CPU/NUMA 바인딩 | `taskset`, `numactl`
리소스 제한 | `prlimit`, `ulimit`, **cgroup v2**(`systemd-run -p …`, `cgexec`)
네임스페이스/격리 | `unshare`, `nsenter`, `bwrap`, `firejail`, `chroot`
동적 추적/후킹 | `strace`, `ltrace`, `perf`, `ftrace`, `bpftrace/bcc`
디버깅/코어덤프 | `gdb`, `coredumpctl`, `rr`(record & replay)
서비스/단위 관리 | `systemctl`, `systemd-run`, `journalctl`
컨테이너 진입/조작 | `docker exec`, `podman exec`, `nsenter`

---

## 1. 프로세스 **발견/검색**: “PID부터 잡자”

```bash
ps aux | less
ps -eo pid,ppid,stat,ni,pri,psr,%cpu,%mem,etime,cmd --sort=-%cpu | head
pgrep -a nginx                       # 이름으로 PID + 커맨드
pidof sshd                           # 데몬 PID
pstree -ap                           # 부모-자식/인자 트리
ps -L -p <pid> -o pid,tid,psr,stat,pcpu,comm  # 스레드별 보기
ps -o pid,cmd --ppid <ppid>          # 특정 부모의 자식만
```

**팁**
- **핫스레드**를 찾을 때: `top -H -p <pid>` 또는 `ps -eLo pid,tid,pcpu,psr,stat,cmd --sort=-pcpu | head`.

---

## 2. **상태/부하 모니터링**: “병목은 어디인가”

```bash
top -H                                   # 스레드 단위
htop                                     # F2로 컬럼/정렬 커스터마이즈
pidstat -d -r -u -h 1                    # PID별 I/O/메모리/CPU(1초 주기)
vmstat 1                                 # 시스템 메모리/스왑/런큐
iostat -xz 1                             # 디스크 대역/큐/서비스타임
mpstat -P ALL 1                          # CPU 코어별
sar -n DEV 1 5                           # NIC 통계
```

**현상-대응 힌트**
- **CPU 100%**: `top -H` → 핫스레드 → `perf top/record`(핫함수) → `strace -p`(시스템콜 바쁜 루프 여부).
- **디스크 I/O 포화**: `iostat -xz 1`에서 `util≈100%`, `await↑` → `pidstat -d`로 가해자 식별.
- **스케줄 대기**: `vmstat`의 `r` 큐↑, PSI(`/proc/pressure/cpu|memory|io`) 확인.

---

## 3. **열린 파일/포트/락**: “누가 점유했나”

```bash
lsof -p <pid>                            # 해당 PID가 연 모든 FD
lsof -i :8080                            # 포트 8080 점유자
ss -ltnp                                 # LISTEN 소켓 + 프로세스
fuser -mv /path/to/file_or_mount         # 파일/마운트 사용중인 PID
```

**간단 레시피**
- “**8080이 안 비워진다**” → `sudo lsof -i :8080` → 점유 PID 종료(`kill -TERM`) 또는 `sudo fuser -k 8080/tcp`.

---

## 4. `/proc`로 **깊게 파보기**: “커널이 보는 그대로”

```bash
cat /proc/<pid>/status                  # 상태/메모리/권한/스레드
tr '\0' ' ' < /proc/<pid>/cmdline       # 인자 복원
readlink /proc/<pid>/exe                # 실행 파일 실제 경로
ls -l /proc/<pid>/fd                    # FD 심볼릭 링크
cat /proc/<pid>/limits                  # RLIMIT (nofile, stack 등)
cat /proc/<pid>/smaps | less            # 매핑/Anon/Shared/NUMA 세부
pmap -x <pid>                           # 주소공간 요약
```

**매핑 파악 포인트**
- **익명(anon)** 폭증 → 힙/캐시 누수 의심.
- **[stack]** 크기 증가 → 재귀/고스택 스레드.
- **[heap] + huge/THP** 여부 → 메모리·TLB 패턴 영향.

---

## 5. **신호와 제어**: 종료/정지/재개/리로드

```bash
kill -TERM <pid>                        # 정상 종료(우선)
kill -INT  <pid>                        # 인터럽트(대화형)
kill -QUIT <pid>                        # 종료 + 코어덤프(디버깅)
kill -KILL <pid>                        # 강제 종료(최후의 수단)
kill -STOP <pid>; kill -CONT <pid>      # 정지/재개
pkill -HUP nginx                        # HUP=리로드 관례
```

**규칙**: `TERM` → `INT` → `QUIT`(덤프) → `KILL` 순으로 **점진적** 시도.
**주의**: `KILL`은 정리/플러시 불가(락/임시파일 남음).

### 5.1 최신 커널 안전 종료: **pidfd** 사용(C)
PID 재사용 레이스를 피하려면 **pidfd**로 신호를 보낸다.

```c
// pidfd_terminate.c (Linux 5.3+)
#define _GNU_SOURCE
#include <sys/syscall.h>
#include <unistd.h>
#include <signal.h>
#include <stdio.h>
#include <errno.h>

int main(int argc, char **argv){
    if (argc<2){ fprintf(stderr,"usage: %s <pid>\n", argv[0]); return 2; }
    pid_t pid = (pid_t)atoi(argv[1]);
    int pidfd = syscall(SYS_pidfd_open, pid, 0);
    if (pidfd<0){ perror("pidfd_open"); return 1; }
    if (syscall(SYS_pidfd_send_signal, pidfd, SIGTERM, NULL, 0)<0){
        perror("pidfd_send_signal");
        return 1;
    }
    close(pidfd);
    return 0;
}
```

---

## 6. **우선순위/스케줄러/I/O 클래스**

```bash
nice -n 10 ./job                       # 낮은 우선순위 시작
renice -n -5 -p <pid>                  # 실행 중 NI 조정(-20..19)
chrt -f -p 80 <pid>                    # RT(FIFO) prio=80 (주의!)
chrt -r 50 -- ./rt_job                 # RR로 실행
ionice -c2 -n7 -p <pid>                # I/O Best-effort class, 낮은 우선
ionice -c3 -p <pid>                    # I/O idle class
```

**주의**
- RT(FIFO/RR)는 **시스템 응답성**에 영향 큼. 실험/격리 환경에서만.
- I/O 경합이 심할 때는 `ionice`로 배경잡업을 **idle**로 내려놓으면 사용자 체감이 크게 개선된다.

---

## 7. **CPU/NUMA 바인딩**: 지역성으로 성능 확보

```bash
taskset -c 0-3,8 ./worker              # 특정 코어 바인딩
taskset -pc 2-5 <pid>                  # 실행 중 수정
numactl --cpunodebind=0 --membind=0 ./app
numactl --hardware                     # NUMA 토폴로지
```

**전략**
- 코어 간 **캐시 스래싱**이 보이면 **코어 묶음**으로 핫스레드 고정.
- **원격 NUMA 메모리** 타격 시 first-touch 지키기(스레드 생성/배치 시점을 조율).

---

## 8. **리소스 제한**: RLIMIT & **cgroup v2(systemd)**

### 8.1 RLIMIT(프로세스 단위 한도)
```bash
prlimit --pid <pid> --nofile=65535 --nproc=4096
ulimit -n 8192               # 셸/자식에 적용
```

### 8.2 cgroup v2 즉시 적용(시스템/사용자 스코프)
```bash
# 현재 PID 트리에 상한 걸기(관리자)
systemd-run -p MemoryMax=1G -p CPUQuota=50% --scope --pid <PID>

# 새 커맨드 제한 실행(사용자 세션에서도 가능)
systemd-run --user -p CPUWeight=200 -p MemoryHigh=2G -p MemoryMax=3G mycmd
```

**개념 수식(배경)**
cgroup v2의 CPU 쿼터는 `cpu.max = <quota_us> <period_us>`로 표현된다.
$$ f_\text{CPU} = \frac{\text{quota}}{\text{period}} $$
예: `50000 100000` → \( f=0.5 \) = **50%**.

**I/O 제한 예**
```bash
# NVMe 장치에 읽기 대역 상한
systemd-run -p IOReadBandwidthMax=/dev/nvme0n1:50M --scope -- pid_of_app
```

**메모리 보호/격리**
- `MemoryLow=`: **워킹셋 보호선** (압박 시 우선 보존)
- `MemoryHigh=`: 넘으면 소프트 스로틀
- `MemoryMax=`: 하드 상한(OOM 대상)

---

## 9. **네임스페이스/격리**: 샌드박스·테스트에 유용

```bash
# 모두 분리해 새 쉘 실행(간이 컨테이너)
unshare --mount --uts --ipc --net --pid --fork --mount-proc bash

# 다른 프로세스의 ns로 들어가기(컨테이너/서비스 디버깅)
nsenter --target <pid> --mount --uts --ipc --net --pid

# 버블랩(bwrap): 읽기전용 루트 + tmpfs /tmp + 네트워크 차단
bwrap --ro-bind / / --tmpfs /tmp --unshare-net --proc /proc --dev /dev bash

# Firejail 간단 샌드박스
firejail --private --net=none myapp
```

**팁**
- 비루트 테스트는 `unshare --map-root-user`(user ns)와 함께.
- 마운트 격리 후 `/proc`은 `--mount-proc`로 새로 붙인다.

---

## 10. **동적 추적/후킹**: 시스템콜·라이브러리·커널 이벤트

```bash
strace -f -o trace.log -ttT -s 128 -p <pid>        # 시간/지연/errno
ltrace -f -p <pid>                                  # libc 레벨 호출
perf stat -p <pid>                                  # IPC, LLC-miss 등 HW 카운터
perf record -p <pid> -- sleep 10; perf report       # 샘플링 프로파일
```

### 10.1 bpftrace(초간단 eBPF 스크립트)
```bash
# 파일 열기 추적
bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf("%d %s\n", pid, str(args->filename)); }'

# write 지연 분포
bpftrace -e 'kprobe:__x64_sys_write { @start[tid]=nsecs; } \
             kretprobe:__x64_sys_write /@start[tid]/ { @d=hist((nsecs-@start[tid])/1000); delete(@start[tid]); }'
```

**오버헤드 주의**: `strace`, `perf record`, eBPF는 생산계에서 **대상·기간 제한**.

---

## 11. **디버깅/코어덤프/재현**

```bash
gdb -p <pid>
ulimit -c unlimited
coredumpctl list
coredumpctl gdb <PID|EXE>             # 심볼 준비 필수
# Repro 디버깅
rr record ./app ; rr replay
```

**코어 경로(systemd)**
```bash
sysctl kernel.core_pattern='|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %e'
```

---

## 12. **서비스/로그/재시작 정책(systemd)**

```bash
systemctl status my.service
journalctl -u my.service -f
systemctl restart my.service

# 임시 스코프로 실행해 자원/권한 부여
systemd-run --unit=tmp.scope -p MemoryMax=1G -p CPUQuota=60% --scope ./job
```

**서비스 단위 주요 옵션(발췌)**
- `Restart=on-failure`, `RestartSec=3s`
- `NoNewPrivileges=yes`, `AmbientCapabilities=`, `CapabilityBoundingSet=`
- `ProtectSystem=strict`, `ProtectHome=yes`, `PrivateTmp=yes`
- `MemoryMax=`, `CPUQuota=`, `IOReadBandwidthMax=` …

---

## 13. **일상 플레이북**(상황→처방)

### 13.1 “포트 8080 충돌”
```bash
sudo lsof -i :8080
sudo fuser -k 8080/tcp
```

### 13.2 “CPU 100%”
```bash
top -H -p <pid>                  # 핫스레드
perf top -p <pid>                # 핫함수
strace -f -p <pid>               # 바쁜 루프/시스콜 대기 확인
```

### 13.3 “디스크 I/O 포화”
```bash
pidstat -d 1 -p <pid>
ionice -c3 -p <pid>              # idle로 내리기
```

### 13.4 “락/파일 점유로 배포 실패”
```bash
lsof /path/to/app.bin
fuser -mv /path/to/app.bin
```

### 13.5 “NUMA 원격 메모리”
```bash
numactl --show --hardware
numactl --cpunodebind=0 --membind=0 -- <cmd>
```

### 13.6 “좀비/고아 청소”
```bash
ps -e -o pid,ppid,stat,cmd | awk '$3 ~ /Z/'
# 근본 해결: 부모 프로세스에 SIGCHLD 핸들러 + wait()/waitpid() 구현
```

---

## 14. **보안/권한/격리 보조**

```bash
capsh --print                              # Capabilities 확인
setcap cap_net_bind_service=+ep ./app      # 1024 미만 포트 바인딩 권한 부여
aa-status | seinfo -a                      # AppArmor/SELinux 상태
# ptrace 제한: 낮추면 디버깅 용이(주의)
sudo sysctl kernel.yama.ptrace_scope=0
```

**seccomp**
- 배포 바이너리의 seccomp 활성화 여부는 배포별 도구(`seccomp-tools`)로 점검.
- systemd `SystemCallFilter=`로 **허용 목록** 기반 제한 가능.

---

## 15. 컨테이너/쿠버네티스 현장 팁

{% raw %}
```bash
# 컨테이너 내부로
docker exec -it <cid> bash
# 호스트에서 네임스페이스 직접 진입
nsenter --target $(docker inspect -f '{{.State.Pid}}' <cid>) --mount --uts --ipc --net --pid bash
# cgroup v2에서 Pod 단위 제한 확인
systemd-cgls /sys/fs/cgroup
```
{% endraw %}

**주의**: 컨테이너 PID 1은 **시그널 처리/좀비 reap**가 필요. tini/--init 또는 애플리케이션에서 SIGCHLD 처리.

---

## 16. 자동화 스니펫(운영 바보-proof)

### 16.1 “안전 종료(TERM→QUIT→KILL)”
```bash
#!/usr/bin/env bash
set -euo pipefail
pid="$1"
for sig in TERM INT QUIT KILL; do
  if kill -0 "$pid" 2>/dev/null; then
    echo "sending $sig to $pid"
    kill -"$sig" "$pid" || true
    sleep 2
  fi
done
```

### 16.2 “write-all (부분 쓰기/신호 재시도)”
```c
ssize_t write_all(int fd, const void *buf, size_t n){
    const unsigned char *p = buf; size_t left = n;
    while (left){
        ssize_t w = write(fd, p, left);
        if (w > 0) { p += w; left -= (size_t)w; continue; }
        if (w < 0 && (errno == EINTR || errno == EAGAIN)) continue;
        return -1;
    }
    return (ssize_t)n;
}
```

---

## 17. 안전 가이드(발밑 지뢰)

항목 | 위험 | 대응
---|---|---
`kill -KILL` 남발 | 정리/플러시/락 해제 불능 | `TERM/INT/QUIT` 우선, 덤프 후 최후에 KILL
RT 스케줄 남용 | 시스템 전체 응답성 저하 | 격리 환경·한시적·모니터링 동반
`taskset/numactl` 오남용 | 스케줄러 최적화 방해 | 핫스레드/메모리 패턴 **근거** 있을 때만
`strace/perf record` 상시 | 오버헤드·노이즈 | 대상·기간 제한, `perf stat` 우선
O_DIRECT 혼용 | 페이지캐시/일관성 충돌 | 한 파일은 한 방식으로
PID 재사용 레이스 | 엉뚱한 프로세스 종료 위험 | **pidfd** 사용
코어덤프 비활성 | 사고 원인 미상 | `ulimit -c unlimited`, `coredumpctl` 활용

---

## 18. Windows/macOS 짧은 길잡이

- **Windows**: Process Explorer/Monitor, `tasklist/taskkill`, PowerShell `Get-Process/Stop-Process`, ProcDump, WPR/WPA, xperf.
- **macOS**: `ps`, `top`, Activity Monitor, `fs_usage`, `dtruss`(DTrace), `lldb`, `launchctl`, `spindump`, `leaks`.

---

## 19. 치트시트(손에 익히는 원라이너)

```bash
# 최다 CPU 스레드 Top-N
ps -eLo pid,tid,psr,pcpu,stat,comm --sort=-pcpu | head

# 소켓: LISTEN과 소유자
ss -ltnp

# 특정 PID 콜스택(심볼 필요)
gdb -q -p <pid> -ex "thread apply all bt" -ex detach -ex quit

# 한 번에: RR 스케줄 + 코어바인딩 + I/O 우선 낮추기 + niceness
chrt -r 20 taskset -c 2-3 ionice -c2 -n7 nice -n5 ./job

# cgroup v2로 지금 이 셸 트리 바로 제한
systemd-run -p CPUQuota=40% -p MemoryMax=2G --scope --pid $$
```

---

## 20. 마무리 요약

프로세스 조작은 **발견(ps/pgrep) → 관찰(top/pidstat/lsof/ss) → 제어(kill/nice/chrt/taskset/numactl) → 추적(strace/perf/bpf) → 격리/제한(unshare/cgroup)** 의 **단계적 플레이북**으로 체계화하면 쉽다.
핵심은 **최소 침습으로 원인을 좁히고**, 재현 가능하게 **추적/덤프**를 남기며, **cgroup/네임스페이스**로 **영향 범위를 제어**하는 것이다.
이 문서의 원라이너·스니펫·안전 수칙을 템플릿화하면, 운영/개발/성능튜닝 모두에서 **빠르고 안정적인** 문제 해결 루틴을 갖출 수 있다.
