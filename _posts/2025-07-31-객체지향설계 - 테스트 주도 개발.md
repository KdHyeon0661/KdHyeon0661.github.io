---
layout: post
title: 객체지향설계 - 테스트 주도 개발
date: 2025-07-31 15:20:23 +0900
category: 객체지향설계
---
# TDD(테스트 주도 개발)와 객체 지향 설계의 관계 — 상세 가이드

테스트 주도 개발(TDD, Test-Driven Development)은 단순한 테스트 작성 규칙이 아니라 **설계를 진화시키는 실천 방법**입니다. TDD의 `Red → Green → Refactor` 사이클을 통해 요구(행동)를 먼저 명세하고, 최소한의 코드로 동작을 구현한 뒤 설계를 개선해 나갑니다. 이 과정은 객체 지향 설계(OOD)의 좋은 특성들 — 응집도·낮은 결합·단일 책임·추상화 등 — 을 자연스럽게 이끌어냅니다. 아래에서 개념·효과·실전 워크플로우·코드 예제·주의사항·모범 사례를 차근차근 정리합니다.

---

## 1. TDD 간단 요약 (Red — Green — Refactor)
1. **Red**: 실패하는 테스트를 하나 작성한다. (새로운 요구/행동을 명세)  
2. **Green**: 테스트가 통과하도록 **가장 단순한 구현**을 추가한다. (빠르게 동작을 맞춘다)  
3. **Refactor**: 테스트가 모두 통과하는 상태에서 **설계 품질을 개선**(추출·이름 변경·추상화)한다.  
이 사이클을 매우 짧게(분 단위) 반복하면 요구를 작고 검증 가능한 단위로 쪼개어 설계를 점진적으로 개선할 수 있습니다.

---

## 2. 왜 TDD가 객체 지향 설계에 좋은가? (핵심 효과)
- **행동 우선(Behavior-first)**: 테스트는 API와 책임(what)을 먼저 정의하므로 클래스의 공개 인터페이스가 자연스럽게 명확해짐.  
- **작고 응집된 클래스 유도**: 테스트를 쉽게 하려면 클래스가 작고 단일 책임을 가져야 하므로 SRP를 따르게 됨.  
- **의존성 역전(DIP)·추상화 촉진**: 외부 의존을 목(Mock)으로 대체하려면 인터페이스가 필요 → 추상화가 생김.  
- **안전한 리팩토링 보장**: 자동화된 테스트가 있으므로 구조 개선(Extract Class, Replace Conditional 등)을 안전하게 수행 가능.  
- **설계의 점진적 진화(An Emergent Design)**: 처음부터 완벽 설계하지 않고 테스트-리팩터링으로 설계가 진화함.  
- **테스트 가능한 경계(Seams) 생성**: I/O·DB와 같은 부작용을 분리해 포트/어댑터 구조가 자연스럽게 도입됨.

---

## 3. TDD가 촉진하는 구체적 OO 기법 / 패턴
- **Value Object**(불변 객체) 사용 증가 — 비교가 쉬워지고 테스트 안정성 향상.  
- **Dependency Injection / Ports & Adapters** — 인터페이스(포트)를 만들고 인프라를 어댑터로 구현.  
- **Strategy / Template Method** — 조건문을 테스트로 드러낸 후 다형성으로 대체.  
- **Small Methods / Extract Method** — 테스트를 위해 메서드를 작게 나누면 재사용성과 가독성이 좋아짐.  
- **Factory / Builder** — 복잡한 생성 로직을 분리하여 테스트 코드 작성 편의 제공.  

---

## 4. 실전 워크플로우: TDD로 OO 클래스 도출하기 (단계별)
1. **작은 사용자 스토리 선택**: "계좌에서 출금할 수 있어야 한다."  
2. **Red — 실패하는 단위 테스트 작성**  
   ```java
   @Test
   void withdraw_reduces_balance() {
       BankAccount account = new BankAccount(10000);
       account.withdraw(3000);
       assertEquals(7000, account.getBalance());
   }
   ```
3. **Green — 최소 구현** (테스트가 통과하도록 가장 간단한 코드)
   ```java
   public class BankAccount {
       private int balance;
       public BankAccount(int initial) { this.balance = initial; }
       public void withdraw(int amount) { this.balance -= amount; }
       public int getBalance() { return balance; }
   }
   ```
4. **추가 테스트 추가**: 음수 금액 거부, 잔액 부족 시 예외 등(요구를 확장)
5. **Refactor — 책임 분리**  
   - `Money` 값 객체 도입  
   - `InsufficientFundsException` 처리  
   - 동시성 필요 시 `synchronized` 또는 트랜잭션 경계로 이동  
   - 외부 저장/연결이 필요하면 `AccountRepository` 인터페이스를 만들어 DI 주입  
6. **반복**: 새 요구마다 Red/Green/Refactor를 반복하여 클래스와 인터페이스가 자연스럽게 도출됨.

> 핵심: 처음에는 `구현`이 아닌 `행동(테스트)`을 먼저 작성 → 작은 동작 단위로 구현 → 필요해질 때만 추상화/인터페이스를 추가(과도한 추상화 회피, YAGNI 준수).

---

## 5. 예제 — 조건문을 전략(Strategy)으로 리팩터링 (TDD로 진행)

**문제**: 결제 수단에 따라 수수료 계산이 달라짐. 초기 테스트는 간단한 조건으로 통과시킨 뒤, 요구가 복잡해지면 전략 패턴으로 리팩터링.

1) Red: 카드 결제 수수료 테스트 작성
```java
@Test
void cardPayment_fee_is_2_percent() {
    Payment p = new Payment(PaymentType.CARD, 10000);
    assertEquals(200, FeeCalculator.calculateFee(p));
}
```
2) Green: 간단한 if 로직으로 구현(테스트 통과)
```java
public class FeeCalculator {
    public static int calculateFee(Payment p) {
        if (p.getType() == PaymentType.CARD) return p.getAmount() * 2 / 100;
        return 0;
    }
}
```
3) 새로운 요구: 해외카드는 3% → 테스트 추가, 이를 계기로 **Refactor**  
   - Extract Strategy 인터페이스 생성, 구체 전략 구현, 맵으로 선택하도록 리팩터링.
   - 테스트는 기존과 동일하게 동작하고, 새로운 전략 추가는 테스트 추가만으로 가능해짐.

TDD를 통해 `Replace Conditional with Strategy` 리팩터링을 안전하게 수행할 수 있습니다.

---

## 6. 단위 테스트가 설계를 어떻게 문서화하는가
- **테스트 = 실행 가능한 명세**: 각 단위 테스트는 클래스가 어떤 책임을 가져야 하는지(혹은 어떤 행동을 해야 하는지)를 문서화한다.  
- 새 팀원이 테스트를 보면 클래스의 계약(contract)을 이해할 수 있음.  
- BDD 스타일(Given-When-Then)로 작성하면 도메인 언어(Ubiquitous Language) 정렬에도 도움.

---

## 7. 주의할 점 — TDD의 한계와 오용
- **TDD가 자동으로 좋은 설계를 보장하지 않음**: 테스트만 많아도 설계가 엉성할 수 있음 — **Refactor를 게을리하면 안 됨**.  
- **구현 세부(구조) 테스트 금지**: 인터페이스/행동을 테스트하라 — 내부 구현(프라이빗 메서드) 테스트는 brittle함.  
- **과도한 Mocking 남용 주의**: 과도한 목 기반 테스트는 설계가 지나치게 분할되어 테스트가 구현 세부를 검증하게 만들 수 있음.  
- **느린 테스트(통합/외부 의존)로 TDD 사이클을 길게 만들면 효과 반감**: 단위 테스트는 빠르게, 통합 테스트는 별도 파이프라인에서.  
- **과도한 추상화(YAGNI 위반)**: 필요해질 때 추상화(인터페이스)를 만들어라 — TDD는 이 점을 지켜주기 좋음.

---

## 8. 모범 사례 체크리스트 (TDD + OO 설계)

- [ ] 요구(행동)를 테스트로 먼저 작성하는가?  
- [ ] Green 단계에서는 가능한 한 간단한 코드로 통과시키는가?  
- [ ] Refactor 단계에서 SRP·DIP·응집도·결합도 개선을 실행하는가?  
- [ ] 외부 의존은 인터페이스로 추상화하고 테스트 더블을 사용 가능한가?  
- [ ] 테스트는 빠르고 결정적인가(외부 네트워크/DB 없음)?  
- [ ] 테스트가 구현 상세에 강하게 결합되어 있지 않은가?  
- [ ] 테스트명과 Assertions가 행동을 잘 설명하는가? (문서화 역할)  
- [ ] 리팩토링 후에도 모든 테스트가 통과하는가? (자동화된 CI)

---

## 9. TDD와 SOLID 원칙의 연결 (요약)
- **S (SRP)**: 테스트를 쉽게 하려면 클래스 책임을 작게 유지 -> SRP 자연 준수.  
- **O (OCP)**: 새로운 요구가 테스트로 추가될 때 기존 코드 변경 없이 확장 가능한 구조로 리팩터링 유도.  
- **L (LSP)**: 상속을 사용할 때 하위 클래스의 행위를 테스트로 검증 가능 → LSP 위반 노출 가능.  
- **I (ISP)**: 테스트 편의를 위해 인터페이스를 세밀하게 분리하는 경향.  
- **D (DIP)**: 외부 의존을 추상화해 테스트 더블로 대체 — DIP 적용 촉진.

---

## 10. 결론 — 실무에서의 적용 팁
1. **작은 스토리/단위부터 시작**: 한 번에 큰 것을 테스트하려 하지 말고, 작은 행동부터.  
2. **빠른 피드백 루프 유지**: 단위 테스트는 초(혹은 1~2초 이내) 안에 돌아가도록.  
3. **테스트를 설계 문서로 활용**: 테스트는 코드의 계약이며 리팩토링 안전망.  
4. **Refactor를 게을리하지 말 것**: Green만으로 끝나면 설계가 나빠질 수 있음.  
5. **적절한 추상화 시점**: 테스트가 필요로 할 때 인터페이스를 도입하라 (Emergent Design).  
6. **팀 규약 수립**: 테스트 네이밍, 테스트 범위, Mock 사용 규칙 등 팀 합의 필요.

---

### 추가 자료(권장 읽기)
- Kent Beck — *Test-Driven Development: By Example*  
- Martin Fowler — *Refactoring*  
- Robert C. Martin — *Clean Code* / *Clean Architecture*  
- Eric Evans — *Domain-Driven Design* (TDD와 DDD 결합 사례 탐색에 유용)