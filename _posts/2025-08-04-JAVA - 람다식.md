---
layout: post
title: Java - 람다식
date: 2025-08-04 15:20:23 +0900
category: Java
---
# 자바 람다식(Lambda Expression)

## 람다 핵심 개념과 문법

### 기본 형태

```
(매개변수들) -> 표현식
(매개변수들) -> { 문장들; return 값; }
```
- 매개변수 1개라면 괄호 생략 가능: `x -> x * x`
- 바디가 **표현식**이면 암시적 반환, **블록**이면 `return` 필요

```java
Runnable r = () -> System.out.println("Hello");

Function<Integer,Integer> square = x -> x * x;

BiFunction<Integer,Integer,Integer> add = (a, b) -> a + b;

Function<Integer,Integer> fact = n -> {
    int res = 1;
    for (int i = 2; i <= n; i++) res *= i;
    return res;
};
```

---

## 함수형 인터페이스와 타깃 타입(Target Typing)

- 람다는 **타깃 타입**이 필요합니다. 즉, **단 하나의 추상 메서드(SAM)** 를 가진 인터페이스에 대입될 때 비로소 타입이 결정됩니다.

```java
@FunctionalInterface
interface MyFunc {
    int apply(int x);
}

MyFunc f = x -> x * 2; // MyFunc#apply(int) 구현
```

**주요 표준 인터페이스**
| 분류 | 시그니처 예 |
|---|---|
| `Predicate<T>` | `boolean test(T t)` |
| `Function<T,R>` | `R apply(T t)` |
| `UnaryOperator<T>` | `T apply(T t)` |
| `BinaryOperator<T>` | `T apply(T t1, T t2)` |
| `Consumer<T>` | `void accept(T t)` |
| `Supplier<T>` | `T get()` |
| `BiFunction<T,U,R>` | `R apply(T t, U u)` 등 |

> **주의**: SAM은 1개여야 하나, `default/static` 메서드는 여러 개 있어도 됩니다. `@FunctionalInterface`는 컴파일 타임 검증에 유용합니다.

---

## 매개변수 표기: 타입 생략/명시, `var`(JDK 11+), 애너테이션

- **타입 생략**(권장): 컴파일러가 컨텍스트로 추론
- **명시적 타입**: `(Integer a, Integer b) -> a + b`
- **`var` 사용**(JDK 11+): `(var a, var b) -> a + b`
  ↳ 파라미터 **모두** 같은 스타일(모두 `var` or 모두 생략/명시)을 써야 함
- 파라미터 애너테이션이 필요하면 `var` 또는 명시 타입과 함께 작성

```java
BiFunction<Integer,Integer,Integer> sum = (a, b) -> a + b;

BiFunction<Integer,Integer,Integer> sum2 = (Integer a, Integer b) -> a + b;

BiFunction<Integer,Integer,Integer> sum3 = (var a, var b) -> a + b;

// 애너테이션 예
Predicate<String> nonBlank = (@NotNull var s) -> !s.isBlank();
```

---

## 표현식 람다 vs 블록 람다

```java
Function<Integer,String> f1 = x -> "num:" + x;           // 표현식 → 암시적 반환
Function<Integer,String> f2 = x -> { return "num:" + x; }; // 블록 → 명시적 return
```

- **표현식**은 간결/인라인에 적합
- **블록**은 여러 문장/try-catch/조기 반환 등 로직이 길어질 때 사용
  ↳ 너무 복잡해지면 **명명된 메서드로 추출** 후 `::` 메서드 레퍼런스로 치환

---

## 메서드 레퍼런스(Method Reference)

람다를 더 간결히 쓰는 표기입니다.

| 형태 | 의미 | 예시 |
|---|---|---|
| `ClassName::staticMethod` | 정적 메서드 참조 | `Math::max`, `Integer::parseInt` |
| `instance::instanceMethod` | 특정 인스턴스의 메서드 | `printer::println` |
| `ClassName::instanceMethod` | 첫 번째 인자가 수신자 | `String::toLowerCase` (적용 시 컨텍스트가 `Function<String,String>`) |
| `ClassName::new` | 생성자 참조 | `ArrayList::new` (`Supplier<List>`로 추론) |
| `Type[]::new` | 배열 생성자 | `String[]::new` (`IntFunction<String[]>`) |

**정렬 예** (람다 → 메서드 레퍼런스):
```java
list.sort((s1, s2) -> Integer.compare(s1.length(), s2.length()));
list.sort(Comparator.comparingInt(String::length));
```

---

## 캡처와 스코프(Effectively final / this / 동시성)

### 로컬 변수 캡처 규칙

- 람다는 **로컬 변수**를 캡처할 수 있으나, 그 변수는 **final 또는 effectively final** 이어야 합니다.
- 이유: **가시성/안전성**(캡처 시점의 값을 스냅샷) 및 구현 제약

```java
int x = 10;
Runnable r = () -> System.out.println(x); // ok
// x = 11; // 컴파일 오류: 이미 람다에서 사용 → 더 이상 effectively final 아님
```

- 변경이 필요하면 **참조형 컨테이너**(예: `AtomicInteger`, 1-원소 배열) 사용

```java
AtomicInteger counter = new AtomicInteger(0);
Runnable inc = () -> counter.incrementAndGet();
```

### 필드 접근

- 인스턴스/정적 필드는 자유롭게 읽고 쓸 수 있습니다(캡처 제약 없음).
  단, **멀티스레드에선 동기화/원자성** 고려 필요.

```java
class A {
  int n = 0;
  Runnable r = () -> n++; // 동시성 환경에서는 원자성 주의
}
```

### `this` 의미 차이: 람다 vs 익명 클래스

- **람다 내부의 `this`** 는 **둘러싼 외부 인스턴스(Enclosing Instance)**.
- **익명 클래스에서 `this`** 는 익명 클래스 자신.

```java
class Outer {
  Runnable r1 = () -> System.out.println(this.getClass().getName()); // Outer
  Runnable r2 = new Runnable() {
    public void run() { System.out.println(this.getClass().getName()); } // 익명 클래스
  };
}
```

### 동시성 주의

- 람다가 **외부 가변 상태**를 캡처하고 병렬로 사용되면 레이스 컨디션 위험.
  → 불변/순수 함수 지향, 필요 시 `Atomic*`/락 사용.

---

## 예외(checked/unchecked) 처리 패턴

- 타깃 인터페이스 메서드가 체크 예외를 `throws` 하지 않으면, 람다 바디에서 해당 체크 예외를 **직접 던질 수 없음**.

```java
Callable<String> c = () -> { throw new IOException("IO"); }; // OK (Callable#call throws Exception)

Runnable r = () -> { throw new IOException("IO"); }; // 컴파일 오류 (Runnable#run 예외 선언 없음)
```

**해결 전략**
1) **try/catch** 로 람다 내부에서 처리/래핑
```java
Runnable r = () -> {
  try { doIO(); } catch (IOException e) { throw new UncheckedIOException(e); }
};
```
2) **예외 선언 있는 인터페이스**(예: `Callable`)로 시그니처 변경
3) **커스텀 함수형 인터페이스** 설계(throws 포함)
4) **유틸 래퍼**로 체크 예외 → 런타임 예외 변환

```java
@FunctionalInterface interface ThrowingFn<T,R> { R apply(T t) throws Exception; }
static <T,R> Function<T,R> sneaky(ThrowingFn<T,R> f) {
  return t -> { try { return f.apply(t); } catch (Exception e) { throw new RuntimeException(e); } };
}
Stream.of("1","x","3").map(sneaky(Integer::parseInt)).forEach(System.out::println);
```

---

## 오버로딩 모호성과 캐스팅

동일한 인수 형태로 여러 오버로드가 있으면 **타입 추론이 모호** → **명시적 캐스트**로 타깃 타입을 지정.

```java
void foo(Runnable r) {}
void foo(Callable<Integer> c) {}

foo((Callable<Integer>) () -> 1); // 모호성 해소
```

> 메서드 참조도 상황에 따라 다르게 해석됨. 필요 시 `(Function<String,Integer>) Integer::parseInt` 처럼 캐스트.

---

## 제네릭/원시형/합성(Compose)

### 제네릭과 타입추론

```java
Function<String,Integer> f = s -> s.length();
```
대부분 생략 가능하며, IDE가 추론을 돕습니다.

### 원시형 특화 인터페이스 (박싱 회피)

- `IntFunction<R>`, `ToIntFunction<T>`, `IntUnaryOperator`, `IntPredicate`, `ObjIntConsumer<T>` 등
  → **핫패스 수치 연산**은 박싱/언박싱 없는 특화형을 사용

```java
IntUnaryOperator twice = x -> x * 2;
int y = twice.applyAsInt(21);
```

### 합성/결합 API

- `Function#compose/andThen`, `Predicate#and/or/negate`, `Comparator#thenComparing`

```java
Function<String,Integer> len = String::length;
Function<String,Boolean> longAndEven = len.andThen(n -> n > 5).andThen(n -> n % 2 == 0);

Predicate<String> p = s -> s.startsWith("A");
Predicate<String> q = s -> s.endsWith("Z");
Predicate<String> pq = p.and(q).negate();
```

---

## Stream/Collectors/Optional과 람다

```java
List<String> names = List.of("Alice","Bob","Charlie","Dave");

List<String> result = names.stream()
  .filter(s -> s.length() > 3)      // Predicate
  .map(String::toUpperCase)         // Function
  .sorted(Comparator.comparingInt(String::length).reversed())
  .collect(Collectors.toList());
```

**그룹화/매핑/요약**
```java
Map<Integer, Long> countsByLen = names.stream()
  .collect(Collectors.groupingBy(String::length, Collectors.counting()));

IntSummaryStatistics st = names.stream()
  .collect(Collectors.summarizingInt(String::length));
```

**Optional 반환 터미널**
```java
Optional<String> firstWithC = names.stream()
  .filter(s -> s.startsWith("C"))
  .findFirst();
firstWithC.ifPresent(System.out::println);
```

---

## Executor/CompletableFuture와 람다

```java
ExecutorService pool = Executors.newFixedThreadPool(4);

CompletableFuture<Integer> f1 = CompletableFuture.supplyAsync(() -> cpuHeavy(1), pool);
CompletableFuture<Integer> f2 = CompletableFuture.supplyAsync(() -> cpuHeavy(2), pool);

CompletableFuture<Integer> sum = f1.thenCombine(f2, Integer::sum)
  .exceptionally(ex -> { log(ex); return -1; });

int ans = sum.join();
pool.shutdown();
```

**thenCompose vs thenApply**
```java
CompletableFuture<User> u = findUserAsync(id);
CompletableFuture<Account> a =
  u.thenCompose(user -> findAccountAsync(user)); // flatMap
```

**타임아웃/대체(JDK 9+)**
```java
CompletableFuture<String> v = fetchAsync()
  .completeOnTimeout("fallback", 2, TimeUnit.SECONDS)
  .orTimeout(5, TimeUnit.SECONDS);
```

> **주의**: I/O 블로킹 작업은 기본 `commonPool` 고갈 위험 → 반드시 **커스텀 Executor** 전달.

---

## 디버깅/가독성/리팩터링 팁

- 람다가 **2~3줄**을 넘기면 **명명된 메서드로 추출** + **메서드 레퍼런스**로 치환
- `peek`는 디버깅용. 비즈니스 로직 의존 금지
- 복잡한 조건은 **Predicate** 조합으로 분해
- 체크 예외 혼재 시, **변환 유틸**로 한곳에 모아 가독성 확보
- **오버로딩 모호성**은 캐스트로 명시적 해소

---

## 성능과 구현 관점

### 구현 개요

- 람다는 `invokedynamic` 부트스트랩(보통 `LambdaMetafactory`) 기반으로 **필요 시점에 구현 객체를 생성**
  → 클래스 파일 폭증 없이 가볍고, JIT 인라이닝에 유리

### 성능 팁

- **캡처 없는 람다**는 JVM이 **싱글턴**으로 재사용 가능 → 매우 저비용
- **캡처 람다**는 캡처한 **환경 객체에 대한 참조**를 저장 → 할당과 생존 시간 고려
- **원시형 특화 인터페이스**를 사용해 **박싱/언박싱** 제거
- 핫패스의 람다는 **메서드 레퍼런스**로 치환 시 인라이닝에 유리한 경우가 많음
- 미세 최적화는 **JMH** 같은 마이크로벤치로 검증

> 람다 **직렬화**: 기본적으로 직렬화 불가. 직렬화해야 한다면 **타깃 인터페이스가 `Serializable`** 이어야 하며, 람다 직렬화는 구현 세부에 의존하므로 **API 계약**으로 노출하지 않는 것이 안전.

---

## 안티패턴 체크리스트

- [ ] 람다 바디가 장문/복잡 → **메서드로 추출**(이름을 주고 테스트하기 좋게)
- [ ] 외부 가변 상태 캡처 → 불변/순수 함수 유지, 필요 시 동시성 컨트롤
- [ ] Stream 병렬 + 외부 리스트에 `forEach(add)` → 경쟁/오염 (→ `collect`)
- [ ] `Optional.get()` 남용 → `orElse/ifPresent/ifPresentOrElse`
- [ ] 체크 예외를 무분별하게 `RuntimeException`으로 래핑 → 적절한 도메인 예외 설계
- [ ] `Comparator`/`Predicate` 로직 중복 → 합성 API(`thenComparing`, `and`, `or`) 사용
- [ ] I/O 블로킹을 `commonPool`에 던짐 → **커스텀 풀**
- [ ] 오버로딩 모호성 방치 → **명시 캐스트**

---

## 실무 레시피 15선

### Comparator 체인

```java
list.sort(
  Comparator.comparing(Person::lastName)
            .thenComparing(Person::firstName)
            .thenComparingInt(Person::age));
```

### BiFunction 부분 적용(커링 유사)

```java
BiFunction<Integer,Integer,Integer> pow = (a,b) -> (int) Math.pow(a,b);
Function<Integer,Integer> square = b -> pow.apply(b, 2);
```

### 조건 결합

```java
Predicate<Order> expensive = o -> o.price() > 1000;
Predicate<Order> vip = o -> o.customer().isVip();
Predicate<Order> rule = expensive.and(vip).and(o -> !o.isCanceled());
```

### 안전 파싱

```java
Function<String, Optional<Integer>> tryParse =
  s -> { try { return Optional.of(Integer.parseInt(s)); } catch (NumberFormatException e) { return Optional.empty(); } };

List<Integer> ints = lines.stream().map(tryParse).flatMap(Optional::stream).toList();
```

### 파일 라인 처리(자원 자동 해제)

```java
try (Stream<String> lines = Files.lines(path)) {
  long errors = lines.filter(s -> s.contains("ERROR")).count();
}
```

### 동시 실행 + 결합

```java
ExecutorService ex = Executors.newFixedThreadPool(8);
CompletableFuture<Integer> a = supplyAsync(() -> calc(1), ex);
CompletableFuture<Integer> b = supplyAsync(() -> calc(2), ex);
int total = a.thenCombine(b, Integer::sum).join();
ex.shutdown();
```

### Function 합성으로 파이프라인 구성

```java
Function<String,String> trim = String::trim;
Function<String,String> toUpper = String::toUpperCase;
Function<String,String> normalize = trim.andThen(toUpper);
```

### 원시형 특화로 합계

```java
int sum = IntStream.of(1,2,3,4).map(x -> x * 2).sum();
```

### 그룹화 + 다운스트림 변환

```java
Map<Integer, Set<Character>> initialsByLen =
  words.stream().collect(Collectors.groupingBy(
    String::length,
    Collectors.mapping(s -> s.charAt(0), Collectors.toSet())
  ));
```

### 메서드 레퍼런스로 이벤트 핸들러

```java
button.addActionListener(evt -> handleClick(evt));
// → 메서드 분리
button.addActionListener(this::handleClick);
```

### Optional 파이프라인

```java
String street = Optional.ofNullable(person)
  .map(Person::getAddress)
  .map(Address::getStreet)
  .filter(s -> !s.isBlank())
  .orElse("N/A");
```

### 시간 제한 + 대체값

```java
String value = CompletableFuture.supplyAsync(this::remoteCall, ex)
  .completeOnTimeout("fallback", 300, TimeUnit.MILLISECONDS)
  .join();
```

### 예외 변환 유틸 적용

```java
Stream<String> lines = Files.lines(path); // checked
try (lines) {
  lines.map(sneaky(this::parse)).forEach(System.out::println);
}
```

### 인덱스 부여(스트림)

```java
List<String> list = List.of("a","b","c");
Map<Integer,String> indexed =
  IntStream.range(0, list.size()).boxed()
    .collect(Collectors.toMap(i -> i, list::get));
```

### 커스텀 DSL 흉내

```java
interface Step { Step then(Runnable r); }
static Step start(Runnable r) { r.run(); return next -> { next.run(); return start(() -> {}); }; }
start(() -> log("A")).then(() -> log("B")).then(() -> log("C"));
```

---

## 요약

- 람다는 **함수형 인터페이스의 구현**이며, **타깃 타입**으로 의미가 정해집니다.
- **캡처 규칙**(effectively final), **this 스코프**, **체크 예외** 제약을 이해해야 안전합니다.
- **메서드 레퍼런스**·**합성 API**로 가독성을 높이고, **원시형 특화 인터페이스**로 박싱을 줄이세요.
- Stream/CompletableFuture와 결합해 **선언적 데이터 처리/비동기 파이프라인**을 구축하되, **동시성/리소스/성능**을 실측으로 관리하세요.
- 복잡한 람다는 **명명된 메서드로 추출**하여 테스트 가능성과 유지보수성을 확보하는 것이 최선입니다.
