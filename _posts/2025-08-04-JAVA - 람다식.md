---
layout: post
title: Java - 람다식
date: 2025-08-04 15:20:23 +0900
category: Java
---
# 람다식(Lambda Expression)의 기본 문법 — 자세 정리

Java의 람다식은 **함수형 프로그래밍 스타일**을 지원하기 위해 도입된 문법으로, 익명 함수(anonymous function)를 간결하게 표현합니다. 주로 **함수형 인터페이스(Functional Interface)**의 구현을 대체하며, 컬렉션 처리나 비동기/스트림 API와 함께 매우 자주 사용됩니다.

아래는 문법, 동작 원리, 예제, 주의사항, 모범 사용법을 체계적으로 정리한 내용입니다.

---

## 1. 기본 문법 형태

람다의 일반 형식:

```
(매개변수 목록) -> { 바디 }
```

- 매개변수 목록은 괄호로 감싼다(매개변수가 하나인 경우 괄호 생략 가능).
- 바디는 **표현식(expression)** 또는 **블록(block)** 으로 작성할 수 있다.
  - 표현식 람다: `x -> x * x` (암시적으로 결과 반환)
  - 블록 람다: `x -> { return x * x; }` (명시적 `return` 필요)

### 예제

```java
// 매개변수 없음
Runnable r = () -> System.out.println("Hello");

// 매개변수 1개 (괄호 생략 가능)
java.util.function.Function<Integer, Integer> square = x -> x * x;

// 매개변수 여러개
java.util.function.BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

// 블록 람다 (여러 문장, 명시적 return)
java.util.function.Function<Integer, Integer> fact = n -> {
    int result = 1;
    for (int i = 2; i <= n; i++) result *= i;
    return result;
};
```

---

## 2. 대상 타입(Target typing) — 함수형 인터페이스

- 람다는 **타입이 있는(target typed)** 표현식입니다. 람다 자체에는 타입 정보가 없고 **어떤 함수형 인터페이스에 할당되느냐**에 따라 파라미터/반환 타입이 결정됩니다.
- **함수형 인터페이스(Function Interface)**: 추상 메서드가 하나뿐인 인터페이스(SAM — Single Abstract Method). `@FunctionalInterface` 어노테이션으로 명시 가능(선택).

```java
@FunctionalInterface
interface MyFunc {
    int apply(int x);
}

MyFunc f = x -> x * 2; // MyFunc의 apply(int)을 구현
```

대표 Java 표준 함수형 인터페이스:
- `Predicate<T>` : `boolean test(T t)`
- `Function<T,R>` : `R apply(T t)`
- `Consumer<T>` : `void accept(T t)`
- `Supplier<T>` : `T get()`
- `UnaryOperator<T>`, `BinaryOperator<T>`
- `BiFunction<T,U,R>`, `BiConsumer<T,U>` 등

---

## 3. 매개변수 타입과 형식

- 매개변수 타입은 **컴파일러가 추론**하므로 보통 생략한다.

```java
BiFunction<Integer, Integer, Integer> sum = (a, b) -> a + b; // 타입 생략
```

- 명시적으로 타입을 적을 수도 있다:

```java
BiFunction<Integer, Integer, Integer> sum = (Integer a, Integer b) -> a + b;
```

- Java 11+에서는 `var` 사용 가능(모든 파라미터에 `var`를 써야 함):

```java
BiFunction<Integer, Integer, Integer> sum = (var a, var b) -> a + b;
```

---

## 4. 표현식 람다 vs 블록 람다

- **표현식 람다**: `x -> x * 2` — 표현식 결과가 반환된다.
- **블록 람다**: `{ ... }` — 여러 문장 가능, `return`을 통해 값을 반환해야 함.

```java
Function<Integer,String> f1 = x -> "num:" + x;         // 표현식 람다
Function<Integer,String> f2 = x -> { return "num:" + x; }; // 블록 람다
```

---

## 5. 메서드 레퍼런스(Method Reference) — 람다의 축약형

람다 표현식을 더 간결히 쓰는 방법:
- `ClassName::staticMethod`
- `instance::instanceMethod`
- `ClassName::instanceMethod` (첫 번째 매개변수가 호출 대상)
- `ClassName::new` (생성자 레퍼런스)
- `Type[]::new` (배열 생성자 레퍼런스)

```java
List<String> list = Arrays.asList("a", "bb", "ccc");

// 람다
list.sort((s1, s2) -> Integer.compare(s1.length(), s2.length()));

// 메서드 레퍼런스 (더 간결)
list.sort(Comparator.comparingInt(String::length));

// 생성자 레퍼런스 예
Supplier<ArrayList<String>> sup = ArrayList::new;
```

---

## 6. 캡처(Capturing)와 스코프

### 로컬 변수 캡처
- 람다는 **로컬 변수(지역변수)**를 캡처할 수 있지만, **final 이거나 사실상(final) 이어야** 한다.
  - 즉, **effectively final**: 초기화 후 변경되지 않는 변수.
- 이유: 안전한 가시성(메모리 모델) 및 구현상의 제약.

```java
int x = 10;
Runnable r = () -> System.out.println(x); // OK (x는 effectively final)
x = 11; // 컴파일 오류: 이미 람다에서 사용된 x를 변경할 수 없음
```

- 로컬 변수를 바꿔야 하면 `AtomicInteger`나 배열 같은 참조형을 이용:

```java
AtomicInteger counter = new AtomicInteger(0);
Runnable r = () -> counter.incrementAndGet(); // 가능
```

### 필드(인스턴스/정적 변수)
- 인스턴스 필드나 정적 필드는 자유롭게 읽고 쓸 수 있다(람다는 객체의 일부가 아니므로).
- 다만 동시성 문제는 별도 고려(동기화/원자성 필요).

```java
class A {
    int n = 0;
    Runnable r = () -> n++; // 가능 (동시성 주의)
}
```

### this의 의미
- **람다식 내부의 `this`는 람다를 둘러싼(외부) 인스턴스를 가리킨다.**
- 반면 익명 클래스에서는 `this`가 익명 클래스 자신의 인스턴스를 가리킨다.

```java
class Outer {
    Runnable r1 = () -> System.out.println(this.getClass().getName()); // Outer
    Runnable r2 = new Runnable() {
        public void run() { System.out.println(this.getClass().getName()); } // 익명 클래스
    };
}
```

---

## 7. 예외 처리는 함수형 인터페이스의 시그니처에 따름

- 람다 바디에서 발생 가능한 **체크 예외(checked exception)** 는 **타깃 함수형 인터페이스의 추상 메서드**가 해당 체크 예외를 `throws`로 선언해야만 허용된다.

```java
// Callable.call()은 throws Exception을 선언하므로 허용
Callable<String> c = () -> { throw new IOException("IO"); }; // OK

// Runnable.run()은 checked 예외 선언이 없으므로 컴파일 에러
Runnable r = () -> { throw new IOException("IO"); }; // 컴파일 오류
```

- 해결: 예외를 잡아서 처리하거나, 함수형 인터페이스가 예외를 선언하도록 하거나, 체크 예외를 런타임 예외로 래핑.

---

## 8. 오버로딩과 모호성(Overloading / Ambiguity)

- 동일한 인수 형태로 여러 오버로드된 메서드가 있고 람다를 전달하면 **타입 추론이 모호**해 컴파일 에러가 날 수 있다. 이때는 **명시적 캐스트**로 타깃 타입을 지정하면 해결된다.

```java
void foo(Runnable r) { ... }
void foo(Callable<Integer> c) { ... }

// foo(() -> 1); // 모호(런타임 상 어떤 타입인지 추론 불가)
// 해결:
foo((Callable<Integer>) () -> 1);
```

---

## 9. 자동 박싱/언박싱, 제네릭과 람다

- 람다는 제네릭 컨텍스트에서도 잘 작동한다. 제네릭 함수형 인터페이스에 대한 타입 인퍼런스가 동작하므로 대부분 타입을 생략할 수 있다.

```java
Function<String, Integer> f = s -> s.length();
List<String> list = ...
list.stream().map(String::length).forEach(System.out::println);
```

---

## 10. 성능 관점 (간단한 이해)
- Java의 람다는 `invokedynamic` 기반으로 구현되어 런타임에서 필요시 컨버터블 구현 객체를 생성한다.  
- 빈번한 생성/캡처 없는 람다는 JVM이 재사용/싱글턴화할 수 있어 큰 오버헤드가 없다.  
- 하지만 **복잡한 로직을 람다에 넣어 가독성이 떨어지면 안 됨** — 테스트/디버깅이 어려워질 수 있음.

---

## 11. 실전 예제: Stream API와 조합

```java
List<String> names = List.of("Alice", "Bob", "Charlie", "Dave");

// filter + map + collect
List<String> result = names.stream()
    .filter(s -> s.length() > 3)        // Predicate<String>
    .map(String::toUpperCase)          // Function<String,String>
    .collect(Collectors.toList());
```

---

## 12. 메서드 레퍼런스와 람다의 선택 기준

- **메서드 레퍼런스**는 람다 표현식을 더 간결하게 만들며 가독성이 좋을 때 사용.
- 복잡한 제어 흐름(예: 여러 문장, 예외 처리 등)은 **블록 람다**로, 복잡한 로직은 **명명된 메서드**로 분리하는 것이 유지보수에 유리.

---

## 13. @FunctionalInterface와 기본/정적 메서드

- 함수형 인터페이스는 하나의 추상 메서드를 가져야 하지만, `default`나 `static` 메서드는 가질 수 있다.
- `@FunctionalInterface` 어노테이션은 컴파일 타임에 해당 규칙을 검증하게 해준다(선택적).

```java
@FunctionalInterface
interface Converter<F,T> {
    T convert(F from);
    default void log(String s) { System.out.println(s); }
}
```

---

## 14. 팁 & 권장사항

- **간결하고 단일 책임**: 람다는 간단한 동작에 사용하라. 긴 로직은 별도 메서드로 분리.
- **예외 처리 명확화**: 체크 예외를 던지는 경우 설계를 명확히(예: Callable 사용).
- **스코프와 캡처 주의**: 로컬 변수의 'effectively final' 규칙을 기억하라.
- **메서드 레퍼런스 우선**: 가독성 향상을 위해 가능하면 `Class::method` 형태 사용.
- **오버로딩 주의**: 모호성이 생기면 명시적 캐스트로 해결.

---

## 15. 요약 체크리스트

- 람다 = `(params) -> expression` 또는 `(params) -> { statements }`
- 람다는 **함수형 인터페이스**의 구현으로 사용됨 (타깃 타입 중요)
- 로컬 변수는 **final 또는 effectively final** 이어야 캡처 가능
- `this`는 람다의 **외부 인스턴스**를 가리킴 (익명 클래스와 차이)
- 메서드 레퍼런스는 간결한 대체 수단: `Class::static`, `instance::method`, `Class::instanceMethod`, `Class::new`
- 체크 예외는 함수형 인터페이스의 `throws` 시그니처를 따라야 함
