---
layout: post
title: CSS - CSS 성능 최적화
date: 2025-05-20 20:20:23 +0900
category: CSS
---
# CSS 성능 최적화 팁

## 1. 미사용 CSS 제거 & 번들 최소화

### 문제
- 거대한 CSS는 **파싱·CSSOM 생성 시간**을 늘려 **First Contentful Paint(FCP)** 지연.

### 해결
- **PurgeCSS/LightningCSS** 등으로 미사용 셀렉터 제거.
- 빌드 시 **cssnano/clean-css**로 Minify.
- 라우트/페이지 단위로 **Code-Splitting**.

```bash
# 예: PostCSS + cssnano
npx postcss src/styles.css -o dist/styles.min.css -u cssnano
```

```js
// 예: Vite/webpack에서 라우트별 CSS 분리 (각 엔트리마다 import)
import './route-home.css'
import './route-dashboard.css'
```

---

## 2. Critical CSS: 위-폴드(above the fold) 우선

### 핵심
“첫 화면을 그리는 데 필요한 최소 CSS”만 **인라인**하고, 나머지는 **비차단**으로 늦게 로드한다.

```html
<!-- 1) Critical CSS 인라인 -->
<style>
  .hero { background:#000; color:#fff; min-height:60vh; display:grid; place-items:center; }
</style>

<!-- 2) 비차단 로딩 패턴 -->
<link rel="preload" as="style" href="/assets/app.css" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="/assets/app.css"></noscript>
```

> `rel="preload"`는 **필요한 리소스만 정확히** 지정한다. 과도한 preload는 다른 중요한 리소스를 밀어낼 수 있다.

---

## 3. 선택자 성능: “짧고, 명확하고, 예측 가능하게”

브라우저는 **오른쪽에서 왼쪽**으로 선택자를 매칭한다. 깊은 후손 지정은 매칭 대상을 폭발시킨다.

| 선택자 예 | 비용 추정 |
|---|---|
| `div div div span` | ❌ 매우 비효율 |
| `.menu > li > a` | ⚠ 중간 |
| `.btn-primary` | ✅ 좋음 |
| `#siteHeader` | ✅ 매우 빠름 |

**전략**
- **BEM/유틸리티**로 클래스 직접 타깃팅.
- `:not()`, `:has()`는 **선택적**으로 사용(가독성/특정성 관리가 우선).
- **Cascade Layers**(아래)로 특이성 경쟁을 피한다.

```css
/* 과도한 후손 선택 지양 */
.header nav ul li a { ... }

/* 권장: 컴포넌트 루트 클래스에 묶기 */
.nav__link { ... }
```

---

## 4. 레이아웃 트리거(리플로우) 줄이기

다음 속성은 **레이아웃 재계산**을 유발한다: `width/height`, `margin/padding`, `top/left`, `display`, `position`, `float`, `font-size`…

### 대안: 컴포지트 친화 속성
- 가능하면 **`transform`/`opacity`** 로 UI 변화를 표현 → **레이아웃/페인트 없이** 컴포지트만 수행.

```css
/* ✅ transform/opacity 전환 */
.modal {
  transform: translateY(16px);
  opacity: 0;
  transition: transform .24s ease, opacity .24s ease;
}
.modal--open { transform:none; opacity:1; }
```

---

## 5. 애니메이션 최적화

- `transition: all` 지양 → **변하는 속성만** 지정.
- `will-change`는 **짧게·선별적으로**(과하면 메모리 낭비/레스터라잇 증가).

```css
/* 나쁜 예 */
.card { transition: all .3s ease; }

/* 좋은 예 */
.card { transition: box-shadow .2s ease, transform .2s ease; }

/* will-change: 이벤트 직전 활성화, 종료 시 해제 */
.tooltip[aria-hidden="false"] { will-change: transform, opacity; }
```

**움직임 축소 선호** 반영(접근성):

```css
@media (prefers-reduced-motion: reduce) {
  * { animation: none !important; transition: none !important; }
}
```

---

## 6. 렌더링 영역 줄이기: `content-visibility`/`contain`

긴 목록·폴드 밖 콘텐츠의 **스타일 계산/레이아웃/페인트**를 건너뛴다.

```css
.article {
  content-visibility: auto;
  contain-intrinsic-size: 600px; /* 예상 높이 힌트로 레이아웃 점프 방지 */
}
```

**추가 컨테인먼트**

```css
.card {
  contain: layout paint;                 /* 외부 레이아웃 영향 차단 */
  contain-intrinsic-size: 300px 200px;   /* 초기 가상 크기 */
}
```

---

## 7. 이미지 최적화(CSS 관점)

- `image-set()`으로 DPR 대응, `object-fit`으로 크롭 비용 최소화.
- 적절한 **백그라운드 vs `<img>`** 선택: 콘텐츠 의미가 있으면 `<img>` + `srcset/sizes`.

```css
.hero {
  background-image: image-set(
    url("/img/hero.avif") type("image/avif") 1x,
    url("/img/hero@2x.avif") type("image/avif") 2x
  );
  background-size: cover; background-position: center;
}
.gallery img { width:100%; height:auto; display:block; object-fit:cover; }
```

---

## 8. 웹폰트: 지연·깜빡임(FOUT/FOIT) 최적화

- `preload` + `font-display: swap|optional` 조합.
- 서브셋 분리(라틴/한글 등), 가변 폰트는 축 범위를 최소화.

```html
<link rel="preload" as="font" href="/fonts/Inter.var.woff2" type="font/woff2" crossorigin>
```

```css
@font-face{
  font-family: Inter;
  src: url("/fonts/Inter.var.woff2") format("woff2-variations");
  font-weight: 100 900;
  font-display: swap; /* 초기 시스템 폰트 → 로드 후 교체 */
}
```

---

## 9. 네트워크·로딩 전략

- **HTTP/2+ 환경**에서는 “과도한 병합”보다 **지연 로딩/분할**이 유리할 수 있다.
- `media` 속성으로 **조건부 스타일**은 차단 최소화.

```html
<link rel="stylesheet" href="/print.css" media="print">
<link rel="stylesheet" href="/wide.css" media="(min-width: 1024px)">
```

---

## 10. CSS 변수로 중복 제거 & 런타임 전환

- **테마·스케일**을 변수로 통일 → 재계산 범위가 **선택적**으로 제한.

```css
:root{
  --space: 1rem;
  --radius: .5rem;
  --brand: #2563eb;
}
.card{ padding: var(--space); border-radius: var(--radius); }
.btn{ background: var(--brand); }
```

다크 모드/테마 토글 시 **클래스/속성 루트 변경**만으로 전체 반영:

```css
[data-theme="dark"]{ --brand:#60a5fa; }
```

---

## 11. Cascade Layers(@layer)로 특이성 경쟁 종료

- 프레임워크 → 컴포넌트 → 유틸 → 오버라이드 순으로 **레이어** 정의.

```css
@layer reset, base, components, utilities, overrides;

@layer reset { /* normalize/resets */ }
@layer base { html, body { font: 16px/1.5 system-ui; } }
@layer components { .button{ ... } }
@layer utilities { .mt-2{ margin-top:.5rem } }
@layer overrides { .button--danger{ ... } }
```

> 레이어는 **선언 순서로 우선순위**가 결정되므로, 무의미한 `!important` 남발을 줄인다 → **매칭·재계산도 단순화**.

---

## 12. 레이아웃 시스템: Flex/Grid, 갭, 논리 속성

- 플로트/마진 계산 대신 **Flex/Grid**로 구문 단순화 → 계산 비용·버그 감소.
- `gap`으로 간격 관리(폴백 필요 시 margin 전략).

```css
.grid{
  display:grid;
  grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
  gap: 1rem;
  contain: layout paint;   /* 카드가 많을 때 컨테인먼트 */
}
```

**논리 속성**으로 방향성 비용 감소(국제화):

```css
.card{ padding-block:1rem; padding-inline:1rem; }
```

---

## 13. 미디어 쿼리: 중복을 변수/믹스인으로 제거

```scss
/* SCSS 예시 */
$bp-md: 768px;
@mixin up($w){ @media (min-width: $w){ @content; } }

.card{ font-size:1rem;
  @include up($bp-md){ font-size:1.125rem; }
}
```

> 프로젝트 전역 **단일 소스(토큰)** 로 브레이크포인트를 관리하면, **조건 재계산과 중복**을 줄여 유지보수가 쉬워진다.

---

## 14. DevTools로 병목 찾아내기

- **Performance**: 레이아웃/페인트/스레드 활동 타임라인.
- **Coverage**: 로딩된 CSS 중 **사용/미사용 바이트** 비율.
- **Layers/Rendering**: 레이어 수, 스크롤 성능, FPS 드롭 지점.

```txt
절차:
1) Performance Record(3~5초)
2) Layout thrashing 구간(다수의 Layout 이벤트) 확인
3) 해당 구간 요소의 스타일 변화를 transform/opacity로 치환
4) Coverage로 route별 미사용 CSS 제거
```

---

## 15. 대형 리스트/피드: CSS로 “가짜 가상화”

가상 스크롤이 어려운 정적 페이지라도 **CSS 만으로 초기 비용**을 줄일 수 있다.

```css
.feed-item{
  content-visibility: auto;
  contain-intrinsic-size: 320px; /* 예상 높이 */
  margin-block: 1rem;
}
```

> 실제 가상화(IntersectionObserver/리사이클링)와 조합하면 **스타일 계산량**이 급감.

---

## 16. 폴백 설계(@supports, :where/:is)

신기능 사용 전 **기능 감지**로 안전하게 분기한다.

```css
@supports (content-visibility: auto) {
  .fold { content-visibility: auto; contain-intrinsic-size: 500px; }
}
@supports not (content-visibility: auto) {
  .fold { min-height: 500px; }
}
```

특이성 0으로 기본 스타일:

```css
:where(.btn){ /* specificity 0 */ padding:.75rem 1rem; border-radius:.5rem; }
.btn--primary{ background:#2563eb; color:#fff; }
```

---

## 17. 실전 예제 — “카드 그리드 + 스켈레톤 + 콘텐츠 가시화”

```html
<section class="cards">
  <article class="card is-loading">
    <div class="card__media"></div>
    <div class="card__title"></div>
    <div class="card__text"></div>
  </article>
  <!-- ... 반복 -->
</section>
```

```css
@layer base, components, utilities;

@layer base {
  :root{
    --space: 1rem; --radius:.75rem; --shadow:0 1px 3px rgba(0,0,0,.08);
  }
  .cards{
    display:grid; gap: var(--space);
    grid-template-columns: repeat(auto-fill, minmax(240px,1fr));
    padding: var(--space);
    content-visibility: auto; /* 카드 많아도 초기 비용 감소 */
  }
}

@layer components {
  .card{
    display:flex; flex-direction:column; gap:.5rem;
    border-radius: var(--radius); box-shadow: var(--shadow);
    overflow:hidden; background:#fff;
    contain: layout paint; /* 개별 카드 컨테인먼트 */
  }
  .card__media{ aspect-ratio: 16/9; background:#f3f4f6; }
  .card__title{ height:1rem; margin:.5rem var(--space) 0; background:#e5e7eb; border-radius:.25rem; }
  .card__text{ height:.75rem; margin:0 var(--space) var(--space); background:#e5e7eb; border-radius:.25rem; }
  .is-loading .card__title,
  .is-loading .card__text { animation: pulse 1.2s ease-in-out infinite; }
  @keyframes pulse { 50% { opacity:.5; } }
}

@layer utilities{
  .fade-in{ opacity:0; transform: translateY(8px); will-change:transform,opacity;
            transition: opacity .2s ease, transform .2s ease; }
  .fade-in.is-visible{ opacity:1; transform:none; will-change:auto; }
}
```

> 스켈레톤은 **페인트 비용이 낮은 단색+가벼운 애니메이션**으로 구현한다. 이미지가 로드되면 `.is-loading` 제거 → `.fade-in` 적용.

---

## 18. 반응형 타이포 & 간격: `clamp()` 한 방에

미디어 쿼리를 남발하지 않고, **가변 + 최소/최대** 범위를 동시에 만족.

```css
h1{ font-size: clamp(1.5rem, 2vw + 1rem, 2.5rem); }
.section{ padding-block: clamp(1rem, 2vw, 2rem); }
```

> 레이아웃 조정이 **폰트/간격 변경만으로 해결**되면 레이아웃 재계산을 크게 줄인다.

---

## 19. 생산성 & 유지보수: 토큰·유틸·레이어의 삼각형

- **디자인 토큰**(색/간격/타이포)을 CSS 변수로.
- **유틸리티 클래스**로 반복 제거(빌드 시 사용량 제한).
- **@layer**로 병합 순서와 오버라이드 전략을 **명시**.

이 구조는 **특이성 전쟁**을 끝내고, 결과적으로 **재계산/매칭 복잡도**를 낮춘다.

---

## 20. 성능 회귀 방지: 자동화

- CI에서 **Lighthouse**/“Coverage 비율”/“CSS 바이트” **게이트** 설정.
- 번들러 통계(rollup/webpack analyze)로 **라우트별 CSS 크기** 모니터링.
- “새 컴포넌트 추가 시 **토큰/유틸 우선**” 팀 규칙.

---

## 부록 A) 실무 템플릿

### A-1. 비차단 로딩 & 프린트/와이드 분리

```html
<style>/* critical.css */</style>
<link rel="preload" as="style" href="/css/app.css" onload="this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="/css/app.css"></noscript>

<link rel="stylesheet" href="/css/print.css" media="print">
<link rel="stylesheet" href="/css/wide.css" media="(min-width: 1200px)">
```

### A-2. 전역 유틸

```css
/* 레이아웃 디버그 */
.debug *:hover { outline:1px dashed rgba(200,0,0,.5); }

/* 길이/텍스트 처리 */
.ellipsis { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.break { overflow-wrap:break-word; }

/* 스크롤/터치 */
.touch { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

/* 안전한 flex 자식 */
.flex-safe > * { min-width:0; min-height:0; }
```

---

## 결론

CSS 성능 최적화는 **규칙 몇 가지**로 압축된다.

1) **필요한 CSS만** 로드하고, **초기 페인트**를 앞당겨라.  
2) 런타임 변화는 **transform/opacity** 중심으로, 레이아웃 재계산을 피하라.  
3) **content-visibility/contain**으로 계산 범위를 줄여라.  
4) **선택자 단순화 + 레이어링 + 토큰화**로 매칭·특이성 복잡도를 제거하라.  
5) **DevTools로 반복 측정**하고, CI에 **성능 게이트**를 박아 회귀를 막아라.

이 다섯 가지만 꾸준히 지키면 **FCP/LCP/CLS**가 자연히 개선되고, 팀의 CSS도 가벼워진다.

---

## 참고 자료

- Google web.dev — Rendering & performance  
- MDN — CSS Containment / content-visibility / Cascade layers  
- CSS-Tricks — Efficient CSS Selectors, Critical CSS, image-set  
- Chrome DevTools — Performance/Coverage/Rendering 패널 가이드