---
layout: post
title: 정보보안기사 - 침입탐지시스템, 침입차단시스템
date: 2025-11-13 21:25:23 +0900
category: 정보보안기사
---
# SECTION 13 보안장비 운영 — 침입탐지시스템(Snort) · 침입차단시스템(iptables) 실전

## 개요 — IDS/NIDS와 패킷 필터의 역할 차이
- **Snort**: 네트워크 트래픽을 **분석**하여 **침입 징후를 탐지/경보**(NIDS/IPS)하는 소프트웨어. **규칙(rule)** 기반, 서명(Signature)·프로토콜·이상행동 탐지. Snort 3(일명 Snort++)가 현행 주류이며 **Lua 기반 설정/규칙 확장**, **JSON/unified2** 등 다양한 로깅을 지원한다.
- **iptables**: 리눅스 커널의 **netfilter**를 제어하는 사용자 공간 도구. **패킷 필터(방화벽)**, NAT, 로깅 등 **정책에 따라 트래픽을 허용/차단**한다. 최근 커널에서는 **nftables**가 후속으로 쓰이며, 많은 배포판은 **iptables-nft** 백엔드로 iptables 문법을 **nftables 규칙으로 변환**해 적용한다.

> 운영 포인트
> - **Snort = 탐지/경보(가시성, 규칙지식)**, **iptables = 차단/허용(경계 정책)**
> - 실전에서는 “**Snort(탐지) → SIEM/경보 → iptables(차단)**” 식으로 **연동**한다.

---

## 01. 침입탐지시스템 — Snort 3

### 1. 설치/배포 옵션(최신 동향 반영)
- **패키지/소스**: 배포판에 따라 Snort 2가 기본인 경우가 있으므로 **Snort 3**를 명시 설치하거나 **컨테이너** 사용이 간편하다. Snort 공식이 **Snort 3 Docker** 가이드를 제공한다.
- **의존성**: Hyperscan, LuaJIT 등. 소스 빌드 시 문서의 **Required Packages**를 확인한다.

#### (권장) Docker로 빠른 실습
```bash
# 예시: Snort 3 공식/커뮤니티 이미지 (이미지 이름은 환경에 맞게 교체)
docker run --rm -it --net=host \
  -v $PWD/snort:/etc/snort \
  -v $PWD/logs:/var/log/snort \
  snort3:latest \
  -c /etc/snort/snort.lua -i eth0
```
> `--net=host`는 로컬 NIC 트래픽 실시간 보기 용도의 예시. 운영 환경에서는 TAP/SPAN이나 미러 포트를 연결.

### 2. Snort 3의 핵심 구성요소
- **엔진/DAQ**: 패킷 캡처(PCAP/live), 스트림 재조립, 디코더/대응 모듈.
- **규칙(규칙 헤더 + 옵션)**: Snort 3 규칙은 **헤더(행동·프로토콜·주소·포트·방향)** + **본문(페이로드/비페이로드 옵션)**으로 구성. 규칙은 `.rules` 파일, **Lua config** 내 포함, 혹은 CLI 전달 가능.
- **출력(로깅)**: **JSON / unified2 / CSV / fast/full** 등 선택 가능. 보통 **JSON**을 SIEM에 연동하거나 **unified2**를 외부 파서에 물린다.

### 3. 최소 설정 템플릿(snort.lua)
```lua
-- /etc/snort/snort.lua (요약 템플릿; 실제 환경에 맞게 경로/네트워크 수정)
HOME_NET = '192.168.1.0/24'
EXTERNAL_NET = '!$HOME_NET'

-- 로깅(예: JSON 파일)
alert_json =
{
  file = true,
  filename = '/var/log/snort/alerts.json'
}

-- 디코더/스트림 기본
include 'snort_defaults.lua'
include 'file_magic.lua'

-- 규칙 경로 및 로드
ips =
{
  mode = 'inline',             -- 스니퍼/패킷로거/IPS 모드 중 선택 (실습은 'autodetect'/'passive'도 가능)
  variables = default_variables,
  enable_builtin_rules = true, -- 내장 규칙 사용
  rules = [[
    include /etc/snort/rules/local.rules
  ]]
}

-- 출력
alert_json = alert_json
```

### 4. 로컬 규칙 예제(local.rules)

#### (A) ICMP Ping 탐지
```conf
alert icmp any any -> $HOME_NET any (msg:"ICMP Echo Request to HOME"; itype:8; sid:1000001; rev:1;)
```

#### (B) 단순 포트 스캔 신호(짧은 시간 다중 포트 SYN)
```conf
alert tcp $EXTERNAL_NET any -> $HOME_NET 1:65535 \
 (msg:"Possible port scan"; flags:S; threshold:type both, track by_src, count 10, seconds 3; sid:1000002; rev:1;)
```

#### (C) HTTP 악성 User-Agent 패턴
```conf
alert http $EXTERNAL_NET any -> $HOME_NET 80 \
 (msg:"Suspicious UA"; content:"User-Agent|3a 20|curl/"; http_header; nocase; sid:1000003; rev:1;)
```

> 규칙 구조/옵션 키는 Snort 3 Rule Writing Guide를 참고(새 Rule 유형, 옵션 키, 헤더/본문 구분 등).

### 5. 실행/테스트
```bash
# 규칙 검사
snort -c /etc/snort/snort.lua -T

# 라이브 인터페이스 모니터링(테스트)
snort -c /etc/snort/snort.lua -i eth0

# 트리거: ICMP
ping -c 1 192.168.1.10

# 트리거: HTTP UA
curl -A "curl/7.88 test" http://192.168.1.20/
```

- **로그**: `/var/log/snort/alerts.json` (예시). JSON 필드는 설정 순서대로 출력된다.

### 6. PCAP 재생 기반 리그레션
```bash
# 공격 PCAP(예: 샘플)을 특정 인터페이스로 재생
tcpreplay --intf1=eth0 samples/attack-and-normal.pcap
```
- Snort는 PCAP에서 이벤트를 생성. CI에서 **“규칙 업데이트 → PCAP 재생 → 기대 알람 비교”**로 회귀 테스트.

### 7. 운영형 팁 — 룰 운영·성능/가시성
- **룰 소스**: 커뮤니티/구독 룰 번들 + 로컬 룰. Snort 2 → 3 전환 시 `snort2lua`로 변환 지원.
- **출력 설계**: JSON(가공/전송 쉬움), unified2(성능/푸시) 중 택1 또는 병행. SIEM/로그 파이프라인(NXLog/Fluent/etc.) 연계.
- **성능**: **Hyperscan**(멀티패턴 매칭) 사용, 필요 룰만 활성화, HTTP/SSL/TLS 등 애플리케이션 디코더 최소화, 오탐 줄이는 **threshold/suppress** 적극 활용.

---

## 02. 침입차단시스템 — iptables (netfilter)

### 1. 구조 이해(테이블/체인/타깃)
- **테이블**: `filter`(기본 차단/허용), `nat`(주소/포트 변환), `mangle`(헤더 가공), `raw`(추적 전), `security`(LSM 훅)
- **체인**: `INPUT`(로컬로 들어옴), `OUTPUT`(로컬에서 나감), `FORWARD`(경유), `PREROUTING`/`POSTROUTING`(NAT·mangle)
- **타깃**: `ACCEPT`, `DROP`, `REJECT`, `LOG`, 사용자 정의 체인 등. (공식 맨페이지·netfilter 문서 참조)

> 최신 배포판의 기본 백엔드는 **nftables**인 경우가 많다. `iptables-nft`가 **iptables 문법을 파싱 → nftables 명령으로 변환**하여 커널에 적용한다. 확인은 `iptables -V` 출력 또는 배포판 문서를 참조.

### 2. 운영 전 사전 점검
```bash
# 현재 백엔드 확인(힌트)
iptables -V
# 예: iptables v1.8.x (nf_tables)  → nftables 백엔드

# 현재 규칙 백업
iptables-save > /root/iptables_$(date +%F).bak

# 플러시(테스트 환경에서만)
iptables -F
iptables -t nat -F
iptables -t mangle -F
iptables -X
```

### 3. 서버 하드닝: “기본 거부 · 필요한 것만 허용”
#### IPv4(기본 정책 DROP) — SSH(관리망), HTTP/HTTPS, DNS 아웃바운드만 허용 예시
```bash
# 기본 정책
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP

# 루프백 허용
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# ESTABLISHED/RELATED 허용
iptables -A INPUT  -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# SSH: 관리망에서만 허용
iptables -A INPUT -p tcp -s 203.0.113.0/24 --dport 22 -m conntrack --ctstate NEW -j ACCEPT
iptables -A OUTPUT -p tcp --sport 22 -m conntrack --ctstate ESTABLISHED -j ACCEPT

# HTTP/HTTPS 인바운드(웹서버)
iptables -A INPUT  -p tcp --dport 80  -m conntrack --ctstate NEW -j ACCEPT
iptables -A INPUT  -p tcp --dport 443 -m conntrack --ctstate NEW -j ACCEPT

# DNS 아웃바운드(서버가 리졸버를 조회해야 한다면)
iptables -A OUTPUT -p udp --dport 53 -m conntrack --ctstate NEW -j ACCEPT
iptables -A OUTPUT -p tcp --dport 53 -m conntrack --ctstate NEW -j ACCEPT

# ICMP: 필요 최소만 허용(예: echo-reply, dest-unreach)
iptables -A INPUT  -p icmp --icmp-type echo-request -j DROP
iptables -A INPUT  -p icmp --icmp-type destination-unreachable -j ACCEPT
iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT

# 로깅(속도 제한)
iptables -N LOGGING
iptables -A INPUT -j LOGGING
iptables -A LOGGING -m limit --limit 5/min -j LOG --log-prefix "iptables_drop: " --log-level 6
iptables -A LOGGING -j DROP
```

#### IPv6(ip6tables) — 필요 시 유사 정책 적용
```bash
ip6tables -P INPUT DROP
ip6tables -P FORWARD DROP
ip6tables -P OUTPUT DROP

ip6tables -A INPUT -i lo -j ACCEPT
ip6tables -A OUTPUT -o lo -j ACCEPT

ip6tables -A INPUT  -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
ip6tables -A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

ip6tables -A INPUT  -p tcp --dport 22 -s 2001:db8:100::/64 -m conntrack --ctstate NEW -j ACCEPT
```

> `iptables/ip6tables`는 **IPv4/IPv6 각각 별도 명령**. 일부 배포판에서는 단일 nftables로 통합 관리하는 것을 권장한다.

### 4. 방어 강화 스니펫
#### (A) SYN flood 완화(hashlimit)
```bash
iptables -A INPUT -p tcp --syn --dport 80 \
  -m hashlimit --hashlimit 50/second --hashlimit-burst 100 \
  --hashlimit-mode srcip --hashlimit-name http_rate \
  -j ACCEPT
iptables -A INPUT -p tcp --syn --dport 80 -j DROP
```

#### (B) 포트 스캔 로그/차단(recent)
```bash
# 3초 이내 10포트 이상 SYN 시도 → DROP
iptables -A INPUT -p tcp --syn -m recent --name portscan --set
iptables -A INPUT -p tcp --syn -m recent --name portscan --update --seconds 3 --hitcount 10 -j LOG --log-prefix "portscan: "
iptables -A INPUT -p tcp --syn -m recent --name portscan --update --seconds 3 --hitcount 10 -j DROP
```

#### (C) 스푸핑/사설대역 차단
```bash
# 외부 인터페이스로 들어오는 RFC1918 출발지 차단
for net in 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16; do
  iptables -A INPUT -s $net -i eth0 -j DROP
done
```

### 5. NAT/포트 포워딩(게이트웨이/중계 서버)
```bash
# IP 포워딩 활성화(일시)
sysctl -w net.ipv4.ip_forward=1

# 내부 -> 외부 마스커레이드
iptables -t nat -A POSTROUTING -s 10.10.0.0/16 -o eth0 -j MASQUERADE

# 외부 443 → 내부 10.10.20.5:443 포워딩
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j DNAT --to-destination 10.10.20.5:443
iptables -A FORWARD -p tcp -d 10.10.20.5 --dport 443 -m conntrack --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT
iptables -A FORWARD -p tcp -s 10.10.20.5 --sport 443 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
```

### 6. 저장/부팅 연동(systemd 예시)
```bash
# 규칙 저장
iptables-save > /etc/iptables/rules.v4
ip6tables-save > /etc/iptables/rules.v6

# systemd-unit (예시)
/etc/systemd/system/iptables-restore.service
-------------------------------------------
[Unit]
Description=Restore iptables rules
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/sbin/iptables-restore < /etc/iptables/rules.v4
ExecStart=/sbin/ip6tables-restore < /etc/iptables/rules.v6
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
```

### 7. nftables 전환/백엔드 확인
```bash
# 백엔드 확인
iptables -V    # (nf_tables) 라고 나오면 nft 백엔드
# nft 규칙 조회
nft list ruleset
```
- **iptables-nft**는 iptables 문법을 **nftables 커널 오브젝트로 변환**한다(하이브리드). 운영 표준을 nft로 통일할지, iptables 호환을 유지할지 **플레이북/문서에 명시**한다.

---

## 03. IDS↔방화벽 연계/운영 시나리오

### 시나리오 A — “탐지 후 수동 차단(운영기본)”
1) **Snort**가 포트스캔/취약 익스플로잇을 **경보(JSON)** 로 남김
2) **수집기/규칙 엔진**(SIEM)이 상관분석 → **알림**
3) **운영자**가 알림 이벤트에서 출발지 `SRC_IP`를 확인, **iptables 차단** 적용
```bash
# 일시 차단(블랙리스트 체인)
iptables -N BLACKLIST 2>/dev/null || true
iptables -I INPUT -j BLACKLIST
iptables -A BLACKLIST -s 198.51.100.23 -j DROP
```

### 시나리오 B — “준자동(스크립트 게이트)”
- SIEM Webhook → **자동 스크립트**가 `SRC_IP`를 파싱, **임시 DROP**(예: 1시간).
- 과차단 방지를 위해 **블록 기간/횟수 한도**·화이트리스트를 둠.

### 시나리오 C — “Inline IPS”
- Snort를 **inline(IPS)** 모드로 두고, 특정 룰 매칭 시 **DROP**(policy-based).
- 초반에는 `alert` → `reject`/`drop` 전환 전 **오탐 검증** 기간을 둔다.

---

## 04. 테스트/검증(체크리스트 & 명령 모음)

### A) 기능 검증
```bash
# 포트 스캔
nmap -sS -p 1-200 192.168.1.10

# 웹/UA 테스트
curl -A "curl/7.88 test" http://192.168.1.20/

# Snort 로그 tail
tail -f /var/log/snort/alerts.json

# iptables 카운터 확인
iptables -L -v -n
journalctl -f | grep iptables_drop
```

### B) 베이스라인 & 회귀
- **Snort**: 샘플 PCAP(정상/공격) 세트를 두고 **규칙 업데이트마다 재생** → 알람 건수/필드 값 비교.
- **iptables**: **nft list ruleset**(또는 `iptables-save`) 스냅샷을 보관, **구성 드리프트** 탐지(CI에서 비교).

### C) 성능/안정성
- **Snort**: CPU/메모리/패킷 드롭률, 룰 매칭 히트톱(N개 규칙 상위 10개).
- **iptables**: 규칙 길어질수록 성능 저하 → **체인 분리·일치 범위를 축소**(source/destination 제한, 커넥션트래킹 활용).

---

## 05. 운영 보안 점검표

### Snort(탐지)
- [ ] Snort **3** 사용 및 **Lua config** 관리(형상관리). 규칙 저장소/버전 고정.
- [ ] **출력 포맷**(JSON/unified2)과 **전송 파이프라인**(에이전트·SIEM) 표준화. 필수 필드 스키마 정의.
- [ ] **threshold/suppress** 로 오탐/잡음 통제, 상관분석 규칙 문서화.
- [ ] PCAP **리그레션** 자동화(CI).

### iptables(차단)
- [ ] **기본 정책 DROP**, **필요 서비스만 허용** 원칙 준수.
- [ ] **관리망/점프호스트**에서만 SSH. `conntrack`, `hashlimit` 등으로 **빈도 제어**.
- [ ] **로그 레이트 제한**(flood 방지), 규칙 저장/부팅 복원.
- [ ] **백엔드(iptables-nft)**/nftables 혼용 시 표준 결정 및 문서화.

---

## 06. 자주 묻는 질문(FAQ)

**Q1. iptables와 nftables 중 무엇을 써야 하나요?**
A. 최신 커널/배포판은 **nftables**를 권장하는 추세이며, 많은 환경이 **iptables-nft** 백엔드로 iptables 문법을 nft로 변환해 적용한다. 새로 시작한다면 **nftables 표준화**를 검토하되, 기존 자산·도구가 iptables에 의존한다면 **iptables-nft 하이브리드**를 먼저 채택해 점진 전환.

**Q2. Snort 2 규칙이 많은데 Snort 3로 옮길 수 있나요?**
A. Snort 3는 **snort2lua** 도구로 규칙/설정 일부를 변환할 수 있다. 변환 오류는 `snort.rej`로 보고되니 수동 보정한다.

**Q3. Snort 로그 포맷은 무엇을 추천하나요?**
A. **JSON**은 필드 파싱과 전송/저장이 용이해 SIEM/데이터레이크 연동에 적합. 고성능·외부 파서 연계가 필요하면 **unified2**도 고려.

---

## 07. 참고(공식/권위 문서)
- **Snort 3 규칙 구조/가이드**: Snort Docs — Rule Writing Guide / Rules Basics.
- **Snort 3 설치/도구**: Snort Docs — Installation, Snort 3 Docker.
- **Snort 로깅(JSON/unified2)**: Snort Docs — Alert Logging / Unified2 README.
- **iptables 공식/Netfilter**: netfilter.org / iptables manpage.
- **iptables-nft(하이브리드)**: Red Hat 블로그 — iptables-nft 동작 원리.

---

## 부록 A — Snort 3 JSON 로그 샘플
```json
{
  "ts": "2025-11-11T02:10:22.345+09:00",
  "event": {
    "msg": "Suspicious UA",
    "sid": 1000003,
    "rev": 1,
    "classification": "misc-activity",
    "priority": 3
  },
  "flow": {
    "src_ip": "198.51.100.23",
    "src_port": 52133,
    "dst_ip": "192.168.1.20",
    "dst_port": 80,
    "proto": "TCP"
  },
  "http": {
    "host": "192.168.1.20",
    "ua": "curl/7.88 test",
    "method": "GET",
    "uri": "/"
  }
}
```

## 부록 B — iptables 표/체인 요약(기억용)
| 표(Table) | 체인(주요) | 용도 |
|---|---|---|
| filter | INPUT, FORWARD, OUTPUT | 허용/차단 정책 |
| nat | PREROUTING, POSTROUTING, OUTPUT | DNAT/SNAT/MASQUERADE |
| mangle | PREROUTING, OUTPUT, INPUT, FORWARD, POSTROUTING | 패킷 헤더/마킹 |
| raw | PREROUTING, OUTPUT | 커넥션 추적 제외 |
| security | INPUT, OUTPUT, FORWARD | LSM 훅(SELinux/Smack 등) |

---

### 마무리
이 문서는 **탐지(Snort 3)** 와 **차단(iptables)** 의 **역할/구조/최신 동향**(JSON/unified2 로깅, iptables-nft 하이브리드)을 정리하고, **즉시 적용 가능한 규칙/스크립트**를 제시했다. 실전에서는 **정책 설계(기본차단/필요허용)** 와 **오탐관리/상관분석**이 성패를 가른다. Snort는 **룰 품질·출력 표준화**, iptables는 **간결·명시적 정책**과 **백엔드 통일**을 목표로 하자.
