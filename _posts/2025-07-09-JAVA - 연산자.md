---
layout: post
title: Java - 연산자
date: 2025-07-09 20:20:23 +0900
category: Java
---
# Java의 연산자(Operators)

## 0. 큰 그림: 자바 연산자 사용 전 알아둘 것

- **연산자 오버로딩은 불가**(예외: 문자열 `+` 연결).
- **피연산자 평가 순서**는 **왼쪽 → 오른쪽**(left-to-right)로 **엄격히 고정**입니다.
- **숫자 연산 전**에는 **정수/단항/이항 승격**이 적용됩니다(아래 §2.4, §10.3).
- **예외 발생 여부**: 정수 나눗셈의 0 나누기 → `ArithmeticException`, 부동소수점은 `Infinity/NaN` 등 **예외 없음**.

---

## 1. 산술(Arithmetic) 연산자

| 연산자 | 의미 | 주의 |
|---|---|---|
| `+` `-` `*` | 덧셈/뺄셈/곱셈 | 오버플로 감지 안 함(래핑); 필요 시 `Math.addExact` 등 사용 |
| `/` | 나눗셈 | 정수끼리는 **0 toward truncation**(0 쪽으로 절단) |
| `%` | 나머지 | 부호는 **피제수(dividend)**의 부호를 따른다 |

```java
int a = 10, b = 3;
System.out.println(a / b);  // 3  (정수 나눗셈: 소수부 버림)
System.out.println(a % b);  // 1

System.out.println(-5 / 3); // -1 (0쪽 절단)
System.out.println(-5 % 3); // -2 (부호는 피제수 -5를 따름)

// 부동소수점은 예외 대신 특수값
System.out.println( 1.0 / 0.0);   // Infinity
System.out.println(-1.0 / 0.0);   // -Infinity
System.out.println( 0.0 / 0.0);   // NaN
```

정수 나눗셈/나머지의 기본 항등식:
$$
a = (a / b) \times b + (a \% b)
$$

### 1.1 오버플로(정수)와 안전 연산
```java
int x = Integer.MAX_VALUE;
int w = x + 1;                    // 래핑(음수로)
try {
    int y = Math.addExact(x, 1);  // ArithmeticException
} catch (ArithmeticException e) { /* 감지 */ }
```

### 1.2 문자열 연결로서의 `+`
```java
System.out.println("a=" + 10 + 20); // a=1020 (왼→오른 평가, 먼저 문자열화)
System.out.println(10 + 20 + " = sum"); // 30 = sum
String s = null;
System.out.println(s + "X");       // "nullX" (String.valueOf(null) → "null")
```

---

## 2. 부호/증감/단항 승격

### 2.1 부호(unary `+`, `-`)
```java
int i = 5;
System.out.println(+i);  // 5
System.out.println(-i);  // -5
```

### 2.2 증감 `++` / `--` (전위·후위)
```java
int i = 5;
System.out.println(i++); // 5  (사용 후 증가)
System.out.println(++i); // 7  (증가 후 사용)
```
- **부작용(side effect)** 의 타이밍을 항상 의식하세요.
```java
int j = 1;
j = j++ + ++j;  // 왼→오 평가, 결과? (주의: 가독성 위해 지양)
System.out.println(j);   // 3
```

### 2.3 단항/이항 숫자 승격(요지)
- `byte/short/char`는 **연산 전에 `int`로 승격**.
- 두 피연산자 중 더 넓은 타입으로 **이항 승격**.
```java
byte b = 1;
// b = b + 1;   // 오류: b+1은 int
b += 1;         // OK: 복합대입 내부 캐스트
```

---

## 3. 대입(Assignment)과 복합 대입

| 연산자 | 의미 |
|---|---|
| `=` | 단순 대입 (표현식의 **값을 반환**함) |
| `+=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, >>>=` | 복합 대입 |

```java
int x, y;
System.out.println(x = y = 3); // 3 (연쇄 가능, 값 반환)

final int z = 1;
// z = 2;                     // 오류: final은 재대입 불가
```

- **복합 대입**은 내부에서 **캐스트**가 들어가므로 축소 변환도 허용(값 손실 가능성은 여전).
```java
byte b = 120;
b += 20;  // -116 (오버플로 래핑 후 캐스트)
```

- 조건문에서의 **대입 실수**:
```java
boolean ok = false;
// if (ok = true) { ... }  // 컴파일 OK, 항상 true (주의!)
```

---

## 4. 비교(Relational) 연산자

| 연산자 | 의미 |
|---|---|
| `<, <=, >, >=` | 대소 비교(숫자·문자) |
| `==, !=` | **기본형**: 값 비교 / **참조형**: **참조(주소)** 비교 |

```java
int a = 10, b = 20;
System.out.println(a < b);   // true

String s1 = new String("hi");
String s2 = new String("hi");
System.out.println(s1 == s2);      // false (참조 다름)
System.out.println(s1.equals(s2)); // true  (내용 비교)
```

**부동소수점 비교 주의**
```java
double v = 0.1 + 0.2;          // 0.30000000000000004
boolean eq = Math.abs(v - 0.3) < 1e-9; // 허용 오차 사용

double nan = Double.NaN;
System.out.println(nan == nan);        // false
System.out.println(Double.isNaN(nan)); // true
```

---

## 5. 논리(Boolean) 연산자

| 연산자 | 의미 | 특징 |
|---|---|---|
| `&&` | AND | **단축 평가**(왼쪽이 false면 오른쪽 평가 안 함) |
| `||` | OR  | **단축 평가**(왼쪽이 true면 오른쪽 평가 안 함) |
| `!`  | NOT | 논리 부정 |
| `&` `|` `^` | 불리언에도 사용 가능(비단축), 비트 연산과 동일 기호 |

```java
String s = null;
if (s != null && s.length() > 0) { // 안전: 왼쪽이 false면 오른쪽 미평가
    ...
}
```

**비단축과의 차이**
```java
boolean a = false;
// a & f()  → f() 반드시 호출
// a && f() → f() 호출 안 됨
```

---

## 6. 조건(삼항) `?:`

형식: `조건 ? 값1 : 값2`
- 조건이 `true` → `값1`, 아니면 `값2`.
- **양측 타입**은 공통 타입으로 변환되어야 함(숫자 승격·참조 변환 규칙 적용).

```java
int age = 20;
String label = (age >= 18) ? "성인" : "미성년자";

Number n = (Math.random() > 0.5) ? 1 : 1.0; // Number(오토박싱 포함)
```

중첩은 가독성 저하 → **if-else** 고려.

---

## 7. 비트(Bitwise)·시프트(Shift) 연산자

| 연산자 | 의미 |
|---|---|
| `&` `|` `^` `~` | AND / OR / XOR / NOT |
| `<<` `>>` `>>>` | 왼쪽 시프트 / 부호 있는 오른쪽 / **부호 없는** 오른쪽 |

### 7.1 정수 승격과 결과 타입
- `byte/short/char`는 연산 전 **`int`로 승격**.
- `long`이 있으면 결과 `long`.

```java
byte b = 1;
int r = b << 5;      // 결과는 int
```

### 7.2 시프트 거리 마스킹
- `int` 시프트: 거리 `n`은 **`n & 0x1F`** 적용(0~31)
- `long` 시프트: 거리 `n`은 **`n & 0x3F`** 적용(0~63)

```java
int v = 1;
System.out.println(v << 33); // 33 & 31 = 1 → 2 출력
```

### 7.3 부호 있는/없는 오른쪽 시프트
```java
int x = -8; // 111111...1000(2의 보수)
System.out.println(x >> 1);   // 부호 유지 시프트
System.out.println(x >>> 1);  // 0으로 채우는 시프트(부호 비유지)
```

### 7.4 비트 마스크 활용 예
```java
int FLAG_A = 1 << 0, FLAG_B = 1 << 1;
int mask = 0;
mask |= FLAG_A;              // 설정
boolean hasA = (mask & FLAG_A) != 0; // 테스트
mask &= ~FLAG_A;             // 해제
```

---

## 8. `instanceof` (패턴 매칭 포함)

```java
Object obj = "hello";
if (obj instanceof String s) {  // 패턴 매칭(지역 변수 s 바인딩)
    System.out.println(s.toUpperCase());
} else {
    System.out.println("not a string");
}
```
- 패턴 변수 `s`는 **검사 통과 영역**에서만 유효.
- 상속/인터페이스 계층에서 **안전한 다운캐스트 대체**로 권장.

---

## 9. 캐스트(Cast)와 타입 검사

```java
double d = 3.14;
int i = (int) d;     // 3 (소수부 버림)

Number n = 42;
Integer k = (Integer) n; // 런타임에 실제 타입이 Integer여야 성공
```

- **잘못된 다운캐스트**는 `ClassCastException`.
- **제네릭**은 타입 소거로 `new T[]` 불가(연산자 아님이지만 실무 함정).

---

## 10. 우선순위(Precedence)·결합성(Associativity)·평가 순서

### 10.1 우선순위 표(상위 → 하위)

| 우선 | 연산자/구성 |
|---|---|
| 1 | `()` 메서드 호출/캐스트, `[]` 배열 접근, `.` 멤버접근, `::` 메서드 참조 |
| 2 | 단항 `++ -- + - ~ !` |
| 3 | `* / %` |
| 4 | `+ -`（숫자) / `+`（문자열 연결） |
| 5 | `<< >> >>>` |
| 6 | `< <= > >= instanceof` |
| 7 | `== !=` |
| 8 | `&` |
| 9 | `^` |
| 10 | `\|` |
| 11 | `&&` |
| 12 | `\|\|` |
| 13 | `?:` |
| 14 | `= += -= *= /= %= &= \|= ^= <<= >>= >>>=` |

> **참고**: `->`(람다 화살표), `new` 등은 “연산자”로 분류되기도 하나, 여기선 **식 문법 요소**로 묶어 설명합니다. 혼동을 피하려면 **괄호**로 의도를 명확히 하세요.

### 10.2 결합성(Associativity)
- 대부분 **왼→오** 결합. 단, `?:`와 대입류는 **오→왼**.
```java
int a = 1, b = 2, c = 3;
int r = a + b * c;       // b*c 먼저
int t = (a > 0) ? b : c = 5; // (?:) 오른쪽 결합, 가독성 위해 괄호 권장
```

### 10.3 피연산자 **평가 순서는 항상 왼→오**
```java
int i = 0;
int[] arr = {10, 20, 30};
arr[i] = i++;   // 왼쪽 arr[i]에서 i는 0으로 읽힘 → 그 후 i가 1 증가
System.out.println(arr[0]); // 0으로 덮여 씀
System.out.println(i);      // 1
```
- C/C++와 달리 **자바는 평가 순서가 정의**되어 있어 예측 가능.

---

## 11. 표·예제로 보는 핵심 규칙

### 11.1 산술/대입/비교 단골 함정

| 상황 | 코드 | 결과/설명 |
|---|---|---|
| 정수 나눗셈 | `5/2` | `2` (절단) |
| 나머지 부호 | `-5 % 3` | `-2` (피제수 부호 따름) |
| 오버플로 | `Integer.MAX_VALUE + 1` | 음수로 래핑 |
| 복합대입 축소 | `byte b=120; b+=20;` | `-116` (래핑+캐스트) |
| 대입 실수 | `if (ok = true)` | 항상 `true` |
| float 비교 | `0.1+0.2 == 0.3` | 대부분 `false` |
| NaN 비교 | `NaN == NaN` | `false` (항상 `Double.isNaN`) |
| 참조 비교 | `s1 == s2` | 참조 동일성, 내용 비교 아님 |
| 문자열 `+` | `"a"+10+20` | `"a1020"` (좌→우 문자열화) |

### 11.2 비트/시프트 요약

| 항목 | 규칙 |
|---|---|
| 승격 | `byte/short/char` → `int` |
| 결과 타입 | `int`/`long` 중 큰 쪽 |
| 시프트 거리 | `int`: `n & 0x1F`, `long`: `n & 0x3F` |
| `>>` vs `>>>` | 부호 유지 vs 0 채움 |

---

## 12. 실전 미니 과제

### 12.1 안전한 나눗셈 유틸(정수/실수)
```java
public final class Div {
    public static int divInt(int a, int b) {
        if (b == 0) throw new ArithmeticException("/ by zero");
        return a / b;
    }
    public static double divDouble(double a, double b) {
        return a / b; // Infinity/NaN 가능
    }
    public static void main(String[] args) {
        System.out.println(divInt(7, 3));      // 2
        System.out.println(divDouble(7, 0.0)); // Infinity
    }
}
```

### 12.2 비트 플래그 집합 구현
```java
public final class Flags {
    public static final int A = 1<<0, B = 1<<1, C = 1<<2;
    public static int set(int m, int f)   { return m | f; }
    public static int clear(int m, int f) { return m & ~f; }
    public static boolean has(int m, int f){ return (m & f) != 0; }
    public static void main(String[] args){
        int m = 0;
        m = set(m, A); m = set(m, C);
        System.out.println(has(m, B)); // false
        m = clear(m, A);
        System.out.println(has(m, A)); // false
    }
}
```

### 12.3 `instanceof` 패턴 매칭
```java
sealed interface Shape permits Rect, Circle {}
record Rect(int w, int h) implements Shape {}
record Circle(int r) implements Shape {}

public class PM {
    static int area(Shape s) {
        if (s instanceof Rect r)   return r.w() * r.h();
        if (s instanceof Circle c) return (int)(Math.PI * c.r() * c.r());
        throw new IllegalArgumentException();
    }
    public static void main(String[] args){
        System.out.println(area(new Rect(3,4)));
    }
}
```

---

## 13. 체크리스트

- [ ] **정수 연산**: 오버플로 감지 필요 시 `Math.*Exact` 사용
- [ ] **부동소수점 비교**: 직접 비교 대신 **허용 오차** 또는 `BigDecimal`
- [ ] **단축 평가** 활용해 NPE 방지 (`s != null && s.length() > 0`)
- [ ] **복합 대입**의 **암묵 캐스트/래핑** 이해
- [ ] **시프트 거리 마스킹** 규칙 숙지 (`& 0x1F`, `& 0x3F`)
- [ ] **우선순위와 결합성**은 괄호로 명시
- [ ] **평가 순서**는 항상 **왼→오** (부작용 코드에 특히 중요)
- [ ] **참조 비교**와 **내용 비교** 구분 (`==` vs `equals`)
- [ ] 문자열 `+`는 좌→우 평가로 문자열화 진행(필요 시 `StringBuilder`)

---

## 14. 한 줄 요약

> 자바 연산자는 **승격·우선순위·평가 순서·단축 평가**를 정확히 이해하면 **예측 가능**하고 **안전**하게 사용할 수 있습니다.
> 모호한 표현은 **괄호로 명시**하고, **수치·비트·부동소수점**의 각 규칙을 습관화하면 실무 오류를 크게 줄일 수 있습니다.
