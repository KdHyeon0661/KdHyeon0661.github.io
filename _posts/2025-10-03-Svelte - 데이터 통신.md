---
layout: post
title: Svelte - 데이터 통신
date: 2025-10-03 14:30:23 +0900
category: Svelte
---
# 데이터 통신

**fetch 사용법 · 서버 전용 모듈 분리 · REST/GraphQL 연동 패턴 · 오류/예외 처리(`error`, `redirect`)와 페이지 전환 UX · 캐싱 전략(ETag/헤더, 무효화, 플랫폼 Cache API 개념)**

> 이 장은 SvelteKit에서 **데이터를 안전하고 빠르게 주고받는 방법**을 총정리한다.
> - SvelteKit이 래핑한 **`fetch`의 특성**과 올바른 사용 패턴
> - **서버 전용 모듈**을 분리해 비밀키·DB를 안전하게 다루는 방법
> - **REST/GraphQL** 연동 설계 — 타입 안정/에러 전파/리트라이
> - **오류/리다이렉트** 흐름과 **페이지 전환 UX**
> - **캐싱 전략**: `cache-control`·`ETag`·조건부 요청·무효화·플랫폼 Cache API

---

## SvelteKit의 `fetch` 핵심 이해

SvelteKit이 `load`/액션/엔드포인트에 주입하는 `fetch`는 **SSR/CSR에서 동일한 시그니처**로 동작한다:

1. **쿠키/자격 자동 전파**: 서버의 `load`·액션·`+server.ts`에서 내부 API(`/api/*`)를 호출하면 현재 사용자의 쿠키가 자동 전달된다.
2. **중복 요청 디듀플리케이션**: 한 라우팅 사이클에서 동일 URL을 여러 번 `fetch`하면 내부적으로 한 번만 요청한다.
3. **의존성 추적**: `fetch('/api/x')`는 해당 URL을 **의존성**으로 등록한다 → 나중에 `invalidate('/api/x')`로 **정밀 무효화** 가능.
4. **캐시 헤더 존중**: 응답의 `cache-control` 등 표준 헤더를 그대로 따른다. SSR에서는 `setHeaders()`로 문서(HTML) 캐시도 제어 가능.

### 안전한 래퍼 만들기(타입+에러 표준화)

```ts
// src/lib/utils/http.ts
export class HttpError extends Error {
  constructor(
    public status: number,
    public body?: unknown,
    message?: string
  ) { super(message ?? `HTTP ${status}`); }
}

export async function getJSON<T>(fetch: typeof window.fetch, url: string, init?: RequestInit): Promise<T> {
  const res = await fetch(url, { ...init, headers: { 'accept': 'application/json', ...(init?.headers || {}) } });
  if (!res.ok) throw new HttpError(res.status, await safeJSON(res), res.statusText);
  return (await res.json()) as T;
}

async function safeJSON(res: Response) {
  try { return await res.clone().json(); } catch { return await res.text(); }
}
```

사용:

```ts
// src/routes/products/+page.ts
import type { PageLoad } from './$types';
import { getJSON } from '$lib/utils/http';

export const load: PageLoad = async ({ fetch, depends, url }) => {
  depends('/api/products');
  const page = Number(url.searchParams.get('page') ?? '1');
  const items = await getJSON<any[]>(fetch, `/api/products?page=${page}`);
  return { items, page };
};
```

> **포인트**
> - 에러를 **한 타입**으로 표준화하면 `try/catch`·로깅·토스트에 일관되게 대응 가능.
> - `depends()`로 무효화 키를 등록하여, 성공 후 `invalidate('/api/products')`로 **선택 재로드**.

---

## 서버 전용 모듈 분리 — **비밀은 클라이언트로 가지 않게**

서버에서만 써야 하는 코드는 **반드시** `src/lib/server/*`로 두고, **클라이언트 번들에 포함되지 않게** 한다.

```
src/
  lib/
    server/
      db.ts            # DB 클라이언트, 비밀키 사용
      mail.ts          # 이메일 송신
      s3.ts            # 스토리지 SDK
    api/
      products.ts      # 프록시/도메인 API(서버에서만 import)
```

### DB 클라이언트 예시

```ts
// src/lib/server/db.ts
import { env } from '$env/dynamic/private'; // 런타임 환경변수 (서버 전용)
import { createClient } from '@libsql/client'; // 예시
export const db = createClient({ url: env.DB_URL, authToken: env.DB_TOKEN });
```

서버 파일에서만 사용:

```ts
// src/routes/api/products/+server.ts
import type { RequestHandler } from './$types';
import { db } from '$lib/server/db';

export const GET: RequestHandler = async () => {
  const rows = await db.execute('select * from products limit 50');
  return new Response(JSON.stringify(rows), {
    headers: { 'content-type': 'application/json', 'cache-control': 'no-store' }
  });
};
```

> **주의**
> - 클라이언트 파일(컴포넌트, `+page.ts`)에서 **서버 전용 모듈을 import하면 안 된다**.
> - 환경변수:
>   - **`$env/static/private`**: 빌드 시 주입(어댑터에 따라 다름), 절대 클라이언트로 가지 않음
>   - **`$env/dynamic/private`**: 런타임 시 서버에서만 접근

---

## REST 연동 패턴

### 엔드포인트 설계(표준 헤더/상태/에러)

```ts
// src/routes/api/items/+server.ts
import type { RequestHandler } from './$types';

export const GET: RequestHandler = async ({ url }) => {
  const page = Number(url.searchParams.get('page') ?? '1');
  const items = await listItems(page);
  return json(items, { headers: { 'cache-control': 'public, max-age=30' } });
};

export const POST: RequestHandler = async ({ request }) => {
  const fd = await request.formData();
  const title = String(fd.get('title') ?? '').trim();
  if (!title) return json({ error: 'title required' }, { status: 400 });
  const created = await createItem(title);
  return json(created, { status: 201 });
};

// 헬퍼: json 응답
function json(data: unknown, init?: ResponseInit) {
  return new Response(JSON.stringify(data), {
    ...init,
    headers: { 'content-type': 'application/json', ...(init?.headers ?? {}) }
  });
}
```

클라이언트(또는 `load`)에서 사용:

```ts
import { getJSON } from '$lib/utils/http';

export const load = async ({ fetch, depends }) => {
  depends('/api/items');
  const items = await getJSON<any[]>(fetch, '/api/items?page=1');
  return { items };
};
```

### 리트라이/백오프(네트워크 일시 오류)

```ts
// src/lib/utils/retry.ts
export async function retry<T>(fn: () => Promise<T>, attempts = 3, base = 150) {
  let last: unknown;
  for (let i = 0; i < attempts; i++) {
    try { return await fn(); }
    catch (e) { last = e; await wait(base * 2 ** i); }
  }
  throw last;
}
const wait = (ms: number) => new Promise(r => setTimeout(r, ms));
```

```ts
// 사용
import { retry } from '$lib/utils/retry';
const items = await retry(() => getJSON(fetch, '/api/items'), 3);
```

---

## GraphQL 연동 패턴

### 최소한의 fetch 기반 클라이언트

```ts
// src/lib/graphql/client.ts
type GQLError = { message: string; path?: (string|number)[] };
type GQLResponse<T> = { data?: T; errors?: GQLError[] };

export async function gql<T>(
  fetch: typeof window.fetch, endpoint: string, query: string, variables?: Record<string, unknown>
): Promise<T> {
  const res = await fetch(endpoint, {
    method: 'POST',
    headers: { 'content-type': 'application/json', 'accept': 'application/json' },
    body: JSON.stringify({ query, variables })
  });
  if (!res.ok) throw new Error(`GraphQL HTTP ${res.status}`);
  const json = (await res.json()) as GQLResponse<T>;
  if (json.errors?.length) throw new Error(json.errors.map(e => e.message).join('; '));
  return json.data as T;
}
```

사용 예:

```ts
// src/routes/users/+page.ts
import { gql } from '$lib/graphql/client';

const Q = `
query Users($first: Int!) {
  users(first: $first) { id name }
}
`;

export const load = async ({ fetch, depends }) => {
  depends('app:users');
  const data = await gql<{ users: { id:string; name:string }[] }>(
    fetch, '/api/graphql', Q, { first: 20 }
  );
  return { users: data.users };
};
```

### 서버 프록시로 토큰 은닉

외부 GraphQL에 직접 브라우저에서 요청하지 말고, **서버 엔드포인트가 프록시**하여 **API 키/토큰**을 숨긴다.

```ts
// src/routes/api/graphql/+server.ts
import type { RequestHandler } from './$types';
import { env } from '$env/dynamic/private';

export const POST: RequestHandler = async ({ request, fetch }) => {
  const body = await request.text();
  const upstream = await fetch(env.GQL_URL, {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
      'authorization': `Bearer ${env.GQL_TOKEN}`
    },
    body
  });
  // 그대로 스트리밍 전달
  return new Response(upstream.body, {
    status: upstream.status,
    headers: { 'content-type': 'application/json', 'cache-control': 'no-store' }
  });
};
```

> **고급**: **Persisted Query**(해시된 쿼리)·**쿼리 배칭**(Apollo)·**GraphQL Codegen**으로 타입 자동 생성까지 도입하면 대규모 팀에서 안정성이 크게 올라간다.

---

## 오류/예외 처리와 페이지 전환 UX

### `error`/`redirect`의 정확한 용도

```ts
// +page.server.ts
import { error, redirect } from '@sveltejs/kit';

export const load = async ({ locals }) => {
  if (!locals.user) throw redirect(303, '/login');
  const data = await something().catch(() => { throw error(500, 'Internal'); });
  return { data };
};
```

- **`throw redirect(status, location)`**: 인증 등 **즉시 이동**
- **`throw error(status, message)`**: **에러 라우트**로 전파 → `src/error.html`(최상위) 또는 `+error.svelte`(구간별)에서 렌더

**구간 에러 UI**:

```svelte
<!-- src/routes/(app)/+error.svelte -->
<script lang="ts">
  export let error: Error & { status?: number };
  export let status: number;
</script>

<h1>{status}</h1>
<p>{error.message}</p>
<a href="/">Go Home</a>
```

### 페이지 전환 UX — 로딩/부분 업데이트

1) **`{#await}`**로 _부분_ 로딩 스켈레톤
2) 폼 제출/액션은 **서버 우선 + `enhance`**(점진적 향상)
3) **정밀 무효화**로 필요한 데이터만 리로드

```ts
// +page.ts (Promise를 그대로 반환 → 스켈레톤 가능)
export const load = async ({ fetch, depends }) => {
  depends('/api/feed');
  return { feed: fetch('/api/feed').then(r => r.json()) };
};
```

```svelte
<!-- +page.svelte -->
<script lang="ts">
  export let data: { feed: Promise<any[]> };
</script>

{#await data.feed}
  <FeedSkeleton/>
{:then items}
  <FeedList {items}/>
{:catch e}
  <ErrorBanner message={e.message}/>
{/await}
```

---

## 캐싱 전략 총정리

> 목표: **정확성**(갱신)과 **속도**(캐시) 사이의 균형.
> 구성요소: **문서(HTML) 캐시**, **데이터(API) 캐시**, **무효화**, **조건부 요청(ETag/Last-Modified)**, **플랫폼 Cache API**.

### 캐시 — `setHeaders` in server `load`

```ts
// +page.server.ts
export const load = async ({ setHeaders }) => {
  // 첫 SSR 문서 응답 캐시(중간 캐시/CDN용)
  setHeaders({ 'cache-control': 'public, s-maxage=60, stale-while-revalidate=300' });
  return {};
};
```

- **주의**: 유니버설 `load`의 `setHeaders()`는 SSR에서만 효과(클라 전환 시 무시).
- CSR 전환에서는 **데이터만 갱신** → 첫 문서 캐시는 영향 없음.

### API 캐시 — `cache-control`, `s-maxage`, `stale-while-revalidate`

```ts
// +server.ts (API)
export const GET = async () => {
  const data = await fetchFromDB();
  return new Response(JSON.stringify(data), {
    headers: {
      'content-type': 'application/json',
      'cache-control': 'public, max-age=10, s-maxage=120, stale-while-revalidate=600'
    }
  });
};
```

- **`max-age`**: 브라우저 캐시
- **`s-maxage`**: 공유 캐시(CDN/프록시)
- **`stale-while-revalidate`**: 만료 후에도 **오래된(stale) 응답을 즉시 제공**하고 백그라운드에서 **갱신**

### — **바이트 아끼기**

```ts
// src/routes/api/posts/+server.ts
import type { RequestHandler } from './$types';
import { createHash } from 'crypto'; // Node 환경(서버)

function etagOf(text: string) {
  return `"${createHash('sha1').update(text).digest('base64').slice(0, 27)}"`; // 짧은 ETag
}

export const GET: RequestHandler = async ({ request }) => {
  const body = JSON.stringify(await getPosts());
  const etag = etagOf(body);

  // 조건부 요청 처리
  if (request.headers.get('if-none-match') === etag) {
    return new Response(null, { status: 304, headers: { etag } });
  }

  return new Response(body, {
    headers: {
      'content-type': 'application/json',
      'cache-control': 'public, max-age=30',
      etag
    }
  });
};
```

- 브라우저가 `If-None-Match`에 이전 ETag를 보내면 서버는 **304 Not Modified**로 응답 → 바이트 절약/지연 감소.
- 대안: **`Last-Modified`** / `If-Modified-Since` (초 단위·시계 동기 문제 감안)

### — **클라이언트에서 필요한 데이터만 다시**

- `load`가 `fetch('/api/x')`로 데이터를 가져왔다면, 이후 상호작용 성공 시:

```ts
import { invalidate } from '$app/navigation';
// ...
await invalidate('/api/x'); // 이 URL을 의존한 load만 재실행
```

- 더 넓게: `invalidateAll()`로 현재 페이지의 모든 `load` 강제 재실행

### — 일부 어댑터에서 사용 가능

일부 배포 환경(예: Cloudflare, Deno, 일부 에지 런타임)은 **표준 Web Cache API**를 서버에서 제공한다.
SvelteKit의 서버 핸들러/`load.server`에서 **`event.platform?.caches`** 등에 접근 가능한 경우가 있다(어댑터 의존).
아이디어:

```ts
// +server.ts (플랫폼의 Cache API가 있는 환경에서만)
export const GET: RequestHandler = async ({ url, platform, fetch }) => {
  const key = new Request(url.toString(), { method: 'GET' });
  const cache = platform?.caches?.default;
  if (cache) {
    const hit = await cache.match(key);
    if (hit) return hit;
    const upstream = await fetch('https://api.example.com/data');
    const res = new Response(upstream.body, upstream); // 복제
    // 캐시에 넣어두기
    await cache.put(key, res.clone());
    return res;
  }
  // 일반 환경: 그냥 패스스루
  return fetch('https://api/example.com/data');
};
```

> **요점**: **플랫폼 캐시**는 서버 측(에지)에서 동작하는 **웹 표준 Cache API**이며, 사용 가능 여부/범위는 어댑터에 따라 다르다. 사용할 수 있다면 **초저지연 캐시**를 구성할 수 있다.

---

## 통신+캐싱 종합 예제 — “검색 + 상세” 하이브리드

**요구사항**
- `/search`: 쿼리·페이지 파라미터 기반 리스트(캐시 30초, 무효화 키 `app:search`)
- `/item/[id]`: 상세(ETag/조건부 요청), 폼 액션으로 댓글 달기 후 상세만 **정밀 무효화**

### API

```ts
// src/routes/api/search/+server.ts
import type { RequestHandler } from './$types';
export const GET: RequestHandler = async ({ url }) => {
  const q = url.searchParams.get('q') ?? '';
  const page = Number(url.searchParams.get('page') ?? '1');
  const data = await searchDB(q, page);
  return new Response(JSON.stringify(data), {
    headers: { 'content-type': 'application/json', 'cache-control': 'public, max-age=30, s-maxage=120' }
  });
};
```

```ts
// src/routes/api/item/[id]/+server.ts
import type { RequestHandler } from './$types';
import { sha1 } from '$lib/server/digest'; // 직접 구현 가능

export const GET: RequestHandler = async ({ params, request }) => {
  const item = await getItem(params.id);
  if (!item) return new Response('Not found', { status: 404 });

  const body = JSON.stringify(item);
  const etag = `"${sha1(body).slice(0, 27)}"`;

  if (request.headers.get('if-none-match') === etag) {
    return new Response(null, { status: 304, headers: { etag } });
  }
  return new Response(body, {
    headers: { 'content-type': 'application/json', etag, 'cache-control': 'public, max-age=20' }
  });
};
```

### 페이지들

검색:

```ts
// src/routes/search/+page.ts
import type { PageLoad } from './$types';
import { getJSON } from '$lib/utils/http';

export const load: PageLoad = async ({ fetch, url, depends }) => {
  depends('app:search');
  const q = url.searchParams.get('q') ?? '';
  const page = Number(url.searchParams.get('page') ?? '1');
  const results = await getJSON<any[]>(fetch, `/api/search?q=${encodeURIComponent(q)}&page=${page}`);
  return { q, page, results };
};
```

상세:

```ts
// src/routes/item/[id]/+page.ts
import type { PageLoad } from './$types';
import { getJSON } from '$lib/utils/http';

export const load: PageLoad = async ({ fetch, params, depends }) => {
  depends(`/api/item/${params.id}`);
  const item = await getJSON<any>(fetch, `/api/item/${params.id}`);
  return { item };
};
```

```svelte
<!-- src/routes/item/[id]/+page.svelte -->
<script lang="ts">
  import { enhance } from '$app/forms';
  import { invalidate } from '$app/navigation';
  export let data: { item: any }; export let form;

  const opts = () => ({
    async result({ result, update }) {
      await update(); // form 반영
      if (result.type === 'success') {
        await invalidate(`/api/item/${data.item.id}`); // 상세만 새로고침
      }
    }
  });
</script>

<article>
  <h1>{data.item.title}</h1>
  <p>{data.item.body}</p>

  <h2>댓글 달기</h2>
  <form method="POST" use:enhance={opts}>
    <input type="hidden" name="id" value={data.item.id} />
    <textarea name="comment" required>{form?.values?.comment ?? ''}</textarea>
    {#if form?.message}<small style="color:#b00020">{form.message}</small>{/if}
    <button name="addComment">등록</button>
  </form>
</article>
```

액션:

```ts
// src/routes/item/[id]/+page.server.ts
import type { Actions } from './$types';
import { fail } from '@sveltejs/kit';

export const actions: Actions = {
  addComment: async ({ request, fetch }) => {
    const fd = await request.formData();
    const id = String(fd.get('id'));
    const comment = String(fd.get('comment') ?? '').trim();
    if (!comment) return fail(400, { message: '댓글을 입력하세요', values: Object.fromEntries(fd) });

    // 서버에서 직접 저장하거나 내부 API 호출
    await fetch('/api/comments', { method: 'POST', body: fd });
    return { ok: true };
  }
};
```

---

## 보안/신뢰성 체크리스트

- [ ] **서버 전용 모듈**(`src/lib/server/*`)에 비밀키·DB·외부 토큰을 격리하고, 클라이언트에서 import하지 않는다.
- [ ] **내부 API**는 반드시 **인증/권한 검사** 수행(`hooks.server.ts`에서 `locals.user` 주입 후 확인).
- [ ] 외부 API는 **서버 프록시**로 호출해 토큰을 숨긴다. CORS·레이트 리밋 고려.
- [ ] **오류 표준화**(에러 클래스/포맷)로 로깅/토스트/재시도 일관성 확보.
- [ ] **캐싱 헤더**는 명확히: 변경 빈도·정확성 요구에 따라 `max-age/s-maxage/SWR` 조합.
- [ ] **조건부 요청**(ETag/Last-Modified)으로 트래픽 절감.
- [ ] **무효화 키**(`depends`/`invalidate`)를 설계하여, 성공 후 **정밀 새로고침**.
- [ ] JS 없는 환경도 고려 — **서버 우선 폼 + `enhance`**로 점진적 향상.
- [ ] 대기/로딩/오류 상태를 **UI에 명시적으로** 보여준다(스켈레톤·토스트·재시도 버튼).
- [ ] 플랫폼(에지) **Cache API** 사용 가능 여부를 파악하고, 가능하면 활용(초저지연 캐싱).

---

## 요약

- SvelteKit의 `fetch`는 **쿠키 전파/디듀플리케이션/의존성 추적**을 제공한다.
- **서버 전용 모듈**로 보안 경계를 세우고, REST/GraphQL은 **프록시/타입/에러 표준화**로 견고하게.
- 에러/리다이렉트는 **`throw error/redirect`**로 제어, 폼은 **서버 우선 + enhance**.
- 캐시는 **문서/데이터/무효화/조건부 요청/플랫폼 캐시**를 조합해 정확성과 속도를 동시에 달성하라.
