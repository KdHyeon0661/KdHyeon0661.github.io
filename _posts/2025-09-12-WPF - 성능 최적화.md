---
layout: post
title: WPF - 성능 최적화
date: 2025-09-12 16:25:23 +0900
category: WPF
---
# ⚡ WPF 성능 최적화 끝장 가이드  
**주제:** 그리기 배치(Drawing Batching) · I/O 병렬화 · 지연 로딩 · UI 응답성 유지  
(*실전 예제 + 체크리스트 + 함정/해결 + 진단 도구까지 “누락 없이” 정리*)

> 이 글은 **WPF(.NET 6~8 포함)** 기준으로 UI 성능을 좌우하는 4대 축을 “실무 패턴” 중심으로 설명합니다.  
> 모든 코드는 **그대로 복붙 후 실행/응용**을 목표로 작성했습니다.

---

## 0) 원리 요약: WPF가 느려지는 순간
- **요소(시각 트리) 수 과다** → 측정/배치/바인딩/레이아웃 비용 폭발  
- **UI 스레드에서 CPU/IO 작업 실행** → 입력/렌더 중단(프리즈)  
- **무분별한 바인딩/컨버터/업데이트** → GC/알림 폭주  
- **이미지 디코딩/스케일링/이펙트** → GPU/CPU 병목  
- **네트워크/디스크 I/O 직행** → 대기/락으로 응답성 하락

**핵심 전략**
1) **그리기 배치**: “많은 요소” → “적은 드로잉 호출”  
2) **I/O 병렬화**: `async/await` + 동시도 제한 + UI 반영 배치  
3) **지연 로딩**: 필요한 순간에만 데이터/이미지/템플릿 로딩  
4) **UI 응답성 유지**: Dispatcher에 양보·청크 처리·디바운스/스로틀

---

# 1) 그리기 배치(Drawing Batching)

### 1.1 수천 개 Shape → **한 번에 그리기**
`Path/Rectangle/TextBlock`을 수천 개 만들지 말고, **`OnRender` + `DrawingContext`** 로 한 번에 그립니다.

```csharp
public class BatchedPolyline : FrameworkElement
{
    public IList<Point> Points
    {
        get => (IList<Point>)GetValue(PointsProperty);
        set => SetValue(PointsProperty, value);
    }
    public static readonly DependencyProperty PointsProperty =
        DependencyProperty.Register(nameof(Points), typeof(IList<Point>), typeof(BatchedPolyline),
            new FrameworkPropertyMetadata(new List<Point>(), FrameworkPropertyMetadataOptions.AffectsRender));

    protected override void OnRender(DrawingContext dc)
    {
        var pen = new Pen(Brushes.SteelBlue, 1);
        if (pen.CanFreeze) pen.Freeze();

        var geo = new StreamGeometry();
        using (var ctx = geo.Open())
        {
            if (Points.Count > 0)
            {
                ctx.BeginFigure(Points[0], isFilled: false, isClosed: false);
                for (int i = 1; i < Points.Count; i++)
                    ctx.LineTo(Points[i], isStroked: true, isSmoothJoin: false);
            }
        }
        if (geo.CanFreeze) geo.Freeze();

        dc.DrawGeometry(null, pen, geo); // ✔ 한 번의 드로잉
    }
}
```

**효과**
- 요소 10,000개 → 요소 1개 + `OnRender` 1회  
- 레이아웃/바인딩/상호작용 오버헤드 급감

---

### 1.2 반복되는 도형/아이콘 → **Drawing/DrawingImage/BitmapCache**
```csharp
// 아이콘 벡터를 한번 구성하고 Freeze → 여러 곳에서 재사용
var circle = new GeometryDrawing(
    Brushes.CornflowerBlue,
    new Pen(Brushes.MidnightBlue, 2),
    new EllipseGeometry(new Point(10,10), 9, 9));
var group = new DrawingGroup();
group.Children.Add(circle);
if (group.CanFreeze) group.Freeze();
var image = new DrawingImage(group);
if (image.CanFreeze) image.Freeze();
MyImage.Source = image;
```

```xml
<!-- 자주 변하지 않는 비주얼은 비트맵 캐시로 렌더 호출 최소화 -->
<Border>
  <Border.CacheMode>
    <BitmapCache RenderAtScale="1"/>
  </Border.CacheMode>
  <!-- 내부에 벡터/복잡 템플릿 -->
</Border>
```

---

### 1.3 텍스트 대량 표시 최적화
- `TextOptions.TextFormattingMode="Display"` (대용량 텍스트 목록)  
- 굵은 효과 대신 **폰트 자체의 Weight** 사용  
- 같은 문자열 반복 → **FormattedText 캐시**(고급: DrawingContext에 직접 그리기)

---

### 1.4 레이아웃 비용 줄이기
- `Grid`의 과도한 `*` 줄이고 **고정 폭/행** 우선  
- 중첩 Grid/StackPanel 최소화, **UniformGrid** 처럼 단순 레이아웃 활용  
- `UseLayoutRounding="True"`, `SnapsToDevicePixels="True"` 로 재측정/블러 감소

---

### 1.5 체크리스트 — 그리기 배치
- [ ] Shape/컨트롤 남발 → **OnRender/DrawingVisual/StreamGeometry**로 집약  
- [ ] 도형/효과/브러시/지오메트리는 **Freeze** 후 재사용  
- [ ] 반복 컨텐츠는 **DrawingImage** 또는 **BitmapCache**  
- [ ] 텍스트는 **Display 모드** + 캐시  
- [ ] 레이아웃은 **단순/고정치 우선**

---

# 2) I/O 병렬화 (네트워크/디스크)

### 2.1 `async/await` + 동시도 제한 + 결과 **배치 반영**
```csharp
public async Task LoadThumbsAsync(IEnumerable<string> urls, CancellationToken ct)
{
    using var http = new HttpClient();
    var gate = new SemaphoreSlim(8); // 동시도 8
    var tasks = urls.Select(async url =>
    {
        await gate.WaitAsync(ct);
        try
        {
            var bytes = await http.GetByteArrayAsync(url, ct); // I/O만
            return (url, bytes);
        }
        finally { gate.Release(); }
    });

    var results = await Task.WhenAll(tasks); // 백그라운드 완료 대기

    // UI에는 한 번만 반영(중간 BeginInvoke 폭주 금지)
    await Application.Current.Dispatcher.InvokeAsync(() =>
    {
        foreach (var (url, bytes) in results)
            Thumbnails.Add(new ThumbItem { Url = url, Bytes = bytes });
    });
}
```

---

### 2.2 이미지 디코딩은 **백그라운드 + Freeze**
```csharp
static BitmapImage ToFrozenBitmap(byte[] bytes)
{
    using var ms = new MemoryStream(bytes);
    var bi = new BitmapImage();
    bi.BeginInit();
    bi.CacheOption = BitmapCacheOption.OnLoad;
    bi.StreamSource = ms;
    bi.EndInit();
    bi.Freeze();             // ✔ UI 경계 안전 + 렌더 최적화
    return bi;
}

var bmp = await Task.Run(() => ToFrozenBitmap(data), ct);
await Dispatcher.InvokeAsync(() => Image.Source = bmp);
```

---

### 2.3 채널(Producer/Consumer) 파이프라인 (고급)
많은 URL 처리 시 **백프레셔**와 **균형**을 잡습니다.

```csharp
using System.Threading.Channels;

public async Task PipeAsync(IAsyncEnumerable<string> urls, CancellationToken ct)
{
    var channel = Channel.CreateBounded<byte[]>(new BoundedChannelOptions(32){ SingleReader=false, SingleWriter=false });

    // Producer: 다운로드
    var prod = Task.Run(async () =>
    {
        using var http = new HttpClient();
        await foreach (var u in urls.WithCancellation(ct))
            await channel.Writer.WriteAsync(await http.GetByteArrayAsync(u, ct), ct);
        channel.Writer.Complete();
    }, ct);

    // Consumers: 디코딩 + UI 등록 (4개 워커)
    var consumers = Enumerable.Range(0, 4).Select(_ => Task.Run(async () =>
    {
        await foreach (var bytes in channel.Reader.ReadAllAsync(ct))
        {
            var bmp = ToFrozenBitmap(bytes);
            await Dispatcher.InvokeAsync(() => Images.Add(bmp));
        }
    }, ct)).ToArray();

    await Task.WhenAll(consumers.Prepend(prod));
}
```

---

### 2.4 체크리스트 — I/O 병렬화
- [ ] `await`로 순수 비동기, CPU는 `Task.Run`  
- [ ] **동시도 제한**(`SemaphoreSlim`)으로 폭주 방지  
- [ ] **UI 반영은 배치**(한 번에)  
- [ ] 이미지/대용량 디코딩은 백그라운드 + **Freeze**  
- [ ] 파이프라인(채널/큐)로 **백프레셔/균형** 확보

---

# 3) 지연 로딩(Incremental/Lazy Loading)

### 3.1 UI 가상화 + 끝 근처 프리페치(무한 스크롤)
```xml
<ListView ItemsSource="{Binding Items}"
          ScrollViewer.CanContentScroll="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          VirtualizingPanel.CacheLengthUnit="Item"
          VirtualizingPanel.CacheLength="2,4"/>
```

```csharp
private async void OnScrollChanged(object s, ScrollChangedEventArgs e)
{
    if (e.VerticalOffset + e.ViewportHeight >= e.ExtentHeight - 300)
    {
        if (!IsLoading && HasMore)
            await LoadNextPageAsync();     // 다음 페이지 로드
    }
}
```

---

### 3.2 템플릿 지연 로딩 (보일 때만 무거운 부분 로드)
```xml
<DataTemplate DataType="{x:Type vm:Photo}">
  <Grid>
    <!-- 가벼운 프리뷰 먼저 -->
    <Image Source="{Binding Preview}" Width="240" Height="160"/>

    <!-- 가시화 후 동적 로딩 -->
    <ContentControl local:LazyLoader.LoadCommand="{Binding LoadFullCommand}"/>
  </Grid>
</DataTemplate>
```

```csharp
// LazyLoader.cs - Attached Property(보일 때 커맨드 실행)
public static class LazyLoader
{
    public static readonly DependencyProperty LoadCommandProperty =
        DependencyProperty.RegisterAttached("LoadCommand", typeof(ICommand), typeof(LazyLoader),
        new PropertyMetadata(null, OnChanged));

    static void OnChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is FrameworkElement fe)
        {
            fe.IsVisibleChanged -= OnVisible;
            fe.IsVisibleChanged += OnVisible;
        }
    }
    static void OnVisible(object sender, DependencyPropertyChangedEventArgs e)
    {
        if (sender is FrameworkElement fe && fe.IsVisible)
            (GetLoadCommand(fe) as ICommand)?.Execute(null);
    }

    public static void SetLoadCommand(DependencyObject o, ICommand v) => o.SetValue(LoadCommandProperty, v);
    public static ICommand GetLoadCommand(DependencyObject o) => (ICommand)o.GetValue(LoadCommandProperty);
}
```

뷰모델:
```csharp
[RelayCommand]
private async Task LoadFullAsync()
{
    if (IsLoaded) return;
    IsLoaded = true;
    Full = await _photoService.GetFullAsync(Id); // I/O
}
```

---

### 3.3 데이터 가상화 컬렉션 (간단 패턴)
```csharp
public sealed class PagedCollection<T> : ObservableCollection<T>
{
    private readonly Func<int, Task<IReadOnlyList<T>>> _loader;
    public int Page { get; private set; } = 0;
    public bool HasMore { get; private set; } = true;
    public PagedCollection(Func<int, Task<IReadOnlyList<T>>> loader) => _loader = loader;

    public async Task LoadNextAsync()
    {
        if (!HasMore) return;
        var next = await _loader(++Page);
        foreach (var item in next) Add(item);
        if (next.Count == 0) HasMore = false;
    }
}
```

---

### 3.4 체크리스트 — 지연 로딩
- [ ] **UI 가상화**(리사이클 ON)  
- [ ] **무한 스크롤**: 끝 근처 프리페치  
- [ ] 템플릿 “무거운 부분”은 **보일 때 로딩**  
- [ ] 데이터는 **페이지 단위**로 가져오고 캐시/해제 정책 수립  
- [ ] 이미지/문서 **프리뷰 → 본문** 2단계 로딩

---

# 4) UI 응답성 유지

### 4.1 긴 작업 **청크 분할 + 프레임 양보**
```csharp
public async Task ProcessManyAsync(IReadOnlyList<Item> items)
{
    const int chunk = 200;
    for (int i = 0; i < items.Count; i += chunk)
    {
        var slice = items.Skip(i).Take(chunk).ToList();
        await Task.Run(() => Compute(slice));                       // CPU
        await Dispatcher.Yield(DispatcherPriority.Background);       // 입력/렌더 기회 제공
    }
}
```

---

### 4.2 디바운스 / 스로틀 (이벤트 폭주 완화)
```csharp
public sealed class Debouncer
{
    private readonly DispatcherTimer _timer;
    private Action? _pending;
    public Debouncer(TimeSpan delay)
    {
        _timer = new DispatcherTimer { Interval = delay };
        _timer.Tick += (_,__) => { _timer.Stop(); _pending?.Invoke(); };
    }
    public void Run(Action action)
    {
        _pending = action;
        _timer.Stop();
        _timer.Start();
    }
}
// 사용: TextChanged → 300ms 후 검색
_debouncer.Run(async () => await SearchAsync());
```

---

### 4.3 `DispatcherTimer` vs `System.Threading.Timer`
- **UI 작업**: `DispatcherTimer` (UI 컨텍스트에서 실행)  
- **정밀/백그라운드**: `Threading.Timer` (UI 접근 시 Dispatcher로 마샬링)

```csharp
var uiTimer = new DispatcherTimer(DispatcherPriority.Background)
{ Interval = TimeSpan.FromMilliseconds(100) };
uiTimer.Tick += (_,__) => Progress++;
uiTimer.Start();
```

---

### 4.4 바인딩/컬렉션 업데이트 **배치 처리**
```csharp
public static class OcEx
{
    public static void ReplaceWith<T>(this ObservableCollection<T> oc, IEnumerable<T> items)
    {
        oc.Clear();
        foreach (var it in items) oc.Add(it);
    }
}
```

**또는** 뷰 갱신이 무거운 경우:
```csharp
using (view.DeferRefresh())
{
    view.Filter = ...;
    view.SortDescriptions.Clear();
    view.SortDescriptions.Add(new SortDescription("Name", ListSortDirection.Ascending));
}
```

---

### 4.5 교착(Deadlock) 회피 규칙
- UI에서 **절대** `.Result`/`.Wait()` 하지 말 것 → 항상 `await`  
- 백그라운드 → UI 갱신은 `BeginInvoke`/`InvokeAsync`  
- 라이브러리 계층 `await`는 `ConfigureAwait(false)` 권장

---

### 4.6 체크리스트 — UI 응답성
- [ ] 무거운 루프는 **청크 + Yield**  
- [ ] 입력/검색/스크롤은 **디바운스/스로틀**  
- [ ] 컬렉션/바인딩은 **배치 업데이트**  
- [ ] 타이머 선택: UI면 `DispatcherTimer`  
- [ ] 교착 유발 패턴 제거(`Result/Wait` 금지)

---

# 5) 이미지/미디어 고성능 팁

### 5.1 스케일링 품질 동적 전환
```xml
<Image Source="{Binding Src}"
       RenderOptions.BitmapScalingMode="{Binding IsScrolling, Converter={StaticResource BoolToScalingMode}}"/>
```
- 스크롤 중: `LowQuality` / 정지: `HighQuality`  
- 스크롤 이벤트/중요 상태에 맞춰 바인딩

### 5.2 렌더 티어 확인
```csharp
var tier = (RenderCapability.Tier >> 16); // 0~2
```
- Tier 0 환경(가상머신, 구형 GPU)에서는 **이펙트 최소화**/벡터 → 비트맵 캐시

---

# 6) 진단 & 모니터링

- **Snoop / Live Visual Tree**: 요소/바인딩 실시간 확인  
- **WPF Performance Suite (Perforator)**: 프레임, 레이아웃, 텍스쳐  
- **바인딩 트레이스**:  
  ```xml
  <TextBlock Text="{Binding Name,
        diag:PresentationTraceSources.TraceLevel=High}"/>
  ```
- **Stopwatch/ETW/로그**로 구간 시간 측정  
- **메모리 프로파일러(dotMemory/VS)**: 대형 객체/이미지 누수 점검

---

# 7) 실전 통합 예제: “대량 썸네일 그리드”

**목표**:  
- 5만 개 이미지 URL 목록 표시  
- 스크롤 부드러움 유지  
- 썸네일 로딩/디코딩 병렬  
- 지연 로딩(보이는 페이지만)  
- 프레임 드랍 최소화

### 7.1 XAML
```xml
<ListView ItemsSource="{Binding Photos}"
          ScrollViewer.CanContentScroll="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          VirtualizingPanel.CacheLengthUnit="Item"
          VirtualizingPanel.CacheLength="2,4">
  <ListView.ItemsPanel>
    <ItemsPanelTemplate>
      <VirtualizingStackPanel/>
    </ItemsPanelTemplate>
  </ListView.ItemsPanel>

  <ListView.ItemTemplate>
    <DataTemplate DataType="{x:Type vm:PhotoItem}">
      <Grid Width="280" Height="180" Margin="6">
        <Border Background="#111" CornerRadius="8" />
        <Image Source="{Binding Preview}" Stretch="UniformToFill"/>
        <TextBlock Text="{Binding Title}" VerticalAlignment="Bottom" Foreground="White" 
                   Background="#66000000" Padding="6,2"/>
      </Grid>
    </DataTemplate>
  </ListView.ItemTemplate>
</ListView>
```

### 7.2 ViewModel (핵심만)
```csharp
public partial class GalleryViewModel : ObservableObject
{
    private readonly SemaphoreSlim _gate = new(16); // 동시도 16
    public ObservableCollection<PhotoItem> Photos { get; } = new();

    [RelayCommand]
    public async Task LoadPageAsync(int page)
    {
        if (IsBusy) return;
        IsBusy = true;
        try
        {
            var urls = await _api.GetUrlsAsync(page, pageSize: 200);
            var tasks = urls.Select(async u =>
            {
                await _gate.WaitAsync();
                try
                {
                    var bytes = await _http.GetByteArrayAsync(u);
                    var thumb = await Task.Run(() => ToFrozenBitmap(bytes));
                    return new PhotoItem { Title = Path.GetFileName(u), Preview = thumb };
                }
                finally { _gate.Release(); }
            });

            var result = await Task.WhenAll(tasks);
            // UI 반영 배치
            foreach (var item in result) Photos.Add(item);
        }
        finally { IsBusy = false; }
    }
}
```

### 7.3 스크롤 프리페치
```csharp
private async void OnScrollChanged(object s, ScrollChangedEventArgs e)
{
    if (e.VerticalOffset + e.ViewportHeight >= e.ExtentHeight - 600)
        await ViewModel.LoadPageAsync(++_page);
}
```

**효과**  
- 보이는 항목만 템플릿 생성(가상화)  
- 이미지 I/O 병렬 + 디코딩 백그라운드 + Freeze  
- UI 반영은 **배치**  
- 끝 근처 프리페치로 끊김 완화

---

# 8) 추가 최적화

### 8.1 ReadyToRun(시작 지연 완화)
```xml
<PropertyGroup>
  <PublishReadyToRun>true</PublishReadyToRun>
</PropertyGroup>
```

### 8.2 단일파일(Self-contained) 배포 주의
- 첫 실행 압축 해제/백신 스캔으로 지연 가능 → **화이트리스트/ReadyToRun** 검토

### 8.3 컨버터/트리거 경량화
- 복잡 로직은 **VM에서 계산** → 바인딩은 단순 값  
- **OneTime/OneWay** 바인딩 적극 사용

---

# 9) 함정 & 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| 스크롤/입력 버벅 | UI에서 CPU/IO 처리 | `Task.Run`/`await` + Yield/배치 |
| UI 가상화 안 됨 | 픽셀 스크롤/WrapPanel/그룹핑 | `VirtualizingStackPanel` + 아이템 스크롤 + 가상화 옵션 |
| 이미지 로딩 때 UI 멈춤 | 디코딩/IO UI 스레드 실행 | 백그라운드 + `Freeze()` |
| BeginInvoke 폭주 | 항목별 UI 갱신 | **`WhenAll` 후 한번에 갱신** |
| 바인딩 성능 저하 | 컨버터 과다/양방향/동기화 폭주 | 값 사전계산 + `OneTime/OneWay` + 디바운스 |
| 교착 | `.Result/Wait()` | 항상 `await`, 라이브러리는 `ConfigureAwait(false)` |

---

# 10) 최종 체크리스트

**그리기 배치**
- [ ] `OnRender/StreamGeometry/Drawing*`로 요소 축소  
- [ ] Freezable(Brush/Geometry/Effect) **Freeze**  
- [ ] `BitmapCache`/DrawingImage 캐시

**I/O 병렬화**
- [ ] `async/await` + **동시도 제한**  
- [ ] 디코딩/처리는 백그라운드 + `Freeze`  
- [ ] UI 반영은 **배치 1회**

**지연 로딩**
- [ ] 리스트 **가상화 + 리사이클**  
- [ ] **끝 근처 프리페치**  
- [ ] 템플릿 **보일 때 로딩**

**UI 응답성**
- [ ] 긴 루프 **청크 + `Dispatcher.Yield`**  
- [ ] **디바운스/스로틀** 적용  
- [ ] 컬렉션/뷰 **배치 갱신**  
- [ ] 교착 유발 패턴 제거

---

## 마무리
이 네 가지 축을 지키면, **수만 건 데이터/이미지**도 “쓸 수 있을 만큼” **빠른 WPF**를 만들 수 있습니다.  
원하시면 기존 화면/XAML/로딩 코드 조각을 보내주세요. **시각 트리/바인딩/디스패처/IO** 관점으로 병목을 찾아 **개별 튜닝 제안**까지 바로 드릴게요. 🚀