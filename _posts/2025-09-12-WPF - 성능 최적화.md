---
layout: post
title: WPF - ì„±ëŠ¥ ìµœì í™”
date: 2025-09-12 16:25:23 +0900
category: WPF
---
# âš¡ WPF ì„±ëŠ¥ ìµœì í™” ëì¥ ê°€ì´ë“œ

**ì£¼ì œ:** ê·¸ë¦¬ê¸° ë°°ì¹˜(Drawing Batching) Â· I/O ë³‘ë ¬í™” Â· ì§€ì—° ë¡œë”© Â· UI ì‘ë‹µì„± ìœ ì§€
(*ì‹¤ì „ ì˜ˆì œ + ì²´í¬ë¦¬ìŠ¤íŠ¸ + í•¨ì •/í•´ê²° + ì§„ë‹¨ ë„êµ¬ê¹Œì§€ â€œëˆ„ë½ ì—†ì´â€ ì •ë¦¬*)

> ì´ ê¸€ì€ **WPF(.NET 6~8 í¬í•¨)** ê¸°ì¤€ìœ¼ë¡œ UI ì„±ëŠ¥ì„ ì¢Œìš°í•˜ëŠ” 4ëŒ€ ì¶•ì„ â€œì‹¤ë¬´ íŒ¨í„´â€ ì¤‘ì‹¬ìœ¼ë¡œ ì„¤ëª…í•©ë‹ˆë‹¤.
> ëª¨ë“  ì½”ë“œëŠ” **ê·¸ëŒ€ë¡œ ë³µë¶™ í›„ ì‹¤í–‰/ì‘ìš©**ì„ ëª©í‘œë¡œ ì‘ì„±í–ˆìŠµë‹ˆë‹¤.

---

## ì›ë¦¬ ìš”ì•½: WPFê°€ ëŠë ¤ì§€ëŠ” ìˆœê°„

- **ìš”ì†Œ(ì‹œê° íŠ¸ë¦¬) ìˆ˜ ê³¼ë‹¤** â†’ ì¸¡ì •/ë°°ì¹˜/ë°”ì¸ë”©/ë ˆì´ì•„ì›ƒ ë¹„ìš© í­ë°œ
- **UI ìŠ¤ë ˆë“œì—ì„œ CPU/IO ì‘ì—… ì‹¤í–‰** â†’ ì…ë ¥/ë Œë” ì¤‘ë‹¨(í”„ë¦¬ì¦ˆ)
- **ë¬´ë¶„ë³„í•œ ë°”ì¸ë”©/ì»¨ë²„í„°/ì—…ë°ì´íŠ¸** â†’ GC/ì•Œë¦¼ í­ì£¼
- **ì´ë¯¸ì§€ ë””ì½”ë”©/ìŠ¤ì¼€ì¼ë§/ì´í™íŠ¸** â†’ GPU/CPU ë³‘ëª©
- **ë„¤íŠ¸ì›Œí¬/ë””ìŠ¤í¬ I/O ì§í–‰** â†’ ëŒ€ê¸°/ë½ìœ¼ë¡œ ì‘ë‹µì„± í•˜ë½

**í•µì‹¬ ì „ëµ**
1) **ê·¸ë¦¬ê¸° ë°°ì¹˜**: â€œë§ì€ ìš”ì†Œâ€ â†’ â€œì ì€ ë“œë¡œì‰ í˜¸ì¶œâ€
2) **I/O ë³‘ë ¬í™”**: `async/await` + ë™ì‹œë„ ì œí•œ + UI ë°˜ì˜ ë°°ì¹˜
3) **ì§€ì—° ë¡œë”©**: í•„ìš”í•œ ìˆœê°„ì—ë§Œ ë°ì´í„°/ì´ë¯¸ì§€/í…œí”Œë¦¿ ë¡œë”©
4) **UI ì‘ë‹µì„± ìœ ì§€**: Dispatcherì— ì–‘ë³´Â·ì²­í¬ ì²˜ë¦¬Â·ë””ë°”ìš´ìŠ¤/ìŠ¤ë¡œí‹€

---

# ê·¸ë¦¬ê¸° ë°°ì¹˜(Drawing Batching)

### ìˆ˜ì²œ ê°œ Shape â†’ **í•œ ë²ˆì— ê·¸ë¦¬ê¸°**

`Path/Rectangle/TextBlock`ì„ ìˆ˜ì²œ ê°œ ë§Œë“¤ì§€ ë§ê³ , **`OnRender` + `DrawingContext`** ë¡œ í•œ ë²ˆì— ê·¸ë¦½ë‹ˆë‹¤.

```csharp
public class BatchedPolyline : FrameworkElement
{
    public IList<Point> Points
    {
        get => (IList<Point>)GetValue(PointsProperty);
        set => SetValue(PointsProperty, value);
    }
    public static readonly DependencyProperty PointsProperty =
        DependencyProperty.Register(nameof(Points), typeof(IList<Point>), typeof(BatchedPolyline),
            new FrameworkPropertyMetadata(new List<Point>(), FrameworkPropertyMetadataOptions.AffectsRender));

    protected override void OnRender(DrawingContext dc)
    {
        var pen = new Pen(Brushes.SteelBlue, 1);
        if (pen.CanFreeze) pen.Freeze();

        var geo = new StreamGeometry();
        using (var ctx = geo.Open())
        {
            if (Points.Count > 0)
            {
                ctx.BeginFigure(Points[0], isFilled: false, isClosed: false);
                for (int i = 1; i < Points.Count; i++)
                    ctx.LineTo(Points[i], isStroked: true, isSmoothJoin: false);
            }
        }
        if (geo.CanFreeze) geo.Freeze();

        dc.DrawGeometry(null, pen, geo); // âœ” í•œ ë²ˆì˜ ë“œë¡œì‰
    }
}
```

**íš¨ê³¼**
- ìš”ì†Œ 10,000ê°œ â†’ ìš”ì†Œ 1ê°œ + `OnRender` 1íšŒ
- ë ˆì´ì•„ì›ƒ/ë°”ì¸ë”©/ìƒí˜¸ì‘ìš© ì˜¤ë²„í—¤ë“œ ê¸‰ê°

---

### ë°˜ë³µë˜ëŠ” ë„í˜•/ì•„ì´ì½˜ â†’ **Drawing/DrawingImage/BitmapCache**

```csharp
// ì•„ì´ì½˜ ë²¡í„°ë¥¼ í•œë²ˆ êµ¬ì„±í•˜ê³  Freeze â†’ ì—¬ëŸ¬ ê³³ì—ì„œ ì¬ì‚¬ìš©
var circle = new GeometryDrawing(
    Brushes.CornflowerBlue,
    new Pen(Brushes.MidnightBlue, 2),
    new EllipseGeometry(new Point(10,10), 9, 9));
var group = new DrawingGroup();
group.Children.Add(circle);
if (group.CanFreeze) group.Freeze();
var image = new DrawingImage(group);
if (image.CanFreeze) image.Freeze();
MyImage.Source = image;
```

```xml
<!-- ìì£¼ ë³€í•˜ì§€ ì•ŠëŠ” ë¹„ì£¼ì–¼ì€ ë¹„íŠ¸ë§µ ìºì‹œë¡œ ë Œë” í˜¸ì¶œ ìµœì†Œí™” -->
<Border>
  <Border.CacheMode>
    <BitmapCache RenderAtScale="1"/>
  </Border.CacheMode>
  <!-- ë‚´ë¶€ì— ë²¡í„°/ë³µì¡ í…œí”Œë¦¿ -->
</Border>
```

---

### í…ìŠ¤íŠ¸ ëŒ€ëŸ‰ í‘œì‹œ ìµœì í™”

- `TextOptions.TextFormattingMode="Display"` (ëŒ€ìš©ëŸ‰ í…ìŠ¤íŠ¸ ëª©ë¡)
- êµµì€ íš¨ê³¼ ëŒ€ì‹  **í°íŠ¸ ìì²´ì˜ Weight** ì‚¬ìš©
- ê°™ì€ ë¬¸ìì—´ ë°˜ë³µ â†’ **FormattedText ìºì‹œ**(ê³ ê¸‰: DrawingContextì— ì§ì ‘ ê·¸ë¦¬ê¸°)

---

### ë ˆì´ì•„ì›ƒ ë¹„ìš© ì¤„ì´ê¸°

- `Grid`ì˜ ê³¼ë„í•œ `*` ì¤„ì´ê³  **ê³ ì • í­/í–‰** ìš°ì„ 
- ì¤‘ì²© Grid/StackPanel ìµœì†Œí™”, **UniformGrid** ì²˜ëŸ¼ ë‹¨ìˆœ ë ˆì´ì•„ì›ƒ í™œìš©
- `UseLayoutRounding="True"`, `SnapsToDevicePixels="True"` ë¡œ ì¬ì¸¡ì •/ë¸”ëŸ¬ ê°ì†Œ

---

### ì²´í¬ë¦¬ìŠ¤íŠ¸ â€” ê·¸ë¦¬ê¸° ë°°ì¹˜

- [ ] Shape/ì»¨íŠ¸ë¡¤ ë‚¨ë°œ â†’ **OnRender/DrawingVisual/StreamGeometry**ë¡œ ì§‘ì•½
- [ ] ë„í˜•/íš¨ê³¼/ë¸ŒëŸ¬ì‹œ/ì§€ì˜¤ë©”íŠ¸ë¦¬ëŠ” **Freeze** í›„ ì¬ì‚¬ìš©
- [ ] ë°˜ë³µ ì»¨í…ì¸ ëŠ” **DrawingImage** ë˜ëŠ” **BitmapCache**
- [ ] í…ìŠ¤íŠ¸ëŠ” **Display ëª¨ë“œ** + ìºì‹œ
- [ ] ë ˆì´ì•„ì›ƒì€ **ë‹¨ìˆœ/ê³ ì •ì¹˜ ìš°ì„ **

---

# I/O ë³‘ë ¬í™” (ë„¤íŠ¸ì›Œí¬/ë””ìŠ¤í¬)

### `async/await` + ë™ì‹œë„ ì œí•œ + ê²°ê³¼ **ë°°ì¹˜ ë°˜ì˜**

```csharp
public async Task LoadThumbsAsync(IEnumerable<string> urls, CancellationToken ct)
{
    using var http = new HttpClient();
    var gate = new SemaphoreSlim(8); // ë™ì‹œë„ 8
    var tasks = urls.Select(async url =>
    {
        await gate.WaitAsync(ct);
        try
        {
            var bytes = await http.GetByteArrayAsync(url, ct); // I/Oë§Œ
            return (url, bytes);
        }
        finally { gate.Release(); }
    });

    var results = await Task.WhenAll(tasks); // ë°±ê·¸ë¼ìš´ë“œ ì™„ë£Œ ëŒ€ê¸°

    // UIì—ëŠ” í•œ ë²ˆë§Œ ë°˜ì˜(ì¤‘ê°„ BeginInvoke í­ì£¼ ê¸ˆì§€)
    await Application.Current.Dispatcher.InvokeAsync(() =>
    {
        foreach (var (url, bytes) in results)
            Thumbnails.Add(new ThumbItem { Url = url, Bytes = bytes });
    });
}
```

---

### ì´ë¯¸ì§€ ë””ì½”ë”©ì€ **ë°±ê·¸ë¼ìš´ë“œ + Freeze**

```csharp
static BitmapImage ToFrozenBitmap(byte[] bytes)
{
    using var ms = new MemoryStream(bytes);
    var bi = new BitmapImage();
    bi.BeginInit();
    bi.CacheOption = BitmapCacheOption.OnLoad;
    bi.StreamSource = ms;
    bi.EndInit();
    bi.Freeze();             // âœ” UI ê²½ê³„ ì•ˆì „ + ë Œë” ìµœì í™”
    return bi;
}

var bmp = await Task.Run(() => ToFrozenBitmap(data), ct);
await Dispatcher.InvokeAsync(() => Image.Source = bmp);
```

---

### ì±„ë„(Producer/Consumer) íŒŒì´í”„ë¼ì¸ (ê³ ê¸‰)

ë§ì€ URL ì²˜ë¦¬ ì‹œ **ë°±í”„ë ˆì…”**ì™€ **ê· í˜•**ì„ ì¡ìŠµë‹ˆë‹¤.

```csharp
using System.Threading.Channels;

public async Task PipeAsync(IAsyncEnumerable<string> urls, CancellationToken ct)
{
    var channel = Channel.CreateBounded<byte[]>(new BoundedChannelOptions(32){ SingleReader=false, SingleWriter=false });

    // Producer: ë‹¤ìš´ë¡œë“œ
    var prod = Task.Run(async () =>
    {
        using var http = new HttpClient();
        await foreach (var u in urls.WithCancellation(ct))
            await channel.Writer.WriteAsync(await http.GetByteArrayAsync(u, ct), ct);
        channel.Writer.Complete();
    }, ct);

    // Consumers: ë””ì½”ë”© + UI ë“±ë¡ (4ê°œ ì›Œì»¤)
    var consumers = Enumerable.Range(0, 4).Select(_ => Task.Run(async () =>
    {
        await foreach (var bytes in channel.Reader.ReadAllAsync(ct))
        {
            var bmp = ToFrozenBitmap(bytes);
            await Dispatcher.InvokeAsync(() => Images.Add(bmp));
        }
    }, ct)).ToArray();

    await Task.WhenAll(consumers.Prepend(prod));
}
```

---

### ì²´í¬ë¦¬ìŠ¤íŠ¸ â€” I/O ë³‘ë ¬í™”

- [ ] `await`ë¡œ ìˆœìˆ˜ ë¹„ë™ê¸°, CPUëŠ” `Task.Run`
- [ ] **ë™ì‹œë„ ì œí•œ**(`SemaphoreSlim`)ìœ¼ë¡œ í­ì£¼ ë°©ì§€
- [ ] **UI ë°˜ì˜ì€ ë°°ì¹˜**(í•œ ë²ˆì—)
- [ ] ì´ë¯¸ì§€/ëŒ€ìš©ëŸ‰ ë””ì½”ë”©ì€ ë°±ê·¸ë¼ìš´ë“œ + **Freeze**
- [ ] íŒŒì´í”„ë¼ì¸(ì±„ë„/í)ë¡œ **ë°±í”„ë ˆì…”/ê· í˜•** í™•ë³´

---

# ì§€ì—° ë¡œë”©(Incremental/Lazy Loading)

### UI ê°€ìƒí™” + ë ê·¼ì²˜ í”„ë¦¬í˜ì¹˜(ë¬´í•œ ìŠ¤í¬ë¡¤)

```xml
<ListView ItemsSource="{Binding Items}"
          ScrollViewer.CanContentScroll="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          VirtualizingPanel.CacheLengthUnit="Item"
          VirtualizingPanel.CacheLength="2,4"/>
```

```csharp
private async void OnScrollChanged(object s, ScrollChangedEventArgs e)
{
    if (e.VerticalOffset + e.ViewportHeight >= e.ExtentHeight - 300)
    {
        if (!IsLoading && HasMore)
            await LoadNextPageAsync();     // ë‹¤ìŒ í˜ì´ì§€ ë¡œë“œ
    }
}
```

---

### í…œí”Œë¦¿ ì§€ì—° ë¡œë”© (ë³´ì¼ ë•Œë§Œ ë¬´ê±°ìš´ ë¶€ë¶„ ë¡œë“œ)

```xml
<DataTemplate DataType="{x:Type vm:Photo}">
  <Grid>
    <!-- ê°€ë²¼ìš´ í”„ë¦¬ë·° ë¨¼ì € -->
    <Image Source="{Binding Preview}" Width="240" Height="160"/>

    <!-- ê°€ì‹œí™” í›„ ë™ì  ë¡œë”© -->
    <ContentControl local:LazyLoader.LoadCommand="{Binding LoadFullCommand}"/>
  </Grid>
</DataTemplate>
```

```csharp
// LazyLoader.cs - Attached Property(ë³´ì¼ ë•Œ ì»¤ë§¨ë“œ ì‹¤í–‰)
public static class LazyLoader
{
    public static readonly DependencyProperty LoadCommandProperty =
        DependencyProperty.RegisterAttached("LoadCommand", typeof(ICommand), typeof(LazyLoader),
        new PropertyMetadata(null, OnChanged));

    static void OnChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is FrameworkElement fe)
        {
            fe.IsVisibleChanged -= OnVisible;
            fe.IsVisibleChanged += OnVisible;
        }
    }
    static void OnVisible(object sender, DependencyPropertyChangedEventArgs e)
    {
        if (sender is FrameworkElement fe && fe.IsVisible)
            (GetLoadCommand(fe) as ICommand)?.Execute(null);
    }

    public static void SetLoadCommand(DependencyObject o, ICommand v) => o.SetValue(LoadCommandProperty, v);
    public static ICommand GetLoadCommand(DependencyObject o) => (ICommand)o.GetValue(LoadCommandProperty);
}
```

ë·°ëª¨ë¸:
```csharp
[RelayCommand]
private async Task LoadFullAsync()
{
    if (IsLoaded) return;
    IsLoaded = true;
    Full = await _photoService.GetFullAsync(Id); // I/O
}
```

---

### ë°ì´í„° ê°€ìƒí™” ì»¬ë ‰ì…˜ (ê°„ë‹¨ íŒ¨í„´)

```csharp
public sealed class PagedCollection<T> : ObservableCollection<T>
{
    private readonly Func<int, Task<IReadOnlyList<T>>> _loader;
    public int Page { get; private set; } = 0;
    public bool HasMore { get; private set; } = true;
    public PagedCollection(Func<int, Task<IReadOnlyList<T>>> loader) => _loader = loader;

    public async Task LoadNextAsync()
    {
        if (!HasMore) return;
        var next = await _loader(++Page);
        foreach (var item in next) Add(item);
        if (next.Count == 0) HasMore = false;
    }
}
```

---

### ì²´í¬ë¦¬ìŠ¤íŠ¸ â€” ì§€ì—° ë¡œë”©

- [ ] **UI ê°€ìƒí™”**(ë¦¬ì‚¬ì´í´ ON)
- [ ] **ë¬´í•œ ìŠ¤í¬ë¡¤**: ë ê·¼ì²˜ í”„ë¦¬í˜ì¹˜
- [ ] í…œí”Œë¦¿ â€œë¬´ê±°ìš´ ë¶€ë¶„â€ì€ **ë³´ì¼ ë•Œ ë¡œë”©**
- [ ] ë°ì´í„°ëŠ” **í˜ì´ì§€ ë‹¨ìœ„**ë¡œ ê°€ì ¸ì˜¤ê³  ìºì‹œ/í•´ì œ ì •ì±… ìˆ˜ë¦½
- [ ] ì´ë¯¸ì§€/ë¬¸ì„œ **í”„ë¦¬ë·° â†’ ë³¸ë¬¸** 2ë‹¨ê³„ ë¡œë”©

---

# UI ì‘ë‹µì„± ìœ ì§€

### ê¸´ ì‘ì—… **ì²­í¬ ë¶„í•  + í”„ë ˆì„ ì–‘ë³´**

```csharp
public async Task ProcessManyAsync(IReadOnlyList<Item> items)
{
    const int chunk = 200;
    for (int i = 0; i < items.Count; i += chunk)
    {
        var slice = items.Skip(i).Take(chunk).ToList();
        await Task.Run(() => Compute(slice));                       // CPU
        await Dispatcher.Yield(DispatcherPriority.Background);       // ì…ë ¥/ë Œë” ê¸°íšŒ ì œê³µ
    }
}
```

---

### ë””ë°”ìš´ìŠ¤ / ìŠ¤ë¡œí‹€ (ì´ë²¤íŠ¸ í­ì£¼ ì™„í™”)

```csharp
public sealed class Debouncer
{
    private readonly DispatcherTimer _timer;
    private Action? _pending;
    public Debouncer(TimeSpan delay)
    {
        _timer = new DispatcherTimer { Interval = delay };
        _timer.Tick += (_,__) => { _timer.Stop(); _pending?.Invoke(); };
    }
    public void Run(Action action)
    {
        _pending = action;
        _timer.Stop();
        _timer.Start();
    }
}
// ì‚¬ìš©: TextChanged â†’ 300ms í›„ ê²€ìƒ‰
_debouncer.Run(async () => await SearchAsync());
```

---

### `DispatcherTimer` vs `System.Threading.Timer`

- **UI ì‘ì—…**: `DispatcherTimer` (UI ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì‹¤í–‰)
- **ì •ë°€/ë°±ê·¸ë¼ìš´ë“œ**: `Threading.Timer` (UI ì ‘ê·¼ ì‹œ Dispatcherë¡œ ë§ˆìƒ¬ë§)

```csharp
var uiTimer = new DispatcherTimer(DispatcherPriority.Background)
{ Interval = TimeSpan.FromMilliseconds(100) };
uiTimer.Tick += (_,__) => Progress++;
uiTimer.Start();
```

---

### ë°”ì¸ë”©/ì»¬ë ‰ì…˜ ì—…ë°ì´íŠ¸ **ë°°ì¹˜ ì²˜ë¦¬**

```csharp
public static class OcEx
{
    public static void ReplaceWith<T>(this ObservableCollection<T> oc, IEnumerable<T> items)
    {
        oc.Clear();
        foreach (var it in items) oc.Add(it);
    }
}
```

**ë˜ëŠ”** ë·° ê°±ì‹ ì´ ë¬´ê±°ìš´ ê²½ìš°:
```csharp
using (view.DeferRefresh())
{
    view.Filter = ...;
    view.SortDescriptions.Clear();
    view.SortDescriptions.Add(new SortDescription("Name", ListSortDirection.Ascending));
}
```

---

### êµì°©(Deadlock) íšŒí”¼ ê·œì¹™

- UIì—ì„œ **ì ˆëŒ€** `.Result`/`.Wait()` í•˜ì§€ ë§ ê²ƒ â†’ í•­ìƒ `await`
- ë°±ê·¸ë¼ìš´ë“œ â†’ UI ê°±ì‹ ì€ `BeginInvoke`/`InvokeAsync`
- ë¼ì´ë¸ŒëŸ¬ë¦¬ ê³„ì¸µ `await`ëŠ” `ConfigureAwait(false)` ê¶Œì¥

---

### ì²´í¬ë¦¬ìŠ¤íŠ¸ â€” UI ì‘ë‹µì„±

- [ ] ë¬´ê±°ìš´ ë£¨í”„ëŠ” **ì²­í¬ + Yield**
- [ ] ì…ë ¥/ê²€ìƒ‰/ìŠ¤í¬ë¡¤ì€ **ë””ë°”ìš´ìŠ¤/ìŠ¤ë¡œí‹€**
- [ ] ì»¬ë ‰ì…˜/ë°”ì¸ë”©ì€ **ë°°ì¹˜ ì—…ë°ì´íŠ¸**
- [ ] íƒ€ì´ë¨¸ ì„ íƒ: UIë©´ `DispatcherTimer`
- [ ] êµì°© ìœ ë°œ íŒ¨í„´ ì œê±°(`Result/Wait` ê¸ˆì§€)

---

# ì´ë¯¸ì§€/ë¯¸ë””ì–´ ê³ ì„±ëŠ¥ íŒ

### ìŠ¤ì¼€ì¼ë§ í’ˆì§ˆ ë™ì  ì „í™˜

```xml
<Image Source="{Binding Src}"
       RenderOptions.BitmapScalingMode="{Binding IsScrolling, Converter={StaticResource BoolToScalingMode}}"/>
```
- ìŠ¤í¬ë¡¤ ì¤‘: `LowQuality` / ì •ì§€: `HighQuality`
- ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸/ì¤‘ìš” ìƒíƒœì— ë§ì¶° ë°”ì¸ë”©

### ë Œë” í‹°ì–´ í™•ì¸

```csharp
var tier = (RenderCapability.Tier >> 16); // 0~2
```
- Tier 0 í™˜ê²½(ê°€ìƒë¨¸ì‹ , êµ¬í˜• GPU)ì—ì„œëŠ” **ì´í™íŠ¸ ìµœì†Œí™”**/ë²¡í„° â†’ ë¹„íŠ¸ë§µ ìºì‹œ

---

# ì§„ë‹¨ & ëª¨ë‹ˆí„°ë§

- **Snoop / Live Visual Tree**: ìš”ì†Œ/ë°”ì¸ë”© ì‹¤ì‹œê°„ í™•ì¸
- **WPF Performance Suite (Perforator)**: í”„ë ˆì„, ë ˆì´ì•„ì›ƒ, í…ìŠ¤ì³
- **ë°”ì¸ë”© íŠ¸ë ˆì´ìŠ¤**:
  ```xml
  <TextBlock Text="{Binding Name,
        diag:PresentationTraceSources.TraceLevel=High}"/>
  ```
- **Stopwatch/ETW/ë¡œê·¸**ë¡œ êµ¬ê°„ ì‹œê°„ ì¸¡ì •
- **ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬(dotMemory/VS)**: ëŒ€í˜• ê°ì²´/ì´ë¯¸ì§€ ëˆ„ìˆ˜ ì ê²€

---

# ì‹¤ì „ í†µí•© ì˜ˆì œ: â€œëŒ€ëŸ‰ ì¸ë„¤ì¼ ê·¸ë¦¬ë“œâ€

**ëª©í‘œ**:
- 5ë§Œ ê°œ ì´ë¯¸ì§€ URL ëª©ë¡ í‘œì‹œ
- ìŠ¤í¬ë¡¤ ë¶€ë“œëŸ¬ì›€ ìœ ì§€
- ì¸ë„¤ì¼ ë¡œë”©/ë””ì½”ë”© ë³‘ë ¬
- ì§€ì—° ë¡œë”©(ë³´ì´ëŠ” í˜ì´ì§€ë§Œ)
- í”„ë ˆì„ ë“œë ìµœì†Œí™”

### XAML

```xml
<ListView ItemsSource="{Binding Photos}"
          ScrollViewer.CanContentScroll="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          VirtualizingPanel.CacheLengthUnit="Item"
          VirtualizingPanel.CacheLength="2,4">
  <ListView.ItemsPanel>
    <ItemsPanelTemplate>
      <VirtualizingStackPanel/>
    </ItemsPanelTemplate>
  </ListView.ItemsPanel>

  <ListView.ItemTemplate>
    <DataTemplate DataType="{x:Type vm:PhotoItem}">
      <Grid Width="280" Height="180" Margin="6">
        <Border Background="#111" CornerRadius="8" />
        <Image Source="{Binding Preview}" Stretch="UniformToFill"/>
        <TextBlock Text="{Binding Title}" VerticalAlignment="Bottom" Foreground="White"
                   Background="#66000000" Padding="6,2"/>
      </Grid>
    </DataTemplate>
  </ListView.ItemTemplate>
</ListView>
```

### ViewModel (í•µì‹¬ë§Œ)

```csharp
public partial class GalleryViewModel : ObservableObject
{
    private readonly SemaphoreSlim _gate = new(16); // ë™ì‹œë„ 16
    public ObservableCollection<PhotoItem> Photos { get; } = new();

    [RelayCommand]
    public async Task LoadPageAsync(int page)
    {
        if (IsBusy) return;
        IsBusy = true;
        try
        {
            var urls = await _api.GetUrlsAsync(page, pageSize: 200);
            var tasks = urls.Select(async u =>
            {
                await _gate.WaitAsync();
                try
                {
                    var bytes = await _http.GetByteArrayAsync(u);
                    var thumb = await Task.Run(() => ToFrozenBitmap(bytes));
                    return new PhotoItem { Title = Path.GetFileName(u), Preview = thumb };
                }
                finally { _gate.Release(); }
            });

            var result = await Task.WhenAll(tasks);
            // UI ë°˜ì˜ ë°°ì¹˜
            foreach (var item in result) Photos.Add(item);
        }
        finally { IsBusy = false; }
    }
}
```

### ìŠ¤í¬ë¡¤ í”„ë¦¬í˜ì¹˜

```csharp
private async void OnScrollChanged(object s, ScrollChangedEventArgs e)
{
    if (e.VerticalOffset + e.ViewportHeight >= e.ExtentHeight - 600)
        await ViewModel.LoadPageAsync(++_page);
}
```

**íš¨ê³¼**
- ë³´ì´ëŠ” í•­ëª©ë§Œ í…œí”Œë¦¿ ìƒì„±(ê°€ìƒí™”)
- ì´ë¯¸ì§€ I/O ë³‘ë ¬ + ë””ì½”ë”© ë°±ê·¸ë¼ìš´ë“œ + Freeze
- UI ë°˜ì˜ì€ **ë°°ì¹˜**
- ë ê·¼ì²˜ í”„ë¦¬í˜ì¹˜ë¡œ ëŠê¹€ ì™„í™”

---

# ì¶”ê°€ ìµœì í™”

### ReadyToRun(ì‹œì‘ ì§€ì—° ì™„í™”)

```xml
<PropertyGroup>
  <PublishReadyToRun>true</PublishReadyToRun>
</PropertyGroup>
```

### ë‹¨ì¼íŒŒì¼(Self-contained) ë°°í¬ ì£¼ì˜

- ì²« ì‹¤í–‰ ì••ì¶• í•´ì œ/ë°±ì‹  ìŠ¤ìº”ìœ¼ë¡œ ì§€ì—° ê°€ëŠ¥ â†’ **í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸/ReadyToRun** ê²€í† 

### ì»¨ë²„í„°/íŠ¸ë¦¬ê±° ê²½ëŸ‰í™”

- ë³µì¡ ë¡œì§ì€ **VMì—ì„œ ê³„ì‚°** â†’ ë°”ì¸ë”©ì€ ë‹¨ìˆœ ê°’
- **OneTime/OneWay** ë°”ì¸ë”© ì ê·¹ ì‚¬ìš©

---

# í•¨ì • & í•´ê²°

| ì¦ìƒ | ì›ì¸ | í•´ê²° |
|---|---|---|
| ìŠ¤í¬ë¡¤/ì…ë ¥ ë²„ë²… | UIì—ì„œ CPU/IO ì²˜ë¦¬ | `Task.Run`/`await` + Yield/ë°°ì¹˜ |
| UI ê°€ìƒí™” ì•ˆ ë¨ | í”½ì…€ ìŠ¤í¬ë¡¤/WrapPanel/ê·¸ë£¹í•‘ | `VirtualizingStackPanel` + ì•„ì´í…œ ìŠ¤í¬ë¡¤ + ê°€ìƒí™” ì˜µì…˜ |
| ì´ë¯¸ì§€ ë¡œë”© ë•Œ UI ë©ˆì¶¤ | ë””ì½”ë”©/IO UI ìŠ¤ë ˆë“œ ì‹¤í–‰ | ë°±ê·¸ë¼ìš´ë“œ + `Freeze()` |
| BeginInvoke í­ì£¼ | í•­ëª©ë³„ UI ê°±ì‹  | **`WhenAll` í›„ í•œë²ˆì— ê°±ì‹ ** |
| ë°”ì¸ë”© ì„±ëŠ¥ ì €í•˜ | ì»¨ë²„í„° ê³¼ë‹¤/ì–‘ë°©í–¥/ë™ê¸°í™” í­ì£¼ | ê°’ ì‚¬ì „ê³„ì‚° + `OneTime/OneWay` + ë””ë°”ìš´ìŠ¤ |
| êµì°© | `.Result/Wait()` | í•­ìƒ `await`, ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `ConfigureAwait(false)` |

---

# ìµœì¢… ì²´í¬ë¦¬ìŠ¤íŠ¸

**ê·¸ë¦¬ê¸° ë°°ì¹˜**
- [ ] `OnRender/StreamGeometry/Drawing*`ë¡œ ìš”ì†Œ ì¶•ì†Œ
- [ ] Freezable(Brush/Geometry/Effect) **Freeze**
- [ ] `BitmapCache`/DrawingImage ìºì‹œ

**I/O ë³‘ë ¬í™”**
- [ ] `async/await` + **ë™ì‹œë„ ì œí•œ**
- [ ] ë””ì½”ë”©/ì²˜ë¦¬ëŠ” ë°±ê·¸ë¼ìš´ë“œ + `Freeze`
- [ ] UI ë°˜ì˜ì€ **ë°°ì¹˜ 1íšŒ**

**ì§€ì—° ë¡œë”©**
- [ ] ë¦¬ìŠ¤íŠ¸ **ê°€ìƒí™” + ë¦¬ì‚¬ì´í´**
- [ ] **ë ê·¼ì²˜ í”„ë¦¬í˜ì¹˜**
- [ ] í…œí”Œë¦¿ **ë³´ì¼ ë•Œ ë¡œë”©**

**UI ì‘ë‹µì„±**
- [ ] ê¸´ ë£¨í”„ **ì²­í¬ + `Dispatcher.Yield`**
- [ ] **ë””ë°”ìš´ìŠ¤/ìŠ¤ë¡œí‹€** ì ìš©
- [ ] ì»¬ë ‰ì…˜/ë·° **ë°°ì¹˜ ê°±ì‹ **
- [ ] êµì°© ìœ ë°œ íŒ¨í„´ ì œê±°

---

## ë§ˆë¬´ë¦¬

ì´ ë„¤ ê°€ì§€ ì¶•ì„ ì§€í‚¤ë©´, **ìˆ˜ë§Œ ê±´ ë°ì´í„°/ì´ë¯¸ì§€**ë„ â€œì“¸ ìˆ˜ ìˆì„ ë§Œí¼â€ **ë¹ ë¥¸ WPF**ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì›í•˜ì‹œë©´ ê¸°ì¡´ í™”ë©´/XAML/ë¡œë”© ì½”ë“œ ì¡°ê°ì„ ë³´ë‚´ì£¼ì„¸ìš”. **ì‹œê° íŠ¸ë¦¬/ë°”ì¸ë”©/ë””ìŠ¤íŒ¨ì²˜/IO** ê´€ì ìœ¼ë¡œ ë³‘ëª©ì„ ì°¾ì•„ **ê°œë³„ íŠœë‹ ì œì•ˆ**ê¹Œì§€ ë°”ë¡œ ë“œë¦´ê²Œìš”. ğŸš€
