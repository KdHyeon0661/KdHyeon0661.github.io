---
layout: post
title: WPF - 성능 최적화
date: 2025-09-12 16:25:23 +0900
category: WPF
---
# WPF 성능 최적화 실전 가이드

이 가이드는 WPF 애플리케이션의 성능을 크게 향상시킬 수 있는 핵심적인 최적화 기술들을 다룹니다. 그리기 배치, I/O 병렬화, 지연 로딩, UI 응답성 유지라는 네 가지 주요 축을 중심으로 실전에서 바로 적용할 수 있는 패턴과 기법들을 설명합니다.

## WPF 성능 문제의 주요 원인

WPF 애플리케이션이 느려지는 일반적인 원인들은 다음과 같습니다:

- **시각적 요소가 과도하게 많음**: 측정, 배치, 바인딩, 레이아웃 비용이 기하급수적으로 증가합니다.
- **UI 스레드에서 무거운 작업 실행**: CPU 집약적 작업이나 I/O 작업이 UI 스레드를 차단하여 입력과 렌더링이 중단됩니다.
- **비효율적인 데이터 바인딩**: 불필요한 컨버터, 너무 빈번한 업데이트, 양방향 바인딩 오용으로 GC 부하가 증가합니다.
- **이미지 처리 비효율**: 고해상도 이미지 디코딩, 스케일링, 복잡한 효과 적용으로 GPU와 CPU에 부하가 발생합니다.
- **동기적 I/O 작업**: 네트워크나 디스크 I/O가 동기적으로 실행되어 UI 응답성이 저하됩니다.

## 핵심 최적화 전략

성능 문제를 해결하기 위한 네 가지 핵심 전략은 다음과 같습니다:

1. **그리기 배치**: 많은 개별 요소를 적은 수의 드로잉 호출로 통합합니다.
2. **I/O 병렬화**: 비동기 프로그래밍과 동시성 제어를 통해 I/O 작업을 효율적으로 처리합니다.
3. **지연 로딩**: 필요할 때만 데이터, 이미지, 템플릿을 로드합니다.
4. **UI 응답성 유지**: 작업을 청크로 분할하고, 디바운싱과 스로틀링을 적용하며, Dispatcher를 적절히 활용합니다.

## 그리기 배치 최적화

### 대량 Shape를 단일 드로잉으로 통합

수천 개의 개별 Path, Rectangle, TextBlock을 생성하는 대신, `OnRender` 메서드와 `DrawingContext`를 사용하여 한 번에 그리는 것이 효율적입니다.

```csharp
public class OptimizedPolyline : FrameworkElement
{
    public IList<Point> Points
    {
        get => (IList<Point>)GetValue(PointsProperty);
        set => SetValue(PointsProperty, value);
    }
    
    public static readonly DependencyProperty PointsProperty =
        DependencyProperty.Register(nameof(Points), typeof(IList<Point>), typeof(OptimizedPolyline),
            new FrameworkPropertyMetadata(new List<Point>(), FrameworkPropertyMetadataOptions.AffectsRender));

    protected override void OnRender(DrawingContext drawingContext)
    {
        var pen = new Pen(Brushes.SteelBlue, 1);
        if (pen.CanFreeze) pen.Freeze();

        var geometry = new StreamGeometry();
        using (var context = geometry.Open())
        {
            if (Points.Count > 0)
            {
                context.BeginFigure(Points[0], isFilled: false, isClosed: false);
                for (int i = 1; i < Points.Count; i++)
                {
                    context.LineTo(Points[i], isStroked: true, isSmoothJoin: false);
                }
            }
        }
        
        if (geometry.CanFreeze) geometry.Freeze();
        drawingContext.DrawGeometry(null, pen, geometry);
    }
}
```

이 방식의 장점은 요소 10,000개를 1개의 요소와 1번의 드로잉 호출로 줄일 수 있어 레이아웃, 바인딩, 상호작용 오버헤드를 크게 감소시킬 수 있다는 점입니다.

### Drawing 객체 재사용과 Freeze 활용

반복적으로 사용되는 도형이나 아이콘은 Drawing 객체로 생성하고 Freeze하여 재사용할 수 있습니다:

```csharp
// Drawing 객체 생성 및 Freeze
var circleDrawing = new GeometryDrawing(
    Brushes.CornflowerBlue,
    new Pen(Brushes.MidnightBlue, 2),
    new EllipseGeometry(new Point(10, 10), 9, 9));
    
var drawingGroup = new DrawingGroup();
drawingGroup.Children.Add(circleDrawing);

if (drawingGroup.CanFreeze) drawingGroup.Freeze();

var drawingImage = new DrawingImage(drawingGroup);
if (drawingImage.CanFreeze) drawingImage.Freeze();

// 사용
MyImage.Source = drawingImage;
```

### BitmapCache를 활용한 렌더링 최적화

자주 변경되지 않는 비주얼 요소는 BitmapCache를 적용하여 렌더링 호출을 최소화할 수 있습니다:

```xml
<Border>
    <Border.CacheMode>
        <BitmapCache RenderAtScale="1"/>
    </Border.CacheMode>
    <!-- 복잡한 내부 콘텐츠 -->
</Border>
```

### 텍스트 렌더링 최적화

대량의 텍스트를 렌더링할 때는 다음과 같은 최적화를 고려하세요:
- `TextOptions.TextFormattingMode="Display"` 설정
- 굵은 효과 대신 폰트 자체의 Weight 사용
- 동일한 문자열 반복 시 FormattedText 캐싱

### 레이아웃 성능 개선

레이아웃 성능을 개선하기 위한 팁:
- Grid의 과도한 `*` 크기 지정을 피하고 고정 크기 우선 사용
- 중첩된 Grid나 StackPanel 최소화, UniformGrid 같은 단순 레이아웃 활용
- `UseLayoutRounding="True"`와 `SnapsToDevicePixels="True"` 설정으로 재측정과 블러 현상 감소

## I/O 병렬화 최적화

### 비동기 프로그래밍과 동시성 제어

네트워크나 디스크 I/O 작업을 효율적으로 처리하기 위한 패턴:

```csharp
public async Task LoadThumbnailsAsync(IEnumerable<string> urls, CancellationToken cancellationToken)
{
    using var httpClient = new HttpClient();
    var semaphore = new SemaphoreSlim(8); // 최대 8개의 동시 작업
    
    var downloadTasks = urls.Select(async url =>
    {
        await semaphore.WaitAsync(cancellationToken);
        try
        {
            var imageData = await httpClient.GetByteArrayAsync(url, cancellationToken);
            return (url, imageData);
        }
        finally
        {
            semaphore.Release();
        }
    });
    
    var results = await Task.WhenAll(downloadTasks);
    
    // UI 업데이트는 한 번에 배치 처리
    await Application.Current.Dispatcher.InvokeAsync(() =>
    {
        foreach (var (url, data) in results)
        {
            Thumbnails.Add(new ThumbnailItem { Url = url, ImageData = data });
        }
    });
}
```

### 이미지 디코딩 백그라운드 처리

이미지 디코딩은 CPU 집약적 작업이므로 백그라운드에서 처리하고 Freeze하여 스레드 안전성을 보장하세요:

```csharp
private static BitmapImage CreateFrozenBitmap(byte[] imageData)
{
    using var memoryStream = new MemoryStream(imageData);
    var bitmap = new BitmapImage();
    
    bitmap.BeginInit();
    bitmap.CacheOption = BitmapCacheOption.OnLoad;
    bitmap.StreamSource = memoryStream;
    bitmap.EndInit();
    bitmap.Freeze(); // 스레드 안전성과 렌더링 최적화
    
    return bitmap;
}

// 사용 예시
var bitmap = await Task.Run(() => CreateFrozenBitmap(imageData));
await Dispatcher.InvokeAsync(() => ImageControl.Source = bitmap);
```

### 파이프라인 패턴 활용

대량의 URL을 처리할 때는 파이프라인 패턴을 사용하여 백프레셔와 부하 분산을 관리할 수 있습니다:

```csharp
public async Task ProcessUrlsWithPipelineAsync(IAsyncEnumerable<string> urls, CancellationToken cancellationToken)
{
    var channel = Channel.CreateBounded<byte[]>(new BoundedChannelOptions(32)
    {
        SingleReader = false,
        SingleWriter = false
    });
    
    // 생산자: 이미지 다운로드
    var producer = Task.Run(async () =>
    {
        using var httpClient = new HttpClient();
        
        await foreach (var url in urls.WithCancellation(cancellationToken))
        {
            var data = await httpClient.GetByteArrayAsync(url, cancellationToken);
            await channel.Writer.WriteAsync(data, cancellationToken);
        }
        
        channel.Writer.Complete();
    }, cancellationToken);
    
    // 소비자: 이미지 디코딩 및 UI 업데이트 (4개 워커)
    var consumers = Enumerable.Range(0, 4).Select(_ => Task.Run(async () =>
    {
        await foreach (var imageData in channel.Reader.ReadAllAsync(cancellationToken))
        {
            var bitmap = CreateFrozenBitmap(imageData);
            await Dispatcher.InvokeAsync(() => ImageCollection.Add(bitmap));
        }
    }, cancellationToken)).ToArray();
    
    await Task.WhenAll(consumers.Prepend(producer));
}
```

## 지연 로딩 구현

### UI 가상화와 무한 스크롤

대용량 목록을 처리할 때는 UI 가상화를 활성화하고 무한 스크롤을 구현하세요:

```xml
<ListView ItemsSource="{Binding Items}"
          ScrollViewer.CanContentScroll="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          VirtualizingPanel.CacheLengthUnit="Item"
          VirtualizingPanel.CacheLength="2,4">
</ListView>
```

```csharp
private async void OnScrollChanged(object sender, ScrollChangedEventArgs e)
{
    // 목록 끝 근처에 도달하면 다음 페이지 로드
    if (e.VerticalOffset + e.ViewportHeight >= e.ExtentHeight - 300)
    {
        if (!IsLoading && HasMoreItems)
        {
            await LoadNextPageAsync();
        }
    }
}
```

### 템플릿 지연 로딩

무거운 템플릿 구성 요소는 필요한 시점에만 로드하도록 구현할 수 있습니다:

```csharp
public static class LazyLoader
{
    public static readonly DependencyProperty LoadCommandProperty =
        DependencyProperty.RegisterAttached("LoadCommand", typeof(ICommand), typeof(LazyLoader),
            new PropertyMetadata(null, OnLoadCommandChanged));
    
    private static void OnLoadCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is FrameworkElement element)
        {
            element.IsVisibleChanged -= OnElementVisibilityChanged;
            element.IsVisibleChanged += OnElementVisibilityChanged;
        }
    }
    
    private static void OnElementVisibilityChanged(object sender, DependencyPropertyChangedEventArgs e)
    {
        if (sender is FrameworkElement element && element.IsVisible)
        {
            var command = GetLoadCommand(element);
            command?.Execute(null);
        }
    }
    
    public static void SetLoadCommand(DependencyObject element, ICommand value) =>
        element.SetValue(LoadCommandProperty, value);
    
    public static ICommand GetLoadCommand(DependencyObject element) =>
        (ICommand)element.GetValue(LoadCommandProperty);
}
```

XAML에서 사용:
```xml
<DataTemplate DataType="{x:Type local:PhotoViewModel}">
    <Grid>
        <!-- 가벼운 프리뷰 -->
        <Image Source="{Binding PreviewImage}" Width="240" Height="160"/>
        
        <!-- 보일 때만 로드되는 무거운 콘텐츠 -->
        <ContentControl local:LazyLoader.LoadCommand="{Binding LoadFullResolutionCommand}"/>
    </Grid>
</DataTemplate>
```

### 페이지 단위 데이터 로딩

대용량 데이터셋은 페이지 단위로 로드하는 컬렉션을 구현할 수 있습니다:

```csharp
public class PagedCollection<T> : ObservableCollection<T>
{
    private readonly Func<int, Task<IReadOnlyList<T>>> _pageLoader;
    private int _currentPage = 0;
    private bool _hasMorePages = true;
    
    public PagedCollection(Func<int, Task<IReadOnlyList<T>>> pageLoader)
    {
        _pageLoader = pageLoader;
    }
    
    public async Task LoadNextPageAsync()
    {
        if (!_hasMorePages) return;
        
        var nextPageItems = await _pageLoader(++_currentPage);
        
        foreach (var item in nextPageItems)
        {
            Add(item);
        }
        
        if (nextPageItems.Count == 0)
        {
            _hasMorePages = false;
        }
    }
    
    public bool HasMorePages => _hasMorePages;
}
```

## UI 응답성 유지 기법

### 긴 작업의 청크 분할

긴 실행 시간이 예상되는 작업은 작은 청크로 나누고, 각 청크 사이에 UI에 양보할 기회를 제공하세요:

```csharp
public async Task ProcessLargeDatasetAsync(IReadOnlyList<DataItem> items)
{
    const int chunkSize = 200;
    
    for (int i = 0; i < items.Count; i += chunkSize)
    {
        var chunk = items.Skip(i).Take(chunkSize).ToList();
        
        // CPU 집약적 작업 백그라운드 실행
        await Task.Run(() => ProcessChunk(chunk));
        
        // UI에 렌더링과 입력 처리 기회 제공
        await Dispatcher.Yield(DispatcherPriority.Background);
    }
}
```

### 디바운싱과 스로틀링

사용자 입력 이벤트가 너무 빈번하게 발생하는 경우 디바운싱이나 스로틀링을 적용하세요:

```csharp
public class Debouncer
{
    private readonly DispatcherTimer _timer;
    private Action? _pendingAction;
    
    public Debouncer(TimeSpan delay)
    {
        _timer = new DispatcherTimer { Interval = delay };
        _timer.Tick += OnTimerTick;
    }
    
    public void Execute(Action action)
    {
        _pendingAction = action;
        _timer.Stop();
        _timer.Start();
    }
    
    private void OnTimerTick(object? sender, EventArgs e)
    {
        _timer.Stop();
        _pendingAction?.Invoke();
        _pendingAction = null;
    }
}

// 사용 예시: 검색 입력
private readonly Debouncer _searchDebouncer = new(TimeSpan.FromMilliseconds(300));

private void SearchTextBox_TextChanged(object sender, TextChangedEventArgs e)
{
    _searchDebouncer.Execute(async () => await PerformSearchAsync());
}
```

### 컬렉션 업데이트 배치 처리

여러 항목을 한 번에 추가하거나 제거할 때는 배치 처리를 적용하세요:

```csharp
public static class ObservableCollectionExtensions
{
    public static void AddRange<T>(this ObservableCollection<T> collection, IEnumerable<T> items)
    {
        foreach (var item in items)
        {
            collection.Add(item);
        }
    }
    
    public static void ReplaceAll<T>(this ObservableCollection<T> collection, IEnumerable<T> items)
    {
        collection.Clear();
        
        foreach (var item in items)
        {
            collection.Add(item);
        }
    }
}
```

CollectionView를 사용하는 경우 `DeferRefresh`를 활용할 수 있습니다:

```csharp
using (collectionView.DeferRefresh())
{
    collectionView.Filter = item => FilterCondition(item);
    collectionView.SortDescriptions.Clear();
    collectionView.SortDescriptions.Add(
        new SortDescription("Name", ListSortDirection.Ascending));
}
```

## 이미지와 미디어 성능 최적화

### 동적 스케일링 품질 조정

스크롤 중에는 이미지 품질을 낮추고, 정지 상태에서는 높은 품질로 표시할 수 있습니다:

```xml
<Image Source="{Binding ImageSource}"
       RenderOptions.BitmapScalingMode="{Binding IsScrolling, 
           Converter={StaticResource ScrollingToScalingModeConverter}}"/>
```

컨버터 구현:
```csharp
public class ScrollingToScalingModeConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool isScrolling && isScrolling)
        {
            return BitmapScalingMode.LowQuality;
        }
        
        return BitmapScalingMode.HighQuality;
    }
    
    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
```

### 렌더링 계층 확인

애플리케이션이 실행되는 하드웨어의 렌더링 능력을 확인하고 적절히 대응하세요:

```csharp
public void AdjustGraphicsBasedOnHardware()
{
    var renderingTier = (RenderCapability.Tier >> 16);
    
    if (renderingTier < 2) // Tier 0 또는 1 (기본 또는 부분 하드웨어 가속)
    {
        // 복잡한 효과 비활성화
        // 벡터 그래픽 대신 비트맵 캐시 사용
        // 애니메이션 복잡도 감소
    }
}
```

## 성능 진단과 모니터링

효과적인 성능 최적화를 위해서는 정확한 진단이 필수적입니다:

1. **Snoop 또는 Live Visual Tree**: 실시간으로 시각적 트리와 바인딩 상태를 확인
2. **WPF Performance Suite**: 프레임률, 레이아웃 비용, 텍스처 사용량 분석
3. **바인딩 트레이스**: 문제 있는 바인딩 식별
   ```xml
   <TextBlock Text="{Binding ItemName, 
                diag:PresentationTraceSources.TraceLevel=High}"/>
   ```
4. **성능 프로파일링**: Stopwatch, ETW 이벤트, 구조화된 로깅을 활용한 구간별 실행 시간 측정
5. **메모리 프로파일링**: 대형 객체 힙, 이미지 메모리, 이벤트 핸들러 누수 점검

## 실전 예제: 대용량 이미지 갤러리

실제 프로젝트에 적용할 수 있는 종합적인 예제로, 대용량 이미지 갤러리를 구현해 보겠습니다:

### XAML 구성

```xml
<ListView ItemsSource="{Binding Photos}"
          ScrollViewer.CanContentScroll="True"
          VirtualizingStackPanel.IsVirtualizing="True"
          VirtualizingStackPanel.VirtualizationMode="Recycling"
          VirtualizingPanel.CacheLengthUnit="Item"
          VirtualizingPanel.CacheLength="2,4">
    
    <ListView.ItemsPanel>
        <ItemsPanelTemplate>
            <VirtualizingStackPanel Orientation="Horizontal"/>
        </ItemsPanelTemplate>
    </ListView.ItemsPanel>
    
    <ListView.ItemTemplate>
        <DataTemplate DataType="{x:Type local:PhotoViewModel}">
            <Border Width="280" Height="180" Margin="6" Background="#111" CornerRadius="8">
                <Image Source="{Binding Thumbnail}" Stretch="UniformToFill"/>
            </Border>
        </DataTemplate>
    </ListView.ItemTemplate>
</ListView>
```

### ViewModel 구현

```csharp
public class GalleryViewModel : ObservableObject
{
    private readonly SemaphoreSlim _concurrencyLimiter = new(16);
    private readonly HttpClient _httpClient = new();
    private int _currentPage = 0;
    
    public ObservableCollection<PhotoViewModel> Photos { get; } = new();
    public bool IsLoading { get; private set; }
    public bool HasMorePhotos { get; private set; } = true;
    
    public async Task LoadNextPageAsync()
    {
        if (IsLoading || !HasMorePhotos) return;
        
        IsLoading = true;
        
        try
        {
            var imageUrls = await FetchImageUrlsAsync(_currentPage++, 50);
            
            var downloadTasks = imageUrls.Select(async url =>
            {
                await _concurrencyLimiter.WaitAsync();
                
                try
                {
                    var imageData = await _httpClient.GetByteArrayAsync(url);
                    var thumbnail = await Task.Run(() => CreateOptimizedThumbnail(imageData));
                    return new PhotoViewModel { ImageUrl = url, Thumbnail = thumbnail };
                }
                finally
                {
                    _concurrencyLimiter.Release();
                }
            });
            
            var photos = await Task.WhenAll(downloadTasks);
            
            // UI 업데이트 배치 처리
            await Application.Current.Dispatcher.InvokeAsync(() =>
            {
                foreach (var photo in photos)
                {
                    Photos.Add(photo);
                }
            });
            
            if (photos.Length < 50)
            {
                HasMorePhotos = false;
            }
        }
        finally
        {
            IsLoading = false;
        }
    }
    
    private async Task<string[]> FetchImageUrlsAsync(int page, int pageSize)
    {
        // 실제 구현에서는 API 호출 등
        await Task.Delay(100); // 시뮬레이션
        return Enumerable.Range(0, pageSize)
            .Select(i => $"https://example.com/images/{page}_{i}.jpg")
            .ToArray();
    }
    
    private static BitmapImage CreateOptimizedThumbnail(byte[] imageData)
    {
        using var stream = new MemoryStream(imageData);
        var bitmap = new BitmapImage();
        
        bitmap.BeginInit();
        bitmap.CacheOption = BitmapCacheOption.OnLoad;
        bitmap.DecodePixelWidth = 280; // 실제 표시 크기로 디코딩
        bitmap.StreamSource = stream;
        bitmap.EndInit();
        bitmap.Freeze();
        
        return bitmap;
    }
}
```

### 스크롤 이벤트 처리

```csharp
private async void OnGalleryScrollChanged(object sender, ScrollChangedEventArgs e)
{
    var scrollViewer = (ScrollViewer)sender;
    
    // 목록의 끝에서 600픽셀 이내에 도달하면 다음 페이지 로드
    if (scrollViewer.VerticalOffset + scrollViewer.ViewportHeight >= 
        scrollViewer.ExtentHeight - 600)
    {
        await _viewModel.LoadNextPageAsync();
    }
}
```

## 결론

WPF 애플리케이션의 성능 최적화는 단일 기법이 아니라 여러 전략의 조합으로 이루어집니다. 이 가이드에서 소개한 네 가지 핵심 전략—그리기 배치, I/O 병렬화, 지연 로딩, UI 응답성 유지—을 효과적으로 적용하면 대용량 데이터 처리에서도 뛰어난 사용자 경험을 제공할 수 있습니다.

성공적인 최적화를 위한 핵심 원칙은 다음과 같습니다:

1. **측정 후 최적화**: 성능 병목 지점을 정확히 식별한 후에 최적화를 적용하세요.
2. **점진적 개선**: 한 번에 모든 것을 최적화하려 하지 말고, 가장 영향이 큰 부분부터 차례로 개선하세요.
3. **사용자 경험 중심**: 기술적 최적화보다는 실제 사용자가 체감하는 성능 향상에 집중하세요.
4. **유지보수성 고려**: 과도한 최적화로 코드 가독성과 유지보수성을 해치지 마세요.

이러한 원칙과 기법들을 현명하게 적용하면, 복잡한 비즈니스 요구사항을 갖춘 WPF 애플리케이션에서도 뛰어난 성능과 반응성을 달성할 수 있을 것입니다.