---
layout: post
title: Elixir - 패턴 매칭
date: 2025-11-14 15:25:23 +0900
category: Elixir
---
# `=` 는 할당이 아니라 “매칭”이다 — 패턴 매칭, 언더스코어, 핀 연산자, 등호를 다시 보는 법

## _2.1 할당문: 당신이 생각하는 할당문이 아니다

많은 언어에서 `=` 는 “**왼쪽 변수에 오른쪽 값을 대입**”하는 연산자다.
하지만 **엘릭서에서 `=` 는 “패턴과 값의 매칭(match)” 연산자**다. 공식 가이드에서도 `=` 를 **match operator**라고 부른다.

조금 더 엄밀하게 말하면:

1. **오른쪽(RHS)** 표현식을 먼저 **평가**한다.
2. **왼쪽(LHS)** 은 “패턴(pattern)”으로 간주된다.
3. 이 패턴이 오른쪽 값과 **형태와 내용이 일치**할 수 있으면,
   - 패턴 안에 아직 값이 없는 변수들은 그 값으로 **바인딩(이름 붙이기)** 된다.
4. 일치할 수 없으면 **`MatchError` 예외**가 발생한다.

즉, 엘릭서에서 `=` 는 “**방정식이 성립하도록 미지수(변수)에 값을 부여하는 연산**”에 가깝다.

### 기본 예제: “대입”처럼 보이지만 사실은 매칭

```elixir
iex> x = 10         # x라는 '패턴(변수)'에 10이라는 값이 매칭된다
10
iex> x
10
```

겉으로 보면 다른 언어의 대입과 동일하다. 하지만 튜플로 가 보면 차이가 바로 드러난다.

```elixir
iex> {:ok, v} = {:ok, 42}
{:ok, 42}
iex> v
42

iex> {:ok, v} = {:error, :bad}
** (MatchError) no match of right hand side value: {:error, :bad}
```

- `{:ok, v}`는 “**첫 요소가 `:ok` 이고, 두 번째 요소가 어떤 값인 2원 튜플**”이라는 패턴이다.
- `{:error, :bad}`는 첫 요소가 `:error` 이므로 이 패턴과 **형태가 맞지 않아 매칭 실패** → `MatchError`.

다른 언어라면 `:=`, `.ok`, `if` 같은 코드가 필요할 부분을, 엘릭서는 **형태 제약(패턴)** 으로 표현한다.

### “재할당”처럼 보이지만 실제로는 “새 매칭”

엘릭서 변수는 **불변(immutable)** 이다. 값이 바뀌는 것이 아니라, **이름이 새 값을 가리키도록 “다시 바인딩”** 된다.

```elixir
iex> a = 1      # a ↦ 1
1
iex> a = 2      # a ↦ 2 (1이 바뀐 게 아니라, a가 다른 값을 가리킴)
2
iex> a
2
```

한 줄마다 독립된 “매칭 식”이 있고, 그 매칭에서 `a`는 **한 번만** 값이 주어진다. 이전 매칭에서의 값 1은 여전히 어딘가에 있지만, 더 이상 `a`라는 이름으로는 접근하지 않을 뿐이다.

이 관점에서 보면:

- “변수는 불변”이라는 말은 “**한 번 바인딩된 값은 내부에서 변경되지 않는다**”는 뜻이고,
- “재할당”은 사실 “**새 매칭, 새 바인딩**”이다.

### 방향성: “오른쪽을 평가하고, 왼쪽은 검증(패턴)”만 한다

```elixir
iex> [h | t] = Enum.to_list(1..3) |> Enum.reverse()
[3, 2, 1]
iex> h
3
iex> t
[2, 1]
```

- `Enum.to_list(1..3) |> Enum.reverse()` 가 먼저 평가되어 `[3, 2, 1]` 이 되고,
- 그 값이 `[h | t]` 패턴과 매칭된다.
- `h`는 리스트의 첫 원소, `t`는 나머지 꼬리 부분에 바인딩된다.

이 패턴을 다른 언어식으로 쓰면 대략 다음과 같다:

```pseudo
tmp = Enum.to_list(1..3).reverse()
h   = tmp.head
t   = tmp.tail
```

하지만 엘릭서에서는 **일관된 `=` 문법과 패턴**만으로 같은 일을 한다.

### 비교 연산과의 차이: `=` vs `==` vs `===`

엘릭서에는 `=`, `==`, `===` 세 가지가 자주 헷갈린다. 역할을 표로 정리해 보면:

| 연산자 | 의미 | 예 |
|--------|------|----|
| `=`    | 매칭(패턴이 값과 일치하도록 변수 바인딩) | `{:ok, v} = {:ok, 10}` |
| `==`   | 값 비교(느슨한 동등: `1 == 1.0` 은 `true`) | `1 == 1.0` |
| `===`  | 값 + 타입 비교(엄격한 동등) | `1 === 1.0` 은 `false` |

간단 예제:

```elixir
iex> 1 = 1        # 매칭: 성공
1
iex> 1 == 1       # 비교: true
true
iex> 1 = 2        # 매칭: 실패 → 예외
** (MatchError) no match ...
iex> 1 == 2
false
```

따라서:

- `=` 는 “**같도록 강제하는 제약**”이고,
- `==`, `===` 는 “**이미 있는 두 값을 검사**하는 비교”이다.

### 어디까지가 “대입처럼” 보이고, 어디부터 다른가

다른 언어들과 비교해 보면 차이가 선명해진다.

```elixir
iex> x = 4
4
iex> 4 = x      # 오른쪽에 변수, 왼쪽에 상수
4
```

- C/Java/Python 에서는 `4 = x` 는 **문법 오류**이지만,
- 엘릭서에서는 “**왼쪽 4라는 패턴과 오른쪽 값이 같아야 한다**”는 매칭이다.
  - `x` 가 4라면 성공, 그 외에는 `MatchError`.

이 “거꾸로 된” 형태가 허용되는 이유는, 엘릭서가 `=` 를 **양방향 대입이 아니라 “일치 제약”으로 정의**했기 때문이다.

---

## _2.2 더 복잡한 매칭

패턴 매칭은 **튜플, 리스트, 맵, 구조체, 바이너리/비트스트링** 등 거의 모든 자료구조에 적용된다. 이는 엘릭서의 가장 강력한 특징 중 하나로, Elixir School, 다양한 유럽·미국 개발자 블로그에서도 “핵심 언어 기능”으로 항상 가장 먼저 소개된다.

### 리스트와 튜플: 중첩 패턴으로 구조 한 번에 풀어내기

```elixir
iex> [a, {:ok, b}, c] = [1, {:ok, 2}, 3]
[1, {:ok, 2}, 3]
iex> {a, b, c}
{1, 2, 3}
```

- `[a, {:ok, b}, c]` 는 “길이 3짜리 리스트, 가운데 요소는 `{:ok, ...}` 튜플”이라는 제약.
- 이 패턴 하나로 `a`, `b`, `c` 를 모두 꺼내 온다.

리스트 “머리/꼬리”는 `|` 패턴으로도 쉽게 나눌 수 있다.

```elixir
iex> [head | tail] = [10, 20, 30]
[10, 20, 30]
iex> head
10
iex> tail
[20, 30]
```

비교용으로, 전통적인 반복문/인덱스 코드와 나란히 써 보자.

```elixir
# 전통적(의사 코드)

head = list[0]
tail = list[1..]

# 엘릭서

[head | tail] = list
```

**형태와 의미가 한 줄에 붙어 있기 때문에**, 경험 많은 엘릭서 코드는 의사 코드처럼 읽힌다.

#### 빈 리스트/길이 제약

```elixir
iex> [] = []          # OK
[]
iex> [x | _] = []     # 실패: 비어 있는 리스트에는 머리가 없음
** (MatchError) no match ...
```

- 리스트/튜플 패턴은 **길이까지 제약**한다.
- `[x, y]` 는 정확히 **길이 2**인 리스트와만 매칭된다.

### 맵 패턴 — 키 기반 구조 제약

맵에서 패턴 매칭은 “**필수 키들을 강제하면서 값은 꺼내기**”에 매우 자주 쓰인다.

```elixir
iex> %{name: name, points: p} =
...>   %{name: "Kim", points: 120, tier: :gold}
%{name: "Kim", points: 120, tier: :gold}
iex> name
"Kim"
iex> p
120
```

- 패턴에 등장한 키(`:name`, `:points`)는 **반드시 존재**해야 한다.
- 그렇지 않으면 매칭 실패:

```elixir
iex> %{name: _} = %{points: 10}
** (MatchError) no match of right hand side value: %{points: 10}
```

맵 패턴은 **“필수 키만 골라서 확인”**할 수 있기 때문에, JSON/XML/DB 결과처럼 필드가 많은 구조에서 특히 유용하다.

#### 변수 키 + 핀 연산자: `%{^key => v}`

맵의 **키 자리에 변수**를 쓰고 싶을 때는 **핀 연산자 `^`**로 현재 값을 고정해야 한다.

```elixir
iex> key = :name
:name
iex> %{^key => v} = %{name: "Lee", points: 5}
%{name: "Lee", points: 5}
iex> v
"Lee"
```

- `%{key: v}` 라고 쓰면 “`:key` 라는 리터럴 키”를 의미한다.
- `%{^key => v}` 는 “**현재 `key` 변수에 들어 있는 값(여기서는 `:name`)을 키로 써라**”는 뜻.

맵 패턴을 이해할 때 자주 하는 실수는:

> “키 자리에 변수를 그대로 쓰면, 그 변수가 새 키로 바인딩된다”

인데, 실제로는 **항상 키는 “값” 기준**으로 비교된다. 변수 이름으로 키를 쓰고 싶으면 **핀 연산자**가 필요하다.

### 패턴 — 타입까지 강제하기

구조체는 “맵 + 타입 정보”이다. 패턴에서도 **타입(모듈명)** 까지 함께 제약할 수 있다.

```elixir
defmodule User do
  defstruct [:id, :name, points: 0]
end

iex> u = %User{id: 1, name: "Kim", points: 10}
%User{id: 1, name: "Kim", points: 10}

iex> %User{name: n, points: p} = u
%User{id: 1, name: "Kim", points: 10}
iex> {n, p}
{"Kim", 10}

iex> %{name: n} = u     # 맵 패턴: 타입은 보지 않는다
%User{id: 1, name: "Kim", points: 10}
```

- `%User{...}` 패턴은 “**User 구조체**이면서, 지정한 필드들을 가진 값”을 의미한다.
- `%{name: n}` 패턴은 **어떤 맵이든 `:name` 키만 있으면** 매칭된다.
  - 즉, **타입을 강제하려면 구조체 패턴을 써야 한다**.

구조체 패턴은 Ecto 스키마, Phoenix 컨텍스트 코드, GenServer 상태 등에서 많이 쓰인다.

### 바이너리/비트스트링 패턴 — 프로토콜 파서의 핵심

바이너리/비트스트링 패턴은 **네트워크 패킷, 파일 포맷, 문자열** 등을 처리할 때 성능·표현력 양쪽 모두에서 강력하다. 공식 문서와 여러 유럽/미국 블로그에서도 “효율적인 데이터 처리의 핵심 도구”로 소개된다.

가장 간단한 예부터 보자.

```elixir
# 문자열을 첫 글자와 나머지로 나누기

iex> <<head, rest::binary>> = "banana"
"banana"
iex> head == ?b
true
iex> rest
"anana"
```

여기서 `"banana"` 는 내부적으로 바이너리이며, `<<...>>` 패턴 안에서 **바이트 단위**로 분해된다.

조금 더 실전적인 예:

```elixir
defmodule Wire do
  # 16비트 big-endian 길이 + 몸체 + 나머지 꼬리
  def parse(<<len::16, payload::binary-size(len), tail::binary>>) do
    {:ok, payload, tail}
  end
end

iex> Wire.parse(<<0, 3, "abc", "rest">>)
{:ok, "abc", "rest"}
```

- `len::16` : 16비트 부호 없는 정수(기본 big-endian)
- `payload::binary-size(len)` : 바로 앞에서 읽은 `len` 바이트만큼의 바이너리
- `tail::binary` : 나머지 전체

이런 식으로 **한 번의 패턴 매칭으로 헤더와 본문, 꼬리까지 한번에 파싱**할 수 있다.

문자열과 유니코드에서 주의할 점:

```elixir
iex> <<c1, rest::binary>> = "über"
"über"
iex> c1
195
iex> rest
<<188, 98, 101, 114>>
```

유럽/미국 개발자 문서에서도 강조하듯, 바이너리 패턴은 **바이트 단위**로 동작하기 때문에, `"ü"` 같은 멀티바이트 문자를 “글자 단위”로 나누고 싶다면 `String.next_grapheme/1` 같은 고수준 API를 써야 한다.

### 함수 헤드, `case`, `with` 에서의 패턴

패턴 매칭은 단순 `=` 에만 쓰이는 게 아니라:

- **함수 헤드**
- **`case`/`cond`**
- **`with`**
- **`for` 내 패턴**

같은 곳에서도 일관되게 사용된다.

#### 함수 헤드 예제

```elixir
defmodule Parser do
  # 접두사에 따라 함수 절이 선택된다
  def parse("OK:" <> rest),  do: {:ok, String.trim(rest)}
  def parse("ERR:" <> rest), do: {:error, String.trim(rest)}
  def parse(_),              do: :unknown
end

iex> Parser.parse("OK: hello")
{:ok, "hello"}
iex> Parser.parse("ERR: oops")
{:error, "oops"}
iex> Parser.parse("???")
:unknown
```

#### `case` 예제

```elixir
iex> case {:ok, 10} do
...>   {:ok, v} when v > 5 -> :big
...>   {:ok, _}            -> :small
...>   :error              -> :fail
...> end
:big
```

- `when v > 5` 같은 **가드(guard)** 와 함께 쓰면 **타입/범위까지 제약**할 수 있다.

#### `with` 예제

```elixir
def signup(params) do
  with {:ok, email} <- fetch(params, "email"),
       true <- valid?(email),
       {:ok, user} <- insert_user(email) do
    {:ok, user}
  else
    false       -> {:error, :bad_email}
    {:error, r} -> {:error, r}
    _           -> {:error, :unknown}
  end
end
```

각 `<-` 오른쪽은 **매칭 대상**이며, **왼쪽 패턴에 맞지 않으면 `else`로 빠진다**. 즉, `with` 전체가 **연쇄적인 패턴 매칭 파이프라인**이다.

---

## _2.3 언더스코어로 값 무시하기

언더스코어(`_`)는 “**이 값은 관심 없음**”을 의미한다.
**매칭은 그대로 수행되지만, 변수 바인딩은 하지 않는다.**

### `_` 는 “아무 곳에도 저장되지 않는다”

```elixir
iex> {:ok, _} = {:ok, 123}
{:ok, 123}

iex> {_, _, third} = {:a, :b, :c}
{:a, :b, :c}
iex> third
:c
```

- `_` 가 있던 자리는 **형태 제약**에는 포함되지만, 실제 값은 **버려진다**.
- 따라서 이후에 `_` 를 참조할 수 있는 곳은 어디에도 없다.

### `_var` 형태 — 이름이 있는 “무시 변수”

컴파일러/도구에게 “**이 변수는 일부러 쓰지 않을 거야**” 라는 의도를 전달하고 싶을 때는 `_value` 같은 이름을 쓴다.

```elixir
iex> {:ok, _value} = {:ok, 10}
{:ok, 10}
```

- `_value` 역시 **실제 값은 버린다**는 점에서 `_` 와 동일하다.
- 단지 “**사람이 읽기 좋도록 이름을 붙인 언더스코어**”라고 보면 된다.
- 컴파일러는 “값을 쓰지 않는다”는 경고를 억제한다.

여러 곳에서 같은 `_value` 가 등장해도 **서로 아무런 관계가 없다**:

```elixir
iex> {_value, _value} = {:a, :b}
{:a, :b}    # 두 자리 모두 버려지므로 항상 성공
```

### `_` 와 “같음 제약”의 구분

같음 제약이 필요한 경우에는 `_` 대신 **같은 변수 이름** 또는 **핀 `^`** 을 써야 한다.

```elixir
# 같은 값 두 번 연속인지 검사

iex> [x, x] = [1, 1]
[1, 1]
iex> [x, x] = [1, 2]
** (MatchError) no match ...

# '무시' 패턴은 '같음'을 강제하지 않는다

iex> [_, _] = [1, 2]   # 항상 성공
[1, 2]
```

- `[x, x]` : “두 원소가 **서로 같아야 한다**”는 제약
- `[_, _]` : “길이 2이면 어떤 값이든 상관 없음”

이 차이는 **함수 헤드/`case` 분기 로직**을 읽을 때 매우 중요하다.

### 이벤트/로그에서 쓰는 패턴

```elixir
def handle_event({:user_login, user_id, _ip, _user_agent}, state) do
  {:ok, audit(state, user_id)}
end
```

- 3, 4번째 인자는 **받긴 하지만 지금은 쓰지 않는다**는 의도가 코드에 드러난다.
- 앞으로 IP 나 User-Agent 가 필요해지면, `_ip`, `_user_agent` 를 변수로 바꾸면 된다.

### `for` 내 패턴 + 언더스코어

리스트 내포에서도 패턴과 언더스코어를 그대로 쓸 수 있다.

```elixir
iex> events = [
...>   {:ok, %{id: 1, user: "kim"}},
...>   {:error, :timeout},
...>   {:ok, %{id: 2, user: "lee"}}
...> ]
iex> for {:ok, %{id: id, user: user}} <- events do
...>   {id, user}
...> end
[{1, "kim"}, {2, "lee"}]
```

에러는 무시하고 싶다면:

```elixir
iex> for {:ok, %{id: id, user: user}} <- events, do: {id, user}
```

- `{:error, _}` 는 **아예 매칭되지 않으므로** 결과에서 자연스럽게 떨어져 나간다.

---

## _2.4 변수는 “매칭당 한 번만” 바인딩된다

엘릭서에서 **하나의 패턴(매칭 식) 안에서** 같은 변수 이름이 두 번 등장하면, 두 번째부터는 “**기존 값과 일치해야 하는 제약**”으로 해석된다.

### 같은 이름 두 번 쓰기: “같아야 함” 강제

```elixir
iex> {x, x} = {1, 1}
{1, 1}

iex> {y, y} = {1, 2}
** (MatchError) no match ...
```

매칭 과정은 다음과 같이 볼 수 있다.

1. 첫 번째 `x` 가 1로 바인딩.
2. 두 번째 `x`는 **이미 값이 있으므로**, “값이 1인지 검사”로 동작.
3. `{1, 2}` 와 `{x, x}` 를 비교해 보면 두 번째 자리가 2 vs 1 이라서 실패.

수식으로 비유하면:

- $$\text{find } x \text{ such that } (x, x) = (1, 1)$$ 는 해 \(x=1\) 이 존재하지만,
- $$\text{find } x \text{ such that } (x, x) = (1, 2)$$ 는 해가 없는 방정식이다.

### 함수 헤드에서 “같은 두 값만 받는 함수” 만들기

```elixir
defmodule SameTwo do
  # 같은 두 값인 경우에만 매칭
  def same({x, x}), do: true
  def same({_a, _b}), do: false
end

iex> SameTwo.same({1, 1})
true
iex> SameTwo.same({1, 2})
false
```

패턴만 보고도 이 함수가 **“두 인자가 같으면 true, 아니면 false”** 라는 것을 거의 자연어 수준으로 읽을 수 있다.

### 핀 연산자 `^` — 이미 바인딩된 값을 “고정”해서 매칭

`^var` 는 “**이 변수의 현재 값을 패턴에 고정하라**”는 뜻이다.
공식 가이드에서도 “다시 바인딩하지 않고, 현재 값을 기준으로 매칭하고 싶을 때 쓰라”고 설명한다.

```elixir
iex> x = 1
1
iex> ^x = 1   # x 의 현재 값(1)과 매칭
1
iex> ^x = 2
** (MatchError) no match of right hand side value: 2

iex> {y, ^x} = {2, 1}
{2, 1}
iex> y
2
```

- 첫 번째 `x` 에서는 새 값 1이 바인딩.
- `^x` 는 “**새 바인딩 금지, 현재 값과 같아야 한다**”는 제약.

맵 키, 바이너리, 문자열 등에서는 특히 자주 쓰인다.

```elixir
iex> key = :name
:name
iex> %{^key => v} = %{name: "Kim", points: 3}
%{name: "Kim", points: 3}
iex> v
"Kim"

iex> prefix = "OK:"
"OK:"
iex> <<^prefix::binary, rest::binary>> = "OK: hello"
"OK: hello"
iex> rest
" hello"
```

- 키/접두사 등에 **동적으로 정해진 값을 강제**하고 싶을 때 `^` 를 쓰면 된다.

### “매칭의 경계”: 다른 매칭에서는 같은 이름이 다시 바인딩된다

“한 번만 바인딩” 규칙은 **단일 매칭 식 내부**에서만 적용된다.

```elixir
iex> x = 1         # 매칭 ①
1
iex> x = 2         # 매칭 ② — 새 바인딩
2

iex> case {:ok, 10} do
...>   {:ok, x} -> x      # 이 x 는 case 블록 안에서 새로 바인딩
...> end
10
```

- `x = 1`, `x = 2` 는 **서로 다른 매칭**이므로 이름 재사용 가능.
- `case` 의 각 분기에서도 **매칭마다 새 환경**이 만들어진다고 보는 편이 이해하기 좋다.

이 규칙을 머리에 두면, “여기서 `^` 를 써야 하나?”를 판단하기가 훨씬 쉽다.

---

## _2.5 등호를 바라보는 다른 시각

이제 `=` 를 더 이상 “대입”으로 보지 말고, **제약을 푸는 연산**으로 다시 보자.
이 관점은 Prolog/Erlang 계열 언어에서 가져온 것으로, Elixir 공식 문서와 여러 해외 튜토리얼에서도 반복해서 강조한다.

### 수학적 관점: 방정식/일치 제약으로서의 `=`

패턴 매칭은 대략 다음과 같은 문제를 푸는 과정이다.

$$
\text{주어진 값 } v \text{ 에 대해, 패턴 } P(\vec{x}) \text{ 를 만족시키는 } \vec{x \text{ 를 찾을 수 있는가?}}
$$

- \(v\): 오른쪽 값 (RHS)
- \(P(\vec{x})\): 왼쪽 패턴 (변수들 \(\vec{x}\) 를 포함)
- 해가 있으면, 그 해를 변수에 **부여(바인딩)**하고 매칭 성공.
- 해가 없으면 **`MatchError`**.

예를 들어:

```elixir
iex> [x, y | t] = [1, 2, 3, 4]
[1, 2, 3, 4]
iex> {x, y, t}
{1, 2, [3, 4]}
```

은 다음 방정식을 푼 것과 같다.

- $$[x, y \mid t] = [1, 2, 3, 4]$$
- 해: \(x = 1, y = 2, t = [3, 4]\)

이렇게 보면 “`=` 는 값을 옮기는 연산이 아니라, **구조/값 제약을 푸는 연산**”임이 분명해진다.

### 절차적 코드 vs 패턴 기반 코드

간단한 로그인 응답 파서를 예로 들자.

#### 절차적 스타일(다른 언어식)

```pseudo
resp = http_post("/login", params)
if resp.status == 200 then
  body = resp.body
  if "user" in body then
    user = body["user"]
    return {ok, user}
  else
    return {error, missing_user}
  end
else
  return {error, resp.status}
end
```

#### 엘릭서 패턴 기반 스타일

```elixir
def decode_login({200, %{"user" => user}}), do: {:ok, user}
def decode_login({code, _}) when code in 400..599, do: {:error, {:http_error, code}}
def decode_login(_), do: {:error, :unknown}
```

이 코드에서:

- `decode_login/1` 의 **함수 헤드 자체가 계약** 역할을 한다.
- `{:ok, user}` 를 만드는 로직은 **조건문을 거의 쓰지 않고**, 패턴으로 드러난다.

### “데이터에서 의미로” 직접 점프하기

바이너리 로그를 파싱하는 예를 다시 보자.

```elixir
defmodule Log do
  # [LEVEL] YYYY-MM-DD hh:mm:ss - message
  def parse_line(
        ~s([) <>
        <<level::binary-size(5)>> <>
        ~s(] ) <>
        <<ts::binary-size(19)>> <>
        " - " <>
        msg
      ) do
    {:ok, String.trim(level), ts, msg}
  end

  def parse_line(_), do: :bad
end

iex> Log.parse_line("[INFO ] 2025-11-10 00:01:02 - started")
{:ok, "INFO", "2025-11-10 00:01:02", "started"}
```

- 어디서부터가 레벨이고, 어디까지가 타임스탬프이며, 메시지는 어디서 시작하는지 등
- **모든 구조 정보가 패턴에 직접 박혀 있다.**

다른 언어였다면 `indexOf`, `substring` 을 여러 번 써서 구현했을 부분을, 엘릭서는 **패턴 한 번**으로 표현한다.

### “관찰 가능한 계약”으로서의 패턴

함수 헤드, `case`, `with` 에서의 패턴은 전부 **입력 계약**이다.

```elixir
def handle({:event, :user_signup, %{id: id, email: email}})
    when is_integer(id) and is_binary(email) do
  {:ok, id}
end

def handle(_), do: {:error, :bad_event}
```

- 틀린 값이 들어오면 **매칭 실패** 또는 `:bad_event` 로 바로 드러난다.
- 계약이 **코드에 녹아 있어** 리팩터링 시에도 깨지면 바로 `MatchError` 로 알려 준다.

이런 “계약이 코드에 직접 드러나는 스타일”은 미국·유럽 쪽 Elixir/BEAM 커뮤니티에서 **가독성과 신뢰성을 동시에 높이는 패턴**으로 많이 권장된다.

---

## _2.6 실전 레시피: 패턴 매칭으로 바꾸면 좋아지는 코드들

### API 응답 디코딩 — 성공/실패 분기

```elixir
defmodule API do
  def decode({200, %{"data" => data}}), do: {:ok, data}

  def decode({code, %{"error" => msg}})
      when code in 400..599 do
    {:error, {code, msg}}
  end

  def decode(_), do: {:error, :unknown}
end

iex> API.decode({200, %{"data" => %{id: 1}}})
{:ok, %{id: 1}}

iex> API.decode({404, %{"error" => "not found"}})
{:error, {404, "not found"}}
```

- 튜플 + 맵 패턴 + 가드로 **성공/실패/기타**가 명확하게 드러난다.

### 연속 이벤트에서 “같은 사용자 두 번 연속” 찾기

```elixir
defmodule Consecutive do
  # 같은 사용자 이벤트가 연속 두 번 들어오면 true
  def same_user?([{u, _}, {u, _} | _]), do: true   # 같은 변수 이름 'u'로 일치 강제
  def same_user?(_), do: false
end

iex> Consecutive.same_user?([{:kim, :a}, {:kim, :b}, {:lee, :c}])
true
iex> Consecutive.same_user?([{:kim, :a}, {:lee, :b}])
false
```

### 프레임 프로토콜 파싱 — 길이 + 타입 헤더

```elixir
defmodule Wire2 do
  # 1바이트 타입 + 16비트 길이 + 본문 + 나머지
  def parse(<<type::8, len::16, body::binary-size(len), rest::binary>>) do
    {:ok, type, body, rest}
  end
end

iex> Wire2.parse(<<1, 0, 3, "abc", "tail">>)
{:ok, 1, "abc", "tail"}
```

실제 프로젝트에서는 여기에 `case`/`with`와 `:gen_tcp.recv/2` 등을 엮어서 **바이너리 프로토콜 파서**를 만든다.

### `with` + 핀으로 파이프라인 제약 추가

```elixir
def upcase_username(params) do
  with %{"user" => %{"name" => name}} <- params,
       name when byte_size(name) > 0 <- name,
       up = String.upcase(name),
       ^up <- String.trim(up) do
    {:ok, up}
  else
    _ -> {:error, :bad}
  end
end

iex> upcase_username(%{"user" => %{"name" => " kim "}})
{:ok, "KIM"}
```

- `^up <- String.trim(up)` : 공백 제거 전후가 **같아야만 통과**하도록 제약한다.
- 의도: “앞뒤 공백만 있는 이름은 허용하지 않는다.”

### `GenServer` 콜 패턴 — 계약이 분기 로직을 정의

```elixir
defmodule KV do
  use GenServer

  def start_link(init \\ %{}),
    do: GenServer.start_link(__MODULE__, init, name: __MODULE__)

  @impl true
  def init(state), do: {:ok, state}

  @impl true
  def handle_call({:get, key}, _from, state) do
    {:reply, Map.get(state, key), state}
  end

  def handle_call({:put, key, val}, _from, state) do
    {:reply, :ok, Map.put(state, key, val)}
  end

  def handle_call(_bad, _from, state) do
    {:reply, {:error, :bad_request}, state}
  end
end
```

- 잘못된 요청은 마지막 절로 떨어진다.
- 함수 헤드만 읽어도 “이 서버는 `{:get, key}`, `{:put, key, val}` 만 유효”라는 것을 알 수 있다.

---

## _2.7 성능·메모리 관점에서 본 패턴 매칭 (요약)

자세한 벤치마크는 별도 장에서 다룰 수 있지만, 개념적으로만 정리하면:

1. **불변 데이터 구조** 덕분에, 튜플·리스트·맵 패턴 매칭은 대체로 **얕은 검사와 포인터 공유**로 구현된다.
2. 바이너리 패턴 매칭은, 공식 문서와 여러 성능 분석 글에서 설명하듯이 **크게 두 가지 장점**이 있다.
   - 헤더/본문을 분해할 때 **새로운 메모리 할당을 줄일 수 있다.**
   - **비트 단위 제어**로, C 수준에 가까운 데이터 파싱을 순수 Elixir 코드로 구현할 수 있다.
3. 패턴이 깊고 복잡해질수록, **매칭 실패 비용**도 커질 수 있으므로, 실제 코드에서는:
   - “성공 가능성이 높은 패턴을 위에 두기”
   - “너무 복잡한 패턴은 여러 함수로 나누기”
   - “바이너리에서 큰 조각을 반복적으로 분해할 때는 슬라이스/오프셋 관리와 비교”

같은 전술이 함께 쓰인다.

---

## _2.8 다른 언어와의 비교: 익숙한 개념으로 연결하기

짧게, 다른 언어 경험과 연결해 보는 것도 도움이 된다.

- **Erlang**
  - 엘릭서의 패턴 매칭은 Erlang/OTP 의 것과 거의 동일하며, 튜플/리스트/바이너리 패턴 문법을 그대로 계승한다.
- **Haskell/Scala/F#**
  - 이들 언어도 `case` 문에서 강력한 패턴 매칭을 제공하지만, 엘릭서는 **함수 헤드와 `=` 자체에 패턴을 넣는 정도**로 좀 더 넓게 쓰인다.
- **Rust**
  - `match` 표현식에서 enum/튜플/구조체 패턴을 제공하며, “같은 이름 두 번 쓰면 같음 강제” 같은 규칙은 거의 동일하다.
- **Python/JavaScript**
  - 최신 Python 의 구조적 패턴 매칭(`match`/`case`), JS의 구조 분해 할당이 어느 정도 비슷하지만, 엘릭서처럼 **예외로 실패를 표면화**하고, `with`/함수 헤드와 결합된 정도는 아니다.

즉, 엘릭서 패턴 매칭은 **“분기 구조 + 계약 표현 + 데이터 분해 + 변수 바인딩”을 하나로 합쳐 놓은 도구**라고 보면 된다.

---

## _2.9 테스트 전략: ExUnit + 패턴 매칭

패턴 매칭이 “계약” 그 자체이기 때문에, 테스트는 “**이 계약이 언제 성공/실패해야 하는지**”를 명확히 하는 방향으로 잡으면 좋다.

```elixir
defmodule MatchingGuideTest do
  use ExUnit.Case, async: true

  test "tuple ok" do
    assert {:ok, v} = {:ok, 123}
    assert v == 123
  end

  test "tuple fail" do
    assert_raise MatchError, fn ->
      {:ok, _} = {:error, :nope}
    end
  end

  test "map pin" do
    key = :id
    assert %{^key => 1} = %{id: 1, extra: true}
  end

  test "same twice" do
    assert {x, x} = {:a, :a}
    assert_raise MatchError, fn ->
      {y, y} = {:a, :b}
    end
  end

  test "binary header" do
    <<h::8, rest::binary>> = <<1, 2, 3>>
    assert h == 1
    assert rest == <<2, 3>>
  end
end
```

- “**성공해야 할 케이스**”와 “**실패해야 할 케이스**”를 나란히 두면 계약이 눈에 잘 들어온다.

---

## _2.10 흔한 실수와 리팩터링 팁 정리

1. “`=` 는 대입이다”라고 생각하기
   → **매칭**이며, 오른쪽 값을 평가한 뒤 왼쪽 패턴과 **일치**를 강제한다.

2. `_` 를 “나중에 쓸 수 있는 변수”라고 착각하기
   → `_` / `_var` 는 **어디에도 저장되지 않는다.** 로그 디버깅에 쓰고 싶다면, 진짜 변수 이름을 써야 한다.

3. “맵 키에 변수를 그대로 쓰면 변수 이름으로 키가 매칭된다”라고 생각하기
   → 키 자리에 **변수의 현재 값을 쓰려면** `%{^var => ...}` 형태로 **핀**해야 한다.

4. 같은 값을 강제하고 싶을 때 `_` 를 쓰기
   → 반드시 같은 변수 이름 두 번 또는 핀 `^` 를 사용해야 한다.

5. 복잡한 `if`/`case` 안에 모든 조건을 몰아넣기
   → **함수 헤드 + 패턴 + 가드**로 나누면 테스트/리뷰/리팩터링이 모두 쉬워진다.

---

## _2.11 연습문제 (간단 해설 포함)

> 가능한 한 `iex` 에서 직접 쳐 보면서 확인해 보는 것을 권장한다.

1) 다음 매칭이 성공하도록 `rhs` 를 채워라.

```elixir
# 목표: a = 1, b = 2, t = [3, 4]

[a, b | t] = rhs
```

예시 해답:

```elixir
rhs = [1, 2, 3, 4]
```

2) 다음이 실패해야 하는 이유를 설명하라.

```elixir
{x, x} = {:ok, :err}
```

힌트:

- 첫 번째 `x` 로 `:ok` 가 바인딩된 뒤, 두 번째 `x` 는 “**이미 있는 값과 같아야 함**” 제약으로 동작한다.

3) 맵 키 고정 매칭을 완성해 보자.

```elixir
key = :user
%{^key => %{id: id}} = %{user: %{id: 10}, meta: :x}
id
```

- `^key` 가 없다면 어떤 일이 벌어지는가?
- `key` 의 현재 값이 `:user` 가 아닐 때는 어떻게 되는가?

4) 바이너리에서 접두/ID/꼬리를 나누기

```elixir
p = "ID:"
<<^p::binary, id::binary-size(4), rest::binary>> = "ID:ABCDTAIL"
{id, rest}
```

- `id` 와 `rest` 의 값은 무엇인가?
- `"NOT:ABCDTAIL"` 과 매칭시키면 어떤 예외가 나는가?

5) 다음 두 구현을 비교하고, 어떤 점에서 패턴 매칭 버전이 더 나은지 설명해 보자.

```elixir
# 버전 A

def get_id(map) do
  if is_map(map) and Map.has_key?(map, :id) do
    {:ok, map.id}
  else
    :error
  end
end

# 버전 B

def get_id(%{id: id}), do: {:ok, id}
def get_id(_),         do: :error
```

---

- `=` 가 단순 대입이 아니라 **패턴과 값의 매칭**임을 확인했고,
- 언더스코어, 같은 이름 두 번 쓰기, 핀 연산자 같은 **미세한 규칙들**이
- 함수 헤드, `case`, `with`, 바이너리/맵/구조체 패턴 등 **언어 전체에 일관되게 적용**된다는 점을 살펴봤다.
