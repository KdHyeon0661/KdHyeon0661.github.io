---
layout: post
title: 영상처리 - AVI 플레이어 만들기
date: 2025-10-09 16:25:23 +0900
category: 영상처리
---
# | **AVI 플레이어 만들기**

_“새 도큐먼트 템플릿 → IppAvi 재생 루프 → 툴바/시크바(트랙바) → 키보드 단축키 → 스냅샷/루프/속도 제어”까지 **끝까지 달리는** 실전 가이드._

> 전제
> - 플랫폼: Windows / C++17 / Win32(비-MFC) / 공용 컨트롤(Common Controls) 사용
> - 비디오 I/O: 앞 절의 **`IppAvi`** (VfW 기반, BGRA32 top-down ↔ AVI)
> - 렌더링: `IppDib::draw(hdc, x, y, w, h)` 혹은 `StretchDIBits`
> - 모든 코드 블록은 한 번만 ``` 으로 감쌉니다(이전에 지적하신 중첩 금지 준수)

---

## 새 도큐먼트 템플릿 등록하기

AVI 전용 뷰(창) 클래스를 하나 더 만듭니다. 메인 윈도우(프레임) 아래 **자식 창**으로 띄우는 구조(멀티 문서 느낌)를 그대로 따르겠습니다.

### 리소스/ID 정의

```cpp
// resource.h (추가)
#pragma once

// 메뉴 / 명령
#define ID_FILE_OPEN_AVI             16020
#define ID_VIEW_TOGGLE_FIT           16021
#define ID_PLAY_PLAYPAUSE            16022
#define ID_PLAY_STOP                 16023
#define ID_PLAY_PREVFRAME            16024
#define ID_PLAY_NEXTFRAME            16025
#define ID_PLAY_SLOWER               16026
#define ID_PLAY_FASTER               16027
#define ID_PLAY_TOGGLE_LOOP          16028
#define ID_PLAY_SNAPSHOT             16029
#define ID_PLAY_GOTO_START           16030
#define ID_PLAY_GOTO_END             16031

// 툴바 / 트랙바 컨트롤 ID
#define IDC_AVI_TOOLBAR              5010
#define IDC_AVI_TRACKBAR             5011

// 윈도우 클래스 이름
#define WC_AVIVIEWW                  L"AviViewWindowClass"

```

### 전역 초기화(공용 컨트롤)와 **AviView** 윈도우 클래스 등록

```cpp
// AviView.h
#pragma once
#include <windows.h>
#include <commctrl.h>
#include <string>
#include "IppAvi.h"
#include "IppDib.h"

// 뷰 상태(도큐먼트 개념)
struct AviPlayerState {
    // 비디오
    IppAvi      avi;
    IppDib      frame;           // 현재 프레임(BGRA32, top-down)
    int         curIndex = 0;    // 현재 프레임 인덱스
    int         total = 0;       // 총 프레임
    double      fps = 0.0;

    // 재생
    bool        playing = false;
    bool        loop = true;
    double      speed = 1.0;     // 0.25~4.0 배속
    UINT_PTR    timerId = 0;     // SetTimer ID
    DWORD       lastTick = 0;    // 타이머 드리프트 보정용

    // 뷰
    bool        fitToWindow = true;  // 창에 맞게(레터박스)
    RECT        client{};            // 클라이언트 크기
    HWND        hToolbar = nullptr;
    HWND        hTrack   = nullptr;
    HWND        hWnd     = nullptr;

    // 파일
    std::wstring filepath;

    // 유틸
    void StopTimer() { if (timerId){ KillTimer(hWnd, timerId); timerId=0; } }
    void StartTimer();
    void TogglePlay();
    void Stop();
    void Step(int delta);            // ±1 프레임
    void SeekAbs(int index);         // 절대 프레임
    void RefreshTitle();
    void Render(HDC hdc);
};

ATOM RegisterAviViewClass(HINSTANCE hInst);
HWND CreateAviViewWindow(HWND hParent, HINSTANCE hInst, const RECT& rc);
```

```cpp
// AviView.cpp
#include "AviView.h"
#include <commdlg.h>
#include <cmath>
#include <cassert>

static LRESULT CALLBACK AviViewProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

ATOM RegisterAviViewClass(HINSTANCE hInst){
    WNDCLASSEXW wc{ sizeof(WNDCLASSEXW) };
    wc.style         = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = AviViewProc;
    wc.hInstance     = hInst;
    wc.hCursor       = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszClassName = WC_AVIVIEWW;
    return RegisterClassExW(&wc);
}

HWND CreateAviViewWindow(HWND hParent, HINSTANCE hInst, const RECT& rc){
    HWND h = CreateWindowExW(0, WC_AVIVIEWW, L"AVI Player",
                             WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
                             rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
                             hParent, nullptr, hInst, nullptr);
    return h;
}
```

> 메인 프레임에서 `RegisterAviViewClass(hInst);` 를 한 번만 호출하고,
> **새 AVI 문서/뷰**가 필요할 때마다 `CreateAviViewWindow(…)` 를 호출하면 됩니다.

---

## IppAvi 클래스를 이용한 동영상 재생

핵심은 **타이머 기반 재생 루프**입니다. `fps`에서 간격을 구해 `SetTimer` → `WM_TIMER` 때 다음 프레임을 `readFrame` → 무효화/그리기.

### AviPlayerState 구현

```cpp
// AviView_player.cpp (AviPlayerState 메서드 구현)
#include "AviView.h"

static UINT msFromFps(double fps, double speed){
    if (fps<=0) return 33; // fallback
    double inv = 1000.0 / (fps * (speed>0?speed:0.001));
    UINT ms = (UINT)std::max(1.0, std::min(1000.0, inv));
    return ms;
}

void AviPlayerState::StartTimer(){
    StopTimer();
    UINT interval = msFromFps(fps, speed);
    lastTick = GetTickCount();                // 기준 시각
    timerId  = SetTimer(hWnd, 1, interval, nullptr);
}

void AviPlayerState::TogglePlay(){
    if (!playing){
        playing = true; StartTimer();
    }else{
        playing = false; StopTimer();
    }
    RefreshTitle();
}

void AviPlayerState::Stop(){
    playing=false; StopTimer();
    curIndex = 0;
    if (total>0) avi.readFrame(curIndex, frame);
    InvalidateRect(hWnd, nullptr, FALSE);
    RefreshTitle();
}

void AviPlayerState::Step(int delta){
    if (total<=0) return;
    playing=false; StopTimer();
    int idx = curIndex + delta;
    if (idx<0) idx = loop? (total-1) : 0;
    if (idx>=total) idx = loop? 0 : total-1;
    SeekAbs(idx);
}

void AviPlayerState::SeekAbs(int index){
    if (total<=0) return;
    index = (index<0)?0: (index>=total? total-1 : index);
    if (avi.readFrame(index, frame)){
        curIndex = index;
        // 트랙바 동기화
        if (hTrack) SendMessageW(hTrack, TBM_SETPOS, TRUE, (LPARAM)curIndex);
        InvalidateRect(hWnd, nullptr, FALSE);
        RefreshTitle();
    }
}

static void format_time(double sec, wchar_t* out, int cap){
    int s = (int)std::floor(sec + 0.5);
    int m = s/60; s%=60;
    _snwprintf_s(out, cap, _TRUNCATE, L"%02d:%02d", m, s);
}

void AviPlayerState::RefreshTitle(){
    wchar_t title[256]; title[0]=0;
    double curSec = (fps>0)? (curIndex/fps) : 0.0;
    double totSec = (fps>0)? (total/fps) : 0.0;
    wchar_t a[16], b[16]; format_time(curSec, a, 16); format_time(totSec, b, 16);
    _snwprintf_s(title, 256, _TRUNCATE, L"%ls %ls  [%ls/%ls]  #%d/%d  %ls  x%.2f",
        filepath.c_str(),
        playing?L"(Playing)":L"(Paused)",
        a,b, curIndex+1, total,
        fitToWindow?L"[Fit]":L"[1:1]",
        speed);
    SetWindowTextW(hWnd, title);
}

void AviPlayerState::Render(HDC hdc){
    if (!frame) return;

    GetClientRect(hWnd, &client);
    int W = frame.width(), H = frame.height();
    int cw = client.right - client.left;
    int ch = client.bottom - client.top;

    if (fitToWindow){
        // 레터박스 유지
        double sx = (double)cw / W;
        double sy = (double)ch / H;
        double s  = std::min(sx, sy);
        int vw = std::max(1, (int)std::round(W*s));
        int vh = std::max(1, (int)std::round(H*s));
        int ox = (cw - vw)/2;
        int oy = (ch - vh)/2;

        // 배경 채우기
        HBRUSH br = (HBRUSH)GetStockObject(BLACK_BRUSH);
        RECT r = client;
        FillRect(hdc, &r, br);
        // 영상 그리기
        frame.draw(hdc, ox, oy, vw, vh);
    }else{
        // 좌상단 원본 크기 (넘치면 잘려도 됨)
        frame.draw(hdc, 0, 0);
    }
}
```

### AviView 윈도우 프로시저 — 열기/타이머/그리기/크기

```cpp
// AviView_wndproc.cpp
#include "AviView.h"
#include <vector>

static void CreateChildControls(AviPlayerState* st){
    // 툴바
    st->hToolbar = CreateWindowExW(0, TOOLBARCLASSNAMEW, nullptr,
        WS_CHILD | WS_VISIBLE | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS,
        0,0,0,0, st->hWnd, (HMENU)IDC_AVI_TOOLBAR, (HINSTANCE)GetWindowLongPtrW(st->hWnd, GWLP_HINSTANCE), nullptr);

    SendMessageW(st->hToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
    // 시스템 표준 이미지 세트 사용
    SendMessageW(st->hToolbar, TB_LOADIMAGES, (WPARAM)IDB_STD_SMALL_COLOR, (LPARAM)HINST_COMMCTRL);

    // 버튼들
    std::vector<TBBUTTON> bs;
    auto PB=[&](int iBitmap,int id){ TBBUTTON b{}; b.iBitmap=iBitmap; b.idCommand=id; b.fsState=TBSTATE_ENABLED; b.fsStyle=TBSTYLE_BUTTON; bs.push_back(b); };

    PB(STD_FILENEW, ID_FILE_OPEN_AVI);
    TBBUTTON sep{}; sep.fsStyle=TBSTYLE_SEP; bs.push_back(sep);

    PB(STD_REWIND,   ID_PLAY_GOTO_START);
    PB(STD_PREV,     ID_PLAY_PREVFRAME);
    PB(STD_PLAY,     ID_PLAY_PLAYPAUSE);
    PB(STD_STOP,     ID_PLAY_STOP);
    PB(STD_NEXT,     ID_PLAY_NEXTFRAME);
    PB(STD_FF,       ID_PLAY_GOTO_END);
    bs.push_back(sep);

    PB(STD_PROPERTIES, ID_VIEW_TOGGLE_FIT);
    PB(STD_UNDO,       ID_PLAY_SLOWER);
    PB(STD_REDOW,      ID_PLAY_FASTER);
    PB(STD_FIND,       ID_PLAY_TOGGLE_LOOP);
    PB(STD_SAVE,       ID_PLAY_SNAPSHOT);

    SendMessageW(st->hToolbar, TB_ADDBUTTONS, (WPARAM)bs.size(), (LPARAM)bs.data());
    SendMessageW(st->hToolbar, TB_AUTOSIZE, 0, 0);
    ShowWindow(st->hToolbar, SW_SHOW);

    // 트랙바 (하단)
    st->hTrack = CreateWindowExW(0, TRACKBAR_CLASSW, L"",
        WS_CHILD | WS_VISIBLE | TBS_HORZ | TBS_TOOLTIPS | TBS_AUTOTICKS,
        0,0,100,30, st->hWnd, (HMENU)IDC_AVI_TRACKBAR,
        (HINSTANCE)GetWindowLongPtrW(st->hWnd, GWLP_HINSTANCE), nullptr);

    SendMessageW(st->hTrack, TBM_SETRANGEMIN, FALSE, 0);
    SendMessageW(st->hTrack, TBM_SETRANGEMAX, FALSE, 0); // 열기 후 갱신
    SendMessageW(st->hTrack, TBM_SETLINESIZE, 0, 1);
    SendMessageW(st->hTrack, TBM_SETPAGESIZE, 0, 10);
    ShowWindow(st->hTrack, SW_SHOW);
}

static void LayoutChildControls(AviPlayerState* st){
    RECT rc; GetClientRect(st->hWnd, &rc);
    // 툴바 높이 얻기
    SendMessageW(st->hToolbar, TB_AUTOSIZE, 0, 0);
    RECT rt; GetWindowRect(st->hToolbar, &rt);
    int tbH = rt.bottom - rt.top;

    int trackH = 28; // 적당
    MoveWindow(st->hToolbar, 0,0, rc.right, tbH, TRUE);
    MoveWindow(st->hTrack,   0, rc.bottom-trackH, rc.right, trackH, TRUE);
    // 중앙 비디오 영역은 나머지
    RECT video = { 0, tbH, rc.right, rc.bottom - trackH };
    InvalidateRect(st->hWnd, &video, TRUE);
}

// 파일 열기
static bool OpenAviCommonDialog(HWND hWnd, std::wstring& out){
    wchar_t buf[MAX_PATH] = L"";
    OPENFILENAMEW ofn{ sizeof(ofn) };
    ofn.hwndOwner = hWnd;
    ofn.lpstrFilter = L"AVI Files (*.avi)\0*.avi\0All Files\0*.*\0\0";
    ofn.lpstrFile = buf;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    if (GetOpenFileNameW(&ofn)){
        out = buf; return true;
    }
    return false;
}

static void UpdateTrackbarRange(AviPlayerState* st){
    if (!st->hTrack) return;
    SendMessageW(st->hTrack, TBM_SETRANGEMAX, FALSE, st->total>0? st->total-1 : 0);
    SendMessageW(st->hTrack, TBM_SETPOS, TRUE, st->curIndex);
}

static void Cmd_OpenAvi(AviPlayerState* st){
    std::wstring path;
    if (!OpenAviCommonDialog(st->hWnd, path)) return;

    // stop & close & open
    st->StopTimer(); st->playing=false;
    st->avi.close();
    if (!st->avi.openRead(path)){
        MessageBoxW(st->hWnd, L"AVI 열기에 실패했습니다.", L"AVI", MB_ICONERROR);
        return;
    }
    st->filepath = path;
    st->fps      = st->avi.fps();
    st->total    = st->avi.totalFrames();
    st->curIndex = 0;

    if (st->total>0) st->avi.readFrame(0, st->frame);
    UpdateTrackbarRange(st);
    st->RefreshTitle();
    InvalidateRect(st->hWnd, nullptr, TRUE);
}

static void Cmd_PlayPause(AviPlayerState* st){ st->TogglePlay(); }
static void Cmd_Stop(AviPlayerState* st){ st->Stop(); }
static void Cmd_Prev(AviPlayerState* st){ st->Step(-1); }
static void Cmd_Next(AviPlayerState* st){ st->Step(+1); }
static void Cmd_GotoStart(AviPlayerState* st){ st->SeekAbs(0); }
static void Cmd_GotoEnd(AviPlayerState* st){ if (st->total>0) st->SeekAbs(st->total-1); }
static void Cmd_ToggleFit(AviPlayerState* st){ st->fitToWindow=!st->fitToWindow; InvalidateRect(st->hWnd,nullptr,TRUE); st->RefreshTitle(); }
static void Cmd_Slower(AviPlayerState* st){ st->speed = std::max(0.1, st->speed/1.25); if (st->playing) st->StartTimer(); st->RefreshTitle(); }
static void Cmd_Faster(AviPlayerState* st){ st->speed = std::min(8.0,  st->speed*1.25); if (st->playing) st->StartTimer(); st->RefreshTitle(); }
static void Cmd_ToggleLoop(AviPlayerState* st){ st->loop = !st->loop; st->RefreshTitle(); }

static void Cmd_Snapshot(AviPlayerState* st){
    if (!st->frame) return;
    // 간단: 동일 경로 옆에 PNG/BMP로 저장 (IppDib::save 호출 가정; BMP 예시)
    std::wstring base = st->filepath;
    size_t p = base.find_last_of(L"."); if (p!=std::wstring::npos) base = base.substr(0,p);
    wchar_t out[MAX_PATH]; swprintf(out, L"%ls_frame_%06d.bmp", base.c_str(), st->curIndex);
    if (st->frame.save(out)) MessageBoxW(st->hWnd, L"스냅샷 저장 완료", L"Snapshot", MB_OK);
    else MessageBoxW(st->hWnd, L"스냅샷 저장 실패", L"Snapshot", MB_ICONERROR);
}

// WM_TIMER: fps에 맞춰 프레임 진전 (드리프트 보정)
static void OnTimer(AviPlayerState* st){
    if (!st->playing || st->total<=0) return;

    DWORD now = GetTickCount();
    DWORD elapsed = now - st->lastTick;
    // 이론간격
    UINT ideal = msFromFps(st->fps, st->speed);

    // 누적이 이상하게 커졌을 때는 보정
    int steps = 1;
    if (ideal>0) steps = std::max(1, (int)(elapsed / ideal));
    st->lastTick = now;

    int idx = st->curIndex + steps;
    if (idx >= st->total){
        if (st->loop) idx %= st->total;
        else { idx = st->total-1; st->playing=false; st->StopTimer(); }
    }
    st->SeekAbs(idx);
}

static LRESULT OnHScroll(AviPlayerState* st, HWND hCtl, UINT code){
    if (hCtl!=st->hTrack) return 0;
    switch(code){
    case TB_THUMBTRACK:
    case TB_THUMBPOSITION:
    case TB_ENDTRACK:
        {
            LRESULT pos = SendMessageW(st->hTrack, TBM_GETPOS, 0, 0);
            st->SeekAbs((int)pos);
            // 드래그 중에는 일시정지 권장(옵션)
        }
        break;
    }
    return 0;
}

// ---- 윈도우 프로시저
static LRESULT CALLBACK AviViewProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam){
    AviPlayerState* st = (AviPlayerState*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);

    switch (msg){
    case WM_CREATE:
        {
            st = new AviPlayerState();
            st->hWnd = hWnd;
            SetWindowLongPtrW(hWnd, GWLP_USERDATA, (LONG_PTR)st);
            InitCommonControls(); // 한 번은 호출되어 있어야 함
            CreateChildControls(st);
        }
        return 0;

    case WM_SIZE:
        if (st){ LayoutChildControls(st); }
        return 0;

    case WM_COMMAND:
        if (!st) return 0;
        switch (LOWORD(wParam)){
        case ID_FILE_OPEN_AVI:    Cmd_OpenAvi(st); return 0;
        case ID_PLAY_PLAYPAUSE:   Cmd_PlayPause(st); return 0;
        case ID_PLAY_STOP:        Cmd_Stop(st); return 0;
        case ID_PLAY_PREVFRAME:   Cmd_Prev(st); return 0;
        case ID_PLAY_NEXTFRAME:   Cmd_Next(st); return 0;
        case ID_PLAY_GOTO_START:  Cmd_GotoStart(st); return 0;
        case ID_PLAY_GOTO_END:    Cmd_GotoEnd(st); return 0;
        case ID_VIEW_TOGGLE_FIT:  Cmd_ToggleFit(st); return 0;
        case ID_PLAY_SLOWER:      Cmd_Slower(st); return 0;
        case ID_PLAY_FASTER:      Cmd_Faster(st); return 0;
        case ID_PLAY_TOGGLE_LOOP: Cmd_ToggleLoop(st); return 0;
        case ID_PLAY_SNAPSHOT:    Cmd_Snapshot(st); return 0;
        }
        break;

    case WM_TIMER:
        if (st){ OnTimer(st); }
        return 0;

    case WM_HSCROLL:
        if (st){ return OnHScroll(st, (HWND)lParam, LOWORD(wParam)); }
        return 0;

    case WM_KEYDOWN:
        if (!st) break;
        switch (wParam){
        case VK_SPACE: Cmd_PlayPause(st); return 0;
        case VK_LEFT:  Cmd_Prev(st); return 0;
        case VK_RIGHT: Cmd_Next(st); return 0;
        case VK_HOME:  Cmd_GotoStart(st); return 0;
        case VK_END:   Cmd_GotoEnd(st); return 0;
        case '1': st->speed=1.0; if (st->playing) st->StartTimer(); st->RefreshTitle(); return 0;
        case VK_OEM_MINUS: Cmd_Slower(st); return 0;
        case VK_OEM_PLUS:  Cmd_Faster(st); return 0;
        }
        return 0;

    case WM_PAINT:
        if (st){
            PAINTSTRUCT ps; HDC hdc=BeginPaint(hWnd, &ps);
            st->Render(hdc);
            EndPaint(hWnd, &ps);
            return 0;
        }
        break;

    case WM_DESTROY:
        if (st){
            st->StopTimer();
            st->avi.close();
            delete st;
            SetWindowLongPtrW(hWnd, GWLP_USERDATA, 0);
        }
        return 0;
    }
    return DefWindowProcW(hWnd, msg, wParam, lParam);
}
```

> 핵심 포인트
> - **드리프트 보정**: `lastTick`과 `msFromFps`를 이용해 누적 지연이 생기면 프레임을 한 번에 2~3개 건너뛰어 **시간 동기 유지**.
> - **루프/스톱** 처리: 끝에 도달 시 `loop`에 따라 순환 또는 정지.
> - **시크바 동기화**: `SeekAbs()` 안에서 `TBM_SETPOS` 호출.
> - **Fit/1:1** 모드: `frame.draw(hdc,x,y,w,h)`로 자동 스케일. 레터박스는 배경(검정) 채우기.

---

## 동영상 재생을 위한 툴바 만들기

위에서 런타임으로 생성했지만, 필요한 경우 RC로도 가능(이미지 커스터마이즈 용이). 여기서는 **표준 이미지 세트**를 써서 외부 비트맵 없이 바로 동작합니다.

### 버튼 설명(권장 단축키)

- **Open** (`Ctrl+O`): `ID_FILE_OPEN_AVI`
- **|<<** 시작, **<** 이전 프레임, **▶/‖** 재생/일시정지(`Space`), **■** 정지, **>** 다음 프레임, **>>|** 끝
- **[Fit]**: 창 맞춤(토글)
- **[–] / [+]**: 느리게/빠르게 (`-`, `+` 키)
- **[Loop]**: 루프 재생(토글)
- **[Snapshot]**: BMP로 현재 프레임 저장

> 세부 동작(아이콘/툴팁/툴버튼 상태)까지 꾸미고 싶다면 `TB_SETBUTTONINFO` 로 상태 토글, `TTN_NEEDTEXT` 로 툴팁 제공 추가.

---

## 동영상 재생을 위한 코드 작성 (시나리오 별)

### “가장 기본” 시나리오

1) `Open`으로 AVI를 탑재 → `fps`,`total` 셋업, 첫 프레임 로드
2) `Play` → `SetTimer(fps)` 로 시작
3) `WM_TIMER` 마다 `readFrame(++cur)` → `InvalidateRect`
4) `WM_PAINT` 에서 `Render()` 로 표시에 집중

### “배속/정밀 타이밍” 시나리오

- `speed` 에 따른 간격 변경 → `StartTimer()` 재호출
- 더 정확한 타이밍이 필요하면 `timeBeginPeriod(1)` 및 `QueryPerformanceCounter` 를 써서 **자체 루프**를 짜는 것도 방법이지만, 본 예제에서는 `SetTimer` 로 충분.

### “시크바(드래그) 기반 탐색” 시나리오

- 드래그 중(`TB_THUMBTRACK`)에도 `SeekAbs(pos)` 를 호출해 미리보기
- 탐색 종료 후(`TB_ENDTRACK`) 재생 중이었다면 재생 지속

### “스냅샷/프레임 내보내기”

- `ID_PLAY_SNAPSHOT` : 현재 프레임을 BMP/PNG로 저장
- 구간 저장(예: A–B Loop 구간을 AVI로 export)도 `IppAvi::beginWrite → writeFrame` 반복으로 손쉽게 확장 가능

---

## 예제 — 메인 프레임과의 연동

메인 프레임(상위 창)에서 “AVI 플레이어 새 창”을 열어줍니다.

```cpp
// MainFrame.cpp (발췌)
#include "AviView.h"

extern HINSTANCE g_hInst;
static int g_next = 0;

void Cmd_NewAviPlayerWindow(HWND hMain){
    RECT rc; GetClientRect(hMain, &rc);
    // 클라이언트에 1/2 크기로 예시 배치
    RECT sub = { rc.right/10, rc.bottom/10, rc.right*9/10, rc.bottom*9/10 };
    HWND h = CreateAviViewWindow(hMain, g_hInst, sub);
    if (!h) MessageBoxW(hMain, L"AviView 생성 실패", L"AVI", MB_ICONERROR);
}

LRESULT CALLBACK MainFrameProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam){
    switch(msg){
    case WM_CREATE:
        RegisterAviViewClass((HINSTANCE)GetWindowLongPtrW(hWnd, GWLP_HINSTANCE));
        // … (메뉴/상태바/도킹 등)
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam)){
        case ID_FILE_OPEN_AVI:
            // 현재 포커스된 AviView에 위임하거나, 없으면 새 창 생성 후 포커스 창으로 전달
            // 여기선 단순히 자식 하나 만들고 포커스
            Cmd_NewAviPlayerWindow(hWnd);
            // 포커스 창이 스스로 Open 다이얼로그를 띄우도록 해도 OK
            return 0;
        }
        break;
    }
    return DefWindowProcW(hWnd, msg, wParam, lParam);
}
```

---

## 디테일/엣지 케이스

- **FPS=0** 혹은 잘못된 메타: `msFromFps()` 에서 33ms(≈30fps)로 폴백.
- **랜덤 액세스 비용**: `AVIStreamGetFrame` 은 중간 디코딩이 일어날 수 있어 탐색 비용이 큽니다.
  - 해결: 순차 재생은 빠름. 시크 시 한두 프레임 “띄엄띄엄” 미리보기 → 손 떼면 정확 프레임 디코딩.
- **성능**: 큰 영상에서 `StretchDIBits` 스케일 비용이 큼 → **가끔만** 화면 갱신(프레임 드랍 허용) or `SetStretchBltMode(hdc, HALFTONE)`.
- **64bit/VfW 코덱**: 일부 코덱이 64bit에 없음 → **Uncompressed/MJPG** 권장(이미 `IppAvi`에서 지원).
- **색 채널/알파**: `IppDib` 의 BGRA32에서 알파=0이면 255로 채움(앞 절 구현).
- **더블 버퍼링**: `WM_PAINT` 에서 메모리 DC에 그린 후 BitBlt하면 깜빡임 감소(지금도 flicker는 거의 없음).

---

## 확장 아이디어

- **오디오 재생**: `streamtypeAUDIO` 를 병행하여 WaveOut/Wasapi 연동(프레임-오디오 동기화 필요)
- **프레임 처리 파이프라인**: 재생 중에 `IppImage<T>` 로 변환하여 필터/검출 결과를 오버레이
- **GPU 스케일링**: D2D/Direct3D로 업스케일(보간 품질/속도↑)
- **자막/오버레이**: 타임코드·ROI·측정값을 GDI로 합성

---

## 빠른 자체 테스트 코드

```cpp
// smoke_test_avi_player.cpp
#include "AviView.h"

// 테스트: 창 하나 띄우고 열기 → 3초 재생 → 스냅샷 → 정지
void SmokeTest_AviPlayer(HWND hParent, HINSTANCE hInst){
    RECT rc; GetClientRect(hParent, &rc);
    RECT sub = { 20, 20, rc.right-20, rc.bottom-60 };
    HWND h = CreateAviViewWindow(hParent, hInst, sub);

    // 사용자 개입 없이 자동 동작하려면 AviPlayerState 포인터를 꺼내 조작:
    auto* st = (AviPlayerState*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!st) return;

    // 임의 파일 경로 (테스트용 경로로 교체)
    st->avi.close();
    if (!st->avi.openRead(L"sample.avi")) return;
    st->filepath = L"sample.avi";
    st->fps   = st->avi.fps();
    st->total = st->avi.totalFrames();
    st->curIndex=0; st->avi.readFrame(0, st->frame);
    SendMessageW(st->hTrack, TBM_SETRANGEMAX, FALSE, st->total>0? st->total-1 : 0);
    SendMessageW(st->hTrack, TBM_SETPOS, TRUE, st->curIndex);
    st->RefreshTitle();
    InvalidateRect(h, nullptr, TRUE);

    // 3초 재생
    st->playing=true; st->StartTimer();
    Sleep(3000);
    st->StopTimer(); st->playing=false;

    // 스냅샷
    Cmd_Snapshot(st);

    // 종료
    st->Stop();
}
```

---

## 요약

- **AviView** 라는 전용 도큐먼트(자식 창)를 만들고, 그 안에서
  - `IppAvi`로 **열기/프레임 디코딩**
  - `SetTimer` 기반 **재생 루프**
  - **툴바/트랙바** 로 조작(재생/정지/이전/다음/속도/루프/시크/스냅샷)
  - **Fit/1:1** 뷰 모드, 레터박스 처리
  - **드리프트 보정** 으로 재생 타이밍 안정화
- 코드가 **독립적**이라, 기존 ImageTool에 파일 입출력/필터를 **그대로** 연결해
  “재생 중 필터링/검출/오버레이” 같은 **실전 툴**로 확장하기 쉽습니다. 🚀
