---
layout: post
title: DB 심화 - 카디널리티
date: 2025-11-15 20:25:23 +0900
category: DB 심화
---
# 카디널리티(Cardinality)

> 실행 후에는 항상 아래 명령으로 **실측 플랜/통계**를 확인하세요.

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'
));
```

---

## 0) 실습 스키마 준비(간단)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

-- 깨끗이
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE CUST PURGE';
EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE PROD PURGE';
EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE ORD PURGE';
EXCEPTION WHEN OTHERS THEN NULL; END;
/

-- 테이블
CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8),              -- 스큐 유도: 'KOR' 많음
  TIER    VARCHAR2(8)               -- VIP/GOLD/SILVER/GEN
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12),            -- ELEC/FOOD/TOY/HOME/FASH
  BRAND    VARCHAR2(12)             -- 스큐 유도: 'B0' 다수
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  ORDER_DT DATE   NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL
);

-- 인덱스
CREATE INDEX IX_CUST_REGION ON CUST(REGION, CUST_ID);
CREATE INDEX IX_PROD_CAT    ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_ORD_CUST_DT ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_ORD_PROD_DT ON ORD(PROD_ID, ORDER_DT);

-- 샘플 데이터(스큐 + NULL 포함)
BEGIN
  FOR c IN 1..30000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,6) WHEN 0 THEN 'KOR' WHEN 1 THEN 'KOR'
                    WHEN 2 THEN 'APAC' WHEN 3 THEN 'EMEA'
                    WHEN 4 THEN 'AMER' ELSE NULL END,      -- 일부 NULL
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
                    WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..12000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
                    WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 4000 THEN 'B0' ELSE 'B'||TO_CHAR(MOD(p,60)) END
    );
  END LOOP;

  FOR o IN 1..180000 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,30000)+1,
      MOD(o,12000)+1,
      DATE '2024-01-01' + MOD(o,365),
      1 + MOD(o,5),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;

  COMMIT;
END;
/

-- 기본 통계(히스토그램은 나중 섹션에서 별도 수집)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
END;
/
```

---

# 1) 선택도와 카디널리티 개념

## 정의

- **선택도(Selectivity)**: 어떤 조건이 **행을 통과시키는 비율**.
- **카디널리티(Cardinality)**: **예상 행수**.
  $$\text{Cardinality} = \text{입력 행수} \times \text{Selectivity}$$

### 예: 단일 등치(EQ) 조건

- **히스토그램/정확 통계 없음** + **균등 가정**이면
  $$\text{Selectivity}(col = :v) \approx \frac{1}{\text{NDV}(col)}$$
- **히스토그램 있음**이면 **값별 정확한 빈도/구간 비율**을 사용.

## E-Rows vs A-Rows

- **E-Rows**(Estimated Rows): 옵티마이저가 추정한 카디널리티.
- **A-Rows**(Actual Rows): 실행 결과 실제 처리한 행수.
- 큰 괴리 → **잘못된 플랜** 가능성(조인 순서/조인 방식/Temp 사용량 등).

---

# 2) NULL 값을 포함할 때의 추정과 주의점

## 개념

- `NUM_NULLS`: 해당 컬럼의 **NULL 개수** 통계가 존재.
- 일반 **B*Tree 인덱스**는 **모든 인덱스 컬럼이 NULL인 엔트리는 저장하지 않음**.
  - `WHERE col IS NULL` 조건은 **인덱스 미사용**(예외: 함수기반 인덱스/FBI 등).

## 실습: `REGION IS NULL`의 선택도/카디널리티

```sql
-- CUST.REGION의 NULL 비율 확인
SELECT num_distinct, num_nulls, density, histogram
FROM   user_tab_col_statistics
WHERE  table_name='CUST' AND column_name='REGION';

-- 실행: REGION IS NULL
EXPLAIN PLAN FOR
SELECT /* is null */ COUNT(*) FROM CUST WHERE REGION IS NULL;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**관찰 포인트**
- `E-Rows`가 **NUM_NULLS** 근사치인지, 인덱스 사용이 배제되는지.
- 동일 검색을 **FBI**로 지원하려면:

```sql
-- NULL도 인덱스 타도록 함수기반 인덱스
CREATE INDEX IX_CUST_REGION_NVL ON CUST(NVL(REGION,'~NULL~'));

-- 이제 인덱스 조건으로 변환
EXPLAIN PLAN FOR
SELECT /* is null with FBI */ COUNT(*)
FROM   CUST
WHERE  NVL(REGION,'~NULL~')='~NULL~';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

# 3) 조건이 **두 개 이상**일 때(결합 선택도)

## 기본(독립 가정)

서로 **독립**이라고 가정하면,
$$\text{Sel}(A \land B) \approx \text{Sel}(A) \times \text{Sel}(B)$$

```sql
-- 예: REGION='KOR' AND TIER='VIP'
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   CUST
WHERE  REGION='KOR'
AND    TIER='VIP';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**문제**: 실제로는 **상관관계**가 존재할 수 있음(예: KOR에서 VIP 비율이 높거나 낮음). 이때 독립 곱은 오차 큼.

## 확장 통계로 보정(컬럼 그룹)

```sql
-- 상관관계 반영
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/

-- 동일 쿼리 다시 확인
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM CUST WHERE REGION='KOR' AND TIER='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**비교**: 확장 통계 적용 전/후 **E-Rows 변화**를 확인하세요.

## 조인 시 결합 선택도(간단 관찰)

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   ORD o
JOIN   CUST c ON c.cust_id = o.cust_id
WHERE  c.region='KOR' AND c.tier='VIP'
AND    o.order_dt BETWEEN DATE '2024-03-01' AND DATE '2024-03-31';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
- 카디널리티 오판은 **조인 순서/조인 방식**을 크게 흔듭니다.

---

# 4) **범위 검색** 조건의 선택도/카디널리티

## 개념

- `BETWEEN`, `<`, `>`, `<=`, `>=` 같은 **범위 조건**의 선택도는
  **히스토그램이 있으면 누적분포 기반**, 없으면 **균등분포/밀도(density)/최소-최대 값** 등을 이용해 **근사**합니다.
- 히스토그램 **없음** + 정보 부족 시, **버전에 따라 보수/경험치(예: ~5%)**를 사용할 수 있습니다(정확 값은 버전/상황 의존).

## 실습: 날짜 범위

```sql
-- 3월 한 달 범위
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   ORD
WHERE  ORDER_DT >= DATE '2024-03-01'
AND    ORDER_DT <  DATE '2024-04-01';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 좁은 범위(3월 1일 하루)
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   ORD
WHERE  ORDER_DT >= DATE '2024-03-01'
AND    ORDER_DT <  DATE '2024-03-02';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**관찰**
- **범위가 좁아질수록** 선택도↓ ⇒ 카디널리티↓.
- 인덱스가 있는 경우, 옵티마이저는 **Index Range Scan + StopKey**를 선택할 가능성↑.

## 실습: 금액 범위(히스토그램 적용)

```sql
-- 금액 분포가 편중되었다고 가정하고 히스토그램 생성
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORD',
    method_opt => 'FOR COLUMNS SIZE 254 AMOUNT'
  );
END;
/

-- 범위 비교
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM ORD WHERE AMOUNT BETWEEN 10 AND 100;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT COUNT(*) FROM ORD WHERE AMOUNT BETWEEN 500 AND 700;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**관찰**
- 히스토그램 존재 시 **구간별 선택도 차이**가 E-Rows에 반영.

---

# 5) **값 스큐**(편중)와 히스토그램

## 예: `PROD.BRAND`

```sql
-- 히스토그램 없음(균등 가정)
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM PROD WHERE BRAND='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 히스토그램 생성(스큐 반영)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    method_opt=>'FOR COLUMNS SIZE 254 BRAND');
END;
/

EXPLAIN PLAN FOR
SELECT COUNT(*) FROM PROD WHERE BRAND='B0';  -- 대량값
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM PROD WHERE BRAND='B47'; -- 희소값
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
**핵심**
- 스큐를 반영하지 못하면 **잘못된 카디널리티** → **틀린 액세스 경로** 선택.

---

# 6) **CARDINALITY 힌트**로 실행계획 제어

> **목적:** 옵티마이저가 특정 서브쿼리/인라인 뷰/테이블의 **예상 행수(E-Rows)**를 잘못 추정할 때, **임시로 정확한(또는 원하는) 값**을 주어 **조인 순서/방식**을 유도.

## 기본 사용법

```sql
-- 구문: /*+ CARDINALITY(테이블별칭 예상행수) */
EXPLAIN PLAN FOR
SELECT /*+ CARDINALITY(c 1000) */
       c.cust_id
FROM   CUST c
WHERE  c.region='KOR' AND c.tier='VIP';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
- `CUST c`의 **E-Rows**를 1000으로 **강제** → 이어지는 조인/필터 선택에 영향.

## 인라인 뷰/서브쿼리 대상

```sql
EXPLAIN PLAN FOR
SELECT /*+ CARDINALITY(v 500) */
       v.cust_id, o.order_id
FROM (
  SELECT /*+ qb_name(vq) */ cust_id
  FROM   CUST
  WHERE  region='KOR' AND tier='VIP'
) v
JOIN ORD o ON o.cust_id = v.cust_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
- 대부분은 **별칭(v)**만으로 통용되지만, 복잡할 땐 `qb_name`과 함께 명확히 지정하는 습관을 권장.

## 조인된 Row Source에 대한 CARDINALITY

```sql
-- 조인 후 집합의 카디널리티를 낮게 가정 → NL 선호/Hash 회피 등 유도
EXPLAIN PLAN FOR
SELECT /*+ CARDINALITY(o 20000) CARDINALITY(c 1000) */
       SUM(o.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id=c.cust_id
WHERE  c.region='KOR' AND c.tier='VIP';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

> **주의:**
> - CARDINALITY 힌트는 **임시·국지 처방**입니다.
> - **히스토그램/확장 통계**/SQL 구조 개선으로 **근본 원인(잘못된 추정)**을 해결하는 것이 정석.
> - 그래도 즉각적인 안정화가 필요할 땐 **SQL Plan Baseline/Profile**과 병행 고려.

---

# 7) **진단 루틴**: E-Rows vs A-Rows 관찰

## 차이 확인

```sql
-- 예: 스큐+범위+다중 조건
SELECT /* run */ SUM(o.amount)
FROM   ORD o
JOIN   CUST c ON c.cust_id = o.cust_id
WHERE  c.region='KOR' AND c.tier='VIP'
AND    o.order_dt >= DATE '2024-03-01'
AND    o.order_dt <  DATE '2024-04-01';

SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
       'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS'));
```
- 각 단계(Row Source)의 **E-Rows vs A-Rows**를 비교 → **어디서부터** 추정이 어긋났는지 확인.
- 어긋난 지점이 **컬럼 스큐**인지 **결합 상관관계**인지 **범위**인지 파악.

## 보정 순서(권장)

1) **히스토그램**(스큐 컬럼)
2) **확장 통계(컬럼 그룹)**(상관관계)
3) **SQL 구조 개선**(SARGable, 불필요 변환 제거)
4) **시스템 통계**(하드웨어 특성 반영)
5) **CARDINALITY/OPT_ESTIMATE 힌트**(최후수단)
6) **Plan Baseline/Profile**(안정화)

---

# 8) 실전 Q&A 스타일 미니 시나리오

### Q1. `REGION='KOR' AND TIER='VIP'`가 생각보다 느립니다.

- **의심**: 결합 선택도 오판(독립 가정).
- **조치**: `(REGION,TIER)` **확장 통계** 생성 후 재수집 → **E-Rows 재확인**.
- **임시**: `/*+ CARDINALITY(c 1200) */`로 조정해 NL/Hash 선택을 유도.

### Q2. `BRAND='B0'` 조건이 인덱스를 타서 오히려 느립니다.

- **의심**: 스큐 미반영.
- **조치**: `BRAND` 히스토그램 생성 → 재계획.
- **임시**: `/*+ CARDINALITY(p 4000000) */` 혹은 액세스 힌트(FFS/USE_HASH) 병행.

### Q3. `IS NULL` 검색이 인덱스를 못 탑니다.

- **이유**: B*Tree는 **모든 컬럼이 NULL이면 엔트리 없음**.
- **해법**: `CREATE INDEX ... ON NVL(col,'~NULL~')` 후 `NVL(col,'~NULL~')='~NULL~'`로 SARG화.

### Q4. 범위 조건이 많은 보고서 쿼리에서 플랜이 요동합니다.

- **의심**: 날짜/금액 분포가 **필터마다 다름**.
- **조치**: 해당 컬럼 히스토그램 + 파티션 통계(증분) + 필요시 **Pending Stats**로 안전 배포.

---

# 9) 요약/체크리스트

- **기초 공식**
  $$\text{Cardinality} = \text{Input Rows} \times \prod \text{Selectivity}_i$$
  - EQ: $$\text{Sel} \approx \frac{1}{\text{NDV}}$$ (균등 가정)
  - RANGE: 히스토그램 있으면 누적분포, 없으면 **근사/밀도** 사용
  - NULL: `NUM_NULLS` 사용, **인덱스 미포함** 주의

- **스큐/상관관계**
  - **히스토그램**(값 스큐) · **확장 통계**(컬럼 그룹)로 보정
  - 필요시 **파티션별** 통계로 시즌ality 반영

- **다중 조건**
  - 독립 가정의 한계 → **E-Rows vs A-Rows** 비교로 진단
  - 상관 크면 **확장 통계** 필수

- **범위 조건**
  - **StopKey/Top-N** → 인덱스 + 정렬 회피
  - 히스토그램으로 **구간별** 선택도 반영

- **CARDINALITY 힌트**
  - **임시 국지 처방**으로 조인 순서/방법 유도
  - 장기적으로는 **통계/SQL 품질**로 해결

---

## 부록 A. 자주 쓰는 통계 수집 스니펫

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'FOR ALL COLUMNS SIZE 1');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'FOR COLUMNS SIZE 254 BRAND'); -- 스큐
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST'); -- 확장 통계 생성 후 재수집 권장
END;
/
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION,TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
```

## 부록 B. CARDINALITY 힌트 사례 모음

```sql
-- 1) 테이블 별칭
SELECT /*+ CARDINALITY(c 800) */ COUNT(*) FROM CUST c WHERE c.region='KOR' AND c.tier='VIP';

-- 2) 인라인 뷰
SELECT /*+ CARDINALITY(v 500) */ *
FROM   (SELECT /*+ qb_name(vq) */ cust_id FROM CUST WHERE region='KOR') v
JOIN   ORD o ON o.cust_id = v.cust_id;

-- 3) 복합 적용(조인 입력/출력)
SELECT /*+ CARDINALITY(c 1000) CARDINALITY(o 20000) */ SUM(o.amount)
FROM   CUST c JOIN ORD o ON o.cust_id=c.cust_id
WHERE  c.region='KOR' AND c.tier='VIP';
```

---

### 마무리

- 카디널리티는 옵티마이저의 **핵심 입력**이며, **정확한 추정**이 좋은 플랜의 출발점입니다.
- **스큐/상관관계/NULL/범위**를 통계로 최대한 **정직하게 전달**하고,
- 남는 오차는 **CARDINALITY 힌트**나 **플랜 안정화**로 **국지 보정**하세요.
- 항상 **E-Rows vs A-Rows**를 비교하여 **팩트 기반**으로 개선하는 것이 정석입니다.
