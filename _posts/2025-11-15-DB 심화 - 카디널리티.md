---
layout: post
title: DB 심화 - 카디널리티
date: 2025-11-15 20:25:23 +0900
category: DB 심화
---
# 카디널리티(Cardinality) — Oracle CBO가 “행 수를 얼마나 맞추는가”가 성능을 결정한다

> 목표  
> 옵티마이저가 **선택도(Selectivity) → 카디널리티(E-Rows) → 비용(Cost)** 을 계산하는 정확한 방식과,  
> 실무에서 **E-Rows ↔ A-Rows 괴리(= 카디널리티 오판)** 를 찾아 고치는 전 과정을  
> **통계(히스토그램/확장통계/실시간 통계/동적 통계)** 와 **SQL 구조/힌트** 관점에서 완전 정리한다.

---

## 0) 항상 실측부터: E-Rows vs A-Rows 확인 루틴

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'
));
```

- 실행 후 **Row Source별 E-Rows(=예상)**, **A-Rows(=실제)**, 논리/물리 I/O, 메모리·Temp 사용량을 본다.
- **카디널리티 오판은 조인 순서/조인 방식/액세스 경로/메모리 할당**을 연쇄적으로 흔든다.
- 따라서 튜닝의 첫 단계는 **“어디서부터 E≠A가 시작되는가”** 를 찾는 것.

---

## 1) 카디널리티의 위치: CBO 비용 모델의 출발점

Oracle CBO는 크게 아래 순서로 판단한다. :contentReference[oaicite:0]{index=0}

1. **통계(Statistics)** 로 각 조건의 선택도 계산  
2. 선택도를 곱해서 **카디널리티(E-Rows)** 추정  
3. 카디널리티를 사용해 각 후보 플랜의 **비용(Cost)** 산출  
4. 최소 비용 플랜 선택

정리하면

$$\text{Cardinality} = \text{Input Rows} \times \text{Selectivity}$$

즉, **카디널리티가 틀리면 비용도 틀리고, 플랜도 틀린다.**

---

## 2) 선택도(Selectivity)와 카디널리티(Cardinality) 정의

### 2.1 선택도

- 조건이 **행을 통과시키는 비율**
- 예: 1,000,000행 테이블에서 `col='X'`가 10,000행이면 Sel = 0.01

### 2.2 카디널리티

- 특정 Row Source(테이블/조인 결과/뷰)의 **예상 행수(E-Rows)**
- 입력 1,000,000행 × Sel 0.01 = 10,000 E-Rows

### 2.3 E-Rows vs A-Rows

- **E-Rows(Estimated Rows)**: 옵티마이저의 추정
- **A-Rows(Actual Rows)**: 실제 실행 값
- **E≪A**: 옵티마이저가 “적을 것”이라 착각 → **NL/인덱스 랜덤 스캔**을 과도하게 택할 수 있음  
- **E≫A**: “클 것”이라 착각 → **Hash/Sort/Full**을 과도하게 택할 수 있음

---

## 3) 통계의 구성 요소: CBO가 보는 데이터의 “요약본”

### 3.1 테이블 통계(Volumetric Stats)

`USER_TABLES / USER_TAB_STATISTICS`

- `NUM_ROWS` : 행 수
- `BLOCKS` : 블록 수
- `AVG_ROW_LEN` : 평균 행 길이
- 파티션이면 **GLOBAL vs PARTITION stats** 모두 관여

### 3.2 컬럼 통계(Column Stats)

`USER_TAB_COL_STATISTICS`

- `NUM_DISTINCT(NDV)` : 고유값 개수
- `NUM_NULLS` : NULL 개수
- `DENSITY` : 값 분포 밀도(= 히스토그램 없을 때 셀렉티비티 근사에 사용)
- `LOW_VALUE/HIGH_VALUE` : 최소/최대(범위 조건 근사)
- `HISTOGRAM` : 분포의 비균등성을 담는 상세 통계

Oracle 12c 이후 히스토그램은 **Frequency / Top-Frequency / Hybrid** 중심으로 자동 선택된다. :contentReference[oaicite:1]{index=1}

### 3.3 인덱스 통계(Index Stats)

`USER_INDEXES / USER_IND_STATISTICS`

- `BLEVEL, LEAF_BLOCKS, DISTINCT_KEYS, CLUSTERING_FACTOR`  
- 인덱스의 효율(랜덤/시퀀셜/스캔 범위)을 비용 모델에 제공

### 3.4 시스템 통계(System Stats)

하드웨어/IO 특성을 반영하는 통계.  
대개 기본값으로 충분하지만, DW/초저지연 환경에서는 중요해질 수 있다.

---

## 4) EQ(=) 조건의 선택도 추정

### 4.1 히스토그램이 없고 균등 가정일 때

$$\text{Sel}(col = v) \approx \frac{1}{\text{NDV}(col)}$$

예:

```sql
SELECT num_distinct, density, histogram
FROM   user_tab_col_statistics
WHERE  table_name='CUST' AND column_name='REGION';
```

- NDV=5이면 `REGION='KOR'`의 Sel ≈ 0.2  
- 행 수 30,000이면 E-Rows ≈ 6,000

**하지만 이건 “균등 분포”라는 강한 가정**이다.

### 4.2 값 스큐(편중)가 있을 때 — 히스토그램 필요

스큐 컬럼에서 균등 가정은 치명적이다.

Oracle은 **스큐가 의심되는 컬럼(사용 빈도/분포 기반)** 에 자동 히스토그램을 생성한다. :contentReference[oaicite:2]{index=2}

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND'
  );
END;
/
```

히스토그램 유형:

- **Frequency**: NDV ≤ bucket 수(=254)인 소NDV 컬럼에서 “값별 정확 빈도”
- **Top-Frequency**: “상위 빈도 값”만 정확히 잡는 방식
- **Hybrid**: 12c+의 기본, 구간+빈도 혼합형으로 넓은 NDV에서도 스큐를 포착 :contentReference[oaicite:3]{index=3}

---

## 5) NULL 포함 컬럼의 추정과 인덱스 상호작용

### 5.1 NULL 선택도

- 옵티마이저는 `NUM_NULLS`를 사용해  
  $$\text{Sel}(col IS NULL) \approx \frac{\text{NUM\_NULLS}}{\text{NUM\_ROWS}}$$  
  로 근사한다.

```sql
SELECT num_distinct, num_nulls, density, histogram
FROM   user_tab_col_statistics
WHERE  table_name='CUST' AND column_name='REGION';
```

### 5.2 B*Tree 인덱스의 NULL 특성

일반 B*Tree 인덱스는  
**모든 인덱스 컬럼이 NULL인 엔트리는 저장하지 않는다.**

따라서

```sql
SELECT COUNT(*)
FROM   cust
WHERE  region IS NULL;
```

은 보통 인덱스를 못 탄다(Full Scan 성향).  
이건 Oracle이 공식적으로 밝히는 인덱스 저장 규칙과一致한다. :contentReference[oaicite:4]{index=4}

### 5.3 NULL도 인덱스를 타게 하려면: FBI

```sql
CREATE INDEX ix_cust_region_nvl ON cust(NVL(region,'~NULL~'));

EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust
WHERE  NVL(region,'~NULL~')='~NULL~';
```

- NULL을 “의미 있는 값”으로 변환 → 인덱스 SARGABLE 복구
- OR/선택적 필터 패턴에서도 자주 쓰는 기법

---

## 6) 다중 조건(AND)의 결합 선택도

### 6.1 기본 모델: 독립 가정

$$\text{Sel}(A \land B) \approx \text{Sel}(A) \times \text{Sel}(B)$$

예:

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust
WHERE  region='KOR'
AND    tier='VIP';
```

하지만 현실 데이터는 **상관관계(Correlation)** 를 가진다.

- “KOR 고객은 VIP 비율이 높다/낮다”
- “브랜드 B0는 ELEC 카테고리에 몰려 있다”

이 관계를 모르면 독립 곱은 큰 오차를 만든다.

### 6.2 확장 통계(Extended Statistics, Column Group)

Oracle은 같은 테이블 내 컬럼 간 상관을 **컬럼 그룹 통계**로 교정한다. :contentReference[oaicite:5]{index=5}

```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
```

- 이후 `region='KOR' AND tier='VIP'`의 결합 선택도를  
  “실제 동시 빈도”에 가깝게 추정한다.
- **조인 순서/조인 방식 선택에 직결**되는 개선점이다. :contentReference[oaicite:6]{index=6}

### 6.3 확장 통계는 “같은 테이블 내부”만 가능

Oracle은 **테이블 간 컬럼 상관**을 직접 통계로 저장하지 않는다. :contentReference[oaicite:7]{index=7}  
따라서 다중 테이블 상관은 주로

- 조인 키 NDV/PK-FK 정보
- 히스토그램
- 동적 통계(샘플링)

으로 간접 해결한다.

---

## 7) 범위(RANGE) 조건의 선택도/카디널리티

### 7.1 히스토그램이 있을 때

- 히스토그램의 **누적 분포(CDF)** 로 구간 비율을 산출한다. :contentReference[oaicite:8]{index=8}

예:

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORD',
    method_opt => 'FOR COLUMNS SIZE 254 AMOUNT'
  );
END;
/
```

그 뒤:

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM ord WHERE amount BETWEEN 10 AND 100;

EXPLAIN PLAN FOR
SELECT COUNT(*) FROM ord WHERE amount BETWEEN 500 AND 700;
```

- 분포가 스큐라면 두 범위의 E-Rows가 크게 다르게 나온다.

### 7.2 히스토그램이 없을 때

옵티마이저는

- `LOW_VALUE/HIGH_VALUE`
- `DENSITY`
- `NUM_DISTINCT`
- 경험적 기본 셀렉티비티

를 이용해 근사한다.  
(정확한 수식/기본값은 버전·조건 유형별로 다르므로, **실측 플랜이 정답**이라는 원칙을 유지하라.) :contentReference[oaicite:9]{index=9}

### 7.3 날짜 범위 + 인덱스/파티션

날짜는 거의 항상 **비균등/시계열(ascending)** 이기 때문에  
범위 카디널리티 오판이 자주 난다.

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   ord
WHERE  order_dt >= DATE '2024-03-01'
AND    order_dt <  DATE '2024-04-01';
```

- 인덱스가 있고 범위가 충분히 좁으면  
  `INDEX RANGE SCAN`이 유리.
- 범위가 넓으면  
  `FULL SCAN` 또는 `INDEX FAST FULL SCAN`이 유리.

**오판이 나면 플랜이 반대로 뒤집힌다.**

---

## 8) 조인(Join) 카디널리티: “여기서 가장 많이 틀린다”

조인 카디널리티는 단일 테이블 필터보다 훨씬 어렵고,  
현대 연구에서도 **조인 카디널리티 추정이 플랜 품질의 핵심 병목**임을 지적한다. :contentReference[oaicite:10]{index=10}

### 8.1 기본 조인 선택도

대략적 모델:

$$
\text{Card}(T_1 \bowtie T_2)
\approx
\frac{\text{Card}(T_1)\times \text{Card}(T_2)}
{\max(\text{NDV}_{T_1}(k),\text{NDV}_{T_2}(k))}
$$

- `k`는 조인 키
- PK-FK라면 NDV 관계가 명확해서 정확도가 좋아진다.

### 8.2 필터가 조인 키 NDV를 “바꿀 때” 문제 발생

예:

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   ord o
JOIN   cust c ON c.cust_id=o.cust_id
WHERE  c.region='KOR'
AND    o.order_dt >= DATE '2024-03-01'
AND    o.order_dt <  DATE '2024-04-01';
```

- `c.region='KOR'` 때문에 조인 키의 유효 NDV가 줄어든다.
- 그런데 그 상관을 모르면 조인 카디널리티가 부정확해진다.

이 영역은 **히스토그램 + 확장 통계(테이블 내부) + 동적 통계**가 함께 필요하다. :contentReference[oaicite:11]{index=11}

---

## 9) 동적 통계(Dynamic Statistics, 구 Dynamic Sampling)

통계가 없거나 부정확할 때, Oracle은 **하드 파스 중 샘플링**으로 카디널리티를 보정한다. :contentReference[oaicite:12]{index=12}

### 9.1 언제 발동하나?

- 객체 통계가 없거나
- 통계가 너무 오래되었거나
- 복잡한 술어(상관/범위/표현식)로 오판 위험이 크다고 판단될 때

기본 레벨(대개 2)은 **“통계 없음/부족”일 때만 제한적으로 발동**한다. :contentReference[oaicite:13]{index=13}

### 9.2 장단점

- 장점: 실제 분포를 부분적으로 “읽어” 카디널리티 정확도↑
- 단점: 하드 파스 오버헤드 증가  
  → 많은 SQL이 동적 통계에 의존하면 시스템 전체가 느려질 수 있음

### 9.3 실무 규칙

1. **먼저 통계를 제대로 만들고(히스토그램/확장통계)**  
2. 그래도 오판이 남는 특정 SQL에만 동적 통계가 쓰이도록 유도/허용한다. :contentReference[oaicite:14]{index=14}

---

## 10) 실시간 통계(Real-Time Statistics, 19c+)

Oracle 19c는 “통계가 배치 수집 사이에서 낡아지는 문제”를 줄이기 위해  
**실행 중 DML을 반영하는 실시간 통계**를 도입했다. :contentReference[oaicite:15]{index=15}

### 10.1 의미

- 기존: 밤에 통계 수집 전까지 CBO는 **낡은 NUM_ROWS/NDV**로 추정
- 19c+: DML이 진행되면 **주요 통계가 온라인으로 갱신**되어  
  다음 하드 파스에서 더 정확한 E-Rows를 낸다. :contentReference[oaicite:16]{index=16}

### 10.2 실무에서의 위치

- OLTP에서 “통계 최신화 공백”이 큰 테이블에 특히 유효
- 대량 적재/삭제 후 “수집 전 오판”이 줄어든다

---

## 11) 카디널리티 피드백/재최적화(Adaptive Re-Optimization)

Oracle은 실행 중 E-Rows와 A-Rows 괴리가 너무 크면  
다음 실행에서 **피드백을 활용해 재최적화**하는 기능을 제공해 왔다(버전별 이름/범위 변화). :contentReference[oaicite:17]{index=17}

### 11.1 플랜 노트에서 확인

```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +NOTE'));
```

`NOTE`에

- Dynamic Statistics 사용 여부
- Plan stability/SPD 사용 여부
- Cardinality feedback/Statistics feedback

같은 항목이 표시될 수 있다. :contentReference[oaicite:18]{index=18}

### 11.2 실무적 해석

- 한두 번의 재최적화로 플랜이 안정되면 좋다.
- 그러나 피드백이 계속 생성되며 플랜이 요동하면  
  **근본 통계/SQL 구조 문제**를 먼저 고쳐야 한다.

---

## 12) 파티션 테이블에서의 카디널리티 포인트

### 12.1 Global vs Partition stats

- **Partition filter가 강하면** 파티션 통계가 정확해야 한다.
- Global stats만 정확하고 partition stats가 엉망이면  
  프루닝 후 E-Rows가 크게 틀어진다.

### 12.2 증분(Incremental) 통계

시계열 파티션에서 오판이 반복되면  
**증분 통계/시놉시스** 동작 여부를 점검하라.  
실무 사례에서도 ascending keys에서 오판이 흔하다고 보고된다. :contentReference[oaicite:19]{index=19}

---

## 13) CARDINALITY / OPT_ESTIMATE 힌트

카디널리티 힌트는 **옵티마이저의 E-Rows를 “수정(또는 강제)”** 하는 임시 처방이다.

### 13.1 테이블 별칭에 적용

```sql
EXPLAIN PLAN FOR
SELECT /*+ CARDINALITY(c 1000) */
       c.cust_id
FROM   cust c
WHERE  c.region='KOR' AND c.tier='VIP';
```

- `cust c`의 E-Rows를 1000으로 고정 → 이후 비용 모델을 강제 변경

### 13.2 인라인 뷰에 적용

```sql
EXPLAIN PLAN FOR
SELECT /*+ CARDINALITY(v 500) */
       v.cust_id, o.order_id
FROM (
  SELECT /*+ qb_name(vq) */ cust_id
  FROM   cust
  WHERE  region='KOR' AND tier='VIP'
) v
JOIN ord o ON o.cust_id = v.cust_id;
```

- `qb_name`을 붙이면 복잡한 SQL에서도 대상이 명확해진다.

### 13.3 주의

- **최후수단**이다.  
  통계/SQL 구조로 근본 해결해야 플랜이 장기적으로 안정된다. :contentReference[oaicite:20]{index=20}
- 힌트는 데이터 변화에 취약 → SPM/베이스라인으로 안정화까지 같이 검토하는 게 실무적이다.

---

## 14) 당신의 실습 스키마로 보는 “오판이 생기는 지점”

아래는 당신이 준 스키마 그대로, 관찰을 확장한 실습 가이드다.

### 14.1 히스토그램 없이 KOR/VIP 결합 추정

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust
WHERE  region='KOR'
AND    tier='VIP';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 히스토그램 없음  
- 확장 통계 없음  
→ 독립 가정으로 E-Rows 계산

### 14.2 확장 통계 추가 후 E-Rows 변화 확인

```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION,TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/

EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust
WHERE  region='KOR'
AND    tier='VIP';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- E-Rows가 **실제 결합 빈도**로 이동하는지 확인

### 14.3 BRAND 스큐 + 히스토그램 효과

```sql
-- histogram 없음
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM prod WHERE brand='B0';

-- histogram 생성
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    method_opt=>'FOR COLUMNS SIZE 254 BRAND');
END;
/

EXPLAIN PLAN FOR
SELECT COUNT(*) FROM prod WHERE brand='B0';   -- 대량값
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM prod WHERE brand='B47';  -- 희소값
```

- 희소값 Sel↓, E-Rows↓  
- 대량값 Sel↑, E-Rows↑  
- **같은 EQ라도 값에 따라 플랜이 달라질 근거가 생긴다.**

---

## 15) 진단–보정의 실무 루프(가장 중요한 부분)

### 15.1 진단 루프

1. **실측 플랜**에서 E-Rows vs A-Rows 비교  
2. 첫 오판 지점을 찾는다  
3. 그 지점이  
   - 스큐(EQ 값별 편중)인지  
   - 상관(AND 결합)인지  
   - 범위(ascending / 구간 편중)인지  
   - 조인 키 NDV 변화인지  
   - 통계 stale/missing인지  
   구분한다

### 15.2 보정 우선순위

1. **히스토그램**(스큐 컬럼)  
2. **확장 통계**(컬럼 그룹/표현식)  
3. **SQL 구조 개선**(SARGABLE, NVL/DECODE/CASE 해소, OR Expansion 등)  
4. **실시간/증분 통계 동작 점검**  
5. **동적 통계 사용 여부/레벨** 튜닝  
6. **CARDINALITY/OPT_ESTIMATE 힌트**  
7. **SPM Baseline/Profile/Patch**로 장기 안정화

이 우선순위는 Oracle Optimizer 팀의 권고(통계 품질 우선, 동적 통계는 보조)와 일치한다. :contentReference[oaicite:21]{index=21}

---

## 16) 자주 나오는 함정 패턴과 처방

### 16.1 NVL/함수로 컬럼 가공 → 카디널리티 붕괴

```sql
WHERE NVL(region, 'KOR') = :v
```

- 컬럼이 가공되어 히스토그램·인덱스·확장 통계가 무력화

**처방**: OR로 의미를 드러내서 SARGABLE 회복

```sql
WHERE (:v IS NULL AND region IS NULL)
   OR (region = :v)
```

→ 필요하면 OR Expansion으로 분기 최적화

### 16.2 복합 OR로 인덱스가 흐려짐

```sql
WHERE (region='KOR' OR tier='VIP')
```

- 한 덩어리 OR은 분기별 선택도를 희석  
- OR Expansion이 플랜 자유도를 복구한다.

### 16.3 LIKE/Prefix 검색의 기본 Sel 오판

```sql
WHERE name LIKE :kw || '%'
```

- 히스토그램/표현식 통계가 없으면 Sel이 경험치로 잡혀 흔들림

**처방**:
- 컬럼 히스토그램
- 필요시 **expression stats**(예: `UPPER(name)` 사용 시)

확장 통계는 *표현식*에도 적용 가능하다. :contentReference[oaicite:22]{index=22}

---

## 17) 요약 체크리스트

- [ ] 모든 튜닝은 **실측(E vs A)** 에서 시작한다.  
- [ ] **스큐 컬럼**은 히스토그램 없으면 반드시 오판한다. :contentReference[oaicite:23]{index=23}  
- [ ] **상관 컬럼**은 확장 통계(컬럼 그룹)로 교정하라. :contentReference[oaicite:24]{index=24}  
- [ ] **범위/시계열/파티션**은 partition/증분/실시간 통계까지 점검하라. :contentReference[oaicite:25]{index=25}  
- [ ] 통계가 충분한데도 오판이 남으면 **동적 통계**를 보조로 쓴다. :contentReference[oaicite:26]{index=26}  
- [ ] **CARDINALITY 힌트는 최후수단**이고, 장기적으론 통계/SQL이 정답이다.  
- [ ] 조인 카디널리티는 가장 많이 틀린다. **필터가 조인 키 NDV를 바꾸는지** 항상 의심하라. :contentReference[oaicite:27]{index=27}  

---

## 부록 A. 통계 수집 “정석” 템플릿

```sql
-- 1) 기본(자동 샘플/자동 히스토그램)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORD',
    cascade    => TRUE,
    method_opt => 'FOR ALL COLUMNS SIZE AUTO'
  );
END;
/

-- 2) 스큐 강제
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'PROD',
    method_opt => 'FOR COLUMNS SIZE 254 BRAND'
  );
END;
/

-- 3) 상관 강제(컬럼 그룹)
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION,TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
```

AUTO 샘플 크기를 유지해야 최신 히스토그램(Top-Frequency/Hybrid)이 제대로 생성된다는 점은 Oracle이 공식 권고한다. :contentReference[oaicite:28]{index=28}

---

## 부록 B. 실전 문제 3개(자기 점검용)

1) **스큐 탐지**  
   `user_tab_col_statistics`에서 `DENSITY`와 실제 빈도(샘플) 간 차이가 큰 컬럼을 찾아  
   히스토그램 전/후 플랜(E-Rows)을 비교하라.

2) **상관 탐지**  
   `REGION='KOR' AND TIER='VIP'`에서 독립 가정 E-Rows가 얼마나 오판되는지 측정하고,  
   컬럼 그룹 확장 통계를 넣은 뒤 E-Rows가 A-Rows에 얼마나 가까워졌는지 측정하라.

3) **조인 오판 진단**  
   `CUST` 필터를 바꿔가며 `ORD` 조인 플랜의 E-Rows가 어떻게 흔들리는지,  
   그 결과 조인 방식(NL/Hash)이 바뀌는지 관찰하라.

---

### 마무리

카디널리티는 **CBO가 세상을 보는 “눈”**이다.  
그 눈이 흐릿하면 아무리 좋은 인덱스/힌트/병렬 옵션을 줘도 플랜은 엉뚱해진다.  
따라서 실무 튜닝은 언제나

> **실측 → 오판 지점 찾기 → 통계/구조로 근본 교정 → 필요한 경우에만 힌트/안정화**

이 루프로 가는 게 정석이다.

원하면, 네가 실제로 겪는 SQL(플랜 포함)을 그대로 붙여줘.  
그 케이스를 기준으로 **어느 Row Source에서 왜 오판이 시작되는지**를 짚고,  
히스토그램/확장통계/SQL 재작성/힌트/SPM까지 포함한 “실전 튜닝 문서”로 이어서 만들어 줄게.