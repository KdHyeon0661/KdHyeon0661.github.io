---
layout: post
title: Linux - DNS & 호스트 설정
date: 2024-11-15 19:20:23 +0900
category: Linux
---
# DNS & 호스트 설정

## 이름 해석 흐름: "누가, 무엇을, 어떤 순서로?"

리눅스 시스템에서 호스트 이름을 IP 주소로 변환하는 과정은 `nsswitch.conf` 파일에 정의된 순서를 따릅니다. 대부분의 배포판(Ubuntu, Debian, Fedora, RHEL 등)은 다음과 같은 기본 해석 순서를 사용합니다:

```conf
# /etc/nsswitch.conf (대표 예시)
hosts: files mymachines myhostname mdns4_minimal [NOTFOUND=return] dns
```

각 구성 요소의 의미:
- **files**: `/etc/hosts` 파일 참조
- **mymachines/myhostname**: systemd가 제공하는 로컬 네임(컨테이너, 로컬 호스트명)
- **mdns4_minimal**: mDNS(Avahi, `.local` 도메인), IPv4만 지원
- **dns**: `/etc/resolv.conf`를 통해 지정된 DNS 서버 사용

핵심 포인트:
- **`/etc/hosts` 파일이 항상 DNS보다 우선**합니다(대부분의 구성에서)
- mDNS(`.local`)가 활성화되어 있으면 로컬 브로드캐스트를 통해 이름을 해석합니다
- 실제 해석 순서는 `nsswitch.conf` 설정에 의해 결정됩니다

---

## `/etc/hosts` — 로컬 정적 매핑(항상 빠르고 우선)

### 기본 예시(IPv4/IPv6 포함)

```conf
127.0.0.1   localhost
127.0.1.1   devbox        # Debian/Ubuntu가 종종 기본으로 추가
::1         localhost ip6-localhost ip6-loopback

192.168.1.100  dev-server.local dev-server
10.0.0.5       webserver

# 서비스 바인딩 테스트나 프록시 개발 시 편리한 설정
127.0.0.1   api.local auth.local
```

실전 팁:
- **한 줄에 여러 별칭**을 지정할 수 있습니다(첫 번째 항목이 canonical 이름으로 취급됨)
- FQDN(예: `devbox.example.com`)을 첫 번째로, 짧은 호스트명을 뒤에 두는 구성을 선호하기도 합니다
- 컨테이너/도커는 `/etc/hosts`를 동적으로 수정하므로, 수동 수정 시 덮어쓰기에 유의하세요

---

## `hostnamectl` — 호스트명 관리

`hostnamectl`은 systemd 환경에서 호스트명을 관리하는 도구입니다:

```bash
# 현재 호스트명 조회
hostnamectl

# 정적 호스트명 변경
sudo hostnamectl set-hostname devbox

# 표시용 이름 설정
sudo hostnamectl set-hostname "Dev Box Seoul" --pretty

# 일시적 이름 확인
hostnamectl
```

참고사항:
- `/etc/hostname` 파일에도 정적 이름이 기록됩니다
- FQDN을 호스트명으로 사용할지(예: `devbox.example.com`)는 운영 정책에 따라 결정합니다(일부 애플리케이션은 FQDN을 선호함)

---

## `/etc/resolv.conf` — 리졸버 설정 파일

기본 형식:
```conf
nameserver 8.8.8.8
nameserver 8.8.4.4
search example.com corp.example.com
options ndots:2 timeout:2 attempts:2 rotate
```

중요 옵션 설명:
- `search`: 도메인 접미사 자동 완성(예: `web` → `web.example.com` 시도)
- `ndots:N`: 점(`.`)이 N개 이상이면 FQDN으로 간주(접미사 붙이기 전 우선 질의)
- `timeout:S`: 서버 응답 타임아웃(초)
- `attempts:N`: 재시도 횟수
- `rotate`: 여러 nameserver 간 라운드로빈 사용
- `single-request`: IPv6/IPv4 동시 요청 대신 단일 요청(일부 NAT 환경에서 유리)

⚠️ 현대 시스템에서는 `/etc/resolv.conf`가 심볼릭 링크로 제공되며 다른 컴포넌트가 자동 생성하는 경우가 흔합니다.

---

## systemd-resolved — 통합 DNS 리졸버

많은 배포판에서 `systemd-resolved`가 캐시와 분할 DNS(split DNS) 기능을 제공합니다. 사용 여부는 다음 명령으로 확인할 수 있습니다:

```bash
ls -l /etc/resolv.conf
# → /run/systemd/resolve/stub-resolv.conf로 연결되거나 127.0.0.53을 가리키는지 확인
```

설정 파일:
```ini
# /etc/systemd/resolved.conf (필요 시 수정)

[Resolve]
DNS=1.1.1.1 8.8.8.8
FallbackDNS=9.9.9.9
Domains=corp.example.com ~dev.internal
DNSSEC=allow-downgrade
DNSOverTLS=opportunistic
Cache=yes
```

적용 방법:
```bash
sudo systemctl restart systemd-resolved
resolvectl status                # 현재 네임서버/도메인/대상 링크별 상태 확인
resolvectl query example.com     # dig 대용으로 간편 질의
```

주요 기능:
- `Domains=`에 `~dev.internal`처럼 틸드(~)를 붙이면 split DNS로 동작(특정 도메인만 지정한 서버로 전송)
- `DNSSEC`, `DNSOverTLS` 옵션으로 무결성/암호화 강화 가능
- NetworkManager와 연동하여 인터페이스별 DNS 설정 관리

---

## NetworkManager / netplan — 네트워크 관리 도구

- **NetworkManager**: GUI/CLI(`nmcli`)로 연결 프로필별 DNS를 지정할 수 있으며, 기본적으로 resolved 또는 자체 `dnsmasq`를 통해 `/etc/resolv.conf` 관리
- **netplan**(주로 Ubuntu Server): YAML 형식으로 인터페이스 설정 후 back-end(`systemd-networkd` 또는 NetworkManager)가 처리

netplan으로 고정 DNS 설정 예시:
```yaml
# /etc/netplan/01-net.yaml

network:
  version: 2
  renderer: networkd
  ethernets:
    enp0s3:
      addresses: [192.168.1.10/24]
      routes:
        - to: default
          via: 192.168.1.1
      nameservers:
        search: [example.com]
        addresses: [1.1.1.1, 8.8.8.8]
```
적용:
```bash
sudo netplan apply
```

---

## 캐싱 리졸버 전략 — systemd-resolved, dnsmasq, unbound

- **systemd-resolved**: 경량 캐시/분할 DNS, 통합 로그/관리(`resolvectl`)
- **dnsmasq**: 경량 캐시/DHCP/TFTP 통합, 개발자 로컬 환경에서 인기
- **unbound**: 완전한 검증 리졸버(DNSSEC), 중·대규모 환경에서 선호

로컬 dnsmasq 최소 설정 예시:
```conf
# /etc/dnsmasq.d/local.conf

no-resolv
server=1.1.1.1
server=8.8.8.8
listen-address=127.0.0.1
cache-size=1000
```
```bash
sudo systemctl restart dnsmasq
```
`/etc/resolv.conf`에서 `nameserver 127.0.0.1`로 dnsmasq를 참조하도록 설정합니다.

---

## DNS 보안 — DNSSEC, DNS over TLS(DoT)

- **DNSSEC**: 응답에 전자서명을 확인하여 변조 탐지. 클라이언트(리졸버)와 네임서버 양쪽에서 지원 필요
- **DNS over TLS(DoT)**: TCP/853 포트에서 암호화 통신. `systemd-resolved`에서 `DNSOverTLS=` 옵션으로 설정
- **DNS over HTTPS(DoH)**: 브라우저/에이전트 레벨에서 구현되는 경우가 많음

운영 팁:
- 사내 split DNS와 DNSSEC/DoT를 동시에 설계할 때, 내부 존 권한 위임과 방화벽 예외를 명확히 설정하세요

---

## mDNS(.local)와 Avahi

로컬 네트워크에서 브로드캐스트 기반으로 이름을 해석하는 기술로, 프린터/IoT/개발 기기 탐색에 편리합니다:

```bash
sudo apt install avahi-daemon
```

주의사항:
- `.local` 도메인은 mDNS가 우선 적용될 수 있으므로 기업 내부 FQDN에 `.local`을 사용하면 충돌 가능성 있음(권장하지 않음)
- `nsswitch.conf`에서 `mdns` 항목 제거/조정으로 비활성화 가능

---

## Split DNS(사내망과 외부망 분리)

개발/사내망에서 내부 도메인(`*.corp.example.com`)은 사설 DNS로, 외부 도메인은 공용 DNS로 질의하는 패턴입니다.

systemd-resolved로 간단한 split DNS 설정:
```ini
# /etc/systemd/resolved.conf

[Resolve]
DNS=1.1.1.1
Domains=~corp.example.com
```

---

## 트러블슈팅 플로우

### 호스트 설정 확인

```bash
hostnamectl
cat /etc/hostname
cat /etc/hosts
```

### 해석 순서/구성 확인

```bash
cat /etc/nsswitch.conf | grep hosts
```
- `hosts:` 라인에 `files dns` 순서 및 `mdns` 존재 확인

### resolv.conf 소유자 확인

```bash
ls -l /etc/resolv.conf
cat /etc/resolv.conf
```
- 심볼릭 링크인 경우 관리자 확인(Resolved? NetworkManager?)

### resolved 상태/질의 확인

```bash
resolvectl status
resolvectl query example.com
```

### 네임서버 지연/실패 확인

```bash
dig example.com
dig @1.1.1.1 example.com +trace   # 권한 위임 경로 추적
```

### DNS vs 라우팅/방화벽 확인

```bash
ip r
ss -tuln | grep 53      # 로컬 53 포트 점유 확인(dnsmasq/unbound 등)
sudo iptables -S        # 또는 firewall-cmd --list-all
```

### 캐시 및 상태 초기화

```bash
sudo systemctl restart systemd-resolved
# 또는 dnsmasq/unbound 재시작
```

### mDNS 충돌 확인

- `nsswitch.conf`에서 `mdns` 제거 후 재테스트
- `.local` 이름이 회사 내 FQDN으로 사용되지 않는지 점검

---

## 실전 시나리오

### 시나리오 1: "사내 내부 도메인만 느리다"

1) split DNS 구성 확인(`resolvectl status`: `Domains=~corp.example.com`?)
2) 내부 DNS 응답 시간 측정:
```bash
dig @10.0.0.53 intranet.corp.example.com +stats
```
3) `ndots` 설정이 너무 커서 FQDN 질의 전에 search를 과도하게 시도하는지 확인:
```conf
# /etc/resolv.conf
options ndots:1 timeout:2 attempts:2
```

### 시나리오 2: "`.local` 이름이 엉뚱한 기기로 연결된다"

- `nsswitch.conf`에서 `mdns` 우선 순서를 조정하거나 mDNS 비활성화
- 사내 도메인으로 `.local`을 사용하지 말 것(권장: `.corp` 또는 실제 FQDN 사용)

### 시나리오 3: "`/etc/hosts`로 로컬 바인딩 테스트"

```conf
# /etc/hosts
127.0.0.1   api.local
```
```bash
curl -v http://api.local:8080/health
```
- 브라우저/언어 런타임이 자체 DoH를 강제로 사용하는 경우 호스트 파일이 무시될 수 있으므로 앱/테스트 경로를 점검

### 시나리오 4: "`resolv.conf`를 편집해도 원래 상태로 돌아간다"

- `systemd-resolved`/NetworkManager가 관리 중인 경우:
  - Resolved 사용 → `/etc/systemd/resolved.conf`에 설정 후 서비스 재시작
  - NetworkManager 사용 → 해당 연결 프로필에서 DNS 고정(`nm-connection-editor` 또는 `nmcli`)

---

## 명령어/파일 요약

| 명령/파일 | 용도 |
|---|---|
| `/etc/hosts` | 로컬 정적 매핑(가장 먼저 적용) |
| `/etc/hostname`, `hostnamectl` | 호스트명 조회/변경(static/pretty/transient) |
| `/etc/nsswitch.conf` | 해석 순서 정의(`hosts:` 라인) |
| `/etc/resolv.conf` | 리졸버 설정(서버·접미사·옵션) — 자동 관리 가능 |
| `resolvectl status/query` | systemd-resolved 상태/질의 |
| `dig`, `nslookup`, `host` | DNS 질의 도구(운영 시 `dig` 추천) |
| `nmcli`, netplan | 인터페이스/프로필 기반 네트워크·DNS 설정 |
| `systemd-resolved`, `dnsmasq`, `unbound` | 로컬 캐시/리졸버 구성 |
| `avahi-daemon` | mDNS(`.local`) 서비스 브로드캐스트/해석 |

---

## 핸즈온 예제 모음

### 예제 A: Ubuntu에서 systemd-resolved로 고정 DNS 설정

```ini
# /etc/systemd/resolved.conf

[Resolve]
DNS=1.1.1.1 8.8.8.8
FallbackDNS=9.9.9.9
DNSSEC=allow-downgrade
DNSOverTLS=opportunistic
```
```bash
sudo systemctl restart systemd-resolved
resolvectl status
```

### 예제 B: `/etc/hosts`로 로컬 개발 라우팅 설정

```conf
# /etc/hosts
127.0.0.1   auth.local user.local api.local
```
```bash
curl http://api.local:8080/ping
```

### 예제 C: split DNS 설정(내부 도메인을 내부 서버로)

```bash
# 인터페이스 단위로 내부 DNS 지정(예: eth0)
sudo resolvectl dns eth0 10.0.0.53
sudo resolvectl domain eth0 '~corp.example.com'
resolvectl status
```

### 예제 D: 느린 DNS 디버깅 원인 규명

```bash
dig example.com +trace
dig @1.1.1.1 example.com +stats
time getent hosts example.com
```
- **`getent hosts`**는 실제 nsswitch 순서를 따라 해석합니다(애플리케이션 관점에서의 결과 확인)

### 예제 E: DoT 지원 리졸버로 암호화 설정

```ini
# /etc/systemd/resolved.conf

[Resolve]
DNS=1.1.1.1
DNSOverTLS=yes
```
```bash
sudo systemctl restart systemd-resolved
resolvectl status
```

---

## 컨테이너/WSL/특수 환경의 주의점

- **Docker/Podman**: 컨테이너 내부 `/etc/hosts`와 `/etc/resolv.conf`는 런타임이 생성
  - Docker 데몬의 `--dns` 옵션이나 `daemon.json`(`"dns": ["1.1.1.1"]`)로 기본 DNS 지정
  - Compose에서는 서비스별 `dns` 지정 가능
- **WSL**: Windows가 `/etc/resolv.conf`를 오버라이드할 수 있음
  - `/etc/wsl.conf`에서 `generateResolvConf=false` 설정 후 수동 관리
- **기업 프록시/보안 에이전트**: 트래픽을 프록시하거나 DoH를 강제할 수 있으므로 경로를 명확히 확인

---

## 결론

리눅스의 DNS와 호스트 설정은 복잡해 보이지만 체계적인 이해를 통해 효과적으로 관리할 수 있습니다. 다음 원칙들을 기억하세요:

**계층적 해석 구조 이해**:
리눅스 이름 해석은 `/etc/hosts` → nsswitch → resolv.conf(혹은 resolved) 순으로 이루어집니다. 이 플로우는 정책화되어 있으며, `nsswitch.conf` 파일이 최종적인 해석 순서를 결정합니다.

**현대적 관리 도구 활용**:
대부분의 현대 배포판은 `systemd-resolved`, NetworkManager, netplan과 같은 도구를 통해 DNS 설정을 자동으로 관리합니다. 설정 변경이 원래 상태로 돌아간다면 해당 관리 도구의 설정 파일에서 수정해야 합니다.

**보안 고려사항**:
DNSSEC와 DNS over TLS(DoT)를 활용하여 DNS 트래픽의 무결성과 기밀성을 보호하세요. 특히 split DNS 환경에서는 내부/외부 트래픽을 명확히 구분하여 보안 정책을 적용해야 합니다.

**효율적인 트러블슈팅**:
DNS 문제 해결은 체계적인 접근이 필요합니다. `getent`, `dig`, `resolvectl` 도구들을 활용하여 해석 순서 → 리졸버 경로 → 네트워크/방화벽 순서로 문제를 좁혀나가면 빠르게 원인을 파악할 수 있습니다.

**환경별 특성 고려**:
컨테이너, WSL, 기업 환경에서는 각기 다른 DNS 관리 메커니즘이 작동할 수 있습니다. 환경의 특성을 이해하고 적절한 설정 방식을 선택하는 것이 중요합니다.

이러한 원칙들을 바탕으로 DNS와 호스트 설정을 관리하면 시스템의 안정성과 보안성을 크게 향상시킬 수 있으며, 문제 발생 시 빠르게 대응할 수 있는 기반을 마련할 수 있습니다.