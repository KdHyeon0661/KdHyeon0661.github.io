---
layout: post
title: Linux - DNS & 호스트 설정
date: 2024-11-15 19:20:23 +0900
category: Linux
---
# DNS & 호스트 설정

## 이름 해석 흐름: “누가, 무엇을, 어떤 순서로?”
대부분의 배포판(예: Ubuntu, Debian, Fedora, RHEL 계열)의 기본 해석 순서는 **`/etc/nsswitch.conf`**에 정의된다.

```conf
# /etc/nsswitch.conf (대표 예시)
hosts: files mymachines myhostname mdns4_minimal [NOTFOUND=return] dns
```

- **files**: `/etc/hosts`
- **mymachines/myhostname**: systemd가 제공하는 로컬 네임(컨테이너, 로컬 호스트명)
- **mdns4_minimal**: mDNS(Avahi, `.local`), IPv4만
- **dns**: `/etc/resolv.conf`를 통해 지정된 리졸버(DNS 서버)

핵심 포인트:
- **`/etc/hosts`가 항상 DNS보다 우선**한다(대부분 구성에서).
- mDNS(`.local`)가 활성화되어 있으면 **로컬 브로드캐스트로 이름을 푼다.**
- 결과적으로, “해석 순서 문제”는 `nsswitch.conf`가 좌우한다.

---

## `/etc/hosts` — 로컬 정적 매핑(항상 빠르고 우선)
### 기본 예시(IPv4/IPv6 포함)
```conf
127.0.0.1   localhost
127.0.1.1   devbox        # Debian/Ubuntu가 종종 기본 추가
::1         localhost ip6-localhost ip6-loopback

192.168.1.100  dev-server.local dev-server
10.0.0.5       webserver

# 서비스 바인딩 테스트나 프록시 개발 시 편리
127.0.0.1   api.local auth.local
```

실전 팁:
- **한 줄에 여러 별칭**을 둘 수 있다(첫 번째가 canonical로 취급되는 경향).
- FQDN(예: `devbox.example.com`)을 첫 번째로, 짧은 호스트명을 뒤에 두는 구성을 선호하기도 한다.
- 컨테이너/도커는 `/etc/hosts`를 **동적으로 수정**(컨테이너명 → IP)하므로, 수동 수정 시 덮어쓰기에 유의.

---

## 호스트명(Hostname) — static·pretty·transient
`hostnamectl`은 systemd 환경에서 호스트명을 관리한다.

```bash
# 조회
hostnamectl

# 변경(정적 호스트명)
sudo hostnamectl set-hostname devbox

# 보기 좋게(Pretty) 이름도 별도 설정 가능
sudo hostnamectl set-hostname "Dev Box ⌁ Seoul" --pretty

# 일시적 이름(transient)은 DHCP/LLDP 등에 의해 바뀔 수 있음
```

참고:
- `/etc/hostname` 파일에도 정적 이름이 기록됨.
- FQDN을 호스트명으로 쓸지(예: `devbox.example.com`)는 운영 정책에 따라 결정. 메일 서버 등 일부 애플리케이션은 FQDN을 선호.

---

## `/etc/resolv.conf` — glibc 리졸버의 힌트 파일
기본 형식:
```conf
nameserver 8.8.8.8
nameserver 8.8.4.4
search example.com corp.example.com
options ndots:2 timeout:2 attempts:2 rotate
```

중요 옵션:
- `search` : **서픽스 자동 보완**(예: `web` → `web.example.com` 시도)
- `ndots:N` : 점(`.`)이 **N개 이상이면** FQDN으로 간주(서픽스 붙이기 전 우선 질의)
- `timeout:S` : 서버 응답 타임아웃(초)
- `attempts:N` : 재시도 횟수
- `rotate` : 멀티 nameserver **라운드로빈**
- `single-request` : IPv6/IPv4 동시 대신 **단일 요청**(일부 NAT 환경에서 유리)

⚠️ 현대 시스템에서는 `/etc/resolv.conf`가 **심볼릭 링크**로 제공되며 **다른 컴포넌트가 자동 생성**하는 경우가 흔하다.

---

## systemd-resolved — 127.0.0.53 스텁 리졸버와 통합
많은 배포판에서 `systemd-resolved`가 **캐시/분할 DNS/split DNS**를 제공한다. 대표 징후:

```bash
ls -l /etc/resolv.conf
# → /run/systemd/resolve/stub-resolv.conf 혹은 127.0.0.53 포인트 여부 확인
```

설정 파일:
```ini
# /etc/systemd/resolved.conf (필요 시)
[Resolve]
DNS=1.1.1.1 8.8.8.8
FallbackDNS=9.9.9.9
Domains=corp.example.com ~dev.internal
DNSSEC=allow-downgrade
DNSOverTLS=opportunistic
Cache=yes
```

적용:
```bash
sudo systemctl restart systemd-resolved
resolvectl status                # 현재 네임서버/도메인/대상 링크별 상태
resolvectl query example.com     # dig 대용으로 간편 질의
```

포인트:
- `Domains=`에 `~dev.internal`처럼 틸드(~)를 붙이면 **split DNS**—특정 도메인만 지정한 서버로 보낸다.
- `DNSSEC`, `DNSOverTLS` 옵션으로 **무결성/암호화** 강화 가능(배포판·버전에 따라 지원 수준 상이).
- NetworkManager와 연동해 인터페이스별 DNS를 저수준에 전달(`resolvectl dns <iface> <server>` 형태로 설정되기도 함).

---

## NetworkManager / netplan — 누가 resolv.conf를 쓰는가
- **NetworkManager**: GUI/CLI(`nmcli`)로 연결 프로필별 DNS를 지정할 수 있고, 기본적으로 resolved 또는 자체 `dnsmasq`를 통해 `/etc/resolv.conf`를 관리.
- **netplan**(주로 Ubuntu Server): YAML로 인터페이스 설정 후 back-end(`systemd-networkd` or NetworkManager)가 처리.

예: netplan로 **고정 DNS** 설정
```yaml
# /etc/netplan/01-net.yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    enp0s3:
      addresses: [192.168.1.10/24]
      routes:
        - to: default
          via: 192.168.1.1
      nameservers:
        search: [example.com]
        addresses: [1.1.1.1, 8.8.8.8]
```
적용:
```bash
sudo netplan apply
```

---

## 캐싱 리졸버 전략 — systemd-resolved, dnsmasq, unbound
- **systemd-resolved**: 라이트급 캐시/분할 DNS, 통합 로그/관리 `resolvectl`.
- **dnsmasq**: 경량 캐시/DHCP/TFTP 통합. 개발자 로컬 랩에서 인기.
- **unbound**: 완전한 **검증 리졸버**(DNSSEC)로 중·대규모 환경 선호.

예: 로컬 dnsmasq 최소 예시
```conf
# /etc/dnsmasq.d/local.conf
no-resolv
server=1.1.1.1
server=8.8.8.8
listen-address=127.0.0.1
cache-size=1000
```
```bash
sudo systemctl restart dnsmasq
```
`/etc/resolv.conf`에서 `nameserver 127.0.0.1`로 dnsmasq를 참조하도록(혹은 resolved 스텁 → dnsmasq 체인) 설계.

---

## DNS 보안 — DNSSEC, DNS over TLS(DoT)
- **DNSSEC**: 응답에 **전자서명**을 확인해 변조 탐지. 클라이언트(리졸버)와 네임서버 양 끝에서 지원 필요.
- **DNS over TLS(DoT)**: TCP/853에서 암호화. `systemd-resolved`에서 `DNSOverTLS=`로 **opportunistic/yes/no** 설정.
- **DNS over HTTPS(DoH)**: 브라우저/에이전트 레벨에서 구현되는 경우가 많음(클라이언트 정책과 충돌하지 않게 주의).

운영 팁:
- 사내 split DNS와 DNSSEC/DoT를 **동시에** 설계할 때, 내부 존 권한 위임과 방화벽 예외를 명확히.

---

## mDNS(.local)와 Avahi
로컬 네트워크에서 **브로드캐스트 기반**으로 이름을 푸는 기술. 프린터/IoT/개발 기기 탐색에 편리.

```bash
sudo apt install avahi-daemon
```

- `.local` 도메인은 mDNS가 **우선**될 수 있음 → 기업 내부 FQDN에 `.local`을 쓰면 충돌(권장 X).
- `nsswitch.conf`에서 `mdns` 항목 제거/조정으로 비활성화 가능.

---

## Split DNS(사내망과 외부망을 분리)
개발/사내망에서 **내부 존**(`*.corp.example.com`)은 사설 DNS로, 외부 도메인은 공용 DNS로 질의하는 패턴.

systemd-resolved로 간단히:
```ini
# /etc/systemd/resolved.conf
[Resolve]
DNS=1.1.1.1
Domains=~corp.example.com
# 링크별(인터페이스별)로 다른 DNS를 물려줄 수도 있음: resolvectl dns eth0 10.0.0.53
```

---

## 트러블슈팅 플로우(체크리스트)

### 1. 호스트 전반
```bash
hostnamectl
cat /etc/hostname
cat /etc/hosts
```

### 2. 해석 순서/구성
```bash
cat /etc/nsswitch.conf | sed -n '1,120p'
```
- `hosts:` 라인에 `files dns` 순서 및 `mdns` 존재 확인.

### 3. resolv.conf 소유자 확인
```bash
ls -l /etc/resolv.conf
cat /etc/resolv.conf
```
- **심볼릭 링크**면 누가 관리하는지 파악(Resolved? NetworkManager?).

### 4. resolved 상태/질의
```bash
resolvectl status
resolvectl query example.com
```

### 5. 네임서버 지연/실패 확인
```bash
dig example.com
dig @1.1.1.1 example.com +trace   # 권한 위임 경로 추적
```

### 6. DNS vs 라우팅/방화벽
```bash
ip r
ss -tuln | grep 53      # 로컬 53 포트 점유(dnsmasq/unbound 등)
sudo iptables -S        # 혹은 firewall-cmd --list-all
```

### 7. 캐시 및 상태 초기화
```bash
sudo systemctl restart systemd-resolved
# 혹은 dnsmasq/unbound 재시작
```

### 8. mDNS 충돌 의심
- `nsswitch.conf`에서 `mdns` 제거 후 재테스트
- `.local` 이름이 회사 내 FQDN으로 쓰이지 않는지 점검

---

## 실전 시나리오

### 시나리오 1: “사내 내부 도메인만 느리다”
1) split DNS 구성 확인(`resolvectl status`: `Domains=~corp.example.com`?)  
2) 내부 DNS 응답 시간 측정:
```bash
dig @10.0.0.53 intranet.corp.example.com +stats
```
3) `ndots`가 너무 커서 FQDN 질의 전에 search를 과도하게 도는지 확인:
```conf
# /etc/resolv.conf
options ndots:1 timeout:2 attempts:2
```

### 시나리오 2: “.local 이름이 엉뚱한 기기로 간다”
- `nsswitch.conf`에서 `mdns` 우선 순서를 조정하거나 mDNS 비활성화.
- 사내 도메인으로 `.local`을 사용하지 말 것(권장: `.corp`, 실제는 사설루트 권장 X → 정식 FQDN 사용).

### 시나리오 3: “/etc/hosts로 바인딩하고 싶은 개발 테스트”
```conf
# /etc/hosts
127.0.0.1   api.local
```
```bash
curl -v http://api.local:8080/health
```
- 브라우저/언어 런타임이 자체 DoH를 강제로 쓰는 경우(브라우저 정책) 호스트스가 무시될 수 있으므로 앱/테스트 경로를 점검.

### 시나리오 4: “resolv.conf를 내가 편집해도 원복된다”
- `systemd-resolved`/NetworkManager가 **관리 중**.  
  - Resolved 사용 → `/etc/systemd/resolved.conf`에 설정 후 서비스 재시작.  
  - NetworkManager 사용 → 해당 연결 프로필에서 DNS를 고정(`nm-connection-editor` 또는 `nmcli`).

---

## 명령어/파일 요약(확장판)

| 명령/파일 | 용도 |
|---|---|
| `/etc/hosts` | 로컬 정적 매핑(가장 먼저 적용) |
| `/etc/hostname`, `hostnamectl` | 호스트명 조회/변경(static/pretty/transient) |
| `/etc/nsswitch.conf` | **해석 순서** 정의(`hosts:` 라인) |
| `/etc/resolv.conf` | 리졸버 힌트(서버·서픽스·옵션) — 자동 관리 가능 |
| `resolvectl status/query` | systemd-resolved 상태/질의 |
| `dig`, `nslookup`, `host` | DNS 질의 도구(운영 시 `dig` 추천) |
| `nmcli`, netplan | 인터페이스/프로필 기반 네트워크·DNS 설정 |
| `systemd-resolved`, `dnsmasq`, `unbound` | 로컬 캐시/리졸버 구성 |
| `avahi-daemon` | mDNS(.local) 서비스 브로드캐스트/해석 |

---

## 핸즈온 예제 모음

### 예제 A: Ubuntu에서 **systemd-resolved로 고정 DNS**
```ini
# /etc/systemd/resolved.conf
[Resolve]
DNS=1.1.1.1 8.8.8.8
FallbackDNS=9.9.9.9
DNSSEC=allow-downgrade
DNSOverTLS=opportunistic
```
```bash
sudo systemctl restart systemd-resolved
resolvectl status
```

### 예제 B: `/etc/hosts`로 로컬 개발 라우팅
```conf
# /etc/hosts
127.0.0.1   auth.local user.local api.local
```
```bash
curl http://api.local:8080/ping
```

### 예제 C: split DNS(내부 존을 내부 서버로)
```bash
# 인터페이스 단위로 내부 DNS 지정(예: eth0)
sudo resolvectl dns eth0 10.0.0.53
sudo resolvectl domain eth0 '~corp.example.com'
resolvectl status
```

### 예제 D: 느린 DNS 디버깅 원인 규명
```bash
dig example.com +trace
dig @1.1.1.1 example.com +stats
time getent hosts example.com
```
- **`getent hosts`**는 실제 nsswitch 순서를 따라 해석한다(앱 관점에서의 결과 확인).

### 예제 E: DoT 지원 리졸버로 암호화 시도
```ini
# /etc/systemd/resolved.conf
[Resolve]
DNS=1.1.1.1
DNSOverTLS=yes
```
```bash
sudo systemctl restart systemd-resolved
resolvectl status
```

---

## 컨테이너/WSL/특수 환경의 주의점
- **Docker/Podman**: 컨테이너 내부 `/etc/hosts`와 `/etc/resolv.conf`는 런타임이 생성한다.  
  - Docker 데몬의 `--dns` 옵션이나 `daemon.json`(`"dns": ["1.1.1.1"]`)로 기본 DNS 지정.
  - Compose에서는 서비스별 `dns` 지정 가능.
- **WSL**: Windows가 `/etc/resolv.conf`를 오버라이드할 수 있다.  
  - `/etc/wsl.conf`에서 `generateResolvConf=false` 설정 후 수동 관리.
- **기업 프록시/보안 에이전트**: 트래픽을 프록시하거나 DoH를 강제할 수 있으므로 **경로를 명확히**.

---

## 운영 체크리스트(요약)
1) `nsswitch.conf`에서 해석 순서 확인 (`files` → `dns` 우선?)  
2) `resolv.conf`가 누가 관리하는지 파악(심볼릭 링크 대상)  
3) `systemd-resolved` 사용 시 `resolvectl status/query`로 인터페이스/분할 DNS/암호화 상태 확인  
4) `dig +trace`, `getent hosts`로 실제 경로와 지연 지점 식별  
5) mDNS(.local)와 사내 FQDN 충돌 여부 확인  
6) 캐시 리졸버/방화벽/프로시/보안제품 개입 확인  
7) 컨테이너/WSL 등 **별도 생성 규칙** 고려

---

## 마무리
- 리눅스 이름 해석은 **`/etc/hosts` → nsswitch → resolv.conf(혹은 resolved)`** 순으로 **플로우가 “정책화”**되어 있다.  
- 현대 배포판은 `systemd-resolved`/NetworkManager/netplan이 얽혀 **자동 관리**된다. 직접 편집이 되돌아간다면 **소유자(Manager)**를 확인하고 **해당 계층에서** 설정하라.  
- 성능/안정/보안(특히 **DNSSEC/DoT**, **split DNS**)까지 고려한 구성이 장애 대응과 운영 품질을 극적으로 높인다.  
- 디버깅은 **getent/dig/resolvectl** 3종 세트를 축으로, **해석 순서→리졸버 경로→네트워크/방화벽** 순서로 좁혀가면 빠르다.