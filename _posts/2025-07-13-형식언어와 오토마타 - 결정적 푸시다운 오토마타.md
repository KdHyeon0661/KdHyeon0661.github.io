---
layout: post
title: 형식언어와 오토마타 - 결정적 푸시다운 오토마타
date: 2025-07-13 23:20:23 +0900
category: 형식언어와 오토마타
---
# 결정적 푸시다운 오토마타(DPDA)와 결정적 문맥 자유 언어(DCFL)

## 큰 그림 한 장

- **PDA(푸시다운 오토마타)** = 유한상태 + 스택 → **모든 CFL** 인식(비결정 허용, NPDA).
- **DPDA(결정적 PDA)** = **항상 한 가지 동작만** 가능한 PDA → **일부 CFL(=DCFL)**만 인식.
- **DCFL ⊊ CFL**: 팰린드롬 `\{ww^R\}`(마커 없이)는 CFL이지만 DCFL이 아님, 반면 `\{wcw^R\}`(중앙 마커 `c`)는 DCFL.

---

## DPDA의 정확한 정의와 “결정성” 제약

### 형식적 정의

DPDA는 7-튜플
$$
M=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)
$$
- \(Q\): 유한한 **상태** 집합
- \(\Sigma\): **입력** 알파벳
- \(\Gamma\): **스택** 알파벳
- 전이 함수
$$
\delta: Q\times(\Sigma\cup\{\varepsilon\})\times\Gamma \;\to\; Q\times\Gamma^*
$$
- \(q_0\): 시작 상태, \(Z_0\): 초기 스택 기호, \(F\): 종료(수용) 상태 집합

### “결정적” 제약 (핵심 규칙)

모든 \(q\in Q, X\in\Gamma, a\in\Sigma\)에 대해
1) **충돌 금지**:
$$
\text{동일 }(q,X)\text{에 대해}\;\delta(q,a,X)\text{와 }\delta(q,\varepsilon,X)\text{를 동시에 정의하면 안 됨}
$$
2) **단일 전이**: 동일한 \((q,\alpha,X)\) 조합(\(\alpha\in\Sigma\cup\{\varepsilon\}\))에 대해 **최대 1개** 전이만 허용.

> 실무 규칙: “같은 조건에서 두 개 이상 움직일 여지”가 보이면 DPDA가 **아님**.

### 수용 방식

- **종료 상태 수용**(accepting by final state): 입력 소진 + 상태 \(\in F\) → 수용.
- **빈 스택 수용**(accepting by empty stack): 입력 소진 + 스택 empty → 수용.
- **NPDA**에선 두 방식이 동치지만, **DPDA**에선 **동치가 아니다**. 실무/이론 모두 **종료 상태 수용**을 표준으로 씀(총괄화 후 보수 닫힘 성질 활용).

---

## DCFL(Deterministic CFL)의 위치와 특징

- **DCFL = DPDA가 인식할 수 있는 CFL들의 집합**:
$$
\mathrm{DCFL}=\{\,L \mid L \text{ is a CFL and there exists a DPDA that accepts } L\,\}
$$

- 성질 요약:
  - **엄밀히 CFL의 진부분집합**:
    $$
    \mathrm{DCFL}\subsetneq \mathrm{CFL}
    $$
  - **비모호성**: 모든 DCFL은 **언어적으로 비모호**(각 문자열에 유일한 유도/파스 트리).
  - **결정 문제**(대표):
    - 멤버십 \(w\in L\) → **선형 시간** 파싱 가능(LL(k)/LR(k) 등).
    - 공허성/유한성 → 결정 가능(CFG와 동일).
    - DPDA 동치성 → **결정 가능**(이론적으로 가능하나 실무적으로는 난해).

---

## 무엇이 DPDA로 “결정적으로” 가능한가?

### 전형적 DCFL 예

1) **균형 괄호**: \(L=\{\,w\in\{(,)\}^* \mid \text{well-balanced}\,\}\)
   ‘(’ → **push**, ‘)’ → **pop** → 스택 바닥만 남고 종료 상태이면 수용.

2) **두 블록의 길이 비교**:
$$
L=\{\,a^n b^n \mid n\ge 0\,\}
$$
   \(a\)마다 push, \(b\)마다 pop → 정확히 맞아떨어지면 수용.

3) **중앙 마커 팰린드롬**:
$$
L=\{\, w c w^R \mid w\in\{a,b\}^* \,\}
$$
   `c` 전까지 push, 이후 **미러 매칭** pop → 결정적.

### DCFL이 아닌 고전 예

1) **마커 없는 팰린드롬**:
$$
\{\,ww^R\mid w\in\{a,b\}^*\,\}
$$
   **중간 지점**을 결정적으로 알 수 없음 → DPDA 불가.

2)
$$
\{\,a^i b^j c^k \mid i=j \ \text{or}\ j=k\,\}
$$
   CFL이지만 보통 **DCFL 아님**(결정적 분기 어려움).

---

## 설계 패턴: “영역 구분” + “스택 역할 일관성”

- **영역 구분**: 입력의 **경계 신호**(첫 \(b\), 중앙 `c`, 첫 ‘)’)를 **상태 전이**로 확정.
- **ε vs 입력 충돌 금지**: 동일 \((q,X)\)에서 ε전이가 필요하면 **같은 곳에 입력 전이 두지 않기**.
- **스택 목적의 단일성**: 스택은 보통 **하나의 수량/중첩 정보**만 추적(역할 혼합은 결정성 붕괴 원인).

---

## DPDA 설계 예제

### (종료 상태 수용)

**상태**: \(q_{\text{push}}, q_{\text{pop}}, q_{\text{acc}}\)
**스택**: 바닥 \(Z_0\), 심볼 \(A\)

- \(q_{\text{push}}\)
  - \((a, Z_0)\to(q_{\text{push}}, A Z_0)\)
  - \((a, A)\to(q_{\text{push}}, AA)\)
  - \((b, A)\to(q_{\text{pop}}, \varepsilon)\) ← **모드 전환**
- \(q_{\text{pop}}\)
  - \((b, A)\to(q_{\text{pop}}, \varepsilon)\)
  - \((\varepsilon, Z_0)\to(q_{\text{acc}}, Z_0)\)
- \(q_{\text{acc}}\) 수용

> 충돌 없음: 같은 \((q,X)\)에서 ε/입력 전이를 동시 정의하지 않음.

**실행 예** `aaabbb`
push: `AAA` → pop: `AAA` → 바닥만 남음 → ε-전이로 \(q_{\text{acc}}\) → 수용.

---

### (중앙 마커 팰린드롬)

**상태**: \(q_{\text{pre}}, q_{\text{post}}, q_{\text{acc}}\)
**스택**: \(Z_0\), 입력 a→`A`, b→`B`

- \(q_{\text{pre}}\)
  - \((a, X)\to(q_{\text{pre}}, A X)\), \((b, X)\to(q_{\text{pre}}, B X)\)
  - \((c, X)\to(q_{\text{post}}, X)\)
- \(q_{\text{post}}\)
  - \((a, A)\to(q_{\text{post}}, \varepsilon)\), \((b, B)\to(q_{\text{post}}, \varepsilon)\)
  - 불일치(예: \((a,B)\))는 **전이 미정의** → 거부
  - \((\varepsilon, Z_0)\to(q_{\text{acc}}, Z_0)\)

---

### 균형 괄호

- `(` → push, `)` → pop, 입력 종료 시 바닥이면 수용.

---

## DPDA의 폐포 성질(정확히 알아두기)

| 연산 | DCFL 폐포성 |
|---|---|
| **보수(Complement)** | ✅ 닫힘(총괄화+종료상태 수용 가정) |
| **정규언어와의 교집합** | ✅ 닫힘 (DPDA×DFA product) |
| **합집합/교집합(두 DCFL)** | ❌ 일반적으로 닫힘 아님 |
| **연접/클로저(\*)** | ❌ 일반적으로 닫힘 아님 |
| **역호모몰피즘** | ✅ 닫힘 |
| **호모몰피즘** | ❌ 일반적으로 닫힘 아님 |

---

## 수용 방식과 보수 닫힘 한 마디

- 보수를 쓰려면 DPDA를 **완전 결정화(totalization)** 하고 **종료상태 수용**으로 본다.
  정의 없는 전이는 **싱크 상태**로 보냄. ε-전이는 입력 전이와 **동일 (q,X)** 에서 충돌하지 않게.

---

## 파싱(LL/LR)과 DPDA의 관계

- **LL(k)/LR(k)** 파서는 본질적으로 **결정적 스택 기계**(=DPDA).
- **LL(1)**: 한 토큰 lookahead로 선택이 유일 → DPDA 결정성과 부합.
- **LR(1)**: DFA 아이템 자동자 + 파스 스택 = 결정적 shift/reduce → DPDA 관점.

---

## “왜 \(\{ww^R\}\)는 DCFL이 아닌가?” (직관 스케치)

- 중간 위치를 알려주는 표식이 없음 → push→pop **전환 시점**을 결정적으로 선택 불가.
- 같은 접두부에서 서로 다른 후속 결정을 요구하는 입력들이 존재 → **결정성 위반**.

---

## 파이썬 DPDA 미니 시뮬레이터 (교육용)

> 입력을 **우선 시도**, 없으면 **ε-전이 시도**. 어떤 전이를 썼는지 반환해 인덱스 증가를 정확히 처리합니다.

```python
from typing import Dict, Tuple, Optional

EPS = ""  # ε

Transition = Dict[Tuple[str, str, str], Tuple[str, str]]
# -> value: (next_state, push_string)

class DPDA:
    def __init__(self, Q, Sigma, Gamma, delta: Transition, q0, Z0, F):
        self.Q, self.Sigma, self.Gamma = set(Q), set(Sigma), set(Gamma)
        self.delta = delta
        self.q0, self.Z0, self.F = q0, Z0, set(F)

    def accepts(self, w: str, trace: bool=False) -> bool:
        q = self.q0
        stack = [self.Z0]
        i = 0

        def step(a: Optional[str]):
            """한 스텝: 입력 전이 우선, 없으면 ε-전이. (moved, used_input, new_q, new_stack)"""
            top = stack[-1] if stack else None
            # 입력 전이
            if a is not None and (q, a, top) in self.delta:
                nq, push = self.delta[(q, a, top)]
                new_stack = stack[:-1]
                for ch in reversed(push):  # 왼쪽이 스택 꼭대기가 되도록
                    if ch:
                        new_stack.append(ch)
                return True, True, nq, new_stack
            # ε-전이
            if (q, EPS, top) in self.delta:
                nq, push = self.delta[(q, EPS, top)]
                new_stack = stack[:-1]
                for ch in reversed(push):
                    if ch:
                        new_stack.append(ch)
                return True, False, nq, new_stack
            return False, False, q, stack

        while True:
            a = w[i] if i < len(w) else None
            moved, used_input, nq, nstack = step(a)
            if not moved:
                break
            q, stack = nq, nstack
            if used_input:
                i += 1
            if trace:
                print(f"state={q}, i={i}, stack={stack}")

        return (i == len(w)) and (q in self.F)

# -------------------------------
# 예제 1: L = { a^n b^n }, 종료 상태 수용

Q = {"qp","qx","qa"}
Sigma = {"a","b"}
Gamma = {"Z","A"}
q0, Z0, F = "qp", "Z", {"qa"}

delta = {
    # push 구간
    ("qp","a","Z"): ("qp","AZ"),
    ("qp","a","A"): ("qp","AA"),
    # b를 처음 보면 pop 모드로 전환
    ("qp","b","A"): ("qx",""),

    # pop 구간
    ("qx","b","A"): ("qx",""),
    # 입력 끝, 바닥이면 ε-전이로 수용 상태
    ("qx",EPS,"Z"): ("qa","Z"),
}

M = DPDA(Q,Sigma,Gamma,delta,q0,Z0,F)
for s in ["", "ab", "aabb", "aaabbb", "aab", "abb", "aaaabbbb", "aaabb"]:
    print(f"{s:8} => {M.accepts(s)}")
```

> **주의**: 교육용 간이 구현입니다(총괄화·싱크 상태 등은 생략). 결정성 전제하에 동작합니다.

---

## 케이스 스터디: “설계가 흔들릴 때” 점검표

1) **ε/입력 충돌**: 같은 `(q,X)`에서 ε전이와 입력 전이가 모두 필요해 보이면 **상태를 분리**해 모드를 고정.
2) **스택 의미 혼용**: “길이 비교”+“중첩 확인”을 한 스택에 동시에 얹으면 결정성이 흔들림 → **단일 역할** 유지.
3) **경계 탐지**: 첫 `b`, 중앙 `c`, 첫 `)` 등 **결정 신호**를 **입력 전이**로 잡아 모드 전환.
4) **보수(Complement)**: 총괄화(정의되지 않은 전이를 싱크로) + 종료상태 수용으로 안정적 구성.

---

## 자주 묻는 질문(FAQ)

- **Q. DCFL은 왜 비모호인가?**
  A. DPDA는 각 접두부에 대해 **유일한 실행 경로**만 허용 → 파스 트리도 **유일**.

- **Q. {ww^R} 대신 {wcw^R}는 왜 되나?**
  A. `c`가 **중앙 경계**를 결정적으로 알림(앞은 push, 뒤는 pop).

- **Q. LL/LR과의 관계 한 줄**
  A. LL/LR 파서는 **결정적 스택 기계**이며, 인식 언어는 **DCFL**.

---

## 연습문제(스스로 점검)

1) \(L=\{a^n b^n c^m\mid n,m\ge0\}\). DPDA를 설계하라. *(힌트: a/b 비교만 결정적으로 처리)*
2) \(L=\{(^{n})^{n}\mid n\ge0\}\). 한 종류 괄호 균형 DPDA 정의하라.
3) \(\overline{L}\) (보수) DPDA 구성을 개요로 설계하라. *(싱크 상태/총괄화 사용)*

---

## 핵심 요약 카드

- **DPDA**: ε/입력 충돌 금지 + 한 조건 한 전이 → **결정적**
- **DCFL**: DPDA가 인식하는 CFL. **비모호**, **보수 닫힘**, **정규와의 교집합 닫힘**
- **설계**: 경계는 **상태 전환**, 스택은 **단일 역할**
- **예/비예**: `{a^n b^n}`, `{wcw^R}` ✅ / `{ww^R}` ❌
- **파싱**: LL/LR = DPDA 구현체(결정적 파스 스택)

---

### 부록: `wcw^R` 전이 스케치(텍스트)

- 상태: `q_pre`(c 이전), `q_post`(c 이후), `q_acc`
- 스택: 바닥 `Z`, 입력 a→`A`, b→`B`

```
(q_pre, a, X)  -> (q_pre, A X)
(q_pre, b, X)  -> (q_pre, B X)
(q_pre, c, X)  -> (q_post, X)

(q_post, a, A) -> (q_post, ε)
(q_post, b, B) -> (q_post, ε)
(q_post, ε, Z) -> (q_acc, Z)
```

> 불일치(예: `(q_post, a, B)`)는 전이 **미정의** → 즉시 거부.
