---
layout: post
title: Java - GC 종류
date: 2025-08-04 22:20:23 +0900
category: Java
---
# Java GC 종류(Serial, Parallel, CMS, G1, ZGC, Shenandoah, Epsilon)

## 0. 한눈에 비교(요약 표)

| GC | 핵심 특징 | 장점 | 단점/주의 | 대표 옵션(시작점) |
|---|---|---|---|---|
| **Serial** | 단일 스레드, STW | 구현 단순, 작은 힙·단일 코어 적합 | Pause 큼, 멀티코어 비효율 | `-XX:+UseSerialGC` |
| **Parallel** (Throughput) | Young/Old 병렬 수거 | 처리량↑, 튜닝 단순 | Pause 길 수 있음 | `-XX:+UseParallelGC -XX:ParallelGCThreads=...` |
| **CMS** | Old 동시(Mark-Sweep) | 과거 저지연 대안 | 단편화·유지보수 종료(현대 JDK 미포함) | *(역사적)* `-XX:+UseConcMarkSweepGC` |
| **G1** | Region 기반, pause 목표 | 예측 가능한 pause, 대형 힙 | 옵션 많음(튜닝 난이도) | `-XX:+UseG1GC -XX:MaxGCPauseMillis=200` |
| **ZGC** | 초저지연, TB급 힙 | 수 ms급 pause, 동시 compaction | 최신 JDK 권장, 플랫폼 의존 | `-XX:+UseZGC` |
| **Shenandoah** | 초저지연(동시 compaction) | 낮은 pause, 확장성 | 배포판/버전 포함 여부 확인 | `-XX:+UseShenandoahGC` |
| **Epsilon** | No-op(수거 없음) | GC 오버헤드 0, 실험/프로파일링 | 힙 고갈→즉시 OOM | `-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC` |

> 실무 요령: **일반 서버는 G1**이 안정적 기본. **처리량 최우선 배치**는 Parallel. **초저지연·대형 힙**은 ZGC(또는 Shenandoah). **CMS는 역사**로만 기억.

---

## 1. GC를 고르는 기준(의사결정 트리)

```
(1) 지연 시간 목표가 빡센가? (예: p99 ≤ 30ms)
   ├─ 예 → ZGC / Shenandoah (지원되는 JDK/플랫폼인지 확인)
   └─ 아니오
       (2) 처리량(throughput) 최우선인가? (배치/오프라인)
          ├─ 예 → Parallel GC
          └─ 아니오 → G1 (기본값 + 목표 pause로 시작)
```

**지연시간 예산 산식(간단):**
$$
B_{\text{GC}} \le L_{\text{SLO}} - L_{\text{App(non-GC)}}
$$
예) p99=150ms, App 자체 p99=110ms → GC에 허용 **≤40ms**. G1 `-XX:MaxGCPauseMillis=30~40`으로 시작 후 실측.

---

## 2. JVM 힙과 수집 단계 요약

### 2.1 힙/세대/리전(개념 그림)

```
[Java Heap]
+-----------------------------------------------+
|    Eden    |   Survivor  |        Old         |
| (Young)    |   S0  S1    |    (Tenured)      |
+-----------------------------------------------+
     ^  Allocation (TLAB)      ^ Promotion
```

- 대부분의 객체는 **Young(Eden)** 에서 짧게 살다 소멸.
- Young을 버텨낸 객체는 **Old**로 승격(promote).
- **G1/ZGC/Shenandoah**는 내부 구조가 더 세밀(Region/Color 등)하지만, 기본 사고방식은 동일: **도달성 기반(mark) + 회수(sweep/evacuation) + 압축(compaction)**.

### 2.2 STW & 동시 단계
- 모든 수집기는 어느 정도 **Stop-The-World(STW)** 를 가짐(루트 스캔, 초기 마킹 등).
- **ZGC/Shenandoah**는 대부분을 동시 처리 + 바리어로 일관성 유지 → **매우 짧은 pause**.

---

## 3. 수집기별 상세

### 3.1 Serial GC
- **언제**: 아주 작은 힙/임베디드/단일 코어.
- **특징**: 단일 스레드 STW. 구현 단순, 예측 가능하지만 **긴 pause**.
- **옵션**
```bash
-XX:+UseSerialGC
```

### 3.2 Parallel GC (Throughput Collector)
- **언제**: **처리량 최우선**(배치, 빅잡).
- **특징**: Young/Old 수집을 **여러 GC 스레드**로 병렬화. **pause 존재**하나 짧아지며, 단위 시간 처리량↑.
- **시작 옵션**
```bash
-XX:+UseParallelGC
-XX:ParallelGCThreads=8               # CPU/코어에 맞게
# (필요 시) Old compaction 병렬화도 자동
```

### 3.3 CMS (Concurrent Mark-Sweep) — 역사/이전 코드 이관용
- **상태**: 과거 저지연 대안. 현재는 유지보수 종료/제거. **새 프로젝트에 사용 금지**.
- **마이그레이션**: G1 또는 ZGC/Shenandoah로 이전.

### 3.4 G1 GC (Garbage-First)
- **언제**: **기본 선택**(대부분 서버). **예측 가능한 pause** + **대형 힙**에 강함.
- **아이디어**: 힙을 **동일 크기의 Region**으로 분할, Young/Mixed(Old 일부) 수집을 교차. **RSet/SATB**로 교차 참조 추적.
- **핵심 시작 옵션**
```bash
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200                 # 목표(보장 아님)
-XX:InitiatingHeapOccupancyPercent=45    # 동시 마킹 시작점
-XX:G1HeapRegionSize=8m                  # (JVM 자동 선택 권장)
-XX:+ParallelRefProcEnabled              # 참조처리 병렬
-XX:+UseStringDeduplication              # 문자열 중복 제거
```
- **튜닝 힌트**  
  - 승격 실패/To-space exhausted → `-XX:G1ReservePercent`↑(기본 10), Young 비율 조정(`G1NewSizePercent/G1MaxNewSizePercent`).
  - Humongous(거대) 객체 잦음 → 배열/큰 문자열 다루는 코드 패턴 재검토.

### 3.5 ZGC (Z Garbage Collector)
- **언제**: **초저지연**, TB급 힙, 수 ms급 pause 목표.
- **특징**: Load Barrier/컬러드 포인터, **동시 relocation/compaction**. STW는 매우 짧게 유지.
- **시작 옵션**
```bash
-XX:+UseZGC
# (일부 JDK는 세대 구분 모드 제공)
# -XX:+ZGenerational
```
- **주의**: 최신 JDK 권장(성숙도/옵션 차이). 플랫폼/배포판 지원 확인.

### 3.6 Shenandoah
- **언제**: 초저지연 대안(특히 해당 수집기 포함 빌드 사용 시).
- **시작 옵션**
```bash
-XX:+UseShenandoahGC
# (휴리스틱/모드 옵션 다양: 빌드/버전에 따름)
```

### 3.7 Epsilon (No-Op)
- **언제**: 벤치마크/프로파일링/GC 오버헤드 상한 확인.
- **시작 옵션**
```bash
-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC
```
- **주의**: 운영 금지(힙 소진 즉시 OOM).

---

## 4. 공통 튜닝 기본기

### 4.1 힙 크기/프리터치/컨테이너
```bash
-Xms8g -Xmx8g                    # 서버에선 가급적 고정
-XX:+AlwaysPreTouch              # 힙 미리 터치 → 페이지 폴트 감소
# 컨테이너: MaxRAMPercentage, InitialRAMPercentage 유의
-XX:MaxRAMPercentage=75.0
```

### 4.2 스레드 병렬도
```bash
-XX:ParallelGCThreads=<N>        # GC 병렬 스레드(Young/Old 병렬)
-XX:ConcGCThreads=<M>            # 동시 마킹/이동 스레드
```

### 4.3 GC 로깅(JDK 9+ Unified Logging)
```bash
-Xlog:gc*,safepoint=info:file=gc.log:time,uptime,level,tags
```
JDK 8:
```bash
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log
```

---

## 5. GC 로그 읽기(샘플 해석)

### 5.1 G1 Young/Mixed 축약 예
```
[3.456s][info][gc,start] GC(12) Pause Young (Normal) (G1 Evacuation Pause)
[3.456s][info][gc,heap]  GC(12) Eden: 40->0, Survivors: 4->4, Old: 120->122
[3.462s][info][gc]       GC(12) Pause Young (Normal) ... 6.2ms
```
- Eden 40→0: 성공적 evacuate. Old 120→122: **승격** 2 region.
- 6.2ms: **실측 pause**. 목표(`MaxGCPauseMillis`)와 비교.

### 5.2 자주 보는 경고
- **to-space exhausted / promotion failed** → Reserve/Young 조정, Old 여유, 라이브 바이트 줄이기.
- **humongous** 증가 → 큰 배열/문자열 생성 패턴 개선(청크 분할/풀링).

---

## 6. 실전 시나리오 & 권장 세트

### 6.1 일반 웹/마이크로서비스(지연-처리량 균형)
```bash
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:+ParallelRefProcEnabled
-Xms4g -Xmx4g
-Xlog:gc*:file=gc.log:time,uptime,level,tags
```
- 모니터링 후 p95/p99를 맞춰 `MaxGCPauseMillis` 조정.

### 6.2 배치·오프라인 처리(처리량 우선)
```bash
-XX:+UseParallelGC
-XX:ParallelGCThreads=<cpu>
-Xms8g -Xmx8g
```
- STW 길어도 OK → 전체 작업시간 단축 목표.

### 6.3 초저지연(거래/실시간)
```bash
-XX:+UseZGC
-Xms16g -Xmx16g
-XX:SoftMaxHeapSize=14g          # 여유 버퍼
-Xlog:gc*:file=gc.log:time,uptime,level,tags
```
- OS/NUMA/스레드 pinning 등 시스템 레벨까지 튜닝.

---

## 7. 코드 예제 — GC 압력과 패턴 관찰

### 7.1 작은 객체 대량 생성(Young 압박)
```java
// GCPressureSmall.java
import java.util.*;
public class GCPressureSmall {
    static byte[] kb(int n){ return new byte[1024*n]; }
    public static void main(String[] a) {
        List<byte[]> bag = new ArrayList<>();
        for (int i=0; i<200_000; i++) {
            bag.add(kb(4));           // 4KB
            if ((i % 1000) == 0) bag.clear(); // 생존률 조절
        }
        System.out.println("Done");
    }
}
```
실행(예: G1):
```bash
java -Xms2g -Xmx2g -XX:+UseG1GC -Xlog:gc*:file=gc.log GCPressureSmall
```
- `bag.clear()` 빈도를 바꾸며 **Young/Mixed 빈도**와 **승격량** 변화 관찰.

### 7.2 거대 객체(Humongous) 패턴 확인(G1)
```java
// HumongousDemo.java
import java.util.*;
public class HumongousDemo {
    public static void main(String[] args){
        // 16MB 이상 큰 배열 여러 개 (Region size 8MB 가정시 humongous)
        List<byte[]> big = new ArrayList<>();
        for(int i=0;i<64;i++) big.add(new byte[16*1024*1024]);
        System.out.println("Allocated");
    }
}
```
- G1 로그에서 humongous region 처리 확인 → 큰 버퍼는 **풀링/청크 분할** 고려.

### 7.3 JMX로 GC/풀 상태 읽기
```java
// GCStats.java
import java.lang.management.*;
public class GCStats {
    public static void main(String[] args) {
        for (GarbageCollectorMXBean gc : ManagementFactory.getGarbageCollectorMXBeans()) {
            System.out.printf("GC=%s, count=%d, time(ms)=%d%n",
                gc.getName(), gc.getCollectionCount(), gc.getCollectionTime());
        }
        for (MemoryPoolMXBean p : ManagementFactory.getMemoryPoolMXBeans()) {
            System.out.printf("Pool=%s, used=%d, committed=%d, max=%d%n",
                p.getName(), p.getUsage().getUsed(),
                p.getUsage().getCommitted(), p.getUsage().getMax());
        }
    }
}
```

---

## 8. 자주 터지는 문제 & 대처

- **Promotion Failure / To-space Exhausted**  
  - **G1**: `-XX:G1ReservePercent=10→15~20` 시도, Young 비율 재조정. 생존률 낮추기(객체 풀링/짧은 수명 유지).
- **Full GC 빈발**  
  - Old 부족/동시 단계 추격 실패. 힙 확대, IHOP(마킹 시작점) 조절, 대형 객체 패턴 개선.
- **메모리 누수**  
  - 캐시/맵 무제한, ThreadLocal 미제거, ClassLoader 누수, Direct/네이티브 자원 미해제.  
  - **JFR/Heap dump**로 레퍼런스 체인 추적, 만료/용량 제한 설계.
- **컨테이너에서 과할당**  
  - `-XX:MaxRAMPercentage`로 컨테이너 메모리 대비 힙/메타스페이스/스택 총량 균형.

---

## 9. 레퍼런스 타입·Finalizer·Cleaner

| 타입 | 회수 타이밍 | 사용처 | 주의 |
|---|---|---|---|
| **SoftReference** | 메모리 압박 시 | 캐시 | 비결정적 |
| **WeakReference** | 다음 GC | 맵/메타데이터 | 강참조 혼용 주의 |
| **PhantomReference** | 회수 이후 큐 통지 | 네이티브 정리 | 내용 접근 불가 |
| **Finalizer** | 비권장/폐기 수순 | X | 지연/보안 취약 |
| **Cleaner** | 대안 | 네이티브 해제 | 명시 해제가 최우선 |

---

## 10. G1로의 마이그레이션(CMS → G1) 체크

1) 같은 힙 크기/로드로 시작: `-XX:+UseG1GC`  
2) `-XX:MaxGCPauseMillis`는 우선 200ms 수준  
3) 로그 분석: Young/Mixed 비율, 승격/라이브 바이트, humongous  
4) 실패 신호 시 Young/Reserve/IHOP 조절  
5) 지연 목표를 천천히 내리며 검증

---

## 11. GC 선택/튜닝 체크리스트

- [ ] **SLO 명확화**(p95/p99) & 처리량/코스트 목표  
- [ ] Collector 선택(G1/Parallel/ZGC…)  
- [ ] 힙/프리터치/컨테이너 메모리 설정  
- [ ] `-Xlog:gc*` 또는 JDK8 로그 활성화  
- [ ] 부하 테스트로 **생존률/승격/Young 빈도** 계측  
- [ ] 경고(`promotion failed`, `humongous`, `to-space exhausted`) 0화  
- [ ] 레퍼런스/캐시/ThreadLocal 설계 점검  
- [ ] JFR/프로메테우스 대시보드 구성  
- [ ] 릴리즈 전 다양한 스파이크/장시간 soak 테스트

---

## 12. 수식으로 보는 대략적 pause 근사(복사형 수집기)
$$
\text{Pause} \approx \frac{\text{Live Bytes (Evacuation 대상)}}{\text{Copy Throughput}} + \text{Overheads}
$$
- **라이브 바이트**(생존률↑)가 크면 pause↑.  
- 해결: Young 축소(생존률 낮추기), Mixed 비중 조정, GC 병렬 스레드↑, 객체 수명 단축.

---

## 13. 옵션 치트시트(발췌)

```text
# 공통
-Xms<size> -Xmx<size>
-XX:+AlwaysPreTouch
-Xlog:gc*,safepoint:file=gc.log:time,uptime,level,tags

# Parallel
-XX:+UseParallelGC
-XX:ParallelGCThreads=<n>

# G1
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:InitiatingHeapOccupancyPercent=45
-XX:G1ReservePercent=10
-XX:+ParallelRefProcEnabled
-XX:+UseStringDeduplication

# ZGC
-XX:+UseZGC
# (버전에 따라) -XX:+ZGenerational
-XX:SoftMaxHeapSize=<size>

# Shenandoah
-XX:+UseShenandoahGC
# (빌드/버전 별 휴리스틱 옵션 존재)

# Epsilon
-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC
```

---

## 14. 부록: 간단 JMH 스켈레톤(할당 패턴 벤치용)

```java
// BenchmarkAlloc.java (JMH 의존)
import org.openjdk.jmh.annotations.*;
import java.util.concurrent.TimeUnit;

@Warmup(iterations=3, time=1, timeUnit=TimeUnit.SECONDS)
@Measurement(iterations=5, time=1, timeUnit=TimeUnit.SECONDS)
@Fork(1)
@State(Scope.Thread)
public class BenchmarkAlloc {
    @Benchmark
    public byte[] allocate1k() {
        return new byte[1024]; // young 압력
    }
}
```

실행 예(히프/수집기 바꿔가며):
```bash
java -Xms2g -Xmx2g -XX:+UseG1GC -Xlog:gc* -jar target/benchmarks.jar
```

> **주의**: 마이크로벤치는 실서비스 패턴을 대체하지 못합니다. **부하 테스트**가 최종 판단.

---

## 결론

- **모든 워크로드에 만능인 GC는 없다.**  
- **기본은 G1**, **처리량은 Parallel**, **초저지연·대형 힙은 ZGC/Shenandoah**.  
- 수집기 교체는 시작점일 뿐. **로그/JFR로 생존률·승격·경고 신호**를 수치로 보고, **작게 한 번씩** 조정하라.  
- 코드/아키텍처 레벨(객체 수명/캐시/ThreadLocal/대형 객체 패턴) 최적화가 **GC 튜닝보다 더 큰 개선**을 주는 경우가 많다.
