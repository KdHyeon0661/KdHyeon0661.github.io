---
layout: post
title: Java - GC 종류
date: 2025-08-04 22:20:23 +0900
category: Java
---
# Java GC 종류 (Serial, Parallel, CMS, G1 등) — 상세 정리

아래는 JVM에서 사용 가능한 주요 가비지 컬렉터(GC)들의 동작 원리, 장단점, 대표 JVM 옵션(사용 방법)과 **언제 어떤 GC를 선택해야 하는지**에 대한 실무 관점의 정리입니다.  
버전별 상태(기본값·deprecated·도입 시기 등)는 JVM 버전에 따라 달라지니, 사용 중인 `java -version`과 공식 문서를 항상 확인하세요.

---

## 한눈에 요약 비교

| GC | 특징(요약) | 장점 | 단점 | 대표 옵션 |
|---|-----------:|------|------|:---------|
| **Serial GC** | 단일 스레드 동작, stop-the-world | 매우 단순·작고 임베디드/단일코어에 적합 | Pause 큼 → 대형/멀티코어엔 부적합 | `-XX:+UseSerialGC` |
| **Parallel GC** (Parallel / Throughput) | Young/Old 병렬 처리, 처리량 최적화 | 높은 전체 처리량(throughput) | Pause 시간은 비교적 김(하지만 병렬로 단축) | `-XX:+UseParallelGC` |
| **CMS** (Concurrent Mark-Sweep) | Old 영역 동시 수거(낮은 pause 목표) — **deprecated/제거** | 낮은 장기 pause(구형 서버에 인기) | 단편화, 유지보수 문제 → deprecated/삭제 | `-XX:+UseConcMarkSweepGC` (deprecated/removed)|
| **G1 GC** (Garbage-First) | Region 기반, pause 목표 설정 가능, Java 9+ 기본 | 예측 가능한 pause, 대형 힙에 강함, 기본 추천 | 매우 복잡→특정 워크로드서 튜닝 필요 | `-XX:+UseG1GC` (Java9+ 기본).|
| **ZGC** | 저지연(very low pause), 대용량 힙 최적화 (Z Garbage Collector) | 매우 짧은 pause(수 ms 이하), 대형 힙에 적합 | 구현 복잡성, 일부 JDK에서만 사용 가능(버전 의존) | `-XX:+UseZGC` (JDK 11 도입, prod-ready 이후 버전에서 권장).|
| **Shenandoah** | 저지연 GC(Oracle/OpenJDK 배포판별 포함 여부 다름) | 낮은 pause, 힙 크기 확장성 | 모든 빌드에 포함되진 않음(빌드/배포판 확인) | `-XX:+UseShenandoahGC` (OpenJDK/배포판에 따라 사용 가능).|
| **Epsilon** | No-op(수거 안함) — 메모리 할당만 처리(테스트/벨치용) | GC 오버헤드 완전 제거(테스트·프로파일링 용도) | 힙 고갈 시 JVM 종료(실 운영엔 부적합) | `-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC` (JDK 11 도입).|

---

## 상세 설명

### 1) Serial GC
- **동작**: 모든 GC 작업을 단일 스레드에서 수행(주로 작은 힙/단일 CPU 환경).  
- **사용처**: 임베디드, 단일 스레드 배치, 메모리·스레드 리소스 제약 환경.  
- **옵션**:
```bash
-XX:+UseSerialGC
```

---

### 2) Parallel GC (Throughput collector)
- **동작**: Young/Old 영역의 마킹·복사·압축 작업을 여러 GC 쓰레드로 병렬 수행.  
- **목표**: 전체 처리량(throughput) 최대화 — GC가 차지하는 총 CPU 시간을 줄여 처리량을 높임.  
- **장점/단점**: 멀티코어서 높은 처리량을 기대할 수 있으나, pause는 여전히 발생(병렬로 단축).  
- **옵션**:
```bash
-XX:+UseParallelGC
# GC 쓰레드 수 지정
-XX:ParallelGCThreads=<N>
```
(자세한 옵션·기본 스레드 수는 JVM/플랫폼에 따라 결정).

---

### 3) CMS (Concurrent Mark-Sweep) — deprecated 및 제거
- **동작**: Old 영역에서 마킹(mark) 단계 일부를 애플리케이션과 **동시(concurrent)**로 수행해 pause 시간을 줄이려는 접근.  
- **상태**: JEP 363에 따라 CMS는 deprecation 이후 제거(예: 제거 결정 및 관련 JEP 참조). 최신 JDK에서는 더 이상 포함되지 않음(대체로 G1 권장).
- **결론**: 과거엔 저지연(Old) 목적으로 많이 쓰였으나, 현재는 **G1/ZGC/Shenandoah** 등으로 대체 권장.

---

### 4) G1 GC (Garbage-First) — 현대 JVM의 기본 선택
- **핵심 아이디어**: 힙을 같은 크기의 *Region*으로 분할하여 일부 Region을 우선(pick)해 수거하는 전략. Young/Old 구분을 Region 단위로 동적으로 관리.  
- **특징**:
  - **pause 목표(예: `-XX:MaxGCPauseMillis`)**를 지정하면 G1가 이를 만족하려 시도.
  - 마킹·정리·compaction을 섞어 수행(Young GC와 Mixed GC).  
- **장점**: 예측 가능한 pause와 대형 힙에서의 우수한 성능. Java 9 이후 기본 GC.
- **대표 옵션**:
```bash
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200     # 목표 최대 pause (ms)
-XX:InitiatingHeapOccupancyPercent=45  # Mixed GC 트리거 기준 (%)
```
- **튜닝 팁**: `MaxGCPauseMillis`는 목표일 뿐 절대 보장 아님. pause 목표가 너무 짧으면 처리량 저하 가능.

---

### 5) ZGC (Z Garbage Collector) — 저지연·대규모 힙 대상
- **도입/현황**:
  - JDK 11에서 실험적(experimental)으로 도입. 이후 버전에서 성숙해져 production-ready 상태로 권장되기도 함(버전별 차이 있음).
  - 최근 JDK(예: JDK 21)에서는 **generational ZGC** 등 기능 추가가 진행됨(세대별 동작 개선).
- **특징**:
  - 매우 짧은 pause(일반적으로 수 ms 이하), 큰 힙(수십 GB~TB)에도 적합.
  - 복잡한 알고리즘과 메모리 포인터 처리(색상·relocation 등).  
- **옵션**:
```bash
-XX:+UseZGC
# (JDK 버전별 추가 플래그 존재: -XX:+ZGenerational 등)
```
- **주의**: 모든 플랫폼/빌드에서 지원되는 것은 아니며, 버전별 안정성·옵션이 다름.

---

### 6) Shenandoah — Red Hat 계열/일부 OpenJDK 빌드의 저지연 GC
- **특징**: ZGC와 비슷하게 낮은 pause 목표를 지향. OpenJDK에 통합되었으나, **모든 JDK 배포판에 포함되지 않을 수 있음**(빌드/배포판 확인 필요).
- **옵션**:
```bash
-XX:+UseShenandoahGC
```
- **사용처**: 대용량·저지연 환경에서 ZGC 대안으로 고려(특히 Shenandoah 포함 빌드 사용 시).

---

### 7) Epsilon (No-Op) — 수거를 하지 않는 실험적 GC
- **동작**: 메모리 **할당만 처리**하고 회수는 전혀 하지 않음. 힙이 가득 차면 JVM이 `OutOfMemoryError`로 종료. 주로 **성능 비교·메모리 프로파일링·테스트** 용도. (JDK 11 도입)
- **옵션**:
```bash
-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC
```
- **주의**: 운영환경에서 사용 금지(특수 목적에만 사용).

---

## GC 선택 가이드(실무 팁)
1. **일반 웹/애플리케이션 서버**: 기본적으로 **G1**이 좋은 출발점(Java 9+). `-XX:MaxGCPauseMillis`로 목표 설정 후 모니터링.
2. **처리량(throughput) 우선**(배치/벡엔드 CPU 바운드): **Parallel GC** 고려.  
3. **초저지연(low latency)·대형 힙**: **ZGC**(또는 Shenandoah, 빌드 지원 시) 고려. JDK 버전 호환성·테스트 필수.
4. **테스트/프로파일링**: Epsilon으로 GC 비용을 제거해 메모리 사용 패턴 확인 가능.
5. **CMS는 사용하지 말 것**: CMS는 deprecated/제거(신규 JDK에 없음). 기존 CMS 설정을 사용하는 경우 G1로 마이그레이션 권장.

---

## 대표 JVM 옵션 예시 (요약)
```bash
# G1 (Java 9+ 기본)
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:InitiatingHeapOccupancyPercent=45

# Parallel
-XX:+UseParallelGC
-XX:ParallelGCThreads=8

# ZGC (JDK 11+, 빌드 지원 필요)
-XX:+UseZGC
# 제너레이셔널 ZGC (버전별 옵션)
-XX:+ZGenerational

# Shenandoah (빌드에 포함된 경우)
-XX:+UseShenandoahGC

# Epsilon (테스트 전용)
-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC

# (CMS는 더 이상 권장/지원되지 않음)
-XX:+UseConcMarkSweepGC   # deprecated/removed — 사용 금지 권장
```

---

## GC 로그/모니터링 포인트 (무엇을 볼까)
- **Pause Count / Pause Time**: 애플리케이션 응답성 영향.
- **Young GC 빈도 및 시간**: 지나치게 잦으면 객체 생성 패턴 재검토.
- **Full GC 빈도/시간**: 치명적 — Old 영역/메타스페이스 문제 의심.
- **Heap 사용량(eden/survivor/old)**: 승격(promote) 비율, survivor 크기조정 필요성 확인.
- **GC 유형**: Young, Mixed, Full, Evacuation Pause 등 로그 식별.

(공식 GC 튜닝 가이드·로그 예시는 Oracle 문서와 각 GC 문서를 참고하세요.)

---

## 마무리 요약
- **어떤 GC가 '최고'라는 것은 없다** — 워크로드(지연 요구·처리량·힙 크기·JDK 버전)에 따라 적합한 GC가 달라진다.  
- 최신 JDK에서는 **G1이 기본**이고, **ZGC / Shenandoah**는 저지연·대규모 힙에 매우 매력적이다. CMS는 더 이상 권장되지 않으니 마이그레이션이 필요합니다.
- 항상 실제 환경(혹은 유사 부하)에서 **벤치마크 + GC 로그 분석**으로 결정을 검증하세요. Oracle의 GC 튜닝 가이드가 좋은 출발점입니다.