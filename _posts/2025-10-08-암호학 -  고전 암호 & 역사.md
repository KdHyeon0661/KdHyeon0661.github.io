---
layout: post
title: 암호학 - 고전 암호 & 역사
date: 2025-10-08 22:30:23 +0900
category: 암호학
---
# 고전 암호 & 역사

## 암호

### 개념과 분류

- **단일표치(Monoalphabetic)**: 하나의 평문 알파벳이 **항상 같은** 암호문 알파벳으로 치환
  - 예: **시저(Caesar)**, **단순치환(Simple substitution)**
- **다표치(Polyalphabetic)**: 같은 평문 알파벳이라도 **위치/키에 따라 다르게** 치환
  - 예: **비제네르(Vigenère)**, **오토키(Autokey)**

**치환**은 “문자의 **형태**를 바꾸는” 접근이고, **전치**는 “문자의 **순서를 바꾸는**” 접근입니다. 두 기법을 **혼합**하면 공격 난이도가 커집니다.

---

### / 이동 암호

- 알파벳을 \(k\)만큼 **고정 이동**:
  \[
  E_k(x) = (x + k) \bmod 26,\quad D_k(y) = (y - k) \bmod 26
  \]
  여기서 \(x,y\)는 A=0, B=1,…, Z=25로 인덱싱.

**예제 (암복호)**
```python
import string
ABC = string.ascii_uppercase

def caesar_encrypt(msg, k):
    out=[]
    for ch in msg.upper():
        if ch in ABC:
            out.append(ABC[(ABC.index(ch)+k)%26])
        else:
            out.append(ch)
    return ''.join(out)

def caesar_decrypt(ct, k):
    return caesar_encrypt(ct, -k)

pt = "MEET AT DAWN"
ct = caesar_encrypt(pt, 3)
print("CT:", ct, "PT:", caesar_decrypt(ct, 3))
```

- **키 공간**: 26개 → **전수조사**로 즉시 파괴.
- **빈도 보존**: E가 가장 많은 영어 텍스트는 암호문에서도 **어떤 한 문자**가 가장 많음 → **빈도분석**으로 추정 가능.

---

### 일반 단일치환(Simple Substitution)

- 임의의 26자 **치환표(permutation)** 를 키로 사용.
- **키 공간**: \(26!\approx 4\times 10^{26}\) (시저보다 훨씬 큼)
  → 그럼에도 **빈도분석 + 언어 모델**로 충분한 텍스트가 있으면 해독 가능.

**간단 암복호기**
```python
import string
ABC = string.ascii_uppercase

def make_sub_key_from_mapping(mapping_dict):
    # mapping_dict: {'A':'Q', 'B':'W', ...} 26자 완전 매핑 가정
    sub_key_enc = ''.join(mapping_dict.get(ch, ch) for ch in ABC)
    # 역치환(복호) 테이블
    inv = {v:k for k,v in mapping_dict.items()}
    sub_key_dec = ''.join(inv.get(ch, ch) for ch in ABC)
    return sub_key_enc, sub_key_dec

def subs_encrypt(msg, sub_key_enc):
    out=[]
    for ch in msg.upper():
        if ch in ABC:
            out.append(sub_key_enc[ABC.index(ch)])
        else:
            out.append(ch)
    return ''.join(out)

def subs_decrypt(ct, sub_key_dec):
    out=[]
    for ch in ct.upper():
        if ch in ABC:
            out.append(sub_key_dec[ABC.index(ch)])
        else:
            out.append(ch)
    return ''.join(out)
```

**핵심 취약점**: 단일치환은 **문자 빈도**(1-gram)와 **쌍문자 빈도**(2-gram) 패턴을 **보존**.
→ ‘E’가 많으면 암호문에서도 특정 문자가 유독 많아지고, ‘TH’, ‘HE’, ‘ER’ 같은 **이중자 빈도**도 흔적을 남긴다.

---

### 빈도분석(Frequency Analysis)

**기본 아이디어**:
암호문에서 **문자 빈도**를 세고, 평문 언어(영어, 한국어 등)의 **전형적 빈도 분포**와 **비교**한다.
영어: E T A O I N S H R … (대략적 순서)

**문자 빈도 계산**
```python
from collections import Counter
def letter_freq(text):
    c = Counter(ch for ch in text.upper() if ch.isalpha())
    n = sum(c.values())
    return {k: v/n for k,v in c.items()}  # 상대빈도

sample = "THIS IS A LONGER TEXT SAMPLE FOR FREQUENCY DEMO. THIS TEXT ..."
print(letter_freq(sample))
```

**\(\chi^2\) 통계량으로 시저 복호키 추정**
각 이동 \(k\)에 대해, 치환 복귀시킨 텍스트의 빈도와 영어 기대 빈도의 **차이**를 측정 → 가장 작은 \(k\) 선택.
```python
import numpy as np

ENG_FREQ = {
 'A':0.08167,'B':0.01492,'C':0.02782,'D':0.04253,'E':0.12702,'F':0.02228,
 'G':0.02015,'H':0.06094,'I':0.06966,'J':0.00153,'K':0.00772,'L':0.04025,
 'M':0.02406,'N':0.06749,'O':0.07507,'P':0.01929,'Q':0.00095,'R':0.05987,
 'S':0.06327,'T':0.09056,'U':0.02758,'V':0.00978,'W':0.02360,'X':0.00150,
 'Y':0.01974,'Z':0.00074
}

def shift_decrypt(ct, k):
    return caesar_decrypt(ct, k)

def chi2_for_k(ct, k):
    # k를 적용해 평문 추정, 그 평문의 빈도분석 -> 영어 빈도와 chi^2
    pt = shift_decrypt(ct, k)
    c = Counter(ch for ch in pt if ch in ABC)
    n = sum(c.values())
    if n == 0: return 1e9
    chi2=0.0
    for ch in ABC:
        obs = c.get(ch,0)
        exp = ENG_FREQ[ch]*n
        chi2 += (obs-exp)**2/(exp+1e-9)
    return chi2

def crack_caesar(ct):
    best=(None, 1e18)
    for k in range(26):
        val = chi2_for_k(ct, k)
        if val < best[1]: best=(k,val)
    return best

# 데모:

ct = caesar_encrypt("WE WILL MEET AT THE BRIDGE AT NIGHT", 7)
print("best k:", crack_caesar(ct))
```

**단일치환**의 자동 공격은 보통
- 1-gram/2-gram/3-gram 점수 +
- 휴리스틱(사전/단어 패턴/고정 표현) +
- 탐색(휴교환·SA·유전 알고리즘)
을 조합합니다. (여기선 개념만)

---

## 암호

### 개념

- **문자의 값은 그대로**, **위치(순서)** 만 재배열.
- 흔한 예: **열전치(Columnar Transposition)**.

**예 (열전치: 키=“ZEBRA”)**
1) 키의 알파벳순 정렬을 기준으로 열 인덱스 순서를 만든다.
2) 행렬에 평문을 가로로 채우고, **키 순서대로 열**을 읽어 암호문 생성.

**간단 구현**
```python
def columnar_encrypt(pt, key):
    pt = ''.join(ch for ch in pt.upper() if ch.isalpha())
    n = len(key)
    rows = (len(pt)+n-1)//n
    grid = [['X']*n for _ in range(rows)]
    idx=0
    for r in range(rows):
        for c in range(n):
            if idx < len(pt): grid[r][c]=pt[idx]; idx+=1
    order = sorted(range(n), key=lambda i: key[i])
    ct=[]
    for c in order:
        for r in range(rows):
            ct.append(grid[r][c])
    return ''.join(ct)

def columnar_decrypt(ct, key):
    n = len(key)
    rows = (len(ct)+n-1)//n
    order = sorted(range(n), key=lambda i: key[i])
    # 각 열의 길이
    col_len = [rows]*n
    extra = rows*n - len(ct)
    if extra>0:
        # 마지막 행 일부는 패딩이었을 수 있으나 간단화
        pass
    grid = [['']*n for _ in range(rows)]
    idx=0
    for c in order:
        for r in range(rows):
            if idx < len(ct):
                grid[r][c]=ct[idx]; idx+=1
    # 가로로 읽기
    out=[]
    for r in range(rows):
        for c in range(n):
            out.append(grid[r][c])
    return ''.join(out)

pt="WE ARE DISCOVERED. FLEE AT ONCE"
key="ZEBRA"
ct = columnar_encrypt(pt, key)
print("CT:", ct)
print("PT:", columnar_decrypt(ct, key))
```

**특징/취약점**
- **문자 빈도**는 **그대로**(치환과 달리 값이 변하지 않음) → **단어 경계** 흔적이 약화되지만, **언어 통계**(n-gram)로 여전히 추적 가능.
- 고정 키 길이 추정은 **열 길이**/패턴/지표로 접근.

---

## — 다표치 암호의 대표

### 원리

- 키가 \(k_0,k_1,\dots, k_{L-1}\) (각 0~25)일 때, 평문의 \(i\)-번째 문자를
  \[
  c_i = (p_i + k_{i \bmod L}) \bmod 26
  \]
  로 치환 → **주기 L**마다 치환 표가 바뀜.

**암복호기**
```python
import string
ABC = string.ascii_uppercase

def vigenere_encrypt(pt, key):
    pt = ''.join(ch for ch in pt.upper() if ch.isalpha())
    key = key.upper()
    out=[]
    j=0
    for ch in pt:
        k = ABC.index(key[j%len(key)])
        out.append(ABC[(ABC.index(ch)+k)%26])
        j+=1
    return ''.join(out)

def vigenere_decrypt(ct, key):
    key = key.upper()
    out=[]
    j=0
    for ch in ct:
        k = ABC.index(key[j%len(key)])
        out.append(ABC[(ABC.index(ch)-k)%26])
        j+=1
    return ''.join(out)

pt="ATTACK AT DAWN"
key="LEMON"
ct = vigenere_encrypt(pt, key)
print("CT:", ct, "PT:", vigenere_decrypt(ct, key))
```

- 단일치환보다 **빈도 흔적 희석** → **장기간** 비제네르는 *“해독 불가”*로 오해받았음.

---

### Kasiski 시험 & 우연지수(Index of Coincidence, IC)

**핵심 아이디어**:
- 암호문에서 **반복되는 조각** 사이의 간격들의 **공약수**를 추정 → **키 길이 후보** 도출(**Kasiski**).
- 키 길이 \(L\)이 맞다면, 암호문을 **L열로 분할**하여 각 열은 **사실상 시저 암호**(고정 이동). → 각 열에 **빈도분석** 적용.

**IC (Friedman’s Test)**
- 우연지수:
  \[
  \mathrm{IC} = \frac{\sum_{i} f_i(f_i-1)}{N(N-1)}
  \]
  (여기서 \(f_i\)는 문자 \(i\)의 등장 횟수, \(N\)은 총 문자수)
- 영어 평문은 약 **0.066**, 균등 랜덤은 **≈ 1/26 ≈ 0.0385**.
- 키 길이 \(L\) 가정 하에, **L개 부분열**의 평균 IC가 영어 IC에 가까우면 **가능성 ↑**.

**Kasiski & IC 코드 데모**
```python
from collections import Counter
import re
import math

def index_of_coincidence(s):
    s = ''.join(ch for ch in s.upper() if ch.isalpha())
    N = len(s)
    c = Counter(s)
    num = sum(v*(v-1) for v in c.values())
    den = N*(N-1) if N>1 else 1
    return num/den

def kasiski_spacings(ct, ngram=3):
    ct = ''.join(ch for ch in ct.upper() if ch.isalpha())
    pos = {}
    for i in range(len(ct)-ngram+1):
        g = ct[i:i+ngram]
        pos.setdefault(g, []).append(i)
    gaps=[]
    for g, arr in pos.items():
        if len(arr) >= 2:
            for i in range(len(arr)-1):
                gaps.append(arr[i+1]-arr[i])
    return gaps

def factors(n):
    out=set()
    for d in range(2, int(math.sqrt(n))+1):
        if n%d==0:
            out.add(d); out.add(n//d)
    return out

def guess_key_lengths(ct, maxlen=20):
    gaps = kasiski_spacings(ct, ngram=3)
    score = Counter()
    for g in gaps:
        for f in factors(g):
            if 2 <= f <= maxlen:
                score[f]+=1
    # IC 보조: 각 L 가정 후 L개 부분열의 IC 평균
    ic_score = {}
    only_alpha = ''.join(ch for ch in ct.upper() if ch.isalpha())
    for L in range(2, maxlen+1):
        ics=[]
        for r in range(L):
            col = only_alpha[r::L]
            if len(col) > 20:
                ics.append(index_of_coincidence(col))
        if ics:
            ic_score[L]=sum(ics)/len(ics)
    # 두 점수 함께 참고
    return score.most_common(10), sorted(ic_score.items(), key=lambda x:abs(x[1]-0.066))

# 데모

pt = "ATTACK AT DAWN! WE WILL REINFORCE THE EASTERN WALL AT SUNSET. SEND SUPPLIES..."
key="LEMON"
ct = vigenere_encrypt(pt, key)
kasiski, ic = guess_key_lengths(ct, maxlen=12)
print("Kasiski:", kasiski)
print("IC-near-english:", ic[:5])
```

**복호(키 길이 가정 후, 각 열의 시저키 결정)**
```python
def crack_vigenere_with_keylen(ct, L):
    # 각 열을 시저 복호문으로 가정하고 chi^2가 최소가 되게 k 결정
    ct_alpha = ''.join(ch for ch in ct.upper() if ch.isalpha())
    columns = [ct_alpha[i::L] for i in range(L)]
    keys=[]
    for col in columns:
        # 시저 복호: col -> 평문 영어 빈도와 가장 가까운 k
        best_k, best_val = None, 1e18
        for k in range(26):
            # k를 빼서 평문 후보
            pt_col = ''.join(ABC[(ABC.index(ch)-k)%26] for ch in col)
            c = Counter(pt_col)
            n = sum(c.values())
            chi2 = 0.0
            for ch in ABC:
                obs = c.get(ch,0)
                exp = ENG_FREQ[ch]*n
                chi2 += (obs-exp)**2/(exp+1e-9)
            if chi2<best_val:
                best_k, best_val = k, chi2
        keys.append(best_k)
    # 키를 문자로
    key = ''.join(ABC[k] for k in keys)
    # 복호
    return vigenere_decrypt(ct, key), key

pt_rec, key_rec = crack_vigenere_with_keylen(ct, len(key))
print("Recovered KEY:", key_rec)
print("PT head:", pt_rec[:80])
```

**요점**
- 비제네르는 **키 길이 추정 → 각 열 시저 공격**의 조합으로 보통 파괴됨.
- **키가 충분히 랜덤하고 길면**(예: OTP 수준) 안전하지만, **키 재사용/짧은 키**는 취약.

---

## 스토리 — 기계적 다표치 + 현실의 공격

### 구조 개요

- **키 요소**: 로터(회전자) 선택·순서, **링 설정**, **플러그보드(Plugboard)** 배선, **시작 위치**
- **신호 흐름**: 키보드 → 플러그보드 → 로터 스택(좌→우) → **반사판(Reflector)** → 로터 역방향 → 플러그보드 → 램프
- **반사판** 때문에 \(E= D\) (자기역함수) 성질이 생기지만, **문자 자신으로 암호화되지 않는** 제약도 함께 생김.

### 보안 직관 & 취약점

- 상태 공간이 거대(로터 조합·플러그보드 배선) → **키 공간** 매우 큼.
- 그러나 **운용 규칙**(키 재사용, 인사말·기상 보고 **상투문구 crib**, 설정 전송 절차) · **기계 제약**(자기암호 금지) · **통계적 중복**이 **공격 표면**을 제공.

### 연합국의 공격(대략)

- **크립(crib)**: “WETTERBERICHT(일기예보)” 같은 상투 평문 추정.
- **반사판 구조**와 **자기암호 금지**를 이용해, **로터 위치/배선** 후보를 **대거 제외**.
- **봄브(Bombe)**: 가정한 crib을 기계적으로 대입·제거해 **가능한 설정만** 남기는 **논리 계산기**.
- **정보전·운용 실수**(독일군의 절차 오류·키북 노획)까지 결합 → 실전에서 대규모 해독 성공.

> 교훈: **알고리즘 복잡성**만으로는 부족. **운용(Procedures)**, **키 관리**, **상투문구·포맷**까지 합치면 **큰 취약점**이 생긴다.

---

## ✅ 3.5 빈도분석과 현대 암호로의 교훈

### 엔트로피(무작위성)는 생명선

- 고전 암호는 **언어 통계(빈도)**를 숨기지 못해 붕괴.
- 현대 암호는 **키/Nonce/시드**의 **엔트로피**와 **AEAD**로 **통계적 단서**를 최대 차단.
  - **키 공간**이 커도, **키 분포가 편향**되거나 **재사용**되면 붕괴(예: GCM Nonce 충돌).

### Kerckhoffs 원리 & 운용 보안

- 알고리즘 공개 가정, **키만 비밀** → 안전해야 한다.
- 하지만 **운용층**(프로토콜·키 전달·기본값·로그·에러 메시지)이 **실제 취약점**의 **절반 이상**을 차지.
  - 에니그마: 거대한 상태 공간에도 **운용 실수/절차**가 치명적.

### 통계적 공격에 대한 설계 원칙

- **인증 없는 암호화 금지**: 패딩오라클, 길이/타이밍 차이 → 통계적 단서.
- **AEAD**: 변조 시 즉시 실패 → 통계 샘플 축적 차단.
- **형태·패턴 은닉**: 길이 은닉(패딩), 포맷 일관성(카운터·난수), **상투문구 제거**(salt/AAD/nonce 다양화).

### 키 관리와 재사용 금지

- **비제네르**와 **에니그마**의 몰락: **키 재사용**·**짧은 키 주기**·**반복 패턴**.
- 현대: **키 회전**, **세션키**(ECDH), **고정키 최소화**, **Nonce 재사용 금지**.

---

## ✅ 3.6 실습: 작은 공격자 도구 만들기

### → 실제 문장으로 시험

```python
sample_pt = ("IN CRYPTOGRAPHY, ATTACKERS LOOK FOR STRUCTURE. "
             "REPEATING PHRASES AND TEMPLATES ARE DANGEROUS.")
ct = caesar_encrypt(sample_pt, 12)
best_k, score = crack_caesar(ct)
print("k=",best_k, "score=",score)
print("recovered:", caesar_decrypt(ct, best_k))
```

### 단일치환 휴리스틱(개념)

- 1) 암호문 단일문자 빈도 → 영어 빈도 맵핑 예비 추정
- 2) 2-gram, 3-gram 점수 개선을 위해 휴교환(swap)으로 탐색
- 3) 사전 단어 점수/스페이스 추정(전치 혼합 시)

> 구현은 길어져 생략하지만, 원리상 **언어 모델**을 점수 함수로 삼아 **탐색**한다는 점이 핵심.

### 비제네르: 키 길이 추정 → 각 열 시저 공격 (이미 코드 제공)

- 실전 텍스트로 크랙 성공률을 시험하고, **짧은 키**일수록 쉽게 깨짐을 확인.

---

## ✅ 3.7 역사적 장면들 (초간략 타임라인)

- **Al-Kindi(9세기)**: **빈도분석** 최초 기록 — 고전 치환암호의 체계적 파괴 시작.
- **Vigenère(16세기)**: 다표치 체계 제안 → “해독 불가” 신화 형성.
- **19세기**: **Kasiski** & **Friedman** → 키 길이 추정·IC로 비제네르 파괴 체계화.
- **WWII**: **에니그마** — 복잡한 기계식 다표치도 **운용·절차·통계**로 격파 가능함을 역사적으로 증명.

> 메시지: **수학·공학·운용**이 모두 맞물려야 **진짜 안전**하다.

---

## ✅ 3.8 현대 암호 설계로의 브리지

1) **통계 흔적 제거**: AEAD, 랜덤·유사랜덤 패딩, 레코드 프레이밍
2) **키 파생/회전**: KDF(예: HKDF), 세션키(ECDH), 하이브리드(KEM + 대칭)
3) **프로토콜 설계**: TLS 1.3의 0-RTT 위험 모델링, AAD(헤더 무결성)
4) **검증 도구**: Wycheproof/미스유스 테스트, 포멀 검증(프로토콜 레벨)

---

## ✅ 3.9 연습문제

1) 단일치환 암호가 **언어 빈도**를 어떻게 보존하는지 1-gram/2-gram 관점에서 설명하라.
2) 비제네르에서 **키 길이**가 길어질수록 공격이 어려워지는 이유와, **완벽 보안(OTP)** 와의 연관을 비교하라.
3) 열전치 암호의 복호 알고리즘을 **키 순서 복원** 관점에서 단계별로 서술하라.
4) 에니그마의 **반사판**이 보안에 미치는 **긍정적/부정적** 효과를 기술하라.
5) 빈도분석의 교훈을 바탕으로, **현대 AEAD**에서 어떤 설계 요소가 “패턴 유출”을 막는지 정리하라(AAD, 태그, Nonce 설계 포함).

---

## ✅ 3.10 요약 카드

- **치환/전치**: 값 바꾸기 vs 순서 바꾸기. 단일치환은 **빈도 보존**으로 취약.
- **비제네르**: 다표치로 흔적 희석 → **Kasiski/IC** + **열별 시저**로 파괴.
- **에니그마**: 거대한 키 공간이라도 **운용**과 **상투문구**가 무너지면 종잇장.
- **교훈**: **엔트로피**(키/Nonce), **AEAD**, **키 관리·회전**, **Kerckhoffs 원리**, **프로토콜/운용 보안**이 필수.
