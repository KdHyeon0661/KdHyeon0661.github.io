---
layout: post
title: 영상처리 - 화질 향상과 히스토그램 (C#)
date: 2025-12-10 19:30:23 +0900
category: 영상처리
---
# 화질 향상과 히스토그램: 이론과 구현

## 화질 향상의 개요와 중요성

화질 향상(Image Enhancement)은 영상의 **시각적 품질을 개선**하기 위한 처리로, 객체 인식이나 분석 이전의 **전처리 단계**로 사용된다. 본질적으로 인간의 시각 인지를 돕거나 후속 처리 알고리즘의 성능을 향상시키는 목적을 가진다.

화질 향상 기법은 크게 두 가지 범주로 분류된다:
1. **공간 영역(Spatial Domain) 처리**: 픽셀 값 직접 조작
2. **주파수 영역(Frequency Domain) 처리**: 변환 도메인에서 조작

본 장에서는 **픽셀 포인트 연산(Point Processing)**을 중심으로, 히스토그램 기반의 이론과 구현을 다룬다.

---

## 히스토그램의 정의와 특성

히스토그램은 영상 내 픽셀 밝기 값의 빈도 분포를 나타내는 통계적 도구이다. 픽셀 값 집합을 $$\{r_0, r_1, \dots, r_{L-1}\}$$라 할 때:

$$
h(r_k) = n_k
$$

여기서:
- $$n_k$$: 값 $$r_k$$를 갖는 픽셀 수
- $$L$$: 전체 밝기 레벨 수 (8비트 영상에서 $$L = 256$$)

### 히스토그램의 시각적 표현

```
예시: 저대비 영상의 히스토그램
     ▲
     │
빈도수│    ┌─────┐
     │    │     │
     │    │     │
     │    │     │
     └────┴─────┴───▶
       0  128  255  밝기
```

---

## 정규화된 히스토그램 (PDF)

전체 픽셀 수를 $$n$$이라 하면, 정규화된 히스토그램은 다음과 같다:

$$
p(r_k) = \frac{n_k}{n}
$$

이는 확률 밀도 함수(PDF)로 해석되며 다음 성질을 만족한다:
- $$0 \leq p(r_k) \leq 1$$
- $$\sum_{k=0}^{L-1} p(r_k) = 1$$

---

## 히스토그램 계산: 고수준 및 저수준 API

### 고수준 API 구현

```csharp
public class ImageProcessor
{
    // 기본 히스토그램 계산
    public int[] CalculateHistogram(MyImage image)
    {
        int[] histogram = new int[256];
        int size = image.Width * image.Height;

        for (int i = 0; i < size; i++)
        {
            histogram[image.Buffer[i]]++;
        }

        return histogram;
    }
    
    // 정규화된 히스토그램 (PDF) 계산
    public double[] CalculateNormalizedHistogram(MyImage image)
    {
        int[] hist = CalculateHistogram(image);
        int totalPixels = image.Width * image.Height;
        double[] normalized = new double[256];
        
        for (int i = 0; i < 256; i++)
        {
            normalized[i] = (double)hist[i] / totalPixels;
        }
        
        return normalized;
    }
}
```

### 최적화된 저수준 구현

```csharp
// SIMD 및 병렬 처리 활용 (고성능 요구시)
public unsafe int[] CalculateHistogramOptimized(MyImage image)
{
    int[] histogram = new int[256];
    int size = image.Width * image.Height;
    
    // 병렬 처리를 위한 잠금 객체
    object[] locks = new object[256];
    for (int i = 0; i < 256; i++) locks[i] = new object();
    
    Parallel.For(0, size, i =>
    {
        byte value = image.Buffer[i];
        lock (locks[value])
        {
            histogram[value]++;
        }
    });
    
    return histogram;
}
```

---

## 기본 포인트 처리 연산

### 1. 영상 반전 (Inverse Transform)

#### 이론적 배경
영상 반전은 밝기 레벨을 반대로 뒤집는 연산으로, 의료 영상이나 특수한 시각화에 사용된다.

$$
g(x,y) = L - 1 - f(x,y)
$$

#### 구현

```csharp
public MyImage Inverse(MyImage src)
{
    MyImage dst = new MyImage(src.Width, src.Height);
    int size = src.Width * src.Height;
    
    // 룩업 테이블 사용 (성능 최적화)
    byte[] lookupTable = new byte[256];
    for (int i = 0; i < 256; i++)
    {
        lookupTable[i] = (byte)(255 - i);
    }
    
    for (int i = 0; i < size; i++)
    {
        dst.Buffer[i] = lookupTable[src.Buffer[i]];
    }
    
    return dst;
}
```

### 2. 밝기 조절 (Brightness Adjustment)

#### 이론적 배경

$$
g(x,y) = f(x,y) + k
$$

단, $$0 \leq g(x,y) \leq L-1$$ 범위를 유지해야 한다.

#### 고급 구현 (감마 보정과의 조합)

```csharp
public MyImage AdjustBrightness(MyImage src, int offset, bool useGamma = false, double gamma = 1.0)
{
    MyImage dst = new MyImage(src.Width, src.Height);
    
    // 룩업 테이블 생성
    byte[] lookupTable = new byte[256];
    for (int i = 0; i < 256; i++)
    {
        double value = i + offset;
        
        if (useGamma)
        {
            double normalized = Math.Clamp(value, 0, 255) / 255.0;
            value = Math.Pow(normalized, gamma) * 255.0;
        }
        
        lookupTable[i] = (byte)Math.Clamp(value, 0, 255);
    }
    
    // 영상에 적용
    int size = src.Width * src.Height;
    for (int i = 0; i < size; i++)
    {
        dst.Buffer[i] = lookupTable[src.Buffer[i]];
    }
    
    return dst;
}
```

### 3. 명암비 조절 (Contrast Scaling)

#### 이론적 배경

$$
g(x,y) = \alpha \cdot f(x,y) + \beta
$$

여기서:
- $$\alpha$$: 대비 조절 계수 ($$\alpha > 1$$: 대비 증가, $$0 < \alpha < 1$$: 대비 감소)
- $$\beta$$: 밝기 오프셋

#### 구현

```csharp
public MyImage AdjustContrast(MyImage src, double alpha, double beta = 0)
{
    MyImage dst = new MyImage(src.Width, src.Height);
    int size = src.Width * src.Height;
    
    // 평균 밝기 계산 (자동 밝기 보정을 위해)
    double mean = CalculateMeanBrightness(src);
    
    for (int i = 0; i < size; i++)
    {
        // 중앙 기반 대비 조절
        double value = (src.Buffer[i] - mean) * alpha + mean + beta;
        dst.Buffer[i] = (byte)Math.Clamp(value, 0, 255);
    }
    
    return dst;
}

private double CalculateMeanBrightness(MyImage image)
{
    long sum = 0;
    int size = image.Width * image.Height;
    
    for (int i = 0; i < size; i++)
    {
        sum += image.Buffer[i];
    }
    
    return (double)sum / size;
}
```

### 4. 감마 보정 (Gamma Correction)

#### 이론적 배경

감마 보정은 비선형 밝기 변환으로, 인간 시각의 비선형적 반응을 보상한다:

$$
s = c \cdot r^\gamma
$$

일반적으로 $$c = 1$$, $$r \in [0,1]$$로 정규화한다.

#### 감마 값에 따른 효과

| 감마 값 | 효과 | 적용 분야 |
|---------|------|-----------|
| $$\gamma < 1$$ | 어두운 영역 확장 | 의료 영상, 어두운 장면 |
| $$\gamma = 1$$ | 선형 변환 (변화 없음) | - |
| $$\gamma > 1$$ | 밝은 영역 확장 | 고대비 디스플레이 |

#### 구현

```csharp
public MyImage GammaCorrection(MyImage src, double gamma, double c = 1.0)
{
    MyImage dst = new MyImage(src.Width, src.Height);
    
    // 룩업 테이블 생성 (성능 최적화)
    byte[] lookupTable = new byte[256];
    for (int i = 0; i < 256; i++)
    {
        double r = i / 255.0;
        double s = c * Math.Pow(r, gamma);
        lookupTable[i] = (byte)(Math.Clamp(s, 0.0, 1.0) * 255.0);
    }
    
    // 영상에 적용
    int size = src.Width * src.Height;
    for (int i = 0; i < size; i++)
    {
        dst.Buffer[i] = lookupTable[src.Buffer[i]];
    }
    
    return dst;
}
```

---

## 히스토그램 기반 고급 기법

### 1. 히스토그램 평활화 (Histogram Equalization)

#### 이론적 배경

누적 분포 함수(CDF)는 다음과 같이 정의된다:

$$
T(r_k) = \sum_{j=0}^{k} p(r_j)
$$

이산 변환식은 다음과 같다:

$$
s_k = (L - 1) \cdot T(r_k)
$$

#### 처리 흐름 다이어그램

```
원본 영상
    │
    ▼
히스토그램 계산
    │
    ▼
PDF 계산 (정규화)
    │
    ▼
CDF 계산 (누적 분포)
    │
    ▼
매핑 함수 생성
    │
    ▼
픽셀 값 변환
    │
    ▼
평활화된 영상
```

#### 상세 구현

```csharp
public MyImage HistogramEqualization(MyImage src)
{
    // 1. 히스토그램 계산
    int[] hist = CalculateHistogram(src);
    int total = src.Width * src.Height;
    
    // 2. PDF 및 CDF 계산
    double[] pdf = new double[256];
    double[] cdf = new double[256];
    
    pdf[0] = (double)hist[0] / total;
    cdf[0] = pdf[0];
    
    for (int i = 1; i < 256; i++)
    {
        pdf[i] = (double)hist[i] / total;
        cdf[i] = cdf[i - 1] + pdf[i];
    }
    
    // 3. 매핑 테이블 생성
    byte[] mapping = new byte[256];
    for (int i = 0; i < 256; i++)
    {
        mapping[i] = (byte)Math.Round(cdf[i] * 255);
    }
    
    // 4. 영상 변환
    MyImage dst = new MyImage(src.Width, src.Height);
    int size = src.Width * src.Height;
    
    for (int i = 0; i < size; i++)
    {
        dst.Buffer[i] = mapping[src.Buffer[i]];
    }
    
    return dst;
}

// 적응형 히스토그램 평활화 (AHE)
public MyImage AdaptiveHistogramEqualization(MyImage src, int tileSize = 8)
{
    MyImage dst = new MyImage(src.Width, src.Height);
    
    int tilesX = (src.Width + tileSize - 1) / tileSize;
    int tilesY = (src.Height + tileSize - 1) / tileSize;
    
    // 각 타일에 대해 히스토그램 평활화 적용
    for (int ty = 0; ty < tilesY; ty++)
    {
        for (int tx = 0; tx < tilesX; tx++)
        {
            int startX = tx * tileSize;
            int startY = ty * tileSize;
            int endX = Math.Min(startX + tileSize, src.Width);
            int endY = Math.Min(startY + tileSize, src.Height);
            
            // 타일 영역 평활화
            ProcessTile(src, dst, startX, endX, startY, endY);
        }
    }
    
    return dst;
}
```

### 2. 히스토그램 스트레칭 (Histogram Stretching)

#### 이론적 배경

최소·최대 밝기 값을 $$r_{\min}, r_{\max}$$라 하면:

$$
g(x,y) = \frac{f(x,y) - r_{\min}}{r_{\max} - r_{\min}} \times (L - 1)
$$

#### 고급 구현 (클리핑 옵션 포함)

```csharp
public MyImage HistogramStretching(
    MyImage src, 
    double lowClip = 0.0, 
    double highClip = 0.0)
{
    // 1. 히스토그램 계산
    int[] hist = CalculateHistogram(src);
    int total = src.Width * src.Height;
    
    // 2. 클리핑을 고려한 최소/최대 값 계산
    int lowCount = (int)(total * lowClip);
    int highCount = (int)(total * highClip);
    
    byte rMin = 0, rMax = 255;
    
    // 낮은 값 클리핑
    int count = 0;
    for (int i = 0; i < 256; i++)
    {
        count += hist[i];
        if (count > lowCount)
        {
            rMin = (byte)i;
            break;
        }
    }
    
    // 높은 값 클리핑
    count = 0;
    for (int i = 255; i >= 0; i--)
    {
        count += hist[i];
        if (count > highCount)
        {
            rMax = (byte)i;
            break;
        }
    }
    
    // 스트레칭 방지 (거의 동일한 값일 경우)
    if (rMax - rMin < 10)
    {
        rMin = 0;
        rMax = 255;
    }
    
    // 3. 매핑 테이블 생성
    byte[] mapping = new byte[256];
    double scale = 255.0 / (rMax - rMin);
    
    for (int i = 0; i < 256; i++)
    {
        double value;
        if (i <= rMin)
            value = 0;
        else if (i >= rMax)
            value = 255;
        else
            value = (i - rMin) * scale;
        
        mapping[i] = (byte)Math.Clamp(value, 0, 255);
    }
    
    // 4. 영상 변환
    MyImage dst = new MyImage(src.Width, src.Height);
    int size = src.Width * src.Height;
    
    for (int i = 0; i < size; i++)
    {
        dst.Buffer[i] = mapping[src.Buffer[i]];
    }
    
    return dst;
}
```

### 3. 히스토그램 명세화 (Histogram Specification)

#### 이론적 배경
원하는 히스토그램 형태로 변환하는 기법으로, 평활화의 일반화된 형태이다.

```
원본 히스토그램 → 원본 CDF → 매핑 → 목표 CDF → 목표 히스토그램
```

#### 구현

```csharp
public MyImage HistogramSpecification(MyImage src, double[] targetHistogram)
{
    // 1. 원본 히스토그램 및 CDF 계산
    double[] srcCDF = CalculateCDF(src);
    
    // 2. 목표 히스토그램 정규화 및 CDF 계산
    double[] targetCDF = new double[256];
    targetCDF[0] = targetHistogram[0];
    
    for (int i = 1; i < 256; i++)
    {
        targetCDF[i] = targetCDF[i - 1] + targetHistogram[i];
    }
    
    // 3. 매핑 함수 생성 (CDF 매칭)
    byte[] mapping = new byte[256];
    for (int i = 0; i < 256; i++)
    {
        double srcCdfValue = srcCDF[i];
        
        // 목표 CDF에서 가장 가까운 값 찾기
        int bestMatch = 0;
        double minDiff = double.MaxValue;
        
        for (int j = 0; j < 256; j++)
        {
            double diff = Math.Abs(srcCdfValue - targetCDF[j]);
            if (diff < minDiff)
            {
                minDiff = diff;
                bestMatch = j;
            }
        }
        
        mapping[i] = (byte)bestMatch;
    }
    
    // 4. 영상 변환
    MyImage dst = new MyImage(src.Width, src.Height);
    int size = src.Width * src.Height;
    
    for (int i = 0; i < size; i++)
    {
        dst.Buffer[i] = mapping[src.Buffer[i]];
    }
    
    return dst;
}
```

---

## 성능 비교 및 최적화 기법

### 룩업 테이블(LUT) 최적화

```csharp
public class LookupTableProcessor
{
    private byte[] _lookupTable;
    
    public LookupTableProcessor(Func<byte, byte> mappingFunction)
    {
        _lookupTable = new byte[256];
        for (int i = 0; i < 256; i++)
        {
            _lookupTable[i] = mappingFunction((byte)i);
        }
    }
    
    public void Apply(MyImage src, MyImage dst)
    {
        int size = src.Width * src.Height;
        
        // 병렬 처리 적용
        Parallel.For(0, size, i =>
        {
            dst.Buffer[i] = _lookupTable[src.Buffer[i]];
        });
    }
}
```

### SIMD 최적화 (Vectorization)

```csharp
public unsafe void ApplyPointTransformSIMD(
    byte* srcBuffer, 
    byte* dstBuffer, 
    int size,
    Func<byte, byte> transform)
{
    int vectorSize = Vector<byte>.Count;
    int i = 0;
    
    for (; i <= size - vectorSize; i += vectorSize)
    {
        var vector = new Vector<byte>(srcBuffer + i);
        
        // 벡터 처리 (SIMD 연산)
        // 실제 구현에서는 벡터화된 변환 필요
    }
    
    // 나머지 처리
    for (; i < size; i++)
    {
        dstBuffer[i] = transform(srcBuffer[i]);
    }
}
```

---

## 화질 향상 기법 비교 및 선택 가이드

### 기법 선택 매트릭스

| 영상 특성 | 권장 기법 | 대체 기법 | 적용 팁 |
|-----------|-----------|-----------|---------|
| 저대비 영상 | 히스토그램 평활화 | 히스토그램 스트레칭 | 클리핑 파라미터 조정 |
| 어두운 영상 | 감마 보정 (γ<1) | 밝기 조절 | 감마 값 0.4~0.7 권장 |
| 너무 밝은 영상 | 감마 보정 (γ>1) | 대비 조절 | 감마 값 1.3~1.8 권장 |
| 노이즈 많은 영상 | CLAHE | 적응형 평활화 | 타일 크기와 클리핑 제한 중요 |
| 의료 영상 | 히스토그램 명세화 | 감마 보정 | 목표 분포 설정이 핵심 |

### 성능 비교 표

| 기법 | 시간 복잡도 | 메모리 사용 | 실시간 적용 | 품질 효과 |
|------|------------|-------------|-------------|-----------|
| 밝기 조절 | O(n) | O(1) | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 대비 조절 | O(n) | O(1) | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 감마 보정 | O(n) | O(L) | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 히스토그램 평활화 | O(n + L) | O(L) | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 히스토그램 스트레칭 | O(n + L) | O(L) | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| AHE | O(n × tiles) | O(L × tiles) | ⭐ | ⭐⭐⭐⭐⭐ |

---

## 실제 적용 사례 및 주의사항

### 의료 영상 처리

```csharp
public MyImage EnhanceMedicalImage(MyImage src)
{
    // 1. 히스토그램 분석
    double[] hist = CalculateNormalizedHistogram(src);
    
    // 2. 관심 영역(ROI) 강조를 위한 감마 보정
    MyImage gammaCorrected = GammaCorrection(src, 0.5);
    
    // 3. CLAHE 적용 (노이즈 증폭 방지)
    MyImage enhanced = AdaptiveHistogramEqualization(gammaCorrected, 16);
    
    // 4. 대비 약간 향상
    return AdjustContrast(enhanced, 1.2);
}
```

### 감시 영상 개선

```csharp
public MyImage EnhanceSurveillanceImage(MyImage src)
{
    // 야간/저조도 영상 개선 파이프라인
    MyImage result = src;
    
    // 1. 기본 밝기 향상
    result = AdjustBrightness(result, 30);
    
    // 2. 대비 향상 (과도하지 않게)
    result = AdjustContrast(result, 1.3);
    
    // 3. 히스토그램 스트레칭 (클리핑 적용)
    result = HistogramStretching(result, 0.01, 0.01);
    
    return result;
}
```

### 주의사항

1. **과적합 문제**: 지나친 화질 향상은 원본 정보 손실을 초래
2. **노이즈 증폭**: 히스토그램 평활화는 노이즈까지 증폭시킬 수 있음
3. **계산 비용**: 실시간 시스템에서는 알고리즘 선택에 유의
4. **매개변수 민감도**: 각 기법의 파라미터는 영상에 따라 최적화 필요

---

## 결론 및 향후 방향

### 핵심 정리

* 히스토그램은 화질 향상의 핵심 통계 도구로, 영상 특성 분석에 필수적
* 모든 포인트 처리 연산은 픽셀 단위의 독립적 변환으로 구현 가능
* CDF 기반 평활화는 전역 대비를 자동으로 조절하는 강력한 기법
* 실제 적용 시에는 계산 효율성과 품질 향상 간의 균형 고려 필요

### 구현 패턴

```csharp
// 일반적인 화질 향상 파이프라인 패턴
public MyImage StandardEnhancementPipeline(MyImage src)
{
    // 1. 전처리 (노이즈 제거 등)
    MyImage preprocessed = Preprocess(src);
    
    // 2. 기본 화질 향상
    MyImage enhanced = ApplyBasicEnhancement(preprocessed);
    
    // 3. 히스토그램 기반 최적화
    enhanced = ApplyHistogramOptimization(enhanced);
    
    // 4. 후처리 (예: 선명화)
    return Postprocess(enhanced);
}
```

### 향후 발전 방향

1. **딥러닝 기반 화질 향상**: 신경망을 이용한 자동 파라미터 튜닝
2. **지능형 적응형 처리**: 영상 내용 인식 기반 자동 기법 선택
3. **실시간 최적화**: 하드웨어 가속(GPU, FPGA) 활용
4. **주관적 품질 평가**: 인간 시각 특성 반영한 평가 지표 개발

이 장을 통해 **픽셀 포인트 처리의 수학적 기반과 효율적인 구현 기법**을 습득하였으며, 다양한 실제 응용에 적용할 수 있는 기본 틀을 마련하였다. 화질 향상은 단순한 기술이 아닌, 영상의 내용과 목적에 맞춘 예술적 판단이 요구되는 분야임을 인식해야 한다.