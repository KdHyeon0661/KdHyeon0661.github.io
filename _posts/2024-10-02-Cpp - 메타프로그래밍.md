---
layout: post
title: C++ - 메타프로그래밍
date: 2024-10-02 19:20:23 +0900
category: Cpp
---
# C++ 타입 추론과 메타프로그래밍 기초

현대 C++의 강점은 **컴파일 타임에 타입을 다루고 계산**하는 능력입니다.
이 글은 `auto`, `decltype`, `decltype(auto)` 같은 **타입 추론 키워드**부터, `<type_traits>`, `constexpr`, `if constexpr`, `SFINAE`, `concepts`까지 **메타프로그래밍의 필수 바닥재**를 예제와 함께 정리합니다.
단순 사용법을 넘어서 “왜 이렇게 동작하는지”를 짚고, 실수 포인트까지 정리합니다.

---

## 요약

- **타입 추론**: `auto`(값/템플릿 추론 규칙), `decltype`(표현식 기반 정확 추론), `decltype(auto)`(참조성/값성 **그대로** 유지)
- **타입 조작**: `<type_traits>`의 `*_t`, `*_v` 별칭과 `remove_cvref_t`, `invoke_result_t`, `is_invocable_v`
- **컴파일 타임 계산**: `constexpr`/`consteval`/`constinit`, `if constexpr`, `std::integer_sequence`
- **선택적 오버로드**: `enable_if`, `void_t`, detection idiom → C++20 `concepts`/`requires`로 정리
- **주의점**: `auto`와 템플릿 추론의 차이, `decltype((x))` vs `decltype(x)`, 초기화 문법(`=`/`{}`)의 의미 차이

---

## 타입 추론: `auto`의 정확한 규칙

### 기본 사용

```cpp
#include <vector>
#include <string>

auto x = 10;              // int
auto y = 3.14;            // double
auto s = std::string("hi"); // std::string

std::vector<int> v = {1,2,3};
auto it = v.begin();      // 복잡한 반복자 타입을 간결하게
```

### `auto`와 참조/포인터

```cpp
int n = 5;
int& r = n;
const int& cr = n;

auto a  = r;   // int  (참조 속성 삭제)
auto b  = cr;  // int  (const, ref 제거)
auto& c = cr;  // const int&  (참조로 받으면 const 유지)
auto* p = &n;  // int*
```

> **핵심**: `auto`는 템플릿 타입 추론과 동일 규칙. **기본적으로 cv/ref 제거**.
> 참조로 받고 싶으면 `auto&`, 상수 참조로 받고 싶으면 `const auto&`, 이동 가능한 참조 범용으로 받고 싶으면 `auto&&`.

### 초기화 문법 차이 (중요)

```cpp
auto a = 1;          // int
auto b(1);           // int
auto c = {1};        // std::initializer_list<int>
auto d{1};           // int (C++11 모호성 → C++14/17에서 규정: 단일 요소는 int)
```

- `auto x = {1,2,3};` 은 `std::initializer_list<int>`로만 추론 가능.
- **개발 팁**: 다요소 중괄호 초기화는 `initializer_list`가 의도인지 확인.

### 범용 람다 파라미터(C++14): “템플릿 없는 템플릿”

```cpp
auto f = [](auto&& t) { return t + t; }; // T 완전 추론
static_assert(std::is_same_v<decltype(f(1)), int>);
```

---

## `decltype`: 표현식 기반 정밀 추론

### 기본

```cpp
int i = 0;
decltype(i) a = 1;          // int
decltype((i)) b = a;        // int&  (주의: 괄호가 참조성을 만든다)
```

- **규칙**:
  - `decltype(id)`는 **id의 선언 타입을 그대로** 가져온다. (참조면 참조)
  - `decltype((expr))`는 lvalue면 `T&`, xvalue면 `T&&`, prvalue면 `T`.

```cpp
int x = 0;
decltype(x)    t1 = x;      // int
decltype((x))  t2 = x;      // int&  ← 괄호로 lvalue 표현식
decltype(0)    t3 = 0;      // int
```

### `std::declval`과 조합: 의존 표현식의 타입 구하기

```cpp
#include <utility>
#include <type_traits>

template <class T, class U>
using plus_result_t = decltype(std::declval<T>() + std::declval<U>());

static_assert(std::is_same_v<plus_result_t<int,double>, double>);
```

### 후행 반환 타입과 `decltype`

```cpp
template <class It>
auto distance(It first, It last) -> decltype(last - first) {
    return last - first;
}
```

---

## `decltype(auto)`: 값/참조/const **그대로** 반환

```cpp
int x = 42;
int& rx = x;

auto g1() { return (rx); }         // int   (auto는 참조를 지움)
decltype(auto) g2() { return (rx);} // int& (그대로)
decltype(auto) g3() { return rx; }  // int& (동일)
```

- **반환에서 필수**: API가 참조를 유지해야 할 때 `decltype(auto)` 사용.
- **주의**: 지역 변수의 참조를 반환하지 않도록 생명주기 주의.

---

## `<type_traits>` 핵심 20선

C++17 이후로는 `_t`, `_v` 별칭을 적극 사용하세요.

| 분류 | 예시 | 설명 |
|---|---|---|
| 판별 | `is_integral_v<T>` | 정수 타입인가 |
| 판별 | `is_floating_point_v<T>` | 부동소수점인가 |
| 판별 | `is_pointer_v<T>`, `is_reference_v<T>` | 포인터/참조인가 |
| 판별 | `is_const_v<T>`, `is_volatile_v<T>` | cv 한정자 |
| 판별 | `is_same_v<T,U>` | 동일 타입인가 |
| 판별 | `is_array_v<T>` | 배열인가 |
| 호출성 | `is_invocable_v<F, Args...>` | 호출 가능? |
| 결과 | `invoke_result_t<F, Args...>` | 호출 결과 타입 |
| 변경 | `remove_reference_t<T>` | 참조 제거 |
| 변경 | `remove_cv_t<T>`, `remove_cvref_t<T>`(C++20) | cv 및 ref 제거 |
| 변경 | `add_pointer_t<T>`, `add_lvalue_reference_t<T>` | 포인터/참조 추가 |
| 상수 | `integral_constant`, `bool_constant<true>` | 타입 레벨 상수 |
| 조건 | `conditional_t<cond, T, U>` | 삼항연산자 at type level |
| enable | `enable_if_t<cond, T>` | 조건부 활성화(SFINAE) |
| 탐지 | `void_t<...>` | detection idiom 도우미 |

### detection idiom (C++17)

```cpp
template <class, class = void>
struct has_push_back : std::false_type {};

template <class T>
struct has_push_back<T, std::void_t<decltype(std::declval<T&>().push_back(0))>>
  : std::true_type {};

static_assert(has_push_back<std::vector<int>>::value);
static_assert(!has_push_back<int>::value);
```

C++20에서는 **concepts**로 더 깔끔해집니다(§9).

---

## `constexpr` / `consteval` / `constinit`

### `constexpr`: **컴파일 타임에도** 평가 가능

```cpp
constexpr int square(int x) { return x * x; }
static_assert(square(5) == 25);

int a[square(3)]; // OK: 정적 배열 크기
```

- C++14부터 `constexpr` 함수 내 문장 대부분 허용, C++20은 더 강화.

### `consteval`(C++20): **항상** 컴파일 타임

```cpp
consteval int twice(int x) { return 2*x; }
// twice(입력)은 반드시 컴파일 타임 상수여야 함
```

### `constinit`(C++20): 정적 저장수명의 **정확 초기화** 보장

```cpp
constinit int g = 42; // 정적 초기화 보장
```

---

## 메타프로그래밍: 템플릿 재귀 vs `if constexpr`

### 템플릿 재귀 예시(팩토리얼)

$$
\mathrm{Factorial}(N) = \prod_{k=1}^{N} k
$$

```cpp
template <int N>
struct Factorial { static constexpr int value = N * Factorial<N-1>::value; };

template <> struct Factorial<0> { static constexpr int value = 1; };

static_assert(Factorial<5>::value == 120);
```

### `constexpr` + `if constexpr` (C++17)

```cpp
constexpr int factorial(int n) {
    int r = 1;
    for (int i=2; i<=n; ++i) r*=i;
    return r;
}

template <class T>
auto twice_or_concat(T&& t) {
    if constexpr (std::is_arithmetic_v<std::decay_t<T>>) {
        return t + t;             // 수치형 덧셈
    } else {
        return std::decay_t<T>(t) + std::decay_t<T>(t); // 문자열 등
    }
}
```

### 태그 디스패치(tag dispatch)와 비교

`if constexpr`은 **컴파일 시 제거**되므로 태그 디스패치보다 간결하고 최적화가 쉬운 경우가 많습니다.

---

## `std::integer_sequence`, 튜플 언패킹

### 인덱스 시퀀스 생성

```cpp
#include <utility>

template <class F, class Tuple, std::size_t... I>
decltype(auto) apply_impl(F&& f, Tuple&& t, std::index_sequence<I...>) {
    return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...);
}

template <class F, class Tuple>
decltype(auto) apply_like_std(F&& f, Tuple&& t) {
    constexpr auto N = std::tuple_size_v<std::decay_t<Tuple>>;
    return apply_impl(std::forward<F>(f), std::forward<Tuple>(t),
                      std::make_index_sequence<N>{});
}
```

> 실제로는 `std::apply`가 존재. 위 코드는 내부 메커니즘 학습용.

---

## 레퍼런스 붕괴(Reference collapsing)와 전달 참조

### 붕괴 규칙

| 조합 | 결과 |
|---|---|
| `T&  &` | `T&` |
| `T&  &&`| `T&` |
| `T&& &` | `T&` |
| `T&& &&`| `T&&` |

### 전달 참조(Forwarding reference)

```cpp
#include <utility>

template <class T, class... Args>
T make_with(T&& seed, Args&&... args) {
    return T(std::forward<T>(seed), std::forward<Args>(args)...);
}
```

- 함수 템플릿에서 `T&&`는 **전달 참조**로 동작(인수에 따라 l/r-value 유지).
- `std::forward`로 **값 범주 보존**.

### `remove_cvref_t`(C++20)

```cpp
template <class T>
using bare_t = std::remove_cvref_t<T>;
```

---

## SFINAE → Concepts (C++20)

### `enable_if` 기반 선택

```cpp
#include <type_traits>

template <class T, std::enable_if_t<std::is_integral_v<T>, int> = 0>
T inc(T x) { return x + 1; }
```

### `void_t` 기반 탐지

```cpp
template <class, class = void> struct has_size : std::false_type {};
template <class T>
struct has_size<T, std::void_t<decltype(std::declval<T&>().size())>> : std::true_type {};
```

### Concepts

```cpp
template <class T>
concept SizedLike = requires(T t) {
    { t.size() } -> std::convertible_to<std::size_t>;
};

template <SizedLike T>
auto first_or_default(const T& t) {
    if (t.size()) return t[0];
    using value_type = std::remove_reference_t<decltype(t[0])>;
    return value_type{};
}
```

- **장점**: 가독성, 에러 메시지 품질, 의도 표현력이 훨씬 좋아짐.

---

## `std::function` vs 템플릿 호출자

```cpp
#include <functional>

template <class F>
auto map_auto(F&& f) {
    return [f = std::forward<F>(f)](auto&& x) {
        return f(std::forward<decltype(x)>(x));
    };
}

int main() {
    auto twice = map_auto([](int x){ return x*2; });
    static_assert(std::is_same_v<decltype(twice(3)), int>);

    std::function<int(int)> g = twice; // type erasure 발생 (약간의 비용)
}
```

- **템플릿 호출자**는 **인라인/최적화 여지**가 더 크고, `std::function`은 **타입 소거 비용**이 있음.
- 라이브러리 경계에서는 `std::function`이 편리, 핫패스에서는 템플릿이 유리.

---

## SFINAE 없는 오버로드 해석 트릭: `if constexpr`

```cpp
template <class T>
auto abs_like(T x) {
    if constexpr (std::is_signed_v<T>) {
        return x < 0 ? -x : x;
    } else {
        return x; // 부호 없는 타입
    }
}
```

- 간단한 조건 분기엔 `if constexpr`이 **가장 읽기 쉽고 오류 적음**.

---

## 실전 예제 모음

### 안전한 컨테이너-혹은-스칼라 합치기

```cpp
#include <type_traits>
#include <vector>
#include <string>

template <class T>
auto add_two(T&& x) {
    using U = std::remove_cvref_t<T>;
    if constexpr (std::is_arithmetic_v<U>) {
        return x + x;
    } else if constexpr (requires(U u){ u.push_back(u.front()); }) { // concepts-like
        U y = x;
        y.insert(y.end(), x.begin(), x.end());
        return y;
    } else {
        return std::string("unsupported");
    }
}

int main(){
    auto a = add_two(3);                        // 6
    std::vector<int> v = {1,2,3};
    auto b = add_two(v);                        // {1,2,3,1,2,3}
    auto c = add_two(std::string("x"));         // "unsupported"
}
```

### `decltype(auto)` 반환 API

```cpp
#include <vector>

template <class V>
decltype(auto) front_ref(V&& v) {
    return (v.front()); // 참조 그대로 내보냄
}

int main() {
    std::vector<int> v{10};
    static_assert(std::is_lvalue_reference_v<decltype(front_ref(v))>);
}
```

### 컴파일타임 튜플 맵

```cpp
#include <tuple>
#include <utility>

template <class F, class Tuple, std::size_t... I>
auto tuple_map_impl(F&& f, Tuple&& t, std::index_sequence<I...>) {
    return std::make_tuple(f(std::get<I>(t))...);
}
template <class F, class Tuple>
auto tuple_map(F&& f, Tuple&& t) {
    constexpr auto N = std::tuple_size_v<std::remove_reference_t<Tuple>>;
    return tuple_map_impl(std::forward<F>(f), std::forward<Tuple>(t), std::make_index_sequence<N>{});
}

int main(){
    auto t = std::make_tuple(1, 2.5, 3);
    auto r = tuple_map([](auto x){ return x+x; }, t); // (2, 5.0, 6)
}
```

---

## 주의할 함정과 체크리스트

1. **`decltype((x))` vs `decltype(x)`**: 괄호가 **참조**를 만든다.
2. **`auto`는 cv/ref 제거**: 참조/const 유지하려면 `auto&`, `const auto&`, `auto&&` 사용.
3. **중괄호 초기화**: `auto x = {1,2}` 는 `initializer_list<int>` 추론.
4. **`decltype(auto)` 반환**: 로컬 변수 생명주기 주의(댕글링 참조 금지).
5. **`std::function` 비용**: 성능 민감 경로에서는 템플릿 호출자/람다 유지.
6. **`enable_if` 난독화**: 가능하면 C++20 `concepts`로 명세화.
7. **`constexpr`는 “가능”이지 “항상”은 아님**: 입력이 상수식이어야 컴파일타임 평가.
8. **이동이 `noexcept`이면 컨테이너 최적화**: 사용자 타입 이동 생성/대입에 `noexcept`.
9. **레이스/UB는 컴파일타임이 막아주지 않음**: 메타프로그래밍은 타입·형식적 안정성, 동시성은 별도 문제.

---

## 연습 문제 (간단)

1. `sum_like(t)`를 작성: 산술형이면 합을, `std::string`이면 이어 붙이기, `std::vector<T>`면 벡터 이어붙이기.
   `if constexpr` + `requires`를 사용.
2. `callable_result_t<F, Args...>` 별칭 템플릿 작성(`invoke_result_t` 재현).
3. `first_or_zero(c)` 작성: `c.size()>0`면 `c[0]`, 아니면 값-초기화된 `value_type{}` 반환. `concepts` 사용.

---

## 마무리

- `auto`/`decltype`/`decltype(auto)`의 **정확한 규칙**을 이해하면 **참조/const 보존**과 **인터페이스 설계**가 안정적입니다.
- `<type_traits>`와 `constexpr`/`if constexpr`은 **런타임 분기 코드를 컴파일 타임에 옮겨** 안전성과 성능을 동시에 강화합니다.
- C++20 `concepts`는 **의도 중심의 타입 제약**을 제공해 SFINAE의 난해함을 크게 줄입니다.

현대 C++의 타입·메타 도구들은 “어렵다”보다 “강력하다”에 가깝습니다.
작은 실험을 반복해 **규칙을 몸에 익히면**, 템플릿과 제네릭 코드의 가독성과 성능은 눈에 띄게 개선됩니다.
