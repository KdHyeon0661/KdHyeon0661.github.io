---
layout: post
title: 네트워크보안 - 컨테이너·쿠버네티스 네트워킹
date: 2025-10-27 19:25:23 +0900
category: 네트워크보안
---
# 컨테이너·쿠버네티스 네트워킹

> 목표: **CNI/Service/Ingress**에서 시작해 **네임스페이스 격리**, **네트워크 폴리시**(기본 거부·세밀 허용),
> **서비스 메시(mTLS·권한정책)**, **eBPF 데이터패스(XDP)/Cilium**까지 실무적으로 묶는다.
> 마지막으로 **L3/L4/L7 정책 설계**를 랩 시나리오로 완성한다.
> (벤더/배포판·클러스터 버전에 따라 API/옵션이 조금 다를 수 있다.)

---

## CNI / Service / Ingress, 네임스페이스

### CNI 개념 요약

- **CNI**: Pod 네트워킹을 담당하는 플러그인(예: **Calico, Cilium, Flannel, Weave** …)
- 핵심 책임
  - Pod에 **IP 부여**(일반적으로 “**Pod당 1 IP**”)
  - 노드 간 **라우팅/캡슐화** (BGP, VXLAN, Geneve 등)
  - (선택) **NetworkPolicy** 데이터플레인 구현(L3/L4/L7)
- 일반적 패턴
  - **Kubernetes Service**는 **VIP/가상 IP**를 부여, kube-proxy(eBPF/iptables/ipvs)나 Cilium eBPF가 로드밸런싱
  - **Ingress**/Gateway는 **L7** 라우팅·TLS 종료

> 운영 포인트: **CNI 선택 = 기능/성능/운영성 트레이드오프**. eBPF 기반(Cilium)은 고성능/풍부한 관측,
> Calico는 범용·BGP 네이티브, Flannel은 단순.

---

### Service 유형

- **ClusterIP**: 클러스터 내부 가상 IP(기본). Pod→Service 로드밸런싱.
- **NodePort**: 모든 노드의 고정 포트(예: 30000~32767) 노출.
- **LoadBalancer**: 클라우드 LB 연동(외부 VIP).
- **Headless**(`clusterIP: None`): Service DNS가 **Pod IP 목록**을 직접 응답(stateful/클라이언트 사이드 LB에 적합).

**예: web 서비스**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: web
  namespace: shop
spec:
  selector:
    app: web
  ports:
  - name: http
    port: 80        # Service Port
    targetPort: 8080 # Pod Container Port
  type: ClusterIP
```

---

### Ingress & Gateway API

- **Ingress**: L7 경로/호스트 기반 라우팅. 컨트롤러(nginx, HAProxy, Traefik, AWS ALB 등)에 의존.
- **Gateway API**: 차세대 표준(HTTPRoute, Gateway, ReferenceGrant …), 멀티-리소스 구조.

**Ingress 예: NGINX**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-ing
  namespace: shop
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  ingressClassName: nginx
  tls:
  - hosts: [ "shop.example.com" ]
    secretName: shop-tls
  rules:
  - host: shop.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web
            port:
              number: 80
```

**Gateway API 예(요지)**
```yaml
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata: { name: edge, namespace: infra }
spec:
  gatewayClassName: nginx
  listeners:
  - name: https
    protocol: HTTPS
    port: 443
    tls:
      mode: Terminate
      certificateRefs:
      - name: edge-cert
---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata: { name: shop-route, namespace: shop }
spec:
  parentRefs:
  - name: edge
    namespace: infra
  hostnames: [ "shop.example.com" ]
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /
    backendRefs:
    - name: web
      port: 80
```

---

### 네임스페이스 격리

- **네임스페이스** 단위로 정책/리소스쿼터/인증·인가 경계 구성.
- **NetworkPolicy** 및 **LimitRange**, **RBAC**를 네임스페이스 단위로 적용.

```bash
kubectl create ns shop
kubectl label ns shop security=restricted
```

---

## 네트워크 폴리시, 서비스 메시(mTLS)

### NetworkPolicy 기본(표준 KNP)

- 기본 동작: 정책이 **하나도 없으면 모든 트래픽 허용**.
- **Default Deny**를 만들려면 **빈 `ingress: []` 또는 `egress: []`** 정책을 네임스페이스에 적용.
- L3/L4(아이피/포트 기준). L7은 벤더 확장(Cilium/Calico Enterprise 등) 또는 메시로.

**Default Deny (shop ns)**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: shop
spec:
  podSelector: {}
  policyTypes: [ Ingress, Egress ]
```

**web↔api 허용 (shop ns)**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: web-to-api
  namespace: shop
spec:
  podSelector:
    matchLabels: { app: api }
  policyTypes: [ Ingress ]
  ingress:
  - from:
    - podSelector:
        matchLabels: { app: web }
    ports:
    - protocol: TCP
      port: 8080
```

**api→db egress 제한**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-egress-db
  namespace: shop
spec:
  podSelector:
    matchLabels: { app: api }
  policyTypes: [ Egress ]
  egress:
  - to:
    - podSelector: { matchLabels: { app: mysql } }
    ports:
    - protocol: TCP
      port: 3306
```

---

### 핵심

- **mTLS**: Pod↔Pod 통신 **자동 암호화** + **신원(Spiffe/SVID)** 부여.
- **정책**: **AuthorizationPolicy**(Istio)로 **서비스·경로·메서드 단위** 허용.
- **관측**: 요청/지연/오류율, 분산 트레이싱.

**Istio mTLS 강제**
```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata: { name: default, namespace: shop }
spec:
  mtls:
    mode: STRICT
```

**Istio 인가 정책 (web만 api 호출 허용)**
```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata: { name: api-allow-web, namespace: shop }
spec:
  selector:
    matchLabels: { app: api }
  rules:
  - from:
    - source:
        principals: ["spiffe://cluster.local/ns/shop/sa/web-sa"]
    to:
    - operation:
        methods: ["GET","POST"]
        paths: ["/v1/*"]
```

> 팁: 서비스 메시를 쓰면 **L3/L4는 NetworkPolicy**, **L7은 메시 인가**로 역할 분리하기 좋다.

---

## eBPF 데이터패스(XDP)/Cilium

### eBPF/XDP 개요

- **eBPF**: 커널 공간에서 안전하게 실행되는 바이트코드(후킹 포인트: tc, XDP, kprobe 등).
- **XDP**: NIC RX 직후 단계에서 패킷 처리(드롭·리다이렉트) → 초고성능 필터링·L4 LB 가능.
- **쿠버네티스**: **Cilium**이 eBPF를 사용해 kube-proxy 없이 **서비스 LB/네트폴/L7** 구현, **Hubble**로 관측.

### Cilium 설치(개념)

```bash
cilium install --version <stable>
cilium status
```

**kube-proxy 제거(선택)**: Cilium **kube-proxy replacement** 모드 사용 가능(클러스터 조건 확인).

### CiliumNetworkPolicy(L7까지)

- Cilium은 **HTTP/GPRC/DNS** 레벨 L7 정책을 지원하고, **FQDN 정책**(DNS 캐시 기반)도 가능.

**예: web→api HTTP 메서드 제한 & Host 제한**
```yaml
apiVersion: "cilium.io/v2"
kind: CiliumNetworkPolicy
metadata:
  name: web-to-api-l7
  namespace: shop
spec:
  endpointSelector:
    matchLabels: { app: web }
  egress:
  - toEndpoints:
    - matchLabels: { app: api }
    toPorts:
    - ports: [{ port: "8080", protocol: TCP }]
      rules:
        http:
        - method: "GET"
          path: "^/v1/catalog"
        - method: "POST"
          path: "^/v1/order"
```

**FQDN egress 제한(외부 API만)**
```yaml
apiVersion: "cilium.io/v2"
kind: CiliumNetworkPolicy
metadata:
  name: web-egress-fqdn
  namespace: shop
spec:
  endpointSelector:
    matchLabels: { app: web }
  egress:
  - toFQDNs:
    - matchName: "api.payment.example.com"
  - toPorts:
    - ports: [{ port: "443", protocol: TCP }]
```

### Hubble로 흐름 가시화

```bash
cilium hubble enable
hubble status
hubble ui
# 또는 CLI

hubble observe --namespace shop --follow --protocol http
```

---

### XDP 학습용 드롭 예제

> 운영은 Cilium 정책으로 충분. XDP는 **학습/특수 고성능**에서만.

```c
// xdp_drop_redis.c: dst port 6379 드롭(학습)
#include <linux/bpf.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <linux/tcp.h>

SEC("xdp")
int xdp_prog(struct xdp_md *ctx){
  void* data=(void*)(long)ctx->data;
  void* end =(void*)(long)ctx->data_end;
  struct ethhdr* eth=data;
  if((void*)eth+sizeof(*eth)>end) return XDP_PASS;
  if(eth->h_proto!=__constant_htons(ETH_P_IP)) return XDP_PASS;
  struct iphdr* iph=(void*)eth+sizeof(*eth);
  if((void*)iph+sizeof(*iph)>end||iph->protocol!=IPPROTO_TCP) return XDP_PASS;
  struct tcphdr* th=(void*)iph+iph->ihl*4;
  if((void*)th+sizeof(*th)>end) return XDP_PASS;
  if(th->dest==__constant_htons(6379)) return XDP_DROP;
  return XDP_PASS;
}
char _license[] SEC("license")="GPL";
```

빌드/적용(학습):
```bash
clang -O2 -target bpf -c xdp_drop_redis.c -o xdp_drop_redis.o
sudo ip link set dev eth0 xdp obj xdp_drop_redis.o sec xdp
```

---

## 실습: L3/L4/L7 정책 설계

> 시나리오
> 네임스페이스 `shop`에 **web/api/mysql/ingress**가 있다. 목표는 **기본 거부**,
> **web→api(HTTP 특정 경로/메서드)**, **api→mysql(3306)**만 허용하고, 외부 egress는
> **결제 API(FQDN)**만, 나머지는 차단한다. 서비스 메시(옵션)를 사용하면 **mTLS + L7 인가**를 강화한다.

### 배포 리소스(샘플 앱)

```yaml
apiVersion: v1
kind: Namespace
metadata: { name: shop }

---
apiVersion: apps/v1
kind: Deployment
metadata: { name: web, namespace: shop }
spec:
  replicas: 2
  selector: { matchLabels: { app: web } }
  template:
    metadata: { labels: { app: web } }
    spec:
      serviceAccountName: web-sa
      containers:
      - name: web
        image: ghcr.io/nginxdemos/hello:plain-text
        ports: [{ containerPort: 8080, name: http }]
---
apiVersion: v1
kind: Service
metadata: { name: web, namespace: shop }
spec:
  selector: { app: web }
  ports:
  - port: 80
    targetPort: http

---
apiVersion: apps/v1
kind: Deployment
metadata: { name: api, namespace: shop }
spec:
  replicas: 2
  selector: { matchLabels: { app: api } }
  template:
    metadata: { labels: { app: api } }
    spec:
      serviceAccountName: api-sa
      containers:
      - name: api
        image: docker.io/hashicorp/http-echo:0.2.3
        args: ["-text=ok"]
        ports: [{ containerPort: 8080, name: http }]
---
apiVersion: v1
kind: Service
metadata: { name: api, namespace: shop }
spec:
  selector: { app: api }
  ports:
  - port: 8080
    targetPort: http

---
apiVersion: apps/v1
kind: Deployment
metadata: { name: mysql, namespace: shop }
spec:
  selector: { matchLabels: { app: mysql } }
  template:
    metadata: { labels: { app: mysql } }
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - { name: MYSQL_ROOT_PASSWORD, value: "rootpw" }
        ports: [{ containerPort: 3306, name: mysql }]
---
apiVersion: v1
kind: Service
metadata: { name: mysql, namespace: shop }
spec:
  selector: { app: mysql }
  ports:
  - port: 3306
    targetPort: mysql
```

---

### 기본 거부(네임스페이스)

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny
  namespace: shop
spec:
  podSelector: {}
  policyTypes: [Ingress, Egress]
```

---

### L3/L4 허용(표준 KNP)

**web → api: 8080/TCP**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-web-to-api
  namespace: shop
spec:
  podSelector: { matchLabels: { app: api } }
  policyTypes: [ Ingress ]
  ingress:
  - from:
    - podSelector: { matchLabels: { app: web } }
    ports: [{ protocol: TCP, port: 8080 }]
```

**api → mysql: 3306/TCP**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-api-egress-mysql
  namespace: shop
spec:
  podSelector: { matchLabels: { app: api } }
  policyTypes: [ Egress ]
  egress:
  - to:
    - podSelector: { matchLabels: { app: mysql } }
    ports: [{ protocol: TCP, port: 3306 }]
```

**DNS 허용(코어DNS로 egress)**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: shop
spec:
  podSelector: {}
  policyTypes: [ Egress ]
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
      podSelector:
        matchLabels: { k8s-app: kube-dns }
    ports:
    - { protocol: UDP, port: 53 }
    - { protocol: TCP, port: 53 }
```

> 표준 KNP만으로는 **외부 FQDN 제한(L7)**이 어려움 → Cilium L7 또는 서비스 메시로 보완.

---

### Cilium L7 정책(선택)

**web → api: L7 경로/메서드 제한**
```yaml
apiVersion: "cilium.io/v2"
kind: CiliumNetworkPolicy
metadata: { name: web-to-api-l7, namespace: shop }
spec:
  endpointSelector: { matchLabels: { app: web } }
  egress:
  - toEndpoints:
    - matchLabels: { app: api }
    toPorts:
    - ports: [{ port: "8080", protocol: TCP }]
      rules:
        http:
        - method: "GET"
          path: "^/v1/catalog"
        - method: "POST"
          path: "^/v1/order"
```

**web 외부 egress: 결제 API만 허용**
```yaml
apiVersion: "cilium.io/v2"
kind: CiliumNetworkPolicy
metadata: { name: web-egress-payment, namespace: shop }
spec:
  endpointSelector: { matchLabels: { app: web } }
  egress:
  - toFQDNs:
    - matchName: "api.payment.example.com"
  - toPorts:
    - ports: [{ port: "443", protocol: TCP }]
```

---

### 서비스 메시 옵션(Istio)

**mTLS 강제**
```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata: { name: default, namespace: shop }
spec:
  mtls: { mode: STRICT }
```

**web → api L7 인가**
```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata: { name: api-allow, namespace: shop }
spec:
  selector: { matchLabels: { app: api } }
  rules:
  - from:
    - source:
        principals: ["spiffe://cluster.local/ns/shop/sa/web-sa"]
    to:
    - operation:
        methods: ["GET","POST"]
        paths: ["/v1/catalog","/v1/order"]
```

**외부 egress 제한 (Istio egress + egress GW 패턴)**
- mesh 외부로는 **Egress Gateway** 통해서만, `api.payment.example.com`만 허용.
- (구현은 Istio VirtualService/DestinationRule/EgressGateway 리소스로 수행)

---

### 검증 시나리오

**1) 기본 접속 확인**
```bash
# 포드 IP/Service 확인

kubectl -n shop get pods -owide
kubectl -n shop get svc

# netshoot로 내부 테스트

kubectl -n shop run tmp --rm -it --image=nicolaka/netshoot -- bash
curl -s web.shop.svc.cluster.local
curl -s api.shop.svc.cluster.local:8080
```

**2) 정책 적용 전후**
- `default-deny` 적용 전: 아무 제약 없음 → web에서 mysql로도 접근 가능해야 함(서비스 없으면 실패)
- 적용 후: 정의하지 않은 경로/포트는 **DROP**(연결 지연/실패)

**3) L7 제한 확인(Cilium 또는 Istio)**
```bash
# 허용된 경로

curl -s api.shop.svc.cluster.local:8080/v1/catalog
# 차단될 경로

curl -s api.shop.svc.cluster.local:8080/admin  # 403 또는 정책 Drop
```

**4) 외부 egress(결제 API만)**
```bash
# 허용 FQDN

curl -I https://api.payment.example.com/health
# 금지 예

curl -I https://www.google.com   # 차단 기대
```

**5) 관측(Hubble/Istio)**
```bash
# Hubble(L3/L4/L7 흐름)

hubble observe --namespace shop --follow

# Istio(텔레메트리/로그)

kubectl -n istio-system logs deploy/istiod | tail
```

---

### 운영 체크리스트

**정책·구성**
- [ ] **기본 거부(Default Deny)** 네임스페이스 단위 적용
- [ ] 서비스 간 **허용 목록(Allow-list)**: web→api, api→db 등 **5-tuple 최소화**
- [ ] 외부 egress는 **FQDN/도메인** 기준으로 최소 허용(Cilium FQDN, egress GW)
- [ ] **Ingress/Gateway**는 TLS 필수, 보안헤더/HSTS, 라우팅 화이트리스트
- [ ] **헤드리스 Service** 사용 시 클라이언트사이드 LB 영향 고려

**관측·로깅**
- [ ] **Hubble/OTel/여행시간 지표**로 경계/드롭/재시도 확인
- [ ] **정책 히트/드롭 이유** 대시보드화(팀 공유)
- [ ] CI에 **정책 회귀 테스트**(허용/거부 케이스) 포함

**변경/릴리즈**
- [ ] GitOps(리뷰·승인)로 NetworkPolicy/Ingress/Gateway 변경
- [ ] 카나리/블루그린로 정책 적용 리스크 최소화
- [ ] 네임스페이스/레이블 **정책-의존성 문서화**

**보안 연계**
- [ ] 서비스 메시 **mTLS** 기본값(STRICT)
- [ ] 비밀/인증서 롤링 자동화(KMS/외부 CA)
- [ ] **노드 보안**: 커널/eBPF/컨테이너 런타임 패치/하드닝

---

## 부록 A. Calico 네트워크 정책(L7 없이 L3/L4 중심)

```yaml
apiVersion: projectcalico.org/v3
kind: NetworkPolicy
metadata:
  name: app-db
  namespace: shop
spec:
  selector: app == 'api'
  ingress:
  - action: Allow
    source:
      selector: app == 'web'
    protocol: TCP
    destination:
      ports: [8080]
  egress:
  - action: Allow
    destination:
      selector: app == 'mysql'
      ports: [3306]
  types: [Ingress, Egress]
```

## 없는 Cilium 서비스

- Cilium에서 **kube-proxy replacement** 활성 시, **iptables/ipvs 없이** eBPF로 서비스 LB.
- 장점: **낮은 지연**, **정확한 소스 IP**, **DSR/회선 최적화** 등.

## 부록 C. 일반적인 문제와 빠른 진단

- **증상**: Service 접근이 간헐적 실패
  - 원인: Pod Readiness, kube-proxy/cilium 버전 혼재, NodePort 헬스체크 실패
  - 조치: readinessProbe/헬스 체크 확인, Cilium `cilium status`, Hubble로 드롭 트레이스
- **증상**: 외부 egress 차단이 안 됨
  - 원인: 표준 KNP만 사용(L7 도메인 제한 불가)
  - 조치: **Cilium FQDN 정책** 또는 **Istio egress GW** 도입
- **증상**: 예상치 못한 통신 허용
  - 원인: 네임스페이스/라벨 선택자 누락, 다른 정책이 넓게 허용
  - 조치: 정책 스코프 검토, `kubectl describe cnp/np`로 매칭 확인

---

## 요약

- **CNI**는 IP·라우팅·LB 기반, **Service/Ingress/Gateway**는 L4/L7 진입점.
- **NetworkPolicy**로 **기본 거부 + 최소 허용**을 시행하고,
  L7은 **Cilium**(eBPF) 혹은 **서비스 메시**(mTLS+인가)로 보강하라.
- **Hubble/OTel**로 흐름을 시각화하고, **GitOps**로 정책 변경을 통제한다.
- 실습 시나리오처럼 **web→api→db** 체인을 **L3/L4/L7**에서 단계별로 제어하면
  **제로트러스트**에 가까운 **워크로드 중심 보안 모델**을 구현할 수 있다.
