---
layout: post
title: DB 심화 - 고급 인덱스 스캔
date: 2025-11-07 16:25:23 +0900
category: DB 심화
---
# Oracle 고급 인덱스 스캔 모음

## 0. 실습 스키마 & 데이터 준비

```sql
-- 깨끗이
DROP TABLE ix_adv_demo PURGE;

-- 고객 주문 테이블(20만 건 수준)
CREATE TABLE ix_adv_demo (
  cust_id     NUMBER        NOT NULL,
  grade       VARCHAR2(10)  NOT NULL,       -- 저카디널리티 후보(비트맵에 적합)
  status      VARCHAR2(10)  NOT NULL,       -- 저카디널리티 후보(비트맵에 적합)
  created_at  DATE          NOT NULL,
  total_amt   NUMBER(12,2)  NOT NULL,
  note        VARCHAR2(200),
  CONSTRAINT pk_ix_adv_demo PRIMARY KEY (cust_id)
);

BEGIN
  FOR i IN 1..200000 LOOP
    INSERT INTO ix_adv_demo
    VALUES (
      i,
      CASE MOD(i,6)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER'
        WHEN 3 THEN 'BRONZE' WHEN 4 THEN 'BASIC' ELSE 'NEW' END,
      CASE MOD(i,5)
        WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP'
        WHEN 3 THEN 'DONE' ELSE 'CANC' END,
      DATE '2024-01-01' + MOD(i, 400),
      ROUND(DBMS_RANDOM.VALUE(0, 100000), 2),
      CASE WHEN MOD(i,97)=0 THEN 'gift' END
    );
  END LOOP;
  COMMIT;
END;
/

-- B-tree 인덱스
CREATE INDEX ix_adv_g_dt_id      ON ix_adv_demo(grade, created_at, cust_id);
CREATE INDEX ix_adv_dt_amt       ON ix_adv_demo(created_at DESC, cust_id DESC, total_amt); -- DESC 포함
CREATE INDEX ix_adv_status       ON ix_adv_demo(status);
CREATE INDEX ix_adv_total_amt    ON ix_adv_demo(total_amt);

-- 비트맵 인덱스(저카디널리티 컬럼에 적합: DW/조회 중심 환경 가정)
CREATE BITMAP INDEX bm_adv_grade  ON ix_adv_demo(grade);
CREATE BITMAP INDEX bm_adv_status ON ix_adv_demo(status);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'IX_ADV_DEMO', cascade => TRUE,
    method_opt => 'for all columns size skewonly');
END;
/

-- 실측 통계 보려면
ALTER SESSION SET statistics_level = ALL;
```

> 주의: **비트맵 인덱스는 DML 경합에 취약**하므로 OLTP보다는 **DW/리포팅**에서 주로 사용합니다.

---

# 1. Index Fast Full Scan (IFFS)

## 1.1 개념
- 인덱스 **전체를 멀티블록 I/O로 일괄 훑기**.  
- **키 순서 보장 X** (정렬 없음) → `MIN/MAX`, `ORDER BY` 최적화에는 부적합.  
- **커버링**이거나 **집계**처럼 “인덱스만 보면 되는” 질의에서 **병렬/대량 처리**에 강함.  
- 실행계획 예: `INDEX FAST FULL SCAN` (병렬이면 `PX BLOCK ITERATOR`와 함께 보일 수 있음)

## 1.2 예제: 인덱스만으로 COUNT/집계
```sql
-- grade, created_at, cust_id를 모두 인덱스에 보유 → 커버링 집계
SELECT /* IFFS 후보 */ COUNT(*)
FROM   ix_adv_demo
WHERE  grade IN ('VIP','GOLD');

-- 힌트로 IFFS 유도(정렬이 필요 없거나 집계일 때 유효)
SELECT /*+ index_ffs(ix_adv_demo ix_adv_g_dt_id) */
       COUNT(*)
FROM   ix_adv_demo
WHERE  grade IN ('VIP','GOLD');

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

**언제 좋은가?**
- **정렬 불필요**, **인덱스만 읽으면 됨**, **대량 범위/집계**, **병렬** 활용.  
- 반대로 `MIN/MAX`, **Top-N**은 **IFFS가 아님**(아래 DESC Full Scan 참조).

---

# 2. Index Full Scan (Descending)

## 2.1 개념
- 인덱스 **키 순서 존중**하며 **싱글블록 I/O** 위주로 훑음.  
- `ORDER BY ... DESC` 최적화: 인덱스 **내림차순 정의** 또는 **INDEX FULL SCAN DESC**로 정렬 제거/Top-N Stopkey 가능.  
- 실행계획: `INDEX FULL SCAN (DESCENDING)` 또는 `INDEX FULL SCAN` + `DESC` 속성

## 2.2 예제: 최신순 Top-N 피드
```sql
-- 인덱스 정의: (created_at DESC, cust_id DESC, total_amt)
-- 최신순 상위 50건 (정렬 제거 + Stopkey)
SELECT /* DESC IFS */
       cust_id, created_at, total_amt
FROM   ix_adv_demo
ORDER  BY created_at DESC, cust_id DESC
FETCH FIRST 50 ROWS ONLY;

-- 필요 시 힌트
SELECT /*+ index_desc(ix_adv_demo ix_adv_dt_amt) */
       cust_id, created_at, total_amt
FROM   ix_adv_demo
ORDER  BY created_at DESC, cust_id DESC
FETCH FIRST 50 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

**포인트**
- **정렬과 인덱스 정의 방향 일치** → `SORT ORDER BY` 제거, **맨 앞 블록들만** 읽고 끝.  
- 이 경우 **IFFS**(순서 미보장)는 적합하지 않다.

---

# 3. Bitmap Index Scan (BITMAP AND/OR/…​)

## 3.1 개념
- 비트맵 인덱스는 **각 키 값에 대해 비트맵**(ROWID 위치를 비트로 표시) 유지.  
- 여러 비트맵을 **BITMAP AND/OR/XOR/…**로 **논리 연산** 후,  
  `BITMAP CONVERSION TO ROWIDS` → 최종 ROWID 집합 산출.  
- 실행계획 예: `BITMAP INDEX RANGE SCAN`, `BITMAP AND`, `BITMAP OR`, `BITMAP MERGE`, `BITMAP CONVERSION TO ROWIDS`.

## 3.2 예제: 복수 저카디널리티 필터 결합
```sql
-- 비트맵 인덱스: bm_adv_grade, bm_adv_status 존재
SELECT /* Bitmap AND */
       COUNT(*)
FROM   ix_adv_demo
WHERE  grade  IN ('VIP','GOLD')
AND    status IN ('PAID','SHIP');

-- 기대 계획(핵심)
-- BITMAP OR (bm_adv_grade 'VIP','GOLD')
-- BITMAP OR (bm_adv_status 'PAID','SHIP')
-- BITMAP AND
-- BITMAP CONVERSION TO ROWIDS
-- TABLE ACCESS BY ROWID IX_ADV_DEMO

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

## 3.3 집계·카운트 최적화
- 비트맵은 **카디널리티 낮을수록** 강력.  
- 조건들이 모두 비트맵이면 **테이블 방문 최소화 가능**(특히 커버링일수록 유리).

---

# 4. AND-EQUAL (B-tree 인덱스 교집합)

## 4.1 개념
- 서로 다른 **B-tree 인덱스** 두세 개의 **ROWID 교집합**을 구해 결과를 얻는 방식.  
- 힌트: `AND_EQUAL(table_alias, idx1, idx2 [, idx3 ...])` (최대 5개).  
- 예전 버전에서 명시적 유도에 유용. 요즘 옵티마이저는 비트맵 변환/결합을 선호하는 경우도 있음.

## 4.2 예제: 두 인덱스 교집합
```sql
-- B-tree: ix_adv_status(status), ix_adv_total_amt(total_amt)
-- 동등 조건 2개 → 교집합으로 좁히기
SELECT /* AND-EQUAL 후보 */
       cust_id
FROM   ix_adv_demo
WHERE  status    = 'PAID'
AND    total_amt = 5000;

-- 힌트로 교집합 유도
SELECT /*+ AND_EQUAL(ix_adv_demo ix_adv_status ix_adv_total_amt) */
       cust_id
FROM   ix_adv_demo
WHERE  status    = 'PAID'
AND    total_amt = 5000;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

**주의**
- 두 조건이 **모두 등호(=)** 이고 **선택도가 좋을 때** 효과적.  
- 조건이 넓거나 비등호이면 **Range Scan + Table Access**가 나을 수 있음.  
- 비트맵 인덱스가 있으면 옵티마이저는 종종 **비트맵 결합**을 선택.

---

# 5. INDEX COMBINE (비트맵 기반 결합 / BTREE→BITMAP 변환)

## 5.1 개념
- 힌트: `INDEX_COMBINE(table_alias [index_or_col ...])`.  
- **비트맵 접근 경로**를 사용하여 **복수 인덱스**를 **AND/OR**로 결합하도록 유도.  
- **비트맵 인덱스**가 있으면 그대로 결합하고,  
  **B-tree만** 있으면 **`BITMAP CONVERSION FROM ROWIDS`** 로 변환해 결합(성능은 상황에 따라 다름).

## 5.2 예제: B-tree 2개를 비트맵으로 변환해 결합
```sql
-- status(B-tree), total_amt(B-tree)만 있다고 가정(혹은 일부 비트맵 없음)
SELECT /*+ INDEX_COMBINE(ix_adv_demo ix_adv_status ix_adv_total_amt) */
       COUNT(*)
FROM   ix_adv_demo
WHERE  status    IN ('PAID','SHIP')
AND    total_amt BETWEEN 1000 AND 2000;

-- 기대계획(상황에 따라):
-- BITMAP CONVERSION FROM ROWIDS (ix_adv_status)
-- BITMAP CONVERSION FROM ROWIDS (ix_adv_total_amt range)
-- BITMAP AND
-- BITMAP CONVERSION TO ROWIDS
-- TABLE ACCESS BY ROWID IX_ADV_DEMO

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

**포인트**
- **저카디널리티 + 복수 조건**에서 효과적.  
- B-tree→Bitmap 변환 비용 vs Range Scan 비교는 **실측으로 판단**.

---

# 6. INDEX JOIN (인덱스만으로 결과 충족)

## 6.1 개념
- **서로 다른 B-tree 인덱스** 두세 개를 **ROWID 기준으로 조인**해서  
  **SELECT-LIST의 모든 컬럼**을 **인덱스들만**으로 충족(테이블 미방문).  
- 힌트: `INDEX_JOIN(table_alias index1 index2 ...)`  
- 실행계획: `INDEX JOIN` 또는 인덱스 소스 간 `HASH JOIN`/`MERGE JOIN`(버전/상황에 따라 표기 다름).

## 6.2 예제: 테이블 미방문으로 리스트 만들기
```sql
-- 인덱스1: ix_adv_status(status)         → status 컬럼 제공
-- 인덱스2: ix_adv_dt_amt(created_at DESC, cust_id DESC, total_amt) → created_at, cust_id, total_amt 제공
-- SELECT-LIST: (cust_id, created_at, status) → 모두 인덱스 속성으로 충족 가능

SELECT /* INDEX JOIN 후보 */
       d.cust_id, d.created_at, d.total_amt, d.status
FROM   ix_adv_demo d
WHERE  d.status = 'PAID'
ORDER  BY d.created_at DESC, d.cust_id DESC
FETCH FIRST 100 ROWS ONLY;

-- 힌트로 직접 유도
SELECT /*+ INDEX_JOIN(d ix_adv_status ix_adv_dt_amt)
           INDEX_DESC(d ix_adv_dt_amt) */
       d.cust_id, d.created_at, d.total_amt, d.status
FROM   ix_adv_demo d
WHERE  d.status = 'PAID'
ORDER  BY d.created_at DESC, d.cust_id DESC
FETCH FIRST 100 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));
```

**포인트**
- **테이블 BY ROWID 랜덤 I/O 제거** → **매우 빠른** 리스트 만들기 가능.  
- 전제: 필요한 컬럼이 **모두 인덱스들로 커버**되어야 함. (그렇지 않으면 테이블 방문 발생)

---

# 7. 어떤 스캔을 선택해야 할까? (의사결정 트리)

1. **정렬이 필요**하고 **최신순/최소/최대/Top-N**?  
   → **Index Full Scan (ASC/DESC)** + Stopkey.  
2. **정렬 불필요**, **인덱스만 보면 됨**, **대량/병렬**?  
   → **Index Fast Full Scan**.  
3. **등호/범위로 Start/Stop Key 명확**?  
   → **Index Range Scan**.  
4. **저카디널리티 다중 조건**?  
   → **Bitmap Index Scan**(BITMAP AND/OR) 또는 `INDEX_COMBINE`.  
5. **두 B-tree 등호 조건 교집합**으로 강하게 좁힐 수 있음?  
   → **AND-EQUAL**.  
6. **테이블 미방문**으로 컬럼 충족 가능?  
   → **INDEX JOIN**.

---

# 8. 실전 튜닝 시나리오

## 8.1 “최신 100건 대시보드가 느림”
- **나쁜 패턴**: Full Scan + Sort + Top-N  
- **개선**: `(created_at DESC, cust_id DESC)` 인덱스 + `INDEX FULL SCAN DESC` + `FETCH FIRST 100`  
  → 정렬 제거, **앞부분 블록만** 읽고 끝.

## 8.2 “다중 필터(등급/상태/금액 구간) 보고서”
- **비트맵 인덱스** + `BITMAP AND/OR`로 약한 컬럼들을 결합.  
- B-tree만 있다면 `INDEX_COMBINE`으로 **B-tree→Bitmap 변환** 후 결합을 시험.  
- **실측**으로 Buffers/Reads 비교(ALLSTATS LAST).

## 8.3 “테이블 랜덤 I/O가 너무 많다”
- 필요한 컬럼이 인덱스들에 산재 → **INDEX JOIN**으로 테이블 미방문 경로 시도.  
- 불가하면 **커버링 인덱스**(SELECT-LIST 포함) 설계.

---

# 9. 실행계획/통계 확인 템플릿

```sql
-- 1) 후보 쿼리 실행
SELECT /* 테스트 */ COUNT(*)
FROM   ix_adv_demo
WHERE  grade='VIP' AND status='PAID';

-- 2) 실제 수행 통계 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +OUTLINE'));

-- 관찰 포인트
-- - OPERATOR: INDEX FAST FULL SCAN / INDEX FULL SCAN (DESC) / BITMAP AND/OR / BITMAP CONVERSION ...
-- - Buffers(일관성 읽기), Reads(물리 I/O), A-Rows(실제 행수), Starts
-- - SORT 유무(정렬 제거되었는지), TABLE ACCESS BY ROWID 발생 여부(커버링/INDEX JOIN 성공했는지)
```

---

# 10. 힌트 요약 & 주의

- `INDEX_FFS(t i)` : **IFFS** 유도(정렬 불가/병렬 적합).  
- `INDEX_ASC/INDEX_DESC(t i)` : **정렬 일치** IFS/Range Scan 유도.  
- `AND_EQUAL(t i1 i2 ...)` : **B-tree 교집합**. 등호 조건 강할 때.  
- `INDEX_COMBINE(t [i1 i2 ...])` : **비트맵 결합** 경로 유도(BTREE→BITMAP 변환 포함).  
- `INDEX_JOIN(t i1 i2 ...)` : **인덱스만으로 결과 충족** 시도.  
- 힌트는 **증상 진단 후 최소한으로**. 구조(인덱스 설계/쿼리 SARGable/정렬 일치)가 근본.

---

## 11. 요약 체크리스트

- **IFFS**: 정렬 불필요, **인덱스만으로 집계/전량 훑기**, 멀티블록 I/O/병렬 강점.  
- **IFS (DESC)**: **정렬 보장**, **Top-N/최신순**에 최적.  
- **Bitmap Scan**: **저카디널리티 다중 조건** 결합에 최강(AND/OR).  
- **AND-EQUAL**: 두 개 이상의 **B-tree 등호 조건 교집합**으로 강하게 좁힐 때.  
- **INDEX COMBINE**: 비트맵 결합 접근 유도(B-tree만 있어도 변환 결합 가능).  
- **INDEX JOIN**: **테이블 미방문**으로 SELECT-LIST 충족, 리스트/피드 최적화에 유용.  
- 항상 **실측(ALLSTATS LAST)**으로 Buffers/Reads/Rows 비교 → **숫자**로 결정.

> 결론: 스캔 방식은 **정렬 필요성**, **선택도/카디널리티**, **커버링 여부**, **병렬·I/O 패턴**의 함수입니다.  
> 인덱스 정의(컬럼/순서/정렬), 비트맵/BTREE 혼용 전략, 그리고 조심스러운 힌트로 **목표 I/O 패턴**을 정확히 그려내세요.  
> 그러면 “느리다”가 **Top-N만 읽고 끝났다**로 바뀝니다.