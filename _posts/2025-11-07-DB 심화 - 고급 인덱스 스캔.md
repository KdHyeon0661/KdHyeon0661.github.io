---
layout: post
title: DB 심화 - 고급 인덱스 스캔
date: 2025-11-07 16:25:23 +0900
category: DB 심화
---
# Oracle 고급 인덱스 스캔 기법 완전 정복

> **핵심 요약**
> Oracle 데이터베이스는 다양한 고급 인덱스 스캔 기법을 제공하여 다양한 데이터 접근 패턴에 최적화된 성능을 달성할 수 있습니다. Index Fast Full Scan, Index Full Scan Descending, Bitmap Index Scan, AND-EQUAL, INDEX COMBINE, INDEX JOIN 등 각각의 기법은 특정 상황에서 뛰어난 성능을 발휘합니다. 이러한 스캔 방식을 효과적으로 활용하기 위해서는 각 기법의 특성과 적용 시기를 정확히 이해하는 것이 중요합니다.

---

## 실습 환경 구성

```sql
-- 테스트 테이블 생성: 고객 주문 데이터
DROP TABLE ix_adv_demo PURGE;

CREATE TABLE ix_adv_demo (
  cust_id     NUMBER        NOT NULL,
  grade       VARCHAR2(10)  NOT NULL,
  status      VARCHAR2(10)  NOT NULL,
  created_at  DATE          NOT NULL,
  total_amt   NUMBER(12,2)  NOT NULL,
  note        VARCHAR2(200),
  CONSTRAINT pk_ix_adv_demo PRIMARY KEY (cust_id)
);

-- 샘플 데이터 생성 (200,000건)
BEGIN
  FOR i IN 1..200000 LOOP
    INSERT INTO ix_adv_demo
    VALUES (
      i,
      CASE MOD(i,6)
        WHEN 0 THEN 'VIP' 
        WHEN 1 THEN 'GOLD' 
        WHEN 2 THEN 'SILVER'
        WHEN 3 THEN 'BRONZE' 
        WHEN 4 THEN 'BASIC' 
        ELSE 'NEW' 
      END,
      CASE MOD(i,5)
        WHEN 0 THEN 'NEW' 
        WHEN 1 THEN 'PAID' 
        WHEN 2 THEN 'SHIP'
        WHEN 3 THEN 'DONE' 
        ELSE 'CANC' 
      END,
      DATE '2024-01-01' + MOD(i, 400),
      ROUND(DBMS_RANDOM.VALUE(0, 100000), 2),
      CASE WHEN MOD(i,97)=0 THEN 'gift' END
    );
    
    -- 일정 주기로 커밋
    IF MOD(i, 10000) = 0 THEN
      COMMIT;
    END IF;
  END LOOP;
  COMMIT;
END;
/

-- B-tree 인덱스 생성
CREATE INDEX ix_adv_g_dt_id ON ix_adv_demo(grade, created_at, cust_id);
CREATE INDEX ix_adv_dt_amt ON ix_adv_demo(created_at DESC, cust_id DESC, total_amt);
CREATE INDEX ix_adv_status ON ix_adv_demo(status);
CREATE INDEX ix_adv_total_amt ON ix_adv_demo(total_amt);

-- 비트맵 인덱스 생성 (DW/리포팅 환경 가정)
CREATE BITMAP INDEX bm_adv_grade ON ix_adv_demo(grade);
CREATE BITMAP INDEX bm_adv_status ON ix_adv_demo(status);

-- 통계 정보 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname => USER,
    tabname => 'IX_ADV_DEMO',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR ALL COLUMNS SIZE SKEWONLY',
    cascade => TRUE
  );
END;
/

-- 상세 실행 통계 활성화
ALTER SESSION SET statistics_level = ALL;
```

---

## Index Fast Full Scan (IFFS)

### 개념과 특징

Index Fast Full Scan은 인덱스 전체를 멀티블록 I/O 방식으로 효율적으로 스캔하는 기법입니다. 이 방식은 인덱스 키 순서를 보장하지 않기 때문에 정렬이 필요하지 않은 집계 작업이나 대량 데이터 처리에 적합합니다.

**주요 특징:**
- 인덱스의 모든 리프 블록을 멀티블록 읽기로 빠르게 스캔
- 키 순서를 보장하지 않음 (정렬 불가)
- 병렬 처리에 효과적
- 인덱스만으로 결과를 얻을 수 있는 커버링 쿼리에 적합

### 활용 예제

```sql
-- IFFS를 활용한 효율적인 집계 쿼리
SELECT /*+ INDEX_FFS(d ix_adv_g_dt_id) */ 
       grade,
       COUNT(*) AS customer_count,
       SUM(total_amt) AS total_amount,
       AVG(total_amt) AS average_amount
FROM ix_adv_demo d
WHERE grade IN ('VIP', 'GOLD', 'SILVER')
GROUP BY grade
ORDER BY total_amount DESC;

-- 실행 계획 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 
    'ALLSTATS LAST +PEEKED_BINDS'));

-- IFFS와 일반 풀 스캔 비교
SET AUTOTRACE TRACEONLY STATISTICS;

-- IFFS 활용
SELECT /*+ INDEX_FFS(d ix_adv_g_dt_id) */ COUNT(*)
FROM ix_adv_demo d
WHERE grade IN ('VIP', 'GOLD');

-- 일반 풀 스캔
SELECT /*+ FULL(d) */ COUNT(*)
FROM ix_adv_demo d
WHERE grade IN ('VIP', 'GOLD');

SET AUTOTRACE OFF;
```

### 적용 시 고려사항

1. **적합한 상황:**
   - 정렬이 필요하지 않은 집계 작업
   - 인덱스만으로 모든 필요한 정보를 얻을 수 있는 경우
   - 대량 데이터의 통계 분석
   - 병렬 쿼리 실행 환경

2. **부적합한 상황:**
   - 정렬이 필요한 경우 (ORDER BY)
   - MIN/MAX 값 찾기
   - Top-N 쿼리
   - 인덱스만으로 필요한 컬럼을 모두 얻을 수 없는 경우

---

## Index Full Scan Descending

### 개념과 특징

Index Full Scan Descending은 인덱스를 내림차순으로 전체 스캔하며 키 순서를 보장하는 기법입니다. 최신 데이터 접근이나 특정 순서의 데이터 검색에 최적화되어 있습니다.

**주요 특징:**
- 인덱스 키 순서를 보장하면서 스캔
- 내림차순 인덱스 정의나 DESC 힌트로 활성화
- Top-N 쿼리와 최신 데이터 접근에 적합
- 정렬 작업을 제거할 수 있음

### 활용 예제

```sql
-- 최신 주문 상위 100개 조회
SELECT /*+ INDEX_DESC(d ix_adv_dt_amt) */
       cust_id,
       created_at,
       total_amt,
       status
FROM ix_adv_demo d
WHERE created_at >= DATE '2024-06-01'
ORDER BY created_at DESC, cust_id DESC
FETCH FIRST 100 ROWS ONLY;

-- 실행 계획 분석
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, NULL, 'ALLSTATS LAST +PEEKED_BINDS +OUTLINE'
));

-- 내림차순 인덱스를 활용한 효율적인 페이지네이션
DECLARE
    v_last_date DATE := DATE '2024-08-15';
    v_last_id NUMBER := 150000;
BEGIN
    SELECT cust_id, created_at, total_amt
    FROM ix_adv_demo
    WHERE created_at < v_last_date
       OR (created_at = v_last_date AND cust_id < v_last_id)
    ORDER BY created_at DESC, cust_id DESC
    FETCH FIRST 50 ROWS ONLY;
END;
/
```

### 성능 최적화 팁

1. **인덱스 설계:**
   ```sql
   -- 내림차순 정렬이 필요한 컬럼에 DESC 인덱스 생성
   CREATE INDEX ix_orders_recent ON orders(
       order_date DESC, 
       order_id DESC
   ) COMPRESS 1;
   ```

2. **쿼리 작성:**
   - ORDER BY 절의 순서와 인덱스 정의 순서 일치
   - 적절한 WHERE 조건으로 스캔 범위 제한
   - FETCH FIRST / ROWNUM 제한 활용

---

## Bitmap Index Scan

### 개념과 특징

Bitmap Index Scan은 저카디널리티 컬럼에 대한 다중 조건 검색을 최적화하는 기법입니다. 비트맵 연산(AND, OR, XOR)을 통해 복잡한 조건 조합을 효율적으로 처리할 수 있습니다.

**주요 특징:**
- 저카디널리티 컬럼에 최적화
- 비트맵 연산으로 다중 조건 효율적 처리
- DW/리포팅 환경에 적합
- DML 작업이 적은 환경에서 효과적

### 활용 예제

```sql
-- 비트맵 인덱스를 활용한 복합 조건 검색
SELECT /*+ INDEX_COMBINE(d) */
       COUNT(*) AS order_count,
       SUM(total_amt) AS total_amount
FROM ix_adv_demo d
WHERE grade IN ('VIP', 'GOLD')
  AND status IN ('PAID', 'SHIPPED')
  AND created_at >= DATE '2024-07-01';

-- 실행 계획 분석
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, NULL, 'ALLSTATS LAST +PEEKED_BINDS'
));

-- 비트맵 인덱스 통계 확인
SELECT 
    index_name,
    leaf_blocks,
    distinct_keys,
    clustering_factor,
    ROUND(num_rows / NULLIF(distinct_keys, 0), 2) AS rows_per_key
FROM user_indexes
WHERE index_name LIKE 'BM_%'
ORDER BY index_name;
```

### 고급 비트맵 연산

```sql
-- 복잡한 비트맵 연산 활용
SELECT 
    grade,
    status,
    COUNT(*) AS count,
    AVG(total_amt) AS avg_amount
FROM ix_adv_demo
WHERE (grade = 'VIP' AND status IN ('PAID', 'SHIPPED'))
   OR (grade = 'GOLD' AND status = 'DONE')
   OR (total_amt > 50000 AND created_at >= DATE '2024-06-01')
GROUP BY grade, status
ORDER BY grade, status;

-- 비트맵 변환 힌트
SELECT /*+ INDEX_COMBINE(d bm_adv_grade bm_adv_status) 
           BITMAP_TREE */
       cust_id,
       created_at,
       total_amt
FROM ix_adv_demo d
WHERE grade = 'VIP'
  AND status = 'PAID'
ORDER BY created_at DESC;
```

### 주의사항

1. **DML 오버헤드:** 비트맵 인덱스는 DML 작업 시 잠금 오버헤드가 큽니다.
2. **적용 환경:** OLTP보다는 DW/리포팅 환경에 적합합니다.
3. **카디널리티:** 매우 높은 카디널리티 컬럼에는 비효율적입니다.

---

## AND-EQUAL (B-tree 인덱스 교집합)

### 개념과 특징

AND-EQUAL은 여러 B-tree 인덱스의 ROWID 교집합을 구하여 결과를 얻는 기법으로, 각 조건의 선택도가 높을 때 효과적입니다.

```sql
-- AND-EQUAL 활용 예제
SELECT /*+ AND_EQUAL(d ix_adv_status ix_adv_total_amt) */
       cust_id,
       created_at,
       total_amt,
       status
FROM ix_adv_demo d
WHERE status = 'PAID'
  AND total_amt BETWEEN 1000 AND 5000
ORDER BY created_at DESC
FETCH FIRST 100 ROWS ONLY;

-- 성능 비교를 위한 대체 방법
SELECT /*+ USE_CONCAT */ 
       cust_id,
       created_at,
       total_amt,
       status
FROM ix_adv_demo d
WHERE status = 'PAID'
  AND total_amt BETWEEN 1000 AND 5000;
```

---

## INDEX COMBINE

### 개념과 특징

INDEX COMBINE은 비트맵 기반의 인덱스 결합 기법으로, B-tree 인덱스를 비트맵으로 변환하여 결합하는 방식입니다.

```sql
-- INDEX COMBINE 활용
SELECT /*+ INDEX_COMBINE(d ix_adv_status ix_adv_total_amt) */
       COUNT(*) AS order_count,
       AVG(total_amt) AS average_amount
FROM ix_adv_demo d
WHERE status IN ('PAID', 'SHIPPED')
  AND total_amt >= 10000
  AND created_at >= DATE '2024-06-01';

-- 비트맵 변환 과정 확인
EXPLAIN PLAN FOR
SELECT /*+ INDEX_COMBINE(d) */ 
       grade,
       COUNT(*)
FROM ix_adv_demo d
WHERE grade IN ('VIP', 'GOLD')
  AND status = 'PAID'
GROUP BY grade;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## INDEX JOIN

### 개념과 특징

INDEX JOIN은 여러 인덱스를 조인하여 테이블 접근 없이 필요한 모든 컬럼을 얻는 기법으로, 랜덤 I/O를 최소화할 수 있습니다.

```sql
-- INDEX JOIN 활용 예제
SELECT /*+ INDEX_JOIN(d ix_adv_status ix_adv_dt_amt) */
       d.cust_id,
       d.created_at,
       d.total_amt,
       d.status
FROM ix_adv_demo d
WHERE d.status = 'PAID'
  AND d.created_at >= DATE '2024-07-01'
ORDER BY d.created_at DESC
FETCH FIRST 200 ROWS ONLY;

-- 인덱스 커버링 확인
SELECT 
    index_name,
    column_name,
    column_position
FROM user_ind_columns
WHERE table_name = 'IX_ADV_DEMO'
ORDER BY index_name, column_position;

-- 필요한 컬럼 커버링 여부 분석
SELECT 
    '필요한 컬럼' as type,
    LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_name) as columns
FROM (
    SELECT 'CUST_ID' as column_name FROM dual UNION
    SELECT 'CREATED_AT' FROM dual UNION
    SELECT 'TOTAL_AMT' FROM dual UNION
    SELECT 'STATUS' FROM dual
)
UNION ALL
SELECT 
    '인덱스 커버링' as type,
    LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_name) as columns
FROM (
    SELECT DISTINCT column_name
    FROM user_ind_columns
    WHERE table_name = 'IX_ADV_DEMO'
);
```

---

## 실전 시나리오별 최적화 전략

### 시나리오 1: 대시보드 성능 최적화

```sql
-- 대시보드용 통계 쿼리 최적화
WITH dashboard_stats AS (
    SELECT /*+ INDEX_FFS(d ix_adv_g_dt_id) MATERIALIZE */
           grade,
           status,
           COUNT(*) AS record_count,
           SUM(total_amt) AS total_amount,
           AVG(total_amt) AS avg_amount
    FROM ix_adv_demo d
    WHERE created_at >= ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -3)
    GROUP BY grade, status
)
SELECT 
    grade,
    status,
    record_count,
    total_amount,
    avg_amount,
    ROUND(record_count * 100.0 / SUM(record_count) OVER(), 2) AS percentage
FROM dashboard_stats
ORDER BY total_amount DESC, grade, status;
```

### 시나리오 2: 실시간 검색 시스템

```sql
-- 효율적인 검색 시스템 구현
CREATE OR REPLACE PACKAGE search_pkg AS
    TYPE search_result_rec IS RECORD (
        cust_id     ix_adv_demo.cust_id%TYPE,
        created_at  ix_adv_demo.created_at%TYPE,
        total_amt   ix_adv_demo.total_amt%TYPE,
        status      ix_adv_demo.status%TYPE,
        grade       ix_adv_demo.grade%TYPE
    );
    
    TYPE search_result_tab IS TABLE OF search_result_rec;
    
    FUNCTION search_orders(
        p_grade     IN VARCHAR2 DEFAULT NULL,
        p_status    IN VARCHAR2 DEFAULT NULL,
        p_min_amt   IN NUMBER DEFAULT NULL,
        p_max_amt   IN NUMBER DEFAULT NULL,
        p_from_date IN DATE DEFAULT NULL,
        p_to_date   IN DATE DEFAULT NULL,
        p_page_size IN NUMBER DEFAULT 100
    ) RETURN search_result_tab PIPELINED;
END search_pkg;
/

CREATE OR REPLACE PACKAGE BODY search_pkg AS
    FUNCTION search_orders(
        p_grade     IN VARCHAR2 DEFAULT NULL,
        p_status    IN VARCHAR2 DEFAULT NULL,
        p_min_amt   IN NUMBER DEFAULT NULL,
        p_max_amt   IN NUMBER DEFAULT NULL,
        p_from_date IN DATE DEFAULT NULL,
        p_to_date   IN DATE DEFAULT NULL,
        p_page_size IN NUMBER DEFAULT 100
    ) RETURN search_result_tab PIPELINED
    IS
        CURSOR search_cursor IS
            SELECT /*+ INDEX_DESC(d ix_adv_dt_amt) */
                   cust_id,
                   created_at,
                   total_amt,
                   status,
                   grade
            FROM ix_adv_demo d
            WHERE (p_grade IS NULL OR grade = p_grade)
              AND (p_status IS NULL OR status = p_status)
              AND (p_min_amt IS NULL OR total_amt >= p_min_amt)
              AND (p_max_amt IS NULL OR total_amt <= p_max_amt)
              AND (p_from_date IS NULL OR created_at >= p_from_date)
              AND (p_to_date IS NULL OR created_at <= p_to_date)
            ORDER BY created_at DESC, cust_id DESC
            FETCH FIRST p_page_size ROWS ONLY;
    BEGIN
        FOR rec IN search_cursor LOOP
            PIPE ROW(rec);
        END LOOP;
        RETURN;
    END search_orders;
END search_pkg;
/
```

### 시나리오 3: 배치 보고 처리

```sql
-- 대량 배치 처리 최적화
CREATE OR REPLACE PROCEDURE generate_daily_report AS
    v_report_date DATE := TRUNC(SYSDATE) - 1;
    v_start_time TIMESTAMP;
    v_end_time TIMESTAMP;
BEGIN
    v_start_time := SYSTIMESTAMP;
    
    -- 비트맵 인덱스를 활용한 효율적인 집계
    INSERT INTO daily_sales_report (report_date, grade, status, order_count, total_amount)
    SELECT /*+ INDEX_COMBINE(d) PARALLEL(d 4) */
           v_report_date,
           grade,
           status,
           COUNT(*) AS order_count,
           SUM(total_amt) AS total_amount
    FROM ix_adv_demo d
    WHERE created_at >= v_report_date
      AND created_at < v_report_date + 1
    GROUP BY grade, status;
    
    COMMIT;
    
    v_end_time := SYSTIMESTAMP;
    
    -- 성능 로깅
    INSERT INTO performance_log (
        job_name, 
        start_time, 
        end_time, 
        duration_seconds,
        rows_processed
    ) VALUES (
        'DAILY_REPORT',
        v_start_time,
        v_end_time,
        EXTRACT(SECOND FROM (v_end_time - v_start_time)),
        SQL%ROWCOUNT
    );
    COMMIT;
END generate_daily_report;
/
```

---

## 성능 측정과 분석 방법

### 종합 성능 분석 리포트

```sql
-- 인덱스 스캔 성능 분석 리포트
CREATE OR REPLACE PROCEDURE analyze_index_performance AS
    v_report CLOB;
    
    PROCEDURE add_line(p_text VARCHAR2) IS
    BEGIN
        v_report := v_report || p_text || CHR(10);
    END;
    
BEGIN
    v_report := '인덱스 스캔 성능 분석 리포트' || CHR(10);
    v_report := v_report || '생성 시간: ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') || CHR(10);
    v_report := v_report || REPEAT('=', 80) || CHR(10) || CHR(10);
    
    -- 1. 인덱스 통계 분석
    add_line('1. 인덱스 통계 분석');
    add_line(REPEAT('-', 40));
    FOR rec IN (
        SELECT 
            index_name,
            index_type,
            uniqueness,
            leaf_blocks,
            distinct_keys,
            clustering_factor,
            ROUND(clustering_factor * 100.0 / NULLIF(leaf_blocks, 0), 2) AS cf_ratio
        FROM user_indexes
        WHERE table_name = 'IX_ADV_DEMO'
        ORDER BY index_name
    ) LOOP
        add_line(RPAD(rec.index_name, 25) || ' | ' ||
                 RPAD(rec.index_type, 15) || ' | ' ||
                 'Leaf: ' || LPAD(TO_CHAR(rec.leaf_blocks, '999,999'), 8) || ' | ' ||
                 'CF Ratio: ' || LPAD(TO_CHAR(rec.cf_ratio, '999.99'), 7) || '%');
    END LOOP;
    add_line('');
    
    -- 2. 인덱스 사용 통계
    add_line('2. 인덱스 사용 통계');
    add_line(REPEAT('-', 40));
    FOR rec IN (
        SELECT 
            name,
            value
        FROM v$segment_statistics
        WHERE owner = USER
          AND object_name LIKE 'IX_%'
          AND statistic_name = 'logical reads'
        ORDER BY value DESC
        FETCH FIRST 5 ROWS ONLY
    ) LOOP
        add_line(RPAD(rec.name, 30) || ' | ' ||
                 '논리적 읽기: ' || LPAD(TO_CHAR(rec.value, '999,999,999'), 12));
    END LOOP;
    add_line('');
    
    -- 3. 최적화 권장 사항
    add_line('3. 최적화 권장 사항');
    add_line(REPEAT('-', 40));
    
    -- 클러스터링 팩터 분석
    DECLARE
        v_poor_cf_indexes NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO v_poor_cf_indexes
        FROM user_indexes i
        WHERE i.table_name = 'IX_ADV_DEMO'
          AND i.clustering_factor > i.leaf_blocks * 3;
        
        IF v_poor_cf_indexes > 0 THEN
            add_line('• 클러스터링 팩터가 나쁜 인덱스가 ' || v_poor_cf_indexes || '개 있습니다.');
            add_line('  테이블 재정렬이나 파티셔닝을 고려하세요.');
        END IF;
        
        -- 비트맵 인덱스 활용 권장
        add_line('• 다중 조건 검색이 빈번한 경우 비트맵 인덱스를 활용하세요.');
        add_line('• Top-N 쿼리에는 DESC 인덱스를 활용하세요.');
        add_line('• 자주 함께 사용되는 컬럼은 복합 인덱스로 구성하세요.');
    END;
    
    -- 리포트 출력
    DBMS_OUTPUT.PUT_LINE(v_report);
END analyze_index_performance;
/

-- 리포트 실행
EXEC analyze_index_performance;
```

### 성능 비교 벤치마크

```sql
-- 다양한 인덱스 스캔 방식 성능 비교
SET TIMING ON
SET AUTOTRACE TRACEONLY STATISTICS

-- 1. Index Range Scan
SELECT /*+ INDEX(d ix_adv_g_dt_id) */ 
       COUNT(*)
FROM ix_adv_demo d
WHERE grade = 'VIP'
  AND created_at >= DATE '2024-07-01';

-- 2. Index Fast Full Scan
SELECT /*+ INDEX_FFS(d ix_adv_g_dt_id) */ 
       COUNT(*)
FROM ix_adv_demo d
WHERE grade = 'VIP'
  AND created_at >= DATE '2024-07-01';

-- 3. Bitmap Index Scan
SELECT /*+ INDEX_COMBINE(d bm_adv_grade) */ 
       COUNT(*)
FROM ix_adv_demo d
WHERE grade = 'VIP'
  AND created_at >= DATE '2024-07-01';

SET AUTOTRACE OFF
SET TIMING OFF

-- 결과 비교 테이블
CREATE TABLE index_scan_comparison (
    test_id NUMBER,
    scan_type VARCHAR2(50),
    execution_time NUMBER,
    logical_reads NUMBER,
    physical_reads NUMBER,
    test_date DATE DEFAULT SYSDATE
);
```

---

## 운영 환경 적용 가이드

### 환경별 최적화 전략

**OLTP 환경:**
```sql
-- B-tree 인덱스 중심 전략
CREATE INDEX ix_orders_oltp ON orders(
    customer_id,
    order_date DESC,
    status
) COMPRESS 1;

-- 커버링 인덱스 활용
CREATE INDEX ix_orders_covering ON orders(
    order_id,
    customer_id,
    order_date,
    total_amount
) INCLUDE (status, payment_method);
```

**데이터 웨어하우스 환경:**
```sql
-- 비트맵 인덱스와 파티셔닝 조합
CREATE BITMAP INDEX bix_sales_region ON sales(region);
CREATE BITMAP INDEX bix_sales_product ON sales(product_category);

-- 파티션 로컬 인덱스
CREATE INDEX ix_sales_part_local ON sales(sale_date, customer_id)
LOCAL;
```

**혼합 환경:**
```sql
-- 시간대별 최적화 전략
BEGIN
    IF TO_CHAR(SYSDATE, 'HH24') BETWEEN 8 AND 18 THEN
        -- 업무 시간: B-tree 인덱스 최적화
        EXECUTE IMMEDIATE 'ALTER INDEX ix_orders_oltp REBUILD ONLINE';
    ELSE
        -- 야간 시간: 비트맵 인덱스 유지보수
        EXECUTE IMMEDIATE 'ALTER INDEX bix_sales_region REBUILD ONLINE';
    END IF;
END;
/
```

### 인덱스 모니터링과 유지보수

```sql
-- 인덱스 사용 통계 수집
ALTER INDEX ix_adv_g_dt_id MONITORING USAGE;

-- 사용되지 않는 인덱스 식별
SELECT 
    index_name,
    table_name,
    monitoring,
    used,
    start_monitoring,
    end_monitoring
FROM v$object_usage
WHERE index_name LIKE 'IX_%'
  AND used = 'NO'
  AND end_monitoring IS NULL;

-- 인덱스 조각화 분석
SELECT 
    index_name,
    ROUND((del_lf_rows_len / NULLIF(lf_rows_len, 0)) * 100, 2) AS fragmentation_percent
FROM index_stats
WHERE name LIKE 'IX_%'
  AND (del_lf_rows_len / NULLIF(lf_rows_len, 0)) > 0.2;

-- 인덱스 재구성 스케줄
BEGIN
    DBMS_SCHEDULER.CREATE_JOB(
        job_name        => 'REBUILD_INDEXES_JOB',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 
            'BEGIN
                FOR idx IN (SELECT index_name 
                           FROM user_indexes 
                           WHERE status = ''VALID''
                             AND index_type = ''NORMAL'') 
                LOOP
                    BEGIN
                        EXECUTE IMMEDIATE ''ALTER INDEX '' || idx.index_name || '' REBUILD ONLINE'';
                    EXCEPTION
                        WHEN OTHERS THEN
                            DBMS_OUTPUT.PUT_LINE(''Failed: '' || idx.index_name || '' - '' || SQLERRM);
                    END;
                END LOOP;
            END;',
        start_date      => TRUNC(SYSDATE) + 2,  -- 이틀 후 시작
        repeat_interval => 'FREQ=WEEKLY; BYDAY=SUN; BYHOUR=2',
        enabled         => TRUE,
        comments        => '주간 인덱스 재구성 작업'
    );
END;
/
```

---

## 결론: 효과적인 인덱스 스캔 전략 수립

Oracle의 고급 인덱스 스캔 기법들은 다양한 데이터 접근 패턴에 맞춰 최적의 성능을 달성할 수 있는 강력한 도구들입니다. 각 기법의 특성과 장단점을 이해하고 상황에 맞게 적용하는 것이 핵심입니다.

### 핵심 성공 원칙

1. **데이터 접근 패턴 이해부터 시작하세요**
   - 애플리케이션의 실제 쿼리 패턴을 분석합니다
   - 데이터 분포와 카디널리티를 이해합니다
   - 접근 빈도와 중요도를 평가합니다

2. **적절한 스캔 방식 선택하기**
   - 정렬이 필요하면 Index Full Scan (Descending)
   - 대량 집계에는 Index Fast Full Scan
   - 다중 조건 검색에는 Bitmap Index Scan
   - 테이블 접근 최소화에는 INDEX JOIN

3. **종합적인 최적화 접근법**
   - 인덱스 설계와 쿼리 작성의 조화
   - 통계 정보의 정확성 유지
   - 정기적인 성능 모니터링
   - 지속적인 튜닝과 개선

4. **운영 환경 고려하기**
   - OLTP vs DW 환경 차이 이해
   - 리소스 제약 조건 고려
   - 유지보수 계획 수립
   - 변화 관리 프로세스 구축

### 실무 적용을 위한 조언

1. **점진적인 접근**: 한 번에 모든 것을 변경하기보다 작은 변화부터 시작하세요.
2. **측정과 검증**: 모든 변경은 성능 데이터로 검증하세요.
3. **균형 있는 설계**: 읽기 성능과 쓰기 성능의 균형을 유지하세요.
4. **지속적인 학습**: 새로운 기능과 최적화 기법을 지속적으로 학습하세요.

### 최종 권장사항

인덱스 최적화는 단순한 기술적 작업을 넘어 시스템 전체의 설계 철학을 반영합니다. 각 애플리케이션의 특성과 비즈니스 요구사항을 깊이 이해하고, 데이터에 기반한 과학적 접근법으로 최적의 솔루션을 찾아가시기 바랍니다.

기억하세요: 가장 효과적인 최적화는 문제를 사전에 예방하는 설계입니다. 데이터 모델링 단계부터 성능을 고려한 접근이 장기적인 성공을 보장합니다. 정기적인 성능 모니터링, 주기적인 튜닝, 그리고 지속적인 개선 문화를 통해 시스템의 건강을 유지하시기 바랍니다.