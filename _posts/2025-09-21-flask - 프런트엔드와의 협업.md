---
layout: post
title: flask - 프런트엔드와의 협업
date: 2025-09-21 21:25:23 +0900
category: flask
---
# 19. 프런트엔드와의 협업

> 이 장은 **SPA(CSR/SSR)와 Flask의 역할 분담**, **CORS/쿠키 기반 인증 vs 토큰 기반(JWT/OAuth2)**, **정적 빌드(React/Vite/Svelte)와 배포 파이프라인**을 “실무 협업” 기준으로 정리한다.  
> 모든 코드는 ``` 로 감싸며, 수식이 필요하면 반드시 $$...$$ 로 표기한다(본 장은 수식이 거의 없다).

---

## 19.1 협업 큰그림

- **Flask**  
  - 인증/인가, 데이터 API, 파일 처리, WebSocket(Flask-SocketIO), 백오피스/웹훅, OpenAPI 문서
  - BFF(Backends For Frontends) 역할: 프런트가 필요로 하는 **맞춤형 API** 집약층
- **프런트엔드(SPA)**  
  - 화면 렌더링/라우팅/상태관리, 접근성(ARIA), 에셋 번들링, i18n, 폼 UX
  - SSR/SSG(Next/Nuxt/SvelteKit) 채택 시, **초기 페인트/SEO/링크 프리뷰** 강화

핵심 원칙:
1) **계약 우선(OpenAPI/GraphQL 스키마)**: API를 문서/스키마로 먼저 정한다.  
2) **분리 배포**: 프런트 정적 자산은 CDN, 백엔드는 API 도메인으로 **독립 배포**.  
3) **인증 전략 합의**: **쿠키 세션 기반** 또는 **토큰(JWT/OAuth2)** 를 팀 합의로 통일.

---

## 19.2 SPA 렌더링 모델과 Flask의 역할

### 19.2.1 CSR(클라이언트 사이드 렌더링)

- 최초에 HTML **껍데기**와 JS 번들을 내려받고, 이후 라우팅/렌더는 브라우저에서 처리.
- **장점**: 배포 간단(CDN 서빙), 페이지 간 전환 빠름.  
- **단점**: 첫 페인트가 늦을 수 있음(특히 저사양/저속 네트워크).

**Flask 역할**  
- 순수 API 서버 + 정적 파일 호스팅(개발 단계)  
- 운영에서는 **정적 파일은 CDN** 으로 옮기고 Flask는 API만.

개발 편의(프록시) 예:

```python
# app/blueprints/site.py - 개발 모드에서 SPA dev server 프록시 (선택)
from flask import Blueprint, redirect, request
site = Blueprint("site", __name__)

@site.get("/")
def index():
    # dev: 프론트 dev 서버(5173)로 리다이렉트, prod: CDN index.html에서 시작
    if current_app.config.get("DEV_PROXY"):
        return redirect("http://localhost:5173/")
    return current_app.send_static_file("index.html")
```

### 19.2.2 SSR(서버 사이드 렌더링)

- Next.js/Nuxt/SvelteKit 등이 **Node SSR**로 초기 HTML 생성 → **Time To First Byte(TTFB)** 개선, SEO/OG 태그 유리.
- SSR 서버는 보통 **Node 런타임**이 담당하고, Flask는 **API**만 제공(혹은 BFF).

**SSR 협업 패턴**
- 도메인: `web.example.com`(SSR) ↔ `api.example.com`(Flask)  
- SSR 서버가 API를 호출할 때는 **서비스-투-서비스 인증**(mTLS/전용 토큰/내부 네트워크)

SSR에서 사용자 쿠키 전달(주의: 보안 헤더) 예:

```ts
// Next.js (route handler or server action)
const res = await fetch(`${process.env.API_BASE}/me`, {
  headers: { cookie: headers().get('cookie') ?? '' }, // SameSite/Domain 일치 필요
  credentials: 'include',
})
```

### 19.2.3 BFF(Backends For Frontends)

- UI 화면/컴포넌트가 필요로 하는 **딱 맞는 API** 를 제공하는 중간층.  
- Flask가 BFF가 되면, 도메인 API(마이크로서비스)들을 호출/집약/캐싱하여 **프런트-친화 응답** 구성.

BFF 예(다중 서비스 집약):

```python
# app/bff/feed.py
from flask import Blueprint, jsonify
from .clients import profile_client, timeline_client
from .cache import cache

bff = Blueprint("bff", __name__, url_prefix="/bff")

@bff.get("/home-feed")
@cache.cached(timeout=5, key_prefix=lambda: f"feed:{g.user_id}")
def home_feed():
    profile = profile_client.get_profile(g.user_id)
    posts = timeline_client.get_timeline(g.user_id, limit=20)
    # 프런트가 바로 그릴 수 있는 구조로 정규화/머지
    return jsonify({"profile": profile, "posts": posts})
```

---

## 19.3 CORS와 인증 전략

### 19.3.1 CORS 개념 요약

- 서로 다른 오리진(front: `https://app.example.com`, api: `https://api.example.com`)에서 API 호출 시 브라우저가 **CORS 정책**을 적용.
- 서버는 `Access-Control-Allow-Origin`, `Access-Control-Allow-Credentials`, `Access-Control-Allow-Headers/Methods` 를 명시.

Flask-CORS 설정(쿠키 포함):

```python
# app/__init__.py
from flask_cors import CORS

def create_app():
    app = Flask(__name__)
    CORS(app,
         resources={r"/api/*": {"origins": ["https://app.example.com"]}},
         supports_credentials=True,
         expose_headers=["X-Request-Id"],
         allow_headers=["Content-Type", "Authorization", "X-Requested-With"],
         methods=["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"])
    return app
```

프런트 fetch 옵션(쿠키 전송):

```javascript
await fetch("https://api.example.com/api/items", {
  method: "GET",
  credentials: "include", // 쿠키 포함
});
```

> **주의**: `Access-Control-Allow-Origin: *` 일 때 `credentials=true` 는 허용되지 않는다(정확한 오리진 명시).

### 19.3.2 쿠키 기반 인증(서버 세션)

- 백엔드가 세션을 관리하고, 브라우저는 **HttpOnly** 쿠키로 인증 상태 유지.
- **장점**: 토큰 보관을 JS에서 하지 않아 **XSS에 상대적으로 안전**(HttpOnly).  
- **단점**: **서버 세션 저장소(메모리/Redis)** 필요, **CSRF** 방어 필요.

Flask 세션 쿠키 보안 설정:

```python
app.config.update(
    SESSION_COOKIE_NAME="sid",
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SAMESITE="Lax",  # or "None" + Secure for cross-site
    SESSION_COOKIE_SECURE=True,     # HTTPS only in production
    PERMANENT_SESSION_LIFETIME=3600 # 1h
)
```

CSRF 토큰(더블 서브밋 패턴) 예:

```python
# 서버: CSRF 토큰 발급 엔드포인트
@bp.get("/csrf-token")
def csrf_token():
    token = secrets.token_urlsafe(32)
    session["csrf"] = token
    resp = jsonify({"csrf": token})
    # 또는 SameSite=Strict 쿠키로 내려도 됨
    return resp

# API: 보호 라우트
@bp.post("/profile")
def update_profile():
    token = request.headers.get("X-CSRF-Token")
    if not token or token != session.get("csrf"):
        abort(403)
    ...
```

프런트:

```javascript
const { csrf } = await fetch("/api/csrf-token", { credentials: "include"}).then(r => r.json())
await fetch("/api/profile", {
  method: "POST",
  credentials: "include",
  headers: { "Content-Type": "application/json", "X-CSRF-Token": csrf },
  body: JSON.stringify({ name: "Alice" })
})
```

**도메인/서브도메인 전략**  
- `app.example.com` ↔ `api.example.com` 간 쿠키 공유: `Domain=.example.com` 사용 + `SameSite=None; Secure`.

### 19.3.3 토큰 기반 인증(JWT/OAuth2)

- 프런트가 액세스 토큰(JWT)을 **Authorization 헤더**에 담아 보냄.
- **장점**: 서버에 세션 저장 불필요(Stateless), 서비스 간 호출도 용이.  
- **단점**: 토큰을 어디에 저장할지(XSS/CSRF), **만료/회수/로테이션** 정책 필요.

권장 패턴:
- **Access Token(짧음, 5~15분)** + **Refresh Token(길음, 7~30일)**  
- Refresh Token은 **HttpOnly 쿠키**로 저장하고, Access Token은 **메모리/상태관리**에만 저장(로컬스토리지 지양).  
- **토큰 로테이션**: 리프레시 할 때마다 새 RT 발급 & 이전 RT 폐기(탈취 위험 줄임).

서버(JWT 발급/갱신) 예:

```python
# app/auth/jwt.py
import time, secrets, jwt
from flask import Blueprint, request, jsonify, make_response

bp = Blueprint("auth", __name__, url_prefix="/auth")
JWT_SECRET = "change-me"
ACCESS_TTL = 900   # 15m
REFRESH_TTL = 60*60*24*14  # 14d

def make_access(user_id):
    now = int(time.time())
    payload = {"sub": str(user_id), "iat": now, "exp": now + ACCESS_TTL, "scope": "api"}
    return jwt.encode(payload, JWT_SECRET, algorithm="HS256")

def make_refresh(user_id, jti=None):
    now = int(time.time())
    jti = jti or secrets.token_urlsafe(16)
    payload = {"sub": str(user_id), "iat": now, "exp": now + REFRESH_TTL, "jti": jti, "type":"refresh"}
    # jti는 서버 저장소(블랙리스트/화이트리스트)로 관리하면 회수 가능
    return jwt.encode(payload, JWT_SECRET, algorithm="HS256"), jti

@bp.post("/login")
def login():
    data = request.get_json()
    # verify user...
    access = make_access(user_id=123)
    refresh, jti = make_refresh(user_id=123)
    resp = jsonify({"access_token": access, "token_type": "Bearer", "expires_in": ACCESS_TTL})
    resp.set_cookie("rt", refresh, httponly=True, secure=True, samesite="None", max_age=REFRESH_TTL, path="/auth")
    return resp

@bp.post("/refresh")
def refresh():
    rt = request.cookies.get("rt")
    if not rt: return {"error":"no refresh"}, 401
    try:
        payload = jwt.decode(rt, JWT_SECRET, algorithms=["HS256"])
        # jti 회수/로테이션 체크 (중복 사용 방지)
    except jwt.PyJWTError:
        return {"error":"invalid refresh"}, 401
    new_access = make_access(payload["sub"])
    new_refresh, new_jti = make_refresh(payload["sub"])
    resp = jsonify({"access_token": new_access, "token_type":"Bearer", "expires_in": ACCESS_TTL})
    resp.set_cookie("rt", new_refresh, httponly=True, secure=True, samesite="None", max_age=REFRESH_TTL, path="/auth")
    return resp
```

보호 라우트:

```python
def require_bearer(fn):
    @wraps(fn)
    def _(*a, **kw):
        auth = request.headers.get("Authorization", "")
        if not auth.startswith("Bearer "): abort(401)
        token = auth.split(" ",1)[1]
        try:
            g.jwt = jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
        except jwt.PyJWTError:
            abort(401)
        return fn(*a, **kw)
    return _
```

프런트(Access 메모리 저장 + Silent Refresh):

```ts
let accessToken: string | null = null;
async function ensureToken() {
  if (!accessToken || isExpiringSoon(accessToken)) {
    const res = await fetch("/auth/refresh", { method: "POST", credentials: "include" });
    if (!res.ok) throw new Error("refresh failed");
    const data = await res.json();
    accessToken = data.access_token;
  }
  return accessToken!;
}
// API 호출
const token = await ensureToken();
await fetch("/api/orders", { headers: { Authorization: `Bearer ${token}` }});
```

**쿠키 vs 토큰 선택 가이드**
- **단일 도메인/서브도메인** & 브라우저 클라이언트 중심 → **쿠키 세션**이 단순/안전  
- **모바일/3rd 파티/서비스-투-서비스** 혼용 → **JWT + RT 쿠키**가 유연

---

## 19.4 정적 빌드(React/Vite/Svelte) & 배포 파이프라인

### 19.4.1 빌드 산출물과 캐시 전략

- 빌드 결과: `index.html`, 해시가 붙은 `assets/*.js`, `*.css` → **immutable 캐시** 가능  
- `index.html` 은 라우팅 게이트이므로 **no-cache** 또는 짧은 TTL, 나머지는 **1년 캐시 + immutable**

Nginx 정적 서빙 예:

```
location / {
  try_files $uri /index.html;
}
location /assets/ {
  add_header Cache-Control "public, max-age=31536000, immutable";
  try_files $uri =404;
}
```

CDN(CloudFront/Fastly) 권장:
- 오리진: S3/Static bucket  
- 경로별 캐시 정책: `/assets/*` 장기, `/index.html` 짧게

### 19.4.2 .env 주입: 빌드타임 vs 런타임

- Vite/CRA는 기본적으로 **빌드 타임**에 `import.meta.env` 또는 `process.env`를 주입 → 환경별로 **다시 빌드** 필요  
- **런타임 주입** 기법: `window.__APP_CONFIG__` JSON을 nginx에서 **템플릿**으로 주입

런타임 config.js:

```html
<!-- index.html -->
<script src="/config.js"></script>
<script>
  // 앱 시작 전에 window.__APP_CONFIG__ 가 존재
</script>
```

Nginx에서 `config.js` 템플릿:

```
location = /config.js {
  default_type application/javascript;
  return 200 'window.__APP_CONFIG__ = {
    "API_BASE": "$API_BASE",
    "SENTRY_DSN": "$SENTRY_DSN"
  };';
}
```

프런트:

```ts
const API_BASE = (window as any).__APP_CONFIG__?.API_BASE ?? import.meta.env.VITE_API_BASE
```

### 19.4.3 CI/CD 파이프라인(예: GitHub Actions)

- **프런트**: Lint/Typecheck/Test → Build → 업로드(S3/Artifacts) → 무효화/배포  
- **백엔드**: Test/Coverage → 이미지 빌드 → K8s 롤링 → 헬스 확인

프런트 워크플로:

```yaml
# .github/workflows/frontend.yml
name: frontend
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: "20" }
      - run: npm ci
      - run: npm run lint && npm run build
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: web-dist
          path: dist
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
        with: { name: web-dist, path: dist }
      - name: Sync to S3
        run: aws s3 sync dist s3://cdn-bucket/ --delete --cache-control "public,max-age=31536000,immutable"
      - name: Set index.html cache
        run: aws s3 cp dist/index.html s3://cdn-bucket/index.html --cache-control "no-cache"
      - name: Invalidate CDN
        run: aws cloudfront create-invalidation --distribution-id ABC123 --paths "/index.html"
```

### 19.4.4 SPA 라우팅(History API) + 404

- 서버는 **존재하지 않는 경로**도 모두 `index.html` 로 보내야 SPA가 클라이언트 라우터로 처리.
- **API 경로**는 예외(`/api/`, `/auth/`, `/static/` 등).

Nginx:

```
location /api/ { proxy_pass http://api_upstream; }
location /auth/ { proxy_pass http://api_upstream; }
location / { try_files $uri /index.html; }
```

### 19.4.5 번들 최적화

- **코드 스플리팅**: 라우트 단위 `import()`  
- **Preload/Prefetch**: 주요 경로 초기 로드 가속  
- **이미지 최적화**: webp/avif, responsive sizes  
- **Sourcemap 비공개 업로드**: Sentry 등 에러 추적에 업로드, 공개 CDN에는 배포하지 않기

Vite 예:

```ts
// vite.config.ts
export default defineConfig({
  build: {
    sourcemap: true,
    rollupOptions: {
      output: { manualChunks: { vendor: ['react','react-dom'] } }
    }
  }
})
```

---

## 19.5 개발 경험(DevX) 정리

### 19.5.1 로컬 개발 프록시

- 프런트 dev server(5173) ↔ Flask(5000) 간 **프록시**로 CORS 우회
- Vite 설정:

```ts
// vite.config.ts
export default defineConfig({
  server: {
    proxy: {
      "/api": { target: "http://localhost:5000", changeOrigin: true },
      "/auth": { target: "http://localhost:5000", changeOrigin: true },
    }
  }
})
```

### 19.5.2 API 타입 안전(클라이언트 코드 생성)

- **OpenAPI** → `openapi-typescript`, `openapi-generator` 로 **API 클라이언트/타입** 생성
- 변경 시 자동 업데이트(CI 전 단계)

예: openapi-typescript

```bash
npx openapi-typescript http://localhost:5000/openapi.json -o src/api/types.ts
```

프런트 사용:

```ts
import type { paths } from './api/types'
type GetOrdersResponse = paths['/api/orders']['get']['responses']['200']['content']['application/json']
```

---

## 19.6 업로드/다운로드 UX와 백엔드 협업

### 19.6.1 대용량 업로드

- **사전서명 URL(S3/GCS)** 로 브라우저→스토리지 직접 업로드 (13장)
- 진행률 표시/취소/재시도 UX

프런트:

```ts
const presign = await fetch("/files/upload/presign", { method:"POST", body: JSON.stringify({name:file.name, content_type:file.type})}).then(r=>r.json())
await fetch(presign.url, { method: "PUT", body: file, headers: {"Content-Type": file.type } })
await fetch("/files/upload/commit", { method:"POST", body: JSON.stringify({ key: presign.key })})
```

### 19.6.2 다운로드/스트리밍

- 백엔드: **X-Accel-Redirect** / 서명 URL (13장)  
- 프런트: Range 요청/미디어 태그 사용

---

## 19.7 WebSocket/실시간

- **Flask-SocketIO**: 이벤트 기반 푸시(알림/채팅/실시간 상태)
- **프런트**: Socket.IO 클라이언트, 인증은 **쿠키 세션** 또는 **Bearer 토큰** 핸드셰이크로 전달

서버:

```python
@socketio.on('connect', namespace="/notify")
def on_connect():
    # 토큰 검증/세션 검증
    if not authorized(): return False
```

프런트:

```js
const socket = io("https://api.example.com/notify", {
  withCredentials: true,
  auth: { token: accessToken } // 또는 쿠키 전송
})
```

---

## 19.8 보안/프라이버시 협업 체크

- **쿠키 보안 속성**: `HttpOnly`, `Secure`, `SameSite` 합의  
- **CSRF 방어**: 쿠키 기반이면 **필수**(더블 서브밋/Origin-검사)  
- **CSP/보안 헤더**: 프런트 inline script 최소화, nonce/hash  
- **XSS 방지**: 사용자 입력 **escape**(React 기본), 위험 HTML은 sanitize  
- **PII 최소화**: 프런트 저장소(LocalStorage/IndexedDB) 에 민감정보 저장 금지  
- **로그/메트릭**: 사용자 식별자/토큰 마스킹

---

## 19.9 사례: React + Vite + Flask (CSR) — 엔드투엔드 스캐폴딩

### 19.9.1 디렉터리 구조

```
frontend/
  src/
    main.tsx
    api/
      client.ts
  index.html
  vite.config.ts
backend/
  app/
    __init__.py
    auth/
    api/
  wsgi.py
```

### 19.9.2 프런트 API 클라이언트

```ts
// frontend/src/api/client.ts
export async function api(path: string, init: RequestInit = {}) {
  const res = await fetch(`${import.meta.env.VITE_API_BASE}${path}`, {
    credentials: "include",
    headers: { "Content-Type":"application/json", ...(init.headers||{}) },
    ...init,
  })
  if (!res.ok) throw new Error(await res.text())
  const type = res.headers.get("Content-Type") || ""
  return type.includes("application/json") ? res.json() : res.text()
}
```

### 19.9.3 로그인 예제

서버(쿠키 세션):

```python
@auth.post("/login")
def login():
    data = request.get_json()
    user = authenticate(data["email"], data["password"])
    if not user: return {"error":"bad cred"}, 401
    session["uid"] = user.id
    return {"ok": True}
```

프런트:

```tsx
async function onLogin(email: string, password: string) {
  await api("/auth/login", { method: "POST", body: JSON.stringify({email,password}) })
  // 이후 me 호출
}
```

---

## 19.10 배포 시나리오 요약

1) **프런트**  
   - CI에서 빌드 → `/assets/*` 해시 파일 **장기 캐시**로 업로드 → `/index.html` 짧은 캐시  
   - 릴리스 태그/릴리즈 노트 자동 생성, sourcemap은 Sentry 업로드

2) **백엔드**  
   - Docker 멀티 스테이지 → K8s 롤링 → HPA, 헬스체크

3) **도메인/네트워킹**  
   - `app.example.com`(프런트, CDN) ↔ `api.example.com`(Flask)  
   - CORS/쿠키/토큰 정책 합의, TLS/HTTP2/ Brotli

4) **모니터링**  
   - 프런트: Web Vitals, Sentry  
   - 백엔드: 메트릭/트레이스/로그(11장), 에러 버짓

---

## 19.11 흔한 안티패턴

- **CORS 허용 과다**: `*` 와 credentials 함께 사용 → 보안 오류  
- **LocalStorage에 토큰 저장**: XSS에 취약 → **메모리 + RT 쿠키** 권장  
- **SSR 서버에서 사용자 쿠키를 무분별 전달**: 도메인/경로/SameSite/보안 헤더 불일치  
- **SPA fallback 미설정**: 새로고침 404  
- **index.html 장기 캐시**: 새 배포 반영 지연  
- **Sourcemap 공개 노출**: 공격자에게 도움 → 에러 추적 서비스로만 업로드  
- **CSRF 미적용**(쿠키 세션) 또는 **Origin/Referer 검증 누락**

---

## 19.12 체크리스트

- [ ] **렌더링 모델**(CSR/SSR/BFF) 결정 & 역할 분담 문서화  
- [ ] **CORS**: 허용 오리진/헤더/메서드/자격증명 정확히 설정  
- [ ] 인증 전략: **쿠키 세션** or **JWT(+RT 쿠키)** 확정, 로테이션 포함  
- [ ] **CSRF 방지**(쿠키 기반) or **토큰 저장 전략**(JWT) 결정  
- [ ] 정적 자산: **해시 파일 장기 캐시** + **index.html 짧은 캐시**  
- [ ] 런타임 구성 주입(환경별 config.js) or 빌드별 아티팩트 분리  
- [ ] Dev 프록시/Vite 설정, OpenAPI 타입 생성 자동화  
- [ ] 업/다운로드: 사전서명 URL, 진행률/재시도 UX  
- [ ] WebSocket 인증/네임스페이스/권한  
- [ ] 모니터링: Web Vitals/Sentry + 백엔드 메트릭/트레이스
