---
layout: post
title: 소켓프로그래밍 - L2~L7과 소켓의 위치
date: 2025-09-13 23:25:23 +0900
category: 소켓프로그래밍
---
# 프로토콜 스택 한눈에: L2~L7과 소켓의 위치, 그리고 5-튜플로 연결을 읽는 법

> 핵심 한 줄 요약  
> **소켓은 L4(전송 계층)의 엔드포인트를 다루는 커널 객체**이고,  
> 응용이 `send/recv` 하는 순간 데이터는 **L7 → L4 → L3 → L2**로 내려가며,  
> 반대로 수신은 **L2 → L3 → L4 → L7**로 올라온다.  
> 그리고 각 TCP 연결은 **5-튜플**  
> $$ (\text{src\_IP},\ \text{src\_port},\ \text{dst\_IP},\ \text{dst\_port},\ \text{protocol}) $$  
> 로 유일하게 식별된다.

---

## 1. OSI / TCP-IP 스택 요약: 소켓은 어디에 위치하는가

먼저 큰 그림을 표로 쭉 보는 것이 좋다.

### 1.1 계층별 요약 표

| 레벨 | (OSI / TCP/IP) 이름          | 단위                 | 핵심 주소/식별자              | 주요 역할                            |
|------|-----------------------------|----------------------|-------------------------------|--------------------------------------|
| L1   | 물리(Physical)              | 비트 스트림          | 없음                          | 전기/광 신호, 케이블, 무선 전파     |
| L2   | 데이터 링크(Data Link)      | 프레임(Frame)        | MAC 주소                      | 같은 링크 내 전송, 충돌/오류 처리   |
| L3   | 네트워크(Network, IP)       | 패킷(Packet)         | IP 주소(IPv4/IPv6)           | 라우팅(다른 네트워크로 전달)        |
| L4   | 전송(Transport: TCP/UDP)    | 세그먼트/데이터그램  | 포트(Port) + 프로토콜        | 종단 간 전송, 흐름/혼잡/신뢰 제어   |
| L5~7 | 세션/표현/응용(실무=응용)   | 메시지/스트림        | URL/호스트/프로토콜 이름 등   | HTTP/TLS/SSH 등 응용 프로토콜       |

**소켓의 위치**는 분명하다.

- **소켓 API**는 **L4(전송 계층)** 의 기능(TCP/UDP)을  
  **운영체제 커널이 제공하는 인터페이스**로 노출한 것이다.
- 개발자가 `socket()`, `bind()`, `connect()`, `send()`, `recv()` 등으로 소켓을 다룰 때,
  - 내부적으로는 **TCP/UDP 헤더(L4)**, **IP 헤더(L3)**, **Ethernet/Wi-Fi 헤더(L2)** 가 자동으로 붙는다.
  - 응용은 **payload(데이터)** 만 만지고, 나머지 계층은 OS/커널이 처리한다.

---

### 1.2 L2: 데이터 링크 계층 (Ethernet / 무선 LAN 등)

- 단위: **프레임(Frame)**  
- 주소: **MAC 주소**
  - 예: `02:42:ac:11:00:02`
  - NIC(네트워크 카드)별로 할당되는 48비트 식별자(전통적 의미 기준).
- **MTU(Maximum Transmission Unit)**:
  - 한 프레임이 운반할 수 있는 L3 payload(IP 패킷)의 최대 크기.
  - 전형적인 Ethernet은 MTU=1500 바이트(점보 프레임은 더 클 수 있음).
- 추가 개념:
  - **VLAN 태그(802.1Q)**: 프레임에 VLAN ID를 추가해 논리 네트워크 분리.
  - **스위치**: MAC 주소 기반으로 프레임을 전달.

L2는 “**같은 링크**” 안에서 프레임이 어떻게 이동하는지를 책임진다.  
L3(IP 패킷)도 결국 L2 프레임 안에 실려서 이동한다.

---

### 1.3 L3: 네트워크 계층 (IP)

- 단위: **패킷(Packet)** (IPv4/IPv6 헤더가 붙은 단위)
- 주소: **IP 주소**
  - IPv4: 32비트, 예 `192.0.2.10`
  - IPv6: 128비트, 예 `2001:db8::1`
- 주요 기능:
  - **라우팅(Routing)**:
    - 라우터는 목적지 IP를 기반으로 **다음 홉(Next Hop)** 을 결정한다.
  - **단편화(Fragmentation)** (IPv4):
    - 패킷이 경로 상 MTU보다 크면 잘라 보낼 수 있다.
  - **PMTUD(Path MTU Discovery)**:
    - 경로 상 MTU를 탐색해 단편화 없이 맞는 크기로 보낼 수 있게 하는 메커니즘.

L3는 “**IP 주소를 가진 서로 다른 네트워크**” 사이를 패킷이 어떻게 넘어 다니는지를 결정한다.  
소켓에는 직접 노출되지 않지만, `connect()` 시 **라우팅 테이블**을 기반으로 소스 IP/출구 인터페이스가 선택된다.

---

### 1.4 L4: 전송 계층 (TCP/UDP/기타)

- 단위:
  - **TCP**: 세그먼트(Segment)
  - **UDP**: 데이터그램(Datagram)
- 주소:
  - **포트(PORT)** 번호 (16비트, 0~65535)
- 특징:
  - **TCP (Transmission Control Protocol)**:
    - 연결 지향(Connection-oriented): **3-way Handshake** 로 연결 수립
    - **신뢰성**: 손실 시 재전송, 순서 보장
    - **흐름 제어(flow control)**: 수신자의 윈도우에 맞춰 전송량 조정
    - **혼잡 제어(congestion control)**: 네트워크 혼잡 감지/완화
    - **바이트 스트림(byte stream)**: 응용엔 경계 없는 바이트 흐름 제공
  - **UDP (User Datagram Protocol)**:
    - 비연결(Connectionless)
    - **메시지 경계가 보존**된다(한 `sendto`가 한 데이터그램이 됨).
    - 신뢰성/순서/재전송 없음 → 가볍고 단순.

**소켓**은 사실상 이 L4의 끝점을 나타내는 **커널 객체**이다.

- TCP 소켓: **바이트 스트림**을 주고받는 인터페이스
- UDP 소켓: **데이터그램(메시지 단위)** 을 주고받는 인터페이스

---

### 1.5 L5~L7: 세션/표현/응용 (실무에선 “응용 계층”으로 통합)

실무에서는 L5~L7을 나누지 않고 그냥 **응용 계층(Application Layer)** 로 부른다.

- 예시 프로토콜:
  - HTTP/1.1, HTTP/2, HTTP/3
  - TLS(HTTPS)
  - gRPC
  - DNS
  - SSH
  - SMTP, IMAP, POP3
- 이 계층에서 다루는 것:
  - **메시지 형식** (JSON, Protobuf, ASN.1, …)
  - **상태 머신** (요청/응답, 세션 유지, 인증/인가 흐름)
  - **암호화/서명** (TLS, SSH 등)
  - **캐싱, 리디렉션, 리트라이 정책** 등

응용 계층은 소켓 위의 **프로토콜 설계**를 책임진다.  
소켓이 “바이트 스트림”만 제공하는 TCP 위에서는 반드시 **프레이밍**이 필요하다(이 부분은 프롤로그 글에서 상세히 다뤘던 내용과 직접 연결된다).

---

## 2. 실제 흐름: send/recv가 L2~L7을 어떻게 타는가

이제 추상적인 설명을 실제 흐름으로 정리해 보자.

### 2.1 송신 경로 (응용 → 네트워크)

응용이 `send()` 를 호출하면, 내부적으로는 대략 다음 순서가 진행된다.

1. **응용(L7)**:
   - `send(fd, buf, len, ...)` 호출 → **payload(순수 데이터)** 를 커널에 건넨다.
2. **L4(TCP/UDP)**:
   - 해당 소켓의 **포트 번호, 시퀀스 번호(TCP), 체크섬** 등을 포함한
     **전송 계층 헤더**를 payload 앞에 붙인다.
3. **L3(IP)**:
   - **소스/목적지 IP**, TTL/Hop Limit, 프로토콜(TCP/UDP) 필드를 포함하는
     **IP 헤더**를 앞에 붙인다.
   - 패킷 크기가 MTU를 넘어가면:
     - IPv4: 단편화
     - IPv6: 발신 측이 크기를 줄이도록 설계(중간 단편화 없음).
4. **L2(Ethernet/Wi-Fi)**:
   - **소스/목적지 MAC 주소**와 **VLAN 태그(필요시)** 를 포함하는
     **L2 헤더**를 맨 앞에 붙인다.
5. **L1/PHY**:
   - 완성된 프레임이 NIC를 통해 전기/광/무선 신호로 나간다.

이 모든 과정은 개발자가 직접 헤더를 꾸밀 필요 없이,  
**커널과 NIC 드라이버**가 처리한다. (raw socket은 예외지만 일반적인 TCP/UDP 소켓에서는 그렇다.)

---

### 2.2 수신 경로 (네트워크 → 응용)

반대로, 원격에서 들어오는 데이터는 다음처럼 올라온다.

1. **L2**:
   - NIC가 프레임을 수신한다.
   - **목적지 MAC** 이 자기 NIC에 해당하는지 확인하고, 맞으면 상위로 올린다.
2. **L3(IP)**:
   - IP 헤더의 **목적지 IP** 를 보고, 자기에게 온 것인지 또는 라우팅해야 하는지 결정.
   - 방화벽/필터링(iptables/nftables 등)을 통과.
   - 상위 프로토콜(L4: TCP/UDP) 번호를 보고 해당 스택으로 전달.
3. **L4(TCP/UDP)**:
   - TCP라면 시퀀스 번호, ACK, 윈도우, 체크섬 등을 검증하고 재조립.
   - **포트와 프로토콜, IP 주소**를 조합해 어떤 소켓에 전달할지 결정한다.
   - **수신 버퍼**에 payload를 적재한다.
4. **응용(L7)**:
   - 프로세스가 `recv()` 를 호출하면 커널 수신 버퍼에서 데이터를 꺼내 전달한다.

이 과정 전체를 **관측**하는 것이 중요하다.

> 관측 Tip  
> - 한 터미널에서: `strace -e trace=network ./your_program` 으로  
>   `send/recv/connect/accept` 호출을 추적한다.  
> - 다른 터미널에서: `sudo tcpdump -i any tcp port 9000 -n -vv` 로  
>   같은 포트의 패킷을 캡처한다.  
> → 그러면 **L7에서의 시스템 콜**과 **L2~L4에서의 패킷**이 어떻게 연결되는지 눈에 보인다.

---

## 3. MTU, MSS, 세그먼트 분할: 스트림 위에서 “패킷”이 보이는 이유

### 3.1 MTU와 MSS 정의

- **MTU(Maximum Transmission Unit)**:
  - L2 프레임의 **payload** 최대 크기.
  - 전형적인 이더넷: MTU = 1500 바이트.
- **MSS(Maximum Segment Size)** (TCP):
  - 한 TCP 세그먼트가 실을 수 있는 **TCP payload** 최대 크기.
  - 대략  
    $$
    \text{MSS} \approx \text{MTU} - (\text{IP 헤더 길이}) - (\text{TCP 헤더 길이})
    $$
  - IPv4 기본 헤더 20B + TCP 기본 헤더 20B 라면:
    - MSS ≈ 1500 - 20 - 20 = 1460 바이트.

실제 환경에서는 IP 옵션, TCP 옵션(Timestamps, SACK, MSS option 자체 등) 때문에  
정확한 계산은 조금 달라질 수 있지만, 개념적으로는 위와 같다.

---

### 3.2 한 번의 send()가 여러 패킷으로 쪼개지는 이유

응용에서 이렇게 한 번에 1MB를 보낸다고 하자.

```cpp
std::vector<char> big(1024 * 1024, 'X');
::send(fd, big.data(), big.size(), 0);
```

TCP 스택은:

- 이 1MB를 한 번에 **하나의 TCP 세그먼트**로 보내지 않는다.
- **MSS 이하** 크기의 조각으로 나누어서 여러 세그먼트로 보낸다.
- 네트워크 상태, 혼잡 제어, 송신 버퍼 상태에 따라:
  - 세그먼트 크기가 다소 달라질 수도 있고,
  - 중간에 재전송도 섞일 수 있다.

그래서 Wireshark에서 보면:

- 응용에겐 “1번 send”였던 것이,
- 패킷 목록에서는 “수십~수백 개의 TCP 세그먼트”로 보이게 된다.

반대로 응용에서 작은 `send()`를 여러 번 호출해도:

- 커널이 OS/네트워크 상태에 따라 이를 **한 세그먼트로 묶어** 보낼 수도 있다(Nagle 등).

---

### 3.3 실습: 64KB 메시지를 여러 세그먼트로 나뉘는 모습 보기

1. 프롤로그에서 작성했던 **TCP 프레이밍 에코 서버/클라이언트**를 사용한다.
2. 클라이언트 쪽에서 64KB 메시지를 만들어 전송하도록 수정한다.

```cpp
// client_big.cpp (요지)
std::string msg(64 * 1024, 'A');  // 64KB
```

3. 캡처:

```bash
sudo tcpdump -i lo tcp port 9000 -n -vv -w trace_64k.pcap
```

4. Wireshark에서 `trace_64k.pcap`을 열고:
   - Packet List에서 “TCP segment of a reassembled PDU” 표시를 확인한다.
   - 하나의 Application Data(프레이밍된 64KB)가
     - 여러 개의 TCP 세그먼트로 나뉘어 나간 모습이 보인다.
   - 응용 레벨에서는 그저 “한 번의 프레임”으로 수신되지만,
     - 네트워크 레벨에서는 여러 패킷으로 분리/재조립되고 있음을 이해할 수 있다.

---

## 4. 소켓 디스크립터 = 커널의 엔드포인트 핸들

리눅스/유닉스에서 **소켓**은 **파일 디스크립터(fd)** 로 표현된다.

- `int fd = socket(...);`
- `read(fd, ...)`, `write(fd, ...)`, `close(fd)` 가 그대로 동작한다.
- `send/recv`는 TCP/UDP 소켓에 특화된 함수일 뿐,  
  **기본 개념은 “파일 디스크립터 위의 I/O”** 이다.

### 4.1 리스닝 소켓 vs 연결 소켓

TCP 서버는 보통 두 종류의 소켓을 가진다.

1. **리스닝 소켓(listening socket)**:
   - `socket()` + `bind()` + `listen()` 으로 만들어진 소켓.
   - `(로컬 IP, 로컬 포트, 프로토콜=TCP)` 를 갖고,
   - **대기열**(SYN 큐, accept 큐)을 관리한다.
   - 클라이언트 연결 요청을 수락할 준비만 하고,  
     실제 데이터는 이 소켓으로 주고받지 않는다.

2. **연결 소켓(accepted socket)**:
   - `accept()` 가 반환하는 소켓.
   - 하나의 TCP 연결(세션)을 대표하는 **5-튜플**을 가진다.

이제 이 5-튜플을 본격적으로 정리해 보자.

---

## 5. 주소/포트/프로토콜: 5-튜플로 연결을 식별하기

### 5.1 정의와 수식

TCP 연결은 일반적으로 다음 **5-튜플**로 유일하게 식별된다.

$$
(\text{src\_IP},\ \text{src\_port},\ \text{dst\_IP},\ \text{dst\_port},\ \text{protocol})
$$

- `src_IP`: 소스 IP 주소 (IPv4/IPv6)
- `src_port`: 소스 포트 번호 (16비트)
- `dst_IP`: 목적지 IP 주소
- `dst_port`: 목적지 포트 번호
- `protocol`: TCP/UDP 등 (실무에서는 대부분 TCP를 의미)

실무에서는 프로토콜이 TCP로 고정되는 경우가 많아서  
**4-튜플** 처럼 간단히 부르기도 한다.

$$
(\text{src\_IP},\ \text{src\_port},\ \text{dst\_IP},\ \text{dst\_port})
$$

그러나 커널 내부에서는 **프로토콜(TCP/UDP)** 을 반드시 포함해 구별한다.

---

### 5.2 예시: 단일 클라이언트와 단일 서버

예를 들어:

- 클라이언트: `10.0.0.5:54321`
- 서버: `203.0.113.10:9000`
- 프로토콜: TCP

이면, 이 TCP 연결의 5-튜플은:

$$
(\text{10.0.0.5},\ 54321,\ \text{203.0.113.10},\ 9000,\ \text{TCP})
$$

서버 입장에서는:

- 로컬: `203.0.113.10:9000`
- 원격: `10.0.0.5:54321`

으로 보인다.

---

### 5.3 여러 클라이언트가 같은 서버로 붙을 때

같은 서버 `203.0.113.10:9000` 에 여러 클라이언트가 접속하면:

- 각 클라이언트는 **다른 src_IP 또는 src_port** 를 사용한다.

예:

1. 클라이언트 A: `10.0.0.5:54321` → `203.0.113.10:9000`
2. 클라이언트 B: `10.0.0.6:54321` → `203.0.113.10:9000`
3. 클라이언트 C: `10.0.0.5:54322` → `203.0.113.10:9000`

5-튜플은 각각:

1. $$(10.0.0.5,\ 54321,\ 203.0.113.10,\ 9000,\ \text{TCP})$$
2. $$(10.0.0.6,\ 54321,\ 203.0.113.10,\ 9000,\ \text{TCP})$$
3. $$(10.0.0.5,\ 54322,\ 203.0.113.10,\ 9000,\ \text{TCP})$$

서버 입장에서는:

- **리스닝 소켓**: `(203.0.113.10, 9000, TCP)`
- **연결 소켓**: 위 세 개와 같은 서로 다른 5-튜플을 가진 소켓 세 개.

즉, 서버 한 프로세스가 하나의 리스닝 소켓만 가지고도  
**다수의 연결 소켓**을 통해 여러 클라이언트와 동시에 통신한다.

---

## 6. 포트(16비트)와 Ephemeral Port

### 6.1 포트 범위와 역할

포트 번호는 0~65535(16비트) 범위다.

$$
0 \leq \text{port} \leq 65535
$$

- **Well-known ports (0–1023)**:
  - HTTP(80), HTTPS(443), SSH(22) 등
  - 일반적으로 **특권 포트**로 취급되어 root 권한이나 특수 권한이 필요하다.
- **Registered ports (1024–49151)**:
  - 여러 공식 서비스들이 이 구간을 사용하도록 등록되어 있다.
- **Dynamic/Ephemeral ports (49152–65535)**:
  - 보통 클라이언트 측에서 **임시(에페메랄) 포트**로 사용된다.
  - OS마다 실제 사용 범위는 설정에 따라 달라질 수 있지만,
    IANA 권고는 이 범위를 에페메랄로 쓰는 것이다.

---

### 6.2 클라이언트 connect() 시 포트 할당

클라이언트 코드:

```cpp
int fd = ::socket(AF_INET, SOCK_STREAM, 0);
::connect(fd, (sockaddr*)&addr, sizeof(addr));
```

를 호출하면:

- `bind()` 를 따로 하지 않았더라도,
- 커널은 **사용 가능한 에페메랄 포트**를 하나 골라 `src_port` 로 설정한다.
- 이 에페메랄 포트는:
  - 같은 `(dst_IP, dst_port, protocol)` 조합으로 여러 연결을 만들 때  
    **서로 다른 값**으로 할당된다.

만약 응용에서 소스 포트를 직접 제어하고 싶다면:

- `connect()` 전에 `bind()` 를 사용해 `(로컬 IP, 로컬 포트)`를 명시적으로 고정할 수 있다.
- 멀티홈(여러 NIC/여러 IP) 환경에서 **특정 NIC로만 나가고 싶을 때** 자주 사용한다.

---

## 7. 서버/리스닝 소켓 vs 연결 소켓의 5-튜플 관점

### 7.1 리스닝 소켓: (로컬 IP, 로컬 포트, 프로토콜)

TCP 서버의 리스닝 소켓은:

- 일반적으로 다음 정보만을 갖는다.

$$
(\text{local\_IP},\ \text{local\_port},\ \text{protocol})
$$

예:

- `(0.0.0.0, 9000, TCP)`  
  → 이 호스트의 **모든 IPv4 주소**에 대해 9000 포트로 들어오는 연결을 받겠다는 의미.
- `(::, 9000, TCP)`  
  → 모든 IPv6 주소에 대해 9000 포트.

아직 **원격 IP/포트**는 정해져 있지 않다.

---

### 7.2 accept() 이후의 연결 소켓: 완전한 5-튜플

`int cfd = ::accept(ls, ...)` 가 성공하면:

- 새로 만들어진 소켓 `cfd` 는 하나의 TCP 연결(세션)을 대표한다.
- 이 연결 소켓은 **완전한 5-튜플**을 가진다.

$$
(\text{local\_IP},\ \text{local\_port},\ \text{remote\_IP},\ \text{remote\_port},\ \text{TCP})
$$

예:

- 리스닝: `(0.0.0.0, 9000, TCP)`
- 클라이언트 A가 `10.0.0.5:54321` 에서 접속했다면:
  - 연결 소켓 A: `(203.0.113.10, 9000, 10.0.0.5, 54321, TCP)`
- 클라이언트 B가 `198.51.100.20:60000` 에서 접속한다면:
  - 연결 소켓 B: `(203.0.113.10, 9000, 198.51.100.20, 60000, TCP)`

리스닝 소켓은 항상 하나지만,  
**연결 소켓은 클라이언트 수만큼 늘어난다.**

---

### 7.3 0.0.0.0:9000 + 여러 NIC에서의 로컬 IP

서버가 `0.0.0.0:9000` 으로 리슨하고, 호스트에 NIC가 여러 개 있어:

- `10.0.0.10` (내부망)
- `203.0.113.10` (공인 IP)

를 갖고 있다고 하자.

- 내부망 클라이언트가 `10.0.0.10:9000` 으로 접속하면:
  - 해당 연결 소켓의 `local_IP` 는 `10.0.0.10` 이 된다.
- 외부 클라이언트가 `203.0.113.10:9000` 으로 접속하면:
  - 해당 연결 소켓의 `local_IP` 는 `203.0.113.10` 이 된다.

즉, 같은 리스닝 소켓에서 나온 연결 소켓이라도:

- **로컬 IP** 가 상황에 따라 달라질 수 있다.
- 이를 `getsockname()` 으로 확인해보면 직접 확인 가능하다(실습은 뒤에서 자세히).

---

## 8. NAT가 끼면 5-튜플은 관찰자에 따라 달라진다

### 8.1 NAT 기본 시나리오

가정:

- 클라이언트: 사설망 `192.168.1.10:55001`
- NAT 라우터의 공인 IP: `198.51.100.77`
- 서버: `203.0.113.10:9000`

클라이언트는 `connect("203.0.113.10","9000")` 을 호출한다.

- 클라이언트 관점 5-튜플:

$$
(\text{192.168.1.10},\ 55001,\ \text{203.0.113.10},\ 9000,\ \text{TCP})
$$

NAT 라우터는:

- **소스 IP/포트**를 자신의 공인 IP와 새 포트로 바꾼다.
  - 예: `198.51.100.77:62000`
- 내부적으로 “이 포트는 원래 `192.168.1.10:55001` 이다”라는 매핑 테이블을 유지한다.

서버 관점에서는:

$$
(\text{198.51.100.77},\ 62000,\ \text{203.0.113.10},\ 9000,\ \text{TCP})
$$

이렇게 보인다.

즉,

- **클라이언트 관점 5-튜플**과
- **서버 관점 5-튜플**이 다르다.

NAT는 이 둘을 **연결 테이블**로 매핑하면서,  
양쪽에서 오는 패킷을 적절히 변환/전달한다.

---

### 8.2 여러 연결이 NAT를 통해 나갈 때

동일 클라이언트 `192.168.1.10` 이:

- 같은 서버 `203.0.113.10:9000` 에 여러 번 연결하면,

클라이언트 측 5-튜플:

1. $$(192.168.1.10,\ 55001,\ 203.0.113.10,\ 9000,\ \text{TCP})$$
2. $$(192.168.1.10,\ 55002,\ 203.0.113.10,\ 9000,\ \text{TCP})$$

NAT는 이를 각각:

1. $$(198.51.100.77,\ 62000,\ 203.0.113.10,\ 9000,\ \text{TCP})$$
2. $$(198.51.100.77,\ 62001,\ 203.0.113.10,\ 9000,\ \text{TCP})$$

로 변환할 수 있다.

서버 입장에서는:

- “서로 다른 5-튜플”로 구분되는 두 연결로 보인다.

---

## 9. IPv6에서의 5-튜플, 링크-로컬, 스코프 ID

### 9.1 IPv6 주소와 5-튜플

IPv6 주소는 128비트 길이이며, 예시는 다음과 같다.

- `2001:db8:1::2`
- `fe80::1` (링크-로컬)

IPv6에서 TCP 연결 5-튜플은 여전히 같은 형식이다.

$$
(\text{src\_IPv6},\ \text{src\_port},\ \text{dst\_IPv6},\ \text{dst\_port},\ \text{TCP})
$$

차이는 **주소 길이와 표현법**뿐이다.

---

### 9.2 링크-로컬 주소와 스코프 ID

IPv6 링크-로컬 주소 예:

- `fe80::1234` (실제 사용 시에는 인터페이스가 필요)

링크-로컬 주소는 **링크(인터페이스)마다 중복**될 수 있기 때문에:

- 실제 사용 시: `fe80::1234%eth0` 와 같이 **스코프 ID(인터페이스 이름/번호)** 를 붙여야 한다.
- 커널 내부에서는:
  - 주소 + 인터페이스 ID가 함께 5-튜플 식별에 영향을 줄 수 있다.

예를 들어, `eth0` 과 `eth1` 두 인터페이스 모두에서 링크-로컬 주소가 설정되어 있고:

- `fe80::1234%eth0:5000` → `fe80::5678%eth0:6000`
- `fe80::1234%eth1:5000` → `fe80::5678%eth1:6000`

은 네트워크적으로 서로 다른 경로를 의미한다.

---

### 9.3 듀얼스택, IPv4-mapped, IPV6_V6ONLY

듀얼스택 서버는:

- `::` (IPv6 any) 주소로 리슨하면서,
- IPv4-mapped 주소(`::ffff:192.0.2.10` 형태)를 통해 IPv4 클라이언트도 받는 방식이 있다.

이 때:

- `IPV6_V6ONLY` 소켓 옵션을 어떻게 설정하느냐에 따라:
  - IPv4-mapped를 허용하거나,
  - **오직 IPv6만** 받도록 강제할 수 있다.

실무에서는:

- 정책을 명확히 하기 위해 `IPV6_V6ONLY` 를 명시적으로 설정하고,
- IPv4는 별도의 리스닝 소켓으로 관리하는 경우가 많다.

---

## 10. TCP vs UDP: 5-튜플이 의미하는 “세션”의 차이

### 10.1 TCP: 상태 있는 세션

TCP는:

- **3-way handshake**(SYN → SYN/ACK → ACK)로 연결 수립.
- 이후 **각 연결 소켓**은 다음 상태를 가진다.
  - 시퀀스 번호/ACK 번호
  - 송수신 윈도우
  - 재전송 타이머
  - 혼잡 제어 변수
  - 상태(State): ESTABLISHED, FIN\_WAIT\_1, TIME\_WAIT, …

따라서 TCP에서 **5-튜플**은:

- **하나의 세션**을 강하게 정의하는 키이다.
- 같은 5-튜플을 가진 두 개의 동시에 살아 있는 연결은 존재할 수 없다.

---

### 10.2 UDP: 상태 없는 데이터그램, 그러나 5-튜플은 여전히 의미 있음

UDP는:

- 연결 수립/종료 개념 없이, 그때그때 데이터그램을 전송한다.
- 프로토콜 레벨에서는 세션 상태를 유지하지 않는다.

하지만:

- 커널의 라우팅/필터링/통계/로깅 관점에서
  - UDP 패킷 흐름도 **5-튜플**로 구분될 수 있다.
- `connect()` 된 UDP 소켓은:
  - “목적지 (IP, Port)를 고정”하고
  - `send()/recv()` 를 사용해 편리하게 I/O를 할 수 있게 한다.
  - 여전히 핸드셰이크/재전송은 없지만,  
    ICMP 오류 보고를 연결된 소켓에 잘 전달받을 수 있다.

결론:

- TCP에선 **5-튜플 = 세션** (매우 강한 의미)
- UDP에선 **5-튜플 = 패킷 흐름을 구분하는 레이블** 정도의 의미

---

## 11. 충돌/중복 방지: 5-튜플의 유일성

커널은 하나의 호스트에서:

- 동일한  
  $$
  (\text{local\_IP},\ \text{local\_port},\ \text{remote\_IP},\ \text{remote\_port},\ \text{protocol})
  $$
  5-튜플을 가진 **두 개의 동시에 살아 있는 TCP 연결**을 허용하지 않는다.

이는 다음을 의미한다.

- 동일 호스트에서:
  - 같은 클라이언트/서버 조합으로 **동시에 여러 연결**을 만들고 싶다면,
    - 보통 **다른 ephemeral port** 를 사용하게 된다.
- 서버 입장에서는:
  - 로컬 `(IP, port)` 가 같더라도,
  - 원격 `(IP, port)` 가 다르면 각기 다른 연결로 관리한다.

예외적으로:

- TIME\_WAIT 상태 등 종료 직후에는 같은 5-튜플 재사용이 제한되며,
- 이 때 `SO_REUSEADDR` 같은 옵션으로 일부 완화를 할 수 있다(주의 필요).

---

## 12. 실패/경계 상황에서 5-튜플 읽기

5-튜플을 잘 이해하면, **이상 상황**을 해석하는 데 큰 도움이 된다.

### 12.1 SYN flood

- 공격자가 대량의 SYN 패킷을 보내고 ACK를 보내지 않는 공격.
- 서버 입장에서는:
  - 리스닝 소켓에 대한 **SYN-RECV** 상태가 매우 많이 늘어날 수 있다.
  - 이 상태는 아직 **완전히 성립되지 않은 5-튜플 후보** 들이다.
- 백로그 큐가 가득 차면:
  - 정상 클라이언트의 SYN이 드롭되고,
  - 서비스 가용성이 떨어진다.

`ss -tan state syn-recv` 같은 명령으로 이런 상태를 감지할 수 있다.

---

### 12.2 TIME_WAIT

- TCP 연결 종료 후, 보통 **클라이언트 쪽**에서 TIME\_WAIT 상태가 오래 남는다.
- 같은 5-튜플로 새 연결을 바로 만들고 싶어도,
  - TIME\_WAIT 때문에 잠시 동안 막힐 수 있다.
- 이 때 `SO_REUSEADDR` 를 적절히 설정하면:
  - 서버 재기동 시 **같은 포트로 빠르게 리슨** 할 수 있게 도와준다.
- 다만, 이 옵션의 의미는 OS 계열마다 미묘하게 다를 수 있으므로
  - 무분별한 사용은 위험하다.

---

### 12.3 포트 고갈 (Ephemeral Port Exhaustion)

대규모 아웃바운드 연결(예: 프록시, 로드테스터)에서:

- 에페메랄 포트 범위가 좁으면,
  - 잠시 동안 너무 많은 연결을 만들 때 **새로운 연결 시도 실패**가 발생할 수 있다.
- 커널 설정(예: `ip_local_port_range`)을 넓히거나,
  - 애플리케이션에서 연결 생명주기를 조절해 해결할 수 있다.

이때도 `ss` 로 현재 사용 중인 포트/5-튜플 분포를 확인하면, 진단에 큰 도움이 된다.

---

## 13. 실습: 실제 5-튜플을 코드와 도구로 확인하기

이제 이론을 실제로 보는 시간을 갖자.

### 13.1 C++23 예제: getsockname / getpeername로 5-튜플 출력

아래 코드는:

- 지정한 호스트/포트로 TCP 연결을 맺고,
- `getsockname()` 으로 로컬 (IP, 포트),
- `getpeername()` 으로 피어 (IP, 포트)를 출력한다.

```cpp
// print_tuple.cpp — TCP 연결에서 5-튜플 일부를 출력하는 예제
// 빌드: g++ -std=c++23 -O2 print_tuple.cpp -o print_tuple

#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>

#include <cstdio>
#include <cstring>
#include <string>

static std::string to_string(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{};
    char serv[NI_MAXSERV]{};
    if (getnameinfo(sa, salen, host, sizeof(host), serv, sizeof(serv),
                    NI_NUMERICHOST | NI_NUMERICSERV) == 0) {
        return std::string(host) + ":" + std::string(serv);
    }
    return "(unknown)";
}

int main(int argc, char** argv) {
    if (argc != 3) {
        std::fprintf(stderr, "usage: %s <host> <port>\n", argv[0]);
        return 1;
    }

    const char* host = argv[1];
    const char* port = argv[2];

    addrinfo hints{};
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    addrinfo* res = nullptr;
    int rc = ::getaddrinfo(host, port, &hints, &res);
    if (rc != 0) {
        std::fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rc));
        return 2;
    }

    int s = -1;
    for (auto* ai = res; ai; ai = ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;

        if (::connect(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            break;
        }

        ::close(s);
        s = -1;
    }

    if (s < 0) {
        std::fprintf(stderr, "connect failed\n");
        ::freeaddrinfo(res);
        return 3;
    }

    sockaddr_storage lsa{};
    sockaddr_storage psa{};
    socklen_t llen = sizeof(lsa);
    socklen_t plen = sizeof(psa);

    if (::getsockname(s, (sockaddr*)&lsa, &llen) == 0 &&
        ::getpeername(s, (sockaddr*)&psa, &plen) == 0) {

        std::printf("LOCAL : %s\n", to_string((sockaddr*)&lsa, llen).c_str());
        std::printf("PEER  : %s\n", to_string((sockaddr*)&psa, plen).c_str());
        std::printf("PROTO : TCP\n");
    } else {
        std::perror("getsockname/getpeername");
    }

    ::freeaddrinfo(res);
    ::close(s);
    return 0;
}
```

#### 실행 예시

```bash
./print_tuple 203.0.113.10 9000
# 예시 출력
# LOCAL : 192.168.1.10:55001
# PEER  : 203.0.113.10:9000
# PROTO : TCP
```

NAT 환경에서:

- 클라이언트 측에서는 `LOCAL` 이 `192.168.1.10:55001` 로 보이지만,
- 서버 측에서 비슷한 코드를 실행하면,
  - `PEER` 가 `198.51.100.77:62000` 같은 값으로 보일 수 있다  
    (NAT 라우터가 변경한 주소/포트).

---

### 13.2 서버에서 accept 직후 5-튜플 찍기

간단한 포인트는:

- 리스닝 소켓은 `(local_IP, local_port)` 만 의미 있고,
- `accept()` 된 소켓은 원격 정보까지 포함한다는 점이다.

```cpp
// server_print_tuple.cpp — accept 후 로컬/피어 출력
// 빌드: g++ -std=c++23 -O2 server_print_tuple.cpp -o server_print_tuple

#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>

#include <cstdio>
#include <cstring>
#include <string>

static std::string to_string(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{};
    char serv[NI_MAXSERV]{};
    if (getnameinfo(sa, salen, host, sizeof(host), serv, sizeof(serv),
                    NI_NUMERICHOST | NI_NUMERICSERV) == 0) {
        return std::string(host) + ":" + std::string(serv);
    }
    return "(unknown)";
}

int main() {
    addrinfo hints{}, *res = nullptr;
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG;

    if (getaddrinfo(nullptr, "9000", &hints, &res) != 0) {
        std::perror("getaddrinfo");
        return 1;
    }

    int ls = -1;
    for (auto* ai = res; ai; ai = ai->ai_next) {
        ls = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (ls < 0) continue;

        int yes = 1;
        ::setsockopt(ls, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

        if (::bind(ls, ai->ai_addr, ai->ai_addrlen) == 0 &&
            ::listen(ls, 128) == 0) {
            break;
        }

        ::close(ls);
        ls = -1;
    }
    freeaddrinfo(res);

    if (ls < 0) {
        std::fprintf(stderr, "listen failed\n");
        return 2;
    }

    std::printf("[server] listening on port 9000\n");

    for (;;) {
        sockaddr_storage peer{};
        socklen_t plen = sizeof(peer);
        int cfd = ::accept(ls, (sockaddr*)&peer, &plen);
        if (cfd < 0) {
            std::perror("accept");
            continue;
        }

        // 연결 소켓의 로컬/피어 주소
        sockaddr_storage lsa{};
        socklen_t llen = sizeof(lsa);
        if (::getsockname(cfd, (sockaddr*)&lsa, &llen) == 0) {
            std::printf("LOCAL : %s\n", to_string((sockaddr*)&lsa, llen).c_str());
        } else {
            std::perror("getsockname");
        }
        std::printf("PEER  : %s\n", to_string((sockaddr*)&peer, plen).c_str());
        std::printf("PROTO : TCP\n\n");

        ::close(cfd);
    }
}
```

- 이 서버를 띄우고,
- 여러 클라이언트(같은/다른 IP, 다른 포트)에서 접속하면,
- 매번 다른 5-튜플이 찍히는 것을 볼 수 있다.

---

### 13.3 `ss` / `netstat` 로 커널 연결 테이블 확인

서버에서 현재 열려 있는 연결들을 보기:

```bash
# 9000 포트 관련 TCP 연결들 보기
ss -tan '( sport = :9000 )'

# ESTABLISHED 상태만
ss -tan state established '( sport = :9000 )'
```

예시 출력(요지):

```text
State   Recv-Q Send-Q Local Address:Port   Peer Address:Port
LISTEN  0      128    0.0.0.0:9000        0.0.0.0:*
ESTAB   0      0      203.0.113.10:9000   10.0.0.5:54321
ESTAB   0      0      203.0.113.10:9000   10.0.0.6:54321
```

각 행이 곧 하나의 **5-튜플**에 해당한다(프로토콜=TCP는 묵시적).

---

### 13.4 `tcpdump` 필터로 5-튜플 흐름 추적

```bash
# 서버 9000 포트로 오가는 모든 TCP 트래픽
sudo tcpdump -i any tcp and port 9000 -n -vv

# 특정 클라이언트/포트에서 오는 트래픽만
sudo tcpdump -i any 'tcp and src 10.0.0.5 and src port 54321 and dst port 9000' -n -vv
```

각 패킷 줄에 대략 다음과 같은 형식이 찍힌다.

```text
10.0.0.5.54321 > 203.0.113.10.9000: Flags [S], seq ...
203.0.113.10.9000 > 10.0.0.5.54321: Flags [S.], seq ...
```

여기서:

- `10.0.0.5.54321` = src\_IP.src\_port
- `203.0.113.10.9000` = dst\_IP.dst\_port

즉, **5-튜플의 일부**를 그대로 보여준다고 봐도 좋다.

---

## 14. 미니 퀴즈 & 과제 정리

이제 여기까지 내용을 바탕으로 다음 질문들을 스스로 답해 보자.

1) 서버 `0.0.0.0:9000` 으로 리슨 중일 때, 같은 서버에서  
   - 한 클라이언트는 `127.0.0.1:9000` 으로,  
   - 다른 클라이언트는 `10.0.0.5:9000` 으로 접속하면,  
   **각 연결 소켓의 로컬 IP**는 어떻게 달라질까?

- 힌트:
  - 루프백에서 온 연결은 `local_IP = 127.0.0.1`
  - NIC를 통해 온 연결은 `local_IP = 10.0.0.5`  
  가 된다.

2) NAT 뒤의 클라이언트가 같은 서버에 두 개의 연결을 연속으로 맺었다.  
   서버에서 보면 **두 연결의 5-튜플 차이점**은 무엇일까?

- 힌트:
  - src\_IP는 NAT의 공인 IP로 동일하지만,
  - src\_port (NAT가 매긴 외부 포트)는 서로 다르다.

3) IPv6 링크-로컬 `fe80::1234%eth0` 로 서버에 붙을 때,  
   **스코프 ID**는 연결의 5-튜플에 어떤 식으로 반영될까?

- 힌트:
  - 커널 내부 식별에는 “어떤 인터페이스에서 온 것인지”가 포함되고,
  - 사용자 공간 문자열 표기에서는 `%eth0` 와 같이 표현된다.

---

## 15. 전체 정리

마지막으로, 이 글에서 확보해야 할 핵심 포인트를 다시 모아 보자.

1. **프로토콜 스택 구조**
   - L2: 프레임, MAC, MTU
   - L3: IP 패킷, 라우팅, 단편화/PMTUD
   - L4: TCP 세그먼트, UDP 데이터그램, 포트, 신뢰/흐름/혼잡 제어
   - L5~L7: HTTP/TLS/SSH 등 응용 프로토콜

2. **소켓의 정체**
   - 소켓 API는 **전송 계층(L4)**의 기능을 커널이 제공하는 인터페이스.
   - TCP 소켓 = **바이트 스트림 엔드포인트**
   - UDP 소켓 = **데이터그램 엔드포인트**

3. **send/recv와 계층 흐름**
   - `send()` 시: L7 → L4 → L3 → L2 → L1
   - `recv()` 시: L1 → L2 → L3 → L4 → L7
   - 이 흐름은 `strace` 와 `tcpdump` 로 함께 관찰할 수 있다.

4. **MTU/MSS와 세그먼트 분할**
   - MTU, MSS 관계  
     $$ \text{MSS} \approx \text{MTU} - \text{IP헤더} - \text{TCP헤더} $$
   - `send()` 한 번이 여러 TCP 세그먼트로 나뉘기도 하고,
   - 반대로 여러 `send()` 가 하나의 세그먼트로 묶이기도 한다.

5. **소켓 디스크립터와 리스닝 vs 연결 소켓**
   - 소켓은 fd로 표현되는 커널 객체.
   - 리스닝 소켓은 `(local_IP, local_port, proto)` 와 대기열을 관리.
   - `accept()`된 연결 소켓은 **완전한 5-튜플**을 가지는 세션.

6. **5-튜플로 연결을 읽는 법**
   - TCP 연결 식별자:
     $$
     (\text{src\_IP},\ \text{src\_port},\ \text{dst\_IP},\ \text{dst\_port},\ \text{protocol})
     $$
   - 서버는 하나의 리스닝 소켓으로도 다수의 5-튜플을 가진 연결 소켓을 동시에 관리한다.
   - NAT/IPv6/듀얼스택 환경에서도 5-튜플 관점은 그대로 유지되지만,
     관찰자 관점에 따라 값이 달라질 수 있다.

7. **실무에서의 중요성**
   - 장애/성능 문제 발생 시:
     - `ss`, `tcpdump`, `lsof`, `strace` 를 함께 사용해
     - “어떤 5-튜플들에 문제가 집중되는지”,
     - “큐 길이/버퍼/상태가 어떤지” 를 보는 습관이 중요하다.
   - 소켓 API를 단순히 “스트림 읽기/쓰기 함수”로만 보지 말고,
     **커널 네트워킹 스택 전체를 관통하는 인터페이스**로 이해하면  
     프레임워크/라이브러리 상위 추상화도 훨씬 잘 다룰 수 있다.