---
layout: post
title: 소켓프로그래밍 - L2~L7과 소켓의 위치
date: 2025-09-13 23:25:23 +0900
category: 소켓프로그래밍
---
## 1. 프로토콜 스택 한눈에: L2~L7과 **소켓**의 위치

> 핵심 한 줄: **소켓은 L4(전송 계층)의 엔드포인트를 다루는 커널 객체**이고, 응용이 `send/recv` 하는 순간 **L7 → L4 → L3 → L2**로 내려가며, 반대로 수신은 **L2 → L3 → L4 → L7**로 올라옵니다.

### 1.1 OSI / TCP-IP 스택 빠르게 잡기

- **L2: 데이터 링크(이더넷/무선랜)**
  - 단위: **프레임(Frame)**  
  - 주소: **MAC 주소** (예: `02:42:ac:11:00:02`)
  - 최대 전송 단위: **MTU**(보통 Ethernet = 1500 바이트)
  - 부가: VLAN(Tag, 802.1Q), 점프: 스위치

- **L3: 네트워크(IP)**
  - 단위: **패킷(Packet)**  
  - 주소: IPv4(32비트, 예 `192.0.2.10`), IPv6(128비트, 예 `2001:db8::1`)
  - 라우팅: 라우터가 목적지 IP 기반으로 다음 홉 결정
  - 단편화(IPv4) / PMTUD(경로 MTU 발견) 등

- **L4: 전송(TCP/UDP/ICMP 등)**
  - 단위: **세그먼트(TCP)** / **데이터그램(UDP)**
  - **포트(PORT)** 번호로 같은 호스트 내 프로세스/서비스 구분
  - **TCP**: 연결 지향(3-way), 신뢰/순서/흐름/혼잡 제어, **바이트 스트림**
  - **UDP**: 비연결, 경계 보존, 손실/순서불보장

- **L5~L7: 세션/표현/응용(실무에선 ‘응용계층’으로 뭉뚱그림)**
  - 프로토콜: HTTP, TLS, gRPC, DNS, SSH 등
  - 메시지/직렬화/상태 머신/보안 정책

**소켓의 위치**  
- **소켓 API**는 **L4(전송 계층)** 의 기능을 **운영체제 커널이 제공하는 인터페이스**로 노출한 것입니다.  
- UDP 소켓은 **데이터그램**(메시지 경계 보존), TCP 소켓은 **바이트 스트림**(경계 없음)을 다룹니다.  
- 응용이 `send()` 하면 커널은 필요한 L4/L3/L2 헤더를 붙여 NIC로 내보내고, `recv()` 때는 그 역으로 헤더를 벗겨 **payload**만 응용으로 넘깁니다.

---

### 1.2 위에서 아래로(송신), 아래에서 위로(수신) — 실제 흐름

#### 송신 경로 (응용 → 네트워크)
1) **응용(L7)**: `send()`로 payload를 커널에 건넴  
2) **L4(TCP/UDP)**: 포트/시퀀스/체크섬 등 **전송 헤더** 부착  
3) **L3(IP)**: 소스/목적지 IP, TTL/HopLimit, 조각화/PMTUD 고려  
4) **L2(Ethernet/Wi-Fi)**: 소스/목적지 MAC, VLAN Tag(있으면) 포함  
5) **PHY**를 통해 전송

#### 수신 경로 (네트워크 → 응용)
1) **L2** 프레임 수신 → MAC 필터 통과  
2) **L3** 목적지 IP 확인 → 라우팅/필터링 → 상위 프로토콜(TCP/UDP)로 디밀기  
3) **L4** 포트/연결 테이블로 **대상 소켓** 식별 → 재정렬/검증 후 **수신 버퍼**에 적재  
4) **응용**이 `recv()`로 가져감

> **관측 Tip**: `strace -e trace=network` 로 프로세스의 `send/recv` 호출을 보고, 동시에 `tcpdump` 로 인터페이스의 패킷을 보면 **L7 호출 ↔ L2~L4 패킷** 상관을 체감할 수 있습니다.

---

### 1.3 MTU, MSS, 세그먼트 분할(스트림에서 “패킷”이 보이는 이유)

- **MTU**: L2 프레임의 payload 한계(이더넷 1500)  
- **IP 헤더**(IPv4 20B 기본) + **TCP 헤더**(20B 기본)를 제하면 **MSS**(TCP payload 최대)이 결정됨  
- 응용은 1MB `send()`를 한 번 호출해도, TCP는 적절한 **MSS 단위로 쪼개어** 여러 세그먼트로 내보냅니다.  
- 그래서 Wireshark에서 **“패킷이 보이는”** 것이고, 응용은 그 사실을 **모른 채 바이트 스트림**만 다룹니다.

---

### 1.4 소켓 디스크립터 = 커널의 엔드포인트 핸들

- 리눅스/유닉스에서 소켓은 **파일 디스크립터(fd)**. `read/write/close`가 적용됩니다.
- **리스닝 소켓**(서버)은 `(로컬 IP, 로컬 포트, 프로토콜)` 을 소유하고 대기열(listen/accept queue)을 관리합니다.
- **연결 소켓**(TCP 수립 후)은 **5-튜플**로 구별되는 “회선”을 대표합니다(아래 2장에서 상세).

---

### 1.5 실습: 같은 메시지를 여러 “패킷”으로 확인하기

1) 최소 TCP 에코 서버/클라이언트(프레이밍 4B+payload)로 **64KB** 메시지를 보냅니다.  
2) **tcpdump** 캡처:
   ```bash
   sudo tcpdump -i lo tcp port 9000 -n -vv -w trace.pcap
   ```
3) Wireshark로 `trace.pcap`을 열고 `Follow TCP Stream` 대신 **Packet List** 에서 **TCP segment of a reassembled PDU** 표시를 확인합니다.  
   - 한 번의 `send()`가 **다수의 TCP 세그먼트**로 나뉘어 전송되는 모습을 볼 수 있습니다.
   - 반대로 커널이 합치면, 작은 `send()` 여러 개가 **하나의 세그먼트**로 묶여 나가기도 합니다(Nagle/OS버퍼 상태 등).

---

## 2. 주소/포트/프로토콜: **5-튜플**로 연결을 식별

> TCP 연결은 **양 끝의 IP/PORT**와 **프로토콜**로 유일하게 구별됩니다. 이때 **NAT** 환경에서는 “내가 보는 5-튜플”과 “원격이 보는 5-튜플”이 다를 수 있습니다.

### 2.1 정의

- **TCP 연결 식별자**:
  $$
  (\text{src\_IP},\ \text{src\_port},\ \text{dst\_IP},\ \text{dst\_port},\ \text{protocol})
  $$
- 일반적으로 프로토콜은 TCP로 고정하니, 실무에서는 **4-튜플**처럼 부르기도 합니다:
  $$
  (\text{src\_IP},\ \text{src\_port},\ \text{dst\_IP},\ \text{dst\_port})
  $$

#### 예시
- 클라이언트: `10.0.0.5:54321` → 서버: `203.0.113.10:9000`, 프로토콜 TCP  
  $$
  (\text{10.0.0.5},\ 54321,\ \text{203.0.113.10},\ 9000,\ \text{TCP})
  $$

- 같은 서버/포트에 **여러 클라이언트**가 접속하면, **src\_IP/src\_port**가 모두 달라 **각기 다른 5-튜플**을 이룹니다. 서버 입장에선 **동시에 다수의 연결 소켓**을 갖게 됩니다.

---

### 2.2 포트(16비트)와 **ephemeral port**

- 포트 범위: $$0 \leq \text{port} \leq 65535$$  
  - **Well-known**(0–1023): root/특권 필요(예: 80, 443, 22)  
  - **Registered**(1024–49151)  
  - **Dynamic/Ephemeral**(49152–65535: OS마다 다름)
- **클라이언트 `connect()`** 시 **임시 포트**가 자동 할당됩니다(직접 `bind()`로 고정 가능).  
- 동시에 동일 서버:포트로 여러 연결을 맺을 때, 클라이언트는 **각기 다른 ephemeral port**로 다중 연결을 성립합니다.

---

### 2.3 서버/리스닝 소켓 vs 연결 소켓의 5-튜플 관점

- **리스닝 소켓**은 일반적으로 `(로컬_IP, 로컬_포트, TCP)` 만 갖습니다(원격이 정해지지 않음).  
- `accept()` 가 반환하는 **연결 소켓**은 비로소 완전한 **5-튜플**을 가집니다:
  $$
  (\text{local\_IP},\ \text{local\_port},\ \text{remote\_IP},\ \text{remote\_port},\ \text{TCP})
  $$
- 서버가 여러 NIC/IP를 갖고 `0.0.0.0:9000` 으로 리슨하면, 실제 연결 소켓마다 **선택된 로컬 IP**가 달라질 수 있습니다(라우팅/NIC 선택).

---

### 2.4 NAT가 끼면 5-튜플은 “관찰자에 따라 달라진다”

- 가정: 클라이언트는 사설망 `192.168.1.10:55001` 에서 인터넷 서버 `203.0.113.10:9000` 로 접속.  
- NAT 라우터는 **소스 변환**을 수행:  
  - 서버가 보는 클라이언트 주소: `198.51.100.77:62000` (NAT의 공인IP와 NAT가 매긴 포트)  
- 즉, **클라이언트 관점 5-튜플**과 **서버 관점 5-튜플**이 다릅니다. NAT는 **연결 테이블**로 매핑을 유지합니다.

---

### 2.5 실습: 실제 **5-튜플**을 코드/도구로 확인하기

#### 2.5.1 C++23: `getsockname`/`getpeername` 로 로컬/피어 5-튜플 출력
```cpp
// print_tuple.cpp — 연결 소켓에서 5-튜플 찍어보기 (요지)
// 빌드: g++ -std=c++23 -O2 print_tuple.cpp -o print_tuple
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstdio>
#include <cstring>
#include <string>

static std::string to_string(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{}, serv[NI_MAXSERV]{};
    if (getnameinfo(sa, salen, host, sizeof(host), serv, sizeof(serv),
                    NI_NUMERICHOST | NI_NUMERICSERV) == 0) {
        return std::string(host) + ":" + serv;
    }
    return "(unknown)";
}

int main(int argc, char** argv) {
    if (argc != 3) { std::fprintf(stderr, "use: %s <host> <port>\n", argv[0]); return 1; }

    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM;
    if (getaddrinfo(argv[1], argv[2], &hints, &res)!=0) return 2;

    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) break;
        ::close(s); s=-1;
    }
    if (s<0) return 3;

    sockaddr_storage lsa{}, psa{}; socklen_t llen=sizeof(lsa), plen=sizeof(psa);
    if (::getsockname(s, (sockaddr*)&lsa, &llen)==0 &&
        ::getpeername(s, (sockaddr*)&psa, &plen)==0) {
        std::printf("LOCAL : %s\n", to_string((sockaddr*)&lsa, llen).c_str());
        std::printf("PEER  : %s\n", to_string((sockaddr*)&psa, plen).c_str());
        std::printf("PROTO : TCP\n");
    }
    ::close(s);
    return 0;
}
```

- 실행 예:
  ```bash
  ./print_tuple 203.0.113.10 9000
  # 출력 (예시)
  # LOCAL : 192.168.1.10:55001
  # PEER  : 203.0.113.10:9000
  # PROTO : TCP
  ```
- NAT 환경이라면, 서버 측에서 같은 기능을 실행하면 **PEER** 가 `198.51.100.77:62000` 처럼 **NAT 변환된 포트/주소**로 보일 수 있습니다.

#### 2.5.2 `ss`/`netstat` 로 커널 연결 테이블 확인
```bash
# 서버에서 9000 포트 연결들을 본다
ss -tan '( sport = :9000 )'
# 또는
ss -tan state established '( sport = :9000 )'
```
- `Recv-Q/Send-Q`, `Local Address:Port`, `Peer Address:Port` 로 **여러 5-튜플**을 한눈에 확인 가능.

#### 2.5.3 `tcpdump` 필터로 5-튜플 추적
```bash
# 서버 9000 포트로 오가는 TCP만 본다
sudo tcpdump -i any tcp and port 9000 -n -vv

# 특정 클라이언트:포트 조합만
sudo tcpdump -i any 'tcp and src 10.0.0.5 and src port 54321 and dst port 9000' -n -vv
```
- 패킷 줄마다 `SRC_IP.SRC_PORT > DST_IP.DST_PORT` 형태가 찍혀 **5-튜플의 일부(프로토콜=TCP는 묵시)** 를 그대로 관찰할 수 있습니다.

---

### 2.6 IPv6에서의 5-튜플, 링크-로컬, 스코프 ID

- **IPv6 주소**는 128비트(예: `2001:db8:1::2`). 포트는 동일하게 16비트.
- **링크-로컬**(예: `fe80::1%eth0`) 주소는 **스코프 ID**가 필요합니다(인터페이스를 지정).  
- 5-튜플 표현은 동일합니다:
  $$
  (\text{src\_IPv6},\ \text{src\_port},\ \text{dst\_IPv6},\ \text{dst\_port},\ \text{TCP})
  $$
- **듀얼스택** 서버는 `::`(IPv6 any) + `IPV6_V6ONLY` 옵션 여부에 따라 IPv4-mapped 접속 수용 여부가 달라질 수 있습니다.

---

### 2.7 TCP vs UDP — 5-튜플의 “세션성” 차이

- **TCP**: 3-way handshake 후 **연결 상태**(상태 머신, 시퀀스/윈도우 등)를 유지 → **5-튜플이 세션**을 강하게 정의  
- **UDP**: 연결 상태가 없지만 **커널 라우팅/필터**는 동일한 5-튜플로 패킷 흐름을 구분 가능  
  - `connect()` 된 UDP 소켓은 **목적지 고정** + ICMP 오류 수신, `send/recv` 사용 가능  
  - 그래도 **핸드셰이크/신뢰성**은 없음(응용이 별도 구현)

---

### 2.8 충돌/중복 방지: 5-튜플의 유일성

- 한 호스트에서 동일한 **(로컬IP, 로컬포트, 원격IP, 원격포트, 프로토콜)** 쌍의 **중복 연결**은 존재할 수 없습니다(이미 그 5-튜플을 가지는 연결이 있다면 새로운 3-way handshake는 다른 ephemeral port를 결과로 가져오거나 실패).  
- 서버는 다수의 클라이언트를 수용하지만, **각 연결 소켓**은 **서로 다른 5-튜플**을 가집니다.

---

### 2.9 실패/경계 상황에서 5-튜플 읽기

- **SYN flood** 시: 서버는 `(local_IP, local_port)` 리스닝 소켓 기준으로 **SYN-RECV** 상태가 많아지고, 완성된 5-튜플 연결은 제한적으로만 형성됩니다.  
- **TIME_WAIT**: 연결 종료 후 **클라이언트 쪽**에서 흔히 보임. 같은 5-튜플로 재사용이 어렵고, `SO_REUSEADDR` 로 완화(주의 필요).  
- **포트 고갈**: Outbound 대량 연결에서 ephemeral port 범위가 바닥나면 **새 연결 실패**. `net.ipv4.ip_local_port_range` 튜닝.

---

### 2.10 미니 퀴즈 & 과제

1) 서버 `0.0.0.0:9000` 로 리슨 중일 때, 동일 머신에서 `127.0.0.1` 과 `10.0.0.5` 로 각각 접속하면 **연결 소켓의 로컬 IP**는 어떻게 달라지는가?  
   - 힌트: 라우팅/선택된 NIC에 따라 **각 연결의 5-튜플**의 **local\_IP**가 달라진다.

2) NAT 뒤의 클라이언트가 서버에 두 개의 연결을 연속으로 맺었다. 서버에서 보면 **두 연결의 5-튜플 차이점**은?  
   - 보통 **src\_port**(NAT가 매긴 외부 포트)가 다르게 나타난다.

3) IPv6 링크-로컬 `fe80::1234%eth0` 로 서버에 붙으면, **스코프 ID**는 연결의 5-튜플에 어떤 식으로 반영될까?  
   - 커널 내부 식별에는 인터페이스가 포함됩니다. 사용자 공간 문자열 표기는 `%eth0` 으로 구분.

---

### 2.11 정리

- **소켓 = L4 엔드포인트 핸들**: 응용이 만지는 것은 바이트/데이터그램이지만, 실제 네트워크에는 **헤더를 덧입은 세그먼트/패킷/프레임**이 흐릅니다.  
- **5-튜플**은 TCP 연결을 유일하게 식별하는 기본 키이며, **NAT**나 **듀얼스택** 같은 현실 요소가 개입하면 “관찰자 시점”에 따라 보이는 5-튜플이 달라질 수 있습니다.  
- 실무에서는 `getsockname/getpeername`, `ss`, `tcpdump` 를 통해 **현재 열린 소켓과 패킷 흐름**을 **수치/텍스트**로 확인하는 습관이 중요합니다.
