---
layout: post
title: 디지털신호처리 - 연습문제 세트 9
date: 2025-11-22 15:25:23 +0900
category: 디지털신호처리
---
# 영향 - 연습문제

## 공통 준비 코드(모든 문제에서 사용)

### 고정소수점 반올림 함수(최근접 반올림)

```octave
function y = q_frac(x, F)
  % F: 소수부 비트 수 (Q-format의 fractional bits)
  scale = 2^F;
  y = round(x*scale)/scale;
end
```

### 함수

```octave
function y = q_trunc(x, F)
  scale = 2^F;
  y = floor(x*scale)/scale;
end
```

### 모델(정수부 비트 I 포함)

```octave
function y = q_sat(x, I, F)
  % I: 정수부 비트(부호 포함) -> 표현 가능 범위 [-2^(I-1), 2^(I-1)-2^-F]
  minv = -2^(I-1);
  maxv =  2^(I-1) - 2^(-F);
  y = min(max(x, minv), maxv);
  y = q_frac(y, F);
end
```

### 고정소수점 Direct-Form FIR 구현(곱/누산 라운딩 포함)

```octave
function y = fir_df_fixed(b, x, F)
  M = length(b)-1;
  xdel = zeros(1,M);
  y = zeros(size(x));

  for n=1:length(x)
    taps = [x(n), xdel];
    acc = 0;

    for k=0:M
      prod = q_frac(b(k+1)*taps(k+1), F);
      acc  = q_frac(acc + prod, F);
    end

    y(n) = acc;

    if M>0
      xdel(2:end)=xdel(1:end-1);
      xdel(1)=x(n);
    end
  end
end
```

### 고정소수점 Direct-Form IIR 구현(DF-I), 라운딩 포함

```octave
function y = iir_df1_fixed(b, a, x, F)
  % a(1)=1 가정
  Nb = length(b)-1;
  Na = length(a)-1;
  xdel = zeros(1,Nb);
  ydel = zeros(1,Na);
  y = zeros(size(x));

  for n=1:length(x)
    tapsx = [x(n), xdel];
    tapsy = [0, ydel];   % y[n-k], k>=1

    acc_b = 0;
    for k=0:Nb
      prod = q_frac(b(k+1)*tapsx(k+1), F);
      acc_b = q_frac(acc_b + prod, F);
    end

    acc_a = 0;
    for k=1:Na
      prod = q_frac(a(k+1)*tapsy(k+1), F);
      acc_a = q_frac(acc_a + prod, F);
    end

    yn = q_frac(acc_b - acc_a, F);
    y(n) = yn;

    if Nb>0
      xdel(2:end)=xdel(1:end-1);
      xdel(1)=x(n);
    end
    if Na>0
      ydel(2:end)=ydel(1:end-1);
      ydel(1)=yn;
    end
  end
end
```

---

## 문제 1. A/D 양자화 잡음이 FIR 출력 SNR에 미치는 영향

### 상황

- 입력은 풀스케일 사인파 + 소량 잡음
- A/D가 \(B\)비트 균일 양자화(mid-tread)로 샘플링
- 이후 FIR LPF를 통과
- 목표: **입력 양자화 잡음이 필터에서 어떻게 변하는지** 확인

### 요구사항

1) \(B=10\), 풀스케일 \(X_{\max}=1\)일 때 A/D 스텝 \(\Delta\)와 입력 양자화 잡음 분산 \(\sigma_e^2\)를 구하라.
2) FIR의 잡음 이득
   $$
   G_H=\sum_{k=0}^{M} b_k^2
   $$
   를 계산하고, 출력 양자화 잡음 분산
   $$
   \sigma_{y,e}^2 = G_H \sigma_e^2
   $$
   를 예측하라.
3) Octave로 측정 분산을 확인하고 예측과 비교하라.

### 풀이

**(1) A/D 양자화 스텝**
$$
\Delta = \frac{2X_{\max}}{2^B}=\frac{2}{2^{10}}=\frac{1}{512}.
$$

**(2) 입력 양자화 잡음 분산**
이상 모델에서
$$
\sigma_e^2=\frac{\Delta^2}{12}
= \frac{1}{12\cdot 512^2}.
$$

**(3) FIR 잡음 이득과 출력 잡음분산**
계수 \(b_k\)가 주어지면
$$
G_H=\sum b_k^2,\quad
\sigma_{y,e}^2 = G_H \sigma_e^2.
$$

**(4) Octave 검증**

```octave
clear; close all; clc; pkg load signal

Fs=48000; N=48000; n=0:N-1; t=n/Fs;
B=10; Xmax=1; Delta=2*Xmax/(2^B);

% 입력: 풀스케일 사인 + 약간의 랜덤잡음
x_ana = 0.95*sin(2*pi*1000*t) + 0.05*randn(1,N);

% A/D 양자화(mid-tread)
x = Delta*round(x_ana/Delta);
e_in = x - x_ana;

% FIR LPF 설계
M=80; fc=4000/(Fs/2);
b = fir1(M, fc, hamming(M+1));

% 잡음 이득
GH = sum(b.^2);

% 필터 통과
y = filter(b,1,x);
y_ana = filter(b,1,x_ana);
e_out = y - y_ana;

sigma_in_theo = Delta^2/12;
sigma_out_theo = GH*sigma_in_theo;

fprintf("Delta=%.5e\n", Delta);
fprintf("theo var(e_in)=%.3e | meas=%.3e\n", sigma_in_theo, var(e_in));
fprintf("G_H=%.3e\n", GH);
fprintf("theo var(e_out)=%.3e | meas=%.3e\n", sigma_out_theo, var(e_out));
```

**해석 포인트**
- A/D 잡음은 FIR에서 **신호처럼 필터링**된다.
- 저역통과 FIR이면 잡음의 고주파 성분이 줄어 출력 분산이 감소한다.
- 이 감소율이 바로 \(G_H\)로 요약된다.

---

## 문제 2. FIR 내부 반올림 잡음의 분산과 SNR 측정

### 상황

- FIR 설계는 float에서 수행
- 내부 연산을 고정소수점 \(F\)비트로 라운딩
- 반올림 잡음이 출력에 얼마나 생기는지 측정

### 요구사항

1) 문제 1의 FIR에 대해 \(F=8,10,12\)일 때 내부 반올림 오차 분산과 SNR을 측정하라.
2) \(F\) 증가에 따라 분산이 어떤 비율로 줄어드는지 확인하라.

### 풀이

```octave
clear; close all; clc; pkg load signal

Fs=48000; N=48000; n=0:N-1; t=n/Fs;

M=80; fc=4000/(Fs/2);
b = fir1(M, fc, hamming(M+1));

x = 0.8*sin(2*pi*1000*t) + 0.2*sin(2*pi*12000*t);
y_float = filter(b,1,x);

for F=[8 10 12]
  y_fix = fir_df_fixed(b,x,F);
  e = y_fix - y_float;
  SNR = 10*log10(mean(y_float.^2)/mean(e.^2));
  fprintf("F=%d -> var(e)=%.3e, SNR=%.2f dB\n", F, var(e), SNR);
end
```

**해석 포인트**
- LSB \(u=2^{-F}\) 이므로 이상 모델에서 var(e) \(\propto u^2\propto 2^{-2F}\).
- \(F\)을 2비트 늘리면 분산이 약 4배 줄어드는 경향을 확인할 수 있다.

---

## 문제 3. FIR 구조(대칭 최적 vs Direct Form)의 반올림 차이

### 상황

- 대칭(선형 위상) FIR은 곱셈기 수를 절반으로 줄일 수 있음
- 내부 반올림 잡음 소스 개수도 변함

### 요구사항

1) 대칭 FIR을 만들고(탭 수 128), Direct Form과 대칭 최적 구현의 출력 반올림 분산을 비교하라.
2) 탭 수가 커질수록 차이가 커지는 이유를 설명하라.

### 풀이

```octave
function y = fir_sym_fixed(b, x, F)
  L = length(b); M=L-1;
  if mod(L,2)~=0, error("L even only"); end
  half=L/2;
  xdel=zeros(1,M); y=zeros(size(x));
  for n=1:length(x)
    taps=[x(n), xdel];
    acc=0;
    for k=1:half
      pair_sum=q_frac(taps(k)+taps(L+1-k),F);
      prod=q_frac(b(k)*pair_sum,F);
      acc=q_frac(acc+prod,F);
    end
    y(n)=acc;
    if M>0
      xdel(2:end)=xdel(1:end-1);
      xdel(1)=x(n);
    end
  end
end

clear; close all; clc; pkg load signal

Fs=48000; N=48000;
x = randn(1,N)*0.2;

M=127; fc=5000/(Fs/2);
b = fir1(M, fc, hamming(M+1));  % 대칭

y_float = filter(b,1,x);
F=10;

y_df  = fir_df_fixed(b,x,F);
y_sym = fir_sym_fixed(b,x,F);

fprintf("DF var(e)=%.3e\n", var(y_df-y_float));
fprintf("SYM var(e)=%.3e\n", var(y_sym-y_float));
```

**해석 포인트**
- 대칭 구조는 곱셈기 수가 절반 → 곱 라운딩 잡음 소스 절반.
- 탭 수가 클수록 Direct Form은 누산 길이도 커져 덧셈 라운딩이 누적되므로 차이가 더 커진다.

---

## 문제 4. truncation과 rounding의 바이어스 차이(FIR)

### 상황

- FIR 내부 연산에서 truncation을 쓰면 평균 바이어스가 생길 수 있음

### 요구사항

1) 같은 FIR에서 truncation vs rounding을 비교하라.
2) DC 입력에 대해 평균 출력 오차(바이어스)를 측정하라.

### 풀이

```octave
function y = fir_df_trunc(b, x, F)
  M = length(b)-1;
  xdel=zeros(1,M); y=zeros(size(x));
  for n=1:length(x)
    taps=[x(n),xdel]; acc=0;
    for k=0:M
      prod=q_trunc(b(k+1)*taps(k+1),F);
      acc=q_trunc(acc+prod,F);
    end
    y(n)=acc;
    if M>0
      xdel(2:end)=xdel(1:end-1);
      xdel(1)=x(n);
    end
  end
end

clear; close all; clc; pkg load signal

Fs=48000; N=20000;
M=60; fc=3000/(Fs/2);
b=fir1(M,fc,hamming(M+1));

x = 0.1*ones(1,N);  % DC
y_float = filter(b,1,x);

F=8;
y_round = fir_df_fixed(b,x,F);
y_trunc = fir_df_trunc(b,x,F);

fprintf("round bias=%.3e\n", mean(y_round - y_float));
fprintf("trunc bias=%.3e\n", mean(y_trunc - y_float));
```

**해석 포인트**
- truncation은 항상 아래로 치우치므로 평균 오차가 0이 아니기 쉽다.
- FIR에서도 누산이 길면 그 바이어스가 누적되어 DC 오프셋을 만든다.

---

## 문제 5. IIR에서의 반올림 잡음 증폭과 구조 차이

### 상황

- IIR은 피드백으로 인해 내부 반올림 잡음이 증폭될 수 있음
- DF-I, DF-II-T, SOS 구조는 반올림에 대한 민감도가 다름

### 요구사항

1) 4차 Butterworth LPF를 설계하라(컷오프 3 kHz, Fs=48 kHz).
2) DF-I 고정소수점으로 구현했을 때 \(F=10\)에서 출력 반올림 잡음 분산을 측정하라.
3) 같은 필터를 SOS로 분해해서 각 섹션마다 DF-II-T로 구현하면 분산이 어떻게 바뀌는지 비교하라.

### 풀이

```octave
clear; close all; clc; pkg load signal

Fs=48000; N=48000;
x = randn(1,N)*0.2;

% 4차 butterworth LPF
n=4; Wn=3000/(Fs/2);
[b,a]=butter(n,Wn);

y_float = filter(b,a,x);

F=10;
y_df1 = iir_df1_fixed(b,a,x,F);
e_df1 = y_df1 - y_float;

% SOS 변환 후 DF-II-T 고정소수점 구현
[sos,g]=tf2sos(b,a);

function y = sos_df2t_fixed(sos, g, x, F)
  y = x;
  for s=1:size(sos,1)
    b = sos(s,1:3);
    a = sos(s,4:6);
    y = iir_df1_fixed(b,a,y,F);  % DF-II-T를 따로 만들 수도 있지만, 개념 비교용
  end
  y = q_frac(g*y, F);
end

y_sos = sos_df2t_fixed(sos,g,x,F);
e_sos = y_sos - y_float;

fprintf("DF-I var(e)=%.3e\n", var(e_df1));
fprintf("SOS  var(e)=%.3e\n", var(e_sos));
```

**해석 포인트**
- IIR은 내부 잡음이 루프를 타고 재순환하여 출력 잡음이 커질 수 있다.
- SOS는 각 섹션을 안정적으로 스케일링할 수 있어 반올림에 훨씬 강하다.

---

## 관찰

### 상황

- 입력이 0인데도 출력이 남아 진동하는 현상
- FIR에는 없고, IIR의 라운딩 비선형성+피드백에서 발생

### 요구사항

1) 2차 IIR 공진 필터를 만들고, 입력을 0으로 두었을 때 limit cycle이 나는지 확인하라.
2) rounding vs truncation에서 limit cycle의 크기/지속성이 어떻게 달라지는지 비교하라.

### 풀이

```octave
clear; close all; clc

% 2차 공진(단위원 근처 극)
r=0.98; w0=0.2*pi;
a = [1, -2*r*cos(w0), r^2];
b = [1, 0, 0];

N=5000; x=zeros(1,N);
x(1)=1e-3;  % 아주 작은 초기 자극만 주고 이후 0

F=8;
y_round = iir_df1_fixed(b,a,x,F);

% truncation 버전
function y = iir_df1_trunc(b,a,x,F)
  Nb=length(b)-1; Na=length(a)-1;
  xdel=zeros(1,Nb); ydel=zeros(1,Na); y=zeros(size(x));
  for n=1:length(x)
    tapsx=[x(n),xdel]; tapsy=[0,ydel];
    acc_b=0; acc_a=0;
    for k=0:Nb, acc_b=q_trunc(acc_b+q_trunc(b(k+1)*tapsx(k+1),F),F); end
    for k=1:Na, acc_a=q_trunc(acc_a+q_trunc(a(k+1)*tapsy(k+1),F),F); end
    yn=q_trunc(acc_b-acc_a,F); y(n)=yn;
    if Nb>0, xdel(2:end)=xdel(1:end-1); xdel(1)=x(n); end
    if Na>0, ydel(2:end)=ydel(1:end-1); ydel(1)=yn; end
  end
end

y_trunc = iir_df1_trunc(b,a,x,F);

figure; plot(y_round); title("rounding limit cycle");
figure; plot(y_trunc); title("truncation limit cycle");
```

**해석 포인트**
- 극이 단위원에 가까우면 아주 작은 라운딩 신호도 오래 증폭/유지된다.
- truncation은 바이어스가 있어 limit cycle이 더 크거나 한쪽으로 치우칠 수 있다.

---

## 문제 7. 오버플로우(래핑 vs 포화)의 영향

### 상황

- 내부 누산기가 표현 범위를 넘으면
  - wrapping(모듈러) 또는
  - saturation(포화)
  정책을 택해야 함
- 둘은 **잡음 수준을 넘어서는 비선형 왜곡**을 만든다.

### 요구사항

1) FIR 이동평균 필터(길이 16)를 만들고, 입력을 피크 1.2로 넣어 누산 오버플로우를 유도하라.
2) wrapping(모듈러) vs saturation에서 출력 파형/스펙트럼이 어떻게 다른지 비교하라.

### 풀이

```octave
clear; close all; clc; pkg load signal

Fs=48000; N=8000; n=0:N-1; t=n/Fs;
b = ones(1,16)/16;

x = 1.2*sin(2*pi*1000*t);  % 피크>1

I=2; F=8;  % 표현 범위 약 [-2, 2)

% wrapping 모델: sat 없이 라운딩만
y_wrap = fir_df_fixed(b,x,F);

% saturation 모델
function y = fir_df_sat(b,x,I,F)
  M=length(b)-1; xdel=zeros(1,M); y=zeros(size(x));
  for n=1:length(x)
    taps=[x(n),xdel]; acc=0;
    for k=0:M
      prod=q_sat(b(k+1)*taps(k+1),I,F);
      acc=q_sat(acc+prod,I,F);
    end
    y(n)=acc;
    if M>0
      xdel(2:end)=xdel(1:end-1);
      xdel(1)=x(n);
    end
  end
end

y_sat = fir_df_sat(b,x,I,F);

figure; plot([y_wrap(1:400); y_sat(1:400)]');
legend("wrap","sat"); title("time domain");

% 스펙트럼 비교
W=hann(N)';
Yw=fft(y_wrap.*W); Ys=fft(y_sat.*W);
f=(0:N-1)*Fs/N;

figure; plot(f,20*log10(abs(Yw)+1e-12), f,20*log10(abs(Ys)+1e-12));
xlim([0 10000]); grid on;
legend("wrap","sat"); title("spectrum compare");
```

**해석 포인트**
- wrapping은 강한 스퓨리어스/하모닉을 만들고 심하면 신호가 완전히 붕괴한다.
- saturation은 왜곡이 있어도 “폭주”는 막는다.
- 실무는 거의 항상 saturation 우선.

---

## 설계

### 상황

- 동일 사양의 LPF라도 설계 방법에 따라 \(\sum b_k^2\)가 달라짐
- 그 차이가 내부 라운딩 SNR에 직결

### 요구사항

1) 같은 컷오프(4 kHz), 같은 탭 수(81)에서
   - Hamming 창
   - Kaiser 창(\(\beta=6\))
   두 FIR을 설계하라.
2) 각 필터의 \(G_H=\sum b_k^2\)를 비교하고, 같은 \(F=10\) 구현에서 라운딩 오차 분산을 비교하라.

### 풀이

```octave
clear; close all; clc; pkg load signal

Fs=48000; N=48000;
x = randn(1,N)*0.2;

M=80; fc=4000/(Fs/2);

b_ham = fir1(M,fc,hamming(M+1));
b_kai = fir1(M,fc,kaiser(M+1,6));

GH_ham = sum(b_ham.^2);
GH_kai = sum(b_kai.^2);

F=10;
y_ham_f = filter(b_ham,1,x);
y_kai_f = filter(b_kai,1,x);

y_ham_q = fir_df_fixed(b_ham,x,F);
y_kai_q = fir_df_fixed(b_kai,x,F);

fprintf("G_H hamming=%.3e | kaiser=%.3e\n", GH_ham, GH_kai);
fprintf("var(round ham)=%.3e\n", var(y_ham_q - y_ham_f));
fprintf("var(round kai)=%.3e\n", var(y_kai_q - y_kai_f));
```

**해석 포인트**
- \(G_H\)가 더 큰 필터는 내부 라운딩 잡음이 더 크게 나온다.
- 전이대역/저지 리플 개선이 곧 라운딩 SNR 개선은 아니다(트레이드오프).

---

## 구조의 라운딩 이득(선택)

### 상황

- 샘플링률 변환용 FIR을 Direct Form으로 구현하면
  “쓰지도 않을 샘플에 대해서도 연산/라운딩을 수행”
- polyphase는 연산을 줄여 라운딩 잡음 소스를 줄임

### 요구사항

1) \(I=3\) 보간용 LPF를 탭 96개로 설계하라.
2) Direct Form vs polyphase 구현의 라운딩 분산을 비교하라.

### 풀이(개념 비교용)

```octave
clear; close all; clc; pkg load signal

Fs=16000; I=3; Fs2=Fs*I;
N=16000; x=randn(1,N)*0.2;

% 보간용 LPF: 컷오프 = pi/I
M=95; fc=1/I;
b = fir1(M, fc, hamming(M+1));

F=10;

% Direct Form: 업샘플 후 FIR
xu = zeros(1,N*I); xu(1:I:end)=x;
y_df = fir_df_fixed(b, xu, F);
y_df_float = filter(b,1,xu);

% Polyphase(간단 구현): 계수 분해 후 필요한 샘플만 연산
E = reshape([b, zeros(1, I*ceil(length(b)/I)-length(b))], I, []);
function y = interp_poly_fixed(E, x, I, F)
  N=length(x); L=size(E,2);
  y=zeros(1,N*I);
  xdel=zeros(1,L-1);
  for n=1:N
    taps=[x(n), xdel];
    for p=1:I
      acc=0;
      for k=1:L
        acc=q_frac(acc + q_frac(E(p,k)*taps(k),F),F);
      end
      y((n-1)*I+p)=acc;
    end
    xdel(2:end)=xdel(1:end-1);
    xdel(1)=x(n);
  end
end

y_ph = interp_poly_fixed(E,x,I,F);
y_ph_float = interp_poly_fixed(E,x,I,20); % 높은 정밀도 근사(float 대용)

fprintf("Direct var(e)=%.3e\n", var(y_df - y_df_float));
fprintf("Poly   var(e)=%.3e\n", var(y_ph - y_ph_float));
```

**해석 포인트**
- polyphase는 “연산 수 자체를 줄여” 라운딩 잡음을 줄이는 구조적 이점이 있다.

---

## 문제 10. 종합 설계 문제(실무형)

### 상황

“휴대용 오디오 기기”에서 다음 사양의 디지털 필터를 구현해야 한다.

- Fs=48 kHz
- 저역통과, 컷오프 5 kHz
- 통과대역 리플 < 0.1 dB
- 저지대역 감쇠 > 60 dB
- 고정소수점 Q-format
- 출력 SNR(라운딩 포함) > 90 dB 목표

### 요구사항

1) 창함수 기반 FIR을 먼저 설계하고, 탭 수와 \(G_H\)를 계산하라.
2) \(F\)를 스윕하며 출력 반올림 SNR을 측정하라.
3) 목표 SNR을 만족하는 최소 \(F\)를 찾고, 필요한 가드비트를 추정하라.

### 풀이

```octave
clear; close all; clc; pkg load signal

Fs=48000; fc=5000/(Fs/2);

% 스펙에 맞춰 탭수 대략치 선택(예시로 121탭)
M=120;
b = fir1(M, fc, kaiser(M+1, 7));   % 저지 60dB 수준

GH = sum(b.^2);
L1 = sum(abs(b));

fprintf("Tap=%d, G_H=%.3e, sum|b|=%.3f\n", M+1, GH, L1);

% 테스트 신호(음악 대신 멀티톤)
N=48000; n=0:N-1; t=n/Fs;
x = 0.7*sin(2*pi*1000*t) + 0.2*sin(2*pi*7000*t) + 0.1*sin(2*pi*12000*t);

y_float = filter(b,1,x);

for F=8:2:18
  y_fix = fir_df_fixed(b,x,F);
  e = y_fix - y_float;
  SNR = 10*log10(mean(y_float.^2)/mean(e.^2));
  fprintf("F=%2d -> SNR=%.2f dB\n", F, SNR);
end

% 가드비트 추정
% 출력 피크 상한: |y| <= Xmax*sum|b|
Xmax = max(abs(x));
ymax_est = Xmax*L1;
guard_bits = ceil(log2(ymax_est));
fprintf("Estimated ymax=%.3f -> guard bits >= %d\n", ymax_est, guard_bits);
```

**해석 포인트**
- 목표 SNR은 필터 구조/탭수/창 선택과 함께 \(F\)로 조정한다.
- \(\sum|b_k|\)로 누산 피크를 예측하고 가드비트를 결정한다.

---

## 마무리 정리

이 연습문제들을 통해 다음을 확실히 체감해야 한다.

1. **FIR**
   - 반올림은 잡음처럼 누적되며 \(G_H=\sum b_k^2\)가 출력 잡음의 핵심 지표
   - 구조 최적화(대칭/폴리페이즈)로 반올림 소스를 줄일 수 있다.

2. **IIR**
   - 반올림 잡음이 피드백으로 증폭될 수 있어 구조가 매우 중요
   - DF-I/DF-II보다 **SOS + 스케일링**이 고정소수점 필수 해법
   - limit cycle은 IIR 고유 위험이며 truncation에서 더 악화된다.

3. **공통**
   - truncation은 바이어스/왜곡을 만든다.
   - 오버플로우는 잡음이 아니라 “비선형 붕괴”다 → saturation/가드비트/스케일링 필수
   - 최종 의사결정은 항상 **정밀도 스윕 시뮬레이션 + 스펙트럼 검사**로 한다.
