---
layout: post
title: Elixir - 문자열과 바이너리
date: 2025-11-17 20:25:23 +0900
category: Elixir
---
# 문자열, 바이너리, 차리스트 — UTF-8과 Unicode, Erlang 인터롭까지 완전 정리

> 목표
> - 엘릭서에서 `"문자열"`이 **실제로 무엇인지**(UTF-8 바이너리)를 정확히 이해한다.
> - **바이트 길이 / 코드포인트 길이 / 그래페임 길이**의 차이를 예제와 함께 체득한다.
> - `"..."` 과 `'...'` 가 완전히 다른 타입(바이너리 vs charlist)이라는 점을 헷갈리지 않도록 정리한다.
> - iodata, 바이너리 패턴 매칭, Erlang 라이브러리 인터롭까지 한 번에 이어지는 실전 감각을 익힌다.

전체 구조는 다음과 같다.

1. 11.1 문자열 리터럴
2. 11.2 문자열이라는 이름 — 바이너리·코드포인트·그래페임
3. 11.3 작은따옴표 문자열은 문자 코드 리스트다
4. 실전 레시피 모음
5. 흔한 함정과 교정
6. 연습 문제
7. 마무리

---

## 문자열 리터럴

### — 문자열(= UTF-8 바이너리)

엘릭서에서 **"문자열"이라고 부르는 값**은 내부적으로 **UTF-8 인코딩된 바이너리**다.

```elixir
iex> is_binary("안녕")
true
iex> byte_size("안녕")
6
iex> String.length("안녕")
2
```

- `"안녕"` 은 `<<...>>` 형태의 **바이너리**다.
- `byte_size/1` 는 **바이트 수** (UTF-8 인코딩 결과의 길이)를 알려준다.
- `String.length/1` 는 **Unicode 코드포인트 개수**를 세어준다.

직관:

$$
\text{byte\_size}(\text{string}) \neq \text{String.length}(\text{string})
$$

멀티바이트 문자가 많을수록 둘의 차이가 커진다.
예를 들어, 한글은 UTF-8에서 **1글자당 3바이트**가 일반적이다.

#### 바이너리 리터럴과 동치

```elixir
iex> "ABC" == <<65, 66, 67>>
true
iex> <<x, y, z>> = "ABC"
iex> {x, y, z}
{65, 66, 67}
```

- `"ABC"` 문자열은 실제로는 `<<65, 66, 67>>` 바이너리와 완전히 같다.

---

### 이스케이프, 보간, 헤리독

문자열 리터럴에서는 **이스케이프**와 **보간(interpolation)** 을 사용할 수 있다.

```elixir
iex> "line1\nline2\t\"quoted\""
"line1
line2\t\"quoted\""

name = "Kim"
iex> "Hello, #{name}!"
"Hello, Kim!"
```

자주 쓰는 이스케이프 시퀀스:

| 시퀀스 | 의미 |
|--------|------|
| `\n`   | 줄바꿈 (newline) |
| `\t`   | 탭 |
| `\"`   | 큰따옴표 |
| `\\`   | 역슬래시 |
| `\uXXXX` | 16진수 코드포인트(UTF-8로 인코딩됨) |

예:

```elixir
iex> "A\u0301"
"Á"
iex> byte_size("A\u0301")
3
```

#### 문자열 보간

`"Hello, #{expr}!"` 형식으로, 문자열 안에서 **코드 표현식**을 평가한 뒤 `to_string/1` 을 통해 문자열로 삽입한다.

```elixir
iex> "1 + 2 = #{1 + 2}"
"1 + 2 = 3"

iex> "User: #{inspect %{id: 1, name: "Kim"}}"
"User: %{id: 1, name: \"Kim\"}"
```

보간은 내부적으로 `Kernel.to_string/1` 또는 `String.Chars` 프로토콜을 사용한다.

#### 헤리독(Heredoc)

`""" ... """` 로 여러 줄 문자열을 손쉽게 작성할 수 있다.

```elixir
iex> """
...> 장문의 문자열
...> 여러 줄
...> """
"장문의 문자열\n여러 줄\n"
```

특징:

- **마지막 줄 개행을 포함**한다.
- 엘릭서 코딩 스타일에 따라 **들여쓰기**가 포함될 수 있다.

들여쓰기 제거 예:

```elixir
doc =
  """
    line1
    line2
  """
  |> String.trim_trailing()
  |> String.replace(~r/^\s{2}/m, "")

doc
# "line1\nline2"

```

도큐먼트 문자열(@doc)에서도 헤리독을 많이 사용한다.

---

### 시길(sigil)로 특수 문자열

엘릭서의 시길(sigil)은 `~s/.../` 같이 `~` 로 시작하는 리터럴 문법이다.

기본 예:

```elixir
~s/quote "inside" /   # 일반 문자열
~S/보간 #{금지} /      # 보간/이스케이프 無
~r/\Afoo|bar\z/       # Regex
~w/foo bar baz/       # ["foo", "bar", "baz"]
```

소문자 vs 대문자:

- 소문자 시길(`~s`, `~r`, `~w` 등): **보간/이스케이프 허용**
- 대문자 시길(`~S`, `~R`, `~W` 등): **보간/이스케이프 미허용(있는 그대로)**

대표 시길 요약:

| 시길 | 의미 | 예 |
|------|------|----|
| `~s` | 문자열 | `~s/hello #{1+2}/` → `"hello 3"` |
| `~S` | raw 문자열 | `~S/hello #{1+2}/` → `"hello \#{1+2}"` |
| `~r` | 정규식 | `~r/foo|bar/` |
| `~R` | raw 정규식 | `~R/\Afoo\z/` (역슬래시 그대로) |
| `~w` | 공백 구분 리스트 | `~w/foo bar/` → `["foo","bar"]` |
| `~W` | raw 리스트 | `~W/foo #{bar}/` → `["foo", "\#{bar}"]` |
| `~c` | charlist | `~c/abc/` → `'abc'` |
| `~C` | raw charlist | 동일하나 이스케이프 없음 |

옵션을 붙여 의미를 바꾸기도 한다:

```elixir
~w/foo bar baz/a  # [:foo, :bar, :baz] (atoms)
~w/1 2 3/c        # '1 2 3' (charlist)
~w/1 2 3/s        # ["1", "2", "3"]
```

정규식에서는 옵션으로 `i`(대소문자 무시), `m`, `u`(UTF-8) 등을 쓴다:

```elixir
~r/straße/i
# "Straße" 와 "STRASSE" 등과의 매칭에 주의 (Unicode case folding)

```

---

### 문자열은 불변 & 내부 공유

엘릭서/얼랭의 문자열(=바이너리)은 **불변(immutable)** 이다.

```elixir
s = "abc"
t = s <> "d"

s  # "abc"
t  # "abcd"
```

- `s` 와 `t` 는 **서로 다른 값**이다.
- 런타임 레벨에서는 바이너리의 일부를 재사용하는 **참조 카운트 기반 공유** 최적화가 있다.
  - 큰 바이너리에서 작은 부분을 잘라낼 때 **전체를 복사하지 않고** 일부를 가리키기만 할 수 있다.
  - 하지만 너무 오래 참조하고 있으면 큰 바이너리가 GC되지 못해 메모리를 잡아먹을 수 있다.

대량 문자열 생성에서 `<>` 를 반복하는 것은 다음과 같이 비싸질 수 있다.

```elixir
# 비효율적인 패턴

Enum.reduce(1..100_000, "", fn i, acc ->
  acc <> Integer.to_string(i) <> "\n"
end)
```

- 각 단계에서 새로운 바이너리를 만들고, 기존 내용까지 복사하므로
  전체 복잡도가 대략 $$O(n^2)$$ 수준으로 악화될 수 있다.

이 문제는 **iodata**를 사용해 개선한다(11.2, 11.2.4, 실전 레시피에서 자세히).

---

## ‘문자열’이라는 이름 — 바이너리·코드포인트·그래페임

엘릭서의 `"문자열"`은 UTF-8 바이너리다.
UTF-8은 **가변 길이 인코딩**이라서, 문자 하나가 **1~4바이트**를 차지할 수 있다.

문자열을 다룰 때는 최소한 세 가지 길이를 구분해야 한다.

- **바이트 길이**: `byte_size/1`
- **코드포인트 길이**: `String.length/1`
- **그래페임 길이**: `String.graphemes/1 |> length/1`

### 바이트 / 코드포인트 / 그래페임 예제

조합형/이모지 예:

```elixir
s1 = "e\u0301"           # e + COMBINING ACUTE ACCENT (é 조합)
s2 = "é"                 # 단일 코드포인트(정규화된 NFC)

{byte_size(s1), String.length(s1), length(String.graphemes(s1))}
# {3, 2, 1}

{byte_size(s2), String.length(s2), length(String.graphemes(s2))}
# {2, 1, 1}

s3 = "🇰🇷"               # Regional Indicator 2개로 표현되는 국기
{byte_size(s3), String.length(s3), length(String.graphemes(s3))}
# {8, 2, 1}

```

- `s1`: 코드포인트 2개 (`e`, Combining accent 1개) → 그래페임은 1개.
- `s2`: 코드포인트 1개 → 그래페임도 1개.
- `s3`: 코드포인트 2개(영문 R, I 처럼 처리) → 그래페임은 1개(국기).

수식 직관:

$$
\text{grapheme\_count} \le \text{codepoint\_count} \le \text{byte\_size}
$$

동등한 경우도 있지만, 일반적으로 왼쪽으로 갈수록 “사용자 관점의 글자 수”에 가깝다.

---

### 문자열 연산 기본 — String 모듈

대표적인 문자열 함수들:

```elixir
String.upcase("straße")           # "STRASSE" (독일어 ß → SS 규칙 적용)
String.downcase("İSTANBUL")       # "i̇stanbul" (위 점 있는 i, 로케일 민감)
String.trim("  안녕  ")           # "안녕"
String.replace("a,b,c", ",", "|") # "a|b|c"
String.split("a::b::c", "::")     # ["a","b","c"]
String.starts_with?("elixir", "eli")
String.ends_with?("elixir", "ir")
String.contains?("hello world", "world")
```

특징:

- `String` 모듈은 **Unicode 인지**이다.
  - 다만 일부 언어의 특수 케이스 매핑은 일반적인 Unicode 규칙을 따르며, 로케일별 예외는 직접 처리해야 할 수 있다.
- `String.length/1` 는 **코드포인트 기준**이므로, 그래페임 기준 작업이 필요할 때는 `String.graphemes/1` 사용.

---

### 코드포인트·그래페임 순회

문자열을 순회할 때도 “코드포인트 vs 그래페임” 을 구분해야 한다.

#### 코드포인트 순회 (바이너리 컴프리헨션)

```elixir
for <<cp::utf8 <- "가나">>, do: cp
# [44032, 45208]

```

- `<<cp::utf8 <- bin>>` 컴프리헨션은 **각 코드포인트**를 순회한다.

#### 그래페임 순회

```elixir
String.graphemes("e\u0301🇰🇷")
# ["é","🇰🇷"]

for g <- String.graphemes("e\u0301🇰🇷"), do: {g, String.length(g), byte_size(g)}
# [{"é", 1, 2}, {"🇰🇷", 2, 8}]

```

- 한 그래페임이 여러 코드포인트를 포함할 수 있다.
- 사용자에게 보여지는 “글자 수” 기준 처리가 필요하면 항상 **그래페임 단위**를 고려해야 한다.

---

### 정규화(NFC/NFD)와 비교

같아 보이는 문자열이 **바이너리로는 다를 수** 있다.

```elixir
a = "e\u0301"   # 조합형
b = "é"         # 단일 코드포인트

a == b
# false (바이너리 다름)

String.normalize(a, :nfc) == String.normalize(b, :nfc)
# true

```

- 파일 시스템, 데이터베이스, 외부 API 등과 연동할 때
  “정규화 정책”을 정해두면 좋은 이유가 여기에 있다.

전략 예:

- 저장 시: 항상 `String.normalize(str, :nfc)` 후 저장.
- 비교 시: 양쪽 모두 `:nfc` 또는 `:nfd`로 통일 후 비교.

---

### iodata/iodata()로 성능 좋게 결합

문자열 결합에서 **가장 중요한 실전 팁** 중 하나:

- `<>` 를 반복해서 사용하는 대신, **iodata** 를 모아서 **마지막에 한 번만 바이너리로 변환**하라.

```elixir
rows =
  1..3
  |> Enum.map(fn i ->
    ["row:", Integer.to_string(i), "\n"]
  end)  # iodata의 리스트

:erlang.iolist_to_binary(rows)
# "row:1\nrow:2\nrow:3\n"

```

- iodata:
  - `binary()` 또는
  - `list()` 안에 `binary()` 또는 다른 iodata가 들어간 **중첩 구조**.
- `:erlang.iolist_to_binary/1` 는 iodata를 한 번에 평탄화하면서 효율적으로 바이너리를 만든다.

복잡도 직관:

- `<>` 연쇄 결합: 대략 $$O(n^2)$$ 까지 악화 가능.
- iodata + `iolist_to_binary`: 대략 $$O(n)$$ 에 가깝게 유지.

---

### 바이너리·비트스트링 매칭

바이너리는 패턴 매칭으로 **헤더/바디/필드를 안전하게 분리**할 수 있다.

```elixir
<<h, rest::binary>> = "ABC"
{h, rest}
# {65, "BC"}

<<r::16>> = <<0x01, 0x02>>
r
# 0x0102 (big-endian 기본)

<<x::size(3), y::size(5)>> = <<0b101_00101>>
{x, y}
# {5, 5}

```

- `::size(n)` 으로 비트 단위 분할 가능.
- `::utf8`, `::utf16`, `::little`, `::signed` 등으로 엔디언/부호까지 제어 가능.

패킷 파서 예:

```elixir
defmodule Wire do
  # [type:1][len:1][payload:len] 반복
  def parse_all(bin), do: do_parse(bin, [])

  defp do_parse(<<>>, acc), do: Enum.reverse(acc)

  defp do_parse(<<type, len, payload::binary-size(len), rest::binary>>, acc) do
    do_parse(rest, [%{type: type, len: len, payload: payload} | acc])
  end
end
```

- 중간 문자열을 만들지 않고 **원 바이너리에서 바로 매칭**한다.
- 잘못된 길이/형식일 때는 패턴 매칭이 실패하므로
  `case` 나 `with` 와 함께 사용할 때 예외 경로를 잘 설계해야 한다.

---

## 작은따옴표 문자열은 문자 코드의 리스트다

### `'...'` = charlist = 정수 리스트

엘릭서에서 **작은따옴표** 리터럴은 문자열이 아니다.

```elixir
iex> is_list('ABC')
true
iex> 'ABC'
'ABC'
iex> Enum.to_list('ABC')
[65, 66, 67]
iex> is_binary('ABC')
false
```

- `'ABC'` 는 `[65, 66, 67]` 의 **syntactic sugar**다.
- 리스트의 각 원소는 **정수(Unicode 코드포인트)** 이다.

같은 값의 여러 표기 방법:

```elixir
'ab'
[?a, ?b]
[97, 98]
```

- `?a` 는 문자를 정수 코드포인트로 표현하는 문법이다.

---

### 문자열 ↔ charlist 변환

문자열과 charlist 사이 변환은 다음과 같이 한다.

```elixir
to_charlist("한글")
# [54620, 44544]

List.to_string([72, 73])
# "HI"

```

Erlang 레벨 함수도 사용할 수 있다.

```elixir
:erlang.binary_to_list("abc")
# 'abc'

:erlang.list_to_binary('abc')
# "abc"

```

실무 패턴:

- 애플리케이션 내부: **항상 `"..."` 문자열(바이너리)** 로 유지.
- Erlang **옛 API** 중 charlist를 기대하는 것과 연결할 때만 **경계에서 변환**.

---

### charlist 장단점

**장점**

- **리스트** 이므로 패턴 매칭/재귀가 자연스럽다.

```elixir
# 리스트 재귀 예

defmodule CL do
  def len([]), do: 0
  def len([_h | t]), do: 1 + len(t)
end

CL.len('abc')
# 3

```

- 일부 기존 **Erlang API** 가 charlist를 기본 인자로 기대한다.

**단점**

- 리스트는 **각 원소에 박스(헤더+포인터)** 가 있으므로
  같은 내용을 담은 바이너리보다 메모리 비효율적이다.
- 인덱스 접근이 **O(n)** 이다(링크드 리스트).
- 문자열 조작 로직 전체를 charlist로 작성하면,
  대부분의 경우 바이너리 기반 `String` 모듈보다 **느리고 복잡** 해진다.

정리하면:

> 도메인 문자열은 항상 `"..."`(바이너리)로 두고,
> **Erlang 경계**에서만 charlist 변환을 사용하라.

---

### charlist 기반 재귀 파서 예시(교육용)

실무에서는 표준 라이브러리로 해결하는 로직이지만,
charlist 재귀 패턴을 이해하기 위한 예제다.

```elixir
defmodule CLParse do
  # "a=1&b=2" 같은 쿼리 문자열을 맵으로 (charlist 입력)
  def parse(list), do: parse_kv(list, [], %{})

  defp parse_kv([], [], acc), do: acc

  defp parse_kv([], cur, acc),
    do: put(acc, to_string(Enum.reverse(cur)), "")

  defp parse_kv([?& | rest], cur, acc),
    do: parse_kv(rest, [], put(acc, to_string(Enum.reverse(cur)), ""))

  defp parse_kv([?= | rest], key, acc),
    do: parse_val(rest, [], key, acc)

  defp parse_kv([h | rest], cur, acc),
    do: parse_kv(rest, [h | cur], acc)

  defp parse_val([], cur, key, acc),
    do: put(acc, to_string(Enum.reverse(key)), to_string(Enum.reverse(cur)))

  defp parse_val([?& | rest], cur, key, acc),
    do:
      parse_kv(
        rest,
        [],
        put(acc, to_string(Enum.reverse(key)), to_string(Enum.reverse(cur)))
      )

  defp parse_val([h | rest], cur, key, acc),
    do: parse_val(rest, [h | cur], key, acc)

  defp put(acc, k, v), do: Map.put(acc, k, v)
end

CLParse.parse('a=1&b=2')
# %{"a" => "1", "b" => "2"}

```

실무에서는:

```elixir
URI.decode_query("a=1&b=2")
# %{"a" => "1", "b" => "2"}

```

를 사용하면 된다.
위 예제는 **charlist 재귀 패턴**을 익히기 위한 교육용 예시로 보는 것이 좋다.

---

### 혼동 방지 체크

테스트/디버깅에서 가장 많이 보는 실수:

```elixir
is_binary("abc")   # true
is_list("abc")     # false

is_binary('abc')   # false
is_list('abc')     # true
```

- `"abc"`: 바이너리
- `'abc'`: 리스트

함수 인자 타입이 맞지 않아서 에러가 날 때는
**따옴표 종류부터 확인**하자.

---

## 실전 레시피 모음

이제 앞에서 정리한 개념을 바탕으로, 실제로 바로 가져다 쓸 수 있는 패턴들을 정리한다.

### (대용량 안전, iodata 출력)

요구사항:

- `data.csv` 를 읽어서
- 첫 줄을 헤더로 사용하고
- 각 행을 `"헤더" => "값"` 형태의 맵으로 만든 뒤
- 다시 다른 CSV로 내보내기(중간 리스트 최소화)

```elixir
headers =
  "data.csv"
  |> File.stream!()
  |> Stream.take(1)
  |> Enum.at(0)
  |> String.trim_trailing()
  |> String.split(",")

rows =
  "data.csv"
  |> File.stream!()
  |> Stream.drop(1)
  |> Stream.map(&String.trim_trailing/1)
  |> Stream.reject(&(&1 == ""))
  |> Stream.map(&String.split(&1, ","))

maps =
  rows
  |> Stream.map(fn cols -> Enum.zip(headers, cols) |> Map.new() end)

# 바로 파일로 쓴다(중간에 전체 리스트로 모으지 않음)

maps
|> Stream.map(fn m ->
  [Enum.join(Map.values(m), ","), "\n"]
end)  # iodata
|> Stream.into(File.stream!("out.csv"))
|> Stream.run()
```

- `maps` 는 **지연 스트림**이다.
- 최종 CSV 출력은 iodata를 `Stream.into(File.stream!)` 로 직접 흘려보낸다.

---

### UTF-8 안전 슬라이스(바이트 인덱스 금지)

**잘못된 예(금지):**

```elixir
# 부분 바이너리 잘라내기 (문자 경계 보장 X)

binary_part("안녕", 0, 2)
# 잘못된 UTF-8 시퀀스로 이어질 수 있고, 이후 연산에서 오류 가능

```

**권장 예: 그래페임 기준 슬라이스**

```elixir
def safe_slice(s, n) do
  s
  |> String.graphemes()
  |> Enum.take(n)
  |> Enum.join()
end

safe_slice("안녕🙂세계", 3)
# "안녕🙂"

```

- `String.slice/2` 는 **코드포인트 기준**이라서 그래페임 조합(이모지/조합형 문자)에선
  미묘한 문제를 만들 수 있다.
- 사용자 UI에 “n글자 제한”을 둘 때는 **그래페임 기준**이 안전하다.

---

### 바이너리 프로토콜 파싱

간단한 프로토콜:

- `[len:1][type:1][payload:len]` 블록이 반복되는 바이너리

```elixir
defmodule Wire do
  def parse_all(bin), do: do_parse(bin, [])

  defp do_parse(<<>>, acc), do: Enum.reverse(acc)

  defp do_parse(<<len, type, payload::binary-size(len), rest::binary>>, acc) do
    do_parse(rest, [%{len: len, type: type, payload: payload} | acc])
  end
end

Wire.parse_all(<<3, 1, "abc", 2, 2, "XY">>)
# [
#   %{len: 3, type: 1, payload: "abc"},
#   %{len: 2, type: 2, payload: "XY"}
# ]

```

- 패턴 매칭으로 헤더/바디를 한 번에 분리한다.
- 잘못된 형식이면 패턴 매칭이 실패하므로, `case` 로 감싸서 에러를 처리할 수 있다.

---

### 문자열 ↔ charlist Erlang 인터롭

Erlang 라이브러리 중 일부는 charlist를 기대한다.
예를 들어, URL을 charlist로 넘기는 함수가 있다고 가정해 보자.

```elixir
defmodule HttpCompat do
  def request(url) when is_binary(url) do
    char_url = to_charlist(url)
    do_request(char_url)
  end

  defp do_request(char_url) do
    # 여기서는 charlist만 사용한다고 가정
    # :some_erlang_http_lib.request(char_url)
    {:ok, char_url}
  end
end

HttpCompat.request("https://example.com")
# {:ok, 'https://example.com'}

```

실제 라이브러리 문서를 보면, 많은 경우 이미 binary/charlist 둘 다 지원하는 인자를 제공하기 때문에,
**기대한 인자 타입**을 정확하게 테스트로 고정해 두는 것이 좋다.

---

### 로그 라인 파싱 + CSV 출력 (문자열 + iodata 조합)

로그 파일 `access.log` 에서 필요한 필드만 추출해 CSV로 쓰는 예제:

```elixir
defmodule Log do
  # 예제용 파서 (실제 로그 포맷에 맞게 수정 필요)
  def parse_line(line) do
    case String.split(line, " ") do
      [ip, path, code_str | _] ->
        case Integer.parse(code_str) do
          {code, _} -> {:ok, %{ip: ip, path: path, code: code}}
          :error    -> :error
        end

      _ ->
        :error
    end
  end
end

"access.log"
|> File.stream!()
|> Stream.map(&Log.parse_line/1)
|> Stream.filter(&match?({:ok, _}, &1))
|> Stream.map(fn {:ok, m} -> m end)
|> Stream.map(fn m ->
  [
    "\"", m.ip, "\"",
    ",",
    "\"", m.path, "\"",
    ",",
    Integer.to_string(m.code),
    "\n"
  ]
end)
|> Stream.into(File.stream!("out.csv"))
|> Stream.run()
```

- 문자열 파싱 로직은 `String` 모듈 사용.
- 출력은 **iodata** 기반으로, `Stream.into/2` 로 파일에 직접 쓴다.

---

## 흔한 함정 → 교정

### 작은따옴표 = 문자열이라는 오해

**증상**: 타입 오류, 예상치 못한 리스트 연산, `String.*` 함수에서 예외.

```elixir
String.length('abc')
# Protocol.UndefinedError: protocol String.Chars not implemented for 'abc'

```

**교정**:

- 문자열은 항상 **큰따옴표** `"..."` 사용.
- charlist는 **작은따옴표** `'...'` 이고, 리스트로 다뤄야 한다.
- 필요시 `to_charlist/1` / `List.to_string/1` 로 변환.

---

### 바이트 오프셋으로 슬라이스

**증상**:

- UTF-8 바이트 중간에서 자르면서 문자열이 깨짐.
- 이후 `String` 함수 호출 시 예외 또는 � 문자 발생.

**교정**:

- 사용자의 글자 수 기준 작업 → `String.graphemes/1` 사용.
- 코드포인트 기준 슬라이스 → `String.slice/2` 사용.
- 반드시 바이너리 패턴에서 `::utf8` 을 사용해 경계를 지키고,
  바이트 오프셋으로 직접 잘라내는 것은 프로토콜/저수준 처리에만 사용하자.

---

### 대용량 문자열 결합에서 `<>` 남발

**증상**:

- 긴 텍스트를 만들어야 하는 코드에서 **성능 저하**, **GC 압박 증가**.

**교정**:

- iodata 리스트에 조각들을 모으고, 마지막에 `:erlang.iolist_to_binary/1` 를 호출한다.
- 파일/소켓에 직접 쓸 경우 `Stream.into(File.stream!...)` 와 조합.

---

### 정규화 미고려 비교

**증상**:

- “사용자 눈에 똑같은 문자열인데 일치 비교에서 false”
  (조합형 vs 단일 코드포인트 등).

**교정**:

- 저장/비교 정책을 세운다.
  - 저장 전 `String.normalize(str, :nfc)` 또는 `:nfd`.
  - 비교 시 양쪽 모두 같은 방식으로 정규화.
- 테스트에 **조합형/단일형 혼합 케이스**를 반드시 포함한다.

---

### Erlang 인터롭에서 기대 타입 미일치

**증상**:

- Erlang 라이브러리 호출 시 `badarg` 등 예외.

**교정**:

- 문서를 보고 binary/charlist 등 **기대 타입을 명확히 확인**한다.
- 어댑터 함수를 만들어 경계에서만 변환.

```elixir
def with_charlist(fun, bin) when is_binary(bin) do
  char = to_charlist(bin)
  result = fun.(char)
  case result do
    list when is_list(list) -> List.to_string(list)
    other                   -> other
  end
end
```

---

## 연습 문제

필요하다면 이 섹션을 그대로 문제집으로 쓸 수 있다.

1) **정규화 비교기**
   `equal?(a, b)` 함수를 작성하라.
   - 역할: 두 문자열을 NFC 정규화 후 비교.
   - 요구사항:
     - `"e\u0301"` 와 `"é"` 가 `true` 를 반환해야 한다.
     - 테스트에 조합형/단일형 혼합 케이스를 포함한다.

2) **그래페임 안전 자르기**
   `truncate(s, n, suffix \\ "…")` 를 작성하라.
   - 역할: 문자열 `s` 를 **그래페임 기준**으로 `n` 글자까지 자르고,
     - 글자 수가 `n` 이하면 그대로 반환.
     - 글자 수가 `n` 을 초과하면, 앞 `n` 글자 + `suffix`를 반환.
   - 예:
     - `truncate("안녕🙂세계", 3)` → `"안녕🙂…"`
     - `truncate("abc", 5)` → `"abc"`

3) **바이너리 파서**
   길이 지정된 key-value 페어를 파싱하는 함수 `parse_kv/2` 를 작성하라.
   - 입력 형식:
     - `<<"k", "=", len, v::binary-size(len), "&", rest::binary>>` 가 반복된다고 가정.
   - 출력:
     - `%{"k" => "value", ...}` 형태의 맵.
   - 잘못된 형식일 때는 `{:error, :invalid}` 를 반환하도록 한다.

4) **charlist 인터롭 레이어**
   `with_charlist(fun, bin)` 함수를 완성하라.
   - 역할:
     - 내부에서 `to_charlist(bin)` 으로 변환해 `fun.(charlist)` 를 호출.
     - 결과가 charlist이면 문자열로, 그렇지 않으면 그대로 반환.
   - `fun` 에는 charlist를 기대하는 Erlang 함수들을 넘길 수 있어야 한다.

5) **성능 실험**
   - 100000 라인의 텍스트를
     1. `<>` 로 누적하는 방법
     2. iodata + `:erlang.iolist_to_binary/1` 방법
     두 가지로 각각 합쳐보고, 소요 시간/메모리 사용량을 측정하여 비교하라.
   - 실험 결과를 표로 정리하고,
     $$O(n^2)$$ vs $$O(n)$$ 관점에서 차이를 해석하라.

---

## 마무리

- 엘릭서에서 `"문자열"` 은 **UTF-8 바이너리**이며,
  **바이트 / 코드포인트 / 그래페임** 의 차이를 알고 있어야 올바른 문자열 처리가 가능하다.
- `"..."` 와 `'...'` 는 타입이 완전히 다르다.
  - `"..."` → binary (문자열)
  - `'...'` → charlist (정수 리스트)
- 대량의 텍스트를 다룰 때는 **iodata + 바이너리 매칭 + Stream/Collectable** 조합이
  성능과 메모리 측면에서 큰 차이를 만든다.
- Erlang 생태계와의 인터롭에서는 **binary vs charlist**를 항상 의식하고,
  경계에서만 변환하는 **깨끗한 레이어**를 두는 것이 좋다.

이 장에서 정리한 패턴들을 실제 프로젝트의 문자열/텍스트/로그/프로토콜 처리 코드에
차근차근 적용해 보면, 코드가 더 **짧고, 예측 가능하고, 성능까지 좋은** 쪽으로 정리되는 것을 느낄 수 있을 것이다.
