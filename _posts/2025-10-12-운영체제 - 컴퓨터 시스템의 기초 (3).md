---
layout: post
title: 운영체제 - 컴퓨터 시스템의 기초 (3)
date: 2025-10-12 23:30:23 +0900
category: 운영체제
---
# 보안·가상화·분산시스템·커널 자료구조

운영체제의 후반부 개요를 하나의 흐름으로 엮는다.
**(1) 보안과 보호**는 “누가, 무엇을, 언제, 어떻게 할 수 있는가”를 정의한다.
**(2) 가상화**는 하드웨어를 분할/합성해 독립적 실행 환경을 만든다.
**(3) 분산 시스템**은 다수의 노드가 네트워크를 통해 하나의 시스템처럼 동작하도록 한다.
**(4) 커널 자료구조**는 위 모든 기능을 지탱하는 성능/일관성의 핵심이다.

각 절마다 **실행 예제, 코드 스니펫, 관찰 포인트**를 제시한다.
코드는 가능한 한 **리눅스/유닉스** 환경 기준이며, 일부는 관리자 권한이 필요할 수 있다.

---

## Security and Protection (보안과 보호)

보안과 보호는 **정책**(무엇이 허용/거부인가)과 **메커니즘**(이를 실행하는 구체적 수단)의 조합이다.

- **정책**: “사용자 U가 객체 O에 대해 연산 R을 수행할 수 있는가?”
- **메커니즘**: 모드/페이지 보호, 권한 비트·ACL·Capabilities, LSM(MAC), ASLR/DEP, 격리(프로세스/컨테이너/VM), 감사(Audit)

### 보호 도메인과 접근 행렬

**접근 행렬(Access Matrix)** 개념으로 표현하면,
- **주체(Subjects)**: 사용자/프로세스/역할
- **객체(Objects)**: 파일/디렉터리/소켓/장치/IPC/메모리 영역
- **권한(Rights)**: read/write/execute/append/rename/ioctl/…

접근 행렬 $$A$$에서 원소 $$A[s,o]$$는 주체 $$s$$가 객체 $$o$$에 대해 가진 권한 집합이다.
**행 기반(권리 리스트, capabilities)** vs **열 기반(ACL)** 저장의 **공간/검사 비용**이 상이하다.

#### 간단 수식 직관(권한 위임 비용)

권한 체크를 위한 평균 비용을 $$C$$, 검사 횟수를 $$n$$, 캐시 적중률을 $$p$$, 캐시 히트 비용을 $$h$$, 미스 비용을 $$m$$이라 하면:
$$
C \approx p \cdot h + (1-p) \cdot m, \quad \text{총비용} \approx n \cdot C
$$
권한 캐시(Linux의 **RCU 기반 dentry/inode 권한 캐시** 등)는 $$p$$를 높여 총비용을 줄인다.

### 링과 모드

- **CPU 특권 링**(x86: ring0=커널, ring3=사용자)
- **사용자 모드 ↔ 커널 모드** 전환: 시스템콜/예외/인터럽트
- 일부 아키텍처는 추가 모드(하이퍼바이저, Secure monitor 등)를 제공

### 메모리 보호

- **가상 메모리 + 페이지 권한**: R/W/X, 사용자/커널 비트
- **ASLR(Address Space Layout Randomization)**: 코드/스택/라이브러리 배치 무작위화
- **DEP/NX**: 데이터 영역 실행 금지

#### [실습] 실행권한 차단 체감(리눅스)

```bash
# 실행 비트가 없는 스크립트/바이너리 실행 시도

printf '#!/bin/sh\necho hello\n' > /var/tmp/x.sh
chmod 600 /var/tmp/x.sh
/var/tmp/x.sh  # 실행 실패 (권한 없음)
bash /var/tmp/x.sh  # 인터프리터로는 실행 가능

# noexec 마운트 옵션 관찰(환경에 따라 다름)

mount | grep noexec || true
```

### 인증·인가·감사(AAA)

- **인증(Authentication)**: 누구인가? (비밀번호, 키, MFA)
- **인가(Authorization)**: 무엇을 할 수 있는가? (ACL, RBAC, Capabilities)
- **감사(Auditing)**: 무엇을 했는가? (Audit log)

#### [실습] 파일 권한/ACL

```bash
# POSIX 권한

touch s.txt && echo "secret" > s.txt
chmod 600 s.txt && ls -l s.txt

# ACL (setfacl/getfacl 필요)

setfacl -m u:someuser:rx s.txt
getfacl s.txt
```

### Capabilities & MAC

- **POSIX Capabilities**: root의 거대한 권한을 세분화(예: `CAP_NET_ADMIN`, `CAP_SYS_ADMIN` 등).
- **MAC(Mandatory Access Control)**: SELinux/AppArmor/Smack — **라벨**과 **정책**으로 강제.

#### [실습] 프로세스 Capabilities

```bash
# 프로세스의 Capabilities 관찰

cat /proc/$$/status | grep Cap
```

### 메모리/바이너리 하드닝

- **PIE+ASLR**, **RELRO**, **Stack Canary**, **FORTIFY_SOURCE**
- **seccomp-bpf**로 시스템콜 화이트리스트

#### [실습] seccomp 개념 스니펫(C)

```c
// seccomp_min.c : 특정 시스템콜만 허용(빌드엔 libseccomp 필요)
#include <seccomp.h>
#include <unistd.h>

int main() {
    scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
    seccomp_load(ctx);
    write(1, "hello\n", 6);  // OK
    getpid();                 // 금지 → 프로세스 종료
    return 0;
}
```

---

## Virtualization (가상화)

가상화는 **리소스의 추상화 계층**을 만들어 **격리**와 **활용도**를 개선한다.

- **프로세스 수준**: 프로세스 가상 메모리, 시스템콜 인터페이스
- **컨테이너**: 네임스페이스(pid, net, mnt, uts, ipc, user) + **cgroups**(CPU/mem/io 제한)
- **머신 가상화**: 타입1/타입2 하이퍼바이저, 하드웨어 지원(VT-x/AMD-V, EPT/NPT)

### 프로세스/컨테이너 가상화

**컨테이너**는 커널을 공유하되 **네임스페이스**와 **cgroups**로 **격리·자원제한**을 제공한다.

#### [실습] 네임스페이스 직접 체험(unshare)

```bash
# 새로운 UTS/pid/mount 네임스페이스에서 셸 실행

sudo unshare -Umipf bash -c '
  hostname container1
  mount -t proc proc /proc
  echo "PID in ns: $$, hostname=$(hostname)"
  sleep 2
'
```

#### [실습] cgroups로 CPU/메모리 제한

```bash
# cgroup v2 예시(시스템 설정에 따라 경로 상이)

sudo mkdir -p /sys/fs/cgroup/demo
echo +cpu +memory | sudo tee /sys/fs/cgroup/cgroup.subtree_control
echo 200000 | sudo tee /sys/fs/cgroup/demo/cpu.max        # 20ms/100ms 비율 등
echo $BASHPID | sudo tee /sys/fs/cgroup/demo/cgroup.procs # 현재 셸 이관
# 제한 상태에서 CPU를 소모하는 작업을 돌리고 top/ps로 관찰

```

### 머신 가상화

- **Full Virtualization**: 하드웨어 전체를 에뮬레이션/가상화(QEMU/KVM)
- **Paravirtualization**: 하이퍼콜 제공(Xen PV)
- **Hardware-assisted**: VMX/SVM + EPT/NPT로 **트랩/에뮬** 비용 감소

#### [실습] QEMU/KVM으로 경량 VM 실행

```bash
# 예: 커널/루트fs를 별도로 준비해 부팅(환경마다 상이, 개념 참고)

qemu-system-x86_64 -enable-kvm -m 1024 \
  -kernel ./bzImage -append "console=ttyS0" \
  -initrd ./initramfs.cpio.gz -nographic
```

### 오버헤드와 스케줄링

가상화는 **트랩/컨텍스트 스위치** 증가, **TLB shootdown**, **I/O 경로 길어짐** 등의 오버헤드가 있다.
하이퍼바이저는 **vCPU 스케줄링**, I/O 성능을 위해 **virtio**(파라가상화 드라이버) 등을 사용한다.

---

## Distributed Systems (분산 시스템)

여러 노드가 네트워크로 연결되어 **일관된 목표**(저장/계산/스트리밍/합의)를 달성한다.

- **특성**: 지연(latency), 대역폭, 장애(부분 실패), 동시성, 시계 비동기
- **목표**: 가용성, 일관성, 확장성, 내구성, 보안

### 모델과 기초

- **동기/비동기 모델**, 장애 유형(충돌/정지/비잔틴)
- **CAP 정리**: 네트워크 분할(Partition) 시 **일관성(C)**과 **가용성(A)**을 동시에 완벽히 보장할 수 없다.
- **일관성 모델**: 강한/약한/SI/최종 일관성

#### 직관 수식(평균 왕복 지연과 처리율)

요청 처리 시간의 평균을 $$T_s$$, 네트워크 왕복 지연을 $$T_r$$, 파이프라이닝 수준을 $$k$$라 하면, 단순화된 평균 처리율:
$$
\text{Throughput} \approx \frac{k}{T_s + T_r}
$$
지연 $$T_r$$가 큰 분산 환경에서 **배치/파이프라이닝**은 핵심 최적화다.

### 시간과 순서

- **물리 시계** 동기화: NTP/PTP
- **논리 시계**: Lamport clock, Vector clock (인과관계 추적)
- **정렬 보장**: 토픽 파티션 내 순서, 전역 순서(합의 프로토콜 필요)

### 합의와 리더 선출

- **Raft/Paxos**: 장애 상황에서도 일관된 결정(로그 합의)
- **Gossip/Failure Detector**: 헌트비/φ-Accrual 등으로 노드 생사 추정

### RPC와 메시징

- **RPC**(gRPC/JSON-RPC/Thrift): 함수 호출 추상화
- **메시징**(Kafka/RabbitMQ/NATS/ZeroMQ): 비동기 큐잉, 백프레셔

#### [실습] 극단적 미니 RPC(파이썬 소켓)

```python
# rpc_server.py : "add x y" 요청을 받아 합을 돌려준다 (실험용)

import socket, threading

def handle(c):
    with c:
        data = c.recv(1024).decode().strip()
        op, *args = data.split()
        if op == "add" and len(args)==2:
            x, y = map(int, args)
            c.sendall(str(x+y).encode()+b"\n")
        else:
            c.sendall(b"ERR\n")

s = socket.socket()
s.bind(("0.0.0.0", 7777))
s.listen(64)
print("RPC server on 7777")
while True:
    c, _ = s.accept()
    threading.Thread(target=handle, args=(c,), daemon=True).start()
```

```bash
python3 rpc_server.py &
printf "add 7 35\n" | nc 127.0.0.1 7777
```

**관찰 포인트**: RTT에 따라 처리량이 달라진다. 여러 클라이언트를 병렬로 붙여보고, 서버 측 CPU/소켓 큐(백로그), 컨텍스트 스위치 등을 관찰하자.

### 장애와 복구

- **재시도/Idempotency 키**: 중복 처리 방지
- **Circuit Breaker/Timeout/Bulkhead**: 연쇄 장애 차단
- **데이터 복제**: 동기/비동기, 다중 AZ/리전

---

## Kernel Data Structures (커널 자료구조)

커널은 **최소한의 지연과 높은 동시성**을 목표로, 다음 특성이 중요한 자료구조를 사용한다.

- **Cache locality**: 바운스 감소, false sharing 방지
- **락 설계**: 스핀락/뮤텍스/RW락/RCU
- **메모리 관리 친화성**: slab/slub, page allocator와의 궁합
- **비용 모델**: 암시적 상수·분기 예측·캐시라인 폭 등

아래는 **핵심 구조**와 **간단 구현/사용 예**다. (생산 커널은 훨씬 복잡/최적화되어 있음)

### Lists, Stacks, and Queues

#### 연결 리스트: Linux style `list_head` (축약 버전)

```c
// klist.h (학습용 축약)
typedef struct list_head { struct list_head *next, *prev; } list_head;

#define LIST_HEAD_INIT(name) { &(name), &(name) }
#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(list_head *l){ l->next=l; l->prev=l; }

static inline void __list_add(list_head *n, list_head *prev, list_head *next){
    next->prev = n; n->next = next; n->prev = prev; prev->next = n;
}

static inline void list_add(list_head *n, list_head *head){ __list_add(n, head, head->next); }
static inline void list_add_tail(list_head *n, list_head *head){ __list_add(n, head->prev, head); }

static inline void __list_del(list_head *prev, list_head *next){ next->prev=prev; prev->next=next; }
static inline void list_del(list_head *e){ __list_del(e->prev, e->next); INIT_LIST_HEAD(e); }

#define list_entry(ptr, type, member) ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))
#define list_for_each(pos, head) for(pos=(head)->next; pos!=(head); pos=pos->next)

```

사용 예:
```c
#include <stdio.h>

typedef struct task {
    int pid;
    list_head link;
} task;

int main(){
    LIST_HEAD(runqueue);
    task a={.pid=1}, b={.pid=2}, c={.pid=3};
    INIT_LIST_HEAD(&a.link); INIT_LIST_HEAD(&b.link); INIT_LIST_HEAD(&c.link);
    list_add(&a.link, &runqueue);
    list_add_tail(&b.link, &runqueue);
    list_add(&c.link, &runqueue);

    list_head *p;
    list_for_each(p, &runqueue){
        task* t = list_entry(p, task, link);
        printf("pid=%d\n", t->pid);
    }
}
```

#### 스택: 배열 기반(ABA 이슈 없는 단일스레드 버전)

```c
typedef struct {
    int *data; int top; int cap;
} stack;

int push(stack* s, int v){ if(s->top==s->cap) return -1; s->data[s->top++]=v; return 0; }
int pop(stack* s, int* out){ if(s->top==0) return -1; *out=s->data[--s->top]; return 0; }
```

#### 큐: 고정 길이 링 버퍼(SPSC)

```c
typedef struct {
    int *buf; int cap;
    int head; // write
    int tail; // read
} ringq;

int rq_push(ringq* q, int v){
    int next = (q->head+1) % q->cap;
    if(next == q->tail) return -1; // full
    q->buf[q->head]=v; q->head=next; return 0;
}
int rq_pop(ringq* q, int* out){
    if(q->head==q->tail) return -1; // empty
    *out=q->buf[q->tail]; q->tail=(q->tail+1)%q->cap; return 0;
}
```

> 커널은 동시성을 위해 **락프리 MPSC 큐**, **per-CPU 큐**, **워크큐** 등을 사용한다.

### Trees

커널은 **정렬/탐색이 빠른** 트리를 광범위하게 사용한다. 예: 일정량 이상에서 **레드-블랙 트리(RBTree)**, 간격 관리에는 **interval tree**, 메모리 관리에는 **radix tree**(또는 XArray) 등.

#### 레드-블랙 트리(개념 요약)

- **균형 이진 탐색 트리**의 한 종류. 삽입/삭제 후 **색 규칙**과 **회전**으로 **$$O(\log n)$$** 보장.
- 규칙(요약): 노드는 **빨강/검정**. 루트/리프(NIL)는 검정. 빨강의 자식은 검정. 모든 루트→리프 경로의 검정 노드 수는 동일.

간단 삽입 코드 스케치(의사 C, 실제 동작용으로 단순화):

```c
typedef struct node {
    int key, color;
    struct node *l, *r, *p;
} node;

#define RED 1
#define BLACK 0

// rotate, fixup 등은 길어서 개념 스케치만 — 실제 커널은 lib/rbtree
void left_rotate(node **root, node *x){ /* ... */ }
void right_rotate(node **root, node *x){ /* ... */ }

void insert_fix(node **root, node *z){ /* 색 규칙 복구 + 회전 */ }

void rb_insert(node **root, node *z){
    node *y=NULL, *x=*root;
    while(x){ y=x; x = (z->key < x->key)? x->l : x->r; }
    z->p=y;
    if(!y) *root=z;
    else if(z->key < y->key) y->l=z; else y->r=z;
    z->l=z->r=NULL; z->color=RED;
    insert_fix(root,z);
}
```

#### 인터벌 트리(간격 관리)

파일 잠금 범위, 가상 메모리 영역(VMA) 등 **구간 충돌 탐색**에 유용하다.
각 노드가 `[start, end)` 간격과 **서브트리 최대 end**를 저장, **겹침 여부**를 빠르게 판단.

### Hash Functions and Maps

**해시 테이블**은 평균 $$O(1)$$ 접근을 목표로 한다(부하율과 해시 품질에 좌우).

- **버킷** + **충돌 해결**(개방 주소/체이닝)
- **좋은 해시**: 균일 분포, 적은 클러스터링
- **리사이즈 전략**: 부하율(예: 0.75) 기준 확장

#### 단순 해시 함수 예(djb2 변형)

```c
static inline unsigned long djb2(const unsigned char* s){
    unsigned long h=5381; int c;
    while((c=*s++)) h = ((h<<5)+h) ^ c;
    return h;
}
```

#### 체이닝 기반 해시맵(축약)

```c
typedef struct hnode { const char* k; int v; struct hnode* next; } hnode;
typedef struct { hnode** tab; size_t cap; } hmap;

int hput(hmap* m, const char* k, int v){
    size_t idx = djb2((const unsigned char*)k) % m->cap;
    for(hnode* n=m->tab[idx]; n; n=n->next){
        if(!strcmp(n->k,k)){ n->v=v; return 0; }
    }
    hnode* nn = malloc(sizeof(*nn));
    nn->k=strdup(k); nn->v=v; nn->next=m->tab[idx]; m->tab[idx]=nn; return 0;
}

int hget(hmap* m, const char* k, int* out){
    size_t idx = djb2((const unsigned char*)k) % m->cap;
    for(hnode* n=m->tab[idx]; n; n=n->next){
        if(!strcmp(n->k,k)){ *out=n->v; return 0; }
    }
    return -1;
}
```

> 커널에서는 **per-CPU 해시**, **RCU 기반 해시** 등으로 동시성과 locality를 챙긴다.

### Bitmaps

**비트맵**은 **자원 할당/해제**(페이지 프레임, inode, 블록 등)에 널리 쓰인다.
**한 비트 = 한 단위**: 1(할당됨)/0(비어있음)

#### 기본 비트 연산

```c
static inline void set_bit(unsigned long *bm, size_t i){ bm[i/64] |=  (1UL<<(i%64)); }
static inline void clr_bit(unsigned long *bm, size_t i){ bm[i/64] &= ~(1UL<<(i%64)); }
static inline int  tst_bit(unsigned long *bm, size_t i){ return (bm[i/64]>>(i%64)) & 1UL; }
```

#### 첫 번째 0 비트 찾기(FFZ)

```c
ssize_t find_first_zero(unsigned long *bm, size_t nbits){
    size_t words = (nbits+63)/64;
    for(size_t w=0; w<words; ++w){
        unsigned long v = ~bm[w];
        if(v){ // 비어있는 비트 있음
            int off = __builtin_ctzl(v); // 하위 0비트 위치 (GCC/Clang)
            size_t idx = w*64 + off;
            if(idx < nbits) return (ssize_t)idx;
        }
    }
    return -1; // 없음
}
```

#### 간단 자원 할당기(비트맵 기반)

```c
typedef struct { unsigned long *bits; size_t n; } pool;

ssize_t alloc_slot(pool* p){
    ssize_t i = find_first_zero(p->bits, p->n);
    if(i>=0) set_bit(p->bits, (size_t)i);
    return i;
}
int free_slot(pool* p, size_t i){
    if(i>=p->n) return -1;
    clr_bit(p->bits, i); return 0;
}
```

---

## 통합 실험 시나리오 — “컨테이너형 Key-Value 캐시”로 끝에서 끝까지 보기

**목표**: 보안(격리)·가상화(네임스페이스)·분산(간단 RPC)·커널 자료구조(해시, 비트맵)의 상호작용을 직접 체감.

1) **네임스페이스로 격리된 프로세스**에서,
2) **간단 해시맵**을 메모리 캐시로 사용하고,
3) **소켓 RPC**로 `GET/SET`을 제공,
4) **비트맵**으로 세션/슬롯을 관리한다.

### 서버(요약 파이썬 + C 확장 개념)

- 파이썬으로 **RPC 루프** 작성, 내부 저장은 C 확장(여기선 C 해시맵을 별도 프로세스로 가정) 또는 파이썬 dict로 시작
- **unshare**로 네임스페이스 분리, **cgroups**로 CPU 제한, **capabilities** 최소화

```bash
# 네임스페이스 분리 + 리소스 제한(개념 흐름)

sudo unshare -Umnipf bash -c '
  hostname kvns
  mount -t proc proc /proc
  # cgroup v2 리소스 제한 (환경 설정에 맞춰 조정)
  # (여기서는 설명만, 실제 시스템에서 echo로 cpu.max/memory.max 설정)
  python3 - <<PY
import socket, threading
store = {}
def h(c):
    with c:
        while True:
            d = c.recv(1024)
            if not d: break
            try:
                op, *rest = d.decode().strip().split()
            except:
                c.sendall(b"ERR\n"); continue
            if op=="SET" and len(rest)==2:
                k,v = rest; store[k]=v; c.sendall(b"OK\n")
            elif op=="GET" and len(rest)==1:
                k=rest[0]; c.sendall((store.get(k,"")+"\n").encode())
            else:
                c.sendall(b"ERR\n")
s=socket.socket(); s.bind(("0.0.0.0",9000)); s.listen(128)
print("KV on 9000")
while True:
    c,_=s.accept()
    threading.Thread(target=h,args=(c,),daemon=True).start()
PY
'
```

```bash
# 클라이언트

printf "SET a 123\nGET a\n" | nc 127.0.0.1 9000
```

**관찰 포인트**
- **보안/격리**: `ps`, `lsns`, `hostname`으로 네임스페이스 확인
- **자원 관리**: `top -H`, `ps -eo pid,psr,pri,ni,stat`
- **커널 자료구조의 효과**: 요청 수가 늘 때 해시맵 접근이 **평균 O(1)**로 유지되는가?
- **분산 확장**: 동일 서버를 여러 네임스페이스/컨테이너로 띄우고 **클라이언트 라운드로빈**으로 스루풋/지연 비교.

---

## 체크리스트 & 요약

- **보안/보호**: Access Matrix, 권한 모델(ACL/Capabilities/RBAC), MAC(SELinux/AppArmor), 하드닝(ASLR/DEP/Canary/seccomp)
- **가상화**: 프로세스/컨테이너(네임스페이스+cgroups), 머신(KVM/Xen), virtio, 스케줄링·TLB의 비용
- **분산**: CAP/일관성 모델, 시간 동기화, 합의(Raft), RPC/메시징, 백프레셔/재시도
- **커널 자료구조**: 리스트(스케줄 큐·inode 체인), 트리(RB/interval/radix), 해시(소켓/파일 캐시), 비트맵(페이지/블록 할당)

**핵심 메시지**:
운영체제는 **보호**로부터 **격리**를 만들고, **가상화**로 자원을 유연하게 사용하며, **분산**으로 확장한다. 이 모든 것을 가능하게 하는 토대가 **커널 자료구조**다. 각 계층의 **시간(지연)**과 **공간(메모리/캐시)** 비용을 정량적으로 관찰·최적화하라.

---

## 더 해보기(연습 문제)

1) **seccomp** 정책을 수정해 `getpid`를 허용하고, 그 외는 차단되도록 바꿔보자.
2) **컨테이너 네트워크 네임스페이스**에서 veth를 생성해 호스트와 통신시키고, iptables/nftables로 포트만 허용하라.
3) **KV 서버**를 3개 띄워 라운드로빈 클라이언트(멀티스레드)로 **Throughput vs Latency** 곡선을 측정하라.
4) **해시맵 부하율**을 바꿔가며 평균 탐색 길이를 측정하라(충돌 시 체이닝 길이).
5) **비트맵 기반 할당기**에 “첫 맞춤(first-fit) vs 다음 맞춤(next-fit)” 전략을 넣고 조각화 정도를 비교하라.
