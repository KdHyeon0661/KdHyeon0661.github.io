---
layout: post
title: Avalonia - 리스트 바인딩 확장
date: 2025-01-05 20:20:23 +0900
category: Avalonia
---
# Avalonia 리스트 확장 기능 예제 (추가, 삭제, 필터, 상세 보기)

## 1) 프로젝트 구조

```
MyAvaloniaApp/
├── Models/
│   └── Person.cs
├── Services/
│   ├── IPeopleStorage.cs
│   └── FilePeopleStorage.cs
├── ViewModels/
│   ├── ViewModelBase.cs
│   └── PeopleViewModel.cs
├── Views/
│   ├── PeopleView.axaml          # ListBox 템플릿 버전
│   ├── PeopleGridView.axaml      # DataGrid 버전
│   └── PeopleView.axaml.cs
├── App.axaml
├── App.axaml.cs
└── MyAvaloniaApp.csproj
```

---

## 2) Model — `Person.cs`

```csharp
// Models/Person.cs
namespace MyAvaloniaApp.Models
{
    public sealed class Person
    {
        public string Name { get; }
        public int Age { get; }

        public Person(string name, int age)
        {
            Name = name;
            Age  = age;
        }

        public Person With(string? name = null, int? age = null)
            => new(name ?? Name, age ?? Age);
    }
}
```

- **불변(immutable)** 형태를 기본으로 제시(수정 시 새 인스턴스). 양방향 편집이 많다면 set 접근자를 둔 가변형도 가능.

---

## 3) Storage 서비스(선택) — JSON 저장/불러오기

```csharp
// Services/IPeopleStorage.cs
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using MyAvaloniaApp.Models;

namespace MyAvaloniaApp.Services
{
    public interface IPeopleStorage
    {
        Task<IReadOnlyList<Person>> LoadAsync(CancellationToken ct = default);
        Task SaveAsync(IEnumerable<Person> people, CancellationToken ct = default);
    }
}
```

```csharp
// Services/FilePeopleStorage.cs
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using MyAvaloniaApp.Models;

namespace MyAvaloniaApp.Services
{
    public sealed class FilePeopleStorage : IPeopleStorage
    {
        private readonly string _path;

        public FilePeopleStorage(string path) => _path = path;

        public async Task<IReadOnlyList<Person>> LoadAsync(CancellationToken ct = default)
        {
            if (!File.Exists(_path)) return new List<Person>();
            await using var fs = File.OpenRead(_path);
            var data = await JsonSerializer.DeserializeAsync<List<PersonDto>>(fs, cancellationToken: ct)
                       ?? new List<PersonDto>();
            return data.Select(d => new Person(d.Name, d.Age)).ToList();
        }

        public async Task SaveAsync(IEnumerable<Person> people, CancellationToken ct = default)
        {
            var data = people.Select(p => new PersonDto { Name = p.Name, Age = p.Age }).ToList();
            await using var fs = File.Create(_path);
            await JsonSerializer.SerializeAsync(fs, data, new JsonSerializerOptions { WriteIndented = true }, ct);
        }

        private sealed class PersonDto
        {
            public string Name { get; set; } = "";
            public int Age { get; set; }
        }
    }
}
```

---

## 4) ViewModel 기반 — ReactiveUI 버전

### 4.1 ViewModelBase

```csharp
// ViewModels/ViewModelBase.cs
using ReactiveUI;

namespace MyAvaloniaApp.ViewModels
{
    public class ViewModelBase : ReactiveObject { }
}
```

### 4.2 PeopleViewModel — 추가/삭제/수정/필터/정렬/저장/불러오기

```csharp
// ViewModels/PeopleViewModel.cs
using MyAvaloniaApp.Models;
using MyAvaloniaApp.Services;
using ReactiveUI;
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reactive;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace MyAvaloniaApp.ViewModels
{
    public sealed class PeopleViewModel : ViewModelBase
    {
        private readonly IPeopleStorage? _storage;
        private readonly TimeSpan _filterDebounce = TimeSpan.FromMilliseconds(200);
        private readonly ObservableAsPropertyHelper<bool> _isBusy;

        public ObservableCollection<Person> People { get; } = new();
        public ObservableCollection<Person> FilteredPeople { get; } = new();

        private string _filterText = "";
        public string FilterText
        {
            get => _filterText;
            set => this.RaiseAndSetIfChanged(ref _filterText, value);
        }

        // 신규 입력용 필드(문자열로 받아서 검증)
        private string _nameInput = "";
        public string NameInput
        {
            get => _nameInput;
            set => this.RaiseAndSetIfChanged(ref _nameInput, value);
        }

        private string _ageInput = "";
        public string AgeInput
        {
            get => _ageInput;
            set => this.RaiseAndSetIfChanged(ref _ageInput, value);
        }

        private Person? _selected;
        public Person? SelectedPerson
        {
            get => _selected;
            set => this.RaiseAndSetIfChanged(ref _selected, value);
        }

        // 편집(수정)용 임시 필드
        private string _editName = "";
        public string EditName
        {
            get => _editName;
            set => this.RaiseAndSetIfChanged(ref _editName, value);
        }

        private string _editAge = "";
        public string EditAge
        {
            get => _editAge;
            set => this.RaiseAndSetIfChanged(ref _editAge, value);
        }

        public ReactiveCommand<Unit, Unit> AddCommand { get; }
        public ReactiveCommand<Unit, Unit> DeleteCommand { get; }
        public ReactiveCommand<Unit, Unit> BeginEditCommand { get; }
        public ReactiveCommand<Unit, Unit> ApplyEditCommand { get; }
        public ReactiveCommand<Unit, Unit> ClearEditCommand { get; }
        public ReactiveCommand<Unit, Unit> SaveToFileCommand { get; }
        public ReactiveCommand<Unit, Unit> LoadFromFileCommand { get; }

        public bool IsBusy => _isBusy.Value;

        public PeopleViewModel(IPeopleStorage? storage = null)
        {
            _storage = storage;

            // 초기 데이터
            People.Add(new Person("홍길동", 30));
            People.Add(new Person("김철수", 25));
            People.Add(new Person("이영희", 28));

            // 필터 적용: Text 변화 → 200ms 디바운스 → 리스트 재구성
            this.WhenAnyValue(vm => vm.FilterText)
                .Throttle(_filterDebounce)
                .ObserveOn(RxApp.MainThreadScheduler)
                .Subscribe(_ => ApplyFilter());

            ApplyFilter();

            AddCommand = ReactiveCommand.Create(AddPerson);
            DeleteCommand = ReactiveCommand.Create(DeletePerson, this.WhenAnyValue(vm => vm.SelectedPerson).Select(p => p != null));

            BeginEditCommand  = ReactiveCommand.Create(BeginEdit, this.WhenAnyValue(vm => vm.SelectedPerson).Select(p => p != null));
            ApplyEditCommand  = ReactiveCommand.Create(ApplyEdit, this.WhenAnyValue(vm => vm.SelectedPerson).Select(p => p != null));
            ClearEditCommand  = ReactiveCommand.Create(ClearEdit);

            // 파일 저장/불러오기(옵션)
            var canPersist = _storage != null;
            SaveToFileCommand = ReactiveCommand.CreateFromTask(SaveAsync, this.WhenAnyValue(_ => canPersist));
            LoadFromFileCommand = ReactiveCommand.CreateFromTask(LoadAsync, this.WhenAnyValue(_ => canPersist));

            _isBusy = SaveToFileCommand.IsExecuting
                .Merge(LoadFromFileCommand.IsExecuting)
                .ToProperty(this, vm => vm.IsBusy, scheduler: RxApp.MainThreadScheduler);
        }

        private void AddPerson()
        {
            if (string.IsNullOrWhiteSpace(NameInput)) return;
            if (!int.TryParse(AgeInput, out var age) || age <= 0) return;

            var person = new Person(NameInput.Trim(), age);
            People.Add(person);

            NameInput = "";
            AgeInput  = "";
            ApplyFilter();
        }

        private void DeletePerson()
        {
            if (SelectedPerson is null) return;
            People.Remove(SelectedPerson);
            SelectedPerson = null;
            ApplyFilter();
            ClearEdit();
        }

        private void BeginEdit()
        {
            if (SelectedPerson is null) return;
            EditName = SelectedPerson.Name;
            EditAge  = SelectedPerson.Age.ToString();
        }

        private void ApplyEdit()
        {
            if (SelectedPerson is null) return;
            var index = People.IndexOf(SelectedPerson);
            if (index < 0) return;

            if (string.IsNullOrWhiteSpace(EditName)) return;
            if (!int.TryParse(EditAge, out var age) || age <= 0) return;

            var updated = SelectedPerson.With(name: EditName.Trim(), age: age);
            People[index] = updated; // 불변 객체 교체
            SelectedPerson = updated;

            ApplyFilter();
        }

        private void ClearEdit()
        {
            EditName = "";
            EditAge  = "";
        }

        private void ApplyFilter()
        {
            // 간단한 이름 필터 + 이름 오름차순 정렬 예
            var query = People.AsEnumerable();
            if (!string.IsNullOrWhiteSpace(FilterText))
            {
                query = query.Where(p => p.Name.Contains(FilterText, StringComparison.OrdinalIgnoreCase));
            }
            query = query.OrderBy(p => p.Name);

            FilteredPeople.Clear();
            foreach (var p in query)
                FilteredPeople.Add(p);
        }

        private async Task SaveAsync()
        {
            if (_storage is null) return;
            using var cts = new CancellationTokenSource();
            await _storage.SaveAsync(People, cts.Token);
        }

        private async Task LoadAsync()
        {
            if (_storage is null) return;
            using var cts = new CancellationTokenSource();
            var loaded = await _storage.LoadAsync(cts.Token);

            People.Clear();
            foreach (var p in loaded) People.Add(p);

            ApplyFilter();
        }
    }
}
```

포인트
- **입력 검증**: Age는 문자열로 입력받아 `int.TryParse` 후 적용(바인딩 변환기 대신 간단 검증 흐름).
- **디바운스 필터**: 타이핑할 때마다 즉시 재계산하지 않고 200ms 지연 후 필터.
- **정렬**: 필터 후 이름 오름차순.
- **저장/불러오기**: `IPeopleStorage` 주입 시 활성화. 없는 경우 버튼 비활성화 조건을 둘 수도 있다.

---

## 5) View — 템플릿 기반(ListBox) 버전

`ListView.Columns`/`GridViewColumn`은 WPF 방식이므로, Avalonia에서는 **ListBox + ItemTemplate** 혹은 **DataGrid**를 사용한다.

```xml
<!-- Views/PeopleView.axaml : 템플릿 기반 리스트 -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:MyAvaloniaApp.ViewModels"
             x:Class="MyAvaloniaApp.Views.PeopleView"
             Width="760" Height="520">

  <UserControl.DataContext>
    <vm:PeopleViewModel/>
  </UserControl.DataContext>

  <Grid RowDefinitions="Auto,*,Auto" ColumnDefinitions="*,*"
        Margin="12" >

    <!-- 필터 + 상태 -->
    <StackPanel Grid.Row="0" Grid.ColumnSpan="2" Orientation="Horizontal" Spacing="8">
      <TextBox Width="240" Watermark="이름으로 검색" Text="{Binding FilterText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
      <TextBlock Text="{Binding IsBusy, StringFormat='저장/불러오기 동작 중: {0}'}" />
    </StackPanel>

    <!-- 리스트(템플릿) -->
    <Border Grid.Row="1" Grid.Column="0" Margin="0,8,8,8" Padding="8">
      <ListBox Items="{Binding FilteredPeople}"
               SelectedItem="{Binding SelectedPerson, Mode=TwoWay}">
        <ListBox.ItemTemplate>
          <DataTemplate>
            <Grid ColumnDefinitions="*,80" Margin="0,2">
              <TextBlock Text="{Binding Name}" />
              <TextBlock Grid.Column="1" Text="{Binding Age}" HorizontalAlignment="Right"/>
            </Grid>
          </DataTemplate>
        </ListBox.ItemTemplate>
      </ListBox>
    </Border>

    <!-- 상세 + 편집 -->
    <Border Grid.Row="1" Grid.Column="1" Margin="8" Padding="8">
      <StackPanel Spacing="8">
        <TextBlock Text="선택된 사람" FontWeight="Bold" />
        <TextBlock Text="{Binding SelectedPerson.Name}" />
        <TextBlock Text="{Binding SelectedPerson.Age}" />

        <Separator/>

        <TextBlock Text="수정" FontWeight="Bold" />
        <TextBox Width="260" Watermark="이름" Text="{Binding EditName, Mode=TwoWay}" />
        <TextBox Width="120" Watermark="나이(정수)" Text="{Binding EditAge, Mode=TwoWay}" />
        <StackPanel Orientation="Horizontal" Spacing="8">
          <Button Content="수정 시작" Command="{Binding BeginEditCommand}"/>
          <Button Content="적용" Command="{Binding ApplyEditCommand}"/>
          <Button Content="취소" Command="{Binding ClearEditCommand}"/>
        </StackPanel>
      </StackPanel>
    </Border>

    <!-- 추가/삭제 + 저장/불러오기 -->
    <StackPanel Grid.Row="2" Grid.ColumnSpan="2" Orientation="Horizontal" Spacing="8">
      <TextBox Width="200" Watermark="이름" Text="{Binding NameInput, Mode=TwoWay}" />
      <TextBox Width="100" Watermark="나이(정수)" Text="{Binding AgeInput, Mode=TwoWay}" />
      <Button Content="추가" Command="{Binding AddCommand}"/>
      <Button Content="선택 삭제" Command="{Binding DeleteCommand}"/>

      <Separator Margin="10,0"/>

      <Button Content="파일 저장(JSON)" Command="{Binding SaveToFileCommand}"/>
      <Button Content="파일 불러오기" Command="{Binding LoadFromFileCommand}"/>
    </StackPanel>
  </Grid>
</UserControl>
```

---

## 6) View — 표형(DataGrid) 버전

> DataGrid 사용 전 패키지 추가:
>
> ```bash
> dotnet add package Avalonia.Controls.DataGrid
> ```

```xml
<!-- Views/PeopleGridView.axaml : DataGrid 기반 리스트 -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="https://github.com/avaloniaui"
             xmlns:vm="using:MyAvaloniaApp.ViewModels"
             xmlns:dg="clr-namespace:Avalonia.Controls;assembly=Avalonia.Controls.DataGrid"
             x:Class="MyAvaloniaApp.Views.PeopleGridView"
             Width="760" Height="520">

  <UserControl.DataContext>
    <vm:PeopleViewModel/>
  </UserControl.DataContext>

  <Grid RowDefinitions="Auto,*" Margin="12">
    <StackPanel Orientation="Horizontal" Spacing="8">
      <TextBox Width="240" Watermark="이름으로 검색" Text="{Binding FilterText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
      <Button Content="추가" Command="{Binding AddCommand}"/>
      <Button Content="선택 삭제" Command="{Binding DeleteCommand}"/>
    </StackPanel>

    <dg:DataGrid Grid.Row="1" Items="{Binding FilteredPeople}" AutoGenerateColumns="False"
                 IsReadOnly="True" SelectionMode="Single" SelectedItem="{Binding SelectedPerson}">
      <dg:DataGrid.Columns>
        <dg:DataGridTextColumn Header="이름" Binding="{Binding Name}" Width="*"/>
        <dg:DataGridTextColumn Header="나이" Binding="{Binding Age}" Width="120"/>
      </dg:DataGrid.Columns>
    </dg:DataGrid>
  </Grid>
</UserControl>
```

---

## 7) App — DI/리소스/탬플릿(선택)

필요 시 `App.axaml.cs`에서 저장소 구현을 주입:

```csharp
// App.axaml.cs
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Microsoft.Extensions.DependencyInjection;
using MyAvaloniaApp.Services;
using MyAvaloniaApp.ViewModels;

namespace MyAvaloniaApp
{
    public partial class App : Application
    {
        public static ServiceProvider Services { get; private set; } = default!;

        public override void OnFrameworkInitializationCompleted()
        {
            var sc = new ServiceCollection();

            // JSON 저장 경로 예시
            sc.AddSingleton<IPeopleStorage>(_ => new FilePeopleStorage("people.json"));

            // VM
            sc.AddTransient<PeopleViewModel>();

            Services = sc.BuildServiceProvider();

            if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            {
                var vm = Services.GetRequiredService<PeopleViewModel>();
                desktop.MainWindow = new Views.MainWindow { DataContext = vm };
            }

            base.OnFrameworkInitializationCompleted();
        }
    }
}
```

리소스/스타일 병합은 앞선 글(Avalonia View 구조)에서 설명한 패턴과 동일하다.

---

## 8) CommunityToolkit.Mvvm 대안(선택 스니펫)

ReactiveUI 대신 Toolkit을 쓰려면:

```csharp
// ViewModels/PeopleViewModel.Toolkit.cs (개념 스니펫)
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using MyAvaloniaApp.Models;
using System.Collections.ObjectModel;

public partial class PeopleViewModel : ObservableObject
{
    public ObservableCollection<Person> People { get; } = new();
    public ObservableCollection<Person> FilteredPeople { get; } = new();

    [ObservableProperty] private string filterText = "";
    [ObservableProperty] private string nameInput = "";
    [ObservableProperty] private string ageInput  = "";
    [ObservableProperty] private Person? selectedPerson;

    [RelayCommand]
    private void Add()
    {
        if (!string.IsNullOrWhiteSpace(NameInput) && int.TryParse(AgeInput, out var age) && age > 0)
        {
            People.Add(new Person(NameInput.Trim(), age));
            NameInput = ""; AgeInput = "";
            ApplyFilter();
        }
    }

    [RelayCommand(CanExecute = nameof(CanDelete))]
    private void Delete()
    {
        if (SelectedPerson is null) return;
        People.Remove(SelectedPerson);
        SelectedPerson = null;
        ApplyFilter();
    }

    private bool CanDelete() => SelectedPerson != null;

    partial void OnFilterTextChanged(string value) => ApplyFilter();

    private void ApplyFilter()
    {
        // ...
    }
}
```

---

## 9) 단위 테스트(뼈대)

```csharp
// MyAvaloniaApp.Tests/PeopleViewModelTests.cs
using MyAvaloniaApp.ViewModels;
using Xunit;

public class PeopleViewModelTests
{
    [Fact]
    public void Add_ValidInput_IncreasesCount()
    {
        var vm = new PeopleViewModel();
        var before = vm.People.Count;

        vm.NameInput = "테스터";
        vm.AgeInput  = "42";
        vm.AddCommand.Execute().Subscribe(); // ReactiveUI

        Assert.True(vm.People.Count == before + 1);
    }

    [Fact]
    public void Filter_Works()
    {
        var vm = new PeopleViewModel();
        vm.FilterText = "홍길동";
        // 디바운스가 있다면 테스트에서 ApplyFilter를 직접 호출하거나 스케줄러 제어
        // 여기서는 간단히 직접 호출했다고 가정
        // vm.TestApplyFilter(); // 필요시 별도 유틸
        Assert.All(vm.FilteredPeople, p => Assert.Contains("홍길동", p.Name));
    }
}
```

---

## 10) 성능/스레딩/오류 처리 팁

- **가상화**: 대량 데이터는 **DataGrid** 사용 시 가상화 이점이 크다. `ListBox`도 템플릿을 간결히 유지.
- **UI 스레드**: `ObservableCollection` 변경은 **UI 스레드에서** 해야 한다. 비동기 로딩 시 `ObserveOn(RxApp.MainThreadScheduler)`로 전환.
- **검증**: 숫자 입력은 변환기(`IValueConverter`)로도 처리 가능하나, 본문에서는 문자열→검증→변환 패턴을 제시.
- **디바운스**: 실시간 필터링 비용을 줄이기 위해 디바운스를 사용했다.
- **예외 처리**: 파일 I/O는 try/catch로 감싸 사용자 피드백(상태 텍스트/다이얼로그)을 제공.

---

## 11) 요약 테이블

| 기능 | 구현 포인트 |
|------|-------------|
| 추가/삭제 | `ReactiveCommand`(또는 `RelayCommand`)로 상태 변경 |
| 필터링 | 디바운스 + 부분 일치(대소문자 무시) + 정렬 |
| 상세/수정 | 선택 항목을 편집용 필드로 복사 → 검증 → 교체 |
| 표 형태 | **DataGrid** 권장(`Avalonia.Controls.DataGrid`) |
| 템플릿 리스트 | `ListBox` + `DataTemplate`로 간단/가벼운 목록 |
| 저장/불러오기 | `IPeopleStorage` + `FilePeopleStorage(JSON)` |
| 테스트 | ViewModel 단위 테스트로 핵심 로직 검증 |

---

## 12) 결론

초안의 **추가/삭제/필터/상세 보기**를 바탕으로, Avalonia에서 **실전적으로 권장되는 컨트롤과 패턴**(ListBox 템플릿 vs DataGrid, 디바운스 필터, 검증, 편집, JSON 영속화, 테스트)까지 통합했다.  
이 스캐폴딩을 기반으로 **페이징/다중 정렬/열 리오더/컬럼 템플릿/CSV 내보내기/원격 API 동기화** 등으로 손쉽게 확장할 수 있다.