---
layout: post
title: DB - 집합 연산자
date: 2025-03-09 19:20:23 +0900
category: DB
---
# SQL 집합 연산자(Set Operators)

## 0. 용어/규칙 요약

- **UNION**: 합집합(중복 제거)
- **UNION ALL**: 합집합(중복 허용, 보통 가장 빠름)
- **INTERSECT**: 교집합(중복 제거)
- **EXCEPT / MINUS(Oracle)**: 차집합(중복 제거)

> **호환 규칙**
> 1) 각 `SELECT`의 **열 개수**가 같아야 한다.
> 2) 각 위치의 **데이터 타입**이 **유니온-호환**(암시적/명시적 CAST 가능)해야 한다.
> 3) **컬럼명은 첫 번째 SELECT의 별칭**이 결과 컬럼명으로 사용된다.
> 4) **ORDER BY는 전체 집합의 끝에서 한 번**만 허용된다(인라인 뷰/서브쿼리로 감싸면 각 파트에서 사용 가능).

---

## 1. 지원 현황(요약)

| DBMS | UNION | UNION ALL | INTERSECT | EXCEPT | MINUS | INTERSECT ALL / EXCEPT ALL |
|---|---|---|---|---|---|---|
| Oracle | ✅ | ✅ | ✅ | ❌ | ✅ | ❌ |
| PostgreSQL | ✅ | ✅ | ✅ | ✅ | ❌ | ✅ (ALL 지원) |
| SQL Server | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ |
| MySQL 8+ | ✅ | ✅ | ❌ | ❌ | ❌ | ❌ |

> MySQL은 **INTERSECT/EXCEPT 미지원** → 아래 **우회 쿼리** 절 참고.

---

## 2. 기본 사용과 동작

### 2.1 UNION — 합집합(중복 제거)

```sql
SELECT name FROM employees
UNION
SELECT name FROM customers
ORDER BY name;
```

- 두 결과를 합쳐서 **중복을 제거**한다(집합적 DISTINCT).
- **NULL 비교**: 집합 연산의 중복 판정에서는 대부분의 RDBMS가 **NULL을 NULL과 동일**로 취급하여 한 번만 남긴다.

### 2.2 UNION ALL — 합집합(중복 허용, 빠름)

```sql
SELECT name FROM employees
UNION ALL
SELECT name FROM customers
ORDER BY name;
```

- 중복 제거를 하지 않아 **정렬/해시 비용이 없다** → 보통 가장 빠른 선택.
- **중복을 나중에 조절**하고 싶다면 `UNION ALL` 후 바깥에서 `GROUP BY`/`DISTINCT`를 적용하는 패턴이 유연하다.

### 2.3 INTERSECT — 교집합(중복 제거)

```sql
-- Oracle / PostgreSQL / SQL Server
SELECT name FROM employees
INTERSECT
SELECT name FROM customers
ORDER BY name;
```

- 두 질의에 **공통 존재**하는 행만 반환.
- **PostgreSQL**은 `INTERSECT ALL`도 지원(공통 등장 횟수의 최소값만큼 반환).

### 2.4 EXCEPT / MINUS — 차집합(중복 제거)

```sql
-- PostgreSQL / SQL Server
SELECT name FROM employees
EXCEPT
SELECT name FROM customers
ORDER BY name;

-- Oracle
SELECT name FROM employees
MINUS
SELECT name FROM customers
ORDER BY name;
```

- 첫 번째 결과에서 두 번째 결과에 **존재하지 않는** 행만 반환.
- PostgreSQL은 `EXCEPT ALL` 지원(빈도 차집합).

---

## 3. 실습용 샘플

```sql
CREATE TABLE employees (id INT, name VARCHAR(50));
CREATE TABLE customers (id INT, name VARCHAR(50));

INSERT INTO employees VALUES
(1, 'Alice'), (2, 'Bob'), (3, 'Charlie'), (4, NULL), (5, 'bob');

INSERT INTO customers VALUES
(101, 'Bob'), (102, 'David'), (103, NULL), (104, 'BOB');
```

> 주의: **대소문자/Collation**과 **NULL 처리**를 함께 관찰할 수 있게 일부러 섞어 두었다.

---

## 4. 결과 비교(+ NULL/대소문자/정렬 관찰)

> 아래 결과는 **DB/Collation 설정에 따라** 달라질 수 있다.
> 예시는 **대소문자 구분(collation: case-sensitive)**, **NULL은 집합 중복 제거 시 동일 취급** 가정.

### 4.1 UNION

```sql
SELECT name FROM employees
UNION
SELECT name FROM customers
ORDER BY name;
```

- 후보 결과: `NULL`, `Alice`, `Bob`, `BOB`, `Charlie`, `David`, `bob`
- **중복 제거**: `'Bob'`과 `'bob'`은 **서로 다른 값**(case-sensitive 가정) → 모두 남음
- **NULL 하나만** 남는다.

### 4.2 UNION ALL

```sql
SELECT name FROM employees
UNION ALL
SELECT name FROM customers
ORDER BY name;
```

- 후보 결과: `employees` 5행 + `customers` 4행 = 9행 그대로.
- **중복/대소문자/NULL** 모두 표시.

### 4.3 INTERSECT

```sql
-- Oracle / PostgreSQL / SQL Server
SELECT name FROM employees
INTERSECT
SELECT name FROM customers;
```

- 공통: `Bob` (대소문자 구분 시 `BOB`/`bob`은 매칭 아님)
- **NULL**은 양쪽 모두에 존재 → 보통 **1행**으로 남는다.

### 4.4 EXCEPT / MINUS

```sql
-- PostgreSQL / SQL Server
SELECT name FROM employees
EXCEPT
SELECT name FROM customers;

-- Oracle
SELECT name FROM employees
MINUS
SELECT name FROM customers;
```

- 결과: `Alice`, `Charlie`, `bob` (case-sensitive 가정)
- `NULL`은 양쪽 모두 등장하므로 차집합에 **포함되지 않는다**.

---

## 5. ORDER BY와 괄호 — 올바른 정렬 위치

**규칙**: 집합 연산 전체의 결과를 정렬하려면 **맨 마지막**에 `ORDER BY`를 한 번만 둔다.

```sql
-- 올바른 예
SELECT name, 'E' AS src FROM employees
UNION ALL
SELECT name, 'C' AS src FROM customers
ORDER BY name, src;
```

**각 SELECT 내부를 정렬**하고 싶으면 **인라인 뷰/서브쿼리**로 감싼다.

```sql
-- Oracle / PostgreSQL
SELECT *
FROM (
  SELECT name, 'E' AS src FROM employees ORDER BY name
) e
UNION ALL
SELECT *
FROM (
  SELECT name, 'C' AS src FROM customers ORDER BY name
) c
ORDER BY name, src;
```

> ANSI 표준에선 **집합 연산자 바로 앞 SELECT에 개별 ORDER BY**를 두려면 **서브쿼리**가 필요하다.
> 일부 DBMS는 **FETCH FIRST / OFFSET**이 인라인 뷰 안에서만 허용되기도 한다.

---

## 6. 데이터 타입 호환 & 명시적 캐스팅

집합 연산은 **동일 위치 컬럼끼리 타입 호환**이 돼야 한다.
호환이 애매하면 **명시적 CAST**로 의도를 고정하라.

```sql
-- 금액을 모두 DECIMAL(12,2)로 정규화
SELECT CAST(amount AS DECIMAL(12,2)) AS amt FROM sales_2024
UNION ALL
SELECT CAST(amount AS DECIMAL(12,2)) FROM sales_2025;
```

> 암시적 승격에 의존하면 **길이/정밀도 손실**이나 **인덱스 사용/정렬 계획**이 달라질 수 있다.

---

## 7. MySQL 우회 쿼리(필수)

MySQL은 `INTERSECT / EXCEPT` 미지원. 아래 패턴을 사용한다.

### 7.1 INTERSECT → **SEM I-Join (EXISTS)**

```sql
-- employees.name ∩ customers.name
SELECT DISTINCT e.name
FROM employees e
WHERE EXISTS (
  SELECT 1
  FROM customers c
  WHERE c.name <=> e.name  -- NULL 안전 동등 비교(=은 NULL 비교 불가)
);
```

> `a <=> b` 는 MySQL의 **NULL-safe equal**. 표준이라면 `IS NOT DISTINCT FROM`를 사용.

### 7.2 EXCEPT → **ANTI-Join (NOT EXISTS)**

```sql
-- employees.name \ customers.name
SELECT DISTINCT e.name
FROM employees e
WHERE NOT EXISTS (
  SELECT 1
  FROM customers c
  WHERE c.name <=> e.name
);
```

### 7.3 INTERSECT ALL / EXCEPT ALL 에뮬레이션(빈도 반영)

```sql
-- INTERSECT ALL: 두 쿼리에서 등장 횟수의 최소만큼 반환
SELECT x.name
FROM (
  SELECT name, COUNT(*) AS cnt
  FROM employees
  GROUP BY name
) e
JOIN (
  SELECT name, COUNT(*) AS cnt
  FROM customers
  GROUP BY name
) c ON c.name <=> e.name
JOIN LATERAL (
  SELECT 1 FROM dual LIMIT LEAST(e.cnt, c.cnt)
) xrep ON TRUE
CROSS JOIN (SELECT e.name) x;

-- MySQL에는 DUAL/LATERAL이 다르게 동작 → 반복 행 생성은 숫자 테이블/재귀 CTE/시퀀스 테이블 등으로 구현
```

> 실무에선 “ALL” 의미가 필요한 경우가 드물지만, **매칭 빈도 기반 로직**(중복 민감)이면 위 패턴이 필요하다.

---

## 8. NULL, 대소문자, Collation

- **중복 제거/집합 비교에서 NULL**: 대부분의 RDBMS는 **NULL = NULL**로 취급(집합 비교 목적의 정의).
- **문자열 대소문자/정렬 순서**: Collation(예: `utf8mb4_0900_as_cs`)에 따라 `'Bob'` vs `'bob'`을 구분하거나 합칠 수 있다.
  - **정렬**이나 **중복 제거** 결과가 달라지므로 **COLLATE 절**로 고정 가능.

```sql
-- 대소문자 무시 Collation 강제(예: PostgreSQL ICU, MySQL도 COLLATE 지원)
SELECT name COLLATE "und-ci" FROM employees
UNION
SELECT name COLLATE "und-ci" FROM customers;
```

---

## 9. 성능 최적화

1) **가능하면 `UNION ALL`**: 중복 제거 비용(정렬/해시)을 피한다.
2) 불가피한 `UNION`이라면:
   - **사전 필터링**을 철저히(WHERE로 소스 축소).
   - 필요하면 **부분 집계** 후 합치기(행수 축소).
3) `INTERSECT/EXCEPT`는 내부적으로 **반조인/세미조인**으로 최적화될 수 있다. 실행 계획 확인.
4) **정렬/ORDER BY**는 큰 비용 → **적절한 인덱스** 또는 **키셋 페이징**으로 줄인다.
5) **병렬 실행**(Oracle PQ, Postgres parallel query 등)을 검토(대용량).
6) 대형 파이프라인: **UNION ALL 후 바깥 한 번 DISTINCT**가 종종 더 빠르다.

```sql
-- “여러 소스 → 합치고 → 마지막에 한 번만 중복 제거”
SELECT DISTINCT key_col, val
FROM (
  SELECT key_col, val FROM src1 WHERE ...
  UNION ALL
  SELECT key_col, val FROM src2 WHERE ...
  UNION ALL
  SELECT key_col, val FROM src3 WHERE ...
) t;
```

---

## 10. 고급 패턴

### 10.1 우선순위 병합(첫 소스 우선, 없으면 다음)

```sql
-- src1이 우선, 없으면 src2 사용
SELECT key, val FROM src1
UNION ALL
SELECT key, val FROM src2 s2
WHERE NOT EXISTS (SELECT 1 FROM src1 s1 WHERE s1.key = s2.key);
```

### 10.2 FULL OUTER JOIN 에뮬레이션(MySQL 등)

```sql
SELECT COALESCE(a.id, b.id) AS id, a.col AS a_col, b.col AS b_col
FROM A a
LEFT JOIN B b ON b.id = a.id
UNION ALL
SELECT b.id, NULL, b.col
FROM B b
LEFT JOIN A a ON a.id = b.id
WHERE a.id IS NULL;
```

### 10.3 상호 배타/중복 레코드 탐지(데이터 품질 점검)

```sql
-- 양쪽 모두에 등장(교집합)
SELECT key FROM A
INTERSECT
SELECT key FROM B;

-- A에만 등장(차집합)
SELECT key FROM A
EXCEPT
SELECT key FROM B;
```

> MySQL은 위를 `EXISTS / NOT EXISTS`로 변환.

---

## 11. 실전 시나리오

### 11.1 “직원/고객 이름 목록” — 합치기 + 표준화

```sql
-- 대소문자 표준화 후 합치기(중복 제거)
SELECT DISTINCT UPPER(name) AS uname
FROM (
  SELECT name FROM employees
  UNION ALL
  SELECT name FROM customers
) t
WHERE uname IS NOT NULL
ORDER BY uname;
```

### 11.2 “활동 사용자” — 최근 로그인 ∪ 최근 구매

```sql
-- 최근 30일 로그인 또는 구매 사용자
SELECT user_id FROM logins WHERE login_at >= CURRENT_DATE - INTERVAL '30 day'
UNION
SELECT user_id FROM orders WHERE order_at >= CURRENT_DATE - INTERVAL '30 day';
```

### 11.3 “재구매 고객” — 로그인 ∩ 구매

```sql
-- 로그인/구매 둘 다 존재
SELECT user_id FROM logins
INTERSECT
SELECT user_id FROM orders;
```

> MySQL: `SELECT DISTINCT l.user_id FROM logins l WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = l.user_id);`

### 11.4 “휴면 고객” — 로그인 \ 구매

```sql
-- 최근 로그인했지만 구매는 없는 고객
SELECT user_id FROM logins
EXCEPT
SELECT user_id FROM orders;

-- Oracle
SELECT user_id FROM logins
MINUS
SELECT user_id FROM orders;
```

---

## 12. 테스트/디버깅 체크리스트

- **열 개수**가 일치하는가?
- **열 타입**이 호환되는가(명시적 CAST 필요?)
- **결과 컬럼명**은 첫 SELECT에서 의도한 별칭인가?
- **ORDER BY 위치**가 올바른가(전체/인라인 뷰)?
- **Collation/대소문자** 영향은 의도대로인가?
- **NULL 처리**가 의도대로인가(집합 중복 제거/비교시)?
- **성능**: `UNION ALL`→필터/집계 vs `UNION` 직접 비교, 실행계획 확인.

---

## 13. 수학적 관점(요약)

$$
\begin{aligned}
A \cup B &:= \{x \mid x \in A \ \text{or}\ x \in B\} \\
A \cap B &:= \{x \mid x \in A \ \text{and}\ x \in B\} \\
A \setminus B &:= \{x \mid x \in A \ \text{and}\ x \notin B\}
\end{aligned}
$$

SQL 집합 연산은 위 정의를 **행의 튜플**에 적용한다. 다만 **정렬/중복/NULL/Collation**은 **DB 엔진 규칙**을 따른다는 점이 수학 집합과의 차이.

---

## 14. 자주 하는 실수(반드시 회피)

1. `ORDER BY`를 **중간 SELECT에 직접** 붙임 → 구문 오류(인라인 뷰로 감싸자).
2. `UNION`으로도 될 일을 무조건 `JOIN`으로 구현 → **중복 폭발**/의미 오해.
3. MySQL에서 `INTERSECT/EXCEPT`를 그대로 사용 → **구문 오류**(EXISTS/NOT EXISTS로 변환).
4. Collation/대소문자 무시 → 현지화 환경에서 **결과/중복 제거 불일치**.
5. 불필요한 `UNION` 남발 → `UNION ALL` + 바깥 `DISTINCT`가 더 빠를 때 많음.

---

## 15. 종합 정리

- **UNION ALL**을 기본으로 생각하고, “진짜 필요한 곳에서만” 중복 제거(`UNION`/`DISTINCT`)를 하자.
- **INTERSECT/EXCEPT**는 개념적으로 명료하지만 DBMS 지원이 다르다(MySQL은 **EXISTS/NOT EXISTS**로 우회).
- **NULL/Collation**이 중복/비교/정렬에 미치는 영향을 알고 있어야 한다.
- **ORDER BY는 전체 결과의 끝**에서 한 번; 중간 정렬은 인라인 뷰를 쓰자.
- 성능은 **필터 → 축소 → 병합** 순서로 생각하고, 실행계획으로 확인하자.

---

## 부록 A) 단일 파일 예제(Oracle/PostgreSQL 호환 느낌)

```sql
-- 1) 합집합(중복 제거)
SELECT name FROM employees
UNION
SELECT name FROM customers
ORDER BY name;

-- 2) 합집합(중복 허용)
SELECT name FROM employees
UNION ALL
SELECT name FROM customers
ORDER BY name;

-- 3) 교집합
-- Oracle/PostgreSQL/SQL Server
SELECT name FROM employees
INTERSECT
SELECT name FROM customers
ORDER BY name;

-- 4) 차집합
-- PostgreSQL/SQL Server
SELECT name FROM employees
EXCEPT
SELECT name FROM customers
ORDER BY name;

-- Oracle
SELECT name FROM employees
MINUS
SELECT name FROM customers
ORDER BY name;
```

## 부록 B) MySQL 전용 우회 패턴 모음

```sql
-- 교집합
SELECT DISTINCT e.name
FROM employees e
WHERE EXISTS (SELECT 1 FROM customers c WHERE c.name <=> e.name);

-- 차집합
SELECT DISTINCT e.name
FROM employees e
WHERE NOT EXISTS (SELECT 1 FROM customers c WHERE c.name <=> e.name);

-- 합집합(중복 제거)
SELECT name FROM (
  SELECT name FROM employees
  UNION ALL
  SELECT name FROM customers
) t
GROUP BY name
ORDER BY name;
```

> 실무에서 집합 연산은 **간결한 문제 정의**와 **엔진별 구현/최적화 차이**를 동시에 이해해야 한다.
> “**의미(집합)**”와 “**엔진(구현/성능)**”을 분리해서 사고하면, 더 정확하고 빠른 SQL을 설계할 수 있다.
