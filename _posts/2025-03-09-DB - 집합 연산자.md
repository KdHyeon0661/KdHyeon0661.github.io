---
layout: post
title: DB - 집합 연산자
date: 2025-03-09 19:20:23 +0900
category: DB
---
# SQL 집합 연산자 완전 정리

## 개요: 집합 연산자의 개념과 종류

SQL의 집합 연산자는 여러 SELECT 문의 결과를 집합 이론에 기반하여 결합하는 연산자입니다. 이들은 수학의 집합 연산 개념을 SQL에 적용한 것으로, 데이터를 수평적으로 결합하는 JOIN과 달리 수직적으로 결합합니다.

주요 집합 연산자 네 가지는 다음과 같습니다:

- **UNION**: 두 결과 집합의 합집합을 반환하며 중복된 행을 제거합니다.
- **UNION ALL**: 두 결과 집합의 합집합을 반환하지만 중복된 행을 제거하지 않습니다. 일반적으로 가장 빠릅니다.
- **INTERSECT**: 두 결과 집합의 교집합을 반환하며 중복된 행을 제거합니다.
- **EXCEPT** (또는 **MINUS**): 첫 번째 결과 집합에서 두 번째 결과 집합을 뺀 차집합을 반환하며 중복된 행을 제거합니다.

집합 연산자를 사용할 때는 몇 가지 중요한 규칙을 따라야 합니다:
1. 각 SELECT 문의 열 개수가 동일해야 합니다.
2. 대응되는 열의 데이터 타입이 호환되어야 합니다.
3. 결과의 열 이름은 첫 번째 SELECT 문의 열 이름이나 별칭을 따릅니다.
4. ORDER BY는 전체 결과에 대해 한 번만 적용할 수 있습니다.

---

## 데이터베이스별 지원 현황

각 데이터베이스 관리 시스템은 집합 연산자를 다르게 지원합니다:

| 데이터베이스 | UNION | UNION ALL | INTERSECT | EXCEPT | 비고 |
|---|---|---|---|---|---|
| **PostgreSQL** | 지원 | 지원 | 지원 | 지원 | INTERSECT ALL, EXCEPT ALL도 지원 |
| **SQL Server** | 지원 | 지원 | 지원 | 지원 | EXCEPT 키워드 사용 |
| **Oracle** | 지원 | 지원 | 지원 | 지원 (MINUS 키워드) | INTERSECT ALL, MINUS ALL은 지원하지 않음 |
| **MySQL 8.0+** | 지원 | 지원 | 지원 | 지원 | 8.0부터 INTERSECT, EXCEPT 지원 |

참고: 이전 버전의 MySQL(8.0 이전)은 INTERSECT와 EXCEPT를 지원하지 않으므로, EXISTS와 NOT EXISTS를 사용한 우회 방법이 필요합니다.

---

## 기본 사용법과 예제

### UNION: 합집합 (중복 제거)
```sql
-- 두 테이블의 이름을 합치고 중복 제거
SELECT name FROM employees
UNION
SELECT name FROM customers
ORDER BY name;
```
UNION은 두 결과 집합을 합치고 중복된 행을 제거합니다. 이는 DISTINCT를 적용한 것과 유사합니다.

### UNION ALL: 합집합 (중복 허용)
```sql
-- 두 테이블의 이름을 합치고 중복 허용
SELECT name FROM employees
UNION ALL
SELECT name FROM customers
ORDER BY name;
```
UNION ALL은 중복 제거 과정이 없기 때문에 일반적으로 UNION보다 빠릅니다. 중복을 허용해도 괜찮거나, 후에 중복을 처리할 계획이라면 UNION ALL을 사용하는 것이 좋습니다.

### INTERSECT: 교집합
```sql
-- 두 테이블에 모두 존재하는 이름 찾기
SELECT name FROM employees
INTERSECT
SELECT name FROM customers
ORDER BY name;
```
INTERSECT는 두 결과 집합에 모두 존재하는 행만 반환합니다.

### EXCEPT (또는 MINUS): 차집합
```sql
-- PostgreSQL, SQL Server
SELECT name FROM employees
EXCEPT
SELECT name FROM customers
ORDER BY name;

-- Oracle
SELECT name FROM employees
MINUS
SELECT name FROM customers
ORDER BY name;
```
EXCEPT(또는 Oracle의 MINUS)는 첫 번째 결과 집합에는 있지만 두 번째 결과 집합에는 없는 행만 반환합니다.

---

## 실습 예제 데이터

다음 예제들을 실행해보기 위한 샘플 데이터입니다:

```sql
-- 테이블 생성
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE customers (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

-- 데이터 삽입
INSERT INTO employees VALUES 
(1, 'Alice'), 
(2, 'Bob'), 
(3, 'Charlie'), 
(4, NULL), 
(5, 'bob');

INSERT INTO customers VALUES 
(101, 'Bob'), 
(102, 'David'), 
(103, NULL), 
(104, 'BOB');
```

이 데이터셋은 대소문자 차이와 NULL 값이 포함되어 있어, 집합 연산자가 이러한 경우를 어떻게 처리하는지 관찰할 수 있습니다.

---

## 주의사항: NULL 값과 대소문자 구분

### NULL 값 처리
집합 연산에서 NULL 값은 특별하게 처리됩니다. 대부분의 데이터베이스는 집합 연산에서 NULL을 NULL과 동일한 것으로 간주합니다. 즉, `UNION`, `INTERSECT`, `EXCEPT` 연산에서 NULL 값은 하나로 취급됩니다.

```sql
-- NULL 값이 양쪽 테이블에 모두 존재할 경우
SELECT name FROM employees WHERE name IS NULL
UNION
SELECT name FROM customers WHERE name IS NULL;
-- 결과: 일반적으로 하나의 NULL 행만 반환됨
```

### 대소문자 구분
문자열의 대소문자 구분은 데이터베이스의 콜레이션(collation) 설정에 따라 다릅니다. 기본적으로 대소문자를 구분하는 설정에서는 'Bob'과 'bob'을 다른 값으로 처리합니다.

```sql
-- 대소문자 구분 설정에서의 UNION
SELECT name FROM employees
UNION
SELECT name FROM customers;
-- 'Bob', 'bob', 'BOB'는 모두 다른 값으로 처리됨
```

특정 콜레이션을 강제하려면 다음과 같이 할 수 있습니다:

```sql
-- PostgreSQL: 대소문자 무시 콜레이션 사용
SELECT name COLLATE "und-u-ks-level2" FROM employees
UNION
SELECT name COLLATE "und-u-ks-level2" FROM customers;
```

---

## ORDER BY의 올바른 사용법

집합 연산자와 ORDER BY를 함께 사용할 때는 주의가 필요합니다. ORDER BY는 전체 결과에 대해서만 적용할 수 있으며, 각 SELECT 문 내부에서는 직접 사용할 수 없습니다.

```sql
-- 올바른 사용법: 전체 결과 정렬
SELECT name, 'Employee' AS type FROM employees
UNION ALL
SELECT name, 'Customer' AS type FROM customers
ORDER BY name, type;

-- 잘못된 사용법: 각 SELECT 내부에서 ORDER BY 사용 (오류 발생)
SELECT name FROM employees ORDER BY name
UNION
SELECT name FROM customers ORDER BY name;
```

각 SELECT 문의 결과를 개별적으로 정렬하고 싶다면, 서브쿼리나 인라인 뷰를 사용해야 합니다:

```sql
-- 서브쿼리를 사용한 개별 정렬
SELECT * FROM (
    SELECT name FROM employees ORDER BY name
) AS emp
UNION ALL
SELECT * FROM (
    SELECT name FROM customers ORDER BY name
) AS cust;
```

---

## 데이터 타입 호환성

집합 연산자를 사용할 때는 각 SELECT 문의 대응되는 열의 데이터 타입이 호환되어야 합니다. 타입이 다르다면 명시적으로 변환해야 합니다.

```sql
-- 명시적 타입 변환을 통한 호환성 보장
SELECT CAST(age AS VARCHAR(10)) AS age_info FROM employees
UNION ALL
SELECT CAST(age_group AS VARCHAR(10)) FROM customers;
```

암시적 타입 변환에 의존하면 예상치 못한 결과나 성능 저하가 발생할 수 있으므로, 가능하면 명시적 타입 변환을 사용하는 것이 좋습니다.

---

## 성능 고려사항과 최적화

집합 연산자의 성능을 최적화하기 위한 몇 가지 지침이 있습니다:

1. **가능하면 UNION ALL 사용하기**: 중복 제거가 필요하지 않다면 UNION 대신 UNION ALL을 사용하세요. 중복 제거 과정은 추가적인 정렬이나 해시 작업을 필요로 하므로 비용이 큽니다.

2. **데이터 양 줄이기**: 집합 연산 전에 WHERE 절을 사용하여 불필요한 데이터를 미리 필터링하세요.

3. **인덱스 활용**: 집합 연산에 자주 사용되는 열에 인덱스를 생성하세요.

4. **UNION ALL과 DISTINCT 조합**: 여러 소스에서 데이터를 합친 후 마지막에 한 번만 중복을 제거하는 패턴이 더 효율적일 수 있습니다.

```sql
-- 여러 소스에서 데이터 수집 후 한 번에 중복 제거
SELECT DISTINCT user_id
FROM (
    SELECT user_id FROM logins WHERE login_date >= '2024-01-01'
    UNION ALL
    SELECT user_id FROM purchases WHERE purchase_date >= '2024-01-01'
    UNION ALL
    SELECT user_id FROM reviews WHERE review_date >= '2024-01-01'
) AS all_users;
```

---

## 고급 패턴과 실전 예제

### FULL OUTER JOIN 에뮬레이션
일부 데이터베이스에서 FULL OUTER JOIN을 지원하지 않을 때 집합 연산자를 사용하여 구현할 수 있습니다.

```sql
-- FULL OUTER JOIN을 UNION으로 구현
SELECT 
    COALESCE(a.id, b.id) AS id,
    a.column AS a_column,
    b.column AS b_column
FROM table_a a
LEFT JOIN table_b b ON a.id = b.id

UNION ALL

SELECT 
    b.id,
    NULL AS a_column,
    b.column AS b_column
FROM table_b b
LEFT JOIN table_a a ON b.id = a.id
WHERE a.id IS NULL;
```

### 데이터 품질 검사
집합 연산자를 사용하여 데이터의 일관성을 검사할 수 있습니다.

```sql
-- 두 테이블 간 데이터 불일치 찾기
-- A에는 있지만 B에는 없는 데이터
SELECT 'In A but not in B' AS issue_type, id, name
FROM table_a
WHERE id NOT IN (SELECT id FROM table_b)

UNION ALL

-- B에는 있지만 A에는 없는 데이터
SELECT 'In B but not in A' AS issue_type, id, name
FROM table_b
WHERE id NOT IN (SELECT id FROM table_a)

ORDER BY issue_type, id;
```

### 계층적 데이터 통합
여러 소스에서 데이터를 수집하여 통합된 뷰를 생성할 때 유용합니다.

```sql
-- 부서별 직원과 고객 통합 목록
SELECT 
    dept_id,
    name,
    'Employee' AS person_type,
    hire_date AS relevant_date
FROM employees

UNION ALL

SELECT 
    dept_id,
    name,
    'Customer' AS person_type,
    registration_date AS relevant_date
FROM customers

ORDER BY dept_id, person_type, name;
```

---

## 실전 시나리오

### 시나리오 1: 활성 사용자 식별
```sql
-- 최근 30일 동안 로그인하거나 구매한 모든 사용자
SELECT DISTINCT user_id
FROM (
    SELECT user_id FROM logins 
    WHERE login_time >= CURRENT_DATE - INTERVAL '30 days'
    
    UNION ALL
    
    SELECT user_id FROM orders 
    WHERE order_time >= CURRENT_DATE - INTERVAL '30 days'
) AS active_users;
```

### 시나리오 2: 재구매 고객 찾기
```sql
-- 두 번 이상 구매한 고객 찾기
SELECT customer_id
FROM (
    -- 첫 번째 구매
    SELECT customer_id, MIN(order_date) AS first_purchase
    FROM orders
    GROUP BY customer_id
    
    INTERSECT
    
    -- 두 번째 이상의 구매
    SELECT customer_id, MIN(order_date)
    FROM orders
    GROUP BY customer_id
    HAVING COUNT(*) >= 2
) AS repeat_customers;
```

### 시나리오 3: 제품 카테고리 분석
```sql
-- 각 카테고리별로 인기 제품과 비인기 제품 비교
SELECT 
    category_id,
    product_id,
    'Top Seller' AS performance_category
FROM top_selling_products

UNION ALL

SELECT 
    category_id,
    product_id,
    'Low Performer' AS performance_category
FROM low_performing_products

ORDER BY category_id, performance_category, product_id;
```

---

## 자주 하는 실수와 피하는 방법

### 실수 1: 불필요한 중복 제거
**문제**: UNION을 사용했지만 실제로 중복 제거가 필요하지 않은 경우
**해결**: UNION ALL을 사용하여 불필요한 처리 비용을 줄이세요.

### 실수 2: ORDER BY 위치 오류
**문제**: 각 SELECT 문 내부에서 ORDER BY를 사용하려고 시도
**해결**: 전체 결과를 정렬하려면 마지막에 ORDER BY를 사용하거나, 서브쿼리를 활용하세요.

### 실수 3: 데이터 타입 불일치
**문제**: 호환되지 않는 데이터 타입을 집합 연산에 사용
**해결**: 명시적 CAST나 CONVERT 함수를 사용하여 타입을 통일하세요.

### 실수 4: 대소문자 문제 무시
**문제**: 콜레이션 설정을 고려하지 않고 문자열 비교
**해결**: 데이터베이스의 콜레이션 설정을 이해하고, 필요시 명시적 콜레이션을 지정하세요.

### 실수 5: 성능 문제 무시
**문제**: 대량 데이터에 UNION을 사용하여 성능 저하
**해결**: 가능한 데이터를 먼저 필터링하고, UNION ALL과 DISTINCT를 조합하여 사용하세요.

---

## 결론

SQL 집합 연산자는 여러 결과 집합을 결합하는 강력한 도구입니다. 각 연산자의 특성을 이해하고 적절히 활용하면 복잡한 데이터 분석 작업을 간결하게 표현할 수 있습니다.

주요 포인트를 정리하면 다음과 같습니다:

1. **적절한 연산자 선택**: 중복 제거가 필요하면 UNION, INTERSECT, EXCEPT를, 성능이 중요하고 중복이 허용되면 UNION ALL을 사용하세요.

2. **데이터베이스별 차이 이해**: 각 데이터베이스 관리 시스템이 지원하는 연산자와 문법이 다를 수 있습니다. 특히 MySQL의 이전 버전에서는 INTERSECT와 EXCEPT를 지원하지 않으므로 EXISTS와 NOT EXISTS를 사용한 대체 방법을 알아야 합니다.

3. **NULL과 대소문자 처리 주의**: 집합 연산에서 NULL 값과 문자열 대소문자는 특별한 주의가 필요합니다. 데이터베이스의 동작 방식을 이해하고 테스트하는 것이 중요합니다.

4. **성능 최적화**: 대량의 데이터를 처리할 때는 가능한 한 빨리 데이터 양을 줄이고, 불필요한 중복 제거를 피하며, 적절한 인덱스를 활용하세요.

5. **가독성과 유지보수성**: 복잡한 집합 연산을 사용할 때는 서브쿼리나 CTE(Common Table Expression)를 활용하여 쿼리를 모듈화하고 가독성을 높이세요.

집합 연산자는 SQL의 수학적 기반을 잘 보여주는 기능입니다. 집합 이론에 대한 기본적인 이해는 더 복잡한 데이터 문제를 해결하는 데 도움이 될 것입니다. 실제 업무에서 집합 연산자를 사용할 때는 항상 작은 데이터셋으로 테스트한 후 확장하고, 실행 계획을 확인하여 성능을 최적화하는 습관을 기르는 것이 좋습니다.