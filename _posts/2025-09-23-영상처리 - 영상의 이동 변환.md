---
layout: post
title: 영상처리 - 영상의 이동 변환
date: 2025-09-23 21:25:23 +0900
category: 영상처리
---
# 영상의 이동(Translation) 변환

## 1) 이동 변환이란?

영상의 모든 점을 \((\Delta x,\Delta y)\) 만큼 **평행 이동**시키는 기하 변환입니다.  
동차 좌표 표현에서 변환 행렬 \(T\)는

\[
T=
\begin{bmatrix}
1 & 0 & \Delta x\\
0 & 1 & \Delta y\\
0 & 0 & 1
\end{bmatrix},\qquad
\begin{bmatrix}x'\\y'\\1\end{bmatrix}
=
T
\begin{bmatrix}x\\y\\1\end{bmatrix}
=
\begin{bmatrix}
x+\Delta x\\y+\Delta y\\1
\end{bmatrix}.
\]

**역방향 매핑(Backward warping)** 을 쓰면, 출력 화소 \((x,y)\)의 원본 좌표는
\[
(x_s, y_s) = (x-\Delta x,\; y-\Delta y)
\]
가 됩니다. 역방향 샘플링을 쓰는 이유는 **출력의 모든 픽셀**을 **정확히 한 번씩** 채울 수 있어서 구멍(hole)이 생기지 않기 때문입니다.

---

## 2) 이동 변환의 구현

### 2.1 설계 포인트

- **보간(Interpolation)**: 최근접(Nearest), 바이리니어(Bilinear).  
- **경계 정책(Border mode)**:  
  - Constant(상수 채움; 색 선택),  
  - Replicate(가장자리 픽셀 반복),  
  - Wrap(타일링).  
- **캔버스 확장(Expand canvas)**: 이동으로 생기는 빈 공간/잘림을 줄이기 위해 **새 캔버스 크기**를 `W + ceil(|Δx|)`, `H + ceil(|Δy|)`로 키우는 옵션.  
- **정수 이동 최적화**: \( \Delta x, \Delta y \) 가 정수라면 **memmove/라인 쉬프트**로 고속화.  
- **알파 처리**: A 채널은 **동일 보간**으로 함께 이동(프리멀티플라이가 아니라면 A도 동일 샘플링이 안전).

### 2.2 핵심 코드

```cpp
// TransformTranslate.h
#pragma once
#include <cstdint>
#include <vector>
#include <cmath>
#include <algorithm>
#include <cstring>
#include "IppDib.h"

enum class Interp { Nearest, Bilinear };
enum class Border { Constant, Replicate, Wrap };

struct TranslateParams {
    float  dx = 0.f;     // +x: 오른쪽으로
    float  dy = 0.f;     // +y: 아래로 (Top-Down DIB)
    Interp interp  = Interp::Bilinear;
    Border border  = Border::Constant;
    uint8_t fillB = 0, fillG = 0, fillR = 0, fillA = 255; // Constant용 색
    bool   expandCanvas = false; // true면 캔버스 크기 확장
};

// ---- 보조: 좌표 조정(경계 정책) ----
inline int mod_pos(int a, int m){ int r = a % m; return (r<0)? r+m : r; }

inline bool map_coord_with_border(int sx, int sy, int W, int H, Border bm, int& ox, int& oy)
{
    if (bm==Border::Replicate) {
        ox = (sx<0)?0:((sx>=W)?W-1:sx);
        oy = (sy<0)?0:((sy>=H)?H-1:sy);
        return true;
    }
    else if (bm==Border::Wrap) {
        ox = mod_pos(sx, W);
        oy = mod_pos(sy, H);
        return true;
    }
    else { // Constant
        if (sx<0 || sx>=W || sy<0 || sy>=H) return false;
        ox = sx; oy = sy; return true;
    }
}

// ---- 최근접 샘플 ----
inline void sample_nearest_BGRA32(const IppDib& src, float fx, float fy,
                                  Border bm, const uint8_t* fill,
                                  uint8_t* outBGRA)
{
    int sx = (int)std::lround(fx);
    int sy = (int)std::lround(fy);
    int ox, oy;
    if (map_coord_with_border(sx, sy, src.width(), src.height(), bm, ox, oy)) {
        const uint8_t* row = (const uint8_t*)src.bits() + (size_t)oy*src.stride();
        const uint8_t* p   = &row[ox*4];
        outBGRA[0]=p[0]; outBGRA[1]=p[1]; outBGRA[2]=p[2]; outBGRA[3]=p[3];
    } else {
        outBGRA[0]=fill[0]; outBGRA[1]=fill[1]; outBGRA[2]=fill[2]; outBGRA[3]=fill[3];
    }
}

// ---- 바이리니어 샘플 ----
inline uint8_t clamp_u8(float v){ if(v<0) v=0; else if(v>255) v=255; return (uint8_t)std::lround(v); }

inline void sample_bilinear_BGRA32(const IppDib& src, float fx, float fy,
                                   Border bm, const uint8_t* fill,
                                   uint8_t* outBGRA)
{
    int x0 = (int)std::floor(fx);
    int y0 = (int)std::floor(fy);
    float ax = fx - x0;
    float ay = fy - y0;

    // 4개 이웃 픽셀
    int x1 = x0 + 1, y1 = y0 + 1;
    const uint8_t* p00=nullptr; const uint8_t* p10=nullptr;
    const uint8_t* p01=nullptr; const uint8_t* p11=nullptr;
    uint8_t buf00[4], buf10[4], buf01[4], buf11[4];

    auto get = [&](int sx, int sy, uint8_t* buf)->const uint8_t* {
        int ox, oy;
        if (map_coord_with_border(sx, sy, src.width(), src.height(), bm, ox, oy)) {
            const uint8_t* row = (const uint8_t*)src.bits() + (size_t)oy*src.stride();
            return &row[ox*4];
        } else {
            buf[0]=fill[0]; buf[1]=fill[1]; buf[2]=fill[2]; buf[3]=fill[3];
            return buf;
        }
    };
    p00 = get(x0,y0,buf00); p10 = get(x1,y0,buf10);
    p01 = get(x0,y1,buf01); p11 = get(x1,y1,buf11);

    for (int c=0;c<4;++c){
        float v0 = p00[c]*(1.f-ax) + p10[c]*ax;
        float v1 = p01[c]*(1.f-ax) + p11[c]*ax;
        float v  = v0*(1.f-ay) + v1*ay;
        outBGRA[c] = clamp_u8(v);
    }
}

// ---- 정수 쉬프트 최적화 (캔버스 고정/Replicate/Wrap 아닌 경우) ----
inline bool fast_integer_translate(const IppDib& src, IppDib& dst, int dx, int dy, const TranslateParams& P)
{
    if (P.expandCanvas || P.border!=Border::Constant || P.interp!=Interp::Nearest)
        return false; // 안전을 위해 제한

    dst.create(src.width(), src.height(), 32);
    // 전체를 fill 색으로 초기화
    for (int y=0;y<dst.height();++y){
        uint8_t* row=(uint8_t*)dst.bits()+(size_t)y*dst.stride();
        for (int x=0;x<dst.width();++x){
            row[x*4+0]=P.fillB; row[x*4+1]=P.fillG; row[x*4+2]=P.fillR; row[x*4+3]=P.fillA;
        }
    }
    // 복사 가능한 교집합 영역
    int sx0 = std::max(0, -dx), sy0 = std::max(0, -dy);
    int dx0 = std::max(0,  dx), dy0 = std::max(0,  dy);
    int copyW = std::min(src.width()-sx0, src.width()-dx0);
    int copyH = std::min(src.height()-sy0, src.height()-dy0);
    if (copyW<=0 || copyH<=0) return true;

    for (int y=0;y<copyH;++y){
        const uint8_t* srow=(const uint8_t*)src.bits() + (size_t)(sy0+y)*src.stride();
        uint8_t* drow=(uint8_t*)dst.bits() + (size_t)(dy0+y)*dst.stride();
        std::memcpy(drow + dx0*4, srow + sx0*4, (size_t)copyW*4);
    }
    return true;
}

// ---- 메인: 이동 변환 ----
inline void Translate_BGRA32(const IppDib& src, IppDib& dst, const TranslateParams& P)
{
    if (!src) { dst=src; return; }

    // 정수 빠른 경로
    int idx = (int)std::lround(P.dx);
    int idy = (int)std::lround(P.dy);
    if (std::fabs(P.dx-idx)<1e-6 && std::fabs(P.dy-idy)<1e-6){
        if (fast_integer_translate(src, dst, idx, idy, P)) return;
    }

    // 캔버스 크기
    int W = src.width(), H = src.height();
    int addW = P.expandCanvas ? (int)std::ceil(std::fabs(P.dx)) : 0;
    int addH = P.expandCanvas ? (int)std::ceil(std::fabs(P.dy)) : 0;
    int newW = W + addW, newH = H + addH;
    dst.create(newW, newH, 32);

    // Constant 초기화
    for (int y=0;y<newH;++y){
        uint8_t* drow=(uint8_t*)dst.bits()+(size_t)y*dst.stride();
        for (int x=0;x<newW;++x){
            drow[x*4+0]=P.fillB; drow[x*4+1]=P.fillG; drow[x*4+2]=P.fillR; drow[x*4+3]=P.fillA;
        }
    }

    // 오프셋(캔버스 확장 시 원점을 음수 이동분만큼 보정)
    float xoff = P.expandCanvas ? std::max(0.f, -P.dx) : 0.f;
    float yoff = P.expandCanvas ? std::max(0.f, -P.dy) : 0.f;

    uint8_t fill[4] = {P.fillB,P.fillG,P.fillR,P.fillA};

    for (int y=0;y<newH;++y){
        uint8_t* drow=(uint8_t*)dst.bits()+(size_t)y*dst.stride();
        for (int x=0;x<newW;++x){
            // 역방향 매핑: (sx,sy) = (x - dx - xoff, y - dy - yoff)
            float sx = (float)x - P.dx - xoff;
            float sy = (float)y - P.dy - yoff;

            uint8_t* pd = &drow[x*4];
            if (P.interp==Interp::Nearest)
                sample_nearest_BGRA32(src, sx, sy, P.border, fill, pd);
            else
                sample_bilinear_BGRA32(src, sx, sy, P.border, fill, pd);
        }
    }
}
```

---

## 3) 이동 변환 대화 상자 만들기

### 3.1 리소스 ID/RC

```cpp
// resource.h (추가)
#define IDD_TRANSLATE_DLG           900
#define IDC_EDIT_TR_DX              2101
#define IDC_EDIT_TR_DY              2102
#define IDC_RAD_TR_NEAREST          2103
#define IDC_RAD_TR_BILINEAR         2104
#define IDC_RAD_BORDER_CONST        2105
#define IDC_RAD_BORDER_REPL         2106
#define IDC_RAD_BORDER_WRAP         2107
#define IDC_EDIT_FILL_R             2108
#define IDC_EDIT_FILL_G             2109
#define IDC_EDIT_FILL_B             2110
#define IDC_CHK_EXPAND_CANVAS       2111

// 메뉴
#define ID_TRANSFORM_TRANSLATE_DLG  62010
```

```rc
// ImageTool.rc (추가)
IDD_TRANSLATE_DLG DIALOGEX 0,0, 240, 150
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Translate (Move)"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "dx:", -1, 12, 14, 16, 10
    EDITTEXT IDC_EDIT_TR_DX, 28, 12, 40, 14, ES_AUTOHSCROLL | WS_TABSTOP
    LTEXT "dy:", -1, 80, 14, 16, 10
    EDITTEXT IDC_EDIT_TR_DY, 96, 12, 40, 14, ES_AUTOHSCROLL | WS_TABSTOP

    GROUPBOX "Interpolation", -1, 12, 34, 72, 40
    AUTORADIOBUTTON "Nearest",  IDC_RAD_TR_NEAREST, 18, 48, 56, 10, WS_TABSTOP
    AUTORADIOBUTTON "Bilinear", IDC_RAD_TR_BILINEAR,18, 60, 56, 10

    GROUPBOX "Border", -1, 92, 34, 68, 54
    AUTORADIOBUTTON "Const",    IDC_RAD_BORDER_CONST, 98, 48, 46, 10, WS_TABSTOP
    AUTORADIOBUTTON "Replicate",IDC_RAD_BORDER_REPL,  98, 60, 56, 10
    AUTORADIOBUTTON "Wrap",     IDC_RAD_BORDER_WRAP,  98, 72, 46, 10

    LTEXT "Fill RGB:", -1, 168, 38, 45, 10
    EDITTEXT IDC_EDIT_FILL_R,  168, 50, 20, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_FILL_G,  192, 50, 20, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_FILL_B,  216, 50, 20, 14, ES_NUMBER

    AUTOCHECKBOX "Expand canvas", IDC_CHK_EXPAND_CANVAS, 12, 84, 90, 10, WS_TABSTOP

    DEFPUSHBUTTON "OK", IDOK,  128, 118, 44, 14
    PUSHBUTTON    "Cancel", IDCANCEL, 178, 118, 44, 14
END

// 메뉴 (일부)
POPUP "&Transform"
BEGIN
    MENUITEM "Translate...\tCtrl+T", ID_TRANSFORM_TRANSLATE_DLG
END

IDR_ACCEL ACCELERATORS
BEGIN
    "T", ID_TRANSFORM_TRANSLATE_DLG, VIRTKEY, CONTROL
END
```

### 3.2 대화 상자 클래스

```cpp
// TranslateDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "TransformTranslate.h"

class TranslateDlg {
public:
    TranslateDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    float  ReadFloat(HWND h, int id, float def) const;
    int    ReadInt(HWND h, int id, int def) const;
    bool   IsChecked(HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }

private:
    HWND   owner_ = nullptr;
    IppDib& dib_;
};
```

```cpp
// TranslateDlg.cpp
#include "TranslateDlg.h"

INT_PTR TranslateDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_TRANSLATE_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK TranslateDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(TranslateDlg*)l; return self->OnInit(h);
    }
    auto* self=(TranslateDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w,l);
    return FALSE;
}
INT_PTR TranslateDlg::OnInit(HWND h){
    SetDlgItemTextW(h, IDC_EDIT_TR_DX, L"20.0");
    SetDlgItemTextW(h, IDC_EDIT_TR_DY, L"15.0");
    CheckRadioButton(h, IDC_RAD_TR_NEAREST, IDC_RAD_TR_BILINEAR, IDC_RAD_TR_BILINEAR);
    CheckRadioButton(h, IDC_RAD_BORDER_CONST, IDC_RAD_BORDER_WRAP, IDC_RAD_BORDER_CONST);
    SetDlgItemInt(h, IDC_EDIT_FILL_R, 0, FALSE);
    SetDlgItemInt(h, IDC_EDIT_FILL_G, 0, FALSE);
    SetDlgItemInt(h, IDC_EDIT_FILL_B, 0, FALSE);
    CheckDlgButton(h, IDC_CHK_EXPAND_CANVAS, BST_UNCHECKED);
    return TRUE;
}
float TranslateDlg::ReadFloat(HWND h, int id, float def) const {
    wchar_t buf[64]; GetDlgItemTextW(h, id, buf, 64);
    wchar_t* e=nullptr; double v=wcstod(buf,&e);
    if (e==buf) return def; return (float)v;
}
int TranslateDlg::ReadInt(HWND h, int id, int def) const {
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    if (!ok) return def; return v;
}
INT_PTR TranslateDlg::OnCommand(HWND h, WPARAM w, LPARAM){
    switch (LOWORD(w)){
    case IDOK: {
        TranslateParams P;
        P.dx = ReadFloat(h, IDC_EDIT_TR_DX, 0.f);
        P.dy = ReadFloat(h, IDC_EDIT_TR_DY, 0.f);
        P.interp = (IsDlgButtonChecked(h, IDC_RAD_TR_NEAREST)==BST_CHECKED)? Interp::Nearest : Interp::Bilinear;

        if (IsDlgButtonChecked(h, IDC_RAD_BORDER_REPL)==BST_CHECKED) P.border=Border::Replicate;
        else if (IsDlgButtonChecked(h, IDC_RAD_BORDER_WRAP)==BST_CHECKED) P.border=Border::Wrap;
        else P.border=Border::Constant;

        P.fillR = (uint8_t)ReadInt(h, IDC_EDIT_FILL_R, 0);
        P.fillG = (uint8_t)ReadInt(h, IDC_EDIT_FILL_G, 0);
        P.fillB = (uint8_t)ReadInt(h, IDC_EDIT_FILL_B, 0);
        P.fillA = 255;

        P.expandCanvas = IsChecked(h, IDC_CHK_EXPAND_CANVAS);

        IppDib out; Translate_BGRA32(dib_, out, P);
        dib_ = out;
        EndDialog(h, IDOK);
        return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL);
        return TRUE;
    }
    return FALSE;
}
```

---

## 4) 이동 변환 메뉴 만들기 (연동)

```cpp
// main_multiwin.cpp (발췌)
#include "TranslateDlg.h"

// ...
case ID_TRANSFORM_TRANSLATE_DLG:
    if (st && st->dib) {
        TranslateDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK) {
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st); // 상태/출력창 갱신
            UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 5) 실전 예제 & 상황

### 예제 A) 워터마크 로고 위치 미세 조정
- **상황**: 오른쪽 아래 워터마크가 살짝 겹침.  
- **동작**: `Transform → Translate…` → dx = **-12.0**, dy = **-8.0**, 보간 **Bilinear**, Border **Constant(0,0,0)**, **Expand canvas Off**.  
- **결과**: 캔버스 크기는 유지, 좌측/상단이 약간 비지만 로고가 원래 프레임 안으로 이동. 필요시 이후 `Crop` 로 정리.

### 예제 B) 텍스처 타일링 테스트
- **상황**: 무늬 텍스처의 심(Seam) 체크.  
- **동작**: dx = **W/2**, dy = **H/2**, Border **Wrap**, 보간 **Nearest**(픽셀 아트).  
- **결과**: 타일 경계에서 심이 있는지 쉽게 시각화 가능. Seam이 보이면 클론/힐 도구로 수정.

### 예제 C) 서브픽셀 정렬(Registration)
- **상황**: 삼각대 연사 사진 2장을 정합. 한 장을 기준으로 다른 한 장을 서브픽셀 이동.  
- **동작**: `dx = 0.35`, `dy = -0.22`, 보간 **Bilinear**, Border **Replicate**, Expand **Off**.  
- **결과**: 덜컥거림(ghosting) 완화. 이후 산술 평균으로 노이즈 감소.

### 예제 D) 프레임보존 이동(크롭 방지)
- **상황**: 오른쪽/아래로 크게 이동시키되 원본이 잘리지 않게 보기.  
- **동작**: dx=**+120.0**, dy=**+80.0**, **Expand canvas On**, Border **Constant**, Fill **RGB(255,255,255)**.  
- **결과**: 새 캔버스가 **W+120×H+80** 으로 확장되어 흰 배경 위로 원본이 이동.

---

## 6) 정확성/성능/UX 팁

- **정확성**
  - 역방향 매핑 \( (x-\Delta x,\,y-\Delta y) \) 으로 구멍 없이 안정적.
  - 바이리니어는 서브픽셀 이동에서 **계단 현상**(aliasing)을 줄임.
  - Wrap 은 **타일 텍스처**에만 사용(일반 사진엔 경계가 말려 보일 수 있음).

- **성능**
  - 정수 이동 경로: `memcpy` 기반으로 매우 빠름(수십 배).  
  - 대형 이미지/반복 이동: 스레딩(행 단위), SSE/NEON 벡터화로 가속 가능.  
  - Expand off + Constant + Nearest + 정수 이동이면 `fast_integer_translate()` 사용.

- **UX**
  - Expand On 시 **xoff/yoff** 보정으로 음수 이동도 0,0 이상에서 안전히 보임.  
  - Constant 색을 **배경색(흰/검)** 으로 미리 지정하거나, 최근 색을 기억하면 편리.

- **알파**
  - 합성 파이프라인이 프리멀티플라이를 쓴다면, 이동 전후 일관되게 유지해야 함(본 예제는 비프리멀티).

---

## 7) 검증 체크리스트

- [ ] dx,dy 정/부호에 따라 이동 방향이 기대와 일치하는지(Top-Down: +dy는 **아래**)  
- [ ] Nearest/Bilinear 시 경계/알파가 정상인지  
- [ ] Border=Constant/Replicate/Wrap 동작 확인(특히 Bilinear의 4샘플 경계 처리)  
- [ ] Expand On/Off 에 따른 캔버스 크기 및 xoff/yoff 보정  
- [ ] 정수 이동 빠른 경로가 선택되는지(프로파일링)  

---

## 8) 확장 아이디어

- **Affine 통합**: 회전/스케일/시어 포함한 일반 아핀 변환에서 이동을 파라미터화.  
- **서브픽셀 정합**: 위상상관(Phase Correlation)으로 자동 추정한 \((\Delta x,\Delta y)\) 적용.  
- **경계 옵션 추가**: Reflect(대칭), MirrorPad 등.  
- **프리뷰 모드**: 슬라이더로 dx/dy 변경 시 즉시 그리기(저해상도 프록시).  
- **벡터 필드**: 픽셀별 이동(옵티컬 플로우/왜곡 보정)의 기본 빌딩 블록으로 확장.

---

## 요약

- 이동 변환은 **가장 기본적인 기하 연산**으로, 역방향 매핑 + 보간/경계 정책으로 안전하게 구현.  
- **최근접/바이리니어**, **Constant/Replicate/Wrap**, **캔버스 확장**까지 실무 옵션을 갖춘 대화 상자/메뉴를 제공.  
- 정수 이동은 **빠른 경로**로 처리하여 큰 이미지에서도 즉시 반응.