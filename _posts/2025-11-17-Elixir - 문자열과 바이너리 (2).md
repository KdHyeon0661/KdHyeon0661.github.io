---
layout: post
title: Elixir - ë¬¸ìì—´ê³¼ ë°”ì´ë„ˆë¦¬ (2)
date: 2025-11-17 21:25:23 +0900
category: Elixir
---
# ë°”ì´ë„ˆë¦¬ì™€ ë¹„íŠ¸ìŠ¤íŠ¸ë§ â€” binary(), bitstring(), iodata(), íŒ¨í„´ ë§¤ì¹­ ì™„ì „ ì •ë¦¬

## _11.4 ë°”ì´ë„ˆë¦¬_

ì´ ì ˆì—ì„œëŠ” ì—˜ë¦­ì„œ/Erlang VMì˜ **binary() / bitstring() / iodata()** ëª¨ë¸ì„ ì •ë¦¬í•˜ê³ ,
`<< >>` êµ¬ë¬¸ìœ¼ë¡œ **ë°”ì´ë„ˆë¦¬ë¥¼ êµ¬ì„±/ë¶„í•´**í•˜ëŠ” ë²•ì„ ì‹¤ì œ í”„ë¡œí† ì½œ ì˜ˆì™€ í•¨ê»˜ ë‹¤ë£¬ë‹¤.

---

### binary() vs bitstring()

ì—˜ë¦­ì„œì˜ ì €ìˆ˜ì¤€ ë¹„íŠ¸/ë°”ì´íŠ¸ íƒ€ì…ì€ í¬ê²Œ ë‘ ê°€ì§€ë‹¤.

- `binary()`  : **8ë¹„íŠ¸(ë°”ì´íŠ¸) ê²½ê³„**ë¡œ ì •ë ¬ëœ ë¹„íŠ¸ìŠ¤íŠ¸ë§
- `bitstring()`: ê¸¸ì´ê°€ **ì„ì˜ ë¹„íŠ¸ ìˆ˜**ì¸ ì‹œí€€ìŠ¤ (ë°”ì´íŠ¸ ê²½ê³„ë¥¼ ë§ì¶œ í•„ìš” ì—†ìŒ)

ìˆ˜ì‹ìœ¼ë¡œ í‘œí˜„í•˜ë©´:

- ì–´ë–¤ ë¹„íŠ¸ìŠ¤íŠ¸ë§ì˜ ê¸¸ì´ë¥¼ ë¹„íŠ¸ ë‹¨ìœ„ë¡œ $$L$$ ì´ë¼ê³  í•  ë•Œ,

  - $$L = 8k \quad (k \in \mathbb{Z}_{\ge 0})$$ ì´ë©´, ì´ ê°’ì€ **binary()** ì´ê¸°ë„ í•˜ë‹¤.
  - $$L \in \mathbb{Z}_{\ge 0}$$ ì´ì§€ë§Œ $$L \bmod 8 \neq 0$$ ì´ë©´, **bitstring()** ì´ì§€ë§Œ binary()ëŠ” ì•„ë‹ˆë‹¤.

```elixir
iex> is_binary(<<1, 2, 3>>)
true

iex> is_bitstring(<<1, 2, 3>>)
true

iex> is_bitstring(<<1, 2, 3::size(1)>>)
true

iex> is_binary(<<1, 2, 3::size(1)>>)
false
```

- `<<1, 2, 3>>`
  - ê° í•­ëª©ì´ 1ë°”ì´íŠ¸(8ë¹„íŠ¸) â†’ ì´ ê¸¸ì´ 24ë¹„íŠ¸ = $$8 \times 3$$ â†’ **binary()** ì´ì bitstring()ì´ë‹¤.
- `<<1, 2, 3::size(1)>>`
  - 1Byte + 1Byte + 1Bit â†’ ì´ ê¸¸ì´ 17ë¹„íŠ¸ â†’ bitstring()ì´ì§€ë§Œ binary()ëŠ” ì•„ë‹˜.

#### ì–¸ì œ bitstring()ì´ í•„ìš”í•œê°€?

ì¼ë°˜ì ì¸ **í…ìŠ¤íŠ¸/JSON/í”„ë¡œí† ì½œ í—¤ë”**ëŠ” ë°”ì´íŠ¸ alignedë¼ì„œ binary()ë¡œ ì¶©ë¶„í•˜ë‹¤.
ê·¸ëŸ¬ë‚˜ ì¼ë¶€ **ì••ì¶• í¬ë§·, ì˜ìƒ/ì˜¤ë””ì˜¤ ì½”ë±, RF/í†µì‹  í—¤ë”**ëŠ” **ë¹„íŠ¸ ë‹¨ìœ„ í•„ë“œ**ë¥¼ ì‚¬ìš©í•œë‹¤.

ì˜ˆ:

- `flags: 3bit`, `version: 5bit` ë¥¼ 1ë°”ì´íŠ¸ ì•ˆì— ë„£ëŠ” ê²½ìš°
- ì••ì¶• ë¹„íŠ¸ìŠ¤íŠ¸ë¦¼(Huffman ì½”ë“œ ë“±)ì—ì„œ **ì½”ë“œì›Œë“œ ê¸¸ì´**ê°€ 3, 5, 7ë¹„íŠ¸ì²˜ëŸ¼ ì œê°ê°ì¸ ê²½ìš°

ì´ëŸ° ê²½ìš°ì—ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ **bitstring()** ì„ ë‹¤ë£¨ê²Œ ë˜ì§€ë§Œ,
ë§ì€ APIëŠ” ì—¬ì „íˆ â€œì™„ì„±ëœ í”„ë ˆì„â€ ìˆ˜ì¤€ì—ì„œëŠ” **binary()** ë¥¼ ê¸°ëŒ€í•œë‹¤.

ì‘ì€ ì˜ˆ:

```elixir
# ìƒìœ„ 3ë¹„íŠ¸: version, í•˜ìœ„ 5ë¹„íŠ¸: type

defmodule Header8 do
  def pack(ver, type) when ver in 0..7 and type in 0..31 do
    <<ver::3, type::5>>
  end

  def unpack(<<ver::3, type::5>>) do
    {ver, type}
  end
end

bin = Header8.pack(5, 17)
Header8.unpack(bin)
# {5, 17}

is_binary(bin)      # true (8ë¹„íŠ¸ì´ë¯€ë¡œ)
is_bitstring(bin)   # true
```

ì´ ì˜ˆëŠ” ìµœì¢…ì ìœ¼ë¡œ 8ë¹„íŠ¸ì— ë§ì¶° ë–¨ì–´ì ¸ binary() ì´ì§€ë§Œ,
ì½”ë±ë“¤ì—ì„œëŠ” **ì´ ê²½ê³„ë¥¼ ë²—ì–´ë‚˜ëŠ” ì¤‘ê°„ bitstringë“¤**ì„ ë‹¤ë£¨ëŠ” ì¼ì´ í”í•˜ë‹¤.

---

### ë°”ì´ë„ˆë¦¬ êµ¬ì„±(emit)ê³¼ ë¶„í•´(decompose)

ì—˜ë¦­ì„œ/Erlangì˜ í•µì‹¬ ë¬´ê¸°ëŠ” `<< >>` ë¬¸ë²•ì´ë‹¤.
ì´ê²ƒì„ ë‘ ë°©í–¥ìœ¼ë¡œ ìƒê°í•  ìˆ˜ ìˆë‹¤.

- **êµ¬ì„±(emit)**: ê°’ë“¤ì„ ë¹„íŠ¸/ë°”ì´íŠ¸ë¡œ ëª¨ì•„ í•˜ë‚˜ì˜ binary/bitstringì„ ë§Œë“ ë‹¤.
- **ë¶„í•´(decompose)**: binary/bitstringì„ íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ë‚˜ëˆˆë‹¤.

#### êµ¬ì„±: `<< â€¦ >>` ì™€ í•œì •ì(modifier)

ê¸°ë³¸ í˜•íƒœ:

```elixir
<<a, b, c>>                      # 1ë°”ì´íŠ¸ì”© 3ê°œ
<<x::16>>                        # 16ë¹„íŠ¸ ë¶€í˜¸ ì—†ëŠ” ì •ìˆ˜ (big endian ê¸°ë³¸)
<<x::little-16, y::32, f::float-32>>
<<cp::utf8, rest::binary>>       # UTF-8 ì½”ë“œí¬ì¸íŠ¸ 1ê°œ + ë‚˜ë¨¸ì§€
<<bits::size(3), more::bitstring>>
```

ì£¼ìš” í•œì •ì ì •ë¦¬:

| í•œì •ì              | ì˜ë¯¸                                          | ì˜ˆì‹œ                               |
|---------------------|-----------------------------------------------|------------------------------------|
| `size(n)`           | í•„ë“œ í¬ê¸°(ë¹„íŠ¸ ìˆ˜)                            | `<<x::size(3)>>`                  |
| `unit(n)`           | ì›ì†Œ ë‹¨ìœ„ í¬ê¸°(ë¹„íŠ¸)                          | `<<x::size(4)-unit(2)>>` = 8ë¹„íŠ¸  |
| `signed` / `unsigned` | ë¶€í˜¸ ìˆëŠ”/ì—†ëŠ” ì •ìˆ˜                          | `<<x::signed-16>>`                |
| `little` / `big` / `native` | ì—”ë””ì•ˆ ì§€ì •                             | `<<x::little-32>>`                |
| `float`             | IEEE754 ë¶€ë™ì†Œìˆ˜ì                             | `<<x::float-32>>`                 |
| `utf8` / `utf16` / `utf32` | ìœ ë‹ˆì½”ë“œ ì½”ë“œí¬ì¸íŠ¸ ì¸ì½”ë”©             | `<<cp::utf8>>`                    |
| `binary` / `bitstring` | ë‚˜ë¨¸ì§€ë¥¼ ë°”ì´ë„ˆë¦¬/ë¹„íŠ¸ìŠ¤íŠ¸ë§ìœ¼ë¡œ í•´ì„     | `<<rest::binary>>`                |

ì˜ˆì‹œ 1: ê°„ë‹¨í•œ í—¤ë” + í˜ì´ë¡œë“œ

```elixir
defmodule Msg do
  # [ver:1][type:1][len:2][payload:len]
  def build(ver, type, payload) when ver in 0..255 and type in 0..255 do
    len = byte_size(payload)
    <<ver, type, len::16, payload::binary>>
  end
end

bin = Msg.build(1, 2, "hello")
bin
# <<1, 2, 0, 5, 104, 101, 108, 108, 111>>

```

#### ë¶„í•´: íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ íŒŒì‹±

ìœ„ì—ì„œ ë§Œë“  ë©”ì‹œì§€ë¥¼ íŒŒì‹±í•œë‹¤.

{% raw %}
```elixir
defmodule Msg do
  def parse(<<ver, type, len::16, payload::binary-size(len), rest::binary>>) do
    {%{ver: ver, type: type, payload: payload}, rest}
  end
end

{%{ver: v, type: t, payload: p}, r} = Msg.parse(bin)
{v, t, p, r}
# {1, 2, "hello", ""}

```
{% endraw %}

íŠ¹ì§•:

- `payload::binary-size(len)` ì´ **ê¸¸ì´ ê²€ì¦**ì„ ìë™ìœ¼ë¡œ ìˆ˜í–‰í•œë‹¤.
- ì˜ëª»ëœ binaryê°€ ë“¤ì–´ì˜¤ë©´ **íŒ¨í„´ ë§¤ì¹­ ì‹¤íŒ¨**ë¡œ ë°”ë¡œ ì¡ì„ ìˆ˜ ìˆë‹¤.

íŒ¨í„´ ë§¤ì¹­ì„ ì´ìš©í•˜ë©´, ì•„ë˜ì™€ ê°™ì´ â€œëª…ì„¸ë¥¼ ê·¸ëŒ€ë¡œ ì½”ë“œë¡œ ë²ˆì—­â€í•  ìˆ˜ ìˆë‹¤.

{% raw %}
```elixir
# [magic:2][flags:1(bit)][ver:3(bit)][reserved:4(bit)][len:16][payload:len]

def parse_packet(
      <<0xCA, 0xFE, flags::1, ver::3, _rsv::4, len::16, payload::binary-size(len), rest::binary>>
    ) do
  {%{flags: flags, ver: ver, payload: payload}, rest}
end
```
{% endraw %}

---

### iodata / iolist â€” íš¨ìœ¨ì  ê²°í•©

- **`iodata()`**: binary() ë˜ëŠ” (binary(), byte(), iodata())ì˜ ë¦¬ìŠ¤íŠ¸
- **`iolist()`**: ì‹¤ì œë¡œëŠ” ê°™ì€ ê°œë…(Erlangì—ì„œ ë¶€ë¥´ëŠ” ì´ë¦„)

ì¬ê·€ ì •ì˜:

- $$iodata ::= binary \mid [iodata\_1, iodata\_2, \dots, byte]$$

ì¤‘ìš”í•œ ì :

- VMì€ iodataë¥¼ **ì‹¤ì œ ë³µì‚¬ ì—†ì´** ë°”ë¡œ ì†Œì¼“/íŒŒì¼ë¡œ ì“°ê±°ë‚˜,
  `:erlang.iolist_to_binary/1` ë¡œ **í•œ ë²ˆì— binaryë¡œ í•©ì¹œë‹¤**.

```elixir
rows =
  for i <- 1..3 do
    ["row:", Integer.to_string(i), "\n"]
  end

rows
# [
#   ["row:", "1", "\n"],
#   ["row:", "2", "\n"],
#   ["row:", "3", "\n"]
# ]

bin = :erlang.iolist_to_binary(rows)
bin
# "row:1\nrow:2\nrow:3\n"

```

#### `<>` ë£¨í”„ vs iodata â€” ë³µì¡ë„ ë¹„êµ

- ë‚˜ìœ íŒ¨í„´:

```elixir
def build_bad(n) do
  Enum.reduce(1..n, "", fn i, acc ->
    acc <> Integer.to_string(i) <> "\n"
  end)
end
```

ì´ ê²½ìš° ê° ë‹¨ê³„ë§ˆë‹¤ `acc`ë¥¼ ë³µì‚¬í•´ì•¼ í•˜ë¯€ë¡œ(ë°”ì´ë„ˆë¦¬ ë¶ˆë³€):

- ì²« ë‹¨ê³„: ê¸¸ì´ ~1
- ë‘ ë²ˆì§¸: ~1+2
- ì„¸ ë²ˆì§¸: ~1+2+3
- â€¦

ì´ ë³µì‚¬ëŸ‰ì€ ëŒ€ëµ:

$$
1 + 2 + \cdots + n = \frac{n(n+1)}{2} \approx O(n^2)
$$

- ì¢‹ì€ íŒ¨í„´:

```elixir
def build_good(n) do
  n
  |> Enum.map(fn i -> [Integer.to_string(i), "\n"] end)
  |> :erlang.iolist_to_binary()
end
```

ì—¬ê¸°ì„œëŠ” **ì¤‘ê°„ì— ë³µì‚¬ ì—†ì´** ë¦¬ìŠ¤íŠ¸ë¡œ ìŒ“ê¸°ë§Œ í•˜ê³ ,
ë§ˆì§€ë§‰ì— í•œ ë²ˆë§Œ ì´ ê¸¸ì´ $$N$$ ë§Œí¼ ë³µì‚¬:

$$
T_{\text{good}} \approx c \cdot N \sim O(N)
$$

ëŒ€ê·œëª¨ í…ìŠ¤íŠ¸/í”„ë ˆì„ ìƒì„±ì—ì„œ ì´ ì°¨ì´ëŠ” ë§¤ìš° í¬ê²Œ ë‚˜íƒ€ë‚œë‹¤.

---

### ë°”ì´ë„ˆë¦¬ ê¸¸ì´/ë‹¨ìœ„ ìˆ˜ì‹ ì§ê´€

`<< >>`ì˜ ê° í•„ë“œëŠ” ì•„ë˜ì™€ ê°™ì€ ê·œì¹™ìœ¼ë¡œ ë¹„íŠ¸ ìˆ˜ê°€ ê²°ì •ëœë‹¤.

- ì–´ë–¤ í•„ë“œê°€ `size_i`, `unit_i` ë¥¼ ê°€ì§ˆ ë•Œ, ê·¸ í•„ë“œì˜ ë¹„íŠ¸ìˆ˜ $$L_i$$ ëŠ”

$$
L_i = \text{size}_i \times \text{unit}_i
$$

- ì „ì²´ ë°”ì´ë„ˆë¦¬ì˜ ë¹„íŠ¸ ê¸¸ì´ $$L$$ ì€

$$
L = \sum_i L_i = \sum_i (\text{size}_i \times \text{unit}_i)
$$

- ë°”ì´íŠ¸ ê²½ê³„(8ë¹„íŠ¸)ë¡œ ë§ì¶° ë–¨ì–´ì§€ë©´ binary(), ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ bitstring():

$$
L \bmod 8 = 0 \Rightarrow \text{binary()}, \quad
L \bmod 8 \neq 0 \Rightarrow \text{bitstring()ë§Œ}.
$$

ê°„ë‹¨í•œ ì˜ˆ:

```elixir
# 3ë¹„íŠ¸ + 5ë¹„íŠ¸ = 8ë¹„íŠ¸ -> binary()

<<_::3, _::5>> = <<0b101_00101>>

# 3ë¹„íŠ¸ + 4ë¹„íŠ¸ = 7ë¹„íŠ¸ -> bitstring()ë§Œ

bs = <<0b101::3, 0b1111::4>>
is_bitstring(bs)   # true
is_binary(bs)      # false
```

ëŒ€ë¶€ë¶„ì˜ ì™¸ë¶€ API/ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” **binary()** ë¥¼ ê¸°ëŒ€í•˜ë©°,
bitstring()ì€ ë‚´ë¶€ ì—°ì‚° ë‹¨ê³„ì—ì„œ ì ê¹ ë“±ì¥í•˜ëŠ” ê²½ìš°ê°€ ë§ë‹¤.

---

### ìœ í‹¸ë¦¬í‹°: :binary, String, Base

ë°”ì´ë„ˆë¦¬ ê´€ë ¨ ì„œí¬íŠ¸ ëª¨ë“ˆë“¤:

- `:binary` : ë°”ì´íŠ¸ ë‹¨ìœ„ ì¡°ì‘(ìŠ¬ë¼ì´ìŠ¤, ë³µì‚¬, ê²€ìƒ‰ ë“±)
- `Base`    : Base16/32/64 ì¸ì½”ë”©/ë””ì½”ë”©
- `String`  : UTF-8 ë¬¸ìì—´ ê´€ì  ì¡°ì‘(11.5ì—ì„œ ìƒì„¸)

```elixir
# :binary

:binary.copy(<<1, 2, 3>>)         # ë¬¼ë¦¬ ë³µì œ(ì„œë¸Œë°”ì´ë„ˆë¦¬ ì°¸ì¡° ë¶„ë¦¬)
:binary.part("abcdef", 2, 3)      # "cde" (ë°”ì´íŠ¸ ìŠ¬ë¼ì´ìŠ¤)
:binary.match("abcdef", "cd")     # {2, 2}
:binary.matches("abcabc", "a")    # [{0,1}, {3,1}]

# Base

Base.encode16(<<0xDE, 0xAD>>)     # "DEAD"
Base.encode16(<<0xDE, 0xAD>>, case: :lower) # "dead"
Base.decode64!("YWJj")            # "abc"
```

#### ì„œë¸Œë°”ì´ë„ˆë¦¬ì™€ :binary.copy/1

í° ë°”ì´ë„ˆë¦¬ì—ì„œ ì‘ì€ ì¡°ê°ì„ ì˜ë¼ ì˜¤ë˜ ë“¤ê³  ìˆìœ¼ë©´,
ì‘ì€ ì¡°ê°ì´ **í° ë°”ì´ë„ˆë¦¬ë¥¼ ì°¸ì¡°**í•˜ëŠ” ì„œë¸Œë°”ì´ë„ˆë¦¬ê°€ ëœë‹¤.

```elixir
big   = File.read!("huge.log")
small = :binary.part(big, 0, 8)
# smallì´ bigì˜ ì• 8ë°”ì´íŠ¸ë¥¼ ê°€ë¦¬í‚¤ëŠ” ì„œë¸Œë°”ì´ë„ˆë¦¬

# í° big ë°”ì´ë„ˆë¦¬ëŠ” smallì´ ì‚´ì•„ìˆëŠ” í•œ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œë˜ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤.

```

ì´ëŸ° ê²½ìš°:

```elixir
small = :binary.copy(:binary.part(big, 0, 8))
```

ì²˜ëŸ¼ **ë³µì‚¬ë³¸ì„ ê°•ì œ**í•´ì„œ í° ë°”ì´ë„ˆë¦¬ë¥¼ í•´ì œ ê°€ëŠ¥í•˜ê²Œ ë§Œë“œëŠ” ê²ƒì´ ì¢‹ë‹¤.

---

### ì‹¤ì „ ì˜ˆì œ: ê°„ë‹¨í•œ HEX dump êµ¬í˜„

ë°”ì´ë„ˆë¦¬ë¥¼ 16ì§„ìˆ˜/ASCII í™”ë©´ìœ¼ë¡œ ë³´ì—¬ì£¼ëŠ” ë„êµ¬ë¥¼ ë§Œë“¤ì–´ ë³´ì.

```elixir
defmodule HexDump do
  def dump(bin), do: dump(bin, 0)

  defp dump(<<>>, _offset), do: :ok

  defp dump(bin, offset) do
    {line, rest} =
      if byte_size(bin) >= 16 do
        :erlang.split_binary(bin, 16)
      else
        {bin, <<>>}
      end

    hex =
      line
      |> :erlang.binary_to_list()
      |> Enum.map(&Integer.to_string(&1, 16) |> String.pad_leading(2, "0"))
      |> Enum.join(" ")

    ascii =
      line
      |> :erlang.binary_to_list()
      |> Enum.map(fn b ->
        if b in 32..126, do: <<b>>, else: "."
      end)
      |> Enum.join()

    IO.puts(
      [
        Integer.to_string(offset, 16) |> String.pad_leading(8, "0"),
        "  ",
        String.pad_trailing(hex, 16 * 3),
        "  ",
        ascii
      ]
    )

    dump(rest, offset + byte_size(line))
  end
end

HexDump.dump("Hello, world!\n")
```

ì´ ì˜ˆì œëŠ”:

- binaryë¥¼ **ë°”ì´íŠ¸ ë¦¬ìŠ¤íŠ¸**ë¡œ ë°”ê¾¸ê³ ,
- hex/ASCII í‘œí˜„ì„ ë§Œë“¤ì–´ ì¶œë ¥í•œë‹¤.
- `:erlang.split_binary/2` ë¥¼ ì´ìš©í•´ ì¼ì • ê¸¸ì´ì”© ë‚˜ëˆ„ëŠ” íŒ¨í„´ë„ ë³´ì—¬ì¤€ë‹¤.

---

## _11.5 í°ë”°ì˜´í‘œ ë¬¸ìì—´ì€ ë°”ì´ë„ˆë¦¬ë‹¤_

ì• ì ˆ(11.1~11.3)ì—ì„œ ì´ë¯¸ ë‹¤ë£¬ ê²ƒì²˜ëŸ¼, ì—˜ë¦­ì„œì—ì„œ `"ë¬¸ìì—´"`ì€ **UTF-8 binary()** ì´ë‹¤.
ì´ ì ˆì—ì„œëŠ” **binary() ê´€ì ì—ì„œ ë¬¸ìì—´ì„ ë‹¤ì‹œ ë°”ë¼ë³´ê³ **,
`String` vs `:binary` ê²½ê³„ë¥¼ ëª…í™•íˆ í•˜ëŠ” ë° ì§‘ì¤‘í•œë‹¤.

---

### String vs :binary â€” ì–¸ì œ ë¬´ì—‡ì„ ì“¸ê¹Œ?

ìš”ì•½:

- **`String.*`**
  - **Unicode ì¸ì§€**
  - ê·¸ë˜í˜ì„, ì½”ë“œí¬ì¸íŠ¸, ì¼€ì´ìŠ¤ ë§¤í•‘, ì •ê·œí™”, íŠ¸ë¦¬ë°, ë¶„í•  ë“±
  - â€œì‚¬ìš©ìê°€ ì½ëŠ” í…ìŠ¤íŠ¸â€ë¥¼ ë‹¤ë£° ë•Œ ì‚¬ìš©

- **`:binary.*`**
  - **ë°”ì´íŠ¸ ë ˆë²¨**
  - ìŠ¬ë¼ì´ìŠ¤, ë§¤ì¹˜, ë³µì‚¬, íŒ¨ë”©, ê²€ìƒ‰ ë“±
  - â€œí”„ë¡œí† ì½œ, íŒŒì¼ í¬ë§·, ì¸ì½”ë”©, raw ë°ì´í„°â€ë¥¼ ë‹¤ë£° ë•Œ ì‚¬ìš©

ì˜ˆ:

```elixir
# â€œë¬¸ì 3ê°œâ€ë¥¼ ìë¥´ê³  ì‹¶ë‹¤ë©´ String (ì½”ë“œí¬ì¸íŠ¸ ê¸°ë°˜)

String.slice("ì•ˆë…•ğŸ™‚ì„¸ê³„", 0, 3)
# "ì•ˆë…•ğŸ™‚"

# íŠ¹ì • ë°”ì´íŠ¸ ì˜¤í”„ì…‹ì—ì„œ 3ë°”ì´íŠ¸ê°€ í•„ìš”í•˜ë‹¤ë©´ :binary

:binary.part("abcdef", 2, 3)
# "cde"

```

ê·œì¹™ì„ ë‹¤ì‹œ ì“°ë©´:

> - ì‚¬ëŒì´ ì½ëŠ” í…ìŠ¤íŠ¸: **String**
> - ë°”ì´íŠ¸ ë‹¨ìœ„ í”„ë¡œí† ì½œ/íŒŒì¼ í¬ë§·: **:binary + íŒ¨í„´ ë§¤ì¹­**

---

### ì•ˆì „í•œ ì˜ë¼ë‚´ê¸°(ê·¸ë˜í˜ì„ ê²½ê³„)

UTF-8 ë¬¸ìì—´ì„ â€œnê¸€ìâ€ë§Œ ë³´ì—¬ì£¼ê³  ì‹¶ì„ ë•Œ,
**ë°”ì´íŠ¸ ë‹¨ìœ„** í˜¹ì€ **ì½”ë“œí¬ì¸íŠ¸ ë‹¨ìœ„**ë§Œ ì‹ ê²½ ì“°ë©´ ë¬¸ì œê°€ ìƒê¸¸ ìˆ˜ ìˆë‹¤.

ì˜ˆ:

```elixir
s = "ì•ˆë…•ğŸ™‚ì„¸ê³„"
byte_size(s)         #  ? (ë©€í‹°ë°”ì´íŠ¸)
String.length(s)     # ì½”ë“œí¬ì¸íŠ¸ ìˆ˜
length(String.graphemes(s))  # ì‚¬ìš©ìê°€ ë³´ëŠ” ê¸€ì ìˆ˜
```

ì´ëª¨ì§€, ì¡°í•©í˜• ë¬¸ì ë•Œë¬¸ì—:

- ì½”ë“œí¬ì¸íŠ¸ ìˆ˜ì™€ ê·¸ë˜í˜ì„ ìˆ˜ê°€ ë‹¤ë¥¼ ìˆ˜ ìˆë‹¤.

ê·¸ë˜í˜ì„ ê¸°ì¤€ìœ¼ë¡œ ìŠ¬ë¼ì´ìŠ¤:

```elixir
def safe_take_graphemes(s, n) do
  s
  |> String.graphemes()
  |> Enum.take(n)
  |> Enum.join()
end

safe_take_graphemes("ì•ˆë…•ğŸ™‚ì„¸ê³„", 3)
# "ì•ˆë…•ğŸ™‚"

```

ì¡°ê¸ˆ ë” ì¼ë°˜í™”í•œ `truncate/3`:

```elixir
def truncate(s, n, suffix \\ "â€¦") do
  gs = String.graphemes(s)

  if length(gs) > n do
    gs
    |> Enum.take(n)
    |> Enum.join()
    |> Kernel.<>(suffix)
  else
    s
  end
end
```

- UIì—ì„œ â€œìµœëŒ€ nê¸€ì + â€¦â€ ê°™ì€ ê¸°ëŠ¥ì„ êµ¬í˜„í•  ë•Œ ìœ ìš©í•˜ë‹¤.

---

### ë¬¸ìì—´ ë¹Œë“œ â€” iodata + Stream.intoë¡œ íŒŒì¼ ì§ê²°

ëŒ€ê·œëª¨ í…ìŠ¤íŠ¸(ë¡œê·¸, CSV, HTML ë“±)ë¥¼ ìƒì„±í•  ë•Œ:

- **ì¤‘ê°„ ë¬¸ìì—´**ì„ ì „ë¶€ ë©”ëª¨ë¦¬ì— ìŒ“ì§€ ë§ê³ ,
- iodata + `Stream.into(File.stream!/3)`ë¡œ **ì§ì ‘ íŒŒì¼/ì†Œì¼“ìœ¼ë¡œ í˜ë ¤ë³´ë‚´ëŠ” íŒ¨í„´**ì´ ì¢‹ë‹¤.

```elixir
"big.txt"
|> File.stream!()
|> Stream.map(&["[", &1, "]"])
|> Stream.into(File.stream!("out.txt"))
|> Stream.run()
```

ì´ íŒŒì´í”„ë¼ì¸ì€:

- ì…ë ¥ íŒŒì¼ì„ í•œ ì¤„ì”© ì½ê³ ,
- ê° ì¤„ì„ iodata `["[", line, "]"]` ë¡œ ê°ì‹¼ ë’¤,
- ì¶œë ¥ íŒŒì¼ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë°”ë¡œ ë³´ë‚¸ë‹¤.

ì¤‘ê°„ì— â€œëª¨ë“  ì¤„ì„ ë¦¬ìŠ¤íŠ¸ì— ëª¨ì•˜ë‹¤ê°€ ë‚˜ì¤‘ì— ì“°ëŠ”â€ ê³¼ì •ì´ ì—†ìœ¼ë¯€ë¡œ,
ì…ë ¥ í¬ê¸°ì— ë¹„í•´ ë©”ëª¨ë¦¬ ì‚¬ìš©ì´ ë§¤ìš° ì‘ê²Œ ìœ ì§€ëœë‹¤.

HTML ìƒì„± ì˜ˆ:

```elixir
defmodule Html do
  def page(title, items) do
    [
      "<!doctype html>\n<html><head><title>",
      title,
      "</title></head><body><ul>\n",
      for item <- items do
        ["<li>", item, "</li>\n"]
      end,
      "</ul></body></html>\n"
    ]
  end
end

html_iodata = Html.page("Title", ~w(a b c))
File.write!("page.html", :erlang.iolist_to_binary(html_iodata))
```

---

### ì •ê·œí™” ë¹„êµ

ì¡°í•©í˜•/ë¶„í•´í˜• ë•Œë¬¸ì—,
ê°™ì´ ë³´ì—¬ë„ ë°”ì´ë„ˆë¦¬ ìˆ˜ì¤€ì—ì„œëŠ” ë‹¤ë¥¸ ë¬¸ìì—´ì´ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.

```elixir
a = "e\u0301"  # e + combining acute
b = "Ã©"

a == b
# false

String.normalize(a, :nfc) == String.normalize(b, :nfc)
# true

```

- â€œì‚¬ìš©ìê°€ ì…ë ¥í•œ í…ìŠ¤íŠ¸â€ë¥¼ **í‚¤**(ì˜ˆ: DBì˜ ìœ ë‹ˆí¬ í‚¤, ìºì‹œ í‚¤)ë¡œ ì“¸ ë•ŒëŠ”
  ì •ê·œí™” ì „ëµì„ ë°˜ë“œì‹œ ì •í•´ì•¼ í•œë‹¤.

ì „í˜•ì ì¸ ì „ëµ:

- ì €ì¥/ë¹„êµ ëª¨ë‘ `String.normalize(str, :nfc)` ì ìš© í›„ ì§„í–‰

ìˆ˜ì‹ìœ¼ë¡œ ì“°ë©´, í•œ ì •ê·œí™” ëª¨ë“œ $$N$$ì— ëŒ€í•´:

$$
\text{equal\_N?}(a, b) \iff \text{normalize}(a, N) = \text{normalize}(b, N)
$$

---

## _11.6 ë°”ì´ë„ˆë¦¬ì™€ íŒ¨í„´ ë§¤ì¹­_

ì´ ì ˆì—ì„œëŠ” **íŒ¨í„´ ë§¤ì¹­**ì„ ì´ìš©í•œ ë°”ì´ë„ˆë¦¬ íŒŒì‹±/ì¡°í•© íŒ¨í„´ì„ ì§‘ì¤‘ì ìœ¼ë¡œ ë‹¤ë£¬ë‹¤.
ê¸¸ì´ ì ‘ë‘ í”„ë ˆì„, ë¹„íŠ¸í•„ë“œ, ë¬¸ìì—´ í† í¬ë‚˜ì´ì €, UTF-8 ìˆœíšŒ, ì„œë¸Œë°”ì´ë„ˆë¦¬ ë©”ëª¨ë¦¬, ì—”ë””ì•ˆ ë“±.

---

### ê¸¸ì´ ì ‘ë‘(length-prefixed) í”„ë ˆì„

ê°€ì¥ í”í•œ íŒ¨í„´:

- `[len:1][type:1][payload:len]` ê°€ ë°˜ë³µë˜ëŠ” ìŠ¤íŠ¸ë¦¼

```elixir
defmodule Wire.LenPref do
  def parse_all(bin), do: do_parse(bin, [])

  defp do_parse(<<>>, acc), do: Enum.reverse(acc)

  defp do_parse(<<len, type, payload::binary-size(len), rest::binary>>, acc) do
    do_parse(rest, [%{type: type, payload: payload} | acc])
  end
end
```

ì¥ì :

- `payload::binary-size(len)` ì´
  `byte_size(payload) == len` ì„ **íŒ¨í„´ ë ˆë²¨ì—ì„œ ë³´ì¥**í•œë‹¤.
- ê¸¸ì´ê°€ ë§ì§€ ì•Šìœ¼ë©´ íŒ¨í„´ ë§¤ì¹­ì´ ì‹¤íŒ¨í•˜ë¯€ë¡œ,
  `case` ë‚˜ `with` ë¡œ ê°ì‹¸ë©´ ì‰½ê²Œ ì—ëŸ¬ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤.

---

### ê³ ì •/ê°€ë³€ í•„ë“œ í˜¼í•©

ë¹„íŠ¸ë‹¨ìœ„ í•„ë“œ + ë°”ì´íŠ¸ë‹¨ìœ„ í•„ë“œë¥¼ í•¨ê»˜ ì“°ëŠ” ì˜ˆ:

- `[magic:2][flags:1(bit)][ver:3(bit)][rsv:4(bit)][len:16][payload:len]`

{% raw %}
```elixir
defmodule Wire.Mixed do
  @magic <<0xCA, 0xFE>>

  def parse(<<@magic, flags::1, ver::3, _rsv::4, len::16, payload::binary-size(len), rest::binary>>) do
    {%{flags: flags, ver: ver, payload: payload}, rest}
  end
end
```
{% endraw %}

ëª…ì„¸ë¥¼ ì½”ë“œë¡œ ì˜®ê²¼ì„ ë¿ì¸ë°:

- **ì—”ë””ì•ˆ, ë¹„íŠ¸ ìˆ˜, ê¸¸ì´ ê²€ì¦**ê¹Œì§€ ìë™ìœ¼ë¡œ ì²˜ë¦¬ëœë‹¤.
- â€œí”„ë¡œí† ì½œ ë¬¸ì„œë¥¼ ë³´ë©´ì„œ ì½”ë“œ ì§œê¸°â€ì— ìµœì í™”ëœ ìŠ¤íƒ€ì¼ì´ë‹¤.

---

### ë¬¸ìì—´ í† í¬ë‚˜ì´ì €(ê°„ë‹¨ ì²´ì¸)

binary íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ê°„ë‹¨í•œ í† í¬ë‚˜ì´ì €ë¥¼ ì‘ì„±í•´ ë³´ì.

ëª©í‘œ:
ì…ë ¥ì´ `"123,45,678"` ë¼ë©´, í† í° ì‹œí€€ìŠ¤:

- `{:int, 123}`, `:comma`, `{:int, 45}`, `:comma`, `{:int, 678}`

```elixir
defmodule Tokenizer do
  def tokenize(bin), do: do_tokenize(bin, [])

  defp do_tokenize(<<>>, acc), do: Enum.reverse(acc)

  defp do_tokenize(<< ?,, rest::binary >>, acc),
    do: do_tokenize(rest, [:comma | acc])

  defp do_tokenize(<< c, rest::binary >>, acc) when c in ?0..?9 do
    {int, rest2} = scan_int(rest, [c])
    do_tokenize(rest2, [{:int, int} | acc])
  end

  defp do_tokenize(<< _other, rest::binary >>, acc),
    do: do_tokenize(rest, acc)

  defp scan_int(<<c, rest::binary>>, acc) when c in ?0..?9,
    do: scan_int(rest, [c | acc])

  defp scan_int(rest, acc),
    do: {:erlang.list_to_integer(Enum.reverse(acc)), rest}
end

Tokenizer.tokenize("123,45,678")
# [{:int, 123}, :comma, {:int, 45}, :comma, {:int, 678}]

```

- ìƒíƒœ ê¸°ê³„ë¥¼ **í•¨ìˆ˜ ì ˆ**ë“¤ì˜ ì¡°í•©ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ì „í˜•ì ì¸ ìŠ¤íƒ€ì¼ì´ë‹¤.

---

### UTF-8 ì½”ë“œí¬ì¸íŠ¸ ìˆœíšŒ(ë°”ì´íŠ¸ ê²½ê³„ ê¸ˆì§€)

UTF-8 ë¬¸ìì—´ì„ ì½”ë“œí¬ì¸íŠ¸ ë‹¨ìœ„ë¡œ ìˆœíšŒí•˜ë ¤ë©´:

```elixir
def codepoints(bin) when is_binary(bin) do
  for <<cp::utf8 <- bin>>, do: cp
end

codepoints("ê°€ë‚˜")
# [44032, 45208]

```

- `<<cp::utf8 <- bin>>` ì»´í”„ë¦¬í—¨ì…˜ì€
  ì½”ë“œí¬ì¸íŠ¸ ê²½ê³„ë¥¼ ì˜ëª» ëŠì„ ê°€ëŠ¥ì„±ì„ ì œê±°í•œë‹¤.
- ë¹„ì •ìƒ UTF-8 ì‹œí€€ìŠ¤ê°€ ë“¤ì–´ì˜¤ë©´ íŒ¨í„´ ë§¤ì¹­ ì‹¤íŒ¨ë¡œ ì²˜ë¦¬ëœë‹¤.

---

### ë°”ì´ë„ˆë¦¬ ì¡°ê° ë³´ê´€ê³¼ ë©”ëª¨ë¦¬ ì••ë ¥

ì„œë¸Œë°”ì´ë„ˆë¦¬ ë¬¸ì œë¥¼ ì¡°ê¸ˆ ë” ìì„¸íˆ ë³´ì.

```elixir
big   = File.read!("huge.log")
head  = :binary.part(big, 0, 16)
keys  = for <<k::binary-16 <- head>>, do: k

# keys ë¦¬ìŠ¤íŠ¸ ì•ˆì˜ ê° këŠ” bigì˜ ì¼ë¶€ë¥¼ ê°€ë¦¬í‚¤ëŠ” ì„œë¸Œë°”ì´ë„ˆë¦¬ì¼ ìˆ˜ ìˆë‹¤.

```

ì´ ìƒíƒœì—ì„œ:

- bigì€ **GCê°€ í•´ì œí•  ìˆ˜ ì—†ëŠ” í° refc binary**ë¡œ ë‚¨ì„ ìˆ˜ ìˆë‹¤.
- ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§ì„ í•´ ë³´ë©´,
  â€œì™œ ì´ë¯¸ ì²˜ë¦¬ê°€ ëë‚œ íŒŒì¼ì´ ì•„ì§ë„ ë©”ëª¨ë¦¬ë¥¼ ì´ë ‡ê²Œ ë§ì´ ì¡ê³  ìˆì§€?â€ë¼ëŠ” ì§ˆë¬¸ì´ ìƒê¸´ë‹¤.

í•´ê²°:

```elixir
keys =
  for <<k::binary-16 <- head>> do
    :binary.copy(k)
  end
```

- `:binary.copy/1` ë¡œ ê° ì¡°ê°ì„ **ë…ë¦½ëœ ì‘ì€ binary**ë¡œ ë§Œë“¤ì–´ ì£¼ë©´,
  bigì€ ë” ì´ìƒ ì°¸ì¡°ë˜ì§€ ì•Šê³  GC ëŒ€ìƒì´ ëœë‹¤.

---

### ì—”ë””ì•ˆ/ë¶€í˜¸/ë¶€ë™ì†Œìˆ˜ì 

ìˆ˜ì¹˜í˜• í•„ë“œë¥¼ íŒŒì‹±í•  ë•ŒëŠ” í•­ìƒ **ì—”ë””ì•ˆ + ë¶€í˜¸ + ì •ë°€ë„**ë¥¼ ëª…ì‹œí•˜ì.

```elixir
# little endian 16ë¹„íŠ¸, signed 32ë¹„íŠ¸, IEEE754 float32

<<x::little-16, y::signed-32, z::float-32>> = bin
```

- ë„¤íŠ¸ì›Œí¬ ë°”ì´íŠ¸ ìˆœì„œëŠ” ì „í†µì ìœ¼ë¡œ **ë¹…ì—”ë””ì•ˆ**ì´ë‹¤.
- x86 CPU ë©”ëª¨ë¦¬ëŠ” ë³´í†µ **ë¦¬í‹€ì—”ë””ì•ˆ**ì´ë‹¤.
- í”„ë¡œí† ì½œ ëª…ì„¸ì— ì íŒ ì—”ë””ì•ˆì„ ê·¸ëŒ€ë¡œ ì½”ë“œì— ë°˜ì˜í•´ì•¼ í•œë‹¤.

í…ŒìŠ¤íŠ¸ íŒ:

- 0, ìµœëŒ€ê°’, ìµœì†Œê°’, ìŒìˆ˜ ë“± **ê²½ê³„ ê°’**ì— ëŒ€í•´
  encode â†’ decode ì™•ë³µ í…ŒìŠ¤íŠ¸ë¥¼ ê¼­ ìˆ˜í–‰í•˜ì.

---

### PNG ì²­í¬(êµ¬ì¡° íŒŒì‹± ì˜ˆì‹œ)

PNG íŒŒì¼ êµ¬ì¡°(ê°„ë‹¨ ë²„ì „):

- 8ë°”ì´íŠ¸ ì‹œê·¸ë‹ˆì²˜
- ë°˜ë³µ: `[len:4][type:4][data:len][crc:4]`

```elixir
defmodule PNG do
  @sig <<137, 80, 78, 71, 13, 10, 26, 10>>

  def parse(<<@sig, rest::binary>>), do: chunks(rest, [])
  def parse(_), do: {:error, :bad_signature}

  defp chunks(<<>>, acc), do: {:ok, Enum.reverse(acc)}

  defp chunks(<<len::32, type::binary-size(4), data::binary-size(len), crc::32, rest::binary>>, acc) do
    # ì‹¤ì „ì—ì„œëŠ” CRC ê²€ì¦ í•„ìš”(ì˜ˆ: :erlang.crc32ì™€ ê°™ì€ í•¨ìˆ˜)
    chunks(rest, [%{type: type, len: len, crc: crc, data: data} | acc])
  end
end
```

ì‚¬ìš©:

```elixir
{:ok, chunks} = PNG.parse(File.read!("image.png"))
Enum.map(chunks, & &1.type)
# ["IHDR", "IDAT", "IEND", ...]

```

- ëª…ì„¸ë¥¼ ë³´ê³  ê·¸ëŒ€ë¡œ í•„ë“œ ë‚˜ì—´ë§Œ í•´ë„ ê½¤ ê´œì°®ì€ íŒŒì„œê°€ ë‚˜ì˜¨ë‹¤.

---

### ìƒíƒœê¸°ê³„ ìŠ¤íŠ¸ë¦¬ë° íŒŒì„œ

ì†Œì¼“/íŒŒì¼ ìŠ¤íŠ¸ë¦¼ì—ì„œ **ì¡°ê° ë‹¨ìœ„ë¡œ ë“¤ì–´ì˜¤ëŠ” í”„ë ˆì„**ì„ íŒŒì‹±í•´ë³´ì.

í”„ë ˆì´ë° ê·œì¹™:

- `[len:1][payload:len]` ë°˜ë³µ
- chunkëŠ” ì„ì˜ ê¸¸ì´ë¡œ ìª¼ê°œì ¸ ë“¤ì–´ì˜¨ë‹¤ê³  ê°€ì •

```elixir
defmodule Framed do
  def parse_stream(enum) do
    enum
    |> Enum.reduce({:need_len, <<>>, []}, &step/2)
    |> then(fn {_, _buf, out} -> Enum.reverse(out) end)
  end

  # ìƒíƒœ: ê¸¸ì´ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘
  defp step(chunk, {:need_len, buf, out}) do
    buf2 = buf <> chunk

    case buf2 do
      <<len, rest::binary>> ->
        step(rest, {:need_payload, {len, <<>>}, out})

      _ ->
        {:need_len, buf2, out}
    end
  end

  # ìƒíƒœ: payloadë¥¼ len ë§Œí¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘
  defp step(chunk, {:need_payload, {len, accp}, out}) do
    accp2 = accp <> chunk

    if byte_size(accp2) < len do
      {:need_payload, {len, accp2}, out}
    else
      <<payload::binary-size(len), rest::binary>> = accp2
      step(rest, {:need_len, <<>>, [%{payload: payload} | out]})
    end
  end
end
```

ì‚¬ìš©:

```elixir
chunks = [<<3, "abc", 2, "xy">>, <<4, "test">>]
Framed.parse_stream(chunks)
# [%{payload: "abc"}, %{payload: "xy"}, %{payload: "test"}]

```

- ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œëŠ” ì—¬ê¸°ì— **ìµœëŒ€ ê¸¸ì´ ì œí•œ, CRC, ì‹œê·¸ë‹ˆì²˜ ê²€ì‚¬** ë“±ì„ ë”í•´ ë³´ì•ˆ/ì•ˆì •ì„±ì„ í™•ë³´í•œë‹¤.

---

### ë°”ì´ë„ˆë¦¬ ì¡°í•©ê¸°(ë¹Œë”)

íŒŒì‹±ì´ ìˆìœ¼ë©´, ë°˜ëŒ€ ë°©í–¥ **ë¹Œë”**ë„ ìˆì–´ì•¼ í•œë‹¤.

```elixir
defmodule Frame do
  def build(type, payload) when is_integer(type) and is_binary(payload) do
    len = byte_size(payload)
    <<type, len::16, payload::binary>>
  end
end
```

íŒ¨í„´:

- parse: `<<...>> = bin` í˜•íƒœë¡œ ëª…ì„¸ì— ë§ì¶° ë¶„í•´
- build: `<<...>>` ë¡œ ëª…ì„¸ì— ë§ì¶° ì¡°ë¦½

ì´ ë‘ í•¨ìˆ˜ë¥¼ ë¬¶ì–´ì„œ **round-trip í…ŒìŠ¤íŠ¸**ë¥¼ ìˆ˜í–‰í•˜ë©´,
í”„ë¡œí† ì½œ êµ¬í˜„ì˜ ì‹ ë¢°ë„ê°€ í¬ê²Œ ì˜¬ë¼ê°„ë‹¤.

---

### property ê¸°ë°˜ í…ŒìŠ¤íŠ¸ íŒíŠ¸

ë°”ì´ë„ˆë¦¬ ì½”ë“œëŠ” **property ê¸°ë°˜ í…ŒìŠ¤íŠ¸**ì™€ ì˜ ì–´ìš¸ë¦°ë‹¤.

ì˜ˆ:

```elixir
# ì˜ì‚¬ ì½”ë“œ: ì‹¤ì œë¡œëŠ” StreamData ë“± ì‚¬ìš©

property "encode/decode roundtrip" do
  for_all {ver, type, payload} <- some_generator() do
    bin = encode(ver, type, payload)
    {ver2, type2, payload2} = decode(bin)
    assert {ver, type, payload} == {ver2, type2, payload2}
  end
end
```

- ì •ìˆ˜ ë²”ìœ„/ê¸¸ì´ ì œí•œ ë“±ì„ í¬í•¨í•œ generatorë¥¼ ë§Œë“¤ê³ ,
- encodeâ†’decode ì™•ë³µì„ ìë™ìœ¼ë¡œ ê²€ì¦í•˜ë©´,
- ì—”ë””ì•ˆ/ê¸¸ì´/ë¶€í˜¸ ë“±ì—ì„œ ì‹¤ìˆ˜í•  ì—¬ì§€ê°€ ì¤„ì–´ë“ ë‹¤.

---

## _11.7 ì¹œìˆ™í•˜ì§€ë§Œ ì•„ì§ ë‚¯ì„  â€” í•¨ì •ê³¼ í•´ë²•_

ë§ˆì§€ë§‰ìœ¼ë¡œ, **ì‹¤ì „ì—ì„œ ìì£¼ ë§ˆì£¼ì¹˜ëŠ” ë¬¸ì œë“¤**ê³¼ ê·¸ í•´ê²°ì±…ì„ ì •ë¦¬í•œë‹¤.

---

### ë¬¸ìì—´â‰ charlist í˜¼ë™

- `"abc"` : binary() (ë¬¸ìì—´)
- `'abc'` : charlist = ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸

ë¬¸ì œ ì˜ˆ:

```elixir
String.length('abc')
# Protocol.UndefinedError: protocol String.Chars not implemented for 'abc'

```

í•´ê²°:

- ë¬¸ìì—´ì€ í•­ìƒ í°ë”°ì˜´í‘œ `"..."` ë¥¼ ì‚¬ìš©í•œë‹¤.
- charlistëŠ” ì‘ì€ë”°ì˜´í‘œ `'...'` ë¡œ ì“°ë˜, Erlang ì¸í„°ë¡­ ê²½ê³„ì—ì„œë§Œ ì‚¬ìš©í•œë‹¤.
- ë³€í™˜ì€ `to_charlist/1`, `List.to_string/1` ë“±ìœ¼ë¡œ í•œë‹¤.

---

### ë°”ì´íŠ¸ ê²½ê³„ ì¸ë±ì‹± ê¸ˆì§€(UTF-8 ê¹¨ì§)

ë©€í‹°ë°”ì´íŠ¸ UTF-8 ë¬¸ìì—´ì„ **ë°”ì´íŠ¸ ìŠ¬ë¼ì´ìŠ¤**ë¡œ ìë¥´ë©´ ë¬¸ì œê°€ ëœë‹¤.

```elixir
# ì´ëŸ° ì‹ì˜ ì˜ë¼ë‚´ê¸°ëŠ” ìœ„í—˜:

bad = :binary.part("ì•ˆë…•", 1, 2)
```

- ìŠ¬ë¼ì´ìŠ¤ê°€ UTF-8 ì½”ë“œ ìœ ë‹› ì¤‘ê°„ì—ì„œ ëŠê¸°ë©´,
  ì´í›„ `String.length/1`, ì¶œë ¥, codec ë“±ì—ì„œ ì˜ˆì™¸/ê¹¨ì§ì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

í•´ê²°:

- í…ìŠ¤íŠ¸ëŠ” í•­ìƒ **String API** ì´ìš©
- ì‚¬ìš©ì â€œê¸€ì ìˆ˜â€ëŠ” **ê·¸ë˜í˜ì„ ë‹¨ìœ„**(`String.graphemes/1`)ë¡œ ì²˜ë¦¬

---

### iodata ë¯¸ì‚¬ìš©ìœ¼ë¡œ ì¸í•œ ì„±ëŠ¥ ì €í•˜

ë¬¸ìì—´ì„ ë‹¤ìŒê³¼ ê°™ì´ ëˆ„ì í•˜ëŠ” ì½”ë“œëŠ” í”¼í•œë‹¤.

```elixir
# ë‚˜ìœ ì˜ˆ

acc = ""
for line <- lines do
  acc = acc <> line <> "\n"
end
```

ëŒ€ì‹ :

```elixir
iodata = for line <- lines, do: [line, "\n"]
bin    = :erlang.iolist_to_binary(iodata)
```

ë˜ëŠ”:

```elixir
lines
|> Stream.map(&[&1, "\n"])
|> Stream.into(File.stream!("out.log"))
|> Stream.run()
```

---

### ì„œë¸Œë°”ì´ë„ˆë¦¬ ëˆ„ìˆ˜

í° binaryì—ì„œ ë¶€ë¶„ì„ ì˜ë¼ Map í‚¤ë¡œ ì“°ëŠ” ì½”ë“œ:

```elixir
def index_by_prefix(lines) do
  Enum.reduce(lines, %{}, fn line, acc ->
    key = :binary.part(line, 0, 8)
    Map.update(acc, key, [line], &[line | &1])
  end)
end
```

ì—¬ê¸°ì„œ keyëŠ” lineì˜ ì„œë¸Œë°”ì´ë„ˆë¦¬ì¼ ìˆ˜ ìˆê³ , lines ìì²´ê°€ í° binaryì—ì„œ ë‚˜ì˜¨ ì„œë¸Œë°”ì´ë„ˆë¦¬ë¼ë©´,
ì „ì²´ large binaryë¥¼ ê³„ì† ë¶™ì¡ê³  ìˆì„ ìˆ˜ ìˆë‹¤.

í•´ê²°:

```elixir
key = :binary.part(line, 0, 8) |> :binary.copy()
```

---

### ì—”ë””ì•ˆ/ë¶€í˜¸/ì •ë°€ë„ ëª…ì‹œ ëˆ„ë½

í”„ë¡œí† ì½œ ëª…ì„¸ì—ì„œ `uint16 little-endian` ì´ë¼ê³  ë˜ì–´ ìˆëŠ”ë°,
ì½”ë“œë¥¼ `<<x::16>>` ë¡œë§Œ ì“°ë©´ ê¸°ë³¸(big-endian)ê³¼ ë§ì§€ ì•ŠëŠ”ë‹¤.

- **í•­ìƒ ëª…ì„¸ì— ì íŒ ì—”ë””ì•ˆ/ë¶€í˜¸/í¬ê¸°ë¥¼ í•œì •ìë¡œ ëª…ì‹œ**í•˜ì.

```elixir
# ëª…ì„¸: 16-bit unsigned, little-endian

<<x::little-unsigned-16>>
```

---

### String vs :binary API ê²½ê³„

í…ìŠ¤íŠ¸ ë¡œì§ ì¤‘ê°„ì— `:binary.part/3` ê°™ì€ ë°”ì´íŠ¸ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì„ìœ¼ë©´,
ë‚˜ì¤‘ì— **UTF-8 ê²½ê³„ ë¬¸ì œ**ê°€ í„°ì§ˆ ìˆ˜ ìˆë‹¤.

- **í…ìŠ¤íŠ¸ ì²˜ë¦¬**: `String` ëª¨ë“ˆ
- **ë°”ì´íŠ¸ ì²˜ë¦¬**: `:binary` + íŒ¨í„´ ë§¤ì¹­
- ë‘ ì„¸ê³„ê°€ ë§Œë‚˜ëŠ” ì§€ì ì—ì„œë§Œ **ë³€í™˜ í•¨ìˆ˜**ë¥¼ ì‚¬ìš©

---

### ì„±ëŠ¥Â·ë©”ëª¨ë¦¬ ëª¨ë¸(ê°œëµ)

ë§ˆì§€ë§‰ìœ¼ë¡œ, ì„±ëŠ¥ ì§ê´€ì„ ì •ë¦¬í•œë‹¤.

- íŒ¨í„´ ë§¤ì¹­ ë¶„í•´:
  - í—¤ë” í•´ì„ì€ **ìƒìˆ˜ ì‹œê°„**,
  - í˜ì´ë¡œë“œ ë¶€ë¶„ë§Œ í•„ìš”í•œ ë§Œí¼ ë¹„ìš© ë°œìƒ
- iodata ê²°í•©:
  - ì´ ì¶œë ¥ ê¸¸ì´ $$N$$ì— ëŒ€í•´

    $$
    T_{\text{iobuf}} \approx c \cdot N
    $$

- `<>` ë°˜ë³µ ê²°í•©:

    $$
    T_{\text{concat}} \approx \sum_{i=1}^{k} i \cdot \Delta_i \sim O(N^2)
    $$

- ì„œë¸Œë°”ì´ë„ˆë¦¬ ì˜¤ë˜ ë³´ê´€:
  - í”¼í¬ ë©”ëª¨ë¦¬ â†‘, GC ì••ë ¥ â†‘, ì˜ˆì¸¡í•˜ê¸° ì–´ë ¤ìš´ ë©”ëª¨ë¦¬ ì‚¬ìš© íŒ¨í„´

---

## ì‹¤ì „ ë ˆì‹œí”¼ ìš”ì•½

- **ê¸¸ì´+íƒ€ì… í”„ë ˆì´ë°** â†’ ìƒíƒœê¸°ê³„ ìŠ¤íŠ¸ë¦¬ë° íŒŒì„œë¡œ êµ¬í˜„í•˜ê³ ,
  encode/decode round-trip í…ŒìŠ¤íŠ¸ ìˆ˜í–‰
- **UTF-8 ë¬¸ìì—´ ì²˜ë¦¬** â†’ `String` + ê·¸ë˜í˜ì„ ê¸°ì¤€ ê¸¸ì´/ìë¥´ê¸°
- **ëŒ€ê·œëª¨ ì¶œë ¥** â†’ iodata + `:erlang.iolist_to_binary/1` ë˜ëŠ” `Stream.into(File.stream!/3)`
- **í”„ë¡œí† ì½œ íŒŒì‹±** â†’ ëª…ì„¸ë¥¼ ê·¸ëŒ€ë¡œ `<< >>` íŒ¨í„´ìœ¼ë¡œ ì˜®ê¸°ê³ ,
  ì—”ë””ì•ˆ/ë¶€í˜¸/ê¸¸ì´/ì •ê·œí™”ê¹Œì§€ í•œ ë²ˆì— ì²˜ë¦¬
- **ë©”ëª¨ë¦¬ ìµœì í™”** â†’ ì„œë¸Œë°”ì´ë„ˆë¦¬ ì—¬ë¶€ë¥¼ ì˜ì‹í•˜ê³ ,
  í•„ìš”í•œ ê³³ì—ì„œëŠ” `:binary.copy/1` ë¡œ ì‘ì€ ì¡°ê°ì„ ë…ë¦½ì‹œí‚¤ê¸°

ì´ ì¥ì˜ ë‚´ìš©ë“¤ì„ ì‹¤ì œ í”„ë¡œì íŠ¸ì˜ ë„¤íŠ¸ì›Œí¬/íŒŒì¼/ë¡œê·¸ ì²˜ë¦¬ ì½”ë“œì— í•˜ë‚˜ì”© ì ìš©í•´ ë³´ë©´,
ì—˜ë¦­ì„œì—ì„œ ë°”ì´ë„ˆë¦¬ì™€ ë¹„íŠ¸ìŠ¤íŠ¸ë§ì„ **ì–¸ì–´ ì°¨ì›ì˜ 1ê¸‰ ë„êµ¬**ë¡œ ì“¸ ìˆ˜ ìˆê²Œ ëœë‹¤.
