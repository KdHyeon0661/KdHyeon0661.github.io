---
layout: post
title: 컴퓨터시스템 - 공유 라이브러리로 동적 링크하기
date: 2025-08-11 18:20:23 +0900
category: 컴퓨터시스템
---
# 공유 라이브러리로 동적 링크하기 (Dynamic Linking with Shared Libraries)

공유 라이브러리(Shared Library)는 여러 프로그램이 **공용으로 참조하는 코드**를 담은 파일로, 리눅스에서는 `.so`(Shared Object), 윈도우에서는 `.dll`, macOS에서는 `.dylib` 확장자를 가진다.  
**동적 링크(Dynamic Linking)**는 실행 시간에 이 라이브러리를 로드하여 프로그램과 결합하는 방식이다.

---

## 1. 개요

### 정적 링크 vs 동적 링크
- **정적 링크(Static Linking)**:  
  라이브러리의 코드가 **빌드 시점**에 실행 파일에 포함됨 → 실행 파일 크기 증가, 업데이트 시 재빌드 필요
- **동적 링크(Dynamic Linking)**:  
  라이브러리의 코드가 **실행 시점**에 메모리에 로드 → 실행 파일 크기 감소, 여러 프로그램이 동일 라이브러리를 공유 가능

---

## 2. 동적 링크의 장점

1. **메모리 절약**:  
   한 번 로드된 공유 라이브러리는 여러 프로세스에서 **공유 메모리**로 사용 가능
2. **업데이트 용이**:  
   라이브러리를 교체하면 모든 프로그램에 즉시 반영
3. **실행 파일 크기 감소**:  
   라이브러리 코드가 실행 파일에 포함되지 않음
4. **Lazy Binding**으로 초기 실행 속도 향상

---

## 3. 동적 링크 과정

### 빌드 시
- 컴파일러(`gcc`)가 **링커(ld)**를 호출할 때 `-l` 옵션으로 라이브러리를 지정
- 실행 파일에 **동적 라이브러리 의존 정보**와 **심볼 참조 정보**만 포함
- ELF 파일의 **Dynamic Section**에 필요한 `.so` 파일 목록 기록

```bash
# 예: libm(수학 라이브러리)을 동적 링크
gcc main.c -o main -lm
```

### 실행 시
1. **커널 로더**가 ELF 헤더의 `PT_INTERP` 엔트리를 확인 → 동적 링커(`ld-linux.so`) 실행
2. 동적 링커가 **Dynamic Section** 확인 → 필요한 `.so` 파일 탐색
3. 환경변수와 기본 경로에서 라이브러리 검색
   - `/lib`
   - `/usr/lib`
   - `LD_LIBRARY_PATH`
4. `.so` 파일을 메모리에 매핑(mmap)
5. 심볼 해석(Symbol Resolution)과 재배치(Relocation) 수행
6. `main()` 실행

---

## 4. 동적 링크에서 사용하는 주요 데이터 구조

- **PLT (Procedure Linkage Table)**  
  함수 호출 시 실제 주소 대신 PLT 엔트리를 참조
- **GOT (Global Offset Table)**  
  전역 변수와 함수 주소를 저장하여 위치 독립 코드(Position Independent Code) 구현
- **Dynamic Section** (`.dynamic`)  
  필요한 라이브러리 목록, 심볼 테이블, 재배치 정보 저장

---

## 5. Lazy Binding vs Eager Binding

- **Lazy Binding**:  
  함수가 처음 호출될 때 심볼 해석 수행 → 시작 속도 빠름
- **Eager Binding**:  
  프로그램 시작 시 모든 심볼 해석 → 실행 중 지연 최소화

환경 변수 `LD_BIND_NOW=1`로 Eager Binding 강제 가능

---

## 6. 동적 링크 예제 (C)

```c
#include <stdio.h>
#include <math.h>

int main() {
    double x = 2.0;
    printf("sqrt(%.2f) = %.2f\n", x, sqrt(x));
    return 0;
}
```

빌드 및 실행:
```bash
gcc main.c -o main -lm
ldd main   # 실행 파일이 참조하는 공유 라이브러리 확인
./main
```

---

## 7. 실행 시 라이브러리 검색 경로

1. 환경 변수 `LD_LIBRARY_PATH`
2. `/etc/ld.so.cache` (ldconfig로 생성)
3. 표준 경로 `/lib`, `/usr/lib`

`LD_DEBUG=libs ./main` → 라이브러리 로드 과정 출력

---

## 8. 동적 라이브러리 제작

### 예: `libhello.so` 만들기
```c
// hello.c
#include <stdio.h>

void hello() {
    printf("Hello, Shared Library!\n");
}
```

컴파일:
```bash
gcc -fPIC -c hello.c
gcc -shared -o libhello.so hello.o
```

사용:
```c
#include <stdio.h>
void hello();

int main() {
    hello();
    return 0;
}
```

빌드:
```bash
gcc main.c -L. -lhello -o main
export LD_LIBRARY_PATH=.
./main
```

---

## 9. 결론

동적 링크는 메모리 효율, 유지보수성, 실행 파일 크기 감소 등의 장점이 있지만,
- 실행 시 의존 라이브러리가 없으면 **실행 실패**
- 버전 호환성 문제 발생 가능

따라서 **버전 관리, 경로 설정, 보안**을 고려한 설계가 필요하다.