---
layout: post
title: 컴퓨터시스템 - 공유 라이브러리로 동적 링크하기
date: 2025-08-11 18:20:23 +0900
category: 컴퓨터시스템
---
# 공유 라이브러리로 동적 링크하기 (Dynamic Linking with Shared Libraries)

## 한 페이지 요약

- **정적 vs 동적**
  - 정적: 빌드 시 바이너리에 **코드 포함** → 크기↑, 업데이트 재빌드 필요
  - 동적: 실행 시 **로더가 .so 로드** → 메모리 공유, 패치 반영 용이
- **핵심 구조**: **ELF**의 `.dynamic`(DT_…), **PLT/GOT**, **재배치(Reloc)**, **PT_INTERP → 동적 링커**
- **검색 경로**: **LD_LIBRARY_PATH** → **DT_RPATH/RUNPATH** → **ld.so.cache** → **기본 디렉터리(예: `/lib64`,`/usr/lib64`)**
  - 현대 권장: **DT_RUNPATH + `$ORIGIN`** (RPATH는 점진 폐기)
- **성능/보안**: Lazy vs Eager(= `-Wl,-z,now` 또는 `LD_BIND_NOW=1`), **RELRO**, **PIE/PIC**, **가시성 제한**
- **버전/ABI**: **SONAME**로 호환성 선언, 심볼/버전 스크립트로 **API 표면 최소화**
- **실전**: `readelf/objdump/ldd/LD_DEBUG`로 추적, `dlopen/dlsym`으로 플러그인, `--as-needed`·`RUNPATH`·`$ORIGIN`로 배포 안정화

---

## 정적 링크 vs 동적 링크 — 무엇이 다른가

| 항목 | 정적(Static) | 동적(Dynamic) |
|---|---|---|
| 결합 시점 | 빌드 시 | 실행 시(로더) |
| 실행 파일 크기 | 큼 | 작음 |
| 패치 반영 | 재빌드/재배포 필요 | 라이브러리 교체로 즉시 |
| 메모리 사용 | 프로세스마다 복제 | **페이지 공유** |
| 최적화 범위 | LTO로 전역 최적화 용이 | DSO 경계로 제한(PLT 간접) |
| 보안 하드닝 | 단순 | **RELRO/BIND_NOW/PIE** 등 필수 고려 |

---

## ELF와 동적 링크의 큰 그림

```
ELF 실행 파일(ET_DYN/PIE) ──PT_INTERP──► 동적 링커(ld-linux.so.*)
                     │
                     └─ .dynamic( DT_NEEDED: libX.so.N, … )
                              │
                              ├─ 라이브러리 검색(환경변수/캐시/경로)
                              ├─ mmap로 매핑 + 재배치 처리(Reloc)
                              ├─ PLT/GOT 작성 (Lazy/Eager)
                              └─ 초기화(.init/.ctors) 실행 → main()
```

- **PT_INTERP**: 사용할 동적 링커 경로(예: `/lib64/ld-linux-x86-64.so.2`, musl은 `/lib/ld-musl-x86_64.so.1`)
- **DT_NEEDED**: 의존 `.so` 목록
- **PLT/GOT**: 간접 호출/주소 테이블(PIE/PIC 필수 요소)
- **Relocation**: 실행 시점 주소에 맞게 **패치**

---

## 동적 링크의 빌드 파이프라인

### 개발용/배포용 빌드 옵션 정리

- **공유 라이브러리 빌드**:
  - 컴파일: `-fPIC` (위치 독립 코드)
  - 링크: `-shared -Wl,-soname,libhello.so.1`
- **실행 파일 링크**:
  - 기본: `-lhello -L/path`
  - 검색 경로 내장: `-Wl,-rpath,'$ORIGIN'` *보다는* **-Wl,-rpath,**보다 **-Wl,-rpath** 대신 **-Wl,-rpath**가 아닌 **-Wl,-rpath**… (아래 RUNPATH 권장 참고)
  - **권장**: `-Wl,-rpath,$ORIGIN/lib -Wl,--enable-new-dtags` → **DT_RUNPATH** 생성

> **RUNPATH vs RPATH**
> - **RUNPATH**: `LD_LIBRARY_PATH`보다 뒤에서 검색, **직접 의존에만 적용**(전이 의존엔 미적용).
> - **RPATH**: 오래된 방식. `LD_LIBRARY_PATH`와의 우선순위/보안 이슈로 비권장.
> - `--enable-new-dtags`를 쓰면 RPATH 대신 **RUNPATH**가 기록된다(현대 권장).

### 예시: `libhello.so` 제작·사용

```c
// hello.c
#include <stdio.h>

void hello(void){ puts("Hello, Shared Library!"); }
```

```bash
# 공유 라이브러리

gcc -fPIC -c hello.c -o hello.o
gcc -shared -Wl,-soname,libhello.so.1 -o libhello.so.1.0.0 hello.o
ln -s libhello.so.1.0.0 libhello.so.1
ln -s libhello.so.1     libhello.so     # 개발 시 링커가 참조하는 링크

# 실행 파일

cat > main.c <<'EOF'
extern void hello(void);
int main(){ hello(); return 0; }
EOF

mkdir -p ./lib && mv libhello.so* ./lib/

# RUNPATH에 $ORIGIN/lib 기록(실행 파일 위치 기준 상대 참조)

gcc main.c -L./lib -lhello \
  -Wl,--enable-new-dtags -Wl,-rpath,'$ORIGIN/lib' \
  -o app

# 확인

readelf -d app | grep -E 'NEEDED|RUNPATH|RPATH'
ldd ./app            # 의존 라이브러리 해석(신뢰된 바이너리에만!)
./app                # 실행: "Hello, Shared Library!"
```

---

## 실행 시 동작 — 로더, 검색 경로, 재배치

### 검색 경로의 우선순위(일반 프로세스)

1. **LD_LIBRARY_PATH**(콜론 구분)
2. **DT_RPATH**(있는 경우; RUNPATH가 없을 때)
3. **ld.so.cache**( `/etc/ld.so.cache` )
4. **DT_RUNPATH**(직접 의존에만)
5. **기본 디렉터리**(예: `/lib64`, `/usr/lib64`)

> **보안 모드(setuid 등)에서는** 다수의 `LD_*` 환경변수가 **무시**된다.
> 컨테이너/서버 배포에서는 **LD_LIBRARY_PATH 남용 금지**: `$ORIGIN` 기반 RUNPATH가 안전/재현성 높음.

### PLT/GOT와 Lazy Binding

- **PLT 엔트리**(함수 호출용 점프 테이블)와 **GOT 엔트리**(실주소 저장)가 작성된다.
- **Lazy(지연) 결합**: 함수 **첫 호출 때** 동적 링커가 실제 주소를 **해석하고 GOT를 패치**한다.
- **Eager(즉시) 결합**: 시작 시 전부 해석(옵션 또는 환경변수)

```bash
# Lazy → Eager 전환(런타임)

LD_BIND_NOW=1 ./app

# 빌드 타임(보안 하드닝 권장)

gcc ... -Wl,-z,now     # Lazy 비활성화(BIND_NOW)
gcc ... -Wl,-z,relro   # GOT 등 일부를 read-only로
```

> **Full RELRO**는 `-Wl,-z,relro -Wl,-z,now` 조합이 일반적이다(시작 시 비용↑ 대신 런타임 안전↑).

### 재배치(Relocation) 개요

- **GOT/데이터**: 절대/상대 주소 패치
- **PLT**: Lazy일 때 첫 진입은 PLT0 트램폴린을 거쳐 바인딩
- **IRELATIVE**: 런타임 계산형 재배치(부트스트랩 순서 유의)

---

## 심볼 해석과 인터포지션(오버라이드)

- **심볼 가시성**: `-fvisibility=hidden` 기본 + 공개 API만 `__attribute__((visibility("default")))`
- **LD_PRELOAD**: 로딩 우선순위 상단에 사용자 .so를 주입해 함수 오버라이드(디버깅/후킹)
- **`dlsym` 특수 핸들**:
  - `RTLD_DEFAULT`: 현재 링크 맥락의 기본 탐색
  - `RTLD_NEXT`: **호출자 다음** 심볼(체이닝/래핑에 유용)

```c
// preload.c — puts()를 가로채는 예(학습용)
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>

int puts(const char *s){
  static int (*real_puts)(const char*) = NULL;
  if(!real_puts) real_puts = dlsym(RTLD_NEXT, "puts");
  real_puts("[interposed] ");
  return real_puts(s);
}
```

```bash
gcc -fPIC -shared -o libpreload.so preload.c -ldl
LD_PRELOAD=./libpreload.so ./app
```

> **주의**: 보안 모드에서는 `LD_PRELOAD`가 차단된다. 운영 환경 오용 금지.

---

## `dlopen`/`dlsym` — 런타임 플러그인

```c
// plugin.c
#include <stdio.h>

__attribute__((visibility("default")))
void run(void){ puts("plugin run"); }
```

```c
// host.c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>

int main(){
  void *h = dlopen("./libplugin.so", RTLD_NOW | RTLD_LOCAL);
  if(!h){ puts(dlerror()); return 1; }
  void (*run)(void) = dlsym(h, "run");
  if(!run){ puts(dlerror()); return 1; }
  run();
  dlclose(h);
  return 0;
}
```

```bash
gcc -fPIC -shared -o libplugin.so plugin.c
gcc host.c -ldl -o host
./host
```

- 플래그:
  - `RTLD_NOW`/`RTLD_LAZY` (즉시/지연 바인딩)
  - `RTLD_GLOBAL`/`RTLD_LOCAL` (심볼 전파 범위)
  - `RTLD_DEEPBIND`(자기 내부 우선 검색, 권장 X: 예측성↓)

---

## ABI/SONAME/버전 관리

### SONAME와 심볼 안정성

- **SONAME**: 런타임 호환을 대표하는 **주 버전**(예: `libhello.so.1`)
- 배포 관례:
  ```
  libhello.so        → 개발(링커 입력용) 심볼릭 링크
  libhello.so.1      → SONAME 심볼릭 링크
  libhello.so.1.2.3  → 실제 파일
  ```
- **ABI가 깨질 때만** SONAME **주 버전** 증가. API 추가/버그 수정은 마이너/패치.

### 심볼/버전 스크립트(가시성·버저닝)

`hello.map`:
```
HELLO_1.0 {
  global: hello;
  local:  *;
};
```

```bash
gcc -fPIC -c hello.c
gcc -shared -Wl,-soname,libhello.so.1 -Wl,--version-script=hello.map \
  -o libhello.so.1.0.0 hello.o
```

- 효과: **공개 심볼 최소화**(네임스페이스 오염 방지), 구버전 호환 시 **다중 버전** 공존 가능

> **현대 glibc 동향 참고**: glibc 2.34부터 **`libpthread` 등이 `libc`로 통합**되었다(스레딩은 여전히 `-pthread` 사용, 링크 타겟은 libc). 오래된 문서의 “`-lpthread` 별도” 관행은 최신 배포판에서 의미가 달라졌음을 유의.

---

## 성능·보안 하드닝 플래그 모음

- **PIE/PIC**: `-fPIC`(공유), `-fpie -pie`(실행파일 ASLR 친화)
- **RELRO**: `-Wl,-z,relro` (GOT 일부 R/O), **Full RELRO**는 `-Wl,-z,now`와 조합
- **BIND_NOW**: `-Wl,-z,now` (Lazy 금지)
- **가시성**: `-fvisibility=hidden` + 공개 API만 `default`
- **RUNPATH**: `-Wl,--enable-new-dtags -Wl,-rpath,'$ORIGIN/…'`
- **as-needed**: 불필요한 DT_NEEDED 제거(리눅스 배포판 다수에서 **기본 활성**)
  - 필요 시 역순 의존 해결: `-Wl,--no-as-needed -lfoo -Wl,--as-needed`

---

## 도구로 내부 들여다보기

```bash
# 동적 섹션(의존/런패스/바인딩 플래그)

readelf -d app

# 프로그램 헤더(PT_INTERP로 링커 확인)

readelf -l app | grep INTERP

# 내보내는/참조하는 동적 심볼

objdump -T libhello.so | less

# 로딩·바인딩 로그(학습에 매우 유용)

LD_DEBUG=libs,bindings ./app

# 캐시 조회·갱신

ldconfig -p    # 캐시된 라이브러리 목록
sudo ldconfig  # /etc/ld.so.cache 갱신(루트)
```

> `ldd`는 **신뢰된 실행 파일에만** 사용(동적 링커를 통해 실행되므로 위험할 수 있음).

---

## 문제 해결 매핑(트러블슈팅)

증상 | 원인 후보 | 빠른 확인 | 해결
---|---|---|---
실행 시 “not found” | 검색 경로 부재 | `LD_DEBUG=libs` | RUNPATH `$ORIGIN` 추가, ld.so.cache 등록
ABI 에러/Segfault | SONAME 불일치, 심볼 충돌 | `objdump -T`, `readelf -d` | SONAME 정책, 버전 스크립트
첫 호출 지연 큼 | Lazy 바인딩 | `LD_BIND_NOW=1`로 비교 | `-Wl,-z,now` (Full RELRO)
의존이 제거됨 | `--as-needed` | 링크 로그/DT_NEEDED 확인 | 문제 구간만 `--no-as-needed`
`LD_PRELOAD` 무시 | 보안 모드 | `id -u`, `cap` | setuid 해제, 개발환경에서만 사용
컨테이너 배포 깨짐 | 절대경로/RPATH 남용 | `readelf -d` | `$ORIGIN` 기반 RUNPATH로 정정

---

## 윈도우·macOS(짧게 비교)

- **Windows**: `.dll`, **검색 순서**는 OS 버전/정책(SafeDLLSearchMode) 영향. **Delay-Load**(`/DELAYLOAD`)로 Lazy 유사 동작.
- **macOS**: `.dylib`, **`@rpath`/`@loader_path`/`@executable_path`**. 환경변수는 `DYLD_*` (SIP 영향으로 제한).

---

## 컨테이너/배포 실무 팁

- **musl vs glibc**: 베이스 이미지에 맞춰 **동적 링커 경로**가 다르다. (musl: `/lib/ld-musl-*.so.1`)
- 베이스 이미지 변경 시 **런타임 `.so` ABI** 호환성 점검(특히 C++ libstdc++/libgcc)
- 재현성: **RUNPATH + `$ORIGIN`** 우선, `LD_LIBRARY_PATH`는 **개발/디버그 한정**

---

## 실험: Lazy vs Eager, RUNPATH 확인

```c
// sqrt_demo.c
#include <math.h>
#include <stdio.h>

int main(){
  for(int i=0;i<3;i++)
    printf("%.1f -> %.3f\n", (double)i, sqrt((double)i));
  return 0;
}
```

```bash
gcc sqrt_demo.c -lm -Wl,--enable-new-dtags -Wl,-rpath,'$ORIGIN' -o sqrt_demo

# Lazy(기본)

time ./sqrt_demo

# Eager

time env LD_BIND_NOW=1 ./sqrt_demo

# 로딩·바인딩 로그

LD_DEBUG=libs,bindings ./sqrt_demo 2>&1 | less
```

관찰 포인트: 첫 `sqrt` 호출 시 바인딩 차이, `ld-linux`의 검색 로그, RUNPATH 적용 여부.

---

## 수식으로 보는 동적 바인딩 비용(개념 근사)

동적 결합에 따른 초기 바인딩 누적 페널티(간단 모델):

$$
T_{\text{start}} \approx T_{\text{mmap}} + \sum_{r \in \text{Relocs}} c_r \;+\;
\begin{cases}
\sum_{f \in \text{호출된 함수}} P_f & \text{(Lazy)}\\[4pt]
\sum_{f \in \text{모든 외부 함수}} P_f & \text{(Eager)}
\end{cases}
$$

- \(c_r\): 재배치 1건 처리 비용(유형/수량에 비례)
- \(P_f\): 함수 바인딩(PLT/GOT 패치) 비용
- 보안 하드닝(Full RELRO)은 시작 시 \(T_{\text{start}}\)↑ 대신 런타임 무결성↑

---

## 체크리스트 (프로젝트 적용)

- [ ] **PIC/PIE**로 빌드(`-fPIC`, `-fpie -pie`)
- [ ] **RUNPATH + `$ORIGIN`**( `-Wl,--enable-new-dtags -Wl,-rpath,'$ORIGIN/…'` )
- [ ] **SONAME** 부여 & 심볼 **가시성 축소**(`-fvisibility=hidden`)
- [ ] **RELRO + BIND_NOW** (`-Wl,-z,relro -Wl,-z,now`) 정책 검토
- [ ] **as-needed**로 불필요 의존 제거(필요 구간만 `--no-as-needed`)
- [ ] `readelf/objdump/LD_DEBUG`로 **내부 확인 자동화**
- [ ] 컨테이너/배포 환경에서 **동적 링커 경로**와 **런타임 .so** 일치 검증

---

## 부록 A — 명령 치트시트

```bash
# 링커 입력/런패스

gcc app.c -L./lib -lfoo -Wl,--enable-new-dtags -Wl,-rpath,'$ORIGIN/lib' -o app
# 공유 라이브러리

gcc -fPIC -shared -Wl,-soname,libfoo.so.1 -o libfoo.so.1.2.3 foo.o
# 내부 확인

readelf -d app
readelf -l app | grep INTERP
objdump -T libfoo.so | less
# 로딩/바인딩 트레이스

LD_DEBUG=libs,bindings ./app
# 캐시

sudo ldconfig
ldconfig -p | grep foo
```

---

## 부록 B — 가시성/버전 스크립트 템플릿

`export.map`:
```
MYLIB_1.0 {
  global: mylib_init; mylib_do; mylib_close;
  local:  *;
};
```

빌드:
```bash
gcc -fPIC -c mylib.c
gcc -shared -Wl,-soname,libmylib.so.1 \
    -Wl,--version-script=export.map \
    -o libmylib.so.1.0.0 mylib.o
```

---

## 마무리

동적 링크는 **메모리 효율과 업데이트 민첩성**을 제공하지만,
성공적인 운영을 위해서는 **ELF·PLT/GOT·RUNPATH·RELRO/BIND_NOW·가시성/SONAME**을 함께 다뤄야 한다.
실무에서 **`$ORIGIN` 기반 RUNPATH**, **가시성 축소**, **하드닝 플래그**, **의존 최소화**를 표준으로 삼고,
항상 **`readelf/LD_DEBUG`로 확인 → CI에서 자동검사**를 습관화하자. 이것이 **안전하고 재현 가능한 동적 링크**의 지름길이다.
