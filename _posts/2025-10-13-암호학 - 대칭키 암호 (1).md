---
layout: post
title: 암호학 - 대칭키 암호 (1)
date: 2025-10-13 14:30:23 +0900
category: 암호학
---
# 대칭키 암호(블록·스트림)

> 이 장은 **블록암호의 추상 개념 → 라운드 구조(라운드 함수, S-box/Permutation/키혼합) → AES 전체 구조(라운드·키스케줄·GF 연산·하드웨어 가속) → 스트림계열 대표 ChaCha20(상태/쿼터라운드/블록함수/키·Nonce·카운터)** 순으로 정리합니다.
> 표준 API 예제는 Python `cryptography`를 쓰고, 내부 동작은 **교육용 순수 파이썬**으로 작게 구현해 직관을 잡습니다.
> **주의**: 실무에서는 항상 **검증된 라이브러리와 AEAD 모드**를 사용하세요(본문 중 “실무 박스”에 강조).

---

## ✅ 5.1 블록암호 개념

### 정의

- **블록암호(block cipher)**: 고정 길이 \(n\)비트 블록 공간 \(\{0,1\}^n\) 위에서 **키 \(K\)** 에 따라 선택되는 **가역(permutation)**
  \[
  E_K: \{0,1\}^n \to \{0,1\}^n,\qquad D_K = E_K^{-1}
  \]
- 구현은 보통 **라운드(round)** 를 여러 번 반복:
  \[
  \text{State}_{i+1} = \mathsf{Round}_i(\text{State}_i, K_i)
  \]
  여기서 \(K_i\)는 키스케줄로부터 파생된 **라운드 키**.

### 설계 직관 — SPN vs Feistel

- **SPN (Substitution–Permutation Network)**
  - 비선형 **S-box**(혼돈) + 선형 **Permutation/확산층**(확산), 그리고 **키 혼합(AddRoundKey)** 를 라운드별 반복.
  - AES가 대표적 SPN.
- **Feistel 네트워크**
  - 블록을 좌/우 반으로 나누고, \(R\gets R \oplus F(L,K),\; L\gets R_{\text{old}}\) 형태로 진행.
  - DES, Camellia 등. 비가역 \(F\)로도 **전체는 가역**이 되는 장점.

### 안전성의 직관적 요구

- **혼돈(Confusion)**: 키 비트가 암호문에 **비선형적으로 얽힘**(S-box의 역할).
- **확산(Diffusion)**: 평문 비트 하나가 암호문 전체에 **넓게 퍼짐**(선형 확산층/행렬).
- **라운드 반복**으로 차분·선형 등 구조적 크립토분석의 이득을 억제.

---

## ✅ 5.2 라운드 함수 구성요소

### S-box (Substitution box)

- 작은 비트열(예: 8비트)을 **비선형 치환**: \(S:\{0,1\}^m\to\{0,1\}^m\).
- 설계 목표(대표 지표)
  - **비선형성(Nonlinearity)** ↑ : 선형 근사 정확도가 낮아야 함.
  - **차분균등성(Differential uniformity)** ↓ : 입력 차분 → 출력 차분 확률이 고르게 낮아야 함.
  - **고정점/역고정점** 적음, **주기** 좋음 등.
- **AES S-box**: \(\mathbb{F}_{2^8}\)에서의 **역원**(0은 0 매핑) + **아핀 변환**으로 구성(§5.3).

### 선형 확산층 (Permutation/Linear layer)

- 비트를 섞어 **한 비트의 영향력**이 빠르게 전체로 확산되게 함.
- 구현 형태:
  - **행·열 순환(ShiftRows)**
  - **고정 행렬 곱(MixColumns)**: \(\mathbb{F}_{2^8}\) 위에서 열 벡터에 일정 행렬을 곱한다.
- 설계 목표: **지연/하드웨어 비용** 대비 **지표(branch number)** 최대화.

### 키 혼합(AddRoundKey)

- 상태와 라운드 키를 **XOR**(또는 모듈러 덧셈)로 섞는다.
- 안전성은 **라운드 키의 독립성/랜덤성** 가정에도 의존 → **키 스케줄** 중요.

---

## ✅ 5.3 AES 한눈에 보기 (Rijndael, FIPS-197)

### 파라미터

- 블록 길이: **128비트**(고정).
- 키 길이: **128/192/256비트**.
- 라운드 수: **10/12/14** (키가 길수록 라운드 증가).

### 라운드 구조(128비트 키 기준)

1. **AddRoundKey** (라운드0; 초기 키 혼합)
2. 라운드 1..9: **SubBytes → ShiftRows → MixColumns → AddRoundKey**
3. 마지막 라운드: **SubBytes → ShiftRows → AddRoundKey** (MixColumns 없음)

상태는 \(4\times 4\) 바이트 행렬(열 우선)로 관리:
\[
\text{State} =
\begin{bmatrix}
s_{0,0}&s_{0,1}&s_{0,2}&s_{0,3}\\
s_{1,0}&s_{1,1}&s_{1,2}&s_{1,3}\\
s_{2,0}&s_{2,1}&s_{2,2}&s_{2,3}\\
s_{3,0}&s_{3,1}&s_{3,2}&s_{3,3}
\end{bmatrix}
\]

### SubBytes — S-box의 수학

- 유한체 \(\mathbb{F}_{2^8} \cong \mathbb{F}_2[x]/\langle m(x)\rangle\) (AES는 \(m(x)=x^8+x^4+x^3+x+1\)).
- 각 바이트 \(a\)에 대해
  1) \(a\neq 0\)이면 \(a \leftarrow a^{-1}\) (0은 0 유지),
  2) 고정 **아핀 변환** \(A(a)= M a \oplus c\) 적용.
- 목적: **비선형성 극대화**, 선형/차분 공격 저항.

### ShiftRows — 행별 순환 이동

- 0행: 0바이트 이동, 1행: 1바이트 좌순환, 2행: 2바이트, 3행: 3바이트.
- 효과: 열 간 상호작용을 유도해 **확산 가속**.

### MixColumns — 열 단위 선형 변환

- 각 열을 \([s_0,s_1,s_2,s_3]^T\)라 할 때,
  \[
  \begin{bmatrix}
  s'_0\\ s'_1\\ s'_2\\ s'_3
  \end{bmatrix}
  =
  \begin{bmatrix}
  02&03&01&01\\
  01&02&03&01\\
  01&01&02&03\\
  03&01&01&02
  \end{bmatrix}
  \cdot
  \begin{bmatrix}
  s_0\\ s_1\\ s_2\\ s_3
  \end{bmatrix}
  \quad \text{in } \mathbb{F}_{2^8}
  \]
- 여기서 02,03은 \(\mathbb{F}_{2^8}\)에서의 다항식 곱(센스: 왼쪽 쉬프트+조건부 XOR).

### 키 스케줄(Key Expansion)

- 입력 키로부터 라운드 키 \(K_0,\dots,K_{10}\) 생성(128비트 기준).
- 핵심 함수: **RotWord**(바이트 순환), **SubWord**(S-box 적용), **Rcon**(라운드 상수)
- 긴 키일수록 중간에 **Extra SubWord** 규칙 추가(192/256비트).

**교육용 파이썬 — AES 핵심 연산(요약)**
```python
# 경고: 교육용 스케치입니다(정확성/성능/보안용 아님). 실무는 라이브러리 사용!

RijXtime = lambda x: ((x<<1) ^ (0x1b if x & 0x80 else 0)) & 0xff

def mix_single_column(a):  # a: list[4] of bytes
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ RijXtime(a[0] ^ a[1])
    a[1] ^= t ^ RijXtime(a[1] ^ a[2])
    a[2] ^= t ^ RijXtime(a[2] ^ a[3])
    a[3] ^= t ^ RijXtime(a[3] ^ u)
    return a
```

> **실무 박스**: AES 자체 구현은 **금지**(타이밍/캐시/테이블루크업/패딩·모드·키스케줄 하드닝 등 수많은 위험).
> **`cryptography.hazmat`** 같은 표준 라이브러리 + **AEAD(GCM)** 를 사용하세요.

### 하드웨어 가속

- **x86**: **AES-NI**(라운드 전용 명령), **VAES**(벡터화), **PCLMULQDQ**(GCM 해시 곱).
- **ARMv8**: **AES/PMULL**.
- 결과: GCM 같은 AEAD에서 **수 GB/s 수준** 처리도 가능(코어·메모리 대역폭 한계 내).

---

## ✅ 5.4 Python으로 AES 사용하기(실무 권장 API)

> **모드·패딩**은 보안에 결정적입니다. **ECB 금지**, **CBC는 MAC/AE 없음**이면 금지. **AEAD(AES-GCM)** 를 사용하세요.

```python
# pip install cryptography

from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

key = AESGCM.generate_key(bit_length=128)   # 16B
aesgcm = AESGCM(key)
nonce = os.urandom(12)                      # 96-bit
aad = b"route:/api/v1"
pt  = b"hello aead"
ct  = aesgcm.encrypt(nonce, pt, aad)        # ciphertext || tag
pt2 = aesgcm.decrypt(nonce, ct, aad)
print(pt2)
```

- **무결성/인증**이 포함 → 복호 시 변조면 **예외**.
- **Nonce 재사용 금지**(동일 키에서)! 라이브러리 생성에 위임하거나, 안전 생성 API 사용.

---

## ✅ 5.5 ChaCha20 (스트림/ARX 계열)

### 왜 ChaCha20인가

- **ARX(Add–Rotate–XOR)** 구조: 테이블/유한체 곱 없이 **덧셈·회전·XOR**만 사용 →
  - **CPU·임베디드** 전반에서 **균일한 성능**, **타이밍 누출 위험 낮음**
  - **SIMD** 최적화 용이
- **표준화**: RFC 8439(ChaCha20-Poly1305 AEAD). TLS/SSH/QUIC 등에서 광범위 사용.

### 상태 구성(16개의 32비트 워드)

\[
\underbrace{\text{constant}}_{4}\ \parallel\
\underbrace{\text{key}}_{8}\ \parallel\
\underbrace{\text{counter}}_{1}\ \parallel\
\underbrace{\text{nonce}}_{3}
\]
- constant: `"expand 32-byte k"`의 ASCII(4워드)
- key: 256-bit(8워드)
- counter: 32-bit 블록 카운터(처음 보통 0 또는 1)
- nonce: 96-bit(3워드, RFC 8439 권장)

### 쿼터라운드(Quarter Round, QR)

- 워드 \((a,b,c,d)\)에 대해(모든 덧셈은 32-bit mod \(2^{32}\)):
  ```
  a += b; d ^= a; d <<<= 16
  c += d; b ^= c; b <<<= 12
  a += b; d ^= a; d <<<=  8
  c += d; b ^= c; b <<<=  7
  ```
- **라운드**는 QR 8회(행→열, 열→행)로 구성(**20라운드**가 ChaCha20).

**교육용 파이썬 QR**
```python
def rotl32(x, n): return ((x << n) & 0xffffffff) | (x >> (32 - n))

def quarter_round(a, b, c, d):
    a = (a + b) & 0xffffffff; d ^= a; d = rotl32(d, 16)
    c = (c + d) & 0xffffffff; b ^= c; b = rotl32(b, 12)
    a = (a + b) & 0xffffffff; d ^= a; d = rotl32(d, 8)
    c = (c + d) & 0xffffffff; b ^= c; b = rotl32(b, 7)
    return a, b, c, d
```

### 블록 함수

1) 초기 상태(16워드)를 배열 \(S\)에 적재
2) \(S\)를 복사해 \(W\)에 저장
3) 20라운드(10번의 **Double Round**) 수행:
   - **행 QR**: \((0,4,8,12), (1,5,9,13), (2,6,10,14), (3,7,11,15)\)
   - **열 QR**: \((0,5,10,15), (1,6,11,12), (2,7,8,13), (3,4,9,14)\)
4) 최종적으로 \(S[i] = S[i] + W[i]\) (워드 단위)
5) 리틀엔디언으로 바이트 스트림 출력 **→ 키스트림 블록(64바이트)**

### 암복호

- 평문과 키스트림을 **XOR**.
- **같은 키/Nonce에서 카운터가 겹치면** 같은 키스트림 → **평문 XOR 유출**(CTR과 동일 위험).
- 실무는 **Poly1305 MAC**을 결합한 **AEAD(ChaCha20-Poly1305)** 를 사용.

**교육용: ChaCha20 블록 생성 스케치**
```python
import struct

SIGMA = b"expand 32-byte k"

def chacha20_block(key32, counter, nonce12):
    # key: 32B, counter: 4B int, nonce: 12B
    def u32(x): return struct.unpack("<I", x)[0]
    state = [
        u32(SIGMA[0:4]), u32(SIGMA[4:8]), u32(SIGMA[8:12]), u32(SIGMA[12:16]),
        u32(key32[0:4]), u32(key32[4:8]), u32(key32[8:12]), u32(key32[12:16]),
        u32(key32[16:20]), u32(key32[20:24]), u32(key32[24:28]), u32(key32[28:32]),
        counter,
        u32(nonce12[0:4]), u32(nonce12[4:8]), u32(nonce12[8:12]),
    ]
    working = state[:]
    for _ in range(10):  # 20 rounds (double round)
        # column
        working[0], working[4], working[8], working[12]   = quarter_round(working[0], working[4], working[8], working[12])
        working[1], working[5], working[9], working[13]   = quarter_round(working[1], working[5], working[9], working[13])
        working[2], working[6], working[10], working[14]  = quarter_round(working[2], working[6], working[10], working[14])
        working[3], working[7], working[11], working[15]  = quarter_round(working[3], working[7], working[11], working[15])
        # diagonal
        working[0], working[5], working[10], working[15]  = quarter_round(working[0], working[5], working[10], working[15])
        working[1], working[6], working[11], working[12]  = quarter_round(working[1], working[6], working[11], working[12])
        working[2], working[7], working[8], working[13]   = quarter_round(working[2], working[7], working[8], working[13])
        working[3], working[4], working[9], working[14]   = quarter_round(working[3], working[4], working[9], working[14])
    out = [(working[i] + state[i]) & 0xffffffff for i in range(16)]
    return b"".join(struct.pack("<I", w) for w in out)
```

**간단 스트림 XOR**
```python
def chacha20_xor(key32, nonce12, counter0, msg: bytes) -> bytes:
    out = bytearray()
    counter = counter0
    i = 0
    while i < len(msg):
        ks = chacha20_block(key32, counter, nonce12)
        take = min(64, len(msg)-i)
        for j in range(take):
            out.append(msg[i+j] ^ ks[j])
        i += take
        counter = (counter + 1) & 0xffffffff
    return bytes(out)

# 데모(교육용): 실무는 RFC 8439 구현/라이브러리 사용

import os
key32 = os.urandom(32)
nonce12 = os.urandom(12)
pt = b"chacha20 demo payload"
ct = chacha20_xor(key32, nonce12, 1, pt)
pt2 = chacha20_xor(key32, nonce12, 1, ct)
assert pt2 == pt
```

### ChaCha20-Poly1305 (AEAD) 개념

- **ChaCha20**로 데이터와 **one-time key**(MAC 키 재료)를 만들고,
- **Poly1305**(정수 계수·모듈러 \(2^{130}-5\) 위 MAC)로 **무결성** 보장.
- AAD를 포함한 전체 레이아웃과 카운터/Nonce 규칙은 **RFC 8439**에 고정.

**표준 라이브러리 사용 예**
```python
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305
import os
key = ChaCha20Poly1305.generate_key()     # 32B
aead = ChaCha20Poly1305(key)
nonce = os.urandom(12)
aad = b"hdr:v1"
pt = b"payload"
ct = aead.encrypt(nonce, pt, aad)
pt2 = aead.decrypt(nonce, ct, aad)
print(pt2)
```

---

## ✅ 5.6 S-box/확산층을 수학으로 더 보기 (AES 관점 보충)

### \(\mathbb{F}_{2^8}\) 역원 + 아핀

- \(a \mapsto a^{-1}\)는 \(\mathbb{F}_{2^8}\)에서 **강한 비선형성**을 제공(0은 0).
- 그 위에 아핀 \(A(a)=Ma\oplus c\). \(M\)은 비가역이 아니어야 하며, 선형 구조를 “뒤섞는” 효과.

### MixColumns의 행렬 성질

- **브랜치 넘버**가 커서 **입력 바이트 하나의 변화**가 출력 4바이트에 빠르게 전파.
- 역변환은 다른 고정 행렬(InvMixColumns)로 정의되어 **가역**.

---

## ✅ 5.7 구현 보안(아주 중요)

1) **타이밍/캐시 누설**: 테이블 기반 S-box 루크업은 **캐시 패턴**이 키·데이터와 연동될 수 있음 →
   - 소프트웨어: **비테이블(비트슬라이스)**, 혹은 **하드웨어 AES-NI** 사용.
2) **고정 시간 비교**: 태그/해시 비교 시 `hmac.compare_digest`.
3) **키/Nonce 관리**: **Nonce 재사용 금지**(GCM/CTR/ChaCha20), 키 회전·수명 정의.
4) **패딩·모드**: CBC는 **패딩오라클** 등 취약 – 실무는 **AEAD**.
5) **무결성 선행 검증**: 복호·파싱 전에 **태그 검증**(AEAD는 자동).
6) **난수**: 키/Nonce/시드 생성은 **CSPRNG**(§4장 참고).

---

## ✅ 5.8 AES vs ChaCha20 — 선택 가이드(요약)

| 항목 | AES-GCM | ChaCha20-Poly1305 |
|---|---|---|
| 성능(데스크톱 x86) | **AES-NI/VAES**로 매우 빠름 | 빠르고 안정적, 하드웨어 가속 없이도 좋음 |
| 성능(모바일/임베디드) | 하드웨어 지원 없으면 느릴 수 | **일관되게 빠름** |
| 구현 난이도 | 하드웨어·테이블 선택에 주의 | ARX라 구현 단순(단, 직접 구현 금지 원칙 동일) |
| 보안 속성 | 성숙·광범위, GCM Nonce 충돌 주의 | 성숙·광범위, Nonce/카운터 관리 동일 |
| 표준/채택 | TLS/SSH/IPsec 등 | TLS/SSH/QUIC 등 |

> **요약**: 하드웨어 AES 가속이 있다면 AES-GCM이 최고 효율. 그 외 환경에서는 ChaCha20-Poly1305가 **가장 무난하고 안전**.

---

## ✅ 5.9 미니 실습: 같은 메시지, 두 AEAD

```python
# 동일 평문을 AES-GCM과 ChaCha20-Poly1305로

from cryptography.hazmat.primitives.ciphers.aead import AESGCM, ChaCha20Poly1305
import os
pt  = b"same payload on two AEADs"
aad = b"v=1"

# AES-GCM

k1 = AESGCM.generate_key(bit_length=256)
n1 = os.urandom(12)
c1 = AESGCM(k1).encrypt(n1, pt, aad)
print("AES-GCM ct+tag len:", len(c1))

# ChaCha20-Poly1305

k2 = ChaCha20Poly1305.generate_key()
n2 = os.urandom(12)
c2 = ChaCha20Poly1305(k2).encrypt(n2, pt, aad)
print("ChaCha20-Poly1305 ct+tag len:", len(c2))
```

- 두 스킴 모두 **무결성**이 포함되어 있어, 암호문 변조 시 복호 단계에서 **예외**가 발생.

---

## ✅ 5.10 체크리스트(요점 암기)

- [ ] 블록암호는 **가역 치환**을 키로 선택: 라운드 = **S-box(혼돈) + 확산층 + 키 혼합**
- [ ] **AES**: SubBytes(역원+아핀) / ShiftRows / MixColumns / AddRoundKey, 키스케줄 중요
- [ ] **하드웨어 가속** 이용(가능 시) — AES-NI/ARMv8 AES, GCM은 PCLMUL/PMULL
- [ ] **ChaCha20**: 16×32비트 상태, **쿼터라운드**(ARX), 20라운드, 스트림 XOR
- [ ] **AEAD** 우선: **AES-GCM** 또는 **ChaCha20-Poly1305**
- [ ] **Nonce 재사용 금지**, 키 수명·회전 정의, CSPRNG로 생성
- [ ] **직접 구현 금지** — 표준 라이브러리 사용 + 미스유스 테스트

---

## ✅ 5.11 연습문제

1) SPN에서 **S-box**와 **MixColumns**가 각각 어떤 공격(선형/차분)에 저항하도록 설계되는지 설명하라.
2) AES에서 마지막 라운드에 **MixColumns가 없는 이유**를 복호 구조 관점에서 서술하라.
3) ChaCha20의 **쿼터라운드**가 ARX 연산만으로도 충분한 혼돈·확산을 달성하는 이유를 직관적으로 설명하라.
4) AES-GCM과 ChaCha20-Poly1305의 **Nonce/카운터** 재사용 시 어떤 정보 누설이 발생하는지 비교하라.
5) 하드웨어 AES 가속이 없는 모바일 환경에서 ChaCha20-Poly1305가 선호되는 이유를 성능·보안 측면에서 정리하라.
