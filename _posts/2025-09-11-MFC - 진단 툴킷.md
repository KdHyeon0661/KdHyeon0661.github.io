---
layout: post
title: MFC - 진단 툴킷
date: 2025-09-11 14:25:23 +0900
category: MFC
---
# 진단 툴킷: TRACE/ASSERT, 핸들·GDI 리소스 추적, 성능 카운터 (MFC/Win32 완전 정리)

이 글은 **MFC/Win32** 애플리케이션에서 현장을 버티는 **진단(Diagnostics) 무기 세트**를 한 번에 정리합니다.  
**로그(TRACE/ATLTRACE/OutputDebugString) → 단언(ASSERT/VERIFY/ENSURE) → CRT 디버그 힙/누수 → 핸들·GDI 리소스 추적 → 성능 카운터(QPC/PDH/ETW)** 까지 **예제 가득** 담았습니다.

> 포커스: **실제 현장 디버깅**에 즉시 가져다 쓸 수 있는 코드/패턴.  
> 전제: Visual C++(x64), Unicode, /MD, MFC(또는 ATL).

---

## 0) 큰 그림(요약)

- **로그**: `TRACE`, `ATLTRACE`, `OutputDebugString`로 **가벼운 실시간 진단**. 카테고리/레벨/스레드ID 포함 권장.  
- **단언**: `ASSERT/VERIFY/ENSURE/_ASSERTE`로 **불변식/계약**을 코드로 고정.  
- **CRT 디버그 힙**: `DEBUG_NEW`, `_CrtSetDbgFlag`, `_CrtDumpMemoryLeaks()`로 **메모리 누수**를 막는다.  
- **핸들/GDI 추적**: `GetProcessHandleCount`, `GetGuiResources` + **RAII** + 선택적 **백트레이스 기록**.  
- **성능 카운터**: `QueryPerformanceCounter`(QPC)로 **마이크로초 단위 측정**, `PDH`로 **시스템 카운터**, `ETW`로 **저오버헤드 추적**.  
- **덤프/예외**: `SetUnhandledExceptionFilter + MiniDumpWriteDump`로 **현장 덤프** 확보(선택).

---

## 1) 로그: TRACE/ATLTRACE/OutputDebugString

### 1-1. 가장 빠른 진단: `TRACE` (MFC)
- **Debug 빌드에서만 출력**, Release에서는 제거(오버헤드 0에 가까움).
- 내부적으로 `afxTraceEnabled`가 켜져 있고, `OutputDebugStringW`로 전달.

```cpp
// 기본 사용
TRACE(L"Loaded file: %s (size=%d)\n", path, size);

// 범위 트레이스
TRACE(L"[Init] App starting… pid=%u tid=%u\n", GetCurrentProcessId(), GetCurrentThreadId());
```

### 1-2. ATL/비 MFC에서도: `ATLTRACE` / `ATLTRACE2`
```cpp
#include <atltrace.h>

ATLTRACE(L"[ComInit] CoInitializeEx ok (thread=%u)\n", GetCurrentThreadId());
ATLTRACE2(atlTraceGeneral, 0, L"Message: %s\n", msg);
```

### 1-3. 어디서나 되는 기본기: `OutputDebugString`
```cpp
void LogLine(LPCWSTR tag, LPCWSTR fmt, ...) {
    WCHAR buf[1024];
    va_list ap; va_start(ap, fmt);
    _vsnwprintf_s(buf, _TRUNCATE, fmt, ap);
    va_end(ap);

    WCHAR line[1200];
    _snwprintf_s(line, _TRUNCATE, L"[%s][%05u] %s\n", tag, GetCurrentThreadId(), buf);
    OutputDebugStringW(line);
}
```
> **팁**  
> - **스레드ID**·**타임스탬프** 포함 권장(병행 문제 추적용).  
> - DebugView(시스인터널즈) 등에서 **실시간** 확인 가능.

### 1-4. 카테고리/레벨 매크로(경량 로거)
```cpp
enum class LogLevel { Error=0, Warn=1, Info=2, Verbose=3 };

#ifndef NDEBUG
static std::atomic<LogLevel> g_logLevel{ LogLevel::Verbose };
#define LOG_IF(lv, fmt, ...) \
    do{ if ((int)(lv) <= (int)g_logLevel.load()) \
        OutputDebugStringW((CStringW().Format(L"[%S][%u] " fmt L"\n", \
        __FUNCTION__, GetCurrentThreadId(), __VA_ARGS__), (LPCWSTR)CStringW())); }while(0)
#else
#define LOG_IF(...) do{}while(0)
#endif

// 사용
LOG_IF(LogLevel::Info, L"opening '%s'", L"C:\\data\\a.bin");
```

---

## 2) 단언: ASSERT/VERIFY/ENSURE/_ASSERTE

### 2-1. 핵심 차이
- `ASSERT(expr)`: **Debug**에서만 체크. 실패 시 중단/콜스택. Release에서는 제거.  
- `VERIFY(expr)`: Debug에서는 `ASSERT`와 동일 + **Release에서도 expr 평가**(부수효과 보존).  
- `ENSURE(expr)`: 실패 시 **예외를 던지거나**(MFC 설정), 메시지 박스 후 리턴하도록 구현하는 패턴에 쓰기도.  
- `_ASSERTE(expr)`: CRT 단언(헤더 `<crtdbg.h>`). `ASSERT`와 유사.

```cpp
ASSERT(pWnd != nullptr);
VERIFY(::SetWindowTextW(hWnd, L"Ready")); // 실패 시 Release에서도 SetWindowText는 호출됨
```

### 2-2. MFC 객체 검증: `ASSERT_VALID`, `IsKindOf`
```cpp
void Foo(CObject* p) {
    ASSERT_VALID(p);                      // m_pfnDump 등 유효성 검사
    ASSERT(p->IsKindOf(RUNTIME_CLASS(CDocument)));
}
```

### 2-3. 계약 고정(전/후조건) 예시
```cpp
void ProcessBuffer(BYTE* p, size_t len) {
    ASSERT(p && len>0);
    // … 작업 …
    ASSERT(m_state == kProcessed); // 후조건(불변 확인)
}
```

---

## 3) CRT 디버그 힙: 메모리 누수/오버런 잡기

### 3-1. 기본 세팅
```cpp
#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
#define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)
#define new DEBUG_NEW
#endif
```

### 3-2. 힙 플래그/누수 덤프
```cpp
#ifdef _DEBUG
int EnableCrtDbg() {
    int flags = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
    flags |= _CRTDBG_ALLOC_MEM_DF;    // 할당 추적
    flags |= _CRTDBG_LEAK_CHECK_DF;   // 종료 시 누수 자동 덤프
    return _CrtSetDbgFlag(flags);
}
#endif

// App 시작 시 호출
BOOL CMyApp::InitInstance() {
#ifdef _DEBUG
    EnableCrtDbg();
#endif
    // ...
    return TRUE;
}
```

### 3-3. 누수 예시/출력 해석
```cpp
void Leak() {
    auto p = new BYTE[1024]; // delete 누락
}
```
- 종료 시 디버그 출력:
```
Detected memory leaks!
Dumping objects ->
{1234} normal block at 0x000001E3F4..., 1024 bytes long.
   Data: <....> ...
```
→ **블록 번호(1234)** 로 `_CrtSetBreakAlloc(1234);` 설정 후 **그 지점에서 브레이크**.

### 3-4. 힙 검사/경계 위반
```cpp
ASSERT(_CrtCheckMemory()); // 실패시 중단(메모리 손상)
```

> **실무 팁**  
> - **서드파티 라이브러리**가 다른 CRT를 쓴다면 누수 출력이 섞일 수 있음.  
> - 대용량/다중스레드 앱은 **샘플링 로그**로 줄이거나, **릴리즈에서도 ETW 메모리 이벤트** 고려.

---

## 4) 핸들/리소스 추적(Handle, GDI, USER)

### 4-1. 총 핸들 수/메모리 지표 빠르게 보기
```cpp
DWORD GetHandleCountFast() {
    DWORD count = 0;
    GetProcessHandleCount(GetCurrentProcess(), &count);
    return count;
}

void DumpProcessMemory() {
    PROCESS_MEMORY_COUNTERS_EX pmc{};
    if (GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*)&pmc, sizeof(pmc))) {
        TRACE(L"[Mem] WS=%zuKB, Private=%zuKB, Pagefile=%zuKB\n",
            pmc.WorkingSetSize/1024, pmc.PrivateUsage/1024, pmc.PagefileUsage/1024);
    }
}
```

### 4-2. GDI/USER 카운터(리소스 누수 탐지)
```cpp
#include <winuser.h> // GetGuiResources
DWORD gdiCount = GetGuiResources(GetCurrentProcess(), GR_GDIOBJECTS);
DWORD usrCount = GetGuiResources(GetCurrentProcess(), GR_USEROBJECTS);
TRACE(L"[GUI] GDI=%u USER=%u\n", gdiCount, usrCount);
```
- **GDI**: `HFONT/HPEN/HBRUSH/HBITMAP/HPALETTE/HRGN` 등  
- **USER**: `HWND/HMENU/HACCEL/HOOK 등`

> **경향 관찰**: 화면을 열고 닫을 때 **GDI/USER가 원복**되어야 정상. 지속 증가 = 누수.

### 4-3. GDI 자원 올바른 사용 패턴(선택/원복/해제)
```cpp
void Paint(HDC hdc) {
    HBRUSH hbr = CreateSolidBrush(RGB(240,240,240));
    HBRUSH hOld = (HBRUSH)SelectObject(hdc, hbr);
    RECT rc; GetClientRect(hwnd, &rc);
    FillRect(hdc, &rc, hbr);
    SelectObject(hdc, hOld);
    DeleteObject(hbr); // 누수 방지
}
```
- **규칙**: `SelectObject`로 바꾼 건 반드시 **이전 객체로 복원** 후 **삭제**.  
- `SaveDC/RestoreDC`로 전체 상태를 **스택처럼 관리**하면 안전.

```cpp
int s = SaveDC(hdc);
// … 폰트/펜/브러시 변경, 맵모드 변경 …
RestoreDC(hdc, s); // 모든 상태 복원
```

### 4-4. RAII 핸들 래퍼(누수/예외 안전)
```cpp
template<class H, class Deleter>
class unique_handle {
    H h{ nullptr };
public:
    unique_handle()=default;
    explicit unique_handle(H v):h(v){}
    ~unique_handle(){ reset(); }
    H get()const{ return h; }
    H release(){ H t=h; h=nullptr; return t; }
    void reset(H v=nullptr){ if(h && h!=INVALID_HANDLE_VALUE) Deleter{}(h); h=v; }
    operator bool()const{ return h && h!=INVALID_HANDLE_VALUE; }
};

struct close_handle { void operator()(HANDLE h){ CloseHandle(h); } };
struct delete_gdi   { void operator()(HGDIOBJ h){ DeleteObject(h); } };

using unique_hfile = unique_handle<HANDLE, close_handle>;
using unique_hgdi  = unique_handle<HGDIOBJ, delete_gdi>;

// 사용
unique_hgdi hb(CreateSolidBrush(RGB(0,0,0)));
```

### 4-5. “누가 안 지웠나?” — 간단 백트레이스 기록(디버그만)
```cpp
struct GdiTrack {
    HGDIOBJ h{};
    USHORT  frames{};
    void*   stack[16]{};
};
static std::mutex g_mx;
static std::unordered_map<HGDIOBJ, GdiTrack> g_map;

HBRUSH TrackedCreateBrush(COLORREF c) {
    HBRUSH h = CreateSolidBrush(c);
#ifndef NDEBUG
    if (h) {
        GdiTrack t; t.h = h;
        t.frames = RtlCaptureStackBackTrace(1, 16, t.stack, nullptr); // <exc api> ntdll
        std::lock_guard<std::mutex> lk(g_mx);
        g_map[h] = t;
    }
#endif
    return h;
}

void TrackedDelete(HGDIOBJ h) {
#ifndef NDEBUG
    std::lock_guard<std::mutex> lk(g_mx);
    g_map.erase(h);
#endif
    DeleteObject(h);
}

void DumpGdiLeaks() {
#ifndef NDEBUG
    std::lock_guard<std::mutex> lk(g_mx);
    for (auto& [h,t] : g_map) {
        TRACE(L"[GDI-LEAK] %p frames=%u\n", h, t.frames);
        for (USHORT i=0;i<t.frames;i++) TRACE(L"  #%u: %p\n", i, t.stack[i]);
    }
#endif
}
```
> **아이디어**: 종료 시 `DumpGdiLeaks()` 호출 → 어디서 만들었는지 스택으로 추정.

---

## 5) 성능 카운터: QPC/스톱워치, 스레드 시간, PDH, ETW

### 5-1. 마이크로초 측정: QPC 스톱워치
```cpp
class Stopwatch {
    LARGE_INTEGER f{}, s{}, e{};
public:
    Stopwatch(){ QueryPerformanceFrequency(&f); }
    void start(){ QueryPerformanceCounter(&s); }
    double stop_us(){ QueryPerformanceCounter(&e); return (e.QuadPart - s.QuadPart) * 1e6 / f.QuadPart; }
};

// 사용
Stopwatch sw; sw.start();
// … 작업 …
TRACE(L"[Perf] stepA=%.3f ms\n", sw.stop_us()/1000.0);
```
> **주의**: QPC는 **HPET/TSC 동기화** 이후 매우 안정적. `Sleep(1)` 과 섞일 땐 `timeBeginPeriod(1)`(Win10 2004+는 시스템 전역 영향) 남용 금지.

### 5-2. 스레드/프로세스 CPU 시간
```cpp
double ThreadCpuMs() {
    FILETIME c, e, k, u;
    GetThreadTimes(GetCurrentThread(), &c,&e,&k,&u);
    ULARGE_INTEGER uu; uu.LowPart=u.dwLowDateTime; uu.HighPart=u.dwHighDateTime;
    return uu.QuadPart / 10000.0; // 100ns 단위 → ms
}
```

### 5-3. 사이클 카운트(정밀, 플랫폼 의존)
```cpp
ULONG64 cycles=0; QueryThreadCycleTime(GetCurrentThread(), &cycles);
```
> 로직 비교/루프 미세비용 비교에 유용(상대값). **절대시간 아님**.

### 5-4. PDH: 시스템 퍼포먼스 카운터 읽기
- 예: 현재 프로세스의 `% Processor Time`, Working Set, Disk Queue 등

```cpp
#include <pdh.h>
#pragma comment(lib, "pdh.lib")

class PdhProbe {
    PDH_HQUERY q{};
    PDH_HCOUNTER cpu{};
public:
    bool init() {
        if (PdhOpenQuery(nullptr, 0, &q)!=ERROR_SUCCESS) return false;
        // 예: 전체 CPU 사용률
        return PdhAddCounter(q, L"\\Processor(_Total)\\% Processor Time", 0, &cpu)==ERROR_SUCCESS;
    }
    double sample() {
        PdhCollectQueryData(q);
        PDH_FMT_COUNTERVALUE v{};
        PdhGetFormattedCounterValue(cpu, PDH_FMT_DOUBLE, nullptr, &v);
        return v.doubleValue; // %
    }
    ~PdhProbe(){ if(q) PdhCloseQuery(q); }
};
```

### 5-5. ETW(추적 이벤트) – 초저오버헤드(개념/스니펫)
- **TraceLoggingProvider**(간편), 또는 **EventRegister** API.  
- 장점: Release에서도 **낮은 오버헤드**로 고해상도 이벤트/구간 측정.

```cpp
// TraceLoggingProvider.h 필요 (Windows SDK)
TRACELOGGING_DECLARE_PROVIDER(g_Prov);

void InitEtw() {
    TraceLoggingRegister(g_Prov);
}
void FiniEtw() {
    TraceLoggingUnregister(g_Prov);
}
void EtwStep(const wchar_t* name, double ms) {
    TraceLoggingWrite(g_Prov, "Step",
        TraceLoggingWideString(name, "name"),
        TraceLoggingFloat64(ms, "ms"));
}
```

---

## 6) 페인트/스크롤 등 핫스팟 성능 가시화(현장 팁)

- **구간 마킹**: 그리기 시작/끝에 QPC 로그.
```cpp
#define SCOPE_TIMER_MS(tag) \
    struct _Scope_##__LINE__ { Stopwatch sw; const wchar_t* t; _Scope_##__LINE__():t(tag){sw.start();} ~_Scope_##__LINE__(){TRACE(L"[Perf] %s=%.3fms\n",t,sw.stop_us()/1000.0);} } _scope_##__LINE__;

// 사용
void CMyView::OnPaint() {
    CPaintDC dc(this);
    SCOPE_TIMER_MS(L"OnPaint");
    // … 그리기 …
}
```
- **프레임 타임 히스토리**: 최근 120프레임 평균/최대 기록 → 버벅임 감지.

---

## 7) 미니덤프(현장 포렌식) — 선택 기능

```cpp
#include <DbgHelp.h>
#pragma comment(lib, "Dbghelp.lib")

LONG WINAPI MyUnhandledFilter(EXCEPTION_POINTERS* p) {
    WCHAR path[MAX_PATH]; GetTempFileNameW(L"C:\\Temp", L"dump", 0, path);
    HANDLE h = CreateFileW(path, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (h != INVALID_HANDLE_VALUE) {
        MINIDUMP_EXCEPTION_INFORMATION ex{ GetCurrentThreadId(), p, FALSE };
        MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), h, MiniDumpWithFullMemory, &ex, nullptr, nullptr);
        CloseHandle(h);
    }
    return EXCEPTION_EXECUTE_HANDLER;
}

BOOL CMyApp::InitInstance() {
    SetUnhandledExceptionFilter(MyUnhandledFilter);
    // …
    return TRUE;
}
```

---

## 8) 종합 진단 패널(샘플 UI 코드 조각)

```cpp
class CDiagPane : public CDialogEx {
    CListCtrl m_log;
    UINT_PTR  m_timer{};
public:
    BOOL OnInitDialog() override {
        CDialogEx::OnInitDialog();
        m_log.InsertColumn(0, L"Time", LVCFMT_LEFT, 120);
        m_log.InsertColumn(1, L"Msg",  LVCFMT_LEFT, 400);
        m_timer = SetTimer(1, 1000, nullptr);
        return TRUE;
    }
    afx_msg void OnTimer(UINT_PTR) {
        // 1초마다 GDI/USER/핸들/메모리/CPU 샘플링
        DWORD gdi = GetGuiResources(GetCurrentProcess(), GR_GDIOBJECTS);
        DWORD usr = GetGuiResources(GetCurrentProcess(), GR_USEROBJECTS);
        DWORD hdl = 0; GetProcessHandleCount(GetCurrentProcess(), &hdl);
        PROCESS_MEMORY_COUNTERS_EX pmc{};
        GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*)&pmc, sizeof(pmc));
        CString msg; msg.Format(L"GDI=%u USER=%u Handles=%u WS=%.1fMB Private=%.1fMB",
            gdi, usr, hdl, pmc.WorkingSetSize/1048576.0, pmc.PrivateUsage/1048576.0);
        int row = m_log.InsertItem(m_log.GetItemCount(), CTime::GetCurrentTime().Format(L"%H:%M:%S"));
        m_log.SetItemText(row, 1, msg);
    }
    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CDiagPane, CDialogEx)
    ON_WM_TIMER()
END_MESSAGE_MAP()
```
> **현장 효용**: 고객 PC에서 **숫자만으로 누수/증가 추세**를 파악 가능.

---

## 9) 체크리스트(현장용)

- **로그**  
  - [ ] `TRACE/ATLTRACE`로 **핵심 경로**에 로그 박기(스레드ID/태그 포함)  
  - [ ] Release 빌드도 켤 수 있는 **경량 OutputDebugString 로거**(레벨 제어)

- **단언**  
  - [ ] `ASSERT/VERIFY`로 **불변식** 명시  
  - [ ] 포인터/인덱스/핸들/HR 체크, `ASSERT_VALID` 활용

- **메모리**  
  - [ ] `_CRTDBG_MAP_ALLOC` + `DEBUG_NEW` + `_CrtDumpMemoryLeaks()`  
  - [ ] 종료 전 `_CrtCheckMemory()`  
  - [ ] 블록 번호로 `_CrtSetBreakAlloc(n)` 브레이크

- **핸들/GDI**  
  - [ ] `GetProcessHandleCount`, `GetGuiResources` 주기 샘플링  
  - [ ] GDI 선택/원복/삭제 규칙 준수, `SaveDC/RestoreDC`  
  - [ ] RAII 핸들 래퍼 사용  
  - [ ] (선택) **백트레이스 기반 GDI 추적** 삽입

- **성능**  
  - [ ] QPC 스톱워치/스코프 타이머 도입  
  - [ ] PDH로 전체 CPU/메모리/디스크 카운터 읽기  
  - [ ] (선택) ETW TraceLoggingProvider로 저오버헤드 이벤트

- **예외/덤프**  
  - [ ] `SetUnhandledExceptionFilter + MiniDumpWriteDump`(선택)  
  - [ ] 덤프와 로그 파일 **경로 정책**(개인정보/권한) 수립

---

## 10) 부록: 한 화면 스타터(복붙용)

```cpp
// 1) 로그 매크로
#ifndef NDEBUG
#define DBGLOG(fmt, ...) do{ WCHAR _b[1024]; _snwprintf_s(_b,_TRUNCATE,L"[T%05u] " fmt L"\n",GetCurrentThreadId(),__VA_ARGS__); OutputDebugStringW(_b);}while(0)
#else
#define DBGLOG(...) do{}while(0)
#endif

// 2) QPC 스코프 타이머
struct ScopeMs { LARGE_INTEGER f,s; const wchar_t* t;
    ScopeMs(const wchar_t* tag):t(tag){ QueryPerformanceFrequency(&f); QueryPerformanceCounter(&s); }
    ~ScopeMs(){ LARGE_INTEGER e; QueryPerformanceCounter(&e);
        double ms=(e.QuadPart-s.QuadPart)*1000.0/f.QuadPart; DBGLOG(L"[perf] %s=%.3fms", t, ms); }
};

// 3) CRT 디버그 힙
#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
#define DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__)
#define new DEBUG_NEW
static int _init_crt_flags(){ int f=_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG); f|=_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF; return _CrtSetDbgFlag(f);} static int _dummy=_init_crt_flags();
#endif

// 4) GDI/USER/핸들 샘플링 함수
inline void DumpGui() {
    DWORD gdi=GetGuiResources(GetCurrentProcess(),GR_GDIOBJECTS);
    DWORD usr=GetGuiResources(GetCurrentProcess(),GR_USEROBJECTS);
    DWORD hc=0; GetProcessHandleCount(GetCurrentProcess(), &hc);
    DBGLOG(L"[gui] GDI=%u USER=%u Handles=%u", gdi, usr, hc);
}
```

---

### 마무리

**진단 글루**는 기능 그 자체만큼 중요합니다.  
여기 있는 **로그·단언·누수·핸들·성능** 툴킷을 **프로젝트 템플릿**에 박아두면,  
현장 이슈가 생겨도 **빠르게 재현/계측/원인 격리**가 가능합니다.