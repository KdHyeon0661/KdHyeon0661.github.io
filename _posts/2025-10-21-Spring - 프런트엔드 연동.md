---
layout: post
title: Spring - 프런트엔드 연동
date: 2025-10-21 23:25:23 +0900
category: Spring
---
# 연동, SSR·엣지 캐시·프리패치 전략

> 목표: **브라우저 ↔ 백엔드** 연동의 기초부터 운영 실전까지 한 번에 정리한다.
> 범위: **CORS/쿠키/세션/CSRF** 보안 베이직, **SPA(React/Vue/Svelte)** 와의 HTTP 연동 패턴, **SSR/엣지 캐시/프리패치** 전략.
> 기준: Spring Boot 3.3+/Spring Security 6, Java 21, 프런트는 최신 React/Vue/SvelteKit 가정.

---

## A. CORS/쿠키/세션/CSRF 정리

### A-1. CORS 핵심 요약

- **Preflight(OPTIONS)**: `Access-Control-Request-Method/Headers` → 서버가 `Access-Control-Allow-*`로 승인.
- **크레덴셜(쿠키/HTTP 인증/클라이언트 인증서)** 포함 요청은:
  - 클라이언트: `fetch(..., { credentials: "include" })`
  - 서버: `Access-Control-Allow-Credentials: true` + **정확한 Origin 값**(와일드카드 `*` 금지).
- 캐시: 브라우저는 **preflight**도 캐시한다 → `Access-Control-Max-Age` 설정.

**Spring(WebMVC) 전역 CORS 예**
```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
  @Override public void addCorsMappings(CorsRegistry r) {
    r.addMapping("/**")
     .allowedOrigins("https://app.example.com")   // * 금지(자격증명 허용 시)
     .allowedMethods("GET","POST","PUT","PATCH","DELETE","OPTIONS")
     .allowedHeaders("*")
     .exposedHeaders("Location","Content-Disposition","X-Trace-Id","ETag")
     .allowCredentials(true)
     .maxAge(3600);
  }
}
```

**Gateway(Global CORS)**
```yaml
spring:
  cloud:
    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOrigins: "https://app.example.com"
            allowedMethods: "*"
            allowedHeaders: "*"
            exposedHeaders:
              - Location
              - Content-Disposition
              - X-Trace-Id
            allowCredentials: true
            maxAge: 3600
```

### A-2. 쿠키 & 세션 운영 포인트

- **보안 플래그**: `Secure`(HTTPS 필수), `HttpOnly`(JS 접근 금지), `SameSite`(Lax/Strict/None).
  - **SPA + 서브도메인**(app.example.com ↔ api.example.com) 에 **크로스 사이트 쿠키** 필요: `SameSite=None; Secure`.
  - SSO/OAuth 코드를 쿠키로 유지하거나 **세션 기반**이면 위 설정이 필수.
- **도메인 범위**: `.example.com`(서브도메인 공유) 또는 정확한 호스트 지정.
- **세션 저장소**: Spring Session(Redis) 권장.
- **타임아웃**: 앱 보안정책에 따라 `30m`~`2h`, Remember-me는 별도 쿠키로 장기.

**Spring Security(세션) 설정**
```java
@EnableWebSecurity
@Configuration
public class SecurityConfig {
  @Bean
  SecurityFilterChain chain(HttpSecurity http) throws Exception {
    http
      .csrf(csrf -> csrf.disable())     // 세션+폼로그인이면 활성, SPA 쿠키-토큰 패턴이면 별도 처리(아래)
      .cors(Customizer.withDefaults())
      .sessionManagement(s -> s
        .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED))
      .authorizeHttpRequests( auth -> auth
        .requestMatchers("/auth/**","/actuator/**").permitAll()
        .anyRequest().authenticated())
      .formLogin(login -> login.loginProcessingUrl("/auth/login"))
      .rememberMe(r -> r
        .rememberMeParameter("remember")
        .tokenValiditySeconds((int)Duration.ofDays(14).getSeconds()))
      ;
    return http.build();
  }
}
```

**쿠키 발행 예(로그인 성공 시)**
```java
ResponseCookie session = ResponseCookie.from("SESSION", sessionId)
  .httpOnly(true).secure(true).sameSite("None")
  .domain(".example.com").path("/")
  .maxAge(Duration.ofHours(2)).build();
response.addHeader(HttpHeaders.SET_COOKIE, session.toString());
```

### A-3. CSRF(크로스 사이트 요청 위조)

- 서버가 **쿠키 기반 인증**을 쓸 때 **반드시** 방어.
- 일반 패턴 3가지
  1) **Synchronizer Token**: 서버가 세션과 매칭되는 토큰 발급 → 헤더/폼필드로 제출.
  2) **Double Submit Cookie**: JS가 **`XSRF-TOKEN` 쿠키** 값을 읽어 `X-XSRF-TOKEN` 헤더로 전송. 서버는 **쿠키 값 == 헤더 값** 검증.
  3) **SameSite=Lax/Strict**: 크로스사이트 쿠키 차단(단, `GET`/`HEAD`는 허용, 완전 방어 아님).

**Spring Security: SPA용 CSRF(Double Submit)**
```java
http
  .csrf(csrf -> csrf
    .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) // JS가 읽을 수 있어야 함
  );
```
서버는 `/` GET 시 `XSRF-TOKEN` 쿠키를 발행. 프런트는 이후 요청 헤더 `X-XSRF-TOKEN`에 담아 전송.

**Axios 예(자동 처리)**
```ts
import axios from "axios";
export const api = axios.create({
  baseURL: "https://api.example.com",
  withCredentials: true,              // 쿠키 포함
  xsrfCookieName: "XSRF-TOKEN",       // Spring 기본
  xsrfHeaderName: "X-XSRF-TOKEN",
});
```

> **JWT(Authorization 헤더) + 쿠키 없음**(Stateless) 구성이라면 **CSRF 대상이 아님**. 단, 토큰 저장 위치(XSS 위험)가 핵심(로컬스토리지 금지 권장 → httpOnly 쿠키+헤더 추가 발행 조합 or in-memory + Refresh 쿠키).

---

## B. SPA와 백엔드 연동(React/Vue/Svelte)

### B-1. 공통 HTTP 클라이언트 설계

- **기본 설정**: `baseURL`, `withCredentials`, 타임아웃, 리트라이(X).
- **인터셉터**: 401 → 리프레시/재로그인, 트레이스ID 표시, 표준 에러모델 매핑.
- **취소 토큰**: 빠른 네비게이션에서 이전 요청 취소.

**Axios 공통 래퍼**
```ts
import axios, { AxiosError } from "axios";

export const api = axios.create({
  baseURL: import.meta.env.VITE_API_BASE || "https://api.example.com",
  withCredentials: true,
  timeout: 7000,
});

api.interceptors.response.use(
  r => r,
  (err: AxiosError<any>) => {
    const traceId = err.response?.headers?.["x-trace-id"];
    const data = err.response?.data; // ApiResponse 규격 가정
    const code = data?.error?.code ?? "UNKNOWN";
    const message = data?.error?.message ?? err.message;
    // 전역 알림/토스트
    console.error(`[${traceId}] ${code} ${message}`);
    if (err.response?.status === 401) {
      // 토큰 갱신 or 로그인으로 리다이렉트
    }
    return Promise.reject(err);
  }
);
```

**fetch 버전(기본)**
```ts
export async function http<T>(path: string, init: RequestInit = {}): Promise<T> {
  const res = await fetch(`${API}${path}`, {
    credentials: "include",
    headers: { "Content-Type": "application/json", ...(init.headers || {}) },
    ...init,
  });
  if (!res.ok) {
    const traceId = res.headers.get("x-trace-id");
    const err = await res.json().catch(() => ({}));
    throw new Error(`[${traceId}] ${err?.error?.message ?? res.statusText}`);
  }
  return res.json();
}
```

### B-2. 인증 패턴(실무 2파전)

#### **세션/쿠키 기반(서버 상태ful)**

- 장점: 토큰 보관 문제 해결, CSRF만 잘 처리하면 안전.
- 단점: 서버 확장 시 세션 저장 필요(Spring Session/Redis), 모바일/공용 API에서 불편.

#### **액세스 토큰(헤더) + 리프레시 토큰(쿠키)**

- 액세스 토큰: **메모리**에만 보관(페이지 리프레시 시 사라짐).
- 리프레시 토큰: **HttpOnly + SameSite=Strict/None** 쿠키.
- 401 시 **/auth/refresh**로 새 액세스 토큰 발급. 서버는 리프레시 토큰 회전·블랙리스트 관리.

**React 상태 예**
```ts
const auth = {
  token: "", // in-memory only
  set(t: string) { this.token = t; },
  clear() { this.token = ""; }
};

api.interceptors.request.use(cfg => {
  if (auth.token) cfg.headers.Authorization = `Bearer ${auth.token}`;
  return cfg;
});
```

**Spring Security(리소스 서버)**
```java
http
  .csrf(AbstractHttpConfigurer::disable)        // 헤더 토큰 기반이면 비활성
  .oauth2ResourceServer(o -> o.jwt(Customizer.withDefaults())); // jwk-set-uri 또는 issuer 설정
```

### B-3. 파일 업로드/다운로드

**업로드(프로그레스)**
```ts
const form = new FormData();
form.append("file", file);
await api.post("/files", form, {
  headers: { "Content-Type": "multipart/form-data" },
  onUploadProgress: e => setProgress(Math.round(100 * e.loaded / (e.total || 1)))
});
```

**다운로드(이름/대용량)**
```ts
const res = await api.get("/reports/123", { responseType: "blob" });
// 서버: Content-Disposition: attachment; filename="report.csv"
const blob = new Blob([res.data]);
const url = URL.createObjectURL(blob);
const a = document.createElement("a");
a.href = url; a.download = getFileName(res.headers["content-disposition"]);
a.click(); URL.revokeObjectURL(url);
```

**서버(CORS exposed header)**
```yaml
exposedHeaders: [ "Content-Disposition", "X-Trace-Id" ]
```

### B-4. 폼·검증·오류 모델

- **Bean Validation** → 표준 에러(`ApiResponse.error`)로 내려주고,
- 프런트는 필드 맵핑:
```ts
catch (e) {
  const fields = e.response?.data?.error?.data?.fields;
  setErrors(fields); // {email: "이메일 형식이 아님"}
}
```

### B-5. 실시간: SSE/WebSocket

- CORS에서 `Cache-Control: no-transform`(중간변환 방지), `Content-Type: text/event-stream`.
- **SSE**: 재연결·백프레셔 쉬움(서버 이벤트), 양방향 필요시 **WebSocket**.

---

## C. React/Vue/Svelte 연동 스니펫

### C-1. React Router(Dynamic Route + 데이터 패칭)

```tsx
// App.tsx
<BrowserRouter>
  <Routes>
    <Route path="/" element={<Home/>} />
    <Route path="/orders" element={<Orders/>} />
    <Route path="/orders/:id" element={<OrderDetail/>} />
  </Routes>
</BrowserRouter>

// OrderDetail.tsx
const { id } = useParams();
const { data, error, isLoading } = useSWR(`/orders/${id}`, (url)=> api.get(url).then(r=>r.data));
```

### C-2. Vue(axios + Pinia)

```ts
// store/auth.ts
export const useAuth = defineStore("auth",{
  state: ()=>({ token: "" }),
  actions: { set(t:string){ this.token = t; } }
});

// main.ts
api.interceptors.request.use(cfg => {
  const { token } = useAuth(); if (token) cfg.headers.Authorization = `Bearer ${token}`;
  return cfg;
});
```

### C-3. SvelteKit(load + form actions)

```ts
// +page.ts
export const load = async ({ fetch, params }) => {
  const res = await fetch(`/api/orders/${params.id}`, { credentials: "include" });
  return { order: await res.json() };
};

// +page.server.ts (프록시/서버 사이드 호출 권장)
export const actions = {
  create: async ({ request, cookies, fetch }) => {
    const fd = await request.formData();
    const res = await fetch("https://api.example.com/orders", {
      method: "POST",
      body: fd,
      headers: { "Cookie": cookies.toString() },
    });
    return { ok: res.ok };
  }
}
```

---

## D. SSR/엣지 캐시/프리패치 전략

### D-1. 왜 SSR/엣지인가?

- **TTFB 개선**(서버에서 HTML 생성), **SEO**, **초기 데이터 프리렌더**.
- 엣지(Cloudflare/Netlify/Vercel/NGINX+CDN)에서 **지리적으로 가까운 캐시/실행** 제공.

### D-2. SSR 프레임워크 × 백엔드 연동

#### Next.js(React)

- **서버 액션/라우트 핸들러** 또는 **getServerSideProps/Server Components**에서 백엔드 호출.
- **쿠키 전달**: 서버 컴포넌트는 **백엔드와 같은 오리진 쿠키**를 헤더로 전달해야 함.

```ts
// Next route handler /app/api/proxy/orders/[id]/route.ts
export async function GET(_req: Request, { params }: { params: { id: string } }) {
  const api = `${process.env.API}/orders/${params.id}`;
  const res = await fetch(api, { headers: { Cookie: headers().get("cookie") || "" }});
  return new Response(res.body, { status: res.status, headers: { "Content-Type": "application/json" }});
}
```

- **캐싱**: `revalidate`(ISR), `fetch(..., { next: { revalidate: 60 }})`, `cache: "force-cache"`/`no-store`.
- **엣지 런타임**: `export const runtime = 'edge'` + 제한된 Node API.

#### Nuxt(Nuxt 3)

- **server/api/** 에서 Nitro 서버로 백엔드 프록시 → 쿠키 안전 전달.
- `isr: 60`으로 페이지 ISR.

#### SvelteKit

- `+page.server.ts`에서 백엔드 호출(서버 세션 접근).
- **Prerender/CSR 혼합**: `export const prerender = true;` + 클라이언트 하이드레이션.

### D-3. CDN/엣지 캐시 헤더 설계

- 정적: `Cache-Control: public, max-age=31536000, immutable`.
- SSR(유저별 아님): `public, s-maxage=60, stale-while-revalidate=30`.
- 유저별(쿠키/권한 의존): **캐시 금지** 또는 **Key 분리**(권한/테넌트별).
- **Vary 헤더**: `Vary: Accept-Encoding, Accept-Language, Authorization?`
  - Authorization에 따라 **캐시 키 폭증** → **프록시 계층에서 프라이빗 캐싱** 또는 **캐시 제외**.

**스프링 컨트롤러 캐시 예**
```java
@GetMapping("/catalog")
public ResponseEntity<List<Item>> catalog(){
  return ResponseEntity.ok()
      .cacheControl(CacheControl.maxAge(Duration.ofMinutes(1)).staleWhileRevalidate(Duration.ofSeconds(30)))
      .body(service.list());
}
```

> **ETag/Last-Modified**도 적극 사용 → 프리패치/리밸리데이션 비용 절감.

### D-4. 프리패치·프리로드 전략

- 링크 뷰포트 진입 시 **사전 패칭**: `link rel="prefetch"`(낮은 우선순위), `preload`(높음).
- 라우터 레벨 프리패치(Next `<Link prefetch>`, SvelteKit `data-sveltekit-preload-data="hover"`).
- **SWR/React Query**: 페이지 진입 전에 `queryClient.prefetchQuery(...)`.
- **서비스 워커**: 설치 직후 핵심 JSON/스프라이트/폰트 프리캐시(Workbox).

**Next 예**
```tsx
<Link prefetch href="/products/123">상품</Link>
```

**SvelteKit 예**
```html
<a href="/orders" data-sveltekit-preload-data="hover">주문</a>
```

**HTTP 힌트**
```html
<link rel="preload" as="style" href="/styles.css" />
<link rel="prefetch" href="/api/catalog?page=2" as="fetch" crossorigin>
```

### D-5. 이미지/정적 리소스

- 이미지 최적화(AVIF/WebP) + `srcset/sizes`.
- **CDN 변환**(Cloudflare Images, imgproxy) → 엣지에서 리사이즈/포맷 자동.
- 캐시 파기: 파일명에 해시(`app.3f2c9e7.css`).

---

## E. 운영 체크리스트

**보안·쿠키/세션**
- [ ] `Secure`/`HttpOnly`/`SameSite` 정확히 설정. 크로스사이트면 `None;Secure`.
- [ ] CORS: **정확한 Origin** 화이트리스트, 자격증명 허용 시 `*` 금지.
- [ ] CSRF: 세션 기반이면 `CookieCsrfTokenRepository`/Double Submit, JWT 헤더 기반이면 CSRF 비활성 + XSS 방어 강화.
- [ ] 로그인/리프레시: 회전, IP/UA 바인딩, 로그아웃 시 무효화.

**성능·캐시**
- [ ] SSR/CSR 혼합: SEO·초기 렌더 경로는 SSR/ISR, 나머지는 CSR.
- [ ] CDN 헤더(스태틱 장캐시, API는 s-maxage + SWR).
- [ ] ETag/Last-Modified/If-None-Match 적용.
- [ ] 프리패치/프리로드/서비스워커로 체감 속도↑.

**신뢰성**
- [ ] 표준 에러모델(ApiResponse) & 트레이스ID 노출.
- [ ] Axios/Fetch 인터셉터로 401/429/5xx 처리, 취소 토큰.
- [ ] 업/다운로드 헤더(CORS exposed) & 재시도 정책(지수백오프+지터, 멱등 요청만).

**개발경험**
- [ ] 로컬 프록시(프런트 dev server → 백엔드)로 CORS 회피/쿠키 전달.
- [ ] API 스키마(OpenAPI)에서 타입 자동 생성(Zod/TypeScript).
- [ ] 환경별 베이스 URL/쿠키 도메인 자동화.

---

## F. 로컬 개발·프록시 설정

**React(Vite)**
```ts
// vite.config.ts
export default defineConfig({
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:8080",
        changeOrigin: true,
        secure: false
      }
    }
  }
});
```

**Vue(Vite) 동일 / SvelteKit**
```ts
// svelte.config.js (hooks) 또는 vite server.proxy 활용
```

**Spring(로컬 CORS 완화)**
```java
if (isDev) {
  // 모든 Origin 허용(로컬 한정), 자격증명은 false
}
```

---

## G. 실전 레시피(요약)

1) **쿠키 기반 세션 + SPA**
   - 서버: `CookieCsrfTokenRepository`, `SameSite=None; Secure`, CORS 정확히.
   - 프런트: `withCredentials`, axios xsrf 자동, 오류모델/트레이스ID.
2) **JWT(헤더) + 리프레시 쿠키**
   - 액세스 토큰은 메모리 저장, 401 시 `/auth/refresh` 호출.
   - 리프레시는 `HttpOnly+Secure+SameSite=Strict/None`.
3) **SSR + API 프록시**
   - 서버 라우트에서 백엔드 호출(서버 쿠키 전달), 클라이언트 호출 최소화.
   - ISR/`s-maxage`/`stale-while-revalidate`로 엣지 캐시.
4) **파일 핸들링**
   - 업로드: multipart + 진행률, 최대크기 제한/바이러스 스캔.
   - 다운로드: `Content-Disposition` + `Content-Type` + `exposedHeaders`.
5) **프리패치**
   - 라우터 프리패치/서비스워커 + SWR 캐시로 사용자 체감 **즉시 응답**.

---

## H. 부록 — 보안 헤더/브라우저 보호

- **CSP**: `default-src 'self'; img-src 'self' https: data:; script-src 'self' 'nonce-<rnd>';`
- **X-Frame-Options**: `DENY`(클릭재킹 방지)
- **Referrer-Policy**: `strict-origin-when-cross-origin`
- **Permissions-Policy**: `geolocation=(), camera=()`
- **X-Content-Type-Options**: `nosniff`
- **Strict-Transport-Security**(HSTS): `max-age=31536000; includeSubDomains; preload`

Spring Filter로 공통 적용하거나 Gateway에서 일괄 주입.

---

## I. 한 페이지 요약

- **CORS**: 정확한 Origin·Credentials, preflight 캐시.
- **쿠키/세션/CSRF**: 크로스사이트면 `SameSite=None; Secure`, 세션은 CSRF 토큰, JWT 헤더는 XSS를 경계.
- **SPA 연동**: 공통 HTTP 래퍼(인터셉터/취소/에러표준), 업/다운로드 헤더, 401 처리.
- **SSR·엣지 캐시**: 서버에서 데이터+HTML 구성, `s-maxage`/SWR/ISR로 빠른 TTFB와 신선도.
- **프리패치**: 라우터/서비스워커로 미리 가져와 **체감 속도**를 올린다.
