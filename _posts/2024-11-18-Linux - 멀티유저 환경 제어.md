---
layout: post
title: Linux - 멀티유저 환경 제어
date: 2024-11-18 19:20:23 +0900
category: Linux
---
# 멀티유저 환경 제어

## 기본 원칙과 적용 우선순위

리눅스 멀티유저 환경에서 리소스 제어는 계층적인 구조를 가집니다. 각 계층은 특정 시점과 범위에서 작동하며, 상위 계층의 제한이 하위 계층보다 우선 적용됩니다:

1. **systemd 단위(unit) 리소스 한계**: 최상위 계층으로 cgroups 레벨에서 작동
2. **PAM limits**: `/etc/security/limits.conf` 및 `limits.d` 파일을 통해 로그인 시점에 적용
3. **세션 내 `ulimit`**: 일시적·로컬 변경으로 셸 하위 프로세스에만 전파

중요한 원칙들:
- **soft ≤ hard** 규칙: soft limit은 hard limit을 초과할 수 없음
- **비대화형 서비스**: systemd로 기동되는 서비스는 PAM을 거치지 않으므로 limits.conf가 적용되지 않을 수 있음 → unit에 직접 지정 필요
- **컨테이너 환경**: 컨테이너 런타임(cgroups) 한계가 최상위 제한으로, 게스트 내부 설정은 상한을 넘지 못함

---

## `ulimit` — 현재 셸/세션의 즉시 한계

### 전체 확인·대표 설정

```bash
ulimit -a                    # 모든 한계(soft) 조회
ulimit -n 4096               # 열린 파일 디스크립터(soft) = 4096
ulimit -u 2048               # 사용자당 프로세스/스레드 수(nproc)
ulimit -f 0                  # 생성 파일 크기 제한(0은 무제한)
ulimit -t 60                 # CPU 초 제한(초)
```
- **세션/셸 한정**으로, 새 로그인·새 셸에서 초기화됨
- `ulimit -Sn`, `-Hn`으로 **soft/hard** 각각 지정/조회 가능

### 프로세스별 한계 확인(운영 디버깅)

```bash
cat /proc/$$/limits            # 현재 셸(자기 자신)
cat /proc/<PID>/limits         # 임의 프로세스
```

### 실행 중 프로세스 한계 변경 `prlimit`

```bash
# PID 1234의 NOFILE soft/hard를 4096/8192로 변경
sudo prlimit --pid 1234 --nofile=4096:8192

# 실행과 동시에 한계 부여
prlimit --nofile=8192:8192 -- bash -c 'your_command'
```

### 코드에서의 설정(레퍼런스)

#### C: `setrlimit(2)`

```c
#include <sys/resource.h>
#include <stdio.h>

int main() {
  struct rlimit rl = { .rlim_cur = 8192, .rlim_max = 8192 };
  if (setrlimit(RLIMIT_NOFILE, &rl) != 0) perror("setrlimit");
  /* 앱 본체 */
  getchar();
}
```

#### Python: `resource` 모듈

```python
import resource
soft, hard = resource.getrlimit(resource.RLIMIT_NOFILE)
resource.setrlimit(resource.RLIMIT_NOFILE, (8192, 8192))
```

---

## `/etc/security/limits.conf` — PAM을 통한 영구 정책

### 파일과 포함 규칙

- 메인 설정 파일: `/etc/security/limits.conf`
- 추가 설정 파일: `/etc/security/limits.d/*.conf` (숫자 접두어로 우선순위 관리 권장)

구문:
```conf
<도메인> <type> <item> <value>
# 도메인: 사용자명, 그룹은 @group, 전체는 *
# type: soft | hard | -
# item: nofile, nproc, fsize, core, memlock, rss, stack, cpu, nice, rtprio 등
```

예시:
```conf
# 개별 사용자 설정
devkim   soft  nofile  2048
devkim   hard  nofile  4096
devkim   soft  nproc   1000
devkim   hard  nproc   2000

# 모든 사용자 기본 설정
*        soft  nproc   1024
*        hard  nproc   2048

# 그룹 전체 설정
@developers hard core   0       # 코어덤프 금지
@render     hard rtprio 60      # RT 우선순위 허용 상한
```

### PAM 경유 여부 확인(매우 중요)

**로그인 경로**가 PAM을 거쳐야 `pam_limits.so`가 적용됩니다:

- Debian/Ubuntu: `/etc/pam.d/common-session` 또는 `common-session-noninteractive` 내에 `session required pam_limits.so` 포함 확인
- RHEL/CentOS: `/etc/pam.d/login`, `/etc/pam.d/sshd`, `/etc/pam.d/su` 등 해당 파일에 동일 라인 존재 확인

> systemd 서비스는 PAM을 거치지 않으므로 **limits.conf가 적용되지 않습니다** → unit에 직접 설정 필요

### 동작 확인

- 재로그인 후 다음 명령으로 확인:
```bash
ulimit -n          # 기대값 확인
cat /proc/$$/limits | grep "open files"
```

### 동시 로그인 제한(동시 세션 억제)

```conf
# 사용자별 동시 로그인 수 제한
james    hard  maxlogins  2
*        hard  maxlogins  10
```
> SSH·DISPLAY 매니저와의 상호작용은 배포판/PAM 스택 구성에 따라 다름. 실제 환경에서 검증 필요

---

## systemd + cgroups v2 — 서비스/세션 리소스 강제

**운영 환경의 최상위 제어 레버**로, 프로세스 그룹 단위(cgroup)로 CPU/메모리/파일핸들/태스크 수를 제한합니다.

### 서비스 Unit에서의 리소스 한계

`/etc/systemd/system/myapp.service`
```ini
[Unit]
Description=My App

[Service]
ExecStart=/opt/myapp/bin/app

# 파일핸들 제한
LimitNOFILE=65535

# 프로세스/스레드 총 수 제한
TasksMax=4096

# 메모리 상한
MemoryMax=2G

# 스왑 제한
MemorySwapMax=0

# CPU 할당(20% 코어 시간)
CPUQuota=20%

# OOM 발생 시 재시작
Restart=on-failure

[Install]
WantedBy=multi-user.target
```
적용:
```bash
sudo systemctl daemon-reload
sudo systemctl restart myapp
systemctl show myapp -p TasksCurrent,MemoryCurrent,CPUUsageNSec
```

### 시스템 전체 기본 설정(DefaultLimit*)

시스템 전역 기본값을 설정하여 신규 서비스의 상한선을 조정할 수 있습니다:

- `/etc/systemd/system.conf` (시스템 서비스)
- `/etc/systemd/user.conf` (사용자 서비스)

대표 항목:
```ini
DefaultLimitNOFILE=65535
DefaultTasksMax=12288
```
적용:
```bash
sudo systemctl daemon-reexec
```

### 로그인 세션 단위 컨트롤(사용자 슬라이스)

systemd는 사용자별로 `user-<UID>.slice`를 구성합니다:

```bash
# 현재 시스템의 사용자 슬라이스 확인
systemctl status user-$(id -u).slice

# 임시로 런칭하면서 한계 부여
systemd-run --user --scope -p MemoryMax=1G -p CPUQuota=50% bash
```

### `loginctl enable-linger` — 로그아웃 후에도 사용자 서비스 유지

```bash
sudo loginctl enable-linger devkim
sudo -u devkim systemctl --user enable --now my-user-service
```
> 데몬과 같은 사용자 서비스가 로그아웃 후에도 계속 동작합니다

### cgroups v2 핵심 컨트롤러

- **memory.max**, **memory.swap.max**
- **cpu.max** (쿼터/주기), **cpu.weight**
- **pids.max** (TasksMax와 맵핑)
- **io.max** (블록 I/O) — 배포판별 지원 차이 있음

---

## 세션/사용자 관찰과 제어

### 현재/과거 사용자 확인

```bash
who -uH                 # 로그인 사용자/TTY/유휴/세션 PID
w                       # 사용자 + load average + 실행 커맨드
last -n 20              # 최근 20개 로그인 기록
last reboot             # 재부팅 이력
```

### systemd 기반 세션 관리

```bash
loginctl list-users
loginctl list-sessions
loginctl show-session <SID> -p Name,State,Remote
loginctl terminate-session <SID>
```

---

## 디스크 사용 제한 — 사용자/그룹/프로젝트 Quota

### fstab 옵션

```fstab
UUID=xxxx-xxxx  /home  ext4  defaults,usrquota,grpquota  0  2
```
재마운트:
```bash
sudo mount -o remount /home
```

### 초기화·활성화

```bash
sudo quotacheck -cum /home     # 사용자(-u)·새 파일생성(-c)·마운트 무시(-m)
sudo quotaon /home
```

### 사용자 한계 설정·조회

```bash
sudo edquota devkim
quota -u devkim
repquota -a                 # 전체 보고서
```
`edquota` 편집 필드: **blocks soft/hard**, **inodes soft/hard**, **grace** (유예 기간)

### 프로젝트 쿼터(대량 디렉터리 단위, xfs/ext4 신기능)

- **xfs**: `xfs_quota` (프로젝트 ID + 디렉토리 바인딩)
- **ext4**: `-O project` 활성화 필요. CI/빌드 캐시 같은 디렉터리 단위 제한에 유용

---

## 운영 충돌·트러블슈팅

### "limits.conf를 변경했는데 서비스에 NOFILE이 그대로 적용되지 않음"

- 서비스가 **systemd로 기동**되는 경우 PAM을 경유하지 않음
  ⇒ **Unit에 `LimitNOFILE=`** 명시 필요
- 전역 기본 설정 필요 시 `/etc/systemd/system.conf`의 `DefaultLimitNOFILE` 조정 후 `daemon-reexec` 실행

### "SSH 로그인은 변경사항이 적용되지만 `sudo` 후 값이 원래 상태로 돌아감"

- `sudo`가 **비로그인·비대화형** PAM 스택을 사용할 수 있음
  ⇒ `/etc/pam.d/sudo`에 `session required pam_limits.so` 포함 여부 확인
  ⇒ 또는 **systemd-run**으로 범위 재지정

### "nproc 제한으로 인해 앱 스레드 생성 실패"

- JVM/NGINX/DB 등이 스레드 생성 시 실패
  ⇒ `limits.conf`의 `nproc` 값 상향, 또는 **서비스 Unit에 `TasksMax=`** 값 상향

### "컨테이너 내부에서 NOFILE을 올려도 실제로 증가하지 않음"

- 컨테이너 호스트 런타임(cgroup 상한/ulimit)이 상위 제한으로 작용
  ⇒ Docker `--ulimit nofile=...` 또는 K8s `pod.spec.securityContext`/`container` 런타임 옵션 사용
  ⇒ 호스트 systemd 서비스(Unit)로 컨테이너를 실행하는 경우 Unit 한계도 확인

### "코어덤프 차단/보안 설정"

- `/etc/security/limits.conf`: `* hard core 0`
- 커널 설정: `sysctl -w fs.suid_dumpable=0` (SUID 바이너리 덤프 금지)

---

## 실전 시나리오

### 시나리오 A — "생산 DB 커넥션 급증 → Too many open files"

1) 현황 파악:
```bash
cat /proc/<DBPID>/limits | grep "open files"
lsof -p <DBPID> | wc -l
```

2) 서비스 Unit 보정:
```ini
# /etc/systemd/system/postgresql.service.d/override.conf
[Service]
LimitNOFILE=262144
```

3) 적용:
```bash
sudo systemctl daemon-reload
sudo systemctl restart postgresql
```

4) 관찰:
```bash
systemctl show postgresql -p TasksCurrent
cat /proc/<DBPID>/limits | grep "open files"
```

### 시나리오 B — "빌드 서버 사용자 과도한 병렬 작업으로 서버 다운"

- 정책 설정:
```conf
# /etc/security/limits.d/50-buildfarm.conf
@buildfarm hard nproc   2000
@buildfarm hard nofile  32768
```

- 세션 수 제한:
```conf
@buildfarm hard maxlogins 20
```

- 큐/스케줄러 도입을 병행(Jenkins/Argo 등)

### 시나리오 C — "로그아웃 후에도 사용자 데몬 유지"

```bash
sudo loginctl enable-linger devkim
sudo -u devkim systemctl --user enable --now my-timer.service
```

### 시나리오 D — "연구 계정 디스크 폭주 방지"

```bash
# /home에 usrquota 설정
sudo edquota researcher1
warnquota -u researcher1         # 경고 메일 발송(선택 사항)
repquota -a | less
```

---

## 명령어·파일 치트시트

| 범주 | 명령/파일 | 설명 |
|---|---|---|
| 세션 한계 | `ulimit -a/-n/-u/-f/-t`, `/proc/<PID>/limits` | 즉시 확인/변경 |
| 실행 중 변경 | `prlimit --pid <PID> --nofile=soft:hard` | 프로세스 한계 수정 |
| PAM limits | `/etc/security/limits.conf`, `limits.d/*.conf`, `pam_limits.so` | 로그인 시 영구 적용 |
| 세션/로그 | `who`, `w`, `last`, `last reboot` | 사용자·부하·이력 |
| systemd 세션 | `loginctl list-sessions`, `terminate-session`, `enable-linger` | 세션·사용자 제어 |
| 서비스 한계 | `LimitNOFILE`, `TasksMax`, `MemoryMax`, `CPUQuota` | Unit(서비스) 리소스 |
| 전역 기본 | `/etc/systemd/system.conf`, `user.conf` | DefaultLimit*, DefaultTasksMax |
| 임시 스코프 | `systemd-run --scope -p Key=Val cmd` | cgroup 스코프로 실행 |
| 쿼터 | `fstab usrquota`, `quotacheck`, `quotaon`, `edquota`, `quota`, `repquota` | 디스크 제한 |

---

## 실습 세트

### 사용자별 NOFILE 정책 + 서비스 한계 매칭

```bash
# PAM limits 설정
echo "alice soft nofile 8192" | sudo tee -a /etc/security/limits.d/90-alice.conf
echo "alice hard nofile 16384" | sudo tee -a /etc/security/limits.d/90-alice.conf

# SSH 재로그인 후 확인
ssh alice@host "ulimit -n; cat /proc/$$/limits | grep 'open files'"

# 서비스에 직접 적용
sudo systemctl edit myapp.service
# [Service]에 LimitNOFILE=16384 추가 → 저장

sudo systemctl daemon-reload && sudo systemctl restart myapp
```

### 빌드 세션을 임시로 1G 메모리·50% CPU로 제한

```bash
systemd-run --user --scope -p MemoryMax=1G -p CPUQuota=50% bash -lc 'make -j'
```

### 동시 로그인 제한 테스트(교육·시험 환경)

```conf
# /etc/security/limits.d/95-lab.conf
student hard maxlogins 1
```
- 동일 사용자의 중복 로그인 시도 거부됨(PAM 경로 필요)

---

## 부록 — 대표 리소스 항목 요약

| 항목 | 의미 | 설정 위치 |
|---|---|---|
| nofile | 열린 파일 디스크립터 수 | ulimit/limits.conf/LimitNOFILE |
| nproc  | 스레드/프로세스 수 | ulimit/limits.conf/TasksMax(pids.max) |
| fsize  | 생성 파일 최대 크기 | ulimit/limits.conf |
| core   | 코어덤프 크기 | ulimit/limits.conf |
| cpu    | 누적 CPU 시간 | ulimit/limits.conf |
| memlock| mlock 잠금 메모리 | ulimit/limits.conf |
| MemoryMax | cgroup 메모리 상한 | systemd unit |
| CPUQuota  | CPU 시간 비율 | systemd unit |
| TasksMax  | 태스크 수 상한 | systemd unit |

> **개념 연결**: `nproc`(유닉스 RLIMIT_NPROC)은 "사용자당 생성 수", `TasksMax(pids.max)`는 **그 cgroup 내** 프로세스/스레드 수입니다. 서비스 단위 제어에는 `TasksMax`가 즉시 효과적입니다.

---

## 결론

리눅스 멀티유저 환경에서 효과적인 리소스 제어는 시스템 안정성과 보안을 유지하는 데 중요합니다. 다음과 같은 원칙과 접근 방식을 기억하세요:

**계층적 제어 구조 이해**:
리눅스의 리소스 제어는 계층적인 구조로 이루어집니다. `ulimit`은 현재 세션의 즉시 제어를, PAM limits는 로그인 시점의 영구적 정책을, systemd와 cgroups는 시스템 수준의 강력한 제어를 제공합니다. 각 계층의 특성과 상호작용을 이해해야 효과적인 제어가 가능합니다.

**적절한 도구 선택**:
- 즉시적인 디버깅: `ulimit`, `prlimit`, `/proc/<PID>/limits` 활용
- 영구적 정책: `pam_limits.so`를 통한 `limits.conf`/`limits.d` 설정
- 운영 환경 제어: systemd + cgroups를 통한 서비스·세션·사용자 슬라이스 관리

**실용적 트러블슈팅 접근**:
문제 발생 시 체계적으로 접근하세요. 예를 들어, "Too many open files" 오류는 프로세스의 현재 한계 확인 → 서비스 unit 설정 검토 → systemd 전역 설정 확인 순으로 진행하면 효과적입니다.

**통합적 모니터링과 제어**:
사용자 활동 가시성(`who`/`w`/`last`/`loginctl`)과 저장공간 통제(quota)를 결합하여 멀티유저 환경의 안정성을 확보하세요. 특히 교육이나 공용 서버 환경에서는 동시 로그인 제한과 디스크 쿼터 설정이 중요합니다.

**컨테이너 환경 고려**:
컨테이너화된 환경에서는 호스트의 cgroup 제한이 최상위로 작용합니다. 컨테이너 내부 설정만으로는 상한을 넘을 수 없으므로, Docker나 Kubernetes 수준에서 적절한 리소스 제한을 설정해야 합니다.

이러한 원칙들을 바탕으로 시스템을 설계하고 운영하면, 다중 사용자 환경에서도 안정적이고 예측 가능한 성능을 제공할 수 있습니다. 각 환경의 특성에 맞게 적절한 제어 메커니즘을 선택하고 조합하는 것이 핵심입니다.