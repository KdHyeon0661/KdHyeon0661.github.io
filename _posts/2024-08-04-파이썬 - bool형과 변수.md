---
layout: post
title: 파이썬 - bool형과 변수
date: 2024-08-04 19:20:23 +0900
category: Python
---
# 참과 거짓 · 변수와 참조

## 1. 참과 거짓 (Boolean)

파이썬의 `True`와 `False`는 **불리언(Boolean)** 값이며, 내부적으로 **정수(int)의 서브클래스**입니다.

```python
print(isinstance(True, bool))    # True
print(isinstance(True, int))     # True  ← bool은 int의 서브클래스
print(True == 1, False == 0)     # True True (값은 같게 비교)
print(True + True + 5)           # 7     (1 + 1 + 5)
print(True is 1, False is 0)     # False False (객체 동일성은 아님)
```

> **핵심**: `==`는 값 비교(동등성), `is`는 객체 동일성(아이덴티티) 비교입니다.  
> `True == 1`은 `True`지만 `True is 1`은 `False`입니다.

### 1.1 불리언 리터럴과 기본 사용

```python
if 10 > 5:
    print("참입니다.")  # 출력

if 10 < 5:
    print("거짓입니다.")
else:
    print("조건이 거짓입니다.")  # 출력
```

### 1.2 진리값으로 평가되는 값 (Truthiness)

아래는 **거짓(Falsey)** 으로 평가됩니다.

- `0` (정수 0), `0.0` (실수 0), `0j` (복소수 0)
- 빈 컨테이너: `""`, `[]`, `()`, `{}`, `set()`, `range(0)`
- `None`
- 사용자 정의 객체의 `__bool__`이 `False`를 반환하거나, `__len__`이 0을 반환하는 경우

그 외 대부분은 **참(Truthy)** 입니다.

```python
print(bool(10), bool(0))           # True False
print(bool("text"), bool(""))      # True False
print(bool([1]), bool([]))         # True False
print(bool(None))                  # False
```

#### 사용자 정의 truthiness
```python
class Batch:
    def __init__(self, items): self.items = items
    def __len__(self): return len(self.items)

b1 = Batch([]); b2 = Batch([1,2])
print(bool(b1), bool(b2))          # False True  (__len__ 기반)
```

### 1.3 논리 연산과 단락 평가 (Short-Circuit)

- `and`: 좌항이 False면 우항을 **평가하지 않음** (False 확정)  
- `or` : 좌항이 True면 우항을 **평가하지 않음** (True 확정)  
- `not`: 단항 부정

```python
def side_effect():
    print("실행됨")
    return True

print(False and side_effect())     # False (우항 평가 안 함)
print(True or side_effect())       # True  (우항 평가 안 함)
print(not 0, not 1)                # True False
```

> **파이썬의 논리 연산자는 피연산자 자체를 반환**합니다(진리값이 아닌).  
> `a and b`는 `a`가 True이면 `b`를, 아니면 `a`를 반환합니다.  
> `a or b`는 `a`가 True이면 `a`를, 아니면 `b`를 반환합니다.

```python
print("" or "default")             # "default"
print([1,2] and "X")               # "X"
```

### 1.4 연산자 우선순위(상대적)

`not` > `and` > `or` (높음 → 낮음). 헷갈리면 괄호로 명시하세요.

```python
print(True or False and False)     # True  (and 먼저)
print((True or False) and False)   # False
```

### 1.5 조건 표현식(삼항 연산)

```python
x = 10
label = "big" if x > 5 else "small"
print(label)                       # big
```

### 1.6 all/any 유틸리티

```python
nums = [2, 4, 6]
print(all(n % 2 == 0 for n in nums))  # True (모두 짝수)
print(any(n > 5 for n in nums))       # True (5보다 큰 값 존재)
```

---

## 2. 비교와 체이닝(Chaining)

파이썬은 **비교 연산을 체인**할 수 있습니다.

```python
x = 5
print(1 < x < 10)         # True   (1 < x and x < 10 과 동일)
print(1 == x < 10)        # False  (1 == x and x < 10)
```

> 체이닝은 **가독성**과 **중복 평가 방지** 장점이 있습니다.

---

## 3. None과 싱글턴, is의 올바른 용법

- `None`은 **싱글턴(singleton)** 입니다. None 비교는 **`is`** 를 쓰는 것이 관용입니다.
- 부울, 작은 정수, 짧은 문자열 등은 **인터닝(interning)** 최적화가 있을 수 있으나, **`is` 비교에 의존하지 마세요**. 값 비교는 `==`가 정석입니다.

```python
x = None
print(x is None)          # True  (권장)
print(x == None)          # True지만 is가 명확

a = 256; b = 256
print(a is b)             # 구현/버전에 따라 True일 수 있음 (의존 금지)
print(1000 is 10**3)      # 경고: is 사용 금지 (== 사용)
```

---

## 4. 변수와 참조 (Binding & Object Model)

파이썬에서 **변수는 ‘상자’가 아닌 ‘이름 → 객체’ 바인딩(참조)** 입니다.  
대입은 **이름을 다른 객체에 재바인딩**할 뿐, 객체를 복사하지 않습니다.

```python
a = [1, 2, 3]
b = a                  # 같은 리스트 객체를 가리킴 (참조 공유)
a.append(4)
print(b)               # [1,2,3,4]
print(a is b)          # True (동일 객체)
```

### 4.1 id()와 동일성/동등성

```python
x = [1,2,3]; y = [1,2,3]
print(x == y)          # True  (내용이 같음)
print(x is y)          # False (다른 객체)
print(id(x), id(y))    # 서로 다른 주소
```

> **요점**: `is`는 **동일한 객체냐** (아이덴티티), `==`는 **값이 같냐** (동등성) 입니다.

### 4.2 불변 vs 가변, 재바인딩/제자리 변경

- **불변(immutable)**: `int`, `float`, `str`, `tuple`, `frozenset` 등  
  → “변경”은 새 객체를 만들어 **재바인딩**합니다.
- **가변(mutable)**: `list`, `dict`, `set` 등  
  → 메서드로 **제자리 변경(in-place)** 합니다.

```python
# 불변 예: str
s = "ab"
print(id(s))
s += "c"               # 새 문자열 생성
print(id(s))           # 다른 id

# 가변 예: list
lst = [1,2]
print(id(lst))
lst.append(3)          # 제자리 변경
print(id(lst))         # 같은 id
```

### 4.3 증강 대입의 함정 (+= 등)

증강 대입은 **컨테이너 타입에 따라** 재바인딩 또는 제자리 변경이 다릅니다.

```python
# 불변: 새 객체 생성
t = (1,2)
print(id(t))
t += (3,)
print(id(t))           # 달라짐 (새 튜플)

# 가변: 제자리 변경
a = [1,2]; b = a
a += [3]
print(a, b, a is b)    # [1,2,3] [1,2,3] True
```

---

## 5. 호출 시 인자 전달 모델 (Call by Object-Sharing)

파이썬은 흔히 **“객체 공유에 의한 호출”** (또는 **call by assignment**)로 설명됩니다:  
**함수 매개변수 이름**이 **인자로 전달된 객체**를 **새로 참조**합니다. 함수 내부에서 **재바인딩**을 하면 외부에는 영향이 없지만, **가변 객체의 제자리 변경**은 외부에 영향을 줍니다.

```python
def f(lst, n):
    lst.append(n)   # 제자리 변경 (외부 영향 O)
    n += 1          # 재바인딩 (외부 영향 X)
    return n

nums = [0]; x = 10
y = f(nums, x)
print(nums, x, y)   # [0, 10] 10 11
```

---

## 6. 가비지 컬렉션 · 참조 카운팅 · 순환 참조

파이썬(CPython)은 **참조 카운팅** + **순환 참조 수집기**를 사용합니다.

- `sys.getrefcount(obj)`로 대략적인 참조 수를 확인할 수 있습니다(함수 인자 전달로 인해 보통 1이 더 큼).
- **순환 참조**(서로가 서로를 가리키는 구조)는 참조 카운팅만으로는 못 지우므로, **GC**가 주기적으로 회수합니다.

```python
import sys

a = []
print(sys.getrefcount(a))      # 예: 2 (getrefcount 인자 전달 영향 포함)

# 순환 참조 예
x = []
x.append(x)                    # 자기 자신 참조
del x                          # 바로 메모리 회수되지 않을 수 있음 (GC가 처리)
```

> 실시간/자원 한정 환경에서는 순환참조 구조를 피하거나 `weakref`를 고려하세요.

---

## 7. 스코프와 바인딩 (LEGB 규칙)

이름 검색은 **L → E → G → B** 순서입니다.

- **L**ocal (함수 내부)  
- **E**nclosing (중첩 함수의 바깥 함수)  
- **G**lobal (모듈 전역)  
- **B**uiltins (파이썬 내장)

```python
x = "global"
def outer():
    x = "enclosing"
    def inner():
        x = "local"
        print(x)
    inner()
outer()                         # local
```

### 7.1 `global`, `nonlocal`

```python
x = 0
def g():
    global x
    x = 100

def outer():
    y = 0
    def inc():
        nonlocal y
        y += 1
    inc()
    return y

g(); print(x)                   # 100
print(outer())                  # 1
```

---

## 8. 불리언 컨텍스트에서의 실전 패턴

### 8.1 “값이 0도 유효”인 경우

`if value:`는 `0`, `""`, `[]`를 **거짓**으로 봅니다.  
**0도 유효한 값**이라면 아래처럼 **존재성**을 별도로 확인하세요.

```python
d = {"count": 0}
if "count" in d:               # 키 존재성
    print("키 존재:", d["count"])   # 0 (유효)
```

### 8.2 기본값 대입 패턴 (`or`와의 차이)

```python
# 'or'는 Falsy면 오른쪽으로 대체 → 값이 0/""인 경우 원치 않게 바뀜
count = d.get("count") or 10   # 0이면 10이 됨 (의도?)
# 안전: 키 존재성으로 구분
count = d["count"] if "count" in d else 10
```

---

## 9. 비교적 자주 묻는 질문(F.A.Q.)

### 9.1 `True == 1`인데 왜 `True is 1`이 아니죠?
- `bool`은 `int`의 서브클래스라서 **값 비교**는 같게 평가될 수 있지만, **객체 동일성**은 다릅니다.

### 9.2 `is`는 언제 쓰나요?
- 싱글턴(`None`, `NotImplemented`, `Ellipsis`) 비교와 **아이덴티티 확인**이 필요한 곳.  
  값 비교는 `==`가 원칙입니다.

### 9.3 `id()`는 주소인가요?
- 구현 상세에 종속적입니다(일반적으로 CPython에서 객체의 메모리 주소를 반영). 디버깅 참고용으로만 사용하세요.

### 9.4 작은 정수/문자열에서 `is`가 가끔 True인 이유?
- **인터닝** 최적화 때문입니다. **절대 의존하지 마세요**. 값 비교는 `==`.

---

## 10. 디버깅/품질을 위한 스니펫

### 10.1 방어적 복사로 사이드이펙트 차단
```python
def process(seq):
    seq = list(seq)   # 이터러블을 복사해 내부에서 안전 조작
    seq.sort()
    return seq
```

### 10.2 가변 기본 인자 금지
```python
def bad(x, acc=[]):      # 호출 간 공유됨 (버그 유발)
    acc.append(x)
    return acc

def good(x, acc=None):
    if acc is None:
        acc = []
    acc.append(x)
    return acc
```

### 10.3 `all/any`로 간결한 검증
```python
def is_strictly_increasing(xs):
    return all(a < b for a, b in zip(xs, xs[1:]))

print(is_strictly_increasing([1,2,3]))  # True
```

---

## 11. 예제 모음

### 11.1 truthiness로 필터링
```python
data = ["", "A", None, "B", " "]
clean = [s for s in data if s]       # "", None 제거
print(clean)                         # ['A', 'B', ' ']
```

### 11.2 단락 평가로 안전 접근
```python
config = {"db": {"host":"localhost"}}
host = config.get("db") and config["db"].get("host") or "127.0.0.1"
print(host)                          # 'localhost'
```

### 11.3 체인 비교로 영역 검사
```python
score = 87
print(80 <= score < 90)              # True
```

### 11.4 None 검사와 디폴트
```python
def take(n=None):
    if n is None:
        n = 10
    return n
```

### 11.5 불리언 산술의 활용
```python
flags = ["--verbose", "--dry-run", ""]
on = sum(bool(f) for f in flags)     # 빈 문자열 제외 카운트
print(on)                            # 2
```

---

## 12. 수학적 메모(불리언 대수의 핵심 성질)

불리언 값에 대해(논리곱: ∧, 논리합: ∨, 부정: ¬) 다음이 성립합니다.

$$
\begin{aligned}
& x \land \text{True} = x,\quad x \land \text{False} = \text{False} \\
& x \lor \text{True} = \text{True},\quad x \lor \text{False} = x \\
& x \lor x = x,\quad x \land x = x \\
& x \lor \neg x = \text{True},\quad x \land \neg x = \text{False} \\
& \neg(\neg x) = x
\end{aligned}
$$

파이썬에서는 `and`, `or`, `not`이 각각 \( \land, \lor, \neg \)에 해당합니다.

---

## 13. 요약 체크리스트

- `bool`은 `int` 서브클래스: `True == 1`이지만 `True is 1`은 **False**.
- **truthiness**: 빈 컨테이너/0/None은 False. 사용자 정의는 `__bool__`/`__len__`.
- **단락 평가**: `and`/`or`는 피연산자 자체를 반환, 우항 평가를 생략할 수 있음.
- **비교 체이닝**: `a < x < b` 가독성·효율성 우수.
- **None 비교는 `is`**: 싱글턴 비교는 `is` 권장, 값 비교는 `==`.
- **변수는 참조(바인딩)**: 재바인딩 vs 제자리 변경을 구분.
- **가변 기본 인자 금지**: `None` 패턴.
- **객체 전달 모델**: 가변 객체 제자리 변경은 외부에 영향.

---

# 부록: 실행 예제 한 번에 보기

```python
# 1. 불리언/truthiness
print(bool(0), bool(""), bool([]), bool([1]))  # False False False True
print("" or "default")                         # "default"
print([1] and "X")                             # "X"

# 2. 단락 평가
def touched():
    print("call")
    return True

print(False and touched())                     # False
print(True or touched())                       # True

# 3. 비교 체인
x = 5
print(1 < x < 10, 1 == x < 10)                 # True False

# 4. None과 is
y = None
print(y is None)                               # True

# 5. 동일성/동등성
a = [1,2,3]; b = [1,2,3]; c = a
print(a == b, a is b, a is c)                  # True False True

# 6. 가변/불변, 증강 대입
t = (1,2); print(id(t)); t += (3,); print(id(t))
lst = [1,2]; ref = lst; lst += [3]; print(lst, ref, lst is ref)

# 7. 호출 모델
def push(xs, n):
    xs.append(n)   # 외부 영향
    n += 1         # 재바인딩
    return n
nums = [0]; v = 10
out = push(nums, v)
print(nums, v, out)                            # [0,10] 10 11
```
