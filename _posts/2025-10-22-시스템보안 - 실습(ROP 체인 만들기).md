---
layout: post
title: 시스템보안 - 실습(ROP 체인 만들기)
date: 2025-10-22 17:30:23 +0900
category: 시스템보안
---
# 실습 1: 보호 취약한 바이너리에 대한 기본 ROP 체인 만들기(개념 설계 중심)

> 목표: “왜 ROP가 가능한가”를 **메모리/호출 규약/가젯 조합** 관점에서 이해한다.
> 안전장치: 실제 주소·오프셋·완전한 exploit 스크립트는 제공하지 않는다. 실습은 오로지 **본인 소유 랩 VM**에서, **의도적으로 취약하게 컴파일한 학습용 프로그램**으로만 한다.

## A. 문제 배경 — ROP가 성립하는 3요소

1) **제어 이전 지점**: 스택 버퍼 오버플로우 등으로 **Saved RIP**(리턴 주소)을 덮을 수 있어야 한다.
2) **가젯(gadget) 풀**: 바이너리/라이브러리 내부에 `ret`으로 끝나는 짧은 어셈블리 조각들이 존재.
3) **실행 정책**: 스택이 NX(실행 금지)이더라도, **기 존재 코드 조각**을 이어붙여 원하는 API를 호출할 수 있다(= ROP).

## B. 호출 규약과 "첫 체인"

- (x86-64 SysV) 함수 인자 레지스터: `rdi, rsi, rdx, rcx, r8, r9`.
- “system("/bin/sh")” 같은 위험 예시는 **실습 금지**. 대신 **무해한 더미 함수 호출** 설계로 개념만 익힌다.

### 예시 토이 시나리오(개념)

- 바이너리에 아래 **무해한 함수**가 존재한다고 가정:
  ```c
  // 개념 예시: 유해한 외부 효과 없이 메시지만 남기는 함수
  void notify(const char *msg) { /* 로그 파일에 "OK: <msg>" 기록 */ }
  ```
- 목표: ROP로 `notify("hello")`를 호출한다.

### 필요한 가젯(개념 표기)

- `pop rdi ; ret`  → 첫 번째 인자(`rdi`)에 문자열 주소 넣기
- (PIE 비활성 가정이면) `.rodata`에 있는 `"hello"` 주소
- `ret` 패딩(스택 얼라인 문제 시)

> **체인 개념**
> `|overflow padding| saved RIP=pop_rdi ; ret | rdi="hello" | RIP=notify |`

**중요**: 위는 **개념**이다. 실제 주소(예: `0x40123a`)·오프셋·바이너리 이름·정확한 페이로드 바이트열은 제공하지 않는다.

## C. 체인 안정화 팁(개념)

- **스택 얼라인(16B)**: x86-64 SysV에서 call 시 스택 정렬이 어긋나면 크래시. `ret` 가젯 한 번 더 넣어 정렬 맞추기도 함.
- **NULL 포함 회피**: 입력이 C 문자열로 처리되면 0x00 바이트가 조기 종료를 유발. 인코딩/환경에 맞춰 설계.

## D. 방어자 관점 점검

- **Full RELRO + NOW**: GOT 덮기/지연 바인딩 악용 줄이기
- **sssp/Canary**: 스택 프레임 변조 감지
- **CET/Shadow Stack(하드웨어 CFI)**: `ret` 대상 정합성 검증
- **CFI/BTI**: 간접 분기 무결성 보강
- **fortify + 산티나이저 + fuzz**: 오버플로우 유발 입력 경로 선제 차단

---

# 실습 ②: ASLR/PIE 우회 기법(리크 → 계산 → ROP)(개념 설계 중심)

> 목표: ASLR/PIE 환경에서 공격자가 **주소를 알아내는 전형 흐름**과, 방어자가 **어디를 막아야 하는지**를 이해한다.
> 주의: 이하 설명은 **설계 흐름과 수학적 관계**에 국한된다. 실제 주소·심볼·완성 페이로드·자동화 스크립트는 의도적으로 제공하지 않는다.

## A. 전형적 우회 흐름(개념)

1) **리크(Leak)**: 프로세스 메모리의 **포인터/함수 주소/스택 포인터** 등을 에러 메시지·포맷 문자열·info leak 버그·/proc 노출 등으로 **유출**.
2) **계산(Calc)**: 유출된 주소에서 **모듈 베이스**를 역산.
   - 예시: `leaked_puts = libc_base + offset_puts` → ⇒ `libc_base = leaked_puts - offset_puts`
3) **체인(ROP)**: 계산한 베이스로부터 **가젯/함수 주소**를 도출해 체인 구성.
4) **실행(Exec)**: 오버플로우/취약 경로로 체인 투입 → 제어 흐름 획득.

> 모든 단계는 **실제 운영환경**이 아닌 **본인 소유 랩**에서만 허용된다.

## B. 리크의 형태(개념 분류)

- **형식 문자열 기반**: `%p`/`%s` 남용으로 스택/코드 포인터 노출
- **오류/로그 메시지**: 예외 메시지에 포인터를 그대로 출력
- **초기화 누락**: 힙/스택의 과거 포인터가 새 응답에 섞여 나옴
- **/proc/self/maps** 남용: 디버그 빌드/설정 오류로 맵 파일 유출

### 방어 체크

- 출력 포맷은 **리터럴**로 고정(`printf("%s", user)`), `%p`는 운영 빌드에서 금지
- 예외/로그 메시지 **민감정보 마스킹**
- **ASLR+PIE**만으로는 부족 — **정보누출을 근본 차단**해야 의미가 생김

## C. 베이스 계산(수학 관계만)

- (예시) `fn_addr = module_base + fn_off` ⇒ `module_base = fn_addr - fn_off`
- (예시) `gadget_addr = module_base + gadget_off`
- (예시) `rodata_str = module_base + rodata_off`
- 여기서 `*_off`는 **ELF/PE 심볼·디섹션으로 얻는 정적 오프셋**(랩 환경)

## D. ROP 체인 설계(개념 흐름)

1) **스택 컨트롤 확보**: 오버플로우/취약 API로 Saved RIP 덮기
2) **레지스터 세팅**: `pop rdi ; ret`, `pop rsi ; ret`, `pop rdx ; ret` …
3) **타겟 함수 호출**: (무해 함수 기준) `notify("hello")`
4) **정리(ret)**: 필요하다면 복귀/종료

**주의**: 실습에서 흔히 보는 “libc system 호출”은 **악용 소지가 커서 이 글에서 다루지 않는다.**

## E. PIE 차이(개념)

- **PIE 비활성**: 메인 바이너리 베이스가 고정(상대적으로 쉬움)
- **PIE 활성**: 메인도 공유 라이브러리처럼 랜덤 매핑 → 먼저 **메인 베이스**를 새어본 뒤(예: GOT/PLT 참조 위치 활용), 그 다음 체인을 설계

## F. 흔한 실패 원인(개념)

- **스택 정렬(16B)** 불일치
- **Bad byte 제약**(입력이 C문자열일 때 `0x00` 삽입 불가 등)
- **부분 RELRO/Full RELRO 오판**
- **rwx/메모리 보호 오해**: NX 때문에 쉘코드 실행이 안되나, 그건 **ROP 체인**과는 별개 개념

---

# 3.x “생산적 실습” 가이드 — 방어 중심으로 이해를 굳히자

다음은 **공격 성공**이 아니라 **방어 관점 학습**을 위한 권장 루틴이다. (주소·오프셋·익스플로잇 스크립트 없음)

1) **보호 옵션별 거동 관찰**
   - 같은 학습용 바이너리를 `-fstack-protector-strong`, `-D_FORTIFY_SOURCE=2`, `-fpie -pie`, `-Wl,-z,relro,-z,now` 조합으로 빌드해 **충돌 지점과 로그 차이**를 기록한다.
   - 목표: “어떤 보호가 어떤 증상을 만들고, 디버거/로그에서 어떻게 보이는지”를 체득.

2) **정보누출 예방 테스트**
   - 포맷 문자열을 리터럴로 고정했을 때와 아닐 때의 로그 차이를 비교.
   - 예외/오류 경로에서 포인터·주소가 노출되지 않도록 포매터를 교체.

3) **가젯 밀도 줄이기**
   - 컴파일러/링커 최적화·CFI·LTO 등을 조합했을 때 가젯 검색(정적만) 결과가 어떻게 달라지는지 **정량 메모**(함수 수, 짧은 `ret` 가젯 수 등).

4) **CET/CFI/Shadow Stack 체감**
   - 하드웨어 CET(지원 CPU)·Shadow Stack 옵션을 켜고, “비정상적인 ret 체인”이 즉시 차단되는지 크래시 로그(예: `#GP`, `Illegal instruction`) 관찰.

---

# 방어 체크리스트(현업 반영)

- **컴파일/링크 기본선**
  - `-fstack-protector-strong`, `-fpie -pie`, `-Wl,-z,relro,-z,now`, `-D_FORTIFY_SOURCE=2`
  - (테스트 빌드) `-fsanitize=address,undefined`
  - (가능 시) **CFI(LTO)**, **CET/Shadow Stack**, **W^X** 정책 엄수

- **코드 규약**
  - 모든 외부 입력은 **스키마/길이/범위 검증**
  - 포맷 문자열은 **리터럴로 고정**
  - 자원 수명: **해제 후 NULL**, UAF/Double-free 정적 분석 규칙 추가

- **운영/런타임**
  - **ASLR 강제** + core dump/오류 메시지의 **주소 마스킹**
  - Syscall/ETW/EBPF 등을 활용한 **비정상 제어흐름 감시**(연속적인 `ret`/gadget-like 패턴 탐지 연구)
  - **Crash triage**와 **자동 회귀 테스트** 파이프라인 구축

---

# 자주 묻는 질문(요약)

**Q. 실제 주소/오프셋/익스 스크립트를 보여줄 수 있나요?**
A. 아니요. 그 수준의 세부 절차는 오남용 위험이 높아 제공하지 않습니다. 이 문서는 **개념 이해와 방어 품질 향상**에 집중합니다.

**Q. 그래도 ROP를 실습하고 싶다면?**
A. **본인이 만든** 학습용 바이너리에서, CTF 플랫폼의 **명시 허용 범위** 내 퍼즐만 다루세요. 그때도 리포트는 **방어 관점**(근본 원인, 수정안, 재현 없는 위험 설명)에 집중하세요.

---

# 정리

- ROP는 **스택 제어 + 가젯 조합 + 호출 규약 이해**의 합이다.
- ASLR/PIE는 **정보누출 차단**과 함께 쓸 때 실질적 방어력이 나온다.
- 최신 방어(RELRO/CFI/CET/Shadow Stack/정적·동적 분석·fuzz)는 **겹겹이** 도입해야 한다.
