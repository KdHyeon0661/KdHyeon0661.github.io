---
layout: post
title: 형식언어와 오토마타 - 다중테이프 튜링 기계
date: 2025-07-30 21:20:23 +0900
category: 형식언어와 오토마타
---
# 다중테이프 튜링 기계와 다차원 튜링 기계

> **핵심 요약**
> - **계산 가능성(무엇을 계산할 수 있는가)** 는 그대로: 표준(단일 테이프) TM ≡ 다중테이프 TM ≡ 다차원 TM.
> - **효율성(시간·공간)** 은 달라질 수 있음: 표준 TM으로의 모사에 **상수~다항 오버헤드**가 붙는다(전형적으로 시간은 \(O(T^2)\), 공간은 \(O(S)\)).
> - **알고리즘 설계**는 다중테이프/다차원 모델이 훨씬 직관적: 복사·병합·2D 패턴 등.

---

## 표기와 전제

- 표준(단일 테이프) 결정적 TM:
  $$M=(Q,\Sigma,\Gamma,\delta,q_0,q_{\text{acc}},q_{\text{rej}})$$
  - \(\Sigma\subset\Gamma\), 공백(빈칸) 기호 \(\sqcup\in\Gamma\setminus\Sigma\)
  - \(\delta: Q\times\Gamma\to Q\times\Gamma\times\{L,R,S\}\)
- 입력 길이를 \(n\), 수행 시간(스텝 수)을 \(T(n)\), 사용 공간(서로 다른 칸 수)을 \(S(n)\)으로 표기.

---

## **다중테이프 튜링 기계** (k-tape TM)

### 정의

- **테이프가 \(k\)개**: 각 테이프에 **자체 헤드** 1개.
- 전이함수는 **동시에** \(k\)개 테이프의 읽기 기호를 본다:
  $$
  \delta: Q\times \Gamma^k \;\to\; Q \times \Gamma^k \times \{L,R,S\}^k .
  $$
- 입력은 보통 1번 테이프(나머지는 공백)로 주입.

### 표현력과 복잡도 (고전 정리)

- **표현력(Computability)**: 표준 TM과 **동등**.
- **시간 모사**: \(T(n)\) 시간의 k-테이프 TM은 **단일 테이프 TM**으로
  $$
  O\big(T(n)^2\big)\ \text{시간에 모사}
  $$
  가능(전형적 구성).
- **공간 모사**: k-테이프에서 \(S(n)\) 칸 사용 ⇒ 단일 테이프에서 **\(O(S(n))\)** 칸(상수 배)만으로 모사 가능.

> 직관: k-테이프 한 스텝을 단일 테이프에서 모사하려면, **모든 테이프 구획을 훑는 스캔**이 필요 → 스텝당 비용이 현재 사용 길이(≈\(O(T)\))에 비례 → \(O(T)\times T = O(T^2)\).

### 단일 테이프에서의 **모사 인코딩**

- **하나의 테이프**에 k개의 테이프 내용을 **구획**으로 나열, 각 구획에 **헤드 마크(^)**:
  ```
  |#1| a b c ^d e ␣ |#2| x ^y z ␣ |#3| ^p q r ␣ | ... |#k| ... |
  ```
- **한 스텝 모사**(스윕 알고리즘):
  1) 왼→오른쪽 스캔으로 각 구획 **헤드 아래 기호** 수집
  2) 유한제어에서 \(\delta\) 계산
  3) 다시 스캔하며 **새 기호 쓰기** + **마커 이동(L/R/S)**

### 다중테이프가 주는 실무적 이점

- **복사/병합/정렬**이 직관적 (입력·작업·출력 테이프 분리)
- **비파괴 스캔**: 한 테이프를 읽으며 다른 테이프에 결과 작성
- **트랜스듀싱/파싱**에서 스택·버퍼 역할을 자연스럽게 분리

---

## 튜링 기계**

### 2차원 TM 정의(대표형)

- 테이프 대신 **무한 격자** \(\mathbb{Z}^2\).
- 헤드 위치: 좌표 \((i,j)\).
- 이동: \(\{\text{N,S,E,W}\}\) (필요시 정지/대각선 포함).
- 전이:
  $$
  \delta: Q\times\Gamma \;\to\; Q\times\Gamma\times \{\text{N,S,E,W(,Stay)}\}.
  $$
- d차원은 \(\mathbb{Z}^d\)와 단위벡터 \(\pm e_1,\dots,\pm e_d\)로 일반화.

### 표현력과 복잡도

- **표현력**: 표준 TM과 동등(계산 가능한 함수/언어 동일).
- **시간 모사(개념적 상한)**: dD-TM의 \(T(n)\) 스텝을 1D TM이 **다항 시간**(전형적으로 \(O(T^2)\))에 모사.

### 2D → 1D **모사 인코딩**

- \(\mathbb{Z}^2\to\mathbb{N}\) **전단사 매핑**(예: 캔터 페어링 + \(\mathbb{Z}\to\mathbb{N}\) 변환)으로 각 좌표를 1D 인덱스로 부여:
  - \(\phi(z)=\begin{cases}2z,&z\ge 0\\ -2z-1,&z<0\end{cases}\) 로 \(\mathbb{Z}\to\mathbb{N}\)
  - \( \pi(x,y)=\frac{(x+y)(x+y+1)}{2}+y \) (캔터 페어링, 필요시 \(\phi\)로 사전 변환)
- 헤드 이동(N/S/E/W)은 **새 인덱스로 점프**해야 하는데, 1D TM은 임의접근이 없어 **해당 위치까지 스캔** → 이동당 선형~준선형 비용 → 총 \(O(T^2)\) 근사.

> **희소 표현**: 방문 칸만 구분자/연결리스트로 유지하면 인접 이동은 짧은 탐색으로 처리(여전히 다항).

---

## 두 모델 비교 요약

| 항목 | 다중테이프 TM | 다차원 TM |
|---|---|---|
| 핵심 구조 | 테이프 \(k\)개 + 각 헤드 | \(\mathbb{Z}^d\) 격자 + (보통) 1 헤드 |
| 표현력 | 표준 TM과 동등 | 표준 TM과 동등 |
| 1D TM으로 모사 시간 | 전형적 \(O(T^2)\) | 전형적 \(O(T^2)\) |
| 공간 모사 | \(O(S)\) | 방문 칸 기준 다항 |
| 설계 장점 | 복사·병합·파이프라인 | 2D 규칙·패턴 자연스러움 |

---

## 복잡도 **증명 스케치**

### k-테이프 → 1테이프 시간 \(O(T^2)\)

- 길이 \(L_t\)는 t번째 스텝 직후 사용 중인 총 칸 수, \(L_t=O(t)\).
- 한 스텝 모사에 **양방향 스캔** 비용이 \(O(L_t)\).
- 총 시간:
  $$
  \sum_{t=1}^{T(n)} O(L_t) \;=\; O\!\left(\sum_{t=1}^{T(n)} t\right)\;=\;O(T(n)^2).
  $$

### 공간 \(O(S)\)

- k개 테이프 내용을 **구획+구분자**로 1테이프에 저장 ⇒ 총 칸 수는 상수 배 증가 ⇒ \(O(S)\).

### 근사

- 헤드가 원점에서 맨해튼 거리 \(r\)인 칸으로 이동할 때, 1D 인코딩 위치까지 선형 스캔 ⇒ 이동당 \(O(r)\).
- \(r=O(T)\), 총 이동 \(T\)회 ⇒ \(O(T^2)\).

---

## **알고리즘 예시**(다중테이프 기준)

### 복사(Copy): 입력을 제2테이프로 그대로 복제

- **2-테이프 TM**:
  1테이프에서 오른쪽으로 진행하며 읽은 기호를 2테이프에 기록, 2테이프 헤드는 같이 우로.

**의사코드**
```text
tape1: input w□...
tape2: □...
loop:
  a := read(tape1)
  if a == □: goto HALT
  write(tape2, a)
  moveRight(tape1); moveRight(tape2)
HALT: accept
```

### (NPDA가 가능, DCFL은 아님)

- **2-테이프 TM** 접근(비결정적 또는 구분자 사용):
  - 입력을 2테이프에 **역순 복사** 후, **동시에 좌→우 비교**.

**러프 아이디어**
```text
# ① 테이프2에 역복사: 입력 우측 끝까지 진행 후 되돌아오며 쓰기
# ② 테이프1, 테이프2를 동시에 좌→우 스캔하며 불일치시 reject, 끝까지 OK면 accept

```
> 결정적 분할점(중앙) 미확정 때문에 **DPDA/LL/LR 결정성**은 일반적으로 불가(DCFL 아님)임을 상기.

### 두 정렬열을 제3테이프로 병합

```text
# tape1: sorted A, tape2: sorted B, tape3: output

a := read(tape1); b := read(tape2)
while a != □ or b != □:
  if b == □ or (a != □ and a <= b):
     write(tape3, a); a := next(tape1)
  else:
     write(tape3, b); b := next(tape2)
accept
```

---

## **실전 구현 예제(Python)** — 미니 **다중테이프 TM 시뮬레이터**

> 교육용 간단 버전: 다중테이프를 리스트로, 테이프 헤드는 인덱스로 표현. 전이는 딕셔너리로.

```python
# -*- coding: utf-8 -*-

from typing import Dict, Tuple, List

BLANK = '□'

Move = {'L': -1, 'S': 0, 'R': 1}

class MultiTapeTM:
    def __init__(self, k: int, delta: Dict, q0: str, qacc: str, qrej: str):
        self.k = k
        self.delta = delta  # key: (q, sym1, ..., symk) -> (q', out1,...,outk, m1,...,mk)
        self.q = q0
        self.qacc = qacc
        self.qrej = qrej
        self.tapes: List[List[str]] = [[BLANK] for _ in range(k)]
        self.heads: List[int] = [0]*k

    def load_input(self, s: str, tape_id: int = 0):
        self.tapes[tape_id] = list(s if s else '') + [BLANK]
        self.heads[tape_id] = 0

    def _readk(self):
        syms = []
        for i in range(self.k):
            h = self.heads[i]
            if h < 0:
                # extend to the left
                self.tapes[i] = [BLANK]*(-h) + self.tapes[i]
                self.heads[i] = 0
                h = 0
            if h >= len(self.tapes[i]):
                self.tapes[i] += [BLANK]*(h - len(self.tapes[i]) + 1)
            syms.append(self.tapes[i][h])
        return tuple(syms)

    def step(self) -> bool:
        if self.q in (self.qacc, self.qrej):
            return False
        read = self._readk()
        key = (self.q,) + read
        if key not in self.delta:
            self.q = self.qrej
            return False
        out = self.delta[key]
        q1 = out[0]
        writes = out[1:1+self.k]
        moves  = out[1+self.k:]
        # write
        for i in range(self.k):
            h = self.heads[i]
            self.tapes[i][h] = writes[i]
        # move
        for i in range(self.k):
            self.heads[i] += Move[moves[i]]
        self.q = q1
        return True

    def run(self, max_steps=10_000):
        steps = 0
        while steps < max_steps and self.q not in (self.qacc, self.qrej):
            if not self.step(): break
            steps += 1
        return self.q == self.qacc, steps, [''.join(t).rstrip(BLANK) for t in self.tapes]

# ===
# 상태: q0: 읽기 진행, q1: 입력 끝 -> accept

delta = {}
# 규칙:
# -> (q0, a, a, R, R)   for a in {0,1}

for a in ['0','1']:
    delta[('q0', a, BLANK)] = ('q0', a, a, 'R','R')
# -> (qacc, □, x, S, S)

for x in ['0','1', BLANK]:
    delta[('q0', BLANK, x)] = ('qacc', BLANK, x, 'S','S')

mtm = MultiTapeTM(2, delta, 'q0', 'qacc', 'qrej')
mtm.load_input('10110', tape_id=0)
ok, steps, tapes = mtm.run()
print(ok, steps, tapes)  # True, [..., '10110']
```

- 응용: 위 틀로 **역복사**, **병합**, **패턴 치환** 등도 손쉽게 구성 가능.

---

## **2차원 TM 미니 시뮬레이터**(교육용)

> 2D 격자(딕셔너리) + 헤드 좌표 \((i,j)\). 전이는 `(상태, 심볼)->(상태', 쓰기, 이동)`.

```python
# -*- coding: utf-8 -*-

from typing import Dict, Tuple

BLANK = '□'

DIR = {'N': (0,1), 'S': (0,-1), 'E': (1,0), 'W': (-1,0), 'S0': (0,0)}  # S0 = Stay

class TM2D:
    def __init__(self, delta: Dict, q0: str, qacc: str, qrej: str):
        self.delta = delta
        self.q = q0
        self.qacc = qacc
        self.qrej = qrej
        self.grid = {}  # (i,j) -> sym
        self.pos = (0,0)

    def read(self):
        return self.grid.get(self.pos, BLANK)

    def write(self, a):
        if a == BLANK:
            self.grid.pop(self.pos, None)
        else:
            self.grid[self.pos] = a

    def step(self) -> bool:
        if self.q in (self.qacc, self.qrej):
            return False
        a = self.read()
        key = (self.q, a)
        if key not in self.delta:
            self.q = self.qrej; return False
        q1, b, mv = self.delta[key]
        self.write(b)
        di, dj = DIR[mv]
        x, y = self.pos
        self.pos = (x+di, y+dj)
        self.q = q1
        return True

    def run(self, max_steps=10_000):
        t = 0
        while t < max_steps and self.q not in (self.qacc, self.qrej):
            if not self.step(): break
            t += 1
        return self.q == self.qacc, t, dict(self.grid), self.pos

# === 예제: "직선 그리기" — (0,0)에서 동쪽으로 'x' n개 출력 후 수용 ===
# 입력은 없다고 가정, BLANK만 있음. 상태 qk에서 x를 쓰고 E로 이동, 카운트 감소.
# 간단히 n=4로 하드코딩(교육용)

delta = {
    ('q0', BLANK): ('q1', 'x', 'E'),
    ('q1', BLANK): ('q2', 'x', 'E'),
    ('q2', BLANK): ('q3', 'x', 'E'),
    ('q3', BLANK): ('qacc','x','S0'),
}
tm2d = TM2D(delta, 'q0', 'qacc', 'qrej')
ok, steps, grid, pos = tm2d.run()
print(ok, steps, sorted(grid.items())[:6])  # True, 4, [((0,0),'x'),((1,0),'x'),...]
```

- 위 구조를 바탕으로 **N/S/E/W 이웃 규칙**(예: 간단한 셀룰러 오토마타 스텝)도 모델링 가능.

---

## **복잡도 클래스** 관점의 강건성

- **P, PSPACE, RE/REC** 등의 ‘큰’ 클래스는 **다중테이프/다차원 여부와 무관**.
- 이론/알고리즘 분석에서는 **다중테이프 TM**을 표준 시간 모델로 삼는 경우가 많음(자연스러운 상수·다항 인자).

> 보조 사실
> - **2-방향 무한 테이프 vs 1-방향**: 상수~선형 오버헤드로 상호 모사.
> - **비결정성**(NTM)도 유사: 다중테이프/다차원화로 **표현력 변화 없음**(폴리오버헤드 관계).

---

## 모사 절차 도식(요약)

### k-테이프 → 1테이프 (1 스텝)

```text
# 수집
# := δ(q,(a1..ak))
# [Phase C] 쓰기/이동: 다시 스캔하며 각 구획 caret 위치에 bi 기록, caret을 mi로 이동
# q := q'

```

### 2D → 1D (좌표 인코딩+희소 저장)

```text
# 블록을 구분자로 정렬 저장

loop:
  a := lookup(indexOf(i,j)) or BLANK
  (q', b, dir) := δ(q, a)
  write(indexOf(i,j), b)
  (i,j) := (i,j) + step(dir)   # N/S/E/W
  q := q'
```

---

## & 팁

- **Q. 다중테이프면 항상 빠른가요?**
  A. ‘상수~다항’ 이득은 있지만 **계산 가능성의 경계**는 동일. 최악 이론상 단일테이프로도 \(O(T^2)\) 내 모사됨.

- **Q. 공간은 왜 \(O(S)\) 보장되나요?**
  A. 각 테이프 내용을 **구획+구분자**로 붙여 저장하면, 실제로 사용한 칸만 합치므로 **상수 배**만 증가.

- **Q. 2D가 더 강력해 보이는데요?**
  A. 표현력은 동일. 2D는 **설계 편의**(국소 규칙·이웃) + 상수 인자 이점 정도.

- **Q. 실제 파서는 PDA(스택)인데, 다중테이프랑 어떤 관계?**
  A. 다중테이프는 **임의 다수 버퍼**를 갖는 TM 모델. **PDA**는 스택 1개라는 강한 제약(=CFL). 목적과 위상 자체가 다르다.

---

## 손으로 따라 해보는 **작은 실습 시나리오**

### 2-테이프 역복사 후 비교(팰린드롬 스타일)

1) 테이프1 끝까지 이동 → 되돌아오며 테이프2에 역순으로 기록
2) 두 테이프를 좌→우 동기 스캔하여 불일치 검사

**전이 스케치**
```text
q0: (t1 != □) -> move R on tape1
q0: (t1 == □) -> q1, move L on tape1  # 끝 도달
q1: copy back to tape2 while moving L on tape1 & R on tape2
q2: compare left-to-right, mismatch -> reject, end -> accept
```
> 결정성/언어 클래스 관점의 교훈: **중간 경계의 결정적 인지**가 가능하지 않으면 DCFL이 아닐 수 있음.

### 2D “+” 표시 그리기

- 원점에서 동/서/남/북으로 일정 길이 ‘x’ 출력 후 수용.
- 1D 모사에서는 각 팔을 순차적으로 그리되, 좌표 인덱스에 해당하는 블록을 찾아가며 쓴다.

---

## 마무리 정리

- **계산 가능성 동일**: 표준 TM ≡ 다중테이프 TM ≡ 다차원 TM
- **효율 차이는 다항 범위**: 전형적 시간 \(O(T^2)\), 공간 \(O(S)\) 오버헤드
- **설계 이점 큼**: 다중테이프(복사·병합), 다차원(격자 규칙)이 직관적
- **복잡도 강건성**: P/PSPACE/RE 등 클래스는 변하지 않는다

> 실무/학습 조언
> - 아이디어 구상·의사코드는 **다중테이프·2D**로 생각하되,
>   증명/복잡도 표준화는 **단일테이프**로 환원해 \(O(T^2)\)/\(O(S)\) 범위를 명시하라.
> - 교육·데모에는 위 **파이썬 미니 시뮬레이터**를 변형해 실험해보면 이해가 빨라진다.
