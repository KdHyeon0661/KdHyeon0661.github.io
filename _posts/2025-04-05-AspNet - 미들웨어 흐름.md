---
layout: post
title: AspNet - 미들웨어 흐름
date: 2025-04-05 21:20:23 +0900
category: AspNet
---
# ASP.NET Core 기본 미들웨어 흐름

## 0. 한 페이지 요약

- **파이프라인은 순서가 전부**: 위에서 아래로 흐르며, 응답을 쓰면 그 지점에서 **종료**될 수 있다.
- **최상단**엔 예외/보안/리다이렉션 계열(예: `UseExceptionHandler`, `UseHsts`, `UseHttpsRedirection`)을 둔다.
- **정적 파일**은 라우팅 앞(`UseRouting`)에 두어 비용을 최소화한다.
- **라우팅 이후**에 **CORS → 인증 → 권한 → 엔드포인트** 순서가 핵심 패턴이다.
- **.NET 7/8**에선 보통 `UseEndpoints` 대신 **`app.MapControllers()` / `app.MapRazorPages()`**를 쓴다(엔드포인트 라우팅).
- **단축/분기**: `Use`, `Run`, `Map`, `MapWhen`/`UseWhen`을 적절히 섞어 효율/분리도를 높인다.
- **문제의 80%**는 **순서 오류**와 **응답을 쓴 뒤 이후 미들웨어가 실행되는 오해**에서 발생한다.

---

## 1. 미들웨어란? (개념·수학적 비유)

- **정의**: 요청(Request)과 응답(Response) 사이를 통과하는 **연속된 함수(ƒ)들의 합성**.
- **형태**: `Func<HttpContext, Task> next`를 인자로 받아, 전/후 처리 가능.

수학적 비유(조합 함수):
$$
Pipeline = f_n \circ f_{n-1} \circ \cdots \circ f_2 \circ f_1
$$
- 각 \( f_i \)는 **미들웨어**.
- 앞 미들웨어가 응답을 **완료**하면 뒤 함수로 **전달되지 않는다**(Short-circuit).

---

## 2. 최소 예시(사용자 제공 흐름 확장)

### 2.1 기본 형태(.NET 6 스타일)

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorPages();
builder.Services.AddControllers();

var app = builder.Build();

app.UseExceptionHandler("/Error");      // 0. 전역 예외 처리 (개발: UseDeveloperExceptionPage)
app.UseHsts();                          // 0-1. HSTS(프로덕션)
app.UseHttpsRedirection();              // 0-2. HTTP → HTTPS 리다이렉션

app.UseStaticFiles();                   // 1. 정적 파일 (wwwroot), 있으면 여기서 응답하고 종료

app.UseRouting();                       // 2. 경로 분석 (Endpoint 선택 전 단계)

app.UseCors("Default");                 // 2-1. CORS (라우팅 이후, 인증 이전 권장)
app.UseAuthentication();                // 3. 인증 (HttpContext.User 구성)
app.UseAuthorization();                 // 4. 권한 (User에 대한 정책/역할 검사)

app.MapRazorPages();                    // 5. 엔드포인트 매핑 (Minimal/현대 스타일)
app.MapControllers();                   // 5. API/컨트롤러 매핑

app.Run();
```

> **주의**: .NET 6 템플릿의 `UseEndpoints`는 `.NET 7/8`에선 보통 **직접 Map** 호출로 대체한다.
> 여전히 `UseEndpoints(endpoints => endpoints.MapControllers())`는 동작하지만, `app.Map*()`가 최신 패턴.

### 2.2 .NET 6 vs .NET 7/8 비교

| 항목                  | .NET 6 (기존 스타일)                            | .NET 7/8 (권장)                         |
|-----------------------|--------------------------------------------------|------------------------------------------|
| 엔드포인트 매핑       | `app.UseEndpoints(e => e.MapControllers())`     | `app.MapControllers()`                   |
| 라우팅 초기화         | `app.UseRouting()` 필요                          | 내부적으로 필요하지만 Map 중심으로 단순화 |
| Minimal API           | 혼용 가능                                        | **기본 권장 패턴**                        |

---

## 3. 미들웨어의 해부학: Use / Run / Map / UseWhen

### 3.1 `Use` — 전/후 처리 + 다음으로 흐름 전달

```csharp
app.Use(async (ctx, next) =>
{
    var started = Stopwatch.GetTimestamp();
    await next(); // 다음 미들웨어로
    var elapsedMs = (Stopwatch.GetTimestamp() - started) * 1000.0 / Stopwatch.Frequency;
    ctx.Response.Headers["X-Elapsed"] = $"{elapsedMs:F1}ms";
});
```

### 3.2 `Run` — 파이프라인 **종료점**(next 없음)

```csharp
app.Run(async ctx =>
{
    await ctx.Response.WriteAsync("끝 미들웨어");
});
```

> `Run`은 **마지막** 또는 특정 분기에서 **단축 종료** 용도로만 사용.

### 3.3 `Map` — **경로 접두어** 분기

```csharp
app.Map("/health", branch =>
{
    branch.Run(async ctx =>
    {
        ctx.Response.ContentType = "application/json";
        await ctx.Response.WriteAsync("{\"status\":\"Healthy\"}");
    });
});
```

### 3.4 `UseWhen` / `MapWhen` — 조건 분기

```csharp
app.UseWhen(ctx => ctx.Request.Path.StartsWithSegments("/admin"), admin =>
{
    admin.Use(async (ctx, next) =>
    {
        // 관리자 영역의 추가 로깅/보안 헤더
        ctx.Response.Headers["X-Area"] = "Admin";
        await next();
    });
});
```

---

## 4. Short-circuit(단축)과 순서의 법칙

### 4.1 단축의 예

```csharp
app.Use(async (ctx, next) =>
{
    if (ctx.Request.Path == "/blocked")
    {
        ctx.Response.StatusCode = StatusCodes.Status403Forbidden;
        await ctx.Response.WriteAsync("Forbidden");
        return; // 여기서 단축: 뒤 미들웨어는 실행되지 않음
    }
    await next();
});
```

### 4.2 순서 오류가 부르는 문제

- `UseAuthorization()`가 `UseRouting()` **앞**에 있으면: **정책 평가할 엔드포인트 정보 부재** → 항상 실패/무시.
- `UseCors()`를 **라우팅 이전**에 쓰면: 최신 엔드포인트 라우팅과의 결합에서 예측 불가. 일반적으로 **라우팅 후, 인증 전에** 둔다.
- `UseStaticFiles()`를 맨 아래 두면: 정적 파일 요청도 라우팅/권한 등 **모든** 미들웨어를 거쳐 성능 저하.

---

## 5. 핵심 미들웨어 카탈로그(실전 배치 순서 포함)

아래는 실무에서 많이 쓰는 **표준 배치 순서**와 권장 주석.

```csharp
// 0. 최상단 — 예외/보안/리다이렉션
app.UseExceptionHandler("/Error");   // 또는 개발: app.UseDeveloperExceptionPage()
app.UseHsts();                       // 프로덕션 권장
app.UseHttpsRedirection();           // HTTP → HTTPS

// 1. 기능/성능 — 압축/캐시/정적파일
app.UseResponseCompression();        // 응답 압축 (등록 필요)
app.UseStaticFiles();                // wwwroot 정적 파일

// 2. 라우팅
app.UseRouting();

// 3. CORS/로컬라이제이션
app.UseCors("Default");              // 라우팅 후, 인증 전
app.UseRequestLocalization();        // 문화권/언어

// 4. 보안 — 인증 → 권한
app.UseAuthentication();
app.UseAuthorization();

// 5. 속도 제한/헬스체크/엔드포인트
app.UseRateLimiter();                // 필요 시 (등록 필요)
app.MapHealthChecks("/healthz");     // 헬스 체크
app.MapControllers();
app.MapRazorPages();
```

> **ResponseCaching/Compression**은 정적/동적 응답 특성에 따라 배치 및 설정이 상이하므로 아래 세부 장에서 예시 제공.

---

## 6. 예외 처리: `UseExceptionHandler` vs `UseDeveloperExceptionPage`

```csharp
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error"); // Razor Page/Controller에서 /Error 처리
    app.UseHsts();
}
else
{
    app.UseDeveloperExceptionPage();   // 개발 중 상세 스택
}
```

- API에서 **문제 상세(JSON)**를 반환하려면 `ProblemDetails` 규격으로 통일:

```csharp
app.UseExceptionHandler(errorApp =>
{
    errorApp.Run(async ctx =>
    {
        ctx.Response.StatusCode = 500;
        ctx.Response.ContentType = "application/problem+json";
        await ctx.Response.WriteAsJsonAsync(new
        {
            type = "about:blank",
            title = "Internal Server Error",
            status = 500,
            detail = "Unexpected error occurred."
        });
    });
});
```

---

## 7. 정적 파일: `UseStaticFiles()` 고급

### 7.1 기본

```csharp
app.UseStaticFiles(); // wwwroot
```

### 7.2 커스텀 디렉토리/캐시 헤더

```csharp
app.UseStaticFiles(new StaticFileOptions
{
    FileProvider = new PhysicalFileProvider(Path.Combine(app.Environment.ContentRootPath, "assets")),
    RequestPath = "/assets",
    OnPrepareResponse = ctx =>
    {
        ctx.Context.Response.Headers["Cache-Control"] = "public,max-age=86400";
    }
});
```

### 7.3 단축 주의
- 정적 파일이 **존재하면** 바로 응답하고 **파이프라인 종료**.
- 정적 파일 경로와 API 경로 충돌을 피하도록 **RequestPath**를 잘 구분.

---

## 8. 라우팅/엔드포인트: `UseRouting`과 `Map*`의 역할

- `UseRouting()`은 **엔드포인트 선택 준비**.
- `MapControllers()`/`MapRazorPages()`/Minimal API `app.MapGet(...)`는 실제 엔드포인트를 **등록**.
- 정책/권한은 **라우팅 후**에야 평가 가능.

### 8.1 Minimal API 예시(권한 포함)

```csharp
app.MapGroup("/api")
   .RequireAuthorization()
   .MapGet("/me", (HttpContext ctx) => new { user = ctx.User.Identity?.Name })
   .WithName("GetMe");
```

---

## 9. 인증/권한: 쿠키/JWT/정책 결합

- **순서**: `UseAuthentication()` → `UseAuthorization()`.
- 컨트롤러/페이지/Minimal API에 `[Authorize]` 또는 `.RequireAuthorization("policy")` 적용.

```csharp
app.MapGet("/admin", () => "ok")
   .RequireAuthorization(new AuthorizeAttribute { Roles = "Admin" });
```

---

## 10. CORS: 위치/예시/실수 방지

- 일반적으로 **라우팅 후, 인증 전**에 위치.

```csharp
builder.Services.AddCors(o =>
{
    o.AddPolicy("Default", p => p
        .WithOrigins("https://app.example.com")
        .AllowAnyHeader()
        .AllowAnyMethod()
        .AllowCredentials());
});

app.UseRouting();
app.UseCors("Default");
app.UseAuthentication();
app.UseAuthorization();
```

- 개발 편의의 `AllowAnyOrigin()+AllowCredentials()` **금지**(브라우저 정책/보안 문제).

---

## 11. 성능 미들웨어: 압축/캐싱/레이트 리미트

### 11.1 응답 압축

```csharp
builder.Services.AddResponseCompression(options =>
{
    options.EnableForHttps = true;
});

app.UseResponseCompression(); // 보통 정적 파일/라우팅 이전
```

### 11.2 응답 캐시(ResponseCaching)

```csharp
builder.Services.AddResponseCaching();
app.UseResponseCaching(); // 라우팅 앞/뒤 모두 가능하나 응답 헤더 의존성 주의

app.MapGet("/cached", (HttpContext ctx) =>
{
    ctx.Response.GetTypedHeaders().CacheControl = new()
    {
        Public = true,
        MaxAge = TimeSpan.FromSeconds(30)
    };
    return Results.Text(DateTime.UtcNow.ToString("O"));
});
```

### 11.3 속도 제한(.NET 7+)

```csharp
builder.Services.AddRateLimiter(_ =>
    _.AddFixedWindowLimiter(policyName: "fixed", options =>
    {
        options.Window = TimeSpan.FromSeconds(10);
        options.PermitLimit = 20;
        options.QueueProcessingOrder = System.Threading.RateLimiting.QueueProcessingOrder.OldestFirst;
        options.QueueLimit = 5;
    }));

app.UseRateLimiter();

app.MapGet("/hot", () => "ok").RequireRateLimiting("fixed");
```

---

## 12. 조건 분기: `MapWhen`/`UseWhen` 실전

```csharp
app.MapWhen(ctx => ctx.Request.Path.StartsWithSegments("/internal"), internalBranch =>
{
    internalBranch.UseAuthorization(); // 내부 엔드포인트 별도 정책
    internalBranch.MapGet("/internal/ping", () => "pong");
});
```

- **운영 팁**: 내부/관리자/헬스 엔드포인트를 별도 가지로 분리하면 **보안/로깅 정책 분리**가 쉬워진다.

---

## 13. 요청/응답 본문 접근(중급)

- **주의**: 요청 본문은 일반적으로 **한 번만** 읽을 수 있다. 재읽기 필요 시 **EnableBuffering**.

```csharp
app.Use(async (ctx, next) =>
{
    if (ctx.Request.ContentLength > 0 && ctx.Request.Body.CanSeek == false)
    {
        ctx.Request.EnableBuffering();
        using var reader = new StreamReader(ctx.Request.Body, leaveOpen: true);
        var body = await reader.ReadToEndAsync();
        ctx.Request.Body.Position = 0; // 원위치
        // body 로깅/검사
    }
    await next();
});
```

- 응답 본문 가로채기(성능/메모리 영향 주의)

```csharp
app.Use(async (ctx, next) =>
{
    var original = ctx.Response.Body;
    await using var mem = new MemoryStream();
    ctx.Response.Body = mem;

    await next();

    mem.Position = 0;
    var text = new StreamReader(mem).ReadToEnd();
    mem.Position = 0;

    await mem.CopyToAsync(original);
    ctx.Response.Body = original;
});
```

---

## 14. 보안 헤더/HSTS/HTTPS

```csharp
app.UseHsts();            // Strict-Transport-Security
app.UseHttpsRedirection();

// 커스텀 보안 헤더
app.Use(async (ctx, next) =>
{
    ctx.Response.Headers["X-Content-Type-Options"] = "nosniff";
    ctx.Response.Headers["X-Frame-Options"] = "DENY";
    ctx.Response.Headers["Referrer-Policy"] = "no-referrer";
    await next();
});
```

---

## 15. 로컬라이제이션/문화권

```csharp
builder.Services.Configure<RequestLocalizationOptions>(o =>
{
    var cultures = new[] { "ko-KR", "en-US" };
    o.SetDefaultCulture("ko-KR")
     .AddSupportedCultures(cultures)
     .AddSupportedUICultures(cultures);
});

app.UseRequestLocalization();
```

---

## 16. 헬스체크/엔드포인트 메타데이터

```csharp
builder.Services.AddHealthChecks()
    .AddCheck("self", () => HealthCheckResult.Healthy());

app.MapHealthChecks("/healthz"); // 로드밸런서/쿠버네티스 프로브용
```

---

## 17. `UseEndpoints` 레거시 패턴(.NET 6)과의 정확한 연결

사용자가 제공한 코드는 **.NET 6 스타일**로, 아래처럼 동작한다:

```csharp
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();

app.UseEndpoints(endpoints =>
{
    endpoints.MapRazorPages();
    endpoints.MapControllers();
});
```

- **의미**: `UseRouting`으로 엔드포인트(후보)를 해석하고, 이후 **인증/권한**을 통과한 뒤 `UseEndpoints`에서 **실제 실행**.
- **최신 권장**: `app.MapRazorPages()` / `app.MapControllers()`로 **직접** 매핑. 내부적으로 같은 엔드포인트 라우팅을 사용한다.

---

## 18. 전체 샘플 — MVC + API + 정적 + 보안 + 성능

```csharp
var builder = WebApplication.CreateBuilder(args);

// Services
builder.Services.AddControllersWithViews();
builder.Services.AddRazorPages();
builder.Services.AddResponseCompression();
builder.Services.AddResponseCaching();
builder.Services.AddCors(o => o.AddPolicy("Default", p => p
    .WithOrigins("https://app.example.com")
    .AllowAnyHeader()
    .AllowAnyMethod()
    .AllowCredentials()));

// TODO: AddAuthentication/AddAuthorization... (JWT/쿠키/정책)

var app = builder.Build();

// Top: error/hsts/https
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}
else
{
    app.UseDeveloperExceptionPage();
}
app.UseHttpsRedirection();

// Perf: compression/static/caching
app.UseResponseCompression();
app.UseStaticFiles();
app.UseResponseCaching();

// Routing
app.UseRouting();

// Cross-cutting
app.UseCors("Default");

// Security
app.UseAuthentication();
app.UseAuthorization();

// Endpoints
app.MapControllers();
app.MapRazorPages();

app.Run();
```

---

## 19. 단위 테스트용 가벼운 커스텀 미들웨어(로깅/상관ID)

```csharp
public class CorrelationMiddleware
{
    private const string HeaderName = "X-Correlation-Id";
    private readonly RequestDelegate _next;
    public CorrelationMiddleware(RequestDelegate next) => _next = next;

    public async Task Invoke(HttpContext ctx)
    {
        if (!ctx.Request.Headers.TryGetValue(HeaderName, out var id) || string.IsNullOrWhiteSpace(id))
        {
            id = Guid.NewGuid().ToString("n");
            ctx.Request.Headers[HeaderName] = id;
        }
        ctx.Response.Headers[HeaderName] = id!;
        await _next(ctx);
    }
}

public static class CorrelationExtensions
{
    public static IApplicationBuilder UseCorrelation(this IApplicationBuilder app)
        => app.UseMiddleware<CorrelationMiddleware>();
}
```

```csharp
// Program.cs
app.UseCorrelation();
```

> 분산 추적/로그 상관관계 분석에 유용.

---

## 20. 트러블슈팅 체크리스트

| 증상 | 원인 | 해결 |
|------|------|------|
| 404인데 컨트롤러 액션이 안 잡힘 | `UseRouting`/`MapControllers` 누락 또는 순서 오류 | 라우팅 순서 점검, 최신 패턴 적용 |
| 401/403가 항상 뜸 | `UseAuthorization`가 라우팅 앞 | `UseRouting` → `UseAuthentication` → `UseAuthorization` 순서 유지 |
| CORS 오류(프리플라이트 실패) | 위치/정책 부적절 | `UseCors`를 라우팅 후·인증 전 배치, Origin/Headers/Methods 확인 |
| 정적 파일이 느림 | 정적 파일이 라우팅 뒤/권한 뒤 | `UseStaticFiles`를 상단 배치 |
| 예외 응답이 HTML | 개발/프로드 예외 미들웨어 혼동 | `UseExceptionHandler`로 API용 JSON 표준화 |

---

## 결론

- **미들웨어는 합성 함수**이며, **순서**와 **단축**이 핵심이다.
- 상단엔 **예외/보안/리다이렉션**, 그 다음 **정적/성능**, 이후 **라우팅→CORS→인증→권한**, 마지막으로 **엔드포인트**가 **안전한 기본형**.
- 분기(`Map`/`UseWhen`)와 정책/권한을 결합해 **깨끗하고 빠른 파이프라인**을 설계하라.
- .NET 7/8에선 `UseEndpoints`보다 **`app.Map*()` 스타일**이 자연스럽고 유지보수에 강하다.
