---
layout: post
title: 데이터 통신 - Switching (1)
date: 2024-07-27 14:20:23 +0900
category: DataCommunication
---
# Switching — Circuit, Packet, Message Switching과 TCP/IP 계층에서의 위치

> 이 글은 데이터 통신/네트워킹 전체 흐름에서 **“스위칭(switching)”**이 어떤 문제를 해결하는지, 그리고 **세 가지 스위칭 방식(circuit / packet / message)** 과 **전통적인 회선교환망(circuit-switched networks)** 의 구조·지연·효율을 정리한 것이다.  
> 앞에서 다룬 물리 계층/링크 계층/라우팅 개념을 **“실제 네트워크가 어떻게 공유 매체를 나누어 쓰는지”** 관점에서 확장하는 느낌으로 읽으면 좋다.

---

## 8.1 Introduction

네트워크의 가장 근본적인 문제는 단순하다.

> “서로 멀리 떨어진 n개의 노드를 **제한된 링크 수**만으로 모두 서로 통신 가능하게 만들려면 어떻게 해야 하는가?”

가장 단순한 방법은 **모든 노드 쌍을 전용 선으로 직접 연결**하는 것이다. 하지만 이는 $$O(n^2)$$ 개의 링크가 필요하므로 현실적으로 불가능하다. 따라서 실제 네트워크는 **“스위치(switch)”라는 중간 노드**를 두고, **링크 수는 적게 유지하면서도 논리적으로는 모든 노드가 서로 통신 가능한 구조**를 만든다.

이때 **스위치들이 “누구의 데이터를 언제, 어느 링크로 보낼지”를 결정하는 방식**을 **스위칭 기법(switching technique)** 이라고 부른다.

---

### 8.1.1 Three Methods of Switching

현대 네트워크 이론에서 보통 다음 **세 가지 스위칭 방식**을 이야기한다.:contentReference[oaicite:0]{index=0}

1. **Circuit Switching (회선 교환)**
2. **Packet Switching (패킷 교환)**
3. **Message Switching (메시지 교환)**

#### 1) Circuit Switching (회선 교환)

- 통신 세션 동안 **두 단말 사이에 전용 회선(논리/물리 경로)을 미리 설정**한다.
- 설정된 회선 위에서는, 통신이 끝날 때까지 **대역폭이 고정적으로 예약**된다.
- 대표적인 예: **PSTN(공중 전화망)**, 고전적인 유선 음성 통화, 일부 전용선(leased line) 서비스.:contentReference[oaicite:1]{index=1}

핵심 특징:

- **연결 지향 (connection-oriented)**: “전화 걸기 → 통화 → 끊기”의 3단계.
- 한 번 연결이 설정되면, 경로는 **고정**이고 패킷 헤더에 별도의 라우팅 정보가 거의 필요 없다.
- **지연 변동이 매우 작음**(jitter가 거의 없음) → 실시간 음성·옛날 회선 기반 영상 전송에 적합.

#### 2) Packet Switching (패킷 교환)

- 데이터를 **작은 단위의 패킷(packet)** 으로 나누고, 각 패킷이 **독립적으로 라우터/스위치들을 통과**한다.
- 각 패킷은 자신의 **헤더에 목적지 주소**를 담고, **라우팅 알고리즘**에 의해 경로가 동적으로 결정된다.
- 대표적인 예: **Internet (IP 네트워크)**, 기업용 LAN, 대부분의 현대 데이터 네트워크.

핵심 특징:

- 링크와 노드를 **통계적 다중화(statistical multiplexing)** 로 공유 → **유휴 시간에는 다른 사용자가 대역폭을 가져다 쓸 수 있음**.
- **버스트(burst)** 트래픽에 특히 효율적 (예: 웹 브라우징, API 호출, 파일 전송).
- 패킷 단위로 **큐잉 지연, 경로 변경**, 심지어 **패킷 손실**이 발생할 수 있으므로, 상위 계층(TCP 등)이 이를 복구/보정.

Packet switching은 내부적으로 다시 두 가지로 나뉘기도 한다.

- **Datagram 방식**: 각 패킷이 **독립적으로 라우팅**되고, 경로가 달라도 상관 없다. (예: IP)
- **Virtual Circuit 방식**: **세션 시작 시 논리 회선(label, VC ID 등)** 을 설정하고, 그 식별자로 패킷을 전달한다. (예: X.25, Frame Relay, ATM, MPLS)

#### 3) Message Switching (메시지 교환)

- 초창기 전보망이나 일부 초창기 컴퓨터 네트워크에서 사용.
- 송신자는 한 번에 **전체 메시지 단위**를 네트워크에 넣고, 각 **노드(스위치)가 메시지 전체를 저장(store)했다가 다음 노드로 전달(forward)** 한다.
- 즉, **store-and-forward** 네트워크이지만, 단위가 패킷이 아니라 **“메시지 전체”** 라는 점이 다르다.

특징:

- 각 노드는 메시지 전체를 보관해야 하므로 **큰 버퍼 메모리**가 필요하다.
- 한 노드에서 다음 노드로 넘기기 전, 메시지 전체를 다 받아야 하므로 **지연이 매우 크다**.
- 현대 인터넷은 **“메시지 교환”이 아니라, 메시지를 잘게 자른 **패킷 교환**을 사용**한다.

---

#### 세 가지 방식 비교

| 항목 | Circuit Switching | Packet Switching | Message Switching |
|------|-------------------|------------------|-------------------|
| 전형적인 예 | 전통 전화망(PSTN) | 인터넷(IP), 이더넷 | 옛날 전보망, 초기 데이터 통신 |
| 연결 방식 | 통화 전 **회선 설정** | 패킷마다 동적 라우팅 (또는 VC 설정) | 메시지를 통째로 store-and-forward |
| 자원 할당 | 회선/슬롯 **고정 예약** | 필요 시 공유 사용 (통계적 다중화) | 링크/버퍼를 메시지 단위로 점유 |
| 지연 특성 | **예측 가능**, 거의 일정 | 변동 있음, 큐잉 지연 발생 | 매우 큼 (메시지 전부 받아야 이동) |
| 효율 (버스트 트래픽) | 낮음 (유휴 시간에도 회선 점유) | 높음 | 낮음 |
| 현대 사용 | 일부 전용선, 옛 전화망의 코어 | 거의 모든 데이터 네트워크 | 역사적인 의미, 사실상 사장 |

---

#### 간단 예시 상황

- **Circuit switching 예시 – 고전 전화 통화**

  A가 B에게 전화를 건다. 네트워크는 A–중앙국–중간교환소–…–B의 경로를 찾아 **64kbps DS0 회선 하나를 전담 배정**한다. 통화가 이어지는 동안 해당 DS0는 다른 누구도 사용할 수 없다.:contentReference[oaicite:2]{index=2}

- **Packet switching 예시 – 웹 페이지 요청**

  브라우저가 서버에 HTTP GET을 보낼 때, 데이터는 **IP 패킷** 여러 개로 나뉘어 인터넷 곳곳의 라우터를 통과한다. 동일한 TCP 연결이라도, 중간에 라우팅이 바뀌면 어떤 패킷은 경로 A, 또 다른 패킷은 경로 B를 지나갈 수 있다.

- **Message switching 예시 – 전보**

  초창기 전보망에서, 한 도시의 중계국은 전체 전보 메시지를 수신(종이에 출력)하고, 다음 도시로 “다시 송신”했다. 메시지 단위로 **완전히 store-and-forward** 되었던 시대의 방식이다.

---

### 8.1.2 Switching and TCP/IP Layers

이제 “스위칭”이 TCP/IP 계층 구조에서 **어디에 위치하는지**를 정리해 보자.

#### 1) 계층별 스위칭 개념

TCP/IP – OSI 대응을 간략히 놓고 보면:

| TCP/IP | OSI | 일반 역할 | 스위칭 관점 역할 |
|--------|-----|-----------|------------------|
| Application | 7, 5 | HTTP, DNS 등 프로토콜 | 논리 연결·세션 관리 |
| Transport | 4 | TCP/UDP 포트 | 포트 번호로 세션 식별 |
| Internet | 3 | IP, 라우팅 | **패킷 스위칭(라우팅)** |
| Network Access | 2,1 | 이더넷, Wi-Fi, PHY | **프레임 스위칭, MAC 기반 전달** |

- **링크 계층(L2)**  
  - 이더넷 스위치, 브리지: **MAC 주소 기반**으로 프레임을 포워딩.  
  - 스위칭의 단위: **프레임**.  
  - 스위치의 FIB/포워딩 테이블에는 `MAC → 포트` 매핑이 들어 있다.

- **인터넷 계층(L3)**  
  - 라우터, L3 스위치: **IP 헤더의 목적지 주소**를 보고 다음 홉(next hop)으로 포워딩.  
  - 스위칭의 단위: **IP 패킷**.  
  - 라우팅 테이블(RIB/FIB)에 `prefix → next hop` 이 저장된다.

- **회선 교환 네트워크(전통 PSTN)** 는 주로 **물리/링크 계층 수준에서 회선(TDM 슬롯, 채널, 광 파장)** 을 설정하는 식으로 구현되지만, 현대에는 **IP 기반 코어와 결합**되어 동작한다.:contentReference[oaicite:3]{index=3}

#### 2) 회선 교환 vs 패킷 교환 vs TCP

- **회선 교환**은 네트워크 자체가 **지속적인 비트 스트림**을 제공한다 (아날로그/PCM).  
  애플리케이션은 추가적인 재전송, 혼잡 제어, 순서 보장 등을 거의 신경 쓰지 않아도 된다.
- **패킷 교환(IP)** 은 **최선형(best-effort)** 전송만 제공한다.
  - 패킷 유실, 중복, 순서 뒤바뀜 가능.
  - 그래서 **TCP** 가 **종단에서 신뢰성·순서·흐름·혼잡 제어를 담당**한다.

즉 **TCP/IP 네트워크의 “스위칭”은 주로 L3 라우팅(패킷 교환)을 의미**하지만, 실제 장비(예: L3 스위치)는 L2/L3를 모두 다루기도 한다.

#### 3) 현대 통신 시장에서의 변화 (최신 데이터 관점)

과거에는 **“음성 = 회선 교환(PSTN), 데이터 = 패킷 교환(인터넷)”**이 분명히 나뉘어 있었다. 그러나 2020년대 중반에는 상황이 크게 달라졌다.

- 유럽 도매 음성 시장에서, 2024년 기준 **70% 이상이 VoIP(패킷 교환 기반 음성)** 으로 집계된다.:contentReference[oaicite:4]{index=4}
- 글로벌 VoIP 시장 규모는 2023년에 약 **1,320억 달러(USD 132.47B)** 로 추정되며, 2032년까지 연평균 10% 이상 성장할 것으로 예상된다.:contentReference[oaicite:5]{index=5}
- 유럽 통신 규제·사업자 협의체(ETNO)와 각국 통신사들은 **ISDN·전통 PSTN을 IP 기반 음성(VoIP)으로 전환하는 “PSTN switch-off” 계획**을 추진 중이며, 영국 등 여러 국가는 2020년대 중반~후반을 목표로 구식 회선망을 단계적으로 퇴출하는 중이다.:contentReference[oaicite:6]{index=6}

정리하면:

> **“TCP/IP 네트워크(패킷 교환)가 기존 회선 교환 음성망까지 흡수하는 흐름”** 이 이미 현실이 되었다.

이제 회선 교환(circuit switching)은 **개념적으로 중요하고, 일부 전용 회선/특수망에는 남아 있지만**,  
대부분의 새로운 서비스는 **IP 패킷 교환 위에서 TCP/UDP를 사용**하는 구조로 설계된다.

---

## 8.2 Circuit-Switched Networks

이제 전통적인 **회선 교환망(circuit-switched networks)** 을 좀 더 깊이 파고든다. 여기서의 전형적인 예시는 **PSTN(공중 전화망)** 이다.:contentReference[oaicite:7]{index=7}

---

### 8.2.1 Three Phase (회선 교환의 세 단계)

회선 교환의 기본 동작은 다음 **세 단계**로 요약된다.

1. **회선 설정 (Circuit Establishment / Setup Phase)**
2. **데이터 전송 (Data Transfer Phase)**
3. **회선 해제 (Circuit Teardown / Release Phase)**

#### 1) 회선 설정 (Setup Phase)

전화 예시를 기준으로 보자.

1. 사용자가 수화기를 들고 번호를 누른다 (또는 스마트폰에서 전화 아이콘을 누른다).
2. **국지 교환국(local exchange)** 은 번호를 보고 **다음 교환국으로의 경로를 계산**한다.
3. 중간 교환국들은 **아직 비어 있는 회선(채널/타임슬롯)** 을 찾아 **연속적인 경로를 형성**한다.
4. 모든 교환국에서 “경로 확보 완료”가 되면, **호(呼, call) 설정이 완료**된다.

전화망의 코어에서는 보통 **SS7(Signalling System No. 7)** 과 같은 **신호망(signaling network)** 이 이 과정을 담당한다. 실제 음성 데이터는 별도의 **음성 회선(베어러 채널)** 로 흐른다.

#### 2) 데이터 전송 (Data Transfer Phase)

- 경로가 확보되면, 두 단말 사이에는 **논리적으로 전용 선**이 생긴 것과 같다.
- 이 경로 위에서 **연속적인 비트 스트림**(옛날에는 아날로그 음성, 이후엔 PCM 디지털 샘플)이 양방향으로 흐른다.
- 이때 **네트워크 내부 스위치는 단순히 타임 슬롯만 맞춰서 재전송**할 뿐, 각 샘플의 내용을 들여다보지 않는다.

#### 3) 회선 해제 (Teardown Phase)

- 둘 중 한 사용자가 수화기를 내려놓거나, call 종료 신호를 보내면,
- 신호망은 각 교환국에 “이 호에 할당된 회선을 해제하라”고 지시하고,
- 중간 노드들은 **해당 회선/슬롯을 반납**하여 다른 통화에 쓸 수 있게 한다.

---

#### 텍스트 기반 그림: Circuit-Switched 전화 통화

```text
[User A]--(local loop)--[Local Exchange A]--[Tandem]--[Local Exchange B]--(local loop)--[User B]

1) Setup:
   A ↔ Local A ↔ Tandem ↔ Local B ↔ B
   => 각 구간에서 빈 회선(TDM 슬롯)을 찾아 연결

2) Data Transfer:
   A 음성 샘플 → Local A → Tandem → Local B → B
   (각 구간에서 슬롯만 맞춰 비트 스트림 전달)

3) Teardown:
   회선 해제 후, 슬롯은 다른 통화에 재사용
```

---

### 8.2.2 Efficiency (효율)

회선 교환망의 효율은 주로 **대역폭 자원을 얼마나 낭비 없이 사용하는가**를 기준으로 볼 수 있다.

#### 1) 시간 관점 효율

간단한 효율 정의:

- 회선이 **실제로 유용한 사용자 데이터(음성/비트)를 전달하고 있는 시간**을 $$T_{\text{data}}$$,
- 회선 설정/해제 및 유휴 시간 등을 포함한 전체 할당 시간을 $$T_{\text{total}}$$ 이라 하면,

$$
\eta = \frac{T_{\text{data}}}{T_{\text{total}}}
$$

- $$\eta$$: 효율(0~1)

예를 들어:

- 통화를 하려면 **설정에 2초, 해제에 1초**가 소요되고,
- 실제 통화 시간(말하는 시간 + 듣는 시간 포함)이 20초라면,

$$
T_{\text{data}} = 20,\quad T_{\text{total}} = 2+20+1 = 23
$$

$$
\eta = \frac{20}{23} \approx 0.8696
$$

즉, 약 87%의 시간 동안만 “실제로 음성을 보내는 데” 회선을 쓴 셈이다.

#### 2) 대역폭 관점

전화망에서 전통적인 한 회선(DS0)은 **64kbps** 대역폭을 갖는다.:contentReference[oaicite:8]{index=8}

- 회선 교환에서는 **이 64kbps가 통화 기간 내내 특정 통화에만 묶여 있다.**
- 통화 중 **말을 하지 않고 침묵하는 시간**에도 64kbps는 여전히 해당 사용자에게만 예약되어 있다.

반면, **패킷 교환 네트워크**에서는 침묵 구간 동안 **패킷이 거의 전송되지 않으므로 링크가 다른 사용자에게 재활용**된다.

#### 3) 데이터/버스트 트래픽의 비효율

파일 전송과 같은 **버스트형 데이터 트래픽** 을 회선 교환망으로 처리한다고 생각해 보자.

- 예: 1 Mbps 회선을 회선 교환 방식으로 통째로 할당하여 파일 10MB를 전송
- 순수 전송 시간(이론적):

  $$
  T_{\text{tx}} = \frac{10 \times 8 \text{ (Mb)}}{1 \text{ Mbps}} = 80 \text{ s}
  $$

- 실제로는 회선 설정과 해제, 프로토콜 핸드셰이크, 응용 계층 오버헤드를 포함하면 더 길다.

문제는:

- **파일 전송이 끝난 직후부터 회선 해제가 완료될 때까지**,
- 또는 상대가 응답을 준비하는 동안,
- 할당된 회선 대역폭이 **아무도 사용하지 않는 시간**이 상당히 생긴다는 점이다.

이 때문에 오늘날 파일 전송·웹 브라우징·API 호출 등은 **절대 회선 교환 방식으로 설계하지 않는다**. 모두 **패킷 교환 위에서 TCP/UDP를 쓰는 구조**를 사용한다.

#### 4) 실제 통화 패턴을 고려한 효율 (간단 모델)

사람들은 통화 중에도:

- 상대가 말할 때는 **침묵**하고,
- 생각하느라 **잠시 끊어지는 구간**이 많다.

간단 모델:

- 통화 시간 1분(60초) 동안, 실제 **발성 중인 시간**이 30초라고 하자.
- 하지만 회선은 60초 동안 전용으로 묶여 있다.
- 그러면

  $$
  \eta_{\text{발성 기준}} = \frac{30}{60} = 0.5
  $$

실제 PSTN에서는 **양방향 TDM** 이고, 상대방도 발성하므로 모형이 단순화되어 있지만, 중요한 포인트는:

> 회선 교환은 **“언제 쓸지 확실하지 않은 대역폭”도 미리 예약**함으로써,  
> **실시간 품질은 좋지만 효율은 떨어지는 구조**라는 것이다.

---

#### 간단 파이썬 예제: 회선 교환 vs 패킷 교환 효율 비교

아래는 매우 단순화된 모델로,  
- 회선 교환: 통화 동안 내내 회선 예약  
- 패킷 교환: 발성 구간에만 패킷 전송  
이라고 가정했을 때의 평균 효율을 보는 예제이다.

```python
import random

def simulate_call_circuit(num_calls=1000, call_duration=60, talk_prob=0.5):
    """
    num_calls: 통화 수
    call_duration: 통화 시간(초)
    talk_prob: 각 초마다 '말하고 있을 확률'
    """
    total_reserved_time = num_calls * call_duration
    total_active_time = 0

    for _ in range(num_calls):
        for _ in range(call_duration):
            if random.random() < talk_prob:
                total_active_time += 1

    efficiency = total_active_time / total_reserved_time
    return efficiency

def simulate_call_packet(num_calls=1000, call_duration=60, talk_prob=0.5):
    """
    패킷 교환 가정: 발성하는 초에만 자원을 사용한다고 단순 가정
    """
    total_possible_time = num_calls * call_duration  # 대역폭이 이 시간 동안 '열려 있다'고 가정
    total_used_time = 0

    for _ in range(num_calls):
        for _ in range(call_duration):
            if random.random() < talk_prob:
                total_used_time += 1

    # 패킷 교환에서는 사용한 시간만큼만 대역폭을 '소비'한다고 보면,
    # 효율을 1에 가깝다고 볼 수 있다. 여기서는 단순히 사용 비율만 출력.
    efficiency = total_used_time / total_possible_time
    return efficiency

if __name__ == "__main__":
    random.seed(42)
    eta_circuit = simulate_call_circuit()
    eta_packet = simulate_call_packet()

    print(f"Circuit switching '발성 기준' 효율: {eta_circuit:.3f}")
    print(f"Packet switching '사용 시간 비율': {eta_packet:.3f}")
```

이 모델은 매우 단순하지만,

- 회선 교환에서는 “발성하지 않는 시간”에도 회선을 점유하는 반면,
- 패킷 교환에서는 “발성하는 순간에만 패킷을 보내고 링크를 잠깐 점유”하는 구조임을 감 잡기에 좋다.

---

### 8.2.3 Delay (지연)

회선 교환망에서의 지연(delay)은 **사용자가 전화를 걸고 실제로 “여보세요”를 듣기까지 걸리는 시간**과, **통화 중 음성이 반대편에 도달하는 시간**으로 나누어 생각할 수 있다.

#### 1) 전체 지연 구성 요소

1. **호 설정 지연 (Call Setup Delay, $$D_{\text{setup}}$$)**  
   - 번호 입력 → 교환기 경로 설정 → 상대방 벨 울리기까지.
2. **전파 지연 (Propagation Delay, $$D_{\text{prop}}$$)**  
   - 신호가 물리적 매체(구리선, 광섬유)를 통해 이동하는 시간.
3. **스위칭 지연 (Switching Delay, $$D_{\text{switch}}$$)**  
   - 각 교환국에서 신호를 처리하고, 타임슬롯을 맞추고, 필요한 경우 신호 변환/복조 등 하는 데 드는 시간.
4. **큐잉 지연 (Queuing Delay, $$D_{\text{queue}}$$)**  
   - 회선 교환의 경우 **정상 전화 통화에서는 거의 없거나 매우 작다**. 하지만 교환기 자원이 부족할 때는 **호가 “차단(blocking)”되어 연결 자체가 안 될 수 있다.**

보통 통화 중 사용자가 체감하는 것은:

- **호 설정 지연**: “전화를 눌렀는데 상대편이 받기까지의 시간”  
- **전파 지연**: 국제 통화에서 느끼는 약간의 “에코” 또는 반응 지연

#### 2) 간단 수식

회선 교환 통화의 **총 지연을** 간단히 표현하면:

$$
D_{\text{total}} = D_{\text{setup}} + D_{\text{prop}} + D_{\text{switch}}
$$

여기서:

- $$D_{\text{setup}}$$ 은 **호 설정이 끝날 때까지의 단발성 지연**이고,
- $$D_{\text{prop}} + D_{\text{switch}}$$ 는 **통화 중 왕복 지연(반응 속도)에 영향을 주는 지속적인 지연 요소**이다.

실제 PSTN에서:

- 같은 대륙 내 통화에서는 **왕복 지연(RTT)** 이 수십 ms 수준,
- 대륙 간 해저 케이블 통화에서는 **RTT가 수백 ms** 가 되기도 한다.

#### 3) 예제: 회선 교환 vs 패킷 교환 지연 모델링 (간단 코드)

아래 코드는 회선 교환과 패킷 교환에서의 **“첫 바이트가 도착하기까지의 지연”**을 매우 단순한 모델로 비교한 것이다.

- 회선 교환:
  - $$D_{\text{setup}}$$ 가 있고,
  - 데이터 자체는 **연속 스트림**으로 전송된다고 가정.
- 패킷 교환:
  - 패킷 단위로 전송,
  - 각 패킷이 라우터를 지나며 큐잉/처리 지연을 가질 수 있음.

```python
def delay_circuit(setup_delay, prop_delay, switch_delay):
    """
    회선 교환: 첫 비트가 상대에게 도달하기까지의 지연 (매우 단순화)
    setup_delay: 회선 설정에 걸리는 시간 (초)
    prop_delay: 전파 지연 (초)
    switch_delay: 스위칭/처리 지연 (초)
    """
    return setup_delay + prop_delay + switch_delay

def delay_packet(num_hops, prop_per_hop, proc_per_hop, queue_per_hop):
    """
    패킷 교환: 첫 패킷이 도착하기까지의 지연 (매우 단순화)
    num_hops: 라우터/스위치 홉 수
    prop_per_hop: 각 홉당 전파 지연 (초)
    proc_per_hop: 각 홉당 처리 지연 (초)
    queue_per_hop: 각 홉당 평균 큐잉 지연 (초)
    """
    per_hop = prop_per_hop + proc_per_hop + queue_per_hop
    return num_hops * per_hop

if __name__ == "__main__":
    # 예시 값
    # 회선 교환: 국제 통화의 경우
    setup = 2.0     # 2초 정도 (실제 국가/사업자/망에 따라 달라짐)
    prop = 0.05     # 50ms
    switch = 0.02   # 20ms

    d_circuit = delay_circuit(setup, prop, switch)
    print(f"Circuit-switched call: 첫 비트 도달까지 지연 ≈ {d_circuit:.3f} s")

    # 패킷 교환: 10홉, 각 홉당 3ms(전파) + 0.5ms(처리) + 2ms(큐잉) 가정
    d_packet = delay_packet(
        num_hops=10,
        prop_per_hop=0.003,
        proc_per_hop=0.0005,
        queue_per_hop=0.002
    )
    print(f"Packet-switched path: 첫 패킷 도달까지 지연 ≈ {d_packet:.3f} s")
```

설명:

- 회선 교환에서는 **호 설정이 완료된 뒤의 지연은 매우 작고 안정적**이지만,
- **호 설정 자체에 몇 초가 걸릴 수 있다.**
- 패킷 교환에서는 호 설정(세션 설정) 지연이 상대적으로 작거나 아예 없을 수 있지만,
- **각 홉마다 큐잉 지연이 누적**되고, 트래픽 폭주 시 지연이 크게 변동할 수 있다.

#### 4) Blocking vs Non-Blocking

회선 교환망의 중요한 개념 중 하나는 **“차단(blocking)”** 이다.

- 교환국의 회선 자원(슬롯/채널)이 모두 사용 중이면,  
  새로운 호는 **연결조차 할 수 없다**.
- 사용자는 **전화가 “통화 중”이거나 “연결 불가”** 상태를 경험하게 된다.

이러한 차단 확률을 계산하기 위해 **Erlang B 공식** 등의 트래픽 이론이 발전했다. (수식 자체는 별도 장에서 다루는 것이 보통이므로 여기서는 언급만 한다.)

---

#### 지연·효율·품질을 종합해서 보면

- **회선 교환**
  - 장점
    - 호가 설정된 이후에는 **지연이 안정적**이고,
    - 음성처럼 **지속적인 실시간 스트림**에 매우 잘 맞는다.
  - 단점
    - 호 설정에 시간이 들고,
    - **버스트형 트래픽에 비효율적**이며,
    - 회선 수가 부족하면 **호 자체가 차단**될 수 있다.

- **패킷 교환**
  - 장점
    - **링크 대역폭을 매우 효율적으로 공유**할 수 있고,
    - 다양한 종류의 트래픽(웹, 파일, 스트리밍)을 하나의 네트워크 위에 통합할 수 있다.
  - 단점
    - **지연과 지터(jitter)가 변동**하고,
    - 상위 계층(TCP/응용)에서 **손실 복구/재정렬/혼잡 제어 로직**을 구현해야 한다.

현대 통신망은 이 둘을 절대적인 대립으로 두지 않고, 다음과 같은 방향으로 진화했다.

- 코어는 **IP 패킷/라벨 스위칭(MPLS)** 을 사용,
- 엑세스 구간에서는 QoS·우선순위 제어 등을 통해 **패킷 교환 네트워크에서 회선 비슷한 품질(“논리적 회선”)을 에뮬레이션**하는 식이다.

---

## (보너스) 간단 시뮬레이션: 회선 교환 vs 패킷 교환 파일 전송 시간 비교

마지막으로 **순수 파일 전송만 놓고 봤을 때** 회선 교환과 패킷 교환이 어떻게 다른지를 보여주는 간단한 코드 예제를 하나 더 살펴보자.

가정:

- 회선 교환:
  - 파일 전송 전에 **항상 회선 설정에 고정 지연 $$D_{\text{setup}}$$** 이 걸린다고 가정.
  - 전송 중에는 **대역폭이 보장**되므로 지연 변동은 무시.
- 패킷 교환:
  - 별도의 회선 설정 지연은 거의 없다고 가정 (TCP 3-way handshake 정도는 무시),
  - 대신 링크 혼잡에 따라 **실효 대역폭이 변동**할 수 있음.

```python
def transfer_time_circuit(file_size_bytes, bandwidth_bps, setup_delay_s):
    """
    회선 교환 기반 파일 전송 시간 (극단적으로 단순화)
    file_size_bytes: 파일 크기 (바이트)
    bandwidth_bps: 회선 대역폭 (bits per second)
    setup_delay_s: 회선 설정 지연 (초)
    """
    tx_time = (file_size_bytes * 8) / bandwidth_bps
    return setup_delay_s + tx_time

def transfer_time_packet(file_size_bytes, avg_bandwidth_bps):
    """
    패킷 교환 기반 파일 전송 시간 (평균 유효 대역폭만 고려)
    """
    return (file_size_bytes * 8) / avg_bandwidth_bps

if __name__ == "__main__":
    file_size_mb = 100      # 100MB 파일
    file_size_bytes = file_size_mb * 1024 * 1024

    # 회선 교환: 10 Mbps 전용 회선, 설정에 3초 필요
    t_circuit = transfer_time_circuit(
        file_size_bytes=file_size_bytes,
        bandwidth_bps=10 * 10**6,
        setup_delay_s=3.0
    )

    # 패킷 교환: 혼잡 때문에 평균 8 Mbps만 나오는 상황
    t_packet = transfer_time_packet(
        file_size_bytes=file_size_bytes,
        avg_bandwidth_bps=8 * 10**6
    )

    print(f"Circuit switching 기반 전송 시간: {t_circuit:.2f} s")
    print(f"Packet switching 기반 전송 시간:  {t_packet:.2f} s")
```

이 예제에서 실제 수치는 가정에 따라 달라지지만, 관점은 다음과 같다.

- **짧은 파일 + 큰 설정 지연**:  
  회선 교환은 설정 지연 때문에 비효율적일 수 있다.
- **아주 긴 파일 + 안정적 대역폭**:  
  회선 교환이 의외로 단순·예측 가능한 전송을 제공할 수도 있다.
- 실제 세계에서는 **비용, 확장성, 다양한 트래픽 유형, 서비스 융합** 등까지 고려하면,  
  오늘날 대부분의 데이터 서비스는 **패킷 교환 기반**으로 설계된다.

---

이 글에서는 **스위칭의 세 가지 방식**과 **TCP/IP 계층에서의 위치**, 그리고 **회선 교환망의 구조·효율·지연**을 자세히 살펴보았다.  
다음 단계로는 **패킷 스위칭(특히 IP 라우팅, MPLS, QoS)** 의 세부 메커니즘과, **스위칭/라우팅 장비의 실제 동작(테이블 구조, 포워딩 엔진, 버퍼 관리)** 등을 이어서 정리하면 전체 네트워크 구조가 입체적으로 보이게 된다.