---
layout: post
title: 시스템보안 - 실습(파일 포맷 Fuzzing)
date: 2025-10-30 17:30:23 +0900
category: 시스템보안
---
# 13.3 실습: 파일 포맷 Fuzzing(무해화 샌드박스에서)

## 13.3.1 큰 그림(아키텍처)

```
[입력(시드/샘플)]
        │
        ▼
  [Fuzzer(ASan/UBSan/TSan)]
        │ (in-process: libFuzzer / out-of-process: AFL++/honggfuzz)
        ▼
  [대상 파서/디코더]───┐
        │             │
        │        [Sanitizer 리포트]
        ▼             │
  [크래시 아티팩트] ◄──┘
        │
        ▼
  [무해화 샌드박스: Docker/Windows Sandbox/QEMU 스냅샷]
        │
        ▼
  [triage → 회귀 테스트 편입 → 패치/릴리즈]
```

- **격리**: Fuzzer/대상 바이너리는 **읽기 전용 루트**, **비네트워크**, **자원 상한(ulimit/seccomp/AppContainer)**.
- **가시성**: crash 입력/로그/프로파일은 **호스트의 격리된 공유폴더(쓰기 전용)**로만 전달.
- **안전성**: 퍼징 타깃은 **사내/오픈소스 파서** 등 라이선스/보안 문제가 없는 대상을 사용.

---

## 13.3.2 샌드박스 베이스라인(리눅스: Docker + seccomp/AppArmor)

### (A) `Dockerfile` (슬림 이미지 + 도구)
```dockerfile
# ./docker/fuzz.Dockerfile
FROM ubuntu:24.04

RUN apt-get update && DEBIAN_FRONTEND=noninteractive \
    apt-get install -y --no-install-recommends \
    clang lld cmake ninja-build make git python3-minimal \
    llvm llvm-dev libstdc++-12-dev libc++-dev libc++abi-dev \
    libpng-dev zlib1g-dev libjpeg-turbo8-dev \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# 비루트 계정
RUN useradd -m fuzz && mkdir -p /work /corpus /out && chown -R fuzz:fuzz /work /corpus /out
USER fuzz
WORKDIR /work
ENV ASAN_OPTIONS=detect_leaks=1:abort_on_error=1:symbolize=1
ENV UBSAN_OPTIONS=print_stacktrace=1:halt_on_error=1
```

### (B) 최소 seccomp & 런타임 옵션
```json
// ./docker/seccomp-min.json (개념 예시; 실제 사용 시 더 제한)
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "syscalls": [
    { "names": ["read","write","exit","exit_group","futex","clock_gettime",
                "mmap","munmap","mprotect","brk","rt_sigaction","rt_sigprocmask",
                "nanosleep","getrandom","prlimit64"],
      "action": "SCMP_ACT_ALLOW" }
  ]
}
```

실행:
```bash
docker build -f docker/fuzz.Dockerfile -t img-fuzz .
docker run --rm -it \
  --security-opt no-new-privileges \
  --security-opt seccomp=$(pwd)/docker/seccomp-min.json \
  --read-only -v $(pwd)/work:/work:rw \
  --tmpfs /tmp:rw,noexec,nosuid,nodev,size=512m \
  --pids-limit 256 --cpus 2 --memory 2g \
  --network none \
  img-fuzz /bin/bash
```

> 포인트: **read-only 루트**, **no-new-privileges**, **nonetwork**, **ulimit/pids-limit**, **tmpfs**만 쓰기 허용.

---

## 13.3.3 대상: 교육용 “PNG-유사” 헤더 파서 + libFuzzer

### (A) 안전한 파서 스켈레톤
```cpp
// src/safe_png.hpp
#pragma once
#include <cstdint>
#include <cstddef>
#include <optional>
struct PngInfo { uint32_t w, h, bitdepth; };
std::optional<PngInfo> ParsePngHeader(const uint8_t* data, size_t n);
```

```cpp
// src/safe_png.cpp
#include "safe_png.hpp"
#include <cstring>
#include <limits>

static bool ReadU32BE(const uint8_t* p, size_t n, size_t off, uint32_t& out) {
  if (off + 4 > n) return false;
  uint32_t v; std::memcpy(&v, p + off, 4);
  out = ((v & 0xFF) << 24) | ((v & 0xFF00) << 8) |
        ((v & 0xFF0000) >> 8) | ((v & 0xFF000000) >> 24);
  return true;
}
static bool MulOverflow(uint32_t a, uint32_t b, uint32_t* out){
  if (a && b > std::numeric_limits<uint32_t>::max()/a) return false;
  *out = a*b; return true;
}
std::optional<PngInfo> ParsePngHeader(const uint8_t* data, size_t n) {
  // 아주 줄인 PNG 매직 & IHDR(폭,높이,비트뎁스)만 검사(교육용)
  const uint8_t sig[8] = {0x89,'P','N','G',0x0D,0x0A,0x1A,0x0A};
  if (!data || n < 8 || std::memcmp(data, sig, 8) != 0) return std::nullopt;
  // IHDR: length(4) 'IHDR'(4) w(4) h(4) bitdepth(1) ...
  uint32_t len; if (!ReadU32BE(data, n, 8, len)) return std::nullopt;
  if (len < 13 || len > (1u<<20)) return std::nullopt;
  if (n < 8 + 4 + 4 + len + 4) return std::nullopt;
  // 'IHDR'
  if (data[12] != 'I' || data[13] != 'H' || data[14] != 'D' || data[15] != 'R') return std::nullopt;
  uint32_t w,h; if (!ReadU32BE(data, n, 16, w)) return std::nullopt;
  if (!ReadU32BE(data, n, 20, h)) return std::nullopt;
  if (w == 0 || h == 0 || w > (1u<<20) || h > (1u<<20)) return std::nullopt;
  uint8_t bd = data[24]; // 가정: 8bit만 허용
  if (!(bd==8 || bd==16)) return std::nullopt;
  uint32_t row; if (!MulOverflow(w, (bd/8)*4 /*RGBA 가정*/, &row)) return std::nullopt;
  if (row > (1u<<26)) return std::nullopt; // 64MB/row 상한
  return PngInfo{w,h,bd};
}
```

### (B) libFuzzer 하네스
```cpp
// fuzz/fuzz_png.cpp
#include <cstdint>
#include <cstddef>
#include "src/safe_png.hpp"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  auto info = ParsePngHeader(data, size);
  (void)info; // 크래시/UB 없이 반환만 보장
  return 0;
}
```

### (C) 빌드 & 실행
```bash
clang++ -g -O1 -fsanitize=address,undefined,fuzzer -fno-omit-frame-pointer \
  src/safe_png.cpp fuzz/fuzz_png.cpp -o fuzz_png

mkdir -p seeds
printf "\x89PNG\x0D\x0A\x1A\x0A\x00\x00\x00\x0D""IHDR\x00\x00\x00\x10\x00\x00\x00\x10\x08" \
  > seeds/min.png
./fuzz_png -max_total_time=120 -artifact_prefix=/out/crashes/ seeds
```

> 산itizer가 **즉시 크래시**를 알려주고, 입력은 `/out/crashes/`에 저장됩니다.
> 크래시가 없다면 최소 smoke 성공.

---

## 13.3.4 고전 파서 Fuzzing: AFL++ (fork-server) 예

### (A) “파일 → stdout” 바이너리 예시
```cpp
// tools/pnginfo.cpp
#include "src/safe_png.hpp"
#include <vector>
#include <cstdio>
int main(int argc, char** argv){
  if (argc<2) return 1;
  FILE* f = std::fopen(argv[1],"rb");
  if(!f) return 1;
  std::vector<unsigned char> buf; unsigned char tmp[4096];
  while (size_t r=std::fread(tmp,1,sizeof(tmp),f)) buf.insert(buf.end(),tmp,tmp+r);
  auto info=ParsePngHeader(buf.data(), buf.size());
  if (info) std::printf("%u x %u, %u-bit\n", info->w, info->h, info->bitdepth);
  std::fclose(f);
  return 0;
}
```

### (B) AFL++ 빌드·실행
```bash
# 계측 빌드(ASan/UBSan 병행 권장)
CC=afl-cc CXX=afl-c++ \
CFLAGS="-O1 -g -fsanitize=address,undefined" \
CXXFLAGS="-O1 -g -fsanitize=address,undefined" \
afl-c++ -o pnginfo tools/pnginfo.cpp src/safe_png.cpp

mkdir -p afl_seeds afl_findings
cp seeds/min.png afl_seeds/

afl-fuzz -i afl_seeds -o afl_findings -m none -t 500 \
  -- ./pnginfo @@
```

- **-m none**: ASan과 함께 쓸 때 메모리 제한을 완화.
- 크래시 발생 시 `afl_findings/crashes/`에 재현 입력 생성.

---

## 13.3.5 커스텀 Mutator·Dictionary(정밀 타격)

### (A) PNG 사전(dictionary) 예
```
# ./dict/png.dict
"PNG"
"IHDR"
"IDAT"
"IEND"
"\x89PNG\x0D\x0A\x1A\x0A"
```
실행:
```bash
./fuzz_png -dict=./dict/png.dict -max_total_time=120 seeds
```

### (B) libFuzzer 커스텀 Mutator(선택)
```cpp
// fuzz/custom_mutator.cpp (선택: 빌드시 -fsanitize=fuzzer-no-link)
extern "C" size_t LLVMFuzzerCustomMutator(uint8_t *Data, size_t Size, size_t MaxSize, unsigned int Seed) {
  // 예: IHDR 길이 필드(12~1MB)만 살짝 변경하는 전략
  // (데모 스텁 — 실제 구현 시 안전한 경계 검사 필수)
  return Size;
}
```

---

## 13.3.6 무해화 샌드박스에서 “오피스 문서” 퍼징(컨셉)

- **OOXML**(docx/xlsx/pptx)은 ZIP 컨테이너 → XML 파서 + 이미지/폰트/매크로
- **헤드리스 변환기**(LibreOffice) 퍼징: **컨테이너로 감싸고** 네트워크 차단, no-new-privileges, seccomp로 최소화.
- **입력**: `*.docx` → `soffice --headless --convert-to pdf`
- **관찰**: 비정상 종료/시간초과/메모리 고갈 (시간 상한 + 메모리 상한)

Docker 예:
```bash
docker run --rm -it \
  --network none --cpus 2 --memory 2g --pids-limit 256 \
  --read-only -v $(pwd)/docs:/docs:ro -v $(pwd)/out:/out:rw \
  libreoffice-docker-image \
  soffice --headless --convert-to pdf --outdir /out /docs/input.docx
```

> 크래시 입력은 `/out`에 로그와 함께 보관 → 회귀 테스트로 편입.

---

## 13.3.7 Windows Sandbox(.wsb)로 “디코더 퍼징” 감싸기

### (A) Windows Sandbox 설정
```xml
<!-- fuzz.wsb -->
<Configuration>
  <VGpu>Disable</VGpu>
  <Networking>Disable</Networking>
  <MappedFolders>
    <MappedFolder>
      <HostFolder>C:\FuzzShare</HostFolder>
      <ReadOnly>true</ReadOnly>
    </MappedFolder>
    <MappedFolder>
      <HostFolder>C:\FuzzOut</HostFolder>
      <ReadOnly>false</ReadOnly>
    </MappedFolder>
  </MappedFolders>
  <LogonCommand>
    <Command>powershell -ExecutionPolicy Bypass -File C:\FuzzShare\start_fuzz.ps1</Command>
  </LogonCommand>
</Configuration>
```

### (B) 시작 스크립트(샌드박스 내부에서 실행)
```powershell
# C:\FuzzShare\start_fuzz.ps1
$env:ASAN_OPTIONS="detect_leaks=1:abort_on_error=1:symbolize=1"
$env:UBSAN_OPTIONS="print_stacktrace=1:halt_on_error=1"

New-Item -ItemType Directory -Force -Path C:\out | Out-Null
Copy-Item C:\FuzzShare\* C:\ -Recurse -Force

# 예: fuzz_png.exe 구동(Clang-cl 빌드 아티팩트)
C:\fuzz_png.exe -max_total_time=300 -artifact_prefix=C:\out\crashes\ C:\seeds

# 결과를 공유 폴더로 이동
Copy-Item C:\out\* C:\FuzzOut\ -Recurse -Force
Stop-Computer -Force
```

> 샌드박스는 **매 세션 초기화**되므로, **깨끗한 상태**에서 반복 가능.
> vGPU/네트워크 Off로 그래픽/네트워크 축소.

---

## 13.3.8 QEMU 스냅샷 퍼징(고립 VM)

```bash
# QEMU VM 스냅샷을 만들어두고, 퍼징 워커가 부팅 → 작업 → 스냅샷 롤백
qemu-system-x86_64 -snapshot -m 4096 -hda win11.qcow2 -net none \
  -monitor stdio

# monitor에서: savevm fuzzbase / loadvm fuzzbase / stop / cont
```

- CI에서 VM을 **병렬 다수 인스턴스**로 띄우고, 충돌 입력은 **호스트 공유 디렉터리**로 수집.

---

## 13.3.9 크래시 triage → 회귀 테스트 편입(필수)

1) **재현**: `./fuzz_png crashes/id:000012,sig:SEGV`
2) **최소화**: `-minimize_crash=1` 혹은 `afl-tmin`
3) **고정 테스트**: `tests/crashes/000012.bin`로 보관하고 gtest 편입
4) **패치 후 확인**: 동일 입력에 대해 **크래시 없음**이 증빙

---

# 13.4 방어: 파일 무해화(CDR), 앱 격리(Windows Sandbox, AppContainer)

## 13.4.1 파일 무해화(Content Disarm & Reconstruction, CDR) 개념

- **화이트리스트 재구성**: 파일을 **허용된 서브셋**만 보존하고 “**깨끗한 새 파일**”로 재구성
  - PDF: **표시용 레이어만 남기고** JS/폼/임베드 제거, 비트맵 렌더링 후 재PDF
  - 이미지: **재인코딩**(메타/ICC/XMP 제거), 최대 해상도/채널 제한
  - Office: 매크로 제거, OLE 임베드 제거, “Safe OOXML”로 재저장
- **이점**: 알려지지 않은 파서 버그에도 **공격 표면 축소**
- **Trade-off**: 기능 손실(양식/주석/투명도), 재인코딩 비용

---

## 13.4.2 CDR 파이프라인(예: 문서/이미지)

### (A) PDF 무해화(두 가지 접근)
1) **비트맵 플래튼**: 렌더링 → 이미지 → 재PDF (JS/폼/링크 제거)
2) **정책형 클리너**: 특정 오브젝트(Annotation/JavaScript/Action) 제거 후 재저장

**플래튼 예(Ghostscript)**
```bash
# input.pdf → 무해화 output.pdf (텍스트 검색성 포기 가능)
gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite \
   -dDetectDuplicateImages -dCompressFonts=true \
   -dCompatibilityLevel=1.5 \
   -sOutputFile=output.pdf input.pdf
```

**정책형 정리(qpdf)**
```bash
# JavaScript 제거, object stream 재작성
qpdf --decrypt --object-streams=disable --qdf in.pdf tmp.pdf
# (qdf 텍스트 상태에서 JS/Action 필드 제거 스크립트 적용 가능)
qpdf --object-streams=generate tmp.pdf output.pdf
```

### (B) 이미지 무해화
```bash
# exiftool로 메타 제거
exiftool -all= -overwrite_original in.jpg

# 이미지 재인코딩(해상도/채널 강제)
magick in.jpg -strip -resize "2048x2048>" -colorspace sRGB -depth 8 out.jpg
```

### (C) Office 무해화(매크로/임베드 제거)
```bash
# LibreOffice headless 변환: docm → pdf (매크로 실행 없음)
soffice --headless --convert-to pdf --outdir out in.docm
```

> 위 변환 작업은 **샌드박스 컨테이너** 안에서 수행하고, 결과물만 호스트로 복사.

---

## 13.4.3 CDR 파이프라인 자동화(샘플 Python)

```python
# tools/cdr_pipeline.py
import subprocess, sys, os, shlex, tempfile

def run(cmd):
    print("+", cmd)
    r = subprocess.run(shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return r.returncode, r.stdout, r.stderr

def cdr_pdf(inp, outp):
    # 1차: Ghostscript 플래튼(표시 전용 재생성)
    rc,_,err = run(f"gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite "
                   f"-dDetectDuplicateImages -dCompressFonts=true "
                   f"-dCompatibilityLevel=1.5 -sOutputFile={outp} {inp}")
    return rc==0

def cdr_image(inp, outp):
    # 메타 제거 + 재인코딩 + 최대 해상도/채널 강제
    rc,_,_ = run(f"magick {inp} -strip -resize 2048x2048> -colorspace sRGB -depth 8 {outp}")
    return rc==0

def main():
    if len(sys.argv)<4:
        print("usage: cdr_pipeline.py type input output"); sys.exit(1)
    typ, i, o = sys.argv[1], sys.argv[2], sys.argv[3]
    if typ=="pdf":
        ok = cdr_pdf(i,o)
    elif typ=="img":
        ok = cdr_image(i,o)
    else:
        print("unknown type"); sys.exit(1)
    sys.exit(0 if ok else 2)

if __name__=="__main__":
    main()
```

> 이 스크립트 자체를 **컨테이너/Windows Sandbox** 내부에서 실행.

---

## 13.4.4 Windows Sandbox로 CDR 배치 처리

### (A) `.wsb` 설정(무해화 전용)
```xml
<!-- cdr.wsb -->
<Configuration>
  <VGpu>Disable</VGpu>
  <Networking>Disable</Networking>
  <MappedFolders>
    <MappedFolder>
      <HostFolder>C:\CDR\in</HostFolder>
      <ReadOnly>true</ReadOnly>
    </MappedFolder>
    <MappedFolder>
      <HostFolder>C:\CDR\out</HostFolder>
      <ReadOnly>false</ReadOnly>
    </MappedFolder>
    <MappedFolder>
      <HostFolder>C:\CDR\tools</HostFolder>
      <ReadOnly>true</ReadOnly>
    </MappedFolder>
  </MappedFolders>
  <LogonCommand>
    <Command>powershell -ExecutionPolicy Bypass -File C:\CDR\tools\run_cdr.ps1</Command>
  </LogonCommand>
</Configuration>
```

### (B) 실행 스크립트(샌드박스 내부)
```powershell
# C:\CDR\tools\run_cdr.ps1
$ErrorActionPreference = "Stop"
Get-ChildItem C:\CDR\in | ForEach-Object {
  $in = $_.FullName
  $ext = $_.Extension.ToLower()
  $out = Join-Path C:\CDR\out ($_.BaseName + ".sanitized" + $ext)

  if ($ext -in @(".pdf")) {
    python C:\CDR\tools\cdr_pipeline.py pdf $in $out
  } elseif ($ext -in @(".jpg",".jpeg",".png",".webp",".tif",".tiff")) {
    python C:\CDR\tools\cdr_pipeline.py img $in $out
  } else {
    # 미지원 포맷: 그대로 거부(정책)
    $out = Join-Path C:\CDR\out ($_.Name + ".blocked.txt")
    "Blocked by policy" | Out-File -Encoding ascii $out
  }
}
Stop-Computer -Force
```

> 샌드박스는 **매번 초기화**되므로 “**깨끗한 작업 공간**” 보장 + **네트워크/디바이스 축소**.

---

## 13.4.5 AppContainer(Windows)로 앱 격리 실행(개념)

- 일반 데스크톱 앱을 **AppContainer**로 직접 실행하는 표준 API는 복잡(패키지/능력 필요).
- **현실적 대안**:
  - **Windows Sandbox** 또는 **WDAG(Defender Application Guard)**로 앱/문서 열람
  - **MSIX 패키징**: 앱을 MSIX로 배포하고 **선언적 capability**만 허용
  - **Exploit Protection/Attack Surface Reduction(ASR)** 정책 강화
  - **Applocker/WDAC**로 실행/로드 정책을 제한

**Exploit Protection(구성 스냅샷)**
- **DEP/ASLR 강제**, **CFG** 켜기, **Export Address Filtering** 등 프로세스 기본 보안 강화.
- 사내 표준 템플릿을 **GPO**로 배포.

---

## 13.4.6 리눅스 측 앱 격리 — systemd-run + Bubblewrap/Firejail(개념)

### (A) bubblewrap 샌드박스 실행 예
```bash
bwrap --ro-bind /usr /usr \
      --ro-bind /lib /lib --ro-bind /lib64 /lib64 \
      --ro-bind /bin /bin --ro-bind /sbin /sbin \
      --tmpfs /tmp --dir /run/user/1000 \
      --unshare-all --die-with-parent \
      --dev-bind /dev/null /dev/null \
      --ro-bind $(pwd)/in /in \
      --bind $(pwd)/out /out \
      --chdir /out \
      -- \
      /usr/bin/convert /in/input.jpg -strip -resize 2048x2048\> out.jpg
```

- **unshare-all**로 namespace 분리, 루트/디바이스/네트워크 차단.

---

## 13.4.7 운영 정책: CDR + 격리 조합

- **게이트**: 메일/업로드/공유 폴더에 들어오는 파일은 **무해화 → 임시 존**에 저장.
- **가시성**: 원본과 무해화 결과의 **해시/메타**를 로그에 기록.
- **예외**: 특정 업무(서명된 매크로 필요 등)만 **승인 요청**으로 패스 스루(만료일 필수).
- **IR 연계**: CDR 실패/비정상 파일은 **격리 보관**(읽기 전용) 후 **분석 큐**로.

---

## 13.4.8 품질·보안 검증(체크리스트)

**퍼징 품질**
- [ ] libFuzzer/AFL++ 병행, **dictionary**/mutator로 파일 포맷 특화
- [ ] 커버리지 지표 수집(분기/라인) — 최소 smoke를 CI에 상시
- [ ] crash 입력은 **회귀 테스트**로 편입(영구 저장소/해시 로그)

**샌드박스**
- [ ] 리눅스: no-new-privileges, seccomp/AppArmor, read-only 루트, nonetwork
- [ ] Windows: Sandbox/WDAG, Exploit Protection 템플릿, AppLocker/WDAC
- [ ] 자원 상한: CPU/mem/pids/IO 제한

**CDR 정책**
- [ ] PDF/이미지/오피스 각각 **화이트리스트 재구성** 프로파일
- [ ] 최대 해상도/채널/파일 크기 제한(DoS 방지)
- [ ] 변환 실패 시 **차단 + 감사 로그**(원본은 격리 보관)

**감사·추적**
- [ ] 입력/출력 SHA256, 처리 도구 버전/옵션, 시간, 오퍼레이터/자동화 ID
- [ ] 샌드박스 실행 로그(종료코드, 크래시 여부, 자원 사용량)

---

## 13.4.9 미니 “끝에서 끝까지” 연습 시나리오

1) **시드**: 정상 PNG/PDF 5~10개.
2) **퍼징**: 2시간(libFuzzer, dictionary 포함).
3) **크래시**: 3건 발생 → `-minimize_crash=1`으로 최소화.
4) **회귀 테스트**: `tests/crashes/*.bin` 편입, gtest 추가.
5) **CDR**: 문제 입력을 CDR 파이프라인에 통과 → 출력물 정상 생성 확인.
6) **격리 검증**: 파일을 Windows Sandbox에서 열어보고 **네트워크/드라이브 접근 없음**을 확인.
7) **보고서**: 입력 해시, 리포트 스택트레이스, 수정 diff, 회귀 테스트 링크, CDR 결과 스크린샷.

---

# 부록 A. CMake(테스트/퍼저/하드닝 분리)

```cmake
cmake_minimum_required(VERSION 3.20)
project(filefuzz LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 20)

option(SAN "Sanitizer build" ON)

add_library(pngsafe src/safe_png.cpp)
target_include_directories(pngsafe PUBLIC ${CMAKE_SOURCE_DIR})

if (MSVC)
  target_compile_options(pngsafe PRIVATE /W4 /permissive- /EHsc)
else()
  target_compile_options(pngsafe PRIVATE -Wall -Wextra -Wpedantic -Wformat -Wformat-security)
endif()

add_executable(fuzz_png fuzz/fuzz_png.cpp)
target_link_libraries(fuzz_png PRIVATE pngsafe)

if (NOT MSVC)
  if (SAN)
    target_compile_options(fuzz_png PRIVATE -fsanitize=address,undefined -g -O1 -fno-omit-frame-pointer)
    target_link_options(fuzz_png PRIVATE -fsanitize=address,undefined,fuzzer)
  else()
    target_compile_options(fuzz_png PRIVATE -O2)
  endif()
endif()
```

---

# 부록 B. gtest 회귀 테스트(크래시 입력 고정)

```cpp
// tests/reg_png.cpp
#include "src/safe_png.hpp"
#include <gtest/gtest.h>
#include <fstream>
#include <vector>
static std::vector<unsigned char> load(const char* p){
  std::ifstream ifs(p, std::ios::binary);
  return std::vector<unsigned char>((std::istreambuf_iterator<char>(ifs)),
                                    std::istreambuf_iterator<char>());
}
TEST(PNG, Crash0001){
  auto buf = load("tests/crashes/0001.bin");
  auto info = ParsePngHeader(buf.data(), buf.size());
  SUCCEED(); // 크래시/UB 없이 반환되면 통과
}
```

---

# 결론

- **파일 포맷 Fuzzing**은 **무해화 샌드박스**와 결합할 때 비로소 **운영에 안전하게** 적용할 수 있습니다.
- **libFuzzer/AFL++ + Sanitizer**는 “빠른 탐지”, **CDR**은 “알 수 없는 버그에도 안전한 결과물 보장”, **Sandbox/AppContainer/seccomp**는 “행위 상한”을 제공합니다.
- 크래시 입력을 **회귀 테스트**로 즉시 봉인하고, 변환·열람은 **격리된 실행 환경**에서만 수행하는 습관이 **실제 사고 확률**을 크게 낮춥니다.
