---
layout: post
title: Git - reset --soft vs --hard
date: 2025-02-11 19:20:23 +0900
category: Git
---
# Git Reset: Soft vs Hard 비교 가이드

## Git의 세 가지 상태 레이어 이해하기

Git 작업은 세 가지 주요 상태 레이어로 구성되어 있습니다. `git reset` 명령어는 이들 레이어 중 어디까지를 이전 상태로 되돌릴지 결정합니다.

### 1. HEAD (커밋 레퍼런스)
현재 브랜치가 가리키는 최신 커밋을 나타내는 포인터입니다. 브랜치의 현재 위치를 정의합니다.

### 2. Index (스테이징 영역)
다음 커밋에 포함될 파일 변경사항들이 임시로 저장되는 공간입니다. `git add` 명령으로 파일을 추가하는 곳입니다.

### 3. Working Directory (작업 디렉토리)
실제 파일 시스템에서 작업 중인 파일들의 상태를 나타냅니다. 편집기에서 수정하고 있는 파일들이 이곳에 있습니다.

---

## Reset 옵션별 상세 비교

### git reset --soft (가장 안전한 옵션)

**작동 방식:**
- HEAD만 이전 커밋으로 이동합니다.
- Index와 Working Directory는 변경되지 않습니다.

**시각적 표현:**
```
초기 상태:
A---B---C (HEAD)

reset --soft HEAD~1 실행 후:
A---B (HEAD)
     \
      C (변경사항은 Index에 그대로 유지됨)
```

**실용적 예제:**
```bash
# 최근 커밋 취소 (변경사항 유지)
git reset --soft HEAD~1

# 커밋 메시지 수정 또는 추가 변경 후 재커밋
git commit -m "수정된 커밋 메시지"
```

**사용 사례:**
- 커밋 메시지 수정
- 여러 커밋을 하나로 합치기 (squash) 전 준비
- 커밋 순서 재정렬

### git reset --mixed (기본 옵션)

**작동 방식:**
- HEAD를 이전 커밋으로 이동합니다.
- Index를 해당 커밋의 상태로 재설정합니다.
- Working Directory는 변경되지 않습니다.

**시각적 표현:**
```
reset --mixed HEAD~1 실행 후:
A---B (HEAD)
     \
      C (변경사항은 Working Directory에만 남음, Index는 초기화됨)
```

**실용적 예제:**
```bash
# 최근 커밋 취소 및 스테이징 해제
git reset --mixed HEAD~1

# 변경사항 확인
git status  # unstaged 상태로 표시됨

# 선택적으로 파일 다시 스테이징
git add 파일명
git commit -m "재구성된 커밋"
```

**사용 사례:**
- 커밋을 여러 개로 분할
- 실수로 추가한 파일 제거
- 스테이징 영역 초기화

### git reset --hard (가장 위험한 옵션)

**작동 방식:**
- HEAD를 이전 커밋으로 이동합니다.
- Index를 해당 커밋의 상태로 재설정합니다.
- Working Directory도 해당 커밋의 상태로 완전히 복원합니다.

**시각적 표현:**
```
reset --hard HEAD~1 실행 후:
A---B (HEAD, Index, Working Directory 모두 동기화됨)
# C 커밋의 모든 변경사항 완전 삭제
```

**실용적 예제:**
```bash
# 모든 변경사항 완전히 폐기
git reset --hard HEAD~1

# 특정 브랜치의 상태로 완전히 복원
git reset --hard origin/main
```

**중요 참고사항:**
- `--hard`는 추적 중인(tracked) 파일의 변경사항만 삭제합니다.
- 추적되지 않은(untracked) 파일은 삭제되지 않습니다.
- `git clean` 명령은 추적되지 않은 파일을 정리하는 별도의 작업입니다.

**사용 사례:**
- 실험적인 변경사항 완전 폐기
- 빌드 아티팩트 또는 임시 파일 정리
- 저장소 상태 완전 초기화

---

## 옵션별 비교 테이블

| 옵션 | HEAD 이동 | Index 상태 | Working Directory | 안전도 | 주요 용도 |
|------|-----------|------------|-------------------|--------|-----------|
| `--soft` | 예 | 변경 없음 | 변경 없음 | 높음 | 커밋 메시지 수정, 커밋 재구성 |
| `--mixed` | 예 | 초기화됨 | 변경 없음 | 중간 | 스테이징 해제, 커밋 분할 |
| `--hard` | 예 | 초기화됨 | 완전 복원 | 낮음 | 변경사항 완전 폐기, 상태 초기화 |

---

## 실무에서의 일반적인 사용 패턴

### 1. 커밋 메시지 수정하기
```bash
# 최근 커밋 취소 (변경사항 유지)
git reset --soft HEAD~1

# 새 메시지로 재커밋
git commit -m "새로운 커밋 메시지"
```

**대안:** 바로 이전 커밋이라면 `git commit --amend`를 사용할 수 있습니다.

### 2. 커밋을 여러 개로 분할하기
```bash
# 최근 커밋을 unstaged 상태로 분해
git reset --mixed HEAD~1

# 변경사항 부분별로 선택적 스테이징
git add -p

# 각 부분을 별도로 커밋
git commit -m "첫 번째 부분"
git commit -m "두 번째 부분"
```

### 3. 실수로 추가한 파일 제거하기
```bash
# 특정 파일만 스테이징 해제
git reset HEAD -- 잘못된파일.txt

# 모든 스테이징 해제
git reset
```

### 4. Working Directory 정리하기
```bash
# 모든 변경사항 폐기
git reset --hard

# 추적되지 않은 파일까지 정리 (주의 필요)
git clean -fd
```

### 5. 특정 파일만 이전 상태로 복원
```bash
# Git 2.23 이전
git checkout 커밋해시 -- 파일명

# Git 2.23 이후 (권장)
git restore --source=커밋해시 -- 파일명
```

---

## 협업 환경에서의 안전 가이드라인

### 사용 가능한 경우
- **개인 브랜치**: 모든 reset 옵션 자유롭게 사용 가능
- **로컬 커밋 정리**: 푸시 전 커밋 구조 정돈
- **실험적 변경 폐기**: 로컬에서의 테스트 결과 정리

### 사용을 피해야 하는 경우
- **공유 브랜치**: 이미 다른 사람이 pull한 브랜치
- **원격에 푸시된 커밋**: 협업자들의 히스토리 손상 가능성
- **팀 정책 위반**: 조직의 Git 워크플로우 규칙 확인 필요

### 안전한 대체 방법
공유 브랜치에서 변경사항을 취소해야 할 경우:
```bash
# revert 사용 (히스토리 보존)
git revert 커밋해시
```

불가피하게 히스토리 재작성이 필요할 경우:
```bash
# 안전한 강제 푸시
git push --force-with-lease
```

---

## 관련 명령어 비교

| 명령어 | 목적 | 안전성 | 권장 사용처 |
|--------|------|--------|------------|
| `git reset --soft` | 커밋 취소 (변경 유지) | 높음 | 커밋 메시지/구조 정리 |
| `git reset --mixed` | 커밋 취소 + 스테이징 해제 | 중간 | 커밋 재구성 |
| `git reset --hard` | 완전 상태 초기화 | 낮음 | 실험 변경 폐기 |
| `git revert` | 취소 커밋 생성 | 매우 높음 | 공유 브랜치 변경 취소 |
| `git checkout` | 파일/브랜치 전환 | 중간 | 파일 복원 (구식) |
| `git restore` | 파일 상태 복원 | 높음 | 파일 복원 (현대) |
| `git clean` | 미추적 파일 삭제 | 위험 | 작업 공간 정리 |

---

## 실수 복구 방법

### 가장 일반적인 복구 방법
```bash
# 작업 기록 확인
git reflog

# 원하는 시점으로 복구
git reset --hard HEAD@{번호}

# 또는 안전하게 새 브랜치 생성
git switch -c 복구브랜치 HEAD@{번호}
```

### ORIG_HEAD 활용
Git은 많은 작업에서 이전 HEAD 위치를 ORIG_HEAD에 저장합니다:
```bash
# 직전 작업 상태로 복구
git reset --hard ORIG_HEAD
```

### 백업 전략
중요한 작업 전에 항상 백업을 생성하는 습관을 들이세요:
```bash
# 백업 브랜치 생성
git branch 백업/작업전-$(date +%Y%m%d-%H%M)

# 또는 태그 사용
git tag 작업전-백업
```

---

## 고급 시나리오 및 고려사항

### 서브모듈이 있는 경우
Reset은 상위 저장소의 서브모듈 참조만 변경합니다:
```bash
# 서브모듈 상태 동기화
git submodule update --init --recursive
```

### 스파스 체크아웃 환경
스파스 체크아웃을 사용 중이라면 reset의 영향이 제한된 경로에만 적용됩니다.

### Git Hooks와의 상호작용
로컬에서 reset을 수행해도 서버측 hooks는 영향을 받지 않지만, 히스토리 재작성 후 푸시하면 CI/CD 파이프라인이 예상치 못하게 동작할 수 있습니다.

---

## 실전 시나리오 모음

### 시나리오 1: 커밋 메시지 실수 수정
```bash
# 잘못된 커밋 메시지로 커밋한 경우
git reset --soft HEAD~1
git commit -m "올바른 커밋 메시지"
```

### 시나리오 2: 여러 커밋을 하나로 합치기
```bash
# 최근 3개 커밋을 하나로 합치기
git reset --soft HEAD~3
git commit -m "통합: 기능 A, B, C 구현"
```

### 시나리오 3: 실험적 코드 완전 폐기
```bash
# 모든 변경사항 삭제 및 최신 상태로 복원
git reset --hard origin/main
```

### 시나리오 4: 특정 파일만 이전 버전으로 복원
```bash
# 특정 파일만 2커밋 전 상태로 복원
git restore --source=HEAD~2 -- 문제된파일.js
```

### 시나리오 5: 스테이징 실수 복구
```bash
# 실수로 모든 파일을 스테이징한 경우
git reset
# 또는 특정 파일만
git reset HEAD -- 실수로추가한파일.txt
```

---

## 상태 확인 명령어

Reset 작업 전후로 상태를 확인하는 것이 중요합니다:

```bash
# 현재 상태 종합 확인
git status

# Working Directory와 Index 차이 확인
git diff

# Index와 HEAD 차이 확인
git diff --cached

# 특정 커밋의 파일 내용 확인
git show 커밋해시:파일명
```

---

## 자주 묻는 질문 (FAQ)

**Q: `--hard` 옵션으로 삭제된 파일을 복구할 수 있나요?**
A: 네, `git reflog`를 사용하여 삭제 직전 상태로 복구할 수 있습니다. 그러나 시간이 지나면 가비지 컬렉션에 의해 영구 삭제될 수 있습니다.

**Q: 추적되지 않은 파일도 `--hard`로 삭제되나요?**
A: 아니요, `--hard`는 추적 중인 파일만 처리합니다. 추적되지 않은 파일을 삭제하려면 `git clean`을 사용해야 합니다.

**Q: 이미 푸시한 커밋을 reset 해도 되나요?**
A: 공유 브랜치에서는 피해야 합니다. 대신 `git revert`를 사용하여 안전하게 변경사항을 취소하세요.

**Q: `reset --soft`과 `commit --amend`의 차이는 무엇인가요?**
A: 둘 다 커밋 메시지를 수정할 수 있지만, `commit --amend`는 바로 이전 커밋만 수정할 수 있는 반면, `reset --soft`은 여러 커밋을 되돌릴 수 있습니다.

**Q: Reset 전에 어떤 확인 작업을 해야 하나요?**
A: 1) `git status`로 현재 상태 확인, 2) `git log`로 커밋 히스토리 확인, 3) 백업 브랜치 생성 고려

---

## 모범 사례 요약

### 안전 작업 원칙
1. **개인 브랜치 한정**: 공유 브랜치에서는 reset 사용 자제
2. **백업 습관**: 중요한 변경 전에 백업 브랜치 또는 태그 생성
3. **상태 확인**: reset 전후로 `git status`와 `git log` 확인
4. **점진적 접근**: 큰 변경은 작은 단위로 나누어 진행

### 옵션 선택 가이드
- **가벼운 정리**: `--soft` 또는 `--mixed` 사용
- **완전 초기화**: `--hard` 사용 (주의 필요)
- **협업 환경**: `revert` 우선 고려

### 복구 전략
1. **Reflog 활용**: `git reflog`로 이전 상태 확인
2. **ORIG_HEAD**: 위험 작업 후 즉시 복구 가능
3. **원격 백업**: 중요한 브랜치는 원격에도 푸시하여 안전장치 마련

---

## 결론

Git의 `reset` 명령어는 개발 워크플로우에서 히스토리를 관리하는 강력한 도구이지만, 그 힘은 신중한 사용에서 비롯됩니다. 세 가지 주요 옵션(`--soft`, `--mixed`, `--hard`)은 각각 다른 수준의 변경을 제공하며, 상황에 맞는 옵션 선택이 핵심입니다.

### 핵심 포인트 정리

1. **목적에 맞는 옵션 선택**: 
   - 간단한 커밋 수정 → `--soft`
   - 커밋 재구성 → `--mixed`
   - 완전한 상태 초기화 → `--hard`

2. **협업 환경 고려**:
   - 개인 브랜치에서는 자유롭게 사용
   - 공유 브랜치에서는 `revert` 우선 고려
   - 팀의 Git 정책 준수 필수

3. **안전 작업 습관**:
   - 중요한 작업 전 백업
   - 상태 확인 후 실행
   - 복구 방법 익히기

4. **현대적 대안 고려**:
   - `git restore` (파일 복원)
   - `git switch` (브랜치 전환)
   - `git revert` (안전한 변경 취소)

`git reset`을 효과적으로 사용하는 것은 Git을 전문적으로 다루는 개발자에게 필수적인 스킬입니다. 각 옵션의 특징을 이해하고, 실수에서 배우며, 점차 복잡한 시나리오에 적용해나가는 과정을 통해 Git을 더욱 효율적으로 활용할 수 있습니다. 가장 중요한 것은 언제나 안전을 고려하고, 팀 협업을 방해하지 않는 방식으로 도구를 사용하는 것입니다.