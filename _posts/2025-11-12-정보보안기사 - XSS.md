---
layout: post
title: 정보보안기사 - XSS
date: 2025-11-12 21:25:23 +0900
category: 정보보안기사
---
# SECTION 08 웹 애플리케이션 취약점 — 02. 크로스 사이트 스크립트(XSS: Cross-Site Scripting) 완전 정리 (유형·컨텍스트·현대 브라우저·프레임워크별 안전코딩·CSP/Trusted Types·테스트/모니터링·체크리스트·예상문제)

## 개요 — “데이터가 코드가 되는 순간”
**XSS**는 사용자가 제공한 **데이터가 브라우저에서 실행 가능한 코드(주로 JavaScript)**로 해석될 때 발생한다. 결과적으로 **세션 탈취, UI 변조, 피싱, 계정 탈취, 내부 리소스 요청** 등으로 이어질 수 있다.  
핵심은 **출력 컨텍스트별 인코딩/검증**과 **프레임워크·브라우저 기능(CSP·Trusted Types 등)**을 올바르게 사용하는 것이다.

---

## 위협 모델과 작동 원리(간단 수식 표현)
입력 \(x\)가 뷰 템플릿 \(T(\cdot)\)에 삽입될 때:

- 안전한 경우(데이터는 데이터로만):  
  $$ \text{safe\_html} \;=\; T(\mathrm{encode\_by\_context}(x)) $$
- 취약한 경우(데이터가 코드로 승격):  
  $$ \text{unsafe\_html} \;=\; T(\mathrm{concat}(x)) $$

브라우저는 **HTML/DOM 파서**로 문맥을 해석한다. 문맥을 깨는 특수 문자(예: `<`, `"`, `'`, `>`), 이벤트 속성(`on*`), 위험 스킴(`javascript:`), 동적 JS 삽입 지점이 합쳐지면 **코드 실행**에 도달한다.

---

## XSS의 4대 유형과 변형

### 1. **Reflected XSS** (반사형)
- 요청 파라미터·헤더에 넣은 입력이 **즉시 응답에 반사**되어 실행
- 검색·에러 페이지, 쿼리스트링 반사 등에서 흔하다

### 2. **Stored XSS** (저장형, 2차 XSS 포함)
- 악성 입력이 DB/캐시/파일에 **저장**되었다가 **다른 사용자**에게 전달될 때 실행
- 게시글/댓글/프로필/로그 등 장기 저장 지점에서 위험

### 3. **DOM-based XSS** (클라이언트 측)
- 서버 HTML이 안전하더라도, **클라이언트 JS가 location/hash/DOM에서 입력을 읽어** `innerHTML` 등 **싱크(sink)**에 꽂아 실행

### 4. **mXSS/Polyglot·우회 기법**
- 브라우저 파서/정규화/교정 과정에서 인코딩을 스쳐 나오는 변형
- SVG/MathML, 템플릿 엔진, 마크다운 렌더러 등 **비전형 컨텍스트**로도 유입

> 그 밖에 **Self-XSS**(사용자 스스로 콘솔에 붙여넣게 유도), **XS-Leaks**(측채널로 정보 유출) 등 인접 개념이 있다.

---

## 컨텍스트(문맥)별 위험과 인코딩 규칙

| 컨텍스트 | 예 | 안전 패턴(요지) | 금지/주의 |
|---|---|---|---|
| **HTML 본문** | `<div>{{data}}</div>` | HTML 이스케이프 (`&`, `<`, `>`, `"`, `'`) | `innerHTML`로 직접 삽입 |
| **HTML 속성 값** | `<img alt="{{data}}">` | 속성 인코딩 + 따옴표로 감싸기 | 이벤트 속성(`on*`)·`srcdoc` |
| **URL 속성** | `<a href="{{url}}">` | **프로토콜 화이트리스트**(`https:`, `mailto:` 등) | `javascript:`, `data:`(특히 `text/html`) |
| **JS 문자열 리터럴** | `<script>var x='{{data}}'</script>` | JS 문자열 이스케이프 + `<script>` 내 삽입 지양 | `</script>` 중단, 템플릿 보간 |
| **CSS 컨텍스트** | `style="background:url({{u}})"` | 인라인 CSS 지양, 클래스/토큰 화이트리스트 | `url()`에 `javascript:` |
| **DOM API** | `el.innerHTML = data` | **`textContent`/`setAttribute`**/템플릿 바인딩 | `innerHTML`/`insertAdjacentHTML` |

> “**컨텍스트-인식(Context-Aware) 인코딩**”이 정석이다. 단일 함수로 모든 컨텍스트를 안전하게 만들 수 없다.

---

## 프레임워크/템플릿 엔진별 안전 기본기

### 서버 측 템플릿
- **Django/Jinja2**: 기본 **자동 이스케이프**. `{{ x }}`는 안전, `|safe` 남용 금지.
- **Thymeleaf**: `th:text="${x}"`는 이스케이프, `th:utext`는 비이스케이프(주의).
- **JSP/EL**: `${x}`는 EL 이스케이프, `out.print`에 `escapeXml=true` 권장.
- **Go html/template**: 컨텍스트 인식 이스케이프 내장. `text/template`는 **비권장**.
- **EJS/Handlebars/Pug**: `<%= x %>`(escape) vs `<%- x %>`(raw) 구분 엄수.

### 클라이언트 프레임워크
- **React**: JSX는 **자동 이스케이프**. `dangerouslySetInnerHTML`는 **금지**(필요 시 DOMPurify).
- **Vue**: `{{ }}`는 이스케이프. `v-html`은 **비이스케이프** → 제한된 신뢰 입력만.
- **Angular**: 템플릿 바인딩은 안전. URL/리소스는 **Sanitizer**가 검증. `bypassSecurityTrust*` 남용 금지.
- **Svelte**: `{@html}`은 비이스케이프 → DOMPurify 병행.

---

## 짧은 “취약 vs 안전” 코드 비교(언어/엔진별)

### 1. Django (서버 측)
```python
# ❌ 취약: safe 남용
{{ user_bio|safe }}
```
```python
# ✅ 안전: 기본 자동 이스케이프 유지
{{ user_bio }}
```

### 2. Thymeleaf (Spring)
```html
<!-- ❌ 취약 -->
<p th:utext="${comment}"></p>
```
```html
<!-- ✅ 안전 -->
<p th:text="${comment}"></p>
```

### 3. React
```jsx
// ❌ 취약
<div dangerouslySetInnerHTML={{ __html: props.html }} />
```
```jsx
// ✅ 안전 (정말 필요한 경우에만)
import DOMPurify from 'dompurify';
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(props.html) }} />
```

### 4. Vue
```html
<!-- ❌ 취약 -->
<div v-html="rawHtml"></div>
```
```html
<!-- ✅ 안전 -->
<div>{{ textOnly }}</div>
```

### 5. Go
```go
// ❌ 취약: text/template는 컨텍스트 인식 X
t := template.Must(template.New("v").Parse(`<a href="{{.}}">`))
```
```go
// ✅ 안전: html/template 사용
t := template.Must(htmltemplate.New("v").Parse(`<a href="{{.}}">`))
```

### 6. PHP
```php
// ❌ 취약
echo "<p>".$_GET['msg']."</p>";
```
```php
// ✅ 안전
echo "<p>".htmlspecialchars($_GET['msg'], ENT_QUOTES, 'UTF-8')."</p>";
```

---

## DOM 기반 XSS: 소스·싱크 개념과 안전한 대체 API

### 전형적 위험 패턴
```js
// ❌ 취약: location에서 가져온 값 → innerHTML
const q = new URLSearchParams(location.search).get('q') || '';
results.innerHTML = `<b>${q}</b>`;
```

### 안전 대체
```js
// ✅ 안전: textContent로 텍스트만 주입
const q = new URLSearchParams(location.search).get('q') || '';
results.textContent = q;

// ✅ 템플릿을 써야 한다면, createElement 조립
const b = document.createElement('b');
b.textContent = q;
results.replaceChildren(b);
```

**주의할 싱크(sink)**: `innerHTML`, `outerHTML`, `document.write`, `insertAdjacentHTML`, `Range.createContextualFragment`, `eval`, `new Function`, `setTimeout(String)`, 이벤트 핸들러 속성(`el.onclick = ...`에 문자열) 등.

---

## CSP(Content-Security-Policy)와 Trusted Types

### CSP의 핵심 전략
- **inline script 차단**: `script-src 'self' 'nonce-<랜덤>' 'strict-dynamic'`
- **외부 도메인 화이트리스트**: CDN 등 최소화
- **업무 단계**: `Report-Only`로 위반 리포트 수집 → 강제 전환

#### Nginx 예시
```nginx
# ✅ 강력한 CSP (예: nonce 기반)
add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'nonce-__NONCE__' 'strict-dynamic'; object-src 'none'; base-uri 'self'; frame-ancestors 'none';" always;
```

### Trusted Types(크롬·엣지)
- DOM 싱크에 문자열을 바로 공급하지 못하게 하고, **승인된 팩토리**로 생성한 객체만 허용
```html
<meta http-equiv="Content-Security-Policy" content="require-trusted-types-for 'script'; trusted-types app;">
<script>
  // 등록
  const policy = trustedTypes.createPolicy('app', {
    createHTML: (s) => DOMPurify.sanitize(s)
  });
  // 사용
  el.innerHTML = policy.createHTML(userInput);
</script>
```
> **CSP + Trusted Types**는 현대 웹에서 DOM XSS 방어의 “마지막 울타리”로 유효하다.

---

## URL·프로토콜 안전화

- `href`, `src` 등 URL 속성은 **프로토콜 화이트리스트**로 검증한다.
- 허용 예: `https:`, `http:`, `mailto:`, `tel:` 등 도메인/패스 제약 포함.
- 금지/주의: `javascript:`, `data:text/html`, `vbscript:` …

```js
function isSafeUrl(u) {
  try {
    const url = new URL(u, location.origin);
    return ['http:', 'https:'].includes(url.protocol) && url.origin === location.origin;
  } catch { return false; }
}
```

---

## 마크다운/리치 텍스트 렌더링 시 주의

- 마크다운 렌더러는 **HTML 패스스루**가 가능한 경우가 많음.  
- **DOMPurify** 같은 **화이트리스트 기반 Sanitizer** 사용:
```js
import DOMPurify from 'dompurify';
const safe = DOMPurify.sanitize(marked(md), { USE_PROFILES: { html: true } });
container.innerHTML = safe;
```
- Sanitizer 옵션에서 **SVG/XLink/MathML** 등 **우회 벡터**를 점검.

---

## 브라우저·쿠키·보안 헤더 세트

- **쿠키**: `HttpOnly`(JS 접근 차단), `Secure`, `SameSite=Lax/Strict`  
- **X-Frame-Options / frame-ancestors**: 클릭재킹 차단  
- **Referrer-Policy**: 민감 경로 노출 최소화  
- **COOP/COEP/CORP**: 교차 문맥 격리로 일부 **XS-Leaks** 완화  
- **X-XSS-Protection**: **구식/비권장**(현대 브라우저 비활성/예측 불가)

---

## 테스트/진단(승인된 테스트 환경 전제)

### 1. 무해한 확인 페이로드(학습용)
- HTML 브레이크 확인: `"><b>x</b>`  
- 이벤트 차단 확인(정상 동작해야 함): `<img alt="x">` — **onerror** 등은 서버가 제거/이스케이프해야 한다.

> 실제 공격성 페이로드나 민감정보 탈취 시나리오는 **실운영에서 금지**. 학습은 **격리 랩**에서만.

### 2. 자동화/도구(테스트 환경)
- 동적 스캐너(DAST)로 흔한 컨텍스트 취약 검출  
- 브라우저 DevTools **CSP Violation Reports** 확인  
- 단위/통합 테스트: 위험 싱크 호출 여부 정적분석(SAST) + 런타임 샌드박스

---

## 운영·모니터링 룰

- **로그**: 응답에 포함된 비정상 태그/속성 비율, CSP 위반 리포트, Sanitizer drop 통계
- **SIEM 룰**: `javascript:`, `<script`, `onerror=`, `svg/onload` 등 **패턴 알림**(오탐 관리)
- **알림과 풍선효과**: 차단 후 사용자 영향/오탐을 지표화해 점진적 강화

---

## CI/CD에 넣는 안전코딩 규칙(샘플)

1) 템플릿 리뷰 규칙  
   - [ ] 비이스케이프 출력(`safe`, `utext`, `Raw`, `v-html`, `dangerouslySetInnerHTML`) 사용 이유와 **근거 문서화**  
   - [ ] URL 속성은 **프로토콜 화이트리스트** 적용

2) 코드 스멜 정적분석(예)  
   - [ ] `innerHTML` 직접 할당 금지(예외 시 DOMPurify+정책)  
   - [ ] `eval/new Function/setTimeout(String)` 불허

3) 보안 헤더  
   - [ ] CSP **Report-Only → Enforce** 전환 계획  
   - [ ] Trusted Types 적용 대상 식별

---

## 실무 예제: Express(서버) + Nginx 헤더 + React(클라)

### 1. Express + Helmet + CSRF + 템플릿 이스케이프
```js
// app.js
import express from 'express';
import helmet from 'helmet';
import csurf from 'csurf';
import path from 'path';

const app = express();
app.use(helmet({
  contentSecurityPolicy: false // Nginx에서 CSP 주입(또는 여기서 직접 구성)
}));
app.use(express.urlencoded({ extended: false }));
app.use(csurf());

app.set('view engine', 'ejs');
app.set('views', path.join(process.cwd(), 'views'));

app.get('/search', (req, res) => {
  res.render('search', { q: req.query.q || '', csrfToken: req.csrfToken() });
});

app.listen(3000);
```

```ejs
<!-- views/search.ejs -->
<!doctype html>
<html>
  <body>
    <form method="get">
      <input name="q" value="<%= q %>"><!-- EJS <%= %>는 이스케이프 -->
      <button>Search</button>
      <input type="hidden" name="_csrf" value="<%= csrfToken %>">
    </form>
    <div id="r"></div>
    <script>
      // DOM XSS 방지: textContent 사용
      const p = new URLSearchParams(location.search);
      const r = document.getElementById('r');
      if (p.get('q')) {
        const b = document.createElement('b');
        b.textContent = p.get('q');
        r.replaceChildren(b);
      }
    </script>
  </body>
</html>
```

### 2. Nginx에서 CSP/기본 헤더
```nginx
add_header X-Content-Type-Options "nosniff" always;
add_header X-Frame-Options "DENY" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
# CSP는 빌드 시 nonce 치환(예: __NONCE__)
add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'nonce-__NONCE__' 'strict-dynamic'; object-src 'none'; base-uri 'self'; frame-ancestors 'none';" always;
```

### 3. React 컴포넌트(안전 패턴)
```jsx
// SearchResult.jsx
export default function SearchResult({ query }) {
  // textContent에 해당하는 JSX 기본 이스케이프
  return <div><b>{query}</b></div>;
}
```

---

## 체크리스트(현장용)

- [ ] **컨텍스트 인식 인코딩**: HTML/Attr/URL/JS/CSS 컨텍스트별 처리
- [ ] **비이스케이프 출력 금지**(`safe`, `utext`, `Raw`, `v-html`, `dangerouslySetInnerHTML`)
- [ ] **DOM API**: `textContent`/`setAttribute`/createElement 우선, `innerHTML` 금지
- [ ] **URL 검증**: 프로토콜/도메인 화이트리스트
- [ ] **Sanitizer**: DOMPurify 등 화이트리스트 기반, SVG/MathML 옵션 점검
- [ ] **CSP**: nonce 기반 + `strict-dynamic`, `Report-Only` → Enforce 전환
- [ ] **Trusted Types**: DOM 싱크 보호, 정책 팩토리 도입
- [ ] **쿠키 보안**: `HttpOnly`/`Secure`/`SameSite`
- [ ] **정적/동적 분석**: SAST(위험 싱크), DAST(컨텍스트), IAST/RASP(선택)
- [ ] **로그/모니터링**: CSP 위반, Sanitizer drop, 의심 키워드 패턴

---

## 예상문제(실기 감각 강화)

1) **문항**: 다음 중 DOM XSS 방지에 가장 적합한 것은?  
   a) `element.innerHTML = userInput`  
   b) `element.textContent = userInput`  
   c) `document.write(userInput)`  
   d) `setTimeout(userInput, 0)`  
   **정답**: b

2) **문항**: 템플릿 엔진에서 비이스케이프 출력이 필요한 경우, 필수 보완책 2가지를 쓰시오.  
   **예시 답**: (1) DOMPurify 같은 Sanitizer로 화이트리스트 정화, (2) CSP nonce/strict-dynamic 적용

3) **문항**: 다음 중 URL 속성에 대한 안전한 처리 전략으로 옳지 않은 것은?  
   a) 프로토콜 화이트리스트 사용  
   b) `javascript:` 허용하되 인코딩  
   c) 도메인/경로 화이트리스트  
   d) 실패 시 빈 문자열로 폴백  
   **정답**: b

4) **문항**: React에서 `dangerouslySetInnerHTML` 사용이 불가피한 경우 보완 대책 2가지를 쓰시오.  
   **예시 답**: DOMPurify sanitize, CSP nonce/Trusted Types 정책 적용

5) **문항**: 아래 Thymeleaf 코드가 위험한 이유와 수정안을 쓰시오.  
```html
<p th:utext="${bio}"></p>
```  
**모범답안 요지**: 비이스케이프 출력으로 XSS 위험. `th:text="${bio}"`로 변경.

---

## 미니 계산 문제(리스크 직관)
XSS 리스크 \(R\)를 단순화해 **발생확률 \(L\)**과 **영향도 \(I\)**의 곱으로 표현하면:
\[
R = L \times I
\]
- CSP/Trusted Types·Sanitizer·컨텍스트 인코딩을 추가할수록 \(L\)이 크게 하락.
- 세션 하이재킹·내부 자산 접근 등 영향 완화(권한 분리·토큰 범위 제한)로 \(I\)도 하락.

---

## 결론
- XSS는 **출력 컨텍스트와 DOM 싱크**를 이해하면 원천 차단 가능하다.  
- “**이스케이프(기본)** → **Sanitizer(예외)** → **CSP/Trusted Types(최후)**”의 **다층 방어**를 적용하라.  
- 프레임워크의 **자동 이스케이프 규칙**을 신뢰하되, **비이스케이프 기능은 원칙적으로 금지**하라.  
- CI/CD·모니터링·교육으로 **조기 탐지와 회귀 방지**를 시스템에 내재화하라.