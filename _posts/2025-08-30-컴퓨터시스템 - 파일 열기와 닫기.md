---
layout: post
title: 컴퓨터시스템 - 파일 열기와 닫기
date: 2025-08-30 22:20:23 +0900
category: 컴퓨터시스템
---
# 파일 **열기와 닫기** — UNIX/Linux 심층 가이드

> 포커스: `open/openat/creat/mkstemp`, 플래그/모드, **권한/umask**, **TOCTTOU 방지**, `O_CLOEXEC`, 파일 디스크립터(FD) 수명주기, `close`의 미묘함(`EINTR`, 에러 전파), **데이터 영속성**(`fsync`), 임시파일(`O_TMPFILE`), 잠금/dup와의 상호작용, 안전한 코드 패턴.

---

## 0) 큰 그림: “열기 → 사용 → 닫기”의 계약

- **열기(open)**: 경로 해석 + 권한 검사 + 커널에 **열린 파일 설명자(open file description)** 생성 → **FD(정수)** 반환.
- **사용**: `read/write/lseek/fcntl/...` 는 **FD**를 통해 그 설명자에 접근.
- **닫기(close)**: 해당 FD의 **참조 카운트**를 감소. 마지막 참조가 닫히면 커널이 설명자를 정리하고, 잠금/리소스/캐시를 해제·동기화.

---

## 1) 파일 열기 — 시스템콜과 변종

### 1.1 기본
```c
#include <fcntl.h>
int fd = open(const char *path, int flags, ... /* mode_t mode if O_CREAT */);
```
- 실패 시 `-1`과 `errno` 설정.

### 1.2 `openat` (경로 레이스·상대경로 제어)
```c
int fd = openat(int dirfd, const char *path, int flags, mode_t mode);
```
- `dirfd` 기준 상대 경로 해석. 보안/샌드박스/서버에서 **TOCTTOU** 방지에 핵심.
- `dirfd = AT_FDCWD`면 현재 작업디렉터리 기준.

### 1.3 `creat`
- 역사적 API. `creat(path, mode)` ≒ `open(path, O_WRONLY|O_CREAT|O_TRUNC, mode)`.

### 1.4 안전한 임시파일
- **권장**: `mkstemp()` → 경로 생성과 **배타적 open**을 동시에 수행.
- Linux 전용: `open(path, O_TMPFILE|O_EXCL|O_RDWR, 0600)` (FS 지원 필요) → **디렉터리에 연결되지 않은 익명 파일** 생성. 필요 시 `linkat`로 이름 붙이기.

---

## 2) 플래그(`flags`)·모드(`mode`) 총정리

### 2.1 접근/생성/배치 플래그
| 플래그 | 의미/용도 |
|---|---|
| `O_RDONLY/O_WRONLY/O_RDWR` | 접근 모드(필수 중 하나) |
| `O_CREAT` | 없으면 생성 (`mode` 필요; `umask` 적용) |
| `O_EXCL` | `O_CREAT` 와 함께 **이미 존재하면 실패**(경쟁 안전 생성) |
| `O_TRUNC` | 열 때 길이 0으로 |
| `O_APPEND` | 매 쓰기가 **끝에** 추가(오프셋 경쟁 방지) |
| `O_CLOEXEC` | **exec 시 자동 닫힘**(FD 유출 방지) |
| `O_NOFOLLOW` | 경로 마지막 요소에 대한 심링크 거부(레이스·권한 상승 방지) |
| `O_DIRECTORY` | 디렉터리만 열기(아닌 경우 실패) |
| `O_NONBLOCK` | 비차단 I/O(파이프/소켓/터미널 등) |
| `O_SYNC/O_DSYNC` | 동기식 쓰기(메타데이터 포함/제외) |
| `O_DIRECT` | 페이지캐시 우회(버퍼 정렬 요구) |

### 2.2 모드(`mode_t`)
- `O_CREAT` 시 **초기 퍼미션**. **`umask`**가 빼기(subtract) 적용.
- 8진수로 표기: 예 `0644`(rw-r--r--), `0600`(rw-------).

### 2.3 권장 조합 예
- 새 파일 배타적 생성: `O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC`, 모드 `0600` or `0644`.
- 로그 append 전용: `O_WRONLY|O_APPEND|O_CLOEXEC`.
- 디렉터리 핸들: `O_RDONLY|O_DIRECTORY|O_CLOEXEC`.

---

## 3) **권한/umask**와 보안 관점

- `umask`는 **프로세스 전역**. 예: `umask(077); open(..., 0666)` → 결과 권한 `0600`.
- **권장**: 민감 데이터는 `mode` 자체를 최소로 (`0600`), 그리고 필요 시 `fchmod`로 넓히기.
- **접근 사전검사 금지**: `access()`로 미리 검사하고 `open()` 하는 패턴은 **TOCTTOU** 야기. **바로 `open` 시도**하고 에러로 판단.

---

## 4) 경로 레이스(TOCTTOU) 방지 레시피

- 디렉터리 FD를 잡고(예: `dfd = open("/safe", O_RDONLY|O_DIRECTORY|O_CLOEXEC)`),  
  **항상** `openat(dfd, "file", O_NOFOLLOW|O_CREAT|O_EXCL|...)`.
- 심링크/교체 공격 방지: `O_NOFOLLOW`, 필요 시 `fstatat`로 유형 재검증.
- 원자적 교체: **임시 파일에 쓰고 → `fsync` → `rename`**(동일 FS에서 원자적).

---

## 5) 파일 디스크립터(FD) 수명·복제

### 5.1 복제: `dup/dup2/dup3` & `fcntl(F_DUPFD[_CLOEXEC])`
```c
int nfd = dup(fd);                 // 가장 낮은 미사용 FD 할당
int nfd = dup2(fd, target_fd);     // target_fd로 강제(기존 닫힘)
int nfd = dup3(fd, target_fd, O_CLOEXEC);
```
- 리디렉션: `dup2(fd, STDOUT_FILENO)`.
- `fcntl(fd, F_SETFD, FD_CLOEXEC)`로 사후 `CLOEXEC` 가능(경쟁 위험 존재 → 생성 시 `O_CLOEXEC` **권장**).

### 5.2 FD 한도/오류
- `EMFILE`(프로세스 한도), `ENFILE`(시스템 한도).  
  → **예약 FD 전략**(비상용 FD 하나 열어두고 해제 후 처리) 유용.
- 한도 조회/변경: `getrlimit(RLIMIT_NOFILE, ...)`, `prlimit`.

---

## 6) 닫기(close)의 **진짜 의미**와 주의점

```c
#include <unistd.h>
int r = close(fd);
```
- **반환값**: 0(성공) / -1(오류).  
- **`EINTR`**: 신호로 중단될 수 있음. POSIX는 **FD 상태가 불특정**이라고 명시 → **실무에서는 성공으로 간주**하고 재시도하지 않는 것이 안전.  
- **`EIO` 등 에러 전파**: 네트워크/NFS/저널드 FS에서 **쓰기 오류가 `close` 때 보고**될 수 있음.  
  → 쓰기 경로의 **마지막 오류 체크**로 `close` 리턴을 반드시 확인.

> **중요**: 데이터 영속성은 `close`만으로 **보장되지 않음**. 디스크 캐시/저널 정책에 따라 **`fsync`/`fdatasync`** 필요(§7).

### 6.1 잠금과 close
- `fcntl` 레코드 잠금은 **프로세스 단위**: 같은 파일에 대한 **어느 FD를 닫아도** 그 파일에 대한 **해당 프로세스의 모든 레코드 잠금이 해제**.
- `flock`은 **open file description** 단위: 그 설명자에 연결된 모든 FD가 닫혀야 해제.

### 6.2 소켓/파이프의 close
- `SO_LINGER`가 설정되면 `close`가 **블록**될 수 있음(전송 완료 대기).
- 반쪽 종료: `shutdown(fd, SHUT_WR)`로 쓰기 스트림만 종료.

---

## 7) **데이터 영속성**과 안전한 파일 갱신

### 7.1 안전 갱신 패턴(크래시/전원 장애 대비)
1) 임시 파일에 쓰기  
2) `fsync(tmpfd)` (데이터 디스크에)  
3) `rename(tmp, target)` (동일 FS에서 원자적 교체)  
4) 디렉터리 `fsync(dirfd)` (엔트리까지 보존)

### 7.2 `O_SYNC/O_DSYNC` vs `fsync`
- `O_SYNC`: 각 `write`가 **데이터+메타데이터** 안정화까지 대기(비용↑).
- `O_DSYNC`: 데이터 위주 동기화. 메타데이터 일부 지연 가능.
- 일반적으론 **버스트 쓰기 + 명시적 `fsync`**가 더 효율적인 경우가 많다.

---

## 8) 임시 파일과 삭제 시맨틱

- **열린 파일을 `unlink`** 해도 FD로는 계속 접근 가능. 마지막 FD가 닫히면 **실제 제거**.  
  → 임시파일을 **이름 없는 상태**로 사용 가능(경쟁·청소 문제 감소).
- Linux **`O_TMPFILE`**: 생성부터 무명. 필요할 때 `linkat`로 이름 부여.

---

## 9) 표준 I/O(`stdio`)와의 상호작용

- `fopen/fclose`는 내부 버퍼를 가지며 OS FD 위에 얹힌다.
- **혼용 주의**: 동일 FD를 `FILE*`과 직접 `write`로 섞어 쓰면 순서/버퍼가 뒤엉킬 수 있음.  
  → 필요 시 `fflush`, `fsync(fileno(fp))`, 또는 **한쪽만 사용**.
- `fdopen(fd, "r+")`로 기존 FD를 `FILE*`로 감싸기.

---

## 10) 에러와 방어적 프로그래밍

- `open` 공통 에러: `ENOENT`(없음), `EEXIST`(배타생성 충돌), `EACCES/EPERM`(권한), `EISDIR`(디렉터리에 쓰기), `ELOOP`(심링크 루프), `ENAMETOOLONG`, `EMFILE/ENFILE`.
- `close` 에러: `EBADF`(잘못된 FD), `EINTR`, `EIO`(지연 보고된 I/O 오류).
- **원자성**: `O_APPEND`는 오프셋 경쟁을 방지하지만 **쓰기 전체가 원자**라는 보장은 (파이프와 달리) 표준에 없음.
- **로그**: `perror`/`strerror_r` 사용. **실패 직후** `errno` 보존 후 기록.

---

## 11) 디렉터리 열기/닫기와 `*at` API

- 디렉터리 FD를 이용:
  - `openat(dfd, "child", ...)`
  - `fstatat(dfd, "child", ...)`
  - `unlinkat/renameat` 등으로 **한 디렉터리 트리 안에서** 경쟁 없이 조작.
- POSIX 디렉터리 I/O: `DIR* d = opendir(path); readdir(d); closedir(d);`  
  - `dirfd(d)`로 FD 획득 가능.

---

## 12) 안전한 코드 패턴

### 12.1 배타적 생성(심링크/경쟁 안전)
```c
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>

int open_new_secure(const char *dir, const char *name, mode_t mode) {
    int dfd = open(dir, O_RDONLY | O_DIRECTORY | O_CLOEXEC);
    if (dfd < 0) return -1;

    int fd = openat(dfd, name, O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC | O_NOFOLLOW, mode);
    int e = errno;
    close(dfd);
    if (fd < 0) { errno = e; return -1; }
    return fd;
}
```

### 12.2 안전한 `close` 래퍼
```c
#include <unistd.h>
#include <errno.h>

int close_safe(int fd){
    if (fd < 0) return 0;
    int r = close(fd);
    if (r == -1 && errno == EINTR) return 0; // 실무상 성공 취급
    return r;
}
```

### 12.3 원자적 갱신(임시→rename)
```c
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

int atomic_replace(const char *dir, const char *tmp, const char *dst, const char *data, size_t n){
    int dfd = open(dir, O_RDONLY|O_DIRECTORY|O_CLOEXEC);
    if (dfd < 0) return -1;

    int tfd = openat(dfd, tmp, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 0644);
    if (tfd < 0) { close(dfd); return -1; }

    ssize_t w = write(tfd, data, n);
    if (w < 0 || (size_t)w != n) { close(tfd); close(dfd); return -1; }

    if (fsync(tfd) < 0) { close(tfd); close(dfd); return -1; }
    if (close_safe(tfd) < 0) { close(dfd); return -1; }

    if (renameat(dfd, tmp, dfd, dst) < 0) { close(dfd); return -1; }
    // 디렉터리 엔트리까지 내구성 확보
    if (fsync(dfd) < 0) { close(dfd); return -1; }

    return close_safe(dfd);
}
```

### 12.4 표준출력 리디렉션
```c
int fd = open("out.log", O_WRONLY|O_CREAT|O_APPEND|O_CLOEXEC, 0644);
dup2(fd, STDOUT_FILENO);   // stdout을 파일로
close_safe(fd);
```

---

## 13) 대량 FD 닫기

- 셸/서버에서 **상속된 수백 FD** 닫기:
  - Linux: `close_range(3, ~0U, 0)` (3 이상 전부)
  - BSD: `closefrom(3)`
  - 이식성: `/proc/self/fd` 열거 후 반복 `close`

---

## 14) 체크리스트

- [ ] 생성 시 **`O_CLOEXEC`** 사용 (FD 유출 방지)  
- [ ] 새 파일은 **`O_CREAT|O_EXCL`** 또는 **`mkstemp`**, 필요 시 **`openat` + `O_NOFOLLOW`**  
- [ ] 쓰기 후 **`fsync`**(필요한 내구성 수준에 따라) 및 **`close` 반환값 확인**  
- [ ] **`EINTR`의 `close`는 성공 취급**, 재시도 금지  
- [ ] **부분 쓰기** 루프 처리, `O_APPEND` 활용  
- [ ] 권한은 **최소 권한**으로 생성 + `umask` 고려  
- [ ] `stdio`와 UNIX I/O **혼용 금지**(혼용 시 명확한 동기화)

---

## 15) 한 줄 결론
**열기**는 플래그·권한·경로 안전(특히 `openat`)이 핵심이고, **닫기**는 단순해 보이지만 **내구성 보장과 에러 전파**의 마지막 관문입니다.  
올바른 플래그 선택, 레이스 방지, `fsync`/`rename` 패턴, `CLOEXEC`와 `close` 에러 처리 규율만 지키면, 파일 I/O는 **안전하고 견고**해집니다.