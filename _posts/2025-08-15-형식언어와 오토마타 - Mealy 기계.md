---
layout: post
title: 형식언어와 오토마타 - Mealy 기계
date: 2025-08-15 17:20:23 +0900
category: 형식언어와 오토마타
---
# Mealy 기계(Finite-State **Mealy** Machine) 완전 가이드  
정의 · 실행 의미 · 예제 · Moore와의 변환 · 최소화/동치성 · 합성/폐포 · 구현 포인트

Mealy 기계는 **입력 기호를 읽는 그 순간**에 **출력 기호**를 내보내는 유한상태 장치다.  
정규언어를 인식하는 DFA가 “예/아니오”를 말한다면, Mealy 기계는 **문자열→문자열 변환**을 실시간으로 수행한다.

---

## 1) 형식적 정의(결정적 Mealy)

\[
M=(Q,\Sigma,\Gamma,\delta,\lambda,q_0)
\]
- \(Q\): 유한한 상태 집합, \(q_0\in Q\): 시작 상태  
- \(\Sigma\): 입력 알파벳, \(\Gamma\): 출력 알파벳  
- \(\delta:Q\times \Sigma\to Q\): **다음 상태** 함수  
- \(\lambda:Q\times \Sigma\to \Gamma\): **출력** 함수

특징
- 한 스텝에서 **입력 1기호를 소비**하고 **출력 1기호**를 방출(동기, ε 없음).  
- (확장형/일반화 Mealy에서는 출력이 문자열( \(\Gamma^*\) )일 수 있으나, 전통 하드웨어/이론 정의는 1:1 출력).

### 문자열로의 확장
\[
\begin{aligned}
\delta^\*(q,\varepsilon)&=q,\quad
\delta^\*(q,xa)=\delta\!\left(\delta^\*(q,x),a\right) \\
\lambda^\*(q,\varepsilon)&=\varepsilon,\quad
\lambda^\*(q,xa)=\lambda^\*(q,x)\ \cdot\ \lambda\!\left(\delta^\*(q,x),a\right)
\end{aligned}
\]
따라서 변환 함수 \(f_M:\Sigma^\*\to\Gamma^\*\) 를 \(f_M(x)=\lambda^\*(q_0,x)\) 로 정의(전이 전부 정의돼 있으면 총함수).

> 결과적으로 **입력 길이 = 출력 길이**(고전 Mealy). “부분”으로 만들면 미정의 입력에 대해 에러(혹은 덫 상태)로 보완한다.

---

## 2) 직관적 동작(런, run)
입력 \(x=x_1x_2\cdots x_n\) 에 대해
\[
q_0 \xrightarrow{x_1/\ \lambda(q_0,x_1)} q_1 \xrightarrow{x_2/\ \lambda(q_1,x_2)} \cdots \xrightarrow{x_n/\ \lambda(q_{n-1},x_n)} q_n
\]
총 출력은 \(\lambda(q_0,x_1)\cdots \lambda(q_{n-1},x_n)\).

---

## 3) 핵심 예제

### 3.1 패턴 검출기(“01”을 보면 1, 아니면 0 출력)
최근 1비트 기억으로 **직전 입력이 0**이었는지 추적한다.

```text
Σ = Γ = {0,1}
상태: qS(시작·기본), q0(직전이 0)
전이 (입력/출력):
qS -- 0/0 --> q0
qS -- 1/0 --> qS
q0 -- 0/0 --> q0
q0 -- 1/1 --> qS    # 직전 0 뒤에 1 오면 '01' 감지 → 1 출력
```

입력 `001011` → 출력 `0 0 1 0 1 0` (공백은 스텝 경계).

### 3.2 1자리 올림이 있는 **이진 가산기(LSB→MSB 스트리밍)**
입력을 **최하위비트부터** 공급한다고 가정(스트리밍 하드웨어에서 흔함).

```text
Σ = {00, 01, 10, 11}  # 같은 자리의 두 비트를 한꺼번에 읽음 (x+y)
Γ = {0,1}             # 합 비트 출력, 상태가 캐리
상태: c0(캐리0), c1(캐리1)
전이(입력 xy / 출력 s):
c0 -- 00/0 --> c0
c0 -- 01/1 --> c0
c0 -- 10/1 --> c0
c0 -- 11/0 --> c1
c1 -- 00/1 --> c0
c1 -- 01/0 --> c1
c1 -- 10/0 --> c1
c1 -- 11/1 --> c1
```
마지막에 남은 캐리는 **추가 출력이 필요**(Mealy 기본 1:1 출력과 어긋남). 이런 **꼬리 출력**은 “후속 출력 \(\tau\)”를 가진 **subsequential 변환기**로 일반화해 처리한다(§7).

### 3.3 1-상태 치환기(시저 +1)
```text
Σ = Γ = {a,...,z}
상태: q
모든 a..z에 대해   q -- a / succ(a) --> q
# succ(a): 알파벳에서 +1( z→a )
```
맥락이 필요 없으면 **한 상태**로 충분.

---

## 4) Mealy ↔ Moore: 차이와 상호 변환

### 개념 차이
- **Mealy**: 출력이 **(현재 상태, 현재 입력)** 의 함수 → **즉시 반응**(입력 변화에 같은 클럭에서 출력 변화).  
- **Moore**: 출력이 **상태만**의 함수 → **1스텝 지연**하지만 글리치 적고 안정.

### 변환
- **Moore → Mealy**: 각 전이 \(p \xrightarrow{a} q\) 에 \(q\)의 상태출력 \(\rho(q)\)를 라벨로 옮겨 **Mealy 전이 출력**으로.  
  상태 수는 그대로, **출력 지연 1스텝 감소**.
- **Mealy → Moore**: 전이마다 출력이 다르면 **(상태, 전이출력)** 를 묶어 **세분화**해야 해 최대 \(|Q|\cdot|\Sigma|\)까지 상태 증가.  
  (대신 출력은 상태에 고정되어 **클럭 경계에서만 변경**).

---

## 5) 최소화(결정적 Mealy)

두 상태 \(p,q\)가 **구별 불가**(equivalent)라는 뜻:
> 모든 입력 단어 \(x\in\Sigma^\*\)에 대해  
> \(\lambda^\*(p,x) = \lambda^\*(q,x)\) **그리고** \(\delta^\*(p,x), \delta^\*(q,x)\) 가 다시 동치.

### 파티션 정제(개략)
1. 길이 1 구분: 임의 \(a\in\Sigma\) 에 대해 \(\lambda(p,a)\ne \lambda(q,a)\) 이면 분할.  
2. 전이 도착 상태의 분할이 다르면 분할.  
3. 수렴할 때까지 반복 → 블록을 상태로 병합(초기상태 포함).

- 시간 복잡도: Hopcroft류 기법을 응용하면 \(O(|\Sigma|\cdot |Q|\log|Q|)\) 수준.

> **요령**: Mealy 최소화는 Moore 최소화와 유사하지만, **출력까지 함께** 비교해야 한다.

---

## 6) 동치성/함수성 검증

- **동치성**: 두 기계 \(M_1,M_2\)의 **차이 출력**을 탐지하는 제품 기계를 만든 뒤, **어떤 입력**에서라도 출력이 달라지는 경로가 있는지 탐색. 없으면 동치.  
- **부분 Mealy**(일부 입력 미정의)면, 정의역(definition domain)도 함께 비교(한쪽만 정의된 입력이 있으면 비동치).

---

## 7) 일반화: 출력 문자열·최종 출력(후속, **subsequential**)

실무/언어공학에서는 한 전이에서 **여러 글자**를 내거나, 입력 종료 시 **꼬리 출력**을 붙여야 할 때가 많다.
- 전이 출력 \(\lambda:Q\times\Sigma\to \Gamma^\*\)  
- 최종 출력 \(\tau:F\to \Gamma^\*\) 를 추가한 **(후속)순차 변환기**는 여전히 결정적이며,  
  구현하는 함수류를 **정규(=순차) 함수**(regular/sequential functions)라 부른다.
- 이 범위는 구성/최소화/합성 이론이 잘 정리되어 있고, 많은 텍스트 정규화·형태소 분석 파이프라인의 근간.

---

## 8) 합성·역·폐포

- **직렬 합성**(cascade): \(M_1:\Sigma\to\Delta\), \(M_2:\Delta\to\Gamma\) → \(M_2\circ M_1:\Sigma\to\Gamma\).  
  제품 상태 \((q_1,q_2)\) 에서 \(M_1\)의 출력이 \(M_2\)의 입력으로 즉시 공급. (일반화 Mealy/순차 변환기에서는 ε-정렬 필터가 유용)
- **역변환**: 출력↔입력 교환은 보통 **관계**가 되어 **함수성 붕괴**(여러 입력이 같은 출력을 낼 수 있음).  
- **닫힘**: 정규 관계/정규 함수의 범위에서 합성/합집합/연접/Kleene★ 등에 대한 좋은 폐포 성질이 성립(정밀한 범위는 모델에 따라 다름).

---

## 9) 설계 패턴(상태로 맥락을 인코딩)

- **최근 k-문맥** 필요 → \(k\)-길이 접두를 상태로 코딩(예: “ab” 치환은 ‘직전 a?’ 상태로 충분).  
- **지연 출력(delay)** → 일단 상태에 보류해 다음 입력을 보고 결정(§3.1의 ‘a-보류’ 패턴).  
- **에러/던지기** → “덫 상태(sink)”를 도입해 미정의 입력을 흡수.  
- **테이블 기반** → 상태×입력 카타로그로 구현(하드웨어: next-state 로직 + output 로직 분리).

---

## 10) 하드웨어 관점(Mealy vs Moore)

| 항목 | Mealy | Moore |
|---|---|---|
| 출력 의존 | (상태, **입력**) | (상태) |
| 반응 지연 | **0-사이클(즉시)** | 1-사이클 |
| 글리치 위험 | 상대적으로 큼(입력의 미세 변화 전파) | 작음(클럭 가장자리에만 변함) |
| 상태 수 | 보통 적음 | 출력-세분화로 늘 수 있음 |
| 용도 | 프로토콜 인코더, 스트리밍 변환 | 동기 인터페이스, 안정 출력 필요 |

---

## 11) 응용 스냅샷

- **문자열 처리**: 소문자→대문자, 토큰 경계 태깅(BIO), 간단 정규화  
- **신호/통신**: 라인 코딩(예: NRZI), 프로토콜 헤더 인코딩  
- **디지털 제어**: 이벤트→제어신호 매핑(즉시 반응형)  
- **언어공학(FST 계열)**: 일반화 Mealy/순차 변환기의 합성으로 형태소 분석, 발음 변환, 텍스트 정규화

---

## 12) 작은 체크리스트

1) **모델**: 순수 Mealy(1:1)인가, 전이/최종에 **문자열 출력**이 필요한가(순차 변환기)?  
2) **완전성**: 모든 \((q,a)\)에 전이가 있는가? 없으면 **덫 상태** 추가.  
3) **최소화**: 출력 차와 도착 분할로 **파티션 정제**.  
4) **테스트**: **구분 입력 시퀀스**로 상태를 분리(모델 기반 테스트, W-Method 등).  
5) **Moore 변환 필요**: 글리치/지연 요구에 맞춰 변환·세분화를 고려.

---

## 13) 요약

- Mealy는 **입력과 동시에 출력**을 내는 유한상태 변환기:  
  \(\lambda:Q\times\Sigma\to\Gamma\), \(\delta:Q\times\Sigma\to Q\).  
- **Moore와 상호 변환** 가능: Mealy는 즉시성, Moore는 안정성을 얻음.  
- **최소화/동치성**은 DFA와 유사한 파티션 정제로 가능하되 **출력 라벨**을 함께 본다.  
- 일반화(전이/최종에 문자열 출력)하면 **순차 변환기**가 되어 언어공학/스트리밍 변환 실무에 폭넓게 쓰인다.
