---
layout: post
title: 형식언어와 오토마타 - Mealy 기계
date: 2025-08-15 17:20:23 +0900
category: 형식언어와 오토마타
---
# Mealy 기계(Finite-State **Mealy** Machine)

Mealy 기계는 입력 기호를 **읽는 그 순간** 출력 기호를 방출하는 유한상태 장치다.
정규언어를 판정하는 DFA가 “예/아니오”만 말한다면, Mealy 기계는 **문자열→문자열 변환**을 **실시간(streaming)** 으로 수행한다.

---

## 빠른 개념 지도

- **Mealy vs Moore**:
  - Mealy: 출력 = **(상태, 입력)** 의 함수 → **즉시 반응**(0-cycle).
  - Moore: 출력 = **(상태)** 의 함수 → **1-cycle 지연**(안정·글리치 적음).
- **일반화(Mealy with strings)**: 전이·최종 출력이 **문자열**일 수 있는 **순차 변환기**(subsequential transducer).
- **표현력**: 1-way 결정 Mealy(순차 함수)는 **정규(=순차) 함수**.
- **검증**: 결정 Mealy끼리 **동치/포함**은 다항 시간에 가능(제품 기계 탐색).
- **최소화**: “출력 차이 + 다음 블록”으로 파티션 정제(Hopcroft 스타일 가속).

---

## 형식적 정의(결정적 Mealy)

$$
M=(Q,\Sigma,\Gamma,\delta,\lambda,q_0)
$$

- \(Q\): 유한 상태 집합, \(q_0\in Q\) 시작 상태
- \(\Sigma\): 입력 알파벳, \(\Gamma\): 출력 알파벳
- \(\delta:Q\times\Sigma\to Q\): 다음 상태 함수
- \(\lambda:Q\times\Sigma\to\Gamma\): 출력 함수(고전 Mealy는 1:1 출력)

### 문자열 확장(유도적 정의)

입력 \(x\in\Sigma^\*, a\in\Sigma\) 에 대해
$$
\delta^\!(q,\varepsilon)=q,\quad \delta^\!(q,xa)=\delta\!\big(\delta^\!(q,x),a\big)
$$
$$
\lambda^\!(q,\varepsilon)=\varepsilon,\quad
\lambda^\!(q,xa)=\lambda^\!(q,x)\cdot \lambda\!\big(\delta^\!(q,x),a\big)
$$

**변환 함수** \(f_M:\Sigma^\*\to\Gamma^\*\) 를 \(f_M(x)=\lambda^\!(q_0,x)\) 로 정의한다.
전이 미정의를 허용하지 않으면 **총함수**. 미정의가 있으면 **덫(sink)** 상태로 총기계화(totalization)한다.

> 결과: 고전 Mealy는 **입력 길이 = 출력 길이**.

---

## 실행 의미(런, run)와 직관

입력 \(x=x_1\cdots x_n\) 에 대해

\[
q_0 \xrightarrow{x_1/\ \lambda(q_0,x_1)} q_1 \xrightarrow{x_2/\ \lambda(q_1,x_2)} \cdots \xrightarrow{x_n/\ \lambda(q_{n-1},x_n)} q_n
\]

총 출력은 \(\lambda(q_0,x_1)\cdots \lambda(q_{n-1},x_n)\).
따라서 **동기 변환기**(ε-출력 없음), 반응은 **즉시**다.

---

## 예제 모음: 설계·상태 인코딩·출력 동기화

### 패턴 검출기: “01”을 보면 1, 아니면 0 출력

**아이디어**: “직전 입력이 0인지”만 기억하면 충분.

```text
Σ=Γ={0,1}
상태 Q={qS(시작), q0(직전 0)}
전이(입력/출력):
qS --0/0--> q0
qS --1/0--> qS
q0 --0/0--> q0
q0 --1/1--> qS   # 직전 0 뒤에 1 오면 1 출력
```

입력 `001011` → 출력 `0 0 1 0 1 0`.

**상태 인코딩 포인트**: 필요한 문맥만 **작게** 코딩(여기선 1비트 기억).

---

### 이진 가산기(LSB→MSB 스트림, 캐리 1비트)

**전제**: 같은 자리의 두 비트를 한 번에 읽는다(하드웨어 스트림).

```text
Σ={00,01,10,11}, Γ={0,1}
상태: c0(캐리0), c1(캐리1)  # 상태 자체가 캐리
전이:
c0 --00/0--> c0
c0 --01/1--> c0
c0 --10/1--> c0
c0 --11/0--> c1
c1 --00/1--> c0
c1 --01/0--> c1
c1 --10/0--> c1
c1 --11/1--> c1
```

마지막 자리 이후 **남은 캐리**는 Mealy 1:1 출력만으론 표현이 깔끔하지 않다.
→ §7의 **subsequential**(최종 출력 \(\tau\))로 일반화하여 **꼬리 출력**을 붙인다.

---

### 간단 치환기(시저 +1)

```text
Σ=Γ={a,…,z}
Q={q}
모든 a∈Σ:  q -- a / succ(a) --> q   # z→a 순환
```

맥락이 전혀 필요 없으면 **한 상태**로 충분.

---

### “a 다음 b면 X로 치환, 아니면 원문” — 지연 설계 패턴

**규칙**: `ab -> X`, 그 외엔 문자 그대로.

- **문제**: `a`를 읽는 순간 다음 문자가 `b`인지 **아직 모른다**.
- **해법**(Mealy의 전형적 **1-기호 지연**):
  - 상태 `holdA`에서 `a`를 **보류**. 다음 입력이 `b`면 `X` 출력, 아니면 `a` 먼저 내고 현재 입력을 처리.

```text
Σ=Γ={a,b, …}
Q={S(기본), holdA}
S --a/ε--> holdA
S --x/x--> S           # x∈Σ\{a}
holdA --b/X--> S
holdA --a/a--> holdA   # a가 연속되면 첫 a를 내고 a를 다시 보류
holdA --x/a x--> S     # x≠{a,b}: 보류 a 먼저, 그 다음 x
```

출력이 1:1이 아니므로 실제 구현은 **문자열 출력 Mealy(순차 변환기)** 로 만든다(§7).

---

## Mealy ↔ Moore 변환(장단·상태 수·지연)

### Moore → Mealy(출력 지연 제거)

Moore \(M=(Q,\Sigma,\Gamma,\delta,\rho,q_0)\) 를 Mealy로:

- 각 전이 \(p\xrightarrow{a}q\) 를 \(p \xrightarrow{a/\rho(q)} q\) 로 치환.
- 상태 수 **변화 없음**, Mealy는 **즉시 반응**.
- 초기 출력 \(\rho(q_0)\)에 대한 해석은 시스템 설계에 맞게 별도 처리.

### Mealy → Moore(출력 안정화·1-사이클 지연)

Mealy \(M=(Q,\Sigma,\Gamma,\delta,\lambda,q_0)\) 를 Moore로:

- 전이마다 출력이 다르면 **(상태, 전이출력)** 조합으로 **세분화** 필요.
- 최악에 \(|Q|\cdot|\Sigma|\) 까지 상태 수 증가 가능.
- 대신 Moore는 출력이 **상태에 고정**되어 **클럭 경계에서만** 변한다(글리치 억제).

**요약**: 즉시성(상태 수 작음) ↔ 안정성(지연 1스텝, 상태 수 증가)의 교환.

---

## — 정의·알고리즘·복잡도

### 동치 정의

상태 \(p,q\in Q\) 가 **동치**라 함은 모든 입력 단어 \(x\) 에 대해
$$
\lambda^\!(p,x) = \lambda^\!(q,x)\quad\text{그리고}\quad
\delta^\!(p,x) \sim \delta^\!(q,x)
$$
이 성립하는 가장 작은 동치관계 \(\sim\) 에 속함을 뜻한다.

### 기본 파티션 정제 알고리즘(개념)

1) **길이 1 구분**: 어떤 \(a\) 에서 \(\lambda(p,a)\ne \lambda(q,a)\) 면 분리.
2) **다음 블록 구분**: 어떤 \(a\) 에서 \([\delta(p,a)] \ne [\delta(q,a)]\) 면 분리.
3) 불변점(fixpoint)까지 반복 → 각 블록을 **하나의 최소 상태**로 수축.

- **시간 복잡도**: 순진 \(O(|\Sigma|\cdot |Q|^2)\).
- **Hopcroft 가속**: “작은쪽 퍼뜨리기”로 \(O(|\Sigma|\cdot |Q|\log |Q|)\) 근처.

### 실전 구현 팁

- **서명(signature)** = \(\big(\lambda(q,a),\ [\delta(q,a)]\big)_{a\in\Sigma}\) 를 해시해 버킷 분할.
- 분할이 일어나면 **작은 조각**만 worklist에 넣어서 전파 비용 최소화.
- 도달 불가 상태는 **사전 제거**(트리밍).

---

## — 제품 기계 탐색

두 기계 \(M_1,M_2\) 가 **동일 변환**을 수행하는지 확인:

1) 제품 상태 \((p,q)\) 에서 모든 \(a\in\Sigma\) 에 대해
   \((p',q')=(\delta_1(p,a),\delta_2(q,a))\),
   출력 비교 \(\lambda_1(p,a)\stackrel{?}{=}\lambda_2(q,a)\).
2) 불일치가 발견되면 **반례 입력**을 재구성하여 반환.
3) 도달 가능한 제품 그래프 전체에서 불일치가 없으면 동치.

- **복잡도**: 상태·전이 수에 **선형~다항**.
- **부분 Mealy**라면 “정의역 차이”(한쪽만 정의)도 반례.

**의사코드**

```text
Equal-Mealy(M1, M2):
  # 둘 다 총기계화 가정(미정의→sink)
  Qp := {(q1,q2) : q1∈Q1, q2∈Q2}
  seen := ∅
  queue := [(q01,q02, ε)]
  while queue:
    (p,q, w) := pop()
    if (p,q) in seen: continue
    seen.add((p,q))
    for a in Σ:
      if λ1(p,a) != λ2(q,a):
        return (False, w⋅a)   # a까지가 최초 불일치
      (p',q') := (δ1(p,a), δ2(q,a))
      push (p',q', w⋅a)
  return (True, None)
```

---

## 일반화: **문자열 출력**·**최종 출력**(후속, subsequential)

실무에선 전이마다 여러 글자, 입력 종료 후 **꼬리**를 내야 하는 상황이 잦다.

- 전이 출력 \(\lambda:Q\times\Sigma\to\Gamma^\*\)
- **최종 출력** \(\tau:Q\to \Gamma^\*\) 를 추가 → **순차 변환기**(subsequential transducer).
- 이들이 구현하는 함수류 = **정규(=순차) 함수**.
- **표현력**은 1-way 결정 Mealy보다 강하지만 여전히 **유한상태** 기반으로 합성/최소화/검증 이론이 잘 정립.

**예) §3.4 규칙의 순차 변환기 버전**

```text
# 전이 출력이 문자열, ε 허용

S     --a/ε--> holdA
S     --x/x--> S         (x∈Σ\{a})
holdA --b/X--> S
holdA --a/a--> holdA
holdA --x/a x--> S
τ(any) = ε
```

---

## 합성·폐포·역

- **직렬 합성** \(M_2\circ M_1\):
  제품 상태 \((q_1,q_2)\)에서 \(M_1\)의 전이 출력이 곧 \(M_2\)의 입력.
  문자열 출력이 섞이면 ε-정렬(ε-filter)을 두거나, 순차 변환기 합성 공식을 따른다.

- **닫힘**: 순차 함수는 **합성**에 닫혀 있음. 결합 시 **결정성 유지**를 위해 중간에 **결정화**(필요시)·최소화.

- **역변환**: 일반적으로 **역함수는 순차가 아님**(여러 입력이 같은 출력을 만들 수 있음 → 관계).
  역이 함수가 되려면 전사·단사 구조 제약 필요.

---

## 구현 포인트 — 테이블·성능·코드 아키텍처

### 테이블 기반 DMealy 구현 스켈레톤(Python)

```python
from typing import Dict, Tuple, Hashable

State = Hashable
Sym   = Hashable

class DMealy:
    def __init__(self, q0: State,
                 delta: Dict[Tuple[State, Sym], State],
                 out:   Dict[Tuple[State, Sym], str]):
        self.q = q0
        self.delta = delta
        self.out = out

    def reset(self, q0): self.q = q0

    def step(self, a: Sym) -> str:
        nxt = self.delta.get((self.q, a))
        if nxt is None:
            raise KeyError(f"undefined transition: {(self.q, a)}")
        o = self.out[(self.q, a)]
        self.q = nxt
        return o

    def transduce(self, xs) -> str:
        self.reset(self.q)
        buf = []
        for a in xs:
            buf.append(self.step(a))
        return "".join(buf)

# 예: 01 검출기

Q  = {"S","Z"}
ΣΓ = {"0","1"}

delta = {
    ("S","0"): "Z", ("S","1"): "S",
    ("Z","0"): "Z", ("Z","1"): "S",
}
out = {
    ("S","0"): "0", ("S","1"): "0",
    ("Z","0"): "0", ("Z","1"): "1",
}
m = DMealy("S", delta, out)
print(m.transduce("001011"))  # 001010
```

### 성능·메모리

- 큰 \(|\Sigma|\) → **희소 전이**(dict/해시)로 저장, 누락은 **sink**로 통일.
- 박싱 비용을 줄이려면 **배열 인덱스화**(상태·기호를 정수로 매핑).
- 핫 루프에선 분기 최소화(테이블-직접 인덱스)·브랜치 예측 유리.

### 테스트(모델 기반)

- **W-Method/HSI**로 상태를 분리하는 **구분 시퀀스** 자동 생성.
- 회귀 검증: **골든 Mealy**와 제품 기계를 만들고 **최초 불일치** 입력을 리포트.

---

## 최소화 — 실전 절차(파이썬 예시; 교육용)

```python
def minimize_mealy(Q, Σ, δ, λ, q0):
    """
    Q: set of states
    Σ: alphabet iterable
    δ: (q,a)->q'
    λ: (q,a)->γ   (γ in Γ)
    q0: start
    return (Qmin, δmin, λmin, q0min, classes)
    """
    # 0) 도달 상태만
    from collections import deque, defaultdict
    reach = set()
    dq = deque([q0])
    while dq:
        q = dq.popleft()
        if q in reach: continue
        reach.add(q)
        for a in Σ:
            qn = δ.get((q,a))
            if qn is not None: dq.append(qn)
    Q = list(reach)

    # 1) 초기 분할: 길이 1 출력 벡터가 같은 상태끼리
    sig = {}
    for q in Q:
        sig[q] = tuple(λ[(q,a)] for a in Σ)
    classes = {}
    for q in Q:
        classes.setdefault(sig[q], []).append(q)
    blocks = list(classes.values())

    changed = True
    while changed:
        changed = False
        new_blocks = []
        for B in blocks:
            # 다음 블록 튜플로 세분화
            buckets = defaultdict(list)
            for q in B:
                next_ids = []
                for a in Σ:
                    qn = δ[(q,a)]
                    # qn이 속한 블록 인덱스를 찾음
                    bid = next(i for i,Blk in enumerate(blocks) if qn in Blk)
                    next_ids.append(bid)
                buckets[tuple(next_ids)].append(q)
            if len(buckets) == 1:
                new_blocks.append(B)
            else:
                changed = True
                new_blocks.extend(buckets.values())
        blocks = new_blocks

    # 몫 기계 구성
    rep = {q: i for i,Blk in enumerate(blocks) for q in Blk}
    Qmin = list(range(len(blocks)))
    q0min = rep[q0]
    δmin, λmin = {}, {}
    for i,Blk in enumerate(blocks):
        qrep = Blk[0]
        for a in Σ:
            qn = δ[(qrep,a)]
            δmin[(i,a)] = rep[qn]
            λmin[(i,a)] = λ[(qrep,a)]
    return Qmin, δmin, λmin, q0min, blocks
```

- 교육용 단순화(블록 탐색 비용 큼). 실제는 **Hopcroft 가속**과 **블록 인덱스 캐시**로 \(O(|\Sigma|\cdot |Q|\log |Q|)\) 근접.

---

## 흔한 설계 패턴·반패턴

- **패턴**
  - **k-문맥 상태화**: 최근 k 문자만 필요 → 상태 수 \(|\Sigma|^k\) 내에서 해결.
  - **1-기호 지연**: 다음 문자를 보고 현재 출력 결정(§3.4).
  - **에러 흡수**: 미정의 입력을 sink로.

- **반패턴(1-way Mealy로 불가/부적합)**
  - **역순** \(w\mapsto w^R\), **전역 복사** \(w\mapsto ww\), **끝-의존 접두 삽입**(마지막 심볼에 따라 앞에 추가).
  - 이런 경우 §14의 대체 모델(2-way/SST/PDT)을 고려.

---

## 하드웨어 관점: 타이밍·글리치·상태 수

| 항목 | Mealy | Moore |
|---|---|---|
| 출력 의존 | (상태, **입력**) | (상태) |
| 반응 지연 | **0-cycle** | 1-cycle |
| 글리치 위험 | 상대적으로 큼 | 작음 |
| 상태 수 | 보통 **작음** | 커질 수 있음 |
| 용례 | 프로토콜 인코더, 스트리밍 | 동기 인터페이스, 안정 출력 |

**실전 팁**: 외부로 나가는 핀/버스에는 Moore를, 내부 파이프에는 Mealy를 혼용하는 설계가 흔하다.

---

## 복잡도·이론 메모

- **출력 길이 상계(고전 Mealy)**:
  $$|\mathrm{out}(x)| = |x|$$
  (문자열 출력 허용 순차 변환기도 전이·최종 출력이 **상수 길이 합**이므로 선형 상계)

- **최소화**: Hopcroft 류로 \(O(|\Sigma|\cdot |Q|\log |Q|)\) 근처.
- **동치성**: 제품 탐색 선형~다항.
- **표현력**: 1-way 결정 Mealy(순차 함수)는 **정규 함수**. 역함수/역순은 일반적으로 순차가 아니다.

---

## 한계를 만났을 때: 대체 모델 선정

| 요구 기능 | 권장 모델 | 요지 |
|---|---|---|
| 역순, 끝-의존 재배열 | **2-way FST** / **SST** | 왕복 스캔 또는 레지스터 복사 제한으로 해결 |
| 전역 복사(상수회) | **SST** | 상수회 복제 가능(복사 제한) |
| 균형/중첩 | **PDT** | 스택 필요(문맥자유급) |
| 복잡 전역 제약+검증 | FST + **SMT/정적분석** | 전처리/후처리 결합 |

---

## 대형 예제: 10진 숫자 → 한글 읽기(순차 변환기)

### 요구사항 요약

- “1203” → “일천이백삼” (0은 구어 규칙상 생략)
- 자리수 접미사: 십/백/천, 네 자리마다 만/억/조… 그룹
- **좌→우 스트리밍**으로 처리, 전이 출력은 **문자열**.

### 상태 설계 아이디어

- 상태 = “현재 그룹 내 자리(index 0..3)” × “그룹 순번(만/억/조…)의 모드(작은 유한 집합)”
- 숫자 `0` 처리는 **자리 접미사 생략** 규칙을 전이 출력에서 처리.

### 스케치(개념 코드)

```python
digits = "영일이삼사오육칠팔구"
unit1  = ["","십","백","천"]           # 블록 내
unit4  = ["","만","억","조"]           # 블록 간 (필요시 확장)

def say_korean_number_dec(s: str) -> str:
    # s는 0~9로만 구성, 선행 0 가능
    n = len(s)
    out = []
    group_idx = 0  # 0: 일~천, 1: 만~천만, ...
    i = n
    while i > 0:
        # 4자리 블록 처리
        chunk = s[max(0, i-4):i]
        i -= 4
        block = []
        for j, ch in enumerate(reversed(chunk)):  # 1의 자리부터
            d = ord(ch)-48
            if d == 0:
                continue
            block.append(digits[d] + unit1[j])
        if block:
            block = "".join(reversed(block))
            if group_idx > 0:
                block += unit4[group_idx]
            out.append(block)
        group_idx += 1
    if not out:
        return "영"
    return "".join(reversed(out))
```

- 핵심은 “자릿수→문자열”의 **고정 패턴** 조립이며, 이는 **순차 변환기**의 합성과 동일 개념.

---

## 디버깅·검증·테스트 전략

- **구분 입력**으로 상태를 분리: W-Method/HSI로 **식별 수열** 생성.
- **제품 기계로 회귀 테스트**: 변경 전/후 Mealy의 제품에서 첫 불일치 추출.
- **커버리지**: 상태·전이 커버리지(각 전이 최소 1회), 출력 값 경계(특히 문자열 출력의 공백/구두점).

---

## 실전 체크리스트

1) **모델 선택**: 고전 Mealy(1:1)인가, **문자열 출력/최종 출력**이 필요한가(순차 변환기)?
2) **완전성**: 모든 \((q,a)\) 전이가 정의되어 있는가? 미정의는 sink로 총기계화.
3) **지연 전략**: 필요한 **lookahead**를 상태로 흡수(1-기호 지연 패턴).
4) **최소화**: 출력 차이와 다음 블록으로 파티션 정제, Hopcroft 가속.
5) **동치성**: 제품 탐색으로 자동화, 반례 입력 수집.
6) **성능**: 희소 전이/정수 인덱싱/브랜치 예측/캐시 친화 레이아웃.
7) **한계 인지**: 역순·전역 복사·끝-의존은 1-way Mealy로 불가 → 2-way/SST/PDT.

---

## 수식·성질 요약

- **Mealy 정의**:
  $$M=(Q,\Sigma,\Gamma,\delta,\lambda,q_0),\
    \delta:Q\times\Sigma\to Q,\
    \lambda:Q\times\Sigma\to\Gamma$$

- **문자열 확장**:
  $$\lambda^\!(q,xa)=\lambda^\!(q,x)\cdot \lambda\!\big(\delta^\!(q,x),a\big)$$

- **동치(최소화)**:
  $$p\sim q\iff \forall x:\ \lambda^\!(p,x)=\lambda^\!(q,x)\ \land\ \delta^\!(p,x)\sim\delta^\!(q,x)$$

- **출력 길이(고전)**:
  $$|\mathrm{out}(x)|=|x|$$

- **복잡도(개략)**: 최소화 \(O(|\Sigma|\cdot|Q|\log|Q|)\), 동치성 검사는 선형~다항.

---

## 요약

- Mealy는 **입력과 동시에 출력**하는 유한상태 변환기다.
- **Moore↔Mealy 변환**으로 즉시성↔안정성을 교환할 수 있으며, Mealy→Moore 시 상태 수가 증가할 수 있다.
- **최소화/동치성**은 DFA와 유사한 파티션 정제로 가능하지만, **출력 라벨**을 함께 본다.
- 문자열 출력·최종 출력이 필요한 실전은 **순차 변환기**로 일반화하여 합성/최소화/검증 생태계를 활용한다.
- 역순/전역 복사/끝-의존 재배열 등 **Mealy의 한계**는 2-way/SST/PDT로 우회하라.

---

## 실무 한 장 요약:

[모델] Mealy(1:1) ↔ 순차 변환기(문자열·최종 출력)
[설계] k-문맥 상태화 + 1-기호 지연 패턴 + sink 총기계화
[최소화] 출력·다음 블록 기반 파티션 정제(Hopcroft 가속)
[검증] 제품 탐색으로 동치/반례, W-Method로 상태 식별
[한계] 역순/전역 복사/끝-의존은 불가 → 2-way/SST/PDT
[성능] 희소 전이·정수 인덱스·캐시/분기 최적화
