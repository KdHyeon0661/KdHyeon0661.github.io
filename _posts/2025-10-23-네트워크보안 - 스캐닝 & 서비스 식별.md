---
layout: post
title: 네트워크보안 - 스캐닝 & 서비스 식별
date: 2025-10-23 17:25:23 +0900
category: 네트워크보안
---
# 스캐닝 & 서비스 식별(정찰)

## 포트 스캔 기법: TCP SYN/Connect, UDP, FIN/Xmas/NULL

### 스캔 결과 상태 모델

- **open**: 대상 포트에서 **연결 수립/응답**(예: SYN/ACK, UDP 응답, 앱 배너).
- **closed**: 대상 포트가 열려 있지 않음(예: RST 응답, ICMP Port Unreachable).
- **filtered**: 방화벽/ACL 등으로 **응답 차단**(무응답/타임아웃/ICMP admin prohibited).
- **open|filtered**: 응답이 모호해 어느 쪽인지 단정 불가(특히 UDP/스텔스 스캔에서 잦음).
- **closed|filtered**: 특정 기법에서 드물게 나오는 중간 상태(주로 변칙 환경).

> 스캔 기법마다 **상태 판정 기준**이 다르다. 동일 호스트라도 기법·타이밍·네트워크 상황에 따라 판정이 바뀔 수 있다.

---

### TCP SYN 스캔(“하프 오픈”, 가장 많이 쓰이는 기본)

- 원리: 클라이언트가 **SYN** 전송 → 서버가 **SYN/ACK**면 `open`, **RST**면 `closed`.
  성공 시 ACK로 완전히 연결하지 않고 **RST**로 끊는다(로그 최소화 가능).
- 장점: 빠르고 광범위, 비교적 **낮은 탐지(로그) 흔적**.
- 한계: 일부 IPS/방화벽이 SYN flood/스캔을 민감히 본다.

```bash
# 예: 10.10.0.10의 톱 1000 포트 SYN 스캔 + 서비스 버전까지

sudo nmap -sS -sV 10.10.0.10
# 포트 범위 지정(1~65535), 속도(빠름), 정확도(낮아질 수 있음)

sudo nmap -sS -p- --min-rate 3000 10.10.0.10
```

---

### TCP Connect 스캔(완전 연결, -sT)

- 원리: `connect()` 시스템콜로 실제 **3-way**을 끝까지 수행한다.
- 장점: RAW 소켓 권한 없이도 가능(비root), 방화벽/중간장비가 “정상 연결”로 인지할 가능성 높음.
- 한계: 로그에 **연결 흔적**이 남기 쉬움(애플리케이션까지 닿을 수 있음), 느리고 차단될 수도.

```bash
# 루트 권한 없이 가능한 스캔(환경에 따라 다름)

nmap -sT -p 22,80,443 10.10.0.10
```

---

### UDP 스캔(-sU)

- 원리: UDP 패킷 송신 → **ICMP Port Unreachable**(Type3 Code3)이 오면 `closed`,
  정상 UDP 응답/배너가 오면 `open`, 무응답이면 `open|filtered`.
- 장점: DNS/NTP/SNMP/… 등 **UDP 기반 서비스** 발굴 가능.
- 한계: **매우 느림**, 무응답이 많아 **false open**이 쉽게 발생, 종종 레이트 제한 필요.

```bash
# UDP 53(DNS), 123(NTP), 161(SNMP) 등만 빠르게

sudo nmap -sU -p 53,123,161 --min-rate 500 10.10.0.10
# UDP 전체 탐색(권장X: 느리고 노이즈 큼) → 대상 좁혀서 선택적으로

sudo nmap -sU -p- --max-rate 400 10.10.0.10
```

---

### FIN/Xmas/NULL 스캔(스텔스 시도)

- 원리(전통적 RFC 해석 가정):
  - **FIN**(세션 종료 표식)만 보내거나,
  - **Xmas**(FIN+PSH+URG),
  - **NULL**(플래그 없음) 전송 →
  **open** 포트는 무응답(스택 구현 차로), **closed**는 RST 응답.
- 장점: 일부 방화벽/로그 우회 시도(“정상 SYN이 아님”).
- 한계: OS/스택 구현·중간장비에 따라 **동작 불확실**. IPv6/현대 스택에 영향도 낮음.

```bash
sudo nmap -sF -p 1-1024 10.10.0.10    # FIN
sudo nmap -sX -p 1-1024 10.10.0.10    # Xmas
sudo nmap -sN -p 1-1024 10.10.0.10    # NULL
```

---

### 혼합 전략

- SYN(+ 서비스 버전)으로 **저비용·광범위** 1차,
- UDP는 **프로토콜 중요 포트**만,
- 필요 시 FIN/Xmas/NULL로 **방화벽 행동 차이** 관찰,
- 의심 호스트는 Connect/스니펫 배너그랩 등으로 **정밀 확인**.

---

## Nmap 심화: NSE, 방화벽 우회 팁, 호스트 디스커버리

### Nmap 서비스 버전·OS 식별

- `-sV`: 서비스 버전 탐지(배너/핸드셰이크 프로브·문자열 매칭).
- `-O`: OS 핑거프린팅(패킷 응답 특성 비교, 관리자 권한 권장).
- `--version-intensity <0-9>`: 적극성 조절(높을수록 정확하지만 느리고 소음 증가).

```bash
sudo nmap -sS -sV -O --version-intensity 7 10.10.0.10
```

> **주의**: -O는 **불확실**할 수 있다. 방화벽·가상화·중간장비가 많을수록 정확도 하락.

---

### NSE(Nmap Scripting Engine)로 심층 식별/취약점 점검

- NSE는 **Lua 스크립트**로 배너 수집/프로토콜 핸드셰이크/취약성 체크/브루트 등 다양한 기능 제공.
- 스크립트 카테고리: `auth`, `broadcast`, `brute`, `default`, `discovery`, `exploit`, `safe`, `vuln` 등.
- **실무 팁**: 처음에는 `default,safe,version` 정도로 시작 → **승인된 환경**에서 `vuln` 등 확장.

```bash
# 기본/안전/버전 스크립트

sudo nmap -sS -sV --script "default,safe,version" 10.10.0.10

# 특정 스크립트 선택(예: SSL/TLS 관련)

sudo nmap -sS -p 443 --script "ssl-enum-ciphers,ssl-cert" 10.10.0.10

# 취약점 카테고리(테스트망/허가범위 한정)

sudo nmap -sS -sV --script "vuln" 10.10.0.10
```

#### (예) 간단한 NSE 스크립트 골격(학습용)

```lua
-- 파일명: example-banner.nse (학습용; Nmap scripts 디렉토리에 저장)
description = [[
  Connect-like banner grab for a TCP port.
  Usage: --script example-banner --script-args="banner.port=80"
]]
author = "your_name"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"discovery", "safe"}

require "shortport"
require "stdnse"

portrule = function(host, port)
  local target_port = stdnse.get_script_args("banner.port") or 80
  return port.number == tonumber(target_port) and shortport.port_or_service(target_port)
end

action = function(host, port)
  local socket = nmap.new_socket()
  socket:set_timeout(3000)
  local status, err = socket:connect(host.ip, port.number)
  if not status then return "connect failed: " .. err end
  socket:send("HEAD / HTTP/1.0\r\n\r\n")
  local data = socket:receive_lines(1)
  socket:close()
  return data or "no banner"
end
```
> 실제 운영 스캔에선 **공식 NSE** 우선 사용. 자체 스크립트는 **ROE 범위 내**에서만.

---

### 방화벽 우회(탐지 회피) **팁(합법 환경 한정!)**

> 목적은 “**네트워크 특성 파악**”이다. **탐지 회피 자체**가 목적이 아니다.

- **Timing Templates**: `-T0`(paranoid) ~ `-T5`(insane).
  느릴수록 **탐지 회피** 가능성↑, 시간↑.
- **Source Port 지정**: `--source-port 53` 등. 오래된 ACL 회피 가능(요즘은 효과 제한적).
- **Packet Fragmentation**: `-f`, `--mtu 8` 등. 중간 장비가 재조립 못하면 무력화/오탐.
- **Decoy**: `-D RND:10` → 소스 IP에 **미끼**를 섞어 로그 혼선. **법적·윤리적 고려 필수**.
- **Scan Delay/Rate 제한**: `--scan-delay`, `--min-rate/--max-rate`로 레이트 낮춰 노이즈 억제.

```bash
sudo nmap -sS -T2 --scan-delay 100ms --max-rate 200 --source-port 53 10.10.0.10
sudo nmap -sS -f --mtu 24 -p 80,443 10.10.0.10
sudo nmap -sS -D RND:5 10.10.0.10   # (실습망 한정)
```

> **경고**: 이 옵션들은 실제 운영망/타인 자산에 **절대 사용 금지**.
> 승인된 테스트에서 **네트워크 반응**을 연구하는 용도로만.

---

### 호스트 디스커버리(Host Discovery)

- **ICMP Echo/Time/Mask**, **ARP Ping**(동일 L2), **TCP ACK/SYN Ping**(포트 지정), **UDP Ping**.
- **L2에서 ARP는 강력**: 같은 브로드캐스트 도메인이면 **활성 MAC** 파악에 탁월(방화벽 영향 적음).
- **IPv6**: ICMPv6 Neighbor Solicitation/Advertisement 활용, **RA/ND 정책** 고려.

```bash
# 로컬 L2망: ARP Ping으로 살아있는 호스트 식별

sudo nmap -sn -PR 10.10.0.0/24
# 방화벽이 ICMP 차단 시: TCP ACK Ping(예: 80/443)

sudo nmap -sn -PA80,443 10.10.0.0/24
# SYN Ping(특정 포트만)

sudo nmap -sn -PS22,80,443 10.10.0.0/24
```

---

## Masscan/ZMap: 대규모 스캔 윤리와 속도·정확도 트레이드오프

### 개요

- **masscan**: 초고속 TCP SYN 스캔(커널 스택 우회, 자체 TCP 스택 기반), **인터넷 스케일** 설계.
- **ZMap**: 초고속 **ICMP/TCP/UDP** 단일 포트 **스캐닝**(정교한 샘플링과 rate control), 학술적 배경.

> 둘 다 **매우 강력**하다. 무분별한 사용은 법적·윤리적 문제와 **대역폭/리소스** 피해를 초래한다.
> **반드시 허가된 범위**에서만, **보수적 rate**로 실행하라.

---

### masscan 기본

- 특징: **속도**(초당 수백만 SYN), **단순 결과**(open 포트 후보).
- 한계: 결과는 **초기 신호**일 뿐. 서비스 버전/정확 식별을 위해 **Nmap로 재확인** 필요.

```bash
# 10.10.0.0/16 전체에서 80/443 열려있는 호스트 후보 찾기(속도 제한 필수!)

sudo masscan 10.10.0.0/16 -p80,443 --rate=5000 -e eth0 -oX masscan.xml

# 발견된 호스트/포트를 Nmap으로 정밀 재스캔
# (아래 3.4에서 자동 파이프라인 스크립트 예시 제공)

```

**주요 옵션**
- `--rate`: 초당 패킷 전송량(필수로 낮게 설정).
- `-p`: 포트 지정. 대역 넓으면 꼭 좁혀라.
- `-e`: 인터페이스 지정(필요 시).
- `--router-mac`/`--source-port`: 특정 환경 대응(고급).

---

### ZMap 기본

- 특징: **단일 포트**를 전체 주소공간에 송신 → 응답 분석으로 **열림/특성** 추정.
- 한계: 실무 랩 범위에선 오버스펙. 연구/대규모 계측에 적합.

```bash
# 예: 10.10.0.0/16에 대해 TCP SYN 443만 스캔, 낮은 레이트로

sudo zmap -B 10M -p 443 10.10.0.0/16 -o zmap_443.txt
```

---

### 속도 ↔ 정확도 트레이드오프

- 속도를 올리면 **드롭/충돌/중복** 증가 → **오탐/미탐**이 커진다.
- **최선 실무**: masscan/ZMap으로 **후보 식별** → Nmap `-sS -sV`로 **정밀 재검증**.

---

## 실습: 승인된 테스트망 인벤토리 작성

### 시나리오

- 대상: `10.10.0.0/24` 내부 테스트망(ROE 문서화 완료).
- 목표: **사용중 호스트**, **열린 포트**, **서비스 버전**, **중요 태그**(역할/OS 추정/리스크)로 **인벤토리 표** 작성.

---

### 1단계 — 호스트 디스커버리(빠르고 안전하게)

```bash
# L2 ARP Ping 우선(브로드캐스트 도메인 내)

sudo nmap -sn -PR 10.10.0.0/24 -oA disco_arp

# ICMP 제한 환경 대비용(ACK/SYN Ping)

sudo nmap -sn -PA80,443 10.10.0.0/24 -oA disco_tcp
```
- 결과(`disco_arp.gnmap`/`.xml`)에서 **활성 호스트 목록** 추출.

---

### 2단계 — 포트 스캔(정확도 위주)

```bash
# 활성 호스트 목록을 파일로 만들었다고 가정: hosts.txt

sudo nmap -sS -p 1-1024,8080,8443,3389,5900 -iL hosts.txt -oA ports_top
# 중요 UDP 포트만 별도

sudo nmap -sU -p 53,123,161,500,514,33434 -iL hosts.txt -oA ports_udp
```

> **팁**: 대역폭/노이즈를 고려해 **포트 집합**을 합리적으로 좁혀라(조직 표준 포트셋 정의).

---

### 3단계 — 서비스 버전·OS 식별

```bash
sudo nmap -sS -sV -O --version-intensity 7 -iL hosts.txt -oA svcos_os
```
- `svcos_os.xml`에서 **서비스명/버전**, **OS 추정**, **각 포트 스테이트** 추출.

---

### 4단계 — NSE(안전 카테고리)로 풍부화(Enrichment)

```bash
sudo nmap -sS -sV --script "default,safe,version" -iL hosts.txt -oA enrich_safe
# TLS/암호화 스위트가 중요하면 선택적으로

sudo nmap -sS -p 443 --script "ssl-enum-ciphers,ssl-cert" -iL hosts.txt -oA enrich_tls
```

---

### 5단계 — (옵션) masscan → nmap 파이프라인

```bash
# 후보 급히 찾기(레이트 낮춰 안전하게!)

sudo masscan 10.10.0.0/24 -p80,443,22,3389 --rate=500 -oX masscan.xml

# XML에서 open 호스트:포트 추출 → Nmap 정밀 스캔
# (아래 Python 스크립트)

```

#### 파이프라인 스크립트(학습용 Python)

```python
# file: masscan_to_nmap.py
# purpose: masscan XML → host:port 리스트 → nmap 정밀 스캔 실행 명령 생성

import xml.etree.ElementTree as ET
import sys

if len(sys.argv) < 2:
    print("usage: python masscan_to_nmap.py masscan.xml")
    sys.exit(1)

tree = ET.parse(sys.argv[1])
root = tree.getroot()

targets = {}  # host -> set(ports)
for host in root.findall('host'):
    addr = host.find('address').get('addr')
    ports = host.find('ports')
    if ports is None:
        continue
    for p in ports.findall('port'):
        portid = p.get('portid')
        state = p.find('state').get('state')
        if state == 'open':
            targets.setdefault(addr, set()).add(portid)

# 출력: host 별 포트 리스트

for h, ps in targets.items():
    plist = ",".join(sorted(ps, key=lambda x: int(x)))
    cmd = f"sudo nmap -sS -sV -p {plist} {h} -oA confirm_{h.replace('.', '_')}"
    print(cmd)
```
> 출력된 명령을 검토 후 실행(레이트/타이밍 옵션 추가 권장).

---

### 6단계 — 결과 합치기 → 인벤토리 테이블 만들기

- 포맷: `hostname/ip | open tcp ports | open udp ports | service:version | os guess | tag(role) | risk note`
- `xsltproc`·`xmlstarlet`·`tshark -T fields`·간단 Python으로 **CSV/Markdown** 생성.

#### 예제: Nmap XML → CSV(간단 Python)

```python
# file: nmapxml_to_csv.py
# usage: python nmapxml_to_csv.py svcos_os.xml > inventory.csv

import xml.etree.ElementTree as ET
import csv, sys

tree = ET.parse(sys.argv[1])
root = tree.getroot()
ns = {'n': 'http://www.nmap.org/schema/nmaprun/1'}

rows = []
for host in root.findall('n:host', ns):
    addr = host.find('n:address', ns).get('addr')
    hostnames = [h.get('name') for h in host.findall('.//n:hostname', ns)]
    hostname = hostnames[0] if hostnames else ''
    osmatch = host.find('.//n:osmatch', ns)
    osname = osmatch.get('name') if osmatch is not None else ''
    for port in host.findall('.//n:port', ns):
        proto = port.get('protocol')
        portid = port.get('portid')
        state = port.find('n:state', ns).get('state')
        service = port.find('n:service', ns)
        name = service.get('name') if service is not None else ''
        version = service.get('version') if service is not None and service.get('version') else ''
        product = service.get('product') if service is not None and service.get('product') else ''
        banner = (product + " " + version).strip()
        rows.append([addr, hostname, proto, portid, state, name, banner, osname])

writer = csv.writer(sys.stdout)
writer.writerow(["ip","hostname","proto","port","state","service","banner","os_guess"])
writer.writerows(rows)
```

---

### 7단계 — 리스크 노트 달기(간단 룰)

- **원격관리** 포트(22/3389/5900)가 외부에 노출? → **High**.
- **평문**(ftp/23/telnet/110/imap/…)? → **TLS 전환 권고**.
- **낡은 서비스 버전**(배너 기반 추정) → **패치/업그레이드**.
- **Unknown service**(커스텀/사내 앱) → 문서화·접근통제 필요.

#### 간단 태깅 스니펫(파이썬 후처리)

```python
# file: tag_risk.py
# usage: python tag_risk.py inventory.csv > inventory_tagged.csv

import csv, sys

def risk(service, port):
    port = int(port)
    if port in (22,3389,5900):
        return "High: remote admin exposure"
    if service in ("ftp","telnet","imap","pop3") or port in (23,21,110,143):
        return "High: plaintext protocol"
    if service in ("ssh","https"):
        return "Medium: check cipher/hardening"
    return "Info"

r = csv.reader(open(sys.argv[1], newline=''))
w = csv.writer(sys.stdout, lineterminator='\n')
header = next(r)
w.writerow(header + ["risk_note"])
for row in r:
    svc = row[5]; port = row[3]
    w.writerow(row + [risk(svc, port)])
```

---

### 8단계 — 최종 보고서(템플릿)

```markdown
# 네트워크 인벤토리(테스트망 10.10.0.0/24) — YYYY-MM-DD

## 요약

- 활성 호스트: 42/256
- 공개 서비스 상위: 80(22호스트), 443(18), 22(15), 3389(2)
- 평문 서비스 감지: 5호스트 (ftp/telnet/imap 등) — TLS 전환 권고
- 원격관리 포트 외부 노출 후보: 3호스트 — ACL/SG로 접근제어 권고

## 상세 인벤토리(발췌)

| IP | Hostname | Proto | Port | State | Service | Banner | OS Guess | Risk |
|---|---|---:|---:|---|---|---|---|---|
| 10.10.0.10 | web1.lab | tcp | 80 | open | http | nginx 1.24 | Linux 5.x | Info |
| 10.10.0.11 | db1.lab  | tcp | 22 | open | ssh  | OpenSSH_7.6 | Ubuntu 18.04 | High: remote admin exposure |
| 10.10.0.12 | mail1.lab| tcp | 110| open | pop3 | Dovecot 2.2 | Linux 4.x | High: plaintext protocol |

## 권고

1) 22/3389 접근은 Jump host/Bastion 또는 VPN으로 제한.
2) 평문 서비스는 즉시 TLS 전환(STARTTLS/SMTPS/IMAPS 등) 및 강제 리다이렉트.
3) 모든 서비스는 최신 보안 패치 적용, 배너 노출 최소화(ServerTokens/SSH 버전 숨김).
```

---

## 부록 A. 배너 그랩/핸드셰이크 수동 확인(점검 보완)

```bash
# HTTP 배너

printf 'HEAD / HTTP/1.0\r\n\r\n' | nc -nv 10.10.0.10 80
# HTTPS/TLS 핸드셰이크 및 인증서

openssl s_client -connect 10.10.0.10:443 -servername web.lab </dev/null | openssl x509 -noout -dates -subject -issuer
# SSH 버전

nc -nv 10.10.0.11 22
# SMTP 배너

nc -nv 10.10.0.20 25
```
> 서버 측에서 **배너 노출 최소화** 설정(ServerTokens Prod, SSH `DebianBanner no` 등)로 정보 노출을 줄인다.

---

## 부록 B. 스캔 안전수칙(필독)

1) **ROE 문서화**: 대상·기간·강도(rate)·데이터 처리·연락 포인트.
2) **레이트 제한**: `--max-rate`, `-T` 수준 낮게, UDP는 특히 보수적으로.
3) **세션 부하**: 로그인 시도/브루트/NSE ‘vuln’ 계열은 **테스트망**에서만.
4) **기록/재현성**: `-oA`(3종 저장)로 증적 남기고, 해시/암호화/보존기간 준수.
5) **운영 영향 최소화**: 스캔 윈도(야간·저부하), 점진 확장(대상 소수 → 확대).
6) **법·윤리 준수**: 타인 자산/공용망/인터넷 스캔은 금지(별도 합법체계 외엔 X).

---

## 요약

- **TCP SYN/Connect/UDP/FIN/Xmas/NULL**를 이해하고 **상태 모델**로 결과를 읽어라.
- **Nmap**은 기본 스캔부터 **NSE로 풍부화**까지, 방화벽 환경에서는 **타이밍/소스포트/프래그/딜레이**를 조심스럽게 조정.
- **masscan/ZMap**은 후보 발굴용 레이더, **Nmap 정밀 재검증**이 필수.
- **인벤토리 파이프라인**을 만들어 결과를 표준 포맷으로 통합·태깅하면 **운영 가치**가 극대화된다.
