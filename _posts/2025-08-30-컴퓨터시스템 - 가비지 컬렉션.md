---
layout: post
title: 컴퓨터시스템 - 가비지 컬렉션
date: 2025-08-30 18:20:23 +0900
category: 컴퓨터시스템
---
# 가비지 컬렉션(Garbage Collection) — 원리·알고리즘·장치·튜닝·실전

> **요약**: GC는 *살아있는 객체만 남기고* 나머지 메모리를 자동 회수하는 런타임 기술입니다.  
> 핵심 키워드는 **루트(roots)**, **도달성(reachability)**, **트라이컬러(tri-color)**, **배리어(barrier)**, **세대별(generational)**, **동시(concurrent)**, **압축(compaction)**, **진단/튜닝**입니다.

---

## 1) 왜 GC인가? (목표와 트레이드오프)

- **목표**: 메모리 안전성(누수/이중해제/댕글링 포인터 방지), 개발 생산성↑
- **대가**: **일시 정지(STW) 지연**, **CPU 사용(백그라운드 마킹)**, **메타데이터/여유 공간 오버헤드**
- **성능 지표**
  - **Throughput**: 총 작업 중 GC가 아닌 시간 비율
  - **Latency**: 각 STW 일시정지 시간
  - **Footprint**: 필요한 힙/메타데이터 메모리
  - **Mutator Utilization** (응용 실행 비율)
    \[
    U = \frac{T_{\text{mutator}}}{T_{\text{mutator}}+T_{\text{GC}}}
    \]

---

## 2) 기본 개념 — 루트, 객체 그래프, 도달성

- **루트(roots)**: 스택/레지스터의 참조, 전역/정적 변수, 스레드 전용 루트, JIT/인터프리터 내부 루트 등
- **도달성(reachability)**: 루트에서 참조 그래프를 따라 도달 가능한 객체 집합
- **정밀(precise) vs 보수(conservative) GC**
  - *정밀*: 객체와 포인터 위치를 정확히 앎(스택맵/타입 정보 필요, Java/.NET/Go 등)
  - *보수*: 포인터처럼 보이는 값을 포인터로 취급(Boehm GC 등 C/C++ 라이브러리)

---

## 3) 고전 추적형 알고리즘

### 3.1 Mark–Sweep (마크 후 스윕)
- **마크**: 루트에서 그래프 DFS/BFS → 방문 표시
- **스윕**: 힙 선형 스캔, 마크 안 된 블록을 자유 리스트에 반환
- **장점**: 구현 단순, 추가 공간↓  
- **단점**: **단편화** 남음(압축 없음), 스윕 비용은 힙 크기에 비례

```pseudo
mark(roots):
  worklist ← roots
  while worklist not empty:
    obj ← pop(worklist)
    if not marked(obj):
      mark(obj)
      for each child in fields(obj):
        push(worklist, child)

sweep(heap):
  for each block in heap:
    if marked(block): clear_mark(block)
    else: free_list.add(block)
```

### 3.2 Mark–Compact (슬라이딩 압축)
- 마킹 후 **살아있는 객체를 앞쪽으로 압축**(슬라이딩)하여 **단편화 제거**
- **주소가 바뀌므로** 포인터 재설정(포워딩 포인터/두 단계 패스) 필요
- **장점**: 단편화 거의 0, bump-pointer 할당 가능  
- **단점**: 이동/포인터 수정 비용, STW 길어질 수 있음

### 3.3 Copying (복사 세미스페이스, Cheney)
- 힙을 **from/to** 두 영역으로 나눔. 살아있는 객체를 to로 **복사**하며 스캔
- 복사 완료 후 역할 스왑 → from 전체가 한 번에 빈 공간
- **장점**: 매우 빠른 **선형(bump) 할당**, 단편화 X  
- **단점**: 메모리 2배 오버헤드, 큰 라이브셋에 비효율

---

## 4) 세대별(Generational) 수집 — “대부분의 객체는 빨리 죽는다”

- 힙을 **Young(Eden + Survivor S0/S1)** / **Old(tenured)** 로 분리
- **Minor GC**: Young만 수집(빠름). 살아남은 객체는 S0↔S1 사이 복사, 일정 횟수 생존 시 Old로 승격(tenuring)
- **Major/Full GC**: Old까지 포함(느림)
- **Remembered Set / Card Table**: Old→Young 참조를 추적해 Minor GC 때 Young만 스캔 가능
- **장점**: 대부분의 GC를 빠르게, 자주 수행  
- **튜닝 포인트**: Young 크기, 승격 임계, 카드 테이블 크기/동작

---

## 5) 증분/동시 GC — 지연(latency)을 줄이는 법

### 5.1 Tri-Color 모델 (흰/회/검)
- **White**: 아직 미방문(수집 대상)
- **Gray**: 방문했으나 자식 미처리(워크리스트)
- **Black**: 자신과 자식 처리 완료(살아있음)
- **불변식**: **Black → White 직접 참조 금지** (있다면 White를 Gray로 승급해야 함)

### 5.2 배리어(Barrier)
- **Write Barrier**: Mutator(응용)가 **필드를 갱신**할 때 호출되는 훅
  - **Dijkstra (incremental update)**: *새 참조를 추가*할 때 대상 White를 Gray로
  - **Yuasa (deletion/한계 스냅샷)**: *이전 참조를 제거*할 때 소스 객체를 Gray로
  - **Card Marking**: 변경된 메모리 영역(카드)을 표시해 나중에 스캔
- **Read Barrier**: 포인터 로드 시 훅(Shenandoah/ZGC, Brooks pointer/colored pointer)

### 5.3 Incremental vs Concurrent
- **Incremental**: 마킹을 **짧은 STW 조각**으로 쪼개 수행(배리어로 불변식 유지)
- **Concurrent**: 마킹 대부분을 **응용과 병행** 수행(Stop-the-world 최소화)
- **Relocation/Compaction**은 보통 짧은 STW 또는 읽기 배리어로 진행(기술 난이도↑)

---

## 6) 현대 수집기의 풍경(간단 지도)

| 수집기 유형 | 예시 | 핵심 아이디어 |
|---|---|---|
| Serial/Parallel Mark–Sweep/Compact | (HotSpot) Serial/Parallel GC | 병렬 마킹·스윕, 고처리량 |
| CMS(Deprecated) | HotSpot CMS | 동시 마킹 + 스윕(압축은 Full GC 때) |
| G1(Region-based) | HotSpot G1 | 힙을 균일 region으로 나눠 **선택적 수집**(SATB write barrier) |
| Shenandoah | HotSpot | **동시(compacting) 이동** + read barrier |
| ZGC | HotSpot | **coloured pointer** + load barrier, 초저지연 |
| CLR Server/Workstation | .NET | 세대별 + 백그라운드 수집, LOH(대형 객체 힙) |
| Go GC | Go | 동시 마킹 + 점진적 스위프, 저지연 지향(비이동 힙) |
| Immix | Research/Some JITs | 블록·라인 기반 마킹/컴팩트(대역 단편화↓) |
| C4 (Azul) | Pauseless | 읽기 배리어 기반 **무정지 이동**(하드웨어 도움+JIT 통합) |

---

## 7) 힙 구조와 할당 fast path

- **Bump-Pointer**: 압축/복사 기반에서 포인터만 전진 → **할당 O(1)**
- **TLAB(Thread-Local Allocation Buffer)**: 스레드별 소형 버퍼로 **락 없는** 빠른 할당
- **대형 객체(LOH/Humongous)**: 전용 영역/직접 맵핑, 컴팩트/이동 예외 처리

---

## 8) 참조의 종류와 파이널라이저

- **Strong/Weak/Soft/Phantom**: 수집 시점 제어(캐시/리소스 패턴)
  - *Weak*: 참조만으로는 객체 유지 X (Map 키로 흔히 사용)
  - *Soft*: 메모리 부족 시 수집 대상(캐시 친화)
  - *Phantom*: 수집 후 알림/정리 큐
- **Finalizer/Destructor**의 함정
  - **비결정적 실행**, **부활(resurrection)** 위험, **대기/락 금지**
  - 파일/소켓 등은 **명시적 close/RAII/try-with-resources**로 관리 권장

```java
// WeakReference 예시
Map<Key, WeakReference<Value>> cache = new ConcurrentHashMap<>();
```

---

## 9) 레퍼런스 카운팅과 하이브리드

- **Refcount(ARC)**: 할당/해제 즉시성, **순환 참조(cycle)** 문제
- **Cycle Collector**: 그래프 분석으로 순환 해제(CPython: refcount + cycle GC)
- **하이브리드**: RC + 추적형(백그라운드) 조합도 존재(Swift ARC는 언어 레벨)

```c
// 순환 예시 (RC만으로는 수집 불가)
a->b = b; b->a = a; // 외부에서 끊겨도 서로 참조해 refcount > 0
```

---

## 10) 스택 스캔, 안전지점(safepoint), 스택맵

- **Safepoint**: 스레드가 특정 지점(분기/호출/폴링)에서만 STW에 응답 → 스택 일관성 보장
- **Stack Map**: 프레임마다 **어디가 포인터인지** 알려주는 메타데이터(정밀 GC 필수)
- JIT는 코드 생성 시 **배리어/세이프포인트/스택맵**을 삽입

---

## 11) 메모리 모델·배리어 구현의 함의

- **Write Barrier**는 보통 **store 앞/뒤에 카드 마킹/엔큐** 삽입
- **Read Barrier**는 로드 후 **인디렉션/색 검사** 삽입(ZGC/She)
- 컴파일러/CPU 재정렬과 상호작용 → **메모리 오더/펜스** 필요(수집기 불변식 보존)

```c
// 간단한 카드 마킹 예시 (p->field = q)
p->field = q;
CARD_TABLE[(uintptr_t)p >> CARD_SHIFT] = DIRTY;
```

---

## 12) 단편화와 압축 전략

- **외부 단편화**: 자유 블록이 쪼개져 큰 할당 불가 → **컴팩션/복사**로 해소
- **내부 단편화**: 정렬/헤더/크기클래스 오버헤드 → **클래스 최적화/슬랩** 사용
- **Region/Line 기반**(Immix/G1): 지역적 압축으로 긴 STW 없이 단편화 줄이기

---

## 13) OS/하드웨어와의 상호작용

- **가상 메모리**: GC의 페이지 터치가 **TLB/캐시**에 영향(스캔 순서에 지역성 고려)
- **NUMA**: Young/Old/Region을 노드별로 배치, **first-touch** 준수
- **Huge Page**: 스캔 비용/DTLB 미스 감소 vs 내부 단편화 증가

---

## 14) 진단과 튜닝(언어별 공통 전략)

### 14.1 공통 원칙
- **목표를 정하라**: 처리량 vs 지연
- **두 수치 기록**: **할당률(MB/s)**, **라이브셋 크기(peak live)** → GC 유형/힙 크기 결정
- **장시간 추적**: 짧은 벤치만으로 결론 금지(버스트/온난화 효과)

### 14.2 흔한 기술
- **객체 수명 줄이기**: 재사용 버퍼/슬라이스, 배치(batch) 크기 조절
- **중간 객체 줄이기**: 박싱/임시 컬렉션 최소화
- **영세대 확대**: Minor GC 빈도↓(단, 승격 폭주 주의)
- **승격 임계(Tenuring) 조절**: “중간 수명” 객체가 Old로 빨리 가지 않게
- **대형 객체 경로**: 별도 영역/직접 맵핑으로 young 오염 방지
- **프로파일링/로그**: GC 로그, 할당 추적, 플레임그래프

### 14.3 예시 명령(플랫폼별)
```bash
# Java
java -Xlog:gc*:file=gc.log -XX:+PrintFlagsFinal
jstat -gcutil <pid> 1s
jcmd <pid> GC.run

# Go
GODEBUG=gctrace=1 ./app
go tool pprof -http :0 heap.out

# .NET
dotnet-counters monitor System.Runtime
COMPlus_GCLogEnabled=1  # (버전에 따라 상이)
```

---

## 15) 지연(latency) 민감 워크로드의 관점

- **목표**: p99/p999 정지 시간 제한(예: < 10ms) 충족
- **수단**: 동시 마킹 + 동시 이동(읽기 배리어), regionized 수집, STW 단계 쪼개기
- **설계 상식**: “작은 STW는 피할 수 없다” → **루트 스캔, 초기 마킹, 리맵** 최소화

---

## 16) 언어별 철학 비교(초간단)

| 언어/런타임 | 요지 |
|---|---|
| Java/HotSpot | 세대별 기본, G1/ZGC/Shenandoah로 저지연 옵션 풍부 |
| .NET CLR | 세대별 + 배경 수집, LOH/Server-GC, 최근 LOH 압축 지원 |
| Go | 저지연 지향 동시 마킹·스윕, 구조 단순, 튜닝노브 제한적 |
| JavaScript | 세대별 + 인라인 캐시 친화, 브라우저 엔진별 커스텀 |
| Python | refcount + 주기적 cycle GC, C 확장과 상호작용 주의 |
| Rust | **GC 없음**: 소유권/수명/빌림 검사로 메모리 안전 달성(런타임 오버헤드↓) |

---

## 17) 체크리스트

- [ ] 라이브셋/할당률을 측정했다  
- [ ] 지연 목표(p99)를 수치로 정했다  
- [ ] Young/Old/Region 크기를 근거 있게 설정했다  
- [ ] “중간 수명” 객체를 줄였다(파이프라인/배치 재설계)  
- [ ] 카드/리멤버드셋 오염이 과도하지 않다(Old→Young 참조 최소화)  
- [ ] 파이널라이저/약참조 사용은 최소·명확한 시맨틱을 가졌다  
- [ ] NUMA/hugepage/TLAB 등 하부와의 상호작용을 점검했다

---

## 18) 마무리

가비지 컬렉션은 **도달성 기반의 자동 메모리 관리**이자, **지연/처리량/메모리** 사이의 공학적 균형 예술입니다.  
알고리즘(마크·스윕/압축/복사/세대별/동시), 불변식(트라이컬러), 장치(배리어/스택맵/TLAB),  
그리고 운영 관점(로그/프로파일/튜닝)을 하나로 바라보면, **안전성과 성능**을 동시에 잡을 수 있습니다.