---
layout: post
title: Django - 배포 & 운영 (1)
date: 2025-10-06 14:25:23 +0900
category: Django
---
# 8. 배포 & 운영 (1) — 설정 분리 · 서버(WSGI/ASGI) · Nginx 리버스 프록시

## A. 설정 분리 — 12-Factor, django-environ, 비밀/환경변수 전략

### A-1. 12-Factor 요약 (운영 관점 핵심만)
- **코드베이스는 하나, 배포는 여러 개**: 동일한 레포지토리에서 `dev/stage/prod` 를 배포.
- **설정은 환경에 저장**: 비밀/엔드포인트/플래그는 **환경변수**로 주입.
- **백엔드 서비스는 연결된 자원**: DB/Redis/S3 등을 설정 문자열로 주입.
- **빌드/릴리스/실행 분리**: 이미지를 빌드 → 릴리스(환경·비밀 주입) → 실행.

### A-2. 프로젝트 구조 (settings 모듈 분리)
```
config/
  settings/
    __init__.py
    base.py
    dev.py
    stage.py
    prod.py
  asgi.py
  wsgi.py
```

```python
# config/settings/__init__.py
# 환경변수 DJANGO_SETTINGS_MODULE 로 제어 (예: config.settings.prod)
```

```python
# config/settings/base.py
from pathlib import Path
import os

BASE_DIR = Path(__file__).resolve().parents[2]
DEBUG = False
ALLOWED_HOSTS = []

INSTALLED_APPS = [
    # 기본 앱...
    "django.contrib.staticfiles",
    # Third-party...
    "rest_framework",
    # Local...
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "config.urls"
WSGI_APPLICATION = "config.wsgi.application"
ASGI_APPLICATION = "config.asgi.application"

# 템플릿/DB/시간대 등 공통 설정...
TIME_ZONE = "Asia/Seoul"
USE_TZ = True

STATIC_URL = "/static/"
STATIC_ROOT = BASE_DIR / "staticfiles"   # collectstatic 대상
MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"
```

### A-3. django-environ 도입
```bash
pip install django-environ
```

```python
# config/settings/base.py
import environ
env = environ.Env()
ENV_FILE = BASE_DIR / ".env"           # dev/stage는 파일, prod는 OS env
if ENV_FILE.exists():
    environ.Env.read_env(str(ENV_FILE))  # 로컬에서만 읽기

SECRET_KEY = env("DJANGO_SECRET_KEY", default="dev-unsafe-secret")
DEBUG = env.bool("DEBUG", default=False)

DATABASES = {
  "default": env.db(default="sqlite:///" + str(BASE_DIR / "db.sqlite3"))
}
CACHES = {
  "default": env.cache(default="locmemcache://")
}
```

`.env` 샘플(커밋 금지, 대신 `.env.example` 제공):
```
DEBUG=True
DJANGO_SECRET_KEY=dev-unsafe-secret
DATABASE_URL=postgres://app:pass@localhost:5432/app
CACHE_URL=redis://localhost:6379/1
ALLOWED_HOSTS=localhost,127.0.0.1
```

### A-4. 환경별 오버레이
```python
# config/settings/prod.py
from .base import *
DEBUG = False

ALLOWED_HOSTS = env.list("ALLOWED_HOSTS", default=["example.com"])
SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True

# HSTS 권장
SECURE_HSTS_SECONDS = 60*60*24*30
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# S3 스토리지 예시
DEFAULT_FILE_STORAGE = "storages.backends.s3boto3.S3Boto3Storage"
AWS_STORAGE_BUCKET_NAME = env("AWS_STORAGE_BUCKET_NAME")
AWS_S3_REGION_NAME = env("AWS_S3_REGION_NAME", default="ap-northeast-2")
```

### A-5. 비밀/환경변수 전략
- **로컬**: `.env` 파일로 개발 편의 확보.
- **스테이징/운영**: 오케스트레이터(Kubernetes/Cloud Run/Heroku 등)에서 **Secret/ConfigMap/EnvVar** 로 주입.
- **회전/교체**: 키를 참조하는 코드가 재배포 없이도 교체 가능하도록 주입 경로를 환경변수로 통일.
- **검증**: 부팅 시 환경 검증(누락/형식)으로 실패를 **초기에** 발견.

```python
# config/settings/validate.py (선택: 부팅 시 필수 env 확인)
required = ["DJANGO_SECRET_KEY", "DATABASE_URL"]
missing = [k for k in required if not env(k, default=None)]
if missing:
    raise RuntimeError(f"Missing env: {missing}")
```

---

## B. WSGI/ASGI 서버 — Gunicorn/Uvicorn, worker 모델, 튜닝 체크리스트

### B-1. 어떤 서버를 쓸까?
- **WSGI(Gunicorn/uWSGI)**: 전통적 동기 뷰 중심 앱에 적합. 안정성/도구 풍부.
- **ASGI(Uvicorn/Daphne + Gunicorn worker)**: **비동기 뷰/웹소켓/스트리밍** 필요 시 필수.
- **혼용**: Django 5.x는 `wsgi.py`/`asgi.py` 모두 제공. **하나만** 노출해도 되고, **ASGI로 통일**하는 경우가 증가.

### B-2. Gunicorn (WSGI) — 기본 실행 & 옵션
```bash
pip install gunicorn
# CPU 코어 x 2 + 1 권장치를 참고하되 실측으로 튜닝
gunicorn config.wsgi:application \
  --bind 0.0.0.0:8000 \
  --workers 4 \
  --threads 2 \
  --timeout 30 \
  --graceful-timeout 30 \
  --access-logfile - \
  --error-logfile -
```
- `--workers`: **프로세스** 수. CPU 바운드면 코어 수 기준, I/O 바운드/DB 대기 많으면 늘리되 메모리 고려.
- `--threads`: 동시성 증가(동기 코드), GIL 영향 감안.
- `--timeout`: 워커가 응답 못 하면 재시작. 너무 짧으면 큰 요청이 끊기고, 너무 길면 리소스 고갈.

**systemd 서비스 예시**
```ini
# /etc/systemd/system/app.service
[Unit]
Description=Django Gunicorn
After=network.target

[Service]
User=www-data
Group=www-data
WorkingDirectory=/srv/app
Environment="DJANGO_SETTINGS_MODULE=config.settings.prod"
ExecStart=/srv/app/venv/bin/gunicorn config.wsgi:application \
  --bind unix:/run/app.sock --workers 4 --threads 2 --timeout 30
Restart=always
RuntimeDirectory=app

[Install]
WantedBy=multi-user.target
```

### B-3. Uvicorn (ASGI) — 단독/혼합 실행
```bash
pip install "uvicorn[standard]"
# 개발/단독
uvicorn config.asgi:application --host 0.0.0.0 --port 8000 --workers 4
```

**Gunicorn + UvicornWorker (추천)**
```bash
pip install "uvicorn[standard]" gunicorn
gunicorn config.asgi:application \
  -k uvicorn.workers.UvicornWorker \
  -w 4 -b 0.0.0.0:8000 \
  --timeout 60 --graceful-timeout 60
```
- `UvicornWorker` 로 **ASGI** 앱을 Gunicorn이 관리(신호/로그/프리포크).
- 웹소켓/비동기 뷰까지 커버.

### B-4. 워커 모델 개념
- **prefork(프로세스)**: 격리·안정성↑ / 메모리↑.
- **스레드**: 동시성↑ / GIL의 제약 / I/O 대기 많은 앱에 유용.
- **async(이벤트 루프)**: 초고동시성 I/O에 강함 / 동기 ORM 호출은 `sync_to_async` 필요.

> **실측 튜닝 원칙**
1) **엣지 제한**(Nginx/ALB)과 **백엔드 워커 수** 밸런싱.
2) 애플리케이션 지연의 **p50/p90/p99**를 측정하고 `--timeout`/`--workers` 조정.
3) 워커 수를 늘려도 DB/Redis/스토리지 **커넥션 풀** 한계를 넘지 않도록.

### B-5. 최대 요청 수 & 메모리 누수 대응
- **Gunicorn**: `--max-requests 1000 --max-requests-jitter 100` 로 주기적 워커 재생성.
- **Uvicorn**: 외부에서 관리(음수 leak 감지 어려우면 프로세스 재순환).

### B-6. 그레이스풀 종료/롤링 배포
- SIGTERM → 워커가 현재 요청 처리 후 종료(`--graceful-timeout` 내).
- 무중단 대안: **블루-그린/카나리** 배포(로드밸런서에서 트래픽 스위치).

### B-7. 헬스체크/프리포크 훅
- `/healthz` 로 DB/캐시 핑(가벼운 쿼리).
- Gunicorn `--preload`(부팅 최적화) 사용 시 DB 커넥션 공유 주의(포크 후 재연결 필요).

```python
# apps/core/health.py
from django.http import JsonResponse
from django.db import connection
def healthz(request):
    with connection.cursor() as c: c.execute("SELECT 1")
    return JsonResponse({"ok": True})
```

---

## C. Nginx 리버스 프록시 — 정적/미디어, 업스트림, 보안 헤더

### C-1. 배치 다이어그램 (가장 흔한 패턴)
```
[Client] ⇄ HTTPS ⇄ [Nginx] ⇄ Unix Socket/TCP ⇄ [Gunicorn(UvicornWorker)] ⇄ Django
                           └── /static, /media (Whitenoise 또는 Nginx 직접서빙)
```

### C-2. 기본 Nginx 서버 블록 (HTTP→HTTPS 리다이렉트)
```nginx
server {
  listen 80;
  server_name example.com www.example.com;
  return 301 https://$host$request_uri;
}
```

### C-3. HTTPS 서버 블록 (업스트림 라우팅)
```nginx
upstream django {
  server unix:/run/app.sock;  # 또는 server 127.0.0.1:8000;
  keepalive 32;
}

server {
  listen 443 ssl http2;
  server_name example.com www.example.com;

  ssl_certificate     /etc/letsencrypt/live/example.com/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

  # 보안 헤더 (기본값)
  add_header X-Content-Type-Options nosniff;
  add_header X-Frame-Options DENY;
  add_header Referrer-Policy "strict-origin-when-cross-origin";
  add_header Permissions-Policy "geolocation=()";
  # (선택) CSP는 점진 도입: Report-Only → 실제 Enforce
  # add_header Content-Security-Policy "default-src 'self'";

  # 프록시 공통 헤더
  proxy_set_header Host $host;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;

  # 정적/미디어 (Nginx 직접 서빙)
  location /static/ {
    alias /srv/app/staticfiles/;
    access_log off;
    expires 30d;
    add_header Cache-Control "public, max-age=2592000, immutable";
  }
  location /media/ {
    alias /srv/app/media/;
    access_log off;
    expires 1h;
    add_header Cache-Control "private, max-age=3600";
  }

  # 업스트림 (Django)
  location / {
    proxy_read_timeout 60s;
    proxy_connect_timeout 5s;
    proxy_send_timeout 60s;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_pass http://django;
  }

  # WebSocket (Channels/ASGI 사용 시)
  location /ws/ {
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_pass http://django;
  }

  # 대용량 다운로드를 파일 서버로 위임(X-Accel-Redirect)
  location /protected/ {
    internal;
    alias /srv/private/;
  }

  # 압축 (정적 자산은 사전 압축 권장)
  gzip on;
  gzip_comp_level 5;
  gzip_min_length 1024;
  gzip_types text/plain text/css application/json application/javascript application/xml image/svg+xml;
}
```

### C-4. Let's Encrypt 자동화 (certbot)
```bash
apt install certbot python3-certbot-nginx
certbot --nginx -d example.com -d www.example.com --redirect
# 갱신 크론/타이머 자동 생성. 수동 갱신: certbot renew --dry-run
```

### C-5. 정적/미디어 서빙 전략
- **Whitenoise**: 앱 컨테이너 단독 배포 시 간단. 작은 트래픽에서 유리.
  - 장점: 별도 Nginx 없이도 됨.
  - 단점: 고부하/큰 파일엔 비효율.
- **Nginx 직접 서빙**: 고부하/대용량에 유리. 캐시/압축/HTTP/2 최적화 수월.
- **CDN(CloudFront/Cloudflare)**: 글로벌 분산/캐시. 원본은 S3/정적 서버.

**Whitenoise 설정**
```bash
pip install whitenoise[brotli]
```
```python
# settings/base.py
MIDDLEWARE = ["whitenoise.middleware.WhiteNoiseMiddleware", *MIDDLEWARE]
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"
```

### C-6. 업스트림/타임아웃/버퍼
- **읽기 타임아웃**(`proxy_read_timeout`): Django가 응답까지 걸리는 최대 시간.
- **sendfile**: Nginx가 파일을 직접 전송(`sendfile on;`) — CPU/컨텍스트 스위치 절감.
- **버퍼링**: `proxy_buffering on;` (기본) — 스트리밍/서버센트이벤트(SSE)는 `off` 고려.

### C-7. HTTP/2, Brotli, 캐시 정책
- `listen 443 ssl http2;` — 멀티플렉싱/헤더 압축.
- **Brotli**(nginx-module-brotli)로 정적 자산 압축률↑.
- **Cache-Control**: 정적은 긴 `max-age` + `immutable`, 해시 파일명을 사용(collectstatic 시 manifest).

### C-8. 보안 헤더/프록시 헤더, SSL 종료 뒤 Django 설정
- Nginx에서 SSL 종료 후 백엔드와는 내부 HTTP.
- Django가 신뢰된 프록시를 알 수 있도록:
```python
# settings/prod.py
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
USE_X_FORWARDED_HOST = True
```

### C-9. 업로드 제한/요청 크기 방어
```nginx
# 너무 큰 요청 early reject
client_max_body_size 20m;
```
Django/폼에서도 **서버 측 검증**(파일 크기/MIME/확장자)을 반드시 병행.

---

## D. 운영 체크리스트 — 요약

**설정/비밀**
- [ ] `django-environ` 으로 환경변수 일원화, `.env` 는 로컬에서만
- [ ] 필수 ENV 사전 검증, 비밀은 Vault/Secret Manager/Secret 리소스로 주입
- [ ] 환경별 설정 모듈(`base/dev/stage/prod`) 분리, 공통은 `base.py`

**서버(Gunicorn/Uvicorn)**
- [ ] 워커 수/스레드/타임아웃 **실측 튜닝**
- [ ] `--max-requests` 로 워커 재순환, 메모리 누수 방어
- [ ] 헬스체크(`/healthz`) 제공, graceful 종료 시간 확보
- [ ] ASGI 필요 시 `UvicornWorker` 채택, WebSocket 라우팅 분리

**Nginx**
- [ ] HTTP→HTTPS 리다이렉트, HTTP/2 활성화
- [ ] 정적/미디어 직접 서빙, 캐시 헤더 최적화
- [ ] WebSocket 업그레이드 헤더(Upgrade/Connection)
- [ ] 보안 헤더(CSP는 Report-Only→Enforce), HSTS, nosniff/Referrer-Policy
- [ ] `client_max_body_size` 제한, proxy/read 타임아웃 합리화

**배포 프로세스**
- [ ] `collectstatic` → 마이그레이션 → 애플리케이션 재시작(그레이스풀)
- [ ] 블루-그린/카나리로 다운타임 최소화
- [ ] 롤백 절차/DB 백업·복구 리허설 정례화

---

## E. 부록 — Docker/Compose 예제 (옵션)

### E-1. Dockerfile (Slim + 빌드 단계)
```dockerfile
# syntax=docker/dockerfile:1
FROM python:3.12-slim AS base
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1

WORKDIR /app
COPY pyproject.toml poetry.lock /app/
RUN pip install --no-cache-dir poetry && poetry config virtualenvs.create false \
 && poetry install --no-root --only main

COPY . /app/

# collectstatic 실행 (WhiteNoise/또는 S3면 생략)
RUN python manage.py collectstatic --noinput

CMD ["gunicorn","config.asgi:application","-k","uvicorn.workers.UvicornWorker","-w","4","-b","0.0.0.0:8000","--timeout","60"]
```

### E-2. docker-compose.yml (Nginx + 앱 + Redis + Postgres)
```yaml
version: "3.9"
services:
  web:
    build: .
    env_file: .env
    depends_on: [db, redis]
    networks: [appnet]

  nginx:
    image: nginx:1.27
    volumes:
      - ./deploy/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - static:/srv/app/staticfiles:ro
      - media:/srv/app/media:ro
    ports: ["80:80","443:443"]
    depends_on: [web]
    networks: [appnet]

  db:
    image: postgres:16
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: app
      POSTGRES_PASSWORD: secret
    volumes: [dbdata:/var/lib/postgresql/data]
    networks: [appnet]

  redis:
    image: redis:7-alpine
    networks: [appnet]

volumes:
  dbdata:
  static:
  media:

networks:
  appnet:
```

---

## F. 운영 스크립트 모음

### F-1. 배포 훅(관리 커맨드)
```bash
python manage.py check --deploy
python manage.py migrate --noinput
python manage.py collectstatic --noinput
# Celery/워커/비트 재시작은 프로세스 매니저로
```

### F-2. 롤링 재시작 (systemd)
```bash
sudo systemctl reload nginx
sudo systemctl restart app
# 상태 확인
sudo systemctl status app --no-pager
journalctl -u app -f
```

### F-3. 로그 구조화 (JSON 한 줄)
```python
# settings/base.py 발췌
LOGGING = {
  "version": 1,
  "disable_existing_loggers": False,
  "handlers": {"console": {"class": "logging.StreamHandler"}},
  "root": {"handlers": ["console"], "level": "INFO"},
}
# 프로덕션에서는 JSON 포매터/Request-ID 필터 추가 권장
```

---

## 마무리

- **설정 분리**는 운영 복잡도를 줄이고 **보안/가용성**을 높이는 출발점입니다. `django-environ` 으로 **환경변수 일원화**, 비밀은 **런타임 주입**으로 관리하세요.
- **서버 레이어**는 **워크로드 측정치**로 튜닝하세요. 동기라면 Gunicorn WSGI, 비동기/웹소켓이라면 **UvicornWorker** 로 **ASGI** 를 선택. 타임아웃, 워커 수, 커넥션 풀을 **실측 기반**으로 맞추는 것이 핵심입니다.
- **Nginx 리버스 프록시**는 **TLS/HTTP2, 보안 헤더, 정적/미디어 캐시**를 책임집니다. 업스트림/웹소켓/대용량 전송(X-Accel)까지 **표준 패턴**으로 묶으면 배포가 단순해지고 성능이 안정화됩니다.
