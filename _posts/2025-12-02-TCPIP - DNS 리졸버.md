---
layout: post
title: TCPIP - DNS 리졸버
date: 2025-12-02 15:25:23 +0900
category: TCPIP
---
# DNS 해석 개념과 리졸버 동작

## DNS 리졸버 기능과 일반 동작

DNS 리졸버는 DNS 질의 체인의 시작점이자 종착점으로, 애플리케이션의 이름 해석 요청을 처리하는 핵심 구성요소입니다. 리졸버는 단순한 주소 변환기를 넘어, 캐싱, 재시도, 오류 처리 등의 지능적 기능을 수행합니다.

### 리졸버 아키텍처

#### 스터브 리졸버 vs 재귀적 리졸버

**스터브 리졸버 (Stub Resolver):**
- 애플리케이션 라이브러리 내장 (예: glibc의 getaddrinfo())
- 최소 기능만 제공: 요청 포맷팅, 응답 파싱
- 재귀적 리졸버에 의존하여 실제 해석 수행
- 로컬 캐시 관리 가능 (일부 구현)

**재귀적 리졸버 (Recursive Resolver):**
- 완전한 DNS 질의 수행 능력
- ISP, 공용 DNS(8.8.8.8), 또는 조직 내부에서 운영
- 캐시 관리, 재시도 로직, 보안 검증 포함

```
애플리케이션 → 스터브 리졸버 → 재귀적 리졸버 → DNS 서버 계층
        (로컬)        (질의 전달)      (실제 해석)
```

### 리졸버의 핵심 동작 절차

1. **요청 수신**: 애플리케이션의 이름 해석 요청
2. **로컬 캐시 확인**: 이전 결과 재사용 가능 여부 판단
3. **캐시 미스 시**: 재귀적 해석 과정 시작
4. **응답 검증**: DNSSEC 서명 확인 (구성된 경우)
5. **결과 반환**: 애플리케이션에 IP 주소 또는 오류 반환

## DNS 기본 이름 해석 기술: 반복적 해석과 재귀적 해석

### 반복적 해석 (Iterative Resolution)

반복적 해석에서 리졸버는 직접 각 단계의 서버와 상호작용합니다. 각 서버는 "이 정도까지는 안다"는 정보를 제공하고, 다음 단계의 서버를 알려줍니다.

**반복적 해석 과정:**

```
클라이언트(리졸버)               서버 응답
───────────────               ─────────────
1. "www.example.com 주소 알려줘" → 루트 서버
2. ← ".com 서버에게 물어봐" (참조 응답)
3. ".com 서버, www.example.com 주소 알려줘" → TLD 서버
4. ← "example.com 서버에게 물어봐"
5. "example.com 서버, www 주소 알려줘" → 권한 서버
6. ← "192.0.2.1입니다" (최종 응답)
```

**반복적 해석 특징:**
- 리졸버가 모든 단계 직접 처리
- 서버 부하 분산: 각 서버는 자신의 영역만 응답
- 클라이언트 복잡도 증가
- 현대 대규모 환경에서 비효율적

### 재귀적 해석 (Recursive Resolution)

재귀적 해석에서 클라이언트는 단일 서버에 요청을 위임하고, 해당 서버가 전체 해석 과정을 대신 수행합니다.

**재귀적 해석 과정:**

```
클라이언트                재귀적 리졸버                DNS 서버 계층
─────────                ─────────────              ──────────────
1. "www.example.com" ──→
                             2. 루트 서버에 질의 ────→
                             3. ←─────────────── ".com 서버 참조"
                             4. .com 서버에 질의 ───→
                             5. ←─────────────── "example.com 서버 참조"
                             6. 권한 서버에 질의 ──→
                             7. ←─────────────── "192.0.2.1"
                    ←──── 8. "192.0.2.1"
```

**재귀적 해석 장점:**
- 클라이언트 단순화: 복잡한 로직 불필요
- 캐싱 효율성: 리졸버 수준의 공유 캐시 가능
- 성능 최적화: 전문 서버의 고성능 구현 가능
- 보안 관리 중앙화: DNSSEC 검증 등

### 현실 세계의 혼합 모델

실제 DNS 구현은 두 모델의 하이브리드를 사용합니다:

```
인터넷 표준 모델:
[스터브 리졸버] → [재귀적 리졸버] → [반복적 질의] → DNS 서버 계층
    (재귀 요청)      (재귀 수행)       (반복 수행)

• 최종 사용자: 재귀적 모델 경험
• 재귀 리졸버: 내부적으로 반복적 질의 사용
• 권한 서버: 반복적 모델로 응답
```

## DNS 이름 해석 효율성 향상: 캐싱과 로컬 해석

### DNS 캐싱 계층 구조

캐싱은 DNS 성능의 핵심으로, 여러 수준에서 구현됩니다:

```
캐싱 계층:
1. 운영체제/애플리케이션 캐시 (초 단위)
2. 스터브 리졸버 캐시 (분 단위)
3. 재귀적 리졸버 캐시 (TTL 기반)
4. 포워더 캐시 (중소 규모 네트워크)
5. 공용 DNS 글로벌 캐시 (Google, Cloudflare 등)
```

### TTL(Time-To-Live) 전략

TTL은 캐시 효율성과 정보 신선도 사이의 균형을 조절합니다:

**다양한 TTL 설정 전략:**

| 사용 사례 | 권장 TTL | 이유 |
|-----------|----------|------|
| 정적 웹사이트 | 86400초 (24시간) | 변경 빈도 낮음, 캐시 효율 |
| CDN 엣지 서버 | 300초 (5분) | 빠른 장애 조치, 로드 밸런싱 |
| 이메일 서버 | 3600초 (1시간) | 이메일 전달 지연 허용 |
| 개발/테스트 | 60초 (1분) | 빠른 변경 반영 필요 |
| 중요 서비스 | 30초 | 최소 다운타임 보장 |

### 로컬 해석 최적화 기법

#### 1. Negative Caching
존재하지 않는 도메인이나 오류 응답도 캐싱하여 불필요한 재시도 방지

```
예시: "nonexistent.example.com" 조회
- 첫 시도: NXDOMAIN 응답
- 캐시: 300-3600초 동안 NXDOMAIN 캐시
- 후속 시도: 즉시 실패 반환
```

#### 2. Prefetching
사용자가 링크를 클릭하기 전에 관련 도메인을 미리 해석

```
브라우저 동작:
1. 페이지 로드 시 페이지 내 모든 링크의 도메인 해석 시작
2. 캐시에 저장
3. 사용자 클릭 시 즉시 연결
```

#### 3. Aggressive Caching
TTL 만료 전에도 백그라운드에서 신선도 확인

```
TTL 90% 경과 시:
- 백그라운드에서 새로고침 시도
- 성공 시 캐시 갱신
- 실패 시 기존 캐시 유지 (TTL 완료까지)
```

### 현대 캐싱 기술 발전

**EDNS Client Subnet:**
```
재귀 리졸버가 클라이언트 서브넷 정보를 권한 서버에 전달
→ 지리적으로 가까운 서버 IP 반환
→ CDN 성능 최적화
```

**DNS over HTTPS/TLS 캐싱:**
```
암호화된 DNS에서의 캐싱 도전:
- 프라이버시 vs 효율성 균형
- 중간자 캐싱 어려움
- 로컬 캐싱 의존성 증가
```

## DNS 이름 해석 과정

### 완전한 DNS 해석 흐름

다음은 `www.sub.example.com`을 조회하는 상세한 과정입니다:

```
단계별 해석 과정:

1. 애플리케이션 요청
   브라우저: "www.sub.example.com 접속"
   
2. 로컬 캐시 확인 (계층적)
   a. 브라우저 DNS 캐시
   b. 운영체제 DNS 캐시
   c. hosts 파일 확인

3. 스터브 리졸버 동작
   a. /etc/resolv.conf 확인 (DNS 서버 설정)
   b. 질의 생성: www.sub.example.com IN A
   c. 재귀적 리졸버(예: 8.8.8.8)로 전송

4. 재귀적 리졸버의 내부 처리
   a. 자기 캐시 확인
   b. 루트 힌트 파일 로드 (기본 13개 루트 서버)
   c. 가장 가까운 루트 서버 선택 (anycast)

5. 반복적 해석 시작
   a. 루트 서버에 .com NS 레코드 요청
      응답: a.gtld-servers.net 등 .com TLD 서버 목록
   
   b. .com TLD 서버에 example.com NS 레코드 요청
      응답: ns1.example.com 등 권한 서버 목록
   
   c. example.com 권한 서버에 sub.example.com NS 레코드 요청
      응답: ns1.sub.example.com 등 하위 권한 서버
   
   d. sub.example.com 권한 서버에 www A 레코드 요청
      최종 응답: 192.0.2.1

6. 응답 캐싱
   각 단계의 응답을 TTL 기반으로 캐시:
   - 루트 서버 정보: 1,200,000초 (약 13일)
   - TLD 서버 정보: 172,800초 (2일)
   - 권한 서버 정보: 86,400초 (1일)
   - A 레코드: 설정된 TTL (예: 300초)

7. 결과 반환
   재귀 리졸버 → 스터브 리졸버 → OS → 브라우저
   최종: 192.0.2.1
```

### 해석 과정에서의 오류 처리

#### 일반적인 오류 유형 및 처리:

1. **NXDOMAIN (Non-Existent Domain)**
   ```
   원인: 도메인이 존재하지 않음
   처리: Negative caching (300-3600초)
   ```

2. **SERVFAIL (Server Failure)**
   ```
   원인: 권한 서버 장애 또는 DNSSEC 검증 실패
   처리: 대체 서버 시도, 캐시 무효화
   ```

3. **REFUSED (Query Refused)**
   ```
   원인: 서버가 재귀 질의를 거부
   처리: 다른 리졸버로 폴백
   ```

4. **TIMEOUT**
   ```
   원인: 서버 응답 시간 초과
   처리: 재시도 (보통 2-3회), 다른 서버 시도
   ```

### 병렬 질의와 성능 최적화

현대 리졸버는 병렬 처리를 통해 성능을 극대화합니다:

```
병렬 해석 예시:
1. IPv4(A)와 IPv6(AAAA) 레코드 동시 질의
2. 다중 업스트림 리졸버 사용 (로드 밸런싱)
3. Happy Eyeballs: 두 스택 중 빠른 응답 선택
4. DNSSEC 검증 병렬화
```

## IN-ADDR.ARPA 도메인을 이용한 DNS 역방향 이름 해석

### 역방향 해석의 필요성

정방향 해석이 이름 → IP 변환이라면, 역방향 해석은 IP → 이름 변환입니다:

**주요 용도:**
1. **로그 분석**: IP 주소를 사람이 읽을 수 있는 이름으로 변환
2. **보안 검증**: 이메일 서버, SSH 접속 등에서 역방향 DNS 확인
3. **네트워크 진단**: 네트워크 문제 해결 시 IP 소유자 식별
4. **스팸 필터링**: PTR 레코드가 정방향과 일치하는지 확인

### IN-ADDR.ARPA 구조

IPv4 주소는 역방향 조회를 위해 거꾸로 배열되고 `.in-addr.arpa` 도메인이 추가됩니다:

```
IPv4 주소: 192.0.2.1
변환 과정:
1. 옥텟 반전: 1.2.0.192
2. .in-addr.arpa 추가: 1.2.0.192.in-addr.arpa
3. PTR 레코드 질의: "1.2.0.192.in-addr.arpa IN PTR"
```

**계층적 구조:**
```
.in-addr.arpa (루트)
├── 192.in-addr.arpa (클래스 C)
│   └── 0.192.in-addr.arpa
│       └── 2.0.192.in-addr.arpa
│           └── 1.2.0.192.in-addr.arpa (최종)
```

### IPv6 역방향 해석: IP6.ARPA

IPv6의 128비트 주소는 16진수 니블(4비트) 단위로 반전됩니다:

```
IPv6 주소: 2001:0db8:85a3::1
정규화: 2001:0db8:85a3:0000:0000:0000:0000:0001
반전: 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.3.a.5.8.8.b.d.0.1.0.0.2
.ip6.arpa 추가: 1.0.0.0...2.ip6.arpa
```

### 역방향 DNS 운영 실무

#### 권한 위임 구조:
```
IANA → RIR(Regional Internet Registry) → ISP/LIR → 최종 사용자
      (ARIN, APNIC, RIPE 등)          (위임 관리)
```

#### PTR 레코드 관리 모범 사례:
1. **일관성 유지**: PTR 레코드가 정방향 A/AAAA 레코드와 일치
2. **의미 있는 이름**: `server1.example.com` 같이 식별 가능한 이름
3. **보안 고려**: 중요한 서버에만 PTR 설정, 내부 서버는 생략 가능
4. **위임 관리**: ISP에 위임하거나 자체 권한 서버 운영

## DNS 전자 메일 지원과 메일 교환(MX) 자원 레코드

### MX 레코드의 역할

MX(Mail Exchange) 레코드는 도메인의 이메일 수신 서버를 지정합니다. 이메일 시스템의 핵심 구성 요소로, SMTP 프로토콜이 이 레코드를 사용하여 메일 라우팅을 결정합니다.

### MX 레코드 구조

```
example.com.  IN  MX  10  mail1.example.com.
example.com.  IN  MX  20  mail2.example.com.
             │     │     │    │
             │     │     │    └─ 메일 서버 호스트명
             │     │     └─────── 우선순위 (낮을수록 높은 우선순위)
             │     └───────────── 레코드 유형
             └─────────────────── 도메인
```

### MX 레코드 해석 과정

이메일 전송 시 메일 서버의 MX 조회 과정:

```
메일 흐름: sender@domainA.com → recipient@example.com

1. 발신 MTA(Mail Transfer Agent)가 example.com의 MX 레코드 조회
2. DNS 응답: MX 10 mail1.example.com, MX 20 mail2.example.com
3. 우선순위 10인 mail1.example.com의 A/AAAA 레코드 조회
4. IP 주소 획득 (예: 192.0.2.10)
5. SMTP 세션 시작: 192.0.2.10의 포트 25로 연결 시도
6. 실패 시: 우선순위 20인 mail2.example.com으로 폴백
```

### MX 레코드 설계 전략

#### 1. 우선순위 전략
```
고가용성 구성:
MX 10  primary-mail.example.com   (기본)
MX 20  secondary-mail.example.com (보조)
MX 30  tertiary-mail.example.com  (3차)

장애 조치: primary 실패 → secondary 자동 시도
```

#### 2. 지리적 분산
```
글로벌 서비스:
MX 10  us-mail.example.com    (미국)
MX 15  eu-mail.example.com    (유럽)
MX 20  asia-mail.example.com  (아시아)

지연 시간 최소화, 지역 규정 준수
```

#### 3. 서비스 제공자 이중화
```
리스크 분산:
MX 10  mx1.google.com      (Google Workspace)
MX 20  mx2.microsoft.com   (Microsoft 365)

한 제공자 장애 시 다른 제공자로 폴백
```

### 관련 레코드와의 상호작용

#### SPF(Sender Policy Framework)
```
SPF 레코드: 허용된 발신 서버 정의
example.com. IN TXT "v=spf1 mx ~all"
의미: "이 도메인의 MX 서버만 발신 허용"
```

#### DKIM(DomainKeys Identified Mail)
```
DKIM: 이메일 서명을 통한 발신자 인증
selector._domainkey.example.com. IN TXT "k=rsa; p=MIGf..."
```

#### DMARC(Domain-based Message Authentication)
```
DMARC: SPF/DKIM 정책 및 보고
_dmarc.example.com. IN TXT "v=DMARC1; p=reject; rua=mailto:reports@example.com"
```

### 현대 이메일 인프라의 발전

#### 구독 기반 메일 라우팅
```
기존: MX → A 레코드 → IP
현대: MX → CNAME → 클라우드 제공자 엔드포인트
장점: 제공자 변경 용이, 로드 밸런싱 자동화
```

#### 메일 백업 서비스
```
MTA가 모든 MX 서버에 동시 전송:
- 최소 지연 보장
- 수신 측 중복 제거
- 고가용성 극대화
```

## 결론

DNS 해석 시스템은 단순한 이름-주소 변환을 넘어, 현대 인터넷 인프라의 지능적인 라우팅 엔진으로 진화했습니다. 반복적 해석과 재귀적 해석의 조화로운 공존은 분산 시스템 설계의 교과서적 사례를 보여주며, 계층적 캐싱 메커니즘은 전 세계 수십 억 개의 질의를 효율적으로 처리할 수 있는 기반을 마련했습니다.

역방향 DNS 해석은 보안과 신뢰성의 중요한 기둥으로 자리 잡았습니다. 단순한 기술적 기능을 넘어, 네트워크 운영의 책임성과 투명성을 보장하는 수단이 되었습니다. 이는 특히 이메일 시스템에서 두드러지며, 스팸 방지와 발신자 검증의 핵심 요소로 작동합니다.

MX 레코드를 중심으로 한 이메일 인프라는 DNS의 또 다른 중요한 응용 분야를 보여줍니다. 단순한 레코드 유형이 전 세계 이메일 통신의 신뢰성과 가용성을 좌우하는 사실은 DNS의 전략적 중요성을 강조합니다. SPF, DKIM, DMARC와 같은 보안 확장은 DNS를 단순한 주소책이 아닌, 디지털 신원과 신뢰를 관리하는 플랫폼으로 격상시켰습니다.

현대 DNS의 도전 과제는 여전히 남아 있습니다. DNS over HTTPS/TLS의 보급은 프라이버시와 보안을 향상시키지만, 기존의 캐싱 및 모니터링 인프라에 혼란을 초래합니다. 역방향 DNS의 경우 IPv6로의 전환과 함께 관리의 복잡성이 증가하고 있으며, 특히 BYOIP(Bring Your Own IP) 환경에서의 권한 위임 문제는 새로운 운영 모델을 요구합니다.

미래의 DNS 해석 시스템은 인공지능과 머신러닝을 통한 예측적 해석, 블록체인 기반의 분산 신뢰 모델, 양자 내성 암호화를 통한 보안 강화 등으로 발전할 것입니다. 그러나 이러한 모든 발전의 중심에는 여전히 도메인 이름을 IP 주소로 변환한다는 근본적 목적이 자리할 것이며, 40년 전 설계된 기본 구조는 계속해서 그 탄력성을 입증할 것입니다.

네트워크 전문가에게 DNS 해석 메커니즘의 깊은 이해는 이제 선택이 아닌 필수입니다. 이는 단순한 기술적 지식을 넘어, 글로벌 디지털 경제의 흐름을 이해하고, 사이버 보안 위협에 대응하며, 새로운 인터넷 서비스를 설계하는 데 필수적인 기초가 됩니다. DNS는 더 이상 보이지 않는 인프라가 아닌, 디지털 세계의 혈관 시스템으로서 그 중요성이 계속해서 부각되고 있습니다.