---
layout: post
title: AspNet -  역할 기반 접근 제어
date: 2025-04-05 20:20:23 +0900
category: AspNet
---
# ASP.NET Core 사용자 역할(Role) 기반 접근 제어

## 핵심 개념 정리

- **RBAC**: 사용자를 역할(권한 그룹)로 분류하고, 각 역할에 리소스 접근 권한을 부여한다.
- **Claim과 Role**: ASP.NET Core는 **Claim 기반** 인증을 사용한다. 역할은 특별한 클레임 타입 `ClaimTypes.Role`로 표현한다.
  - 예: `new Claim(ClaimTypes.Role, "Admin")`
- **권장 흐름**
  1) 로그인 시 DB에서 사용자 역할 조회 → 2) 클레임에 `Role` 포함 → 3) `[Authorize(Roles="...")]` 혹은 정책 적용

---

## 최소 구성 흐름

```text
[로그인] → [DB에서 사용자/역할 조회] → [ClaimsPrincipal 구성(ClaimTypes.Role)] →
[SignIn 또는 JWT 발급] → [요청] → [UseAuthentication] → [UseAuthorization] → [Authorize 평가]
```

- 인증 실패: 401 Unauthorized
- 인증 성공이나 역할 부적합: 403 Forbidden

---

## Program.cs 기본 배선

### 쿠키 인증 + 역할 기반

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddAuthentication("MyCookie")
    .AddCookie("MyCookie", o =>
    {
        o.LoginPath = "/Account/Login";
        o.AccessDeniedPath = "/Account/Denied";
        o.SlidingExpiration = true;
        o.ExpireTimeSpan = TimeSpan.FromMinutes(30);
    });

builder.Services.AddAuthorization(); // 기본 정책/역할 평가

builder.Services.AddControllersWithViews();
var app = builder.Build();

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.MapDefaultControllerRoute();

app.Run();
```

### JWT 인증 + 역할 클레임 주의점

JWT 환경에서 **역할 클레임 타입 매핑**이 중요하다. 토큰에 `role`로 들어온 값을 `ClaimTypes.Role`로 평가하게 하려면 매핑을 맞춰야 한다.

```csharp
using Microsoft.IdentityModel.Tokens;
using System.Security.Claims;
using System.Text;

builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", o =>
    {
        o.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,

            ValidIssuer = "myapi",
            ValidAudience = "myclient",
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes("super_secret_jwt_key!123")),

            // 핵심: 토큰 내 role 클레임을 Role로 인식
            RoleClaimType = ClaimTypes.Role, // 기본값은 ClaimTypes.Role
            NameClaimType = ClaimTypes.Name
        };
        // 토큰에 "role": "Admin" 형태가 있다면 위 RoleClaimType대로 해석
    });

builder.Services.AddAuthorization();
```

토큰 생성 시에도 `ClaimTypes.Role` 혹은 `"role"` 중 **한 가지로 일관**되게 발급하라.

---

## 로그인 시 역할 부여 예제

### 쿠키 방식: ClaimsPrincipal 발급

```csharp
[HttpPost("/account/login")]
public async Task<IActionResult> Login(LoginModel model)
{
    // TODO: 사용자 검증 & DB 조회
    if (model.Username == "admin" && model.Password == "1234")
    {
        // 예: DB에서 roles = ["Admin", "Manager"] 조회했다고 가정
        var roles = new[] { "Admin", "Manager" };

        var claims = new List<Claim>
        {
            new Claim(ClaimTypes.Name, model.Username),
            new Claim("UserId", "42")
        };
        claims.AddRange(roles.Select(r => new Claim(ClaimTypes.Role, r)));

        var identity = new ClaimsIdentity(claims, "MyCookie");
        var principal = new ClaimsPrincipal(identity);
        await HttpContext.SignInAsync("MyCookie", principal);

        return Redirect("~/");
    }
    ModelState.AddModelError("", "로그인 실패");
    return View(model);
}
```

### JWT 방식: 토큰 발급

```csharp
[HttpPost("/api/login")]
public IActionResult JwtLogin([FromBody] LoginModel model)
{
    if (model.Username == "admin" && model.Password == "1234")
    {
        var roles = new[] { "Admin", "Manager" };
        var claims = new List<Claim>
        {
            new Claim(ClaimTypes.Name, model.Username),
            new Claim("UserId", "42"),
        };
        claims.AddRange(roles.Select(r => new Claim(ClaimTypes.Role, r)));

        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("super_secret_jwt_key!123"));
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        var token = new JwtSecurityToken(
            issuer: "myapi",
            audience: "myclient",
            claims: claims,
            expires: DateTime.UtcNow.AddHours(1),
            signingCredentials: creds
        );
        return Ok(new { token = new JwtSecurityTokenHandler().WriteToken(token) });
    }
    return Unauthorized();
}
```

---

## 역할 기반 접근 제어

### Controller/Razor

```csharp
[Authorize(Roles = "Admin")]
public IActionResult AdminOnly() => View();

[Authorize(Roles = "Admin,Manager")] // 둘 중 하나라도 보유하면 통과
public IActionResult Report() => View();

[AllowAnonymous]
public IActionResult Public() => View();
```

### Minimal API

```csharp
app.MapGroup("/admin")
   .RequireAuthorization(new AuthorizeAttribute { Roles = "Admin" })
   .MapGet("/dashboard", () => Results.Ok("Admin area"));
```

### 코드 내부 분기

```csharp
if (User.IsInRole("Admin"))
{
    // 관리자 전용 로직
}
```

---

## 정책 기반(Policy)으로 일반화하기

RBAC는 단순하지만, **시간·테넌트·조직·세부권한** 등 복잡 조건은 정책 기반이 유리하다.

```csharp
builder.Services.AddAuthorization(o =>
{
    o.AddPolicy("OnlyAdmin", p => p.RequireRole("Admin"));
    o.AddPolicy("HRDepartmentOnly", p =>
        p.RequireClaim("Department", "HR"));
    o.AddPolicy("ReportManagers", p =>
        p.RequireAssertion(ctx =>
            ctx.User.IsInRole("Manager") &&
            ctx.User.HasClaim("Scope", "Report.Read")));
});
```

컨트롤러/엔드포인트:

```csharp
[Authorize(Policy = "HRDepartmentOnly")]
public IActionResult HrPage() => View();
```

---

## 커스텀 AuthorizationHandler (세밀 제어)

예: 사용자 본인만 접근 허용하거나, 관리자는 예외적으로 허용.

```csharp
public class OwnerOrAdminRequirement : IAuthorizationRequirement { }

public class OwnerOrAdminHandler
  : AuthorizationHandler<OwnerOrAdminRequirement, int> // 리소스: int userId
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        OwnerOrAdminRequirement requirement,
        int resourceUserId)
    {
        if (context.User.IsInRole("Admin"))
        {
            context.Succeed(requirement);
            return Task.CompletedTask;
        }

        var myId = context.User.FindFirst("UserId")?.Value;
        if (int.TryParse(myId, out int uid) && uid == resourceUserId)
        {
            context.Succeed(requirement);
        }
        return Task.CompletedTask;
    }
}
```

등록/사용:

```csharp
builder.Services.AddSingleton<IAuthorizationHandler, OwnerOrAdminHandler>();
builder.Services.AddAuthorization(o =>
{
    o.AddPolicy("OwnerOrAdmin", p => p.AddRequirements(new OwnerOrAdminRequirement()));
});

// 컨트롤러에서:
[Authorize(Policy = "OwnerOrAdmin")]
public IActionResult Profile([FromRoute] int id) => View();
```

리소스를 전달하려면 `IAuthorizationService`를 직접 호출(리소스 기반)하는 패턴도 있다.

---

## ASP.NET Core Identity와 연계

Identity를 사용하면 **RoleManager/UserManager**로 역할을 DB로 관리한다.

### 서비스 구성

```csharp
builder.Services.AddDbContext<AppDbContext>(...);
builder.Services
    .AddIdentity<AppUser, IdentityRole>(o =>
    {
        o.Password.RequireNonAlphanumeric = false;
        o.User.RequireUniqueEmail = true;
    })
    .AddEntityFrameworkStores<AppDbContext>()
    .AddDefaultTokenProviders();

builder.Services.AddAuthentication()
    .AddCookie(IdentityConstants.ApplicationScheme);
builder.Services.AddAuthorization();
```

### 역할 시드(초기화)

```csharp
public static async Task SeedRolesAsync(IServiceProvider sp)
{
    using var scope = sp.CreateScope();
    var roleManager = scope.ServiceProvider.GetRequiredService<RoleManager<IdentityRole>>();
    var userManager = scope.ServiceProvider.GetRequiredService<UserManager<AppUser>>();

    foreach (var role in new[] { "Admin", "Manager", "User" })
    {
        if (!await roleManager.RoleExistsAsync(role))
            await roleManager.CreateAsync(new IdentityRole(role));
    }

    var admin = await userManager.FindByNameAsync("admin@example.com");
    if (admin != null && !await userManager.IsInRoleAsync(admin, "Admin"))
        await userManager.AddToRoleAsync(admin, "Admin");
}
```

앱 시작 시 호출:

```csharp
await SeedRolesAsync(app.Services);
```

### 요청 시 역할 확인

```csharp
var roles = await _userManager.GetRolesAsync(user); // DB 기반 역할 조회
```

---

## 클레임 변환으로 역할 동적 주입

외부 IdP(JWT)에 role이 없거나 사용자 메타에서 보강해야 할 때 `IClaimsTransformation`을 사용한다.

```csharp
public class RoleAugmentor : IClaimsTransformation
{
    private readonly IUserRoleService _svc;
    public RoleAugmentor(IUserRoleService svc) => _svc = svc;

    public async Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)
    {
        if (!principal.Identity?.IsAuthenticated ?? true) return principal;

        var userId = principal.FindFirst("UserId")?.Value;
        if (string.IsNullOrEmpty(userId)) return principal;

        var roles = await _svc.GetRolesAsync(userId);
        var id = (ClaimsIdentity)principal.Identity;
        foreach (var r in roles)
        {
            if (!principal.IsInRole(r))
                id.AddClaim(new Claim(ClaimTypes.Role, r));
        }
        return principal;
    }
}
```

등록:

```csharp
builder.Services.AddScoped<IClaimsTransformation, RoleAugmentor>();
```

---

## 다국적/다중 테넌트/계층형 역할 설계 팁

- **계층형 역할**: Admin > Manager > User 식의 상속을 DB 또는 정책 코드에서 해석.
- **테넌트 격리**: `TenantId` 클레임을 추가하고, 정책에서 `RequireClaim("TenantId", requestedTenant)`로 강제.
- **최소 권한 원칙(Least Privilege)**: 기본 권한은 최소로, 필요한 리소스에만 역할·권한을 할당.
- **권한 모델 일반화**: Role 외에 Permission(세부 권한) 테이블을 두고, 정책에서 `RequireClaim("perm", "Order.Delete")` 등으로 미세 제어.

---

## 에지 케이스 및 보안 체크리스트

| 항목 | 체크 포인트 | 코드/설명 |
|------|-------------|-----------|
| 토큰/쿠키 위변조 | JWT 서명 검증, 쿠키 HttpOnly+Secure | TokenValidationParameters, 쿠키 옵션 설정 |
| 역할 매핑 오류 | JWT의 `role` ↔ `ClaimTypes.Role` | `RoleClaimType`/발급 시 클레임 키 일관화 |
| 캐시된 역할 | IClaimsTransformation 결과 캐시 주의 | 사용자의 역할 변경 시 즉시 반영 필요하면 다시 로그인/토큰 재발급/캐시 무효화 |
| CORS/CSRF | JWT는 CSRF 영향 적음, 쿠키는 방어 | SameSite, Antiforgery 토큰 |
| 다중 인증 스킴 | `[Authorize(AuthenticationSchemes="...")]` | API와 웹을 분리해 스킴 명시 |
| 실패 응답 | 401/403 구분 | 미들웨어 순서, 정책 조건 점검 |

---

## 통합 샘플: API 그룹별 역할 보호

```csharp
var api = app.MapGroup("/api");

api.MapGroup("/admin")
   .RequireAuthorization(new AuthorizeAttribute { Roles = "Admin" })
   .MapGet("/users", () => Results.Ok("admin users"));

api.MapGroup("/report")
   .RequireAuthorization(new AuthorizeAttribute { Roles = "Admin,Manager" })
   .MapGet("/daily", () => Results.Ok("daily report"));

api.MapGet("/me", (ClaimsPrincipal user) =>
{
    var name = user.Identity?.Name ?? "anonymous";
    var roles = string.Join(",", user.Claims.Where(c => c.Type == ClaimTypes.Role).Select(c => c.Value));
    return Results.Ok(new { name, roles });
}).RequireAuthorization();
```

---

## 테스트 전략

- **단위 테스트**: `IAuthorizationService.AuthorizeAsync`를 모킹해 핸들러/정책을 검증.
- **통합 테스트**: `WebApplicationFactory`로 테스트 서버 구동 후 인증 헤더/쿠키 설정.
- **부하 테스트**: 역할 평가가 병목이 되지 않도록 캐싱/쿼리 최적화(단, 즉시성 요구가 낮을 때만).

---

## 요약

- 역할 기반 접근 제어는 **ClaimTypes.Role**에 의존한다. 발급/검증 **양쪽에서 일관성**이 중요하다.
- 단순 RBAC는 `[Authorize(Roles="...")]`, 복잡 조건은 **정책**(Claim/Assertion/Handler)로 확장하라.
- JWT에서는 **RoleClaimType 매핑**과 토큰 발급 시 역할 클레임 추가가 필수.
- Identity를 사용하면 **RoleManager/UserManager**로 역할을 DB에서 안전하게 관리할 수 있다.
- 동적/외부 역할 보강은 `IClaimsTransformation`, 자원 단위 세밀 제어는 **AuthorizationHandler**를 사용한다.

본 문서의 코드 스니펫을 조합하면, MVC/Razor/API/Minimal API 어디서든 **일관되고 확장 가능한 RBAC**를 구현할 수 있다.
