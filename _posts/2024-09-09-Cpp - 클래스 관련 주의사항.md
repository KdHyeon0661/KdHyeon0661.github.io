---
layout: post
title: C++ - 클래스 관련 주의사항
date: 2024-09-09 19:20:23 +0900
category: Cpp
---
# 클래스 설계에서 자주 하는 실수와 해결책

## 다중 상속의 함정

C++은 다중 상속을 지원하지만, 남용하면 복잡성과 버그를 초래할 수 있습니다. 특히 구현을 다중으로 상속받는 것은 상태 충돌, 불변식 위반, 자원 해제 순서 문제 등을 야기합니다.

```cpp
// 문제의 예: 구현 다중 상속
struct FileHandler { void read() { /* 파일 읽기 */ } };
struct NetworkHandler { void read() { /* 네트워크 읽기 */ } };
struct HybridHandler : FileHandler, NetworkHandler {}; // ❌ 어떤 read()를 호출할지?

// 해결: 인터페이스 다중 상속 + 컴포지션
struct IReadable { virtual void read() = 0; virtual ~IReadable() = default; };
struct FileReader : IReadable { void read() override { /* 파일 읽기 */ } };
struct NetworkReader : IReadable { void read() override { /* 네트워크 읽기 */ } };

class SmartReader {
    FileReader file_reader;
    NetworkReader network_reader;
public:
    void readFromFile() { file_reader.read(); }
    void readFromNetwork() { network_reader.read(); }
};
```

**핵심**: 다중 상속은 순수 가상 함수만 가진 인터페이스에 한정하고, 구현 공유는 컴포지션(멤버 객체)으로 해결하세요.

---

## 다이아몬드 문제와 가상 상속

다중 상속에서 가장 흔한 문제는 "다이아몬드 문제"입니다. 공통 베이스 클래스가 두 경로로 중복 상속되는 상황을 말합니다.

```cpp
// 다이아몬드 문제 발생
struct Animal { void speak() { /* ... */ } };
struct Dog : Animal {};
struct Cat : Animal {};
struct MythicalCreature : Dog, Cat {}; // ❌ Animal이 두 개 존재

MythicalCreature creature;
// creature.speak(); // 컴파일 오류: 어떤 Animal의 speak()를 호출할지 모호함
```

**해결책: 가상 상속**
```cpp
struct Animal { void speak() { /* ... */ } };
struct Dog : virtual Animal {};    // 가상 상속
struct Cat : virtual Animal {};    // 가상 상속
struct MythicalCreature : Dog, Cat {}; // ✅ Animal은 하나만 존재

MythicalCreature creature;
creature.speak(); // 정상 동작
```

**중요한 규칙**: 가상 상속에서는 **가장 파생된(가장 하위) 클래스가 가상 베이스 클래스의 생성자를 직접 호출해야 합니다**.

```cpp
struct Animal {
    Animal(int id) : id_(id) {}
    int id_;
};

struct Dog : virtual Animal {
    Dog() : Animal(1) {} // 호출되지만, 최종 값은...
};

struct Cat : virtual Animal {
    Cat() : Animal(2) {} // 호출되지만, 최종 값은...
};

struct MythicalCreature : Dog, Cat {
    MythicalCreature() : Animal(3), Dog(), Cat() {} 
    // ✅ Animal(3)이 최종 값이 됨
};
```

---

## 가상 소멸자 누락: 메모리 누수의 지름길

다형성을 사용하는 베이스 클래스에 가상 소멸자를 정의하지 않으면, 파생 클래스의 소멸자가 호출되지 않아 메모리 누수가 발생할 수 있습니다.

```cpp
// 위험한 코드
struct Base {
    // ~Base() { ... } // ❌ 비가상 소멸자
};

struct Derived : Base {
    int* data = new int[100];
    ~Derived() { delete[] data; } // ❌ 이 소멸자가 호출되지 않을 수 있음
};

int main() {
    Base* obj = new Derived();
    delete obj; // Base의 소멸자만 호출, Derived의 소멸자는 호출되지 않음
    // 메모리 누수 발생!
}
```

**해결책**: 폴리모픽(다형성을 사용하는) 베이스 클래스에는 항상 가상 소멸자를 선언하세요.

```cpp
// 안전한 코드
struct Base {
    virtual ~Base() = default; // ✅ 가상 소멸자
};

struct Derived : Base {
    int* data = new int[100];
    ~Derived() override { delete[] data; } // ✅ 항상 호출됨
};
```

**규칙**: 클래스에 가상 함수가 하나라도 있다면(다형성을 의도했다면), 소멸자도 반드시 가상으로 만들어야 합니다.

---

## Rule of Three/Five/Zero: 자원 관리의 기본 법칙

클래스가 자원(메모리, 파일 핸들, 네트워크 연결 등)을 직접 관리할 때, 복사와 이동 연산을 올바르게 정의하지 않으면 심각한 문제가 발생합니다.

### Rule of Three (C++98/03)
클래스가 다음 중 하나라도 직접 정의하면, 셋 모두 정의해야 합니다:
1. 소멸자
2. 복사 생성자
3. 복사 대입 연산자

### Rule of Five (C++11 이상)
Rule of Three에 다음을 추가:
4. 이동 생성자
5. 이동 대입 연산자

```cpp
// Rule of Five를 적용한 예
class Buffer {
    size_t size_;
    int* data_;
public:
    // 생성자
    Buffer(size_t size) : size_(size), data_(new int[size]) {}
    
    // 1. 소멸자
    ~Buffer() { delete[] data_; }
    
    // 2. 복사 생성자
    Buffer(const Buffer& other) : size_(other.size_), data_(new int[other.size_]) {
        std::copy(other.data_, other.data_ + size_, data_);
    }
    
    // 3. 복사 대입 연산자 (copy-and-swap 관용구)
    Buffer& operator=(const Buffer& other) {
        if (this != &other) {
            Buffer temp(other); // 복사 생성
            swap(*this, temp);  // 스왑
        }
        return *this;
    }
    
    // 4. 이동 생성자
    Buffer(Buffer&& other) noexcept 
        : size_(std::exchange(other.size_, 0)), 
          data_(std::exchange(other.data_, nullptr)) {}
    
    // 5. 이동 대입 연산자
    Buffer& operator=(Buffer&& other) noexcept {
        if (this != &other) {
            delete[] data_;
            size_ = std::exchange(other.size_, 0);
            data_ = std::exchange(other.data_, nullptr);
        }
        return *this;
    }
    
    friend void swap(Buffer& a, Buffer& b) noexcept {
        std::swap(a.size_, b.size_);
        std::swap(a.data_, b.data_);
    }
};
```

### Rule of Zero (가장 권장)
가장 좋은 방법은 자원 관리를 스마트 포인터나 표준 라이브러리 컨테이너에게 맡기는 것입니다.

```cpp
// Rule of Zero: 특별 멤버 함수를 직접 정의할 필요 없음
class SafeBuffer {
    std::vector<int> data_; // 자원 관리를 vector에게 맡김
public:
    SafeBuffer(size_t size) : data_(size) {}
    // 컴파일러가 생성하는 기본 복사/이동/소멸자가 안전하게 동작
};
```

**핵심 원칙**: 가능하면 Rule of Zero를 따르고, 불가피하게 자원을 직접 관리해야 할 때만 Rule of Five를 적용하세요.

---

## 객체 슬라이싱: 값 복사의 함정

객체를 값으로 전달하거나 저장할 때 발생하는 문제로, 파생 클래스 객체의 특수한 부분이 잘려나가 기본 클래스 부분만 남게 됩니다.

```cpp
struct Animal {
    virtual void speak() const { std::cout << "Animal sound\n"; }
    virtual ~Animal() = default;
};

struct Dog : Animal {
    void speak() const override { std::cout << "Woof!\n"; }
    void fetch() { std::cout << "Fetching...\n"; }
};

// 문제 발생 지점들
void byValue(Animal a) { a.speak(); }  // ❌ 슬라이싱 발생
void byReference(Animal& a) { a.speak(); } // ✅ 정상 동작

int main() {
    Dog dog;
    
    byValue(dog);     // "Animal sound" 출력 (Dog의 특성이 손실됨)
    byReference(dog); // "Woof!" 출력 (정상 동작)
    
    // 컨테이너에서의 슬라이싱
    std::vector<Animal> animals;
    animals.push_back(dog); // ❌ 슬라이싱 발생
    
    // 해결: 포인터나 참조 사용
    std::vector<std::unique_ptr<Animal>> animalPtrs;
    animalPtrs.push_back(std::make_unique<Dog>()); // ✅ 정상 동작
}
```

**해결책**:
1. 다형성을 의도한 객체는 항상 포인터나 참조로 전달하세요.
2. 컨테이너에 다형적 객체를 저장할 때는 포인터 컨테이너(`vector<unique_ptr<Base>>`)를 사용하세요.

---

## 생성자와 소멸자에서의 가상 함수 호출

생성자와 소멸자 내에서는 가상 함수가 정상적으로 동작하지 않습니다. 이는 객체의 생성과 소멸 과정에서 가상 함수 테이블이 완전히 설정되거나 파괴되기 때문입니다.

```cpp
class Base {
public:
    Base() { 
        initialize(); // ❌ 파생 클래스의 override 버전이 호출되지 않음
    }
    
    virtual void initialize() { 
        std::cout << "Base 초기화\n"; 
    }
    
    virtual ~Base() {
        cleanup(); // ❌ 마찬가지 문제
    }
    
    virtual void cleanup() {
        std::cout << "Base 정리\n";
    }
};

class Derived : public Base {
public:
    void initialize() override {
        std::cout << "Derived 초기화\n";
    }
    
    void cleanup() override {
        std::cout << "Derived 정리\n";
    }
};

int main() {
    Derived d; // "Base 초기화"만 출력됨
    // 소멸 시 "Base 정리"만 출력됨
}
```

**해결책: NVI(Non-Virtual Interface) 패턴**
```cpp
class SafeBase {
public:
    // 공개 인터페이스는 비가상
    void init() { 
        do_init(); // 내부 가상 함수 호출
    }
    
    virtual ~SafeBase() {
        do_cleanup();
    }
    
private:
    // 실제 구현은 가상 함수로
    virtual void do_init() {
        std::cout << "Base 초기화\n";
    }
    
    virtual void do_cleanup() {
        std::cout << "Base 정리\n";
    }
};

class SafeDerived : public SafeBase {
private:
    void do_init() override {
        std::cout << "Derived 초기화\n";
    }
    
    void do_cleanup() override {
        std::cout << "Derived 정리\n";
    }
};

int main() {
    SafeDerived d;
    d.init(); // "Derived 초기화" 출력됨
    // 소멸 시 "Derived 정리" 출력됨
}
```

---

## 이름 숨김(Name Hiding)

파생 클래스에서 베이스 클래스의 함수를 오버로드하지 않고 새 함수를 정의하면, 베이스 클래스의 동일한 이름을 가진 모든 함수가 숨겨집니다.

```cpp
class Base {
public:
    void process(int x) {
        std::cout << "Base::process(int)\n";
    }
    
    void process(double x) {
        std::cout << "Base::process(double)\n";
    }
};

class Derived : public Base {
public:
    // 이 선언으로 Base의 모든 process() 함수가 숨겨짐
    void process(const std::string& s) {
        std::cout << "Derived::process(string)\n";
    }
};

int main() {
    Derived d;
    d.process("hello"); // 정상 동작
    // d.process(10);    // ❌ 컴파일 오류: Base::process(int)가 숨겨짐
}
```

**해결책: `using` 선언 사용**
```cpp
class FixedDerived : public Base {
public:
    using Base::process; // ✅ Base의 process 함수들을 현재 스코프로 가져옴
    
    void process(const std::string& s) {
        std::cout << "Derived::process(string)\n";
    }
};

int main() {
    FixedDerived d;
    d.process(10);      // "Base::process(int)" 출력
    d.process(3.14);    // "Base::process(double)" 출력
    d.process("hello"); // "Derived::process(string)" 출력
}
```

---

## 현대 C++의 안전 장치 활용하기

### `override` 키워드
함수 재정의 의도를 명시적으로 표현하고, 실수로 시그니처가 다르게 작성되는 것을 방지합니다.

```cpp
class Base {
public:
    virtual void draw() const;
    virtual void resize(int width, int height);
};

class Derived : public Base {
public:
    void draw() const override;      // ✅ 명시적 재정의
    void resize(int width) override; // ❌ 컴파일 오류: 시그니처 불일치
};
```

### `final` 키워드
더 이상의 재정의를 금지합니다.

```cpp
class Base {
public:
    virtual void cannotOverride() final; // 이 함수는 재정의 불가
};

class Derived : public Base {
public:
    void cannotOverride() override; // ❌ 컴파일 오류
};
```

### `explicit` 키워드
의도치 않은 암시적 변환을 방지합니다.

```cpp
class SmartString {
    std::string data_;
public:
    explicit SmartString(const char* str) : data_(str) {}
    // explicit 없으면: SmartString s = "hello"; 가 가능
    // explicit 있으면: SmartString s("hello"); 만 가능
};
```

### `noexcept` 키워드
함수가 예외를 발생시키지 않음을 명시하고, 컴파일러의 최적화를 돕습니다.

```cpp
class Optimized {
public:
    void safeOperation() noexcept { // 예외가 절대 발생하지 않음
        // 예외 불가능한 연산만 수행
    }
    
    Optimized(Optimized&& other) noexcept // 이동 연산은 대체로 noexcept
        : data_(std::move(other.data_)) {}
};
```

---

## 정적 초기화 순서 문제

서로 다른 소스 파일에 있는 전역/정적 객체들은 초기화 순서가 보장되지 않습니다. 한 객체가 다른 객체를 사용하는 경우 문제가 발생할 수 있습니다.

```cpp
// file1.cpp
extern int global_value;
struct Initializer {
    Initializer() {
        global_value = 42; // ❌ global_value가 아직 초기화되지 않았을 수 있음
    }
} init;

// file2.cpp
int global_value = 10; // 초기화 순서 불확실
```

**해결책: 함수 내 정적 변수 사용**
```cpp
int& get_global_value() {
    static int value = 10; // ✅ 첫 호출 시 안전하게 초기화 (C++11부터 스레드 안전)
    return value;
}

struct SafeInitializer {
    SafeInitializer() {
        get_global_value() = 42; // ✅ 항상 초기화된 값에 접근
    }
};
```

**C++17의 `inline static`**
```cpp
class Config {
public:
    inline static int max_connections = 100; // 헤더에서 바로 초기화 가능
};
```

---

## 결론: 안전한 클래스 설계를 위한 핵심 원칙

1. **다중 상속은 신중하게**: 구현 다중 상속은 피하고, 인터페이스 다중 상속만 사용하세요. 다이아몬드 문제가 예상되면 가상 상속을 적용하고, 최하위 클래스에서 가상 베이스를 초기화하세요.

2. **가상 소멸자는 필수**: 다형성을 사용하는 모든 베이스 클래스에는 가상 소멸자를 선언하세요.

3. **자원 관리의 원칙**: 가능하면 Rule of Zero를 따르고(스마트 포인터/컨테이너 사용), 직접 관리해야 한다면 Rule of Five를 완전히 준수하세요.

4. **슬라이싱을 경계하세요**: 다형적 객체는 값이 아닌 참조나 포인터로 전달하고 저장하세요.

5. **생성자/소멸자에서 가상 함수 호출 금지**: NVI 패턴을 사용하여 초기화와 정리 로직을 안전하게 구현하세요.

6. **현대 C++ 기능을 적극 활용**: `override`, `final`, `explicit`, `noexcept` 키워드로 코드의 의도를 명확히 하고 실수를 방지하세요.

7. **정적 초기화는 안전하게**: 전역/정적 객체의 초기화 순서 문제를 피하려면 함수 내 정적 변수나 `inline static`을 사용하세요.

클래스 설계는 단순히 문법적으로 맞는 코드를 작성하는 것을 넘어, 안전성, 유지보수성, 성능을 종합적으로 고려해야 합니다. 이러한 실수 패턴들을 이해하고 올바른 해결책을 적용하면 더 견고하고 예측 가능한 C++ 코드를 작성할 수 있습니다.