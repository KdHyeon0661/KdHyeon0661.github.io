---
layout: post
title: C++ - 클래스 관련 주의사항
date: 2024-09-09 19:20:23 +0900
category: Cpp
---
# 클래스 설계에서 자주 하는 실수들

## 1) 다중 상속(MI) — “가능하다고 해도 필요한가?”

### 1.1 개념 & 정상 동작 예

```cpp
#include <iostream>
using namespace std;

struct A { void showA() const { cout << "A\n"; } };
struct B { void showB() const { cout << "B\n"; } };

struct C : A, B { /* 두 인터페이스의 합성 */ };

int main() {
    C c;
    c.showA();  // A
    c.showB();  // B
}
```

- **문제는 아님**. 하지만 **공통 베이스가 겹치는 순간** 다이아몬드 문제가 발생.

### 1.2 실수 #1 — 구현 다중 상속 남발
- 서로 다른 구현을 물려받아 상태/불변식 충돌, 두 베이스의 수명/자원 해제 순서 문제.
- **대안**: 인터페이스 다중 상속(순수 가상만 보유) + **컴포지션**으로 구현 공유.

---

## 2) 다이아몬드(Diamond)와 가상 상속(virtual inheritance)

### 2.1 문제 재현

```cpp
#include <iostream>
using namespace std;

struct Animal { void speak() const { cout << "Animal 소리\n"; } };
struct Dog : Animal {};
struct Cat : Animal {};
struct Hybrid : Dog, Cat {};

int main(){
    Hybrid h;
    // h.speak(); // ❌ 모호성: Animal이 두 번 상속되어 경로가 2개
}
```

- `Hybrid`는 `Dog→Animal`과 `Cat→Animal` 두 경로로 **중복 상속**.

### 2.2 교정: 가상 상속

```cpp
#include <iostream>
using namespace std;

struct Animal { void speak() const { cout << "Animal 소리\n"; } };
struct Dog : virtual Animal {};
struct Cat : virtual Animal {};
struct Hybrid : Dog, Cat {};

int main(){
    Hybrid h;
    h.speak(); // ✅ Animal은 단 1회 포함
}
```

### 2.3 실수 #2 — 가상 상속에서 “누가 `Animal`을 초기화하는가?”

- **규칙**: 가상 베이스(`Animal`)의 **생성자 인자 전달은 최하위 파생 클래스**가 책임.

```cpp
struct Animal {
    explicit Animal(int id) : id(id) {}
    int id;
};

struct Dog : virtual Animal {
    Dog() : Animal(0) {}   // ✅ 임시로 호출해도 최종 값은...
};

struct Cat : virtual Animal {
    Cat() : Animal(0) {}
};

struct Hybrid : Dog, Cat {
    Hybrid() : Animal(42), Dog(), Cat() {} // ✅ 최하위에서 결정
};
```

> 가상 상속에서는 **하위(가장 파생된 클래스)** 의 이니셜라이저가 **유일한 최종 초기화 지점**이다.

---

## 3) 가상 소멸자 누락 — 누수의 지름길

### 3.1 재현

```cpp
struct Base { ~Base(){ /* 비가상 */ } }; // ❌
struct Derived : Base { ~Derived(){ /* 자원 해제 */ } };

int main(){
    Base* p = new Derived();
    delete p; // ❌ Derived 소멸자 호출되지 않을 수 있음 → 누수
}
```

### 3.2 교정

```cpp
struct Base { virtual ~Base() = default; }; // ✅
```

> **폴리모픽 베이스**(가상 함수 하나라도 보유)에는 **반드시 가상 소멸자**.

---

## 4) Rule of Three/Five/Zero — 복사·이동·수명 규약

### 4.1 실수 #3 — 소유 리소스를 가진데 복사/대입/소멸 불일치

```cpp
#include <algorithm>

struct ResourceHolder {
    int* data;
    ResourceHolder(int v) : data(new int(v)) {}
    ~ResourceHolder(){ delete data; }

    // ❌ 복사/대입 미정의 → 얕은 복사로 이중 해제 위험
};
```

### 4.2 교정: Rule of Five (C++11~)

```cpp
struct ResourceHolder {
    int* data{};
    ResourceHolder(int v) : data(new int(v)) {}
    ~ResourceHolder(){ delete data; }

    ResourceHolder(const ResourceHolder& o)             // 복사
      : data(new int(*o.data)) {}
    ResourceHolder& operator=(const ResourceHolder& o){ // 복사 대입
        if(this!=&o){
            ResourceHolder tmp(o);
            std::swap(data, tmp.data);
        }
        return *this;
    }
    ResourceHolder(ResourceHolder&& o) noexcept         // 이동
      : data(o.data) { o.data=nullptr; }
    ResourceHolder& operator=(ResourceHolder&& o) noexcept {
        if(this!=&o){
            delete data;
            data = o.data;
            o.data=nullptr;
        }
        return *this;
    }
};
```

### 4.3 더 나은 교정: Rule of Zero

```cpp
#include <memory>
struct Holder {
    std::unique_ptr<int> data;
    explicit Holder(int v) : data(std::make_unique<int>(v)) {}
    // 복사 금지/이동 기본 제공, 소멸 자동 — 특별 멤버 함수 정의 불필요
};
```

---

## 5) 다형성에서 값 전달(by value) — 슬라이싱(slicing)

### 5.1 재현

```cpp
#include <iostream>
using namespace std;

struct Animal { virtual void speak() const { cout<<"Animal\n"; } virtual ~Animal()=default; };
struct Dog    : Animal { void speak() const override { cout<<"Dog\n"; } };

void doSpeak_bad(Animal a) { a.speak(); }      // ❌ slicing
void doSpeak_ok (Animal& a){ a.speak(); }      // ✅ 참조
void doSpeak_ok2(Animal* a){ a->speak(); }     // ✅ 포인터

int main(){
    Dog d;
    doSpeak_bad(d);  // Animal로 복사되어 Animal::speak
    doSpeak_ok(d);   // Dog::speak
}
```

### 5.2 원인과 교정
- **원인**: 값 전달 시 **객체의 정적 타입으로 복사**되며 파생 부분이 잘림.  
- **교정**: 다형성 대상은 **참조/포인터**로 전달하고, 필요 시 **소유권**은 스마트 포인터로 표현.

---

## 6) 기본 생성자 누락 — 파생 이니셜라이즈 실패

### 6.1 재현

```cpp
struct Base {
    Base(int x) { /*...*/ }   // 기본 생성자 없음
};

struct Child : Base {
    Child() /* : Base()? */ { } // ❌ 컴파일 오류
};
```

### 6.2 교정

```cpp
struct Child : Base {
    Child() : Base(10) { } // ✅ 명시적 호출
};
```

---

## 7) 의도치 않은 객체 슬라이싱 — 대입/컨테이너

```cpp
#include <vector>

struct B{ virtual ~B()=default; };
struct D: B{ int x=1; };

int main(){
    std::vector<B> v; // ❌ 값 컨테이너에 폴리모픽 타입
    // v.push_back(D{});    // D → B로 슬라이스
}
```

**교정**: `std::vector<std::unique_ptr<B>>` 또는 `std::vector<std::shared_ptr<B>>`로 **포인터 컨테이너** 사용.

---

## 8) 이름 숨김(name hiding)과 오버로드 세트 소실

### 8.1 재현

```cpp
struct Base { void f(int){} };
struct Der  : Base { void f(double){} }; // Base::f(int)가 숨겨짐
```

### 8.2 교정 — `using`으로 노출

```cpp
struct Der : Base {
    using Base::f;       // ✅ 오버로드 세트 복원
    void f(double){}
};
```

---

## 9) 생성자/소멸자에서의 가상 호출 — 동적 디스패치 정지

### 9.1 재현

```cpp
#include <iostream>
struct B {
    B(){ f(); }                  // ❌ B::f만 호출
    virtual void f(){ std::cout<<"B::f\n"; }
    virtual ~B(){ f(); }         // ❌ 여기서도 B::f
};
struct D : B {
    void f() override { std::cout<<"D::f\n"; }
};
int main(){ D d; } // 출력은 B::f, B::f
```

### 9.2 교정 — NVI(Non-Virtual Interface)

```cpp
struct Algo {
    void run(){ pre(); step(); post(); } // public 비가상
private:
    void pre(){ /*검증*/ }
    virtual void step() = 0;             // 확장 지점
    void post(){ /*정리*/ }
};
```

---

## 10) `override`/`final`/`explicit`를 잊는 실수

### 10.1 `override` 누락 → 오타/시그니처 불일치 미검출

```cpp
struct B { virtual void foo(int){} };
struct D : B { void foo(double){} }; // ❌ 재정의 아님, 숨김 발생
```

**교정**:

```cpp
struct D : B { void foo(int) override {} }; // ✅
```

### 10.2 `final`로 더 이상의 재정의 금지

```cpp
struct D : B {
    void foo(int) override final {}
};
```

### 10.3 `explicit`로 깜짝 생성 차단

```cpp
struct Meter {
    explicit Meter(double); // ✅
};
```

---

## 11) 이동 연산의 `noexcept` 누락 — 성능 저하(컨테이너 재할당)

```cpp
struct Big {
    Big(Big&&) /*noexcept(false) by default*/ { /*...*/ }
    // ❌ move가 예외 가능이면 vector가 move 대신 copy를 택할 수 있음
};

// ✅ 권장
struct Fast {
    Fast(Fast&&) noexcept { /*...*/ }
    Fast& operator=(Fast&&) noexcept { /*...*/ return *this; }
};
```

---

## 12) 정적 초기화 순서 문제 & 안전한 정적

### 12.1 문제

- 서로 다른 번역 단위의 전역/정적 객체 간 **초기화 순서 비결정**으로 **미초기화 참조** 발생.

### 12.2 교정

- **함수 지역 정적**(C++11~ thread-safe 초기화 보장):

```cpp
const std::string& name(){
    static const std::string n = "app"; // 첫 호출 때 안전 초기화
    return n;
}
```

- C++17 `inline static` 멤버:

```cpp
struct Config {
    inline static int max_conn = 256; // 헤더만으로 정의
};
```

---

## 13) RAII 미사용, `delete` / `delete[]` 혼동

### 13.1 실수

```cpp
int* a = new int[10];
delete a;      // ❌ delete[] 필요
```

### 13.2 교정

```cpp
auto p = std::make_unique<int[]>(10); // ✅ 배열도 스마트 포인터
// 소멸 자동, delete[] 걱정 불필요
```

---

## 14) 연산자/해시/정렬의 계약 위반

### 14.1 실수 — `==`와 `<`/`<=>`가 서로 다른 개념

- 컨테이너 키·정렬에서 **반사/대칭/추이성** 불만족 시 **UB** 위험.

### 14.2 교정 — `operator<=>`(C++20)로 자동화

```cpp
#include <compare>
struct Point {
    int x, y;
    auto operator<=>(const Point&) const = default; // ==와 비교 일관
};
```

해시를 쓰면 **동치인 두 값의 해시가 동일**해야 한다:
$$
a == b \implies \text{hash}(a) = \text{hash}(b)
$$

---

## 15) 인터페이스 다중 상속 — 안전한 설계 가이드

- **인터페이스(순수 가상)만 다중 상속**: 데이터 멤버 없음 → 다이아몬드라도 충돌 적음.  
- 구현 공유는 **컴포지션**으로.  
- 공통 베이스가 필요한 진짜 다이아몬드 구조면 **가상 상속 + 최하위 초기화**를 준수.

```cpp
struct Drawable{ virtual void draw() = 0; virtual ~Drawable()=default; };
struct Clickable{ virtual void onClick() = 0; virtual ~Clickable()=default; };

class Button : public Drawable, public Clickable {
public:
    void draw() override    { /*...*/ }
    void onClick() override { /*...*/ }
};
```

---

## 16) 사례 통합: “하이브리드 위젯” — 잘못된 설계 vs 교정 설계

### 16.1 잘못된 설계

```cpp
#include <iostream>
using namespace std;

struct View { virtual void render(){ cout<<"View\n"; } ~View(){} }; // ❌ 비가상 소멸자
struct Border { void drawBorder(){ cout<<"Border\n"; } };
struct Shadow { void drawShadow(){ cout<<"Shadow\n"; } };

struct Hybrid : View, Border, Shadow {
    int* raw = new int(42);                 // ❌ 수동 리소스
    void render() override { drawBorder(); drawShadow(); cout<<"Hybrid\n"; }
    // 복사/이동/대입/소멸 규약 없음 → 누수/이중해제/슬라이싱 위험
};
```

### 16.2 교정 설계

```cpp
#include <iostream>
#include <memory>
using namespace std;

struct View {
    virtual void render(){ cout<<"View\n"; }
    virtual ~View() = default;              // ✅ 가상 소멸자
};

struct IBorder { virtual void border() = 0; virtual ~IBorder()=default; };
struct IShadow { virtual void shadow() = 0; virtual ~IShadow()=default; };

struct Border : IBorder { void border() override { cout<<"Border\n"; } };
struct Shadow : IShadow { void shadow() override { cout<<"Shadow\n"; } };

class Hybrid : public View {
    Border  border_;
    Shadow  shadow_;
    std::unique_ptr<int> data_ = std::make_unique<int>(42); // ✅ RAII
public:
    void render() override {
        border_.border();
        shadow_.shadow();
        cout<<"Hybrid\n";
    }
    // Rule of Zero: 특별 멤버 함수 정의 불필요
};
```

- 다중 상속은 **인터페이스만**(IBorder/IShadow).  
- 구현 공유는 **컴포지션**(Border/Shadow 멤버).  
- 베이스(View)는 **가상 소멸자**.  
- 자원은 **스마트 포인터**.

---

## 17) 성능/안전 관점 비용 모델(개념)

- **슬라이싱**으로 인한 다형성 상실 비용:
$$
\text{Cost}_{\text{slicing}} \approx \text{BehaviorLoss} + \text{DebugTime} + \text{BugRisk}
$$

- **가상 디스패치**의 평균 비용(간접 분기):
$$
T_{\text{virtual}} \approx T_{\text{indirect\_load}} + T_{\text{branch\_predict\_miss}} + T_{\text{callee}}
$$

핫 루프에서 비용이 문제면 **정적 다형성(템플릿/CRTP)**, 인라이닝, 레이아웃 최적화 고려.

---

## 18) 실전 점검표

- [ ] 폴리모픽 베이스에 **가상 소멸자** 있는가?  
- [ ] 다중 상속은 **인터페이스로만** 사용했는가?  
- [ ] 다이아몬드면 **가상 상속** + **최하위 초기화**를 지켰는가?  
- [ ] 자원 소유 타입은 **Rule of Zero/Five**를 지키는가?  
- [ ] 다형성 인수/컨테이너는 **참조/포인터**/스마트 포인터인가?  
- [ ] 생성/소멸 중 **가상 호출 금지**(NVI 도입)인가?  
- [ ] `override`/`final`/`explicit`/`noexcept` 적절히 사용했는가?  
- [ ] 정적/전역 초기화는 **안전한 패턴**(함수 지역 정적/`inline static`)인가?  
- [ ] `delete`/`delete[]` 혼용이 없는가?  
- [ ] 연산자/해시/정렬의 **계약**(반사/대칭/추이성/동치-해시 일치)을 지켰는가?

---

## 19) 빠른 레퍼런스 스니펫

```cpp
// 폴리모픽 베이스 규약
struct Base {
    virtual ~Base() = default;
    Base() = default;
    Base(const Base&)            = default;
    Base& operator=(const Base&) = default;
    Base(Base&&)                 = default;
    Base& operator=(Base&&)      = default;
};

// 슬라이싱 방지: 컨테이너
std::vector<std::unique_ptr<Base>> v; // ✅

// 이름 숨김 교정
struct D : B { using B::f; void f(double); };

// 안전한 싱글턴성 정적
const std::string& app_name(){
    static const std::string n = "myapp";
    return n;
}
```

---

## 한눈 요약 체크리스트

- [ ] 다중 상속은 **인터페이스(순수 가상)** 에 한정. 구현 다중 상속은 신중.  
- [ ] 다이아몬드 구조는 **가상 상속**으로 단일 베이스 보장 + **최하위 클래스**에서 베이스를 초기화.  
- [ ] **폴리모픽 베이스**에는 늘 **가상 소멸자**.  
- [ ] 자원 소유 타입은 **Rule of Five**(혹은 **Zero**).  
- [ ] 다형성 인수는 **값 전달 금지**(슬라이싱); **참조/포인터** 사용.  
- [ ] 생성자/소멸자에서 **가상 호출 금지** → **NVI**로 구조화.  
- [ ] `override`/`final`/`explicit` 적극 사용.  
- [ ] 이동 연산은 가능하면 **`noexcept`**.  
- [ ] 정적/전역 초기화는 **정적 초기화 순서 문제** 주의(함수 지역 정적·`inline static`).  
- [ ] `delete` vs `delete[]` 구분, `new[]`에는 `delete[]`.

---

## 결론

- 다중 상속/다이아몬드는 **가능하면 피하고**, 불가피하면 **가상 상속+최하위 초기화**를 준수하라.  
- 다형성 타입은 **가상 소멸자·참조/포인터 전달**이 기본기.  
- 자원은 **RAII**로 관리하고, 복사/이동/대입/소멸의 **규약**(Rule of Zero/Five)을 지켜라.  
- `override`/`final`/`explicit`/`noexcept`/`using` 등 **현대 C++ 안전장치**를 적극 활용하라.  
- 성능이 문제라면 **정적 다형성**·인라이닝·레이아웃 최적화로 보완하고, **계약을 깨지 않는 설계**로 유지보수 비용을 최소화하라.