---
layout: post
title: 파이썬 심화 - 클래스와 객체 (2)
date: 2025-11-30 16:25:23 +0900
category: 파이썬 심화
---
# 클래스와 객체 (2)

파이썬의 객체 지향 프로그래밍은 단순한 클래스 정의를 넘어 속성 접근 제어, 상속 체계, 동적 속성 생성 등 고급 기법들을 제공합니다. 이러한 기능들을 효과적으로 활용하면 더 견고하고 유연한 코드를 작성할 수 있습니다.

## 관리 속성 만들기: 속성 접근의 완전한 제어

관리 속성은 속성 접근(get, set, delete)에 사용자 정의 로직을 추가할 수 있는 강력한 기능입니다. 이를 통해 데이터 검증, 계산된 값, 접근 로깅 등을 구현할 수 있습니다.

### @property 데코레이터를 이용한 기본적인 관리 속성

```python
class Temperature:
    """온도를 관리하는 클래스"""
    
    def __init__(self, celsius=0):
        self._celsius = celsius  # 내부 저장 변수는 관례적으로 _로 시작
    
    @property
    def celsius(self):
        """섭씨 온도 속성 (getter)"""
        print(f"섭씨 온도 읽기: {self._celsius}°C")
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        """섭씨 온도 설정 (setter)"""
        if value < -273.15:
            raise ValueError("절대 영도(-273.15°C)보다 낮을 수 없습니다.")
        print(f"섭씨 온도 설정: {value}°C")
        self._celsius = value
    
    @celsius.deleter
    def celsius(self):
        """섭씨 온도 삭제 (deleter)"""
        print("섭씨 온도 삭제 (기본값으로 초기화)")
        self._celsius = 0
    
    @property
    def fahrenheit(self):
        """화씨 온도 (계산된 속성)"""
        f = (self._celsius * 9/5) + 32
        print(f"화씨 온도 계산: {self._celsius}°C → {f}°F")
        return f
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        """화씨 온도로부터 섭씨 계산 (setter)"""
        c = (value - 32) * 5/9
        print(f"화씨 온도 설정: {value}°F → {c}°C")
        self.celsius = c  # 검증 로직이 있는 setter 사용

# 사용 예제
print("1. 기본적인 @property 사용")
print("=" * 60)

temp = Temperature(25)
print(f"초기 섭씨: {temp.celsius}°C")
print(f"계산된 화씨: {temp.fahrenheit:.1f}°F")

# 속성 변경
temp.celsius = 30
print(f"변경된 섭씨: {temp.celsius}°C")
print(f"변경된 화씨: {temp.fahrenheit:.1f}°F")

# 화씨로 설정
temp.fahrenheit = 100
print(f"100°F 설정 후 섭씨: {temp.celsius:.1f}°C")

# 잘못된 값 설정 시도
try:
    temp.celsius = -300
except ValueError as e:
    print(f"오류 발생: {e}")

# 속성 삭제
del temp.celsius
print(f"삭제 후 섭씨: {temp.celsius}°C")
```

### 고급: property() 함수를 이용한 동적 관리 속성

```python
class Account:
    """은행 계좌 클래스 (동적 속성 관리)"""
    
    def __init__(self, owner, balance=0):
        self.owner = owner
        self._balance = balance
        self.transaction_history = []
        
        # 동적으로 속성 생성
        self._create_managed_attributes()
    
    def _create_managed_attributes(self):
        """동적으로 관리 속성 생성"""
        
        # 잔고 getter
        def get_balance(account):
            print(f"잔고 조회: {account.owner}님의 잔고는 {account._balance:,}원")
            return account._balance
        
        # 잔고 setter
        def set_balance(account, value):
            if value < 0:
                raise ValueError("잔고는 음수일 수 없습니다.")
            old_balance = account._balance
            account._balance = value
            account.transaction_history.append({
                'type': '잔고조정',
                '이전잔고': old_balance,
                '새잔고': value,
                '변동': value - old_balance,
                'timestamp': '2024-01-15 10:00:00'
            })
            print(f"잔고 변경: {old_balance:,}원 → {value:,}원")
        
        # 잔고 deleter
        def del_balance(account):
            if account._balance > 0:
                raise ValueError("잔고가 남아있어 삭제할 수 없습니다.")
            print(f"계좌 삭제: {account.owner}님의 계좌")
            account._balance = 0
        
        # property 객체 생성
        balance_property = property(
            fget=lambda self: get_balance(self),
            fset=lambda self, value: set_balance(self, value),
            fdel=lambda self: del_balance(self),
            doc="계좌 잔고 (동적으로 생성된 속성)"
        )
        
        # 클래스에 속성 추가
        type(self).balance = balance_property
    
    # 달러 잔고 속성 (계산된 속성)
    @property
    def balance_usd(self):
        """달러 잔고 (환율 적용)"""
        exchange_rate = 1300  # 1 USD = 1300 KRW 가정
        usd_balance = self._balance / exchange_rate
        return round(usd_balance, 2)
    
    @balance_usd.setter
    def balance_usd(self, usd_amount):
        """달러로 잔고 설정"""
        exchange_rate = 1300
        self.balance = usd_amount * exchange_rate  # 관리 속성의 setter 사용
    
    def deposit(self, amount):
        """입금"""
        if amount <= 0:
            raise ValueError("입금액은 0보다 커야 합니다.")
        self.balance += amount  # 관리 속성의 setter 사용
        self.transaction_history.append({
            'type': '입금',
            '금액': amount,
            '후잔고': self._balance,
            'timestamp': '2024-01-15 10:30:00'
        })
        return self.balance
    
    def withdraw(self, amount):
        """출금"""
        if amount <= 0:
            raise ValueError("출금액은 0보다 커야 합니다.")
        if amount > self.balance:
            raise ValueError("잔고가 부족합니다.")
        self.balance -= amount  # 관리 속성의 setter 사용
        self.transaction_history.append({
            'type': '출금',
            '금액': amount,
            '후잔고': self._balance,
            'timestamp': '2024-01-15 10:35:00'
        })
        return self.balance

print("\n2. 동적 관리 속성 생성")
print("=" * 60)

# 계좌 생성
account = Account("김철수", 1000000)
print(f"계좌 소유자: {account.owner}")
print(f"초기 잔고: {account.balance:,}원")
print(f"달러 잔고: ${account.balance_usd}")

# 입금
account.deposit(500000)
print(f"입금 후 잔고: {account.balance:,}원")

# 달러로 설정
account.balance_usd = 2000
print(f"2000달러 설정 후 원화 잔고: {account.balance:,}원")
print(f"현재 달러 잔고: ${account.balance_usd}")

# 거래 기록 출력
print(f"\n거래 기록 ({len(account.transaction_history)}건):")
for i, transaction in enumerate(account.transaction_history, 1):
    print(f"  {i}. {transaction['type']}: {transaction.get('금액', transaction.get('변동', 0)):,}원")
```

### 속성 접근 로깅과 감시 시스템

```python
class MonitoredAttribute:
    """속성 접근을 모니터링하는 디스크립터"""
    
    def __init__(self, name=None):
        self.name = name
        self.access_log = []
    
    def __set_name__(self, owner, name):
        if self.name is None:
            self.name = name
        self.private_name = '_' + self.name
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        
        value = getattr(obj, self.private_name)
        
        # 접근 로깅
        log_entry = {
            'type': 'get',
            'attribute': self.name,
            'value': value,
            'timestamp': '2024-01-15 11:00:00',
            'caller': 'user'  # 실제로는 traceback 모듈로 호출자 정보 추적
        }
        self.access_log.append(log_entry)
        print(f"[모니터링] 속성 읽기: {self.name} = {value}")
        
        return value
    
    def __set__(self, obj, value):
        old_value = getattr(obj, self.private_name, None)
        setattr(obj, self.private_name, value)
        
        # 변경 로깅
        log_entry = {
            'type': 'set',
            'attribute': self.name,
            'old_value': old_value,
            'new_value': value,
            'timestamp': '2024-01-15 11:00:00',
            'caller': 'user'
        }
        self.access_log.append(log_entry)
        print(f"[모니터링] 속성 변경: {self.name} = {old_value} → {value}")
    
    def get_access_stats(self):
        """접근 통계"""
        total_accesses = len(self.access_log)
        gets = sum(1 for log in self.access_log if log['type'] == 'get')
        sets = sum(1 for log in self.access_log if log['type'] == 'set')
        
        return {
            'total': total_accesses,
            'gets': gets,
            'sets': sets,
            'last_access': self.access_log[-1] if self.access_log else None
        }

class UserProfile:
    """사용자 프로필 (모니터링된 속성 사용)"""
    
    # 모니터링된 속성들
    username = MonitoredAttribute()
    email = MonitoredAttribute()
    age = MonitoredAttribute()
    
    def __init__(self, username, email, age):
        self.username = username
        self.email = email
        self.age = age
        self._is_active = True  # 모니터링되지 않는 일반 속성
    
    @property
    def is_active(self):
        """활성 상태 (일반 프로퍼티)"""
        return self._is_active
    
    @is_active.setter
    def is_active(self, value):
        """활성 상태 설정"""
        if not isinstance(value, bool):
            raise ValueError("활성 상태는 불리언이어야 합니다.")
        self._is_active = value

print("\n3. 속성 접근 모니터링 시스템")
print("=" * 60)

# 사용자 프로필 생성
user = UserProfile("kimcheolsu", "kim@example.com", 30)

# 속성 접근
print(f"사용자명: {user.username}")
print(f"이메일: {user.email}")
print(f"나이: {user.age}")

# 속성 변경
user.age = 31
user.email = "newkim@example.com"

# 통계 확인
print("\n속성 접근 통계:")
for attr_name in ['username', 'email', 'age']:
    attr = getattr(UserProfile, attr_name)
    stats = attr.get_access_stats()
    print(f"  {attr_name}: 총 {stats['total']}회 접근 (읽기: {stats['gets']}, 쓰기: {stats['sets']})")

# 모니터링 로그 출력
print("\n이메일 속성 접근 로그:")
email_attr = UserProfile.email
for i, log in enumerate(email_attr.access_log[:3], 1):  # 처음 3개만
    print(f"  {i}. {log['type']}: {log['old_value'] if 'old_value' in log else ''} → {log['new_value'] if 'new_value' in log else log['value']}")
```

## 부모 클래스의 메소드 호출: 상속 체인의 올바른 활용

상속 체인에서 부모 클래스의 메소드를 올바르게 호출하는 방법은 다중 상속, 믹스인 클래스, 메소드 오버라이딩 등 고급 객체 지향 패턴의 핵심입니다.

### 기본적인 super() 사용법

```python
class Animal:
    """동물 기본 클래스"""
    
    def __init__(self, name, species):
        print(f"Animal.__init__() 호출: {name} ({species})")
        self.name = name
        self.species = species
        self.age = 0
    
    def speak(self):
        """소리 내기"""
        return f"{self.name}이(가) 소리를 냅니다."
    
    def get_info(self):
        """정보 출력"""
        return f"이름: {self.name}, 종: {self.species}, 나이: {self.age}살"

class Mammal(Animal):
    """포유류 클래스"""
    
    def __init__(self, name, species, fur_color):
        # 부모 클래스의 __init__ 호출
        print(f"Mammal.__init__() 호출: {name}")
        super().__init__(name, species)
        self.fur_color = fur_color
        self.is_warm_blooded = True
    
    def speak(self):
        # 부모 클래스의 speak 호출 및 확장
        parent_speak = super().speak()
        return f"{parent_speak} 포유류 특유의 소리입니다."
    
    def get_info(self):
        # 부모 클래스의 get_info 호출 및 확장
        parent_info = super().get_info()
        return f"{parent_info}, 털색: {self.fur_color}, 온혈: {self.is_warm_blooded}"

class Dog(Mammal):
    """개 클래스"""
    
    def __init__(self, name, breed, fur_color):
        # 부모 클래스의 __init__ 호출
        print(f"Dog.__init__() 호출: {name}")
        super().__init__(name, "Canis lupus familiaris", fur_color)
        self.breed = breed
        self.tricks = []
    
    def speak(self):
        # 부모 클래스의 speak 호출 및 확장
        parent_speak = super().speak()
        return f"{parent_speak} 멍멍!"
    
    def get_info(self):
        # 부모 클래스의 get_info 호출 및 확장
        parent_info = super().get_info()
        return f"{parent_info}, 품종: {self.breed}, 배운기술: {len(self.tricks)}개"
    
    def learn_trick(self, trick):
        """기술 배우기"""
        self.tricks.append(trick)
        return f"{self.name}이(가) '{trick}'을(를) 배웠습니다!"

print("1. 기본적인 super() 사용")
print("=" * 60)

# 객체 생성
my_dog = Dog("바둑이", "진돗개", "갈색")

print(f"\n객체 생성 완료: {my_dog.name}")

# 메소드 호출
print(f"\n말하기: {my_dog.speak()}")
print(f"\n정보: {my_dog.get_info()}")

# 기술 배우기
print(f"\n{my_dog.learn_trick('앉아')}")
print(f"{my_dog.learn_trick('손')}")
print(f"\n업데이트된 정보: {my_dog.get_info()}")
```

### 다중 상속과 메소드 결정 순서(MRO)

```python
print("\n2. 다중 상속과 MRO")
print("=" * 60)

class Flyable:
    """날 수 있는 동물 믹스인"""
    
    def __init__(self, max_altitude=1000):
        print(f"Flyable.__init__() 호출")
        self.max_altitude = max_altitude
        self.is_flying = False
        super().__init__()  # 다중 상속을 위해 super() 호출
    
    def take_off(self):
        """이륙"""
        if not self.is_flying:
            self.is_flying = True
            return f"{self.__class__.__name__}가 이륙했습니다."
        return "이미 날고 있습니다."
    
    def land(self):
        """착륙"""
        if self.is_flying:
            self.is_flying = False
            return f"{self.__class__.__name__}가 착륙했습니다."
        return "이미 땅에 있습니다."
    
    def get_info(self):
        """정보 출력"""
        info = f"최대고도: {self.max_altitude}m, 비행중: {self.is_flying}"
        # super() 호출로 다른 클래스의 get_info와 결합
        try:
            parent_info = super().get_info()
            return f"{parent_info}, {info}"
        except AttributeError:
            return info

class Swimmable:
    """수영할 수 있는 동물 믹스인"""
    
    def __init__(self, max_depth=50):
        print(f"Swimmable.__init__() 호출")
        self.max_depth = max_depth
        self.is_swimming = False
        super().__init__()  # 다중 상속을 위해 super() 호출
    
    def dive(self):
        """잠수"""
        if not self.is_swimming:
            self.is_swimming = True
            return f"{self.__class__.__name__}가 잠수했습니다."
        return "이미 수영중입니다."
    
    def surface(self):
        """부상"""
        if self.is_swimming:
            self.is_swimming = False
            return f"{self.__class__.__name__}가 부상했습니다."
        return "이미 수면에 있습니다."
    
    def get_info(self):
        """정보 출력"""
        info = f"최대깊이: {self.max_depth}m, 수영중: {self.is_swimming}"
        # super() 호출로 다른 클래스의 get_info와 결합
        try:
            parent_info = super().get_info()
            return f"{parent_info}, {info}"
        except AttributeError:
            return info

class Bird(Animal, Flyable):
    """새 클래스 (다중 상속)"""
    
    def __init__(self, name, species, wing_span):
        print(f"Bird.__init__() 호출: {name}")
        # 명시적으로 각 부모 클래스 초기화
        Animal.__init__(self, name, species)
        Flyable.__init__(self)
        self.wing_span = wing_span
        self.can_fly = True
    
    def speak(self):
        """새 소리"""
        return f"{self.name}이(가) 짹짹 웁니다."
    
    def get_info(self):
        """정보 출력"""
        animal_info = Animal.get_info(self)
        flyable_info = Flyable.get_info(self)
        return f"{animal_info}, 날개길이: {self.wing_span}cm, {flyable_info}"

class Duck(Bird, Swimmable):
    """오리 클래스 (다중 상속)"""
    
    def __init__(self, name, wing_span):
        print(f"Duck.__init__() 호출: {name}")
        # super()를 사용한 체인 호출
        super().__init__(name, "Anatidae", wing_span)
        # Swimmable은 Bird의 상속 체인에 없으므로 명시적으로 초기화
        Swimmable.__init__(self, max_depth=10)
    
    def speak(self):
        """오리 소리"""
        return f"{self.name}이(가) 꽥꽥 웁니다."
    
    def get_info(self):
        """정보 출력"""
        # super()를 사용하면 MRO에 따라 모든 부모의 get_info가 호출됨
        return super().get_info()

# MRO 확인
print("Duck 클래스의 메소드 결정 순서(MRO):")
for i, cls in enumerate(Duck.__mro__, 1):
    print(f"  {i}. {cls.__name__}")

# 객체 생성
print("\n오리 객체 생성:")
donald = Duck("도날드", 80)

print(f"\n객체 생성 완료: {donald.name}")

# 메소드 호출
print(f"\n말하기: {donald.speak()}")

# 비행 기능
print(f"\n{donald.take_off()}")
print(f"비행 상태: {donald.is_flying}")

# 수영 기능
print(f"\n{donald.dive()}")
print(f"수영 상태: {donald.is_swimming}")

# 정보 출력 (모든 부모 클래스의 get_info가 결합됨)
print(f"\n전체 정보:\n{donald.get_info()}")

# 착륙과 부상
print(f"\n{donald.land()}")
print(f"{donald.surface()}")
```

### 실전: 플러그인 아키텍처와 믹스인 패턴

```python
print("\n3. 실전: 플러그인 아키텍처")
print("=" * 60)

class PluginBase:
    """플러그인 기본 클래스"""
    
    def __init__(self):
        self.plugin_name = self.__class__.__name__
        self.is_enabled = True
    
    def initialize(self):
        """플러그인 초기화"""
        print(f"[{self.plugin_name}] 플러그인 초기화")
    
    def cleanup(self):
        """플러그인 정리"""
        print(f"[{self.plugin_name}] 플러그인 정리")

class LoggingMixin:
    """로깅 기능 믹스인"""
    
    def __init__(self):
        super().__init__()
        self.logs = []
    
    def log(self, message, level="INFO"):
        """로그 기록"""
        log_entry = {
            'timestamp': '2024-01-15 12:00:00',
            'level': level,
            'message': message,
            'plugin': self.plugin_name
        }
        self.logs.append(log_entry)
        print(f"[{level}] {self.plugin_name}: {message}")
    
    def get_logs(self):
        """로그 조회"""
        return self.logs

class ConfigurableMixin:
    """설정 가능 믹스인"""
    
    def __init__(self):
        super().__init__()
        self.config = {}
    
    def load_config(self, config_dict):
        """설정 로드"""
        self.config.update(config_dict)
        self.log(f"설정 로드됨: {len(config_dict)}개 항목")
    
    def get_config(self, key=None, default=None):
        """설정 조회"""
        if key is None:
            return self.config
        return self.config.get(key, default)
    
    def set_config(self, key, value):
        """설정 변경"""
        old_value = self.config.get(key)
        self.config[key] = value
        self.log(f"설정 변경: {key}={old_value} → {value}")

class CacheMixin:
    """캐싱 기능 믹스인"""
    
    def __init__(self):
        super().__init__()
        self.cache = {}
        self.cache_hits = 0
        self.cache_misses = 0
    
    def get_cached(self, key, default=None):
        """캐시에서 값 가져오기"""
        if key in self.cache:
            self.cache_hits += 1
            self.log(f"캐시 히트: {key}")
            return self.cache[key]
        else:
            self.cache_misses += 1
            self.log(f"캐시 미스: {key}")
            return default
    
    def set_cached(self, key, value):
        """캐시에 값 저장"""
        self.cache[key] = value
        self.log(f"캐시 저장: {key}")
    
    def clear_cache(self):
        """캐시 초기화"""
        count = len(self.cache)
        self.cache.clear()
        self.log(f"캐시 초기화: {count}개 항목 삭제")
    
    def get_cache_stats(self):
        """캐시 통계"""
        return {
            'size': len(self.cache),
            'hits': self.cache_hits,
            'misses': self.cache_misses,
            'hit_rate': self.cache_hits / (self.cache_hits + self.cache_misses) 
                        if (self.cache_hits + self.cache_misses) > 0 else 0
        }

class DatabasePlugin(PluginBase, LoggingMixin, ConfigurableMixin, CacheMixin):
    """데이터베이스 플러그인 (다중 믹스인 상속)"""
    
    def __init__(self):
        # 모든 믹스인의 __init__ 호출 (super() 체인)
        super().__init__()
        self.connection = None
    
    def initialize(self):
        """초기화 오버라이드"""
        super().initialize()  # 부모 클래스의 initialize 호출
        self.log("데이터베이스 플러그인 초기화 시작")
        
        # 설정에서 연결 정보 읽기
        host = self.get_config('host', 'localhost')
        port = self.get_config('port', 5432)
        
        self.log(f"데이터베이스 연결: {host}:{port}")
        self.connection = f"Connected to {host}:{port}"
        
        # 캐시 초기화
        self.clear_cache()
    
    def query(self, sql, use_cache=True):
        """쿼리 실행"""
        self.log(f"쿼리 실행: {sql[:50]}...")
        
        # 캐싱 로직
        if use_cache:
            cached_result = self.get_cached(sql)
            if cached_result is not None:
                return cached_result
        
        # 실제 쿼리 실행 (시뮬레이션)
        result = f"Result of: {sql}"
        
        # 캐시에 저장
        if use_cache:
            self.set_cached(sql, result)
        
        return result
    
    def cleanup(self):
        """정리"""
        super().cleanup()  # 부모 클래스의 cleanup 호출
        self.log("데이터베이스 연결 종료")
        self.connection = None
        self.clear_cache()

print("플러그인 시스템 데모:")

# 플러그인 생성
db_plugin = DatabasePlugin()

# 설정 로드
db_plugin.load_config({
    'host': 'db.example.com',
    'port': 5432,
    'username': 'admin',
    'cache_enabled': True
})

# 플러그인 초기화
db_plugin.initialize()

# 쿼리 실행 (캐싱 테스트)
print(f"\n쿼리 1 실행:")
result1 = db_plugin.query("SELECT * FROM users WHERE age > 30")
print(f"결과: {result1}")

print(f"\n동일 쿼리 재실행 (캐시 사용):")
result2 = db_plugin.query("SELECT * FROM users WHERE age > 30")
print(f"결과: {result2}")

print(f"\n다른 쿼리 실행:")
result3 = db_plugin.query("SELECT * FROM products WHERE price < 10000")
print(f"결과: {result3}")

# 캐시 통계
stats = db_plugin.get_cache_stats()
print(f"\n캐시 통계:")
print(f"  캐시 크기: {stats['size']}개")
print(f"  히트: {stats['hits']}회, 미스: {stats['misses']}회")
print(f"  히트율: {stats['hit_rate']:.1%}")

# 로그 확인
print(f"\n로그 ({len(db_plugin.logs)}건):")
for log in db_plugin.logs[-5:]:  # 마지막 5개만
    print(f"  [{log['level']}] {log['message']}")

# 플러그인 정리
db_plugin.cleanup()
```

## 서브클래스에서 프로퍼티 확장: 상속된 속성의 재정의와 확장

부모 클래스의 프로퍼티를 서브클래스에서 확장하거나 수정하는 방법을 알아봅니다.

### 프로퍼티 오버라이딩과 확장

```python
class Shape:
    """도형 기본 클래스"""
    
    def __init__(self, color="black"):
        self._color = color
        self._area = 0
        self._perimeter = 0
    
    @property
    def color(self):
        """색상"""
        return self._color
    
    @color.setter
    def color(self, value):
        """색상 설정"""
        if not isinstance(value, str):
            raise ValueError("색상은 문자열이어야 합니다.")
        self._color = value
    
    @property
    def area(self):
        """면적 (추상 프로퍼티)"""
        raise NotImplementedError("서브클래스에서 구현해야 합니다.")
    
    @property
    def perimeter(self):
        """둘레 (추상 프로퍼티)"""
        raise NotImplementedError("서브클래스에서 구현해야 합니다.")
    
    @property
    def description(self):
        """도형 설명"""
        return f"{self.color}색 도형"

class Rectangle(Shape):
    """사각형 클래스"""
    
    def __init__(self, width, height, color="black"):
        super().__init__(color)
        self._width = width
        self._height = height
        self._calculate_geometry()
    
    def _calculate_geometry(self):
        """기하학적 속성 계산"""
        self._area = self._width * self._height
        self._perimeter = 2 * (self._width + self._height)
    
    @property
    def width(self):
        """너비"""
        return self._width
    
    @width.setter
    def width(self, value):
        """너비 설정"""
        if value <= 0:
            raise ValueError("너비는 0보다 커야 합니다.")
        self._width = value
        self._calculate_geometry()  # 면적과 둘레 재계산
    
    @property
    def height(self):
        """높이"""
        return self._height
    
    @height.setter
    def height(self, value):
        """높이 설정"""
        if value <= 0:
            raise ValueError("높이는 0보다 커야 합니다.")
        self._height = value
        self._calculate_geometry()  # 면적과 둘레 재계산
    
    # 부모 클래스의 추상 프로퍼티 구현
    @property
    def area(self):
        """면적 (구현)"""
        return self._area
    
    @property
    def perimeter(self):
        """둘레 (구현)"""
        return self._perimeter
    
    # 부모 클래스의 description 프로퍼티 확장
    @property
    def description(self):
        """도형 설명 (확장)"""
        # 부모 클래스의 description 가져오기
        parent_desc = super().description
        return f"{parent_desc}, 너비: {self.width}, 높이: {self.height}"

class ColoredRectangle(Rectangle):
    """색상 관리가 추가된 사각형"""
    
    # 색상 프로퍼티 확장 (유효성 검사 추가)
    @property
    def color(self):
        """색상 (확장)"""
        # 부모의 getter 호출
        return super().color
    
    @color.setter
    def color(self, value):
        """색상 설정 (확장 - 유효성 검사 추가)"""
        # 추가 유효성 검사
        valid_colors = ['red', 'green', 'blue', 'yellow', 'black', 'white']
        if value.lower() not in valid_colors:
            raise ValueError(f"색상은 {valid_colors} 중 하나여야 합니다.")
        
        # 부모의 setter 호출
        super(ColoredRectangle, type(self)).color.fset(self, value)
    
    @property
    def description(self):
        """도형 설명 (더 확장)"""
        # 조부모(Shape)의 description 호출
        shape_desc = Shape.description.fget(self)
        return f"{shape_desc}, 크기: {self.width}×{self.height}, 면적: {self.area}"

print("1. 프로퍼티 오버라이딩과 확장")
print("=" * 60)

# 기본 사각형
rect = Rectangle(10, 5, "blue")
print(f"사각형: {rect.description}")
print(f"면적: {rect.area}, 둘레: {rect.perimeter}")

# 크기 변경
rect.width = 15
print(f"\n너비 변경 후:")
print(f"사각형: {rect.description}")
print(f"면적: {rect.area}, 둘레: {rect.perimeter}")

# 색상 관리 사각형
colored_rect = ColoredRectangle(8, 6, "green")
print(f"\n색상 관리 사각형: {colored_rect.description}")

# 색상 변경 (추가 유효성 검사)
try:
    colored_rect.color = "purple"  # 유효하지 않은 색상
except ValueError as e:
    print(f"색상 변경 오류: {e}")

# 유효한 색상 변경
colored_rect.color = "red"
print(f"\n색상 변경 후: {colored_rect.description}")

# 다양한 설명 방법 비교
print(f"\n설명 비교:")
print(f"- Shape.description: {Shape.description.fget(colored_rect)}")
print(f"- Rectangle.description: {Rectangle.description.fget(colored_rect)}")
print(f"- ColoredRectangle.description: {colored_rect.description}")
```

### 동적 프로퍼티 확장 시스템

```python
print("\n2. 동적 프로퍼티 확장 시스템")
print("=" * 60)

class ExtendableProperty:
    """확장 가능한 프로퍼티 디스크립터"""
    
    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        self.__doc__ = doc
        self.extensions = {
            'get': [],
            'set': [],
            'delete': []
        }
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        
        # 기본 getter
        value = self.fget(obj) if self.fget else None
        
        # 확장 getter 실행
        for extension in self.extensions['get']:
            value = extension(obj, value)
        
        return value
    
    def __set__(self, obj, value):
        # 확장 setter 실행 (역순)
        for extension in reversed(self.extensions['set']):
            value = extension(obj, value)
        
        # 기본 setter
        if self.fset:
            self.fset(obj, value)
    
    def __delete__(self, obj):
        # 확장 deleter 실행 (역순)
        for extension in reversed(self.extensions['delete']):
            extension(obj)
        
        # 기본 deleter
        if self.fdel:
            self.fdel(obj)
    
    def extend_getter(self, func):
        """Getter 확장 추가"""
        self.extensions['get'].append(func)
        return self
    
    def extend_setter(self, func):
        """Setter 확장 추가"""
        self.extensions['set'].append(func)
        return self
    
    def extend_deleter(self, func):
        """Deleter 확장 추가"""
        self.extensions['delete'].append(func)
        return self

class Product:
    """제품 클래스"""
    
    def __init__(self, name, price):
        self._name = name
        self._price = price
        self._discount = 0
    
    # 확장 가능한 프로퍼티
    price = ExtendableProperty()
    
    # 기본 getter/setter 설정
    @price.fget
    def price(self):
        return self._price
    
    @price.fset
    def price(self, value):
        if value < 0:
            raise ValueError("가격은 0 이상이어야 합니다.")
        self._price = value
    
    # 할인율 프로퍼티
    @property
    def discount(self):
        return self._discount
    
    @discount.setter
    def discount(self, value):
        if not 0 <= value <= 1:
            raise ValueError("할인율은 0과 1 사이여야 합니다.")
        self._discount = value
    
    # 할인 가격 프로퍼티
    @property
    def discounted_price(self):
        return self._price * (1 - self._discount)

class TaxableProduct(Product):
    """세금이 적용된 제품"""
    
    def __init__(self, name, price, tax_rate=0.1):
        super().__init__(name, price)
        self.tax_rate = tax_rate
        
        # 부모 클래스의 price 프로퍼티 확장
        self._extend_price_property()
    
    def _extend_price_property(self):
        """가격 프로퍼티 확장"""
        
        # Getter 확장: 세금 포함 가격 계산
        def add_tax(obj, price):
            """세금 추가"""
            return price * (1 + obj.tax_rate)
        
        # Setter 확장: 세금 전 가격으로 저장
        def remove_tax(obj, price_with_tax):
            """세금 제거"""
            return price_with_tax / (1 + obj.tax_rate)
        
        # 부모 클래스의 price 프로퍼티 가져오기
        price_property = Product.price
        
        # 확장 추가
        price_property.extend_getter(add_tax)
        price_property.extend_setter(remove_tax)
    
    @property
    def price_before_tax(self):
        """세금 전 가격"""
        return self._price
    
    @price_before_tax.setter
    def price_before_tax(self, value):
        """세금 전 가격 설정"""
        self._price = value

class DiscountableTaxableProduct(TaxableProduct):
    """할인과 세금이 모두 적용된 제품"""
    
    def __init__(self, name, price, tax_rate=0.1, max_discount=0.3):
        super().__init__(name, price, tax_rate)
        self.max_discount = max_discount
        
        # 추가 확장
        self._extend_price_property_further()
    
    def _extend_price_property_further(self):
        """가격 프로퍼티 추가 확장"""
        
        # Getter 확장: 할인 적용
        def apply_discount(obj, price_with_tax):
            """할인 적용"""
            return price_with_tax * (1 - obj.discount)
        
        # Setter 확장: 할인을 고려한 가격 설정
        def reverse_discount(obj, discounted_price):
            """할인 되돌리기"""
            if obj.discount > 0:
                return discounted_price / (1 - obj.discount)
            return discounted_price
        
        # Setter 확장: 최대 할인율 검사
        def validate_discount(obj, price_before_discount):
            """할인율 검증"""
            # 할인율이 최대값을 초과하는지 계산
            if obj.discount > obj.max_discount:
                raise ValueError(f"할인율은 최대 {obj.max_discount*100}%까지 가능합니다.")
            return price_before_discount
        
        # 부모 클래스의 price 프로퍼티 가져오기
        price_property = Product.price
        
        # 추가 확장 (순서 중요!)
        price_property.extend_getter(apply_discount)
        price_property.extend_setter(reverse_discount)
        price_property.extend_setter(validate_discount)  # 마지막에 실행됨

print("동적 프로퍼티 확장 시스템:")

# 기본 제품
print("\n1. 기본 제품:")
product = Product("노트북", 1000000)
print(f"제품: {product._name}")
print(f"가격: {product.price:,}원")

# 세금 적용 제품
print("\n2. 세금 적용 제품:")
taxable = TaxableProduct("노트북", 1000000, tax_rate=0.1)
print(f"세금 전 가격: {taxable.price_before_tax:,}원")
print(f"세금 포함 가격: {taxable.price:,}원")  # 1,100,000원

# 가격 변경
taxable.price = 1100000  # 세금 포함 가격으로 설정
print(f"새 가격 설정 후:")
print(f"  세금 포함: {taxable.price:,}원")
print(f"  세금 전: {taxable.price_before_tax:,.0f}원")  # 1,000,000원

# 할인+세금 적용 제품
print("\n3. 할인+세금 적용 제품:")
discountable = DiscountableTaxableProduct(
    "노트북", 
    1000000, 
    tax_rate=0.1, 
    max_discount=0.3
)

# 할인 설정
discountable.discount = 0.2  # 20% 할인

print(f"기본 정보:")
print(f"  원가: {discountable.price_before_tax:,}원")
print(f"  세금율: {discountable.tax_rate*100}%")
print(f"  할인율: {discountable.discount*100}%")
print(f"  최종 가격: {discountable.price:,.0f}원")  # 880,000원

# 계산 확인
print(f"\n계산 확인:")
print(f"  세금 포함 가격: {discountable.price_before_tax * 1.1:,.0f}원")
print(f"  할인 적용: {discountable.price_before_tax * 1.1 * 0.8:,.0f}원")

# 할인율 초과 시도
print(f"\n최대 할인율 초과 테스트:")
try:
    discountable.discount = 0.5  # 50% 할인 시도
except ValueError as e:
    print(f"  오류: {e}")

# 가격 설정 테스트
print(f"\n새 가격 설정 (880,000원):")
discountable.price = 880000
print(f"  설정된 최종 가격: {discountable.price:,}원")
print(f"  세금 전 가격: {discountable.price_before_tax:,.0f}원")
```

## 새로운 클래스나 인스턴스 속성 만들기: 메타프로그래밍 기법

동적으로 클래스나 인스턴스 속성을 생성하는 고급 기법들을 살펴봅니다.

### 클래스 데코레이터를 이용한 동적 속성 추가

```python
def add_timestamps(cls):
    """생성 및 수정 시간 속성을 추가하는 클래스 데코레이터"""
    
    class WrappedClass(cls):
        def __init__(self, *args, **kwargs):
            self._created_at = '2024-01-15 12:00:00'
            self._updated_at = self._created_at
            self._version = 1
            super().__init__(*args, **kwargs)
        
        @property
        def created_at(self):
            """생성 시간"""
            return self._created_at
        
        @property
        def updated_at(self):
            """수정 시간"""
            return self._updated_at
        
        @property
        def version(self):
            """버전"""
            return self._version
        
        def update(self, **kwargs):
            """속성 업데이트"""
            for key, value in kwargs.items():
                if hasattr(self, key):
                    setattr(self, key, value)
            
            self._updated_at = '2024-01-15 12:05:00'
            self._version += 1
            
            return self
        
        def get_info(self):
            """정보 출력 (부모 메소드 확장)"""
            parent_info = super().get_info() if hasattr(super(), 'get_info') else ""
            return f"{parent_info}\n생성: {self.created_at}, 수정: {self.updated_at}, 버전: {self.version}"
    
    return WrappedClass

def add_serialization(cls):
    """직렬화 속성과 메소드를 추가하는 클래스 데코레이터"""
    
    # 동적으로 속성 추가
    cls._serializable_attributes = []
    
    # 기존 __init__ 저장
    original_init = cls.__init__
    
    def new_init(self, *args, **kwargs):
        original_init(self, *args, **kwargs)
        
        # 모든 인스턴스 속성을 직렬화 목록에 추가
        for key in self.__dict__:
            if not key.startswith('_'):
                cls._serializable_attributes.append(key)
        
        # 고유 ID 생성
        import uuid
        self._id = str(uuid.uuid4())[:8]
    
    cls.__init__ = new_init
    
    # 직렬화 메소드 추가
    def to_dict(self):
        """딕셔너리로 직렬화"""
        result = {'_id': self._id, '_type': self.__class__.__name__}
        for attr in self.__class__._serializable_attributes:
            if hasattr(self, attr):
                value = getattr(self, attr)
                # 간단한 타입만 직렬화
                if isinstance(value, (str, int, float, bool, list, dict, type(None))):
                    result[attr] = value
        return result
    
    def to_json(self):
        """JSON 문자열로 직렬화"""
        import json
        return json.dumps(self.to_dict(), ensure_ascii=False, indent=2)
    
    @classmethod
    def from_dict(cls, data):
        """딕셔너리에서 객체 생성"""
        # _id와 _type 제외
        filtered_data = {k: v for k, v in data.items() 
                        if not k.startswith('_') or k == '_id'}
        
        # 객체 생성
        obj = cls.__new__(cls)
        for key, value in filtered_data.items():
            setattr(obj, key, value)
        
        return obj
    
    # 메소드 추가
    cls.to_dict = to_dict
    cls.to_json = to_json
    cls.from_dict = classmethod(from_dict)
    
    return cls

@add_timestamps
@add_serialization
class Document:
    """문서 클래스"""
    
    def __init__(self, title, content, author):
        self.title = title
        self.content = content
        self.author = author
    
    def get_info(self):
        """기본 정보"""
        return f"제목: {self.title}, 저자: {self.author}"

print("1. 클래스 데코레이터를 이용한 동적 속성 추가")
print("=" * 60)

# 문서 생성
doc = Document("파이썬 가이드", "파이썬은 훌륭한 언어입니다.", "김철수")

print("문서 정보:")
print(doc.get_info())

print(f"\n추가된 속성들:")
print(f"  생성 시간: {doc.created_at}")
print(f"  수정 시간: {doc.updated_at}")
print(f"  버전: {doc.version}")
print(f"  ID: {doc._id}")

# 업데이트
doc.update(title="파이썬 고급 가이드", content="파이썬 고급 기능을 배워봅시다.")
print(f"\n업데이트 후:")
print(doc.get_info())
print(f"  새로운 버전: {doc.version}")

# 직렬화
print(f"\n직렬화 결과:")
print(f"딕셔너리: {doc.to_dict()}")
print(f"\nJSON:\n{doc.to_json()}")

# 역직렬화
print(f"\n역직렬화 테스트:")
data = doc.to_dict()
new_doc = Document.from_dict(data)
print(f"복원된 문서 제목: {new_doc.title}")
print(f"복원된 문서 ID: {new_doc._id}")
```

### 메타클래스를 이용한 동적 속성 생성

```python
print("\n2. 메타클래스를 이용한 동적 속성 생성")
print("=" * 60)

class AutoPropertyMeta(type):
    """자동 프로퍼티 생성을 위한 메타클래스"""
    
    def __new__(cls, name, bases, attrs):
        # 새로운 속성들을 저장할 딕셔너리
        new_attrs = {}
        
        # 필드에서 자동으로 프로퍼티 생성
        for attr_name, attr_value in attrs.items():
            if not attr_name.startswith('_') and not callable(attr_value):
                # 필드를 프로퍼티로 변환
                new_attrs[attr_name] = cls._create_property(attr_name)
                # 원래 값은 내부 변수로 저장
                new_attrs[f'_{attr_name}'] = attr_value
            else:
                new_attrs[attr_name] = attr_value
        
        # 유효성 검사 메소드 추가
        new_attrs['_validate_all'] = cls._create_validation_method()
        
        return super().__new__(cls, name, bases, new_attrs)
    
    @staticmethod
    def _create_property(field_name):
        """필드에 대한 프로퍼티 생성"""
        
        def getter(self):
            """Getter"""
            internal_name = f'_{field_name}'
            return getattr(self, internal_name)
        
        def setter(self, value):
            """Setter"""
            # 유효성 검사
            validator_name = f'_validate_{field_name}'
            if hasattr(self, validator_name):
                validator = getattr(self, validator_name)
                value = validator(value)
            
            internal_name = f'_{field_name}'
            setattr(self, internal_name, value)
        
        def deleter(self):
            """Deleter"""
            internal_name = f'_{field_name}'
            setattr(self, internal_name, None)
        
        return property(getter, setter, deleter, doc=f"{field_name} 속성")
    
    @staticmethod
    def _create_validation_method():
        """모든 필드 검증 메소드"""
        def validate_all(self):
            """모든 필드 검증"""
            errors = []
            for attr_name in dir(self):
                if attr_name.startswith('_validate_'):
                    validator = getattr(self, attr_name)
                    field_name = attr_name[10:]  # '_validate_' 제거
                    field_value = getattr(self, field_name)
                    
                    try:
                        validator(field_value)
                    except ValueError as e:
                        errors.append(f"{field_name}: {e}")
            
            if errors:
                raise ValueError(f"검증 오류:\n" + "\n".join(errors))
            
            return True
        
        return validate_all

class Model(metaclass=AutoPropertyMeta):
    """모델 기본 클래스"""
    
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)
    
    def to_dict(self):
        """딕셔너리로 변환"""
        result = {}
        for attr_name in dir(self):
            if not attr_name.startswith('_') and not callable(getattr(self, attr_name)):
                result[attr_name] = getattr(self, attr_name)
        return result

class User(Model):
    """사용자 모델"""
    
    # 필드 정의 (자동으로 프로퍼티 생성됨)
    username = ""
    email = ""
    age = 0
    is_active = True
    
    # 유효성 검사 메소드들
    def _validate_username(self, value):
        """사용자명 검증"""
        if not value:
            raise ValueError("사용자명은 필수입니다.")
        if len(value) < 3:
            raise ValueError("사용자명은 3자 이상이어야 합니다.")
        return value
    
    def _validate_email(self, value):
        """이메일 검증"""
        if not value:
            raise ValueError("이메일은 필수입니다.")
        if '@' not in value:
            raise ValueError("유효한 이메일 형식이 아닙니다.")
        return value
    
    def _validate_age(self, value):
        """나이 검증"""
        if not isinstance(value, int):
            raise ValueError("나이는 정수여야 합니다.")
        if value < 0:
            raise ValueError("나이는 0 이상이어야 합니다.")
        if value > 150:
            raise ValueError("나이는 150 이하여야 합니다.")
        return value
    
    def _validate_is_active(self, value):
        """활성 상태 검증"""
        if not isinstance(value, bool):
            raise ValueError("활성 상태는 불리언이어야 합니다.")
        return value

print("메타클래스를 이용한 동적 속성 생성:")

# 사용자 생성
user = User(username="kimcheolsu", email="kim@example.com", age=30)

print(f"생성된 사용자:")
print(f"  사용자명: {user.username}")
print(f"  이메일: {user.email}")
print(f"  나이: {user.age}")
print(f"  활성: {user.is_active}")

# 딕셔너리 변환
print(f"\n딕셔너리 표현:")
print(f"  {user.to_dict()}")

# 속성 변경 (유효성 검사 동작)
print(f"\n속성 변경 테스트:")

try:
    user.username = "ab"  # 너무 짧은 사용자명
except ValueError as e:
    print(f"  오류: {e}")

try:
    user.age = -5  # 음수 나이
except ValueError as e:
    print(f"  오류: {e}")

try:
    user.email = "invalid-email"  # 잘못된 이메일
except ValueError as e:
    print(f"  오류: {e}")

# 정상적인 변경
user.username = "newuser123"
user.age = 35
print(f"\n정상 변경 후:")
print(f"  사용자명: {user.username}")
print(f"  나이: {user.age}")

# 전체 검증
print(f"\n전체 검증:")
try:
    user._validate_all()
    print("  모든 검증 통과!")
except ValueError as e:
    print(f"  검증 실패: {e}")

# 동적으로 생성된 프로퍼티 확인
print(f"\n생성된 프로퍼티들:")
for attr_name in dir(user):
    if not attr_name.startswith('_') and not callable(getattr(user, attr_name)):
        print(f"  {attr_name}: {type(getattr(User, attr_name))}")
```

### __setattr__와 __getattr__를 이용한 동적 속성 관리

```python
print("\n3. __setattr__와 __getattr__를 이용한 동적 속성 관리")
print("=" * 60)

class DynamicAttributes:
    """동적 속성 관리 클래스"""
    
    def __init__(self):
        # 실제 데이터 저장소
        self._data = {}
        self._access_count = {}
        self._validators = {}
        self._defaults = {}
    
    def __setattr__(self, name, value):
        # 특별한 속성들
        if name in ['_data', '_access_count', '_validators', '_defaults']:
            super().__setattr__(name, value)
            return
        
        # 유효성 검사
        if name in self._validators:
            validator = self._validators[name]
            try:
                value = validator(value)
            except Exception as e:
                raise ValueError(f"{name} 설정 오류: {e}")
        
        # 데이터 저장
        self._data[name] = value
        
        # 접근 카운트 초기화
        if name not in self._access_count:
            self._access_count[name] = 0
    
    def __getattr__(self, name):
        # 특별한 속성들은 실제 __getattribute__에서 처리됨
        if name in self._data:
            # 접근 카운트 증가
            self._access_count[name] = self._access_count.get(name, 0) + 1
            
            # 값 반환
            return self._data[name]
        
        # 기본값이 있는 경우
        if name in self._defaults:
            default_value = self._defaults[name]
            if callable(default_value):
                return default_value()
            return default_value
        
        # 속성이 없을 때
        raise AttributeError(f"'{self.__class__.__name__}' 객체에 '{name}' 속성이 없습니다")
    
    def __delattr__(self, name):
        if name in self._data:
            del self._data[name]
            if name in self._access_count:
                del self._access_count[name]
        else:
            super().__delattr__(name)
    
    def set_validator(self, name, validator_func):
        """속성 유효성 검사기 설정"""
        self._validators[name] = validator_func
    
    def set_default(self, name, default_value):
        """속성 기본값 설정"""
        self._defaults[name] = default_value
    
    def get_access_stats(self):
        """접근 통계"""
        return dict(self._access_count)
    
    def get_all_attributes(self):
        """모든 속성 반환"""
        return dict(self._data)
    
    def add_computed_attribute(self, name, compute_func):
        """계산된 속성 추가"""
        self._data[name] = None  # 플레이스홀더
        
        def getter(self):
            # 계산 함수 실행
            return compute_func(self)
        
        # 속성으로 추가
        setattr(self.__class__, name, property(getter))

class Config(DynamicAttributes):
    """설정 관리 클래스"""
    
    def __init__(self):
        super().__init__()
        
        # 기본값 설정
        self.set_default('theme', 'light')
        self.set_default('language', 'ko')
        self.set_default('font_size', 14)
        
        # 유효성 검사기 설정
        self.set_validator('font_size', self._validate_font_size)
        self.set_validator('theme', self._validate_theme)
        
        # 계산된 속성 추가
        self.add_computed_attribute('config_summary', self._compute_summary)
    
    def _validate_font_size(self, value):
        """폰트 크기 검증"""
        if not isinstance(value, int):
            raise ValueError("폰트 크기는 정수여야 합니다.")
        if not 8 <= value <= 72:
            raise ValueError("폰트 크기는 8에서 72 사이여야 합니다.")
        return value
    
    def _validate_theme(self, value):
        """테마 검증"""
        valid_themes = ['light', 'dark', 'system']
        if value not in valid_themes:
            raise ValueError(f"테마는 {valid_themes} 중 하나여야 합니다.")
        return value
    
    def _compute_summary(self):
        """설정 요약 계산"""
        items = []
        for key in sorted(self._data.keys()):
            if not key.startswith('_'):
                items.append(f"{key}: {self._data[key]}")
        return "; ".join(items)

print("동적 속성 관리 시스템:")

# 설정 객체 생성
config = Config()

print("기본 설정:")
print(f"  테마: {config.theme}")
print(f"  언어: {config.language}")
print(f"  폰트 크기: {config.font_size}")

# 동적 속성 설정
config.timeout = 30
config.debug_mode = True
config.api_url = "https://api.example.com"

print(f"\n추가된 설정:")
print(f"  타임아웃: {config.timeout}")
print(f"  디버그 모드: {config.debug_mode}")
print(f"  API URL: {config.api_url}")

# 계산된 속성
print(f"\n계산된 속성:")
print(f"  설정 요약: {config.config_summary}")

# 유효성 검사 테스트
print(f"\n유효성 검사 테스트:")

try:
    config.font_size = 100  # 잘못된 폰트 크기
except ValueError as e:
    print(f"  오류: {e}")

try:
    config.theme = "blue"  # 잘못된 테마
except ValueError as e:
    print(f"  오류: {e}")

# 정상적인 변경
config.font_size = 16
config.theme = "dark"

print(f"\n변경 후 설정:")
print(f"  폰트 크기: {config.font_size}")
print(f"  테마: {config.theme}")
print(f"  설정 요약: {config.config_summary}")

# 접근 통계
print(f"\n접근 통계:")
stats = config.get_access_stats()
for attr, count in stats.items():
    print(f"  {attr}: {count}회")

# 존재하지 않는 속성 접근
print(f"\n존재하지 않는 속성 접근 테스트:")
try:
    print(f"  {config.unknown_attribute}")
except AttributeError as e:
    print(f"  예상된 오류: {e}")

# 기본값 테스트
print(f"\n기본값 테스트 (새로운 객체):")
config2 = Config()
print(f"  새 객체 테마: {config2.theme} (기본값)")
```

## 게으른 계산을 하는 프로퍼티 사용: 지연 평가 패턴

게으른 계산(lazy evaluation)은 값이 실제로 필요할 때까지 계산을 미루는 패턴으로, 성능 최적화에 유용합니다.

### 기본적인 게으른 프로퍼티 패턴

```python
import time
import random

class LazyProperty:
    """게으른 계산을 위한 디스크립터"""
    
    def __init__(self, func):
        self.func = func
        self.name = func.__name__
        self.__doc__ = func.__doc__
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        
        # 계산 결과 캐싱
        if not hasattr(obj, '_lazy_cache'):
            obj._lazy_cache = {}
        
        if self.name not in obj._lazy_cache:
            print(f"[게으른 계산] {self.name} 계산 중...")
            start_time = time.time()
            obj._lazy_cache[self.name] = self.func(obj)
            elapsed = time.time() - start_time
            print(f"[게으른 계산] {self.name} 계산 완료 ({elapsed:.3f}초)")
        
        return obj._lazy_cache[self.name]
    
    def __set__(self, obj, value):
        # 직접 설정 시 캐시 업데이트
        if not hasattr(obj, '_lazy_cache'):
            obj._lazy_cache = {}
        obj._lazy_cache[self.name] = value

class ExpensiveData:
    """비용이 많이 드는 계산을 포함하는 클래스"""
    
    def __init__(self, data_size=1000000):
        self.data_size = data_size
        self.raw_data = list(range(data_size))
    
    @LazyProperty
    def sorted_data(self):
        """정렬된 데이터 (비용이 많이 드는 연산)"""
        # 대용량 데이터 정렬 시뮬레이션
        data = self.raw_data.copy()
        for i in range(len(data)):
            # 느린 정렬 알고리즘 시뮬레이션
            time.sleep(0.000001)  # 각 요소당 1마이크로초
            for j in range(i+1, len(data)):
                if data[i] > data[j]:
                    data[i], data[j] = data[j], data[i]
        return data
    
    @LazyProperty
    def statistics(self):
        """통계 계산 (비용이 많이 드는 연산)"""
        print(f"[통계] {self.data_size}개 데이터 처리 중...")
        
        # 시간이 걸리는 통계 계산
        data = self.sorted_data  # 다른 게으른 속성 사용
        
        stats = {
            'mean': sum(data) / len(data),
            'min': min(data),
            'max': max(data),
            'median': data[len(data) // 2],
            'sum': sum(data)
        }
        
        # 추가 계산 시뮬레이션
        time.sleep(0.5)
        
        return stats
    
    @LazyProperty
    def hash_value(self):
        """해시 값 계산 (비용이 많이 드는 연산)"""
        import hashlib
        import pickle
        
        print(f"[해시] 데이터 해싱 중...")
        
        # 데이터 직렬화
        data_bytes = pickle.dumps(self.raw_data)
        
        # 여러 해시 알고리즘 적용
        hashes = {
            'md5': hashlib.md5(data_bytes).hexdigest(),
            'sha1': hashlib.sha1(data_bytes).hexdigest(),
            'sha256': hashlib.sha256(data_bytes).hexdigest(),
            'blake2b': hashlib.blake2b(data_bytes).hexdigest()
        }
        
        time.sleep(0.3)
        
        return hashes

print("1. 기본적인 게으른 프로퍼티 패턴")
print("=" * 60)

# 데이터 객체 생성
print("데이터 객체 생성 중...")
data = ExpensiveData(data_size=10000)  # 테스트를 위해 크기 줄임

print(f"\n객체 생성 완료. 데이터 크기: {data.data_size}")

# 첫 번째 접근 (계산 발생)
print(f"\n첫 번째 sorted_data 접근:")
start = time.time()
sorted_data = data.sorted_data
elapsed = time.time() - start
print(f"  결과: 처음 {min(sorted_data[:5])}...{max(sorted_data[-5:])}")
print(f"  소요 시간: {elapsed:.3f}초")

# 두 번째 접근 (캐시 사용)
print(f"\n두 번째 sorted_data 접근:")
start = time.time()
sorted_data_again = data.sorted_data
elapsed = time.time() - start
print(f"  소요 시간: {elapsed:.6f}초 (캐시 사용)")

# 통계 계산 (다른 게으른 속성)
print(f"\nstatistics 접근:")
stats = data.statistics
print(f"  평균: {stats['mean']:.2f}")
print(f"  최소: {stats['min']}")
print(f"  최대: {stats['max']}")

# 해시 값 계산
print(f"\nhash_value 접근:")
hashes = data.hash_value
print(f"  MD5: {hashes['md5'][:16]}...")
print(f"  SHA256: {hashes['sha256'][:16]}...")

# 캐시 확인
print(f"\n캐시 상태:")
if hasattr(data, '_lazy_cache'):
    for key in data._lazy_cache:
        print(f"  {key}: 계산됨")
```

### 게으른 프로퍼티의 고급 패턴들

```python
print("\n2. 게으른 프로퍼티의 고급 패턴")
print("=" * 60)

class SmartLazyProperty:
    """스마트한 게으른 프로퍼티 디스크립터"""
    
    def __init__(self, func, ttl=None, max_size=None):
        """
        Args:
            func: 계산 함수
            ttl: 캐시 유효 시간 (초)
            max_size: 최대 캐시 크기
        """
        self.func = func
        self.name = func.__name__
        self.ttl = ttl
        self.max_size = max_size
        self.__doc__ = func.__doc__
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        
        # 캐시 초기화
        if not hasattr(obj, '_smart_cache'):
            obj._smart_cache = {
                'data': {},
                'timestamps': {},
                'access_count': {}
            }
        
        cache_info = obj._smart_cache
        
        # 캐시 히트 확인
        if self.name in cache_info['data']:
            # TTL 확인
            if self.ttl is not None:
                last_access = cache_info['timestamps'].get(self.name, 0)
                current_time = time.time()
                if current_time - last_access > self.ttl:
                    print(f"[캐시 만료] {self.name}, 재계산")
                    del cache_info['data'][self.name]
                else:
                    # 접근 카운트 증가
                    cache_info['access_count'][self.name] = \
                        cache_info['access_count'].get(self.name, 0) + 1
                    cache_info['timestamps'][self.name] = time.time()
                    
                    print(f"[캐시 히트] {self.name} (접근 {cache_info['access_count'][self.name]}회)")
                    return cache_info['data'][self.name]
        
        # 캐시 크기 관리
        if self.max_size is not None and len(cache_info['data']) >= self.max_size:
            self._evict_cache(obj)
        
        # 계산 실행
        print(f"[계산 시작] {self.name}")
        start_time = time.time()
        result = self.func(obj)
        elapsed = time.time() - start_time
        
        # 캐시 저장
        cache_info['data'][self.name] = result
        cache_info['timestamps'][self.name] = time.time()
        cache_info['access_count'][self.name] = 1
        
        print(f"[계산 완료] {self.name} ({elapsed:.3f}초)")
        
        return result
    
    def _evict_cache(self, obj):
        """캐시 항목 제거 (LRU: 가장 오래전에 사용된 항목)"""
        cache_info = obj._smart_cache
        
        if not cache_info['data']:
            return
        
        # 가장 오래전에 접근한 항목 찾기
        oldest_key = min(cache_info['timestamps'], 
                        key=lambda k: cache_info['timestamps'][k])
        
        print(f"[캐시 제거] {oldest_key} (LRU)")
        
        # 제거
        del cache_info['data'][oldest_key]
        del cache_info['timestamps'][oldest_key]
        del cache_info['access_count'][oldest_key]
    
    def invalidate(self, obj):
        """캐시 무효화"""
        if hasattr(obj, '_smart_cache') and self.name in obj._smart_cache['data']:
            print(f"[캐시 무효화] {self.name}")
            del obj._smart_cache['data'][self.name]
            del obj._smart_cache['timestamps'][self.name]
            del obj._smart_cache['access_count'][self.name]
    
    def precompute(self, obj):
        """사전 계산"""
        _ = self.__get__(obj)  # 강제 계산
    
    def get_cache_info(self, obj):
        """캐시 정보"""
        if not hasattr(obj, '_smart_cache'):
            return None
        
        cache_info = obj._smart_cache
        if self.name not in cache_info['data']:
            return {'status': 'not_cached'}
        
        return {
            'status': 'cached',
            'last_access': cache_info['timestamps'][self.name],
            'access_count': cache_info['access_count'][self.name],
            'age_seconds': time.time() - cache_info['timestamps'][self.name]
        }

class DataProcessor:
    """데이터 처리기 (스마트 게으른 프로퍼티 사용)"""
    
    def __init__(self, data):
        self.data = data
        self._modification_count = 0
    
    @SmartLazyProperty(ttl=10, max_size=2)  # 10초 TTL, 최대 2개 캐시
    def processed_data(self):
        """처리된 데이터 (비용이 많이 드는 연산)"""
        print(f"[처리] 데이터 처리 중...")
        time.sleep(0.5)
        
        # 데이터 처리 시뮬레이션
        result = []
        for item in self.data:
            # 복잡한 처리 시뮬레이션
            processed = item ** 2 + item * 3 + 5
            result.append(processed)
            time.sleep(0.0001)
        
        return result
    
    @SmartLazyProperty(ttl=5)  # 5초 TTL
    def statistics(self):
        """통계 (다른 게으른 속성에 의존)"""
        print(f"[통계] 통계 계산 중...")
        data = self.processed_data  # 다른 게으른 속성 사용
        
        stats = {
            'mean': sum(data) / len(data),
            'std': (sum((x - sum(data)/len(data))**2 for x in data) / len(data))**0.5,
            'min': min(data),
            'max': max(data),
            'count': len(data)
        }
        
        time.sleep(0.3)
        
        return stats
    
    @SmartLazyProperty  # 기본 설정 (무제한 TTL)
    def metadata(self):
        """메타데이터"""
        print(f"[메타데이터] 생성 중...")
        return {
            'data_length': len(self.data),
            'modification_count': self._modification_count,
            'created_at': '2024-01-15 12:00:00',
            'hash': hash(tuple(self.data)) % 1000000
        }
    
    def modify_data(self):
        """데이터 수정 (캐시 무효화)"""
        self._modification_count += 1
        print(f"\n데이터 수정됨 (수정 횟수: {self._modification_count})")
        
        # 관련 캐시 무효화
        if hasattr(self, '_smart_cache'):
            # processed_data 캐시 무효화
            if 'processed_data' in self._smart_cache['data']:
                SmartLazyProperty.__get__(self.__class__, 'processed_data').invalidate(self)
            
            # statistics 캐시 무효화 (processed_data에 의존)
            if 'statistics' in self._smart_cache['data']:
                SmartLazyProperty.__get__(self.__class__, 'statistics').invalidate(self)

print("스마트 게으른 프로퍼티 시스템:")

# 테스트 데이터
test_data = list(range(1000))
processor = DataProcessor(test_data)

print(f"데이터 처리기 생성 완료 (데이터 크기: {len(test_data)})")

# 첫 번째 접근
print(f"\n1. 첫 번째 processed_data 접근:")
result1 = processor.processed_data
print(f"  결과 길이: {len(result1)}")
print(f"  처음 3개 값: {result1[:3]}")

# 두 번째 접근 (캐시 히트)
print(f"\n2. 두 번째 processed_data 접근 (즉시):")
result2 = processor.processed_data
print(f"  캐시 사용됨")

# 통계 계산
print(f"\n3. statistics 접근:")
stats = processor.statistics
print(f"  평균: {stats['mean']:.2f}")
print(f"  표준편차: {stats['std']:.2f}")

# 메타데이터
print(f"\n4. metadata 접근:")
meta = processor.metadata
print(f"  데이터 길이: {meta['data_length']}")
print(f"  해시: {meta['hash']}")

# 캐시 정보 확인
print(f"\n5. 캐시 정보:")
for prop_name in ['processed_data', 'statistics', 'metadata']:
    prop = getattr(DataProcessor, prop_name)
    info = prop.get_cache_info(processor)
    if info:
        print(f"  {prop_name}: {info['status']}, "
              f"접근 {info.get('access_count', 0)}회, "
              f"나이 {info.get('age_seconds', 0):.1f}초")

# 데이터 수정 (캐시 무효화)
print(f"\n6. 데이터 수정 테스트:")
processor.modify_data()

# 수정 후 다시 접근
print(f"\n7. 수정 후 processed_data 접근:")
result3 = processor.processed_data  # 재계산 발생
print(f"  재계산됨")

# TTL 테스트
print(f"\n8. TTL 테스트 (5초 대기):")
time.sleep(5)

print(f"\n9. TTL 만료 후 statistics 접근:")
stats2 = processor.statistics  # 재계산 발생 (TTL 만료)
print(f"  재계산됨")

# 최종 캐시 상태
print(f"\n10. 최종 캐시 상태:")
if hasattr(processor, '_smart_cache'):
    print(f"  캐시된 항목: {list(processor._smart_cache['data'].keys())}")
```

### 실전: 데이터베이스 지연 로딩 시스템

```python
print("\n3. 실전: 데이터베이스 지연 로딩 시스템")
print("=" * 60)

class LazyDatabaseLoader:
    """데이터베이스 지연 로딩 시스템"""
    
    # 클래스 레벨 캐시 (모든 인스턴스 공유)
    _shared_cache = {}
    _cache_hits = 0
    _cache_misses = 0
    
    def __init__(self, db_connection):
        self.db = db_connection
        self._local_cache = {}  # 인스턴스 레벨 캐시
        self.query_log = []
    
    @classmethod
    def get_cache_stats(cls):
        """공유 캐시 통계"""
        return {
            'size': len(cls._shared_cache),
            'hits': cls._cache_hits,
            'misses': cls._cache_misses,
            'hit_rate': cls._cache_hits / (cls._cache_hits + cls._cache_misses) 
                       if (cls._cache_hits + cls._cache_misses) > 0 else 0
        }
    
    def lazy_load(self, entity_type, entity_id):
        """지연 로딩 메소드"""
        
        def load_from_db():
            """실제 데이터베이스 로딩"""
            print(f"[DB] {entity_type} #{entity_id} 로딩 중...")
            
            # 쿼리 로깅
            query = f"SELECT * FROM {entity_type} WHERE id = {entity_id}"
            self.query_log.append({
                'query': query,
                'timestamp': '2024-01-15 12:00:00',
                'type': 'load'
            })
            
            # 데이터베이스 조회 시뮬레이션
            time.sleep(0.1)  # 네트워크 지연 시뮬레이션
            
            # 샘플 데이터
            if entity_type == 'users':
                data = {
                    'id': entity_id,
                    'name': f'사용자{entity_id}',
                    'email': f'user{entity_id}@example.com',
                    'created_at': '2024-01-01',
                    'status': 'active'
                }
            elif entity_type == 'products':
                data = {
                    'id': entity_id,
                    'name': f'제품{entity_id}',
                    'price': entity_id * 1000,
                    'category': '전자제품',
                    'stock': entity_id * 10
                }
            elif entity_type == 'orders':
                data = {
                    'id': entity_id,
                    'user_id': entity_id % 10 + 1,
                    'total_amount': entity_id * 5000,
                    'status': 'completed',
                    'created_at': '2024-01-15'
                }
            else:
                data = {'id': entity_id, 'type': entity_type}
            
            return data
        
        # 캐시 키 생성
        cache_key = f"{entity_type}:{entity_id}"
        
        # 1. 로컬 캐시 확인
        if cache_key in self._local_cache:
            print(f"[캐시] 로컬 캐시 히트: {cache_key}")
            return self._local_cache[cache_key]
        
        # 2. 공유 캐시 확인
        if cache_key in self._shared_cache:
            type(self)._cache_hits += 1
            print(f"[캐시] 공유 캐시 히트: {cache_key}")
            result = self._shared_cache[cache_key]
            # 로컬 캐시에도 저장
            self._local_cache[cache_key] = result
            return result
        
        # 3. 데이터베이스에서 로딩
        type(self)._cache_misses += 1
        result = load_from_db()
        
        # 캐시 저장
        self._local_cache[cache_key] = result
        self._shared_cache[cache_key] = result
        
        return result
    
    def create_lazy_property(self, entity_type, entity_id):
        """지연 로딩 프로퍼티 생성"""
        
        def getter(self):
            return self.lazy_load(entity_type, entity_id)
        
        # 고유한 속성 이름 생성
        prop_name = f"{entity_type}_{entity_id}"
        
        # 프로퍼티 생성 및 반환
        return property(getter, doc=f"지연 로딩: {entity_type} #{entity_id}")

class ECommerceSystem:
    """전자상거래 시스템"""
    
    def __init__(self):
        self.db_loader = LazyDatabaseLoader("database_connection")
        
        # 지연 로딩 속성들
        self._setup_lazy_properties()
    
    def _setup_lazy_properties(self):
        """지연 로딩 프로퍼티 설정"""
        
        # 사용자 프로퍼티
        for user_id in [1, 2, 3, 4, 5]:
            prop_name = f"user_{user_id}"
            prop = self.db_loader.create_lazy_property('users', user_id)
            setattr(ECommerceSystem, prop_name, prop)
        
        # 제품 프로퍼티
        for product_id in [101, 102, 103]:
            prop_name = f"product_{product_id}"
            prop = self.db_loader.create_lazy_property('products', product_id)
            setattr(ECommerceSystem, prop_name, prop)
        
        # 주문 프로퍼티
        for order_id in [1001, 1002]:
            prop_name = f"order_{order_id}"
            prop = self.db_loader.create_lazy_property('orders', order_id)
            setattr(ECommerceSystem, prop_name, prop)
    
    def process_order(self, order_id, user_id, product_id):
        """주문 처리 (지연 로딩 사용)"""
        print(f"\n[시스템] 주문 {order_id} 처리 중...")
        
        # 지연 로딩으로 데이터 접근
        user = getattr(self, f"user_{user_id}")
        product = getattr(self, f"product_{product_id}")
        
        print(f"  사용자: {user['name']}")
        print(f"  제품: {product['name']} ({product['price']:,}원)")
        print(f"  재고: {product['stock']}개")
        
        # 주문 생성
        order = {
            'id': order_id,
            'user': user,
            'product': product,
            'quantity': 2,
            'total': product['price'] * 2,
            'status': 'processing'
        }
        
        return order
    
    def generate_report(self):
        """리포트 생성 (여러 지연 로딩 속성 사용)"""
        print(f"\n[시스템] 리포트 생성 중...")
        
        report = {
            'users': [],
            'products': [],
            'summary': {}
        }
        
        # 모든 사용자 데이터 수집 (지연 로딩)
        for user_id in [1, 2, 3, 4, 5]:
            user = getattr(self, f"user_{user_id}")
            report['users'].append(user)
        
        # 모든 제품 데이터 수집 (지연 로딩)
        for product_id in [101, 102, 103]:
            product = getattr(self, f"product_{product_id}")
            report['products'].append(product)
        
        # 요약 계산
        total_users = len(report['users'])
        total_products = len(report['products'])
        total_value = sum(p['price'] * p['stock'] for p in report['products'])
        
        report['summary'] = {
            'total_users': total_users,
            'total_products': total_products,
            'total_inventory_value': total_value
        }
        
        return report

print("데이터베이스 지연 로딩 시스템:")

# 시스템 생성
system = ECommerceSystem()

# 개별 접근 테스트
print("\n1. 개별 사용자 접근:")
user1 = system.user_1
print(f"  사용자 1: {user1['name']} ({user1['email']})")

print("\n2. 동일 사용자 재접근 (캐시 사용):")
user1_again = system.user_1
print(f"  캐시에서 반환됨")

print("\n3. 다른 사용자 접근:")
user2 = system.user_2
print(f"  사용자 2: {user2['name']}")

# 주문 처리
print("\n4. 주문 처리:")
order = system.process_order(1001, 1, 101)
print(f"  주문 총액: {order['total']:,}원")

# 리포트 생성
print("\n5. 리포트 생성:")
report = system.generate_report()
print(f"  총 사용자: {report['summary']['total_users']}명")
print(f"  총 제품: {report['summary']['total_products']}개")
print(f"  총 재고 가치: {report['summary']['total_inventory_value']:,}원")

# 캐시 통계
print("\n6. 캐시 통계:")
stats = LazyDatabaseLoader.get_cache_stats()
print(f"  공유 캐시 크기: {stats['size']}개")
print(f"  캐시 히트: {stats['hits']}회")
print(f"  캐시 미스: {stats['misses']}회")
print(f"  히트율: {stats['hit_rate']:.1%}")

# 쿼리 로그
print(f"\n7. 실행된 쿼리 ({len(system.db_loader.query_log)}개):")
for i, log in enumerate(system.db_loader.query_log[:5], 1):
    print(f"  {i}. {log['query']}")

# 동일 데이터에 대한 다른 시스템 접근
print("\n8. 다른 시스템 인스턴스 테스트:")
system2 = ECommerceSystem()
print(f"  시스템2 사용자1 접근 (공유 캐시 사용):")
user1_sys2 = system2.user_1
print(f"    이름: {user1_sys2['name']}")
```

## 결론: 파이썬 속성 관리와 상속의 모범 사례

### 1. **관리 속성(@property)의 올바른 사용**
- **캡슐화 강화**: 내부 구현을 숨기고 안전한 인터페이스 제공
- **유효성 검사**: setter에서 데이터 무결성 보장
- **계산된 속성**: 필요시마다 계산되는 동적 속성 구현
- **호환성 유지**: 기존 코드 변경 없이 속성 동작 수정 가능

### 2. **상속 체인에서의 메소드 호출 원칙**
- **super() 사용**: 다중 상속에서 MRO를 따르는 안전한 호출
- **명시적 호출**: 특정 부모 클래스 메소드 호출 시 클래스명 사용
- **체인 호출 순서**: __init__ 메소드는 부모에서 자식으로 호출
- **믹스인 패턴**: 작은 기능 단위의 클래스를 조합

### 3. **서브클래스에서 프로퍼티 확장 전략**
- **재정의(Override)**: 완전히 새로운 동작 구현
- **확장(Extend)**: 부모 동작에 새로운 기능 추가
- **super() 활용**: 부모 프로퍼티의 getter/setter 재사용
- **데코레이터 조합**: @property와 @메소드.setter의 적절한 조합

### 4. **동적 속성 생성 패턴**
- **__setattr__/__getattr__**: 완전한 제어가 필요한 경우
- **메타클래스**: 클래스 생성 시점에 속성 자동 생성
- **디스크립터**: 재사용 가능한 속성 동작 정의
- **클래스 데코레이터**: 기존 클래스에 기능 추가

### 5. **게으른 계산 프로퍼티의 최적화**
- **필요시 계산**: 실제 사용될 때만 비용이 드는 연산 실행
- **캐싱 전략**: 계산 결과 저장으로 반복 연산 방지
- **TTL 구현**: 시간에 따라 캐시 무효화
- **의존성 관리**: 관련 데이터 변경 시 캐시 무효화

### 6. **성능 고려사항**
- **프로퍼티 오버헤드**: 간단한 속성은 일반 어트리뷰트가 더 빠름
- **캐시 메모리**: 게으른 프로퍼티는 추가 메모리 사용
- **지연 로딩 vs 즉시 로딩**: 사용 패턴에 맞는 전략 선택
- **다중 상속 비용**: 복잡한 MRO는 성능 저하 가능

### 7. **디버깅과 유지보수**
- **명확한 인터페이스**: 프로퍼티는 메소드처럼 동작하지만 어트리뷰트처럼 사용
- **문서화**: 복잡한 프로퍼티는 상세한 docstring 필요
- **에러 메시지**: 사용자 친화적인 검증 오류 메시지 제공
- **로깅**: 속성 접근과 변경 추적을 위한 로깅 시스템

### 8. **테스트 전략**
- **단위 테스트**: 각 프로퍼티의 getter/setter 별도 테스트
- **상호작용 테스트**: 상속 체인에서의 메소드 호출 검증
- **에러 조건 테스트**: 유효성 검사 실패 케이스 포함
- **성능 테스트**: 게으른 프로퍼티의 캐싱 효과 측정

파이썬의 속성 관리와 상속 시스템은 매우 강력하지만, 그 힘을 효과적으로 활용하려면 각 패턴의 적절한 사용 시기와 방법을 이해하는 것이 중요합니다. @property는 데이터 캡슐화와 유효성 검사를, 상속은 코드 재사용과 계층적 설계를, 동적 속성은 유연한 인터페이스를, 게으른 프로퍼티는 성능 최적화를 제공합니다. 이러한 도구들을 상황에 맞게 조합하면 더 견고하고 유지보수하기 쉬운 객체 지향 코드를 작성할 수 있습니다.