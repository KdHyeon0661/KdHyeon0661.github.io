---
layout: post
title: 파이썬 심화 - 메타프로그래밍 (4)
date: 2025-12-03 14:30:23 +0900
category: 파이썬 심화
---
# 메타프로그래밍 (4)

메타클래스는 파이썬에서 클래스의 생성과 동작을 세밀하게 제어할 수 있는 강력한 도구입니다. 클래스가 정의되는 방식을 프로그래밍적으로 조정하여 일관성 있는 구조를 유지하고, 오류를 사전에 방지할 수 있습니다.

## 메타클래스의 핵심 기능

### 1. 클래스 속성 정의 순서 수집
메타클래스는 클래스가 생성될 때 모든 속성의 정의 순서를 자동으로 기록할 수 있습니다. 이는 특히 데이터 클래스나 ORM 모델에서 필드 순서가 중요한 경우에 유용합니다.

```python
class OrderMeta(type):
    def __new__(mcls, name, bases, namespace):
        # 정의된 속성들의 순서를 수집
        namespace['_field_order'] = [
            key for key in namespace.keys()
            if not key.startswith('__')
        ]
        return super().__new__(mcls, name, bases, namespace)

class MyClass(metaclass=OrderMeta):
    x = 10
    y = 20
    z = 30

print(MyClass._field_order)  # ['x', 'y', 'z']
```

### 2. 옵션 매개변수를 받는 메타클래스 정의
메타클래스는 클래스 정의 시 추가적인 옵션 매개변수를 받아 동작을 커스터마이징할 수 있습니다. 이를 통해 더 유연한 클래스 생성 로직을 구현할 수 있습니다.

```python
class ConfigurableMeta(type):
    def __new__(mcls, name, bases, namespace, **kwargs):
        # 메타클래스 옵션 처리
        if kwargs.get('register', False):
            namespace['_registered'] = True
            namespace['_registry_key'] = kwargs.get('key', name.lower())
        
        # 추가 메타데이터 저장
        namespace['_meta_options'] = kwargs
        
        return super().__new__(mcls, name, bases, namespace)

class Product(metaclass=ConfigurableMeta, register=True, key='prod'):
    price = 100
    category = 'general'

print(Product._registered)    # True
print(Product._registry_key)  # 'prod'
```

### 3. *args, **kwargs에 매개변수 시그니처 강제
메타클래스를 사용하면 클래스의 초기화 메서드(`__init__`)나 다른 메서드의 매개변수 시그니처를 강제할 수 있습니다. 이는 API 일관성을 유지하거나 특정 패턴을 따르도록 강제하는 데 유용합니다.

```python
class SignatureEnforcingMeta(type):
    def __new__(mcls, name, bases, namespace):
        if '__init__' in namespace:
            init_method = namespace['__init__']
            # __init__ 메서드가 *args나 **kwargs만 사용하는지 확인
            import inspect
            sig = inspect.signature(init_method)
            params = list(sig.parameters.values())[1:]  # self 제외
            
            has_args = any(p.kind == p.VAR_POSITIONAL for p in params)
            has_kwargs = any(p.kind == p.VAR_KEYWORD for p in params)
            
            if has_args or has_kwargs:
                # 모든 매개변수가 명시적으로 정의되도록 강제
                raise TypeError(
                    f"{name}.__init__은 명시적인 매개변수만 사용해야 합니다. "
                    f"*args나 **kwargs는 허용되지 않습니다."
                )
        
        return super().__new__(mcls, name, bases, namespace)

class ValidClass(metaclass=SignatureEnforcingMeta):
    def __init__(self, x, y, z=None):
        self.x = x
        self.y = y
        self.z = z

# 다음 클래스는 TypeError 발생
# class InvalidClass(metaclass=SignatureEnforcingMeta):
#     def __init__(self, *args, **kwargs):
#         pass
```

### 4. 클래스 코딩 규칙 강제
메타클래스는 클래스 정의 시 다양한 코딩 규칙을 검사하고 강제할 수 있습니다. 이는 팀 내 코딩 표준을 유지하거나 특정 디자인 패턴을 따르도록 하는 데 효과적입니다.

```python
class CodingConventionsMeta(type):
    def __new__(mcls, name, bases, namespace):
        # 규칙 1: 모든 공개 메서드에 docstring 필요
        for attr_name, attr_value in namespace.items():
            if callable(attr_value) and not attr_name.startswith('_'):
                if attr_value.__doc__ is None:
                    raise TypeError(
                        f"{name}.{attr_name} 메서드는 docstring이 필요합니다."
                    )
        
        # 규칙 2: 특정 접두사를 가진 메서드만 허용
        allowed_prefixes = ['get_', 'set_', 'validate_', 'process_']
        for attr_name in namespace.keys():
            if callable(namespace.get(attr_name)) and not attr_name.startswith('_'):
                if not any(attr_name.startswith(prefix) for prefix in allowed_prefixes):
                    raise TypeError(
                        f"{name}.{attr_name} 메서드는 허용된 접두사로 시작해야 합니다: "
                        f"{allowed_prefixes}"
                    )
        
        # 규칙 3: 모든 클래스 속성은 타입 힌트를 가져야 함
        annotations = namespace.get('__annotations__', {})
        for attr_name, attr_value in namespace.items():
            if not callable(attr_value) and not attr_name.startswith('_'):
                if attr_name not in annotations:
                    import warnings
                    warnings.warn(
                        f"{name}.{attr_name} 속성에 타입 힌트가 없습니다.",
                        SyntaxWarning
                    )
        
        return super().__new__(mcls, name, bases, namespace)

class DataProcessor(metaclass=CodingConventionsMeta):
    """데이터 처리기 클래스"""
    
    timeout: int = 30
    
    def validate_input(self, data):
        """입력 데이터 검증"""
        return bool(data)
    
    def process_data(self, data):
        """데이터 처리"""
        return str(data)
```

## 메타클래스의 실용적인 적용 패턴

### 데이터베이스 모델 자동 등록
```python
class ModelMeta(type):
    _registry = {}
    
    def __new__(mcls, name, bases, namespace):
        cls = super().__new__(mcls, name, bases, namespace)
        
        # 추상 클래스가 아니면 등록
        if not namespace.get('__abstract__', False):
            mcls._registry[name] = cls
            cls._table_name = namespace.get('__tablename__', name.lower())
        
        return cls
    
    @classmethod
    def get_model(cls, name):
        return cls._registry.get(name)

class BaseModel(metaclass=ModelMeta):
    __abstract__ = True
    
    def save(self):
        print(f"{self.__class__.__name__} 저장됨")

class User(BaseModel):
    __tablename__ = 'users'
    
    def __init__(self, name, email):
        self.name = name
        self.email = email

print(ModelMeta._registry)  # {'User': <class '__main__.User'>}
```

### 인터페이스나 추상 클래스 검증 강화
```python
class InterfaceMeta(type):
    def __new__(mcls, name, bases, namespace):
        # 인터페이스 메서드 추출
        interface_methods = set()
        for base in bases:
            if hasattr(base, '_interface_methods'):
                interface_methods.update(base._interface_methods)
        
        # 현재 클래스의 추상 메서드 추가
        for attr_name, attr_value in namespace.items():
            if getattr(attr_value, '__isabstractmethod__', False):
                interface_methods.add(attr_name)
        
        namespace['_interface_methods'] = interface_methods
        
        cls = super().__new__(mcls, name, bases, namespace)
        
        # 추상 클래스가 아니면 모든 인터페이스 메서드 구현 확인
        if not hasattr(cls, '__abstractmethods__') or not cls.__abstractmethods__:
            missing_methods = []
            for method in interface_methods:
                if not hasattr(cls, method) or getattr(getattr(cls, method), '__isabstractmethod__', False):
                    missing_methods.append(method)
            
            if missing_methods:
                raise TypeError(
                    f"{name} 클래스는 다음 메서드를 구현해야 합니다: {missing_methods}"
                )
        
        return cls
```

## 결론

파이썬 메타클래스는 클래스 생성 프로세스를 인터셉트하고 수정하는 강력한 메커니즘을 제공합니다. 클래스 속성의 순서 추적, 옵션 매개변수 처리, 매개변수 시그니처 강제, 코딩 규칙 검증 등 다양한 고급 기능을 구현할 수 있습니다. 이러한 기능들은 프레임워크 개발, API 디자인, 코드 품질 관리 등에서 매우 유용하게 활용됩니다.

메타클래스를 효과적으로 사용하면 반복적인 코드 패턴을 제거하고, 일관성 있는 클래스 구조를 유지하며, 런타임 오류를 컴파일 타임에 발견할 수 있습니다. 다만 메타클래스는 복잡성을 증가시킬 수 있으므로, 실제 적용 시에는 명확한 사용 사례와 팀의 이해 수준을 고려하여 적절히 활용하는 것이 중요합니다.