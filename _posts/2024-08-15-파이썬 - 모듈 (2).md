---
layout: post
title: 파이썬 - 모듈 (2)
date: 2024-08-15 19:20:23 +0900
category: Python
---
# – 구조적인 파이썬 구현

## 한눈에 보는 체크리스트

- [ ] **프로젝트 구조**: `src/` 레이아웃 + 테스트 분리 + `pyproject.toml`
- [ ] **패키지 루트 공개 API**: `__init__.py`에서 `__all__` 제어
- [ ] **import 규칙**: 절대 import 권장, 패키지 내부만 상대 import (`python -m …` 실행)
- [ ] **배포 산출물**: **wheel(whl)** + sdist 둘 다 빌드
- [ ] **가상환경**: venv 또는 Poetry/Hatch 등으로 격리
- [ ] **환경 변수**: `.env` + `python-dotenv` 또는 `pydantic-settings`
- [ ] **테스트/CI**: `pytest` + `tox`/`nox` + GitHub Actions
- [ ] **버전/변경 이력**: SemVer + 단일 버전 소스(`__version__`) + CHANGELOG

---

## 패키지란?

> 여러 모듈을 **디렉터리**로 묶은 단위. 대규모 프로젝트를 **기능별로 분리**하고 **공개/비공개 경계**를 명확히 만든다.

```bash
myproject/
├── main.py
├── mathpack/
│   ├── __init__.py
│   ├── add.py
│   └── sub.py
```

**TIP**: 현대적인 레이아웃은 **src/ 레이아웃**을 권장(테스트에서 우연히 로컬 import 되는 문제를 방지).

```bash
myproject/
├── pyproject.toml
├── src/
│   └── mathpack/
│       ├── __init__.py
│       ├── add.py
│       └── sub.py
└── tests/
    └── test_add.py
```

---

## `__init__.py`의 역할 (전통 패키지 vs 네임스페이스)

- **전통 패키지**: 디렉터리에 `__init__.py`가 있으면 패키지로 인식됨.
- **네임스페이스 패키지(PEP 420)**: `__init__.py` 없이도 패키지; 플러그인 구조에 유용.
  (도구 체인 호환성 고려. 일반 앱/라이브러리는 `__init__.py` 작성 권장)

### 초기화/공개 API/메타데이터

```python
# src/mathpack/__init__.py

from .add import add
from .sub import subtract

__all__ = ["add", "subtract"]   # 공개 API
__version__ = "0.1.0"           # 단일 소스 버전 관리에 유리
```

```python
# src/mathpack/add.py

def add(a: int, b: int) -> int:
    return a + b
```

```python
# src/mathpack/sub.py

def subtract(a: int, b: int) -> int:
    return a - b
```

---

## import 방법 요약 + 베스트프랙티스

### 절대 import (권장)

```python
from mathpack.add import add
from mathpack import subtract
```

- **장점**: 위치 변경에 강함, 도구/IDE/정적분석 친화적.

### 상대 import (패키지 내부 전용)

```python
# src/mathpack/ops/arith.py

from ..add import add
from ..sub import subtract
```

- **주의**: 직접 스크립트 실행 시 실패하기 쉬움 → **모듈 실행** 권장:
  ```bash
  python -m mathpack.cli
  ```

### 실수 방지 요령

- 패키지 내부에서만 상대 import 사용.
- 실행 진입점은 `if __name__ == "__main__":` 또는 `__main__.py` + `python -m …`.

---

## 모듈 분리·인터페이스 구성

```bash
myproject/
├── src/
│   └── service/
│       ├── __init__.py   # 공개 API 표면
│       ├── user.py       # 내부 로직
│       └── auth.py       # 내부 로직
└── main.py
```

```python
# src/service/__init__.py

from .user import get_user
from .auth import login

__all__ = ["get_user", "login"]
```

```python
# main.py

from service import get_user, login
print(get_user(1))
```

- **단일 책임 원칙**: 모듈은 한 가지 역할.
- 파일명은 소문자/스네이크케이스: `math_utils.py`.

---

## 구조/레이아웃 패턴

### src/ 레이아웃 + pyproject (권장)

```bash
project/
├── pyproject.toml
├── src/
│   └── pkgname/
│       ├── __init__.py
│       └── core.py
└── tests/
    └── test_core.py
```

**pyproject.toml (modern setuptools 예시)**

```toml
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "pkgname"
version = "0.1.0"
description = "Example package"
readme = "README.md"
requires-python = ">=3.10"
license = { text = "MIT" }
authors = [{ name="Your Name", email="you@example.com" }]
dependencies = ["python-dotenv>=1.0"]

[project.urls]
Homepage = "https://github.com/you/pkgname"

[tool.setuptools]
package-dir = {"" = "src"}                 # src 레이아웃
packages = ["pkgname"]                     # 또는 find 사용

[tool.setuptools.package-data]
"pkgname" = ["py.typed"]                   # 타입힌트 배포 시
```

**타입힌트 패키징(라이브러리용)**: `src/pkgname/py.typed` 빈 파일 포함.

### 데이터/리소스 포함

```toml
[tool.setuptools.package-data]
"pkgname" = ["data/*.json", "templates/**/*.html"]
```

런타임 로딩(3.9+):

```python
from importlib import resources
data = resources.files("pkgname").joinpath("data/config.json").read_text(encoding="utf-8")
```

---

## CLI(엔트리 포인트)와 실행

### 콘솔 스크립트

```toml
[project.scripts]
pkg-cli = "pkgname.cli:main"
```

```python
# src/pkgname/cli.py

def main() -> None:
    print("hello from pkg-cli")
```

설치 후 바로:
```bash
pkg-cli
```

### 모듈 실행

```bash
python -m pkgname.cli
```

`__main__.py`를 두면 패키지 자체 실행도 가능:

```bash
python -m pkgname
```

---

## 빌드·배포·업로드

### 개발 설치 (editable)

```bash
pip install -e .
```

- 코드 수정 → 즉시 반영(개발 편의 최고)

### 빌드

```bash
pip install build
python -m build            # dist/*.whl, *.tar.gz 생성
```

### PyPI/TestPyPI 업로드

```bash
pip install twine
python -m twine upload --repository testpypi dist/*
# 확인 후

python -m twine upload dist/*
```

**계정·API 토큰 준비** 필요.

---

## 의존성/가상환경 관리

### venv (표준)

```bash
python -m venv .venv
# Windows: .venv\Scripts\activate
# macOS/Linux:

source .venv/bin/activate
pip install -r requirements.txt
```

`requirements.txt` 예:
```
requests>=2.32
python-dotenv>=1.0
```

### Poetry/Hatch(대안)

- 잠금 파일 포함, 배포/스クリپ트 연계 편리.
- 팀 합의에 맞춰 선택.

---

## 환경 변수·설정 관리

### `.env` + `python-dotenv`

```
# .env

DATABASE_URL=postgresql://user:pwd@host/db
DEBUG=false
SECRET_KEY=supersecret
```

```python
# src/pkgname/config.py

from dotenv import load_dotenv
import os

load_dotenv()  # .env 읽기
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///local.db")
DEBUG = os.getenv("DEBUG", "false").lower() == "true"
```

### pydantic-settings (권장)

```bash
pip install pydantic-settings
```

```python
# src/pkgname/settings.py

from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_prefix="APP_")
    database_url: str = "sqlite:///local.db"
    debug: bool = False
    secret_key: str

settings = Settings()
```

- **우선순위**: OS env > .env > 기본값
- 환경별 `.env.development`, `.env.production` 분리 + 배포 시에는 **OS 환경 변수** 우선 사용(비밀 유출 방지)

---

## 테스트·품질·CI

### pytest

```bash
pip install pytest
pytest -q
```

```python
# tests/test_add.py

from mathpack.add import add

def test_add():
    assert add(2, 3) == 5
```

### tox (멀티 파이썬/환경)

```ini
# tox.ini

[tox]
envlist = py310, py311

[testenv]
deps = pytest
commands = pytest -q
```

### pre-commit (정적 분석/포맷)

```bash
pip install pre-commit
pre-commit sample-config > .pre-commit-config.yaml
pre-commit install
```

- black/isort/ruff/mypy 등 추가

### GitHub Actions (간단 예)

```yaml
# .github/workflows/ci.yml

name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix: { python: ["3.10", "3.11"] }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: ${{ matrix.python }} }
      - run: python -m pip install -U pip
      - run: pip install -e .[test] pytest
      - run: pytest -q
```

---

## 순환 import·지연 로딩·실행 비용

### 순환 import 회피

- 공통 로직 상위로 올리기, 런타임 import, 타입힌트 전용 import:

```python
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .models import User

def use_user(u: "User") -> None:
    ...
```

### 지연 import (성능·시작시간 최적화)

```python
def heavy():
    import pandas as pd  # 필요할 때만
    ...
```

### 모듈 최상단 부작용 금지

- import 시 네트워크 호출/큰 파일 로딩/로그 폭주 X
- **함수 내부** 또는 `if __name__ == "__main__":`로 감싸기

---

## 배포 산출물·플랫폼

- **wheel(whl)**: 설치 빠르고 신뢰성 ↑ (가능하면 wheel 제공)
- **sdist**: 소스 배포 (pip가 빌드)
- 네이티브 확장(C/C++): 플랫폼별 wheel 필요(manylinux, macOS, win)

---

## 예시: 작은 패키지 풀셋

### 트리

```bash
my_package/
├── pyproject.toml
├── README.md
├── src/
│   └── my_package/
│       ├── __init__.py
│       ├── cli.py
│       ├── core.py
│       ├── data/
│       │   └── default.json
│       └── py.typed
└── tests/
    └── test_core.py
```

### 코드

```python
# src/my_package/__init__.py

from .core import add
__all__ = ["add"]
__version__ = "0.2.0"
```

```python
# src/my_package/core.py

def add(a: int, b: int) -> int:
    return a + b
```

```python
# src/my_package/cli.py

import argparse
from . import add, __version__

def main() -> None:
    p = argparse.ArgumentParser(prog="mycli")
    p.add_argument("a", type=int)
    p.add_argument("b", type=int)
    p.add_argument("-v", "--version", action="store_true")
    ns = p.parse_args()
    if ns.version:
        print(__version__)
        return
    print(add(ns.a, ns.b))
```

```toml
# pyproject.toml (modern setuptools)

[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "my-package-example"
version = "0.2.0"
description = "Small demo package"
readme = "README.md"
requires-python = ">=3.10"
dependencies = []

[project.scripts]
mycli = "my_package.cli:main"

[tool.setuptools]
package-dir = {"" = "src"}
packages = ["my_package"]

[tool.setuptools.package-data]
"my_package" = ["data/*.json", "py.typed"]
```

```python
# tests/test_core.py

from my_package import add
def test_add():
    assert add(1, 2) == 3
```

---

## 운영 환경 배포(요약)

- **서버 측**: 시스템 Python 대신 **가상환경** 사용.
- 환경 변수는 시스템 서비스(systemd, Docker, k8s Secret)에서 주입.
- 배포 전 빌드된 wheel 설치:
  ```bash
  pip install my_package_example-0.2.0-py3-none-any.whl
  ```
- **로그/설정/비밀 키**는 코드와 분리.

---

## 흔한 문제 & 해결

| 문제 | 원인 | 해결 |
|---|---|---|
| 상대 import 실패 | 스크립트 직접 실행 | `python -m 패키지.모듈` |
| 테스트가 로컬 코드 우연히 참조 | src 레이아웃 미사용 | `src/` 사용 + `pip install -e .` |
| build 후 데이터파일 누락 | package-data 누락 | `tool.setuptools.package-data` 설정 |
| 타입힌트 경고 | `py.typed` 없음 | `py.typed` 포함 |
| 시작 느림 | 최상단 무거운 import | 지연 import/함수 내부 로딩 |
| 순환 import | 상호 참조 구조 | 모듈 분리/런타임 import/TYPE_CHECKING |

---

## 요약

- **패키지 구조**: `src/` + 명시적 `__init__.py` + 공개 API(`__all__`)
- **import 원칙**: 절대 import 기본, 내부만 상대 import
- **설정/환경**: `.env`는 개발 편의, 운영은 OS env 우선
- **배포**: wheel/SDist 빌드 → TestPyPI 검증 → PyPI 게시
- **품질/자동화**: pytest + tox/nox + pre-commit + CI

---

## `setup.py` 레거시 예시 (참고용)

```python
# setup.py (현대 프로젝트는 pyproject.toml 권장)

from setuptools import setup, find_packages

setup(
    name="pkgname",
    version="0.1.0",
    package_dir={"": "src"},
    packages=find_packages("src"),
    install_requires=["python-dotenv>=1.0"],
    entry_points={"console_scripts": ["pkg-cli=pkgname.cli:main"]},
    include_package_data=True,
)
```

---

## MANIFEST.in (sdist 제어)

```
include README.md
recursive-include src/pkgname/data *.json
```

---

## `.gitignore` (요지)

```
.venv/
__pycache__/
*.pyc
dist/
build/
*.egg-info/
.env
```
