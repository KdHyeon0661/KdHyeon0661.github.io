---
layout: post
title: 파이썬 모듈과 패키지: 구조적인 코드 관리
date: 2024-08-15 19:20:23 +0900
category: Python
---
# 파이썬 모듈과 패키지: 구조적인 코드 관리

모듈과 패키지는 파이썬에서 코드를 조직화하고 재사용하는 핵심 개념입니다. 작은 스크립트에서 대규모 애플리케이션으로 발전할 때, 적절한 모듈화와 패키지 구조는 코드의 유지보수성과 확장성을 결정하는 중요한 요소가 됩니다. 이 글에서는 현대적인 파이썬 프로젝트에서 모듈과 패키지를 효과적으로 구성하는 방법을 실용적인 관점에서 살펴보겠습니다.

## 모듈의 기본: 코드 조직화의 시작

모듈은 파이썬 코드가 담긴 파일(.py)로, 관련된 기능을 하나의 단위로 묶습니다. 모듈을 사용하면 코드를 논리적으로 분리하고, 이름 공간을 관리하며, 재사용성을 높일 수 있습니다.

```python
# math_operations.py (모듈 예시)

def add(a, b):
    """두 수의 합을 반환합니다."""
    return a + b

def multiply(a, b):
    """두 수의 곱을 반환합니다."""
    return a * b

def calculate_average(numbers):
    """숫자 리스트의 평균을 계산합니다."""
    if not numbers:
        return 0
    return sum(numbers) / len(numbers)

# 모듈 내 테스트 코드
if __name__ == "__main__":
    # 모듈을 직접 실행할 때만 실행되는 코드
    print(f"2 + 3 = {add(2, 3)}")
    print(f"평균: {calculate_average([1, 2, 3, 4, 5])}")
```

위 모듈을 다른 파일에서 다음과 같이 사용할 수 있습니다:

```python
# main.py

import math_operations

result = math_operations.add(10, 20)
print(f"10 + 20 = {result}")

average = math_operations.calculate_average([85, 92, 78, 90])
print(f"평균 점수: {average}")

# 또는 필요한 함수만 import
from math_operations import multiply
product = multiply(5, 6)
print(f"5 × 6 = {product}")
```

## 패키지: 모듈의 컨테이너

프로젝트가 커지면서 여러 모듈을 조직화해야 할 때 패키지가 필요합니다. 패키지는 모듈을 담는 디렉터리로, `__init__.py` 파일을 포함합니다.

### 기본 패키지 구조

```bash
ecommerce/
├── __init__.py
├── cart.py
├── product.py
└── payment.py
```

`__init__.py` 파일은 패키지를 초기화하고 패키지 수준의 설정을 정의합니다. 이 파일이 비어있더라도 디렉터리를 패키지로 인식하게 만듭니다.

```python
# ecommerce/__init__.py

# 패키지 버전 정의
__version__ = "1.0.0"

# 공개할 API 명시
from .cart import Cart
from .product import Product
from .payment import process_payment

__all__ = ["Cart", "Product", "process_payment"]
```

각 모듈은 특정 기능을 담당합니다:

```python
# ecommerce/product.py

class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price
    
    def display_info(self):
        return f"{self.name}: ${self.price:.2f}"
```

```python
# ecommerce/cart.py

from .product import Product

class Cart:
    def __init__(self):
        self.items = []
    
    def add_item(self, product, quantity=1):
        self.items.append({"product": product, "quantity": quantity})
    
    def total(self):
        return sum(item["product"].price * item["quantity"] for item in self.items)
```

```python
# main.py

from ecommerce import Product, Cart

# 패키지 사용
laptop = Product("노트북", 1200.00)
mouse = Product("마우스", 25.00)

cart = Cart()
cart.add_item(laptop, 1)
cart.add_item(mouse, 2)

print(f"총액: ${cart.total():.2f}")
```

## 현대적인 프로젝트 구조: src 레이아웃

전통적인 패키지 구조 대신, 현대적인 파이썬 프로젝트에서는 `src` 레이아웃을 권장합니다. 이 구조는 테스트 중에 로컬 개발 코드가 실수로 import되는 문제를 방지합니다.

### src 레이아웃 예시

```bash
my_project/
├── pyproject.toml          # 프로젝트 설정
├── README.md               # 프로젝트 설명
├── src/                    # 소스 코드
│   └── my_package/
│       ├── __init__.py
│       ├── core.py
│       ├── utils.py
│       └── cli.py
├── tests/                  # 테스트 코드
│   ├── __init__.py
│   ├── test_core.py
│   └── test_utils.py
├── docs/                   # 문서
│   └── index.md
└── scripts/                # 유틸리티 스크립트
    └── setup_dev.py
```

### pyproject.toml 설정

`pyproject.toml`은 현대적인 파이썬 프로젝트의 표준 설정 파일입니다:

```toml
# pyproject.toml

[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "my-package"
version = "0.1.0"
description = "설명적인 패키지 설명"
readme = "README.md"
requires-python = ">=3.10"
license = {text = "MIT"}
authors = [
    {name = "개발자 이름", email = "email@example.com"}
]
dependencies = [
    "requests>=2.32",
    "python-dotenv>=1.0",
]

[project.optional-dependencies]
dev = ["pytest", "black", "mypy"]
test = ["pytest", "pytest-cov"]

[project.scripts]
mycli = "my_package.cli:main"

[tool.setuptools]
package-dir = {"" = "src"}
packages = ["my_package"]

[tool.setuptools.package-data]
"my_package" = ["data/*.json", "templates/*.html", "py.typed"]

[project.urls]
Homepage = "https://github.com/username/my-package"
Repository = "https://github.com/username/my-package.git"
```

## Import 전략: 절대 import와 상대 import

### 절대 import (권장)

절대 import는 전체 경로를 사용하여 모듈을 import하는 방식입니다:

```python
# src/my_package/core.py
from my_package.utils import helper_function
from external_package import SomeClass
```

장점:
- 코드의 위치가 변경되어도 import 경로가 유효함
- IDE와 정적 분석 도구에서 더 잘 이해함
- 가독성이 높음

### 상대 import (패키지 내부에서만 사용)

상대 import는 현재 모듈의 위치를 기준으로 다른 모듈을 import합니다:

```python
# src/my_package/submodule/feature.py
from ..utils import helper_function  # 상위 디렉터리의 utils 모듈
from .helpers import specific_helper  # 같은 디렉터리의 helpers 모듈
```

주의사항:
- 패키지 외부에서 직접 실행하면 실패할 수 있음
- 모듈 구조 변경 시 import 경로도 함께 변경해야 함
- 가능하면 절대 import를 우선적으로 사용

### 모듈 실행 방식

모듈을 실행할 때는 다음과 같은 방식을 사용하는 것이 좋습니다:

```bash
# 잘못된 방식 (상대 import 문제 발생 가능)
python src/my_package/cli.py

# 올바른 방식
python -m my_package.cli
```

`__main__.py` 파일을 사용하면 패키지를 직접 실행할 수도 있습니다:

```python
# src/my_package/__main__.py
from .cli import main

if __name__ == "__main__":
    main()
```

```bash
# 패키지 직접 실행
python -m my_package
```

## 의존성 관리와 가상환경

### 가상환경 생성과 관리

```bash
# 가상환경 생성
python -m venv .venv

# 활성화 (Windows)
.venv\Scripts\activate

# 활성화 (macOS/Linux)
source .venv/bin/activate

# 의존성 설치
pip install -e .  # 개발 모드 설치
pip install -e ".[dev]"  # 개발 의존성 포함 설치
```

### 의존성 파일

`requirements.txt` 또는 `pyproject.toml`을 사용하여 의존성을 관리합니다:

```txt
# requirements.txt
requests>=2.32.0
pandas>=2.0.0
numpy>=1.24.0
python-dotenv>=1.0.0
```

```bash
# 의존성 설치
pip install -r requirements.txt

# 의존성 목록 생성
pip freeze > requirements.txt
```

## 환경 변수와 설정 관리

### 환경 변수 사용

```python
# config.py
import os
from dotenv import load_dotenv

# .env 파일 로드
load_dotenv()

# 환경 변수 읽기
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///default.db")
DEBUG = os.getenv("DEBUG", "false").lower() == "true"
API_KEY = os.getenv("API_KEY")

# 필수 환경 변수 검증
if not API_KEY:
    raise ValueError("API_KEY 환경 변수가 설정되지 않았습니다.")
```

`.env` 파일 예시:

```env
# .env
DATABASE_URL=postgresql://user:password@localhost/mydb
DEBUG=true
API_KEY=your_api_key_here
SECRET_KEY=super_secret_key
```

### Pydantic Settings (고급 설정 관리)

```python
# settings.py
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Optional

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        env_prefix="APP_",
        case_sensitive=False
    )
    
    database_url: str = "sqlite:///local.db"
    debug: bool = False
    api_key: Optional[str] = None
    log_level: str = "INFO"
    
    # 복합 설정
    @property
    def is_production(self) -> bool:
        return not self.debug

# 설정 인스턴스 생성
settings = Settings()

# 사용 예시
print(f"데이터베이스: {settings.database_url}")
print(f"프로덕션 모드: {settings.is_production}")
```

## 테스트와 코드 품질

### 테스트 구조

```python
# tests/test_core.py
import pytest
from my_package.core import process_data

def test_process_data_with_valid_input():
    """유효한 입력으로 데이터 처리 테스트"""
    result = process_data([1, 2, 3, 4, 5])
    assert result == 15
    assert isinstance(result, int)

def test_process_data_with_empty_list():
    """빈 리스트 입력 테스트"""
    result = process_data([])
    assert result == 0

def test_process_data_with_invalid_input():
    """잘못된 입력 타입 테스트"""
    with pytest.raises(TypeError):
        process_data("not a list")

@pytest.mark.parametrize("input_list,expected", [
    ([1, 2, 3], 6),
    ([10, 20, 30], 60),
    ([-1, 0, 1], 0),
])
def test_process_data_parametrized(input_list, expected):
    """매개변수화된 테스트"""
    result = process_data(input_list)
    assert result == expected
```

### 테스트 실행

```bash
# 기본 테스트 실행
pytest

# 상세 출력
pytest -v

# 특정 테스트만 실행
pytest tests/test_core.py::test_process_data_with_valid_input

# 커버리지 리포트
pytest --cov=my_package tests/

# 병렬 실행
pytest -n auto
```

### 코드 품질 도구

```bash
# 코드 포맷팅 (black)
black src/ tests/

# import 정렬 (isort)
isort src/ tests/

# 린팅 (ruff)
ruff check src/ tests/

# 타입 체크 (mypy)
mypy src/

# 보안 취약점 검사 (bandit)
bandit -r src/
```

## 패키지 빌드와 배포

### 패키지 빌드

```bash
# 빌드 도구 설치
pip install build

# 패키지 빌드
python -m build

# 결과 확인
ls dist/
# my_package-0.1.0-py3-none-any.whl
# my_package-0.1.0.tar.gz
```

### PyPI에 배포

```bash
# 업로드 도구 설치
pip install twine

# TestPyPI에 업로드 (테스트용)
python -m twine upload --repository testpypi dist/*

# 실제 PyPI에 업로드
python -m twine upload dist/*
```

### 버전 관리 전략

```python
# src/my_package/__init__.py

# 단일 진실 공급원(SSOT)으로 버전 관리
__version__ = "1.2.3"
__version_info__ = (1, 2, 3)
```

버전 번호는 [시멘틱 버저닝](https://semver.org/lang/ko/)을 따르는 것이 좋습니다:
- **주 버전(Major)**: 호환되지 않는 API 변경
- **부 버전(Minor)**: 이전 버전과 호환되는 기능 추가
- **수 버전(Patch)**: 이전 버전과 호환되는 버그 수정

## 고급 패턴과 모범 사례

### 네임스페이스 패키지

여러 위치에 분산된 패키지를 하나처럼 사용할 수 있게 합니다:

```python
# 디렉터리 구조
company_product/
├── component_a/
│   └── company/
│       └── product/
│           └── feature_a.py
└── component_b/
    └── company/
        └── product/
            └── feature_b.py

# 사용
import company.product.feature_a
import company.product.feature_b
```

### 지연 로딩(Lazy Loading)

```python
# lazy_module.py
class HeavyModule:
    """무거운 모듈을 지연 로딩하는 예시"""
    
    def __init__(self):
        self._data = None
    
    @property
    def data(self):
        if self._data is None:
            # 실제 필요할 때만 import
            import pandas as pd
            import numpy as np
            
            # 무거운 작업 수행
            self._data = pd.DataFrame(np.random.randn(1000, 1000))
        return self._data
    
    def process(self):
        """데이터 처리"""
        return self.data.mean().mean()

# 사용
module = HeavyModule()
# 이 시점에는 pandas, numpy가 로드되지 않음
result = module.process()  # 이때 로드됨
```

### 순환 참조(Circular Import) 해결

```python
# module_a.py
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    # 타입 체킹을 위한 import (런타임에는 로드되지 않음)
    from module_b import ClassB

class ClassA:
    def process(self, b: "ClassB") -> str:
        return f"Processing {b}"
```

```python
# module_b.py
class ClassB:
    def __init__(self):
        # 런타임에 필요한 경우에만 import
        from module_a import ClassA
        self.helper = ClassA()
```

### 플러그인 아키텍처

```python
# plugin_base.py
import importlib
from abc import ABC, abstractmethod
from typing import Dict, List

class Plugin(ABC):
    """플러그인 기본 클래스"""
    
    @abstractmethod
    def execute(self, data):
        """플러그인 실행"""
        pass

class PluginManager:
    """플러그인 관리자"""
    
    def __init__(self):
        self.plugins: Dict[str, Plugin] = {}
    
    def register_plugin(self, name: str, plugin: Plugin):
        """플러그인 등록"""
        self.plugins[name] = plugin
    
    def load_plugins(self, plugin_paths: List[str]):
        """플러그인 동적 로드"""
        for path in plugin_paths:
            module_name, class_name = path.rsplit(".", 1)
            module = importlib.import_module(module_name)
            plugin_class = getattr(module, class_name)
            plugin_instance = plugin_class()
            self.register_plugin(plugin_class.__name__, plugin_instance)
    
    def execute_all(self, data):
        """모든 플러그인 실행"""
        results = {}
        for name, plugin in self.plugins.items():
            results[name] = plugin.execute(data)
        return results
```

```python
# plugins/uppercase_plugin.py
from plugin_base import Plugin

class UppercasePlugin(Plugin):
    def execute(self, data):
        return str(data).upper()

# plugins/reverse_plugin.py
from plugin_base import Plugin

class ReversePlugin(Plugin):
    def execute(self, data):
        return str(data)[::-1]

# 사용
manager = PluginManager()
manager.load_plugins([
    "plugins.uppercase_plugin.UppercasePlugin",
    "plugins.reverse_plugin.ReversePlugin"
])

results = manager.execute_all("hello world")
print(results)  # {'UppercasePlugin': 'HELLO WORLD', 'ReversePlugin': 'dlrow olleh'}
```

## 실전 예제: 데이터 처리 패키지

다음은 실제 프로젝트에서 사용할 수 있는 데이터 처리 패키지의 완전한 예시입니다:

### 프로젝트 구조

```bash
data_processor/
├── pyproject.toml
├── README.md
├── src/
│   └── dataprocessor/
│       ├── __init__.py
│       ├── core.py
│       ├── transformers.py
│       ├── validators.py
│       ├── exporters.py
│       └── cli.py
├── tests/
│   ├── __init__.py
│   ├── test_core.py
│   ├── test_transformers.py
│   └── test_validators.py
├── examples/
│   └── basic_usage.py
└── data/
    └── sample.csv
```

### 핵심 코드

```python
# src/dataprocessor/__init__.py
"""
데이터 처리 패키지

이 패키지는 다양한 형식의 데이터를 처리, 변환, 검증, 내보내기 기능을 제공합니다.
"""

__version__ = "1.0.0"
__author__ = "데이터 팀"

from .core import DataProcessor, DataPipeline
from .transformers import (
    ColumnRenamer,
    TypeConverter,
    MissingValueHandler,
    StandardScaler
)
from .validators import (
    SchemaValidator,
    RangeValidator,
    PatternValidator
)
from .exporters import CSVExporter, JSONExporter, SQLExporter

__all__ = [
    "DataProcessor",
    "DataPipeline",
    "ColumnRenamer",
    "TypeConverter",
    "MissingValueHandler",
    "StandardScaler",
    "SchemaValidator",
    "RangeValidator",
    "PatternValidator",
    "CSVExporter",
    "JSONExporter",
    "SQLExporter",
]
```

```python
# src/dataprocessor/core.py
from typing import List, Dict, Any, Optional
from pathlib import Path
import pandas as pd
from .transformers import BaseTransformer
from .validators import BaseValidator
from .exporters import BaseExporter

class DataProcessor:
    """데이터 처리기 기본 클래스"""
    
    def __init__(self, data: pd.DataFrame):
        self.data = data
        self.transformers: List[BaseTransformer] = []
        self.validators: List[BaseValidator] = []
    
    def add_transformer(self, transformer: BaseTransformer):
        """변환기 추가"""
        self.transformers.append(transformer)
        return self
    
    def add_validator(self, validator: BaseValidator):
        """검증기 추가"""
        self.validators.append(validator)
        return self
    
    def process(self) -> pd.DataFrame:
        """데이터 처리 실행"""
        # 검증 실행
        for validator in self.validators:
            if not validator.validate(self.data):
                raise ValueError(f"검증 실패: {validator.__class__.__name__}")
        
        # 변환 실행
        processed_data = self.data.copy()
        for transformer in self.transformers:
            processed_data = transformer.transform(processed_data)
        
        return processed_data

class DataPipeline:
    """데이터 파이프라인"""
    
    def __init__(self):
        self.steps: List[Dict[str, Any]] = []
    
    def add_step(self, name: str, processor: DataProcessor):
        """처리 단계 추가"""
        self.steps.append({"name": name, "processor": processor})
    
    def execute(self, initial_data: pd.DataFrame) -> pd.DataFrame:
        """파이프라인 실행"""
        current_data = initial_data
        
        for step in self.steps:
            print(f"실행 중: {step['name']}")
            processor = step["processor"]
            processor.data = current_data
            current_data = processor.process()
        
        return current_data
    
    def export(self, data: pd.DataFrame, exporter: BaseExporter, 
               output_path: Path):
        """데이터 내보내기"""
        exporter.export(data, output_path)
```

```python
# src/dataprocessor/cli.py
import argparse
import sys
from pathlib import Path
import pandas as pd
from . import DataProcessor, DataPipeline
from .transformers import ColumnRenamer, TypeConverter
from .exporters import CSVExporter

def main():
    """CLI 진입점"""
    parser = argparse.ArgumentParser(
        description="데이터 처리 패키지 명령행 인터페이스"
    )
    parser.add_argument("input", help="입력 파일 경로")
    parser.add_argument("output", help="출력 파일 경로")
    parser.add_argument("--rename", nargs=2, action="append",
                       metavar=("OLD", "NEW"),
                       help="컬럼 이름 변경 (OLD NEW)")
    parser.add_argument("--convert", nargs=2, action="append",
                       metavar=("COLUMN", "TYPE"),
                       help="컬럼 타입 변환")
    parser.add_argument("-v", "--version", action="store_true",
                       help="버전 정보 출력")
    
    args = parser.parse_args()
    
    if args.version:
        from . import __version__
        print(f"Data Processor v{__version__}")
        return
    
    try:
        # 데이터 읽기
        input_path = Path(args.input)
        if not input_path.exists():
            print(f"오류: 입력 파일을 찾을 수 없습니다: {args.input}")
            sys.exit(1)
        
        data = pd.read_csv(input_path)
        
        # 데이터 처리기 생성
        processor = DataProcessor(data)
        
        # 컬럼 이름 변경
        if args.rename:
            rename_map = {old: new for old, new in args.rename}
            processor.add_transformer(ColumnRenamer(rename_map))
        
        # 타입 변환
        if args.convert:
            for column, dtype in args.convert:
                processor.add_transformer(TypeConverter({column: dtype}))
        
        # 처리 실행
        processed_data = processor.process()
        
        # 결과 저장
        output_path = Path(args.output)
        exporter = CSVExporter()
        exporter.export(processed_data, output_path)
        
        print(f"처리 완료: {len(processed_data)}행")
        print(f"결과 저장: {output_path}")
        
    except Exception as e:
        print(f"오류 발생: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

```python
# tests/test_core.py
import pytest
import pandas as pd
import numpy as np
from dataprocessor import DataProcessor
from dataprocessor.transformers import ColumnRenamer

def test_data_processor_initialization():
    """데이터 처리기 초기화 테스트"""
    data = pd.DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
    processor = DataProcessor(data)
    
    assert len(processor.data) == 3
    assert list(processor.data.columns) == ["A", "B"]
    assert len(processor.transformers) == 0
    assert len(processor.validators) == 0

def test_data_processor_with_transformer():
    """변환기 포함 데이터 처리 테스트"""
    data = pd.DataFrame({"old_name": [1, 2, 3]})
    processor = DataProcessor(data)
    
    # 컬럼 이름 변경 변환기 추가
    processor.add_transformer(ColumnRenamer({"old_name": "new_name"}))
    
    # 처리 실행
    result = processor.process()
    
    assert "new_name" in result.columns
    assert "old_name" not in result.columns
    assert len(result) == 3

def test_data_processor_empty_data():
    """빈 데이터 처리 테스트"""
    data = pd.DataFrame()
    processor = DataProcessor(data)
    
    result = processor.process()
    
    assert len(result) == 0
    assert len(result.columns) == 0

def test_data_processor_invalid_transformer():
    """잘못된 변환기 테스트"""
    data = pd.DataFrame({"A": [1, 2, 3]})
    processor = DataProcessor(data)
    
    # None을 변환기로 추가 시도
    with pytest.raises(AttributeError):
        processor.add_transformer(None)
```

### 패키지 사용 예시

```python
# examples/basic_usage.py
import pandas as pd
from dataprocessor import DataProcessor, DataPipeline
from dataprocessor.transformers import (
    ColumnRenamer, 
    TypeConverter, 
    MissingValueHandler
)
from dataprocessor.validators import SchemaValidator
from dataprocessor.exporters import CSVExporter

# 샘플 데이터 생성
data = pd.DataFrame({
    "User_ID": [1, 2, 3, 4, 5],
    "Name": ["Alice", "Bob", "Charlie", None, "Eve"],
    "Age": [25, 30, None, 35, 40],
    "Score": ["85", "92", "78", "88", "95"]
})

print("원본 데이터:")
print(data)
print()

# 데이터 처리기 생성
processor = DataProcessor(data)

# 변환기 추가
processor.add_transformer(
    ColumnRenamer({"User_ID": "id", "Name": "name"})
).add_transformer(
    TypeConverter({"Score": "int"})
).add_transformer(
    MissingValueHandler({"Age": "mean", "name": "Unknown"})
)

# 검증기 추가
schema = {
    "id": "int",
    "name": "str",
    "Age": "float",
    "Score": "int"
}
processor.add_validator(SchemaValidator(schema))

# 데이터 처리
try:
    processed_data = processor.process()
    print("처리된 데이터:")
    print(processed_data)
    print(f"\n데이터 형태: {processed_data.shape}")
    
    # 결과 저장
    exporter = CSVExporter()
    exporter.export(processed_data, "processed_data.csv")
    print("\n결과가 'processed_data.csv'에 저장되었습니다.")
    
except Exception as e:
    print(f"처리 중 오류 발생: {e}")
```

## 결론

효과적인 모듈과 패키지 구조는 파이썬 프로젝트의 성공을 결정하는 중요한 요소입니다. 잘 구성된 패키지 구조는 다음과 같은 이점을 제공합니다:

1. **유지보수성**: 논리적으로 분리된 모듈은 이해하기 쉽고 수정하기 편리합니다.
2. **재사용성**: 잘 설계된 패키지는 다른 프로젝트에서 쉽게 재사용할 수 있습니다.
3. **테스트 용이성**: 독립적인 모듈은 단위 테스트 작성이 쉽습니다.
4. **협업 효율성**: 명확한 구조와 인터페이스는 팀 협업을 원활하게 합니다.
5. **확장성**: 모듈화된 구조는 새로운 기능 추가가 용이합니다.

프로젝트를 시작할 때부터 적절한 구조를 고려하는 것이 중요합니다. 작은 프로젝트라도 `src` 레이아웃과 `pyproject.toml`을 사용하는 습관을 들이면, 프로젝트가 커졌을 때 구조 변경에 소요되는 비용을 크게 줄일 수 있습니다.

기억해야 할 핵심 원칙은 다음과 같습니다:
- **단일 책임**: 각 모듈은 하나의 명확한 책임을 가져야 합니다.
- **명시적 인터페이스**: `__all__`을 사용하여 공개 API를 명시적으로 정의하세요.
- **의존성 최소화**: 모듈 간 의존성을 최소화하고 순환 참조를 피하세요.
- **구성 가능성**: 작은 모듈을 조합하여 복잡한 기능을 구성할 수 있도록 설계하세요.
- **테스트 용이성**: 모듈이 독립적으로 테스트 가능하도록 설계하세요.

이러한 원칙들을 따르면 시간이 지나도 관리하기 쉬운, 견고하고 확장 가능한 파이썬 프로젝트를 구축할 수 있을 것입니다.