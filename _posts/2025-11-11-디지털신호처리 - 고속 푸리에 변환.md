---
layout: post
title: 디지털신호처리 - 고속 푸리에 변환
date: 2025-11-11 20:25:23 +0900
category: 디지털신호처리
---
# 고속 푸리에 변환(FFT)

## 0. 개관 — 왜 FFT인가

DFT 직접 계산의 복잡도는
$$
\mathcal{O}(N^2).
$$
FFT는 지수항의 **대칭/주기성**을 체계적으로 재사용해
$$
\mathcal{O}(N\log_2 N)
$$
으로 감소시킨다. 핵심 개념은 (1) 작은 DFT로 **재귀 분할**, (2) **트위들 팩터** \(W_N^k=e^{-j2\pi k/N}\) 재사용, (3) **버터플라이** 연산으로 부분 결과를 결합하는 것이다. 아래에서는 Radix-2 Cooley–Tukey부터 Bluestein, 혼합 기수, 2D, 수치/성능/고정소수점까지 단계적으로 확장한다.

---

## 1. 수학적 기반 — DFT와 트위들 대칭

길이 \(N\) 시퀀스 \(x[n]\)의 DFT/IDFT:
$$
X[k]=\sum_{n=0}^{N-1}x[n]\,W_N^{kn},\qquad
x[n]=\frac{1}{N}\sum_{k=0}^{N-1}X[k]\,W_N^{-kn},
$$
여기서 \(W_N=e^{-j2\pi/N}\).

트위들의 성질:
- \(W_N^{k+N}=W_N^k\) (주기성)
- 짝수 \(N\)에서 \(W_N^{k+N/2}=-W_N^k\) (부호 반전)
- \(W_N^{2k}=W_{N/2}^k\) (반크기와 연동)

이 성질이 **부분 DFT로의 분해**를 가능하게 한다.

---

## 2. Cooley–Tukey Radix-2: DIT 유도 (정석)

\(N=2M\)이라 하자. 샘플을 짝/홀로 분해:
\[
x_e[m]=x[2m],\qquad x_o[m]=x[2m+1],\quad m=0,\dots,M-1.
\]
그럼
\[
\begin{aligned}
X[k]
&=\sum_{m=0}^{M-1}x[2m]\,W_N^{k(2m)}+\sum_{m=0}^{M-1}x[2m+1]\,W_N^{k(2m+1)} \\
&=E[k] + W_N^k\,O[k],
\end{aligned}
\]
단,
\[
E[k]=\sum_{m=0}^{M-1}x_e[m]\,W_M^{km},\qquad
O[k]=\sum_{m=0}^{M-1}x_o[m]\,W_M^{km}.
\]
또한
\[
X[k+M]=E[k]-W_N^k\,O[k].
\]
따라서 한 단계 **버터플라이**:
\[
\boxed{
X[k]=E[k]+W_N^k O[k],\quad X[k+M]=E[k]-W_N^k O[k]
}
\]
이 과정을 \(M\gets M/2\)로 줄이며 \(\log_2 N\) 단계 반복하면 전체 FFT가 완성된다. 이 방식이 **DIT(Decimation-in-Time)**.

---

## 3. DIF(Decimation-in-Frequency) — 대칭 형제

DIF는 **출력**을 먼저 반으로 나누고 입력을 나중에 섞는다. 버터플라이 구조가 달라지고, **비트역전** 정렬의 위치가 DIT와 반대가 된다. 계산량은 동일하며 캐시/파이프라인에 따라 구현 상 이점이 갈린다.

---

## 4. 버터플라이·비트역전·Stockham

### 4.1 버터플라이 기본형
DIT 스테이지의 원자 연산:
\[
(a,b)\ \mapsto\ (a+W\,b,\ a-W\,b),\quad W=W_N^{k}.
\]

### 4.2 비트역전(bit reversal)
DIT를 **in-place**로 구현하려면 입력을 **비트역전 순서**로 재배열하면 최종 출력이 자연 순서가 된다. 예: \(N=8\)에서 인덱스 3비트를 역전.

### 4.3 Stockham 자동정렬
Stockham은 단계마다 입력/출력 버퍼를 교차 사용해 **매 단계 결과가 정렬 상태**가 되도록 한다. 비트역전 없이 자연 순서 입출력을 달성하고 **스트라이드 불균일**을 줄여 캐시 친화적이다.

---

## 5. GNU Octave — Radix-2 DIT FFT 구현과 검증

### 5.1 비트역전 함수
```octave
function y = bitrev_permute(x)
  N = numel(x);
  b = log2(N);
  if mod(b,1) ~= 0, error("N must be power of two"); end
  y = zeros(size(x));
  for n = 0:N-1
    r = 0; t = n;
    for i = 1:b
      r = bitshift(r, 1) + bitand(t, 1);
      t = bitshift(t, -1);
    end
    y(r+1) = x(n+1);
  end
end
```

### 5.2 반복형 Radix-2 DIT FFT
```octave
function X = myfft_radix2(x)
  x = x(:).';                    % row
  N = numel(x);
  if N == 0, X = []; return; end
  if bitand(N, N-1) ~= 0, error("N must be power of two"); end

  % 1) 비트역전 입력
  X = bitrev_permute(x);

  % 2) 스테이지 반복
  m = 2;
  while m <= N
    half = m/2;
    Wm = exp(-1j*2*pi*(0:half-1)/m);       % twiddles of this stage
    for k = 1:m:N
      idx1 = k:(k+half-1);
      idx2 = (k+half):(k+m-1);
      t = Wm .* X(idx2);
      u = X(idx1);
      X(idx1) = u + t;
      X(idx2) = u - t;
    end
    m *= 2;
  endwhile
end
```

### 5.3 IFFT (컨주게이트 대칭 활용)
```octave
function x = myifft_radix2(X)
  N = numel(X);
  x = conj(myfft_radix2(conj(X)));
  x = x / N;
end
```

### 5.4 참조 FFT와 정확도 검증
```octave
clear; close all; clc
N = 1024; x = randn(1,N) + 1j*randn(1,N);
X_ref = fft(x);          X_my = myfft_radix2(x);
printf("FFT  rel-err = %.3e\n", norm(X_ref - X_my)/norm(X_ref));
x_ref = ifft(X_ref);     x_my = myifft_radix2(X_ref);
printf("IFFT rel-err = %.3e\n", norm(x_ref - x_my)/norm(x_ref));
```

---

## 6. 복잡도·연산 카운트·캐시 패턴

Radix-2 DIT의 총 연산량(복소):
- 곱: \(\frac{N}{2}\log_2 N\)
- 합: \(N\log_2 N\)

초기 스테이지는 **스트라이드가 커** 캐시 미스가 늘 수 있다. Stockham, 블록형 알고리즘, 루프 타일링/전치(transpose)로 완화한다.

---

## 7. Radix-4·혼합 기수·소인수 분해

### 7.1 Radix-4
\(N=4^p\)이면 4점 DFT(고정 매트릭스)를 기본 블록으로 사용해 복소 곱 일부를 **덜** 사용한다. 실전 라이브러리는 Radix-2/4를 혼용하거나 하이브리드로 최적화한다.

### 7.2 혼합 기수(Cooley–Tukey 일반형)
\(N=N_1N_2\)로 분해 가능하면
\[
n = n_1 + N_1 n_2,\quad k = k_1 N_2 + k_2
\]
치환으로 \(N_1\)-점과 \(N_2\)-점 FFT로 분해한다. 소인수(2·3·5·7 등) 조합에서 강력하다.

### 7.3 소인수 서로소일 때: Good–Thomas(참고)
\(N_1,N_2\)가 서로소이면 **중국인의 나머지 정리(CRT)**로 **트위들 없이** 인덱스 재배열만으로 2D형으로 분해 가능하다(메모리 주소 복잡성은 증가).

---

## 8. 소수 길이/임의 길이: Bluestein(Chirp-Z) FFT

### 8.1 아이디어와 등식
임의 \(N\) (특히 **소수**)에서 DFT를 **선형 컨볼루션**으로 환원:
\[
\begin{aligned}
X[k] &= \sum_{n=0}^{N-1} x[n]\,e^{-j\frac{2\pi}{N}kn}
= e^{-j\pi k^2/N}\sum_{n=0}^{N-1}\Big(x[n]e^{-j\pi n^2/N}\Big)\,e^{+j\pi(n-k)^2/N}.
\end{aligned}
\]
따라서 \(a[n]=x[n]e^{-j\pi n^2/N}\), \(b[m]=e^{+j\pi m^2/N}\) (단, \(m=-(N-1),\dots,(N-1)\))에 대해
\[
c[k]=\sum_{n} a[n]\ b[k-n]\quad\Rightarrow\quad X[k]=e^{-j\pi k^2/N}\,c[k].
\]
\(c\)는 길이 \(2N-1\)의 선형 컨볼루션 → **제로패딩 FFT 두 번**으로 계산.

### 8.2 실전형 Octave 구현(정렬/패딩 엄밀)
```octave
function X = bluestein_fft(x)
  % 임의 길이 N의 FFT를 Bluestein(Chirp-Z)으로 계산
  x = x(:).';
  N = numel(x);
  n = 0:N-1;

  % 1) chirp 곱 (프리/포스트)
  w = exp(-1j*pi*(n.^2)/N);      % pre/post 공통
  a = x .* w;                    % a[n] = x[n] * e^{-j*pi*n^2/N}

  % 2) b: 길이 2N-1의 대칭 chirp 시퀀스를 길이 P로 임베딩
  L = 2*N - 1;
  P = 2^nextpow2(L);             % FFT 길이
  b = zeros(1, P);
  b(1:N) = exp( 1j*pi*((0:N-1).^2)/N );          % b[0..N-1]
  b(P-N+2:P) = exp( 1j*pi*((N-1:-1:1).^2)/N );   % b[-(N-1)..-1]을 꼬리로

  % 3) 선형 컨볼루션: ifft(fft(a,P) .* fft(b))
  A = fft([a, zeros(1, P - N)]);
  B = fft(b);
  C = ifft(A .* B);

  % 4) 필요한 구간 취득 + post chirp
  c = C(1:N);                     % k=0..N-1 구간
  X = w .* c;                     % X[k] = e^{-j*pi*k^2/N} * c[k]
end
```

### 8.3 정확도 검증
```octave
clear; close all; clc
for N=[30, 97, 256, 1000]     % 97: 소수 길이
  x = randn(1,N) + 1j*randn(1,N);
  X_ref = fft(x);
  X_bz  = bluestein_fft(x);
  fprintf("N=%4d | rel-err=%.3e\n", N, norm(X_ref - X_bz)/norm(X_ref));
end
```

> 주: 위 임베딩은 \(2N\!-\!1\) 길이 chirp를 **원형 컨볼루션과 충돌 없이** 담도록 앞/뒤에 대칭 배치한다. 실무에서는 상수 팩터/오프셋을 사전/사후에 흡수해 부동 오차를 더 낮추기도 한다. Rader도 대안이지만 구현 난이도/메모리 패턴이 다르다.

---

## 9. 실수 입력 최적화(rFFT)와 “2-in-1” 트릭

실수 \(x[n]\)의 DFT는 켤레대칭:
\[
X[k]=X^\ast[(-k)\!\!\mod N].
\]
따라서 **절반 스펙트럼**만 계산/보관하면 된다.

또한 **두 개의 실수 시퀀스** \(a,b\)를 하나의 복소 시퀀스 \(u=a+j\,b\)로 묶어 **복소 FFT 1회**로 두 실수 FFT를 얻는 트릭:
\[
\begin{aligned}
U &= \mathrm{FFT}\{a+j\,b\},\\
\mathrm{FFT}\{a\} &= \tfrac{1}{2}\big(U + U^\ast_{\text{rev}}\big),\quad
\mathrm{FFT}\{b\} = \tfrac{1}{2j}\big(U - U^\ast_{\text{rev}}\big),
\end{aligned}
\]
여기서 \(U^\ast_{\text{rev}}\)는 켤레대칭을 이용해 인덱스를 반전한 벡터.

```octave
clear; close all; clc
N=2048; a=randn(1,N); b=randn(1,N);
u = a + 1j*b; U = fft(u);
Urev = conj([U(1), U(end:-1:2)]);
A_est = 0.5*(U + Urev);
B_est = (U - Urev)/(2j);
printf("2-in-1 err A = %.3e, B = %.3e\n", norm(A_est-fft(a))/norm(fft(a)), ...
                                         norm(B_est-fft(b))/norm(fft(b)));
```

---

## 10. 2D/다차원 FFT — 행/열 순차 FFT

2D-DFT는 행/열에 대한 1D FFT를 **두 번** 수행하면 된다:
\[
\mathcal{F}_{2D}\{A\} = \mathcal{F}_{\text{행}}\big(\mathcal{F}_{\text{열}}(A)\big).
\]

```octave
clear; close all; clc
M=128; N=256; A = randn(M,N);
F = fft( fft(A, [], 2), [], 1 );            % 열→행
R = ifft( ifft(F, [], 1), [], 2 );
printf("2D recon rel-err = %.3e\n", norm(A-R)/norm(A));
```

응용: 이미지 저역통과(원형 마스크) 등은 `fftshift`/`ifftshift`로 중심정렬 후 마스크 곱.

---

## 11. 성능 튜닝 — 크기·배치·캐시·평균

- **크기 선택**: \(2^p\)가 유리하나 FFTW류는 혼합 기수도 잘 최적화.
- **배치 FFT**: 프레임을 행렬로 쌓아 **벡터화**.
- **캐시/스트라이드**: 연속 메모리 접근을 유지. 필요 시 전치/Stockham을 사용.
- **스펙트럼 평균**: Welch 방식으로 분산 감소.
- **제로패딩**: 보간(해상도 증가 아님).

```octave
clear; close all; clc
N=2048; B=100; X = randn(B,N);
tic; Y = fft(X, [], 2); t=toc;
printf("Batched FFT: B=%d, N=%d, time=%.3fs\n", B, N, t);
```

---

## 12. 수치 정확도·스케일·Parseval

Octave의 `ifft`는 자동으로 \(1/N\)을 곱한다(정방향 1, 역방향 \(1/N\)). Parseval:
\[
\sum_n|x[n]|^2=\frac{1}{N}\sum_k|X[k]|^2.
\]
부동오차는 대략 \(\mathcal{O}(\epsilon\log N)\).

```octave
clear; close all; clc
N=8192; x=randn(1,N);
X=fft(x); xr=ifft(X);
e = norm(x - xr)/norm(x);
p1 = sum(abs(x).^2); p2 = (1/N)*sum(abs(X).^2);
printf("rel recon err=%.3e | Parseval diff=%.3e\n", e, abs(p1-p2));
```

---

## 13. 고정소수점/정수 FFT — 현업 관점 체크리스트

- **스테이지 스케일링**: 매 스테이지 1비트 쉬프트 등으로 **오버플로 방지**.
- **포화/라운딩 규칙**: 플랫폼( SIMD/DSP ) 일관성 유지.
- **트위들 정밀도**: Q-format 테이블의 비트폭이 SNR에 직접 영향.
- **블록 부동(BFP)**: 프레임 공통 지수로 동적범위 확보(코덱/무선 표준에서 보편).

(Octave는 부동이므로 개념만 제시.)

---

## 14. Stockham 한 스텝 데모(개념) — 비트역전 없는 흐름

```octave
function y = stockham_once(x)
  % 단일 스테이지 데모: 크기 N=2M, 짝/홀 섞기
  x = x(:).'; N=numel(x); M=N/2;
  if mod(N,2), error("N must be even"); end
  n = 0:M-1;
  W = exp(-1j*2*pi*n/N);      % 스테이지 twiddle
  % 입력을 짝/홀로 interleave하여 출력은 자연 정렬
  a = x(1:2:end); b = x(2:2:end);
  y = zeros(size(x));
  y(1:M)   = a + W.*b;
  y(M+1:N) = a - W.*b;
end
```

실전 Stockham FFT는 모든 스테이지를 이런 **교차 버퍼링**으로 누적해 비트역전이 불필요해진다.

---

## 15. FFT 응용 연결(요약)

- **선형 컨볼루션**: 제로패딩, OLA/OLS (앞선 글)
- **스펙트럼 분석**: 창/ENBW/스캘러핑/피크보간
- **상관/GCC-PHAT**: 상호스펙트럼 → IFFT
- **STFT**: 프레임 창 + FFT + 마스킹 + OLA 합성

---

## 16. 연습문제(풀이/코드 포함)

### 문제 1) Radix-2 버터플라이 연산 카운트 유도·검증
이론: 곱 \((N/2)\log_2N\), 합 \(N\log_2N\).
```octave
function [mul_cnt, add_cnt] = count_ops_fft_radix2(N)
  if bitand(N, N-1) ~= 0, error("power of two only"); end
  p = log2(N);
  mul_cnt = (N/2)*p;
  add_cnt = N*p;
end
for N=[8 16 1024 4096]
  [m,a] = count_ops_fft_radix2(N);
  printf("N=%d | mul=%d, add=%d\n", N, m, a);
end
```

### 문제 2) Bluestein 정확도/성능 비교
\(N=1000\)에서 `fft` vs `bluestein_fft` 시간과 상대오차를 기록하라.
```octave
clear; close all; clc
N=1000; x=randn(1,N)+1j*randn(1,N);
tic; X1=fft(x); t1=toc;
tic; X2=bluestein_fft(x); t2=toc;
printf("time fft=%.3fs, bluestein=%.3fs | rel-err=%.3e\n", t1, t2, norm(X1-X2)/norm(X1));
```

### 문제 3) rFFT “2-in-1” 가속 이득
4096샘플 실수 신호 100프레임에서 복소 FFT 대비 이득을 측정하라(후처리 포함).

### 문제 4) 2D 이미지 저역통과
`fft2`/`ifft2`로 원형 저역 마스크 필터링을 구현하고 원영상과의 오차를 확인하라(정규화 주의).

### 문제 5) Stockham vs 비트역전(개념 서술)
Stockham이 **매 단계 정렬**을 달성해 비트역전이 불필요해지는 이유를 서술하고, 캐시-스트라이드 관점의 장단점을 정리하라.

---

## 17. 핵심 공식(요약)

- Radix-2 DIT 결합
\[
X[k]=E[k]+W_N^k O[k],\quad X[k+N/2]=E[k]-W_N^k O[k].
\]
- 복잡도
\[
\text{mult}\approx \frac{N}{2}\log_2 N,\qquad \text{add}\approx N\log_2 N.
\]
- Bluestein(Chirp-Z) 환원
\[
X[k]=e^{-j\pi k^2/N}\,(a\star b)[k],\quad
a[n]=x[n]e^{-j\pi n^2/N},\ b[m]=e^{+j\pi m^2/N}.
\]

---

## 18. 결론

FFT는 DFT의 대칭/주기성을 이용한 **분할정복 알고리즘**으로, 이론·구현·성능이 정교하게 맞물린다. Radix-2/4·혼합기수로 크기 제약을 극복하고, 소수 길이는 **Bluestein**으로 커버한다. 실수/2D 최적화, 캐시·배치·스케일링·정확도 관리, 고정소수점 스케일링까지 이해하면 **분석·필터링·합성** 전 분야에서 견고한 FFT 파이프라인을 설계할 수 있다. 본문의 Octave 코드를 변형해 자신만의 데이터/프레임/크기에서 **정확도와 성능**을 직접 검증하라.
