---
layout: post
title: DB 심화 - 병렬 쿼리와 스칼라 서브쿼리 · 사용자 정의 함수 · ROWNUM · 병렬 처리 시 주의사항
date: 2025-11-25 17:25:23 +0900
category: DB 심화
---

# 병렬 쿼리와 스칼라 서브쿼리, UDF, ROWNUM의 함정과 해법

병렬 처리는 대용량 데이터를 빠르게 처리할 수 있는 강력한 도구이지만, 특정 패턴과 함께 사용할 때는 주의가 필요합니다. 이 문서에서는 병렬 쿼리 환경에서 스칼라 서브쿼리, 사용자 정의 함수(UDF), ROWNUM 사용 시 발생할 수 있는 문제점과 효과적인 해결책을 심층적으로 분석합니다.

## 실습 환경 설정

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET parallel_degree_policy = MANUAL;

-- 기본 테이블 생성
DROP TABLE sales PURGE;
CREATE TABLE sales (
  sales_id   NUMBER       PRIMARY KEY,
  cust_id    NUMBER       NOT NULL,
  sales_dt   DATE         NOT NULL,
  region_cd  VARCHAR2(6)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL
);

DROP TABLE orders PURGE;
CREATE TABLE orders (
  order_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  order_dt DATE   NOT NULL,
  amt      NUMBER(12,2)
);

DROP TABLE dim_customer PURGE;
CREATE TABLE dim_customer (
  cust_id      NUMBER PRIMARY KEY,
  region_group VARCHAR2(10),
  grade        VARCHAR2(10),
  active_yn    CHAR(1)
);

CREATE INDEX ix_sales_cust  ON sales(cust_id);
CREATE INDEX ix_orders_cust ON orders(cust_id);

-- 샘플 데이터 삽입
INSERT INTO dim_customer VALUES (101,'APAC','GOLD','Y');
INSERT INTO dim_customer VALUES (202,'AMER','SILVER','Y');
INSERT INTO dim_customer VALUES (303,'EMEA','BRONZE','N');

INSERT INTO sales  VALUES (1,101, DATE '2025-02-10','KR',100);
INSERT INTO sales  VALUES (2,202, DATE '2025-02-11','US',170);
INSERT INTO sales  VALUES (3,202, DATE '2025-03-01','US',250);

INSERT INTO orders VALUES (10,101, DATE '2025-02-10', 300);
INSERT INTO orders VALUES (20,202, DATE '2025-02-11', 500);
INSERT INTO orders VALUES (30,202, DATE '2025-03-01', 700);

COMMIT;

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES',  method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_CUSTOMER');
END;
/
```

## 병렬 처리의 기본 구조 이해

병렬 쿼리는 하나의 쿼리를 여러 프로세스가 분담하여 처리하는 구조입니다. 주요 구성 요소는 다음과 같습니다:

- **QC(Query Coordinator)**: 사용자 세션이며, 실행 계획을 병렬 작업 단위(DFO)로 분할하고 병렬 서버를 관리합니다.
- **PX 서버**: 실제 데이터 처리 작업을 수행하는 병렬 프로세스입니다.
- **DFO(Data Flow Operation)**: 병렬 실행의 작업 단위입니다.
- **TQ(Table Queue)**: 병렬 프로세스 간 데이터를 전달하는 통로입니다.

병렬 처리의 핵심은 "데이터 흐름 설계"입니다. 각 병렬 프로세스가 처리하는 데이터의 양과 이동 경로가 성능을 결정합니다.

## 스칼라 서브쿼리의 병렬 처리 문제

### 문제의 본질

스칼라 서브쿼리는 외부 쿼리의 각 행에 대해 실행되는 상관 서브쿼리입니다. 병렬 환경에서 이는 치명적인 성능 문제를 일으킬 수 있습니다:

```sql
-- 문제가 될 수 있는 병렬 스칼라 서브쿼리
EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) monitor */
       s.sales_id,
       s.amount,
       (SELECT MAX(o.amt)
          FROM orders o
         WHERE o.cust_id = s.cust_id) AS max_amt
FROM   sales s;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +ALIAS +PARALLEL +NOTE'));
```

이 쿼리의 문제점은 다음과 같습니다:

1. **반복 실행**: 외부 쿼리의 각 행마다 서브쿼리가 실행됩니다.
2. **인덱스 랜덤 액세스**: 각 실행마다 인덱스를 통한 랜덤 액세스가 발생합니다.
3. **병렬 증폭 효과**: 병렬 프로세스 수만큼 반복 실행이 증폭됩니다.

### 해결책: 조인 변환

스칼라 서브쿼리를 조인으로 변환하는 것이 가장 효과적인 해결책입니다:

```sql
-- 스칼라 서브쿼리를 조인으로 변환
EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) parallel(o 16)
           unnest
           use_hash(o) monitor */
       s.sales_id,
       s.amount,
       m.max_amt
FROM   sales s
LEFT JOIN (
  SELECT /*+ parallel(o 16) */ cust_id, MAX(amt) AS max_amt
  FROM   orders o
  GROUP  BY cust_id
) m
  ON m.cust_id = s.cust_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +ALIAS +PARALLEL +NOTE'));
```

이 변환의 장점:
- **단일 스캔**: orders 테이블을 한 번만 스캔합니다.
- **집계 최적화**: 그룹별 집계를 효율적으로 처리합니다.
- **병렬 최적화**: 병렬 부분 집계가 가능합니다.

### 스칼라 서브쿼리 캐시의 한계

오라클은 스칼라 서브쿼리 결과를 캐시하지만, 병렬 환경에서는 이 캐시 효과가 제한적입니다:

1. **캐시 분산**: 각 병렬 프로세스가 자신의 캐시를 유지합니다.
2. **데이터 분산**: 동일한 키가 여러 프로세스에 분산되어 캐시 히트율이 낮아집니다.
3. **메모리 제한**: 캐시 크기가 제한적입니다.

## 사용자 정의 함수(UDF)의 병렬 처리 문제

### UDF 호출 오버헤드

PL/SQL 함수를 SQL에서 호출할 때 발생하는 컨텍스트 스위칭은 병렬 환경에서 심각한 성능 문제를 일으킵니다:

```sql
-- 사용자 정의 함수 생성
CREATE OR REPLACE FUNCTION f_score(p_amt NUMBER)
RETURN NUMBER IS
BEGIN
  -- 복잡한 비즈니스 로직
  RETURN CASE 
           WHEN p_amt >= 500 THEN 3 
           WHEN p_amt >= 200 THEN 2 
           ELSE 1 
         END;
END;
/

-- 문제가 될 수 있는 UDF 호출
EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount, f_score(s.amount) AS score
FROM   sales s;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +ALIAS +PARALLEL +NOTE'));
```

### UDF 최적화 전략

#### 1. SQL 표현식으로 대체

가장 효과적인 방법은 UDF를 SQL 표현식으로 대체하는 것입니다:

```sql
-- CASE 표현식으로 UDF 대체
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount,
       CASE WHEN s.amount >= 500 THEN 3
            WHEN s.amount >= 200 THEN 2
            ELSE 1 END AS score
FROM   sales s;
```

#### 2. 조인 테이블 활용

UDF가 복잡한 매핑 로직인 경우 조인 테이블을 활용할 수 있습니다:

```sql
-- 매핑 테이블 생성
CREATE TABLE score_rule (
    min_amt NUMBER, 
    max_amt NUMBER, 
    score NUMBER
);

INSERT INTO score_rule VALUES (500, 1e18, 3);
INSERT INTO score_rule VALUES (200, 500-1e-9, 2);
INSERT INTO score_rule VALUES (0,   200-1e-9, 1);
COMMIT;

-- 조인으로 UDF 대체
SELECT /*+ leading(s) use_nl(r) parallel(s 16) parallel(r 16) monitor */
       s.sales_id, s.amount, r.score
FROM   sales s
JOIN   score_rule r
  ON   s.amount BETWEEN r.min_amt AND r.max_amt;
```

#### 3. PRAGMA UDF 활용

Oracle 12c 이상에서는 PRAGMA UDF를 사용하여 호출 오버헤드를 줄일 수 있습니다:

```sql
CREATE OR REPLACE FUNCTION f_score_optimized(p_amt NUMBER)
RETURN NUMBER
IS
  PRAGMA UDF;  -- 호출 오버헤드 감소
BEGIN
  RETURN CASE 
           WHEN p_amt >= 500 THEN 3 
           WHEN p_amt >= 200 THEN 2 
           ELSE 1 
         END;
END;
/
```

#### 4. 결과 캐시 활용

결과 캐시를 사용하여 반복 호출을 줄일 수 있습니다:

```sql
CREATE OR REPLACE FUNCTION f_score_cached(p_amt NUMBER)
RETURN NUMBER
RESULT_CACHE  -- 결과 캐싱
IS
BEGIN
  RETURN CASE 
           WHEN p_amt >= 500 THEN 3 
           WHEN p_amt >= 200 THEN 2 
           ELSE 1 
         END;
END;
/
```

## ROWNUM과 병렬 처리

### ROWNUM의 동작 방식

ROWNUM은 결과 집합이 생성되는 순서대로 번호를 부여합니다. 병렬 환경에서는 이 동작이 예상과 다를 수 있습니다:

```sql
-- 병렬 환경에서의 ROWNUM
SELECT /*+ parallel(s 8) monitor */
       *
FROM   sales s
WHERE  ROWNUM <= 10;
```

이 쿼리의 문제점:
- 각 병렬 프로세스가 자신의 로컬 ROWNUM을 생성합니다.
- 결과적으로 QC는 각 프로세스로부터 최대 10개의 행을 받을 수 있습니다.
- 실제로는 DOP × 10개의 행이 QC에 전달된 후 10개로 필터링됩니다.

### 올바른 Top-N 처리 방법

#### FETCH FIRST 사용 (Oracle 12c 이상)

```sql
-- FETCH FIRST를 사용한 Top-N
EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount
FROM   sales s
ORDER  BY s.amount DESC
FETCH FIRST 10 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +NOTE'));
```

FETCH FIRST의 장점:
- **Top-N Pushdown**: 각 병렬 프로세스가 로컬 Top-N을 계산합니다.
- **네트워크 트래픽 감소**: QC로 전송되는 데이터 양이 줄어듭니다.
- **정렬 최적화**: 전체 정렬 대신 Top-N 정렬이 수행됩니다.

#### 분석 함수 사용

```sql
-- ROW_NUMBER()를 사용한 Top-N
SELECT /*+ parallel(s 16) monitor */
       *
FROM (
  SELECT s.*, 
         ROW_NUMBER() OVER(ORDER BY s.amount DESC) AS rn
  FROM   sales s
)
WHERE rn <= 10;
```

#### 주의사항: 잘못된 Top-N 패턴

```sql
-- 잘못된 Top-N 패턴 (Random-10 정렬)
SELECT *
FROM   sales
WHERE  ROWNUM <= 10
ORDER  BY amount DESC;
```

이 패턴은 먼저 임의의 10개 행을 선택한 후 정렬하므로, 실제 Top-10이 아닙니다.

## 병렬 처리 성능 모니터링과 문제 진단

### TQ 스큐 모니터링

```sql
-- TQ 분배 상태 확인
SELECT dfo_number, tq_id, server_type, inst_id, process,
       num_rows, bytes,
       ROUND(100.0 * num_rows / SUM(num_rows) OVER (PARTITION BY dfo_number, tq_id), 2) AS pct
FROM   v$pq_tqstat
ORDER  BY dfo_number, tq_id, server_type, inst_id, process;
```

이 쿼리는 각 병렬 프로세스의 처리 데이터 양과 비율을 보여줍니다. 특정 프로세스의 비율이 다른 프로세스와 크게 다르면 데이터 스큐가 있음을 의미합니다.

### 실행 계획 분석

```sql
-- 실행 계획 확인
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
     'BASIC +PARALLEL +ALIAS +PREDICATE +NOTE +STATS LAST'));
```

실행 계획에서 주목할 점:
- PX SEND/RECEIVE 작업의 유형(HASH, BROADCAST, ROUND-ROBIN)
- 각 작업의 Starts 횟수
- 실제 처리된 행 수(A-Rows)

### 대기 이벤트 분석

```sql
-- 병렬 관련 대기 이벤트 분석
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSDATE - INTERVAL '5' MINUTE
  AND (event LIKE 'PX Deq%'
       OR event LIKE 'direct path%'
       OR event LIKE 'db file sequential read%')
GROUP  BY event
ORDER  BY samples DESC;
```

주요 대기 이벤트:
- `PX Deq Credit: send blkd`: 생산자 프로세스가 소비자 프로세스를 기다리는 상태
- `direct path read temp`: Temp 영역에서의 읽기 대기
- `db file sequential read`: 인덱스 랜덤 액세스 대기

## 병렬 처리 최적화 기법

### 데이터 분배 전략

병렬 조인의 성능은 데이터 분배 전략에 크게 영향을 받습니다:

```sql
-- HASH-HASH 분배 (동일 키를 같은 프로세스로)
SELECT /*+ leading(s) use_hash(o)
           parallel(s 16) parallel(o 16)
           pq_distribute(s HASH HASH)
           pq_distribute(o HASH HASH) monitor */
       s.cust_id, SUM(s.amount) amt, MAX(o.amt) mx
FROM   sales s
JOIN   orders o
  ON   o.cust_id = s.cust_id
GROUP  BY s.cust_id;
```

### 스큐 완화 기법

데이터 스큐가 심한 경우 다음과 같은 기법을 적용할 수 있습니다:

```sql
-- SALT 기법을 통한 스큐 완화
WITH salted AS (
  SELECT /*+ parallel(s 16) */
         cust_id,
         MOD(DBMS_RANDOM.VALUE(0, 8), 8) AS salt,  -- 8은 DOP에 맞춤
         SUM(amount) AS amt
  FROM   sales s
  GROUP  BY cust_id, MOD(DBMS_RANDOM.VALUE(0, 8), 8)
)
SELECT cust_id, SUM(amt) AS total_amt
FROM   salted
GROUP  BY cust_id;
```

### 적절한 DOP 선택

DOP(Degree of Parallelism)는 성능에 큰 영향을 미칩니다. 너무 높은 DOP는 오히려 성능을 저하시킬 수 있습니다:

```sql
-- 적절한 DOP 테스트
ALTER SESSION SET parallel_degree_policy = AUTO;

-- 다양한 DOP로 테스트
SELECT /*+ parallel(s 4) */ COUNT(*) FROM sales s;
SELECT /*+ parallel(s 8) */ COUNT(*) FROM sales s;
SELECT /*+ parallel(s 16) */ COUNT(*) FROM sales s;
SELECT /*+ parallel(s 32) */ COUNT(*) FROM sales s;
```

## 실전 시나리오

### 대용량 데이터 환경에서의 최적화

```sql
-- 대용량 테스트 데이터 생성
TRUNCATE TABLE sales;
TRUNCATE TABLE orders;

INSERT /*+ append parallel */ INTO sales
SELECT level                                 AS sales_id,
       MOD(level, 50000) + 1                 AS cust_id,
       DATE '2024-01-01' + MOD(level, 365)   AS sales_dt,
       CASE MOD(level,5)
         WHEN 0 THEN 'US' WHEN 1 THEN 'UK' WHEN 2 THEN 'DE'
         WHEN 3 THEN 'FR' ELSE 'KR' END      AS region_cd,
       DBMS_RANDOM.VALUE(10, 1000)           AS amount
FROM dual
CONNECT BY level <= 1000000;

INSERT /*+ append parallel */ INTO orders
SELECT level                                 AS order_id,
       MOD(level, 50000) + 1                 AS cust_id,
       DATE '2024-01-01' + MOD(level, 365)   AS order_dt,
       DBMS_RANDOM.VALUE(10, 2000)           AS amt
FROM dual
CONNECT BY level <= 1000000;

COMMIT;

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS');
END;
/

-- 최적화된 쿼리 실행
SET TIMING ON

-- 원본 (문제가 될 수 있는 패턴)
SELECT /*+ parallel(s 16) monitor */
       s.sales_id,
       s.amount,
       (SELECT MAX(o.amt)
          FROM orders o
         WHERE o.cust_id = s.cust_id) AS max_amt
FROM   sales s
WHERE  s.sales_dt >= DATE '2024-06-01'
  AND  s.sales_dt < DATE '2024-07-01';

-- 최적화된 버전
SELECT /*+ leading(s) use_hash(m) 
           parallel(s 16) parallel(m 16) monitor */
       s.sales_id,
       s.amount,
       m.max_amt
FROM   sales s
LEFT JOIN (
  SELECT /*+ parallel(o 16) */ cust_id, MAX(amt) AS max_amt
  FROM   orders o
  WHERE  o.order_dt >= DATE '2024-06-01'
    AND  o.order_dt < DATE '2024-07-01'
  GROUP  BY cust_id
) m
  ON m.cust_id = s.cust_id
WHERE  s.sales_dt >= DATE '2024-06-01'
  AND  s.sales_dt < DATE '2024-07-01';

SET TIMING OFF
```

## 결론

병렬 쿼리는 강력한 도구이지만, 올바르게 사용하지 않으면 오히려 성능을 저하시킬 수 있습니다. 효과적인 병렬 처리를 위한 핵심 원칙은 다음과 같습니다:

### 스칼라 서브쿼리 처리 원칙

1. **조인 변환 우선**: 스칼라 서브쿼리는 가능한 한 조인으로 변환하세요.
2. **집계 최적화**: 그룹별 집계는 서브쿼리 내부에서 미리 처리하세요.
3. **인덱스 활용**: 필수적인 경우 적절한 인덱스를 구성하세요.

### UDF 처리 원칙

1. **SQL 표현식 우선**: 가능한 경우 UDF를 SQL 표현식(CASE, DECODE 등)으로 대체하세요.
2. **조인 테이블 활용**: 복잡한 매핑 로직은 조인 테이블로 구현하세요.
3. **최신 기능 활용**: PRAGMA UDF와 결과 캐시를 적절히 활용하세요.

### ROWNUM 및 Top-N 처리 원칙

1. **FETCH FIRST 사용**: Oracle 12c 이상에서는 FETCH FIRST를 사용하세요.
2. **분석 함수 고려**: 복잡한 Top-N 요구사항은 분석 함수로 처리하세요.
3. **순서 주의**: ROWNUM과 ORDER BY의 실행 순서를 정확히 이해하세요.

### 병렬 처리 일반 원칙

1. **데이터 흐름 설계**: 실행 계획의 PX SEND/RECEIVE 패턴을 분석하고 최적화하세요.
2. **스큐 모니터링**: `V$PQ_TQSTAT`를 통해 데이터 스큐를 정기적으로 모니터링하세요.
3. **적절한 DOP 선택**: 시스템 리소스와 데이터 특성을 고려하여 적절한 DOP를 선택하세요.
4. **통계 관리**: 최신 통계를 유지하여 옵티마이저의 결정을 돕도록 하세요.

병렬 처리는 단순히 쿼리에 `/*+ parallel */` 힌트를 추가하는 것이 아닙니다. 데이터의 흐름, 분배, 처리 방식을 체계적으로 설계하고 모니터링해야 진정한 성능 향상을 달성할 수 있습니다. 본 문서에서 제시한 원칙과 기법을 바탕으로 조직의 데이터 환경에 맞는 최적의 병렬 처리 전략을 수립하시기 바랍니다.