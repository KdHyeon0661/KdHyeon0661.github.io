---
layout: post
title: DB 심화 - 병렬 쿼리와 스칼라 서브쿼리 · 사용자 정의 함수 · ROWNUM · 병렬 처리 시 주의사항
date: 2025-11-25 17:25:23 +0900
category: DB 심화
---
# · ROWNUM · 병렬 처리 시 주의사항

> 기준: Oracle 11g 이상(12c/19c도 동일한 원리).
> 목표: “**병렬(PQ)** 환경에서 **스칼라 서브쿼리/PLSQL 함수/ROWNUM** 이 어떻게 동작하고, 어떤 **병목**이 생기며, 어떻게 **튜닝**하는지”를 실행계획/대기이벤트/힌트 중심으로 **끝까지** 설명합니다.

---

## 공통 실습 스키마 (한 번만 실행)

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;          -- DBMS_XPLAN 통계
ALTER SESSION SET parallel_degree_policy = MANUAL; -- 필요 시 AUTO로 변경

DROP TABLE sales PURGE;
CREATE TABLE sales (
  sales_id   NUMBER       PRIMARY KEY,
  cust_id    NUMBER       NOT NULL,
  sales_dt   DATE         NOT NULL,
  region_cd  VARCHAR2(6)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL
);

DROP TABLE orders PURGE;
CREATE TABLE orders (
  order_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  order_dt DATE   NOT NULL,
  amt      NUMBER(12,2)
);

DROP TABLE dim_customer PURGE;
CREATE TABLE dim_customer (
  cust_id      NUMBER PRIMARY KEY,
  region_group VARCHAR2(10),
  grade        VARCHAR2(10),
  active_yn    CHAR(1)
);

CREATE INDEX ix_sales_cust  ON sales(cust_id);
CREATE INDEX ix_orders_cust ON orders(cust_id);

INSERT INTO dim_customer VALUES (101,'APAC','GOLD','Y');
INSERT INTO dim_customer VALUES (202,'AMER','SILVER','Y');
INSERT INTO dim_customer VALUES (303,'EMEA','BRONZE','N');

INSERT INTO sales  VALUES (1,101, DATE '2025-02-10','KR',100);
INSERT INTO sales  VALUES (2,202, DATE '2025-02-11','US',170);
INSERT INTO sales  VALUES (3,202, DATE '2025-03-01','US',250);

INSERT INTO orders VALUES (10,101, DATE '2025-02-10', 300);
INSERT INTO orders VALUES (20,202, DATE '2025-02-11', 500);
INSERT INTO orders VALUES (30,202, DATE '2025-03-01', 700);

COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES',  method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_CUSTOMER');
END;
/
```

---

# 병렬 쿼리와 **스칼라 서브쿼리**

### 개념 정리

- **스칼라 서브쿼리**: SELECT 목록이나 WHERE 절 등에서 **단일 값**을 반환하는 서브쿼리.
- 병렬 환경에선 **각 PX 슬레이브**가 자기 몫의 로우마다 서브쿼리를 **반복 평가**합니다.
  → **중복 평가**, **캐시 미공유**, **NL(중첩) 패턴 폭발**이 병목이 됩니다.
- 옵티마이저가 가능하면 **unnesting**(조인 변환)으로 바꿔서 병렬 **JOIN + GROUP BY**로 풀어줍니다.
  → **핵심**: “**서브쿼리를 JOIN으로 바꿔라**”가 기본 원칙.

### 나쁜 예: 병렬 + 상관 스칼라 서브쿼리

```sql
EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) monitor */
       s.sales_id,
       s.amount,
       (SELECT /* scalar subquery */ MAX(o.amt)
          FROM orders o
         WHERE o.cust_id = s.cust_id) AS max_amt
FROM   sales s;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +ALIAS +PARALLEL +NOTE'));
```
- 슬레이브 각자가 `s.cust_id`별로 **반복 평가** → **랜덤 I/O** 증가, **스칼라 서브쿼리 캐시**가 있어도 **슬레이브별 로컬**이라 효과 제한.
- 대기 이벤트 예시: `db file sequential read`(인덱스+ROWID), (분배 있으면) `PX Deq Credit: send blkd`.

### 좋은 예: **UNNEST**(조인 변환)로 병렬화

```sql
EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) parallel(o 16)
           unnest
           use_hash(o) monitor */
       s.sales_id,
       s.amount,
       m.max_amt
FROM   sales s
LEFT JOIN (
  SELECT /*+ parallel(o 16) */ cust_id, MAX(amt) AS max_amt
  FROM   orders o
  GROUP  BY cust_id
) m
  ON m.cust_id = s.cust_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +ALIAS +PARALLEL +NOTE'));
```
- 스칼라 서브쿼리 → `LEFT JOIN + GROUP BY` 변환(unnesting).
- 이제 **병렬 해시 조인** + **병렬 집계**로 확장성↑, **중복 평가 제거**.

> 팁
> - 옵티마이저가 자동으로 unnest 못 할 때 `/*+ UNNEST */` 시도.
> - 반대로 변환이 해악일 때는 `/*+ NO_UNNEST */`.

### “값이 적게 반복되는” 스칼라 서브쿼리일 때

- 일부 버전/상황에서 **스칼라 서브쿼리 캐싱** 최적화가 동작(같은 입력은 재평가 회피).
- **병렬**에선 **슬레이브별 별도 캐시** → **글로벌 공유가 아님**: 중복 키가 슬레이브 간 분산되면 캐시 이점이 약합니다.
- 해법은 여전히 **조인 변환**이 우선, 보조적으로 **PX 분배**(예: `PQ_DISTRIBUTE(HASH/HASH)`로 같은 키를 한 슬레이브로 모으기)로 캐시 히트율을 올릴 수 있습니다.

```sql
-- 슬레이브 간 동일 cust_id를 한곳으로 모아 캐시효율↑ + 조인 비용↓
SELECT /*+ leading(s) use_hash(o)
           parallel(s 16) parallel(o 16)
           pq_distribute(s HASH HASH)
           pq_distribute(o HASH HASH) monitor */
       s.sales_id, s.amount,
       MAX(o.amt) OVER (PARTITION BY s.cust_id) AS max_amt_like
FROM   sales s
JOIN   orders o
  ON   o.cust_id = s.cust_id;
```

---

# 병렬 쿼리와 **사용자 정의 함수(UDF)**

### 문제의 본질: **컨텍스트 스위칭**

- SQL 엔진 ↔ PL/SQL 함수 호출은 **컨텍스트 스위칭** 비용이 큽니다.
- 병렬이면 **슬레이브 수 × 로우 건수**만큼 호출이 폭증 → CPU 소모/직렬화/캐시 경합.

### 증상 재현 (비추천 패턴)

```sql
-- 비결정적/고비용 PL/SQL 함수 예시
CREATE OR REPLACE FUNCTION f_score(p_amt NUMBER)
RETURN NUMBER IS
BEGIN
  -- (복잡한 로직/패키지 호출/쿼리 등)
  RETURN CASE WHEN p_amt >= 500 THEN 3 WHEN p_amt >= 200 THEN 2 ELSE 1 END;
END;
/

EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount, f_score(s.amount) AS score
FROM   sales s;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +ALIAS +PARALLEL +NOTE'));
```
- 슬레이브들이 로우마다 **PL/SQL 진입** → CPU↑.
- 함수 내부에서 또 SQL을 호출하면 **Recursive call** 폭증.

### 해법 1: **내장 SQL**(CASE/DECODE)로 **대체**

```sql
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount,
       CASE WHEN s.amount >= 500 THEN 3
            WHEN s.amount >= 200 THEN 2
            ELSE 1 END AS score
FROM   sales s;
```
- **컨텍스트 스위칭 제로**, 병렬/벡터라이즈된 평가.

### 해법 2: **DETERMINISTIC/RESULT_CACHE** + **LOOKUP JOIN**

- **DETERMINISTIC**: 같은 입력에 동일 출력(함수기반 인덱스 조건).
- **RESULT_CACHE**: 결과를 공유 캐시에 넣어 **반복 호출 절약**(함수 시그니처가 적고 재사용 빈번할 때).
- 복잡한 로직이면 **룩업 테이블**로 치환(범주화 규칙을 테이블화)하여 **조인**.

```sql
-- 룩업 테이블로 치환(권장)
CREATE TABLE score_rule (min_amt NUMBER, max_amt NUMBER, score NUMBER);
INSERT INTO score_rule VALUES (500, 1e18, 3);
INSERT INTO score_rule VALUES (200, 500-1e-9, 2);
INSERT INTO score_rule VALUES (0,   200-1e-9, 1);
COMMIT;

SELECT /*+ leading(s) use_nl(r) parallel(s 16) parallel(r 16) monitor */
       s.sales_id, s.amount, r.score
FROM   sales s
JOIN   score_rule r
  ON   s.amount BETWEEN r.min_amt AND r.max_amt;
```

### 해법 3: **PRAGMA UDF**(가능 시)로 호출비 절감

- PL/SQL 함수에 `PRAGMA UDF`를 선언하면 SQL에서 호출시 **오버헤드 감소**(버전 호환 확인).
- 그래도 **CASE/DECODE/조인 치환**이 가능하다면 그게 더 빠른 경우가 대부분.

### 해법 4: **파이프라인/병렬 가능 테이블 함수**로 아키텍처 전환

- 행단위 스칼라 함수 대신, **PIPELINED TABLE FUNCTION** + `PARALLEL_ENABLE`로 **세트 처리**.
- (복잡) 운영에서는 유지보수/테스트 비용 고려.

---

# 병렬 쿼리와 **ROWNUM**

### ROWNUM의 성질

- `ROWNUM`은 **프로젝션 단계**에서 **흘러가는 순서대로** 번호가 매겨지는 **물리적 순서 의존** 값.
- PQ에선 **각 슬레이브가 자기 출력 흐름**에 대해 ROWNUM을 **개별로** 생성 →
  `WHERE ROWNUM <= N`은 **슬레이브별 N개씩** 뽑혀 **QC가 합쳐서 다시 자르기도** 합니다.

### 정렬 없음 + ROWNUM 상한 (임의 N개 빨리 뽑기)

```sql
SELECT /*+ parallel(s 8) monitor */
       *
FROM   sales s
WHERE  ROWNUM <= 10;
```
- 빠르게 **임의의 10개**를 얻는 용도엔 좋습니다.
- **글로벌 순서 보장 X**.

### 정렬과 함께 **Top-N**을 전역적으로 보장하려면

- `ORDER BY ... FETCH FIRST N ROWS ONLY` 또는
- `ROW_NUMBER() OVER(ORDER BY ...) <= N` 사용.
- PQ에선 **PX PARTIAL ORDER BY**(슬레이브 로컬 Top-N) 후 **QC에서 전역 Top-N**으로 마무리.
  슬레이브 수가 크면 **N×DOP** 정도가 QC로 올라오고, QC가 **STOPKEY**로 컷팅.

```sql
-- 전역 Top-N 보장 (12c+ 문법)
EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount
FROM   sales s
ORDER  BY s.amount DESC
FETCH FIRST 10 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +NOTE'));
```

```sql
-- 분석함수로 전역 랭킹 후 필터
SELECT /*+ parallel(s 16) monitor */
       *
FROM (
  SELECT s.*, ROW_NUMBER() OVER(ORDER BY s.amount DESC) AS rn
  FROM   sales s
)
WHERE rn <= 10;
```

> 팁
> - 대량 정렬 Top-N은 **Top-N Pushdown**이 일어나면 **슬레이브 단계에서 버려지는 로우↑** → 네트워크 바이트↓.
> - 여전히 **QC의 최종 머지 소트**가 병목이 될 수 있으므로 N을 작게, **적절한 인덱스**(ORDER BY 대응)로 소트를 대체할 수 있으면 더 좋습니다.

---

# 병렬 처리 시 **주의사항(체크리스트)**

### 실행계획/분배/스큐

- **PX SEND/RECEIVE** 라인을 항상 확인: `HASH`, `BROADCAST`, `PARTITION`, `ROUND-ROBIN` 등.
- `V$PQ_TQSTAT`로 **TQ 스큐** 체크(슬레이브별 `NUM_ROWS` 편차).
  스큐 심하면 `PX Deq Credit: send blkd` 급증 → **SALT 컬럼**, 키 변형, 브로드캐스트 전환.

```sql
SELECT dfo_number, tq_id, server_type, inst_id, process, num_rows, bytes
FROM   v$pq_tqstat
ORDER  BY dfo_number, tq_id, server_type, inst_id, process;
```

### 메모리/Temp/스토리지

- **PGA_AGGREGATE_TARGET**(AUTO)로 워크에어리어 확보(소트/해시 Temp 스필↓).
- 대량 작업은 `direct path read/write temp`가 정상. 다만 **TEMP 과부하**로 스로틀링/대기 발생 시 DOP 조절.
- 스토리지/인터커넥트 대역폭을 **DOP에 맞춰**(과대 DOP는 오히려 느림).

### RAC 고려

- 재분배 많은 해시 조인/집계는 **인터커넥트 병목** 가능.
- **Full Partition-Wise Join** + **서비스/파티션 affinity**로 **GC 대기** 최소화.

### 스칼라 서브쿼리/함수

- **조인 변환(unnest)** 최우선, 불가하면 **PX 분배**(동일 키 수렴)로 비용 완화.
- PL/SQL 함수는 **CASE/DECODE/룩업 조인** 치환 우선.
- 어쩔 수 없으면 `PRAGMA UDF`, `RESULT_CACHE`(패턴 적을 때), **함수기반 인덱스/가상 컬럼** 검토.

### Top-N / ROWNUM

- 전역 순서를 요구하면 **`ORDER BY … FETCH FIRST N`** 또는 **분석함수**.
- 정렬 없는 ROWNUM은 “**빨리 아무거나**”엔 좋지만, 의미 있는 상위 N엔 **부적합**.

### 병렬 DML과의 상호작용

- PDML 후 같은 세션에서 **즉시 읽기/수정 금지(ORA-12838)** → **COMMIT** 필요.
- 인덱스/트리거/제약 때문에 PDML이 **Serial 강등**되는지 **NOTE** 확인.

### 통계/옵티마이저 힌트

- 통계 부정확 시 분배 선택이 잘못되어 **네트워크/Temp 폭증**.
- `PQ_DISTRIBUTE`(HASH/HASH, BROADCAST/NONE, PARTITION/PARTITION)로 **의도된 데이터 흐름** 유도.

---

# 실습 시나리오 모음(바로 적용 가능)

## 스칼라 서브쿼리 → 조인 변환 전/후 비교

```sql
-- BEFORE: 스칼라 서브쿼리
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount,
       (SELECT MAX(o.amt) FROM orders o WHERE o.cust_id = s.cust_id) max_amt
FROM   sales s;

-- AFTER: 조인 변환 + 집계
SELECT /*+ leading(s) use_hash(m) parallel(s 16) parallel(m 16) monitor */
       s.sales_id, s.amount, m.max_amt
FROM   sales s
LEFT JOIN (
  SELECT cust_id, MAX(amt) max_amt
  FROM   orders
  GROUP  BY cust_id
) m
  ON m.cust_id = s.cust_id;
```

## 함수 호출 제거/대체

```sql
-- BEFORE: UDF
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, f_score(s.amount)
FROM   sales s;

-- AFTER: CASE
SELECT /*+ parallel(s 16) monitor */
       s.sales_id,
       CASE WHEN amount>=500 THEN 3 WHEN amount>=200 THEN 2 ELSE 1 END AS score
FROM   sales s;

-- AFTER: 룩업 조인
SELECT /*+ parallel(s 16) parallel(r 16) use_nl(r) monitor */
       s.sales_id, r.score
FROM   sales s
JOIN   score_rule r
  ON   s.amount BETWEEN r.min_amt AND r.max_amt;
```

## 전역 Top-N 보장

```sql
-- 정렬 + FETCH FIRST
SELECT /*+ parallel(s 16) monitor */
       sales_id, amount
FROM   sales
ORDER  BY amount DESC
FETCH FIRST 10 ROWS ONLY;

-- 분석함수
SELECT /*+ parallel(s 16) monitor */
       *
FROM (
  SELECT s.*, ROW_NUMBER() OVER(ORDER BY amount DESC) rn
  FROM   sales s
)
WHERE rn <= 10;
```

## 분배 전략으로 캐시/조인 비용 완화

```sql
SELECT /*+ leading(s) use_hash(o)
           parallel(s 16) parallel(o 16)
           pq_distribute(s HASH HASH)
           pq_distribute(o HASH HASH) monitor */
       s.cust_id, SUM(s.amount) amt, MAX(o.amt) mx
FROM   sales s
JOIN   orders o
  ON   o.cust_id = s.cust_id
GROUP  BY s.cust_id;
```

---

# 모니터링 루틴(권장 템플릿)

```sql
-- 실제 실행된 커서 플랜(통계 포함)
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'BASIC +PARALLEL +ALIAS +PREDICATE +NOTE'));

-- TQ 스큐/바이트
SELECT dfo_number, tq_id, server_type, inst_id, process,
       num_rows, bytes
FROM   v$pq_tqstat
ORDER  BY dfo_number, tq_id, server_type, inst_id, process;

-- 최근 5분 병렬/Direct Path/랜덤IO/GC 대기(ASH 예시)
-- SELECT event, COUNT(*) samples
-- FROM   v$active_session_history
-- WHERE  sample_time > SYSDATE - 1/288
--   AND  session_type = 'FOREGROUND'
--   AND (event LIKE 'PX Deq%' OR event LIKE 'direct path%'
--        OR event LIKE 'db file sequential read' OR event LIKE 'gc %')
-- GROUP  BY event
-- ORDER  BY samples DESC;
```

---

## 한 줄 요약

- **스칼라 서브쿼리/함수**는 병렬에서 **로우당 호출 폭증** → **조인 변환/CASE/룩업**으로 **세트 처리**하라.
- **ROWNUM**은 **전역 순서 불가** → **`ORDER BY … FETCH FIRST`** 또는 **분석함수**로 Top-N을 **전역 보장**하라.
- **분배 전략/스큐/PGA·Temp/RAC**를 함께 살피면, 병렬 환경에서의 대부분 **병목**을 정확히 진단·해결할 수 있다.
