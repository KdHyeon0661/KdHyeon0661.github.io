---
layout: post
title: DB 심화 - 병렬 쿼리와 스칼라 서브쿼리 · 사용자 정의 함수 · ROWNUM · 병렬 처리 시 주의사항
date: 2025-11-25 17:25:23 +0900
category: DB 심화
---
# 병렬 쿼리와 스칼라 서브쿼리·UDF·ROWNUM·병렬 처리 주의사항

## 공통 실습 스키마 (한 번만 실행)

아래 실습은 **메커니즘 설명용**이라 데이터가 작습니다. 병렬의 병목/스큐/네트워크 효과를 제대로 보려면 뒤쪽 “대용량 데이터 생성 스크립트”까지 함께 실행하는 걸 권장합니다.

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;          -- DBMS_XPLAN 통계
ALTER SESSION SET parallel_degree_policy = MANUAL; -- 필요 시 AUTO로 변경

DROP TABLE sales PURGE;
CREATE TABLE sales (
  sales_id   NUMBER       PRIMARY KEY,
  cust_id    NUMBER       NOT NULL,
  sales_dt   DATE         NOT NULL,
  region_cd  VARCHAR2(6)  NOT NULL,
  amount     NUMBER(12,2) NOT NULL
);

DROP TABLE orders PURGE;
CREATE TABLE orders (
  order_id NUMBER PRIMARY KEY,
  cust_id  NUMBER NOT NULL,
  order_dt DATE   NOT NULL,
  amt      NUMBER(12,2)
);

DROP TABLE dim_customer PURGE;
CREATE TABLE dim_customer (
  cust_id      NUMBER PRIMARY KEY,
  region_group VARCHAR2(10),
  grade        VARCHAR2(10),
  active_yn    CHAR(1)
);

CREATE INDEX ix_sales_cust  ON sales(cust_id);
CREATE INDEX ix_orders_cust ON orders(cust_id);

INSERT INTO dim_customer VALUES (101,'APAC','GOLD','Y');
INSERT INTO dim_customer VALUES (202,'AMER','SILVER','Y');
INSERT INTO dim_customer VALUES (303,'EMEA','BRONZE','N');

INSERT INTO sales  VALUES (1,101, DATE '2025-02-10','KR',100);
INSERT INTO sales  VALUES (2,202, DATE '2025-02-11','US',170);
INSERT INTO sales  VALUES (3,202, DATE '2025-03-01','US',250);

INSERT INTO orders VALUES (10,101, DATE '2025-02-10', 300);
INSERT INTO orders VALUES (20,202, DATE '2025-02-11', 500);
INSERT INTO orders VALUES (30,202, DATE '2025-03-01', 700);

COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES',  method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'DIM_CUSTOMER');
END;
/
```

---

## 1) 병렬 실행(PQ) 내부 구조 리마인드 — 왜 “로우당 반복”이 치명적인가

병렬 쿼리는 “쿼리 하나를 여러 프로세스가 나눠 처리”하는 구조입니다. 핵심 구성요소는 다음과 같습니다. :contentReference[oaicite:1]{index=1}

- **QC(Query Coordinator)**: 사용자가 붙는 세션. 실행계획을 트리 형태로 DFO로 쪼개고 PX 서버를 할당/관리.
- **PX Server Set(S1, S2, …)**: 슬레이브 집합. 각 DFO를 수행.
- **DFO(Data Flow Operation)**: 병렬 실행의 “단위 작업”. 한 DFO 안에서 PX 슬레이브들이 동기화/분배/집계 수행.
- **TQ(Table Queue)**: DFO 간 또는 Producer→Consumer 간 **행 전달 파이프**. TQ를 얼마나 많이/어떻게 타는지가 네트워크·대기 핵심.

아스키 그림으로 보면:

```
        [ QC ]
          |
     ---- DFO 1 ----            (scan/filters)
     |  PX S1..Sn  |
     ----------------
          |
       PX SEND  (TQ#1 : HASH/BROADCAST/RR)
          |
     ---- DFO 2 ----            (join/aggregate/sort)
     |  PX S1..Sn  |
     ----------------
          |
        [ QC ]
```

여기서 중요한 사실:

1. **슬레이브는 자기 몫의 로우에 대해 “표현식/서브쿼리/함수”를 로우 단위로 평가한다.**  
2. 평가가 비싸면 **“슬레이브 수 × 로우 수” 만큼 비용이 터진다.**  
3. Producer가 너무 많이 보내거나(스큐), Consumer가 느리면 **TQ 버퍼가 꽉 차 Producer가 멈춘다.** 이때 대표적인 대기가  
   `PX Deq Credit: send blkd`, `PX Deq Credit: need buffer` 입니다. :contentReference[oaicite:2]{index=2}  

즉, **병렬 자체는 빠르게 만드는 도구가 아니라, 로우당 비용을 크게 만들면 오히려 폭발시키는 증폭기**입니다.

---

## 2) 병렬 쿼리와 스칼라 서브쿼리

### 2.1 스칼라 서브쿼리의 성질(병렬에서 왜 위험한가)

- **스칼라 서브쿼리**: SELECT 리스트/WHERE 등에서 **단일 값**을 반환하는 서브쿼리.
- 상관(correlated) 스칼라 서브쿼리는 **바깥 로우마다 실행**되는 NL 패턴입니다.
- Oracle은 **스칼라 서브쿼리 캐시**(SQL 엔진 내부 해시 테이블)를 두어 같은 입력 반복을 줄이기도 합니다. 하지만 이 캐시는  
  **“문장 실행 동안 세션 메모리에만 존재하는 로컬 캐시”**이며, 병렬에서는 **슬레이브별로 따로 생깁니다.** :contentReference[oaicite:3]{index=3}  

따라서 PQ에서의 “치명적 조합”:

- **PX 슬레이브가 로우를 나눠 가짐 → 동일 키가 슬레이브에 분산 → 캐시 히트율 급감**
- 결과적으로 **서브쿼리 재평가가 수십/수백 배**로 늘어날 수 있음.

---

### 2.2 나쁜 예: 병렬 + 상관 스칼라 서브쿼리

```sql
EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) monitor */
       s.sales_id,
       s.amount,
       (SELECT /* scalar subquery */ MAX(o.amt)
          FROM orders o
         WHERE o.cust_id = s.cust_id) AS max_amt
FROM   sales s;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +ALIAS +PARALLEL +NOTE'));
```

병렬 실행계획에서 자주 보이는 형태(전형적):

- `PX BLOCK ITERATOR` / `PX PARTITION` / `PX SEND` 아래에서  
  `FILTER` → `TABLE ACCESS BY INDEX ROWID (orders)` → `INDEX RANGE SCAN (ix_orders_cust)`
- **orders 접근이 바깥 로우 수만큼 반복**되고,  
  인덱스 기반 Random I/O가 늘어 `db file sequential read`가 튀기 쉽습니다.
- Producer/Consumer 속도 차가 나면 `PX Deq Credit: send blkd`가 AWR/ASH 상위로 올라옵니다. :contentReference[oaicite:4]{index=4}  

#### 병목을 “눈으로” 확인하는 법

1) 실제 커서 플랜에서 **Starts/Rows 폭발**을 확인:

```sql
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
     'BASIC +PARALLEL +ALIAS +PREDICATE +NOTE +STATS LAST'));
```

- 스칼라 서브쿼리 영역(orders 접근 단계)의 `Starts`가  
  `sales rows × PX slaves` 수준으로 나오면 **그 자체가 병목 원인**입니다.

2) ASH에서 wait 분포 확인:

```sql
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSDATE - 1/288   -- 최근 5분
  AND  (event LIKE 'db file sequential read%'
        OR event LIKE 'PX Deq Credit%'
        OR event LIKE 'PX Deq: Execute Reply%'
        OR event LIKE 'direct path read%')
GROUP  BY event
ORDER  BY samples DESC;
```

`db file sequential read` + `PX Deq Credit: send blkd`의 조합이면  
“로우당 서브쿼리 반복 + TQ 백프레셔(skew/ordering)” 의심이 1순위입니다. :contentReference[oaicite:5]{index=5}  

---

### 2.3 좋은 예: 스칼라 서브쿼리 **UNNEST**(조인 변환)

Oracle 12c 이후 옵티마이저는 **스칼라 서브쿼리를 OUTER JOIN + 집계로 변환(unnesting)**할 수 있고, 필요하면 `UNNEST/NO_UNNEST`로 제어할 수 있습니다. :contentReference[oaicite:6]{index=6}  

```sql
EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) parallel(o 16)
           unnest
           use_hash(o) monitor */
       s.sales_id,
       s.amount,
       m.max_amt
FROM   sales s
LEFT JOIN (
  SELECT /*+ parallel(o 16) */ cust_id, MAX(amt) AS max_amt
  FROM   orders o
  GROUP  BY cust_id
) m
  ON m.cust_id = s.cust_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +ALIAS +PARALLEL +NOTE'));
```

#### 왜 이게 병렬에서 압도적으로 좋은가

- `orders`를 **한 번만 스캔**해서 PX 슬레이브에서 **부분집계(PX PARTIAL GROUP BY)**  
- 중간 결과(고객별 max)만 TQ로 보내고  
- QC 또는 두 번째 DFO에서 **최종집계/조인**으로 마무리

즉,

- **로우당 반복 평가 제거**
- **Random I/O → Sequential/Hash 처리**
- **네트워크 바이트 대폭 감소**
- 스큐는 생길 수 있지만 “조인 분배 설계”로 해결 가능(아래 2.5 참고)

---

### 2.4 스칼라 서브쿼리 캐시를 “쓰고 싶을 때”의 현실적 결론

스칼라 서브쿼리 캐시는 다음 조건에서만 **보조적**으로 의미가 있습니다. :contentReference[oaicite:7]{index=7}  

- 입력 패턴이 작고(수백~수천)
- 바깥 로우가 엄청 크며
- 같은 입력이 “한 슬레이브 안에서” 많이 반복될 때

병렬에서 캐시 히트율이 떨어지는 이유는 “동일 키가 여러 슬레이브에 흩어지기” 때문입니다.  
이때는 `PQ_DISTRIBUTE`로 **같은 키를 같은 슬레이브로 몰아** 캐시 히트율/조인 지역성을 높이는 방법이 있습니다.

```sql
-- 동일 cust_id가 같은 PX로 모이도록 양쪽 HASH/HASH 분배
SELECT /*+ leading(s) use_hash(o)
           parallel(s 16) parallel(o 16)
           pq_distribute(s HASH HASH)
           pq_distribute(o HASH HASH) monitor */
       s.sales_id, s.amount,
       MAX(o.amt) OVER (PARTITION BY s.cust_id) AS max_amt_like
FROM   sales s
JOIN   orders o
  ON   o.cust_id = s.cust_id;
```

하지만 결론은 변하지 않습니다.

> **병렬 + 상관 스칼라 서브쿼리의 1순위 해법은 “조인으로 변환”이다.**  
> 캐시는 “그 다음에” 고려하는 보조 옵션입니다.

---

### 2.5 실전 확장: 스큐가 심한 키에서의 대응

스칼라 서브쿼리/조인 변환 후에도 **키 스큐**가 심하면 특정 PX가 과부하가 됩니다.  
이때의 진단/처방은 아래 5장(병렬 주의사항)에서 자세히 다루지만, 스칼라 서브쿼리 맥락에서 핵심만 적으면:

- 진단: `V$PQ_TQSTAT`에서 PX별 `NUM_ROWS/BYTES` 편차 확인
- 처방:
  - **SALT 컬럼**(해시 분산용 인공 키)
  - `PQ_DISTRIBUTE`를 `BROADCAST/NONE`로 바꿔 작은 쪽을 뿌리기
  - 파티션 테이블이면 **Partition-Wise Join** 유도

---

## 3) 병렬 쿼리와 사용자 정의 함수(UDF)

### 3.1 문제의 본질: SQL ↔ PL/SQL **컨텍스트 스위칭**

SQL 엔진에서 PL/SQL 함수를 호출하면

- 실행 스택/세션 상태를 SQL ↔ PL/SQL로 오가며
- 인자/리턴 값 마샬링이 일어나고
- 호출 횟수만큼 CPU 오버헤드가 붙습니다.

Oracle 12c+에 추가된 `PRAGMA UDF`가 이 오버헤드를 줄여주지만,  
**호출 횟수 자체를 줄이진 못합니다.** :contentReference[oaicite:8]{index=8}

그리고 병렬에서는 이 호출이:

> **PX 슬레이브 수 × 로우 수** 만큼 폭증합니다.

즉, UDF는 병렬 환경에서 가장 흔한 “CPU 병목 유발 스위치”입니다.

---

### 3.2 비추천 패턴: 로우당 PL/SQL UDF

```sql
CREATE OR REPLACE FUNCTION f_score(p_amt NUMBER)
RETURN NUMBER IS
BEGIN
  -- (복잡한 로직/패키지 호출/쿼리 등)
  RETURN CASE WHEN p_amt >= 500 THEN 3 WHEN p_amt >= 200 THEN 2 ELSE 1 END;
END;
/

EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount, f_score(s.amount) AS score
FROM   sales s;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +ALIAS +PARALLEL +NOTE'));
```

#### 왜 병렬에서 특히 나쁜가

- 슬레이브가 분산 처리하는 동안에도 **함수는 로우 단위(벡터화 불가)**  
- 함수 내부가 SQL을 호출하면  
  - **Recursive SQL 폭증**
  - 라이브러리 캐시 경합(특히 많은 슬레이브)
  - `library cache: mutex X` 같은 대기 가능

---

### 3.3 해법 1: **CASE/DECODE**로 SQL 내부화

가장 강력하고 안전합니다.

```sql
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount,
       CASE WHEN s.amount >= 500 THEN 3
            WHEN s.amount >= 200 THEN 2
            ELSE 1 END AS score
FROM   sales s;
```

- 컨텍스트 스위칭 0
- PX 슬레이브에서 **순수 SQL 연산**으로 처리
- CPU/확장성 최상

---

### 3.4 해법 2: 규칙을 **룩업 테이블로 치환(조인)**

UDF가 사실상 “범주화/매핑 규칙”이면 테이블화하세요.

```sql
CREATE TABLE score_rule (min_amt NUMBER, max_amt NUMBER, score NUMBER);
INSERT INTO score_rule VALUES (500, 1e18, 3);
INSERT INTO score_rule VALUES (200, 500-1e-9, 2);
INSERT INTO score_rule VALUES (0,   200-1e-9, 1);
COMMIT;

SELECT /*+ leading(s) use_nl(r) parallel(s 16) parallel(r 16) monitor */
       s.sales_id, s.amount, r.score
FROM   sales s
JOIN   score_rule r
  ON   s.amount BETWEEN r.min_amt AND r.max_amt;
```

병렬에선:

- rule이 작으니 `BROADCAST` 되거나
- NL로도 충분히 빠른 “룩업 조인” 구조

---

### 3.5 해법 3: DETERMINISTIC / RESULT_CACHE의 정확한 쓰임

- `DETERMINISTIC`: **동일 입력→동일 출력임을 옵티마이저에 선언**  
  그러나 “SQL에서 호출 횟수를 자동으로 줄여준다”는 보장은 없습니다.  
  (특히 상관 패턴/병렬에서는 효과가 제한적입니다.) :contentReference[oaicite:9]{index=9}

- `RESULT_CACHE`: 함수 결과를 **PL/SQL 엔진 캐시에 저장**해 반복 호출을 줄입니다.  
  다만 **캐시 탐색/동기화 비용도 있으므로**  
  - 입력 패턴이 작고  
  - 함수가 무겁고  
  - 반복이 매우 심할 때만 이득입니다. :contentReference[oaicite:10]{index=10}

실무 팁:

1) **가능하면 “함수 호출 자체를 없애는 설계(CASE/조인)”가 먼저**  
2) 부득이하게 함수가 남을 때만  
   `DETERMINISTIC` + (필요 시) `RESULT_CACHE`를 고려

---

### 3.6 해법 4: **PRAGMA UDF**로 호출 오버헤드 완화

Oracle 12.1+에서 사용 가능하고, SQL 호출 오버헤드를 줄입니다. :contentReference[oaicite:11]{index=11}

```sql
CREATE OR REPLACE FUNCTION f_score(p_amt NUMBER)
RETURN NUMBER
IS
  PRAGMA UDF;
BEGIN
  RETURN CASE WHEN p_amt >= 500 THEN 3 WHEN p_amt >= 200 THEN 2 ELSE 1 END;
END;
/
```

- “호출 횟수”는 그대로지만 **호출당 비용이 감소**
- 그래도 병렬에서 로우당 호출이면 구조적으로 한계가 있습니다.

---

### 3.7 해법 5: 세트 기반 아키텍처로 전환

UDF가 정말 복잡해서 SQL로 옮길 수 없다면:

- **PIPELINED TABLE FUNCTION**
- `PARALLEL_ENABLE`  

로 “행 단위”가 아니라 “세트 단위”로 처리하는 구조로 바꿉니다.  
단점은 코드/테스트/운영 난이도가 커진다는 점이라, **마지막 카드**로 쓰세요.

---

## 4) 병렬 쿼리와 ROWNUM / Top-N

### 4.1 ROWNUM의 작동 위치

`ROWNUM`은 “정렬된 논리 순서”가 아니라

> **실제 로우가 위로 흘러오는 순서대로 매기는 물리적 번호**

즉, **프로젝션 단계에서 생성**되고,  
`ROWNUM <= N`은 해당 단계에 **STOPKEY(조기 종료)**를 걸어주는 효과가 있습니다. :contentReference[oaicite:12]{index=12}

---

### 4.2 PQ에서 `ROWNUM <= N`이 위험한 이유

병렬에선 로우 스트림이 여러 개입니다.

- PX 슬레이브들이 각자 로우를 만들어 `ROWNUM`을 **자기 스트림 기준으로 부여**
- `ROWNUM <= N` 필터가 **슬레이브마다 적용**
- QC가 결과를 모은 다음에 **전역적으로 다시 N개로 자르는** 형태가 됩니다.

따라서 **“슬레이브별 N개씩” → 총 N×DOP 개가 QC로 올라온 뒤 cut** 될 수 있습니다.

```sql
SELECT /*+ parallel(s 8) monitor */
       *
FROM   sales s
WHERE  ROWNUM <= 10;
```

- 목적이 “아무 10개 빨리 보기”면 OK
- **전역 순서/Top-N 의미는 없음**

---

### 4.3 전역 Top-N을 보장하려면

#### 방법 A) 12c+ `FETCH FIRST N ROWS ONLY`

```sql
EXPLAIN PLAN FOR
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount
FROM   sales s
ORDER  BY s.amount DESC
FETCH FIRST 10 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL,NULL,'BASIC +PARALLEL +NOTE'));
```

PQ에서의 실행 메커니즘:

1) 각 PX 슬레이브가 **로컬 정렬 + 로컬 Top-N(STOPKEY)** 수행
2) 로컬 Top-N 결과만 QC로 전달(PX PARTIAL ORDER BY)
3) QC가 **전역 머지/정렬 후 최종 Top-N(STOPKEY)** 확정

즉, QC로 올라오는 로우는 대략 `N × DOP` 수준으로 제한됩니다. :contentReference[oaicite:13]{index=13}

> 핵심: **Top-N Pushdown**이 잘 일어나면 네트워크/정렬 비용이 크게 줄어듭니다.

#### 방법 B) 분석함수 `ROW_NUMBER()`로 전역 랭킹

```sql
SELECT /*+ parallel(s 16) monitor */
       *
FROM (
  SELECT s.*, ROW_NUMBER() OVER(ORDER BY s.amount DESC) AS rn
  FROM   sales s
)
WHERE rn <= 10;
```

- 내부적으로는 A와 유사한 Top-N pushdown/merge 패턴이 나옵니다.
- 다만 경우에 따라 “정렬 + 윈도우 처리” 비용이 더 들 수 있어  
  **A/B를 둘 다 테스트**하는 게 실전적입니다.

---

### 4.4 “FETCH FIRST가 더 느린 경우”의 원인과 대응

일부 환경에서 `FETCH FIRST`가 `ROWNUM`보다 느리게 보이는 사례가 있습니다.  
이는 대개

- 힌트/변환 차이로 인한 **실행계획 불안정**
- `FETCH FIRST`가 **다른 변환 경로**를 타면서 정렬 범위를 넓게 잡는 경우
- 혹은 통계/카디널리티 추정 오류

때문입니다. :contentReference[oaicite:14]{index=14}

대응:

1) **실제 실행계획을 통계 포함으로 비교**
2) `ORDER BY`를 지원하는 **인덱스**가 있다면  
   - 인덱스 범위 스캔 + STOPKEY가 더 빠를 수 있음
3) 변환이 꼬이면  
   - 인라인 뷰 + `ROWNUM` 패턴으로 **계획을 고정**하는 것도 실전 옵션

---

### 4.5 절대 금지 패턴: `ROWNUM`과 `ORDER BY`의 순서 착각

```sql
-- 잘못된 Top-N
SELECT *
FROM   sales
WHERE  ROWNUM <= 10
ORDER  BY amount DESC;
```

이건

1) 먼저 임의 10개가 선택되고
2) 그 10개만 정렬됩니다.

즉 “Top-10”이 아니라 “Random-10 정렬”입니다.  
병렬이면 이 불안정성이 더 커집니다.

---

## 5) 병렬 처리 시 주의사항(체크리스트) — 실전에서 제일 중요한 파트

### 5.1 실행계획에서 **PX SEND/RECEIVE + 분배 방식**을 먼저 본다

대표 분배:

- `HASH`: 조인/집계 키 기반 분배
- `BROADCAST`: 작은 쪽을 모든 슬레이브로 복제
- `ROUND-ROBIN`: 키 없이 균등 분배
- `PARTITION`: 파티션 기준 분배

Oracle은 조인/정렬/집계에서 **분배→재분배(RESHUFFLE)** 를 자동으로 삽입합니다.  
결국 PQ 튜닝은 **“데이터가 어디로 얼마나 흐르는가”**를 설계하는 일입니다. :contentReference[oaicite:15]{index=15}

---

### 5.2 스큐(skew) 진단: `V$PQ_TQSTAT`

```sql
SELECT dfo_number, tq_id, server_type, inst_id, process,
       num_rows, bytes
FROM   v$pq_tqstat
ORDER  BY dfo_number, tq_id, server_type, inst_id, process;
```

- `NUM_ROWS`/`BYTES`가 PX별로 크게 차이나면 스큐
- 스큐가 심하면 Producer PX가 Consumer를 기다리며  
  `PX Deq Credit: send blkd` 대기가 폭증합니다. :contentReference[oaicite:16]{index=16}

#### 스큐 해소법(우선순위)

1) 조인 키 재설계 / SALT 컬럼 추가  
2) 분배 변경  
   - 작은 테이블을 `BROADCAST`  
   - 큰 테이블을 `HASH`  
3) 파티션 테이블이면 **Partition-Wise Join**

---

### 5.3 PGA/Temp/Direct Path 대기

병렬의 해시조인/정렬/집계는 **워크에어리어(PGA)** 크기에 민감합니다.

- PGA가 부족하면 Temp로 스필  
- 대표 대기: `direct path read temp`, `direct path write temp`  
  이는 “병렬/대용량에서 정상적으로 나타나기도 하나”,  
  과도하면 DOP 과다/PGA 부족/Temp I/O 병목을 의미합니다. :contentReference[oaicite:17]{index=17}

실전 팁:

- `PGA_AGGREGATE_TARGET`(AUTO)로 워크에어리어 확보
- Temp 스필이 과도하면  
  - DOP 낮추기  
  - 조인 순서/분배 재설계  
  - 인덱스/프리어그리게이션으로 중간 결과 줄이기

---

### 5.4 “DOP를 키우면 무조건 빨라진다”는 착각

AskTOM에서도 반복되는 결론:  
**과한 병렬은 오히려 느리다.** :contentReference[oaicite:18]{index=18}

원인:

- PX 서버 기동/제어 비용
- TQ 네트워크/버퍼 오버헤드
- Producer/Consumer 불균형
- 스토리지 대역폭 한계

실무에서는 “**CPU 코어 수 × I/O 대역폭 × 쿼리 형태**”를 보고  
**최적 DOP 지점**이 따로 존재합니다.

---

### 5.5 RAC 환경 고려

RAC에선 해시 재분배가 **인터커넥트 병목**을 만들 수 있습니다.

- `gc cr request`, `gc buffer busy` 같은 글로벌 캐시 대기 증가 가능
- 해결:
  - **Full Partition-Wise Join** 유도
  - 서비스/파티션 affinity로 같은 파티션이 같은 인스턴스에서 처리 :contentReference[oaicite:19]{index=19}

---

### 5.6 병렬 DML(PDML) 주의

- PDML 후 같은 세션에서 즉시 읽기/수정하면 **ORA-12838**  
  → **COMMIT 후 재시도**
- 인덱스/제약/트리거 때문에 PDML이 **Serial 강등**될 수 있음  
  실행계획의 `NOTE`를 꼭 확인. :contentReference[oaicite:20]{index=20}

---

### 5.7 통계/카디널리티가 병렬 분배를 망친다

- 통계가 틀리면:
  - HASH 해야 할 걸 BROADCAST 하거나
  - 불필요한 재분배/정렬/Temp 스필 유발
- 해결:
  - 최신 통계 유지
  - 힌트로 **의도된 데이터 흐름 강제**

대표 힌트:

- `PARALLEL(t dop)`
- `PQ_DISTRIBUTE(t1 HASH HASH | BROADCAST NONE | PARTITION PARTITION)`
- `LEADING`, `USE_HASH`, `USE_NL`, `SWAP_JOIN_INPUTS`
- 서브쿼리 변환 제어: `UNNEST`, `NO_UNNEST`, `PUSH_SUBQ`, `NO_MERGE`, `MATERIALIZE`

:contentReference[oaicite:21]{index=21}

---

## 6) 실습 시나리오 모음(바로 적용 가능)

### 6.1 스칼라 서브쿼리 → 조인 변환 전/후

```sql
-- BEFORE
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, s.amount,
       (SELECT MAX(o.amt) FROM orders o WHERE o.cust_id = s.cust_id) max_amt
FROM   sales s;

-- AFTER
SELECT /*+ leading(s) use_hash(m) parallel(s 16) parallel(m 16) monitor */
       s.sales_id, s.amount, m.max_amt
FROM   sales s
LEFT JOIN (
  SELECT cust_id, MAX(amt) max_amt
  FROM   orders
  GROUP  BY cust_id
) m
  ON m.cust_id = s.cust_id;
```

체크 포인트:

- BEFORE에서 orders 접근 단계 `Starts` 폭발
- AFTER에서 orders는 1회 스캔 + PX partial group by

---

### 6.2 UDF 제거/대체

```sql
-- BEFORE: UDF
SELECT /*+ parallel(s 16) monitor */
       s.sales_id, f_score(s.amount)
FROM   sales s;

-- AFTER: CASE
SELECT /*+ parallel(s 16) monitor */
       s.sales_id,
       CASE WHEN amount>=500 THEN 3 WHEN amount>=200 THEN 2 ELSE 1 END AS score
FROM   sales s;

-- AFTER: 룩업 조인
SELECT /*+ parallel(s 16) parallel(r 16) use_nl(r) monitor */
       s.sales_id, r.score
FROM   sales s
JOIN   score_rule r
  ON   s.amount BETWEEN r.min_amt AND r.max_amt;
```

---

### 6.3 전역 Top-N

```sql
-- FETCH FIRST
SELECT /*+ parallel(s 16) monitor */
       sales_id, amount
FROM   sales
ORDER  BY amount DESC
FETCH FIRST 10 ROWS ONLY;

-- 분석함수
SELECT /*+ parallel(s 16) monitor */
       *
FROM (
  SELECT s.*, ROW_NUMBER() OVER(ORDER BY amount DESC) rn
  FROM   sales s
)
WHERE rn <= 10;
```

실행계획에서

- `PX PARTIAL ORDER BY`
- `COUNT STOPKEY`
- 최종 QC 정렬/STOPKEY

구조가 잘 나오는지 확인.

---

### 6.4 분배 전략으로 캐시/조인 비용 완화

```sql
SELECT /*+ leading(s) use_hash(o)
           parallel(s 16) parallel(o 16)
           pq_distribute(s HASH HASH)
           pq_distribute(o HASH HASH) monitor */
       s.cust_id, SUM(s.amount) amt, MAX(o.amt) mx
FROM   sales s
JOIN   orders o
  ON   o.cust_id = s.cust_id
GROUP  BY s.cust_id;
```

- 동일 키가 동일 PX로 모이면  
  조인/집계 지역성이 좋아지고 TQ 스큐가 줄어듭니다.

---

## 7) 대용량 데이터 생성(병렬 효과 관측용)

실습 데이터가 작으면 PQ가 Serial로 강등되거나, 병목/대기 관측이 어렵습니다.  
아래로 100만 로우 정도를 만들어 “진짜 PQ 현상”을 보세요.

```sql
TRUNCATE TABLE sales;
TRUNCATE TABLE orders;

INSERT /*+ append */ INTO sales
SELECT level                                 AS sales_id,
       MOD(level, 50000) + 1                 AS cust_id,
       DATE '2024-01-01' + MOD(level, 365)   AS sales_dt,
       CASE MOD(level,5)
         WHEN 0 THEN 'US' WHEN 1 THEN 'UK' WHEN 2 THEN 'DE'
         WHEN 3 THEN 'FR' ELSE 'KR' END      AS region_cd,
       DBMS_RANDOM.VALUE(10, 1000)           AS amount
FROM dual
CONNECT BY level <= 1000000;

INSERT /*+ append */ INTO orders
SELECT level                                 AS order_id,
       MOD(level, 50000) + 1                 AS cust_id,
       DATE '2024-01-01' + MOD(level, 365)   AS order_dt,
       DBMS_RANDOM.VALUE(10, 2000)           AS amt
FROM dual
CONNECT BY level <= 1000000;

COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'SALES');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS');
END;
/
```

이제부터는

- 스칼라 서브쿼리 bad case가 **진짜 지옥**
- 조인 변환/분배 힌트의 효과가 **수치로 관측**
- `V$PQ_TQSTAT`, `ASH`, `direct path read temp`, `PX Deq Credit`가 **뚜렷하게 보일 것**

---

## 8) 모니터링 루틴(권장 템플릿)

```sql
-- 실제 실행 플랜(통계 포함)
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
     'BASIC +PARALLEL +ALIAS +PREDICATE +NOTE +STATS LAST'));

-- TQ 스큐/바이트
SELECT dfo_number, tq_id, server_type, inst_id, process,
       num_rows, bytes
FROM   v$pq_tqstat
ORDER  BY dfo_number, tq_id, server_type, inst_id, process;

-- 최근 병렬/Temp/랜덤IO/GC 대기(ASH)
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSDATE - 1/288
  AND (event LIKE 'PX Deq%'
       OR event LIKE 'direct path%'
       OR event LIKE 'db file sequential read%'
       OR event LIKE 'gc %')
GROUP  BY event
ORDER  BY samples DESC;
```

---

## 한 줄 요약(실무용 결론)

1) **스칼라 서브쿼리/상관 표현식**은 병렬에서 **로우당 반복 폭증**이 핵심 병목  
   → **UNNEST(조인 변환) + 병렬 집계/해시 조인**으로 세트 처리하라. :contentReference[oaicite:22]{index=22}  

2) **PL/SQL UDF**는 병렬에서 **컨텍스트 스위칭이 DOP×로우 만큼 증폭**  
   → **CASE/DECODE/룩업 조인**으로 없애고, 불가하면 **PRAGMA UDF/RESULT_CACHE는 보조적**으로만 써라. :contentReference[oaicite:23]{index=23}  

3) **ROWNUM은 전역 순서가 없다.**  
   → 전역 Top-N은 `ORDER BY … FETCH FIRST N` 또는 `ROW_NUMBER()`로 보장하고,  
   병렬에선 PX partial Top-N + QC stopkey 구조를 확인하라. :contentReference[oaicite:24]{index=24}  

4) 병렬 튜닝의 80%는 **분배/스큐/Temp/PGA/네트워크**다.  
   → 실행계획의 PX SEND, `V$PQ_TQSTAT`, `PX Deq Credit`, `direct path read temp`를 같이 보고  
   **의도된 데이터 흐름을 설계**하면 대부분의 병목은 정확히 잡힌다. :contentReference[oaicite:25]{index=25}  