---
layout: post
title: 영상처리 - 영상 처리 툴 UI 프레임워크 구축 (C#)
date: 2025-12-10 18:30:23 +0900
category: 영상처리
---
# 영상 처리 툴 UI 프레임워크 구축

## UI 프레임워크 설계 개요

본 장에서는 앞서 구현한 **MyImage 영상 엔진**을 실제로 조작·시각화할 수 있는  
WPF 기반 영상 처리 툴 UI 프레임워크를 구축한다. 이 프레임워크는 단순한 뷰어가 아닌,  
향후 다양한 영상 처리 알고리즘을 실험하고 분석할 수 있는 **통합 개발 환경**의 기반이 된다.

핵심 목표는 다음과 같다.

- 영상 엔진과 UI의 완전한 분리 (MVVM 패턴)
- 대용량 영상에서도 끊김 없는 인터랙션 (가상화 및 렌더링 최적화)
- 영상 처리 결과에 대한 즉각적인 피드백 제공 (히스토그램, 실시간 통계)

---

## 전체 UI 아키텍처

```
[File System]
    |
    v
BMP Loader (엔진 계층)
    |
    v
MyImage (영상 엔진)
    ├─ Pixel Buffer (Raw Data)
    ├─ Metadata (Width, Height, Stride)
    └─ Processing Methods
    |
    v
ImageViewModel (비즈니스 로직)
    ├─ Zoom / Pan 컨트롤러
    ├─ Histogram 계산기
    ├─ Status 정보 관리자
    └─ Command 처리기
    |
    v
MainView (표현 계층)
    ├─ ImageDisplay (가상화 캔버스)
    ├─ HistogramView (시각화 컴포넌트)
    ├─ StatusBar (실시간 정보)
    └─ ToolPanel (알고리즘 선택)
```

---

## 1. 파일 열기와 저장

### 1.1 고수준 API: ViewModel에서의 파일 열기

```csharp
public void OpenImage(string path)
{
    // 1. 엔진을 통해 영상 로드 (UI는 포맷을 알 필요 없음)
    MyImage image = _bmpLoader.Load(path);
    
    // 2. 현재 영상으로 설정
    CurrentImage = image;
    
    // 3. 렌더링 파이프라인 실행
    RenderImage(image);
    
    // 4. 분석 정보 업데이트
    UpdateHistogram(image);
    UpdateImageStatistics(image);
    
    // 5. 상태 정보 초기화
    StatusText = $"Loaded: {Path.GetFileName(path)} | Size: {image.Width}x{image.Height}";
}
```

**설명**: 이 메서드는 UI와 엔진 사이의 **추상화 계층** 역할을 합니다. UI는 단순히 "파일 열기" 요청만 하고,  
구체적인 BMP 포맷 파싱은 엔진 계층의 `BmpLoader`가 담당합니다. 이는 **단일 책임 원칙(SRP)** 을 따르며,  
다른 이미지 포맷(PNG, JPEG 등)을 추가할 때 UI 코드를 변경하지 않고 확장할 수 있도록 합니다.

---

### 1.2 내부 구현: BMP Raw Data 저장

```csharp
public void SaveImage(string path, MyImage image)
{
    // 1. 파일 스트림 생성
    using FileStream fs = new FileStream(path, FileMode.Create);
    using BinaryWriter bw = new BinaryWriter(fs);

    // 2. BMP 헤더 작성 (파일 구조 정보)
    WriteBmpHeader(bw, image);
    
    // 3. 실제 픽셀 데이터 작성
    WritePixelData(bw, image);
    
    // 4. 플러시 및 자원 해제
    bw.Flush();
    
    StatusText = $"Saved: {Path.GetFileName(path)}";
}
```

**헤더 구조**: BMP 파일은 다음으로 구성됩니다:
- 파일 헤더(14바이트): 파일 타입, 크기 등
- 정보 헤더(40바이트): 영상 크기, 색상 깊이, 압축 방식 등
- 색상 테이블(옵션): 팔레트 색상
- 픽셀 데이터: 실제 이미지 데이터

---

### 1.3 저수준 픽셀 데이터 쓰기 - 메모리 레이아웃 이해

```csharp
private void WritePixelData(BinaryWriter bw, MyImage image)
{
    int width = image.Width;
    int height = image.Height;
    
    // BMP 형식은 각 행(row)이 4바이트 배수가 되어야 함
    // 예: 3픽셀(3바이트) → 4바이트, 5픽셀(5바이트) → 8바이트
    int stride = ((width * 3 + 3) / 4) * 4; // 3은 RGB 채널
    int padding = stride - (width * 3);
    
    byte[] paddingBytes = new byte[padding];
    
    // BMP는 하단에서 상단으로 저장됨 (좌하단이 원점)
    for (int y = height - 1; y >= 0; y--)
    {
        for (int x = 0; x < width; x++)
        {
            // 픽셀 데이터는 보통 BGR 순서로 저장
            Color pixel = image.GetPixel(x, y);
            bw.Write(pixel.B);  // Blue
            bw.Write(pixel.G);  // Green
            bw.Write(pixel.R);  // Red
        }
        
        // 패딩 바이트 추가 (4바이트 정렬)
        if (padding > 0)
        {
            bw.Write(paddingBytes);
        }
    }
}
```

**중요 개념**:
- **Stride**: 실제 메모리에서 한 행(row)의 바이트 수. 4바이트 정렬을 위해 패딩이 추가될 수 있음
- **Bottom-up 저장**: BMP는 수학적 좌표계와 달리 화면 좌표계를 사용하여 하단부터 저장
- **BGR 순서**: OpenCV 등의 라이브러리와 일관성을 위해 BGR 순서를 사용

---

## 2. Zoom 기능 구현 - 매트릭스 변환의 이해

### 2.1 수학적 모델: 아핀 변환(Affine Transformation)

Zoom은 **균일 스케일 변환(Uniform Scaling)** 으로 표현됩니다:

\[
\begin{bmatrix}
x' \\
y'
\end{bmatrix}
=
\begin{bmatrix}
s & 0 \\
0 & s
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
+
\begin{bmatrix}
t_x \\
t_y
\end{bmatrix}
\]

여기서:
- \( s \): 스케일 팩터 (ZoomFactor)
- \( t_x, t_y \): 이동량 (PanX, PanY)

---

### 2.2 고수준 API: Zoom 제어 로직

```csharp
public void Zoom(double delta, Point centerPoint)
{
    // 1. 이전 스케일 저장
    double oldScale = ZoomFactor;
    
    // 2. 새로운 스케일 계산 (마우스 휠 델타에 비례)
    ZoomFactor *= Math.Pow(1.1, delta); // delta: 마우스 휠 틱 수
    
    // 3. 중심점 기준으로 Zoom (중심점이 고정됨)
    if (CurrentImage != null)
    {
        // 화면 좌표를 이미지 좌표로 변환
        Point imagePoint = ConvertToImageCoordinates(centerPoint);
        
        // 중심점을 기준으로 Pan 조정
        PanX = centerPoint.X - (imagePoint.X * ZoomFactor);
        PanY = centerPoint.Y - (imagePoint.Y * ZoomFactor);
    }
    
    // 4. 변환 적용
    ApplyTransform();
}
```

**사용 예시**:
```csharp
// 마우스 휠 이벤트 핸들러
private void OnMouseWheel(object sender, MouseWheelEventArgs e)
{
    // e.Delta: 휠 틱 수 (양수=확대, 음수=축소)
    // e.GetPosition(imageCanvas): Zoom 중심점
    _viewModel.Zoom(e.Delta / 120.0, e.GetPosition(imageCanvas));
}
```

---

### 2.3 저수준 구현: WPF 변환 시스템

```csharp
private void ApplyTransform()
{
    // 1. 변환 그룹 생성 (여러 변환을 조합)
    TransformGroup transformGroup = new TransformGroup();
    
    // 2. 스케일 변환: 이미지 크기 조정
    // ScaleTransform은 지정된 점을 중심으로 스케일링
    ScaleTransform scale = new ScaleTransform(ZoomFactor, ZoomFactor);
    
    // 3. 이동 변환: 뷰포트 이동
    TranslateTransform translate = new TranslateTransform(PanX, PanY);
    
    // 4. 변환 순서 중요: 먼저 스케일, 후에 이동
    transformGroup.Children.Add(scale);
    transformGroup.Children.Add(translate);
    
    // 5. UI 요소에 변환 적용
    ImageTransform = transformGroup;
    
    // 6. 클리핑 영역 업데이트 (성능 최적화)
    UpdateViewport();
}
```

**성능 최적화**:
```csharp
private void UpdateViewport()
{
    if (CurrentImage == null) return;
    
    // 1. 현재 뷰포트 계산 (화면에 보이는 영역)
    Rect viewport = CalculateViewport();
    
    // 2. 가상화: 보이는 부분만 렌더링
    RenderOnlyVisibleRegion(viewport);
    
    // 3. 상태바 업데이트
    StatusText = $"Zoom: {ZoomFactor:F2}x | Viewport: {viewport}";
}
```

---

## 3. Pan 기능 구현 - 실시간 인터랙션

### 3.1 좌표 이동 모델

Pan은 단순한 **평행 이동(Translation)** 입니다:

\[
x' = x + \Delta x,\quad y' = y + \Delta y
\]

---

### 3.2 마우스 드래그 기반 Pan 처리

```csharp
private Point _lastMousePosition;
private bool _isPanning = false;

public void StartPan(Point mousePosition)
{
    _lastMousePosition = mousePosition;
    _isPanning = true;
    Cursor = Cursors.Hand; // 커서 변경으로 피드백 제공
}

public void UpdatePan(Point currentMousePosition)
{
    if (!_isPanning || CurrentImage == null) return;
    
    // 1. 마우스 이동량 계산
    double dx = currentMousePosition.X - _lastMousePosition.X;
    double dy = currentMousePosition.Y - _lastMousePosition.Y;
    
    // 2. Pan 위치 업데이트
    PanX += dx;
    PanY += dy;
    
    // 3. 기준점 업데이트
    _lastMousePosition = currentMousePosition;
    
    // 4. 변환 즉시 적용
    ApplyTransform();
    
    // 5. 실시간 상태 업데이트
    UpdateStatus(currentMousePosition);
}

public void EndPan()
{
    _isPanning = false;
    Cursor = Cursors.Arrow;
}
```

**UI 통합**:
```xml
<Image x:Name="DisplayImage"
       MouseLeftButtonDown="OnMouseDown"
       MouseMove="OnMouseMove"
       MouseLeftButtonUp="OnMouseUp">
    <Image.RenderTransform>
        <TransformGroup>
            <ScaleTransform ScaleX="{Binding ZoomFactor}" 
                           ScaleY="{Binding ZoomFactor}"/>
            <TranslateTransform X="{Binding PanX}" 
                               Y="{Binding PanY}"/>
        </TransformGroup>
    </Image.RenderTransform>
</Image>
```

---

## 4. 히스토그램 계산 - 영상 분석의 핵심

### 4.1 수학적 정의와 의미

히스토그램은 **영상의 톤(Tone) 분포**를 나타냅니다:

- **정의**: \( h(r_k) = n_k \)
  - \( r_k \): k번째 밝기 값 (0~255)
  - \( n_k \): 해당 밝기를 가진 픽셀 수

- **정규화된 히스토그램** (확률 밀도 함수):
  \[
  p(r_k) = \frac{n_k}{N}, \quad N = \text{총 픽셀 수}
  \]

**히스토그램 분석의 응용**:
- **명암 대비**: 히스토그램이 좁게 분포 → 낮은 대비
- **밝기 편향**: 히스토그램이 한쪽으로 치우침 → 과/저노출
- **이진화 임계값 결정**: 밸리(valley) 지점 찾기

---

### 4.2 고수준 API: 히스토그램 생성 및 분석

```csharp
public HistogramData BuildHistogram(MyImage image, Channel channel = Channel.Gray)
{
    // 1. 히스토그램 배열 초기화 (256 빈)
    int[] histogram = new int[256];
    int totalPixels = image.Width * image.Height;
    
    // 2. 채널별 히스토그램 계산
    switch (channel)
    {
        case Channel.Red:
            CalculateChannelHistogram(image, histogram, 0); // R 채널
            break;
        case Channel.Green:
            CalculateChannelHistogram(image, histogram, 1); // G 채널
            break;
        case Channel.Blue:
            CalculateChannelHistogram(image, histogram, 2); // B 채널
            break;
        case Channel.Gray:
            CalculateGrayHistogram(image, histogram);
            break;
    }
    
    // 3. 통계 정보 계산
    var stats = CalculateHistogramStatistics(histogram, totalPixels);
    
    // 4. 히스토그램 데이터 패키징
    return new HistogramData
    {
        Values = histogram,
        Statistics = stats,
        Channel = channel
    };
}
```

---

### 4.3 저수준 구현: 메모리 효율적인 계산

```csharp
private unsafe void CalculateGrayHistogram(MyImage image, int[] histogram)
{
    int width = image.Width;
    int height = image.Height;
    
    // 1. 메모리 고정 (성능 최적화)
    fixed (byte* src = image.Buffer)
    {
        byte* ptr = src;
        
        // 2. 모든 픽셀 순회
        for (int i = 0; i < width * height; i++)
        {
            // 3. 그레이스케일 값 계산 (표준 공식)
            // Y = 0.299R + 0.587G + 0.114B (인간의 색감 반영)
            byte gray = (byte)((*ptr * 0.114) +       // B
                              (*(ptr + 1) * 0.587) +  // G
                              (*(ptr + 2) * 0.299));  // R
            
            // 4. 히스토그램 빈 증가
            histogram[gray]++;
            
            // 5. 다음 픽셀로 이동 (RGB 채널)
            ptr += 3;
        }
    }
}

private HistogramStatistics CalculateHistogramStatistics(int[] histogram, int totalPixels)
{
    int min = 255, max = 0;
    long sum = 0;
    int median = 0;
    
    // 1. 최소/최대 값 찾기
    for (int i = 0; i < 256; i++)
    {
        if (histogram[i] > 0)
        {
            if (i < min) min = i;
            if (i > max) max = i;
            sum += i * histogram[i];
        }
    }
    
    // 2. 중앙값 계산
    int half = totalPixels / 2;
    int count = 0;
    for (int i = 0; i < 256; i++)
    {
        count += histogram[i];
        if (count >= half)
        {
            median = i;
            break;
        }
    }
    
    return new HistogramStatistics
    {
        Min = min,
        Max = max,
        Mean = (double)sum / totalPixels,
        Median = median,
        StdDev = CalculateStandardDeviation(histogram, totalPixels)
    };
}
```

---

### 4.4 히스토그램 시각화 컴포넌트

```csharp
public class HistogramView : FrameworkElement
{
    private int[] _histogramData;
    private int _maxFrequency;
    
    protected override void OnRender(DrawingContext dc)
    {
        base.OnRender(dc);
        
        if (_histogramData == null) return;
        
        // 1. 배경 그리기
        dc.DrawRectangle(Brushes.White, null, 
                        new Rect(0, 0, ActualWidth, ActualHeight));
        
        // 2. 히스토그램 막대 그리기
        double barWidth = ActualWidth / 256.0;
        
        for (int i = 0; i < 256; i++)
        {
            // 3. 정규화: 빈도를 높이로 변환
            double normalizedHeight = (_histogramData[i] / (double)_maxFrequency) 
                                      * ActualHeight;
            
            // 4. 막대 그리기
            Rect barRect = new Rect(
                i * barWidth,
                ActualHeight - normalizedHeight,
                barWidth,
                normalizedHeight);
            
            // 5. 색상 그라데이션 (저명도→고명도)
            Color barColor = Color.FromArgb(180, (byte)i, (byte)i, (byte)i);
            dc.DrawRectangle(new SolidColorBrush(barColor), null, barRect);
        }
        
        // 6. 격자 및 레이블 추가
        DrawGridAndLabels(dc);
    }
}
```

---

## 5. 상태바(Status Bar) 정보 시스템

### 5.1 실시간 정보 표시 체계

상태바는 **영상 처리 작업의 컨텍스트**를 제공합니다:

```csharp
public class StatusViewModel : INotifyPropertyChanged
{
    // 기본 정보
    public string ImageInfo { get; set; } = "No image loaded";
    public string MousePosition { get; set; } = "X: -, Y: -";
    public string PixelValue { get; set; } = "Value: -";
    
    // 처리 상태
    public string OperationStatus { get; set; } = "Ready";
    public double ProgressValue { get; set; }
    public bool IsProcessing { get; set; }
    
    // 메모리 정보
    public string MemoryUsage { get; set; }
    
    public void UpdatePixelInfo(int x, int y, MyImage image)
    {
        if (image == null || 
            x < 0 || x >= image.Width || 
            y < 0 || y >= image.Height)
        {
            MousePosition = "X: -, Y: -";
            PixelValue = "Value: -";
            return;
        }
        
        // 1. 좌표 정보
        MousePosition = $"X: {x}, Y: {y}";
        
        // 2. 픽셀 값 (채널별)
        Color pixel = image.GetPixel(x, y);
        PixelValue = $"RGB: ({pixel.R}, {pixel.G}, {pixel.B}) | " +
                    $"Gray: {pixel.GrayValue} | " +
                    $"HSV: ({pixel.H:F1}, {pixel.S:F1}, {pixel.V:F1})";
        
        // 3. 지역 통계 (3x3 윈도우)
        UpdateLocalStatistics(x, y, image);
    }
    
    private void UpdateLocalStatistics(int centerX, int centerY, MyImage image)
    {
        // 3x3 윈도우 평균 및 표준편차 계산
        double sum = 0;
        List<byte> values = new List<byte>();
        
        for (int dy = -1; dy <= 1; dy++)
        {
            for (int dx = -1; dx <= 1; dx++)
            {
                int x = centerX + dx;
                int y = centerY + dy;
                
                if (x >= 0 && x < image.Width && y >= 0 && y < image.Height)
                {
                    byte value = image.GetPixelGray(x, y);
                    values.Add(value);
                    sum += value;
                }
            }
        }
        
        if (values.Count > 0)
        {
            double mean = sum / values.Count;
            double variance = values.Select(v => Math.Pow(v - mean, 2)).Sum() / values.Count;
            
            LocalStats = $"Local Mean: {mean:F1}, StdDev: {Math.Sqrt(variance):F1}";
        }
    }
}
```

---

### 5.2 툴팁과 상호작용 피드백

```csharp
// 이미지 위에 마우스 호버 시 상세 정보 표시
private void OnMouseMoveOverImage(object sender, MouseEventArgs e)
{
    Point mousePos = e.GetPosition(imageCanvas);
    
    // 1. 화면 좌표 → 이미지 좌표 변환
    Point imagePoint = ConvertToImageCoordinates(mousePos);
    int x = (int)imagePoint.X;
    int y = (int)imagePoint.Y;
    
    // 2. 상태바 업데이트
    _statusViewModel.UpdatePixelInfo(x, y, CurrentImage);
    
    // 3. 툴팁 표시 (고급 정보)
    if (e.LeftButton == MouseButtonState.Released)
    {
        ShowAdvancedTooltip(mousePos, x, y);
    }
    
    // 4. 선택 영역 표시 (드래그 시)
    if (_isSelecting)
    {
        UpdateSelectionRectangle(mousePos);
    }
}
```

---

## 6. 이벤트 흐름과 데이터 바인딩

### 6.1 MVVM 패턴 구현 구조

```
┌─────────────────┐    Command     ┌──────────────────┐
│     View        │───────────────▶│   ViewModel      │
│                 │◀───────────────│                  │
│ - XAML 정의      │  Data Binding │ - 비즈니스 로직   │
│ - 이벤트 핸들러   │               │ - 상태 관리       │
└─────────────────┘               └──────────────────┘
                                           │
                                           │ Engine API
                                           ▼
                                 ┌──────────────────┐
                                 │   영상 엔진       │
                                 │                  │
                                 │ - 픽셀 처리       │
                                 │ - 알고리즘        │
                                 └──────────────────┘
```

---

### 6.2 명령(Command) 패턴 구현

```csharp
public class ImageProcessingCommands
{
    // 파일 명령
    public ICommand OpenCommand { get; }
    public ICommand SaveCommand { get; }
    public ICommand SaveAsCommand { get; }
    
    // 편집 명령
    public ICommand UndoCommand { get; }
    public ICommand RedoCommand { get; }
    
    // 처리 명령
    public ICommand ApplyFilterCommand { get; }
    public ICommand AdjustBrightnessCommand { get; }
    public ICommand EqualizeHistogramCommand { get; }
    
    public ImageProcessingCommands(ImageViewModel viewModel)
    {
        OpenCommand = new RelayCommand(
            execute: () => viewModel.OpenImageDialog(),
            canExecute: () => true);
            
        ApplyFilterCommand = new RelayCommand(
            execute: (parameter) => 
            {
                if (parameter is FilterType filterType)
                {
                    viewModel.ApplyFilter(filterType);
                }
            },
            canExecute: () => viewModel.CurrentImage != null);
    }
}

// RelayCommand 구현
public class RelayCommand : ICommand
{
    private readonly Action<object> _execute;
    private readonly Func<object, bool> _canExecute;
    
    public event EventHandler CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }
    
    public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }
    
    public bool CanExecute(object parameter) => _canExecute?.Invoke(parameter) ?? true;
    
    public void Execute(object parameter) => _execute(parameter);
}
```

---

### 6.3 데이터 바인딩 예제

```xml
<Window x:Class="ImageProcessor.MainWindow"
        DataContext="{Binding MainViewModel, Source={StaticResource Locator}}">
    
    <!-- 이미지 디스플레이 -->
    <Image Source="{Binding DisplayImage}"
           RenderTransform="{Binding ImageTransform}"
           MouseLeftButtonDown="{Binding StartPanCommand}"
           MouseMove="{Binding UpdatePanCommand}"
           MouseLeftButtonUp="{Binding EndPanCommand}"
           MouseWheel="{Binding ZoomCommand}">
    </Image>
    
    <!-- 상태바 -->
    <StatusBar DockPanel.Dock="Bottom">
        <StatusBarItem>
            <TextBlock Text="{Binding StatusViewModel.ImageInfo}"/>
        </StatusBarItem>
        <Separator/>
        <StatusBarItem>
            <TextBlock Text="{Binding StatusViewModel.MousePosition}"/>
        </StatusBarItem>
        <Separator/>
        <StatusBarItem>
            <TextBlock Text="{Binding StatusViewModel.PixelValue}"/>
        </StatusBarItem>
    </StatusBar>
    
    <!-- 히스토그램 -->
    <local:HistogramView Data="{Binding HistogramData}"
                         Width="256" Height="100"/>
</Window>
```

---

## 7. 성능 최적화 기법

### 7.1 대용량 이미지 처리

```csharp
public class VirtualizedImageRenderer
{
    // 1. 타일 기반 렌더링
    private const int TileSize = 256;
    private Dictionary<Point, BitmapSource> _tileCache = new();
    
    public void RenderVisibleTiles(Rect visibleRect)
    {
        // 현재 보이는 영역만 렌더링
        int startTileX = (int)(visibleRect.X / TileSize);
        int startTileY = (int)(visibleRect.Y / TileSize);
        int endTileX = (int)((visibleRect.Right) / TileSize) + 1;
        int endTileY = (int)((visibleRect.Bottom) / TileSize) + 1;
        
        for (int ty = startTileY; ty <= endTileY; ty++)
        {
            for (int tx = startTileX; tx <= endTileX; tx++)
            {
                RenderTile(tx, ty);
            }
        }
    }
    
    // 2. 비동기 렌더링
    public async Task<BitmapSource> RenderAsync(MyImage image)
    {
        return await Task.Run(() =>
        {
            // 백그라운드 스레드에서 렌더링
            return RenderImageInternal(image);
        });
    }
    
    // 3. 메모리 관리
    private void ManageCache()
    {
        // LRU (Least Recently Used) 캐시 관리
        if (_tileCache.Count > MaxCacheSize)
        {
            var oldest = _tileCache.OrderBy(kvp => kvp.Value.LastAccessTime)
                                  .First();
            _tileCache.Remove(oldest.Key);
        }
    }
}
```

### 7.2 쓰레드 안전성 보장

```csharp
public class ThreadSafeImageProcessor
{
    private readonly object _imageLock = new object();
    private MyImage _currentImage;
    
    public MyImage CurrentImage
    {
        get { lock (_imageLock) return _currentImage?.Clone(); }
        set { lock (_imageLock) _currentImage = value; }
    }
    
    public void ProcessImage(Action<MyImage> processAction)
    {
        Task.Run(() =>
        {
            MyImage workingCopy;
            lock (_imageLock)
            {
                workingCopy = _currentImage.Clone();
            }
            
            // 처리 실행
            processAction(workingCopy);
            
            // UI 스레드에서 결과 업데이트
            Application.Current.Dispatcher.Invoke(() =>
            {
                lock (_imageLock)
                {
                    _currentImage = workingCopy;
                }
                OnImageUpdated?.Invoke(this, EventArgs.Empty);
            });
        });
    }
}
```

---

## 8. 확장성 설계

### 8.1 플러그인 아키텍처

```csharp
public interface IImageFilter
{
    string Name { get; }
    string Category { get; }
    BitmapSource Icon { get; }
    
    // 필터 적용 메서드
    MyImage Apply(MyImage input, params object[] parameters);
    
    // UI 설정 컨트롤
    FrameworkElement GetSettingsControl();
}

public class FilterManager
{
    private List<IImageFilter> _filters = new();
    
    public void LoadPlugins(string pluginsPath)
    {
        foreach (var dll in Directory.GetFiles(pluginsPath, "*.dll"))
        {
            var assembly = Assembly.LoadFrom(dll);
            var filterTypes = assembly.GetTypes()
                .Where(t => typeof(IImageFilter).IsAssignableFrom(t) && !t.IsAbstract);
            
            foreach (var type in filterTypes)
            {
                var filter = Activator.CreateInstance(type) as IImageFilter;
                _filters.Add(filter);
            }
        }
    }
    
    public IEnumerable<IImageFilter> GetFiltersByCategory(string category)
    {
        return _filters.Where(f => f.Category == category);
    }
}
```

---

## 9. 디버깅과 로깅 시스템

```csharp
public class ImageProcessorLogger
{
    public enum LogLevel { Debug, Info, Warning, Error }
    
    public void Log(LogLevel level, string message, 
                   [CallerMemberName] string caller = "")
    {
        string logEntry = $"[{DateTime.Now:HH:mm:ss}] [{level}] {caller}: {message}";
        
        // 콘솔 출력
        Console.WriteLine(logEntry);
        
        // 파일 로그
        File.AppendAllText("image_processor.log", logEntry + Environment.NewLine);
        
        // UI 표시 (Info 이상)
        if (level >= LogLevel.Info)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                StatusBar.LogMessage = message;
            });
        }
    }
    
    // 성능 프로파일링
    public IDisposable MeasurePerformance(string operationName)
    {
        return new PerformanceMonitor(operationName, this);
    }
    
    private class PerformanceMonitor : IDisposable
    {
        private Stopwatch _stopwatch;
        private string _operationName;
        private ImageProcessorLogger _logger;
        
        public PerformanceMonitor(string operationName, ImageProcessorLogger logger)
        {
            _operationName = operationName;
            _logger = logger;
            _stopwatch = Stopwatch.StartNew();
        }
        
        public void Dispose()
        {
            _stopwatch.Stop();
            _logger.Log(LogLevel.Debug, 
                       $"{_operationName} took {_stopwatch.ElapsedMilliseconds}ms");
        }
    }
}
```

---

## 10. 테스트와 검증

### 10.1 단위 테스트 예제

```csharp
[TestClass]
public class ImageViewModelTests
{
    [TestMethod]
    public void TestZoomAroundCenter()
    {
        // 준비
        var viewModel = new ImageViewModel();
        viewModel.LoadTestImage(800, 600);
        
        // 실행
        Point center = new Point(400, 300);
        viewModel.Zoom(2.0, center); // 2배 확대
        
        // 검증
        Assert.AreEqual(2.0, viewModel.ZoomFactor);
        
        // 중심점이 유지되는지 확인
        Point imagePoint = viewModel.ConvertToImageCoordinates(center);
        Assert.AreEqual(400, imagePoint.X, 0.1);
        Assert.AreEqual(300, imagePoint.Y, 0.1);
    }
    
    [TestMethod]
    public void TestHistogramCalculation()
    {
        // 흰색 이미지 생성 (모든 픽셀 = 255)
        var whiteImage = CreateTestImage(100, 100, 255);
        
        // 히스토그램 계산
        var histogram = viewModel.BuildHistogram(whiteImage);
        
        // 검증: 255번 빈에만 10000픽셀이 있어야 함
        Assert.AreEqual(10000, histogram[255]);
        for (int i = 0; i < 255; i++)
        {
            Assert.AreEqual(0, histogram[i]);
        }
    }
}
```

---

## 정리: UI 프레임워크의 핵심 가치

| 구성 요소 | 기술적 구현 | 비즈니스 가치 |
|-----------|-------------|---------------|
| **파일 처리** | 엔진 계층 분리, 플러그인 아키텍처 | 확장성, 유지보수성 |
| **Zoom/Pan** | 아핀 변환, 행렬 연산 | 직관적 인터랙션, 사용성 |
| **히스토그램** | 실시간 계산, 통계 분석 | 데이터 기반 의사결정 지원 |
| **상태 관리** | 실시간 피드백, 컨텍스트 제공 | 작업 효율성 향상 |
| **성능 최적화** | 가상화, 캐싱, 비동기 처리 | 대용량 데이터 처리 가능 |

### 핵심 디자인 패턴:
1. **MVVM**: 관심사 분리, 테스트 용이성
2. **전략 패턴**: 알고리즘 교체 용이
3. **커맨드 패턴**: UI 액션 추상화
4. **옵저버 패턴**: 실시간 데이터 바인딩

이 UI 프레임워크는 단순한 뷰어를 넘어 **영상 처리 알고리즘 개발 플랫폼**으로서의 기반을 제공합니다. 모든 구성 요소는 독립적으로 교체·확장이 가능하며, 향후 추가될 고급 영상 처리 기능들을 효과적으로 지원할 수 있는 구조를 가지고 있습니다.