---
layout: post
title: AWS - S3 수명 주기 정책
date: 2025-07-18 18:20:23 +0900
category: AWS
---
# S3 수명 주기 정책(Lifecycle Policy)으로 자동 스토리지 이동하기

## 0) 한 장 요약

- **무엇**: 객체의 **나이/조건**에 따라 **스토리지 클래스를 자동 이전**(Transition)하거나 **삭제**(Expiration)하는 규칙.  
- **왜**: **비용 최적화 자동화** + 대규모 객체 집합의 **운영 간소화**.  
- **핵심 개념**: `Filter(Prefix/Tag)` + `Transitions` + `Expiration` + `Noncurrent*`(버전 관리) + `AbortIncompleteMultipartUpload`.

---

## 1) 동작 원리와 비용 직관 (초안 보강)

### 1.1 수명 주기 엔진의 대상과 타이밍
- **대상**: 버킷 내 **객체**(버전 관리 ON이면 **각 버전**).  
- **기준**: 객체 생성일(또는 버전 생성일)로부터의 **경과 일수**.  
- **적용 시점**: 하루 1회 이상 **비동기 평가** 후 배치적으로 실행(즉시가 아님).

### 1.2 비용 근사(이해용)
$$
\text{월 비용} \approx \sum_{c} (G_c \cdot p_c) + \sum_{t} \frac{R_t}{1000}\cdot k_t
$$
- \(G_c\): 클래스 \(c\)의 월 평균 GB, \(p_c\): GB·월 단가.  
- \(R_t\): 요청 수(Transition/Expiration 등 포함), \(k_t\): 1000건당 단가.  
- **전략**: \(G_{\text{Standard}}\)를 빠르게 \(G_{\text{IA/Glacier}}\)로 낮추되, **복원 트래픽/요청** 증가를 감안.

---

## 2) 지원 동작과 설계 체크리스트 (초안 확장)

| 동작 | 키 필드 | 체크 포인트 |
|---|---|---|
| **스토리지 이전** | `Transitions` | 클래스 간 순서 지켜야 함(예: Standard → IA → Glacier) |
| **객체 만료(삭제)** | `Expiration` | 복구 불가. 접두사/태그 필터 정확히 지정 |
| **비최신 버전 이전/만료** | `NoncurrentVersionTransitions/Expiration` | 버전 관리 ON일 때만. “현행 버전” 보호·비최신 정리 |
| **미완료 멀티파트 정리** | `AbortIncompleteMultipartUpload` | 방치된 파편 비용 방지 |

> **Intelligent-Tiering**와 병행 시, 불필요한 Transitions는 최소화(중복 비용 회피).

---

## 3) 콘솔 설정(요약) → CLI/IaC로 재현

### 3.1 콘솔
- 버킷 → **관리(Management)** → **수명 주기 규칙 만들기**
- 규칙 이름/범위(전체 or Prefix or 태그) → 전환/만료/비최신/Abort 구성 → 저장

### 3.2 CLI: 정책 적용
```bash
# lifecycle.json 파일을 준비한 뒤 적용
aws s3api put-bucket-lifecycle-configuration \
  --bucket my-bucket \
  --lifecycle-configuration file://lifecycle.json

# 확인
aws s3api get-bucket-lifecycle-configuration --bucket my-bucket
```

### 3.3 CloudFormation 스니펫
```yaml
Resources:
  LcBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: my-lc-bucket
      LifecycleConfiguration:
        Rules:
          - Id: ArchiveOldLogs
            Status: Enabled
            Prefix: logs/
            Transitions:
              - TransitionInDays: 30
                StorageClass: STANDARD_IA
              - TransitionInDays: 90
                StorageClass: GLACIER
            ExpirationInDays: 365
```

### 3.4 Terraform 스니펫
```hcl
resource "aws_s3_bucket" "b" {
  bucket = "my-lc-bucket"
}

resource "aws_s3_bucket_lifecycle_configuration" "lc" {
  bucket = aws_s3_bucket.b.id
  rule {
    id     = "ArchiveOldLogs"
    status = "Enabled"
    filter { prefix = "logs/" }

    transition {
      days          = 30
      storage_class = "STANDARD_IA"
    }
    transition {
      days          = 90
      storage_class = "GLACIER"
    }
    expiration {
      days = 365
    }
  }
}
```

---

## 4) 기본 예시 정책 (초안 강화)

### 4.1 단일 접두사 아카이브 + 삭제
```json
{
  "Rules": [
    {
      "ID": "ArchiveOldLogs",
      "Filter": { "Prefix": "logs/" },
      "Status": "Enabled",
      "Transitions": [
        { "Days": 30, "StorageClass": "STANDARD_IA" },
        { "Days": 90, "StorageClass": "GLACIER" }
      ],
      "Expiration": { "Days": 365 }
    }
  ]
}
```

### 4.2 태그 기반(환경 구분) + Abort
```json
{
  "Rules": [
    {
      "ID": "ArchiveProd",
      "Filter": { "And": { "Tags": [ { "Key": "Env", "Value": "prod" } ] } },
      "Status": "Enabled",
      "Transitions": [
        { "Days": 60, "StorageClass": "STANDARD_IA" },
        { "Days": 120, "StorageClass": "GLACIER" }
      ],
      "AbortIncompleteMultipartUpload": { "DaysAfterInitiation": 7 }
    }
  ]
}
```

### 4.3 버전 관리 활성화: 비최신 버전 제어
```json
{
  "Rules": [
    {
      "ID": "NoncurrentControl",
      "Status": "Enabled",
      "Filter": { "Prefix": "" },
      "NoncurrentVersionTransitions": [
        { "NoncurrentDays": 30, "StorageClass": "GLACIER" }
      ],
      "NoncurrentVersionExpiration": { "NoncurrentDays": 180 }
    }
  ]
}
```

---

## 5) 실습 시나리오 (E2E)

### 5.1 로그 저장소(초안 예시 확장)
- `logs/` 접두사: 30일 → IA, 90일 → Glacier, 365일 삭제.

```bash
# 구조 예시
aws s3 cp access_2025_01.log s3://my-logs-bucket/logs/
aws s3 cp access_2025_02.log s3://my-logs-bucket/logs/
```

**정책 적용 후 기대 상태(예시)**

| 날짜 | 상태 |
|---|---|
| 2025-01-01 업로드 | Standard |
| 2025-01-31 | Standard-IA 전환 |
| 2025-04-01 | Glacier 전환 |
| 2026-01-01 | 만료(삭제) |

### 5.2 배포 산출물: 최신만 핫, 비최신 즉시 아카이브
```json
{
  "Rules": [
    {
      "ID": "Artifacts-Noncurrent-Glacier",
      "Status": "Enabled",
      "Filter": { "Prefix": "artifacts/" },
      "NoncurrentVersionTransitions": [
        { "NoncurrentDays": 1, "StorageClass": "GLACIER" }
      ],
      "NoncurrentVersionExpiration": { "NoncurrentDays": 90 }
    }
  ]
}
```

### 5.3 혼합 전략: Intelligent-Tiering + 만료
- **패턴 예측 어려움** → 업로드는 `INTELLIGENT_TIERING`  
- 그러나 **1년 이후 삭제**는 Lifecycle로 강제

```json
{
  "Rules": [
    {
      "ID": "IT-then-Expire",
      "Status": "Enabled",
      "Filter": { "Prefix": "media/" },
      "Expiration": { "Days": 365 }
    }
  ]
}
```

> IT는 자동 계층 이동이지만, **삭제 시점은 정책으로 명시**.

---

## 6) boto3/SDK 자동화 스니펫

### 6.1 정책 생성/적용
```python
import json, boto3

s3 = boto3.client("s3")
bucket = "my-bucket"

policy = {
  "Rules": [{
    "ID": "ArchiveOldLogs",
    "Filter": {"Prefix": "logs/"},
    "Status": "Enabled",
    "Transitions": [
      {"Days": 30, "StorageClass": "STANDARD_IA"},
      {"Days": 90, "StorageClass": "GLACIER"}
    ],
    "Expiration": {"Days": 365}
  }]
}

s3.put_bucket_lifecycle_configuration(
    Bucket=bucket,
    LifecycleConfiguration=policy
)

resp = s3.get_bucket_lifecycle_configuration(Bucket=bucket)
print(json.dumps(resp, indent=2, default=str))
```

### 6.2 접두사/태그 자동 분류(간단 예)
```python
def classify_key(key: str):
    if key.startswith("logs/"):
        return "logs"
    if key.endswith(".mov"):
        return "media"
    return "general"
```

---

## 7) 상호작용: 버전 관리 / 복제 / KMS / Object Lock

### 7.1 버전 관리(Versioning)
- `NoncurrentVersion*` 필드로 **비최신 버전만** 별도 제어.
- **주의**: 삭제 마커가 있어도 과거 버전은 남아 있을 수 있음 → **NoncurrentExpiration**으로 정리.

### 7.2 복제(Replication)
- 원본에서 전환/만료가 **복제 후 대상에도 적용**되려면 대상 버킷에도 **동일 또는 적합한 정책** 필요.
- 삭제 마커 복제 여부(`DeleteMarkerReplication`)와 **KMS 암호화 키 권한** 주의.

### 7.3 KMS 암호화(SSE-KMS)
- Glacier/IA 전환 시에도 **KMS 권한**이 필요할 수 있음(특히 복제/다계정 환경).
- 잘못된 키 정책은 전환 실패 원인.

### 7.4 Object Lock(불변성)
- **Retention/Legal Hold** 기간 중에는 수명 주기 만료/삭제가 지연될 수 있음.  
- 규정 준수(Compliance) 모드 객체는 **만료 불가**(기간 종료 후에야 가능).

---

## 8) 검증/모니터링

### 8.1 즉시 확인 포인트
```bash
# 정책 조회
aws s3api get-bucket-lifecycle-configuration --bucket my-bucket

# 객체 스토리지 클래스 확인
aws s3api head-object --bucket my-bucket --key logs/access_2025_01.log \
  --query '[StorageClass, LastModified]'
```

### 8.2 S3 Storage Lens / Inventory
- **Storage Lens**: 객체 수/비최신 비율/Transition 적용률 확인.  
- **S3 Inventory**: 매일 **버전/클래스** 스냅샷 → Athena로 분석.

### 8.3 CloudTrail / EventBridge (감시)
- **PutBucketLifecycleConfiguration** 이벤트 알림 → **변경 감지**.

---

## 9) 트러블슈팅 표

| 증상 | 원인 | 해결 |
|---|---|---|
| 전환/삭제가 즉시 안 됨 | 평가 주기 지연(비동기) | 하루~수일 관찰, 정책/필터 재확인 |
| 일부 객체만 남음 | 필터(Prefix/Tag) 불일치 | Filter 수정, Inventory로 범위 점검 |
| 전환 실패 | KMS 권한/정책 문제 | CMK 정책/Grant 점검, 역할에 Decrypt/Encrypt |
| 삭제 안 됨 | Object Lock 보존/Legal Hold | 기간 만료 또는 해제 후 만료 가능 |
| 복제 대상에서 정책 미적용 | 대상 버킷에 Lifecycle 없음 | 대상에도 동등 정책 구성 |
| IA→Glacier 순서 오류 | 전환 순서 위배 | Standard→IA→Glacier 순으로 정의 |

---

## 10) 비용·성능 팁

- **작은 객체 대량**: Transition/IT 모니터링/Select 비용이 상대적으로 비싸질 수 있음 → **임계 크기** 기준 분리.  
- **리스트 비용**: 접두사 파티션(연/월/일/해시)으로 **LIST 범위 축소**.  
- **복원 러시 방지**: Glacier 복원은 **등급/배치 스케줄링**으로 청구 피크 완화.

---

## 11) 확장 레시피(샘플 모음)

### 11.1 접두사별 상이한 정책(Logs/Media/Docs)
```json
{
  "Rules": [
    { "ID": "Logs-Deep", "Status": "Enabled", "Filter": { "Prefix": "logs/" },
      "Transitions": [
        { "Days": 30, "StorageClass": "STANDARD_IA" },
        { "Days": 90, "StorageClass": "GLACIER" }
      ],
      "Expiration": { "Days": 730 }
    },
    { "ID": "Media-IT-Expire", "Status": "Enabled", "Filter": { "Prefix": "media/" },
      "Expiration": { "Days": 365 }
    },
    { "ID": "Docs-Noncurrent", "Status": "Enabled", "Filter": { "Prefix": "docs/" },
      "NoncurrentVersionTransitions": [
        { "NoncurrentDays": 30, "StorageClass": "GLACIER" }
      ],
      "NoncurrentVersionExpiration": { "NoncurrentDays": 365 }
    }
  ]
}
```

### 11.2 테스트/스테이징 자동 청소(태그 기반)
```json
{
  "Rules": [
    {
      "ID": "AutoClean-Staging",
      "Status": "Enabled",
      "Filter": { "And": { "Tags": [ { "Key": "Env", "Value": "staging" } ] } },
      "Expiration": { "Days": 14 },
      "AbortIncompleteMultipartUpload": { "DaysAfterInitiation": 3 }
    }
  ]
}
```

---

## 12) 치트시트

```bash
# 적용
aws s3api put-bucket-lifecycle-configuration \
  --bucket <bucket> \
  --lifecycle-configuration file://lifecycle.json

# 조회/삭제
aws s3api get-bucket-lifecycle-configuration --bucket <bucket>
aws s3api delete-bucket-lifecycle --bucket <bucket>

# 객체 클래스/메타 확인
aws s3api head-object --bucket <bucket> --key <key> \
  --query '{StorageClass:StorageClass,LastModified:LastModified,ETag:ETag}'

# 인벤토리 설정(별도 JSON)
aws s3api put-bucket-inventory-configuration \
  --bucket <bucket> --id daily-all \
  --inventory-configuration file://inventory.json
```

---

## 13) 마무리 요약(초안 정리 + 보강)

| 포인트 | 핵심 |
|---|---|
| 설계 최소 단위 | Prefix/Tag로 **정밀 타겟팅** |
| 버전 관리 | **Noncurrent** 규칙으로 과거 버전 정리 |
| IT 병행 | **자동 계층화 + 명시적 만료** 조합 |
| 보안 상호작용 | **Object Lock/KMS/Replication**과 충돌 시 우선순위 고려 |
| 검증/감시 | **Storage Lens/Inventory/CloudTrail**로 효과/변경 추적 |
| 비용 효과 | Standard 체류 기간 축소 + Glacier/IA 적시 전환 |

---

이로써 **Lifecycle의 개념 → 콘솔/CLI/IaC/boto3 실습 → 버전/잠금/복제/KMS 상호작용 → 검증/모니터링 → 트러블슈팅 → 비용·운영 팁**을 모두 담아,  
당신의 초안을 **운영에 바로 적용 가능한 형태**로 확장했다. 필요 시 실제 버킷 구조/태그 체계에 맞게 **Prefix/Tag 규칙**만 바꿔 곧바로 배포하면 된다.