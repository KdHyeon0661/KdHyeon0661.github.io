---
layout: post
title: 영상처리 - 영상 날카롭게 만들기
date: 2025-09-23 18:25:23 +0900
category: 영상처리
---
# 영상 날카롭게 만들기 (Sharpening)

## 1) 개념 정리

### 1.1 언샤프 마스크(USM, Unsharp Mask)
원본 \(I\)에서 **블러된 영상** \(B = G_\sigma * I\) 를 빼서 **고주파(세부)** 성분을 추출하고, 원본에 다시 더합니다.

\[
\begin{aligned}
M &= I - B \quad \text{(마스크 = 고주파)}\\
I' &= I + k \cdot M = I + k\,(I - B)
\end{aligned}
\]

- \(k\) (amount, 샤프닝 강도), \(\sigma\) (가우시안 표준편차, 반경)  
- **Threshold** \(T\): \(|M|<T\) 인 약한 차이는 무시하여 **노이즈 증폭 방지**  
- **Luma-only** 모드: **휘도**에서만 샤프닝 후 **RGB에 동일한 델타**를 더해 **색조 보존**

### 1.2 라플라시안(Laplacian) 샤프닝
라플라시안은 2차 미분(에지 강조) 연산자입니다.  
대표 커널:
\[
\begin{aligned}
\text{4방향:}\;&
\begin{bmatrix}
0 & -1 & 0\\
-1 & 4 & -1\\
0 & -1 & 0
\end{bmatrix}
\quad
\text{8방향:}\;
\begin{bmatrix}
-1 & -1 & -1\\
-1 & 8 & -1\\
-1 & -1 & -1
\end{bmatrix}
\end{aligned}
\]
샤프닝은 보통
\[
I' = I - \alpha \,\nabla^2 I
\]
형태로 구현합니다. (\(\alpha>0\), 커널 부호에 맞춰 “빼기”로 날카롭게)

### 1.3 하이부스트(High-Boost) 필터
언샤프의 일반화:
\[
I' = A\cdot I - (A-1)\cdot B
= I + (A-1)\,(I-B)
\]
- \(A\ge 1\). \(A=1\)이면 원본, \(A>1\)이면 세부 강화.  
- 사실상 **USM**에서 \(k = A-1\).

---

## 2) 코어 구현

아래 헤더 하나로 **USM / 라플라시안 / 하이부스트**를 제공합니다.  
(8.2장의 `Smoothing.h`에 있는 `GaussianFilter_BGRA32()`를 사용합니다.)

```cpp
// Sharpen.h
#pragma once
#include <cstdint>
#include <vector>
#include <cmath>
#include <algorithm>
#include "IppDib.h"
#include "SpatialFilter.h"  // Convolve2D_BGRA32()
#include "Smoothing.h"      // GaussianFilter_BGRA32()

inline uint8_t clamp_u8_int(int v){ return (uint8_t)std::min(255, std::max(0, v)); }
inline int clamp255(int v){ return v<0?0:(v>255?255:v); }
inline int luma_from_rgb(int R,int G,int B){
    // ITU-R BT.601 근사
    return clamp255((int)std::lround(0.299*R + 0.587*G + 0.114*B));
}

// --------------------- 2.1 언샤프 마스크 ---------------------
// sigma: 가우시안 표준편차, ksize: 홀수, amount: k, thresh: 0..255, lumaOnly: true면 luma에서만
inline void UnsharpMask_BGRA32(const IppDib& src, IppDib& dst,
                               float sigma, int ksize, float amount,
                               int thresh /*0..255*/, bool lumaOnly)
{
    if (!src || sigma<=0.f || amount==0.f) { dst = src; return; }
    if (ksize<3) ksize=3; if ((ksize&1)==0) ++ksize;

    // 1) 가우시안 블러
    IppDib blur; GaussianFilter_BGRA32(src, blur, sigma, ksize);

    dst.create(src.width(), src.height(), 32);

    for (int y=0; y<src.height(); ++y) {
        const uint8_t* srow = (const uint8_t*)src.bits()  + (size_t)y*src.stride();
        const uint8_t* brow = (const uint8_t*)blur.bits() + (size_t)y*blur.stride();
        uint8_t*       drow = (uint8_t*)dst.bits()        + (size_t)y*dst.stride();
        for (int x=0; x<src.width(); ++x) {
            const uint8_t* ps = &srow[x*4];
            const uint8_t* pb = &brow[x*4];
            int B=ps[0], G=ps[1], R=ps[2], A=ps[3];
            if (lumaOnly) {
                int Ys = luma_from_rgb(R,G,B);
                int Yb = luma_from_rgb(pb[2], pb[1], pb[0]); // blur의 R,G,B
                int d  = Ys - Yb; // 마스크
                if (std::abs(d) < thresh) d=0;
                int delta = (int)std::lround(amount * d);
                int Rn = clamp255(R + delta);
                int Gn = clamp255(G + delta);
                int Bn = clamp255(B + delta);
                drow[x*4+0]=Bn; drow[x*4+1]=Gn; drow[x*4+2]=Rn; drow[x*4+3]=A;
            } else {
                // RGB 채널별 (threshold는 휘도 기반으로 게이트)
                int Ys = luma_from_rgb(R,G,B);
                int Yb = luma_from_rgb(pb[2], pb[1], pb[0]);
                int gate = (std::abs(Ys - Yb) >= thresh) ? 1 : 0;

                int dB = B - pb[0];
                int dG = G - pb[1];
                int dR = R - pb[2];
                int Rn = clamp255(R + (int)std::lround(amount * dR * gate));
                int Gn = clamp255(G + (int)std::lround(amount * dG * gate));
                int Bn = clamp255(B + (int)std::lround(amount * dB * gate));
                drow[x*4+0]=Bn; drow[x*4+1]=Gn; drow[x*4+2]=Rn; drow[x*4+3]=A;
            }
        }
    }
}

// --------------------- 2.2 라플라시안 샤프닝 ---------------------
// alpha: 라플라시안 스케일, use8: 8방향(중심 8) 사용, lumaOnly: true면 라플라시안의 '휘도'만 덧셈
inline void LaplacianSharpen_BGRA32(const IppDib& src, IppDib& dst,
                                    float alpha, bool use8, bool lumaOnly)
{
    if (!src || alpha==0.f) { dst=src; return; }

    // 1) 라플라시안 컨볼루션
    std::vector<float> k(9);
    if (use8) {
        // [-1 -1 -1; -1 8 -1; -1 -1 -1]
        float K[9] = {-1,-1,-1, -1,8,-1, -1,-1,-1};
        k.assign(K, K+9);
    } else {
        // [0 -1 0; -1 4 -1; 0 -1 0]
        float K[9] = {0,-1,0, -1,4,-1, 0,-1,0};
        k.assign(K, K+9);
    }
    IppDib lap; Convolve2D_BGRA32(src, lap, k, 3, 3, /*normalize=*/false);

    dst.create(src.width(), src.height(), 32);

    for (int y=0; y<src.height(); ++y) {
        const uint8_t* srow = (const uint8_t*)src.bits() + (size_t)y*src.stride();
        const uint8_t* lrow = (const uint8_t*)lap.bits() + (size_t)y*lap.stride();
        uint8_t*       drow = (uint8_t*)dst.bits()       + (size_t)y*dst.stride();
        for (int x=0; x<src.width(); ++x) {
            const uint8_t* ps = &srow[x*4];
            const uint8_t* pl = &lrow[x*4];
            int B=ps[0], G=ps[1], R=ps[2], A=ps[3];

            if (lumaOnly) {
                // 라플라시안의 '휘도' 성분만 delta로 사용 (선형성에 의해 Lap(Y)=0.299*Lap(R)+...)
                int Ly = luma_from_rgb(pl[2], pl[1], pl[0]);
                int delta = (int)std::lround(-alpha * Ly);
                int Rn = clamp255(R + delta);
                int Gn = clamp255(G + delta);
                int Bn = clamp255(B + delta);
                drow[x*4+0]=Bn; drow[x*4+1]=Gn; drow[x*4+2]=Rn; drow[x*4+3]=A;
            } else {
                int Rn = clamp255(R + (int)std::lround(-alpha * (int)pl[2]));
                int Gn = clamp255(G + (int)std::lround(-alpha * (int)pl[1]));
                int Bn = clamp255(B + (int)std::lround(-alpha * (int)pl[0]));
                drow[x*4+0]=Bn; drow[x*4+1]=Gn; drow[x*4+2]=Rn; drow[x*4+3]=A;
            }
        }
    }
}

// --------------------- 2.3 하이부스트 ---------------------
// A>=1, A=1이면 원본. Unsharp의 amount=k=A-1 로 구현. threshold/lumaOnly 동일.
inline void HighBoost_BGRA32(const IppDib& src, IppDib& dst,
                             float A, float sigma, int ksize,
                             int thresh, bool lumaOnly)
{
    if (A<=1.f) { dst=src; return; }
    float amount = (A - 1.f);
    UnsharpMask_BGRA32(src, dst, sigma, ksize, amount, thresh, lumaOnly);
}
```

---

## 3) “샤프닝” 대화 상자(USM/Laplacian/High-Boost)

하나의 대화 상자에서 **세 가지 모드**를 라디오로 선택하게 구성합니다.  
- **Unsharp**: `sigma`, `ksize(자동)`, `amount(k)`, `threshold`, `Luma only`  
- **Laplacian**: `alpha`, `4/8-방향`, `Luma only`  
- **High-Boost**: `A`, `sigma`, `ksize(자동)`, `threshold`, `Luma only`

### 3.1 리소스 정의

```cpp
// resource.h (추가)
#define IDD_SHARPEN_DIALOG          700

// 모드
#define IDC_RAD_UNSHARP             1701
#define IDC_RAD_LAPLACE             1702
#define IDC_RAD_HIGHBOOST           1703

// 공통
#define IDC_CHK_LUMAONLY            1710

// Unsharp
#define IDC_EDIT_USM_SIGMA          1721
#define IDC_EDIT_USM_KSIZE          1722
#define IDC_CHK_USM_AUTOK           1723
#define IDC_EDIT_USM_AMOUNT         1724
#define IDC_EDIT_USM_THRESH         1725

// Laplacian
#define IDC_EDIT_LAP_ALPHA          1731
#define IDC_RAD_LAP_4               1732
#define IDC_RAD_LAP_8               1733

// High-Boost
#define IDC_EDIT_HB_A               1741
#define IDC_EDIT_HB_SIGMA           1742
#define IDC_EDIT_HB_KSIZE           1743
#define IDC_CHK_HB_AUTOK            1744
#define IDC_EDIT_HB_THRESH          1745

// 메뉴
#define ID_IMAGE_SHARPEN_DIALOG     52010
```

```rc
// ImageTool.rc (추가)
IDD_SHARPEN_DIALOG DIALOGEX 0,0, 320, 230
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Sharpen"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Mode", -1, 10, 8, 100, 54
    AUTORADIOBUTTON "Unsharp",   IDC_RAD_UNSHARP, 16, 22, 70, 10, WS_TABSTOP
    AUTORADIOBUTTON "Laplacian", IDC_RAD_LAPLACE, 16, 36, 70, 10
    AUTORADIOBUTTON "High-Boost",IDC_RAD_HIGHBOOST,16,50, 70, 10

    AUTOCHECKBOX "Luma only", IDC_CHK_LUMAONLY, 120, 20, 70, 10

    GROUPBOX "Unsharp", -1, 10, 66, 300, 58
    LTEXT "σ:", -1, 18, 80, 10, 10
    EDITTEXT IDC_EDIT_USM_SIGMA, 30, 78, 36, 14, ES_AUTOHSCROLL
    LTEXT "ksize:", -1, 72, 80, 24, 10
    EDITTEXT IDC_EDIT_USM_KSIZE, 100, 78, 24, 14, ES_NUMBER
    AUTOCHECKBOX "Auto (≈2*ceil(3σ)+1)", IDC_CHK_USM_AUTOK, 130, 80, 160, 12
    LTEXT "amount:", -1, 18, 98, 32, 10
    EDITTEXT IDC_EDIT_USM_AMOUNT, 54, 96, 36, 14, ES_AUTOHSCROLL
    LTEXT "thresh:", -1, 98, 98, 30, 10
    EDITTEXT IDC_EDIT_USM_THRESH, 130, 96, 24, 14, ES_NUMBER

    GROUPBOX "Laplacian", -1, 10, 128, 300, 38
    LTEXT "alpha:", -1, 18, 142, 30, 10
    EDITTEXT IDC_EDIT_LAP_ALPHA, 50, 140, 36, 14, ES_AUTOHSCROLL
    AUTORADIOBUTTON "4-neigh", IDC_RAD_LAP_4, 100, 140, 56, 10
    AUTORADIOBUTTON "8-neigh", IDC_RAD_LAP_8, 160, 140, 56, 10

    GROUPBOX "High-Boost", -1, 10, 168, 300, 38
    LTEXT "A:", -1, 18, 182, 14, 10
    EDITTEXT IDC_EDIT_HB_A, 34, 180, 36, 14, ES_AUTOHSCROLL
    LTEXT "σ:", -1, 80, 182, 10, 10
    EDITTEXT IDC_EDIT_HB_SIGMA, 94, 180, 34, 14, ES_AUTOHSCROLL
    LTEXT "ksize:", -1, 136, 182, 28, 10
    EDITTEXT IDC_EDIT_HB_KSIZE, 166, 180, 24, 14, ES_NUMBER
    AUTOCHECKBOX "Auto k", IDC_CHK_HB_AUTOK, 196, 182, 50, 12
    LTEXT "thresh:", -1, 250, 182, 30, 10
    EDITTEXT IDC_EDIT_HB_THRESH, 282, 180, 20, 14, ES_NUMBER

    DEFPUSHBUTTON "OK", IDOK,  204, 210, 48, 14
    PUSHBUTTON    "Cancel", IDCANCEL, 258, 210, 48, 14
END

// 메뉴 (일부)
POPUP "&Image"
BEGIN
    POPUP "Sharpen"
    BEGIN
        MENUITEM "Sharpen...\tCtrl+H", ID_IMAGE_SHARPEN_DIALOG
    END
END

IDR_ACCEL ACCELERATORS
BEGIN
    "H", ID_IMAGE_SHARPEN_DIALOG, VIRTKEY, CONTROL
END
```

### 3.2 대화 상자 로직

```cpp
// SharpenDlg.h
#pragma once
#include <windows.h>
#include <string>
#include <cmath>
#include "resource.h"
#include "Sharpen.h"

class SharpenDlg {
public:
    SharpenDlg(HWND owner, IppDib& dib) : owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    // 읽기 도우미
    float  ReadFloat(HWND h, int id, float def) const;
    int    ReadInt(HWND h, int id, int def) const;
    int    AutoK(float sigma) const { int r=(int)std::ceil(3.f*sigma); int k=2*r+1; return k<3?3:k; }
    bool   IsChecked(HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }

private:
    HWND    owner_ = nullptr;
    IppDib& dib_;
};
```

```cpp
// SharpenDlg.cpp
#include "SharpenDlg.h"

INT_PTR SharpenDlg::DoModal() {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_SHARPEN_DIALOG),
                           owner_, DlgProc, (LPARAM)this);
}

INT_PTR CALLBACK SharpenDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m==WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self = (SharpenDlg*)l; return self->OnInit(h);
    }
    auto* self = (SharpenDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;

    switch (m) {
    case WM_COMMAND: return self->OnCommand(h, w, l);
    default: return FALSE;
    }
}

INT_PTR SharpenDlg::OnInit(HWND h) {
    // 기본값
    CheckRadioButton(h, IDC_RAD_UNSHARP, IDC_RAD_HIGHBOOST, IDC_RAD_UNSHARP);
    CheckDlgButton(h, IDC_CHK_LUMAONLY, BST_CHECKED);

    SetDlgItemTextW(h, IDC_EDIT_USM_SIGMA,  L"1.0");
    SetDlgItemTextW(h, IDC_EDIT_USM_KSIZE,  L"5");
    SetDlgItemTextW(h, IDC_EDIT_USM_AMOUNT, L"1.0");
    SetDlgItemTextW(h, IDC_EDIT_USM_THRESH, L"0");
    CheckDlgButton(h, IDC_CHK_USM_AUTOK, BST_CHECKED);

    SetDlgItemTextW(h, IDC_EDIT_LAP_ALPHA,  L"0.2");
    CheckRadioButton(h, IDC_RAD_LAP_4, IDC_RAD_LAP_8, IDC_RAD_LAP_8);

    SetDlgItemTextW(h, IDC_EDIT_HB_A,      L"1.5");
    SetDlgItemTextW(h, IDC_EDIT_HB_SIGMA,  L"1.0");
    SetDlgItemTextW(h, IDC_EDIT_HB_KSIZE,  L"5");
    SetDlgItemTextW(h, IDC_EDIT_HB_THRESH, L"0");
    CheckDlgButton(h, IDC_CHK_HB_AUTOK, BST_CHECKED);
    return TRUE;
}

float SharpenDlg::ReadFloat(HWND h, int id, float def) const {
    wchar_t buf[64]; GetDlgItemTextW(h, id, buf, 64);
    wchar_t* end=nullptr; double v = wcstod(buf, &end);
    if (end==buf) return def; return (float)v;
}
int SharpenDlg::ReadInt(HWND h, int id, int def) const {
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE);
    if (!ok) return def; return v;
}

INT_PTR SharpenDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)) {
    case IDOK: {
        bool lumaOnly = IsChecked(h, IDC_CHK_LUMAONLY);

        if (IsDlgButtonChecked(h, IDC_RAD_UNSHARP)==BST_CHECKED) {
            float sigma = ReadFloat(h, IDC_EDIT_USM_SIGMA, 1.f);
            int   ksize = IsChecked(h, IDC_CHK_USM_AUTOK)? AutoK(sigma) : ReadInt(h, IDC_EDIT_USM_KSIZE, 5);
            if ((ksize&1)==0) ++ksize; if (ksize<3) ksize=3;
            float amount = ReadFloat(h, IDC_EDIT_USM_AMOUNT, 1.f);
            int   thresh = ReadInt(h,   IDC_EDIT_USM_THRESH, 0);
            IppDib out; UnsharpMask_BGRA32(dib_, out, sigma, ksize, amount, thresh, lumaOnly);
            dib_ = out; EndDialog(h, IDOK); return TRUE;
        }
        if (IsDlgButtonChecked(h, IDC_RAD_LAPLACE)==BST_CHECKED) {
            float alpha = ReadFloat(h, IDC_EDIT_LAP_ALPHA, 0.2f);
            bool use8   = (IsDlgButtonChecked(h, IDC_RAD_LAP_8)==BST_CHECKED);
            IppDib out; LaplacianSharpen_BGRA32(dib_, out, alpha, use8, lumaOnly);
            dib_ = out; EndDialog(h, IDOK); return TRUE;
        }
        if (IsDlgButtonChecked(h, IDC_RAD_HIGHBOOST)==BST_CHECKED) {
            float A     = ReadFloat(h, IDC_EDIT_HB_A, 1.5f);
            float sigma = ReadFloat(h, IDC_EDIT_HB_SIGMA, 1.f);
            int   ksize = IsChecked(h, IDC_CHK_HB_AUTOK)? AutoK(sigma) : ReadInt(h, IDC_EDIT_HB_KSIZE, 5);
            if ((ksize&1)==0) ++ksize; if (ksize<3) ksize=3;
            int   thresh= ReadInt(h, IDC_EDIT_HB_THRESH, 0);
            IppDib out; HighBoost_BGRA32(dib_, out, A, sigma, ksize, thresh, lumaOnly);
            dib_ = out; EndDialog(h, IDOK); return TRUE;
        }
        return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL);
        return TRUE;
    }
    return FALSE;
}
```

---

## 4) 메뉴/이벤트 연결

```cpp
// main_multiwin.cpp (발췌)
#include "SharpenDlg.h"

// ...
case ID_IMAGE_SHARPEN_DIALOG:
    if (st && st->dib) {
        SharpenDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK) {
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st);
            UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 5) 파라미터 가이드 & 주의점

### 5.1 권장 범위(경험치)
- **USM**
  - \(\sigma\): 0.6 ~ 2.0 (작을수록 **미세 텍스처**, 클수록 **큰 윤곽** 강화)  
  - `amount k`: 0.3 ~ 1.5 (너무 크면 **헤일로** 발생)  
  - `thresh`: 0 ~ 10 (잡음 많은 사진은 4~8 권장)  
  - **Luma only**: **On** 권장(색번짐 최소화)

- **Laplacian**
  - `alpha`: 0.05 ~ 0.4 (8-neigh가 다소 강함 → 값 낮춤)  
  - 4-neigh: 링잉 덜함, 8-neigh: 강한 에지

- **High-Boost**
  - `A`: 1.2 ~ 2.0 (실질적 강화량은 `A-1`)  
  - `sigma/ksize`: USM과 동일. **큰 A**일수록 더 큰 `thresh` 권장

### 5.2 아티팩트/안정성
- **헤일로(halo)**: 경계 주변 밝은 띠 → amount/alpha를 줄이거나 σ ↑  
- **노이즈 증폭**: `threshold` 도입/상향, Luma-only 사용  
- **색조 변화**: RGB 채널별 샤프닝은 색 변화 가능 → **Luma-only** 권장  
- **경계 처리**: 8.1에서 구현한 **클램프(Replicate)** 사용. 필요시 Reflect 옵션화 가능

---

## 6) 실전 예제 시나리오

### 예제 1) 풍경 사진(미세 디테일) 샤프닝
- **상황**: 산 능선, 나뭇잎 텍스처가 뭉친 24MP JPEG.  
- **동작**: `Sharpen… → Unsharp`, Luma only On, σ=0.8, amount=0.8, thresh=3.  
- **결과**: 잎사귀 디테일 회복, 하늘의 노이즈는 threshold로 억제. 헤일로 미미.

### 예제 2) 인물 사진(얼굴 피부) 과샤프 방지
- **상황**: 실내 인물, ISO 노이즈 존재.  
- **동작**: USM: σ=1.2, amount=0.5, thresh=6, Luma only On.  
- **결과**: 눈썹/머리카락은 또렷, 피부 포어(모공) 증폭 최소화.

### 예제 3) 스캔 문서(텍스트) 또렷하게
- **상황**: 저해상도 스캔, 글자선이 흐림.  
- **동작**: Laplacian: alpha=0.25, 4-neigh, Luma only On.  
- **결과**: 글자 획 대비 증가, 링잉 적음. 필요시 alpha 0.3까지.

### 예제 4) 하이부스트로 로우패스 보정
- **상황**: 광학 저역통과(AA) 센서 이미지로 전체가 소프트.  
- **동작**: High-Boost: A=1.6 (amount 0.6), σ=1.5, Auto k, thresh=2, Luma only On.  
- **결과**: 전체 선명감 일괄 향상, 헤일로 제어 용이.

---

## 7) 추가 팁(확장)

- **USM 톤클리핑 완화**: 덧셈 전/후에 `soft-clip`(S-curve)로 하이라이트/딥섀도우 보호  
- **방향성 샤프닝**: 수평/수직 라플라시안 또는 LoG(가우시안-라플라시안)  
- **에지 마스크 결합**: Canny/DoG로 **에지 영역만** 샤프닝하여 링잉 최소화  
- **프리뷰**: 슬라이더 적용 즉시 프리뷰(원본 백업 + 디바운스)  
- **Undo/Redo**: 커맨드 스택에 결과 DIB를 push하여 Ctrl+Z 지원

---

## 8) 요약

- **USM**: \(I' = I + k(I-G_\sigma*I)\) — `sigma/amount/threshold`로 미세 제어, **Luma-only** 권장  
- **Laplacian**: \(I' = I - \alpha \nabla^2 I\) — 단순/빠르며 문서/선 구조에 유리  
- **High-Boost**: \(I' = A I - (A-1)B\) — USM 일반화, 전체 선명감 향상  
- UI 대화 상자/메뉴를 통해 세 방식 모두를 한 화면에서 조절 가능
