---
layout: post
title: 소켓프로그래밍 - IPv6와 듀얼스택
date: 2025-09-25 21:25:23 +0900
category: 소켓프로그래밍
---
## 17. IPv6와 듀얼스택

> 목표: **IPv6 기본기**(링크-로컬/스코프 ID, 듀얼스택, IPv4-mapped, `AI_V4MAPPED`)를 정확히 짚고,
> **방화벽/보안 그룹**에서 IPv6 규칙이 왜 별도인지, 어떤 ICMPv6를 꼭 열어야 하는지 이해한다.
> 끝으로 **IPv4/IPv6 자동 선택(해피 아이볼스; Happy Eyeballs)** 클라이언트를 C++23로 구현한다.
> 환경: 리눅스/POSIX + C++23.

---

### 17.1 IPv6 주소 스코프: 링크-로컬과 scope id

#### 17.1.1 스코프 개념 한 줄 요약
- IPv6 주소는 **스코프(scope)** 개념을 가진다. 대표적으로:
  - **링크-로컬**: `fe80::/64` — *해당 링크(인터페이스) 안에서만* 유효. **라우팅 불가**.
  - 유니크 로컬(ULA): `fc00::/7` — 사설망용.
  - 글로벌: `2000::/3` — 인터넷 라우팅.
- **링크-로컬**은 동일 호스트의 `eth0`, `wlan0` 등 **각 링크마다 동일한 주소**가 있을 수 있어,
  패킷을 보낼 때 **어떤 인터페이스로** 보낼지 추가 정보가 필요하다.
  이게 바로 **scope id(= 인터페이스 인덱스)**.

#### 17.1.2 scope id를 지정하는 방법
- **문자열 표기**: `"fe80::1%eth0"` 또는 `"fe80::a:b:c:d%enp0s3"` 처럼 `%ifname` 붙이기.
- **코드에서 직접**: `sockaddr_in6` 의 `sin6_scope_id` 필드에 **인터페이스 인덱스**(`if_nametoindex("eth0")`)를 넣는다.

```cpp
// fe80::1 링크-로컬로 연결: scope id 필수!
#include <net/if.h>        // if_nametoindex
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>

int connect_linklocal(const char* ifname, const char* addr, const char* port){
    addrinfo hints{}, *res=nullptr;
    hints.ai_family = AF_INET6;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV; // 문자열 파서가 %ifname 처리해 줄 때도 있음

    if (getaddrinfo(addr, port, &hints, &res)!=0) return -1;

    int s = ::socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (s<0) { freeaddrinfo(res); return -1; }

    // fe80:: 계열이면 scope 설정
    auto* sa6 = (sockaddr_in6*)res->ai_addr;
    if (IN6_IS_ADDR_LINKLOCAL(&sa6->sin6_addr)) {
        sa6->sin6_scope_id = if_nametoindex(ifname); // 예: "eth0"
    }

    if (::connect(s, res->ai_addr, res->ai_addrlen)!=0) { ::close(s); s=-1; }
    freeaddrinfo(res);
    return s;
}
```

> **주의**
> 링크-로컬은 **라우팅이 안 된다**. 즉, 다른 서브넷으로 **게이트웨이를 거쳐** 갈 수 없다.
> 반드시 **같은 L2 링크**(같은 스위치/브리지)에서만 통신 가능.

---

### 17.2 듀얼스택 리스닝과 `IPV6_V6ONLY`

#### 17.2.1 한 소켓으로 v4/v6를 받을 수 있나?
- **가능**: `AF_INET6` 리스너를 만들고 `IPV6_V6ONLY=0`이면
  **IPv4-mapped IPv6 주소**(`::ffff:192.0.2.10`)로 **IPv4 연결도 수용**한다.
- OS에 따라 기본값이 다르다:
  - **Linux**: 기본 `V6ONLY=0`(듀얼수용)인 경우가 많음.
  - **BSD/Windows**: 기본 `V6ONLY=1`(IPv6만). 필요 시 `setsockopt`로 꺼야 함.

```cpp
// dualstack_listen.cpp — AF_INET6 하나로 v4/v6 수용(리눅스 기본을 명시적으로 설정)
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>

int make_dual_listener(const char* port, int backlog=1024){
    int s = ::socket(AF_INET6, SOCK_STREAM, 0);
    if (s<0) return -1;
    int on=1; ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));

    // 듀얼스택: V6ONLY=0
    int v6only=0; ::setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));

    sockaddr_in6 a6{}; a6.sin6_family=AF_INET6; a6.sin6_addr=in6addr_any; a6.sin6_port=htons((uint16_t)std::stoi(port));
    if (::bind(s, (sockaddr*)&a6, sizeof(a6))!=0 || ::listen(s, backlog)!=0) { ::close(s); return -1; }
    std::print("[listen] [::]:{}\n", port);
    return s;
}
```

- 듀얼로 받으면 `accept()` 이후 **peer 주소**가 `::ffff:a.b.c.d` 형태일 수 있다.
  `getnameinfo()`로 출력할 때 **IPv4-mapped**를 인지하고 **사람이 보기 좋게** 바꿔주자.

```cpp
#include <netdb.h>
#include <string>
static std::string peer_string(const sockaddr* sa, socklen_t sl){
    char h[NI_MAXHOST]{}, s[NI_MAXSERV]{};
    if (getnameinfo(sa, sl, h, sizeof(h), s, sizeof(s), NI_NUMERICHOST|NI_NUMERICSERV)==0) {
        // ::ffff:1.2.3.4 -> 1.2.3.4 로 표시 바꾸기(선택)
        if (strncmp(h, "::ffff:", 7)==0) return std::string(h+7) + ":" + s;
        return std::string(h) + ":" + s;
    }
    return "(unknown)";
}
```

---

### 17.3 `AI_V4MAPPED`/`AI_ADDRCONFIG` — 주소 해석 모드

#### 17.3.1 `AI_ADDRCONFIG` (추천)
- **호스트의 설정**을 고려하여 **존재하지 않는 패밀리**는 배제.
  - 예: IPv6가 **비활성**이면 `AF_INET6` 결과를 내지 않음.
  - 예: IPv4가 없다면 `AF_INET` 결과를 내지 않음.
- 듀얼스택 클라이언트에서는 `AF_UNSPEC + AI_ADDRCONFIG`로 **둘 다 요청**하는 것이 **기본값**에 가깝다.

#### 17.3.2 `AI_V4MAPPED`
- `AF_INET6`로 *만* 해석하고 싶은데 **IPv4도 필요**할 때,
  **IPv4 주소를 IPv6-mapped**로 돌려 달라 요청하는 플래그.
- 사용 예:
  - 코드가 **순수 IPv6 소켓 경로**만 존재할 때도, `::ffff:a.b.c.d` 로 결과를 받아 같은 코드 경로로 처리.
  - 보통은 `AF_UNSPEC` + 자연 듀얼스택이 더 직관적이라 `AI_V4MAPPED`는 *특정 요구*가 있는 경우에만.

```cpp
addrinfo hints{};
hints.ai_family   = AF_INET6;        // IPv6 소켓만 쓸 것이다
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags    = AI_ADDRCONFIG | AI_V4MAPPED;
// → IPv6가 있으면 v6, 없으면 v4를 v6-mapped(::ffff:...)로 반환
```

---

### 17.4 방화벽/보안 그룹(클라우드)에서의 **IPv6 주의점**

1) **IPv4 규칙과 별개**
   - 클라우드(예: “보안 그룹”)는 **IPv4 규칙**과 **IPv6 규칙**이 **분리**되어 있는 경우가 많다.
   - IPv6를 켰다면 **::/0**(또는 제한 CIDR)로 별도 허용 규칙을 넣어야 한다.
   - 보안 그룹에 IPv4만 열어 둔 채 “왜 접속이 안 되지?”가 흔한 실수.

2) **ICMPv6는 필수**
   - IPv4에서 ICMP를 과도 차단해도 비교적 버티지만, **IPv6는 ICMPv6가 핵심 프로토콜**(PMTUD, ND).
   - 최소한 다음을 허용(수신/송신 정책에 따라 조정):
     - **Echo Request/Reply**(핑) — 운영 가이드에 따라 제한 가능
     - **Packet Too Big** — PMTUD 필수
     - **Neighbor Solicitation/Advertisement** — ARP 대응 개념(로컬 링크)
     - **Router Solicitation/Advertisement** — L3 경로 자동 구성(서버에서는 보통 RA는 필요 없음)

3) **예시: ip6tables 최소 규칙(학습용)**
```bash
# 정책: 기본 DROP → 필수만 허용 (실서비스 전 테스트 필수!)
sudo ip6tables -P INPUT DROP
sudo ip6tables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
sudo ip6tables -A INPUT -i lo -j ACCEPT
# ICMPv6 필수
sudo ip6tables -A INPUT -p ipv6-icmp -j ACCEPT
# TCP 9000 서비스
sudo ip6tables -A INPUT -p tcp --dport 9000 -j ACCEPT
```

4) **클라우드 예시(개념)**
   - 보안 그룹에 다음 규칙을 **IPv6 탭**에도 추가:
     - 인바운드: TCP 9000, 소스 `::/0` (또는 특정 프리픽스)
     - ICMPv6: 타입 “패킷 너무 큼(PTB)”, “에코 요청/응답” 등 필요 범위
   - 로드밸런서 앞단이면 **LB IPv6 리스닝** 여부도 별도 옵션인 경우가 많다.

---

### 17.5 실습: **IPv4/IPv6 자동 선택 클라이언트** (Happy Eyeballs 스타일)

> 목표: **IPv6 우선**이지만 **지연 없이 IPv4로 자동 폴백**하는 클라이언트.
> **RFC 6555/8305**의 정신: “**racing**” — IPv6 시도 후 **짧은 지연(예: 200~300ms)** 으로 IPv4도 시도, **먼저 성공하는 쪽**을 채택.
> - 장점: 느린 IPv6 경로/PMTUD 블랙홀에서도 **눈에 띄는 지연 없이** 성공.
> - 구현 요지:
>   1) `getaddrinfo(AF_UNSPEC | AI_ADDRCONFIG)` 로 v6/v4 모두 받아 **적절히 섞기**
>   2) **논블로킹** `connect`
>   3) 첫 시도 후 `Δ=250ms` 지나면 다음 주소도 착수
>   4) **가장 먼저 연결 완료**된 소켓을 반환, 나머지는 정리

#### 17.5.1 도우미: 주소 문자열/스코프/소켓 유틸

```cpp
// v46_happy.hpp — 공용 유틸
#pragma once
#include <netdb.h>
#include <net/if.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>
#include <print>
#include <vector>
#include <string>
#include <string_view>
#include <chrono>
#include <optional>
#include <algorithm>
#include <system_error>

using clock = std::chrono::steady_clock;

inline int set_nonblock(int fd){
    int fl = ::fcntl(fd, F_GETFL, 0);
    if (fl<0) return -1;
    return ::fcntl(fd, F_SETFL, fl | O_NONBLOCK);
}

inline std::string sa_to_string(const sockaddr* sa, socklen_t sl){
    char h[NI_MAXHOST]{}, s[NI_MAXSERV]{};
    if (::getnameinfo(sa, sl, h, sizeof(h), s, sizeof(s), NI_NUMERICHOST|NI_NUMERICSERV)==0){
        if (strncmp(h, "::ffff:", 7)==0) return std::string(h+7) + ":" + s;
        return std::string(h) + ":" + s;
    }
    return "(?)";
}

struct Addr {
    sockaddr_storage ss{};
    socklen_t slen{};
    bool is_v6() const { return ss.ss_family==AF_INET6; }
    bool is_v4() const { return ss.ss_family==AF_INET; }
};

inline std::vector<Addr> resolve_all(std::string_view host, std::string_view serv){
    addrinfo hints{}, *res=nullptr;
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_ADDRCONFIG | AI_NUMERICSERV; // 포트는 숫자로
    if (getaddrinfo(host.empty()?nullptr:std::string(host).c_str(), std::string(serv).c_str(), &hints, &res)!=0) {
        return {};
    }
    std::vector<Addr> out;
    for (auto* ai=res; ai; ai=ai->ai_next){
        if (ai->ai_family!=AF_INET && ai->ai_family!=AF_INET6) continue;
        Addr a{}; std::memcpy(&a.ss, ai->ai_addr, ai->ai_addrlen); a.slen = (socklen_t)ai->ai_addrlen;
        // 링크-로컬이면 scope 보정(문자열에 %ifname가 왔을 때는 이미 설정됨)
        if (ai->ai_family==AF_INET6) {
            auto* sa6 = (sockaddr_in6*)&a.ss;
            if (IN6_IS_ADDR_LINKLOCAL(&sa6->sin6_addr) && sa6->sin6_scope_id==0) {
                // 기본 인터페이스가 필요하다면 여기서 if_nametoindex("eth0") 같은 정책 적용 가능(생략)
            }
        }
        out.push_back(a);
    }
    freeaddrinfo(res);
    return out;
}
```

#### 17.5.2 해피 아이볼스: 간단 스케줄러

- 주소 리스트를 **IPv6, IPv4 번갈아 가며** 섞는다(혹은 OS가 준 우선순위 유지).
- 첫 시도 시작 → **Δ(예: 250ms)** 타이머 → 다음 후보 시도 → …
- `poll()` 로 **어느 소켓이 먼저 연결 완료**되는지 감시.
- 완료 판정: `POLLOUT` 발생 후 `getsockopt(SO_ERROR)==0`.

```cpp
// happy_client.cpp — IPv4/IPv6 자동 선택(비동기 connect 레이싱)
// 빌드: g++ -std=c++23 -O2 happy_client.cpp -o happyc
#include "v46_happy.hpp"
#include <expected>

struct InFlight {
    int fd{-1};
    Addr addr{};
    bool active{false};
};

std::expected<int, std::error_code>
connect_happy(std::string_view host, std::string_view serv,
              std::chrono::milliseconds total_timeout = std::chrono::seconds(5),
              std::chrono::milliseconds step_delay    = std::chrono::milliseconds(250))
{
    auto addrs = resolve_all(host, serv);
    if (addrs.empty()) return std::unexpected(std::make_error_code(std::errc::host_unreachable));

    // 섞기: v6 먼저, 그 다음 v4, 번갈아
    std::vector<Addr> v6, v4;
    for (auto& a: addrs) (a.is_v6()? v6 : v4).push_back(a);
    std::vector<Addr> seq; seq.reserve(addrs.size());
    size_t i=0;
    while (i < v6.size() || i < v4.size()){
        if (i < v6.size()) seq.push_back(v6[i]);
        if (i < v4.size()) seq.push_back(v4[i]);
        ++i;
    }

    auto t_end = clock::now() + total_timeout;
    size_t next_idx = 0;
    std::vector<InFlight> infl;
    infl.reserve(seq.size());

    auto launch = [&](const Addr& a)->bool {
        int s = ::socket(a.ss.ss_family, SOCK_STREAM | SOCK_CLOEXEC, 0);
        if (s<0) return false;
        set_nonblock(s);
        int rc = ::connect(s, (sockaddr*)&a.ss, a.slen);
        if (rc==0) {
            // 즉시 연결됨
            // 나머지는 필요 시 close
            return infl.emplace_back(InFlight{s,a,true}), true;
        }
        if (errno==EINPROGRESS) {
            infl.emplace_back(InFlight{s,a,true});
            return true;
        }
        ::close(s);
        return false;
    };

    // 첫 후보 시작
    if (next_idx < seq.size()) launch(seq[next_idx++]);
    auto t_next = clock::now() + step_delay;

    while (clock::now() < t_end) {
        // 필요하면 다음 후보도 띄움
        if (next_idx < seq.size() && clock::now() >= t_next) {
            launch(seq[next_idx++]);
            t_next = clock::now() + step_delay;
        }

        // poll 대상 구성
        std::vector<pollfd> fds;
        for (auto& x: infl) if (x.active) fds.push_back(pollfd{.fd=x.fd, .events=POLLOUT, .revents=0});

        int to = std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::min({ step_delay, (t_end - clock::now()) })
                 ).count();
        if (to < 0) to = 0;
        int rc = ::poll(fds.data(), (nfds_t)fds.size(), to);
        if (rc < 0) {
            if (errno==EINTR) continue;
            return std::unexpected(std::error_code(errno, std::generic_category()));
        }
        if (rc == 0) continue;

        // 완료 검사
        for (auto& p : fds) if (p.revents & (POLLOUT|POLLERR|POLLHUP)) {
            int so=0; socklen_t sl=sizeof(so);
            ::getsockopt(p.fd, SOL_SOCKET, SO_ERROR, &so, &sl);
            if (so==0) {
                // winner!
                int winner = p.fd;
                // 기타는 정리
                for (auto& x: infl) if (x.fd!=winner) { ::close(x.fd); x.active=false; }
                // 옵션: Nagle off (지연 민감 트래픽이라면)
                // int on=1; setsockopt(winner, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on));
                return winner;
            } else {
                // 실패 → 닫기
                ::close(p.fd);
                for (auto& x: infl) if (x.fd==p.fd) x.active=false;
            }
        }
    }
    // 타임아웃 → 모두 닫고 실패
    for (auto& x: infl) if (x.active) ::close(x.fd);
    return std::unexpected(std::make_error_code(std::errc::timed_out));
}

int main(int argc, char** argv){
    if (argc < 3) {
        std::print(stderr, "usage: {} <host> <port> [timeout_ms=5000] [step_ms=250]\n", argv[0]);
        return 1;
    }
    std::string host=argv[1], port=argv[2];
    auto total = std::chrono::milliseconds(argc>3? std::stoi(argv[3]) : 5000);
    auto step  = std::chrono::milliseconds(argc>4? std::stoi(argv[4]) : 250);

    auto sock = connect_happy(host, port, total, step);
    if (!sock) {
        std::print(stderr, "connect fail: {}\n", sock.error().message());
        return 2;
    }

    // 데모: 한 줄 보내고 한 줄 받기(단순)
    const char* line = "hello over v4/v6!\n";
    ::send(*sock, line, strlen(line), 0);
    char buf[256]; int n = ::recv(*sock, buf, sizeof(buf)-1, 0);
    if (n>0){ buf[n]=0; std::print("[recv] {}\n", buf); }

    ::close(*sock);
    return 0;
}
```

**사용 예**
- 서버(아무 TCP echo 서버든 OK): `nc -l 9000 -k` (IPv4), `nc -6 -l 9000 -k` (IPv6)
- 클라이언트:
```bash
# IPv6 먼저, 250ms 뒤 IPv4도 레이싱
./happyc example.com 9000
# 링크-로컬로 테스트(같은 L2): 호스트명 대신 [fe80::1%eth0]
./happyc fe80::1%eth0 9000
```

> **팁**
> - 위 구현은 **간결화를 위해** in-flight 소켓을 모두 `POLLOUT`로만 감시했다.
>   실제로는 **에러 큐/에러 이벤트**를 더 세밀히 처리하고, 실패 주소를 **블랙리스트/힌트**로 반영하여
>   재시도 효율을 높인다.
> - Happy Eyeballs v2(RFC 8305)는 **주소 섞는 방식/지연**에 좀 더 정교한 규칙이 있다(예: 최초는 v6, 이후 인터리빙).

---

### 17.6 운영/디버깅 포인트

1) **주소 출력 시** `getnameinfo(..., NI_NUMERICHOST)`로 **역해석**(DNS) 지연을 피하고,
   **IPv4-mapped**는 보기 좋게 `::ffff:a.b.c.d` → `a.b.c.d`로 바꿔 로그한다.
2) **듀얼스택 리스너**를 한 개만 두면 편하지만,
   환경에 따라 `IPV6_V6ONLY` 기본값 차이가 있어 **명시적** 설정 권장.
3) **ICMPv6 차단**은 장애의 지름길: PMTUD 실패로 **큰 패킷 정체**.
   “**작게 보내면 되잖아**”가 아니라 **경로 전반**에 맞는 MTU를 찾게 해줘야 한다.
4) **NAT64/DNS64** 환경: `A` 레코드 없이 `AAAA`만 받아 **IPv6 → IPv4 변환**이 일어나는 특수망이 있다.
   일반 듀얼스택 앱은 Happy Eyeballs로 크게 문제 없으나, **주소-직렬화**(IPv4 전제) 코드가 숨어 있으면 오류.
5) **보안**: IPv6 활성화 장비에서 **IPv6 서비스를 열지 않았어도**
   **링크-로컬** 경유로 포트가 접근 가능할 수 있으니, **호스트 방화벽의 IPv6 규칙**을 반드시 점검.

---

### 17.7 미니 체크리스트

- [ ] **링크-로컬**로 보낼 땐 **scope id**(ifindex) 설정. 문자열 `"%eth0"`도 OK.
- [ ] 클라이언트 해석: **`AF_UNSPEC | AI_ADDRCONFIG`** (기본), 필요 시 `AI_V4MAPPED`.
- [ ] 리스너: `AF_INET6` + `IPV6_V6ONLY=0`(듀얼) 또는 =1(엄격 v6).
- [ ] 로그: `getnameinfo(NI_NUMERICHOST)` + IPv4-mapped 처리.
- [ ] 방화벽/SG: **IPv6 규칙 별도** + **ICMPv6 허용**(최소: PTB, ND, ping).
- [ ] 자동 선택: **Happy Eyeballs**(v6 우선, Δ=200~300ms)로 **지연 없는 폴백**.

---

### 17.8 부록: 듀얼스택 에코 서버(참고용, 간단)

```cpp
// dual_echo.cpp — 듀얼스택 리스너 + 에코(블로킹, 교육용)
// 빌드: g++ -std=c++23 -O2 dual_echo.cpp -o decho
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <print>
#include <thread>
#include <vector>
#include <cstring>
#include <netdb.h>

std::string sa_to_string(const sockaddr* sa, socklen_t sl){
    char h[NI_MAXHOST]{}, s[NI_MAXSERV]{};
    if (getnameinfo(sa, sl, h, sizeof(h), s, sizeof(s), NI_NUMERICHOST|NI_NUMERICSERV)==0){
        if (strncmp(h, "::ffff:", 7)==0) return std::string(h+7)+":"+s;
        return std::string(h)+":"+s;
    }
    return "(?)";
}

int main(int argc, char** argv){
    const char* port = (argc>1? argv[1] : "9000");
    int l = ::socket(AF_INET6, SOCK_STREAM, 0);
    int on=1; setsockopt(l,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));
    int v6only=0; setsockopt(l,IPPROTO_IPV6,IPV6_V6ONLY,&v6only,sizeof(v6only));
    sockaddr_in6 a{}; a.sin6_family=AF_INET6; a.sin6_addr=in6addr_any; a.sin6_port=htons((uint16_t)std::stoi(port));
    if (bind(l,(sockaddr*)&a,sizeof(a))||listen(l,1024)){ perror("bind/listen"); return 1; }
    std::print("[listen] [::]:{}\n", port);

    for(;;){
        sockaddr_storage ss{}; socklen_t sl=sizeof(ss);
        int c = ::accept(l,(sockaddr*)&ss,&sl);
        if (c<0){ if (errno==EINTR) continue; perror("accept"); break; }
        std::thread([c,ss,sl]{
            std::print("[conn] {}\n", sa_to_string((sockaddr*)&const_cast<sockaddr_storage&>(ss), sl));
            char buf[4096];
            for(;;){
                int n = ::recv(c, buf, sizeof(buf), 0);
                if (n>0){ ::send(c, buf, n, 0); continue; }
                break;
            }
            ::close(c);
        }).detach();
    }
    ::close(l);
}
```

- IPv4/IPv6 어느 쪽으로 붙어도 답하는 간단한 에코.
- 운영용은 10~11장의 **epoll(ET)** 구조를 사용하고, TLS(14장)도 곁들일 수 있다.

---

### 17.9 마무리

- **IPv6 기본기**: 링크-로컬은 **scope id** 없이는 동작하지 않는다.
- **듀얼스택**: 리스너/클라이언트에서 `AF_UNSPEC` + **Happy Eyeballs**를 채택하면 **지연 없는 연결성**을 얻는다.
- **방화벽/SG**: IPv6는 **별도 규칙**이며, **ICMPv6 허용**은 **필수**.
- 실습 코드로 v4/v6 환경에서 **즉시 폴백**되는 경험을 직접 확인하라 — 그게 듀얼스택의 **현실적인 품질 보증**이다.
