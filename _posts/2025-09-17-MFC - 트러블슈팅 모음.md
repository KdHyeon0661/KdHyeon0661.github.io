---
layout: post
title: MFC - 트러블슈팅 모음
date: 2025-09-17 17:25:23 +0900
category: MFC
---
# 트러블슈팅 모음 — **MFC/Win32 실전**  
_빌드/링크 · 컨트롤 크래시 · 메시지 맵 · x64 전환 · DPI/스케일링 · 리소스 충돌_

> “증상을 정확히 기록 → 최소 재현 코드 → 패턴별 체크리스트 적용.”  
> 아래는 현장에서 자주 터지는 이슈를 **원인→증상→재현→진단→해결** 순으로 정리했습니다.  
> 모든 섹션은 **붙여넣어 쓰는 스니펫**과 **체크리스트**를 포함합니다.

---

## 0) 빠른 진단 루틴(모든 이슈 공통)

1) **정확한 증상 캡처**  
   - 로그(시간/스레드/모듈/오류코드) + 덤프(있다면) + 이벤트 뷰어  
   - “무엇을 했을 때” → **입력·환경·버전**(OS, DPI, 지역) 기록

2) **최소 재현**  
   - 새 MFC 프로젝트(대화상자/SDI)에서 코드 30줄 이내로 복제  
   - 3rd-party 제거, 리소스/매크로 줄이기

3) **바이너리/툴체인 매트릭스**  
   - x86/x64, Debug/Release, /MD(/MDd)/MT(/MTd), 정적(MFC stat) vs 공유(MFC shared)  
   - **서로 다른 조합 섞였는지** 확인 (특히 라이브러리 링크)

---

## 1) 빌드/링크 에러 — 정적/공유 MFC 혼용, 런타임 라이브러리 충돌

### 1-1. 증상/메시지 예시

- LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug'
- LNK2005: _DllMain@12 already defined in msvcrt.lib
- fatal error LNK1104: cannot open file 'mfc140ud.lib' / 'libcmtd.lib'
- unresolved external symbol __imp_Afx… / AfxBeginThread 등

### 1-2. 원인

- **정적 MFC(/MT, /MTd)** 와 **공유 MFC(/MD, /MDd)** **혼용**  
- .lib/.dll **서드파티 바이너리**의 **런타임 설정**이 프로젝트와 다름  
- 프로젝트 일부 서브모듈만 설정 변경(솔루션 전체 불일치)

### 1-3. 진단

- 각 프로젝트의 **C/C++ → 코드 생성 → 런타임 라이브러리** 확인  
- **C/C++ → 고급 → 전처리기 정의**에서 `_AFXDLL` 존재 여부(공유 MFC는 **필수**)  
- 링커 입력에 수동 추가한 **라이브러리 제거**(우선 자동 링커 지시문 사용)

### 1-4. 해결(정석)

**공유 MFC + DLL CRT(/MD or /MDd)** 를 **기본**으로 통일  
(대부분의 상용 배포/서드파티 바이너리와 호환)

- C/C++ → 코드 생성 → **/MD**(Release), **/MDd**(Debug)  
- MFC 사용: **Use of MFC** = “Use MFC in a Shared DLL”  
- 전처리기: `_AFXDLL` 자동 추가 확인

```diff
// 프로젝트 .vcxproj (요지)
<RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>        <!-- /MD -->
<MFCUseOfMFC>Dynamic</MFCUseOfMFC>                       <!-- Shared DLL -->
<PreprocessorDefinitions>_AFXDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
```

> **정적(/MT)** 을 써야 하는 이유가 명확하지 않다면 피하세요. 패치/보안 업데이트, 바이너리 호환성이 불리합니다.

### 1-5. 혼용 환경에서의 응급처치

- 링크 에러가 특정 .lib에서 온다면 **같은 런타임으로 재빌드** 요청(또는 재컴파일)  
- 부득이하게 혼용 시: **/NODEFAULTLIB** 조합, 명시적 링크 라이브러리 지정  
  _단, 숨은 UB(메모리/예외 경계)가 남으므로 장기적으로 **재빌드 통일**이 정답_

```text
링커 → 명령줄: /NODEFAULTLIB:LIBCMTD /NODEFAULTLIB:LIBCMT
```

---

## 2) 컨트롤 크래시 — 수명/소유권, 메시지 경계

### 2-1. 증상

- 종료 시 크래시(0xC0000005, 잘못된 핸들)  
- `C++ EH not handled` / `ASSERT(::IsWindow(m_hWnd))`  
- 메시지 처리 중 컨트롤 포인터 접근 시 Access Violation

### 2-2. 흔한 원인

- **모델리스 대화상자**를 `new` 생성 후 **`delete` 직접 호출** (정답: `DestroyWindow` → `PostNcDestroy`에서 `delete`)  
- **자식 컨트롤**이 파괴된 뒤 멤버 포인터 재사용  
- **소유자 그리기/커스텀 Draw**에서 **수명 긴 GDI 오브젝트**를 Stack으로 생성 후 원복 미실시  
- **OnDestroy → base 호출 순서** 누락

### 2-3. 안전 패턴

```cpp
class CPane : public CDialogEx {
public:
    BOOL Create(CWnd* pParent) { return CDialogEx::Create(IDD_PANE, pParent); }
    void PostNcDestroy() override { delete this; } // 모델리스 수명
};

// 파괴
if (m_pPane && ::IsWindow(m_pPane->GetSafeHwnd())) {
    m_pPane->DestroyWindow(); // → PostNcDestroy 에서 delete
    m_pPane = nullptr;
}
```

```cpp
// GDI 선택/원복/수명
void Draw(CDC& dc) {
    CPen pen(PS_SOLID, 1, RGB(0,0,0));
    CPen* old = dc.SelectObject(&pen);
    // ... draw ...
    dc.SelectObject(old); // 원복!
}
```

**체크리스트**
- [ ] 모델리스: `DestroyWindow` + `PostNcDestroy()`  
- [ ] 자식 컨트롤 포인터 접근 전 `::IsWindow(h)` 검사  
- [ ] `OnDestroy()` → **반드시** `__super::OnDestroy()` 호출  
- [ ] 타 스레드에서 UI 접근 금지(필요 시 `PostMessage`)

---

## 3) 메시지 맵 중복/오타 — 라우팅 미스

### 3-1. 증상

- 핸들러가 **호출되지 않음** / 엉뚱한 클래스가 처리  
- `ASSERT(AfxIsValidString)` / `Command/UI Update`가 깜빡이거나 상태 이상

### 3-2. 원인/패턴

- **ID 충돌**: 리소스 ID가 중복 → 다른 핸들러로 라우팅  
- 메시지 맵 매크로 **오타**: `ON_BN_CLICKED` ↔ `ON_BN_CLICK`  
- **반사 메시지**(`ON_NOTIFY_REFLECT`) 써야 할 곳에서 상위에 바인딩  
- SDI/MDI 라우팅 경로 오해(활성 View → Frame → Doc → App)

### 3-3. 진단/해결

- **Spy++** 또는 `TRACE`로 메시지 흐름 확인  
- 리소스.h에서 **ID 범위/중복** 검색  
- 컨트롤 서브클래싱 시 **REFLECT 사용**

```cpp
BEGIN_MESSAGE_MAP(CMyListCtrl, CListCtrl)
    ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, &CMyListCtrl::OnCustomDraw)
END_MESSAGE_MAP()
```

```cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_BN_CLICKED(IDC_BTN_DO, &CMainDlg::OnBnClickedDo) // 정확한 매크로/ID
END_MESSAGE_MAP()
```

**체크리스트**
- [ ] 리소스 ID 고유(섹션 7 참조)  
- [ ] `*_REFLECT`는 서브클래싱된 컨트롤에  
- [ ] SDI/MDI: 데이터 조작은 Doc, 표시/UI는 View

---

## 4) x64 전환 — 포인터/정수 크기, 캐스트

### 4-1. 증상

- x86에서 정상 → x64에서 **크래시/값 깨짐**  
- LNK2019: unresolved external (호출규약/데코레이션 차이)  
- 경고 C4311/C4302: 포인터를 좁은 정수로 캐스트

### 4-2. 원인 패턴

- `int`/`long`에 포인터 저장 (`long`는 x64에서 32-bit)  
- `sizeof(long) == 4`(Windows), `sizeof(size_t) == 8`  
- `WPARAM`/`LPARAM` 사용법 착각, 콜백 캐스트 잘못

### 4-3. 안전 치트시트

- 주소/핸들/길이: **`UINT_PTR`, `LONG_PTR`, `WPARAM`, `LPARAM`, `size_t`**  
- 인덱스/사이즈: `size_t`  
- 형변환: `reinterpret_cast<UINT_PTR>(ptr)` ↔ `reinterpret_cast<void*>(val)`

```cpp
// BAD
long tag = (long)pObj;    // x64에서 짤림
void* p = (void*)lParam;  // 서명 불명확

// GOOD
LONG_PTR tag = reinterpret_cast<LONG_PTR>(pObj);
void* p = reinterpret_cast<void*>(lParam);
```

```cpp
// LVN_GETDISPINFO 사용자 데이터
m_list.SetItemData(i, reinterpret_cast<DWORD_PTR>(pItem));
auto* p = reinterpret_cast<Item*>(m_list.GetItemData(i));
```

**빌드 설정**
- Warning Level = **/W4**, **C4244/4267**(손실 변환) **검토**  
- “Treat Warnings as Errors”는 전환 기간엔 **OFF**, 목록 관리 후 점진 적용

---

## 5) DPI/스케일링 깨짐 — 고해상도 테스트 포인트

### 5-1. 증상

- 125%/150%에서 레이아웃 겹침/잘림  
- 아이콘/비트맵이 흐릿함(스케일링)  
- 다중 모니터(서로 다른 DPI)에서 이동 시 크기 튐

### 5-2. 근본

- 고정 픽셀 좌표(마법 숫자), 폰트/메트릭 무시  
- DPI Awareness 미지정 → 시스템 스케일링(흐릿함/좌표 변환)  
- GDI 비트맵 리소스가 단일 해상도

### 5-3. 대책(저침습→고급 순)

1) **System DPI Aware** 매니페스트(최저)  
   - 흐릿함은 줄고, DPI 변경 시 **재시작 필요**  
2) **PerMonitorV2** + **WM_DPICHANGED** 처리  
   - 창 이동/모니터 변경 시 즉시 레이아웃 재계산

```xml
<!-- app.manifest -->
<asmv3:application>
  <asmv3:windowsSettings
    xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
    <dpiAware>true/pm</dpiAware>
    <dpiAwareness>PerMonitorV2</dpiAwareness>
  </asmv3:windowsSettings>
</asmv3:application>
```

```cpp
// WM_DPICHANGED 처리(대화상자/프레임)
afx_msg LRESULT OnDpiChanged(WPARAM w, LPARAM l) {
    UINT dpi = HIWORD(w);
    RECT* prcNew = (RECT*)l;
    SetWindowPos(nullptr, prcNew->left, prcNew->top,
        prcNew->right - prcNew->left, prcNew->bottom - prcNew->top,
        SWP_NOZORDER|SWP_NOACTIVATE);
    RecalcLayoutForDpi(dpi); // 컨트롤 크기/간격 재계산
    return 0;
}
```

```cpp
// 폰트/간격 재계산 예시
int Scale(int px, UINT dpi) { return MulDiv(px, dpi, 96); }

BOOL CMainDlg::ApplyDpi(UINT dpi) {
    LOGFONT lf{}; SystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, 0, dpi);
    m_font.DeleteObject(); m_font.CreateFontIndirect(&lf);
    SendMessageToDescendants(WM_SETFONT, (WPARAM)m_font.m_hFont, TRUE);
    // 버튼/에디트 MoveWindow with Scale(...)
    return TRUE;
}
```

**테스트 포인트**
- [ ] 100/125/150/200% **모두**  
- [ ] 듀얼 모니터 **서로 다른 DPI**  
- [ ] 프리뷰/인쇄 대화상자(폰트 pt→픽셀 변환 확인)  
- [ ] 아이콘 리소스 **멀티 사이즈**(16~64) 포함

---

## 6) 리소스 충돌 — 다국어/서드파티와 ID 범위 관리

### 6-1. 증상

- 메뉴/대화상자 텍스트가 **뒤섞임**(다른 언어 리소스)  
- **ID 충돌**로 잘못된 핸들러 라우팅  
- 서드파티 DLL 추가 후 버튼/메뉴가 이상 동작

### 6-2. 원인

- `resource.h` ID **중복 충돌**(수동 상수 정의, 여러 모듈 혼재)  
- 다국어 **위성 DLL**/다중 `LANG` 블록 섞임  
- **공용 범위**(예: 1001~1100)를 팀/모듈 간 충돌 없이 관리 못함

### 6-3. 관리 전략

- **ID 범위 계획**(모듈별 할당)

| 모듈 | ID 범위 |
|---|---|
| Core | 10000–11999 |
| UI(Main) | 12000–13999 |
| Reports | 14000–15999 |
| 3rdParty Wrapper | 20000–21999 |

- **리소스 전용 헤더 분리**: `res_ids_core.h`, `res_ids_ui.h` → `resource.h`에서 **포함 순서 고정**  
- 자동 생성 블록(`APSTUDIO_INVOKED`) **아래**에 커스텀 상수는 두지 말 것

```cpp
// resource.h (발췌)
#include "res_ids_core.h"
#include "res_ids_ui.h"
// APSTUDIO will append its block below. Do not put custom defines after this.
#ifdef APSTUDIO_INVOKED
// ...
#endif
```

### 6-4. 다국어 배포(위성 DLL)

- `MyApp.exe` + `ko-KR\MyApp.resources.dll` + `en-US\…`  
- 런타임 `SetThreadPreferredUILanguages` 또는 `AfxSetResourceHandle(hLangDll)`로 전환

```cpp
// 언어 전환 예
HMODULE hRes = LoadLibraryEx(L"ko-KR\\MyApp.resources.dll", nullptr, LOAD_LIBRARY_AS_IMAGE_RESOURCE);
if (hRes) AfxSetResourceHandle(hRes);
```

**체크리스트**
- [ ] 모듈별 **ID 범위표** 유지  
- [ ] `resource.h` 커스텀 상수는 **별도 헤더**에서  
- [ ] 다국어: **위성 DLL** 사용 시 리소스 핸들 전환 코드 명시

---

## 7) 추가 자주 만나는 이슈 & 미니 레시피

### 7-1. “Debug OK, Release 충돌”

- **최적화**로 인한 UB 노출: 초기화되지 않은 변수, 범위 밖 접근  
- **ASSERT 제거**로 인한 사이드이펙트  
- 해결  
  - /GS, /sdl, /W4  
  - AddressSanitizer(가능한 툴체인), Static Analysis  
  - **정의되지 않은 순서 의존** 코드 제거

### 7-2. “릴리즈에서만 LNK… 심볼 못 찾음”

- `#pragma comment(lib, “…d.lib”)` 같은 **디버그 전용** 강제 링크가 Release에도 남음  
- 프로젝트 설정의 “추가 종속성” **구성별** 확인

### 7-3. “ListCtrl 가상 모드 깜빡임/느림”

- `LVS_EX_DOUBLEBUFFER` + Owner Data  
- 대량 갱신 전 `SetRedraw(FALSE)` 후 일괄 업데이트

```cpp
m_list.SetRedraw(FALSE);
// insert/update batch
m_list.SetRedraw(TRUE); m_list.Invalidate();
```

### 7-4. “모달 대화상자 재진입으로 Freeze”

- 긴 작업에서 `DoModal()`/메시지 박스 반복 호출  
- **진행 대화상자 + 취소**(모달 1회)로 구조 단순화  
- 백그라운드 작업은 워커 스레드 + `PostMessage` 로 UI 갱신

### 7-5. “파일 경로 한글/공백/긴 경로 이슈”

- 항상 **유니코드** API(…W) 사용, 문자열은 UTF-16  
- MAX\_PATH 초과: `\\?\` prefix 사용

```cpp
std::wstring widen(const std::string& u8);
CreateFileW(LR"(\\?\C:\Very\Long\Path\...)", ...);
```

---

## 8) 스니펫 보관함(붙여넣기용)

### 8-1. Win32 오류 포맷 & 로깅 매크로

```cpp
inline std::wstring LastErrorW(DWORD e = GetLastError()) {
    LPWSTR p = nullptr;
    FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
                   nullptr, e, 0, (LPWSTR)&p, 0, nullptr);
    std::wstring s = p ? p : L"(unknown)";
    if (p) LocalFree(p);
    return s;
}

#define LOG_HRFAIL(hr, where) \
    do{ if(FAILED(hr)) gLog->error((where) + (L": hr=0x") + std::to_wstring(hr)); }while(0)
```

### 8-2. 모델리스 수명 안전틀

```cpp
class CAboutDlg : public CDialogEx {
public: CAboutDlg():CDialogEx(IDD_ABOUT) {}
    void PostNcDestroy() override { delete this; }
};
void CMainDlg::OnAbout() {
    if (!m_pAbout) m_pAbout = new CAboutDlg;
    if (!::IsWindow(m_pAbout->m_hWnd)) m_pAbout->Create(this);
    m_pAbout->ShowWindow(SW_SHOW);
}
```

### 8-3. x64 안전 캐스트

```cpp
auto to_ptr = [](LPARAM l){ return reinterpret_cast<void*>(l); };
auto to_lparam = [](void* p){ return reinterpret_cast<LPARAM>(p); };
```

### 8-4. DPI 스케일 유틸

```cpp
class Dpi {
public:
    explicit Dpi(HWND h): m( winrt::Windows::Graphics::Display::DisplayInformation::GetForCurrentView().LogicalDpi() ) {}
    static int Scale(int px, UINT dpi) { return MulDiv(px, dpi, 96); }
};
```

(※ WinRT 없이도 `GetDpiForWindow` / `GetDpiForSystem` 사용 가능)

---

## 9) 체크리스트(요약)

**빌드/링크**
- [ ] 모든 프로젝트 **/MD(/MDd)**, **MFC Shared** 통일  
- [ ] `_AFXDLL` 정의, /NODEFAULTLIB 제거(예외 상황만)  
- [ ] 3rd-party .lib **툴체인/런타임 일치**

**컨트롤/수명**
- [ ] 모델리스: `DestroyWindow` + `PostNcDestroy`  
- [ ] GDI 선택/원복, 핸들 누수 없음  
- [ ] UI는 UI 스레드에서만 업데이트

**메시지 맵**
- [ ] ID 중복 없음, 리소스 헤더 분리  
- [ ] `_REFLECT`는 컨트롤 클래스에  
- [ ] SDI/MDI 경로 이해(Active View → Frame → Doc → App)

**x64**
- [ ] 포인터는 `UINT_PTR/LONG_PTR/size_t`  
- [ ] 경고 C4311/C4302 해결  
- [ ] /W4 + 손실 변환 경고 확인

**DPI**
- [ ] 매니페스트 PerMonitorV2  
- [ ] `WM_DPICHANGED` 처리, 폰트/간격 재계산  
- [ ] 아이콘 멀티 해상도

**리소스**
- [ ] 모듈별 ID 범위표  
- [ ] 위성 DLL/리소스 핸들 전환 코드  
- [ ] `resource.h` 관리 규칙 준수

---

## 10) 마무리

- **혼용 금지(런타임/MFC)** → 빌드/링크 안정  
- **수명/메시지 경계** → 컨트롤 크래시 해결  
- **x64 캐스트/타입** → 이식 안정  
- **DPI/리소스 규율** → 현대 환경 대응