---
layout: post
title: 컴퓨터시스템 - 쓰레드를 이용한 동시성 프로그래밍
date: 2025-09-10 19:20:23 +0900
category: 컴퓨터시스템
---
# 쓰레드를 이용한 동시성 프로그래밍 (POSIX/pthreads 중심, CS:APP 스타일)

> 형식: 전체는 `~~~markdown`으로 감싸고, **코드는 모두 ```** 로 감쌉니다.  
> 목표: **쓰레드의 수명주기 → 메모리 모델 → 동기화 원리 → 대표 패턴(생산자-소비자/스레드풀) → 안정성(데드록‧취소‧신호) → 성능 튜닝(거짓 공유‧NUMA)** 를 체계적으로 이해합니다.

---

## 0) 동시성 프로그래밍이란? (요약 재정의)

- **동시성(Concurrency)**: 여러 작업을 *겹쳐서* 진행되도록 구성하는 설계 기법(단일 코어도 스케줄링으로 동시처럼 보임).  
- **병렬성(Parallelism)**: 여러 작업이 **물리적으로 동시에** 수행(멀티코어).  
- 쓰레드 기반 동시성은 **하나의 프로세스 안에서 주소공간을 공유**하며 가벼운 실행 흐름을 병행시킵니다.

---

## 1) 쓰레드의 기본: 모델과 수명주기

### 1.1 쓰레드 모델
- **1:1 커널 스레드**(현대 Linux/Windows/macOS 대부분): 사용자 쓰레드 1 ↔ 커널 스레드 1.
- **M:N**(과거 일부 런타임): 사용자 스케줄러가 사용자 스레드를 커널 스레드에 다대다 매핑(복잡성↑, 요즘 드뭄).

### 1.2 POSIX 쓰레드(pthreads) 빠른 지도

| 목적 | 함수 | 설명 |
|---|---|---|
| 생성/종료 | `pthread_create`, `pthread_exit` | 새 스레드 시작/자기 종료 |
| 합류/분리 | `pthread_join`, `pthread_detach` | 합류(join)·분리(detach) |
| 속성 | `pthread_attr_init/setdetachstate/setstacksize` | 스택 크기/분리 상태 |
| 상호배제 | `pthread_mutex_*` | 뮤텍스(상호배제 락) |
| 조건변수 | `pthread_cond_*` | 대기/신호(조건 충족 시 깨움) |
| 읽기-쓰기 락 | `pthread_rwlock_*` | 읽기 다중 / 쓰기 단일 |
| 스핀락 | `pthread_spin_*` | 짧은 임계구역 바쁜대기 |
| 세마포어 | `sem_init/sem_wait/sem_post` | 카운팅 동기화(프로세스 간도 가능) |
| 배리어 | `pthread_barrier_*` | 스레드 동시 지점 맞추기 |
| 원샷 | `pthread_once` | 1회 초기화 보장 |
| TLS | `pthread_key_*` / `__thread` | 스레드 지역 저장소 |
| 취소 | `pthread_cancel`, `pthread_cleanup_push/pop` | 스레드 취소와 정리 |
| 신호 | `pthread_sigmask`, `sigwait` | 멀티스레드 신호 처리 |

---

## 2) 메모리 모델: 데이터 레이스와 happens-before

### 2.1 공유 메모리와 레이스
- 모든 스레드는 **같은 주소공간**을 보므로 **동시에 같은 변수**를 만질 수 있습니다.
- **데이터 레이스**: 동기화 없이 둘 이상의 스레드가 같은 메모리를 접근하며 적어도 하나가 쓰기일 때.  
  → **정의되지 않은 동작(UB)**. 반드시 **락·원자적 연산·메모리 질서**로 보호하세요.

### 2.2 C11 원자/메모리 질서(요지)
- `_Atomic T` / `<stdatomic.h>`: `atomic_int`, `atomic_fetch_add`, `atomic_load/store`.
- **메모리 오더**: `memory_order_relaxed`, `acquire`, `release`, `acq_rel`, `seq_cst`.  
  - 보편 규칙: **생산자**가 `release`로 쓰고, **소비자**가 `acquire`로 읽으면 **happens-before** 보장.

```c
#include <stdatomic.h>
typedef struct { atomic_int ready; int payload; } slot_t;
/* producer */
s->payload = 42;
atomic_store_explicit(&s->ready, 1, memory_order_release);
/* consumer */
while (!atomic_load_explicit(&s->ready, memory_order_acquire)) { /* spin */ }
printf("%d\n", s->payload); // 42 보장
```

> 뮤텍스/조건변수는 **잠금/해제 시점에 적절한 메모리 장벽**을 내장합니다(일반적으로 `acquire/release`).

---

## 3) 동기화 원리와 올바른 사용

### 3.1 뮤텍스 + 조건변수: 정석 패턴
- **불변식**: *조건변수는 “이벤트”가 아니라 “상태(predicate)”를 기다릴 때* 사용.
- **항상 `while (!predicate) pthread_cond_wait(...)`**: 스퍼리어스 웨이크업/경쟁을 막는 정석.

```c
/* 유한 버퍼: 생산자-소비자 (뮤텍스+조건변수) */
#include <pthread.h>
#define N 16
int buf[N], cnt=0, in=0, out=0;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  cv_not_full  = PTHREAD_COND_INITIALIZER;
pthread_cond_t  cv_not_empty = PTHREAD_COND_INITIALIZER;

void put(int x){
  pthread_mutex_lock(&m);
  while (cnt==N) pthread_cond_wait(&cv_not_full, &m);
  buf[in]=(x); in=(in+1)%N; cnt++;
  pthread_cond_signal(&cv_not_empty);
  pthread_mutex_unlock(&m);
}
int get(void){
  pthread_mutex_lock(&m);
  while (cnt==0) pthread_cond_wait(&cv_not_empty, &m);
  int x = buf[out]; out=(out+1)%N; cnt--;
  pthread_cond_signal(&cv_not_full);
  pthread_mutex_unlock(&m);
  return x;
}
```

**주의**
- `signal` vs `broadcast`: 한 소비자만 깨우면 충분할 때 `signal`, 조건을 만족할지 모르는 다수 스레드라면 `broadcast`.
- `pthread_mutex_t` 타입: `NORMAL`/`ERRORCHECK`/`RECURSIVE` 중 **재귀 락은 가급적 지양**.

### 3.2 읽기-쓰기 락
- 읽기 위주 워크로드에서 이득. 쓰기 경합이 많으면 뮤텍스보다 느려질 수 있음.

```c
pthread_rwlock_t rw = PTHREAD_RWLOCK_INITIALIZER;
/* reader */ pthread_rwlock_rdlock(&rw); /* read ... */ pthread_rwlock_unlock(&rw);
/* writer */ pthread_rwlock_wrlock(&rw); /* write.. */ pthread_rwlock_unlock(&rw);
```

### 3.3 세마포어
- **자원 카운팅**. 생산자-소비자 대체 구현에도 흔히 쓰임(프로세스 간 공유 가능).

```c
#include <semaphore.h>
sem_t slots, items; // slots=N, items=0 초기화
// put: sem_wait(&slots) → enqueue → sem_post(&items)
// get: sem_wait(&items) → dequeue → sem_post(&slots)
```

### 3.4 스핀락
- 임계구역이 **매우 짧고**, 커널 스케줄 아웃이 부담일 때(커널 내, 또는 가벼운 사용자 임계).  
  장시간 점유/페이지 폴트 가능 코드와 같이 쓰면 **CPU 낭비**.

### 3.5 배리어 / 원샷 / TLS
```c
pthread_barrier_t b; pthread_barrier_init(&b, NULL, P); // P개 스레드 동시점
pthread_once_t once = PTHREAD_ONCE_INIT;
void init_once(void) { /* 전역 초기화 */ }
__thread int tl_var; // (GCC) 스레드 지역 변수
```

---

## 4) 스레드의 수명주기와 취소/정리

### 4.1 생성–합류–분리

```c
#include <pthread.h>
#include <stdio.h>

void* worker(void* arg){ printf("hello %s\n",(char*)arg); return (void*)42; }

int main(void){
  pthread_t t; pthread_create(&t, NULL, worker, "thread");
  void* ret; pthread_join(t, &ret);
  printf("ret=%ld\n", (long)ret);
}
```

- **detached**: 합류할 수 없고 종료 즉시 자원 반환 → 결과 수집 불가.  
  `pthread_detach(t)` 또는 생성 속성에서 `DETACHED`.

### 4.2 취소와 정리
- **취소**는 기본 **지연 취소(deferred)**. 취소 가능 지점(`read`, `pthread_cond_wait` 등)에서만 반응.
- **정리 핸들러**로 락 해제를 보장:

```c
void cleanup(void* p){ pthread_mutex_unlock((pthread_mutex_t*)p); }
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
void* w(void*){
  pthread_mutex_lock(&m);
  pthread_cleanup_push(cleanup, &m);
  /* 작업… (중간에 취소되면 cleanup 호출) */
  pthread_cleanup_pop(1); // 1 → cleanup 호출
  return NULL;
}
```

### 4.3 `fork`와 멀티스레딩
- 멀티스레드 프로세스에서 `fork()` 후 **자식은 호출 스레드 1개만 존재**.  
  락이 잠겨 있으면 **교착** 위험 → `pthread_atfork` 핸들러로 락을 풀거나, 가능하면 `posix_spawn()` 사용.

---

## 5) 대표 동시성 패턴

### 5.1 스레드 풀(작업 큐 기반)

- **장점**: 스레드 생성/파괴 오버헤드 제거, 큐로 역압(Backpressure).
- 최소 구현(작업 = 함수 포인터 + 인자):

```c
/* 간단 스레드풀: 교육용(오류검사/종료처리 축약) */
#include <pthread.h>
#include <stdlib.h>

typedef void (*job_fn)(void*);
typedef struct job { job_fn fn; void* arg; struct job* next; } job_t;

typedef struct {
  pthread_mutex_t m;
  pthread_cond_t  cv;
  job_t* head;
  int stop, nworkers;
  pthread_t* th;
} tpool_t;

void* worker(void* p){
  tpool_t* tp = p;
  for(;;){
    pthread_mutex_lock(&tp->m);
    while(!tp->head && !tp->stop) pthread_cond_wait(&tp->cv, &tp->m);
    if (tp->stop && !tp->head){ pthread_mutex_unlock(&tp->m); break; }
    job_t* j = tp->head; tp->head = j->next;
    pthread_mutex_unlock(&tp->m);
    j->fn(j->arg); free(j);
  }
  return NULL;
}

void tpool_init(tpool_t* tp, int n){
  *tp=(tpool_t){.m=PTHREAD_MUTEX_INITIALIZER,.cv=PTHREAD_COND_INITIALIZER};
  tp->nworkers=n; tp->th=calloc(n,sizeof(pthread_t));
  for(int i=0;i<n;i++) pthread_create(&tp->th[i],NULL,worker,tp);
}
void tpool_submit(tpool_t* tp, job_fn fn, void* arg){
  job_t* j = malloc(sizeof* j); j->fn=fn; j->arg=arg; j->next=NULL;
  pthread_mutex_lock(&tp->m);
  j->next = tp->head; tp->head = j;
  pthread_cond_signal(&tp->cv);
  pthread_mutex_unlock(&tp->m);
}
void tpool_shutdown(tpool_t* tp){
  pthread_mutex_lock(&tp->m); tp->stop=1; pthread_cond_broadcast(&tp->cv); pthread_mutex_unlock(&tp->m);
  for(int i=0;i<tp->nworkers;i++) pthread_join(tp->th[i],NULL);
  free(tp->th);
}
```

> 실무에서는 **작업 큐를 MPMC 락프리**로 바꾸거나, **우선순위/타임아웃**을 넣습니다.

### 5.2 생산자–소비자 (유한 버퍼)
- §3.1 예제 참고. 다수 생산자/소비자에서도 **하나의 뮤텍스 + 두 조건변수**로 해결.

### 5.3 병렬 map/reduce(배리어)
- P개 스레드가 부분 집계 → 배리어 → 마스터가 병합.

---

## 6) 안정성: 데드록‧라이브락‧기아‧우선순위 역전

### 6.1 데드록 4조건과 예방법
- **상호배제, 점유-대기, 비선점, 환형대기**.  
- 예방법:
  - **전역 락 순서** 규칙(ABC 순서로만 획득)
  - **trylock + backoff**(충돌 시 포기/재시도)
  - **시간 제한** 락(표준에선 제한적, OS 확장 사용)

```c
/* 잘못된 예: 순서 역전 */
pthread_mutex_t A, B;
/* T1: lock(A)→lock(B) , T2: lock(B)→lock(A) => 교착 가능 */
```

### 6.2 라이브락/기아
- 계속 양보만 해서 진전이 없는 상태(라이브락) / 우선순위 낮아 영원히 기회가 없는 상태(기아).
- 해결: **랜덤 백오프**, 공정 락, 스케줄 정책 점검.

### 6.3 우선순위 역전
- 낮은 우선순위 스레드가 락을 잡고 있고 높은 우선순위가 기다릴 때, 중간 우선순위가 선점해 **역전** 발생.  
- 해결: **우선순위 상속/천장** 지원 락(실시간 OS/특정 뮤텍스 속성).

---

## 7) 성능: 스케일링과 캐시 친화

### 7.1 Amdahl과 임계구역
- 전체 시간에서 직렬 부분 비율 α일 때, 코어 p개에서 속도향상은  
  \( S(p)=\frac{1}{\alpha + \frac{1-\alpha}{p}} \).  
  → **임계구역/공유자료 접근**을 줄이는 게 스레드 확장성의 핵심.

### 7.2 거짓 공유(False Sharing)
- 서로 다른 변수를 **같은 캐시라인**에 둘 때, 다른 코어의 쓰기가 **불필요한 무효화** 유발.
- 해결: **패딩** 또는 **캐시라인 정렬**.

```c
#include <stdalign.h>
#define CL 64
typedef struct { alignas(CL) long x; } padded_counter_t;
```

### 7.3 메모리 할당기
- 전역 락을 쓰는 할당기는 경합 큼. **jemalloc/tcmalloc** 등 **스레드 캐시** 지원 할당기를 고려.

### 7.4 NUMA/코어 배치
- **첫 터치(First-touch)** 정책: 데이터를 사용할 스레드가 **초기에 할당/접근**하도록 하여 로컬 노드에 배치.
- CPU 친화도: `pthread_setaffinity_np`(Linux)로 **스레드-코어 고정**.

### 7.5 I/O 결합
- I/O 중심이라면 **이벤트 루프(epoll)** + **스레드풀(작업 처리)** 하이브리드가 효과적.

---

## 8) 멀티스레드에서의 신호·I/O·표준 라이브러리

- **신호**: 프로세스 전체 범위. 한 스레드가 처리하도록
  ```c
  sigset_t set; sigemptyset(&set); sigaddset(&set,SIGINT);
  pthread_sigmask(SIG_BLOCK,&set,NULL);
  // 전용 스레드에서
  int sig; sigwait(&set,&sig); /* 동기적으로 처리 */
  ```
- **stdio**는 내부 락으로 보통 thread-safe지만, **동시 포맷 출력의 논리적 원자성**은 보장 안 됨(줄 단위로 `flockfile` 고려).
- **재진입 가능한 함수** 사용(`strtok_r` 등). 전역 상태가 있는 함수 주의.

---

## 9) 디버깅/검증 도구

- **ThreadSanitizer(TSan)**: 데이터 레이스/락 순서 탐지(Clang/GCC `-fsanitize=thread`).
- **Valgrind Helgrind/DRD**: 레이스/락 오류.
- **gdb**: `info threads`, `thread apply all bt`, `set scheduler-locking on`.
- **perf / flamegraph**: 락 경합/핫스팟 분석.
- **로그**: 스레드 ID `pthread_self()`/`gettid()` 포함.

---

## 10) 체크리스트 (현업용 요약)

- [ ] **공유 데이터**에 접근할 때는 항상 **락/원자** 또는 **불변/복사-갱신**  
- [ ] **조건변수는 while**(스퍼리어스‧경쟁 대비)  
- [ ] **락 순서 규약** 수립, `trylock`/타임아웃 전략  
- [ ] **취소/종료 경로**에서 **정리 핸들러**로 락/자원 해제  
- [ ] **거짓 공유** 방지(패딩/정렬)  
- [ ] **스레드풀**로 생성/파괴 오버헤드 제거, 큐에 역압 적용  
- [ ] **fork 대신 posix_spawn**, 꼭 필요 시 `pthread_atfork`로 안전화  
- [ ] **신호는 전용 스레드에서 `sigwait`**  
- [ ] 할당기/NUMA/코어 친화도 튜닝

---

## 11) 부록: 추가 예제

### 11.1 기본 pthread 예제(인자/반환값)
```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct { int a, b; } args_t;

void* run(void* p){
  args_t* x = p;
  int* ret = malloc(sizeof(int));
  *ret = x->a + x->b;
  return ret;
}
int main(void){
  pthread_t t; args_t arg={.a=7,.b=35};
  pthread_create(&t, NULL, run, &arg);
  int* sum; pthread_join(t, (void**)&sum);
  printf("%d\n", *sum); free(sum);
}
```

### 11.2 C11 원자적 카운터(락 없는 증가)
```c
#include <stdatomic.h>
#include <pthread.h>
#include <stdio.h>

atomic_long cnt = 0;
void* worker(void*){
  for (long i=0;i<1000000;i++) atomic_fetch_add_explicit(&cnt, 1, memory_order_relaxed);
  return NULL;
}
int main(){
  pthread_t t[4]; for(int i=0;i<4;i++) pthread_create(&t[i],NULL,worker,NULL);
  for(int i=0;i<4;i++) pthread_join(t[i],NULL);
  printf("%ld\n", atomic_load(&cnt));
}
```

---

## 12) 한 줄 결론
쓰레드 동시성의 본질은 **공유 데이터를 언제‧어떻게 안전하게 만질 것인가**입니다.  
**올바른 동기화(뮤텍스/조건/원자)와 메모리 모델**, **안정성(데드록/취소/신호)**, **성능(거짓 공유/NUMA/락 경합 감소)**를 체계적으로 적용하면, 쓰레드는 I/O·CPU 구분 없이 **응답성과 처리량을 동시에** 잡는 강력한 수단이 됩니다.