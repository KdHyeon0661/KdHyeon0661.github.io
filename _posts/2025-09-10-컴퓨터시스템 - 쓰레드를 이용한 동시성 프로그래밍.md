---
layout: post
title: 컴퓨터시스템 - 쓰레드를 이용한 동시성 프로그래밍
date: 2025-09-10 19:20:23 +0900
category: 컴퓨터시스템
---
# 쓰레드를 이용한 동시성 프로그래밍

## 0) 동시성/병렬성 요약

- **동시성(Concurrency)**: 여러 작업을 *겹쳐서* 진행되도록 스케줄. 단일 코어에서도 시분할로 “동시처럼”.  
- **병렬성(Parallelism)**: 여러 코어가 **물리적으로 동시에** 작업.  
- **쓰레드 기반 동시성**: 하나의 프로세스 안에서 **주소 공간을 공유**하며 가벼운 실행 흐름을 병행.

---

## 1) 쓰레드의 기본 — 모델과 수명주기

### 1.1 쓰레드 모델
- **1:1 커널 스레드**: 사용자 스레드 1 ↔ 커널 스레드 1 (현대 Linux/macOS/Windows 기본).
- **M:N**: 사용자 스케줄러가 사용자 스레드를 커널 스레드에 다대다 매핑(역사적/특수 런타임).

### 1.2 pthreads 핵심 API 지도

| 목적 | 함수 | 요점 |
|---|---|---|
| 생성/종료 | `pthread_create`, `pthread_exit` | 시작 루틴/인자/리턴값 |
| 합류/분리 | `pthread_join`, `pthread_detach` | join으로 결과 수집, detach는 즉시 자원 반납 |
| 속성 | `pthread_attr_*` | 스택 크기, 분리 상태, 스케줄 정책/우선순위 |
| 상호배제 | `pthread_mutex_*` | `lock/unlock`, `trylock`, robust/PI 옵션 |
| 조건변수 | `pthread_cond_*` | `wait/signal/broadcast`, timedwait |
| RW 락 | `pthread_rwlock_*` | 읽기 다중/쓰기 단일 |
| 스핀락 | `pthread_spin_*` | 짧은 임계구역 |
| 배리어 | `pthread_barrier_*` | P개 동시 도착점 |
| 원샷 | `pthread_once` | 한 번만 초기화 |
| TLS | `pthread_key_*`, `__thread` | 스레드 지역 저장소 |
| 취소 | `pthread_cancel`, `pthread_cleanup_push/pop` | 지연 취소/정리 |
| 신호 | `pthread_sigmask`, `sigwait` | 전용 스레드로 동기 처리 |
| 포착 | `pthread_atfork` | `fork()` 안전화(권장: `posix_spawn`) |

---

## 2) 메모리 모델 — 데이터 레이스와 happens-before

### 2.1 데이터 레이스(금지)
- 같은 메모리에 **동기화 없이** 2개 이상 스레드가 접근(최소 1개는 쓰기) ⇒ **UB(정의되지 않음)**.  
- 해결: **뮤텍스/조건변수**, **C11 원자(atomic)**, **메모리 순서**를 정확히 사용.

### 2.2 C11 원자/메모리 오더(요지)
- `<stdatomic.h>`: `_Atomic T`, `atomic_load/store`, `atomic_fetch_add`, `atomic_compare_exchange_*`.
- 오더: `relaxed < acquire/release < acq_rel < seq_cst`
  - **생산자**: `atomic_store(..., memory_order_release)`
  - **소비자**: `atomic_load(..., memory_order_acquire)`  
    ⇒ 해당 쓰기/읽기 사이 **happens-before** 성립.

```c
#include <stdatomic.h>
typedef struct { atomic_int ready; int payload; } slot_t;

void produce(slot_t* s){
  s->payload = 42; // 일반 쓰기
  atomic_store_explicit(&s->ready, 1, memory_order_release);
}
int consume(slot_t* s){
  while (!atomic_load_explicit(&s->ready, memory_order_acquire)) { /* spin */ }
  return s->payload; // 반드시 42
}
```

> **뮤텍스/조건변수**는 lock/unlock, wait/signal 자체에 **적절한 메모리 장벽**을 내장합니다(사실상 acquire/release).

---

## 3) 동기화 원리 — 정석 패턴과 주의점

### 3.1 뮤텍스 + 조건변수(정석)
- 조건변수는 “**상태(predicate)** 를 기다릴 때” 사용.  
- **항상 `while (!predicate) pthread_cond_wait(...)`**: 스퍼리어스 웨이크업/레이스 대비.

```c
/* 유한 버퍼(생산자–소비자) — 뮤텍스+조건변수 정석 */
#include <pthread.h>
#define N 16
static int q[N], cnt=0, in=0, out=0;
static pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t cv_not_full  = PTHREAD_COND_INITIALIZER;
static pthread_cond_t cv_not_empty = PTHREAD_COND_INITIALIZER;

void put(int x){
  pthread_mutex_lock(&m);
  while (cnt==N) pthread_cond_wait(&cv_not_full, &m);
  q[in]=x; in=(in+1)%N; cnt++;
  pthread_cond_signal(&cv_not_empty);
  pthread_mutex_unlock(&m);
}
int get(void){
  pthread_mutex_lock(&m);
  while (cnt==0) pthread_cond_wait(&cv_not_empty, &m);
  int x=q[out]; out=(out+1)%N; cnt--;
  pthread_cond_signal(&cv_not_full);
  pthread_mutex_unlock(&m);
  return x;
}
```

**실전 팁**
- 타임아웃이 필요하면 `pthread_cond_timedwait` + **모노토닉(clock attr)**:
```c
pthread_condattr_t ca; pthread_condattr_init(&ca);
pthread_condattr_setclock(&ca, CLOCK_MONOTONIC);
pthread_cond_t cv; pthread_cond_init(&cv, &ca);
```

### 3.2 읽기–쓰기 락
- 읽기 위주일 때 이점. 쓰기 경합이 잦으면 오히려 느릴 수 있음.
```c
pthread_rwlock_t rw = PTHREAD_RWLOCK_INITIALIZER;
/* reader */ pthread_rwlock_rdlock(&rw); /* read */ pthread_rwlock_unlock(&rw);
/* writer */ pthread_rwlock_wrlock(&rw); /* write*/ pthread_rwlock_unlock(&rw);
```

### 3.3 세마포어(간단 카운팅/제약)
```c
#include <semaphore.h>
sem_t slots, items; // slots=N, items=0
// put: sem_wait(&slots)→enqueue→sem_post(&items)
// get: sem_wait(&items)→dequeue→sem_post(&slots)
```

### 3.4 스핀락(짧은 임계구역)
- 페이지 폴트/시스템콜/긴 루프가 있으면 **금지**. CPU 낭비.

### 3.5 배리어/원샷/TLS
```c
pthread_barrier_t b; pthread_barrier_init(&b, NULL, P);
pthread_once_t once = PTHREAD_ONCE_INIT; /* pthread_once(&once, init_fn) */
__thread int tls_var; // (GCC) 스레드 지역 저장소
```

---

## 4) 수명주기 — 생성/합류/분리/취소

### 4.1 생성–합류–분리
```c
#include <pthread.h>
#include <stdio.h>

void* worker(void* arg){ (void)arg; return (void*)42; }
int main(void){
  pthread_t t; pthread_create(&t, NULL, worker, NULL);
  void* ret; pthread_join(t, &ret);
  printf("%ld\n", (long)ret);
}
```
- **detached**: `pthread_detach(t)` 또는 생성 속성에서 분리. 결과를 join으로 받을 수 없음.

### 4.2 취소와 정리(필수 패턴)
- 취소는 기본 **지연 취소**(cancellation point에서만 반응).  
- 정리 핸들러를 반드시 두어 **락/자원 해제 보장**.

```c
#include <pthread.h>
static pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
static void cleanup(void* p){ pthread_mutex_unlock((pthread_mutex_t*)p); }
void* w(void*){
  pthread_mutex_lock(&m);
  pthread_cleanup_push(cleanup, &m);
  /* ... 취소 가능 지점 호출 가능 ... */
  pthread_cleanup_pop(1); // 1이면 cleanup 실행
  return NULL;
}
```

### 4.3 `fork()`와 스레드
- 멀티스레드에서 `fork()` 후 **자식에는 호출 스레드만** 존재. 잠긴 락은 **교착** 위험.  
- 해결: `pthread_atfork`로 잠금 해제/재획득 or **`posix_spawn()` 권장**.

---

## 5) 대표 패턴 — 스레드풀/생산자–소비자/배리어

### 5.1 스레드풀(작업 큐, 역압 포함)

```c
/* 최소 스레드풀: 교육용(오류/종료경로 축약) */
#include <pthread.h>
#include <stdlib.h>

typedef void (*job_fn)(void*);
typedef struct job { job_fn fn; void* arg; struct job* next; } job_t;

typedef struct {
  pthread_mutex_t m;
  pthread_cond_t  cv;
  job_t* head;
  int stop, n;
  pthread_t* th;
} tpool_t;

static void* worker(void* vp){
  tpool_t* p = vp;
  for(;;){
    pthread_mutex_lock(&p->m);
    while(!p->head && !p->stop) pthread_cond_wait(&p->cv, &p->m);
    if (p->stop && !p->head){ pthread_mutex_unlock(&p->m); break; }
    job_t* j = p->head; p->head = j->next;
    pthread_mutex_unlock(&p->m);
    j->fn(j->arg); free(j);
  }
  return NULL;
}
void tpool_init(tpool_t* p, int n){
  *p=(tpool_t){.m=PTHREAD_MUTEX_INITIALIZER,.cv=PTHREAD_COND_INITIALIZER,.n=n};
  p->th = calloc(n,sizeof*p->th);
  for(int i=0;i<n;i++) pthread_create(&p->th[i],NULL,worker,p);
}
void tpool_submit(tpool_t* p, job_fn fn, void* arg){
  job_t* j=malloc(sizeof* j); j->fn=fn; j->arg=arg; j->next=NULL;
  pthread_mutex_lock(&p->m); j->next=p->head; p->head=j; pthread_cond_signal(&p->cv); pthread_mutex_unlock(&p->m);
}
void tpool_shutdown(tpool_t* p){
  pthread_mutex_lock(&p->m); p->stop=1; pthread_cond_broadcast(&p->cv); pthread_mutex_unlock(&p->m);
  for(int i=0;i<p->n;i++) pthread_join(p->th[i],NULL); free(p->th);
}
```

> 실무: **MPMC 락프리 큐**, **우선순위/타임아웃**, **작업량 기반 워크 스틸링** 추가.

### 5.2 생산자–소비자(유한 버퍼)
- §3.1 예제를 그대로 다중 생산자/소비자로 확장 가능.

### 5.3 배리어 기반 map/reduce
- P개 스레드가 **부분 결과** 계산 → `pthread_barrier_wait` → 마스터 병합.

---

## 6) 안정성 — 데드록/라이브락/기아/우선순위 역전

### 6.1 데드록 4조건 & 예방
- 상호배제, 점유-대기, 비선점, 환형대기.  
- 예방:
  - **전역 락 획득 순서** 고정(예: A→B→C).
  - `trylock` + **backoff**.
  - 타임아웃 기반 감지/로그(운영 관측).

```c
/* 역순획득 예 — 교착 가능 */
pthread_mutex_t A, B;
/* T1: lock(A)->lock(B),  T2: lock(B)->lock(A) */
```

### 6.2 라이브락/기아
- 계속 양보·재시도만 하는 **라이브락**; 낮은 우선순위가 영원히 기회 못 얻는 **기아**.  
- 해결: 랜덤 백오프, 공정 락, 스케줄 정책 점검.

### 6.3 우선순위 역전
- 저우선 스레드가 락을 잡고 고우선이 대기, 중간 우선이 계속 실행되는 상황.  
- 해결: **우선순위 상속/천장** 지원 뮤텍스(플랫폼 옵션):
```c
pthread_mutexattr_t ma; pthread_mutexattr_init(&ma);
pthread_mutexattr_setprotocol(&ma, PTHREAD_PRIO_INHERIT); // 지원 OS에서만
pthread_mutex_t m; pthread_mutex_init(&m, &ma);
```

---

## 7) 성능 튜닝 — Amdahl, 거짓 공유, NUMA, 할당기

### 7.1 Amdahl’s Law
- 직렬 비율 \( \alpha \), 코어 수 \( p \)일 때:
$$
S(p)=\frac{1}{\alpha + \frac{1-\alpha}{p}}
$$
- ⇒ 임계구역 축소/공유 쓰기 제거가 **스케일**의 핵심.

### 7.2 거짓 공유(False Sharing)
- 서로 다른 변수가 **같은 캐시라인(보통 64B)** 에 있으면 각 쓰기마다 **라인 무효화**.  
- 해결: **패딩/정렬** 또는 **per-thread 로컬** 후 **reduction**.

```c
#include <stdalign.h>
#define CL 64
typedef struct { alignas(CL) long v; } padded_long;
```

### 7.3 NUMA & first-touch & 코어 고정
- NUMA에서 **처음 접근한 스레드의 노드**에 페이지가 할당(first-touch).  
- 데이터 **초기화 자체를 스레드별**로 수행해 로컬리티 확보.  
- 긴 작업은 `pthread_setaffinity_np`로 **코어 친화도** 고정이 유리.

```c
#define _GNU_SOURCE
#include <pthread.h>
#include <sched.h>
void pin_to_core(int c){
  cpu_set_t cs; CPU_ZERO(&cs); CPU_SET(c,&cs);
  pthread_setaffinity_np(pthread_self(), sizeof cs, &cs);
}
```

### 7.4 메모리 할당기
- 전역 락 기반 할당기는 경합 ↑. **jemalloc/tcmalloc** 같은 **스레드 캐시 할당기** 고려.

---

## 8) 멀티스레드에서의 신호·I/O·표준 라이브러리

### 8.1 신호 처리(전용 스레드)
- 모든 워커에서 신호를 **블록** → 전용 스레드가 `sigwait`로 **동기 처리**.

```c
#include <signal.h>
void* sigthread(void*){
  sigset_t set; sigemptyset(&set); sigaddset(&set,SIGINT); sigaddset(&set,SIGTERM);
  for(;;){ int sig; sigwait(&set,&sig); /* 안전한 종료 루틴 */ }
  return NULL;
}
int main(){
  sigset_t set; sigemptyset(&set); sigaddset(&set,SIGINT); sigaddset(&set,SIGTERM);
  pthread_sigmask(SIG_BLOCK,&set,NULL);
  pthread_t st; pthread_create(&st,NULL,sigthread,NULL);
  /* 나머지 워커 생성 */
}
```

### 8.2 I/O와 취소 지점
- 많은 블로킹 I/O는 **취소 지점**. 취소를 쓴다면 **정리 핸들러**로 자원 반납 보장.

### 8.3 stdio/라이브러리
- `printf` 등은 내부 락으로 thread-safe지만, **논리적 원자성**은 보장 안 됨(줄 단위 flush 권장).  
- 재진입 버전(`strtok_r`, `asctime_r`) 사용.

---

## 9) 디버깅/검증 — TSan, Helgrind, gdb, 로깅

- **ThreadSanitizer**: `-fsanitize=thread` 로 레이스/락 순서 점검.  
- **Helgrind/DRD(Valgrind)**: 락/레이스 분석.  
- **gdb**: `info threads`, `thread apply all bt`, `set scheduler-locking on`.  
- **로그**: 스레드 ID 포함, 대기시간/락 획득/해제 지점 기록.

---

## 10) 실전 예제 묶음

### 10.1 취소 안전한 큐 pop (cleanup 보장)

```c
typedef struct node { int v; struct node* next; } node_t;
typedef struct { pthread_mutex_t m; pthread_cond_t cv; node_t* head; } q_t;

int q_pop(q_t* q, int* out){
  pthread_mutex_lock(&q->m);
  void cleanup(void* p){ pthread_mutex_unlock((pthread_mutex_t*)p); }
  pthread_cleanup_push(cleanup, &q->m);
  while(!q->head) pthread_cond_wait(&q->cv, &q->m);  // 취소 지점
  node_t* n = q->head; q->head = n->next;
  *out = n->v; free(n);
  pthread_cleanup_pop(1); // unlock 보장
  return 0;
}
```

### 10.2 robust mutex(프로세스 크래시 복구 패턴)
- 리눅스 glibc: **robust** 뮤텍스에서 소유자 사망 시 `EOWNERDEAD` 반환, 일관성 복구 후 `pthread_mutex_consistent`.

```c
pthread_mutexattr_t a; pthread_mutexattr_init(&a);
pthread_mutexattr_setrobust(&a, PTHREAD_MUTEX_ROBUST);
pthread_mutex_t m; pthread_mutex_init(&m,&a);

int lock_and_fix(){
  int r = pthread_mutex_lock(&m);
  if (r==EOWNERDEAD){ /* 공유 상태 복구 */ pthread_mutex_consistent(&m); }
  else if (r!=0){ return r; }
  return 0;
}
```

### 10.3 원자 카운터(통계/모니터링용, relaxed)

```c
#include <stdatomic.h>
atomic_long hits=0;
void on_event(){ atomic_fetch_add_explicit(&hits, 1, memory_order_relaxed); }
long snapshot(){ return atomic_load_explicit(&hits, memory_order_relaxed); }
```

---

## 11) 운영 체크리스트(요약)

- [ ] **데이터 레이스 금지**: 락/원자/불변·복사-갱신 중 하나로 보호  
- [ ] **조건변수는 while**: 상태 재확인 & 스퍼리어스 대비  
- [ ] **락 순서** 규약 문서화, `trylock`/타임아웃/백오프 전략  
- [ ] **취소 안전**: cleanup으로 락/자원 해제 보장  
- [ ] **거짓 공유 방지**: 패딩/정렬, per-thread → reduction  
- [ ] **NUMA/affinity**: first-touch 초기화 + 코어 고정 검토  
- [ ] **스레드풀**: 생성/파괴 오버헤드 제거, 역압으로 과부하 제어  
- [ ] **fork 대신 posix_spawn**(필요 시 `pthread_atfork`)  
- [ ] **신호는 전용 스레드에서 `sigwait`**  
- [ ] **할당기/TSan/Helgrind/gdb**로 성능·정확성 검증

---

## 12) 부록 — 벤치마킹 골격 & 타임 유틸

```c
#include <time.h>
static double now_sec(void){
  struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts);
  return ts.tv_sec + ts.tv_nsec*1e-9;
}
```

```bash
# 컴파일 권장 플래그
gcc -O3 -march=native -pthread -Wall -Wextra file.c -o app
# 레이스 탐지(Clang/GCC)
clang -O1 -g -fsanitize=thread file.c -lpthread -o app_tsan
```

---

## 13) 한 줄 결론

쓰레드 동시성의 본질은 **공유 데이터를 언제‧어떻게 안전하게 다룰지**에 있다.  
**뮤텍스/조건/원자와 happens-before**를 바르게 적용하고, **데드록‧취소‧신호**의 함정을 피해,  
**거짓 공유·NUMA·락 경합**을 줄이는 설계(로컬→reduction, first-touch, affinity)를 더하면  
실전에서도 **예측 가능하고 빠른** 멀티스레드 프로그램을 만들 수 있다.