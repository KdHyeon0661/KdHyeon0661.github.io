---
layout: post
title: 웹해킹 - SRI
date: 2025-10-10 18:25:23 +0900
category: 웹해킹
---
# 22. SRI(Subresource Integrity)
**— 왜 쓰는가 · 어떻게 쓰는가 · 실무에서 틀리기 쉬운 지점(특히 `crossorigin`) · 도입/배포 자동화 · 디버깅/테스트 · 프레임워크·CDN 연동 예제**

> ⚠️ 목적  
> 외부(CDN·서드파티)에서 불러오는 **스크립트/스타일**이 변조되었을 때,  
> 브라우저가 **해시 검증**으로 차단하도록 하는 표준이 **Subresource Integrity(SRI)** 입니다.

---

## 0) 한눈에 보기 (Executive Summary)

- **문제**: CDN/서드파티 스크립트가 해킹·오염되면 **모든 소비자 사이트가 광범위 XSS**에 노출됩니다.
- **해결(핵심)**: `<script|link ... integrity="sha384-<base64>" crossorigin="anonymous">`
  - 브라우저는 **응답 바이트의 해시**가 `integrity` 값과 일치할 때만 실행/적용합니다.
  - **불일치 시**: 네트워크 성공이어도 **그 리소스는 “실패”로 간주되어 미적용**(콘솔에 에러).
- **꼭 함께**: **`crossorigin="anonymous"`**(대부분의 CDN 필요) + **자체 호스팅 또는 고정 버전**.

---

## 1) SRI의 동작 원리 (정확히 이해하기)

- `integrity` 속성은 하나 이상의 **알고리즘+해시**를 공백으로 나열합니다.  
  지원 알고리즘: `sha256`, `sha384`, `sha512` (권장: **sha384** — 보안·호환성 균형)
- 브라우저는 다운로드한 **리소스 본문(표현)**에 대해 해시를 계산하여 `integrity`와 비교합니다.
  - **압축(gzip, br)·전송 인코딩**은 해시에 **영향을 주지 않습니다.**(브라우저가 **디코딩된 콘텐츠** 기준으로 검사)
- **불일치**면:
  - `<script>`: **실행되지 않음** (스크립트가 전혀 평가되지 않음)
  - `<link rel="stylesheet">`: **적용되지 않음**
  - 콘솔에 `Failed to find a valid digest in the 'integrity' attribute for resource ...` 경고가 남음.
- **여러 해시**를 넣으면, 그 중 **하나라도 일치**하면 통과합니다(멀티 버전 전환용).

> 포인트: SRI는 **“정확히 이 바이트여야 한다”**는 **완전 매칭** 보장 장치입니다.  
> 변경(패치·광고 삽입·A/B 코드 주입 등)이 조금이라도 있으면 **실패**해야 **정상**입니다.

---

## 2) 가장 많이 틀리는 부분: `crossorigin`

### 2.1 왜 필요한가?
- **동일 출처** 리소스는 문제 없음.
- **교차 출처**(CDN 등) 리소스를 SRI로 검증하려면, 브라우저가 **실제 바이트**를 읽어 해시를 계산해야 합니다.  
  그런데 **CORS 미허용(no-cors)** 응답은 **opaque(불투명)** 으로 간주되어 **검증 불가 → SRI 실패**가 됩니다.
- 해결: **`crossorigin="anonymous"`** 를 지정하고, **CDN이 CORS 응답 헤더**(`Access-Control-Allow-Origin: *` 또는 귀사 도메인) 를 내주도록 하세요.

### 2.2 언제 `use-credentials`?
- 쿠키·인증이 필요한 **특수 케이스**에서만(`Access-Control-Allow-Credentials: true` + 특정 Origin).  
- 보통 **CDN 정적 자산**엔 **필요 없습니다.**(가능하면 쓰지 마세요.)

---

## 3) 최소 예제 (정석)

### 3.1 스크립트 (CDN)

```html
<!-- CDN가 CORS 허용을 내준다는 전제 -->
<script
  src="https://cdn.example.com/libs/awesome@1.2.3/awesome.min.js"
  integrity="sha384-<여기에-Base64-해시>"
  crossorigin="anonymous">
</script>
```

### 3.2 스타일 (CDN)
```html
<link
  rel="stylesheet"
  href="https://cdn.example.com/libs/awesome@1.2.3/awesome.min.css"
  integrity="sha384-<여기에-Base64-해시>"
  crossorigin="anonymous">
```

### 3.3 자체 호스팅(서버에서 제공)
```html
<!-- same-origin이면 CORS 필요 없음. 그래도 SRI는 동작 -->
<script
  src="/static/vendor/awesome.min.js"
  integrity="sha384-<base64-hash>">
</script>
```

> **권장**: **자체 호스팅** + **버전 고정 파일명**(예: `/static/vendor/awesome-1.2.3.min.js`)  
> CDN을 쓰더라도 **버전이 포함된 정적 경로**를 사용하세요(변조·롤링 업데이트 리스크 감소).

---

## 4) SRI 해시 만들기 (수동/자동)

### 4.1 OpenSSL (CLI)
```bash
# sha384 해시(Base64) 생성
openssl dgst -sha384 -binary awesome.min.js | openssl base64 -A
# => Wv5s...tQ=  (예시)
# integrity="sha384-Wv5s...tQ="
```

### 4.2 Node.js (스크립트)
```js
import { createHash } from "node:crypto";
import { readFileSync } from "node:fs";

const buf = readFileSync("awesome.min.js");
const hash = createHash("sha384").update(buf).digest("base64");
console.log(`integrity="sha384-${hash}"`);
```

### 4.3 Python
```python
import hashlib, base64
data = open("awesome.min.css","rb").read()
h = hashlib.sha384(data).digest()
print('integrity="sha384-{}"'.format(base64.b64encode(h).decode()))
```

---

## 5) 빌드/배포 자동화 (Webpack · Vite · HTML 빌더)

### 5.1 Webpack: `webpack-subresource-integrity`
> 번들 산출물에 **SRI 해시를 자동 추가**하고, **html 템플릿**에도 `integrity`를 삽입.

```js
// webpack.config.js
const SriPlugin = require('webpack-subresource-integrity');

module.exports = {
  output: {
    filename: '[name].[contenthash].js',
    crossOriginLoading: 'anonymous', // <-- SRI와 궁합
  },
  plugins: [
    new SriPlugin({
      hashFuncNames: ['sha384'],       // sha384 권장
      enabled: process.env.NODE_ENV === 'production',
    }),
  ],
};
```

HTML 템플릿(예: HtmlWebpackPlugin)을 쓰면, 빌더가 `<script>`/`<link>`에 `integrity` + `crossorigin`을 자동삽입합니다.

### 5.2 정적 사이트 빌더(예: 자체 스크립트)
- 배포 단계에서 산출물 디렉토리를 순회하며 `.js/.css`에 대해 해시 생성 →  
  템플릿의 `<script src>`/`<link href>` 노드를 찾아 **`integrity` 추가**.

---

## 6) CDN·서버 설정: CORS 헤더 (SRI 성공 조건)

### 6.1 Nginx (정적 오리진)
```nginx
location /libs/ {
  add_header Access-Control-Allow-Origin "*" always;
  # 폰트/스타일 호환 대비
  add_header Access-Control-Allow-Headers "*" always;
  add_header Access-Control-Allow-Methods "GET, HEAD, OPTIONS" always;
}
```

### 6.2 S3/CloudFront
- **CloudFront Response Headers Policy**로 `Access-Control-Allow-Origin: *` 추가.
- 폰트/스타일은 **CORS 필수**인 경우가 많습니다(특히 다른 오리진에서 사용 시).

---

## 7) 실무 패턴 & 앤티패턴

### 7.1 권장 패턴
- **버전 고정 경로**: `/vendor/lib-1.2.3.min.js` (패치 시 경로 변경 → SRI 값도 함께 바꿈)
- **여러 해시 동시 표기**(점진 전환 시):
  ```html
  <script src="..." integrity="sha384-abc sha512-def" crossorigin="anonymous"></script>
  ```
- **동적 로더도 SRI**:
  ```html
  <script>
    const s = document.createElement('script');
    s.src = 'https://cdn.example.com/lib.min.js';
    s.integrity = 'sha384-...';
    s.crossOrigin = 'anonymous';
    document.head.appendChild(s);
  </script>
  ```

### 7.2 피해야 할 것
- **버전 없는 URL**(“latest”) → CDN이 파일을 바꾸면 **SRI 즉시 깨짐**(사이트가 갑자기 먹통)
- **`crossorigin` 누락** + CDN CORS 미허용 → **항상 실패**(opaque 응답)
- **빌드 시 해시 후, 배포에서 파일을 다시 최적화/난독화** → 해시 불일치
- **SRI만 믿고 CSP 미구현**: 인라인 스크립트는 여전히 공격면. **CSP**로 보조(아래 §10)

---

## 8) 실패 시 대처(UX / 폴백)

- SRI 실패는 **네트워크 오류처럼 취급**됩니다.
- **`onerror` 폴백** 예(다른 CDN로 재시도):
  ```html
  <script
    src="https://cdn1.example.com/lib-1.2.3.min.js"
    integrity="sha384-AAA..."
    crossorigin="anonymous"
    onerror="loadFallback()">
  </script>
  <script>
    function loadFallback() {
      var s = document.createElement('script');
      s.src = 'https://cdn2.example.com/lib-1.2.3.min.js';
      s.integrity = 'sha384-AAA...'; // 동일 파일의 동일 해시
      s.crossOrigin = 'anonymous';
      document.head.appendChild(s);
    }
  </script>
  ```
- **중요**: 폴백도 **같은 파일**을 가리켜야 하며 **해시는 동일**해야 합니다.

---

## 9) 테스트/디버깅 체크리스트

1) **콘솔 확인**: 해시 불일치/opaque 응답(=CORS 문제) 시 콘솔 에러 발생.  
2) **네트워크 패널**: Response Headers에 CORS 헤더가 있는지 확인.  
3) **해시 검증**: 로컬에서 파일을 받아 같은 해시가 나오는지 `openssl`로 검증.  
4) **배포 파이프라인**: (1) 번들 생성 → (2) 해시 생성/주입 → (3) CDN 업로드 **순서** 보장.  
5) **압축/후처리**: CDN/프록시가 **내용을 바꾸는 최적화**(ex. HTML/JS 재압축/난독화)를 하지 않는지 확인.

---

## 10) CSP와의 관계(보조 장치)

- **CSP(Content Security Policy)** 는 **어디서 스크립트를 불러올 수 있는지**를 제어합니다.
- SRI는 **가져온 리소스의 무결성**을 보장합니다.  
- 실무 권장:
  - `script-src 'self' https://신뢰CDN ...; object-src 'none'; base-uri 'self'`
  - 인라인 스크립트를 쓰면 **nonce/해시 기반 CSP** 도입.
  - (과거의) `require-sri-for script style` 은 **브라우저 지원이 제한적**이므로, **빌드 타임 검사**로 보완하세요.

---

## 11) 프레임워크 연동 메모

- **React/Vue/Next/Nuxt**: 빌드 결과 HTML에 **외부 스크립트**가 남는 경우에만 SRI 적용 대상.  
  앱 번들 자체는 보통 **same-origin**이므로 SRI보다 **CSP/서버 무결성**이 우선.
- **SSR + 외부 위젯**(결제·채팅 등): 공급자가 SRI를 제공하면 그대로 사용.  
  제공하지 않으면 **정확 버전 파일**을 **자체 호스팅**하는 방안을 검토(라이선스 확인).

---

## 12) 예제: 페이지에 SRI 일괄 적용(간단 스캐너)

> 빌드 아웃풋 HTML을 읽어서, 외부 `src/href`가 있으면 파일을 내려받아 해시를 계산하고 `integrity`/`crossorigin`을 삽입합니다.  
> (데모 수준 코드 — 실무에선 캐시·에러 핸들링·동일 URL 중복처리 등을 보강)

```js
// tools/apply-sri.js
import fs from 'node:fs';
import path from 'node:path';
import crypto from 'node:crypto';
import fetch from 'node-fetch';
import { JSDOM } from 'jsdom';

function b64sha384(buf) {
  return 'sha384-' + crypto.createHash('sha384').update(buf).digest('base64');
}

async function hashRemote(url) {
  const res = await fetch(url, { method: 'GET' });
  if (!res.ok) throw new Error(`Fetch fail ${url} ${res.status}`);
  const buf = Buffer.from(await res.arrayBuffer());
  return b64sha384(buf);
}

async function main(file) {
  const html = fs.readFileSync(file, 'utf8');
  const dom = new JSDOM(html);
  const { document } = dom.window;

  const nodes = [
    ...document.querySelectorAll('script[src]'),
    ...document.querySelectorAll('link[rel="stylesheet"][href]')
  ];

  for (const el of nodes) {
    const url = el.getAttribute('src') || el.getAttribute('href');
    if (!url) continue;
    // same-origin 경로(/로 시작)는 건너뜀(옵션)
    const isExternal = /^https?:\/\//i.test(url);
    if (!isExternal) continue;

    const integrity = await hashRemote(url);
    el.setAttribute('integrity', integrity);
    el.setAttribute('crossorigin', 'anonymous');
  }

  fs.writeFileSync(file, dom.serialize());
  console.log(`SRI applied: ${file}`);
}

const file = process.argv[2] || path.join('dist', 'index.html');
main(file).catch(e => { console.error(e); process.exit(1); });
```

---

## 13) 케이스 스터디: 폰트/아이콘, 프리로드, Service Worker

- **웹폰트** (`<link rel="stylesheet">`→폰트 참조):  
  - **스타일 시트**에 SRI를 적용할 수 있습니다.  
  - 그러나 CSS 안에서 불러오는 **폰트 파일(WOFF2)** 자체에는 SRI가 적용되지 않습니다.  
  - 대신 **CSP `font-src`**와 **CORS 허용**으로 통제하세요.
- **preload** (`<link rel="preload" as="script/style">`):  
  - 사양상 `integrity` 속성을 쓸 수 있습니다(브라우저 지원에 유의).  
  - **본 태그에도 동일한 `integrity`**를 **반드시** 반복 지정하세요(프리로드만으론 부족).
- **Service Worker**:  
  - SW가 응답을 변조하면 SRI가 **불일치**로 **차단**됩니다(안전).  
  - SW 캐시에 이미 있는 파일이 변경되면 **SRI 실패** → 캐시 무효화/버전 관리 필요.

---

## 14) 운영 체크리스트

- [ ] 외부 스크립트/스타일에 **모두 SRI** 적용, **sha384** 권장  
- [ ] **CDN CORS 허용**(대개 `*`) + `<script|link crossorigin="anonymous">`  
- [ ] **버전 포함 경로** 사용(파일 바뀌면 경로도 바뀜)  
- [ ] 빌드/배포에서 **해시 생성 → HTML 주입 → 업로드** 순서 보장  
- [ ] 배포 후 **샘플 페이지 로드 자동 테스트**(콘솔 에러 탐지)  
- [ ] 중요한 위젯은 **자체 호스팅** 검토 + CSP로 보조  
- [ ] 폴백 경로(2nd CDN) 준비 시 **동일 파일** + **동일 SRI**  
- [ ] 변경 감지(파일 핑거프린트)와 모니터링(콘솔 로그 수집/에러 리포팅)

---

## 15) “막혀야 정상” 테스트

### 15.1 해시 일부러 틀리기
```html
<script src="/static/vendor/awesome.min.js"
        integrity="sha384-AAAAAAAA..."
        crossorigin="anonymous"></script>
<!-- 기대: 콘솔에 integrity 오류, 스크립트 미실행 -->
```

### 15.2 `crossorigin` 제거
- CDN이 `Access-Control-Allow-Origin`을 주지만 `crossorigin`을 빼면 **opaque**가 되어  
  일부 환경에서 **검증 불가 → 실패**. 브라우저 콘솔/네트워크로 확인.

### 15.3 배포 파이프라인 검증(예: CI)
- HTML에 외부 `src/href`가 있는데 `integrity`가 비어 있으면 **실패**시키는 린트.

간단 린터 예:
```js
// tools/lint-sri.js
import fs from 'node:fs';
import { JSDOM } from 'jsdom';
const html = fs.readFileSync('dist/index.html','utf8');
const { document } = new JSDOM(html).window;
const bad = [...document.querySelectorAll('script[src],link[rel="stylesheet"][href]')]
  .filter(el => !el.getAttribute('integrity'));
if (bad.length) {
  console.error('SRI missing on:', bad.map(n => n.outerHTML).join('\n'));
  process.exit(1);
}
```

---

## 16) FAQ

- **Q. gzip/브로틀리 압축이 바뀌면 해시가 깨지나요?**  
  A. **아니요.** SRI는 **디코딩된 콘텐츠 기준**으로 검증합니다. 동일 파일이면 압축 방식이 달라도 통과합니다.

- **Q. 라이브러리 패치(보안 업데이트)로 파일이 바뀌는데, SRI가 계속 깨집니다.**  
  A. 그게 정상입니다. **버전 고정 파일**로 배포하고, **업데이트 시 SRI 해시도 함께 갱신**하세요.

- **Q. 인라인 스크립트에 SRI를 적용할 수 있나요?**  
  A. 불가합니다. 인라인은 **CSP 해시/nonce**를 쓰세요.

- **Q. 여러 해시를 넣으면 성능/보안에 문제 없나요?**  
  A. 없습니다. 하지만 **관리 복잡도**가 늘 수 있으니 전환 기간에만 사용을 권장합니다.

---

## 17) 마무리

SRI는 **“외부 리소스를 불신”**하는 시대의 **마지막 안전장치**입니다.  
핵심은 **정확한 해시** + **CORS 설정과 `crossorigin` 일치** + **버전 고정 경로**입니다.  
여기에 **CSP**와 **빌드 자동화**를 붙이면, **광범위 XSS** 리스크를 실무적으로 크게 줄일 수 있습니다.