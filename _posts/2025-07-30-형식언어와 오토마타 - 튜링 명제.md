---
layout: post
title: 형식언어와 오토마타 - 튜링 명제
date: 2025-07-30 19:20:23 +0900
category: 형식언어와 오토마타
---
# 튜링 명제(Church–Turing Thesis)

> **핵심 요약**
> - “**효과적으로 계산 가능**(effectively calculable)”한 모든 함수는 **튜링 기계**로 계산 가능하며, **람다 계산(λ-calculus)**, **μ-재귀함수(μ-recursive)**, **레지스터 머신/RAM**, **Post 시스템** 등 다른 모델로도 **동일한 경계**를 이룬다는 **철학적 주장**이 바로 **튜링 명제**다.
> - 명제는 **정리**가 아니라, **자연적 직관**과 **형식 모델** 사이의 **일치 가설**이다.
> - **확장 명제(ECT)** 는 “효율(다항 시간)”까지 포함해 모든 ‘합리적’ 계산이 확률적 튜링 기계로 **폴리오버헤드** 내 모사된다는 주장인데, **양자 계산**(BQP)이 **도전**을 제기한다.
> - 실무적으로는 “언어/머신 다양성에도 **무엇을 계산할 수 있는가**는 같고, 차이는 **효율**과 **표현 양식**에 있다”는 인식으로 이어진다.

---

## 고전 **튜링 명제**(Computability Thesis)

- **비형식적 왼편(직관)**:
  “**효과적 계산**”이란, 유한한 규칙에 따라 기호를 조작하여 입력(자연수/유한 문자열)에 대해 **유한 시간** 안에 출력을 내는 **절차**가 존재한다는 것.

- **형식적 오른편(모델)**:
  이와 같은 모든 계산은 **튜링 기계(Turing machine)** 로 **정확히** 포착된다(= **튜링 계산 가능성**, T-computability).

- **동등한 진술** — 서로 독립적으로 정의된 모델들이 **같은 계산 가능성의 경계**를 준다:
  $$
  \text{Turing} \;\equiv\; \lambda\text{-calculus} \;\equiv\; \mu\text{-recursive} \;\equiv\; \text{Post 시스템} \;\equiv\; \text{레지스터/RAM} \;\equiv\; \cdots
  $$

> **왜 정리가 아닌가?**
> “효과적 계산”은 본질적으로 **직관적 개념**이라 수학 안에서 **정의-정리**로 증명할 대상이 아니다.
> 대신 **다중 모델의 수렴**, **강건성(robustness)**, **광범위한 시뮬레이션 가능성**이 강한 **증거**를 형성한다.

---

## 역사 히스토리 — 1930년대의 수렴

- **Church(1936)**: **람다 계산(λ-calculus)** 로 계산 가능성을 제안.
- **Turing(1936)**: **튜링 기계** 제안 — “인간 계산자”의 기계적 절차를 치밀하게 형식화.
- **Kleene, Post** 등: **μ-재귀함수**·**문자열 재작성** 등 **다른 모델** 정교화 및 **상호 등가성** 확립.
- 이후 **Markov**, **Minsky(레지스터 머신)**, **RAM** 등 현대적 모델도 같은 경계에 합류.

---

## 대표 **등가 모델**과 **등가성 스케치**

### λ-계산 ↔ 튜링

- **λ→TM**: λ항을 **SKI** 또는 **De Bruijn index**로 표준화 → **구성적 재작성 규칙**을 **TM 전이표**로 컴파일(β-감소를 step-by-step 모사).
- **TM→λ**: 테이프·상태를 λ로 **자료구조(Church encoding)** 화하고, “한 단계 전이”를 **λ함수**로 표현 → β-감소로 **TM 실행을 에뮬**.

### μ-재귀함수 ↔ 튜링

- **기초함수**: 영 함수 \(Z(x)=0\), 후행자 \(S(x)=x+1\), 투사 \(\pi_i^n\).
- **연산자**: 합성, **초등 재귀**(primitive recursion), **μ-연산(최소화)**.
- **정리**: **부분 μ-재귀함수** = **튜링 계산 가능 부분함수**.

> **Kleene 정상형 정리(스케치)**
> 모든 계산 가능한 부분함수 \(f\) 에 대해
> $$
> f(x) \;=\; U\big(\underbrace{S(e,x)}_{\text{s-m-n}},\, x\big)
> $$
> 형태(보편함수 \(U\), 지수변환 \(S\))로 쓸 수 있다 → **보편성**과 **프로그램 변환**의 근거.

---

## 강건성(robustness) — “조금 바꿔도 경계는 동일”

- **Stay 이동, 다중 테이프/트랙/헤드, 일방/양방 테이프, 오프라인 입력** 등 작은 변형은 **표현력 불변**.
- **시간/공간**에 **상수~다항 오버헤드**만 증가할 뿐, **RE(재귀적 열거)/REC(결정 가능)** 경계는 동일.

> 이 강건성이 곧 “**현실적 계산 장치**가 결국 **같은 경계**에 갇힌다”는 튜링 명제의 **설득력**.

---

## **확장(강한) 튜링 명제(ECT)** — 효율까지?

> **ECT**: “모든 ‘합리적’ 계산 모델은 **확률적 튜링 기계(PTM)** 로 **다항 시간 오버헤드** 이내에서 모사 가능.”

- **양자 계산**:
  - **BQP**(양자 다항 시간)이 **BPP**(확률적 다항 시간)보다 **강할 가능성**이 크다고 여겨짐(Shor 등).
  - 그럴 경우 **ECT(효율 동치)** 는 **일반적으로 성립하지 않을** 수 있음.
- **결론**: **고전 CTT(계산 가능성 경계)** 는 안전. **ECT(효율 동치)** 는 **열린 논의**.

---

## **물리적** 튜링 명제(Physical CTT) & 공리화

- **물리적 CTT**: “물리적으로 실현 가능한 모든 계산은 **튜링**으로 모사 가능”.
- **Gandy의 공리화**: 불연속성, 지역성, 유한 정보량/속도 등 **물리적으로 그럴듯한 공리**를 만족하는 장치는 **튜링 경계**를 넘지 못함(정리).
- **ASM(추상상태기계)**, **Deutsch 원리**: 알고리즘/물리 공리에서 **보편성**을 정식화하려는 시도.

---

## **초튜링(Hypercomputation)** 논의(개관)

- **오라클 TM**: HALT 오라클 등 “초능력” 가정 → **정의상** CTT 밖.
- **Malament–Hogarth**(상대론), **연속 모델(무한 정밀)**, **혼돈 아날로그** 등:
  소음·유한 정밀·자원 제한·초기조건 인코딩 문제로 **물리적 실현성**에 큰 의문.
- 요약: **흥미로운 이론 실험**이나, 현실 물리 전제하에 **CTT를 깨뜨린 사례는 없음**.

---

## 명제가 주는 **실질적 함의**

1. **언어/머신 동치성**: Python·C·Haskell·RAM·레지스터 머신·TM은 **무엇을 계산할 수 있는가**에서 동치.
2. **한계 인식**: **정지 문제**, **Rice 정리**(비자명 의미론적 성질은 비결정) 등 **자동화 불가능**의 경계.
3. **복잡도와의 분업**: 가능/불가능(CTT) 경계 내에서 **얼마나 빠른가**(P, NP, PSPACE, BQP…)는 **복잡도 이론**의 과제.
4. **보편성**: **UTM/바이트코드/VM** — “프로그램=데이터” 패러다임의 이론적 토대.

---

## **예제 중심** 미니 교실 — 세 모델로 **같은 함수** 계산하기

### 목표 함수: 최대공약수 **gcd(m,n)**

#### (A) μ-재귀 스타일(스케치)

- 기본 연산: 뺄셈(반복 감소), 비교(0?, ≤), 나머지.
- **유클리드**:
  $$
  \mathrm{gcd}(m,n) \;=\;
  \begin{cases}
  m & (n=0)\\
  \mathrm{gcd}(n,\; m\bmod n) & \text{otherwise}
  \end{cases}
  $$
- μ-연산으로 “나머지가 0이 되는 가장 큰 수”를 찾거나, primitive recursion으로 **반복**.

#### (B) λ-계산(의사 코드; Church 인코딩 개념)

```haskell
-- 의사 λ: 숫자, 쌍, 비교, 뺄셈이 Church 인코딩으로 주어졌다고 가정
gcd = Y (\self m n ->
  IF (isZero n)
     m
     (self n (mod m n)))
```
- 실제 λ로는 `Y`(고정점), `IF`, `mod` 등 모든 조각을 Church 인코딩으로 구현 가능(다만 장황).

#### (C) 레지스터 머신(URM/RAM) 의사 코드

```
# R0 <- m, R1 <- n

LOOP:
  JZ R1, DONE            # if n == 0 -> done
  R2 <- R0 MOD R1        # 바이트코드 라이브러리 루틴(반복 뺄셈)
  R0 <- R1
  R1 <- R2
  JMP LOOP
DONE:
  HALT (answer in R0)
```
- 이 URM/RAM 프로그램은 **TM 전이표**로 기계적으로 컴파일 가능 → **튜링 계산 가능**.

> **정리 포인트**: 세 모델 모두 **동일 함수**를 계산. 표현과 효율은 달라도 **계산 가능성**은 동일.

---

## **보편성·자기참조**를 보여주는 예제

### **도베일링(dovetailing)** — “모든 프로그램을 조금씩”

모든 프로그램 \(P_i\) 와 입력 \(x_i\) 를 사전식으로 열거하고, 각자를 1스텝씩 **라운드로빈** 실행:
```python
# 개념 스니펫(설명용)

def universal_dovetailer(programs_inputs):
    # programs_inputs: [(P0,x0), (P1,x1), ...] 무한열거(이론적)
    layers = []
    step = 0
    while True:
        # 새로 유입된 (Pi,xi)를 한 겹에 추가
        while len(layers) <= step:
            layers.append([])
        # 레벨 ≤ step 에 있는 모든 실행을 한 스텝씩
        for lvl in range(step+1):
            for run in layers[lvl]:
                run.step()  # 한 스텝 실행
        step += 1
```
- 멈추는 실행은 **언젠가 결과가 관찰**된다 → **RE(재귀적 열거)** 개념의 핵심 직관.

### **재귀정리(고정점)** 감각 — “퀸(quine)” 예

```python
# 파이썬 퀸(자기 자신의 소스 출력) — 자기참조/고정점의 직관적 예

s = 's = %r\nprint(s%%s)'
print(s%s)
```
- 이 직관은 **재귀정리**: “프로그램을 입력으로 받는 변환”에 대해 **자기 자신의 코드**를 **내장**하는 고정점이 항상 존재.

---

## **정지 문제·Rice 정리** 간단 실험(개념 코드)

### “정지 여부” 판별기가 **없음을** 보이는 고전 귀류(의사 코드)

```python
def HALTS(code, x) -> bool:
    ... # 가정: 완전한 정지 판정기

def paradox(code):
    # code를 입력으로 받은 자신의 행동을 뒤집는 장치
    if HALTS(code, code):
        while True: pass  # 무한루프
    else:
        return "halt"

# paradox를 paradox에 넣으면?
# HALTS가 참이면 루프, 거짓이면 종료 → 모순

```

### Rice — “의미론적 비자명 성질은 비결정”

- 예: “프로그램이 어떤 입력에서 **정확히 100을 출력**하는가?” → **비결정**(의미론적·비자명).
- **튜링 명제**는 이런 한계를 **모든 ‘효과적 계산’ 패러다임에 공통**인 경계로 이해하게 한다.

---

## **확장 명제(ECT)** ↔ **양자 계산**(짧은 가이드)

- **ECT 주장**: “합리적” 계산은 PTM로 **poly** 오버헤드에 모사.
- **양자 우위 사례**(정황): **Shor**(소인수분해), **HHL**(선형시스템), **위상적 이점** 실험 등 →
  **BQP ≠ BPP?** 가설이 유력(엄밀한 증명은 미해결).
- **요지**: 고전 **명제(가능/불가능)** 는 영향 없음. **효율 동치**는 **논쟁 중**.

---

## 물리적 모델 & 초튜링 주장의 **현실성 점검 체크리스트**

- [ ] 무한 정밀(실수) 요구? → **물리 노이즈/양자 불확정**과 **정보량 한계** 고려.
- [ ] 무한 시간/에너지/속도 가정? → **자원 유한성** 위배.
- [ ] 초기조건에 “무한 정보” 내장? → 사실상 **오라클**.
- [ ] 지역성/유한 전파 속도 준수? → **Gandy 공리** 위반 시 **현실성 낮음**.

---

## 자주 하는 **질문/오해**

- **Q. CTT가 P=NP를 말해주나?**
  **A. 아니오.** CTT는 “가능/불가능” 경계. P vs NP는 **효율** 문제.

- **Q. 양자가 CTT를 깨나?**
  **A. 고전 CTT는 안전.** 양자는 **효율(ECT)** 에 도전 가능.

- **Q. 실수 기반 연산이 초튜링?**
  **A. 무한 정밀을 전제하면 이론적으로 강하지만, 물리적으로 **불안정/비현실**.

- **Q. ‘새 언어 X’는 파이썬보다 계산적으로 강한가?**
  **A. 아니오(일반적으로).** 튜링 완전이라면 **동일 경계**. 차이는 **표현성·안전성·생태계·성능**.

---

## 학습/연구 **실습 과제** (스스로 해보기)

1. **λ→TM 컴파일 스케치**: SKI 변환 후, `K x y = x`, `S x y z = x z (y z)` 의 **재작성 규칙**을 **TM 전이**로 코딩하라.
2. **μ-재귀로 덧셈·곱셈**:
   - \( \mathrm{add}(x,0)=x,\; \mathrm{add}(x,S(y))=S(\mathrm{add}(x,y)) \)
   - \( \mathrm{mul}(x,0)=0,\; \mathrm{mul}(x,S(y))=\mathrm{add}(x,\mathrm{mul}(x,y)) \)
3. **도베일링 열거기**: 자연수 순서로 `(코드,입력)`을 나열하고 **라운드로빈**으로 스텝 실행하는 **미니 인터프리터**를 만들라.
4. **Rice 체감**: “어떤 프로그램이 모든 입력에 대해 0을 출력하는가?” 판정기가 존재한다고 가정하고 **모순**을 구성하라.

---

## 더 깊이: 수학적 정리 몇 가지(스케치)

- **Kleene s-m-n 정리**:
  $$\exists\ s\ \forall e,x,y:\ \varphi_e(x,y)=\varphi_{s(e,x)}(y)$$
  → “프로그램의 일부 인자를 **고정**해 새 프로그램을 **합성**” 가능(부분평가).

- **재귀정리(고정점)**:
  임의의 전체 계산 가능한 변환 \(F\) 에 대해
  $$\exists e:\ \varphi_e=\varphi_{F(e)}$$
  → **자기참조** 프로그램 구성(퀸, 자기복제자 등).

- **Rice 정리**:
  “부분함수의 의미에 대한 비자명 성질”은 **결정 불가능**.

---

## **실용 예제 코드** 모음

> 아래 코드는 “모델 간 교차”를 눈으로 확인하기 위한 **학습용** 스니펫이다. (개념/교육 목적)

### μ-재귀 감각: primitive recursion & μ (파이썬 의사)

```python
# 기초함수

def Z(x): return 0
def S(x): return x + 1
def proj2_1(x, y): return x

# primitive recursion: add

def add(x, y):
    if y == 0: return x
    return S(add(x, y-1))

# primitive recursion: mul

def mul(x, y):
    if y == 0: return 0
    return add(x, mul(x, y-1))

# μ-연산: 최소의 t such that P(t)=0 (단, 정의역에서 종료 가정)

def mu(P):
    t = 0
    while True:
        if P(t) == 0:
            return t
        t += 1
```

### “미니 λ-해석기” 감각(극단 단순화; 실제 λ는 훨씬 복잡)

```python
# 아주 제한된 λ-식: Var | Lam(var, body) | App(f, a)

class Var:  def __init__(self, name): self.name=name
class Lam:  def __init__(self, v, body): self.v, self.body = v, body
class App:  def __init__(self, f, a): self.f, self.a = f, a

def subst(term, v, by):
    if isinstance(term, Var):
        return by if term.name==v else term
    if isinstance(term, Lam):
        if term.v==v: return term
        return Lam(term.v, subst(term.body, v, by))
    if isinstance(term, App):
        return App(subst(term.f, v, by), subst(term.a, v, by))

def beta_reduce_once(t):
    if isinstance(t, App) and isinstance(t.f, Lam):
        return subst(t.f.body, t.f.v, t.a), True
    if isinstance(t, App):
        t1, ch = beta_reduce_once(t.f)
        if ch: return App(t1, t.a), True
        t2, ch = beta_reduce_once(t.a)
        if ch: return App(t.f, t2), True
    if isinstance(t, Lam):
        b, ch = beta_reduce_once(t.body)
        return Lam(t.v, b), ch
    return t, False

def normalize(t, max_steps=10000):
    for _ in range(max_steps):
        t, ch = beta_reduce_once(t)
        if not ch: break
    return t
```
- **메시지**: 아주 조악해도 “**재작성에 의한 계산**” 감각을 주기 충분.
- 이 재작성 시스템은 **TM 전이**로 **기계적 변환** 가능 → **등가성** 직관.

### 레지스터 머신(URM) 인터프리터 단편

```python
# 매우 단순화: 명령어 형식 [("Z",i), ("S",i), ("T",i,j), ("J",i,j,k)]
# Z: Ri <- 0, S: Ri <- Ri+1, T: Rj <- Ri, J: if Ri==Rj: goto k else next

def run_urm(prog, regs, pc=0, steps=10_000):
    while 0 <= pc < len(prog) and steps > 0:
        op = prog[pc]; steps -= 1
        if op[0]=="Z":
            regs[op[1]] = 0; pc += 1
        elif op[0]=="S":
            regs[op[1]] += 1; pc += 1
        elif op[0]=="T":
            regs[op[2]] = regs[op[1]]; pc += 1
        elif op[0]=="J":
            pc = op[3] if regs[op[1]]==regs[op[2]] else pc+1
        else:
            raise ValueError("unknown")
    return regs, pc
```
- **URM ↔ TM**: 각 명령은 **유한 전이 매크로**로 TM에 **기계적** 변환 가능.

---

## 결론 — **하나의 경계, 다양한 얼굴**

- **튜링 명제**는 “효과적 계산 가능성”의 **자연적 직관**과 **여러 형식 모델**의 **일치**를 말한다.
- **계산 가능성의 경계(CTT)** 는 언어/머신/아키텍처가 달라도 **불변**.
- **효율(ECT)** 은 별개의 논의이며, **양자 계산**이 활발히 **재검토** 중.
- 실무적으로는 **가능/불가능**의 **절대 경계**를 이해한 뒤, 그 안에서 **복잡도·엔지니어링**을 최적화하는 것이 핵심.

---

## 부록 A) 용어 미니 사전

- **RE/REC**: 재귀적 열거/결정 가능. RE는 수용 사례를 **열거** 가능, REC는 **양쪽 정지**.
- **UTM**: 범용 튜링 기계(인터프리터/VM 원형).
- **Rice 정리**: 의미론적 비자명 성질은 비결정.
- **s-m-n / 재귀정리**: 프로그램 **부분평가**/**자기참조**를 가능케 하는 핵심 정리.
- **ECT**: 효율(다항 시간)까지 동치 주장 — 양자 계산이 도전.

---

## 부록 B) 체크리스트 — “새 모델을 제안한다면”

- [ ] 유한 기술 가능? (유한 규칙/유한 알파벳/유한 제어)
- [ ] 지역성·유한 정보 전파 속도(물리 공리) 준수?
- [ ] 기존 TM/RAM/λ로 **구성적 시뮬** 가능? 역시뮬도 가능?
- [ ] 요구 자원이 **유한 정밀/유한 에너지/유한 시간** 내 현실적인가?

> 위에 **예** 라면, 거의 항상 **튜링 경계** 안쪽임.
