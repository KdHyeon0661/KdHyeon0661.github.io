---
layout: post
title: Linux - 빌드 시스템과 소스에서 설치
date: 2024-12-04 19:20:23 +0900
category: Linux
---
# 빌드 시스템과 소스에서 설치

## 1. GNU 전통 빌드 시스템: configure → make → make install

Autotools 기반의 소스 코드는 일반적으로 `configure` 스크립트를 포함하고 있습니다. 이 스크립트는 시스템 환경을 검사하고 적절한 `Makefile`을 생성합니다.

### 빌드 환경 준비

```bash
# 컴파일러 및 빌드 도구 설치 (Debian/Ubuntu)
sudo apt update
sudo apt install -y build-essential pkg-config

# RHEL/Fedora 계열
# sudo dnf groupinstall "Development Tools"
# sudo dnf install pkgconf-pkg-config
```

### 표준 빌드 절차

```bash
# 소스 압축 해제
tar -xzf program-1.2.3.tar.gz
cd program-1.2.3

# 환경 검사 및 Makefile 생성
./configure --prefix=/usr/local --enable-something --with-ssl

# 병렬 컴파일 (시스템 코어 수만큼)
make -j"$(nproc)"

# 테스트 실행 (선택사항)
make check    # 또는 make test

# 시스템 설치
sudo make install
```

### 자주 사용하는 configure 옵션

| 옵션 | 설명 |
|---|---|
| `--prefix=/opt/myapp` | 설치 경로 지정 (기본값: `/usr/local`) |
| `--sysconfdir=/etc` | 설정 파일 위치 지정 |
| `--libdir=/usr/lib64` | 라이브러리 경로 (멀티아키텍처 환경 고려) |
| `--enable-XXX` / `--disable-XXX` | 특정 기능 활성화/비활성화 |
| `--with-XXX[=PATH]` | 외부 라이브러리 지정 및 경로 설정 |

### 안전한 설치: DESTDIR를 이용한 스테이징

실제 시스템에 직접 설치하기 전에 스테이징 디렉토리를 사용하여 검토하는 것이 안전합니다:

```bash
# 스테이징 디렉토리에 설치
make -j"$(nproc)"
make DESTDIR="$PWD/_staging" install

# 설치된 파일 확인
tree _staging
```

이 방법을 사용하면 설치될 파일 목록을 쉽게 확인할 수 있으며, 이후 패키지 생성이나 다른 관리 도구와의 통합이 용이해집니다.

### 소프트웨어 삭제 및 업그레이드

소스 코드가 `uninstall` 타겟을 제공하는 경우:
```bash
sudo make uninstall
```

`uninstall` 타겟이 없는 경우 DESTDIR 스테이징과 패키징 방식을 사용하여 관리하는 것이 권장됩니다. 이렇게 하면 설치와 삭제를 체계적으로 관리할 수 있습니다.

### Autotools가 없는 경우

소스 코드에 `configure` 스크립트가 없는 경우:
```bash
# autogen.sh 또는 bootstrap 스크립트 확인
./autogen.sh      # 또는
autoreconf -fi    # configure.ac에서 configure 생성
./configure && make -j"$(nproc)"
```

---

## 2. 빌드 도구와 환경 설정

### 필수 및 유용한 도구

| 도구 | 용도 |
|---|---|
| `gcc`, `g++`, `clang` | C/C++ 컴파일러 |
| `make`, `ninja` | 빌드 실행기 |
| `pkg-config` | 외부 라이브러리 검색 (`.pc` 파일 사용) |
| `ccache`/`sccache` | 컴파일 캐시 (재빌드 속도 향상) |
| `distcc` | 분산 컴파일 |
| `gdb`, `valgrind` | 디버깅 및 메모리 검사 |
| `asan/ubsan/tsan` | 런타임 버그 탐지 |

```bash
# ccache 설정 예시
sudo apt install -y ccache
export CC="ccache gcc"
export CXX="ccache g++"
```

### 최적화 및 디버깅 컴파일 플래그

```bash
# 디버그 빌드
CFLAGS="-O0 -g3 -fno-omit-frame-pointer" CXXFLAGS="$CFLAGS" ./configure

# 릴리스 빌드 (최적화 및 LTO 포함)
CFLAGS="-O3 -DNDEBUG -flto" CXXFLAGS="$CFLAGS" ./configure
make -j"$(nproc)"
```

### Sanitizers를 이용한 버그 탐지

Sanitizers는 컴파일 타임에 코드에 계측을 추가하여 런타임에 다양한 버그를 탐지합니다:

```bash
CFLAGS="-O1 -g -fsanitize=address,undefined -fno-omit-frame-pointer" \
CXXFLAGS="$CFLAGS" \
./configure && make -j"$(nproc)"
```

주요 Sanitizers:
- **AddressSanitizer**: 메모리 오류 탐지
- **UndefinedBehaviorSanitizer**: 정의되지 않은 동작 탐지  
- **ThreadSanitizer**: 데이터 레이스 탐지

### 테스트 및 코드 커버리지

```bash
# Autotools 기반 테스트
make check

# 코드 커버리지 측정 (gcc + lcov)
CFLAGS="--coverage -O0" CXXFLAGS="$CFLAGS" ./configure && make && make check
lcov --capture --directory . --output-file coverage.info
genhtml coverage.info --output-directory out
```

---

## 3. CMake와 Ninja: 현대적 빌드 시스템

CMake는 플랫폼 독립적인 빌드 시스템 생성기이며, Ninja는 빠른 빌드 실행기로 CMake와 잘 통합됩니다.

### 표준 워크플로우

```bash
sudo apt install -y cmake ninja-build

# out-of-tree 빌드 (소스 디렉토리와 빌드 디렉토리 분리)
mkdir -p build && cd build
cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local ..
ninja -j"$(nproc)"
ctest --output-on-failure         # 테스트 실행
sudo ninja install
```

### 의존성 관리

패키지 관리자를 통한 의존성:
```cmake
find_package(PkgConfig REQUIRED)
pkg_check_modules(FOO REQUIRED IMPORTED_TARGET foo)
target_link_libraries(myapp PRIVATE PkgConfig::FOO)
```

FetchContent를 이용한 소스 수준 의존성:
```cmake
include(FetchContent)
FetchContent_Declare(
  fmt
  GIT_REPOSITORY https://github.com/fmtlib/fmt.git
  GIT_TAG        11.0.2
)
FetchContent_MakeAvailable(fmt)
target_link_libraries(myapp PRIVATE fmt::fmt)
```

### 스테이징 설치 (DESTDIR)

```bash
ninja
DESTDIR="$PWD/_stage" ninja install
```

### CPack를 이용한 패키지 생성

CMake에는 내장 패키징 도구인 CPack가 포함되어 있습니다:

```cmake
# CMakeLists.txt에 추가
include(CPack)
set(CPACK_GENERATOR "DEB;RPM")
set(CPACK_PACKAGE_NAME "myapp")
set(CPACK_PACKAGE_VERSION "1.2.3")
```

패키지 생성:
```bash
cpack -G DEB
cpack -G RPM
```

### CMake Presets를 이용한 구성 관리

`CMakePresets.json` 파일을 사용하면 빌드 구성을 일관되게 관리할 수 있습니다:

```json
{
  "version": 3,
  "configurePresets": [
    {
      "name": "rel",
      "generator": "Ninja",
      "binaryDir": "build/rel",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_INSTALL_PREFIX": "/usr/local"
      }
    }
  ]
}
```

사용:
```bash
cmake --preset rel
cmake --build --preset rel
cmake --install --preset rel
```

---

## 4. Meson과 Ninja: 선언적이고 빠른 빌드 시스템

Meson은 선언적 문법을 사용하는 현대적인 빌드 시스템입니다:

```bash
sudo apt install -y meson ninja-build
meson setup build --prefix=/usr/local -Ddefault_library=shared -Dbuildtype=release
meson compile -C build
meson test -C build
sudo meson install -C build
```

### WrapDB를 이용한 의존성 관리

Meson은 WrapDB를 통해 의존성을 쉽게 관리할 수 있습니다:

```bash
meson wrap install fmt
# subprojects/fmt/ 디렉토리에 다운로드되어 자동으로 통합됨
```

---

## 5. 라이브러리, 링커, 런타임 경로

### 주요 개념 이해

- **soname**: ABI 호환성을 나타내는 라이브러리 버전 이름 (예: `libfoo.so.1`)
- **ldconfig**: `/etc/ld.so.conf.d/*.conf` 설정을 기반으로 `ld.so.cache` 생성
- **RPATH/RUNPATH**: 실행 파일이 런타임에 공유 라이브러리를 찾는 경로 (RUNPATH가 권장됨)

### 공유 라이브러리 설치 후 시스템 인식

```bash
# /usr/local/lib 경로 시스템에 등록
echo "/usr/local/lib" | sudo tee /etc/ld.so.conf.d/local.conf
sudo ldconfig

# 라이브러리 의존성 확인
ldd /usr/local/bin/myprog
```

### LD_LIBRARY_PATH 사용 주의사항

`LD_LIBRARY_PATH`는 임시 디버깅 목적으로만 사용하고, 시스템 전역에 설정하는 것은 충돌과 보안 문제를 일으킬 수 있으므로 피해야 합니다.

---

## 6. 패키징 방법

### checkinstall (간편한 패키징)

```bash
sudo apt install -y checkinstall
make
sudo checkinstall           # make install을 모니터링하여 .deb/.rpm 생성
```

checkinstall은 빠르고 간단하지만, 복잡한 패키지 메타데이터나 스크립트가 필요한 경우에는 한계가 있습니다.

### 수동 DEB 패키지 생성

디렉토리 구조:
```
mypkg/
├── DEBIAN/control
└── usr/local/bin/myprog
```

`DEBIAN/control` 파일:
```
Package: myprog
Version: 1.0.0
Section: utils
Priority: optional
Architecture: amd64
Maintainer: You <you@example.com>
Description: 설명
```

패키지 빌드:
```bash
dpkg-deb --build mypkg
sudo apt install ./mypkg.deb
```

### RPM 스펙 파일 개요

`~/.rpmmacros` 설정 후 스펙 파일 작성:
```
%define name myprog
%define version 1.0.0
Summary: 설명
Name: %{name}
Version: %{version}
Release: 1%{?dist}
License: MIT
Source: myprog-%{version}.tar.gz
BuildRequires: gcc, make
%description
긴 설명

%prep
%setup -q

%build
%configure
make -j%{_smp_build_ncpus}

%install
rm -rf %{buildroot}
make DESTDIR=%{buildroot} install

%files
/usr/local/bin/myprog
```

RPM 빌드:
```bash
rpmbuild -ba SPECS/myprog.spec
```

### FPM (만능 패키지 생성기)

FPM은 다양한 형식의 패키지를 생성할 수 있는 유연한 도구입니다:

```bash
gem install --user-install fpm
fpm -s dir -t deb -n myprog -v 1.0.0 /usr/local/bin/myprog
```

---

## 7. 실전 예제

### 예제 A: htop 소스 코드 직접 설치 (Autotools)

```bash
tar -xzf htop-3.2.2.tar.gz
cd htop-3.2.2
./configure --prefix=/usr/local
make -j"$(nproc)"
sudo make install
```

### 예제 B: checkinstall을 이용한 패키지화 설치

```bash
cd htop-3.2.2
./configure && make -j"$(nproc)"
sudo checkinstall   # .deb 생성 및 설치
```

### 예제 C: CMake 프로젝트를 /opt 경로에 설치

```bash
mkdir build && cd build
cmake -G Ninja -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_INSTALL_PREFIX=/opt/myapp ..
ninja && sudo ninja install
```

### 예제 D: DESTDIR 스테이징 + dpkg-deb 패키지 생성

```bash
cmake -B build -G Ninja -DCMAKE_INSTALL_PREFIX=/usr/local
cmake --build build -j"$(nproc)"
DESTDIR="$PWD/_stage" cmake --install build

mkdir -p mypkg/DEBIAN
cat > mypkg/DEBIAN/control <<'EOF'
Package: mycmakeapp
Version: 1.0.0
Section: utils
Priority: optional
Architecture: amd64
Maintainer: You <you@example.com>
Description: My CMake App
EOF

# 스테이징 내용 복사
rsync -a _stage/usr mypkg/
dpkg-deb --build mypkg
sudo apt install ./mypkg.deb
```

---

## 8. 크로스 컴파일 및 임베디드 시스템

### Autotools 크로스 컴파일

```bash
./configure --host=aarch64-linux-gnu --build=x86_64-pc-linux-gnu \
            --prefix=/usr \
            CC=aarch64-linux-gnu-gcc \
            PKG_CONFIG_PATH=/opt/arm-sysroot/usr/lib/pkgconfig \
            PKG_CONFIG_SYSROOT_DIR=/opt/arm-sysroot
make -j"$(nproc)"
```

### CMake 툴체인 파일

`toolchain-aarch64.cmake` 파일 생성:
```cmake
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR aarch64)
set(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)
set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)
set(CMAKE_SYSROOT /opt/arm-sysroot)
set(PKG_CONFIG_USE_CMAKE_PREFIX_PATH TRUE)
```

사용:
```bash
cmake -G Ninja -B build.arm -DCMAKE_TOOLCHAIN_FILE=toolchain-aarch64.cmake -DCMAKE_BUILD_TYPE=Release
cmake --build build.arm -j"$(nproc)"
```

### QEMU를 이용한 타겟 바이너리 테스트

```bash
qemu-aarch64 -L /opt/arm-sysroot ./build.arm/myprog
```

---

## 9. 지속적 통합(CI)과 빌드 자동화

### Docker 컨테이너를 이용한 빌드 환경 고정

```Dockerfile
FROM debian:stable-slim
RUN apt update && apt install -y build-essential cmake ninja-build pkg-config
WORKDIR /src
```

```bash
docker build -t mybuild .
docker run --rm -v "$PWD":/src mybuild bash -lc 'cmake -B build -G Ninja && cmake --build build -j$(nproc)'
```

### GitHub Actions 예시

```yaml
name: build
on: [push, pull_request]
jobs:
  linux:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: sudo apt update && sudo apt install -y cmake ninja-build build-essential
      - run: cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Release
      - run: cmake --build build -j"$(nproc)"
      - run: ctest --test-dir build --output-on-failure
```

### 재현 가능한 빌드를 위한 팁

- **정확한 버전 고정**: 서브모듈이나 FetchContent 해시 명시적 지정
- **환경 변수 기록**: 빌드 시 사용된 환경 변수와 경로 기록
- **타임스탬프 표준화**: `SOURCE_DATE_EPOCH` 사용으로 재현성 보장

---

## 10. 빌드 성능 최적화

병렬 빌드 성능은 다음 공식으로 추정할 수 있습니다:

$$
T_j \approx \frac{T_1}{\eta \cdot j}
$$

여기서:
- \(T_j\): \(j\)개의 스레드로 빌드할 때 걸리는 시간
- \(T_1\): 단일 스레드 빌드 시간
- \(\eta\): 병렬화 효율 (0과 1 사이)
- \(j\): 병렬 스레드 수

빌드 성능 향상을 위한 전략:
- **컴파일 캐시**: ccache/sccache 사용
- **빠른 빌드 시스템**: Ninja 사용
- **고속 스토리지**: SSD/NVMe 사용
- **의존성 그래프 최적화**: 불필요한 의존성 제거

---

## 11. 일반적인 문제와 해결 방법

1. **헤더 파일이나 라이브러리를 찾을 수 없는 경우**
   - `pkg-config --cflags --libs libname` 명령으로 필요한 플래그 확인
   - `PKG_CONFIG_PATH`, `CMAKE_PREFIX_PATH` 환경 변수 점검
   - 라이브러리 설치 후 `sudo ldconfig` 실행

2. **RPATH/RUNPATH 문제**
   - CMake에서 `CMAKE_INSTALL_RPATH_USE_LINK_PATH=ON` 설정
   - `CMAKE_INSTALL_RPATH` 최소화
   - 시스템 전역 `LD_LIBRARY_PATH` 사용 피하기

3. **uninstall 타겟이 없는 경우**
   - DESTDIR 스테이징과 패키징 방식으로 관리
   - checkinstall 또는 GNU Stow 사용 고려

4. **디버그 심볼 분리**
   - `strip` 또는 `objcopy --only-keep-debug`로 디버그 심볼 분리
   - 별도의 디버그 심볼 패키지 생성

5. **라이선스 준수**
   - 배포 전 `LICENSE`, `NOTICE` 파일 확인
   - 포함된 소스 및 바이너리의 라이선스 검토

---

## 12. 미니 프로젝트 예시: 다양한 빌드 시스템 비교

### GNU Makefile 예시

```make
CC ?= gcc
CFLAGS ?= -O2 -Wall
LDFLAGS ?=
PREFIX ?= /usr/local

all: hello
hello: src/hello.c
	$(CC) $(CFLAGS) -o $@ $< $(LDFLAGS)

install: hello
	install -d $(DESTDIR)$(PREFIX)/bin
	install -m 0755 hello $(DESTDIR)$(PREFIX)/bin/hello

uninstall:
	rm -f $(DESTDIR)$(PREFIX)/bin/hello

clean:
	rm -f hello
```

### CMakeLists.txt 예시

```cmake
cmake_minimum_required(VERSION 3.20)
project(hello C)
add_executable(hello src/hello.c)
install(TARGETS hello RUNTIME DESTINATION bin)
```

### Meson.build 예시

```meson
project('hello', 'c')
executable('hello', 'src/hello.c', install: true)
```

---

## 핵심 명령어 요약

| 명령어 | 설명 |
|---|---|
| `./configure && make && sudo make install` | 전통적 Autotools 빌드 |
| `make DESTDIR=_stage install` | 스테이징 설치 (패키징/검토용) |
| `cmake -B build -G Ninja … && cmake --build build` | CMake + Ninja 빌드 |
| `ctest`, `meson test` | 테스트 실행 |
| `sudo checkinstall` | 간편 패키징 설치 |
| `dpkg-deb --build`, `rpmbuild -ba` | 수동 DEB/RPM 패키지 생성 |
| `cpack -G DEB/RPM` | CMake 내장 패키징 |
| `fpm -s dir -t deb …` | FPM을 이용한 패키지 생성 |
| `pkg-config --cflags --libs` | 의존성 컴파일 플래그 조회 |
| `ldconfig`, `ldd` | 라이브러리 캐시 관리 및 진단 |

---

## 결론

소스 코드에서의 빌드와 설치 작업은 리눅스 시스템 관리와 소프트웨어 개발의 핵심 기술입니다. 효과적인 빌드 관리 전략을 통해 소프트웨어의 설치, 유지보수, 배포를 체계적으로 관리할 수 있습니다.

가장 중요한 원칙은 **안전성과 재현성**입니다. DESTDIR 스테이징과 패키징 방식을 활용하면 시스템에 직접 설치하는 위험을 피할 수 있으며, 언제든지 깨끗하게 제거할 수 있습니다. 테스트, 캐시, 병렬 빌드를 적절히 활용하면 개발 생산성을 크게 향상시킬 수 있습니다.

Autotools, CMake, Meson 등의 다양한 빌드 시스템은 각각의 장점이 있습니다. 프로젝트의 특성과 요구사항에 맞는 적절한 도구를 선택하는 것이 중요합니다. 특히 CMake와 Ninja의 조합은 현대적인 프로젝트에 매우 효과적입니다.

라이브러리 관리와 런타임 경로 설정(RPATH/RUNPATH, soname, pkg-config)을 올바르게 이해하고 적용하면 배포와 디버깅이 훨씬 쉬워집니다. 이러한 기본 개념을 잘 숙지하는 것이 장기적인 시스템 안정성에 기여합니다.

마지막으로, 컨테이너와 CI/CD 파이프라인을 활용하여 빌드 환경을 고정하고 자동화하면 팀 협업과 소프트웨어 품질 관리에 큰 도움이 됩니다. 재현 가능한 빌드 환경을 구축하는 습관은 전문적인 소프트웨어 개발의 필수 요소입니다.

이러한 기술과 원칙들을 잘 이해하고 적용하면, 복잡한 소프트웨어도 안정적으로 빌드하고 배포할 수 있는 능력을 갖추게 될 것입니다.