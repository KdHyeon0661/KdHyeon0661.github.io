---
layout: post
title: Java - 자바 최신 문법 정리
date: 2025-08-18 17:25:23 +0900
category: Java
---
# 자바 최신 문법 정리

## 0. 한눈에 보는 핵심 업데이트

| 주제 | 도입/상태 | 한 줄 요약 |
|---|---|---|
| `var` (지역 변수 추론) | **Java 10 (GA)** | 로컬 변수 타입 추론으로 보일러플레이트 축소 |
| **switch expression** | **Java 14 (GA)** | `switch`가 “식”이 되어 값을 반환, `yield`/`->` 사용 |
| **records** | **Java 16 (GA)** | 불변 데이터 캐리어: `equals/hashCode/toString` 자동 |
| **sealed classes/interfaces** | **Java 17 (GA)** | 상속 허용 타입을 `permits`로 제한 |
| **pattern matching** (`instanceof`, **switch**, **record patterns**) | `instanceof`: 16 (GA) / **switch**: 21 (GA) / **record patterns**: 21 (GA) | 분기/분해 로직을 간결·안전하게 작성 (널/완전성 검사 포함) |
| **virtual threads** | **Java 21 (GA)** | 경량 스레드로 대규모 동시성 I/O를 간단히 처리 |
| **sequenced collections** | **Java 21 (GA)** | 앞/뒤 개념이 있는 양방향 순서 API(`getFirst/Last`, `reversed`) |
| **unnamed classes & instance main** | 21(Preview) → **22(GA)** | 1파일 예제/교육용 진입장벽 대폭 인하(“암시적” 클래스/메인) |
| **string templates** | 21(Preview) → 22(2nd Preview) → **Withdrawn** | 문자열 템플릿은 25 시점 GA 미포함(재설계 진행) |
| **JDK 25 (LTS)** | **2025-09 GA** | 최신 LTS. 팀 표준 런타임으로 권장(프로덕션 정책에 맞게 승격) |

---

## 1. `var` — 지역 변수 타입 추론 (Java 10)

- **언제 쓰나**: 생성자나 제너릭 타입이 장황할 때 가독성 ↑.  
- **주의**: 의미가 모호해지는 경우(예: `var x = foo();`)엔 명시 타입이 낫다.
```java
var list = new ArrayList<String>(); // List<String>
var n = 0;                          // int
for (var s : List.of("a","b")) { /* ... */ }

// 람다 파라미터에도 사용 가능 (Java 11+):
BiFunction<Integer,Integer,Integer> add = (var a, var b) -> a + b;
```
- **금지**: 필드/메서드 파라미터/리턴 타입에는 불가(“로컬 변수 전용”).

---

## 2. Switch **Expression** (Java 14)

- `switch`를 **식(expression)** 으로 사용하여 값을 **반환**:
```java
int letters = switch (day) {
  case MONDAY, FRIDAY, SUNDAY -> 6;
  case TUESDAY               -> 7;
  case THURSDAY, SATURDAY    -> 8;
  case WEDNESDAY -> {
    System.out.println("mid");
    yield 9;
  }
};
```
- **장점**: `break` 누락 버그 방지, **완전성 검사** 지원.

---

## 3. Records — 불변 데이터 캐리어 (Java 16)

```java
public record User(long id, String name) {
  public User {
    if (name == null || name.isBlank()) throw new IllegalArgumentException();
    name = name.trim(); // 정규화
  }
}

var u = new User(1, "  Alice ");
System.out.println(u.name()); // "Alice"
```
- **권장**: 내부에서 **불변 컬렉션**(`List.copyOf`)로 방어적 복사.

---

## 4. Sealed Classes/Interfaces — 상속 제어 (Java 17)

```java
public sealed interface Shape permits Circle, Rect {}
public final class Circle implements Shape { /* ... */ }
public non-sealed class Rect implements Shape { /* 다시 개방 */ }
```
- **효과**: 패턴 매칭/`switch`와 조합 시 **케이스 완전성**을 컴파일 타임에 담보.

---

## 5. Pattern Matching — `instanceof`, **switch**, **record patterns**

### 5.1 `instanceof` 패턴 (Java 16)
```java
if (o instanceof String s && !s.isBlank()) {
  System.out.println(s.toUpperCase());
}
```

### 5.2 **switch 패턴 매칭** (Java 21, GA)
- 널 안전 분기, 가드(`when`) 지원.  
```java
static String render(Object o) {
  return switch (o) {
    case null                      -> "null";
    case String s when s.isBlank() -> "blank";
    case String s                  -> "str:" + s;
    case Integer i                 -> "int:" + i;
    case List<?> list              -> "list(size=" + list.size() + ")";
    default                        -> "other";
  };
}
```
- 정식 사양: **JEP 441**(JDK 21).

### 5.3 **Record Patterns** (Java 21, GA)
- 레코드 구성요소를 **구조 분해**:
```java
record Point(int x, int y) {}
static String quad(Object o) {
  return switch (o) {
    case Point(int x, int y) when x>=0 && y>=0 -> "Q1";
    case Point(int x, int y) when x< 0 && y>=0 -> "Q2";
    case Point(int x, int y) when x< 0 && y< 0 -> "Q3";
    case Point(int x, int y) when x>=0 && y< 0 -> "Q4";
    default -> "N/A";
  };
}
```
- 정식 사양: **JEP 440**(JDK 21).

---

## 6. Virtual Threads — 경량 스레드 (Java 21, GA)

- 기존 **블로킹** 스타일 API를 그대로 쓰면서도 **대량 동시성 I/O**를 처리하기 쉬워진다.
```java
try (var exec = Executors.newVirtualThreadPerTaskExecutor()) {
  Future<String> f = exec.submit(() -> Files.readString(Path.of("a.txt")));
  System.out.println(f.get());
}
```
- 사양: **JEP 444**(JDK 21). 운영에서는 **스레드풀 고갈/컨텍스트 전파(MDC/ThreadLocal)** 를 함께 점검.

---

## 7. 실무에서 자주 쓰는 “현대 문법” 추가

### 7.1 Text Blocks — 멀티라인 문자열 (Java 15)
```java
String json = """
{
  "name": "Alice",
  "age": 30
}
""";
```

### 7.2 Sequenced Collections — 양방향 순서 API (Java 21, GA)
```java
SequencedCollection<String> sc = new ArrayList<>();
sc.addFirst("a"); sc.addLast("b");
System.out.println(sc.reversed()); // 역순 뷰
```
- 사양: **JEP 431**. 기존 컬렉션을 **앞/뒤** 관점으로 직관적으로 다룬다.

### 7.3 Unnamed Classes & Instance Main — 빠른 진입 (21 Preview → **22 GA**)
- 교육/스니펫/스크립팅 용의 **저마찰 진입**:
```java
void main() { // 클래스 선언 생략
  System.out.println("Hello");
}
```
- 21에서 프리뷰(**JEP 445**), 22에서 **JEP 463**로 정식화.

### 7.4 String Templates — “현재 GA 아님”
- 21(Preview, **JEP 430**) → 22(2nd Preview, **JEP 459**).  
- 2025-11 기준 **JEP 465(3rd Preview) Withdrawn**: 템플릿은 **JDK 25에 포함되지 않음**. 팀에서 사용 시 주의.

---

## 8. 현대 문법 조합 예제

### 8.1 도메인 분기(Sealed + Record + Pattern + switch)
```java
sealed interface Msg permits Text, Image {}
record Text(String body) implements Msg {}
record Image(String url, int w, int h) implements Msg {}

static String describe(Msg m) {
  return switch (m) {
    case Text(String body)            -> "text:" + body;
    case Image(String url, int w, _)  -> "img:" + url + "(" + w + "px)";
  };
}
```
- sealed로 **완전성 보장**, record pattern으로 **구조 분해**, `_`(unused)로 의도 명시.

### 8.2 Virtual Threads + HTTP Client (Java 11+) 조합
```java
var urls = List.of("https://example.com/a", "https://example.com/b");
try (var exec = Executors.newVirtualThreadPerTaskExecutor()) {
  var client = HttpClient.newHttpClient();
  var futures = urls.stream()
      .map(u -> exec.submit(() ->
          client.send(
              HttpRequest.newBuilder(URI.create(u)).build(),
              HttpResponse.BodyHandlers.ofString()
          ).body()))
      .toList();
  for (var f : futures) System.out.println(f.get());
}
```

### 8.3 레코드 + 불변 컬렉션
```java
public record Order(long id, List<String> items) {
  public Order {
    items = List.copyOf(items); // 방어적 복사
  }
}
```

---

## 9. 마이그레이션&리팩터링 가이드 (17/21 → 25)

1) **분기 리팩터링**: `if-else` 체인 → **switch expression + 패턴 매칭**  
2) **DTO/값 객체**: 클래식 POJO → **record** (불변/자동 메서드)  
3) **상속 모델**: 무분별한 상속 → **sealed**로 폐쇄·모델링 강화  
4) **I/O 동시성**: “대기 많은” 워크로드 → **virtual threads** 우선 검토  
5) **컬렉션 API**: 인덱스/역순/앞뒤 조작 → **sequenced collections**  
6) **샘플/교육/CLI 툴**: **unnamed classes & instance main**로 진입장벽 ↓ (22+)  
7) **프리뷰 사용 주의**: 템플릿 문자열 등 **프리뷰/철회 기능은 GA 전 배제** 정책 권장(빌드 플래그/코드 규칙화)

---

## 10. 테스트 포인트 & 코드 리뷰 체크리스트

- [ ] `switch` 식의 **널 분기**를 명시했는가? (패턴-switch는 `null` 케이스 필요)  
- [ ] sealed 계층이 **모두 나열**되었는가? (후속 타입 추가 시 컴파일 오류로 신호)  
- [ ] record에서 **불변성**을 지키는가? (가변 컬렉션 방어)  
- [ ] virtual threads 사용 시 **ThreadLocal/MDC/보안 컨텍스트** 전파를 점검했는가?  
- [ ] 텍스트 블록/문자열 합성은 **가독성·보안(인젝션)** 관점에서 적절한가?  
- [ ] 프리뷰/철회 기능(예: String Templates)을 **프로덕션 빌드에서 차단**했는가?

---

## 11. 자주 묻는 질문(FAQ)

**Q. 팀 표준 런타임으로 무엇을 써야 하나요?**  
A. 2025년 현재 **JDK 25(LTS)** 가 GA다. 보안·지원 정책을 고려해 **LTS 채택**을 권장한다. JDK 21→25 업그레이드는 컴파일 옵션/경고 확인 후 단계 이행(테스트 커버리지 확보).

**Q. 패턴-switch에서 누락 케이스는?**  
A. JEP 441은 **완전성 검사**를 강화했다. sealed 계층/enum와 조합하면 누락을 컴파일 타임에 드러낼 수 있다.

**Q. 문자열 템플릿을 써도 될까요?**  
A. 21/22에서 프리뷰였으나 **3rd Preview(JEP 465)가 철회**되었다. 25 기준 **GA 기능이 아니므로** 프로덕션 금지/실험 전용 권장.

---

## 12. 마무리

- **Java 21**에서 현대 문법의 큰 축(패턴 매칭·레코드 패턴·가상 스레드·시퀀스 컬렉션)이 **정식**으로 완성되었고,  
- **Java 22**에서 교육/샘플 친화 기능(unnamed classes & instance main)이 **정식화**,  
- **Java 25(LTS)** 가 현재 표준 배포선이다.  
새 코드는 **레코드/패턴-switch/virtual threads**를 기본값으로, 프리뷰/철회 기능(문자열 템플릿 등)은 **보수적 도입**을 권장한다.