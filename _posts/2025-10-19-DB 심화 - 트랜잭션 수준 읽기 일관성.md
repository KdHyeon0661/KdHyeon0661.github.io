---
layout: post
title: DB 심화 - 트랜잭션 수준 읽기 일관성
date: 2025-10-19 18:25:23 +0900
category: DB 심화
---
# 트랜잭션 **수준 읽기 일관성(Transaction-Level Read Consistency)** — 정의, 고립화(격리) 수준, Dirty/Non-Repeatable/Phantom Read까지 (Oracle 중심·타 DB 비교)

> 목표
> - **트랜잭션 수준 읽기 일관성**(Transaction-Level Read Consistency, 이하 **TLRC**)이 **무엇**이며 **왜** 필요한지 명확히 정의
> - ANSI **격리 수준(Isolation Levels)** 과 제품별 구현(Oracle, PostgreSQL, InnoDB) 비교
> - **Dirty Read / Non-Repeatable Read / Phantom Read** 를 **세션 A/B 시나리오**로 재현하고, **예방책**과 **튜닝/설계 포인트** 제시
> - Oracle의 **Statement-Level vs Transaction-Level** 차이를 Undo/SCN/CR(Current/Consistent Read) 관점으로 설명

---

## 0. 한눈에 핵심 요약

- **문장 수준 읽기 일관성(SLRC)**: 한 **SELECT 문**이 **시작된 시점**의 스냅샷을 끝까지 지키는 것. (Oracle의 **기본 SELECT** 동작)
- **트랜잭션 수준 읽기 일관성(TLRC)**: **트랜잭션 시작 시점**(혹은 고정된 시점)의 스냅샷을 **트랜잭션이 끝날 때까지** **모든 SELECT** 가 동일하게 보도록 보장. (Oracle의 **SERIALIZABLE**, Postgres의 **REPEATABLE READ/Serializable**, InnoDB의 **REPEATABLE READ**)
- **Dirty/Non-Repeatable/Phantom** 은 격리 수준에 따라 허용/차단 여부가 다름. TLRC는 최소 **Non-Repeatable Read**를 방지하며, 구현에 따라 **Phantom** 도 방지하거나 **충돌 실패**로 처리.

---

## 1. TLRC의 정의와 직관

### 1.1 정의(개념식)
- 트랜잭션 T가 시작할 때 스냅샷 **SCN 또는 Read View = \(S_T\)** 를 정하고, **T가 끝날 때까지** 모든 읽기는 다음 가시성 규칙을 따른다.

\[
\textbf{Visible(row)} \iff \text{commit\_scn(row)} \le S_T
\]

- 이후에 발생한 커밋( \(\text{commit\_scn} > S_T\) ) 은 **T가 끝날 때까지** **보이지 않는다**.

### 1.2 직관
- “**한 트랜잭션 내의 모든 SELECT** 가 **한 번 찍은 사진**(스냅샷)을 보고 일한다.”
- 중간에 누군가가 값을 바꾸고 커밋해도, **내 트랜잭션이 끝날 때까지는** 그 변화가 **눈에 들어오지 않는다.**

---

## 2. Statement-Level vs Transaction-Level (Oracle 관점)

| 구분 | 스냅샷 기준 | 보장 범위 | Oracle 기본 | 장단점 |
|---|---|---|---|---|
| **SLRC** (문장 수준) | **문장 시작 시점** | **해당 SELECT 문** | 기본 SELECT는 SLRC | 일관성/성능 균형. 문장 사이에는 변화가 보일 수 있어 **Non-Repeatable/Phantom** 가능 |
| **TLRC** (트랜잭션 수준) | **트랜잭션 시작 시점** | **트랜잭션 전체** | `SET ISOLATION_LEVEL = SERIALIZABLE` | 같은 트랜잭션의 모든 SELECT가 동일한 스냅샷. 경쟁 충돌 시 **실패/재시도** 필요 |

> Oracle **Read Committed(RC)** = **SLRC** (문장 단위로 스냅샷 유지)
> Oracle **Serializable** = **TLRC** (트랜잭션 전체 스냅샷 유지, 충돌 시 **ORA-08177**)

---

## 3. ANSI 격리 수준과 TLRC의 위치

| ANSI 수준 | Dirty Read | Non-Repeatable | Phantom | TLRC 여부(제품 의존) |
|---|---:|---:|---:|---|
| Read Uncommitted | 허용 | 허용 | 허용 | X |
| **Read Committed** | 차단 | **허용** | **허용** | X (Oracle은 SLRC) |
| **Repeatable Read** | 차단 | 차단 | 제품차 | **대체로 TLRC**(PG/Innodb) |
| **Serializable** | 차단 | 차단 | 차단 | TLRC (직렬화 의미로 달성) |

- **PostgreSQL**: RR = TLRC(스냅샷 고정), 다만 팬텀은 Serializable에서 완전 차단
- **InnoDB**: RR에서 **Gap/Next-Key 잠금**으로 팬텀까지 사실상 차단 → TLRC 성격 강함
- **Oracle**: Serializable에서 TLRC. 팬텀은 **충돌 탐지 시 실패(ORA-08177)** 로 처리

---

## 4. TLRC를 구현하는 핵심 메커니즘

### 4.1 MVCC(다중 버전 동시성 제어)
- **Undo/버전 체인**으로 **과거 버전**을 복원하여 읽음(Oracle/Innodb)
- **튜플 버전 마킹**으로 과거/현재 가시성 결정(PostgreSQL)

### 4.2 스냅샷/SCN/Read View
- 트랜잭션 시작 시 **스냅샷 시점 \(S_T\)** 을 잡고, 읽기마다 “행의 커밋 SCN ≤ \(S_T\)” 여부로 판정
- **부족한 Undo** → 과거 버전을 복원하지 못하면 **ORA-01555(snapshot too old)**

---

## 5. 세 가지 대표 이상(Anomalies) — 시나리오와 예방

아래 예제는 **Oracle** 기본(READ COMMITTED = SLRC)과 **SERIALIZABLE = TLRC** 비교를 중심으로 합니다.

### 5.1 공통 준비

```sql
-- 테스트 테이블 준비
DROP TABLE bank PURGE;
CREATE TABLE bank(
  acct NUMBER PRIMARY KEY,
  bal  NUMBER NOT NULL
);
INSERT INTO bank VALUES(1, 100);
INSERT INTO bank VALUES(2, 200);
COMMIT;
```

---

### 5.2 Dirty Read (더러운 읽기)

- **정의**: T1이 **아직 커밋하지 않은 변경**을 T2가 읽는 현상. T1이 롤백하면 T2는 유령 데이터를 본 셈.
- **Oracle RC/Serializable** 모두 **Dirty Read를 허용하지 않음**(Undo 기반 읽기).

**시나리오(개념)**
- **세션 A**: `UPDATE bank SET bal=999 WHERE acct=1;`  — **커밋 지연**
- **세션 B**: `SELECT bal FROM bank WHERE acct=1;`
  - Oracle은 **Undo 기준(문장/트랜잭션 스냅샷)** 으로 **커밋 이전 값(100)** 을 보여줌 → Dirty Read 차단

**방지 요약**: **RC 이상**이면 Dirty Read 없음(Oracle/PG/Innodb 모두).

---

### 5.3 Non-Repeatable Read (반복 불가능 읽기)

- **정의**: 같은 트랜잭션 T에서 **같은 행**을 **두 번 읽었을 때** 값이 달라짐(중간에 다른 트랜잭션이 커밋한 경우).
- **Oracle RC(SLRC)** 에서는 **발생 가능**(문장마다 스냅샷 새로)
- **TLRC(Serializable/RR)** 에서는 **차단**

**데모**

```sql
-- 세션 A (RC: 기본)
-- 첫 번째 읽기 (문장 S1)
SELECT bal FROM bank WHERE acct=1;  -- 100

-- 세션 B
UPDATE bank SET bal=300 WHERE acct=1;
COMMIT;

-- 세션 A (두 번째 읽기, 새 문장 S2)
SELECT bal FROM bank WHERE acct=1;  -- 300  (Non-Repeatable Read 발생)
```

**TLRC로 방지(Oracle Serializable)**

```sql
-- 세션 A
ALTER SESSION SET ISOLATION_LEVEL = SERIALIZABLE;

SELECT bal FROM bank WHERE acct=1;  -- 트랜잭션 스냅샷 ST 기준: 100

-- 세션 B
UPDATE bank SET bal=300 WHERE acct=1; COMMIT;

-- 세션 A
SELECT bal FROM bank WHERE acct=1;  -- 여전히 100 (TLRC)
-- A가 이후 acct=1을 갱신하려 하면 충돌로 ORA-08177 가능
```

**요지**: TLRC는 **같은 트랜잭션 내** **읽기 재실행**에서 **항상 동일 결과**를 보장.

---

### 5.4 Phantom Read (팬텀 읽기)

- **정의**: 동일 조건으로 두 번 조회했을 때, **행의 개수**(범위 결과)가 달라지는 현상(중간에 다른 트랜잭션의 INSERT/DELETE).
- **Oracle RC(SLRC)**: 허용
- **TLRC**: DB별 처리 차이
  - InnoDB RR: **Next-Key/GAP 락**으로 **사실상 차단**
  - PostgreSQL RR: 팬텀 가능, Serializable에서 차단
  - Oracle Serializable(TLRC): **충돌 시 실패(ORA-08177)** 로 **일관성 유지**

**데모(Oracle)**

```sql
-- 준비
DROP TABLE orders PURGE;
CREATE TABLE orders(id NUMBER PRIMARY KEY, amt NUMBER NOT NULL);
INSERT INTO orders VALUES(1, 500);
INSERT INTO orders VALUES(2, 300);
COMMIT;

-- 세션 A (RC)
SELECT COUNT(*) FROM orders WHERE amt >= 300;  -- 2

-- 세션 B
INSERT INTO orders VALUES(3, 1000);
COMMIT;

-- 세션 A (같은 조건 다시)
SELECT COUNT(*) FROM orders WHERE amt >= 300;  -- 3  (팬텀 발생)
```

**TLRC로 방지(Oracle Serializable)**

```sql
-- 세션 A
ALTER SESSION SET ISOLATION_LEVEL = SERIALIZABLE;
SELECT COUNT(*) FROM orders WHERE amt >= 300;  -- 스냅샷: 2

-- 세션 B
INSERT INTO orders VALUES(4, 1000); COMMIT;

-- 세션 A (트랜잭션 내 반복)
SELECT COUNT(*) FROM orders WHERE amt >= 300;  -- 여전히 2 (스냅샷 유지)
-- A가 동일 범위 갱신 시도 시 ORA-08177로 실패 가능(충돌 감지)
```

**비교(제품별)**
- **InnoDB RR**: 인덱스 범위에 **Next-Key 잠금** → B의 INSERT 자체가 **대기/차단**되어 팬텀 차단
- **Oracle Serializable**: 읽기는 자유롭게 스냅샷 유지, 나중에 **A의 쓰기** 또는 **커밋** 시 **충돌 판단 → 실패**
- **PostgreSQL**: RR은 TLRC지만 팬텀 가능, Serializable로 완전 차단(SSI: Serializable Snapshot Isolation with conflict checks)

---

## 6. TLRC 환경의 “쓰기(갱신)” 충돌 — 재시도 필요성

TLRC는 “읽기 일관성”을 트랜잭션 전체로 보장하지만, **동시에 누군가가 같은 범위를 갱신**해버리면 **내 트랜잭션의 가정이 깨짐**.
이때 제품들은 다음처럼 반응:

- **Oracle Serializable**: **ORA-08177** — “serialize 불가”, 트랜잭션 **롤백 후 재시도** 필요
- **InnoDB RR**: 범위 잠금으로 **상대 갱신을 대기/차단**하여 충돌을 **선제 제거**
- **PostgreSQL Serializable**: **Serialization Failure** 예외 → **재시도**

**예시(Oracle)**

```sql
-- 세션 A (Serializable)
ALTER SESSION SET ISOLATION_LEVEL = SERIALIZABLE;
SELECT SUM(amt) FROM orders WHERE amt >= 300;  -- 스냅샷 S_T

-- 세션 B
INSERT INTO orders VALUES(5, 1000); COMMIT;

-- 세션 A
UPDATE orders SET amt = amt * 1.1 WHERE amt >= 300;
-- ORA-08177 가능. 재시도 로직 필요
```

**애플리케이션 권고**
- TLRC/Serializable 사용 시, **Serialization Failure** 를 **정상 시그널** 로 보고 **재시도 루프**를 두는 것이 일반적.

---

## 7. TLRC를 쓸 것인가? 설계 체크리스트

1. **요구 일관성**:
   - **같은 트랜잭션 내 반복 조회가 반드시 동일**해야 하는가? (리포트/배치 계산) → TLRC 적합
   - **한 문장 내만** 일관하면 되는가? → SLRC(Oracle RC) 로 충분
2. **팬텀 중요도**:
   - **범위 기반 불변식**(예: 좌석/재고 상한) 보장이 필요 → InnoDB RR/Next-Key, 혹은 Serializable(+재시도)
3. **경쟁/성능**:
   - TLRC는 충돌 시 **실패**(재시도) 또는 **락 대기**(제품별) 비용 존재
   - 대량 동시 OLTP에서 TLRC를 광범위하게 쓰면 **처리량** 저하 → **업무별 선택적 적용**
4. **Undo/버전 보존**:
   - TLRC(긴 트랜잭션)는 **오래된 스냅샷**을 많이 요구 → **UNDO_RETENTION/용량** 확보, ORA-01555 예방
5. **재시도 전략**:
   - **지수 백오프** + **Idempotent 설계**(멱등성) + **트랜잭션 범위 축소** 권장

---

## 8. 실습 묶음 — RC vs TLRC 응답 비교

### 8.1 TLRC(Serializable) 지연·충돌 체감

```sql
-- A: Serializable
ALTER SESSION SET ISOLATION_LEVEL = SERIALIZABLE;

-- 트랜잭션 시작
SELECT COUNT(*) FROM orders WHERE amt >= 300;  -- 스냅샷 고정

-- B: 동시 삽입/삭제
INSERT INTO orders VALUES(10, 700); COMMIT;

-- A: 범위 갱신 시도
UPDATE orders SET amt = amt + 1 WHERE amt >= 300;
-- ORA-08177 가능 → ROLLBACK 후 재시도
```

### 8.2 RC(SLRC) 동일 시나리오

```sql
-- A: RC(기본)
SELECT COUNT(*) FROM orders WHERE amt >= 300;  -- 2

-- B
INSERT INTO orders VALUES(11, 700); COMMIT;

-- A (다음 문장)
SELECT COUNT(*) FROM orders WHERE amt >= 300;  -- 3 (문장 사이 결과 변동 허용)
-- 갱신은 최신 현재 버전 대상으로 진행(팬텀 반영). 일관성은 문장 단위로만 보장.
```

---

## 9. Dirty/Non-Repeatable/Phantom: 요약표(제품 매핑)

| 현상 | Oracle RC(SLRC) | Oracle Serializable(TLRC) | PostgreSQL RR | PostgreSQL Serializable | InnoDB RR |
|---|---|---|---|---|---|
| Dirty Read | 차단 | 차단 | 차단 | 차단 | 차단 |
| Non-Repeatable | **가능** | 차단 | 차단 | 차단 | 차단 |
| Phantom | **가능** | **충돌 시 실패** | **가능** | 차단 | **차단(Next-Key)** |

---

## 10. 베스트 프랙티스

- **일관성이 정말 트랜잭션 전체로 필요**한 지를 먼저 검토. 대부분의 OLTP는 **SLRC(Oracle RC)** 로 충분, **핵심 구간만 TLRC/Serializable**.
- **팬텀이 치명적**이면:
  - InnoDB: **RR + 적절한 인덱스**(Next-Key 범위 명확)
  - Oracle: **Serializable + 재시도** 또는 **`SELECT ... FOR UPDATE`로 현재 잠금**(범위잠금은 별 논의 필요)
- **재시도 가능 설계**: **멱등성**(동일 입력 → 동일 결과), **짧은 트랜잭션**, **충돌 최소화 키 설계**
- **Undo 보존**: 긴 TLRC 트랜잭션은 **UNDO_RETENTION/용량**, **ORA-01555** 모니터
- **모니터링**: `v$undostat`, `v$transaction`, `v$session`(이벤트: `enq: TX - row lock contention`, `read by other session`, `buffer busy waits`)
- **업무 스케줄링**: 대량 쓰기/통계 갱신/DDL은 **비혼잡 시간**으로

---

## 11. TLRC와 수식 한 줄

- 트랜잭션 T의 **가시성 판정**:

\[
\forall r \in \text{rows},\quad \text{Visible}_T(r) \iff \text{commit\_scn}(r) \le S_T
\]

- SLRC는 \(S_T\) 가 “**각 문장 시작 시점**”, TLRC는 “**트랜잭션 시작 시점**(또는 첫 스냅샷 고정)”으로 다르다.

---

## 12. 마무리

- **TLRC** 는 **트랜잭션 전체**에 동일 스냅샷을 적용해 **Non-Repeatable/Phantom** 을 원칙적으로 배제(또는 충돌로 실패)한다.
- **Oracle** 은 기본이 **SLRC**(RC)이고, **TLRC** 는 **Serializable** 로 달성(충돌 시 **ORA-08177** 재시도).
- **제품별 구현 차**(Oracle vs PG vs InnoDB)를 이해해 **업무별 최적 조합**(격리수준 + 잠금/재시도 + 인덱스/범위)을 설계하는 것이 핵심.

> 한 줄 결론:
> **문장만 일관하면 RC, 트랜잭션 내내 일관해야 하면 TLRC(Serializable/RR)** — 그리고 충돌은 **락으로 미리 막거나**, **실패-재시도**로 **사후 정리**하라.
