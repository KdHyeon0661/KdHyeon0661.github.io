---
layout: post
title: Django - 도메인 설계 & 패턴
date: 2025-10-06 18:25:23 +0900
category: Django
---
# 11. 도메인 설계 & 패턴

## A. 앱 모듈러 구조 — 기능/레이어 기준, 의존성 규칙

### A-1. 왜 모듈화인가?
- 도메인 복잡도가 커질수록 **경계(boundary)** 가 중요합니다.
- 목표:
  1) **변경 영향 최소화**(단일 책임, 낮은 결합)  
  2) **테스트 용이성**(순수 도메인 테스트 → 인프라 격리)  
  3) **확장성**(새 기능을 신규 앱으로 추가)

### A-2. 두 가지 관점: 기능 중심 vs 레이어 중심

#### 1) 기능(Feature) 중심(권장)
```
project/
  apps/
    accounts/      # 사용자/권한/역할
      domain/      # 도메인 모델, 규칙
      app/         # 유스케이스(Service)
      infra/       # ORM/외부 API/리포지토리 구현
      ui/          # views/forms/serializers
    catalog/
      domain/
      app/
      infra/
      ui/
    orders/
      domain/
      app/
      infra/
      ui/
  shared/          # cross-cutting: utils, event bus, time, money
```

#### 2) 레이어 중심
```
project/
  domain/          # 모든 도메인 모델 & 규칙
  app/             # 서비스/유스케이스
  infra/           # Django ORM, 외부 API, 리포지토리 구현
  ui/              # views/forms/serializers
```
- 장점: 레이어 간 의존성 명확.  
- 단점: 기능별 변경이 여러 폴더를 가로지름 → **기능 응집도**가 떨어질 수 있음.

> **실무 팁**: 기능 중심을 기본으로 하고, 각 기능 안에서 **도메인/domain, 애플리케이션/app, 인프라/infra, UI/ui** 4 레이어를 가볍게 유지합니다.

---

### A-3. 의존성 규칙(Import 방향)

- `ui → app → domain` (핵심 규칙)  
- `infra` 는 **양방향 금지**: `app/domain` 이 **infra를 몰라야** 합니다.  
- 대신 **추상화 인터페이스**(포트/리포지토리)를 `domain` 또는 `app` 에 정의하고, 구현체는 `infra`가 제공합니다.

의존성 예:
```
ui/views.py        -> app/services.py
app/services.py    -> domain/entities.py, domain/ports.py
infra/repositories -> app/domain의 ports 구현 (import는 app/domain만)
```

Django-특화 고려:
- ORM 모델은 일반적으로 `infra`에 두지만, 간단하게는 `domain`에 두고 **쿼리/저장 로직**만 `infra` 리포지토리에 넣어도 됩니다.
- Admin, forms, serializers, views 등 **프레젠테이션/UI** 레이어는 `ui` 에 위치.

---

### A-4. 공용 타입/값 객체(Value Object)

- 통화/금액, 기간, 이메일, 전화 등은 **값 객체**로 캡슐화.
- 불변성과 유효성 검사가 핵심.

```python
# shared/value_objects.py
from dataclasses import dataclass

@dataclass(frozen=True)
class Money:
    amount: int  # 원 단위 (정수)
    currency: str = "KRW"

    def __post_init__(self):
        if self.amount < 0:
            raise ValueError("음수 금지")
        if len(self.currency) != 3:
            raise ValueError("통화코드는 3글자")

    def add(self, other: "Money") -> "Money":
        if self.currency != other.currency:
            raise ValueError("통화 불일치")
        return Money(self.amount + other.amount, self.currency)

    def mul(self, n: float) -> "Money":
        return Money(int(self.amount * n), self.currency)
```

---

### A-5. 도메인 엔티티 vs ORM 모델 분리(선택)

- **분리 장점**: ORM 의존 제거, 도메인 테스트가 쉬움.  
- **분리 비용**: 매핑 코드 필요(ORM 모델 ↔ 도메인 엔티티).

```python
# apps/catalog/domain/entities.py
from dataclasses import dataclass
from shared.value_objects import Money

@dataclass
class Product:
    id: int | None
    name: str
    price: Money
    is_public: bool = True
```

```python
# apps/catalog/infra/models.py (Django ORM)
from django.db import models

class ProductModel(models.Model):
    name = models.CharField(max_length=180)
    price = models.PositiveIntegerField()
    currency = models.CharField(max_length=3, default="KRW")
    is_public = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
```

```python
# apps/catalog/infra/mappers.py
from .models import ProductModel
from apps.catalog.domain.entities import Product
from shared.value_objects import Money

def to_entity(row: ProductModel) -> Product:
    return Product(id=row.id, name=row.name, price=Money(row.price, row.currency), is_public=row.is_public)

def to_model(entity: Product) -> ProductModel:
    if entity.id:
        m = ProductModel.objects.get(pk=entity.id)
    else:
        m = ProductModel()
    m.name = entity.name
    m.price = entity.price.amount
    m.currency = entity.price.currency
    m.is_public = entity.is_public
    return m
```

---

### A-6. 경계 추상화(포트/리포지토리 인터페이스)

```python
# apps/catalog/domain/ports.py
from typing import Protocol, Iterable
from .entities import Product

class ProductRepository(Protocol):
    def get(self, product_id: int) -> Product: ...
    def list_public(self, limit: int = 50) -> Iterable[Product]: ...
    def save(self, p: Product) -> Product: ...
```

```python
# apps/catalog/infra/repositories.py
from .models import ProductModel
from .mappers import to_entity, to_model
from apps.catalog.domain.ports import ProductRepository

class DjangoORMProductRepository(ProductRepository):
    def get(self, product_id: int):
        return to_entity(ProductModel.objects.get(pk=product_id))

    def list_public(self, limit: int = 50):
        qs = ProductModel.objects.filter(is_public=True).order_by("-id")[:limit]
        for r in qs:
            yield to_entity(r)

    def save(self, p):
        m = to_model(p)
        m.save()
        return to_entity(m)
```

---

### A-7. 애플리케이션 서비스(유스케이스)

```python
# apps/catalog/app/services.py
from dataclasses import dataclass
from apps.catalog.domain.entities import Product
from apps.catalog.domain.ports import ProductRepository
from shared.value_objects import Money

@dataclass
class CreateProductDTO:
    name: str
    price: int
    currency: str = "KRW"

class CatalogService:
    def __init__(self, repo: ProductRepository):
        self.repo = repo

    def create_product(self, dto: CreateProductDTO) -> Product:
        p = Product(id=None, name=dto.name, price=Money(dto.price, dto.currency))
        return self.repo.save(p)

    def publish(self, product_id: int):
        p = self.repo.get(product_id)
        if p.is_public:
            return p
        p.is_public = True
        return self.repo.save(p)
```

UI 레이어에서 주입:

```python
# apps/catalog/ui/views.py
from django.views.generic import View
from django.shortcuts import render, redirect, get_object_or_404
from apps.catalog.infra.repositories import DjangoORMProductRepository
from apps.catalog.app.services import CatalogService, CreateProductDTO

class ProductCreateView(View):
    def get(self, request):
        return render(request, "catalog/new.html")

    def post(self, request):
        svc = CatalogService(DjangoORMProductRepository())
        dto = CreateProductDTO(name=request.POST["name"], price=int(request.POST["price"]))
        p = svc.create_product(dto)
        return redirect("catalog:detail", p.id)
```

> **핵심**: UI는 **서비스**만 알고, 서비스는 **포트(리포지토리 인터페이스)** 만 알고, 구현은 **infra**가 담당.

---

## B. 폼/서비스/리포지토리/도메인 이벤트 — 실무 패턴

### B-1. 폼(Form)과 서비스의 역할 구분

- **폼**: **입력 검증**과 **표면적 데이터 정규화**.  
- **서비스**: **업무 규칙/트랜잭션 경계**.  
- **리포지토리**: DB 접근 캡슐화.

```python
# apps/catalog/ui/forms.py
from django import forms

class ProductForm(forms.Form):
    name = forms.CharField(max_length=180)
    price = forms.IntegerField(min_value=0)
    currency = forms.ChoiceField(choices=[("KRW","KRW"), ("USD","USD")])
```

```python
# apps/catalog/ui/views.py (서비스 호출 전에 폼 검증)
class ProductCreateView(View):
    def post(self, request):
        form = ProductForm(request.POST)
        if not form.is_valid():
            return render(request, "catalog/new.html", {"form": form})
        svc = CatalogService(DjangoORMProductRepository())
        dto = CreateProductDTO(**form.cleaned_data)
        p = svc.create_product(dto)
        return redirect("catalog:detail", p.id)
```

> DRF에서는 Serializer가 폼 역할을 부분 대체. 핵심은 **UI 검증과 도메인 규칙 분리**.

---

### B-2. 트랜잭션 & 일관성 패턴

- **서비스**에서 `transaction.atomic()` 으로 **유스케이스 단위** 경계 설정.
- 후속 사이드이펙트는 **`on_commit`** 에 등록.

```python
# apps/orders/app/services.py
from django.db import transaction
from .ports import OrderRepository, PaymentGateway
from .entities import Order

class OrderService:
    def __init__(self, orders: OrderRepository, pay: PaymentGateway):
        self.orders = orders; self.pay = pay

    def pay_order(self, order_id: int):
        with transaction.atomic():
            o: Order = self.orders.get(order_id)
            if o.paid: return o
            r = self.pay.authorize(o.id, o.total.amount, o.total.currency)
            o.mark_authorized(r.tx_id)
            o = self.orders.save(o)
            transaction.on_commit(lambda: self._emit_paid(o))
            return o

    def _emit_paid(self, o: Order):
        # 도메인 이벤트 발행 (큐로 위임)
        from apps.orders.domain.events import order_paid
        order_paid.send(sender=Order.__class__, order_id=o.id)
```

---

### B-3. 리포지토리 테스트 더블(메모리/페이크)

- 도메인/서비스 테스트에서 **DB 의존 제거**.

```python
# tests/fakes.py
from apps.catalog.domain.ports import ProductRepository
from apps.catalog.domain.entities import Product
from shared.value_objects import Money

class InMemoryProductRepo(ProductRepository):
    def __init__(self):
        self.data = {}; self.next_id = 1
    def get(self, product_id: int) -> Product:
        return self.data[product_id]
    def list_public(self, limit: int = 50):
        return [p for p in self.data.values() if p.is_public][:limit]
    def save(self, p: Product) -> Product:
        if not p.id:
            p = Product(self.next_id, p.name, p.price, p.is_public); self.next_id += 1
        self.data[p.id] = p
        return p
```

```python
# tests/test_catalog_service.py
from apps.catalog.app.services import CatalogService, CreateProductDTO

def test_create_product_domain_only():
    repo = InMemoryProductRepo()
    svc = CatalogService(repo)
    p = svc.create_product(CreateProductDTO(name="X", price=1000))
    assert p.id == 1 and p.name == "X"
```

---

### B-4. 도메인 이벤트(Event) & 아웃박스(Outbox) 패턴

**문제**: 이벤트를 외부 시스템(메시지 브로커/웹훅)으로 전송할 때, DB 트랜잭션과 **원자성** 보장 필요.

**해결**: 이벤트 레코드를 같은 DB에 **아웃박스(outbox)** 테이블로 저장 → 별도 워커가 전달/삭제.

```python
# shared/outbox/models.py
from django.db import models

class OutboxEvent(models.Model):
    type = models.CharField(max_length=80)
    payload = models.JSONField()
    published = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
```

```python
# shared/outbox/api.py
from django.db import transaction
from .models import OutboxEvent

def add_outbox_event(type: str, payload: dict):
    def _save():
        OutboxEvent.objects.create(type=type, payload=payload)
    transaction.on_commit(_save)
```

서비스에서 사용:

```python
# apps/orders/app/services.py (일부)
from shared.outbox.api import add_outbox_event
...
transaction.on_commit(lambda: add_outbox_event("order_paid", {"order_id": o.id}))
```

워커(주기 실행):

```python
# shared/outbox/tasks.py
from celery import shared_task
from .models import OutboxEvent

@shared_task
def publish_outbox():
    for ev in OutboxEvent.objects.filter(published=False).order_by("id")[:100]:
        try:
            # 외부 브로커/웹훅 전송
            # post("https://...", json=ev.payload)
            ev.published = True
            ev.save(update_fields=["published"])
        except Exception:
            # 재시도/백오프
            pass
```

---

### B-5. 안티코럽션 레이어(ACL) — 외부 결제 연동

- **서비스는 인터페이스**(포트)만 알고, 구체 구현은 `infra.adapters` 로 격리.

```python
# apps/orders/domain/ports.py
from typing import Protocol

class PaymentGateway(Protocol):
    def authorize(self, order_id: int, amount: int, currency: str) -> "PaymentResult": ...

class PaymentResult:
    def __init__(self, ok: bool, tx_id: str | None = None):
        self.ok = ok; self.tx_id = tx_id
```

```python
# apps/orders/infra/adapters/iamport.py (예: 아임포트)
import requests
from apps.orders.domain.ports import PaymentGateway, PaymentResult

class IamportGateway(PaymentGateway):
    def __init__(self, api_key: str, api_secret: str):
        self.key, self.secret = api_key, api_secret

    def authorize(self, order_id: int, amount: int, currency: str) -> PaymentResult:
        # 토큰 발급 → 결제 승인 API 호출 (예시)
        # resp = requests.post(..., timeout=10)
        # ...
        return PaymentResult(ok=True, tx_id=f"imp_{order_id}")
```

UI/DI:

```python
# apps/orders/ui/views.py
from django.conf import settings
from apps.orders.infra.adapters.iamport import IamportGateway
from apps.orders.app.services import OrderService
from apps.orders.infra.repositories import DjangoORMOrderRepository

def pay_view(request, oid: int):
    svc = OrderService(DjangoORMOrderRepository(),
                       IamportGateway(settings.IAMPORT_KEY, settings.IAMPORT_SECRET))
    svc.pay_order(oid)
    # ...
```

---

### B-6. 서비스/리포지토리 로깅 & 관측성

- 서비스 시작/종료 시점, 입력 DTO, 결과 요약을 **구조화 로그**로 남깁니다.
- 도메인 이벤트는 **Sentry breadcrumb** 로도 유용.

```python
import structlog
log = structlog.get_logger(__name__)

class CatalogService:
    def create_product(self, dto):
        log.info("create_product.begin", name=dto.name, price=dto.price)
        p = ...
        log.info("create_product.end", id=p.id)
        return p
```

---

## C. 다국어(i18n) / 지역화(l10n) — 번역 워크플로우, 포맷

### C-1. 설정

```python
# settings/base.py
LANGUAGE_CODE = "ko"
USE_I18N = True
USE_L10N = True
USE_TZ = True
TIME_ZONE = "Asia/Seoul"

LANGUAGES = [
  ("ko", "Korean"),
  ("en", "English"),
  ("ja", "Japanese"),
]

LOCALE_PATHS = [BASE_DIR / "locale"]  # django.po 저장 위치
MIDDLEWARE = [
  "django.middleware.locale.LocaleMiddleware",
  # 언어 결정 순서: URL → 세션 → 쿠키 → 브라우저 → 기본값
]
```

URL에 언어코드 포함(선택):

```python
# config/urls.py
from django.conf.urls.i18n import i18n_patterns
urlpatterns = [
  # 기본(언어코드 없음)
]
urlpatterns += i18n_patterns(
  path("catalog/", include("apps.catalog.ui.urls", namespace="catalog")),
)
```

---

### C-2. 번역 마크업

파이썬 코드:

```python
from django.utils.translation import gettext_lazy as _
class ProductForm(forms.Form):
    name = forms.CharField(label=_("Product name"))
    price = forms.IntegerField(label=_("Price"))
```

템플릿:

```html
{% load i18n %}
<h1>{% trans "Product list" %}</h1>
<p>{% blocktrans with cnt=products|length %}There are {{ cnt }} products.{% endblocktrans %}</p>
```

컨텍스트 구분(동형 단어):

```python
from django.utils.translation import pgettext_lazy
label = pgettext_lazy("catalog button", "Order")  # '주문' vs '순서'
```

복수형:

```python
from django.utils.translation import ngettext
msg = ngettext("%(count)d item", "%(count)d items", count) % {"count": count}
```

---

### C-3. 메시지 추출/컴파일 워크플로우

```bash
# 루트에서
django-admin makemessages -l en -l ja
# locale/<lang>/LC_MESSAGES/django.po 생성 → 번역 → 저장
django-admin compilemessages
```

CI에 포함(권장):
- `makemessages` 변경 검사 → PR에 `.po` 업데이트 강제
- `compilemessages` 후 정적 자산 배포

---

### C-4. 지역화 포맷(날짜/숫자/통화)

템플릿 필터:

```html
{{ order.total|localize }}  {# 천 단위 구분자 #}
{{ order.created_at|date:"SHORT_DATE_FORMAT" }}
```

파이썬 API:

```python
from django.utils import formats, timezone
dt = timezone.now()
formatted = formats.date_format(dt, "DATETIME_FORMAT", use_l10n=True)
```

통화/숫자 세밀 제어(선택: Babel):

```python
# pip install Babel
from babel.numbers import format_currency
price_str = format_currency(1234567.8, "KRW", locale="ko_KR")  # ₩1,234,568
```

**주의**: 금액 계산은 항상 **정수(최소 통화단위)** 로 저장하고 표시만 포맷.

---

### C-5. 언어 선택 UI & 유지

```html
<form action="{% url 'set_language' %}" method="post">{% csrf_token %}
  <select name="language">
    {% get_current_language as LANGUAGE_CODE %}
    {% get_available_languages as LANGUAGES %}
    {% for code, name in LANGUAGES %}
      <option value="{{ code }}" {% if code == LANGUAGE_CODE %}selected{% endif %}>{{ name }}</option>
    {% endfor %}
  </select>
  <button>OK</button>
</form>
```

> `set_language` 뷰는 `LocaleMiddleware` 와 함께 작동하여 세션/쿠키에 언어 저장.

---

### C-6. 모델 번역(콘텐츠 i18n) — 간단 자체 구현

서드파티(django-parler, modeltranslation)를 써도 되지만, **원리**를 이해하기 위한 간단한 구현:

모델:

```python
# apps/catalog/infra/models.py
class ProductModel(models.Model):
    # 기본(기준) 언어 필드
    name = models.CharField(max_length=180)
    description = models.TextField(blank=True)
    # ...

class ProductI18n(models.Model):
    product = models.ForeignKey(ProductModel, on_delete=models.CASCADE, related_name="i18n")
    lang = models.CharField(max_length=5, db_index=True)  # 'en', 'ja', ...
    name = models.CharField(max_length=180)
    description = models.TextField(blank=True)

    class Meta:
        unique_together = [("product", "lang")]
```

리졸버:

```python
# apps/catalog/infra/i18n_resolver.py
from django.utils.translation import get_language

def resolve_product_text(p: ProductModel, lang: str | None = None):
    lang = lang or get_language() or "ko"
    tr = next((t for t in p.i18n.all() if t.lang == lang), None)
    if tr:
        return {"name": tr.name or p.name, "description": tr.description or p.description}
    return {"name": p.name, "description": p.description}
```

쿼리:

```python
qs = ProductModel.objects.prefetch_related("i18n")
for p in qs:
    text = resolve_product_text(p)  # 현재 언어
    print(text["name"])
```

Admin 인라인:

```python
class ProductI18nInline(admin.TabularInline):
    model = ProductI18n
    extra = 1
```

---

### C-7. 타임존/달력/형식 주의

- 사용자별 **timezone** 보관(프로필) → 미들웨어/컨텍스트에서 activation.

```python
from django.utils import timezone
from django.utils.deprecation import MiddlewareMixin

class UserTimezoneMiddleware(MiddlewareMixin):
    def process_request(self, request):
        tz = getattr(getattr(request, "user", None), "timezone", None)
        if tz: timezone.activate(tz)
        else: timezone.deactivate()
```

- 날짜 파싱/출력은 **naive ↔ aware** 변환 주의.
- 각 로케일별 **요일 시작 요일**, **숫자 구분자**, **AM/PM** 포맷 차이를 테스트로 커버.

---

### C-8. i18n 테스트

```python
from django.test import override_settings
from django.utils.translation import activate

def test_translated_label():
    activate("en")
    from apps.catalog.ui.forms import ProductForm
    f = ProductForm()
    assert str(f.fields["name"].label) == "Product name"
```

---

## D. 전반 체크리스트

**모듈러 구조/의존성**
- [ ] `ui → app → domain`, `infra` 는 구현만  
- [ ] 리포지토리/포트 인터페이스로 경계 유지  
- [ ] 값 객체로 핵심 타입 캡슐화

**서비스/트랜잭션/이벤트**
- [ ] 서비스는 **유스케이스 경계 + atomic + on_commit**  
- [ ] 무거운 작업은 **큐로 위임**, 아웃박스 패턴 고려  
- [ ] 이벤트/사이드이펙트는 **명시적** 으로

**폼/검증**
- [ ] 폼/Serializer: 입력 검증 & 정규화  
- [ ] 도메인 규칙은 **서비스/엔티티**에서

**i18n/l10n**
- [ ] `makemessages/compilemessages` 워크플로우  
- [ ] `pgettext/ngettext` 로 문맥/복수형 처리  
- [ ] 날짜/통화 **로케일 포맷** 및 타임존 활성화  
- [ ] DB 콘텐츠 번역(필요시 별도 테이블/라이브러리)

**테스트**
- [ ] 인메모리 리포지토리로 **순수 도메인 테스트**  
- [ ] i18n 활성화/비활성화 케이스  
- [ ] 트랜잭션/이벤트 on_commit 동작 검증

---

## E. 부록: 샘플 엔드투엔드(상품 생성 → 번역 추가 → 공개)

1) UI(Form)에서 입력 검증 → DTO 생성  
2) Service.create_product(dto) → Repo.save → on_commit 이벤트  
3) Admin에서 `ProductI18n` 인라인으로 번역 추가  
4) 목록/상세에서 `resolve_product_text` 로 현재 언어 텍스트 표시  
5) 테스트: `activate("en")` 후 이름이 영문으로 보이는지 확인

---

## F. 마이그레이션 전략(모델 분리 도입 시)

- 기존 `ProductModel.name`만 사용 → `ProductI18n` 추가  
- 단계:
  1) `ProductI18n` 테이블 추가, 코드에서 우선순위: `i18n.name or name`  
  2) 번역 데이터 백필  
  3) 필요한 경우 기준 언어를 `i18n(lang='ko')` 로 이동  
  4) 마지막에만 스키마 축소(옵션)

---

## G. FAQ

- **Django ORM을 굳이 리포지토리로 감싸야 하나요?**  
  - 작은 프로젝트는 직접 사용해도 무방. **중/대형**에서 테스트/교체 가능성/경계 관리가 필요하면 리포지토리 패턴이 이점.

- **엔티티/ORM 이중화가 번거롭습니다.**  
  - 혼합 접근 가능: **엔티티=ORM 모델**로 두되, **쿼리/저장 책임**만 `infra` 리포지토리에 모읍니다.

- **i18n이 많아 속도가 걱정됩니다.**  
  - `prefetch_related("i18n")` + **프래그먼트 캐시**. 번역 키는 **짧고 안정적**이어야 합니다.

---

## 마무리

- **경계가 선명한 구조**(UI→서비스→도메인, 구현=infra)와 **값 객체/이벤트**는 **유지보수성과 테스트성**을 비약적으로 높입니다.  
- 입력 검증(폼/Serializer)과 도메인 규칙(서비스/엔티티)을 나누고, 트랜잭션 경계에서 **on_commit + 아웃박스** 로 일관성을 확보하세요.  
- **i18n/l10n** 은 번역 워크플로우(추출/컴파일)와 로케일 포맷(날짜/통화/타임존)을 표준 방식으로 적용하고, 콘텐츠 번역은 테이블 분리/라이브러리로 설계하세요.
