---
layout: post
title: 디지털신호처리 - IIR 디지털 필터의 반올림 영향
date: 2025-11-19 23:25:23 +0900
category: 디지털신호처리
---
# IIR 디지털 필터의 반올림(라운딩) 영향

IIR(Infinite Impulse Response) 디지털 필터는 **적은 차수로 날카로운 주파수 특성**을 만들 수 있는 강력한 도구다.
하지만 IIR은 **피드백(재귀)** 구조 때문에, 유한 정밀도(고정소수점/부동소수점)에서 발생하는 **반올림(라운딩)·절단(truncation)·오버플로우(overflow)** 의 영향이 FIR보다 훨씬 크고 복잡하게 나타난다.

---

## 0) 유한 정밀도가 들어오는 지점: IIR에서 “두 종류의 잡음”

IIR 필터의 유한 정밀도 문제는 크게 두 층으로 나뉜다.

1. **입력 신호의 양자화 잡음(A/D 잡음)**
   - 아날로그 → 디지털 변환에서 생기는 잡음
   - 이미 앞 글에서 본 것처럼, 이상적으로는
     $$
     e_q[n] \sim \mathcal{U}\!\left(-\frac{\Delta}{2}, \frac{\Delta}{2}\right),
     \quad \sigma_q^2=\frac{\Delta^2}{12}
     $$
     로 모델링된다.
   - IIR은 이 잡음을 “신호처럼” 필터링한다.

2. **필터 내부 연산의 반올림/절단 잡음(roundoff noise)**
   - 매 곱셈, 매 덧셈, 매 상태 업데이트에서 발생
   - IIR에서는 이 잡음이 피드백을 타고 다시 들어와 **재귀적으로 증폭**될 수 있다.
   - 이 두 번째 잡음이 IIR 특유의 어려움을 만든다.

따라서 IIR 유한 정밀도 분석은
**(A) 입력 잡음이 필터를 통과할 때의 영향**과
**(B) 내부 연산 잡음이 출력에 더해지는 영향**을 반드시 분리해야 한다.

---

## 1) IIR 차분방정식과 반올림 오차의 삽입 위치

### 기본 IIR 차분방정식

차수 \(N\)인 IIR의 표준 형태는

$$
y[n] = -\sum_{k=1}^{N} a_k\,y[n-k] + \sum_{k=0}^{M} b_k\,x[n-k].
$$

- \(a_k\): 피드백(분모) 계수
- \(b_k\): 피드포워드(분자) 계수

이 식이 의미하는 바는

- 출력이 **과거 출력의 선형 결합**으로 다시 만들어진다.
- 즉, 내부 상태가 계속 순환하며 현재 출력에 영향을 준다.

### 반올림 오차의 “선형화 모델”

실제 고정소수점 시스템에서 연산 결과는 반올림을 거친다.
각 연산을 “정확값 + 작은 오차”로 쓸 수 있다.

예를 들어, DF-I 구조의 한 샘플 업데이트에서

- 피드포워드 합:
  $$
  s_x[n] = \sum_{k=0}^{M} b_k x[n-k] + \epsilon_x[n]
  $$
- 피드백 합:
  $$
  s_y[n] = \sum_{k=1}^{N} a_k y[n-k] + \epsilon_y[n]
  $$

라고 하면 실제 출력은

$$
y[n] = s_x[n] - s_y[n].
$$

여기서 \(\epsilon_x[n], \epsilon_y[n]\)는 각각 **피드포워드·피드백 경로에서 생긴 반올림 오차**를 대표하는 잡음 소스다.

### 반올림 잡음의 이상적 확률 가정

최근접 반올림(round-to-nearest)이라면, 한 번의 반올림 오차 \(\epsilon\)는

$$
\epsilon \sim \mathcal{U}\!\left(-\frac{u}{2},\frac{u}{2}\right),
\quad
\mathbb{E}[\epsilon]=0,
\quad
\sigma_\epsilon^2=\frac{u^2}{12}.
$$

- \(u\)는 내부 Q-format LSB 크기
- truncation은 평균이 0이 아니어서 바이어스가 쉽게 누적된다.

이 모델을 “선형화(roundoff-noise linear model)”라고 부른다.
IIR 반올림 분석의 표준 출발점이다.

---

## 2) IIR에서 반올림 영향이 FIR보다 큰 이유

### 피드백에 의한 잡음 재순환

FIR에서는 내부 반올림 잡음이 **한 번 출력으로 가면 끝**이다.
하지만 IIR에서는

- 내부 잡음이 출력으로 나감
- 그 출력이 다음 스텝에서 다시 피드백 입력으로 들어옴
- 잡음이 필터의 극점(poles) 구조에 따라 **지속적으로 누적·증폭**

된다.

즉, IIR 내부 잡음은

$$
y_\epsilon[n] = H(z)\,\epsilon[n]
$$

형태로 필터를 다시 한 번 거쳐 출력에 나타난다.
극점이 단위원에 가깝다면 \(H(z)\)의 에너지가 커져 **잡음 이득**이 폭증한다.

### 잡음 이득(noise gain)

입력 백색잡음이 PSD \(S_\epsilon\)를 가질 때 출력 잡음 파워는

$$
\sigma_{y,\epsilon}^2
=
\frac{1}{2\pi}\int_{-\pi}^{\pi} |H(e^{j\omega})|^2 S_\epsilon \, d\omega
=
\sigma_\epsilon^2\,G_H
$$

$$
G_H \equiv \frac{1}{2\pi}\int_{-\pi}^{\pi} |H(e^{j\omega})|^2 d\omega.
$$

- FIR: \(G_H=\sum h[k]^2\)로 유한하고 보통 비교적 작다.
- IIR: \(h[n]\)이 무한이어서 \(G_H\)가 **극점 위치에 매우 민감**하다.

특히 **단위원 근처의 pole**은

- 통과대역 리플이나 경계가 날카로워지는 대신
- 내부 잡음도 크게 증폭시키는 trade-off를 만든다.

---

## 3) 구조별 반올림 영향

IIR은 같은 \((b,a)\)라도 구조에 따라 내부 상태의 크기와 잡음 경로가 달라진다.

### Direct Form I (DF-I)

DF-I은 피드포워드와 피드백 지연선을 분리한다.

텍스트 구조(2차 예):

```text
x ─▶(FIR 부분)──▶(+)──▶ y
          ▲        │
          │        ▼
      (IIR 피드백 부분)
```

특징:

- 상태(지연)가 **입력측/출력측** 두 줄에 나눠짐 → 내부 노드 수가 많다.
- 내부 반올림 잡음 소스가 많아지고, 덧셈 깊이가 커진다.
- 대신 각 노드의 의미가 비교적 직관적이다.

### Direct Form II (DF-II)

DF-II는 지연선을 공유해 상태 수를 최소화한다.

특징:

- 메모리 최소
- 하지만 **중간 상태(w[n])의 동적범위가 커지기 쉬움**
- 고정소수점에서 오버플로우/라운딩 잡음이 더 커지는 경우가 많다.

### Direct Form II Transposed (DF-II-T)

DF-II의 전치 구조.

특징:

- 실제 하드웨어에서 가장 널리 쓰이는 IIR 구조 중 하나
- 누산 경로가 분명하고 파이프라인화가 쉽다.
- 내부 상태 스케일링을 잡기 좋다.
- 그럼에도 **극점 근처에서는 라운딩 잡음 순환 문제**가 여전히 남는다.

### SOS(Second-Order Sections) 캐스케이드

고차 IIR은 반드시 2차 섹션(바이쿼드)으로 분해해 구현한다.

$$
H(z)=g\prod_{i=1}^{K}
\frac{b_{0i}+b_{1i}z^{-1}+b_{2i}z^{-2}}
{1+a_{1i}z^{-1}+a_{2i}z^{-2}}.
$$

장점:

- 각 섹션이 낮은 차수라
  - 내부 상태가 작아지고
  - 오버플로우/라운딩에 더 강해진다.
- 섹션별로 스케일링해 동적범위를 제어할 수 있다.
- 구현 표준.

---

## 4) IIR 반올림 영향의 대표적 현상

### 출력 잡음 상승(Noise floor rise)

가장 흔한 결과는

- 내부 라운딩 잡음이 필터를 타고 출력으로 섞임
- 출력 스펙트럼에서 잡음 플로어가 상승

하는 것이다.

특히 통과대역이 좁거나 극점이 날카롭다면
대역 내 잡음이 크게 커질 수 있다.

### 바이어스/드리프트(DC drift)

절단(truncation)이나 비대칭 라운딩을 쓰면

- 오차의 평균이 0이 아니게 되고
- 피드백을 통해 누적되며
- 출력 평균이 천천히 치우친다.

이는 제어·계측 시스템에서 매우 위험하다.

### 한정주기(limit cycle)

IIR의 가장 악명 높은 현상.

- 입력이 **0인데도** 출력이 0으로 수렴하지 않고
- 작은 진동/주기파가 계속 남는다.

원인:

- 피드백 루프가 반올림 오차를 “입력처럼” 계속 받아
  자기 자신을 구동하는 상황이 만들어지기 때문.

limit cycle은

- 극점이 단위원 근처일수록
- 정밀도(F)가 낮고 truncation/랩어라운드를 쓸수록
- 내부 상태가 큰 DF-II 구조일수록

잘 발생한다.

### 극점 이동(pole migration)

계수를 고정소수점으로 양자화하면

- 실제 구현된 계수 \(\hat{a}_k\)가 원래 계수와 달라지고
- 결과적으로 극점 위치가 이동한다.

\[
a_k \to \hat{a}_k = a_k + \delta a_k
\]

단위원 근처의 pole은 작은 \(\delta a_k\)에도 크게 이동해
리플·경계·대역폭이 변하거나 심하면 불안정해질 수 있다.

이 문제는 “계수 양자화” 쪽이지만,
반올림 잡음과 함께 실무에서 동시에 고려된다.

---

## 5) GNU Octave 실험 1 — DF-I vs DF-II-T 반올림 잡음 비교

### 고정소수점 라운딩 함수(Q-format)

```octave
function y = q_frac(x, F)
  scale = 2^F;
  y = round(x*scale)/scale;
end
```

### DF-I 고정소수 IIR 시뮬레이터(일반형)

```octave
function y = iir_df1_fixed(b, a, x, F)
  M = length(b)-1;
  N = length(a)-1;

  xdel = zeros(1,M);
  ydel = zeros(1,N);

  y = zeros(size(x));

  for n=1:length(x)
    tapsx = [x(n), xdel];
    tapsy = [0, ydel];   % y[n]은 아직 없음

    sx = 0; sy = 0;

    % feedforward
    for k=0:M
      prod = q_frac(b(k+1)*tapsx(k+1), F);
      sx   = q_frac(sx + prod, F);
    end

    % feedback (a(1)=1 가정)
    for k=1:N
      prod = q_frac(a(k+1)*tapsy(k+1), F);
      sy   = q_frac(sy + prod, F);
    end

    y(n) = q_frac(sx - sy, F);

    % update delays
    if M>0
      xdel(2:end)=xdel(1:end-1);
      xdel(1)=x(n);
    end
    if N>0
      ydel(2:end)=ydel(1:end-1);
      ydel(1)=y(n);
    end
  end
end
```

### DF-II-T SOS 고정소수 실행기

```octave
function y = sos_df2t_fixed(sos, g, x, F)
  scale = 2^F;

  for s=1:rows(sos)
    b0=sos(s,1); b1=sos(s,2); b2=sos(s,3);
    a0=sos(s,4); a1=sos(s,5); a2=sos(s,6);
    w1=0; w2=0;

    xin = x;
    xout = zeros(size(x));

    for n=1:length(x)
      w0 = xin(n) - a1*w1 - a2*w2;
      w0 = round(w0*scale)/scale;

      y0 = b0*w0 + b1*w1 + b2*w2;
      y0 = round(y0*scale)/scale;

      w2=w1; w1=w0;
      xout(n)=y0;
    end
    x = xout;
  end

  y = g*xout;
end
```

### 비교 실험

```octave
clear; close all; clc; pkg load signal

Fs=48000; N=Fs/2; n=0:N-1; t=n/Fs;
x = 0.6*sin(2*pi*1000*t) + 0.2*sin(2*pi*12000*t);

% 6차 Chebyshev I LPF (날카로운 pole)
[b,a] = cheby1(6, 0.5, 4000/(Fs/2));
[sos,g] = tf2sos(b,a);

y_float = filter(b,a,x);

F=12;  % 소수부 12비트
y_df1  = iir_df1_fixed(b,a,x,F);
y_sos  = sos_df2t_fixed(sos,g,x,F);

e_df1 = y_df1 - y_float;
e_sos = y_sos - y_float;

fprintf("DF-I  roundoff var = %.3e\n", var(e_df1));
fprintf("SOS DF-II-T roundoff var = %.3e\n", var(e_sos));

figure;
subplot(2,1,1); plot(e_df1); title("DF-I roundoff error");
subplot(2,1,2); plot(e_sos); title("SOS DF-II-T roundoff error");
```

관찰 포인트:

- 동일한 필터인데도 SOS/DF-II-T 구현이 **라운딩 잡음이 훨씬 작게** 나오는 경우가 많다.
- 고차 필터일수록 SOS 분해 이점이 커진다.

---

## 6) GNU Octave 실험 2 — limit cycle(무입력 진동) 재현

```octave
clear; close all; clc; pkg load signal

Fs=48000; N=20000;
x = zeros(1,N);
x(1)=1e-3;   % 작은 초기 충격

[b,a] = butter(4, 1000/(Fs/2)); % 비교적 낮은 컷오프
[sos,g] = tf2sos(b,a);

for F=[8 10 12]
  y_fix = sos_df2t_fixed(sos,g,x,F);

  figure; plot(y_fix);
  title(sprintf("Limit cycle check: F=%d",F));
  xlabel("n"); ylabel("y[n]");
  grid on
end
```

- \(F=8\) 정도로 낮추면 무입력에서도 작은 주기 진동이 남는 경우가 흔하다.
- \(F\)가 늘수록 진동이 사라지거나 잡음 플로어 수준으로 줄어든다.

---

## 7) GNU Octave 실험 3 — pole radius가 라운딩 잡음에 미치는 영향

극점 반경 \(r\)이 커질수록(단위원 근처일수록) 잡음 이득이 커진다.

### 2차 공진기 테스트

```octave
clear; close all; clc

Fs=48000; N=Fs/2; n=0:N-1; t=n/Fs;
x = randn(size(t))*0.1;  % 약한 잡음 입력(내부 잡음 관측 용)

w0 = 2*pi*2000/Fs;       % 공진 주파수
F=12;

r_list = [0.7 0.9 0.97 0.99];
for r=r_list
  % 2차 IIR resonator:
  % H(z)=1 / (1 - 2r cos(w0) z^-1 + r^2 z^-2)
  b=[1 0 0];
  a=[1, -2*r*cos(w0), r^2];

  y_float = filter(b,a,x);
  y_fix   = iir_df1_fixed(b,a,x,F);

  e = y_fix - y_float;

  fprintf("r=%.2f -> roundoff var=%.3e\n", r, var(e));
end
```

결과 경향:

- \(r=0.7\): 라운딩 잡음 작음
- \(r\to 1\): **라운딩 잡음 급증**, limit cycle 위험도 함께 상승

즉, “날카로운 공진/경계”를 만들수록 유한 정밀도 비용이 커진다.

---

## 8) IIR 반올림 영향 완화 기법

### SOS 캐스케이드 + 섹션 스케일링

각 바이쿼드 내부 상태가 너무 커지면 라운딩·오버플로우가 악화된다.

- 섹션별로 이득을 분배해
- 내부 노드의 최대값을 1 근처로 유지

하도록 스케일링한다.

실무 절차(개념):

1. \(H(z)\)를 SOS로 분해
2. 섹션별 내부 노드의 peak/RMS 측정
3. 섹션마다 gain을 조정해 동적범위를 균등화
4. 최종 전체 gain으로 보정

### 구조 선택

일반적으로 고정소수점 IIR 구현 우선순위:

1. **SOS + DF-II-T**
2. **SOS + DF-I(필요 시)**
3. 고차 direct-form 단독 구현은 피함

### 라운딩 정책

- round-to-nearest(무바이어스)
- guard bits(누산 비트 여유)
- saturation overflow(포화)
- dithering(특정 오디오/계측에서 왜곡 완화)

### 극점 안정 여유 확보

- pole radius를 너무 1에 붙이지 않음
- 통과대역 성능 ↔ 잡음·limit cycle 사이에서 설계 타협

---

## 9) 실무 설계 흐름(반올림 관점)

1. **필터 사양 확정**
   - 통과대역/저지대역 리플, 차수 목표
2. **아날로그 원형 설계 → 디지털 변환**
3. **SOS 분해**
4. **구현 구조 선택(DF-II-T)**
5. **고정소수점 비트폭/스케일링 설계**
6. **반올림/오버플로우 정책 결정**
7. **시뮬레이션으로**
   - 잡음 플로어
   - SNR/THD+N
   - limit cycle
   - 극점 이동/안정성
   검증
8. **필요시 재설계(차수/사양/구조 조정)**

이 루프를 돌리면서 “유한 정밀도에서 성능이 유지되는 설계”를 찾는다.

---

## 10) 연습문제(문제 + 풀이)

### 문제 1

4차 Butterworth LPF를 \(Fs=48\,kHz\), \(f_c=3\,kHz\)로 설계하고,
SOS+DF-II-T 고정소수점 구현에서 \(F=8,10,12\)일 때 라운딩 잡음 분산을 비교하라.

**풀이 코드**

```octave
clear; close all; clc; pkg load signal
Fs=48000; fc=3000;
[b,a] = butter(4, fc/(Fs/2));
[sos,g] = tf2sos(b,a);

N=Fs/2; n=0:N-1;
x = randn(1,N)*0.2;

y_float = filter(b,a,x);

for F=[8 10 12]
  y_fix = sos_df2t_fixed(sos,g,x,F);
  e = y_fix - y_float;
  fprintf("F=%d -> var(e)=%.3e\n", F, var(e));
end
```

---

### 문제 2

문제 1의 필터에서 입력을 0으로 두고 작은 초기 충격만 주어
limit cycle 발생 여부를 확인하라.

**풀이 코드**

```octave
clear; close all; clc; pkg load signal
Fs=48000; fc=3000;
[b,a] = butter(4, fc/(Fs/2));
[sos,g] = tf2sos(b,a);

N=20000;
x=zeros(1,N); x(1)=1e-3;

for F=[8 10 12]
  y_fix = sos_df2t_fixed(sos,g,x,F);
  figure; plot(y_fix);
  title(sprintf("limit cycle check F=%d",F));
end
```

---

### 문제 3

2차 공진기
\[
H(z)=\frac{1}{1-2r\cos\omega_0 z^{-1}+r^2 z^{-2}}
\]
에서 \(r=[0.8,0.9,0.98]\)일 때
고정소수 라운딩 잡음이 어떻게 변하는지 측정하라.

**풀이**는 §7 실험 코드 그대로 사용하면 된다.

---

## 11) 전체 정리

IIR 필터에서 반올림 영향이 중요한 이유는 단 하나다.

- **피드백이 반올림 오차를 다시 시스템 안으로 집어넣기 때문**이다.

그 결과

1. 출력 잡음 플로어 상승
2. truncation 기반 바이어스 누적
3. 무입력 한정주기(limit cycle)
4. 극점 이동/불안정 위험

이 FIR보다 훨씬 쉽게 나타난다.

따라서 실무 IIR 구현의 정석은

- **SOS 분해**
- **DF-II Transposed**
- **섹션별 스케일링**
- **최근접 반올림 + 가드비트**
- **포화 오버플로우**
- **limit cycle/잡음 시뮬레이션 검증**

이라는 하나의 묶음으로 굳어져 있다.

이 글의 Octave 실험들을 직접 돌려 보면
“극점이 날카롭고 차수가 높을수록 왜 IIR이 유한 정밀도에 민감한지”를
수치·스펙트럼·시간 영역에서 한 번에 체감할 수 있을 것이다.
