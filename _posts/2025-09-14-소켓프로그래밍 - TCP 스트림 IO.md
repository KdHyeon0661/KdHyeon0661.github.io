---
layout: post
title: 소켓프로그래밍 - TCP 스트림 I/O
date: 2025-09-14 18:25:23 +0900
category: 소켓프로그래밍
---
# TCP 스트림 I/O — 블로킹의 본질과 부분 입출력

## 0. 들어가기 — 왜 TCP 스트림 I/O를 제대로 이해해야 하는가

TCP로 프로토콜을 설계하다가 흔히 겪는 문제들:

- `recv()` 를 한 번만 호출했는데 **메시지의 반만** 들어온다.
- `send()` 를 호출했는데 **보낸 양만큼 다 보내지 않고** 중간에 멈춘다.
- 한쪽에서 `close()` 를 했는데, 다른 쪽에서는 **언제까지 읽을 수 있는지** 감이 안 잡힌다.
- 길이-프리픽스를 붙였는데, 도중에 연결이 끊기면 **프레임이 절반만 들어와 있는 상태**가 된다.

이 모든 질문의 공통 분모는:

1. **TCP는 바이트 스트림이다** (메시지 경계가 없다).
2. **커널 버퍼와 TCP 상태 머신이 어떻게 움직이는지** 이해해야 한다.
3. 그 위에 **프레이밍 + 안전한 입출력 루틴**을 올려야 한다.

이 글은 이 세 가지를 하나씩 연결해서 정리한다.

---

## 1. 스트림은 경계가 없다: **부분 쓰기/읽기**가 왜 발생하는가

### 1.1 = 흐르는 바이트, 경계 없음

- TCP는 **바이트 스트림**이다. 응용이 `send()` 를 1회 호출했다고 해서  
  **네트워크 상에서도 1회** 전송된다는 보장은 없다.
- 커널은 송신 버퍼/혼잡 제어/상대 윈도우 등에 따라  
  **임의 크기로 쪼개거나 합쳐** TCP 세그먼트를 만든다.
- 수신 측에서 `recv()` 를 한 번 호출했을 때,
  - **얼마나 많은 바이트가 한 번에 들어올지**는 커널이 결정한다.
  - 호출 시점에 수신 버퍼에 쌓여 있는 만큼만 반환한다.

즉, 다음 둘은 완전히 다른 이야기다:

- “응용이 `send()` 를 호출한 횟수/크기”
- “TCP가 실제로 네트워크에 흘려보낸 세그먼트의 개수/크기”

TCP는 “**흐르는 바이트 파이프**”에 가깝다.  
UDP가 “데이터그램(메시지) 단위”라면, TCP는

> 어느 쪽에서나 끊어서 **조각을 떠다 줄 수 있는 긴 바이트 파이프**

라고 생각하는 편이 좋다.

---

### 1.2 커널 관점의 데이터 흐름 — 송신

응용 코드가 다음을 호출한다고 하자.

```cpp
const char* msg = "HELLO WORLD";
::send(fd, msg, std::strlen(msg), 0);
```

커널 내부에서는 대략 이런 일이 일어난다:

1. **사용자 공간 → 커널 공간 복사**
   - `msg` 의 내용을 **커널 송신 버퍼**(per-socket send buffer)에 복사한다.
2. **TCP 계층에서 세그먼트 생성**
   - `MSS(Maximum Segment Size)` 와 **현재 혼잡 윈도우(cwnd)**,  
     **상대의 receive window(rwnd)** 를 고려해 “이번에 내보낼 TCP 세그먼트” 크기를 결정한다.
3. **NIC로 전송**
   - 커널이 스케줄링에 따라 NIC로 TCP 세그먼트를 밀어 넣는다.
   - NIC/드라이버가 DMA 등으로 실제 전선을 통해 보낸다.

여기서 중요한 점:

- `send()` 는 “**송신 버퍼에 복사**가 완료되면” 성공했다고 보고 반환한다.
- `send()` 호출이 성공해도, 실제로 네트워크를 타고 나간 세그먼트는 **그 이후에 천천히** 나갈 수 있다.
- 송신 버퍼가 꽉 차 있거나, 혼잡 제어가 세게 걸려 있으면 `send()` 가
  - **일부만** 버퍼에 복사하고 반환하거나(부분 쓰기),
  - 블로킹 소켓이라면 **버퍼가 비워지길 기다리다가** 다시 시도한다.

---

### 1.3 커널 관점의 데이터 흐름 — 수신

수신 측 `recv(fd, buf, len, 0)` 은 다음 과정을 거친다.

1. NIC로 들어온 TCP 세그먼트들은 커널의 **수신 버퍼**에 쌓인다.
2. `recv()` 호출 시점에,
   - 수신 버퍼에 **당장 읽을 수 있는 만큼의 바이트**만큼 사용자 버퍼로 복사한다.
   - 복사한 만큼 수신 버퍼에서 제거한다.
3. 수신 버퍼가 비어 있다면:
   - **블로킹 소켓**: 새로운 세그먼트가 올 때까지 대기.
   - **논블로킹 소켓**: `EAGAIN` / `EWOULDBLOCK` 으로 즉시 반환.

여기서 **메시지 경계가 없기 때문에**:

- 송신 측에서 `send()` 한 번에 보낸 데이터가
  - 수신 측에서 여러 번의 `recv()` 로 나눠 들어올 수도 있고,
  - 여러 번의 `send()` 가 한 번의 `recv()` 에 몰려 들어올 수도 있다.
- 커널은 “**지금까지 도착해 버퍼에 있는 만큼**”만 복사해서 반환한다.  
  “논리적인 메시지 단위”는 신경 쓰지 않는다.

---

### 1.4 왜 `send()` 가 “부분만” 쓰는가 (short write)

블로킹 소켓이라고 해서 항상 `send()` 가 내가 원하는 바이트 수를 **한 번에** 다 보내주는 것은 아니다.  
다음 같은 이유로 **부분만 쓰고(return < len)** 돌아올 수 있다.

1. **송신 버퍼 여유 공간 부족**
   - 상대가 아주 느리게 읽거나, 윈도우 크기가 작거나, 네트워크가 혼잡하다면  
     커널 송신 버퍼가 꽉 차기 쉽다.
   - 이 경우 커널은
     - 이미 들어갈 수 있는 만큼만 복사하고,
     - 나머지는 나중에 다시 보내라고 응용에 돌려준다.

2. **EINTR (시그널로 인한 인터럽트)**
   - 시스템 콜 도중 프로세스가 시그널을 받으면,
     - 일부 바이트는 이미 복사되었는데,
     - 시스템 콜이 **조기 종료**되면서 `EINTR` 로 돌아올 수 있다.
   - POSIX 환경에서는 이 경우 **이미 보낸 바이트 수**를 응용이 확인해서  
     다시 이어서 보내야 한다.

3. **논블로킹 소켓 / 타임아웃 기반 소켓**
   - `O_NONBLOCK` 또는 `SO_SNDTIMEO` 가 설정되어 있으면,
     - 지금 가능한 만큼만 보낸 뒤 즉시 돌아오는 것이 정상이다.
   - 애초에 “부분 쓰기 + 재시도” 패턴을 전제로 설계해야 한다.

**정리**: TCP 스트림에서 **부분 쓰기(short write)** 는 예외가 아니라 **정상 동작**이다.  
그래서 항상 `send_all` 류의 래퍼를 써서 **루프를 돌며 전부 보낼 때까지 반복**해야 한다.

---

### 1.5 왜 `recv()` 가 “부분만” 읽히는가 (short read)

`recv()` 의 반환값이 항상 “내가 기대한 메시지 길이”가 아닐 수 있는 이유는:

1. **수신 버퍼에 지금 도착한 데이터가 그만큼뿐**이라서
   - 예를 들어 송신자가 1MB 를 보냈는데, 아직 4KB 정도만 도착해 있다면
     - `recv(fd, buf, 1_MB, 0)` 은 **4KB** 를 반환할 수 있다.
2. **커널은 “지금까지 도착한 바이트”만** 사용자 공간으로 복사하고 싶어함
   - “메시지를 다 받을 때까지 기다렸다가 한 번에 넘겨줄 것”이라는 계약이 없다.
3. **논블로킹 모드**
   - 수신 버퍼에 있는 것만큼만 복사하고 반환.
   - 없으면 `EAGAIN` 으로 즉시 리턴.

결과적으로:

- 송신 측이 `"HELLO"` 와 `"WORLD"` 를 따로 `send()` 했다 하더라도,
  - 수신 측에서는 `"HELLOW"` 가 한 번의 `recv()` 로 들어올 수 있다.
- 반대로 `"HELLO WORLD"` 를 한 번에 `send()` 했다고 해서,
  - 수신 측에서 그게 **딱 한 번의 `recv()`** 로 들어오는 보장은 없다.

---

### 1.6 프레이밍(메시지 경계)의 필연성

TCP 스트림에서 **메시지 경계**는 전적으로 **응용 프로토콜이 직접** 관리해야 한다.

대표적인 패턴들:

1. **길이-프리픽스(length-prefixed)**  
   - 헤더에 “이 뒤에 따라올 payload 의 길이”를 넣는 방식.
   - 예: 4바이트 빅엔디안 길이 + 길이만큼 payload.
2. **구분자 기반(delimiter-based)**  
   - 줄 단위 프로토콜(예: `\r\n` 로 끝나는 라인들).
   - SMTP, HTTP/1.x 의 헤더 부분, 여러 텍스트 프로토콜이 이런 형태.
3. **고정 길이(fixed-size records)**  
   - 각 레코드가 항상 같은 크기인 경우(예: 128바이트 레코드).
4. **TLV(Type-Length-Value)**  
   - 필드마다 (타입, 길이, 값) 트리플을 사용:
     - TYPE 1B, LENGTH 2B, VALUE N바이트 …를 나열.

이 글에서는 가장 일반적인 **4바이트 빅엔디안 길이-프리픽스**를 기준으로 설명한다.

---

## 2. 안전한 `send_all` / `recv_exact` 루틴의 형태

> **원칙**: TCP 스트림에서는 **부분 입출력**이 규범이다.  
> 원하는 바이트 수를 **반드시 충족**할 때까지 **루프**를 돈다.

### 2.1 C++23 바이트 중심 시그니처 설계

- **바이트 뷰**: `std::span<std::byte>` 를 사용해 “소유권 없는 바이트 배열”을 표현.
- **결과/오류**: `std::expected<T, std::error_code>` 로 성공/실패를 명시적으로 전달.

이를 바탕으로 블로킹 소켓을 전제로 한 `send_all`, `recv_exact`를 작성해 보자.

```cpp
// io_safe.hpp
#pragma once
#include <span>
#include <vector>
#include <expected>
#include <system_error>
#include <cerrno>
#include <cstddef>
#include <sys/socket.h>
#include <unistd.h>

inline std::error_code last_errno() {
    return std::error_code(errno, std::generic_category());
}

// 블로킹 전제의 안전한 "모두 보내기"
inline std::expected<std::size_t, std::error_code>
send_all(int fd, std::span<const std::byte> buf) {
    std::size_t sent = 0;
    while (sent < buf.size()) {
        ssize_t n = ::send(fd, buf.data() + sent, buf.size() - sent, 0);
        if (n > 0) {
            sent += static_cast<std::size_t>(n);
            continue;
        }
        if (n == 0) {
            // 전진 불능: 거의 안 나오지만, 여기선 루프를 빠져나가도록 처리
            break;
        }
        if (errno == EINTR) {
            // 시그널로 인터럽트 → 다시 시도
            continue;
        }
        // 그 밖의 에러는 즉시 종료
        return std::unexpected(last_errno());
    }
    return sent;
}

// 블로킹 전제의 "정확히 N바이트 받기"
inline std::expected<std::size_t, std::error_code>
recv_exact(int fd, std::span<stdbyte> buf) {
    std::size_t got = 0;
    while (got < buf.size()) {
        ssize_t n = ::recv(fd, buf.data() + got, buf.size() - got, 0);
        if (n > 0) {
            got += static_cast<std::size_t>(n);
            continue;
        }
        if (n == 0) {
            // 동료가 FIN을 보냈고, 커널 수신 버퍼가 비어 있으면 0 → 스트림 종료
            // 여기서는 "프레임을 다 받기도 전에 끊겼다"로 보고 에러 취급
            return std::unexpected(std::make_error_code(std::errc::connection_reset));
        }
        if (errno == EINTR) {
            // 시그널로 인터럽트 → 다시 시도
            continue;
        }
        return std::unexpected(last_errno());
    }
    return got;
}
```

> 구현 주의:
>
> - `recv_exact` 는 **정해진 길이를 받는 도중**에 0 바이트를 만나면
>   - “프레임이 끝나기도 전에 상대가 연결을 끊었다” → **프로토콜 오류**로 보는 것이 일반적이다.
> - `send_all` 에서의 `n == 0` 은 일반적으로 거의 나오지 않지만,  
>   여기서는 “진행이 불가능한 상황”으로 보고 루프를 빠져나가도록 처리했다.  
>   더 엄밀히 다루고 싶으면 `std::errc::connection_reset` 류의 에러로 변환해도 된다.

---

### 2.2 논블로킹/타임아웃 버전 설계 힌트

위 코드는 **블로킹 소켓**을 전제로 한다.  
논블로킹/데드라인 기반에서 쓰려면 보통 다음과 같이 확장한다.

- `send_all_with_deadline(fd, buf, deadline)`:
  - 내부에서 `poll/epoll` 로 **쓰기가 가능해질 때까지 대기**한 뒤,
  - 가능한 만큼 `send()` 하고, 전체 길이를 채울 때까지 반복.
- `recv_exact_with_deadline(fd, buf, deadline)`:
  - 내부에서 `poll/epoll` 로 **읽기가 가능해질 때까지 대기**한 뒤,
  - 필요한 만큼 `recv()` 하고, 전체 길이를 채울 때까지 반복.
- 데드라인을 넘으면 `std::errc::timed_out` 으로 종료.

논블로킹 소켓은 **항상 partial read/write + EAGAIN** 을 전제로 동작하므로,  
위 패턴은 필수적이다.

---

## 3. 길이-프리픽스 프레이밍(4바이트 빅엔디안)과 다른 패턴들

### 3.1 길이-프리픽스 패턴

가장 간단하고 강력한 패턴:

1. 먼저 “이 뒤에 올 payload 길이”를 4바이트 **빅엔디안**으로 보낸다.
2. 그 뒤 **payload 를 정확히 그 길이만큼** 보낸다.
3. 수신 측은:
   - 먼저 4바이트를 정확히 읽고(`recv_exact`),
   - 그 길이만큼 다시 `recv_exact` 를 해서 payload 를 읽는다.

```cpp
// framing.hpp
#pragma once
#include "io_safe.hpp"
#include <arpa/inet.h>    // htonl/ntohl
#include <cstring>

inline std::expected<void, std::error_code>
send_frame(int fd, std::span<const std::byte> payload) {
    uint32_t len = static_cast<uint32_t>(payload.size());
    uint32_t be  = htonl(len); // 네트워크 바이트 오더(빅엔디안)
    auto h = send_all(fd, std::as_bytes(std::span{&be, 1}));
    if (!h) return std::unexpected(h.error());

    auto b = send_all(fd, payload);
    if (!b) return std::unexpected(b.error());

    return {};
}

inline std::expected<std::vector<std::byte>, std::error_code>
recv_frame(int fd, std::size_t cap = (1u<<20)) {
    uint32_t be_len = 0;
    auto h = recv_exact(fd, std::as_writable_bytes(std::span{&be_len, 1}));
    if (!h) return std::unexpected(h.error());

    uint32_t len = ntohl(be_len); // 호스트 엔디안으로 복원
    if (len > cap) {
        // 메모리 고갈 방지
        return std::unexpected(std::make_error_code(std::errc::message_size));
    }

    std::vector<std::byte> buf(len);
    auto b = recv_exact(fd, std::span<std::byte>(buf.data(), buf.size()));
    if (!b) return std::unexpected(b.error());

    return buf;
}
```

#### 보안/안정성 포인트

- 반드시 **최대 허용 길이(cap)** 를 둔다.
  - 그렇지 않으면 공격자가 길이 필드를 크게 만들어 **OOM 유도** 가능.
- 길이 필드는 **네트워크 바이트 오더**로 고정해,  
  이기종(빅엔디안/리틀엔디안) 시스템 간에도 의미가 같도록 한다.

---

### 3.2 구분자 기반 프레이밍 예

줄 단위 텍스트 프로토콜(예: `\n` 또는 `\r\n` 으로 끝나는 라인들)을 생각해 보자.

```cpp
// 매우 단순한 '\n' 라인 리더(블로킹, 에러 처리 단순화)
std::expected<std::string, std::error_code>
recv_line(int fd, std::size_t cap = 4096) {
    std::string line;
    line.reserve(128);
    char ch;
    while (line.size() < cap) {
        ssize_t n = ::recv(fd, &ch, 1, 0);
        if (n > 0) {
            if (ch == '\n') break;
            line.push_back(ch);
        } else if (n == 0) {
            return std::unexpected(std::make_error_code(std::errc::connection_reset));
        } else if (errno == EINTR) {
            continue;
        } else {
            return std::unexpected(last_errno());
        }
    }
    return line;
}
```

단점:

- **N바이트 요청에 비해 시스템 콜 횟수가 많아질 수 있음**.
- 대량 데이터에는 부적합하지만, **명령/응답형 텍스트 프로토콜**에는 여전히 많이 쓰인다.

---

### 3.3 고정 길이 기록 프레이밍

예: 항상 “헤더 32바이트 + 바디 96바이트 = 128바이트”라면:

- `recv_exact(fd, 128바이트 버퍼)` 한 번이면 **항상 한 레코드**를 읽을 수 있다.
- 단, 데이터 구조를 바꾸고 싶을 때 유연성이 떨어진다.
- 바이너리 프로토콜에서 자주 쓰인다.

---

### 3.4 TLV (Type-Length-Value) 패턴

복잡한 바이너리 프로토콜에서:

- 여러 타입의 필드를 하나의 메시지 안에 섞어 넣고 싶을 때 유용하다.
- 예: `[TYPE(1B)][LEN(2B)][VALUE]` 를 반복.

```cpp
// 단순 TLV 디코더의 스케치
struct Tlv {
    uint8_t  type;
    uint16_t len;
    std::vector<std::byte> value;
};

std::vector<Tlv> parse_tlvs(std::span<const std::byte> frame) {
    std::vector<Tlv> out;
    std::size_t pos = 0;
    while (pos + 3 <= frame.size()) {
        Tlv t{};
        t.type = std::to_integer<uint8_t>(frame[pos]);
        uint16_t be_len;
        std::memcpy(&be_len, frame.data() + pos + 1, 2);
        t.len = ntohs(be_len);
        pos += 3;
        if (pos + t.len > frame.size()) break; // 잘못된 프레임
        t.value.assign(frame.begin() + pos, frame.begin() + pos + t.len);
        pos += t.len;
        out.push_back(std::move(t));
    }
    return out;
}
```

---

## 4. TCP 연결 수립: 3-way 핸드셰이크

TCP의 기본 연결 과정은 **3-way handshake** 이다.

### 4.1 흐름

텍스트 다이어그램:

```
클라이언트                              서버
-----------                            -----------

  CLOSED                               LISTEN

  SYN  --------------------------------->
         seq = x

                                       SYN-RECEIVED
         <---------------------------------  SYN + ACK
                                              seq = y
                                              ack = x+1

  ESTABLISHED
  ACK  --------------------------------->
         seq = x+1
         ack = y+1

                                       ESTABLISHED
```

핵심 포인트:

- 클라이언트/서버는 각각 자신이 사용할 **초기 시퀀스 번호(ISN)** 를 선택한다.
- 서로의 ISN 을 **ACK** 하면서 양쪽 모두 ESTABLISHED 상태가 된다.
- 이 핸드셰이크가 끝나야 양측은 **데이터를 자유롭게 주고받을 수 있다.**

---

### 4.2 RTT와 핸드셰이크 비용

간단히, 왕복 지연(RTT)은 핸드셰이크에 들어가는 **최소 비용**이다.

- 핸드셰이크에 대략 1 RTT.
- 그 다음 데이터 송수신에 또 RTT.
- 그래서 **짧은 연결을 많이 만드는 패턴**(예: HTTP/1.0 keep-alive 없는 경우)은  
  RTT 비용을 굉장히 크게 만든다.
- HTTP/2, HTTP/3, 연결 재활용 등의 이유가 여기에도 있다.

---

## 5. TCP 연결 종료: 4-way 핸드셰이크와 TIME_WAIT

### 5.1 일반적인 종료 흐름 (active close / passive close)

보통 한쪽이 먼저 `close()` 를 호출하면서 **active close** 를 시작한다.

```
클라이언트(active close)                서버(passive close)
-------------------------              ----------------------

ESTABLISHED                             ESTABLISHED

FIN ------------------------------------>
                                          수신: 더 이상 상대가 보낼 데이터 없음
         <---------------------------------- ACK

FIN_WAIT_1                              CLOSE_WAIT

                                        (서버는 응답을 계속 보낼 수 있음)

                                        FIN ------------------->
  ACK ----------------------------------->
FIN_WAIT_2                              LAST_ACK

TIME_WAIT                               CLOSED

(일정 시간 경과 후 CLOSED)
```

중요한 상태:

- **CLOSE_WAIT**:
  - 상대의 FIN 을 받고 ACK 까지 보냈지만,
  - 아직 `close()` 를 호출하지 않은 상태.
  - 응용이 늦게 `close()` 를 호출하면 오래 유지될 수 있다.
- **TIME_WAIT**:
  - **active close** 를 한 쪽이 들어가는 상태.
  - 최소 2 * MSL (Maximum Segment Lifetime) 동안 소켓을 유지한다.
  - 지연된/중복된 세그먼트가 잘못된 연결에 섞이지 않도록 하는 역할.

---

### 5.2 `shutdown()` 의 의미 (half-close)

`close(fd)` 는:

- 그 fd에 대한 **송신/수신 모두**를 닫고,
- 커널 객체 참조를 줄여, 0이 되면 실제 TCP 소켓을 정리한다.

반면 `shutdown()` 은 **방향(direction)** 을 제어한다.

- `shutdown(fd, SHUT_WR)`:
  - **송신 방향만 종료**.
  - 커널은 **FIN 세그먼트**를 보낸다.
  - 이후 `send()` 는 실패 (일반적으로 `EPIPE`).
  - 하지만 `recv()` 로 **상대가 보내는 데이터는 계속 읽을 수 있다**.
- `shutdown(fd, SHUT_RD)`:
  - **수신 방향만 종료**.
  - 커널은 이후 들어오는 데이터를 폐기한다.
  - `recv()` 는 바로 0 또는 에러.
- `shutdown(fd, SHUT_RDWR)`:
  - 양방향 종료(FIN 전송 + 더 이상 읽지 않음).

대표적인 패턴:

- 클라이언트가 요청을 전부 보낸 뒤,
  - 더 이상 보낼 게 없음을 알리기 위해 `shutdown(fd, SHUT_WR)` 호출.
  - 서버는 “요청 스트림이 끝났다”는 신호로 인식.
  - 서버는 응답을 전부 보내고, 자신도 `shutdown(fd, SHUT_WR)` 또는 `close()` 로 마무리.

---

## 6. 바이트 스트림과 종료 조건을 코드로 느끼기

TCP 스트림에서 “상대가 연결을 끊었다”는 것은 `recv()` 가 **0 바이트**를 반환하는 순간이다.

```cpp
std::array<std::byte, 4096> buf;
ssize_t n = ::recv(fd, buf.data(), buf.size(), 0);
if (n > 0) {
    // 실제 데이터 n 바이트
} else if (n == 0) {
    // 상대가 FIN 전송 → 더 읽을 데이터 없음
} else {
    // 에러 (EINTR, ECONNRESET 등)
}
```

프레이밍 도중이라면:

- 예: “길이-프리픽스 4바이트 + payload”를 읽는 도중 `n == 0` 을 만나면
  - “**프레임이 중간에 끊겼다**” → 프로토콜에서는 보통 에러로 처리해야 한다.

이는 앞서 `recv_exact` 에서 0 바이트를 `connection_reset` 류의 에러로 매핑한 이유다.

---

## 7. 가장 작은 블로킹 에코 서버/클라이언트 (C++23)

> 의도: **RAII + `getaddrinfo()` 루프 + 안전 I/O + 프레이밍**을 모두 담은 **초소형 레퍼런스**.  
> 플랫폼: 리눅스/유닉스 계열(POSIX).  
> 빌드: `g++ -std=c++23 -O2 echo.cpp -o echo`

### 7.1 전체 코드 (단일 파일: `echo.cpp`)

```cpp
// echo.cpp — C++23 블로킹 TCP 에코(프레이밍 4B + payload)
// 빌드: g++ -std=c++23 -O2 -Wall echo.cpp -o echo
// 사용:
//   서버: ./echo server 0.0.0.0 9000
//   클라: ./echo client 127.0.0.1 9000 "hello world"

#include <array>
#include <cerrno>
#include <cstring>
#include <expected>
#include <print>
#include <span>
#include <string>
#include <string_view>
#include <system_error>
#include <utility>
#include <vector>

// POSIX
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

// ----------------- 공통 유틸 -----------------
inline std::error_code last_errno() {
    return std::error_code(errno, std::generic_category());
}

struct unique_fd {
    int fd{-1};
    unique_fd() = default;
    explicit unique_fd(int f) : fd(f) {}
    unique_fd(const unique_fd&) = delete;
    unique_fd& operator=(const unique_fd&) = delete;
    unique_fd(unique_fd&& o) noexcept : fd(std::exchange(o.fd, -1)) {}
    unique_fd& operator=(unique_fd&& o) noexcept {
        if (this != &o) {
            if (fd != -1) ::close(fd);
            fd = std::exchange(o.fd, -1);
        }
        return *this;
    }
    ~unique_fd(){ if (fd != -1) ::close(fd); }
    void reset(int f=-1) noexcept { if (fd!=-1) ::close(fd); fd=f; }
    int  get() const noexcept { return fd; }
    explicit operator bool() const noexcept { return fd != -1; }
};

inline std::string to_string_sa(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{}, serv[NI_MAXSERV]{};
    if (::getnameinfo(sa, salen, host, sizeof(host), serv, sizeof(serv),
                      NI_NUMERICHOST | NI_NUMERICSERV) == 0) {
        return std::string(host) + ":" + serv;
    }
    return "(unknown)";
}

// 안전한 블로킹 I/O
inline std::expected<std::size_t, std::error_code>
send_all(int fd, std::span<const std::byte> buf) {
    std::size_t sent = 0;
    while (sent < buf.size()) {
        ssize_t n = ::send(fd, buf.data() + sent, buf.size() - sent, 0);
        if (n > 0) {
            sent += (std::size_t)n;
            continue;
        }
        if (n == 0) break;
        if (errno == EINTR) continue;
        return std::unexpected(last_errno());
    }
    return sent;
}

inline std::expected<std::size_t, std::error_code>
recv_exact(int fd, std::span<std::byte> buf) {
    std::size_t got = 0;
    while (got < buf.size()) {
        ssize_t n = ::recv(fd, buf.data() + got, buf.size() - got, 0);
        if (n > 0) {
            got += (std::size_t)n;
            continue;
        }
        if (n == 0) return std::unexpected(std::make_error_code(std::errc::connection_reset));
        if (errno == EINTR) continue;
        return std::unexpected(last_errno());
    }
    return got;
}

inline std::expected<void, std::error_code>
send_frame(int fd, std::span<const std::byte> payload) {
    uint32_t len = static_cast<uint32_t>(payload.size());
    uint32_t be  = ::htonl(len);
    auto h = send_all(fd, std::as_bytes(std::span{&be, 1}));
    if (!h) return std::unexpected(h.error());
    auto b = send_all(fd, payload);
    if (!b) return std::unexpected(b.error());
    return {};
}

inline std::expected<std::vector<std::byte>, std::error_code>
recv_frame(int fd, std::size_t cap = (1u<<20)) {
    uint32_t be_len = 0;
    auto h = recv_exact(fd, std::as_writable_bytes(std::span{&be_len, 1}));
    if (!h) return std::unexpected(h.error());
    uint32_t len = ::ntohl(be_len);
    if (len > cap) return std::unexpected(std::make_error_code(std::errc::message_size));
    std::vector<std::byte> buf(len);
    auto b = recv_exact(fd, std::span<std::byte>(buf.data(), buf.size()));
    if (!b) return std::unexpected(b.error());
    return buf;
}

// 주소 해석 RAII
struct addr_list {
    addrinfo* head{};
    addr_list() = default;
    addr_list(const addr_list&) = delete;
    addr_list& operator=(const addr_list&) = delete;
    ~addr_list(){ if (head) ::freeaddrinfo(head); }
};

inline std::expected<addr_list, std::error_code>
resolve(std::string_view host, std::string_view service,
        int family, int socktype, int flags) {
    addrinfo hints{};
    hints.ai_family   = family;
    hints.ai_socktype = socktype;
    hints.ai_protocol = 0;
    hints.ai_flags    = flags;

    addrinfo* res = nullptr;
    int rc = ::getaddrinfo(host.empty() ? nullptr : std::string(host).c_str(),
                           std::string(service).c_str(), &hints, &res);
    if (rc != 0) return std::unexpected(std::make_error_code(std::errc::invalid_argument));
    addr_list L; L.head = res; return L;
}

// ----------------- 서버 -----------------
inline std::expected<unique_fd, std::error_code>
listen_on(std::string_view bind_host, std::string_view port, int backlog=128) {
    auto R = resolve(bind_host, port, AF_UNSPEC, SOCK_STREAM,
                     AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV);
    if (!R) return std::unexpected(R.error());
    for (auto* ai = R->head; ai; ai = ai->ai_next) {
        unique_fd s{ ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol) };
        if (!s) continue;

        int yes = 1;
        ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        if (ai->ai_family == AF_INET6) {
            int v6only = 0; // v4-mapped 허용
            ::setsockopt(s.get(), IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
        }
        if (::bind(s.get(), ai->ai_addr, ai->ai_addrlen) != 0) {
            std::print(stderr, "[bind-fail] {} -> {}\n",
                       std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
            continue;
        }
        if (::listen(s.get(), backlog) != 0) {
            std::print(stderr, "[listen-fail] {} -> {}\n",
                       std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
            continue;
        }
        std::print("[listen-ok] {}\n", to_string_sa(ai->ai_addr, ai->ai_addrlen));
        return s;
    }
    return std::unexpected(std::make_error_code(std::errc::address_not_available));
}

inline int run_server(std::string_view bind_host, std::string_view port) {
    auto L = listen_on(bind_host, port);
    if (!L) {
        std::print(stderr, "listen failed: {}\n", L.error().message());
        return 1;
    }

    for (;;) {
        sockaddr_storage cli{}; socklen_t clen = sizeof(cli);
        int cfd = ::accept(L->get(), (sockaddr*)&cli, &clen);
        if (cfd < 0) {
            if (errno == EINTR) continue;
            std::print(stderr, "accept: {}\n", std::strerror(errno));
            continue;
        }

        unique_fd c{cfd};
        std::print("[accept] peer={}\n", to_string_sa((sockaddr*)&cli, clen));

        // 1 frame 받으면 그대로 1 frame 에코하고 종료(초소형 데모)
        auto frame = recv_frame(c.get());
        if (!frame) {
            std::print(stderr, "recv_frame: {}\n", frame.error().message());
            continue;
        }
        auto ok = send_frame(c.get(), std::span<const std::byte>(frame->data(), frame->size()));
        if (!ok) {
            std::print(stderr, "send_frame: {}\n", ok.error().message());
            continue;
        }
        // half-close 예시: 더 이상 보낼 게 없음을 통지
        ::shutdown(c.get(), SHUT_WR);
        std::print("[done] echoed {} bytes\n", frame->size());
    }
    return 0;
}

// ----------------- 클라이언트 -----------------
inline std::expected<unique_fd, std::error_code>
connect_to(std::string_view host, std::string_view port) {
    auto R = resolve(host, port, AF_UNSPEC, SOCK_STREAM, AI_ADDRCONFIG | AI_NUMERICSERV);
    if (!R) return std::unexpected(R.error());
    for (auto* ai = R->head; ai; ai = ai->ai_next) {
        unique_fd s{ ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol) };
        if (!s) continue;
        if (::connect(s.get(), ai->ai_addr, ai->ai_addrlen) == 0) {
            std::print("[connected] {}\n", to_string_sa(ai->ai_addr, ai->ai_addrlen));
            return s;
        }
        std::print(stderr, "[connect-fail] {} to {}\n",
                   std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
    }
    return std::unexpected(std::make_error_code(std::errc::host_unreachable));
}

inline int run_client(std::string_view host, std::string_view port, std::string msg) {
    auto S = connect_to(host, port);
    if (!S) {
        std::print(stderr, "connect failed: {}\n", S.error().message());
        return 1;
    }

    std::vector<std::byte> payload(msg.size());
    std::memcpy(payload.data(), msg.data(), msg.size());
    if (auto ok = send_frame(S->get(), payload); !ok) {
        std::print(stderr, "send_frame: {}\n", ok.error().message());
        return 2;
    }
    auto echo = recv_frame(S->get());
    if (!echo) {
        std::print(stderr, "recv_frame: {}\n", echo.error().message());
        return 3;
    }
    std::string echoed(reinterpret_cast<const char*>(echo->data()), echo->size());
    std::print("[echoed] {}\n", echoed);
    return 0;
}

// ----------------- main -----------------
int main(int argc, char** argv) {
    if (argc < 2) {
        std::print(stderr, "usage:\n");
        std::print(stderr, "  {} server <bind_addr> <port>\n", argv[0]);
        std::print(stderr, "  {} client <host> <port> <msg>\n",   argv[0]);
        return 1;
    }
    std::string mode = argv[1];
    if (mode == "server") {
        if (argc != 4) {
            std::print(stderr, "server args\n");
            return 1;
        }
        return run_server(argv[2], argv[3]);
    } else if (mode == "client") {
        if (argc != 5) {
            std::print(stderr, "client args\n");
            return 1;
        }
        return run_client(argv[2], argv[3], argv[4]);
    } else {
        std::print(stderr, "unknown mode\n");
        return 1;
    }
}
```

### 7.2 실행 예

```bash
# 터미널 1: 서버
./echo server 0.0.0.0 9000
# 출력 예:
# [listen-ok] 0.0.0.0:9000

# 터미널 2: 클라이언트
./echo client 127.0.0.1 9000 "HELLO-WORLD"
# 출력 예:
# [connected] 127.0.0.1:9000
# [echoed] HELLO-WORLD

# 서버 콘솔:
# [accept] peer=127.0.0.1:54321
# [done] echoed 11 bytes
```

---

## 8. 관측과 검증: tcpdump / Wireshark / ss / strace

### 8.1 패킷 흐름 보기 (tcpdump + Wireshark)

```bash
# 루프백에서 9000/TCP만 캡처해 파일로 저장
sudo tcpdump -i lo tcp port 9000 -n -vv -w trace.pcap
# 클라/서버를 실행한 뒤 Ctrl+C 로 종료,
# trace.pcap 을 Wireshark 로 열어서:
#   - 3-way 핸드셰이크
#   - 길이-프리픽스(4바이트)
#   - payload
#   - 4-way 종료
# 를 실제로 확인한다.
```

### 8.2 소켓 상태/큐 길이 보기 (`ss`)

```bash
ss -tanp '( sport = :9000 )'
# Recv-Q / Send-Q 를 보며 서버 소켓의 큐 상태를 관찰한다.
```

### 8.3 시스템 콜 수준 보기 (`strace`)

```bash
strace -f -e trace=network ./echo server 0.0.0.0 9000
# accept, recv, send, shutdown, close 호출 순서를 그대로 볼 수 있다.
```

이렇게 “위에서 본 개념”을 실제 커널/패킷 레벨에서 검증해 보면,  
**부분 쓰기/읽기, FIN, half-close** 개념이 훨씬 단단해진다.

---

## 9. 지연/처리량 직관: 수식으로 보는 TCP의 성격

### 9.1 대역폭–지연곱(BDP)

링크의 **대역폭–지연곱(Bandwidth–Delay Product)** 은 간단히:

$$
\text{BDP} = \text{Bandwidth} \times \text{RTT}
$$

- 단위:
  - Bandwidth: bit/s
  - RTT: s
  - BDP: bit (또는 Byte 로 환산)

예:

- 대역폭: 10 Mbps
- RTT: 100 ms
- 세그먼트(payload): 1000 byte 라 하면,

$$
\text{BDP} = 10 \times 10^6 \times 0.1 = 10^6 \text{ bit} \approx 125,000 \text{ byte}
$$

이를 세그먼트 크기로 나누면 약 125개.

- 즉, 파이프를 가득 채우려면 **동시에 125개 정도의 세그먼트**가 인플라이트 상태에 있어야 한다.
- Stop-and-Wait 패턴(항상 하나만 인플라이트)은 이론상 최대의 **1/125** 정도만 사용하게 된다.

### 9.2 손실 환경에서의 대략적인 처리량 감소

고전적인 이론 결과에 따르면(대략적인 직관):

$$
\text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}}
$$

- \( \text{MSS} \): 세그먼트 크기
- \( \text{RTT} \): 왕복 지연
- \( p \): 패킷 손실 확률

손실이 커지거나 RTT가 커지면 **제곱근 비율로 처리량이 급감**한다.  
이 때문에, 고손실/고지연 환경에서는:

- TCP의 기본 혼잡 제어 대신,
- QUIC 기반 프로토콜, 혹은 UDP 위에 직접 설계한 전송 계층(ARQ/FEC 혼합) 등이 고려되는 것이다.

---

## 10. 부분 읽기/쓰기 상황을 직접 재현하는 실험 시나리오

### 10.1 “부분 읽기” 재현

1. 서버에서:
   - `recv(fd, buf, 4)` 같은 **아주 작은 버퍼**로 반복 읽기를 구현.
2. 클라이언트에서:
   - 한 번에 수 KB ~ 수십 KB 를 `send_all` 하지 않고,
   - **`send(fd, buf, 큰_길이, 0)` 를 한 번만 호출**하고 종료.

관찰:

- 서버 로그에서 `recv()` 가 **4, 4, 4, 4, ...** 등의 단위로 잘게 잘려 들어오는 것을 볼 수 있다.
- Wireshark 에서 보면, TCP 세그먼트는 1KB 정도 단위로 왔는데,
  - 응용은 그보다 훨씬 잘게 쪼개서 읽고 있다는 것을 확인 가능.

### 10.2 `EINTR` 상황 재현

- 서버 프로세스에 `SIGUSR1` 을 주기적으로 보내면서(`kill -USR1 <pid>`),
- `recv()` / `send()` 에서 `EINTR` 가 발생하는지 확인.
- `strace` 로 보면 `EINTR` 로 종료되는 시스템 콜 기록이 있다.

이 실험을 통해:

- **EINTR 재시도** 로직을 넣지 않으면,
  - “가끔씩만 터지는 모호한 버그”를 만들 수 있다는 점을 체감할 수 있다.

---

## 11. 실전 디테일: Nagle, Delayed ACK, 작은 메시지

TCP는 작은 세그먼트 폭주를 막기 위해 여러 최적화/메커니즘을 갖고 있다.

### 11.1 Nagle 알고리즘

- 작은 세그먼트가 너무 많이 나가면 네트워크/라우터에 좋지 않으니,
  - 아직 미확인 ACK 가 있는 동안에는
  - **새로운 작은 세그먼트를 모아서 보낸다**는 아이디어.

일부 상황에서:

- “작은 메시지를 굉장히 자주 보내는 프로토콜”과
- “Delayed ACK” 이 상호작용하면 **지연이 눈에 띄게 늘어날 수 있다.**

### 11.2 대응책

1. 애플리케이션 레벨에서 **버퍼링(coalescing)**:
   - 여러 작은 메시지를 모아서 한 번에 보냄.
2. 소켓 옵션 `TCP_NODELAY`:
   - Nagle 을 끄고, “바로바로 보내기” (지연 감소, 세그먼트 수 증가).

둘 다 장단점이 있으므로, 실제 서비스에서는 **측정 기반으로 선택**해야 한다.

---

## 12. 체크리스트

TCP 스트림 I/O 를 설계/구현할 때 항상 점검해야 할 항목들이다.

### 12.1 I/O 레벨

- [ ] **부분 쓰기/읽기**를 전제로 `send_all` / `recv_exact` 류의 래퍼 사용.
- [ ] **프레이밍**(길이-프리픽스, 구분자, TLV 등) 설계.
- [ ] 엔디안 통일: 길이/숫자 필드는 **네트워크 바이트 오더(빅엔디안)** 로 전송 (`htonl/ntohl`).
- [ ] **EINTR 재시도** 처리.
- [ ] 필요 시 **논블로킹 + `poll/epoll` + 데드라인** 기반 루틴 구현.

### 12.2 종료/에러 처리

- [ ] `recv()` 가 0 → **상대 FIN** → 프레임 도중이라면 **프로토콜 에러**로 처리.
- [ ] `shutdown()` 의 의미(half-close)를 정확히 이해하고,  
      요청-응답형 프로토콜에서는 `SHUT_WR` 를 적절히 사용.
- [ ] `SIGPIPE` 방지:
  - Linux: `send(..., MSG_NOSIGNAL)` 또는 `signal(SIGPIPE, SIG_IGN)`.
  - BSD/macOS: `SO_NOSIGPIPE` 옵션.

### 12.3 디버깅/관측

- [ ] tcpdump/Wireshark 로 패킷 레벨을 확인해,  
      프레이밍/길이/시퀀스/FIN/ACK 가 설계대로 움직이는지 검증.
- [ ] `ss` 로 큐 길이, TCP 상태(TIME_WAIT 등)를 관찰.
- [ ] `strace` 로 `accept/recv/send/shutdown/close` 의 호출 순서를 이해.

---

## 13. 마무리

정리하면:

1. **TCP는 바이트 스트림**이다.  
   - 송수신에서 **부분 쓰기/읽기**는 예외가 아니라 **기본 동작**이다.
2. 커널이 관리하는 **송신/수신 버퍼, 혼잡 제어, 윈도우** 때문에,
   - `send()` 와 `recv()` 의 단위는 **세그먼트/메시지의 단위와 무관**하다.
3. 신뢰성 있는 응용 프로토콜을 만들려면:
   - **프레이밍(메시지 경계)** 을 직접 정의하고,
   - `send_all` / `recv_exact` 같은 **안전한 스트림 I/O 루틴**을 항상 사용해야 한다.
4. 3-way/4-way 핸드셰이크, `shutdown()` 을 이해하면:
   - “언제 연결이 수립되고, 언제 어느 방향이 닫히는지”를 코드에서 정확히 다룰 수 있다.
5. 이 글의 **에코 서버/클라이언트 예제**는
   - 실제 서비스 코드로 확장하기 위한 **최소 안전 템플릿**이다.
   - 여기에서 논블로킹/이벤트 루프, 타임아웃, TLS, 멀티스레드, 로깅 등을 차근차근 얹어 나가면 된다.
