---
layout: post
title: 소켓프로그래밍 - TCP 스트림 I/O
date: 2025-09-14 18:25:23 +0900
category: 소켓프로그래밍
---
## TCP 스트림 I/O — 블로킹의 본질과 부분 입출력

> 목표: **TCP는 “바이트 스트림”(경계 없음)** 임을 정확히 이해하고, 왜 **부분 쓰기/부분 읽기**가 발생하는지 커널 관점에서 설명한다. 이어서 **안전한 `send_all`/`recv_exact` 루틴**을 C++23로 구현하고, **3-way/4-way** 연결 수립/종료 및 **`shutdown()`(half-close)** 의 정확한 의미를 다룬다. 마지막으로 이 모든 것을 합친 **가장 작은 블로킹 에코 서버/클라이언트**를 제공한다.

---

### 스트림은 경계가 없다: **부분 쓰기/읽기**가 왜 발생하는가

#### 스트림(Stream) = 흐르는 바이트, 경계 없음

- TCP는 **바이트 스트림**이다. 응용이 `send()` 를 1회 호출했다고 해서 **네트워크 상으로도 1회** 전송되는 것이 아니다.
- 커널은 송신 버퍼/혼잡 제어/상대 윈도우 등에 따라 **임의 크기로 쪼개거나 합쳐** 전송한다. 수신 측에서도 `recv()` 호출 1회에 **얼마나 올지는 미정**이다.

#### 커널 관점의 데이터 흐름

- 사용자 공간 `send()` → **커널 송신 버퍼**에 적재 → 커널이 **MSS** 단위 등을 고려해 TCP 세그먼트 생성 → NIC로 전송
- 네트워크 → NIC → 커널 수신 버퍼 → 응용이 `recv()` 로 **복사**
- 이 과정에서 **세그먼트 단위**(패킷)와 **응용 호출 단위**는 무관하다.

#### 왜 `send()`가 “부분만” 쓰는가 (short write)

- **송신 버퍼 여유 부족**: 상대가 느리거나 윈도우가 작으면 커널 송신 버퍼가 찬다 → `send()` 가 일부만 쓰고 반환 (또는 블록)
- **신호(EINTR)**: 호출 도중 시그널로 인터럽트 → 이미 보낸 일부 바이트를 제외하고 조기 반환
- **타임아웃/논블로킹**: 논블로킹 또는 소켓 타임아웃 설정 시 “지금 가능한 만큼만” 쓰고 돌아온다

#### 왜 `recv()`가 “부분만” 읽히는가 (short read)

- 커널 수신 버퍼에 **현재 도착해 있는 바이트 수**만큼만 복사하고 즉시 반환한다(블로킹이라면 없으면 대기).
- “**메시지 경계가 없다**”는 사실 때문에, 한 `send()` 에서 보낸 ‘문자열 A’가 수신에서는 **여러 번의 `recv()` 로 나눠** 들어오기도 하고, 반대로 **여러 `send()` 가 한 번의 `recv()`** 로 뭉쳐 들어오기도 한다.

#### 프레이밍(메시지 경계)의 필연성

- TCP에서 **경계**는 응용이 **스스로** 만들어야 한다: 길이-프리픽스(4바이트), 구분자(`\n`), TLV 헤더 등.
- 길이-프리픽스의 핵심 예:
  1) 먼저 4바이트 **빅엔디안 길이**를 보낸다.
  2) 그 뒤 **payload** 를 정확히 그 길이만큼 보낸다.
  3) 수신 측은 **4바이트를 정확히 읽고(`recv_exact`)**, 그 길이만큼 **다시 정확히 읽는다**.

---

### 안전한 `send_all` / `recv_exact` 루틴의 형태

> **원칙**: TCP 스트림에서는 **부분 입출력**이 규범이다. 원하는 바이트 수를 **반드시 충족**할 때까지 **루프**를 돈다.

#### C++23 바이트 중심 시그니처

- `std::span<std::byte>` 를 사용해 **소유권 없는 바이트 뷰**를 전달.
- `std::expected<T, std::error_code>` 로 **성공/오류 흐름**을 명시.

```cpp
// io_safe.hpp
#pragma once
#include <span>
#include <vector>
#include <expected>
#include <system_error>
#include <cerrno>
#include <cstddef>
#include <sys/socket.h>
#include <unistd.h>

inline std::error_code last_errno() {
    return std::error_code(errno, std::generic_category());
}

// 블로킹 전제의 안전한 "모두 보내기"
inline std::expected<std::size_t, std::error_code>
send_all(int fd, std::span<const std::byte> buf) {
    std::size_t sent = 0;
    while (sent < buf.size()) {
        ssize_t n = ::send(fd, buf.data() + sent, buf.size() - sent, 0);
        if (n > 0) { sent += static_cast<std::size_t>(n); continue; }
        if (n == 0) break;                 // 드물지만 전진 불능
        if (errno == EINTR) continue;      // 시그널 재시도
        return std::unexpected(last_errno());
    }
    return sent;
}

// 블로킹 전제의 "정확히 N바이트 받기"
inline std::expected<std::size_t, std::error_code>
recv_exact(int fd, std::span<std::byte> buf) {
    std::size_t got = 0;
    while (got < buf.size()) {
        ssize_t n = ::recv(fd, buf.data() + got, buf.size() - got, 0);
        if (n > 0) { got += static_cast<std::size_t>(n); continue; }
        if (n == 0) {
            // 동료가 FIN을 보냈고, 커널 수신 버퍼가 비어 있으면 0 → 스트림 종료
            return std::unexpected(std::make_error_code(std::errc::connection_reset));
        }
        if (errno == EINTR) continue;
        return std::unexpected(last_errno());
    }
    return got;
}
```

##### 설계 포인트

- **EINTR**: 시그널 개입 시 다시 시도.
- **0 바이트 수신**: 상대가 **정상 종료(FIN)** 한 상태로, 더 읽을 데이터가 없는 것. **프로토콜의 관점**에서 조기 종료로 간주해 오류로 반환(프레이밍 도중이라면 특히 오류).

#### 길이-프리픽스 프레이밍(4바이트 빅엔디안)

```cpp
// framing.hpp
#pragma once
#include "io_safe.hpp"
#include <arpa/inet.h>    // htonl/ntohl
#include <cstring>

inline std::expected<void, std::error_code>
send_frame(int fd, std::span<const std::byte> payload) {
    uint32_t len = static_cast<uint32_t>(payload.size());
    uint32_t be  = htonl(len);
    auto h = send_all(fd, std::as_bytes(std::span{&be, 1}));
    if (!h) return std::unexpected(h.error());
    auto b = send_all(fd, payload);
    if (!b) return std::unexpected(b.error());
    return {};
}

inline std::expected<std::vector<std::byte>, std::error_code>
recv_frame(int fd, std::size_t cap = (1u<<20)) {
    uint32_t be_len = 0;
    auto h = recv_exact(fd, std::as_writable_bytes(std::span{&be_len, 1}));
    if (!h) return std::unexpected(h.error());
    uint32_t len = ntohl(be_len);
    if (len > cap) return std::unexpected(std::make_error_code(std::errc::message_size));
    std::vector<std::byte> buf(len);
    auto b = recv_exact(fd, std::span<std::byte>(buf.data(), buf.size()));
    if (!b) return std::unexpected(b.error());
    return buf;
}
```

##### 실무 팁

- **cap(최대 길이)** 는 필수. 악의적 길이로 **메모리 고갈**(OOM) 방지.
- `SIGPIPE` 방지(Linux): `send(..., MSG_NOSIGNAL)` 또는 `signal(SIGPIPE, SIG_IGN)` / BSD `SO_NOSIGPIPE`.

---

### 연결 수립/종료: 3-way/4-way, `shutdown()`의 의미

#### 3-way 핸드셰이크(연결 수립)

```
클라이언트        서버
   SYN  --------->
       <---------  SYN+ACK
   ACK  --------->
(ESTABLISHED)  (ESTABLISHED)
```
- **RTT** (왕복지연) ≈ SYN→SYN/ACK→ACK 완료까지의 대략적 시간.
- 핸드셰이크가 끝나야 **데이터 송수신**이 시작된다.

#### 4-way 종료(일반적)

```
클라이언트        서버
  FIN  ----------->
       <-----------  ACK
                    (서버 아직 보낼 게 있으면 계속 전송)
       <-----------  FIN
  ACK  ----------->
(CLOSED)        (CLOSED)
```
- **half-close** 단계가 존재: 한쪽이 먼저 `FIN`(= 더 이상 **보내지 않겠다**).
- 상대가 아직 보낼 게 있으면 그동안 **읽기는 가능**.

#### `shutdown()` 의 의미 (half-close)

- `shutdown(fd, SHUT_WR)` = **송신 종료**: 더 이상 보낼 수 없지만 **수신은 계속** 가능.
- `shutdown(fd, SHUT_RD)` = **수신 종료**: 더 이상 읽지 않겠다(커널이 이후 수신 데이터를 폐기).
- `shutdown(fd, SHUT_RDWR)` = 양방향 종료.

> 예시: 요청을 보내고(`SHUT_WR`) 상대 응답을 끝까지 읽은 뒤 `close()` 로 정리.

---

### 실습: **가장 작은 블로킹 에코 서버/클라이언트** (C++23)

> 의도: **RAII + `getaddrinfo()` 루프 + 안전 I/O + 프레이밍**을 모두 담은 **초소형 레퍼런스**.
> 플랫폼: 리눅스/유닉스 계열(POSIX).
> 빌드: `g++ -std=c++23 -O2 echo.cpp -o echo`

#### 전체 코드 (단일 파일: `echo.cpp`)

```cpp
// echo.cpp — C++23 블로킹 TCP 에코(프레이밍 4B + payload)
// 빌드: g++ -std=c++23 -O2 -Wall echo.cpp -o echo
// 사용:
//   서버: ./echo server 0.0.0.0 9000
//   클라: ./echo client 127.0.0.1 9000 "hello world"

#include <array>
#include <cerrno>
#include <cstring>
#include <expected>
#include <print>
#include <span>
#include <string>
#include <string_view>
#include <system_error>
#include <utility>
#include <vector>

// POSIX
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

// ----------------- 공통 유틸 -----------------
inline std::error_code last_errno() {
    return std::error_code(errno, std::generic_category());
}

struct unique_fd {
    int fd{-1};
    unique_fd() = default;
    explicit unique_fd(int f) : fd(f) {}
    unique_fd(const unique_fd&) = delete;
    unique_fd& operator=(const unique_fd&) = delete;
    unique_fd(unique_fd&& o) noexcept : fd(std::exchange(o.fd, -1)) {}
    unique_fd& operator=(unique_fd&& o) noexcept {
        if (this != &o) { if (fd != -1) ::close(fd); fd = std::exchange(o.fd, -1); }
        return *this;
    }
    ~unique_fd(){ if (fd != -1) ::close(fd); }
    void reset(int f=-1) noexcept { if (fd!=-1) ::close(fd); fd=f; }
    int  get() const noexcept { return fd; }
    explicit operator bool() const noexcept { return fd != -1; }
};

inline std::string to_string_sa(const sockaddr* sa, socklen_t salen) {
    char host[NI_MAXHOST]{}, serv[NI_MAXSERV]{};
    if (::getnameinfo(sa, salen, host, sizeof(host), serv, sizeof(serv),
                      NI_NUMERICHOST | NI_NUMERICSERV) == 0) {
        return std::string(host) + ":" + serv;
    }
    return "(unknown)";
}

// 안전한 블로킹 I/O
inline std::expected<std::size_t, std::error_code>
send_all(int fd, std::span<const std::byte> buf) {
    std::size_t sent = 0;
    while (sent < buf.size()) {
        ssize_t n = ::send(fd, buf.data() + sent, buf.size() - sent, 0);
        if (n > 0) { sent += (std::size_t)n; continue; }
        if (n == 0) break;
        if (errno == EINTR) continue;
        return std::unexpected(last_errno());
    }
    return sent;
}

inline std::expected<std::size_t, std::error_code>
recv_exact(int fd, std::span<std::byte> buf) {
    std::size_t got = 0;
    while (got < buf.size()) {
        ssize_t n = ::recv(fd, buf.data() + got, buf.size() - got, 0);
        if (n > 0) { got += (std::size_t)n; continue; }
        if (n == 0) return std::unexpected(std::make_error_code(std::errc::connection_reset));
        if (errno == EINTR) continue;
        return std::unexpected(last_errno());
    }
    return got;
}

inline std::expected<void, std::error_code>
send_frame(int fd, std::span<const std::byte> payload) {
    uint32_t len = static_cast<uint32_t>(payload.size());
    uint32_t be  = ::htonl(len);
    auto h = send_all(fd, std::as_bytes(std::span{&be, 1}));
    if (!h) return std::unexpected(h.error());
    auto b = send_all(fd, payload);
    if (!b) return std::unexpected(b.error());
    return {};
}

inline std::expected<std::vector<std::byte>, std::error_code>
recv_frame(int fd, std::size_t cap = (1u<<20)) {
    uint32_t be_len = 0;
    auto h = recv_exact(fd, std::as_writable_bytes(std::span{&be_len, 1}));
    if (!h) return std::unexpected(h.error());
    uint32_t len = ::ntohl(be_len);
    if (len > cap) return std::unexpected(std::make_error_code(std::errc::message_size));
    std::vector<std::byte> buf(len);
    auto b = recv_exact(fd, std::span<std::byte>(buf.data(), buf.size()));
    if (!b) return std::unexpected(b.error());
    return buf;
}

// 주소 해석 RAII
struct addr_list {
    addrinfo* head{};
    addr_list() = default;
    addr_list(const addr_list&) = delete;
    addr_list& operator=(const addr_list&) = delete;
    ~addr_list(){ if (head) ::freeaddrinfo(head); }
};

inline std::expected<addr_list, std::error_code>
resolve(std::string_view host, std::string_view service,
        int family, int socktype, int flags) {
    addrinfo hints{};
    hints.ai_family   = family;
    hints.ai_socktype = socktype;
    hints.ai_protocol = 0;
    hints.ai_flags    = flags;

    addrinfo* res = nullptr;
    int rc = ::getaddrinfo(host.empty() ? nullptr : std::string(host).c_str(),
                           std::string(service).c_str(), &hints, &res);
    if (rc != 0) return std::unexpected(std::make_error_code(std::errc::invalid_argument));
    addr_list L; L.head = res; return L;
}

// ----------------- 서버 -----------------
inline std::expected<unique_fd, std::error_code>
listen_on(std::string_view bind_host, std::string_view port, int backlog=128) {
    auto R = resolve(bind_host, port, AF_UNSPEC, SOCK_STREAM,
                     AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV);
    if (!R) return std::unexpected(R.error());
    for (auto* ai = R->head; ai; ai = ai->ai_next) {
        unique_fd s{ ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol) };
        if (!s) continue;

        int yes = 1;
        ::setsockopt(s.get(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        if (ai->ai_family == AF_INET6) {
            int v6only = 0; // 정책: v4-mapped 허용(플랫폼 정책을 명시적으로 고정)
            ::setsockopt(s.get(), IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
        }
        if (::bind(s.get(), ai->ai_addr, ai->ai_addrlen) != 0) {
            std::print(stderr, "[bind-fail] {} -> {}\n",
                       std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
            continue;
        }
        if (::listen(s.get(), backlog) != 0) {
            std::print(stderr, "[listen-fail] {} -> {}\n",
                       std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
            continue;
        }
        std::print("[listen-ok] {}\n", to_string_sa(ai->ai_addr, ai->ai_addrlen));
        return s;
    }
    return std::unexpected(std::make_error_code(std::errc::address_not_available));
}

inline int run_server(std::string_view bind_host, std::string_view port) {
    auto L = listen_on(bind_host, port);
    if (!L) { std::print(stderr, "listen failed: {}\n", L.error().message()); return 1; }

    for (;;) {
        sockaddr_storage cli{}; socklen_t clen = sizeof(cli);
        int cfd = ::accept(L->get(), (sockaddr*)&cli, &clen);
        if (cfd < 0) { if (errno == EINTR) continue; std::print(stderr, "accept: {}\n", std::strerror(errno)); continue; }

        unique_fd c{cfd};
        std::print("[accept] peer={}\n", to_string_sa((sockaddr*)&cli, clen));

        // 1 frame 받으면 그대로 1 frame 에코하고 종료(초소형 데모)
        auto frame = recv_frame(c.get());
        if (!frame) { std::print(stderr, "recv_frame: {}\n", frame.error().message()); continue; }
        auto ok = send_frame(c.get(), std::span<const std::byte>(frame->data(), frame->size()));
        if (!ok) { std::print(stderr, "send_frame: {}\n", ok.error().message()); continue; }
        // half-close 예시: 더 이상 보낼 게 없음을 통지
        ::shutdown(c.get(), SHUT_WR);
        // 상대 FIN까지 읽어주려면 여기에 drain 루틴을 둘 수 있다(생략).
        std::print("[done] echoed {} bytes\n", frame->size());
    }
    return 0;
}

// ----------------- 클라이언트 -----------------
inline std::expected<unique_fd, std::error_code>
connect_to(std::string_view host, std::string_view port) {
    auto R = resolve(host, port, AF_UNSPEC, SOCK_STREAM, AI_ADDRCONFIG | AI_NUMERICSERV);
    if (!R) return std::unexpected(R.error());
    for (auto* ai = R->head; ai; ai = ai->ai_next) {
        unique_fd s{ ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol) };
        if (!s) continue;
        if (::connect(s.get(), ai->ai_addr, ai->ai_addrlen) == 0) {
            std::print("[connected] {}\n", to_string_sa(ai->ai_addr, ai->ai_addrlen));
            return s;
        }
        std::print(stderr, "[connect-fail] {} to {}\n",
                   std::strerror(errno), to_string_sa(ai->ai_addr, ai->ai_addrlen));
    }
    return std::unexpected(std::make_error_code(std::errc::host_unreachable));
}

inline int run_client(std::string_view host, std::string_view port, std::string msg) {
    auto S = connect_to(host, port);
    if (!S) { std::print(stderr, "connect failed: {}\n", S.error().message()); return 1; }

    std::vector<std::byte> payload(msg.size());
    std::memcpy(payload.data(), msg.data(), msg.size());
    if (auto ok = send_frame(S->get(), payload); !ok) {
        std::print(stderr, "send_frame: {}\n", ok.error().message()); return 2;
    }
    auto echo = recv_frame(S->get());
    if (!echo) { std::print(stderr, "recv_frame: {}\n", echo.error().message()); return 3; }
    std::string echoed(reinterpret_cast<const char*>(echo->data()), echo->size());
    std::print("[echoed] {}\n", echoed);
    // 예: 송신 끝났음을 알리고 응답만 더 받고 끊고 싶다면 SHUT_WR 등 정책 적용.
    return 0;
}

// ----------------- main -----------------
int main(int argc, char** argv) {
    if (argc < 2) {
        std::print(stderr, "usage:\n");
        std::print(stderr, "  {} server <bind_addr> <port>\n", argv[0]);
        std::print(stderr, "  {} client <host> <port> <msg>\n",   argv[0]);
        return 1;
    }
    std::string mode = argv[1];
    if (mode == "server") {
        if (argc != 4) { std::print(stderr, "server args\n"); return 1; }
        return run_server(argv[2], argv[3]);
    } else if (mode == "client") {
        if (argc != 5) { std::print(stderr, "client args\n"); return 1; }
        return run_client(argv[2], argv[3], argv[4]);
    } else {
        std::print(stderr, "unknown mode\n");
        return 1;
    }
}
```

#### 실행 예

```bash
# 터미널 1: 서버

./echo server 0.0.0.0 9000
# 출력 예:
# [listen-ok] 0.0.0.0:9000

# 터미널 2: 클라이언트

./echo client 127.0.0.1 9000 "HELLO-WORLD"
# 출력 예:
# [connected] 127.0.0.1:9000
# [echoed] HELLO-WORLD

# 서버 콘솔:
# [accept] peer=127.0.0.1:54321
# [done] echoed 11 bytes

```

---

### 관측과 검증: tcpdump / Wireshark / ss / strace

#### 패킷 흐름 보기

```bash
# 루프백에서 9000/TCP만 캡처해 파일로 저장

sudo tcpdump -i lo tcp port 9000 -n -vv -w trace.pcap
# 클라/서버를 실행한 뒤 종료(Ctrl+C), trace.pcap을 Wireshark로 열어
# 3-way, 데이터, 4-way를 확인한다.

```

#### 소켓 상태/큐 길이 보기

```bash
ss -tanp '( sport = :9000 )'
# Recv-Q / Send-Q 를 보며 서버의 큐 상태를 관찰

```

#### 시스템 콜 수준 보기

```bash
strace -f -e trace=network ./echo server 0.0.0.0 9000
# accept, recv, send, shutdown, close 흐름을 생생히 확인

```

---

### 실전 디테일: Nagle, Delayed ACK, 작은 메시지

- 작은 메시지를 매우 자주 보낼 때, **Nagle(작은 세그먼트 합치기)** 와 **Delayed ACK** 가 상호작용해 **지연**이 생길 수 있다.
- 대응책:
  - **버퍼링(coalescing)**: 응용 레벨에서 묶어서 전송
  - **`TCP_NODELAY`**: Nagle 끄기(지연 감소, 하지만 세그먼트 수 증가)
- 상황에 따라 성능/지연 트레이드오프가 있으므로 **측정 기반**으로 선택한다.

---

### 타임아웃/해프 클로즈/종료 절차 추천 패턴

- **요청-응답형** 프로토콜:
  1) 요청 한 덩어리 **프레이밍**으로 전송 (`send_frame`)
  2) **데드라인 기반**으로 응답 `recv_frame`
  3) 더 이상 보낼 게 없으면 `shutdown(fd, SHUT_WR)` 로 **송신만 종료**
  4) 상대 `FIN` 확인 후 `close()`
- **스트리밍형**은 별도 정책: keepalive/heartbeat, backpressure 시나리오, 재시도/멱등성 등의 규정이 필요.

---

### (보너스) 수식으로 보는 지연/처리량 직관

- 대역폭–지연곱(BDP):
  $$
  \text{BDP} = \text{Bandwidth} \times \text{RTT}
  $$
  링크/상대 윈도우/버퍼가 BDP에 미치지 못하면 파이프를 **가득 채우지 못해 처리량 손실**.

- 손실 환경 처리량(직관):
  $$
  \text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}}
  $$
  여기서 \(p\)는 패킷 손실 확률. 손실/RTT가 커질수록 처리량은 **급감**한다.

---

### 체크리스트

- [ ] **부분 쓰기/읽기**를 전제로 `send_all`/`recv_exact` 사용
- [ ] **프레이밍(길이-프리픽스)** 또는 구분자 기반 파서 적용
- [ ] **네트워크 바이트 오더**(빅엔디안) 변환 준수 (`htonl/ntohl`)
- [ ] **SIGPIPE** 대비(`MSG_NOSIGNAL` or 신호 무시)
- [ ] **`shutdown()` 의미** 이해(half-close) 및 올바른 종료 절차
- [ ] **관측 습관**: tcpdump/Wireshark/ss/strace

---

### 요약

- TCP는 **바이트 스트림**이므로 **부분 입출력**이 **정상 상태**다.
- 신뢰성 있는 응용을 위해 **프레이밍**과 **안전 루틴**(`send_all`/`recv_exact`)이 필수.
- 연결 수립/종료(3-way/4-way)와 `shutdown()` 을 정확히 이해하면 **프로토콜 설계/구현**이 견고해진다.
- 제공한 **C++23 블로킹 에코**는 실무 서버/클라의 **최소 안전 템플릿**으로 확장할 수 있다(논블로킹/epoll, 타임아웃/재시도, TLS 등으로 이어서).
