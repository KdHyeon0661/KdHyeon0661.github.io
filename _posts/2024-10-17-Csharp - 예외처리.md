---
layout: post
title: C# - 예외처리
date: 2024-10-17 19:20:23 +0900
category: Csharp
---
# C# 예외 처리

## 큰 그림: “예외는 흐름 제어가 아닌 **오류 신호**”

- 예외는 **예상치 못한 실패**를 나타냅니다(파일 없음, 네트워크 단절, 권한 부족 등).
- 일반 분기(`if/else`)로 처리 가능한 정상 흐름은 **예외를 쓰지 않습니다**(예: TryParse).
- **던지기 → 전파 → 적절한 레이어에서 처리**가 원칙입니다.

---

## try–catch 기본 구조

```csharp
try
{
    // 예외가 발생할 수 있는 코드
}
catch (Exception ex)
{
    // 예외 처리(로깅, 변환, 사용자 메시지 등)
}
```

### 예제: 0으로 나누기

```csharp
try
{
    int x = 0;
    int result = 10 / x;
}
catch (DivideByZeroException e)
{
    Console.WriteLine("0으로 나눌 수 없습니다!");
}
```

- **구체적 예외부터** 잡고, 가장 마지막에 일반 `Exception`을 고려합니다.

---

## finally — 항상 실행되는 정리 블록

리소스 해제, 핸들 닫기, 임시 상태 복구에 사용합니다.

```csharp
FileStream? fs = null;
try
{
    fs = File.OpenRead("data.bin");
    // 읽기 수행…
}
catch (IOException ex)
{
    Console.WriteLine($"I/O 실패: {ex.Message}");
}
finally
{
    fs?.Dispose();     // 항상 호출
    Console.WriteLine("항상 실행됩니다.");
}
```

> **팁**: `using` 또는 `await using`을 사용하면 보일러플레이트가 줄고 finally-equivalent가 자동 적용됩니다.

---

## throw — 예외 던지기 & 재던지기

### 새 예외 던지기

```csharp
if (userId is null)
    throw new ArgumentNullException(nameof(userId), "사용자 ID는 null일 수 없습니다.");
```

### 예외 **다시 던지기(rethrow)**

```csharp
try
{
    Dangerous();
}
catch (Exception ex)
{
    Log(ex);
    throw; // 스택 추적 유지
    // throw ex;  <-- ❌ 스택이 초기화되어 디버깅에 불리합니다.
}
```

### 예외 **래핑(wrap)**

```csharp
try
{
    ParseConfig();
}
catch (FormatException fe)
{
    throw new ConfigurationErrorsException("설정 파싱 실패", fe);
}
```

- **InnerException**으로 원인이 보존됩니다.

---

## 여러 개의 catch — 구체적 → 일반 순서

```csharp
try
{
    // …
}
catch (ArgumentNullException e)
{
    // 매개변수 null
}
catch (InvalidOperationException e)
{
    // 논리적 상태 오류
}
catch (Exception e)
{
    // 나머지
}
```

- 순서가 중요합니다. **좁은 범위 → 넓은 범위**.

---

## finally 대체: `using` / `await using`

### 동기 `using` (C# 8 이전/이후 모두)

```csharp
using (var conn = new SqlConnection(cs))
{
    conn.Open();
    // 사용…
} // 자동 Dispose
```

### using 선언(C# 8+)

```csharp
using var reader = File.OpenText("log.txt");
// 범위 종료 시 Dispose
```

### 비동기 `await using` (IAsyncDisposable)

```csharp
await using var stream = new AsyncFileStream("a.bin");
await stream.WriteAsync(buffer);
```

---

## — `when` 조건

로깅/조건부 처리에 유용하며, **스택을 오염시키지 않습니다**.

```csharp
try
{
    // …
}
catch (HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.TooManyRequests)
{
    Console.WriteLine("429: 대기 후 재시도");
}
catch (Exception ex) when (LogAndReturnTrue(ex))
{
    // 이 블록은 조건이 true여야 실행됩니다.
    Console.WriteLine("로깅 후 공통 처리");
}

static bool LogAndReturnTrue(Exception ex)
{
    Console.Error.WriteLine(ex);
    return true;
}
```

---

## 예외 객체에서 자주 쓰는 정보

```csharp
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
    Console.WriteLine(ex.StackTrace);
    Console.WriteLine(ex.GetType().FullName);
    Console.WriteLine(ex.Source);
    Console.WriteLine(ex.HResult.ToString("X")); // Win32 스타일 코드
    if (ex.Data?["Context"] is string ctx) Console.WriteLine(ctx);
}
```

- `ex.Data`는 임의의 메타데이터 사전을 제공합니다.

---

## **ExceptionDispatchInfo** — 스택 보존 재던지기

중간 계층에서 잡았다가 **다른 시점에 동일 스택으로** 다시 던지려면:

```csharp
using System.Runtime.ExceptionServices;

ExceptionDispatchInfo? captured = null;
try
{
    Work();
}
catch (Exception ex)
{
    captured = ExceptionDispatchInfo.Capture(ex);
}

DoCleanup();

captured?.Throw(); // 원래 스택 유지
```

---

## 비동기/병렬: async/await, Task, AggregateException

### async/await — 예외 전파

```csharp
async Task<int> FetchAsync()
{
    using var client = new HttpClient();
    var s = await client.GetStringAsync("https://example.com");
    return s.Length;
}

try
{
    int len = await FetchAsync(); // await 시 예외가 여기로 전파
}
catch (HttpRequestException ex)
{
    Console.WriteLine("네트워크 실패");
}
```

- `await`하지 않은 Task에서 예외는 **관찰되지 않을 수** 있습니다. 반드시 관찰( await / Task.Wait / ContinueWith 등)하세요.

### Task/Parallel — AggregateException

```csharp
try
{
    Parallel.Invoke(
        () => throw new InvalidOperationException("A"),
        () => throw new ArgumentException("B")
    );
}
catch (AggregateException ae)
{
    foreach (var ex in ae.Flatten().InnerExceptions)
        Console.WriteLine(ex.Message); // "A", "B"
}
```

- `Task.WhenAll` 등도 **여러 예외를 AggregateException에** 담습니다.

### 취소: OperationCanceledException

```csharp
var cts = new CancellationTokenSource(TimeSpan.FromSeconds(2));
try
{
    await DoWorkAsync(cts.Token);
}
catch (OperationCanceledException) when (cts.IsCancellationRequested)
{
    Console.WriteLine("의도된 취소");
}
```

- **취소는 예외지만 정상 시나리오**로 간주해, 사용자 메시지는 “실패”가 아닌 “취소됨”으로 처리.

---

## 예외 vs 반환형: 언제 어떤 것을?

- 정상적 분기(존재 여부, 파싱 실패, 조건 미충족)는 **TryXxx 패턴**이 적합.

```csharp
if (int.TryParse(s, out var n)) { /* 정상 */ }
else { /* 대안 경로 */ }
```

- 외부 환경 실패(네트워크/디스크/권한)나 **불가능한 상태**는 예외가 적합.
- **Validation**: 컨트롤러/도메인에서 **검증 오류**는 예외 대신 **결과 객체**로 반환하는 설계도 선택지.

---

## 사용자 정의 예외 — 도메인에 맞춘 타입

### 최소 구현

```csharp
public class MyCustomException : Exception
{
    public MyCustomException() { }
    public MyCustomException(string message) : base(message) { }
    public MyCustomException(string message, Exception inner) : base(message, inner) { }
}
```

### 시리얼라이즈 지원(필요 시)

```csharp
[Serializable]
public class OutboxPublishException : Exception
{
    public string? EventId { get; }
    public OutboxPublishException() { }
    public OutboxPublishException(string message) : base(message) { }
    public OutboxPublishException(string message, Exception inner) : base(message, inner) { }
    protected OutboxPublishException(
        System.Runtime.Serialization.SerializationInfo info,
        System.Runtime.Serialization.StreamingContext context) : base(info, context)
    {
        EventId = info.GetString(nameof(EventId));
    }
    public override void GetObjectData(
        System.Runtime.Serialization.SerializationInfo info,
        System.Runtime.Serialization.StreamingContext context)
    {
        base.GetObjectData(info, context);
        info.AddValue(nameof(EventId), EventId);
    }
}
```

- 분산/리모팅/크로스-도메인 필요가 없다면 직렬화는 생략 가능.

---

## 예외 필터의 실전 패턴

### 조건부 재시도 힌트

```csharp
catch (HttpRequestException ex) when ((int?)ex.StatusCode is >= 500 and < 600)
{
    // 서버 오류군만 재시도
    EnqueueRetry();
}
```

### 로깅 전용 필터

```csharp
catch (Exception ex) when (LogAndReturnFalse(ex))
{
    // 실행되지 않음 (조건이 false) — 스택을 건드리지 않고 로그만
}

static bool LogAndReturnFalse(Exception ex)
{
    Console.Error.WriteLine(ex);
    return false;
}
```

---

## 글로벌 핸들링(애플리케이션 레벨)

### 콘솔/데스크톱

```csharp
AppDomain.CurrentDomain.UnhandledException += (s, e) =>
{
    Console.Error.WriteLine($"Fatal: {e.ExceptionObject}");
    Environment.Exit(-1);
};
```

### ASP.NET Core — 미들웨어

```csharp
app.UseExceptionHandler(errApp =>
{
    errApp.Run(async ctx =>
    {
        var feature = ctx.Features.Get<IExceptionHandlerPathFeature>();
        var ex = feature?.Error;

        var problem = new
        {
            title = "서버 오류",
            status = 500,
            traceId = ctx.TraceIdentifier
        };

        ctx.Response.StatusCode = 500;
        ctx.Response.ContentType = "application/json; charset=utf-8";
        await ctx.Response.WriteAsJsonAsync(problem);
    });
});
```

- 환경에 따라 개발 중에는 **DeveloperExceptionPage**, 운영에서는 **Problem Details**를 반환.

---

## 로깅 지침

- **컨텍스트**(CorrelationId/사용자/요청 경로/파라미터)를 함께 기록.
- **중복 로깅**(여러 레이어에서 같은 예외를 반복 기록)은 잡음 증가 → **핸들링 지점 1회** 원칙.
- **PII/민감정보**(비밀번호, 토큰)는 로그에 기록 금지.

```csharp
try
{
    // …
}
catch (SqlException ex)
{
    logger.LogError(ex, "DB 실패; OrderId={OrderId}", orderId);
    throw; // 상위에서 최종 변환
}
```

---

## 성능 관점 — 예외 빈도/비용 직관

- 예외는 **희귀**해야 합니다. 빈번한 예외는 고비용입니다(스택 캡처, 언와인딩, 로깅).
- 대략적 기대 비용(직관)
  $$ \mathbb{E}[\text{비용}] \approx p_\text{ex} \cdot C_\text{throw} + (1-p_\text{ex}) \cdot C_\text{normal} $$
  여기서 \(p_\text{ex}\)는 예외 확률, \(C_\text{throw}\)는 던지기 비용, \(C_\text{normal}\)은 정상 비용입니다.
- **핫 패스**에서 예외가 발생한다면 설계를 재검토하세요(예: TryXxx로 전환).

---

## 패턴/안티패턴 체크리스트

**Do**
- [ ] 구체적 예외 우선, 일반 예외는 마지막
- [ ] `throw;`로 스택 보존
- [ ] 예외 필터로 조건/로깅 분리
- [ ] using/await using으로 리소스 정리 자동화
- [ ] 취소는 OperationCanceledException으로 구분 처리
- [ ] AggregateException은 Flatten 후 모두 기록/보고
- [ ] 사용자 정의 예외에 의미 있는 **이름/속성** 제공

**Don’t**
- [ ] **빈 catch**(침묵) 금지
- [ ] 정상 흐름을 예외로 제어 금지
- [ ] `throw ex;` 금지(스택 초기화)
- [ ] 모든 곳에서 과도한 로깅 금지(중복)
- [ ] 비밀정보를 예외 메시지/로그에 포함 금지

---

## 미니 프로젝트 — 안정적 파일 처리기

요구:
1) 텍스트 파일을 라인 단위로 읽고 정수 합계를 출력.
2) 잘못된 라인은 건너뛰되 **라인 번호/내용**을 로깅.
3) 파일 없음/권한 오류/취소를 구분 처리.
4) 합계 계산 중 오류는 상위로 래핑해 전달.

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.ExceptionServices;
using System.Threading;
using System.Threading.Tasks;

public class FileSumException : Exception
{
    public string Path { get; }
    public FileSumException(string path, string message, Exception inner)
        : base(message, inner) => Path = path;
}

public static class SafeFileSum
{
    public static async Task<int> SumAsync(string path, CancellationToken ct = default)
    {
        try
        {
            await using var stream = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read);
            using var reader = new StreamReader(stream);

            int sum = 0, lineNo = 0;
            while (!reader.EndOfStream)
            {
                ct.ThrowIfCancellationRequested();

                var line = await reader.ReadLineAsync();
                lineNo++;

                if (string.IsNullOrWhiteSpace(line)) continue;

                if (int.TryParse(line, out var n))
                {
                    checked { sum += n; }
                }
                else
                {
                    // 조건부 로깅: 필터를 흉내 (여기선 단순 콘솔)
                    Console.Error.WriteLine($"[WARN] 잘못된 숫자: line {lineNo}: '{line}'");
                }
            }

            return sum;
        }
        catch (OperationCanceledException) when (ct.IsCancellationRequested)
        {
            Console.WriteLine("작업이 취소되었습니다.");
            throw; // 호출자가 취소를 인지하도록 그대로 전파
        }
        catch (FileNotFoundException ex)
        {
            Console.Error.WriteLine($"[ERROR] 파일을 찾을 수 없습니다: {path}");
            throw new FileSumException(path, "입력 파일이 존재하지 않습니다.", ex);
        }
        catch (UnauthorizedAccessException ex)
        {
            Console.Error.WriteLine($"[ERROR] 권한 부족: {path}");
            throw new FileSumException(path, "파일에 접근 권한이 없습니다.", ex);
        }
        catch (OverflowException ex)
        {
            Console.Error.WriteLine($"[ERROR] 합계 오버플로우: {path}");
            throw new FileSumException(path, "합계가 정수 범위를 초과했습니다.", ex);
        }
        catch (IOException ex)
        {
            Console.Error.WriteLine($"[ERROR] I/O 오류: {ex.Message}");
            throw new FileSumException(path, "파일 읽기 중 오류.", ex);
        }
    }
}

class Program
{
    static async Task Main()
    {
        var cts = new CancellationTokenSource();
        Console.CancelKeyPress += (s, e) => { e.Cancel = true; cts.Cancel(); };

        try
        {
            int total = await SafeFileSum.SumAsync("numbers.txt", cts.Token);
            Console.WriteLine($"합계: {total}");
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("사용자 취소.");
        }
        catch (FileSumException ex)
        {
            Console.WriteLine($"처리 실패: {ex.Message} (Path={ex.Path})");
            Console.WriteLine(ex.InnerException); // 원인
        }
        catch (Exception ex)
        {
            Console.WriteLine($"예기치 못한 오류: {ex}");
        }
    }
}
```

**포인트**
- 구체 예외 분기 → 의미 있는 `FileSumException`으로 래핑
- 취소는 그대로 전파(정상적 중단 시그널)
- `checked`로 합계 오버플로우 감지

---

## 예외를 HTTP 응답으로 맵핑(간단 패턴)

- `ValidationException` → 400
- `UnauthorizedAccessException`/`SecurityException` → 403/401
- `KeyNotFoundException`/`EntityNotFoundException` → 404
- 기타 → 500 (Problem Details)

```csharp
app.Use(async (ctx, next) =>
{
    try
    {
        await next();
    }
    catch (Exception ex)
    {
        ctx.Response.ContentType = "application/problem+json";
        ctx.Response.StatusCode = ex switch
        {
            ValidationException     => StatusCodes.Status400BadRequest,
            UnauthorizedAccessException => StatusCodes.Status403Forbidden,
            KeyNotFoundException    => StatusCodes.Status404NotFound,
            _                       => StatusCodes.Status500InternalServerError
        };
        await ctx.Response.WriteAsJsonAsync(new
        {
            title = ex.Message,
            status = ctx.Response.StatusCode,
            traceId = ctx.TraceIdentifier
        });
    }
});
```

---

## 도구/디버깅 팁

- **First-chance exceptions**: 디버거에서 예외 발생 지점을 즉시 포착(Visual Studio: Exception Settings).
- **Break on throw**: 특정 타입에서 던져질 때 중단.
- **Minidump/ProcDump**: 운영 환경 크래시 분석.
- **Structured logging**(Serilog, NLog): 예외와 컨텍스트를 구조화.

---

## 요약 테이블

| 주제 | 핵심 포인트 |
|---|---|
| try/catch/finally | 구체적 → 일반 순, finally는 정리 책임 |
| throw/rethrow | `throw;`로 스택 보존, 래핑 시 InnerException 유지 |
| 필터(when) | 조건부 처리/로깅, 스택 오염 없음 |
| async/await | await 지점으로 예외 전파, **관찰되지 않은 예외** 없도록 |
| AggregateException | 병렬/WhenAll에서 예외 집합 처리 |
| 취소 | `OperationCanceledException`은 정상적 중단 신호 |
| 사용자 정의 예외 | 의미 있는 이름/속성, 필요 시 직렬화 |
| 글로벌 핸들링 | 콘솔: UnhandledException, 웹: 미들웨어/Problem Details |
| 성능 | 예외는 희귀해야 함, TryXxx 사용 검토 |
| 보안/로깅 | PII 제거, 중복 로깅 회피, 컨텍스트 포함 |

---

## 연습 과제

1) `RetryPolicy`를 작성하여 `HttpRequestException`의 5xx만 **지수 백오프**로 재시도하고, 4xx는 즉시 실패하게 하라(예외 필터 활용).
2) `IRepository` 구현에서 `SqlException`을 `RepositoryException`으로 래핑하고, `Deadlock` 코드는 **한 번 재시도** 후 실패하라.
3) `Task.WhenAll`로 3개의 비동기 작업을 실행하고, `AggregateException`의 모든 예외를 구조화 로깅하라.
4) `CancellationToken`을 이용해 3초 후 취소되는 계산 작업을 만들고, 취소와 진짜 실패를 다른 메시지로 구분 출력하라.
5) ASP.NET Core에서 전역 예외 미들웨어로 도메인 예외들을 400/404/409로 매핑하는 미들웨어를 작성하라.

---

## 결론

예외는 **신뢰성 있는 소프트웨어**의 필수 메커니즘입니다.
핵심은 “**던지기 위치 최소화**—**처리 위치 명확화**—**정리 책임 보장**—**사용자/로거에 적절한 정보 제공**”입니다.
이 글의 패턴들을 프로젝트에 맞게 **일관된 정책**으로 정하고, 코드 리뷰의 체크리스트로 삼으세요.
