---
layout: post
title: C# - 예외처리
date: 2024-10-17 19:20:23 +0900
category: Csharp
---
# C# 예외 처리

## 소개: 오류 처리를 위한 견고한 시스템 구축

소프트웨어 개발에서 오류는 피할 수 없는 현실입니다. 네트워크 연결 끊김, 파일 시스템 권한 문제, 잘못된 사용자 입력 등 다양한 이유로 프로그램은 예기치 않은 상황에 직면합니다. C#의 예외 처리(Exception Handling) 시스템은 이러한 비정상적인 상황을 체계적으로 관리하고, 애플리케이션의 견고성(robustness)과 사용자 경험을 향상시키는 강력한 도구입니다.

예외 처리의 핵심 철학은 **"예외는 오류 신호일 뿐, 일반적인 제어 흐름이 아니다"** 입니다. 예외는 예상치 못한 실패 상황을 나타내며, 정상적인 프로그램 로직과 명확히 구분되어 처리되어야 합니다.

---

## 1. 기본 구조: try-catch-finally

C# 예외 처리의 기본 구성 요소는 `try`, `catch`, `finally` 블록입니다.

### try-catch 블록

```csharp
try
{
    // 예외가 발생할 가능성이 있는 코드
    int result = DivideNumbers(10, 0);
    Console.WriteLine($"결과: {result}");
}
catch (DivideByZeroException ex)
{
    // 특정 예외 처리
    Console.WriteLine("0으로 나눌 수 없습니다!");
    Console.WriteLine($"상세 정보: {ex.Message}");
}
catch (Exception ex)
{
    // 모든 예외를 처리 (가장 일반적인 예외)
    Console.WriteLine($"예외 발생: {ex.GetType().Name}");
    Console.WriteLine($"메시지: {ex.Message}");
}
```

### catch 블록의 순서

catch 블록은 **구체적인 예외부터 일반적인 예외 순서로** 작성해야 합니다. 컴파일러는 catch 블록을 위에서 아래로 평가하며, 첫 번째로 일치하는 catch 블록을 실행합니다.

```csharp
try
{
    // 예외 발생 가능한 코드
}
catch (FileNotFoundException ex)  // 가장 구체적인 예외
{
    Console.WriteLine("파일을 찾을 수 없습니다.");
}
catch (IOException ex)            // 더 일반적인 예외
{
    Console.WriteLine("입출력 오류가 발생했습니다.");
}
catch (Exception ex)              // 가장 일반적인 예외 (마지막에 위치)
{
    Console.WriteLine($"예상치 못한 오류: {ex.Message}");
}
```

### finally 블록: 항상 실행되는 정리 코드

`finally` 블록은 예외 발생 여부와 관계없이 항상 실행됩니다. 리소스 해제, 정리 작업 등에 사용됩니다.

```csharp
FileStream? fileStream = null;
try
{
    fileStream = File.Open("data.txt", FileMode.Open);
    // 파일 작업 수행
}
catch (FileNotFoundException ex)
{
    Console.WriteLine("파일을 찾을 수 없습니다.");
}
finally
{
    // 예외 발생 여부와 상관없이 항상 실행
    fileStream?.Dispose();
    Console.WriteLine("리소스 정리 완료.");
}
```

---

## 2. 예외 발생시키기: throw 키워드

### 새로운 예외 발생

```csharp
public class BankAccount
{
    private decimal _balance;
    
    public void Withdraw(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(amount), 
                "출금액은 0보다 커야 합니다.");
        }
        
        if (amount > _balance)
        {
            throw new InvalidOperationException(
                $"잔액 부족. 현재 잔액: {_balance:C}, 요청 금액: {amount:C}");
        }
        
        _balance -= amount;
    }
}

// 사용 예
try
{
    var account = new BankAccount();
    account.Withdraw(-100); // 예외 발생
}
catch (ArgumentOutOfRangeException ex)
{
    Console.WriteLine($"잘못된 입력: {ex.Message}");
}
```

### 예외 다시 던지기(Rethrowing)

예외를 잡아서 처리한 후 다시 던질 때는 `throw;`를 사용하여 원래의 스택 추적 정보를 유지해야 합니다.

```csharp
public void ProcessData(string data)
{
    try
    {
        ValidateAndProcess(data);
    }
    catch (FormatException)
    {
        // 로깅 등 추가 처리
        Console.WriteLine("데이터 형식 오류 발생");
        
        // 올바른 방법: 원래 예외를 다시 던짐 (스택 추적 유지)
        throw;
        
        // ❌ 잘못된 방법: throw ex; (스택 추적 정보 손실)
        // throw ex;
    }
}
```

### 예외 래핑(Wrapping)

하위 수준의 예외를 상위 수준의 의미 있는 예외로 래핑할 수 있습니다.

```csharp
public class DataAccessException : Exception
{
    public DataAccessException(string message, Exception innerException)
        : base(message, innerException)
    {
    }
}

public class UserRepository
{
    public User GetUser(int id)
    {
        try
        {
            // 데이터베이스 접근 코드
            return Database.Query<User>($"SELECT * FROM Users WHERE Id = {id}");
        }
        catch (SqlException sqlEx)
        {
            // 하위 수준 예외를 도메인 예외로 래핑
            throw new DataAccessException(
                $"사용자 ID {id} 조회 중 오류 발생", sqlEx);
        }
    }
}
```

---

## 3. using 문: 자동 리소스 관리

`IDisposable` 인터페이스를 구현하는 객체(파일, 데이터베이스 연결 등)는 `using` 문을 사용하여 자동으로 리소스를 해제할 수 있습니다.

### 기본 using 문

```csharp
// using 블록이 끝나면 자동으로 Dispose() 호출
using (var fileStream = File.Open("data.txt", FileMode.Open))
{
    // 파일 작업
    byte[] buffer = new byte[1024];
    fileStream.Read(buffer, 0, buffer.Length);
} // fileStream.Dispose()가 자동 호출됨
```

### C# 8.0의 using 선언

```csharp
// C# 8.0+: 블록 범위가 끝나면 자동으로 Dispose() 호출
using var fileStream = File.Open("data.txt", FileMode.Open);
using var reader = new StreamReader(fileStream);

// 파일 작업
string content = await reader.ReadToEndAsync();
// 블록이 끝나면 reader와 fileStream이 자동으로 Dispose됨
```

### 비동기 using (IAsyncDisposable)

```csharp
// IAsyncDisposable을 구현하는 객체는 await using 사용
await using var httpClient = new HttpClient();
await using var response = await httpClient.GetAsync("https://api.example.com");

// 작업 수행 후 자동으로 비동기 정리
```

---

## 4. 예외 필터: when 키워드

C# 6.0부터 도입된 예외 필터는 특정 조건에서만 예외를 처리할 수 있게 해줍니다.

### 기본 사용법

```csharp
try
{
    // 예외 발생 가능한 코드
}
catch (HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.NotFound)
{
    Console.WriteLine("404 오류: 리소스를 찾을 수 없습니다.");
}
catch (HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.Unauthorized)
{
    Console.WriteLine("401 오류: 인증이 필요합니다.");
}
catch (HttpRequestException ex)
{
    Console.WriteLine($"HTTP 오류: {(int)ex.StatusCode}");
}
```

### 로깅을 위한 예외 필터 활용

```csharp
try
{
    ProcessOrder(order);
}
catch (Exception ex) when (LogException(ex))
{
    // 이 블록은 실행되지 않음 (LogException이 false를 반환하기 때문에)
    // 단지 예외를 로깅하기 위한 필터 역할
}

// 항상 false를 반환하는 헬퍼 메서드
private static bool LogException(Exception ex)
{
    Console.WriteLine($"[ERROR] {DateTime.Now:O} - {ex.GetType().Name}: {ex.Message}");
    Console.WriteLine($"스택 추적: {ex.StackTrace}");
    return false; // false를 반환하여 catch 블록이 실행되지 않게 함
}
```

### 조건부 재시도 로직

```csharp
private int retryCount = 0;
private const int MaxRetries = 3;

public async Task<string> FetchDataWithRetryAsync(string url)
{
    while (true)
    {
        try
        {
            using var client = new HttpClient();
            return await client.GetStringAsync(url);
        }
        catch (HttpRequestException ex) when (retryCount < MaxRetries && 
                                              ex.StatusCode >= HttpStatusCode.InternalServerError)
        {
            // 서버 오류(5xx)일 때만 재시도
            retryCount++;
            Console.WriteLine($"서버 오류 발생, {retryCount}번째 재시도...");
            await Task.Delay(1000 * retryCount); // 지수 백오프
        }
    }
}
```

---

## 5. 사용자 정의 예외 클래스

도메인에 특화된 예외 클래스를 만들어 더 의미 있는 오류 정보를 제공할 수 있습니다.

### 기본 사용자 정의 예외

```csharp
public class InsufficientFundsException : Exception
{
    public decimal CurrentBalance { get; }
    public decimal RequiredAmount { get; }
    
    public InsufficientFundsException(decimal currentBalance, decimal requiredAmount)
        : base($"잔액 부족. 현재 잔액: {currentBalance:C}, 필요 금액: {requiredAmount:C}")
    {
        CurrentBalance = currentBalance;
        RequiredAmount = requiredAmount;
    }
    
    public InsufficientFundsException(decimal currentBalance, decimal requiredAmount, Exception innerException)
        : base($"잔액 부족. 현재 잔액: {currentBalance:C}, 필요 금액: {requiredAmount:C}", 
               innerException)
    {
        CurrentBalance = currentBalance;
        RequiredAmount = requiredAmount;
    }
}

// 사용 예
public class BankAccount
{
    private decimal _balance = 1000;
    
    public void Withdraw(decimal amount)
    {
        if (amount > _balance)
        {
            throw new InsufficientFundsException(_balance, amount);
        }
        
        _balance -= amount;
    }
}
```

### 직렬화 지원 사용자 정의 예외

```csharp
[Serializable]
public class DomainException : Exception
{
    public string ErrorCode { get; }
    
    public DomainException() { }
    
    public DomainException(string message) : base(message) { }
    
    public DomainException(string message, Exception inner) : base(message, inner) { }
    
    public DomainException(string errorCode, string message) : base(message)
    {
        ErrorCode = errorCode;
    }
    
    // 직렬화를 위한 생성자
    protected DomainException(
        System.Runtime.Serialization.SerializationInfo info,
        System.Runtime.Serialization.StreamingContext context) : base(info, context)
    {
        ErrorCode = info.GetString(nameof(ErrorCode)) ?? string.Empty;
    }
    
    // 직렬화 메서드 오버라이드
    public override void GetObjectData(
        System.Runtime.Serialization.SerializationInfo info,
        System.Runtime.Serialization.StreamingContext context)
    {
        base.GetObjectData(info, context);
        info.AddValue(nameof(ErrorCode), ErrorCode);
    }
}
```

---

## 6. 비동기 코드의 예외 처리

비동기 메서드에서 예외 처리는 동기 코드와 유사하지만 몇 가지 주의사항이 있습니다.

### async/await에서의 예외 처리

```csharp
public async Task<string> DownloadContentAsync(string url)
{
    try
    {
        using var httpClient = new HttpClient();
        return await httpClient.GetStringAsync(url);
    }
    catch (HttpRequestException ex)
    {
        Console.WriteLine($"HTTP 요청 실패: {ex.Message}");
        return string.Empty; // 기본값 반환 또는 다른 처리
    }
    catch (TaskCanceledException ex)
    {
        Console.WriteLine("요청이 취소되었습니다.");
        throw; // 호출자에게 취소 사실 전달
    }
}

// 호출 예
try
{
    string content = await DownloadContentAsync("https://example.com");
    Console.WriteLine($"다운로드 완료: {content.Length}바이트");
}
catch (TaskCanceledException)
{
    Console.WriteLine("작업이 취소되었습니다.");
}
```

### Task.WhenAll과 AggregateException

여러 비동기 작업을 병렬로 실행할 때는 `AggregateException`을 처리해야 합니다.

```csharp
public async Task ProcessMultipleUrlsAsync(string[] urls)
{
    var tasks = urls.Select(url => DownloadContentAsync(url)).ToList();
    
    try
    {
        // 모든 작업 완료 대기
        string[] results = await Task.WhenAll(tasks);
        Console.WriteLine($"모든 작업 완료: {results.Length}개 결과");
    }
    catch (AggregateException ae)
    {
        // AggregateException 처리
        Console.WriteLine($"{ae.InnerExceptions.Count}개의 작업에서 예외 발생:");
        
        foreach (var ex in ae.Flatten().InnerExceptions)
        {
            Console.WriteLine($"  - {ex.GetType().Name}: {ex.Message}");
        }
    }
}
```

### 관찰되지 않은 예외(Unobserved Task Exceptions)

```csharp
// TaskScheduler.UnobservedTaskException 이벤트 처리
TaskScheduler.UnobservedTaskException += (sender, e) =>
{
    Console.WriteLine($"관찰되지 않은 작업 예외: {e.Exception}");
    e.SetObserved(); // 예외가 처리되었음을 표시
};

// 예: ContinueWith에서 예외를 처리하지 않은 경우
Task.Run(() => throw new InvalidOperationException("테스트 예외"))
    .ContinueWith(t => Console.WriteLine("작업 완료"));
```

---

## 7. 성능 고려사항

예외 처리는 강력하지만 비용이 많이 드는 작업입니다. 성능이 중요한 코드에서는 다음 사항을 고려하세요.

### 예외 vs 반환 코드

예외가 자주 발생할 수 있는 상황에서는 예외 대신 반환 코드를 사용하는 것이 더 효율적일 수 있습니다.

```csharp
// 예외 기반 접근 (예외가 드물게 발생할 때 적합)
public decimal DivideWithException(decimal a, decimal b)
{
    if (b == 0)
    {
        throw new DivideByZeroException("0으로 나눌 수 없습니다.");
    }
    return a / b;
}

// 반환 코드 기반 접근 (예외가 자주 발생할 수 있을 때 적합)
public bool TryDivide(decimal a, decimal b, out decimal result)
{
    if (b == 0)
    {
        result = 0;
        return false;
    }
    
    result = a / b;
    return true;
}

// 사용 예
if (TryDivide(10, 2, out decimal result))
{
    Console.WriteLine($"결과: {result}");
}
else
{
    Console.WriteLine("나눗셈 실패");
}
```

### 예외 캐싱 패턴

```csharp
public class ExceptionCache
{
    private static readonly Dictionary<string, Exception> _cachedExceptions = new();
    
    public static Exception GetOrCreateException(string key, Func<Exception> createException)
    {
        // 동일한 예외를 반복 생성하는 비용 방지
        if (!_cachedExceptions.TryGetValue(key, out var exception))
        {
            exception = createException();
            _cachedExceptions[key] = exception;
        }
        
        return exception;
    }
}
```

---

## 8. 실전 예제: 파일 처리기

다양한 예외 처리 패턴을 적용한 실용적인 파일 처리기를 구현해 보겠습니다.

```csharp
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

public class FileProcessor
{
    private readonly ILogger _logger;
    
    public FileProcessor(ILogger logger)
    {
        _logger = logger;
    }
    
    public async Task<FileProcessResult> ProcessFileAsync(
        string filePath, 
        CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(filePath))
        {
            throw new ArgumentException("파일 경로가 유효하지 않습니다.", nameof(filePath));
        }
        
        try
        {
            _logger.LogInformation($"파일 처리 시작: {filePath}");
            
            // 취소 토큰 체크
            cancellationToken.ThrowIfCancellationRequested();
            
            // 파일 열기
            using var fileStream = File.Open(filePath, FileMode.Open, FileAccess.Read);
            using var reader = new StreamReader(fileStream);
            
            // 파일 내용 처리
            string content = await reader.ReadToEndAsync();
            var result = AnalyzeContent(content);
            
            _logger.LogInformation($"파일 처리 완료: {filePath}, 결과: {result.Status}");
            return result;
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            _logger.LogWarning($"파일 처리 취소: {filePath}");
            throw; // 정상적인 취소는 다시 던짐
        }
        catch (FileNotFoundException ex)
        {
            _logger.LogError($"파일을 찾을 수 없음: {filePath}", ex);
            return FileProcessResult.Failure("파일을 찾을 수 없습니다.");
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogError($"파일 접근 권한 없음: {filePath}", ex);
            return FileProcessResult.Failure("파일에 접근할 권한이 없습니다.");
        }
        catch (IOException ex) when (IsDiskFullException(ex))
        {
            _logger.LogError($"디스크 공간 부족: {filePath}", ex);
            return FileProcessResult.Failure("디스크 공간이 부족합니다.");
        }
        catch (IOException ex)
        {
            _logger.LogError($"입출력 오류: {filePath}", ex);
            return FileProcessResult.Failure($"파일 처리 중 오류 발생: {ex.Message}");
        }
        catch (Exception ex) when (!(ex is OperationCanceledException))
        {
            _logger.LogError($"예상치 못한 오류: {filePath}", ex);
            throw new FileProcessingException($"파일 처리 중 오류 발생: {filePath}", ex);
        }
    }
    
    private bool IsDiskFullException(IOException ex)
    {
        // Windows의 디스크 공간 부족 예외 코드 확인
        const int ERROR_DISK_FULL = 0x70;
        const int ERROR_HANDLE_DISK_FULL = 0x27;
        
        return ex.HResult == ERROR_DISK_FULL || 
               ex.HResult == ERROR_HANDLE_DISK_FULL ||
               ex.Message.Contains("디스크 공간이 부족합니다");
    }
    
    private FileProcessResult AnalyzeContent(string content)
    {
        // 간단한 내용 분석 (실제 구현에서는 더 복잡한 로직)
        if (string.IsNullOrWhiteSpace(content))
        {
            return FileProcessResult.Failure("파일 내용이 비어 있습니다.");
        }
        
        int lineCount = content.Split('\n').Length;
        int wordCount = content.Split(new[] { ' ', '\t', '\n', '\r' }, 
                                     StringSplitOptions.RemoveEmptyEntries).Length;
        
        return FileProcessResult.Success(lineCount, wordCount);
    }
}

// 지원 클래스들
public interface ILogger
{
    void LogInformation(string message);
    void LogWarning(string message);
    void LogError(string message, Exception? exception = null);
}

public class FileProcessResult
{
    public bool IsSuccess { get; }
    public string? ErrorMessage { get; }
    public int LineCount { get; }
    public int WordCount { get; }
    public FileProcessStatus Status { get; }
    
    private FileProcessResult(bool isSuccess, string? errorMessage, 
                             int lineCount, int wordCount)
    {
        IsSuccess = isSuccess;
        ErrorMessage = errorMessage;
        LineCount = lineCount;
        WordCount = wordCount;
        Status = isSuccess ? FileProcessStatus.Success : FileProcessStatus.Failed;
    }
    
    public static FileProcessResult Success(int lineCount, int wordCount)
        => new(true, null, lineCount, wordCount);
    
    public static FileProcessResult Failure(string errorMessage)
        => new(false, errorMessage, 0, 0);
}

public enum FileProcessStatus
{
    Pending,
    Processing,
    Success,
    Failed,
    Cancelled
}

public class FileProcessingException : Exception
{
    public string FilePath { get; }
    
    public FileProcessingException(string filePath, string message) 
        : base(message)
    {
        FilePath = filePath;
    }
    
    public FileProcessingException(string filePath, string message, Exception innerException) 
        : base(message, innerException)
    {
        FilePath = filePath;
    }
}

// 사용 예
class Program
{
    static async Task Main()
    {
        var logger = new ConsoleLogger();
        var processor = new FileProcessor(logger);
        
        var cts = new CancellationTokenSource();
        
        // Ctrl+C로 취소 가능
        Console.CancelKeyPress += (s, e) =>
        {
            Console.WriteLine("취소 요청 받음...");
            cts.Cancel();
            e.Cancel = true; // 프로세스 종료 방지
        };
        
        try
        {
            var result = await processor.ProcessFileAsync("sample.txt", cts.Token);
            
            if (result.IsSuccess)
            {
                Console.WriteLine($"처리 성공: {result.LineCount}줄, {result.WordCount}단어");
            }
            else
            {
                Console.WriteLine($"처리 실패: {result.ErrorMessage}");
            }
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("작업이 사용자에 의해 취소되었습니다.");
        }
        catch (FileProcessingException ex)
        {
            Console.WriteLine($"파일 처리 예외: {ex.Message}");
            Console.WriteLine($"원인: {ex.InnerException?.Message}");
        }
    }
}

public class ConsoleLogger : ILogger
{
    public void LogInformation(string message)
        => Console.WriteLine($"[INFO] {DateTime.Now:HH:mm:ss} - {message}");
    
    public void LogWarning(string message)
    {
        Console.ForegroundColor = ConsoleColor.Yellow;
        Console.WriteLine($"[WARN] {DateTime.Now:HH:mm:ss} - {message}");
        Console.ResetColor();
    }
    
    public void LogError(string message, Exception? exception = null)
    {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine($"[ERROR] {DateTime.Now:HH:mm:ss} - {message}");
        if (exception != null)
        {
            Console.WriteLine($"       예외: {exception.GetType().Name}: {exception.Message}");
        }
        Console.ResetColor();
    }
}
```

---

## 9. 애플리케이션 수준 예외 처리

### 콘솔 애플리케이션

```csharp
class Program
{
    static void Main()
    {
        // 전역 예외 처리기 등록
        AppDomain.CurrentDomain.UnhandledException += (sender, e) =>
        {
            Console.WriteLine($"치명적 오류 발생: {e.ExceptionObject}");
            // 로깅, 사용자 알림, 정리 작업 등
            Environment.Exit(1);
        };
        
        // Task 예외 처리기
        TaskScheduler.UnobservedTaskException += (sender, e) =>
        {
            Console.WriteLine($"관찰되지 않은 작업 예외: {e.Exception}");
            e.SetObserved(); // 프로세스 종료 방지
        };
        
        try
        {
            RunApplication();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"애플리케이션 오류: {ex.Message}");
            // 정리 작업
        }
    }
    
    static void RunApplication()
    {
        // 애플리케이션 로직
    }
}
```

### ASP.NET Core 미들웨어

```csharp
public class ExceptionHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ExceptionHandlingMiddleware> _logger;
    
    public ExceptionHandlingMiddleware(RequestDelegate next, ILogger<ExceptionHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (ValidationException ex)
        {
            _logger.LogWarning(ex, "유효성 검사 실패");
            context.Response.StatusCode = StatusCodes.Status400BadRequest;
            await context.Response.WriteAsJsonAsync(new
            {
                error = "ValidationFailed",
                message = ex.Message,
                details = ex.Errors
            });
        }
        catch (NotFoundException ex)
        {
            _logger.LogInformation(ex, "리소스를 찾을 수 없음");
            context.Response.StatusCode = StatusCodes.Status404NotFound;
            await context.Response.WriteAsJsonAsync(new
            {
                error = "NotFound",
                message = ex.Message,
                resource = ex.ResourceType
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "처리되지 않은 예외");
            context.Response.StatusCode = StatusCodes.Status500InternalServerError;
            
            // 운영 환경에서는 상세 정보 노출하지 않음
            var errorResponse = new
            {
                error = "InternalServerError",
                message = "서버 내부 오류가 발생했습니다."
            };
            
            // 개발 환경에서는 상세 정보 포함
            if (context.RequestServices.GetRequiredService<IWebHostEnvironment>().IsDevelopment())
            {
                errorResponse = new
                {
                    error = "InternalServerError",
                    message = ex.Message,
                    stackTrace = ex.StackTrace
                };
            }
            
            await context.Response.WriteAsJsonAsync(errorResponse);
        }
    }
}

// Startup.cs 또는 Program.cs에서 미들웨어 등록
app.UseMiddleware<ExceptionHandlingMiddleware>();
```

---

## 결론: 견고한 예외 처리 전략 수립

효과적인 예외 처리는 단순히 코드에 `try-catch` 블록을 추가하는 것이 아니라, 체계적인 전략을 수립하는 것입니다. 다음 원칙들을 기억하세요:

1. **적절한 수준에서 예외 처리**: 예외는 발생한 곳에서 즉시 처리해야 하는 것이 아니라, 해당 예외를 가장 잘 처리할 수 있는 수준(레이어)에서 처리되어야 합니다. 데이터 액세스 예외는 리포지토리 레이어에서, 비즈니스 규칙 위반은 서비스 레이어에서 처리하는 것이 좋습니다.

2. **예외의 의미 전달**: 예외 메시지는 문제를 진단하는 데 도움이 되어야 합니다. "오류 발생"보다는 "사용자 'john'의 잔액이 부족합니다 (현재: $50, 요청: $100)"와 같은 구체적인 메시지를 제공하세요.

3. **finally 블록과 using 문 활용**: 리소스 누수를 방지하기 위해 파일, 데이터베이스 연결, 네트워크 스트림 등의 리소스는 항상 적절하게 해제되어야 합니다.

4. **사용자 정의 예외의 적절한 사용**: 도메인에 특화된 예외 클래스를 만들어 비즈니스 규칙 위반을 명확히 표현하세요. 이는 코드의 가독성과 유지보수성을 높입니다.

5. **성능 고려**: 예외 처리는 비용이 많이 드는 작업입니다. 자주 발생할 수 있는 오류 조건(예: 잘못된 사용자 입력)은 예외 대신 반환 코드나 `TryXXX` 패턴을 고려하세요.

6. **로그 기록**: 예외가 발생한 컨텍스트(사용자 ID, 요청 경로, 입력값 등)를 로그에 기록하되, 개인정보 보호법을 준수하세요.

7. **보안 고려**: 예외 메시지에 시스템 내부 정보(데이터베이스 구조, 파일 경로, 스택 추적 등)가 포함되지 않도록 주의하세요. 운영 환경에서는 일반적인 오류 메시지만 사용자에게 표시하세요.

예외 처리는 소프트웨어의 신뢰성과 사용자 경험을 결정하는 중요한 요소입니다. 처음부터 견고한 예외 처리 전략을 수립하면, 장기적으로 유지보수하기 쉽고 신뢰할 수 있는 애플리케이션을 구축할 수 있습니다.