---
layout: post
title: 영상처리 - 영상 반전하기
date: 2025-09-18 19:25:23 +0900
category: 영상처리
---
# 영상 반전하기

## 1. IppImage 클래스를 이용한 **픽셀 값 접근 방법**

> 아래 접근 방법은 이전 장의 `IppImage<T,C>` 설계를 그대로 사용합니다.

- **버퍼 구조**: Top-Down, interleaved, `stride`(행 당 바이트)  
- **기본 API**  
  - `rowp(y)` → y행 시작 포인터  
  - `ptr(x,y)` → (x,y) 픽셀 포인터  
  - `operator()(x,y,ch)` → 채널값 참조  
- **주의**: `stride` 는 `width*C*sizeof(T)` 보다 **크거나 같음** (정렬 때문)

### 예: Gray8(1채널) 한 줄 처리
```cpp
void invertGray8_line(IppImage<uint8_t,1>& img, int y) {
    uint8_t* r = img.rowp(y);
    for (int x=0; x<img.width(); ++x) {
        r[x] = 255 - r[x];
    }
}
```

### 예: BGR24(3채널) 한 픽셀 처리
```cpp
void invertBgr24_pixel(IppImage<uint8_t,3>& img, int x, int y) {
    uint8_t* p = img.ptr(x,y);
    p[0] = 255 - p[0];  // B
    p[1] = 255 - p[1];  // G
    p[2] = 255 - p[2];  // R
}
```

---

## 2. **영상의 반전이란?**

### 2.1 8-bit 정수형(0~255)
- **정의**: `v' = 255 - v`  
- 히스토그램 관점: 밝은 영역↔어두운 영역 **대칭 교환**  
- 두 번 적용하면 원본 회복(이론적으로 **자기 역원**)

### 2.2 16-bit 정수형(0~65535)
- `v' = 65535 - v`

### 2.3 부동소수(0.0~1.0) 정규화 영상
- `v' = 1.0f - v`  
- 두 번 적용하면 동일하게 원복  
- **감마**: 보통 “채널 값 자체” 반전(감마 미고려).  
  색역/감마를 정확히 다루려면 **선형화 후 반전**을 고려할 수 있지만, **일반 영상처리 교재/도구** 수준에선 채널값 반전으로 충분합니다.

### 2.4 컬러 영상(BGR/BGRA)
- **알파 제외**한 **색 채널만 반전**:  
  - B,G,R 각각 `255 - chan`  
  - A(알파)는 그대로 유지(투명도는 “색”이 아님)

---

## 3. **영상 반전 구현**

### 3.1 범용 템플릿(정수형/부동소수 모두)
```cpp
// Invert.h
#pragma once
#include "IppImage.h"
#include <type_traits>
#include <limits>

template<typename T, int C>
void InvertImage(IppImage<T,C>& img, bool invertAlpha=false) {
    if (!img) return;

    // 범위 상한/하한
    using lim = std::numeric_limits<T>;
    const bool isFloat = std::is_floating_point<T>::value;
    const T maxv = isFloat ? (T)1 : lim::max();
    const T minv = isFloat ? (T)0 : lim::min(); // 보통 0

    for (int y=0; y<img.height(); ++y) {
        T* row = img.rowp(y);
        for (int x=0; x<img.width(); ++x) {
            T* p = &row[x*C];
            // 각 채널 반전
            for (int ch=0; ch<C; ++ch) {
                // 알파 채널이 있고(ch==3) invertAlpha=false면 건너뛴다(BGRA32 가정)
                if (!invertAlpha && C==4 && ch==3) continue;
                if constexpr (std::is_floating_point<T>::value) {
                    p[ch] = (T)1 - p[ch];       // 0..1
                } else {
                    p[ch] = (T)(maxv - p[ch]);  // 정수
                }
            }
        }
    }
}
```

> **포인트**  
> - BGRA32일 때 **A채널 유지** 기본, 필요 시 `invertAlpha=true`  
> - float는 0…1 범위를 가정. 범위 밖 값이 있다면 클램프를 추가하세요.

### 3.2 구체 타입 최적화(Gray8/BGR24/BGRA32)

성능·가독성을 위해 **전용 루프**가 유리합니다.

```cpp
// InvertSpecialized.h
#pragma once
#include "IppImage.h"
#include <cstdint>

using Gray8  = IppImage<uint8_t,1>;
using BGR24  = IppImage<uint8_t,3>;
using BGRA32 = IppImage<uint8_t,4>;

inline void InvertGray8(Gray8& img) {
    for (int y=0; y<img.height(); ++y) {
        uint8_t* r = img.rowp(y);
        for (int x=0; x<img.width(); ++x) r[x] = 255 - r[x];
    }
}

inline void InvertBGR24(BGR24& img) {
    for (int y=0; y<img.height(); ++y) {
        uint8_t* r = reinterpret_cast<uint8_t*>(img.rowp(y));
        for (int x=0; x<img.width(); ++x) {
            uint8_t* p=&r[x*3];
            p[0]=255-p[0]; p[1]=255-p[1]; p[2]=255-p[2];
        }
    }
}

inline void InvertBGRA32(BGRA32& img, bool invertAlpha=false) {
    for (int y=0; y<img.height(); ++y) {
        uint8_t* r = reinterpret_cast<uint8_t*>(img.rowp(y));
        for (int x=0; x<img.width(); ++x) {
            uint8_t* p=&r[x*4];
            p[0]=255-p[0]; p[1]=255-p[1]; p[2]=255-p[2];
            if (invertAlpha) p[3]=255-p[3];
        }
    }
}
```

### 3.3 **ROI(부분 영역)** 만 반전하기

```cpp
// 예: (x0,y0,w,h) 영역만 반전, Gray8
inline void InvertROI(Gray8& img, int x0,int y0,int w,int h) {
    if (x0<0||y0<0||x0+w>img.width()||y0+h>img.height()) return;
    for (int y=0; y<h; ++y) {
        uint8_t* r = img.rowp(y0+y) + x0;
        for (int x=0; x<w; ++x) r[x] = 255 - r[x];
    }
}
```

---

## 4. **영상 반전 메뉴** 만들기 (Win32 기반)

> **전제**: 이전 장의 `main_multiwin.cpp` 구조(툴바/상태바/출력창) 그대로 사용

### 4.1 `resource.h` 에 메뉴 ID 추가
```cpp
#define ID_EDIT_INVERT    40100
```

### 4.2 `.rc` 파일의 메뉴에 항목 추가
```rc
POPUP "&Edit"
BEGIN
    MENUITEM "&Copy\tCtrl+C",  ID_EDIT_COPY
    MENUITEM "&Paste\tCtrl+V", ID_EDIT_PASTE
    MENUITEM SEPARATOR
    MENUITEM "&Invert\tCtrl+I", ID_EDIT_INVERT
END
```

**가속기(선택)**:
```rc
IDR_ACCEL ACCELERATORS
BEGIN
    "I",  ID_EDIT_INVERT, VIRTKEY, CONTROL
END
```

### 4.3 이벤트 처리기 (두 경로 제공)

#### (A) **IppDib**만 쓰는 프로젝트: **DIB 직접 반전**
> 이미 32bpp BGRA Top-Down 이므로 `IppDib::invert()` 호출이 가장 간단.

```cpp
// main_multiwin.cpp의 WM_COMMAND 처리
case ID_EDIT_INVERT:
    if (st && st->dib) {
        st->dib.invert();                    // B,G,R만 반전 (전 장 구현)
        OutputBasicInfo(st);
        InvalidateRect(hWnd, nullptr, FALSE);
    }
    return 0;
```

#### (B) **IppImage로 처리**하고 다시 DIB로 반영
> IppImage에서 다양한 타입/알고리즘을 활용하고 싶을 때.

```cpp
#include "IppInterOp.h"     // FromIppDib / ToIppDib
#include "InvertSpecialized.h"

case ID_EDIT_INVERT:
    if (st && st->dib) {
        BGR24 tmp;                      // 또는 Gray8, BGRA32 등
        FromIppDib(st->dib, tmp);       // DIB → IppImage
        InvertBGR24(tmp);               // 처리
        ToIppDib(tmp, st->dib, nullptr);// IppImage → DIB
        OutputBasicInfo(st);
        InvalidateRect(hWnd, nullptr, FALSE);
    }
    return 0;
```

> **팁**  
> - Gray BMP라면 Gray8으로 받아 반전하면 **속도/메모리** 효율적  
> - 메뉴 항목을 “Invert (Luma)” / “Invert (RGB)” 등으로 나눠도 좋습니다.

---

## 5. **매크로 함수를 이용한 코드 간소화**

반복되는 2중 루프/채널 접근을 **매크로/인라인**으로 줄이면 코드가 깔끔해집니다.

### 5.1 2D 루프 매크로
```cpp
// LoopMacros.h
#pragma once

#define FOR_EACH_Y(img)            for (int y__=0; y__<(img).height(); ++y__)
#define ROW_PTR(img, T)            reinterpret_cast<T*>((img).rowp(y__))
#define FOR_EACH_X(img)            for (int x__=0; x__<(img).width(); ++x__)
#define PIX_PTR(row, C, x)         (&(row)[(x)* (C)])
```

**사용 예**(BGR24 반전):
```cpp
#include "LoopMacros.h"

inline void InvertBGR24_Macro(IppImage<uint8_t,3>& img) {
    FOR_EACH_Y(img) {
        auto* row = ROW_PTR(img, uint8_t);
        FOR_EACH_X(img) {
            uint8_t* p = PIX_PTR(row, 3, x__);
            p[0] = 255 - p[0];
            p[1] = 255 - p[1];
            p[2] = 255 - p[2];
        }
    }
}
```

### 5.2 채널 루프까지 포괄
```cpp
#define FOR_EACH_CH(C) for (int ch__=0; ch__<(C); ++ch__)

template<typename T, int C>
inline void Invert_Generic_Macro(IppImage<T,C>& img, bool invertAlpha=false) {
    FOR_EACH_Y(img) {
        T* row = ROW_PTR(img, T);
        FOR_EACH_X(img) {
            T* p = PIX_PTR(row, C, x__);
            FOR_EACH_CH(C) {
                if (!invertAlpha && C==4 && ch__==3) continue;
                if constexpr (std::is_floating_point<T>::value) p[ch__] = (T)1 - p[ch__];
                else                                            p[ch__] = std::numeric_limits<T>::max() - p[ch__];
            }
        }
    }
}
```

> **주의**: 매크로는 디버깅이 불편할 수 있습니다. **인라인 함수**(람다)로 대체하는 것도 좋은 선택입니다.

---

## 6. **테스트/검증** 포인트

- **자기 역원성**: `invert(invert(img)) == img` (정수/0~1 float)  
- **성능**: 큰 이미지(예: 8K)에서 루프 최적화, 캐시 친화성(행 우선) 확인  
- **알파 보존**: BGRA32에서 A 변하지 않는지(옵션 off)  
- **ROI**: 부분 반전 시 좌표/크기 경계 검사  
- **다중 포맷**: Gray8/BGR24/BGRA32/Gray16/float 각각 수동 테스트  
- **클립보드/파일**: 반전 후 저장/붙여넣기 및 타 앱에서 확인

---

## 7. **성능 팁**(선택)

- **OpenMP**: 행 단위 병렬화 → `#pragma omp parallel for`  
- **SIMD**: 32바이트 정렬(이미 정렬 stride) 활용해 **AVX2** 로 32픽셀 단위 반전  
- **타일링**: 큰 이미지에서 CPU 캐시 적중률 향상

---

## 8. **전체 통합 예제** (간단 버전)

> Gray8/BGR24/BGRA32 세 경우 모두 지원. 앱 메뉴 `Invert` 클릭 시 즉시 반영.

```cpp
// InvertMenuHandler.h
#pragma once
#include "IppDib.h"
#include "IppInterOp.h"
#include "InvertSpecialized.h"

inline void DoMenuInvert_UsingDib(HWND hWnd, IppDib& dib) {
    if (!dib) return;
    dib.invert(); // BGRA32 BGR만 반전
    InvalidateRect(hWnd, nullptr, FALSE);
}

inline void DoMenuInvert_UsingIppImage_Bgr(HWND hWnd, IppDib& dib) {
    if (!dib) return;
    BGR24 img;
    FromIppDib(dib, img);
    InvertBGR24(img);
    ToIppDib(img, dib, nullptr);
    InvalidateRect(hWnd, nullptr, FALSE);
}
```

---

## 9. **요약**

- **반전의 정의**: 정수(8/16) → `max - v`, float(0..1) → `1 - v`  
- **컬러**: BGR/BGRA **색 채널만** 반전(알파 유지)  
- **IppImage 접근**: `rowp/ptr/operator()` 로 빠르고 안전  
- **구현 선택**  
  - **간단/빠름**: `IppDib::invert()`(BGRA32 직접)  
  - **일반화**: `IppImage<T,C>` 에서 처리 후 DIB로 반영  
- **메뉴 통합**: `[Edit] → Invert` + Ctrl+I, 핸들러에서 한 줄 호출  
- **매크로/인라인**: 2중 루프/채널 루프를 추상화해 **가독성 향상**