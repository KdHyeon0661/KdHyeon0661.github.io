---
layout: post
title: 네트워크보안 - 시작
date: 2025-10-23 14:25:23 +0900
category: 네트워크보안
---
# 0. 시작하기 (상세 가이드)

## 0.1 범위/목표: Red·Blue·Purple 역할

### 🎯 우리가 다룰 범위
- **네트워크 보안 전 과정**: 정찰(스캐닝) → 가로채기/스니핑/세션조작 → 프로토콜 공격·방어 → 탐지·로깅·대응.
- **계층**: L2(스위칭/ARP), L3(라우팅/ICMP), L4(TCP/UDP), L7(HTTP/DNS/TLS), 무선(802.11).
- **환경**: 개인 PC의 가상화(Bridge/NAT/Host-only), 클라우드 격리 VPC, 컨테이너(도커/쿠버네티스) 기반 테스트.

> 제외: 실제 타인/타 조직 대상 테스트, 상용 서비스에 대한 비인가 스캐닝·침투.  
> 포함: **합법적** 사전 승인 대상(본인 소유, 명시적 허가된 자산)의 학습·실험·모의침투.

### 🧭 역할 정의
- **Red Team (공격)**  
  목표: 취약점 발견·악용 경로 증명(Exploit Proof), 리스크 우선순위 제시.  
  산출물: 재현 절차, 영향 범위, 완화책 제안(기술/운영).
- **Blue Team (수비)**  
  목표: 사전 예방(구성·정책), 탐지 규칙(Suricata/Zeek/SIEM), 사고 대응(IR) 플레이북.  
  산출물: 탐지 룰, 경보 튜닝, 포렌식 절차, 운영 체크리스트.
- **Purple Team (협업/연동)**  
  목표: Red 시나리오를 Blue의 탐지/대응에 **즉시 연결**.  
  산출물: 공격기법↔탐지시그니처 매핑, 탐지 공백 제거, MTTD/MTTR 개선.

### ✅ 역할별 “완성의 정의(DoD)” 체크리스트
- Red: 승인된 범위 내에서 **재현 가능한 PoC**와 **치료 가능한 권고안** 제공.
- Blue: 관련 TTP에 대응하는 **탐지 룰**(단위테스트 포함)과 **대응 절차서** 확보.
- Purple: 공격-탐지-대응 사이의 **추적성(Traceability)** 보장(시나리오→로그→알람→조치).

---

## 0.2 합법·윤리: 책임 있는 공개(Responsible Disclosure), 테스트 범위(ROE), 로그·개인정보 처리

### ⚖️ 윤리·합법 원칙
- **사전 승인(Authorization)**: 테스트 대상, 시간, 수단, 한계, 연락 포인트를 문서화.  
- **무중단 안전(Safety)**: 서비스 중단·데이터 손실·법 위반 위험을 배제/최소화(레이트 제한, 공격 강도 제한).  
- **최소 권한·최소 수집**: 필요한 데이터만 수집, 민감정보는 즉시 마스킹/암호화.  
- **복구 가능성**: 설정 변경·PoC는 원복 절차 포함.  
- **책임 공개**: 본인 소유/승인 대상 외 취약점 발견 시, 안전한 경로로 통지하고 악용 금지.

### 📝 ROE(룰 오브 엔게이지먼트) 샘플 템플릿
```markdown
# Rules of Engagement (ROE) — 네트워크 보안 테스트

## 1) 테스트 개요
- 목적: 내부 랩 네트워크 방어능력 점검(스니핑·MITM 탐지/차단 검증)
- 기간: 2025-11-05 10:00 ~ 2025-11-07 18:00 (KST)
- 테스트 범위: 10.10.0.0/24 (랩망), 10.10.0.1/24 (게이트웨이), 10.10.0.10/24 (웹서버), 10.10.0.20/24 (클라이언트)
- 제외: 외부 인터넷, 회사/타인 자산, 무단 무선 AP

## 2) 허용/금지 행위
- 허용: Nmap 스캔(T3 이하), ARP 스푸핑(격리망), DNS 스푸핑(테스트 존), 패킷 캡처
- 금지: 서비스 중단 유발 공격(DoS), 인증정보 외부 반출, 취약 데이터 영구 저장

## 3) 강도·속도 제한
- 스캔 레이트: SYN 200pps 이하, UDP 100pps 이하
- ARP 스푸핑: 단일 서브넷 내 10분 이내, 이후 복구 절차 실행

## 4) 로그·데이터 처리
- 캡처 파일: 로컬 암호화 저장(AES-256), 7일 내 파기
- PII/민감정보: 마스킹 규칙 적용(예: 이메일/쿠키 토큰 해시화)
- 접근 통제: 테스트 리더/감사자 2인 승인 시 열람

## 5) 의사소통
- 온콜: SecOps(010-XXXX-YYYY), 랩 네트워크 소유자(010-ZZZZ-WWWW)
- 인시던트 기준: 비의도 서비스 중단/성능 저하 발생 시 즉시 중단·보고

## 6) 종료·원복
- 테스트 종료 후 ARP 테이블 정상화, 스위치 보안 기능 재적용 검증
- 결과 보고서: 48시간 내 제출(리스크/개선안/재현절차 포함)
```

### 🔏 로그·개인정보(PII) 처리 지침(샘플)
- **수집 최소화**: 패킷 페이로드는 기본 비저장, 메타데이터(5-tuple, 바이트/패킷 수, JA3 해시) 중심.  
- **익명화 파이프라인**:
  - IP → **가명화**: 내부 맵핑 테이블(암호화 저장)로 토큰화.
  - 사용자 식별자/쿠키 → 해시(SHA-256 + 조직 고정 salt), 원문 저장 금지.
  - 이메일/전화번호 등 정규식 탐지 후 마스킹(중앙 40~60% `*` 처리).
- **보관 주기**: 원본 PCAP 7일, 익명화 Flow 로그 90일(합의 필요).
- **접근 제어**: 개인별 RBAC, 접근 로그 기록, 4-eyes 승인.
- **전송·휴지 암호화**: S3/디스크 암호화 + HTTPS/mTLS 전송.

#### 예제: PCAP에서 PII 마스킹(테스트용)
```bash
# 1) HTTP만 추출(테스트망에서만 사용)
tshark -r input.pcap -Y "http" -w http_only.pcap

# 2) 민감 헤더 제거(간소한 예시 — 실제 운영은 전용 익명화 툴 권장)
editcap --inject-secrets dyn,http,Authorization:REDACTED http_only.pcap http_sanitized.pcap

# 3) 전체 PCAP AES-256 암호화(공유 전)
zip -P '강한_비밀번호' -e http_sanitized.zip http_sanitized.pcap
```

#### 예제: 간단한 이메일/쿠키 패턴 마스킹(Python)
```python
import re, hashlib, sys, pathlib

def mask_email(s: str) -> str:
    return re.sub(r'([A-Za-z0-9._%+-]+)@([A-Za-z0-9.-]+\.[A-Za-z]{2,})',
                  lambda m: m.group(1)[:2] + "***@" + m.group(2), s)

def hash_cookie(s: str) -> str:
    def repl(m):
        raw = m.group(1).encode()
        h = hashlib.sha256(raw + b"fixed_org_salt").hexdigest()[:16]
        return f"Cookie: token={h}"
    return re.sub(r'Cookie:\s*token=([A-Za-z0-9\-_\.]+)', repl, s)

text = pathlib.Path(sys.argv[1]).read_text(encoding='utf-8', errors='ignore')
text = mask_email(text)
text = hash_cookie(text)
pathlib.Path('sanitized.txt').write_text(text, encoding='utf-8')
print("sanitized -> sanitized.txt")
```

> ⚠️ 실제 운영 환경에선 **전용 익명화 도구/파이프라인**을 권장하고, 조직의 개인정보보호 기준(국내법/GDPR 등)에 맞춰 정책화하세요.

---

## 0.3 랩 환경: 가상 스위치/브리지/NAT, 클라우드 격리 VPC, 샘플 PCAP·토폴로지

### 🧪 랩 설계 원칙
- **완전 격리**: 외부 네트워크와 트래픽 혼선 없음(Host-only/전용 VPC).  
- **재현 가능**: IaC(예: Terraform/Ansible)·Compose로 동일 환경 신속 구축.  
- **관찰성 우선**: 미러 포트(가상 스위치), 패킷 캡처 포인트, 중앙 로깅.

### A) 로컬 가상 네트워크 (리눅스 네임스페이스 기반 미니 랩)
- 장점: 초경량, 호스트 1대로 “스위치/게이트웨이/클라이언트/공격자” 구성.
- 사용: `ip netns`, veth, 가상브릿지(bridge), tcpdump/Wireshark.

#### 토폴로지
```
[ns-attacker]---veth-a <-> (br0) <-> veth-c---[ns-client]
                         |
                         +--- veth-g---[ns-gw]  (게이트웨이: NAT 역할)
```

#### 구축 스크립트(예제, root 필요)
```bash
# 0) 깨끗한 시작
ip link del veth-a 2>/dev/null || true
ip link del veth-c 2>/dev/null || true
ip link del veth-g 2>/dev/null || true
ip link del br0 2>/dev/null || true
ip netns del ns-attacker 2>/dev/null || true
ip netns del ns-client 2>/dev/null || true
ip netns del ns-gw 2>/dev/null || true

# 1) 네임스페이스 생성
ip netns add ns-attacker
ip netns add ns-client
ip netns add ns-gw

# 2) 브릿지 생성
ip link add br0 type bridge
ip link set br0 up

# 3) veth 페어 생성 및 연결
ip link add veth-a type veth peer name veth-a-br
ip link add veth-c type veth peer name veth-c-br
ip link add veth-g type veth peer name veth-g-br

# 4) 브릿지에 연결
ip link set veth-a-br master br0
ip link set veth-c-br master br0
ip link set veth-g-br master br0
ip link set veth-a-br up
ip link set veth-c-br up
ip link set veth-g-br up

# 5) 각 네임스페이스에 veth 할당
ip link set veth-a netns ns-attacker
ip link set veth-c netns ns-client
ip link set veth-g netns ns-gw
ip -n ns-attacker link set veth-a up
ip -n ns-client  link set veth-c up
ip -n ns-gw      link set veth-g up

# 6) IP 부여
ip -n ns-attacker addr add 10.10.0.11/24 dev veth-a
ip -n ns-client  addr add 10.10.0.10/24 dev veth-c
ip -n ns-gw      addr add 10.10.0.1/24  dev veth-g

# 7) 게이트웨이 설정
ip -n ns-attacker route add default via 10.10.0.1
ip -n ns-client  route add default via 10.10.0.1

# 8) ns-gw에 NAT 구성(외부 인터넷이 필요 없다면 생략 가능)
# 여기서는 호스트의 eth0을 외부로 가정 — 실제 환경에 맞게 수정
# iptables -t nat -A POSTROUTING -s 10.10.0.0/24 -o eth0 -j MASQUERADE
# ip netns exec ns-gw sysctl -w net.ipv4.ip_forward=1

echo "DONE. ns-attacker/ns-client/ns-gw up."
```

#### 기본 통신 테스트 & 캡처
```bash
# 클라이언트에서 게이트웨이 핑
ip netns exec ns-client ping -c 2 10.10.0.1

# 공격자 ↔ 클라이언트 통신 발생시키기
ip netns exec ns-attacker ping -c 2 10.10.0.10

# 브릿지(br0)에서 패킷 캡처(호스트에서)
tcpdump -i br0 -nn -e -v 'arp or icmp'

# 특정 ns에서 캡처
ip netns exec ns-client tcpdump -i veth-c -w client.pcap
```

#### 미니 ARP 스푸핑 실습(※ 격리망에서만)
```bash
# 공격자 ns에서 arpspoof(패키지: dsniff) 사용 예 (설치 필요)
ip netns exec ns-attacker arpspoof -i veth-a -t 10.10.0.10 10.10.0.1   # 클→GW
ip netns exec ns-attacker arpspoof -i veth-a -t 10.10.0.1  10.10.0.10  # GW→클

# ns-client에서 ARP 테이블 변화 확인
ip netns exec ns-client ip neigh show
```

> 방어 시나리오: 브릿지 대신 스위치 보안 기능(DAI/DHCP Snooping 유사)을 구현하긴 어렵지만,  
> **Zeek/Suricata**로 ARP 이상을 탐지하거나, **정적 ARP** 설정을 시험해볼 수 있습니다.

---

### B) Docker Compose 기반 랩 (웹/DNS/미들박스 포함)
- 목적: **L7까지** 다뤄보는 가벼운 컨테이너 랩.
- 구성: `attacker`(도구), `client`(브라우저/ curl), `web`(Nginx), `dns`(테스트용 dnsmasq), `mirror`(tcpdump).

#### docker-compose.yml (학습용 샘플)
```yaml
version: "3.9"
services:
  web:
    image: nginx:alpine
    networks: [ labnet ]
    ports: ["8080:80"]
    volumes:
      - ./webroot:/usr/share/nginx/html:ro

  dns:
    image: andyshinn/dnsmasq:2.78
    command: ["-k", "--log-facility=-", "--address=/test.local/10.10.10.10"]
    networks: [ labnet ]

  client:
    image: curlimages/curl:8.10.1
    entrypoint: ["sleep", "infinity"]
    networks: [ labnet ]

  attacker:
    image: debian:stable-slim
    entrypoint: ["sleep", "infinity"]
    networks: [ labnet ]
    cap_add: ["NET_ADMIN","NET_RAW"]

  mirror:
    image: corfr/tcpdump
    command: ["-i", "any", "-w", "/pcap/lab.pcap"]
    networks: [ labnet ]
    volumes:
      - ./pcap:/pcap
    cap_add: ["NET_ADMIN","NET_RAW"]

networks:
  labnet:
    driver: bridge
```

#### 실습 명령
```bash
docker compose up -d
# client에서 웹 호출
docker compose exec client sh -c "curl -s http://web/ | head"
# dns 질의(컨테이너 내부에는 dig 없음 → busybox nslookup 사용 가능)
docker compose exec client sh -c "nslookup test.local dns || true"

# mirror가 저장한 PCAP 확인
ls -lh pcap/lab.pcap
```

> 확장: `attacker`에 `nmap`, `arpspoof`, `scapy`를 설치해 스니핑/정찰을 실습합니다.  
> (컨테이너 브릿지는 L2 전형과 달라 ARP 스푸핑 동작이 다를 수 있어, 필요 시 **Macvlan**/Host 네트워크 옵션을 연구하세요.)

---

### C) 클라우드 격리 VPC (Terraform 예시 — 최소 예)
> **주의**: 비용 발생 가능. 인터넷 노출 없이 **프라이빗 서브넷**만으로 시작하세요.

```hcl
# main.tf — 개념용 축약본
provider "aws" {
  region = "ap-northeast-2"
}

resource "aws_vpc" "lab" {
  cidr_block           = "10.20.0.0/16"
  enable_dns_hostnames = true
  tags = { Name = "lab-vpc" }
}

resource "aws_subnet" "private_a" {
  vpc_id                  = aws_vpc.lab.id
  cidr_block              = "10.20.1.0/24"
  availability_zone       = "ap-northeast-2a"
  map_public_ip_on_launch = false
  tags = { Name = "lab-private-a" }
}

# VPC 엔드포인트(S3/Logs 등)나 Bastion 없이 SSM Session Manager를 쓰면
# 퍼블릭 노출 없이 인스턴스를 관리 가능(권장).
resource "aws_security_group" "lab_sg" {
  name        = "lab-sg"
  description = "Isolated lab"
  vpc_id      = aws_vpc.lab.id

  # inbound/ outbound 최소화
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# EC2는 여기서 생략(SSM/프라이빗만 구성 권장)
```

> 권장: **인터넷 게이트웨이 없이**, SSM Session Manager로만 접속 → 진짜 격리.  
> PCAP/로그는 S3(암호화)로 수집하고, 7~30일 보관 후 자동 삭제 정책(Lifecycle Rule) 설정.

---

### D) 샘플 PCAP·토폴로지·분석 워크시트

#### 샘플 트래픽 시드(자체 생성)
```bash
# client 컨테이너에서 시드 트래픽 생성
docker compose exec client sh -c "for i in 1 2 3; do curl -s http://web/ >/dev/null; sleep 1; done"
docker compose exec client sh -c "wget -qO- http://web/ >/dev/null || true"
docker compose exec client sh -c "nslookup test.local dns || true"
```

#### Wireshark 필터 예시
- TCP Handshake만: `tcp.flags.syn == 1 and tcp.flags.ack == 0`
- HTTP 요청: `http.request`
- DNS 쿼리: `dns.flags.response == 0`
- ARP 이례: `arp.opcode == 2 and arp.src.proto_ipv4 == 10.10.0.1 and eth.src != {게이트웨이 MAC}`

#### 분석 워크시트(예)
```markdown
- 시나리오: client → web HTTP 요청 중 지연 발생
- 관찰:
  - [ ] SYN 재전송 횟수 / RTT
  - [ ] 서버 측 RST/FIN 타이밍
  - [ ] DNS 해석 지연(권위/재귀)
- 가설:
  - [ ] MTU/MSS 미스매치 → 프래그먼트/재전송?
  - [ ] NAT 테이블 과포화?
- 실험:
  - [ ] tc netem으로 1% 패킷 손실/50ms 지연 주입 후 비교
- 결론/개선:
  - [ ] 서버/클라이언트 MSS 정렬, Keep-Alive/커넥션 풀 튜닝
```

---

## (보너스) Red/Blue/Purple 공동 미션 예제

### 미션 1 — ARP 스푸핑 탐지·차단
- **Red**: ns-attacker에서 ARP 스푸핑 3분 수행 → client 통신 중개.
- **Blue**: Zeek/Suricata로 ARP Reply 빈도 급증 규칙 추가, 알람 발생 확인.
- **Purple**: 알람 발생 시 `ip neigh flush` 자동 실행(랩 한정), 게이트웨이 ARP 재주입.

#### Suricata 룰 샘플(개념용)
```conf
alert ether any any -> any any (msg:"ARP storm likely"; ether type 0x806; detection_filter:track by_src, count 50, seconds 10; sid:4200001; rev:1;)
```

### 미션 2 — 평문 제거·TLS 전환
- **Red**: HTTP 로그인 폼 제출 캡처(랩 안에서만) → 위험 제시.
- **Blue**: Nginx에 TLS 적용, HSTS 설정, 쿠키 Secure/HttpOnly, 리다이렉트 강제.
- **Purple**: 변경 후 재공격 → 가시성(메타데이터 수준)과 남은 위험(SNI) 기록.

#### Nginx 간단 TLS 스니펫(학습용)
```nginx
server {
  listen 443 ssl;
  server_name web.local;
  ssl_certificate     /etc/nginx/certs/fullchain.pem;
  ssl_certificate_key /etc/nginx/certs/privkey.pem;
  add_header Strict-Transport-Security "max-age=31536000" always;
  location / { root /usr/share/nginx/html; index index.html; }
}
server {
  listen 80;
  return 301 https://$host$request_uri;
}
```

---

## 체크리스트 요약

- [ ] **ROE 문서화**: 범위/강도/데이터 처리/연락/원복.
- [ ] **격리 랩** 준비: 로컬 네임스페이스 or Compose or 클라우드 VPC(인터넷 차단).
- [ ] **도구**: tcpdump/Wireshark/Zeek/Suricata/Nmap/Scapy, 샘플 PCAP.
- [ ] **PII 보호**: 수집 최소화, 마스킹/해시, 보관 주기, 접근 제어.
- [ ] **Purple 루프**: Red 시나리오 ↔ Blue 탐지 ↔ 조치 자동화 실험.
