---
layout: post
title: 네트워크보안 - 시작
date: 2025-10-23 14:25:23 +0900
category: 네트워크보안
---
# 시작하기 (상세 가이드)

## 범위/목표: Red·Blue·Purple 역할

### 우리가 다룰 범위

이 연재에서 다루는 범위는 단순히 “방화벽 설정 몇 개” 수준이 아니라, **네트워크 보안 라이프사이클 전체**다.

- **공격 흐름(ATT&CK 관점 축약)**  
  - 정찰(Scanning/Enumeration)  
  - 가로채기 / 스니핑 / 세션 하이재킹 (L2/L3/L4/L7)  
  - 프로토콜 취약점 활용(ARP, ICMP, TCP, HTTP, DNS, TLS 등)  
  - 권한 상승·측면 이동·지속성 확보  
  - 데이터 탈취·파괴·가용성 공격(DoS/DDoS, 랜섬웨어)  
- **방어 흐름**  
  - 사전 예방: 네트워크 설계, 세그멘테이션, L2 보호(DAI/DHCP Snooping/Port Security), L3 ACL, L7 WAF/TLS 정책  
  - 탐지: NDR/IDS(예: Suricata, Zeek), 로그 수집·상관분석(SIEM)  
  - 대응: 차단·격리, 포렌식, 재발 방지 패치, 플레이북 개선  
- **계층별 포커스**  
  - L2: 스위칭, ARP, MAC 플러딩, VLAN 호핑, 포트 보안  
  - L3: 라우팅, ICMP 악용/탐지, BGP 개요(심화에서 다룸)  
  - L4: TCP 세션 하이재킹·RST/FIN 스캐닝, UDP 기반 탐지  
  - L7: HTTP(S) 인증·세션, DNS 조작, TLS 핸드셰이크·암호군, JA3/JA4  
  - 무선(802.11): 오픈/PSK/Enterprise, 관리 프레임 공격, WIDS/WIPS

최근 미국 Verizon의 **2025 Data Breach Investigations Report(DBIR)** 는  
11개월 동안 **2만 2천 건 이상의 보안 인시던트와 약 1만 2천 건의 확인된 침해 사고**를 분석했다.:contentReference[oaicite:0]{index=0}  
이 보고서에 따르면 **침해 사고의 거의 60%에 “인간 요소”가 개입**되며(오류, 피싱, 내부자의 악의적 행동 등),:contentReference[oaicite:1]{index=1}  
공격 표면은 클라우드·원격근무·공급망 연계로 계속 확장되고 있다.

유럽연합 사이버보안기구 ENISA의 **Threat Landscape 2025**는  
2024년 7월부터 2025년 6월 사이의 **약 4,900개 사건**을 분석했고,  
랜섬웨어·DDoS·해킹티비즘이 **지속적이고 수렴하는(convergent) 위협**으로 나타난다고 정리한다.:contentReference[oaicite:2]{index=2}  
2024년판 Threat Landscape에서는 **가용성 위협(DDoS 등)** 과 **랜섬웨어·데이터 탈취**가  
유럽 내에서 특히 큰 비중을 차지하는 것으로 보고되었다.:contentReference[oaicite:3]{index=3}  

이 연재의 목표는 이런 최신 글로벌 위협 데이터를 배경으로,  
실제 **Red/Blue/Purple 팀 관점의 실습 가능한 랩**과 **운영에 쓸 수 있는 체크리스트**를 만드는 것이다.

---

### 역할 정의

#### Red Team (공격 관점)

- **목표**
  - 합법적인 범위 안에서 **실제 공격자가 할 법한 행동을 재현**해 본다.
  - 단순 PoC를 넘어, **위협 시나리오와 비즈니스 영향**을 보여준다.
- **핵심 활동**
  - 정보 수집: 포트 스캔, 서비스·버전 파악, OS Fingerprinting, 공개 정보(OSINT)
  - 취약점 분석: 잘못된 구성, 노후 프로토콜, 평문 통신, 인증·세션 취약점
  - 악용 경로 설계: L2 MITM, DNS Spoof, HTTP 세션 하이재킹, 취약 API 남용 등
  - 보고서 작성: 재현 절차, 영향 평가, 완화책(패치, 구성 변경, 모니터링 보강)
- **실무 산출물 예**
  - “10.10.0.10 웹 애플리케이션: 평문 로그인·취약 세션 쿠키 → 네트워크 스니핑으로 계정 탈취 가능”  
  - “동일 서브넷 내 ARP 스푸핑 시도에 대해 DAI가 활성화되어 있지 않아 게이트웨이 MAC이 쉽게 위조됨”

#### Blue Team (수비 관점)

- **목표**
  - 구성·정책·도구를 활용해 **공격을 사전에 어렵게 만들고**,  
    발생한 이벤트를 **빨리 탐지**해 **피해를 최소화**하는 것.
- **핵심 활동**
  - 네트워크 설계·구성:
    - L2: VLAN, DAI, DHCP Snooping, Port Security
    - L3: 세그멘테이션, ACL, 라우팅 필터링
    - L7: WAF, TLS 설정, 인증·세션 정책
  - 모니터링 설계:
    - Suricata/Zeek 룰, NetFlow/sFlow, DNS 로그, TLS 메타(JA3/JA4)
  - 사고 대응(Incident Response):
    - 탐지 → 확인 → 격리(Quarantine) → 복구 → 사후 분석
  - 지표 관리:
    - **MTTD(Mean Time To Detect)**, **MTTR(Mean Time To Respond)**,  
      오탐/미탐 비율, 룰·플레이북 커버리지

간단히 수식으로 표현하면, 예를 들어 MTTD는 다음과 같다.

$$
\mathrm{MTTD} = \frac{1}{N} \sum_{i=1}^{N} (t^{\text{detect}}_i - t^{\text{start}}_i)
$$

여기서 \(t^{\text{start}}_i\) 는 각 공격/이벤트가 시작된 시각,  
\(t^{\text{detect}}_i\) 는 해당 이벤트가 모니터링 시스템에서 최초로 탐지된 시각이다.

#### Purple Team (협업/연동 관점)

- **목표**
  - Red가 찾은 취약점과 TTP를 **그대로 Blue의 탐지·대응 체인에 연결**하는 역할.
  - “공격자처럼 생각하되, 방어자의 언어로 번역”하는 팀.
- **핵심 활동**
  - 공격 시나리오 → 로그/이벤트 매핑:
    - 예: ARP 스푸핑 → ARP Reply 증가, 게이트웨이 MAC 변경, DHCP 이상
  - 탐지 룰 공동 설계:
    - Red가 실제로 사용하는 툴/패턴을 Suricata/Zeek 룰로 표현
  - 회귀 테스트:
    - 정기적으로 예전 공격 시나리오를 재실행하거나 **pcap 재생**으로  
      탐지 품질이 유지되는지 확인

---

### 역할별 “완성의 정의(DoD)” 체크리스트

#### Red Team DoD

- [ ] 테스트 범위·강도·시간·연락 체계가 **ROE 문서**로 합의되어 있다.
- [ ] 공격 절차가 **재현 가능하게 문서화**되어 있다(도구 버전·옵션 포함).
- [ ] 각 취약점에 대해 **구체적인 비즈니스 영향**이 서술되어 있다.
- [ ] **완화책**이 기술/조직/프로세스 관점에서 제안되어 있다.
- [ ] PII·민감 데이터에 대한 취급이 **데이터 처리 정책**과 일관된다.

#### Blue Team DoD

- [ ] Red가 사용한 TTP 각각에 대해 최소 한 개 이상의  
      **탐지 룰/대시보드/알람**이 정의되어 있다.
- [ ] 탐지 룰이 **테스트(유닛 테스트/pcap 재생)** 로 검증되어 있다.
- [ ] 알람이 발생했을 때 따라갈 수 있는 **대응 절차서(플레이북)** 가 있다.
- [ ] 룰과 플레이북이 **운영팀이 이해하는 용어**로 작성되어 있다.

#### Purple Team DoD

- [ ] “시나리오 → 로그 → 룰 → 알람 → 조치”의 **추적성(Traceability)** 이 보장된다.
- [ ] 주요 TTP에 대해 **회귀 테스트 스위트(pcap·합성 이벤트)** 가 준비되어 있다.
- [ ] MTTD/MTTR 개선 추세를 **정량적으로 측정**하고 있다.
- [ ] Red/Blue 모두가 합의한 “성공 조건”이 정의되어 있다.

---

## 합법·윤리: Responsible Disclosure, 테스트 범위(ROE), 로그·개인정보 처리

### 왜 윤리·법적 프레임이 먼저인가

Verizon DBIR와 ENISA Threat Landscape 보고서에서 반복되는 메시지는,  
**공격 시도 자체보다도 탐지 실패·관리 부실이 더 큰 피해를 부른다**는 점이다.:contentReference[oaicite:4]{index=4}  

그렇다고 해서 “보안을 위해서라면 아무 테스트나 해도 된다”는 뜻은 아니다.  
오히려 **법적·윤리적 기준을 준수하는 테스트 체계**를 만드는 것이  
조직의 신뢰·규제 준수·사후 책임 측면에서 필수적이다.

특히 유럽의 **NIS2, GDPR**, 미국의 각종 규제·가이드라인(NIST SP 800-115 등)은  
보안 테스트가 **명확한 범위·동의·데이터 보호 체계** 안에서 이루어져야 한다는 점을 강조한다.:contentReference[oaicite:5]{index=5}  

이 글에서는 **불법·무단 공격 행위는 전제로 하지 않고**,  
다음의 조건을 전제한다.

- 테스트 대상은 **본인이 소유하거나 명시적으로 승인된 자산**이다.
- 공격 실습은 **격리된 랩 환경**에서만 수행한다.
- 실제 운영망에서 필요한 검증은 **합성 트래픽·pcap 재생·시뮬레이션** 위주로 한다.

---

### 윤리·합법 핵심 원칙

1. **사전 승인(Authorization)**
   - 대상 시스템, 네트워크 범위, 테스트 도구·기법, 시간, 담당자 연락처를 문서로 남긴다.
   - 외부 벤더·고객 시스템이 포함될 경우, **계약/서면 동의**가 선행되어야 한다.

2. **무중단 안전(Safety)**
   - 스캔·공격 강도에 상한선을 둔다(패킷 레이트, 동시 연결 수, 공격 시간).
   - 고가용성 시스템이나 민감 시스템은 반드시 **별도의 승인·사전 위험 평가**가 필요하다.

3. **최소 권한·최소 수집**
   - 정말 필요한 계정·권한만 사용한다.
   - 테스트 중 수집하는 데이터(로그, 패킷, 덤프)는 **최소화·익명화·암호화** 한다.

4. **복구 가능성**
   - 테스트 전 상태로 되돌릴 수 있도록 **백업/스냅샷**을 준비한다.
   - 설정 변경을 동반하는 테스트는 반드시 **원복 절차**를 함께 기록한다.

5. **책임 있는 공개(Responsible Disclosure)**
   - 승인 범위 외에서 우연히 취약점을 발견한 경우,  
     이를 **악용하지 않고**, 안전한 채널을 통해 적절한 주체에게만 알린다.

---

### 샘플 템플릿 (ROE – Rules of Engagement)

아래는 실제 네트워크 보안 테스트에서 사용할 수 있는 ROE 문서의 예제다.  
조직 정책에 맞게 섹션을 추가·수정해서 사용하면 된다.

```markdown
# 네트워크 보안 테스트 Rules of Engagement(ROE)

## 1. 테스트 개요

- 목적:
  - 내부 랩 네트워크 방어 능력 점검
  - 스니핑·MITM·평문 통신 탐지/차단 검증
- 기간:
  - 2025-11-05 10:00 ~ 2025-11-07 18:00 (KST)
- 테스트 범위:
  - 네트워크: 10.10.0.0/24 (랩망)
  - 게이트웨이: 10.10.0.1
  - 웹서버: 10.10.0.10
  - 클라이언트: 10.10.0.20
- 제외:
  - 외부 인터넷, 회사/타인 자산, 무단 무선 AP
  - 생산(Production) VPC, 클라우드 계정

## 2. 허용/금지 행위

- 허용:
  - Nmap 스캔(T3 이하, 안전한 스크립트만)
  - ARP 관련 합성 트래픽 생성(격리망)
  - DNS 스푸핑은 테스트 존에 한정
  - 패킷 캡처(PCAP) – 테스트 기간 및 범위 내
- 금지:
  - 서비스 중단(Denial of Service) 유발 공격
  - 암호·쿠키 등 인증정보의 외부 반출
  - 민감 데이터(개인정보, 기밀 문서) 영구 저장
  - 기준 외 대상(다른 프로젝트의 VPC, 지사망 등) 테스트

## 3. 강도·속도 제한

- 스캔 레이트:
  - SYN: 200 pps 이하
  - UDP: 100 pps 이하
- ARP 관련 트래픽:
  - 단일 서브넷 내 10분 이내, 이후 복구 절차 실행
- HTTP 요청:
  - 초당 50 req/s 이하, 동시 연결 100 미만

## 4. 로그·데이터 처리

- 캡처 파일:
  - 로컬 암호화 저장(AES-256 등) 후, 7일 내 파기
- PII/민감정보:
  - 이메일/계정명/쿠키 등은 마스킹 또는 해시 처리
- 접근 통제:
  - 테스트 리더와 감사자 2인 승인 후 열람
- 보관:
  - 원본 PCAP: 7일
  - 익명화 Flow 로그: 90일

## 5. 의사소통·보고

- 온콜:
  - SecOps: 010-XXXX-YYYY
  - 랩 네트워크 소유자: 010-ZZZZ-WWWW
- 인시던트 정의:
  - 비의도 서비스 중단/성능 저하, 메모리/CPU/디스크 사용 폭증
- 보고 체계:
  - 인시던트 발생 시 테스트 중단 → 즉시 보고 → 영향 분석 후 재개 여부 결정

## 6. 종료·원복

- 테스트 종료 후:
  - ARP 테이블 정상화, 라우팅/방화벽/스위치 보안 기능 재적용 확인
  - 임시 계정/키/토큰 폐기
- 결과 보고서:
  - 48시간 내 제출(리스크/개선안/재현 절차 포함)
```

---

### 로그·데이터 처리 지침

#### 수집 최소화 원칙

- 패킷 캡처 시 **전체 페이로드가 정말 필요한지**를 항상 의심해야 한다.
  - 많은 경우, 5-tuple(소스/목적 IP·포트, 프로토콜), 바이트/패킷 수, TLS·DNS 메타 정보만으로도 충분하다.
- 원칙:
  - 기본은 **Flow 로그**(NetFlow, IPFIX, Zeek conn.log 등)
  - PCAP은 **필요 시, 짧은 시점, 제한된 인터페이스**만 캡처

#### 익명화·가명화

- IP 주소:
  - 내부에서는 토큰으로 치환(예: `10.10.0.10` → `HOST_A`),  
    외부 보고서에는 토큰만 사용하고 맵핑 테이블은 암호화 저장.
- 사용자 식별자·이메일·전화번호:
  - 일부 글자만 남기고 나머지는 `*` 처리(예: `alice@example.com` → `al***@example.com`)
- 쿠키/세션 토큰:
  - 원문을 남기지 않고, 조직 고정 salt를 섞은 해시로 변환.

#### 보관 주기·접근 통제

- 보관 주기는 **위험·규제·분석 요구** 사이의 타협 결과여야 한다.
  - 예시: 원본 PCAP 7일, 익명화 Flow 90일, 요약 통계 1년.
- 접근은 RBAC(Role-Based Access Control)으로 제한하고,  
  **접근 로그**를 남겨 나중에 누가 무엇을 봤는지 추적 가능해야 한다.

---

### PCAP에서 PII 마스킹 예제

#### HTTP 트래픽만 추출·간단한 헤더 마스킹

```bash
# 1) HTTP 트래픽만 분리 (테스트망에서만 사용)
tshark -r input.pcap -Y "http" -w http_only.pcap

# 2) 민감 헤더 제거(단순 예시 — 실제 운영은 전문 익명화 도구 권장)
#   여기서는 Authorization 헤더를 "REDACTED"로 교체
editcap --inject-secrets dyn,http,Authorization:REDACTED http_only.pcap http_sanitized.pcap

# 3) 공유를 위해 압축 + 암호화 (AES-256 기반 zip)
zip -P '강한_비밀번호' -e http_sanitized.zip http_sanitized.pcap
```

#### 이메일·쿠키 토큰 마스킹(Python 예제)

```python
import re
import hashlib
import sys
import pathlib

EMAIL_RE = re.compile(
    r'([A-Za-z0-9._%+-]+)@([A-Za-z0-9.-]+\.[A-Za-z]{2,})'
)

COOKIE_RE = re.compile(
    r'Cookie:\s*token=([A-Za-z0-9\-_\.]+)'
)

def mask_email(s: str) -> str:
    def repl(m):
        local = m.group(1)
        domain = m.group(2)
        masked_local = local[:2] + "***"
        return f"{masked_local}@{domain}"
    return EMAIL_RE.sub(repl, s)

def hash_cookie(s: str) -> str:
    def repl(m):
        raw = m.group(1).encode()
        h = hashlib.sha256(raw + b"fixed_org_salt").hexdigest()[:16]
        return f"Cookie: token={h}"
    return COOKIE_RE.sub(repl, s)

def main(path: str) -> None:
    text = pathlib.Path(path).read_text(
        encoding="utf-8",
        errors="ignore"
    )
    text = mask_email(text)
    text = hash_cookie(text)
    out = pathlib.Path("sanitized.txt")
    out.write_text(text, encoding="utf-8")
    print(f"sanitized -> {out}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python sanitize.py <input.txt>")
        sys.exit(1)
    main(sys.argv[1])
```

이 스크립트는 PCAP을 ASCII로 덤프한 파일이나, HTTP 로그 파일에 적용할 수 있다.  
실제 운영에서는 **정규식 기반 접근만으로는 부족**하므로, 전문 익명화 솔루션이나  
정교한 파서 기반 도구를 사용하는 것이 바람직하다.

---

## 랩 환경: 가상 스위치/브리지/NAT, 클라우드 격리 VPC, 샘플 PCAP·토폴로지

### 랩 설계 원칙

1. **완전 격리(Isolation)**
   - 외부 인터넷/사내망과 분리된 환경에서만 공격 실습을 수행한다.
   - 로컬 네트워크:
     - Host-only 네트워크, 리눅스 네임스페이스, 가상 브리지
   - 클라우드:
     - 인터넷 게이트웨이 없는 VPC, SSM(Session Manager)만 허용

2. **재현 가능(Repeatability)**
   - 스크립트/코드(IaC, Compose, Shell)로 언제든지 같은 환경을 다시 띄울 수 있어야 한다.
   - 수동 클릭 기반 설정은 최소화하고, 코드로 문서화한다.

3. **관찰성(Observability) 우선**
   - 어디를 미러링/캡처할지, 어떤 로그를 남길지 먼저 설계한다.
   - NDR/IDS, 패킷 캡처, Flow, 시스템 로그를 중앙으로 모을 수 있는 구조면 좋다.

---

### 리눅스 네임스페이스 기반 미니 랩

#### 토폴로지

```
[ns-attacker]---veth-a <-> (br0) <-> veth-c---[ns-client]
                         |
                         +--- veth-g---[ns-gw]  (게이트웨이: NAT 역할 가능)
```

- `ns-attacker`: 공격 도구, 정찰·스니핑·합성 트래픽 생성
- `ns-client`: 일반 클라이언트 역할
- `ns-gw`: 게이트웨이/라우터 역할, 필요하면 NAT 구성
- `br0`: 가상 브리지(스위치처럼 동작)

#### 구축 스크립트(예제, root 권한 필요)

```bash
# 0) 깨끗이 초기화
ip link del veth-a 2>/dev/null || true
ip link del veth-c 2>/dev/null || true
ip link del veth-g 2>/dev/null || true
ip link del br0 2>/dev/null || true
ip netns del ns-attacker 2>/dev/null || true
ip netns del ns-client 2>/dev/null || true
ip netns del ns-gw 2>/dev/null || true

# 1) 네임스페이스 생성
ip netns add ns-attacker
ip netns add ns-client
ip netns add ns-gw

# 2) 브리지 생성
ip link add br0 type bridge
ip link set br0 up

# 3) veth 페어 생성
ip link add veth-a type veth peer name veth-a-br
ip link add veth-c type veth peer name veth-c-br
ip link add veth-g type veth peer name veth-g-br

# 4) 브리지에 연결
ip link set veth-a-br master br0
ip link set veth-c-br master br0
ip link set veth-g-br master br0
ip link set veth-a-br up
ip link set veth-c-br up
ip link set veth-g-br up

# 5) 네임스페이스에 veth 할당
ip link set veth-a netns ns-attacker
ip link set veth-c netns ns-client
ip link set veth-g netns ns-gw
ip -n ns-attacker link set veth-a up
ip -n ns-client  link set veth-c up
ip -n ns-gw      link set veth-g up

# 6) IP 주소 부여
ip -n ns-attacker addr add 10.10.0.11/24 dev veth-a
ip -n ns-client  addr add 10.10.0.10/24 dev veth-c
ip -n ns-gw      addr add 10.10.0.1/24  dev veth-g

# 7) 기본 게이트웨이 설정
ip -n ns-attacker route add default via 10.10.0.1
ip -n ns-client  route add default via 10.10.0.1

# 8) NAT 필요 시 (호스트 인터페이스 명은 환경에 맞게 수정)
# ip netns exec ns-gw sysctl -w net.ipv4.ip_forward=1
# iptables -t nat -A POSTROUTING -s 10.10.0.0/24 -o eth0 -j MASQUERADE

echo "DONE. ns-attacker/ns-client/ns-gw up."
```

#### 기본 통신·캡처 예제

```bash
# ns-client에서 게이트웨이 핑
ip netns exec ns-client ping -c 2 10.10.0.1

# ns-attacker에서 클라이언트 핑
ip netns exec ns-attacker ping -c 2 10.10.0.10

# 호스트에서 브리지 트래픽 캡처(ARP/ICMP 위주 관찰)
tcpdump -i br0 -nn -e -v 'arp or icmp'

# ns-client 내부에서 PCAP 생성
ip netns exec ns-client tcpdump -i veth-c -w /tmp/client.pcap
```

이 토폴로지는 단일 호스트만 있으면 쉽게 구축할 수 있고,  
L2·L3 레벨의 공격/방어·탐지 실험을 안전하게 수행할 수 있다.

> 주의: ARP 스푸핑, MITM 등은 **항상 이와 같이 격리된 랩 환경에서만** 실행해야 한다.  
> 실제 운영망에서는 합성 이벤트, PCAP 재생, 시뮬레이션으로 대체하는 것이 바람직하다.

---

### Docker Compose 기반 랩

#### 구성 목표

- 웹 서버(Nginx) + DNS(dnsmasq) + 클라이언트(curl) + 공격자(도구용) + 미러(tcpdump)
- 단일 Docker 네트워크(`labnet`)에 붙여 L2/L3/L7 흐름 관찰

#### docker-compose.yml (학습용 샘플)

```yaml
version: "3.9"
services:
  web:
    image: nginx:alpine
    networks: [ labnet ]
    ports:
      - "8080:80"
    volumes:
      - ./webroot:/usr/share/nginx/html:ro

  dns:
    image: andyshinn/dnsmasq:2.78
    command:
      - "-k"
      - "--log-facility=-"
      - "--address=/test.local/10.10.10.10"
    networks: [ labnet ]

  client:
    image: curlimages/curl:8.10.1
    entrypoint: ["sleep", "infinity"]
    networks: [ labnet ]

  attacker:
    image: debian:stable-slim
    entrypoint: ["sleep", "infinity"]
    networks: [ labnet ]
    cap_add: ["NET_ADMIN","NET_RAW"]

  mirror:
    image: corfr/tcpdump
    command: ["-i", "any", "-w", "/pcap/lab.pcap"]
    networks: [ labnet ]
    volumes:
      - ./pcap:/pcap
    cap_add: ["NET_ADMIN","NET_RAW"]

networks:
  labnet:
    driver: bridge
```

#### 실습 명령·관찰 포인트

```bash
# 1) 랩 기동
docker compose up -d

# 2) client 컨테이너에서 웹 호출
docker compose exec client sh -c "curl -s http://web/ | head"

# 3) DNS 질의
docker compose exec client sh -c "nslookup test.local dns || true"

# 4) mirror가 저장한 PCAP 확인
ls -lh pcap/lab.pcap
```

추가로, `attacker` 컨테이너에 `nmap`, `scapy` 등을 설치해  
정찰 트래픽을 생성할 수 있으나, **항상 이 Compose 네트워크 내부에서만** 사용해야 한다.

---

### 클라우드 격리 VPC (Terraform 개념 예시)

클라우드 상에서도 네트워크 보안 실험을 할 수 있지만,  
비용·규제·공동 사용자를 고려하면 **완전 격리된 랩 VPC**를 만드는 것이 필수다.

#### 최소 VPC 예시 (AWS, Terraform)

```hcl
# main.tf — 개념용 축약본

provider "aws" {
  region = "eu-central-1"
}

resource "aws_vpc" "lab" {
  cidr_block           = "10.20.0.0/16"
  enable_dns_hostnames = true
  tags = {
    Name = "lab-vpc"
  }
}

resource "aws_subnet" "private_a" {
  vpc_id                  = aws_vpc.lab.id
  cidr_block              = "10.20.1.0/24"
  availability_zone       = "eu-central-1a"
  map_public_ip_on_launch = false
  tags = {
    Name = "lab-private-a"
  }
}

resource "aws_security_group" "lab_sg" {
  name        = "lab-sg"
  description = "Isolated lab security group"
  vpc_id      = aws_vpc.lab.id

  # 최소 Egress (필요 시 VPC 엔드포인트만 허용)
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# EC2 인스턴스는 Systems Manager Session Manager로만 접속
# 인터넷 게이트웨이/퍼블릭 서브넷은 생성하지 않는다.
```

- **핵심 포인트**
  - 퍼블릭 서브넷, 인터넷 게이트웨이를 만들지 않는다.
  - 관리·접속은 SSM Session Manager 같은 **관리 채널**만 사용한다.
  - 패킷 캡처·로그는 S3(서버측 암호화)로 모으고, 라이프사이클 정책으로 자동 삭제를 설정한다.

---

### 랩 유형 비교

| 유형                     | 장점                                             | 단점/주의사항                                     |
|--------------------------|--------------------------------------------------|--------------------------------------------------|
| 리눅스 네임스페이스 랩   | 가볍고 빠르며 완전 로컬, L2·L3 실습에 적합      | 초기 셋업이 다소 낯설 수 있음                   |
| Docker Compose 랩        | 서비스(L7)까지 포함한 시나리오 구성 용이        | Docker 네트워크의 특성을 이해해야 함            |
| 클라우드 VPC 랩         | 실제 운영에 가까운 구조, 클라우드 보안 테스트  | 비용·권한·규제 고려 필요, 엄격한 격리 설계 필수 |

---

### 샘플 트래픽·워크시트

#### 샘플 트래픽 시드 생성 (Docker 랩 기준)

```bash
# client 컨테이너에서 여러 번 요청하여 HTTP 트래픽 생성
docker compose exec client sh -c '
  for i in 1 2 3; do
    curl -s http://web/ >/dev/null
    sleep 1
  done
  wget -qO- http://web/ >/dev/null || true
  nslookup test.local dns || true
'
```

#### Wireshark 필터 예시

- TCP 3-way 핸드셰이크:  
  `tcp.flags.syn == 1 and tcp.flags.ack == 0`
- HTTP 요청:  
  `http.request`
- DNS 쿼리:  
  `dns.flags.response == 0`
- 특정 IP에서 오는 ARP Reply:  
  `arp.opcode == 2 and arp.src.proto_ipv4 == 10.10.0.1`

#### 분석 워크시트(예시 템플릿)

```markdown
# 네트워크 지연 분석 워크시트

## 시나리오
- client → web HTTP 요청 중 간헐적 지연 발생

## 관찰 항목
- [ ] SYN 재전송 횟수 / RTT (Wireshark "tcp.analysis.retransmission")
- [ ] 서버 측 RST/FIN 발생 시점
- [ ] DNS 질의/응답 시간
- [ ] 패킷 손실 추정 (Dup ACK, Fast Retransmit 등)

## 가설
- [ ] MTU/MSS 미스매치 → 프래그먼트/재전송?
- [ ] NAT 테이블 과포화?
- [ ] 응용 계층의 느린 응답(백엔드 DB 지연)?

## 실험
- [ ] tc netem으로 1% 패킷 손실 / 50ms 지연 주입 후 비교
- [ ] 서버/클라이언트 양쪽에서 캡처하여 RTT 비교

## 결론·개선
- [ ] 서버/클라이언트 MSS 정렬
- [ ] Keep-Alive/커넥션 풀 튜닝
- [ ] NAT/방화벽 리소스 모니터링 강화
```

---

## Red/Blue/Purple 공동 미션 예제

이제 위에서 정의한 역할과 랩 환경을 실제로 “운영 체인”과 연결하기 위한  
공동 미션 예제를 살펴본다.

### 미션 1 — L2 ARP 기반 공격의 “탐지·대응 체인” 검증

#### 목표

- L2 ARP 이상행위(게이트웨이 MAC 변경, ARP Reply 폭증)를  
  Suricata/Zeek/SIEM으로 **탐지**하고,  
  간단한 자동 대응(예: 알람·로그 강화·베이스라인 재설정)을 구현한다.

#### 제약

- 실제 ARP MITM 공격(클라이언트의 트래픽을 가로채는 행위)은  
  **운영망에서 수행하지 않는다.**
- 랩 환경에서조차, 테스트 임팩트를 제한하고, 이벤트 종료 후  
  ARP 테이블과 네트워크 상태를 정상화한다.

#### 합성 ARP “변동” 트래픽 생성 예시

아래 예시는 Python으로 **자기 자신의 IP/MAC에 대한 GARP(Gratuitous ARP)** 를  
여러 번 보내서, 탐지 체인에 “ARP 변동이 있었음”을 알려주는 식의 합성 트래픽을 만든다.  
실제 MITM을 수행하지 않고도, DAI/Zeek/Suricata 룰이 어떻게 반응하는지 테스트할 수 있다.

```python
# safe_arp_churn_generator.py
# 주의: 격리된 랩 환경에서만 사용할 것.
from scapy.all import ARP, Ether, sendp
import time

def generate_garp(iface: str, ip: str, mac: str, count: int = 10, interval: float = 1.0):
    for i in range(count):
        ether = Ether(dst="ff:ff:ff:ff:ff:ff", src=mac)
        arp = ARP(op=2, psrc=ip, pdst=ip, hwsrc=mac, hwdst="00:00:00:00:00:00")
        frame = ether / arp
        sendp(frame, iface=iface, verbose=False)
        print(f"[{i+1}/{count}] Sent GARP for {ip} as {mac}")
        time.sleep(interval)

if __name__ == "__main__":
    # 예: iface="veth-a", ip="10.10.0.11", mac="02:42:ac:11:00:02"
    import sys
    if len(sys.argv) != 4:
        print("Usage: python safe_arp_churn_generator.py <iface> <ip> <mac>")
        sys.exit(1)
    generate_garp(sys.argv[1], sys.argv[2], sys.argv[3])
```

- Red 관점: GARP를 통해 “ARP 관련 이상 이벤트”를 발생시킨다.
- Blue 관점: Suricata/Zeek 로그를 통해 **어떤 형태로 이벤트가 보이는지**를 확인한다.
- Purple 관점: 이벤트를 SIEM 룰로 연결하고, 알람·대응 절차를 검증한다.

#### Suricata 룰 예시

```conf
# ARP Reply 폭증 감지 (간단 예제)
alert ether any any -> any any (
  msg:"ARP storm likely";
  ether type 0x806;  # ARP
  detection_filter:track by_src, count 50, seconds 10;
  sid:4200001;
  rev:1;
)
```

#### Zeek 스크립트 예시 (게이트웨이 MAC 베이스라인 감시)

```zeek
# arp_gateway_watch.zeek
@load protocols/arp

const gateway_ip: addr = 10.10.0.1;
global gw_mac: string &persistent;

event arp_reply(c: connection, spa: addr, sha: string, tpa: addr, tha: string) {
  if ( spa == gateway_ip ) {
    if ( gw_mac == "" ) {
      gw_mac = sha;
      print fmt("[GW-ARP] baseline set %s -> %s", gateway_ip, gw_mac);
    } else if ( gw_mac != sha ) {
      print fmt("[ALERT] Gateway MAC changed! %s: %s -> %s", gateway_ip, gw_mac, sha);
      gw_mac = sha;
    }
  }
}
```

#### SIEM 규칙(개념, 의사코드)

```yaml
title: Gateway MAC Address Change
logsource: arp logs (Zeek / Suricata / Switch syslog)

detection:
  selection:
    event_type: ARP_REPLY
    dst_ip: 10.10.0.1
  condition: |
    track per 1h window by dst_ip
    and alert if src_mac changes from previously seen value

level: high
```

#### 성공 기준

- GARP 합성 스크립트를 실행하면 Zeek·Suricata·SIEM에서  
  **ARP 관련 경보**가 발생한다.
- 경보 내용에는 최소한 다음 정보가 포함된다.
  - 게이트웨이 IP, 이전 MAC, 새로운 MAC, 발생 시간
- 테스트 종료 후, ARP 테이블을 정상화하고, **오탐 여부**를 검토한다.

---

### 미션 2 — 평문 제거·TLS 전환 검증

#### 목표

- HTTP 평문 로그인·쿠키·세션이 노출될 수 있음을 랩에서 확인한 뒤,
- HTTPS/TLS와 HSTS, 쿠키 플래그(Secure/HttpOnly)를 적용해서  
  **네트워크 상 평문 자격증명이 더 이상 보이지 않는지**를 검증한다.

#### 시나리오

1. Docker 랩의 `web` 서비스에 간단한 로그인 폼을 배치한다.
2. `client`에서 HTTP로 로그인 요청을 보내고, `mirror`가 캡처한 PCAP에서  
   아이디·비밀번호가 평문으로 노출된다는 사실을 확인한다.
3. 이후 `web`에 TLS 설정을 적용하고, HTTP → HTTPS 리다이렉트, HSTS 헤더,  
   쿠키 플래그를 적용한다.
4. 다시 동일 시나리오를 수행하고, 이번에는 네트워크 상에서  
   **비밀번호·세션 토큰이 평문으로 보이지 않음**을 확인한다.

#### Nginx 기본 TLS 스니펫

```nginx
server {
  listen 443 ssl http2;
  server_name web.local;

  ssl_certificate     /etc/nginx/certs/fullchain.pem;
  ssl_certificate_key /etc/nginx/certs/privkey.pem;

  # 운영 환경에 맞는 강한 설정 필요
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_prefer_server_ciphers on;

  # HSTS: 첫 접속 이후 항상 HTTPS 사용
  add_header Strict-Transport-Security "max-age=31536000" always;

  # 쿠키·콘텐츠 보호를 위한 보안 헤더 예시
  add_header X-Content-Type-Options nosniff always;
  add_header X-Frame-Options DENY always;

  location / {
    root /usr/share/nginx/html;
    index index.html;
  }
}

server {
  listen 80;
  server_name web.local;
  return 301 https://$host$request_uri;
}
```

#### 쿠키 설정 예시(백엔드 애플리케이션 코드 관점, Python Flask)

```python
from flask import Flask, make_response

app = Flask(__name__)

@app.route("/login", methods=["POST"])
def login():
  # 인증 로직 생략(테스트용)
  resp = make_response("ok")
  resp.set_cookie(
      "sessionid",
      "dummy-session-token",
      secure=True,       # HTTPS에서만 전송
      httponly=True,     # JavaScript에서 접근 불가
      samesite="Lax"
  )
  return resp
```

#### Red/Blue/Purple 관점

- Red:
  - TLS 적용 전·후 캡처를 비교해 **자격증명 탈취 가능성 감소**를 명확히 보여준다.
- Blue:
  - SSL/TLS 설정, 인증서 관리, HSTS 정책을 운영 문서에 반영하고 모니터링한다.
- Purple:
  - “평문 로그인 → HTTPS/HSTS 전환” 시나리오를 회귀 테스트에 추가하고,  
    이후 설정 변경·인프라 마이그레이션 시에도 **평문이 다시 등장하지 않는지** 자동으로 검사한다.

---

### 미션 3 — DNS·TLS 메타 기반 의심 트래픽 탐지

#### 목표

- 암호화된 트래픽 비중이 높은 오늘날, **DNS와 TLS 메타데이터**를  
  활용해 의심스러운 도메인·클라이언트 패턴을 탐지하는 룰을 설계한다.

#### DNS 측면

- 의심 도메인 패턴:
  - 랜덤 문자열처럼 보이는 도메인(DGA 가능성)
  - 짧은 기간 내 다량의 NXDOMAIN 응답
  - 알려진 악성 도메인 목록과의 일치

#### 간단한 Zeek 예시 (NXDOMAIN 폭증 감지)

```zeek
@load protocols/dns

global nxdomain_counts: table[addr] of count &default=0;

event dns_message(c: connection, msg: dns_msg) {
  if ( msg?$qr && msg$qr == 1 && msg?$rcode && msg$rcode == DNS::NXDOMAIN ) {
    local client = c$id$orig_h;
    nxdomain_counts[client] += 1;
    if ( nxdomain_counts[client] > 50 ) {
      print fmt("[ALERT] High NXDOMAIN rate from %s: %d",
                client, nxdomain_counts[client]);
    }
  }
}
```

#### TLS 측면

- TLS 핸드셰이크의 ClientHello에서 추출 가능한 정보:
  - SNI(Server Name Indication)
  - JA3/JA4 지문
  - 사용 cipher suite, 프로토콜 버전
- ENISA·Verizon DBIR 등은 랜섬웨어·피싱 캠페인이  
  점점 더 **암호화된 채널과 정교한 피싱 도메인**을 사용한다고 분석한다.:contentReference[oaicite:6]{index=6}  

#### Suricata TLS 메타 기반 룰 개념

```conf
# 의심스러운 JA3 해시(예시 값) 탐지
alert tls any any -> any any (
  msg:"Suspicious JA3 fingerprint";
  tls.ja3_hash; content:"769f845b0a...";
  sid:4300001;
  rev:1;
)

# 내부 정책상 허용되지 않은 TLD(.xyz 등)에 대한 SNI 사용 감지
alert tls any any -> any any (
  msg:"Disallowed TLD in SNI";
  tls.sni; pcre:"/\.xyz$/";
  sid:4300002;
  rev:1;
)
```

#### Purple 루프

- Red: 특정 도메인·클라이언트 패턴을 사용하는 테스트 트래픽 생성.
- Blue: DNS/TLS 로그 대시보드에서 해당 패턴을 확인·튜닝.
- Purple: 룰이 일정 기준 이상 탐지하는지, 오탐은 없는지  
  **pcap·로그 재생 기반 회귀 테스트 스위트**에 추가.

---

## 체크리스트 요약

아래 체크리스트는 이 글에서 다룬 개념을 실제 프로젝트·조직에 도입할 때  
“빠뜨린 것이 없는지” 확인하는 용도로 사용할 수 있다.

- [ ] **ROE 문서화**
  - [ ] 테스트 목적·범위·기간·강도·도구 명시
  - [ ] 허용/금지 행위 구분
  - [ ] 데이터 처리·보관·폐기 기준 정의
- [ ] **격리 랩 준비**
  - [ ] 로컬 네임스페이스 랩 또는 Docker Compose 랩
  - [ ] 필요 시 클라우드 격리 VPC (퍼블릭 접근 없음)
  - [ ] 패킷 캡처·NDR/IDS·Flow 로그 수집 지점 설계
- [ ] **도구 셋**
  - [ ] tcpdump / Wireshark
  - [ ] Zeek / Suricata
  - [ ] 스캐너(Nmap 등) – 안전옵션 사용
  - [ ] pcap 재생·분석 스크립트(jq, tshark 등)
- [ ] **PII 보호**
  - [ ] 수집 최소화 정책 수립
  - [ ] 익명화/가명화 파이프라인 정의
  - [ ] 보관 주기·접근 통제·암호화 정책 적용
- [ ] **Red/Blue/Purple 역할 정립**
  - [ ] 각 역할의 DoD(완성 정의) 문서화
  - [ ] 공격 시나리오 ↔ 탐지 룰 ↔ 플레이북 간 추적성 확보
- [ ] **Purple 루프·회귀 테스트**
  - [ ] 주요 네트워크 공격 시나리오에 대한 테스트 케이스(pcaps, 합성 이벤트)
  - [ ] Suricata/Zeek/SIEM 룰이 기대대로 동작하는지 자동 채점 스크립트 작성
  - [ ] 룰·플레이북 변경 시 회귀 테스트 자동 실행

이 글은 **네트워크 보안 연재의 시작점**으로,  
이후 글에서는 구체적인 기술 요소(예: DAI/DHCP Snooping/Port Security, HTTPS/HSTS/mTLS,  
WIDS/WIPS, Suricata/Zeek 룰 설계 등)를  
이 시작 글에서 정의한 **윤리·랩 환경·역할 체계** 위에 하나씩 쌓아 올리는 방식으로 다룬다.