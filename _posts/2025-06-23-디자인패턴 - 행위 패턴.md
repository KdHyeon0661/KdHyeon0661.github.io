---
layout: post
title: 디자인패턴 - 행위 패턴
date: 2025-06-23 21:20:23 +0900
category: 디자인패턴
---
# 행위 패턴 (Behavioral Patterns)

## 개요

**행위 패턴(Behavioral Patterns)**은 **객체 간 상호작용(Interaction)**과 **책임 분산(Responsibility Delegation)**을 다룬다.  
즉, 어떤 객체가 **무엇을 알고**, **누가 무엇을 처리하고**, **어떻게 협력하는가**에 대한 **통신 규칙과 흐름 제어**를 정의한다.

> “객체들이 어떻게 협력하며, 어떻게 책임을 분산할지에 대한 규칙을 정의하는 패턴”

---

## 핵심 목표

- 객체들 사이의 **의사소통을 구조화**하고 일관성 있게 관리  
- **하나의 객체에 과도하게 집중된 책임을 분산**  
- 복잡한 제어 흐름을 **효율적으로 분리 및 관리**

---

## 주요 특징

- 객체 간 **결합도를 줄이고** 유연한 협력 가능  
- 시스템의 **행동(Behavior)**을 쉽게 확장/교체  
- **관찰, 명령, 전략, 상태 전이, 순회, 해석, 방문** 등 다양한 요구를 포괄

---

## 대표적인 행위 패턴 목록

| 패턴 | 설명 |
|------|------|
| **Chain of Responsibility** | 요청을 처리할 수 있는 객체가 체인을 따라 전달되며 책임을 위임 |
| **Command** | 요청을 객체로 캡슐화하여 실행/취소/큐잉 등의 작업을 지원 |
| **Interpreter** | 언어나 표현식을 해석할 수 있는 구조 제공 |
| **Iterator** | 컬렉션을 순회하는 표준화된 방법 제공 |
| **Mediator** | 객체 간 직접 통신을 제거하고 중재자에게 위임 |
| **Memento** | 객체의 상태를 저장하고 복원 가능 (Undo 기능) |
| **Observer** | 객체 상태 변화 시 등록된 모든 객체에게 자동 알림 |
| **State** | 객체의 내부 상태에 따라 행동을 변경 (상태 전이) |
| **Strategy** | 알고리즘을 객체로 캡슐화하고 실행 중 교체 가능 |
| **Template Method** | 알고리즘의 구조를 정의하고, 일부 단계를 서브클래스에 위임 |
| **Visitor** | 객체 구조는 변경하지 않고 연산을 추가 |

---

## 언제 사용해야 할까?

- 객체 사이의 **상호작용이 복잡**해지는 경우  
- 특정 행동/알고리즘을 **유연하게 교체/확장**하고 싶은 경우  
- **역할과 책임 분산**을 명확히 하고 싶은 경우  
- **이벤트 기반 시스템, UI, 상태 전이 모델** 구현 시

---

## 장점 / 단점

**장점**
- 객체 간 **결합도 감소**, **행동 확장성 증가(OCP)**  
- **유지보수성·테스트 용이성** 향상  
- 공통 인터페이스/구조로 **일관된 협력 방식** 구현

**단점**
- 과도한 적용 시 **복잡성 증가**  
- 책임 분산이 지나치면 **흐름 추적 어려움**  
- 일부 패턴은 **클래스 수 증가**(Command, Visitor)

---

## 관련 패턴 비교(보강)

| 패턴 | 목적 | 주요 포인트 | 유사/대조 |
|------|------|-------------|-----------|
| **Strategy** | 알고리즘 교체 | 런타임 전략 변경 | Template Method, State |
| **Observer** | 상태 변경 통보 | Subject–Observer | Mediator, Event Bus |
| **State** | 상태 기반 전이 | 상태가 행동을 결정 | Strategy |
| **Command** | 요청 캡슐화 | 실행/취소/큐잉/매크로 | Memento, Macro |
| **Mediator** | 중재자 | 직접 연결 제거→간접 통신 | Observer, Facade |
| **Template Method** | 뼈대 제공 | Hook/Step 오버라이드 | Strategy |
| **Visitor** | 연산 추가 | 구조 고정, 연산 가변 | Interpreter |

---

# 패턴별 심화

> 각 패턴은 **의도 → 구조(UML) → 구현 포인트 → 예제 코드 → 적용 시점·주의점 → 관련 패턴** 순서로 정리.

---

## Strategy — 알고리즘 교체·조합의 기본기

### 의도
알고리즘을 **객체로 캡슐화**하고, 실행 중에 **전략을 교체**할 수 있게 한다.

### 구조(UML)
```
      ┌──────────────┐
      │   Context    │
      └──────┬───────┘
             │ uses
      ┌──────▼───────┐
      │  Strategy    │ (interface)
      └───▲─────▲────┘
          │     │
   ┌──────┘     └──────┐
┌───────┐           ┌────────┐
│ StratA│           │ StratB │
└───────┘           └────────┘
```

### 구현 포인트
- 전략은 **순수 함수형**으로 만들면 테스트·교체가 쉽다.  
- Context는 **전략 인터페이스**만 의존.

### 예제(Python)

```python
from abc import ABC, abstractmethod

class PricingStrategy(ABC):
    @abstractmethod
    def price(self, amount: float) -> float: ...

class Normal(PricingStrategy):
    def price(self, amount: float) -> float: return amount

class Discount(PricingStrategy):
    def __init__(self, rate: float): self.rate = rate
    def price(self, amount: float) -> float: return amount * (1.0 - self.rate)

class Context:
    def __init__(self, strategy: PricingStrategy): self.strategy = strategy
    def checkout(self, amount: float) -> float: return self.strategy.price(amount)

ctx = Context(Discount(0.2))
print(ctx.checkout(100))  # 80.0
ctx.strategy = Normal()
print(ctx.checkout(100))  # 100.0
```

### 적용 시점/주의점
- **여러 알고리즘을 교체**해야 할 때.  
- 전략 수 증가→클래스 증가. 간단한 경우 함수 콜백으로 시작 후 필요 시 클래스로 승격.

### 관련 패턴
- **Template Method**(상속 기반 교체)와 대비. **State**는 “상태가 전략을 고른다.”

---

## Observer — 상태 변화의 방송(Notify)

### 의도
주체(Subject)의 상태가 바뀌면 **옵저버(Observer)**에게 자동으로 **알림**을 보낸다.

### 구조(UML)
```
Subject ── maintains ──> Observer*
   │ notify()
   └ state changes
```

### 구현 포인트
- **푸시**(새 값 전달) vs **풀**(옵저버가 조회) 선택.  
- **메모리 누수** 방지: 등록/해제, 약한 참조(weakref) 고려.

### 예제(Python)

```python
from typing import Callable, List

class Subject:
    def __init__(self): self._subs: List[Callable[[int], None]] = []
    def subscribe(self, fn: Callable[[int], None]): self._subs.append(fn)
    def unsubscribe(self, fn: Callable[[int], None]): self._subs.remove(fn)
    def set_value(self, v: int):
        self._v = v
        for fn in list(self._subs): fn(v)

s = Subject()
s.subscribe(lambda v: print("A got", v))
def B(v): print("B got", v)
s.subscribe(B)
s.set_value(10)
s.unsubscribe(B)
s.set_value(20)
```

### 적용 시점/주의점
- **이벤트/상태 변화** 전파.  
- 옵저버 폭증/순환 의존성 주의. **Event Bus/Mediator** 검토.

### 관련 패턴
- **Mediator**(중앙 중재)와 상보적.

---

## Command — 실행/취소/큐잉을 한 객체로

### 의도
요청을 **객체로 캡슐화**하여 **실행/취소/큐잉/로깅/매크로**를 지원.

### 구조(UML)
```
Invoker -> Command.execute()
            ▲
            │
        Receiver (실제 동작)
```

### 구현 포인트
- **undo()**를 지원하려면 **Memento**와 조합하거나 **반대 연산**을 저장.  
- 큐/스케줄러와 자연스럽게 결합.

### 예제(Python) — 간단 에디터 Undo

```python
from abc import ABC, abstractmethod

class Editor:
    def __init__(self): self.text = ""
    def insert(self, s): self.text += s
    def erase(self, n): self.text = self.text[:-n]

class Command(ABC):
    @abstractmethod def execute(self): ...
    @abstractmethod def undo(self): ...

class Insert(Command):
    def __init__(self, ed: Editor, s: str): self.ed, self.s = ed, s
    def execute(self): self.ed.insert(self.s)
    def undo(self): self.ed.erase(len(self.s))

class Invoker:
    def __init__(self): self.stack=[]
    def run(self, cmd: Command):
        cmd.execute(); self.stack.append(cmd)
    def undo(self):
        if self.stack: self.stack.pop().undo()

ed = Editor(); inv = Invoker()
inv.run(Insert(ed, "Hello"))
inv.run(Insert(ed, " World"))
print(ed.text)  # Hello World
inv.undo(); print(ed.text)  # Hello
```

### 적용 시점/주의점
- **Undo/Redo, 취소 가능한 작업, 큐잉/원격 실행**.  
- 명령 폭증 시 **팩토리/레지스트리**로 관리.

### 관련 패턴
- **Memento**(상태 스냅샷), **Macro Command**(복합 명령).

---

## State — 상태가 행동을 결정한다

### 의도
객체의 **내부 상태**에 따라 **행동이 변경**되도록, 상태를 객체로 분리.

### 구조(UML)
```
Context --has--> State (interface)
    │            ├─ ConcreteStateA
    └----------> └─ ConcreteStateB
```

### 구현 포인트
- 상태 전이는 **Context** 혹은 **State** 내부에서 결정.  
- 전이 표/그래프를 문서화하면 유지보수 수월.

### 예제(Python) — 간이 Turnstile

```python
from abc import ABC, abstractmethod

class State(ABC):
    @abstractmethod
    def coin(self, ctx): ...
    @abstractmethod
    def push(self, ctx): ...

class Locked(State):
    def coin(self, ctx):
        print("unlocked"); ctx.state = Unlocked()
    def push(self, ctx):
        print("locked. alarm!")

class Unlocked(State):
    def coin(self, ctx):
        print("already unlocked")
    def push(self, ctx):
        print("pass"); ctx.state = Locked()

class Turnstile:
    def __init__(self): self.state: State = Locked()
    def coin(self): self.state.coin(self)
    def push(self): self.state.push(self)

t = Turnstile()
t.push(); t.coin(); t.push()
```

### 적용 시점/주의점
- 상태 전이가 많고 **분기문이 난립**할 때.  
- 상태 수 폭증 시 **전이 표/데이터 주도** 구현 고려.

### 관련 패턴
- **Strategy**와 유사하나, **상태가 전이를 내재**.

---

## Template Method — 알고리즘 뼈대 + Hook

### 의도
알고리즘 **골격(템플릿)을 상위 클래스**에 정의하고, **세부 단계는 하위 클래스**에 위임.

### 구조(UML)
```
AbstractClass.template()
   ├─ step1() (fixed)
   ├─ step2() (override)
   └─ hook()  (optional)
```

### 구현 포인트
- 상속 기반이라 **런타임 교체는 어려움** → 필요 시 **Strategy**로 전환.

### 예제(Python)

```python
from abc import ABC, abstractmethod

class Pipeline(ABC):
    def run(self):
        data = self.load()
        data = self.transform(data)
        self.save(data)

    def load(self): return [1,2,3]  # 고정 단계(또는 override)
    @abstractmethod
    def transform(self, xs): ...
    def save(self, xs): print(xs)

class SquarePipeline(Pipeline):
    def transform(self, xs): return [x*x for x in xs]

SquarePipeline().run()  # [1,4,9]
```

### 적용 시점/주의점
- **공통 뼈대**는 같고 **일부 단계만 다를 때**.  
- 상속 트리가 깊어지면 **전략/조합**을 고려.

### 관련 패턴
- **Strategy**(합성 기반 대체), **Hook Method**.

---

## Iterator — 내부 구조를 숨기고 순회

### 의도
컬렉션의 **내부 표현을 노출하지 않고** 요소에 **순차 접근**.

### 구조(UML)
```
Iterable -> Iterator.next()/hasNext()
```

### 구현 포인트
- Python은 **이터레이터 프로토콜**(`__iter__`, `__next__`) 혹은 **제너레이터**를 활용.

### 예제(Python)

```python
class Range:
    def __init__(self, start, end, step=1): self.s, self.e, self.st = start, end, step
    def __iter__(self):
        x = self.s
        while x < self.e:
            yield x
            x += self.st

for x in Range(0, 5, 2):
    print(x)  # 0 2 4
```

### 적용 시점/주의점
- **다형적 순회**, **지연 평가**.  
- 동시 수정 시 **스냅샷/복사/락** 고려.

### 관련 패턴
- **Composite**와 함께 트리 순회.

---

## Chain of Responsibility — 책임의 연결고리

### 의도
요청을 **체인의 첫 처리자**에게 보내고, 처리 못하면 **다음 처리자**로 넘긴다.

### 구조(UML)
```
Handler -> handle(req) or forward to next
   ▲
   └─ ConcreteHandlerA/B/...
```

### 구현 포인트
- 체인 구성은 **런타임 조합**이 유연.  
- **중단 조건**과 **전파 규칙**을 명확히.

### 예제(Python)

```python
from abc import ABC, abstractmethod

class Handler(ABC):
    def __init__(self, nxt=None): self._next = nxt
    @abstractmethod
    def handle(self, req): ...
    def next(self, req):
        if self._next: return self._next.handle(req)

class Auth(Handler):
    def handle(self, req):
        if not req.get("user"): raise PermissionError("no user")
        return self.next(req)

class RateLimit(Handler):
    def handle(self, req):
        # 예시: 간단 패스
        return self.next(req)

class Biz(Handler):
    def handle(self, req):
        return f"ok:{req['action']}"

chain = Auth(RateLimit(Biz()))
print(chain.handle({"user":"kim","action":"read"}))
```

### 기대 비용(간단 수식)
요청이 \(k\)번째에서 처리될 확률을 \(p_k\), 각 처리 비용을 \(c_k\)라 할 때, 기대 비용:
$$
\mathbb{E}[C] = \sum_{k=1}^{n} p_k \cdot \Big(\sum_{i=1}^{k} c_i\Big)
$$
→ **앞단에서 처리될수록** 전체 비용이 작아진다.

### 적용 시점/주의점
- **미들웨어 파이프라인**, **이벤트 처리 체인**.  
- 과도한 체인 길이는 **지연 증가**. **분기/단축 평가** 도입.

### 관련 패턴
- **Decorator**(구조 유사하나, 기능 확장 목적), **Middleware**.

---

## Mediator — 대화의 중앙집중

### 의도
객체 간 **직접 통신을 제거**하고, **중재자**를 통해 상호작용을 관리.

### 구조(UML)
```
Mediator <-> Colleague A/B/C
```

### 구현 포인트
- **방향성/규칙**을 Mediator에 집중.  
- Mediator가 **비대**해지지 않게 모듈화.

### 예제(Python)

```python
class ChatRoom:
    def __init__(self): self.users={}
    def join(self, user):
        self.users[user.name]=user; user.room=self
    def send(self, frm, to, msg):
        if to in self.users: self.users[to].recv(frm, msg)

class User:
    def __init__(self, name): self.name=name; self.room=None
    def send(self, to, msg): self.room.send(self.name, to, msg)
    def recv(self, frm, msg): print(f"[{self.name}] {frm}: {msg}")

room = ChatRoom()
a,b=User("A"),User("B"); room.join(a); room.join(b)
a.send("B","hello")
```

### 적용 시점/주의점
- **N:N 통신 복잡성**을 중앙집중으로 축소.  
- Mediator가 과도해지면 **분리/계층화**.

### 관련 패턴
- **Observer**(방송형), **Facade**(서브시스템 단순화).

---

## Memento — 상태의 스냅샷

### 의도
객체의 **내부 상태를 캡슐화**하여 외부에 노출하지 않고 **저장/복원**.

### 구조(UML)
```
Originator <-> Memento (opaque to others)
Caretaker (보관)
```

### 구현 포인트
- 스냅샷 크기/빈도 관리(메모리).  
- 민감 정보는 **암호화/필터링**.

### 예제(Python)

```python
class Editor:
    def __init__(self): self.text=""
    def type(self, s): self.text+=s
    def save(self): return self.text[:]  # memento
    def restore(self, m): self.text=m

ed = Editor()
stack=[]
ed.type("Hi"); stack.append(ed.save())
ed.type(", all"); stack.append(ed.save())
ed.type("!!!")
ed.restore(stack.pop())
print(ed.text)  # Hi, all
```

### 적용 시점/주의점
- **Undo/Redo**, 세이브 포인트.  
- 큰 상태는 **차등 스냅샷**이나 **Command 기반 Undo** 검토.

### 관련 패턴
- **Command**(반대 연산), **Caretaker** 역할 분리.

---

## Visitor — 구조 고정, 연산 가변

### 의도
객체 구조를 변경하지 않고 **새 연산을 추가**.

### 구조(UML)
```
Element.accept(Visitor)
Visitor.visit(ElementX)
```

### 구현 포인트
- **이중 디스패치**(언어 지원이 없다면 수작업).  
- 요소 타입 변화가 잦다면 Visitor는 부적합.

### 예제(Python) — 간단 AST

```python
class Num: 
    def __init__(self, v): self.v=v
    def accept(self, v): return v.visit_num(self)

class Add:
    def __init__(self, l, r): self.l, self.r = l, r
    def accept(self, v): return v.visit_add(self)

class EvalVisitor:
    def visit_num(self, n): return n.v
    def visit_add(self, a): return a.l.accept(self)+a.r.accept(self)

expr = Add(Num(2), Add(Num(3), Num(4)))
print(EvalVisitor().__class__.__name__, "=", expr.accept(EvalVisitor()))  # 9
```

### 적용 시점/주의점
- **구조는 안정**, 연산 추가가 잦은 시스템(컴파일러/도메인 모델).  
- 요소 타입이 자주 바뀌면 유지보수 어려움.

### 관련 패턴
- **Interpreter**와 조합하여 AST 처리.

---

## Interpreter — 미니 언어 해석기

### 의도
간단한 언어/표현식을 **문법 구조로 표현**하고 **해석**.

### 구조(UML)
```
AbstractExpression.interpret(ctx)
 ├─ TerminalExpression
 └─ NonterminalExpression
```

### 구현 포인트
- 파서/토크나이저/AST 분리.  
- 언어가 커지면 **파서 생성기**나 일반 파싱 라이브러리 권장.

### 예제(Python) — 불리언 수식 (AND/OR/NOT, 단순 AST)

```python
class Context(dict): pass

class Expr: 
    def eval(self, ctx: Context) -> bool: ...

class Var(Expr):
    def __init__(self, name): self.name=name
    def eval(self, ctx): return bool(ctx[self.name])

class And(Expr):
    def __init__(self, l, r): self.l,self.r=l,r
    def eval(self, ctx): return self.l.eval(ctx) and self.r.eval(ctx)

class Or(Expr):
    def __init__(self, l, r): self.l,self.r=l,r
    def eval(self, ctx): return self.l.eval(ctx) or self.r.eval(ctx)

class Not(Expr):
    def __init__(self, x): self.x=x
    def eval(self, ctx): return not self.x.eval(ctx)

ctx = Context(A=True, B=False)
expr = And(Var("A"), Or(Var("B"), Not(Var("B"))))
print(expr.eval(ctx))  # True
```

### 적용 시점/주의점
- 규칙/조건이 **선언적**으로 늘어나는 도메인.  
- 복잡해지면 성능/가독성 문제 → **컴파일/캐시** 고려.

### 관련 패턴
- **Visitor**(해석 외 추가 연산), **Composite**(트리 구조).

---

## 실무 활용 예시(보강)

| 패턴 | 예시 |
|------|------|
| **Observer** | React/Vue 상태 변화→UI 업데이트, 이벤트 리스너 |
| **Strategy** | 결제 방식(카드/포인트)·정렬/압축 알고리즘 교체 |
| **Command** | GUI 버튼→작업·Undo, 작업 큐/스케줄러 |
| **State** | ATM/주문/세션 상태 머신 |
| **Mediator** | 채팅방/항공 관제/부품 간 간접 통신 |
| **Visitor** | 컴파일러 AST 패스(해석/최적화/코드 생성) |
| **Template Method** | 프레임워크 Hook 기반 파이프라인 |
| **Iterator** | 대용량 스트림/지연 평가 |
| **Memento** | 편집기 Undo/Redo |
| **Interpreter** | 규칙 엔진/필터 DSL |

---

## 테스트·검증 체크리스트

- **계약 테스트**: 인터페이스(전략/명령/상태/방문자)의 **일관성 확인**  
- **상호작용 테스트**: Observer/Mediator 이벤트 흐름, 등록/해제/순환 의존  
- **성능/지연**: Chain 길이/Command 큐/Interpreter 비용  
- **동시성**: Observer 알림 순서/한정자, State 전이의 원자성  
- **회귀 방지**: Template Hook/Step 변경 시 공통 시나리오

---

## 안티패턴·주의점

- **과도한 패턴화**: 단순한 문제에 복잡한 패턴을 들이대지 말 것  
- **흐름 추적 어려움**: Chain/Mediator/Observer를 섞으면 디버깅 난이도 상승 → **로그·트레이싱** 표준화  
- **클래스 폭발**: Command/Visitor는 **레지스트리/코드 생성/메타프로그래밍**으로 완화  
- **상태 누수**: Memento/Observer에서 자원 해제·구독 해제·민감 정보 관리

---

## 마무리

행위 패턴은 **알고리즘 자체**보다 **객체 간 협력·책임 배분**을 설계한다.  
적절히 선택·조합하면 **유연하고 테스트 가능한 흐름**을 얻을 수 있다.  
- **전략/상태/템플릿**: 알고리즘·행동의 변이 처리  
- **옵저버/중재자/체인**: 상호작용·흐름 제어  
- **명령/메멘토/방문자/해석기**: 실행/복원/연산 추가/규칙 해석

도입 전 **목표(교체/확장/테스트/성능)**를 명확히 하고, 도입 후 **관측(로그/트레이싱)·테스트**로 검증하라. 그러면 행위 패턴은 복잡한 프로그램의 흐름을 **유연하고 명확하게** 만들어 준다.