---
layout: post
title: 논리회로설계 - VHDL 언어 요약
date: 2025-09-13 20:25:23 +0900
category: 논리회로설계
---
# VHDL 언어 요약 (Synthesizable 중심 + Testbench까지, 예제 다수)

> 대상: 합성 가능한 RTL 중심으로 **언어 핵심**을 한 자리에서 정리.  
> 표준: `ieee.std_logic_1164`, `ieee.numeric_std`(권장), 필요 시 `ieee.fixed_pkg`, `ieee.float_pkg`.  
> 버전: VHDL-93/2002/2008을 기준으로 설명(2008 기능 표기).  
> 기호: `<=`(신호 할당), `:=`(변수/상수/제네릭 초기화), `--`(주석).

---

## 0) 기초 단위: **라이브러리/패키지/엔티티/아키텍처**

```vhdl
library ieee;                            -- 표준 라이브러리 참조
use ieee.std_logic_1164.all;             -- std_logic, rising_edge 등
use ieee.numeric_std.all;                -- signed/unsigned, 산술

entity my_block is                       -- 인터페이스(포트/제네릭)
  generic (N : positive := 8);           -- 파라미터(기본값 가능)
  port (
    clk, rst  : in  std_logic;
    a, b      : in  std_logic_vector(N-1 downto 0);
    y         : out std_logic_vector(N-1 downto 0)
  );
end;

architecture rtl of my_block is          -- 구현 본문
  signal r : unsigned(N-1 downto 0);     -- 내부 신호
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0');
      else             r <= unsigned(a) + unsigned(b); -- 산술은 numeric_std로!
      end if;
    end if;
  end process;
  y <= std_logic_vector(r);
end;
```

**핵심 요점**
- **entity**: I/O(포트)와 **generics(제네릭)** 선언.
- **architecture**: 내부 신호/동시문(concurrent)/프로세스 등 구현.
- `library/use`: 패키지 공개 심벌을 가져옴.  
- 합성 시 **직접 엔티티 인스턴스화** 권장(VHDL-93+): `u0: entity work.my_block(rtl) port map(...);`

---

## 1) **데이터 타입** — 강타입 언어(캐스팅 필수)

### 1.1 스칼라·열거
- `boolean` (`true|false`), `integer`(범위 가능), `natural`, `positive`, `real`(TB용), `time`(TB용)
- `std_logic`: 9상태(‘U,X,0,1,Z,W,L,H,-’) — **해결형(resolved)**

```vhdl
signal s : std_logic := '0';
signal i : integer range 0 to 255 := 0;
```

### 1.2 배열
- `std_logic_vector(M downto N)`, `unsigned/signed`(numeric_std)
- 문자열: `string(1 to 12) := "Hello VHDL!";`

```vhdl
signal v : std_logic_vector(7 downto 0);       -- 비트열
signal u : unsigned(15 downto 0);              -- 비부호 산술
signal s : signed(15 downto 0);                -- 부호 산술
v <= x"AB";  u <= to_unsigned(1234, u'length); s <= to_signed(-7, s'length);
```

### 1.3 레코드·열거 사용자 정의
```vhdl
type state_t is (IDLE, RUN, DONE);             -- 열거형
type axi_t is record                            -- 레코드(버스 묶음)
  valid : std_logic;
  ready : std_logic;
  data  : std_logic_vector(31 downto 0);
end record;
signal st : state_t := IDLE;
signal m  : axi_t;
```

### 1.4 물리 타입(시간)·파일/접근 타입
- TB에서 `time` 사용: `wait for 10 ns;`  
- 파일 I/O는 `textio`로(합성 불가).

### 1.5 리졸루션/멀티 드라이버
- `std_logic`은 **해결형**이므로 여러 드라이버를 **해상**(wired-OR 등)  
- 내부 tri-state는 FPGA 합성기에서 버퍼로 대체될 수 있음(외부 I/O에서만 실제 3-state).

---

## 2) **표현식과 연산자** — 오버로드 주의

- 논리: `and or nand nor xor xnor not`
- 산술: `+ - * / mod rem`(정수/unsigned/signed 지원)
- 시프트: `sll srl sla sra rol ror`
- 비교: `= /= < <= > >=`
- 연결: `&` (예: `'0' & v(7 downto 1)`)
- 집합/집계(aggregate): `(others=>'0')`, `("00" & a(5 downto 2))`

**강타입 주의**: `std_logic_vector`는 산술 불가 → **unsigned/signed로 변환** 후 연산.

---

## 3) **동시문**과 **프로세스** — 동시성 모델과 델타 사이클

### 3.1 동시 신호 할당
```vhdl
y <= (a and b) or (c and d);                 -- 언제나 유효(조합)
with sel select                               -- 선택문
  y <= d0 when "00",
       d1 when "01",
       d2 when "10",
       d3 when others;
```

### 3.2 프로세스 (조합/순차 패턴)
- **조합 프로세스**: `process(all)` + **기본값**으로 래치 방지(VHDL-2008)
- **순차(클럭) 프로세스**: `if rising_edge(clk)` 내부에서만 레지스터 업데이트

```vhdl
-- 조합 블록(래치 방지: 기본값 필수)
process(all) is
begin
  next_y <= (others=>'0');           -- 기본값
  if en='1' then
    if a>b then next_y <= a; else next_y <= b; end if;
  end if;
end process;

-- 순차(클럭) 블록
process(clk) is
begin
  if rising_edge(clk) then
    if rst='1' then y<= (others=>'0');
    else            y<= next_y;
    end if;
  end if;
end process;
```

### 3.3 델타 사이클 & 변수/신호
- **신호**: 다음 **델타**에 업데이트(스케줄링 있음)  
- **변수**: 프로세스 **즉시** 업데이트(동일 사이클 내 임시 계산에 유리)

```vhdl
process(all)
  variable t: unsigned(8 downto 0);
begin
  t := ('0' & unsigned(a)) + ('0' & unsigned(b));
  sum   <= std_logic_vector(t(7 downto 0));
  carry <= t(8);
end process;
```

---

## 4) **순차문**: if/case/loop/wait/return/null

```vhdl
if en='1' then
  y <= a; 
elsif sel="10" then
  y <= b;
else
  y <= (others=>'0');
end if;

case op is
  when "000" => y <= a+b;
  when "001" => y <= a-b;
  when others=> y <= (others=>'0');
end case;

for i in 0 to 7 loop             -- 정적 범위 → 합성 시 펼침
  arr(i) <= '0';
end loop;

-- TB에서만 권장
wait until rising_edge(clk);     -- 합성기 일부 지원하나 관용은 if rising_edge
wait for 10 ns;                  -- TB 전용
null;                            -- 아무 것도 안 함
```

---

## 5) **서브프로그램**: 함수/프로시저, 패키지화

### 5.1 함수 (조합 로직 캡슐화; 합성 가능)
```vhdl
package util_pkg is
  function popcount(v: std_logic_vector) return unsigned;
end;
package body util_pkg is
  function popcount(v: std_logic_vector) return unsigned is
    variable c: unsigned(15 downto 0) := (others=>'0');
  begin
    for i in v'range loop
      if v(i)='1' then c := c + 1; end if;
    end loop;
    return c;
  end;
end;
```

### 5.2 프로시저 (출력/부작용 다수)
```vhdl
procedure sat_add(a,b: in signed; limit: in signed; result: out signed) is
  variable t: signed(a'length downto 0);
begin
  t := resize(a, t'length) + resize(b, t'length);
  if t > resize(limit, t'length) then
    result := resize(limit, result'length);
  elsif t < -resize(limit, t'length) then
    result := -resize(limit, result'length);
  else
    result := resize(t, result'length);
  end if;
end;
```

**규칙**  
- 합성 시 **pure** 함수(상태 없음) 권장.  
- TB에서는 `impure`/파일 I/O 사용 가능.

---

## 6) **제네릭/포트 매핑**: 파라미터화/인스턴스화

```vhdl
u0: entity work.my_block(rtl)
  generic map (N => 16)                      -- 파라미터 지정
  port map (
    clk=>clk, rst=>rst,
    a  =>a16, b=>b16,
    y  =>y16
  );
```

- **명시적 이름 매핑** 권장(순서 오류 방지).  
- 포트에 연결하지 않을 때 `open` 사용(출력만 가능).

---

## 7) **FSM 템플릿**(2-프로세스/3-프로세스)

```vhdl
type S_t is (IDLE, LOAD, RUN, DONE);
signal s, ns : S_t := IDLE;
signal y_reg : std_logic := '0';

-- (1) 조합: ns / (Mealy 출력은 ns와 함께 계산)
process(all) begin
  ns    <= s;            -- 기본값
  y_reg <= '0';          -- Moore 출력은 별도 등록 권장
  case s is
    when IDLE => if start='1' then ns<=LOAD; end if;
    when LOAD => ns<=RUN;
    when RUN  => if done_i='1' then ns<=DONE; end if;
    when DONE => y_reg<='1'; ns<=IDLE;
  end case;
end process;

-- (2) 순차: 상태 레지스터
process(clk) begin
  if rising_edge(clk) then
    if rst='1' then s<=IDLE; else s<=ns; end if;
  end if;
end process;

y <= y_reg;                                -- 등록된 출력(글리치 방지)
```

---

## 8) **합성 가능/불가** 요약

**가능(일반)**  
- `if/case`, 정적 범위 `for` 루프(펼침), 함수/프로시저(합성 코드), 산술/비교/시프트  
- `generate`(for/if), `with-select/when-else`  

**주의/불가(합성)**  
- `wait for`, 파일 I/O, `textio` (TB 전용)  
- 비결정적/동적 크기 배열, 무한 루프, 액세스 타입(포인터)  
- `after` 지연(합성기 무시/에러)

---

## 9) **지연/전파 모델**(시뮬레이션 이해용)

- **관성 지연(inertial)** *(기본)*: 짧은 펄스 차단  
- **수송 지연(transport)**: 파형 그대로 전달

```vhdl
y <= a after 5 ns;                    -- inertial (기본)
y <= transport a after 5 ns;          -- transport
y <= reject 2 ns inertial a after 5 ns; -- 2ns 미만 펄스 거부
```

> 합성과 무관, TB/타이밍 모델링용.

---

## 10) **속성(Attributes)**

- 범위: `'left`, `'right`, `'high`, `'low`, `'range`, `'length`
- 신호: `'event`, `'last_event`, `'stable(T)`, `'quiet(T)`, `rising_edge(s)`/`falling_edge(s)`
- 이미지/문자열(2008): `'image` → TB 디버깅 편리

```vhdl
if rising_edge(clk) then
  if a'event and a='1' then ... end if;          -- (과거 스타일)
end if;

report integer'image(i) severity note;           -- "42"
```

---

## 11) **배열/슬라이스/집계 팁**

```vhdl
y <= a(7 downto 4) & b(3 downto 0);             -- 연결
z <= (others => '0');                            -- 집계
w <= (0 => '1', others=>'0');                    -- 비트 선택 초기화
for i in v'range loop ... end loop;              -- 범위 속성 활용
```

- **비트순서**: `downto` 권장(상위→하위).  
- `resize`/`to_unsigned`/`to_signed`로 폭 맞춤.

---

## 12) **generate** — 구조적 반복/조건 인스턴스

```vhdl
gen_reg: for i in 0 to N-1 generate
  ff: entity work.dff port map(clk=>clk, rst=>rst, d=>din(i), q=>q(i));
end generate;

gen_opt: if USE_PARITY generate
  -- 패리티 생성 로직
end generate;
```

---

## 13) **컴포넌트 vs 직접 인스턴스화**(권장: 직접)

```vhdl
-- 직접
u1: entity work.alu(rtl) port map(...);

-- 구형 스타일(컴포넌트 선언 후 인스턴스)
component alu is
  port (...);
end component;
u1: alu port map(...);
```

**Configuration**(바인딩/대체)도 가능하지만, 대부분의 RTL 플로우는 직접 바인딩 사용.

---

## 14) **표준 패키지** 정리

- `std_logic_1164`: `std_logic(_vector)`, `rising_edge`, 해상 테이블
- `numeric_std`: `unsigned/signed` 산술, `resize`, 캐스팅
- `std_logic_textio`/`textio`: TB 파일 I/O
- (2008) `fixed_pkg`(sfixed/ufixed), `float_pkg`(부동소수)

```vhdl
use ieee.fixed_pkg.all;
signal a_fx, b_fx, y_fx : sfixed(3 downto -12);
y_fx <= a_fx * b_fx;                          -- 고정소수 연산(합성 지원 도구 확인)
```

> **주의**: `std_logic_arith/unsigned`(비표준) 지양 → `numeric_std` 사용!

---

## 15) **해결형/버스/3상(Tristate)**

```vhdl
y <= (others=>'Z') when oe='0' else data;     -- 외부 I/O 버스
```

- 내부 3-state는 FPGA 합성에서 **MUX로 치환**됨.  
- 여러 드라이버가 같은 신호를 구동하면 **해결형 타입** 필수(`std_logic`).

---

## 16) **RAM/ROM 추론**(합성 팁)

```vhdl
type ram_t is array (0 to 255) of std_logic_vector(31 downto 0);
signal ram : ram_t;

-- 단일 포트 동기 RAM (합성기 패턴)
process(clk) begin
  if rising_edge(clk) then
    if we='1' then ram(to_integer(addr)) <= din; end if;
    dout <= ram(to_integer(addr));
  end if;
end process;
```

- 초기화는 `readmem` 유사 TB에서 파일 로드 or 초기 집계(도구별).  
- True dual-port/byte enable 패턴은 합성기 문서 참고.

---

## 17) **테스트벤치(TB)** 핵심: 클럭/리셋/자극/검증

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity tb is end;
architecture sim of tb is
  signal clk: std_logic:='0'; signal rst: std_logic:='1';
  -- DUT 포트 신호들...
begin
  clk <= not clk after 5 ns;                 -- 100 MHz
  process begin wait for 50 ns; rst<='0'; wait; end process;

  -- 인스턴스
  dut: entity work.my_block(rtl) port map(...);

  -- 간단 검증
  process
    variable ref: unsigned(7 downto 0);
  begin
    wait until rst='0';
    -- stimulus
    -- ...
    assert y = std_logic_vector(ref)
      report "Mismatch!" severity error;
    assert false report "SIM DONE" severity failure;
  end process;
end;
```

- **assert**: `note|warning|error|failure`  
- 커버리지/랜덤: OSVVM(패키지) 등 프레임워크 사용 가능(TB용).

---

## 18) **예제 모음** — 언어 기능을 망라한 작은 조각들

### 18.1 조합/동기 템플릿(래치 방지/CE 사용)
```vhdl
-- 조합: full coverage + 기본값
process(all) begin
  y_n <= y;                     -- 유지 기본값
  case sel is
    when "00" => y_n <= a;
    when "01" => y_n <= b;
    when "10" => y_n <= c;
    when others => null;        -- 유지
  end case;
end process;

-- 순차: CE, 동기 리셋
process(clk) begin
  if rising_edge(clk) then
    if rst='1' then y <= (others=>'0');
    elsif ce='1' then y <= y_n;
    end if;
  end if;
end process;
```

### 18.2 파라메트릭 MUX/디코더
```vhdl
entity muxN is
  generic (N: positive := 8);
  port (d: in  std_logic_vector(N-1 downto 0);
        s: in  integer range 0 to N-1;
        y: out std_logic);
end;
architecture rtl of muxN is begin
  y <= d(s);                                  -- 인덱스 접근(합성 가능: 정적 범위)
end;

entity dec3to8 is
  port (a: in std_logic_vector(2 downto 0);
        y: out std_logic_vector(7 downto 0));
end;
architecture rtl of dec3to8 is begin
  y <= (others=>'0');
  with a select
    y <= "00000001" when "000",
         "00000010" when "001",
         "00000100" when "010",
         "00001000" when "011",
         "00010000" when "100",
         "00100000" when "101",
         "01000000" when "110",
         "10000000" when others;
end;
```

### 18.3 레코드 포트·패키지(인터페이스 깨끗하게)
```vhdl
package bus_pkg is
  type axis_t is record
    valid, ready, last : std_logic;
    data               : std_logic_vector(31 downto 0);
  end record;
end package;

library ieee; use ieee.std_logic_1164.all; use work.bus_pkg.all;
entity pass is
  port (s: in axis_t; m: out axis_t);
end;
architecture rtl of pass is begin
  m <= s;                                      -- 레코드 통째 복사(합성 OK)
end;
```

### 18.4 고정소수점(2008) 예
```vhdl
library ieee; use ieee.fixed_pkg.all;

entity fir1 is
  generic (W: integer:=16; F: integer:=14);
  port(clk: in std_logic; rst: in std_logic;
       x: in  sfixed(W-1 downto -F);
       h: in  sfixed(W-1 downto -F);
       y: out sfixed(W-1 downto -F));
end;
architecture rtl of fir1 is
  signal acc: sfixed(W-1 downto -F);
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then acc <= (others=>'0');
      else            acc <= acc + (x*h);  -- 곱셈/덧셈(도구 지원 확인)
      end if;
    end if;
  end process;
  y <= acc;
end;
```

### 18.5 사용자 정의 **해결 함수**(개념)
```vhdl
function wired_or (drivers: std_logic_vector) return std_logic is
  variable r: std_logic := '0';
begin
  for i in drivers'range loop
    if drivers(i)='1' then r:='1'; exit; end if;
  end loop;
  return r;
end;

subtype wor_logic is wired_or std_logic;       -- 사용자 해결형 타입
signal bus: wor_logic;                          -- 여러 드라이버 OR 결합(모형)
```
> 실제 설계에선 `std_logic`로 충분. 사용자 해결형은 모델링/특수 버스에서만.

---

## 19) **디자인 룰 & 베스트 프랙티스**

1. **numeric_std**만으로 산술. (비표준 패키지 회피)  
2. 조합 프로세스는 **`process(all)` + 기본값**으로 래치 방지.  
3. 클럭은 **게이팅 금지**, CE 사용. 리셋은 **동기** 권장(해제 동기화).  
4. 멀티클럭/비동기 입력 → **2FF 동기화**/CDC 구조 채택.  
5. Mealy 출력은 **레지스터링**해 글리치 방지.  
6. `case`는 **완전 커버**(`when others`)로 최적화/안전성 확보.  
7. 제네릭으로 **폭/기능 파라미터화**, 재사용 극대화.  
8. RAM/ROM/乘除법 등은 **합성기 추론 패턴**에 맞춰 코딩.  
9. TB에서 **assert/report**로 자동 검증.  
10. 도구 경고(래치/게이티드 클럭/혼합 드라이버)는 **0건**을 목표.

---

## 20) **미니 프로젝트 예** — 파라메트릭 ALU (연산자/케이스/플래그)

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;

entity alu is
  generic (N: positive := 8);
  port (a,b : in  std_logic_vector(N-1 downto 0);
        op  : in  std_logic_vector(2 downto 0);  -- 000:add 001:sub 010:and 011:or 100:xor 101:sll1 110:srl1 111:cmp
        y   : out std_logic_vector(N-1 downto 0);
        zf, nf, cf, vf : out std_logic);
end;

architecture rtl of alu is
  signal au, bu, yu : unsigned(N-1 downto 0);
  signal tmp        : unsigned(N downto 0);
begin
  au <= unsigned(a); bu <= unsigned(b);

  process(all) begin
    yu <= (others=>'0'); cf<='0'; vf<='0'; -- 기본
    case op is
      when "000" => tmp <= ('0' & au) + ('0' & bu); yu <= tmp(N-1 downto 0); cf<=tmp(N);
      when "001" => tmp <= ('0' & au) - ('0' & bu); yu <= tmp(N-1 downto 0); cf<=tmp(N);
      when "010" => yu <= au and bu;
      when "011" => yu <= au or  bu;
      when "100" => yu <= au xor bu;
      when "101" => yu <= au sll 1; cf<=a(N-1);
      when "110" => yu <= au srl 1; cf<=a(0);
      when others=> -- compare: y=0, zf=1 if equal, nf=(a<b)
        yu <= (others=>'0');
        zf <= '1' when au=bu else '0';
        nf <= '1' when au<bu else '0';
    end case;
    y  <= std_logic_vector(yu);
    zf <= '1' when yu=(others=>'0') else '0';
    nf <= yu(N-1);
    -- vf(부호 오버플로우)는 signed로 별도 계산해도 됨
  end process;
end;
```

TB 스케치:
```vhdl
entity tb_alu is end;
architecture sim of tb_alu is
  constant N: integer := 8;
  signal a,b,y: std_logic_vector(N-1 downto 0);
  signal op: std_logic_vector(2 downto 0);
  signal zf,nf,cf,vf: std_logic;
begin
  dut: entity work.alu(rtl) generic map (N=>N) port map(a=>a,b=>b,op=>op,y=>y,zf=>zf,nf=>nf,cf=>cf,vf=>vf);
  process
    variable r: unsigned(N-1 downto 0);
  begin
    a<=x"0A"; b<=x"03"; op<="000"; wait for 1 ns; -- add
    r := unsigned(a)+unsigned(b);
    assert y=std_logic_vector(r) report "ADD mismatch" severity error;

    op<="001"; wait for 1 ns;                     -- sub
    r := unsigned(a)-unsigned(b);
    assert y=std_logic_vector(r) report "SUB mismatch" severity error;

    op<="100"; wait for 1 ns;                     -- xor
    assert y=(a xor b) report "XOR mismatch" severity error;

    assert false report "ALU OK" severity failure;
  end process;
end;
```

---

## 21) **VHDL-2008 하이라이트**

- `process(all)` 감도 자동  
- 통합 인스턴스화 구문 개선(기존 그대로 사용 가능)  
- `'image`(문자열 변환), `'to_string`류 유틸(도구 종속)  
- 패키지 **제네릭**(도구별 지원 차)  
- 보호 타입(protected type)으로 **공유변수 thread-safe** (TB/고급 모델용)

---

## 22) **디버깅/품질 체크리스트**

- [ ] 모든 조합 블록 **기본값**/완전 커버  
- [ ] 철저한 **캐스팅**(unsigned/signed)  
- [ ] **CE** 사용, **게이티드 클럭 금지**  
- [ ] 비동기 입력 **2FF 동기화**, 리셋 **해제 동기화**  
- [ ] `assert/report`로 경계값 검증  
- [ ] 합성 후 리포트: **래치 0건**, **멀티드라이버 0건**, **타이밍 여유** 확인

---

### 결론

VHDL은 **강타입/동시성** 언어로, **명확한 타입 변환**과 **패턴화된 코딩(조합/순차 분리, FSM 2·3-프로세스, CE, numeric_std)** 만 지키면 **가독성/합성성/이식성**이 뛰어난 RTL을 만들 수 있습니다.  
본 요약의 예제들(템플릿·패키지·TB)은 실제 프로젝트의 **스타터 킷**으로 바로 사용 가능하며, 필요에 따라 **제네릭/패키지화**로 확장하면 됩니다.
