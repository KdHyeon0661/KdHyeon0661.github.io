---
layout: post
title: DB 심화 - SQL 처리과정
date: 2025-10-28 16:25:23 +0900
category: DB 심화
---
# SQL 처리과정(Oracle 중심)

> 목표  
> - SQL이 DB로 들어와 **어떻게 파싱**되고, **어떻게 최적화**되며, **어떤 로우-소스 트리**로 실행되는지 **엔드투엔드**로 이해한다.  
> - 실습 스키마를 만들고, **파싱 비용/커서 재사용**/최적화 로그/XPLAN 라인 통계로 **변경 전후를 증명**한다.  
> - “**증상(느림)** → **원인(파싱/통계/플랜)** → **처방(바인드/통계/힌트/인덱스)**”의 **정석 루틴**을 손에 익힌다.

---

## 0) 준비: 실습 스키마 & 데이터

> 실습은 **바인드 사용**, **통계 수집**, **XPLAN(ALLSTATS LAST)** 를 기본으로 한다.

```sql
-- 0.1 스키마
CREATE TABLE customers (
  id           NUMBER PRIMARY KEY,
  name         VARCHAR2(100),
  segment      VARCHAR2(20),
  region       VARCHAR2(10)
);

CREATE TABLE orders (
  id           NUMBER PRIMARY KEY,
  customer_id  NUMBER REFERENCES customers(id),
  order_date   DATE,
  status       VARCHAR2(10),
  amount       NUMBER
);

CREATE INDEX ix_orders_cust_date ON orders(customer_id, order_date);
CREATE INDEX ix_customers_region  ON customers(region);

-- 0.2 샘플 데이터(의미 있는 스큐: APAC 비중 높게)
INSERT INTO customers
SELECT level, 'C'||level,
       CASE WHEN MOD(level,5)=0 THEN 'ENT' ELSE 'SMB' END,
       CASE WHEN MOD(level,3)=0 THEN 'APAC'
            WHEN MOD(level,3)=1 THEN 'EMEA'
            ELSE 'AMER' END
FROM dual CONNECT BY level <= 10000;

INSERT /*+ APPEND */ INTO orders
SELECT level,
       TRUNC(DBMS_RANDOM.VALUE(1,10000)),                        -- customer_id
       DATE '2025-09-01' + TRUNC(DBMS_RANDOM.VALUE(0,60)),       -- 9~10월
       CASE WHEN MOD(level,10)=0 THEN 'CANCEL' ELSE 'OK' END,
       ROUND(DBMS_RANDOM.VALUE(10,500),2)
FROM dual CONNECT BY level <= 500000;

COMMIT;

-- 0.3 통계 & 히스토그램 (스큐 컬럼에 SIZE 지정)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS',cascade=>TRUE,
    method_opt=>'FOR COLUMNS SIZE 75 region SIZE 75 segment');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE,
    method_opt=>'FOR COLUMNS SIZE 75 status SIZE 75 order_date');
END;
/
```

---

## 1) Phase 1 — **SQL 파싱(Parsing)**  
SQL 텍스트가 **공유 풀(Shared Pool)** 과 **라이브러리 캐시**에서 **커서(Cursor)** 로 변환되는 단계.

### 1.1 파싱의 세부 단계
1) **Lexical/Syntax 분석**: 토큰화·구문검사 → 오류면 즉시 반환.  
2) **Semantic 분석**: 객체 이름 해석(스키마/시노님/뷰 확장), **권한 검사**, 컬럼 존재/타입 검사.  
3) **의존 관계 & 파스락(Parse Lock)**: 참조 객체에 대한 **파스 락** 획득(DDL 동시성 보장).  
4) **플랜 후보 탐색 전 변환(Transform) 프롤로그**: View Merge, Predicate Pushdown 등 일부 전처리.  
5) **커서 탐색(소프트 파싱 경로)**: 같은 SQL 텍스트, 같은 환경(세션 파라미터·NLS·ROLE 등)과 **바인드 패턴**을 가진 **Child** 커서가 있으면 재사용.  
6) **커서 생성(하드 파싱)**: 없으면 최적화 단계로 진입하여 새 Child 생성.  
7) **커서 캐시 탑재**: 결과 커서를 라이브러리 캐시에 로드.

> 용어  
> - **하드 파싱**: 새로운 커서 생성(비용 큼, `parse time elapsed` 증가, `library cache latch/mutex` 경합 가능).  
> - **소프트 파싱**: 기존 커서 재사용(빠름).  
> - **세션 커서 캐시**: `SESSION_CACHED_CURSORS` 로 세션 단 재사용 개선.

### 1.2 파싱 관련 지표·뷰
- `V$SQL.PARSE_CALLS`(Child 기준 파스 횟수)  
- `V$SYSSTAT`의 `parse count (total)`, `parse count (hard)`, `parse time elapsed`  
- `V$SQL_SHARED_CURSOR`(Child 분기 이유: BIND_MISMATCH 등)  
- `V$SESSION`(현재 세션의 `sql_id`, `sql_child_number`)

```sql
-- 파싱 부담 지표(시스템 레벨)
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('parse count (total)','parse count (hard)','parse time elapsed');

-- 같은 SQL_ID가 Child를 많이 만드는 경우
SELECT sql_id, COUNT(*) children, SUM(parse_calls) parse_calls
FROM   v$sql
GROUP  BY sql_id
HAVING COUNT(*) > 5
ORDER  BY children DESC FETCH FIRST 20 ROWS ONLY;

-- Child 분기 이유
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_id = :sql_id
  AND  reason IS NOT NULL AND reason <> 'N';
```

### 1.3 하드 vs 소프트 파싱 실험(바인드 사용)
```sql
VAR r VARCHAR2(10); EXEC :r := 'APAC';

-- ① 바인드 사용(커서 재사용 잘 됨)
SELECT /* bind */ COUNT(*) FROM customers WHERE region=:r;

-- ② 리터럴 남발(Child 폭증 위험)
SELECT /* literal */ COUNT(*) FROM customers WHERE region='APAC';
SELECT /* literal */ COUNT(*) FROM customers WHERE region='EMEA';
SELECT /* literal */ COUNT(*) FROM customers WHERE region='AMER';

-- V$SQL 확인
SELECT sql_id, child_number, executions, parse_calls, is_bind_sensitive
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* bind */ COUNT(*) FROM customers%'
    OR sql_text LIKE 'SELECT /* literal */ COUNT(*) FROM customers%'
ORDER  BY sql_id, child_number;
```

**요점**  
- **리터럴**은 **Child 늘어남 → 하드파싱 증가**.  
- **바인드**는 **커서 재사용 → 소프트파싱**.  
- 바인드일 때 **바인드 피킹/ACS**가 개입(§2.4).

---

## 2) Phase 2 — **최적화(Optimization)**  
CBO(Cost-Based Optimizer)가 **카디널리티**와 **비용**을 추정하고 **플랜**을 고르는 단계.

### 2.1 최적화 파이프라인(고수준)
1) **Query Block 파싱**: 쿼리를 여러 블록으로 분해(`SELECT`, 인라인 뷰 등).  
2) **변환(Transformation)**: View Merge, Predicate Pushdown, Subquery Unnesting, OR Expansion, Group-By Placement, Join Predicate Pushdown, Join Factorization, Star Transformation 등.  
3) **카디널리티 추정**: 통계/히스토그램/동적 샘플링/Feedback/ColGroup으로 선택도 계산.  
4) **플랜 탐색 & 비용 계산**: 접근 경로(인덱스·풀스캔·프루닝), 조인 순서·방법(NL/Hash/SMJ), 정렬/집계 비용.  
5) **적응형 요소 반영**: Adaptive Plans, Adaptive Cursor Sharing(바인드 분포).  
6) **플랜 선택**: 최저 비용 플랜 채택. 필요 시 SPM(베이스라인)·프로파일·아웃라인 개입.

### 2.2 카디널리티(선택도) 기초 수학
- 단일등가 조건 \(A=v\) 의 선택도  
  $$ \mathrm{Sel}(A\!=\!v) \approx \frac{1}{\mathrm{NDV}(A)} $$
- 카디널리티  
  $$ \mathrm{Card} = \mathrm{Sel} \times \mathrm{RowCount} $$
- 독립성 가정(단순)  
  $$ \mathrm{Sel}(A\!\land\!B) \approx \mathrm{Sel}(A)\cdot\mathrm{Sel}(B) $$
- 등가 조인 추정  
  $$ \mathrm{Card}(A\bowtie B) \approx \frac{|A|\cdot|B|}{\max(\mathrm{NDV}(key_A),\mathrm{NDV}(key_B))} $$

> 실제로는 **히스토그램**, **컬럼 상관관계(ColGroup)**, **동적 샘플링**, **통계 피드백**으로 보정.

### 2.3 변환(Transformation) 예제 — **Subquery Unnesting**
```sql
-- 원본: 스칼라 서브쿼리
SELECT c.id,
       (SELECT SUM(o.amount)
        FROM   orders o
        WHERE  o.customer_id=c.id
           AND o.order_date BETWEEN :d1 AND :d2) sum_amt
FROM   customers c
WHERE  c.region=:r;

-- 변환 의도: 조인 + 선행 집계 (옵티마이저가 자동 적용하는 경우多)
SELECT c.id, SUM(o.amount) sum_amt
FROM   customers c
LEFT JOIN orders o
  ON o.customer_id = c.id
 AND o.order_date BETWEEN :d1 AND :d2
WHERE  c.region=:r
GROUP  BY c.id;
```

**변환 효과**  
- 조인 순서/방법 선택 폭 확대, 선행 필터 적용, 중복연산 감소.  
- XPLAN의 `NOTE` 및 라인 구조에서 확인.

### 2.4 바인드 피킹 & ACS(Adaptive Cursor Sharing)
- **첫 실행 바인드**로 선택도를 추정(**피킹**)하여 플랜이 고정될 수 있다.  
- 값 분포가 **스큐**이면 **다른 값**에서는 나쁜 플랜.  
- **ACS**는 바인드 값 범위를 구간화해 **Child**를 분기.  

```sql
-- 바인드 민감/어웨어 여부 점검
SELECT sql_id, child_number, is_bind_sensitive, is_bind_aware
FROM   v$sql
WHERE  sql_text LIKE 'SELECT c.id,%sum_amt%FROM   customers c%';
```

### 2.5 XPLAN으로 최적화 결과 읽기
```sql
-- 방금 실행한 커서의 실제 라인 통계
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  sql_id => NULL, child_number => NULL,
  format => 'ALLSTATS LAST +PEEKED_BINDS +PREDICATE +PROJECTION +OUTLINE +NOTE'));
```
- **E-Rows vs A-Rows** 괴리 → **카디널리티 오류** 의심.  
- **BUFFERS / TEMP SPC / TIME** 큰 라인 = 병목.  
- `+PEEKED_BINDS` 로 피킹된 바인드 값 확인.  
- `+OUTLINE` 로 계획을 강제했던 힌트(내부) 확인.  
- `NOTE` 에 **dynamic sampling / adaptive plan / statistics feedback** 힌트.

---

## 3) Phase 3 — **Row-Source Generation**  
선택된 실행계획을 **Iterator(오픈/페치/클로즈)** 가능한 **로우-소스 트리**로 생성하고 실행.

### 3.1 로우-소스(Iterator) 모델
- 각 노드(라인)는 **OPEN → GET-NEXT(=FETCH) → CLOSE** 인터페이스.  
- **자식 노드**에서 **한 행씩** 받아 상위 연산을 수행(파이프라인).  
- 주요 노드: `TABLE ACCESS [FULL/BY ROWID]`, `INDEX [RANGE/UNIQUE/FFS]`, `NESTED LOOPS`, `HASH JOIN`, `SORT ORDER BY`, `SORT GROUP BY`, `HASH GROUP BY`, `VIEW`, `FILTER`, `CONNECT BY`, `PARTITION RANGE`, `BITMAP CONVERSION`, `WINDOW (ANALYTIC)` 등.

### 3.2 블록 읽기 모드
- **Consistent Read (CR)**: **UNDO** 로 특정 시점의 읽기(SELECT).  
- **Current Mode**: DML/갱신 시 현행 블록(ITL/락 검사).  
- 각 노드의 Buffers는 **CR/Current** 혼재 가능(테이블 액세스 후 NL로 ROWID 갱신 등).

### 3.3 PGA Workarea & Temp
- `SORT`/`HASH` 노드는 PGA에 **워크에어리어**를 잡고 부족하면 **Temp** 로 스필 → 대기 `direct path read/write temp`.  
- XPLAN의 `TempSpc` 와 ASH의 Temp 이벤트로 식별.

---

## 4) 세 단계가 **어떻게 연결**되는지: 한 번에 따라하기

### 4.1 문제 쿼리(보고 지표)
```sql
VAR d1 DATE; VAR d2 DATE; VAR r VARCHAR2(10);
EXEC :d1 := DATE '2025-10-01'; EXEC :d2 := DATE '2025-11-01'; EXEC :r := 'APAC';

-- 월-단위 보고: 지역별 고객 매출 Top-N
WITH agg AS (
  SELECT o.customer_id, SUM(o.amount) sum_amt
  FROM   orders o
  WHERE  o.order_date BETWEEN :d1 AND :d2
  GROUP  BY o.customer_id
)
SELECT /* report */ c.region, a.customer_id, a.sum_amt
FROM   agg a JOIN customers c ON c.id=a.customer_id
WHERE  c.region=:r
ORDER  BY a.sum_amt DESC
FETCH FIRST 10 ROWS ONLY;
```

### 4.2 파싱 관찰
```sql
-- 해당 커서가 소프트 파싱 되는지(같은 SQL 재실행 후 parse_calls 증가 여부)
SELECT sql_id, child_number, executions, parse_calls, last_active_time
FROM   v$sql
WHERE  sql_text LIKE 'WITH agg AS (%'
ORDER  BY last_active_time DESC FETCH FIRST 1 ROW ONLY;
```
- 리터럴이 없고 바인드만 쓰면 **소프트 파싱**이 주로 일어남.

### 4.3 최적화 결과(XPLAN)
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  sql_id => NULL, child_number => NULL,
  format => 'ALLSTATS LAST +PREDICATE +PROJECTION +OUTLINE +NOTE'));
```
**읽는 법**
- `HASH GROUP BY` (agg 생성) → `NESTED LOOPS` 또는 `HASH JOIN` 으로 `customers` 매칭.  
- `ORDER BY ... FETCH FIRST 10` → `SORT ORDER BY STOPKEY` 가 이상적(Top-N Stopkey).  
- `A-Rows`(실측)와 `E-Rows`(예상) 비교, `BUFFERS`/`TempSpc` 집중 라인 파악.

### 4.4 라인 튜닝 예: **정렬 스필 제거**
- XPLAN에 `SORT ORDER BY` 의 `TempSpc`↑ → **인덱스로 정렬 회피** 가능성 점검.  
- 보고서가 **고객별 합계 내림차순 Top-N**이면, 사전 집계 MV나 **인덱스에 amount 포함**이 대안.  
- 간단 대안: **집계 후 상위 N 추출**을 **윈도우**로 바꾸고 조인 순서 조정.

```sql
-- 대안 쿼리(윈도우 + 선행 필터링으로 정렬량 축소)
WITH agg AS (
  SELECT o.customer_id, SUM(o.amount) sum_amt
  FROM   orders o
  WHERE  o.order_date BETWEEN :d1 AND :d2
  GROUP  BY o.customer_id
),
ranked AS (
  SELECT a.*, ROW_NUMBER() OVER (ORDER BY sum_amt DESC) rn
  FROM   agg a
)
SELECT c.region, r.customer_id, r.sum_amt
FROM   ranked r JOIN customers c ON c.id=r.customer_id
WHERE  c.region=:r AND r.rn <= 10;
```

재실행 후 XPLAN에서 `TempSpc`/`Time` 비교.

---

## 5) 파싱/최적화/로우-소스 별 **토픽 딥다이브**

### 5.1 파싱 딥다이브
- **오브젝트 네임 해석**: 스키마 접두어·시노님·뷰 확장(뷰는 일종의 매크로로 **텍스트 치환 + 변환** 대상).  
- **권한 검사**: 직접 권한/롤/권한 위임, 뷰 체인 전체 검사.  
- **의존성 & Invalidations**: 참조 오브젝트 DDL → 커서 **무효화**(Invalidation) → 재파싱 필요.  
- **파스락(Parse Lock)**: DDL과 DML의 안전한 공존을 위한 잠금.  
- **재귀 SQL**: 파싱 중 딕셔너리 조회/통계 조회가 재귀적으로 발생(과도하면 Shared Pool 압박).

**파싱 비용 줄이기**
- 바인드 변수 사용, `SESSION_CACHED_CURSORS` 적절히, 과도한 DDL 피하기, 커서 고정(PIN)은 신중히.

### 5.2 최적화 딥다이브
- **변환(Transformations)**  
  - *Predicate Pushdown*: 조인/뷰 아래로 필터를 밀어 넣기.  
  - *OR Expansion*: `OR` → `UNION ALL` 로 분해 후 각 분기로 인덱스 활용.  
  - *Subquery Unnesting*: IN/EXISTS/스칼라 서브쿼리를 조인화.  
  - *Group-By Placement*: 선행 집계로 조인량 축소.  
  - *Star Transformation*: 차원 필터를 팩트에 Bloom Filter로 전파.  
- **접근 경로**: 인덱스 스캔(UNIQUE/RANGE/FFS), TABLE FULL(멀티블록 I/O), 파티션 프루닝(단일/범위/리스트/해시·서브 파티션), 인메모리, 스토리지 오프로드.  
- **조인 전략**: NL(소량·랜덤 I/O), HASH(대량·병렬), SMJ(정렬 가능/특정 상황).  
- **정렬/집계 전략**: SORT vs HASH GROUP BY, Stopkey, `RESULT_CACHE`(신중히).  
- **적응형 기능**: Adaptive Plan(런-타임 경로 선택), Statistics Feedback(다음 실행 보정), Dynamic Sampling.

### 5.3 Row-Source 딥다이브
- **Iterator** 의 OPEN/FETCH/CLOSE:  
  - `NESTED LOOPS` 는 **드라이빙** 집합을 한 행씩 받아 **프루브(Probe)** 테이블/인덱스에 접근.  
  - `HASH JOIN` 은 Build 입력을 해시 테이블에 올리고, Probe 입력을 스캔하며 매칭.  
  - `SORT` 는 입력을 모아 정렬(메모리 부족 시 Temp 스필).  
- **CR vs Current**: SELECT는 **CR** 중심, DML은 **Current** 필요(ITL/락/체인지).  
- **버퍼 캐시 경합**: 핫 블록 접근 → `buffer busy waits`, `read by other session`.  
- **PGA Workarea**: `v$pgastat`, `v$sql_workarea`, `v$tempseg_usage` 로 추적.

```sql
-- Workarea 관찰(실행 직후)
SELECT sql_id, operation_type, policy, expected_size, actual_mem_used, tempseg_size
FROM   v$sql_workarea
WHERE  sql_id = :sql_id
ORDER  BY operation_id;

-- Temp 사용 상위
SELECT tablespace_name, SUM(blocks) blocks
FROM   v$sort_usage
GROUP  BY tablespace_name
ORDER  BY blocks DESC;
```

---

## 6) “같은 SQL, 다른 플랜” — 바인드 스큐/ACS 시나리오

### 6.1 재현
```sql
VAR r VARCHAR2(10);
EXEC :r := 'APAC';

SELECT /* skew */ c.region, SUM(o.amount) amt
FROM   customers c JOIN orders o ON o.customer_id=c.id
WHERE  c.region=:r
GROUP  BY c.region;
```

- `region='APAC'` 은 **고빈도**, `'EMEA'` 는 저빈도 → **같은 SQL**이어도 **최적 플랜이 다를** 수 있다.

### 6.2 관찰
```sql
-- Child 특징
SELECT sql_id, child_number, executions, is_bind_sensitive, is_bind_aware,
       plan_hash_value, last_active_time
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* skew */ c.region%'
ORDER  BY child_number;

-- XPLAN으로 각 Child 실제 라인 비교
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(:sql_id, :child,
 'ALLSTATS LAST +PEEKED_BINDS +NOTE'));
```

**요점**  
- ACS가 활성화되면 바인드 범위 구간별로 **Child 분기**(NL vs Hash 등).  
- 히스토그램이 있으면 초기 카디널리티가 **더 정확** → 불필요 분기 감소.

---

## 7) “정렬 스필” 제거 — Row-Source 레벨 최적화 예제

### 7.1 증상
- XPLAN: `SORT ORDER BY` 또는 `HASH GROUP BY` 라인 `TempSpc`↑  
- ASH: `direct path read temp` / `write temp` 상위

### 7.2 해법 패턴
1) **카디널리티 정정**(통계/히스토그램/표현식 제거)로 **입력량 축소**  
2) **정렬 회피 인덱스**(ORDER BY 컬럼 접두 인덱스)  
3) **선행 집계/물질화 뷰**  
4) **PGA/Workarea 정책** 점검

```sql
-- 정렬 회피: 그룹/정렬 컬럼 포함 커버링 인덱스
CREATE INDEX ix_orders_r_dt_amt ON orders(region, order_date, amount);

-- 보고서 특화 MV (빠른 조회)
CREATE MATERIALIZED VIEW mv_order_amt_daily
BUILD IMMEDIATE REFRESH FAST ON COMMIT AS
SELECT region, TRUNC(order_date) d, SUM(amount) amt
FROM   orders
GROUP  BY region, TRUNC(order_date);
```

재실행하여 `TempSpc`/`Time` 감소 확인.

---

## 8) 파싱/최적화/실행 관련 **점검 SQL 묶음**

```sql
-- (A) 최근 15분, 세션 상태(ASH)로 플랜 라인 집중
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '15' MINUTE; EXEC :t2 := SYSTIMESTAMP;

SELECT sql_id, sql_plan_line_id, event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY sql_id, sql_plan_line_id, event
ORDER  BY samples DESC FETCH FIRST 20 ROWS;

-- (B) 파싱 비용(시스템)
SELECT name, value FROM v$sysstat
WHERE  name LIKE 'parse count%' OR name='parse time elapsed';

-- (C) Child 폭증 SQL
SELECT sql_id, COUNT(*) children, SUM(parse_calls) parse_calls
FROM   v$sql GROUP BY sql_id
HAVING COUNT(*)>10
ORDER  BY children DESC;

-- (D) Workarea/Temp
SELECT sql_id, operation_type, expected_size, actual_mem_used, tempseg_size
FROM   v$sql_workarea
WHERE  sql_id IN (SELECT sql_id FROM v$sql ORDER BY last_active_time DESC FETCH FIRST 10 ROWS)
ORDER  BY 1;

-- (E) 해당 커서 XPLAN (실행 후 즉시)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
 'ALLSTATS LAST +PEEKED_BINDS +PREDICATE +PROJECTION +OUTLINE +NOTE'));
```

---

## 9) 성능/안정화를 위한 **베스트 프랙티스 체크리스트**

1) **바인드**를 사용해 **소프트 파싱** 비율을 높인다.  
2) **스큐 컬럼**에 **히스토그램**, **표현식 제거**로 통계를 살린다.  
3) **E-Rows vs A-Rows** 괴리가 크면 **카디널리티 오류**부터 해결.  
4) 접근 경로/조인 순서/정렬·해시 라인을 **XPLAN(ALLSTATS LAST)** 로 읽는다.  
5) Temp 스필은 **정렬 회피/선행 집계/PGA 정책**으로 줄인다.  
6) 바인드 스큐는 **ACS** 확인, 필요 시 **값대 분기** 또는 **플랜 베이스라인**.  
7) 좋은 플랜은 **SQL Plan Baseline** 으로 고정해 **변동성**을 낮춘다.  
8) **전/후 검증**: `V$SQL` 평균 단가, ASH 이벤트 샘플, AWR Diff, 서비스 p95.

---

## 10) 부록 — 수학/개념 간단 정리

- **응답시간 분해**  
  $$ T_{\text{elapsed}} = T_{\text{CPU}} + \sum_k T_{\text{wait},k} $$
- **평균 활성 세션(AAS)** (ASH 근사)  
  $$ \mathrm{AAS} \approx \frac{\#\mathrm{활성\ 샘플}}{\Delta t(\mathrm{sec})} $$
- **리틀의 법칙**  
  $$ L=\lambda W \Rightarrow \mathrm{AAS}\approx \mathrm{RPS}\times \mathrm{Mean\,RT} $$

---

## 11) 마무리

- **Parsing** 은 “**이 SQL을 어떻게 이해하고, 기존 것을 재사용할까?**”의 단계다.  
- **Optimization** 은 “**사실(통계)에 기반해, 가장 싼 길을 고르자**”는 의사결정이다.  
- **Row-Source Generation** 은 “**그 길(플랜)을 실제로 걷는 방법(Iterator 트리)**”이다.  

정석 루프는 항상 같다.  
1) **파싱 재사용(바인드/커서)** 을 확보하고,  
2) **카디널리티** 를 바로 세워 **올바른 플랜**을 만들며,  
3) **로우-소스 라인**을 읽어 **정렬/해시/조인/프루닝**의 병목을 제거한다.  
증거는 **XPLAN(ALLSTATS LAST)** 와 **ASH**가 말해준다.

> 한 줄 정리  
> **SQL 실행은 “해석(Parsing)→선택(Optimization)→실행(Row-Source)” 3막극**이다.  
> 바인드·통계·계획 읽기가 3막극을 **빠르고 안정적으로** 만든다.