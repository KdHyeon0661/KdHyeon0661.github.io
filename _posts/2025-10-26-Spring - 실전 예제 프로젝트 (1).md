---
layout: post
title: Spring - 실전 예제 프로젝트 (1)
date: 2025-10-26 14:25:23 +0900
category: Spring
---
# 28. 실전 예제 프로젝트(End-to-End) — “미니 쇼핑몰” 단일 레포: API/보안/결제/배치 + 관측/로그/대시보드 + 부하 결과/개선 로그

> 목표: **설계 → 코드 → 배치 → 보안 → 관측 → 배포 → 부하 → 개선**까지 한 번에 훑는 **엔드투엔드 샘플**.
> 스택: Spring Boot 3.3 / Java 21 / Gradle 8 / PostgreSQL / Redis / Kafka(옵션: In-Memory로 대체 가능) / Docker Compose(로컬) / K8s(운영) / Prometheus+Grafana+Tempo / Loki(로그).
> 인증: **JWT(헤더) + Refresh(httponly 쿠키)**. 결제: **Mock PG**(성공/실패/지연 시뮬레이션). 배치: **정산/슬러그 백필/정리 작업**.
> 운영: **MDC/JSON 로그**, **OpenTelemetry**, **Actuator**, **대시보드**. 부하: **k6** 스크립트 + **전/후 개선 로그**.

---

## A. 레포 구조(모듈러 모노리스)

```
mini-shop/
├─ apps/
│  └─ api/                         # Spring Boot (웹/API/시큐리티)
│     ├─ src/main/java/com/acme/shop/...
│     └─ src/main/resources/
├─ modules/
│  ├─ shop-domain/                 # 순수 도메인 (엔티티/VO/도메인서비스)
│  ├─ shop-application/            # 유스케이스(포트/서비스)
│  ├─ shop-adapter-jpa/            # JPA 구현체(리포지토리/매핑)
│  ├─ shop-adapter-web/            # REST 어댑터(DTO/컨트롤러)
│  ├─ shop-adapter-payment-mock/   # 결제 PG 모킹(외부 연동 시뮬)
│  ├─ common-core/                 # 에러코드/예외/유틸(Result/Money/Masking)
│  ├─ common-web/                  # ApiResponse/ExceptionHandler/MDCFilter
│  ├─ common-security/             # JWT/Refresh 쿠키/권한 유틸
│  ├─ common-jpa/                  # Auditing/BaseEntity/Outbox
│  └─ common-i18n/                 # MessageSource/LocaleResolver
├─ batch/
│  ├─ settlement-batch/            # 정산 배치(Spring Batch)
│  └─ maintenance-batch/           # 정리/보수(오래된 장바구니 삭제 등)
├─ deploy/
│  ├─ docker-compose/              # 로컬 관측/DB/PG 모킹
│  └─ k8s/                         # K8s 매니페스트(Helm 차트)
├─ scripts/                        # k6(부하), 데이터 씨드, 마이그 도구
└─ .github/workflows/              # CI(빌드/테스트/이미지)/CD(GitOps PR)
```

---

## B. 도메인 개요

### B-1. 핵심 개념
- **상품(Product)**: 아이디/이름/가격/재고.
- **장바구니(Cart)**: 사용자별 임시 담기(만료 전략).
- **주문(Order)**: Aggregate(루트: Order, 라인들 OrderLine). 상태: `PENDING → PAYING → PAID → FULFILLING → DONE` (실패: `FAILED/CANCELLED`).
- **결제(Payment)**: 외부 PG. 카드/가상계좌 등은 **모킹**.
- **정산(Settlement)**: 배치에서 기간 집계·수수료 차감.

### B-2. 값 객체 & 머니
```java
// modules/common-core
public record Money(@NonNull BigDecimal amount, @NonNull Currency currency) {
  public static Money KRW(long w) { return new Money(BigDecimal.valueOf(w), Currency.getInstance("KRW")); }
  public Money add(Money o){ require(o); return new Money(amount.add(o.amount), currency); }
  public Money multiply(int n){ return new Money(amount.multiply(BigDecimal.valueOf(n)), currency); }
  private void require(Money o){ if(!currency.equals(o.currency)) throw new IllegalArgumentException("currency mismatch"); }
}
```

### B-3. 주문 도메인(순수 자바)
```java
// modules/shop-domain
public final class Order {
  private final OrderId id;
  private final CustomerId customerId;
  private final List<OrderLine> lines = new ArrayList<>();
  private OrderState state = OrderState.PENDING;
  private Money total = Money.KRW(0);

  private Order(OrderId id, CustomerId customerId){ this.id = id; this.customerId = customerId; }

  public static Order create(OrderId id, CustomerId c){ return new Order(id, c); }
  public void add(ProductId pid, Money price, int qty){
    if (qty <= 0) throw new IllegalArgumentException("qty>0");
    lines.add(new OrderLine(pid, price, qty)); recompute();
  }
  public void startPay(){ ensureState(OrderState.PENDING); state = OrderState.PAYING; }
  public void paid(){ ensureState(OrderState.PAYING); state = OrderState.PAID; }
  public void cancel(){ if (state == OrderState.PAID) throw new IllegalStateException("already paid"); state = OrderState.CANCELLED; }

  private void ensureState(OrderState s){ if (state!=s) throw new IllegalStateException("state="+state+" expected="+s); }
  private void recompute(){ total = lines.stream().map(l->l.price().multiply(l.qty())).reduce(Money.KRW(0), Money::add); }

  // getters...
}
```

---

## C. API/웹 어댑터(주요 엔드포인트)

### C-1. DTO & 컨트롤러
```java
// modules/shop-adapter-web
public record CreateOrderReq(@NotNull String customerId, @Size(min=1) List<Line> lines) {
  public record Line(@NotNull String productId, @Positive int qty){}
}
public record OrderRes(String id, String state, long totalWon){}

@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
class OrderController {
  private final PlaceOrderUseCase place;  // :shop-application
  private final PayOrderUseCase pay;

  @PostMapping
  @PreAuthorize("isAuthenticated()")
  ApiResponse<OrderRes> create(@Valid @RequestBody CreateOrderReq req) {
    var id = place.place(req.customerId(), req.lines());
    var view = pay.view(id.value()); // or separate query usecase
    return ApiResponse.ok(new OrderRes(id.value(), view.state().name(), view.total().amount().longValue()));
  }

  @PostMapping("/{id}/pay")
  @PreAuthorize("isAuthenticated()")
  ApiResponse<Map<String,String>> pay(@PathVariable String id) {
    var txId = pay.requestPayment(new OrderId(id));
    return ApiResponse.ok(Map.of("transactionId", txId));
  }
}
```

### C-2. 애플리케이션(유스케이스)
```java
// modules/shop-application
public interface PlaceOrderUseCase { OrderId place(String customerId, List<CreateOrderReq.Line> lines); }
public interface PayOrderUseCase {
  String requestPayment(OrderId id);
  OrderView view(String id);
}

@Service
@RequiredArgsConstructor
class PlaceOrderService implements PlaceOrderUseCase {
  private final OrderRepository repo;  // outbound port
  private final InventoryGateway inventory; // 재고 확인용 포트
  @Transactional
  public OrderId place(String customerId, List<CreateOrderReq.Line> lines) {
    var o = Order.create(OrderId.newId(), new CustomerId(customerId));
    lines.forEach(l -> {
      var price = inventory.currentPrice(new ProductId(l.productId()));
      o.add(new ProductId(l.productId()), price, l.qty());
    });
    repo.save(o);
    return o.id();
  }
}

@Service
@RequiredArgsConstructor
class PayOrderService implements PayOrderUseCase {
  private final OrderRepository repo;
  private final PaymentGateway pg; // 외부 PG 포트
  private final OutboxPublisher outbox;

  @Transactional
  public String requestPayment(OrderId id) {
    var o = repo.get(id);
    o.startPay();
    var result = pg.authorize(id, o.total());
    if (result.approved()) { o.paid(); outbox.publish(new OrderPaidEvent(id)); }
    else { o.cancel(); }
    return result.transactionId();
  }
  @Transactional(readOnly = true)
  public OrderView view(String id){ return repo.view(new OrderId(id)); }
}
```

---

## D. JPA 어댑터 & 마이그레이션

### D-1. 엔티티 매핑(어댑터 내부)
```java
// modules/shop-adapter-jpa
@Entity(name="orders")
class OrderJpa {
  @Id String id;
  String customerId;
  @Enumerated(EnumType.STRING) OrderState state;
  Long totalWon;
  @OneToMany(mappedBy="order", cascade=ALL, orphanRemoval=true, fetch=FetchType.EAGER)
  List<OrderLineJpa> lines = new ArrayList<>();
  // mapper: toDomain()/fromDomain()
}
```

### D-2. Flyway SQL(발췌)
```sql
-- V1__init.sql
CREATE TABLE orders (id varchar(26) PRIMARY KEY, customer_id varchar(26) NOT NULL,
  state varchar(20) NOT NULL, total_won numeric(18,0) NOT NULL DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now(), updated_at timestamptz NOT NULL DEFAULT now());
CREATE TABLE order_lines (id bigserial PRIMARY KEY, order_id varchar(26) REFERENCES orders(id),
  product_id varchar(26) NOT NULL, price_won numeric(18,0) NOT NULL, qty int NOT NULL);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_created ON orders(created_at);
```

---

## E. 보안(인증/인가) — JWT + Refresh 쿠키

### E-1. 흐름
1) `/auth/login`에 ID/PW → 액세스 토큰(JWT, 15분) **본문/헤더 반환** + 리프레시 토큰(7~14일) **HttpOnly 쿠키**.
2) 요청 시 `Authorization: Bearer <access>`.
3) 만료 시 `/auth/refresh` → 새 액세스 토큰 발급(리프레시 회전/블랙리스트).

### E-2. 설정
```java
@Bean SecurityFilterChain chain(HttpSecurity http) throws Exception {
  http.csrf(AbstractHttpConfigurer::disable)
      .cors(Customizer.withDefaults())
      .sessionManagement(s -> s.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
      .authorizeHttpRequests(a -> a.requestMatchers("/auth/**","/actuator/**","/docs/**").permitAll().anyRequest().authenticated())
      .oauth2ResourceServer(o -> o.jwt(Customizer.withDefaults()));
  return http.build();
}
```

### E-3. 토큰 발급(요약)
```java
@PostMapping("/auth/login")
public ApiResponse<Map<String,Object>> login(@RequestBody LoginReq req, HttpServletResponse res) {
  var user = authService.verify(req.username(), req.password());
  var access = jwt.issueAccess(user);
  var refresh = jwt.issueRefresh(user);  // store jti in Redis for rotation
  res.addHeader(SET_COOKIE, cookie("REFRESH", refresh, true, "None", Duration.ofDays(14)));
  return ApiResponse.ok(Map.of("accessToken", access, "user", userView(user)));
}
```

---

## F. 결제 모킹(외부 PG 시뮬레이터)

### F-1. 모킹 컨트롤러
```java
// modules/shop-adapter-payment-mock
@RestController
@RequestMapping("/mockpg")
class MockPgController {
  @PostMapping("/authorize")
  public Map<String, Object> authorize(@RequestBody Map<String,Object> req) throws InterruptedException {
    var ms = Optional.ofNullable((Integer) req.getOrDefault("latencyMs", 0)).orElse(0);
    Thread.sleep(ms);
    var ok = !"FAIL".equals(req.get("card"));
    return Map.of("approved", ok, "transactionId", UUID.randomUUID().toString());
  }
}
```

### F-2. Resilience4j(타임아웃/리트라이/서킷/벌크헤드)
```yaml
resilience4j:
  circuitbreaker.instances.pg:
    sliding-window-size: 50
    failure-rate-threshold: 50
    wait-duration-in-open-state: 10s
  retry.instances.pg:
    max-attempts: 2
    wait-duration: 150ms
  timelimiter.instances.pg.timeout-duration: 2s
  bulkhead.instances.pg.max-concurrent-calls: 30
```

---

## G. 배치(정산/정리)

### G-1. 정산 배치(Spring Batch)
- **목표**: 하루 매출 집계, 수수료(예: 2.5%) 차감, `settlement` 테이블 기록.
```java
@Configuration
@EnableBatchProcessing
class SettlementJobConfig {
  @Bean Job settlement(JobRepository r, Step step){ return new JobBuilder("settlement", r).start(step).build(); }

  @Bean Step step(JobRepository r, PlatformTransactionManager tx,
                  ItemReader<OrderAgg> reader, ItemWriter<Settlement> writer){
    return new StepBuilder("settlementStep", r)
      .<OrderAgg, Settlement>chunk(1000, tx)
      .reader(reader).processor(this::toSettlement).writer(writer).build();
  }

  private Settlement toSettlement(OrderAgg a){
    var fee = a.totalWon().multiply(new BigDecimal("0.025")).longValue();
    return new Settlement(a.sellerId(), a.date(), a.totalWon().longValue(), fee, a.totalWon().longValue()-fee);
  }
}
```

### G-2. 유지보수 배치
- 만료 장바구니 삭제, 실패 Outbox 재전송, 오래된 로그 테이블 파티션 drop 등.

---

## H. 관측/로그/대시보드

### H-1. Actuator & Micrometer
```yaml
management:
  endpoints.web.exposure.include: health,info,metrics,prometheus,loggers,threaddump,heapdump
  metrics.tags.application: mini-shop
  otlp.metrics.export.enabled: true
  tracing.sampling.probability: 1.0
```

### H-2. OpenTelemetry(자동 계측)
```yaml
otel:
  exporter.otlp.endpoint: http://tempo:4317
  resource.attributes: service.name=mini-shop
```

### H-3. JSON 로그 + MDC
- `X-Trace-Id` 헤더/응답 반영, `tenantId`(없으면 `public`).
- **logback-spring.xml**에서 JSON 레이아웃 + 필드: timestamp, level, logger, msg, traceId, spanId, http.method/url/status, userId.

### H-4. Prometheus 대시(메트릭)
- **HTTP**: QPS, 2xx/4xx/5xx, p95/p99 지연.
- **DB/Hikari**: active/max, timeout count.
- **PG 모킹**: circuit state, timeout rate.
- **JVM**: heap/oldgen, GC pause.

**예: PromQL**
```promql
sum(rate(http_server_requests_seconds_count{uri!~".*actuator.*"}[5m]))
histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket[5m])) by (le,uri))
```

### H-5. Grafana 대시보드 JSON(발췌)
```json
{
  "title": "Mini Shop - API Overview",
  "panels": [
    { "type": "stat", "title": "RPS", "targets": [{ "expr": "sum(rate(http_server_requests_seconds_count[1m]))" }] },
    { "type": "timeseries", "title": "Latency p95", "targets": [{ "expr": "histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket[5m])) by (le))" }] },
    { "type": "gauge", "title": "Hikari Busy %", "targets": [{ "expr": "sum(hikaricp_connections_active)/sum(hikaricp_connections_max)" }] }
  ]
}
```

---

## I. 로컬 운영: docker-compose (관측/DB/PG모킹)

`deploy/docker-compose/docker-compose.yml`
```yaml
version: "3.9"
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: shop
      POSTGRES_PASSWORD: shop
      POSTGRES_DB: shop
    ports: [ "5432:5432" ]
  redis:
    image: redis:7
    ports: [ "6379:6379" ]
  prometheus:
    image: prom/prometheus
    volumes: [ "./prometheus.yml:/etc/prometheus/prometheus.yml" ]
    ports: [ "9090:9090" ]
  grafana:
    image: grafana/grafana
    ports: [ "3000:3000" ]
  tempo:
    image: grafana/tempo
    ports: [ "4317:4317" ]
  api:
    build: ../../
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://db:5432/shop
      SPRING_DATASOURCE_USERNAME: shop
      SPRING_DATASOURCE_PASSWORD: shop
    ports: [ "8080:8080" ]
    depends_on: [ db, prometheus, tempo, redis ]
```

---

## J. CI(빌드/테스트/스캔) & CD(이미지/서명/GitOps)

- **CI**: Gradle 빌드+테스트+JaCoCo(≥80%), Spotless/Checkstyle, SBOM(Syft), Trivy(FS).
- **이미지**: Buildx 멀티아키텍처, Trivy 이미지 스캔(High/Critical 차단), cosign 서명.
- **CD**: Helm values의 `image.tag=sha-xxxx` 자동 PR → Argo CD stage 자동 동기화 → prod 승격.

(상세 YAML은 21장에서 제공한 워크플로를 재사용)

---

## K. OpenAPI(요약)

`/v3/api-docs` 자동 노출 + Swagger UI.
핵심 스키마:
- `OrderRes`, `CreateOrderReq`, `ApiResponse<T>`, `ApiError`.

스니펫:
```yaml
paths:
  /api/orders:
    post:
      summary: Create order
      requestBody:
        content:
          application/json:
            schema: { $ref: '#/components/schemas/CreateOrderReq' }
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/ApiResponseOrderRes' }}}}
```

---

## L. 테스트 전략

- **유닛**: 도메인(엔티티/VO/서비스) 1ms 급.
- **애플리케이션**: 포트 더블로 유스케이스 테스트.
- **통합(JPA)**: `@DataJpaTest`로 매핑/쿼리.
- **웹 계층**: `@WebMvcTest` + 예외 표준 확인.
- **컨트랙트**: Spring Cloud Contract(옵션) or OpenAPI schema 검사.
- **성능 회귀**: k6 스크립트 스모크(1~2분)가 CI에 포함.

---

## M. 시드 데이터 & 시연 시나리오

### M-1. 데이터 시드
```sql
INSERT INTO products(id, name, price_won, stock) VALUES
('P1','Basic Tee', 12000, 500),
('P2','Hoodie', 49000, 200),
('P3','Sneakers', 89000, 100);
```

### M-2. 시연(해피패스)
1) 로그인 → 액세스 토큰 + REFRESH 쿠키.
2) `POST /api/orders` (P1 x2, P3 x1) → `200 OK`.
3) `POST /api/orders/{id}/pay` → 모킹 PG 승인 → `OrderPaid` Outbox → 이벤트 발행.
4) 정산 배치 실행 → `settlements` 적재.
5) Grafana에서 RPS/지연 확인, Tempo에서 트레이스 검색(TraceId는 응답 헤더).

---

## N. 부하 테스트(k6) 스크립트 & 결과

### N-1. k6 스크립트
`scripts/load/k6-orders.js`
```js
import http from 'k6/http';
import { sleep, check } from 'k6';

export const options = {
  scenarios: {
    ramp: {
      executor: 'ramping-vus',
      startVUs: 0,
      stages: [
        { duration: '2m', target: 100 },  // 웜업
        { duration: '5m', target: 300 },  // 유지
        { duration: '2m', target: 0 }     // 다운
      ],
      gracefulRampDown: '30s'
    }
  },
  thresholds: {
    http_req_failed: ['rate<0.01'],                 // 에러율 < 1%
    http_req_duration: ['p(95)<400'],               // p95 < 400ms
    'checks{kind:createOrder}': ['rate>0.99']
  }
};

const BASE = __ENV.API || 'http://localhost:8080';
const token = __ENV.TOKEN; // 미리 발급된 액세스 토큰

export default function () {
  const order = { customerId: 'U1', lines: [{productId:'P1', qty:1}] };
  const res = http.post(`${BASE}/api/orders`, JSON.stringify(order), {
    headers: { 'Authorization': `Bearer ${token}`, 'Content-Type':'application/json' }
  });
  check(res, { 'createOrder 200': (r)=> r.status===200 }, { kind: 'createOrder' });

  if (res.status===200) {
    const id = res.json().data.id;
    const pay = http.post(`${BASE}/api/orders/${id}/pay`, null, { headers: { 'Authorization': `Bearer ${token}` } });
    check(pay, { 'pay 200': (r)=> r.status===200 });
  }
  sleep(1);
}
```

### N-2. (가상) 1차 결과
- **부하**: 최대 300 VUs, 평균 RPS ≈ **820/s**
- **지연**: p50 95ms / p95 **520ms** / p99 1.2s
- **에러율**: 1.8% (주로 504/PG 타임아웃)
- **병목**:
  - PG 모킹 호출에서 타임아웃/서킷 미세 튜닝 미비
  - Hikari `maximumPoolSize=10`(기본치)로 풀 고갈 순간적 발생
  - 톰캣 `max-threads=200` vs DB 풀 불균형

### N-3. 개선(튜닝)
1) **Hikari**: max 40, min 8, connection-timeout 2s
2) **Resilience4j**(PG): 타임리미터 1.5s, 서킷 임계 하향(실패율 40%), 벌크헤드 50
3) **쿼리 최적화**: `orders` 조회 인덱스 추가(상태+created_at)
4) **캐시**: 제품 가격형 조회 Redis 캐시(HOT path)
5) **JVM**: `-XX:MaxRAMPercentage=70`, 문자열 dedup 유지
6) **톰캣**: `max-threads=180`, `min-spare=20`(풀과 균형)

### N-4. (가상) 2차 결과
- **RPS**: **1040/s** (+26.8%)
- **지연**: p50 70ms / **p95 310ms** / p99 680ms 개선
- **에러율**: **0.4%** (PG 타임아웃 감소, 리트라이 후 성공 비율↑)
- **자원**: CPU 65% / OldGen 68% 안정

---

## O. 장애 드릴 & 운영 런북(요약)

- **스레드풀 포화**: `tomcat_threads_busy/max` > 0.8 → 레이트 리밋 10% 하향 + HPA 30% 스케일아웃.
- **DB 대기**: `hikaricp_timeout_total` 상승 → 슬로우 쿼리 캡처 + 임시 쓰기 트래픽 컷(게이트웨이 503).
- **PG 장애**: `circuitbreaker.state{pg}=OPEN` → 기능 토글로 후불 결제 OFF, 캐시된 주문 응답 제공.
- **롤백**: Argo 롤백 or `kubectl rollout undo`.
- **포스트모템**: 48시간 내 작성(지표/타임라인/근본 원인/행동항목).

---

## P. K8s/Helm(핵심 스펙)

- **Deployment**: readiness/liveness/startup probe(`/actuator/health/*`), `maxSurge:1, maxUnavailable:0`
- **ConfigMap/Secret**: JWT 키/PG URL/Redis/토글
- **HPA**: CPU 60% 목표(3~30), 메모리 보조 지표
- **NetworkPolicy**: DB/Redis/Tempo/Prometheus만 허용
- **PodSecurity**: nonroot, readOnlyRootFilesystem

(자세한 매니페스트는 20장에서 제시한 예와 동일 패턴)

---

## Q. 체크리스트(실무 기준)

**보안**
- [ ] JWT 키 로테이션(JWKs) / Refresh 회전
- [ ] CORS 정확 지정, `SameSite=None; Secure` (프런트 서브도메인)
- [ ] 권한 검증(도메인 PermissionEvaluator)

**데이터**
- [ ] Flyway/Liquibase 마이그 → Expand/Migrate/Contract
- [ ] Outbox 이벤트/멱등키

**관측**
- [ ] 대시보드: API/DB/PG/JVM
- [ ] 알람: 에러율>1% 5m, p95>400ms 10m, Hikari busy>0.9 3m

**성능**
- [ ] k6 스모크(1~2m) + 야간 부하(30m) 자동
- [ ] 튜닝 결과/변경은 **개선 로그**로 남김

**배포**
- [ ] Stage canary → Prod canary 5%/15m → 전체
- [ ] 실패 시 롤백 ≤ 2분

---

## R. 개선 로그(예시)

| 날짜 | 변경 | 지표 전/후 |
|---|---|---|
| 2025-10-10 | PG 타임리미터 2s→1.5s, 벌크헤드 30→50 | p95 520ms→410ms, 에러율 1.8%→0.9% |
| 2025-10-12 | Hikari max 10→40, 인덱스 추가 | DB wait 14%→4%, p95 410ms→330ms |
| 2025-10-14 | 제품 가격 캐시 도입(300s) | RPS +18%, p50 95ms→70ms |
| 2025-10-16 | 톰캣 스레드 200→180 균형 | 타임아웃 504 0.6%→0.2% |
| 2025-10-20 | 주문 조회 Projection 최적화 | p95 330ms→310ms |

---

## S. 마무리(한 장 요약)

- **모듈러 모노리스**로 핵심 경계를 유지하며, **포트/어댑터**로 외부를 교체 가능하게 만들었다.
- **JWT + Refresh 쿠키**로 안전한 인증 흐름, **Resilience4j**로 외부 연동 회복탄력성 확보.
- **정산 배치**와 **Outbox 이벤트**로 동기/비동기 처리를 균형 있게 구성.
- **Prometheus/Grafana/Tempo/Loki**로 **관측**을 기본값으로, 대시보드/알람을 표준화.
- **k6 부하 결과**를 근거로 풀/타임아웃/인덱스/캐시를 개선해 **p95 520→310ms**, **에러율 1.8→0.4%**로 낮췄다.

> 바로 활용: 이 레포 뼈대를 포크해 **도메인/PG/배치/관측**을 자신들의 환경으로 맞추고, **부하 스크립트**로 성능을 수치화하자. 수치가 쌓이면 아키텍처 선택도, 최적화 우선순위도 “감”이 아니라 **데이터**가 결정한다.
