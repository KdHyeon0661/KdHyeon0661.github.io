---
layout: post
title: 시스템보안 - 루트킷·EPP/EDR 우회 개론
date: 2025-10-26 20:30:23 +0900
category: 시스템보안
---
# 루트킷·EPP/EDR 우회 개론 (블루팀 관점)

## 유저/커널 루트킷 개념, 훅킹/인라인 패치/SSDT

### 용어와 위협 모델

- **유저 모드 루트킷(User-mode Rootkit)**
  - 프로세스 내에서 **API 레벨**을 변조(예: `CreateFileW`, `NtQuerySystemInformation` 결과 필터링).
  - 기법: **IAT/EAT 훅**, **인라인 패치(프롤로그 JMP)**, **Proxy DLL/지연 로딩 오남용**.
  - **탐지 표면**: 모듈 무결성, API 바이트 프롤로그, `GetProcAddress` 재해석 불일치, ETW 소비 차단 시도.

- **커널 모드 루트킷(Kernel-mode Rootkit)**
  - 커널 드라이버로 **OS 내부 구조**를 변조.
  - 기법: **SSDT 후킹(과거)**, **IRP MajorFunction 가로채기**, **DKOM(Direct Kernel Object Manipulation)**.
  - 현대 Windows는 **PatchGuard/Driver Signature Enforcement**로 임의 패치·SSDT 후킹을 **강하게 차단**.

- **훅킹(Hooking)**
  - **간접/직접** 제어 흐름 변경으로 모니터링/변조.
  - 정상 보안 제품도 **후킹**을 사용하므로, **정상/악성 구분은 서명·무결성·행위 맥락**으로 한다.

- **인라인 패치(Inline Patch)**
  - 타깃 함수 시작부를 짧은 JMP로 덮어써 **별도 트램폴린**으로 점프시킴.
  - **무결성 검사**(서명·시그니처)와 **Code Integrity** 정책, **Control-flow Enforcement(예: CET)**가 방어에 중요.

- **SSDT(System Service Dispatch Table)**
  - 유저→커널 시스템콜 진입 인덱스 테이블. 과거 후킹의 주요 타깃이었으나, **현대 Windows**에서 **PatchGuard**가 보호.
  - 커널 후킹 탐지의 핵심은 **서명·로딩 경로·콜백 등록·객체 무결성**.

> **방어 핵심 메시지**
> 1) **서명된 코드만 커널에**(WDAC/고급 Device Guard), 유저 모드도 **서명 기준** 강화.
> 2) **무결성·행위 가시성**(ETW/Sysmon/AMSI)로 **은닉 시도**를 조기 탐지.
> 3) **코드 주입·API 후킹**은 악성만의 기술이 아니다 → **허용 리스트링 + 맥락 기반 룰**로 판별.

---

### 블루팀 “관찰 실습” — 후킹/변조 징후 스캔(읽기 전용)

> 목적: “후킹이 있을 수 있는 흔적”을 **변경 없이 관찰**하고, **허용/차단 기준**을 설계.

#### 프로세스 모듈 서명/경로 요약

```powershell
# 서명/경로 기반 거칠게 분류: 시스템 디렉터리 외 DLL 주입 의심 후보 시각화

Get-Process | ForEach-Object {
  $p = $_
  try {
    $mods = $p.Modules
    foreach($m in $mods){
      $signing = (Get-AuthenticodeSignature -FilePath $m.FileName -ErrorAction SilentlyContinue)
      [pscustomobject]@{
        PID = $p.Id
        Proc = $p.ProcessName
        Module = $m.ModuleName
        Path = $m.FileName
        InSystemDir = $m.FileName -like "$env:WINDIR\System32\*"
        Signed = $signing.Status
        Issuer = $signing.SignerCertificate.Issuer
      }
    }
  } catch {}
} | Where-Object { -not $_.InSystemDir -or $_.Signed -ne 'Valid' } |
    Sort-Object Proc, Module | Format-Table -Auto
```

#### 코드 무결성 및 AMSI/ETW 차단 시도 지표

```powershell
# 관련 로그 채널/정책 상태 점검 (읽기 전용)

wevtutil el | Select-String -Pattern "CodeIntegrity|AppLocker|Security-Mitigations"
Get-WinEvent -LogName "Microsoft-Windows-CodeIntegrity/Operational" -MaxEvents 20 |
  Select TimeCreated, Id, Message

# AMSI 공급자/레지스트리 존재 확인 (우회 시도 징후는 레지스트리/모듈 교란)

Get-ChildItem "HKLM:\SOFTWARE\Microsoft\AMSI\Providers" -ErrorAction SilentlyContinue |
  Select PSChildName
```

> **해석 가이드**
> - **시스템 디렉터리 외** 로드 모듈, **서명 무효/부재** 모듈은 **허용 목록**에 없으면 경보 후보.
> - 코드 무결성/AMSI 관련 **로그 거부/오류**는 **정책·충돌** 또는 **차단 시도** 신호.

---

### 커널 드라이버·콜백 관찰 (변경 금지, 서명/상태만 점검)

```powershell
# 드라이버 서명/경로 요약

Get-CimInstance Win32_SystemDriver | Select Name, State, PathName, StartMode | Sort Name

# PnP 서명 요약 (비서명/테스트 서명 주의)

Get-CimInstance Win32_PnPSignedDriver | Select DeviceName, DriverVersion, DriverProviderName, IsSigned |
  Sort-Object IsSigned, DriverProviderName
```

> **원칙**: **서명되지 않은 드라이버=거부**. 테스트 서명/셀프서명은 **랩에서만**.

---

## 안티-분석: Anti-VM / Anti-Debug / Timing trick (탐지·완화 관점)

### 개념 지도

- **Anti-VM**: 가상환경 아티팩트(디바이스/BIOS/레지스트리/툴 드라이버) 감지.
- **Anti-Debug**: `IsDebuggerPresent`, 예외 처리 꼬기, 스레드 히지/`NtSetInformationThread(ThreadHideFromDebugger)` 등.
- **Timing Trick**: `RDTSC`/`QueryPerformanceCounter` 측정으로 **분석 지연·후킹 오버헤드** 탐지.
- **Anti-ETW/AMSI**: ETW 세션/AMSI 인터페이스 **비활성/패치 시도**.

> **블루팀 전략**
> 1) **표준 샌드박스/EDR 에이전트 구성**을 **다양화**(단일 아티팩트 의존 X).
> 2) **안티-분석 함수 호출 패턴**(API Import/메모리 패치) 탐지 룰.
> 3) **타이밍 프로파일링**(성능 카운터/스케줄러 이벤트)을 통한 **이상 지연** 감시.
> 4) **ETW/AMSI** 비활성 시도 **즉시 알림**.

---

### “안전한 관찰 실습” — Anti-VM/Anti-Debug 시그널 헌팅

> 아래 스크립트는 **공격 코드가 아닌**, **분석 회피 흔적**을 **로그로 탐지**하기 위한 템플릿입니다.

#### 의심 API Import/메모리 보호 변경 패턴 나열

```powershell
# 단순 휴리스틱: 프로세스 모듈 Import 테이블에서 분석회피에 흔한 심볼을 찾음

$interesting = @("IsDebuggerPresent", "CheckRemoteDebuggerPresent", "NtSetInformationThread",
                 "QueryPerformanceCounter", "RtlAdjustPrivilege", "EtwEventWrite", "AmsiScanBuffer")
Get-Process | ForEach-Object {
  try {
    $p = $_
    $mods = $p.Modules | Where-Object { $_.ModuleName -match "kernel32|ntdll|advapi32|amsi|dbghelp" }
    foreach($m in $mods){
      # 실제 Import 파싱은 별도 도구/모듈이 필요. 여기선 "의심 모듈 로드"만 표시.
      [pscustomobject]@{ PID=$p.Id; Proc=$p.ProcessName; Module=$m.ModuleName; Path=$m.FileName }
    }
  } catch {}
} | Sort Proc, Module | Format-Table -Auto
# → 결과를 바탕으로 특정 업무 프로세스가 'amsi.dll'을 정당한 사유 없이 로드했는지 등의 룰 설계.

```

#### ETW/AMSI 무력화 시도 탐지(개념)

```kusto
// Microsoft Sentinel 예시(환경에 맞게 테이블 조정)
SecurityEvent
| where TimeGenerated > ago(1d)
| where EventID in (4688, 1)  // 프로세스 생성 (Sysmon 1 포함 시 조합)
| where CommandLine has_any ("wevtutil", "logman") or
       CommandLine has_all ("reg","AMSI","Disable") or
       CommandLine has_all ("reg","Etw","Start")
| project TimeGenerated, Account, Process, CommandLine, Computer
```

#### – ETW/AMSI 관련 레지스트리/모듈 조작 경고

```xml
<!-- Sysmon Config Snippet (개념) -->
<Sysmon schemaversion="4.50">
  <EventFiltering>
    <ProcessCreate onmatch="include">
      <CommandLine condition="contains">wevtutil</CommandLine>
      <CommandLine condition="contains">logman</CommandLine>
      <CommandLine condition="contains">reg add HKLM\SOFTWARE\Microsoft\AMSI</CommandLine>
    </ProcessCreate>
    <ImageLoad onmatch="include">
      <ImageLoaded condition="end with">amsi.dll</ImageLoaded>
      <ImageLoaded condition="end with">dbghelp.dll</ImageLoaded>
      <Signature condition="is">Unsigned</Signature>
    </ImageLoad>
    <RegistryEvent onmatch="include">
      <TargetObject condition="contains">\SOFTWARE\Microsoft\AMSI</TargetObject>
      <TargetObject condition="contains">\Control\Session Manager\Memory Management</TargetObject>
    </RegistryEvent>
  </EventFiltering>
</Sysmon>
```

> **운영 팁**: **허용 리스트**(EDR, 백업/보안툴 등 정상 주체)부터 작성 → 나머지 “과잉 탐욕” 프로세스를 경고.

---

### 타이밍 기반 탐지 — “분석 회피 지연”의 이상치

- **아이디어**: 일반 업무 앱의 **API 호출→응답 지연 분포**를 수집해, 특정 구간에서 **비정상적 스파이크**가 발생하면 경고.
- **실무 적용**: APM/ETW 성능 카운터, 스레드 스케줄링 지연, `Sleep` 호출 패턴(특히 변칙 분포)을 헌팅.

#### ETW 기반 간이 성능 샘플(개념)

```powershell
# Windows Performance Counters: CPU/Context Switch 비교로 비정상 지연 힌트

Get-Counter -Counter "\Thread(_Total)\Context Switches/sec","\Processor(_Total)\% Processor Time" -SampleInterval 1 -MaxSamples 10
# → 분석 장비/세션에서 특정 앱 실행 시 지연·스케줄 변동을 상대 비교

```

---

## EDR 탐지 표면: API 호출, 드라이버 통신, ETW/Sysmon 이벤트

### EDR/EPP의 일반적 가시성 레이어

1) **프로세스/스레드/모듈 이벤트**
   - 생성/종료, 명령줄, 서명, 모듈 로딩, 메모리 보호 전환.
2) **파일/레지스트리/네트워크**
   - 생성/삭제/권한 변경, 민감 키 변경, 외부 연결/바인딩.
3) **스크립트 엔진/AMSI/ETW**
   - 스크립트 콘텐츠(AMSI), 특정 ETW Provider(Win32k/Threat Intelligence 등).
4) **커널 드라이버·콜백**
   - 이미지 로드, 프로세스/스레드/레지스트리 콜백, Callout 등.
5) **행위 분석/ML**
   - 연쇄 패턴(드롭→주입→지속성→C2), 희귀도, 시간대 이상치.

> **루트킷/우회 모델**은 이 표면을 **축소·교란**하려는 시도입니다. **블루팀**은 반대로 **중복 가시성**(두세 레이어를 겹침)과 **정책 가드레일**을 적용합니다.

---

### ETW와 Sysmon — 실전 헌팅 쿼리/보고서

#### Sysmon 이벤트 빠른 요약

```powershell
# 최근 2시간 핵심 이벤트 요약

$since=(Get-Date).AddHours(-2)
$ids=1,3,7,8,10,12,13,14,22,23,24,25,26
Get-WinEvent -FilterHashtable @{LogName="Microsoft-Windows-Sysmon/Operational"; StartTime=$since} |
  Where-Object { $ids -contains $_.Id } |
  Group-Object Id | Select Name, Count
```

#### 의심 주입/메모리 보호 전환 패턴

```kusto
// Sysmon 10(ProcessAccess) + 7(ImageLoad) + 11(FileCreate) 조합 예시
Sysmon
| where TimeGenerated > ago(1d)
| where EventID in (7,10,11)
| summarize cnt=count() by bin(TimeGenerated, 15m), Computer
| join kind=inner (
    Sysmon
    | where EventID == 10 and CallTrace has_any ("WriteProcessMemory","VirtualAllocEx","CreateRemoteThread")
    | summarize inj_cnt=count() by bin(TimeGenerated, 15m), Computer
) on Computer, TimeGenerated
| where inj_cnt > 0
```

#### — ETW/AMSI 차단 흔적

```yaml
title: Possible ETW/AMSI Tamper
logsource:
  product: windows
  service: sysmon
detection:
  selection:
    EventID: 1
    CommandLine|contains:
      - "wevtutil"
      - "logman"
      - "reg add HKLM\\SOFTWARE\\Microsoft\\AMSI"
  condition: selection
level: high
```

---

### 하드닝: WDAC/ASR/LSA 보호/드라이버 정책

- **WDAC(Windows Defender Application Control)**
  - **서명/경로/정책 기반 화이트리스트**로 **로더 단계**부터 차단.
  - **드라이버 차단 리스트(호환성 주의)**: 알려진 취약/서명 악용 드라이버 거부.

- **ASR(Attack Surface Reduction) 규칙**
  - `Block process creations from PS exec`, `Block Office child process` 등 **행위 기반** 차단.
  - 스크립트/LOLBin 기반 우회를 **벽돌화**.

- **LSA 보호(PPL), Credential Guard**
  - 크리덴셜 접근·주입 경로 차단.
  - **EDR 우회**가 자격 탈취로 이어지지 않게 **2차 방어선**.

- **ETW/Sysmon 정책 보존**
  - 이벤트 크기·보존 정책, **로그 삭제/중지 시도**에 대한 **즉시 경보**.
  - 중앙집중 수집(WEF/에이전트)로 **현지 삭제 무의미화**.

#### WDAC/드라이버 차단 상태 샘플 확인(개념)

```powershell
# CodeIntegrity-Operational 로그에서 차단/오류만 조회

Get-WinEvent -LogName "Microsoft-Windows-CodeIntegrity/Operational" -MaxEvents 100 |
  Where-Object { $_.Message -match "Blocked|Code integrity" } |
  Select TimeCreated, Id, Message
```

---

### “안전 실패” 기반 랩 체크리스트

- [ ] Sysmon/ETW/AMSI **로그가 계속 쌓이는지**(중지/삭제 시 즉시 알림)
- [ ] **비서명 드라이버** 로드는 **완전 차단**되는지
- [ ] **비인가 모듈 로드/자체 인젝션**이 **ASR/WDAC**에서 막히는지
- [ ] **안티-분석 흔적**(wevtutil/logman/reg 편집) 커맨드가 **탐지되는지**
- [ ] **허용 리스트**가 최신 업무/보안 툴에 맞춰 **정기 갱신**되는지

---

## 10.x 부록 — 운영 예제 모음

### “로그 지우기/중지” 시도 탐지(헬스체크)

```kusto
// 이벤트 로그 삭제/클리어 흔적
SecurityEvent
| where EventID in (1102, 104)  // Audit log cleared / Security policy change
| project TimeGenerated, Computer, Account, EventID, Activity
```

### “의심 DLL 사이드로딩” 관찰(업무 앱 경로 외 DLL)

```kusto
Sysmon
| where EventID == 7
| where ImageLoaded notstartswith "C:\\Windows\\System32\\"
| where SignatureStatus != "Valid"
| summarize cnt=count() by ImageLoaded, Signing, Computer
| order by cnt desc
```

### “드라이버 로드” 스냅샷(비서명/새 공급자 강조)

```powershell
Get-CimInstance Win32_PnPSignedDriver |
  where { -not $_.IsSigned -or $_.DriverProviderName -notmatch "Microsoft|Intel|AMD|NVIDIA|VMware" } |
  Select DeviceName, DriverVersion, DriverProviderName, IsSigned |
  Sort-Object IsSigned, DriverProviderName
```

---

# 정리

- **루트킷/우회**의 본질은 **가시성 축소**와 **무결성 교란**입니다.
- 블루팀은 **다층 가시성(ETW+Sysmon+AMSI+서명 정책)**과 **강제 정책(WDAC/ASR/LSA PPL)**로 **중복 방어**를 구축해야 합니다.
- 본 문서의 **헌팅 쿼리/하드닝 점검/허용 리스트 전략**을 CI/MDM/SIEM에 결합하여,
  **“배포 전 차단 → 배포 후 탐지 → 로그 보전 → 예외 만료”**의 운영 루프를 완성하세요.
