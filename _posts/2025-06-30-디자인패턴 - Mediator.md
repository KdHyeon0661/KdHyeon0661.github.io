---
layout: post
title: 디자인패턴 - Mediator
date: 2025-06-30 21:20:23 +0900
category: 디자인패턴
---
# Mediator (중재자 패턴)

## ✅ 정의

**중재자 패턴(Mediator Pattern)**은 객체들이 서로 직접 통신하지 않고, **중재자(Mediator)**를 통해서만 상호작용하도록 만드는 **행위 패턴**입니다.  
객체 간의 **결합도를 낮추고**, 복잡한 의사소통 구조를 **중앙 집중식으로 관리**할 수 있게 해줍니다.

> “객체 간 복잡한 연결 관계를 중재자 하나로 단순화한다”

---

## 🎯 의도 (Intent)

- 객체 간 직접적인 의존을 제거하여, **느슨한 결합(loose coupling)** 구현
- 다수의 객체가 상호작용하는 복잡한 시스템에서 **통신 구조를 단순화**

---

## 📦 구조 (UML)

```
┌────────────┐
│  Mediator  │◄────────────┐
└────┬───────┘             │
     ▼                     │
┌────────────┐        ┌────────────┐
│ConcreteMedi│◄──────▶│  ColleagueA│
│  ator      │◄──────▶│  ColleagueB│
└────────────┘        └────────────┘
```

- **Mediator**: 동료(Colleague) 객체들 간의 소통을 중개하는 인터페이스
- **ConcreteMediator**: 실제 중재 역할 수행. 모든 상호작용을 여기에 집중
- **Colleague**: 중재자를 통해서만 다른 객체와 소통하는 객체들

---

## 🧑‍💻 구현 예시 (Python)

```python
from abc import ABC, abstractmethod

# 중재자 인터페이스
class ChatMediator(ABC):
    @abstractmethod
    def send(self, message, sender):
        pass

# Colleague (참여자)
class User:
    def __init__(self, name, mediator):
        self.name = name
        self.mediator = mediator

    def send(self, message):
        print(f"🗣️ {self.name} 보냄: {message}")
        self.mediator.send(message, self)

    def receive(self, message):
        print(f"📥 {self.name} 수신함: {message}")

# 중재자 구현
class ChatRoom(ChatMediator):
    def __init__(self):
        self.users = []

    def add_user(self, user):
        self.users.append(user)

    def send(self, message, sender):
        for user in self.users:
            if user != sender:
                user.receive(f"{sender.name}: {message}")

# 사용 예시
room = ChatRoom()
alice = User("Alice", room)
bob = User("Bob", room)
charlie = User("Charlie", room)

room.add_user(alice)
room.add_user(bob)
room.add_user(charlie)

alice.send("안녕하세요!")
bob.send("반가워요!")
```

**출력 예시:**
```
🗣️ Alice 보냄: 안녕하세요!
📥 Bob 수신함: Alice: 안녕하세요!
📥 Charlie 수신함: Alice: 안녕하세요!
🗣️ Bob 보냄: 반가워요!
📥 Alice 수신함: Bob: 반가워요!
📥 Charlie 수신함: Bob: 반가워요!
```

---

## ✅ 장점

- 객체 간의 **직접 참조 제거 → 결합도 감소**
- 객체 추가/제거가 쉬워짐 → **유지보수성 향상**
- **통신 흐름을 중앙에서 관리** → 구조적 이해 용이
- 복잡한 관계를 **하나의 중재자**로 단순화

---

## ⚠️ 단점

- 모든 통신이 중재자로 집중됨 → **중재자가 과도하게 비대해질 위험**
- 너무 많은 책임을 가지면 **SRP(단일 책임 원칙) 위반** 가능성

---

## 📌 사용 사례

| 분야 | 예시 |
|------|------|
| UI 구성요소 | 버튼, 텍스트박스 등 컴포넌트 간 상호작용 |
| 채팅 시스템 | 사용자 간 메시지 중개 |
| 항공 교통 통제 | 비행기(Colleague) → 관제탑(Mediator) |
| 이벤트 버스 | Observer들과 중재자 간 통신 |
| 게임 | 유닛 간 상호작용을 GameManager가 중재 |

---

## 🧠 Mediator vs Observer vs Facade

| 패턴 | 목적 | 유사점 | 차이점 |
|------|------|--------|--------|
| **Mediator** | 객체 간 통신 단순화 | 관계 구조 캡슐화 | 객체들이 중재자에 의존 |
| **Observer** | 이벤트 알림 | 다대다 구조 처리 | 느슨한 통보 구조 (중재자 없음) |
| **Facade** | 서브시스템 단순화 | 통합 인터페이스 제공 | 의사소통이 아닌 기능 제공 중심 |

---

## ✅ 실무 팁

- **이벤트 중심 아키텍처**에서 `EventBus`, `Dispatcher`는 Mediator 역할
- UI 컴포넌트 간 동기화나, **MVC/MVVM**에서 View-ViewModel 간 중재에도 유용
- 중재자가 복잡해진다면 `Chain of Responsibility`나 `Observer`와 혼합 고려

---

## 🧠 마무리

**Mediator 패턴은 객체 간 복잡한 관계를 정리하고**,  
**중재자 객체에 모든 상호작용을 위임함으로써 구조적인 안정성과 유지보수성을 제공합니다.**

GUI, 실시간 시스템, 이벤트 기반 구조 등에서 자주 사용되며,  
클래스 간 **결합도를 획기적으로 줄이는 데 강력한 패턴**입니다.
