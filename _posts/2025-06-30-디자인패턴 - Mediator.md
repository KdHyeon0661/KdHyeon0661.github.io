---
layout: post
title: 디자인패턴 - Mediator
date: 2025-06-30 21:20:23 +0900
category: 디자인패턴
---
# Mediator (중재자 패턴)

## 1. 정의와 동기

**중재자 패턴(Mediator)**은 객체들이 서로 **직접 통신하지 않고** 오직 **중재자(Mediator)**를 통해서만 상호작용하도록 강제하는 **행위 패턴**이다.
목표는 다음과 같다.

- **결합도 감소**: Colleague(참여자) 간 직접 참조 제거
- **소통 규칙 표준화**: 메시지 라우팅, 검증, 로깅, 트랜잭션 경계의 일원화
- **변경 용이성**: 참여자를 교체/추가해도 상호작용 규칙은 중재자에 머문다

중재자가 없는 경우, 참여자 수가 늘수록 **상호 참조가 기하급수적**으로 증가한다.

- 참여자가 \( n \)개일 때 완전 그래프의 엣지 수:
  $$
  E_{\text{full}}=\frac{n(n-1)}{2}
  $$
- Mediator를 두면 각 참여자는 **중재자 1곳**만 참조:
  $$
  E_{\text{mediated}}=n
  $$
즉, **\(O(n^2)\to O(n)\)** 로 상호작용 엣지 수가 줄어든다. 규모가 커질수록 유지보수 이득이 크다.

---

## 2. 언제 쓰나 (코드 스멜)

- 구성요소들이 **서로를 직접 호출**하며 이벤트/상태 동기화 지옥
- 작은 변경이 **폭포수처럼 전파**(Ripple Effect)
- UI 폼/위젯 간 **상호 의존**이 얽힘(입력 → 검증 → 버튼 활성화 → 경고 표시)
- 도메인 객체 사이의 **업무 규칙**이 여기저기 흩어짐(중복/상충)
- 비동기 이벤트 흐름이 **로깅·트레이싱 불가**하고 디버깅 난해

---

## 3. 구조 (UML/ASCII)

```
┌────────────────────────┐
│        Mediator        │  ← 인터페이스: 라우팅 규약
└───────────┬────────────┘
            │
     ┌──────▼──────────────────┐
     │    ConcreteMediator     │  ← 상호작용 규칙의 집중화
     └───┬───────────┬─────────┘
         │           │
┌────────▼───┐ ┌─────▼────────┐
│ ColleagueA │ │  ColleagueB  │  ← 참여자: Mediator에만 말한다
└────────────┘ └──────────────┘
```

변형
- **Event-Driven Mediator**: 이벤트 토픽/타입 기반 라우팅
- **Command/Query Mediator**: 요청-응답(CQRS 스타일)
- **Async Mediator**: 큐/채널/코루틴으로 비동기 파이프

---

## 4. 최소/표준 인터페이스

```text
interface Mediator {
  notify(sender, eventOrMessage)
}

abstract class Colleague {
  constructor(mediator)
  protected notify(eventOrMessage) -> mediator.notify(this, eventOrMessage)
}
```

이 규약을 바탕으로, 비즈니스 규칙은 **ConcreteMediator** 내부에만 존재한다.

---

## 5. Python — 동기형 기본 구현

### 5.1 채팅방(브로드캐스트) 예제

```python
from abc import ABC, abstractmethod
from typing import List

class Mediator(ABC):
    @abstractmethod
    def send(self, message: str, sender: "User") -> None: ...

class User:
    def __init__(self, name: str, mediator: Mediator) -> None:
        self.name = name
        self.mediator = mediator

    def send(self, message: str) -> None:
        self.mediator.send(message, self)

    def receive(self, message: str) -> None:
        print(f"{self.name} 수신: {message}")

class ChatRoom(Mediator):
    def __init__(self) -> None:
        self._users: List[User] = []

    def add(self, user: User) -> None:
        self._users.append(user)

    def send(self, message: str, sender: User) -> None:
        for u in self._users:
            if u is not sender:
                u.receive(f"{sender.name}: {message}")

# 사용
room = ChatRoom()
alice = User("Alice", room); bob = User("Bob", room); carol = User("Carol", room)
room.add(alice); room.add(bob); room.add(carol)
alice.send("안녕하세요")
bob.send("반갑습니다")
```

### 5.2 타입별 라우팅(명령/이벤트 분리)

```python
from dataclasses import dataclass
from typing import Protocol, Dict, Type, Callable, Any

# 메시지 타입
@dataclass(frozen=True) class CreateOrder: user_id: int; items: list[str]
@dataclass(frozen=True) class OrderCreated: order_id: str; user_id: int

# 핸들러 프로토콜
class CommandHandler(Protocol):
    def __call__(self, cmd: Any) -> Any: ...

class EventHandler(Protocol):
    def __call__(self, evt: Any) -> None: ...

class TypedMediator:
    def __init__(self) -> None:
        self._cmd_handlers: Dict[Type, CommandHandler] = {}
        self._evt_handlers: Dict[Type, list[EventHandler]] = {}

    def register_command(self, t: Type, h: CommandHandler) -> None:
        self._cmd_handlers[t] = h

    def register_event(self, t: Type, h: EventHandler) -> None:
        self._evt_handlers.setdefault(t, []).append(h)

    def send(self, cmd: Any) -> Any:
        h = self._cmd_handlers[type(cmd)]
        result = h(cmd)
        return result

    def publish(self, evt: Any) -> None:
        for h in self._evt_handlers.get(type(evt), []):
            h(evt)

# 예시 핸들러
import uuid
store: dict[str, dict] = {}

def create_order_handler(cmd: CreateOrder) -> str:
    oid = str(uuid.uuid4())
    store[oid] = {"user_id": cmd.user_id, "items": cmd.items}
    bus.publish(OrderCreated(order_id=oid, user_id=cmd.user_id))
    return oid

def audit_order_created(evt: OrderCreated) -> None:
    print(f"AUDIT: Order={evt.order_id} by User={evt.user_id}")

bus = TypedMediator()
bus.register_command(CreateOrder, create_order_handler)
bus.register_event(OrderCreated, audit_order_created)

oid = bus.send(CreateOrder(user_id=10, items=["A","B"]))
```

핵심: **명령(send)** 은 단일 핸들러, **이벤트(publish)** 는 다중 구독자.

### 5.3 비동기 Mediator (asyncio)

```python
import asyncio
from typing import Awaitable, Callable, Dict, Type, Any

AsyncHandler = Callable[[Any], Awaitable[Any]]

class AsyncMediator:
    def __init__(self) -> None:
        self._cmd: Dict[Type, AsyncHandler] = {}
        self._evt: Dict[Type, list[AsyncHandler]] = {}

    def command(self, t: Type, h: AsyncHandler) -> None: self._cmd[t] = h
    def event(self, t: Type, h: AsyncHandler) -> None: self._evt.setdefault(t, []).append(h)

    async def send(self, cmd: Any) -> Any: return await self._cmd[type(cmd)](cmd)
    async def publish(self, evt: Any) -> None:
        await asyncio.gather(*[h(evt) for h in self._evt.get(type(evt), [])])

# 사용 시 await mediator.send(...) / publish(...)
```

비동기에서는 **오더링, 재시도, 타임아웃**을 중재자에서 통일적으로 제공할 수 있다.

---

## 6. UI 폼 시나리오 — 위젯 간 직접참조 제거

**문제**: 입력 변경 → 즉시 검증 → 버튼 활성화 → 에러 표시. 위젯들이 서로 직접 호출하면 순환 의존이 쉽게 발생.

**해결**: 각 위젯은 **Mediator에 이벤트를 알리고**, Mediator가 규칙에 따라 다른 위젯에 명령.

```python
class FormMediator:
    def __init__(self, name_input, age_input, submit_button, error_label):
        self.name_input = name_input
        self.age_input = age_input
        self.submit_button = submit_button
        self.error_label = error_label

    def on_change(self, sender):
        errors = []
        if not self.name_input.text.strip(): errors.append("이름은 필수")
        try:
            age = int(self.age_input.text)
            if age < 0: errors.append("나이는 0 이상")
        except ValueError:
            errors.append("나이는 정수")

        if errors:
            self.error_label.set("\n".join(errors))
            self.submit_button.disable()
        else:
            self.error_label.clear()
            self.submit_button.enable()
```

UI 컴포넌트는 **Mediator에만 보고**하며 서로를 모른다.

---

## 7. Java — 간단한 중재자

```java
interface Mediator { void notify(Colleague sender, String event); }

abstract class Colleague {
    protected final Mediator mediator;
    protected Colleague(Mediator m) { this.mediator = m; }
}

class Button extends Colleague {
    public Button(Mediator m) { super(m); }
    public void click() { mediator.notify(this, "click"); }
}

class TextBox extends Colleague {
    private String text = "";
    public TextBox(Mediator m) { super(m); }
    public void setText(String t) { text = t; mediator.notify(this, "changed"); }
    public String getText() { return text; }
}

class Dialog implements Mediator {
    private final Button ok;
    private final TextBox name;
    Dialog() {
        this.ok = new Button(this);
        this.name = new TextBox(this);
    }
    public Button okButton() { return ok; }
    public TextBox nameBox() { return name; }

    @Override
    public void notify(Colleague sender, String event) {
        if (sender == name && event.equals("changed")) {
            if (name.getText().isBlank()) System.out.println("오류: 이름은 필수");
        }
        if (sender == ok && event.equals("click")) {
            if (!name.getText().isBlank()) System.out.println("제출");
            else System.out.println("제출 불가");
        }
    }
}

public class Demo {
    public static void main(String[] args) {
        Dialog dlg = new Dialog();
        dlg.nameBox().setText("");
        dlg.okButton().click();
        dlg.nameBox().setText("Kim");
        dlg.okButton().click();
    }
}
```

---

## 8. C# 스타일 — 요청/응답/알림(CQRS풍)

```csharp
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

public interface IRequest<TResponse> {}
public interface INotification {}
public interface IRequestHandler<TReq,TRes> where TReq : IRequest<TRes> {
    Task<TRes> Handle(TReq request, CancellationToken ct);
}
public interface INotificationHandler<T> where T : INotification {
    Task Handle(T notification, CancellationToken ct);
}

public class Mediator {
    private readonly Dictionary<Type, object> _reqHandlers = new();
    private readonly Dictionary<Type, List<object>> _evtHandlers = new();

    public void RegisterRequest<TReq,TRes>(IRequestHandler<TReq,TRes> h) where TReq : IRequest<TRes>
        => _reqHandlers[typeof(TReq)] = h;

    public void RegisterEvent<T>(INotificationHandler<T> h) where T : INotification
        => _evtHandlers.TryGetValue(typeof(T), out var list)
           ? list.Add(h) : _evtHandlers[typeof(T)] = new List<object>{h};

    public Task<TRes> Send<TRes>(IRequest<TRes> req, CancellationToken ct=default)
        => ((IRequestHandler<IRequest<TRes>,TRes>)_reqHandlers[req.GetType()]).Handle((dynamic)req, ct);

    public Task Publish<T>(T evt, CancellationToken ct=default) where T : INotification {
        if(!_evtHandlers.TryGetValue(typeof(T), out var list)) return Task.CompletedTask;
        var tasks = new List<Task>();
        foreach (var h in list) tasks.Add(((INotificationHandler<T>)h).Handle(evt, ct));
        return Task.WhenAll(tasks);
    }
}

// 예시 메시지/핸들러
public record CreateUser(string Name) : IRequest<Guid>;
public record UserCreated(Guid Id, string Name) : INotification;

public class CreateUserHandler : IRequestHandler<CreateUser, Guid> {
    public Task<Guid> Handle(CreateUser r, CancellationToken ct) {
        var id = Guid.NewGuid(); /* 저장 로직 */
        return Task.FromResult(id);
    }
}
public class AuditUserCreated : INotificationHandler<UserCreated> {
    public Task Handle(UserCreated e, CancellationToken ct) {
        Console.WriteLine($"AUDIT {e.Id} {e.Name}");
        return Task.CompletedTask;
    }
}
```

핵심 포인트
- **Send**: 단일 핸들러, 결과 반환
- **Publish**: 다중 핸들러, fan-out
- 타임아웃/재시도/트랜잭션/파이프라인(로깅, 성능계측)도 Mediator에 주입 가능

---

## 9. TypeScript — 채널형 Mediator

```ts
type Handler<T> = (msg: T) => void | Promise<void>;

class Mediator {
  private topics = new Map<string, Set<Handler<any>>>();

  subscribe<T>(topic: string, h: Handler<T>): () => void {
    const set = this.topics.get(topic) ?? new Set();
    set.add(h as Handler<any>);
    this.topics.set(topic, set);
    return () => set.delete(h as Handler<any>);
  }

  async publish<T>(topic: string, msg: T): Promise<void> {
    const set = this.topics.get(topic); if (!set) return;
    await Promise.all([...set].map(h => Promise.resolve(h(msg))));
  }
}

// 사용
const bus = new Mediator();
const unsub = bus.subscribe("order.created", (m:{id:string}) => { /* audit */ });
bus.publish("order.created", {id: "O123"});
unsub();
```

---

## 10. 도메인/시스템 시나리오

1) **항공 관제**: 각 항공기는 서로 통신하지 않고 관제탑(Mediator)과만 대화. 충돌 회피, 이륙/착륙 순서 결정.
2) **마이크로서비스 Saga Orchestrator**: 주문→결제→재고→배송을 오케스트레이터가 조율(보상 트랜잭션 포함).
3) **IDE/그래픽 도구**: 선택/이동/스냅 등 툴들이 캔버스를 직접 건드리지 않고 커맨드/이벤트 경유.

---

## 11. 동시성·오더링·오류 처리

- **오더링**: 토픽별 순서 보장 필요 시, 큐/채널 per-key로 구성. 파티셔닝 키(예: userId)로 ordering 유지.
- **스레드 안전**: 등록/구독 변화가 잦다면 RWLock·Lock-free 구조 검토.
- **오류 격리**: 한 핸들러 실패가 전체 실패로 번지지 않도록 **개별 트라이/재시도/서킷 브레이커**.
- **타임아웃/취소**: C# `CancellationToken`, Python `asyncio.wait_for` 등으로 일관된 취소 프로토콜.
- **멱등성**: 재시도 시 중복 효과 방지(키드/상태 체크).
- **백프레셔**: 느린 소비자 보호(버퍼 한도/드롭/오버플로 전략).

---

## 12. Mediator vs Observer vs Facade vs Event Bus

| 패턴/구성 | 목적 | 관계 | 데이터 흐름 | 비고 |
|---|---|---|---|---|
| Mediator | 상호작용 규칙 중앙화 | Colleague↔Mediator | 양방향/명령+이벤트 | 규칙·순서·검증 포함 |
| Observer | 상태변화 통보 | Subject→Observers | 단방향 푸시 | 규칙은 분산, 중재자 없음 |
| Facade | 서브시스템 단순화 | Client→Subsystem | 단방향 | 상호작용이 아니라 **진입점** |
| Event Bus | 광범위 브로드캐스트 | Publisher→Subscribers | 단방향 | 중개이지만 규칙 최소화 |

Mediator는 **규칙·흐름 제어**를 적극적으로 담는 점이 핵심 차별점이다.

---

## 13. 안티패턴과 대응

- **God Mediator**: 모든 규칙이 몰려 비대화.
  → 토픽/기능별 **서브 중재자** 분리, 파이프라인/데코레이터로 횡단 관심사 분리.
- **우회 통신**(Backdoor): Colleague가 서로 직접 호출.
  → 코드리뷰 규칙/테스트로 차단, 의존성 주입 컨테이너에서 강제.
- **메모리 누수**: 구독자 등록만 하고 해제 없음.
  → 해지 토큰/스코프, WeakRef, Dispose 패턴.
- **순환 이벤트 루프**: A 통지 → B 반응 → 다시 A 트리거.
  → 재진입 방지 플래그/세션 ID로 중복 차단.

---

## 14. 테스트 전략

- **단위**: 중재자에 테스트 더블(가짜 Colleague) 주입, 시나리오별 라우팅 검증.
- **계약**: 한 명령에 하나의 핸들러만 등록되어야 하는 규칙 등 검증.
- **동시성**: 레이스 조건/오더링 보장 여부에 대한 프로퍼티 테스트.
- **회귀**: 토픽/타입 이름 변경 시 깨지지 않도록 스냅샷/계약 테스트.

예시(PyTest 스케치):

```python
def test_publish_fanout(monkeypatch):
    hits = []
    def h1(e): hits.append(("h1", e))
    def h2(e): hits.append(("h2", e))
    bus = TypedMediator()
    class E: pass
    bus.register_event(E, h1); bus.register_event(E, h2)
    bus.publish(E())
    assert [k for k,_ in hits] == ["h1","h2"]
```

---

## 15. 체크리스트

- [ ] Colleague는 **Mediator만 의존**하는가(상호 직접 참조 금지)?
- [ ] 라우팅/검증/오더링/로깅/트랜잭션 등 **규칙이 중앙**에 모였는가?
- [ ] 명령(send)과 이벤트(publish)의 **계약**이 명확한가?
- [ ] 구독 해제/수명 관리로 **메모리 누수**를 방지했는가?
- [ ] 실패 격리/재시도/타임아웃/취소가 일관적으로 적용되는가?
- [ ] 성능 병목(단일 스레드 Mediator) 시 **샤딩/분산** 전략이 있는가?

---

## 16. 정리

- Mediator는 **결합도를 O(n)** 으로 줄이고, **상호작용 규칙을 중앙집중화**한다.
- 명령/이벤트를 분리하면 **CQRS 스타일**의 확장성과 가시성을 얻을 수 있다.
- 비동기·분산 환경에서는 **오더링·백프레셔·멱등성·타임아웃**을 중재자에서 표준화하라.
- 과도한 비대화는 **서브 중재자/파이프라인/토픽 분할**로 완화하라.

---

## 부록 A. 수식 메모 — 엣지 수 비교

완전 연결된 참여자 \( n \)개의 상호 참조 수:
$$
E_{\text{full}}=\frac{n(n-1)}{2}
$$

Mediator 적용 시:
$$
E_{\text{mediated}}=n
$$

**규모가 커질수록 차이는 \(O(n^2)\) vs \(O(n)\)** 로 벌어지며, 변경 비용·테스트 복잡도도 함께 감소한다.
