---
layout: post
title: DB - 데이터베이스 구조와 성능
date: 2025-02-12 19:20:23 +0900
category: DB
---
# 🏗️ 데이터베이스 구조와 성능의 관계

데이터베이스의 구조(Structure)는 데이터의 **정의, 배치, 연결, 저장 방식**을 포함하며, 이는 성능에 **직접적인 영향**을 미칩니다.

---

## 1️⃣ 데이터베이스 구조란?

| 구조 유형 | 설명 |
|-----------|------|
| 논리 구조 (Logical) | 엔터티/속성/관계 모델링, 정규화, 키 구성 등 |
| 물리 구조 (Physical) | 테이블 구조, 인덱스, 파티션, 클러스터링, 저장 위치 |
| 저장 구조 (Storage) | 블록 크기, I/O 설정, 테이블스페이스, 파일 그룹 등 |
| 시스템 구조 | RDBMS 엔진 구성, 인스턴스 수, 캐시/버퍼 설정 |

---

## 2️⃣ 데이터 구조 설계가 성능에 미치는 주요 영향

| 설계 요소 | 성능 영향 |
|-----------|------------|
| 정규화 수준 | 정규화는 데이터 중복 제거로 저장 공간과 무결성 ↑, 하지만 과도하면 JOIN 증가로 성능 ↓ |
| 반정규화 적용 여부 | 읽기 성능 ↑, 하지만 쓰기 성능과 데이터 일관성 유지 비용 ↑ |
| 키 설계 (PK/FK) | 식별자 설계는 인덱스, JOIN, 쿼리 플랜 등에 큰 영향 |
| 파티셔닝 | 파티션 프루닝으로 대량 데이터 조회 성능 비약적 향상 |
| 클러스터링 | 클러스터 인덱스는 데이터의 물리적 정렬에 기반해 범위 조회 성능 개선 |
| 인덱스 구조 | 적절한 인덱스는 SELECT 성능 ↑, 하지만 INSERT/UPDATE는 부하 ↑ |
| 스토리지 배치 | 데이터/인덱스/Redo 등을 디스크 단위로 분리 시 I/O 병목 해소 |

---

## 3️⃣ 성능 병목의 주요 원인과 구조적 대응

### 📌 JOIN 과다 / 비효율적 관계 설계
- 비정상적 정규화 (2NF 미준수 등) → 불필요한 테이블 분리
- 해결:
  - 관계 재설계 또는 반정규화
  - 중간 테이블 최소화
  - JOIN 순서 조절 및 서브쿼리 제거

### 📌 인덱스 부재 또는 과잉
- 인덱스 미존재 → Full Table Scan
- 인덱스 과다 → DML 성능 저하
- 해결:
  - 조건절 기준 복합 인덱스 설계
  - **Covering Index** 활용
  - 사용되지 않는 인덱스 정리

### 📌 파티셔닝 미적용
- 대용량 테이블에서 WHERE 조건 없이 전체 스캔
- 해결:
  - 날짜/범위/해시 기반 파티셔닝
  - 파티션 키 설계 주의: 자주 사용하는 필드로 구성

### 📌 클러스터링 고려 부족
- 무작위 저장으로 I/O 비용 증가
- 해결:
  - 자주 조회되는 컬럼 기준으로 클러스터 인덱스 적용

---

## 4️⃣ 구조적 성능 설계의 사례

### 예시 1: 주문 + 주문상세 테이블
- 구조: 주문(Order), 주문상세(OrderItem) → 1:N 관계
- 성능 고려:
  - 복합 PK: (주문번호 + 상품ID)
  - FK 제약조건 사용
  - 주문일 기준 파티셔닝 → 보고서 성능 향상

### 예시 2: 사용자 로그 테이블
- 문제: 5억 건 이상 → 조회/삭제 성능 저하
- 대응:
  - 수평 파티셔닝 (월 단위)
  - 로그 데이터는 별도 테이블로 Archive
  - Materialized View로 요약 데이터 캐싱

---

## 5️⃣ 구조 설계와 쿼리 튜닝의 연계

- SQL은 데이터 구조 위에서 작동 → 구조가 나쁘면 튜닝에도 한계
- 설계와 SQL은 반드시 함께 고려

| 항목 | 설계적 개선 | SQL 튜닝 |
|------|-------------|----------|
| 조인 횟수 과다 | 반정규화 | 조인 순서 조정 |
| 느린 정렬 | 클러스터링 | 인덱스 활용 |
| 집계 성능 문제 | 집계용 컬럼 추가 | Group By 최적화 |
| 느린 페이징 | 커버링 인덱스 | Seek 방식 LIMIT |

---

## 6️⃣ 대규모 시스템에서 구조가 중요한 이유

- 페타바이트(PB) 단위 데이터는 단순 튜닝으로 해결 불가
- 설계 단계에서:
  - **데이터 분산 전략**
  - **쿼리 패턴 중심 설계**
  - **쓰기/읽기 분리 구조** 고려 필수

---

## ✅ 결론: 성능 중심 구조 설계의 원칙

1. 정규화 → 정합성 확보  
2. 병목 발생 → 반정규화  
3. 데이터 증가 → 파티셔닝/클러스터링  
4. 조회 패턴 고려 → 복합 인덱스/Materialized View  
5. 지속적인 모니터링 → 구조 개선 피드백 루프

> ❗ 데이터베이스 성능은 구조에서 시작되며, 구조는 성능의 운명을 좌우합니다.