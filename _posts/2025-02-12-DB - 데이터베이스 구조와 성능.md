---
layout: post
title: DB - 데이터베이스 구조와 성능
date: 2025-02-12 19:20:23 +0900
category: DB
---
# 데이터베이스 구조와 성능의 관계

## 성능을 지배하는 5가지 구조적 요소

데이터베이스 성능은 단순한 쿼리 튜닝 이상의 문제입니다. 시스템의 구조적 설계가 성능의 근본적인 한계와 가능성을 결정합니다. 다음 다섯 가지 구조적 요소가 성능에 결정적인 영향을 미칩니다.

1. **정규화 수준과 관계 설계**: 이는 조인 횟수, 데이터 카디널리티, 그리고 잠금 경합을 결정합니다.
2. **인덱스 설계**: 인덱스의 선두 컬럼 선택, 정렬 방향, 그리고 커버링 여부가 쿼리 복잡도를 극적으로 낮춥니다.
3. **파티셔닝과 클러스터링**: 데이터 스캔 범위를 구조적으로 제한하여 불필요한 I/O를 제거합니다.
4. **저장 구조와 데이터 배치**: 파일 그룹, 테이블스페이스, 리두 로그/WAL, 임시 공간의 물리적 분리가 병목 현상을 해소합니다.
5. **시스템 수준 구조**: 버퍼 풀 크기, 병렬 처리 설정, NUMA 아키텍처, 데이터 압축, WAL 설정 등이 물리적 연산 비용을 결정합니다.

성능 지연 시간은 근사적으로 `계획 수립(CPU) + 메모리 연산(해시/정렬) + I/O(스캔/탐색) + 동기화(WAL/락)`의 합으로 표현할 수 있습니다. 구조 설계는 이러한 각 항목의 상수 계수를 변화시키는 1차 변수 역할을 합니다.

---

## 데이터베이스 구조의 네 가지 층위

데이터베이스 구조는 서로 다른 추상화 수준에서 성능에 영향을 미칩니다.

| 층위 | 핵심 요소 | 성능 영향 |
|---|---|---|
| **논리적 구조** | 엔터티, 속성, 관계, 키, 정규화 수준 | 조인 횟수, 데이터 카디널리티, 쿼리 최적화기의 정확도 |
| **물리적 구조** | 테이블, 인덱스, 클러스터링, 파티셔닝 | 데이터 접근 패턴(스캔/탐색), 정렬 필요성, 페이지 지역성 |
| **저장 구조** | 블록/페이지, 파일 그룹, 테이블스페이스, 임시/리두 공간 | 랜덤/순차 I/O 비율, 임시 파일 스필, 체크포인트 간섭 |
| **시스템 구조** | 버퍼 풀, 쿼리 메모리, 병렬 처리, NUMA, 압축 | 캐시 적중률, 스필 회피, 동시성 처리, CPU 효율성 |

효율적인 설계는 **논리 → 물리 → 저장 → 시스템**의 순서로 각 층위에서의 결정이 누적되어 이루어집니다.

---

## 논리적 구조가 성능에 미치는 영향

### 정규화와 조인 비용의 균형
정규화는 데이터 중복을 제거하여 저장 공간을 줄이고 무결성을 높이지만, 과도한 정규화는 많은 조인을 유발하여 성능을 저하시킬 수 있습니다.

**해시 조인**의 비용은 빌드 단계와 프로브 단계로 구성되며, 일반적으로 작은 테이블을 빌드하는 것이 효율적입니다. **인덱스 중첩 루프 조인**은 적절한 인덱스가 존재할 때 효율적이며, 그 비용은 외부 테이블 행 수와 내부 테이블 인덱스 탐색 비용에 비례합니다.

정규화의 이점은 행 크기 감소로 인한 캐시 적중률 향상과 스캔 페이지 수 감소입니다. 반면, 단점은 조인 횟수 증가로 인한 랜덤 I/O 증가 가능성입니다. 이는 적절한 조인 키 인덱스, 커버링 인덱스, 파티션 정렬 전략으로 완화할 수 있습니다.

### 키 설계의 영향
**자연키**(이메일, 주민번호 등)는 변경 가능성과 길이 문제로 인덱스 성능에 부정적 영향을 줄 수 있습니다. **인조키**(시퀀스, UUID)를 기본키로 사용하고, 업무적 유일성을 보장해야 하는 컬럼에는 별도의 UNIQUE 제약을 두는 것이 일반적인 모범 사례입니다.

```sql
-- 인조키 기본키 + 업무 키 UNIQUE 제약
CREATE TABLE app_user (
  user_id BIGSERIAL PRIMARY KEY,  -- 인조키
  email   TEXT NOT NULL UNIQUE,   -- 업무적 유일성 보장
  name    TEXT NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);
```

---

## 물리적 구조: 인덱스, 클러스터링, 파티셔닝

### 인덱스 설계의 세 가지 원칙
1. **선두 컬럼**: 선택도가 높은(고유한 값이 많은) 컬럼을 선두에 위치
2. **정렬 방향**: ORDER BY 절의 정렬 방향과 인덱스 정렬 방향 일치
3. **커버링 인덱스**: SELECT 절의 모든 컬럼을 인덱스가 포함하도록 설계

```sql
-- 고객별 최근 주문 조회를 위한 최적화된 인덱스
CREATE INDEX idx_order_list
  ON orders (customer_id, status, ordered_at DESC)
  INCLUDE (amount); -- 커버링 인덱스 (PostgreSQL)

-- 최적화된 쿼리
SELECT order_id, ordered_at, amount
FROM orders
WHERE customer_id = :cid AND status = 'PAID'
ORDER BY ordered_at DESC
LIMIT 50;
```

### 클러스터링: 물리적 데이터 정렬
클러스터링은 데이터를 특정 키 순서로 물리적으로 저장하여 관련 데이터의 지역성을 높입니다. 이는 범위 쿼리와 정렬 작업의 성능을 크게 향상시킵니다.

```sql
-- PostgreSQL: 테이블을 인덱스 순서로 물리적 재배치
CLUSTER orders USING idx_orders_ordered_at;

-- 재배치 후 범위 쿼리 성능 향상
SELECT * FROM orders
WHERE ordered_at >= now() - interval '1 day'
ORDER BY ordered_at DESC
LIMIT 100;
```

### 파티셔닝: 데이터 분할로 스캔 범위 축소
파티셔닝은 대량의 데이터를 논리적 단위로 분할하여 관리 효율성과 쿼리 성능을 향상시킵니다.

```sql
-- PostgreSQL: 날짜 기반 범위 파티셔닝
CREATE TABLE log_events (
  id BIGSERIAL,
  ts timestamptz NOT NULL,
  service text NOT NULL,
  payload jsonb NOT NULL,
  PRIMARY KEY (id, ts)
) PARTITION BY RANGE (ts);

-- 월별 파티션 생성
CREATE TABLE log_events_2025_11 PARTITION OF log_events
  FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');

-- 파티션 프루닝이 적용된 효율적인 쿼리
SELECT count(*) FROM log_events
WHERE ts >= '2025-11-20' AND ts < '2025-11-21';
```

파티셔닝의 핵심은 쿼리 조건에서 자주 사용되는 컬럼을 파티션 키로 선정하는 것입니다. 또한 파티션 추가/제거를 자동화하는 운영 절차를 마련하는 것이 중요합니다.

---

## 저장 구조: I/O 병목 해소를 위한 물리적 분리

저장 구조의 적절한 설계는 I/O 경쟁을 줄이고 시스템 전반의 성능을 향상시킵니다.

| 구성 요소 | 배치 원칙 | 이유 |
|---|---|---|
| **데이터 파일** | 전용 고속 스토리지 | 랜덤 읽기/쓰기 성능 보장 |
| **인덱스 파일** | 데이터와 분리 가능 | I/O 경합 감소, 병렬성 향상 |
| **임시/정렬 공간** | 고성능 NVMe SSD | 정렬 및 해시 조인 스필 성능 보장 |
| **트랜잭션 로그** | 순차 쓰기 최적화 스토리지 | 커밋 지연 최소화 |
| **아카이브/백업** | 저비용 대용량 스토리지 | 비용 효율성 및 운영 부하 분리 |

```sql
-- PostgreSQL: 테이블스페이스를 이용한 물리적 분리
CREATE TABLESPACE ts_data LOCATION '/mnt/fast/data';
CREATE TABLESPACE ts_idx  LOCATION '/mnt/fast/index';
CREATE TABLESPACE ts_tmp  LOCATION '/mnt/nvme/tmp';

-- 테이블과 인덱스를 다른 테이블스페이스에 배치
CREATE TABLE big_fact (...) TABLESPACE ts_data;
CREATE INDEX ix_big_fact_d ON big_fact(d) TABLESPACE ts_idx;
SET temp_tablespaces = 'ts_tmp';
```

### 블록 크기와 압축
데이터베이스 블록 크기와 저장 장치의 특성이 일치하지 않으면 I/O 효율이 낮아질 수 있습니다. 압축은 CPU 사용량과 I/O 양 사이의 트레이드오프를 제공하며, 데이터 웨어하우스나 아카이브 테이블에 특히 유용합니다.

---

## 시스템 구조: 메모리와 병렬 처리

시스템 수준의 구조적 선택도 성능에 큰 영향을 미칩니다.

- **버퍼 풀/공유 버퍼**: 자주 접근하는 데이터셋의 크기에 맞게 설정해야 합니다. 너무 크면 운영체제 캐시의 이점을 잃고, 너무 작으면 캐시 적중률이 낮아집니다.
- **워크 메모리**: 정렬 및 해시 조인 작업에 사용되는 메모리를 적절히 설정하여 디스크 스필을 방지해야 합니다.
- **병렬 쿼리 처리**: 대용량 스캔이나 집계 작업을 여러 CPU 코어로 분산 처리할 수 있습니다.
- **NUMA 아키텍처**: 메모리 접근의 지역성을 고려한 설정이 성능에 중요합니다.

---

## 성능 병목 현상과 구조적 해결책

| 병목 원인 | 구조적 해결책 | SQL 수준 보완책 |
|---|---|---|
| **과도한/고비용 조인** | 선택적 반정규화, 파티션 정렬, 클러스터링 | 조인 순서 고정, EXISTS 활용, 세미조인 |
| **풀 테이블 스캔 빈발** | 함수 인덱스, 파티셔닝 | SARGable 조건 재작성(좌변에 컬럼 유지) |
| **정렬/집계 디스크 스필** | 클러스터링, 물질화 뷰, 파티션별 집계 | 윈도우 함수 최소화, 부분 집계 활용 |
| **DML 성능 저하** | 불필요한 인덱스 정리, 배치 처리 최적화 | 청크 단위 커밋, 벌크 연산 활용 |
| **I/O 경합** | Temp/WAL/데이터의 물리적 분리 | 쿼리 힌트를 통한 실행 계획 조정 |

---

## 사례 연구: 주문 시스템 성능 최적화

### 기본 구조
```sql
-- 고객 테이블
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL UNIQUE
);

-- 파티셔닝된 주문 테이블
CREATE TABLE orders (
  order_id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id),
  ordered_at timestamptz NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('PENDING','PAID','CANCELLED','SHIPPED','COMPLETED')),
  amount NUMERIC(12,2) NOT NULL CHECK (amount >= 0)
) PARTITION BY RANGE (ordered_at);

-- 최적화된 인덱스
CREATE INDEX idx_orders_cust_status_dt
  ON orders(customer_id, status, ordered_at DESC);
```

### 성능 문제: 고객별 최근 30일 매출 집계
기본 구현에서는 매번 주문 테이블을 스캔하고 집계해야 하므로 성능이 저하되었습니다.

**해결책: 요약 테이블 도입**
```sql
-- 일별 고객 매출 요약 테이블
CREATE TABLE daily_customer_sales (
  customer_id BIGINT NOT NULL,
  d DATE NOT NULL,
  revenue NUMERIC(18,2) NOT NULL,
  PRIMARY KEY (customer_id, d)
);

-- 배치 작업으로 요약 테이블 갱신
INSERT INTO daily_customer_sales(customer_id, d, revenue)
SELECT customer_id, ordered_at::date, SUM(amount)
FROM orders
WHERE ordered_at::date = current_date - 1
GROUP BY 1,2
ON CONFLICT (customer_id,d) DO UPDATE SET revenue = EXCLUDED.revenue;

-- 최적화된 조회 쿼리
SELECT customer_id, SUM(revenue) AS last30
FROM daily_customer_sales
WHERE d >= current_date - 30
GROUP BY 1
ORDER BY last30 DESC
LIMIT 50;
```

### 정합성 검증
요약 테이블의 정확성을 주기적으로 검증하는 것이 중요합니다.

```sql
-- 요약 테이블과 원본 데이터 비교
WITH source_data AS (
  SELECT customer_id, ordered_at::date d, SUM(amount) amt
  FROM orders
  WHERE ordered_at >= now() - interval '30 days'
  GROUP BY 1,2
)
SELECT COUNT(*) as mismatch_count
FROM source_data s
LEFT JOIN daily_customer_sales d
  ON (s.customer_id, s.d) = (d.customer_id, d.d)
WHERE s.amt IS DISTINCT FROM d.revenue;
```

---

## 구조적 선택의 수학적 이해

### 파티셔닝의 이점
파티션 수를 \(p\), 실제 접근하는 파티션 수를 \(k\)라고 할 때, 스캔 비용 감소율은 대략 \(1 - \frac{k}{p}\)입니다. 예를 들어 월별 36개 파티션 중 최근 1개월만 조회하면 약 97%의 스캔을 회피할 수 있습니다.

### 커버링 인덱스의 가치
테이블 랜덤 접근 비용을 \(c_t\), 인덱스만으로 쿼리가 처리될 때의 접근 비용을 \(c_i\)(\(c_i \ll c_t\))라고 하면, \(n\)개의 행을 처리할 때의 이득은 \(n \cdot (c_t - c_i)\)로 근사할 수 있습니다. 이는 대량의 페이지 랜덤 접근을 상수 시간 접근으로 줄여줍니다.

### 정렬 메모리 부족 임계값
정렬 대상 행 수를 \(M\), 정렬 키의 평균 바이트 수를 \(k\), 사용 가능한 메모리를 \(m\)이라고 할 때, 디스크 스필은 \(M \cdot k > m\)일 때 발생합니다. 구조적으로 클러스터링이나 정렬 방향이 일치하는 인덱스를 사용하면 정렬 작업 자체를 제거할 수 있습니다.

---

## 안전한 구조 변경을 위한 절차

구조 변경은 신중한 계획과 실행이 필요합니다.

1. **논리 모델 검토**: 정규화 수준, 키 설계, 관계 정확성 확인
2. **파티셔닝 도입**: 파티션 키, 단위, 자동 관리 절차 설계
3. **저장 구조 최적화**: Temp, WAL, 데이터/인덱스의 물리적 분리
4. **인덱스 재설계**: 실제 워크로드 패턴에 맞는 인덱스 설계
5. **클러스터링 검토**: 물리적 데이터 정렬 필요성 평가
6. **선택적 반정규화**: 필요한 경우 최소 범위로 적용 (동기화 메커니즘 포함)
7. **점진적 배포**: 읽기 전환과 철저한 모니터링
8. **결과 분석**: 성능 지표 변화 문서화

---

## 데이터베이스별 모니터링 포인트

각 데이터베이스 시스템은 고유한 모니터링 도구와 지표를 제공합니다.

- **PostgreSQL**: `EXPLAIN (ANALYZE, BUFFERS)`, `pg_stat_statements`, 잠금 모니터링, WAL 통계
- **MySQL/InnoDB**: Performance Schema, InnoDB 버퍼 풀 통계, 트랜잭션 로그 설정
- **Oracle**: AWR/ASH 리포트, 세그먼트 어드바이저, 인메모리 옵션

---

## 결론

데이터베이스 성능은 단일 기술이나 기법으로 해결될 수 없는 복합적인 문제입니다. 정규화를 통한 데이터 무결성은 모든 설계의 기초가 되어야 하며, 성능 최적화는 인덱스, 파티셔닝, 클러스터링과 같은 물리적 구조 설계에서 시작됩니다.

저장 구조의 적절한 분리(Temp, WAL, 데이터의 물리적 분리)는 I/O 병목을 근본적으로 해결합니다. 이러한 기법으로도 해결되지 않는 병목이 있을 때만 선택적 반정규화나 요약 테이블을 도입해야 하며, 이때도 데이터 정합성 유지와 롤백 계획을 반드시 수반해야 합니다.

가장 중요한 것은 구조 변경이 일회성 이벤트가 아닌 지속적인 프로세스라는 점입니다. 모든 변경은 벤치마크로 검증하고, 프로덕션에서는 철저히 모니터링하며, 성능 회귀가 발생하면 신속히 대응하는 체계가 필요합니다. 데이터베이스 구조 설계는 기술적 선택이자 비즈니스 요구사항과 운영 현실을 연결하는 전략적 결정입니다.