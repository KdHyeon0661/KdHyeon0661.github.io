---
layout: post
title: DB - 데이터베이스 구조와 성능
date: 2025-02-12 19:20:23 +0900
category: DB
---
# 데이터베이스 구조와 성능의 관계

## 성능을 지배하는 구조 신호 — 5가지 관문

1) **정규화 수준과 관계 설계**: 조인 수·카디널리티·잠금 경합을 좌우
2) **인덱스(논리+물리)**: **선두 컬럼·정렬 일치·커버링**이 쿼리 복잡도를 상수로 낮춤
3) **파티셔닝/클러스터링**: 스캔 범위를 구조적으로 잘라 **I/O를 선별적**으로 만듦
4) **저장 구조/배치**: 파일그룹·테이블스페이스·Redo/WAL·Temp의 **I/O 분리**가 병목을 제거
5) **시스템 구조**: 버퍼/캐시·병렬·NUMA·압축·WAL/Redo 파라미터가 **물리 비용**을 결정

핵심 원리(근사):
$$
\text{Latency} \approx \text{CPU}_{plan} + \text{Mem}_{hash/sort} + \text{IO}_{scan/seek} + \text{Sync}_{WAL/locks}
$$
구조는 위 항들의 상수를 바꾸는 **1차 변수**다.

---

## “데이터베이스 구조”의 네 층

| 층 | 핵심 요소 | 성능 영향 포인트 |
|---|---|---|
| 논리(Logical) | 엔터티/속성/관계, 키, 정규화 | 조인 수·카디널리티·이상 제거→옵티마이저 추정 정확도 |
| 물리(Physical) | 테이블/인덱스/클러스터/파티션 | 스캔/시크·정렬 회피·프루닝·페이지 근접성 |
| 저장(Storage) | 블록/페이지, 파일그룹/테이블스페이스, Temp/Redo 배치 | 랜덤/순차 I/O, 스필, 체크포인트 간섭 |
| 시스템(System) | 버퍼풀/쿼리메모리, 병렬, NUMA, 압축 | 캐시 적중률·스필 회피·동시성·CPU 효율 |

> 설계는 **논리→물리→저장→시스템** 순으로 누적 의사결정이 필요하다.

---

## 논리 구조와 성능 — 관계·키·정규화의 실제 비용

### 조인 비용과 정규화의 균형

- 조인 근사 비용(해시 조인):
$$
C_{\text{hash-join}} \approx O(|B|) + O(|P|)
$$
여기서 \(B\)=Build 집합(작은 쪽), \(P\)=Probe 집합(큰 쪽).
- 인덱스 중첩 루프:
$$
C_{\text{NLJ}} \approx |R|\cdot \log|S| \quad(\text{적합 인덱스가 있을 때})
$$

**정규화 이점**: 중복 제거→행 크기↓→캐시 적중률↑, 스캔 페이지 수↓
**부작용**: 조인 수↑→Random I/O↑ 가능.
**대응**: **조인 키 인덱스·커버링·파티션 정렬**로 조인 비용을 상수에 가깝게 만든다.

### 키(식별자) 설계

- **자연키 vs 인조키**: 자연키는 변경 가능성·길이 문제로 인덱스 비용↑. 대개 **인조키(PK)** + **보조 UNIQUE** 조합.
- **복합키**: 의미상 필요할 때만. 과도한 복합키는 인덱스 폭과 모든 조인의 비용을 키운다.

**예시 (정규화 + 후보키 관리)**

```sql
-- 후보키(이메일) 보장 + 인조키 PK
CREATE TABLE app_user (
  user_id BIGSERIAL PRIMARY KEY,
  email   TEXT NOT NULL UNIQUE,
  name    TEXT NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);
```

---

## 물리 구조 — 인덱스·클러스터·파티셔닝의 3점 결합

### 인덱스: 선두·정렬·커버링

**원칙**
1) 선두 컬럼 = 선택도 높은 필터
2) ORDER BY와 **인덱스 정렬 일치**
3) SELECT 목록을 **인덱스가 커버**하도록(가능하면)

**예시(최근 주문 목록)**
```sql
-- 고객/상태/최신순, 목록 조회를 커버
CREATE INDEX idx_order_list
  ON orders (customer_id, status, ordered_at DESC)
  INCLUDE (amount); -- PostgreSQL 11+, MySQL/InnoDB는 커버링은 secondary 키 구성을 조정

EXPLAIN (ANALYZE, BUFFERS)
SELECT order_id, ordered_at, amount
FROM orders
WHERE customer_id = :cid AND status = 'PAID'
ORDER BY ordered_at DESC
LIMIT 50;
```

**함수 인덱스**
```sql
-- 날짜만 자주 필터할 때
CREATE INDEX idx_logs_day ON logs ((date_trunc('day', log_ts)));

SELECT count(*) FROM logs
WHERE date_trunc('day', log_ts) = '2025-11-06'::date;
```
> 표현식은 **인덱스 정의와 동일**하게 써야 사용된다.

### 클러스터링(물리적 정렬)

- **클러스터형 인덱스**(InnoDB PK, SQL Server Clustered): 데이터가 키 순서로 저장 → 범위 스캔/ORDER BY 비용↓
- **비클러스터형**(PostgreSQL, Oracle Heap): `CLUSTER` 명령으로 한 번 정렬 가능(유지 비용 고려).

**예시: 클러스터링으로 정렬 회피**
```sql
-- PostgreSQL: 물리 재배치(정렬) - 주기적 유지 필요
CLUSTER orders USING idx_orders_ordered_at;

-- 이후 최근순 조회는 정렬/파일 정렬 감소
SELECT * FROM orders
WHERE ordered_at >= now() - interval '1 day'
ORDER BY ordered_at DESC
LIMIT 100;
```

### 파티셔닝: 프루닝으로 범위를 구조적으로 절단

**절차**
1) 파티션 키 = **주요 WHERE의 좌변**(주로 시계열)
2) 단위(일/월/분기) 결정 → **Drop/Attach** 운영 절차 설계
3) **로컬 인덱스**로 유지비 최소화

**예시: PostgreSQL RANGE 파티션**
```sql
CREATE TABLE log_events (
  id BIGSERIAL,
  ts timestamptz NOT NULL,
  service text NOT NULL,
  payload jsonb NOT NULL,
  PRIMARY KEY (id, ts)
) PARTITION BY RANGE (ts);

CREATE TABLE log_events_2025_11 PARTITION OF log_events
  FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');

-- Pruning이 되도록 조건을 직접 건다
SELECT count(*) FROM log_events
WHERE ts >= '2025-11-20' AND ts < '2025-11-21';
```

**Oracle Interval/SQL Server Partition Function**도 유사하게 적용.

---

## 저장 구조 — I/O 배치와 스필, WAL/Redo

### 파일그룹/테이블스페이스 분리

| 구성 | 배치 원칙 | 이유 |
|---|---|---|
| 데이터 | 전용 LUN/디스크 | 랜덤 읽기/쓰기 분리 |
| 인덱스 | (선택) 분리 | I/O 혼잡 분리, 병렬성 확보 |
| Temp/Sort | 고성능 SSD | 스필·해시/정렬 임시파일 병목 완화 |
| WAL/Redo | 순차 쓰기 최적 매체 | 커밋 지연 최소화 |
| 아카이브/백업 | 느린/저렴한 스토리지 | 비용 효율 + 운영부하 분리 |

**예시: PostgreSQL**
```sql
-- 테이블스페이스 생성
CREATE TABLESPACE ts_data LOCATION '/mnt/fast/data';
CREATE TABLESPACE ts_idx  LOCATION '/mnt/fast/index';
CREATE TABLESPACE ts_tmp  LOCATION '/mnt/nvme/tmp';

-- 배치
CREATE TABLE big_fact (...) TABLESPACE ts_data;
CREATE INDEX ix_big_fact_d ON big_fact(d) TABLESPACE ts_idx;
SET temp_tablespaces = 'ts_tmp';
```

### 블록/페이지 크기, 압축, 체크포인트

- 페이지 크기와 I/O 장치 특성의 불일치 → 낭비 발생
- **압축**: CPU vs I/O 교환. DW·아카이브 테이블에 유리, OLTP 핫 경로는 신중.
- **체크포인트**/`innodb_flush_log_at_trx_commit`/`wal_compression` 등 파라미터는 **커밋 지연**을 좌우.

---

## 시스템 구조 — 버퍼풀/메모리/병렬/NUMA

- **버퍼풀/Shared Buffers**를 핫셋 크기에 맞춘다(과도하면 OS 캐시 이점 상실, 적으면 적중률↓).
- **워크메모리/정렬메모리**를 정렬/해시 집계 스필이 줄도록 서비스별 튜닝.
- **병렬 쿼리**(Oracle 힌트, PostgreSQL Parallel Gather)로 큰 스캔/집계를 분해.
- **NUMA**: 메모리 지역성 고려, 바인딩/hugepage 검토.

---

## 병목 유형 → 구조적 대응 맵

| 병목 | 원인 | 구조적 대응 | SQL 대응 |
|---|---|---|---|
| JOIN 과다/고비용 | 과도한 분해, 조인 키 인덱스 부재 | 선택적 반정규화, 파티션 정렬, 클러스터링 | 조인 순서 고정, EXISTS, 세미조인 |
| Full Scan 빈발 | 조건 함수화·인덱스 부적합 | 함수/생성열 인덱스, 파티셔닝 | SARGable 재작성(좌변 컬럼) |
| 정렬/집계 스필 | 워크메모리 부족, 정렬+대량집계 | 클러스터링, 물질화뷰, 파티션 집계 | PARTIAL/GROUPING SETS/윈도우 최소화 |
| DML 느림 | 인덱스 과다, PK/FK 설계 | 인덱스 정리·배치, FK 지연검증(일괄) | 청크 커밋, 배치/벌크 로드 |
| I/O 병목 | Temp/WAL 충돌, 혼합 배치 | Temp/WAL 분리, NVMe | LIMIT…WITH TIES, 힌트로 조정 |

---

## 사례 연구 A — 주문/주문상세, 보고서와 운영의 공존

### 논리·물리 모델

```sql
CREATE TABLE customer (
  customer_id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL UNIQUE
);

CREATE TABLE orders (
  order_id BIGSERIAL PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES customer(customer_id),
  ordered_at timestamptz NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('PENDING','PAID','CANCELLED','SHIPPED','COMPLETED')),
  amount NUMERIC(12,2) NOT NULL CHECK (amount >= 0)
) PARTITION BY RANGE (ordered_at);

CREATE INDEX idx_orders_cust_status_dt
  ON orders(customer_id, status, ordered_at DESC);
```

### 대시보드(최근 30일 매출 Top N)

- 베이스라인: 조인+집계+정렬 → 느림
- 구조 개선: **일자×고객 요약 테이블** + 파티션

```sql
CREATE TABLE daily_customer_sales (
  customer_id BIGINT NOT NULL,
  d DATE NOT NULL,
  revenue NUMERIC(18,2) NOT NULL,
  PRIMARY KEY (customer_id, d)
);

-- 배치 적재 (또는 CDC)
INSERT INTO daily_customer_sales(customer_id, d, revenue)
SELECT customer_id, ordered_at::date, SUM(amount)
FROM orders
WHERE ordered_at::date = current_date - 1
GROUP BY 1,2
ON CONFLICT (customer_id,d) DO UPDATE SET revenue = EXCLUDED.revenue;

-- 조회(고속)
SELECT customer_id, SUM(revenue) AS last30
FROM daily_customer_sales
WHERE d >= current_date - 30
GROUP BY 1
ORDER BY last30 DESC
LIMIT 50;
```

### 정합성 검증·수선 잡

```sql
WITH led AS (
  SELECT customer_id, ordered_at::date d, SUM(amount) amt
  FROM orders
  WHERE ordered_at >= now() - interval '30 days'
  GROUP BY 1,2
)
SELECT COUNT(*) diff_rows
FROM led l
LEFT JOIN daily_customer_sales s
  ON (l.customer_id,l.d)=(s.customer_id,s.d)
WHERE l.amt IS DISTINCT FROM s.revenue;
```

---

## 사례 연구 B — 초대형 로그 테이블(5억 행) 정리

### 구조

- 월별 **RANGE 파티션**, 서비스 코드 **서브파티션**(DB별 지원에 맞춰 적용)
- Temp/WAL/데이터 **스토리지 분리**
- Top-K 조회 패턴에 맞춘 **커버링 인덱스**

```sql
CREATE TABLE web_log (
  id BIGSERIAL,
  ts timestamptz NOT NULL,
  svc text NOT NULL,
  user_id BIGINT,
  path text NOT NULL,
  status smallint NOT NULL,
  bytes int NOT NULL,
  PRIMARY KEY (id, ts)
) PARTITION BY RANGE (ts);

CREATE INDEX idx_weblog_svc_ts ON web_log (svc, ts DESC);
```

### 운영

- 매월 1일 `DETACH PARTITION` → `archive` 스키마로 이동
- 보존주기 만료 파티션 Drop
- BI/리포트는 외부 테이블 또는 DW로 조회

---

## 수식으로 보는 구조적 선택

### 파티션 프루닝 이득

파티션 수 \(p\), 활성 범위 \(k\)(선택된 파티션 수).
스캔 비용 감소율 근사:
$$
\text{gain} \approx 1 - \frac{k}{p}
$$
월단위 36개 파티션 중 1개월만 조회 → 약 \(97\%\) 스캔 회피.

### 커버링 인덱스의 이득

테이블 랜덤 접근 비용 \(c_t\), 인덱스만으로 충족 시 접근 \(c_i\)(\(c_i \ll c_t\)):
$$
\Delta \approx n\cdot (c_t - c_i)
$$
\(n\) = 반환/검사 행 수. 대량 페이지 랜덤 접근을 상수로 낮춘다.

### 정렬 스필 임계

정렬 대상 행 \(M\), 정렬키 평균 바이트 \(k\), 메모리 \(m\):
$$
\text{spill} \;\;\text{iff}\;\; M\cdot k > m
$$
→ 구조적으로 **클러스터링/인덱스 정렬 일치**로 정렬을 제거하라.

---

## 저장·인덱스 유지·배치 DML 절차

### 인덱스 블로트/조각화 대응

- PostgreSQL: `REINDEX CONCURRENTLY`, `VACUUM (FULL)` 신중히
- MySQL: `OPTIMIZE TABLE`
- Oracle: `ALTER INDEX ... REBUILD`

### 대량 UPDATE/DELETE의 청크 커밋

```sql
DO $$
DECLARE
  _limit int := 10000;
  _cnt   int;
BEGIN
  LOOP
    WITH cte AS (
      SELECT id FROM big_table
      WHERE need_fix = true
      LIMIT _limit
      FOR UPDATE SKIP LOCKED
    )
    UPDATE big_table t
       SET need_fix=false, updated_at=now()
      FROM cte
     WHERE t.id=cte.id;

    GET DIAGNOSTICS _cnt = ROW_COUNT;
    EXIT WHEN _cnt=0;
    COMMIT;  -- 청크 커밋
    BEGIN;   -- 다음 라운드
  END LOOP;
END $$;
```
- Undo/Redo 폭발 방지, 락 점유 시간 단축.

---

## 구조 설계와 SQL 튜닝의 연계 — 대응 표

| 문제 | 구조적 개선 | 대표 SQL·전략 |
|---|---|---|
| 느린 페이징 | 클러스터링, 정렬 일치 인덱스 | SEEK 방식 페이징(`WHERE key < ? ORDER BY key DESC LIMIT N`) |
| 비효율 JOIN | 파티션 정렬, 스냅샷 컬럼(선택적) | `EXISTS`/세미조인, 조인 순서 힌트 |
| 집계 느림 | 일자·테넌트 파티션, 요약 테이블 | 부분집계→재집계, 물질화뷰 Fast Refresh |
| 카디널리티 오판 | 코드/상태 히스토그램 | `ANALYZE`, `DBMS_STATS` 파라미터 튜닝 |
| Temp 스필 | Temp 전용 NVMe, 워크메모리 상향 | 정렬 회피(인덱스), 해시→소트머지 전환 검토 |

---

## 설계→운영 피드백 루프(회귀 방지)

1) **Top-K 쿼리 목록화**(p95/99, 호출량, 총 CPU/IO)
2) 스키마/인덱스 변경 전후 **EXPLAIN (ANALYZE, BUFFERS)** 스냅샷
3) CI에 **벤치마크 쿼리** 포함(스키마 변경 PR 차단 기준)
4) 모니터링: `pg_stat_statements`, Performance Schema, AWR/ASH
5) 자동 알람: 스필/락 경합/체크포인트 지연/Redo Flush 지연 임계

**예시: 벤치마크 스냅샷 저장**
```sql
CREATE TABLE if not exists plan_bench (
  id bigserial primary key,
  tag text,
  ts timestamptz default now(),
  plan jsonb
);

-- 앱에서 EXPLAIN 결과를 JSON으로 insert하여 회귀 감시
```

---

## 마이그레이션/리팩터링 절차(안전 가드레일)

1) 논리 모델 점검(3NF/키/관계) → **조인 키 인덱스** 보강
2) 파티셔닝 도입: 키·주기·Drop/Attach 자동화
3) 저장 구조 분리: Temp/WAL/데이터·인덱스 분리
4) 대표 쿼리 커버링 인덱스 설계
5) 클러스터링/정렬 일치 검토
6) 필요 시 **선택적 반정규화**(동기화·검증·롤백 포함)
7) 배포: **읽기 플래그 전환 + 회귀 모니터링**
8) 결과 레포트(지연·IO·스필 변화)

---

## 부록: DBMS별 관찰 지표·명령

- **PostgreSQL**: `EXPLAIN (ANALYZE, BUFFERS)`, `pg_stat_statements`, `pg_locks`, `pg_stat_io`, `wal_compression`, `parallel_*`
- **MySQL/InnoDB**: `EXPLAIN FORMAT=JSON`, Performance Schema, `innodb_buffer_pool_size`, `innodb_flush_log_at_trx_commit`, `OPTIMIZE TABLE`
- **Oracle**: AWR/ASH, `DBMS_STATS`, `/*+ PARALLEL */`, Segment Advisor, Interval Partition, In-Memory Column Store

---

## 결론 — 성능은 구조에서, 구조는 패턴에서

- **정규화→무결성**은 기본값. 성능은 **인덱스·파티션·클러스터링**으로 만든다.
- **저장 구조 분리**(Temp/WAL/데이터)로 I/O 병목을 원천 차단한다.
- 병목이 남으면 **선택적 반정규화**와 **요약 테이블**을 도입하되 **동기화/검증/롤백**을 동반한다.
- 설계와 SQL, 저장과 시스템을 **한 지도**에서 보되, 모든 변경은 **벤치마크→모니터링→회귀 방지**로 닫는다.
