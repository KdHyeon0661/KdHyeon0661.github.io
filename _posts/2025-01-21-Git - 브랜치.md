---
layout: post
title: Git - branch
date: 2025-01-21 19:20:23 +0900
category: Git
---
# Git 브랜치 **생성 및 관리**

## 핵심 개념 요약

- **생성**: `git branch <브랜치명>` 또는 생성과 동시에 전환하는 `git switch -c <브랜치명>`
- **전환**: `git switch <브랜치명>` (또는 `git checkout <브랜치명>`)
- **원격 추적 브랜치 생성**: `git switch -c <로컬브랜치> origin/<원격브랜치>`
- **원격에 푸시 및 추적 연결**: `git push -u origin <브랜치명>`
- **삭제**: `git branch -d <브랜치명>` (로컬, 안전), `git branch -D <브랜치명>` (강제), `git push origin --delete <브랜치명>` (원격)
- **정리**: `git fetch --prune`으로 로컬에서 삭제된 원격 브랜치의 추적 정보를 정리합니다.
- **이름 변경**: `git branch -m <기존이름> <새이름>` (로컬), 이후 원격에도 반영 필요
- **복구**: `git reflog`를 통해 실수로 삭제한 커밋이나 브랜치를 찾아 `git switch -c <새브랜치> <커밋해시>`로 복구
- **동시 작업**: `git worktree add <경로> <브랜치>`로 단일 저장소 내에서 여러 워킹 트리에서 병렬 개발 가능

---

## 브랜치란 무엇인가?

브랜치는 Git에서 개발 흐름을 분리하고 관리하는 핵심 메커니즘입니다. 커밋 히스토리 상의 특정 지점을 가리키는 **이동 가능한 포인터**로, 서로 다른 기능 개발, 실험, 버그 수정 등을 **격리된 환경**에서 진행할 수 있게 해줍니다.

- **기본 브랜치**: 대부분의 저장소는 `main`(이전 `master`) 브랜치를 기본 개발 라인으로 사용합니다.
- **네이밍 관례**: 브랜치 이름은 그 목적을 나타내는 것이 좋습니다. 기능 개발(`feature/`), 버그 수정(`fix/`), 릴리스 준비(`release/`) 등이 일반적입니다.

---

## GitHub 웹 인터페이스에서 브랜치 생성 및 로컬 연동

GitHub 웹사이트에서 브랜치를 생성하는 것은 원격 저장소에 즉시 브랜치를 만드는 간편한 방법입니다.

1.  저장소 페이지에서 좌측 상단의 브랜치 드롭다운을 클릭합니다.
2.  "Find or create a branch..." 입력창에 새 브랜치 이름을 입력하고 "Create branch: <이름>"을 선택합니다.

**중요**: 웹에서 생성된 브랜치는 **원격 저장소에만 존재**합니다. 로컬에서 작업하려면 이를 가져와 로컬 추적 브랜치를 생성해야 합니다.

```bash
# 원격 저장소의 최신 정보를 가져옵니다.
git fetch origin

# 원격 브랜치를 추적하는 로컬 브랜치를 생성하고 해당 브랜치로 전환합니다.
git switch -c <새_브랜치명> origin/<새_브랜치명>
```

---

## 로컬에서 브랜치 생성과 전환하기

### 브랜치만 생성 (현재 브랜치 유지)
```bash
git branch feature/login
```

### 브랜치 생성과 동시에 전환 (최신 권장 방식)
```bash
git switch -c feature/login
```

### 브랜치 생성과 동시에 전환 (전통적인 방식)
```bash
git checkout -b feature/login
```

### 이미 존재하는 브랜치로 전환
```bash
git switch feature/login        # 권장 방식
git checkout feature/login      # 전통 방식
```

### 현재 브랜치 및 상태 확인
```bash
git branch                       # 로컬 브랜치 목록
git branch --show-current        # 현재 브랜치 이름만 출력
git branch -vv                   # 각 브랜치의 상세 상태(원격 추적, ahead/behind) 확인
```

---

## 원격 브랜치와의 협업: 추적 설정

### 원격 브랜치 목록 확인
```bash
git branch -r       # 원격 브랜치만 표시 (예: origin/dev)
git branch -a       # 로컬과 원격 브랜치 모두 표시
```

### 원격 브랜치를 추적하는 로컬 브랜치 생성 및 전환
```bash
git switch -c dev origin/dev
# 또는
git checkout -b dev origin/dev
```
이 명령은 `origin/dev` 브랜치를 추적하는 `dev`라는 이름의 로컬 브랜치를 만들고, 그 브랜치로 전환합니다.

### 새 로컬 브랜치를 원격에 푸시하고 추적 연결 설정
```bash
git push -u origin feature/login
```
`-u`(`--set-upstream`) 옵션은 로컬 `feature/login` 브랜치가 원격 `origin`의 `feature/login` 브랜치를 추적하도록 설정합니다. 이후에는 `git push`나 `git pull` 명령을 간단히 사용할 수 있습니다.

### 기존 로컬 브랜치의 추적 대상을 설정 또는 변경
```bash
git branch --set-upstream-to=origin/dev dev
```

---

## 브랜치 삭제와 정리

### 로컬 브랜치 삭제
```bash
git branch -d feature/login      # 안전 삭제 (브랜치의 변경사항이 다른 브랜치에 병합된 경우만 허용)
git branch -D feature/login      # 강제 삭제 (병합 여부와 관계없이 삭제, 주의 요망)
```

### 원격 브랜치 삭제
```bash
git push origin --delete feature/login
# 또는 구식 문법
git push origin :feature/login
```

### 삭제된 원격 브랜치의 추적 정보 로컬에서 정리
원격에서 브랜치가 삭제된 후, 로컬에는 `origin/feature/login` 같은 추적 정보가 남아 있을 수 있습니다. 이를 정리합니다.
```bash
git fetch --prune
# 또는
git remote prune origin
```

---

## 브랜치 이름 변경하기

### 로컬 브랜치 이름 변경
```bash
git branch -m old-branch-name new-branch-name
# 현재 체크아웃된 브랜치의 이름을 변경할 때는 간단히
git branch -m new-branch-name
```

### 원격 브랜치 이름 변경 (로컬 변경 후 반영)
원격 브랜치의 이름을 직접 변경하는 명령은 없습니다. 새 이름으로 브랜치를 푸시한 후, 기존 이름의 브랜치를 삭제합니다.
```bash
# 1. 로컬 브랜치 이름 변경
git branch -m old-name new-name

# 2. 새 이름으로 원격에 푸시 및 추적 설정
git push -u origin new-name

# 3. 원격의 예전 브랜치 삭제
git push origin --delete old-name
```

### 기본 브랜치 이름 변경 (`master` → `main`)
많은 프로젝트가 기본 브랜치 이름을 `master`에서 `main`으로 변경하고 있습니다.
```bash
# 1. 로컬에서 브랜치 이름 변경
git branch -m master main

# 2. 새 이름으로 원격에 푸시
git push -u origin main

# 3. GitHub 웹 설정에서 'Default branch'를 'main'으로 변경합니다.
# 4. 원래의 'master' 브랜치를 원격에서 삭제
git push origin --delete master

# 5. 팀원들에게 변경 사항을 알리고, 각자의 로컬 환경에서도 동일한 조치를 취하도록 안내합니다.
```

---

## Detached HEAD 상태와 특정 커밋에서 브랜치 생성

### Detached HEAD 상태란?
`git checkout <커밋해시>` 또는 `git checkout <태그>`를 실행하면, HEAD가 특정 브랜치가 아닌 직접 커밋을 가리키는 **Detached HEAD** 상태가 됩니다. 이 상태에서 커밋을 생성하면 나중에 참조하기 어려울 수 있습니다.

### Detached HEAD 상태에서 새 브랜치 생성 (안전한 복구)
Detached HEAD 상태에서 작업한 내용을 잃지 않고 브랜치로 만들려면:
```bash
git switch -c new-branch-name
# 또는
git checkout -b new-branch-name
```
이 명령은 현재 Detached HEAD 상태의 커밋을 기반으로 새 브랜치를 생성하고, 그 브랜치로 전환합니다.

### 특정 태그에서 브랜치 시작하기
```bash
git switch -c patch/1.2.1 v1.2.1
```

---

## 실수 복구: Reflog를 활용한 브랜치/커밋 구출

Git은 모든 HEAD의 이동 기록을 `reflog`에 보관합니다. 실수로 브랜치를 삭제하거나 리셋한 경우, 이를 통해 과거 상태로 되돌릴 수 있습니다.

### reflog 조회
```bash
git reflog
# 출력 예시: 각 행은 HEAD가 이동했던 지점을 보여줍니다 (예: `HEAD@{5}: checkout: moving from main to feature/x`).
```

### reflog를 사용해 브랜치 복구
```bash
# reflog에서 잃어버린 작업의 시점(예: HEAD@{3})을 찾습니다.
git switch -c rescued-branch HEAD@{3}
# 또는 특정 커밋 해시를 알고 있다면
git switch -c rescued-branch a1b2c3d
```

---

## 브랜치 네이밍 규칙

일관된 브랜치 네이밍은 프로젝트 관리와 자동화에 도움이 됩니다. 일반적으로 접두어(Prefix)를 사용합니다.

| 용도 | 예시 | 설명 |
|------|------|------|
| 기능 개발 | `feature/user-auth`, `feature/payment-gateway` | 새로운 기능이나 개선사항을 개발 |
| 버그 수정 | `fix/login-error`, `bugfix/memory-leak` | 버그를 수정 |
| 리팩토링 | `refactor/api-client`, `refactor/database-layer` | 코드 구조 개선 (기능 변경 없음) |
| 실험/유지보수 | `experiment/new-algorithm`, `chore/update-deps` | 실험적 작업 또는 문서, 설정 파일 수정 |
| 릴리스 준비 | `release/v2.0.0`, `release/1.5.1` | 새로운 버전 출시를 위한 최종 준비 |
| 핫픽스 | `hotfix/critical-security-patch` | 프로덕션 환경의 긴급 버그 수정 |
| 운영/인프라 | `ops/ci-pipeline`, `infra/kubernetes-upgrade` | 배포, CI/CD, 인프라 관련 작업 |

팀 내에서 이러한 규칙을 문서화하고, PR 템플릿이나 자동 라벨링 시스템과 연동하면 효율성이 크게 향상됩니다.

---

## 브랜치 정보 파악을 위한 유용한 명령어

```bash
# 각 브랜치의 상세 상태(원격 추적 및 커밋 차이) 확인
git branch -vv

# 현재 브랜치와 추적 중인 원격 브랜치 정보 확인
git status

# 원격 저장소의 최신 정보 동기화 (브랜치 생성/삭제 반영)
git fetch

# 모든 참조(브랜치)와 그들의 업스트림 정보를 포맷팅하여 출력
git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:track)"

# 모든 브랜치의 커밋 히스토리를 그래프로 시각화
git log --oneline --graph --decorate --all

# 두 브랜치 간의 코드 차이 비교
git diff main..feature/login

# 두 브랜치 간에 변경된 파일 목록만 확인
git diff --name-status main..dev
```

---

## Git Worktree를 활용한 동시 작업

하나의 Git 저장소에서 여러 브랜치를 동시에 작업해야 할 때, 저장소를 여러 번 복제(clone)하지 않고도 **별도의 워킹 디렉터리**를 생성할 수 있습니다. 이는 서로 다른 브랜치에서 동시에 개발, 빌드, 테스트를 진행할 때 매우 유용합니다.

```bash
# 현재 저장소와 별도로 '../ui-work' 디렉터리에 'feature/ui' 브랜치를 위한 워킹 트리 생성
git worktree add ../ui-work feature/ui

# 또 다른 브랜치를 위한 워킹 트리 추가 생성
git worktree add ../api-work feature/api

# 생성된 워킹 트리 목록 확인
git worktree list

# 워킹 트리 제거 (워킹 트리 디렉터리 자체는 삭제되지 않음, 수동 삭제 필요)
git worktree remove ../api-work
```

**장점**: 디스크 공간과 네트워크 대역폭을 절약하면서도 완전히 독립된 환경에서 병렬 개발이 가능합니다.

---

## Git 설정과 팀 협업 팁

### Push/Pull 기본 동작 설정
```bash
# push 시 현재 브랜치만 푸시하도록 설정 (권장)
git config --global push.default simple

# pull 시 병합(merge) 대신 리베이스(rebase)를 기본으로 사용할지 설정
git config --global pull.rebase false   # 기본값: 병합
git config --global pull.rebase true    # 리베이스 사용 (주의 필요)
```
**리베이스 주의사항**: 공유 브랜치(예: `main`, `develop`)에서 리베이스는 다른 협업자의 히스토리를 재작성할 위험이 있으므로, 팀 정책을 반드시 확인하세요.

### GitHub 브랜치 보호 규칙
GitHub에서는 웹 인터페이스를 통해 브랜치 보호 규칙을 설정할 수 있습니다.
- **필수 리뷰**: PR 병합 전 최소 리뷰어 수 지정
- **상태 확인**: CI 테스트 등의 성공 여부 확인
- **선형 히스토리 강제**: Merge Commit 방지
- **관리자 예외**: 설정 가능
이러한 규칙은 `main` 같은 중요한 브랜치를 실수로 손상시키는 것을 방지합니다.

---

## 실전 연습 시나리오

### 시나리오 1: 웹에서 생성된 브랜치 로컬에서 사용하기
```bash
# GitHub 웹에서 'new-api' 브랜치를 생성했다고 가정
git fetch origin
git switch -c new-api origin/new-api
# ... 작업 수행 ...
git push -u origin new-api
```

### 시나리오 2: 로컬 브랜치 생성부터 원격 삭제까지
```bash
# 1. 브랜치 생성 및 작업
git switch -c feature/banner
# 파일 수정 및 커밋

# 2. 원격에 푸시 및 추적 설정
git push -u origin feature/banner

# 3. 작업 완료 후 정리
git switch main # 다른 브랜치로 이동
git branch -d feature/banner # 로컬 브랜치 삭제
git push origin --delete feature/banner # 원격 브랜치 삭제
git fetch --prune # 로컬 원격 추적 정보 정리
```

### 시나리오 3: Detached HEAD에서 브랜치 구출
```bash
git checkout a1b2c3d4 # 특정 커밋 체크아웃 (Detached HEAD)
# ... 실험적인 작업 ...
git switch -c experiment/save-point # 작업 내용을 새 브랜치에 저장
```

---

## 트러블슈팅 가이드

| 상황 | 원인 | 해결 방법 |
|------|------|----------|
| `fatal: A branch named 'X' already exists.` | 동일한 이름의 로컬 브랜치가 이미 존재 | 다른 이름 사용 또는 기존 브랜치 삭제/이름 변경 |
| `error: pathspec 'X' did not match any file(s) known to git` | 브랜치 이름 오타 또는 존재하지 않는 브랜치 | `git branch -a`로 존재하는 브랜치 확인, `git fetch origin`으로 원격 정보 동기화 |
| 웹에서 본 브랜치를 로컬에서 체크아웃할 수 없음 | 로컬에 해당 브랜치의 추적 정보가 없음 | `git fetch origin` 후 `git switch -c <이름> origin/<이름>` 실행 |
| 원격에서 삭제한 브랜치가 `git branch -r`에 계속 표시됨 | 로컬의 원격 추적 참조가 오래됨 | `git fetch --prune` 또는 `git remote prune origin` 실행 |
| `git push` 거부됨 | 브랜치 보호 규칙에 위배되거나 업스트림 미설정 | 원격 저장소의 보호 규칙 확인, `git push -u origin <브랜치>`로 처음 푸시 시 추적 설정 |
| 실수로 브랜치 삭제 | `git branch -D` 사용 또는 잘못된 삭제 | `git reflog`로 마지막 커밋 위치를 찾아 `git switch -c <복구브랜치> <커밋해시>` 실행 |
| 브랜치 전환 시 다른 브랜치의 변경사항이 섞임 | 커밋하지 않은 변경사항이나 스태시를 적용하지 않음 | 전환 전 `git status`로 상태 확인, 필요시 `git stash`로 변경사항 임시 저장 |

---

## 결론

Git 브랜치는 현대적인 소프트웨어 개발 워크플로우의 중심에 있습니다. 효과적인 브랜치 관리—생성, 전환, 원격 동기화, 정리, 복구—는 개발 생산성과 코드 품질을 높이는 데 기여합니다.

핵심은 `git switch`/`git checkout` 명령을 정확히 이해하고, `-u` 옵션을 통한 원격 추적 연결을 습관화하며, `git fetch --prune`으로 환경을 깨끗하게 유지하는 것입니다. `git reflog`는 실수를 바로잡을 수 있는 강력한 안전망 역할을 합니다. 또한, `git worktree`는 복잡한 병렬 개발 시나리오에서 유용한 도구가 될 수 있습니다.

팀으로 협업할 때는 브랜치 네이밍 규칙, 수명 주기(생성 → PR → 병합 → 삭제), 그리고 GitHub의 브랜치 보호 규칙을 함께 정의하고 따르는 것이 중요합니다. 이러한 표준화된 접근 방식은 프로젝트의 일관성과 안정성을 보장하며, 모든 구성원이 효율적으로 기여할 수 있는 토대를 마련해 줍니다.
