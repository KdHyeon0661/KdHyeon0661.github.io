---
layout: post
title: Git - branch
date: 2025-01-21 19:20:23 +0900
category: Git
---
# Git 브랜치 **생성 및 관리**

## 0. 한눈에 보는 요약(핵심만)

- **생성**: `git branch feature/x` 또는 `git switch -c feature/x`  
- **전환**: `git switch feature/x` (또는 `git checkout feature/x`)  
- **원격 추적 브랜치 만들기**: `git switch -c dev origin/dev`  
- **푸시와 추적 연결**: `git push -u origin feature/x`  
- **삭제(로컬/원격)**: `git branch -d|-D feature/x`, `git push origin --delete feature/x`  
- **정리**: `git fetch --prune`, `git remote prune origin`, `git branch -vv`  
- **리네임**: `git branch -m old new` (원격도 교체 필요)  
- **복구**: `git reflog`, `git switch -c rescue <커밋>`  
- **동시 작업**: `git worktree add ../repo-ui feature/ui`

---

## 1. 브랜치란? (기존 설명 보강)

브랜치는 커밋 그래프의 **이동 포인터(참조)** 로, 서로 다른 실험/기능을 **격리**해 개발합니다.  
- 기본 브랜치: `main`(또는 `master`)  
- 관례상 기능/버그/릴리스/핫픽스 등 **목적별 네이밍**을 사용합니다(표는 §9 참조).

---

## 2. GitHub(웹)에서 브랜치 생성 (기존 + 주의점)

1. 저장소 접속 → 좌상단 브랜치 셀렉터에서 `Create branch: new-name`  
2. 웹에서 생성한 브랜치는 **서버(원격)** 에만 존재  
3. 로컬에서 사용하려면 **가져와서 추적**해야 합니다:
```bash
git fetch origin
git switch -c new-name origin/new-name
# 또는
git checkout -b new-name origin/new-name
```

---

## 3. 로컬에서 브랜치 생성과 전환 (switch vs checkout)

### 3.1 생성만(전환 없음)
```bash
git branch feature/login
```

### 3.2 생성과 동시에 전환
```bash
# 최신 권장
git switch -c feature/login

# 기존 방식
git checkout -b feature/login
```

### 3.3 전환만
```bash
git switch feature/login        # 권장
# 또는
git checkout feature/login
```

### 3.4 현재 브랜치 확인
```bash
git branch
git branch --show-current
git branch -vv                  # 원격 추적 상태/앞뒤 카운트
```

---

## 4. 원격 브랜치 사용과 “추적 브랜치” 설정

### 4.1 원격 브랜치 목록
```bash
git branch -r       # origin/dev, origin/release/1.2 등
git branch -a       # 로컬+원격 모두
```

### 4.2 원격을 **추적하는** 로컬 브랜치 생성
```bash
git switch -c dev origin/dev
# 또는
git checkout -b dev origin/dev
```

### 4.3 새 로컬 브랜치를 원격에 **업로드**(추적 연결까지)
```bash
git push -u origin feature/login
# 이후에는:
git push
git pull            # 자동으로 origin/feature/login 추적
```

### 4.4 기존 브랜치에 **upstream(추적 대상)** 설정/변경
```bash
# 현재 브랜치를 origin/dev 추적으로 묶기
git branch --set-upstream-to=origin/dev

# 한 줄로 push + 추적 연결
git push -u origin dev
```

---

## 5. 브랜치 삭제(로컬/원격) — 안전/강제

### 5.1 로컬 삭제
```bash
git branch -d feature/login      # 병합된 경우만 삭제(안전)
git branch -D feature/login      # 강제 삭제(주의)
```

### 5.2 원격 삭제
```bash
git push origin --delete feature/login
# 구버전 호환:
git push origin :feature/login
```

### 5.3 삭제 후 로컬의 “원격 추적 참조” 정리
```bash
git fetch --prune
# 또는
git remote prune origin
```

---

## 6. 브랜치 **리네임(이름 변경)** — 로컬/원격/기본 브랜치

### 6.1 로컬 브랜치 이름 변경
```bash
git branch -m old-name new-name
# 현재 브랜치를 바꿀 때는 -m new-name 만 써도 됨
```

### 6.2 원격에도 반영
```bash
# 새 이름으로 push + 추적 연결
git push -u origin new-name

# 원격의 옛 이름 삭제
git push origin --delete old-name
```

### 6.3 **기본 브랜치(main)** 이름 변경(로컬 → 원격)
```bash
# 1. 로컬에서
git branch -m master main

# 2. 원격 새 이름 push
git push -u origin main

# 3. GitHub에서 기본 브랜치(Default branch)를 main으로 변경(웹 설정)
# 4. 필요 시 보호 규칙(branch protection)도 main으로 재설정
# 5. 팀원들에게 pull/rebase 대상 변경 안내
```

---

## 7. “detached HEAD”와 특정 커밋/태그에서 브랜치 만들기

### 7.1 detached HEAD 진입(예시)
```bash
git checkout <커밋SHA>    # 또는 태그
# 현재 HEAD는 브랜치를 가리키지 않음(임시 상태)
```

### 7.2 여기서 **새 브랜치로 구출**
```bash
git switch -c hotfix/urgent
# 또는
git checkout -b hotfix/urgent
```

### 7.3 태그에서 시작
```bash
git switch -c patch/1.2.1 v1.2.1
```

---

## 8. 실수/사고 복구: 삭제/리셋 이후 **reflog**로 구출

### 8.1 마지막 커밋/브랜치 위치 찾기
```bash
git reflog
# 예시: HEAD@{5} 2시간 전 상태
```

### 8.2 잃어버린 작업을 **새 브랜치**로 살리기
```bash
git switch -c rescue HEAD@{5}
# 또는 커밋 해시로:
git switch -c rescue <sha>
```

### 8.3 강제 삭제로 날린 브랜치 복원(가능한 경우)
- 해당 브랜치의 tip 커밋을 reflog에서 찾아 `switch -c`  
- 로컬 GC가 돌기 전에 빠르게 조치

---

## 9. 브랜치 **네이밍 규칙**(확장)

| 용도        | 예시                                   | 설명 |
|-------------|----------------------------------------|------|
| 기능        | `feature/login`, `feature/profile-edit` | 기능 단위 개발 |
| 버그        | `bugfix/image-crash`, `fix/null-ref`    | 이슈/버그 해결 |
| 리팩터링    | `refactor/http-client`                  | 구조 개선 |
| 실험        | `exp/new-cache`, `chore/lint`           | 실험/잡무 |
| 릴리스      | `release/v1.2.0`                        | 릴리스 준비 |
| 핫픽스      | `hotfix/critical-npe`                   | 긴급 패치 |
| 환경/데브옵스 | `ops/ci-cache`, `infra/auth-proxy`      | 인프라/CI |

> 팀에서 규칙을 문서화하고, PR 템플릿과 함께 사용하면 가독성과 자동화(라벨링)에 유리합니다.

---

## 10. 브랜치 상태/차이/앞뒤(ahead/behind) 파악 도구

```bash
git branch -vv                       # 추적 상태와 ahead/behind
git status                           # 현재 브랜치/추적 정보
git fetch                            # 최신 참조 동기화
git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:track)"
git log --oneline --graph --decorate --all
git diff main..feature/login         # 두 브랜치 사이 diff
git diff --name-status main..dev     # 변경 파일 목록
```

---

## 11. 원격 브랜치 **정리(prune)**와 추적 교체

### 11.1 사라진 원격 브랜치 흔적 지우기
```bash
git fetch --prune
# 또는
git remote prune origin
```

### 11.2 추적 대상 바꾸기(브랜치가 옮겨졌을 때)
```bash
git branch --set-upstream-to=origin/new-dev dev
```

---

## 12. push/pull 기본 동작 파라미터(팀 표준화)

```bash
# push: 현재 브랜치만(권장)
git config --global push.default simple

# pull 기본은 merge지만, 개인 선호로 rebase도 가능(공유 브랜치 주의)
git config --global pull.rebase false   # 기본
# 또는
git config --global pull.rebase true
```

> 팀 정책에 맞춰 표준화하세요. 공유 브랜치에서 rebase는 이력 재작성 문제를 유발할 수 있습니다.

---

## 13. 동시 작업을 위한 **worktree** (1 리포에서 다중 워킹트리)

여러 브랜치를 동시에 체크아웃해야 할 때, 리포 복제 없이 **추가 워킹트리**를 만듭니다.

```bash
# 현재 리포에서 다른 폴더에 브랜치용 worktree 추가
git worktree add ../repo-ui feature/ui
git worktree add ../repo-api feature/api

# 목록 확인/제거
git worktree list
git worktree remove ../repo-api
```

장점: 디스크/네트워크 낭비 없이 **병렬 개발** 가능.

---

## 14. GitHub 보호 브랜치(웹 설정) — merge 없이도 알아야 하는 운영 팁

- **Default branch**: `Settings → Branches → Default branch`  
- **Branch protection rules**: force push 금지, 필수 리뷰/체크, 선형 이력 요구 등  
- 브랜치 삭제 방지/승인 조건 지정으로 운영사고 예방  
- 브랜치 네이밍 패턴(예: `release/*`)에 규칙을 걸어 자동 보호

> 로컬에서 브랜치 생성/전환/삭제를 다뤄도, 원격 정책이 막으면 push가 거절될 수 있습니다.

---

## 15. 완전 재현 가능한 미니 시나리오 (merge 없음)

### 15.1 “웹에서 브랜치 만들어 로컬로 가져다 쓰기”
```bash
# 웹에서 new-api 브랜치 생성했다고 가정
git fetch origin
git switch -c new-api origin/new-api
# 작업 후
git push -u origin new-api
```

### 15.2 “로컬에서 기능 브랜치 생성 → 원격 업로드 → 삭제”
```bash
git switch -c feature/banner
# 파일 수정/커밋
git push -u origin feature/banner
# 작업 종료 후 로컬/원격 삭제
git branch -d feature/banner
git push origin --delete feature/banner
git fetch --prune
```

### 15.3 “브랜치 이름 바꾸기(main 전환 포함, merge 불개입)”
```bash
# 현재 master라고 가정
git branch -m master main
git push -u origin main
# 웹에서 Default branch를 main으로 바꾸고
# 예전 원격 참조 제거
git push origin --delete master
```

### 15.4 “detached HEAD에서 브랜치로 구출”
```bash
git checkout <임의커밋>
# 작업 시험
git switch -c rescue/experiment
# 이제 안전한 분기에서 계속
```

### 15.5 “원격에만 있는 브랜치로 로컬 추적 시작”
```bash
git fetch origin
git switch -c release/1.3 origin/release/1.3
```

### 15.6 “사라진 원격 브랜치 흔적 정리”
```bash
git fetch --prune
git branch -r
git branch -vv
```

---

## 16. 트러블슈팅 (상황 → 원인 → 해결)

| 상황/증상 | 원인 | 해결 |
|---|---|---|
| `fatal: A branch named 'X' already exists.` | 같은 이름의 로컬 브랜치 존재 | 다른 이름 사용 또는 기존 브랜치 삭제/리네임 |
| `error: pathspec 'X' did not match any file(s) known to git` | 해당 브랜치/참조가 없음 | `git fetch origin`, 이름 재확인, `git branch -a` 확인 |
| 원격에 브랜치 보이는데 로컬 전환 실패 | 추적 브랜치 미생성 | `git switch -c X origin/X` |
| 삭제했는데 목록에 계속 표시 | 원격 추적 참조 잔존 | `git fetch --prune` 또는 `git remote prune origin` |
| push 거부 | 보호 브랜치 정책 또는 Upstream 미설정 | 원격 정책 확인, `git push -u origin X` |
| 실수로 브랜치 삭제 | 강제 삭제/정리 | `git reflog`로 커밋 찾고 `git switch -c rescue <sha>` |
| 다른 브랜치 변경이 섞임 | 전환 전 커밋/스태시 누락 | 브랜치 전환 전 `git status`, 필요 시 `git stash` 사용 |
| detached HEAD 경고 | 브랜치 아닌 커밋에 체크아웃 | 작업 후 `git switch -c <name>`로 구출 |

---

## 17. 팀 운영 팁(merge 없이도 유효)

- “작업 전환”은 **작업 단위 커밋 후** 수행(미커밋/미스태시 변경은 섞임 위험)  
- 브랜치 수명주기: **생성 → 작업 → 리뷰(PR) → 종료 후 삭제**를 표준화  
- **`git branch -vv`** 로 추적/앞뒤 상태를 주기적으로 점검  
- 주간 청소: `git fetch --prune` + 오래된 로컬 브랜치 정리  
- 기본 브랜치(main) 변경/보호 규칙은 **문서화**하고 팀에 공지

---

## 18. 자주 쓰는 명령어(치트시트, 확장판)

```bash
# 생성/전환
git branch <name>
git switch -c <name>
git switch <name>
git checkout -b <name>
git checkout <name>

# 원격 브랜치 추적
git branch -r
git switch -c <local> origin/<remote>
git push -u origin <name>
git branch --set-upstream-to=origin/<remote> <local>

# 조회/상태
git branch
git branch -a
git branch -vv
git status
git fetch --prune
git remote prune origin

# 삭제/리네임
git branch -d <name>
git branch -D <name>
git push origin --delete <name>
git branch -m <old> <new>
git push -u origin <new>
git push origin --delete <old>

# 복구
git reflog
git switch -c rescue <sha_or_HEAD@{n}>

# worktree
git worktree add ../path <branch>
git worktree list
git worktree remove ../path
```

---

## 19. 실습 과제(오프라인 재현 루틴)

```bash
# 1. 새 레포
mkdir branch-lab && cd branch-lab
git init
echo "root" > readme.md
git add . && git commit -m "init"

# 2. 기능 브랜치 생성/전환
git switch -c feature/a
echo "A1" >> readme.md
git commit -am "feat(a): A1"

# 3. 기본으로 돌아갔다가 다시 전환
git switch -    # 직전 브랜치로 토글
git switch -    # (토글 반복)

# 4. 브랜치 리네임
git branch -m feature/a feature/login

# 5. 임의 커밋에서 브랜치 만들기
echo "temp" >> temp.txt
git add . && git commit -m "temp commit"
git checkout HEAD~1          # detached
git switch -c rescue/from-old

# 6. 정리
git switch main
git branch -d feature/login
git branch -D rescue/from-old
```

---

## 20. 결론

- 브랜치는 **격리·전환·정리·복구** 관점에서 관리해야 실수가 줄고 속도가 납니다.  
- `switch`, 추적 설정(`-u`/`--set-upstream-to`), 정리(`--prune`), 리네임, reflog 복구, worktree 병렬 운영까지 숙지하면 **merge가 등장하기 전 단계**의 생산성이 크게 올라갑니다.  
- 팀에서는 **네이밍/수명주기/보호 규칙**을 문서화하고 자동화(템플릿·규칙)로 일관성을 유지하세요.

---

## 참고

- Git 공식 문서(브랜치): https://git-scm.com/docs/git-branch  
- Git 공식 문서(체크아웃/스위치): https://git-scm.com/docs/git-switch , https://git-scm.com/docs/git-checkout  
- GitHub 브랜치 가이드: https://docs.github.com/en/get-started/quickstart/github-flow