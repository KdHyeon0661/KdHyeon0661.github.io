---
layout: post
title: 컴퓨터시스템 - 가비지 컬렉션
date: 2025-08-24 18:20:23 +0900
category: 컴퓨터시스템
---
# 가비지 컬렉션(Garbage Collection)

## 0. 큰 지도 — 무엇을 얻고 무엇을 치를까

목표 | 이점 | 대가(트레이드오프) | 대표 기술
---|---|---|---
메모리 안전/생산성 | UAF/이중해제 방지, 개발 단순 | STW 일시정지, 추가 CPU/메모리 | 마크/스윕·압축·복사
저지연 | p99 정지시간 축소 | 읽기/쓰기 배리어 오버헤드 | Tri-color, SATB, ZGC/Shenandoah
고처리량 | 스루풋↑ | 긴 Full GC 가능 | Parallel/Region(여러 코어)
낮은 풋프린트 | 힙↓ | 단편화/재배치 비용↑ | 압축(compact), region compaction

**핵심 지표**
- **Throughput**(처리량), **Latency**(정지시간), **Footprint**(메모리), **Mutator Utilization**:
  $$
  U=\frac{T_{\text{mutator}}}{T_{\text{mutator}}+T_{\text{GC}}}\approx \frac{1}{1+r/g}
  $$
  여기서 \(r\)=할당률(MB/s), \(g\)=유효 회수 속도(MB/s).

---

## 1. 기본 개념 — 루트·객체 그래프·도달성

- **루트**: 스택/레지스터, 전역/정적, JIT/인터프리터 내부 루트.
- **도달성**: 루트에서 필드 참조를 따라 도달 가능하면 “살아있음”.
- **정밀(precise)** vs **보수(conservative)**: 포인터 위치를 정확히 아는가(스택맵/타입정보) 여부.

간단 그림
```
[Roots] -> ObjA -> ObjB
         -> ObjC    ObjD (도달X → 회수)
```

---

## 2. 추적형(Tracing) 알고리즘

### 2.1 Mark–Sweep (마크/스윕)
- **마크**: 루트에서 DFS/BFS로 방문 표시 →
- **스윕**: 힙 선형 스캔하며 미마크 블록을 자유리스트로 반환.
- **장점**: 구현 단순, 추가 공간 작음. **단점**: 외부 단편화 남음.

```pseudo
mark(roots):
  W ← roots
  while W not empty:
    o ← pop(W)
    if !marked(o):
      mark(o)
      for c in children(o): push(W, c)

sweep(heap):
  for block in heap:
    if marked(block) clear_mark(block)
    else free_list.add(block)
```

### 2.2 Mark–Compact (슬라이딩 압축)
- 마크 후 **살아있는 객체를 앞으로 압축**하여 단편화 제거.
- 포인터 재설정(포워딩 포인터/두 단계 패스) 필요.
- 장점: **bump-pointer** 할당 가능, 대형 할당 성공률↑.

### 2.3 Copying(Semispace, Cheney)
- from/to 두 공간. 살아있는 것만 to로 복사→역할 스왑.
- 장점: 단편화 0, 매우 빠른 선형 할당. 단점: 메모리 2× 오버헤드.

---

## 3. 세대별(Generational) — “대부분은 빨리 죽는다”

- 힙을 **Young(Eden + Survivor)** / **Old** 로 구분.
- **Minor GC**: Young만, 살아남으면 S0↔S1 복사, 임계 생존 횟수 도달 시 Old 승격.
- **Major/Full GC**: Old 포함.
- **Remembered Set/Card Table**: Old→Young 참조를 추적하여 Minor 시 Young만 스캔.

작동 스케치
```
[Eden] --minor--> [S0] --minor--> [S1] --tenure--> [Old]
```

튜닝 포인트(언어 공통 감각)
- Young 크기: 너무 작으면 Minor 빈발, 너무 크면 각 패스 지연.
- 승격 임계: “중간 수명” 객체의 불필요 승격 방지.

---

## 4. 저지연을 위한 Tri-Color & 배리어

### 4.1 Tri-Color 불변식
- **White**(미방문=수집 후보), **Gray**(자식 미처리), **Black**(자식 처리 완료).
- **불변식**: *Black → White* 직접 참조 금지(있다면 White를 Gray로 “끌어올려야” 함).

### 4.2 배리어(barrier)
- **Write barrier**
  - *Incremental Update*(Dijkstra): 새로 저장되는 참조의 대상 White를 Gray로.
  - *SATB*(Snapshot-At-The-Beginning, G1 등): “스냅샷” 시점 직후 **지워지는** 오래된 참조의 **소스**를 Gray로.
- **Read barrier**
  - 로드시 인디렉션/색 검사(ZGC/Shenandoah). 이동 중인 객체를 안전히 참조.

### 4.3 Incremental vs Concurrent
- **Incremental**: STW를 여러 조각으로 분할(배리어로 불변식 유지).
- **Concurrent**: 마킹 대부분을 mutator와 **병행**. **이동(압축)**은 읽기 배리어를 써서 동시 진행하거나 짧은 STW로 마무리.

---

## 5. 현대 수집기 스냅샷

유형 | 대표 | 핵심
---|---|---
Parallel Mark-Sweep/Compact | HotSpot Parallel | 고처리량(STW 길 수 있음)
G1(Region) | HotSpot G1 | 균일 region, **선택적 수집**, SATB write barrier
Shenandoah | HotSpot | **동시(compacting) 이동**, read barrier
ZGC | HotSpot | **colored pointer + load barrier**, p99 수 ms 수준 지향
CLR Server/Workstation | .NET | 세대별 + 백그라운드, LOH 경로
Go GC | Go | 동시 마킹 + 점진 스윕(비이동 힙), 저지연 지향
CPython | Python | refcount + cycle collector(백그라운드)

> 용어 메모: **Humongous/LOH**(대형 객체)는 별 경로로 관리되며 압축/이동 제외되는 경우가 많다.

---

## 6. 할당 Fast Path — bump, TLAB, 슬랩

- **Bump-Pointer**: 포인터만 전진 → O(1) 할당.
- **TLAB(Thread-Local Allocation Buffer)**: 스레드 로컬 영역에서 락 없이 할당.
- **슬랩/클래스**: 크기별 블록 풀로 내부 단편화·메타데이터 오버헤드 최소화.

---

## 7. 참조와 파이널라이저

종류 | 의미 | 전형적 용도
---|---|---
Strong | 평범한 참조 | 라이브 유지
Weak | 참조만으로는 생존 X | 캐시 키/값
Soft | 메모리 압박 시 회수 | 메모리 민감 캐시
Phantom | 수집 후 큐로 알림 | 리소스 정리 예약

- **Finalizer**/소멸자는 비결정적·순서 불명·부활 위험 → **명시적 close/RAII** 권장.

---

## 8. 레퍼런스 카운팅(RC)과 하이브리드

- 장점: 즉시성(Deterministic), 단점: **순환(cycle)**.
- **CPython**: RC + 주기적 cycle GC. **Swift**: ARC(컴파일러 삽입) + 약한 참조로 보완.

순환 예
```c
// 둘만 서로 참조하면 외부에서 끊어도 살아남음 → RC>0
a->next = b; b->next = a;
```

---

## 9. 스택 스캔·세이프포인트·스택맵

- **Safepoint**: 스레드가 STW에 협조하는 체크 지점(호출/분기/폴링).
- **Stack Map**: 프레임별 포인터 위치 정보(정밀 GC 필수).
- JIT는 배리어/세이프포인트/스택맵을 코드에 삽입.

---

## 10. 단편화와 압축 전략

문제 | 원인 | 대책
---|---|---
외부 단편화 | 자유 블록 쪼개짐 | **압축(compact)**, 복사 수집
내부 단편화 | 정렬/헤더/클래스 오버헤드 | 크기 클래스/슬랩 조정
지역성 저하 | 마킹 순회 랜덤 터치 | Region/Line 스캔, prefetch, 순회 순서 최적화

---

## 11. OS/하드웨어 상호작용

- **가상 메모리**: 페이지 터치 → TLB/캐시 영향.
- **NUMA**: first-touch, Young/Old를 노드별 배치.
- **Huge Page**: DTLB 미스↓ ↔ 내부 단편화↑.
- **메모리 압축/스와핑**이 GC와 상호작용(압박 시 STW/LRU 불리).

---

## 12. 수학적 직감 — 언제 GC가 버거워지나

- 할당률 \(r\) 과 수집기의 유효 처리량 \(g\) 비교.
- 평균 mutator 이용률:
  $$
  U \approx \frac{1}{1+r/g}
  $$
- p99 정지시간 \(L\) 목표가 있을 때, region 크기 \(R\) 과 *한 패스당 처리량* \(\rho\) 로
  $$ L \approx \frac{k\cdot R}{\rho} \quad (\text{상수 }k:\ \text{배리어/메타비용}) $$
  → \(R\)을 줄이거나 \(\rho\)를 올리면 p99 감소.

---

## 13. 진단/튜닝 — 공통 전략

### 13.1 절차
1) **목표** 정의: 처리량 vs p99/p999 정지시간.
2) **계측**: 할당률(MB/s), 라이브셋 크기(peak live), 객체 수명 분포.
3) **가설**: Young/Old/Region·승격·배리어 비용 중 병목 가정.
4) **실험**: 한 번에 하나만 바꾸고 장시간 워크로드로 관찰.
5) **회귀 방지**: GC 로그·메트릭을 CI에 포함.

### 13.2 흔한 지렛대
- **객체 수명 줄이기**(풀/슬라이스, in-place 변환).
- **중간 객체 줄이기**(박싱 최소화, 불변 객체 재사용).
- **Young 확대**(Minor 빈도↓) vs **승격 임계↑**(Old 오염↓).
- **대형 객체 분리 경로**(Humongous/LOH).
- **NUMA 바인딩**(TLAB/region 할당의 노드 일관성).

---

## 14. 언어별 실전 메모

### 14.1 Java/HotSpot
- **옵션 예**
  ```bash
  # 로그/지표
  java -Xlog:gc*:file=gc.log:tags,uptime,level,timestamps
  jstat -gcutil <pid> 1s

  # 수집기 선택
  -XX:+UseG1GC            # 기본(신버전)
  -XX:+UseZGC             # 초저지연
  -XX:+UseShenandoahGC    # 저지연

  # 튜닝 힌트
  -XX:MaxGCPauseMillis=50       # 목표 정지시간(G1)
  -XX:InitiatingHeapOccupancyPercent=35  # concurrent 시작 임계
  -XX:+AlwaysPreTouch           # 힙 사전 터치(TLB/NUMA)
  ```
- **패턴**
  - 짧은 생명은 Eden→Survivor를 **빨리 통과**.
  - Old→Young 참조를 최소화(카드 오염↓).

### 14.2 .NET
- `Server GC`(다중 코어), `Workstation GC`(데스크톱), **Background GC**.
- LOH(대형 객체 힙) 압축 가능 버전 확인.
- 진단: `dotnet-counters monitor System.Runtime`, ETW/PerfView.

### 14.3 Go
- 목표: 저지연 동시 마킹·점진 스윕.
- `GOGC=100`(디폴트, 힙 성장 허용률), 숫자↑ → GC 빈도↓(힙↑).
- 진단: `GODEBUG=gctrace=1`, `pprof` 힙/할당.

---

## 15. 미니 예제(관찰용)

### 15.1 Java: 생명주기 관찰
```java
// javac GcDemo.java && java -Xms512m -Xmx512m -Xlog:gc*:stdout GcDemo
import java.util.*;
public class GcDemo {
  static final int N = 2000;
  public static void main(String[] a){
    List<byte[]> keep = new ArrayList<>();
    for (int i=0;i<1000;i++){
      byte[] eden = new byte[1024*256]; // 256KB
      if (i%N==0) keep.add(new byte[1024*1024]); // Old 오염 유도
    }
    System.gc(); // 강제 Full GC (관찰용)
    System.out.println("done");
  }
}
```
- 로그에서 **Minor/Full**, 승격, region 처리량을 확인.

### 15.2 Go: GOGC 영향 보기
```go
// GOGC=50 go run main.go  (더 자주 GC) / GOGC=200 (적게)
package main
import "time"
func main(){
  for {
    _ = make([]byte, 1<<20) // 1MB
    time.Sleep(5 * time.Millisecond)
  }
}
```

---

## 16. 배리어 구현 감각

### 16.1 카드 마킹(Write Barrier) 스케치
```c
// p->field = q; 를 수행할 때
p->field = q;
CARD_TABLE[((uintptr_t)p) >> CARD_SHIFT] = DIRTY; // 변경된 카드 표시
```

### 16.2 SATB(스냅샷 시작 시점 유지) 예시
```c
// 필드 갱신 전 오래된 참조 old를 큐에 보관
enqueue_if_white(old);
p->field = new;
```

### 16.3 Read Barrier(개념)
```c
// 로드 시 포인터의 '색' 검사 → 이동 중이면 포워딩 주소로 재매핑
o = load(ptr);
if (colored(o) == MOVING) o = remap(o);
```

---

## 17. 안티패턴 & 함정

- **파이널라이저에 동기 I/O/락/네트워크** 넣기(정지시간·교착 유발).
- **중간 컬렉션 남발**(스트림/박싱 객체 대량 생성).
- **대형 배열/문자열 반복 재할당**(복사 비용 + humongous 오염).
- **NUMA 무시**(원격 메모리).
- **사일런트 누수**(전역 캐시/정적 맵/리스너 미해제).
- **언어 간 브리지**(JNI/PInvoke)에서 비관리 리소스 누수.

---

## 18. 토이 수집기(학습용) — 반 공간 복사 의사코드

```pseudo
// from / to 두 세미스페이스, 루트 집합은 포인터 배열
copy_gc(roots):
  to_start ← to_space.start; scan ← to_start
  for r in roots:
    r ← copy_obj(*r)      // 루트 복사
  while scan < to_free:   // Cheney scan
    for each ref in fields(scan):
      ref ← copy_obj(*ref)
    scan ← next_object(scan)
  swap(from_space, to_space)

copy_obj(x):
  if x == NULL: return NULL
  if x.forwarding != NULL: return x.forwarding
  y ← allocate_in_to(x.size)
  memcpy(y, x, x.size)
  x.forwarding = y
  return y
```
- **장점**: 단편화 없음, 선형 할당. **한계**: 2× 공간.

---

## 19. 체크리스트

- [ ] p99/p999 **정지시간 목표**를 수치로 정의
- [ ] 할당률·라이브셋 **실측**
- [ ] Young/Old/Region **크기/승격 임계** 근거 설정
- [ ] Old→Young 참조 최소화(카드 오염↓)
- [ ] 대형 객체 경로 분리/최적화
- [ ] NUMA/huge page 전략 점검
- [ ] GC 로그를 수집·대시보드화
- [ ] 파이널라이저 의존 최소/명시적 해제

---

## 20. 결론

가비지 컬렉션은 **도달성 기반 자동 메모리 관리**이자, **지연·처리량·풋프린트** 사이의 공학적 균형 문제다.
알고리즘(마크/압축/복사/세대별/동시), 불변식(트라이컬러)과 장치(배리어/스택맵/TLAB),
그리고 운영(로그/프로파일/튜닝)을 함께 보라. 그러면 **안전성과 성능**을 동시에 얻을 수 있다.
