---
layout: post
title: DB 심화 - I/O 효율화
date: 2025-11-04 23:25:23 +0900
category: DB 심화
---
# I/O 효율화 체크리스트 (Oracle 중심, 실무 예제·진단 스니펫 포함)

> 목표: **필요한 최소 블록만 읽고(write 포함), 불필요한 왕복과 I/O 대기를 제거**한다.  
> 방법: **쿼리 구조 → 통계/옵티마이저 팩터 → 액세스 경로 → 실행 중 계측** 순으로 점검한다.

---

## 0) 준비: 샘플 스키마 & 공통 진단 스니펫

```sql
-- (옵션) 데모용 테이블
CREATE TABLE customers (
  cust_id    NUMBER PRIMARY KEY,
  region     VARCHAR2(8),
  grade      VARCHAR2(8),
  created_at DATE,
  name       VARCHAR2(60)
);

CREATE TABLE orders (
  order_id   NUMBER PRIMARY KEY,
  cust_id    NUMBER NOT NULL,
  order_dt   DATE   NOT NULL,
  status     VARCHAR2(8),
  amount     NUMBER(12,2)
);

CREATE INDEX ix_cust_rg_gr ON customers(region, grade, cust_id);
CREATE INDEX ix_orders_cust_dt ON orders(cust_id, order_dt DESC, order_id DESC);

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS',cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/

-- (공통) 실행 후 실제 수행통계
ALTER SESSION SET statistics_level = ALL;

SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +MEMSTATS'));

-- SQL I/O 요약
SELECT sql_id, plan_hash_value, executions,
       buffer_gets, disk_reads,
       ROUND(buffer_gets/NULLIF(executions,0)) avg_lio,
       ROUND(disk_reads/NULLIF(executions,0))  avg_pio
FROM   v$sql
WHERE  sql_text LIKE 'SELECT%'
ORDER  BY avg_pio DESC FETCH FIRST 30 ROWS ONLY;

-- 최근 10분 I/O 대기
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
AND    session_type='FOREGROUND'
AND    event IN ('db file sequential read','db file scattered read',
                 'direct path read','direct path read temp',
                 'direct path write','direct path write temp')
GROUP  BY event ORDER BY samples DESC;
```

---

## 1) 쿼리 구조 체크리스트 — “필요한 최소 블록만 읽는가?”

- [ ] **SARGable**(인덱스 사용 가능) 표현인가?
  - 나쁜 예:
    ```sql
    SELECT COUNT(*) FROM orders
    WHERE TRUNC(order_dt) = DATE '2025-10-01';
    ```
  - 개선:
    ```sql
    SELECT COUNT(*) FROM orders
    WHERE order_dt >= DATE '2025-10-01'
      AND order_dt <  DATE '2025-10-02';
    ```
- [ ] **조기 필터링**(선택도 높은 조건을 먼저 적용)로 입력 로우를 대폭 축소했는가?
  ```sql
  WITH cand AS (
    SELECT /*+ index(c ix_cust_rg_gr) */ cust_id
    FROM   customers c
    WHERE  c.region=:r AND c.grade=:g
  )
  SELECT /*+ leading(cand o) use_hash(o) */
         o.cust_id, COUNT(*)
  FROM   cand JOIN orders o ON o.cust_id=cand.cust_id
  WHERE  o.order_dt >= SYSDATE-7
  GROUP  BY o.cust_id;
  ```
- [ ] **존재성 확인**은 `EXISTS/NOT EXISTS`(세미/안티 조인)로 했는가?
  ```sql
  -- 존재만 확인: COUNT(*) 대신 EXISTS
  SELECT /*+ first_rows(1) */ o.order_id
  FROM   orders o
  WHERE  EXISTS (SELECT 1 FROM order_items oi WHERE oi.order_id=o.order_id)
  FETCH FIRST 1 ROW ONLY;
  ```
- [ ] **Top-N/Stopkey** 또는 **Keyset 페이징**으로 정렬 회피·앞부분만 읽는가?
  ```sql
  -- Keyset: 마지막 키로 이어받기
  SELECT /*+ index(o ix_orders_cust_dt) */ order_id, order_dt, amount
  FROM   orders o
  WHERE  o.cust_id = :cust
    AND (o.order_dt < :last_dt OR (o.order_dt=:last_dt AND o.order_id<:last_id))
  ORDER  BY o.order_dt DESC, o.order_id DESC
  FETCH FIRST 50 ROWS ONLY;
  ```
- [ ] **파티션 프루닝** 100% 동작하는가(타입/표현 일치)?
  ```sql
  SELECT COUNT(*) FROM orders
  WHERE order_dt >= DATE '2025-10-01'
    AND order_dt <  DATE '2025-11-01';  -- 월 파티션 프루닝 유도
  ```

**미니 점검 지표**  
- `DBMS_XPLAN` 의 `Buffers`, `Reads`, `A-Rows`를 비교해 **불필요 블록 감소** 여부를 확인.

---

## 2) 인덱스·액세스 경로 체크리스트 — “랜덤 방문과 전체 스캔을 최소화했는가?”

- [ ] **정렬 일치 인덱스** + **커버링 인덱스**로 테이블 방문 제거 가능한가?
  ```sql
  -- (cust_id, order_dt desc, order_id desc) 인덱스로 커버링
  SELECT /*+ index(o ix_orders_cust_dt) */ o.order_id,o.order_dt,o.amount
  FROM   orders o
  WHERE  o.cust_id=:cust AND o.order_dt>=SYSDATE-7
  ORDER  BY o.order_dt DESC, o.order_id DESC
  FETCH FIRST 50 ROWS ONLY;  -- 테이블 무방문 가능
  ```
- [ ] **클러스터링 팩터**(CF)가 좋도록 물리 정렬/인덱스 설계를 맞췄는가?
  ```sql
  -- 물리 재적재(CTAS) → 인덱스 재생성 → 통계 갱신
  CREATE TABLE orders_sorted NOLOGGING AS
  SELECT * FROM orders ORDER BY cust_id, order_dt, order_id;
  ALTER TABLE orders RENAME TO orders_old;
  ALTER TABLE orders_sorted RENAME TO orders;

  DROP INDEX ix_orders_cust_dt;
  CREATE INDEX ix_orders_cust_dt ON orders(cust_id, order_dt DESC, order_id DESC);

  BEGIN DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE); END;
  /
  ```
- [ ] **NL/해시 조인** 선택이 데이터 패턴과 I/O 비용에 부합하는가?
  - **NL**: 선행 집합이 작고, 후행 인덱스 접근(높은 선택도)이 빠를 때  
  - **해시**: 대량 조인·배치·DW, 순차/멀티블록 I/O에 유리
  ```sql
  -- NL 강제(좁은 키 반복 조회에 유리)
  SELECT /*+ leading(o) use_nl(oi) index(oi(order_id)) */
         o.order_id, SUM(oi.qty*oi.price)
  FROM   orders o
  JOIN   order_items oi ON oi.order_id=o.order_id
  WHERE  o.cust_id=:cust AND o.order_dt>=SYSDATE-7
  GROUP  BY o.order_id;
  ```

---

## 3) 통계·옵티마이저 팩터 체크리스트 — “좋은 길을 선택할 근거를 주었는가?”

- [ ] **객체 통계** 최신화(카디널리티·널·분포):
  ```sql
  BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  END;
  /
  ```
- [ ] **히스토그램**(편중 컬럼) 적용으로 선택도 정확화:
  ```sql
  BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(
      ownname    => USER,
      tabname    => 'ORDERS',
      method_opt => 'for columns status size 254'
    );
  END;
  /
  ```
- [ ] **확장 통계**(상관관계 반영):
  ```sql
  BEGIN
    DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUSTOMERS','(region, grade)');
    DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS', method_opt=>'for all columns size skewonly');
  END;
  /
  ```
- [ ] **시스템 통계**(IO/CPU/MBRC) 반영:
  ```sql
  BEGIN
    DBMS_STATS.GATHER_SYSTEM_STATS('INTERVAL', interval=>3600); -- 운영 시간대 측정
  END;
  /
  ```
- [ ] **바인드 변수/Adaptive Cursor Sharing** 이해 및 편중 값 대응:
  - 히스토그램 + ACS로 **값에 따른 계획 분기** 허용  
  - 필요한 곳은 **리터럴 분리**(소수의 인기 값만)도 고려

---

## 4) 힌트 체크리스트 — “원인 교정 후에도 불확실하면 안전 레일”

- [ ] 액세스 경로 강제: `INDEX / FULL / INDEX_FFS`
- [ ] 조인 순서/방법: `LEADING / USE_NL / USE_HASH / NO_MERGE / PUSH_PRED`
- [ ] 병렬/Stopkey: `PARALLEL`, `FIRST_ROWS`

```sql
WITH cand AS (
  SELECT /*+ index(c ix_cust_rg_gr) */ cust_id
  FROM   customers c
  WHERE  c.region=:r AND c.grade='VIP'
)
SELECT /*+ leading(cand o) use_hash(o) */
       o.cust_id, COUNT(*)
FROM   cand JOIN orders o ON o.cust_id=cand.cust_id
WHERE  o.order_dt >= SYSDATE-7
GROUP  BY o.cust_id;
```

> 힌트는 **환경 바뀌면 위험**. 가능하면 **통계·설계로 자연 선택**을 유도하고, **핵심 쿼리**에만 제한적으로 사용.

---

## 5) TEMP/정렬/해시 체크리스트 — “스필(direct path read/write temp)을 줄였는가?”

- [ ] `workarea_size_policy=AUTO`, `pga_aggregate_target` 적정?
- [ ] **스필**이 빈번한 정렬/해시는 구조상 줄였는가(Top-N, 조기 집계, 조인 순서)?
- [ ] 대기 이벤트가 `direct path write temp/read temp` 로 지배되는가?
  ```sql
  SELECT name, value
  FROM   v$sysstat
  WHERE  name IN ('physical writes direct temporary','physical reads direct temporary');
  ```

---

## 6) Direct Path I/O 체크리스트 — “대량 작업은 Bypass로, OLTP는 캐시 재사용”

- [ ] 배치/보고: **Full/Partition Scan + 병렬**로 `direct path read` 유도  
- [ ] 대량 적재/변경: `INSERT /*+ APPEND */`/`CTAS` 로 `direct path write`  
- [ ] OLTP: 불필요한 직렬 direct read 강제 지양 (`"_serial_direct_read"` 테스트 옵션)

```sql
-- 적재 최적화
INSERT /*+ APPEND */ INTO big_table
SELECT * FROM staging_day;
COMMIT;
```

---

## 7) 페이징/리스트 API 체크리스트 — “OFFSET 말고 Keyset”

- [ ] OFFSET/COUNT 방식 대신 **Keyset**(마지막 키) 사용?
- [ ] 정렬 일치 인덱스에 맞춰 **앞부분만** 스캔?

```sql
-- Keyset 페이징
SELECT /*+ index(o ix_orders_cust_dt) */
       order_id, order_dt, amount
FROM   orders o
WHERE  o.cust_id=:cust
  AND (o.order_dt < :last_dt OR (o.order_dt=:last_dt AND o.order_id<:last_id))
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST :take ROWS ONLY;
```

---

## 8) 파티셔닝 체크리스트 — “읽지 않을 파티션은 아예 건드리지 않는다”

- [ ] **파티션 키와 조건 표현**이 동일 타입/연산인가(함수/형변환 없음)?
- [ ] **서브파티션**으로 핫셋/경합 분산?
- [ ] **Exchange Partition** 등으로 로드/재빌드 오프라인화?

```sql
SELECT /* 특정 월만 */ COUNT(*)
FROM   orders
WHERE  order_dt >= DATE '2025-10-01'
  AND  order_dt <  DATE '2025-11-01';
```

---

## 9) 애플리케이션·네트워크 체크리스트 — “DB 왕복/Fetch를 최소화했는가?”

- [ ] **배치 바인드(Array Insert/Update)** 로 **call 수↓**
  ```plsql
  -- PL/SQL FORALL: 다건 DML에 필수
  FORALL i IN 1..l_cnt
    INSERT INTO orders(order_id,cust_id,order_dt,status,amount)
    VALUES (arr_id(i), arr_cust(i), arr_dt(i), arr_st(i), arr_amt(i));
  ```
- [ ] **ArraySize(페치 크기)** 조정으로 Fetch call↓·블록 I/O↓
- [ ] **Result Cache/Client Cache**(빈번 동일 결과)로 서버 I/O 축소
- [ ] **Keyset 페이징**으로 대량 OFFSET 제거

---

## 10) RAC/캐시 퓨전 체크리스트 — “전송 없는 읽기 비율을 높였는가?”

- [ ] 서비스 라우팅으로 **읽기/쓰기 트래픽 분리**(인스턴스 로컬리티)
- [ ] 파티션/키 설계로 **핫 블록 분산**
- [ ] `gc %` 이벤트(특히 `gc current block 2/3-way`) 비중 감소?
  ```sql
  SELECT event, COUNT(*) samples
  FROM   v$active_session_history
  WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
    AND  event LIKE 'gc %'
  GROUP  BY event ORDER BY samples DESC;
  ```

---

## 11) 실행 중 계측 체크리스트 — “느낌이 아니라 숫자”

- [ ] `DBMS_XPLAN.DISPLAY_CURSOR('','', 'ALLSTATS LAST')` 로 **실제 블록 수**·카디널리티 확인
- [ ] `V$SQL` 의 `buffer_gets/disk_reads`(평균/총)
- [ ] ASH로 **대기 이벤트 분포**(sequential vs scattered vs direct path)
- [ ] AWR(스냅샷)로 **전/후 비교**: Top SQL, IO 기다림, Temp 사용량

---

## 12) 종합 시나리오: “최근 7일 VIP 고객 Top-K 주문”

### 12.1 나쁜 버전
```sql
SELECT o.order_id, o.order_dt, o.amount
FROM   customers c
JOIN   orders o ON o.cust_id = c.cust_id
WHERE  c.region=:r
AND    c.grade='VIP'
AND    TRUNC(o.order_dt) >= TRUNC(SYSDATE)-7
ORDER  BY o.amount DESC
OFFSET :skip ROWS FETCH NEXT :take ROWS ONLY;
```
- 문제: `TRUNC`, OFFSET, 광범위 조인 → **여분 블록 다량**.

### 12.2 체크리스트 기반 개선
```sql
-- (1) 후보 축소 + SARGable 범위
WITH vip AS (
  SELECT /*+ index(c ix_cust_rg_gr) */ cust_id
  FROM   customers c
  WHERE  c.region=:r AND c.grade='VIP'
)
SELECT /*+ leading(vip o) use_hash(o) */
       o.order_id, o.order_dt, o.amount
FROM   vip
JOIN   orders o ON o.cust_id = vip.cust_id
WHERE  o.order_dt >= SYSDATE - 7
ORDER  BY o.amount DESC
FETCH FIRST :take ROWS ONLY;  -- Stopkey

-- (2) 통계: 확장 통계/히스토그램/시스템 통계
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUSTOMERS','(region, grade)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS', method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',    method_opt=>'for all columns size skewonly');
END;
/
```
- 기대: 스캔 범위↓, 정렬량↓, I/O 대기↓, 응답시간↓.

---

## 13) 미니 “Yes/No” 체크 테이블

| 구분 | 질문 | 예/아니오 | 조치 |
|---|---|---|---|
| 쿼리 | 컬럼에 함수/형변환 없이 범위형 조건인가? |  | SARGable로 변환 |
| 쿼리 | Top-N/Keyset으로 앞부분만 읽는가? |  | Stopkey/Keyset 적용 |
| 인덱스 | 정렬 일치·커버링 인덱스인가? |  | 인덱스 설계/재구성 |
| 인덱스 | CF가 양호한가? |  | CTAS→재빌드 |
| 통계 | 히스토그램/확장 통계/시스템 통계 최신인가? |  | 통계 수집/보정 |
| TEMP | 스필이 많은가? |  | PGA/쿼리 재구성 |
| Direct | 배치에는 direct path, OLTP에는 캐시 재사용? |  | 경로 재설계 |
| RAC | 전송 없는 읽기 비율이 높은가? |  | 파티션/서비스 라우팅 |
| 앱 | 배치 바인드/ArraySize 튜닝 했는가? |  | call 최소화 |

---

## 14) 수학적 직관(간단)

- **총 블록 근사**  
  $$ \text{Blocks} \approx \sum (\text{입력 행 수} \times \text{행당 블록 접근}) $$
  - 입력을 줄이거나(프루닝/조기 필터), **행당 블록 접근을 1에 가깝게**(커버링/CF 개선) 만들면 **선형적으로 감소**.
- **정렬 비용**  
  $$ \text{Sort} \sim \mathcal{O}(n\log n) \Rightarrow \text{Stopkey/정렬 일치} \Downarrow n $$

---

## 15) 빠른 진단/조치 스니펫 묶음

```sql
-- 1) 실제 수행통계
ALTER SESSION SET statistics_level = ALL;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS'));

-- 2) I/O 대기 분포(ASH)
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
AND    session_type='FOREGROUND'
AND    event IN ('db file sequential read','db file scattered read',
                 'direct path read','direct path read temp',
                 'direct path write','direct path write temp')
GROUP  BY event ORDER BY samples DESC;

-- 3) Top SQL I/O
SELECT sql_id, executions, buffer_gets, disk_reads
FROM   v$sql ORDER BY disk_reads DESC FETCH FIRST 20 ROWS ONLY;

-- 4) 통계 보강
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUSTOMERS','(region, grade)');
END;
/

-- 5) 인덱스 경로 유도(필요시)
SELECT /*+ index(o ix_orders_cust_dt) */ COUNT(*)
FROM   orders o
WHERE  o.cust_id=:cust AND o.order_dt>=SYSDATE-7;
```

---

## 결론

- I/O 효율화는 **체크리스트로 체계화**하면 일관되게 성과가 난다.  
- 순서는 항상 **(1) 쿼리 구조(최소 블록) → (2) 통계/옵티마이저 근거 → (3) 액세스 경로/인덱스 → (4) 실행 중 계측**.  
- 계측은 “**느낌이 아니라 숫자**”로: `DBMS_XPLAN`, `V$SQL`, `ASH/AWR` 로 **전/후 블록·대기·응답시간**을 비교해 검증하라.  
- 배치/보고와 OLTP는 다르다. **적절한 Direct Path/캐시 재사용 전략**을 구분 적용하고, 필요하면 힌트로 안전 레일을 깐다.  
- 끝으로, **서비스 라우팅·파티셔닝·Keyset 페이징·커버링 인덱스**는 현대 시스템의 “4대 필살기”다. 이 네 가지만 제대로 써도 I/O는 대부분 정리된다.