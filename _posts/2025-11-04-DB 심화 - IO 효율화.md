---
layout: post
title: DB 심화 - I/O 효율화
date: 2025-11-04 23:25:23 +0900
category: DB 심화
---
# Oracle I/O 효율화 종합 가이드

> **핵심 목표**: 필요한 최소한의 블록만 읽고 쓰며, 불필요한 I/O와 대기 시간을 제거하여 데이터베이스 성능을 최적화합니다.

---

## 테스트 환경 구성

```sql
-- 데모용 테이블 생성
CREATE TABLE customers (
  cust_id    NUMBER PRIMARY KEY,
  region     VARCHAR2(8),
  grade      VARCHAR2(8),
  created_at DATE,
  name       VARCHAR2(60)
);

CREATE TABLE orders (
  order_id   NUMBER PRIMARY KEY,
  cust_id    NUMBER NOT NULL,
  order_dt   DATE   NOT NULL,
  status     VARCHAR2(8),
  amount     NUMBER(12,2)
);

-- 인덱스 생성
CREATE INDEX ix_cust_rg_gr ON customers(region, grade, cust_id);
CREATE INDEX ix_orders_cust_dt ON orders(cust_id, order_dt DESC, order_id DESC);

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS',cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## I/O 성능 분석을 위한 기본 도구

### 실행 계획과 통계 확인
```sql
-- 세션 통계 수집 활성화
ALTER SESSION SET statistics_level = ALL;

-- 쿼리 실행 후 실행 계획 확인
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +MEMSTATS'));
```

### SQL I/O 성능 분석
```sql
-- 최근 실행된 SQL의 I/O 패턴 분석
SELECT sql_id, plan_hash_value, executions,
       buffer_gets, disk_reads,
       ROUND(buffer_gets/NULLIF(executions,0)) avg_lio,
       ROUND(disk_reads/NULLIF(executions,0))  avg_pio
FROM   v$sql
WHERE  sql_text LIKE 'SELECT%'
ORDER  BY avg_pio DESC FETCH FIRST 30 ROWS ONLY;
```

### I/O 대기 이벤트 모니터링
```sql
-- 최근 10분간의 I/O 관련 대기 이벤트 분석
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
AND    session_type='FOREGROUND'
AND    event IN ('db file sequential read','db file scattered read',
                 'direct path read','direct path read temp',
                 'direct path write','direct path write temp')
GROUP  BY event ORDER BY samples DESC;
```

---

## 쿼리 구조 최적화

효율적인 I/O 관리를 위한 첫 번째 단계는 쿼리 구조 자체를 최적화하는 것입니다.

### SARGable 조건 사용
인덱스를 효과적으로 활용할 수 있는 조건을 사용해야 합니다.

**비효율적 예시:**
```sql
SELECT COUNT(*) FROM orders
WHERE TRUNC(order_dt) = DATE '2025-10-01';
```

**최적화된 예시:**
```sql
SELECT COUNT(*) FROM orders
WHERE order_dt >= DATE '2025-10-01'
  AND order_dt <  DATE '2025-10-02';
```

### 조기 필터링 적용
선택도가 높은 조건을 먼저 적용하여 처리해야 할 데이터 양을 줄입니다.

```sql
WITH cand AS (
  SELECT /*+ index(c ix_cust_rg_gr) */ cust_id
  FROM   customers c
  WHERE  c.region=:r AND c.grade=:g
)
SELECT /*+ leading(cand o) use_hash(o) */
       o.cust_id, COUNT(*)
FROM   cand JOIN orders o ON o.cust_id=cand.cust_id
WHERE  o.order_dt >= SYSDATE-7
GROUP  BY o.cust_id;
```

### EXISTS 활용
존재성 확인 시 COUNT 대신 EXISTS를 사용합니다.

```sql
SELECT /*+ first_rows(1) */ o.order_id
FROM   orders o
WHERE  EXISTS (SELECT 1 FROM order_items oi WHERE oi.order_id=o.order_id)
FETCH FIRST 1 ROW ONLY;
```

### Keyset 페이지네이션
OFFSET 대신 Keyset 방식을 사용하여 효율적인 페이지 처리를 구현합니다.

```sql
SELECT /*+ index(o ix_orders_cust_dt) */ order_id, order_dt, amount
FROM   orders o
WHERE  o.cust_id = :cust
  AND (o.order_dt < :last_dt OR (o.order_dt=:last_dt AND o.order_id<:last_id))
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

---

## 인덱스 설계와 액세스 경로 최적화

### 커버링 인덱스 활용
인덱스에 필요한 모든 컬럼을 포함시켜 테이블 접근을 최소화합니다.

```sql
SELECT /*+ index(o ix_orders_cust_dt) */ o.order_id, o.order_dt, o.amount
FROM   orders o
WHERE  o.cust_id=:cust AND o.order_dt>=SYSDATE-7
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

### 클러스터링 팩터 개선
데이터의 물리적 배치를 최적화하여 인덱스 효율성을 높입니다.

```sql
-- 데이터 물리적 재배치
CREATE TABLE orders_sorted NOLOGGING AS
SELECT * FROM orders ORDER BY cust_id, order_dt, order_id;

-- 기존 테이블 교체
ALTER TABLE orders RENAME TO orders_old;
ALTER TABLE orders_sorted RENAME TO orders;

-- 인덱스 재생성
DROP INDEX ix_orders_cust_dt;
CREATE INDEX ix_orders_cust_dt ON orders(cust_id, order_dt DESC, order_id DESC);

-- 통계 갱신
BEGIN 
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE); 
END;
/
```

### 조인 방법 선택
데이터 패턴에 맞는 조인 방법을 선택합니다.

```sql
-- NL 조인: 선행 집합이 작고 후행 인덱스 접근이 빠를 때
SELECT /*+ leading(o) use_nl(oi) index(oi(order_id)) */
       o.order_id, SUM(oi.qty*oi.price)
FROM   orders o
JOIN   order_items oi ON oi.order_id=o.order_id
WHERE  o.cust_id=:cust AND o.order_dt>=SYSDATE-7
GROUP  BY o.order_id;
```

---

## 통계 관리와 옵티마이저 지원

### 정확한 통계 유지
옵티마이저가 최적의 실행 계획을 선택할 수 있도록 정확한 통계를 유지합니다.

```sql
-- 기본 테이블 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/

-- 히스토그램 생성 (편중된 데이터 분포 처리)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'ORDERS',
    method_opt => 'for columns status size 254'
  );
END;
/

-- 확장 통계 생성 (컬럼 간 상관관계 반영)
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUSTOMERS','(region, grade)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS', method_opt=>'for all columns size skewonly');
END;
/

-- 시스템 통계 수집
BEGIN
  DBMS_STATS.GATHER_SYSTEM_STATS('INTERVAL', interval=>3600);
END;
/
```

---

## TEMP 공간과 정렬 작업 최적화

### PGA 설정 확인
```sql
-- PGA 설정 확인
SELECT name, value
FROM v$parameter 
WHERE name IN ('pga_aggregate_target', 'workarea_size_policy');

-- TEMP 공간 사용 통계
SELECT name, value
FROM   v$sysstat
WHERE  name IN ('physical writes direct temporary','physical reads direct temporary');
```

### 정렬 최소화
불필요한 정렬 작업을 피하고, 필요한 경우 메모리 내에서 처리되도록 합니다.

---

## Direct Path I/O 전략

### 대량 작업 최적화
배치 작업에는 Direct Path I/O를 활용합니다.

```sql
-- 대량 데이터 적재
INSERT /*+ APPEND */ INTO big_table
SELECT * FROM staging_day;
COMMIT;
```

### OLTP 작업 최적화
OLTP 환경에서는 버퍼 캐시 재사용을 최대화합니다.

---

## 파티셔닝 전략

### 파티션 프루닝 활용
읽지 않을 파티션은 아예 접근하지 않도록 합니다.

```sql
-- 월 단위 파티션 프루닝
SELECT /* 특정 월만 */ COUNT(*)
FROM   orders
WHERE  order_dt >= DATE '2025-10-01'
  AND  order_dt <  DATE '2025-11-01';
```

---

## 애플리케이션 레벨 최적화

### 배열 처리 활용
배치 작업 시 배열 바인드를 사용하여 호출 횟수를 최소화합니다.

```plsql
-- PL/SQL FORALL을 이용한 대량 삽입
DECLARE
  TYPE t_ids IS TABLE OF NUMBER;
  TYPE t_dates IS TABLE OF DATE;
  TYPE t_amounts IS TABLE OF NUMBER;
  
  l_ids t_ids;
  l_dates t_dates;
  l_amounts t_amounts;
BEGIN
  -- 배열에 데이터 채우기
  FOR i IN 1..1000 LOOP
    l_ids(i) := i;
    l_dates(i) := SYSDATE;
    l_amounts(i) := i * 10;
  END LOOP;
  
  -- FORALL로 일괄 삽입
  FORALL i IN 1..l_ids.COUNT
    INSERT INTO orders(order_id, cust_id, order_dt, amount)
    VALUES (l_ids(i), 1, l_dates(i), l_amounts(i));
    
  COMMIT;
END;
/
```

### 페치 크기 최적화
적절한 Array Size를 설정하여 네트워크 왕복을 최소화합니다.

---

## RAC 환경 최적화

### 캐시 퓨전 최소화
```sql
-- RAC 대기 이벤트 분석
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
  AND  event LIKE 'gc %'
GROUP  BY event ORDER BY samples DESC;
```

---

## 실전 튜닝 사례: VIP 고객 주문 분석

### 문제가 있는 쿼리
```sql
SELECT o.order_id, o.order_dt, o.amount
FROM   customers c
JOIN   orders o ON o.cust_id = c.cust_id
WHERE  c.region=:r
AND    c.grade='VIP'
AND    TRUNC(o.order_dt) >= TRUNC(SYSDATE)-7
ORDER  BY o.amount DESC
OFFSET :skip ROWS FETCH NEXT :take ROWS ONLY;
```

**문제점:**
- `TRUNC()` 함수 사용으로 인덱스 활용 불가
- OFFSET 방식으로 인한 비효율적인 페이지네이션
- 광범위한 조인으로 불필요한 블록 접근

### 최적화된 쿼리
```sql
-- 후보 데이터 축소 및 SARGable 조건 적용
WITH vip AS (
  SELECT /*+ index(c ix_cust_rg_gr) */ cust_id
  FROM   customers c
  WHERE  c.region=:r AND c.grade='VIP'
)
SELECT /*+ leading(vip o) use_hash(o) */
       o.order_id, o.order_dt, o.amount
FROM   vip
JOIN   orders o ON o.cust_id = vip.cust_id
WHERE  o.order_dt >= SYSDATE - 7
ORDER  BY o.amount DESC
FETCH FIRST :take ROWS ONLY;  -- Stopkey 활용
```

**개선사항:**
- 공통 테이블 표현식(CTE)으로 VIP 고객 필터링
- 함수 적용 없이 범위 조건 사용
- Stopkey를 활용한 효율적인 상위 N개 행 조회

### 통계 보강
```sql
BEGIN
  -- 확장 통계 생성
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUSTOMERS','(region, grade)');
  
  -- 상세 통계 수집
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUSTOMERS', method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS', method_opt=>'for all columns size skewonly');
END;
/
```

---

## 성능 분석 도구 모음

### 실행 계획 분석
```sql
ALTER SESSION SET statistics_level = ALL;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS'));
```

### I/O 대기 분석
```sql
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
AND    session_type='FOREGROUND'
AND    event IN ('db file sequential read','db file scattered read',
                 'direct path read','direct path read temp',
                 'direct path write','direct path write temp')
GROUP  BY event ORDER BY samples DESC;
```

### 상위 I/O 소비 SQL 확인
```sql
SELECT sql_id, executions, buffer_gets, disk_reads
FROM   v$sql ORDER BY disk_reads DESC FETCH FIRST 20 ROWS ONLY;
```

---

## 결론

Oracle 데이터베이스의 I/O 효율화는 체계적인 접근이 필요한 다각적인 작업입니다. 성공적인 최적화를 위해 다음 원칙을 준수하십시오:

### 기본 원칙
1. **쿼리 구조 최적화**: 필요한 최소한의 데이터만 처리하도록 쿼리를 설계합니다. SARGable 조건, 조기 필터링, EXISTS 패턴, Keyset 페이지네이션을 활용하세요.
2. **인덱스 전략**: 커버링 인덱스, 클러스터링 팩터 개선, 적절한 조인 방법 선택으로 물리적 I/O를 최소화하세요.
3. **통계 관리**: 정확하고 최신의 통계 정보로 옵티마이저가 최적의 실행 계획을 선택할 수 있도록 지원하세요.

### 실전 적용 지침
- **측정 기반 접근**: 감정이나 추측이 아니라 `DBMS_XPLAN`, `V$SQL`, ASH/AWR 등의 도구로 실제 성능 데이터를 분석하세요.
- **환경에 맞는 전략**: 배치 작업과 OLTP 작업은 서로 다른 I/O 전략이 필요합니다. Direct Path I/O와 버퍼 캐시 재사용을 상황에 맞게 적용하세요.
- **현대적 기법 활용**: 서비스 라우팅, 파티셔닝, Keyset 페이지네이션, 커버링 인덱스는 현대 시스템의 핵심 최적화 기술입니다.

### 지속적인 개선
I/O 효율화는 일회성 작업이 아닌 지속적인 과정입니다. 새로운 데이터 패턴이 나타나거나 애플리케이션 요구사항이 변경될 때마다 성능을 재평가하고 필요한 조정을 수행하십시오. 항상 실제 운영 환경에서의 성능 측정을 통해 개선 효과를 검증하고, 그 결과를 바탕으로 추가 최적화를 진행하세요.

효율적인 I/O 관리는 단순한 성능 개선을 넘어 시스템의 확장성, 안정성, 운영 비용 절감에까지 영향을 미치는 핵심 역량입니다. 체계적인 접근과 지속적인 개선을 통해 데이터베이스 인프라의 전반적인 건강 상태를 유지하십시오.