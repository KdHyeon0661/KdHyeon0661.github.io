---
layout: post
title: C - 배열과 문자열
date: 2024-08-23 19:20:23 +0900
category: C
---
# 배열과 문자열: C 언어의 데이터 구조 기초

## 시작하기 전: 배열과 문자열의 핵심 개념

배열과 문자열은 C 프로그래밍에서 데이터를 구조화하고 처리하는 기본적인 방법입니다. 배열은 동일한 자료형의 여러 값을 하나의 변수로 묶어 관리할 수 있게 해주며, 문자열은 문자 배열의 특별한 형태로 텍스트 데이터를 다룹니다.

먼저 배열과 문자열의 기본적인 사용법을 간단한 예제로 살펴보겠습니다:

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    // 1. 배열의 기본 사용법
    int numbers[5] = {10, 20, 30, 40, 50};
    
    // 배열의 크기 확인
    printf("배열 크기(바이트): %zu\n", sizeof(numbers));
    printf("요소 개수: %zu\n", sizeof(numbers) / sizeof(numbers[0]));
    
    // 2. 배열과 포인터의 관계
    int *p = numbers;  // 배열 이름은 첫 번째 요소의 주소로 변환됨
    printf("첫 번째 요소: %d (인덱스), %d (포인터)\n", numbers[0], *p);
    
    // 3. 문자열: 문자 배열의 특별한 형태
    char greeting[] = "Hello";  // 자동으로 널 문자('\0')가 추가됨
    const char *name = "World"; // 문자열 리터럴 (읽기 전용)
    
    // 문자열 수정 (배열은 수정 가능)
    greeting[0] = 'h';
    printf("%s %s\n", greeting, name);
    
    // 4. 안전한 문자열 조작
    char buffer[20] = "Hello";
    // 남은 공간을 고려한 문자열 연결
    strncat(buffer, " World!", sizeof(buffer) - strlen(buffer) - 1);
    printf("%s\n", buffer);
    
    return 0;
}
```

## 배열: 데이터의 집합체

### 1차원 배열: 기본부터 시작

배열은 같은 자료형의 여러 값을 연속된 메모리 공간에 저장하는 자료구조입니다:

```c
#include <stdio.h>

int main(void) {
    // 배열 선언과 초기화
    int scores[5];                     // 선언만 (초기화되지 않음)
    int ages[3] = {25, 30, 35};       // 선언과 초기화
    int numbers[] = {1, 2, 3, 4, 5};  // 크기를 생략하면 초기값 개수로 결정
    
    // 배열 요소 접근
    scores[0] = 85;    // 첫 번째 요소
    scores[1] = 90;    // 두 번째 요소
    scores[4] = 95;    // 마지막 요소 (인덱스 4, 크기는 5)
    
    // 배열 순회
    printf("점수 배열: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", scores[i]);
    }
    printf("\n");
    
    // 배열 크기 계산
    int size = sizeof(scores) / sizeof(scores[0]);
    printf("배열 크기: %d\n", size);
    
    return 0;
}
```

#### 배열의 중요한 특징

1. **인덱스는 0부터 시작**: 첫 번째 요소의 인덱스는 0입니다
2. **연속된 메모리 공간**: 모든 요소가 메모리에 연속적으로 저장됩니다
3. **고정 크기**: 컴파일 시간에 크기가 결정되며, 실행 중에 변경할 수 없습니다
4. **배열 이름은 포인터로 변환**: 대부분의 상황에서 배열 이름은 첫 번째 요소의 주소로 변환됩니다

### 배열과 포인터의 관계

배열과 포인터는 밀접한 관계가 있습니다:

```c
#include <stdio.h>

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    
    // 배열 이름은 첫 번째 요소의 주소로 변환됨
    int *ptr = arr;  // arr은 &arr[0]과 동일
    
    printf("배열 접근:\n");
    printf("arr[0] = %d\n", arr[0]);
    printf("*ptr   = %d\n", *ptr);
    
    printf("\n포인터 산술:\n");
    printf("*(ptr + 1) = %d  (arr[1]과 동일)\n", *(ptr + 1));
    printf("*(ptr + 2) = %d  (arr[2]과 동일)\n", *(ptr + 2));
    
    // 인덱스 표기법과 포인터 표기법은 상호 교환 가능
    printf("\n동등성 확인:\n");
    printf("arr[3] = %d\n", arr[3]);
    printf("*(arr + 3) = %d\n", *(arr + 3));
    printf("3[arr] = %d (권장하지 않음)\n", 3[arr]);  // 가능하지만 사용하지 마세요!
    
    return 0;
}
```

#### sizeof 연산자의 차이

```c
#include <stdio.h>

void print_array_size(int arr[]) {
    // 경고: 함수 내부에서 배열 매개변수는 포인터로 처리됨
    printf("함수 내부 sizeof(arr): %zu (포인터 크기)\n", sizeof(arr));
}

int main(void) {
    int numbers[10] = {0};
    
    printf("main 함수 내 sizeof(numbers): %zu (배열 전체 크기)\n", 
           sizeof(numbers));
    printf("요소 개수: %zu\n", 
           sizeof(numbers) / sizeof(numbers[0]));
    
    print_array_size(numbers);  // 포인터 크기 출력됨
    
    return 0;
}
```

## 다차원 배열: 행과 열로 데이터 구성

### 2차원 배열: 표 형태의 데이터

2차원 배열은 행과 열로 구성된 표 형태의 데이터를 저장합니다:

```c
#include <stdio.h>

int main(void) {
    // 2차원 배열 선언과 초기화
    int matrix[3][4] = {
        {1, 2, 3, 4},      // 첫 번째 행
        {5, 6, 7, 8},      // 두 번째 행
        {9, 10, 11, 12}    // 세 번째 행
    };
    
    // 다른 초기화 방법
    int identity[3][3] = {
        [0][0] = 1, [1][1] = 1, [2][2] = 1  // 나머지는 0으로 초기화
    };
    
    // 2차원 배열 접근
    printf("2차원 배열 출력:\n");
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 4; col++) {
            printf("%3d ", matrix[row][col]);
        }
        printf("\n");
    }
    
    // 2차원 배열의 메모리 레이아웃 이해
    printf("\n1차원으로 접근하기:\n");
    int *flat_view = (int *)matrix;
    for (int i = 0; i < 3 * 4; i++) {
        printf("%d ", flat_view[i]);
    }
    printf("\n");
    
    return 0;
}
```

### 2차원 배열을 함수에 전달하기

2차원 배열을 함수에 전달할 때는 열의 크기를 지정해야 합니다:

```c
#include <stdio.h>

// 열의 크기가 4로 고정된 경우
void print_fixed_matrix(int matrix[][4], int rows) {
    printf("고정 열 크기 배열:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%3d ", matrix[i][j]);
        }
        printf("\n");
    }
}

// 가변 길이 배열(VLA) 사용 (C99 이상)
void print_vla_matrix(int rows, int cols, int matrix[rows][cols]) {
    printf("가변 크기 배열 (%d x %d):\n", rows, cols);
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%3d ", matrix[i][j]);
        }
        printf("\n");
    }
}

// 포인터와 수동 인덱싱
void print_pointer_matrix(int *matrix, int rows, int cols) {
    printf("포인터와 수동 인덱싱:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%3d ", matrix[i * cols + j]);
        }
        printf("\n");
    }
}

int main(void) {
    int matrix[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    print_fixed_matrix(matrix, 3);
    printf("\n");
    
    print_vla_matrix(3, 4, matrix);
    printf("\n");
    
    print_pointer_matrix((int *)matrix, 3, 4);
    
    return 0;
}
```

### 동적 2차원 배열

실행 시간에 크기가 결정되는 2차원 배열이 필요할 때:

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int rows = 3, cols = 4;
    
    // 방법 1: 단일 메모리 블록 사용 (권장)
    printf("방법 1: 단일 메모리 블록\n");
    int *matrix1 = malloc(rows * cols * sizeof(int));
    
    if (matrix1 == NULL) {
        printf("메모리 할당 실패\n");
        return 1;
    }
    
    // 초기화
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix1[i * cols + j] = i * cols + j + 1;
        }
    }
    
    // 접근
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%3d ", matrix1[i * cols + j]);
        }
        printf("\n");
    }
    
    free(matrix1);
    
    // 방법 2: 포인터 배열 사용
    printf("\n방법 2: 포인터 배열\n");
    int **matrix2 = malloc(rows * sizeof(int *));
    
    if (matrix2 == NULL) {
        printf("메모리 할당 실패\n");
        return 1;
    }
    
    for (int i = 0; i < rows; i++) {
        matrix2[i] = malloc(cols * sizeof(int));
        if (matrix2[i] == NULL) {
            printf("메모리 할당 실패\n");
            // 이미 할당된 메모리 정리
            for (int j = 0; j < i; j++) {
                free(matrix2[j]);
            }
            free(matrix2);
            return 1;
        }
    }
    
    // 초기화
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix2[i][j] = i * cols + j + 1;
        }
    }
    
    // 접근
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%3d ", matrix2[i][j]);
        }
        printf("\n");
    }
    
    // 메모리 해제
    for (int i = 0; i < rows; i++) {
        free(matrix2[i]);
    }
    free(matrix2);
    
    return 0;
}
```

## 문자열: 텍스트 데이터 다루기

### 문자열의 기본 개념

C 언어에서 문자열은 널 문자(`'\0'`)로 끝나는 문자 배열입니다:

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    // 문자열 초기화 방법들
    char str1[] = "Hello";                    // 자동으로 널 문자 추가
    char str2[10] = "World";                  // 명시적 크기 지정
    char str3[] = {'H', 'i', '\0'};           // 문자 배열로 초기화
    const char *str4 = "String Literal";      // 문자열 리터럴 (읽기 전용)
    
    // 문자열 길이
    printf("str1: %s (길이: %zu)\n", str1, strlen(str1));
    
    // 문자열 복사
    char copy[20];
    strcpy(copy, str1);                       // 간단한 복사
    strncpy(copy, str1, sizeof(copy) - 1);    // 안전한 복사
    copy[sizeof(copy) - 1] = '\0';            // 널 문자 보장
    printf("복사된 문자열: %s\n", copy);
    
    // 문자열 비교
    if (strcmp(str1, "Hello") == 0) {
        printf("str1은 \"Hello\"와 같습니다.\n");
    }
    
    // 문자열 연결
    char greeting[50] = "Hello, ";
    strcat(greeting, str2);                   // 기본 연결
    printf("기본 연결: %s\n", greeting);
    
    // 안전한 연결
    char safe_greeting[20] = "Hello, ";
    strncat(safe_greeting, "World!", 
            sizeof(safe_greeting) - strlen(safe_greeting) - 1);
    printf("안전한 연결: %s\n", safe_greeting);
    
    // 문자열 검색
    char text[] = "The quick brown fox jumps over the lazy dog";
    char *found = strstr(text, "fox");
    if (found) {
        printf("'fox'를 찾았습니다: %s\n", found);
    }
    
    return 0;
}
```

### 문자열 입력 처리

사용자로부터 문자열을 안전하게 입력받는 방법:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 안전한 문자열 입력 함수
void safe_input(char *buffer, size_t size) {
    if (fgets(buffer, size, stdin) == NULL) {
        buffer[0] = '\0';  // 입력 실패 시 빈 문자열
        return;
    }
    
    // 개행 문자 제거
    size_t len = strlen(buffer);
    if (len > 0 && buffer[len - 1] == '\n') {
        buffer[len - 1] = '\0';
    }
}

// 문자열을 정수로 변환 (안전한 버전)
int safe_string_to_int(const char *str, int *result) {
    char *endptr;
    long value = strtol(str, &endptr, 10);
    
    // 변환 오류 확인
    if (endptr == str) {
        return 0;  // 숫자로 변환할 수 없음
    }
    
    // 범위 확인
    if (value < -2147483648 || value > 2147483647) {
        return 0;  // int 범위를 벗어남
    }
    
    *result = (int)value;
    return 1;  // 성공
}

int main(void) {
    char name[50];
    char age_str[20];
    int age;
    
    printf("이름을 입력하세요: ");
    safe_input(name, sizeof(name));
    
    printf("나이를 입력하세요: ");
    safe_input(age_str, sizeof(age_str));
    
    if (safe_string_to_int(age_str, &age)) {
        printf("안녕하세요, %s님! 나이: %d\n", name, age);
    } else {
        printf("나이를 올바르게 입력해주세요.\n");
    }
    
    return 0;
}
```

### 문자열 조작 함수 직접 구현

표준 라이브러리 함수를 직접 구현해 이해를 깊게 해봅시다:

```c
#include <stdio.h>
#include <stddef.h>  // size_t 정의

// 문자열 길이 계산
size_t my_strlen(const char *str) {
    size_t length = 0;
    while (str[length] != '\0') {
        length++;
    }
    return length;
}

// 문자열 복사
char *my_strcpy(char *dest, const char *src) {
    char *original_dest = dest;
    while ((*dest++ = *src++) != '\0') {
        // 빈 루프 - 모든 작업은 조건식에서 수행됨
    }
    return original_dest;
}

// 안전한 문자열 복사 (버퍼 크기 고려)
size_t my_strlcpy(char *dest, const char *src, size_t size) {
    size_t src_len = 0;
    
    // src 길이 계산
    while (src[src_len] != '\0') {
        src_len++;
    }
    
    if (size > 0) {
        // 복사할 바이트 수 결정
        size_t copy_len = src_len;
        if (copy_len >= size) {
            copy_len = size - 1;
        }
        
        // 복사
        for (size_t i = 0; i < copy_len; i++) {
            dest[i] = src[i];
        }
        dest[copy_len] = '\0';
    }
    
    return src_len;  // 원본 문자열 길이 반환
}

// 문자열 비교
int my_strcmp(const char *str1, const char *str2) {
    while (*str1 && (*str1 == *str2)) {
        str1++;
        str2++;
    }
    return *(unsigned char *)str1 - *(unsigned char *)str2;
}

// 부분 문자열 검색
const char *my_strstr(const char *haystack, const char *needle) {
    if (*needle == '\0') {
        return haystack;
    }
    
    for (const char *h = haystack; *h != '\0'; h++) {
        const char *n = needle;
        const char *h2 = h;
        
        while (*n != '\0' && *h2 != '\0' && *n == *h2) {
            n++;
            h2++;
        }
        
        if (*n == '\0') {
            return h;  // 찾음
        }
    }
    
    return NULL;  // 찾지 못함
}

int main(void) {
    char dest[20];
    const char *src = "Hello, World!";
    
    // 직접 구현한 함수 테스트
    printf("원본 문자열: %s\n", src);
    printf("길이: %zu\n", my_strlen(src));
    
    my_strcpy(dest, src);
    printf("복사된 문자열: %s\n", dest);
    
    char safe_dest[10];
    size_t needed = my_strlcpy(safe_dest, src, sizeof(safe_dest));
    printf("안전 복사: %s (필요한 크기: %zu)\n", safe_dest, needed);
    
    printf("비교 결과: %d\n", my_strcmp("apple", "banana"));
    
    const char *found = my_strstr("The quick brown fox", "brown");
    if (found) {
        printf("부분 문자열 찾음: %s\n", found);
    }
    
    return 0;
}
```

## 실전 예제: 학생 성적 관리 시스템

배열과 문자열을 활용한 실제적인 예제를 살펴보겠습니다:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_STUDENTS 100
#define MAX_NAME_LENGTH 50
#define NUM_SUBJECTS 3

// 학생 구조체 정의
typedef struct {
    char name[MAX_NAME_LENGTH];
    int scores[NUM_SUBJECTS];
    double average;
} Student;

// 성적 등급 계산
char calculate_grade(double score) {
    if (score >= 90) return 'A';
    if (score >= 80) return 'B';
    if (score >= 70) return 'C';
    if (score >= 60) return 'D';
    return 'F';
}

// 안전한 문자열 입력
void get_string_input(char *buffer, size_t size, const char *prompt) {
    printf("%s", prompt);
    
    if (fgets(buffer, size, stdin) == NULL) {
        buffer[0] = '\0';
        return;
    }
    
    // 개행 문자 제거
    size_t len = strlen(buffer);
    if (len > 0 && buffer[len - 1] == '\n') {
        buffer[len - 1] = '\0';
    }
}

// 학생 정보 입력
int input_student(Student *student) {
    printf("\n=== 학생 정보 입력 ===\n");
    
    get_string_input(student->name, MAX_NAME_LENGTH, "이름: ");
    
    if (student->name[0] == '\0') {
        return 0;  // 빈 이름이면 입력 종료
    }
    
    printf("성적 입력 (국어, 영어, 수학): ");
    for (int i = 0; i < NUM_SUBJECTS; i++) {
        if (scanf("%d", &student->scores[i]) != 1) {
            printf("잘못된 입력입니다.\n");
            while (getchar() != '\n');  // 입력 버퍼 비우기
            return 0;
        }
    }
    while (getchar() != '\n');  // 입력 버퍼 비우기
    
    // 평균 계산
    int sum = 0;
    for (int i = 0; i < NUM_SUBJECTS; i++) {
        sum += student->scores[i];
    }
    student->average = (double)sum / NUM_SUBJECTS;
    
    return 1;  // 성공
}

// 학생 정보 출력
void print_student(const Student *student, int index) {
    printf("\n학생 #%d\n", index + 1);
    printf("  이름: %s\n", student->name);
    printf("  성적: ");
    for (int i = 0; i < NUM_SUBJECTS; i++) {
        printf("%d ", student->scores[i]);
    }
    printf("\n  평균: %.2f\n", student->average);
    printf("  등급: %c\n", calculate_grade(student->average));
}

// 전체 통계 계산
void calculate_statistics(const Student students[], int count) {
    if (count == 0) {
        printf("등록된 학생이 없습니다.\n");
        return;
    }
    
    double total_average = 0;
    int highest_index = 0;
    int lowest_index = 0;
    
    for (int i = 0; i < count; i++) {
        total_average += students[i].average;
        
        if (students[i].average > students[highest_index].average) {
            highest_index = i;
        }
        
        if (students[i].average < students[lowest_index].average) {
            lowest_index = i;
        }
    }
    
    total_average /= count;
    
    printf("\n=== 전체 통계 ===\n");
    printf("총 학생 수: %d\n", count);
    printf("전체 평균: %.2f\n", total_average);
    printf("최고 성적: %s (%.2f)\n", 
           students[highest_index].name, students[highest_index].average);
    printf("최저 성적: %s (%.2f)\n", 
           students[lowest_index].name, students[lowest_index].average);
    
    // 등급 분포 계산
    int grade_counts[5] = {0};  // A, B, C, D, F
    char grades[] = "ABCDF";
    
    for (int i = 0; i < count; i++) {
        char grade = calculate_grade(students[i].average);
        for (int j = 0; j < 5; j++) {
            if (grade == grades[j]) {
                grade_counts[j]++;
                break;
            }
        }
    }
    
    printf("\n등급 분포:\n");
    for (int i = 0; i < 5; i++) {
        printf("  %c: %d명 (%.1f%%)\n", 
               grades[i], grade_counts[i], 
               (double)grade_counts[i] / count * 100);
    }
}

int main(void) {
    Student students[MAX_STUDENTS];
    int student_count = 0;
    
    printf("학생 성적 관리 시스템\n");
    printf("빈 이름 입력 시 입력 종료\n");
    
    // 학생 정보 입력
    while (student_count < MAX_STUDENTS) {
        if (!input_student(&students[student_count])) {
            break;
        }
        student_count++;
    }
    
    // 입력된 학생 정보 출력
    printf("\n=== 입력된 학생 정보 ===\n");
    for (int i = 0; i < student_count; i++) {
        print_student(&students[i], i);
    }
    
    // 통계 계산
    calculate_statistics(students, student_count);
    
    // 이름으로 학생 검색
    char search_name[MAX_NAME_LENGTH];
    get_string_input(search_name, MAX_NAME_LENGTH, 
                     "\n검색할 학생 이름: ");
    
    if (search_name[0] != '\0') {
        printf("\n=== 검색 결과 ===\n");
        int found = 0;
        
        for (int i = 0; i < student_count; i++) {
            if (strstr(students[i].name, search_name) != NULL) {
                print_student(&students[i], i);
                found = 1;
            }
        }
        
        if (!found) {
            printf("'%s' 학생을 찾을 수 없습니다.\n", search_name);
        }
    }
    
    return 0;
}
```

## 주의사항과 모범 사례

### 1. 배열 경계 검사

배열 인덱스는 항상 유효한 범위 내에 있는지 확인하세요:

```c
#include <stdio.h>
#include <assert.h>

#define ARRAY_SIZE 10

void safe_array_access(int array[], int index) {
    // 인덱스 범위 검사
    if (index < 0 || index >= ARRAY_SIZE) {
        printf("오류: 인덱스 %d는 유효하지 않습니다 (0-%d)\n", 
               index, ARRAY_SIZE - 1);
        return;
    }
    
    printf("array[%d] = %d\n", index, array[index]);
}

// 또는 assert 사용 (디버그 모드에서만 활성화)
void debug_array_access(int array[], int index) {
    assert(index >= 0 && index < ARRAY_SIZE);
    printf("array[%d] = %d\n", index, array[index]);
}

int main(void) {
    int numbers[ARRAY_SIZE] = {0};
    
    // 안전한 접근
    safe_array_access(numbers, 5);   // 정상
    safe_array_access(numbers, 15);  // 오류 메시지 출력
    
    // 디버그용 접근
    debug_array_access(numbers, 5);  // 정상
    // debug_array_access(numbers, 15);  // assert 실패 (디버그 모드에서만)
    
    return 0;
}
```

### 2. 문자열 버퍼 오버플로 방지

문자열 작업 시 항상 버퍼 크기를 고려하세요:

```c
#include <stdio.h>
#include <string.h>

// 안전한 문자열 함수들
void safe_strcpy(char *dest, size_t dest_size, const char *src) {
    if (dest_size == 0) return;
    
    size_t src_len = strlen(src);
    size_t copy_len = src_len;
    
    if (copy_len >= dest_size) {
        copy_len = dest_size - 1;
    }
    
    memcpy(dest, src, copy_len);
    dest[copy_len] = '\0';
    
    if (copy_len < src_len) {
        printf("경고: 문자열이 잘렸습니다 (%zu 바이트 필요, %zu 바이트 사용 가능)\n",
               src_len + 1, dest_size);
    }
}

void safe_strcat(char *dest, size_t dest_size, const char *src) {
    size_t dest_len = strlen(dest);
    size_t src_len = strlen(src);
    
    if (dest_len >= dest_size) {
        printf("오류: 대상 버퍼가 이미 가득 찼습니다\n");
        return;
    }
    
    size_t remaining = dest_size - dest_len - 1;  // 널 문자 공간 제외
    
    if (src_len > remaining) {
        // 잘림 발생
        memcpy(dest + dest_len, src, remaining);
        dest[dest_size - 1] = '\0';
        printf("경고: 연결 중 문자열이 잘렸습니다\n");
    } else {
        // 정상 연결
        memcpy(dest + dest_len, src, src_len + 1);  // 널 문자 포함
    }
}

int main(void) {
    char buffer[10];
    
    // 안전한 복사
    safe_strcpy(buffer, sizeof(buffer), "Hello, World!");
    printf("결과: %s\n", buffer);
    
    // 안전한 연결
    strcpy(buffer, "Hi");
    safe_strcat(buffer, sizeof(buffer), " there, everyone!");
    printf("결과: %s\n", buffer);
    
    return 0;
}
```

### 3. 다차원 배열 성능 고려사항

캐시 친화적인 코드 작성:

```c
#include <stdio.h>
#include <time.h>

#define ROWS 1000
#define COLS 1000

int main(void) {
    int matrix[ROWS][COLS];
    clock_t start, end;
    
    // 행 우선 접근 (캐시 친화적)
    printf("행 우선 접근 테스트...\n");
    start = clock();
    
    int sum1 = 0;
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            matrix[i][j] = i + j;
            sum1 += matrix[i][j];
        }
    }
    
    end = clock();
    printf("소요 시간: %.4f초\n", (double)(end - start) / CLOCKS_PER_SEC);
    
    // 열 우선 접근 (캐시 비친화적)
    printf("\n열 우선 접근 테스트...\n");
    start = clock();
    
    int sum2 = 0;
    for (int j = 0; j < COLS; j++) {
        for (int i = 0; i < ROWS; i++) {
            matrix[i][j] = i + j;
            sum2 += matrix[i][j];
        }
    }
    
    end = clock();
    printf("소요 시간: %.4f초\n", (double)(end - start) / CLOCKS_PER_SEC);
    
    printf("\n두 방법의 결과가 동일한가? %s\n", 
           (sum1 == sum2) ? "예" : "아니오");
    
    return 0;
}
```

## 디버깅 팁

### 1. 배열 내용 출력 도우미 함수

```c
#include <stdio.h>

// 정수 배열 출력
void print_int_array(const char *name, const int *array, size_t size) {
    printf("%s[%zu] = {", name, size);
    for (size_t i = 0; i < size; i++) {
        printf("%d", array[i]);
        if (i < size - 1) printf(", ");
    }
    printf("}\n");
}

// 2차원 배열 출력
void print_2d_array(const char *name, const int *array, 
                    size_t rows, size_t cols) {
    printf("%s[%zu][%zu]:\n", name, rows, cols);
    for (size_t i = 0; i < rows; i++) {
        printf("  [");
        for (size_t j = 0; j < cols; j++) {
            printf("%4d", array[i * cols + j]);
            if (j < cols - 1) printf(", ");
        }
        printf("]\n");
    }
}

// 문자열 디버그 출력
void debug_string(const char *name, const char *str) {
    printf("%s = \"%s\"\n", name, str);
    printf("  길이: %zu\n", strlen(str));
    printf("  메모리 내용: ");
    for (size_t i = 0; str[i] != '\0'; i++) {
        printf("'%c'(%d) ", str[i], str[i]);
    }
    printf("'\\0'\n");
}

int main(void) {
    int numbers[] = {1, 2, 3, 4, 5};
    print_int_array("numbers", numbers, 5);
    
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
    print_2d_array("matrix", (int *)matrix, 2, 3);
    
    char text[] = "Hello";
    debug_string("text", text);
    
    return 0;
}
```

### 2. 배열 범위 검사 도구

```c
#include <stdio.h>
#include <stdlib.h>

#ifdef DEBUG
#define ARRAY_BOUNDS_CHECK
#endif

#ifdef ARRAY_BOUNDS_CHECK
#define ARRAY_ACCESS(array, index, size) \
    ( \
        ((index) < 0 || (index) >= (size)) ? \
        (printf("오류: %s[%d] (크기: %d)\n", #array, index, size), \
         exit(1), (array)[0]) : \
        (array)[index] \
    )
#else
#define ARRAY_ACCESS(array, index, size) ((array)[index])
#endif

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    
    // 안전한 접근
    printf("arr[2] = %d\n", ARRAY_ACCESS(arr, 2, 5));
    
    // 디버그 모드에서만 범위 검사
    // printf("arr[10] = %d\n", ARRAY_ACCESS(arr, 10, 5)); // 디버그 모드에서 오류
    
    return 0;
}
```

## 마무리

배열과 문자열은 C 프로그래밍의 기초 중의 기초입니다. 이들을 효과적으로 사용하기 위해서는:

1. **메모리 레이아웃 이해**: 배열이 메모리에 어떻게 저장되는지 이해하세요
2. **경계 검사 습관화**: 항상 인덱스가 유효한 범위 내에 있는지 확인하세요
3. **문자열은 널 문자로 끝난다**: 이 규칙을 잊지 마세요
4. **버퍼 크기 항상 고려**: 문자열 작업 시 항상 버퍼 크기를 확인하세요
5. **적절한 자료구조 선택**: 다차원 배열, 동적 배열 등 상황에 맞는 구조를 선택하세요

배열과 문자열을 마스터하면 C 언어로 복잡한 데이터 구조와 알고리즘을 구현하는 데 한 걸음 더 나아갈 수 있습니다. 연습을 통해 익숙해지면 자연스럽게 효율적이고 안전한 코드를 작성할 수 있을 것입니다.