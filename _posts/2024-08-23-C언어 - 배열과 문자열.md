---
layout: post
title: C - 배열과 문자열
date: 2024-08-23 19:20:23 +0900
category: C
---
# 배열과 문자열

## 워밍업: 배열·문자열 핵심을 한 번에

```c
#include <stdio.h>
#include <string.h>
#include <stdint.h>

#define COUNT_OF(a) (sizeof(a)/sizeof((a)[0])) // 배열에만 안전

static void print_ints(const int *p, size_t n) {
    for (size_t i=0;i<n;++i) printf("%d ", p[i]);
    puts("");
}

int main(void) {
    int numbers[5] = {10,20,30,40,50};
    printf("sizeof(numbers)=%zu (bytes)\n", sizeof numbers);     // 5*4=20
    printf("COUNT_OF(numbers)=%zu\n", COUNT_OF(numbers));         // 5

    int *p = numbers;    // 배열→포인터 디케이
    // 주의: sizeof(p)는 포인터 크기(4/8), 배열 전체 크기 아님
    printf("sizeof(p)=%zu\n", sizeof p);

    print_ints(numbers, COUNT_OF(numbers)); // 길이는 별도로 전달

    char s[]  = "Hello";           // 수정 가능(스택 배열)
    const char *t = "World";       // 리터럴: 읽기 전용 메모리
    s[0]='h';                      // OK
    // t[0]='w';                   // UB(금지): 리터럴은 수정하면 안 됨
    printf("%s %s\n", s, t);

    // 안전 연결: 남은 공간 고려
    strncat(s, "!", (sizeof s - strlen(s) - 1));
    printf("%s\n", s);
    return 0;
}
```

---

## 배열이란?

- **같은 타입**의 요소들이 **연속(contiguous)** 메모리에 배치된 구조.
- 선언 시 **길이가 고정**되며(정적/자동/VLA), 이름은 대부분의 표현식에서 **첫 요소의 주소로 디케이**합니다.

```c
int numbers[5] = {10, 20, 30, 40, 50};
```

- 인덱스는 0부터 시작: `numbers[i]`는 *(numbers + i)* 와 동일.
- 예외적으로 **`sizeof numbers`**와 **`&numbers`**에서는 **디케이하지 않음**.

---

## 1차원 배열 — 인덱스 vs 포인터

```c
#include <stdio.h>

int main(void) {
    int scores[4] = {90,85,78,92};

    for (int i=0;i<4;i++) printf("%d ", scores[i]);
    puts("");

    int *p = scores;              // int (*) → first element
    for (int i=0;i<4;i++) printf("%d ", *(p+i));
    puts("");

    return 0;
}
```

### `sizeof` / 길이 구하기

```c
size_t n = sizeof scores / sizeof scores[0]; // 배열에서만 유효
```

> 함수 인자로 전달되면 **포인터**로 취급되어 `sizeof`가 **포인터 크기**가 됩니다.
> → 길이는 **항상 함께** 전달하세요.

---

## 2차원 배열 — 메모리 모델과 올바른 인자 선언

```c
#include <stdio.h>

int main(void) {
    int matrix[2][3] = { {1,2,3}, {4,5,6} };

    for (int i=0;i<2;i++){
        for (int j=0;j<3;j++) printf("%d ", matrix[i][j]);
        puts("");
    }

    // 포인터로 접근 (정확한 타입)
    int (*p)[3] = matrix; // "길이 3의 int 배열"을 가리키는 포인터
    printf("%d %d\n", p[0][1], p[1][2]); // 2 6

    // 1차원처럼 평면화
    int *q = (int*)matrix;
    for (int k=0; k<2*3; ++k) printf("%d ", q[k]); // 1 2 3 4 5 6
    puts("");
    return 0;
}
```

### 행-주도(row-major) 저장과 인덱스 수식

$$
\text{addr}(i,j) = \text{base} + (i \cdot \text{COLS} + j) \cdot \text{sizeof(int)}
$$

> C는 **row-major** (행 우선). 파이썬/넘파이(기본)와 동일, 포트란은 **column-major**.

### 함수 인자로 2D 배열을 받을 때

```c
void print_2d(int rows, int cols, int a[rows][cols]);      // VLA
void print_2d_fixed(int a[2][3]);                          // 고정 크기
void print_2d_ptr(int (*a)[3], int rows);                  // 포인터 to [3]
```

> **열 크기**(inner dimension)는 **컴파일러가 필요**로 합니다. 모른다면 **VLA 매개변수**를 쓰세요(C99+).

---

## 3차원 배열 — 인덱싱과 평면화

{% raw %}
```c
int cube[2][2][2] = {
    {{1,2},{3,4}},
    {{5,6},{7,8}}
};
printf("%d\n", cube[1][0][1]); // 6
```
{% endraw %}

주소 수식(각 차원의 크기를 \(D_0,D_1,D_2\)라 할 때):

$$
\text{addr}(i,j,k) = \text{base} + \big((i\cdot D_1 + j)\cdot D_2 + k\big)\cdot \text{sizeof(T)}
$$

---

## 정적 vs 동적 2D — “연속 공간”과 “포인터 배열”의 차이

### 한 덩어리(연속)로 할당

```c
int rows=3, cols=4;
int *a = malloc((size_t)rows * cols * sizeof *a); // [rows*cols]
a[r*cols + c] = 42;
free(a);
```

- 장점: 캐시 친화/`memcpy` 가능.
- 단점: `a[r][c]` 표기 불가(매크로/래퍼로 해결).

### “배열의 배열” (포인터 배열)

```c
int **b = malloc(rows * sizeof *b);
b[0] = malloc(rows*cols*sizeof *b[0]);
for (int r=1; r<rows; ++r) b[r] = b[0] + r*cols; // 행 포인터를 같은 블록으로
// 이제 b[r][c] 사용 가능, 그리고 연속 메모리 장점도 유지
free(b[0]);
free(b);
```

> **주의**: `rows` 개 각각 `malloc`하면 **행마다 분리**되어 `memcpy`/I/O가 비효율적일 수 있습니다.
> 위처럼 **한 덩어리 + 포인터 테이블**을 권장.

---

## `char`와 문자

- `char`는 **1바이트 정수형**. `signed char`/`unsigned char`는 구현 의존.
- **문자 리터럴**: `'A'`, `'1'`, `'\n'` 등은 실제로 **정수 값**.

```c
char ch='A';
printf("%c %d\n", ch, ch); // A 65
```

> 바이트 처리/이미지/파일 I/O에는 **`unsigned char`** 또는 `uint8_t` 사용을 권장.

---

## 문자열 — `char[]` + **널 종료 `\0`**

```c
char str1[] = "Hello";                    // {'H','e','l','l','o','\0'}
char str2[] = {'H','e','l','l','o','\0'}; // 동일
```

- **반드시 `\0`**로 종료, 미종료 시 `printf("%s")` 등에서 **UB**.
- **문자열 리터럴**은 읽기 전용(대부분 `.rodata`). **수정 금지**.

```c
const char *p = "World";  // 올바른 선언
// ((char*)p)[0]='w';     // UB: 금지
```

---

## 문자열 함수 `<string.h>` — 안전 패턴과 함정

| 함수 | 핵심 |
|---|---|
| `strlen(s)` | 종료 널 이전 길이 |
| `strcpy(dst,src)` | **버퍼 크기 미검사**(주의) |
| `strncpy(dst,src,n)` | **널 보장 안 함** → 수동으로 `dst[n-1]='\0'` 필요 |
| `strcat(dst,src)` | **버퍼 크기 미검사**(주의) |
| `strncat(dst,src,n)` | `n`은 **추가할 최대 수**, 남은 공간 고려 |
| `strcmp(a,b)`/`strncmp` | 사전식 비교 |
| `strchr`/`strrchr` | 문자 검색 |
| `strstr` | 부분 문자열 검색 |
| `memcpy`/`memmove` | 바이트 단위 복사(겹침 시 `memmove`) |
| `memset` | 바이트 채우기 |

> `strlcpy/strlcat`는 **비표준**(BSD/일부 libc). 휴대성 중시 시 직접 래퍼 작성.

### 안전 복사/연결 래퍼 예

```c
#include <string.h>

int safe_copy(char *dst, size_t cap, const char *src) {
    if (cap==0) return -1;
    size_t n = strlen(src);
    if (n >= cap) { // 잘림
        memcpy(dst, src, cap-1);
        dst[cap-1]='\0';
        return 1;   // 1=truncated
    }
    memcpy(dst, src, n+1);
    return 0;       // 0=ok
}

int safe_cat(char *dst, size_t cap, const char *src) {
    size_t d = strlen(dst);
    if (d >= cap) return -1;               // 잘못된 입력
    size_t space = cap - d - 1;
    size_t n = strlen(src);
    if (n > space) n = space;
    memcpy(dst+d, src, n);
    dst[d+n] = '\0';
    return (n == strlen(src)) ? 0 : 1;     // 1=truncated
}
```

---

## `fgets`로 안전 입력 + 숫자 파싱

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

int read_line(char *buf, size_t cap) {
    if (!fgets(buf, cap, stdin)) return 0;
    // 개행 제거(있다면)
    size_t n = strlen(buf);
    if (n && buf[n-1]=='\n') buf[n-1]='\0';
    return 1;
}

int main(void){
    char buf[64];
    if (!read_line(buf, sizeof buf)) return 1;

    errno=0; char *end=NULL;
    long v = strtol(buf, &end, 10);
    if (errno==ERANGE || end==buf) { puts("invalid"); return 1; }
    printf("v=%ld\n", v);
    return 0;
}
```

> `gets`는 **금지**. `scanf("%s",buf)`도 공백/길이 문제로 주의.

---

## `strtok`의 상태성/대안

```c
char s[]="apple,banana,orange";
for (char *tok=strtok(s, ","); tok; tok=strtok(NULL, ",")) {
    puts(tok);
}
```

- **동작 중 전역 상태 유지** → 스레드/중첩 파싱에 취약.
- **대안**: POSIX `strtok_r`(재진입 가능) 또는 **수동 스캐닝**.

수동 스캐닝 예:
```c
#include <string.h>
#include <stdio.h>

void split_commas(char *s){
    char *start=s, *cur=s;
    while (*cur) {
        if (*cur==',') {
            *cur='\0'; puts(start);
            start = cur+1;
        }
        ++cur;
    }
    if (start!=cur) puts(start);
}

int main(void){
    char s[]="apple,banana,orange";
    split_commas(s);
}
```

---

## 배열 vs 포인터 — **표기 동일성**의 함정 6가지

1) **디케이**: 대부분의 표현식에서 `T[N]` → `T*`.
2) **`sizeof`**: 배열에는 전체 바이트, 포인터에는 포인터 크기.
3) **`&array`**: 타입은 `T (*)[N]`(“배열에 대한 포인터”), `&array[0]`과 다름.
4) **함수 매개변수**: `int a[]`와 `int *a`는 동일한 선언.
5) **인덱스 표기**: `a[i]` ↔ `*(a+i)` ↔ `i[a]`(가능하지만 쓰지 말 것).
6) **다차원**: `int a[R][C]` → **열 크기 C 필요**. `int (*p)[C]`로 받아라.

확인 예:
```c
int a[3]={1,2,3};
int (*pa)[3] = &a; // OK: 전체 배열의 주소
// int **pp = &a;  // 잘못된 타입
```

---

## 문자 배열 vs 문자열 포인터 — 정확한 정리

```c
char s[] = "Hello";          // 스택의 수정 가능한 배열
const char *p = "World";     // 읽기 전용 리터럴을 가리킴
s[0] = 'h';                  // OK
// p[0] = 'w';               // 금지(UB)
p = "world";                 // 다른 리터럴을 가리키도록 변경 OK
```

- C 표준에서 문자열 리터럴을 **수정하는 동작은 UB**.
- **항상 `const char *`** 로 받으면 실수를 방지.

---

## UTF-8와 “문자 개수” 오해

- `strlen`은 **바이트 수**(널 제외)를 반환.
- UTF-8에서 한 “문자”(유니코드 스칼라 값)는 **1~4바이트**.
- “문자 길이”가 필요하면 **라이브러리** 사용 또는 직접 디코딩.

---

## 바이너리 데이터와 `char*`/`unsigned char*`

- 이진 버퍼는 **`unsigned char*`** 가 관례.
- `memcpy/memcmp/memchr` 등 **메모리 함수** 사용.

```c
unsigned char buf[4] = {0xDE,0xAD,0xBE,0xEF};
for (size_t i=0;i<sizeof buf;i++) printf("%02X ", buf[i]);
puts("");
```

---

## 실전 예제 모음

### 최대 길이 N까지 안전하게 읽어 연결

```c
#include <stdio.h>
#include <string.h>

int main(void){
    char name[32] = "";
    char add[32]  = "";

    printf("name: ");
    if (!fgets(name, sizeof name, stdin)) return 1;
    if (name[0] && name[strlen(name)-1]=='\n') name[strlen(name)-1]='\0';

    printf("add: ");
    if (!fgets(add, sizeof add, stdin)) return 1;
    if (add[0] && add[strlen(add)-1]=='\n') add[strlen(add)-1]='\0';

    // 남은 공간 계산 후 연결
    size_t cap = sizeof name;
    strncat(name, " ", cap - strlen(name) - 1);
    strncat(name, add, cap - strlen(name) - 1);

    printf("=> %s\n", name);
    return 0;
}
```

### 2D 합계(정적/동적 모두 적용 가능한 인덱싱)

```c
int sum_2d(const int *a, int rows, int cols) {
    int s=0;
    for (int r=0;r<rows;++r)
        for (int c=0;c<cols;++c)
            s += a[r*cols + c];
    return s;
}
```

### 고정 열 3의 2D를 함수로 받기

```c
int sum_2d_3cols(int (*m)[3], int rows) {
    int s=0;
    for (int r=0;r<rows;++r)
        for (int c=0;c<3;++c)
            s += m[r][c];
    return s;
}
```

### 문자열 뒤집기(제자리)

```c
void reverse_str(char *s) {
    size_t n = strlen(s);
    for (size_t i=0, j=n? n-1:0; i<j; ++i, --j) {
        char t=s[i]; s[i]=s[j]; s[j]=t;
    }
}
```

### 부분 문자열 카운트(겹침 허용)

```c
size_t count_substr(const char *hay, const char *nee) {
    if (!*nee) return 0;
    size_t cnt=0;
    for (const char *p=hay; (p=strstr(p,nee)); ++p) ++cnt;
    return cnt;
}
```

---

## 테스트 체크리스트(배열·문자열)

- **경계**: 빈 문자열, 정확히 버퍼 크기-1, 널 미종료 입력.
- **국제화**: 멀티바이트 문자 포함 시 바이트/코드포인트 혼동 방지.
- **다차원**: 행/열 경계, 평면화 인덱스 검증.
- **API 계약**: 함수 인자(`const`, 길이) 문서화, 잘림(truncation) 신호.
- **메모리**: 동적 2D의 단일 블록/포인터 테이블 해제 순서.

---

## 요약

| 주제 | 핵심 |
|---|---|
| 배열↔포인터 | 대부분 디케이, **`sizeof`/`&` 예외** |
| 2D 인자 | `int (*p)[C]` 또는 VLA(`int a[r][c]`) |
| 동적 2D | **단일 블록 + 포인터 테이블** 권장 |
| 문자열 | `char[]` + `\0`, 리터럴은 **수정 금지** |
| 안전 API | `fgets` + 수동 파싱, `memcpy/memmove`, 안전 래퍼 |
| UTF-8 | `strlen`은 **바이트 수**, 문자 수 아님 |
