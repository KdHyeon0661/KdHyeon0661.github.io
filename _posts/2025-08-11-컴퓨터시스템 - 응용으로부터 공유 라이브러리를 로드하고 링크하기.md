---
layout: post
title: 컴퓨터시스템 - 응용으로부터 공유 라이브러리를 로드하고 링크하기
date: 2025-08-11 19:20:23 +0900
category: 컴퓨터시스템
---
# 응용으로부터 공유 라이브러리를 로드하고 링크하기
> **주제**: 실행 중에 프로그램이 직접 `.so`(공유 라이브러리)를 로드/탐색/해제하는 기법  
> **키워드**: `dlopen`, `dlsym`, `dlclose`, `dlerror`, `RTLD_*`, PLT/GOT, ABI, 플러그인

이 글은 ELF/리눅스·glibc 환경을 기준으로, **CS:APP의 Linking 챕터** 흐름에서 “응용이 런타임에 공유 라이브러리를 조작하는 방법”을 **C 코드 예제**와 함께 자세히 다룬다.  
아래 모든 C 예제 코드는 `-ldl`을 링크해야 한다.

```bash
gcc app.c -ldl -o app
```

---

## 1) 왜 런타임 로딩인가?
- **선택적 의존성(Optional dependency)**: 사용자가 특정 기능을 쓰는 경우에만 라이브러리를 로드.
- **플러그인 아키텍처(확장성)**: 외부 모듈을 독립 배포하고 실행 중에 끼워 넣는다.
- **A/B 스위칭/하위호환**: 시스템/하드웨어에 맞춰 적절한 구현을 선택.
- **프로세스 메모리 최적화**: 필요할 때만 메모리를 사용하고, 안 쓰면 해제.

---

## 2) 기본 API — `dlopen`/`dlsym`/`dlclose`/`dlerror`

### 2.1 `dlopen`
```c
#include <dlfcn.h>
void *dlopen(const char *filename, int flags);
```
- **filename**: 경로 또는 라이브러리 이름(예: `"libm.so.6"`). `NULL`이면 **메인 프로그램**의 핸들.
- **flags**:
  - `RTLD_LAZY`: 심볼 바인딩을 **지연**(첫 호출 시).
  - `RTLD_NOW`: 로드 시점에 **즉시** 바인딩(검증 강함, 시작 느림).
  - `RTLD_GLOBAL`: 이후에 로드되는 DSO가 **이 라이브러리의 심볼을 전역 탐색**에서 볼 수 있게 함(인터포지션 영향).
  - `RTLD_LOCAL`: 심볼을 로컬 범위에 한정(기본값).
  - `RTLD_NODELETE`(glibc): `dlclose` 후에도 언로드하지 않음(재사용/안정성).
  - `RTLD_NOLOAD`: 이미 로드돼 있으면 핸들만 얻고, 아니면 실패(상태 확인 용도).

> 보안/성능 팁: 기본은 `RTLD_NOW | RTLD_LOCAL`을 권장.  
> 전역 심볼 노출이 필요한 이유(플러그인이 다른 플러그인을 참조) 없으면 `RTLD_GLOBAL`은 피한다.

### 2.2 `dlsym`
```c
void *dlsym(void *handle, const char *symbol);
```
- `handle` 은 `dlopen` 결과 또는 특수 핸들(`RTLD_DEFAULT`, `RTLD_NEXT`).
- 반환은 **함수 포인터가 아닌 `void*`** → 함수에 쓸 때는 적절한 타입으로 변환해야 한다.
- 오류는 `dlsym` 직후 `dlerror()`로 확인.

### 2.3 `dlclose`
```c
int dlclose(void *handle);
```
- 참조 카운트를 줄이고 0이 되면 **언로드**(코드/데이터 해제, DTOR 호출).
- 다른 스레드가 해당 코드 안에서 실행 중일 수 있으므로 **언로드 타이밍** 주의.

### 2.4 `dlerror`
```c
char *dlerror(void);
```
- 스레드 로컬 에러 문자열을 반환. **호출 즉시 복사**해 두는 습관이 안전.

---

## 3) 검색 경로와 보안
동적 링커가 `.so`를 찾는 순서(일반적인 규약)  
1) **절대 경로**를 주면 그대로 사용.  
2) `DT_RUNPATH`(또는 구식 `DT_RPATH`), `LD_LIBRARY_PATH`  
3) `/etc/ld.so.cache` (ldconfig)  
4) 표준 경로 `/lib`, `/usr/lib`, `/lib64`, `/usr/lib64` …

> **보안**: setuid 바이너리 등에서는 `LD_LIBRARY_PATH` 무시.  
> 배포 시 **RUNPATH**와 **`$ORIGIN`** 사용을 고려(실행 파일 위치 상대 경로).  
> `RPATH`는 현대 환경에서 비권장.

---

## 4) 심볼 탐색 스코프와 특수 핸들
- `dlsym(RTLD_DEFAULT, "name")`: 현재 프로세스 전체 전역 스코프에서 탐색.
- `dlsym(RTLD_NEXT, "name")`: **호출자 다음** 라이브러리 체인에서 탐색(인터포지션 구현에 유용).
- `dlopen(NULL, ...)`: 메인 프로그램 핸들 획득.
- glibc 확장:
  - `dlvsym(handle, "name", "VER")`: **버전 지정 심볼** 탐색.
  - `dlmopen(LMID_NEWLM, "lib.so", flags)`: **새 로더 네임스페이스**(충돌 격리).

---

## 5) 수명과 초기화/종료 훅
- `.so` 내부의 **전역 생성자/소멸자**:
  - `__attribute__((constructor))` / `__attribute__((destructor))`
  - 또는 `.init_array` / `.fini_array` 섹션
- `dlopen` 시 **생성자** 실행, `dlclose` 시 **소멸자** 실행.
- **주의**: 생성자에서 `dlopen`/`dlsym` 재귀 호출 시 순서/재진입성 고려.

---

## 6) 스레드 안전성과 동시성
- glibc의 `dlopen/dlsym/dlclose`는 내부적으로 락을 사용해 **함수 호출 자체는 스레드 안전**.  
- 그러나 **언로드 시점**에 다른 스레드가 해당 코드 실행 중이면 **use-after-free** 위험.
  - 해결: 플러그인마다 **참조 카운팅**(자체 락) 또는 **작업 중인 스레드 수**를 추적한 뒤 안전 시 `dlclose`.
  - 또는 `RTLD_NODELETE`로 일시적 언로드 금지(메모리 누수 주의).

---

## 7) C 예제 — 가장 작은 형태

```c
// tiny.c
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>

typedef double (*sqrt_fn)(double);

int main(void){
    void *h = dlopen("libm.so.6", RTLD_NOW | RTLD_LOCAL);
    if (!h) { fprintf(stderr, "dlopen: %s\n", dlerror()); return 1; }

    dlerror(); // 에러 플래그 클리어
    sqrt_fn my_sqrt = (sqrt_fn)dlsym(h, "sqrt");
    const char *err = dlerror();
    if (err) { fprintf(stderr, "dlsym: %s\n", err); dlclose(h); return 1; }

    printf("sqrt(2) = %.6f\n", my_sqrt(2.0));
    dlclose(h);
    return 0;
}
```

빌드:
```bash
gcc tiny.c -ldl -o tiny
./tiny
```

---

## 8) 플러그인 인터페이스 설계(안정적 ABI)

**문제**: 플러그인과 호스트가 **ABI(바이너리 호환)** 를 공유해야 한다.  
**해법**: “C” 기반의 **작은 vtable 구조체** + **버전 필드**를 내보낸다.

### 8.1 플러그인 API 헤더 (호스트·플러그인 공용)
```c
// plugin_api.h
#pragma once
#ifdef __cplusplus
extern "C" {
#endif

#define PLUGIN_API_VERSION 0x00010002u  // major.minor 패킹 예

typedef struct PluginAPI {
    unsigned int version;   // PLUGIN_API_VERSION
    const char *name;       // 플러그인 이름
    int  (*init)(void);
    int  (*process)(const void *in, void *out, int n);
    void (*fini)(void);
} PluginAPI;

// 플러그인은 아래 심볼을 정의해 호스트가 dlsym으로 얻는다.
extern const PluginAPI plugin_api;

#ifdef __cplusplus
}
#endif
```

### 8.2 플러그인 구현 예
```c
// plugin_echo.c
#include "plugin_api.h"
#include <stdio.h>

static int my_init(void){ puts("[echo] init"); return 0; }
static int my_process(const void *in, void *out, int n){
    // 단순 에코: out <- in (바이트 단위 복사)
    const unsigned char *src = (const unsigned char*)in;
    unsigned char *dst = (unsigned char*)out;
    for (int i=0;i<n;i++) dst[i]=src[i];
    return n;
}
static void my_fini(void){ puts("[echo] fini"); }

const PluginAPI plugin_api = {
    .version = PLUGIN_API_VERSION,
    .name    = "echo",
    .init    = my_init,
    .process = my_process,
    .fini    = my_fini
};
```

빌드:
```bash
gcc -fPIC -shared plugin_echo.c -o libplugin_echo.so
```

### 8.3 호스트 로더
```c
// host.c
#include "plugin_api.h"
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void *open_so(const char *path, int flags){
    void *h = dlopen(path, flags);
    if (!h) fprintf(stderr, "dlopen(%s): %s\n", path, dlerror());
    return h;
}

int main(int argc, char **argv){
    if (argc < 2) { fprintf(stderr, "usage: %s ./libplugin_echo.so\n", argv[0]); return 2; }

    void *h = open_so(argv[1], RTLD_NOW | RTLD_LOCAL);
    if (!h) return 1;

    dlerror(); // clear
    const PluginAPI *api = (const PluginAPI*)dlsym(h, "plugin_api");
    const char *err = dlerror();
    if (err || !api) { fprintf(stderr, "dlsym(plugin_api): %s\n", err); dlclose(h); return 1; }

    if (api->version != PLUGIN_API_VERSION) {
        fprintf(stderr, "ABI mismatch: plugin %x != host %x\n", api->version, PLUGIN_API_VERSION);
        dlclose(h); return 1;
    }
    if (api->init && api->init()!=0) { fprintf(stderr, "init failed\n"); dlclose(h); return 1; }

    const char msg[] = "hello";
    char buf[32]={0};
    int k = api->process(msg, buf, (int)strlen(msg)+1);
    printf("[host] result: %s (n=%d)\n", buf, k);

    if (api->fini) api->fini();
    dlclose(h);
    return 0;
}
```

빌드 & 실행:
```bash
gcc host.c -ldl -o host
./host ./libplugin_echo.so
```

**포인트**
- **C ABI** 사용(헤더에 `extern "C"` 보호) → C++ 네임 맹글링 회피.
- **버전 필드**로 호환성 체크.
- **함수 포인터 테이블(vtable)** 로 API 확장 시 **뒤에 필드 추가** 패턴을 사용(하위호환 유지).

---

## 9) 에러 처리 패턴(권장)
```c
#define DLOK(x) do { dlerror(); (x); const char* e = dlerror(); \
  if (e) { fprintf(stderr, "[dl] %s failed: %s\n", #x, e); goto FAIL; } } while(0)
```
- `dlerror()`는 상태를 읽으면서 **초기화**하므로, 호출 직전/직후에 즉시 확인.

---

## 10) Lazy vs Now, 성능·안정성 트레이드오프
- `RTLD_LAZY`: 시작은 빠르지만 첫 호출 때마다 PLT 트램폴린을 거쳐 바인딩(분기 예측에 따라 미미한 오버헤드).
- `RTLD_NOW`: 로드 실패를 초기에 발견, **런타임 안정성**↑. 대형 DSO는 시작이 느릴 수 있음.
- `LD_BIND_NOW=1`: 시스템/사용자 정책으로 즉시 바인딩 강제(디버깅/지연 제거).

---

## 11) RTLD_GLOBAL의 의미와 주의
- A를 `RTLD_GLOBAL`로 열면, 이후 `dlopen`되는 B가 심볼 해석 시 **A의 심볼을 전역 스코프**에서 볼 수 있다.
- 장점: 플러그인 간 공통 심볼 공유/후킹 가능.  
- 단점: **인터포지션·충돌·의존성 암묵화** 위험 → 디버깅 난이도↑.  
- 가급적 `RTLD_LOCAL` 기본, 꼭 필요한 경우만 사용.

---

## 12) 데이터 심볼과 TLS
- `dlsym`은 **함수뿐 아니라 데이터 심볼**에도 사용 가능(전역 변수 주소).
- TLS(Thread-Local Storage) 심볼은 **TLS 재배치**를 거치므로 성능/호환 이슈가 있을 수 있다.
- 고성능 경로에서는 TLS 접근 모델(LE/IE 등)과 컴파일러 옵션을 일치시켜야 한다.

---

## 13) 디버깅/진단 도구
```bash
ldd ./host                 # 필요한 .so 확인
LD_DEBUG=libs,bindings ./host ./libplugin_echo.so 2>&1 | less  # 로딩/바인딩 로그
LD_DEBUG=reloc ./host ...  # 재배치 로그
readelf -dW ./libplugin_echo.so  # .dynamic 확인 (NEEDED/RUNPATH 등)
objdump -T ./libplugin_echo.so   # 동적 심볼 테이블 확인
```

---

## 14) 고급: 네임스페이스 분리(dlmopen, glibc)
- `dlmopen(LMID_NEWLM, "libX.so", flags)` 으로 **독립된 로더 네임스페이스**를 만든다.
- 효과: 같은 이름의 심볼/라이브러리 충돌을 격리(서로 다른 버전 공존 등).
- 제약: 상호 참조/전역 공유가 어려워짐, 플랫폼 의존성↑.

---

## 15) C++과의 경계
- C++ 함수는 **네임 맹글링** → `dlsym` 이름이 달라짐.  
  해결: **플러그인 API는 C로 노출**(`extern "C"`).
- 예외/RTTI/템플릿 등은 **DSO 경계**를 넘나들 때 ABI 민감 → 가급적 **C ABI**.

---

## 16) 흔한 함정과 체크리스트
- [ ] `-ldl` 링크를 잊지 않았는가?  
- [ ] `dlerror()`를 즉시 확인했는가? (다른 라이브러리 호출 사이에 값이 지워짐)  
- [ ] 함수 포인터 변환이 올바른가? (`typedef` 로 명확히)  
- [ ] `RTLD_GLOBAL` 남용으로 심볼 충돌을 만들지 않았는가?  
- [ ] 플러그인 언로드 시 다른 스레드가 실행 중이 아님을 보장했는가?  
- [ ] ABI 버전 필드/사이즈 체크를 했는가?  
- [ ] 검색 경로를 안전하게 구성했는가? (`RUNPATH`, `$ORIGIN`, setuid 환경)  
- [ ] 생성자/소멸자에서의 부작용(재진입, 순환 의존)을 점검했는가?

---

## 17) 보너스: 런타임 바인딩으로 “다음” 심볼 호출
인터포지션 구현에서 **원래 구현**을 부르는 패턴:
```c
// my_malloc.c — LD_PRELOAD로 주입
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>

void* malloc(size_t n){
    static void* (*real_malloc)(size_t) = NULL;
    if (!real_malloc) real_malloc = (void*(*)(size_t)) dlsym(RTLD_NEXT, "malloc");
    void *p = real_malloc(n);
    fprintf(stderr, "[hook] malloc(%zu) -> %p\n", n, p);
    return p;
}
```
빌드:
```bash
gcc -fPIC -shared my_malloc.c -ldl -o my_malloc.so
LD_PRELOAD=./my_malloc.so your_app
```

---

## 18) 요약
- **dlopen/dlsym/dlclose** 로 응용이 실행 중에 공유 라이브러리를 **로드/탐색/해제**한다.
- 기본 전략은 **`RTLD_NOW | RTLD_LOCAL`**, 필요할 때만 `GLOBAL`/`LAZY`/`NODELETE`.  
- 플러그인 ABI는 **C 기반 vtable + 버전 필드**로 안정화하라.  
- 언로드/동시성, 검색 경로/보안, 인터포지션/충돌을 고려하고, **디버깅 툴**로 확인하라.
