---
layout: post
title: 컴퓨터시스템 - 응용으로부터 공유 라이브러리를 로드하고 링크하기
date: 2025-08-11 19:20:23 +0900
category: 컴퓨터시스템
---
# 응용으로부터 공유 라이브러리를 로드하고 링크하기

## 0. 한눈 요약

- **기본 4총사**: `dlopen`(로드) · `dlsym`(심볼 조회) · `dlerror`(오류 문자열) · `dlclose`(언로드).  
- **권장 플래그**: 기본은 **`RTLD_NOW | RTLD_LOCAL`** (즉시 바인딩 + 로컬 범위).  
- **검색 경로**: 절대경로 우선 → `RUNPATH`/`LD_LIBRARY_PATH` → `/etc/ld.so.cache` → 표준 경로. 배포는 **`$ORIGIN`** 선호.  
- **ABI**: C 기반 **vtable(함수 포인터 구조체)** + **버전 필드**로 안정화.  
- **스레드/안전**: 호출 자체는 스레드 안전이나 **언로드 타이밍**이 함정. 필요 시 `RTLD_NODELETE`.  
- **고급**: `RTLD_DEFAULT/NEXT`(인터포지션), `dladdr`(역탐색), `dlinfo`/`link_map`(메타), `dlmopen`(네임스페이스), `dlvsym`(버전), TLS·IFUNC 주의.  
- **보안**: setuid에서 환경변수 무시, `RUNPATH`/서명/샌드박스/RELRO+NOW, 플러그인 디렉터리 고정.

---

## 1. 왜 런타임 로딩인가?

- **선택적 의존성**: 사용자가 기능을 쓸 때만 로드 → 메모리/스타트업 최적화.  
- **플러그인 아키텍처**: 독립 배포·핫스왑·서드파티 확장.  
- **환경 적응**: CPU/라이브러리/드라이버에 따라 구현 선택(예: AVX2/NEON).  
- **무중단 교체**: 새 버전 라이브러리를 곁줄기에서 로드해 스위칭.

**비용 모델(개념)**  
초기화 지연을 허용할 때 기대 지연은 대략
$$
T_{\text{lazy}} \approx p\cdot C_{\text{bind}} + T_{\text{call}}
$$
여기서 \(p\)는 “해당 API를 적어도 한 번 호출할 확률”, \(C_{\text{bind}}\)는 **첫 바인딩 비용**. 자주 호출되면 `RTLD_NOW`가 더 낫다.

---

## 2. 기본 API — 시그니처와 관례

### 2.1 `dlopen`
```c
#include <dlfcn.h>
void *dlopen(const char *filename, int flags);
```
- **filename**: 절대/상대 경로, `"libm.so.6"`, 또는 `NULL`(메인 프로그램).  
- **flags**:
  - `RTLD_LAZY` | `RTLD_NOW` — 지연/즉시 바인딩
  - `RTLD_LOCAL` | `RTLD_GLOBAL` — 심볼 공개 범위
  - `RTLD_NODELETE` — `dlclose` 후에도 언로드 금지(재사용/안정)
  - `RTLD_NOLOAD` — 로드하지 않고 기존 핸들만 획득(상태 확인)

> **실무 기본값**: `RTLD_NOW | RTLD_LOCAL` (초기 실패 조기 발견, 전역 오염 방지)

### 2.2 `dlsym`
```c
void *dlsym(void *handle, const char *symbol);
```
- `handle`: `dlopen` 결과 또는 **`RTLD_DEFAULT`**, **`RTLD_NEXT`**.  
- 반환은 `void*` → **반드시 정확한 함수 포인터 타입으로 캐스팅**.

### 2.3 `dlclose`
```c
int dlclose(void *handle);
```
- 내부 참조 카운트 감소, 0이면 언로드 및 `.fini_array`/소멸자 호출.

### 2.4 `dlerror`
```c
char *dlerror(void);  // TLS 기반, 즉시 복사 권장
```

**에러 처리 습관**
```c
#define DLOK(x) do { dlerror(); (x); char* e = dlerror(); \
  if (e){ fprintf(stderr, "[dl] %s: %s\n", #x, e); goto FAIL; } } while(0)
```

---

## 3. 검색 경로, RUNPATH, 보안

탐색 순서(요지):
1) **절대경로** 그대로  
2) **`DT_RUNPATH`** (또는 구식 `DT_RPATH`) · `LD_LIBRARY_PATH`  
3) `/etc/ld.so.cache`  
4) 표준 경로 `/lib*`, `/usr/lib*`

- **배포 팁**: 실행 파일과 상대인 **`$ORIGIN`** 활용.
```bash
# 예) rpath 대신 현대적 RUNPATH로
gcc app.c -Wl,-rpath,'$ORIGIN/../lib' -o app
```
- **보안**: setuid·보안모드에서는 `LD_LIBRARY_PATH` 등 **무시**.  
- **폴더 고정**: 플러그인 디렉터리 화이트리스트, 사용자 입력 경로 거부.

---

## 4. 스코프·특수 핸들·인터포지션

- `dlsym(RTLD_DEFAULT, "name")` : 전역 스코프에서 탐색(실행파일 → NEEDED 순).  
- `dlsym(RTLD_NEXT, "name")` : **현재 호출자 다음** 체인부터 탐색(후킹 시 “원본” 호출).  
- `dlopen(NULL, ...)` : 메인 프로그램 핸들.  
- 확장: `dlvsym(handle, "name", "VER")`(버전 지정), `dlmopen`(네임스페이스).

**예: 원래 malloc 호출하기**
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdlib.h>
void* malloc(size_t n){
  static void* (*real)(size_t);
  if (!real) real = (void*(*)(size_t)) dlsym(RTLD_NEXT, "malloc");
  return real(n);
}
```

---

## 5. 수명 — 생성자/소멸자, 초기화 순서

- `.init_array` / `__attribute__((constructor))` 는 `dlopen` 시 실행.  
- `.fini_array` / `__attribute__((destructor))` 는 `dlclose` 시 실행.  
- **주의**: 생성자에서 다른 `dlopen` 호출 시 **순환 의존**·재진입에 유의.

```c
__attribute__((constructor))
static void on_load(void){ /* 리소스 준비 */ }

__attribute__((destructor))
static void on_unload(void){ /* 리소스 해제 */ }
```

---

## 6. 스레드 안전·언로드 타이밍

- API 자체는 내부 락으로 스레드 안전.  
- 그러나 **코드 언로드 시점**에 다른 스레드가 그 코드를 실행 중이면 **use-after-free**.  
  - 해결1: 플러그인 레벨 **참조 카운팅**(진입/탈출).  
  - 해결2: **수신 중단** → 작업 완료 대기 → `dlclose`.  
  - 해결3: **`RTLD_NODELETE`** (언로드하지 않음; 메모리 상주 비용 감수).

**간단한 참조 카운팅 패턴**
```c
// plugin_api.h 의 vtable에 acquire/release 훅 추가하는 방식이 안전.
_Atomic int busy;
void enter(){ ++busy; }
void leave(){ --busy; }
void safe_close(void* h){
  while (busy > 0) sched_yield();
  dlclose(h);
}
```

---

## 7. 가장 작은 예제(동적 수학 라이브러리)

```c
// tiny.c
#include <dlfcn.h>
#include <stdio.h>
typedef double (*sqrt_fn)(double);

int main(void){
  void* h = dlopen("libm.so.6", RTLD_NOW | RTLD_LOCAL);
  if (!h){ fprintf(stderr, "dlopen: %s\n", dlerror()); return 1; }

  dlerror(); // clear
  sqrt_fn mysqrt = (sqrt_fn) dlsym(h, "sqrt");
  if (char* e = dlerror()){ fprintf(stderr, "dlsym: %s\n", e); dlclose(h); return 1; }

  printf("sqrt(2)=%.6f\n", mysqrt(2.0));
  dlclose(h);
}
```

```bash
gcc tiny.c -ldl -o tiny && ./tiny
```

---

## 8. 안정적 ABI 설계 — vtable + 버전

**원칙**
- **C ABI**(네임 맹글링 회피): 헤더에 `extern "C"` 가드.  
- **함수 포인터 테이블(vtable)** 로 API 제공.  
- **버전/사이즈 필드**로 상·하위 호환.

### 8.1 공용 헤더
```c
// plugin_api.h
#pragma once
#ifdef __cplusplus
extern "C" { #endif

#define PLUGIN_API_VERSION 0x00010002u

typedef struct PluginAPI {
  unsigned int version;    // == PLUGIN_API_VERSION
  unsigned int size;       // 구조체 크기(뒤 필드 확장 대비)
  const char*  name;
  int  (*init)(void);
  int  (*process)(const void* in, void* out, int n);
  void (*fini)(void);
  // v1.1부터 추가될 수도 있는 선택 필드들은 구조체 뒤에 확장
} PluginAPI;

extern const PluginAPI plugin_api;

#ifdef __cplusplus
} #endif
```

### 8.2 플러그인 구현
```c
// plugin_echo.c
#include "plugin_api.h"
#include <string.h>
static int my_init(void){ return 0; }
static int my_process(const void* in, void* out, int n){
  memcpy(out, in, (size_t)n); return n;
}
static void my_fini(void){}
const PluginAPI plugin_api = {
  .version = PLUGIN_API_VERSION,
  .size    = sizeof(PluginAPI),
  .name    = "echo",
  .init    = my_init,
  .process = my_process,
  .fini    = my_fini
};
```

```bash
gcc -fPIC -shared plugin_echo.c -o libplugin_echo.so
```

### 8.3 호스트 로더
```c
// host.c
#include "plugin_api.h"
#include <dlfcn.h>
#include <stdio.h>

static void* open_so(const char* path){
  void* h = dlopen(path, RTLD_NOW | RTLD_LOCAL);
  if (!h) fprintf(stderr,"dlopen(%s): %s\n", path, dlerror());
  return h;
}
int main(int argc, char** argv){
  if (argc<2){ fprintf(stderr,"usage: %s ./libplugin_echo.so\n", argv[0]); return 2; }
  void* h = open_so(argv[1]); if(!h) return 1;

  dlerror();
  const PluginAPI* api = (const PluginAPI*) dlsym(h, "plugin_api");
  if (char* e=dlerror()){ fprintf(stderr,"dlsym: %s\n", e); dlclose(h); return 1; }

  if (api->version != PLUGIN_API_VERSION || api->size < sizeof(PluginAPI)){
    fprintf(stderr,"ABI mismatch: plugin v=%x size=%u\n", api->version, api->size);
    dlclose(h); return 1;
  }
  if (api->init && api->init()) { fprintf(stderr,"init failed\n"); dlclose(h); return 1; }

  const char msg[]="hello";
  char buf[16]={0};
  int n = api->process(msg, buf, sizeof msg);
  printf("result: %s (n=%d)\n", buf, n);

  if (api->fini) api->fini();
  dlclose(h);
}
```

---

## 9. Lazy vs Now — 성능·안정성

- **`RTLD_LAZY`**: 시작 빠름, **첫 호출** 때마다 바인딩(PLT 트램폴린).  
- **`RTLD_NOW`**: 로드시 전부 바인딩 → 실패 조기 발견, **런타임 안정성↑**. 대형 DSO는 스타트업 지연.  
- 시스템 강제: `LD_BIND_NOW=1`.

**콜 경로 최적화**  
자주 쓰는 함수 포인터는 **한 번만 `dlsym` → 캐시**. 함수 포인터를 전역/정적에 저장하고, **분기 예측** 유리한 쪽으로 배치.

---

## 10. RTLD_GLOBAL의 의미와 리스크

- `RTLD_GLOBAL` 로 연 라이브러리는 **그 심볼을 전역 스코프에 노출** → 이후 로드되는 라이브러리가 이를 참조 가능.  
- **장점**: 플러그인 간 공유/후킹 가능.  
- **단점**: **인터포지션/이름 충돌/순서 의존**이 숨어 디버깅 난이도↑.  
- **원칙**: 기본은 `RTLD_LOCAL`. 정말 필요한 경우에만 GLOBAL.

---

## 11. 진단·관찰 도구

```bash
ldd ./host                                 # 필요한 .so 확인
LD_DEBUG=libs,reloc,bindings ./host ... 2>&1 | less  # 로더 로그
readelf -dW ./libplugin_echo.so             # .dynamic (NEEDED/RUNPATH/SONAME)
objdump -T ./libplugin_echo.so              # 동적 심볼 테이블
```

- **역탐색**: `dladdr` 로 임의의 함수 포인터가 **어느 심볼/파일**인지 조회.
```c
#include <dlfcn.h>
Dl_info info;
if (dladdr((void*)api->process, &info))
  printf("sym=%s, dso=%s\n", info.dli_sname, info.dli_fname);
```

- **메타**: `dlinfo(h, RTLD_DI_LINKMAP, &lm)`로 **link_map** 체인 접근(베이스/다음 노드/이름).

---

## 12. TLS·IFUNC — 특수 케이스

- **TLS 전역**(`__thread`)은 **TLS 재배치**를 거쳐 접근 모델(LE/IE/LD/GD)에 따라 성능 차이.  
  플러그인 경계에서 TLS 심볼을 `dlsym`으로 가져다 쓰는 것은 이식성 이슈가 있으니 **API로 포장**(getter 함수) 권장.
- **IFUNC**(간접 함수): 런타임에 해결자(resolver)가 구현 주소를 선택.  
  플러그인이 IFUNC를 노출할 땐 **초기화 순서/스레드 안전**을 점검.

---

## 13. 네임스페이스 분리 — `dlmopen`(glibc 고급)

동일 프로세스에서 **서로 다른 버전**의 라이브러리를 격리 로드:
```c
#define _GNU_SOURCE
#include <dlfcn.h>
void* h = dlmopen(LMID_NEWLM, "./libX.so", RTLD_NOW|RTLD_LOCAL);
```
- **효과**: 심볼/전역 충돌 격리.  
- **제약**: 네임스페이스 간 직접 참조 어렵고 상호 호출 설계가 복잡.

---

## 14. 배포·경로·패키징

- **상대경로 고정**: `-Wl,-rpath,'$ORIGIN/../lib'` 로 바이너리 옆/하위에 배치.  
- **의존 최소화**: 공개 API만 `DEFAULT`, 나머지 `HIDDEN`.  
- **디버그 심볼 분리**: 런타임 크기↓, 사고 시 정확한 스택 복구.
```bash
objcopy --only-keep-debug libX.so libX.so.debug
strip --strip-unneeded libX.so
objcopy --add-gnu-debuglink=libX.so.debug libX.so
```

---

## 15. 보안 체크리스트

- [ ] 플러그인 **디렉터리 고정**(화이트리스트), 사용자 임의 경로 금지  
- [ ] setuid/컨테이너 정책에서 환경 영향(`LD_*`) 확인  
- [ ] 실행파일/DSO `RELRO + NOW` (`-Wl,-z,relro -Wl,-z,now`)  
- [ ] **서명/해시** 검증(자체 로더가 SHA-256 확인 후 `dlopen`)  
- [ ] **권한 축소**·샌드박스(seccomp, cgroup, namespaces)  
- [ ] **RTLD_GLOBAL 최소화**(인터포지션 공격면 축소)  
- [ ] 플러그인 API 입력 검증, ODR/ABI 버전 체크 강제

---

## 16. 성능 팁 모음

- **함수 포인터 캐시**: `dlsym` 비용과 간접 분기 패널티를 줄인다.  
- **핫콜은 직접 연결**: 가능하다면 DSO 내부 호출은 가시성 제한 + `-fno-semantic-interposition` 로 **직접 결속**.  
- **NOW vs LAZY 프로파일**: 시작/steady-state 모두 측정.  
- **PLT 오염 줄이기**: `-fno-plt`(적용 가능한 타깃) 또는 **초기 워밍업 호출**.  
- **오류 경로**: `dlerror` 문자열 생성도 비용 → 정상 경로에서 불필요 호출 금지.

---

## 17. 실전 매니저(다중 플러그인 로더 샘플)

```c
// plugin_mgr.c
#include "plugin_api.h"
#include <dlfcn.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>

typedef struct { void* h; const PluginAPI* api; } Plug;

int load_all(const char* dir, Plug out[], int cap){
  int n=0; DIR* dp=opendir(dir); if(!dp) return 0;
  struct dirent* ent;
  while ((ent = readdir(dp)) && n<cap){
    if (!strstr(ent->d_name, ".so")) continue;
    char path[1024]; snprintf(path,sizeof path,"%s/%s",dir,ent->d_name);
    void* h = dlopen(path, RTLD_NOW|RTLD_LOCAL);
    if (!h){ fprintf(stderr,"dlopen: %s\n", dlerror()); continue; }
    dlerror();
    const PluginAPI* api=(const PluginAPI*) dlsym(h,"plugin_api");
    if (char* e=dlerror()){ fprintf(stderr,"dlsym: %s\n", e); dlclose(h); continue; }
    if (api->version!=PLUGIN_API_VERSION || api->size<sizeof *api){ dlclose(h); continue; }
    if (api->init && api->init()) { dlclose(h); continue; }
    out[n++] = (Plug){h, api};
  }
  closedir(dp); return n;
}
void unload_all(Plug arr[], int n){
  for (int i=0;i<n;i++){ if (arr[i].api->fini) arr[i].api->fini(); dlclose(arr[i].h); }
}
```

---

## 18. C++ 경계

- **네임 맹글링**: `extern "C"` 로 API를 내보내라.  
- **예외/RTTI**: DSO 경계 간 전파는 동일 libstdc++/옵션 전제 — **권장X**. 예외는 경계 내부에서 처리.  
- **템플릿**: ABI 불안정 → **C 래퍼** 제공.

---

## 19. 흔한 함정(FAQ식)

| 증상 | 원인 | 해결 |
|---|---|---|
| `undefined symbol` 런타임 | `RTLD_NOW`로 미리 검출/혹은 심볼 누락 | 링크 옵션/NEEDED 확인, `readelf -d/-s` |
| 플러그인 언로드 후 크래시 | 다른 스레드가 코드 실행 중 | 참조 카운트/쿼이스, `RTLD_NODELETE` |
| 후킹이 안 먹음 | 스코프/순서 문제 | `RTLD_NEXT`, `RTLD_GLOBAL`, `LD_PRELOAD` 우선순위 확인 |
| 성능이 나쁨 | PLT 간접/지연 바인딩 | 포인터 캐시, `-Wl,-z,now`, `-fno-plt` |
| TLS 변수 주소 이상 | 모델/로더 차이 | getter 함수로 추상화 |
| 버전 충돌 | 동일 심볼 다른 ABI | `dlmopen` 네임스페이스로 격리 |

---

## 20. 이식성 노트(간단)

- **Windows**: `LoadLibrary` / `GetProcAddress` / `FreeLibrary` (보안: DLL 검색 순서, `SetDefaultDllDirectories`).  
- **macOS**: `dlopen` 계열 동일, 또는 CoreFoundation 번들 API. 코드 서명/하든드 런타임 정책 고려.

---

## 21. 체크리스트

- [ ] 기본 `RTLD_NOW | RTLD_LOCAL`  
- [ ] 절대/`$ORIGIN` 기반 경로, 사용자 임의 경로 금지  
- [ ] C ABI vtable + `version/size` 검사  
- [ ] 스레드·언로드 타이밍 제어(카운트/노딜리트)  
- [ ] 전역 스코프 오염 최소화(`RTLD_GLOBAL` 회피)  
- [ ] 진단 도구로 확인: `LD_DEBUG`, `readelf`, `objdump`, `dladdr`  
- [ ] 보안 플래그(RELRO+NOW), 샌드박스(필요 시)

---

## 22. 맺음말

런타임 로딩은 **유연성**(선택적 의존/플러그인)과 **제어성**(버전/교체)을 준다.  
핵심은 **스코프 관리**(LOCAL/DEFAULT/NEXT), **안정적 ABI**(C vtable+버전), **언로드 안전성**,  
그리고 **보안/배포**(RUNPATH, `$ORIGIN`, RELRO+NOW).  
마지막으로, 모든 가설은 **툴 출력**으로 검증하자 — 말이 아니라 `LD_DEBUG` 로그와 `readelf/objdump`가 진실이다.