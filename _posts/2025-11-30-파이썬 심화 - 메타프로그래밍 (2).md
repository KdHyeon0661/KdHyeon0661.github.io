---
layout: post
title: 파이썬 심화 - 메타프로그래밍 (2)
date: 2025-11-30 23:25:23 +0900
category: 파이썬 심화
---
# 메타프로그래밍 (2)

데코레이터는 파이썬의 가장 우아한 기능 중 하나로, 기존 코드를 수정하지 않고도 함수나 클래스의 동작을 확장하고 수정할 수 있게 해줍니다. 이 글에서는 실전에서 유용하게 활용할 수 있는 고급 데코레이터 패턴을 심층적으로 살펴보겠습니다.

## 옵션 매개변수를 받는 유연한 데코레이터 정의하기

데코레이터에 옵션 매개변수를 추가하면 재사용성과 유연성을 크게 높일 수 있습니다. 이를 구현하려면 데코레이터 팩토리 패턴을 사용해야 합니다.

```python
def retry(max_attempts=3, delay=1.0, exceptions=(Exception,)):
    """
    실패 시 재시도하는 데코레이터
    
    Args:
        max_attempts: 최대 재시도 횟수
        delay: 재시도 간 대기 시간(초)
        exceptions: 포착할 예외 타입들
    """
    def decorator(func):
        import time
        
        def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    if attempt < max_attempts - 1:
                        time.sleep(delay)
                        print(f"재시도 중... ({attempt + 1}/{max_attempts})")
            
            raise last_exception
            
        return wrapper
    return decorator

# 사용 예시: 네트워크 요청에 재시도 로직 추가
@retry(max_attempts=5, delay=2.0, exceptions=(ConnectionError, TimeoutError))
def fetch_data(url):
    """외부 API에서 데이터를 가져오는 함수"""
    # 네트워크 요청 구현
    return "데이터"
```

이 패턴의 핵심은 **데코레이터를 반환하는 함수**를 생성하는 것입니다. `retry()` 함수 자체는 데코레이터가 아니라 데코레이터를 생성하는 팩토리입니다. 이렇게 구현하면 사용 시점에 데코레이터의 동작을 동적으로 조정할 수 있습니다.

## 타입 안전성을 강제하는 데코레이터 구현

동적 타입 언어인 파이썬에서 타입 검사 데코레이터는 런타임 안정성을 보장하는 강력한 도구가 됩니다.

```python
def type_enforce(*type_hints, return_type=None):
    """
    함수의 입력과 출력 타입을 검증하는 데코레이터
    
    Args:
        *type_hints: 위치 인자의 기대 타입들
        return_type: 반환값의 기대 타입
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            # 위치 인자 타입 검사
            for i, (arg, expected_type) in enumerate(zip(args, type_hints)):
                if not isinstance(arg, expected_type):
                    actual_type = type(arg).__name__
                    expected_name = expected_type.__name__
                    raise TypeError(
                        f"인자 {i}의 타입이 일치하지 않습니다: "
                        f"기대={expected_name}, 실제={actual_type}"
                    )
            
            # 키워드 인자 타입 검사 (어노테이션 기반)
            annotations = func.__annotations__
            for key, value in kwargs.items():
                if key in annotations:
                    expected_type = annotations[key]
                    if not isinstance(value, expected_type):
                        actual_type = type(value).__name__
                        expected_name = expected_type.__name__
                        raise TypeError(
                            f"키워드 인자 '{key}'의 타입이 일치하지 않습니다: "
                            f"기대={expected_name}, 실제={actual_type}"
                        )
            
            result = func(*args, **kwargs)
            
            # 반환값 타입 검사
            if return_type and not isinstance(result, return_type):
                actual_type = type(result).__name__
                expected_name = return_type.__name__
                raise TypeError(
                    f"반환값 타입이 일치하지 않습니다: "
                    f"기대={expected_name}, 실제={actual_type}"
                )
            
            return result
            
        return wrapper
    return decorator

# 사용 예시: 다양한 타입 검사 시나리오
@type_enforce(int, str, return_type=bool)
def process_data(count: int, name: str, enabled: bool = True) -> bool:
    """타입 검증이 적용된 함수"""
    print(f"{count}개의 {name} 데이터 처리, enabled={enabled}")
    return enabled

# 정상 실행
process_data(10, "테스트")  # 성공

# 타입 오류 발생
process_data("10", "테스트")  # TypeError: 인자 0의 타입이 일치하지 않습니다
```

이 데코레이터는 Python 3.5+의 타입 힌트와도 완벽하게 통합됩니다. 개발 단계에서 타입 관련 버그를 조기에 발견할 수 있어 대규모 프로젝트에서 특히 유용합니다.

## 클래스 내부에 데코레이터 통합하기

데코레이터를 클래스의 메서드로 정의하면 관련 기능을 논리적으로 그룹화하고 상태를 공유할 수 있습니다.

```python
class CacheManager:
    """캐싱 기능을 관리하는 클래스"""
    
    def __init__(self):
        self._cache = {}
        self._hits = 0
        self._misses = 0
    
    def cached(self, ttl_seconds=300):
        """결과를 캐싱하는 데코레이터"""
        import time
        
        def decorator(func):
            def wrapper(*args, **kwargs):
                # 캐시 키 생성 (인자를 기반으로)
                cache_key = (
                    func.__name__, 
                    args, 
                    tuple(sorted(kwargs.items()))
                )
                
                current_time = time.time()
                
                # 캐시 히트 확인
                if cache_key in self._cache:
                    cached_value, expiry_time = self._cache[cache_key]
                    if current_time < expiry_time:
                        self._hits += 1
                        return cached_value
                
                # 캐시 미스: 실제 함수 실행
                self._misses += 1
                result = func(*args, **kwargs)
                
                # 결과 캐싱
                self._cache[cache_key] = (
                    result, 
                    current_time + ttl_seconds
                )
                
                # 캐시 크기 관리 (간단한 LRU 전략)
                if len(self._cache) > 100:
                    oldest_key = next(iter(self._cache))
                    del self._cache[oldest_key]
                
                return result
            
            return wrapper
        return decorator
    
    def get_stats(self):
        """캐시 통계 반환"""
        return {
            'hits': self._hits,
            'misses': self._misses,
            'hit_ratio': self._hits / max(self._hits + self._misses, 1),
            'cache_size': len(self._cache)
        }

# 사용 예시
class DataService:
    def __init__(self):
        self.cache_manager = CacheManager()
    
    @cache_manager.cached(ttl_seconds=600)
    def get_user_data(self, user_id: int) -> dict:
        """데이터베이스에서 사용자 데이터 조회 (비용이 큰 연산)"""
        print(f"데이터베이스 조회: 사용자 {user_id}")
        return {"id": user_id, "name": f"사용자{user_id}", "score": 95}

# 캐싱 효과 확인
service = DataService()
print(service.get_user_data(1))  # 데이터베이스 조회 발생
print(service.get_user_data(1))  # 캐시에서 반환 (조회 없음)
print(service.cache_manager.get_stats())  # 캐시 통계 확인
```

클래스 기반 데코레이터는 상태 관리와 관련 기능의 캡슐화에 적합합니다. 캐싱, 로깅, 인증, 권한 부여 등 공통 관심사를 효과적으로 처리할 수 있습니다.

## 클래스 데코레이터로 클래스 변형하기

클래스 데코레이터는 클래스 자체를 수정하거나 확장할 수 있는 강력한 메타프로그래밍 도구입니다.

```python
def auto_register(registry=None):
    """클래스의 인스턴스를 자동으로 레지스트리에 등록"""
    if registry is None:
        registry = []
    
    def decorator(cls):
        original_init = cls.__init__
        
        def new_init(self, *args, **kwargs):
            original_init(self, *args, **kwargs)
            registry.append(self)
            print(f"{cls.__name__} 인스턴스가 레지스트리에 등록되었습니다.")
        
        cls.__init__ = new_init
        return cls
    
    return decorator

def add_method(method_name, method_func):
    """클래스에 새로운 메서드를 동적으로 추가"""
    def decorator(cls):
        setattr(cls, method_name, method_func)
        return cls
    return decorator

# 사용 예시: 여러 데코레이터 조합
registry = []

@auto_register(registry)
@add_method("to_dict", lambda self: self.__dict__)
@add_method("from_dict", classmethod(lambda cls, data: cls(**data)))
class Product:
    def __init__(self, id, name, price):
        self.id = id
        self.name = name
        self.price = price
    
    def display(self):
        return f"{self.name}: ${self.price}"

# 데코레이터 효과 확인
p1 = Product(1, "노트북", 1200)
p2 = Product(2, "마우스", 50)

print(p1.display())  # 노트북: $1200
print(p1.to_dict())  # {'id': 1, 'name': '노트북', 'price': 1200}
print(f"레지스트리 크기: {len(registry)}")  # 2
```

클래스 데코레이터의 고급 활용 사례:

```python
def singleton(cls):
    """싱글톤 패턴 구현"""
    instances = {}
    
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

def deprecated(message="이 클래스는 더 이상 사용되지 않습니다."):
    """사용 중단 경고를 추가"""
    def decorator(cls):
        original_init = cls.__init__
        
        def new_init(self, *args, **kwargs):
            import warnings
            warnings.warn(f"{cls.__name__}: {message}", DeprecationWarning, stacklevel=2)
            original_init(self, *args, **kwargs)
        
        cls.__init__ = new_init
        return cls
    return decorator

def enforce_interface(*required_methods):
    """인터페이스 구현 강제"""
    def decorator(cls):
        for method in required_methods:
            if not hasattr(cls, method) or not callable(getattr(cls, method)):
                raise TypeError(
                    f"{cls.__name__}은 {method} 메서드를 구현해야 합니다."
                )
        return cls
    return decorator

# 인터페이스 강제 예시
@enforce_interface("save", "load", "delete")
class DataRepository:
    def save(self, data):
        print("데이터 저장")
    
    def load(self, id):
        print("데이터 로드")
        return {"id": id}
    
    def delete(self, id):
        print("데이터 삭제")

# 필수 메서드가 없으면 TypeError 발생
@enforce_interface("save", "load", "delete")
class IncompleteRepository:
    def save(self, data):
        pass
    # load와 delete 메서드가 없음 -> TypeError 발생
```

## 결론

파이썬 데코레이터는 단순한 문법적 편의를 넘어서는 강력한 도구입니다. 옵션 매개변수를 통한 유연한 데코레이터 설계는 다양한 시나리오에 대응할 수 있는 재사용 가능한 컴포넌트를 만들 수 있게 해줍니다. 타입 검사 데코레이터는 동적 타입 언어의 단점을 보완하며 런타임 안정성을 확보합니다. 클래스와의 통합은 관련 기능을 논리적으로 조직화하고 상태 관리를 용이하게 하며, 클래스 데코레이터는 메타프로그래밍을 통해 클래스 자체의 구조와 동작을 변형할 수 있는 무한한 가능성을 제공합니다.

이러한 고급 기법들을 효과적으로 활용하려면 데코레이터의 실행 시점(임포트 타임)과 실행 컨텍스트를 이해하는 것이 중요합니다. 데코레이터는 코드의 가독성을 높이고 관심사를 분리하며, 디자인 패턴을 보다 우아하게 구현할 수 있게 해줍니다. 실제 프로젝트에서는 이러한 패턴들을 조합하여 도메인에 특화된 강력한 추상화 계층을 구축할 수 있습니다.