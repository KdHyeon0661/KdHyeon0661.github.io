---
layout: post
title: Elixir - 맵, 키워드 리스트, 집합, 구조체 (1)
date: 2025-11-17 15:25:23 +0900
category: Elixir
---
# 키워드 리스트·맵·MapSet·구조체 완전 정리

> 목표
> - 엘릭서에서 **키/값·집합·도메인 레코드**를 표현하는 네 가지 축:
>   **키워드 리스트, 맵, MapSet, 구조체**를 **역할·비용·패턴·실전 예제**까지 정리한다.
> - 앞 장(리스트/머리·꼬리, map/reduce)을 전제로,
>   “리스트 위에 얹어지는 딕셔너리·집합·레코드”를 보는 관점을 만든다.

---

## 무엇을 써야 할까? — 선택 기준

먼저 큰 그림을 한 번에 보자. 엘릭서에서 “키/값, 옵션, 집합, 도메인 레코드”를 표현할 때 보통 아래 네 가지를 쓴다.

| 용도 | 자료형 | 특징/장단 |
|---|---|---|
| 옵션 전달 | **키워드 리스트** `[{key, value}]` | **순서 유지**, **중복 키 허용**. 패턴·머지 편리. 옵션/DSL에 최적, **데이터 저장에는 부적합**. |
| 범용 딕셔너리 | **맵(Map)** `%{key => value}` | **중복 키 불가**, **순서 의미 없음**. 빠른 조회/갱신, 패턴매칭/업데이트 표준. 대부분 데이터 구조의 기본. |
| 집합 | **MapSet** | 원소 고유성 보장, 합/차/교 연산. 내부적으로 맵 기반. |
| 도메인 레코드 | **구조체(Struct)** `%Module{}` | 맵의 특수형. **필드 고정**, `@enforce_keys`로 필수 강제, 패턴매칭·타입·도메인 모델링에 최적. |

실무 요약(다시 정리):

- **함수 옵션/DSL/설정 인자** → **키워드 리스트**
- **상태/엔터티/레코드** → **구조체** (또는 맵)
- **일반 해시 딕셔너리/JSON/임의 키 데이터** → **맵**
- **유일 원소 모음/집합 연산(태그, 권한 등)** → **MapSet**

시간 복잡도(평균, 개략):

$$
\begin{aligned}
&\text{맵 조회/삽입/수정} \approx O(1) && \text{(해시 + 트리 아말감 구조)} \\
&\text{키워드 리스트 조회} \approx O(n) && \text{(앞에서부터 선형 탐색)} \\
&\text{MapSet 원소 연산} \approx O(1),\quad
  \text{합/교/차} \approx O(n)
\end{aligned}
$$

- 키워드 리스트는 결국 **리스트**이기 때문에 “많이 찾을수록 느려진다”.
- 맵·MapSet은 BEAM VM 구현(해시 기반 + 균형 구조) 덕분에 **평균 O(1)** 수준 성능을 기대할 수 있다.
- “실제 복사 비용”은 불변 구조의 **구조 공유** 때문에 생각보다 낮지만,
  **갱신 빈도·데이터 크기**에 따라 설계를 조절해야 한다.

이제 각 자료형을 차례로 파고들자.

---

## 키워드 리스트 (Keyword List)

키워드 리스트는 **아톰 키를 갖는 튜플 리스트**다:

```elixir
[key: value]  # == [{:key, value}]
```

- 내부 구현은 그냥 `[{atom(), term()}]` 리스트.
- **순서가 보존**되고, **중복 키 허용**이 핵심이다.
- **do/end 구문**, **함수 옵션**, **DSL**에 널리 쓰인다.

### 기본 사용

```elixir
opts = [timeout: 3000, pool: :db]

opts[:timeout]                    # 3000
Keyword.get(opts, :pool, :default) # :db
Keyword.get(opts, :missing, 10)    # 10
```

성질:

- `opts[:k]` 는 **첫 번째 일치**를 반환한다. 없으면 `nil`.
- `Keyword.get/3` 은 기본값을 지정할 수 있어 더 안전하다.
- 키는 **아톰**이어야 하므로, 외부 JSON/자유 형식 데이터에는 맞지 않는다.

키워드 리스트는 리스트이기 때문에, 리스트 함수도 그대로 사용할 수 있다:

```elixir
Enum.each(opts, fn {k, v} ->
  IO.puts("#{k}=#{inspect(v)}")
end)
```

---

### 중복 키와 우선순위

중복 키가 허용된다는 것은, 같은 키가 여러 번 등장해도 된다는 뜻이다.

```elixir
opts = [timeout: 1000, pool: :a, timeout: 5000]

opts[:timeout]                       # 1000 (앞쪽 우선)
Keyword.get_values(opts, :timeout)   # [1000, 5000]

Keyword.put(opts, :timeout, 2000)
# => [timeout: 2000, timeout: 1000, pool: :a, timeout: 5000]

Keyword.merge([a: 1, a: 2], [a: 3])
# => [a: 1, a: 2, a: 3]

```

특징:

- 인덱스 접근 `opts[:timeout]` 은 **항상 “첫 원소”** 를 반환.
- `Keyword.get_values/2` 를 쓰면 모든 값을 리스트로 가져올 수 있다.
- `Keyword.put/3` 은 **앞에 새 튜플**을 추가하여, 새로운 값이 **우선**되게 만든다.
- `Keyword.merge/2` 는 단순히 리스트를 이어 붙인다.
  두 번째 인자의 값이 “뒤에 추가되는” 것이지, 기존 값을 제거하지 않는다.

**옵션/DSL 설계에서 유용한 패턴**:

- “사용자 옵션 → 기본 옵션” 순으로 이어붙인 뒤,
  앞쪽(사용자 쪽)을 우선하는 룰을 사용한다.
- 예: `opts ++ @default_opts` 에서 `opts[:timeout]` 을 읽으면 사용자 값이 우선.

---

### 패턴 매칭으로 필수/선택 옵션 처리

키워드 리스트는 그냥 리스트이므로, **패턴매칭**으로 필수 키를 강제할 수 있다.

```elixir
def connect([host: host, port: port] = opts)
    when is_binary(host) and is_integer(port) do
  timeout = Keyword.get(opts, :timeout, 1000)
  {:ok, %{host: host, port: port, timeout: timeout}}
end
```

동작:

- `[host: host, port: port]` 패턴은
  - **반드시** `:host`, `:port` 키가 존재해야 하고,
  - 순서도 이 패턴대로 올 것을 요구한다.
- `timeout` 은 선택 옵션이므로 `Keyword.get/3` 으로 기본값을 준다.

조금 더 유연하게(순서에 관계 없이) 받으려면:

```elixir
def connect(opts) when is_list(opts) do
  with host when is_binary(host) <- Keyword.fetch!(opts, :host),
       port when is_integer(port) <- Keyword.fetch!(opts, :port),
       timeout <- Keyword.get(opts, :timeout, 1000) do
    {:ok, %{host: host, port: port, timeout: timeout}}
  end
rescue
  KeyError -> {:error, :missing_required_option}
end
```

- `Keyword.fetch!/2` 로 **필수 키 누락 시 예외**를 발생시키고,
  예외를 잡아서 `{:error, reason}` 으로 바꾸는 패턴도 실무에서 자주 쓰인다.

---

### 키워드 리스트를 “데이터”로 쓰지 말아야 할 때

키워드 리스트는 **옵션·DSL** 에 최적화된 자료형이지,
일반적인 “데이터 저장소”로는 적합하지 않다.

피해야 할 상황:

- 수천/수만 건 이상을 담는 **대규모 딕셔너리**로 사용
- 자주 조회/갱신해야 하는 **상태 저장**
- 키가 문자열/정수 등으로 다양하고, **외부 JSON을 그대로 유지**해야 하는 경우
- 정렬/검색/집계/필터링이 빈번한 경우

이럴 땐:

- **맵(Map)** 으로 변환해서 사용해야 한다.

```elixir
opts = [timeout: 1000, pool: :a, timeout: 2000]
map  = Map.new(opts)
# %{timeout: 2000, pool: :a} (중복 키는 마지막 값만 남는다)

```

또한:

- 키워드 리스트는 **키가 반드시 아톰** 이어야 한다.
  외부 JSON 문자열 키를 그대로 담고 싶다면, **맵**이 자연스럽다.

정리:

- **옵션 전달/DSL/함수 인자용** → 키워드 리스트
- **데이터 저장/조작** → 맵 또는 구조체

---

## 맵 (Map)

맵은 엘릭서의 표준 딕셔너리 타입이다.

- 키 → 값 매핑
- **중복 키 불가**
- 키 타입은 **어떤 타입도 가능** (보통 아톰/문자열/정수)

### 생성/접근 기본

```elixir
m = %{id: 1, "name" => "Kim", :active => true}

m[:id]       # 1
m["name"]    # "Kim"
m[:missing]  # nil
```

아톰 키에 한해서 **점 표기(dot)** 를 사용할 수 있다.

```elixir
m.id         # 1
# m.name     # 컴파일 에러: "name"은 문자열 키

```

점 표기는:

- **아톰 키**일 때만 가능,
- 그리고 **컴파일 타임에 키가 고정**되어 있어야 한다.

```elixir
k = :id
m.k      # 안 됨 (컴파일 에러)
m[k]     # 가능
```

---

### 존재 확인과 안전 접근

맵에서 값이 `nil` 일 수도 있기 때문에,
“키가 없다”와 “키가 있는데 값이 nil”인 상황을 구분하려면 `Map.fetch/2` 를 이용한다.

```elixir
m = %{a: 1, b: nil}

m[:b]                    # nil
Map.get(m, :b, :none)    # nil (이미 존재)
/* 키 없음 vs 값이 nil 구분 불가 */

Map.fetch(m, :a)         # {:ok, 1}
Map.fetch(m, :b)         # {:ok, nil}
Map.fetch(m, :missing)   # :error
```

정리:

- **키 존재 여부**: `Map.has_key?/2`, `Map.fetch/2` 를 사용.
- `m[:k]` 또는 `Map.get/3` 는 “없으면 nil/기본값”을 돌려주기 때문에,
  “존재 여부 자체”를 알고 싶을 때는 적합하지 않을 수 있다.

---

### 머지/갱신/삭제(기초)

```elixir
m  = %{a: 1}
m2 = Map.put(m, :b, 2)
# %{a: 1, b: 2}

m3 = Map.update(m2, :a, 0, &(&1 + 10))
# %{a: 11, b: 2}

m4 = Map.delete(m3, :b)
# %{a: 11}

m5 = Map.merge(%{a: 1}, %{a: 9, c: 3})
# %{a: 9, c: 3}

```

- `Map.put/3` : 키가 있으면 덮어쓰고, 없으면 추가.
- `Map.update/4` :
  - 키가 있으면 함수를 적용해 새 값 생성,
  - 없으면 “기본값 인자”를 사용.
- `Map.delete/2` : 키 제거.
- `Map.merge/2` : 두 맵을 합치는데, **두 번째 인자가 우선**.

충돌 정책을 제어하고 싶으면, 3-아리티 버전:

```elixir
Map.merge(m1, m2, fn key, v1, v2 ->
  # key : 충돌한 키
  # v1  : m1의 값
  # v2  : m2의 값
  decide(key, v1, v2)
end)
```

---

### 키 타입 전략

키로 **무엇을 쓸지**는 설계에서 매우 중요하다.

1. **도메인 내부 데이터**
   - 예: 사용자, 주문, 상품 등
   - 보통 **아톰 키** 사용:
     - 패턴매칭/점 표기 편리
     - 컴파일 타임에서 실수 일부를 잡을 수 있음

2. **외부 JSON/HTTP 응답 등의 데이터**
   - 예: `"id"`, `"user_name"` 등 문자열 키
   - 파싱 시 그대로 **문자열 키** 맵으로 유지하곤 한다.

경계에서 “문자열 키 → 아톰 키” 변환이 필요할 수 있다.
그러나, 아톰은 **GC되지 않는다는 점** 때문에 임의 문자열을 아톰으로 계속 만들면 **VM이 죽는다**.

```elixir
# 위험: 임의 문자열을 아톰으로 만들면 누수

String.to_atom("user_" <> user_input)

# 비교적 안전: 기존 아톰만 허용

String.to_existing_atom("id")
```

안전한 패턴:

1. **화이트리스트 기반 변환**

```elixir
def safe_atom_key("id"),    do: :id
def safe_atom_key("email"), do: :email
def safe_atom_key(_),       do: :unknown
```

2. **변환 범위가 제한된 설정·내부 API** 에서만 문자열→아톰 변환 허용

정리:

- 도메인 모델/내부 데이터 → **아톰 키**
- 외부 API/불특정 키 → **문자열 키** 유지
- 경계에서 변환 시 **화이트리스트 + to_existing_atom** 로 방어

---

## 패턴 매칭하기, 맵 수정하기 (원리 편)

맵은 **부분 패턴 매칭**이 가능하다.
즉, “맵에 이 키들이 반드시 있어야 한다”는 것을 패턴으로 선언할 수 있다.

### 부분 패턴 매칭과 필수 키

```elixir
%{id: id, name: name} = %{id: 1, name: "Kim", active: true}
{id, name} # {1, "Kim"}

# 실패 예
# %{id: id} = %{name: "Kim"}   # MatchError

```

- 오른쪽 맵에 `:id` 키가 없으면 **`MatchError`**.
- 이 방식은 **계약**을 코드에 명시하는 좋은 방법이다.

---

### 중첩 맵 패턴

좌변 패턴은 깊게 중첩할 수도 있다.

```elixir
%{user: %{profile: %{email: email}}} =
  %{user: %{profile: %{email: "a@b"}}}

email  # "a@b"
```

이 코드는:

- `:user`, `:profile`, `:email` 키가 모두 존재해야 한다.
- 어느 하나라도 빠져 있으면 `MatchError`.

중첩 구조에서 일부 필드만 필요할 때 유용하다.

---

### 핀(`^`)으로 기존 값 고정

핀 연산자 `^` 는 “이미 바인딩된 값을 다시 확인”하는 역할을 한다.

```elixir
status = :active

case %{status: :active, id: 1} do
  %{status: ^status} = m -> {:ok, m}
  _ -> :nope
end
# {:ok, %{status: :active, id: 1}}

```

- `^status` 는 “status 변수에 현재 들어 있는 값(:active)과 같아야 한다”는 뜻.
- 핀 없이 `status` 라고 쓰면 그 자리에 **새로 바인딩** 해버린다.

---

### 맵 업데이트의 두 관점

맵을 수정할 때 큰 틀에서 두 가지 접근이 있다.

1. **함수형 API 기반**
   - `Map.put/3`, `Map.update/4`, `Map.merge/2`, `Map.drop/2` …

2. **접근자(Access) 기반 매크로**
   - `get_in/2`, `put_in/3`, `update_in/3`, `get_and_update_in/3`
   - 경로(`[:user, :profile, :email]`)를 한 번에 기술

예:

```elixir
m = %{user: %{profile: %{email: "a@b", tags: ["elixir"]}}}

# 함수형 API

m1 = Map.update!(m, :user, fn user ->
  Map.update!(user, :profile, fn prof ->
    %{prof | email: "z@x"}
  end)
end)

# Access 기반

m2 = put_in(m, [:user, :profile, :email], "z@x")
```

Access 기반은:

- 중첩 깊이가 깊어질수록 **훨씬 읽기 쉽다**.
- 특히 JSON 비슷한 중첩 구조를 많이 다룰 때 강력하다.

---

## 맵 수정하기 (기법 편)

이제 실전에서 자주 쓰는 맵 수정 기법들을 정리하자.

### 얕은 필드 업데이트

```elixir
m = %{id: 1, profile: %{email: "a@b"}}

# 잘못된 예 (맵에는 안 됨)
# m1 = %{m | id: 2}  # 구조체 전용 문법

m1 = Map.put(m, :id, 2)
m2 = Map.update(m1, :visits, 1, &(&1 + 1))
```

주의:

- `%{struct | k: v}` 문법은 **구조체 전용**이다.
  일반 맵에 사용하면 컴파일 에러.
- 맵에서는 **항상 `Map.put/3`** 으로 갱신하는 습관을 들이는 편이 낫다.

---

### 중첩 업데이트: `put_in/3`, `update_in/3`

중첩 구조 갱신은 Access 경로로 매우 간단하게 표현할 수 있다.

```elixir
m = %{user: %{profile: %{email: "a@b", tags: ["elixir"]}}}

m1 = put_in(m, [:user, :profile, :email], "z@x")
# %{user: %{profile: %{email: "z@x", tags: ["elixir"]}}}

m2 = update_in(m, [:user, :profile, :tags], fn tags ->
  ["fp" | tags]
end)
# %{user: %{profile: %{email: "a@b", tags: ["fp", "elixir"]}}}

```

경로 중간이 없는 경우:

- 기본 `put_in/update_in` 은 `KeyError` 를 낸다.
- 꽤 복잡한 경로를 다룰 때는 `get_and_update_in/3` 에
  **커스텀 Access** 를 섞어 쓰는 방법도 있다(조금 뒤에서 예시).

---

### Access 프로토콜 확장과 리스트 경로

Access는 맵만이 아니라 **리스트**에도 쓸 수 있는 도구들을 제공한다.

```elixir
posts = %{items: [%{id: 1, title: "A"}, %{id: 2, title: "B"}]}

m =
  update_in(posts, [:items, Access.filter(&(&1.id == 2)), :title], fn title ->
    "New " <> title
  end)

# %{items: [%{id: 1, title: "A"}, %{id: 2, title: "New B"}]}

```

- `Access.filter/1` : 리스트에서 주어진 조건을 만족하는 원소에만 적용.
- 비슷하게 `Access.at(index)` 등도 제공된다.

이런 경로를 활용하면, **복잡한 중첩+리스트 구조**도 쉬운 문법으로 갱신할 수 있다.

---

### 안전한 “없으면 생성” 패턴

맵 안에 다시 맵을 넣고, 그 안에서 카운터를 올리는 패턴을 생각해보자.

```elixir
m = %{}

m1 =
  m
  |> Map.update(:counters, %{a: 1}, fn counters ->
    Map.update(counters, :a, 1, &(&1 + 1))
  end)

# %{counters: %{a: 2}}

```

설명:

1. `Map.update/3` 으로 최상위 `:counters` 키를 갱신 (없으면 `%{a: 1}` 생성)
2. 이미 있다면 내부 맵을 받아 다시 `Map.update/4` 로 `:a` 카운터 증가

이런 패턴은 **로그 레벨별 카운팅, 메트릭 집계** 등에서 많이 쓰인다.

---

### iodata와 맵을 이용한 리포트 생성

맵을 갱신해 가며 **보고서 문자열**을 만들어야 할 때,
매 번 `report <> "...string..."` 로 이어 붙이면 성능이 좋지 않다.

더 좋은 패턴:

```elixir
report =
  data
  |> Enum.reduce([], fn row, acc ->
    [[row.id, ":", row.val, "\n"] | acc]
  end)
  |> :erlang.iolist_to_binary()
```

- 중간 단계에서는 **리스트(= iolist)** 로만 누적.
- 마지막에 한 번만 `iolist_to_binary/1` 로 평탄화.
- 맵과 리스트를 섞어 사용하는 실전에서 매우 자주 쓰이는 패턴이다.

---

## 집합 — MapSet

`MapSet` 은 **원소 고유성**과 **집합 연산**을 제공하는 모듈이다.

- 내부 구현은 맵 기반 (원소 → `true` 형태).
- 원소 추가/삭제/멤버십 검사 등이 평균 **O(1)** 수준.

```elixir
s = MapSet.new([:a, :b, :a])
# #MapSet<[:a, :b]>

s = MapSet.put(s, :c)
MapSet.member?(s, :b)                     # true

MapSet.union(s, MapSet.new([:c, :d]))
# #MapSet<[:a, :b, :c, :d]>

MapSet.intersection(s, MapSet.new([:b]))
# #MapSet<[:b]>

MapSet.difference(s, MapSet.new([:a]))
# #MapSet<[:b, :c]>

```

---

### 태그/권한 관리 예제

태그나 권한처럼 “집합 연산이 자연스럽게 필요한 도메인”에서 MapSet이 빛난다.

```elixir
defmodule Tag do
  def add_tags(post, tags) do
    tags_set =
      post
      |> Map.get(:tags, MapSet.new())
      |> MapSet.union(MapSet.new(tags))

    %{post | tags: tags_set}
  end

  def has_any_tag?(post, tags) do
    post_set = Map.get(post, :tags, MapSet.new())
    not MapSet.disjoint?(post_set, MapSet.new(tags))
  end

  def has_all_tags?(post, tags) do
    post_set = Map.get(post, :tags, MapSet.new())
    MapSet.subset?(MapSet.new(tags), post_set)
  end
end
```

- `disjoint?/2` : 두 집합이 교집합을 갖지 않는지.
- `subset?/2` : 부분집합 여부.

실무에서 **접근 제어(ACL), 기능 플래그, 태깅 시스템**에 그대로 적용할 수 있다.

---

## 구조체 — 도메인 모델링의 기본

구조체는 “**모듈 이름을 타입으로 갖는 맵**”이라고 볼 수 있다.

- 맵의 특수형: 내부적으로는 맵
- 필드 집합이 고정되고, **키 오타 방지**
- 패턴매칭으로 도메인 모델을 표현하기 좋다

### 정의/기본값/필수 키

```elixir
defmodule User do
  @enforce_keys [:id, :email]
  defstruct [:id, :email, name: nil, active: true]
end

u = %User{id: 1, email: "a@b"}
# %User{id: 1, email: "a@b", name: nil, active: true}

# 누락 시 예외
# %User{}   # (ArgumentError: the following keys must also be given when building struct User: [:id, :email])

```

- `@enforce_keys` : 구조체 생성 시 **필수 필드**를 강제한다.
- `defstruct` : 필드 목록과 기본값 지정.

도메인에서 “이 필드가 없으면 안 된다”는 것을 코드 레벨에서 강제할 수 있다.

---

### 패턴 매칭/업데이트

구조체는 맵처럼 패턴매칭이 되지만, **모듈 이름까지 포함**한다.

```elixir
%User{id: id, email: e} = u
id  # 1
e   # "a@b"

u2 = %{u | name: "Kim"}
# %User{id: 1, email: "a@b", name: "Kim", active: true}

```

업데이트 문법 `%{struct | k: v}` 특성:

- **정의된 키만** 수정 가능
- 존재하지 않는 키를 쓰면 컴파일 에러 → 오타 방지

```elixir
# %{u | nickname: "x"}  # 컴파일 에러: key :nickname is not in struct

```

---

### 맵처럼 동작하지만 타입을 갖는다

```elixir
is_struct(u)          # true
Map.from_struct(u)    # %{active: true, email: "a@b", id: 1, name: nil}

Map.put(u, :extra, 1) # 일반 맵처럼 키 추가 가능 (하지만 타입 정보는 그대로 남음)
```

- 구조체는 내부적으로 맵이지만, `__struct__` 키로 모듈 이름을 가진다.
- 프로토콜 구현/파생 시 구조체 타입이 중요한 역할을 한다.

예: JSON 인코딩 시 특정 필드만 쓰고 싶을 때

```elixir
defmodule UserJson do
  @derive {Jason.Encoder, only: [:id, :email]}
  defstruct [:id, :email, :password]
end
```

---

### 구조체 + Access + 중첩 갱신

구조체 내부에 구조체를 중첩해서 도메인을 모델링할 수 있다.

```elixir
defmodule Profile do
  defstruct [:city]
end

defmodule User2 do
  defstruct [:id, profile: %Profile{}]
end

u = %User2{id: 1}
u = put_in(u, [:profile, :city], "Seoul")
# %User2{id: 1, profile: %Profile{city: "Seoul"}}

```

- 구조체도 맵이므로 `put_in/update_in` 을 그대로 사용할 수 있다.
- 구조체 중첩은 **도메인 경계**를 분리하고, 타입 정보를 더 풍부하게 만들어 준다.

---

## 실전 미니 프로젝트: 설정 파이프라인 (Keyword → Map → Struct)

지금까지 내용을 한 번에 엮어보자.

목표:

- 외부에서는 **키워드 리스트**로 옵션을 받는다.
- 내부에서는 **맵/MapSet** 으로 정규화한다.
- 최종적으로 **구조체**에 담아 애플리케이션 설정으로 쓴다.

디렉터리 가상 구조:

```text
lib/
  app_config.ex
```

### 구조체 정의

```elixir
defmodule App.Config do
  defmodule T do
    @enforce_keys [:endpoint]
    defstruct [:endpoint, timeout: 1000, headers: %{}, tags: MapSet.new()]
  end
end
```

- `endpoint` : 필수
- `timeout` : 기본 1000ms
- `headers` : 맵(문자열/아톰 키 허용)
- `tags` : MapSet (문자열 태그 집합 등)

---

### 로더 구현

```elixir
defmodule App.Config do
  defmodule T do
    @enforce_keys [:endpoint]
    defstruct [:endpoint, timeout: 1000, headers: %{}, tags: MapSet.new()]
  end

  @doc """
  키워드 옵션을 받아 구조체로 정규화한다.

  필수:
    * :endpoint (binary)

  선택:
    * :timeout (integer, > 0)
    * :headers (map 또는 keyword)
    * :tags (list 또는 MapSet)
  """
  def load(opts) when is_list(opts) do
    with endpoint when is_binary(endpoint) <- Keyword.get(opts, :endpoint),
         timeout  when is_integer(timeout) and timeout > 0 <- Keyword.get(opts, :timeout, 1000),
         headers0 <- Keyword.get(opts, :headers, %{}),
         {:ok, headers} <- norm_headers(headers0),
         tags0    <- Keyword.get(opts, :tags, []),
         {:ok, tags} <- norm_tags(tags0) do
      {:ok, %T{endpoint: endpoint, timeout: timeout, headers: headers, tags: tags}}
    else
      nil ->
        {:error, :missing_endpoint}

      false ->
        {:error, :invalid_timeout}

      {:error, reason} ->
        {:error, reason}
    end
  end

  def load(_), do: {:error, :bad_options}

  defp norm_headers(h) when is_map(h), do: {:ok, h}

  defp norm_headers(h) when is_list(h) do
    # 키워드 리스트를 맵으로 변환
    {:ok, Map.new(h)}
  rescue
    _ -> {:error, :bad_headers}
  end

  defp norm_headers(_), do: {:error, :bad_headers}

  defp norm_tags(%MapSet{} = s), do: {:ok, s}
  defp norm_tags(list) when is_list(list), do: {:ok, MapSet.new(list)}
  defp norm_tags(_), do: {:error, :bad_tags}
end
```

사용 예:

```elixir
opts = [
  endpoint: "https://api.example.com",
  timeout: 2000,
  headers: [accept: "application/json"],
  tags: ~w(api v1)
]

case App.Config.load(opts) do
  {:ok, cfg} ->
    IO.inspect(cfg, label: "config")

  {:error, reason} ->
    IO.inspect(reason, label: "error")
end
```

이 파이프라인에서:

- 외부 인터페이스는 **키워드 리스트**로 유연하게 받는다.
- 내부에서는 **맵/MapSet** 으로 정규화하여 사용상의 일관성을 얻는다.
- 최종 결과는 **구조체**에 담아,
  - 필수 필드 강제,
  - 타입 정보 제공,
  - 패턴매칭/검증 용이성 확보.

---

## 디버깅·탐색 팁

IEx에서 자료형을 탐색하는 도구들:

```elixir
i %{a: 1}
# 타입, 프로토콜, 구조체 여부 등 출력

h Map.update/4
# 문서

t Map
# 타입 스펙

```

실전 디버깅 시:

```elixir
config
|> tap(&IO.inspect(&1, label: "raw config"))
|> some_transform()
|> tap(&IO.inspect(&1, label: "after transform"))
|> other_transform()
```

- `tap/2` 는 중간 값 관찰에 매우 유용하다.

---

## 흔한 함정 → 교정

1) **키워드 리스트를 데이터베이스 레코드처럼 사용**

- 문제: 선형 탐색, 중복 키 허용으로 인한 혼란, 성능 저하.
- 교정:
  - 데이터 저장/조작에는 **맵/구조체**를 사용.
  - 키워드 리스트는 옵션/DSL 용으로만 사용.

2) **맵에서 점 표기의 오용**

- `"name"` 키에 대해 `m.name` 호출 → 컴파일 에러.
- 교정:
  - 문자열 키는 `m["name"]` 또는 `Map.get(m, "name")`.
  - 점 표기는 **아톰 키 + 컴파일 타임 고정** 인 경우에만.

3) **중첩 갱신에서 수작업 복제 남발**

```elixir
# 나쁜 예

profile = m.user.profile
profile2 = %{profile | email: "x"}
user2 = %{m.user | profile: profile2}
m2 = %{m | user: user2}
```

- 교정: `put_in/update_in/get_in` 사용:

```elixir
m2 = put_in(m, [:user, :profile, :email], "x")
```

4) **임의 문자열 → 아톰 변환 남용**

```elixir
String.to_atom(user_input)  # 위험
```

- 아톰은 GC되지 않는다.
- 교정:
  - `String.to_existing_atom/1` 사용.
  - 또는 화이트리스트 방식으로만 변환 허용.

5) **Map.merge 로 의도치 않은 덮어쓰기**

```elixir
Map.merge(%{a: 1}, %{a: 2, b: 3})
# %{a: 2, b: 3}  (뒤의 값이 우선)

```

- 교정:
  - 충돌 정책이 중요한 경우 `Map.merge/3` 사용:

```elixir
Map.merge(a, b, fn key, v1, v2 ->
  resolve(key, v1, v2)
end)
```

---

## 비용 모델 요약

맵/키워드 리스트/MapSet/구조체의 평균 비용 모델(개략)은 다음과 같다.

$$
\begin{aligned}
&\text{Map get/put} \approx O(1), \quad \text{merge} \approx O(n) \\
&\text{Keyword get} \approx O(n) \quad(\text{리스트 선형 탐색}) \\
&\text{MapSet union/intersection/difference} \approx O(n) \\
&\text{Struct update} \approx O(1) \ (\text{실제로는 공유되는 구조 재사용})
\end{aligned}
$$

불변 구조에서의 갱신 비용:

- 맵/구조체를 갱신할 때 전체를 복사하는 것이 아니라,
  **변경된 경로 주변만 새 노드**를 만들고 나머지는 공유한다.
- 따라서 “눈에 보이는 크기”에 비해 실제 복사 비용이 줄어든다.
- 하지만, 큰 맵을 매우 자주 갱신하는 워크로드에서는
  여전히 **GC/캐시 영향**을 고려해야 한다.

---

## 연습 문제

마지막으로 연습 문제로 내용을 정리해 보자.

1) **안전 옵션 파서**

```elixir
# 요구사항:
# ::
#   {:ok, %Config{}} | {:error, reason}
#
# 필수:
#   :host (binary)
# 선택:
#   :retries (integer, >= 0, 기본값 3)
#   :headers (keyword 또는 map)
#
# 구현:
#   - 키워드 리스트로 입력 받기
#   - 내부에서는 구조체로 반환
#   - 실패 사유를 세분화(:missing_host, :bad_retries, :bad_headers 등)

```

2) **중첩 갱신**

```elixir
# ::
#   path: [:top_key, :sub_key, ...]
#   - path로 지정된 위치의 숫자 필드를 1 증가
#   - 없으면 1로 생성
#   - get_and_update_in/3, Access 사용

```

3) **태그 집합 연산**

```elixir
# ::
#   user_tags : MapSet.t()
#   rule      : %{any: [...], all: [...], none: [...]}
#
# 규칙:
#   - any: 중 하나라도 포함하면 OK
#   - all: 모두 포함해야 OK
#   - none: 하나도 포함하면 안 됨
#   - MapSet 연산으로 구현

```

4) **구조체 유효성**

```elixir
# %User{email: email} 생성 시 이메일 형식 검증:
# :: {:ok, %User{}} | {:error, reason}
#   - 이메일 정규식을 이용해 형식 확인
#   - @type t :: %__MODULE__{...} 로 타입 정의

```

5) **머지 정책**

```elixir
# ::
#   - 둘 다 맵이면 재귀 머지
#   - 둘 다 리스트면 이어 붙이기
#   - 그 외에는 b가 우선
#   - Map.merge/3 로 구현

```

---

## 마무리 정리

- **8.1 선택 기준**
  - 옵션/DSL은 **키워드 리스트**,
  - 일반 데이터/상태는 **맵/구조체**,
  - 고유 원소 모음은 **MapSet**으로 표현한다.

- **8.2 키워드 리스트**
  - 아톰 키 + 순서 + 중복 키 허용.
  - 옵션 우선순위, DSL 구성에 좋지만,
    “데이터 저장소”로 쓰기엔 선형 탐색 + 중복 키 때문에 부적절하다.

- **8.3 맵**
  - 범용 딕셔너리.
  - 점 표기는 “아톰 키 + 컴파일 타임 상수”일 때만.
  - 외부 JSON/내부 도메인 사이에서
    “문자열 키 ↔ 아톰 키” 전략을 명확히 해야 한다.

- **8.4 패턴 매칭**
  - 맵/구조체는 부분 패턴 매칭으로 **필수 필드**를 선언할 수 있다.
  - 핀(`^`)으로 이미 알고 있는 값을 패턴에서 재확인한다.

- **8.5 수정 기법**
  - 얕은 갱신은 `Map.put/3`, 깊은 갱신은 `put_in/update_in/get_in`.
  - 리스트/맵/구조체/MapSet을 Access 경로로 섞어 다루면,
    JSON 수준의 복잡한 중첩 구조도 깔끔하게 갱신할 수 있다.

- **8.6 MapSet**
  - 집합 연산(합·교·차·부분집합/상호배타)을 자연스럽게 제공한다.
  - 태그/권한/기능 플래그 같은 도메인에 특히 적합하다.

- **8.7 구조체**
  - 도메인 모델의 스키마 역할.
  - `@enforce_keys`로 필수 필드 강제,
  - `%{struct | k: v}` 업데이트 문법으로 오타를 초기에 잡을 수 있다.

- **8.8~8.12 실전 파이프라인·연습**
  - Keyword → Map → Struct로 이어지는 설정 파이프라인은
    실제 백엔드/서비스 코드에서 매우 흔한 패턴이다.
  - 연습 문제들로 map/reduce, Access, MapSet, 구조체 패턴을 직접 구현해 보면
    이후 Ecto 스키마, Phoenix 컨트롤러, OTP 서버 상태 등
    상위 레벨 컴포넌트를 이해하는 데 큰 도움이 된다.
