---
layout: post
title: 선형대수 - 선형 결합, 기저, 차원
date: 2025-05-09 21:20:23 +0900
category: 선형대수
---
# 선형 결합, 기저, 차원 — 벡터 공간의 뼈대 이해하기 (전면 개정)

## 0. 표기 규약(Notation)

- 스칼라(실수): $$\alpha,\beta,c_i\in\mathbb{R}$$
- 벡터: $$\mathbf{v},\mathbf{w},\mathbf{x}\in\mathbb{R}^n$$ (열벡터)
- 행렬: $$\mathbf{A}\in\mathbb{R}^{m\times n}$$, 전치: $$\mathbf{A}^\top$$
- 노름: $$\lVert\cdot\rVert\equiv\lVert\cdot\rVert_2$$
- 생성(span): $$\operatorname{span}\{\cdot\}$$, 영벡터: $$\mathbf{0}$$

---

## 1. 선형 결합(Linear Combination)

### 1.1 정의
벡터 집합 $$\{\mathbf{v}_1,\dots,\mathbf{v}_k\}\subset\mathbb{R}^n$$ 과 스칼라 $$c_1,\dots,c_k\in\mathbb{R}$$ 에 대해
$$
\mathbf{u} \;=\; \sum_{i=1}^k c_i\,\mathbf{v}_i
$$
로 표현되는 $$\mathbf{u}$$ 를 **선형 결합**이라 합니다.

### 1.2 기하학적 의미
- 각 벡터를 늘이고(스칼라배) 더해 만든 모든 벡터의 집합이 그 벡터들의 **생성(span)** 입니다.
- $$\operatorname{span}\{\mathbf{v}_1,\mathbf{v}_2\}$$ 가 평면 전체를 덮는다면, 두 벡터는 평면의 “방향 축” 역할을 합니다.

### 1.3 즉시 성질
- $$\operatorname{span}$$ 은 항상 부분공간입니다(원점 포함, 덧셈/스칼라배에 닫힘).
- $$\operatorname{span}\{\mathbf{v}_1,\dots,\mathbf{v}_k\}=\operatorname{span}\{\text{그들을 선형독립으로 줄인 집합}\}$$.

### 1.4 PyTorch 예제 — 선형 결합
```python
import torch
torch.set_printoptions(precision=4, sci_mode=False)

v1 = torch.tensor([1., 2.])
v2 = torch.tensor([3., 1.])
c1, c2 = 2.0, 3.0

u = c1 * v1 + c2 * v2
print("선형 결합 2*v1 + 3*v2 =", u)  # tensor([11.,  7.])
```

---

## 2. 선형독립과 생성

### 2.1 선형독립 정의
벡터들 $$\{\mathbf{v}_1,\dots,\mathbf{v}_k\}$$ 가
$$
\sum_{i=1}^k c_i\,\mathbf{v}_i=\mathbf{0}
\ \Rightarrow\
c_1=\cdots=c_k=0
$$
를 만족하면 **선형독립**, 아니면 **선형종속**입니다.

### 2.2 생성과의 관계
- 생성은 “공간을 모두 만들 수 있는가”라는 **범위**의 조건.
- 선형독립은 “중복 없이 최소인가”라는 **중복 배제**의 조건.

둘을 동시에 만족하는 최소 집합이 **기저**입니다.

### 2.3 독립성 판정법(유한차원)
- 열로 쌓은 행렬 $$\mathbf{V}=[\mathbf{v}_1\ \cdots\ \mathbf{v}_k]\in\mathbb{R}^{n\times k}$$ 의 **랭크**가 $$k$$ 이면 독립.
- $$k\le n$$ 이 필수(벡터 개수 > 차원 ⇒ 반드시 종속).

### 2.4 PyTorch 예제 — 독립성 검사(랭크)
```python
import torch

def is_independent(vecs, tol=1e-10):
    # vecs: list of 1D tensors (same length)
    V = torch.stack(vecs, dim=1).double()  # n x k
    # SVD 기반 랭크
    _, S, _ = torch.linalg.svd(V, full_matrices=False)
    r = int((S > tol * S.max()).sum().item())
    return r == V.size(1), r

v1 = torch.tensor([1., 1.])
v2 = torch.tensor([1., -1.])
print("독립성:", is_independent([v1, v2]))  # (True, 2)
```

---

## 3. 기저(Basis)

### 3.1 정의
벡터 공간 $$V$$ 의 부분집합 $$\mathcal{B}=\{\mathbf{b}_1,\dots,\mathbf{b}_d\}$$ 가
1) 선형독립이고
2) $$V=\operatorname{span}\mathcal{B}$$ 를 만족하면
**기저**라 합니다.

### 3.2 최소 생성 집합
기저는 “생성”을 만족하는 집합 중 **가장 작음**(어떤 벡터도 다른 것들의 선형 결합으로 대체 불가).

### 3.3 예시
- $$\mathbb{R}^2$$: 표준기저 $$\{(1,0)^\top,(0,1)^\top\}$$, 혹은 $$\{(1,1)^\top,(1,-1)^\top\}$$ 도 기저(정사각행렬 행렬식이 0이 아니면 가능).
- $$\mathcal{P}_2$$(차수 ≤ 2 다항식): $$\{1,x,x^2\}$$ 가 기저, 차원 3.

### 3.4 좌표 표현
기저 $$\mathcal{B}=\{\mathbf{b}_1,\dots,\mathbf{b}_d\}$$ 에 대해 임의의 $$\mathbf{x}\in V$$ 는
$$
\mathbf{x}=\sum_{i=1}^d c_i\,\mathbf{b}_i,\qquad
[\mathbf{x}]_{\mathcal{B}}=
\begin{bmatrix}
c_1\\ \vdots\\ c_d
\end{bmatrix}.
$$
이 표현은 **유일**합니다.

### 3.5 PyTorch 예제 — 기저 좌표 구하기
정사각 기저행렬 $$\mathbf{B}\in\mathbb{R}^{n\times n}$$ 에 대해 $$\mathbf{x}=\mathbf{B}\mathbf{c}$$ ⇒ $$\mathbf{c}=\mathbf{B}^{-1}\mathbf{x}$$.
```python
import torch

B = torch.tensor([[1., 1.],
                  [1., -1.]])     # 기저 벡터를 열로
x = torch.tensor([3., 1.])

c = torch.linalg.solve(B, x)       # c = [x]_B
print("기저 좌표 c:", c)
print("복원 B c:", B @ c)          # x와 일치
```

---

## 4. 차원(Dimension)

### 4.1 정의
벡터 공간 $$V$$ 의 **차원**은 그 공간의 기저 벡터 개수입니다.
- $$\dim(\mathbb{R}^n)=n$$
- 원점을 지나는 직선: 차원 1
- 원점을 지나는 평면: 차원 2
- $$\mathcal{P}_k$$: 차원 $$k+1$$

### 4.2 핵심 정리
- 유한차원 공간에서 모든 기저의 크기는 동일합니다(차원의 불변성).
- $$\dim(\operatorname{span}\{\mathbf{v}_1,\dots,\mathbf{v}_k\})\le k$$, 등호는 독립일 때.

### 4.3 차원과 행렬
- 열공간의 차원 = 랭크
- 영공간의 차원 = 널리티(nullity)
- **랭크–널리티 정리**: $$\operatorname{rank}(\mathbf{A})+\operatorname{nullity}(\mathbf{A})=n$$ (열 수).

---

## 5. 기저 구성과 축소: RREF/SVD/QR, 그람–슈미트

### 5.1 실전 알고리즘 개요
- RREF(가우스 소거): 피벗 열이 기저를 줌(수치적 불안정 가능).
- QR 분해: 정규직교 기저 획득(열 독립 판단).
- SVD: 수치적으로 가장 견고(특이값 임계로 랭크/기저 판정).

### 5.2 PyTorch — 열공간/영공간 기저(SVD)
```python
import torch

def colspace_basis(A, tol=1e-12):
    U, S, Vh = torch.linalg.svd(A, full_matrices=False)
    r = int((S > tol * S.max()).sum().item())
    return U[:, :r]  # 정규직교 기저 (열공간)

def nullspace_basis(A, tol=1e-12):
    U, S, Vh = torch.linalg.svd(A, full_matrices=False)
    mask = S <= tol * S.max()
    if not torch.any(mask):     # 널리티 0
        return torch.empty(A.size(1), 0, dtype=A.dtype)
    return Vh[mask, :].T        # 영공간 기저(열)

A = torch.tensor([[1., 2., 3.],
                  [2., 4., 6.],
                  [0., 1., 1.]], dtype=torch.float64)

Q_col = colspace_basis(A)
N = nullspace_basis(A)
print("rank =", Q_col.size(1))
print("Col(A) 기저 Q:\n", Q_col)
print("Null(A) 기저 N:\n", N)
```

### 5.3 PyTorch — 수정 그람–슈미트(MGS)로 기저 정규직교화
```python
import torch

def modified_gram_schmidt(V, tol=1e-12):
    # V: n x k (열에 벡터)
    V = V.clone().double()
    n, k = V.shape
    Q = []
    for j in range(k):
        v = V[:, j]
        for q in Q:
            v = v - (q @ v) * q
        nrm = torch.linalg.norm(v)
        if nrm > tol:
            Q.append(v / nrm)
    if not Q:
        return torch.zeros(n, 0, dtype=V.dtype)
    return torch.stack(Q, dim=1)

V = torch.tensor([[1., 1., 2.],
                  [0., 1., 1.],
                  [1., 2., 3.]], dtype=torch.float64)
Q = modified_gram_schmidt(V)
print("정규직교 기저 Q:\n", Q)
print("Q^T Q ~ I:\n", Q.T @ Q)
```

---

## 6. 기저변환(Change of Basis)와 좌표

### 6.1 정의
기저 $$\mathcal{B}=\{\mathbf{b}_1,\dots,\mathbf{b}_n\}$$, $$\mathcal{C}=\{\mathbf{c}_1,\dots,\mathbf{c}_n\}$$ 의 열행렬을 각각
$$
\mathbf{B}=[\mathbf{b}_1\ \cdots\ \mathbf{b}_n],\quad
\mathbf{C}=[\mathbf{c}_1\ \cdots\ \mathbf{c}_n]
$$
라 하면, 임의의 벡터 $$\mathbf{x}$$ 에 대해
$$
\mathbf{x}=\mathbf{B}[\mathbf{x}]_{\mathcal{B}}=\mathbf{C}[\mathbf{x}]_{\mathcal{C}}
\ \Rightarrow\
[\mathbf{x}]_{\mathcal{C}}=\underbrace{\mathbf{C}^{-1}\mathbf{B}}_{\mathbf{P}_{\mathcal{C}\leftarrow\mathcal{B}}}[\mathbf{x}]_{\mathcal{B}}.
$$
즉, **기저변환 행렬**은 $$\mathbf{P}_{\mathcal{C}\leftarrow\mathcal{B}}=\mathbf{C}^{-1}\mathbf{B}$$.

### 6.2 PyTorch — 기저변환 예제
```python
import torch

B = torch.tensor([[1., 1.],
                  [1., -1.]], dtype=torch.float64)  # 기저 B
C = torch.tensor([[2., 0.],
                  [0., 1.]], dtype=torch.float64)   # 기저 C

P_C_from_B = torch.linalg.inv(C) @ B

xB = torch.tensor([3., -1.], dtype=torch.float64)   # [x]_B
xC = P_C_from_B @ xB                                 # [x]_C

# 검증: x = B xB = C xC
x1 = B @ xB
x2 = C @ xC
print("기저변환 P_C<-B:\n", P_C_from_B)
print("x (B좌표) =", x1, "  x (C좌표) =", x2)
```

---

## 7. 차원과 제약: 해공간·행/열공간

### 7.1 동차 선형방정식의 해공간(영공간)
$$
\mathcal{N}(\mathbf{A})=\{\mathbf{x}\in\mathbb{R}^n:\mathbf{A}\mathbf{x}=\mathbf{0}\}
$$
은 부분공간이며, $$\dim\mathcal{N}(\mathbf{A})=\text{nullity}(\mathbf{A})$$.

### 7.2 열공간과 랭크
$$
\operatorname{Col}(\mathbf{A})=\{\mathbf{A}\mathbf{x}:\mathbf{x}\in\mathbb{R}^n\},\quad
\dim\operatorname{Col}(\mathbf{A})=\operatorname{rank}(\mathbf{A}).
$$

### 7.3 랭크–널리티 정리
열 수가 $$n$$ 인 $$\mathbf{A}$$ 에 대해
$$
\operatorname{rank}(\mathbf{A})+\operatorname{nullity}(\mathbf{A})=n.
$$

### 7.4 PyTorch — 랭크/널리티 확인
```python
import torch

A = torch.tensor([[1., 2., 3.],
                  [2., 4., 6.],
                  [0., 1., 1.]], dtype=torch.float64)

U, S, Vh = torch.linalg.svd(A, full_matrices=False)
tol = 1e-12
rank = int((S > tol * S.max()).sum().item())
nullity = A.size(1) - rank

print("rank =", rank, " nullity =", nullity, "  rank+nullity =", rank + nullity)
```

---

## 8. “어떤 벡터가 주어진 생성 안에 있는가?” — 판정법

### 8.1 잔차 투영 판정
생성자들을 열로 쌓아 $$\mathbf{V}\in\mathbb{R}^{n\times k}$$, 후보벡터 $$\mathbf{x}$$ 에 대해
정규직교 기저 $$\mathbf{Q}$$ 로의 투영
$$
\mathbf{P}=\mathbf{Q}\mathbf{Q}^\top,\quad
\lVert (\mathbf{I}-\mathbf{P})\mathbf{x}\rVert \le \varepsilon
$$
이면 수치적으로 span 안에 있습니다.

### 8.2 PyTorch — in-span 검사
```python
import torch

def in_span(V, x, tol=1e-10):
    # V: n x k (열=생성자), x: n
    U, S, Vh = torch.linalg.svd(V, full_matrices=False)
    r = int((S > tol * S.max()).sum().item())
    Q = U[:, :r] if r > 0 else torch.zeros(V.size(0), 0, dtype=V.dtype)
    P = Q @ Q.T if r > 0 else torch.zeros(V.size(0), V.size(0), dtype=V.dtype)
    resid = torch.linalg.norm((torch.eye(V.size(0)) - P) @ x)
    return bool(resid <= 1e-8), resid.item()

V = torch.tensor([[1., 1.],
                  [0., 1.]], dtype=torch.float64)
x1 = torch.tensor([2., 1.], dtype=torch.float64)
x2 = torch.tensor([1., 3.], dtype=torch.float64)

print("x1 in span(V)?", in_span(V, x1))
print("x2 in span(V)?", in_span(V, x2))
```

---

## 9. 실제 시나리오

1) 데이터 압축/차원 축소: PCA는 공분산 행렬의 고유벡터(직교 기저)를 선택하여 **저차원 기저**를 만든 뒤 좌표로 표현합니다.
2) 좌표계 변경: 물리/그래픽스에서 다른 기준 벡터 집합(기저)로 **좌표를 변환**하면 계산이 단순해집니다.
3) 제약 시스템: 선형 제약 $$\mathbf{A}\mathbf{x}=\mathbf{0}$$ 의 해는 **영공간 기저**의 선형 결합으로 전개됩니다.
4) 피처 재표현: 서로 다른 피처 축(기저)으로 벡터를 표현하면 회귀/분류의 해석이 쉬워질 수 있습니다.

---

## 10. 흔한 실수와 방어 전략

- 기저에 영벡터 포함 금지(독립 위반).
- $$k>n$$ 인 $$k$$개 벡터는 반드시 종속.
- 수치적 독립/랭크는 **임계값(tol)** 설정에 민감(스케일 표준화·float64 권장).
- 기저변환 행렬은 **기저행렬의 역**이 필요(정사각·가역 여부 확인).
- “합집합 차원”이 아니라 **부분공간의 합/교집합**을 다룸: $$\dim(U+W)=\dim U+\dim W-\dim(U\cap W)$$.

---

## 11. 연습문제(해설 힌트 포함)

1) $$\mathbb{R}^3$$ 에서 벡터
   $$\mathbf{v}_1=(1,0,1)^\top,\ \mathbf{v}_2=(0,1,1)^\top,\ \mathbf{v}_3=(1,1,2)^\top$$
   가 선형종속임을 보이고(힌트: $$\mathbf{v}_3=\mathbf{v}_1+\mathbf{v}_2$$), 기저를 제시하시오.

2) $$\mathbb{R}^2$$ 의 집합 $$\{(1,1)^\top,(2,3)^\top\}$$ 가 기저임을 보이고, 벡터 $$\mathbf{x}=(4,5)^\top$$ 의 해당 기저 좌표를 구하시오.
   힌트: 기저행렬 $$\mathbf{B}=[(1,1)^\top,(2,3)^\top]$$ 에 대해 $$\mathbf{B}\mathbf{c}=\mathbf{x}$$ 풀기.

3) 행렬
   $$\mathbf{A}=\begin{bmatrix}1&2&3\\2&4&6\\0&1&1\end{bmatrix}$$
   에 대해 랭크와 널리티를 구하고, 열공간/영공간의 기저를 구하시오.
   힌트: SVD 또는 RREF.

4) 기저 $$\mathcal{B}=\{(1,1)^\top,(1,-1)^\top\},\ \mathcal{C}=\{(2,0)^\top,(0,1)^\top\}$$ 에 대해 기저변환 행렬 $$\mathbf{P}_{\mathcal{C}\leftarrow\mathcal{B}}$$ 를 구하고, $$[\mathbf{x}]_{\mathcal{B}}=(3,-1)^\top$$ 의 $$[\mathbf{x}]_{\mathcal{C}}$$ 를 계산하시오.

5) $$\mathcal{P}_3$$ 에서 부분공간 $$W=\{p(x): p(1)=0\}$$ 의 차원과 기저를 구하시오.
   힌트: $$p(1)=0 \Rightarrow (x-1)$$ 인자를 갖습니다.

---

## 12. 요약

- **선형 결합**: 벡터를 스칼라배·덧셈으로 조합한 결과.
- **기저**: 선형독립이면서 공간을 생성하는 최소 집합 → 유일한 좌표 표현 제공.
- **차원**: 기저의 크기(불변). 랭크–널리티로 행렬 제약과 직결.
- **실전**: SVD/QR로 기저·차원·투영을 안정적으로 계산, 기저변환으로 좌표계를 바꾸어 해석/계산 단순화.
