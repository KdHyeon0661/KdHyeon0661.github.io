---
layout: post
title: 선형대수 - 가우스 소거법
date: 2025-05-14 20:20:23 +0900
category: 선형대수
---
# 가우스 소거법(Gaussian Elimination) — 연립방정식의 강력한 해법

## 0. 표기

- 선형계: $$\mathbf{A}\mathbf{x}=\mathbf{b}$$, $$\mathbf{A}\in\mathbb{R}^{m\times n}$$, $$\mathbf{x}\in\mathbb{R}^n$$, $$\mathbf{b}\in\mathbb{R}^m$$  
- 확대행렬(augmented): $$[\ \mathbf{A}\ |\ \mathbf{b}\ ] \in \mathbb{R}^{m\times (n+1)}$$  
- 전치: $$\mathbf{A}^\top$$, 단위행렬: $$\mathbf{I}$$

---

## 1. 기본 아이디어

가우스 소거는 행 연산으로 $$[\ \mathbf{A}\ |\ \mathbf{b}\ ]$$ 를 **위 삼각 형태(REF)** 또는 더 강한 **기약 행 사다리꼴(RREF)** 로 만들고,  
REF이면 **후방 대입**으로, RREF이면 바로 해를 읽어 해결합니다.

- REF(행 사다리꼴): 각 행의 첫 비영(피벗)이 아래 행의 피벗보다 오른쪽에 위치, 피벗 아래는 0.
- RREF(기약): REF 조건 + 각 피벗 위아래가 0, 피벗은 1.

---

## 2. 기본 행 연산(Row Operations)

1) 행 교환: $$R_i \leftrightarrow R_j$$  
2) 스칼라 배: $$R_i \leftarrow c\cdot R_i,\ c\neq 0$$  
3) 행 대치: $$R_i \leftarrow R_i + c\cdot R_j$$

이 연산은 **해 집합을 보존**합니다(해의 존재·개수는 유지).

---

## 3. 단계적 절차(개요)

1) 확대행렬 구성: $$[\ \mathbf{A}\ |\ \mathbf{b}\ ]$$  
2) 열마다 피벗을 선택하고(보통 절댓값 최대: **부분 피벗팅**) 피벗 아래를 0으로 만듭니다(전진 소거).  
3) REF 완성 후, 뒤에서부터 **후방 대입**으로 미지수 계산.  
4) RREF까지 만들면 자유변수에 대한 **매개변수 해**를 바로 읽을 수 있습니다.

---

## 4. 피벗팅과 수치 안정성

- **부분 피벗팅**: 현재 열에서 절댓값이 가장 큰 항을 피벗으로 행 교환.  
- **이유**: 작은 피벗은 큰 나눗셈을 초래하여 **반올림 오차를 증폭**시킴.  
- **완전 피벗팅**: 행·열 모두 교환(더 안정적이나 비용 증가).  
- **권장**: 실수 연산에서는 부분 피벗팅을 기본으로 사용.

---

## 5. 해의 분류: 랭크와 자유도

랭크 표기로 $$r(\mathbf{A})=\operatorname{rank}(\mathbf{A})$$, $$r([\mathbf{A}|\mathbf{b}])$$.

- **해 존재 조건**(Rouché–Capelli 정리):  
  $$r(\mathbf{A})=r([\mathbf{A}|\mathbf{b}]) \iff \text{해 존재}.$$
- **해의 개수**:  
  - 유일해: $$r(\mathbf{A})=r([\mathbf{A}|\mathbf{b}])=n$$  
  - 무한해: $$r(\mathbf{A})=r([\mathbf{A}|\mathbf{b}])<n$$ → 자유변수 수는 $$n-r(\mathbf{A})$$  
  - 무해(불일치): $$r(\mathbf{A})<r([\mathbf{A}|\mathbf{b}])$$

---

## 6. 예제

### 6.1 유일해 예제(사용자 예시 확장)

연립방정식
$$
\begin{cases}
x+y+z=6\\
2y+5z=-4\\
2x+5y-z=27
\end{cases}
$$

확대행렬
$$
\left[
\begin{array}{ccc|c}
1&1&1&6\\
0&2&5&-4\\
2&5&-1&27
\end{array}
\right].
$$

전진 소거:
- $$R_3 \leftarrow R_3 - 2R_1 \Rightarrow \left[\begin{smallmatrix}1&1&1&6\\0&2&5&-4\\0&3&-3&15\end{smallmatrix}\right]$$  
- $$R_3 \leftarrow R_3 - \tfrac{3}{2}R_2 \Rightarrow \left[\begin{smallmatrix}1&1&1&6\\0&2&5&-4\\0&0&-10.5&21\end{smallmatrix}\right]$$

후방 대입:
$$
-10.5z=21\Rightarrow z=-2,\quad 2y+5(-2)=-4\Rightarrow y=3,\quad x=6-y-z=5.
$$
유일해 $$\mathbf{x}=[5,3,-2]^\top$$.

---

### 6.2 무해(불일치) 예제

$$
\begin{cases}
x+y+z=1\\
2x+2y+2z=3\\
-x-y-z=-2
\end{cases}
\Rightarrow
\left[
\begin{array}{ccc|c}
1&1&1&1\\
2&2&2&3\\
-1&-1&-1&-2
\end{array}
\right].
$$

전진 소거를 하면 마지막에 $$[0\ 0\ 0\ |\ c]$$ 꼴(예: $$c=1$$)이 나타납니다.  
즉 $$0=1$$ 형태 → **해가 없음**.  
랭크 판정: $$r(\mathbf{A})=1,\ r([\mathbf{A}|\mathbf{b}])=2 \Rightarrow \text{불일치}$$.

---

### 6.3 무한해(자유변수) 예제

$$
\begin{cases}
x+y+z=2\\
2x+2y+2z=4\\
0=0
\end{cases}
\Rightarrow
\left[
\begin{array}{ccc|c}
1&1&1&2\\
2&2&2&4\\
0&0&0&0
\end{array}
\right].
$$

소거 후 RREF의 한 줄만 독립.  
랭크는 1, 미지수 3 → 자유변수 2개.  
예를 들어 $$y=s,\ z=t$$ 로 두면  
$$
x=2-y-z=2-s-t,\quad
\mathbf{x}=\begin{bmatrix}2-s-t\\ s\\ t\end{bmatrix},\ s,t\in\mathbb{R}.
$$

---

## 7. 계산 복잡도·수치 주의

- 전진 소거(피벗팅 포함): 대략 $$\tfrac{2}{3}n^3$$ FLOPs.  
- 후방 대입: $$O(n^2)$$.  
- 수치안정성: 작은 피벗(또는 0)은 **큰 배율**을 만들어 오차 증폭 → **부분 피벗팅** 사용.  
- 조건수 $$\kappa(\mathbf{A})$$ 가 크면(ill-conditioned) 해가 작은 데이터 교란에 민감.

---

## 8. PyTorch 구현

아래 구현은 교육용으로 **부분 피벗팅**을 포함한 가우스 소거와 RREF, 해 분류 유틸을 제공합니다.  
실전에서는 `torch.linalg.solve` 또는 LU/QR/SVD 기반 해법을 권장합니다.

```python
import torch
torch.set_printoptions(precision=6, sci_mode=False)
dtype = torch.float64

def gaussian_elimination_solve(A, b, atol=1e-12):
    """
    부분 피벗팅 포함 가우스 소거 + 후방 대입으로 Ax=b를 풉니다.
    유일해가 있는 정방(또는 랭크가 충분한) 케이스를 가정합니다.
    """
    A = A.clone().to(dtype)
    b = b.clone().to(dtype).reshape(-1, 1)
    m, n = A.shape
    assert m == n, "정방행렬 A만 지원(교육용). 비정방은 RREF 활용 권장."
    Ab = torch.cat([A, b], dim=1)

    for col in range(n):
        # 부분 피벗팅: 현재 열의 최대 절댓값 행 선택
        pivot_row = col + torch.argmax(torch.abs(Ab[col:, col]))
        pivot_row = int(pivot_row)
        # 행 교환
        if pivot_row != col:
            Ab[[col, pivot_row], :] = Ab[[pivot_row, col], :]

        pivot = Ab[col, col].item()
        if abs(pivot) < atol:
            raise RuntimeError("피벗이 0에 가까움: 특이 혹은 ill-conditioned")

        # 피벗 아래 제거
        for row in range(col+1, n):
            factor = Ab[row, col] / Ab[col, col]
            Ab[row, col:] -= factor * Ab[col, col:]

    # 후방 대입
    x = torch.zeros((n, 1), dtype=dtype)
    for i in range(n-1, -1, -1):
        s = Ab[i, i+1:n] @ x[i+1:n]
        denom = Ab[i, i]
        if abs(denom) < atol:
            raise RuntimeError("후방 대입 실패: 0 피벗")
        x[i] = (Ab[i, -1] - s) / denom

    return x.flatten()

def rref(A, b=None, atol=1e-12):
    """
    RREF로 변환. b가 주어지면 [A|b]에 대해 수행하고 결과를 반환.
    반환: R, pivot_cols
    """
    if b is not None:
        Aext = torch.cat([A.clone().to(dtype), b.clone().to(dtype).reshape(-1,1)], dim=1)
    else:
        Aext = A.clone().to(dtype)

    m, p = Aext.shape
    i = 0  # 현재 행
    pivot_cols = []

    for j in range(p if b is None else p-1):  # 마지막 열은 b일 수 있음
        # 피벗 행 선택(절댓값 최대)
        pivot_row = None
        maxv = 0.0
        for r in range(i, m):
            v = abs(Aext[r, j].item())
            if v > maxv + 0.0:
                maxv = v
                pivot_row = r
        if pivot_row is None or maxv < atol:
            continue  # 피벗 없음(해당 열은 자유 변수)

        # 행 교환
        if pivot_row != i:
            Aext[[i, pivot_row], :] = Aext[[pivot_row, i], :]

        # 피벗 1로 정규화
        pivot = Aext[i, j]
        Aext[i, :] = Aext[i, :] / pivot

        # 위/아래 소거
        for r in range(m):
            if r == i: 
                continue
            factor = Aext[r, j]
            if abs(factor) > atol:
                Aext[r, :] -= factor * Aext[i, :]

        pivot_cols.append(j)
        i += 1
        if i >= m: 
            break

    return Aext, pivot_cols

def classify_solutions(A, b, atol=1e-10):
    """
    랭크를 이용해 해의 존재/개수를 판정.
    반환: kind, rankA, rankAb, free_vars
    """
    A = A.to(dtype)
    b = b.to(dtype).reshape(-1,1)
    Ab = torch.cat([A, b], dim=1)
    # torch.linalg.matrix_rank 는 수치 tol 자동 결정(데이터 스케일에 의존)
    rankA  = torch.linalg.matrix_rank(A)
    rankAb = torch.linalg.matrix_rank(Ab)
    m, n = A.shape
    if rankA < rankAb:
        return "inconsistent", int(rankA.item()), int(rankAb.item()), None
    elif rankA == n and rankAb == n:
        return "unique", int(rankA.item()), int(rankAb.item()), 0
    else:
        free = n - int(rankA.item())
        return "infinite", int(rankA.item()), int(rankAb.item()), free

# 1. 유일해 예제
A1 = torch.tensor([[1.,1.,1.],
                   [0.,2.,5.],
                   [2.,5.,-1.]], dtype=dtype)
b1 = torch.tensor([6., -4., 27.], dtype=dtype)
kind, rA, rAb, free = classify_solutions(A1, b1)
x1 = gaussian_elimination_solve(A1, b1)
print("예제1 유형:", kind, "랭크:", rA, rAb, "해:", x1.tolist())

# 2. 무해 예제
A2 = torch.tensor([[1.,1.,1.],
                   [2.,2.,2.],
                   [-1.,-1.,-1.]], dtype=dtype)
b2 = torch.tensor([1., 3., -2.], dtype=dtype)
kind, rA, rAb, free = classify_solutions(A2, b2)
R2, piv2 = rref(A2, b2)
print("예제2 유형:", kind, "랭크:", rA, rAb, "\nRREF:\n", R2)

# 3. 무한해 예제
A3 = torch.tensor([[1.,1.,1.],
                   [2.,2.,2.],
                   [0.,0.,0.]], dtype=dtype)
b3 = torch.tensor([2., 4., 0.], dtype=dtype)
kind, rA, rAb, free = classify_solutions(A3, b3)
R3, piv3 = rref(A3, b3)
print("예제3 유형:", kind, "랭크:", rA, rAb, "자유변수:", free, "\nRREF:\n", R3)
```

설명:
- `gaussian_elimination_solve` 는 부분 피벗팅+후방대입으로 유일해를 구합니다.  
- `rref` 는 RREF와 피벗 열을 주며, 자유변수는 피벗 열이 아닌 열들입니다.  
- `classify_solutions` 는 랭크 비교로 해의 존재/개수를 판정합니다.

---

## 9. 해를 벡터공간 관점에서 읽기(RREF 기반)

RREF $$[\ \mathbf{I}_r\ |\ \mathbf{F}\ |\ \mathbf{c}\ ]$$ 꼴이라면(피벗 열 $$r$$개):
- 피벗 변수 $$\mathbf{x}_p=\mathbf{c}-\mathbf{F}\mathbf{x}_f$$
- 자유변수 $$\mathbf{x}_f$$ 는 임의의 벡터  
따라서 일반해는
$$
\mathbf{x}=\begin{bmatrix}\mathbf{x}_p\\ \mathbf{x}_f\end{bmatrix}
=
\begin{bmatrix}\mathbf{c}\\ \mathbf{0}\end{bmatrix}
+
\sum_{j} \alpha_j
\begin{bmatrix}-\mathbf{f}_j\\ \mathbf{e}_j\end{bmatrix},
$$
여기서 $$\mathbf{f}_j$$ 는 $$\mathbf{F}$$ 의 열, $$\mathbf{e}_j$$ 는 표준기저, $$\alpha_j\in\mathbb{R}$$.

---

## 10. 실전 팁

1) **정방·다수 우변**: 한 번 분해(LU/QR) 후 재사용.  
2) **SPD**(대칭 양의정부호): 촐레스키를 쓸 것(더 빠르고 안정적).  
3) **직사각 최소제곱**: QR 또는 SVD 사용.  
4) **조건수 점검**: `torch.linalg.cond`(2-노름, SVD 기반)로 민감도 확인.  
5) **정확성 검사**: 잔차 $$\|\mathbf{A}\mathbf{x}-\mathbf{b}\|/\|\mathbf{b}\|$$, 피벗 크기 모니터링.  
6) **정수/유리수 정확 해**: 부동소수 대신 유리수/정수 연산(분수 소거) 또는 심볼릭 CAS 사용.

---

## 11. 연습문제(해설 스케치)

1) 부분 피벗팅 없이 작은 피벗이 만드는 오차 사례를 구성하고, 부분 피벗팅 적용 전후 해의 상대오차를 비교하라.  
2) 다음 시스템의 해 존재성/개수를 랭크로 판정하고, 자유변수로 일반해를 제시하라:
$$
\begin{cases}
x+2y+z=1\\
2x+4y+2z=2\\
3x+6y+3z=3
\end{cases}
$$
3) RREF로부터 해를 직접 읽어내는 공식을 벡터·블록 행렬 표기법으로 정리하라.  
4) 확대행렬에 행 연산을 적용할 때, 행렬식과 역행렬 계산에 미치는 영향(특히 행 교환의 부호 변화)을 설명하라.

---

## 12. 결론

- 가우스 소거법은 연립 1차 방정식을 푸는 **표준 절차**로, **부분 피벗팅**이 수치안정성의 핵심입니다.  
- 랭크 비교로 **해의 존재/개수**를 체계적으로 판정하고, RREF로 **자유변수 표현**을 얻을 수 있습니다.  
- 실전에서는 문제 구조에 맞춰 LU/QR/Cholesky/SVD 등으로 일반화하여 효율·안정성을 최적화합니다.