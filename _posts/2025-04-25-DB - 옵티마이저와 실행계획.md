---
layout: post
title: DB - 옵티마이저와 실행계획
date: 2025-04-25 21:20:23 +0900
category: DB
---
# SQL 쿼리 최적화와 실행 계획 완전 가이드

## 개요: 옵티마이저의 역할 이해하기

데이터베이스 옵티마이저는 SQL 쿼리를 가장 효율적으로 실행할 수 있는 경로를 찾아내는 핵심 컴포넌트입니다. 같은 SQL 쿼리라도 다양한 실행 경로가 존재할 수 있으며, 옵티마이저는 비용 기반 최적화(Cost-Based Optimization, CBO)를 통해 가장 낮은 비용으로 예상되는 실행 계획을 선택합니다.

옵티마이저의 결정은 주로 다음과 같은 요소에 기반합니다:
- **통계 정보**: 테이블 크기, 데이터 분포, 인덱스 정보 등
- **비용 모델**: CPU, I/O, 메모리 사용에 대한 예상 비용
- **시스템 리소스**: 사용 가능한 메모리, 병렬 처리 능력 등

옵티마이저의 선택이 항상 최적이 아닐 수 있으므로, 개발자와 DBA는 실행 계획을 이해하고 필요한 경우 최적화할 수 있어야 합니다.

---

## 실행 계획의 기초: 비용 모델 이해

옵티마이저는 각 실행 경로의 비용을 계산하여 비교합니다. 핵심 개념은 **선택도**와 **예상 행 수**입니다.

**선택도**는 특정 조건을 만족하는 행의 비율을 의미합니다. 예를 들어, 10,000행 중 100행이 조건을 만족한다면 선택도는 0.01(1%)입니다.

**예상 행 수**는 다음과 같이 계산됩니다:
```
예상 행 수 = 총 행 수 × 선택도
```

여러 조건이 결합된 경우, 옵티마이저는 일반적으로 각 조건의 선택도를 곱하여 전체 선택도를 추정합니다. 이는 조건들이 독립적이라는 가정 하에 이루어지며, 실제 데이터의 상관관계를 반영하지 못할 수 있습니다.

---

## 쿼리 최적화의 첫 번째 단계: SARGable 쿼리 작성

SARGable(Search Argument Able) 쿼리는 인덱스를 효과적으로 사용할 수 있는 쿼리를 의미합니다. 비SARGable 쿼리는 인덱스 사용을 방해하여 성능 저하를 초래합니다.

### 비SARGable 패턴과 개선 방법

```sql
-- 비SARGable: 컬럼에 함수 적용
SELECT * FROM employees 
WHERE YEAR(hire_date) = 2024 AND MONTH(hire_date) = 1;

-- SARGable로 개선
SELECT * FROM employees 
WHERE hire_date >= '2024-01-01' AND hire_date < '2024-02-01';
```

```sql
-- 비SARGable: 왼쪽 와일드카드
SELECT * FROM products 
WHERE product_name LIKE '%apple%';

-- 개선 방법 (전방 일치로 변경)
SELECT * FROM products 
WHERE product_name LIKE 'apple%';

-- 대안: 전문 검색 인덱스 사용
CREATE FULLTEXT INDEX idx_products_name ON products(product_name);
SELECT * FROM products 
WHERE MATCH(product_name) AGAINST('apple');
```

```sql
-- 비SARGable: 암시적 형변환
SELECT * FROM users 
WHERE phone_number = 01012345678;  -- phone_number는 문자열 컬럼

-- SARGable로 개선
SELECT * FROM users 
WHERE phone_number = '01012345678';
```

### 커버링 인덱스 활용
커버링 인덱스는 쿼리에 필요한 모든 컬럼을 포함하여 테이블 접근을 완전히 피할 수 있게 합니다.

```sql
-- SQL Server: INCLUDE 절 사용
CREATE INDEX idx_orders_customer_date 
ON orders(customer_id, order_date) 
INCLUDE (total_amount, status);

-- PostgreSQL: 복합 인덱스 사용
CREATE INDEX idx_orders_customer_date_amount 
ON orders(customer_id, order_date, total_amount);
```

커버링 인덱스를 사용하면 인덱스만 스캔하여 쿼리를 처리할 수 있어 성능이 크게 향상됩니다.

---

## 조인 최적화: 순서와 방식 선택

### 조인 순서 최적화
옵티마이저는 일반적으로 선택도가 높은(많은 행을 걸러내는) 필터를 먼저 적용하여 조인할 행 수를 줄이려고 합니다. 그러나 때로는 옵티마이저의 선택이 최적이 아닐 수 있습니다.

```sql
-- Oracle: LEADING 힌트로 조인 순서 지정
SELECT /*+ LEADING(orders customers) */ *
FROM orders
JOIN customers ON orders.customer_id = customers.id
WHERE orders.total_amount > 1000;

-- MySQL: STRAIGHT_JOIN으로 조인 순서 고정
SELECT *
FROM orders STRAIGHT_JOIN customers 
ON orders.customer_id = customers.id
WHERE orders.total_amount > 1000;
```

### 조인 방식 선택
옵티마이저는 세 가지 주요 조인 방식 중에서 선택합니다:

1. **Nested Loop Join**: 작은 테이블과 인덱스가 있는 테이블 간 조인에 적합
2. **Hash Join**: 대량 데이터와 동등 조인에 적합
3. **Sort Merge Join**: 정렬된 데이터나 정렬 비용이 낮은 경우에 적합

```sql
-- Oracle: USE_NL 힌트로 Nested Loop Join 강제
SELECT /*+ USE_NL(orders customers) */ *
FROM orders
JOIN customers ON orders.customer_id = customers.id;

-- SQL Server: 조인 힌트 사용
SELECT *
FROM orders 
INNER HASH JOIN customers ON orders.customer_id = customers.id;
```

---

## 통계 정보 관리: 옵티마이저의 눈과 귀

옵티마이저가 올바른 결정을 내리려면 정확한 통계 정보가 필수적입니다. 통계 정보에는 다음이 포함됩니다:
- 테이블 통계: 행 수, 페이지/블록 수
- 컬럼 통계: 고유값 수, NULL 비율, 최소/최대값
- 히스토그램: 데이터 분포 정보
- 확장 통계: 컬럼 간 상관관계 정보

### 통계 업데이트 명령어
```sql
-- PostgreSQL
ANALYZE table_name;
ANALYZE VERBOSE table_name;  -- 상세 정보 출력

-- SQL Server
UPDATE STATISTICS table_name;
UPDATE STATISTICS table_name WITH FULLSCAN;  -- 전체 스캔으로 정확도 향상

-- Oracle
BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(
        ownname => 'SCHEMA_NAME',
        tabname => 'TABLE_NAME',
        estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
        method_opt => 'FOR ALL COLUMNS SIZE AUTO'
    );
END;

-- MySQL
ANALYZE TABLE table_name;
```

### 히스토그램과 확장 통계
히스토그램은 데이터의 분포를 보여주어 옵티마이저가 치우친 데이터 분포를 이해할 수 있게 합니다. 확장 통계는 컬럼 간의 상관관계를 캡처하여 더 정확한 선택도 추정을 가능하게 합니다.

```sql
-- PostgreSQL: 확장 통계 생성
CREATE STATISTICS stats_orders_customer_date 
ON customer_id, order_date 
FROM orders;

-- 통계 업데이트
ANALYZE orders;
```

---

## 실행 계획 분석: 데이터베이스별 접근법

실행 계획을 이해하는 것은 쿼리 최적화의 핵심입니다. 각 데이터베이스는 실행 계획을 확인하는 고유한 방법을 제공합니다.

### PostgreSQL
```sql
-- 기본 실행 계획
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;

-- 실제 실행 통계 포함
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 123;

-- 버퍼 사용량 포함
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM orders WHERE customer_id = 123;

-- 자세한 정보 포함
EXPLAIN (ANALYZE, VERBOSE, BUFFERS) SELECT * FROM orders WHERE customer_id = 123;
```

PostgreSQL의 실행 계획에서 주목해야 할 점:
- **실제 행 수 vs 예상 행 수**: 큰 차이가 있다면 통계 정보 문제
- **버퍼 히트율**: 높을수록 캐시 효율이 좋음
- **임시 파일 사용**: work_mem 부족 시 디스크 사용

### MySQL
```sql
-- 기본 실행 계획
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;

-- JSON 형식 (더 자세한 정보)
EXPLAIN FORMAT=JSON SELECT * FROM orders WHERE customer_id = 123;

-- 트리 형식 (MySQL 8.0+)
EXPLAIN FORMAT=TREE SELECT * FROM orders WHERE customer_id = 123;
```

MySQL 실행 계획의 주요 항목:
- **type**: ALL(전체 테이블 스캔), index(인덱스 전체 스캔), ref/range(인덱스 범위 스캔), const(단일 행)
- **key**: 사용된 인덱스
- **rows**: 예상 행 수
- **Extra**: Using index(커버링 인덱스), Using temporary(임시 테이블), Using filesort(정렬 필요)

### SQL Server
```sql
-- 통계 정보 켜기
SET STATISTICS IO ON;
SET STATISTICS TIME ON;

-- 쿼리 실행
SELECT * FROM orders WHERE customer_id = 123;

-- 실행 계획 확인 (SSMS에서 "실제 실행 계획 포함" 클릭)
```

SQL Server 실행 계획 분석 포인트:
- **실제 행 수 vs 예상 행 수**
- **키 조회(Key Lookup)**: 과다하면 커버링 인덱스 고려
- **임시 DB 스필**: 메모리 부족 시 발생

### Oracle
```sql
-- 실행 계획 생성
EXPLAIN PLAN FOR SELECT * FROM orders WHERE customer_id = 123;

-- 실행 계획 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 실제 실행 통계 포함
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null, null, 'ALLSTATS LAST'));
```

---

## 파라미터 스니핑과 실행 계획 안정성

파라미터 스니핑(또는 바인드 피킹)은 첫 번째 쿼리 실행 시의 파라미터 값이 이후 모든 실행에 사용되는 실행 계획을 결정하는 현상입니다. 이는 성능 불안정성을 초래할 수 있습니다.

### 문제 시나리오
```sql
-- 첫 실행: 희귀값으로 인덱스 사용
DECLARE @status VARCHAR(20) = 'CANCELLED';  -- 0.1%만 이 상태
SELECT * FROM orders WHERE status = @status;

-- 이후 실행: 빈번한 값에도 동일한 실행 계획 사용
DECLARE @status VARCHAR(20) = 'SHIPPED';  -- 70%가 이 상태
SELECT * FROM orders WHERE status = @status;  -- 비효율적일 수 있음
```

### 해결 방법
```sql
-- SQL Server: 런타임 재컴파일
SELECT * FROM orders WHERE status = @status
OPTION (RECOMPILE);

-- SQL Server: 특정 값으로 최적화
SELECT * FROM orders WHERE status = @status
OPTION (OPTIMIZE FOR (@status = 'SHIPPED'));

-- SQL Server: 알 수 없는 값으로 최적화
SELECT * FROM orders WHERE status = @status
OPTION (OPTIMIZE FOR (@status UNKNOWN));

-- Oracle: 힌트로 조인 방식 강제
SELECT /*+ USE_NL(orders) */ * FROM orders WHERE status = :status;
```

---

## 성능 문제 진단과 해결 패턴

### 문제 1: 전체 테이블 스캔
**증상**: 실행 계획에 TABLE ACCESS FULL 또는 Seq Scan 표시
**해결**:
- WHERE 절 조건 최적화 (SARGable하게)
- 적절한 인덱스 생성
- 커버링 인덱스 고려

### 문제 2: 키 조회 과다
**증상**: Key Lookup 또는 Bookmark Lookup이 많음
**해결**:
- 커버링 인덱스 생성
- 필요한 컬럼만 SELECT
- 클러스터형 인덱스 재고려

### 문제 3: 정렬 비용 과다
**증상**: Sort 작업이 전체 비용의 큰 부분 차지
**해결**:
- 인덱스를 활용한 정렬
- ORDER BY 절 최적화
- 필요한 행만 먼저 필터링

### 문제 4: 임시 테이블/디스크 스필
**증상**: Using temporary, Using filesort 또는 tempdb 사용량 과다
**해결**:
- 메모리 설정 조정 (work_mem, sort_area_size 등)
- 쿼리 재작성 (조인 순서 변경, 서브쿼리 제거)
- 인덱스 추가

---

## 고급 최적화 기법

### OR 조건을 UNION ALL로 변환
```sql
-- 최적화 전
SELECT * FROM orders 
WHERE (status = 'PENDING' AND created_date > '2024-01-01')
   OR (status = 'SHIPPED' AND ship_date > '2024-01-01');

-- 최적화 후
SELECT * FROM orders 
WHERE status = 'PENDING' AND created_date > '2024-01-01'
UNION ALL
SELECT * FROM orders 
WHERE status = 'SHIPPED' AND ship_date > '2024-01-01';
```
각 조건이 서로 다른 인덱스를 사용할 수 있을 때 특히 유용합니다.

### 상관 서브쿼리를 윈도우 함수로 변환
```sql
-- 최적화 전 (상관 서브쿼리)
SELECT e.*, 
       (SELECT MAX(salary) FROM employees WHERE department_id = e.department_id) 
       AS max_dept_salary
FROM employees e;

-- 최적화 후 (윈도우 함수)
SELECT e.*,
       MAX(salary) OVER (PARTITION BY department_id) AS max_dept_salary
FROM employees e;
```

### 페이징 최적화: OFFSET 대신 키셋 페이징
```sql
-- 비효율적: OFFSET이 클수록 성능 저하
SELECT * FROM orders 
ORDER BY order_date DESC, id DESC
LIMIT 20 OFFSET 10000;

-- 효율적: 키셋 페이징
SELECT * FROM orders 
WHERE (order_date, id) < ('2024-01-15', 5000)
ORDER BY order_date DESC, id DESC
LIMIT 20;
```

---

## 실행 계획 안정화와 관리

### 실행 계획 캐시 관리
실행 계획 캐시는 성능에 중요한 영향을 미칩니다. 너무 많은 실행 계획이 캐시되거나 오래된 실행 계획이 유지되면 문제가 될 수 있습니다.

```sql
-- SQL Server: 쿼리 저장소로 실행 계획 관리
-- 실행 계획 강제
EXEC sp_query_store_force_plan @query_id = 123, @plan_id = 456;

-- 실행 계획 강제 해제
EXEC sp_query_store_unforce_plan @query_id = 123, @plan_id = 456;

-- Oracle: SQL 계획 기준선
-- 계획 수동 수락
DECLARE
    v_report CLOB;
BEGIN
    v_report := DBMS_SPM.EVOLVE_SQL_PLAN_BASELINE(
        sql_handle => 'SYS_SQL_1234567890'
    );
END;
```

### 실행 계획 회귀 감지
실행 계획이 갑자기 성능이 저하되는 경우를 감지하는 것이 중요합니다.

```sql
-- PostgreSQL: pg_stat_statements를 통한 모니터링
SELECT query, calls, total_time, mean_time, rows
FROM pg_stat_statements
WHERE query LIKE '%orders%'
ORDER BY mean_time DESC
LIMIT 10;

-- SQL Server: 쿼리 저장소 보고서
-- SSMS에서 "데이터베이스 → 쿼리 저장소 → 전체 쿼리 통계" 확인
```

---

## 데이터베이스별 특수 고려사항

### PostgreSQL
- **JIT 컴파일**: 고비용 쿼리에서 성능 향상 가능
- **병렬 쿼리**: `max_parallel_workers_per_gather` 설정 확인
- **확장 통계**: 컬럼 간 상관관계 캡처
- **힌트**: 기본적으로 지원하지 않으나 `pg_hint_plan` 확장 사용 가능

### MySQL
- **지속적 통계**: InnoDB 지속적 통계 정보 활용
- **옵티마이저 스위치**: `optimizer_switch` 변수로 동작 제어
- **인덱스 병합**: 여러 인덱스를 동시에 사용
- **히스토그램**: MySQL 8.0부터 지원

### SQL Server
- **파라미터 스니핑**: 실행 계획 안정성에 큰 영향
- **메모리 부여**: 충분한 메모리 할당 중요
- **적응형 조인**: 런타임에 조인 방식 변경 가능
- **배치 모드**: 컬럼스토어 인덱스와 함께 사용 시 성능 향상

### Oracle
- **적응형 커서 공유**: 파라미터 값에 따라 다른 실행 계획 사용
- **카디널리티 피드백**: 실행 중 통계 수집
- **SQL 계획 기준선**: 실행 계획 안정화
- **실제 실행 통계**: `DBMS_XPLAN.DISPLAY_CURSOR`로 확인

---

## 결론

SQL 쿼리 최적화와 실행 계획 분석은 데이터베이스 성능 튜닝의 핵심 기술입니다. 효과적인 최적화를 위한 핵심 원칙은 다음과 같습니다:

1. **SARGable 쿼리 작성**: 옵티마이저가 인덱스를 효과적으로 사용할 수 있도록 쿼리를 작성하세요. 컬럼에 함수를 적용하지 말고, 암시적 형변환을 피하세요.

2. **통계 정보 관리**: 옵티마이저의 결정은 통계 정보의 정확성에 크게 의존합니다. 정기적으로 통계를 업데이트하고, 필요한 경우 히스토그램과 확장 통계를 활용하세요.

3. **실행 계획 분석**: 실행 계획을 읽고 이해하는 능력을 기르세요. 예상 행 수와 실제 행 수의 차이, 인덱스 사용 여부, 조인 방식 등을 분석하세요.

4. **적절한 인덱스 설계**: 쿼리 패턴에 맞는 인덱스를 설계하고, 커버링 인덱스를 적극 활용하세요. 단, 인덱스는 쓰기 성능에 영향을 미치므로 신중하게 선택하세요.

5. **파라미터 스니핑 이해**: 파라미터 값에 따른 실행 계획 변화를 이해하고, 필요한 경우 재컴파일 옵션이나 실행 계획 강제를 활용하세요.

6. **점진적인 접근**: 한 번에 많은 변경을 시도하기보다 작은 변경을 하나씩 적용하고 효과를 측정하세요. 실행 계획 비교와 성능 측정을 체계적으로 수행하세요.

7. **데이터베이스 특성 이해**: 각 데이터베이스 관리 시스템은 고유한 특성과 최적화 기법을 가지고 있습니다. 사용하는 데이터베이스의 특성을 깊이 이해하세요.

쿼리 최적화는 단순히 빠른 쿼리를 작성하는 기술이 아니라, 데이터베이스 시스템의 동작 원리를 이해하고 시스템과 효과적으로 소통하는 능력입니다. 기본 원칙을 이해하고 실전 경험을 쌓다 보면, 복잡한 성능 문제도 체계적으로 진단하고 해결할 수 있게 될 것입니다.

가장 중요한 것은 테스트와 측정입니다. 가정이나 추측에 의존하지 말고, 실제 환경에서 변경 사항의 영향을 측정하고 검증하세요. 이를 통해 지속적으로 시스템 성능을 개선하고 최적의 사용자 경험을 제공할 수 있을 것입니다.