---
layout: post
title: DB - 옵티마이저와 실행계획
date: 2025-04-25 21:20:23 +0900
category: DB
---
# ⚙️ 옵티마이저(Optimizer)와 실행계획(Execution Plan) — 실무 완전 가이드

> 당신이 제공한 기본 글을 바탕으로 **핵심을 압축**하고, 실무에서 바로 쓰는 **확장 내용**(카디널리티/선택도, SARGability, 조인 순서/방식, 통계·히스토그램, 바인드 피킹/파라미터 스니핑, 플랜 캐시·안정화, 병렬/어댑티브, 엔진별 EXPLAIN/힌트, 튜닝 플레이북)을 끝까지 채웠다.  
> 모든 예시는 **문법→왜 그 플랜이 나왔는지→대안** 순서로 제시한다.

---

## 0. 큰 그림: 옵티마이저가 하는 일

- 동일한 SQL이라도 실행 경로는 수십 가지.  
- **CBO(Cost-Based Optimizer)** 는 **통계 정보**를 이용해 **비용(cost)** 을 추정, 최저 비용 플랜을 선택한다.
- 결과는 **실행계획(Execution Plan)** 으로 표현된다.

### 비용 모델의 직관
선택도(selectivity) \(s\)와 예상 행수(cardinality) \(N\)가 있으면, 어떤 필터의 예상 반환 행수는
$$
\text{rows\_out} = N \times s
$$
여러 조건이 독립(independent)이라고 가정하면(단순화) \(s_{\text{total}} \approx \prod_i s_i\).  
이 근사치로 **조인 순서**(먼저 많이 거르는 테이블)와 **조인 방식**(NL/Hash/Merge) 결정에 큰 영향.

---

## 1. 옵티마이저 파이프라인(개념)

1. **파싱/정규화**: 구문 분석, 제한/프로젝션/조인 재배치(연산자 교환법칙, 결합법칙 적용)
2. **카디널리티 추정**: 통계/히스토그램/상관관계 기반으로 각 단계 예상 행수 계산
3. **검색 공간 탐색**: 조인 순서/방식, 액세스 경로(Index/Full/Bitmap) 조합 탐색
4. **비용 평가**: I/O, CPU, 메모리, 네트워크(분산/병렬) 비용 추정
5. **플랜 선택/캐시**: 최저 비용 플랜 채택, 경우에 따라 캐시/바인딩

> 성능이 엇나가면 대부분 **②카디널리티 추정 오류** 또는 **③검색 공간 제약/힌트/규칙** 때문이다.

---

## 2. 액세스 경로 & SARGability

### 2.1 인덱스 사용을 가로막는 패턴(비 SARGable)
```sql
-- 비 SARGable: 컬럼에 함수 → 인덱스 못탐
SELECT * FROM emp WHERE TO_CHAR(hire_date, 'YYYY-MM') = '2025-11';

-- SARGable로 변환
SELECT * FROM emp
WHERE hire_date >= DATE '2025-11-01'
  AND hire_date <  DATE '2025-12-01';
```

```sql
-- 비 SARGable: 좌측 와일드카드
WHERE name LIKE '%kim%'

-- 대안: 역인덱스/Trigram/Fulltext/함수 인덱스 등 엔진별 기능 활용
```

```sql
-- 암묵적 형변환(열 = 숫자)도 인덱스 사용 저해
WHERE phone = 01012341234
-- 대안: 타입 정합성 유지, 리터럴/바인드 타입 명확화
```

### 2.2 커버링 인덱스(Include/복합 인덱스)
```sql
-- SQL Server: include로 커버링
CREATE INDEX ix_orders_cust_date
ON dbo.Orders(customer_id, order_date)
INCLUDE (amount);

-- PostgreSQL: 복합 인덱스 + 필요 컬럼 최소화
CREATE INDEX ON orders (customer_id, order_date);
```
커버링되면 **Bookmark Lookup**/Table Access를 피하고 **Index Only Scan** 가능(PostgreSQL의 *visibility map* 전제).

---

## 3. 조인 순서 & 조인 방식

### 3.1 조인 순서(LEADING/Join Reorder)
- **선택도가 큰 필터 → 먼저** 적용(행수를 급감시켜 NL 효율 ↑)
- 옵티마이저는 통계로 순서를 정하지만, 때로 **힌트/옵션으로 강제**가 필요

```sql
-- Oracle: 조인 선행 테이블 지정
SELECT /*+ LEADING(o c p) */ ...
FROM orders o
JOIN customers c ON ...
JOIN products  p ON ...
```

### 3.2 조인 방식
- **Nested Loop (NL)**: 작은 외부 × 인덱스 있는 내부 → 소량/OLTP 최강
- **Hash Join (HJ)**: 해시 테이블 메모리에 빌드, 큰 데이터/집계 전 조인에 강함
- **Sort Merge Join (SMJ)**: 양쪽 정렬 후 merge. 정렬비용 vs 조인 효율 균형

```sql
-- 강제 힌트 예시
-- Oracle
SELECT /*+ USE_NL(b) */ ...
-- SQL Server
SELECT ... FROM A JOIN B ON ... OPTION (LOOP JOIN);
-- PostgreSQL/야매: enable_hashjoin=off (세션 GUC) 등으로 탐색 공간 제한
```

---

## 4. 집계/정렬 전략: Hash Aggregate vs Sort Aggregate

```sql
-- 해시 집계(충분한 work_mem/hash_area면 강함)
SELECT dept_id, SUM(salary)
FROM emp
GROUP BY dept_id;

-- 인덱스 정렬 활용: 이미 정렬된 키로 그룹핑 → 정렬 비용 절감
CREATE INDEX ix_emp_dept_salary ON emp(dept_id, salary);
```

---

## 5. 통계(Statistics)와 히스토그램

### 5.1 무엇을 갱신하나
- **테이블 통계**: 행수, 페이지/블록 수
- **컬럼 통계**: NDV(고유값 수), NULL 비율, 최소/최대
- **히스토그램**: **치우친 분포**를 잡아내는 핵심(Top-값 skew 인지)
- **확장 통계**(PostgreSQL)/**멀티 컬럼 통계**: 컬럼 상관관계를 반영

```sql
-- Oracle
BEGIN DBMS_STATS.GATHER_TABLE_STATS('HR','EMP', method_opt=>'FOR ALL COLUMNS SIZE AUTO'); END;
-- PostgreSQL
ANALYZE emp;  -- autovacuum/autoanalyze 설정 확인
-- MySQL
ANALYZE TABLE emp;  -- InnoDB persistent stats
-- SQL Server
UPDATE STATISTICS dbo.Emp WITH FULLSCAN;
```

### 5.2 상관관계와 선택도
서로 강하게 연관된 컬럼(A=’KR’, city=’Seoul’)을 **독립**이라고 가정하면 \(s\) 과소/과대 평가 → **잘못된 조인 순서**.  
**확장 통계**(pg 10+) `CREATE STATISTICS ... (dependencies)` 로 완화.

---

## 6. 바인드 피킹/파라미터 스니핑 & 해결

- **Oracle Bind Peeking** / **SQL Server Parameter Sniffing**: 첫 실행의 변수 값(분포)이 **플랜을 결정**, 이후 다른 값에도 같은 플랜 사용 → **불안정**.
- 해결:
  - **옵션 재컴파일/Optimize for**  
  - **플랜 가이드/베이스라인**  
  - **센시티브 쿼리 분기**(선택도 임계값에 따라 다른 SQL)

```sql
-- SQL Server: 런타임 재최적화
SELECT ... 
OPTION (RECOMPILE);

-- SQL Server: 특정 값 기준 최적화
OPTION (OPTIMIZE FOR (@id UNKNOWN));  -- 평균적 분포 가정

-- Oracle: 바인드 민감도(Adaptive Cursor Sharing) 점검, 힌트 USE_NL/USE_HASH 등으로 강제
```

---

## 7. 플랜 캐시 & 플랜 안정화

- **Oracle**: SQL Plan Baselines / Stored Outlines  
- **SQL Server**: Query Store(플랜 강제/회귀 탐지)  
- **PostgreSQL**: 플랜 캐시 단순(준비/바인딩 차이). `pg_hint_plan`(확장)로 힌트 역할 가능  
- **MySQL**: PS/PSM, 8.0 힌트 문법(`/*+ SET_VAR... */`, `JOIN_ORDER`, `INDEX_MERGE` 등)

```sql
-- SQL Server: Query Store 강제
EXEC sp_query_store_force_plan @query_id = 123, @plan_id = 456;
```

---

## 8. 병렬/어댑티브/분산

- **병렬**: 병렬 스캔/조인/집계. 탐색/분할/재분배 비용이 있으니 **대량처리**에서만 이득.
  - Oracle: `/*+ PARALLEL(emp 8) */`, DOP 자동  
  - PostgreSQL: parallel seq scan/parallel hash join/aggregate (work_mem, max_parallel_workers)  
  - SQL Server: MAXDOP, 비용 임계값  
  - MySQL: 옵티마이저 병렬성 제한적(엔진/실행기 관점). 분산은 **Sharding/MPP**로 해결
- **어댑티브**: 러닝 중 카디널리티 관찰해 조인 방식 전환(Oracle Adaptive Plans, SQL Server Adaptive Joins)
- **분산**: Sharding/MPP(Systems): 재분배(Shuffle) 비용이 핵심 → **파티션/샤드 키** 설계가 옵티마이저보다 중요

---

## 9. EXPLAIN/실행계획 읽기 (엔진별 요령)

### 9.1 Oracle
```sql
EXPLAIN PLAN FOR
SELECT * FROM emp WHERE deptno = 10;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(format=>'ALLSTATS LAST'));
```
- **Operation**(TABLE ACCESS FULL/INDEX RANGE SCAN), **Cost/Rows/Bytes**, **Predicate Information** 확인
- `ALLSTATS LAST` 는 **실제 수행 통계**와 비교 가능

### 9.2 PostgreSQL
```sql
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM emp WHERE deptno = 10;
```
- **Actual Rows vs Planned Rows** 차이가 크면 통계/선택도 문제
- **Buffers**(shared hit/read), **I/O** 파악

### 9.3 MySQL
```sql
EXPLAIN FORMAT=TREE
SELECT * FROM emp WHERE deptno = 10;
```
- **type**(ALL, index, ref, range, const, system), **key**, **rows**, **filtered** 확인
- `ANALYZE FORMAT=JSON` 으로 더 자세한 카디널리티/선택도 추정 보기(버전 의존)

### 9.4 SQL Server
- *Actual Execution Plan* 보기 또는
```sql
SET STATISTICS IO, TIME ON;
-- 쿼리 실행 후 I/O/CPU 확인
```
- **Key Lookup**(책갈피 조회) 과다 → **커버링 인덱스(INCLUDE)** 고려
- **Spill to TempDb** 경고 → 메모리 그랜트/쿼리 설계 조정

---

## 10. 튜닝 예제 — 전형적 케이스

### 10.1 날짜 범위 & 함수 제거
```sql
-- Before
SELECT * FROM orders
WHERE DATE(order_time) = CURRENT_DATE;

-- After (SARGable)
SELECT * FROM orders
WHERE order_time >= CURRENT_DATE
  AND order_time <  CURRENT_DATE + INTERVAL '1 day';
```

### 10.2 OR → UNION ALL 분해
```sql
-- Before
WHERE (cust_id = :id AND status = 'PAID')
   OR (cust_id = :id AND ship_date >= CURRENT_DATE);

-- After: 공통 조건 분리 + UNION ALL
SELECT ... WHERE cust_id = :id AND status='PAID'
UNION ALL
SELECT ... WHERE cust_id = :id AND ship_date >= CURRENT_DATE;
```
> 각 분기별 다른 인덱스를 사용하게 돼 **카디널리티 추정과 액세스 경로 최적화**가 쉬움.

### 10.3 조인 순서/방식 고정(필요 시)
```sql
-- SQL Server: 큰 테이블 해시 조인 강제
SELECT ...
FROM big A
JOIN big B ON ...
OPTION (HASH JOIN, MERGE JOIN OFF, LOOP JOIN OFF);
```

### 10.4 Key Lookup 제거(커버링)
```sql
-- SQL Server
CREATE INDEX ix_orders_cust ON dbo.Orders(customer_id) INCLUDE(order_date, amount);
```

### 10.5 상관 서브쿼리 → 조인/윈도우
```sql
-- Before: 상관 서브쿼리(행마다 실행)
SELECT e.*, (SELECT MAX(salary) FROM emp WHERE dept_id = e.dept_id)
FROM emp e;

-- After: 윈도우 함수(1스캔)
SELECT e.*, MAX(salary) OVER (PARTITION BY dept_id) AS max_sal_by_dept
FROM emp e;
```

---

## 11. 힌트: 마지막 수단(그러나 때로는 필요)

| 힌트 | Oracle | SQL Server | PostgreSQL | MySQL |
|---|---|---|---|---|
| 인덱스/풀 | `INDEX`, `FULL` | `INDEX` 힌트 없음(인덱스 강제는 FORCESEEK/쿼리 힌트) | 없음(확장 pg_hint_plan) | `USE INDEX` / `IGNORE INDEX` |
| 조인 순서 | `LEADING` | `JOIN HINTS`(OPTION) | pg_hint_plan `Leading` | `STRAIGHT_JOIN` |
| 조인 방식 | `USE_NL/USE_HASH/USE_MERGE` | `LOOP/HASH/MERGE JOIN` | enable_hashjoin=off 등 GUC | optimizer_switch/힌트 |
| 병렬 | `PARALLEL` | `MAXDOP` | work\_mem/parallel\_* | 제한적 |

> 힌트는 **문제 원인(통계/설계)** 을 가리는 **붕대**가 될 수 있다. 가능하면 근본 해결 후 최종 안전장치로.

---

## 12. 대용량·OLAP 고려: 정렬/메모리/스필

- **정렬/해시 집계**는 메모리 초과 시 **디스크 스필** 발생 → 급격한 저하  
- SQL Server: *Sort/Hash Warning*, TempDB 사용량 관찰  
- PostgreSQL: `work_mem` 적절 조정, `EXPLAIN (ANALYZE, BUFFERS)` 로 temp file 확인  
- Oracle: pga_aggregate_target/hash_area_size, temp usage 모니터

---

## 13. 실전 플레이북(체크리스트)

1. **문제 재현 & 측정**: 평균/최댓값/분산, P95, I/O/CPU/대기 이벤트
2. **실행계획 비교**: Planned vs Actual Rows/Time/IO
3. **SARGability 확보**: 함수/암묵 캐스팅 제거, 범위 조건 재작성
4. **카디널리티 개선**: ANALYZE/DBMS_STATS, 히스토그램/확장통계
5. **조인 전략 조정**: 인덱스 설계(키/순서/커버링), 조인 순서/방식 점검
6. **쿼리 재구성**: OR→UNION ALL, 상관 서브쿼리→조인/윈도우
7. **메모리/병렬/옵션**: work_mem/MAXDOP/parallel 힌트(대용량 한정)
8. **플랜 안정화**: Baseline/Query Store/가이드, 파라미터 스니핑 대응
9. **회귀 방지**: 테스트 케이스+실행계획 스냅샷을 CI에 편입
10. **문서화**: 원인/대안/지표 전후 비교를 기록

---

## 14. 엔진별 미묘한 포인트

- **Oracle**: Adaptive Cursor Sharing, Card. Feedback, SQL Plan Baselines 적극 활용  
- **PostgreSQL**: JIT(고비용 쿼리), parallel query, 확장 통계, `enable_*` GUC로 탐색공간 실험  
- **MySQL**: InnoDB persistent stats/히스토그램(8.0), `EXPLAIN FORMAT=JSON/TREE`, `optimizer_switch`  
- **SQL Server**: Parameter Sniffing, Memory Grant, Adaptive Join, Batch Mode(컬럼스토어/Rowstore on)에 주목

---

## 15. 미니 랩: 같은 질의, 다른 플랜

### 15.1 통계가 없을 때(카디널리티 과소/과대)
```sql
-- PostgreSQL
CREATE TABLE t AS
SELECT generate_series(1,1000000) AS id,
       (CASE WHEN random() < 0.01 THEN 'X' ELSE 'Y' END) AS flag;

-- 통계 초기
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM t WHERE flag='X';

-- ANALYZE 후
ANALYZE t;
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM t WHERE flag='X';
```
> ANALYZE 전에는 선택도 추정이 어긋나 **잘못된 플랜**을 고를 수 있다.

### 15.2 파라미터 민감도
```sql
-- SQL Server (개념)
DECLARE @v CHAR(1) = 'X';  -- 희귀값
SELECT * FROM t WHERE flag = @v; -- 인덱스 탐

-- 이후 @v='Y' (대부분)에도 같은 플랜 사용 → 과도한 Lookup/선택도 엇갈림
```
> `OPTION(RECOMPILE)` 혹은 `OPTIMIZE FOR UNKNOWN`/Query Store 강제로 안정화.

---

## 16. 자주 보는 실행계획 신호 → 처방

| 신호 | 의미 | 처방 |
|---|---|---|
| TABLE ACCESS FULL(대량) | 인덱스 미사용/비 SARG | 함수 제거, 범위 재작성, 인덱스 설계 |
| Key Lookup 다량 | 커버링 안 됨 | INCLUDE/커버링 인덱스 |
| Hash Join + temp spill | 메모리 부족 | work_mem/메모리그랜트 상향, 조인 순서 수정 |
| Planned vs Actual Rows 큰 오차 | 통계 부정확/상관성 무시 | ANALYZE/히스토그램/확장 통계 |
| Sort 비용 과다 | 정렬 큰 비용 | 인덱스 정렬 활용, Top-N 최적화 |
| Parameter Sniffing 의심 | 값 따라 성능 출렁 | RECOMPILE/UNKNOWN/플랜 강제/쿼리 분기 |

---

## 17. 현업 패턴 모음

### 17.1 Top-N with 인덱스만
```sql
-- 이미 (score DESC, id) 인덱스가 있다면
SELECT id, score
FROM ranking
ORDER BY score DESC, id
FETCH FIRST 100 ROWS ONLY;  -- Oracle/PG(標準)
```

### 17.2 페이징 성능(OFFSET 피로)
```sql
-- Before: OFFSET 크면 스캔 낭비
SELECT ... ORDER BY id LIMIT 50 OFFSET 100000;

-- After: 시크 기반 키셋 페이징
SELECT ... 
FROM t
WHERE id > :last_seen_id
ORDER BY id
LIMIT 50;
```

---

## 18. 정리

- **옵티마이저의 본질**: 통계를 바탕으로 **가장 싸게** 끝내는 계획을 고르는 것.  
- **성공 공식**: SARGability 확보 → 통계 정확화 → 인덱스/조인 전략 설계 → 검증(Actual Plan/I/O) → 안정화.  
- **힌트는 최후 수단**, 근본 원인은 쿼리/스키마/통계에 있다.  
- **플레이북/체크리스트**를 팀 규약으로 만들고, 실행계획을 **테스트의 일부**로 관리하라.

---

## 부록) 빠른 참조 — 엔진별 실행계획 명령

```sql
-- Oracle
EXPLAIN PLAN FOR <SQL>;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(format=>'ALLSTATS LAST'));

-- PostgreSQL
EXPLAIN (ANALYZE, BUFFERS, VERBOSE) <SQL>;

-- MySQL
EXPLAIN FORMAT=JSON <SQL>;
EXPLAIN FORMAT=TREE <SQL>;

-- SQL Server
SET STATISTICS IO, TIME ON; -- I/O/시간
-- SSMS에서 Actual Execution Plan 버튼
```