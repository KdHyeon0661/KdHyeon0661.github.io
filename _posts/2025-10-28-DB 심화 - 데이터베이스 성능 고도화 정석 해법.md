---
layout: post
title: DB 심화 - 데이터베이스 성능 고도화 정석 해법
date: 2025-10-28 14:25:23 +0900
category: DB 심화
---

# 데이터베이스 성능 고도화 **정석 해법**

> 목표  
> - “**느리다**”를 **수치**로 정의하고, **라벨(대기 이벤트)** → **좌표(실행계획 라인)** 로 추적해 **최소 변경**으로 고친다.  
> - **정석 순서**(워크로드 파악→카디널리티 정확화→접근경로 최적화→정렬/해시 회피→동시성/락 제어→I/O·메모리→플랜 안정화→배포/회귀 방지)를 제공한다.  
> - 모든 섹션에 **Oracle 중심**의 **운영 SQL/DDL/PLSQL** 예제와 **현장 시나리오**를 포함한다.

---

## 0. 성능 철학(3줄 요약)
1) **응답시간 분해**:  
   $$T_{\text{elapsed}} = T_{\text{CPU}} + \sum_k T_{\text{wait},k}$$  
   → **Top Wait**와 **Top SQL**을 찾고, 해당 SQL의 **Plan 라인**에서 시간을 줄여라.
2) **작은 변경** 먼저: 인덱스 하나, 통계 한 줄, 조인순서, 힌트/프로파일/플랜베이스라인 등 **저위험 수정**으로 시작.  
3) **증명**: 변경 전/후 **같은 구간·입력**으로 **AWR Diff/ASH**와 **p95**로 효과를 수치화.

---

## 1. 측정과 원인분해: **이름표 → 좌표**
### 1.1 Top Wait / Top SQL / 라인
```sql
-- 최근 15분 Top Wait/Event
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '15' MINUTE; EXEC :t2 := SYSTIMESTAMP;

SELECT wait_class, event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2 AND session_type='FOREGROUND'
GROUP  BY wait_class, event
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;

-- Top SQL (ASH)
SELECT sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2 AND session_type='FOREGROUND'
GROUP  BY sql_id
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;
```
```sql
-- 해당 SQL의 실제 실행계획(라인 통계)
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR('&&SQL_ID', NULL,
    'ALLSTATS LAST +PREDICATE +PROJECTION +PEEKED_BINDS +OUTLINE +NOTE'));
```
**원칙**: 대기 이벤트는 **증상 이름표**, 실행계획 라인은 **원인 좌표**.

### 1.2 성능 예산(필수 감각)
- `/api/report` p95 **800ms** 목표: 게이트웨이 100ms, 서비스 300ms, **DB 250ms**, 외부 100ms, 버퍼 50ms.  
- DB 250ms 예산을 **쿼리별/라인별**로 나누어 본다.

---

## 2. 카디널리티 정확화: **옵티마이저가 믿을 숫자 만들기**
> 80%의 성능문제는 **잘못된 선택도(카디널리티)** 가 뿌리. “**사실**을 알려주면 플랜은 따라온다.”

### 2.1 통계 최신화 + 히스토그램
```sql
-- 테이블/인덱스 통계 + 스큐 컬럼 히스토그램
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',cascade=>TRUE,
     method_opt=>'FOR COLUMNS SIZE 75 region size skewonly order_date');
```
- **스큐 컬럼**(지역/상태/카테고리)엔 **도수분포**가 필요.
- 바인드일 때 **ACS(Adaptive Cursor Sharing)** 가 플랜 구간을 분기하도록 돕는다.

### 2.2 표현식/함수 제거로 카드 왜곡 방지
```sql
-- 나쁜 예: 함수로 컬럼을 감싸 인덱스/통계 무력화
WHERE TRUNC(order_date) = DATE '2025-10-01'

-- 좋은 예: 범위로 전개(함수 제거)
WHERE order_date >= DATE '2025-10-01' AND order_date < DATE '2025-10-02'
```

### 2.3 바인드 피킹/ACS 확인
```sql
SELECT sql_id, child_number, is_bind_sensitive, is_bind_aware
FROM   v$sql
WHERE  sql_id='&&SQL_ID';
```
- **스큐 심함 + 바인드** → 히스토그램 + ACS로 **범위별 Child**를 확보.
- **Child 폭증**은 `V$SQL_SHARED_CURSOR`에서 이유 확인(리터럴/환경 불일치).

---

## 3. 접근 경로 최적화: **커버링·프루닝·조인순서**
### 3.1 커버링 인덱스(정렬/ROWID 점프 제거)
```sql
-- 보고서에 자주 쓰는 쿼리
SELECT region, order_date, SUM(amount) amt
FROM   orders
WHERE  region='APAC' AND order_date BETWEEN :d1 AND :d2
GROUP  BY region, order_date
ORDER  BY region, order_date;

-- 커버링 인덱스(필터+그룹+정렬 컬럼 포함)
CREATE INDEX ix_orders_r_dt_amt ON orders(region, order_date, amount);
```
- `ORDER BY`와 같은 정렬열이 **인덱스 순서**와 맞으면 `SORT` 제거 가능.
- 집계는 경우에 따라 **인덱스 스킵 스캔/그룹 순회**로 가벼워짐.

### 3.2 파티션 프루닝(대량에서 소량으로)
```sql
-- 범위-해시 복합 파티셔닝(월별 + 고객 해시)
CREATE TABLE orders_p
PARTITION BY RANGE(order_date) SUBPARTITION BY HASH(customer_id)
SUBPARTITIONS 8 (
  PARTITION p2025_10 VALUES LESS THAN (DATE '2025-11-01'),
  PARTITION p2025_11 VALUES LESS THAN (DATE '2025-12-01')
);

-- 쿼리가 "월 + 고객 일부"면 파티션 + 서브파티션 프루닝
```
- 프루닝이 되면 **I/O량이 질적으로 감소**. 실행계획에 `PARTITION RANGE`가 보이는지 확인.

### 3.3 조인 순서/방식(드라이빙은 소량 먼저)
```sql
-- 통계가 맞으면 옵티마이저가 대체로 올바른 조인순서를 선택한다.
-- 필요시 힌트로 보정
SELECT /*+ LEADING(c o) USE_NL(o) INDEX(o ix_orders_cust_date) */
       c.region, SUM(o.amount)
FROM   customers c JOIN orders o ON o.customer_id=c.id
WHERE  c.region=:r AND o.order_date BETWEEN :d1 AND :d2
GROUP  BY c.region;
```
- **NL**: 드라이빙(소량) → 인덱스 접근. 랜덤 I/O 패턴, 소량에 강함.  
- **HASH**: 대량/병렬에 강함. 메모리 모자라면 **TEMP 스필**(`direct path read temp`) 발생.

---

## 4. 정렬/해시 **스필** 제거(Temp I/O 제로화)
### 4.1 증상과 진단
- 대기: `direct path read temp` / `write temp`  
- Plan 라인: `SORT GROUP BY / ORDER BY`, `HASH JOIN/AGGREGATE`의 **TempSpc/Time↑**  
```sql
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR('&&SQL_ID', NULL,
    'ALLSTATS LAST +PROJECTION +NOTE')); -- TempSpc 큰 라인 찾기
```
### 4.2 해법
1) **카디널리티 정확화**(히스토그램/필터 푸시)로 입력량 축소  
2) **정렬 회피 인덱스**/선행 집계/물질화 뷰  
3) **PGA↑** & workarea 정책 점검  
4) 해시→NL 전환(소량 먼저)

---

## 5. 동시성·락: **TX/FK/핫블록** 정석
### 5.1 TX Row Lock: **FK 인덱스는 의무**
```sql
-- FK 미인덱스 탐지
SELECT a.table_name, a.constraint_name
FROM   user_constraints a
WHERE  a.constraint_type='R'
  AND NOT EXISTS (
    SELECT 1 FROM user_ind_columns i
    WHERE  i.table_name=a.table_name
      AND  (i.column_name) IN (
            SELECT column_name FROM user_cons_columns WHERE constraint_name=a.constraint_name)
  );
```
- 부모 갱신/삭제시 자식 풀스캔 + **TX 락 확산**. **FK 인덱스**로 즉시 해소.

### 5.2 핫블록/버퍼 경합: **키 분산**
- 증가키 집중(시퀀스 ORDER, 우측성장 인덱스) → `buffer busy waits/read by other session`  
**해법**: `REVERSE` 키, `NOORDER CACHE` 시퀀스, 해시·샤딩키, 파티션 분산, `INITRANS` ↑.

### 5.3 커밋 지연: `log file sync`
- 매 행 커밋/네트워크 RTT/로그 디스크 지연.  
**해법**: **배치 커밋**, 로그 경로 성능 개선.

---

## 6. 읽기 일관성·블록 클린아웃 **이해하고 튜닝**
- **Consistent Read**: UNDO로 읽기시점 복원 → `consistent gets` 증가.  
- **Delayed Cleanout**: COMMIT 후에도 블록 ITL 정리가 지연 → 다음 접근 때 추가 지연 가능.  
**해법**: 긴 트랜잭션 자제, **커밋 패턴 개선**, HOT 블록 회피.

---

## 7. 메모리·캐시: **Shared Pool / Buffer Cache / PGA**
### 7.1 Shared Pool(파싱/커서 재사용)
- **바인드 변수** 사용 → 리터럴 폭증 방지.  
- `session_cached_cursors` 적절히.  
- `library cache lock/pin` ↑ 시 하드파싱/DDL 빈도 점검.

### 7.2 Buffer Cache
- BCHR(버퍼 캐시 히트율)만 보지 말고 **대기 이벤트/Plan**으로 판단.  
- 랜덤 I/O 과다면 **커버링 인덱스/클러스터링 팩터** 개선이 우선.

### 7.3 PGA(정렬/해시 작업 메모리)
```sql
SELECT name, round(value/1024/1024) MB FROM v$pgastat WHERE name IN ('total PGA allocated','total PGA inuse');
```
- Temp 스필 보이면 **PGA 증설** + 쿼리 구조개선(§4).

---

## 8. 저장소·I/O 배치: **데이터/로그/Temp 분리**
- **데이터**와 **로그**, **Temp**를 물리/스토리지 정책 분리.  
- 잦은 랜덤 I/O 인덱스/테이블은 속도 좋은 그룹에.  
- IOPS/대역·지연(P99) 모니터링.

---

## 9. 플랜 안정화: **SQL Plan Baseline / Profile / Outline**
### 9.1 Baseline으로 “좋을 때” 고정
```sql
-- 좋은 실행 시점에서 베이스라인 캡쳐
BEGIN
  DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE(sql_id => '&&SQL_ID');
END;
/
-- Baseline 확인/고정
SELECT sql_handle, plan_name, enabled, accepted FROM dba_sql_plan_baselines;
```
- 통계 변경/환경 변화에도 **좋은 플랜 유지**.

### 9.2 SQL Profile(카디널리티 힌트)
- 옵티마이저 내부 카디널리티 보정치 제공(자동 Tuning Pack)  
- 대안: **힌트**로 명시(`LEADING/USE_NL/INDEX/NO_MERGE` 등) + 코드 관리.

---

## 10. 쿼리 재작성·물질화 뷰·결과 캐싱
### 10.1 재작성 패턴
- **N+1 제거**: 조인으로 합치거나 IN 절 한 번.  
- **사전 집계**: 일별/월별 요약 테이블, **물질화 뷰** 리프레시.
```sql
CREATE MATERIALIZED VIEW mv_daily_sales
BUILD IMMEDIATE REFRESH FAST ON COMMIT
AS
SELECT trunc(order_date) d, region, SUM(amount) amt
FROM   orders
GROUP  BY trunc(order_date), region;
```
- 보고서는 MV 또는 요약 인덱스로 즉시 응답.

---

## 11. 배치/대용량 DML 정석
- **인덱스/트리거 최소화** 후 일괄 로드 → 나중에 인덱스 재생성.  
- `APPEND` 힌트/`NOLOGGING`(업무 허용시)로 로깅 축소.  
- 커밋 주기 **적절히**(너무 촘촘하면 `log file sync` 폭증).

---
## 12. RAC/Scale-Out 전략
- **서비스 로컬리티**: 파티션/데이터와 서비스 매핑(인터커넥트 `gc*` 대기 감소).  
- 증가키/특정 파티션 핫 → 분산/재파티셔닝/NOORDER/Reverse 키.

---

## 13. 운영 자동화: **탑다운 리포트 묶음**
### 13.1 15분 핫스팟(Wait/Event/SQL)
```sql
-- Wait/Event
SELECT wait_class, event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '15' MINUTE
  AND  session_type='FOREGROUND'
GROUP  BY wait_class, event
ORDER  BY samples DESC FETCH FIRST 12 ROWS;

-- Top SQL (V$SQL, 누적 지표)
SELECT sql_id, ROUND(elapsed_time/1e6,1) elapsed_s, executions,
       ROUND(elapsed_time/1e6/NULLIF(executions,0),3) s_per_exec,
       plan_hash_value, last_active_time
FROM   v$sql
ORDER  BY elapsed_time DESC FETCH FIRST 20 ROWS;
```

### 13.2 Temp/정렬 히트
```sql
SELECT tablespace_name, SUM(blocks) blocks
FROM   v$sort_usage
GROUP  BY tablespace_name
ORDER  BY blocks DESC;
```

### 13.3 세그먼트 핫스팟(논리/물리/버퍼 경합)
```sql
-- AWR 세그먼트 통계가 가장 정확하지만, 라이브는 다음과 같이 보조
SELECT owner, object_name, object_type, value logical_reads
FROM   v$segment_statistics
WHERE  statistic_name='logical reads'
ORDER  BY value DESC FETCH FIRST 20 ROWS;
```

---

## 14. 시나리오별 **정석 해법**

### 14.1 “보고서가 느리다” — Temp 스필 1위
- **증상**: `direct path read temp` Top, `SORT GROUP BY` 라인 TempSpc↑  
- **원인**: 카드 오판, 정렬/해시 입력 과다  
- **해법**: 히스토그램, 정렬 회피 인덱스, PGA↑, 해시→NL  
- **검증**: `awrdiff.sql`로 Temp I/O/Elapsed 감소 확인

### 14.2 “OLTP가 자꾸 멈춘다” — TX 락
- **증상**: `enq: TX - row lock contention`  
- **원인**: FK 미인덱스, 긴 트랜잭션, 업데이트 순서 충돌  
- **해법**: FK 인덱스, 단위작업 축소/커밋 주기, 순서 정책  
- **검증**: ASH에서 TX 샘플 급감

### 14.3 “배치 커밋 때만 느림” — log file sync
- **해법**: 배치 커밋(묶기), 로그 장치 성능/RTT, 대량 DML 전략 전환

### 14.4 “RAC에서 특정 노드만 느림” — GC 경합
- **증상**: `gc current/cr block busy`  
- **해법**: 서비스 로컬리티, 파티션 분산, 키 분산(Reverse/NOORDER)

---

## 15. 체크리스트(암기 카드)
1) **Top Wait → Top SQL → Plan 라인**(ALLSTATS LAST)  
2) **카디널리티**: 통계/히스토그램/함수 제거/바인드 스큐  
3) **접근경로**: 커버링 인덱스/프루닝/조인순서·방식  
4) **정렬/해시 스필 제로**: 정렬 회피 + PGA 정책  
5) **동시성**: FK 인덱스/키 분산/INITRANS/커밋 정책  
6) **플랜 안정화**: Baseline/Profile/힌트  
7) **저위험부터**: 인덱스 추가/통계 보정/힌트/뷰 재작성  
8) **증명**: AWR Diff + p95 응답 + ASH 타임라인  
9) **회귀 방지**: CI 성능 게이트 + 카나리 + 자동 롤백

---

## 16. 미니 실습(끝까지 따라하기)

### 16.1 문제 재현 & 관측
1) 피크 30분 **AWR 리포트** 생성 → `direct path read temp` 1위  
2) **ASH**로 Top SQL & `sql_plan_line_id` 집중 라인 확인  
3) **XPLAN**으로 `SORT GROUP BY` 라인 `TempSpc/Time` 확인

### 16.2 최소 변경
```sql
-- 스큐 컬럼 히스토그램
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'ORDERS',
     method_opt=>'FOR COLUMNS SIZE 75 region size 75 order_date');

-- 정렬 회피 커버링 인덱스
CREATE INDEX ix_orders_r_dt_amt ON orders(region, order_date, amount);
```

### 16.3 재검증(동일 구간)
- **AWR Diff**: DB Time↓, Temp I/O↓  
- **ASH**: temp 이벤트 샘플↓, 다른 대기 지배 없음  
- **서비스 p95**: 8.2s → 1.1s

---

## 17. 부록 — 자주 쓰는 힌트/옵션 요약
- `LEADING(a b)` / `USE_NL(b)` / `USE_HASH(b)` / `INDEX(t idx)` / `FULL(t)`  
- `NO_MERGE(subq)` / `PUSH_PRED(subq)` / `RESULT_CACHE`(조건부)  
- `APPEND`(대량 Insert) / `PARALLEL(t N)`(TEMP/로깅 주의)

---

## 18. 마무리
“고도화”는 마법이 아니다.  
**(1) 관측(Top Wait/Top SQL) → (2) 라인 원인분해 → (3) 최소 변경 → (4) 전/후 수치 증명**을  
**습관**으로 만들면, 성능은 “운”이 아니라 “공정”이 된다.  
**카디널리티 정확화**와 **접근경로 최적화**가 1순위, **동시성/Temp/I/O/플랜 안정화**가 그 다음이다.

> 한 줄 정리  
> **정석 해법 = “이름표(대기)”에서 출발해 “좌표(라인)”에 도착하여, 가장 작은 변경으로 성능 예산을 지키는 것.**  
> 증명하고, 자동화로 굳히면, 성능은 반복가능한 공예가 된다.