---
layout: post
title: 운영체제 - 부록
date: 2025-11-05 19:25:23 +0900
category: 운영체제
---
# Appendices — Deep Dive & Hands-On

## Appendix A — Influential Operating Systems

### A.1 왜 “영향력 있는” OS인가

운영체제의 큰 진화는 **자원 격리/공유**, **추상화(파일·프로세스·IPC)**, **보안 모델**, **프로그래밍 인터페이스**에서 일어난다. 아래 시스템들은 “처음 도입했거나 널리 보급한 아이디어”로 이후 OS에 장기적인 지분을 남겼다.

---

### A.2 타임셰어링과 계층화의 태동: CTSS → Multics

- **CTSS(1960s)**: 다중 사용자 타임셰어링.
- **Multics**: **계층적 파일 시스템**, **세그먼트/페이지** 결합 메모리, **ring-based 보호(링 0~7)**, **동적 링크**, **시분할의 완성형**.

**핵심 아이디어**
- 보호 링: $$\text{ring}_0 \subset \text{ring}_1 \subset \cdots$$, 특권 전이의 최소화.
- 세그먼트+페이지: 세그먼트는 논리 단위, 페이지는 물리 매핑 단위.

---

### — 간결한 추상화

**단일 인터페이스(모든 것을 파일처럼)**, **fork/exec**, **파이프**, **쉘**.

#### 예제: 파이프라인 직접 구현(Unix/POSIX, C)

```c
// pipe_ls_wc.c : ls | wc -l (Linux/macOS/BSD)
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>

int main(){
    int p[2]; pipe(p);
    if(fork()==0){ // child1: producer (ls)
        dup2(p[1], 1); close(p[0]); close(p[1]);
        execlp("ls", "ls", (char*)NULL);
        perror("execlp");
    }
    if(fork()==0){ // child2: consumer (wc -l)
        dup2(p[0], 0); close(p[1]); close(p[0]);
        execlp("wc", "wc", "-l", (char*)NULL);
        perror("execlp");
    }
    close(p[0]); close(p[1]);
    wait(NULL); wait(NULL);
}
```

**영향력**:
- **프로세스 모델(fork/exec/wait)**, **파일 서술자**, **파이프**는 이후 모든 유닉스, 리눅스, BSD, macOS의 기본.

---

### — 네트워크의 표준화

- **소켓 API**(TCP/IP) 정립.
- **FFS(UFS)**: 실린더 그룹/로컬리티, 큰 블록/프래그먼트.
- **가상 메모리**(BSD + Mach 통합으로 고도화).
- **kqueue/kevent**(후대 FreeBSD, macOS).

#### 예제: BSD 스타일 TCP 에코(모든 POSIX 호환)

```c
// bsd_echo.c : 단순 TCP 에코 서버
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

int main(){
    int s=socket(AF_INET,SOCK_STREAM,0);
    int on=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));
    struct sockaddr_in a={.sin_family=AF_INET,.sin_port=htons(9000),.sin_addr={INADDR_ANY}};
    bind(s,(void*)&a,sizeof(a)); listen(s,128);
    for(;;){
        int c=accept(s,NULL,NULL);
        char buf[4096]; ssize_t n;
        while((n=read(c,buf,sizeof(buf)))>0) write(c,buf,n);
        close(c);
    }
}
```

---

### A.5 System V — 상용 유닉스의 교점

- **IPC(메시지 큐/세마포어/공유 메모리)**, **init 스크립트**, **STREAMS**.
- BSD와 함께 **POSIX 표준화의 두 축**.

---

### A.6 VMS → Windows NT — 객체·보안·I/O

- NT 커널은 **객체(핸들) 기반**, **I/O 매니저/IRP**, **보안 참조 모니터**를 계승.
- **하이브리드 커널** 설계, **HAL** 로 이식성 확보.

#### 예제: Windows에서 Job Object로 격리

```cpp
// nt_job_isolation.cpp (Windows)
#include <windows.h>

int main(){
  HANDLE j=CreateJobObjectW(NULL,L"Demo");
  JOBOBJECT_BASIC_LIMIT_INFORMATION li={0};
  li.LimitFlags=JOB_OBJECT_LIMIT_ACTIVE_PROCESS; li.ActiveProcessLimit=2;
  SetInformationJobObject(j,JobObjectBasicLimitInformation,&li,sizeof(li));
  // 이후 CreateProcess → AssignProcessToJobObject
}
```

---

### A.7 Plan 9 — “모든 것을 파일/네임스페이스”의 확장

- **9P 프로토콜**, **개인 네임스페이스**(프로세스별 바인드/리마운트), **acme**.
- 컨테이너/마운트 네임스페이스 사상의 선구.

---

### A.8 QNX/Integrity — 마이크로커널의 실전

- **QNX Neutrino**: **동기 메시지 전달(send/recv/reply)** 이 커널 원시.
- **고신뢰/RT** 차량·산업 제어에 적합.

#### 예제: QNX 메시징 패턴(개념 의사코드)

```c
int chid = ChannelCreate(0);
int rcvid = MsgReceive(chid, &msg, sizeof(msg), NULL);
MsgReply(rcvid, EOK, &reply, sizeof(reply));
```

---

### A.9 Minix → Linux, 그리고 오픈소스 폭발

- **Minix**: 교육용 미니 유닉스.
- **Linux**: 모놀리식+모듈형, GNU 유틸리티와 결합해 **GNU/Linux** 생태계를 형성.
- **영향**: Git, 패키지, 커널 드라이버 모델, 네임스페이스/CGroups(컨테이너).

---

### A.10 BeOS, macOS(XNU), Android/iOS

- **BeOS**: 멀티미디어/스케줄링, BFS.
- **macOS**: XNU( Mach + BSD + IOKit ), **launchd**, **Sandbox**.
- **Android**: 리눅스 커널 + Binder IPC + HAL + ART, 권한 모델/SELinux.
- **iOS**: Darwin(XNU) + 코드 서명 강제 + 앱 샌드박스.

---

### A.11 모델 총정리 수식(간단)

- **Little’s Law(대기/스케줄링 직관)**:
  $$L = \lambda \cdot W$$
  평균 시스템 내 작업 수 = 도착률 × 평균 체류시간.
  → OS 설계에서 **큐 길이/컨텍스트 스위치/오프로딩**의 균형 핵심.

---

## Appendix B — Windows 7

### B.1 개요(2009 출시)

- **목표**: Vista의 호환성/체감 성능 이슈 개선, **UI 일관**, **전력/배터리 최적화**.
- **커널/그래픽**: **WDDM 1.1**(시스템/비디오 메모리 중복 감소), **DWM 개선**.
- **보안·관리**: **UAC 경험 개선**, **BitLocker To Go(이동식)**, **AppLocker**, **DirectAccess**, **BranchCache**, **SMB 2.1**.

### B.2 핵심 구성 차이

- **세션 0 격리**(Vista 도입, Win7 지속): 서비스-대화형 분리 강화.
- **I/O 성능**: 저장장치 큐/캐시 개선, 백그라운드 유지보수 스케줄링.
- **전력**: 장치 전원 상태 전이/타이머 공용화로 **idle 합치기**.

### B.3 AppLocker(Enterprise/Ultimate)

```powershell
# 후 경로 허용 규칙 추가

New-AppLockerPolicy -DefaultRule -RuleType Publisher,Path,Hash |
  Set-AppLockerPolicy -XMLPolicy -Merge
# 권장 → 이벤트 확인 후 적용

```

### B.4 DirectAccess/BranchCache(서버 2008 R2 연계)

- **DirectAccess**: IPv6/IPsec 기반 “항상 연결” 원격 액세스.
- **BranchCache**: 원격 사무소 캐시(호스트/분산 모드).

### B.5 개발자 포인트

- **UAC**: 관리자 권한이 필요 없도록 설계(ProgramData/LocalAppData 사용).
- **매니페스트**: DPI-Aware, 권한 선언.
```xml
<!-- app.manifest (부분) -->
<requestedExecutionLevel level="asInvoker" uiAccess="false" />
<asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
  <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
    <dpiAware>true</dpiAware>
  </asmv3:windowsSettings>
</asmv3:application>
```

### B.6 PowerShell 2.0 & ETW

```powershell
Get-WinEvent -ListProvider * | Where-Object { $_.Name -like "*Kernel*" } |
  Select-Object Name | Sort-Object Name
```

---

## Appendix C — BSD UNIX (FreeBSD / OpenBSD / NetBSD)

### C.1 역사·분화

- **CSRG(캘리포니아 버클리)** 의 4BSD 라인 → **4.2BSD(소켓/FFS)**, **4.3BSD**.
- 소송 이후 **FreeBSD/NetBSD/OpenBSD** 로 분화.
- **FreeBSD**: 서버/스토리지, **ZFS**, **jail**, **DTrace(포팅)**, **Capsicum**.
- **OpenBSD**: 보안 기본값, **pf** 방화벽, **pledge/unveil**.
- **NetBSD**: 이식성(“Of course it runs NetBSD.”).

### C.2 파일 시스템

- **UFS2 + Soft Updates/Journal**(FreeBSD), **ZFS**(일부 기본).
- **GEOM** 프레임워크(미러/암호화/파티셔닝).

### C.3 프로세스/이벤트: kqueue/kevent

```c
// kq_tail.c : 여러 fd 이벤트를 kqueue로 감시(FreeBSD/macOS)
#include <sys/event.h>
#include <sys/time.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(){
    int kq = kqueue();
    int fd = open("data.log", O_RDONLY);
    struct kevent ev;
    EV_SET(&ev, fd, EVFILT_VNODE, EV_ADD|EV_ENABLE|EV_CLEAR, NOTE_WRITE, 0, 0);
    kevent(kq, &ev, 1, NULL, 0, NULL);
    for(;;){
        struct kevent out;
        int n = kevent(kq, NULL, 0, &out, 1, NULL);
        if(n>0 && out.filter==EVFILT_VNODE && (out.fflags & NOTE_WRITE))
            puts("file changed");
    }
}
```

### C.4 FreeBSD Jail — 경량 격리

**개념**: 한 커널 안에서 파일·네트워크·호스트네임 등을 **감금**(격리).
**설정 예** (`/etc/jail.conf`):
```conf
web {
  host.hostname = web.example;
  path = /jails/web;
  mount.devfs;
  ip4.addr = 10.0.0.10;
  exec.start = "/bin/sh /etc/rc";
  exec.stop  = "/bin/sh /etc/rc.shutdown";
}
```
실행:
```sh
service jail start web
jls       # jail 목록
jexec 1 sh
```

### — 권한 축소

```c
// cap_echo.c : 소켓 오픈 후 권한 축소
#include <sys/capsicum.h>
#include <capsicum_helpers.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

int main(){
  int s=socket(AF_INET,SOCK_STREAM,0);
  struct sockaddr_in a={.sin_family=AF_INET,.sin_port=htons(9000),.sin_addr={INADDR_ANY}};
  bind(s,(void*)&a,sizeof(a)); listen(s,128);
  cap_enter();                    // 여기부터 capability 모드(글로벌 네임스페이스 차단)
  cap_rights_t r; cap_rights_init(&r, CAP_ACCEPT, CAP_EVENT);
  cap_rights_limit(s, &r);
  for(;;){ int c=accept(s,0,0); write(c,"ok\n",3); close(c); }
}
```

### — 기본 보안

`/etc/pf.conf` 예:
```pf
set block-policy return
set skip on lo
block in all
pass out all keep state
pass in on egress proto tcp to port { 22, 80, 443 } flags S/SA keep state
```
적용:
```sh
pfctl -f /etc/pf.conf
pfctl -sr
```

### C.7 패키지·서비스

- **FreeBSD**: `pkg install nginx`, rc 스크립트 `/etc/rc.conf`.
- **OpenBSD**: `doas pkg_add`, `rcctl enable/disable`.

---

## Appendix D — The Mach System

### D.1 배경과 목표

- **CMU Mach(1980s)**: **마이크로커널** 연구 — **태스크/스레드**, **포트/메시지 기반 IPC**, **메모리 객체/외부 페이저**, **디바이스 독립성**.
- Mach 2.x(유닉스 서버 커널과 결합), Mach 3.0(순수 마이크로커널 + 사용자 공간 서버).
- 현대 macOS의 **XNU**는 **Mach(MK)** + **BSD** + **IOKit** 하이브리드.

### D.2 핵심 개념

- **Task**: 주소 공간 + 포트 네임스페이스.
- **Thread**: 실행 단위(한 task에 여러 개).
- **Port**: **권한(capability) 토큰** + 메시지 큐.
- **mach_msg()**: **송신/수신** 원시.
- **Memory Object/External Pager**: 페이지 폴트 처리 인터페이스를 사용자 공간에도 노출.

**성능 직관**
- 마이크로커널은 IPC 빈도가 높은 경로에서 오버헤드가 커질 수 있어 **co-location(서버 커널 내)**, **빠른 경로**, **공유 메모리** 등을 병용한다.

---

### D.3 mach_msg 기본 예제(macOS)

```c
// mach_ping.c : 같은 프로세스 내 간단 송수신(데모용)
#include <mach/mach.h>
#include <stdio.h>

int main(){
    mach_port_t self = mach_task_self();
    mach_port_t recv_port, send_port;

    mach_port_allocate(self, MACH_PORT_RIGHT_RECEIVE, &recv_port);
    mach_port_insert_right(self, recv_port, recv_port, MACH_MSG_TYPE_MAKE_SEND);
    send_port = recv_port; // 데모: 동일 포트로 send/recv

    struct {
      mach_msg_header_t head;
      char payload[16];
    } msg = {0}, rpl = {0};

    msg.head.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);
    msg.head.msgh_size = sizeof(msg);
    msg.head.msgh_remote_port = send_port;
    msg.head.msgh_local_port  = MACH_PORT_NULL;
    snprintf(msg.payload, sizeof(msg.payload), "hello");

    mach_msg(&msg.head, MACH_SEND_MSG, msg.head.msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);

    rpl.head.msgh_local_port = recv_port;
    mach_msg(&rpl.head, MACH_RCV_MSG, 0, sizeof(rpl), recv_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    printf("got: %s\n", rpl.payload);
}
```
> 실제 서비스는 **MIG(Mach Interface Generator)** 로 IDL을 정의하고 스텁을 생성해 사용.

---

### D.4 MIG(개념 흐름)

1) **IDL** 파일에서 RPC 인터페이스 정의
2) `mig` → 클라이언트/서버 스텁 생성
3) 서버: 수신 루프에서 스텁 호출 → 구현 함수 실행
4) 클라이언트: 스텁 호출 → `mach_msg` 송신 → 응답 수신

#### MIG IDL 스니펫(개념)

```c
/* ping.defs */
subsystem ping 1000;
serverprefix ping_;
routine ping_echo(
    in  string_t s,
    out string_t r);
```
생성물: `pingUser.c`(클라), `pingServer.c`(서버). 서버는 `ping_echo()`를 구현.

---

### D.5 메모리 객체/외부 페이저(개념도)

- 프로세스가 매핑한 주소에 페이지 폴트 발생 → 커널은 **memory object** 에게 **페이지 공급** 요청 → 외부 페이저(사용자 공간 서버)가 데이터를 제공/쓰기 반영.
- **의의**: 파일 시스템/VM 정책의 사용자 공간 실험이 가능.

---

### D.6 스케줄링/스레드 정책

- 우선순위, **타임셰어/RT**, 정책을 **스레드** 단위로 부여.
- macOS는 상위 수준에서 **QoS 클래스**로 매핑.

---

### D.7 XNU: Mach + BSD + IOKit

- **Mach**: task/thread/IPC/VM.
- **BSD**: 파일시스템, 소켓(–> PF_INET), 프로세스/자격증명.
- **IOKit**: C++ 기반 드라이버 프레임워크(매치/라이프사이클).

---

## 종합 시나리오 — “IPC 설계 선택” 비교표

| 목적 | 유닉스 파이프 | BSD 소켓 | Windows ALPC | Mach 포트 | QNX 메시지 |
|---|---|---|---|---|---|
| 경계 | 바이트 스트림 | 스트림/데이터그램 | 메시지 | 메시지 | 동기 메시지 |
| 권한 | FD 상속 | 바인드/권한 | 포트 권한 | 포트 권한 | 채널 ID |
| 복사 | 1회 | 커널 버퍼 | 커널 버퍼/맵 | 커널 버퍼/공유 | 커널 경로 최적화 |
| 장점 | 간단/범용 | 네트워크까지 확장 | 고성능 로컬 IPC | 일관된 capability | RT 시스템에 적합 |
| 사용처 | 간단 필터링 | 서버/클라 | Win 서브시스템 | macOS 서버 | 임베디드/산업 |

---

## 마무리 체크리스트

- **역사/사상**: Multics(보호·세그먼트) → UNIX(간결·파일 추상화) → BSD(네트워크) → NT(객체/보안) → 현대(컨테이너/가상화/샌드박스).
- **Windows 7**: WDDM 1.1, AppLocker, DirectAccess/BranchCache, UAC 개선 — “현업 안정판”.
- **BSD**: kqueue, jail, pf, Capsicum — “간결하지만 강력한 보안/서버 플랫폼”.
- **Mach**: 포트/메시지/외부 페이저 — “마이크로커널 연구의 산”, macOS의 토대.

---

## 부록 — 추가 실습 레시피(짧게)

1) **Linux/FreeBSD**: `strace -f -o trace.log ./bsd_echo` → **fork/exec/accept** 흐름 관찰.
2) **Windows 7+**: `wpr -start GeneralProfile -filemode`, 재현 후 `wpr -stop w7.etl` → WPA로 I/O 큐/CPU 분석.
3) **OpenBSD pf**: 테스트 VM에서 `pfctl -e` 후 `pfctl -f /etc/pf.conf` → 외부에서 포트 스캔.
4) **macOS Mach**: `otool -hv mybin`(Mach-O 헤더), `dtrace -n 'syscall:::entry{ @num[probefunc] = count(); }'`(권한 필요).
