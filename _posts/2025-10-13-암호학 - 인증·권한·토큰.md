---
layout: post
title: 암호학 - 인증·권한·토큰
date: 2025-10-13 19:30:23 +0900
category: 암호학
---
# 11. 인증·권한·토큰

> 이 장은 **계정 인증(비밀번호·2FA/MFA·WebAuthn)** → **권한 부여(OAuth 2.1 / OIDC)** → **토큰 설계와 운용(JWT/opaque, 보관·회수)** 를 **실무 중심**으로 정리합니다.
> 각 섹션에 **공격 표면·안전 기본값·코드 예제**(Python/Node 개념 코드)를 넣었습니다.
> 원칙: **자작 보안 금지** + **표준/검증 라이브러리 사용** + **로그/비밀/쿠키 정책**.

---

## ✅ 11.1 비밀번호 보안: 솔팅, Argon2 파라미터 프로파일

### 11.1.1 핵심 규칙
- **솔트(salt)**: 계정마다 **랜덤 ≥16바이트**, **저장**(비밀 아님). 재사용 금지.
- **KDF**: **Argon2id**(권장) 또는 scrypt. PBKDF2는 레거시.
- **Pepper(선택)**: 서버 공통 비밀(환경변수/HSM/KMS). DB 탈취 시 추가 장벽.
- **상수시간 비교**: `hmac.compare_digest` / `crypto.timingSafeEqual`.

### 11.1.2 Argon2 파라미터 프로파일(출발선; 실제 장비에서 측정 후 조정)
| 환경 | 권장 알고리즘 | 파라미터(예) | 목표 |
|---|---|---|---|
| 서버/데스크톱 | Argon2id | `m=128 MiB, t=3, p=코어/2` | 100–250 ms/해시 |
| 모바일 상중급 | Argon2id | `m=32–64 MiB, t=2–3, p=1` | 150–300 ms |
| 임베디드/레거시 | scrypt/Argon2id | scrypt `N=2^15,r=8,p=1` | 장비 한계 내 최댓값 |

> 파라미터는 **버전 관리**하고, 로그인 시 검증이 성공하면 **느슨한 파라미터는 상향**(재해시)하십시오.

### 11.1.3 Python 예제(Argon2id: `argon2-cffi`)
```python
# pip install argon2-cffi
from argon2.low_level import hash_secret, Type, verify_secret
import os, hmac

def hash_password(password: str):
    salt = os.urandom(16)
    h = hash_secret(
        password.encode(),
        salt,
        time_cost=3, memory_cost=128*1024, parallelism=2,
        hash_len=32, type=Type.ID
    )  # 표준 인코딩 문자열로 반환
    return h  # bytes (b"$argon2id$v=19$m=...$...")

def verify_password(stored: bytes, password: str) -> bool:
    try:
        return verify_secret(stored, password.encode(), Type.ID)
    except Exception:
        return False
```

### 11.1.4 Node 예제(`@node-rs/argon2` 또는 `argon2`)
```js
// npm i argon2
const argon2 = require('argon2');

async function hashPassword(pw) {
  return await argon2.hash(pw, {
    type: argon2.argon2id,
    memoryCost: 128*1024, timeCost: 3, parallelism: 2,
    hashLength: 32
  });
}

async function verifyPassword(hash, pw) {
  return await argon2.verify(hash, pw); // 상수시간 비교
}
```

### 11.1.5 저장 포맷 & 마이그레이션
- 문자열 자체에 **파라미터 포함**(Argon2 표준 인코딩).
- 구형 해시(PBKDF2 등) 발견 시 **로그인 성공 순간** 새 포맷으로 재해시/저장.

### 11.1.6 공격 표면 & 방어
- **재사용·약한 비번** → 비번 정책/금지 목록(유출 DB 기반)/**Have I Been Pwned** API 검사(서버 측 k-익명 방식).
- **크리덴셜 스터핑** → **2FA/MFA**, IP/디바이스/ASN·속도 제한, **비정상 시도 알림**.
- **패스워드 리커버리** → 토큰 단기 만료, 단일 사용, 채널 바운딩(메시지·IP), 로깅.

---

## ✅ 11.2 2FA/MFA: TOTP/HOTP, WebAuthn/FIDO2

### 11.2.1 HOTP vs TOTP
- **HOTP**: HMAC(비밀, 카운터). 서버·클라 **카운터 동기화** 필요(재전송·드리프트 관리).
- **TOTP**: HMAC(비밀, floor(time/step)). **시간 기반**, `step=30 s`가 흔함.

**TOTP 생성/검증(Python)**
```python
import hmac, hashlib, base64, struct, time

def totp_generate(secret_b32: str, digits=6, step=30, algo=hashlib.sha1):
    key = base64.b32decode(secret_b32, casefold=True)
    counter = int(time.time() // step)
    msg = struct.pack(">Q", counter)
    h = hmac.new(key, msg, algo).digest()
    # dynamic truncation
    o = h[-1] & 0x0f
    code = (h[o:o+4][0] & 0x7f) << 24 | h[o:o+4][1] << 16 | h[o:o+4][2] << 8 | h[o:o+4][3]
    return str(code % (10**digits)).zfill(digits)

def totp_verify(secret_b32, code, window=1, **kw):
    now = int(time.time() // kw.get('step', 30))
    for w in range(-window, window+1):
        if totp_generate(secret_b32, **kw, step=kw.get('step',30)) == code:
            return True
    return False
```
**운영 팁**
- **시계 동기화**(NTP), 드리프트 허용 `±1` 윈도(60~90s).
- 비밀(시드)는 **서버 측 암호화 저장**(KMS/HSM 권장).
- QR 프로비저닝: `otpauth://totp/Issuer:User?secret=...&issuer=Issuer&algorithm=SHA1&digits=6&period=30`.

### 11.2.2 WebAuthn/FIDO2 (패스키)
- **피싱 저항**, **도메인 바운딩**(RP ID), **사용자 검증**(PIN/생체).
- **크리덴셜 유형**:
  - **플랫폼(패스키)**: OS 계정 동기화(안드/iOS/Win/macOS).
  - **로어빙/보안키**: YubiKey 등.
- **등록(Attestation)**: `navigator.credentials.create` → 퍼블릭키·크리덴셜 ID·옵션의 Attestation Object.
- **인증(Authentication)**: `navigator.credentials.get` → `clientDataJSON` + `authenticatorData` + `signature` 검증.

**서버 검증 체크(요약)**
- `clientDataJSON.type` = `"webauthn.create"`/`"webauthn.get"` 확인.
- `clientDataJSON.challenge` = 서버가 보낸 챌린지.
- `clientDataJSON.origin` = 기대 오리진(스킴+호스트+포트).
- `authenticatorData.rpIdHash` = SHA-256(RP ID).
- 카운터 증가(재사용/리플레이 방지), 서명 검사(공개키).
- **User verification**(UV) 플래그 확인(정책에 따라 요구).

**실무 팁**
- 비밀번호 + WebAuthn(2FA) → 점진적 “패스키 전환” 경로 제공.
- MDM/엔터프라이즈: **Attestation 정책**(AAGUID 화이트리스트)·백업 키·계정 복구 플로우.

---

## ✅ 11.3 OAuth 2.1 & OpenID Connect (OIDC)

### 11.3.1 큰 그림
- **OAuth 2.1**: 자원 접근 권한 부여(액세스 토큰).
- **OIDC**: OAuth 위에 **사용자 인증**(ID 토큰) 계층.
- 실무 권장: **Authorization Code + PKCE**(공개 클라이언트, SPA/모바일 포함),
  백엔드 통합은 **BFF 패턴**(브라우저-백엔드-백엔드).

### 11.3.2 코드 플로우 + PKCE
1) 클라이언트가 **`code_verifier`**(랜덤) 생성 → `code_challenge = BASE64URL(SHA256(verifier))`.
2) 사용자를 **Authorization Endpoint**로 리다이렉트: `response_type=code&code_challenge=...&code_challenge_method=S256&redirect_uri=...&client_id=...&scope=openid profile ...&state=...&nonce=...`
3) 인증 후 **Authorization Code** 발급(브라우저로 `redirect_uri?code=...&state=...`).
4) 서버-서버로 **Token Endpoint**에 `code + code_verifier` 교환 → **Access Token**(+ **ID Token**).
5) **ID Token(JWT)** 검증(iss/aud/nonce/exp).

**중요 파라미터**
- `state`: CSRF 방지(요청-응답 바인딩).
- `nonce`: OIDC ID 토큰 바인딩(재생·섞기 방지).
- `redirect_uri`: **화이트리스트**(정확 일치).

### 11.3.3 SPA 보안(토큰 보관 전략)
- **권장**: SPA → **BFF**(백엔드가 토큰을 보유, 브라우저에는 **HTTPOnly, SameSite 쿠키**로 세션).
- **대안**(직접 토큰 보유): **메모리 보관**(리프레시 토큰 **미발급**), **프레임워크의 Token Manager** 사용, 새로고침 시 `Auth Code + PKCE` 재인증.
- **로컬스토리지/세션스토리지**: XSS에 취약 → **지양**.
- **쿠키**: `HttpOnly; Secure; SameSite=Lax/Strict`, **도메인 스코프 최소화**.

### 11.3.4 리프레시 토큰 전략
- **회전(refresh token rotation)**: 한 번 쓰면 **즉시 새로운 RT** 발급, 이전 RT는 **폐기**.
- **바인딩**: 클라이언트/디바이스/ASN/IP/UA 지표로 **사용자 컨텍스트** 점검 → 이상 탐지/차단.
- **만료**: RT 장기 만료(일~주) + 비활성 만료.
- **토큰 스코프** 최소화, **Audience** 명확화(리소스 서버별).

### 11.3.5 권한(Scopes/Claims)
- **Scope**는 **권한 요청**(예: `read:invoices`).
- **ID Token의 Claims**는 **사용자 속성**(프로필, 이메일, sub 등).
- 민감 정보는 **UserInfo Endpoint**를 통해 서버-서버로 가져오기(토큰 크기/갱신 제어).

### 11.3.6 백엔드(BFF) 개념 예: Node(Express)
```js
import express from 'express';
import fetch from 'node-fetch';
import crypto from 'crypto';

const app = express();

function b64url(buf) { return buf.toString('base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }

app.get('/login', (req,res) => {
  const verifier = b64url(crypto.randomBytes(32));
  const challenge = b64url(crypto.createHash('sha256').update(verifier).digest());
  res.cookie('pkce', verifier, { httpOnly: true, sameSite: 'Lax', secure: true });
  const state = b64url(crypto.randomBytes(16)), nonce = b64url(crypto.randomBytes(16));
  res.cookie('state', state, { httpOnly:true, sameSite:'Lax', secure:true });
  res.cookie('nonce', nonce, { httpOnly:true, sameSite:'Lax', secure:true });
  const url = new URL('https://idp.example.com/authorize');
  url.search = new URLSearchParams({
    response_type: 'code',
    client_id: 'CLIENT_ID',
    redirect_uri: 'https://app.example.com/callback',
    scope: 'openid profile email',
    code_challenge: challenge,
    code_challenge_method: 'S256',
    state, nonce
  }).toString();
  res.redirect(url.toString());
});

app.get('/callback', async (req,res) => {
  const {code, state} = req.query;
  if (state !== req.cookies.state) return res.status(400).send('bad state');
  const verifier = req.cookies.pkce;
  const tokenRes = await fetch('https://idp.example.com/token', {
    method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'},
    body: new URLSearchParams({
      grant_type:'authorization_code', code, redirect_uri:'https://app.example.com/callback',
      client_id:'CLIENT_ID', code_verifier: verifier
    })
  });
  const tok = await tokenRes.json(); // { access_token, id_token, refresh_token? }
  // 여기서 토큰은 서버 세션 저장소(메모리/Redis 등)에 저장하고,
  // 브라우저에는 세션 쿠키만 발급(HTTPOnly)
  // ID 토큰 검증(iss/aud/nonce/exp) 후 사용자 세션 생성
  res.cookie('sid', b64url(crypto.randomBytes(24)), { httpOnly:true, sameSite:'Lax', secure:true });
  res.redirect('/');
});

app.listen(3000);
```

---

## ✅ 11.4 JWT 안전 가이드

### 11.4.1 기본
- JWT = `BASE64URL(header).BASE64URL(payload).BASE64URL(signature)`
- **서명 알고리즘**: 대칭(HMAC) 또는 비대칭(RS/ES/EdDSA). **혼용 금지**(key confusion 방지).

### 11.4.2 핵심 검증 체크리스트
- [ ] **서명 알고리즘 강제**: 기대 알고리즘을 **코드에서 고정**(예: `alg=RS256`만).
- [ ] **키 선택**:
  - HMAC: 서버 비밀.
  - RSA/ECDSA/EdDSA: **JWK 세트**(키 ID `kid`)로 공개키 **고정/캐시**.
  - 원격 JWK URL 사용 시 **고정해시/핀·호스트 화이트리스트**/**캐시 만료**/**타임아웃**.
- [ ] **클레임 검증**: `iss`(발급자), `aud`(대상), `exp`/`nbf`/`iat`(시간), 필요 시 `sub`/`jti`.
- [ ] **시간 여유**(leeway) ±1~2분(서버간 시계 오차).
- [ ] **짧은 만료**(AT: 분~10분, IDT: 5~15분). RT는 서버 보관(BFF) 또는 회전/바인딩.

### 11.4.3 대표 취약점 패턴
1) **`alg=none` 허용**
   - 해결: 라이브러리 옵션으로 **none 비활성** 및 **기대 알고리즘 고정**.
2) **키 혼동(Key Confusion)**
   - 공격자가 공개키를 **HMAC key**로 사용하도록 오용 유도(서명 검증 우회).
   - 해결: **서명 알고리즘과 키 타입을 코드에서 고정**하고, JWK `kty`/`use`/`alg`를 매칭 검증.
3) **`kid` 인젝션**
   - `kid`를 파일 경로/SQL에 삽입해 임의 키를 로드하게 만들기.
   - 해결: `kid`는 **미리 등록된 매핑에서만** 선택. 원격 페치 시 **검증/화이트리스트**.
4) **무제한 만료/JWT 블랙홀**
   - 장기 만료 토큰, 탈취 시 장기간 악용.
   - 해결: **짧은 만료** + **리프레시 토큰 회전/철회** + 고위험 시 온라인 **인트로스펙션**(opaque 토큰).
5) **클레임 미검증**
   - `aud`/`iss` 확인 누락 → 다른 서비스 토큰을 재사용.
   - 해결: **엄격 검증**(정확 일치), 멀티테넌트는 `azp` 등 추가 검증.

### 11.4.4 Python(검증 예: `python-jose`/`pyjwt` 개념)
```python
import jwt, time, requests

def fetch_jwks(url):
    # 반드시 도메인 화이트리스트/캐시/타임아웃 적용
    return requests.get(url, timeout=2).json()

def verify_id_token(id_token, jwks, audience, issuer):
    headers = jwt.get_unverified_header(id_token)
    kid = headers.get('kid')
    jwk = next((k for k in jwks['keys'] if k['kid']==kid), None)
    if not jwk or jwk.get('kty') not in ('RSA','EC','OKP'):
        raise Exception('bad key')

    # 알고리즘 고정(예: RS256)
    return jwt.decode(
        id_token,
        key=jwk, algorithms=['RS256'],
        audience=audience, issuer=issuer,
        options={'require': ['exp','iat','iss','aud']}
    )
```

### 11.4.5 Opaque 토큰 vs JWT
- **JWT(자기 기술형)**: 리소스 서버가 **로컬 검증**(빠름), **회수(revoke) 어려움**(짧은 만료/RT 회전으로 보완).
- **Opaque(불투명)**: 리소스 서버가 **인트로스펙션 엔드포인트**로 **온라인 검증** → **즉시 회수 가능**, 비용↑.
- 혼합 전략: **Access=Opaque**, **ID=JWT** 또는 **단기 JWT + 블랙리스트**.

### 11.4.6 토큰 보관 & 전송
- 브라우저: **BFF 세션 쿠키**(HTTPOnly; SameSite=Lax/Strict; Secure).
- 네이티브 앱: **OS 보안 저장소**(Keychain/Keystore) + 디바이스 바인딩(바이오/하드웨어).
- 서버 간: 환경변수/시크릿 매니저(KMS/HashiCorp Vault), **로그 금지**.

### 11.4.7 회수(Revocation) & 위험 신호
- **Refresh Token Rotation** + 사용 시 **로그/지표**로 위치/디바이스/ASN 탐지 → **세션 강제 종료**.
- **JWT jti** 블랙리스트(고위험 액션, 짧은 TTL).
- **SSO 로그아웃**: **Back-Channel Logout**(OP→RP 통지) 또는 **Front-Channel** 동기화.
- IP/UA 바뀜, 짧은 시간 다중 지역, 실패/성공 패턴 이상 → **MFA 업셀** 또는 리스크 기반 인증.

---

## ✅ 11.5 권한(Authorization) 설계: 스코프·RBAC·ABAC

### 11.5.1 스코프 & 권한 모델
- **스코프**: API 호출 권한 단위(예: `invoices:read`). 세분화하되 **운영 가능한 수**로 제한.
- **RBAC**: 역할(ROLE_ADMIN 등) 기반.
- **ABAC**: 속성 기반(부서/지역/시간/리소스 태그). 정책 엔진(Opa/Rego, Cedar 등) 고려.

### 11.5.2 클레임에 권한 담기
- **최소화**: 토큰에는 **필요 최소 권한만**.
- 권한 변경 반영을 위해 **짧은 만료** 또는 **인트로스펙션**.
- 멀티 테넌트: `tenant_id` 분리, `aud`/`azp`/`resource` 엄격화.

---

## ✅ 11.6 감사·로깅·프라이버시

- **로그**: 실패/성공 이벤트, 토큰 ID(jti)/sub/클라이언트ID, IP/ASN/UA(개인식별 최소화), 민감 데이터 마스킹.
- **프라이버시**: ID Token/프로필 최소화, **동의 화면** 관리, 데이터 보존 기간/삭제.
- **감사**: 권한 상승/민감 스코프 접근, 2FA 상태 변경, 리프레시 토큰 재발급.

---

## ✅ 11.7 실무 체크리스트

- **비밀번호**
  - [ ] Argon2id(측정 후 `m/t/p` 상향), 솔트≥16B, Pepper(선택)
  - [ ] 상수시간 비교, 재해시/마이그레이션

- **MFA**
  - [ ] TOTP: 시계 동기화, 시드 보호, 드리프트 윈도
  - [ ] WebAuthn: RP ID/Origin/UV 검증, 백업·복구 정책

- **OAuth/OIDC**
  - [ ] Code + **PKCE**(모든 공개 클라이언트)
  - [ ] **state/nonce** 사용, `redirect_uri` 화이트리스트
  - [ ] **BFF**(브라우저 토큰 비보유), RT 회전/바인딩
  - [ ] 스코프 최소화, Audience 명확화

- **JWT/토큰**
  - [ ] 기대 **alg 고정**, `alg=none` 금지, `kid` 화이트리스트
  - [ ] `iss/aud/exp/nbf/iat` 검증, 만료 짧게
  - [ ] 토큰 보관: HTTPOnly 쿠키/OS 보안 저장소
  - [ ] 회수 전략: RT 회전, jti 블랙리스트(단기), 인트로스펙션(opaque)

- **운영**
  - [ ] 비밀·토큰 **로그 금지**, 샘플 마스킹
  - [ ] 경계 리스크: IP/ASN/UA/위치 변화 탐지 → MFA 업셀
  - [ ] 키/인증서/클라이언트 시크릿 **회전 자동화**

---

## ✅ 11.8 자주 하는 실수(미스유스)

1) **SPA에서 로컬스토리지에 액세스 토큰 저장** → XSS 탈취. **BFF** 또는 메모리 보관 + 짧은 수명.
2) **`alg` 자동 수용** → `alg=none`/키 혼동. **알고리즘 고정**.
3) **리프레시 토큰 무회전** → 탈취 시 장기 악용. **회전+바인딩**.
4) **무제한 만료 JWT** → 즉시 폐기 불가. **짧은 만료 + 인트로스펙션/블랙리스트**.
5) **TOTP 시드 평문 저장** → 탈취. **암호화(At-Rest)** + 접근 통제.
6) **WebAuthn Origin 불일치 허용** → 피싱. **정확 일치** 검사.
7) **OAuth 리디렉트 오픈 리다이렉터** → 코드 탈취. **정확 매칭** 화이트리스트.

---

## ✅ 11.9 미니 시나리오: 안전한 로그인 플로우(웹)

1) 사용자 ID/비번 제출 → **Argon2id 검증**.
2) 계정에 **MFA(WebAuthn 우선, 대체로 TOTP)** 요구.
3) 성공 시 서버가 **세션 생성**: 토큰은 서버(세션 저장소), 브라우저엔 **HTTPOnly 세션 쿠키**.
4) SPA는 API 호출 시 쿠키 기반 CSRF 방어: **SameSite=Lax** + **CSRF 토큰**(stateful) 또는 **Double Submit Cookie**.
5) 민감 액션/새 환경 감지 시 **Step-up MFA**.
6) 로그아웃: 서버 세션 파기 + RT 철회.
7) 주기적으로 키/비밀 회전, 감사/알림.

---

## ✅ 11.10 연습문제

1) Argon2id 파라미터(`m/t/p`)를 **장비 성능**에 맞춰 결정하는 절차를 쓰고, GPU/ASIC 공격자 모델에서 왜 **메모리 하드**가 중요한지 설명하라.
2) TOTP 검증에서 **드리프트 윈도**를 설정하는 이유와, 보안/사용성 간 트레이드오프를 논하라.
3) OIDC **Authorization Code + PKCE**가 **Implicit Flow** 대비 안전한 이유를 CSRF/코드 탈취 관점에서 설명하라.
4) JWT **키 혼동**(HMAC↔RSA) 공격 시나리오를 서술하고, 서버에서 이를 방지하는 구체적 검증 로직을 제시하라.
5) **BFF 패턴**과 **리프레시 토큰 회전**을 결합했을 때, SPA에서 XSS·토큰 탈취 리스크를 어떻게 낮추는지 설명하라.

---

## ✅ 11.11 요약 카드

- **비밀번호**: Argon2id + 솔트≥16B + (선택) Pepper, 상수시간 비교, 파라미터 상향.
- **MFA**: TOTP/HOTP(시계/시드 관리), **WebAuthn(패스키)** 로 피싱저항·도메인바운딩.
- **OAuth 2.1 / OIDC**: **Code + PKCE** 기본, `state/nonce` 엄격, **BFF**로 토큰 브라우저 비공개.
- **토큰**: JWT는 **alg 고정/클레임 검증/짧은 만료**, 회수는 **RT 회전/인트로스펙션**.
- **운영**: 로깅 최소화, 리스크 신호 기반 Step-up, 키·비밀 회전 자동화.

---

### 부록 A — QR 프로비저닝 URL 포맷(TOTP)
```
otpauth://totp/<ISSUER>:<ACCOUNT>?secret=<BASE32>&issuer=<ISSUER>&algorithm=SHA1&digits=6&period=30
```

### 부록 B — SameSite 요약
- **Strict**: 제3자 컨텍스트 전송 안 함(UX 영향).
- **Lax**: 탑레벨 GET 동반 시 전송(기본).
- **None**: 제3자 전송 허용(**Secure 필수**).
쿠키는 항상 `HttpOnly; Secure`로.

### 부록 C — ID Token 필수 검증 필드
- `iss`(정확 일치), `aud`(클라이언트 ID), `nonce`(요청과 바인딩), `exp/nbf/iat`(시간), `sub`(사용자 식별).
