---
layout: post
title: 형식언어와 오토마타 - 복잡한 작업을 위한 튜링 기계의 조합
date: 2025-07-13 18:20:23 +0900
category: 형식언어와 오토마타
---
# 복잡한 작업을 위한 튜링 기계의 **조합(Combinators for TMs)**

> **핵심 메시지**  
> - 튜링 기계(TM)는 단일 기능보다 **조합**을 통해 실전급 복잡한 계산을 구현한다.  
> - 조합 방식: **직렬(파이프라인)**, **조건 분기**, **반복(루프)**, **서브루틴/콜-리턴**.  
> - 형식적(튜링 수준) 구성과 실용적(UTM/인터프리터) 오케스트레이션을 함께 제시한다.  
> - 예제: 간단한 TM 프로그램과 **파이썬 미니 인터프리터 + 조합기 코드**(교육용) 제공.

---

## 0) 표기 & 기본 원칙

- 표준 단일-테이프 TM  
  \(M=(Q,\Sigma,\Gamma,\delta,q_0,q_{\mathrm{acc}},q_{\mathrm{rej}})\),  
  \(\delta:Q\times\Gamma\to Q\times\Gamma\times\{L,R,S\}\).
- 다중-테이프, 2D TM 등은 **표현력 동일**, **효율/설계 편의**만 달라짐.
- **상태/알파벳 이름 충돌 방지**: 조합 시 각 기계의 상태에 **접두사** 부여(예: `A:q0`, `B:q0`).

---

## 1) 조합자 ①: **직렬(파이프라인) 조합**

### 1.1 형식적 구성 (언어 합성 \(M_2\circ M_1\))
두 TM \(M_1, M_2\)가 있고, 같은 테이프를 공유한다고 하자(출력=다음 입력).
- 상태 집합을 **서로소 복사**: \(Q'=\{1\}\!:\!Q_1 \;\dot\cup\; \{2\}\!:\!Q_2\).
- 시작 상태 \(q'_0=(1\!:\!q^{(1)}_0)\).
- \(M_1\)의 **수용 상태**는 **중간 상태**로 바꿔서 \(M_2\)의 시작으로 **점프**:
  - 모든 기호 \(a\in\Gamma\)에 대해  
    \((1\!:\!q^{(1)}_{\mathrm{acc}},a)\mapsto(2\!:\!q^{(2)}_0, a, S)\).
- 최종 수용/거절은 \(M_2\)의 \(q^{(2)}_{\mathrm{acc}}, q^{(2)}_{\mathrm{rej}}\)로 통일.

> **정확성**: \(M_1\)이 끝나면 곧바로 \(M_2\) 실행.  
> **시간**: \(T_{1\to 2}(n)=T_1(n)+T_2(n')+O(|\Gamma|)\) (브릿지 규칙 상수 오버헤드).

### 1.2 단일-테이프에서의 실용 팁
- **왼쪽 기준점(⊢)** 또는 **끝표식(#)** 를 둬서 두 기계 사이 통제점을 명시.
- 브릿지 상태에서 **헤드 위치 정렬**(필요 시 좌측으로 귀환 후 시작).

### 1.3 예시 시나리오
- \(M_1\): 소문자→대문자 변환  
- \(M_2\): 숫자만 남기고 삭제  
- \(M_3\): 길이(단항) 계산 → 직렬로 \(M_3\circ M_2\circ M_1\)

---

## 2) 조합자 ②: **조건 분기(Branch) 조합**

### 2.1 형식적 구성
- **정규 전처리기 DFA \(D\)** 로 분기 조건을 판단(예: 입력 첫 글자 카테고리).
- 제품 구성으로 \(M\)의 상태를 \((q_{\text{DFA}}, q_{\text{TM}})\) 로 들고 가다가, DFA가 **결정 시그널**을 내면
  - `branchL`: \(M_L\)의 시작으로 점프
  - `branchR`: \(M_R\)의 시작으로 점프

**간단 대안**(상태만으로 구현):  
처음 몇 글자를 읽어 **분기 결정 상태**에 진입 → 그 상태에서 \(M_L\) 또는 \(M_R\)의 시작 상태로 점프.

### 2.2 예시
- **규칙**: 첫 글자가 digit면 \(M_{\mathrm{num}}\), 아니면 \(M_{\mathrm{id}}\).  
  브릿지 상태 `q_br`에서 테이프 기호 클래스에 따라 두 시작 상태로 전이.

---

## 3) 조합자 ③: **반복(Loop) 조합**

### 3.1 형식적 구성
- TM \(M_{\text{body}}\)가 특정 변환을 수행.  
- 루프 제어 TM \(M_{\text{cond}}\) 가 “종료조건”을 검사:
  - \(M_{\text{cond}}\) 수용 ⇒ **stop**
  - 거절 ⇒ **\(M_{\text{body}}\) 다시 실행**

**상태 그래프**
```
q0 --> (run cond) --> accept_cond ? qHALT : (run body) --> back to q0
```

### 3.2 사용 패턴
- **정규화/정렬** 절차의 **고정점** 도달까지 반복.  
- 예: 문자열에서 ‘a’를 ‘b’로 모두 치환(매 회 1개 이상 치환되면 계속).

---

## 4) 조합자 ④: **서브루틴/콜-리턴**

### 4.1 콜-리턴 프로토콜(단일-테이프)
- **호출 전**: 테이프에 **리턴 주소 토큰**(예: `⟨RET_i⟩`)을 **스택처럼** 푸시.
- **서브 시작**: 공통 시작 상태 `SUB:entry`.
- **리턴**: `SUB:ret`에서 좌방향으로 `⟨RET_i⟩`를 검색 → 규칙테이블로 **분기**하여 호출지별 후속 상태로 점프.  
  토큰은 지우거나 재사용.

> 임의 깊이의 중첩 호출도 가능(토큰을 중첩 저장).  
> **주의**: 토큰 포맷은 입력과 **불충돌**하도록 설계.

### 4.2 다중-테이프 최적화
- 2번 테이프를 **콜스택** 전용으로 사용(토큰 대신 **상태코드** 저장).

---

## 5) 사례 연구(설계 스케치): 파이프라인

### 목표
1) 모든 공백 제거 → 2) 괄호 균형 검사 → 3) 길이 계산(단항)

#### 5.1 (개념) 2-테이프 버전
- **M_ws(공백 제거)**: T1(읽기), T2(쓰기). 공백이 아니면 T2에 복사.
- **M_par(균형 검사)**: T2만 사용. ‘(’이면 카운터+1, ‘)’이면 카운터−1(음수면 거절). 끝나면 0이면 수용.
- **M_len(길이)**: T2를 스캔하며 T2의 끝에 `1`을 하나씩 추가.

#### 5.2 단일-테이프 현실적 구현 팁
- 테이프 오른쪽 끝에 `#`로 **작업영역** 확보.  
- 카운터/길이표시는 `#` 뒤에 단항(`1…1`) 유지.

> 아래 코드는 **교육용**이므로, 간단한 조합 예제(TMs) + **파이썬 미니 인터프리터/오케스트레이터**를 제공한다.

---

## 6) (실전) **파이썬 미니 인터프리터 + 조합기**  
> **주의**: 학습 편의를 위한 간단 DSL. 공백은 `_`로 표기.  
> 시작 `q0`, 수용 `qa`, 거절 `qr` 고정.  
> 한 줄 규칙: `q,a -> q',b,D` (`D∈{L,R,S}`), 여러 규칙은 `;` 로 구분.

```python
# -------------------------------
# tmsim.py — 교육용 단일-테이프 TM 해석기 & 조합기
# -------------------------------
from dataclasses import dataclass
from typing import Dict, Tuple, Optional, List

Sym = str
State = str
Move = str  # 'L','R','S'

@dataclass
class TM:
    delta: Dict[Tuple[State, Sym], Tuple[State, Sym, Move]]
    start: State = "q0"
    accept: State = "qa"
    reject: State = "qr"
    blank: Sym = "_"

def parse_tm(program: str, start="q0", accept="qa", reject="qr", blank="_") -> TM:
    delta: Dict[Tuple[State, Sym], Tuple[State, Sym, Move]] = {}
    for raw in program.replace("\n", " ").split(";"):
        s = raw.strip()
        if not s:
            continue
        # q,a -> q',b,D
        left, right = s.split("->")
        q, a = [t.strip() for t in left.split(",")]
        q2, b, D = [t.strip() for t in right.split(",")]
        if D not in ("L","R","S"):
            raise ValueError(f"Invalid move {D}")
        delta[(q,a)] = (q2,b,D)
    return TM(delta, start, accept, reject, blank)

@dataclass
class RunResult:
    outcome: str         # 'ACCEPT'|'REJECT'|'TIMEOUT'
    steps: int
    head: int
    string: str          # contiguous rendering
    left_idx: int        # leftmost index used
    right_idx: int       # rightmost index used

def run(tm: TM, s: str, max_steps: int = 100000) -> RunResult:
    tape: Dict[int, Sym] = {}
    for i,ch in enumerate(s):
        tape[i] = ch
    head = 0
    q = tm.start
    def read(i: int) -> Sym:
        return tape.get(i, tm.blank)
    def write(i: int, ch: Sym):
        if ch == tm.blank:
            tape.pop(i, None)
        else:
            tape[i] = ch
    for step in range(1, max_steps+1):
        if q == tm.accept:
            left = min([0, *tape.keys()]) if tape else 0
            right = max([0, *tape.keys()]) if tape else 0
            return RunResult("ACCEPT", step-1, head,
                             "".join(tape.get(i, tm.blank) for i in range(left, right+1)),
                             left, right)
        if q == tm.reject:
            left = min([0, *tape.keys()]) if tape else 0
            right = max([0, *tape.keys()]) if tape else 0
            return RunResult("REJECT", step-1, head,
                             "".join(tape.get(i, tm.blank) for i in range(left, right+1)),
                             left, right)

        a = read(head)
        rule = tm.delta.get((q,a))
        if rule is None:
            # 규약: 전이 없음 = 거절
            left = min([0, *tape.keys()]) if tape else 0
            right = max([0, *tape.keys()]) if tape else 0
            return RunResult("REJECT", step, head,
                             "".join(tape.get(i, tm.blank) for i in range(left, right+1)),
                             left, right)

        q2, b, D = rule
        write(head, b)
        if D == "L":
            head -= 1
        elif D == "R":
            head += 1
        q = q2

    left = min([0, *tape.keys()]) if tape else 0
    right = max([0, *tape.keys()]) if tape else 0
    return RunResult("TIMEOUT", max_steps, head,
                     "".join(tape.get(i, tm.blank) for i in range(left, right+1)),
                     left, right)

# ------------- 조합기: 직렬/분기/반복 (오케스트레이터) ----------------

def serial(programs: List[TM], s: str, max_steps_each: int = 100000) -> RunResult:
    """ M_k ∘ ... ∘ M_2 ∘ M_1 : 해석기 수준 오케스트레이션 """
    current = s
    total_steps = 0
    head = 0
    left = 0
    right = len(s)-1 if s else 0
    for i,tm in enumerate(programs, start=1):
        r = run(tm, current, max_steps_each)
        total_steps += r.steps
        head, left, right = r.head, r.left_idx, r.right_idx
        if r.outcome != "ACCEPT":
            return RunResult(r.outcome, total_steps, head, r.string, left, right)
        # 다음 TM으로 입력 전달: 현재 테이프의 contiguous 구간
        current = r.string
    return RunResult("ACCEPT", total_steps, head, current, left, right)

def branch(tm_if: TM, tm_else: TM, s: str, predicate) -> RunResult:
    """ if predicate(s): run tm_if else tm_else """
    if predicate(s):
        return run(tm_if, s)
    else:
        return run(tm_else, s)

def loop(tm_body: TM, tm_cond: TM, s: str, max_iters: int = 1000) -> RunResult:
    """ while not cond(s): s = body(s) """
    total_steps = 0
    current = s
    head=0; left=0; right=len(s)-1 if s else 0
    for _ in range(max_iters):
        rc = run(tm_cond, current)
        total_steps += rc.steps
        if rc.outcome == "ACCEPT":   # cond == True → 종료
            return RunResult("ACCEPT", total_steps, rc.head, current, rc.left_idx, rc.right_idx)
        # cond 거절 → body 수행
        rb = run(tm_body, current)
        total_steps += rb.steps
        if rb.outcome != "ACCEPT":
            return RunResult(rb.outcome, total_steps, rb.head, rb.string, rb.left_idx, rb.right_idx)
        current = rb.string
        head, left, right = rb.head, rb.left_idx, rb.right_idx
    return RunResult("TIMEOUT", total_steps, head, current, left, right)
```

---

## 7) **작동하는 소형 TM 예제** (교육용 DSL)

### 7.1 M\_map\_a2b — 모든 `a`를 `b`로 바꾸고 수용
```
q0,a -> q0,b,R;
q0,b -> q0,b,R;
q0,_ -> qa,_,S;
q0,1 -> q0,1,R;
q0,0 -> q0,0,R;
q0,( -> q0,(,R;
q0,) -> q0,),R;
```
- 의미: 입력 종류가 몇 가지 없다는 가정 하의 단순 매퍼(추가 문자는 필요에 따라 열거).

### 7.2 M\_even1 — `1`의 개수가 **짝수**면 수용, 홀수면 거절
```
q0,1 -> q1,1,R;  q1,1 -> q0,1,R;
q0,0 -> q0,0,R;  q1,0 -> q1,0,R;
q0,_ -> qa,_,S;  q1,_-> qr,_,S;
```

### 7.3 M\_len\_unary — 입력의 길이만큼 오른쪽에 `#111...1` 생성
아이디어: 처음 `_`을 찾으면 `#` 기록, 헤드를 되돌린 뒤 **문자 1개당** `#` 뒤에 `1` 하나 추가.
(간단화 버전: 끝으로 가서 `#` 찍고 다시 처음으로 복귀 → 각 문자를 표식으로 바꿔가며 카운팅)

```
# Phase A: 끝으로 가서 # 배치
q0,1 -> q0,1,R;  q0,0 -> q0,0,R;  q0,a -> q0,a,R;  q0,b -> q0,b,R;  q0,_ -> q1,#,L;

# Phase B: 왼쪽으로 돌아가며 아직 표식되지 않은 기호(X가 아님)를 찾는다
q1,# -> q1,#,L;  q1,1 -> q2,X,R;  q1,0 -> q2,X,R;  q1,a -> q2,X,R;  q1,b -> q2,X,R;  q1,_ -> q6,#,R;

# Phase C: # 끝으로 가서 1 추가
q2,1 -> q2,1,R;  q2,0 -> q2,0,R;  q2,a -> q2,a,R;  q2,b -> q2,b,R;  q2,X -> q2,X,R;  q2,# -> q3,#,R;
q3,_ -> q4,1,L;  q4,# -> q5,#,L;  q5,1 -> q5,1,L;  q5,0 -> q5,0,L;  q5,a -> q5,a,L;  q5,b -> q5,b,L;  q5,X -> q1,X,L;

# Phase D: 모든 기호가 X면 종료(= 카운트완료)
q6,1 -> q6,1,R; q6,0 -> q6,0,R; q6,X -> q6,X,R; q6,# -> q7,#,R; q6,_ -> q7,_,S;
q7,_ -> qa,_,S;
```
> *설명*: 실제 상용기 수준으로 간결하지 않지만, **작동 원리**(표식, 카운트, 복귀)를 보여주는 교육용 스케치.

---

## 8) **조합 사용 예** (오케스트레이터로 실행)

```python
# (1) a->b 매핑 → (2) 1의 개수 짝수 검사  → 직렬 조합
tm_map = parse_tm("""
q0,a->q0,b,R; q0,b->q0,b,R; q0,1->q0,1,R; q0,0->q0,0,R; q0,_->qa,_,S;
""")
tm_even = parse_tm("""
q0,1->q1,1,R; q1,1->q0,1,R; q0,0->q0,0,R; q1,0->q1,0,R; q0,_->qa,_,S; q1,_->qr,_,S;
""")

r = serial([tm_map, tm_even], "a10a1")
print(r.outcome, r.string)   # 변환 후 "b10b1" → 1의 개수 2 → ACCEPT

# 분기: 첫 글자가 숫자면 even1, 아니면 map만
def first_is_digit(s: str) -> bool:
    return len(s)>0 and s[0] in "01"
r1 = branch(tm_even, tm_map, "1ab", first_is_digit)
r2 = branch(tm_even, tm_map, "a1b", first_is_digit)
print(r1.outcome)  # even 검사
print(r2.outcome)  # map 수행 결과
```

```python
# 반복: cond가 만족할 때까지 map_a2b를 계속 (여기서는 이미 한 번이면 충분)
tm_cond_done = parse_tm("q0,b->q0,b,R; q0,_->qa,_,S; q0,a->qr,a,S;")
# 의미: 'a'가 남아있으면 거절(= 계속), 모두 b면 수용(= 종료)

r = loop(tm_map, tm_cond_done, "aaab")
print(r.outcome, r.string)  # 최종 "bbbb"
```

> 위 오케스트레이션은 **UTM 수준의 “조합 실행”**을 보여준다.  
> 형식적(튜링 수준) 조합과 개념적으로 동일하며, 실습/테스트에 **매우 유용**하다.

---

## 9) **서브루틴(콜-리턴) 설계 예시** (형식적 스케치)

### 과제: `SUB:scan_to_blank_and_write(X)`
- 호출부: `CALL_SUB_X` 상태에서 **리턴 토큰** `⟨RET_CALL_SUB_X⟩` 를 현 헤드 오른쪽에 푸시 후 `SUB:entry`로 점프.
- 서브루틴:
  1) 오른쪽으로 이동하며 첫 `_`을 찾음
  2) 거기에 `X`를 쓰기
  3) 좌로 이동하며 가장 가까운 `⟨RET_*⟩`를 찾음
  4) 토큰 종류에 따라 분기: `⟨RET_CALL_SUB_X⟩` → `AFTER_SUB_X`
- 리턴: 토큰 지우고 `AFTER_SUB_X` 상태로 이어감.

**장점**
- 서브루틴 **재사용/중첩 호출** 가능(토큰이 스택처럼 쌓임).
- 다중-테이프면 2번 테이프를 **콜스택**으로 쓰면 구현이 간단/효율적.

---

## 10) **정확성 & 복잡도**(개요)

- **정확성**: 네 조합(직렬/분기/반복/서브루틴)은 모두 **튜링 등가** 연산.  
  형식적 구성(상태 분리·브릿지 전이·콜스택 토큰)으로 **언어 수준** 조합이 가능한 것과 동치.
- **시간 복잡도**
  - **직렬**: 합산 \(T_1+T_2+\cdots\) + 상수 오버헤드(브릿지).  
  - **분기**: 전처리 DFA가 선형이면 총 \(O(n)+T_{\text{선택}}\).  
  - **반복**: \(k\)회 반복이면 \(k\cdot (T_{\text{cond}}+T_{\text{body}})\).  
  - **서브루틴**: 콜/리턴 오버헤드 = 토큰 푸시/팝(대개 선형 또는 상수에 가까운 비용) × 호출 횟수.
- **공간**: 보통 합/최대치 + 콜스택(토큰) 길이. 다중-테이프는 동일 차수 내에서 절약 가능.

---

## 11) **실전 체크리스트**

1. **상태 충돌 회피**: 기계마다 접두사(예: `A:`, `B:`)를 붙여 조합.  
2. **헤드 정렬**: 브릿지에서 **왼쪽 기준점**이나 **첫 기호**로 맞춘 뒤 시작.  
3. **알파벳 합집합**: 조합 기계의 \(\Gamma\)는 각 기계의 \(\Gamma\) 합집합.  
4. **토큰 설계**: 입력과 **충돌하지 않는** 리턴 토큰/마커 사용.  
5. **무한루프 방지**: 반복 조합엔 **수학적 종료조건** 또는 **상태 불변량**을 잡고, 실습 코드는 가드(최대 스텝/반복) 부여.  
6. **테스트**: (빈 입력, 최소 길이, 경계 문자, 긴 입력)로 케이스 분류.

---

## 12) 한 페이지 요약

- **조합 핵심**: 튜링 기계는 **직렬·분기·반복·서브루틴**으로 복잡한 작업을 **모듈화**하여 구현할 수 있다.  
- **형식적 구성**: 상태 집합 분리, 브릿지 전이, DFA 기반 분기, 콜스택 토큰 등으로 **튜링 수준**에서도 자연스럽게 가능.  
- **실용 오케스트레이션**: UTM/해석기에서 **직렬/분기/반복 함수**로 구현하면 실습/검증이 빠르고 유연.  
- **효율**: 표현력은 동일, 시간/공간 오버헤드는 **상수~다항** 범위에서 제어 가능.

---

## 13) 빠른 실행 가이드(요약 코드)

```python
# 1) 파서/해석기 로드 후
tm_map = parse_tm("q0,a->q0,b,R; q0,b->q0,b,R; q0,1->q0,1,R; q0,0->q0,0,R; q0,_->qa,_,S;")
tm_even = parse_tm("q0,1->q1,1,R; q1,1->q0,1,R; q0,0->q0,0,R; q1,0->q1,0,R; q0,_->qa,_,S; q1,_->qr,_,S;")

# 2) 직렬 조합
print(serial([tm_map, tm_even], "a10a1").outcome)   # ACCEPT

# 3) 분기 조합
print(branch(tm_even, tm_map, "1ab", lambda s: s[:1] in ("0","1")).outcome)

# 4) 반복 조합
tm_cond_done = parse_tm("q0,b->q0,b,R; q0,_->qa,_,S; q0,a->qr,a,S;")
print(loop(tm_map, tm_cond_done, "aaab").string)     # bbbb
```
