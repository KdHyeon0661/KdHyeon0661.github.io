---
layout: post
title: 객체지향설계 - 다형성
date: 2025-07-15 18:20:23 +0900
category: 객체지향설계
---
# 다형성 (Polymorphism)

다형성(Polymorphism)은 객체지향 프로그래밍(OOP)의 핵심 개념 중 하나로, **"여러 형태를 가질 수 있는 능력"**을 의미합니다. 같은 인터페이스를 통해 서로 다른 구현을 사용할 수 있게 하여 **유연하고 확장 가능한 코드**를 작성할 수 있게 합니다.

---

## 1. 다형성의 정의

다형성이란, **같은 타입의 참조 변수가 다양한 객체를 참조할 수 있는 성질**을 말합니다. 즉, 동일한 메시지를 보냈을 때 객체의 타입에 따라 다른 동작을 수행하는 능력입니다.

```java
Animal a = new Dog();
a.speak(); // "멍멍" 출력

a = new Cat();
a.speak(); // "야옹" 출력
```

`a`는 `Animal` 타입이지만, 실제로는 `Dog` 또는 `Cat` 객체를 참조함으로써 각기 다른 동작을 수행합니다.

---

## 2. 다형성의 종류

### ✅ 2.1 컴파일 시간 다형성 (정적 다형성, Static Polymorphism)

- **오버로딩(Overloading)**: 같은 이름의 메서드를 매개변수만 다르게 정의
- 컴파일 타임에 어떤 메서드가 호출될지 결정됨

```java
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
}
```

> 장점: 빠름  
> 단점: 런타임 조건에 따라 결정 불가

---

### ✅ 2.2 런타임 다형성 (동적 다형성, Dynamic Polymorphism)

- **오버라이딩(Overriding)**: 상속 관계에서 부모 클래스의 메서드를 자식 클래스가 재정의
- **업캐스팅을 통해 부모 타입의 참조 변수가 자식 객체를 가리킴**
- 실행 시점에 어떤 메서드가 호출될지 결정됨

```java
class Animal {
    void speak() { System.out.println("..."); }
}

class Dog extends Animal {
    @Override
    void speak() { System.out.println("멍멍!"); }
}

class Cat extends Animal {
    @Override
    void speak() { System.out.println("야옹!"); }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.speak(); // 멍멍!
    }
}
```

> 장점: 유연하고 확장 가능  
> 단점: 약간의 성능 저하 (가상 메서드 테이블 사용)

---

## 3. 다형성의 전제 조건

- 상속(Inheritance) 또는 인터페이스 구현
- 메서드 오버라이딩
- 업캐스팅 (부모 클래스 타입 참조)

---

## 4. 다형성의 장점

| 항목             | 설명 |
|------------------|------|
| 코드의 유연성      | 새로운 기능 추가 시 기존 코드를 수정하지 않고도 확장 가능 |
| 유지보수 용이성    | 변경이 필요한 경우 인터페이스 구현만 변경하면 됨 |
| 중복 코드 제거     | 공통된 로직은 상위 클래스에서 정의하고, 개별 동작은 하위 클래스에 위임 |

---

## 5. 예시: 인터페이스와 다형성

```java
interface Shape {
    double area();
}

class Circle implements Shape {
    double r;
    Circle(double r) { this.r = r; }
    public double area() { return Math.PI * r * r; }
}

class Rectangle implements Shape {
    double w, h;
    Rectangle(double w, double h) { this.w = w; this.h = h; }
    public double area() { return w * h; }
}

public class Main {
    public static void main(String[] args) {
        Shape[] shapes = {
            new Circle(5),
            new Rectangle(3, 4)
        };

        for (Shape s : shapes) {
            System.out.println("면적: " + s.area());
        }
    }
}
```

> 출력  
> 면적: 78.5398  
> 면적: 12.0

인터페이스 `Shape`를 기반으로 다양한 도형 클래스(`Circle`, `Rectangle`)를 다형적으로 처리합니다.

---

## 6. 실전 활용 예: 전략 패턴 (Strategy Pattern)

전략 패턴은 다형성을 활용하여 런타임에 알고리즘을 선택할 수 있게 해주는 디자인 패턴입니다.

```java
interface SortStrategy {
    void sort(int[] arr);
}

class BubbleSort implements SortStrategy {
    public void sort(int[] arr) {
        // 버블 정렬 구현
    }
}

class QuickSort implements SortStrategy {
    public void sort(int[] arr) {
        // 퀵 정렬 구현
    }
}

class Sorter {
    SortStrategy strategy;
    public Sorter(SortStrategy strategy) {
        this.strategy = strategy;
    }
    public void sort(int[] arr) {
        strategy.sort(arr);
    }
}
```

```java
int[] data = {5, 2, 8, 1};
Sorter s = new Sorter(new QuickSort());
s.sort(data);
```

> 런타임에 정렬 알고리즘을 쉽게 변경 가능

---

## 7. instanceof와 형변환 (Downcasting)

다형성을 사용할 때 실제 타입을 알아야 하는 경우 `instanceof` 연산자나 명시적 형변환을 사용할 수 있습니다.

```java
Animal a = new Dog();

if (a instanceof Dog) {
    Dog d = (Dog) a;
    d.bark();
}
```

> 단, 자바에서는 `instanceof` 사용이 지나치면 OOP 원칙 위반 가능성 있으므로 주의

---

## 8. 다형성과 가상 메서드 테이블(VMT)

다형성을 구현하는 핵심 기술은 **가상 메서드 테이블(Virtual Method Table)**입니다.

- 각 클래스는 자신의 메서드 테이블(VMT)을 가짐
- 오버라이딩된 메서드는 자식 클래스의 VMT에 저장됨
- 런타임 시 해당 메서드를 참조하여 호출

---

## 9. 다형성과 SOLID 원칙

다형성은 SOLID 원칙 중 특히 아래 2가지와 밀접하게 연결되어 있습니다:

- **OCP (Open/Closed Principle)**  
  : 기존 코드를 변경하지 않고 기능을 확장할 수 있음

- **LSP (Liskov Substitution Principle)**  
  : 자식 클래스는 부모 클래스를 대체할 수 있어야 함

---

## 10. 주의할 점

- 다형성은 유연한 구조를 제공하지만 **추상화가 과도하면 오히려 복잡도 증가**
- 실제 타입을 확인하는 코드가 많아지면 **추상화가 실패한 구조**

---

## ✅ 결론

| 항목 | 설명 |
|------|------|
| 정의 | 동일한 메시지에 대해 다양한 동작을 수행하는 능력 |
| 구현 방법 | 상속 + 오버라이딩 + 업캐스팅 |
| 장점 | 코드 재사용, 확장성, 유연성 |
| 실전 활용 | 디자인 패턴, 전략/상태 패턴, 라이브러리/프레임워크 구조 등 |
| 유의점 | 남용하면 복잡도 증가, SOLID 원칙 위배 가능 |

---

> 다형성은 객체지향 프로그래밍의 진정한 힘을 이끌어내는 핵심 기술입니다. 잘 활용하면 복잡한 시스템도 유연하게 설계할 수 있지만, 잘못 사용하면 오히려 설계가 무너지므로 추상화 수준을 신중하게 조절하는 것이 중요합니다.
