---
layout: post
title: 객체지향설계 - 다형성
date: 2025-07-15 18:20:23 +0900
category: 객체지향설계
---
# 다형성 (Polymorphism)

## 다형성의 정의

> **다형성(polymorphism)**은 **같은 타입의 참조**(또는 같은 인터페이스)를 통해 **여러 구현**을 일관된 방식으로 사용할 수 있는 능력이다. 동일한 메시지(메서드 호출)에 대해, **구체 타입에 따라 다른 동작**을 수행한다.

```java
Animal a = new Dog(); a.speak(); // "멍멍"
a = new Cat();      a.speak(); // "야옹"
```

---

## 다형성의 분류(큰 지도)

| 분류 | 핵심 | 예 |
|---|---|---|
| **부분형(Subtype) 다형성)** | 상위 타입(추상/인터페이스) 참조로 하위를 대체 | 인터페이스/상속 + 오버라이딩 |
| **매개변수(Parametric) 다형성** | 타입 매개변수로 알고리즘을 일반화 | 제네릭/템플릿 `List<T>`, `std::vector<T>` |
| **애드혹(Ad-hoc) 다형성** | 이름은 같지만 인자 타입으로 다른 의미 | 오버로딩, 연산자 오버로딩 |

> 초안의 **정적/동적 다형성**은 구현 시점의 관점(바인딩 타이밍)으로 본 분류다.
> - 정적(컴파일 타임): **오버로딩, 템플릿/제네릭**
> - 동적(런타임): **오버라이딩(가상 디스패치)**

---

## 정적 vs 동적 다형성

### 컴파일 시간(정적) 다형성

- **오버로딩**: 시그니처로 구분
- **제네릭/템플릿**: 타입 인수에 따라 인스턴스화/타입 소거

```java
class Calculator {
    int add(int a, int b)       { return a + b; }
    double add(double a, double b){ return a + b; } // 오버로딩
}
```

```cpp
template <class T>
T add(T a, T b){ return a + b; } // 템플릿: 정적 결정
```

### 런타임(동적) 다형성

- **오버라이딩** + **업캐스팅** + **가상 디스패치**
- 실행 시점에 실제 객체의 vtable을 통해 호출 대상 결정

```java
class Animal { void speak(){ System.out.println("..."); } }
class Dog extends Animal { @Override void speak(){ System.out.println("멍멍!"); } }
```

장단점 요약:
- 정적: 빠르고 최적화 쉬움, 유연성은 상대적으로 적음
- 동적: 유연·확장 용이, 약간의 호출 오버헤드

---

## 디스패치 메커니즘(언어별)

| 언어 | 메커니즘 | 비고 |
|---|---|---|
| Java | 가상 메서드 테이블(vtable)/인터페이스 디스패치 | `final/sealed`로 디가상화/인라이닝 유도 가능 |
| C# | vtable, `virtual/override/sealed` | 인터페이스 호출 최적화 발전(.NET JIT) |
| C++ | `virtual` vtable, `final`/`override` | 가상 소멸자 필수, CRTP로 정적 다형성 |
| Python | 덕 타이핑 + MRO | `__getattr__`, 다중상속 MRO 규칙 |
| Kotlin/Scala | JVM 위에서의 가상 디스패치 + 고급 타입 시스템 | sealed, traits |

---

## 오버로딩 vs 오버라이딩 vs 섀도잉(하이딩)

| 개념 | 시점 | 기준 | 설명 |
|---|---|---|---|
| 오버로딩 | 컴파일 | 시그니처 | 같은 이름, 다른 파라미터 |
| 오버라이딩 | 런타임 | 동적 디스패치 | 상속/인터페이스에서 재정의 |
| 하이딩(섀도잉) | 컴파일 | 정적 바인딩 | 정적 메서드/필드가 상위와 같은 이름일 때 가림 |

```java
class Base { static void f(){ System.out.println("Base"); } }
class Sub extends Base { static void f(){ System.out.println("Sub"); } }
Base.f(); // Base, 하이딩은 정적
```

---

## 공변·반공변·불변(제네릭/반환 타입)

### 반환 타입 공변(covariant return)

```java
class Parent { Number value(){ return 1; } }
class Child extends Parent { @Override Integer value(){ return 1; } } // 공변 허용
```

### 제네릭 변성

- **Java**: 무공변 기본, 와일드카드로 변성 명시(**PECS**)
  - `? extends T` : 읽기 전용(Producer)
  - `? super T` : 쓰기 가능(Consumer)
- **C#**: `out`(공변), `in`(반공변) 키워드

```java
List<? extends Number> r = List.of(1,2,3); // 읽기 OK, 추가 X
List<? super Integer>  w = new ArrayList<Number>(); // Integer 추가 OK
```

> 과도한 변성은 복잡도를 높이므로 **인터페이스는 작게** 설계하고, 필요한 지점에서만 변성 사용.

---

## 계약과 LSP(리스코프 치환 원칙)

**정의**: 상위 타입의 모든 바람직한 성질(계약)을 **하위 타입도 보존**해야 한다.

수식 형식:
$$
\text{Pre}_S \subseteq \text{Pre}_T,\quad \text{Post}_T \subseteq \text{Post}_S,\quad \text{Inv}_S \supseteq \text{Inv}_T
$$

- 하위는 **전제조건을 강화하면 안 되고**, **사후조건을 약화하면 안 되며**, **불변식**을 유지해야 한다.

**사각형-정사각형** 문제는 전형적 LSP 위반 사례. 해결은 **상속 대신 역할 인터페이스/합성**.

---

## 인터페이스 기반 다형성(실전)

### Shape 예제(초안 확장)

```java
interface Shape { double area(); }

final class Circle implements Shape {
    private final double r;
    Circle(double r){ this.r = r; }
    public double area(){ return Math.PI * r * r; }
}

final class Rectangle implements Shape {
    private final double w, h;
    Rectangle(double w, double h){ this.w = w; this.h = h; }
    public double area(){ return w * h; }
}

class Demo {
    public static void main(String[] args){
        Shape[] shapes = { new Circle(5), new Rectangle(3,4) };
        for (Shape s : shapes) System.out.println("면적: " + s.area());
    }
}
```

- **개방-폐쇄(OCP)**: 새 도형 추가 시 기존 코드 변경 없이 확장

### 전략 패턴(초안 확장)

```java
interface SortStrategy { void sort(int[] arr); }
final class BubbleSort implements SortStrategy { public void sort(int[] a){ /* ... */ } }
final class QuickSort  implements SortStrategy { public void sort(int[] a){ /* ... */ } }

final class Sorter {
    private SortStrategy s;
    Sorter(SortStrategy s){ this.s = s; }
    void setStrategy(SortStrategy s){ this.s = s; } // 런타임 교체
    void sort(int[] a){ s.sort(a); }
}
```

- 런타임에 알고리즘 교체 → **다형성의 전형적 활용**

---

## Visitor(더블 디스패치)로 `instanceof` 제거

**문제**: `instanceof`/타입 분기 남용은 다형성 실패의 신호.

**해결**: Visitor 패턴—수신자와 방문자의 **더블 디스패치**로 타입별 동작을 분리.

```java
interface Expr { <R> R accept(ExprVisitor<R> v); }
final class Num implements Expr {
    final int n; Num(int n){ this.n=n; }
    public <R> R accept(ExprVisitor<R> v){ return v.visitNum(this); }
}
final class Add implements Expr {
    final Expr l,r; Add(Expr l, Expr r){ this.l=l; this.r=r; }
    public <R> R accept(ExprVisitor<R> v){ return v.visitAdd(this); }
}
interface ExprVisitor<R> {
    R visitNum(Num n); R visitAdd(Add a);
}
final class Eval implements ExprVisitor<Integer> {
    public Integer visitNum(Num n){ return n.n; }
    public Integer visitAdd(Add a){ return a.l.accept(this) + a.r.accept(this); }
}
```

- 새로운 **동작**(방문자) 추가가 쉬움, 새로운 **타입(노드)** 추가는 비용 증가 → 트레이드오프 인지

---

## 매개변수 다형성(제네릭)으로 알고리즘 일반화

```java
interface Serializer<T> { byte[] serialize(T v); }
final class JsonUserSerializer implements Serializer<User> {
    public byte[] serialize(User u){ /* ... */ return new byte[0]; }
}
final class JsonOrderSerializer implements Serializer<Order> {
    public byte[] serialize(Order o){ /* ... */ return new byte[0]; }
}
```

- **타입 인수**를 통해 **동일한 추상 동작**을 여러 타입에 적용
- Java는 **타입 소거**, C#은 **런타임 제네릭(리플렉션/속도 차)**

---

## DI/플러그인 아키텍처에서의 다형성

### 포트/어댑터(헥사고날 아키텍처)

```java
public interface PaymentPort { void pay(int amount, String key); } // Port
public final class KakaoAdapter implements PaymentPort { public void pay(int a, String k){ /* ... */ } }
public final class CardAdapter  implements PaymentPort { public void pay(int a, String k){ /* ... */ } }

public final class Checkout {
    private final PaymentPort payment;
    public Checkout(PaymentPort p){ this.payment = p; }
    public void confirm(int amount, String key){ payment.pay(amount, key); }
}
```

- 도메인 계층은 **추상(Port)**에 의존, 인프라 계층은 **구현(Adapter)** 제공
- 새로운 결제 수단 = 새 어댑터만 추가(OCP)

### Java ServiceLoader(런타임 플러그인)

```java
// META-INF/services/com.acme.Plugin 에 구현 클래스 이름 등록
public interface Plugin { void run(); }
// 로딩
ServiceLoader<Plugin> loader = ServiceLoader.load(Plugin.class);
for (var p : loader) p.run();
```

---

## `instanceof`와 다운캐스팅—언제, 어떻게?

- 불가피한 경우(성능 최적화, 레거시 API 조합) **국소적으로** 사용
- 우선순위: **다형적 메서드 → Visitor → 패턴 매칭(JDK 21+) → instanceof**
- 과다 사용은 **추상화 실패** 시그널 → 인터페이스/동작 재배치

```java
if (a instanceof Dog d) { d.bark(); } // 패턴 매칭 (JDK 21+)
```

---

## 성능 관점: vtable, 인라이닝, `sealed/final`

- 가상 호출은 일반 호출보다 미세하게 비싸지만, **JIT가 디가상화/인라이닝**을 활발히 수행
- **Java**: `final`/`sealed`/`private` 메서드는 인라이닝 유리
- **C#**: `sealed` 오버라이드, `AggressiveInlining` 힌트
- **C++**: `final`, LTO, CRTP로 정적 다형성(런타임 비용 제거)

> 핫패스가 아니라면 **읽기 쉬운 다형성**이 최적화보다 중요.
> 핫패스라면 **측정-검증** 후 정적 다형성/전략 선택.

---

## 동시성과 다형성

- 다형적 구현마다 **스레드 안전성**이 다를 수 있으므로 **계약**에 명시하라.
  예: `Cache` 인터페이스의 구현 중 `ConcurrentCache`와 `LocalCache`의 동기화 보장 차이

```java
interface Cache<K,V> { V get(K k); void put(K k, V v); } // 스레드 안전 여부를 Javadoc/문서로 명시
```

---

## 테스트 전략: **계약 테스트**로 구현 교체를 안전하게

```java
abstract class PaymentContract {
    protected abstract PaymentPort sut();
    @org.junit.jupiter.api.Test
    void paysPositiveAmount(){
        sut().pay(1000, "k1"); // 예외 없이 동작, 멱등키 재호출은 중복 방지 등
    }
}
final class KakaoAdapterTest extends PaymentContract {
    protected PaymentPort sut(){ return new KakaoAdapter(); }
}
final class CardAdapterTest extends PaymentContract {
    protected PaymentPort sut(){ return new CardAdapter(); }
}
```

- 상위 **역할 계약**을 공유 테스트로 캡쳐 → 모든 구현이 동일 계약을 만족

---

## 안티패턴과 리팩토링

| 증상 | 원인 | 해결 |
|---|---|---|
| `instanceof` 사슬 | 추상화 실패 | 다형적 메서드로 이동, Visitor 도입 |
| God 인터페이스 | 역할 혼재 | **ISP**로 분리(작은 인터페이스) |
| 과도한 추상화 | YAGNI 위반 | 구체 클래스로 단순화, 필요 시 점진 추상화 |
| 상속 남용 | DRY 오해 | 합성/전략/데코레이터로 전환 |
| 공변성 오류 | 잘못된 제네릭 변성 | `? extends/? super`, C# `in/out` 적용 |

**리팩토링 레시피**
1) 타입 분기 → Visitor/다형 메서드로 이동
2) 상속 제거 → 협력 객체 주입(합성)
3) 비대한 인터페이스 → 역할별로 분리(ISP)
4) 하위만 아는 메서드 → 상위 계약에 승격(다형성의 표면으로)

---

## 패턴 with 다형성(짧은 지도)

| 패턴 | 다형성 포인트 | 비고 |
|---|---|---|
| **Strategy** | 알고리즘 교체 | 런타임 교체/테스트 용이 |
| **State** | 상태별 동작 분기 제거 | 내부 객체로 상태 전환 |
| **Template Method** | 골격 상속 + 후크 | 상속 기반—확장 지점 제한 |
| **Command** | 요청 캡슐화 | 큐잉/트랜잭션과 결합 |
| **Visitor** | 더블 디스패치 | 타입 분기 제거(노드 고정) |
| **Adapter** | 인터페이스 변환 | 포트/어댑터의 핵심 |

---

## 수식으로 보는 다형성의 안정성

클라이언트 관찰 가능 결과를 \(Obs\), 구현을 \(Impl\), 계약을 \(C\)라 하면,

$$
\forall \; Impl_1, Impl_2 \models C \;\Rightarrow\; Obs(Impl_1) = Obs(Impl_2)
$$

- **같은 계약**을 만족하는 구현은 **클라이언트 관점에서 대체 가능**해야 한다—다형성의 핵심.

---

## 종합 예시: 직렬화 플러그인 + 전략 + 계약 테스트

```java
// 역할
interface Serializer<T> { byte[] serialize(T t); }
// 구현
final class JsonUserSerializer implements Serializer<User> { public byte[] serialize(User u){ /* ... */ return new byte[0]; } }
final class XmlUserSerializer  implements Serializer<User> { public byte[] serialize(User u){ /* ... */ return new byte[0]; } }
// 전략 적용
final class UserExporter {
    private Serializer<User> s;
    UserExporter(Serializer<User> s){ this.s = s; }
    void setStrategy(Serializer<User> s){ this.s = s; }
    byte[] export(User u){ return s.serialize(u); }
}
```

계약 테스트 스케치:

```java
abstract class SerializerContract {
    protected abstract Serializer<User> sut();
    @org.junit.jupiter.api.Test
    void roundtripGivesEquivalent(){
        User u = new User("kim", 30);
        byte[] bytes = sut().serialize(u);
        // 역직렬화 구현이 있다면 round-trip 동치성 검증
    }
}
```

---

## 체크리스트

- [ ] **is-a**가 자연스러운가? (**역할**로 표현 가능한가?)
- [ ] **LSP**를 계약/테스트로 고정했는가?
- [ ] 새 기능 추가가 **기존 코드 수정 없이** 가능한가(OCP)?
- [ ] `instanceof` 사슬을 **Visitor/다형 메서드**로 치환했는가?
- [ ] 제네릭 변성/반환 공변성 규칙을 지켰는가?
- [ ] 핫패스는 측정 후 **정적 다형성/인라이닝**을 고려했는가?
- [ ] 인터페이스는 **작고 역할 중심(ISP)**인가?
- [ ] DI/플러그인 구조로 **구현 교체**가 쉬운가?

---

## 요약

| 항목 | 핵심 정리 |
|---|---|
| 정의 | 동일한 메시지에 대해 **구현마다 다른 동작**을 수행하는 능력 |
| 구현 | **오버라이딩**(동적), **오버로딩/제네릭**(정적) |
| 원칙 | **LSP/OCP/ISP/DIP**—계약을 지키는 교체 가능성 |
| 활용 | 전략/상태/어댑터/Visitor/템플릿 메서드, DI/플러그인 |
| 성능 | JIT 디가상화/인라이닝, `sealed/final`, C++ CRTP |
| 주의 | `instanceof` 남용, 과도한 추상화, 변성 오류, 상속 남용 |

다형성은 **확장 가능성과 교체 가능성**을 시스템에 심어주는 핵심 장치다. **작은 인터페이스·명확한 계약·검증 가능한 테스트**를 기본값으로 삼아라. 그러면 구현은 자유롭게 바뀌어도, **클라이언트의 관찰 결과는 안정**적으로 유지된다—그것이 다형성의 진짜 힘이다.
