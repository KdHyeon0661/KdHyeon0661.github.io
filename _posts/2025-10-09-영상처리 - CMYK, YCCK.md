---
layout: post
title: 영상처리 - CMYK, YCCK
date: 2025-10-09 21:25:23 +0900
category: 영상처리
---
# CMYK / YCCK JPEG **완전 대응** — Adobe APP14(Transform) 파싱 → 올바른 CMYK→RGB 변환 → YCCK 처리 · 테스트 전략

## 개요 — 왜 CMYK/YCCK가 까다로운가?

- **RGB JPEG**만 다루던 뷰어에 **CMYK / YCCK** JPEG를 던지면,
  - 색이 **뒤집혀 보이거나**(시커멓게/색 반전),
  - **초록/보라**로 붕 뜨는 현상이 나올 수 있습니다.
- 원인:
  1) JPEG가 **CMYK**(감산계) 또는 **YCCK**(YCbCr의 CMYK 버전) 색공간으로 인코드됨
  2) **Adobe APP14** 마커의 **transform** 및 일부 **인버전 관행**(특히 포토샵 계열)
  3) **ICC 프로파일** 유무/색관리 미적용

핵심 대책은 아래 **3단계 파이프라인**입니다.

1. **헤더/마커 파싱**: `jpeg_read_header` 후 `cinfo.jpeg_color_space` 검사, APP14(Adobe) **transform** 파싱
2. **출력 색공간 결정**: YCCK/CMYK이면 디코더 출력 `JCS_CMYK`(4채널)로
3. **CMYK → BGRA 변환**:
   - **정석(빠름)**: 단순 합산 모델
     \[
     R = 255 - \min(255, C + K),\quad
     G = 255 - \min(255, M + K),\quad
     B = 255 - \min(255, Y + K)
     \]
     ※ 필요 시 **채널 인버전**(C=M=Y=K=255-채널) 먼저 적용
   - **정밀(선택)**: 임베디드 **ICC** → **lcms2**로 **sRGB** 변환

---

## Adobe APP14(0xFFEE) 마커 — transform 규칙

APP14("Adobe") 페이로드 구조(요약):

```
"Adobe" (5B) | version(2B BE) | flags0(2B BE) | flags1(2B BE) | transform(1B)
```

- **transform** 의미(관례):
  - **0**: Unknown (대개 **CMYK**) — 일부 인코더는 **인버전된 CMYK**를 사용
  - **1**: YCbCr (RGB JPEG 맥락)
  - **2**: **YCCK** (YCbCr의 CMYK 확장) — 보통 **인버전 필요**
- 따라서 **CMYK/YCCK** JPEG에서 Adobe transform은 **채널 뒤집음**(invert) 여부에 대한 강력한 힌트입니다.

> 안전 가이드
> - **transform==2**(YCCK) → YCCK→CMYK 변환 후 **인버전**을 적용해야 하는 케이스가 일반적
> - **transform==0**(CMYK) → **인버전 적용**하는 파일이 많음(특히 포토샵/스캐너)
> - APP14가 **없으면** 인버전은 **하지 않는** 것이 안전(필요 시 **강제토글** 제공)

---

## 구현 개요

- **저수준 JPEG IO**: libjpeg(-turbo)
- **마커 저장**: `jpeg_save_markers(&cinfo, JPEG_APP0+14, 0xFFFF)` (APP14 저장)
- **출력 색공간**: YCCK/CMYK이면 `cinfo.out_color_space = JCS_CMYK;`
  - YCCK인 경우 libjpeg가 **YCCK → CMYK** 변환 수행(지원됨)
- **스캔라인 읽기(4채널)** → (필요 시 **인버전**) → **CMYK→RGB** → BGRA로 포장

---

## 코드 — Adobe APP14 파싱 + YCCK/CMYK 전처리 + BGRA 출력

### 헤더 (유틸 선언)

```cpp
// CmykJpegUtil.hpp
#pragma once
#include <vector>
#include <string>
#include <cstdint>
#include <jpeglib.h>
#include "IppDib.h"

struct AdobeAPP14 {
    bool   present = false;
    int    version = 0;
    int    flags0  = 0;
    int    flags1  = 0;
    int    transform = -1; // 0:Unknown(CMYK), 1:YCbCr, 2:YCCK
};

// APP14 저장 활성화
inline void EnableSaveAdobeAPP14(j_decompress_ptr cinfo){
    jpeg_save_markers(cinfo, JPEG_APP0 + 14, 0xFFFF);
}

// APP14("Adobe") 파싱
bool ParseAdobeAPP14(j_decompress_ptr cinfo, AdobeAPP14& out);

// CMYK 채널 인버전(제자리)
inline void InvertCMYKRow(uint8_t* rowCMYK, int width){
    for (int x=0;x<width;++x){
        rowCMYK[x*4+0] = 255 - rowCMYK[x*4+0]; // C
        rowCMYK[x*4+1] = 255 - rowCMYK[x*4+1]; // M
        rowCMYK[x*4+2] = 255 - rowCMYK[x*4+2]; // Y
        rowCMYK[x*4+3] = 255 - rowCMYK[x*4+3]; // K
    }
}

// CMYK → BGRA(단순 모델)
inline void CMYKtoBGRA_Row(const uint8_t* cmyk, uint8_t* bgra, int width){
    for (int x=0;x<width;++x){
        uint8_t C=cmyk[x*4+0], M=cmyk[x*4+1], Y=cmyk[x*4+2], K=cmyk[x*4+3];
        uint8_t R = 255 - (uint8_t)std::min(255, (int)C + (int)K);
        uint8_t G = 255 - (uint8_t)std::min(255, (int)M + (int)K);
        uint8_t B = 255 - (uint8_t)std::min(255, (int)Y + (int)K);
        bgra[x*4+0]=B; bgra[x*4+1]=G; bgra[x*4+2]=R; bgra[x*4+3]=255;
    }
}

// 메인: JPEG(CMYK/YCCK 포함) → IppDib(BGRA32) 로드
bool LoadJpeg_CMYK_Aware(const std::wstring& path, IppDib& out, bool* outWasCMYK=nullptr);
```

### APP14 파싱 구현

```cpp
// CmykJpegUtil.cpp
#include "CmykJpegUtil.hpp"
#include <cstring>
#include <cstdio>

static bool ParseAdobeAPP14Payload(const uint8_t* data, size_t len, AdobeAPP14& out){
    // 최소 길이: "Adobe"(5) + ver(2) + flags0(2) + flags1(2) + transform(1) = 12
    if (len < 12) return false;
    if (std::memcmp(data, "Adobe", 5) != 0) return false;
    out.present = true;
    // Big-endian 2바이트
    auto rd16 = [](const uint8_t* p){ return (int)p[0]*256 + (int)p[1]; };
    out.version   = rd16(data+5);
    out.flags0    = rd16(data+7);
    out.flags1    = rd16(data+9);
    out.transform = (int)data[11];
    return true;
}

bool ParseAdobeAPP14(j_decompress_ptr cinfo, AdobeAPP14& out){
    out = AdobeAPP14{};
    for (jpeg_saved_marker_ptr m = cinfo->marker_list; m; m = m->next){
        if (m->marker == JPEG_APP0 + 14){
            if (ParseAdobeAPP14Payload(m->data, m->data_length, out)){
                return true; // 첫 번째 유효 Adobe APP14만 사용
            }
        }
    }
    return false;
}
```

### 디코드(핵심): CMYK/YCCK → BGRA

```cpp
// CmykJpegUtil.cpp (계속)
#include <vector>

bool LoadJpeg_CMYK_Aware(const std::wstring& path, IppDib& out, bool* outWasCMYK){
    if (outWasCMYK) *outWasCMYK = false;

    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"rb");
    if (!fp) return false;

    jpeg_decompress_struct cinfo{}; jpeg_error_mgr jerr{};
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_stdio_src(&cinfo, fp);

    // APP14(Adobe) 저장(== transform 힌트 확보)
    EnableSaveAdobeAPP14(&cinfo);

    if (jpeg_read_header(&cinfo, TRUE) != JPEG_HEADER_OK){
        jpeg_destroy_decompress(&cinfo); fclose(fp); return false;
    }

    // 입력 JPEG 색공간 파악
    bool jpegIsYCCK = (cinfo.jpeg_color_space == JCS_YCCK);
    bool jpegIsCMYK = (cinfo.jpeg_color_space == JCS_CMYK);

    AdobeAPP14 adobe{};
    ParseAdobeAPP14(&cinfo, adobe);

    if (jpegIsYCCK || jpegIsCMYK){
        // 4채널로 출력
        cinfo.out_color_space = JCS_CMYK; // YCCK이면 내부에서 CMYK로 변환됨
    }else{
        cinfo.out_color_space = JCS_RGB;  // 일반 RGB 경로
    }

    jpeg_start_decompress(&cinfo);

    const int W=cinfo.output_width;
    const int H=cinfo.output_height;
    const int C=cinfo.output_components; // 3 or 4

    if (C == 4){
        if (outWasCMYK) *outWasCMYK = true;
        out.create(W, H, 32);

        std::vector<uint8_t> rowCMYK(W*4);
        while (cinfo.output_scanline < cinfo.output_height){
            JSAMPROW rp = rowCMYK.data();
            jpeg_read_scanlines(&cinfo, &rp, 1);

            // 인버전 여부 결정
            // - transform==2 (YCCK): 일반적으로 invert 필요
            // - transform==0 (CMYK): 포토샵/스캐너 계열에서 invert 필요 사례 다수
            bool needInvert = false;
            if (adobe.present){
                if (adobe.transform == 2) needInvert = true;       // YCCK
                else if (adobe.transform == 0 && jpegIsCMYK) needInvert = true; // CMYK with Adobe tag
            }
            // (APP14 없으면 기본은 invert 안함. 옵션으로 강제 invert 토글을 제공해도 좋음)

            if (needInvert) InvertCMYKRow(rowCMYK.data(), W);

            // CMYK → BGRA
            uint8_t* dst = (uint8_t*)out.bits() + (size_t)(cinfo.output_scanline-1)*out.stride();
            CMYKtoBGRA_Row(rowCMYK.data(), dst, W);
        }
    }else if (C == 3){
        // 일반 RGB
        out.create(W, H, 32);
        std::vector<uint8_t> rowRGB(W*3);
        while (cinfo.output_scanline < cinfo.output_height){
            JSAMPROW rp=rowRGB.data();
            jpeg_read_scanlines(&cinfo, &rp, 1);
            uint8_t* dst=(uint8_t*)out.bits() + (size_t)(cinfo.output_scanline-1)*out.stride();
            for (int x=0;x<W;++x){
                uint8_t R=rowRGB[x*3+0], G=rowRGB[x*3+1], B=rowRGB[x*3+2];
                dst[x*4+0]=B; dst[x*4+1]=G; dst[x*4+2]=R; dst[x*4+3]=255;
            }
        }
    }else if (C == 1){
        // 그레이스케일
        out.create(W, H, 32);
        std::vector<uint8_t> rowG(W);
        while (cinfo.output_scanline < cinfo.output_height){
            JSAMPROW rp=rowG.data();
            jpeg_read_scanlines(&cinfo, &rp, 1);
            uint8_t* dst=(uint8_t*)out.bits() + (size_t)(cinfo.output_scanline-1)*out.stride();
            for (int x=0;x<W;++x){
                uint8_t g=rowG[x];
                dst[x*4+0]=g; dst[x*4+1]=g; dst[x*4+2]=g; dst[x*4+3]=255;
            }
        }
    }else{
        // 예외: 2,5 등 비정상
        jpeg_finish_decompress(&cinfo);
        jpeg_destroy_decompress(&cinfo);
        fclose(fp);
        return false;
    }

    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);
    fclose(fp);
    return true;
}
```

> **참고**
> - **YCCK**인 경우 `out_color_space = JCS_CMYK`로 지정하면 libjpeg이 YCCK→CMYK 변환을 내부에서 수행합니다.
> - 색 정확도가 매우 중요한 경우(인쇄 프루핑 등)는 **ICC(색관리)** 경로(아래 §6)를 사용하세요.

---

## 수학 — 단순 CMYK→RGB 변환식 (표시용)

픽셀 단위(8비트 정수, 0..255 스케일):

- (필요 시) **인버전**: \( C' = 255 - C, M' = 255 - M, Y' = 255 - Y, K' = 255 - K \)
- **감산 모델 근사**:
\[
\begin{aligned}
R &= 255 - \min(255, C' + K') \\
G &= 255 - \min(255, M' + K') \\
B &= 255 - \min(255, Y' + K')
\end{aligned}
\]
위 식은 UCR/GCR, 점확산(dot gain), 프로파일 특성은 무시한 **간단한 표시 모델**입니다.
실제 인쇄 시뮬레이션/정밀 컬러는 아래 **ICC 변환**을 쓰세요.

---

## (선택) ICC 기반 **정밀** CMYK → sRGB 변환 (lcms2)

CMYK JPEG에 **ICC 프로파일**(APP2)이 함께 있을 수 있습니다.
이 경우 **임베디드 CMYK 프로파일 → sRGB** 변환을 **lcms2**로 수행하면
화면 표시가 **정확**해집니다(특히 AdobeRGB/FOGRA/Coated 등).

- YCCK/CMYK → (libjpeg) → **CMYK 8비트 버퍼** 확보
- APP2(ICC) 추출/결합(이전 ICC 파트 코드 참고)
- `cmsCreateTransform(srcICC, TYPE_CMYK_8, sRGB, TYPE_BGRA_8, intent, flags)`
- **주의**: ICC 변환은 보통 **인버전 없는 CMYK**를 가정합니다.
  - Adobe APP14로 인버전이 필요한 경우 **먼저 인버전 적용 후** ICC 변환을 수행하세요.

---

## UI/옵션 설계 제안 (실전)

- **해석 모드**:
  - **Auto**(기본): APP14의 transform 기반
    - transform==2(YCCK) → invert
    - transform==0(CMYK) → invert
    - else/no APP14 → no invert
  - **Force Invert**: 항상 인버전
  - **Force Non-Invert**: 항상 비인버전
- **색관리**:
  - ICC가 있으면 **“ICC 사용(sRGB 변환)”** 체크(기본 켜기)
  - 없으면 **sRGB 가정**
- **진단 표시**: 상태바/로그에 `jpeg_color_space`, `adobe.transform`, `invert yes/no`, `icc present yes/no` 출력

---

## 상황별 예제

### A) 포토샵에서 저장한 **YCCK** JPEG (색이 시커멓게 보임)

- 증상: 일반 RGB 디코드 경로로 열면 **검게/이상**
- 조치: 위 `LoadJpeg_CMYK_Aware` 로 로드
  - `jpeg_color_space=JCS_YCCK` → `out_color_space=JCS_CMYK`
  - APP14.transform=**2** → **인버트 적용**
  - CMYK→BGRA 변환 후 정상 표시
- (선택) ICC가 있으면 sRGB 변환 경로 사용

### B) 스캐너가 만든 **CMYK** JPEG (Adobe APP14 있음)

- APP14.transform=**0** (Unknown) → **인버전 적용**
- 인버전 후 CMYK→BGRA 변환 → 색감 정상화

### C) **CMYK** JPEG (APP14 없음)

- 기본은 **인버전 미적용**
- 화면이 어색하면, “**Force Invert**” 옵션으로 재로드하여 비교

---

## 저장(Export) 정책

- **표시용 BGRA**를 JPEG로 다시 저장할 땐 보통 **RGB(sRGB)** 로 내보냅니다.
  - CMYK로 **다시 저장**해야 한다면(인쇄 워크플로), CMYK ICC/프로파일을 갖춘 별도 인코더 경로 필요(일반 뷰어/웹 호환성은 떨어짐).
- 메타데이터(ICC/EXIF/XMP)는 필요 시 **재주입**(앞선 EXIF/ICC 편 참조).
- EXIF Orientation은 **픽셀 반영 후** 저장 시 **1로 패치** 권장(이중 회전 방지).

---

## 견고성 체크리스트

- [ ] `jpeg_save_markers(APP14)` 를 **read_header 이전**에 호출
- [ ] **APP14 페이로드 검증**(길이/시그니처/transform 범위)
- [ ] `jpeg_color_space`가 **JCS_YCCK/JCS_CMYK** 일 때만 `out_color_space=JCS_CMYK`
- [ ] **인버전 조건**: `transform==2`(YCCK) or `transform==0`(CMYK) → invert
- [ ] APP14 미존재 시 **no invert**(토글 제공)
- [ ] **ICC가 있으면**: 인버전 후 ICC 변환(lcms2), 실패 시 단순 모델 fallback
- [ ] 대용량 이미지에 대해 **행 단위 처리**(현재 코드 OK), 필요 시 멀티스레드

---

## 전체 사용 흐름(샘플)

```cpp
IppDib dib;
bool wasCMYK=false;
if (!LoadJpeg_CMYK_Aware(L"input_cmyk_or_ycck.jpg", dib, &wasCMYK)){
    // 오류 처리
}
// dib는 BGRA32 → 그대로 GDI/MFC로 화면 출력
// 저장은 RGB JPEG(sRGB) 권장
// SaveJpegWithMetadata(dib, L"out.jpg", 90, ...);
```

---

## 자주 묻는 질문 (FAQ)

**Q. 왜 어떤 CMYK는 인버전이 필요하고 어떤 건 아닌가요?**
A. 역사적/도구별 관행 차이입니다. **Adobe APP14 transform**이 그 힌트를 주며,
`transform==2(YCCK)`는 거의 항상 인버전이 필요합니다. `transform==0(CMYK)` 도 인버전되는 경우가 많습니다.

**Q. 단순 모델(C+K 등)로 충분한가요?**
A. 화면 표시에는 충분한 경우가 많지만, **색 정확도**가 중요하면 **ICC 경로**(lcms2)를 사용하세요.

**Q. YCCK → CMYK 변환은 누가 하나요?**
A. libjpeg(-turbo)가 `out_color_space = JCS_CMYK`일 때 내부에서 수행합니다.

**Q. APP14가 없고 색이 뒤집힌 것 같습니다.**
A. **Force Invert** 옵션으로 재로드하여 비교하세요. UI에 토글을 제공하는 것이 실무적으로 안전합니다.

---

## 결론

- **CMYK/YCCK JPEG** 대응의 핵심은 **APP14(Adobe) transform 파싱 + 올바른 인버전 적용 + CMYK→RGB 변환**입니다.
- 위 예제는 **간단·안전**한 기본 해석을 구현합니다.
- **정확 색**이 필요하면 **ICC 변환(lcms2)** 를 더해 품질을 끌어올리세요.
