---
layout: post
title: 정보보안기사 - 스니핑 공격
date: 2025-11-09 18:25:23 +0900
category: 정보보안기사
---
# SECTION 04 네트워크 기본 학습 — 10. 스니핑(Sniffing) 공격

## 1. 개요 — 스니핑이란 무엇인가

- **정의**: 네트워크 상에서 흐르는 **패킷을 수집·열람·분석**하는 행위. 도구(패킷 캡처러/프로토콜 해석기)와 **획득 경로(패시브/액티브)**가 핵심.
- **공격 관점**:
  - **패시브(passive)**: 트래픽 흐름을 **변조하지 않고** 관찰(허브, 미러 포트, 무선 모니터 모드, 이미 확보한 TAP 등).
  - **액티브(active)**: 트래픽을 **자기 쪽으로 유도**(예: ARP 스푸핑, DHCP 스푸핑, STP/루트 가로채기, CAM 테이블 오버플로우, DNS 가로채기 등).
- **주요 표적**: 평문 프로토콜(HTTP, Telnet, FTP, POP3/IMAP/SMTP-plaintext, SNMPv1/v2c), 인증 토큰/세션 쿠키, 내부 식별자(사내 시스템명·IP·도메인), 메타데이터(누가/언제/어디와 통신했는지).
- **수비 관점 핵심**:
  1) **엔드-투-엔드 암호화** 강제(TLS, SSH, SNMPv3, WPA3/802.1X).
  2) **L2 보호**(DHCP Snooping, Dynamic ARP Inspection, Port Security, BPDU Guard/Root Guard).
  3) **가시성/탐지**(Zeek/Suricata, NetFlow/IPFIX, ARP 이상 탐지).
  4) **분할/격리**(VLAN, 프라이빗 VLAN, ACL, 프록시/게이트웨이 통제).

---

## 2. 위협 모델 — 어디서 어떻게 패킷을 얻는가

### 2.1 패시브 스니핑(흐름 불변)

| 경로 | 방법 | 장점 | 한계/대응 |
|---|---|---|---|
| **허브/리피터** | 모든 프레임이 브로드캐스트 | 간단 | 현대엔 거의 사용 X |
| **스위치 SPAN/미러 포트** | 포트/ VLAN 트래픽 복제 | 정밀 분석 | 권한 통제 필요, 대역폭 주의 |
| **네트워크 TAP** | 인라인 광/동선 분기 | 안정/무영향 | 비용/설치 필요 |
| **무선 모니터 모드** | 802.11 관리/데이터 프레임 | 공간적 자유 | 암호화/PMF 적용 시 난이도↑ |
| **호스트 로컬** | 자체 NIC의 RX/TX | 앱별 문제 분석 | 로컬만 관찰 |

### 2.2 액티브 스니핑(트래픽 유도)

| 기법 | 개념 | 위험·탐지 포인트 | 방어 |
|---|---|---|---|
| **ARP 스푸핑** | 가짜 ARP Reply로 게이트웨이/피어의 MAC 매핑 왜곡 | ARP Reply 폭증, 게이트웨이 MAC 변동 | **DHCP Snooping + DAI**, 정적 ARP(선별), 802.1X |
| **DHCP 스푸핑(로그 DHCP)** | 가짜 DHCP 서버로 게이트웨이/DNS 조작 | 다중 DHCP Offer, 임대 정보 이상 | **DHCP Snooping** |
| **DNS 가로채기** | 로컬 리졸버/프록시로 유도 | 쿼리/응답 상이, TTL 비정상 | 내부 DNS 고정/DoT/DoH 정책 |
| **CAM 오버플로우(스위치 메모리 가득)** | 스위치가 MAC 학습 불가→플러딩 | MAC 학습 실패, 브로드캐스트 급증 | **Port Security**, 스톰 제어 |
| **STP 루트 가로채기** | 낮은 브릿지 우선순위로 루트 브릿지 가장 | Topology 변경 로그, 루프 위험 | **Root Guard/BPDU Guard** |
| **VLAN 이중태깅/트렁크 오용** | 태그 조작으로 이웃 VLAN 접근 | 이례적 태그, Native VLAN 남용 | Native VLAN 격리, 포트 모드 고정 |

---

## 3. 필수 도구·명령 — 수집·보기·요약

### 3.1 패킷 캡처

```bash
# Linux/Unix: tcpdump
sudo tcpdump -i any -w sniff.pcap
sudo tcpdump -nni eth0 "tcp port 80 or tcp port 21 or tcp port 110"
sudo tcpdump -nni any "arp or (icmp and icmp[0]==3 and icmp[1]==4)"  # ARP/PMTUD 관측

# 텍스트 분석: tshark
tshark -r sniff.pcap -Y "http.request" -T fields -e frame.time -e ip.src -e http.host -e http.request.uri | head

# Windows: pktmon (내장)
pktmon start --etw -p 0
timeout /t 10
pktmon stop
pktmon format PktMon.etl -o sniff.pcapng
```

### 3.2 프로토콜 해석/요약

```bash
# Zeek(구 Bro): HTTP 로그 추출
zeek -r sniff.pcap
head -n 5 http.log
# Suricata: 룰 기반 탐지 + eve.json
suricata -r sniff.pcap -l out/
jq '.event_type' out/eve.json | head
```

### 3.3 현황 파악

```bash
# 소켓/세션
ss -tulpn
# ARP/NDP 캐시
ip neigh
# 인터페이스 플래그(프로미스큐어스 여부 포함)
ip link show | grep -E "PROMISC|LOWER_UP"
```

---

## 4. (수비 중심) 실습 랩 — 네임스페이스 기반 “안전 캡처”

> 아래는 **한 대의 Linux**에서 **세 개의 네임스페이스**(hostA, hostB, gw)를 만들어 **자기 트래픽만** 실험하는 절차다. 외부 네트워크에는 영향이 없다.

### 4.1 토폴로지

```
[hostA] vethA <-> (A)      (G) <-> vethB [hostB]
                 \        /
                  \      /
                 10.0.0.1/24 (gw namespace, 가상 라우터)
```

### 4.2 구성 스크립트

```bash
#!/usr/bin/env bash
set -e
ip netns add hostA
ip netns add hostB
ip netns add gw

ip link add vethA type veth peer name vethA_gw
ip link add vethB type veth peer name vethB_gw

ip link set vethA netns hostA
ip link set vethB netns hostB
ip link set vethA_gw netns gw
ip link set vethB_gw netns gw

ip netns exec hostA ip addr add 10.0.0.10/24 dev vethA
ip netns exec hostB ip addr add 10.0.0.20/24 dev vethB
ip netns exec gw    ip addr add 10.0.0.1/24  dev vethA_gw
ip netns exec gw    ip addr add 10.0.0.1/24  dev vethB_gw

ip netns exec hostA ip link set vethA up
ip netns exec hostB ip link set vethB up
ip netns exec gw    ip link set vethA_gw up
ip netns exec gw    ip link set vethB_gw up
ip netns exec gw    sysctl -w net.ipv4.ip_forward=1 >/dev/null

ip netns exec hostA ip route add default via 10.0.0.1
ip netns exec hostB ip route add default via 10.0.0.1

echo "[+] ping test"
ip netns exec hostA ping -c 2 10.0.0.20
```

### 4.3 **패시브 캡처**(자기 인터페이스만)

```bash
# hostA에서 hostB로 HTTP처럼 보이는 트래픽 전송(단순 텍스트)
ip netns exec hostB ncat -l 8080 > /tmp/recv.txt &
sleep 1
ip netns exec hostA bash -lc 'echo "GET / HTTP/1.1\r\nHost: b\r\n\r\n" | ncat 10.0.0.20 8080'

# hostA 네임스페이스에서 자체 캡처
ip netns exec hostA tcpdump -nni vethA -A -c 10 'tcp port 8080'
```

> 이렇게 **본인이 소유한 트래픽만 캡처**하여 **도구 사용법과 디코딩 절차**를 익힌다.

---

## 5. 액티브 스니핑 기법 — 개념·탐지·대응 (공격 절차 자체는 불제공)

> 아래 내용은 **이해·탐지·대응**을 위한 **개념 설명**에 국한한다. 실제 공격명령·스텝바이스텝은 제공하지 않는다.

### 5.1 ARP 스푸핑(개념)

- **원리**: 공격자가 “게이트웨이는 내 MAC” 또는 “피어는 내 MAC”이라는 **거짓 ARP 응답**을 뿌려 **중간자(MITM)**가 된다.
- **탐지 지표**
  - 동일 IP에 대해 **MAC 매핑이 빈번히 바뀜**
  - **Gratuitous ARP**/ARP Reply 빈발, 다량의 ARP 트래픽
  - GW MAC이 벤더 OUI와 불일치
- **대응**
  - 스위치 **DHCP Snooping + DAI(Dynamic ARP Inspection)**
  - 서버/보안구간에 한해 **정적 ARP**(운영·확장성 고려)
  - **802.1X**(EAP-TLS)로 포트 액세스 제어

**호스트 기반 간이 탐지 예(Python/Scapy)**

```python
# arp_watch.py — 게이트웨이 IP의 MAC이 변하면 경고
from scapy.all import sniff, ARP
GATEWAY_IP = "10.0.0.1"
gw_mac = None

def cb(pkt):
    global gw_mac
    if pkt.haslayer(ARP) and pkt[ARP].op in (1,2):  # who-has/is-at
        ip = pkt[ARP].psrc
        mac = pkt[ARP].hwsrc
        if ip == GATEWAY_IP:
            if gw_mac is None:
                gw_mac = mac
                print(f"[INIT] GW {ip} -> {mac}")
            elif gw_mac != mac:
                print(f"[ALERT] GW MAC changed: {gw_mac} -> {mac} from {pkt.src}")

sniff(filter="arp", prn=cb, store=0)
```

> 방어 도구(예: `arpwatch`)도 유사한 원리로 경고를 발생한다.

### 5.2 DHCP 스푸핑(개념)

- **원리**: 가짜 DHCP 서버가 **게이트웨이/DNS** 옵션을 공격자 소유로 제공 → 트래픽 유도.
- **탐지**: 짧은 시간 내 **서로 다른 서버의 DHCP Offer** 다발, 임대 정보 갑작스런 변경.
- **대응**: **DHCP Snooping**(신뢰 포트만 DHCP 서버 허용), IP Source Guard.

### 5.3 CAM 오버플로우·STP 루트 가로채기(개념)

- **CAM 오버플로우**: 수천 개의 가짜 MAC을 학습시키면 스위치가 **플러딩** → 타 포트 트래픽도 관측 가능.
  방어: **Port Security(MAC 수 제한)**, 스톰 컨트롤.
- **STP 루트 가로채기**: 낮은 브리지 우선순위 광고로 루트 브리지 탈취.
  방어: **Root Guard**, **BPDU Guard**, 관리 포트만 트렁크.

### 5.4 무선(802.11) 스니핑(개념)

- **모니터 모드**: 관리/데이터 프레임 수집, 개방망 평문 수집 가능.
- **WPA2-PSK**: 4-way 핸드셰이크 캡처 후 오프라인 사전대입 위험(약한 패스프레이즈 시).
- **WPA3/SAE**: 오프라인 추측 내성↑, **PMF(Protected Management Frames)**로 디어스/디스어소시에이션 보호.
- 방어: **WPA3 + PMF**, **802.1X(EAP-TLS)**, 강한 길이/복잡도, **게스트 VLAN 분리**.

---

## 6. 무엇이 노출되는가 — 평문과 메타데이터

| 계층 | 예시 | 스니핑 결과(평문일 때) | 완화 |
|---|---|---|---|
| 애플리케이션 | HTTP/Telnet/FTP/SMTP-plain/POP3/IMAP | 자격증명, 쿠키, 요청/응답 | **TLS/SSH**, HSTS, SMTP MTA-STS |
| 전송 | TCP/UDP | 포트·세션 메타, 일부 평문 프로토콜 | 필요 시 DTLS/QUIC |
| 네임서비스 | DNS | 요청 도메인, 분류/추적 | **DoT/DoH**, 내부 DNS 정책 |
| 관리 | SNMPv1/v2c | 커뮤니티 문자열, MIB 값 | **SNMPv3**, 접근통제 |
| 무선 | 802.11 관리 프레임 | SSID, 비콘, 프로브 | **PMF**, SSID 관리 |

---

## 7. 가시성·탐지 플레이북

### 7.1 Wireshark/tshark 디스플레이 필터

```text
arp
arp.opcode == 2 && arp.src.proto_ipv4 == 10.0.0.1            # GW is-at 감시
bootp || dhcp                                                # DHCP
stp || rstp                                                  # STP/BPDU
dns && ip.dst != local_dns                                   # 외부 DNS로 샌딩
http.request || http.response                                # 평문 HTTP
wlan.fc.type_subtype == 0x0c || 0x0a                         # deauth/disassoc
```

### 7.2 NetFlow/IPFIX 징후

- 단기간 **ARP/브로드캐스트** 급증(센서가 L2 집계 지원 시),
- **DNS 요청 분산 패턴 변화**(내부 리졸버 우회),
- **새로운 이그레스 경로**로의 HTTP/HTTPS 집중(의심 프록시).

### 7.3 Zeek 정책 예(ARP 매핑 불일치 경고 — 개념 스케치)

```zeek
# notice-policy.zeek (개념 스케치)
@load base/protocols/arp
event arp_reply(c: connection, spa: addr, sha: string, tpa: addr, tha: string) {
    # spa(Source Protocol Address: IP) -> sha(Source Hardware/MAC)
    # 상태 저장 후 불일치 감지시 Notice
}
```

---

## 8. 하드닝 체크리스트 — 스위치/라우터/무선/호스트

### 8.1 L2/L3 장비

- [ ] **DHCP Snooping** 활성(신뢰 포트만 서버 허용, 바인딩 DB 유지)
- [ ] **Dynamic ARP Inspection(DAI)** + **IP Source Guard**
- [ ] **Port Security**(MAC 수 제한, sticky MAC, 위반 시 shut/일시차단)
- [ ] **BPDU Guard/Root Guard**(엣지 포트 보호), **Storm Control**
- [ ] **Native VLAN 비사용** 또는 전용 격리, 트렁크 최소화
- [ ] **프라이빗 VLAN/ACL**로 L2 동평면 최소화
- [ ] **가시성**: SPAN/TAP 계획 + 수집기(Zeek/Suricata)

### 8.2 무선

- [ ] **WPA3-Personal**(가능하면 **WPA3-Enterprise + 802.1X/EAP-TLS**)
- [ ] **PMF 필수**(Deauth/Disassoc 보호)
- [ ] **게스트/IoT VLAN 분리**, L3 방화벽 정책
- [ ] WIPS(Wireless IPS)로 Rogue AP/에빅션 탐지

### 8.3 호스트/서버

- [ ] **전 구간 TLS/SSH**(HSTS, SMTP MTA-STS, DNS-over-TLS/DoH 정책화)
- [ ] **SNMPv3**로 전환(legacy read-only v1/v2c 제거)
- [ ] **정적 ARP**(선별적 적용; 관리망·핵심 GW)
- [ ] 인증서 검증/핀(중요 클라이언트), 세션 쿠키 `Secure`/`HttpOnly`/`SameSite`
- [ ] **EDR/호스트 방화벽**: 비정상 ARP/미승인 스니퍼 탐지 룰

---

## 9. 사고 대응(IOC) — 의심 시 단계

1) **증상 수집**: 사용자 “웹 느림/간헐 끊김/인증 실패”, 모니터링 알림(ARP 급증, DHCP 다중 Offer).
2) **현장 확인**: 스위치 포트 **MAC 학습 수**·BPDU 로그·DHCP Snooping 카운터.
3) **패킷 증거**: SPAN으로 **ARP Reply 폭주**, GW MAC 변동, DHCP Offer 다중.
4) **격리**: 의심 포트 shutdown, **포트 보안 위반** 처리, Rogue 기기 밀봉.
5) **영향평가**: 평문 트래픽 노출 범위, 비인가 DNS/프록시로의 이동 확인.
6) **근절/복구**: 네트워크 하드닝(§8), 자격증명 교체, TLS 강제, 사용자 공지.
7) **사후학습**: 룰/대시보드 보강(ARP/ DHCP/ STP 이벤트), 핸즈온 교육.

---

## 10. 실습: “탐지 우선” 미니 랩 3종

> 모두 **본인 랩**에서만. 액티브 공격 재현은 **명시적으로 제외**하고, **탐지/대응 절차**만 연습한다.

### 10.1 ARP 매핑 변동 감시

```bash
# (네임스페이스 hostA)
ip netns exec hostA bash -lc 'ip -o neigh show dev vethA; watch -n1 "ip neigh show dev vethA"'
# 게이트웨이 MAC이 변하는지 관찰(정상 상황에선 변동 거의 없음)
```

### 10.2 DHCP 이상 탐지(다중 Offer)

```bash
# 캡처 후 필터링
tcpdump -i any -w dhcp.pcap 'port 67 or port 68' -G 30 -W 1
tshark -r dhcp.pcap -Y "bootp.option.type==53 && bootp.option.value==2" -T fields -e ip.src | sort | uniq -c
# 서로 다른 소스 IP 다중 Offer -> 의심
```

### 10.3 무선(개념) — 관리 프레임 이벤트 모니터

> 실제 무선 캡처는 **모니터 모드 지원** 장비와 **독립된 테스트 AP** 필요. 운영 WLAN에서 무단 캡처 금지.

---

## 11. 수식 한 줄 — 토큰 버킷으로 브로드캐스트 제어 직관

스니핑은 **브로드캐스트/플러딩**이 많을수록 유리하다. 스위치의 스톰 제어는 토큰 버킷으로 구현되는 경우가 많다.

- 버킷 용량을 \(B\), 리필률을 \(r\), 시간 \(t\)라 하면 특정 인터벌에 허용되는 브로드캐스트 총량은
$$
\text{allowed}(t) \le r \cdot t + B.
$$
- **r·t + B**를 넘는 브로드캐스트는 **드롭**되어 플러딩 기반 스니핑이 어려워진다.

---

## 12. 표 — 스니핑 위험·탐지·대응 요약

| 범주 | 위험 | 즉시 탐지 포인트 | 장기 대응 |
|---|---|---|---|
| ARP | GW MAC 변조로 MITM | ARP Reply 폭증, GW MAC 변경 | DHCP Snooping+DAI, 802.1X |
| DHCP | 가짜 게이트웨이/DNS | Offer 다중, 임대 변경 | DHCP Snooping, IP Source Guard |
| DNS | 가짜 리졸버로 유도 | 외부 DoH/DoT 트래픽 급증 | 내부 DNS 강제/프록시 |
| CAM | 플러딩으로 스니핑 | MAC 학습 실패/브로드캐스트↑ | Port Security, 스톰 제어 |
| STP | 루트 탈취/루프 | Topology Change 잦음 | BPDU/Root Guard |
| 무선 | 평문/핸드셰이크 | mgmt frame 이벤트 | WPA3/PMF/802.1X |

---

## 13. 흔한 면접/필답 포인트(예상 문제)

1) **패시브 vs 액티브 스니핑** 차이를 정의하고 각각 2가지 예를 들어라.
2) **ARP 스푸핑**이 어떻게 MITM을 가능하게 하는지 설명하고, **DAI**의 작동 원리를 서술하라.
3) 스위치에서 **CAM 테이블 오버플로우**를 방지하는 **Port Security** 설정의 핵심 파라미터 3가지를 써라.
4) 무선 환경에서 스니핑 위험을 줄이기 위한 **WPA3/PMF**의 역할을 요약하라.
5) 운영망에서 **PMTUD/ICMP 차단**이 스니핑 탐지/트러블슈팅에 주는 부작용을 설명하라.
6) **NetFlow/IPFIX**와 **패킷 캡처**의 역할 차이와 상호보완 관계를 기술하라.
7) **SNMPv1/v2c → v3** 전환이 스니핑 위험을 어떻게 낮추는지 설명하라.

---

## 14. 운영 체크리스트

- [ ] **암호화 강제**: HTTP→HTTPS(HSTS), Telnet/FTP→SSH/SFTP, SNMPv3, DB TLS
- [ ] **스위치 보안**: DHCP Snooping/DAI/Port Security/BPDU·Root Guard/Storm Control
- [ ] **분리**: VLAN·프라이빗 VLAN·ACL, 게스트·IoT 분리
- [ ] **무선 보안**: WPA3(+PMF), 802.1X(EAP-TLS), Rogue AP 탐지
- [ ] **가시성**: SPAN/TAP 계획, NetFlow, Zeek/Suricata 룰
- [ ] **호스트**: 정적 ARP(핵심망), 인증서 검증/핀, EDR로 스니퍼 탐지
- [ ] **정책**: 외부 DoH/프록시 우회 차단, SSL 인스펙션 범위·예외 관리
- [ ] **훈련**: 개발/운영 대상 평문 프로토콜 점검 캠페인, 핸즈온 랩

---

## 15. 참고 스니펫 모음

### 15.1 tcpdump 필터 모음

```bash
# 평문 자격증명 의심
tcpdump -nni any "tcp port 23 or port 21 or port 110 or port 143"

# ARP/GARP 폭주
tcpdump -nni any "arp and arp[6:2] = 2"

# DHCP
tcpdump -nni any "port 67 or port 68"

# STP/BPDU
tcpdump -nni any "ether proto 0x8100 or ether proto 0x0026"
```

### 15.2 PowerShell — 포트 개방/경로·TLS 헬스

```powershell
# 단순 포트/경로
Test-NetConnection example.com -Port 443 -TraceRoute -InformationLevel Detailed

# 인증서/ALPN 확인(서버 이름 표시)
# (OpenSSL이 더 상세하나 Windows 환경 기본 점검 예시)
```

---

## 16. 결론

- 스니핑은 **획득 경로(패시브/액티브)**와 **평문/메타데이터 노출**에 의존한다.
- **암호화 기본기 + L2 보호** 없이는 어느 환경도 안전하지 않다.
- 운영자는 **실습 랩**으로 도구 숙련도를 올리고, 실제 환경에서는 **탐지·대응·하드닝 루틴**(본 문서 체크리스트)을 표준화해야 한다.

---
```python
# 부록(옵션) — 간단 HTTP 요약기(본인 pcap만)
# tshark가 추출한 필드를 Python으로 가공하는 샘플. 외부망/제3자 트래픽은 취급 금지.
import csv, sys, subprocess
pcap = sys.argv[1]
cmd = ["tshark","-r",pcap,"-Y","http.request","-T","fields","-e","frame.time","-e","ip.src","-e","http.host","-e","http.request.method","-e","http.request.uri"]
out = subprocess.check_output(cmd, text=True).splitlines()
w = csv.writer(sys.stdout)
w.writerow(["time","src","host","method","uri"])
for line in out:
    cols = [c if c else "-" for c in line.split("\t")]
    w.writerow(cols)
```
