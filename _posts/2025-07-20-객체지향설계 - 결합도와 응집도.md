---
layout: post
title: 객체지향설계 - 결합도와 응집도
date: 2025-07-20 19:20:23 +0900
category: 객체지향설계
---
# 결합도(Coupling)와 응집도(Cohesion)

## 0. 한눈에 개요

- **목표 품질 상태**: **낮은 결합도**(모듈 간 의존 최소) + **높은 응집도**(모듈 내부 목적 단일)
- **효과**: 변경 파급 최소화, 재사용성·테스트 용이성 향상, 기능 추가의 국소화
- **핵심 기술**: 인터페이스/포트(추상화), 의존성 주입(DI), 이벤트/메시징, 도메인 분리(경계 설정), 상태/계약(불변식) 모델링

---

## 1. 결합도(Coupling)

### 1.1 정의
**결합도**는 한 모듈이 다른 모듈의 존재·구현·데이터 형태·실행 순서에 **얼마나 강하게 의존하는지**를 나타낸다. 낮을수록 변경 파급이 작다.

### 1.2 결합도의 효과
- **높은 결합도**: 변경 전파, 재사용성 하락, 테스트 어려움(대역/스텁 준비 비용↑)
- **낮은 결합도**: 기능 추가의 **국소화**, 독립 배포·테스트 가능, 팀 간 **병렬 작업성**↑

### 1.3 결합도 분류(약→강)
| 레벨 | 이름 | 설명 | 흔한 징후 | 권장 대응 |
|---|---|---|---|---|
| 1 | **데이터 결합** | 필요한 **값만** 파라미터로 전달 | 파라미터 최소, 불변 DTO | 유지 |
| 2 | **스탬프 결합** | 큰 구조(객체/DTO)를 통째로 전달(일부만 사용) | 불필요 필드 의존 | 필드 축소/DTO 세분 |
| 3 | **제어 결합** | 플래그/코드로 **흐름**을 지시 | if(flag)로 분기 | 전략/다형성으로 대체 |
| 4 | **외부 결합** | 파일·프로토콜·포맷 등 외부 계약 공유 | 파싱/포맷 변경 전파 | 안티코럽션/게이트웨이 |
| 5 | **공통 결합** | 전역 상태/싱글턴 공유 | 예측 불가 부수효과 | DI/명시적 의존 주입 |
| 6 | **내용 결합** | 타 모듈 **내부 구현** 접근 | 리플렉션·프렌드·전용 필드 접근 | 경계 재설계(완전 제거) |

#### 코드 예 — 제어 결합 → 다형성
```java
// ❌ 제어 결합: 호출자가 로직 분기까지 지시
class DiscountService {
    int apply(int price, boolean vip) {
        if (vip) return (int)(price * 0.9);
        return price;
    }
}
```
```java
// ✅ 다형성: 분기 제거, 확장 가능(OCP)
interface DiscountPolicy { int apply(int price); }
class VipDiscount implements DiscountPolicy { public int apply(int p){ return (int)(p*0.9);} }
class NoDiscount implements DiscountPolicy { public int apply(int p){ return p; } }

class DiscountService {
    private final DiscountPolicy policy;
    DiscountService(DiscountPolicy policy){ this.policy = policy; }
    int apply(int price){ return policy.apply(price); }
}
```

#### 코드 예 — 스탬프 결합 축소
```java
// ❌ 스탬프 결합: Order 전체를 넘기고 일부 필드만 사용
int calcShippingFee(Order order) { return table.lookup(order.destZip()); }
```
```java
// ✅ 필요한 데이터만 전달(데이터 결합)
int calcShippingFee(ZipCode destZip) { return table.lookup(destZip); }
```

### 1.4 정적·동적·시간적 결합
- **정적 결합**: 컴파일 타임 의존(타입·패키지). → 인터페이스·팩토리로 완화
- **동적 결합**: 런타임 상호작용(네트워크·DB). → 타임아웃/리트라이/폴백/서킷브레이커
- **시간적 결합(Temporal)**: **호출 순서/타이밍** 의존. → 상태머신/불변식/사가(분산 트랜잭션)로 단절

#### 시간적 결합 해소 — 상태 모델링(타입세이프 API)
```java
// 예: 계좌의 '개설→입금→출금→해지' 순서 강제
sealed interface AccountState permits Opened, Closed {}
final class Opened implements AccountState { /* deposit/withdraw 허용 */ }
final class Closed implements AccountState { /* 모든 거래 불가 */ }

final class Account {
    private AccountState state = new Opened();
    void close() { this.state = new Closed(); }
    void withdraw(int amt) {
        if (!(state instanceof Opened)) throw new IllegalStateException("closed");
        // ...
    }
}
```

---

## 2. 응집도(Cohesion)

### 2.1 정의
**응집도**는 한 모듈 내부 요소(데이터·행위)가 **하나의 목적**을 위해 얼마나 밀접히 협력하는지를 나타낸다. 높을수록 이해·변경이 쉽다.

### 2.2 응집도 스펙트럼(낮음→높음)
| 레벨 | 이름 | 설명 | 냄새 | 개선 |
|---|---|---|---|---|
| 1 | **우연적** | 관련 없는 기능 묶음 | 유틸 잡탕 | 역할별 분해 |
| 2 | **논리적** | 유사 성격(로그/검증) 모음 | 거대 스위치 | 전략/핵심별 분리 |
| 3 | **시간적** | 같은 시점에 실행 | init/cleanup 뒤섞임 | 라이프사이클 오브젝트 |
| 4 | **절차적** | 순서 중심 묶음 | 출력-입력 불명확 | 파이프/스텝 명시화 |
| 5 | **통신적** | 같은 데이터 사용 | 공유 데이터 확산 | 데이터 소유권 명확화 |
| 6 | **순차적** | 출력이 다음의 입력 | 긴 체인 | 명시적 파이프라인 |
| 7 | **기능적** | 단 하나의 명확 기능 | 이상적 | 유지 |

#### 코드 예 — 응집도 상승(파이프화)
```java
// ❌ 혼합: 조회/가공/저장/발송 뒤엉킴
void generateReport(){ /* fetch DB */ /* map */ /* pdf */ /* email */ }
```
```java
// ✅ 기능 파이프라인(순차/기능 응집)
ReportData data = fetcher.fetch();
Pdf pdf = generator.generate(data);
store.save(pdf);
notifier.send(pdf);
```

---

## 3. 결합도 vs 응집도 — 상호작용

- **낮은 결합도**는 모듈 간 **자율성**을, **높은 응집도**는 모듈 내부 **명확성**을 키운다.
- 결합도를 낮추면 자연히 **SRP**가 촉진되고, 응집도가 올라가면 **인터페이스(공개 면)**가 줄어든다.

#### 미니 체크
- “이 변경이 **한 파일**에서 끝나는가?” → 응집도 지표
- “새 기능 추가 시 **기존 코드**를 바꾸는가?” → 결합도·OCP 지표

---

## 4. 계측과 품질 지표(팩키지/모듈 수준)

### 4.1 Afferent/Efferent Coupling
- **Ca**: 외부에서 **해당 모듈로 들어오는 의존 수**(책임·안정도)
- **Ce**: 해당 모듈이 **외부에 의존하는 수**(변화 민감도)

### 4.2 불안정도/추상도/거리
$$
I = \frac{C_e}{C_a + C_e},\quad
A = \frac{N_a}{N_c},\quad
D = \left|A + I - 1\right|
$$
- **I**(Instability) 0=안정, 1=불안정
- **A**(Abstractness) 0=구체, 1=추상
- **D**: Main Sequence(`A + I = 1`)로부터 거리(0에 가까울수록 바람직)

> 실무 팁: **경계/포트 패키지**는 I↑A↑ (유연), **도메인 엔티티**는 I↓A↓(안정·구체)

---

## 5. 리팩토링 레시피(결합도↓, 응집도↑)

### 5.1 제어 결합 제거 → 전략/상태/템플릿
- **냄새**: 플래그/타입 코드로 분기
- **행동**: 분기 블록을 **전략 구현체**로 이동

```java
// 템플릿 메서드 예
abstract class ReportJob {
    public final void run(){
        var d = fetch();
        var r = make(d);
        publish(r);
    }
    protected abstract Data fetch();
    protected abstract Report make(Data d);
    protected abstract void publish(Report r);
}
```

### 5.2 스탬프 결합 축소 → DTO 분해/Projection
- 필요한 필드만 가진 **View/DTO** 정의, 파라미터 **좁히기**

### 5.3 공통 결합 제거 → DI/포트-어댑터
- 전역 싱글턴/정적 호출을 **생성자 주입**으로 교체

```java
class UserService {
    private final Mailer mailer; // 인터페이스
    UserService(Mailer mailer){ this.mailer = mailer; }
}
```

### 5.4 외부 결합 완충 → 안티코럽션/게이트웨이
- 외부 시스템 계약을 **게이트웨이**에서 흡수·변환

```java
interface PaymentPort { Receipt pay(Money amount); } // 내부 모델
class ExtPaymentGateway implements PaymentPort { /* 외부 SDK 감싸기 */ }
```

### 5.5 시간적 결합 제거 → 명시적 라이프사이클
- `init()`/`start()`/`stop()`을 **상태 모델**로 강제, 타입으로 제약

### 5.6 응집도 상승 → 기능별 모듈/클래스 분해
- **SRP** 기준으로 역할 분리(도메인 서비스, 어댑터, 애플리케이션 서비스)

---

## 6. 패턴 매핑(문제→해법)

| 문제(냄새) | 결합도/응집도 관점 | 추천 패턴/기법 |
|---|---|---|
| 타입 코드/플래그 분기 | 제어 결합↑ | 전략, 상태, 템플릿 메서드 |
| 전역 설정/싱글턴 | 공통 결합↑ | DI, 컴포지션 루트, 환경 어댑터 |
| 외부 API 변경 전파 | 외부 결합↑ | 포트/어댑터, 안티코럽션 레이어 |
| 다단 체이닝(기차 충돌) | 구현 결합↑ | **디미터 법칙**, Tell-Don't-Ask |
| 큰 DTO 통째 전달 | 스탬프 결합↑ | Projection, 파라미터 축소 |
| 혼합 관심사 클래스 | 응집도↓ | 기능 파이프/모듈 분리, 파사드 |

#### 디미터 법칙 예
```java
// ❌ 기차 충돌
order.customer().address().city().name();

// ✅ Tell-Don't-Ask
order.shipToCityName();
```

---

## 7. 테스트 전략(결합도·응집도 친화)

- **계약 테스트**: 포트/인터페이스의 **행동 계약**을 공유 테스트로 검증
- **대역 사용 최소화**: 내부 순수 로직은 **상태 검증**, 경계는 **계약·통합 테스트**
- **회귀 보호**: 파이프라인·DSL은 **골든 마스터**도 유효
- **성능/격리**: 동적 결합(외부 I/O)은 타임아웃·폴백 포함 테스트

```java
// 계약 테스트 예(공유)
abstract class PaymentPortContract {
    protected abstract PaymentPort sut();
    @org.junit.Test
    public void pay_positive_amount_returns_paid(){
        var r = sut().pay(new Money(1000));
        org.junit.Assert.assertEquals(Status.PAID, r.status());
    }
}
```

---

## 8. 운영 가드레일(런타임 결합 제어)

- **리트라이/백오프/서킷브레이커**(외부 결합)
- **아이도엠포턴시 키/아웃박스 패턴**(메시지 중복·순서)
- **타임박스/데드라인 전파**(시간적 결합 관리)
- **관측 가능성**: 경계 호출에 **상관 ID**와 **지연/실패율** 메트릭

---

## 9. 사례 연구 — 리포트 생성 모듈(초안→개선→이벤트화)

### 9.1 나쁜 예(높은 결합도·낮은 응집도)
```java
class ReportManager {
    public void generateReport() {
        // DB 연결/조회
        // 데이터 가공
        // PDF 생성
        // 이메일 전송
    }
}
```
- DB/PDF/메일과 **내용/외부/제어 결합** 다수
- 단일 메서드에 **다양한 책임** 혼재(응집도↓)

### 9.2 개선(포트/어댑터 + 파이프라인)
```java
interface DataFetcher { ReportData fetch(); }
interface ReportGenerator { Pdf generate(ReportData d); }
interface EmailSender { void send(Pdf pdf); }

class ReportService {
    private final DataFetcher fetcher;
    private final ReportGenerator generator;
    private final EmailSender sender;

    public ReportService(DataFetcher f, ReportGenerator g, EmailSender s){
        this.fetcher=f; this.generator=g; this.sender=s;
    }
    public void process(){
        var data = fetcher.fetch();
        var pdf = generator.generate(data);
        sender.send(pdf);
    }
}
```
- **결합도**: 외부 의존은 인터페이스로 차단(DIP)
- **응집도**: 각 컴포넌트가 **단일 목적**을 수행

### 9.3 확장(이벤트 구독으로 시간적 결합 제거)
```java
interface EventBus { void publish(Object e); void subscribe(Class<?> t, Handler h); }

class ReportServiceV2 {
    private final DataFetcher fetcher;
    private final ReportGenerator generator;
    private final EventBus bus;
    public void process(){
        var data = fetcher.fetch();
        var pdf = generator.generate(data);
        bus.publish(new ReportGenerated(pdf)); // 이메일/보관은 구독자가 처리
    }
}
```
- 생산자/소비자 **비동기 분리** → 실패 격리·재시도 유연

---

## 10. 경계 설정과 도메인 응집

### 10.1 경계·컨텍스트
- **바운디드 컨텍스트**(도메인 주도 설계): 모델·용어·불변식을 **경계 내부**로 응집
- 컨텍스트 간 결합은 **번역/매핑** 계층으로 완충

### 10.2 데이터 소유권
- “누가 이 데이터의 **원천(Truth)** 인가?”를 명확히. 소유자만 갱신, 타자는 조회/캐시

---

## 11. 안티패턴·냄새 카탈로그

| 냄새 | 결합/응집 관점 | 개선 |
|---|---|---|
| Feature Envy(질투) | 메서드가 타 객체 데이터만 만지작 | **Move Method**, 캡슐화 강화 |
| God Object | 우연/논리 응집, 공개면 비대 | 모듈 분리, 파사드로 표면 축소 |
| Train Wreck | 디미터 위반(내용 결합 기폭제) | 질의 대신 명령(Tell-Don't-Ask) |
| Boolean Parameters | 제어 결합 | 다형성, 명명 enum/전략 |
| Static/Global | 공통 결합 | DI/컴포지션 루트 |
| Wide Interface | ISP 위반 | 파셋 인터페이스로 분할 |

---

## 12. 실무 체크리스트(리뷰용)

- **결합도**
  - [ ] 외부 의존은 **포트/인터페이스** 뒤에 감췄는가?
  - [ ] 플래그/타입코드 분기는 **전략/다형성**인가?
  - [ ] 전역/싱글턴 대신 **주입**하는가?
  - [ ] 외부 계약 변화가 내부에 **전파되지 않도록** 게이트웨이가 있는가?
  - [ ] 호출 **순서 의존**을 타입/상태로 **강제**했는가?

- **응집도**
  - [ ] 클래스/모듈은 **하나의 변경 이유**만 갖는가(SRP)?
  - [ ] 파이프라인/스텝이 **명확히 분리**되었는가?
  - [ ] 공개 인터페이스가 **최소**인가(ISP)?

---

## 13. 보너스: 간단 메트릭 스니펫(정적 의존 수 세기)

```python
# 파이썬 의사 코드: 자바 소스에서 import 의존 개수 세기
import glob, re
deps = {}
for f in glob.glob("src/**/*.java", recursive=True):
    with open(f, encoding="utf-8") as fh:
        pk = re.search(r'package\s+([\w\.]+);', fh.read())
    if not pk: continue
    pkg = pk.group(1)
    deps.setdefault(pkg, set())

for f in glob.glob("src/**/*.java", recursive=True):
    with open(f, encoding="utf-8") as fh:
        txt = fh.read()
    pkg = re.search(r'package\s+([\w\.]+);', txt)
    if not pkg: continue
    p = pkg.group(1)
    for m in re.findall(r'import\s+([\w\.]+)\.\w+;', txt):
        if m != p:
            deps[p].add(m.split('.')[0])

for p, ds in deps.items():
    print(p, "Ce:", len(ds))
```

> 산출된 **Ce**(efferent)와 역 참조로 **Ca**를 유추해 `I, A, D`를 대략 계산해볼 수 있다.

---

## 14. 요약

- **결합도 낮추기**: 추상화(포트·인터페이스), DI, 이벤트/메시징, 게이트웨이/안티코럽션, 디미터 법칙
- **응집도 높이기**: SRP 분해, 파이프라인화, 데이터 소유권/불변식, 경계 설정(바운디드 컨텍스트)
- **측정**: Ca/Ce, Instability `I`, Abstractness `A`, Distance `D`로 경향 파악
- **목표**: 변경이 **국소적**이고, 기능 추가가 **확장**으로 이루어지는 구조

---

## 15. 부록: 수식 요약

$$
I = \frac{C_e}{C_a + C_e},\quad
A = \frac{N_a}{N_c},\quad
D = \left|A + I - 1\right|
$$

- \(C_a\): Afferent(들어오는 의존), \(C_e\): Efferent(나가는 의존)
- \(N_a\): 추상 타입 수(인터페이스/추상 클래스), \(N_c\): 타입 총수
- \(D\)가 0에 가까울수록 균형(메인 시퀀스)

---

## 16. 부록: 예제 전개(응용)

### A. 결제(외부 결합 완충 + 계약 테스트)
```java
interface PaymentPort { Receipt pay(Money amount); }  // 내부 계약
final class ExtPaymentAdapter implements PaymentPort { /* 외부 SDK 캡슐화 */ }
abstract class PaymentPortContract { /* 공통 테스트 */ }
```

### B. 주문 파이프라인(응집도 강화)
```java
Order order = orderRepo.find(id);
Invoice invoice = invoiceGen.create(order);
invoiceRepo.save(invoice);
eventBus.publish(new InvoiceCreated(invoice.id()));
```

### C. 시간적 결합 분리(사가)
```java
// 결제→재고→송장 발행을 사가로 오케스트레이션
class CheckoutSaga {
    void handle(OrderPlaced e){
        tryPay(e.orderId());
        reserveStock(e.orderId());
        issueInvoice(e.orderId());
    }
}
```
