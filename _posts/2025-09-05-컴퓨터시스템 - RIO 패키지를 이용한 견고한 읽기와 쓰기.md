---
layout: post
title: 컴퓨터시스템 - RIO 패키지를 이용한 견고한 읽기와 쓰기
date: 2025-09-05 14:20:23 +0900
category: 컴퓨터시스템
---
# RIO(robust I/O) 패키지를 이용한 **견고한 읽기와 쓰기** — 설계, 구현, 사용법

> RIO는 “**부분 I/O(Short I/O)**”, “**EINTR**(시그널 인터럽트)”, “**라인 단위 읽기**”를 안전하게 처리하기 위한 **C용 보일러플레이트**입니다.  
> CS:APP에서 소개된 인터페이스를 토대로 **언버퍼드(정확히 N바이트)**, **버퍼드(라인/블록)** 두 계층을 제공합니다.

---

## 0) 왜 RIO인가?

- `read`/`write`는 **요청한 크기만큼** 처리하지 않을 수 있습니다(부분 I/O).  
- 시그널이 끼어들면 `EINTR`로 **중단**될 수 있습니다.  
- 소켓/파이프/TTY 등에서는 라인 단위로 읽고 싶을 때가 많습니다.  
→ RIO는 이 문제들을 **일관된 반환 규약**과 **반복 루프/내부 버퍼**로 해결합니다.

---

## 1) RIO 인터페이스 요약

### 1.1 언버퍼드(정확히 N바이트 지향)
- `rio_readn(fd, buf, n)` : 최대 **n바이트를 채울 때까지**(EOF/오류 전까지) 반복 읽기  
- `rio_writen(fd, buf, n)`: **모두 쓸 때까지** 반복 쓰기

### 1.2 버퍼드(내부 8KB 버퍼 보유, 라인/블록)
- `rio_readinitb(rp, fd)` : 버퍼 상태 초기화  
- `rio_readlineb(rp, usrbuf, maxlen)` : **개행 포함 라인**(최대 `maxlen-1`) 읽기  
- `rio_readnb(rp, usrbuf, n)` : 내부 버퍼에서 **총 n바이트** 읽기

> 반환 규약(공통):  
> `>0`: 읽거나 쓴 바이트 수, `0`: EOF(읽기), `<0`: 오류(`errno` 확인)

---

## 2) RIO 헤더/구조체

```c
/* rio.h */
#ifndef RIO_H
#define RIO_H
#include <sys/types.h>

#define RIO_BUFSIZE 8192

typedef struct {
    int   rio_fd;                 /* 대상 FD */
    int   rio_cnt;                /* 내부 버퍼에 남은 바이트 수 */
    char *rio_bufptr;             /* 내부 버퍼의 현재 위치 */
    char  rio_buf[RIO_BUFSIZE];   /* 내부 버퍼 */
} rio_t;

/* 언버퍼드: 정확히 N바이트 지향 */
ssize_t rio_readn (int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, const void *usrbuf, size_t n);

/* 버퍼드: 라인/블록 */
void    rio_readinitb(rio_t *rp, int fd);
ssize_t rio_readnb  (rio_t *rp, void *usrbuf, size_t n);
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);

#endif
```

---

## 3) RIO 구현(참고용 완성 코드)

```c
/* rio.c */
#include "rio.h"
#include <unistd.h>
#include <errno.h>
#include <string.h>

ssize_t rio_readn(int fd, void *usrbuf, size_t n) {
    size_t  nleft = n;
    ssize_t nread;
    char   *bufp = (char*)usrbuf;

    while (nleft > 0) {
        nread = read(fd, bufp, nleft);
        if (nread > 0) {
            nleft -= nread;
            bufp  += nread;
        } else if (nread == 0) {
            break;                       /* EOF */
        } else { /* nread < 0 */
            if (errno == EINTR) continue;              /* 다시 시도 */
            if (errno == EAGAIN || errno == EWOULDBLOCK) break; /* 비차단: 지금은 없음 */
            return -1;                                   /* 진짜 오류 */
        }
    }
    return (ssize_t)(n - nleft); /* 요청보다 작으면 EOF/비차단 */
}

ssize_t rio_writen(int fd, const void *usrbuf, size_t n) {
    size_t      nleft = n;
    ssize_t     nwritten;
    const char *bufp = (const char*)usrbuf;

    while (nleft > 0) {
        nwritten = write(fd, bufp, nleft);
        if (nwritten > 0) {
            nleft -= nwritten;
            bufp  += nwritten;
        } else if (nwritten == 0) {
            continue; /* 이례적이지만 루프 지속 */
        } else { /* < 0 */
            if (errno == EINTR) continue;
            if (errno == EAGAIN || errno == EWOULDBLOCK) continue; /* 준비될 때까지 스핀(비차단이면 상위에서 epoll 권장) */
            return -1;
        }
    }
    return (ssize_t)n;
}

/* --- 버퍼드 계층 --- */

static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n) {
    while (rp->rio_cnt <= 0) { /* 내부 버퍼를 비웠으면 채움 */
        rp->rio_cnt = (int)read(rp->rio_fd, rp->rio_buf, sizeof(rp->rio_buf));
        if (rp->rio_cnt < 0) {
            if (errno == EINTR) continue;
            return -1;                         /* EAGAIN 등은 상위에 전파 */
        } else if (rp->rio_cnt == 0) {
            return 0;                          /* EOF */
        }
        rp->rio_bufptr = rp->rio_buf;          /* 포인터 리셋 */
    }
    int cnt = (int)((rp->rio_cnt < (int)n) ? rp->rio_cnt : (int)n);
    memcpy(usrbuf, rp->rio_bufptr, (size_t)cnt);
    rp->rio_bufptr += cnt;
    rp->rio_cnt    -= cnt;
    return cnt;
}

void rio_readinitb(rio_t *rp, int fd) {
    rp->rio_fd     = fd;
    rp->rio_cnt    = 0;
    rp->rio_bufptr = rp->rio_buf;
}

ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n) {
    size_t  nleft = n;
    ssize_t nread;
    char   *bufp = (char*)usrbuf;

    while (nleft > 0) {
        nread = rio_read(rp, bufp, nleft);
        if (nread > 0) {
            nleft -= nread;
            bufp  += nread;
        } else if (nread == 0) {
            break;               /* EOF */
        } else {                 /* -1: 오류 */
            return -1;
        }
    }
    return (ssize_t)(n - nleft);
}

ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) {
    char   *bufp = (char*)usrbuf;
    ssize_t n, rc;
    char    c;

    for (n = 1; n < (ssize_t)maxlen; n++) {
        rc = rio_read(rp, &c, 1);
        if (rc == 1) {
            *bufp++ = c;
            if (c == '\n') break;   /* 라인 종료 */
        } else if (rc == 0) {       /* EOF */
            if (n == 1) return 0;   /* 아무 것도 못 읽음 */
            break;                   /* 일부 읽었으면 그만 */
        } else {
            return -1;               /* 오류 전파 */
        }
    }
    *bufp = '\0';
    return n;
}
```

---

## 4) 사용 예시

### 4.1 라인 에코(소켓/표준입력 모두 동작)
```c
#include "rio.h"
#include <stdio.h>
#include <string.h>

int main(void) {
    rio_t rio;
    char line[4096];

    rio_readinitb(&rio, 0);              // stdin (fd=0)
    while (1) {
        ssize_t n = rio_readlineb(&rio, line, sizeof(line));
        if (n == 0) break;               // EOF
        if (n < 0) { perror("readline"); break; }
        if (rio_writen(1, line, (size_t)n) < 0) { perror("writen"); break; } // stdout
    }
    return 0;
}
```

### 4.2 정확히 N바이트 읽기(바이너리 프로토콜)
```c
/* 헤더(4바이트 길이) + 본문 읽기 */
#include "rio.h"
#include <arpa/inet.h>
#include <stdint.h>
#include <stdio.h>

int handle(int fd){
    uint32_t netlen;
    if (rio_readn(fd, &netlen, sizeof(netlen)) != sizeof(netlen)) return -1;
    uint32_t len = ntohl(netlen);
    if (len > (1<<24)) return -1; // 방어적 체크

    char *buf = (char*)malloc(len);
    if (!buf) return -1;

    ssize_t r = rio_readn(fd, buf, len);
    if (r != (ssize_t)len) { free(buf); return -1; }

    /* 처리 후 응답 쓰기 */
    if (rio_writen(fd, buf, len) < 0) { free(buf); return -1; }
    free(buf);
    return 0;
}
```

---

## 5) 반환 규약/동작 철학

- `rio_readn`: **최대한 채운 뒤**(EOF/비차단이면 덜 채워질 수도) 그만큼을 반환.  
- `rio_writen`: **요청 바이트 모두 쓰여야만** 반환(비차단 FD에선 busy loop 위험 → 상위에서 `select/poll/epoll`로 준비 상태를 보장하세요).  
- `rio_readlineb`: `'\n'`을 포함해 최대 `maxlen-1`까지 읽고, 항상 **널 종단**.

> **비차단 FD**: 위 구현은 `read`의 `EAGAIN`을 **버퍼드 계층에선 -1로 전파**, 언버퍼드에선 **현재까지 읽은 바이트**를 반환합니다.  
> 이벤트 기반 프로그램이라면 `EAGAIN`을 만나면 **상위 루프로 제어를 돌려** 다시 준비되었을 때 재호출하세요.

---

## 6) 실전 팁

1. **stdio와 혼용 금지**: 동일 FD에 대해 `RIO`와 `fprintf/fread`를 섞으면 순서/버퍼가 꼬입니다. 한 쪽만 사용하거나, `fflush`/`fsync`(주의)로 동기화.
2. **라인 길이 방어**: `rio_readlineb`의 `maxlen`은 반드시 프로토콜 상한보다 크거나 같게. 과도한 라인은 잘라내거나 에러 처리.
3. **타임아웃**: 순수 RIO에는 타임아웃이 없습니다. 필요하면 소켓 옵션(`SO_RCVTIMEO`) 또는 `poll/epoll`로 감싸세요.
4. **스레드 안전**: `rio_t`는 **인스턴스 단위** 상태이므로, 스레드마다 **자신의 `rio_t`**를 쓰면 안전합니다.
5. **대용량 덩어리**: 덩어리 쓰기는 `rio_writen` + 적절한 **청크 크기**(예: 64KB)로 나누면 커널 버퍼 압박을 줄입니다.

---

## 7) 흔한 함정과 대처

| 상황 | 증상 | 해결 |
|---|---|---|
| 부분 쓰기 무시 | 데이터 일부만 전송 | **반드시 `rio_writen`** 사용 |
| EINTR 미처리 | 가끔 `read`/`write`가 -1 | RIO가 자동 재시도 |
| 라인 읽기에서 버퍼 초과 | 긴 줄에서 잘림/크래시 | `maxlen` 상향 + 프로토콜 상한 검사 |
| 비차단 소켓에서 바쁜 루프 | CPU 100% | `epoll`로 준비 확인 후 `rio_readn/nb` 호출 |
| 혼용(`stdio`+`RIO`) | 순서 뒤섞임 | 한쪽만 쓰기 |

---

## 8) 선택 가이드 — 언제 무엇을 쓰나?

- **바이너리/고정 길이**: `rio_readn` / `rio_writen`  
- **라인 프로토콜(HTTP, SMTP, REPL)**: `rio_readlineb` + `rio_writen`  
- **대량 일괄 읽기**: `rio_readnb` (내부 8KB 버퍼로 시스템콜 수 절감)  
- **비차단 이벤트 루프**: `epoll`로 준비 이벤트 → 그때 `rio_readnb/lineb` 호출(또는 자체 nonblocking-friendly 래퍼 작성)

---

## 9) 작동 확인용 미니 테스트

```c
/* 표준입력을 받아 표준출력으로 돌려보며 라인/블록 API를 연습 */
#include "rio.h"
#include <stdio.h>

int main(void){
    rio_t r; char line[1024]; rio_readinitb(&r, 0);

    /* 라인 모드 */
    while (1) {
        ssize_t n = rio_readlineb(&r, line, sizeof(line));
        if (n <= 0) break;
        rio_writen(1, line, (size_t)n);
    }
    return 0;
}
```

---

## 10) 마무리

RIO는 **짧은 I/O, EINTR, 라인 처리**를 표준화하여, 네트워크·파일·파이프 어디서나 **예측 가능한 I/O**를 제공합니다.  
프로토콜에 맞춰 `readn/lineb/nb`를 고르고, 쓰기는 항상 `writen`으로 **완전 쓰기 보장**—이 원칙만 지키면, 대부분의 I/O 버그는 초기에 사라집니다.