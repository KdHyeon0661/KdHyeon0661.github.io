---
layout: post
title: 컴퓨터시스템 - RIO 패키지를 이용한 견고한 읽기와 쓰기
date: 2025-09-05 14:20:23 +0900
category: 컴퓨터시스템
---
# RIO(robust I/O) 패키지를 이용한 **견고한 읽기와 쓰기**

## 왜 RIO인가?

POSIX `read`/`write`는 “요청한 만큼” 처리되지 않을 수 있습니다. 이유는 다양합니다.

- **부분 I/O(Short I/O)**: 내부 버퍼가 부족하거나 커널 정책에 따라 일부만 처리
- **EINTR**: 시그널 개입으로 시스템콜이 중단
- **소켓/파이프**: 라인 단위 처리가 필요하지만 `read`는 경계 개념이 없음

**RIO**는 아래의 **일관된 규약**으로 이 문제를 통일합니다.

- `rio_writen(fd, buf, n)` → **n바이트 전부** 쓸 때까지 반복(오류면 -1)
- `rio_readn(fd, buf, n)` → **최대한 채워** 반환(EOF/비차단이면 부분으로 끝날 수 있음)
- `rio_readlineb(rp, usrbuf, maxlen)` → 개행 포함 라인을 **널 종단**으로 반환
- `rio_readnb(rp, usrbuf, n)` → 내부 버퍼 기반 **블록 읽기**

---

## 설계 개요 — 두 층으로 나눈다

1) **언버퍼드(보장 계층)**
   - `rio_readn`, `rio_writen`
   - **EINTR 재시도**, **부분 쓰기 루프** 내장
   - 바이너리 프로토콜/길이 프레이밍에 적합

2) **버퍼드(편의 계층)**
   - `rio_readinitb`, `rio_readlineb`, `rio_readnb`
   - 내부 **8KB 고정 버퍼**(기본값)로 시스템콜 횟수 절감
   - 라인 프로토콜(예: SMTP/HTTP 요청 헤더) 구현이 간단

> **스레드 안전성**: `rio_t`는 **인스턴스 상태**를 갖습니다. **스레드마다 별도 `rio_t`** 를 쓰면 안전합니다.

---

## API 요약

### 언버퍼드(정확히 N바이트 지향)

- `ssize_t rio_readn (int fd, void *usrbuf, size_t n);`
- `ssize_t rio_writen(int fd, const void *usrbuf, size_t n);`

### 버퍼드(라인/블록)

- `void    rio_readinitb(rio_t *rp, int fd);`
- `ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);`
- `ssize_t rio_readnb   (rio_t *rp, void *usrbuf, size_t n);`

> **반환 규약**:
> `>0` 처리 바이트 수, `0`=EOF(읽기), `<0`=오류(`errno`).

---

## 헤더/구조체

```c
/* rio.h */
#ifndef RIO_H
#define RIO_H
#include <sys/types.h>
#include <stddef.h>

#ifdef __cplusplus

extern "C" {
#endif

#define RIO_BUFSIZE 8192

typedef struct {
    int   rio_fd;                 /* 대상 FD */
    int   rio_cnt;                /* 내부 버퍼에 남은 바이트 수 */
    char *rio_bufptr;             /* 내부 버퍼 현재 위치 */
    char  rio_buf[RIO_BUFSIZE];   /* 내부 버퍼 저장소 */
} rio_t;

/* 언버퍼드 */
ssize_t rio_readn (int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, const void *usrbuf, size_t n);

/* 버퍼드 */
void    rio_readinitb(rio_t *rp, int fd);
ssize_t rio_readnb   (rio_t *rp, void *usrbuf, size_t n);
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);

#ifdef __cplusplus

}
#endif
#endif

```

---

## 구현(참고용 완성 코드)

```c
/* rio.c */
#include "rio.h"
#include <unistd.h>
#include <errno.h>
#include <string.h>

/* --- 언버퍼드 계층 --------------------------------------------------- */

ssize_t rio_readn(int fd, void *usrbuf, size_t n) {
    size_t  nleft = n;
    ssize_t nread;
    char   *bufp = (char*)usrbuf;

    while (nleft > 0) {
        nread = read(fd, bufp, nleft);
        if (nread > 0) {
            nleft -= (size_t)nread;
            bufp  += nread;
        } else if (nread == 0) {
            break; /* EOF */
        } else {
            if (errno == EINTR) continue;
            if (errno == EAGAIN || errno == EWOULDBLOCK) break; /* 비차단: 지금은 없음 */
            return -1;
        }
    }
    return (ssize_t)(n - nleft); /* 요청보다 작으면 EOF/비차단 */
}

ssize_t rio_writen(int fd, const void *usrbuf, size_t n) {
    size_t      nleft = n;
    ssize_t     nw;
    const char *bufp = (const char*)usrbuf;

    while (nleft > 0) {
        nw = write(fd, bufp, nleft);
        if (nw > 0) {
            nleft -= (size_t)nw;
            bufp  += nw;
        } else if (nw == 0) {
            continue; /* 드뭄: 다시 시도 */
        } else {
            if (errno == EINTR) continue;
            if (errno == EAGAIN || errno == EWOULDBLOCK) continue; /* 상위에서 준비 보장 권장 */
            return -1;
        }
    }
    return (ssize_t)n;
}

/* --- 버퍼드 계층 ----------------------------------------------------- */

static ssize_t rio_fillbuf(rio_t *rp) {
    for (;;) {
        ssize_t rc = read(rp->rio_fd, rp->rio_buf, sizeof(rp->rio_buf));
        if (rc > 0) {
            rp->rio_cnt    = (int)rc;
            rp->rio_bufptr = rp->rio_buf;
            return rc;
        } else if (rc == 0) {
            rp->rio_cnt = 0; /* EOF 표시 */
            return 0;
        } else {
            if (errno == EINTR) continue;
            return -1; /* EAGAIN은 상위로 전파 */
        }
    }
}

void rio_readinitb(rio_t *rp, int fd) {
    rp->rio_fd     = fd;
    rp->rio_cnt    = 0;
    rp->rio_bufptr = rp->rio_buf;
}

ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n) {
    size_t  nleft = n;
    ssize_t nread;
    char   *bufp  = (char*)usrbuf;

    while (nleft > 0) {
        if (rp->rio_cnt <= 0) {
            if (rio_fillbuf(rp) <= 0) { /* 0=EOF, -1=오류 */
                return (nleft == n) ? rp->rio_cnt : (ssize_t)(n - nleft);
            }
        }
        int cnt = rp->rio_cnt < (int)nleft ? rp->rio_cnt : (int)nleft;
        memcpy(bufp, rp->rio_bufptr, (size_t)cnt);
        rp->rio_bufptr += cnt;
        rp->rio_cnt    -= cnt;
        bufp           += cnt;
        nleft          -= (size_t)cnt;
    }
    return (ssize_t)n;
}

ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) {
    char   *bufp = (char*)usrbuf;
    ssize_t n, c;

    for (n = 1; n < (ssize_t)maxlen; n++) {
        if (rp->rio_cnt <= 0) {
            ssize_t rc = rio_fillbuf(rp);
            if (rc == 0) {             /* EOF */
                if (n == 1) return 0;  /* 아무 것도 못 읽음 */
                break;                  /* 일부 읽었으면 탈출 */
            }
            if (rc < 0) return -1;     /* 오류 */
        }
        c = *rp->rio_bufptr++;
        rp->rio_cnt--;
        *bufp++ = (char)c;
        if (c == '\n') break;
    }
    *bufp = '\0';
    return n;
}
```

---

## 사용법 — 상황별 스니펫

### 라인 에코(표준입력/소켓 동일)

```c
#include "rio.h"
#include <stdio.h>

int main(void) {
    rio_t rio; char line[4096];
    rio_readinitb(&rio, 0);        // stdin

    while (1) {
        ssize_t n = rio_readlineb(&rio, line, sizeof(line));
        if (n == 0) break;         // EOF
        if (n < 0) { perror("readline"); return 1; }
        if (rio_writen(1, line, (size_t)n) < 0) { perror("writen"); return 1; } // stdout
    }
    return 0;
}
```

### 길이-프레임 바이너리(네트워크 메시지)

```c
#include "rio.h"
#include <arpa/inet.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

int recv_msg(int fd){
    uint32_t netlen;
    if (rio_readn(fd, &netlen, sizeof(netlen)) != sizeof(netlen)) return -1;
    uint32_t len = ntohl(netlen);
    if (len > (1u<<24)) return -1; // 방어

    char *buf = (char*)malloc(len);
    if (!buf) return -1;

    ssize_t r = rio_readn(fd, buf, len);
    if (r != (ssize_t)len) { free(buf); return -1; }

    // echo
    if (rio_writen(fd, &netlen, sizeof(netlen)) < 0) { free(buf); return -1; }
    if (rio_writen(fd, buf, len) < 0) { free(buf); return -1; }

    free(buf);
    return 0;
}
```

### 비차단 소켓 + epoll과의 결합

```c
/* 이벤트가 '읽기 가능'일 때만 호출하라 */
#include "rio.h"
#include <sys/epoll.h>
#include <fcntl.h>
#include <errno.h>

typedef struct {
    int   fd;
    rio_t rio;
    char  inbuf[4096];
} conn_t;

/* accept 후 O_NONBLOCK 설정, rio_readinitb(&c->rio, c->fd) */

int on_readable(conn_t *c){
    for (;;) {
        ssize_t n = rio_readlineb(&c->rio, c->inbuf, sizeof(c->inbuf));
        if (n > 0) {
            if (rio_writen(c->fd, c->inbuf, (size_t)n) < 0) {
                if (errno == EAGAIN || errno == EWOULDBLOCK) return 0; /* 나중에 다시 */
                return -1;
            }
        } else if (n == 0) {
            return -1; // EOF: 연결 종료
        } else { // n < 0
            if (errno == EAGAIN || errno == EWOULDBLOCK) return 0;
            if (errno == EINTR) continue;
            return -1;
        }
    }
}
```

> **요령**: RIO는 `EAGAIN`을 “지금은 읽을 게 없다”로 전파합니다. **epoll의 EPOLLIN 이벤트**를 받았을 때만 `rio_read*` 를 호출하고, `EAGAIN`이면 **상위 루프로 복귀**하세요.

---

## 반환 규약(정밀)

- **언버퍼드**
  - `rio_readn`: `0`=EOF, `>0`=읽은 바이트(요청보다 작을 수 있음), `<0`=오류
  - `rio_writen`: **요청한 바이트 모두** 쓰거나 `<0` 오류
- **버퍼드**
  - `rio_readnb`: 요청 바이트를 채우거나(가능하면) EOF/오류 시 조기 종료
  - `rio_readlineb`: `'\n'` 포함, 최대 `maxlen-1`, 항상 널 종단

---

## 경계/보안 고려

- **라인 길이 상한**: `maxlen`은 프로토콜 상한보다 충분히 크게. 이탈 시 **절단** 또는 **에러**.
- **혼용 금지**: 같은 FD에서 `RIO`와 `stdio(fgets/printf)`를 섞지 말 것(버퍼링 충돌).
- **타임아웃**: RIO는 제공하지 않음. 필요 시 `poll/epoll`이나 `SO_RCVTIMEO/SO_SNDTIMEO`.

---

## 성능/복잡도 관찰

- **시스템콜 수** (버퍼드 읽기):
  $$
  \text{syscalls} \approx \left\lceil \frac{N}{B} \right\rceil
  $$
  여기서 \(N\)=총 바이트, \(B\)=RIO 내부 버퍼 크기(기본 8192).
- **스루풋**은 워크로드별로 다르나, 소량 라인 처리에서 버퍼드 API가 시스템콜 호출을 크게 줄이는 경향.

---

## 테스트 — 간단 회귀

```c
/* rio_test.c: 표준입력 라인 에코 */
#include "rio.h"
#include <stdio.h>

int main(void){
    rio_t r; char line[1024]; rio_readinitb(&r, 0);
    while (1) {
        ssize_t n = rio_readlineb(&r, line, sizeof(line));
        if (n <= 0) break;
        if (rio_writen(1, line, (size_t)n) < 0) { perror("writen"); return 1; }
    }
    return 0;
}
```

컴파일:
```bash
cc -O2 -Wall -Wextra -c rio.c
cc -O2 -Wall -Wextra rio_test.c rio.o -o rio_test
```

---

## 실전 체크리스트

- [ ] **쓰기**는 항상 `rio_writen`으로 **전체 쓰기 보장**
- [ ] **EINTR** 자동 재시도, **EAGAIN**은 상위에서 이벤트 루프와 조합
- [ ] **라인 상한** 설정 및 방어적 검사
- [ ] **stdio 혼용 금지**
- [ ] 멀티스레드: 연결/FD마다 **독립 `rio_t`**

---

## 확장 아이디어(선택)

- **구분자 기반 읽기**(예: `\r\n` 까지) 함수 추가
- **peek**(내부 버퍼 비파괴 조회) 제공
- **타임아웃 가능 래퍼**: `poll/epoll`과 조합한 `rio_timed_readlineb`

---

## 결론

RIO는 **짧은 I/O, EINTR, 라인 경계**를 한 번에 정리해, 파일/파이프/소켓 어디서나 **안정적인 I/O**를 제공합니다.
프로토콜에 맞춰 `readn/lineb/nb`를 선택하고, **항상 `writen`** 을 쓰는 규율만 지켜도 현장의 대부분 I/O 문제는 사라집니다.
