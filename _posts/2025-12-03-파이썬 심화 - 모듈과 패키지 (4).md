---
layout: post
title: 파이썬 심화 - 모듈과 패키지 (4)
date: 2025-12-03 20:30:23 +0900
category: 파이썬 심화
---
# 모듈과 패키지 (4)

파이썬 생태계에서 효과적인 패키지 관리와 환경 구성은 프로젝트 성공의 핵심 요소입니다. 개발, 테스트, 배포의 각 단계에 맞는 환경을 구축하고 관리하는 방법을 체계적으로 살펴보겠습니다.

## 임포트 시 모듈 패치와 동적 수정

### 모듈 패치의 기본 개념과 활용
모듈 패치는 런타임에 기존 모듈의 동작을 변경하는 기술로, 테스트와 디버깅에서 특히 유용합니다.

```python
# 기본적인 모듈 패치 예제
import requests

original_get = requests.get  # 원본 함수 저장

def patched_get(url, **kwargs):
    """패치된 get 함수 - 특정 URL에 대해 모의 응답 반환"""
    if "example.com" in url:
        from unittest.mock import Mock
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"mocked": True}
        return mock_response
    
    # 다른 URL은 원래 함수로 처리
    return original_get(url, **kwargs)

# 모듈 패치 적용
requests.get = patched_get

# 테스트
response = requests.get("https://example.com/api/data")
print(response.json())  # {"mocked": True}

# 패치 제거 (원상복구)
requests.get = original_get
```

### `unittest.mock`을 활용한 체계적인 패치
```python
from unittest.mock import patch, MagicMock
import datetime

# 데코레이터를 이용한 패치
@patch('datetime.datetime')
def test_get_current_time(mock_datetime):
    """datetime 모듈 패치 테스트"""
    # 고정된 시간 설정
    fixed_time = datetime.datetime(2024, 1, 15, 10, 30, 0)
    mock_datetime.now.return_value = fixed_time
    
    # 테스트 대상 함수
    def get_current_time():
        return datetime.datetime.now()
    
    result = get_current_time()
    assert result == fixed_time
    print(f"패치된 시간: {result}")

# 컨텍스트 매니저를 이용한 패치
def process_data():
    """외부 API 호출이 필요한 함수"""
    import requests
    response = requests.get("https://api.example.com/data")
    return response.json()

# 테스트 시 외부 의존성 제거
with patch('requests.get') as mock_get:
    mock_response = MagicMock()
    mock_response.json.return_value = {"test": "data"}
    mock_get.return_value = mock_response
    
    result = process_data()
    print(f"모의 데이터: {result}")  # {"test": "data"}
    mock_get.assert_called_once_with("https://api.example.com/data")
```

### 심화: 임포트 후킹을 통한 동적 모듈 변형
```python
import sys
import importlib

class ModulePatcher:
    """임포트 시점에 모듈을 동적으로 패치하는 클래스"""
    
    def __init__(self):
        self.original_import = None
        self.patches = {}
    
    def patch_module(self, module_name, patch_dict):
        """패치할 모듈과 내용 등록"""
        self.patches[module_name] = patch_dict
    
    def install(self):
        """임포트 후킹 설치"""
        self.original_import = __builtins__.__import__
        
        def custom_import(name, *args, **kwargs):
            # 원래 임포트 수행
            module = self.original_import(name, *args, **kwargs)
            
            # 등록된 패치 적용
            if name in self.patches:
                for attr_name, new_value in self.patches[name].items():
                    setattr(module, attr_name, new_value)
                    print(f"패치 적용: {name}.{attr_name}")
            
            return module
        
        # 임포트 시스템 오버라이드
        __builtins__.__import__ = custom_import
        sys.meta_path.insert(0, self)  # 메타 경로에도 추가
    
    def uninstall(self):
        """패치 제거"""
        if self.original_import:
            __builtins__.__import__ = self.original_import
            if self in sys.meta_path:
                sys.meta_path.remove(self)

# 사용 예제
patcher = ModulePatcher()
patcher.patch_module('math', {'pi': 3.14, 'sqrt': lambda x: x ** 0.5})

patcher.install()

# 패치가 적용된 임포트
import math
print(math.pi)  # 3.14 (원래는 3.141592653589793)

patcher.uninstall()

# 원래 모듈로 다시 임포트
import importlib
importlib.reload(math)
print(math.pi)  # 3.141592653589793
```

## 개인적 목적의 패키지 설치와 관리

### 사용자별 패키지 설치
시스템 전역 설치를 피하고 사용자 공간에 패키지를 설치하는 방법:

```bash
# 사용자 디렉토리에 패키지 설치
pip install --user package-name

# 특정 버전 설치
pip install --user requests==2.28.0

# 개발 모드 설치 (편집 가능)
pip install --user -e /path/to/your/package

# requirements.txt에서 설치
pip install --user -r requirements.txt
```

### 패키지 설치 위치 확인과 관리
```python
import site
import pkg_resources
import sys

def analyze_package_locations():
    """패키지 설치 위치 분석"""
    
    print("사용자 사이트 패키지 위치:")
    for path in site.getusersitepackages():
        print(f"  - {path}")
    
    print("\n시스템 사이트 패키지 위치:")
    for path in site.getsitepackages():
        print(f"  - {path}")
    
    print("\n현재 Python 경로:")
    for path in sys.path:
        print(f"  - {path}")
    
    print("\n설치된 패키지들:")
    for dist in pkg_resources.working_set:
        print(f"  - {dist.key}=={dist.version}")

# 사용자 설치 경로 프로그래밍적으로 추가
def add_user_site_to_path():
    """사용자 사이트 패키지 경로를 sys.path에 추가"""
    import site
    import sys
    
    user_site = site.getusersitepackages()
    if user_site and user_site[0] not in sys.path:
        sys.path.insert(0, user_site[0])
        print(f"사용자 경로 추가됨: {user_site[0]}")
```

### 개인 패키지 레포지토리 활용
```bash
# 개인 Git 저장소에서 직접 설치
pip install --user git+https://github.com/yourusername/private-package.git

# 특정 브랜치 설치
pip install --user git+https://github.com/yourusername/private-package.git@develop

# 비공개 저장소 (SSH 키 필요)
pip install --user git+ssh://git@github.com/yourusername/private-repo.git

# 로컬 디렉토리에서 설치
pip install --user /path/to/local/package

# ZIP 파일에서 설치
pip install --user https://example.com/package.zip
```

## 새로운 파이썬 환경 생성과 관리

### 가상환경의 중요성과 생성 방법
프로젝트별로 격리된 파이썬 환경을 생성하는 다양한 방법:

```bash
# 1. venv 모듈 (Python 3.3+ 기본)
python -m venv myenv
# 활성화 (Linux/Mac)
source myenv/bin/activate
# 활성화 (Windows)
myenv\Scripts\activate

# 2. virtualenv (더 많은 기능)
pip install virtualenv
virtualenv myenv --python=python3.9

# 3. conda 환경 (과학 컴퓨팅용)
conda create -n myenv python=3.9
conda activate myenv

# 4. pipenv (의존성 관리 통합)
pip install pipenv
pipenv --python 3.9
pipenv install requests
pipenv shell
```

### 프로그래밍적 환경 관리
```python
import venv
import subprocess
import sys
import os

class VirtualEnvironmentManager:
    """가상환경을 프로그래밍적으로 관리하는 클래스"""
    
    def __init__(self, env_path):
        self.env_path = env_path
        self.bin_path = os.path.join(env_path, 'bin' if os.name != 'nt' else 'Scripts')
    
    def create(self, python_path=None, with_pip=True):
        """새로운 가상환경 생성"""
        builder = venv.EnvBuilder(
            system_site_packages=False,
            clear=True,
            symlinks=False,
            with_pip=with_pip
        )
        
        print(f"가상환경 생성 중: {self.env_path}")
        builder.create(self.env_path)
        
        if python_path:
            self.set_python_executable(python_path)
    
    def install_packages(self, packages):
        """패키지 설치"""
        pip_path = os.path.join(self.bin_path, 'pip')
        
        for package in packages:
            print(f"패키지 설치: {package}")
            subprocess.run([pip_path, 'install', package], check=True)
    
    def run_script(self, script_content):
        """가상환경에서 스크립트 실행"""
        python_path = os.path.join(self.bin_path, 'python')
        
        # 임시 파일 생성
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(script_content)
            temp_file = f.name
        
        try:
            result = subprocess.run(
                [python_path, temp_file],
                capture_output=True,
                text=True
            )
            print("출력:", result.stdout)
            if result.stderr:
                print("에러:", result.stderr)
            return result.returncode
        finally:
            os.unlink(temp_file)
    
    def generate_requirements(self, output_file='requirements.txt'):
        """의존성 파일 생성"""
        pip_path = os.path.join(self.bin_path, 'pip')
        with open(output_file, 'w') as f:
            subprocess.run([pip_path, 'freeze'], stdout=f, check=True)
        print(f"의존성 파일 생성됨: {output_file}")

# 사용 예제
manager = VirtualEnvironmentManager('./my_project_env')
manager.create(python_path=sys.executable)

packages = ['requests', 'numpy', 'pandas']
manager.install_packages(packages)

test_script = """
import requests
import numpy as np
print('모든 패키지가 정상적으로 설치되었습니다.')
print(f'NumPy 버전: {np.__version__}')
"""
manager.run_script(test_script)
manager.generate_requirements()
```

### 고급 환경 구성: `pyenv`와 결합
```bash
# pyenv로 여러 Python 버전 관리
pyenv install 3.9.0
pyenv install 3.10.0
pyenv install 3.11.0

# 전역 Python 버전 설정
pyenv global 3.11.0

# 프로젝트별 Python 버전 설정
cd my-project
pyenv local 3.10.0

# pyenv-virtualenv 플러그인 설치
git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv

# pyenv로 가상환경 생성
pyenv virtualenv 3.10.0 myproject-3.10
pyenv activate myproject-3.10
```

## 패키지 배포: 개발에서 PyPI까지

### 패키지 구조 설계
배포할 패키지의 표준 구조:

```
my_awesome_package/
├── LICENSE
├── README.md
├── pyproject.toml          # 최신 빌드 시스템 설정
├── setup.py                # 기존 빌드 시스템 (하위 호환성)
├── setup.cfg
├── MANIFEST.in
├── my_awesome_package/
│   ├── __init__.py
│   ├── core.py
│   └── utils.py
├── tests/
│   ├── __init__.py
│   └── test_core.py
└── examples/
    └── basic_usage.py
```

### `pyproject.toml` 설정 (최신 표준)
```toml
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "my-awesome-package"
version = "1.0.0"
description = "An awesome Python package"
readme = "README.md"
license = {text = "MIT"}
authors = [
    {name = "Your Name", email = "you@example.com"}
]
keywords = ["awesome", "utility", "tools"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
]
requires-python = ">=3.9"
dependencies = [
    "requests>=2.28.0",
    "numpy>=1.21.0",
]

[project.optional-dependencies]
dev = ["pytest>=7.0", "black", "flake8"]
docs = ["sphinx", "sphinx-rtd-theme"]

[project.urls]
Homepage = "https://github.com/yourusername/my-awesome-package"
Repository = "https://github.com/yourusername/my-awesome-package"
"Bug Tracker" = "https://github.com/yourusername/my-awesome-package/issues"

[tool.setuptools]
packages = ["my_awesome_package"]

[tool.setuptools.package-data]
"my_awesome_package" = ["data/*.json", "templates/*.html"]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
```

### 패키지 빌드와 테스트
```python
# setup.py (하위 호환성을 위해 유지)
from setuptools import setup, find_packages

setup(
    name="my-awesome-package",
    version="1.0.0",
    packages=find_packages(),
    install_requires=[
        "requests>=2.28.0",
        "numpy>=1.21.0",
    ],
    extras_require={
        "dev": ["pytest>=7.0", "black", "flake8"],
        "docs": ["sphinx", "sphinx-rtd-theme"],
    },
    package_data={
        "my_awesome_package": ["data/*.json", "templates/*.html"],
    },
)
```

```bash
# 패키지 빌드
pip install build
python -m build

# 빌드 결과 확인
ls dist/
# my_awesome_package-1.0.0-py3-none-any.whl
# my_awesome_package-1.0.0.tar.gz

# 로컬에서 테스트 설치
pip install dist/my_awesome_package-1.0.0-py3-none-any.whl

# 또는 개발 모드 설치
pip install -e .

# 테스트 실행
pip install -e ".[dev]"
pytest tests/
```

### PyPI 배포 자동화
```python
# 배포 자동화 스크립트
import subprocess
import os
import sys

def release_new_version(version_type="patch"):
    """새로운 버전 릴리즈 자동화"""
    
    # 버전 증가 (semantic versioning)
    import re
    with open("pyproject.toml", "r") as f:
        content = f.read()
    
    # 현재 버전 추출
    version_match = re.search(r'version\s*=\s*"(\d+)\.(\d+)\.(\d+)"', content)
    if not version_match:
        raise ValueError("버전 정보를 찾을 수 없습니다")
    
    major, minor, patch = map(int, version_match.groups())
    
    # 버전 증가
    if version_type == "major":
        major += 1
        minor = 0
        patch = 0
    elif version_type == "minor":
        minor += 1
        patch = 0
    else:  # patch
        patch += 1
    
    new_version = f"{major}.{minor}.{patch}"
    
    # 버전 업데이트
    new_content = re.sub(
        r'version\s*=\s*"\d+\.\d+\.\d+"',
        f'version = "{new_version}"',
        content
    )
    
    with open("pyproject.toml", "w") as f:
        f.write(new_content)
    
    print(f"버전 업데이트: {new_version}")
    
    # 변경사항 커밋
    subprocess.run(["git", "add", "pyproject.toml"], check=True)
    subprocess.run(["git", "commit", "-m", f"Bump version to {new_version}"], check=True)
    subprocess.run(["git", "tag", f"v{new_version}"], check=True)
    subprocess.run(["git", "push", "origin", "main", "--tags"], check=True)
    
    # 패키지 빌드
    subprocess.run([sys.executable, "-m", "build"], check=True)
    
    # 테스트 PyPI 업로드
    print("테스트 PyPI에 업로드 중...")
    subprocess.run([
        sys.executable, "-m", "twine", "upload",
        "--repository-url", "https://test.pypi.org/legacy/",
        "dist/*"
    ], check=True)
    
    # 실제 PyPI 업로드 (확인 후)
    print("\n실제 PyPI에 업로드하려면 다음 명령을 실행하세요:")
    print(f"python -m twine upload dist/*")
    
    return new_version

# GitHub Actions 자동화 예제 (`.github/workflows/publish.yml`)
"""
name: Publish Python Package

on:
  release:
    types: [created]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine
    
    - name: Build package
      run: python -m build
    
    - name: Publish to PyPI
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
      run: python -m twine upload dist/*
"""
```

### 사설 패키지 저장소 구성
```python
# 간단한 사설 PyPI 서버 (using pypiserver)
"""
1. pypiserver 설치
pip install pypiserver

2. 패키지 디렉토리 생성
mkdir ~/packages

3. 패키지 파일 복사
cp dist/* ~/packages/

4. 서버 실행
pypi-server -p 8080 ~/packages/

5. 클라이언트에서 사용
pip install --index-url http://localhost:8080/simple/ my-awesome-package

6. pip 영구 설정
# pip.conf 또는 ~/.pip/pip.conf에 추가
[global]
index-url = http://localhost:8080/simple/
trusted-host = localhost
"""
```

## 결론

파이썬 패키지 관리와 환경 구성은 현대적 파이썬 개발의 핵심 역량입니다. 효과적인 개발 워크플로우를 구축하기 위해 다음 원칙을 준수하는 것이 좋습니다:

1. **환경 격리의 원칙**: 모든 프로젝트는 독립된 가상환경에서 개발하여 의존성 충돌을 방지합니다.
2. **재현 가능성 보장**: `requirements.txt`, `Pipfile.lock`, `poetry.lock` 등을 통해 정확한 의존성 버전을 관리합니다.
3. **점진적 개선**: 단순한 `venv`에서 시작해 필요에 따라 `pipenv`, `poetry`, `conda` 등 더 정교한 도구로 발전시킵니다.
4. **자동화 활용**: CI/CD 파이프라인을 구축하여 테스트, 빌드, 배포를 자동화합니다.
5. **배포 표준 준수**: `pyproject.toml`과 최신 패키징 표준을 따라 호환성과 유지보수성을 확보합니다.

개발 초기 단계부터 격리된 환경과 명확한 의존성 관리를 적용하면, 프로젝트가 성장하거나 팀이 확대되더라도 기술적 부채를 최소화할 수 있습니다. 패키지 배포 시에는 테스트 PyPI를 활용한 사전 검증과 자동화된 배포 파이프라인 구축으로 품질과 안정성을 보장해야 합니다.

이러한 모범 사례들을 체계적으로 적용하면 개인 프로젝트에서 기업 수준의 애플리케이션에 이르기까지 모든 규모의 파이썬 개발을 효과적으로 관리할 수 있습니다.