---
layout: post
title: C++ - 유닛 테스트와 디버깅
date: 2024-10-04 19:20:23 +0900
category: Cpp
---
# 유닛 테스트 & 디버깅 기초 정리

## 0) 왜 지금 테스트인가? (테스트 피라미드와 ROI)

- **유닛 테스트**(빠르고 좁음) → **통합/시스템 테스트**(느리지만 넓음)
- 리팩토링/의존성 업그레이드/최적화 시 **회귀 방지**
- 버그를 초기에 잡을수록 비용이 급감 (10배 규칙)

테스트 품질 지표 예:
- **라인 커버리지**, **브랜치 커버리지**, **뮤테이션 스코어** 등  
  $$\text{Mutation Score}=\frac{\text{Killed Mutants}}{\text{All Mutants}}$$

---

## 1) `assert` vs `static_assert` vs 예외: 언제 무엇을 쓰나

### 1.1 런타임 검증: `assert`

```cpp
#include <cassert>

int divide(int a, int b) {
    assert(b != 0 && "divide by zero");
    return a / b;
}
```

- **디버그 전용**: `NDEBUG`가 정의되면 제거됨.
- **불변식(invariant)·사전조건(precondition)** 점검에 좋다. 릴리스에서도 강제하고 싶다면 **커스텀 어서션**을 쓰라.

```cpp
// 릴리스에서도 켜지는 간단한 강제 체크
#define ENSURE(x) do { if(!(x)) { std::fprintf(stderr,"ENSURE fail:%s:%d\n",__FILE__,__LINE__); std::abort(); } } while(0)
```

### 1.2 컴파일 타임 검증: `static_assert`

```cpp
template<class T>
void print_size() {
    static_assert(sizeof(T) <= 8, "Too big!");
    std::cout << sizeof(T) << "\n";
}
```

- 템플릿 제약·플랫폼 의존 조건·레이아웃 보장 등에 유용.

### 1.3 예외(throw/catch)

- **복구 가능한 오류**는 예외로 처리한다.
- 라이브러리 경계(API)에서는 **명확한 예외 계층**을 문서화하라.

| 상황 | 권장 |
|---|---|
| 불변식 위반·프로그래머 실수 | `assert`/커스텀 강제 종료 |
| 외부 입력 오류(파일 없음 등) | 예외/에러 코드 |
| 컴파일타임 속성 | `static_assert` |

---

## 2) Catch2: 가벼운 유닛 테스트 프레임워크

### 2.1 최소 예제

```cpp
#define CATCH_CONFIG_MAIN
#include "catch.hpp"

int add(int a, int b) { return a + b; }

TEST_CASE("덧셈은 교환법칙을 만족한다") {
    REQUIRE(add(2,3) == 5);
    REQUIRE(add(3,2) == 5);
}
```

- `REQUIRE` 실패 시 즉시 중단, `CHECK`는 이어서 진행.
- **BDD 스타일**: `SCENARIO`/`GIVEN`/`WHEN`/`THEN`도 가능.

### 2.2 섹션/픽스처/파라미터

```cpp
struct DB {
    DB()  { /* connect */ }
    ~DB() { /* close   */ }
    int get(int id) const { return id*2; }
};

TEST_CASE("DB 접근", "[db]") {
    DB db;

    SECTION("id=1") { REQUIRE(db.get(1) == 2); }
    SECTION("id=2") { REQUIRE(db.get(2) == 4); }
}
```

### 2.3 예외·근사치·생성기

```cpp
double divd(int a, int b) { if(!b) throw std::runtime_error("0"); return double(a)/b; }

TEST_CASE("예외와 실수 비교") {
    REQUIRE_THROWS_AS(divd(1,0), std::runtime_error);
    CHECK(divd(1,2) == Approx(0.5).epsilon(1e-12));
}
```

---

## 3) GoogleTest & GoogleMock: 대규모 프로젝트 표준

### 3.1 기본

```cpp
#include <gtest/gtest.h>

int mul(int a, int b){return a*b;}

TEST(Math, Multiply) {
    EXPECT_EQ(mul(2,3), 6);
}
```

### 3.2 픽스처

```cpp
class MyFixture : public ::testing::Test {
protected:
    void SetUp() override { acc = 10; }
    int acc{};
};

TEST_F(MyFixture, Add)  { acc += 5; EXPECT_EQ(acc, 15); }
TEST_F(MyFixture, Mul)  { acc *= 2; EXPECT_EQ(acc, 20); }
```

### 3.3 파라미터화 테스트

```cpp
class AddParam : public ::testing::TestWithParam<std::tuple<int,int,int>> {};
TEST_P(AddParam, Works) {
    auto [a,b,expect] = GetParam();
    EXPECT_EQ(a+b, expect);
}
INSTANTIATE_TEST_SUITE_P(Simple, AddParam,
    ::testing::Values(std::make_tuple(1,2,3),
                      std::make_tuple(3,5,8)));
```

### 3.4 목킹(GMock)

```cpp
#include <gmock/gmock.h>
struct IClock { virtual ~IClock()=default; virtual int now() const =0; };
struct MockClock : IClock { MOCK_METHOD(int, now, (), (const, override)); };

int deadline_left(const IClock& c, int deadline){ return deadline - c.now(); }

TEST(Clock, Mock) {
    MockClock clk;
    EXPECT_CALL(clk, now()).WillOnce(::testing::Return(7));
    EXPECT_EQ(deadline_left(clk, 10), 3);
}
```

---

## 4) Property-based Testing 한 숟갈 (불변식 테스트)

```cpp
// 아이디어만: reverse(reverse(x)) == x
#include <algorithm>
#include <vector>
#include <random>

bool invariant_reverse_twice(const std::vector<int>& v) {
    auto t=v; std::reverse(t.begin(), t.end());
    std::reverse(t.begin(), t.end());
    return t==v;
}
```

- 프레임워크: RapidCheck/CppQuickCheck/Catch2 generators 등.
- **경계값·난수 시드 고정**으로 재현성 확보.

---

## 5) CMake + CTest로 한 번에 돌리기

### 5.1 Catch2(단일 헤더 가정)

```
project(demo LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 17)

add_executable(math_test tests/math_test.cpp)
# tests/math_test.cpp 안에서 #define CATCH_CONFIG_MAIN 로 진입점 제공
add_test(NAME math_test COMMAND math_test)
```

실행:
```
cmake -S . -B build && cmake --build build && ctest --test-dir build --output-on-failure
```

### 5.2 GoogleTest FetchContent

```cmake
include(FetchContent)
FetchContent_Declare(
  googletest
  URL https://github.com/google/googletest/archive/refs/tags/release-1.14.0.zip
)
FetchContent_MakeAvailable(googletest)

add_executable(gtest_sample tests/gtest_sample.cpp)
target_link_libraries(gtest_sample gtest_main)
add_test(NAME gtest_sample COMMAND gtest_sample)
```

---

## 6) 커버리지: gcc/clang + (lcov|llvm-cov)

### 6.1 Clang/LLVM 예시

```
cmake -S . -B build -DCMAKE_CXX_FLAGS="--coverage -O0 -g" -DCMAKE_EXE_LINKER_FLAGS="--coverage"
cmake --build build
ctest --test-dir build
llvm-profdata merge -sparse build/default.profraw -o build/default.profdata
llvm-cov report build/my_tests -instr-profile=build/default.profdata
llvm-cov show   build/my_tests -instr-profile=build/default.profdata -format=html > coverage.html
```

> 팁: 테스트 전용으로 **-O0/ -Og, -g, -fno-omit-frame-pointer**를 켜라. 인라이닝은 디버깅을 어렵게 한다.

---

## 7) 새너타이저(ASan/UBSan/TSan/MSan): 버그를 “즉시” 터뜨려라

### 7.1 AddressSanitizer

```
-fsanitize=address -fno-omit-frame-pointer -g
```

```cpp
// 댕글링 포인터 예시
int* leak() { int* p = new int(1); return p; } // 해제 안 함
```

ASan으로 실행 시 바로 리포트(누수/오버플로/이중해제 등).

### 7.2 UndefinedBehaviorSanitizer

```
-fsanitize=undefined
```

정수 오버플로, 잘못된 시프트, 미정의 동작 탐지.

### 7.3 ThreadSanitizer

```
-fsanitize=thread
```

데이터 레이스 탐지. **락 없이 공유 데이터 쓰기**를 바로 잡아준다.

---

## 8) gdb/LLDB/Visual Studio 디버깅 루틴

### 8.1 gdb 기본

```sh
g++ -g -O0 app.cpp -o app
gdb ./app
(gdb) break main
(gdb) run
(gdb) next / step / finish
(gdb) print var
(gdb) bt           # backtrace
(gdb) info threads
(gdb) thread apply all bt
(gdb) watch x      # 데이터 변경 감시
(gdb) condition 1 i==42   # 조건부 브레이크
```

**코어 덤프**:
```
ulimit -c unlimited
./app   # 크래시
gdb ./app core
```

### 8.2 LLDB (macOS/clang)

```
lldb ./app
(lldb) b main
(lldb) r
(lldb) n / s
(lldb) bt
(lldb) frame variable
```

### 8.3 Visual Studio

- **Breakpoints**: 조건/히트 카운트/데이터 브레이크포인트
- **Autos/Locals/Watch**, **Call Stack**, **Exception Settings**
- **Just My Code**, **Step Into Specific**
- **Address Sanitizer for Windows**(MSVC) 지원

> 빌드 설정: **Debug**(최소 최적화) + **/ZI** (편집하며 계속).

---

## 9) 동시성 버그 디버깅 팁

- **로그 타임스탬프 + 스레드 ID** 남기기
- **TSAN** 먼저 돌린 뒤 재현 시도
- 무작위 **yield/슬립 주입**으로 스케줄링 섞기
- **데드락**: 모든 스레드에 대해 `bt` 수집 → 락 순서 확인
- **false sharing** 의심 시 캐시라인 정렬(`alignas(64)`)

---

## 10) 실전 미니 모듈: `StringUtil` + 두 프레임워크 테스트

### 10.1 구현

```cpp
// src/string_util.hpp
#pragma once
#include <string>
#include <vector>
#include <sstream>

namespace su {
inline std::vector<std::string> split(const std::string& s, char delim) {
    std::vector<std::string> out;
    std::string item;
    std::stringstream ss(s);
    while (std::getline(ss, item, delim)) out.push_back(item);
    if (!s.empty() && s.back()==delim) out.emplace_back(""); // 트레일링 구분자 보존
    return out;
}
inline std::string join(const std::vector<std::string>& v, const std::string& sep) {
    std::string out;
    for (size_t i=0;i<v.size();++i){ if(i) out += sep; out += v[i]; }
    return out;
}
} // namespace su
```

### 10.2 Catch2 테스트

```cpp
// tests/string_util_catch.cpp
#define CATCH_CONFIG_MAIN
#include "catch.hpp"
#include "string_util.hpp"

TEST_CASE("split basic") {
    using su::split;
    auto v = split("a,b,c", ',');
    REQUIRE(v.size()==3);
    CHECK(v[0]=="a"); CHECK(v[1]=="b"); CHECK(v[2]=="c");
}

TEST_CASE("split trailing delimiter kept") {
    auto v = su::split("a,b,", ',');
    REQUIRE(v.size()==3);
    CHECK(v[2]=="");
}

TEST_CASE("join basic") {
    using su::join;
    std::vector<std::string> v{"x","y","z"};
    CHECK(join(v, "/")=="x/y/z");
}
```

### 10.3 GoogleTest 테스트

```cpp
// tests/string_util_gtest.cpp
#include <gtest/gtest.h>
#include "string_util.hpp"

TEST(SU, SplitBasic) {
    auto v = su::split("a,b,c", ',');
    ASSERT_EQ(v.size(), 3u);
    EXPECT_EQ(v[1], "b");
}

TEST(SU, SplitTrailing) {
    auto v = su::split("a,b,", ',');
    ASSERT_EQ(v.size(), 3u);
    EXPECT_TRUE(v.back().empty());
}

TEST(SU, JoinBasic) {
    std::vector<std::string> v{"x","y","z"};
    EXPECT_EQ(su::join(v, "/"), "x/y/z");
}
```

---

## 11) AAA·픽스처·경계값·플레이크(Flaky) 테스트

- **AAA 패턴**: Arrange(준비) → Act(행동) → Assert(검증) 순서 명확히.
- **픽스처**로 반복 초기화 비용 절감.
- **경계값**: 빈 문자열, 최대 길이, 트레일링/리딩 구분자, 유니코드.
- **Flaky 방지**: 시간 의존/네트워크 의존 제거, 시드 고정, 리트라이 대신 원인 제거.

---

## 12) 로깅 vs 어서션 vs 예외 — 운영 기준

| 레벨 | 언제 |
|---|---|
| 로그 | 운영 관찰·원인 추적. 성능 민감 구간은 배치/버퍼링 |
| 어서션 | 개발/테스트 중 논리 오류 조기 발견 |
| 예외 | 복구 가능한 실패 경로. API 경계에서 명확히 문서화 |

---

## 13) 테스트 조직과 CI

```
project/
  src/
  tests/
    unit/        # 순수 유닛
    integration/ # 파일/DB/네트워크
  CMakeLists.txt
```

- CTest로 `ctest -L unit`/`-L integration` 라벨 구분.
- CI(예: GitHub Actions)에서 **ASan+UBSan**, **-O0 -g**, **커버리지** 잡을 분리.

---

## 14) 치트시트

- Catch2: `REQUIRE_THROWS_AS`, `Approx`, `SECTION`, `TEMPLATE_TEST_CASE`
- GTest: `TEST_F`, `TEST_P`, `INSTANTIATE_TEST_SUITE_P`, `ASSERT_*` vs `EXPECT_*`
- gdb: `b file:line`, `r`, `n/s`, `bt`, `p`, `watch`, `info threads`, `thread apply all bt`
- 플래그: `-g -O0 -fno-omit-frame-pointer`, `-fsanitize=address,undefined,thread`, `--coverage`

---

## 15) 마무리

- **테스트는 설계 도구**다. API를 “테스트 가능하게” 만들면 응집도·가독성·치명 버그 저항성이 좋아진다.
- **디버깅은 반복 가능한 실험**이다. 심볼/플래그/로그/새너타이저/코어덤프를 표준 루틴으로 만들자.
- 지금 바로: 위 `StringUtil` 예제를 **Catch2와 GTest 둘 다**로 빌드→실행→커버리지→ASan로 돌려 보라.  
  “작동하는 안전망”이 생기는 순간, 개발 속도는 자연히 오른다.