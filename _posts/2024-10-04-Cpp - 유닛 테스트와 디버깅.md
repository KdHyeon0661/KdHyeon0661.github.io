---
layout: post
title: C++ - ìœ ë‹› í…ŒìŠ¤íŠ¸ì™€ ë””ë²„ê¹…
date: 2024-10-04 19:20:23 +0900
category: Cpp
---
# C++ ìœ ë‹› í…ŒìŠ¤íŠ¸ì™€ ë””ë²„ê¹…: ì „ë¬¸ê°€ë¥¼ ìœ„í•œ ì™„ë²½ ê°€ì´ë“œ

## ì„œë¡ : í…ŒìŠ¤íŠ¸ì™€ ë””ë²„ê¹…ì´ ì™œ ì¤‘ìš”í•œê°€?

ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œì—ì„œ ê°€ì¥ ë¹„ìš©ì´ ë§ì´ ë“œëŠ” ê²ƒì€ ë²„ê·¸ë¥¼ ìˆ˜ì •í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ **ë²„ê·¸ë¥¼ ì°¾ëŠ” ê²ƒ**ì…ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ì™€ ë””ë²„ê¹…ì€ ë‹¨ìˆœí•œ ê²€ì¦ ë„êµ¬ê°€ ì•„ë‹Œ, ì†Œí”„íŠ¸ì›¨ì–´ì˜ í’ˆì§ˆê³¼ ì‹ ë¢°ì„±ì„ ë³´ì¥í•˜ëŠ” í•µì‹¬ ê³¼ì •ì…ë‹ˆë‹¤. ì˜ ì‘ì„±ëœ í…ŒìŠ¤íŠ¸ëŠ”:

1. **íšŒê·€ ë°©ì§€**: ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê¸°ì¡´ ê¸°ëŠ¥ì´ ê¹¨ì§€ì§€ ì•Šë„ë¡ ë³´ì¥
2. **ì„¤ê³„ ë¬¸ì„œ**: ì½”ë“œê°€ ì–´ë–»ê²Œ ë™ì‘í•´ì•¼ í•˜ëŠ”ì§€ ëª…í™•íˆ ì„¤ëª…
3. **ë¦¬íŒ©í† ë§ ìš©ì´ì„±**: ì•ˆì „í•˜ê²Œ ì½”ë“œ êµ¬ì¡°ë¥¼ ê°œì„ í•  ìˆ˜ ìˆê²Œ í•¨
4. **ë””ë²„ê¹… ì‹œê°„ ë‹¨ì¶•**: ë¬¸ì œê°€ ë°œìƒí–ˆì„ ë•Œ ì›ì¸ì„ ë¹ ë¥´ê²Œ ì°¾ì„ ìˆ˜ ìˆê²Œ í•¨

ì´ ê°€ì´ë“œëŠ” í˜„ëŒ€ C++ ê°œë°œì—ì„œ íš¨ê³¼ì ì¸ í…ŒìŠ¤íŠ¸ì™€ ë””ë²„ê¹…ì„ ìœ„í•œ ì²´ê³„ì ì¸ ì ‘ê·¼ë²•ì„ ì œê³µí•©ë‹ˆë‹¤.

---

## ì œ1ì¥: ì–´ì„œì…˜(Assertion)ì˜ ì¢…ë¥˜ì™€ ì ì ˆí•œ ì‚¬ìš©

### `assert`: ëŸ°íƒ€ì„ ë¶ˆë³€ì‹ ê²€ì‚¬

```cpp
#include <cassert>
#include <iostream>

double calculate_average(const std::vector<int>& numbers) {
    // ì‚¬ì „ì¡°ê±´ ê²€ì‚¬
    assert(!numbers.empty() && "ìˆ«ì ëª©ë¡ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤");
    
    long long sum = 0;
    for (int num : numbers) {
        sum += num;
    }
    
    double average = static_cast<double>(sum) / numbers.size();
    
    // ì‚¬í›„ì¡°ê±´ ê²€ì‚¬
    assert(average >= *std::min_element(numbers.begin(), numbers.end()) &&
           average <= *std::max_element(numbers.begin(), numbers.end()) &&
           "í‰ê· ê°’ì€ ìµœì†Œê°’ê³¼ ìµœëŒ€ê°’ ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤");
    
    return average;
}
```

**ì¤‘ìš”**: `assert`ëŠ” ë””ë²„ê·¸ ë¹Œë“œì—ì„œë§Œ í™œì„±í™”ë©ë‹ˆë‹¤. ë¦´ë¦¬ìŠ¤ ë¹Œë“œì—ì„œëŠ” `NDEBUG` ë§¤í¬ë¡œê°€ ì •ì˜ë˜ì–´ `assert`ê°€ ì œê±°ë©ë‹ˆë‹¤.

### `static_assert`: ì»´íŒŒì¼ íƒ€ì„ ê²€ì‚¬

```cpp
#include <type_traits>
#include <array>

template<typename T>
class FixedSizeBuffer {
    static_assert(std::is_trivially_copyable_v<T>,
                  "TëŠ” ê°„ë‹¨íˆ ë³µì‚¬ ê°€ëŠ¥í•´ì•¼ í•©ë‹ˆë‹¤");
    static_assert(sizeof(T) <= 256,
                  "TëŠ” 256ë°”ì´íŠ¸ ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤");
    
    std::array<T, 1024> buffer_;
    
public:
    // ...
};

// í”Œë«í¼ ê²€ì‚¬
static_assert(sizeof(void*) == 8, "64ë¹„íŠ¸ ì‹œìŠ¤í…œì—ì„œë§Œ ì»´íŒŒì¼ ê°€ëŠ¥í•©ë‹ˆë‹¤");
```

### ì»¤ìŠ¤í…€ ì–´ì„œì…˜: ë¦´ë¦¬ìŠ¤ì—ì„œë„ ë™ì‘í•˜ëŠ” ê²€ì‚¬

```cpp
#include <iostream>
#include <cstdlib>

#ifdef NDEBUG
    #define RELEASE_ASSERT(condition, message) \
        do { \
            if (!(condition)) { \
                std::cerr << "Assertion failed: " << #condition \
                          << ", " << message << " (" << __FILE__ \
                          << ":" << __LINE__ << ")" << std::endl; \
                std::abort(); \
            } \
        } while (false)
#else
    #define RELEASE_ASSERT(condition, message) assert((condition) && message)
#endif

void process_sensitive_data(int* data, size_t size) {
    RELEASE_ASSERT(data != nullptr, "ë°ì´í„° í¬ì¸í„°ëŠ” nullptrì´ ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
    RELEASE_ASSERT(size > 0, "ë°ì´í„° í¬ê¸°ëŠ” 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤");
    // ...
}
```

---

## ì œ2ì¥: Catch2 - í˜„ëŒ€ì ì´ê³  ê°„ê²°í•œ í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬

### ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì‘ì„±

```cpp
#define CATCH_CONFIG_MAIN  // í…ŒìŠ¤íŠ¸ ì‹¤í–‰ê¸°ë¥¼ ìƒì„±
#include <catch2/catch.hpp>

#include <string>
#include <vector>

// í…ŒìŠ¤íŠ¸í•  í•¨ìˆ˜
std::string reverse_string(const std::string& input) {
    return std::string(input.rbegin(), input.rend());
}

TEST_CASE("ë¬¸ìì—´ ë’¤ì§‘ê¸° í…ŒìŠ¤íŠ¸") {
    SECTION("ê¸°ë³¸ ë¬¸ìì—´") {
        REQUIRE(reverse_string("hello") == "olleh");
        REQUIRE(reverse_string("world") == "dlrow");
    }
    
    SECTION("íŠ¹ìˆ˜ ì¼€ì´ìŠ¤") {
        REQUIRE(reverse_string("") == "");           // ë¹ˆ ë¬¸ìì—´
        REQUIRE(reverse_string("a") == "a");         // ë‹¨ì¼ ë¬¸ì
        REQUIRE(reverse_string("ab") == "ba");       // ë‘ ë¬¸ì
        REQUIRE(reverse_string("aba") == "aba");     // íšŒë¬¸
    }
    
    SECTION("ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´") {
        REQUIRE(reverse_string("ì•ˆë…•") == "ë…•ì•ˆ");
        REQUIRE(reverse_string("ğŸ‰ğŸŒŸ") == "ğŸŒŸğŸ‰");
    }
}
```

### BDD(í–‰ìœ„ ì£¼ë„ ê°œë°œ) ìŠ¤íƒ€ì¼

```cpp
SCENARIO("ì‚¬ìš©ì ì¸ì¦ ì‹œìŠ¤í…œ", "[auth]") {
    GIVEN("ìœ íš¨í•œ ìê²© ì¦ëª…ì„ ê°€ì§„ ì‚¬ìš©ì") {
        std::string username = "alice";
        std::string password = "secure123";
        
        WHEN("ì˜¬ë°”ë¥¸ ë¹„ë°€ë²ˆí˜¸ë¡œ ë¡œê·¸ì¸ ì‹œë„") {
            bool result = authenticate(username, password);
            
            THEN("ì¸ì¦ ì„±ê³µ") {
                REQUIRE(result == true);
            }
        }
        
        WHEN("ì˜ëª»ëœ ë¹„ë°€ë²ˆí˜¸ë¡œ ë¡œê·¸ì¸ ì‹œë„") {
            bool result = authenticate(username, "wrong");
            
            THEN("ì¸ì¦ ì‹¤íŒ¨") {
                REQUIRE(result == false);
            }
        }
    }
    
    GIVEN("ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì‚¬ìš©ì") {
        WHEN("ë¡œê·¸ì¸ ì‹œë„") {
            bool result = authenticate("nonexistent", "any");
            
            THEN("ì¸ì¦ ì‹¤íŒ¨") {
                REQUIRE(result == false);
            }
        }
    }
}
```

### ë§¤ê°œë³€ìˆ˜í™”ëœ í…ŒìŠ¤íŠ¸

```cpp
#include <catch2/catch.hpp>
#include <catch2/generators/catch_generators.hpp>

TEST_CASE("ì œê³± í•¨ìˆ˜ í…ŒìŠ¤íŠ¸") {
    auto [input, expected] = GENERATE(
        std::make_tuple(0, 0),
        std::make_tuple(1, 1),
        std::make_tuple(2, 4),
        std::make_tuple(3, 9),
        std::make_tuple(-3, 9)
    );
    
    CAPTURE(input, expected);  // ì‹¤íŒ¨ ì‹œ ê°’ ì¶œë ¥
    REQUIRE(square(input) == expected);
}
```

### ì˜ˆì™¸ í…ŒìŠ¤íŠ¸

```cpp
TEST_CASE("ì˜ˆì™¸ ë°œìƒ í…ŒìŠ¤íŠ¸") {
    SECTION("íŠ¹ì • ì˜ˆì™¸ íƒ€ì… ê²€ì‚¬") {
        REQUIRE_THROWS_AS(divide(10, 0), std::invalid_argument);
    }
    
    SECTION("ì˜ˆì™¸ ë©”ì‹œì§€ ê²€ì‚¬") {
        REQUIRE_THROWS_WITH(divide(10, 0), "0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
    }
    
    SECTION("ì˜ˆì™¸ê°€ ë°œìƒí•˜ì§€ ì•Šì•„ì•¼ í•˜ëŠ” ê²½ìš°") {
        REQUIRE_NOTHROW(divide(10, 2));
    }
}
```

---

## ì œ3ì¥: Google Test - ê¸°ì—…ìš© í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬

### ê¸°ë³¸ í…ŒìŠ¤íŠ¸ êµ¬ì¡°

```cpp
#include <gtest/gtest.h>

// í…ŒìŠ¤íŠ¸í•  í´ë˜ìŠ¤
class Calculator {
public:
    int add(int a, int b) { return a + b; }
    int multiply(int a, int b) { return a * b; }
    double divide(double a, double b) {
        if (b == 0.0) {
            throw std::invalid_argument("0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
        }
        return a / b;
    }
};

// ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸
TEST(CalculatorTest, Addition) {
    Calculator calc;
    EXPECT_EQ(calc.add(2, 3), 5);
    EXPECT_EQ(calc.add(-1, 1), 0);
    EXPECT_EQ(calc.add(0, 0), 0);
}

// ì˜ˆì™¸ í…ŒìŠ¤íŠ¸
TEST(CalculatorTest, DivisionByZero) {
    Calculator calc;
    EXPECT_THROW(calc.divide(10, 0), std::invalid_argument);
    EXPECT_NO_THROW(calc.divide(10, 2));
}
```

### í…ŒìŠ¤íŠ¸ í”½ìŠ¤ì²˜

```cpp
class DatabaseTest : public ::testing::Test {
protected:
    // ê° í…ŒìŠ¤íŠ¸ ì „ì— ì‹¤í–‰
    void SetUp() override {
        database_.connect("test.db");
        database_.clear();
    }
    
    // ê° í…ŒìŠ¤íŠ¸ í›„ì— ì‹¤í–‰
    void TearDown() override {
        database_.disconnect();
    }
    
    // í—¬í¼ í•¨ìˆ˜
    void insert_sample_data() {
        database_.insert("user1", "data1");
        database_.insert("user2", "data2");
    }
    
    Database database_;
};

TEST_F(DatabaseTest, InsertAndRetrieve) {
    database_.insert("test_key", "test_value");
    EXPECT_EQ(database_.get("test_key"), "test_value");
}

TEST_F(DatabaseTest, ClearDatabase) {
    insert_sample_data();
    database_.clear();
    EXPECT_TRUE(database_.is_empty());
}
```

### í˜•ì‹í™”ëœ í…ŒìŠ¤íŠ¸

```cpp
struct TestCase {
    int a;
    int b;
    int expected_sum;
    int expected_product;
};

class ParameterizedMathTest : 
    public ::testing::TestWithParam<TestCase> {};

TEST_P(ParameterizedMathTest, AllOperations) {
    Calculator calc;
    const auto& param = GetParam();
    
    EXPECT_EQ(calc.add(param.a, param.b), param.expected_sum);
    EXPECT_EQ(calc.multiply(param.a, param.b), param.expected_product);
}

INSTANTIATE_TEST_SUITE_P(
    MathTests,
    ParameterizedMathTest,
    ::testing::Values(
        TestCase{1, 2, 3, 2},
        TestCase{0, 5, 5, 0},
        TestCase{-3, 3, 0, -9},
        TestCase{10, -2, 8, -20}
    )
);
```

### Google Mock - ëª¨ì˜ ê°ì²´

```cpp
#include <gmock/gmock.h>

// ì¸í„°í˜ì´ìŠ¤
class ILogger {
public:
    virtual ~ILogger() = default;
    virtual void log(const std::string& message) = 0;
    virtual void error(const std::string& message) = 0;
    virtual bool is_enabled() const = 0;
};

// ëª¨ì˜ í´ë˜ìŠ¤
class MockLogger : public ILogger {
public:
    MOCK_METHOD(void, log, (const std::string&), (override));
    MOCK_METHOD(void, error, (const std::string&), (override));
    MOCK_METHOD(bool, is_enabled, (), (const, override));
};

// ëª¨ì˜ ê°ì²´ë¥¼ ì‚¬ìš©í•˜ëŠ” í…ŒìŠ¤íŠ¸
TEST(ServiceTest, UsesLoggerCorrectly) {
    MockLogger mock_logger;
    Service service(mock_logger);
    
    // ê¸°ëŒ€ì‚¬í•­ ì„¤ì •
    EXPECT_CALL(mock_logger, is_enabled())
        .WillOnce(::testing::Return(true));
    
    EXPECT_CALL(mock_logger, log(::testing::HasSubstr("ì‹œì‘")))
        .Times(1);
    
    EXPECT_CALL(mock_logger, error(::testing::_))
        .Times(0);  // ì—ëŸ¬ê°€ í˜¸ì¶œë˜ì§€ ì•Šì•„ì•¼ í•¨
    
    // ì‹¤í–‰
    service.process();
}
```

---

## ì œ4ì¥: í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ì™€ ì •ì  ë¶„ì„

### GCC/Clang ì»¤ë²„ë¦¬ì§€ ì¸¡ì •

```bash
# Clangì—ì„œ ì»´íŒŒì¼
clang++ -std=c++17 -g -O0 --coverage -o mytests tests.cpp source.cpp

# í…ŒìŠ¤íŠ¸ ì‹¤í–‰
./mytests

# ì»¤ë²„ë¦¬ì§€ ë°ì´í„° ë³‘í•©
llvm-profdata merge -sparse default.profraw -o default.profdata

# ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„±
llvm-cov show ./mytests -instr-profile=default.profdata
llvm-cov report ./mytests -instr-profile=default.profdata

# HTML ë¦¬í¬íŠ¸
llvm-cov show ./mytests -instr-profile=default.profdata -format=html -o coverage_report
```

### CMakeì™€ í†µí•©

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.15)
project(MyProject LANGUAGES CXX)

# ì»¤ë²„ë¦¬ì§€ í”Œë˜ê·¸
if(CMAKE_CXX_COMPILER_ID MATCHES "Clang|GNU")
    set(COVERAGE_FLAGS "--coverage -fprofile-arcs -ftest-coverage")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${COVERAGE_FLAGS}")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${COVERAGE_FLAGS}")
endif()

# í…ŒìŠ¤íŠ¸ ì¶”ê°€
add_executable(mytests tests.cpp source.cpp)
add_test(NAME mytests COMMAND mytests)
```

---

## ì œ5ì¥: Sanitizers - ëŸ°íƒ€ì„ ë©”ëª¨ë¦¬ ê²€ì‚¬

### AddressSanitizer (ASan)

```cpp
#include <iostream>
#include <vector>

// ë²„ê·¸ê°€ ìˆëŠ” ì½”ë“œ
void memory_bugs() {
    // 1. íˆí”„ ë²„í¼ ì˜¤ë²„í”Œë¡œìš°
    int* array = new int[10];
    array[10] = 42;  // ì˜¤ë²„í”Œë¡œìš°!
    delete[] array;
    
    // 2. ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°
    int stack_array[10];
    stack_array[10] = 42;  // ì˜¤ë²„í”Œë¡œìš°!
    
    // 3. use-after-free
    int* ptr = new int(42);
    delete ptr;
    *ptr = 100;  // ì´ë¯¸ í•´ì œëœ ë©”ëª¨ë¦¬ ì‚¬ìš©!
    
    // 4. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜
    int* leaked = new int(42);
    // delete ëˆ„ë½
}
```

ì»´íŒŒì¼ ë° ì‹¤í–‰:
```bash
clang++ -g -fsanitize=address -fno-omit-frame-pointer buggy.cpp -o buggy
./buggy  # ASanì´ ë²„ê·¸ë¥¼ ì¦‰ì‹œ ê°ì§€í•˜ê³  ë¦¬í¬íŠ¸
```

### UndefinedBehaviorSanitizer (UBSan)

```cpp
#include <iostream>
#include <limits>

void undefined_behaviors() {
    // 1. ë¶€í˜¸ ìˆëŠ” ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš°
    int max_int = std::numeric_limits<int>::max();
    int overflow = max_int + 1;  // ë¯¸ì •ì˜ ë™ì‘!
    
    // 2. ë„ í¬ì¸í„° ì—­ì°¸ì¡°
    int* ptr = nullptr;
    int value = *ptr;  // ë¯¸ì •ì˜ ë™ì‘!
    
    // 3. ì˜ëª»ëœ ì‹œí”„íŠ¸
    int x = 1;
    int invalid_shift = x << 32;  // 32ë¹„íŠ¸ í”Œë«í¼ì—ì„œ ë¯¸ì •ì˜ ë™ì‘!
    
    // 4. ì •ë ¬ë˜ì§€ ì•Šì€ ì ‘ê·¼
    char buffer[10];
    int* misaligned = reinterpret_cast<int*>(&buffer[1]);
    *misaligned = 42;  // ì •ë ¬ë˜ì§€ ì•Šì€ ì ‘ê·¼!
}
```

ì»´íŒŒì¼ ë° ì‹¤í–‰:
```bash
clang++ -g -fsanitize=undefined buggy.cpp -o buggy
./buggy  # UBSanì´ ë¯¸ì •ì˜ ë™ì‘ì„ ê°ì§€
```

### ThreadSanitizer (TSan)

```cpp
#include <thread>
#include <vector>
#include <iostream>

int shared_counter = 0;

void increment_counter() {
    for (int i = 0; i < 100000; ++i) {
        // ë½ ì—†ì´ ê³µìœ  ë³€ìˆ˜ ì ‘ê·¼ - ë°ì´í„° ë ˆì´ìŠ¤!
        ++shared_counter;
    }
}

void data_race_example() {
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment_counter);
    }
    
    for (auto& thread : threads) {
        thread.join();
    }
    
    std::cout << "Counter: " << shared_counter << std::endl;
}
```

ì»´íŒŒì¼ ë° ì‹¤í–‰:
```bash
clang++ -g -fsanitize=thread -fPIE -pie race.cpp -o race
./race  # TSanì´ ë°ì´í„° ë ˆì´ìŠ¤ë¥¼ ê°ì§€
```

---

## ì œ6ì¥: GDBì™€ LLDB ë””ë²„ê¹… ì‹¤ë¬´

### GDB ê¸°ë³¸ ì‚¬ìš©ë²•

```cpp
// debug_example.cpp
#include <iostream>
#include <vector>

int calculate_sum(const std::vector<int>& numbers) {
    int sum = 0;
    for (size_t i = 0; i <= numbers.size(); ++i) {  // ë²„ê·¸: <= ëŒ€ì‹  < ì‚¬ìš©í•´ì•¼ í•¨
        sum += numbers[i];
    }
    return sum;
}

int main() {
    std::vector<int> data = {1, 2, 3, 4, 5};
    int result = calculate_sum(data);
    std::cout << "Sum: " << result << std::endl;
    return 0;
}
```

ë””ë²„ê¹… ê³¼ì •:
```bash
# ë””ë²„ê·¸ ì‹¬ë³¼ í¬í•¨í•˜ì—¬ ì»´íŒŒì¼
g++ -g -O0 debug_example.cpp -o debug_example

# GDB ì‹œì‘
gdb ./debug_example

# GDB ëª…ë ¹ì–´
(gdb) break main               # main í•¨ìˆ˜ì— ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ì„¤ì •
(gdb) run                      # í”„ë¡œê·¸ë¨ ì‹¤í–‰
(gdb) next                     # ë‹¤ìŒ ì¤„ ì‹¤í–‰ (step over)
(gdb) step                     # í•¨ìˆ˜ ë‚´ë¶€ë¡œ ë“¤ì–´ê°€ê¸° (step into)
(gdb) print data               # ë³€ìˆ˜ ê°’ ì¶œë ¥
(gdb) print data.size()        # ë©¤ë²„ í•¨ìˆ˜ í˜¸ì¶œ
(gdb) break calculate_sum      # í•¨ìˆ˜ì— ë¸Œë ˆì´í¬í¬ì¸íŠ¸
(gdb) continue                 # ë‹¤ìŒ ë¸Œë ˆì´í¬í¬ì¸íŠ¸ê¹Œì§€ ê³„ì†
(gdb) watch sum                # ë³€ìˆ˜ ê°’ ë³€ê²½ ê°ì‹œ
(gdb) backtrace                # í˜¸ì¶œ ìŠ¤íƒ ì¶œë ¥
(gdb) frame 1                  # íŠ¹ì • í”„ë ˆì„ìœ¼ë¡œ ì´ë™
(gdb) info locals              # ì§€ì—­ ë³€ìˆ˜ ëª©ë¡
(gdb) info breakpoints         # ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ëª©ë¡
(gdb) delete breakpoint 1      # ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ì‚­ì œ
(gdb) quit                     # GDB ì¢…ë£Œ
```

### ì¡°ê±´ë¶€ ë¸Œë ˆì´í¬í¬ì¸íŠ¸

```bash
(gdb) break calculate_sum if i == 3        # iê°€ 3ì¼ ë•Œ ë©ˆì¶¤
(gdb) break main.cpp:15 if sum > 100       # íŠ¹ì • ì¤„ì—ì„œ ì¡°ê±´ë¶€
(gdb) command 1                            # ë¸Œë ˆì´í¬í¬ì¸íŠ¸ 1ì— ëª…ë ¹ì–´ ì—°ê²°
> print i
> print numbers[i]
> continue
> end
```

### ì½”ì–´ ë¤í”„ ë¶„ì„

```bash
# ì½”ì–´ ë¤í”„ í™œì„±í™”
ulimit -c unlimited

# í”„ë¡œê·¸ë¨ ì‹¤í–‰ (ì„¸ê·¸í´íŠ¸ ë°œìƒ)
./crashing_program

# ì½”ì–´ ë¤í”„ ë¶„ì„
gdb ./crashing_program core
(gdb) backtrace
(gdb) frame 0
(gdb) info locals
```

### LLDB (macOS/Clang)

```bash
# LLDB ì‚¬ìš© (macOS)
lldb ./debug_example
(lldb) breakpoint set --name main
(lldb) run
(lldb) n          # next
(lldb) s          # step
(lldb) p data     # print
(lldb) bt         # backtrace
(lldb) frame variable  # ì§€ì—­ ë³€ìˆ˜
(lldb) quit
```

---

## ì œ7ì¥: í†µí•© ì˜ˆì œ - ì€í–‰ ê³„ì¢Œ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸

### êµ¬í˜„ ì½”ë“œ

```cpp
// account.h
#pragma once
#include <string>
#include <stdexcept>

class InsufficientFundsException : public std::runtime_error {
public:
    InsufficientFundsException(const std::string& message)
        : std::runtime_error(message) {}
};

class Account {
private:
    std::string account_number_;
    std::string owner_name_;
    double balance_;
    double overdraft_limit_;
    
public:
    Account(const std::string& acc_num, const std::string& owner, 
            double initial_balance = 0.0, double overdraft = 0.0);
    
    const std::string& get_account_number() const { return account_number_; }
    const std::string& get_owner_name() const { return owner_name_; }
    double get_balance() const { return balance_; }
    double get_overdraft_limit() const { return overdraft_limit_; }
    
    void deposit(double amount);
    void withdraw(double amount);
    void transfer_to(Account& destination, double amount);
    
    bool can_withdraw(double amount) const;
};

// account.cpp
#include "account.h"
#include <algorithm>

Account::Account(const std::string& acc_num, const std::string& owner, 
                 double initial_balance, double overdraft)
    : account_number_(acc_num), owner_name_(owner),
      balance_(initial_balance), overdraft_limit_(std::max(0.0, overdraft)) {
    
    if (initial_balance < 0) {
        throw std::invalid_argument("ì´ˆê¸° ì”ì•¡ì€ ìŒìˆ˜ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
    }
    if (overdraft < 0) {
        throw std::invalid_argument("ëŒ€ì¶œ í•œë„ëŠ” ìŒìˆ˜ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
    }
}

void Account::deposit(double amount) {
    if (amount <= 0) {
        throw std::invalid_argument("ì…ê¸ˆì•¡ì€ 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤");
    }
    balance_ += amount;
}

void Account::withdraw(double amount) {
    if (amount <= 0) {
        throw std::invalid_argument("ì¶œê¸ˆì•¡ì€ 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤");
    }
    
    if (!can_withdraw(amount)) {
        throw InsufficientFundsException("ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤");
    }
    
    balance_ -= amount;
}

bool Account::can_withdraw(double amount) const {
    return amount <= (balance_ + overdraft_limit_);
}

void Account::transfer_to(Account& destination, double amount) {
    if (this == &destination) {
        throw std::invalid_argument("ê°™ì€ ê³„ì¢Œë¡œì˜ ì´ì²´ëŠ” ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤");
    }
    
    withdraw(amount);
    destination.deposit(amount);
}
```

### Catch2 í…ŒìŠ¤íŠ¸

```cpp
// test_account_catch.cpp
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
#include "account.h"

TEST_CASE("ê³„ì¢Œ ìƒì„± ë° ê¸°ë³¸ ê¸°ëŠ¥", "[account]") {
    SECTION("ìœ íš¨í•œ ê³„ì¢Œ ìƒì„±") {
        Account acc("123456", "í™ê¸¸ë™", 1000.0);
        
        REQUIRE(acc.get_account_number() == "123456");
        REQUIRE(acc.get_owner_name() == "í™ê¸¸ë™");
        REQUIRE(acc.get_balance() == 1000.0);
        REQUIRE(acc.get_overdraft_limit() == 0.0);
    }
    
    SECTION("ìŒìˆ˜ ì´ˆê¸° ì”ì•¡ ì˜ˆì™¸") {
        REQUIRE_THROWS_AS(
            Account("123", "í™ê¸¸ë™", -100.0),
            std::invalid_argument
        );
    }
    
    SECTION("ëŒ€ì¶œ í•œë„ í¬í•¨ ê³„ì¢Œ") {
        Account acc("789", "ê¹€ì² ìˆ˜", 500.0, 1000.0);
        REQUIRE(acc.get_overdraft_limit() == 1000.0);
        REQUIRE(acc.can_withdraw(1500.0) == true);   // 500 + 1000 = 1500
        REQUIRE(acc.can_withdraw(1501.0) == false);
    }
}

TEST_CASE("ì…ì¶œê¸ˆ í…ŒìŠ¤íŠ¸", "[account][transactions]") {
    Account acc("123", "í™ê¸¸ë™", 1000.0);
    
    SECTION("ì •ìƒ ì…ê¸ˆ") {
        acc.deposit(500.0);
        REQUIRE(acc.get_balance() == 1500.0);
    }
    
    SECTION("ìŒìˆ˜ ì…ê¸ˆ ì˜ˆì™¸") {
        REQUIRE_THROWS_AS(acc.deposit(-100.0), std::invalid_argument);
    }
    
    SECTION("ì •ìƒ ì¶œê¸ˆ") {
        acc.withdraw(300.0);
        REQUIRE(acc.get_balance() == 700.0);
    }
    
    SECTION("ì”ì•¡ ì´ˆê³¼ ì¶œê¸ˆ ì˜ˆì™¸") {
        REQUIRE_THROWS_AS(acc.withdraw(2000.0), InsufficientFundsException);
    }
    
    SECTION("ëŒ€ì¶œ í•œë„ ë‚´ ì¶œê¸ˆ") {
        Account acc_with_overdraft("456", "ê¹€ì˜í¬", 100.0, 400.0);
        acc_with_overdraft.withdraw(500.0);  // 100 + 400 = 500
        REQUIRE(acc_with_overdraft.get_balance() == -400.0);
    }
}

TEST_CASE("ê³„ì¢Œ ì´ì²´ í…ŒìŠ¤íŠ¸", "[account][transfer]") {
    Account alice("111", "Alice", 1000.0);
    Account bob("222", "Bob", 500.0);
    
    SECTION("ì •ìƒ ì´ì²´") {
        alice.transfer_to(bob, 300.0);
        REQUIRE(alice.get_balance() == 700.0);
        REQUIRE(bob.get_balance() == 800.0);
    }
    
    SECTION("ì”ì•¡ ë¶€ì¡± ì´ì²´ ì˜ˆì™¸") {
        REQUIRE_THROWS_AS(alice.transfer_to(bob, 2000.0), 
                         InsufficientFundsException);
        // ì›ë³¸ ê³„ì¢Œ ìƒíƒœ ìœ ì§€ í™•ì¸
        REQUIRE(alice.get_balance() == 1000.0);
        REQUIRE(bob.get_balance() == 500.0);
    }
    
    SECTION("ê°™ì€ ê³„ì¢Œ ì´ì²´ ì˜ˆì™¸") {
        REQUIRE_THROWS_AS(alice.transfer_to(alice, 100.0), 
                         std::invalid_argument);
    }
}
```

### Google Test í…ŒìŠ¤íŠ¸

```cpp
// test_account_gtest.cpp
#include <gtest/gtest.h>
#include "account.h"

class AccountTest : public ::testing::Test {
protected:
    void SetUp() override {
        normal_account = std::make_unique<Account>("123", "í™ê¸¸ë™", 1000.0);
        overdraft_account = std::make_unique<Account>("456", "ê¹€ì˜í¬", 100.0, 400.0);
    }
    
    std::unique_ptr<Account> normal_account;
    std::unique_ptr<Account> overdraft_account;
};

TEST_F(AccountTest, Initialization) {
    EXPECT_EQ(normal_account->get_account_number(), "123");
    EXPECT_EQ(normal_account->get_owner_name(), "í™ê¸¸ë™");
    EXPECT_DOUBLE_EQ(normal_account->get_balance(), 1000.0);
    EXPECT_DOUBLE_EQ(normal_account->get_overdraft_limit(), 0.0);
}

TEST_F(AccountTest, Deposit) {
    normal_account->deposit(500.0);
    EXPECT_DOUBLE_EQ(normal_account->get_balance(), 1500.0);
}

TEST_F(AccountTest, DepositNegativeAmount) {
    EXPECT_THROW(normal_account->deposit(-100.0), std::invalid_argument);
}

TEST_F(AccountTest, Withdraw) {
    normal_account->withdraw(300.0);
    EXPECT_DOUBLE_EQ(normal_account->get_balance(), 700.0);
}

TEST_F(AccountTest, WithdrawInsufficientFunds) {
    EXPECT_THROW(normal_account->withdraw(2000.0), InsufficientFundsException);
}

TEST_F(AccountTest, WithdrawWithOverdraft) {
    overdraft_account->withdraw(500.0);  // 100 + 400 = 500
    EXPECT_DOUBLE_EQ(overdraft_account->get_balance(), -400.0);
}

TEST_F(AccountTest, CanWithdraw) {
    EXPECT_TRUE(normal_account->can_withdraw(800.0));
    EXPECT_FALSE(normal_account->can_withdraw(1200.0));
    EXPECT_TRUE(overdraft_account->can_withdraw(500.0));   // 100 + 400
    EXPECT_FALSE(overdraft_account->can_withdraw(501.0));
}

class TransferTest : public ::testing::Test {
protected:
    void SetUp() override {
        account1 = std::make_unique<Account>("111", "Alice", 1000.0);
        account2 = std::make_unique<Account>("222", "Bob", 500.0);
    }
    
    std::unique_ptr<Account> account1;
    std::unique_ptr<Account> account2;
};

TEST_F(TransferTest, SuccessfulTransfer) {
    account1->transfer_to(*account2, 300.0);
    EXPECT_DOUBLE_EQ(account1->get_balance(), 700.0);
    EXPECT_DOUBLE_EQ(account2->get_balance(), 800.0);
}

TEST_F(TransferTest, TransferToSelf) {
    EXPECT_THROW(account1->transfer_to(*account1, 100.0), std::invalid_argument);
}

TEST_F(TransferTest, InsufficientFundsTransfer) {
    EXPECT_THROW(account1->transfer_to(*account2, 2000.0), 
                 InsufficientFundsException);
    // íŠ¸ëœì­ì…˜ ì›ìì„± í™•ì¸
    EXPECT_DOUBLE_EQ(account1->get_balance(), 1000.0);
    EXPECT_DOUBLE_EQ(account2->get_balance(), 500.0);
}

// ë§¤ê°œë³€ìˆ˜í™” í…ŒìŠ¤íŠ¸
struct TransferTestCase {
    double initial_balance1;
    double initial_balance2;
    double transfer_amount;
    double expected_balance1;
    double expected_balance2;
    bool should_succeed;
};

class ParameterizedTransferTest : 
    public ::testing::TestWithParam<TransferTestCase> {};

TEST_P(ParameterizedTransferTest, Transfer) {
    const auto& param = GetParam();
    
    Account acc1("111", "Alice", param.initial_balance1);
    Account acc2("222", "Bob", param.initial_balance2);
    
    if (param.should_succeed) {
        acc1.transfer_to(acc2, param.transfer_amount);
        EXPECT_DOUBLE_EQ(acc1.get_balance(), param.expected_balance1);
        EXPECT_DOUBLE_EQ(acc2.get_balance(), param.expected_balance2);
    } else {
        EXPECT_THROW(acc1.transfer_to(acc2, param.transfer_amount),
                     InsufficientFundsException);
    }
}

INSTANTIATE_TEST_SUITE_P(
    TransferTests,
    ParameterizedTransferTest,
    ::testing::Values(
        TransferTestCase{1000, 500, 300, 700, 800, true},
        TransferTestCase{500, 1000, 500, 0, 1500, true},
        TransferTestCase{100, 100, 1000, 100, 100, false},
        TransferTestCase{0, 1000, 1, 0, 1000, false}
    )
);
```

---

## ê²°ë¡ : ì „ë¬¸ê°€ ìˆ˜ì¤€ì˜ í…ŒìŠ¤íŠ¸ì™€ ë””ë²„ê¹… ë¬¸í™” êµ¬ì¶•

### 1. **í…ŒìŠ¤íŠ¸ ìš°ì„  ê°œë°œì˜ ê°€ì¹˜**
   - í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ê¸° ì „ì— ì‹¤íŒ¨í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”
   - ê°€ì¥ ì¤‘ìš”í•œ ê¸°ëŠ¥ë¶€í„° í…ŒìŠ¤íŠ¸í•˜ì„¸ìš”
   - í…ŒìŠ¤íŠ¸ëŠ” ë¬¸ì„œ ì—­í• ë„ í•©ë‹ˆë‹¤

### 2. **ì ì ˆí•œ ë„êµ¬ ì„ íƒ**
   - ì†Œê·œëª¨ í”„ë¡œì íŠ¸: Catch2 (ê°€ë²¼ì›€ê³¼ ê°„ê²°í•¨)
   - ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸: Google Test (í’ë¶€í•œ ê¸°ëŠ¥ê³¼ ê¸°ì—… ì§€ì›)
   - ëª¨í‚¹ í•„ìš” ì‹œ: Google Mock

### 3. **ì»¤ë²„ë¦¬ì§€ì™€ í’ˆì§ˆ ì§€í‘œ**
   - ëª©í‘œ ì»¤ë²„ë¦¬ì§€ ì„¤ì • (ì¼ë°˜ì ìœ¼ë¡œ 80-90%)
   - ë¸Œëœì¹˜ ì»¤ë²„ë¦¬ì§€ë„ ì¸¡ì •í•˜ì„¸ìš”
   - ë®¤í…Œì´ì…˜ í…ŒìŠ¤íŠ¸ë¡œ í…ŒìŠ¤íŠ¸ íš¨ê³¼ì„± í‰ê°€

### 4. **ìë™í™”ì™€ CI/CD í†µí•©**
   - ëª¨ë“  í‘¸ì‹œì—ì„œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
   - ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìë™ ìƒì„±
   - Sanitizersë¥¼ í†µí•œ ë©”ëª¨ë¦¬ ì˜¤ë¥˜ ê²€ì‚¬

### 5. **ë””ë²„ê¹… ì² í•™**
   - ì¬í˜„ ê°€ëŠ¥í•œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ìƒì„±
   - ì¦ë¶„ì  ì ‘ê·¼: ë¬¸ì œë¥¼ ì‘ì€ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆ„ê¸°
   - ê°€ì • ê²€ì¦: ì¶”ì¸¡í•˜ì§€ ë§ê³  ê²€ì¦í•˜ì„¸ìš”

### 6. **íŒ€ ë¬¸í™” êµ¬ì¶•**
   - ì½”ë“œ ë¦¬ë·° ì‹œ í…ŒìŠ¤íŠ¸ ê²€í†  í¬í•¨
   - í…ŒìŠ¤íŠ¸ ì‘ì„± ì‹œê°„ ê³„íšì— í¬í•¨
   - í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ë¥¼ í•™ìŠµ ê¸°íšŒë¡œ í™œìš©

í…ŒìŠ¤íŠ¸ì™€ ë””ë²„ê¹…ì€ ë‹¨ìˆœí•œ ê¸°ìˆ ì´ ì•„ë‹Œ ë§ˆì¸ë“œì…‹ì…ë‹ˆë‹¤. ì´ëŠ” ì½”ë“œì— ëŒ€í•œ í™•ì‹ ì„ ì£¼ê³ , ë³€ê²½ì„ ë‘ë µì§€ ì•Šê²Œ í•˜ë©°, ê¶ê·¹ì ìœ¼ë¡œ ë” ë‚˜ì€ ì†Œí”„íŠ¸ì›¨ì–´ë¥¼ ë§Œë“œëŠ” ê¸¸ì…ë‹ˆë‹¤. ê¸°ì–µí•˜ì„¸ìš”: ë²„ê·¸ë¥¼ ë¯¸ë¦¬ ì°¾ëŠ” ë° íˆ¬ìí•œ ì‹œê°„ì€ ë‚˜ì¤‘ì— ë””ë²„ê¹…í•˜ëŠ” ë° ë“œëŠ” ì‹œê°„ë³´ë‹¤ í›¨ì”¬ ì ìŠµë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ì™€ ë””ë²„ê¹…ì„ ê°œë°œ í”„ë¡œì„¸ìŠ¤ì˜ í•„ìˆ˜ ë¶€ë¶„ìœ¼ë¡œ ë§Œë“¤ë©´, ë” ì•ˆì •ì ì´ê³  ìœ ì§€ë³´ìˆ˜ ê°€ëŠ¥í•œ ì†Œí”„íŠ¸ì›¨ì–´ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.