---
layout: post
title: 컴퓨터시스템 - 메모리 보호를 위한 도구로서의 VM
date: 2025-08-16 23:20:23 +0900
category: 컴퓨터시스템
---
# 메모리 보호를 위한 도구로서의 가상 메모리(VM)

## 0. 큰 그림

```
사용자 프로세스(각자 독립 VA 공간)
  ├─ 코드(.text)     R- X
  ├─ 데이터(.data)   RW-
  ├─ 읽기전용(.ro)   R--
  ├─ 힙(Heap)        RW-  ← brk/mmap
  ├─ 공유맵핑        R--/RW-  ← shm/mmap
  └─ 스택(Stack)     RW-  ← 가드 페이지

하드웨어(MMU/TLB)
  VA ──(TLB 조회)──▶ PA
            │미스
            └─ 다단계 페이지테이블(권한비트 검사: R/W/X, U/S, NX/UXN)

커널 정책(보안/성능)
  - 주소공간 분리(User↔Kernel), KPTI, KASLR
  - 권한: W^X, mprotect/pkey_mprotect, SMEP/SMAP
  - 예외: Page Fault → 시그널(SIGSEGV) 또는 커널 핸들링
```

---

## 1. 보호 목표(Threat Model)와 보안 성질

- **격리(Isolation)**: 한 프로세스가 다른 프로세스/커널 메모리에 접근 불가.
- **무결성/기밀성**: 페이지 권한(R/W/X)으로 쓰기·읽기·실행을 분리.
- **가용성**: 잘못된 접근은 **예외**로 격리 종료(크래시), 시스템 전체 영향 최소화.
- **완화(Mitigation)**: ASLR, NX, SMEP/SMAP, W^X, KPTI 등으로 취약점 악용 난이도 상승.

---

## 2. 하드웨어 보호 메커니즘(요점 정리)

### 2.1 MMU & 페이지테이블 권한비트
- x86-64 PTE 주요 비트: **P(존재), RW, US(User/Supervisor), NX(Execute Disable)**, A/D(Access/Dirty), PAT 등.
- ARMv8(AArch64) PTE: {% highlight text %} AP[2:1](R/W){% endhighlight %}, UXN/ PXN(Execute-Never), AttrIndx(캐시속성).

### 2.2 실행 방지(XD/NX, UXN/PXN)
- **데이터 영역 실행 금지**로 코드주입/ROP 난이도 상승. 스택/힙은 기본 **NX** 권장.

### 2.3 권한 상승 차단(플랫폼 보강)
- **SMEP(x86)**: 사용자 공간 주소를 **커널 모드에서 실행 금지**.
- **SMAP(x86)**: 커널이 사용자 페이지 **읽기/쓰기 금지**(명시적 우회 필요).
- **KPTI**: 사용자/커널 **페이지테이블 분리**로 커널 주소노출·측채널 완화.

### 2.4 메모리 보호키(MPK, x86)** / **메모리 태깅(MTE, ARMv8.5+)**
- **MPK**: 동일 페이지를 서로 다른 **Protection Key**로 묶고, 사용자 공간에서 **WRPKRU**로 R/W를 저비용 전환.
- **MTE**: 포인터/메모리에 태그를 부여해 **Use-After-Free/Out-of-Bounds** 탐지 강화(하드웨어 지원).

---

## 3. 수학적 관점의 접근 검증

가상주소 \(v\)에 대한 접근 **op**(read/write/exec)가 허용되는 충분조건을 단순화하면:
$$
\text{allow}(v, op) \iff
\underbrace{\text{present}(v)}_{\text{P=1}} \wedge
\underbrace{\text{domain\_ok}(v)}_{\text{U/S 규칙}} \wedge
\underbrace{\text{perms}(v)\ni op}_{\text{R/W/X 비트}} \wedge
\underbrace{\text{policy}(v)}_{\text{SMEP/SMAP/MPK/MTE 등}}
$$
불만족 시 CPU는 **#PF(Page Fault)** 를 발생, 커널이 트랩을 처리한다.

---

## 4. 리눅스 메모리 보호 설계 개요

### 4.1 주소공간 분리 & VMA
- 각 프로세스는 **VMA(가상 메모리 영역) 목록**으로 권한·플래그가 관리됨.
- `/proc/$pid/maps`로 매핑/권한을 관찰 가능.

### 4.2 ASLR & KASLR
- **PIE 실행파일/공유라이브러리/스택/힙/맵핑 베이스** 랜덤화.
- 커널도 **KASLR** 로 섹션 배치 무작위화.

### 4.3 W^X 원칙
- **Write-or-Execute**: 어떤 주소범위도 **동시에 W와 X를 부여하지 않기**.
- JIT 등은 **RW → RX 전환**(mprotect) 패턴을 사용.

---

## 5. 페이지 폴트와 시그널 흐름

1) CPU가 접근 → MMU 권한검사 실패 → **#PF**
2) 커널: 맵핑 부재면 **Demand Paging**/COW 처리, 권한 위반이면 **SIGSEGV**(기본 종료).
3) 사용자 코드에서 `sigaction`으로 핸들러 작성 가능(단, 신중히).

---

## 6. 보호를 활용하는 실전 코드

### 6.1 읽기전용 매핑에 쓰기 → SIGSEGV
```c
// ro_fault.c
#define _GNU_SOURCE
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
    size_t pg = sysconf(_SC_PAGESIZE);
    char* p = mmap(NULL, pg, PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if(p==MAP_FAILED){perror("mmap");return 1;}
    // 읽기는 가능
    printf("R ok: first byte=%d\n", p[0]);
    // 쓰기 시도 → SIGSEGV
    strcpy(p, "Hello"); // crash
    munmap(p, pg);
    return 0;
}
```

### 6.2 SIGSEGV 핸들러로 폴트 주소 로깅(+ 대체 스택)
```c
// segv_log.c
#define _GNU_SOURCE
#include <signal.h>
#include <ucontext.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static stack_t alt;
static void on_segv(int sig, siginfo_t* si, void* ctx){
    (void)ctx;
    fprintf(stderr, "SIGSEGV at %p (code=%d)\n", si->si_addr, si->si_code);
    _exit(139); // 세그폴트 종료코드
}
int main(){
    size_t sz = 1<<20;
    alt.ss_sp = mmap(NULL, sz, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    alt.ss_size = sz; sigaltstack(&alt, NULL);

    struct sigaction sa = {0};
    sa.sa_sigaction = on_segv;
    sa.sa_flags = SA_SIGINFO | SA_ONSTACK;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGSEGV, &sa, NULL);

    // PROT_NONE 가드 페이지 생성
    size_t pg = sysconf(_SC_PAGESIZE);
    char* p = mmap(NULL, pg, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    // 접근 → 즉시 SIGSEGV
    volatile char x = p[0];
    (void)x;
    return 0;
}
```

### 6.3 W^X 준수 JIT 패턴(RW → RX 전환)
```c
// w_x_switch.c
#define _GNU_SOURCE
#include <sys/mman.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

unsigned char code[] = {
    0x48,0x31,0xC0,        // xor    %rax,%rax
    0x48,0xFF,0xC0,        // inc    %rax
    0xC3                   // ret
};
typedef long (*fn_t)(void);

int main(){
    size_t pg = sysconf(_SC_PAGESIZE);
    void* buf = mmap(NULL, pg, PROT_READ|PROT_WRITE,
                     MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    memcpy(buf, code, sizeof(code));
    // 실행 전 쓰기 권한 제거, 실행권한 부여
    mprotect(buf, pg, PROT_READ|PROT_EXEC);
    fn_t f = (fn_t)buf;
    printf("f() = %ld\n", f()); // 1
    // 필요 시 실행 종료 후 다시 쓰기(RW)로 바꾸고 재컴파일 → 다시 RX
    mprotect(buf, pg, PROT_READ|PROT_WRITE);
    return 0;
}
```

### 6.4 동일 물리 페이지를 다르게 매핑(읽기전용/읽기쓰기 분리)
```c
// shared_ro_rw.c
#define _GNU_SOURCE
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(){
    int fd = memfd_create("blob", 0);        // 임시 익명파일
    ftruncate(fd, 4096);
    char* rw = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    char* ro = mmap(NULL, 4096, PROT_READ,           MAP_SHARED, fd, 0);

    strcpy(rw, "secure view");
    printf("RO sees: %s\n", ro);             // 읽기만 가능
    // ro[0] = 'X'; // 시도 시 SIGSEGV
    munmap(rw,4096); munmap(ro,4096); close(fd);
    return 0;
}
```

### 6.5 MPK(pkey)로 초저비용 권한 전환(하드웨어/커널 지원 필요)
```c
// mpk_demo.c (x86 MPK 지원 커널/CPU/글리브 필요)
#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/mman.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

// glibc: pkey_alloc/pkey_mprotect 래퍼가 있는 환경 권장
extern int pkey_alloc(unsigned int flags, unsigned int access_rights);
extern int pkey_free(int pkey);
extern int pkey_mprotect(void *addr, size_t len, int prot, int pkey);

int main(){
    size_t pg = sysconf(_SC_PAGESIZE);
    char* p = mmap(NULL, pg, PROT_READ|PROT_WRITE,
                   MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    int pk = pkey_alloc(0, 0); // 접근 제한 없음
    if(pk<0){perror("pkey_alloc"); return 1;}
    if(pkey_mprotect(p, pg, PROT_READ|PROT_WRITE, pk)){perror("pkey_mprotect");}

    strcpy(p, "secret");
    // 이후 사용자 공간에서 WRPKRU로 해당 pkey의 쓰기권한만 제거/복구 가능
    // (실코드는 아키텍처별 인라인 어셈 필요)

    printf("%s\n", p);
    pkey_free(pk);
    munmap(p, pg);
    return 0;
}
```

> MPK는 **페이지 권한 비트를 바꾸지 않고** 레지스터(PKRU)로 접근권을 토글한다.
> 시스템콜 없이 유저 모드에서 전환 가능 → **컨텍스트 스위치 없는 미세 권한 분리**.

---

## 7. 스택/힙 보호: 가드 페이지·NX·COW

- **스택 가드 페이지**: 스택 끝에 **PROT_NONE** 페이지를 두어 오버플로우 즉시 SIGSEGV.
- **NX 스택/힙**: 데이터 실행 금지.
- **COW**: `fork()` 직후 부모/자식은 메모리를 공유(읽기). 쓰기 시 **사본 할당**으로 격리.

---

## 8. 운영·관측 도구

| 목적 | 도구/파일 |
|---|---|
| VA 맵/권한 | `/proc/$pid/maps`, `pmap -x $pid` |
| 메모리 통계 | `/proc/$pid/smaps`, `/proc/meminfo`, `vmstat 1` |
| 폴트 관측 | `perf stat -e page-faults,major-faults ./app` |
| 캐시 상주 | `mincore(addr,len,vec)` |
| 보호 전환 | `mprotect`, `pkey_mprotect` |
| 실행 방지 확인 | `readelf -l ./a.out` (GNU_STACK, GNU_RELRO 등) |

---

## 9. 가상화(하이퍼바이저)와 이중 보호

- **EPT/NPT(SLAT)**: 하이퍼바이저가 **게스트의 VA→PA** 뒤에 **PA→HPA** 2단 변환으로 추가 격리.
- **KSM(페이지 중복제거)** 사용 시 **사이드채널 위험** 고려(보안지향 시스템은 비활성화 권고).
- 컨테이너는 **주소공간 분리 자체는 프로세스/커널과 동일**(VM이 아님) → **cgroup/LSM**과 병행 필요.

---

## 10. 베스트 프랙티스 체크리스트

- [ ] **W^X** 준수: JIT/플러그인은 **RW→RX** 전환 사용, **RWX 금지**
- [ ] **ASLR/PIE** 활성, 라이브러리도 기본 PIE 시스템 권장
- [ ] **RELRO + NOW**(링킹 보안)로 GOT 변조 여지 축소
- [ ] **SMEP/SMAP/KPTI** 등 커널 보호 기능 켜기
- [ ] 민감 버퍼는 **mlock/MPK/MTE** 등으로 추가 보호
- [ ] 공유메모리는 **최소권한**(RO 뷰 분리), 필요 시 **memfd + 시그널링**
- [ ] 크래시 시 **SIGSEGV 로깅**(si_addr, si_code), 코어덤프 보안정책 검토
- [ ] 정보유출(ASLR 파괴) 방지: `/proc` 권한, 포인터 포맷 보호 등

---

## 11. 자주 겪는 함정과 진단

| 증상 | 원인 | 해결 |
|---|---|---|
| 예상치 못한 SIGSEGV | PROT_NONE/RO 영역 접근, 스택 가드 히트 | `/proc/$pid/maps` 확인, 보호 전환(mprotect) |
| RWX 매핑이 필요하다고 함 | JIT/플러그인 미설계 | **이중 단계**(RW 컴파일 → RX 실행) 채택 |
| 성능 저하(권한 전환 잦음) | 잦은 `mprotect` 호출 | MPK(MTE) 검토, 배치/버퍼 설계 변경 |
| 커널 크래시/권한 오류 | SMEP/SMAP와의 충돌 | 올바른 카피/유저포인터 접근 API 사용 |
| ASLR 무력화 | 정보 유출(주소 출력 등) | 로깅/포맷 제한, `dmesg_restrict`/`kptr_restrict` |

---

## 12. 간단 수식: W^X 정책의 공격 표면 축소 효과

데이터 영역에서 코드 실행 성공확률을 \(p_\text{exec}\), 쓰기성공확률을 \(p_\text{write}\)라 하면,
**W^X**에서 두 권한이 공존하지 않으므로
$$
p_{\text{payload}} \le \min\{p_\text{exec},\, p_\text{write}\}
$$
RWX 환경의 \(p_{\text{payload}}^{\text{rwx}} \approx p_\text{exec}\cdot p_\text{write}\) 대비 현저히 작다(권한 분리로 **연쇄조건** 추가).

---

## 13. 요약

- **VM은 보안 장치**다: **격리, 권한, 예외, 무작위화, 실행방지**가 MMU/OS로 공동 구현된다.
- 개발자는 **W^X·ASLR·NX**를 기본으로, 필요 시 **MPK/MTE** 같은 하드웨어 가속 보호를 활용하라.
- 운영은 **관측(맵/폴트/권한)** 과 **최소권한 배치**를 습관화하고, 공유·JIT·IPC 같은 경계지점에 **정책적 제동장치**를 넣어라.
- 이 원칙만 지켜도, 버그가 **취약점으로 변질**될 확률을 크게 낮출 수 있다.
