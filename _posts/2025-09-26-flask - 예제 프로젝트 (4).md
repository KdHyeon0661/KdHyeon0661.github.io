---
layout: post
title: flask - 예제 프로젝트 (4) 프로덕션 배포
date: 2025-09-26 17:25:23 +0900
category: flask
---
# 프로덕션 배포 : Docker + Nginx + PostgreSQL

> 이 장은 **Flask 애플리케이션**을 **Docker + Gunicorn + Nginx + PostgreSQL** 스택으로 **프로덕션 배포**하는 과정을 처음부터 끝까지, “붙여넣어 실행 가능한” 예제와 함께 정리한다.

---

## 아키텍처 개요

- **Flask 앱**: Gunicorn WSGI 서버로 서비스
- **Nginx**: 리버스 프록시(HTTP/2, Gzip/Brotli, 정적파일, 업스트림 헬스체크)
- **PostgreSQL**: 트랜잭션 DB (볼륨에 영속화, 백업/복구 제공)
- **Docker Compose**: 로컬/스테이징/프로덕션 구성 관리
- **엔트리포인트**: 마이그레이션 → 앱 기동 (헬스체크, 레디니스)
- **TLS(HTTPS)**: Nginx + Let’s Encrypt(옵션) or L4/ELB 뒤 Nginx(내부 HTTP)

**트래픽 플로우**
`Client ↔ (HTTPS) Nginx ↔ (HTTP/Unix) Gunicorn(Flask) ↔ PostgreSQL`

---

## 예제 프로젝트 레이아웃

```
flask-prod-deploy/
├─ .env
├─ docker-compose.yml
├─ docker-compose.override.yml      # 로컬 개발용 (선택)
├─ docker-compose.prod.yml          # 프로덕션 오버레이
├─ app/
│  ├─ wsgi.py
│  ├─ __init__.py
│  ├─ models.py
│  ├─ routes.py
│  ├─ extensions.py
│  ├─ cli.py
│  ├─ migrations/                   # alembic(Flask-Migrate)
│  └─ requirements.txt
├─ conf/
│  ├─ gunicorn.conf.py
│  ├─ nginx.conf
│  ├─ nginx-site.conf               # server 블록
│  └─ supervisord.conf              # (선택) 여러 프로세스 기동시
├─ docker/
│  ├─ app.Dockerfile
│  ├─ nginx.Dockerfile
│  └─ pgbackups/
│     └─ backup-entrypoint.sh
└─ scripts/
   ├─ entrypoint.sh                 # 마이그레이션 + 헬스체크 후 기동
   └─ wait-for.sh                   # 포트 대기 유틸
```

---

## Flask 애플리케이션(샘플)

### `app/requirements.txt`

```txt
Flask==3.0.3
Werkzeug==3.0.4
Flask-SQLAlchemy==3.1.1
Flask-Migrate==4.0.7
psycopg2-binary==2.9.9
gunicorn==22.0.0
python-dotenv==1.0.1
flask-cors==4.0.1
```

### `app/__init__.py`

```python
from flask import Flask
from .extensions import db, migrate
from .routes import bp as main_bp
import os

def create_app():
    app = Flask(__name__)
    app.config.update(
        SQLALCHEMY_DATABASE_URI=os.getenv("DATABASE_URL", "postgresql://postgres:postgres@db:5432/appdb"),
        SQLALCHEMY_TRACK_MODIFICATIONS=False,
        SECRET_KEY=os.getenv("SECRET_KEY", "change-me"),
    )
    db.init_app(app)
    migrate.init_app(app, db)
    app.register_blueprint(main_bp)
    return app
```

### `app/extensions.py`

```python
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

db = SQLAlchemy(session_options={"autoflush": False, "expire_on_commit": False})
migrate = Migrate()
```

### `app/models.py`

```python
from .extensions import db
from datetime import datetime, timezone

def utcnow(): return datetime.now(timezone.utc)

class Note(db.Model):
    __tablename__ = "notes"
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(160), nullable=False)
    body = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime(timezone=True), default=utcnow, index=True)
```

### `app/routes.py`

```python
from flask import Blueprint, jsonify, request
from .extensions import db
from .models import Note

bp = Blueprint("main", __name__)

@bp.get("/healthz")
def healthz():
    return {"ok": True}

@bp.get("/")
def index():
    return jsonify({"message": "Hello, production!"})

@bp.get("/api/notes")
def list_notes():
    notes = Note.query.order_by(Note.created_at.desc()).limit(50).all()
    return jsonify([{"id": n.id, "title": n.title, "body": n.body} for n in notes])

@bp.post("/api/notes")
def create_note():
    data = request.get_json() or {}
    n = Note(title=data.get("title", "Untitled"), body=data.get("body"))
    db.session.add(n); db.session.commit()
    return jsonify({"id": n.id}), 201
```

### `app/wsgi.py`

```python
from . import create_app
app = create_app()

if __name__ == "__main__":
    app.run()
```

### `app/cli.py` (선택: 시드/관리)

```python
import click
from .extensions import db
from .models import Note

def init_cli(app):
    @app.cli.command("seed")
    @click.option("--count", default=10)
    def seed(count):
        for i in range(count):
            db.session.add(Note(title=f"Note {i+1}", body="Hello"))
        db.session.commit()
        click.echo(f"seeded {count}")
```

> `create_app()` 내에서 `from .cli import init_cli; init_cli(app)` 식으로 등록해도 된다.

---

## Gunicorn 설정

### `conf/gunicorn.conf.py`

```python
import multiprocessing
bind = "0.0.0.0:8000"          # Nginx가 프록시할 포트
workers = (multiprocessing.cpu_count() * 2) + 1
worker_class = "gthread"       # 또는 "gevent" / "uvicorn.workers.UvicornWorker" 등
threads = 2
timeout = 60
graceful_timeout = 30
keepalive = 5
accesslog = "-"
errorlog = "-"
loglevel = "info"
preload_app = True
```

- **preload_app**: 모델/모듈을 미리 로드해 **메모리 공유**(CoW) 효과. 초기화 시 DB 연결 생성하지 않도록 주의.
- CPU, 메모리에 맞춰 `workers` 튜닝.

---

## Nginx 설정

### `conf/nginx.conf` (글로벌)

```nginx
user  nginx;
worker_processes auto;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events { worker_connections 1024; }

http {
  include       /etc/nginx/mime.types;
  default_type  application/octet-stream;

  log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'rt=$request_time uct=$upstream_connect_time '
                    'urt=$upstream_response_time uhtt=$upstream_header_time';

  access_log  /var/log/nginx/access.log  main;

  sendfile        on;
  tcp_nopush      on;
  tcp_nodelay     on;
  keepalive_timeout  65;
  types_hash_max_size 2048;

  # Gzip/Brotli (Brotli모듈 이미지에 포함시)
  gzip on;
  gzip_types text/plain text/css application/json application/javascript;
  gzip_min_length 1024;

  include /etc/nginx/conf.d/*.conf;
}
```

### `conf/nginx-site.conf` (server 블록)

```nginx
server {
  listen 80;
  # listen 443 ssl http2;                      # TLS 사용 시
  server_name _;                               # 예: api.example.com

  # ssl_certificate /etc/letsencrypt/live/api.example.com/fullchain.pem;
  # ssl_certificate_key /etc/letsencrypt/live/api.example.com/privkey.pem;

  client_max_body_size 20m;

  location /healthz {
    proxy_pass http://app:8000/healthz;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }

  location /static/ {
    alias /static/;           # 정적 자산을 컨테이너 볼륨/바인드로 탑재하면 캐시헤더 부착 가능
    add_header Cache-Control "public, max-age=31536000, immutable";
    try_files $uri =404;
  }

  location / {
    proxy_pass http://app:8000;
    proxy_http_version 1.1;

    # 프록시 기본 헤더
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    # WebSocket 지원(필요 시)
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";

    proxy_read_timeout 75s;
    proxy_connect_timeout 5s;
    proxy_send_timeout 30s;
  }
}
```

> 프로덕션에서는 `server_name` 을 명시하고, 80→443 리다이렉트를 추가(SSL 섹션 참고).

---

## Docker 이미지

### `docker/app.Dockerfile` (멀티스테이지)

```dockerfile
# ---- builder ----

FROM python:3.11-slim AS builder
WORKDIR /build
ENV PIP_NO_CACHE_DIR=1 PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1
RUN apt-get update && apt-get install -y --no-install-recommends build-essential gcc \
    && rm -rf /var/lib/apt/lists/*
COPY app/requirements.txt .
RUN pip wheel --wheel-dir /wheels -r requirements.txt

# ---- runtime ----

FROM python:3.11-slim
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1
WORKDIR /app
RUN useradd -m app && chown -R app /app
COPY --from=builder /wheels /wheels
RUN pip install --no-cache-dir /wheels/* && rm -rf /wheels
COPY app/ /app/
COPY conf/gunicorn.conf.py /app/gunicorn.conf.py
COPY scripts/entrypoint.sh /entrypoint.sh
COPY scripts/wait-for.sh /wait-for.sh
RUN chmod +x /entrypoint.sh /wait-for.sh
USER app
EXPOSE 8000
CMD ["/entrypoint.sh"]
```

### `docker/nginx.Dockerfile`

```dockerfile
FROM nginx:1.27-alpine
COPY conf/nginx.conf /etc/nginx/nginx.conf
COPY conf/nginx-site.conf /etc/nginx/conf.d/default.conf
# 정적파일 별도 마운트 시 아래 사용
# RUN mkdir -p /static && chown -R nginx:nginx /static

EXPOSE 80
```

---

## Entrypoint & 헬스체크

### `scripts/wait-for.sh` (간단 포트대기)

```bash
#!/usr/bin/env sh
# usage: ./wait-for.sh host:port timeout_seconds

HOSTPORT=$1
TIMEOUT=${2:-30}
echo "Waiting for $HOSTPORT up to $TIMEOUT seconds..."
SECONDS=0
until nc -z $(echo $HOSTPORT | cut -d: -f1) $(echo $HOSTPORT | cut -d: -f2); do
  if [ $SECONDS -ge $TIMEOUT ]; then
    echo "Timeout waiting for $HOSTPORT"
    exit 1
  fi
  sleep 1
done
echo "$HOSTPORT is available"
```

### `scripts/entrypoint.sh`

```bash
#!/usr/bin/env bash

set -euo pipefail

# DB 준비 대기

/wait-for.sh db:5432 60

# 마이그레이션 적용

echo "[entrypoint] running migrations..."
flask db upgrade || { echo "migrate failed"; exit 1; }

# 앱 헬스 셀프체크(선택)

( gunicorn -c gunicorn.conf.py 'wsgi:app' & ) &
PID=$!

# 간단 대기 후 헬스 확인(선택적으로 curl)

sleep 2
echo "[entrypoint] app started with pid=$PID"
wait $PID
```

> **주의**: `entrypoint`에서 별도 배경 실행 없이 바로 Gunicorn 실행해도 된다. (위 예는 self-check 데모)

---

## PostgreSQL 컨테이너

### Compose로 볼륨/초기화

Postgres는 데이터 영속화를 위해 **네임드 볼륨**을 사용한다. 필요 시 `init.sql`을 마운트해 초기 스키마/사용자를 만들 수 있다.

---

## Compose 설정

### `.env` (루트)

```env
# 공통

COMPOSE_PROJECT_NAME=flaskprod
APP_IMAGE=flaskprod/app:latest
NGINX_IMAGE=flaskprod/nginx:latest

# 앱

SECRET_KEY=please-change-me
DATABASE_URL=postgresql://postgres:postgres@db:5432/appdb

# DB

POSTGRES_DB=appdb
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres

# 도메인/TLS (옵션)

DOMAIN=api.example.com
```

### `docker-compose.yml` (기본)

```yaml
version: "3.9"

services:
  db:
    image: postgres:16
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-appdb}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
    ports:
      - "5432:5432"                # 로컬 개발 편의. 프로덕션은 내부 네트워크만.
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB} || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

  app:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    image: ${APP_IMAGE}
    environment:
      FLASK_APP: app/wsgi.py
      SECRET_KEY: ${SECRET_KEY}
      DATABASE_URL: ${DATABASE_URL}
      FLASK_ENV: production
    depends_on:
      db:
        condition: service_healthy
    expose:
      - "8000"
    command: ["/entrypoint.sh"]
    # healthcheck: (애플리케이션 내부 헬스엔드포인트 사용)
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost:8000/healthz || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 5

  nginx:
    build:
      context: .
      dockerfile: docker/nginx.Dockerfile
    image: ${NGINX_IMAGE}
    ports:
      - "80:80"
    depends_on:
      app:
        condition: service_healthy
    # 정적을 app에서 빌드해 마운트하려면:
    # volumes:
    #   - static-data:/static:ro

volumes:
  pgdata:
  # static-data:
```

### `docker-compose.prod.yml` (프로덕션 오버레이)

```yaml
services:
  db:
    ports: []                 # 외부 노출 금지
    restart: always
  app:
    restart: always
    environment:
      GUNICORN_CMD_ARGS: "--log-level info"
  nginx:
    restart: always
    ports:
      - "80:80"
      # - "443:443"          # TLS 사용 시
```

**배포 실행 예시**

```bash
# 이미지 빌드

docker compose -f docker-compose.yml -f docker-compose.prod.yml build

# 백그라운드 실행

docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

# 로그 보기

docker compose logs -f app nginx db
```

---

## 마이그레이션(Alembic/Flask-Migrate)

### 초기화 & 적용

```bash
# 마이그레이션 폴더 생성

docker compose run --rm app flask db init
docker compose run --rm app flask db migrate -m "init tables"
docker compose run --rm app flask db upgrade
```

- 프로덕션 배포 시 `entrypoint.sh` 에서 `flask db upgrade` 자동 실행(롤링 배포 고려 시 **Additive-first** 전략).

---

## 구성

### Nginx 컨테이너에서 Certbot (간편 예)

도메인이 있고 80/443을 할당할 수 있다면:

1) **임시로** Nginx를 80에서 기동(정상 응답)
2) 호스트에 certbot 설치 후 webroot 방식으로 발급:

```bash
sudo certbot certonly --webroot -w /var/www/html -d api.example.com
```

3) 컨테이너에 인증서 볼륨 마운트:

```yaml
nginx:
  volumes:
    - /etc/letsencrypt:/etc/letsencrypt:ro
```

4) `nginx-site.conf` 에 ssl 지시어 활성화 + 80→443 리다이렉트 server 블록 추가:

```nginx
server {
  listen 80;
  server_name api.example.com;
  return 301 https://$host$request_uri;
}

server {
  listen 443 ssl http2;
  server_name api.example.com;

  ssl_certificate /etc/letsencrypt/live/api.example.com/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/api.example.com/privkey.pem;

  # ... 앞서 정의한 location 구성
}
```

> **대안**: 클라우드의 L4/ALB에서 TLS 종료 후, Nginx는 내부 HTTP만. 이때는 `X-Forwarded-Proto` 를 올바로 전달해야 한다.

---

## PostgreSQL 운영 팁

### 기본 설정(컨테이너)

- `POSTGRES_*` 환경변수로 사용자/DB 생성
- 컨테이너 재시작 시 데이터는 `pgdata` 볼륨에 보존

### 연결 풀

- Flask/SQLAlchemy 엔진
  ```python
  engine = create_engine(
      DATABASE_URL,
      pool_pre_ping=True,
      pool_size=10,
      max_overflow=20,
      pool_timeout=10,
      pool_recycle=1800,
      future=True,
  )
  ```
- 동접이 많은 경우 **pgBouncer** 를 사이에 두는 것을 권장(별도 컨테이너로 추가)

### 백업/복구(간단)

#### 덤프

```bash
docker compose exec db pg_dump -U ${POSTGRES_USER} -d ${POSTGRES_DB} -F c -f /tmp/backup.dump
docker compose cp db:/tmp/backup.dump ./backup.dump
```

#### 복구

```bash
docker compose cp ./backup.dump db:/tmp/backup.dump
docker compose exec db pg_restore -U ${POSTGRES_USER} -d ${POSTGRES_DB} --clean --if-exists /tmp/backup.dump
```

> **운영 권장**: 관리형 DB의 **스냅샷 / PITR** 사용. 자체 운영 시 스케줄러(CronJob)로 주기 백업.

---

## 로그·모니터링

### 로그 표준화

- Gunicorn `accesslog=-`, `errorlog=-` 로 **stdout/stderr** 출력 → 도커 로그 수집(CloudWatch/ELK/Datadog 등)
- Nginx access log 포맷에 **upstream 시간**(u*)을 포함해 병목 진단

### 헬스/레디니스

- `/healthz` 응답 코드=200
- 필요 시 DB ping도 수행하여 **레디니스**를 분리:

```python
@bp.get("/readyz")
def readyz():
    from sqlalchemy import text
    try:
        db.session.execute(text("SELECT 1"))
        return {"ok": True}
    except Exception:
        return {"ok": False}, 500
```

- Compose의 `healthcheck` 는 `/healthz` 또는 `/readyz` 사용

---

## 성능/보안 하드닝

### Nginx

- `client_max_body_size` (업로드 제한)
- `keepalive_timeout`, `gzip`, 캐시 헤더
- **보안 헤더**(역할에 따라 추가):
  ```nginx
  add_header X-Frame-Options SAMEORIGIN always;
  add_header X-Content-Type-Options nosniff always;
  add_header Referrer-Policy strict-origin-when-cross-origin always;
  ```
- CORS가 필요하면 `add_header Access-Control-Allow-Origin ...` (정확한 오리진만 허용)

### Gunicorn

- 워커 수, 클래스(gevent/gthread) 튜닝
- 타임아웃 설정 및 백엔드 I/O 타임아웃(데이터베이스/외부 API) 별도 설정

### 앱(Flask)

- 모든 I/O 경계에 **타임아웃**
- **CSRF/XSS/CORS** 설정(8~10장 참고)
- **시크릿/환경변수**는 `.env` 대신 배포 환경 **시크릿 매니저** 사용 권장

---

## 예시

### GitHub Actions (요약)

```yaml
# .github/workflows/deploy.yml

name: deploy
on:
  push:
    branches: [ main ]

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build app image
        run: docker build -t ghcr.io/${{ github.repository }}/app:latest -f docker/app.Dockerfile .
      - name: Push app image
        run: docker push ghcr.io/${{ github.repository }}/app:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: SSH and update
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd /srv/flask-prod-deploy
            docker compose -f docker-compose.yml -f docker-compose.prod.yml pull
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --no-deps app
            docker system prune -f
```

- **롤링/무중단**: 다중 인스턴스 환경(예: Swarm/K8s, 또는 여러 VM)에서 Nginx Upstream에 **두 개 이상의 app** 을 라운드로빈하면 무중단 교체 가능.

---

## 확장: 정적 빌드/별도 CDN

- 프런트엔드(React/Vite 등)의 **정적 자산**은 **빌드 → 해시파일** → S3/CloudFront에 배포하고, Flask는 API만 제공
- Nginx는 `/static/` 을 CDN으로 리디렉션 또는 302/리버스프록시 가능

---

## 확장: WebSocket/Socket.IO

- Gunicorn 워커를 `gevent` 또는 `eventlet` 로 설정하고, Nginx에서 **Upgrade/Connection** 헤더 전달(이미 예시 포함)
- 다중 컨테이너 확장 시 **Redis message_queue** 사용(Flask-SocketIO)

---

## 트러블슈팅

- **502/504**: app 헬스 불량, 타임아웃, Nginx ↔ app 연결 실패
  - `docker compose logs nginx app` 로 upstream 에러 확인
- **데이터베이스 연결 오류**: ENV `DATABASE_URL` 확인, `db` 헬스 상태, 방화벽/포트
- **마이그레이션 실패**: Alembic 스크립트 트랜잭션/락, 대용량 변경은 오프피크 수행
- **정적 파일 404**: Nginx `alias`/경로 권한, 빌드/마운트 확인
- **메모리 누수**: Gunicorn `--max-requests` + `--max-requests-jitter` 로 워커 재순환

---

## 보안 체크리스트

- [ ] 도메인에 **TLS** 적용(HTTP→HTTPS 리다이렉트)
- [ ] **보안 헤더** 기본값 설정(HSTS는 충분한 검증 후)
- [ ] **시크릿/자격증명**: 레포지토리에 커밋 금지, 시크릿 매니저 사용
- [ ] DB 계정 **권한 최소화**, 네트워크는 내부 통신만 허용
- [ ] **백업 암호화/접근통제**, 복구 리허설
- [ ] **로그 마스킹**(토큰/비번) + 접근 로그 보존 기간
- [ ] **레이트 리미팅**(인증/쓰기 경로) + **WAF** 필요 시 도입

---

## 로컬 빠른 실행(개발용)

```bash
# 이미지 빌드

docker compose build

# 기동

docker compose up -d

# 마이그레이션

docker compose exec app flask db init
docker compose exec app flask db migrate -m "init"
docker compose exec app flask db upgrade

# 테스트 데이터

docker compose exec app flask seed --count 10

# 브라우저

open http://localhost/
```

---

## 요약 & 다음 단계

- **Docker + Nginx + PostgreSQL** 조합으로 **Flask 앱**을 **안전하고 확장 가능**하게 배포했다.
- 핵심 포인트:
  - **Gunicorn 튜닝**(workers/timeout/keepalive)
  - **Nginx 리버스 프록시**(gzip/보안헤더/업스트림 타임아웃)
  - **PostgreSQL 영속화/백업/연결 풀**
  - **마이그레이션 자동화** & **헬스체크**
  - **TLS** 와 **CI/CD 파이프라인** 도입
