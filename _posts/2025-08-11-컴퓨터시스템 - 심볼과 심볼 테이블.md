---
layout: post
title: 컴퓨터시스템 - 심볼과 심볼 테이블
date: 2025-08-11 14:20:23 +0900
category: 컴퓨터시스템
---
# 심볼(Symbol)과 심볼 테이블(Symbol Table)

## 1. 심볼(Symbol)의 개념
**심볼(Symbol)**은 프로그램에서 특정 개체를 식별하기 위해 사용하는 이름(name)이다.  
이는 **변수, 함수, 전역 데이터, 상수, 레이블(label)** 등 프로그램의 각 요소를 참조할 때 사용된다.

- **예시**:
  - 전역 변수: `int counter;` → 심볼: `counter`
  - 함수: `void print_result()` → 심볼: `print_result`
  - 어셈블리 레이블: `.L1` → 심볼: `.L1`

심볼은 **소스 코드 단계**에서는 사람이 읽을 수 있는 이름이고, **컴파일·링크 단계**에서는 기계가 이해할 수 있는 **주소, 크기, 타입 등의 메타데이터**로 변환된다.

---

## 2. 심볼 테이블(Symbol Table)의 역할
**심볼 테이블**은 컴파일러, 어셈블러, 링커가 심볼에 대한 정보를 관리하는 **데이터베이스**다.

### 주요 기능
1. **이름 → 속성 매핑**  
   심볼 이름을 해시 테이블이나 트리에 저장하고, 해당 심볼의 속성을 참조할 수 있게 한다.
2. **주소 결정(Address Resolution)**  
   변수가 실제 메모리나 레지스터에 배치될 주소를 결정한다.
3. **링킹 지원**  
   여러 개의 오브젝트 파일에서 심볼을 찾아 연결한다.
4. **디버깅 정보 제공**  
   디버거(gdb)가 변수 이름과 메모리 주소를 연결해주는 역할.

---

## 3. 심볼의 분류
심볼은 **정의(Definition)**와 **참조(Reference)**의 관점에서 나눌 수 있다.

| 심볼 유형 | 의미 | 예 |
|-----------|------|----|
| **전역 정의(Global Definition)** | 심볼이 해당 오브젝트 파일 내에서 정의됨 | `int counter = 0;` |
| **전역 참조(Global Reference)** | 외부 오브젝트 파일에 정의된 심볼을 참조 | `extern int counter;` |
| **지역 심볼(Local Symbol)** | 오브젝트 파일 내에서만 유효 | 정적 변수 `static int x;` |
| **파일 로컬 심볼(File-scope Symbol)** | 링커에 노출되지 않음 | 정적 함수 `static void f();` |

---

## 4. 심볼 테이블 구조
심볼 테이블은 ELF, COFF, Mach-O 같은 오브젝트 파일 포맷 내부에 저장된다.

### ELF의 심볼 테이블 예
- **.symtab**: 모든 심볼의 메타데이터 저장
- **.strtab**: 심볼 이름 문자열 저장
- **.dynsym**: 동적 링킹 시 필요한 심볼 저장

각 심볼 항목에는 다음 정보가 포함된다:
| 필드 | 설명 |
|------|------|
| Name | 심볼 이름(문자열 테이블 인덱스) |
| Value | 심볼 값 (주소 또는 오프셋) |
| Size | 심볼 크기 (바이트) |
| Type | 함수(FUNC), 객체(OBJECT) 등 |
| Binding | 전역(GLOBAL), 로컬(LOCAL) 등 |
| Section index | 어떤 섹션에 속하는지 |

---

## 5. 심볼 해석 과정
심볼 해석(Symbol Resolution)은 **링커**가 수행한다.

1. **정적 링크**
   - 모든 오브젝트 파일의 심볼 테이블을 읽음
   - 전역 참조를 해당 전역 정의로 연결
   - 하나의 전역 심볼에는 단 하나의 정의만 허용
2. **동적 링크**
   - 실행 시 로더가 공유 라이브러리(.so) 로드 후 심볼 연결
   - **PLT(Procedure Linkage Table)**와 **GOT(Global Offset Table)**을 이용해 지연 바인딩(Lazy Binding) 수행

---

## 6. 예시: GCC + nm로 심볼 확인
다음 코드를 예로 들자:
```c
#include <stdio.h>
int global_var = 42;
void hello() {
    printf("Hello\n");
}
int main() {
    hello();
    return 0;
}
```

컴파일 후 심볼 테이블 확인:
```bash
gcc -c example.c -o example.o
nm example.o
```

출력 예:
```
0000000000000000 T hello
0000000000000000 D global_var
                 U printf
0000000000000010 T main
```

- `T` = .text 섹션(코드)에 정의됨
- `D` = .data 섹션(초기화 데이터)에 정의됨
- `U` = undefined(외부 참조)

---

## 7. 디버깅과 심볼
- **디버그 빌드(-g 옵션)** 시, 심볼 테이블에 **변수 타입, 함수 매개변수, 소스 코드 위치** 정보 추가
- 디버거(gdb)는 이 정보를 사용해 브레이크포인트, 변수 출력 등 수행

---

## 8. 요약
- **심볼**: 프로그램 내 식별자에 대한 이름과 속성
- **심볼 테이블**: 이름을 주소·타입 등 메타데이터와 연결하는 자료구조
- **링커**는 심볼 테이블을 기반으로 여러 오브젝트 파일을 하나로 결합
- **디버거**는 심볼 테이블을 통해 사람이 읽을 수 있는 정보를 제공

캐시, 최적화, 링크 타임 최적화(LTO) 등과 마찬가지로 **심볼 관리**는 프로그램 성능과 유지보수성에 중요한 영향을 미친다.





나의 말:
심볼 해석에 대해 자세하게 작성해줘


ChatGPT의 말:
markdown
복사
# 심볼 해석(Symbol Resolution) — 정적·동적 링크, 강/약 심볼, 가시성, 인터포지션까지

**심볼 해석**은 “이 참조(이름)가 가리키는 **정확한 정의(주소/객체)** 를 언제·어디서·어떻게 찾는가”의 전 과정을 뜻한다.  
컴파일/어셈블 단계에서 심볼은 미정(Undefined)일 수 있고, **정적 링크 시간**과 **동적 로딩 시간**에 걸쳐 해석·재배치가 일어난다.  
본 글은 ELF/GNU 계열(리눅스, x86-64) 기준이다.

---

## 0) 용어 미리 보기
- **정의(Defined)**: 이 오브젝트(.o/.so)에 구현/실체가 존재.
- **미정(Undefined)**: 외부에 정의가 있다고 가정(참조만 함).
- **강(Strong) / 약(Weak)** 바인딩: 충돌 시 **강 > 약** 규칙.
- **가시성(Visibility)**: `DEFAULT / HIDDEN / PROTECTED / INTERNAL`
- **심볼 바인딩(STB)**: `GLOBAL / LOCAL / WEAK`
- **섹션 인덱스**: `SHN_UNDEF`(미정), 그 외(정의 위치)
- **재배치(Relocation)**: 링크러/로더가 “값을 채워 넣는” 패치점.

---

## 1) 정적 링크에서의 심볼 해석(오프라인)

### 1.1 입력과 스캔 순서
정적 링커(`ld`, `lld`, `gold`)는 **왼쪽→오른쪽**으로 입력을 순회한다.
- **.o 파일**: **무조건** 포함.
- **.a(정적 라이브러리)**: **필요한 심볼**이 있을 때만 내부 멤버(.o)를 끄집어냄.
- 상호 참조가 복잡하면 `--start-group ... --end-group`으로 순환 해결.

```bash
# 올바른 예: 참조(main.o) 뒤에 라이브러리
gcc main.o -L. -lfoo -o app
# 필요 시
gcc main.o -Wl,--start-group -lfoo -lbar -Wl,--end-group -o app
```

### 1.2 해석 규칙(요지)
- **강/약 규칙**: 동일 이름 **강 정의**가 둘 이상이면 링크 에러.  
  약(weak) 정의는 **강 정의가 있으면** 대체된다.
- **정의 선택**: 우선 발견된(스캔 순서상) **강 정의**로 해석된다.
- **로컬/파일 한정**: `static`(C)·익명 네임스페이스(C++)는 **심볼이 외부로 노출되지 않음**(STB_LOCAL).
- **재배치 적용**: 모든 미정 참조가 해석되면, `R_X86_64_PC32`, `R_X86_64_64` 등 타입에 맞춰 주소/오프셋을 **실수 값으로 패치**한다.

### 1.3 진단 도구
```bash
nm -C main.o         # 심볼 바인딩/섹션
readelf -Ws a.o      # 타입/바인딩/가시성
readelf -r  b.o      # 재배치 엔트리
objdump -drwC app    # 디스어셈+재배치 표시
```

---

## 2) 동적 링크에서의 심볼 해석(런타임)

실행 파일과 공유 라이브러리(.so)는 **동적 로더(ld.so)** 가 로딩하며, **GOT/PLT**를 중심으로 심볼을 결속한다.

### 2.1 로더의 작업
1) **ELF 파싱**: `DT_NEEDED` 의존성 로드(필요 시 검색 경로 사용: RPATH/RUNPATH/`LD_LIBRARY_PATH`).  
2) **재배치 처리**: `REL(A)` 엔트리 적용(`R_X86_64_GLOB_DAT`, `R_X86_64_RELATIVE`, `R_X86_64_JUMP_SLOT` 등).  
3) **심볼 탐색 범위 구성**: 실행 파일 + 전역 스코프 DSOs.

### 2.2 탐색 순서(ELF SysV 일반 규칙)
- **기본 인터포지션 모델**: **실행 파일**의 전역 심볼이 **공유 라이브러리**의 같은 이름을 **선점(preempt)** 할 수 있다.  
- 로더는 **참조자가 속한 오브젝트의 링커 스코프**에 따라,
  - **전역 범위(Global)**: 실행 파일 → 그 **직접 의존성**(DT_NEEDED) → 그 하위 의존성(순서)으로 탐색.
  - `STV_HIDDEN/INTERNAL` 은 외부에서 보이지 않아 탐색 대상 제외.
- GNU의 실제 탐색은 구현 세부가 있으나, 요지는 **실행 파일이 우선**, 다음은 **의존 선언 순서**라는 점.

> **주의**: `LD_PRELOAD` 로 주입한 DSO는 가장 먼저 탐색되어 **오버라이드(인터포지션)** 가 가능.

### 2.3 PLT/GOT & Lazy Binding
- **PLT 엔트리**: 외부 함수 호출 시 점프하는 **간접 점프 슬롯**.  
- **GOT 엔트리**: 함수/데이터의 **실제 주소** 저장 장소.
- **지연 바인딩(lazy)**: 첫 호출 시 `plt0` → 로더 바인더 진입 → 심볼 해석 → GOT에 진짜 주소 기록 → 이후 오버헤드 없음.  
  즉시 바인딩은 `LD_BIND_NOW=1` 또는 `-Wl,-z,now`.

```text
call foo@PLT  →  PLT[foo]가 바인더 호출 → GOT[foo] 채움 → 다음부터 foo로 직행
```

### 2.4 대표 재배치 타입(AMD64)
- **함수**: `R_X86_64_JUMP_SLOT`(PLT/GOT 엔트리 채움)
- **데이터 전역**: `R_X86_64_GLOB_DAT`
- **상대 재배치**: `R_X86_64_RELATIVE`(PIC/PIE 핵심)
- **복사 재배치**: `R_X86_64_COPY`(과거 호환; 전역 변수 인터포지션 부작용의 원천)
- **IFUNC**: `R_X86_64_IRELATIVE` — 런타임에 최적 구현 선택(예: CPU 기능별)

---

## 3) 강/약(Strong/Weak)과 ODR, 이름 장식

### 3.1 강/약 규칙(정리)
- **강 정의 × 2** → 링크 에러  
- **강 vs 약** → 강이 승, 약은 무시  
- **약 참조(Weak Undef)** → 정의가 없어도 0/NULL로 허용(용도: 선택적 훅)

```c
// 약(weak) 훅: 정의 없으면 빈 동작
__attribute__((weak)) void on_start(void);
int main(){ if (on_start) on_start(); return 0; }
```

### 3.2 C++ ODR/이름 장식
- C++는 템플릿/오버로드로 **이름 장식(name mangling)** 발생 → `nm -C`로 복원.  
- **ODR(One Definition Rule)**: 동일 엔티티는 프로그램 전체에서 단 하나의 정의만.  
- C API 내보내기에는 `extern "C"` 로 장식 제거.

---

## 4) 가시성(Visibility)과 최적화/안전성

| 가시성 | 의미 | 해석 영향 |
|---|---|---|
| `DEFAULT` | 외부에서 보임(기본) | 인터포지션 가능 |
| `HIDDEN` | 외부에서 안 보임 | 외부 탐색 제외, 내부 결합 고정 |
| `PROTECTED` | 외부에 보이지만 **자기 DSO 내부 참조는 선점 불가** | 내부 참조는 **자기 정의로 고정** |
| `INTERNAL` | 구현 전용 | 특수 |

- 전체 기본을 `-fvisibility=hidden`으로 두고, 공개 API만 `__attribute__((visibility("default")))` 권장.
- `-fno-semantic-interposition`(컴파일) / `-Wl,-Bsymbolic`(링크; DSO 내부 참조 고정)는  
  **인터포지션 가정**을 약화시켜 **인라이닝/상수 전파 등** 최적화에 유리(단, 오버라이드 의도 시 주의).

---

## 5) 인터포지션(Interposition) — 의도와 부작용

- **의도적 오버라이드**: `LD_PRELOAD=libtrace.so ./app`로 `malloc/free` 후킹, 로깅/샌드박싱.  
- **부작용**:  
  - 성능: 로더 탐색/PLT 간접화로 **추가 오버헤드**.  
  - 의미: `R_X86_64_COPY` 같은 **전역 데이터 복사**가 얽히면 **동기화/일관성 문제**.  
- 방지/완화:
  - DSO 내부에서는 `-Bsymbolic`/`PROTECTED`/`HIDDEN` 으로 **자기 참조 고정**.
  - 실행 파일은 **PIE+RELRO+NOW**로 보안·일관성 강화.

---

## 6) TLS(Thread-Local Storage)와 심볼 해석

TLS 심볼은 스레드별 별도 저장소에 위치하며 **TLS 재배치**가 필요하다.
- 접근 모델: `GD/LD/IE/LE` (Global/Local/Initial Exec/Local Exec)
- 정적/동적 링크와 로딩 시점에 따라 최적 모델이 다름(성능 차 큼).
- 동적 로더는 TLS 블록을 할당하고 **TLS 관련 재배치**(`R_X86_64_TPOFF64` 등)를 처리.

---

## 7) 심볼 버전(Symbol Versioning)

- glibc 등은 **버전 기호**로 ABI 호환 관리(`GLIBC_2.28` 등).  
- **버전 스크립트(version script)** 로 내보낼 심볼과 버전을 제어:
```ld
VERS_1 {
  global: public_api*;
  local: *;
};
```
- 런타임 해석 시 **요청 버전과 일치하는 정의**를 선택.

---

## 8) 실전 시나리오와 처방

### 8.1 “정의가 있는데 undefined reference?”
- **라이브러리 순서** 문제(정적 링크). → 참조 **뒤에** `-l` 배치, 혹은 group 사용.
- **가시성**: `hidden` 으로 내보내지 않아 외부에서 못 봄. → visibility 확인.
- **이름 장식**: C++ 함수인데 `extern "C"` 누락. → `nm -C`로 확인.

### 8.2 “내가 만든 함수가 호출되지 않는다”
- **인터포지션**: 실행 파일/다른 DSO가 선점. → `LD_DEBUG=bindings` 로 결속 로그, `-Bsymbolic` 고려.

### 8.3 “성능이 이상하게 나쁘다(간접 호출·분기 미스)”
- 잦은 PLT 우회 → `-Wl,-z,now`(즉시 바인딩) 또는 내부 호출 고정(`-Bsymbolic`, `-fno-semantic-interposition`).
- 너무 넓은 `DEFAULT` 가시성 → `HIDDEN/PROTECTED` 로 축소.

---

## 9) 명령어 모음(문제 추적)

```bash
# 로딩/바인딩 로그
LD_DEBUG=libs,bindings,reloc ./app 2>&1 | less

# 실행 파일/DSO가 필요로 하는 라이브러리
ldd ./app

# 모든 동적 심볼(가시성/바인딩/버전 포함)
readelf -Ws ./libx.so | less

# 심볼/버전 조회
objdump --syms --dynamic-syms ./libx.so | less
```

---

## 10) 미니 예제: 약 심볼과 인터포지션

```c
// libhook.c
#include <stdio.h>
__attribute__((weak)) void hook(void) {}
void api(void){ puts("api"); hook(); }
```

```c
// app.c
void api(void);
int main(){ api(); }
```

```bash
# 공유 라이브러리 + 실행 파일
gcc -fPIC -shared libhook.c -o libhook.so
gcc app.c -L. -lhook -Wl,-rpath,. -o app
./app           # 기본: hook() 없음 → 아무 일 없음

# 프리로드로 후킹
cat > myhook.c <<'EOF'
#include <stdio.h>
void hook(void){ puts("hooked"); }
EOF
gcc -fPIC -shared myhook.c -o myhook.so
LD_PRELOAD=./myhook.so ./app    # → "api" 다음에 "hooked"
```

---

## 11) 체크리스트

- [ ] **정의는 단 하나**(ODR)인가? 강/약 충돌 없는가?  
- [ ] 정적 링크 시 **라이브러리 순서**는 올바른가?  
- [ ] 외부로 노출할 심볼만 `DEFAULT`, 나머지는 `HIDDEN/PROTECTED`인가?  
- [ ] 성능 민감 경로는 **인터포지션 불가**로 고정했는가(`-Bsymbolic`, `-fno-semantic-interposition`)?  
- [ ] PLT 오버헤드가 문제면 **NOW/RELRO**를 사용했는가?  
- [ ] C/C++ 혼용 시 **이름 장식** 문제(`extern "C"`)는 없는가?  
- [ ] TLS 심볼은 올바른 접근 모델을 쓰는가?  
- [ ] 버전 스크립트로 **내보낼 그 이름만** 공개하는가?

---

## 12) 한 줄 결론
심볼 해석은 **링커·로더·가시성·바인딩·인터포지션**의 상호작용이다.  
**무엇을 외부에 보이고, 무엇을 내부에 고정할지**를 설계/플래그/스크립트로 제어하면  
정확성과 성능(인라이닝·분기 예측·PLT 제거)을 동시에 잡을 수 있다.