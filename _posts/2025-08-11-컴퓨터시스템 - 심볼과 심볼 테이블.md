---
layout: post
title: 컴퓨터시스템 - 심볼과 심볼 테이블
date: 2025-08-11 14:20:23 +0900
category: 컴퓨터시스템
---
# 심볼 해석(Symbol Resolution)

## 0. 용어·스코프

- **정의(Defined)**: 이 오브젝트(.o/.so)에 심볼의 실체(코드/데이터)가 존재.
- **미정(Undefined, SHN_UNDEF)**: 외부에 정의가 있다고 가정(참조만 함).
- **바인딩(Binding)**: `GLOBAL / LOCAL / WEAK` (ELF의 STB\_*)
- **가시성(Visibility)**: `DEFAULT / HIDDEN / PROTECTED / INTERNAL` (ELF의 STV\_*)
- **링커(정적)**: `ld(bfd)/gold/lld` — 빌드 시 해석.
- **로더(동적)**: `ld.so` — 실행 시 해석(PLT/GOT · 재배치 적용).

---

## 1. 심볼 테이블과 재배치의 최소 단위 이해

ELF에서 심볼은 `.symtab`(정적) / `.dynsym`(동적)에 행 단위로 저장된다. 재배치 엔트리는 “**여기(오프셋)** 를 **이 심볼**을 이용해 **이 방식**으로 채워 넣어라”라는 지시다.

대표적인 결과식(AMD64):

- **절대(Absolute)**:
  $$
  \text{Result} = S + A
  $$
  여기서 \(S\): 심볼 최종 주소, \(A\): 애드엔드(addend).

- **PC-상대(분기/호출 등)**:
  $$
  \text{Result} = S + A - P
  $$
  \(P\): 이 필드가 위치한 명령의 다음 주소(Program Counter 기준).

동적 링크 시엔 `RELATIVE / GLOB_DAT / JUMP_SLOT / IRELATIVE` 같은 타입이 추가로 등장한다.

---

## 2. 정적 링크 시 심볼 해석 — “왼쪽→오른쪽”과 강/약

### 2.1 입력 스캔 규칙
- **.o**: 등장하면 **무조건 포함**.
- **.a(정적 라이브러리)**: 해당 아카이브 내부의 멤버(.o)는 **필요한 심볼이 있을 때만** 꺼내 포함.
- 명령행은 **왼쪽→오른쪽**으로 해석된다. 참조자 뒤에 제공자를 둬라.

```bash
# OK: main.o가 먼저 참조를 만들고, 이어서 -lfoo가 제공
gcc main.o -L. -lfoo -o app

# 순환 의존은 group로 감싸기
gcc a.o -Wl,--start-group -lfoo -lbar -Wl,--end-group -o app
```

### 2.2 강/약(Strong/Weak) 규칙
- **강 정의 × 2** ⇒ 링크 에러(One Definition Rule 위반).
- **강 vs 약** ⇒ 강이 승; 약 정의는 대체/무시됨.
- **약 참조(Weak Undef)** ⇒ 정의가 없어도 0/NULL 허용(선택적 훅에 활용).

```c
// 선택적 훅 패턴
__attribute__((weak)) void on_start(void);
int main(){ if (on_start) on_start(); return 0; }
```

### 2.3 가시성·내부 연결
- `static`(C)/익명 네임스페이스(C++)는 **STB_LOCAL**로 외부에 노출되지 않는다.
- `-fvisibility=hidden`을 기본으로 두고 공개 API만 `__attribute__((visibility("default")))`로 노출하라.

### 2.4 진단 툴
```bash
nm -C a.o              # 바인딩/섹션/약/강 확인
readelf -Ws a.o        # 타입/가시성/버전
readelf -r b.o         # 재배치 엔트리(무엇을 채워야 하나)
objdump -drwC app      # 디스어셈+재배치 주석
```

---

## 3. 동적 링크 시 심볼 해석 — 로더의 탐색 범위와 순서

### 3.1 로더의 큰 절차
1) 실행 파일의 `PT_INTERP`로 로더(예: `/lib64/ld-linux-x86-64.so.2`) 매핑
2) `DT_NEEDED` 체인을 따라 .so 로드(검색 경로 = RUNPATH/RPATH/`LD_LIBRARY_PATH`)
3) **재배치** 적용: `RELATIVE / GLOB_DAT / JUMP_SLOT / COPY / IRELATIVE / TLS*`
4) `.init_array`/TLS 초기화 → 실행 파일의 `_start`로 점프

### 3.2 탐색 순서(ELF SysV 기본 모델)
- **전역 스코프(Global Scope)**: 보통 **실행 파일**이 먼저, 그다음 **직접 의존(Needed) 순서**로 탐색.
- **가시성**: `HIDDEN/INTERNAL` 은 외부 탐색에서 제외.
- **LD_PRELOAD** 로 지정된 DSO는 **최우선**으로 탐색되어 인터포지션 가능.

> 구현체(예: glibc)별 미세 차는 있지만, 핵심 그림은 “실행 파일 우선 → 의존 순서”다.

### 3.3 Lazy vs Now(즉시) 바인딩
- **Lazy**: 첫 호출에만 바인더 진입(시작 빠름, 첫콜 지연 존재)
- **Now**: 시작 시 전부 결속(시작 느릴 수, 실행 중 지연 없음)
```bash
# 즉시 바인딩 강제
LD_BIND_NOW=1 ./app
# 빌드 시
-Wl,-z,now
```

---

## 4. PLT/GOT와 재배치 타입 — 호출·데이터의 결속

- **PLT**: 외부 함수 호출 진입점(간접 점프 슬롯)
- **GOT**: 함수/데이터의 실제 주소 테이블

대표 타입(AMD64):
- 함수: `R_X86_64_JUMP_SLOT`(PLT/GOT 엔트리 채움)
- 데이터 전역: `R_X86_64_GLOB_DAT`
- 위치독립 기반: `R_X86_64_RELATIVE`
- IFUNC: `R_X86_64_IRELATIVE`(런타임에 최적 구현 선택)
- 역사적 호환: `R_X86_64_COPY`(전역 데이터 복사 — 권장X)

---

## 5. 인터포지션(Interposition) — 의도적 오버라이드와 억제

- **활용**: 로깅/샌드박싱/트레이싱 — `LD_PRELOAD` 주입 DSO가 기존 심볼을 오버라이드.
- **부작용**: 성능(간접화·바인더), 의미(데이터 복사·일관성 붕괴).
- **억제**:
  - DSO 내부 참조 고정: `-Wl,-Bsymbolic` 또는 함수 한정 `-Wl,-Bsymbolic-functions`
  - 컴파일러 최적화 허용: `-fno-semantic-interposition`
  - 가시성 축소: `HIDDEN/PROTECTED` 사용(외부에서 보이지 않거나, 내부 참조는 고정)

---

## 6. TLS(Thread-Local Storage) 심볼 해석

### 6.1 접근 모델
- **LE(Local Exec)**: 정적 배치(가장 빠름, 정적 링크/초기 로딩에만)
- **IE(Initial Exec)**: 초기 로딩 시 고정(PLT/GOT 없이 빠름, 동적이지만 주 DSO에 한정)
- **LD/GE(Local/Global Dynamic)**: 런타임 해석 필요(유연, 느림)

로더는 TLS 블록을 할당하고 `R_X86_64_TPOFF64` 등 재배치를 수행하거나 `__tls_get_addr`를 통해 주소를 산출한다. 성능 민감 코드에서는 IE/LE 모델을 활용하되, **로드 순서/링킹 형태** 제약을 인지해야 한다.

---

## 7. IFUNC(Indirect Functions) — 런타임 선택 심볼

- 심볼 해석 시 “**해결자 함수**”를 먼저 호출해 **최적 구현 주소**(SSE/AVX/NEON 등)를 반환받는 메커니즘.
- 재배치: `R_X86_64_IRELATIVE`
- 주의: 초기화 순서/스레드 안전성·정적 링크 제약.

간단 스케치:
```c
// gcc -O2 -fpic -shared ifunc.c -o libx.so
static void *resolve(void){
    /* CPUID 검사 후 최적 구현 주소 반환 */
    extern void fast_impl(void), base_impl(void);
    return /* 조건 ? */ (void*)fast_impl : (void*)base_impl;
}
void foo(void) __attribute__((ifunc("resolve")));
```

---

## 8. 심볼 버전(Symbol Versioning) — ABI 진화의 안전핀

- glibc 스타일: 심볼에 버전 태그 부여(`GLIBC_2.35` 등).
- 링커 **버전 스크립트**로 내보낼 심볼과 버전을 명시:
```ld
LIB_1.0 {
  global: api_*;
  local: *;
};
```
- 실행 시 로더는 **요청 버전**과 맞는 정의를 선택. 잘못된 버전은 즉시 실패로 드러나므로 **ABI 호환성** 검증에 유리.

---

## 9. COMDAT/ODR(특히 C++) — 중복 제거와 법칙

- **COMDAT**: 여러 개의 동일 엔티티(템플릿/inline 등)가 각 오브젝트에 중복 생성되어도 **하나만 선택**하는 그룹 규칙.
- **ODR(One Definition Rule)**: 동일 엔티티는 **프로그램 전체에서 단 하나**. 링크 타임에 위반 시 충돌.
- 진단: `-Wl,-Map=link.map`로 어떤 개체가 남는지 확인.

---

## 10. Copy Relocation — 왜 피해야 하는가

- 실행 파일의 **전역 데이터를 DSO에서 참조**하면, 로더가 실행 파일로 **복사본**을 만들어 DSO가 그 주소를 보게 하는 옛 기법(`R_X86_64_COPY`).
- 결과: **한 곳을 변경해도 다른 쪽에 반영되지 않는** 일관성 이슈.
- 회피:
  - **PIE + -fPIC** 빌드, 전역 데이터를 `HIDDEN`/캡슐화.
  - DSO 외부에서 실행 파일의 전역을 직접 참조하지 않도록 설계.

---

## 11. 가시성·버전·인터포지션 조합의 실전 규칙

- 기본: `-fvisibility=hidden` + 공개 API만 `DEFAULT`
- 성능: `-fno-semantic-interposition` + (필요시) `-Wl,-Bsymbolic`
- 보안: `-Wl,-z,relro,-z,now` + PIE
- ABI: **버전 스크립트**로 공개 심볼·버전 범위를 명시, 나머지 **local** 처리

---

## 12. 링커 스크립트/옵션으로 해석을 “설계”하기

### 12.1 내보내기(Export) 제어
```ld
VERS_1 {
  global: x_public_*;   # 공개 API
  local:  *;            # 그 외는 비공개
};
```
```bash
gcc -shared x.c -Wl,--version-script=exports.map -o libx.so
```

### 12.2 해석 강제·우회
- `-Wl,--undefined,sym` : **정의가 없어도** 로더가 나중에 해결하도록 해석(플러그인 지점).
- `-Wl,--wrap,foo` : `foo` 호출을 `__wrap_foo`로 리라이트(후킹/계측에 유용).
- `--whole-archive/--no-whole-archive` : 아카이브 멤버 **모두 포함**(필요 모듈 강제 풀어내기).

---

## 13. 문제 재현·진단 — “말이 아닌 숫자/로그”

### 13.1 로더 로그/의존
```bash
ldd ./app
LD_DEBUG=libs,reloc,bindings ./app 2>&1 | less
```

### 13.2 심볼/재배치/맵
```bash
readelf -dW ./libx.so | less          # DT_NEEDED/RUNPATH/Hash
readelf -Ws ./libx.so | less          # 동적 심볼(바인딩/가시성/버전)
objdump -R ./app | less               # GOT/PLT 재배치
gcc a.o -Wl,-Map=link.map -o app      # 해석/배치 맵 파일
```

### 13.3 디버깅 심볼과 역변환
```bash
objcopy --only-keep-debug app app.debug
objcopy --add-gnu-debuglink=app.debug app
addr2line -e app.debug 0x40123a
```

---

## 14. 성능 관점 — 해석이 만드는 오버헤드와 최적화

- **PLT 간접**/인터포지션 가정은 인라이닝·상수 전파를 막는다.
- 최적화 플래그:
  - 컴파일: `-O2 -fno-semantic-interposition -fvisibility=hidden`
  - 링크: `-Wl,-Bsymbolic`(DSO 내부 고정), `-Wl,-z,now`(즉시 바인딩), `-Wl,--as-needed`(불필요 NEEDED 제거)
- **IFUNC**: CPU 기능에 맞는 구현 자동 선택(주요 루프에 유리). 초기 결속 오버헤드와 스레드/초기화 순서를 고려.

---

## 15. 보안 관점 — 해석 경로를 공격면으로 보라

- **LD_PRELOAD**: SUID에선 무시되지만, 일반 프로세스엔 인터포지션 창구.
- **RELRO+NOW**: GOT를 **읽기 전용** 봉인(Full RELRO) + 즉시 바인딩으로 **런타임 쓰기 악용** 방지.
- **PIE+ASLR**: 주소 예측 공격 방어.
- **가시성 축소**: 공격자가 오버라이드할 표면 자체를 최소화.

빌드 템플릿:
```bash
CFLAGS="-O2 -fpie -fstack-protector-strong -D_FORTIFY_SOURCE=3 -fvisibility=hidden -fno-semantic-interposition"
LDFLAGS="-pie -Wl,-z,relro,-z,now -Wl,--as-needed -Wl,--hash-style=gnu"
```

---

## 16. 크로스 플랫폼 짧은 비교 — 해석 모델의 차이

### 16.1 Windows(PE/COFF)
- **IAT(Import Address Table)**로 정적 해석, `Delay-Load`로 지연 바인딩 가능.
- 내보내기: `__declspec(dllexport)` 또는 .def 파일(이름/ordinal).
- 가져오기: `__declspec(dllimport)` → 최적화.
- 런타임 해석: `LoadLibrary/GetProcAddress`.

### 16.2 macOS(Mach-O/dyld)
- **Two-Level Namespace**(DSO별 네임스페이스) — **이름 충돌·인터포지션 영향이 줄어듦**.
- 경로: `@rpath/@loader_path/@executable_path`.
- 인터포지션: `DYLD_INSERT_LIBRARIES`(보안 제약 존재), `__interpose` 섹션 기반 기법.

---

## 17. 실전 레시피 모음

### 17.1 선택적 플러그인 훅(약 참조)
```c
// core.c
__attribute__((weak)) void plugin_init(void);
int main(){ if (plugin_init) plugin_init(); }
```
```c
// plugin.c
#include <stdio.h>
void plugin_init(void){ puts("plugin loaded"); }
```
```bash
gcc -fPIC -shared plugin.c -o libplug.so
gcc core.c -ldl -o app
LD_PRELOAD=./libplug.so ./app   # → "plugin loaded"
```

### 17.2 내부 참조 고정(성능/안정)
```bash
gcc -fPIC -shared lib.c -o libx.so -Wl,-Bsymbolic -fno-semantic-interposition
```

### 17.3 내보내기 화이트리스트(버전 스크립트)
```ld
LIB_1.0 { global: x_*; local: *; };
```
```bash
gcc -shared x.c -Wl,--version-script=exports.map -o libx.so
```

---

## 18. 자주 겪는 장애와 즉시 처방

증상 | 원인 | 확인/툴 | 처방
---|---|---|---
`undefined reference`(정적) | 라이브러리 순서 역전 | 명령행·`-Wl,-Map=` | 참조 뒤에 `-l` 배치, group 사용
정의가 있는데도 안 불림 | 인터포지션 선점 | `LD_DEBUG=bindings` | `-Bsymbolic`/가시성 축소
첫 호출만 느림 | Lazy 바인딩 | `LD_DEBUG=bindings` | `LD_BIND_NOW=1` or `-Wl,-z,now`
전역 데이터 일관성 깨짐 | Copy relocation | `objdump -R` | PIE+PIC, 전역 캡슐화
TLS가 느림 | GD/LD 모델 | `objdump -r` | IE/LE로 재구성(제약 확인)

---

## 19. 체크리스트(요점만)

- [ ] 정적: **왼→오**, 아카이브는 **필요 시만 풀림**, group로 순환 해결
- [ ] 강/약 규칙·ODR 준수, C/C++ 혼용시 `extern "C"`
- [ ] 공개 API만 `DEFAULT`, 나머지 `HIDDEN/PROTECTED`
- [ ] 인터포지션 억제: `-Bsymbolic`/`-fno-semantic-interposition`
- [ ] 보안: PIE + Full RELRO(NOW) + NX + FORTIFY + SSP
- [ ] 동적: RUNPATH는 `$ORIGIN`로 고정, 불필요 NEEDED 제거
- [ ] 성능: IFUNC/TLS 모델 선정, PLT 간접 최소화
- [ ] 진단: `LD_DEBUG`/`readelf -Ws/-dW`/`objdump -R`/맵파일

---

## 20. 마무리 — “설계된 해석”이 정답

심볼 해석은 **링커·로더·가시성·바인딩·버전·TLS**가 교차하는 설계 문제다.
무턱대고 DEFAULT로 내보이고 인터포지션을 허용하면 **성능을 잃고 공격면을 넓힌다**.
반대로 **가시성 축소 + 내부 고정 + 버전 스크립트**로 해석을 **의도대로 설계**하면,
정확성·성능·보안을 동시에 잡을 수 있다.
마지막은 항상 **툴로 확인**하라 — “말이 아닌 로그/맵/숫자”가 결론이다.
