---
layout: post
title: 영상처리 - 밝기와 명암비 조절
date: 2025-09-18 20:25:23 +0900
category: 영상처리
---
# 밝기와 명암비 조절

## 1) 이론 정리: 밝기/명암비의 의미

### 1.1 밝기(Brightness)
픽셀 값(채널 값)을 **일정 값 \(\beta\)** 만큼 더하거나 빼는 연산입니다.

- 8-bit 정수 채널 \(v\in[0,255]\) 에 대해  
  \[
  v' \;=\; \mathrm{clamp}\bigl(v + \beta,\; 0,\; 255\bigr)
  \]

### 1.2 명암비(Contrast)
픽셀 값을 **중간값** 주위로 **스케일링**합니다. 8-bit의 중간값은 128로 보고, **비율 \(\alpha\)** 로 늘리거나 줄입니다.

\[
v' \;=\; \mathrm{clamp}\bigl(\,\alpha\,(v-128)+128,\;0,\;255\bigr)
\]

### 1.3 밝기+명암비 동시 적용
보통 한 번에 처리합니다.

\[
\boxed{\,v' \;=\; \mathrm{clamp}\bigl(\,\alpha\,(v-128)+128+\beta,\;0,\;255\bigr)\,}
\]

- \(\beta\) : 밝기(오프셋), 예: \([-255, +255]\)  
- \(\alpha\) : 명암비(기울기), 예: \([0, 2]\) 또는 \([0.1, 3]\)

UI 슬라이더를 다음처럼 매핑하면 직관적입니다.

- **밝기 슬라이더** \(\in[-255, +255]\) → \(\beta\) 그대로 사용  
- **명암비 슬라이더** \(\in[-100,+100]\) → \(\alpha = 1 + \dfrac{\text{slider}}{100}\)  
  - \(-100 \Rightarrow \alpha=0\) (완전 회색), \(0\Rightarrow 1\) (그대로), \(+100\Rightarrow 2\) (2배 대비)

> 다른 매핑(감마 스타일, 259 공식을 쓰는 방식 등)도 있지만, 본 글은 단순·직관적인 **선형 모델**을 채택합니다.

---

## 2) 구현 전략: **LUT(룩업 테이블)** 로 빠르게

매 프레임/슬라이더 이벤트에 픽셀마다 실수 연산을 하면 느려집니다.  
**256개 원소의 LUT** 를 미리 만들어 `out[v]` 를 O(1)로 얻으면 매우 빠릅니다.

- 고정소수점으로 \(\alpha\) 를 \(\text{fp} = \lfloor 256\alpha \rceil\) 로 바꾸고,  
  \[
  \text{temp} \;=\; \frac{\text{fp}\cdot(v-128) + 128\cdot256}{256} + \beta
  \]
  를 정수로 계산 → **클램프** → LUT 저장.

---

## 3) 핵심 코드 — **계산/LUT/적용**

### 3.1 유틸: 클램프/정수 라운드
```cpp
// BrightContrast.h
#pragma once
#include <cstdint>
#include <algorithm>
#include <cmath>

inline uint8_t clamp_u8(int v) { return (uint8_t)std::min(255, std::max(0, v)); }
```

### 3.2 LUT 생성
```cpp
// alpha = 1 + c/100 (c: [-100,100]), beta = brightness [-255,255]
inline void BuildBrightnessContrastLUT(int brightness, int contrast, uint8_t lut[256]) {
    // 명암비: 1 + c/100.0 → 고정소수점(×256)으로
    const double a  = 1.0 + contrast / 100.0;
    const int    afp = (int)std::lround(a * 256.0);
    const int    b   = brightness; // 그대로 더하기

    for (int v=0; v<256; ++v) {
        // temp = (afp*(v-128) + 128*256) >> 8  + b
        int t = ((afp * (v - 128) + 128 * 256) >> 8) + b;
        lut[v] = clamp_u8(t);
    }
}
```

### 3.3 **IppDib(BGRA32)** 에 LUT 적용 (B,G,R만 변환, A는 보존)
```cpp
#include "IppDib.h"

inline void ApplyBC_ToDIB_BGRA32(IppDib& dib, const uint8_t lut[256]) {
    if (!dib) return;
    for (int y=0; y<dib.height(); ++y) {
        uint8_t* row = (uint8_t*)dib.bits() + (size_t)y * dib.stride();
        for (int x=0; x<dib.width(); ++x) {
            uint8_t* p = &row[x*4];
            p[0] = lut[p[0]]; // B
            p[1] = lut[p[1]]; // G
            p[2] = lut[p[2]]; // R
            // p[3] = A 그대로
        }
    }
}
```

### 3.4 **IppImage(BGR24, Gray8)** 에 LUT 적용 (선택)
```cpp
#include "IppImage.h"

// BGR24
inline void ApplyBC_ToBGR24(IppImage<uint8_t,3>& img, const uint8_t lut[256]) {
    if (!img) return;
    for (int y=0; y<img.height(); ++y) {
        uint8_t* r = reinterpret_cast<uint8_t*>(img.rowp(y));
        for (int x=0; x<img.width(); ++x) {
            uint8_t* p = &r[x*3];
            p[0] = lut[p[0]];
            p[1] = lut[p[1]];
            p[2] = lut[p[2]];
        }
    }
}

// Gray8
inline void ApplyBC_ToGray8(IppImage<uint8_t,1>& img, const uint8_t lut[256]) {
    if (!img) return;
    for (int y=0; y<img.height(); ++y) {
        uint8_t* r = img.rowp(y);
        for (int x=0; x<img.width(); ++x) r[x] = lut[r[x]];
    }
}
```

---

## 4) **밝기/명암비 조절 대화 상자 만들기**

### 4.1 리소스 ID 추가 — `res/resource.h`
```cpp
// Dialog
#define IDD_BRIGHTCONTRAST            310

// Controls
#define IDC_SLIDER_BRIGHT             1001
#define IDC_SLIDER_CONTRAST           1002
#define IDC_EDIT_BRIGHT               1003
#define IDC_EDIT_CONTRAST             1004
#define IDC_CHECK_PREVIEW             1005
#define IDC_BTN_RESET                 1006

// Menu command
#define ID_IMAGE_BRIGHTCONTRAST       40200
```

### 4.2 대화 상자 템플릿 — `res/ImageTool.rc`
```rc
#include "resource.h"
#include <windows.h>

IDD_BRIGHTCONTRAST DIALOGEX 0, 0, 260, 150
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Brightness / Contrast"
FONT 9, "Segoe UI"
BEGIN
    LTEXT       "Brightness (-255 .. +255):", -1, 10, 12, 120, 10
    CONTROL     "", IDC_SLIDER_BRIGHT,  TRACKBAR_CLASS, WS_TABSTOP | TBS_AUTOTICKS, 10, 24, 160, 16
    EDITTEXT    IDC_EDIT_BRIGHT,                           180, 22, 60, 14, ES_NUMBER | WS_TABSTOP

    LTEXT       "Contrast (-100 .. +100):",   -1, 10, 50, 120, 10
    CONTROL     "", IDC_SLIDER_CONTRAST, TRACKBAR_CLASS, WS_TABSTOP | TBS_AUTOTICKS, 10, 62, 160, 16
    EDITTEXT    IDC_EDIT_CONTRAST,                          180, 60, 60, 14, ES_NUMBER | WS_TABSTOP

    AUTOCHECKBOX "Preview", IDC_CHECK_PREVIEW, 10, 90, 60, 12, WS_TABSTOP
    PUSHBUTTON   "Reset",   IDC_BTN_RESET,     120, 90,  50, 14, WS_TABSTOP
    DEFPUSHBUTTON "OK",     IDOK,              120, 115, 50, 14
    PUSHBUTTON   "Cancel",  IDCANCEL,          190, 115, 50, 14
END
```

> **트랙바 범위**
> - 밝기: \([-255, +255]\)  
> - 명암비: \([-100, +100]\)  
> 틱 간격은 `TBS_AUTOTICKS`로 자동, 필요하면 `TBM_SETTICFREQ`로 조절하세요.

---

## 5) **대화 상자 클래스** (실시간 미리보기)

미리보기는 다음 방식이 가장 단순하고 안전합니다.

1. 다이얼로그 시작 시 **원본 픽셀**을 **백업**(std::vector)  
2. 슬라이더 움직일 때마다 **백업에서 복사 → LUT 적용 → 화면 갱신**  
3. **OK**: 적용된 상태 유지, **Cancel**: 백업을 되돌려 **원상복구**

```cpp
// BrightContrastDlg.h
#pragma once
#include <vector>
#include <string>
#include <commctrl.h>
#include "resource.h"
#include "IppDib.h"
#include "BrightContrast.h"

class BrightContrastDlg {
public:
    BrightContrastDlg(HWND owner, IppDib& dib)
        : owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);
    INT_PTR OnHScroll(HWND h, WPARAM w, LPARAM l);

    void SyncEditsFromSliders(HWND h);
    void SyncSlidersFromEdits(HWND h);
    void GetValuesFromControls(HWND h, int& bright, int& contrast);
    void ApplyPreview(HWND h);
    void ResetPreview();
    void BackupOriginal();
    void RestoreOriginal();
    void RepaintOwner();

private:
    HWND   owner_ = nullptr;
    HWND   hDlg_  = nullptr;
    IppDib& dib_;

    // 백업(원본 BGRA32)
    std::vector<uint8_t> backup_;
    int width_ = 0, height_ = 0, stride_ = 0;

    // 현재 값
    int bright_ = 0;    // [-255,255]
    int contrast_ = 0;  // [-100,100]
    bool preview_ = true;
};
```

```cpp
// BrightContrastDlg.cpp
#include "BrightContrastDlg.h"

INT_PTR BrightContrastDlg::DoModal() {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_BRIGHTCONTRAST),
                           owner_, DlgProc, (LPARAM)this);
}

INT_PTR CALLBACK BrightContrastDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m == WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self = reinterpret_cast<BrightContrastDlg*>(l);
        self->hDlg_ = h;
        return self->OnInit(h);
    }
    auto* self = reinterpret_cast<BrightContrastDlg*>(GetWindowLongPtrW(h, GWLP_USERDATA));
    if (!self) return FALSE;

    switch (m) {
    case WM_COMMAND: return self->OnCommand(h, w, l);
    case WM_HSCROLL: return self->OnHScroll(h, w, l);
    default: return FALSE;
    }
}

INT_PTR BrightContrastDlg::OnInit(HWND h) {
    // 초기값
    bright_ = 0; contrast_ = 0; preview_ = true;

    // 컨트롤 초기화 (트랙바 범위)
    SendDlgItemMessageW(h, IDC_SLIDER_BRIGHT,   TBM_SETRANGE, TRUE,  MAKELPARAM(-255, +255));
    SendDlgItemMessageW(h, IDC_SLIDER_CONTRAST, TBM_SETRANGE, TRUE,  MAKELPARAM(-100, +100));
    SendDlgItemMessageW(h, IDC_SLIDER_BRIGHT,   TBM_SETPOS, TRUE, bright_);
    SendDlgItemMessageW(h, IDC_SLIDER_CONTRAST, TBM_SETPOS, TRUE, contrast_);
    CheckDlgButton(h, IDC_CHECK_PREVIEW, preview_ ? BST_CHECKED : BST_UNCHECKED);
    SyncEditsFromSliders(h);

    // 원본 백업
    BackupOriginal();

    return TRUE;
}

void BrightContrastDlg::BackupOriginal() {
    if (!dib_) return;
    width_  = dib_.width();
    height_ = dib_.height();
    stride_ = dib_.stride();
    backup_.resize((size_t)height_ * stride_);
    for (int y=0; y<height_; ++y) {
        const uint8_t* s = (const uint8_t*)dib_.bits() + (size_t)y * stride_;
        std::memcpy(backup_.data() + (size_t)y * stride_, s, (size_t)stride_);
    }
}

void BrightContrastDlg::RestoreOriginal() {
    if (!dib_ || backup_.empty()) return;
    for (int y=0; y<height_; ++y) {
        uint8_t* d = (uint8_t*)dib_.bits() + (size_t)y * stride_;
        std::memcpy(d, backup_.data() + (size_t)y * stride_, (size_t)stride_);
    }
    RepaintOwner();
}

void BrightContrastDlg::RepaintOwner() {
    InvalidateRect(owner_, nullptr, FALSE);
    UpdateWindow(owner_);
}

void BrightContrastDlg::SyncEditsFromSliders(HWND h) {
    int b = (int)SendDlgItemMessageW(h, IDC_SLIDER_BRIGHT,   TBM_GETPOS, 0, 0);
    int c = (int)SendDlgItemMessageW(h, IDC_SLIDER_CONTRAST, TBM_GETPOS, 0, 0);
    SetDlgItemInt(h, IDC_EDIT_BRIGHT,   b, TRUE);
    SetDlgItemInt(h, IDC_EDIT_CONTRAST, c, TRUE);
}

void BrightContrastDlg::SyncSlidersFromEdits(HWND h) {
    BOOL okB=FALSE, okC=FALSE;
    int b = GetDlgItemInt(h, IDC_EDIT_BRIGHT, &okB, TRUE);
    int c = GetDlgItemInt(h, IDC_EDIT_CONTRAST, &okC, TRUE);
    if (!okB) b=0; if (!okC) c=0;
    b = std::max(-255, std::min(+255, b));
    c = std::max(-100, std::min(+100, c));
    SendDlgItemMessageW(h, IDC_SLIDER_BRIGHT,   TBM_SETPOS, TRUE, b);
    SendDlgItemMessageW(h, IDC_SLIDER_CONTRAST, TBM_SETPOS, TRUE, c);
}

void BrightContrastDlg::GetValuesFromControls(HWND h, int& bright, int& contrast) {
    bright   = (int)SendDlgItemMessageW(h, IDC_SLIDER_BRIGHT,   TBM_GETPOS, 0, 0);
    contrast = (int)SendDlgItemMessageW(h, IDC_SLIDER_CONTRAST, TBM_GETPOS, 0, 0);
}

void BrightContrastDlg::ApplyPreview(HWND h) {
    if (!dib_) return;
    preview_ = (IsDlgButtonChecked(h, IDC_CHECK_PREVIEW) == BST_CHECKED);
    GetValuesFromControls(h, bright_, contrast_);

    if (!preview_) {
        RestoreOriginal();
        return;
    }

    // 1) 원본에서 다시 복사
    for (int y=0; y<height_; ++y) {
        uint8_t* d = (uint8_t*)dib_.bits() + (size_t)y * stride_;
        std::memcpy(d, backup_.data() + (size_t)y * stride_, (size_t)stride_);
    }

    // 2) LUT 적용 → BGRA32 BGR 채널
    uint8_t lut[256];
    BuildBrightnessContrastLUT(bright_, contrast_, lut);
    ApplyBC_ToDIB_BGRA32(dib_, lut);

    // 3) 화면 갱신
    RepaintOwner();
}

void BrightContrastDlg::ResetPreview() {
    SetDlgItemInt(hDlg_, IDC_EDIT_BRIGHT, 0, TRUE);
    SetDlgItemInt(hDlg_, IDC_EDIT_CONTRAST, 0, TRUE);
    SyncSlidersFromEdits(hDlg_);
    ApplyPreview(hDlg_);
}

INT_PTR BrightContrastDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)) {
    case IDC_EDIT_BRIGHT:
    case IDC_EDIT_CONTRAST:
        if (HIWORD(w) == EN_CHANGE) {
            SyncSlidersFromEdits(h);
            ApplyPreview(h);
            return TRUE;
        }
        break;

    case IDC_CHECK_PREVIEW:
        ApplyPreview(h);
        return TRUE;

    case IDC_BTN_RESET:
        ResetPreview();
        return TRUE;

    case IDOK:
        // Preview 켠 상태면 이미 적용 완료. 꺼져있다면 원본 → 값 적용
        if (!preview_) {
            // 원본에서 복구 후 적용
            RestoreOriginal();
            uint8_t lut[256];
            BuildBrightnessContrastLUT(bright_, contrast_, lut);
            ApplyBC_ToDIB_BGRA32(dib_, lut);
            RepaintOwner();
        }
        EndDialog(h, IDOK);
        return TRUE;

    case IDCANCEL:
        // 원본으로 복구
        RestoreOriginal();
        EndDialog(h, IDCANCEL);
        return TRUE;
    }
    return FALSE;
}

INT_PTR BrightContrastDlg::OnHScroll(HWND h, WPARAM, LPARAM l) {
    HWND hCtrl = (HWND)l;
    if (hCtrl == GetDlgItem(h, IDC_SLIDER_BRIGHT) ||
        hCtrl == GetDlgItem(h, IDC_SLIDER_CONTRAST)) {
        SyncEditsFromSliders(h);
        ApplyPreview(h);
        return TRUE;
    }
    return FALSE;
}
```

> **성능 팁**  
> - 원본 한 벌을 **백업(1회)** 하고, 슬라이더 변경마다 **백업 → 대상 복사 → LUT 적용**의 2-pass만 수행합니다.  
> - 초대형 이미지라면 **타일 단위**로 적용하거나, **OpenMP 병렬**(행 병렬)을 추가하면 더 빠릅니다.

---

## 6) **메뉴 추가** 및 **핸들러 연결**

### 6.1 메뉴 — `res/ImageTool.rc`
```rc
POPUP "&Image"
BEGIN
    MENUITEM "Brightness / Contrast...\tCtrl+B", ID_IMAGE_BRIGHTCONTRAST
END

// Accelerator (선택)
IDR_ACCEL ACCELERATORS
BEGIN
    "B",  ID_IMAGE_BRIGHTCONTRAST, VIRTKEY, CONTROL
END
```

### 6.2 메인 윈도우 처리기 — `main_multiwin.cpp` (일부)
```cpp
#include "BrightContrastDlg.h"

// ... WndProc의 WM_COMMAND 스위치문에 추가 ...
case ID_IMAGE_BRIGHTCONTRAST:
    if (st && st->dib) {
        BrightContrastDlg dlg(hWnd, st->dib);
        if (dlg.DoModal() == IDOK) {
            // 출력창/상태바 갱신 (선택)
            OutputBasicInfo(st);
            UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 7) **IppImage 기반 구현** (선택사항)

이미지 처리 레이어를 **IppImage<T,C>** 로 일원화하고 싶다면:

1) 미리보기마다 **IppDib → IppImage(BGR24)** 로 복사  
2) LUT 적용 후 **IppImage → IppDib** 로 되돌리기

```cpp
#include "IppInterOp.h" // FromIppDib, ToIppDib

inline void ApplyBC_IppImageRoundTrip(IppDib& dib, const uint8_t lut[256]) {
    BGR24 img;
    FromIppDib(dib, img);
    ApplyBC_ToBGR24(img, lut);
    ToIppDib(img, dib, nullptr);
}
```

> **비교**  
> - **DIB 직접**: 복사 1회 + LUT 적용 1회 → 가장 빠름  
> - **IppImage 경유**: 코드 재사용성↑(여러 포맷 대응 쉬움) vs. 복사 비용↑

---

## 8) **UI/UX 디테일**

- **Preview 체크 박스**: 끄면 원본으로 복귀 → OK 시에만 일괄 적용  
- **Reset**: 밝기/명암비 0으로 초기화 → LUT 재적용  
- **숫자 편집**: 직접 입력 시 슬라이더 자동 동기화  
- **상태바**: 배율/크기/파일명은 기존 함수 `UpdateStatusBasic` 재사용

---

## 9) **테스트 시나리오**

1) 어두운 이미지에서 **밝기 +50** → 디테일 확인  
2) 저대비 이미지에서 **명암비 +40** → 대비 향상  
3) 과도한 대비(+100) → 하이라이트/섀도우 **클리핑** 체크  
4) 프리뷰 On/Off → OK/Cancel 동작 검증  
5) 대용량(예: 8K)에서 슬라이더 반응속도 확인(필요시 OpenMP 도입)

---

## 10) (선택) **매크로**로 반복 줄이기

```cpp
// Loop helper (선택)
#define FOR_EACH_LINE_H(dib) for (int y__=0; y__<(dib).height(); ++y__) { \
    uint8_t* row__ = (uint8_t*)(dib).bits() + (size_t)y__*(dib).stride();

#define END_FOR_EACH_LINE }

inline void ApplyBC_ToDIB_BGRA32_Macro(IppDib& dib, const uint8_t lut[256]) {
    if (!dib) return;
    FOR_EACH_LINE_H(dib)
        for (int x=0; x<dib.width(); ++x) {
            uint8_t* p = &row__[x*4];
            p[0] = lut[p[0]]; p[1] = lut[p[1]]; p[2] = lut[p[2]];
        }
    END_FOR_EACH_LINE
}
```

> 매크로는 디버깅이 까다로울 수 있으니, 가능하면 **인라인 함수**를 선호하세요.

---

## 11) **성능 팁**

- LUT는 **매 이벤트마다 재계산**(256개)해도 매우 빠릅니다(미미한 비용).  
- 대형 이미지:  
  - 행 병렬(`#pragma omp parallel for`)  
  - **타일 처리(예: 64×N)** 로 캐시 효율 개선  
- UI 딜레이가 느껴지면 **`SetTimer`로 10~30ms 디바운스** 후 적용(슬라이더 잔떨림 완화)

---

## 12) 마무리

- 밝기 \(\beta\) / 명암비 \(\alpha\) 를 **선형 모델**로 간명하게 정의  
- **LUT 기반**으로 실시간 미리보기 구현 → 대용량에서도 경쾌  
- **다이얼로그/메뉴** 연동, **Preview/Reset** UX 완비  
- 필요시 **IppImage 레이어**로 확장해 포맷 일반화 가능