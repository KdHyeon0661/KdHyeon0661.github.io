---
layout: post
title: 시스템보안 - 실습(교육용 루트킷 코드 읽기 & 탐지 룰)
date: 2025-10-26 20:30:23 +0900
category: 시스템보안
---
# 10.4 실습: 교육용 루트킷 코드 읽기 & 탐지 룰(쌍방 시점) 설계

## 10.4.1 목표와 스코프
- **목표**: (1) “교육용 루트킷 스켈레톤”의 구조를 읽으면서 **행위 기반 가정**을 세우고, (2) 그 가정에 맞춰 **EDR/OS 로깅 관점**에서 **탐지 룰**을 상향식으로 설계, (3) 운영환경으로 가져갈 **완화·정책 가드레일**을 함께 정의.
- **범위**: *커널 드라이버/유저모드 훅의 전형적인 컴포넌트*를 **읽는** 수준(로드/언로드/콜백 등록/IRP 핸들러/ETW 조작 의심 흔적 등).  
  - **하지 않음**: SSDT 패치/ETW 패치/AMSI 우회/핸들 탈취/직접 DKOM 등 **실제 변조**.

---

## 10.4.2 교육용 루트킷 스켈레톤(읽기 전용 가상 코드) — 구조 이해

> 아래는 “전형적인 커널 드라이버 샘플”을 **설명용 의사코드**로 축약한 것입니다. (악용 불가)

```c
// pseudo_driver.c (설명 목적 의사코드)
#include <ntifs.h>

PDRIVER_OBJECT g_DriverObject = NULL;
PDEVICE_OBJECT g_DeviceObject = NULL;
UNICODE_STRING g_SymLink;

// 등록할 가능성이 있는 콜백/핸들러 (전형적 관찰 포인트)
OB_CALLBACK g_ObCbHandle = NULL;     // Handle creation callbacks
PVOID       g_RegCbHandle = NULL;    // Registry callbacks
PVOID       g_ImageLoadCbHandle = NULL; // PsSetLoadImageNotifyRoutine

// IRP MajorFunction 핸들러 — 디바이스IoControl, Read/Write 등
NTSTATUS DriverDispatch(PDEVICE_OBJECT DevObj, PIRP Irp) {
    // 전형적으로 IOCTL 스위치/버퍼 검증/커널-유저 경계 처리
    // [가정] 악성이라면: 은닉/후킹/프로세스 조작/파일 필터 등의 요청을 내릴 수 있음
    return CompleteIrp(Irp, STATUS_SUCCESS, 0);
}

VOID DriverUnload(PDRIVER_OBJECT DriverObject) {
    // 등록된 콜백/객체 해제 (미정리/잔존은 IOC)
    if (g_ObCbHandle) ObUnRegisterCallbacks(g_ObCbHandle);
    if (g_RegCbHandle) CmUnRegisterCallback(g_RegCbHandle);
    if (g_ImageLoadCbHandle) PsRemoveLoadImageNotifyRoutine(MyImageLoadNotify);
    IoDeleteSymbolicLink(&g_SymLink);
    IoDeleteDevice(g_DeviceObject);
}

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    g_DriverObject = DriverObject;

    // 디바이스/심볼릭 링크 생성
    IoCreateDevice(..., &g_DeviceObject);
    RtlInitUnicodeString(&g_SymLink, L"\\DosDevices\\EduDrv");
    IoCreateSymbolicLink(&g_SymLink, ...);

    // IRP 테이블 등록: Create/Close/DeviceControl/Read/Write 등
    for (int i=0;i<=IRP_MJ_MAXIMUM_FUNCTION;i++)
        DriverObject->MajorFunction[i] = DriverDispatch;

    // 콜백 등록 (합법 드라이버도 사용, 그러나 탐지 표면)
    ObRegisterCallbacks(..., &g_ObCbHandle);         // 핸들 생성/중복 열람 모니터/필터
    CmRegisterCallbackEx(MyRegistryNotify, ..., &g_RegCbHandle); // 레지스트리 변경 감시/필터
    PsSetLoadImageNotifyRoutine(MyImageLoadNotify);  // 이미지 로드 이벤트 훅

    DriverObject->DriverUnload = DriverUnload;
    return STATUS_SUCCESS;
}

// 예: 이미지 로드 콜백 (합법적 사용도 많음)
VOID MyImageLoadNotify(PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo) {
    // [가정] 특정 모듈 로드를 감시/차단하거나, 이벤트를 유저모드로 전달
    // EDR·AMSI·ETW 관련 모듈 이름/주소 감시가 보이면 의심 근거
}
```

### 읽기 포인트(행위 가정 → 탐지 지표)
1) **DriverEntry/Unload**: *로드/언로드 이벤트*가 **짧은 주기로 반복**되는가? (시그널: 실험적 주입/은폐 시도)  
2) **콜백 등록**:  
   - `ObRegisterCallbacks`: **핸들 생성 감시/차단**(LSASS 등 민감 프로세스 접근 관여 가능) → **과도/비정상 패턴** 탐지  
   - `PsSetLoadImageNotifyRoutine`: **모듈 로드 가로채기** → **EDR/보안모듈 로드 시 간섭** 흔적  
   - `CmRegisterCallbackEx`: **레지스트리 조작**(보안 설정/로깅 변경) 관여 → **보안 키 변경** 로그와 상관  
3) **IRP 핸들러**: `DeviceIoControl`의 **비인가 제어 코드** 호출 시도(유저→커널 RPC 경유) → **이례적 IOCTL 분포**  
4) **심볼릭 링크**: 비표준 네임스페이스/권한 → **디바이스 트리 변동** IOC

---

## 10.4.3 유저모드 훅 스켈레톤(읽기 전용 가상 코드) — 구조 이해

```c
// pseudo_userhook.c (설명용 의사코드)
HMODULE hNtdll;
BYTE    SavedPrologue[16]; // 인라인 패치 복구용

typedef NTSTATUS (NTAPI *pNtQSI)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);
pNtQSI RealNtQuerySystemInformation;

NTSTATUS NTAPI HookedNtQuerySystemInformation(SYSTEM_INFORMATION_CLASS cls, PVOID buf, ULONG len, PULONG ret) {
    NTSTATUS st = RealNtQuerySystemInformation(cls, buf, len, ret);
    // [가정] 프로세스 목록/모듈 목록에서 특정 엔트리 필터링(은닉)
    return st;
}

void InstallInlineHook() {
    hNtdll = GetModuleHandleW(L"ntdll.dll");
    RealNtQuerySystemInformation = (pNtQSI)GetProcAddress(hNtdll, "NtQuerySystemInformation");
    // [가정] 프롤로그를 JMP Hooked*로 덮음 (인라인 패치)
    // 정상 제품은 서명/무결성 내에서 API 체인/프록시 구현을 사용하기도 함
}
```

### 읽기 포인트
- **인라인 패치/프롤로그 변경**: 모듈 **코드 섹션 무결성**(서명/해시)과 **실행 중 코드 페이지 보호** 추적  
- **IAT/EAT 후킹**: Import/Export 테이블 변조 흔적 → **모듈 로드/재기입 이벤트** 모니터

---

## 10.4.4 “쌍방 시점” 탐지 설계: 가정→관측→룰

### (A) 커널 측 이벤트/정책
- **Code Integrity/WDAC**: 미서명/불명 공급자 드라이버 로드 차단  
- **드라이버/콜백 레지스트리**: *새/변경 등록*의 감사를 중앙 수집  
- **ETW Provider**: CodeIntegrity, Kernel-ImageLoad, Registry, Object Manager 콜백 이벤트

**PowerShell — 드라이버/이미지 로드 스냅샷(읽기 전용)**
```powershell
# 최근 이미지 로드(Sysmon 6/7 조합)와 CodeIntegrity 차단 확인
$since=(Get-Date).AddHours(-2)
$ci = "Microsoft-Windows-CodeIntegrity/Operational"
Get-WinEvent -FilterHashtable @{LogName=$ci; StartTime=$since} |
  Where-Object {$_.Message -match "Blocked|Invalid|Unsigned"} |
  Select TimeCreated, Id, Message

Get-WinEvent -FilterHashtable @{LogName="Microsoft-Windows-Sysmon/Operational"; StartTime=$since} |
  Where-Object {$_.Id -in  (6,7)} |
  Select TimeCreated, Id, ProviderName, Message | Select -First 50
```

**KQL — 비서명/희귀 드라이버 로드**
```kusto
Sysmon | where EventID == 6 // DriverLoad
| summarize cnt=count() by ImageLoaded, Signed, SignatureStatus, bin(TimeGenerated, 1h), Computer
| where Signed != "true" or SignatureStatus != "Valid"
```

### (B) 유저 측 이벤트/정책
- **ImageLoad/ModuleLoad**: 시스템 디렉터리 외 DLL/무서명 모듈 로드 경보  
- **ProcessAccess/Memory Protection**: `VirtualProtect`, `WriteProcessMemory`, `CreateRemoteThread` 등 **주입 체인**  
- **AMSI/ETW**: 관련 DLL 로드/레지스트리 편집/세션 조작 시그널

**Sysmon 룰 스케치 — ImageLoad & ProcessAccess**
```xml
<ImageLoad onmatch="include">
  <ImageLoaded condition="end with">ntdll.dll</ImageLoaded>
  <ImageLoaded condition="end with">amsi.dll</ImageLoaded>
  <Signature condition="is">Unsigned</Signature>
</ImageLoad>
<ProcessAccess onmatch="include">
  <CallTrace condition="contains">WriteProcessMemory</CallTrace>
  <CallTrace condition="contains">VirtualProtect</CallTrace>
</ProcessAccess>
```

### (C) 디바이스/IOCTL 분포 이상
- **가정**: 교육용 드라이버라도 유저모드와 `DeviceIoControl`로 명령 교환.  
- **탐지**: 정상 업무에 없는 **새 디바이스 경로**/IOCTL 코드 분포 급증.

**KQL — 드라이버 인터페이스 의심(에이전트 텔레메트리 필요)**
```kusto
TelemetryDeviceIo
| where TimeGenerated > ago(24h)
| summarize cnt=count(), dcount(IoctlCode) by DevicePath, Process, bin(TimeGenerated, 1h)
| where cnt > 100 and DevicePath !startswith "\\Device\\KnownVendor"
```

---

## 10.4.5 랩 운영 시나리오(안전)

1) **기준선 수집**: 드라이버 로드/이미지 로드/레지스트리 변경/ProcessAccess/AMSI/ETW 관련 **정상 분포** 확보  
2) **교육용 프로젝트 코드 읽기**: DriverEntry/콜백/IRP/심볼릭 링크/유저 훅 설치 함수 **행위 가정 표** 작성  
3) **탐지 룰 시뮬**: 위 가정에 맞춘 Sigma/KQL/Sysmon 룰 **시뮬레이션 모드**  
4) **오탐 조정**: 정상 보안 도구/백업/엔드포인트 관리 에이전트를 **허용 리스트**로 먼저 등록  
5) **Enforce 전환**: WDAC/ASR/LSA PPL/AMSI 정책은 **감사→강제** 단계적 전환

---

# 10.5 방어: 커널 서명 강제, HVCI, AMSI/ETW 기반 탐지 튜닝

## 10.5.1 커널 서명 강제(드라이버 정책) — WDAC/CI/CD통합

### 핵심 원칙
- **비서명/테스트 서명 드라이버 = 금지**(랩 제외).  
- **드라이버 차단 리스트**(취약/악용 사례) **항상 최신화**.  
- **빌드 파이프라인**에 **서명/정책 검증**을 포함(드라이버 해시 자동 리포트).

**PowerShell — Code Integrity 이벤트 모니터**
```powershell
$since=(Get-Date).AddHours(-4)
Get-WinEvent -FilterHashtable @{LogName="Microsoft-Windows-CodeIntegrity/Operational"; StartTime=$since} |
  Where-Object { $_.Message -match "driver" -and $_.Message -match "Blocked|not trusted|unsigned" } |
  Select TimeCreated, Id, Message
```

**CI/CD Gate — 서명 검증(개념)**
- 빌드 산출물(드라이버 `.sys`)에 대해:
  - `signtool verify /kp /tw` 성공?  
  - 서명 체인/타임스탬프/만료일 보고  
  - WDAC 정책 시뮬레이터로 **허용/차단 결과** 직전 검증

---

## 10.5.2 HVCI(하이퍼바이저 기반 코드 무결성) & VBS

### 개념
- **HVCI**는 커널 코드 무결성을 **하이퍼바이저** 격리로 강제. 임의 커널 패치·후킹 난이도를 급상승시킴.  
- **VBS**는 자격/보안 데이터(예: Credential Guard)를 **격리 메모리**에 보관.

### 배포 체크(예시)
```powershell
Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\Microsoft\Windows\DeviceGuard |
  Select SecurityServicesConfigured, SecurityServicesRunning, VirtualizationBasedSecurityStatus
```

### 운영 포인트
- **드라이버 호환성**: 레거시 드라이버는 HVCI와 충돌 가능 → 공급사 업데이트 필요  
- **정책 계층화**: HVCI + WDAC + Driver Blocklist(누적) → **다중 방어**

---

## 10.5.3 AMSI/ETW 기반 탐지 튜닝

### AMSI(안티멀웨어 스캔 인터페이스)
- **역할**: 스크립트/매크로/메모리 내 콘텐츠를 **엔진으로 전달**해 검사  
- **튜닝 포인트**:
  - **우회 시그널**: `amsi.dll` 재로딩/교체, `AmsiScanBuffer` 호출 실패율 급증  
  - **허용 리스트**: 정상 대용량 스크립팅 워크로드는 **오탐 억제**(특정 경로/서명자/해시)

**KQL — AMSI 실패/오류율 감시(개념)**
```kusto
AmsiEvents
| where TimeGenerated > ago(24h)
| summarize total=count(), fail=sumif(1, Result == "Error") by Process, bin(TimeGenerated, 1h)
| extend failRate = todouble(fail) / todouble(total)
| where failRate > 0.3 and total > 50
```

### ETW(이벤트 추적)
- **역할**: 커널/사용자 활동 가시화. **우회는 ETW 세션 중단/필터 조작** 형태를 띰.  
- **튜닝 포인트**:
  - ETW 세션 시작/중지/프로바이더 변동 로그 **즉시 알림**
  - 보안 중요 프로바이더(예: `Microsoft-Windows-Kernel-Process`, CodeIntegrity, Threat-Intelligence 등) 모니터

**KQL — ETW 세션 변동 탐지(개념)**
```kusto
EtwAdmin
| where TimeGenerated > ago(24h)
| where Operation in ("StartTrace","StopTrace","UpdateTrace")
| summarize cnt=count() by Operation, bin(TimeGenerated, 15m), Computer
| where cnt > 5
```

---

## 10.5.4 ASR/WDAC/LSA PPL 연동 — 가드레일 셋

- **ASR(Attack Surface Reduction)**: 주입/LOLBin/Office 하위 프로세스 차단 → 유저 훅·주입 경로를 **초기에 끊음**  
- **WDAC**: **서명/경로/정책**으로 **모듈·스크립트 로딩** 경로 차단  
- **LSA PPL**: 자격 모듈/프로세스 **핸들 제한**(루트킷이 자격 탈취로 이어지지 않도록)

**PowerShell — LSA PPL 상태**
```powershell
Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name RunAsPPL
```

---

## 10.5.5 운영 체크리스트

**정책**
- [ ] WDAC 적용(감사→강제), **드라이버 차단 리스트 최신화**  
- [ ] HVCI/VBS 상태 **전면 켜기**(호환성 검증 후)  
- [ ] LSA PPL + Credential Guard 배포

**탐지**
- [ ] Sysmon 1/3/6/7/10/11/12~14/22~26 수집  
- [ ] CodeIntegrity/ETW/Admin 로그 보전, **StopTrace/wevtutil/logman** 즉시 경보  
- [ ] AMSI 오류율/로드 이벤트/서명 미스매치 알림

**허용 리스트**
- [ ] EDR/백업/관리 에이전트 서명자/경로 화이트리스트  
- [ ] 업무상 스크립트 엔진/모듈 **허용 사전등록**, 주기 검증

**드릴**
- [ ] “비서명 드라이버 로드 시도”/“ETW 중단 시도”/“AMSI 오류 급증” **테이블탑**  
- [ ] 룰 임계치/화이트리스트 **분기별 재평가**

---

## 10.5.6 트러블슈팅(자주 묻는 질문)

- **HVCI 켰더니 특정 장치 드라이버가 동작 안 함**  
  → 공급사 최신 버전 필요. 임시 예외는 **장치 한정/기간 한정**, 교체 일정 문서화.

- **AMSI로 인해 업무 스크립트가 느려짐**  
  → 서명·경로 기반 허용 리스트로 오탐 줄이고, **캐시/스캔 예외는 최소 범위**만.

- **WDAC 때문에 서드파티 툴 배포가 번거로움**  
  → CI/CD에 **정책 시뮬레이터**를 넣어 사전 검증. 정책은 **정기 릴리즈(버전)**로 관리.

- **Sysmon 이벤트가 너무 많아 SIEM 비용 상승**  
  → 룰을 **두 단계**로 분리: (1) 에지 필터링(에이전트 측) (2) 코어 룰(중앙). 희귀도/위험 기반 샘플링 병행.

---

# 마무리 요약
- “교육용 루트킷 코드 읽기”의 핵심은 **구조(로드/콜백/IRP/훅)**에서 **탐지 가능한 행위 가정**을 도출하는 것입니다.  
- **WDAC+HVCI+ASR+LSA PPL**의 조합은 **커널/유저 후킹의 난이도**를 구조적으로 올립니다.  
- **AMSI/ETW**는 가시성의 축 — **우회 시도 자체**를 이벤트로 보고 **즉시 알림**을 설계하세요.  
- 모든 룰/정책은 **허용 리스트 선(先)구축 → 감사 모드 → 강제 전환**의 루프로 운영해야 **오탐·업무 영향**을 최소화할 수 있습니다.
