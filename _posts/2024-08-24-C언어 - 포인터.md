---
layout: post
title: C - 포인터
date: 2024-08-24 19:20:23 +0900
category: C
---
# 포인터(Pointer)

## 워밍업: 3분 압축 데모

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>  // PRIxPTR
#include <stdint.h>

// 안전 출력: %p는 void*만 정의적 → (void*)로 캐스팅
static void print_addr(const void *p) {
    printf("addr=%p (0x%" PRIxPTR ")\n", (const void*)p, (uintptr_t)p);
}

static void swap_int(int *a, int *b) { int t=*a; *a=*b; *b=t; }

static size_t count_lt(const int *p, size_t n, int x) {
    size_t c=0;
    for (const int *it=p; it!=p+n; ++it) if (*it < x) ++c; // 포인터 산술
    return c;
}

int add(int a,int b){return a+b;}
int mul(int a,int b){return a*b;}

int main(void){
    int v[]={10,20,30};
    int *p = v;               // 배열→포인터 디케이(decay)
    print_addr(p);
    printf("%d %d %d\n", *p, *(p+1), p[2]); // 10 20 30

    swap_int(&v[0], &v[2]);
    printf("%d %d %d\n", v[0], v[1], v[2]); // 30 20 10

    printf("<20: %zu\n", count_lt(v, 3, 20)); // 1

    // 문자열: 리터럴은 읽기 전용
    const char *s = "World";
    printf("%s (len=%zu)\n", s, strlen(s));

    // 함수 포인터
    int (*op)(int,int) = add;
    printf("op: %d\n", op(3,4)); // 7
    op = mul;
    printf("op: %d\n", op(3,4)); // 12

    return 0;
}
```

---

## 포인터의 본질과 핵심 개념

포인터는 **메모리 주소를 값으로 저장하는 변수**입니다. 두 가지 핵심 연산자인 `&`(주소 연산자)와 `*`(역참조 연산자)를 통해 메모리를 직접 다룰 수 있는 능력을 부여합니다.

```c
int a = 10;
int *p = &a;        // p는 a의 주소를 저장
printf("%p\n", (void*)p); // 주소 출력
printf("%d\n", *p);       // 10 - 저장된 주소의 값을 읽음
```

포인터를 사용할 때 가장 중요한 것은 **수명(lifetime)**과 **소유권(ownership)** 개념입니다:
- **자동 변수(스택)**: 함수가 종료되면 소멸되므로, 그 주소를 외부로 반환하거나 저장하면 안 됩니다.
- **정적/전역 변수**: 프로그램 전체 실행 동안 유효합니다.
- **동적 할당(malloc 계열)**: 명시적으로 `free()`를 호출하기 전까지 메모리가 유지됩니다. 누가 언제 메모리를 해제할지가 명확해야 합니다.

```c
int *bad_example(void) {
    int x = 42;
    return &x; // ❌ 위험: x는 함수 종료 시 소멸됨
}
```

---

## 포인터의 속성과 안전한 사용법

### 크기와 정렬
포인터의 크기는 플랫폼에 따라 다릅니다(32비트에서는 4바이트, 64비트에서는 8바이트). 또한 모든 데이터 타입은 특정 **정렬(alignment)** 요구사항을 가지며, 잘못 정렬된 주소로 접근하면 정의되지 않은 동작(UB)이 발생할 수 있습니다.

```c
#include <stdint.h>
uintptr_t addr = (uintptr_t)malloc(16);
// 4바이트 정렬 검사 예시
if (addr % 4 == 0) { /* 적절히 정렬됨 */ }
```

### 주소 출력의 올바른 방법
포인터 주소를 출력할 때는 반드시 `%p` 서식 지정자와 `(void*)` 캐스팅을 함께 사용해야 합니다.

```c
int *p = ...;
printf("%p\n", (void*)p); // 올바른 방법
```

---

## 타입 한정자: 코드 의도를 명확히 하기

### const의 세 가지 형태
`const`는 포인터 사용 의도를 컴파일러와 다른 프로그래머에게 명확히 전달합니다.

```c
int x = 1, y = 2;

const int *a = &x;  // 가리키는 값이 상수 (읽기 전용)
// *a = 3;          // ❌ 컴파일 에러
a = &y;             // ✅ 다른 주소로 변경 가능

int * const b = &x; // 포인터 자체가 상수 (주소 고정)
*b = 3;             // ✅ 값 변경 가능
// b = &y;          // ❌ 주소 변경 불가

const int * const c = &x; // 값과 포인터 모두 상수
```

문자열 리터럴은 항상 `const char*`로 다루어야 합니다:
```c
const char *s = "Hello"; // 이 문자열은 수정할 수 없음
```

### restrict와 volatile
- `restrict`: "이 포인터가 가리키는 메모리는 이 포인터를 통해서만 접근한다"는 힌트를 컴파일러에게 제공하여 최적화를 가능하게 합니다.
- `volatile`: 컴파일러의 최적화를 억제하며, 하드웨어 레지스터나 시그널 핸들러에서 사용되는 변수에 필요합니다.

---

## 포인터 산술: 배열과의 밀접한 관계

포인터 산술은 배열 요소 접근의 근간이 됩니다. `p + k`는 실제로 `k * sizeof(*p)` 바이트만큼 이동합니다.

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;        // arr[0]의 주소
int *q = p + 3;      // arr[3]의 주소
ptrdiff_t diff = q - p; // 3 (요소 개수 차이)
```

**중요**: 포인터 산술과 비교는 동일한 배열(또는 배열의 끝 바로 다음) 내에서만 정의된 동작입니다. 서로 다른 배열의 포인터를 빼거나 비교하는 것은 정의되지 않은 동작입니다.

---

## 특수한 포인터 상태와 안전 패턴

### NULL 포인터
의도적으로 아무것도 가리키지 않음을 나타냅니다.

```c
int *p = NULL;
if (p != NULL) {  // 항상 검사 후 사용
    printf("%d\n", *p);
}
```

### Dangling과 Wild 포인터
- **Dangling 포인터**: 이미 해제되거나 소멸된 메모리를 가리키는 포인터
- **Wild 포인터**: 초기화되지 않은 포인터 (임의의 주소값을 가짐)

### 안전 패턴
함수가 포인터를 반환할 때는 실패 시 `NULL`을 반환하는 sentinel 패턴을 사용하고, 호출자는 반드시 이를 검사해야 합니다.

```c
int *create_array(size_t size) {
    if (size == 0) return NULL;
    int *arr = malloc(size * sizeof(int));
    if (!arr) return NULL;  // 할당 실패 시 NULL
    return arr;
}

// 사용 예
int *my_array = create_array(100);
if (!my_array) {
    // 오류 처리
}
```

---

## 배열과 포인터: 디케이(Decay) 현상

배열 이름은 대부분의 상황에서 첫 번째 요소의 포인터로 변환됩니다. 이를 "배열에서 포인터로의 디케이"라고 합니다.

```c
int arr[5];
int *p = arr;      // arr은 &arr[0]으로 변환됨

// 중요한 예외 경우들:
sizeof(arr);       // 전체 배열 크기 (디케이 발생 안 함)
&arr;              // int (*)[5] 타입 (배열 전체에 대한 포인터)
```

### 다차원 배열 전달
함수에 다차원 배열을 전달할 때는 열(column) 크기를 명시해야 합니다.

```c
// 고정 크기 배열
void process_matrix(int matrix[][3], int rows) {
    // matrix[r][c] 접근 가능
}

// 가변 길이 배열(VLA) - C99
void process_vla(int rows, int cols, int matrix[rows][cols]) {
    // 유연한 크기 처리
}
```

---

## 구조체와 포인터

구조체 포인터는 `->` 연산자를 통해 멤버에 접근할 수 있으며, 이는 `(*ptr).member`의 편의 문법입니다.

```c
typedef struct {
    int id;
    char name[50];
    double salary;
} Employee;

Employee emp = {1, "John", 50000.0};
Employee *ptr = &emp;

printf("%s의 급여: %.2f\n", ptr->name, ptr->salary);
```

구조체 내부의 메모리 정렬과 패딩을 이해하는 것은 메모리 매핑, 네트워크 프로그래밍, 파일 I/O에서 중요합니다.

---

## 문자열: 문자 포인터의 가장 흔한 사용처

C에서 문자열은 널 문자(`\0`)로 종료되는 문자 배열입니다.

```c
// 문자열 리터럴 (읽기 전용 메모리)
const char *str1 = "Hello, World!";

// 수정 가능한 문자열
char str2[] = "Hello";
str2[0] = 'h';  // ✅ 수정 가능

// 동적 할당 문자열
char *str3 = malloc(20 * sizeof(char));
if (str3) {
    strcpy(str3, "Dynamic string");
    free(str3);  // 반드시 해제
}
```

**중요**: 문자열 리터럴은 수정하지 마세요. 이는 정의되지 않은 동작을 일으킵니다.

---

## 함수 인자로서의 포인터: 다양한 패턴

포인터를 함수 인자로 사용하는 세 가지 주요 패턴:

### 1. 입력 전용 (Read-only)
```c
// 배열의 합계 계산
double calculate_average(const int *numbers, size_t count) {
    long sum = 0;
    for (size_t i = 0; i < count; i++) {
        sum += numbers[i];
    }
    return (double)sum / count;
}
```

### 2. 출력 전용 (Write-only)
```c
// 여러 결과 반환
void get_min_max(const int *arr, size_t n, int *out_min, int *out_max) {
    if (n == 0) return;
    *out_min = *out_max = arr[0];
    for (size_t i = 1; i < n; i++) {
        if (arr[i] < *out_min) *out_min = arr[i];
        if (arr[i] > *out_max) *out_max = arr[i];
    }
}
```

### 3. 입력-출력 (Read-Write)
```c
// 배열 요소 두 배로
void double_values(int *arr, size_t n) {
    for (size_t i = 0; i < n; i++) {
        arr[i] *= 2;
    }
}
```

### 4. 생성자 패턴 (소유권 전달)
```c
// 메모리 할당과 소유권 전달
int create_buffer(size_t size, void **buffer) {
    *buffer = malloc(size);
    return (*buffer != NULL) ? 0 : -1;
}
```

---

## 이중 포인터: 포인터를 변경해야 할 때

이중 포인터는 포인터의 값을 변경해야 할 때 사용됩니다. 주로 동적 메모리 재할당이나 함수에서 포인터 자체를 수정해야 할 때 필요합니다.

```c
// 포인터를 NULL로 설정
void safe_free(void **ptr) {
    if (ptr && *ptr) {
        free(*ptr);
        *ptr = NULL;  // dangling 포인터 방지
    }
}

// 재할당 패턴 (실패 안전)
int resize_array(int **arr, size_t *capacity, size_t new_capacity) {
    int *temp = realloc(*arr, new_capacity * sizeof(int));
    if (!temp) return -1;  // 실패 시 원본 유지
    
    *arr = temp;
    *capacity = new_capacity;
    return 0;
}
```

---

## 함수 포인터: 런타임 다형성과 콜백

함수 포인터는 C에서 고차 함수(higher-order function)를 구현하고 런타임에 동작을 변경할 수 있게 합니다.

### 기본 사용법
```c
int add(int a, int b) { return a + b; }
int multiply(int a, int b) { return a * b; }

int main(void) {
    // 함수 포인터 선언
    int (*operation)(int, int);
    
    operation = add;
    printf("5 + 3 = %d\n", operation(5, 3));  // 8
    
    operation = multiply;
    printf("5 * 3 = %d\n", operation(5, 3));  // 15
    
    return 0;
}
```

### 디스패치 테이블
```c
typedef double (*MathFunc)(double);

double square(double x) { return x * x; }
double cube(double x) { return x * x * x; }
double reciprocal(double x) { return 1.0 / x; }

MathFunc functions[] = {square, cube, reciprocal};

// 사용 예
double result = functions[0](5.0);  // square(5.0)
```

### qsort와 함께 사용
```c
#include <stdlib.h>

// 비교 함수
int compare_ints(const void *a, const void *b) {
    int x = *(const int*)a;
    int y = *(const int*)b;
    return (x > y) - (x < y);  // 안전한 비교
}

int main(void) {
    int arr[] = {5, 2, 8, 1, 9};
    qsort(arr, 5, sizeof(int), compare_ints);
    // arr은 이제 {1, 2, 5, 8, 9}
    return 0;
}
```

---

## void 포인터: 제네릭 프로그래밍

`void*`는 어떤 타입의 데이터도 가리킬 수 있는 범용 포인터입니다. 메모리 할당 함수나 제네릭 컨테이너 구현에 사용됩니다.

```c
// 제네릭 메모리 복사 함수
void copy_memory(void *dest, const void *src, size_t size) {
    // void*는 직접 역참조할 수 없으므로 char*로 변환
    char *d = dest;
    const char *s = src;
    
    for (size_t i = 0; i < size; i++) {
        d[i] = s[i];
    }
}

// 사용 예
int a = 42;
int b;
copy_memory(&b, &a, sizeof(int));  // b = 42
```

---

## 엄격한 별칭 규칙과 메모리 접근

엄격한 별칭 규칙(strict aliasing rule)은 서로 다른 타입의 포인터가 동일한 메모리 위치를 가리키지 않는다고 가정하는 컴파일러 최적화 규칙입니다. 이 규칙을 위반하면 정의되지 않은 동작이 발생할 수 있습니다.

```c
float f = 3.14f;

// 위험한 방법 (엄격한 별칭 규칙 위반 가능성)
// int i = *(int*)&f;  // ❌

// 안전한 방법 1: memcpy 사용
int i;
memcpy(&i, &f, sizeof(int));  // ✅

// 안전한 방법 2: 공용체 사용 (C에서 허용되는 경우)
union {
    float f;
    int i;
} converter;
converter.f = 3.14f;
int j = converter.i;  // ✅ (의도된 타입 펀닝)
```

---

## 메모리 조작 함수

C 표준 라이브러리는 메모리 조작을 위한 중요한 함수들을 제공합니다:

```c
#include <string.h>

// 1. memcpy - 겹치지 않는 메모리 복사
char src[] = "Hello";
char dest[10];
memcpy(dest, src, strlen(src) + 1);  // +1 for null terminator

// 2. memmove - 겹치는 메모리 안전 복사
char buffer[] = "ABCDEF";
memmove(buffer + 2, buffer, 4);  // "ABABCD"

// 3. memset - 메모리 영역을 특정 값으로 설정
int arr[10];
memset(arr, 0, sizeof(arr));  // 모든 요소를 0으로

// 4. memcmp - 메모리 블록 비교
int cmp = memcmp(arr1, arr2, 100 * sizeof(int));
```

---

## 2차원 배열의 동적 할당

실제 응용 프로그램에서 2차원 배열을 동적으로 할당하는 두 가지 일반적인 방법:

### 방법 1: 단일 블록 + 포인터 배열
```c
int **create_matrix(int rows, int cols) {
    // 행 포인터 배열 할당
    int **matrix = malloc(rows * sizeof(int*));
    if (!matrix) return NULL;
    
    // 모든 데이터를 위한 단일 연속 블록 할당
    int *data = malloc(rows * cols * sizeof(int));
    if (!data) {
        free(matrix);
        return NULL;
    }
    
    // 각 행 포인터 설정
    for (int i = 0; i < rows; i++) {
        matrix[i] = data + i * cols;
    }
    
    return matrix;
}

void free_matrix(int **matrix) {
    if (matrix) {
        free(matrix[0]);  // 데이터 블록 해제
        free(matrix);     // 포인터 배열 해제
    }
}
```

### 방법 2: 별도의 행 할당
```c
int **create_matrix_separate(int rows, int cols) {
    int **matrix = malloc(rows * sizeof(int*));
    if (!matrix) return NULL;
    
    for (int i = 0; i < rows; i++) {
        matrix[i] = malloc(cols * sizeof(int));
        if (!matrix[i]) {
            // 할당 실패 시 이전에 할당된 메모리 정리
            for (int j = 0; j < i; j++) {
                free(matrix[j]);
            }
            free(matrix);
            return NULL;
        }
    }
    
    return matrix;
}
```

---

## 흔한 포인터 실수와 해결책

### 1. 초기화되지 않은 포인터 사용
```c
// ❌ 잘못된 예
int *ptr;
*ptr = 10;  // 위험: 초기화되지 않은 포인터

// ✅ 올바른 예
int *ptr = NULL;
if (ptr) {
    *ptr = 10;  // 안전한 접근
}
```

### 2. 해제된 메모리 접근 (Use-After-Free)
```c
// ❌ 잘못된 예
int *ptr = malloc(sizeof(int));
free(ptr);
*ptr = 20;  // 위험: 이미 해제된 메모리

// ✅ 올바른 예
int *ptr = malloc(sizeof(int));
if (ptr) {
    free(ptr);
    ptr = NULL;  // dangling 포인터 방지
}
```

### 3. 배열 경계 초과 접근
```c
// ❌ 잘못된 예
int arr[5];
for (int i = 0; i <= 5; i++) {  // 한 칸 초과
    arr[i] = i * i;
}

// ✅ 올바른 예
int arr[5];
for (int i = 0; i < 5; i++) {  // 올바른 범위
    arr[i] = i * i;
}
```

### 4. 문자열 리터럴 수정 시도
```c
// ❌ 잘못된 예
char *str = "Hello";
str[0] = 'h';  // 정의되지 않은 동작

// ✅ 올바른 예
char str[] = "Hello";  // 배열로 선언
str[0] = 'h';  // 수정 가능
```

---

## 실제 프로젝트: 안전한 동적 배열 구현

C에서 포인터를 효과적으로 사용하는 방법을 보여주는 완전한 동적 배열 구현:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

typedef struct {
    int *data;      // 실제 데이터 저장소
    size_t size;    // 현재 요소 개수
    size_t capacity;// 할당된 메모리 용량
} IntVector;

// 벡터 초기화
IntVector* iv_create(void) {
    IntVector *vec = malloc(sizeof(IntVector));
    if (!vec) return NULL;
    
    vec->data = NULL;
    vec->size = 0;
    vec->capacity = 0;
    
    return vec;
}

// 벡터 용량 확보
int iv_reserve(IntVector *vec, size_t new_capacity) {
    if (!vec) return -1;
    
    if (new_capacity <= vec->capacity) {
        return 0;  // 이미 충분한 용량
    }
    
    // 새로운 메모리 할당
    int *new_data = realloc(vec->data, new_capacity * sizeof(int));
    if (!new_data) return -1;  // 할당 실패
    
    vec->data = new_data;
    vec->capacity = new_capacity;
    return 0;
}

// 요소 추가
int iv_push_back(IntVector *vec, int value) {
    if (!vec) return -1;
    
    // 용량이 부족하면 확장
    if (vec->size >= vec->capacity) {
        size_t new_capacity = (vec->capacity == 0) ? 4 : vec->capacity * 2;
        if (iv_reserve(vec, new_capacity) != 0) {
            return -1;  // 확장 실패
        }
    }
    
    // 요소 추가
    vec->data[vec->size] = value;
    vec->size++;
    
    return 0;
}

// 요소 접근
int iv_get(const IntVector *vec, size_t index, int *out_value) {
    if (!vec || !out_value || index >= vec->size) {
        return -1;
    }
    
    *out_value = vec->data[index];
    return 0;
}

// 벡터 해제
void iv_destroy(IntVector *vec) {
    if (vec) {
        free(vec->data);
        free(vec);
    }
}

// 사용 예제
int main(void) {
    IntVector *vec = iv_create();
    if (!vec) {
        fprintf(stderr, "벡터 생성 실패\n");
        return 1;
    }
    
    // 요소 추가
    for (int i = 0; i < 10; i++) {
        if (iv_push_back(vec, i * i) != 0) {
            fprintf(stderr, "요소 추가 실패\n");
            iv_destroy(vec);
            return 1;
        }
    }
    
    // 요소 접근 및 출력
    for (size_t i = 0; i < vec->size; i++) {
        int value;
        if (iv_get(vec, i, &value) == 0) {
            printf("vec[%zu] = %d\n", i, value);
        }
    }
    
    // 정리
    iv_destroy(vec);
    return 0;
}
```

---

## 결론: 포인터 마스터하기 위한 핵심 원칙

포인터는 C 언어의 가장 강력한 기능이자 가장 위험한 기능입니다. 효과적이고 안전하게 사용하기 위해 다음 원칙들을 기억하세요:

1. **의도 명확화**: `const`, `restrict`, `volatile`을 사용하여 포인터의 의도를 명확히 표현하세요.
2. **수명 관리**: 포인터가 가리키는 데이터의 수명을 항상 인식하고, dangling 포인터를 만들지 마세요.
3. **소유권 명확화**: 동적 메모리의 경우 누가 언제 해제할지 명확한 계약을 정하세요.
4. **경계 검사**: 배열 경계를 넘어서지 않도록 주의하세요. `size`와 함께 포인터를 전달하는 패턴을 사용하세요.
5. **NULL 안전성**: 포인터를 사용하기 전에 NULL 검사를 고려하세요.
6. **타입 안전성**: 올바른 타입의 포인터를 사용하고, 필요한 경우에만 캐스팅하세요.
7. **계층적 추상화**: 저수준 포인터 연산을 고수준 인터페이스 뒤에 숨기세요(위의 IntVector 예제처럼).

포인터를 마스터하는 것은 C 프로그래밍에서 가장 중요한 단계입니다. 처음에는 복잡하게 느껴질 수 있지만, 이러한 개념들과 패턴들을 이해하고 적용하면 메모리를 효율적으로 관리하면서도 안전한 프로그램을 작성할 수 있습니다. 연습과 경험을 통해 포인터 사용에 대한 직관을 개발하면, C 언어의 전체적인 힘과 유연성을 활용할 수 있게 될 것입니다.