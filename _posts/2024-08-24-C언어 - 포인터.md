---
layout: post
title: C - 포인터
date: 2024-08-24 19:20:23 +0900
category: C
---
# 포인터(Pointer)

## 0. 워밍업: 3분 압축 데모

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>  // PRIxPTR
#include <stdint.h>

// 안전 출력: %p는 void*만 정의적 → (void*)로 캐스팅
static void print_addr(const void *p) {
    printf("addr=%p (0x%" PRIxPTR ")\n", (const void*)p, (uintptr_t)p);
}

static void swap_int(int *a, int *b) { int t=*a; *a=*b; *b=t; }

static size_t count_lt(const int *p, size_t n, int x) {
    size_t c=0;
    for (const int *it=p; it!=p+n; ++it) if (*it < x) ++c; // 포인터 산술
    return c;
}

int add(int a,int b){return a+b;}
int mul(int a,int b){return a*b;}

int main(void){
    int v[]={10,20,30};
    int *p = v;               // 배열→포인터 디케이(decay)
    print_addr(p);
    printf("%d %d %d\n", *p, *(p+1), p[2]); // 10 20 30

    swap_int(&v[0], &v[2]);
    printf("%d %d %d\n", v[0], v[1], v[2]); // 30 20 10

    printf("<20: %zu\n", count_lt(v, 3, 20)); // 1

    // 문자열: 리터럴은 읽기 전용
    const char *s = "World";
    printf("%s (len=%zu)\n", s, strlen(s));

    // 함수 포인터
    int (*op)(int,int) = add;
    printf("op: %d\n", op(3,4)); // 7
    op = mul;
    printf("op: %d\n", op(3,4)); // 12

    return 0;
}
```

---

## 1. 포인터란?

- **메모리 주소를 값으로 담는 변수**.
- 두 기호: `&`(주소 연산자), `*`(역참조·선언에서의 “포인터임” 표식).

```c
int a = 10;
int *p = &a;
printf("%p\n", (void*)p); // 주소
printf("%d\n", *p);       // 10 (역참조)
```

| 기호 | 의미 |
|---|---|
| `&x` | x의 주소 |
| `*p` | p가 가리키는 저장소의 값(역참조) |
| `T *` | “T를 가리키는 포인터 타입” |

### 1.1 수명(lifetime)과 소유(ownership)
- **자동 변수(스택)**: 함수 종료 시 소멸 → 그 주소를 외부에 저장/반환 **금지**.
- **정적/전역**: 프로그램 전체 수명.
- **동적(`malloc` 계열)**: `free` 전까지 유효. **누가 `free`?** 소유자 명시.

```c
int *bad(void){
    int x = 42;
    return &x; // ❌ Dangling pointer (x 소멸)
}
```

---

## 2. 포인터 크기/정렬(alignment)/인쇄

- 포인터 크기는 **플랫폼 의존**(32/64비트 등). 포인터끼리의 대입은 **동일 포인터 종류** 간에만 정의적.
- 정렬: 대부분의 타입은 **자연 정렬**을 요구. 잘못 정렬된 주소로 역참조하면 UB.

```c
#include <stdint.h>
uintptr_t u = (uintptr_t)malloc(16);
// 정렬 검사 예(4바이트 정렬)
if (u % 4 == 0) { /* OK */ }
```

주소 출력은 **`%p` + (void*)**:

```c
printf("%p\n", (void*)p);
```

---

## 3. `const`/`restrict`/`volatile` — 의도 표식

### 3.1 `const` 조합 3형제

```c
int  x=1, y=2;
const int *a = &x;  // 포인터가 가리키는 "값"이 상수 (읽기 전용), a는 다른 곳 가리킬 수 있음
//*a = 3;           // ❌
a = &y;             // OK

int * const b = &x; // 포인터 "자체"가 상수(주소 고정), 값은 수정 가능
*b = 3;             // OK
//b = &y;           // ❌

const int * const c = &x; // 둘 다 상수
```

문자열 리터럴에는 **항상 `const char*`**:

```c
const char *s = "Hello"; // 수정 금지
```

### 3.2 `restrict` (C99)
- “이 포인터 경로로만 해당 저장소를 접근합니다” 힌트 → 최적화 유리.

```c
void addv(size_t n, double * restrict dst,
          const double * restrict a, const double * restrict b) {
    for (size_t i=0;i<n;++i) dst[i] = a[i] + b[i];
}
```

### 3.3 `volatile`
- 컴파일러 최적화로 제거/재정렬하면 안 되는 위치(메모리 매핑 레지스터, 시그널 플래그 등).

```c
volatile int flag;
```

---

## 4. 포인터 산술(pointer arithmetic)

- `p + k`는 **`k * sizeof(*p)` 바이트** 이동.
- 합법적 산술은 **같은 배열 내** 범위 혹은 **끝 원소 바로 다음**까지만 정의적.

```c
int v[3]={1,2,3};
int *p=v;    // &v[0]
int *q=v+3;  // &v[3] (하나 지나친 위치, 역참조 금지)
size_t n = q - p; // 3 (요소 수 차이)
```

> 서로 **다른 배열**에서 뺄셈/비교는 **UB** (동일 배열 한정).

---

## 5. NULL·Dangling·Wild 포인터

```c
int *p = NULL; // 어떤 것도 가리키지 않음
if (p) printf("%d\n", *p); // 체크 후 사용
```

- **Dangling**: 해제/소멸된 객체를 가리킴.
- **Wild**: 초기화되지 않은 임의 값.
- **Sentinel 패턴**: 실패 시 `NULL` 반환, 호출자는 검사.

```c
int *arr = malloc(n * sizeof *arr);
if (!arr) { /* 처리 */ }
// ...
free(arr);
arr = NULL; // 재사용 방지
```

---

## 6. 포인터와 배열 — 디케이(decay)와 예외

```c
int a[5];
int *p = a;           // a → &a[0] 로 디케이
sizeof(a);            // 5 * sizeof(int)  (예외: 디케이 안 함)
sizeof(p);            // 포인터 크기
&a;                   // 타입: int (*)[5]  (배열에 대한 포인터)
&a[0];                // 타입: int*
```

### 6.1 다차원 배열 인자
- `int m[R][C]`를 함수 인자로 받을 때: **안쪽 차원 크기(C) 필요**.

```c
void sum2d_fixed(int (*m)[3], int rows){
    int s=0;
    for(int r=0;r<rows;++r)
        for(int c=0;c<3;++c) s+=m[r][c];
    printf("%d\n", s);
}
```

- 혹은 **VLA 파라미터(C99)**:

```c
void sum2d_vla(int r, int c, int a[r][c]) {
    long s=0;
    for (int i=0;i<r;++i)
        for (int j=0;j<c;++j) s+=a[i][j];
    printf("%ld\n", s);
}
```

---

## 7. 구조체와 포인터 — `.` vs `->`, 오프셋/정렬

```c
typedef struct { int x; double y; } Node;
Node n = {1, 3.14};
Node *pn = &n;
printf("%d %.2f\n", pn->x, pn->y); // ->는 (*pn).x 의 축약
```

- 구조체 내 **패딩/정렬**을 이해하면 바이너리 I/O, 네트워크 패킹, 메모리 맵에 유리.

---

## 8. 문자와 문자열 포인터

- `char`는 **작은 정수형**. UTF-8 “문자 수”는 **바이트 수와 다를 수 있음**.
- 리터럴 수정 금지:

```c
const char *s = "ABC";
// s[0]='a'; // ❌ UB
```

- 가변 문자열: 배열로

```c
char buf[16] = "ABC";
buf[0]='a'; // OK
```

- 안전 연결:

```c
#include <string.h>
strncat(buf, "XYZ", sizeof buf - strlen(buf) - 1); // 남은 공간 고려
```

---

## 9. 함수 인자로 포인터 — in/out/ownership 계약

### 9.1 in-only (읽기 전용)

```c
double mean(const int *a, size_t n);
```

### 9.2 out-only (출력 인자)

```c
int get_range(const int *a, size_t n, int *min, int *max);
```

### 9.3 in-out (수정)

```c
void normalize(double *v, size_t n);
```

### 9.4 소유 이전(owning) / 생성자 패턴

```c
int make_array(size_t n, int **out) {
    int *p = malloc(n*sizeof *p);
    if (!p) return -1;
    *out = p;             // 소유권 전달
    return 0;
}
```

- **포인터에 포인터(이중 포인터)**는 “포인터 값 자체”를 바꾸고 싶을 때 사용.

---

## 10. 이중 포인터 — 재할당/리스트/테이블

```c
void setNull(int **pp) { *pp = NULL; }

int *p;           // 초기화 생략 예
setNull(&p);      // p가 NULL이 됨
```

### 10.1 `realloc` 패턴(실패 안전)

```c
int grow(int **buf, size_t *cap, size_t need) {
    if (need <= *cap) return 0;
    size_t ncap = (*cap? *cap:1);
    while (ncap < need) ncap *= 2;
    int *tmp = realloc(*buf, ncap*sizeof **buf);
    if (!tmp) return -1;
    *buf = tmp; *cap = ncap;
    return 0;
}
```

> 실패 시 원 포인터 유지 → **이중 포인터**가 유리.

---

## 11. 함수 포인터 — 전략/콜백/디스패치 테이블

### 11.1 문법과 시그니처 일치

```c
int add(int,int);
int (*fp)(int,int) = add;
printf("%d\n", fp(3,4));
```

### 11.2 디스패치 테이블

```c
#include <stdio.h>

typedef int (*op_t)(int,int);
static int add(int a,int b){return a+b;}
static int mul(int a,int b){return a*b;}
static int sub(int a,int b){return a-b;}

static op_t ops[] = { add, mul, sub };

int main(void){
    for (int i=0;i<3;++i) printf("%d ", ops[i](6,2)); // 8 12 4
    puts("");
    return 0;
}
```

### 11.3 `qsort`/`bsearch` 콜백

```c
#include <stdlib.h>

static int cmp_int(const void *a, const void *b){
    int x=*(const int*)a, y=*(const int*)b;
    return (x>y)-(x<y); // 음수/0/양수
}
```

---

## 12. `void*`와 캐스팅 — 제네릭 버퍼

- `void*`는 **임의의 객체**를 가리킬 수 있는 범용 포인터.
- 산술 불가(표준상) → 필요 시 적절한 타입으로 캐스팅.

```c
void *buf = malloc(1024);
unsigned char *p = buf;
p[0]=0xFF;
free(buf);
```

---

## 13. 엄격 별칭(strict aliasing)과 UB

- 대부분의 최적화 컴파일러는 **서로 다른 타입 포인터가 같은 저장소를 가리키지 않는다**고 가정(단, 예외: `char*`).
- 다른 타입으로 재해석 캐스팅 후 역참조는 UB 위험.

```c
float f = 1.0f;
// *(int*)&f; // ❌ 잠재적 UB
```

대안: **`memcpy`로 바이트 복사** 또는 **공용체의 합법적 사용 범위** 확인.

```c
int i;
memcpy(&i, &f, sizeof i); // 이동 의미론 (type-punning 대안)
```

---

## 14. 메모리 함수와 겹침

- `memcpy(dst,src,n)`: 겹침 **없을 때**.
- `memmove(dst,src,n)`: 겹침 **있어도** 안전.
- `memset(p,0,n)`: 0 초기화.

```c
char s[]="abcde";
memmove(s+1, s, 3); // s="aabcd"
```

---

## 15. 안전 입력/출력과 포인터

### 15.1 `%p`/정수 포인터 변환
- `%p`는 `void*` 전용.
- 정수 변환은 `uintptr_t`/`intptr_t` 사용.

```c
#include <inttypes.h>
printf("0x%" PRIxPTR "\n", (uintptr_t)p);
```

### 15.2 읽기 버퍼와 널 종료
- `fgets(buf, cap, stdin)` 후 개행 제거.
- 항상 **남은 공간 검사** 후 이어 붙이기.

---

## 16. 포인터와 수학: 인덱스 수식

row-major 2D: 열 수 `C`, 타입 크기 `S`일 때

$$
\text{addr}(i,j) = \text{base} + (i \cdot C + j)\cdot S
$$

포인터 차:

$$
(p+k) - p = k
$$

---

## 17. 동적 2D — 단일 블록 + 포인터 테이블

```c
int **make_2d(int r,int c){
    int **row = malloc((size_t)r * sizeof *row);
    int *blk   = malloc((size_t)r * c * sizeof *blk);
    if(!row || !blk){ free(row); free(blk); return NULL; }
    for(int i=0;i<r;++i) row[i] = blk + i*c;
    return row; // free(row[0]); free(row); 순서
}
```

장점: `row[i][j]` 문법 + 연속 메모리의 캐시/IO 이득.

---

## 18. 흔한 실수와 교정

### 18.1 일반 변수에 `NULL` 대입
```c
int x = NULL; // ❌ 의미 불일치: NULL은 포인터용
```
→ 정수는 **숫자**로 초기화.

### 18.2 임의 정수 → 포인터 대입
```c
int *p = (int*)1234; // ❌ UB 가능
```

### 18.3 해제 후 사용(UAF)
```c
free(p);
*p = 1;    // ❌
```
→ `p=NULL;`로 표식.

### 18.4 서로 다른 배열 포인터 뺄셈/비교
```c
int a[3], b[3];
// (a+1) - (b+2); // ❌
```

### 18.5 잘못된 캐스팅과 정렬 위반
- 임의 바이트 주소를 `int*`로 캐스팅 후 역참조 → 정렬 위반으로 UB.

---

## 19. 미니 프로젝트: 안전한 동적 벡터

요구:
- `push`/`get`/`free`, 자동 확장, 실패 안전, 소유 명확.

```c
#include <stdlib.h>
#include <string.h>

typedef struct { int *data; size_t len, cap; } ivec;

static int ivec_init(ivec *v){ v->data=NULL; v->len=v->cap=0; return 0; }

static int ivec_grow(ivec *v, size_t need){
    if (need <= v->cap) return 0;
    size_t ncap = v->cap? v->cap:1;
    while (ncap < need) ncap <<= 1;
    int *tmp = realloc(v->data, ncap*sizeof *tmp);
    if (!tmp) return -1;
    v->data=tmp; v->cap=ncap; return 0;
}

static int ivec_push(ivec *v, int x){
    if (ivec_grow(v, v->len+1)) return -1;
    v->data[v->len++] = x;
    return 0;
}

static int ivec_get(const ivec *v, size_t i, int *out){
    if (!v || i>=v->len || !out) return -1;
    *out = v->data[i]; return 0;
}

static void ivec_free(ivec *v){ free(v->data); v->data=NULL; v->len=v->cap=0; }
```

핵심 포인터 포인트:
- **이중 포인터 없이도** 구조체 내부 포인터를 캡슐화해 관리.
- `realloc` 실패 안전 처리.

---

## 20. 체크리스트(포인터 편)

- [ ] **수명**: 자동/정적/동적 구분, Dangling 방지.
- [ ] **소유**: 누가 `free`? 인터페이스 문서화.
- [ ] **NULL**: 실패 시 `NULL` 반환·검사.
- [ ] **경계**: 배열 범위, `end = begin + n`.
- [ ] **정렬**: 타입 정렬 보장된 주소만 역참조.
- [ ] **별칭**: 서로 다른 타입 포인터로 재해석 금지(엄격 별칭).
- [ ] **`const`/`restrict`/`volatile`**: 의도 표식으로 버그·성능 개선.
- [ ] **출력 형식**: `%p` + (void*), 포인터→정수는 `uintptr_t`.
- [ ] **함수 포인터**: 시그니처 정확히 일치, 테이블/콜백에서 typedef 사용.
- [ ] **해제 후 NULL**: UAF 예방.

---

## 21. 요약

| 주제 | 핵심 |
|---|---|
| 포인터 정의 | “주소를 담는 값”, `&`/`*` |
| 수명/소유 | 자동/정적/동적, 소유자 규약과 `free` 책임 |
| 산술/비교 | 같은 배열 범위 내에서만 정의적, `end = begin + n` |
| 배열/디케이 | `T[N]` → `T*` (예외: `sizeof`, `&array`) |
| 다차원 | `int (*p)[C]` 또는 VLA 파라미터 |
| `const`/`restrict`/`volatile` | 계약/최적화/하드웨어 동기화 |
| 문자열 | 리터럴은 **수정 금지**, 가변 문자열은 배열 |
| 이중 포인터 | 포인터 값 변경/재할당/소유 전달에 유용 |
| 함수 포인터 | 콜백·전략·디스패치 테이블 |
| 안전성 | NULL 체크, 정렬·별칭·UAF·경계·출력 형식 준수 |
