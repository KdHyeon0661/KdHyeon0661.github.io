---
layout: post
title: Spring - 운영 체크리스트 & 장애 대응
date: 2025-10-21 20:25:23 +0900
category: Spring
---
# 운영 체크리스트 & 장애 대응 — 스타트업 프로파일링, 장애 시나리오(스레드풀·DB 잠금·타임아웃), 롤백·핫픽스·피처 플래그

> 목표: **장애를 “발생 전에 줄이고, 발생 시 빨리 복구하고, 재발을 막는”** 운영 체계를 만든다.
> 범위: **부팅/메모리** 프로파일링과 최적화, **대표 장애 3종**(스레드풀 고갈, DB 잠금/데드락, 타임아웃) 탐지→대응→예방, **롤백/핫픽스/피처 플래그**로 안전 배포.
> 전제: Spring Boot 3.3+, Java 21, K8s/Helm, Prometheus/Grafana, 로깅(JSON+traceId), Micrometer/Actuator, Resilience4j.

---

## A. 스타트업(부팅) & 메모리 프로파일링

### A-1. “얼마나 느린가” 가시화 — Spring ApplicationStartup

```java
@SpringBootApplication
public class App {
  public static void main(String[] args) {
    SpringApplication app = new SpringApplication(App.class);
    app.setApplicationStartup(new BufferingApplicationStartup(2048)); // or FlightRecorderApplicationStartup
    app.run(args);
  }
}
```
`/actuator/startup` 노출:
```yaml
management.endpoints.web.exposure.include: health,info,metrics,startup
```
→ 부팅 단계별(ms) 지연 지점 파악(예: JPA 엔티티 스캔, Feign 클라이언트 초기화).

### A-2. JVM/JFR로 콜드 스타트 분석

- 실행 시: `-XX:StartFlightRecording=name=boot,filename=boot.jfr,dumponexit=true,settings=profile`
- 분석: JFR(VisualVM/Mission Control)로 **클래스 초기화, I/O, GC, 스레드 생성** 타임라인 확인.

### A-3. 톰캣/넷티 초기화 튜닝

- **톰캣 스레드** 미리 생성:
  `server.tomcat.threads.max=200` / `server.tomcat.threads.min-spare=20`
- **Netty DNS 캐시**(WebFlux):
  `-Dio.netty.resolver.dns.ttl=30 -Dio.netty.resolver.dns.negativeTtl=10`

### A-4. Spring 부팅 최적화 플래그

```yaml
spring.main.lazy-initialization=true       # 초기 트래픽 낮을 때만; 첫 요청 지연에 주의
spring.aop.auto=false                      # AOP 미사용 서비스
spring.mvc.format.date=iso                 # 컨버터 부하 ↓
```
- Dev/Stage에만 `lazy`를 켜고 Prod은 주로 **워밍업(프리로드)**으로 커버:
  - K8s `startupProbe` 넉넉히, Readiness true 전 **핫 경로 워밍업**(헬스 핑/캐시 프라임).

### A-5. Native Image(AOT) 옵션(선택)

- GraalVM **native-image**로 **초저지연 기동**(ms 단위).
- 단점: 힙/리플렉션 제약, 빌드/관측 난이도.
- 현실론: **관리/툴링이 성숙한 JVM + 워밍업**이 다수 서비스에선 더 경제적.

---

### A-6. 메모리(힙/네이티브) 프로파일링

#### 컨테이너 친화 JVM 옵션(기본)

```
-XX:+UseG1GC -XX:MaxRAMPercentage=70 -XX:InitialRAMPercentage=25
-XX:+AlwaysActAsServerClassMachine -XX:+UseStringDeduplication
-Dfile.encoding=UTF-8 -Duser.timezone=Asia/Seoul
```

#### 러닝 중 확인

```bash
jcmd <pid> VM.flags
jcmd <pid> GC.heap_info
jcmd <pid> GC.class_histogram
jcmd <pid> GC.heap_dump /tmp/heap.hprof
```
- **Native Memory Tracking(NMT)**: `-XX:NativeMemoryTracking=detail` + `jcmd <pid> VM.native_memory summary`

#### Micrometer JVM 메트릭

- `jvm.memory.used{area="heap"}`, `jvm.gc.pause`, `process.cpu.usage`
- OOM 직전 **Old Gen 상승 + GC pause 증가**를 알람(예: OldGen > 85% 지속 5m).

---

### A-7. 부팅/메모리 체크리스트

- [ ] `/actuator/startup`으로 **Top N 느린 단계** 기록.
- [ ] JFR로 **클래스 초기화/IO** 핫스팟 파악.
- [ ] 톰캣/Netty 스레드, DB 풀 **초기 사이즈** 적절히.
- [ ] **워밍업**(캐시/쿼리 프라임) 후 Readiness ON.
- [ ] JVM 힙 **MaxRAMPercentage 65~75%**, NMT 켬.
- [ ] **메모리 알람**: OldGen>85%, GC pause p99>200ms(10m).
- [ ] 힙 덤프 수집/보관 전략(민감정보 마스킹, 접근 통제).

---

## B. 장애 시나리오 #1 — 스레드풀 고갈(Thread Pool Exhaustion)

### B-1. 증상

- 응답 지연↑, 큐 대기, 5xx/타임아웃 급증.
- 로그: `RejectedExecutionException`, `Task was rejected from ...`, `http-nio` 요청 처리 지연.
- 스레드 덤프: **RUNNABLE 대량** 또는 **WAITING on pool queue**.

### B-2. 즉각 대응(런북)

1) **상태 파악**
```bash
kubectl top pod -n prod | grep api
kubectl logs deploy/api -n prod | tail -200
kubectl exec -it pod/api-xxx -- jcmd 1 Thread.print > /tmp/th.txt
```
2) **임시 완화**
- **HPA scale-out**(Pod 수 ↑).
- 게이트웨이/리버스 프록시에 **RPS 제한**(폭주 차단).
- 비핵심 엔드포인트 임시 **503**(피크 흡수).

3) **원인 제거**
- **블로킹 호출**(외부 API/FS/DB)을 **웹/넷티 스레드에서** 수행? → `@Async` + **전용 Executor**로 격리 또는 WebClient + 타임아웃.
- DB 풀보다 **웹 스레드**가 많음? → 톰캣 max-threads ↓ 또는 DB/Hikari maxPool ↑(균형).
- **무한 재시도**/리트라이 폭주? → 재시도 제한 + 지터.

### B-3. 구성 베스트 프랙티스

**톰캣(동기 MVC)**
```yaml
server:
  tomcat:
    threads:
      max: 200
      min-spare: 20
spring:
  task:
    execution:
      pool:
        core-size: 16
        max-size: 64
        queue-capacity: 1000
```

**공용 @Async 금지 → 업무별 풀 분리**
```java
@Configuration
class ExecutorsConfig {
  @Bean(name="ioPool")
  public Executor ioPool(){
    var ex = new ThreadPoolTaskExecutor();
    ex.setCorePoolSize(32); ex.setMaxPoolSize(64); ex.setQueueCapacity(500);
    ex.setThreadNamePrefix("io-"); ex.initialize(); return ex;
  }
}

@Service
class PdfService {
  @Async("ioPool")
  public CompletableFuture<Path> render(...) { ... } // 블로킹 I/O 격리
}
```

**WebFlux(Netty)**
- CPU 바운드: 이벤트 루프 / 사용자 연산 분리(`publishOn(Schedulers.boundedElastic())` 최소화).
- 블로킹 라이브러리 호출 금지(불가피하면 **boundedElastic** 또는 **전용 스레드풀**).

**관측/알람**
- `tomcat.threads.current`, `tomcat.threads.busy / max`
- `executor.completed + queue.size`(커스텀 메트릭)
- 임계: busy/max > 0.8 1m 지속 알람.

---

## C. 장애 시나리오 #2 — DB 잠금/데드락/슬로우 쿼리

### C-1. 증상

- API p95↑, DB 커넥션 대기, 타임아웃.
- 로그: `Lock wait timeout exceeded`, `Deadlock found`, `Connection is not available, request timed out`.
- DB 메트릭: **활성 세션↑**, **락 대기↑**, **슬로우 쿼리** 증가.

### C-2. 즉각 대응(런북)

1) **DB 상태 확인**
- RDB 콘솔에서 잠금/슬로우 쿼리 확인:
  - MySQL: `SHOW ENGINE INNODB STATUS;`, `performance_schema.events_statements_current`
  - Postgres: `pg_stat_activity` / `pg_locks`, `pg_stat_statements`

예) Postgres
```sql
SELECT pid, state, wait_event_type, wait_event, query
FROM pg_stat_activity WHERE datname='prod' ORDER BY state, query_start;
SELECT * FROM pg_locks WHERE NOT granted;
```

2) **서비스 측 조치**
- **문제 트랜잭션 kill**(DBA 승인), **쓰기 트래픽 차단**(게이트웨이 503)
- **배치/리포트 쿼리 중지**(스케줄러 OFF)
- **스케일아웃**으로 동시성 분산(락 대기 완화)

3) **원인 수습**
- **갭락/순서 역전** → **일관된 update 순서**(예: 작은 PK → 큰 PK)
- **대량 업데이트** → **배치 크기↓**, **staging 테이블**로 분리
- **누락 인덱스** → 실행계획/카디널리티 점검, 인덱스 추가
- **긴 트랜잭션** → 트랜잭션 경계 축소(읽기-쓰기 분리)

### C-3. 예방 설정

**Hikari / JPA**
```yaml
spring.datasource.hikari:
  maximum-pool-size: 40
  minimum-idle: 8
  connection-timeout: 2000   # ms
  validation-timeout: 1000
spring.jpa:
  properties.hibernate.jdbc.batch_size: 100     # 대량 쓰기 최적화
  properties.hibernate.order_inserts: true
  properties.hibernate.order_updates: true
```

**트랜잭션 타임아웃**
```java
@Transactional(timeout = 3) // 초; 유스케이스별 타임아웃
public void placeOrder(...) { ... }
```

**읽기 전용**
```java
@Transactional(readOnly = true) // 스냅샷/락 부담↓
public OrderView get(...) { ... }
```

**슬로우 쿼리 로깅**
- MySQL: `long_query_time=0.5`
- PG: `log_min_duration_statement=500ms`
- 애플리케이션: `logging.level.org.hibernate.SQL=debug`(운영에선 샘플링/마스킹!)

**쿼리 캡**
- 비용 큰 API에 **쿼리 한도/페이지 최대 크기 200**
- `SELECT ... LIMIT 1000` 가드, 전체 스캔 금지 규칙.

---

## D. 장애 시나리오 #3 — 타임아웃/연쇄 장애(Cascading Failure)

### D-1. 증상

- 외부 API 5xx/지연 → 우리 서비스 큐 적체 → 재시도 폭주 → **전체 장애**.
- 로그: `ReadTimeout`, `connect timed out`, `CircuitBreaker OPEN`.

### D-2. 즉각 대응

- **서킷 오픈**(강제) 또는 **기능 토글**로 문제 경로 차단(부분 기능 degrade 제공).
- 게이트웨이에서 **레이트 리밋** 낮추기, **RPS 컷**.
- **캐시된 응답/대체 값**(fallback) 사용.

### D-3. 설계 예방 — 타임아웃/리트라이/서킷/벌크헤드

**클라이언트 공통(Resilience4j)**
```yaml
resilience4j:
  circuitbreaker:
    instances:
      partner:
        sliding-window-size: 50
        failure-rate-threshold: 50
        wait-duration-in-open-state: 10s
  retry:
    instances:
      partner:
        max-attempts: 3
        wait-duration: 200ms
        retry-exceptions: [ java.io.IOException, java.util.concurrent.TimeoutException ]
  timelimiter:
    instances.partner.timeout-duration: 2s
  bulkhead:
    instances.partner.max-concurrent-calls: 50
  ratelimiter:
    instances.partner.limit-for-period: 100
    instances.partner.limit-refresh-period: 1s
```

**코드 예**
```java
@CircuitBreaker(name="partner", fallbackMethod="fallback")
@Retry(name="partner")
@TimeLimiter(name="partner")
@Bulkhead(name="partner")
public CompletableFuture<Item> getItem(String id){
  return CompletableFuture.supplyAsync(() ->
    rest.get().uri("/v1/items/{id}", id).retrieve().body(Item.class));
}
private CompletableFuture<Item> fallback(String id, Throwable ex){
  return CompletableFuture.completedFuture(Item.placeholder(id)); // grace degrade
}
```

**서버 타임아웃/헤더**
```yaml
server.tomcat.connection-timeout: 5s
spring.mvc.async.request-timeout: 3s
```

**게이트웨이**
```yaml
spring.cloud.gateway:
  default-filters:
    - RequestRateLimiter={"redis-rate-limiter.replenishRate": 300, "burstCapacity": 600, "key-resolver":"#{@apiKeyResolver}"}
  httpclient:
    connect-timeout: 2000
    response-timeout: 3000
```

**관측**
- 알람: `circuitbreaker.state{OPEN}`, `http.client.requests{outcome="SERVER_ERROR"}` 상승
- SLO: 외부 API 의존 경로 **에러율/지연** 분리 대시보드.

---

## E. 롤백·핫픽스·피처 플래그 — 안전 배포 런북

### E-1. 롤백 전략

**1) 어플리케이션 롤백**
- K8s: `kubectl rollout undo deploy/api -n prod`
- Helm: `helm rollback acme-api <REVISION>`

**2) Blue/Green**
- 두 버전 동시 상주, Ingress/Service 스위치.
- 실패 시 **즉시 Blue로 복귀**(DNS/라우팅 전환만).

**3) Canary**
- 트래픽 5%→25%→50%→100% 증분. **메트릭 게이트**(에러율, p95)를 넘으면 자동 롤백(Argo Rollouts/Istio).

**운영 핵심**
- **DB 마이그레이션은 Expand → Contract**(뒤 호환 스키마):
  1. 추가(컬럼/인덱스) → 새 코드 배포(둘 다 읽기) → 오래된 필드 제거.

### E-2. 핫픽스(Hotfix) 플로우

1) **prod에서 재현/원인 파악**(던프/로그/JFR 확보).
2) `hotfix/####` 브랜치 생성 → 테스트/스캔 통과.
3) **Stage canary** 10% 15분 → **Prod canary** 5% 15분 → **승급**.
4) 릴리스 태그/체인지로그 기록, **Postmortem 48시간 내 작성**.

**GitHub Actions 예(수동 프로모션)**
```yaml
on: workflow_dispatch
jobs:
  promote:
    steps:
      - run: ./scripts/promote.sh sha-abc123 prod  # values.yaml 교체 PR
```

### E-3. 피처 플래그(토글) — 즉시 차단/해제

**Config 기반(간단)**
```yaml
features:
  new-checkout: false
```
```java
@RefreshScope
@ConfigurationProperties(prefix="features")
public record Features(boolean newCheckout) {}
```
→ 장애 시 **ConfigRepo 수정 + BusRefresh**만으로 기능 **OFF**.

**토글 엔진(강화: 퍼센트 롤아웃)**
- Togglz/Unleash: 사용자/테넌트/퍼센트 기반 활성화, 실험 안전화.
- 운영 보호: **Fail-closed**(토글 서버 불능 시 안전 기본값 선택).

### E-4. Fast Rollback Playbook(요약)

- [ ] 장애 감지(알람) → **배포 중단**(Sync Window close)
- [ ] **토글 OFF**(해당 기능), **서킷 오픈**(외부 의존)
- [ ] 최근 배포 30분 이내? **롤백 우선**(Blue/Green revert or `rollout undo`)
- [ ] 증상 완화 후 **루트 원인 분석** → 핫픽스 경로
- [ ] **포스트모템**: 탐지/완화/복구/예방 항목 & 타임라인

---

## F. 관측/알람 패키지(샘플 쿼리 & 경계값)

### F-1. API SLO

- **에러율**: `sum(rate(http_server_requests_seconds_count{status=~"5.."}[5m])) / sum(rate(http_server_requests_seconds_count[5m])) > 0.01` (1%) 10m
- **지연 p95**: `histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket[5m])) by (le, uri))` 임계 초과 10m

### F-2. 풀/스레드/DB

- `hikaricp_connections_active / hikaricp_connections_max > 0.9` 5m
- `tomcat_threads_busy / tomcat_threads_config_max > 0.8` 5m
- `jvm_memory_used_bytes{area="heap"} / jvm_memory_max_bytes > 0.85` 10m

### F-3. 외부 호출

- `http_client_requests_seconds_count{outcome="SERVER_ERROR"}` 증가율 알람
- `resilience4j_circuitbreaker_state{name="partner"}==OPEN` 1m

---

## G. 장애 복기(Postmortem) 포맷(요약 템플릿)

1) **요약**: 언제, 영향 범위, 다운타임, 고객 영향
2) **타임라인**: 감지→진단→완화→복구
3) **루트 원인**: 기술적/조직적(체크리스트 누락?)
4) **잘한 점/개선점**
5) **액션 아이템**(D.R.I/마감일)
6) **재현/검증 계획**(테스트/카오스 시나리오 추가)

---

## H. 카오스 엔지니어링(경량)

- **스레드풀 포화**: 부하 테스트 중 톰캣 busy 90%로 만들고 **레이트리밋/서킷**이 동작하는지 확인.
- **DB 락**: 테스트 DB에 의도적 대량 업데이트 + 읽기 동시; 트랜잭션 타임아웃/슬로우 쿼리 알람 검증.
- **네트워크 지연/패킷 손실**: tc/netem로 200ms 지연, 2% loss → 리트라이 지터/타임리밋 검증.

---

## I. 실전 스니펫 모음

### I-1. 스레드 덤프 수집(사이드카 핸들러)

```bash
#!/usr/bin/env bash

PID=$(jcmd | awk '/org.springframework.boot/{print $1}')
jcmd $PID Thread.print > /tmp/tdump-$(date +%s).log
```

### I-2. 장애시 임시 ReadOnly 모드(게이트웨이 필터)

```java
@Component
public class EmergencyReadOnlyFilter implements GlobalFilter, Ordered {
  private volatile boolean readonly = false;
  @Override
  public Mono<Void> filter(ServerWebExchange ex, GatewayFilterChain chain) {
    if (readonly && ex.getRequest().getMethod().matches("POST|PUT|PATCH|DELETE")) {
      ex.getResponse().setStatusCode(HttpStatus.SERVICE_UNAVAILABLE);
      return ex.getResponse().setComplete();
    }
    return chain.filter(ex);
  }
  @Override public int getOrder() { return -100; }
}
```

### I-3. 기능 토글 중앙 핸들러(404/410로 가려내기)

```java
@RestControllerAdvice
class FeatureGuard {
  @Value("${features.checkout-v2:false}") boolean newCheckout;
  @ExceptionHandler(FeatureDisabled.class)
  ResponseEntity<ApiResponse<Void>> off() {
    return ResponseEntity.status(410).body(ApiResponse.fail(
      new ApiError("4100", 410, "기능 일시 중지", "feature.off", trace.currentTraceId(), Map.of())));
  }
  static void ensure(boolean flag){ if(!flag) throw new FeatureDisabled(); }
}
```
사용:
```java
FeatureGuard.ensure(features.newCheckout());
```

---

## J. 운영 체크리스트(요약)

**프로파일링**
- [ ] `/actuator/startup` / JFR 확보
- [ ] JVM/GC 옵션, 힙/OldGen 알람
- [ ] 부팅 워밍업 & Readiness 제어

**스레드풀**
- [ ] 업무별 **풀 분리**, 큐 한도/거부정책
- [ ] 톰캣/Netty vs Hikari **균형**
- [ ] 풀/큐 메트릭 알람

**DB**
- [ ] 트랜잭션 타임아웃, 읽기전용, 배치 사이즈
- [ ] 슬로우 쿼리, 인덱스, 실행계획 리뷰
- [ ] 데드락/락 모니터링 쿼리

**타임아웃/회복탄력성**
- [ ] 클라이언트 **connect/read timeout**
- [ ] **리트라이 제한 + 지터**, **서킷** 기준치
- [ ] **벌크헤드/레이트리밋**

**배포/롤백**
- [ ] Blue/Green/Canary + **자동 롤백 게이트**
- [ ] Config/Togglz **피처 플래그**
- [ ] 핫픽스 전용 파이프라인

**관측/로그**
- [ ] traceId 패스스루, JSON 로그
- [ ] SLO 대시보드(에러율/지연/리소스)
- [ ] 런북/포스트모템 템플릿

---

## K. 한 페이지 요약

- **부팅/메모리**는 계측 없이는 개선 불가: `/actuator/startup`·JFR·GC 메트릭으로 **느린 지점**을 잡아라.
- 장애의 80%는 **스레드풀/DB/타임아웃**: 풀을 분리하고, 트랜잭션을 줄이고, **타임아웃/서킷/레이트리밋**을 기본값으로 둬라.
- 배포는 늘 **되돌릴 수 있어야** 한다: **롤백**은 즉시, **핫픽스**는 짧게, **피처 플래그**로 위험한 기능을 단추 하나로 끊어라.
- 알람은 **증상이 아니라 고객 영향**(에러율/지연/SLO)을 기준으로, 포스트모템은 **비난 없이 학습**을 남겨라.
