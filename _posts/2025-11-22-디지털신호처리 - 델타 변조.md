---
layout: post
title: 디지털신호처리 - 델타 변조
date: 2025-11-22 19:25:23 +0900
category: 디지털신호처리
---
# — 1비트 미분 부호화의 원리, 한계, 적응형 구조, 그리고 GNU Octave 실험

이 글은 펄스 부호 변조(PCM)·차분 PCM(DPCM) 계열의 가장 단순한 형태인 **델타 변조(DM)** 를 다룬다. DM은 “입력의 **변화 방향(증가/감소)** 만 1비트로 보내고, 수신측에서 누적 적분으로 파형을 복원”하는 방식이다. 구조가 극단적으로 단순한 대신, **과립 잡음(granular noise)** 과 **경사 과부하(slope overload)** 라는 고유한 한계가 있다. 또한 DM의 개선형인 **적응 델타 변조(ADM, CVSD)**, 그리고 현대 ADC의 핵심인 **ΣΔ(시그마-델타) 변조**로 이어지는 흐름의 출발점이기도 하다.

---

## 예비사항: DM의 위치와 기본 아이디어

### PCM → DPCM → DM

- **PCM**: 입력 \(x(t)\)를 샘플링 후 각 샘플을 \(B\)비트로 양자화.
- **DPCM**: 샘플 자체 대신 “예측값과의 차이(오차)” \(e[n] = x[n]-\hat{x}[n]\) 를 양자화.
- **DM**: DPCM에서 **오차 양자화기를 1비트(2레벨)로 극단화**한 것. 즉 오차의 **부호(sign)** 만 보냄.

DM은 다음 질문에 대한 가장 단순한 답이다.

> “샘플 간 변화가 작다면, **‘어느 쪽으로 움직였는지’** 만 알려줘도 파형을 따라갈 수 있지 않을까?”

이 “변화 방향만 보내고 누적”하는 철학은 뒤에서 보듯이 ΣΔ 변조의 핵심 노이즈 셰이핑으로 확장된다.

### DM의 전형적 블록도

텍스트 블록도로 나타내면:

```text
송신기(Encoder)

x[n] ──▶(+)──▶ e[n] ─▶ sign(·) ─▶ b[n] (1비트)
        ▲
        │
      y[n-1]
      (수신기와 같은 누산기 출력의 1샘플 지연)

수신기(Decoder)

b[n] ─▶(±Δ) ─▶ 누산기(적분기) ─▶ y[n]
```

- 송신기에서 **현재 입력** \(x[n]\) 과 **이전 복원값** \(y[n-1]\) 의 차이를 구해
  \(e[n]=x[n]-y[n-1]\) 를 만든다.
- \(e[n]\) 의 부호만 전송 비트 \(b[n]\in\{+1,-1\}\) 로 보낸다.
- 수신기에서는 비트에 따라 **고정 스텝 \(\Delta\)** 만큼 위/아래로 움직이며
  \(y[n]\) 을 누적 적분(누산)으로 만든다.

---

## 델타 변조의 수학적 모델

### 오차 신호와 1비트 양자화

가장 표준적인 DM 정의는 다음과 같다.

1) 오차(차분) 계산:
$$
e[n]=x[n]-y[n-1]
$$

2) 1비트 부호 양자화:
$$
b[n]=\operatorname{sign}(e[n])=
\begin{cases}
+1,& e[n]\ge 0\\
-1,& e[n]<0
\end{cases}
$$

3) 복원(누산):
$$
y[n]=y[n-1]+\Delta\,b[n]
$$

여기서 \(\Delta>0\)는 고정 스텝 크기(step size)다. 이 3식이 DM의 “전부”라고 해도 과언이 아니다.

### “계단 함수로 입력을 근사한다”는 관점

위 식을 보면 \(y[n]\) 은 매 샘플마다 \(\pm\Delta\) 만큼만 변할 수 있다. 즉

- \(y[n]\) 은 **계단형(staircase)** 파형
- \(x[n]\) 을 그 계단으로 “쫓아가는(tracking)” 구조

그러므로 DM의 성능은

- 샘플링이 충분히 빠르고(오버샘플링),
- \(\Delta\) 가 입력 변화에 적절하면

좋아지고, 둘 중 하나라도 안 맞으면 한계가 드러난다.

### 비트율과 샘플링율

DM은 **샘플당 1비트**이므로, 비트율은 샘플링율에 비례한다.

$$
R_b = f_s\quad(\text{1 bit/sample})
$$

따라서 **비트율을 늘리는 유일한 방법은 샘플링을 더 빠르게 하는 것**이다.
DM이 “저비트율 코덱”이라고 불리지만, 실제로는 **고 오버샘플링을 쓰는 1비트 코덱**이다.

---

## DM의 핵심 한계 1: 과립 잡음(Granular Noise)

### 과립 잡음이란?

입력이 거의 변화하지 않거나 아주 천천히 변할 때, DM의 출력은

- 한 샘플은 위로,
- 다음 샘플은 아래로,

**지그재그로 흔들리며 평균적으로 입력 근처를 맴도는** 형태가 된다.

이 진동이 바로 **granular noise**다.

직관:

> 입력이 “거의 평평한데도” 출력은 \(\pm\Delta\) 로만 움직일 수 있으니
> 결국 **계단이 너무 거칠어서 생기는 미세 진동**이다.

### 단순 모델에서의 과립 잡음 전력

입력이 매우 천천히 변한다고 가정하면, 출력은 대략 입력 주변에서 \(\pm\Delta/2\) 범위로 진동한다.
이를 균일 잡음으로 근사하면

$$
e_q[n]=y[n]-x[n]\sim\mathcal{U}\!\left(-\frac{\Delta}{2},\frac{\Delta}{2}\right)
$$

따라서

$$
\sigma_{g}^{2}=\mathrm{Var}(e_q)\approx\frac{\Delta^2}{12}.
$$

이 근사는 “과립 영역”에서의 직관적 SNR 계산에 자주 쓰인다.

### 과립 잡음을 줄이려면?

가장 직접적인 방법은

- **\(\Delta\) 를 줄인다**

하지만 \(\Delta\) 를 너무 줄이면 다음 절의 **경사 과부하**가 심해진다.
즉 DM은 **\(\Delta\) 하나로 두 문제 사이를 트레이드오프** 한다.

---

## DM의 핵심 한계 2: 경사 과부하(Slope Overload)

### 경사 과부하란?

입력이 빠르게 변할 때, DM 출력은 샘플당 최대 \(\Delta\) 만큼만 변할 수 있는데
입력의 기울기가 이것보다 크면 출력이 따라가지 못한다.

이 때 나타나는 큰 추적 오차가 **slope overload**다.

### 경사 과부하의 수학적 조건

연속시간 입력 \(x(t)\) 를 샘플링한다고 할 때,

- 샘플 간 시간: \(T_s = 1/f_s\)
- DM 출력이 한 샘플 동안 움직일 수 있는 최대 변화량: \(\Delta\)

따라서 **추적 가능한 최대 기울기**는

$$
\left|\frac{dx(t)}{dt}\right|_{\max} \le \frac{\Delta}{T_s}=\Delta f_s.
$$

즉,

$$
\boxed{\Delta f_s \;\ge\; \max_t |x'(t)|}
$$

가 slope overload를 피하는 기본 조건이다.

### 사인 입력에서의 구체화

사인파

$$
x(t)=A\sin(2\pi f t)
$$

이면

$$
x'(t)=2\pi f A\cos(2\pi f t)
$$

따라서

$$
\max |x'(t)|=2\pi f A.
$$

경사 과부하 조건은

$$
\boxed{\Delta f_s \ge 2\pi f A}
$$

로 정리된다.

**해석**

- 주파수 \(f\) 가 높을수록,
- 진폭 \(A\) 가 클수록,

더 큰 \(\Delta\) 또는 더 높은 \(f_s\) 가 필요하다.

즉 DM은 **고주파 성분이 있는 신호에서 원천적으로 불리**하다.

---

## DM 설계 트레이드오프: \(\Delta\) 와 \(f_s\)

### 두 한계의 방향이 반대

| 문제 | 원인 | 줄이는 방법 |
|---|---|---|
| 과립 잡음 | \(\Delta\) 가 너무 커서 입력을 거칠게 근사 | \(\Delta\) ↓ |
| 경사 과부하 | \(\Delta f_s\) 가 입력 기울기에 비해 작음 | \(\Delta\) ↑ 또는 \(f_s\) ↑ |

**즉, \(\Delta\) 를 줄이면 과립 잡음은 좋아지지만 경사 과부하는 악화되고,
\(\Delta\) 를 키우면 그 반대가 된다.**

### 오버샘플링의 역할

\(f_s\) 를 높이면

- 경사 과부하 조건이 완화되고
- 같은 \(\Delta\) 에서 더 섬세하게 계단이 움직인다.

그래서 DM은 대부분 **Nyquist보다 훨씬 높은 오버샘플링**을 전제로 한다.
(이 철학이 그대로 ΣΔ ADC로 이어진다.)

### 실무적 튜닝 감각

- **음성/오디오 저대역**: \(f_s\) 를 크게 잡고 \(\Delta\) 를 작게 → 과립 잡음 억제
- **변화가 큰 신호(자극적 트랜지언트)**: \(\Delta\) 를 키우거나 적응형으로.

그러나 \(\Delta\) 와 \(f_s\) 를 정적으로 고정하면 최적 타협점이 매우 좁다.
이 문제를 해결하기 위해 **적응 델타 변조**가 나왔다.

---

## 적응 델타 변조(ADM)와 CVSD

### 왜 적응이 필요한가?

DM은 입력이

- 아주 조용할 때(낮은 기울기)
- 갑자기 커질 때(높은 기울기)

두 상황을 **동시에 잘 커버할 수 없다**는 점이 치명적이다.

그래서 “입력 변화가 빠르면 \(\Delta\) 를 키우고, 느리면 줄이는”
**가변 스텝 DM**이 등장한다.

### CVSD(Continuously Variable Slope Delta Modulation)

CVSD의 핵심은:

- 최근 비트가 같은 방향으로 계속 나오면
  → 입력이 빠르게 변한다고 보고 \(\Delta\) 를 **증가**
- 비트가 자주 교대하면
  → 입력이 평탄하다고 보고 \(\Delta\) 를 **감소**

MathWorks 요약: CVSD는 LDM(고정 스텝 DM)에 “적응 스텝”을 더해
고주파에서 slope overload를 줄이면서 저주파에서는 과립 잡음도 줄인다.

또한 CVSD는 계산량·메모리가 작고 1비트/샘플 구조여서
저비트율 음성 통신에 널리 쓰였고, 미국 군 표준(예: MIL-STD-188-113의 16/32 kbps, Federal Standard 1023의 12 kbps)에서도 사용되었다.

### 간단한 CVSD 적응 법칙(예시)

많은 변형이 있지만, 직관적 예시를 들면:

1) 기본 스텝 \(\Delta_0\), 적응 계수 \(\alpha>1\)
2) 최근 \(L\)개 비트의 “연속 동일 방향 길이(run length)”를 본다.

- run length가 크면 \(\Delta \leftarrow \alpha \Delta\)
- run length가 작으면 \(\Delta \leftarrow \Delta/\alpha\)

실제 CVSD는 syllabic filter(시간 상수 필터)와 slope overload detector를 함께 쓴다.

---

## DM ↔ ΣΔ(시그마-델타) 변조의 연결

DM은

- 오차를 1비트로 양자화하고
- 누산으로 복원

하는 구조다. 여기에 **오차를 누적(Σ)한 뒤 양자화하고, 피드백(Δ)으로 되돌리는** 형태로 확장하면 ΣΔ 변조가 된다.

Virginia Tech의 ΣΔ 변조기 개요에서 “DM의 단점(과립 잡음·경사 과부하·DC 추적 문제)을 오버샘플링 + 적분 루프 구조로 개선한 것이 ΣΔ”라는 흐름이 정리되어 있다.

DM을 이해하면 ΣΔ의 노이즈 셰이핑 철학이 자연스럽게 보인다.

---

## GNU Octave로 DM 실험하기

아래 코드는 **GNU Octave**에서 바로 실행 가능한 형태로 작성했다.
(신호처리 패키지 필요: `pkg load signal`)

### 고정 스텝 DM 인코더/디코더

```octave
function b = dm_encode(x, Delta)
  % x: 입력 샘플 벡터
  % Delta: 고정 스텝
  N = length(x);
  b = zeros(1, N);
  y_prev = 0;

  for n = 1:N
    e = x(n) - y_prev;
    if e >= 0
      b(n) = 1;
    else
      b(n) = -1;
    end
    y_prev = y_prev + Delta * b(n);
  end
end

function y = dm_decode(b, Delta)
  N = length(b);
  y = zeros(1, N);
  y_prev = 0;

  for n = 1:N
    y_prev = y_prev + Delta * b(n);
    y(n) = y_prev;
  end
end
```

### 실험 1: 사인파 추적(과립 vs 경사 과부하)

```octave
clear; close all; clc; pkg load signal

Fs = 48000;           % 샘플링율
T  = 0.02;            % 20 ms
n  = 0:round(Fs*T)-1;
t  = n/Fs;

f1 = 500;  A1 = 0.8;
f2 = 4000; A2 = 0.8;

x1 = A1*sin(2*pi*f1*t);   % 저주파 사인
x2 = A2*sin(2*pi*f2*t);   % 고주파 사인

Delta_small = 0.01;
Delta_large = 0.05;

% case A: 저주파 + 작은 Delta (과립은 작고 추적 OK)
b1s = dm_encode(x1, Delta_small);
y1s = dm_decode(b1s, Delta_small);

% case B: 고주파 + 작은 Delta (경사 과부하 발생)
b2s = dm_encode(x2, Delta_small);
y2s = dm_decode(b2s, Delta_small);

% case C: 고주파 + 큰 Delta (경사 과부하 완화, 과립 증가)
b2l = dm_encode(x2, Delta_large);
y2l = dm_decode(b2l, Delta_large);

subplot(3,1,1);
plot(t, x1, 'b', t, y1s, 'r'); grid on;
title('저주파 500 Hz, Delta=0.01 (추적 양호)');
legend('x1','y1s');

subplot(3,1,2);
plot(t, x2, 'b', t, y2s, 'r'); grid on;
title('고주파 4 kHz, Delta=0.01 (경사 과부하)');
legend('x2','y2s');

subplot(3,1,3);
plot(t, x2, 'b', t, y2l, 'r'); grid on;
title('고주파 4 kHz, Delta=0.05 (경사 완화, 과립 증가)');
legend('x2','y2l');
```

**관찰 포인트**

- (2)에서 출력이 입력 기울기를 못 따라가 “평평하게 깎이는” 구간이 보일 것.
- (3)에서 추적은 개선되지만 평탄 구간에서 계단 진동이 더 커짐.

이는 §2–§3에서 정리한 트레이드오프를 그대로 재현한다.

### 실험 2: 기울기 과부하 조건 직접 확인

사인 \(x(t)=A\sin(2\pi f t)\) 에 대해

$$
\Delta f_s \ge 2\pi f A
$$

조건을 실험으로 체크한다.

```octave
clear; clc

Fs = 48000;
A  = 0.8;
f  = 4000;               % 4 kHz
Delta = 0.01;

lhs = Delta*Fs;
rhs = 2*pi*f*A;

fprintf("Delta*Fs = %.2f,  2*pi*f*A = %.2f\n", lhs, rhs);
if lhs >= rhs
  disp("-> slope overload 이론상 없음");
else
  disp("-> slope overload 이론상 발생");
end
```

- 출력 메시지가 “발생”이라면 §7.2 (2)와 같은 현상이 나타나는 게 정상이다.

### 데모

“최근 비트가 같은 방향으로 3번 이상 연속되면 \(\Delta\) 를 키우고,
그렇지 않으면 줄이는” 아주 단순한 가변 스텝 예제다.

```octave
function [b, Delta_hist] = cvsd_encode(x, Delta0, alpha, run_th)
  N = length(x);
  b = zeros(1, N);
  Delta_hist = zeros(1, N);

  y_prev = 0;
  Delta = Delta0;

  run = 0;      % 연속 동일 부호 길이
  prev_bit = 0;

  for n = 1:N
    e = x(n) - y_prev;
    bit = (e >= 0) * 2 - 1;   % +1 or -1

    % run length 업데이트
    if bit == prev_bit
      run = run + 1;
    else
      run = 1;
    end
    prev_bit = bit;

    % Delta 적응
    if run >= run_th
      Delta = Delta * alpha;       % 빠른 변화 -> 스텝 증가
    else
      Delta = Delta / alpha;       % 평탄 -> 스텝 감소
    end

    b(n) = bit;
    y_prev = y_prev + Delta * bit;
    Delta_hist(n) = Delta;
  end
end

function y = cvsd_decode(b, Delta_hist)
  N = length(b);
  y = zeros(1, N);
  y_prev = 0;
  for n = 1:N
    y_prev = y_prev + Delta_hist(n) * b(n);
    y(n) = y_prev;
  end
end
```

적응 DM과 고정 DM 비교:

```octave
clear; close all; clc; pkg load signal
Fs = 48000; T=0.03; n=0:round(Fs*T)-1; t=n/Fs;

x = 0.8*sin(2*pi*4000*t);  % 고주파 톤

Delta0=0.01; alpha=1.2; run_th=3;

% 고정 DM
b_fix = dm_encode(x, Delta0);
y_fix = dm_decode(b_fix, Delta0);

% CVSD(단순 적응)
[b_adp, Dh] = cvsd_encode(x, Delta0, alpha, run_th);
y_adp = cvsd_decode(b_adp, Dh);

subplot(2,1,1);
plot(t, x, 'b', t, y_fix, 'r'); grid on;
title('고정 Delta DM');
legend('x','y\_fix');

subplot(2,1,2);
plot(t, x, 'b', t, y_adp, 'r'); grid on;
title('단순 CVSD(적응 Delta)');
legend('x','y\_adp');
```

**기대 결과**

- 고정 DM 대비 적응 DM이 고주파 구간에서 추적이 좋아지는 것을 확인할 수 있다.
- 대신 \(\Delta\) 가 움직이므로 저주파/평탄 구간에서는 과립 잡음이 더 줄어든다.
  (이게 CVSD의 핵심 장점이다.)

---

## DM의 실무적 쓰임과 평가

### 어디에 쓰나?

DM은 현재 “주류 오디오/멀티미디어 코덱”에서는 거의 쓰이지 않는다.
하지만 다음과 같은 제약적 환경에서는 여전히 가치가 있다.

- **아주 단순한 하드웨어로 저비트율 음성을 보내야 하는 경우**
  (CVSD가 군·상용 저비트율 음성 시스템에서 사용된 배경)
- **전력/면적이 극도로 제한된 센서·텔레메트리**
- **ΣΔ ADC의 교육/이해를 위한 가장 단순한 1비트 루프 모델**

### 평가 지표

DM 품질 평가는 보통

1. **MSE/RMSE**
2. **SNR**
3. **스펙트럼 왜곡(고주파 스퓨리어스)**
4. **slope overload 발생률**

로 본다.

예시 SNR 측정 코드:

```octave
Ps = mean(x.^2);
Pe_fix = mean((x - y_fix).^2);
Pe_adp = mean((x - y_adp).^2);

SNR_fix = 10*log10(Ps/Pe_fix);
SNR_adp = 10*log10(Ps/Pe_adp);

fprintf("SNR fixed DM = %.2f dB\n", SNR_fix);
fprintf("SNR adaptive DM = %.2f dB\n", SNR_adp);
```

---

## 흔한 구현 실수와 주의점

1. **포화(saturation) 처리**
   실제 시스템은 출력 \(y[n]\) 이 허용 범위를 넘지 않도록 포화/클리핑을 둔다.
   포화를 안 두면 오버플로우로 시스템이 붕괴한다.

2. **초기값 \(y[-1]\)**
   보통 0 또는 입력의 첫 샘플로 둔다.
   초기값이 나쁘면 시작 구간에 큰 추적 오차가 생긴다.

3. **적응 DM에서의 불안정**
   \(\Delta\) 를 너무 빠르게 키우면 “과립 잡음이 오히려 폭증”할 수 있다.
   실무 CVSD가 syllabic filter/검출기를 넣는 이유다.

---

## 연습문제 (예제와 풀이)

### slope overload 조건 계산

입력 \(x(t)=0.9\sin(2\pi\cdot 3\,\mathrm{kHz}\cdot t)\),
DM 스텝 \(\Delta=0.01\), 샘플링율 \(f_s=48\,\mathrm{kHz}\) 일 때
slope overload가 발생하는지 판단하라.

**풀이**

사인 조건:
$$
\Delta f_s \ge 2\pi f A
$$

좌변:
$$
\Delta f_s = 0.01 \times 48000 = 480
$$

우변:
$$
2\pi f A = 2\pi \times 3000 \times 0.9 \approx 16964
$$

따라서
$$
480 \ll 16964
$$

→ slope overload **발생**.

Octave 검증:

```octave
Delta=0.01; Fs=48000; f=3000; A=0.9;
lhs=Delta*Fs; rhs=2*pi*f*A;
printf("lhs=%.1f, rhs=%.1f -> overload=%d\n", lhs, rhs, lhs<rhs);
```

---

### 과립 잡음 MSE 근사

입력이 충분히 천천히 변해 과립 영역이라고 하자.
\(\Delta=0.02\)일 때 과립 잡음 분산 \(\sigma_g^2\) 를 근사 계산하라.

**풀이**

$$
\sigma_g^2\approx\frac{\Delta^2}{12}=\frac{0.02^2}{12}
=\frac{0.0004}{12}\approx 3.33\times10^{-5}.
$$

---

### \(\Delta\) 변화에 따른 품질 비교

§7.2 코드를 참고하여
\(f=1\,\mathrm{kHz}\), \(A=0.8\) 사인파에 대해

- \(\Delta=0.005\)
- \(\Delta=0.02\)

두 경우의 SNR을 비교하라.
(힌트: slope overload가 없는 주파수에서 과립 잡음이 지배적이다.)

**풀이(요지)**

- 1 kHz에서는 두 경우 모두 slope overload는 거의 없다.
- \(\Delta\) 가 작은 쪽이 과립 잡음 전력이 \(\Delta^2\) 에 비례해 작아지므로 SNR이 높다.

직접 측정:

```octave
clear; clc
Fs=48000; T=0.05; n=0:round(Fs*T)-1; t=n/Fs;
x=0.8*sin(2*pi*1000*t);

for Delta=[0.005 0.02]
  b=dm_encode(x,Delta); y=dm_decode(b,Delta);
  SNR=10*log10(mean(x.^2)/mean((x-y).^2));
  fprintf("Delta=%.3f -> SNR=%.2f dB\n", Delta, SNR);
end
```

---

### CVSD가 유리한 상황 설명

입력이 “작은 진폭의 저주파 구간”과 “큰 진폭의 고주파 구간”이 섞인 음성 신호라고 하자.
고정 DM보다 CVSD가 유리한 이유를 §2–§5 관점에서 설명하라.

**풀이**

- 고정 DM은 \(\Delta\) 하나로 두 구간을 동시에 커버해야 한다.
  - \(\Delta\) 를 작게 잡으면 고주파/큰 진폭 구간에서 slope overload
  - \(\Delta\) 를 크게 잡으면 저주파/작은 진폭 구간에서 과립 잡음 증가
- CVSD는 입력 변화가 빠른 구간에서 \(\Delta\) 를 키워 slope overload를 줄이고,
  평탄한 구간에서 \(\Delta\) 를 줄여 과립 잡음을 억제한다.

---

## 정리

- DM은 DPCM의 극단적 단순화로,
  $$e[n]=x[n]-y[n-1],\quad b[n]=\operatorname{sign}(e[n]),\quad y[n]=y[n-1]+\Delta b[n]$$
  세 식으로 요약된다.
- 고정 스텝 DM의 핵심 한계는
  **과립 잡음**(입력이 평탄할 때)과 **경사 과부하**(입력이 급변할 때)이며,
  각각 \(\Delta\) 를 줄이거나 \(\Delta f_s\) 를 키우는 방향으로 해결된다.
- 두 한계는 **서로 반대 방향의 트레이드오프**를 만들므로,
  오버샘플링과 **적응형 스텝(CVSD/ADM)** 이 실용적 해법이 된다.
- DM은 현대 ΣΔ 변조의 출발점으로,
  1비트 양자화 + 누산/피드백 루프라는 관점에서 매우 중요한 개념이다.

이제 DM의 원리·한계·적응형 개선·ΣΔ로의 연결이 잡혔다면,
다음 글에서는 **ΣΔ 변조의 노이즈 셰이핑 수식, NTF 설계, 다단/고차 루프 안정성**으로 확장하면 자연스럽게 이어진다.
