---
layout: post
title: AspNet - 인증과 권환
date: 2025-04-02 20:20:23 +0900
category: AspNet
---
# 인증(Authentication)과 권한(Authorization)의 차이

## 1. 개념/흐름 복습(핵심 1페이지 요약)

- **Authentication(인증)**: “당신은 누구인가?”  
  로그인/토큰 검증을 통해 **Identity(ClaimsPrincipal)** 생성.
- **Authorization(권한)**: “당신은 무엇을 할 수 있는가?”  
  정책/역할/클레임/리소스 규칙으로 **요청 허용 여부** 결정.

요청 파이프라인 흐름:

```
[UseAuthentication] → HttpContext.User 설정
[UseAuthorization]  → 정책 평가(롤/클레임/커스텀)
[엔드포인트 실행]    → [Authorize]/[AllowAnonymous]에 따라 접근
```

상태코드:

- 401 Unauthorized: **인증 실패/부재**(토큰 없음/유효하지 않음)
- 403 Forbidden: **인증 성공**했지만 **권한 없음**

---

## 2. 인증(Authentication) — 스킴과 핸들러

ASP.NET Core는 **인증 스킴(Scheme)** 단위로 인증 핸들러를 등록/선택한다.  
대표 핸들러:
- `JwtBearerHandler` — API용 JWT
- `CookieAuthenticationHandler` — MVC/Razor용 세션 쿠키
- OIDC/OAuth2 클라이언트 — 외부 IdP 로그인

### 기본 구조

```csharp
builder.Services
    .AddAuthentication(options =>
    {
        options.DefaultAuthenticateScheme = "Bearer"; // 기본 인증 스킴
        options.DefaultChallengeScheme = "Bearer";
    })
    .AddJwtBearer("Bearer", options =>
    {
        options.Authority = "https://auth.myapp.com";
        options.Audience = "myapi";
        options.RequireHttpsMetadata = true;
    });
```

> **포인트**: 스킴 이름(예: `"Bearer"`, `"Cookies"`)을 명확히 관리하면 다중 스킴 구성 시 유연해진다.

---

## 3. 권한(Authorization) — 롤/정책/클레임/리소스 기반

- **Role 기반**: `[Authorize(Roles = "Admin,Manager")]`
- **Policy 기반**: `RequireClaim/RequireRole/Requirements` 등 조합
- **리소스 기반**: `IAuthorizationService.AuthorizeAsync(user, resource, "policy")`  
  (엔티티의 소유자 여부, 상태값 등 **런타임 데이터**로 판단)

---

## 4. 프로그램 구조(Program.cs) — 파이프라인과 순서

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();

// 1) 인증 등록
builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", o =>
    {
        o.Authority = "https://auth.myapp.com";
        o.Audience = "myapi";
    });

// 2) 권한 정책 등록
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("CanDelete", p => p.RequireClaim("permission", "delete:order"));
});

// 3) MVC 필터나 정책 변환기가 필요하면 추가 등록
// builder.Services.AddSingleton<IAuthorizationHandler, ...>();

var app = builder.Build();

// 순서 중요: 인증 → 권한
app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.Run();
```

---

## 5. JWT(OAuth2/OIDC) 실전 설정

### 5.1 JwtBearer 기본

```csharp
builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", options =>
    {
        options.Authority = builder.Configuration["Auth:Authority"]; // OIDC Issuer
        options.Audience  = builder.Configuration["Auth:Audience"];  // API 리소스 식별자
        options.TokenValidationParameters = new()
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true
        };
        // 필요 시 이벤트 훅
        options.Events = new Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerEvents
        {
            OnTokenValidated = ctx =>
            {
                // 추가 검증/로깅
                return Task.CompletedTask;
            },
            OnAuthenticationFailed = ctx =>
            {
                // 실패 로깅
                return Task.CompletedTask;
            }
        };
    });
```

### 5.2 스코프 기반 권한(OAuth2 권장)

스코프 클레임(예: `scope: "orders.read orders.write"`)으로 정책 설계:

```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("scope:orders.read", p =>
        p.RequireAssertion(c =>
            c.User.HasClaim("scope", "orders.read") ||
            c.User.FindAll("scope").Any(s => s.Value.Split(' ').Contains("orders.read"))));
});
```

사용:

```csharp
[Authorize(Policy = "scope:orders.read")]
[HttpGet("api/orders")]
public IActionResult GetOrders() => Ok(...);
```

---

## 6. Cookie 인증(MVC/Razor용) 설정

```csharp
builder.Services.AddAuthentication("Cookies")
    .AddCookie("Cookies", o =>
    {
        o.LoginPath = "/auth/signin";
        o.LogoutPath = "/auth/signout";
        o.AccessDeniedPath = "/auth/denied";
        o.SlidingExpiration = true;
        o.ExpireTimeSpan = TimeSpan.FromHours(8);
    });

builder.Services.AddAuthorization();
```

로그인 성공 시:

```csharp
public async Task<IActionResult> SignIn([FromForm] LoginInput input)
{
    // 사용자 검증 후
    var claims = new List<Claim>
    {
        new(ClaimTypes.NameIdentifier, user.Id),
        new(ClaimTypes.Name, user.UserName),
        new("permission", "delete:order")
    };
    var identity = new ClaimsIdentity(claims, "Cookies");
    await HttpContext.SignInAsync("Cookies", new ClaimsPrincipal(identity));
    return Redirect("/");
}
```

---

## 7. 다중 스킴(웹+API 동시) 구성과 선택

웹은 Cookies, API는 Bearer:

```csharp
builder.Services.AddAuthentication()
    .AddCookie("Cookies", o => { /* ... */ })
    .AddJwtBearer("Bearer", o => { /* ... */ });

builder.Services.AddAuthorization();
```

엔드포인트별 스킴 선택:

```csharp
[Authorize(AuthenticationSchemes = "Bearer", Policy = "scope:orders.read")]
[ApiController]
[Route("api/orders")]
public class OrdersApiController : ControllerBase { /* ... */ }

[Authorize(AuthenticationSchemes = "Cookies")]
public class HomeController : Controller { /* ... */ }
```

또는 **정책에 스킴 강제**:

```csharp
builder.Services.AddAuthorization(o =>
{
    o.AddPolicy("WebOnly", p =>
    {
        p.AddAuthenticationSchemes("Cookies");
        p.RequireAuthenticatedUser();
    });
});
```

---

## 8. 정책 기반 권한 — Role/Claim/Custom Requirement

### 8.1 기본 정책

```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("AdminsOnly", p => p.RequireRole("Admin"));
    options.AddPolicy("CanDelete", p => p.RequireClaim("permission", "delete:order"));
});
```

사용:

```csharp
[Authorize(Policy = "AdminsOnly")]
public IActionResult AdminPage() => View();

[Authorize(Policy = "CanDelete")]
[HttpDelete("api/orders/{id:int}")]
public IActionResult Delete(int id) => NoContent();
```

### 8.2 커스텀 Requirement/Handler

요구사항:

```csharp
public sealed class OwnerOrAdminRequirement : IAuthorizationRequirement { }
```

핸들러:

```csharp
public sealed class OwnerOrAdminHandler
    : AuthorizationHandler<OwnerOrAdminRequirement, Order>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        OwnerOrAdminRequirement requirement,
        Order resource)
    {
        var isAdmin = context.User.IsInRole("Admin");
        var userId = context.User.FindFirstValue(ClaimTypes.NameIdentifier);

        if (isAdmin || resource.OwnerId == userId)
            context.Succeed(requirement);

        return Task.CompletedTask;
    }
}
```

등록:

```csharp
builder.Services.AddSingleton<IAuthorizationHandler, OwnerOrAdminHandler>();
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("OwnerOrAdmin", p =>
        p.AddRequirements(new OwnerOrAdminRequirement()));
});
```

사용(리소스 기반 섹션 참고).

---

## 9. 리소스 기반 권한(IAuthorizationService)

엔티티 상태/소유권 등을 런타임으로 평가:

```csharp
public class OrdersController : ControllerBase
{
    private readonly IAuthorizationService _auth;
    private readonly AppDbContext _db;

    public OrdersController(IAuthorizationService auth, AppDbContext db)
    {
        _auth = auth; _db = db;
    }

    [HttpDelete("api/orders/{id:int}")]
    public async Task<IActionResult> Delete(int id)
    {
        var order = await _db.Orders.FindAsync(id);
        if (order is null) return NotFound();

        var result = await _auth.AuthorizeAsync(User, order, "OwnerOrAdmin");
        if (!result.Succeeded) return Forbid();

        _db.Orders.Remove(order);
        await _db.SaveChangesAsync();
        return NoContent();
    }
}
```

> **장점**: 소유자/상태(예: `IsLocked`) 등 **동적 규칙** 반영이 용이.

---

## 10. 엔드포인트/Minimal API에서의 권한 부착

### 10.1 엔드포인트 체이닝

```csharp
app.MapGet("/api/reports", () => Results.Ok())
   .RequireAuthorization("scope:reports.read");
```

### 10.2 그룹 라우트에 기본 정책

```csharp
var api = app.MapGroup("/api")
             .RequireAuthorization(); // 인증 필수(기본 정책)

api.MapGet("/me", (ClaimsPrincipal user) => Results.Ok(new { name = user.Identity?.Name }));
api.MapPost("/orders", () => Results.Created(...)).RequireAuthorization("scope:orders.write");
```

---

## 11. 권한 캐시/성능(클레임 변환, 역할 폭발 대응)

- **Claims Transformation**: 토큰 수신 후 **서버 측에서 추가 클레임** 부여/변환

```csharp
builder.Services.AddScoped<IClaimsTransformation, MyClaimsTransformer>();

public sealed class MyClaimsTransformer : IClaimsTransformation
{
    public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)
    {
        // DB/캐시 조회로 permission 추가(주의: 매 요청 비용 → 캐시/메모이제)
        return Task.FromResult(principal);
    }
}
```

- **역할 폭발 방지**: 수십/수백 Roles 대신 **권한(permissions)** 단위 스코프/클레임을 추천
- **Token Introspection**: 레거시/보안 엄격 환경에서 토큰 검사를 IdP에 조회(네트워크 비용 주의, 캐시 도입)
- **권한 캐시**: 사용자 권한을 `IMemoryCache`/Redis로 캐시 후 TTL 관리

---

## 12. 401 vs 403 — 에러 응답 표준화(ProblemDetails)

전역 예외/결과 필터로 일관된 에러 바디 제공:

```csharp
app.UseStatusCodePages(async ctx =>
{
    var res = ctx.HttpContext.Response;
    if (res.StatusCode is 401 or 403)
    {
        var problem = new ProblemDetails
        {
            Status = res.StatusCode,
            Title = res.StatusCode == 401 ? "Unauthorized" : "Forbidden",
            Detail = res.StatusCode == 401
                ? "유효한 인증이 필요합니다."
                : "요청한 작업에 대한 권한이 없습니다."
        };
        res.ContentType = "application/problem+json";
        await ctx.HttpContext.Response.WriteAsJsonAsync(problem);
    }
});
```

**응답 예(403)**:

```json
{
  "type": "about:blank",
  "title": "Forbidden",
  "status": 403,
  "detail": "요청한 작업에 대한 권한이 없습니다."
}
```

---

## 13. 테스트 전략(단위/통합)

- **핸들러 단위 테스트**: `AuthorizationHandlerContext`를 생성해 `HandleRequirementAsync` 검증
- **통합 테스트**: `WebApplicationFactory<TEntryPoint>` + `HttpClient`로 JWT/쿠키 시나리오

```csharp
public class OwnerOrAdminHandlerTests
{
    [Fact]
    public async Task Owner_Succeeds()
    {
        var user = new ClaimsPrincipal(new ClaimsIdentity(
            new[] { new Claim(ClaimTypes.NameIdentifier, "u1") }, "test"));

        var order = new Order { OwnerId = "u1" };
        var req = new OwnerOrAdminRequirement();
        var ctx = new AuthorizationHandlerContext(new[] { req }, user, order);

        var handler = new OwnerOrAdminHandler();
        await handler.HandleAsync(ctx);

        Assert.True(ctx.HasSucceeded);
    }
}
```

---

## 14. 운영 팁(토큰 회전, 스코프 설계, 로깅/감사)

- **토큰 수명/회전**: 액세스 토큰 짧게, 리프레시 토큰 안전 저장 및 회전(Rotation)
- **스코프 설계**: `resource.action` 패턴(`orders.read`, `orders.write`)으로 명시적/미세 권한
- **로깅/감사**:
  - `UserId`, `Scopes`, `ClientId`를 구조화 로깅에 포함
  - 403/401 비율 모니터링(오용/권한 누락 탐지)
- **권한 변경 전파**:
  - 토큰 기반 시스템은 즉시 반영 어려움 → **토큰 짧게**, **백채널 매커니즘**(deny-list) 고려

---

## 15. 자주 겪는 문제/체크리스트

1. **401/403 혼동**  
   인증 부재/실패는 401, 인증은 됐으나 권한 없음은 403.
2. **[AllowAnonymous] 누락**  
   공개 엔드포인트는 명시적으로 허용.
3. **정책 이름 오타**  
   `options.AddPolicy("CanDelete"...` vs `[Authorize(Policy = "CanDelete")]` 일치 확인.
4. **다중 스킴에서 기본 스킴 착각**  
   엔드포인트별 `AuthenticationSchemes` 또는 정책 내 `AddAuthenticationSchemes`로 명시.
5. **클레임 타입 혼재**  
   `role` vs `ClaimTypes.Role`, `scope` 표준화. 토큰 발급기(IdP)와 합의.
6. **권한 변환 시 과도한 DB 호출**  
   `IClaimsTransformation` 사용 시 캐시 도입.
7. **리소스 미적용**  
   소유권/상태 기반은 리소스 기반 권한으로 평가(`AuthorizeAsync(user, resource, policy)`).
8. **Swagger 테스트 시 인증 미부착**  
   JWT/OAuth2 스키마 정의 후 UI Authorize 버튼으로 토큰 주입.

---

## 통합 예제

### DTO/엔티티

```csharp
public class Order
{
    public int Id { get; set; }
    public string OwnerId { get; set; } = default!;
    public bool IsLocked { get; set; }
}
```

### 정책 & 핸들러 등록(Program.cs)

```csharp
builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", o =>
    {
        o.Authority = "https://auth.myapp.com";
        o.Audience = "myapi";
    });

builder.Services.AddAuthorization(o =>
{
    o.AddPolicy("Orders.Read", p => p.RequireClaim("scope", "orders.read"));
    o.AddPolicy("Orders.Modify", p => p.RequireClaim("scope", "orders.write"));
    o.AddPolicy("OwnerOrAdmin", p => p.AddRequirements(new OwnerOrAdminRequirement()));
});

builder.Services.AddSingleton<IAuthorizationHandler, OwnerOrAdminHandler>();
```

### 리소스 기반 컨트롤러

```csharp
[ApiController]
[Route("api/orders")]
public class OrdersController : ControllerBase
{
    private readonly AppDbContext _db;
    private readonly IAuthorizationService _auth;

    public OrdersController(AppDbContext db, IAuthorizationService auth)
    {
        _db = db; _auth = auth;
    }

    [HttpGet]
    [Authorize(Policy = "Orders.Read")]
    public IActionResult List() => Ok(_db.Orders.Take(50));

    [HttpDelete("{id:int}")]
    [Authorize(Policy = "Orders.Modify")]
    public async Task<IActionResult> Delete(int id)
    {
        var entity = await _db.Orders.FindAsync(id);
        if (entity is null) return NotFound();

        // 리소스 기반 추가 검증(소유자/관리자)
        var authz = await _auth.AuthorizeAsync(User, entity, "OwnerOrAdmin");
        if (!authz.Succeeded) return Forbid();

        _db.Orders.Remove(entity);
        await _db.SaveChangesAsync();
        return NoContent();
    }
}
```

---

## 부록: 빠른 레퍼런스 코드 스니펫

### 1. 모든 API 인증 필수(미인증 401 자동)

```csharp
builder.Services.AddAuthorization(o =>
{
    o.FallbackPolicy = new AuthorizationPolicyBuilder()
        .RequireAuthenticatedUser()
        .Build();
});
```

### 2. Minimal API에서 스코프 요구

```csharp
app.MapPost("/api/reports", () => Results.Created("/api/reports/1", null))
   .RequireAuthorization("scope:reports.write");
```

### 3. 역할+권한 혼합 정책

```csharp
options.AddPolicy("AdminOrWriter", p =>
    p.RequireAssertion(ctx =>
        ctx.User.IsInRole("Admin") ||
        ctx.User.HasClaim("scope", "content.write")));
```

---

## 요약

| 구분 | 핵심 포인트 |
|------|-------------|
| 인증 | 스킴 단위 구성(JWT/Cookies/OIDC). `UseAuthentication()`로 `HttpContext.User` 설정 |
| 권한 | 역할/스코프/클레임/리소스 기반 조합. 정책으로 일관 관리 |
| 401/403 | 인증 부재/실패=401, 권한 없음=403, ProblemDetails로 표준화 |
| 실무 설계 | 스코프 기반(권한) 권장, 리소스 기반 병행, 다중 스킴 명시 |
| 테스트/운영 | 핸들러 단위테스트, JWT 회전/수명, 로깅/감사, 캐시 전략 |

> **결론**: 인증은 **신원**을, 권한은 **행위 허용**을 다룬다. ASP.NET Core의 스킴/정책/핸들러/리소스 기반 도구들을 **일관된 정책 설계**로 엮으면, 유지보수성이 높고 보안 친화적인 애플리케이션을 만들 수 있다.