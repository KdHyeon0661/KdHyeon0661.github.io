---
layout: post
title: 알고리즘 - 그리디
date: 2025-02-04 19:20:23 +0900
category: 알고리즘
---
# 그리디 알고리즘 완전 정복

## 그리디란 무엇인가

### 정의와 직관

> **매 순간 국소적으로 최선**이라고 판단되는 선택을 하고 되돌리지 않으며, 그 결과가 전체 최적이 되기를 기대하는 방법.

- 의사결정은 **한 번 내리면 고정**(백트래킹/DP의 되돌림 없음).
- 적용 가능 조건을 만족해야만 전역 최적을 얻는다.

### 필수 조건 두 가지 (재강조)

| 조건 | 의미 |
|---|---|
| 탐욕 선택 속성 (Greedy Choice Property) | **지금의 최적 선택**을 취해도 **전역 최적해의 일부**가 될 수 있음 |
| 최적 부분 구조 (Optimal Substructure) | 문제의 최적해가 **서브문제의 최적해**로 구성됨 |

수학적으로는, 최적해 \(O\)가 있을 때 현재 탐욕 선택 \(g\)을 포함하는 최적해 \(O'\)로 **교환**(exchange)해서도 최적임을 보이면 충분하다.

---

## 그리디가 “맞는 이유” — 교환 논증 기본형

### 회의실 배정(BOJ 1931)의 교환 논증

- 전략: **종료 시간**이 빠른 회의부터 선택.
- 증명 스케치(교환):
  1) 최적해 \(O\)를 하나 고른다.
  2) \(O\)에서 첫 회의와 **종료 시간이 가장 빠른 회의** \(m^*\)가 다르면, 두 회의를 **교환**해도 이후 선택 가능 집합은 줄지 않음.
  3) 반복 교환으로, 탐욕 해의 앞부분을 최적해로 바꾸어가도 **해의 크기**(회의 수)는 유지된다.
- 결론: 탐욕 해 = 최적해.

### 동전 거스름(BOJ 11047)이 안전한 경우

- **동전 단위가 서로 배수/정규 체계**일 때(예: 한국/미국 통화 체계), 큰 단위부터 최대한 쓰는 탐욕 해가 최적.
- 반례(그리디 실패): 동전이 \(\{1,3,4\}\), 목표 6 → 탐욕: 4+1+1(3개), 최적: 3+3(2개).

---

## 핵심 패턴

### 정렬 그리디

- “**정렬 → 한 번 순회 → 조건에 맞게 선택/스킵**”
- 예: 회의실 배정(종료시각), ATM(시간 오름차순), 줄 세우기 누적합, 구간 병합/덮개.

### 그리디

- “**지금 가장 좋은 후보를 빠르게 꺼내기**”
- 예: 허프만(카드 묶기, BOJ 1715), 보석 도둑(BOJ 1202), 멀티탭 스케줄링(BOJ 1700·차후 사용시점).

### 스위핑(sweep line)

- 구간/이벤트를 정렬 후 **좌→우로 훑으며** 힙/카운터로 상태 관리.
- 예: 구간 덮개 최소 수, 강의실 배정(동시 배정 수), 회의실 배정 종류의 확장.

### 증감 누적/경계 점프

- 예: 저울(BOJ 2437) — 만들 수 있는 **연속 구간 상한** \(target\)을 유지하며 점프.

---

## 대표 예제 (초안 보강 + 증명/주의)

### 동전 0 (BOJ 11047)

**조건**: 통화 체계가 그리디 친화(배수)일 때 최적.

```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
coins = [int(input()) for _ in range(n)]
coins.sort(reverse=True)

cnt = 0
for c in coins:
    if k == 0: break
    cnt += k // c
    k %= c
print(cnt)
```

### ATM (BOJ 11399)

**핵심**: 작은 시간부터 정렬 → 누적합 최소화.

```python
import sys
input = sys.stdin.readline

n = int(input())
arr = sorted(map(int, input().split()))
acc = 0
ans = 0
for t in arr:
    acc += t
    ans += acc
print(ans)
```

### 회의실 배정 (BOJ 1931)

**전략**: (종료, 시작) 순으로 정렬 → 가능한 회의 최대 수.

```python
import sys
input = sys.stdin.readline

n = int(input())
meet = [tuple(map(int, input().split())) for _ in range(n)]
meet.sort(key=lambda x: (x[1], x[0]))

end = -10**18
cnt = 0
for s, e in meet:
    if s >= end:
        cnt += 1
        end = e
print(cnt)
```

### 잃어버린 괄호 (BOJ 1541)

**핵심**: `-` 이후의 `+`들을 **한 묶음**으로 뺀다.

```python
import sys
parts = sys.stdin.readline().strip().split('-')
total = sum(map(int, parts[0].split('+')))
for block in parts[1:]:
    total -= sum(map(int, block.split('+')))
print(total)
```

### 주유소 (BOJ 13305)

**핵심**: **지금까지 본 최솟값**으로 매 거리 구간을 누적.

```python
import sys
input = sys.stdin.readline

n = int(input())
dist = list(map(int, input().split()))
price = list(map(int, input().split()))

minp = price[0]
ans = 0
for i in range(n-1):
    if price[i] < minp:
        minp = price[i]
    ans += minp * dist[i]
print(ans)
```

### 저울 (BOJ 2437)

**증명 직관**: 만들 수 있는 구간이 \([1, target)\)이라면, 다음 무게 \(w\)가 `target` 이하이면 범위가 \([1, target+w)\)로 **확장**, 크면 `target`이 **최소 불가능 수**.

```python
import sys
input = sys.stdin.readline

n = int(input())
arr = sorted(map(int, input().split()))
target = 1
for w in arr:
    if w > target:
        break
    target += w
print(target)
```

---

## 확장 예제 — 그리디 고전/실전

### — 정렬 그리디가 **정확**

- 가중치 \(W\) 이하로 가치 \(V\) 최대화. **분할 허용(일부만 담기)**이면 \(\frac{v}{w}\) 큰 것부터 채움이 최적.
- 증명: 교환 논증(비율이 큰 항목 일부로 바꾸면 항상 가치가 증가).

```python
def fractional_knapsack(items, W):
    # items: list of (value, weight)
    items.sort(key=lambda x: x[0]/x[1], reverse=True)
    cap = W
    val = 0.0
    for v, w in items:
        if w <= cap:
            val += v
            cap -= w
        else:
            val += v * (cap / w)
            break
    return val
```

> **정수 배낭(0/1)**은 그리디 실패 → **DP** 필요.

### — **마감 오름차순 + 힙**

- 한 번에 하나의 작업, 각 작업은 소요 1, 마감 \(d\), 이익 \(p\).
- 전략: **마감 오름차순으로 보며**, 매번 후보 작업을 **이익 기준 최소 힙으로 관리**, 작업 수가 마감 초과하면 가장 이익 작은 것을 제거.
- 교환 논증: 더 이익 큰 것을 남기는 것이 전역 최적.

```python
import heapq

def job_scheduling(jobs):
    # jobs: [(deadline, profit)]
    jobs.sort()
    pq = []  # min-heap of profits
    for d, p in jobs:
        heapq.heappush(pq, p)
        if len(pq) > d:
            heapq.heappop(pq)
    return sum(pq)
```

(BOJ 2109 “순회강연”과 유사 패턴)

### — 정렬 누적 최댓값

- 로프 \(k\)개를 함께 쓰면 하중은 \(k \times \min(\text{그 중 가장 약한 로프})\).
- 전략: 하중 내림차순 정렬 후 \(i\)번째까지 사용할 때 가능한 하중 갱신.

```python
import sys
input = sys.stdin.readline

n = int(input())
arr = sorted([int(input()) for _ in range(n)], reverse=True)

ans = 0
for i, w in enumerate(arr, 1):
    ans = max(ans, w * i)
print(ans)
```

### — 허프만/합치기 최소 비용

- 전략: 항상 **가장 작은 두 묶음**부터 합친다(최적).
- 우선순위 큐로 구현.

```python
import sys, heapq
input = sys.stdin.readline

n = int(input())
pq = []
for _ in range(n):
    heapq.heappush(pq, int(input()))
if n == 1:
    print(0); sys.exit(0)

cost = 0
while len(pq) > 1:
    a = heapq.heappop(pq)
    b = heapq.heappop(pq)
    s = a + b
    cost += s
    heapq.heappush(pq, s)
print(cost)
```

### — 스위핑 + 힙

- 가방마다 용량 \(C_i\), 보석(무게, 가치) 존재. **각 가방에 1개** 담기.
- 전략: 가방 용량 오름차순으로 훑으면서, **들어갈 수 있는 보석**들을 가치 기준 **최대 힙**에 넣고 **가장 가치 큰 것**을 꺼내 담기.

```python
import sys, heapq
input = sys.stdin.readline

n, k = map(int, input().split())
jew = [tuple(map(int, input().split())) for _ in range(n)]
bags = [int(input()) for _ in range(k)]
jew.sort(key=lambda x: x[0])  # by weight
bags.sort()

ans = 0
pq = []  # max-heap via negative
idx = 0
for cap in bags:
    while idx < n and jew[idx][0] <= cap:
        heapq.heappush(pq, -jew[idx][1])
        idx += 1
    if pq:
        ans += -heapq.heappop(pq)
print(ans)
```

### — **가장 늦게 다시 쓰는 것**을 뽑아라

- 플러그 구멍 \(N\), 사용 순서 길이 \(K\).
- 전략(벨만-포드류가 아니라 **그리디**): 현재 꽂힘 집합이 가득인데 새 기기를 꽂아야 하면, **미래에 가장 나중에 다시 쓰이거나 아예 안 쓰이는** 기기를 제거.

```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
order = list(map(int, input().split()))

plug = set()
ans = 0
for i, x in enumerate(order):
    if x in plug:
        continue
    if len(plug) < n:
        plug.add(x);
        continue
    # 교체 필요: 가장 늦게 다시 쓰이는 기기 선택
    victim, far = None, -1
    for p in plug:
        try:
            nxt = order.index(p, i+1)
        except ValueError:
            victim = p; break  # 다시 안 씀: 즉시 희생양
        if nxt > far:
            far, victim = nxt, p
    plug.remove(victim)
    plug.add(x)
    ans += 1
print(ans)
```

### — 내림차순 + 가장 무거운 것부터

- **매 분** 각 크레인은 하나씩만 들 수 있고, 자신의 한도 이하에서 **가장 무거운** 것을 들려 시도.
- 전략: 크레인 내림차순, 박스 내림차순 → **리스트 포인터**로 한 번 내리그으며 적합한 박스 할당. 불가하면 -1.

```python
import sys
input = sys.stdin.readline

n = int(input())
cr = sorted(map(int, input().split()), reverse=True)
m = int(input())
bx = sorted(map(int, input().split()), reverse=True)

if bx[0] > cr[0]:
    print(-1); sys.exit(0)

pos = [0]*n
taken = [False]*m
cnt = 0
time = 0

while cnt < m:
    for i in range(n):
        while pos[i] < m and (taken[pos[i]] or bx[pos[i]] > cr[i]):
            pos[i] += 1
        if pos[i] < m:
            taken[pos[i]] = True
            pos[i] += 1
            cnt += 1
    time += 1
print(time)
```

### — 스위핑

- 목표 구간을 **최소 개수**의 구간으로 덮음.
- 전략: 시작 시점을 현재 `cur`로 두고, `cur` 이하에서 시작하는 구간들 중 **끝나는 시점이 가장 먼** 것을 확장 선택. 실패 시 불가능.

```python
import sys
input = sys.stdin.readline

def pack(m, d): return m*100 + d

n = int(input())
seg = []
for _ in range(n):
    sm, sd, em, ed = map(int, input().split())
    seg.append((pack(sm, sd), pack(em, ed)))
seg.sort()

target_end = pack(12, 1)
cur = pack(3, 1)
idx = 0
cnt = 0
best = cur

while cur < target_end:
    updated = False
    while idx < n and seg[idx][0] <= cur:
        best = max(best, seg[idx][1])
        idx += 1
        updated = True
    if not updated:  # cur 이하 시작 구간 없음
        break
    cnt += 1
    cur = best

print(cnt if cur >= target_end else 0)
```

---

## 그리디 vs 다른 패러다임 — 경계 정리

### DP와의 경계

- **그리디 실패 예**: 정수 배낭(0/1), 동전 단위 임의(앞서 반례).
- **DP 필요 신호**: “지금의 최선이 미래를 해침” / “부분해 결합 시 상호작용”.

### 그래프 최단거리/최소 신장 트리

- **다익스트라**: 비음수 가중치에서, “미확정 정점 중 **현재 가장 가까운 정점** 확정” → **그리디 + 우선순위 큐**.
- **프림/크루스칼(MST)**: 매 단계 **가장 가벼운 안전 간선** 선택(컷 속성) → **그리디**.
  - 크루스칼: 간선 가중 오름차순 + 유니온파인드.
  - 프림: 힙으로 가벼운 연결 간선 확장.

---

## 실전 구현 팁

1) **정렬은 한 번만**: 입력 후 기준 정렬, 탐색/스캔은 O(N).
2) **힙**: 파이썬 `heapq`는 **최소 힙** → 최대 힙은 **부호 반전**.
3) **스위핑 포인터**: 두 리스트를 정렬 후 **한 번의 선형 포인터 전진**으로 결합.
4) **반례 점검**: 동전/배낭처럼 **조건이 깨지면 그리디가 오답**.
5) **I/O 최적화**: `sys.stdin.readline` 사용, 출력은 모아서.

---

## 수학 메모: 그리디 올바름의 전형적 형태

- **교환 논증**(exchange argument):
  $$
  \text{탐욕 선택 } g \text{ 을 포함하지 않는 최적해 } O \Rightarrow O' \text{ 로 교환하여 } g \text{ 을 포함시키되 가치 불변}
  $$
- **컷/안전 간선**(MST):
  - 어떤 컷을 가르는 **최소 가중치 간선**은 항상 어떤 MST에 포함(안전).

---

## 추가 백준 문제 모음(유형별)

| 번호 | 제목 | 키워드 |
|---|---|---|
| 2217 | 로프 | 정렬 누적 max |
| 1715 | 카드 묶기 | 힙(허프만) |
| 1202 | 보석 도둑 | 스위핑+힙 |
| 1700 | 멀티탭 스케줄링 | 미래 사용 시점 |
| 1092 | 크레인 | 내림차순+포인터 |
| 2457 | 공주님의 정원 | 구간 덮개 |
| 11000 | 강의실 배정 | 스위핑+힙(동시 수) |
| 19941 | 햄버거 분배 | 양방향 그리디 |
| 2810 | 컵홀더 | 규칙 그리디 |
| 1026 | 보물 | 재배열 부등식 |
| 15903 | 카드 합체 놀이 | 힙 반복 |
| 1449 | 수리공 항승 | 덮개 길이 |

---

## 마무리 요약

| 항목 | 요약 |
|---|---|
| 본질 | **지금의 최선**을 택하고 되돌리지 않는다 |
| 필요조건 | **탐욕 선택 속성** + **최적 부분 구조** |
| 증명 | **교환 논증** 또는 **컷 속성**으로 안전성 보임 |
| 핵심패턴 | 정렬 그리디 / 힙 그리디 / 스위핑 |
| 주의 | 동전/배낭 등 **조건 불충족 시 그리디 오답** → DP/그래프 고려 |

> 실전 절차: **(1) 정렬 기준 가설 → (2) 교환 논증으로 안전성 점검 → (3) 반례 탐색 → (4) 실패 시 DP/그래프 전환**.

---

## 부록: 코드 스니펫 모음

### A. 정렬 + 한 번 스캔 템플릿

```python
arr.sort(key=...)  # 기준 확정
state = init()
for x in arr:
    if can_take(x, state):
        take(x, state)
    else:
        skip_or_adjust(x, state)
print(answer(state))
```

### B. 스위핑 + 힙 템플릿

```python
events.sort()      # by position/time
i = 0
pq = []            # min or max (negate)
for pos in key_positions:
    while i < len(events) and events[i].start <= pos:
        heapq.heappush(pq, priority_of(events[i]))
        i += 1
    # pop while invalid/overflow
    while pq and not valid(pq[0], pos):
        heapq.heappop(pq)
    if pq:
        use_top(pq)
```

### C. “미래 재사용 시점” 선택(멀티탭/페이지 교체형)

```python
def farthest_future(vset, seq, cur_idx):
    victim, far = None, -1
    for v in vset:
        try:
            nxt = seq.index(v, cur_idx+1)
        except ValueError:
            return v
        if nxt > far:
            victim, far = v, nxt
    return victim
```

이제, 각 문제에서 **정렬 기준** 혹은 **힙 우선순위 정의**만 정확히 세우면 그리디 풀이가 뼈대부터 단단해진다.
