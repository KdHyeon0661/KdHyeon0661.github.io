---
layout: post
title: 디지털신호처리 - 연습문제 세트 5
date: 2025-11-16 16:25:23 +0900
category: 디지털신호처리
---
# DSP 필터 구조와 유한 정밀도 — 종합 연습 문제 세트 5

## 연습 세트 사용 안내

### 준비 환경 (GNU Octave 기준)

- GNU Octave (신버전 권장, 예: 7.x 이상)
- `signal` 패키지 사용 (필터 설계, `freqz`, `butter`, `cheby1` 등)

```octave
pkg load signal   % 설치되어 있다면 이렇게 로드
```

- 기본 플롯: `plot`, `freqz`, `stem`, `subplot`, `axis` 등.

### 문제 구성 방식

각 섹션은 다음 형식을 따른다.

1. **문제 설명**: 이론 + 요구사항
2. **요구되는 결과**: 그래프, 수치 값, 코드 스니펫 등
3. **힌트**: 접근 방법, 핵심 아이디어
4. **참고 Octave 코드**: 실습용 예제

실전에서는:

- 먼저 **문제 본문만 보고** 풀어본 뒤,
- 막힐 때 **힌트/코드**를 참고하는 것을 추천한다.

---

## 기본 소자와 LTI 시스템 — 연습 문제

### 문제 1-1: 기본 소자 조합에서 차분방정식 유도하기

다음과 같은 블록 구조를 생각하자.

```text
x[n] ──▶(×2)──▶(+)────▶ y[n]
             ▲   │
             │   │
          [z⁻¹]  │
             ▲   │
             └───┘
```

- 입력 $$x[n]$$ 이 곱셈기 $$\times 2$$ 를 통과한 뒤,
- 이전 출력 $$y[n-1]$$ 과 더해져서 $$y[n]$$ 이 나온다.

**(1)** 이 구조에 해당하는 차분방정식 $$y[n] = \dots$$ 을 유도하라.

**(2)** 단위 계단 입력 $$x[n] = u[n]$$ 에 대해 $$y[n]$$ 을 손으로 최소 5샘플 정도 계산하라.

**(3)** GNU Octave로 이 시스템을 `filter` 함수 없이 직접 시뮬레이션하고,
단위 계단 응답을 그림으로 나타내라.

#### 힌트

- 블록도에서 신호 흐름을 따라가면:

  - 곱셈기 출력: $$2x[n]$$
  - 피드백 지점에서의 지연된 출력: $$y[n-1]$$
  - 가산기 출력: $$y[n] = 2x[n] + y[n-1]$$

- 초깃값 $$y[-1] = 0$$ 으로 두고, $$x[n]=1$$ (단위 계단)일 때,
  $$y[0], y[1], y[2], \dots$$ 을 순서대로 계산하면 된다.

#### 참고 Octave 코드

```octave
% 문제 1-1: 기본 LTI 시스템 시뮬레이션
clear; clc;

N = 20;
x = ones(1, N);   % 단위 계단 u[n]
y = zeros(1, N);

for n = 1:N
  if n == 1
    y_prev = 0;
  else
    y_prev = y(n-1);
  end
  y(n) = 2 * x(n) + y_prev;  % y[n] = 2x[n] + y[n-1]
end

stem(0:N-1, y, 'filled');
xlabel('n'); ylabel('y[n]');
title('문제 1-1: y[n] = 2x[n] + y[n-1] 의 단위 계단 응답');
grid on;
```

---

### 문제 1-2: 합성 블록을 단일 전송함수로 만들기

다음 구조를 고려하자.

```text
          ┌────────────[z⁻¹]────────────┐
          │                             ▼
x[n] ─▶(+)────▶(×0.5)────▶(+)────▶ y[n]
   ▲          ▲               ▲
   │          │               │
   │        (×0.3)          (×0.2)
   │          │               │
   └──────────┴───────────────┘
```

**(1)** 이 구조에 해당하는 차분방정식을 유도하라.
**(2)** 전송함수 $$H(z) = Y(z)/X(z)$$ 를 구하라.
**(3)** GNU Octave에서 `freqz`를 사용해 주파수 응답을 그려보고,
이 필터가 저역통과/고역통과/대역통과 중 어느 성격에 가까운지 판단하라.

#### 힌트

- 노드를 잘 이름 붙여라.
  - 예: 첫 번째 가산기 출력 $$v[n]$$, 곱셈기 $$0.5$$ 이후 $$w[n]$$, 두 번째 가산기 출력이 $$y[n]$$.
- 피드백 경로에서 $$y[n]$$ 와 $$y[n-1]$$ 이 곱셈기들을 거쳐 다시 더해지는 구조이다.
- 전송함수는

  $$
  H(z) = \frac{Y(z)}{X(z)} = \frac{\text{분자 다항식}}{\text{분모 다항식}}
  $$

  꼴로 정리하면 된다.

#### 참고 Octave 코드(구조를 직접 `filter`로 옮기는 버전)

```octave
clear; clc; pkg load signal;

% 전송함수 계수를 손으로 구했다는 가정 하에:
% y[n] = ... 형태를 b, a 계수로 표현
b = [b0 b1 ...];   % TODO: 손 계산 결과로 채우기
a = [1 a1 a2 ...]; % TODO: 손 계산 결과로 채우기

[H, w] = freqz(b, a, 1024);

plot(w/pi, 20*log10(abs(H)+eps));
xlabel('정규화 주파수 (\times\pi rad/sample)');
ylabel('Magnitude [dB]');
title('문제 1-2: H(z) 주파수 응답');
grid on;
```

---

## IIR 필터 구조 — Direct Form, 캐스케이드, 병렬

### 문제 2-1: Direct Form I / II / II-Transposed 비교

다음 IIR 전송함수를 고려하자.

$$
H(z) = \frac{Y(z)}{X(z)} =
\frac{1 + 0.5z^{-1}}{1 - 1.2z^{-1} + 0.81z^{-2}}.
$$

**(1)** 이것을 Direct Form I 구조로 구현할 때의 차분방정식을 써라.

**(2)** Direct Form II 구조로 구현할 때 필요한 지연소자 수는 몇 개인가?
Direct Form I과 비교해라.

**(3)** Direct Form II-Transposed 구조를 그려보고,
GNU Octave로 각 구조를 구현하여 임펄스 응답이 동일함을 확인하라.

#### 힌트

- Direct Form II의 표준 형태:

  $$
  y[n] = -a_1 y[n-1] - a_2 y[n-2] + b_0 x[n] + b_1 x[n-1] + b_2 x[n-2]
  $$

- 상태공간 관점에서 DF-II와 DF-II-Transposed는 지연 위치와 신호 흐름이 달라질 뿐, 전송함수는 동일.
- GNU Octave에서는 직접 `for` 루프를 돌려 DF-I/DF-II를 구현해 볼 수 있다.

#### 참고 Octave 코드(DF-II 직접 구현 예)

```octave
function y = iir_df2(b, a, x)
  % b: 분자 계수 [b0 b1 ... bM]
  % a: 분모 계수 [1 a1 ... aN]
  % x: 입력 신호
  N = length(a) - 1;
  w = zeros(1, N);    % 상태 (지연)
  y = zeros(size(x));

  for n = 1:length(x)
    % 입력 + 피드백
    w0 = x(n);
    for k = 1:N
      w0 = w0 - a(k+1) * w(k);
    end
    y(n) = b(1) * w0;
    for k = 1:N-1
      y(n) = y(n) + b(k+1)*w(k);
    end
    y(n) = y(n) + b(N+1)*w(N);  % M=N 가정 예시

    % 상태 업데이트 (시프트)
    w(2:end) = w(1:end-1);
    w(1) = w0;
  end
end

% 테스트
clear; clc;
b = [1 0.5];
a = [1 -1.2 0.81];

N = 100;
x = [1 zeros(1, N-1)];   % 임펄스
y_df2 = iir_df2(b, a, x);

stem(0:N-1, y_df2, 'filled');
xlabel('n'); ylabel('h[n]');
title('문제 2-1: DF-II 임펄스 응답');
grid on;
```

---

### 문제 2-2: 캐스케이드 구조 vs 직접 구조의 수치 안정성

다음 4차 IIR 필터를 생각하자.

$$
H(z) =
\frac{1}{(1 - 1.8\cos(\pi/4)z^{-1} + 0.81z^{-2}) (1 - 1.8\cos(\pi/3)z^{-1} + 0.81z^{-2})}.
$$

**(1)** 두 개의 2차 섹션(바이쿼드)을 캐스케이드한 구조로 표현하라.
각 섹션의 분모 다항식을 명시하라.

**(2)** 전체 4차 필터를 Direct Form II(단일 섹션) 구조로 구현했을 때와,
두 개의 2차 섹션을 캐스케이드로 구현했을 때,
고정소수점 (예: 16-bit, fractional bits 14)에서 응답이 어떻게 달라지는지 시뮬레이션하라.

**(3)** 왜 캐스케이드 구조가 일반적으로 더 수치적으로 안전한지 설명하라.

#### 힌트

- GNU Octave에서 `roots`/`poly`를 이용해 2차 섹션 계수를 얻을 수 있다.
- 고정소수점 흉내:

  - 계수를 $$2^{14}$$ 로 곱해 정수로 반올림 후, 다시 $$2^{14}$$ 로 나누기
  - 내부 누산은 더 큰 정밀도를 써도 되고, 일부러 좁혀도 된다.

#### 참고 Octave 코드 스케치

```octave
clear; clc; pkg load signal;

r1 = 0.9 * exp(1j*pi/4);
r2 = 0.9 * exp(-1j*pi/4);
r3 = 0.9 * exp(1j*pi/3);
r4 = 0.9 * exp(-1j*pi/3);

p = [r1 r2 r3 r4];
a = poly(p);          % 분모 계수 (4차)

b = 1;                % 분자는 1로 가정
[H, w] = freqz(b, a, 4096);

% (1) 2차 섹션 분해는 직접 p를 2개씩 묶어 poly() 적용
a1 = poly([r1 r2]);
a2 = poly([r3 r4]);

% (2) 고정소수점 양자화 예
nfrac = 14;
a_q = round(a * 2^nfrac) / 2^nfrac;
[Hq, ~] = freqz(b, a_q, 4096);

% 캐스케이드 구현 시에도 각각 a1, a2를 별도로 양자화 후 filter 두 번 적용
```

---

## FIR 필터 구조 — Direct, Transposed, 선형 위상, Polyphase

### 문제 3-1: 이동 평균 FIR 필터의 구조와 구현

길이 5 이동 평균 FIR 필터:

$$
h[n] = \frac{1}{5}, \quad n = 0,1,2,3,4
$$

**(1)** 이 필터의 차분방정식 $$y[n] = \dots$$ 을 쓰고, Direct Form 구조를 텍스트 블록도로 그려라.

**(2)** GNU Octave로 `for` 루프를 이용하여 직접 FIR 필터를 구현하라 (`conv` 금지).

**(3)** 동일한 필터를 `conv` 또는 `filter` 함수로도 구현한 후,
두 결과가 일치함을 확인하라.

#### 힌트

- 차분방정식:

  $$
  y[n] = \frac{1}{5}\bigl( x[n] + x[n-1] + x[n-2] + x[n-3] + x[n-4] \bigr).
  $$

#### 참고 Octave 코드

```octave
clear; clc;

b = ones(1, 5)/5;
N = 50;
x = randn(1, N);

% 직접 구현
M = length(b)-1;
x_delay = zeros(1, M);
y1 = zeros(1, N);

for n = 1:N
  x_taps = [x(n) x_delay];
  y1(n) = b * x_taps.';
  if M > 0
    x_delay(2:end) = x_delay(1:end-1);
    x_delay(1) = x(n);
  end
end

% conv를 사용한 구현
y2 = conv(x, b, 'same');

printf("max|y1 - y2| = %.3e\n", max(abs(y1 - y2)));
```

---

### 문제 3-2: 선형 위상 FIR의 대칭성 이용

길이 6인 선형 위상 FIR 필터가 다음과 같은 계수를 가진다고 하자.

$$
h[0] = 0.1, \quad h[1] = 0.2, \quad h[2] = 0.3, \quad h[3] = 0.3, \quad h[4] = 0.2, \quad h[5] = 0.1.
$$

**(1)** $$h[k] = h[5-k]$$ 대칭성을 이용하여, 곱셈기 수를 최소화하는 구조에서의 출력식을 유도하라.

**(2)** Direct Form 구현과 대칭성을 이용한 구현 각각에 대해,
동일한 입력에 대해 연산 횟수(곱셈, 덧셈)를 비교하라.

**(3)** GNU Octave로 두 구조를 각각 구현하고, 임펄스 응답과 주파수 응답이 동일함을 확인하라.

#### 힌트

- 대칭 FIR 출력:

  $$
  y[n] = h[0](x[n] + x[n-5]) + h[1](x[n-1] + x[n-4]) + h[2](x[n-2] + x[n-3]).
  $$

- 곱셈기 3개, 덧셈은 5개(입력 쌍 더하기 3개 + 결과 합치기 2개 정도).

#### 참고 Octave 코드

```octave
clear; clc;

h = [0.1 0.2 0.3 0.3 0.2 0.1];
N = 100;
x = randn(1, N);

% Direct Form (conv)
y1 = conv(x, h, 'same');

% 대칭성 이용 구현
L = length(h);
M = L - 1;
x_delay = zeros(1, M);
y2 = zeros(1, N);

for n = 1:N
  taps = [x(n) x_delay];
  % y[n] = h0(x0+x5) + h1(x1+x4) + h2(x2+x3)
  s0 = taps(1) + taps(6);
  s1 = taps(2) + taps(5);
  s2 = taps(3) + taps(4);
  y2(n) = h(1)*s0 + h(2)*s1 + h(3)*s2;

  if M > 0
    x_delay(2:end) = x_delay(1:end-1);
    x_delay(1) = x(n);
  end
end

printf("max|y1 - y2| = %.3e\n", max(abs(y1 - y2)));
```

---

### 문제 3-3: Polyphase 구조와 다운샘플링 효율 비교

다운샘플링 비율이 3인 FIR 필터를 생각하자.

$$
H(z) = \sum_{k=0}^{8} h_k z^{-k}
$$

계수가 다음과 같다고 하자.

$$
h = [1, 2, 3, 4, 5, 4, 3, 2, 1] / 25.
$$

**(1)** Polyphase 분해를 수행하여,

- $$E_0(z)$$: $$h_0, h_3, h_6$$
- $$E_1(z)$$: $$h_1, h_4, h_7$$
- $$E_2(z)$$: $$h_2, h_5, h_8$$

를 정의하고, 각 $$E_i(z)$$ 의 계수를 명시하라.

**(2)** (a) 먼저 입력을 FIR 필터에 통과시키고, 그 결과를 3배 다운샘플하는 naive 구조와,
(b) Polyphase 구조를 사용하여 연산량을 줄인 구조를 비교하라.
각각의 **평균 곱셈 횟수(샘플당)** 을 계산하라.

**(3)** GNU Octave로 두 방식을 구현하고, 동일 입력에서 다운샘플된 출력이 동일함을 수치적으로 검증하라.

#### 참고 Octave 코드 스케치

```octave
clear; clc;

h = [1 2 3 4 5 4 3 2 1]/25;
L = 3;   % 다운샘플 비율

% Polyphase 계수
E0 = h(1:3:end);  % h0, h3, h6
E1 = h(2:3:end);  % h1, h4, h7
E2 = h(3:3:end);  % h2, h5, h8

% 입력 신호
N = 1000;
x = randn(1, N);

% (a) Naive
y_full = conv(x, h);
y_naive = y_full(1:L:end);

% (b) Polyphase 구현
% (가장 단순한 구현: 각 위상에 대해 부분 필터 계산 후 적절히 샘플 선택)
% 직접 구현해 보라.
```

---

## 격자(Lattice) 필터 구조 — FIR Lattice–Ladder

### 문제 4-1: 2단 FIR 격자–사다리 vs Direct Form 동치성

2단 FIR 격자–사다리 구조가 다음 계수를 가진다고 하자.

- 반사계수(reflection coefficients):

  $$
  k_1 = 0.4, \quad k_2 = -0.3
  $$

- 사다리(ladder) 계수:

  $$
  v_0 = 0.5, \quad v_1 = 0.3, \quad v_2 = -0.2
  $$

격자-사다리 구조의 출력은

$$
y[n] = v_0 f_0[n] + v_1 f_1[n] + v_2 f_2[n]
$$

라고 하자. 여기서 $$f_0[n] = x[n]$$, 각 스테이지에서

$$
f_m[n] = f_{m-1}[n] - k_m b_{m-1}[n-1]
$$

$$
b_m[n] = b_{m-1}[n-1] - k_m f_{m-1}[n]
$$

로 정의한다고 하자(한 가지 표준 형태).

**(1)** 이 구조에 해당하는 Direct Form FIR 필터의 임펄스 응답 $$h[0], h[1], h[2]$$ 를 유도하라.

**(2)** GNU Octave로 격자–사다리 구조를 직접 구현한 함수와,
Direct Form FIR 필터를 `conv`로 구현한 경우의 출력을 비교하라.

**(3)** 반사계수 $$|k_m| < 1$$ 조건이 왜 구조의 안정성에 중요한지 설명하라.

#### 참고 Octave 코드(격자–사다리 구현 예)

```octave
function y = fir_lattice_ladder_2(k, v, x)
  % k: [k1 k2], v: [v0 v1 v2]
  N = length(x);
  y = zeros(1, N);

  % backward 신호의 지연 상태
  b0_prev = 0;
  b1_prev = 0;

  for n = 1:N
    f0 = x(n);
    b0 = b0_prev;

    % stage 1
    f1 = f0 - k(1) * b0;
    b1 = b0 - k(1) * f0;

    % stage 2 (b1_prev 사용)
    f2 = f1 - k(2) * b1_prev;
    b2 = b1_prev - k(2) * f1;

    % ladder 합성
    y(n) = v(1)*f0 + v(2)*f1 + v(3)*f2;

    % 상태 업데이트
    b0_prev = b0;
    b1_prev = b1;
  end
end

% 테스트
clear; clc;
k = [0.4 -0.3];
v = [0.5 0.3 -0.2];

N = 32;
x = [1 zeros(1, N-1)];   % 임펄스
y_lattice = fir_lattice_ladder_2(k, v, x);

% 이제 y_lattice = h[n] 임을 이용해 Direct Form FIR 설계
h = y_lattice(1:3);   % 2단이면 길이 3까지 유효
y_direct = conv(x, h);

printf("max|y_lattice - y_direct| = %.3e\n", max(abs(y_lattice - y_direct)));
```

---

### 문제 4-2: LPC(Linear Prediction)와 격자 계수

주어진 자기상관 계열 $$r[0], \dots, r[4]$$ 에 대해 4차 LPC를 구한다고 하자.

$$
r[0] = 1, \quad r[1] = 0.8, \quad r[2] = 0.5, \quad r[3] = 0.2, \quad r[4] = 0.1.
$$

**(1)** Levinson–Durbin 알고리즘을 사용하여 LPC 계수 $$a_1,\dots,a_4$$ 과
반사계수(=격자 반사계수) $$k_1,\dots,k_4$$ 를 구하라.

**(2)** GNU Octave에서 `levinson` 함수를 사용하여 위 결과를 확인하고,
반사계수의 크기 $$|k_m|$$ 을 출력하라.

**(3)** 왜 LPC 반사계수가 격자 구조에서 직접 사용될 수 있는지,
그리고 $$|k_m| < 1$$ 이면 왜 안정성이 보장되는지 설명하라.

#### 참고 Octave 코드

```octave
clear; clc;

r = [1 0.8 0.5 0.2 0.1];
% levinson(R, n): R는 자기상관 계열, n차까지
[a, e, k] = levinson(r, 4);

disp("LPC 계수 a (a(1)=1):");
disp(a);
disp("반사계수 k:");
disp(k);
disp("|k|:");
disp(abs(k));
```

---

## 유한 정밀도 수치 영향 & 수의 표현 — 고정소수점

### 문제 5-1: 2의 보수 고정소수점 표현과 오버플로

16비트 2의 보수 고정소수점 형식에서,
정수부 1비트, 소수부 14비트를 사용하는 형식을 생각하자 (총 16비트, 부호 1비트 포함).

**(1)** 이 형식에서 표현 가능한 최소/최대 실수 값을 계산하라.

**(2)** $$x = 0.75$$ 와 $$y = 0.5$$ 를 이 형식으로 양자화한 뒤,
고정소수점 덧셈을 수행하면 내부 이진 표현과 결과 실수 값은 어떻게 되는가?

**(3)** $$x = 0.75$$ 와 $$y = 0.75$$ 를 더할 때,
오버플로는 발생하는가? 래핑(wrap-around)과 포화(saturation) 정책이 각각
어떤 결과를 주는지 설명하라.

#### 힌트

- 정수 표현 범위:
  최소값: $$-2^{15}$$, 최대값: $$2^{15}-1$$.
  하지만 정수부/소수부 해석에 따라 최대 실수는

  $$
  x_{\max} \approx (2^{15}-1)/2^{14}.
  $$

- 고정소수점 덧셈: 실수값을 $$2^{14}$$ 로 곱해 정수로 만들고,
  정수 덧셈 후 다시 $$2^{14}$$ 로 나눠 실수로 복원.

#### 참고 Octave 코드

```octave
function q = fxp_quant(x, nfrac)
  q = round(x * 2^nfrac);
end

function x = fxp_dequant(q, nfrac)
  x = q / 2^nfrac;
end

clear; clc;

nfrac = 14;
x = 0.75;
y = 0.5;

qx = fxp_quant(x, nfrac);
qy = fxp_quant(y, nfrac);

qsum = qx + qy;
xsum = fxp_dequant(qsum, nfrac);

fprintf("x=%.4f -> qx=%d\n", x, qx);
fprintf("y=%.4f -> qy=%d\n", y, qy);
fprintf("qsum=%d -> xsum=%.6f\n", qsum, xsum);
```

---

### 문제 5-2: 고정소수점 FIR 필터 구현

3탭 FIR 필터

$$
y[n] = 0.25 x[n] + 0.5 x[n-1] + 0.25 x[n-2]
$$

를 16비트 고정소수점(소수부 14비트)으로 구현한다고 하자.

**(1)** 계수 $$0.25, 0.5, 0.25$$ 를 고정소수점으로 양자화한 정수값을 구하라.

**(2)** GNU Octave에서 **고정소수점 FIR 필터**를 다음 규칙으로 구현하라.

- 입력 신호도 소수부 14비트 고정소수점으로 양자화
- 내부 곱셈 결과는 32비트 정수로 유지 (오버플로 방지 가정)
- 최종 출력에서 다시 소수부 14비트로 스케일

**(3)** 동일한 필터를 배정밀도(double)로 구현한 결과와 비교하여,
최대 오차를 측정하라.

#### 참고 Octave 코드 스케치

```octave
clear; clc;

nfrac = 14;
h = [0.25 0.5 0.25];
hq = round(h * 2^nfrac);   % 정수 계수

N = 1000;
x = randn(1, N);
xq = round(x * 2^nfrac);   % 입력도 고정소수점

% 고정소수점 FIR
M = length(hq)-1;
x_delay = zeros(1, M);
yq = zeros(1, N);

for n = 1:N
  xtaps = [xq(n) x_delay];
  acc = int64(0);
  for k = 1:length(hq)
    acc = acc + int64(hq(k)) * int64(xtaps(k));   % 32비트 누산
  end
  % acc는 2*nfrac 배 스케일 -> 다시 nfrac으로 줄인다
  yq(n) = bitshift(acc, -nfrac);  % 또는 round(double(acc)/2^nfrac)
  if M > 0
    x_delay(2:end) = x_delay(1:end-1);
    x_delay(1) = xq(n);
  end
end

y_fixed = double(yq) / 2^nfrac;
y_float = filter(h, 1, x);

fprintf("max|y_fixed - y_float| = %.3e\n", max(abs(y_fixed - y_float)));
```

---

## 양자화 과정과 오차 특성 — SNR, 디더, 컴팬딩

이 부분은 이미 자세히 다루었으므로, **연습 문제 중심**으로 정리한다.

### 문제 6-1: 비트 수 vs SNR 곡선 그리기

**(1)** 다음 비트 수에 대해

$$
B \in \{4, 6, 8, 10, 12, 14, 16\}
$$

각각에 대해 이론 SNR

$$
\mathrm{SNR}_{\text{theory}} = 6.02B + 1.76
$$

을 계산하라.

**(2)** 각 비트 수에 대해 풀스케일에 가까운 사인파를 생성하고,
GNU Octave에서 양자화 후 SNR을 측정하여
그래프 $$\mathrm{SNR}_{\text{meas}}(B)$$ 를 그려라.

**(3)** 이론값과 측정값을 같은 그림에 표시하고,
차이가 나는 이유(사인파 peak vs RMS, 과부하 유무, 사인파 주파수 선택, finite length 등)를 설명하라.

#### 참고 Octave 코드 스케치

```octave
clear; clc;

Fs = 48000;
N  = 48000;
n  = 0:N-1;
t  = n / Fs;

B_list = 4:2:16;
SNR_meas = zeros(size(B_list));
SNR_theo = 6.02 * B_list + 1.76;
Xmax = 1;

for i = 1:length(B_list)
  B = B_list(i);
  Delta = 2*Xmax / (2^B);

  f0 = 997;  % 비정합 주파수
  x = 0.999*Xmax * sin(2*pi*f0*t);

  y = q_uniform_mid_tread(x, Delta);
  e = y - x;

  Ps = mean(x.^2);
  Pe = mean(e.^2);

  SNR_meas(i) = 10*log10(Ps/Pe);
end

plot(B_list, SNR_meas, 'o-', B_list, SNR_theo, 'x--');
xlabel('비트 수 B'); ylabel('SNR [dB]');
legend('Measured', 'Theoretical');
grid on;
```

---

### 문제 6-2: 미드트레드 vs 미드라이즈 작은 DC 바이어스

**(1)** 양자화 스텝 $$\Delta = 1/64$$ 에 대해, 작은 DC 값 $$dc = 0.2\Delta$$ 를 선택하라.

**(2)** 노이즈가 약간 섞인 입력

$$
x[n] = dc + \epsilon[n],
$$

여기서 $$\epsilon[n]$$ 은 매우 작은 백색 잡음이라고 할 때,
미드트레드/미드라이즈 양자화기를 통과시켜 평균 바이어스를 비교하라.

**(3)** 어떤 상황에서 미드트레드가, 어떤 상황에서 미드라이즈가 더 적절한지 논하라
(예: 센서 오프셋, 오디오 DC 제거 등).

#### 참고 Octave 코드

```octave
clear; clc;

Delta = 1/64;
dc = 0.2 * Delta;
N  = 200000;

x = dc + 1e-6 * randn(1, N);

ymt = q_uniform_mid_tread(x, Delta);
ymr = q_uniform_mid_rise(x, Delta);

fprintf("mean bias mid-tread = %.3e\n", mean(ymt - x));
fprintf("mean bias mid-rise  = %.3e\n", mean(ymr - x));
```

---

### 문제 6-3: 디더 스케일 변경에 따른 왜곡/잡음 트레이드오프

**(1)** TPDF 디더를

$$
d_k = d_{1,k} + d_{2,k}, \quad d_{1,k}, d_{2,k} \sim \mathcal{U}\left(-\frac{k\Delta}{2}, \frac{k\Delta}{2}\right)
$$

형태로 정의하고, $$k \in \{0.5, 1, 2\}$$ 에 대해 각각 감산형 디더를 적용하라.

**(2)** 각 경우에 대해,

- 양자화 오차 분산 $$\sigma_e^2$$
- 입력과 오차의 상관계수 $$\mathrm{corr}(x,e)$$

를 측정하고, $$k$$ 가 커질수록 어떻게 변하는지 분석하라.

**(3)** 각 경우에 대해 오차 스펙트럼을 그려,
왜곡 스파이크가 어떻게 변화하는지 비교하라.

---

## 필터 계수의 양자화 — IIR/FIR 비교, SOS 구조

### 문제 7-1: IIR vs FIR 계수 양자화 감도 비교

다음 두 필터를 고려하자.

1. 8차 IIR 저역통과 (예: Chebyshev I형, 통과대역 리플 1 dB, 저지대역 감쇠 60 dB)
2. 63차 선형 위상 FIR 저역통과 (동일 컷오프 주파수, 대략 비슷한 스펙)

**(1)** GNU Octave에서 `cheby1`, `fir1` 등을 사용해 두 필터를 설계하고,
각각의 주파수 응답을 비교하라.

**(2)** 계수들을 각각 fractional bits $$n_{\text{frac}} = 10, 12, 14$$ 로 양자화했을 때,
주파수 응답에서의 최대 편차

$$
\max_\omega \bigl| |H(e^{j\omega})| - |H_q(e^{j\omega})| \bigr|
$$

를 측정하라.

**(3)** IIR 필터의 극점 위치가 양자화 후 어떻게 이동하는지,
특히 반지름이 1에 가까운 극점이 어떻게 되는지 확인하라.

**(4)** 왜 IIR이 FIR보다 계수 양자화에 더 민감하게 반응하는지,
수학적/직관적 이유를 설명하라.

#### 참고 Octave 코드 스케치

```octave
clear; clc; pkg load signal;

Fs = 48000;

% (1) IIR (Chebyshev)
[niir, Wniir] = cheb1ord(0.2, 0.3, 1, 60);
[biir, aiir]  = cheby1(niir, 1, Wniir);

% (2) FIR
Nfir = 63;
bfir = fir1(Nfir, 0.25, hamming(Nfir+1));
afir = 1;

[Hiir, w] = freqz(biir, aiir, 4096);
[Hfir, ~] = freqz(bfir, afir, 4096);

% 양자화 함수
fxp = @(c, nfrac) round(c * 2^nfrac) / 2^nfrac;

for nfrac = [10 12 14]
  biir_q = fxp(biir, nfrac);
  aiir_q = fxp(aiir, nfrac);
  [Hiir_q, ~] = freqz(biir_q, aiir_q, 4096);

  bfir_q = fxp(bfir, nfrac);
  [Hfir_q, ~] = freqz(bfir_q, afir, 4096);

  err_iir = max(abs(abs(Hiir) - abs(Hiir_q)));
  err_fir = max(abs(abs(Hfir) - abs(Hfir_q)));

  fprintf("nfrac=%d: IIR err=%.3e, FIR err=%.3e\n", nfrac, err_iir, err_fir);
end

% 극점 이동
piir  = roots(aiir);
piir_q = roots(aiir_q);
disp('Original pole radii:'); disp(abs(piir));
disp('Quantized pole radii:'); disp(abs(piir_q));
```

---

### 구조에서 계수 양자화

문제 7-1의 IIR 필터에 대해,
이번에는 다음 순서로 진행하라.

**(1)** `tf2sos` 또는 `zp2sos` 형태(Octave에서는 `zp2sos` 사용 가능)를 통해,
필터를 2차 섹션(SOS) 캐스케이드로 분해하라.

**(2)** 각 섹션의 계수를 fractional bits $$n_{\text{frac}} = 12$$ 로 양자화한 뒤,
각 섹션을 순차적으로 `filter`로 적용하여 전체 응답을 구하라.

**(3)** Direct Form II 단일 섹션을 사용하여 모든 계수를 한 번에 양자화했을 때와 비교하여,
주파수 응답 왜곡, 극점 위치 변화, 오버플로 위험 등에서 차이를 분석하라.

#### 참고 Octave 코드 스케치

```octave
% IIR 설계는 문제 7-1과 동일
[z, p, k] = tf2zp(biir, aiir);   % 또는 직접 roots 이용 후 zpk
sos = zp2sos(z, p, k);           % [b0 b1 b2 a0 a1 a2] 행렬

nfrac = 12;
sos_q = sos;
for i = 1:size(sos,1)
  sos_q(i,:) = round(sos(i,:) * 2^nfrac) / 2^nfrac;
end

% 캐스케이드 적용
N = 4096;
x = [1 zeros(1, N-1)];  % 임펄스 응답 보기 위해
y = x;
for i = 1:size(sos_q,1)
  b_s = sos_q(i,1:3);
  a_s = sos_q(i,4:6);
  y = filter(b_s, a_s, y);
end
% y는 양자화된 SOS 구조 임펄스 응답
```

---

## 종합 프로젝트형 연습 문제

### 문제 8-1: 고정소수점 오디오 체인 설계

다음과 같은 **간단한 오디오 처리 체인**을 설계하고 시뮬레이션하라.

1. 입력: 16-bit PCM, 샘플링 주파수 $$F_s = 48000\ \mathrm{Hz}$$ 라고 가정
2. 체인:
   - (a) 2차 IIR 저역통과(예: 컷오프 8 kHz, 집적형 바이쿼드)
   - (b) 5탭 선형 위상 FIR(미세한 고역 보정용)
   - (c) 최종 출력에서 다시 16-bit로 양자화 (디더 옵션 on/off)

**요구사항**

**(1)** 전체 체인의 전송함수(주파수 응답)를 double 정밀도에서 먼저 설계하고 플롯하라.

**(2)** 각 단계의 필터 계수와 내부 상태를 고정소수점(예: 16-bit, fractional bits 14)으로 구현하고,
내부에서 포화(saturation) 정책을 적용하는 버전과, 래핑(wrap-around) 버전을 각각 구현하라.

**(3)** 테스트 입력으로
- 단일 톤 (1 kHz, -3 dBFS)
- 다중 톤 (1 kHz + 3 kHz + 7 kHz)
- 백색 잡음 (대역 제한)

을 사용하고, 각 경우에 대해 THD+N 또는 SNR을 측정하라.

**(4)** 디더(감산형 TPDF)를 사용할 때와 사용하지 않을 때의 스펙트럼을 비교하여,
왜곡 스파이크/잡음 플로어 관점에서 어떤 차이가 나는지 분석하라.

#### 참고 구조 코드 스케치

```octave
clear; clc; pkg load signal;

Fs = 48000;
N  = 48000;
n  = 0:N-1;
t  = n / Fs;

% (1) Double 정밀도 필터 설계
% (a) 2차 IIR LPF 예: butter
[biir, aiir] = butter(2, 8000/(Fs/2));   % 약 컷오프 8kHz
% (b) 5탭 FIR 예: 약간의 고역 부스트/평활
bfir = [ -0.1 0.3 0.6 0.3 -0.1 ];
afir = 1;

% 테스트 신호: 다중 톤
x = 0.5*(sin(2*pi*1000*t) + 0.3*sin(2*pi*3000*t) + 0.2*sin(2*pi*7000*t));

% double 정밀도 체인
y_double = filter(biir, aiir, x);
y_double = filter(bfir, afir, y_double);

% (2) 고정소수점 계수/신호로 동일 체인 구성
nfrac = 14;
% ... 여기서 biir, aiir, bfir를 정수 계수로 양자화하고
%     고정소수점 필터 함수를 만든 뒤 적용한다.
%     (앞에서 만든 fxp_quant, fxp_dequant, fxp FIR/IIR 함수를 재사용 가능)
```

---

## 마무리

이 연습 세트는 다음 전체 흐름을 **문제/코드 중심**으로 다시 훑도록 설계되어 있다.

1. **기본 소자**
   - 지연, 곱셈, 가산기, 피드백/피드포워드를 조합하여 차분방정식과 전송함수 유도
2. **IIR 필터 구조**
   - Direct Form I/II/II-Transposed, 캐스케이드 구조, 극점 안정성
3. **FIR 필터 구조**
   - Direct/Transposed, 선형 위상, Polyphase, 다중레이트 처리
4. **격자 필터 구조**
   - Forward/Backward 신호, 반사계수, FIR lattice–ladder, LPC와의 연결
5. **유한 정밀도 수치 영향**
   - 고정소수점 표현, 오버플로, 포화 vs 래핑, 숫자 범위/해상도
6. **양자화 과정과 오차 특성**
   - SNR 공식 $$6.02B+1.76$$, 양자화 잡음 모델, 디더, 컴팬딩, 노이즈 셰이핑
7. **필터 계수의 양자화**
   - FIR vs IIR 감도 비교, SOS 구조, 극점 이동 분석
8. **종합 프로젝트**
   - 실제 오디오 체인을 가정한 end-to-end 고정소수점 설계와 검증

각 문제의 GNU Octave 스케치 코드는 **직접 손으로 완성하고, 수치 결과/그래프를 확인**하면서
자신만의 블로그 포스팅/노트로 옮겨 적는 것을 전제로 했다.

이제 이 연습들을 하나씩 실제로 실행해 보면서:

- *“어디서 수치적인 문제가 생기는지”*
- *“어떤 구조가 어떤 상황에서 더 유리한지”*
- *“양자화/고정소수점/계수 정밀도/구조 선택이 최종 신호 품질에 어떻게 연결되는지”*
