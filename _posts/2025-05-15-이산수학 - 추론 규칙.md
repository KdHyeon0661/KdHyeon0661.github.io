---
layout: post
title: 이산수학 - 추론 규칙
date: 2025-05-15 19:20:23 +0900
category: 이산수학
---
# 추론 규칙(Rules of Inference)

## 핵심 개념

- 전제(premise): 이미 참으로 받아들이는 문장.
- 결론(conclusion): 전제로부터 논리적으로 도출되는 문장.
- 타당성(validity): 어떤 **스키마**가 전제를 모두 참으로 만들면 결론도 반드시 참이 되는 성질.

형식화:
- 명제 논리 기호: $$\lnot, \land, \lor, \to, \leftrightarrow$$
- 스키마 판정: 진리표(유한 변수), 의미론적 항진성, 혹은 증명 시스템(자연 연역, 힐베르트 체계)에서의 유도.

---

## 명제 논리의 기본 추론 규칙

아래는 자연 연역 스타일로 자주 쓰는 규칙들이다. 각 규칙은 **항진적**(sound)이다.

### 조건과 결론

- Modus Ponens (MP)
  $$
  p\to q,\ \ p\ \ \vdash\ \ q
  $$

- Modus Tollens (MT)
  $$
  p\to q,\ \ \lnot q\ \ \vdash\ \ \lnot p
  $$

- Hypothetical Syllogism (HS)
  $$
  p\to q,\ \ q\to r\ \ \vdash\ \ p\to r
  $$

- Contraposition (대우 교환)
  $$
  p\to q\ \ \vdash\ \ \lnot q\to \lnot p
  $$
  (혹은 동치 $$p\to q \equiv \lnot q\to \lnot p$$ 를 **치환 규칙**으로 사용)

### 분리와 결합

- Simplification (간단화)
  $$
  p\land q\ \ \vdash\ \ p \quad(\text{또는 } q)
  $$

- Conjunction (결합)
  $$
  p,\ q\ \ \vdash\ \ p\land q
  $$

- Addition (첨가)
  $$
  p\ \ \vdash\ \ p\lor q
  $$

- Disjunctive Syllogism (선택 제거)
  $$
  p\lor q,\ \ \lnot p\ \ \vdash\ \ q
  $$

- Absorption (흡수)
  $$
  p\to q\ \ \vdash\ \ p\to (p\land q)
  $$

- Exportation/Importation (조건의 결합 분해)
  $$
  (p\land q)\to r\ \ \equiv\ \ p\to (q\to r)
  $$

### 딜레마와 케이스 분석

- Constructive Dilemma
  $$
  (p\to r)\land (q\to s),\ \ p\lor q\ \ \vdash\ \ r\lor s
  $$

- Destructive Dilemma
  $$
  (p\to r)\land (q\to s),\ \ \lnot r\lor \lnot s\ \ \vdash\ \ \lnot p\lor \lnot q
  $$

- Proof by Cases (분할 증명)
  $$
  p\lor q,\ \ p\to r,\ \ q\to r\ \ \vdash\ \ r
  $$

### 간접 증명 스키마

- Reductio ad Absurdum (모순 유도)
  $$
  \text{가정 } \lnot p \vdash \bot \ \Rightarrow\ p
  $$

- Conditional Proof (조건 도입)
  $$
  \text{가정 } p \vdash q \ \Rightarrow\ p\to q
  $$

여기서 $$\bot$$ 은 모순을 뜻한다.

---

## 해석 규칙(치환 규칙, 동치 규칙)

전개 시 **동치 변환**을 사용해 식을 바꾸는 규칙들이다(결론을 바로 만드는 규칙이 아니라, **형태를 바꾸는 도구**).

- 드모르간
  $$
  \lnot(p\land q)\equiv \lnot p\lor \lnot q,\quad
  \lnot(p\lor q)\equiv \lnot p\land \lnot q
  $$

- 함의 제거
  $$
  p\to q \equiv \lnot p\lor q
  $$

- 쌍방향
  $$
  p\leftrightarrow q \equiv (p\to q)\land(q\to p)
  $$

- 이중부정
  $$
  \lnot\lnot p \equiv p
  $$

- 분배, 결합, 교환, 항등, 흡수 등 집합 대수와 유사한 기본 등식들.

동치 규칙은 **치환**으로 사용 가능하다. 즉, 증명 중 임의의 부분식을 동치식으로 바꿔도 전체 진리값은 유지된다.

---

## 해석 기반 증명 예시

목표: $$(p\to r)\land(q\to r),\ p\lor q \vdash r$$

증명(자연 연역 스케치):
1) $$(p\to r)\land(q\to r)$$  (전제)
2) $$p\to r$$, $$q\to r$$ (1에서 간단화 2회)
3) $$p\lor q$$ (전제)
4) 가정 $$p$$. 2로부터 $$r$$ (MP)
5) 가정 $$q$$. 2로부터 $$r$$ (MP)
6) 3,4,5에서 케이스 분석으로 $$r$$.

---

## 유효한 추론 vs 전형적 오류

- 유효
  - Modus Ponens: $$p\to q,\ p\ \vdash\ q$$
  - Modus Tollens: $$p\to q,\ \lnot q\ \vdash\ \lnot p$$

- 오류
  - Affirming the Consequent(역의 오류): $$p\to q,\ q \vdash p$$ (일반적으로 거짓)
  - Denying the Antecedent(전건 부정 오류): $$p\to q,\ \lnot p \vdash \lnot q$$ (일반적으로 거짓)
  - Equivocation(동음이의 전이), Begging the question(순환논법) 등

간단 반례:
- $$p\to q$$ 를 “비면 젖는다”, $$q$$ 를 “젖었다”로 해석하면, 젖었지만 다른 이유(물놀이)일 수도 있다.

---

## 해 해결법(Resolution)과 CNF

해결법은 **절(clause) 형태**에서만 쓰는 강력한 규칙이다.
절은 리터럴들의 합(OR), 전체는 곱(AND)인 **CNF** 로 정규화한다.

규칙:
$$
(p\lor A),\ (\lnot p\lor B)\ \ \vdash\ \ A\lor B
$$
여기서 $$A,B$$ 는 (가능한 비어있을 수도 있는) 또 다른 리터럴들의 OR.

예:
- $$(p\lor q),\ (\lnot p\lor r)\ \vdash\ q\lor r$$

SAT/자동 증명기에서 핵심 역할을 한다.

---

## 1차 술어 논리의 양화사 규칙

도메인 $$D$$ 에 대해, 변수의 **자유/결합**과 **스코프**를 엄격히 지켜야 한다.

- Universal Instantiation (UI)
  $$
  \forall x\,\varphi(x)\ \ \vdash\ \ \varphi(t)
  $$
  단, $$t$$ 가 치환에 적합해야 함(자유 변수 포획 주의).

- Universal Generalization (UG)
  $$
  \varphi(x) \ \text{에서}\ x \ \text{가 임의적일 때}\ \ \vdash\ \ \forall x\,\varphi(x)
  $$

- Existential Instantiation (EI)
  $$
  \exists x\,\varphi(x)\ \ \vdash\ \ \varphi(c)
  $$
  단, $$c$$ 는 새 상수(스코프 밖 영향 금지). 이후 결론에서 $$c$$ 가 남지 않도록 조심.

- Existential Generalization (EG)
  $$
  \varphi(t)\ \ \vdash\ \ \exists x\,\varphi(x)
  $$

- 명제 규칙과의 결합
  - 예: $$\forall x (P(x)\to Q(x))$$ 와 $$P(a)$$ 로부터 $$Q(a)$$ (UI+MP)

양화사 부정 이동(드모르간-양화사판):
$$
\lnot \forall x\,\varphi \equiv \exists x\,\lnot\varphi,\quad
\lnot \exists x\,\varphi \equiv \forall x\,\lnot\varphi
$$

---

## 형식 예제: 간단한 1차 논리 유도

전제:
1) $$\forall x\,(\mathrm{Student}(x)\to \mathrm{Studies}(x))$$
2) $$\mathrm{Student}(a)$$

결론: $$\mathrm{Studies}(a)$$

증명:
- 1에서 UI로 $$\mathrm{Student}(a)\to \mathrm{Studies}(a)$$
- 2와 MP로 $$\mathrm{Studies}(a)$$

---

## 진리표로 규칙 확인(명제 수준)

Modus Ponens의 타당성은 함의 제거 $$p\to q \equiv \lnot p\lor q$$ 를 쓰면,
$$(\lnot p\lor q)\land p\ \Rightarrow\ q$$
가 항상 참임을 4행 진리표로 곧바로 확인 가능하다.

진리표 스케치:

| p | q | p→q | (p→q)∧p | q |
|---|---|-----|---------|---|
| T | T |  T  |    T    | T |
| T | F |  F  |    F    | F |
| F | T |  T  |    F    | T |
| F | F |  T  |    F    | F |

결정적 행은 (p→q)∧p 가 T 일 때뿐이며, 그때 q 는 반드시 T.

---

## 파이썬으로 스키마 자동 점검(명제)

경고: 이는 유한 변수에 대한 **의미론적 검사**일 뿐, 형식 증명을 대체하지 않는다.

```python
import itertools

# 진리함수 정의

def implies(p, q): return (not p) or q
def equiv(p, q): return (p and q) or ((not p) and (not q))

def modus_ponens_holds():
    # p, q 모든 경우에 대해 (p->q) and p => q 가 항상 True 인지 검사
    for p, q in itertools.product([False, True], repeat=2):
        prem = implies(p, q) and p
        if prem and not q:
            return False
    return True

def modus_tollens_holds():
    for p, q in itertools.product([False, True], repeat=2):
        prem = implies(p, q) and (not q)
        if prem and p:  # 결론 ¬p 가 거짓이면 실패
            return False
    return True

def hs_holds():
    # (p->q) and (q->r) => (p->r)
    for p, q, r in itertools.product([False, True], repeat=3):
        prem = implies(p, q) and implies(q, r)
        concl = implies(p, r)
        if prem and not concl:
            return False
    return True

print("MP:", modus_ponens_holds())
print("MT:", modus_tollens_holds())
print("HS:", hs_holds())
```

해결법(Resolution) 검증용 간단 유틸(작은 절 집합 전용):

```python
def resolve(C1, C2):
    # C1, C2는 리터럴의 frozenset, 리터럴은 문자열 혹은 ('~', sym) 튜플 등으로 표준화 가능
    resolvents = []
    for l in C1:
        neg = ('~', l) if not (isinstance(l, tuple) and l[0]=='~') else l[1]
        if neg in C2:
            resolvents.append((C1 - {l}) | (C2 - {neg}))
    return resolvents

# 예: (p ∨ q), (¬p ∨ r) => (q ∨ r)

p, q, r = 'p', 'q', 'r'
C1 = frozenset({p, q})
C2 = frozenset({('~', p), r})
print(resolve(C1, C2))  # [{q, r}]
```

---

## 증명 전략 체크리스트

1) 목표가 조건문이면 **조건도입**을 고려하라.
2) 모순을 빠르게 찾을 수 있으면 **모순 유도**를 시도하라.
3) 분기 전개가 명확하면 **케이스 분석**으로 나눠라.
4) 술어 논리에서는 먼저 **UI/EG** 로 구체 항을 확보하라.
5) 복잡한 부정은 **드모르간**으로 정규화하라.
6) CNF로 바꿔 **해결법**을 적용할 수 있는지 보라.
7) 증명 중간에는 **치환 규칙(동치들)** 로 식을 단순화하라.

---

## 소리성과 완전성(개요)

- 소리성(soundness): 증명 가능한 것은 모두 의미론적으로 참.
- 완전성(completeness): 의미론적으로 참인 것은 모두 증명 가능.
명제 논리, 1차 논리는 표준 체계에서 두 성질을 만족한다(고전 결과).

---

## 연습문제(해설 또는 힌트 포함)

1) 다음을 자연 연역으로 증명하라.
   a) $$p\land(q\lor r) \vdash (p\land q)\lor(p\land r)$$ (분배)
   힌트: 케이스 분석.

2) $$p\lor q,\ \lnot p \vdash q$$ 를 증명하라.
   해설: Disjunctive Syllogism.

3) $$\forall x(P(x)\to Q(x)),\ \exists x P(x) \vdash \exists x Q(x)$$
   힌트: EI 로 새 상수 $$c$$ 를 도입 후, UI 와 MP 를 적용, 마지막에 EG.

4) 해결법: $$(p\lor q),\ (\lnot p\lor r),\ (\lnot q\lor \lnot r) \vdash \bot$$
   힌트: 앞 둘을 해 해법으로 결합해 $$q\lor r$$, 이를 세 번째와 결합.

5) 오류 구별: 다음이 왜 타당하지 않은가 설명하라.
   $$p\to q,\ q \vdash p$$

---

## 마무리

- 추론 규칙은 **타당성 보장 장치**다.
- 명제 규칙(MP, MT, HS, DS, CP, RAA 등)과 1차 규칙(UI, UG, EI, EG)을 유연하게 결합하라.
- 치환 규칙(드모르간, 함의 제거, 분배 등)으로 식을 작업 가능한 형태로 만든다.
- 해 해결법과 CNF는 자동화의 핵심 통로다.
- 작은 사례는 진리표·파이썬으로 감각을 점검하고, 글에는 간결하고 명확한 유도를 남겨라.
