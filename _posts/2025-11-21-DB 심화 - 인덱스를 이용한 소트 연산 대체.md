---
layout: post
title: DB 심화 - 인덱스를 이용한 소트 연산 대체
date: 2025-11-21 23:25:23 +0900
category: DB 심화
---
# 인덱스를 이용한 소트 연산 대체

## SORT ORDER BY / SORT GROUP BY를 제거하는 설계 방법과 주의사항

## 소트 제거의 필요성

대규모 데이터 처리에서 `SORT ORDER BY`와 `SORT GROUP BY` 연산은 항상 성능 위험 요소로 작용합니다. 메모리 내에서 수행될 때는 비교적 빠르지만, 데이터량이 증가하거나 병렬 처리가 적용되면 여러 문제가 발생합니다.

**주요 문제점**:
- **워크에어리어 스필**: PGA 메모리를 초과하면 TEMP 디스크로 데이터가 흘러넘치며 `direct path write/read temp` 대기 이벤트 증가
- **병렬 처리 부담**: PX SEND/RECEIVE 오퍼레이션과 함께 글로벌 소트 발생으로 네트워크 및 TEMP 부하 증대
- **확장성 한계**: 데이터 증가에 따른 성능 저하가 선형이 아닌 지수적으로 발생

이러한 이유로 소트 연산을 최적화하는 가장 효과적인 전략은 간단명료합니다: **정렬이 필요한 결과라면, 처음부터 정렬된 순서로 데이터를 읽어오는 것**입니다. B-Tree 인덱스는 키 순서로 데이터를 저장하고 유지하기 때문에, 옵티마이저가 이 자연 정렬 순서를 활용하도록 설계하면 소트 연산을 완전히 제거할 수 있습니다.

---

## 기본 원리: 인덱스로 정렬을 대체하는 조건

### ORDER BY 대체의 충분 조건

소트 연산을 인덱스로 대체하려면 다음 조건을 모두 만족해야 합니다:

1. **순서 일치**: ORDER BY 절의 컬럼 순서, 정렬 방향(ASC/DESC), NULLS 처리 규칙이 인덱스 키와 완전히 일치
2. **정렬 보장 스캔**: 인덱스 접근 방식이 정렬 순서를 보장하는 스캔 방식(INDEX RANGE SCAN 또는 INDEX FULL SCAN)
3. **순서 유지**: 조인이나 필터 연산이 정렬 순서를 깨뜨리지 않아야 함

**수식적으로 표현하면**:
```
인덱스 정렬 순서 ≡ ORDER BY 키 (동일 컬럼, 동일 방향, 동일 NULLS 규칙)
```

### INDEX FAST FULL SCAN의 한계

`INDEX FAST FULL SCAN`은 성능 최적화를 위해 인덱스를 멀티블록 방식으로 읽으며, 이 과정에서 **인덱스의 키 순서가 보장되지 않습니다**. 따라서 정렬 제거를 목표로 할 때는 IFFS 대신 정렬 순서를 보장하는 인덱스 스캔 방식으로 유도해야 합니다.

---

## ORDER BY 제거: SORT ORDER BY Elimination

### 실습 환경 설정

```sql
-- 테스트 스키마 구성
DROP TABLE f_sales PURGE;
DROP TABLE d_product PURGE;

CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  sales_dt  DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
);

-- 샘플 데이터
INSERT INTO d_product VALUES (10,'ELECTRONICS','BRAND_A');
INSERT INTO d_product VALUES (20,'HOME','BRAND_B');
INSERT INTO d_product VALUES (30,'ELECTRONICS','BRAND_C');

INSERT INTO f_sales VALUES (1001,10,DATE '2025-02-03',1,10000);
INSERT INTO f_sales VALUES (1002,20,DATE '2025-02-05',2,15000);
INSERT INTO f_sales VALUES (1003,10,DATE '2025-02-10',1,9000);
INSERT INTO f_sales VALUES (1004,30,DATE '2025-02-15',3,20000);

COMMIT;

-- 통계 수집
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'D_PRODUCT');
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER,'F_SALES');
```

### 단일 컬럼 정렬 제거

**기본 쿼리 (소트 필요)**:
```sql
SELECT sales_id, amount
FROM f_sales
ORDER BY amount DESC;
-- 실행계획: TABLE ACCESS FULL + SORT ORDER BY
```

**인덱스 활용 개선**:
```sql
-- DESC 방향 인덱스 생성
CREATE INDEX ix_f_sales_amount_desc ON f_sales(amount DESC);

-- 인덱스 힌트를 사용한 정렬 제거
SELECT /*+ INDEX_DESC(f_sales ix_f_sales_amount_desc) */
       sales_id, amount
FROM f_sales
ORDER BY amount DESC;
-- 실행계획: INDEX FULL SCAN DESCENDING (SORT ORDER BY 제거됨)
```

**핵심 포인트**: 인덱스가 이미 내림차순으로 정렬되어 있기 때문에 추가적인 소트 연산이 필요 없습니다. 주의할 점은 옵티마이저가 INDEX FAST FULL SCAN을 선택하지 않도록 해야 합니다.

### 복합 컬럼 정렬 제거

실무에서는 여러 컬럼을 조합한 정렬이 흔합니다. 이 경우 인덱스 설계가 더욱 중요해집니다.

**요구사항**: 판매일자 내림차순, 금액 내림차순으로 정렬
```sql
-- 복합 DESC 인덱스 생성
CREATE INDEX ix_f_sales_dt_amt_desc ON f_sales(sales_dt DESC, amount DESC);

-- 인덱스를 활용한 정렬 제거
SELECT /*+ INDEX_DESC(f_sales ix_f_sales_dt_amt_desc) */
       sales_id, sales_dt, amount
FROM f_sales
WHERE sales_dt >= DATE '2025-02-01'
  AND sales_dt < DATE '2025-03-01'
ORDER BY sales_dt DESC, amount DESC;
-- 실행계획: INDEX RANGE SCAN DESCENDING (SORT ORDER BY 제거)
```

**원리 이해**: B-Tree 인덱스는 선두 컬럼(sales_dt) 기준으로 범위를 지정하면, 해당 범위 내에서 두 번째 컬럼(amount)의 정렬 순서가 자연스럽게 유지됩니다.

### Top-N 쿼리 최적화

Top-N 패턴은 실무에서 가장 빈번하게 사용되며, 인덱스를 통한 최적화 효과가 극대화됩니다.

**기본 Top-N 쿼리**:
```sql
SELECT sales_id, amount
FROM f_sales
WHERE sales_dt >= DATE '2025-02-01'
  AND sales_dt < DATE '2025-03-01'
ORDER BY amount DESC
FETCH FIRST 100 ROWS ONLY;
-- 실행계획: SORT ORDER BY STOPKEY (부분 정렬)
```

**인덱스 기반 완전 최적화**:
```sql
SELECT /*+ INDEX_DESC(f_sales ix_f_sales_amount_desc) */
       sales_id, amount
FROM f_sales
WHERE sales_dt >= DATE '2025-02-01'
  AND sales_dt < DATE '2025-03-01'
FETCH FIRST 100 ROWS ONLY;
-- 실행계획: INDEX RANGE SCAN DESCENDING + STOPKEY (소트 완전 제거)
```

**동작 원리**: 인덱스가 이미 정렬된 상태이므로, 데이터베이스는 상위부터 순차적으로 읽다가 100번째 행에서 스캔을 중단합니다. 이로 인해 대량 데이터에서도 극도로 빠른 응답 시간을 보장합니다.

### 키셋 기반 페이지네이션

OFFSET 기반 페이지네이션은 앞부분 데이터를 버리기 위해 전체 정렬을 수행해야 하는 치명적 단점이 있습니다. 키셋(Seek) 페이지네이션은 이 문제를 근본적으로 해결합니다.

```sql
-- 페이지네이션을 위한 복합 인덱스
CREATE INDEX ix_f_sales_pagination 
ON f_sales(sales_dt DESC, amount DESC, sales_id DESC);

-- 첫 페이지 조회
SELECT /*+ INDEX_DESC(f_sales ix_f_sales_pagination) */
       sales_id, sales_dt, amount
FROM f_sales
ORDER BY sales_dt DESC, amount DESC, sales_id DESC
FETCH FIRST 50 ROWS ONLY;

-- 두 번째 페이지: 이전 페이지 마지막 키값을 조건으로 사용
SELECT /*+ INDEX_DESC(f_sales ix_f_sales_pagination) */
       sales_id, sales_dt, amount
FROM f_sales
WHERE (sales_dt, amount, sales_id) < (:last_dt, :last_amount, :last_id)
ORDER BY sales_dt DESC, amount DESC, sales_id DESC
FETCH FIRST 50 ROWS ONLY;
-- 실행계획: INDEX RANGE SCAN DESCENDING (소트 없음)
```

**장점**:
- 각 페이지 조회 시 전체 정렬 불필요
- 데이터 증가에 따른 성능 저하 없음
- 정렬 순서가 변경되어도 페이지 간 일관성 유지

---

## GROUP BY 제거: HASH / NOSORT / ELIMINATION

GROUP BY 연산에서 소트를 제거하는 세 가지 주요 전략이 있습니다.

### 1. 해시 집계(HASH GROUP BY)

가장 일반적인 GROUP BY 소트 제거 방법으로, 정렬 없이 해시 테이블을 이용해 그룹화를 수행합니다.

```sql
-- 기본 GROUP BY (옵티마이저 판단에 따라 SORT 또는 HASH 선택)
SELECT prod_id, COUNT(*), SUM(amount)
FROM f_sales
GROUP BY prod_id;

-- 해시 집계 명시적 유도
SELECT /*+ USE_HASH_AGGREGATION */
       prod_id, COUNT(*), SUM(amount)
FROM f_sales
GROUP BY prod_id;
-- 실행계획: HASH GROUP BY (정렬 없음)
```

**주의사항**: 해시 테이블이 PGA 메모리를 초과하면 TEMP 디스크로 스필될 수 있습니다. 하지만 이는 정렬 기반 소트의 TEMP 사용보다 일반적으로 더 효율적입니다.

### 2. GROUP BY NOSORT

입력 데이터가 이미 그룹 키 순서로 정렬되어 있는 경우, 옵티마이저는 `SORT GROUP BY NOSORT`를 수행합니다. 이는 그룹화는 수행하되 정렬은 생략하는 최적화입니다.

**NOSORT 조건**:
1. GROUP BY 키가 인덱스의 선두 접두어(prefix)여야 함
2. 인덱스 스캔이 그룹별 연속 구간을 제공해야 함
3. WHERE 조건이 인덱스 선두 컬럼을 활용해야 함

```sql
-- NOSORT를 유도하는 인덱스 설계
CREATE INDEX ix_f_sales_prod_dt ON f_sales(prod_id, sales_dt);

-- NOSORT GROUP BY 예제
SELECT /*+ INDEX(f_sales ix_f_sales_prod_dt) */
       prod_id, COUNT(*), SUM(amount)
FROM f_sales
WHERE sales_dt >= DATE '2025-02-01'
  AND sales_dt < DATE '2025-03-01'
GROUP BY prod_id;
-- 실행계획: SORT GROUP BY NOSORT
```

**복합 그룹 키에서의 NOSORT**:
```sql
SELECT /*+ INDEX(f_sales ix_f_sales_prod_dt) */
       prod_id, sales_dt, COUNT(*), SUM(amount)
FROM f_sales
WHERE sales_dt >= DATE '2025-02-01'
  AND sales_dt < DATE '2025-03-01'
GROUP BY prod_id, sales_dt;
-- 실행계획: SORT GROUP BY NOSORT
```

인덱스가 `(prod_id, sales_dt)` 순서로 정렬되어 있기 때문에, 입력 데이터는 자연스럽게 그룹 키 순서를 따릅니다.

### 3. GROUP BY ELIMINATION

GROUP BY 대상이 기본 키(PK)이면서 NOT NULL 컬럼인 경우, 옵티마이저는 그룹화 연산 자체를 제거할 수 있습니다.

```sql
-- PK 컬럼으로의 GROUP BY
SELECT customer_id, COUNT(*)
FROM orders
GROUP BY customer_id;
-- 실행계획: GROUP BY 제거 가능 (최신 옵티마이저)
```

**제한 조건**:
- 그룹화 대상이 유니크하거나 기본 키여야 함
- 컬럼이 NOT NULL 제약조건을 가져야 함
- 복합 PK의 경우 모든 컬럼을 GROUP BY 해야 제거 가능

---

## 실전에서 마주치는 함정과 해결책

인덱스를 이용한 소트 제거 시 자주 발생하는 문제들와 그 해결 방안을 살펴보겠습니다.

### 함정 1: INDEX FAST FULL SCAN 선택

**문제**: 옵티마이저가 IFFS를 선택하면 정렬 순서가 보장되지 않아 소트 제거 실패

**해결책**:
```sql
-- IFFS 회피 힌트
SELECT /*+ INDEX_DESC(t index_name) NO_INDEX_FFS(t) */ ...
FROM 테이블 t;
```

### 함정 2: 인덱스 접두 불일치

**문제**: 인덱스가 `(A, B)` 순서인데 `ORDER BY B`나 `GROUP BY B`만 필요한 경우

**해결책**:
- 정렬/그룹화에 필요한 컬럼을 선두로 하는 별도 인덱스 생성
- 함수 기반 인덱스(FBI) 활용

### 함정 3: 정렬 방향 및 NULLS 규칙 불일치

**문제**: `ORDER BY col DESC NULLS LAST` 요구사항에 인덱스가 `col ASC NULLS FIRST`로 생성된 경우

**해결책**:
```sql
-- 정확한 규칙으로 인덱스 재생성
CREATE INDEX idx_exact ON 테이블(col DESC NULLS LAST);
```

### 함정 4: 함수/표현식 기반 정렬

**문제**: `ORDER BY UPPER(name)`이나 `GROUP BY TRUNC(date)`와 같은 표현식 사용

**해결책 1 - 함수 기반 인덱스**:
```sql
CREATE INDEX idx_upper_name ON employees(UPPER(last_name));
```

**해결책 2 - 가상 컬럼 활용**:
```sql
ALTER TABLE sales ADD (sales_month GENERATED ALWAYS AS (TRUNC(sales_date, 'MM')));

CREATE INDEX idx_sales_month ON sales(sales_month);
```

### 함정 5: 조인으로 인한 순서 파괴

**문제**: 조인 연산이 인덱스 정렬 순서를 깨뜨리는 경우

**해결책**:
```sql
-- NL 조인으로 순서 유지
SELECT /*+ LEADING(driving_table) USE_NL(joined_table) */
       ...
FROM driving_table
JOIN joined_table ON ...
WHERE ...
ORDER BY driving_table.indexed_column;
```

### 함정 6: 파티션 테이블의 로컬 인덱스

**문제**: 로컬 인덱스는 파티션 내에서는 정렬을 보장하지만, 파티션 간 전역 정렬은 보장하지 않음

**해결책**:
- 글로벌 인덱스 사용 (단, 파티션 관리 비용 증가)
- 파티션 키를 정렬 키에 포함시켜 파티션별 정렬 최적화

---

## 실전 리팩토링 사례

### 사례 1: 월별 전자제품 상위 판매 조회

**개선 전 (소트 의존)**:
```sql
SELECT s.sales_id, s.prod_id, s.amount
FROM f_sales s
JOIN d_product p ON p.prod_id = s.prod_id
WHERE p.category = 'ELECTRONICS'
  AND s.sales_dt >= DATE '2025-02-01'
  AND s.sales_dt < DATE '2025-03-01'
ORDER BY s.amount DESC
FETCH FIRST 100 ROWS ONLY;
-- 실행계획: SORT ORDER BY STOPKEY
```

**개선 후 (인덱스 기반)**:
```sql
-- 최적화 인덱스 생성
CREATE INDEX ix_d_product_category_prod ON d_product(category, prod_id);
CREATE INDEX ix_f_sales_amount_desc ON f_sales(amount DESC);

-- NL 조인 + 인덱스 활용
SELECT /*+ LEADING(p) USE_NL(s)
           INDEX(p ix_d_product_category_prod)
           INDEX_DESC(s ix_f_sales_amount_desc) */
       s.sales_id, s.prod_id, s.amount
FROM d_product p
JOIN f_sales s ON s.prod_id = p.prod_id
WHERE p.category = 'ELECTRONICS'
  AND s.sales_dt >= DATE '2025-02-01'
  AND s.sales_dt < DATE '2025-03-01'
FETCH FIRST 100 ROWS ONLY;
-- 실행계획: INDEX RANGE SCAN DESCENDING + STOPKEY (소트 없음)
```

**최적화 핵심**:
1. 작은 차원 테이블(d_product)을 드라이빙으로 설정
2. 금액 내림차순 인덱스를 활용한 Top-N 스캔
3. NL 조인으로 정렬 순서 유지

### 사례 2: 일별 상품별 집계 최적화

**개선 전**:
```sql
SELECT prod_id, sales_dt, COUNT(*), SUM(amount)
FROM f_sales
WHERE sales_dt >= :start_date AND sales_dt < :end_date
GROUP BY prod_id, sales_dt;
-- 실행계획: SORT GROUP BY
```

**개선 후**:
```sql
-- NOSORT 유도 인덱스
CREATE INDEX ix_f_sales_prod_dt_inc ON f_sales(prod_id, sales_dt, amount);

SELECT /*+ INDEX(f_sales ix_f_sales_prod_dt_inc) */
       prod_id, sales_dt, COUNT(*), SUM(amount)
FROM f_sales
WHERE sales_dt >= :start_date AND sales_dt < :end_date
GROUP BY prod_id, sales_dt;
-- 실행계획: SORT GROUP BY NOSORT
```

---

## 검증 방법론: 소트 제거 효과 측정

### 실행계획 분석

```sql
-- 상세 실행계획 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, NULL, 'ALLSTATS LAST +PREDICATE +NOTE +ALIAS'
));
```

**확인 포인트**:
- `SORT ORDER BY` 또는 `SORT GROUP BY` 오퍼레이션 제거 여부
- 인덱스 스캔 방식 확인 (FULL SCAN vs FAST FULL SCAN)
- TEMP 사용량(TempSpc) 감소 여부

### 성능 통계 비교

```sql
-- 소트 관련 통계 모니터링
SELECT 
    sn.name AS 통계명,
    ms.value AS 현재값
FROM v$mystat ms 
JOIN v$statname sn ON sn.stat# = ms.stat#
WHERE sn.name IN (
    'sorts (memory)',      -- 메모리 내 소트 횟수
    'sorts (disk)',        -- 디스크 스필 소트 횟수
    'workarea executions - optimal',
    'workarea executions - onepass',
    'workarea executions - multipass'
);
```

**효과 측정 지표**:
- `sorts (disk)` 감소: TEMP I/O 감소 증거
- `workarea executions - optimal` 증가: 메모리 내 처리 증대
- `onepass/multipass` 감소: 외부 소트 필요성 감소

### TEMP 사용량 모니터링

```sql
-- 실시간 TEMP 사용량 확인
SELECT 
    s.username,
    t.sql_id,
    t.segtype,
    ROUND(t.blocks * ts.block_size / 1024 / 1024, 2) AS used_mb,
    t.tablespace
FROM v$tempseg_usage t
JOIN v$session s ON s.saddr = t.session_addr
JOIN dba_tablespaces ts ON ts.tablespace_name = t.tablespace
ORDER BY used_mb DESC;
```

---

## 결론: 체계적인 소트 제거 전략

인덱스를 활용한 소트 연산 제거는 성능 최적화의 핵심 기법입니다. 효과적인 적용을 위한 체계적인 접근법을 정리해보겠습니다.

### 핵심 원칙 3가지

1. **정렬을 제거하라, 줄이지 말라**
   - 불필요한 ORDER BY, DISTINCT, UNION 연산 제거
   - 인덱스 설계로 자연 정렬 획득
   - Top-N 패턴 적극 활용

2. **인덱스 설계는 쿼리 요구사항에서 출발하라**
   - 정렬 키와 인덱스 키의 완전한 일치(컬럼, 순서, 방향, NULLS)
   - 자주 사용되는 정렬/그룹화 패턴을 우선 지원
   - 함수 기반 정렬 요구는 FBI나 가상 컬럼으로 해결

3. **측정 없이 개선하지 말라**
   - 모든 최적화는 실행계획으로 검증
   - 전/후 성능 통계 비교
   - TEMP I/O 감소 효과 정량화

### 실전 적용 가이드라인

**인덱스 스캔 방식 관리**:
- 정렬 제거 목적이라면 INDEX FAST FULL SCAN 회피
- `INDEX_DESC`, `NO_INDEX_FFS` 힌트로 정렬 보장 스캔 유도

**GROUP BY 최적화 전략**:
1차 시도: 해시 집계(`USE_HASH_AGGREGATION`)
2차 시도: NOSORT 그룹화(인덱스 접두 일치 설계)
3차 시도: 그룹화 제거(ELIMINATION 조건 확인)

**조인 순서 관리**:
- 정렬 키를 가진 테이블을 드라이빙으로 설정
- NL 조인으로 순서 유지(필요시 힌트 활용)
- 해시/머지 조인은 순서 파괴 가능성 고려

**파티션 환경 대응**:
- 전역 정렬 필요시 글로벌 인덱스 검토
- 로컬 인덱스만으로 충분한지 파티션 프루닝 효과 분석

### 지속적 최적화 사이클

1. **분석**: 실행계획에서 소트 연산 식별
2. **원인 진단**: 인덱스 불일치, 조인 순서, 표현식 문제 등 분석
3. **해결책 설계**: 인덱스 재설계, 쿼리 리팩토링, 힌트 적용
4. **검증**: 실행계획, 성능 통계, TEMP 사용량으로 효과 확인
5. **모니터링**: 프로덕션 환경에서 장기적 안정성 확인

소트 연산 제거는 단순한 성능 개선을 넘어, 데이터베이스 자원 사용 효율성을 근본적으로 높이는 작업입니다. 체계적인 접근과 과학적인 검증을 통해 예측 가능한 성능 향상을 달성할 수 있습니다. 인덱스 설계와 쿼리 작성 시 항상 "이 정렬을 없앨 수 있는가?"라는 질문을 던지는 습관이 지속적인 최적화의 시작점이 됩니다.