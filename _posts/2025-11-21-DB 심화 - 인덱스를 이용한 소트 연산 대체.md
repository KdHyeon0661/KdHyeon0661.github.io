---
layout: post
title: DB 심화 - 인덱스를 이용한 소트 연산 대체
date: 2025-11-21 23:25:23 +0900
category: DB 심화
---
# 인덱스를 이용한 소트 연산 대체

**주제**: `SORT ORDER BY` 대체, `SORT GROUP BY` 대체, 그리고 **인덱스가 소트를 대체하지 못하는 경우(제한/함정)**

> 핵심 요약
> - **정렬을 피하는 최우선 전략**은 “**인덱스가 만들어내는 자연 순서**”를 그대로 이용하는 것이다.
> - `ORDER BY`는 **방향/컬럼 순서**를 반영한 인덱스로, `GROUP BY`는 **그룹 키 순서로 입력**을 공급하면 `GROUP BY NOSORT`가 가능하다.
> - 단, **IFFS(Index Fast Full Scan)는 정렬을 보장하지 않는다**. **INDEX FULL SCAN(ASC/DESC)** 또는 **INDEX RANGE SCAN**을 유도해야 한다.
> - **함수/표현식 기반 정렬/그룹**은 **가상 컬럼/함수기반 인덱스(FBI)**로 SARGABLE하게 만든다.

---

## 0) 실습 스키마 & 점검 루틴

```sql
-- 제품/매출 샘플
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  sales_dt  DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
);

INSERT INTO d_product VALUES (10,'ELEC','B0');
INSERT INTO d_product VALUES (20,'HOME','B1');

INSERT INTO f_sales VALUES (1001,10,DATE '2025-02-03',1,10000);
INSERT INTO f_sales VALUES (1002,20,DATE '2025-02-05',2,15000);
INSERT INTO f_sales VALUES (1003,10,DATE '2025-02-10',1, 9000);
COMMIT;
```

자주 쓰는 인덱스(예시):

```sql
-- ORDER BY 대체용
CREATE INDEX ix_amt_desc         ON f_sales(amount DESC);
CREATE INDEX ix_dt_amt_desc      ON f_sales(sales_dt, amount DESC);
CREATE INDEX ix_prod_dt          ON f_sales(prod_id, sales_dt);
CREATE INDEX ix_brand3_fbi       ON d_product(SUBSTR(brand,1,3));
```

실행계획/통계 확인:

```sql
-- 마지막 커서의 실제 실행계획/통계
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE +ALIAS'));

-- 세션 소트/워크에어리어 관련 지표(전/후 비교)
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN (
  'sorts (memory)','sorts (disk)',
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass'
);
```

---

# 1) `SORT ORDER BY` 대체 — 인덱스로 정렬을 없애는 법

## 단일 컬럼 정렬(내림차순)

```sql
-- Before: 정렬 필요(내림차순)
SELECT sales_id, amount
FROM   f_sales
ORDER  BY amount DESC;
-- PLAN: SORT ORDER BY

-- After: DESC 인덱스로 자연 순서 획득
-- 준비: CREATE INDEX ix_amt_desc ON f_sales(amount DESC);
SELECT /*+ INDEX_DESC(f_sales ix_amt_desc) */
       sales_id, amount
FROM   f_sales
ORDER  BY amount DESC;
-- PLAN 기대: INDEX FULL SCAN (DESCENDING) → SORT ORDER BY 제거
```
> 팁
> - **INDEX FAST FULL SCAN(IFFS)** 은 블록 병렬/랜덤 읽기로 **순서를 보장하지 않는다**.
>   정렬 제거 목적이라면 **`INDEX FULL SCAN` 또는 `INDEX RANGE SCAN`** 을 유도해야 한다.

## 복합 정렬(여러 컬럼/방향)

```sql
-- 요구: ORDER BY sales_dt DESC, amount DESC
CREATE INDEX ix_dt_amt_desc ON f_sales(sales_dt, amount DESC);

SELECT /*+ INDEX_DESC(f_sales ix_dt_amt_desc) */
       sales_id, sales_dt, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01' AND sales_dt < DATE '2025-03-01'
ORDER  BY sales_dt DESC, amount DESC;
-- PLAN 기대: INDEX RANGE SCAN DESC → SORT 없음
```
원리:
- **정렬키와 완전히 동일한 컬럼 순서/방향**으로 인덱스 설계
- WHERE 절이 선두 컬럼에 범위를 주면 **해당 범위 내부는 여전히 정렬 유지**

## Top-N (STOPKEY) — 전체 정렬 없이 상위 N건

```sql
-- 월간 상위 100건
SELECT sales_id, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01' AND sales_dt < DATE '2025-03-01'
ORDER  BY amount DESC
FETCH  FIRST 100 ROWS ONLY;
-- PLAN: SORT ORDER BY STOPKEY (부분 힙), 대개 빠르나 여전히 SORT

-- 인덱스로 완전 제거
SELECT /*+ INDEX_DESC(f_sales ix_amt_desc) */
       sales_id, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01' AND sales_dt < DATE '2025-03-01'
FETCH  FIRST 100 ROWS ONLY;
-- PLAN: INDEX DESC + STOPKEY → SORT 자체 없음
```

## 페이지네이션(OFFSET 회피) — **키셋 페이지네이션**

OFFSET은 앞의 페이지를 **버리기 위해 정렬+스캔**한다.
대신 **마지막 키**를 기억하고 그 **다음 범위**를 인덱스에서 바로 찾는다.

```sql
-- 정렬 키: (sales_dt DESC, amount DESC, sales_id DESC)
CREATE INDEX ix_seek ON f_sales(sales_dt, amount DESC, sales_id DESC);

-- 첫 페이지
SELECT /*+ INDEX_DESC(f_sales ix_seek) */
       sales_id, sales_dt, amount
FROM   f_sales
ORDER  BY sales_dt DESC, amount DESC, sales_id DESC
FETCH  FIRST 50 ROWS ONLY;

-- 다음 페이지: 직전 페이지의 마지막 키(:dt0, :amt0, :id0)
SELECT /*+ INDEX_DESC(f_sales ix_seek) */
       sales_id, sales_dt, amount
FROM   f_sales
WHERE  (sales_dt, amount, sales_id) < (:dt0, :amt0, :id0)
ORDER  BY sales_dt DESC, amount DESC, sales_id DESC
FETCH  FIRST 50 ROWS ONLY;
-- PLAN: INDEX DESC Range Scan, SORT 없음
```

## 표현식/가공 정렬은 **FBI(함수기반 인덱스)**

```sql
-- 요구: ORDER BY SUBSTR(brand,1,3)
CREATE INDEX ix_brand3_fbi ON d_product(SUBSTR(brand,1,3));

SELECT /*+ INDEX(d_product ix_brand3_fbi) */
       prod_id, brand
FROM   d_product
ORDER  BY SUBSTR(brand,1,3);
-- PLAN 기대: INDEX FULL/RANGE SCAN → SORT 제거
```

## NULLS FIRST/LAST, NLS 정렬, 대소문자 무시

- 인덱스 **ASC/DESC + NULLS FIRST/LAST** 조합으로 정렬 규칙 일치
- 대소문자/악센트 무시는 `UPPER(col)` FBI 또는 **NLSSORT** 기반 FBI로 처리
  (예: `CREATE INDEX ... ON (NLSSORT(col, 'NLS_SORT=BINARY_CI'))`)

---

# 2) `SORT GROUP BY` 대체 — `GROUP BY NOSORT`와 해시 집계

## 해시 집계로 정렬 자체 제거

```sql
-- 기본 집계(옵티마이저가 상황에 따라 소트/해시 선택)
SELECT prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP  BY prod_id;

-- 해시 집계 유도(비교용)
SELECT /*+ USE_HASH_AGGREGATION */
       prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP  BY prod_id;
-- PLAN 기대: HASH GROUP BY → SORT GROUP BY 제거
```
> 해시 집계는 **메모리 충분**하면 매우 효율적이며, **정렬이 없다**.
> 단, 해시 스필 시 TEMP I/O가 발생할 수 있지만, 이는 “정렬”이 아니라 “해시 파티션” 처리다.

## `GROUP BY NOSORT`를 얻는 조건과 예제

**아이디어**: 입력이 이미 **그룹 키 순서**로 올라오면 소트가 불필요하다.

조건(경험칙):
- **그룹 키가 인덱스의 선두 접두(prefix)**
- 옵티마이저가 인덱스 스캔으로 **그룹별 연속 블록**을 공급할 수 있다고 판단
- WHERE 절이 선두 컬럼 필터에 친화적

```sql
-- 인덱스: (prod_id, sales_dt)
CREATE INDEX ix_prod_dt ON f_sales(prod_id, sales_dt);

-- 특정 기간 내 상품별 집계 (prod_id로 그룹)
SELECT /*+ INDEX(f_sales ix_prod_dt) */
       prod_id, COUNT(*), SUM(amount)
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi
GROUP  BY prod_id;
-- PLAN(상황 따라): GROUP BY NOSORT 또는 HASH GROUP BY
```

다른 예 — **다중 컬럼 그룹**:
```sql
-- (prod_id, sales_dt) 로 그룹
SELECT /*+ INDEX(f_sales ix_prod_dt) */
       prod_id, sales_dt, COUNT(*), SUM(amount)
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi
GROUP  BY prod_id, sales_dt;
-- 인덱스가 prod_id → sales_dt 순이라면 NOSORT 가능성이 높음
```

> 주의
> - 버전/통계/분포에 따라 항상 `NOSORT`가 되진 않는다. `DBMS_XPLAN`으로 확인하라.
> - `HAVING`에 **비그룹 컬럼 표현식**이 개입되면 NOSORT가 깨질 수 있다.

## `MIN/MAX`는 인덱스가 정렬을 대체하는 대표 패턴

```sql
-- 각 상품의 첫 판매일
-- 인덱스: (prod_id, sales_dt)
SELECT prod_id, MIN(sales_dt) AS first_dt
FROM   f_sales
GROUP  BY prod_id;
-- 내부적으로 인덱스 선두에서 STOPKEY 사용 가능 → 정렬 없이 매우 효율적

-- 상관 서브쿼리(인덱스 MIN STOPKEY)
SELECT s.*
FROM   f_sales s
WHERE  s.sales_dt = (
  SELECT MIN(s2.sales_dt)
  FROM   f_sales s2
  WHERE  s2.prod_id = s.prod_id
);
```

---

# 3) 인덱스가 소트를 대체하지 못하는 경우(제한/함정)

## IFFS(Index Fast Full Scan) 사용 시

- **IFFS는 테이블 풀스캔의 인덱스 버전**으로 **정렬을 보장하지 않는다**.
- 실행계획에서 `INDEX FAST FULL SCAN`이 잡히면 **ORDER BY 제거 불가**.
  → **`INDEX FULL SCAN` 또는 `INDEX RANGE SCAN`**으로 유도해야 한다.

해결:
```sql
SELECT /*+ INDEX_DESC(f_sales ix_dt_amt_desc) */ ...
```
또는 `no_parallel_index`, `index_combine` 회피 등으로 FFScan 선택을 막는다.

## 정렬/그룹 키가 **인덱스 접두(prefix)** 가 아닐 때

- 예: 인덱스가 `(A, B)`인데 `ORDER BY B`만 필요/`GROUP BY B`만 필요
- **선두 컬럼 A의 선택도가 낮아**도 **접두 불일치**면 인덱스로 정렬 보장 불가
해결: 정렬/그룹에 맞춘 **별도의 인덱스** 또는 **FBI/가상 컬럼** 설계.

## 정렬 방향/NULL 위치 불일치

- `ORDER BY col DESC NULLS LAST`인데 인덱스가 `col ASC NULLS FIRST`
- **방향/NULLS 규칙**을 맞추지 않으면 결국 SORT 필요
해결: **DESC/ASC + NULLS** 규칙 일치 인덱스 재설계.

## 표현식/함수 기반 정렬/그룹(인덱스 없음)

- `ORDER BY SUBSTR(col,1,3)`, `GROUP BY TRUNC(dt)` 등
- 해당 표현식에 대한 **FBI 또는 가상 컬럼+인덱스**가 없으면 SORT 필요
해결:
```sql
ALTER TABLE f_sales ADD dt_d    GENERATED ALWAYS AS (TRUNC(sales_dt)) VIRTUAL;
CREATE INDEX ix_dt_d ON f_sales(dt_d);
```

## 다테이블 조인 후의 정렬

- 조인 결과가 **인덱스가 보장한 순서**를 깨뜨릴 수 있다.
- NL 조인에서 **드라이빙 테이블 인덱스 순서**를 유지하는 설계면 가능하나,
  해시/소트-머지 조인 등은 자체 내부 단계로 **정렬이 재필요**할 수 있다.
해결: **조인 순서/방식 힌트** + **정렬키 인덱스를 가진 테이블로 드라이빙**.

## `UNION`/`DISTINCT`/`ROLLUP/CUBE`

- `UNION`은 중복 제거(대개 `SORT UNIQUE`) 필요, `UNION ALL`이 아니면 정렬 대체 난해
- `GROUP BY ROLLUP/CUBE`는 다단계 집계/정렬이 필요할 수 있어 단순 NOSORT 어려움
- `DISTINCT`도 보통 정렬 또는 해시 기반 중복 제거. 인덱스만으로는 일반적으로 대체 불가
  (특정 케이스: 단일 유니크 컬럼만 SELECT하는 **유니크 인덱스** + **정렬 불요**라면 DISTINCT 불필요)

## 윈도우 함수(분석 함수)

- `OVER(PARTITION BY ... ORDER BY ...)`는 파티션별 정렬 필요 → `WINDOW SORT`
- 인덱스로 PARTITION/ORDER 순서로 **이미 읽히게** 하면 줄일 수 있지만,
  **완전 제거**는 계산 프레임에 따라 제한적.

## 파티션 병합 정렬(다파티션 조회)

- 로컬 인덱스만으로는 파티션 간 **글로벌 순서**가 보장되지 않아
  파티션 결합 시점에 **Merge Sort**가 발생할 수 있다.
해결: **글로벌 인덱스**(주의 필요) 또는 **파티션-키 포함 정렬 전략**.

## 동적 ORDER BY(사용자 입력)

- 사용자 파라미터에 따라 방향/컬럼이 바뀌면 **하나의 인덱스로 커버 불가**.
해결:
  - **정렬 후보가 제한적**이면 **멀티 인덱스** 준비 + 동적 힌트 분기
  - 그렇지 않으면 **해시 집계/Top-N**과 **적절한 Sort**를 감수

---

# 4) 실전 시나리오 — 리팩터링 전/후

## 월간 상위 100건(카테고리=ELEC), 정렬 제거

**Before**: 정렬 필요
```sql
SELECT s.sales_id, s.prod_id, s.amount
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'
AND    s.sales_dt >= DATE '2025-02-01' AND s.sales_dt < DATE '2025-03-01'
ORDER  BY s.amount DESC
FETCH  FIRST 100 ROWS ONLY;
-- PLAN: SORT ORDER BY STOPKEY (큰 입력이면 TEMP 스필 가능)
```

**After**: NL + DESC 인덱스 + STOPKEY
```sql
-- 인덱스 준비
CREATE INDEX ix_dp_cat_prod ON d_product(category, prod_id);  -- 드라이빙
-- 금액 정렬 제거용
CREATE INDEX ix_amt_desc    ON f_sales(amount DESC);

SELECT /*+ LEADING(p) USE_NL(s) INDEX_DESC(s ix_amt_desc) */
       s.sales_id, s.prod_id, s.amount
FROM   d_product p
JOIN   f_sales   s ON s.prod_id = p.prod_id
WHERE  p.category = 'ELEC'
AND    s.sales_dt >= DATE '2025-02-01' AND s.sales_dt < DATE '2025-03-01'
FETCH  FIRST 100 ROWS ONLY;
-- PLAN 기대: INDEX DESC Range + STOPKEY, SORT 없음
-- 검증: DBMS_XPLAN Note의 TempSpc=0, sorts(disk) 증가 없음
```

## 일자별/상품별 집계에서 `GROUP BY NOSORT` 유도

**Before**: SORT GROUP BY
```sql
SELECT prod_id, sales_dt, COUNT(*), SUM(amount)
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi
GROUP  BY prod_id, sales_dt;
-- PLAN: SORT GROUP BY
```

**After**: 인덱스로 그룹순 입력 보장
```sql
CREATE INDEX ix_prod_dt ON f_sales(prod_id, sales_dt);

SELECT /*+ INDEX(f_sales ix_prod_dt) */
       prod_id, sales_dt, COUNT(*), SUM(amount)
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi
GROUP  BY prod_id, sales_dt;
-- PLAN(상황 따라): GROUP BY NOSORT 또는 HASH GROUP BY
```

## 표현식 정렬 제거(FBI)

**Before**:
```sql
SELECT prod_id, brand
FROM   d_product
ORDER  BY SUBSTR(brand,1,3);
-- PLAN: SORT ORDER BY
```
**After**:
```sql
CREATE INDEX ix_brand3_fbi ON d_product(SUBSTR(brand,1,3));

SELECT /*+ INDEX(d_product ix_brand3_fbi) */
       prod_id, brand
FROM   d_product
ORDER  BY SUBSTR(brand,1,3);
-- PLAN: INDEX FULL/RANGE SCAN → SORT 제거
```

---

# 5) 이론 메모: 인덱스가 소트를 대체하는 충분조건(직관)

- `ORDER BY` 대체
  $$\text{Index order} \equiv \text{ORDER BY list (same columns, same directions, same NULLS)}$$
  **AND** 액세스 경로가 `INDEX FULL/RANGE SCAN(ASC/DESC)`일 것.

- `GROUP BY` 대체(`NOSORT`)
  $$\text{Index leading prefix} \supseteq \text{GROUP BY key list in order}$$
  그리고 입력이 해당 인덱스 **순서대로** 공급될 것(조인/필터가 순서를 깨지 않게).

---

# 6) 운영 체크리스트

- [ ] **IFFS 금지**: 정렬 대체 시 IFFS가 아닌 **INDEX FULL/RANGE SCAN** 유도
- [ ] **정렬키=인덱스 설계**: 컬럼 순서/방향/NULLS 규칙 일치
- [ ] **WHERE 절**은 **선두 컬럼 범위**를 주어도 순서 유지되는지 확인
- [ ] **Top-N/페이지네이션**은 STOPKEY/키셋 방식으로 처리
- [ ] **GROUP BY**는 해시 집계 우선, 또는 **NOSORT**가 가능한 인덱스 설계
- [ ] **표현식 정렬/그룹**은 **가상 컬럼/FBI**로 SARGABLE하게
- [ ] **조인 방식/순서**가 순서를 깨지 않도록 NL+드라이빙 설계 고려
- [ ] **파티션** 간 글로벌 순서가 필요하면 글로벌 인덱스·전략 검토
- [ ] 모든 변경은 **DBMS_XPLAN + V$ 통계**로 정량 검증

---

## 부록: 검증 쿼리 스니펫

```sql
-- 1) 대상 SQL 실행 전/후 sorts 통계 비교
WITH now AS (
  SELECT sn.name, ms.value
  FROM   v$mystat ms JOIN v$statname sn ON sn.stat# = ms.stat#
  WHERE  sn.name IN ('sorts (memory)','sorts (disk)')
)
SELECT * FROM now; -- 실행 전 캡처

-- (여기에 대상 SQL 실행)

WITH now AS (
  SELECT sn.name, ms.value
  FROM   v$mystat ms JOIN v$statname sn ON sn.stat# = ms.stat#
  WHERE  sn.name IN ('sorts (memory)','sorts (disk)')
)
SELECT name, value - LAG(value) OVER (ORDER BY name) AS delta
FROM   now;

-- 2) 실행계획(정렬 라인 부재 확인)
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +NOTE +PREDICATE +ALIAS'));
```

---

## 결론

- **정렬은 비싸다**. 가장 확실한 해법은 **인덱스가 만들어내는 순서**와 **쿼리의 요구 순서**를 **일치**시키는 것이다.
- `ORDER BY`는 **ASC/DESC·NULLS 규칙까지 포함**해 인덱스로 대체하고, `GROUP BY`는 **해시 집계** 또는 **NOSORT**가 되도록 **입력을 설계**하라.
- “왜 소트가 없어졌는지”는 **`DBMS_XPLAN`과 `V$` 통계**로 **증명**하라. 그렇게 하면 **TEMP 스필/작업영역 패스**가 줄며, **응답시간·스루풋**이 눈에 띄게 개선된다.
