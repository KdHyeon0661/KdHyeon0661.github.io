---
layout: post
title: DB 심화 - 인덱스를 이용한 소트 연산 대체
date: 2025-11-21 23:25:23 +0900
category: DB 심화
---
# 인덱스를 이용한 소트 연산 대체 — SORT ORDER BY / SORT GROUP BY 없애는 설계와 함정

## 0) 왜 “인덱스로 소트를 대체”해야 하나?

대용량 SQL에서 `SORT ORDER BY`, `SORT GROUP BY`는 늘 **비용·리스크가 큰 연산**이다.

- **메모리 내 소트(optimal)**면 빠르지만,
- 입력이 커지거나 DOP가 커지면 **워크에어리어 스필**이 발생해서 `direct path write temp / read temp`가 늘고,
- 병렬이면 **재분배(PX SEND RANGE/HASH) + 로컬/글로벌 소트**까지 붙어 TEMP·네트워크가 터지기 쉽다.

따라서 최우선 튜닝 전략은 딱 하나다.

> **“정렬이 필요한 결과라면, 애초에 정렬된 순서로 읽어오자.”**

B-Tree 인덱스는 **키 순으로 저장/유지되므로 자연 정렬 순서 자체가 존재**하고, 옵티마이저가 그 순서를 그대로 활용하면 소트 연산을 완전히 제거할 수 있다. :contentReference[oaicite:0]{index=0}

---

## 1) 정렬 대체의 기본 원리(충분조건)

### 1.1 ORDER BY 대체의 충분조건(직관)

정렬 요구가 다음을 전부 만족하면 소트가 없어질 수 있다.

1) **ORDER BY 리스트가 인덱스 키 순서/방향/NULLS 규칙과 동일**  
2) 액세스 경로가 **정렬을 보장하는 인덱스 스캔**이어야 함  
   - `INDEX RANGE SCAN`  
   - `INDEX FULL SCAN (ASCENDING/DESCENDING)`  
3) 조인/필터가 **그 순서를 깨지 않게** 설계되어야 함.

> 즉,  
> $$\text{Index Order} \equiv \text{ORDER BY Keys (same columns, same directions, same NULLS)}$$  
> 그리고 **정렬 보장 스캔**이 전제.

### 1.2 IFFS(Index Fast Full Scan)는 왜 안 되는가?

`INDEX FAST FULL SCAN`은 인덱스를 **테이블 풀스캔처럼 멀티블록/병렬/랜덤 방식으로 읽는다.**  
그래서 **인덱스의 키 순서를 “그대로” 보장하지 않는다.** :contentReference[oaicite:1]{index=1}

정렬 제거 목적이라면 IFFS가 아닌 **정렬 보장 스캔(Full/Range Scan)**으로 유도해야 한다.

---

## 2) `SORT ORDER BY` 대체 — ORDER BY Elimination

아래 실습 스키마는 그대로 사용해도 된다(샘플 데이터는 US/EU 중심 코드로).

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';

DROP TABLE d_product PURGE;
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

DROP TABLE f_sales PURGE;
CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  sales_dt  DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
);

INSERT INTO d_product VALUES (10,'ELEC','US_B0');
INSERT INTO d_product VALUES (20,'HOME','DE_B1');

INSERT INTO f_sales VALUES (1001,10,DATE '2025-02-03',1,10000);
INSERT INTO f_sales VALUES (1002,20,DATE '2025-02-05',2,15000);
INSERT INTO f_sales VALUES (1003,10,DATE '2025-02-10',1, 9000);
COMMIT;

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'D_PRODUCT');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'F_SALES');
END;
/
```

### 2.1 단일 컬럼 정렬 제거(ASC/DESC)

#### (A) 소트가 필요한 기본형

```sql
SELECT sales_id, amount
FROM   f_sales
ORDER  BY amount DESC;
-- PLAN: SORT ORDER BY
```

#### (B) DESC 인덱스로 완전 제거

```sql
CREATE INDEX ix_amt_desc ON f_sales(amount DESC);

SELECT /*+ INDEX_DESC(f_sales ix_amt_desc) */
       sales_id, amount
FROM   f_sales
ORDER  BY amount DESC;
-- PLAN 기대:
-- INDEX FULL SCAN (DESCENDING)
-- SORT ORDER BY 미출현
```

**포인트**

- 인덱스가 이미 내림차순으로 정렬되어 있으므로 **추가 소트가 불필요**. :contentReference[oaicite:2]{index=2}
- 만약 옵티마이저가 IFFS를 선택하면 정렬이 보장되지 않으므로 소트가 다시 생긴다. :contentReference[oaicite:3]{index=3}

### 2.2 복합 정렬 제거(여러 컬럼/혼합 방향)

요구 정렬이:

```sql
ORDER BY sales_dt DESC, amount DESC
```

이면 인덱스도 **동일 순서·방향**으로 만든다.

```sql
CREATE INDEX ix_dt_amt_desc ON f_sales(sales_dt DESC, amount DESC);

SELECT /*+ INDEX_DESC(f_sales ix_dt_amt_desc) */
       sales_id, sales_dt, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01'
ORDER  BY sales_dt DESC, amount DESC;
-- PLAN 기대:
-- INDEX RANGE SCAN DESCENDING
-- SORT ORDER BY 제거
```

**왜 RANGE SCAN이어도 정렬이 유지되나?**

- B-Tree는 선두 컬럼(=sales_dt) 기준으로 범위를 자르면  
  그 범위 내부는 **sales_dt DESC → amount DESC 순서가 그대로 유지**된다.

### 2.3 Top-N에서의 “정렬 완전 제거”

Top-N은 보통 `SORT ORDER BY STOPKEY`로 줄일 수 있지만,  
**인덱스로 읽는 순간 STOPKEY만 남기고 소트를 없앨 수 있다.**

```sql
-- 월간 상위 100건
SELECT sales_id, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01'
ORDER  BY amount DESC
FETCH  FIRST 100 ROWS ONLY;
-- PLAN: SORT ORDER BY STOPKEY (부분 힙)

-- 인덱스 기반 완전 제거
SELECT /*+ INDEX_DESC(f_sales ix_amt_desc) */
       sales_id, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01'
AND    sales_dt <  DATE '2025-03-01'
FETCH  FIRST 100 ROWS ONLY;
-- PLAN:
-- INDEX DESC RANGE/FULL SCAN + STOPKEY
-- SORT 없음
```

정렬키 인덱스를 타면, 스캔 자체가 이미 “상위부터” 나오므로  
`FETCH FIRST n`은 **읽다가 n개 채우면 즉시 중단**하는 작업으로 바뀐다.

### 2.4 키셋(Seek) 페이지네이션으로 OFFSET 정렬 비용 제거

OFFSET은 **앞 부분을 버리기 위해 정렬/스캔을 끝까지 끌고 가는** 구조라 대용량에서 치명적이다.

```sql
-- 정렬키 3개를 “전역 키”로 고정
CREATE INDEX ix_seek
ON f_sales(sales_dt DESC, amount DESC, sales_id DESC);

-- 1페이지
SELECT /*+ INDEX_DESC(f_sales ix_seek) */
       sales_id, sales_dt, amount
FROM   f_sales
ORDER  BY sales_dt DESC, amount DESC, sales_id DESC
FETCH  FIRST 50 ROWS ONLY;

-- 2페이지: 직전 페이지 마지막 키(:dt0,:amt0,:id0)
SELECT /*+ INDEX_DESC(f_sales ix_seek) */
       sales_id, sales_dt, amount
FROM   f_sales
WHERE  (sales_dt, amount, sales_id) < (:dt0, :amt0, :id0)
ORDER  BY sales_dt DESC, amount DESC, sales_id DESC
FETCH  FIRST 50 ROWS ONLY;
-- PLAN: INDEX RANGE SCAN DESC, SORT 없음
```

---

## 3) `SORT GROUP BY` 대체 — HASH / NOSORT / ELIMINATION

GROUP BY의 소트 제거는 크게 세 가지 길이 있다.

1) **HASH GROUP BY**(정렬 없는 집계)  
2) **GROUP BY NOSORT**(정렬된 입력을 그대로 그룹핑)  
3) **GROUP BY ELIMINATION**(유니크/PK 조건이면 그룹핑 자체 제거)

### 3.1 해시 집계(HASH GROUP BY)로 소트 제거

```sql
SELECT prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP  BY prod_id;
-- PLAN: 상황에 따라 SORT GROUP BY or HASH GROUP BY

-- 해시 집계 유도(비교)
SELECT /*+ USE_HASH_AGGREGATION */
       prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP  BY prod_id;
-- PLAN 기대: HASH GROUP BY (정렬 없음)
```

해시 집계는 **입력 순서가 없어도** 그룹을 만들 수 있어  
정렬 기반 `SORT GROUP BY`를 없애는 가장 일반적인 방법이다.

> 단, 해시 테이블이 PGA를 넘으면 **TEMP 스필(onepass/multipass)**이 생길 수 있다.  
> 이때 대기는 `direct path write/read temp`로 나타난다.  
> 그래도 “정렬 소트”가 아니라 **해시 파티션 스필**이므로 구조적으로 더 유리한 경우가 많다.

### 3.2 GROUP BY NOSORT의 원리

핵심은 이것이다.

> **입력이 이미 “그룹 키 순서”로 올라오면 GROUP BY는 소트 없이도 가능하다.**

옵티마이저는 그때 플랜에 `SORT GROUP BY NOSORT`를 붙인다.  
그 의미는 “**그룹 연산은 하되, 소트는 하지 않는다**”이다. :contentReference[oaicite:4]{index=4}

#### NOSORT가 잘 되는 경험칙

- 그룹 키가 **인덱스 선두 접두(prefix)**  
- 인덱스 스캔이 **그룹별 연속 구간을 공급**  
- WHERE 절이 선두 컬럼 접근에 친화적  
- 조인/필터가 순서를 깨지 않음

#### 예제: (prod_id, sales_dt) 인덱스로 그룹 소트 제거

```sql
CREATE INDEX ix_prod_dt ON f_sales(prod_id, sales_dt);

SELECT /*+ INDEX(f_sales ix_prod_dt) */
       prod_id, COUNT(*), SUM(amount)
FROM   f_sales
WHERE  sales_dt >= :lo
AND    sales_dt <  :hi
GROUP  BY prod_id;
-- PLAN 기대:
-- INDEX RANGE SCAN (ix_prod_dt)
-- SORT GROUP BY NOSORT  (또는 HASH GROUP BY)
```

인덱스가 `prod_id` 순으로 rows를 올려주므로  
GROUP BY가 **순서 유지 입력을 받아 NOSORT가 성립**한다. :contentReference[oaicite:5]{index=5}

#### 다중 컬럼 그룹도 동일

```sql
SELECT /*+ INDEX(f_sales ix_prod_dt) */
       prod_id, sales_dt, COUNT(*), SUM(amount)
FROM   f_sales
WHERE  sales_dt >= :lo
AND    sales_dt <  :hi
GROUP  BY prod_id, sales_dt;
```

- 인덱스 순서가 `(prod_id → sales_dt)`이므로  
  입력은 이미 `prod_id, sales_dt` 그룹 기준으로 정렬돼 있다.

### 3.3 GROUP BY ELIMINATION(그룹 연산 자체 제거)

GROUP BY 대상이 **PK/유니크**이고 **NOT NULL**이면  
“그룹을 만들 이유가 없다”고 판단해 GROUP BY 자체를 제거할 수 있다. :contentReference[oaicite:6]{index=6}

```sql
-- PK(id) 테이블에서 id로 그룹핑
SELECT id, COUNT(*)
FROM   t_pk
GROUP  BY id;
-- 최신 옵티마이저에서는 GROUP BY 제거 가능
```

**실무 주의사항(매우 중요)** :contentReference[oaicite:7]{index=7}

- 유니크/PK라도 **컬럼이 NOT NULL이어야** 제거가 가능
- 인덱스가 INVISIBLE이면 제거가 막힐 수 있음
- **복합 PK** 전체를 GROUP BY 해야 제거가 가능하며,
  일부 컬럼만 그룹하면 제거가 안 되고 `NOSORT` 정도만 성립할 수 있다.

---

## 4) 인덱스가 소트를 대체하지 못하는 대표 함정들

아래 패턴들은 실무에서 “왜 소트가 안 없어지냐?”의 90%를 만든다.

### 4.1 IFFS 선택

**문제**: `INDEX FAST FULL SCAN`은 순서를 보장하지 않아 ORDER BY 제거가 불가. :contentReference[oaicite:8]{index=8}

**대책**

```sql
SELECT /*+ INDEX_DESC(f_sales ix_dt_amt_desc) */ ...
-- 또는 IFFS 유도 힌트/병렬 인덱스 스캔을 회피
```

### 4.2 정렬/그룹 키가 인덱스 접두가 아님

- 인덱스가 `(A,B)`인데 `ORDER BY B`만 필요  
- 또는 `GROUP BY B`만 필요

접두 불일치면 **인덱스 순서가 정렬 조건을 보장하지 못한다.**

**대책**: 정렬/그룹에 맞는 별도 인덱스(또는 FBI).

### 4.3 방향/NULLS 규칙 불일치

`ORDER BY col DESC NULLS LAST`인데  
인덱스는 `col ASC NULLS FIRST`라면 결국 소트가 필요.

**대책**: **정렬 규칙에 딱 맞춘 인덱스** 재설계.

### 4.4 함수/표현식 기반 정렬/그룹(인덱스 없음)

```sql
ORDER BY SUBSTR(brand,1,3)
GROUP BY TRUNC(sales_dt)
```

표현식 자체에 대한 인덱스가 없으면 소트를 피할 수 없다.

**대책: FBI 또는 가상 컬럼**

```sql
-- 가상 컬럼
ALTER TABLE f_sales
  ADD sales_dt_d GENERATED ALWAYS AS (TRUNC(sales_dt)) VIRTUAL;
CREATE INDEX ix_sales_dt_d ON f_sales(sales_dt_d);

-- FBI
CREATE INDEX ix_brand3_fbi ON d_product(SUBSTR(brand,1,3));
```

### 4.5 조인 이후 순서가 깨짐

조인 방식에 따라 인덱스 순서가 **조인 결과의 전역 순서를 보장하지 못한다.**

- NL 조인은 “드라이빙 인덱스 순서”가 유지될 수 있음
- 해시/소트-머지 조인은 내부에서 데이터를 섞으므로 대개 순서가 깨짐

**대책**

- 정렬키 인덱스를 가진 테이블이 드라이빙이 되도록 `LEADING/USE_NL`
- 또는 조인 후 소트를 감수하되 입력량을 줄이는 방향으로 튜닝

### 4.6 UNION / DISTINCT / ROLLUP / CUBE

- `UNION`은 중복 제거가 필요해 `SORT UNIQUE`가 거의 필수  
  (정말 제거하려면 `UNION ALL` 구조로 바꾸어야 함)
- `DISTINCT`는 내부적으로 GROUP BY/SORT UNIQUE
- `ROLLUP/CUBE`는 계층/다단계 집계 때문에 정렬 기반이 섞이기 쉬움

### 4.7 윈도우 함수(분석 함수)

`OVER(PARTITION BY ... ORDER BY ...)`는  
파티션별 정렬이 필요하여 `WINDOW SORT`가 잘 생긴다.

인덱스로 비용을 **줄일 수는** 있어도  
프레임 정의에 따라 **완전 제거는 제한적**이다.

### 4.8 파티션 테이블 + 로컬 인덱스

여러 파티션을 읽을 때 **파티션 간 글로벌 순서가 보장되지 않아**  
`MERGE SORT`가 붙을 수 있다.

**대책**

- 글로벌 인덱스(주의: 파티션 DDL 비용 상승)
- 또는 정렬 키에 파티션 키를 포함해 “파티션 별 로컬 순서 + 상위 병합 최소화” 설계

### 4.9 동적 ORDER BY

사용자 입력으로 컬럼/방향이 바뀌면  
**하나의 인덱스로 모든 정렬을 커버할 수 없다.**

**대책**

- 정렬 후보가 제한적이면 **후보별 인덱스 + 동적 힌트 분기**
- 아니면 Top-N/해시 집계 등과 함께 **소트를 일부 감수**

---

## 5) 실전 리팩터링: 전/후 비교

### 5.1 월간 상위 100건(카테고리=ELEC) — 정렬 제거

#### Before (소트 필요)

```sql
SELECT s.sales_id, s.prod_id, s.amount
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'
AND    s.sales_dt >= DATE '2025-02-01'
AND    s.sales_dt <  DATE '2025-03-01'
ORDER  BY s.amount DESC
FETCH  FIRST 100 ROWS ONLY;
-- PLAN: SORT ORDER BY STOPKEY
```

#### After (NL + 인덱스 DESC + STOPKEY)

```sql
CREATE INDEX ix_dp_cat_prod ON d_product(category, prod_id);
CREATE INDEX ix_amt_desc    ON f_sales(amount DESC);

SELECT /*+ LEADING(p) USE_NL(s)
           INDEX(p ix_dp_cat_prod)
           INDEX_DESC(s ix_amt_desc) */
       s.sales_id, s.prod_id, s.amount
FROM   d_product p
JOIN   f_sales   s ON s.prod_id = p.prod_id
WHERE  p.category = 'ELEC'
AND    s.sales_dt >= DATE '2025-02-01'
AND    s.sales_dt <  DATE '2025-03-01'
FETCH  FIRST 100 ROWS ONLY;
-- PLAN 기대:
-- INDEX DESC RANGE/FS + STOPKEY
-- SORT 없음
```

**핵심**

- 드라이빙을 제품(소형)으로 잡고
- 매출은 금액 DESC 인덱스에서 Top-N을 “그냥 읽어오기”

### 5.2 일자/상품별 집계 — NOSORT 유도

#### Before

```sql
SELECT prod_id, sales_dt, COUNT(*), SUM(amount)
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi
GROUP  BY prod_id, sales_dt;
-- PLAN: SORT GROUP BY
```

#### After

```sql
CREATE INDEX ix_prod_dt ON f_sales(prod_id, sales_dt);

SELECT /*+ INDEX(f_sales ix_prod_dt) */
       prod_id, sales_dt, COUNT(*), SUM(amount)
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi
GROUP  BY prod_id, sales_dt;
-- PLAN: SORT GROUP BY NOSORT (또는 HASH GROUP BY)
```

---

## 6) 검증 루틴: “소트가 진짜 없어졌는지” 증명하는 법

### 6.1 실제 실행계획 확인

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +NOTE +ALIAS'));
```

**확인 포인트**

- `SORT ORDER BY` / `SORT GROUP BY` 라인이 사라졌는가?
- `INDEX FULL SCAN (ASC/DESC)` 또는 `INDEX RANGE SCAN`으로 바뀌었는가?
- `INDEX FAST FULL SCAN`이 있으면 ORDER BY 제거 실패 신호. :contentReference[oaicite:9]{index=9}

### 6.2 소트/워크에어리어 통계 비교

```sql
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN (
  'sorts (memory)','sorts (disk)',
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass'
);
```

- `sorts (disk)` 증가 0이면 TEMP 소트 제거 성공
- onepass/multipass 감소는 해시/정렬 스필 완화 성공

---

## 7) 운영 체크리스트(바로 쓰는 결론)

- [ ] **IFFS 금지**: 정렬 대체 목적이면 `INDEX FULL/RANGE SCAN` 유도  
  (IFFS는 순서 보장 안 됨). :contentReference[oaicite:10]{index=10}
- [ ] **정렬키=인덱스키 일치**: 컬럼 순서/방향/NULLS 규칙까지 동일. :contentReference[oaicite:11]{index=11}
- [ ] WHERE 절이 선두 컬럼 범위를 줘도 **순서 유지되는지** 확인
- [ ] Top-N은 인덱스 + STOPKEY(+FETCH FIRST)로 **소트 제로화**
- [ ] GROUP BY는
  - 해시 집계(HASH GROUP BY)로 소트 제거
  - 또는 **인덱스 접두 순서 입력으로 NOSORT 유도**. :contentReference[oaicite:12]{index=12}
- [ ] 표현식 정렬/그룹은 **가상 컬럼/FBI**로 SARGable하게
- [ ] 조인이 순서를 깨면 NL 드라이빙 설계 또는 소트를 감수하되 입력을 줄여라
- [ ] 파티션 전역 순서가 필요하면 로컬 인덱스만 믿지 말고 **글로벌 전략 검토**
- [ ] 모든 개선은 `DBMS_XPLAN + V$ 통계`로 **정량 증명**

---

## 결론

정렬을 최적화하는 가장 확실한 방법은 “정렬을 잘 하는 것”이 아니라 **정렬을 안 하는 것**이다.  
B-Tree 인덱스의 자연 순서를 쿼리 요구와 **완전히 일치**시키고,  
옵티마이저가 **정렬 보장 스캔(Full/Range)**을 선택하도록 설계·힌트·통계를 맞추면

- `SORT ORDER BY`는 **0**
- `SORT GROUP BY`는 **HASH 또는 NOSORT**
- TEMP 스필/병렬 재분배 부담도 함께 줄어든다.

그리고 그 “0”은 반드시 플랜과 통계로 증명해야 한다.  
그 순간부터 정렬 튜닝은 감이 아니라 **재현 가능한 공학**이 된다.