---
layout: post
title: 형식언어와 오토마타 - 결정적 유한 인식기
date: 2025-06-12 22:20:23 +0900
category: 형식언어와 오토마타
---
# 결정적 유한 인식기와 정규 언어 (DFA & Regular Languages)

**결정적 유한 인식기(DFA, Deterministic Finite Automaton)**는 정규 언어를 인식하는 가장 기본적인 오토마타 모델입니다.

---

## & 개요

- 알파벳(유한 집합): $$\Sigma$$
- 문자열: $$w\in\Sigma^\*$$, 길이 $$|w|$$, 공백 문자열 $$\varepsilon$$
- 언어: $$L\subseteq\Sigma^\*$$
- 연결: $$xy$$, 거듭제곱: $$x^k$$, Kleene-별: $$L^\*=\bigcup_{k\ge0}L^k$$

---

## 결정적 유한 인식기 (DFA)

### 정의

DFA는 5-튜플
$$
M=(Q,\ \Sigma,\ \delta,\ q_0,\ F)
$$
로 정의됩니다.

- $$Q$$: 유한한 상태 집합
- $$\Sigma$$: 입력 알파벳
- $$\delta:Q\times\Sigma\to Q$$: 전이 함수(결정적—하나의 입력에 대해 **정확히 하나**의 다음 상태)
- $$q_0\in Q$$: 시작 상태
- $$F\subseteq Q$$: 받아들이는(accepting) 상태들의 집합

**확장 전이함수** $$\hat\delta:Q\times\Sigma^\*\to Q$$ 를 재귀적으로
$$
\hat\delta(q,\varepsilon)=q,\qquad
\hat\delta(q,xa)=\delta\big(\hat\delta(q,x),a\big)
$$
로 정의하면, **수용 언어**는
$$
L(M)=\{w\in\Sigma^\*\mid \hat\delta(q_0,w)\in F\}
$$
입니다.

### 동작 방식(절차적 요약)

1) $$q_0$$에서 시작 → 2) 입력을 왼쪽에서 오른쪽으로 한 글자씩 읽음 → 3) 매 글자마다 $$\delta$$에 따라 상태 이동 → 4) 입력 종료 시 현재 상태가 $$F$$에 있으면 **accept**, 아니면 **reject**.

---

## 전이 그래프 (Transition Graph)

- **정점(원)**: 상태, **겹원**: 받아들이는 상태
- **화살표**: 전이(라벨은 입력 기호), **왼쪽 외부 화살표**: 시작 상태 표시
- **결정성**: 상태·입력 조합마다 **하나의** 나가는 변만 존재

### 예제: ‘a’ 개수가 짝수인 언어

알파벳 $$\Sigma=\{a\}$$, 언어 $$L=\{w\in\{a\}^\*\mid \#a(w)\text{가 짝수}\}$$

- 상태: $$Q=\{q_0(\text{짝수}), q_1(\text{홀수})\}$$
- 시작/종료: $$q_0\in F$$
- 전이:
  - $$\delta(q_0,a)=q_1,\quad \delta(q_1,a)=q_0$$

**직관**: ‘a’를 볼 때마다 짝수↔홀수 상태가 토글.

**추적 예**
- 입력 `aaa`: $$q_0 \xrightarrow{a} q_1 \xrightarrow{a} q_0 \xrightarrow{a} q_1$$ → **reject**
- 입력 `aaaa`: $$q_0 \xrightarrow{a} q_1 \xrightarrow{a} q_0 \xrightarrow{a} q_1 \xrightarrow{a} q_0$$ → **accept**

---

## DFA가 인식하는 언어

### 수용 언어의 정의(재강조)

$$
L(M)=\{w\in\Sigma^\*\mid \hat\delta(q_0,w)\in F\}\,.
$$

### DFA ↔ 언어

- 어떤 언어를 DFA가 인식 가능하면 그 언어는 **정규 언어(regular)**.
- 정규 언어는 **DFA/NFA/정규표현식**으로 **동등하게** 표현 가능(§6 참조).

---

## 정규 언어 (Regular Languages)

### 정의(동치적 관점)

정규 언어 클래스는 다음 셋이 **동일**합니다.

1) 어떤 DFA가 인식하는 언어
2) 어떤 NFA(또는 $$\varepsilon$$-NFA)가 인식하는 언어
3) 어떤 정규표현식으로 생성되는 언어

### 닫힘 성질(폐쇄성)

정규 언어는 다음 연산에 대해 **닫혀** 있습니다.

- 합 $$L_1\cup L_2$$, 교 $$L_1\cap L_2$$, 차 $$L_1\setminus L_2$$, 여 $$\Sigma^\*\setminus L$$
- 연결 $$L_1\cdot L_2=\{xy\mid x\in L_1,y\in L_2\}$$
- Kleene-별 $$L^\*=\bigcup_{n\ge0}L^n$$
- 역(반전) $$L^R=\{w^R\mid w\in L\}$$
- 동형사상(이미지/역상)

**증명 스케치**
- **교집합**: 두 DFA의 **곱구성(product construction)**으로 새 DFA 구성
- **여집합**: DFA에서 **수용/비수용 상태를 뒤집기**(완전 DFA 필요)

### 예(대표 패턴)

- $$L=\{w\in\{a,b\}^\*\mid \text{‘ab’가 부분문자열로 등장}\}$$
- $$L=\{a^n\mid n\ \text{짝수}\}$$
- $$L=\{w\in\{0,1\}^\*\mid \text{2진수로 본 }w\text{가 }3\text{의 배수}\}$$  ← (mod 3 DFA로 인식)

> **상황 예시(스트리밍 검증)**: 로그 스트림에서 “에러 코드 E가 짝수 번” 또는 “마지막 3글자가 `abb`” 같은 규칙은 **상태수 고정** DFA로 선형 시간 판정 가능.

### 정규가 아닌 언어(비정규)

- $$L=\{a^n b^n\mid n\ge 0\}$$ (CFL이지만 **정규 아님**)
- $$L=\{ww\mid w\in\Sigma^\*\}$$ (**CFL도 아님**)

> 주의: “정규가 아니다” ⇒ 곧바로 “CFL이다”가 아님. 예컨대 $$\{ww\}$$는 **문맥자유도 아님**.

---

## DFA 설계 레시피(핵심 패턴 4종)

### 추적

- 아이디어: **2상태**로 토글.
- 예: `a`의 개수 짝수/홀수, 특정 문자 출현 짝/홀 등.

### 인식

- 아이디어: “현재까지의 **최장 일치 접미사**”를 상태로 유지.
- 예: $$(a\mid b)^\*abb$$
  - 상태 의미: `""`, `a`, `ab`, `abb(accept)`, 그리고 불일치 시 되돌림.

### 모듈러 카운팅(나머지)

- 아이디어: “현재까지의 **나머지**”를 상태로 유지.
- 예: 2진수 문자열의 값이 **3의 배수**
  - 상태: $$\{0,1,2\}$$(mod 3), 입력 0/1에 따라 $$r\mapsto (2r+a)\bmod 3$$.

### 금지 부분문자열 회피

- 아이디어: 금지 패턴의 **접두사 자동자**를 반전 활용.
- 예: `11`을 포함하지 않는 언어
  - 상태: “마지막 문자가 1인가?”를 기억하여 `1` 뒤의 또 `1`을 막음.

---

## DFA, NFA, 정규표현식의 동치(개요)

- **정리**: DFA ≡ NFA ≡ $$\varepsilon$$-NFA ≡ 정규표현식(이론적 의미)
  - 정규식 → (Thompson) → $$\varepsilon$$-NFA
  - $$\varepsilon$$-NFA → (ε-폐포) → NFA
  - NFA → (부분집합 구성) → DFA
  - DFA → (상태 집합을 정규식으로 제거) → 정규식

> **현실 주의**: 프로그래밍 언어의 정규식 엔진은 **역참조/전후방 탐색** 등 **정규 언어 밖**의 기능을 포함. 백트래킹 기반 엔진은 **최악 지수 시간**도 가능.

---

## 비정규성 판정(두 축)

### 펌핑 보조정리(정규)

**정리**: 정규 언어 $$L$$에 대해 $$\exists p$$ s.t. $$\forall s\in L, |s|\ge p$$ 이면
$$\exists x,y,z:\ s=xyz,\ |xy|\le p,\ |y|\ge1,\ \forall i\ge0:\ xy^iz\in L$$.

**증명 템플릿(귀류)**
1) 정규라고 가정하여 펌핑 길이 $$p$$ 존재
2) 반례 문자열 $$s$$를 **구성적으로 선택**
3) 임의의 분해 $$s=xyz$$에 대해 어떤 $$i$$에서 모순 유도

**예**: $$\{a^n b^n\}$$는 정규가 아님
- $$s=a^p b^p$$, $$|xy|\le p$$ ⇒ $$y=a^k(k\ge1)$$
- $$xy^2z=a^{p+k}b^p\notin L$$ (a/b 개수 불일치)

### Myhill–Nerode 정리

**정리**: $$x\equiv_L y \iff \forall z:\ xz\in L\Leftrightarrow yz\in L$$ 로 정의되는 우동치의 **동치류가 유한 개** ↔ $$L$$이 정규. 최소 DFA 상태 수 = 동치류 수.

**활용**: 서로 다른 접미사로 **무한히 구별되는 접두사 집합**을 잡아 **비정규성** 증명, 또는 **최소 상태 하한** 제시.

---

## 최소 DFA (Hopcroft 개요 + 예시)

### 파티션 정제(Partition Refinement)

1) 초기 분할: $$\{F,\ Q\setminus F\}$$
2) 어떤 블록을 문자 $$a\in\Sigma$$로 전이했을 때 행선지가 **서로 다른 블록**이면 블록 **분할**
3) 더 이상 분할되지 않을 때 수렴 → 각 블록이 최소 DFA의 상태

### 소형 예시(개략)

- 다섯 상태 중 일부가 동치라면 반복 정제로 3상태로 압축되는 과정을 표로 전개(블로그에 표/그림으로 배치 권장).

---

## 알고리즘/구성(코드 포함)

> 코드는 **교육용**으로 간단화했습니다. 실서비스라면 입력 검증 및 에러 처리, 성능 고려를 추가하세요.

### DFA 시뮬레이터

```python
class DFA:
    def __init__(self, states, alphabet, delta, start, accepts):
        self.states = set(states)
        self.alphabet = set(alphabet)
        self.delta = dict(delta)               # {(q,a): q'}
        self.start = start
        self.accepts = set(accepts)

    def run(self, s):
        q = self.start
        for ch in s:
            if ch not in self.alphabet:
                return False
            q = self.delta[(q, ch)]
        return q in self.accepts

# 예1: 'a' 개수 짝수

dfa_even_a = DFA(
    states={'q0','q1'},
    alphabet={'a'},
    delta={('q0','a'):'q1', ('q1','a'):'q0'},
    start='q0',
    accepts={'q0'}
)

print(dfa_even_a.run(""))       # True
print(dfa_even_a.run("aaa"))    # False
print(dfa_even_a.run("aaaa"))   # True
```

### NFA → DFA (부분집합 구성)

```python
from collections import defaultdict, deque

class NFA:
    def __init__(self, states, alphabet, delta, start, accepts):
        self.states = set(states)
        self.alphabet = set(alphabet)          # ε는 제외
        # delta: dict (q, a) -> set of q'
        self.delta = defaultdict(set)
        for (q,a), dests in delta.items():
            self.delta[(q,a)].update(dests)
        self.start = start
        self.accepts = set(accepts)

def nfa_to_dfa(nfa: NFA):
    # ε-이동이 없다 가정(있다면 ε-폐포로 먼저 제거)
    start_set = frozenset([nfa.start])
    qmap = {start_set: "S0"}                   # 집합 상태 → 이름
    rev = {"S0": start_set}

    work = deque([start_set])
    dfa_states = {"S0"}
    dfa_delta = {}
    dfa_accepts = set()
    name_id = 1

    def name_of(state_set):
        nonlocal name_id
        if state_set not in qmap:
            qmap[state_set] = f"S{name_id}"
            rev[f"S{name_id}"] = state_set
            dfa_states.add(f"S{name_id}")
            name_id += 1
        return qmap[state_set]

    while work:
        T = work.popleft()
        T_name = qmap[T]
        if any(q in nfa.accepts for q in T):
            dfa_accepts.add(T_name)
        for a in nfa.alphabet:
            U = set()
            for q in T:
                U |= nfa.delta.get((q,a), set())
            U = frozenset(U)
            if not U:
                continue
            U_name = name_of(U)
            dfa_delta[(T_name, a)] = U_name
            if U_name not in dfa_states:
                dfa_states.add(U_name)
            if U not in qmap or U_name not in rev:
                # already handled by name_of
                pass
            if U_name not in [qmap[x] for x in work]:
                if U_name not in [T_name]:
                    work.append(U)

    return DFA(states=dfa_states, alphabet=nfa.alphabet,
               delta=dfa_delta, start="S0", accepts=dfa_accepts)

# 간단 예: (a|b)*abb

nfa = NFA(
    states={'q0','q1','q2','q3'},
    alphabet={'a','b'},
    delta={
      ('q0','a'):{'q0','q1'}, ('q0','b'):{'q0'},
      ('q1','b'):{'q2'},
      ('q2','b'):{'q3'},
    },
    start='q0',
    accepts={'q3'}
)
dfa = nfa_to_dfa(nfa)
print(dfa.run("abb"))       # True
print(dfa.run("aabb"))      # True
print(dfa.run("ababa"))     # False
```

> 교육적 단순화를 위해 **dead/sink 상태** 추가·완전화 처리는 생략했습니다. 블로그에선 “완전 DFA 만들기(정의역 전부 채우기)” 팁을 각주로 덧붙이세요.

### Hopcroft 최소화(핵심 구조)

```python
def hopcroft_minimize(dfa: DFA):
    # 완전 DFA(모든 (q,a) 정의)라 가정. 아니라면 먼저 sink 상태로 완전화.
    alphabet = dfa.alphabet
    P = [dfa.accepts, dfa.states - dfa.accepts]     # 초기 분할
    W = [dfa.accepts.copy()]                        # worklist

    def involved(X, a):
        # X에 들어가는 전이의 원소 역상 집합
        inv = set()
        for (q, ch), q2 in dfa.delta.items():
            if ch == a and q2 in X:
                inv.add(q)
        return inv

    while W:
        A = W.pop()
        for a in alphabet:
            X = involved(A, a)
            newP = []
            for Y in P:
                i = Y & X
                d = Y - X
                if i and d:
                    newP.extend([i, d])
                    if Y in W:
                        W.remove(Y); W.extend([i, d])
                    else:
                        # 작은 쪽을 worklist에
                        W.append(i if len(i) <= len(d) else d)
                else:
                    newP.append(Y)
            P = newP

    # 각 블록을 하나의 상태로 축약
    repr_map = {}
    for block in P:
        rep = next(iter(block))
        for q in block:
            repr_map[q] = rep

    new_states = set(repr_map.values())
    new_start  = repr_map[dfa.start]
    new_accepts = {repr_map[q] for q in dfa.accepts}
    new_delta = {}
    for (q,a), q2 in dfa.delta.items():
        new_delta[(repr_map[q], a)] = repr_map[q2]

    return DFA(new_states, alphabet, new_delta, new_start, new_accepts)
```

**활용 가이드**
- “비슷해 보이는 상태가 정말 같은가?”를 **자동**으로 판별/병합
- 렉서·패턴 매칭기에서 **최소 DFA**는 테이블·메모리 축소에 직결

---

## 사례로 이해하는 DFA

### 접미사 `abb` 인식 DFA

- 상태 의미: 지금까지 읽은 접미사 중 ‘abb’에 대한 **최장 일치 길이**(0,1,2,3).
- 전이 규칙은 KMP 접두사함수 감각과 유사(불일치 시 돌아갈 곳을 정의)

### 2진수로 3의 배수

- 상태: {0,1,2} (나머지)
- 입력 0/1에 대해 $$r\gets (2r+a)\bmod 3$$
- 시작/종료: {0} (빈 문자열=0)

### 금지 패턴 `11` 방지

- 상태: `last_is_1` 여부
- `1` 뒤에 또 `1`이면 거부(또는 sink로 감금)
- “연속 실패 금지”, “이중 승인 금지” 같은 **간단 정책**을 DFA로 표현

---

## 흔한 실수 & 팁

- **펌핑 보조정리 오해**: “펌핑 가능 → 정규”는 **거짓**. 펌핑은 **필요조건**임.
- **정규식 엔진 혼동**: 현실 엔진의 역참조·전후방은 이론 정규식에 **없는 기능** → 성능 폭발 주의.
- **CFL 비폐쇄성 망각**: CFL은 교집합/여집합에 일반적으로 닫혀 있지 않음.
- **여집합 만들 때**: DFA가 **완전**해야 수용/비수용 뒤집기가 올바름.

---

## 연습 문제(해설 스케치)

1) $$L=\{w\in\{a,b\}^\*\mid \#a(w)\text{가 홀수}\}$$ DFA 설계
- 짝/홀 2상태, 시작은 짝수, 수용은 홀수.

2) $$L=\{w\in\{0,1\}^\*\mid w \text{가 }01\text{로 끝난다}\}$$ DFA 설계
- 접미사 최장일치 0/01/그 외 상태.

3) $$L=\{a^n b^n\mid n\ge0\}$$가 정규가 아님을 보이기
- 펌핑 보조정리 또는 Myhill–Nerode로 무한 동치류.

4) 최소 DFA 구하기
- 임의 DFA에서 Hopcroft로 상태 수를 줄이고, 각 블록이 하나의 상태.

5) $$(a\mid b)^\*abb$$ NFA를 만들고 DFA로 변환
- Thompson → $$\varepsilon$$-NFA → 부분집합 구성.

---

## 결론

DFA는 **정규 언어**를 가장 투명하게 설명하는 계산 모델입니다.
- 설계 레시피(패리티, 접미사, 모듈러, 금지 패턴)로 대부분의 “스트리밍 규칙”을 빠르게 모델링 가능
- 정규 언어의 **닫힘성**과 **비정규성 판정(펌핑·Myhill–Nerode)**으로 이론적 경계를 명확히
- NFA/정규표현식과의 **동치**, **최소화** 알고리즘까지 익히면 **렉서/패턴 매칭/입력 검증**에 직접 응용된다.
