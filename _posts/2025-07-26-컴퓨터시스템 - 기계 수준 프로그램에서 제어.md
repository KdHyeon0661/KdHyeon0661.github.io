---
layout: post
title: 컴퓨터시스템 - 기계 수준 프로그램에서 제어
date: 2025-07-26 17:20:23 +0900
category: 컴퓨터시스템
---
# 💡 기계 수준 프로그램에서 제어와 데이터의 종합 적용

## 1. 들어가며

기계 수준의 프로그램은 고급 언어에서 표현된 연산, 제어 흐름, 자료 구조 등을 CPU가 이해할 수 있는 **어셈블리 수준의 명령어**로 변환한 것입니다. 고급 언어에서는 추상적으로 보이는 `if`, `while`, `struct`, `array`, `function` 같은 구조들이, 기계 수준에서는 레지스터와 메모리, 분기 명령, 스택 등을 통해 **제어 흐름(control flow)**과 **데이터 구조(data structure)**가 종합적으로 동작하게 됩니다.

기계 수준에서의 제어와 데이터는 밀접하게 연결되어 있으며, 하나의 명령어가 제어 흐름을 바꾸고, 또 다른 명령어는 데이터를 조작하는 방식으로 협력합니다.

---

## 2. 기본 구조

### 2.1 제어 흐름의 핵심 구성 요소

- **분기(branch)**: 조건에 따라 실행 위치를 바꿈 (예: `jmp`, `je`, `jne`)
- **함수 호출(call/ret)**: 서브루틴의 시작과 종료
- **조건 판단(cmp/test)**: 조건 분기 전 비교 연산
- **루프 구조**: 반복 제어 (일반적으로 조건 분기 + 레지스터)

### 2.2 데이터 흐름의 핵심 구성 요소

- **레지스터(register)**: 연산 대상, 주소 저장
- **스택(stack)**: 함수 호출 시 지역 변수, 복귀 주소 저장
- **힙(heap)**: 동적 메모리 할당에 사용
- **전역 데이터(global data)**: 프로그램 시작 시부터 끝까지 유지되는 변수

---

## 3. 기계 수준 제어 흐름의 실현

### 3.1 조건 분기

조건 분기는 `cmp`, `test` 등의 명령어와 조건 분기 명령어 (`je`, `jne`, `jg`, `jl`, ...)로 이루어집니다.

```asm
cmp %eax, %ebx
je equal_label
```

- `cmp`: 두 값을 빼고 플래그 레지스터를 설정 (결과는 저장되지 않음)
- `je`: Zero flag(ZF)가 설정되어 있으면 분기

### 3.2 루프 구현

```c
for (int i = 0; i < n; i++) {
    sum += A[i];
}
```

이 코드는 다음과 같이 변환됩니다:

```asm
movl $0, %ecx        # i = 0
movl $0, %eax        # sum = 0
loop_start:
    cmpl %ecx, %edx  # n과 i 비교 (edx = n)
    jle loop_end     # i >= n 이면 종료
    movl A(,%ecx,4), %ebx
    addl %ebx, %eax
    incl %ecx
    jmp loop_start
loop_end:
```

### 3.3 함수 호출과 복귀

```c
int add(int x, int y) {
    return x + y;
}
```

이 코드는 다음 어셈블리로 표현됩니다:

```asm
add:
    push %ebp
    mov %esp, %ebp
    mov 8(%ebp), %eax
    add 12(%ebp), %eax
    pop %ebp
    ret
```

---

## 4. 기계 수준 데이터의 실현

### 4.1 스택 프레임 구조

함수 호출 시 다음과 같은 구조의 **스택 프레임(stack frame)**이 만들어집니다.

```
|-------------------| ← %ebp + offset
| argument n        |
| ...               |
| argument 1        |
| return address    |
| saved %ebp        |
| local variable 1  |
| ...               |
| local variable n  | ← %esp
```

- `%esp` (stack pointer): 현재 스택의 최상단
- `%ebp` (base pointer): 현재 함수의 기준 위치

### 4.2 레지스터의 역할

- `%eax`, `%ebx`, `%ecx`, `%edx`: 일반적인 연산
- `%esi`, `%edi`: 배열 접근, 포인터 연산
- `%ebp`: 스택 프레임 기준
- `%esp`: 현재 스택의 위치

---

## 5. 제어와 데이터의 종합 예제

### 5.1 구조체 + 배열 + 함수 호출

```c
typedef struct {
    int id;
    int score;
} Student;

void update(Student* s, int delta) {
    s->score += delta;
}

void update_all(Student* arr, int len, int delta) {
    for (int i = 0; i < len; i++) {
        update(&arr[i], delta);
    }
}
```

#### 어셈블리 레벨 개요

```asm
update_all:
    push %ebp
    mov %esp, %ebp
    movl 8(%ebp), %eax    # arr
    movl 12(%ebp), %ecx   # len
    movl 16(%ebp), %edx   # delta
    movl $0, %esi         # i = 0

.L_loop:
    cmpl %esi, %ecx
    jge .L_end
    movl %esi, %edi
    sall $3, %edi         # sizeof(Student) == 8, shift by 3
    addl %eax, %edi       # &arr[i]
    push %edx             # delta
    push %edi             # &arr[i]
    call update
    addl $8, %esp         # pop 2 args
    incl %esi
    jmp .L_loop

.L_end:
    pop %ebp
    ret
```

---

## 6. 제어 흐름 + 데이터의 최적화

기계 수준에서는 다음과 같은 최적화가 이루어집니다:

- **루프 풀기(loop unrolling)**: 반복 횟수 감소로 분기 비용 줄임
- **레지스터 재활용**: 메모리 접근 최소화
- **조건 병합**: 여러 조건을 하나의 플래그 비교로 단순화

---

## 7. C 예제와 어셈블리 대응

```c
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```

### 대응 어셈블리

```asm
factorial:
    push %ebp
    mov %esp, %ebp
    mov 8(%ebp), %eax
    cmp $1, %eax
    jg recurse
    mov $1, %eax
    jmp done

recurse:
    mov 8(%ebp), %eax
    decl %eax
    push %eax
    call factorial
    add $4, %esp
    mov 8(%ebp), %ecx
    imul %ecx, %eax

done:
    pop %ebp
    ret
```

---

## 8. 요약: 제어와 데이터의 종합

| 요소 | 제어 흐름에 기여 | 데이터에 기여 |
|------|-------------------|----------------|
| 레지스터 | 조건 비교, 분기 대상 주소 저장 | 연산 피연산자 저장 |
| 메모리 주소 | 분기 타겟 계산 | 배열, 구조체, 포인터 참조 |
| 스택 | 함수 호출 흐름 제어 | 지역 변수, 복귀 주소 |
| 조건 코드 | 분기 결정 | 비교 연산 결과 |

---

## 9. 마무리

기계 수준에서의 제어 흐름과 데이터 흐름은 고급 언어의 추상적 구조를 실제 하드웨어에서 작동하게 만드는 실체입니다. 이 둘의 종합은 효율적인 프로그램의 실행, 디버깅, 성능 분석에 핵심적인 통찰을 제공합니다.

특히 컴파일러가 생성한 어셈블리 코드를 분석하면 고급 언어로는 보이지 않는 최적화나 버그의 원인을 찾을 수 있으며, 하드웨어 수준에서의 동작을 명확히 이해할 수 있습니다.