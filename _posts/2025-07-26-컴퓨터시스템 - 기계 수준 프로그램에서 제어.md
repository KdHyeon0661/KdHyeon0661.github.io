---
layout: post
title: 컴퓨터시스템 - 기계 수준 프로그램에서 제어
date: 2025-07-26 17:20:23 +0900
category: 컴퓨터시스템
---
# 기계 수준 프로그램에서 제어와 데이터의 종합 적용

## 1. 큰 그림: 제어 흐름과 데이터 흐름의 만남

- **제어 흐름**: 분기/루프/호출/복귀가 **PC(프로그램 카운터)**를 바꾼다.  
- **데이터 흐름**: 연산을 위한 피연산자는 **레지스터**와 **메모리(스택/힙/전역)** 사이를 오간다.  
- 두 축은 항상 **함께** 움직인다:  
  - 분기 판단에는 **데이터 비교**가 필요하고(조건 코드, 플래그),  
  - 데이터 적재/저장은 **루프 인덱스와 주소 계산**이라는 제어적 패턴 위에서 벌어진다.

**주소 계산의 표준형**(행우선, 1차원·2차원 일반화):

$$
\text{addr}(A[i]) = \text{base}(A) + i \cdot \text{sizeof}(T)
$$

$$
\text{addr}(A[i][j]) = \text{base}(A) + \left(i \cdot N_{\text{cols}} + j\right)\cdot \text{sizeof}(T)
$$

---

## 2. 실행 환경과 자료 배치(메모리·레지스터·스택)

### 2.1 프로세스 메모리 대략도

```
높은 주소
+------------------+  ← stack top (downward)
|       Stack      |
+------------------+
|        Heap      |  ← malloc/new
+------------------+
| .bss (zero-init) |
| .data (init)     |
| .rodata          |
| .text (code)     |
+------------------+  낮은 주소
```

- **.text**: 명령어(실행 코드, R-X)  
- **.data/.bss**: 전역/정적 데이터(R/W)  
- **heap**: 동적 메모리  
- **stack**: 호출 프레임, 지역 변수, 복귀 주소, 임시 저장

### 2.2 x86-64(SysV) 주요 레지스터(발췌)

| 레지스터 | 용도(관례) |
|---|---|
| `%rax` | 반환값(정수/포인터) |
| `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9` | 함수 인자 1~6 |
| `%rbp` | 프레임 포인터(선택적) |
| `%rsp` | 스택 포인터 |
| `%rbx`, `%rbp`, `%r12`~`%r15` | callee-saved |
| `%r10`, `%r11`, … | caller-saved(일반) |

> **호출 규약(요지)**:  
> - 인자 1~6은 레지스터로, 초과 인자는 스택으로.  
> - **caller-saved**는 호출자가 보존, **callee-saved**는 피호출자가 보존.

---

## 3. 조건과 분기: 플래그 → 분기/이동

### 3.1 조건 판단과 분기

x86-64의 `cmp`/`test`는 결과를 저장하지 않고 **플래그 레지스터(ZF/SF/OF/CF)**를 갱신한다.

```asm
# if (a <= b) goto L
cmp    %esi, %edi        # 내부적으로 edi - esi, ZF/SF/OF/CF 설정
jle    L
```

- `jle` 판단식(부호 비교):  
  $$ \text{taken} \iff (SF \oplus OF) \lor ZF $$

### 3.2 분기 없는 조건 이동(cmov)

짧은 조건에서 분기 예측 실패를 피하기 위한 **분기 없는 선택**:

```asm
# dst = (cond ? x : y)
mov     %esi, %eax       # eax = y (디폴트)
cmp     %edx, %ecx       # cond: ecx ? edx
cmovg   %edi, %eax       # cond가 참이면 eax=y 대신 x로 덮기
```

---

## 4. 루프: 인덱스·주소·종료조건

### 4.1 C → 어셈블리(합계 루프)

```c
int sum(const int *a, int n) {
    int s = 0;
    for (int i = 0; i < n; i++) s += a[i];
    return s;
}
```

어셈블리(개념적, SysV/AT&T):

```asm
sum:
    xorl    %eax, %eax         # s=0
    xorl    %ecx, %ecx         # i=0
.L_loop:
    cmpl    %ecx, %esi         # n vs i
    jle     .L_end
    addl    (%rdi,%rcx,4), %eax  # s += a[i], 주소 = rdi + rcx*4
    incl    %ecx
    jmp     .L_loop
.L_end:
    ret
```

주소 산식:

$$
\text{addr} = \text{base}(a) + i\cdot \text{sizeof(int)} = RDI + RCX \cdot 4
$$

---

## 5. 함수 호출/복귀와 스택 프레임

### 5.1 전형적 프롤로그/에필로그

```asm
foo:
    push    %rbp
    mov     %rsp, %rbp
    sub     $32, %rsp       # 지역공간 (예시)
    ...
    leave                  # mov %rbp,%rsp; pop %rbp
    ret
```

스택 프레임 개념도:

```
          높은 주소
[caller args > 6]   ← 호출자
return address
saved %rbp           ← %rbp (프레임 기준)
locals / spills      ← %rsp (하강)
          낮은 주소
```

### 5.2 호출 규약 준수 포인트

- **caller-saved**: 호출 직전/직후에 보존/복원  
- **callee-saved**: 프롤로그에서 저장, 에필로그에서 복원  
- **스택 정렬**: SysV는 호출 시점에 `%rsp ≡ 16n + 8` (call이 return addr을 push하여 16정렬 유지)

---

## 6. 구조체·배열·포인터 조합: 주소 계산과 정렬

### 6.1 구조체 정렬과 패딩

```c
typedef struct {
    int id;     // 4
    int score;  // 4
} Student;      // 총 8바이트 (정렬로 padding 없음)
```

```c
typedef struct {
    char tag;   // 1
    int  x;     // 4 (정렬 위해 3바이트 패딩)
    long y;     // 8
} P;            // 크기: 1 + 3(pad) + 4 + 8 = 16 (대개 16으로 정렬)
```

### 6.2 AoS vs SoA

- **AoS(Array of Structs)**: `Student a[N];`  
  - 좋은 점: 각 학생 단위 접근  
  - 나쁜 점: 특정 필드만 스캔 시 불필요 데이터 끌림
- **SoA(Struct of Arrays)**: `int id[N]; int score[N];`  
  - 좋은 점: 필드별 대량 처리/벡터화 유리  
  - 나쁜 점: 객체 지향적 조작은 번거로움

---

## 7. 종합 예제: 구조체 배열 + 조건 + 함수 호출

### 7.1 C 코드

```c
typedef struct {
    int id;
    int score;
} Student;

void bump(Student *s, int delta) {
    s->score += delta;
}

int bump_and_count(Student *arr, int n, int delta, int threshold) {
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        bump(&arr[i], delta);
        if (arr[i].score >= threshold) cnt++;
    }
    return cnt;
}
```

### 7.2 어셈블리 스케치(x86-64 SysV, AT&T)

```asm
# int bump_and_count(Student* arr, int n, int delta, int th)
#    rdi=arr, esi=n, edx=delta, ecx=th  (정수 인자 레지스터 규약)
bump_and_count:
    push   %rbp
    mov    %rsp, %rbp
    xor    %eax, %eax        # cnt=0
    xor    %r8d, %r8d        # i=0

.L_loop:
    cmpl   %r8d, %esi
    jle    .L_end

    # &arr[i] : rdi + i*8 (Student가 8바이트)
    lea    (%rdi,%r8,8), %r9

    # bump(&arr[i], delta)
    mov    %edx, %esi        # arg2: delta
    mov    %r9,  %rdi        # arg1: &arr[i]
    call   bump

    # if (arr[i].score >= th) cnt++
    cmpl   %ecx, 4(%r9)      # *(int*)(r9+4) vs th
    jl     .L_skip
    inc    %eax
.L_skip:
    inc    %r8d
    jmp    .L_loop

.L_end:
    pop    %rbp
    ret
```

### 7.3 `bump` 정의 (인라인화 전)

```asm
# void bump(Student* s, int delta)  => rdi=s, esi=delta
bump:
    addl   %esi, 4(%rdi)    # s->score += delta
    ret
```

> **최적화 힌트**: 컴파일러는 `bump`를 **인라인**해 호출 오버헤드를 없애고, 루프 안 분기(`jl .L_skip`)를 **cmov/셋 명령** 등으로 **분기 없는 카운팅**으로 바꿀 수 있다.

---

## 8. 분기 제거: 조건 집계의 분기-less 화

카운팅 분기를 **집계용 비트**로 바꾸면 예측 실패 비용을 줄일 수 있다.

```c
// 조건을 0/1로 변환하여 누적
cnt += (arr[i].score >= threshold);
```

어셈블리 한 가지 형태:

```asm
cmpl    %ecx, 4(%r9)
setge   %r10b           # r10b = 1 if >=
addzb   %r10b, %al      # 8비트 덧셈(확장 주의), 혹은 movzx/addl
```

또는:

```asm
mov     $1, %r10d
cmovl   %r11d, %r10d    # 조건 반대로 쓰는 방식 등
add     %r10d, %eax
```

---

## 9. 데이터 지역성·캐시·프리패치

- **공간 지역성**: `arr[i]`를 순차 접근 → 다음 라인 미리 캐시에 있음  
- **시간 지역성**: 최근 사용 데이터 재사용  
- **스트라이드**가 1에 가까울수록(연속 접근) 캐시 효율↑  
- **포인터 추적**(linked list)처럼 랜덤 접근은 캐시 미스↑

**루프 블로킹**(행렬 등), **AoS→SoA** 변환, **프리패치**는 기계 수준 성능 개선의 핵심 기법.

---

## 10. 엄밀한 주소/형 변환과 엄격 별칭(strict aliasing)

### 10.1 엄격 별칭 규칙(요지)

서로 다른 타입 포인터가 같은 메모리를 가리켜 **정의되지 않은 동작**을 유발할 수 있다.  
컴파일러는 별칭이 없다고 가정하고 레지스터에 값을 **가둬 두는** 최적화를 수행한다.

- 안전한 접근: 같은 타입, `char*`(바이트 관찰), `memcpy` 등  
- 위험 예: `int*`와 `float*`가 동일 위치를 번갈아 접근

```c
void f(int *pi, float *pf) {
    *pi = 0x3f800000;   // 1.0f의 비트 패턴
    // *pf를 바로 읽으면, 별칭 가정 위반 시 비정상 최적화 가능
}
```

**대응**: `memcpy`, `std::bit_cast`(C++20), `union`(제약 확인), `-fno-strict-aliasing`(권장X).

---

## 11. 원자적 연산과 메모리 모델(간단 관점)

### 11.1 x86-TSO 요지

- 대부분의 메모리 저장은 **Total Store Order**로 보이지만, **Store→Load 재정렬**이 관찰될 수 있다(버퍼링).  
- `LOCK` 접두어/원자적 명령(`xchg`, `lock xadd` 등)은 **원자성**과 **순서 보장**을 제공.

### 11.2 카운터 예

```c
#include <stdatomic.h>
void inc(_Atomic int *p) { atomic_fetch_add_explicit(p, 1, memory_order_relaxed); }
```

어셈블리(한 구현 예):

```asm
lock xaddl   $1, (%rdi)
```

---

## 12. 예제: 필터+집계+변환 파이프라인

### 12.1 C: 점수 필터링 후 정규화

```c
// arr[i].score가 threshold 이상이면 cnt++,
// 그리고 score를 min/max로 정규화하여 [0,1]로 저장(부동소수점)
typedef struct { int id, score; } Student;

int filter_and_normalize(Student *arr, int n, int threshold,
                         int minv, int maxv, float *out_norm) {
    int cnt = 0;
    int range = (maxv - minv);
    for (int i = 0; i < n; i++) {
        int sc = arr[i].score;
        cnt += (sc >= threshold);
        float t = (range ? (float)(sc - minv) / (float)range : 0.0f);
        out_norm[i] = t;
    }
    return cnt;
}
```

### 12.2 기계 수준 관찰 포인트

- **분기 없는 조건 누적**  
- **주소 계산**: `arr + i*8`, `out_norm + i*4`  
- **나눗셈** 회피: `1.0f/range`를 미리 곱하기로 교체(강한 최적화)  
- **벡터화**: SoA일 때 `score[]`만 벡터로드 가능성이 높아짐

---

## 13. 보안/디버깅 각론: 프레임, 오버플로, 도구

### 13.1 스택 보호와 레이아웃

- **스택 카나리**: 프롤로그에서 난수 카나리 저장, 에필로그에서 검증  
- **ASLR**: 주소 무작위화  
- **NX**: 스택/힙 실행 금지

### 13.2 디버깅 도구 예시

- `objdump -d a.out` : 디스어셈블  
- `readelf -S a.out` : 섹션 확인  
- `gdb` : 레지스터/메모리/스택 프레임 추적  
- `perf` : 분기 예측 실패·캐시 미스 통계

---

## 14. 마이크로아키텍처 힌트: 예측·의존성·루프

- **분기 예측**: 예측 실패는 파이프라인 플러시 → 루프의 분기-less화가 유효  
- **데이터 의존성**: RAW/WAR/WAW → 리네이밍/OOO로 완화되나 **load-use** 지연은 잦다  
- **메모리 계층**: L1/L2/L3/메모리, **패턴이 성능**을 좌우

---

## 15. 종합 미니 프로젝트: “상위 K명 추출 + 누적 통계”

### 15.1 요구

- 입력: `Student arr[N]`  
- 작업: (1) `delta`만큼 점수 가산, (2) 평균/표준편차 집계, (3) 상위 K명 id를 별도 배열에 저장(점수 내림차순)

### 15.2 C(스케치)

```c
#include <math.h>
typedef struct { int id, score; } Student;

int topk_after_bump(Student *arr, int n, int delta, int K, int *out_ids,
                    double *avg, double *stdev) {
    long sum = 0, sum2 = 0;
    for (int i = 0; i < n; i++) {
        int sc = arr[i].score + delta;
        arr[i].score = sc;
        sum  += sc;
        sum2 += (long)sc * sc;
    }
    double mean = (n ? (double)sum / (double)n : 0.0);
    double var  = (n ? (double)sum2/(double)n - mean*mean : 0.0);
    *avg = mean;
    *stdev = (var > 0.0 ? sqrt(var) : 0.0);

    // 간단한 선택 알고리즘(부분 정렬) – 여기서는 O(n*K) 스케치
    for (int k = 0; k < K && k < n; k++) {
        int best = k;
        for (int j = k+1; j < n; j++) {
            if (arr[j].score > arr[best].score) best = j;
        }
        // swap
        if (best != k) {
            Student t = arr[k]; arr[k] = arr[best]; arr[best] = t;
        }
        out_ids[k] = arr[k].id;
    }
    return (K < n ? K : n);
}
```

### 15.3 기계 수준 관찰

- 1차 루프: 연속 접근 → 캐시 친화적, 곱/덧셈 누적은 레지스터 체류  
- 2차 루프(선택): 비교 분기 다수 → 작은 K에는 괜찮지만, 큰 K에는 힙/퀵셀렉션이 유리  
- **정밀도**: `sum2` 오버플로 방지 위해 `long` 사용  
- **수학적 부분**:  
  $$ \mathrm{var} = E[X^2] - (E[X])^2 $$

---

## 16. Y86 스타일로 보는 본질(요지)

- `OPq` 후 플래그(ZF/SF/OF) 설정 → `cmovXX/jXX`가 이를 소비  
- `rmmovq/mrmovq` 형태의 주소 계산: `regB + D`  
- `call/ret`으로 스택 push/pop, 간단한 호출 규약  
- 분기 없는 `cmov` 패턴, **조건 누적**은 `setcc`/`cmov`로 재현

---

## 17. 체크리스트(실전)

- [ ] **인덱스 → 주소**: `base + i*stride`를 명확히  
- [ ] **정렬/패딩**: 구조체 크기/필드 오프셋 확정  
- [ ] **호출 규약**: 인자/반환/보존 레지스터 일관  
- [ ] **분기 최소화**: cmov/setcc/분기less 카운팅  
- [ ] **지역성**: 데이터 배치(AoS↔SoA), 순차 접근 유지  
- [ ] **별칭/정밀도**: strict aliasing, 승격, 오버플로 대응  
- [ ] **디버깅/측정**: objdump/readelf/gdb/perf로 실제 확인

---

## 18. 요약

- **제어**(분기·루프·호출)는 **데이터**(레지스터·메모리)와 한 몸이다.  
- 주소 계산/정렬/호출 규약을 이해하면 고급 언어의 추상이 **기계 수준**에서 어떻게 실체화되는지 보인다.  
- 분기 제거·벡터화·데이터 재배치 같은 **저수준 최적화**는 코드/데이터/아키텍처의 접점을 정확히 짚을 때 성과가 난다.  
- 도구로 실제 바이너리/성능을 **관찰**하라: “보이는 것”이 곧 학습이다.

---
```c
// 스스로 실습해볼 소형 벤치 스켈레톤(리눅스)
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct { int id, score; } Student;

int bump_and_count(Student *arr, int n, int delta, int th);

int main() {
    int n = 1<<20;
    Student *a = (Student*)aligned_alloc(64, sizeof(Student)*n);
    for (int i=0;i<n;i++){ a[i].id=i; a[i].score=rand()%1000; }

    clock_t t0=clock();
    int c = bump_and_count(a,n,7,500);
    clock_t t1=clock();

    printf("count=%d, time=%.3f ms\n", c, 1000.0*(t1-t0)/CLOCKS_PER_SEC);
    free(a);
}
```

```asm
# bump(&arr[i], delta) – 분기 없는 집계의 한 조각(개념)
# cmpl %ecx, 4(%r9) / setge %r10b / movzx %r10b,%r10d / addl %r10d,%eax
```

위 실습을 기반으로 `objdump -d`, `perf stat`, `perf record`로 **분기 예측 실패/캐시 미스**를 관찰해보면,  
분기 제거/데이터 배치 개선의 효과가 **수치로** 보이기 시작한다.