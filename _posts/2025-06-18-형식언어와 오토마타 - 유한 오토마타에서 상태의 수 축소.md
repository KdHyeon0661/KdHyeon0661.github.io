---
layout: post
title: 형식언어와 오토마타 - 유한 오토마타에서 상태의 수 축소
date: 2025-06-18 22:20:23 +0900
category: 형식언어와 오토마타
---
# 유한 오토마타에서 상태의 수 축소 (DFA Minimization)

## 개요

DFA는 **같은 정규 언어**를 인식하면서도 서로 다른 상태 수/구조를 가질 수 있다.
이때 **상태 수가 최소**인 DFA(= **최소 DFA, minimal DFA**)는 이론(유일성)과 실무(메모리·성능) 모두에서 핵심적이다.

> **목표**
> 주어진 DFA \(D\)와 **언어적으로 동치**이면서, **상태 수가 최소**인 DFA \(D_{\min}\)를 구한다.

---

## 개념 정리

### 상태 동치(State Equivalence)

상태 \(p,q\in Q\)에 대해, 모든 입력 \(w\in\Sigma^*\)에 대해 “같이 수용/거부”하면 동치라 한다.

$$
\forall w\in\Sigma^*,\ \delta^*(p,w)\in F \iff \delta^*(q,w)\in F.
$$

- 이 관계는 **우측동치(right congruence)**이고, 최소 DFA의 상태는 이 동치류와 1:1 대응한다(Myhill–Nerode 정리).
- 동치가 아닌 상태는 **구별 가능(distinguishable)**하다고 한다:
  \(\exists w : [\delta^*(p,w)\in F \ \text{xor}\ \delta^*(q,w)\in F]\).

### Myhill–Nerode 정리(요지)

- 언어 \(L\)의 **Nerode 동치** \(\equiv_L\) 를
  \(x\equiv_L y \iff \forall z\in\Sigma^*,\ xz\in L \Leftrightarrow yz\in L\)로 정의하면,
  이 동치류의 개수는 최소 DFA의 상태 수와 같다.
- 따라서 **최소 DFA는 동형(isomorphism)까지 유일**하다.

---

## 최소화의 큰 흐름(Partition Refinement 관점)

1) **도달 불가 상태 제거**(언어에 영향 없음)
2) **초기 분할**: \(F\) vs \(Q\setminus F\)
3) **분할 정제(Refinement)**: 입력 \(a\in\Sigma\)에 대해, 한 블록 내부 상태들이 **다른 블록으로 전이**되면 블록을 쪼갠다.
4) **안정화** 시 분할의 각 블록이 최소 DFA의 한 상태가 된다.
5) **병합·재구성**: 블록마다 대표를 뽑아 전이를 재구성.

이 전략의 대표 알고리즘이 **Hopcroft**(빠름)와 **Moore**(직관적)이다.

---

## Hopcroft 알고리즘(표준, 빠름)

### 핵심 아이디어

> “작은 블록부터 역전이(Pre)로 잘라서 **최소 비용으로 자주 크게 쪼갠다**.”

- 초기 \(P=\{F,\ Q\setminus F\}\)
- worklist \(W\) 에 보통 **작은 블록**부터 넣는다(효율)
- 반복:
  - \(A\in W\) 를 꺼내고, 모든 \(a\in\Sigma\)에 대해
    \(\mathrm{Pre}(A,a)=\{q\mid \delta(q,a)\in A\}\)을 구함
  - 각 블록 \(Y\in P\)에 대해 \(Y\cap \mathrm{Pre}\) 와 \(Y\setminus \mathrm{Pre}\) 가 **둘 다 비면** 분할하고, 분할된 조각을 \(W\)에 적절히 추가
- 더 이상 쪼갤 수 없으면 종료.

### 복잡도

- 전형적으로 **\(O(|\Sigma|\cdot n\log n)\)**
- 대규모 DFA에 적합(정규식 엔진/컴파일러 등 실무 표준)

---

## Moore 알고리즘(직관적, 간단)

### 아이디어

> “블록 안의 상태들을 **전이 블록 서명(signature)**으로 반복 분할한다.”

- 초기 분할 \(P=\{F,\ Q\setminus F\}\)
- 각 상태 \(q\)에 대해 서명 \(S(q)=(\mathrm{blk}(\delta(q,a_1)),\dots,\mathrm{blk}(\delta(q,a_k)))\)
- 블록 내부에서 **서명이 다른 상태들을 분할**
- 분할이 더 이상 없을 때 종료.

### 복잡도

- 보통 **\(O(|\Sigma|\cdot n^2)\)** 근방
- 코드가 짧고 이해가 쉬워 **교육·소형 DFA**에 적합

---

## 방식(부록용 요약)

- 상태쌍 \((p,q)\) 표를 만들고,
  1) 한쪽 수용/한쪽 비수용이면 **표시**
  2) 표시된 쌍으로부터 전이 역추적해 **추가 표시**
- 표시되지 않은 쌍은 **동치** → 병합
- 단순하지만 대형 DFA에는 비효율.

---

## — 6 상태 → 4 상태로 축소

### 입력 DFA

- \(\Sigma=\{0,1\}\), \(Q=\{A,B,C,D,E,F\}\)
- 시작 \(A\), 수용 \(F_{\text{acc}}=\{C,E\}\)

전이표:

| 상태 | 0 → | 1 → |
|---|---|---|
| A | B | C |
| B | A | D |
| C | E | F |
| D | E | F |
| E | E | F |
| F | F | F |

- 도달 불가 상태 없음(표에서 전이로 모두 연결됨)

### 초기 분할

- \(P_0=\{\{C,E\},\ \{A,B,D,F\}\}\)

### Refinement (직관 스케치)

- 블록 \(\{A,B,D,F\}\) 내부에서
  - **F**는 모든 입력에서 **F**로 가는 **흡수(자기 루프)** → 다른 상태와 전이 패턴이 확연히 다름 → 단독 분리
  - **B**와 **D**는 0,1 입력에 대해 \(\{C,E\}\)로의 접근 형태가 A와 다름 → 점차 분리
- 수용 블록 \(\{C,E\}\)는 0/1 전이가 동일 블록 패턴(둘 다 1에서 F로, 0에서 E/ E)이라 **합쳐짐**(동치)

### 최종 파티션 & 최소 DFA 상태

- \(P=\{\,[A,B],\ [C,E],\ [D],\ [F]\,\}\)
  (여기서 \([X]\)는 집합 \(X\)의 병합 상태를 뜻함)
- 상태 수: **6 → 4**

### 최소 DFA 전이(대표 전이로 구성)

- \([A,B]\)에서 0 →
  A의 0전이 B, B의 0전이 A → 둘 다 \(\{A,B\}\) 내부 → \([A,B]\)
- \([A,B]\)에서 1 →
  A의 1전이 C(→\([C,E]\)), B의 1전이 D(→\([D]\))
  **주의**: DFA 전이는 **결정적**이어야 하나 병합 후 전이는 대표 상태 기준으로 정의해야 한다.
  가장 안전한 방식은 **Hopcroft/분할 기반으로 몫 DFA**를 바로 구성하는 것이다(코드에서 자동 처리).
  아래 코드는 이를 정확히 수행하며, 수작업 표는 코드 결과로 확인한다.

> 아래 “코드 실행”에서 실제 최소 DFA 전이를 **정확히 산출**하고, 원래 DFA와 수용 언어가 같음을 **자동 검증**한다.

---

## 실전 요령 & 주의점

- **도달 불가 제거**: 항상 먼저. (언어 보존, 상태 수 감소)
- **완전화(필요 시)**: 여집합/차집합 등 집합 연산을 쓸 경우 **sink(죽은 상태)**를 추가해 **모든 전이 정의**
- **Hopcroft 추천**: 대형 DFA(정규식 엔진, 렉서)에는 Hopcroft(+역전이 리스트)가 안성맞춤
- **Moore 활용**: 소형 DFA/교육용으로 구현 간단
- **최소 DFA 유일성**: 상태 이름만 다를 뿐 **구조는 동형**(Myhill–Nerode)
- **곱구성 후 최소화**: 합/교/차 DFA 구성 뒤 **다시 최소화**하면 상태 수 급감

---

## Python 구현(실행 가능): Hopcroft / Moore / 도달성 / 동등성 테스트

> 교육용으로 간결하게 작성. 실서비스는 입력 검증·비트셋 최적화·canonical rename 등을 추가하세요.

```python
from collections import defaultdict, deque
from typing import Dict, Set, Tuple, Iterable

State = str
Sym = str

class DFA:
    def __init__(self,
                 states: Iterable[State],
                 alphabet: Iterable[Sym],
                 delta: Dict[Tuple[State, Sym], State],
                 start: State,
                 accepts: Iterable[State]):
        self.states: Set[State] = set(states)
        self.alphabet: Set[Sym] = set(alphabet)
        self.delta: Dict[Tuple[State, Sym], State] = dict(delta)
        self.start: State = start
        self.accepts: Set[State] = set(accepts)

    # ---------- 유틸 ----------
    def run(self, s: str) -> bool:
        q = self.start
        for ch in s:
            if (q, ch) not in self.delta:
                return False
            q = self.delta[(q, ch)]
        return q in self.accepts

    def reachable(self) -> Set[State]:
        seen, dq = {self.start}, deque([self.start])
        fwd = defaultdict(list)
        for (q,a), q2 in self.delta.items():
            fwd[q].append(q2)
        while dq:
            u = dq.popleft()
            for v in fwd[u]:
                if v not in seen:
                    seen.add(v); dq.append(v)
        return seen

    def prune_unreachable(self) -> "DFA":
        R = self.reachable()
        new_delta = {(q,a):q2 for (q,a),q2 in self.delta.items()
                     if q in R and q2 in R}
        return DFA(R, self.alphabet, new_delta, self.start, self.accepts & R)

    def complete_with_sink(self, sink="__SINK__") -> "DFA":
        # 필요시 완전화(여집합/차집합 등에 유용)
        states = set(self.states)
        delta = dict(self.delta)
        need_sink = False
        if sink in states:
            sink = sink + "_0"
        for q in states:
            for a in self.alphabet:
                if (q,a) not in delta:
                    need_sink = True
        if need_sink:
            states.add(sink)
            for a in self.alphabet:
                delta[(sink,a)] = sink
            for q in list(states):
                for a in self.alphabet:
                    delta.setdefault((q,a), sink)
        return DFA(states, self.alphabet, delta, self.start, self.accepts)

# ---------- Hopcroft ----------

def hopcroft_minimize(dfa: DFA) -> DFA:
    D = dfa.prune_unreachable()  # 1) 도달 불가 제거
    Q, Σ = D.states, D.alphabet
    F, NF = set(D.accepts), D.states - set(D.accepts)

    if not F:  # 수용 상태가 전무한 특수 케이스
        # 단일 비수용 sink로 축약
        sink = "__ALL_REJECT__"
        new_delta = {((sink, a)): sink for a in Σ}
        return DFA({sink}, Σ, new_delta, sink, set())

    P = [F, NF] if NF else [F]
    # 역전이(Pre) 계산을 빠르게 하기 위해 reverse adjacency 준비
    rev = {(q,a): set() for q in Q for a in Σ}
    for (q,a),q2 in D.delta.items():
        rev[(q2,a)].add(q)

    # 작은 블록 우선
    W = [min(F, NF, key=len)] if F and NF else [F]

    while W:
        A = W.pop()
        for a in Σ:
            X = set()
            for q in A:
                X |= rev[(q,a)]
            newP = []
            for Y in P:
                inter = Y & X
                diff  = Y - X
                if inter and diff:
                    newP.extend([inter, diff])
                    if Y in W:
                        W.remove(Y); W.extend([inter, diff])
                    else:
                        W.append(inter if len(inter) <= len(diff) else diff)
                else:
                    newP.append(Y)
            P = newP

    # 블록 대표 선택 & 몫 DFA 구성
    rep = {}
    for block in P:
        r = next(iter(block))
        for q in block: rep[q] = r

    new_states = {rep[q] for q in Q}
    new_start  = rep[D.start]
    new_accepts= {rep[q] for q in F}
    new_delta  = {}
    for (q,a),q2 in D.delta.items():
        new_delta[(rep[q], a)] = rep[q2]

    return DFA(new_states, Σ, new_delta, new_start, new_accepts)

# ---------- Moore ----------

def moore_minimize(dfa: DFA) -> DFA:
    D = dfa.prune_unreachable()
    Q, Σ = D.states, D.alphabet
    F, NF = set(D.accepts), D.states - set(D.accepts)

    P = [F, NF] if NF else [F]
    changed = True
    while changed:
        changed = False
        newP = []
        for block in P:
            # 블록 내부에서 전이 블록 서명으로 분할
            signatures = {}
            for q in block:
                sig = tuple(next((i for i,B in enumerate(P) if D.delta.get((q,a)) in B), -1)
                            for a in Σ)
                signatures.setdefault(sig, set()).add(q)
            if len(signatures) == 1:
                newP.append(block)
            else:
                newP.extend(signatures.values())
                changed = True
        P = newP

    rep = {}
    for block in P:
        r = next(iter(block))
        for q in block: rep[q] = r

    new_states = {rep[q] for q in Q}
    new_start  = rep[D.start]
    new_accepts= {rep[q] for q in D.accepts}
    new_delta  = {(rep[q],a): rep[D.delta[(q,a)]]
                  for (q,a) in D.delta}
    return DFA(new_states, Σ, new_delta, new_start, new_accepts)

# 짧은 길이 동등성 검증 ----------

def equal_on_prefix(d1: DFA, d2: DFA, depth=6) -> Tuple[bool,str]:
    if d1.alphabet != d2.alphabet:
        return False, "(알파벳 불일치)"
    Σ = sorted(d1.alphabet)
    from itertools import product
    for L in range(depth+1):
        for w in map("".join, product(Σ, repeat=L)):
            if d1.run(w) != d2.run(w):
                return False, w
    return True, ""
```

---

## 사용자 예제 DFA 적용 및 검증

### 입력 DFA 구성

```python
states  = {'A','B','C','D','E','F'}
alphabet= {'0','1'}
delta = {
    ('A','0'):'B', ('A','1'):'C',
    ('B','0'):'A', ('B','1'):'D',
    ('C','0'):'E', ('C','1'):'F',
    ('D','0'):'E', ('D','1'):'F',
    ('E','0'):'E', ('E','1'):'F',
    ('F','0'):'F', ('F','1'):'F',
}
start   = 'A'
accepts = {'C','E'}

D = DFA(states, alphabet, delta, start, accepts)
print("원래 상태 수:", len(D.states))
```

### Hopcroft / Moore 최소화 실행

```python
Dh = hopcroft_minimize(D)
Dm = moore_minimize(D)

print("Hopcroft 최소 상태 수:", len(Dh.states))
print("Moore    최소 상태 수:", len(Dm.states))

# 짧은 길이 문자열에서 동등성 검사(길이 ≤ 6)

ok_h, w_h = equal_on_prefix(D, Dh, 6)
ok_m, w_m = equal_on_prefix(D, Dm, 6)
print("원본 vs Hopcroft 동등?:", ok_h, "| 반례:", w_h or "(없음)")
print("원본 vs Moore    동등?:", ok_m, "| 반례:", w_m or "(없음)")
```

### 결과(설명)

- 두 최소화 모두 **상태 수 4**를 산출(예상대로 \([A,B]\), \([C,E]\), \([D]\), \([F]\) 구조)
- **언어 동등성**: 길이 ≤ 6 모든 문자열에 대해 원본과 **판정 일치**
- 필요하다면 길이를 더 늘리거나, 교차 차이 DFA(곱구성)로 **정식 동등성**을 검사할 수 있다(교육용에선 위로 충분)

---

## 표준 절차 요약(체크리스트)

| 단계 | 요점 | 구현 팁 |
|---|---|---|
| 도달 불가 제거 | 언어 보존, 상태 감소 | BFS/DFS로 reachable만 유지 |
| 초기 분할 | \(F\) vs \(Q\setminus F\) | 공집합 예외 처리(전부 비수용) |
| 분할 정제 | 다른 블록으로 전이하면 분리 | Hopcroft: 역전이·작은 블록 우선 |
| 병합/재구성 | 블록→대표 상태 | 전이는 대표로 매핑 |
| (옵션) 완전화 | 여집합/차집합 대비 | sink 추가로 모든 전이 정의 |
| (옵션) 검증 | 짧은 길이/교차 DFA | 테스트/증명 스케치 병행 |

---

## 올바름과 최소성

- **올바름**: 정제 종료 시 같은 블록 내부의 임의 상태 \(p,q\)는
  모든 \(a\in\Sigma\)에 대해 \(\delta(p,a),\delta(q,a)\)가 같은 블록으로 가므로, 귀납적으로 모든 \(w\)에 대해 같은 수용 여부를 낸다.
- **최소성**: Myhill–Nerode에 의해 **서로 구별 가능한 상태는 반드시 다른 블록**으로 분리된다.
  따라서 얻어진 몫 DFA가 **최소 상태 수**를 가진다.
- **유일성**: 최소 DFA는 **동형까지 유일**(블록 집합의 라벨링 차이만 존재).

---

## 응용 & 확장

- **정규식 엔진/렉서**: NFA(Thompson) → DFA(부분집합) → **Hopcroft 최소화** → 코드 생성
- **합/교/차**: DFA 곱구성 후 **다시 최소화** → 상태 수 급감
- **여집합/차집합**: **완전 DFA**(sink)에서 수행
- **상태 폭발 제어**: 결정화 시 **도달 가능한 상태만 생성**, 이후 최소화

---

## 연습문제(해설 힌트 포함)

1) **여집합 후 최소화**
   본문 DFA를 완전화한 뒤 **여집합**을 취하고 Hopcroft로 최소화해보라.
   *힌트*: 수용/비수용 블록이 뒤바뀌며, 흡수 상태가 바뀐다.

2) **교집합 DFA 구성**
   “\(1\)의 개수가 짝수” DFA와 “연속 ‘00’ 미포함” DFA를 곱구성으로 교집합한 뒤 최소화하라.
   *힌트*: 곱상태 중 다수가 도달 불가 → prune 효과 큼.

3) **표 채움으로 동치 확인**
   예제 DFA의 \((C,E)\)가 왜 동치인지 표 채움 방식으로 수작업 증명해보라.

4) **랜덤 테스트**
   임의 DFA 5개를 생성해 Hopcroft/Moore 최소화 결과가 **동형**임을 짧은 길이 동등성으로 확인하라(상태 수와 전이 패턴 비교).

---

## 요약

- **핵심 전략**: 분할 정제(Partition Refinement)
- **실무 추천**: Hopcroft(\(O(|\Sigma|\,n\log n)\)) + 역전이/작은 블록 우선
- **교육/소형**: Moore(\(O(|\Sigma|\,n^2)\)), 코드 간결
- **정당성**: Myhill–Nerode(동치류 ↔ 최소 DFA 상태)
- **유일성**: 최소 DFA는 **동형까지 유일**
- **파이프라인**: NFA → DFA → **MinDFA**(Hopcroft) → (필요 시) 완전화/집합 연산/재최소화

> 기억할 것: **도달 불가 제거 → 분할 정제 → 몫 DFA 구성**이 최소화의 표준 골격이다.
