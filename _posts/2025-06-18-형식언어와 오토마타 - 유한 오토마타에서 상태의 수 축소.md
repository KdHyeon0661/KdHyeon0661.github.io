---
layout: post
title: 형식언어와 오토마타 - 유한 오토마타에서 상태의 수 축소
date: 2025-06-18 22:20:23 +0900
category: 형식언어와 오토마타
---
# 유한 오토마타에서 상태의 수 축소 (DFA Minimization)

## 개요

DFA가 하나의 정규 언어를 인식하는 방식은 유일하지 않으며, **같은 언어를 인식하는 여러 개의 DFA**가 존재할 수 있습니다. 이 중에서도 **가장 적은 수의 상태를 가지는 DFA**, 즉 **최소 DFA(minimal DFA)**는 이론적, 실용적 측면에서 모두 중요합니다.

> **목표:** 주어진 DFA와 언어적으로 동치이면서, 상태 수가 최소인 DFA를 만드는 것

---

## 1. 개념 정리

### 1.1 상태 동치(State Equivalence)

두 상태 \\( p, q \\in Q \\)가 **동치(equivalent)**라는 것은, 이 상태들에서 시작해 어떤 입력 문자열을 읽더라도 결과가 항상 **같은 수용 여부**를 가진다는 의미입니다.

수학적으로:

\\[
\forall w \in \Sigma^*,\; \delta^*(p, w) \in F \iff \delta^*(q, w) \in F
\\]

즉, 상태 p와 q는 어떤 문자열을 넣든 **항상 함께 수용하거나 함께 거부**한다면 동치입니다.

---

## 2. DFA 최소화 알고리즘 (Hopcroft 알고리즘)

최소화를 위해 가장 널리 쓰이는 방식은 **상태 분할(partition refinement)** 기법입니다.

### 단계 요약:

1. **도달 불가능한 상태 제거**
2. **종료 상태와 비종료 상태 분할**
3. **구별 가능한 상태 쌍 분리 (Partition Refinement)**
4. **동치 상태 병합**
5. **새로운 DFA 구성**

---

## 3. 최소화 알고리즘 상세 과정

### Step 1: 도달 불가능한 상태 제거

시작 상태 \\( q_0 \\)로부터 어떤 경로로도 도달할 수 없는 상태는 제거해도 인식 언어에는 영향을 주지 않음.

#### 방법:
- BFS/DFS로 \\( q_0 \\)에서 시작하여 도달 가능한 상태만 모음
- 나머지는 제거

---

### Step 2: 상태 초기 분할

- 종료 상태 집합 \\( F \\)
- 비종료 상태 집합 \\( Q \setminus F \\)

이 두 집합은 절대 서로 동치가 될 수 없음 (수용 여부가 다름)

---

### Step 3: 구별 가능한 상태 분할

입력 기호를 기준으로, 상태들이 같은 집합에 속해도 **전이 결과가 다른 집합으로 가면** 서로 **구별 가능(distinguishable)**하다고 판단

#### 반복적으로 refine:

1. 현재 파티션 내에서 모든 상태 쌍을 확인
2. 입력 기호에 따라 **다른 파티션으로 전이**되는 상태들을 분리
3. 더 이상 refine이 불가능할 때까지 반복

이 과정을 통해 **모든 동치 상태들이 같은 파티션에 묶임**

---

### Step 4: 동치 상태 병합

파티션 내에서 동일한 집합에 있는 상태들을 하나로 병합하여 새로운 상태로 만듦.

- 병합된 상태는 새로운 이름(예: [q0, q1])을 가질 수 있음
- 전이 함수도 병합된 상태를 기준으로 재정의

---

### Step 5: 새로운 DFA 구성

- 새로운 상태 집합: 파티션된 집합들
- 시작 상태: \\( q_0 \\)이 속한 파티션
- 종료 상태: 원래 종료 상태를 포함하는 파티션들
- 전이 함수: 각 병합 상태의 대표 전이를 따름

---

## 4. 예제

### 원래 DFA

입력 알파벳: \\( \Sigma = \{0, 1\} \\)

상태 집합: \\( Q = \{A, B, C, D, E, F\} \\)  
시작 상태: A  
종료 상태: \\( F = \{C, E\} \\)

전이표:

| 상태 | 0 입력 | 1 입력 |
|------|--------|--------|
| A    | B      | C      |
| B    | A      | D      |
| C    | E      | F      |
| D    | E      | F      |
| E    | E      | F      |
| F    | F      | F      |

### Step 1: 도달 불가능한 상태 없음

### Step 2: 초기 분할

- P₀ = { {C, E}, {A, B, D, F} }

### Step 3: Refinement 반복

분리 기준: 전이 결과가 다른 집합으로 가는가?

- F는 모든 입력에서 F로 가므로 다른 상태들과 분리됨
- B와 D는 입력 결과에 따라 다른 파티션으로 가므로 분리됨

결과 파티션:

- P = { {A, B}, {C, E}, {D}, {F} }

### Step 4: 병합

- A와 B → 병합: [A, B]
- C와 E → 병합: [C, E]
- D, F는 단독 상태

### Step 5: 최소 DFA 구성

최소 DFA 상태 집합:  
\\( Q' = \{[A,B], [C,E], D, F\} \\)

새 전이표 구성 후, 상태 수는 6 → **4개로 축소됨**

---

## 5. DFA 최소화의 중요성

- **메모리 절약**: 상태 수가 줄어들어 공간 사용 감소
- **속도 향상**: 실행 시 전이 확인 횟수 감소
- **정규 언어 동치 확인**: 두 DFA가 동일한 언어를 인식하는지 비교 시 **최소 DFA**로 비교하면 간단함

> DFA의 최소 형태는 **동일한 언어를 인식하는 DFA 중 유일(unique)**합니다 (상태 이름을 제외하면 구조적으로 동일).

---

## 6. 요약

| 단계 | 설명 |
|------|------|
| 도달 불가능 상태 제거 | BFS/DFS로 도달 가능한 상태만 남김 |
| 상태 초기 분할 | 종료 / 비종료 상태 분리 |
| 상태 구분 반복 | 입력에 따라 전이되는 파티션이 다르면 분리 |
| 병합 및 재구성 | 동치 상태 병합, 새 DFA 구성 |

---

## 참고

- 가장 유명한 알고리즘: **Hopcroft's Algorithm**
  - 시간복잡도: \\( O(n \log n) \\)
- 다른 방법: Moore's Algorithm (단순하지만 느림)