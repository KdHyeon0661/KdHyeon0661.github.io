---
layout: post
title: Django - 실전 미니 프로젝트 (3)
date: 2025-10-06 23:25:23 +0900
category: Django
---
# 12. 실전 미니 프로젝트 (3) — **실시간 채팅**  

## A. 전반 구조와 요구사항

### A-1. 요구사항 목록
- 1:1, 그룹(멀티멤버) 채팅
- 메시지: 텍스트/이모지/파일(썸네일은 4편에서)
- **실시간** 수신, **알림** (브라우저/모바일 푸시), **읽음 표시(✔✔)**, **타이핑…** 표시
- **온라인/오프라인** 상태, **마지막 접속** 시각
- 메시지 **중복 방지(멱등키)**, **순서**(room-seq), **재연결 복구**
- **권한**(룸 멤버만 접근), **레이트 리밋**, **감사 로그**
- 수평 확장: **Channels + Redis Channel Layer**

### A-2. 시스템 개요(텍스트 다이어그램)

```
[Browser/App]  <--WebSocket-->  [Daphne/Uvicorn + Django Channels]
                                     |
                                [Redis Channel Layer]
                                     |
                         [Django Workers(멀티 인스턴스)]
                                     |
                            [Postgres (메시지 영속화)]
                                     |
                         [Redis (Presence, Typing, Cursors)]
```

---

## B. 프로젝트 설정

### B-1. 설치

```bash
pip install "django>=5.0" "channels>=4.0" "channels-redis>=4.2" "django-redis" "psycopg2-binary"
```

### B-2. settings.py

```python
# settings.py
INSTALLED_APPS = [
    "django.contrib.admin", "django.contrib.auth", "django.contrib.contenttypes",
    "django.contrib.sessions", "django.contrib.messages", "django.contrib.staticfiles",
    "channels", "chat",  # chat 앱
]

ASGI_APPLICATION = "config.asgi.application"

# Redis Channel Layer
# 여러 인스턴스에서 같은 그룹 브로드캐스트/팬아웃을 가능하게 함
CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {"hosts": [("127.0.0.1", 6379)]}
    }
}

# 세션/캐시 (옵션)
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/1",
        "OPTIONS": {"CLIENT_CLASS": "django_redis.client.DefaultClient"}
    }
}

# AUTH 미들웨어는 기본 SessionAuth 사용 (Token/JWT는 별도 설정)
```

### B-3. asgi.py

```python
# config/asgi.py
import os
from channels.routing import ProtocolTypeRouter, URLRouter
from django.core.asgi import get_asgi_application
from channels.auth import AuthMiddlewareStack
from chat import routing as chat_routing

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
django_asgi_app = get_asgi_application()

application = ProtocolTypeRouter({
    "http": django_asgi_app,  # 일반 HTTP
    "websocket": AuthMiddlewareStack(  # 세션 기반 인증
        URLRouter(chat_routing.websocket_urlpatterns)
    ),
})
```

### B-4. 라우팅

```python
# chat/routing.py
from django.urls import path
from . import consumers

websocket_urlpatterns = [
    path("ws/chat/<uuid:room_id>/", consumers.ChatConsumer.as_asgi()),
    path("ws/notify/", consumers.NotifyConsumer.as_asgi()),  # 알림 스트림
]
```

> **Auth**: 세션/쿠키 인증을 쓰면 **AuthMiddlewareStack**. 모바일/SPA에서 **JWT**를 쓰려면 커스텀 미들웨어를 추가(토큰→유저 로딩).

---

## C. 데이터 모델

### C-1. 모델 정의

```python
# chat/models.py
import uuid
from django.db import models
from django.conf import settings
from django.utils import timezone

class Room(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    is_group = models.BooleanField(default=False)
    name = models.CharField(max_length=120, blank=True)   # 그룹명(1:1은 빈칸)
    created_at = models.DateTimeField(auto_now_add=True)

class RoomMember(models.Model):
    room = models.ForeignKey(Room, on_delete=models.CASCADE, related_name="members")
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="chat_rooms")
    joined_at = models.DateTimeField(auto_now_add=True)
    last_read_seq = models.BigIntegerField(default=0)  # 읽음 커서(시퀀스)
    is_muted = models.BooleanField(default=False)

    class Meta:
        unique_together = [("room","user")]

class Message(models.Model):
    """ 메시지 시퀀스(seq)는 룸 내 증가 정수 — 순서 보장 """
    room = models.ForeignKey(Room, on_delete=models.CASCADE, related_name="messages")
    sender = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.PROTECT, related_name="chat_messages")
    seq = models.BigIntegerField()  # room-local sequence
    client_mid = models.CharField(max_length=64, blank=True)  # 클라이언트 멱등키(중복 방지)
    text = models.TextField(blank=True)
    # 파일/이미지 필드는 4편에서 추가
    created_at = models.DateTimeField(auto_now_add=True)
    edited_at = models.DateTimeField(null=True, blank=True)
    deleted_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        unique_together = [("room","seq")]
        indexes = [models.Index(fields=["room","-seq"])]

class ReadReceipt(models.Model):
    """ 사용자별 '마지막 읽은 seq'를 기록(중복 방지 위해 upsert-style 사용) """
    room = models.ForeignKey(Room, on_delete=models.CASCADE, related_name="read_receipts")
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    last_read_seq = models.BigIntegerField(default=0)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = [("room","user")]

class Notification(models.Model):
    """ 알림: 미표시(전달 대기)/표시됨 """
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="notifications")
    room = models.ForeignKey(Room, on_delete=models.CASCADE)
    message_seq = models.BigIntegerField()     # 어떤 메시지에 대한 알림인지
    created_at = models.DateTimeField(auto_now_add=True)
    delivered = models.BooleanField(default=False)
    seen = models.BooleanField(default=False)
```

### C-2. 룸 시퀀스 생성 전략

- 각 룸에 대해 증가 시퀀스를 유지해야 함.
- **DB 락 + MAX(seq)+1** 사용은 경합 시 느릴 수 있음 → **전용 시퀀스 테이블** 또는 **Redis INCR** 권장.

간단 Redis INCR:

```python
# chat/seq.py
import aioredis
import asyncio

async def next_seq(redis, room_id: str) -> int:
    return await redis.incr(f"room:{room_id}:seq")
```

> Channels Consumer는 **async**이므로 `redis.asyncio` 클라이언트를 바로 사용.

---

## D. Channels 컨슈머 — 실시간 메시지/알림/타이핑/프레즌스

### D-1. 채널 그룹 네이밍

- 룸 그룹: `room:<room_id>`
- 유저 개인 알림: `user:<user_id>`
- 프레즌스/타이핑 키: Redis Hash/Set 사용

### D-2. 공통 유틸

```python
# chat/utils.py
from channels.db import database_sync_to_async
from django.contrib.auth import get_user_model
from .models import Room, RoomMember, Message, ReadReceipt, Notification
from django.db import transaction

User = get_user_model()

@database_sync_to_async
def is_member(room_id, user_id) -> bool:
    return RoomMember.objects.filter(room_id=room_id, user_id=user_id).exists()

@database_sync_to_async
def save_message(room, sender, seq, text, client_mid="") -> Message:
    with transaction.atomic():
        msg = Message.objects.create(room=room, sender=sender, seq=seq, text=text, client_mid=client_mid)
        # 알림 생성: 나를 제외한 멤버에게
        members = RoomMember.objects.filter(room=room).exclude(user=sender).values_list("user_id", flat=True)
        Notification.objects.bulk_create([
            Notification(user_id=uid, room=room, message_seq=seq) for uid in members
        ])
        return msg

@database_sync_to_async
def mark_read(room_id, user_id, seq):
    # 읽음 커서 업데이트(앞으로만 이동)
    rr, _ = ReadReceipt.objects.get_or_create(room_id=room_id, user_id=user_id)
    if seq > rr.last_read_seq:
        rr.last_read_seq = seq; rr.save(update_fields=["last_read_seq","updated_at"])
    # RoomMember에도 반영(쿼리 최적화 위해)
    RoomMember.objects.filter(room_id=room_id, user_id=user_id, last_read_seq__lt=seq)\
                      .update(last_read_seq=seq)

@database_sync_to_async
def load_history(room_id, after_seq: int = 0, limit: int = 50):
    qs = Message.objects.filter(room_id=room_id, seq__gt=after_seq, deleted_at__isnull=True)\
                        .order_by("seq")[:limit]
    return list(qs.values("seq","sender_id","text","created_at"))

@database_sync_to_async
def list_unread_badges(user_id: int):
    # 각 룸별 badge = last_seq - last_read_seq
    from django.db.models import Max, F, Value, IntegerField
    from django.db.models.functions import Coalesce
    last_seq = Message.objects.values("room_id").annotate(m=Max("seq"))
    # JOIN 비슷하게 처리(실무: Subquery/OuterRef)
    # 여기서는 간단히 python 계산을 예시로 둠(실무는 Subquery로 한 번에)
    data = {}
    for row in last_seq:
        room_id = row["room_id"]; m = row["m"] or 0
        try:
            rr = ReadReceipt.objects.get(room_id=room_id, user_id=user_id)
            data[str(room_id)] = max(0, m - rr.last_read_seq)
        except ReadReceipt.DoesNotExist:
            data[str(room_id)] = m
    return data
```

### D-3. ChatConsumer

```python
# chat/consumers.py
import json
import asyncio
import redis.asyncio as aioredis
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.layers import get_channel_layer
from django.utils import timezone
from .utils import is_member, save_message, mark_read, load_history
from .models import Room
from .seq import next_seq

CHANNEL_REDIS_URL = "redis://127.0.0.1:6379/0"

class ChatConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.room_id = self.scope["url_route"]["kwargs"]["room_id"]
        user = self.scope["user"]
        if not user.is_authenticated:
            await self.close(code=4401); return
        if not await is_member(self.room_id, user.id):
            await self.close(code=4403); return

        self.group_name = f"room:{self.room_id}"
        await self.channel_layer.group_add(self.group_name, self.channel_name)

        # presence: online set
        self.redis = aioredis.from_url(CHANNEL_REDIS_URL, decode_responses=True)
        await self.redis.sadd(f"room:{self.room_id}:online", str(user.id))
        await self.accept()

        # 최근 50개 히스토리(최초 접속)
        history = await load_history(self.room_id, after_seq=0, limit=50)
        await self.send_json({"type":"history", "items": history})

        # 입장 이벤트(선택)
        await self.channel_layer.group_send(self.group_name, {
            "type": "chat.system",
            "event": "join",
            "user_id": user.id,
        })

    async def disconnect(self, code):
        user = self.scope["user"]
        if hasattr(self, "group_name"):
            await self.channel_layer.group_discard(self.group_name, self.channel_name)
        if hasattr(self, "redis"):
            await self.redis.srem(f"room:{self.room_id}:online", str(user.id))
            await self.redis.aclose()

    async def receive(self, text_data=None, bytes_data=None):
        user = self.scope["user"]
        try:
            data = json.loads(text_data or "{}")
        except Exception:
            return
        action = data.get("action")

        if action == "send":
            # {action: "send", text: "...", client_mid: "uuid"}
            text = (data.get("text") or "").strip()
            if not text: return
            client_mid = data.get("client_mid","")
            # 룸 시퀀스 배정
            seq = await next_seq(self.redis, str(self.room_id))
            # 영속화
            room = Room(id=self.room_id)  # pk-only instance
            msg = await save_message(room, user, seq, text, client_mid=client_mid)
            # 브로드캐스트
            await self.channel_layer.group_send(self.group_name, {
                "type": "chat.message",
                "seq": msg.seq,
                "text": msg.text,
                "sender_id": user.id,
                "client_mid": client_mid,
                "ts": msg.created_at.isoformat(),
            })

        elif action == "read":
            # {action:"read", seq: 123}
            seq = int(data.get("seq", 0))
            if seq > 0:
                await mark_read(self.room_id, user.id, seq)
                await self.channel_layer.group_send(self.group_name, {
                    "type": "chat.read",
                    "user_id": user.id,
                    "seq": seq,
                })

        elif action == "typing":
            # {action:"typing", state: true/false}
            state = bool(data.get("state", True))
            key = f"room:{self.room_id}:typing"
            if state:
                await self.redis.hset(key, str(user.id), int(timezone.now().timestamp()))
            else:
                await self.redis.hdel(key, str(user.id))
            await self.channel_layer.group_send(self.group_name, {
                "type": "chat.typing",
                "user_id": user.id,
                "state": state,
            })

        elif action == "history":
            # {action:"history", after: seq, limit: 50}
            after = int(data.get("after", 0))
            limit = min(int(data.get("limit", 50)), 200)
            items = await load_history(self.room_id, after_seq=after, limit=limit)
            await self.send_json({"type":"history", "items": items})

    # --- 그룹 이벤트 핸들러들
    async def chat_message(self, event):
        await self.send_json({"type":"message", **event})

    async def chat_read(self, event):
        await self.send_json({"type":"read", **event})

    async def chat_typing(self, event):
        await self.send_json({"type":"typing", **event})

    async def chat_system(self, event):
        await self.send_json({"type":"system", **event})

    # --- 유틸
    async def send_json(self, data):
        await self.send(text_data=json.dumps(data))
```

### D-4. NotifyConsumer(유저 개별 알림 스트림)

```python
# chat/consumers.py (추가)
from .utils import list_unread_badges

class NotifyConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        user = self.scope["user"]
        if not user.is_authenticated:
            await self.close(code=4401); return
        self.group_name = f"user:{user.id}"
        await self.channel_layer.group_add(self.group_name, self.channel_name)
        await self.accept()
        # 초기에 뱃지 전달
        badges = await list_unread_badges(user.id)
        await self.send_json({"type":"badge", "rooms": badges})

    async def disconnect(self, code):
        await self.channel_layer.group_discard(self.group_name, self.channel_name)

    async def notify(self, event):
        # {"type":"notify", "kind":"new_message", "room_id":..., "seq":...}
        await self.send_json(event)

    async def send_json(self, data):
        await self.send(text_data=json.dumps(data))
```

> 메시지 생성 시 `Notification`을 만들었으므로, 별도 작업(주기 태스크 또는 시점 트리거)에서 `user:<id>` 그룹으로 `notify` 이벤트를 날려주면 브라우저는 **탑바 배지**를 즉시 갱신할 수 있습니다. 최소 구현은 **메시지 브로드캐스트와 동시에 멤버별 user 그룹으로도 전송**하는 방법을 사용합니다.

브로드캐스트 시 알림도 발송:

```python
# ChatConsumer.receive "send" 처리 직후 추가
for uid in await self.redis.smembers(f"room:{self.room_id}:members"):  # 멤버 목록 캐시(아래 G-3 참고)
    if int(uid) == self.scope["user"].id: continue
    await self.channel_layer.group_send(f"user:{uid}", {
        "type": "notify",
        "kind": "new_message",
        "room_id": str(self.room_id),
        "seq": seq
    })
```

(멤버 목록 캐시는 뒤 G-3 절에서 다룸)

---

## E. HTTP API (룸 생성/목록/멤버/히스토리)

```python
# chat/views.py
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse, HttpResponseForbidden
from django.shortcuts import get_object_or_404
from .models import Room, RoomMember, Message
from django.db.models import Max

@login_required
def room_create(request):
    # POST: {members: [2,3,...], is_group: true, name: "팀 채널"}
    if request.method != "POST":
        return JsonResponse({"error":"POST only"}, status=405)
    data = request.POST
    is_group = data.get("is_group") == "true"
    name = data.get("name","")
    members = request.POST.getlist("members[]")
    room = Room.objects.create(is_group=is_group, name=name)
    RoomMember.objects.bulk_create([RoomMember(room=room, user=request.user)])
    if members:
        RoomMember.objects.bulk_create([RoomMember(room=room, user_id=int(u)) for u in members])
    return JsonResponse({"room_id": str(room.id)})

@login_required
def room_list(request):
    qs = RoomMember.objects.filter(user=request.user).values("room_id")
    rooms = Room.objects.filter(id__in=qs).annotate(last_seq=Max("messages__seq")).order_by("-last_seq")
    data = [{"room_id": str(r.id), "name": r.name, "is_group": r.is_group, "last_seq": r.last_seq or 0} for r in rooms]
    return JsonResponse({"items": data})
```

---

## F. 프런트엔드(간단 HTML/JS)

```html
<!-- templates/chat/room.html -->
<h2 id="room-name"></h2>
<div id="log" style="height:300px; overflow:auto; border:1px solid #ccc"></div>
<input id="msg" placeholder="메시지를 입력…" />
<button id="send">보내기</button>

<script>
const roomId = "{{ room_id }}";
const ws = new WebSocket("wss://" + location.host + "/ws/chat/" + roomId + "/");
ws.onopen = () => console.log("connected");
ws.onmessage = (e) => {
  const data = JSON.parse(e.data);
  if (data.type === "history") {
    data.items.forEach(addLine);
  } else if (data.type === "message") {
    addLine(data);
  } else if (data.type === "read") {
    // 읽음 표시 업데이트 (여기서는 생략)
  } else if (data.type === "typing") {
    // "상대가 입력 중…" UI 반영
  }
};
function addLine(m) {
  const el = document.getElementById("log");
  const div = document.createElement("div");
  div.textContent = `[${m.seq || ""}] ${m.sender_id || ""}: ${m.text || ""}`;
  el.appendChild(div);
  el.scrollTop = el.scrollHeight;
}
document.getElementById("send").onclick = () => {
  const text = document.getElementById("msg").value.trim();
  if (!text) return;
  ws.send(JSON.stringify({action:"send", text, client_mid: crypto.randomUUID()}));
  document.getElementById("msg").value = "";
  // 내 화면에서 낙관적 표시(선택), 서버 응답으로 최종 seq/시간 확정
};
document.getElementById("msg").addEventListener("input", debounce(()=>{
  ws.send(JSON.stringify({action:"typing", state:true}));
  setTimeout(()=>ws.send(JSON.stringify({action:"typing", state:false})), 1500);
}, 200));

function debounce(f, d){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>f(...a),d); } }
</script>
```

---

## G. 확장: 멤버 캐시/프레즌스/타이핑/뱃지

### G-1. 프레즌스
- 키: `room:<id>:online` (Set of user_ids)
- 연결 시 `SADD`, 종료 시 `SREM`.
- 정기 청소(예: WebSocket 끊김 예외 케이스) 위해 TTL heartbeat 키를 둘 수도 있음: `presence:<uid>` with expire.

### G-2. 타이핑
- 키: `room:<id>:typing` (Hash {user_id: last_ts})
- UI에선 `now - last_ts < 2s` 인 사용자만 “입력 중” 표시.

### G-3. 멤버 캐시
- 키: `room:<id>:members` (Set) — 룸 멤버 user_id
- 룸 생성/멤버 추가/탈퇴 시 업데이트. 실무는 DB → Redis 백필 또는 첫 접근시 warm-up.

```python
# chat/cache.py
import redis.asyncio as aioredis
REDIS = aioredis.from_url("redis://127.0.0.1:6379/0", decode_responses=True)

async def warm_members(room_id: str, members: list[int]):
    await REDIS.delete(f"room:{room_id}:members")
    if members:
        await REDIS.sadd(f"room:{room_id}:members", *map(str, members))
```

---

## H. 멱등성/순서/재연결 복구

### H-1. 멱등성
- 클라이언트는 `client_mid`(UUID)와 함께 송신.
- 서버는 `(room_id, sender, client_mid)` 최근 N개를 Redis Set/TTL에 기록하여 **중복 메시지 재처리 방지** (네트워크 재전송 대응).  
- 본 예제에서는 DB에 중복을 허용하되, 실무에서는 **Message.client_mid에 Index** 후 `(room, sender, client_mid)` unique 제약을 두어 **강제 멱등** 가능.

```python
# Message 모델에 unique_together 추가 고려:
# unique_together = [("room","sender","client_mid")]  # client_mid가 빈문자 가능 → NOT NULL 제약 권장
```

### H-2. 순서
- 룸 단위 **seq**를 Redis INCR로 배정 → 모든 워커에서 **단조 증가**.
- 브로드캐스트 전에 seq가 확정되므로 클라이언트는 순서대로 렌더 가능.

### H-3. 재연결
- 클라이언트는 마지막 렌더된 `seq`를 기억 → 재접속 시 `"history", after: last_seq` 로 **갭만 요청**.
- 서버는 반환된 아이템을 전송 → 끊긴 동안의 메시지만 복구.

---

## I. 읽음 처리(✔✔) UX와 서버 흐름

1) 클라에서 메시지를 렌더 후, 뷰포트에 노출되면 `"read", seq: last_visible_seq` 전송  
2) 서버는 `ReadReceipt.last_read_seq = max(old, seq)` 업데이트  
3) 서버는 룸 그룹에 `"chat.read", user_id, seq"` 브로드캐스트 → **상대 클라**는 내 말풍선에 ✔✔ 표시/수정

> 읽음 커서는 **단조 증가**해야 하며, 과거 메시지를 다시 읽더라도 커서를 되돌리지 않습니다.

---

## J. 알림(Notification) 설계

### J-1. 브라우저 알림/탑바 뱃지
- `NotifyConsumer`로 `user:<id>` 그룹에 **배지 업데이트** 이벤트 푸시
- 탑바 컴포넌트는 `"badge"` 수신 시 뱃지 갱신

### J-2. 오프라인 푸시(선택)
- 모바일/웹 푸시 토큰을 별도 테이블에 저장
- 새 메시지 생성 시, **해당 사용자가 오프라인**(presence set에 없음) 이고 룸 mute가 아니면 **푸시 큐에 적재**
- 푸시는 별도 워커(Celery)로 전송(FCM/APNS/웹푸시)

```python
# chat/tasks.py (개략)
from celery import shared_task
@shared_task
def push_notify(user_id: int, title: str, body: str):
    # FCM/APNS/WebPush 발송
    pass
```

---

## K. 권한/보안/레이트 리밋

### K-1. 권한
- **소켓 연결** 시점에 룸 멤버 검사
- 메시지 수신/읽음/타이핑 모두 **룸 멤버만** 허용

### K-2. 레이트 리밋
- 키: `rl:room:<id>:user:<uid>` → 1초당 5개, 1분당 100개 등  
- 초과 시 메시지 드롭/경고/연결 종료

```python
# chat/ratelimit.py
import time
import redis.asyncio as aioredis
R = aioredis.from_url("redis://127.0.0.1:6379/0", decode_responses=True)

async def allow(key: str, limit: int, window: int) -> bool:
    now = int(time.time())
    pipe = R.pipeline()
    pipe.zremrangebyscore(key, 0, now - window)
    pipe.zadd(key, {str(now): now})
    pipe.zcard(key)
    pipe.expire(key, window)
    _, _, count, _ = await pipe.execute()
    return count <= limit
```

컨슈머에서 사용:

```python
if action == "send":
    ok = await allow(f"rl:s:{self.room_id}:{user.id}", limit=5, window=1)
    if not ok:
        return  # or close
```

### K-3. 콘텐츠 보안
- 텍스트 sanitize(링크/스크립트 제거) — 템플릿 자동 이스케이프 + 필요시 bleach
- 파일 업로드는 4편에서 다루는 **MIME 검증/바이러스 스캔**

---

## L. 배포(ASGI) & Nginx

### L-1. Daphne/Uvicorn 실행

```bash
daphne -b 0.0.0.0 -p 8001 config.asgi:application
# 또는
uvicorn config.asgi:application --host 0.0.0.0 --port 8001
```

### L-2. Nginx 웹소켓 프록시 예시

```nginx
location /ws/ {
    proxy_pass http://127.0.0.1:8001;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_read_timeout 60m;  # 장시간 연결 유지
}
```

---

## M. 테스트

### M-1. 데이터베이스 테스트(메시지/읽음)

```python
# chat/tests/test_message_read.py
import pytest
from django.contrib.auth import get_user_model
from chat.models import Room, RoomMember, Message, ReadReceipt
from django.utils import timezone

pytestmark = pytest.mark.django_db
User = get_user_model()

def test_message_and_read():
    u1 = User.objects.create_user("u1","u1@x.com","pw")
    u2 = User.objects.create_user("u2","u2@x.com","pw")
    r = Room.objects.create(is_group=False)
    RoomMember.objects.bulk_create([RoomMember(room=r,user=u1), RoomMember(room=r,user=u2)])
    # seq 1,2
    m1 = Message.objects.create(room=r, sender=u1, seq=1, text="hi")
    m2 = Message.objects.create(room=r, sender=u2, seq=2, text="yo")
    # 읽음
    rr, _ = ReadReceipt.objects.get_or_create(room=r, user=u1)
    rr.last_read_seq = 2; rr.save()
    assert ReadReceipt.objects.get(room=r,user=u1).last_read_seq == 2
```

### M-2. Channels 테스트(채널 레이어 메모리 백엔드)

```python
# chat/tests/test_ws.py
import pytest
from channels.testing import WebsocketCommunicator
from config.asgi import application
from django.contrib.auth.models import AnonymousUser
from django.contrib.sessions.middleware import SessionMiddleware
from django.contrib.auth import get_user_model
from channels.auth import AuthMiddlewareStack
from chat.models import Room, RoomMember

pytestmark = pytest.mark.asyncio

async def test_ws_connect(db):
    User = get_user_model()
    u = User.objects.create_user("u","u@x.com","pw")
    r = Room.objects.create()
    RoomMember.objects.create(room=r, user=u)
    path = f"/ws/chat/{r.id}/"
    communicator = WebsocketCommunicator(application, path)
    # 인증 세션 주입은 별도 미들웨어 셋업 필요(여기선 단순 연결만)
    connected, subproto = await communicator.connect()
    assert connected
    await communicator.disconnect()
```

> 실제 인증이 필요한 통합 테스트는 **AuthMiddlewareStack** 안에서 세션 쿠키를 심거나, **JWT 미들웨어**를 만들고 헤더를 세팅하는 방식으로 작성합니다.

---

## N. 운영/모니터링/튜닝

- **메트릭**: 방별 연결 수, 초당 메시지, Redis 레이턴시, DB write QPS, 브로드캐스트 지연  
- **로그**: 연결/해제, 에러, 허용되지 않은 액션, 레이트리밋 차단, 예외 스택  
- **알람**: Redis 연결 실패, 채널 레이어 publish 실패, DB deadlock 재시도  
- **튜닝**:
  - 메시지 저장은 **batched insert**(가능 시) 또는 **async write 큐**(Outbox) 고려  
  - 알림 푸시는 **비동기 큐**(Celery)로 분리  
  - 읽기 히스토리는 **페이지네이션** + **역순(최신부터)** 지원  
  - 대규모 룸(수천 명): 브로드캐스트 비용 큼 → **하위 그룹 샤딩** or **Fanout to users** (room→user N개)

---

## O. 확장 주제(간단 안내)

- **메시지 수정/삭제**: `edited_at/deleted_at`으로 소프트 체인지, 이벤트 브로드캐스트로 클라 동기화  
- **파일/이미지 메시지**: 업로드(서명 URL) → 메시지에 파일 메타 저장 → 썸네일/안전 검사(다음 편)  
- **검색/하이라이트**: 읽기 모델(Elasticsearch)로 인덱싱  
- **엔드투엔드 암호화**: 키 교환/클라 암복호화(서버는 페이로드 미인지)  
- **다국어/시간대**: 메시지 타임스탬프 로컬라이즈, i18n UI

---

## P. 체크리스트(요약)

**기능**
- [ ] 1:1/그룹 룸, 메시지/타이핑/읽음/알림
- [ ] 프레즌스/배지/히스토리

**일관성**
- [ ] 룸 시퀀스(REDIS INCR), 단조 증가
- [ ] 멱등키(client_mid) 처리
- [ ] 재연결 히스토리 after_seq

**보안**
- [ ] 룸 멤버 권한 검사
- [ ] 레이트 리밋 + 콘텐츠 sanitize
- [ ] 인증 미들웨어(Session/JWT)

**운영**
- [ ] Redis/DB 모니터링
- [ ] 알림/푸시 큐 분리
- [ ] Nginx 웹소켓 프록시/타임아웃

---

## Q. 결론

- **Channels + Redis** 조합으로 **순서/멱등/재연결**을 신경 쓰면 **안정적인 실시간 채팅**을 구축할 수 있습니다.  
- **읽음/알림/타이핑/프레즌스**는 Redis 자료구조(Set/Hash/INCR)와 **그룹 브로드캐스트**로 간결하게 맞출 수 있습니다.  
- 트래픽이 증가하면 **샤딩/팬아웃 패턴**, **Outbox/비동기 푸시**, **읽기 모델 분리**로 확장하세요.

```python
# 끝까지 따라 한 경우 최소 실행 체크:
# - settings CHANNEL_LAYERS/ASGI ok
# - migrate 후 Room/RoomMember 생성
# - /ws/chat/<room_id>/ 연결 → send/read 동작
# - NotifyConsumer로 배지 수신
```