---
layout: post
title: 이산수학 - 유한 상태 기계
date: 2025-07-03 20:20:23 +0900
category: 이산수학
---
# 유한 상태 기계 (Finite State Machine, FSM)

## 0. 왜 FSM인가?

- **간결한 상태 모델**: 복잡한 시스템을 유한 개 상태와 전이로 모델링
- **형식적 검증 용이**: 안전성, 도달성, 결정성 등을 수학적으로 확인
- **실전 적용 폭넓음**: 컴파일러 렉서, 네트워크 프로토콜, 임베디드 제어기, 게임 AI, UI 흐름, 보안 패턴 탐지 등

---

## 1. 출력 없는 FSM: DFA/NFA/ε-NFA

### 1.1 DFA 정의 (Deterministic Finite Automaton)
$$
M=(Q,\Sigma,\delta,q_0,F)
$$
- \(Q\): 유한 상태 집합
- \(\Sigma\): 유한 입력 알파벳
- \(\delta: Q\times\Sigma\to Q\): **단일** 다음 상태
- \(q_0\in Q\): 시작 상태
- \(F\subseteq Q\): 최종(수용) 상태 집합

**수용(acceptance)**
문자열 \(w=a_1a_2\cdots a_n\)에 대해 확장 전이 \(\delta^*\):
$$
\delta^*(q,w)=\begin{cases}
q & (w=\varepsilon)\\
\delta(\delta^*(q,a_1\cdots a_{n-1}),a_n) & (n\ge1)
\end{cases}
$$
\(\ \delta^*(q_0,w)\in F\) 이면 \(w\)를 **수용**.

---

### 1.2 NFA/ε-NFA 정의
- **NFA**: \(\delta: Q\times\Sigma \to 2^Q\) (다음 상태가 집합)
- **ε-NFA**: \(\delta: Q\times(\Sigma\cup\{\varepsilon\}) \to 2^Q\) (입력 소모 없이 ε 전이 허용)

**ε-폐포(closure)**
상태집합 \(S\)의 ε-폐포 \(\mathrm{Eps}(S)\): \(S\)에서 ε-전이만 따라 도달 가능한 모든 상태 집합.

---

### 1.3 미세 팁: 완전 DFA & 함정(trap) 상태
- 모든 \((q,a)\)에 대해 \(\delta(q,a)\)가 정의되게 하려면 **함정 상태**(모든 입력이 자기 루프)를 추가.
- 최소화/합성 시 **완전 DFA**가 편리.

---

## 2. 출력 있는 FSM: Mealy & Moore 트랜스듀서

| 구분 | 출력 의존 | 출력 시점 | 출력 함수 |
|---|---|---|---|
| **Mealy** | (상태, 입력) | 입력 처리 즉시 | \(\lambda:Q\times\Sigma\to\Gamma\) |
| **Moore** | 상태 | 상태 진입 시 | \(\lambda:Q\to\Gamma\) |

- **Mealy→Moore 변환**: 각 \((q,a)\)의 출력 차이를 상태 분할로 흡수 → 상태 수 증가 가능
- **Moore→Mealy 변환**: 간선 출력으로 옮김 → 상태 수 줄 수 있음

---

## 3. 예제 DFA: 2진 문자열의 ‘0’ 개수가 짝수인 언어
- 상태 \(E\)(짝수, 수용), \(O\)(홀수)
- 전이:
  - \(E\xrightarrow{0}O\), \(O\xrightarrow{0}E\)
  - \(E\xrightarrow{1}E\), \(O\xrightarrow{1}O\)

```python
def dfa_accepts(trans, start, finals, s):
    q = start
    for ch in s:
        if ch not in trans[q]:  # 미정의 입력 방지
            return False
        q = trans[q][ch]
    return q in finals

trans = {
    'E': {'0': 'O', '1': 'E'},
    'O': {'0': 'E', '1': 'O'},
}
print(dfa_accepts(trans, 'E', {'E'}, "0100"))  # False
print(dfa_accepts(trans, 'E', {'E'}, "010"))   # True
```

---

## 4. ε-NFA 시뮬레이터 & NFA→DFA 결정화(Subset Construction)

### 4.1 ε-폐포와 시뮬레이터
```python
from collections import defaultdict, deque

class ENFA:
    def __init__(self, states, alphabet, start, finals):
        self.Q = set(states)
        self.Sigma = set(alphabet)
        self.start = start
        self.F = set(finals)
        # transitions[(q,a)] -> set of next states; a is symbol or None for ε
        self.transitions = defaultdict(set)

    def add(self, q, a, r):
        self.transitions[(q, a)].add(r)

    def eps_closure(self, S):
        stack = list(S)
        seen = set(S)
        while stack:
            q = stack.pop()
            for r in self.transitions.get((q, None), ()):
                if r not in seen:
                    seen.add(r)
                    stack.append(r)
        return seen

    def move(self, S, a):
        nxt = set()
        for q in S:
            nxt |= self.transitions.get((q, a), set())
        return nxt

    def accepts(self, s):
        cur = self.eps_closure({self.start})
        for ch in s:
            cur = self.eps_closure(self.move(cur, ch))
            if not cur:
                return False
        return len(cur & self.F) > 0
```

### 4.2 Subset Construction (ε-NFA → DFA)
```python
def enfa_to_dfa(enfa):
    start_set = frozenset(enfa.eps_closure({enfa.start}))
    d_states = {start_set}
    queue = deque([start_set])
    d_trans = {}
    finals = set()

    while queue:
        S = queue.popleft()
        d_trans[S] = {}
        if S & enfa.F:
            finals.add(S)
        for a in enfa.Sigma:
            T = enfa.eps_closure(enfa.move(S, a))
            T = frozenset(T)
            if not T:
                continue
            d_trans[S][a] = T
            if T not in d_states:
                d_states.add(T)
                queue.append(T)

    # 선택적으로 trap 상태 완성
    # (여기선 생략; 필요시 모든 (state,a) 채워주세요)
    return d_states, d_trans, start_set, finals
```

**테스트 (간단 ε-NFA: 정규식 `a(b|ε)` 수용)**
```python
# States: 0(start) --a--> 1 --ε--> 2(final)
#                 \--a--> 1 --b--> 2
E = ENFA(states=[0,1,2], alphabet=['a','b'], start=0, finals=[2])
E.add(0,'a',1)
E.add(1,None,2)  # ε
E.add(1,'b',2)
print(E.accepts("a"))   # True
print(E.accepts("ab"))  # True
print(E.accepts("b"))   # False

D_states, D_trans, D_start, D_finals = enfa_to_dfa(E)
# DFA로도 같은 결과가 나와야 함
def dfa_accepts_sets(trans, start, finals, s):
    q = start
    for ch in s:
        if ch not in trans[q]: return False
        q = trans[q][ch]
    return q in finals

print(dfa_accepts_sets(D_trans, D_start, D_finals, "a"))   # True
print(dfa_accepts_sets(D_trans, D_start, D_finals, "ab"))  # True
print(dfa_accepts_sets(D_trans, D_start, D_finals, "b"))   # False
```

---

## 5. DFA 최소화: Hopcroft 알고리즘

- **아이디어**: 수용/비수용으로 시작해, 각 입력 기호에 대한 **귀속(partition-refinement)** 으로 동치 상태 분할
- **시간복잡도**: \(O(|\Sigma|\cdot |Q|\log|Q|)\)

```python
def hopcroft_minimize(trans, start, finals, alphabet):
    # trans: dict[state][a] = next_state (완전 DFA 가정 권장)
    Q = set(trans.keys())
    F = set(finals)
    P = [F, Q - F]  # 파티션
    W = [F] if len(F) < len(Q - F) else [Q - F]

    while W:
        A = W.pop()
        for a in alphabet:
            # X = { q | δ(q,a) ∈ A }
            X = {q for q in Q if trans.get(q, {}).get(a) in A}
            newP = []
            for Y in P:
                i = Y & X
                d = Y - X
                if i and d:
                    newP.extend([i, d])
                    # 업데이트 W
                    if Y in W:
                        W.remove(Y); W.extend([i, d])
                    else:
                        W.append(i if len(i) <= len(d) else d)
                else:
                    newP.append(Y)
            P = newP

    # 대표자 매핑
    rep = {}
    for block in P:
        r = next(iter(block))
        for q in block:
            rep[q] = r

    min_states = {rep[q] for q in Q}
    min_start = rep[start]
    min_finals = {rep[q] for q in F}
    min_trans = {r: {} for r in min_states}
    for q in Q:
        r = rep[q]
        for a, t in trans.get(q, {}).items():
            min_trans[r][a] = rep[t]
    return min_states, min_trans, min_start, min_finals
```

**소규모 테스트**: 등가 상태가 있는 DFA에 적용해 상태 수가 줄어드는지 확인하세요.

---

## 6. 정규식 → ε-NFA (Thompson Construction) — 핵심 버전

지원: **연결(암시), 합 `|`, Kleene-스타 `*`, 괄호 `( )`**
절차: 정규식을 후위표기(Shunting-yard) → 스택 머지로 NFA 프래그먼트 조립

```python
# 6.1 Shunting-yard to postfix with explicit concatenation '.'
def re_to_postfix(regex):
    # 1) insert explicit concatenation '.'
    out = []
    ops = []
    # precedence: * > . > |
    prec = {'|':1, '.':2, '*':3}
    def need_concat(prev, cur):
        if prev is None: return False
        # concat when (symbol or ') or '*') followed by (symbol or '(')
        if (prev.isalnum() or prev in (')','*')) and (cur.isalnum() or cur=='('):
            return True
        return False
    r = []
    prev = None
    for c in regex:
        if need_concat(prev, c):
            r.append('.')
        r.append(c)
        prev = c

    for c in r:
        if c.isalnum():
            out.append(c)
        elif c == '(':
            ops.append(c)
        elif c == ')':
            while ops and ops[-1] != '(':
                out.append(ops.pop())
            ops.pop()  # pop '('
        else:  # operator
            while ops and ops[-1] != '(' and prec[ops[-1]] >= prec[c]:
                out.append(ops.pop())
            ops.append(c)
    while ops:
        out.append(ops.pop())
    return ''.join(out)

# 6.2 Thompson construction
class Frag:
    def __init__(self, start, accepts):
        self.start = start
        self.accepts = accepts  # set of accept states

class ThompsonENFA(ENFA):
    def __init__(self):
        super().__init__(states=[], alphabet=[], start=None, finals=[])
        self._next = 0

    def new_state(self):
        s = self._next; self._next += 1
        self.Q.add(s)
        return s

    def from_postfix(self, postfix):
        stack = []
        for c in postfix:
            if c.isalnum():
                s = self.new_state()
                t = self.new_state()
                self.add(s, c, t)
                stack.append(Frag(s, {t}))
                self.Sigma.add(c)
            elif c == '.':  # concat
                f2 = stack.pop(); f1 = stack.pop()
                for a in f1.accepts:
                    self.add(a, None, f2.start)
                stack.append(Frag(f1.start, f2.accepts))
            elif c == '|':  # union
                f2 = stack.pop(); f1 = stack.pop()
                s = self.new_state(); t = self.new_state()
                self.add(s, None, f1.start)
                self.add(s, None, f2.start)
                for a in f1.accepts: self.add(a, None, t)
                for a in f2.accepts: self.add(a, None, t)
                stack.append(Frag(s, {t}))
            elif c == '*':  # star
                f = stack.pop()
                s = self.new_state(); t = self.new_state()
                self.add(s, None, f.start)  # enter
                self.add(s, None, t)        # ε for empty
                for a in f.accepts:
                    self.add(a, None, f.start)  # loop
                    self.add(a, None, t)
                stack.append(Frag(s, {t}))
            else:
                raise ValueError(f'unsupported token {c}')
        f = stack.pop()
        self.start = f.start
        self.F = set(f.accepts)

# Quick demo: regex (a|b)*abb
post = re_to_postfix("(a|b)*abb")
N = ThompsonENFA()
N.from_postfix(post)
for s in ["abb", "aabb", "babb", "ab", "abba"]:
    print(s, N.accepts(s))
```

---

## 7. Mealy/Moore 트랜스듀서 — 스트리밍 변환

### 7.1 Mealy 예제: 1의 패리티를 출력(E/O)
```python
class Mealy:
    def __init__(self, trans, out, start):
        self.trans = trans      # trans[q][a] -> q'
        self.out = out          # out[q][a]  -> gamma
        self.start = start

    def run(self, s):
        q = self.start
        outs=[]
        for ch in s:
            outs.append(self.out[q][ch])
            q = self.trans[q][ch]
        return ''.join(outs)

trans = {'E': {'0':'E','1':'O'}, 'O': {'0':'O','1':'E'}}
out   = {'E': {'0':'E','1':'O'}, 'O': {'0':'O','1':'E'}}
m = Mealy(trans, out, 'E')
print(m.run("10101"))  # OEOEO
```

### 7.2 Moore 예제: 신호등 제어 (상태별 출력)
```python
class Moore:
    def __init__(self, trans, out_state, start):
        self.trans = trans          # trans[q][a] -> q'
        self.out_state = out_state  # out_state[q] -> gamma
        self.start = start

    def run(self, inputs):
        q = self.start
        outs = [self.out_state[q]]  # 초기 출력
        for ch in inputs:
            q = self.trans[q][ch]
            outs.append(self.out_state[q])
        return outs

trans = {
  'G': {'t':'Y'},   # 타이머 t가 오면 다음
  'Y': {'t':'R'},
  'R': {'t':'G'}
}
out_state = {'G':'Green', 'Y':'Yellow', 'R':'Red'}
controller = Moore(trans, out_state, 'G')
print(controller.run("ttt"))  # ['Green','Yellow','Red','Green']
```

**설계 팁**
- **Mealy**: 입력 변화에 즉각 반응(지연↓), 하지만 입력 글리치에 취약 → 하드웨어선 동기화 필요
- **Moore**: 상태 기반 안정 출력(안정↑), 대신 반응 1클럭 지연

---

## 8. FSM 합성/연산: 합·교·여·연결·반복

- **정규 언어 닫힘성**: 합/교/차/여/연결/스타 모두 닫힘
- **구성법**
  - 합: 제품구성 \((Q_1\times Q_2)\), 최종 \(F_1\times Q_2 \cup Q_1\times F_2\)
  - 교: 제품구성, 최종 \(F_1\times F_2\)
  - 여: DFA에서 \(F\) ↔ \(Q\setminus F\)
  - 연결/스타: ε-NFA로 자연스럽게 구성, 이후 NFA→DFA

---

## 9. 실전 시나리오

### 9.1 **네트워크 프로토콜(축약) — 3-way handshake 감시기 (Mealy)**
- 상태: `INIT → SYN_RCVD → ESTABLISHED`
- 입력: `SYN`, `ACK`, `RST`, 기타
- 출력: `OK/ERR/ALERT` 등 즉시 신호

```python
trans = {
 'INIT': {'SYN':'SYN_RCVD', 'RST':'INIT', '*':'INIT'},
 'SYN_RCVD': {'ACK':'EST', 'RST':'INIT', '*':'SYN_RCVD'},
 'EST': {'RST':'INIT', '*':'EST'}
}
out = {
 'INIT': {'SYN':'OK','RST':'OK','*':'-'},
 'SYN_RCVD': {'ACK':'OK','RST':'-','*':'-'},
 'EST': {'RST':'OK','*':'-'}
}
def mealy_run(trans, out, start, seq):
    q=start; outs=[]
    for a in seq:
        gamma = out[q].get(a, out[q].get('*','-'))
        outs.append(gamma)
        q = trans[q].get(a, trans[q].get('*', q))
    return q, outs

q, o = mealy_run(trans, out, 'INIT', ['SYN','ACK'])
print(q, o)  # EST ['OK','OK']
```

### 9.2 **버튼 디바운싱(임베디드) — Moore**
- `UP`/`DOWN` 원시 입력 → 안정된 `PRESSED/RELEASED` 출력

```
RELEASED --(DOWN for k ticks)--> PRESSED
   ^                               |
   |--(UP for k ticks)--------------
```

Moore로 상태별 출력(`0/1`)을 두고, 카운팅 입력으로 전이.

### 9.3 **렉서(토크나이저) DFA**
- 정수: `0|[1-9][0-9]*`
- 식별자: `[A-Za-z_][A-Za-z_0-9]*`
패턴별 DFA(또는 한 DFA에 통합)로 최대 접두(mmax) 수용.

---

## 10. 상태 부호화(하드웨어) & 품질

- **엔코딩**
  - Binary(⌈log₂|Q|⌉ 플립플롭), **One-hot**(|Q| 플립플롭, 전이 단순)
  - Gray(전이시 1비트만 변경 → 글리치↓)
- **클럭 도메인**: Mealy 입력 이질화 → 동기화 FF 2단 권장
- **검증**: 도달 불가 상태 제거, 완전 전이, 안전 상태로 리셋

---

## 11. 복잡도 & 한계

- DFA 인식: \(O(|w|)\) 시간, 상수 메모리(상태)
- NFA 인식(백트래킹 naïve): 지수적 가능 → **ε-NFA 시뮬은 집합 DP로 \(O(|w|\cdot |Q|)\)**
- NFA→DFA: 상태 수 최대 \(2^{|Q|}\) (이론적 폭증)
- DFA 최소화(Hopcroft): \(O(|\Sigma||Q|\log|Q|)\)

---

## 12. 테스트 베드 (스모크 테스트)

```python
def smoke_tests():
    # 1) DFA 짝수 0
    trans = {'E':{'0':'O','1':'E'}, 'O':{'0':'E','1':'O'}}
    assert dfa_accepts(trans,'E',{'E'},"010")==True
    assert dfa_accepts(trans,'E',{'E'},"0100")==False

    # 2) Thompson: (a|b)*abb
    post = re_to_postfix("(a|b)*abb")
    N = ThompsonENFA(); N.from_postfix(post)
    assert N.accepts("abb")
    assert N.accepts("babb")
    assert not N.accepts("ab")

    # 3) ENFA→DFA 동치성 샘플
    D_states, D_trans, D_start, D_finals = enfa_to_dfa(N)
    def runD(s): return dfa_accepts_sets(D_trans, D_start, D_finals, s)
    for s in ["", "a", "abb", "babb", "ab", "abba"]:
        assert runD(s) == N.accepts(s)

    print("All smoke tests passed.")
# smoke_tests()
```

---

## 13. 학습 체크리스트 & 과제

1. **DFA 설계**: \(L=\{w\in\{0,1\}^*\mid w \text{ mod }3=0\}\) (이진수 해석) DFA 만들고 테스트.
2. **ε-NFA 구성**: 정규식 `(0|1)*01` 의 Thompson 자동자 작성 → 결정화 → 최소화.
3. **Mealy→Moore 변환**: 출력이 입력 의존인 패리티 Mealy를 Moore로 옮겨 상태 수 비교.
4. **렉서 통합 DFA**: 정수/식별자/공백/기타 토큰을 하나의 DFA로 병합(우선순위/최대접두).
5. **디바운서 Moore**: 타이머 입력(tick)과 원시 입력(UP/DOWN)으로 전이표 설계, 시뮬레이터 작성.

---

## 14. 핵심 요약

- **DFA/NFA/ε-NFA**: 정규 언어 인식. ε-NFA는 구성 쉬움, DFA는 실행 빠름.
- **Subset Construction**: NFA→DFA, 때로 지수 폭증 가능.
- **Hopcroft**: 최소 DFA를 빠르게.
- **정규식→자동자**: Thompson(ε-NFA)→DFA→Min DFA 파이프라인이 표준.
- **Mealy/Moore**: 출력이 입력+상태/상태. 하드웨어/실시간에서 선택.
- **실전**: 프로토콜 모니터, 버튼 디바운스, 렉서, 게임/UI 상태기 등 FSM Everywhere!
