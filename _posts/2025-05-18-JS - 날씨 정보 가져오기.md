---
layout: post
title: JavaScript - 날씨 정보 가져오기
date: 2025-05-18 22:20:23 +0900
category: JavaScript
---
# 자바스크립트로 날씨 정보 가져오기 (OpenWeatherMap API 활용)

## 1. 준비

### 계정·키 발급
- OpenWeatherMap 회원가입 → API Keys에서 키 발급
- 무료 요금제는 분당/일 요청 제한이 있으므로 **캐싱/디바운스** 권장

### 핵심 REST 엔드포인트
- 현재 날씨:
  `GET https://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}&units=metric&lang=kr`
- 좌표 기반:
  `GET https://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={API_KEY}&units=metric&lang=kr`
- 5일/3시간 예보:
  `GET https://api.openweathermap.org/data/2.5/forecast?q={city}&appid={API_KEY}&units=metric&lang=kr`
- 공기질:
  `GET https://api.openweathermap.org/data/2.5/air_pollution?lat={lat}&lon={lon}&appid={API_KEY}`

> `units=metric`(섭씨), `imperial`(화씨), 기본은 Kelvin.
> `lang=kr`로 한국어 설명을 받을 수 있습니다.

---

## 2. V1 — 단일 도시 현재 날씨 (최소 기능)

### HTML

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>날씨 정보</title>
  <link rel="stylesheet" href="./style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
  <main class="container">
    <h1>날씨 정보 조회</h1>

    <form id="searchForm" class="row" autocomplete="off">
      <input type="text" id="cityInput" placeholder="도시명을 입력하세요 (예: Seoul)" required />
      <button id="searchBtn" type="submit">검색</button>
    </form>

    <section id="status" aria-live="polite" class="status"></section>
    <section id="weatherResult" class="card" aria-live="polite"></section>
  </main>

  <script src="./app.v1.js" defer></script>
</body>
</html>
```

### CSS (기본 스타일)

```css
/* style.css */
:root {
  --gap: .75rem;
  --border: #d0d0d0;
  --muted: #666;
}
* { box-sizing: border-box; }
body { font-family: system-ui, sans-serif; margin: 24px; display:flex; justify-content:center; }
.container { width: min(680px, 92vw); }
.row { display: grid; grid-template-columns: 1fr auto; gap: var(--gap); margin: var(--gap) 0; }
input, button { padding: .6rem .8rem; font-size: 1rem; }
button { cursor: pointer; }
.status { min-height: 1.5rem; color: var(--muted); margin: .25rem 0 .75rem; }
.card { border: 1px solid var(--border); border-radius: 10px; padding: 1rem; min-height: 96px; }
.result-grid { display:grid; grid-template-columns: 96px 1fr; gap: var(--gap); align-items:center; }
.kv { margin:.25rem 0; }
.kv b { display:inline-block; width: 7em; }
```

### JS (단일 요청 + 기본 예외)

```js
// app.v1.js
const API_KEY = "YOUR_API_KEY"; // 실제 키로 교체
const form = document.getElementById("searchForm");
const input = document.getElementById("cityInput");
const result = document.getElementById("weatherResult");
const statusEl = document.getElementById("status");

form.addEventListener("submit", async (e) => {
  e.preventDefault();
  const city = input.value.trim();
  if (!city) return;
  await fetchWeatherByCity(city);
});

async function fetchWeatherByCity(city) {
  const url = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(
    city
  )}&appid=${API_KEY}&units=metric&lang=kr`;

  statusEl.textContent = "불러오는 중...";
  result.innerHTML = "";

  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error("도시 정보를 찾을 수 없습니다.");
    const data = await res.json();
    renderWeather(data);
    statusEl.textContent = "";
  } catch (err) {
    statusEl.textContent = "";
    result.innerHTML = `<p style="color:#b00;">오류: ${err.message}</p>`;
  }
}

function renderWeather(data) {
  const name = data.name;
  const temp = data.main?.temp;
  const feels = data.main?.feels_like;
  const humidity = data.main?.humidity;
  const wind = data.wind?.speed;
  const weather = data.weather?.[0]?.description ?? "";
  const icon = data.weather?.[0]?.icon ?? "01d";

  result.innerHTML = `
    <div class="result-grid">
      <img src="https://openweathermap.org/img/wn/${icon}@2x.png" alt="${weather}" width="96" height="96"/>
      <div>
        <h2>${name}</h2>
        <p class="kv"><b>현재</b> ${temp}℃ (${weather})</p>
        <p class="kv"><b>체감</b> ${feels}℃</p>
        <p class="kv"><b>습도</b> ${humidity}%</p>
        <p class="kv"><b>바람</b> ${wind} m/s</p>
      </div>
    </div>
  `;
}
```

---

## 3. V1.5 — UX 다듬기: 로딩·에러·접근성

### 로딩 스피너/상태, 에러 메시지, 입력 잠금

```js
// 공용 헬퍼
function setLoading(isLoading) {
  if (isLoading) {
    statusEl.textContent = "불러오는 중...";
    input.setAttribute("aria-busy", "true");
    input.disabled = true;
  } else {
    statusEl.textContent = "";
    input.removeAttribute("aria-busy");
    input.disabled = false;
  }
}

async function fetchJson(url, opts = {}) {
  setLoading(true);
  try {
    const res = await fetch(url, opts);
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(`HTTP ${res.status} ${res.statusText} ${text ? "- " + text : ""}`);
    }
    return await res.json();
  } finally {
    setLoading(false);
  }
}
```

호출부를 `fetchJson`으로 교체:

```js
async function fetchWeatherByCity(city) {
  const url = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(
    city
  )}&appid=${API_KEY}&units=metric&lang=kr`;

  result.innerHTML = "";
  try {
    const data = await fetchJson(url);
    renderWeather(data);
  } catch (err) {
    result.innerHTML = `<p role="alert" style="color:#b00;">오류: ${err.message}</p>`;
  }
}
```

> `role="alert"` 또는 `aria-live`로 **스크린리더가 에러를 즉시 읽어주도록** 합니다.

---

## 4. V2 — 지오로케이션, 취소(AbortController), 디바운스

### 지오로케이션 버튼 추가

```html
<button id="useMyLocation" type="button">현재 위치로</button>
```

```js
const useMyLocation = document.getElementById("useMyLocation");
useMyLocation.addEventListener("click", () => {
  if (!navigator.geolocation) {
    result.innerHTML = `<p role="alert" style="color:#b00;">이 브라우저는 위치 정보를 지원하지 않습니다.</p>`;
    return;
  }
  navigator.geolocation.getCurrentPosition(
    ({ coords }) => fetchWeatherByCoords(coords.latitude, coords.longitude),
    (err) => {
      result.innerHTML = `<p role="alert" style="color:#b00;">위치 접근이 거부되었거나 실패했습니다. (${err.code})</p>`;
    },
    { enableHighAccuracy: false, timeout: 8000 }
  );
});

async function fetchWeatherByCoords(lat, lon, signal) {
  const url = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}
    &appid=${API_KEY}&units=metric&lang=kr`.replace(/\s+/g, "");
  try {
    const data = await fetchJson(url, { signal });
    renderWeather(data);
  } catch (err) {
    if (err.name === "AbortError") return; // 취소
    result.innerHTML = `<p role="alert" style="color:#b00;">오류: ${err.message}</p>`;
  }
}
```

### 요청 취소(AbortController)

질의가 바뀔 때 이전 네트워크를 취소하여 **낭비/경쟁 상태** 방지:

```js
let aborter = null;

async function fetchWeatherByCityCancellable(city) {
  if (aborter) aborter.abort();
  aborter = new AbortController();

  const url = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(
    city
  )}&appid=${API_KEY}&units=metric&lang=kr`;

  result.innerHTML = "";
  try {
    const data = await fetchJson(url, { signal: aborter.signal });
    renderWeather(data);
  } catch (err) {
    if (err.name === "AbortError") return;
    result.innerHTML = `<p role="alert" style="color:#b00;">오류: ${err.message}</p>`;
  } finally {
    aborter = null;
  }
}
```

### 입력 디바운스(자동 검색)

```js
function debounce(fn, ms = 400) {
  let t = 0;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), ms);
  };
}

const onType = debounce((v) => {
  const city = v.trim();
  if (city.length >= 2) {
    fetchWeatherByCityCancellable(city);
  }
}, 500);

input.addEventListener("input", (e) => onType(e.target.value));
```

---

## 5. V3 — 5일/3시간 예보(`forecast`) + 간단 차트(바닐라)

예보 응답은 `list`에 3시간 간격으로 40개 내외의 항목이 들어옵니다.

### UI 추가

```html
<section id="forecast" class="card" aria-live="polite"></section>
```

### JS — 예보 가져오기/그리기

```js
async function fetchForecastByCity(city) {
  const url = `https://api.openweathermap.org/data/2.5/forecast?q=${encodeURIComponent(
    city
  )}&appid=${API_KEY}&units=metric&lang=kr`;
  try {
    const data = await fetchJson(url);
    renderForecast(data);
  } catch (err) {
    document.getElementById("forecast").innerHTML =
      `<p role="alert" style="color:#b00;">예보 오류: ${err.message}</p>`;
  }
}

function renderForecast(data) {
  const mount = document.getElementById("forecast");
  const items = data.list?.slice(0, 8) ?? []; // 다음 24시간(3시간×8)
  if (!items.length) { mount.textContent = "예보가 없습니다."; return; }

  // 간단한 텍스트 테이블
  const rows = items.map((x) => {
    const dt = new Date(x.dt * 1000);
    const hh = dt.getHours().toString().padStart(2, "0");
    const temp = Math.round(x.main.temp);
    const desc = x.weather?.[0]?.description ?? "";
    return `<tr><td>${hh}:00</td><td>${temp}℃</td><td>${desc}</td></tr>`;
  }).join("");

  mount.innerHTML = `
    <h3>다음 24시간 예보(3시간 간격)</h3>
    <table>
      <thead><tr><th>시각</th><th>기온</th><th>날씨</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}
```

검색 완료 후 현재 날씨와 함께 예보도 호출:

```js
async function fetchCityBundle(city) {
  await fetchWeatherByCityCancellable(city);
  await fetchForecastByCity(city);
}
form.addEventListener("submit", async (e) => {
  e.preventDefault();
  const city = input.value.trim();
  if (!city) return;
  await fetchCityBundle(city);
});
```

---

## 6. V4 — 단위/언어 전환 + 즐겨찾기(localStorage)

### 토글 UI

```html
<div class="row">
  <label>
    단위:
    <select id="unitSelect">
      <option value="metric">℃</option>
      <option value="imperial">℉</option>
    </select>
  </label>
  <label>
    언어:
    <select id="langSelect">
      <option value="kr">KR</option>
      <option value="en">EN</option>
      <option value="ja">JA</option>
    </select>
  </label>
</div>

<section class="card">
  <h3>즐겨찾기</h3>
  <form id="favForm" class="row">
    <input id="favCity" placeholder="도시명 추가" />
    <button type="submit">추가</button>
  </form>
  <ul id="favList"></ul>
</section>
```

### 상태/저장 로직

```js
const unitSel = document.getElementById("unitSelect");
const langSel = document.getElementById("langSelect");
const favForm = document.getElementById("favForm");
const favInput = document.getElementById("favCity");
const favList = document.getElementById("favList");

const state = {
  unit: localStorage.getItem("unit") || "metric",
  lang: localStorage.getItem("lang") || "kr",
  favorites: JSON.parse(localStorage.getItem("favorites") || "[]"),
};

unitSel.value = state.unit; langSel.value = state.lang;
renderFavorites();

unitSel.addEventListener("change", () => {
  state.unit = unitSel.value;
  localStorage.setItem("unit", state.unit);
  if (input.value.trim()) fetchCityBundleWithOptions(input.value.trim());
});
langSel.addEventListener("change", () => {
  state.lang = langSel.value;
  localStorage.setItem("lang", state.lang);
  if (input.value.trim()) fetchCityBundleWithOptions(input.value.trim());
});

favForm.addEventListener("submit", (e) => {
  e.preventDefault();
  const name = favInput.value.trim();
  if (!name) return;
  if (!state.favorites.includes(name)) {
    state.favorites.push(name);
    localStorage.setItem("favorites", JSON.stringify(state.favorites));
    renderFavorites();
  }
  favInput.value = "";
});

function renderFavorites() {
  favList.innerHTML = state.favorites.map((c, i) => `
    <li>
      <button type="button" data-city="${c}">${c}</button>
      <button type="button" data-remove="${i}">삭제</button>
    </li>
  `).join("");
}
favList.addEventListener("click", (e) => {
  const b = e.target.closest("button"); if (!b) return;
  if (b.dataset.city) fetchCityBundleWithOptions(b.dataset.city);
  if (b.dataset.remove) {
    const idx = Number(b.dataset.remove);
    state.favorites.splice(idx, 1);
    localStorage.setItem("favorites", JSON.stringify(state.favorites));
    renderFavorites();
  }
});
```

### 옵션 반영하여 호출

```js
function buildWeatherUrlByCity(city) {
  return `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${API_KEY}&units=${state.unit}&lang=${state.lang}`;
}
function buildForecastUrlByCity(city) {
  return `https://api.openweathermap.org/data/2.5/forecast?q=${encodeURIComponent(city)}&appid=${API_KEY}&units=${state.unit}&lang=${state.lang}`;
}

async function fetchWeatherByCityCancellableWithOptions(city) {
  if (aborter) aborter.abort();
  aborter = new AbortController();
  try {
    const data = await fetchJson(buildWeatherUrlByCity(city), { signal: aborter.signal });
    renderWeather(data);
  } catch (err) {
    if (err.name !== "AbortError")
      result.innerHTML = `<p role="alert" style="color:#b00;">오류: ${err.message}</p>`;
  } finally {
    aborter = null;
  }
}
async function fetchCityBundleWithOptions(city) {
  await fetchWeatherByCityCancellableWithOptions(city);
  try { await fetchForecastByCity(city); } catch {}
}
```

> 렌더링 시 단위 표기를 `state.unit`에 따라 `℃/℉, m/s/mph`로 바꿔주면 UX가 좋아집니다.

---

## 7. 보안 — API 키 보호(프록시 + .env)

클라이언트에 **직접 API 키를 넣는 것은 위험**합니다. 실제 서비스에서는 간단한 **서버 프록시**를 두고 키를 감춥니다.

### 프록시(Express) 예시

```js
// server.js
import express from "express";
import fetch from "node-fetch";
import dotenv from "dotenv";
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;
const API_KEY = process.env.OWM_KEY;

app.get("/api/weather", async (req, res) => {
  const { q, lat, lon, units = "metric", lang = "kr" } = req.query;
  const base = "https://api.openweathermap.org/data/2.5/weather";
  const url = q
    ? `${base}?q=${encodeURIComponent(q)}&appid=${API_KEY}&units=${units}&lang=${lang}`
    : `${base}?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=${units}&lang=${lang}`;
  try {
    const r = await fetch(url);
    const json = await r.json();
    res.status(r.status).json(json);
  } catch (e) {
    res.status(500).json({ error: "ProxyError", message: e.message });
  }
});

app.get("/api/forecast", async (req, res) => {
  const { q, units = "metric", lang = "kr" } = req.query;
  const url = `https://api.openweathermap.org/data/2.5/forecast?q=${encodeURIComponent(q)}&appid=${API_KEY}&units=${units}&lang=${lang}`;
  try {
    const r = await fetch(url);
    const json = await r.json();
    res.status(r.status).json(json);
  } catch (e) {
    res.status(500).json({ error: "ProxyError", message: e.message });
  }
});

app.use(express.static("public")); // 정적 파일: index.html 등
app.listen(PORT, () => console.log(`Listening on http://localhost:${PORT}`));
```

`public/app.js`에서 호출을 `/api/...`로 변경하면 **클라이언트 코드에는 키가 노출되지 않습니다**.

---

## 8. 성능 — 캐싱, 리트라이/백오프

### 간단 메모리 캐시(+ TTL)

```js
const cache = new Map(); // key: url, value: { data, expires }

async function fetchCachedJson(url, ttlMs = 60000, opts = {}) {
  const now = Date.now();
  const c = cache.get(url);
  if (c && c.expires > now) return c.data;
  const data = await fetchJson(url, opts);
  cache.set(url, { data, expires: now + ttlMs });
  return data;
}
```

### 지수 백오프 리트라이(429/네트워크 오류에)

```js
async function fetchWithRetry(url, { retries = 3, backoff = 400, ...opts } = {}) {
  let attempt = 0;
  for (;;) {
    try {
      const res = await fetch(url, opts);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      attempt++;
      if (attempt > retries) throw e;
      await new Promise(r => setTimeout(r, backoff * 2 ** (attempt - 1)));
    }
  }
}
```

---

## 9. 데이터 보정 — 체감온도/열지수 (수식 포함)

기온과 풍속, 습도로 **체감 온도**와 **열지수**를 계산하여 더 직관적 정보를 제공합니다.

### 체감온도(풍속 냉각; °C, `wind_speed` m/s, `temp` °C)

일반적으로 풍속 냉각(체감온도)은 화씨/마일을 기준 공식이 많습니다. 간단한 근사로 다음을 사용할 수 있습니다:

$$
T_{\text{wc}} \approx T - 0.7 \cdot v + 0.2
$$

- \(T\): 기온(℃), \(v\): 풍속(m/s)
- 참고: 공식은 다양한 버전이 있으며 기상청/NOAA 공식은 단위 변환이 필요합니다.

### 열지수(Heat Index; 단순 근사, °C/상대습도 RH)

섭씨용 근사식 중 하나:

$$
HI \approx T + 0.33 \cdot RH - 0.7 \cdot v - 4
$$

- \(T\): 기온(℃), \(RH\): 상대습도(0–1), \(v\): 풍속(m/s)
- 정밀 모델은 더 복잡한 다항식을 사용합니다.

실사용 예:

```js
function approxWindChillC(tempC, windMs) {
  return tempC - 0.7 * windMs + 0.2;
}
function approxHeatIndexC(tempC, rhPercent, windMs = 0) {
  const RH = rhPercent / 100;
  return tempC + 0.33 * RH - 0.7 * windMs - 4;
}
```

`renderWeather`에서 함께 표기:

```js
const windMs = data.wind?.speed ?? 0;
const feelApprox = approxHeatIndexC(temp, humidity, windMs);

result.innerHTML = `
  <!-- 기존 내용 + -->
  <p class="kv"><b>추정 체감</b> ${feelApprox.toFixed(1)}℃</p>
`;
```

> 과학적으로 엄밀한 수치가 필요한 경우에는 공식 문헌의 단위와 범위를 정확히 맞춰 변환하는 절차가 필요합니다.

---

## 10. 오류·디버깅 체크리스트, 구조, 확장

### 체크리스트
- [ ] `res.ok` 체크 누락 → 404/500를 성공으로 처리하지 않도록
- [ ] CORS 실패(프록시/서버 설정 확인)
- [ ] 과도한 호출 → 디바운스/캐싱/리트라이 적용
- [ ] 지오로케이션 권한 거부/타임아웃 처리
- [ ] 단위/언어 토글 시 즉시 재호출 및 표시 단위 일치
- [ ] 네트워크 취소(AbortController)로 레이스 컨디션 방지

### 폴더 구조(권장)

```
/public
  index.html
  style.css
  app.js        // UI 결합
  api.js        // fetchJson, fetchCachedJson, buildUrl 등
  geo.js        // geolocation 관련
  render.js     // DOM 렌더 함수
  util.js       // debounce, retry, format 등
server.js       // 프록시 (Express)
.env            // OWM_KEY=...
```

### 확장 아이디어
- 공기질(AQI) 표시: `/air_pollution`로 PM2.5/PM10/NO2 등
- 일 단위 예보(One Call API 3.0)
- 지도(Leaflet/Mapbox)와 연동해 클릭 위치 날씨
- PWA(서비스워커)로 오프라인 캐싱·홈 화면 설치
- SSG/프레임워크(Next/Vite)로 모듈화·코드 스플리팅

---

## 완성 예시(요약 통합본)

```html
<!-- index.html (요약) -->
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>날씨 앱</title>
  <link rel="stylesheet" href="./style.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
  <main class="container">
    <h1>날씨 정보</h1>
    <form id="searchForm" class="row" autocomplete="off">
      <input id="cityInput" placeholder="도시명 (예: Seoul)" required />
      <button id="searchBtn" type="submit">검색</button>
    </form>
    <div class="row">
      <button id="useMyLocation" type="button">현재 위치로</button>
      <label>단위:
        <select id="unitSelect">
          <option value="metric">℃</option>
          <option value="imperial">℉</option>
        </select>
      </label>
      <label>언어:
        <select id="langSelect">
          <option value="kr">KR</option>
          <option value="en">EN</option>
        </select>
      </label>
    </div>

    <section id="status" aria-live="polite" class="status"></section>
    <section id="weatherResult" class="card" aria-live="polite"></section>
    <section id="forecast" class="card" aria-live="polite"></section>

    <section class="card">
      <h3>즐겨찾기</h3>
      <form id="favForm" class="row">
        <input id="favCity" placeholder="도시명 추가" />
        <button type="submit">추가</button>
      </form>
      <ul id="favList"></ul>
    </section>
  </main>
  <script src="./app.js" defer></script>
</body>
</html>
```

```js
// app.js (요약)
const API_BASE = "/api"; // 프록시 사용 권장. 프록시 없으면 OWM URL로 대체.
const form = document.getElementById("searchForm");
const input = document.getElementById("cityInput");
const useMyLocation = document.getElementById("useMyLocation");
const unitSel = document.getElementById("unitSelect");
const langSel = document.getElementById("langSelect");
const result = document.getElementById("weatherResult");
const forecastEl = document.getElementById("forecast");
const statusEl = document.getElementById("status");
const favForm = document.getElementById("favForm");
const favInput = document.getElementById("favCity");
const favList = document.getElementById("favList");

let aborter = null;
const state = {
  unit: localStorage.getItem("unit") || "metric",
  lang: localStorage.getItem("lang") || "kr",
  favorites: JSON.parse(localStorage.getItem("favorites") || "[]"),
};

unitSel.value = state.unit; langSel.value = state.lang;

function setLoading(v){ statusEl.textContent = v ? "불러오는 중..." : ""; }

async function fetchJson(url, opts={}){
  setLoading(true);
  try{
    const r = await fetch(url, opts);
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    return await r.json();
  } finally { setLoading(false); }
}

function weatherUrl(city){
  return `${API_BASE}/weather?q=${encodeURIComponent(city)}&units=${state.unit}&lang=${state.lang}`;
}
function forecastUrl(city){
  return `${API_BASE}/forecast?q=${encodeURIComponent(city)}&units=${state.unit}&lang=${state.lang}`;
}

function renderWeather(d){
  const weather = d.weather?.[0]?.description ?? "";
  const icon = d.weather?.[0]?.icon ?? "01d";
  const windUnit = state.unit === "imperial" ? "mph" : "m/s";
  result.innerHTML = `
    <div class="result-grid">
      <img src="https://openweathermap.org/img/wn/${icon}@2x.png" alt="${weather}" width="96" height="96"/>
      <div>
        <h2>${d.name}</h2>
        <p class="kv"><b>현재</b> ${d.main.temp}°</p>
        <p class="kv"><b>체감</b> ${d.main.feels_like}°</p>
        <p class="kv"><b>습도</b> ${d.main.humidity}%</p>
        <p class="kv"><b>바람</b> ${d.wind.speed} ${windUnit}</p>
        <p class="kv"><b>날씨</b> ${weather}</p>
      </div>
    </div>`;
}

function renderForecast(data){
  const items = data.list?.slice(0,8) ?? [];
  if(!items.length){ forecastEl.textContent="예보가 없습니다."; return; }
  const rows = items.map(x=>{
    const hh = new Date(x.dt*1000).getHours().toString().padStart(2,"0");
    const temp = Math.round(x.main.temp);
    const desc = x.weather?.[0]?.description ?? "";
    return `<tr><td>${hh}:00</td><td>${temp}°</td><td>${desc}</td></tr>`;
  }).join("");
  forecastEl.innerHTML = `
    <h3>다음 24시간 예보</h3>
    <table>
      <thead><tr><th>시각</th><th>기온</th><th>날씨</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
}

async function fetchCity(city){
  if (aborter) aborter.abort();
  aborter = new AbortController();
  result.textContent = ""; forecastEl.textContent = "";
  try{
    const [w,f] = await Promise.all([
      fetchJson(weatherUrl(city), {signal:aborter.signal}),
      fetchJson(forecastUrl(city), {signal:aborter.signal}),
    ]);
    renderWeather(w); renderForecast(f);
  } catch(e){
    if(e.name !== "AbortError")
      result.innerHTML = `<p role="alert" style="color:#b00;">오류: ${e.message}</p>`;
  } finally { aborter=null; }
}

form.addEventListener("submit", e=>{
  e.preventDefault();
  const city = input.value.trim();
  if(city) fetchCity(city);
});
useMyLocation.addEventListener("click", ()=>{
  if(!navigator.geolocation){
    result.innerHTML = `<p role="alert" style="color:#b00;">지오로케이션 미지원</p>`;
    return;
  }
  navigator.geolocation.getCurrentPosition(async ({coords})=>{
    const {latitude:lat, longitude:lon} = coords;
    // 프록시 서버에 좌표 지원 라우트를 추가했을 경우 사용
    const url = `${API_BASE}/weather?lat=${lat}&lon=${lon}&units=${state.unit}&lang=${state.lang}`;
    try{
      const w = await fetchJson(url);
      input.value = w.name || "";
      renderWeather(w);
      const f = await fetchJson(`${API_BASE}/forecast?q=${encodeURIComponent(w.name)}&units=${state.unit}&lang=${state.lang}`);
      renderForecast(f);
    }catch(e){
      result.innerHTML = `<p role="alert" style="color:#b00;">오류: ${e.message}</p>`;
    }
  }, err=>{
    result.innerHTML = `<p role="alert" style="color:#b00;">위치 실패: ${err.code}</p>`;
  }, {timeout:8000});
});

unitSel.addEventListener("change", ()=>{
  state.unit = unitSel.value; localStorage.setItem("unit", state.unit);
  if(input.value.trim()) fetchCity(input.value.trim());
});
langSel.addEventListener("change", ()=>{
  state.lang = langSel.value; localStorage.setItem("lang", state.lang);
  if(input.value.trim()) fetchCity(input.value.trim());
});

// 즐겨찾기
state.favorites = JSON.parse(localStorage.getItem("favorites")||"[]");
renderFav();
favForm.addEventListener("submit", e=>{
  e.preventDefault();
  const c = favInput.value.trim(); if(!c) return;
  if(!state.favorites.includes(c)){
    state.favorites.push(c);
    localStorage.setItem("favorites", JSON.stringify(state.favorites));
    renderFav();
  }
  favInput.value="";
});
favList.addEventListener("click", e=>{
  const b = e.target.closest("button"); if(!b) return;
  if(b.dataset.city) fetchCity(b.dataset.city);
  if(b.dataset.remove){ state.favorites.splice(+b.dataset.remove,1);
    localStorage.setItem("favorites", JSON.stringify(state.favorites)); renderFav(); }
});
function renderFav(){
  favList.innerHTML = state.favorites.map((c,i)=>`
    <li>
      <button type="button" data-city="${c}">${c}</button>
      <button type="button" data-remove="${i}">삭제</button>
    </li>`).join("");
}
```

---

## 마무리

- **기초**: `fetch/async-await`과 `res.ok` 체크, 에러/로딩/접근성
- **실전**: 지오로케이션, 취소, 디바운스, 예보 표, 단위/언어, 즐겨찾기
- **보안/운영**: **프록시 서버로 API 키 보호**, 캐싱·리트라이·백오프
