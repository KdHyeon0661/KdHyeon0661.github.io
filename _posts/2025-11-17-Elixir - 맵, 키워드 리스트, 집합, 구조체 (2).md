---
layout: post
title: Elixir - 맵, 키워드 리스트, 집합, 구조체 (2)
date: 2025-11-17 16:25:23 +0900
category: Elixir
---
# 8장 — 구조체(Struct), 중첩 딕셔너리, 집합(MapSet), 그리고 “강력 기능”의 사용 기준

## — 도메인 모델의 표준 형태

### 개요: 왜 구조체를 쓰는가?

맵은 자유롭다.

```elixir
%{id: 1, email: "a@b", anything: 123}
```

- 장점: 키/값을 마음대로 넣을 수 있어 유연하다.
- 단점:
  - “이 맵이 **무엇**을 의미하는지”가 코드 상에서 드러나지 않는다.
  - 타이핑 실수(`:emial` vs `:email`)를 컴파일 타임에 잡기 어렵다.
  - 필수 필드가 누락돼 있어도 컴파일/런타임에서 잘 드러나지 않을 수 있다.

**구조체(Struct)** 는 “**필드 집합이 정해진 맵**”이다.

- 문법: `%Module{}`
- 내부는 맵과 동일하게 동작하지만,
  - **어떤 필드가 있어야 하는지** 고정된다.
  - **모듈 이름**이 타입/네임스페이스 역할을 한다.
  - 엘릭서 도구(타입스펙, 프로토콜, JSON 인코더 등)와 잘 맞는다.

“**이 데이터는 User라는 도메인 객체다**”를 코드 차원에서 명시하는 것,
그게 구조체의 핵심 목적이다.

---

### 정의 · 필수 필드 · 기본값

가장 기본적인 예제부터 보자.

```elixir
defmodule User do
  @enforce_keys [:id, :email]
  defstruct [:id, :email, name: nil, active: true, roles: MapSet.new()]
end

u = %User{id: 1, email: "a@b"}
# %User{
#   id: 1,
#   email: "a@b",
#   name: nil,
#   active: true,
#   roles: #MapSet<[]>
# }

```

설명:

- `defstruct`
  - 구조체의 **필드 목록과 기본값**을 정의한다.
  - `[필드1, 필드2, ...]` 또는 `[필드1: 기본값, 필드2: 기본값]` 형태.
- `@enforce_keys [:id, :email]`
  - 구조체 **리터럴 생성 시** 반드시 제공해야 하는 키들.
  - 예: `%User{}` 처럼 `id`, `email` 없이 만들면 `ArgumentError`가 난다.

```elixir
%User{}
# the following keys must also be given when building struct User: [:id, :email]

```

- 기본값의 역할:
  - `name: nil` → 이름이 아직 없는 상태를 명시.
  - `active: true` → “생성 시 기본적으로 활성 사용자”라는 도메인 규칙 반영.
  - `roles: MapSet.new()` → 빈 집합으로 초기화.

구조체 정의를 “도메인 스키마”로 보는 관점이 중요하다.

| 필드 | 타입(의도) | 의미 |
|------|------------|------|
| `id` | `pos_integer` | 내부 식별자 |
| `email` | `String.t` | 로그인/연락용 메일 주소 |
| `name` | `String.t | nil` | 표시 이름(없을 수 있음) |
| `active` | `boolean` | 활성/비활성 여부 |
| `roles` | `MapSet.t` | 역할/권한 집합 |

이 정보는 `@type`으로 정리해 둘 수 있다.

```elixir
defmodule User do
  @enforce_keys [:id, :email]
  defstruct [:id, :email, name: nil, active: true, roles: MapSet.new()]

  @type t :: %__MODULE__{
          id: pos_integer,
          email: String.t(),
          name: String.t() | nil,
          active: boolean,
          roles: MapSet.t(atom)
        }
end
```

타입스펙은 Dialyzer, 문서, IDE 지원에 모두 도움을 준다.

---

### 패턴 매칭 · 업데이트 문법

구조체는 맵처럼 **패턴 매칭**이 가능하지만,
특징은 **모듈 이름까지 함께 매칭**된다는 점이다.

```elixir
%User{id: id, email: e} = u
id  # 1
e   # "a@b"
```

- 오른쪽에 `%{id: 1, email: "a@b"}` 이런 맵을 넣으면 **매칭 실패**다.
- 구조체 패턴은 “이 값은 **반드시 User 구조체**여야 한다”는 의미를 갖는다.

함수 헤드에서 구조체 패턴을 쓰면 **계약**이 더 분명해진다.

```elixir
def print_user(%User{id: id, email: email}) do
  IO.puts("User##{id} <#{email}>")
end

def print_user(_), do: IO.puts("not a user")
```

업데이트는 `%{struct | key: value}` 문법으로 한다.

```elixir
u2 = %{u | name: "Kim"}
# %User{id: 1, email: "a@b", name: "Kim", active: true, roles: #MapSet<[]>}

```

주요 포인트:

- `%{struct | k: v}` 문법은 **구조체에서만 사용 가능**하다.
  - 일반 맵에 쓰면 컴파일 에러.
- 구조체 정의에 없는 키를 쓰면 **컴파일 시점에 에러**가 난다.

```elixir
# %{u | nickname: "kim"}
# key :nickname not found in: %User{...}

```

즉, 구조체 업데이트 문법 자체가 **오타 방지 장치** 역할을 한다.

---

### 맵 ↔ 구조체 변환 · 직렬화

구조체는 내부적으로 맵과 비슷하게 동작하므로,
맵과 구조체 간 변환이 자연스럽게 지원된다.

```elixir
Map.from_struct(u)
# %{active: true, email: "a@b", id: 1, name: nil, roles: #MapSet<[]>}

struct(User, %{id: 2, email: "x@y"})
# %User{id: 2, email: "x@y", name: nil, active: true, roles: #MapSet<[]>}

struct!(User, %{id: 3, email: "z@w"})
# 동일하지만, 없는 키가 들어오면 ArgumentError

```

- `Map.from_struct/1`
  - 구조체를 “필드만 있는 맵”으로 바꾼다.
- `struct/2`, `struct!/2`
  - 맵/키워드에서 구조체로 변환할 때 사용한다.
  - `struct!/2` 는 존재하지 않는 키가 들어오면 예외를 던져서
    “입력 데이터가 스키마와 안 맞는 상황”을 잡아준다.

#### JSON 직렬화와 @derive

웹 API에서는 구조체를 JSON으로 직렬화하는 일이 흔하다.
대표적인 JSON 라이브러리로는 `Jason` 등이 있고,
구조체에 `@derive`를 사용하면 기본 인코딩 정책을 쉽게 정할 수 있다.

```elixir
defmodule User do
  @derive {Jason.Encoder, only: [:id, :email, :name, :active]}
  @enforce_keys [:id, :email]
  defstruct [:id, :email, name: nil, active: true, roles: MapSet.new()]
end
```

- `roles` 같은 필드는 JSON으로 내보내지 않는다.
- 비밀번호, 토큰 등의 민감 정보도 `@derive`에서 제외하면 된다.

원한다면 JSON 인코딩을 직접 커스터마이즈할 수도 있다.
(예: 날짜 포맷 변환, 선택 필드만 노출 등)

```elixir
defimpl Jason.Encoder, for: User do
  def encode(%User{id: id, email: e, name: n, active: a}, opts) do
    Jason.Encode.map(%{
      "id" => id,
      "email" => e,
      "name" => n,
      "status" => if(a, do: "active", else: "inactive")
    }, opts)
  end
end
```

---

### 생성자/검증 — “불변식”을 구조체 안으로

도메인에는 항상 규칙(불변식)이 있다.

- id는 양의 정수여야 한다.
- email은 `@` 를 포함해야 한다.
- active가 false이면, 어떤 필드는 nil이어야 한다 … 등.

이런 규칙을 **이곳저곳에서 중복 검사**하는 대신,
**구조체 생성 시점**에 모아두는 편이 훨씬 안전하다.

```elixir
defmodule User do
  @enforce_keys [:id, :email]
  defstruct [:id, :email, name: nil, active: true]

  @type t :: %__MODULE__{
          id: pos_integer,
          email: String.t(),
          name: String.t() | nil,
          active: boolean
        }

  @spec new(keyword | map) :: {:ok, t} | {:error, term}
  def new(attrs) do
    with {:ok, id}    <- req_pos_int(attrs, :id),
         {:ok, email} <- req_email(attrs, :email),
         name         <- get_opt(attrs, :name, nil),
         active       <- get_opt(attrs, :active, true) do
      {:ok, %__MODULE__{id: id, email: email, name: name, active: active}}
    else
      {:error, reason} -> {:error, reason}
      other            -> {:error, other}
    end
  end

  defp req_pos_int(a, k) do
    v = fetch!(a, k)
    if is_integer(v) and v > 0, do: {:ok, v}, else: {:error, {:bad, k}}
  end

  defp req_email(a, k) do
    v = fetch!(a, k)
    if is_binary(v) and String.contains?(v, "@"), do: {:ok, v}, else: {:error, {:bad, k}}
  end

  defp get_opt(a, k, default) when is_list(a), do: Keyword.get(a, k, default)
  defp get_opt(a, k, default) when is_map(a),  do: Map.get(a, k, default)

  defp fetch!(a, k) when is_list(a) do
    case Keyword.fetch(a, k) do
      {:ok, v} -> v
      :error   -> raise ArgumentError, "missing key #{inspect k}"
    end
  end

  defp fetch!(a, k) when is_map(a) do
    case Map.fetch(a, k) do
      {:ok, v} -> v
      :error   -> raise ArgumentError, "missing key #{inspect k}"
    end
  end
end
```

사용 예:

```elixir
User.new(%{id: 1, email: "a@b"})
# {:ok, %User{id: 1, email: "a@b", name: nil, active: true}}

User.new(id: -1, email: "no-at")
# {:error, {:bad, :id}} 또는 {:error, {:bad, :email}} 등

```

이 패턴의 장점:

- 구조체를 **직접 리터럴로 만드는 대신**,
  항상 `User.new/1` 을 통해 만들도록 강제하면,
- 이후 코드에서는 “User는 최소한 id>0, email에 @ 포함”이라는 사실을 **믿고 사용할 수 있다**.
- 테스트 시에도 “비정상 User”가 돌아다니지 않게 막아준다.

---

### 중첩 구조체와 Access

구조체는 다른 구조체를 필드로 가질 수 있다.
이렇게 하면 도메인을 더 작은 조각으로 나눌 수 있고,
각 조각이 자기 불변식을 갖게 된다.

```elixir
defmodule Profile do
  defstruct [:city, :tags]
end

defmodule Account do
  defstruct [:user, :profile]
end

u = %User{id: 1, email: "a@b"}
p = %Profile{city: "Seoul", tags: []}
acc = %Account{user: u, profile: p}
```

이제 **중첩 필드 갱신**은 `put_in/update_in` 으로 한다.

```elixir
acc2 = put_in(acc, [:profile, :tags], ["elixir" | acc.profile.tags])
# %Account{
#   user: %User{...},
#   profile: %Profile{city: "Seoul", tags: ["elixir"]}
# }

```

혹은:

```elixir
acc3 = update_in(acc, [:profile, :city], &String.upcase/1)
```

`get_in/2` 도 그대로 쓸 수 있다.

```elixir
city = get_in(acc, [:profile, :city])  # "Seoul"
```

핵심:

- 구조체도 결국 맵이므로, `Access` 기반 도구가 **그대로 통한다**.
- 중첩 구조체를 쪼개두면, 불변식을 각 모듈에 나눠 담을 수 있고,
  하나의 거대한 맵보다 구조가 훨씬 이해하기 쉬워진다.

---

### 프로토콜과 구조체

엘릭서의 **프로토콜(protocol)** 은 “타입에 따라 다른 구현”을 제공하는 메커니즘이다.
구조체는 여기에 딱 맞는다.

예: `String.Chars` 프로토콜을 구현해서
`to_string/1` 이 User 구조체를 예쁘게 표현하도록 만들 수 있다.

```elixir
defimpl String.Chars, for: User do
  def to_string(%User{id: id, email: e}) do
    "User(#{id}, #{e})"
  end
end

to_string(%User{id: 1, email: "a@b"})
# "User(1, a@b)"

```

`Inspect` 프로토콜을 구현하면 `IO.inspect/2` 의 출력 형식을 제어할 수도 있다.

```elixir
defimpl Inspect, for: User do
  import Inspect.Algebra

  def inspect(%User{id: id, email: e, active: a}, opts) do
    concat([
      "#User<",
      to_doc(id, opts),
      " ",
      e,
      if(a, do: " active", else: " inactive"),
      ">"
    ])
  end
end

IO.inspect(%User{id: 1, email: "a@b", active: true})
# #User<1 a@b active>

```

프로토콜과 구조체를 함께 쓰면:

- 표준 라이브러리 함수(예: `to_string/1`, `Enum.into/2`)와 자연스럽게 연결된다.
- 도메인 객체를 다양한 콘텍스트(로그, JSON, UI 등)에 맞게 표현할 수 있다.

---

### 실전 미니 프로젝트: User + Session + Role 구조체

간단한 예제를 통해, 여러 구조체가 함께 동작하는 모습을 보자.

```elixir
defmodule Role do
  @enforce_keys [:name]
  defstruct [:name, permissions: MapSet.new()]

  @type t :: %__MODULE__{
          name: atom,
          permissions: MapSet.t(atom)
        }
end

defmodule User do
  @enforce_keys [:id, :email]
  defstruct [:id, :email, name: nil, active: true, roles: MapSet.new()]

  @type t :: %__MODULE__{
          id: pos_integer,
          email: String.t(),
          name: String.t() | nil,
          active: boolean,
          roles: MapSet.t(atom)
        }

  def add_role(%__MODULE__{roles: rs} = u, role) when is_atom(role) do
    %{u | roles: MapSet.put(rs, role)}
  end

  def has_role?(%__MODULE__{roles: rs}, role) do
    MapSet.member?(rs, role)
  end
end

defmodule Session do
  @enforce_keys [:user, :token]
  defstruct [:user, :token, :issued_at, data: %{}]

  @type t :: %__MODULE__{
          user: User.t(),
          token: String.t(),
          issued_at: :calendar.datetime() | nil,
          data: map
        }
end
```

사용:

```elixir
u =
  %User{id: 1, email: "a@b"}
  |> User.add_role(:admin)
  |> User.add_role(:editor)

User.has_role?(u, :admin)   # true

s = %Session{user: u, token: "abc123", issued_at: :calendar.universal_time()}

s2 = put_in(s, [:data, :last_page], "/home")
```

- User: 도메인 엔터티
- Role: 역할 정의
- Session: 인증·상태 관리

각 구조체가 역할을 분담하면서, 전체 시스템이 더 읽기 쉬운 모양이 된다.

---

## 중첩된 딕셔너리 구조 — 안전 탐색과 갱신

현실 데이터, 특히 JSON 기반 API 응답은 대부분 **중첩 맵** 형태다.

```elixir
user = %{
  "id" => 1,
  "profile" => %{
    "email" => "a@b",
    "addr" => %{"city" => "Seoul", "zip" => "00000"}
  }
}
```

과제는 세 가지다.

1. 중첩 경로를 **안전하게 탐색**하고 (없을 수 있음)
2. 중첩된 값을 **안전하게 갱신**하며
3. “부분 데이터”에 대한 정책(없으면 기본값, 없으면 예외 등)을 정하는 것.

---

### 안전 탐색: `get_in/2` + Access

`get_in/2` 는 “경로(path)”를 따라가며 값을 찾는다.

```elixir
get_in(user, ["profile", "addr", "city"])
# "Seoul"

get_in(user, ["profile", "phone"])
# nil

```

- 키가 중간에 없으면 **nil** 반환.
- 이 행동이 충분한 경우도 있지만,
  - “없는 것”과 “실제로 값이 nil인 것” 구분이 필요하다면 부족하다.

간단한 `fetch_in/2` 스타일 함수를 직접 만들 수 있다.

```elixir
defmodule SafeGet do
  def fetch_in(data, []), do: {:ok, data}

  def fetch_in(data, [k | ks]) when is_map(data) do
    case Map.fetch(data, k) do
      {:ok, v} -> fetch_in(v, ks)
      :error   -> :error
    end
  end

  def fetch_in(_data, _), do: :error
end

SafeGet.fetch_in(user, ["profile", "addr", "city"])
# {:ok, "Seoul"}

SafeGet.fetch_in(user, ["profile", "phone"])
# :error

```

이제:

- 경로가 모두 존재하면 `{:ok, 값}`
- 어느 단계에서든 키가 없으면 `:error`

처럼, “없음/있음”을 명확히 구분할 수 있다.

---

### 안전 갱신: `update_in/3`, `get_and_update_in/3`

중첩 구조 갱신은 `update_in/3` 을 쓰면 간단하다.

```elixir
u1 = update_in(user, ["profile", "addr", "city"], &String.upcase/1)
# %{..., "profile" => %{"addr" => %{"city" => "SEOUL", ...}, ...}}

```

문제는, 경로 중간에 키가 없다면 **`KeyError`** 가 난다는 점이다.

```elixir
u2 = update_in(user, ["profile", "phone", "country"], &String.upcase/1)
# ** (KeyError)

```

이럴 때는 `get_and_update_in/3` 를 이용해 “없으면 생성” 등 정책을 함께 정의할 수 있다.

```elixir
{old, new_user} =
  get_and_update_in(user, ["profile", "addr", "country"], fn
    nil -> {nil, "UNKNOWN"}
    v   -> {v, String.upcase(v)}
  end)

old       # nil (이전 값)
new_user  # country: "UNKNOWN" 추가된 새 맵
```

- `get_and_update_in/3` 는 `(old_value, new_structure)` 를 반환한다.
- 익명 함수 안에서 “없으면 기본값으로 세팅”, “있으면 어떻게 변환” 같은 정책을 마음대로 정의한다.

---

### 리스트 내부 요소 선택: `Access.at/1`, `Access.filter/1`

중첩 구조에 리스트가 섞이면 상황이 복잡해진다.
하지만 `Access` 모듈이 제공하는 도구를 쓰면 꽤 깔끔하게 처리할 수 있다.

```elixir
posts = %{
  "items" => [
    %{"id" => 1, "title" => "A"},
    %{"id" => 2, "title" => "B"}
  ]
}
```

`id == 2` 인 포스트의 제목만 수정하고 싶다면:

```elixir
posts2 =
  update_in(
    posts,
    ["items", Access.filter(&(&1["id"] == 2)), "title"],
    &("New " <> &1)
  )

# "id" == 2인 요소의 title만 "New B"로 바뀐다.

```

또는 인덱스로 접근:

```elixir
posts3 =
  update_in(posts, ["items", Access.at(0), "title"], &String.downcase/1)
```

- `Access.at/1` : 리스트 인덱스 기반 접근
- `Access.filter/1` : 조건을 만족하는 모든 요소를 대상으로 갱신

중첩 구조 + 리스트가 섞여 있어도 경로를 “문장처럼” 쓸 수 있게 해준다.

---

### 경계에서의 키 전략 — 문자열 ↔ 아톰 변환

외부(JSON)는 보통 **문자열 키**고,
내부 도메인은 대개 **아톰 키**를 쓴다.

경계에서 변환이 필요할 때,

- 절대 임의 문자열을 그대로 `String.to_atom/1` 하지 말고
- 화이트리스트 기반으로만 변환해야 한다.

```elixir
defmodule KeyConv do
  @allowed ~w(id email name active)a

  def to_safe_atoms(map) when is_map(map) do
    for {k, v} <- map, into: %{} do
      key =
        case k do
          k when is_atom(k) ->
            k

          k when is_binary(k) and String.to_atom(k) in @allowed ->
            String.to_atom(k)

          _ ->
            k
        end

      {key, v}
    end
  end
end
```

좀 더 안전하게 만들려면 `String.to_existing_atom/1` 를 쓸 수도 있지만,
그 전에 반드시 어느 값만 허용할지 **화이트리스트**를 정해야 한다.

핵심 원칙:

- 외부 입력은 **가능한 한 문자열로 유지**.
- 도메인 내부에서만 아톰을 사용.
- 변환은 **경계 레이어** 하나에 모아두고, 아무 곳에서나 하지 않는다.

---

### 중첩 머지: `deep_merge/2` 패턴

“기본 설정 + 사용자 설정” 같은 경우,
중첩 맵을 **깊이 합치기**(deep merge) 패턴이 필요하다.

```elixir
defmodule Deep do
  def merge(a, b) when is_map(a) and is_map(b) do
    Map.merge(a, b, fn _k, v1, v2 -> merge(v1, v2) end)
  end

  def merge(_a, b), do: b
end
```

예:

```elixir
default = %{
  http: %{timeout: 1000, pool_size: 10},
  log: %{level: :info}
}

user = %{
  http: %{timeout: 2000},
  log: %{format: :json}
}

Deep.merge(default, user)
# %{
#   http: %{timeout: 2000, pool_size: 10},
#   log: %{level: :info, format: :json}
# }

```

구조:

- 둘 다 맵이면, 각 키에 대해 재귀적으로 `merge/2`
- 아니면 오른쪽(`b`)이 우선

충돌 정책을 더 세밀하게 제어하고 싶다면,
3-아리티 `Map.merge/3` 처럼 정책 함수를 추가로 받도록 설계해도 된다.

---

### 비용 모델 — 중첩 갱신의 누적 비용

중첩 맵에서 깊이 \(d\) 의 경로를 갱신한다고 하면,
불변 구조 특성상 각 레벨에서 **새 맵**이 한 번씩 만들어진다.

즉, 대략적인 비용은:

$$
T_{\text{update}} \approx O(d)
$$

- 각 레벨에서 새 맵을 만들지만,
  그 맵의 나머지 키·값은 기존 구조를 **공유**한다.
- 따라서 중첩 깊이가 그리 크지 않다면, 비용은 충분히 감당할 만하다.

하지만,

- 경로가 매우 깊고
- 갱신이 매우 빈번한 경우라면

중첩 구조를 조금 **평탄화(denormalization)** 하거나,
중간 레벨에 캐시용 레지스트리를 두는 등의 최적화가 필요할 수 있다.

---

## — 고유성·합/교/차 연산

`MapSet` 은 “원소의 고유성 + 집합 연산”을 제공하는 자료형이다.

- 내부적으로 **맵 기반**이어서,
  - 원소 삽입/삭제/검사 평균 시간은 \(O(1)\) 수준.
- 합집합/교집합/차집합은 원소 수 \(n\) 에 비례하는 비용을 가진다.

---

### 기본 연산

```elixir
s = MapSet.new([:a, :b, :a])
# #MapSet<[:a, :b]>

s = MapSet.put(s, :c)
MapSet.member?(s, :b)      # true
MapSet.size(s)             # 3

u = MapSet.new([:c, :d])

MapSet.union(s, u)
# #MapSet<[:a, :b, :c, :d]>

MapSet.intersection(s, u)
# #MapSet<[:c]>

MapSet.difference(s, u)
# #MapSet<[:a, :b]>

```

유형:

- 태그, 권한, 기능 플래그, 팔로우 관계(간단한 경우) 등
  “고유한 원소들의 모음”이 필요한 곳에 쓰면 좋다.

---

### 권한/태그/가시성 규칙 — 실전 예시

“어떤 콘텐츠가 사용자의 태그/권한에 따라 보이는가?”를 판정하는 규칙을 생각해보자.

```elixir
defmodule Visibility do
  def visible?(user_tags, rule) do
    u    = MapSet.new(user_tags)
    any  = Map.get(rule, :any, [])  |> MapSet.new()
    all  = Map.get(rule, :all, [])  |> MapSet.new()
    none = Map.get(rule, :none, []) |> MapSet.new()

    cond do
      # none에 속한 태그를 가진 사용자는 항상 차단
      not MapSet.disjoint?(u, none) ->
        false

      # all에 정의된 태그를 모두 갖추지 못하면 차단
      not MapSet.subset?(all, u) ->
        false

      # any 조건이 정의되어 있는데, 교집합이 없으면 차단
      MapSet.size(any) > 0 and MapSet.disjoint?(u, any) ->
        false

      # 그 외는 허용
      true ->
        true
    end
  end
end

Visibility.visible?(~w(pro paid)a, any: ~w(promo)a, all: ~w(pro)a, none: ~w(banned)a)
# true (none 불만족, all 만족, any는 상관없음)

```

이 로직은:

- `none` : 차단 태그 집합
- `all`  : 반드시 모두 갖춰야 하는 태그 집합
- `any`  : 하나라도 있으면 좋은 태그 집합

으로 해석할 수 있고,
MapSet 연산으로 깔끔하게 표현된다.

---

### 추천/매칭 예시: 태그 기반 매칭 점수

사용자가 가진 태그와, 아이템이 가진 태그를 비교해
“매칭 점수”를 계산하는 toy 예제를 보자.

```elixir
defmodule Match do
  def score(user_tags, item_tags) do
    u = MapSet.new(user_tags)
    i = MapSet.new(item_tags)

    inter = MapSet.intersection(u, i)
    union = MapSet.union(u, i)

    # Jaccard 유사도 흉내: 교집합/합집합
    if MapSet.size(union) == 0 do
      0.0
    else
      MapSet.size(inter) / MapSet.size(union)
    end
  end
end

Match.score(~w(elixir fp backend)a, ~w(elixir phoenix)a)
# 교집합: [:elixir], 합집합: [:elixir, :fp, :backend, :phoenix]
# 점수: 1/4

```

물론 실제 시스템에서는
- 태그 중요도 가중치,
- 최신성 반영,
- 부정 태그 등
복잡한 요소가 들어가지만,
**집합 연산**이 기본 뼈대가 된다는 점은 동일하다.

---

### 성능/메모리 메모

원소 수를 \(n\) 이라고 할 때:

- `MapSet.member?/2`, `MapSet.put/2` 등 원소 단위는 평균 \(O(1)\)
- `MapSet.union/intersection/difference` 는 \(O(n)\)

불변 자료구조 특성상:

- 집합 갱신 시 전체를 새로 복사하는 것이 아니라,
  구조 공유를 통해 필요 부분만 새로 만든다.
- 대량 갱신이 잦다면, **왜 MapSet을 쓰는지**(중복 제거의 가치)를 항상 의식해야 한다.

---

## 큰 힘은 큰 유혹을 낳는다 — 강력 기능의 함정과 기준선

엘릭서는 다음과 같은 매우 강력한 도구를 제공한다.

- 매크로(`defmacro`)
- 동적 아톰 생성
- 전역 프로세스/등록 이름
- ETS(에르랑 Term Storage)
- 예외 기반 흐름 제어

이 도구들은 성능·표현력 측면에서 강력하지만,
잘못 쓰면 **디버깅이 어려워지고, 시스템이脆弱해지고, 메모리 누수**가 날 수 있다.

여기서는 “언제 쓰지 말아야 하는지”를 기준 삼아 정리해보자.

---

### 동적 아톰 생성 — 편하지만 위험한 메모리 누수

아톰은 **GC되지 않는다**.
즉, 한 번 만들어진 아톰은 VM이 내려갈 때까지 메모리에 남는다.

```elixir
String.to_atom(user_input)  # 위험
```

- 외부 입력에 따라 매번 새로운 아톰이 생성되면,
  아톰 테이블이 점점 커져 결국 VM이 죽을 수 있다.

**교정/원칙:**

1. 외부 문자열은 웬만하면 **문자열로 유지**하라.
2. 도메인 내부에서만 제한된 범위의 아톰을 사용하라.
3. 부득이할 경우:
   - `String.to_existing_atom/1` 사용 (이미 존재하는 아톰만 허용)
   - 또는 화이트리스트 기반 매핑:

```elixir
def safe_atom("id"),    do: :id
def safe_atom("email"), do: :email
def safe_atom(other),   do: other
```

---

### 매크로 남용 — 디버깅/가독성 악화

매크로는 컴파일 타임에 코드를 생성하는 도구다.

- 장점: 보일러플레이트 제거, DSL 구현
- 단점:
  - 디버깅이 어렵다 (`quote/2`, generated code 확인 필요)
  - 팀원이 이해하기 어려운 “마법 같은 코드”가 늘어난다.

**질문:**
“이 작업을 단순 함수/모듈 추출로 해결할 수 있는가?”

- Yes → **함수로** 해결한다.
- No  → 그때 매크로를 검토한다.

매크로의 적절한 사용 예:

- 반복되는 패턴의 **간결화** (예: 라우팅 DSL, 스키마 선언 DSL)
- “컴파일 타임 정보”를 이용한 최적화 (예: 경로 미리 계산 등)

하지만:

- 단순한 로직까지 매크로로 숨기면
  나중에 본인이 봐도 “여기서 무슨 일이 일어나지?”가 된다.

---

### 전역 프로세스/등록 이름 남발

엘릭서/에르랑에서는 프로세스에 이름을 붙일 수 있다.

```elixir
GenServer.start_link(MyServer, init_arg, name: :my_server)
```

편리하지만:

- 테스트에서 병렬 실행/격리가 어려워진다.
- 여러 인스턴스를 띄우기 어렵다.
- “전역 상태”에 의존하는 코드가 많아지면 리팩토링이 어렵다.

**가이드:**

- 최상위 Supervisor 정도만 이름을 주고,
  하위 프로세스는 가능하면 **익명/동적 이름**을 쓴다.
- 명시적으로 “이름을 주어야 하는 이유”(예: 하나만 존재해야 하는 리소스)를 문서화하라.

---

### ETS 남용 — 일관성/경계 관리 실패

ETS는 에르랑 VM 내부의 **고성능 in-memory 테이블**이다.

- 매우 빠르고, 큰 데이터도 잘 다룬다.
- 하지만:
  - 가변 데이터 구조다.
  - 트랜잭션이 없다.
  - 누가 언제 무엇을 수정했는지 추적하기 어렵다.

**추천 패턴:**

- ETS를 **읽기 캐시**나 **대규모 읽기 중심 데이터**에 사용.
- 쓰기는 **소유 프로세스**를 통해서만 수행.
  (예: GenServer 한 개만 ETS를 업데이트)

> “ETS로 해결하자”라는 생각이 들 때마다,
> “정말 필요한지, 맵/구조체/프로세스로 안 되는지”를 먼저 따져야 한다.

---

### 예외 흐름 남용 — 파이프라인 붕괴

엘릭서에서 권장되는 실패 표현은 **태그드 튜플**이다.

```elixir
{:ok, value} | {:error, reason}
```

`with`나 파이프라인에서 이 형태를 유지하면
에러 처리를 구조적으로 관리하기 쉽다.

반대로, 예외를 남발하면:

- 파이프라인이 끊기고,
- 어떤 함수가 어떤 예외를 던지는지 추적하기 어렵다.

**가이드:**

- “예상 가능한 실패”는 `{:error, reason}` 로 표현.
- “정말 예외적인 상황”(프로그래밍 버그, 불변식 위반 등)에만 예외를 사용.

---

### 정리 — “기본으로 충분한가?”를 먼저 묻기

이 장에서 다룬 “기본”은 다음과 같다.

- 구조체(Struct)
- 맵(Map) / 키워드 리스트
- MapSet
- Access + `get_in/put_in/update_in/get_and_update_in`
- Enum/Stream
- 태그드 튜플 기반 오류 처리

이 도구들만으로도 **대부분의 애플리케이션**이 충분히 설계 가능하다.

질문:

1. **구조체 + 맵 + MapSet으로 표현 가능한가?**
2. **Access + Enum/Stream으로 중첩/집계 로직을 표현할 수 있는가?**
3. **태그드 튜플 오류 처리로 충분한가?**

이 세 가지에 **Yes**라면:

- 매크로, ETS, 동적 아톰 생성 등 강력한 도구는 굳이 쓸 이유가 없다.

---

## + 규칙 엔진(MapSet) + 안전 갱신

지금까지의 내용을 한 번에 묶어 보자.

요구사항:

1. 외부에서 **키워드** 또는 **맵**으로 설정 입력을 받는다.
2. 내부에서 **검증 및 정규화** 후 **구조체**에 저장한다.
3. 설정에 붙은 **태그 규칙**으로 기능 활성 여부를 판정한다.
4. 중첩 구조(예: 로그 설정)를 **안전 갱신**으로 관리한다.

### 설정 구조체 정의

```elixir
defmodule App.Config do
  defmodule T do
    @enforce_keys [:endpoint]
    defstruct [:endpoint, timeout: 1000, headers: %{}, tags: MapSet.new(), log: %{level: :info}]

    @type t :: %__MODULE__{
            endpoint: String.t(),
            timeout: pos_integer,
            headers: map,
            tags: MapSet.t(String.t()),
            log: %{level: atom}
          }
  end
end
```

### 로더 구현 (Keyword | Map → Struct)

```elixir
defmodule App.Config do
  defmodule T do
    @enforce_keys [:endpoint]
    defstruct [:endpoint, timeout: 1000, headers: %{}, tags: MapSet.new(), log: %{level: :info}]
  end

  @spec load(keyword | map) :: {:ok, T.t()} | {:error, term}
  def load(opts) do
    with endpoint when is_binary(endpoint) <- fetch(opts, :endpoint),
         timeout  <- get_opt(opts, :timeout, 1000),
         true     <- is_integer(timeout) and timeout > 0 or {:error, :bad_timeout},
         headers0 <- get_opt(opts, :headers, %{}),
         headers  <- norm_headers(headers0),
         tags0    <- get_opt(opts, :tags, []),
         tags     <- MapSet.new(tags0),
         log0     <- get_opt(opts, :log, %{}),
         log      <- Deep.merge(%{level: :info}, log0) do
      {:ok, %T{endpoint: endpoint, timeout: timeout, headers: headers, tags: tags, log: log}}
    else
      {:error, _} = e -> e
      _               -> {:error, :bad_options}
    end
  end

  defp fetch(m, k) when is_list(m), do: Keyword.fetch!(m, k)
  defp fetch(m, k) when is_map(m),  do: Map.fetch!(m, k)

  defp get_opt(m, k, d) when is_list(m), do: Keyword.get(m, k, d)
  defp get_opt(m, k, d) when is_map(m),  do: Map.get(m, k, d)

  defp norm_headers(h) when is_map(h), do: h
  defp norm_headers(h) when is_list(h), do: Map.new(h)
end

defmodule Deep do
  def merge(a, b) when is_map(a) and is_map(b) do
    Map.merge(a, b, fn _k, v1, v2 -> merge(v1, v2) end)
  end
  def merge(_a, b), do: b
end
```

사용 예:

```elixir
opts = [
  endpoint: "https://api.example.com",
  timeout: 2000,
  headers: [accept: "application/json"],
  tags: ~w(api v1),
  log: %{level: :debug}
]

{:ok, cfg} = App.Config.load(opts)
```

- `log` 필드: 기본값 `%{level: :info}`를 `Deep.merge/2`로 사용자 설정과 합침.
- 입력은 키워드/맵 둘 다 받아들이지만, 내부에서는 **구조체**로 표준화.

---

### 태그 규칙 엔진 (MapSet 활용)

```elixir
defmodule App.Rule do
  def visible?(%App.Config.T{tags: tags}, rule) do
    u    = tags
    any  = Map.get(rule, :any, [])  |> MapSet.new()
    all  = Map.get(rule, :all, [])  |> MapSet.new()
    none = Map.get(rule, :none, []) |> MapSet.new()

    cond do
      not MapSet.disjoint?(u, none) ->
        false

      not MapSet.subset?(all, u) ->
        false

      MapSet.size(any) > 0 and MapSet.disjoint?(u, any) ->
        false

      true ->
        true
    end
  end
end

App.Rule.visible?(cfg, any: ~w(v2)a, all: ~w(api)a, none: ~w(banned)a)
# false (any 조건 불만족)

```

---

### 중첩 갱신: 로그 레벨 동적 변경

운영 중 로그 레벨을 동적으로 바꾸고 싶을 때:

```elixir
cfg2 = put_in(cfg, [:log, :level], :warn)
```

조건부 갱신:

```elixir
{old_level, cfg3} =
  get_and_update_in(cfg, [:log, :level], fn
    :debug -> {:debug, :info}
    lvl    -> {lvl, lvl}
  end)
```

---

### 비용 메모 (요약)

이 설정 시스템 전체의 비용은 대략 이렇게 정리할 수 있다.

- 구조체 생성: 필드 수에 비례하는 \(O(1)\) 수준
- 중첩 맵 머지: 각 맵 크기에 비례하는 \(O(n)\)
- MapSet 연산:
  - member/put: 평균 \(O(1)\)
  - union/intersection/difference: \(O(n)\)

대부분의 애플리케이션에서 \(n\) 은
“설정 항목 수, 태그 수” 정도의 작은 값이다.
따라서 이런 구조를 **안심하고** 사용해도 된다.

---

## 디버깅·탐색 팁 요약

- `i term` (IEx): 자료형/프로토콜/구조체 정보 확인
- `h Map.update/4`, `h put_in/3`, `h MapSet.union/2`: 문서 확인
- `IO.inspect(term, label: "x", pretty: true, limit: :infinity)`: 중첩 구조 확인
- `tap/2`, `then/2` 를 이용한 파이프라인 중간 관찰

```elixir
config
|> tap(&IO.inspect(&1, label: "raw config"))
|> then(&Map.put(&1, :debug, true))
|> tap(&IO.inspect(&1, label: "with debug"))
```

---

## 연습 문제

1) **구조체 검증 확장**
   - `%User{}`에 `roles: MapSet` 필드를 두고,
     `add_role/2`, `remove_role/2`, `has_role?/2`를 구현하라.
   - `new/1`에서 `roles`를 리스트로 받아 MapSet으로 변환하되,
     허용되지 않은 역할이 들어오면 `{:error, {:unknown_role, role}}`을 반환하라.

2) **안전 경로 갱신**
   - `bump(map, path)` 함수를 구현하라.
     - `path` : 키 리스트
     - `path`가 가리키는 위치의 숫자 필드를 1 증가
     - 값이 없으면 1로 세팅
     - `get_and_update_in/3` 사용

3) **가시성 규칙 확장**
   - `visible?(config, rule)`에 `except: [...]` 옵션을 추가하라.
     - `except`에 포함된 태그를 가진 사용자는 **항상 false**를 반환.
     - `none`보다 우선한다.

4) **deep_merge/3**
   - `deep_merge(a, b, policy)`를 구현하라.
     - `policy`는 충돌 시 어떻게 할지 정하는 함수:
       `fn key, left, right -> ... end`
     - 맵이면 재귀, 리스트면 이어붙이기, 그 외는 `policy`에 따르게 하라.

5) **JSON 스키마 → 구조체 매핑**
   - 문자열 키 JSON을 `%User{}`로 변환하는 `from_json/1`을 구현하라.
   - 키는 `"id"`, `"email"`, `"name"`, `"active"`만 허용.
   - 허용되지 않은 키가 있으면 `{:error, {:unknown_field, key}}`.

---

## 마무리

- **구조체(Struct)** 는 “필드가 정해진 맵”이다.
  - 도메인 불변식을 생성 시점에 모아서,
    이후 코드를 **안심하고 작성**하게 해준다.

- **중첩 딕셔너리(JSON 스타일)** 는 `get_in/put_in/update_in/get_and_update_in`과
  `Access.at/1`, `Access.filter/1` 을 조합해서
  **선언적으로 탐색·갱신**하는 습관을 들이는 게 좋다.

- **MapSet** 은 태그/권한/가시성/추천 등
  “고유한 원소의 집합”이 필요한 곳에서
  생각보다 훨씬 넓게 쓰일 수 있다.

- 마지막으로, 매크로, 동적 아톰, ETS, 전역 프로세스 같은 **강력 기능**은
  “기본 도구로는 해결이 불가능한가?”를 충분히 따져본 뒤에만
  **좁은 범위**에서 사용하는 것이 좋다.

이 장의 목표는 “**구조체 + 맵 + MapSet + Access + Enum/Stream**” 이라는
기본 도구들만으로도, 상당히 복잡한 도메인과 데이터 구조를
**안전하고 읽기 좋은 형태**로 모델링할 수 있다는 것을 보여주는 것이다.
이 감각이 잡히면, 이후 OTP, Ecto, Phoenix 같은 상위 레이어도
“본질적으로 이 패턴들의 조합”으로 보이게 될 것이다.
