---
layout: post
title: DB 심화 - 바인드 변수 부작용과 해법
date: 2025-10-28 20:25:23 +0900
category: DB 심화
---
# 바인드 변수의 **부작용과 해법**

> **핵심 요약**
> - 바인드 변수는 좋다. 하지만 **값 스큐(skew)** 가 크면 **첫 실행 값(피킹)** 으로 고정된 플랜이 **다른 값**에선 느려질 수 있다.
> - 11g+의 **Adaptive Cursor Sharing(ACS)** 이 이를 보완하지만, **과도한 Child 분기**나 **불안정**이 생길 수 있다.
> - 해결은 **히스토그램+통계 피드백**으로 *카디널리티 정확화* → 그래도 값별 최적 플랜이 극단적으로 다르면 **입력 값대별로 SQL을 분리**한다.
> - 극히 예외적으로 **리터럴 상수**를 사용해 “특정 값만 다른 플랜”을 고정해 문제를 차단할 수 있다(운영 규율 필요).

---

## 실습 데이터 준비 (스큐 유발)

```sql
-- 스키마 준비
DROP TABLE t_sales PURGE;

CREATE TABLE t_sales (
  id        NUMBER PRIMARY KEY,
  region    VARCHAR2(10),
  order_dt  DATE,
  amount    NUMBER
);

-- 값 스큐: 'APAC' 70%, 'EMEA' 20%, 'AMER' 10%
INSERT /*+ APPEND */ INTO t_sales
SELECT level,
       CASE
         WHEN MOD(level,10) < 7 THEN 'APAC'
         WHEN MOD(level,10) < 9 THEN 'EMEA'
         ELSE 'AMER'
       END,
       DATE '2025-10-01' + MOD(level, 31),
       ROUND(DBMS_RANDOM.VALUE(10,1000),2)
FROM dual CONNECT BY level <= 600000;

COMMIT;

CREATE INDEX ix_sales_region_dt ON t_sales(region, order_dt);

-- 통계 + 히스토그램(스큐 컬럼에 SIZE 지정)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'T_SALES', cascade => TRUE,
    method_opt => 'FOR COLUMNS SIZE 75 region SIZE 1 order_dt');
END;
/
```

> 포인트
> - `region`에 **히스토그램**(SIZE 75)으로 스큐 인지.
> - `order_dt`는 균등한 편이라 SIZE 1(히스토그램 없음)로 두었다.

---

## 바인드 **Peeking(피킹)** 의 부작용

### 무엇인가?

- **첫 실행** 때 입력 바인드 값을 **엿보고(peek)** 그 값의 **선택도**로 카디널리티를 추정해 **플랜을 결정**한다.
- 그후 **같은 Parent 커서**를 재사용하면 *초기에 선택된 플랜*이 **다른 값**에도 적용된다.
- 스큐가 크면 **한 플랜으로 모든 값**을 잘 처리하기 어렵다.

### 재현: 같은 SQL, 값만 바꿈

```sql
VAR r VARCHAR2(10);
VAR d1 DATE; VAR d2 DATE;

EXEC :d1 := DATE '2025-10-01'; EXEC :d2 := DATE '2025-10-31';
EXEC :r := 'APAC';

-- 첫 실행(고빈도 값)
SELECT /* peek-demo */ SUM(amount)
FROM   t_sales
WHERE  region=:r
AND    order_dt BETWEEN :d1 AND :d2;

-- 다른 값(저빈도)으로 즉시 재실행
EXEC :r := 'AMER';
SELECT /* peek-demo */ SUM(amount)
FROM   t_sales
WHERE  region=:r
AND    order_dt BETWEEN :d1 AND :d2;
```

### 관찰: 플랜/라인 통계

```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  sql_id => NULL, child_number => NULL,
  format => 'ALLSTATS LAST +PEEKED_BINDS +PREDICATE +NOTE +OUTLINE'));
```

**전형적 현상**
- 첫 실행이 **APAC(행 많음)** 이면 옵티마이저는 `HASH GROUP BY`나 `FULL/FFS` 기반이 될 확률↑.
- 같은 커서를 재사용한 **AMER(행 적음)** 에도 같은 대량용 플랜이 적용되어 **과한 비용**이 든다.

> **첫 처방**: 스큐 컬럼에는 **히스토그램**을 적용(이미 적용함). 그래도 **첫 실행 값**에 따라 플랜이 “한쪽으로” 치우칠 수 있다 → 다음 절의 **ACS**.

---

## **Adaptive Cursor Sharing(ACS)** — 바인드 스큐 보정

### 개념

- 실행 중 수집한 **실측 카드(A-Rows)** 와 바인드 패턴을 학습해, **값 범위별 Child 커서**를 만든다.
- 예: `region='APAC'` → **Child#0**(대량 플랜), `region='AMER'` → **Child#1**(소량 플랜).

### 확인 쿼리

```sql
-- 같은 SQL을 값만 바꿔 몇 번 더 실행해 학습 기회를 준다
EXEC :r := 'APAC';
SELECT /* acs-demo */ SUM(amount) FROM t_sales
WHERE region=:r AND order_dt BETWEEN :d1 AND :d2;

EXEC :r := 'EMEA';
SELECT /* acs-demo */ SUM(amount) FROM t_sales
WHERE region=:r AND order_dt BETWEEN :d1 AND :d2;

EXEC :r := 'AMER';
SELECT /* acs-demo */ SUM(amount) FROM t_sales
WHERE region=:r AND order_dt BETWEEN :d1 AND :d2;

-- Child/ACS 상태 보기
SELECT sql_id, child_number,
       is_bind_sensitive, is_bind_aware,
       executions, plan_hash_value
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* acs-demo */ SUM(amount)%'
ORDER  BY child_number;

-- Child 분기 이유(공유 실패 사유가 아니라 '의도된 분기'가 보인다)
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_text LIKE 'SELECT /* acs-demo */ SUM(amount)%'
  AND  reason IS NOT NULL AND reason <> 'N'
ORDER BY child_number;
```

> **정상적이면** `IS_BIND_SENSITIVE='Y'`, `IS_BIND_AWARE='Y'` 인 Child가 **두셋** 생기고, 각 값 구간에 맞는 플랜이 선택된다.

### ACS의 **부작용**

- **Child 과다 생성**: 값 분포가 변화무쌍하거나 조건이 많으면 Child가 너무 늘 수 있다.
- **학습 지연/불안정**: 워크로드가 불규칙하거나 통계가 부정확하면 학습이 요지부동.
- **환경 불일치**와 섞이면(세션 NLS/파라미터 혼재) 원인 파악 난해.

> **운영 팁**: 히스토그램으로 **카디널리티 정확화** → ACS가 “필요한 만큼만” 분기하도록 만든다.
> 과다 분기 시 히스토그램 **SIZE 조절**·쿼리 구조 정리·**SPM(Plan Baseline)** 병행.

---

## **입력 값에 따라 SQL을 분리** — 의도를 명시하는 설계

> ACS로도 커버가 어려울 만큼 **큰 스큐** 혹은 **플랜 선택이 완전히 달라져야** 하는 경우,
> **값대별로 SQL을 분리**하여 **명시적**으로 최적 플랜을 사용하게 한다.

### 분리 원칙

- **텍스트가 달라지면 Parent가 달라진다** → 서로 독립적인 플랜을 고정 가능.
- 분리 기준은 **업무 도메인**으로 합리화(예: `VIP 지역 vs 일반 지역`, `최근 7일 vs 과거`).

### 예제 — 지역별로 다른 조인전략/힌트

```sql
-- (A) APAC: 대량 → HASH 기반
SELECT /* apac-heavy */
       /*+ LEADING(s) USE_HASH(s) FULL(s) */
       SUM(amount)
FROM   t_sales s
WHERE  s.region = :r
AND    s.order_dt BETWEEN :d1 AND :d2
  AND  :r = 'APAC';

-- (B) 그 외: 소량 → NL + 인덱스
SELECT /* non-apac-light */
       /*+ INDEX(s ix_sales_region_dt) USE_NL(s) */
       SUM(amount)
FROM   t_sales s
WHERE  s.region = :r
AND    s.order_dt BETWEEN :d1 AND :d2
  AND  :r <> 'APAC';
```

> **동일 바인드**를 쓰지만 **서로 다른 SQL 텍스트**(주석/힌트 포함)로 분리 → Parent가 2개.
> 프레임워크에선 **조건 분기**로 두 개의 PreparedStatement를 선택하는 식으로 구현.

### 코드 레벨(예: Java/JDBC)

```java
String sqlApac =
 "SELECT /* apac-heavy */ /*+ LEADING(s) USE_HASH(s) FULL(s) */ " +
 "SUM(amount) FROM t_sales s " +
 "WHERE s.region = :r AND s.order_dt BETWEEN :d1 AND :d2 AND :r = 'APAC'";

String sqlOther =
 "SELECT /* non-apac-light */ /*+ INDEX(s ix_sales_region_dt) USE_NL(s) */ " +
 "SUM(amount) FROM t_sales s " +
 "WHERE s.region = :r AND s.order_dt BETWEEN :d1 AND :d2 AND :r <> 'APAC'";

PreparedStatement ps = region.equals("APAC") ? conn.prepareStatement(sqlApac)
                                             : conn.prepareStatement(sqlOther);
```

> **장점**: 예측 가능하고 안정적이다(특히 배치/리포트).
> **주의**: SQL 텍스트 관리가 늘어난다. **테스트/배포 룰**로 관리.

---

## **예외적으로 리터럴 상수 사용** — 정말 그 값만 다르다!

> 대원칙: **바인드가 기본**. 다만, **특정 값 딱 하나**에서만 **압도적 스큐**가 있고,
> 그 값은 **업무상 의미가 고정**(예: ‘전체’, ‘기본’, ‘국내’)이라면 **리터럴 상수**를 써서 **별도 플랜**을 만들 수도 있다.

### 왜 리터럴인가?

- Parent를 분리하여 **완전히 다른 플랜**을 강제.
- ACS 학습이나 히스토그램에 의존하지 않고, **특정값=특정 플랜**을 확정.

### 예제

```sql
-- (1) APAC은 '리터럴'로 고정 → Parent #1
SELECT /* apac-literal */ SUM(amount)
FROM   t_sales
WHERE  region='APAC'
AND    order_dt BETWEEN :d1 AND :d2;

-- (2) 그 외는 바인드 → Parent #2
SELECT /* others-bind */ SUM(amount)
FROM   t_sales
WHERE  region=:r
AND    order_dt BETWEEN :d1 AND :d2;
```

> **주의**
> - 리터럴은 **커서 공유**가 안 된다 → 호출이 매우 잦으면 **하드 파싱 증가**.
> - 정말 **핫한 단일 값**이며, 별도 Parent 유지가 시스템적으로 이득일 때만 고려.
> - 릴리즈/성능 검증 체계를 반드시 거친다.

---

## 부작용별 **진단 → 처방** 표

| 부작용 | 전형적 증상 | 확인 포인트 | 1차 처방 | 2차/보강 |
|---|---|---|---|---|
| Peeking 오판 | 특정 값에서만 급격히 느림 | XPLAN `+PEEKED_BINDS`, E/A Rows 괴리 | **히스토그램** 생성, 표현식 제거 | **ACS** 유도, 통계 피드백 확인 |
| ACS 과다 분기 | Parent 1개에 Child 수십/백 | `V$SQL_SHARED_CURSOR.reason`, `is_bind_aware` | 히스토그램 SIZE 조정, 쿼리 단순화 | **값대별 SQL 분리**, **SPM** |
| 값대별 플랜 극단 차 | 소수 값/대량 값 공존 | 유사쿼리의 라인 통계/TempSpc | **SQL 분리**(두 개의 Parent) | 베이스라인/힌트로 안정화 |
| 리터럴 남용 | Parent 폭증, 하드파싱↑ | `parse count (hard)`, `library cache: mutex X` | **바인드** 전환 | (예외) 특정 단일값만 **리터럴 분리** |

---

## 통계/히스토그램/피드백 **올바른 세팅**

```sql
-- 스큐 컬럼에 도수 히스토그램: SIZE 75 권장(환경 따라 조정)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'T_SALES', cascade => TRUE,
    method_opt => 'FOR COLUMNS SIZE 75 region SIZE 1 order_dt');
END;
/

-- 실행 후 통계 피드백 여부(XPLAN NOTE에서 표시)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  sql_id => '&&SQL_ID', child_number => NULL,
  format => 'ALLSTATS LAST +NOTE +PEEKED_BINDS +PREDICATE'));
```

> **팁**
> - 표현식(예: `TRUNC(order_dt)`)은 인덱스/통계를 무력화 → 범위식으로 전개.
> - 바인드 타입/길이 **일관화**(NLS/문자셋 혼재 방지).
> - 12c 이후 **Statistics Feedback**(Cardinality Feedback)이 켜져 있다면, 다음 실행에서 카디널리티 보정이 반영될 수 있다.

---

## SPM(SQL Plan Baseline)으로 **좋은 플랜 봉인**

```sql
-- 현재 좋은 플랜을 베이스라인으로 캡처
BEGIN
  DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE(sql_id => '&&SQL_ID');
END;
/

-- 상태 확인
SELECT sql_handle, plan_name, enabled, accepted
FROM   dba_sql_plan_baselines
ORDER  BY last_verified;
```

> **역할**: 히스토그램/ACS/동적 샘플링으로도 불안정하면, **좋은 플랜을 장기 보존**해 변동성 차단.
> **주의**: 데이터/통계가 크게 변하면 “좋았던 플랜”이 더이상 최적이 아닐 수 있다 → 정기 재검증.

---

## 관찰/점검 스크립트 묶음

```sql
-- (A) 최근 15분, 해당 SQL의 Child/라인 통계/XPLAN
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,
 'ALLSTATS LAST +PEEKED_BINDS +PREDICATE +NOTE +OUTLINE'));

-- (B) Child 과다 여부
SELECT sql_id, COUNT(*) children, SUM(parse_calls) parse_calls
FROM   v$sql
WHERE  sql_text LIKE 'SELECT /* acs-demo */%'
GROUP  BY sql_id ORDER BY children DESC;

-- (C) 공유 실패/분기 이유
SELECT child_number, reason
FROM   v$sql_shared_cursor
WHERE  sql_text LIKE 'SELECT /* acs-demo */%'
  AND  reason IS NOT NULL AND reason <> 'N'
ORDER  BY child_number;

-- (D) 라이브러리 캐시 관련 대기(학습·재파싱이 많은지)
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '15' MINUTE; EXEC :t2 := SYSTIMESTAMP;
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event IN ('library cache: mutex X','library cache: mutex S',
                 'cursor: pin S wait on X')
GROUP  BY event ORDER  BY samples DESC;
```

---

## 의사결정 트리(운영용)

1) **스큐가 큰가?**
   - 아니오 → **바인드 + 표준 통계**로 충분.
   - 예 → 2로.

2) **히스토그램 적용 후에도 값별 성능 격차가 큰가?**
   - 아니오 → **ACS** 가 자연스럽게 Child 2~3개로 안정.
   - 예 → 3으로.

3) **ACS가 과다 분기/불안정한가?**
   - 아니오 → 그대로 운용, **SPM**으로 봉인 고려.
   - 예 → 4로.

4) **값대별 SQL 분리**(APAC 전용, 기타 전용 등) 설계가 가능한가?
   - 예 → **SQL 분리 + 힌트/베이스라인**으로 안정화.
   - 아니오 → 5로.

5) **특정 단일값만 압도적으로 핫**하고, 호출 패턴 예측 가능?
   - 예 → **그 값만 리터럴**로 분리(Parent 분리).
   - 아니오 → 데이터 모델/인덱싱/쿼리 재설계 검토.

---

## 실전 Q&A

- **Q. `CURSOR_SHARING=FORCE`로 강제 바인드하면 끝 아닌가요?**
  **A.** 응급 처치론 가능하지만 **히스토그램 정보를 무력화**해 플랜 품질이 떨어질 수 있다.
  근본 해결은 **앱 차원의 바인드 + 히스토그램 + (필요 시) SQL 분리**.

- **Q. ACS Child가 너무 많습니다. 끄는 게 답인가요?**
  **A.** 먼저 **히스토그램 SIZE/통계 정확도**를 조정해 “필요한 분기만” 일어나게 하고,
  그래도 과하면 **SQL 분리**·**SPM**으로 안정화. 무조건 Off는 권장하지 않는다.

- **Q. 리터럴 분리의 기준은?**
  **A.** (1) **단일 값** 혹은 극소수 값, (2) **고정된 비즈니스 의미**, (3) **명백한 성능 이득**,
  (4) **운영 관리** 가능(모니터링/테스트/릴리스 체크리스트 포함).

---

## 결론

- **Peeking** 은 바인드의 성능 이점을 주면서도 **첫 값 편향** 부작용을 만든다.
- **ACS** 는 이를 런타임에 보정하지만, **통계 정확도**와 **환경 일관성**이 뒷받침되어야 한다.
- 여전히 **값별 플랜이 극단적으로 다르면** **SQL을 값대별로 분리**하는 **명시적 전략**이 가장 안정적이다.
- 극히 예외적으로 **리터럴 상수 분리**로 핫값을 격리할 수 있으나, **운영 규율**(검증·모니터링·롤백 플랜)이 필수다.

> **한 줄 요약**
> 바인드는 기본, **히스토그램+ACS** 는 보정, **SQL 분리**는 해답, **리터럴 분리**는 **최후의 카드**다.
> *숫자(E/A Rows, Child 수, AWR/ASH)로 증명하면서 적용하라.*
