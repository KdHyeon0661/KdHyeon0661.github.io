---
layout: post
title: 시스템보안 - 커널 익스플로잇 입문
date: 2025-10-22 21:30:23 +0900
category: 시스템보안
---
# 커널 익스플로잇 입문 — 구조 이해, 버그 패턴, 안전한 실습/디버깅

> 본 문서는 **방어/교육 목적**입니다. 실제 “권한 상승”을 일으키는 **완전한 익스플로잇 단계**(주소·가젯·페이로드)는 제공하지 않습니다. 대신 **커널 메모리 모델/시스템콜 경로/드라이버 IOCTL**의 구조를 이해하고, **UAF/타입 혼동/임의 쓰기** 같은 전형적 버그가 “어떤 코드 패턴에서 왜 생기는지”를 **재현 가능한 안전 랩**으로 관찰합니다. 모든 실습은 **본인 소유의 VM/스냅샷**에서만 진행하세요.

---

## 실습 공통 세팅(안전 가드레일)

- **VM**: QEMU/KVM(권장) 또는 Hyper-V/VMware, “Host-only” 네트워크, **스냅샷 필수**.
- **Linux 타깃(예)**: Ubuntu LTS (generic kernel) + 커널 헤더(`linux-headers-$(uname -r)`).
- **Windows 타깃(예)**: Windows 11 + WDK + WinDbg Preview.
- 실습 소스는 **학습용 드라이버**로만 사용(실서비스/서드파티 드라이버에 적용 금지).

---

# 커널 메모리, 시스템 콜 경로, 드라이버 인터페이스(IOCTL)

## 커널 메모리 모델(요약)

### Linux

- **가상 주소 분할**(전통 x86\_64): 사용자 128 TB / 커널 128 TB (플랫폼·구성에 따라 다름).
- **주요 힙**: `kmalloc`/`kzalloc`(SLUB/SLAB), `vmalloc`(비연속), `page_alloc`.
- **레퍼런스 카운팅**: `kref`, `refcount_t`, `atomic_t`.
- **동기화**: `spinlock_t`, `mutex`, RCU(읽기 다수/쓰기 적음 경로).

### Windows

- **Pool**: NonPagedPool(페이징 불가), PagedPool(페이징 가능).
- **Object manager** + **Handle table** + **Reference counting**.
- **IRQL**(인터럽트 요청 레벨): 락/메모리 API 사용 제약의 핵심.

> 핵심: **수명과 동시성**이 메모리 버그의 뿌리. “어디서 참조를 늘리고, 어디서 줄이며, 언제 free 되는가”를 **코드로** 명확히 하라.

---

## 시스템 콜 경로(호출 스택 시야 넓히기)

### Linux

```
user space
  ↳ libc wrapper (e.g., write)
    ↳ syscall instruction (syscall/sysenter)
      ↳ entry_SYSCALL_64()
        ↳ do_syscall_64()
          ↳ __x64_sys_write()         # 커널 구현
            ↳ vfs_write() → file ops → driver
```
- **보안 레이어**: LSM(SELinux/AppArmor), seccomp, cgroup, namespace, capabilities.

### Windows

```
user space
  ↳ ntdll!NtXxx
    ↳ sysenter/syscall
      ↳ ntoskrnl!NtXxx / ZwXxx
        ↳ I/O manager → IRP → Driver Dispatch
```
- **보안 레이어**: Ob/Se(객체/보안), Token/Integrity/UAC, Code Integrity.

---

## 드라이버 인터페이스: IOCTL

### Linux: `unlocked_ioctl` / `compat_ioctl`

- 사용자→커널 전달은 **항상 신용 금지**.
- **필수**: `copy_from_user`/`copy_to_user` + 길이/정렬 검증 + 스펙 고정.

**(예) 학습용 문자 디바이스 스켈레톤 (취약 아님)**
```c
// drv_skel.c — 안전 스켈레톤 (Linux)
// 빌드: make -C /lib/modules/$(uname -r)/build M=$PWD modules
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/cdev.h>

#define DEV "skel"
#define IOCTL_MAGIC 'S'
#define IOCTL_ECHO _IOWR(IOCTL_MAGIC, 0x10, struct echo_arg)

struct echo_arg { __u32 len; char __user *buf; };

static dev_t devno;
static struct cdev cdev_skel;

static long skel_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
{
    if (_IOC_TYPE(cmd) != IOCTL_MAGIC) return -ENOTTY;

    if (cmd == IOCTL_ECHO) {
        struct echo_arg ua;
        char kbuf[256];
        if (copy_from_user(&ua, (void __user *)arg, sizeof(ua)))
            return -EFAULT;
        if (ua.len > sizeof(kbuf)) return -EINVAL;
        if (!ua.buf) return -EINVAL;
        if (copy_from_user(kbuf, ua.buf, ua.len))
            return -EFAULT;
        // 간단 검증: ASCII만 허용(예시)
        for (u32 i = 0; i < ua.len; ++i) if (kbuf[i] < 0x09 || kbuf[i] > 0x7e) return -EINVAL;
        // 사용자에게 그대로 반환
        if (copy_to_user(ua.buf, kbuf, ua.len)) return -EFAULT;
        return ua.len;
    }
    return -ENOTTY;
}

static const struct file_operations fops = {
    .owner = THIS_MODULE, .unlocked_ioctl = skel_ioctl,
#ifdef CONFIG_COMPAT

    .compat_ioctl = skel_ioctl,
#endif

};

static int __init skel_init(void){
    int ret = alloc_chrdev_region(&devno, 0, 1, DEV);
    if (ret) return ret;
    cdev_init(&cdev_skel, &fops);
    cdev_skel.owner = THIS_MODULE;
    ret = cdev_add(&cdev_skel, devno, 1);
    if (ret) { unregister_chrdev_region(devno, 1); return ret; }
    pr_info(DEV ": loaded major=%d minor=%d\n", MAJOR(devno), MINOR(devno));
    return 0;
}
static void __exit skel_exit(void){
    cdev_del(&cdev_skel);
    unregister_chrdev_region(devno, 1);
    pr_info(DEV ": unloaded\n");
}
module_init(skel_init); module_exit(skel_exit);
MODULE_LICENSE("GPL");
```

**사용자 공간 테스트(안전)**
```c
// user_echo.c — 안전 테스트
#include <stdio.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <string.h>
#include <stdint.h>
#define IOCTL_MAGIC 'S'
#define IOCTL_ECHO _IOWR(IOCTL_MAGIC, 0x10, struct echo_arg)

struct echo_arg { uint32_t len; char *buf; };
int main(){
  int fd = open("/dev/skel0", O_RDONLY); // udev rules로 /dev 생성했음 가정
  if(fd<0){perror("open"); return 1;}
  char msg[16] = "HELLO\n";
  struct echo_arg a = { .len = (uint32_t)strlen(msg), .buf = msg };
  int r = ioctl(fd, IOCTL_ECHO, &a);
  if(r<0){perror("ioctl");} else { write(1, msg, r); }
  close(fd);
}
```

> 포인트: **모든 경계/포인터를 검증**하고, 커널 메모리를 사용자 포인터로 **직접 쓰지 않는다**.

### Windows: KMDF `EvtIoDeviceControl`

- Windows는 IRP를 통해 I/O Stack을 전달. 사용자 버퍼 접근은 **`WdfRequestRetrieveInputBuffer`** 등 프레임워크가 검증된 매핑을 제공.

**(예) KMDF 스켈레톤**
```c
// KMDF EvtIoDeviceControl 스니펫(개념)
VOID EvtIoDeviceControl(
    WDFQUEUE Queue, WDFREQUEST Request,
    size_t OutputBufferLength, size_t InputBufferLength, ULONG IoControlCode)
{
    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
    PVOID inBuf = NULL; size_t inLen = 0;
    PVOID outBuf = NULL; size_t outLen = 0;

    // 길이/코드 스펙 강제
    if (IoControlCode == IOCTL_SAFEECHO) {
        if (InputBufferLength > 256 || OutputBufferLength > 256) {
            status = STATUS_BUFFER_OVERFLOW; goto done;
        }
        status = WdfRequestRetrieveInputBuffer(Request, InputBufferLength, &inBuf, &inLen);
        if (!NT_SUCCESS(status)) goto done;
        status = WdfRequestRetrieveOutputBuffer(Request, OutputBufferLength, &outBuf, &outLen);
        if (!NT_SUCCESS(status)) goto done;

        RtlCopyMemory(outBuf, inBuf, min(inLen, outLen));
        WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, min(inLen, outLen));
        return;
    }
done:
    WdfRequestComplete(Request, status);
}
```

> 포인트: **길이 제한**, **버퍼 매핑 API 사용**, **스펙(프로토콜) 고정**.

---

# 흔한 버그 유형: UAF / Type Confusion / Arbitrary Write

> 다음 예제는 “버그가 **어떤 코드 냄새**에서 생기는지”를 보여주는 **교육용 패턴**입니다. “권한 상승”을 일으키는 악용 절차는 포함하지 않습니다.

## Use-After-Free(UAF)

### 왜 생기나?

- 객체 해제 후에도 **다른 경로에서 참조**(dangling pointer).
- 레퍼런스 카운트 관리 부재/경합에서 흔함.

**(취약 패턴 예시: 개념)**
```c
// 나쁜 예(의도적): 참조 잡지 않고, free 후 다른 쓰레드가 접근 가능
struct node { atomic_t ref; char data[32]; };
struct node *g; // 전역

void release(struct node *n){
  if (atomic_dec_and_test(&n->ref)) kfree(n);
}

long ioctl_set(struct node *n, const char __user *u, size_t l){
  if (copy_from_user(n->data, u, min(l, sizeof(n->data)))) return -EFAULT;
  return 0;
}

long bad_path(unsigned long arg){
  // g를 잠금 없이 교체
  struct node *old = g;
  struct node *n = kmalloc(sizeof(*n), GFP_KERNEL);
  atomic_set(&n->ref, 1);
  g = n;
  release(old); // 여기서 old가 free
  // 다른 CPU에서 아직 old를 가리키는 경로가 있을 수 있음 → UAF
  return 0;
}
```

**(수정 방향)**
- **kref/refcount_t**로 수명 통일, **RCU**나 **락**으로 교체 시점 보호.
```c
// 스케치: 안전한 교체
spinlock_t g_lock;
struct node *g;

void replace_node(struct node *n){
  struct node *old;
  spin_lock(&g_lock);
  old = g; g = n;
  spin_unlock(&g_lock);
  // 동시 참조가 끝났음을 보장하는 메커니즘으로 해제(RCU 등)
  synchronize_rcu();
  kfree(old);
}
```

### 탐지 도구

- Linux: **KASAN**(커널 AddressSanitizer), KFENCE, `CONFIG_DEBUG_OBJECTS_*`.
- Windows: Driver Verifier(특히 **Pool Tracking**, I/O Verification).

---

## 타입 혼동(Type Confusion)

### 왜 생기나?

- 같은 메모리 블록을 **서로 다른 타입으로 해석**(태그/버전 필드 검사 부재).
- IOCTL 구조체 버전 혼동, 폴리모픽 구조체 캐스팅 오류.

**(취약 패턴 예시: 개념)**
```c
struct hdr { u16 tag; u16 len; };
struct A { struct hdr h; int x; };
struct B { struct hdr h; int y; int z; };

// 사용자 입력을 hdr만 보고 A로 단정
long bad_parse(void __user *up)
{
    struct A a;
    if (copy_from_user(&a, up, sizeof(a))) return -EFAULT;
    if (a.h.tag != 0xA0) return -EINVAL;  // len 검증 없음
    // 사용자는 사실 B를 보냈고 len이 더 큼 → 남은 필드를 다른 경로에서 B로 취급할 수도
    return 0;
}
```

**(수정 방향)**
- **명확한 버전/길이/태그 매칭** 및 상한 검증.
- 하나의 IOCTL에 **단일 타입/버전**만 허용(새 버전은 새 코드).

```c
long good_parse(void __user *up, size_t ulen)
{
    struct A a;
    if (ulen != sizeof(a)) return -EINVAL;
    if (copy_from_user(&a, up, sizeof(a))) return -EFAULT;
    if (a.h.tag != 0xA0 || a.h.len != sizeof(a)) return -EINVAL;
    // a 사용
    return 0;
}
```

---

## 임의 쓰기(Arbitrary Write)

### 왜 생기나?

- IOCTL에서 **커널 포인터를 그대로** 받아 `memcpy`/`strcpy` 등으로 **쓰기**.
- 또는 **오프셋 계산 검증 부재**로 커널 구조체의 민감 필드 덮침.

**(취약 패턴: 절대 금지)**
```c
// BAD: 사용자 포인터를 커널 주소로 신뢰
struct wreq { void *dst; char data[32]; size_t len; };
long bad_write(unsigned long arg){
  struct wreq r;
  if (copy_from_user(&r, (void __user *)arg, sizeof(r))) return -EFAULT;
  memcpy(r.dst, r.data, min(r.len, sizeof(r.data))); // 임의 커널 주소 덮기 위험
  return 0;
}
```

**(수정 방향)**
- **절대** 커널 주소를 사용자로부터 받지 않는다.
- 디바이스 내부 **컨텍스트 ID**(핸들/인덱스)를 받고 **테이블 조회**로 커널 포인터를 **서버 측**에서 해석.
```c
struct obj { char buf[64]; };
#define MAX_OBJ 128

static struct obj *table[MAX_OBJ];

struct wreq2 { u32 id; u32 off; u32 len; char data[32]; };
long safe_write(unsigned long arg){
  struct wreq2 r; struct obj *o;
  if (copy_from_user(&r, (void __user *)arg, sizeof(r))) return -EFAULT;
  if (r.id >= MAX_OBJ) return -EINVAL;
  o = table[r.id]; if (!o) return -ENOENT;
  if (r.off > sizeof(o->buf)) return -EINVAL;
  if (r.len > sizeof(r.data)) return -EINVAL;
  if (r.off + r.len > sizeof(o->buf)) return -EINVAL;
  memcpy(&o->buf[r.off], r.data, r.len);
  return r.len;
}
```

---

# 심볼/디버깅 환경(WinDbg KD, kASLR, kptr_restrict)

## Linux 커널 디버깅/심볼

### QEMU + GDB + vmlinux 심볼

1) **심볼 포함 빌드**: 배포 커널이면 `/usr/lib/debug/boot/vmlinux-$(uname -r)` 또는 `CONFIG_DEBUG_INFO=y`로 직접 빌드.
2) **QEMU**:
   ```bash
   qemu-system-x86_64 -kernel bzImage \
     -append "root=/dev/sda console=ttyS0 nokaslr" \
     -s -S -hda rootfs.img -nographic
   ```
   - `-S`: 부팅 정지, `-s`: gdb stub(`:1234`).
3) **gdb 연결**:
   ```gdb
   (gdb) file vmlinux
   (gdb) target remote :1234
   (gdb) b start_kernel
   (gdb) c
   ```
4) **nokaslr**로 커널 베이스 고정(학습용). 실제 운영은 **KASLR ON**.

### kASLR / kptr\_restrict

- **kASLR**: `randomize_kstack_offset`, 텍스트/모듈 베이스 랜덤화(플랫폼별 상이).
- **kptr_restrict**: 커널 심볼 주소 노출 제어.
  ```bash
  cat /proc/sys/kernel/kptr_restrict  # 0/1/2
  # 1 이상이면 커널 주소가 /proc/kallsyms 등에서 마스킹
  echo 2 | sudo tee /proc/sys/kernel/kptr_restrict
  ```
- **보안 원칙**: 연구 외 목적에서는 **kASLR ON + kptr_restrict=2** 유지.

### ftrace / dynamic debug / KASAN

- `echo function > /sys/kernel/debug/tracing/current_tracer`
- `dyndbg="module drv_skel +p"` 커맨드라인 옵션으로 `pr_debug` 활성.
- `KASAN`/`KFENCE`로 UAF/오버런 탐지(자체 빌드 필요).

---

## Windows WinDbg KD

### 커널 디버깅 채널 구성

- **KD over network**(신규): `bcdedit /dbgsettings net hostip:HOST port:PORT key:KEY`
- **시리얼/1394/USB**(환경 제약).
- **부트 설정**:
  ```cmd
  bcdedit /debug on
  bcdedit /dbgsettings net hostip:192.168.56.1 port:50000 key:1.1.1.1
  ```
  호스트 WinDbg에서 **Listen** 후 타깃 재부팅.

### 심볼 서버

```text
SRV*c:\symbols*https://msdl.microsoft.com/download/symbols
```
- WinDbg: File → Symbol File Path → 위 문자열 입력, `.reload /f`.

### 필수 명령

- `!process 0 1` / `!thread` / `!handle`
- `!pool`, `!verifier 3`(Driver Verifier 상태)
- `!rcdrkd.rcdrlogs`(ETW)
- 브레이크: `bp nt!NtCreateFile`, `ba w4 <addr>`(write watch)

### Code Integrity/CFG/모던 보호

- **HVCI**(Hypervisor-enforced Code Integrity), **CFG**, **CET**는 코드 재사용/로딩을 강하게 제한.
- 드라이버 개발/테스트 시 **서명** 요구(테스트 서명 모드에서만 예외).

---

## 안전한 “재현-없이” 관찰하는 방법

- **목표**: 버그를 **촉발**하지 않고 **경계 조건/로그/러닝타임 보호**가 “어떻게 반응하는지” 관찰.
- **Linux**:
  - 잘못된 IOCTL 길이/태그 투입 → **-EINVAL/-EFAULT** 경로만 관찰.
  - `lockdep`/`KASAN`/`CONFIG_DEBUG_ATOMIC_SLEEP` 활성 빌드로 **잠재 경합/수면 위반** 탐지.
- **Windows**:
  - Driver Verifier(**pool tracking, I/O verification**) 활성 → **오용 시 즉시 버그체크**로 알려줌.
  - ETW/Sysmon으로 **권한 민감 이벤트**만 추적.

---

# 6.x 운영·개발팀 체크리스트(정리)

- **IOCTL 스펙 고정**: 매직/버전/길이/정렬 **모두 검사**. 사용자 포인터로 **커널 주소를 받지 말 것**.
- **수명 관리**: `refcount_t/kref` 사용, 교체 시 RCU/락으로 **dangling 방지**.
- **메모리 안전 옵션**: KASAN/KFENCE/UBSAN(리눅스), Driver Verifier(윈도우).
- **빌드/배포**: 심볼은 **개발/테스트 전용**으로 관리, 운영은 KASLR/kptr\_restrict 활성.
- **관찰성**: ftrace/Kprobe/eBPF(리눅스), ETW/Sysmon(윈도우)로 변칙 행위 감시.
- **정책**: Windows **WDAC/AppLocker**, Linux **LSM/seccomp**로 입력 채널 축소.

---

# 부록 A — Linux 학습용 Makefile (모듈 빌드)

```make
# Makefile

obj-m := drv_skel.o
KDIR  := /lib/modules/$(shell uname -r)/build
all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules
clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean
```
```bash
make && sudo insmod drv_skel.ko
dmesg | tail
# /dev 노출은 udev 규칙 또는 misc 등록으로 처리(실습에서는 'sudo mknod /dev/skel0 c <major> 0'로 수동 생성 가능)

```

---

# 부록 B — “안전 실패” 중심 사용자 테스트(리눅스)

```c
// user_fuzzlite.c — 경계값만 흔드는 안전 퍼저(커널 크래시 유발 금지 설계)
#include <stdio.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <string.h>
#include <stdint.h>
#define IOCTL_MAGIC 'S'
#define IOCTL_ECHO _IOWR(IOCTL_MAGIC, 0x10, struct echo_arg)

struct echo_arg { uint32_t len; char *buf; };

int main(){
  int fd = open("/dev/skel0", O_RDONLY);
  if(fd<0){perror("open"); return 1;}
  char junk[300]; memset(junk, 'A', sizeof(junk));
  struct echo_arg a;
  // 1) len=0
  a.len=0; a.buf=junk;
  ioctl(fd, IOCTL_ECHO, &a);
  // 2) len=255(허용 최대 근처)
  a.len=255; ioctl(fd, IOCTL_ECHO, &a);
  // 3) len=257(초과 → -EINVAL 기대)
  a.len=257; if(ioctl(fd, IOCTL_ECHO, &a)>=0) puts("unexpected ok");
  close(fd);
}
```
- 기대: 커널에서 **-EINVAL/-EFAULT**로 “안전 실패”. KASAN/lockdep 경고 **무**.

---

# 부록 C — Windows Driver Verifier 빠른 힌트

```cmd
verifier /standard /driver MyDriver.sys
# 재부팅 후 블루스크린이 난다면, 해당 콜스택/검사 항목을 기반으로 수명/IRQL/풀 사용을 고치세요.

verifier /reset
```

---

# 마무리

- 커널 취약점의 80%는 **수명/경계/타입** 문제로 귀결됩니다.
- 익스플로잇을 “만드는” 것보다 **버그가 생기지 않게 코드를 작성**하고, **런타임 보호/검증**으로 조기에 포착하는 것이 실무의 정답입니다.
- 위 스켈레톤/테스트는 **재현 없이**도 “검증·관찰·학습”이 가능합니다.
- 필요하면 본 문서를 **사내 커널 코딩 규약**과 **드라이버 IOCTL 스펙 템플릿**으로 변환하고, KASAN/Verifier/ETW·ftrace 기반 **정적·동적 테스트 파이프라인** 샘플을 만들어 드릴게요.
