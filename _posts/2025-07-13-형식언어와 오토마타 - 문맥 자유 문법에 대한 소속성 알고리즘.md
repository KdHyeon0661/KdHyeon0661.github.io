---
layout: post
title: 형식언어와 오토마타 - 문맥 자유 문법에 대한 소속성 알고리즘
date: 2025-07-13 20:20:23 +0900
category: 형식언어와 오토마타
---
# 문맥 자유 문법(CFG)에 대한 **소속성 알고리즘** 완전 가이드  

## 0. 한눈 개요

- **소속성 문제(Membership)**:  
  주어진 CFG \(G\)와 문자열 \(w\)에 대해 **\(w \in L(G)\)** 인지 판정.
- **대표 알고리즘**  
  - **CYK**: CNF 필요, **\(O(n^3\cdot|P|)\)**. DP 테이블 기반(하향식·역유도).  
  - **Earley**: 일반 CFG에 적용, **최악 \(O(n^3)\)**, 보통 더 빠름.  
- **실무 감각**:  
  - **정적 분석/컴파일러**: LR/LL 생성기(ANTLR, bison 등) = 결정적 파서(DCFL 영역).  
  - **모호 문법/자유도 큰 문법**: Earley/GLR, 또는 CYK(+SPPF)로 모두 처리.

---

## 1. 문제 정의와 표기

> **문제**: CFG \(G=(V,\Sigma,R,S)\) 와 문자열 \(w=a_1a_2\cdots a_n\) 가 주어졌을 때,  
> **\(w \in L(G)\)** 인지(= \(S \Rightarrow^* w\))를 결정하라.

- \(V\): 비터미널 집합, \(\Sigma\): 터미널 집합, \(R\): 생성규칙, \(S\): 시작기호.
- **목표**: True/False (필요시 파스 트리까지 복원).

---

## 2. CYK 알고리즘: 이론 → 구현

### 2.1 CNF(Chomsky Normal Form) 전제
- 규칙 형태:
  1) \(A \to BC\) (두 비터미널)  
  2) \(A \to a\) (하나의 터미널)  
  3) \(S \to \varepsilon\) (필요한 경우에만)
- **CNF 변환**은 항상 가능(언어 보존). 변환 절차는 §4에 정리.

### 2.2 DP 정의

문자열 \(w=a_1\cdots a_n\) 에 대해, 2차원 테이블 \(T[i][\ell]\) (1-indexed) 를:

- \(T[i][\ell] = \{ A \in V \mid A \Rightarrow^* a_i\cdots a_{i+\ell-1} \}\)

로 정의.

**점화식** (길이 \(\ell\ge 2\), 분할점 \(k\in[1,\ell-1]\)):
$$
A\in T[i][\ell]\iff \exists\,k,\,\exists\,B\in T[i][k],\,\exists\,C\in T[i+k][\ell-k]\ \text{s.t.}\ (A\to BC)\in R.
$$

**초기화** (\(\ell=1\)):
$$
A\in T[i][1]\iff (A\to a_i)\in R.
$$

**최종 판정**: \(S\in T[1][n]\) 이면 수용.

### 2.3 시간·공간 복잡도
- 시간: \(O(n^3\cdot|P|)\) (실전 구현은 RHS 인덱싱으로 \(O(n^3)\)에 가깝게).
- 공간: \(O(n^2\cdot|V|)\).

### 2.4 손으로 해보는 미니 예제

문법(CNF):
```
S → AB | BC
A → BA | a
B → CC | b
C → AB | a
```
문자열: `baaba` (길이 5)

- \(T[i][1]\): 각 단문자 칸에 \(A\to a\), \(B\to b\), \(C\to a\) 근거로 채움
- 길이 2..5 차례로, 모든 분할 \(k\) 조합을 보며 \(A\to BC\) 역으로 채움
- 마지막 \(T[1][5]\)에 **S**가 있으면 True

> (전체 표 전개는 길어 생략. 아래 CYK 구현으로 자동 확인 가능)

---

## 3. CYK **파이썬 구현** (멤버십 + 파스 트리 복원)

아래 코드는:
- **CNF**를 입력으로 받음
- **멤버십 판정**과 **하나의 파스 트리** 복원(백포인터 사용)
- 다수 파스 트리(모호 문법)는 조합 폭발 → 예제로는 **하나** 복원

```python
from collections import defaultdict
from typing import Dict, Set, Tuple, List, Optional

# ----- CNF Grammar container -----
class CNFGrammar:
    def __init__(self):
        # unary: a -> {A | A->a}
        self.unary: Dict[str, Set[str]] = defaultdict(set)
        # binary: (B, C) -> {A | A->BC}
        self.binary: Dict[Tuple[str, str], Set[str]] = defaultdict(set)
        self.start: Optional[str] = None
        self.vars: Set[str] = set()
        self.terminals: Set[str] = set()

    def add_rule_unary(self, A: str, a: str):
        self.unary[a].add(A)
        self.vars.add(A)
        self.terminals.add(a)

    def add_rule_binary(self, A: str, B: str, C: str):
        self.binary[(B, C)].add(A)
        self.vars.update([A, B, C])

    def set_start(self, S: str):
        self.start = S
        self.vars.add(S)

# ----- CYK with backpointers -----
def cyk_membership_with_tree(G: CNFGrammar, w: str):
    n = len(w)
    if n == 0:
        # 빈 문자열은 CNF에서 S->ε일 때만 수용(여기선 규칙을 따로 저장하지 않음)
        return False, None

    # T[i][l] = set of variables deriving w[i:i+l]
    T: List[List[Set[str]]] = [[set() for _ in range(n+1)] for _ in range(n)]
    # back[i][l][A] = one witness to reconstruct a parse for A ⇒ w[i:i+l]
    #   if l==1: ("unary", terminal)
    #   if l>1: ("binary", k, B, C)
    back: List[List[Dict[str, Tuple]]] = [[{} for _ in range(n+1)] for _ in range(n)]

    # init for length 1
    for i, a in enumerate(w):
        for A in G.unary.get(a, ()):
            T[i][1].add(A)
            back[i][1][A] = ("unary", a)

    # fill for length l = 2..n
    for l in range(2, n+1):
        for i in range(0, n-l+1):
            for k in range(1, l):
                left_set = T[i][k]
                right_set = T[i+k][l-k]
                if not left_set or not right_set:
                    continue
                # try all pairs (B,C)
                for B in left_set:
                    for C in right_set:
                        for A in G.binary.get((B, C), ()):
                            if A not in T[i][l]:
                                T[i][l].add(A)
                                back[i][l][A] = ("binary", k, B, C)

    accepted = (G.start in T[0][n])
    tree = None
    if accepted:
        tree = reconstruct_tree(back, G.start, 0, n, w)
    return accepted, tree

def reconstruct_tree(back, A: str, i: int, l: int, w: str):
    info = back[i][l][A]
    if info[0] == "unary":
        # leaf: A -> a
        (_, a) = info
        return (A, a)
    else:
        _, k, B, C = info
        left = reconstruct_tree(back, B, i, k, w)
        right = reconstruct_tree(back, C, i+k, l-k, w)
        return (A, left, right)

def pretty_tree(node, indent=0):
    if isinstance(node, tuple) and len(node) == 2 and isinstance(node[1], str):
        A, a = node
        return "  "*indent + f"{A} -> '{a}'"
    A, left, right = node
    s = "  "*indent + f"{A}\n"
    s += pretty_tree(left, indent+1) + "\n"
    s += pretty_tree(right, indent+1)
    return s

# ----- Example grammar from the text -----
def example_grammar():
    G = CNFGrammar()
    G.set_start("S")
    # S → AB | BC
    G.add_rule_binary("S", "A", "B")
    G.add_rule_binary("S", "B", "C")
    # A → BA | a
    G.add_rule_binary("A", "B", "A")
    G.add_rule_unary("A", "a")
    # B → CC | b
    G.add_rule_binary("B", "C", "C")
    G.add_rule_unary("B", "b")
    # C → AB | a
    G.add_rule_binary("C", "A", "B")
    G.add_rule_unary("C", "a")
    return G

if __name__ == "__main__":
    G = example_grammar()
    for w in ["baaba", "abba", "a", "baba", "baabaa"]:
        ok, tree = cyk_membership_with_tree(G, w)
        print(f"{w}: {ok}")
        if ok and tree:
            print(pretty_tree(tree))
            print("----")
```

**설명**
- `unary[a] = {A}` 는 \(A\to a\).  
- `binary[(B,C)] = {A}` 는 \(A\to BC\).  
- `back` 테이블로 **하나의 파스 트리** 복원. (모호 시 첫 발견만 기록)

---

## 4. CNF 변환(필수 전처리): 실전 절차 & 코드 스켈레톤

### 4.1 절차(요약)
1) **쓸모없는 기호 제거**  
   - 생성 불가(터미널로 닫히지 않음), 도달 불가(시작에서 닿지 않음).
2) **\(\varepsilon\)-규칙 제거**  
   - nullable 집합 계산 → 각 규칙 RHS에서 nullable 기호 모든 부분집합 생략의 조합 추가. \(S\to\varepsilon\) 예외.
3) **단위 규칙 제거** (\(A\to B\))  
   - unit-closure로 \(A\)가 도달하는 \(B\)의 비단위 규칙을 \(A\)에 귀속.
4) **CNF 모양 만들기**  
   - 터미널이 비터미널 옆에 섞여 있으면 “프리터미널” 도입: \(A\to aB\) → \(A\to X_a B,\ X_a\to a\)  
   - RHS 길이 \(>2\) 규칙은 단계적으로 이항화: \(A\to BCD\) → \(A\to B X_1,\ X_1\to C D\)

### 4.2 파이썬 스켈레톤 (간단/교육용; 전체 구현은 길어 핵심만)

```python
from collections import defaultdict, deque

class CFG:
    def __init__(self, start):
        self.start = start
        self.vars = set([start])
        self.terminals = set()
        # rules: A -> list of RHS (each RHS is tuple of symbols)
        self.rules = defaultdict(list)

    def add(self, A, rhs):
        self.vars.add(A)
        for s in rhs:
            if s.islower():  # heuristic: lowercase=terminal
                self.terminals.add(s)
            else:
                self.vars.add(s)
        self.rules[A].append(tuple(rhs))

def to_cnf(cfg: CFG):
    # 1) useless removal (sketch)
    cfg = remove_useless(cfg)
    # 2) epsilon removal (sketch)
    cfg = remove_epsilon(cfg)
    # 3) unit removal (sketch)
    cfg = remove_unit(cfg)
    # 4) binarize & terminal isolate
    cnf = binarize_and_isolate_terminals(cfg)
    return cnf

# 아래 함수들은 실제론 수십~수백 줄 규모가 될 수 있음.
# 교육용으로 골격만 제시. 실전 사용 시 철저한 테스트 권장.
def remove_useless(cfg: CFG): ...
def remove_epsilon(cfg: CFG): ...
def remove_unit(cfg: CFG): ...
def binarize_and_isolate_terminals(cfg: CFG): ...
```

> **팁**: 현업/연구용은 검증된 라이브러리(예: NLTK CFG→CNF 변환기) 참조 권장.

---

## 5. Earley 알고리즘: CNF 필요 없음, 모든 CFG에 적용

### 5.1 핵심 아이디어
- **Earley 항목**: \([A\to \alpha \cdot \beta, i]\)  
  - 점(`·`)은 **현재까지 인식한 RHS 위치**,  
  - \(i\)는 **해당 규칙의 시작 인덱스**(백포인터용).
- **차트(Chart)**: 위치 \(k\)마다 집합 \(S_k\) (입력 접두사 길이 \(k\)까지 고려)
- **세 연산**  
  1) **Predictor**: \([A\to \alpha\cdot B\beta,i]\) ⇒ \(B\)의 규칙을 \(S_k\)에 예측  
  2) **Scanner**: \([A\to \alpha\cdot a\beta,i]\) & 다음 입력 \(a\) 일치 ⇒ \(S_{k+1}\)에 점 전진  
  3) **Completer**: \([B\to \gamma\cdot, j]\) complete ⇒ 이를 기다리던 항목들의 점 전진

**수용**: \(S_n\) (입력 길이 \(n\)) 안에 \([S\to \gamma\cdot, 0]\) 존재하면 True.

### 5.2 시간복잡도
- 최악 \(O(n^3)\), 평균/현실에서 종종 \(O(n^2)\)~\(O(n)\).

### 5.3 **파이썬 구현(멤버십)**: 간결 버전

```python
from collections import defaultdict

class EarleyGrammar:
    def __init__(self, start):
        self.start = start
        self.rules = defaultdict(list)  # A -> list of RHS (tuple)
        self.nonterm = set([start])
        self.term = set()

    def add(self, A, rhs):
        self.nonterm.add(A)
        tup = tuple(rhs)
        for s in tup:
            if s.islower(): self.term.add(s)
            else: self.nonterm.add(s)
        self.rules[A].append(tup)

def earley_membership(G: EarleyGrammar, w: str) -> bool:
    n = len(w)
    # State = (A, rhs_tuple, dot, origin_i)
    S = [set() for _ in range(n+1)]

    # augmented start: S' -> S
    S0 = G.start + "'"
    while S0 in G.nonterm: S0 += "'"
    G.rules[S0] = [(G.start,)]
    G.nonterm.add(S0)

    def predictor(A, k):
        changed = False
        for rhs in G.rules[A]:
            it = (A, rhs, 0, k)
            if it not in S[k]:
                S[k].add(it); changed = True
        return changed

    def scanner(state, k):
        # state: (A, rhs, dot, i)
        A, rhs, dot, i = state
        if dot < len(rhs):
            a = rhs[dot]
            if k < n and a in G.term and w[k] == a:
                it = (A, rhs, dot+1, i)
                if it not in S[k+1]:
                    S[k+1].add(it); return True
        return False

    def completer(state, k):
        # completed B at k
        B, rhs, dot, j = state
        changed = False
        for st in list(S[j]):
            A, rhsA, dotA, iA = st
            if dotA < len(rhsA) and rhsA[dotA] == B:
                it = (A, rhsA, dotA+1, iA)
                if it not in S[k]:
                    S[k].add(it); changed = True
        return changed

    # init
    S[0].add((S0, (G.start,), 0, 0))

    for k in range(n+1):
        changed = True
        while changed:
            changed = False
            for state in list(S[k]):
                A, rhs, dot, i = state
                # predictor
                if dot < len(rhs) and rhs[dot] in G.nonterm:
                    if predictor(rhs[dot], k): changed = True
                # scanner
                if dot < len(rhs) and rhs[dot] in G.term:
                    if scanner(state, k): changed = True
                # completer
                if dot == len(rhs):
                    if completer(state, k): changed = True

    return (S0, (G.start,), 1, 0) in S[n]

# 예시
if __name__ == "__main__":
    G = EarleyGrammar("S")
    # S -> a S b | ε
    G.add("S", ("a","S","b"))
    G.add("S", ())  # ε
    for w in ["", "ab", "aabb", "aaabbb", "aab", "abb"]:
        print(w, earley_membership(G, w))
```

**포인트**
- CNF 변환 **불필요**.  
- \(\varepsilon\)-규칙도 자연스럽게 처리(길이 0 RHS: `()`).

---

## 6. 파스 트리/포레스트 복원

- **CYK**: `back[i][l][A] = ("binary", k, B, C)` 형태의 백포인터를 **여러 개** 저장하면 **모든 트리** 생성 가능(단, 수가 기하급수적일 수 있음).
- **Earley**: 각 항목에 **백포인터**(예: 어떤 completer로 진행되었는지) 저장 → **SPPF**(Shared Packed Parse Forest)로 공유 구조 생성 → 모호성도 압축 표현.

> 실전: **SPPF**를 쓰면 ‘모든 트리’를 지연 생성/공유 저장 가능(메모리·시간 모두 절약).

---

## 7. 실전 성능 팁

### CYK
- **인덱싱**: `binary[(B,C)]` 사전으로 RHS→LHS 즉시 조회(위 코드 반영).  
- **비트셋**: 각 칸을 bitmask로(변수 수가 수십~수백일 때 빠름).  
- **삼중루프 순서**: (길이)→(i)→(k) 고정 VS cache-friendly 튜닝.  
- **사전 계산**: 단말→변수, (B,C)→변수는 불변이라 사전 구축 필수.

### Earley
- **도메인 제약**: 특정 비터미널의 예측 폭 줄이기(우변 첫 기호 파생 시작 문자를 전계산: FIRST sets).  
- **실전 평균 빠름**: LL/LR로는 불가능한 문법도 Earley가 유연히 처리.

---

## 8. 에지 케이스·디버깅

- **빈 문자열**: CNF에서 \(S\to\varepsilon\) 허용 시에만 수용. Earley는 빈 RHS로 자연 처리.  
- **단말/비단말 혼재 RHS**: CNF 전처리에서 **프리터미널 도입** 잊지 않기.  
- **유닛/ε 규칙 제거 순서**: 보통 “쓸모없는 제거 → ε 제거 → 유닛 제거 → 이항화”.  
- **모호성**: 멤버십은 True라도 **여러 트리**가 있을 수 있음(특히 표현식 문법).  
- **길이 폭증 주의**: 모든 트리 출력은 금지(테스트는 1~2개만).

---

## 9. “상황” 별 선택 가이드

| 상황 | 추천 |
|---|---|
| 학습·증명·모형검증 | **CYK** (CNF + DP 테이블 가시성 높음) |
| CNF 변환 피하고 싶다 | **Earley** |
| 문법이 복잡·모호 가능성 큼 | **Earley / GLR** |
| 파스 트리 모두 필요 | CYK/Earley + **SPPF** |

---

## 10. 실습 세트

### 10.1 CYK로 `baaba` 확인
- 위 **CNF 예제** + `baaba` 입력 → 코드 출력에서 `True` 이면 수용.  
- `pretty_tree(tree)`로 하나의 파스 트리 확인.

### 10.2 Earley로 균형 괄호
- `S → a S b | ε` 문법 + 입력 `"aaabbb"` → `True`, `"aab"` → `False`.

### 10.3 CNF 변환 미션
- 임의 CFG에서 섞인 RHS(`A→aB`, `A→BCD`)를 **프리터미널** 도입 및 **이항화**로 CNF 만들기.  
- 만든 CNF로 CYK 테이블의 **대각선(길이1)**부터 채워보라.

---

## 11. 자주 하는 질문(FAQ)

**Q1. CYK는 왜 CNF여야 하나요?**  
A. 점화식이 **길이 2 분해(이항)**에 의존. CNF가 아니면 분해 조합이 복잡해짐.

**Q2. Earley가 항상 더 좋은가요?**  
A. 항상은 아님. CNF가 있고 대량 배치로 돌릴 땐 CYK도 빠르고 구현도 단순.

**Q3. 모호 문법의 모든 파스 트리를 어떻게?**  
A. **SPPF**를 구성해 공유·압축 형태로 보관. 필요 시 순회하며 일부 출력.

**Q4. 실무에서 굳이 CYK/Earley를 쓰나요?**  
A. 컴파일러는 보통 **LL/LR(결정적)**. 하지만 DSL/포괄 문법/도구 연구에선 Earley/GLR도 실전 사용.

---

## 12. 요약 치트시트

- **CYK**  
  - 전제: **CNF**  
  - 테이블: \(T[i][\ell]\) = 부분문자열 `w[i:i+ℓ]`를 만들 수 있는 **비터미널 집합**  
  - 점화: 분할 \(k\)로 \(A\to BC\) 역추적  
  - 복잡도: \(O(n^3)\)
- **Earley**  
  - 전제: **일반 CFG**  
  - 차트 \(S_k\), 항목 \([A\to \alpha\cdot\beta, i]\)  
  - 연산: Predictor / Scanner / Completer  
  - 복잡도: 최악 \(O(n^3)\), 평균 더 좋음
- **트리 복원**: 백포인터 / SPPF  
- **CNF 변환**: 쓸모없는→ε→유닛→이항화/프리터미널

---

## 13. 추가: CYK 테이블 출력 유틸 (디버깅용)

아래는 내부 테이블을 보기 좋게 찍는 간단 함수(위 CYK 코드에 붙여 사용):

```python
def dump_table(T):
    # T[i][l] sets
    n = len(T)
    # 최대 길이 n
    for l in range(1, n+1):
        row = []
        for i in range(0, n-l+1):
            cell = "{" + ",".join(sorted(T[i][l])) + "}"
            row.append(f"T[{i+1},{l}]={cell}")
        print(" ".join(row))
```

---

## 14. 마무리

- 소속성 판정은 **CFG 처리의 초석**.  
- **CYK**는 명료·교육·증명에 탁월, **Earley**는 범용성·실무 민첩성 장점.  
- **CNF 전처리**와 **백포인터/포레스트**가 실전 품질을 가른다.

> 실습: 위 코드를 바로 붙여 넣고 **여러 문법/문자열**로 테스트해보라.  
> 테이블과 트리를 함께 보면서 “왜 True/False인지”를 **구조적으로 납득**하면,  
> 파싱/정형언어의 감각이 한 단계 올라간다.