---
layout: post
title: Java - 의존성 관리
date: 2025-08-13 15:20:23 +0900
category: Java
---
# 의존성 관리 (Dependency Management)

## 1. 왜 의존성 관리인가 — 목표와 위험

- **일관성(Consistency)**: 팀/환경이 달라도 **같은 그래프, 같은 버전**으로 빌드.
- **재현성(Reproducibility)**: 시간·네트워크·미러 차이와 무관하게 **동일 아티팩트 집합** 보장(잠금/검증).
- **충돌 해결(Resolution)**: 전이로 끌려온 상이한 버전들 사이에 **선택 규칙**을 정의/강제.
- **보안(Supply Chain)**: **체크섬/서명 검증**으로 아티팩트 변조·오염 방지.

---

## 2. 도구 개관 — Maven vs Gradle

| 항목 | Maven | Gradle |
|---|---|---|
| 선언 단위 | `pom.xml` | `build.gradle[.kts]` + (선택) `libs.versions.toml` |
| 버전 관리 | `dependencyManagement`/BOM import | **platform(BOM)**, **version catalogs**, **constraints** |
| 충돌 규칙 | **Nearest wins**(가까운 경로 우선) | **Highest/Latest wins**(기본: 가장 높은 버전) |
| 재현성 | 고정 버전 + 리포지토리 미러/사설 저장소 | **Dependency Locking**, **Dependency Verification** |
| 분석 도구 | `mvn dependency:tree` | `gradle dependencies`, `dependencyInsight` |

> 충돌 규칙을 명확히 이해해야 한다. Maven은 **더 가까운 의존성**을, Gradle은 기본적으로 **가장 높은 버전**을 채택한다.

---

## 3. 저장소(Repository) 정의와 기본 원칙

- **공식 중앙**(Maven Central) + **사설 저장소**(Nexus/Artifactory)를 조합한다.
- **읽기 순서**는 “내부 미러 → 외부 중앙”로 하여, 내부 검증/캐시를 우선.
- **SNAPSHOT**은 내부 저장소로 격리하고, 릴리스와 분리.

Maven 예:
```xml
<!-- settings.xml: 중앙을 내부 미러로 대체 -->
<mirrors>
  <mirror>
    <id>internal-repo</id>
    <name>Company Nexus</name>
    <url>https://nexus.mycorp/repository/maven-public/</url>
    <mirrorOf>central</mirrorOf>
  </mirror>
</mirrors>
```

Gradle 예:
```kotlin
repositories {
    maven("https://nexus.mycorp/repository/maven-public/") {
        mavenContent {
            releasesOnly() // 스냅샷 차단 (필요 시 분리)
        }
    }
    mavenCentral()
}
```

---

## 4. Maven 실전

### 4.1 기본 의존성 선언
```xml
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <version>3.5.7</version>
  </dependency>
</dependencies>
```
> 최신 라인은 3.5.x. 실제 프로젝트에서는 **BOM을 통해 버전 생략**을 권장.

### 4.2 BOM(Bill of Materials)로 버전 일괄 관리
```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-dependencies</artifactId>
      <version>3.5.7</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>

<dependencies>
  <!-- 버전 생략: BOM이 관리 -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
</dependencies>
```

### 4.3 전이/스코프/제외
- **전이(Transitive)**: 선언한 라이브러리가 끌고 오는 하위 의존성.
- **스코프**: `compile`/`provided`/`runtime`/`test` 등을 상황에 맞게.
- **제외**: 충돌/중복을 막기 위해 특정 전이를 제거.
```xml
<dependency>
  <groupId>org.example</groupId>
  <artifactId>lib-a</artifactId>
  <version>1.2.0</version>
  <exclusions>
    <exclusion>
      <groupId>commons-logging</groupId>
      <artifactId>commons-logging</artifactId>
    </exclusion>
  </exclusions>
</dependency>
```

### 4.4 충돌 진단/수정
- 트리 보기: `mvn dependency:tree -Dverbose`
- **Nearest wins**로 선택된 버전이 적절치 않다면:
  1) `dependencyManagement`에 **원하는 버전 고정**,
  2) 하위 모듈에 동일 규칙 상속(Parent POM).

---

## 5. Gradle 실전

### 5.1 현대적 선언: `implementation`/`api`
```kotlin
dependencies {
    implementation("com.google.guava:guava:33.1.0-jre") // 내부 의존
    api("org.apache.commons:commons-lang3:3.14.0")       // 퍼블릭 API에 노출
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
}
```

### 5.2 BOM 사용 — `platform` / `enforcedPlatform`
```kotlin
dependencies {
    implementation(platform("org.springframework.boot:spring-boot-dependencies:3.5.7"))
    implementation("org.springframework.boot:spring-boot-starter-web") // 버전 생략
}
```

### 5.3 Version Catalogs (`libs.versions.toml`) 예
`gradle/libs.versions.toml`:
```toml
[versions]
junit = "5.10.2"
boot  = "3.5.7"

[libraries]
junit-bom = { module = "org.junit:junit-bom", version.ref = "junit" }
junit-jupiter = { module = "org.junit.jupiter:junit-jupiter" }

[bundles]
test = ["junit-jupiter"]
```
`build.gradle.kts`:
```kotlin
dependencies {
    testImplementation(platform(libs.junit.bom))
    testImplementation(libs.junit.jupiter)
}
```

### 5.4 충돌 규칙과 분석
- Gradle 기본 규칙: **가장 높은 버전 선택(“greatest wins”)**.
- 분석 명령:
  - 트리: `./gradlew :app:dependencies --configuration runtimeClasspath`
  - 특정 모듈 인사이트:
    `./gradlew :app:dependencyInsight --configuration runtimeClasspath --dependency guava`

### 5.5 재현성 필수: **Dependency Locking**
```kotlin
// settings.gradle.kts
dependencyLocking { lockAllConfigurations() }

// 최초 잠금 생성
// ./gradlew dependencies --write-locks
```
- 생성된 `gradle.lockfile`에 **해결 결과 버전**이 고정되어, 이후 빌드는 **동일 그래프**를 재사용. 릴리스 파이프라인에서 강력 권장.

### 5.6 공급망 보안: **Dependency Verification**
```bash
# 메타데이터 스켈레톤 생성
./gradlew --write-verification-metadata sha256 help
# 검증 실패 시 키/체크섬 갱신 힌트를 기반으로 승인
```
- `gradle/verification-metadata.xml`에 **체크섬/서명 키**를 고정해 변조/오염을 차단한다.

---

## 6. 스코프/구성(Configuration) 요약표

### Maven Scope
| Scope | 의미 | 예 |
|---|---|---|
| `compile` | 기본, 컴파일·런타임·패키징 포함 | 로깅 API |
| `provided` | 런타임에 컨테이너가 제공 | Servlet API |
| `runtime` | 실행 시만 필요 | JDBC 드라이버 |
| `test` | 테스트 전용 | JUnit/Mockito |
| `import` | BOM 가져오기(관리 전용) | spring-boot-dependencies |

### Gradle Configuration
| Configuration | 의미 | 예 |
|---|---|---|
| `implementation` | 내부 구현에만 필요 | 컬렉션 유틸 |
| `api` | 공개 API에 노출 | SPI/인터페이스 |
| `compileOnly` | 컴파일 시만 | 애너테이션 API |
| `runtimeOnly` | 런타임 전용 | JDBC 드라이버 |
| `testImplementation` | 테스트 전용 | JUnit/AssertJ |

---

## 7. 충돌·정렬 패턴 — 실전 시나리오

### 7.1 “부트 스타터 + 개별 모듈” 혼용
증상: `spring-boot-starter-xyz`가 끌어오는 버전과 **직접 선언 버전**이 상이.
대응(권장 순서):
1) **BOM(platform)** 으로 통일(Gradle) 혹은 **BOM import**(Maven).
2) 꼭 필요할 때만 **override**(Maven `dependencyManagement` / Gradle `constraints`).

### 7.2 로깅 중복(SLF4J vs Log4j vs JUL)
- Maven: 전이 제외로 하나만 남기고, BOM으로 정렬.
- Gradle: platform + `dependencyInsight`로 중복 제거.

---

## 8. 대규모/모듈형 프로젝트 전략

- **Maven**: Parent POM + `dependencyManagement`로 **버전 중앙집중 관리**.
- **Gradle**: **Version Catalogs** + **platform(BOM)** + **constraints** → 루트에서 공유, 서브프로젝트는 **버전 생략**.

---

## 9. 성능·안전·운영 체크리스트

- **재현성**
  - [ ] Maven: 고정 버전 + 내부 미러 사용
  - [ ] Gradle: **Locking**(필수), **Verification**(체크섬/서명) 적용
- **충돌 제어**
  - [ ] Maven: `dependencyManagement` 우선, 필요 시 전이 `exclusions`
  - [ ] Gradle: platform(BOM) + `dependencyInsight`로 조정
- **보안**
  - [ ] 불필요한 리포지토리 차단, 사설 저장소 우선
  - [ ] 검증 실패 알림을 CI에서 **빌드 실패**로 강제(Gradle Verification)
- **가시성/분석**
  - [ ] Maven: `mvn dependency:tree -Dverbose`
  - [ ] Gradle: `dependencies`, `dependencyInsight`
- **버전 정책**
  - [ ] **동적 버전(1.+)** 은 개발 단계에서만, 릴리스는 잠금/고정
  - [ ] 장기 유지: BOM 업데이트 주기화(Spring Boot 3.5.x 등)

---

## 10. 예제 묶음

### 10.1 Maven + Spring Boot (BOM + 프로파일)
```xml
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId><artifactId>demo</artifactId><version>1.0.0</version>
  <properties>
    <java.version>17</java.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>3.5.7</version>
        <type>pom</type><scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>
</project>
```

### 10.2 Gradle + Spring Boot (platform + catalogs + locking)
`gradle/libs.versions.toml`:
```toml
[versions]
boot = "3.5.7"
junit = "5.10.2"

[libraries]
boot-bom = { module = "org.springframework.boot:spring-boot-dependencies", version.ref = "boot" }
spring-web = { module = "org.springframework.boot:spring-boot-starter-web" }
junit-bom = { module = "org.junit:junit-bom", version.ref = "junit" }
junit-jupiter = { module = "org.junit.jupiter:junit-jupiter" }
```

`build.gradle.kts`:
```kotlin
plugins { java }

repositories { mavenCentral() }

dependencies {
    implementation(platform(libs.boot.bom))
    implementation(libs.spring.web)

    testImplementation(platform(libs.junit.bom))
    testImplementation(libs.junit.jupiter)
}

tasks.test { useJUnitPlatform() }

// 재현성 강화
// settings.gradle.kts 에서:
// dependencyLocking { lockAllConfigurations() }
// 최초: ./gradlew dependencies --write-locks
```
> platform과 catalogs를 조합하면 **버전은 TOML로, 정렬은 BOM으로**, 실제 선언에서는 **버전 생략**이 가능하다.

---

## 11. FAQ — 자주 묻는 문제

**Q1. “의존성 그래프가 PC마다 달라요.”**
A1. Gradle이면 **Locking**을, Maven이면 **고정 버전 + 내부 미러**를 사용한다. 동적/범위 버전은 릴리스에서 금지.

**Q2. “보안 이슈가 걱정돼요.”**
A2. Gradle의 **Dependency Verification**으로 **체크섬/키서명** 검증을 CI에 강제한다. Maven도 사설 저장소에서 검증/승인 절차를 거친 아티팩트만 허용한다.

**Q3. “Gradle에서 BOM과 constraints 차이는?”**
A3. BOM(platform)은 **여러 모듈의 버전을 한 번에 정렬**, constraints는 **특정 모듈 버전 상한/고정**을 부과한다(두 기능을 병행 가능).

**Q4. “Maven 충돌 규칙이 헷갈립니다.”**
A4. Maven은 **Nearest wins**. 필요하다면 `dependencyManagement`에 **원하는 버전**을 명시해 모든 하위 모듈에 강제한다.

---

## 12. 마무리

- **현대 표준**: Maven은 **BOM + dependencyManagement**, Gradle은 **platform(BOM) + version catalogs + locking + verification**.
- **운영 필수**: 충돌 규칙 이해(Nearest vs Highest), **재현성/보안**을 위한 잠금·검증을 **CI 파이프라인**에 통합한다.
- **업데이트 기준**(2025-11): **JDK 25**, **Gradle 9.2**, **Maven 3.9.10**, **Spring Boot 3.5.x** 를 기준으로 예시를 제시했다. 세부 버전은 릴리스 노트를 수시로 확인하라.
