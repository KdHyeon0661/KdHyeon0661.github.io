---
layout: post
title: Java - 의존성 관리
date: 2025-08-13 15:20:23 +0900
category: Java
---
# 의존성 관리 (Dependency Management)

Java 프로젝트에서는 **외부 라이브러리**와 **모듈**을 효율적으로 관리하기 위해 **의존성 관리 시스템**을 사용합니다.  
의존성 관리는 프로젝트에서 사용하는 모든 외부 라이브러리의 **다운로드, 버전 관리, 충돌 해결** 등을 자동화하여 개발 생산성을 높입니다.

---

## 1. 의존성 관리의 필요성
- **재사용성**: 외부 라이브러리를 쉽게 가져와 재사용 가능.
- **일관성**: 팀원들이 동일한 버전의 라이브러리를 사용하도록 보장.
- **자동화**: 라이브러리 다운로드 및 업데이트 과정 자동화.
- **충돌 해결**: 동일한 라이브러리의 서로 다른 버전 간 충돌 방지.

---

## 2. 의존성 관리 도구

### 2.1 Maven
- `pom.xml` 파일에 의존성을 선언.
- Maven Central Repository에서 자동 다운로드.
- 버전, 범위(scope), 전이(Transitive) 의존성 관리 기능 제공.
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <version>3.3.0</version>
    </dependency>
</dependencies>
```

---

### 2.2 Gradle
- `build.gradle`(Groovy) 또는 `build.gradle.kts`(Kotlin DSL) 파일에 선언.
- Maven Central, JCenter 등 다양한 저장소 사용 가능.
- 증분 빌드 및 캐시를 통한 빠른 빌드 지원.
```kotlin
dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.0")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
}
```

---

## 3. 의존성 범위(Scope) / 구성(Configuration)

### Maven Scope
| Scope | 의미 | 사용 예시 |
|-------|------|----------|
| `compile` | 기본 범위, 모든 단계에서 사용 | 로깅 라이브러리 |
| `provided` | 런타임에 제공됨(서버가 제공) | 서블릿 API |
| `runtime` | 컴파일 시 불필요, 실행 시 필요 | JDBC 드라이버 |
| `test` | 테스트 코드에서만 사용 | JUnit |
| `system` | 로컬 경로에서 직접 참조 | 특정 jar 파일 |

### Gradle Configuration
| Configuration | 의미 | 사용 예시 |
|---------------|------|----------|
| `implementation` | 내부에서만 사용하는 라이브러리 | 내부 유틸 클래스 |
| `api` | 외부에도 노출되는 라이브러리 | 공용 모듈 |
| `compileOnly` | 컴파일 시만 필요 | 애너테이션 프로세서 |
| `runtimeOnly` | 실행 시만 필요 | JDBC 드라이버 |
| `testImplementation` | 테스트 코드 전용 | JUnit |

---

## 4. 전이(Transitive) 의존성
- 라이브러리가 다른 라이브러리를 참조하는 경우, 이를 **전이 의존성**이라 함.
- 예: Spring Boot → Spring Core → Commons Logging
- **Maven & Gradle** 모두 전이 의존성 자동 처리 기능 제공.
- 필요 시 특정 의존성을 제외 가능.
```xml
<dependency>
    <groupId>org.example</groupId>
    <artifactId>lib-a</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.unwanted</groupId>
            <artifactId>lib-b</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```
```kotlin
dependencies {
    implementation("org.example:lib-a:1.0") {
        exclude(group = "org.unwanted", module = "lib-b")
    }
}
```

---

## 5. 버전 충돌 해결
- **Maven**: "Nearest-Wins" 전략 (더 가까운 의존성 버전을 사용)
- **Gradle**: 기본적으로 최신 버전 선택, `resolutionStrategy`로 변경 가능
```kotlin
configurations.all {
    resolutionStrategy {
        force("org.example:lib-a:1.2.0")
    }
}
```

---

## 6. BOM (Bill of Materials) 사용
- 여러 라이브러리의 버전을 일괄적으로 관리.
- 특히 Spring Boot 프로젝트에서 자주 사용.
```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>3.3.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

---

## 7. 요약
- **Maven, Gradle** 모두 의존성 관리에 강력한 기능 제공.
- 전이 의존성, 버전 충돌 해결, BOM 등을 활용하면 안정적이고 일관된 빌드 가능.
- 프로젝트 규모와 팀 환경에 맞는 도구 선택이 중요.