---
layout: post
title: Docker - exec vs attach
date: 2025-01-28 20:20:23 +0900
category: Docker
---
# Docker 네트워크 심화: macvlan↔host 연결(올바른 방법), Overlay+Consul 서비스 디스커버리, Compose 연계, 보안·운영 팁

## 빠른 개념 정리

- **macvlan**: 컨테이너에 **고유 MAC/IP**를 부여해 물리망(L2)에 바로 붙입니다. 외부 장비에서 컨테이너를 **실제 호스트처럼** 보게 할 때 유리합니다.
- **기본 제약**: 동일 parent NIC에서 **호스트 ↔ macvlan 컨테이너 직접 통신이 불가**합니다(커널 레벨 정책).
- **overlay**: 여러 호스트에 걸친 가상망(VXLAN). Swarm 필요. 암호화 가능. attachable로 일반 컨테이너도 참가 가능.
- **Consul**: 서비스 디스커버리(+K/V, 헬스체크, DNS). overlay 환경에서 **이름 기반 통신**을 Swarm 외에도 구현하는 데 유용합니다.

---

## macvlan + host 통신, 정확한 해법

### 흔한 오해 바로잡기

- `docker network create -d macvlan -o macvlan_mode=bridge ...` 라고 해도, **동일 parent NIC**(예: `eth0`) 위에서 **호스트 ↔ macvlan 컨테이너 간** 직접 통신은 **여전히 되지 않습니다**.
  이는 macvlan의 **설계적 특성**(호스트의 상위 인터페이스와 macvlan 하위 인터페이스 간 프레임 전달 미허용) 때문입니다.

> 핵심: **macvlan bridge 모드**는 macvlan 인터페이스들 **끼리의 통신**을 허용하는 모드입니다. **호스트 인터페이스 자신과의 통신**을 허용하진 않습니다.

따라서, 호스트와 macvlan 사이를 잇기 위해선 **호스트 측에도 macvlan 인터페이스**(예: `macvlan0`)를 만들어 **같은 서브넷**에 붙이고 그 인터페이스를 통해 통신하게 해야 합니다.

### 올바른 구성 절차(리눅스 호스트)

1) **macvlan 네트워크 생성**
```bash
docker network create -d macvlan \
  --subnet=192.168.1.0/24 \
  --gateway=192.168.1.1 \
  -o parent=eth0 \
  lan-macvlan
```

2) **컨테이너 기동(정적 IP 부여)**
```bash
docker run -d --name ext-nginx \
  --network lan-macvlan \
  --ip 192.168.1.100 \
  nginx:alpine
```

3) **호스트에도 macvlan 인터페이스 생성**
   (호스트와 macvlan이 **동일 서브넷**에서 L2로 만나게 함)
```bash
# 호스트에서 실행(root 필요)

ip link add macvlan0 link eth0 type macvlan mode bridge
ip addr add 192.168.1.240/24 dev macvlan0
ip link set macvlan0 up
```

4) **통신 확인**
```bash
# 호스트 -> 컨테이너

ping -c 1 192.168.1.100

# 컨테이너 -> 호스트

docker exec -it ext-nginx sh -c "ping -c 1 192.168.1.240"
```

이제 호스트와 macvlan 컨테이너가 **서로 통신**됩니다. 외부 클라이언트는 `192.168.1.100:80`으로 직접 접근합니다.

### DHCP 충돌/중복 IP 예방, VLAN 분리 선택지

- DHCP의 동적 대역과 **정적 macvlan IP 대역을 분리**하세요.
- L2 혼잡/분리를 원하면 `eth0.30` 같은 **VLAN 서브인터페이스**를 parent로 사용:
```bash
# 호스트

ip link add link eth0 name eth0.30 type vlan id 30
ip link set eth0.30 up

# 도커 macvlan

docker network create -d macvlan \
  --subnet=192.168.30.0/24 --gateway=192.168.30.1 \
  -o parent=eth0.30 lan-mv-30
```
- 이렇게 두면, 호스트 기본망(eth0)과 macvlan망(eth0.30)이 **L3 라우팅**으로 만납니다(라우터/레이어3 스위치 경유).

### Compose로 붙이기(외부 macvlan 참조 권장)

macvlan 네트워크는 **외부에서 먼저 생성** 후 Compose에서 참조하는 패턴이 안정적입니다.

```yaml
version: "3.9"
services:
  camera:
    image: nginx:alpine
    networks:
      lan:
        ipv4_address: 192.168.1.60

networks:
  lan:
    external: true
```

외부 생성:
```bash
docker network create -d macvlan \
  --subnet=192.168.1.0/24 --gateway=192.168.1.1 \
  -o parent=eth0 lan
```

### 운영 팁

- **MTU**: macvlan은 캡슐화가 없어 대개 물리망 MTU와 동일.
- **프라미스큐어스 모드**: 일부 NIC/스위치 환경에서 필요할 수 있음(대개 불필요).
- **감사/보안**: macvlan 컨테이너는 **LAN 상 실체 IP**이므로, 방화벽·IDS·DHCP·NAC 정책 대상에 포함하세요.
- **Docker Desktop(Mac/Windows)**: macvlan은 리눅스 커널 기능에 의존, Desktop 환경은 제약이 큼(프로덕션은 Linux 호스트 권장).

---

## Overlay + Consul: Swarm 밖에서도 이름 기반 통신

### 배경

- Docker overlay는 **Swarm 모드**가 필요합니다(멀티 호스트 VXLAN).
- Swarm의 내장 DNS만으로도 서비스 이름 해석이 되지만, **Swarm 외 시나리오**(단순 Docker+overlay-like 네트워킹, 혹은 쿠버네티스 외 환경) 또는 **크로스 플랫폼/도메인 서비스 라우팅**이 필요하다면 **Consul** 같은 **외부 서비스 디스커버리**가 유용합니다.

### Consul 핵심

- DNS 인터페이스: `*.service.consul` 도메인으로 서비스 조회
- 헬스체크: 응답 불능 인스턴스 제외
- K/V: 환경·구성 저장
- Connect(+Envoy): Zero-trust 스타일 mTLS/인증

### Overlay 네트워크 생성(Swarm)

```bash
# Swarm 활성화

docker swarm init

# attachable overlay

docker network create -d overlay --attachable appnet
```

`--attachable`을 주면 서비스뿐 아니라 **일반 컨테이너**도 붙일 수 있습니다.

### Consul + 앱 구성 예(Compose 두 파일로 분리)

> 목적: Consul을 **서비스 디스커버리 DNS**로 두고, 앱 컨테이너들이 **Consul에 등록**하여 이름으로 서로 찾게 합니다.
> 네트워크는 Swarm overlay(`appnet`)를 사용하거나, 단일 호스트면 bridge로 대체도 가능(단, 멀티 호스트라면 overlay 권장).

#### Consul 스택(또는 Compose)

```yaml
# consul.yml

version: "3.9"
services:
  consul:
    image: hashicorp/consul:1.18
    command: agent -server -bootstrap -ui -client=0.0.0.0 -bind=0.0.0.0
    ports:
      - "8500:8500"        # Web UI/API
      - "8600:8600/udp"    # DNS
    networks:
      - appnet

networks:
  appnet:
    external: true
```

배포(스웜 스택 예):
```bash
docker stack deploy -c consul.yml infr
```

웹 UI: `http://<노드IP>:8500`

#### 앱 스택(등록 방식 선택지 포함)

앱 컨테이너가 Consul에 **자동 등록**되게 하려면 방법이 여러 가지입니다.

- **registrator**(gliderlabs): Docker 이벤트를 듣고 컨테이너를 Consul에 등록/해제.
- **Sidecar(Consul agent)**: 각 서비스 옆에 에이전트를 두고 local 등록.
- **애플리케이션 자체 등록**: 부트업시 Consul HTTP API로 등록.

아래는 **registrator** 사용 예입니다.

```yaml
# app.yml

version: "3.9"
services:
  registrator:
    image: gliderlabs/registrator:latest
    command: -internal consul://consul:8500
    volumes:
      - /var/run/docker.sock:/tmp/docker.sock
    networks: [appnet]
    depends_on: [consul]

  web:
    image: nginx:alpine
    networks: [appnet]
    environment:
      - SERVICE_NAME=web
      - SERVICE_TAGS=urlprefix-/   # (fabio/traefik 등과 연계 시 유용)
    deploy:
      replicas: 2

  api:
    image: hashicorp/http-echo
    command: -text="hello api"
    networks: [appnet]
    environment:
      - SERVICE_NAME=api
    deploy:
      replicas: 2

networks:
  appnet:
    external: true
```

배포:
```bash
docker stack deploy -c app.yml apps
```

등록 확인(컨테이너 내부 혹은 임시 도구 컨테이너에서):
```bash
# Consul DNS를 직접 질의
# 노드에서:

dig @127.0.0.1 -p 8600 web.service.consul
dig @127.0.0.1 -p 8600 api.service.consul

# 같은 네트워크 컨테이너에서:

apk add --no-cache bind-tools
dig web.service.consul
```

> 시스템 전역에서 Consul DNS를 사용하려면 `/etc/resolv.conf` 또는 DNS 포워더 설정에 Consul(8600/udp)을 추가하세요.

### Swarm 없이 Consul만? (단일 호스트/bridge)

- 단일 호스트에서 **bridge 네트워크**로도 Consul DNS 기반 디스커버리가 가능합니다.
- 다만 멀티 호스트 간 오버레이(터널) 없이 **서로 다른 호스트**의 컨테이너를 이름으로 찾으려면, **호스트 레벨 라우팅/VPN/Consul WAN** 등 **다른 네트워킹 계층**을 설계해야 합니다.

### Consul Connect(선택)

mTLS 및 L4/L7 필터링이 필요하면 Consul Connect(+Envoy)를 사용하세요. 서비스 간 **정체성 기반** 통신 정책 수립이 가능합니다(초심자에겐 운영 복잡도가 높을 수 있음).

---

## 보안·성능·운영 체크리스트

### 보안

- macvlan은 컨테이너가 **LAN 상 실체 IP**가 됩니다. 방화벽·ACL·NAC 정책에 반영하세요.
- overlay는 **`--opt encrypted`** 로 데이터플레인 암호화 가능. 매니저 노드 보안(키 유출 방지)은 필수.
- 컨테이너 내 권한 최소화: `user`, `read_only`, `cap_drop: [ALL]`, `no-new-privileges`, `tmpfs` 사용.
- Consul 보안: **ACL 활성화**, **gossip/HTTP TLS**, UI/API 접근 제어. 운영망 외부 노출 금지.

### 성능

- 대략적 경향: **host > macvlan/bridge > overlay**
- overlay는 VXLAN 오버헤드로 지연이 증가할 수 있습니다.
- 유효 MTU 근사(오버레이):
  $$
  MTU_{\text{effective}} \approx MTU_{\text{underlay}} - 50
  $$
  1500 MTU라면 약 1450. 대용량 UDP/ICMP는 단편화 가능. 필요 시 **앱/OS MTU 조정**.

### 관측·운영

- 네이밍/해결: 도커 내장 DNS(127.0.0.11)와 Consul DNS 충돌 없이 설계.
- 진단 도구 컨테이너: `nicolaka/netshoot` 추천(파편화/MTU/경로 확인).
- 로그/이벤트: `docker events`, `docker logs`, Consul health 상태판(UI/8500).

---

## 트러블슈팅 루틴

| 증상 | 원인 후보 | 해결 절차 |
|------|-----------|-----------|
| 호스트↔macvlan 통신 불가 | macvlan 설계 특성 | 호스트에 **macvlan0** 생성(같은 서브넷), 또는 VLAN 분리 후 라우팅 |
| 외부에서 macvlan 응답 없음 | IP 충돌, 스위치 포트 정책 | DHCP 범위/정적 IP 재검토, `arp -a`, `ip neigh`, 스위치 포트 보안 확인 |
| overlay 지연/패킷 유실 | MTU/단편화 | `ping -M do -s <size>`, 앱/OS MTU 1450± 조정, 경로 MTU 탐지 |
| Consul 이름해결 불가 | DNS 설정 누락 | 컨테이너/호스트의 resolver가 Consul(8600/udp)를 질의하도록 설정 |
| registrator 미등록 | 라벨/환경변수 누락 | `SERVICE_NAME`, 포트 노출 여부, registrator 로그(`docker service logs`) 점검 |
| 포트 충돌/노출 과다 | 잘못된 publish | Swarm ingress vs host 모드 선택, 최소 포트만 공개 |

**도움되는 명령**
```bash
# 네트워크 상태

docker network ls
docker network inspect <net>

# 이름해결

getent hosts web
dig @127.0.0.1 -p 8600 web.service.consul

# 경로/MTU

ip route
ip link show
ping -c 1 -M do -s 1472 <dst>   # 1500 MTU 경로 테스트(헤더 여유 감안)

# 컨테이너 안에서 네트워크 진단

docker run --rm -it --network <net> nicolaka/netshoot sh
```

---

## 실전 예제 모음

### macvlan + host 직통 세트(재현형)

```bash
# macvlan 네트워크

docker network create -d macvlan \
  --subnet=192.168.1.0/24 --gateway=192.168.1.1 \
  -o parent=eth0 lan-macvlan

# 컨테이너

docker run -d --name cam \
  --network lan-macvlan --ip 192.168.1.60 \
  nginx:alpine

# 호스트 측 macvlan0

ip link add macvlan0 link eth0 type macvlan mode bridge
ip addr add 192.168.1.240/24 dev macvlan0
ip link set macvlan0 up

# 통신 확인

ping -c 1 192.168.1.60
docker exec -it cam sh -c "ping -c 1 192.168.1.240"
```

### Overlay + Consul + Registrator(스웜)

```bash
docker swarm init
docker network create -d overlay --attachable appnet

# consul.yml

cat > consul.yml <<'YAML'
version: "3.9"
services:
  consul:
    image: hashicorp/consul:1.18
    command: agent -server -bootstrap -ui -client=0.0.0.0 -bind=0.0.0.0
    ports: ["8500:8500","8600:8600/udp"]
    networks: [appnet]
networks:
  appnet:
    external: true
YAML

docker stack deploy -c consul.yml infr

# app.yml

cat > app.yml <<'YAML'
version: "3.9"
services:
  registrator:
    image: gliderlabs/registrator:latest
    command: -internal consul://consul:8500
    volumes:
      - /var/run/docker.sock:/tmp/docker.sock
    networks: [appnet]
    depends_on: [consul]

  web:
    image: nginx:alpine
    networks: [appnet]
    environment:
      - SERVICE_NAME=web
    deploy: { replicas: 2 }

  api:
    image: hashicorp/http-echo
    command: -text="hello api"
    networks: [appnet]
    environment:
      - SERVICE_NAME=api
    deploy: { replicas: 2 }
networks:
  appnet:
    external: true
YAML

docker stack deploy -c app.yml apps
```

질의:
```bash
# 노드에서

dig @127.0.0.1 -p 8600 web.service.consul
dig @127.0.0.1 -p 8600 api.service.consul
```

---

## 수학적 직감(간단 MTU 근사)

VXLAN 오버헤드로 유효 MTU가 줄어들면, 단편화가 발생해 지연/손실이 커질 수 있습니다. 근사:

$$
MTU_{\text{effective}} \approx MTU_{\text{underlay}} - 50
$$

- 예: 언더레이 1500 → 유효 약 1450
- 애플리케이션/OS에서 MTU 1450으로 낮추면 단편화를 완화할 수 있습니다.

---

## 요약 표

| 주제 | 핵심 | 권장 해법 |
|------|------|-----------|
| macvlan↔host 통신 | 기본적으로 불가 | **호스트 macvlan 인터페이스 추가**(같은 서브넷) 또는 VLAN 분리 후 L3 라우팅 |
| macvlan 운영 | 외부에서 실체 IP로 접근 | 정적 IP 대역 분리, DHCP 충돌 방지, 보안정책 반영 |
| overlay 멀티호스트 | VXLAN 기반 가상망 | Swarm init, attachable overlay, 필요 시 `--opt encrypted` |
| 서비스 디스커버리 | 이름 기반 연결 | Consul(등록: registrator/sidecar/앱 API), DNS 8600/udp 사용 |
| 성능/MTU | 오버레이 오버헤드 | MTU 튜닝, host publish, 경로 MTU 확인 |

---

## 참고 명령·파일 정리

```bash
# 네트워크 확인/점검

docker network ls
docker network inspect <net>

# 스웜/스택

docker swarm init
docker stack deploy -c <file.yml> <name>
docker stack services <name>
docker stack ps <name>

# Consul DNS 질의

dig @<consul-ip> -p 8600 web.service.consul

# MTU 테스트(1500 경로 가정)

ping -M do -s 1472 <dst>
```

---

## 마무리

- **macvlan**: 외부에서 컨테이너를 장비처럼 보여야 할 때 최적. 단, **호스트와의 통신은 별도 macvlan 인터페이스**로 연결하는 것이 정석입니다.
- **overlay + Consul**: 멀티 호스트에서 Swarm DNS를 넘어, **유연한 이름 기반 디스커버리**가 필요할 때 실전적입니다.
- Compose/Stack 선언으로 **네트워크 경계와 기동 순서(healthcheck)** 를 고정하고, 보안·성능 가이드를 따라 운영 안정성을 확보하십시오.
