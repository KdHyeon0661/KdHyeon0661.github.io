---
layout: post
title: 알고리즘 - 덱 관련 문제
date: 2025-01-10 19:20:23 +0900
category: 알고리즘
---
# 덱(Deque)을 활용한 알고리즘 문제

## 덱 기본기 리마인드

- **정의**: Double-Ended Queue. 양쪽 끝에서 삽입/삭제가 가능한 선형 자료구조.
- **파이썬 구현 권장**: `collections.deque` — 양쪽 끝 연산이 평균 \(O(1)\). `list.pop(0)`은 \(O(n)\)이라 불가.
- **핵심 연산**
  - `append(x)`, `appendleft(x)`
  - `pop()`, `popleft()`
  - `rotate(k)` — 우측으로 \(k\)칸 회전(음수면 좌측)
  - `clear()`, `extend`, `extendleft`(역순 주의)
- **시간복잡도**: 덱의 양끝 삽입/삭제 \(O(1)\), 임의 위치 접근 `dq[i]`는 \(O(1)\) **아님**(CPython에서는 평균 \(O(1)\)처럼 보일 수 있으나 보장 대상 아님).

```python
from collections import deque

dq = deque()
dq.append(1)         # 뒤 삽입
dq.appendleft(2)     # 앞 삽입
x = dq.pop()         # 뒤 삭제 -> 1
y = dq.popleft()     # 앞 삭제 -> 2
```

---

## 대표 문제 ① — 덱 구현 (BOJ 10866)

### 문제 요약

표준 입력으로 주어지는 명령들을 덱에 수행하고 결과를 출력.

### 핵심 포인트 보강

- 비어 있을 때의 `pop_front/pop_back/front/back`은 `-1`.
- 문자열 파싱과 I/O 병목을 줄이기 위해 `sys.stdin.readline`과 결과 버퍼링을 사용.

```python
import sys
from collections import deque
input = sys.stdin.readline

n = int(input())
dq = deque()
out = []

for _ in range(n):
    cmd = input().split()
    op = cmd[0]
    if op == 'push_front':
        dq.appendleft(cmd[1])
    elif op == 'push_back':
        dq.append(cmd[1])
    elif op == 'pop_front':
        out.append(dq.popleft() if dq else '-1')
    elif op == 'pop_back':
        out.append(dq.pop() if dq else '-1')
    elif op == 'size':
        out.append(str(len(dq)))
    elif op == 'empty':
        out.append('0' if dq else '1')
    elif op == 'front':
        out.append(dq[0] if dq else '-1')
    elif op == 'back':
        out.append(dq[-1] if dq else '-1')

sys.stdout.write('\n'.join(out))
```

- 복잡도: 각 연산 \(O(1)\). 총 \(O(n)\).

---

## 대표 문제 ② — 회전하는 큐 (BOJ 1021)

### 문제 요약

초기 덱 `[1..N]`에서 목표 원소들을 순서대로 꺼내되, 매번 최소 회전 횟수로 꺼낸다. 허용 연산: 좌/우 회전 1칸 또는 꺼내기.

### 핵심 아이디어 보강

- 현재 목표 위치 `idx = dq.index(t)`.
- `idx <= len(dq)//2`라면 좌회전이 유리, 아니면 우회전.
- `rotate`를 사용하면 코드가 간결하고 빠르다.

```python
from collections import deque
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
targets = list(map(int, input().split()))

dq = deque(range(1, n+1))
moves = 0

for t in targets:
    idx = dq.index(t)
    if idx <= len(dq)//2:
        dq.rotate(-idx)      # 좌로 idx
        moves += idx
    else:
        r = len(dq) - idx
        dq.rotate(r)         # 우로 r
        moves += r
    dq.popleft()             # 현재 맨 앞의 t를 꺼냄

print(moves)
```

- 복잡도: 각 타깃에 대해 인덱스 탐색 \(O(k)\) + 회전/팝 \(O(1)\). 전체 \(O(nm)\)로 보일 수 있으나 `index`는 덱 길이에 선형. 입력 한도에서 통과.

---

## 대표 문제 ③ — AC (BOJ 5430)

### 문제 요약

문자열 명령 `R`(뒤집기), `D`(맨 앞 삭제)를 배열에 적용. 빈 배열에 `D` → `error`.

### 핵심 아이디어 보강

- 실제로 뒤집지 않고 `rev` 플래그로 방향성만 토글.
- 삭제는 `rev`에 따라 `popleft` 또는 `pop`.
- 입력 배열 파싱: `[]` 처리, 숫자 사이 공백 없음에 유의.

```python
import sys
from collections import deque
input = sys.stdin.readline

t = int(input())
out = []
for _ in range(t):
    p = input().strip()
    n = int(input())
    s = input().strip()
    if n == 0:
        dq = deque()
    else:
        arr = s[1:-1].split(',')
        dq = deque(arr)
    rev = False
    err = False

    for ch in p:
        if ch == 'R':
            rev = not rev
        else:  # D
            if dq:
                if rev:
                    dq.pop()
                else:
                    dq.popleft()
            else:
                err = True
                break

    if err:
        out.append("error")
    else:
        if rev:
            dq.reverse()
        out.append('[' + ','.join(dq) + ']')

sys.stdout.write('\n'.join(out))
```

- 복잡도: 각 원소는 최대 한 번 삭제 → \(O(n + |p|)\).

---

## 대표 문제 ④ — 슬라이딩 윈도우 최솟값 (BOJ 11003)

### 문제 요약

수열 \(A\)와 창 크기 \(L\)이 주어질 때, 각 위치 \(i\)에서 구간 \([i-L+1, i]\)의 최소값을 출력.

### 모노토닉 덱 설계

- 덱에는 **인덱스**를 저장하되 값이 **단조 증가**되도록 유지.
- 새 원소 \(A[i]\)보다 **크거나 같은** 값의 인덱스를 뒤에서 제거.
- 윈도우 바깥 인덱스(≤ \(i-L\))는 앞에서 제거.

```python
import sys
from collections import deque
input = sys.stdin.readline

n, L = map(int, input().split())
A = list(map(int, input().split()))
dq = deque()
out = []

for i, x in enumerate(A):
    while dq and A[dq[-1]] >= x:
        dq.pop()
    dq.append(i)
    if dq[0] <= i - L:
        dq.popleft()
    out.append(str(A[dq[0]]))

sys.stdout.write(' '.join(out))
```

- 각 인덱스는 덱에 **최대 1회 삽입·삭제** → 총 \(O(n)\).

---

## 덱 확장: 모노토닉 최대/최소 클래스화

다양한 문제에서 재사용 가능한 패턴으로 추상화.

```python
from collections import deque

class MonotoneDequeMin:
    def __init__(self):
        self.dq = deque()   # (value, index)
    def push(self, val, idx):
        while self.dq and self.dq[-1][0] >= val:
            self.dq.pop()
        self.dq.append((val, idx))
    def pop_until(self, left_idx):
        while self.dq and self.dq[0][1] < left_idx:
            self.dq.popleft()
    def min(self):
        return self.dq[0][0]

class MonotoneDequeMax:
    def __init__(self):
        self.dq = deque()
    def push(self, val, idx):
        while self.dq and self.dq[-1][0] <= val:
            self.dq.pop()
        self.dq.append((val, idx))
    def pop_until(self, left_idx):
        while self.dq and self.dq[0][1] < left_idx:
            self.dq.popleft()
    def max(self):
        return self.dq[0][0]
```

---

## 덱 기반 최단경로: 0-1 BFS

가중치가 0 또는 1인 그래프의 최단경로는 **덱**으로 Dijkstra보다 간단히 처리한다.

- 간선 가중치가 0이면 `appendleft`, 1이면 `append`.
- 항상 덱 앞에서 꺼내 처리하면 거리의 비내림 순으로 확장.

```python
from collections import deque

def zero_one_bfs(adj, s):
    # adj[u] = [(v, w)] with w in {0,1}
    n = len(adj)
    INF = 10**18
    dist = [INF]*n
    dist[s] = 0
    dq = deque([s])
    while dq:
        u = dq.popleft()
        du = dist[u]
        for v, w in adj[u]:
            nd = du + w
            if nd < dist[v]:
                dist[v] = nd
                if w == 0:
                    dq.appendleft(v)
                else:
                    dq.append(v)
    return dist
```

- 복잡도: 각 간선이 상수번 덱 연산 → \(O(V+E)\).

---

## 시뮬레이션에서의 덱: 뱀, 에디터, 카드 게임

### 뱀(예: BOJ 3190 풍의 구현 스케치)

- 뱀의 몸통 위치를 덱으로 관리. 머리를 `appendleft`, 꼬리를 `pop`.
- 사과를 먹지 않으면 꼬리를 뺀다. 방향 전환은 큐로 명령 스케줄링.

```python
from collections import deque

def snake_sim(board, commands):
    # board: 0 빈칸, 1 사과
    # commands: dict[time] = 'L' or 'D'
    N = len(board)
    snake = deque([(0,0)])  # head at left
    dir_idx = 0
    dirs = [(0,1),(1,0),(0,-1),(-1,0)]
    t = 0
    r = c = 0
    board[0][0] = -1  # snake body

    while True:
        t += 1
        dr, dc = dirs[dir_idx]
        nr, nc = r+dr, c+dc
        if not (0 <= nr < N and 0 <= nc < N):  # wall
            return t
        if board[nr][nc] == -1:                # hit itself
            return t

        snake.appendleft((nr, nc))
        if board[nr][nc] == 1:                 # apple
            board[nr][nc] = -1
        else:
            board[nr][nc] = -1
            tr, tc = snake.pop()
            board[tr][tc] = 0

        if t in commands:
            turn = commands[t]
            if turn == 'L': dir_idx = (dir_idx - 1) % 4
            else:           dir_idx = (dir_idx + 1) % 4

        r, c = nr, nc
```

### 에디터(좌/우 스택이 정석이지만 덱으로도 가능)

- 커서 왼쪽을 덱 L, 오른쪽을 덱 R로 두고, 이동 시 원소를 옮긴다.
- 덱 대신 리스트 두 개를 쓰는 것이 일반적이지만, 덱으로도 시뮬 가능.

---

## 회전 전략과 비용 분석

- `deque.rotate(k)`의 개념적 비용은 덱 길이에 독립적이지만, 내부적으로 원형 버퍼 포인터 이동이라 매우 빠르다.
- 반면 `dq.index(x)`는 선형 탐색이다.
  따라서 1021류 문제에서 **회전 횟수 계산은 `index` 한 번**, 실제 회전은 `rotate`로 최소화.

---

## 증명 스케치: 모노토닉 덱의 \(O(n)\)성

각 인덱스 \(i\)는 덱에 **한 번 들어가고**, 새 원소가 들어올 때 자신보다 더 작거나 같으면 **한 번 밀려난다**.
따라서 전체 팝 횟수는 최대 \(n\), 푸시도 \(n\).
즉,
$$
\sum_{i=1}^{n} (\text{push}_i + \text{pop}_i) \le 2n \Rightarrow O(n).
$$

---

## 경계·디버깅 체크리스트

1) 10866: 비어 있을 때 출력 값과 줄바꿈, 문자열 vs 정수 혼용 주의.
2) 1021: 중앙값 처리(`<=` vs `<`), `rotate` 방향 부호.
3) 5430: 빈 배열 `[]` 처리, `reverse()` 최종 1회만, 큰 입력에서 I/O 버퍼링.
4) 11003: 비교 부등식 방향(최솟값은 `>=` 제거), 윈도우 이탈 조건 `<= i-L`.
5) 0-1 BFS: 간선 가중치가 0/1 이외가 섞이면 오답.
6) 파이썬 I/O: `input()` 대신 `sys.stdin.readline`, 출력은 누적 후 한 번에.

---

## 대형 입력 대응 템플릿 모음

### 빠른 입력/출력 래퍼

```python
import sys
from collections import deque
input = sys.stdin.readline

def readints(): return map(int, input().split())
def readlist(): return list(map(int, input().split()))

buf = []
def flush():
    sys.stdout.write(''.join(buf))
    buf.clear()
```

### 덱 회전/비용 유틸

```python
from collections import deque

def rotate_to_front(dq, value):
    idx = dq.index(value)
    if idx <= len(dq)//2:
        dq.rotate(-idx)
        return idx
    else:
        r = len(dq)-idx
        dq.rotate(r)
        return r
```

---

## 추가 연습 문제 아이디어(덱 전형)

- **슬라이딩 윈도우 최댓값**: 11003을 최대값 버전으로.
- **같은 수가 K번 연속 등장하면 제거**: 덱에 (값, 연속카운트)로 누적.
- **창 내 중간값**: 덱만으로는 까다롭고, 보통 두 힙(또는 `bisect`+리스트) 사용.
- **문자열 폭발**: 스택 전형이지만 양방향 삭제가 필요하면 덱+보조 스택.

---

## 수학적 요약

- 모노토닉 덱 총 연산 수:
  $$
  O(n)
  $$
- 0-1 BFS:
  $$
  O(V+E)
  $$

---

## 마무리 — 선택 판단표

| 문제 유형 | 해법/구조 | 선택 이유 |
|---|---|---|
| 좌/우 회전 최소화 | `deque.rotate` + 인덱스 비교 | 연산을 덱 연산으로 캡슐화 |
| 파서(뒤집기/양끝 삭제) | `rev` 플래그 + 덱 | 실제 뒤집기 비용 제거 |
| 슬윈 최솟/최댓값 | 모노토닉 덱 | 각 인덱스 1회 입출로 \(O(n)\) |
| 0/1 가중 최단경로 | 0-1 BFS(덱) | 다익스트라보다 간단/빠름 |
| 몸체가 줄기/늘기 | 시뮬 덱(머리/꼬리) | 자연스럽고 코드가 명료 |

---

## 부록 A. 대표 코드 스니펫 한눈에 보기

### A.1 슬윈 최댓값

```python
from collections import deque

def sliding_window_max(a, k):
    dq = deque()
    out = []
    for i, x in enumerate(a):
        while dq and a[dq[-1]] <= x:
            dq.pop()
        dq.append(i)
        if dq[0] <= i-k:
            dq.popleft()
        if i >= k-1:
            out.append(a[dq[0]])
    return out
```

### A.2 0-1 BFS 최소 비용 도달성

```python
def min_cost_01(adj, s, t):
    dist = zero_one_bfs(adj, s)
    return dist[t]
```

---

# 결론

초안의 4개 대표 문제(10866, 1021, 5430, 11003)를 토대로, **입출력 최적화, 회전 전략, 모노토닉 덱의 정당성, 0-1 BFS, 시뮬레이션 전형**까지 실전에 바로 쓰는 설계·코드·검증 포인트를 추가했다.
이 가이드의 순서대로 구현→테스트→확장을 따라가면, 덱이 필요한 거의 모든 백준형 문제에서 **어떤 연산을 덱에 위임하고, 어떤 상태를 플래그로 보존하며, 어디서 모노토닉 불변식을 유지해야 하는지**를 일관된 원칙으로 결정할 수 있다.
