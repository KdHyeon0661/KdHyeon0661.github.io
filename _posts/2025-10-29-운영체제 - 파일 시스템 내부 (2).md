---
layout: post
title: 운영체제 - 파일 시스템 내부 (2)
date: 2025-10-29 20:25:23 +0900
category: 운영체제
---
# Chapter 15 — File-System Internals (2)

## File Sharing

### “파일 공유”의 의미와 범주

- **단일 호스트 내 공유**: 여러 **프로세스**가 동일 파일 객체(같은 inode)를 동시에 사용.
- **다중 호스트 간 공유**: **원격 파일시스템**(NFS/SMB/9P/virtio-fs 등)을 통해 네트워크 넘어 같은 논리 파일을 접근.
- **복제 기반 공유**: rsync/버전관리/오브젝트 스토리지처럼 *사본*을 전달하여 간접 공유.

공유의 핵심 변수:
1) **이름 공유**(하드/심볼릭 링크), **핸들 공유**(open 후 fd 상속/dup), **데이터/캐시 공유**(페이지 캐시/mmap).
2) **동시성 제어**: advisory/mandatory 락, 레인지 락, oplock/lease, close-to-open.
3) **일관성**: 캐시/쓰기 순서/`fsync` 의미, “원자적 rename” 패턴.
4) **보호**: DAC/ACL/캡 능력치, 네임스페이스, 마운트 옵션(`nodev,nosuid,noexec`).

---

### 단일 호스트에서의 공유: FD, OFT, inode

리눅스 기준 내부 모델(요약):
- **프로세스 테이블** → **FD 테이블**(정수 fd → *file 객체 포인터*).
- **file 객체(열린 파일 객체)**: 오프셋/플래그/연산자. 여러 fd(dup/fork)가 **같은 file 객체**를 가리킬 수 있음.
- **inode**: 파일의 메타데이터/블록 매핑(모든 열린 file이 참조).
- **페이지 캐시**: inode 단위로 데이터 페이지 공유.

#### 예: `fork()` 후 부모·자식의 오프셋 공유

```c
// share_offset.c — 부모/자식이 같은 'file 객체'를 공유 → 오프셋도 공유
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int main(){
  int fd=open("demo.txt",O_CREAT|O_TRUNC|O_RDWR,0644);
  write(fd, "ABCDEFGH", 8); lseek(fd,0,SEEK_SET);
  if(!fork()){
    char b[4]={0}; read(fd,b,3);   // 자식: "ABC"
    printf("child read: %s, off=%ld\n", b, lseek(fd,0,SEEK_CUR));
    _exit(0);
  }
  sleep(1);                        // 자식 먼저 읽도록
  char b[4]={0}; read(fd,b,3);     // 부모는 "DEF" (오프셋 공유 효과)
  printf("parent read: %s, off=%ld\n", b, lseek(fd,0,SEEK_CUR));
  return 0;
}
```

#### 예: `dup()` vs 별도 `open()`

```c
// dup_vs_open.c — dup는 같은 file 객체 공유, open은 별개
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int main(){
  int fd=open("demo.txt",O_RDONLY);
  int fd2=dup(fd);                 // 같은 file 객체
  int fd3=open("demo.txt",O_RDONLY); // 다른 file 객체
  char b1[3]={0}, b2[3]={0};
  read(fd,b1,2);   // off=2
  read(fd2,b2,2);  // off=4 (같은 객체 공유)
  printf("dup pair: %s%s (off=%ld)\n", b1,b2,lseek(fd,0,SEEK_CUR));
  printf("open sep off3=%ld\n", lseek(fd3,0,SEEK_CUR)); // 0
  return 0;
}
```

---

### 링크로 공유: 하드 링크 vs 심볼릭 링크

- **하드 링크**: 같은 inode를 다른 이름으로 참조(링크 수 증가). 파일 삭제는 **링크 수 0**이 되고 열린 핸들이 사라질 때 공간 회수.
- **심볼릭 링크**: 텍스트 경로를 저장하는 별도 inode. 대상 삭제 시 **dangling symlink** 가능.

```c
// link_demo.c — 하드링크와 심링크
#include <unistd.h>
#include <sys/stat.h>
#include <stdio.h>

int main(){
  link("a.txt","b.txt");    // 하드 링크
  symlink("a.txt","c.ln");  // 심볼릭 링크
  struct stat st;
  lstat("a.txt",&st);
  printf("a.txt nlink=%lu\n",(unsigned long)st.st_nlink);
  return 0;
}
```

---

### 동시성 제어: advisory/mandatory, 레인지 락, flock

- **`flock(fd, LOCK_EX|LOCK_NB)`**: 파일 단위의 단순 락(어드바이저리).
- **`fcntl(F_SETLK/F_SETLKW)`**: **바이트 범위(레인지) 락**.
- (드물게) **mandatory 락**: 마운트/퍼미션 조합으로 강제 적용되나 호환성 문제로 거의 미사용.

```c
// fcntl_lock_range.c — 레인지 락 (어드바이저리)
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int lock_range(int fd, short type, off_t start, off_t len, int wait){
  struct flock lk={.l_type=type,.l_whence=SEEK_SET,.l_start=start,.l_len=len};
  return fcntl(fd, wait?F_SETLKW:F_SETLK, &lk);
}
int main(){
  int fd=open("counter.bin",O_CREAT|O_RDWR,0644);
  if(lock_range(fd, F_WRLCK, 0, 4, 0)<0){perror("lock"); return 1;}
  // …임계구역…
  lock_range(fd, F_UNLCK, 0, 4, 1);
  return 0;
}
```

> **주의**: advisory 락은 **협조적**. 다른 프로세스가 *무시하고 쓰는 것*을 막지 못한다.

---

### 파일 **lease**(임대)와 알림

리눅스 `fcntl(F_SETLEASE)` 로 **읽기/쓰기 임대**를 설정하면 충돌 접근 시 **시그널**(기본 SIGIO)을 받아 캐시를 정리/닫는 등 처리(주로 데몬/DB 캐시에서).

---

### mmap 기반 공유

동일 파일을 `MAP_SHARED` 로 매핑하면 페이지 캐시를 매개로 **프로세스 간 공유 메모리**처럼 동작.
- 쓰기 후 **`msync(MS_SYNC)`** 또는 파일 닫기/`fsync` 로 내구성 보장.
- 레이스 조건에 주의(별도 락 필요).

```c
// mmap_shared.c
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main(){
  int fd=open("shm.dat",O_CREAT|O_RDWR,0644);
  ftruncate(fd,4096);
  char* p=mmap(NULL,4096,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
  strcpy(p,"hello via mmap"); msync(p,4096,MS_SYNC);
  munmap(p,4096); close(fd);
  return 0;
}
```

---

### 원자적 업데이트 패턴: temp + fsync + rename

- **쓰기**: 임시파일에 전체 쓰기 → `fsync(tmp)` → `rename(tmp, final)`(원자) → `fsync(dir)`(디렉터리 항목 내구성).
- 크래시 후 **부분 쓰기 노출 방지**.

```c
// atomic_write.c — 견고한 저장 (데이터+메타 내구성 확보)
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int main(){
  int fd=open("final.txt.tmp",O_CREAT|O_TRUNC|O_WRONLY,0644);
  write(fd,"consistent!\n",12);
  fsync(fd); close(fd);
  rename("final.txt.tmp","final.txt");
  int dfd=open(".",O_DIRECTORY|O_RDONLY); fsync(dfd); close(dfd);
  return 0;
}
```

---

### 권한/ACL/UMASK/캡abilities

- **DAC**: uid/gid + rwx 비트, `umask` 로 기본 권한 제한.
- **POSIX ACL**: 더 세밀한 주체/권한 부여.
- **Capabilities**: root 권한을 세분화(`CAP_DAC_OVERRIDE` 등).
- **스티키비트** 디렉터리(`/tmp`): 소유자만 자신의 파일 삭제 허용.

---

### Windows와의 차이(요점)

- **Share Modes**: `CreateFile` 의 `FILE_SHARE_READ/WRITE/DELETE`로 *열기 자체*를 제어.
- **Byte-range locks**: Mandatory 성격, SMB와 결합.
- **Opportunistic Locks / Leases**: 클라이언트 캐시 허용/회수 프로토콜(원격 공유에서 중요).

---

## Virtual File Systems (VFS)

### 역할

- 서로 다른 파일시스템(ext4/XFS/Btrfs/ZFS/NTFS/NFS/FUSE/overlayfs/….)을 **단일 추상 인터페이스**로 통행.
- 객체: **superblock / inode / dentry / file**, 연산 벡터: `super_operations`, `inode_operations`, `file_operations`, `dentry_operations` 등.
- 기능: **경로 해석**, **캐시**(dentry/inode/pagecache), **마운트 그래프**, **보안 체크**(LSM), **네임스페이스**.

### 경로 해석과 dentry 캐시

- `"root → a → b → c"` 순서로 **dentry**를 따라가며, **음성(negative) dentry** 로 “존재하지 않음”도 캐시.
- **`openat2()` + RESOLVE 플래그**로 보안 제한(심링크 탈출 차단 등).

```c
// openat2_secure.c — 심링크/교차 마운트 탈출 제한
#define _GNU_SOURCE
#include <linux/openat2.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <stdio.h>

int main(){
  struct open_how how = {
    .flags = O_RDONLY|O_CLOEXEC,
    .resolve = RESOLVE_BENEATH | RESOLVE_NO_MAGICLINKS | RESOLVE_NO_XDEV | RESOLVE_NO_SYMLINKS
  };
  int dfd = open("/srv/chroot", O_DIRECTORY|O_RDONLY);
  int fd = syscall(SYS_openat2, dfd, "safe/file.txt", &how, sizeof(how));
  if(fd<0){ perror("openat2"); return 1; }
  puts("ok"); return 0;
}
```

### pseudo-fs: procfs/sysfs/devtmpfs/tmpfs/overlayfs

- **procfs**: 프로세스/커널 뷰 노출(가상 파일).
- **sysfs**: 디바이스/드라이버/클래스 모델의 트리.
- **tmpfs**: 메모리 상 임시 목적(컨테이너/빌드/IPC).
- **overlayfs**: RO 하위 + RW 상위 병합.

### — 읽기/쓰기 메모리 FS 예제

> 의존: `fusepy` (개념 학습용). 아래는 **create/write/read/rename/unlink** 지원.

```python
# rw_memfs.py — 간단 메모리 FS (학습용)

from fuse import FUSE, Operations, FuseOSError
import errno, stat, time, os

class RWMemFS(Operations):
    def __init__(self):
        self.now = lambda:int(time.time())
        self.dir = {"/": {"st_mode":stat.S_IFDIR|0o755,"st_nlink":2,"st_ctime":self.now(),"st_mtime":self.now(),"st_atime":self.now()}}
        self.data = {}  # path -> bytes

    def getattr(self, path, fh=None):
        if path in self.dir: return self.dir[path]
        if path in self.data:
            d = self.data[path]
            return {"st_mode":stat.S_IFREG|0o644,"st_nlink":1,"st_size":len(d),"st_ctime":self.now(),"st_mtime":self.now(),"st_atime":self.now()}
        raise FuseOSError(errno.ENOENT)

    def readdir(self, path, fh):
        ents=[".",".."] + [p.split("/")[-1] for p in self.dir if p!="/" and os.path.dirname(p)==path] \
                        + [p.split("/")[-1] for p in self.data if os.path.dirname(p)==path]
        return ents

    def mkdir(self, path, mode):
        self.dir[path]={"st_mode":stat.S_IFDIR|mode,"st_nlink":2,"st_ctime":self.now(),"st_mtime":self.now(),"st_atime":self.now()}

    def create(self, path, mode, fi=None):
        self.data[path]=b""
        return 0

    def write(self, path, buf, offset, fh):
        s=self.data.get(path,b"")
        if offset>len(s): s+=b"\x00"*(offset-len(s))
        s=s[:offset]+buf+s[offset+len(buf):]
        self.data[path]=s; return len(buf)

    def read(self, path, size, offset, fh):
        s=self.data[path]; return s[offset:offset+size]

    def unlink(self, path):
        if path in self.data: del self.data[path]
        else: raise FuseOSError(errno.ENOENT)

    def rename(self, old, new):
        if old in self.data:
            self.data[new]=self.data.pop(old)
        elif old in self.dir:
            self.dir[new]=self.dir.pop(old)
        else: raise FuseOSError(errno.ENOENT)

if __name__ == "__main__":
    import sys; mountpoint=sys.argv[1]
    FUSE(RWMemFS(), mountpoint, foreground=True)
```

### 커널 VFS 연산 매핑(개념)

- `open` → `path_walk + inode_operations::lookup + file_operations::open`
- `read/write` → `file_operations::read_iter/write_iter` + 페이지캐시/blk-layer I/O
- `rename` → 부모 디렉터리 락 순서 보장 + 저널 트랜잭션 or COW

---

## Remote File Systems

### 왜 원격 FS인가?

- **투명한 공유**: 여러 호스트에서 같은 네임스페이스/파일을 **동시에**.
- **운영 단순화**: 중앙 백업/스냅샷/정책 관리.
- **가상화/컨테이너**: 호스트↔게스트, POD 간 **공유 볼륨**.

핵심 도전 과제:
1) **일관성 모델**: 서버/클라이언트 캐시, 쓰기 순서, 잠금.
2) **신뢰/보안**: 인증/권한 위임, 전송 암호화/서명.
3) **성능**: RTT/대역폭/배치/멀티채널/대용량 I/O.
4) **장애 회복**: 네트워크 분리/서버 failover/재연결 시语.

---

### NFS (Network File System)

- **v3**: *대체로 stateless*, 잠금은 **NLM(별도 데몬)**, 캐시는 **close-to-open** 의미.
- **v4**: **stateful**(세션/락 통합), **delegation**(클라이언트 캐시 위임), **Kerberos**(krb5/krb5i/krb5p).
- **pNFS**: 데이터 경로를 스케일아웃(메타는 MDS, 데이터는 DS).

**close-to-open 근사 모델**
- 클라이언트 A가 `close()` 시 변경을 서버로 밀고, 클라이언트 B가 `open()` 할 때 **속성 검증**을 통해 **갱신 감지**.
- 속성 캐시 TTL을 \(T\), 쓰기 발생률을 \(\lambda\) 라면 **stale 확률**을 단순 근사하면
  $$
  P(\text{stale}) \approx 1 - e^{-\lambda T}
  $$

**마운트 예시**
```bash
# 단순 (속성 캐시 2초, 읽기/쓰기 사이즈 1MiB)

mount -t nfs -o vers=4.1,rsize=1048576,wsize=1048576,acregmin=2,acdirmin=2 nfs.example.com:/export/data /mnt/data

# 보안 (Kerberos 암호화: krb5p, soft 타임아웃 + 재시도 제어)

mount -t nfs4 -o sec=krb5p,soft,timeo=600,retrans=2 nfs-sec:/secure /mnt/secure
```

**락 예시**: POSIX `fcntl` 락은 NFSv4에서 **서버가 소유권/상태**를 추적(재연결 시 회복 로직 중요).

---

### SMB (CIFS)

- **Stateful** 프로토콜: **세션/트리/파일 핸들** 계층.
- **Share modes + Byte-range locks**: 열기 단계에서 **공유 허용 범위**를 지정.
- **Oplock/Lease**: 클라이언트 캐시 권한 위임. **브레이크** 통지 시 플러시/락 해제.
- **SMB3**: 암호화/서명, 멀티채널, RDMA(SMB Direct).

**마운트 예시**
```bash
mount -t cifs //fileserver/share /mnt/smb \
  -o username=USER,vers=3.1.1,seal,actimeo=1,uid=1000,gid=1000,iocharset=utf8
```

---

### 9P, virtio-fs, FUSE over network

- **9P(plan9fs)**: 단순한 파일 RPC, QEMU 게스트 공유에 사용 가능(`virtio-9p`).
- **virtio-fs**: 게스트↔호스트 공유를 **DAX(페이지 캐시 우회)** 로 고성능 제공.
- **sshfs(FUSE)**: SFTP 위에 FUSE — 간편하지만 메타데이터 왕복이 많아 성능 한계.

---

### 원격 FS의 캐시/일관성 설계

1) **콜백 무효화**(AFS/NFSv4 delegations/SMB leases): 서버가 **변경 통지** → 클라이언트 캐시 **무효화**.
2) **폴링/TTL**: 정해진 기간 속성 체크(`ac*` 옵션).
3) **세션语**: open→read/write→close 동안의 **시맨틱**을 문서화(원자 rename, fsync 전달).
4) **락/서버 권한**: 락은 서버 권한이 최종적. 네트워크 단절시 **lease 만료**로 회수.

---

### 성능 최적화 체크리스트

- **I/O 배치**: `rsize/wsize` 확대(256KiB~1MiB), **async write/read-ahead**.
- **멀티채널/RDMA**: SMB3 multichannel, nconnect(NFS)로 **다중 TCP**.
- **속성 캐시**: `acregmin/acdirmin` 조정(작게 하면 동기화↑, 왕복↑).
- **압축/암호화**: 보안-성능 균형(SMB `seal`, NFS `krb5p`).
- **MTU/Jumbo**: 대형 프레임(환경 허용 시).
- **soft vs hard 마운트**: *hard*는 무한 재시도(데이터 안정성), *soft*는 오류 빠른 반환(응답성).

---

### 장애/재연결/복구

- **NFSv4 세션 재연결**: 클라이언트는 **session/sequenceid** 로 **재전달 안전**.
- **SMB durable handles**: 연결 끊김 후 **핸들 복구**.
- **락 회복**: 재연결 시 **락 재취득** 절차 필요(실패하면 앱에 오류 전파).

---

### 미니 실습: 소켓 기반 “아주 단순한 원격 파일 서버/클라이언트”

> 학습용. 보안을 고려하지 않은 *toy* 프로토콜(JSON 한 줄). 서버는 서버 디렉터리 아래 파일만 조작.

**서버(Python)**
```python
# toy_rfs_server.py — LIST/GET/PUT/DEL (학습용)

import json, os, socket, threading

ROOT = "./srvroot"

def handle(conn):
  with conn:
    line = conn.makefile().readline()
    req = json.loads(line)
    cmd = req["cmd"]
    if cmd == "LIST":
      files = [f for f in os.listdir(ROOT) if os.path.isfile(os.path.join(ROOT,f))]
      conn.sendall((json.dumps({"ok":True,"files":files})+"\n").encode())
    elif cmd == "GET":
      p = os.path.join(ROOT, req["name"])
      if not os.path.isfile(p): conn.sendall(b'{"ok":false}\n'); return
      data = open(p,"rb").read()
      conn.sendall((json.dumps({"ok":True,"size":len(data)})+"\n").encode()+data)
    elif cmd == "PUT":
      p = os.path.join(ROOT, req["name"])
      data = req["data"].encode() if isinstance(req["data"],str) else bytes(req["data"])
      tmp = p+".tmp"; open(tmp,"wb").write(data); os.replace(tmp,p)
      conn.sendall(b'{"ok":true}\n')
    elif cmd == "DEL":
      p = os.path.join(ROOT, req["name"])
      os.unlink(p); conn.sendall(b'{"ok":true}\n')

def main():
  os.makedirs(ROOT, exist_ok=True)
  s=socket.socket(); s.bind(("0.0.0.0",9099)); s.listen()
  while True:
    c,_=s.accept()
    threading.Thread(target=handle,args=(c,),daemon=True).start()

if __name__=="__main__": main()
```

**클라이언트(Python)**
```python
# toy_rfs_client.py

import json, socket, sys
def req(obj):
  s=socket.create_connection(("127.0.0.1",9099))
  s.sendall((json.dumps(obj)+"\n").encode())
  f=s.makefile("rb")
  head=f.readline()
  rsp=json.loads(head)
  if obj["cmd"]=="GET" and rsp.get("ok"):
    data=f.read(rsp["size"])
    return rsp, data
  return rsp, None

if __name__=="__main__":
  # 예: PUT → LIST → GET
  print(req({"cmd":"PUT","name":"hello.txt","data":b"hello remote"}))
  print(req({"cmd":"LIST"}))
  h,body=req({"cmd":"GET","name":"hello.txt"})
  print(h, body)
```

> 위 toy 서버/클라이언트는 “원격 FS가 수행해야 할 **원자적 쓰기/경로 제한/보안/락** 등 수많은 세부”가 필요함을 체감시키는 예제다. 실제 NFS/SMB는 이를 강건하게 표준화/구현한다.

---

### 원격 락 데모: “서버 권한이 최종”

원격 FS에서는 **서버가 진실**이다. 클라이언트가 로컬에서 advisory 락을 잡아도, 서버에서 **락 거부**되면 실패.

```c
// nfs_lock_hints.c — 개념 요약(실제 NFS 호출은 커널/서버가 담당)
// 1) fcntl로 레인지 락 시도 → 2) 커널 NFS 클라이언트가 서버에 락 RPC → 3) 승인/거부
// 실패 시 errno=EACCES/EAGAIN 등으로 반환 → 앱은 backoff/retry
```

---

## 상황별 설계 요약(현업 체크리스트)

1) **동일 호스트 동시쓰기**: 레인지 락 + 원자적 rename + `fsync(dir)`.
2) **로컬+원격 혼재**: *로컬 임시파일*에 완성 후 **원자적 배치**(원격이면 write+fsync 후 close).
3) **NFS**: close-to-open 시맨틱 이해, 속성 캐시 TTL 조정, 필요 시 `noac`(*주의: 성능 저하*).
4) **SMB**: oplock/lease가 캐시 성능 핵심 — 서버 정책과 충돌 시 성능 급락 가능.
5) **컨테이너**: overlayFS 상단에 원격 마운트는 성능/일관성 이슈 — **전용 볼륨 플러그인** 고려.
6) **보안**: NFSv4 `sec=krb5[p]`, SMB3 `seal`; 네트워크 분리/방화벽/서브넷 MTU 조정.
7) **관측/튜닝**: rsize/wsize, nconnect/multichannel, RTT, p99 latency, 재연결/락 회복 로그.

---

## 핵심 요약

- **15.4 File Sharing**: 같은 파일을 여러 주체가 쓸 때의 **핸들/캐시/락/원자성**을 구체적으로 이해하라. 로컬에서는 FD/페이지캐시/레인지락, 원자적 rename 패턴이 실무 표준이다.
- **15.5 VFS**: superblock/inode/dentry/file과 연산 벡터가 모든 파일시스템의 **공통 골격**. `openat2`/네임스페이스/overlay/FUSE로 **확장·격리**를 설계한다.
- **15.6 Remote FS**: NFS/SMB/9P/virtio-fs 각기 **일관성·보안·성능** 특성이 다르다. close-to-open/leases/delegations, rsize/wsize/TTL/암호화 옵션을 워크로드에 맞게 조합하라.
