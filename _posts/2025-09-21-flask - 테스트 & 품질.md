---
layout: post
title: flask - 테스트 & 품질
date: 2025-09-21 17:25:23 +0900
category: flask
---
# 15. 테스트 & 품질

> 이 장은 Flask 프로젝트에서 **pytest 기반의 단위/통합 테스트 전략**을 **운영 기준**으로 정리한다.  
> 범위는 **pytest 픽스처(app/client/db), 커버리지, 통합 테스트(실DB 대체/트랜잭션 롤백), 계약 테스트, 테스트 더블(Stub/Mock), Flask CLI 테스트 자동화**까지 포괄한다.  
> 모든 코드는 ``` 로 감싸며, 수식이 필요하면 $$...$$로 감싼다(본 장은 수식이 거의 없음).

---

## 15.1 테스트 철학: “작게 빠르게, 크긴 드물게, 실패는 의미 있게”

- **단위 테스트(Unit)**: 함수/메서드 단위. **빠르고 많게(밀도↑)**. 외부 의존성은 **더블**(stub/mocks)로 격리.
- **통합 테스트(Integration)**: DB/외부 API/큐/템플릿/라우팅이 **실제처럼 합쳐짐**을 검증. **핵심 경로 위주**.
- **계약 테스트(Contract)**: 서비스 간 **API 계약**(스키마/상태코드/필수 필드)을 **독립적으로 보증**.
- **E2E/시스템 테스트**: 소수만, 주 경로만. 느리고 불안정해지기 쉬움 → **최소화**.
- **커버리지**는 **품질 지표**일 뿐 목표치(예: 80%)를 **목적화하지 말 것**. **리그레션 방지** 수단.

---

## 15.2 프로젝트 레이아웃 & 의존성

```
app/
  __init__.py            # create_app(config)
  extensions.py          # db, cache, login, ...
  models/                # SQLAlchemy models
  blueprints/            # views, api
  services/              # domain logic
  cli/                   # click commands (Flask CLI)
migrations/              # alembic (선택)
tests/
  conftest.py
  unit/                  # 단위 테스트
  integration/           # 통합 테스트
  contract/              # 계약 테스트
  e2e/                   # (선택)
.pytest.ini
.coveragerc
requirements-dev.txt
```

개발 의존성:

```txt
# requirements-dev.txt
pytest
pytest-cov
pytest-mock
pytest-xdist
pytest-randomly
factory_boy
Faker
responses           # requests 더블
respx              # httpx 더블
testcontainers     # 통합 테스트에 실DB 컨테이너
pact-python        # 계약 테스트(옵션)
freezegun          # 시간 고정
```

---

## 15.3 pytest 설정(기본 옵션/마커/경고)

```ini
# .pytest.ini
[pytest]
minversion = 7.0
addopts = -ra -q --strict-markers --strict-config
testpaths = tests
xfail_strict = true
filterwarnings =
    error
    ignore::DeprecationWarning:pkg_resources
markers =
    unit: 빠른 단위 테스트
    integration: DB/외부 연동 포함 통합 테스트
    contract: 소비자/제공자 계약 테스트
    slow: 느린 테스트
```

---

## 15.4 커버리지(coverage.py, pytest-cov)

### 15.4.1 설정

```ini
# .coveragerc
[run]
branch = True
omit =
    */tests/*
    */venv/*
    app/cli/dev_only.py

[report]
show_missing = True
skip_covered = True
fail_under = 80
precision = 1
```

### 15.4.2 실행

```bash
pytest --cov=app --cov-report=term-missing
# HTML 리포트
pytest --cov=app --cov-report=html
# 병렬(xdist)과 함께
pytest -n auto --dist=loadscope --cov=app
```

> **팁**: **fail_under** 를 CI에 적용하되, 신규 모듈에는 더 높은 기준(예: 90%)을 PR 규칙으로 적용.

---

## 15.5 테스트 픽스처: app / client / db

### 15.5.1 앱 팩토리 & 테스트 설정

```python
# app/__init__.py
from flask import Flask
from .extensions import db
def create_app(config_name="testing"):
    app = Flask(__name__)
    if config_name == "testing":
        app.config.update(
            TESTING=True,
            SQLALCHEMY_DATABASE_URI="sqlite:///:memory:",
            SQLALCHEMY_TRACK_MODIFICATIONS=False,
            WTF_CSRF_ENABLED=False,        # 테스트 편의
            SECRET_KEY="test-secret",
        )
    # ... production/dev 등
    db.init_app(app)

    # 블루프린트/CLI 등록 등
    from .blueprints.site import site_bp
    app.register_blueprint(site_bp)

    return app
```

### 15.5.2 conftest.py – app/client/db 픽스처

```python
# tests/conftest.py
import os
import pytest
from app import create_app
from app.extensions import db as _db

@pytest.fixture(scope="session")
def app():
    os.environ["APP_ENV"] = "testing"
    app = create_app("testing")
    with app.app_context():
        yield app

@pytest.fixture(scope="session")
def db(app):
    # 세션 스코프 DB(스키마 생성 1회)
    _db.create_all()
    yield _db
    _db.session.remove()
    _db.drop_all()

@pytest.fixture(scope="function", autouse=True)
def session(db):
    """
    각 테스트마다 새로운 트랜잭션을 열고 종료 시 롤백하여 고립 보장.
    """
    connection = db.engine.connect()
    trans = connection.begin()
    options = dict(bind=connection, binds={})
    session = db.create_scoped_session(options=options)
    db.session = session  # 앱의 전역 세션을 교체

    yield session

    # 롤백 & 정리
    trans.rollback()
    connection.close()
    session.remove()

@pytest.fixture()
def client(app):
    return app.test_client()

@pytest.fixture()
def runner(app):
    return app.test_cli_runner()
```

> **핵심**: **세션 스코프 DB** + **함수 스코프 트랜잭션 롤백**으로 **엄청 빠르면서도 고립**된 테스트 환경.

### 15.5.3 Factory & Faker(테스트 데이터)

```python
# tests/factories.py
import factory
from app.extensions import db
from app.models import User, Order

class SQLAFactory(factory.alchemy.SQLAlchemyModelFactory):
    class Meta:
        abstract = True
        sqlalchemy_session = db.session
        sqlalchemy_session_persistence = "flush"   # flush 후 테스트 코드에서 commit 제어

class UserFactory(SQLAFactory):
    class Meta: model = User
    email = factory.Faker("email")
    name  = factory.Faker("name")

class OrderFactory(SQLAFactory):
    class Meta: model = Order
    user  = factory.SubFactory(UserFactory)
    total = factory.Faker("pydecimal", left_digits=3, right_digits=2, positive=True)
    status = "pending"
```

---

## 15.6 단위 테스트 패턴

### 15.6.1 서비스 로직 테스트

```python
# app/services/pricing.py
def calc_total(items, *, tax_rate=0.1, discount=0.0):
    subtotal = sum(p*q for p, q in items)
    subtotal *= (1.0 - discount)
    return round(subtotal * (1.0 + tax_rate), 2)
```

```python
# tests/unit/test_pricing.py
import pytest
from app.services.pricing import calc_total

@pytest.mark.unit
@pytest.mark.parametrize("items,discount,expected", [
    ([(100,1),(50,2)], 0.0, 220.0),
    ([(100,1)],         0.1, 99.0),   # (100 * 0.9) * 1.1 = 99.0
])
def test_calc_total(items, discount, expected):
    assert calc_total(items, discount=discount) == expected
```

### 15.6.2 Flask view(라우트) 단위 테스트

```python
# app/blueprints/site/__init__.py
from flask import Blueprint, jsonify
site_bp = Blueprint("site", __name__)

@site_bp.get("/ping")
def ping():
    return jsonify(ok=True)
```

```python
# tests/unit/test_ping.py
@pytest.mark.unit
def test_ping(client):
    rv = client.get("/ping")
    assert rv.status_code == 200
    assert rv.get_json() == {"ok": True}
```

### 15.6.3 시간 고정(Freezegun)

```python
from freezegun import freeze_time
from datetime import datetime, timezone

@freeze_time("2025-10-20 09:00:00", tz_offset=0)
def test_time_sensitive():
    assert datetime.now(timezone.utc).hour == 9
```

---

## 15.7 통합 테스트: 실DB 대체/트랜잭션 롤백/실제 경로

### 15.7.1 In-memory SQLite vs 실제 엔진

- **SQLite(in-memory)**: 속도 최강, 하지만 **행 잠금/동작 차이**가 PostgreSQL/MySQL과 다름.
- **테스트컨테이너(Testcontainers)**: 실제 DB 컨테이너를 테스트 중 띄워 **현실성↑**.

#### 옵션 A) SQLite로 빠른 통합

이미 15.5에서 in-memory를 구성. ORM 쿼리/마이그레이션을 **큰 그림**으로 확인.

#### 옵션 B) Testcontainers로 Postgres 실DB

```python
# tests/conftest.py (대체/추가)
import pytest
from testcontainers.postgres import PostgresContainer
from app import create_app
from app.extensions import db as _db

@pytest.fixture(scope="session")
def pg_url():
    with PostgresContainer("postgres:15-alpine") as pg:
        yield pg.get_connection_url()  # postgresql://test:test@localhost:xxxxx/test

@pytest.fixture(scope="session")
def app(pg_url):
    app = create_app("testing")
    app.config["SQLALCHEMY_DATABASE_URI"] = pg_url
    with app.app_context():
        yield app

@pytest.fixture(scope="session")
def db(app):
    _db.create_all()
    yield _db
    _db.session.remove()
    _db.drop_all()
```

> **속도/비용**: 컨테이너 기동(수 초) 비용 있으나 **행위/락/인덱스 차이**로 생길 수 있는 버그를 조기 포착.

### 15.7.2 API 플로우(인증/인가 포함) 통합 시나리오

```python
# tests/integration/test_checkout.py
import pytest
from tests.factories import UserFactory, OrderFactory
from app.extensions import db

@pytest.mark.integration
def test_checkout_flow(client):
    user = UserFactory()
    db.session.commit()            # 실제 ID 발급
    # 로그인 세션(예제: 간단 쿠키 시뮬)
    with client.session_transaction() as sess:
        sess["user_id"] = user.id

    # 장바구니 -> 결제 -> 주문 상태 변환
    rv = client.post("/api/checkout", json={"items":[{"id":1,"qty":2}]})
    assert rv.status_code == 200
    order_id = rv.get_json()["order_id"]

    # 결제 성공 웹훅 시뮬
    rv = client.post("/api/payment/webhook", json={"order_id":order_id,"status":"paid"})
    assert rv.status_code == 204

    # 주문 상태 확인
    rv = client.get(f"/api/orders/{order_id}")
    assert rv.status_code == 200
    assert rv.get_json()["status"] == "paid"
```

### 15.7.3 트랜잭션 롤백 검증

```python
# tests/integration/test_tx_rollback.py
from app.extensions import db
from app.models import Order

def test_rollback(session):
    o = Order(total=10, status="pending")
    db.session.add(o)
    db.session.flush()
    assert Order.query.count() == 1  # 트랜잭션 내부
    # 테스트 끝나면 conftest의 session 픽스처가 rollback → 깨끗
```

---

## 15.8 외부 의존성 더블: Stub/Mock/Spy/Fake

### 15.8.1 requests 호출 더블(responses)

```python
# app/services/external.py
import requests
def fetch_profile(uid: str):
    r = requests.get(f"https://api.example.com/users/{uid}", timeout=2)
    r.raise_for_status()
    return r.json()
```

```python
# tests/unit/test_external.py
import responses
from app.services.external import fetch_profile

@responses.activate
def test_fetch_profile_ok():
    responses.add(
        responses.GET, "https://api.example.com/users/42",
        json={"id":"42","name":"Neo"}, status=200
    )
    data = fetch_profile("42")
    assert data["name"] == "Neo"

@responses.activate
def test_fetch_profile_5xx_retry():
    responses.add(responses.GET, "https://api.example.com/users/42", status=500)
    # 재시도 로직이 있다면 assert 호출 횟수/예외 유형
```

### 15.8.2 httpx 더블(respx)

```python
# app/services/httpx_client.py
import httpx
client = httpx.Client(timeout=2.0)

def get_weather(city):
    r = client.get(f"https://weather.example.com/{city}")
    r.raise_for_status()
    return r.json()
```

```python
# tests/unit/test_httpx_respx.py
import respx
from app.services.httpx_client import get_weather

@respx.mock
def test_weather():
    route = respx.get("https://weather.example.com/Seoul").mock(
        return_value=respx.Response(200, json={"t": 21})
    )
    assert get_weather("Seoul") == {"t": 21}
    assert route.called
```

### 15.8.3 mock.patch/pytest-mock

```python
# app/services/notify.py
from .mailer import send_mail
def notify_user(email):
    send_mail(email, subject="Hi", body="Hello")
    return True
```

```python
# tests/unit/test_notify.py
def test_notify_user(mocker):
    m = mocker.patch("app.services.notify.send_mail", return_value=True)
    from app.services.notify import notify_user
    assert notify_user("a@b.com") is True
    m.assert_called_once_with("a@b.com", subject="Hi", body="Hello")
```

### 15.8.4 Fake(간이 구현으로 대체)

```python
# tests/fakes.py
class FakeCache:
    store = {}
    def get(self, k): return self.store.get(k)
    def set(self, k, v, timeout=None): self.store[k] = v
```

```python
def test_service_with_fake_cache(monkeypatch):
    from app import services
    services.cache = FakeCache()
    # cache에 의존하는 함수 테스트
```

---

## 15.9 계약 테스트(Consumer-Driven Contracts, Pact)

> **문제**: 마이크로서비스/외부 API가 자주 바뀌면 **통합 테스트만으로는 사전 탐지**가 어려움.  
> **해법**: **소비자(Consumer)** 가 기대하는 **계약**을 명시 → **제공자(Provider)** 가 이를 만족하는지 **독립적으로 검증**.

### 15.9.1 소비자 측(Pact 파일 생성)

```python
# tests/contract/test_consumer_pact.py
import pytest
from pact import Consumer, Provider

pact = Consumer("orders-frontend").has_pact_with(Provider("billing-api"))
pact.start_service()

def test_get_invoice_contract():
    # 기대 계약 정의
    (pact
     .given("invoice 100 exists")
     .upon_receiving("a request for invoice 100")
     .with_request("GET", "/invoices/100")
     .will_respond_with(200, body={"id": "100", "amount": 129.9, "status":"paid"}))

    with pact:
        # 실제 소비자 코드(더블 엔드포인트로 호출)
        import requests
        r = requests.get(pact.uri + "/invoices/100")
        assert r.status_code == 200
        data = r.json()
        assert "amount" in data

    pact.stop_service()
```

> 결과로 **pact 파일**이 생성되어 **브로커**(Pact Broker 등)에 업로드 → 제공자 파이프라인에서 검증.

### 15.9.2 제공자 측(계약 검증)

```python
# tests/contract/test_provider_pact_verify.py
import pytest
from pact import Verifier

def test_verify_pacts():
    verifier = Verifier(provider="billing-api")
    # pact 브로커 혹은 로컬 파일 기반
    output, _ = verifier.verify_pacts("./pacts/orders-frontend-billing-api.json",
                                      provider_base_url="http://localhost:5001")
    assert output == 0
```

> **운영 포인트**: **버전/환경** 태그를 활용해 **스테이징/프로덕션** 별 계약을 관리.  
> **스키마 드리프트**는 **계약 실패**로 즉시 감지한다.

---

## 15.10 Flask CLI 테스트 자동화

### 15.10.1 CLI 명령(Click 기반)

```python
# app/cli/commands.py
import click
from flask import current_app
from app.extensions import db
from app.models import User

@click.command("create-admin")
@click.option("--email", prompt=True)
def create_admin(email):
    u = User(email=email, is_admin=True)
    db.session.add(u); db.session.commit()
    click.echo(f"created admin: {u.id}")

def register_cli(app):
    app.cli.add_command(create_admin)
```

앱 등록:

```python
# app/__init__.py (create_app 내부)
from .cli.commands import register_cli
register_cli(app)
```

### 15.10.2 테스트

```python
# tests/unit/test_cli.py
def test_create_admin_cli(runner, db):
    result = runner.invoke(args=["create-admin"], input="boss@example.com\n")
    assert result.exit_code == 0
    assert "created admin:" in result.output
```

---

## 15.11 고급 기법: Property-based, Snapshot, Golden Master

### 15.11.1 Hypothesis(성질 기반 테스트)

```python
# pip install hypothesis
from hypothesis import given, strategies as st
from app.services.pricing import calc_total

@given(st.lists(st.tuples(st.decimals(min_value=0), st.integers(min_value=0)), min_size=1))
def test_calc_total_non_negative(items):
    total = calc_total(items, discount=0)
    assert total >= 0
```

### 15.11.2 스냅샷/골든 파일

- JSON 응답/렌더 템플릿을 **스냅샷**으로 남기고 **회귀** 감지
- 파라미터 변경으로 쉽게 깨질 수 있어, **중요 출력에 한정**해서 사용

---

## 15.12 플레이크(Flaky) & 격리 문제 해결

- **랜덤 시드 고정**: `pytest-randomly`  
- **시간 의존**: freezegun  
- **네트워크 의존 제거**: responses/respx  
- **파일 시스템 고립**: `tmp_path`  
- **글로벌 상태/싱글톤**: 테스트 후 **reset**(픽스처 finalizer)  
- **비결정 동시성**: 폴링/슬립 대신 **조건 대기**(exponential backoff + 타임아웃)

---

## 15.13 CI 구성(예: GitHub Actions)

```yaml
# .github/workflows/test.yml
name: tests
on: [push, pull_request]
jobs:
  pytest:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        ports: ["5432:5432"]
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=5s --health-timeout=5s --health-retries=5
    env:
      DATABASE_URL: postgresql://postgres:postgres@localhost:5432/testdb
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: {python-version: "3.11"}
      - run: pip install -r requirements-dev.txt
      - run: pip install -e .
      - run: pytest --cov=app --cov-report=xml
      - uses: codecov/codecov-action@v4
        with: {files: ./coverage.xml}
```

---

## 15.14 성능 최적화: 테스트가 느려질 때

- **픽스처 재사용**: session/module scope로 비싼 초기화 최소화
- **트랜잭션 롤백**: DB 재생성 대신 **rollback**으로 고립 (이미 적용)
- **xdist 병렬화**: `-n auto`; DB는 **각 워커별 DB**(SQLite 파일/PG 스키마) 분리
- **선택 실행**: `pytest -m "unit and not slow"` / `-k "keyword"`
- **프로파일링**: `pytest --durations=20` 로 느린 20개 테스트 식별

---

## 15.15 품질 게이트: 린터/포맷터/타입체커와 결합

- **ruff/flake8**: 스타일/잠재 버그
- **black**: 포맷 통일
- **mypy/pyright**: 정적 타입  
- **pre-commit** 훅으로 PR 전에 자동 실행

```yaml
# .pre-commit-config.yaml
repos:
- repo: https://github.com/psf/black
  rev: 24.8.0
  hooks: [{id: black}]
- repo: https://github.com/astral-sh/ruff-pre-commit
  rev: v0.6.9
  hooks: [{id: ruff}]
```

---

## 15.16 흔한 안티패턴

- **테스트에서 실제 외부 API 호출**: 느리고 깨지기 쉬움 → **더블** 사용
- **DB에 commit 남발**: 단위 테스트에서 굳이 commit 불필요 → **flush 또는 롤백** 패턴
- **대형 통합 테스트만 의존**: 실패 지점 파악 어려움, 유지비↑ → **단위 테스트 우선**
- **커버리지 숫자 집착**: 무의미한 라인 강제 → **중요 분기/에러 경로** 커버리지에 집중
- **전역 상태 오염**: 테스트 간 의존 → 픽스처 격리와 finalizer 필수
- **시간/난수/순서 의존**: 랜덤/시간 고정 없이 작성 → **freezegun/pytest-randomly**

---

## 15.17 붙여넣기 스타터 패키지

### 15.17.1 최소 conftest + app factory

```python
# tests/conftest.py (요약)
import pytest
from app import create_app
from app.extensions import db as _db

@pytest.fixture(scope="session")
def app():
    app = create_app("testing")
    with app.app_context():
        yield app

@pytest.fixture(scope="session")
def db(app):
    _db.create_all()
    yield _db
    _db.drop_all()

@pytest.fixture(autouse=True)
def session(db):
    con = db.engine.connect(); tx = con.begin()
    session = db.create_scoped_session(bind=con)
    db.session = session
    yield session
    tx.rollback(); con.close(); session.remove()

@pytest.fixture
def client(app):
    return app.test_client()
```

### 15.17.2 커버리지 & 명령

```bash
pytest -q --cov=app --cov-report=term-missing
pytest -n auto --dist=loadscope
```

---

## 15.18 마무리

이 장에서는 **pytest 기반 테스트 인프라**(app/client/db 픽스처, 트랜잭션 롤백, 팩토리), **커버리지 설정**, **통합 테스트(실DB 대체 옵션과 Testcontainers)**, **계약 테스트(Pact)**, **테스트 더블(responses/respx/mock)**, **Flask CLI 자동화 테스트**까지 **운영 환경에 바로 쓰는 패턴**을 담았다.  

핵심 포인트를 다시 정리하면:

- **고속 격리**: 세션 스코프 DB + 함수 스코프 트랜잭션 롤백
- **더블 우선**: 외부 의존성은 stub/mock 으로 격리, 통합은 핵심 경로만
- **계약 유지**: Pact로 소비자-제공자 간 API 변동을 조기 감지
- **품질 게이트**: 커버리지 임계치 + 린터/타입체커 + CI 자동화