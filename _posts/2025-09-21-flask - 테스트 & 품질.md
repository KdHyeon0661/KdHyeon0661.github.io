---
layout: post
title: flask - 테스트 & 품질
date: 2025-09-21 17:25:23 +0900
category: flask
---
# 테스트 & 품질

## 테스트 철학: "작게 빠르게, 크긴 드물게, 실패는 의미 있게"

효과적인 테스트 전략은 다음과 같은 원칙을 따릅니다:

- **단위 테스트(Unit)**: 함수/메서드 단위로 빠르고 많이 작성합니다. 외부 의존성은 **더블**(stub/mocks)로 격리합니다.
- **통합 테스트(Integration)**: DB/외부 API/큐/템플릿/라우팅이 실제처럼 함께 작동하는 것을 검증하며, 핵심 경로 위주로 작성합니다.
- **계약 테스트(Contract)**: 서비스 간 **API 계약**(스키마/상태코드/필수 필드)을 독립적으로 보증합니다.
- **E2E/시스템 테스트**: 소수만, 주 경로만 테스트하며 느리고 불안정해지기 쉬우므로 최소화합니다.
- **커버리지**는 품질 지표일 뿐 목표치를 목적으로 삼지 않습니다. **리그레션 방지** 수단으로 활용합니다.

---

## 프로젝트 레이아웃 & 의존성

```
app/
  __init__.py            # create_app(config)
  extensions.py          # db, cache, login, ...
  models/                # SQLAlchemy models
  blueprints/            # views, api
  services/              # domain logic
  cli/                   # click commands (Flask CLI)
migrations/              # alembic (선택)
tests/
  conftest.py
  unit/                  # 단위 테스트
  integration/           # 통합 테스트
  contract/              # 계약 테스트
  e2e/                   # (선택)
.pytest.ini
.coveragerc
requirements-dev.txt
```

개발 의존성:

```txt
# requirements-dev.txt

pytest
pytest-cov
pytest-mock
pytest-xdist
pytest-randomly
factory_boy
Faker
responses           # requests 더블
respx              # httpx 더블
testcontainers     # 통합 테스트에 실DB 컨테이너
pact-python        # 계약 테스트(옵션)
freezegun          # 시간 고정
```

---

## pytest 설정(기본 옵션/마커/경고)

```ini
# .pytest.ini

[pytest]
minversion = 7.0
addopts = -ra -q --strict-markers --strict-config
testpaths = tests
xfail_strict = true
filterwarnings =
    error
    ignore::DeprecationWarning:pkg_resources
markers =
    unit: 빠른 단위 테스트
    integration: DB/외부 연동 포함 통합 테스트
    contract: 소비자/제공자 계약 테스트
    slow: 느린 테스트
```

---

## 커버리지(coverage.py, pytest-cov)

### 설정

```ini
# .coveragerc

[run]
branch = True
omit =
    */tests/*
    */venv/*
    app/cli/dev_only.py

[report]
show_missing = True
skip_covered = True
fail_under = 80
precision = 1
```

### 실행

```bash
pytest --cov=app --cov-report=term-missing
# HTML 리포트

pytest --cov=app --cov-report=html
# 병렬(xdist)과 함께

pytest -n auto --dist=loadscope --cov=app
```

**팁**: **fail_under** 를 CI에 적용하되, 신규 모듈에는 더 높은 기준(예: 90%)을 PR 규칙으로 적용합니다.

---

## 테스트 픽스처: app / client / db

### 앱 팩토리 & 테스트 설정

```python
# app/__init__.py

from flask import Flask
from .extensions import db
def create_app(config_name="testing"):
    app = Flask(__name__)
    if config_name == "testing":
        app.config.update(
            TESTING=True,
            SQLALCHEMY_DATABASE_URI="sqlite:///:memory:",
            SQLALCHEMY_TRACK_MODIFICATIONS=False,
            WTF_CSRF_ENABLED=False,        # 테스트 편의
            SECRET_KEY="test-secret",
        )
    # ... production/dev 등
    db.init_app(app)

    # 블루프린트/CLI 등록 등
    from .blueprints.site import site_bp
    app.register_blueprint(site_bp)

    return app
```

### conftest.py – app/client/db 픽스처

```python
# tests/conftest.py

import os
import pytest
from app import create_app
from app.extensions import db as _db

@pytest.fixture(scope="session")
def app():
    os.environ["APP_ENV"] = "testing"
    app = create_app("testing")
    with app.app_context():
        yield app

@pytest.fixture(scope="session")
def db(app):
    # 세션 스코프 DB(스키마 생성 1회)
    _db.create_all()
    yield _db
    _db.session.remove()
    _db.drop_all()

@pytest.fixture(scope="function", autouse=True)
def session(db):
    """
    각 테스트마다 새로운 트랜잭션을 열고 종료 시 롤백하여 고립 보장.
    """
    connection = db.engine.connect()
    trans = connection.begin()
    options = dict(bind=connection, binds={})
    session = db.create_scoped_session(options=options)
    db.session = session  # 앱의 전역 세션을 교체

    yield session

    # 롤백 & 정리
    trans.rollback()
    connection.close()
    session.remove()

@pytest.fixture()
def client(app):
    return app.test_client()

@pytest.fixture()
def runner(app):
    return app.test_cli_runner()
```

**핵심**: **세션 스코프 DB** + **함수 스코프 트랜잭션 롤백**으로 **빠르면서도 고립**된 테스트 환경을 구성합니다.

### Factory & Faker(테스트 데이터)

```python
# tests/factories.py

import factory
from app.extensions import db
from app.models import User, Order

class SQLAFactory(factory.alchemy.SQLAlchemyModelFactory):
    class Meta:
        abstract = True
        sqlalchemy_session = db.session
        sqlalchemy_session_persistence = "flush"   # flush 후 테스트 코드에서 commit 제어

class UserFactory(SQLAFactory):
    class Meta: model = User
    email = factory.Faker("email")
    name  = factory.Faker("name")

class OrderFactory(SQLAFactory):
    class Meta: model = Order
    user  = factory.SubFactory(UserFactory)
    total = factory.Faker("pydecimal", left_digits=3, right_digits=2, positive=True)
    status = "pending"
```

---

## 단위 테스트 패턴

### 서비스 로직 테스트

```python
# app/services/pricing.py

def calc_total(items, *, tax_rate=0.1, discount=0.0):
    subtotal = sum(p*q for p, q in items)
    subtotal *= (1.0 - discount)
    return round(subtotal * (1.0 + tax_rate), 2)
```

```python
# tests/unit/test_pricing.py

import pytest
from app.services.pricing import calc_total

@pytest.mark.unit
@pytest.mark.parametrize("items,discount,expected", [
    ([(100,1),(50,2)], 0.0, 220.0),
    ([(100,1)],         0.1, 99.0),   # (100 * 0.9) * 1.1 = 99.0
])
def test_calc_total(items, discount, expected):
    assert calc_total(items, discount=discount) == expected
```

### 라우트 단위 테스트

```python
# app/blueprints/site/__init__.py

from flask import Blueprint, jsonify
site_bp = Blueprint("site", __name__)

@site_bp.get("/ping")
def ping():
    return jsonify(ok=True)
```

```python
# tests/unit/test_ping.py

@pytest.mark.unit
def test_ping(client):
    rv = client.get("/ping")
    assert rv.status_code == 200
    assert rv.get_json() == {"ok": True}
```

### 시간 고정(Freezegun)

```python
from freezegun import freeze_time
from datetime import datetime, timezone

@freeze_time("2025-10-20 09:00:00", tz_offset=0)
def test_time_sensitive():
    assert datetime.now(timezone.utc).hour == 9
```

---

## 통합 테스트: 실DB 대체/트랜잭션 롤백/실제 경로

### In-memory SQLite vs 실제 엔진

- **SQLite(in-memory)**: 속도가 빠르지만, **행 잠금/동작 차이**가 PostgreSQL/MySQL과 다릅니다.
- **테스트컨테이너(Testcontainers)**: 실제 DB 컨테이너를 테스트 중 띄워 **현실성**을 높입니다.

#### SQLite로 빠른 통합

이미 in-memory SQLite를 구성한 방식으로 ORM 쿼리와 마이그레이션을 전체적인 관점에서 확인합니다.

#### Testcontainers로 Postgres 실DB

```python
# tests/conftest.py (대체/추가)

import pytest
from testcontainers.postgres import PostgresContainer
from app import create_app
from app.extensions import db as _db

@pytest.fixture(scope="session")
def pg_url():
    with PostgresContainer("postgres:15-alpine") as pg:
        yield pg.get_connection_url()  # postgresql://test:test@localhost:xxxxx/test

@pytest.fixture(scope="session")
def app(pg_url):
    app = create_app("testing")
    app.config["SQLALCHEMY_DATABASE_URI"] = pg_url
    with app.app_context():
        yield app

@pytest.fixture(scope="session")
def db(app):
    _db.create_all()
    yield _db
    _db.session.remove()
    _db.drop_all()
```

**속도/비용 고려사항**: 컨테이너 기동에 수 초의 비용이 들지만, **행위/락/인덱스 차이**로 인한 버그를 조기에 포착할 수 있습니다.

### 통합 시나리오 테스트

```python
# tests/integration/test_checkout.py

import pytest
from tests.factories import UserFactory, OrderFactory
from app.extensions import db

@pytest.mark.integration
def test_checkout_flow(client):
    user = UserFactory()
    db.session.commit()            # 실제 ID 발급
    # 로그인 세션(예제: 간단 쿠키 시뮬)
    with client.session_transaction() as sess:
        sess["user_id"] = user.id

    # 장바구니 -> 결제 -> 주문 상태 변환
    rv = client.post("/api/checkout", json={"items":[{"id":1,"qty":2}]})
    assert rv.status_code == 200
    order_id = rv.get_json()["order_id"]

    # 결제 성공 웹훅 시뮬
    rv = client.post("/api/payment/webhook", json={"order_id":order_id,"status":"paid"})
    assert rv.status_code == 204

    # 주문 상태 확인
    rv = client.get(f"/api/orders/{order_id}")
    assert rv.status_code == 200
    assert rv.get_json()["status"] == "paid"
```

### 트랜잭션 롤백 검증

```python
# tests/integration/test_tx_rollback.py

from app.extensions import db
from app.models import Order

def test_rollback(session):
    o = Order(total=10, status="pending")
    db.session.add(o)
    db.session.flush()
    assert Order.query.count() == 1  # 트랜잭션 내부
    # 테스트 끝나면 conftest의 session 픽스처가 rollback → 깨끗
```

---

## 외부 의존성 더블: Stub/Mock/Spy/Fake

### requests 호출 더블(responses)

```python
# app/services/external.py

import requests
def fetch_profile(uid: str):
    r = requests.get(f"https://api.example.com/users/{uid}", timeout=2)
    r.raise_for_status()
    return r.json()
```

```python
# tests/unit/test_external.py

import responses
from app.services.external import fetch_profile

@responses.activate
def test_fetch_profile_ok():
    responses.add(
        responses.GET, "https://api.example.com/users/42",
        json={"id":"42","name":"Neo"}, status=200
    )
    data = fetch_profile("42")
    assert data["name"] == "Neo"

@responses.activate
def test_fetch_profile_5xx_retry():
    responses.add(responses.GET, "https://api.example.com/users/42", status=500)
    # 재시도 로직이 있다면 assert 호출 횟수/예외 유형
```

### httpx 더블(respx)

```python
# app/services/httpx_client.py

import httpx
client = httpx.Client(timeout=2.0)

def get_weather(city):
    r = client.get(f"https://weather.example.com/{city}")
    r.raise_for_status()
    return r.json()
```

```python
# tests/unit/test_httpx_respx.py

import respx
from app.services.httpx_client import get_weather

@respx.mock
def test_weather():
    route = respx.get("https://weather.example.com/Seoul").mock(
        return_value=respx.Response(200, json={"t": 21})
    )
    assert get_weather("Seoul") == {"t": 21}
    assert route.called
```

### mock.patch/pytest-mock

```python
# app/services/notify.py

from .mailer import send_mail
def notify_user(email):
    send_mail(email, subject="Hi", body="Hello")
    return True
```

```python
# tests/unit/test_notify.py

def test_notify_user(mocker):
    m = mocker.patch("app.services.notify.send_mail", return_value=True)
    from app.services.notify import notify_user
    assert notify_user("a@b.com") is True
    m.assert_called_once_with("a@b.com", subject="Hi", body="Hello")
```

### Fake(간이 구현으로 대체)

```python
# tests/fakes.py

class FakeCache:
    store = {}
    def get(self, k): return self.store.get(k)
    def set(self, k, v, timeout=None): self.store[k] = v
```

```python
def test_service_with_fake_cache(monkeypatch):
    from app import services
    services.cache = FakeCache()
    # cache에 의존하는 함수 테스트
```

---

## 계약 테스트(Consumer-Driven Contracts, Pact)

**문제**: 마이크로서비스나 외부 API가 자주 변경될 때 **통합 테스트만으로는 사전 탐지**가 어렵습니다.
**해법**: **소비자(Consumer)** 가 기대하는 **계약**을 명시하고, **제공자(Provider)** 가 이를 만족하는지 **독립적으로 검증**합니다.

### 소비자 측(Pact 파일 생성)

```python
# tests/contract/test_consumer_pact.py

import pytest
from pact import Consumer, Provider

pact = Consumer("orders-frontend").has_pact_with(Provider("billing-api"))
pact.start_service()

def test_get_invoice_contract():
    # 기대 계약 정의
    (pact
     .given("invoice 100 exists")
     .upon_receiving("a request for invoice 100")
     .with_request("GET", "/invoices/100")
     .will_respond_with(200, body={"id": "100", "amount": 129.9, "status":"paid"}))

    with pact:
        # 실제 소비자 코드(더블 엔드포인트로 호출)
        import requests
        r = requests.get(pact.uri + "/invoices/100")
        assert r.status_code == 200
        data = r.json()
        assert "amount" in data

    pact.stop_service()
```

이렇게 생성된 **pact 파일**을 **브로커**(Pact Broker 등)에 업로드하여 제공자 파이프라인에서 검증합니다.

### 제공자 측(계약 검증)

```python
# tests/contract/test_provider_pact_verify.py

import pytest
from pact import Verifier

def test_verify_pacts():
    verifier = Verifier(provider="billing-api")
    # pact 브로커 혹은 로컬 파일 기반
    output, _ = verifier.verify_pacts("./pacts/orders-frontend-billing-api.json",
                                      provider_base_url="http://localhost:5001")
    assert output == 0
```

**운영 포인트**: **버전/환경** 태그를 활용해 **스테이징/프로덕션** 별 계약을 관리합니다.
**스키마 드리프트**는 **계약 실패**로 즉시 감지됩니다.

---

## Flask CLI 테스트 자동화

### CLI 명령(Click 기반)

```python
# app/cli/commands.py

import click
from flask import current_app
from app.extensions import db
from app.models import User

@click.command("create-admin")
@click.option("--email", prompt=True)
def create_admin(email):
    u = User(email=email, is_admin=True)
    db.session.add(u); db.session.commit()
    click.echo(f"created admin: {u.id}")

def register_cli(app):
    app.cli.add_command(create_admin)
```

앱 등록:

```python
# app/__init__.py (create_app 내부)

from .cli.commands import register_cli
register_cli(app)
```

### 테스트

```python
# tests/unit/test_cli.py

def test_create_admin_cli(runner, db):
    result = runner.invoke(args=["create-admin"], input="boss@example.com\n")
    assert result.exit_code == 0
    assert "created admin:" in result.output
```

---

## 고급 기법: Property-based, Snapshot, Golden Master

### Hypothesis(성질 기반 테스트)

```python
# pip install hypothesis

from hypothesis import given, strategies as st
from app.services.pricing import calc_total

@given(st.lists(st.tuples(st.decimals(min_value=0), st.integers(min_value=0)), min_size=1))
def test_calc_total_non_negative(items):
    total = calc_total(items, discount=0)
    assert total >= 0
```

### 스냅샷/골든 파일

- JSON 응답/렌더 템플릿을 **스냅샷**으로 남기고 **회귀** 감지
- 파라미터 변경으로 쉽게 깨질 수 있어, **중요 출력에 한정**해서 사용

---

## 격리 문제 해결

- **랜덤 시드 고정**: `pytest-randomly`
- **시간 의존**: freezegun
- **네트워크 의존 제거**: responses/respx
- **파일 시스템 고립**: `tmp_path`
- **글로벌 상태/싱글톤**: 테스트 후 **reset**(픽스처 finalizer)
- **비결정 동시성**: 폴링/슬립 대신 **조건 대기**(exponential backoff + 타임아웃)

---

## CI 구성(예: GitHub Actions)

```yaml
# .github/workflows/test.yml

name: tests
on: [push, pull_request]
jobs:
  pytest:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        ports: ["5432:5432"]
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=5s --health-timeout=5s --health-retries=5
    env:
      DATABASE_URL: postgresql://postgres:postgres@localhost:5432/testdb
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: {python-version: "3.11"}
      - run: pip install -r requirements-dev.txt
      - run: pip install -e .
      - run: pytest --cov=app --cov-report=xml
      - uses: codecov/codecov-action@v4
        with: {files: ./coverage.xml}
```

---

## 성능 최적화: 테스트가 느려질 때

- **픽스처 재사용**: session/module scope로 비싼 초기화 최소화
- **트랜잭션 롤백**: DB 재생성 대신 **rollback**으로 고립 (이미 적용)
- **xdist 병렬화**: `-n auto`; DB는 **각 워커별 DB**(SQLite 파일/PG 스키마) 분리
- **선택 실행**: `pytest -m "unit and not slow"` / `-k "keyword"`
- **프로파일링**: `pytest --durations=20` 로 느린 20개 테스트 식별

---

## 품질 게이트: 린터/포맷터/타입체커와 결합

- **ruff/flake8**: 스타일/잠재 버그
- **black**: 포맷 통일
- **mypy/pyright**: 정적 타입
- **pre-commit** 훅으로 PR 전에 자동 실행

```yaml
# .pre-commit-config.yaml

repos:
- repo: https://github.com/psf/black
  rev: 24.8.0
  hooks: [{id: black}]
- repo: https://github.com/astral-sh/ruff-pre-commit
  rev: v0.6.9
  hooks: [{id: ruff}]
```

---

## 흔한 안티패턴

- **테스트에서 실제 외부 API 호출**: 느리고 깨지기 쉬움 → **더블** 사용
- **DB에 commit 남발**: 단위 테스트에서 굳이 commit 불필요 → **flush 또는 롤백** 패턴
- **대형 통합 테스트만 의존**: 실패 지점 파악 어려움, 유지비↑ → **단위 테스트 우선**
- **커버리지 숫자 집착**: 무의미한 라인 강제 → **중요 분기/에러 경로** 커버리지에 집중
- **전역 상태 오염**: 테스트 간 의존 → 픽스처 격리와 finalizer 필수
- **시간/난수/순서 의존**: 랜덤/시간 고정 없이 작성 → **freezegun/pytest-randomly**

---

## 붙여넣기 스타터 패키지

### 최소 conftest + app factory

```python
# tests/conftest.py (요약)

import pytest
from app import create_app
from app.extensions import db as _db

@pytest.fixture(scope="session")
def app():
    app = create_app("testing")
    with app.app_context():
        yield app

@pytest.fixture(scope="session")
def db(app):
    _db.create_all()
    yield _db
    _db.drop_all()

@pytest.fixture(autouse=True)
def session(db):
    con = db.engine.connect(); tx = con.begin()
    session = db.create_scoped_session(bind=con)
    db.session = session
    yield session
    tx.rollback(); con.close(); session.remove()

@pytest.fixture
def client(app):
    return app.test_client()
```

### 커버리지 & 명령

```bash
pytest -q --cov=app --cov-report=term-missing
pytest -n auto --dist=loadscope
```

---

## 결론

이번 섹션에서는 Flask 애플리케이션을 위한 포괄적인 테스트 전략과 인프라를 살펴보았습니다. pytest 기반의 테스트 환경 구축부터 시작하여, 효율적인 픽스처 설계, 다양한 유형의 테스트 작성 방법, 그리고 테스트 품질 관리에 이르기까지 현대적인 테스트 체계의 모든 요소를 다루었습니다.

테스트의 핵심은 적절한 수준의 격리와 속도, 그리고 의미 있는 실패 메시지를 제공하는 데 있습니다. 단위 테스트에서는 외부 의존성을 적절히 모의(mocking)하여 빠르게 실행되도록 하고, 통합 테스트에서는 실제 데이터베이스와의 상호작용을 검증하며, 계약 테스트를 통해 서비스 간의 인터페이스를 안정적으로 유지합니다.

테스트 인프라를 올바르게 구축하면 개발 주기를 가속화하고 리팩토링에 대한 자신감을 높일 수 있습니다. CI/CD 파이프라인에 테스트를 통합하고 품질 게이트를 설정하면 코드베이스의 건강을 지속적으로 모니터링할 수 있습니다.

실제 프로젝트에서는 비즈니스 도메인의 복잡성과 팀의 요구사항에 맞게 이러한 패턴들을 적절히 조정하고 적용해야 합니다. 초기부터 견고한 테스트 인프라를 구축하면 장기적으로 코드 품질을 유지하고 유지보수 비용을 절감하는 데 크게 기여할 것입니다. 테스트는 비용이 아니라 투자라는 마음가짐으로 접근하면, 더 견고하고 신뢰할 수 있는 소프트웨어를 개발할 수 있습니다.