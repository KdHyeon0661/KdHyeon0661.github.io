---
layout: post
title: C++ - 템플릿
date: 2024-09-10 19:20:23 +0900
category: Cpp
---
# 템플릿 완전 정리: 함수/클래스 템플릿부터 특수화, SFINAE, Concepts, 가변 템플릿, CTAD, CRTP까지

## 0) 한눈 요약 (핵심 체크리스트)

- **함수/클래스 템플릿**: 형식(T) 일반화. STL 전부가 여기에 기반.  
- **특수화**: 전용 타입 처리(예: `Printer<bool>`). **부분 특수화**는 클래스/변수 템플릿에만 가능(함수는 불가 → 오버로드/도우미 타입로 해결).  
- **NTTP(비타입 인수)**: `std::array<int, N>`, `fixed_string`, `std::span`. C++20부터 비정수/포인터 등 더 유연.  
- **가변 템플릿** + **폴드식**: 임의 개수 인자 처리.  
- **SFINAE/enable_if/void_t** → **Concepts**: 조건부 템플릿 참여를 제어. C++20 `requires`로 가독성↑.  
- **CTAD/추론 가이드**: `std::pair p{1,2};` 처럼 클래스 템플릿 인수 유추.  
- **완벽 전달/전달 참조**: `T&&` + `std::forward<T>`로 원본 값범주 유지.  
- **CRTP/정책 기반 설계**: 정적 다형성/믹스인.  
- **ODR/명시적 인스턴스화/extern template**: 컴파일·링크 최적화와 오류 회피.  
- **타입 트레이트/메타프로그래밍**: `std::conditional`, `std::enable_if_t`, `std::integral_constant`, `std::type_identity`, `std::ranges`와 함께.

---

## 1) 함수 템플릿 — 기본에서 안전한 오버로드까지

### 1.1 기초: 제네릭 `add`

```cpp
#include <iostream>
template <typename T>
T add(T a, T b) { return a + b; }

int main(){
    std::cout << add<int>(3,4) << "\n";       // 7
    std::cout << add(1.2, 3.4) << "\n";       // 4.6 (인수로부터 추론)
}
```

- `template <typename T>`와 `template <class T>`는 **동의어**.
- 함수 템플릿은 **오버로드 후보**로 참가한다(일반 함수와도 경쟁).

### 1.2 템플릿 오버로드 vs 일반 함수 오버로드

```cpp
#include <string>
template <typename T>
T add(T a, T b){ return a + b; }

int add(int a, int b){ return a + b + 1; } // 일반 함수

int main(){
    // 정확히 일치하는 일반 함수가 우선
    // 결과: 3+4+1 = 8
    return add(3,4);
}
```

> **규칙**: 동일 가중치면 **일반 함수가 템플릿보다 우선**.

---

## 2) 클래스 템플릿 — 기본, 부분 특수화, 멤버 템플릿

### 2.1 기초

```cpp
#include <string>
template <typename T>
class Box {
    T data_;
public:
    void set(T v){ data_ = v; }
    T get() const { return data_; }
};
```

### 2.2 부분 특수화 (클래스/변수 템플릿에서만 가능)

```cpp
#include <iostream>
template <typename T>
struct Printer { static void print(const T& v){ std::cout << v << "\n"; } };

// 부분 특수화: 포인터 타입 전용
template <typename T>
struct Printer<T*> {
    static void print(T* p){ std::cout << "ptr:" << *p << "\n"; }
};

int main(){
    Printer<int>::print(42);              // 42
    int x=7; Printer<int*>::print(&x);    // ptr:7
}
```

### 2.3 함수 템플릿 “특수화”는 왜 골치 아픈가?
- 함수 템플릿은 **부분 특수화가 불가능**. 대신
  1) **오버로드**를 제공하거나  
  2) 클래스 템플릿에 위임(정적 멤버 호출)하는 패턴을 사용.

---

## 3) 템플릿 특수화 — 전면/부분

### 3.1 전면 특수화(전용 타입)

```cpp
#include <iostream>
template <typename T>
struct Show { static void go(const T& v){ std::cout<<v<<"\n"; } };

template <>
struct Show<bool> {
    static void go(bool v){ std::cout << (v?"true":"false") << "\n"; }
};

int main(){ Show<bool>::go(true); } // true
```

### 3.2 부분 특수화와 패턴 매칭

```cpp
template <typename T> struct Wrapper;
template <typename T> struct Wrapper<T*> { /* 포인터 전용 */ };
template <typename T, std::size_t N> struct Wrapper<T[N]> { /* 배열 전용 */ };
```

---

## 4) 비타입 템플릿 인수(NTTP)

### 4.1 정수/열거/포인터/참조/클래스 형식의 값 인수 (C++20 확대)

```cpp
#include <array>
template <typename T, std::size_t N>
struct MatrixRow { std::array<T, N> data; };
```

### 4.2 `fixed_string`로 문자열 리터럴 길이/내용을 형식 차원에서 사용

```cpp
#include <utility>
template <std::size_t N>
struct fixed_string {
    char s[N];
    constexpr fixed_string(const char(&str)[N]) noexcept : s{} {
        for(std::size_t i=0;i<N;i++) s[i]=str[i];
    }
};
template <fixed_string Name>
struct Named { static constexpr auto name = Name; };

int main(){
    // 형식 자체가 "hello"로 구분됨
    (void)Named<"hello">{};
}
```

---

## 5) 가변 템플릿(Variadic Templates) & 폴드식(Fold Expression)

### 5.1 가변 인자 팩

```cpp
template <typename... Ts>
void print_all(const Ts&... xs){
    (std::cout << ... << xs) << "\n"; // C++17 오른쪽 폴드
}
```

### 5.2 커스텀 누적

```cpp
template <typename... Ts>
auto sum(Ts... xs){
    return (xs + ... + 0); // ((x1 + x2) + ... ) + 0
}
```

> 폴드식은 **빈 팩** 허용 여부/초깃값에 유의.

---

## 6) `auto`/`decltype`/반환 형식 추론/트레일링 반환

```cpp
template <typename T, typename U>
auto mul(T a, U b) -> decltype(a*b) { return a*b; }
```

- C++14부터는 **함수 반환 형식도 추론**: `auto f(){ return 42; }`
- `decltype((x))` vs `decltype(x)` 차이(참조 유지/제거)에 유의.

---

## 7) CTAD (Class Template Argument Deduction) & Deduction Guides

```cpp
#include <utility>
std::pair p{1, 2.0}; // C++17 CTAD → pair<int,double>
```

직접 가이드를 줄 수도 있다:

```cpp
template <typename T> struct Vec { Vec(int n, T v); /*...*/ };
// 가이드: (int, int) → Vec<int>
Vec(int, int) -> Vec<int>;
```

---

## 8) SFINAE / `enable_if` / `void_t` / Detection idiom

### 8.1 SFINAE(서브스티튜션 실패는 오류 아님)

```cpp
#include <type_traits>
template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
T twice(T v){ return v*2; }

static_assert(twice(3) == 6);
// twice(3.1); // ❌ 참여 불가
```

### 8.2 `void_t` & 검출 관용구(detection idiom)

```cpp
template <typename, typename=void>
struct has_push_back : std::false_type{};

template <typename T>
struct has_push_back<T, std::void_t<decltype(std::declval<T&>().push_back(std::declval<typename T::value_type>()))>>
: std::true_type{};

static_assert( has_push_back<std::vector<int>>::value );
```

> C++20 Concepts로 더 간결하게 대체 가능(§9).

---

## 9) Concepts / `requires` / 제약 기반 오버로드

### 9.1 기본 컨셉과 `requires`

```cpp
#include <concepts>

template <std::integral T>
T gcd(T a, T b){
    while(b){ auto t=a%b; a=b; b=t; }
    return a;
}

template <typename T>
requires requires(T x){ x.begin(); x.end(); } // 임시 컨셉 표현
auto head(T&& c){ return *c.begin(); }
```

### 9.2 오버로드 해소 가독성/에러 메시지 품질 향상

```cpp
template <std::ranges::input_range R>
auto sum(R&& r){
    typename std::ranges::range_value_t<R> s{};
    for(auto&& x : r) s += x;
    return s;
}
```

---

## 10) 전달 참조(Forwarding Reference) & 완벽 전달(Perfect Forwarding)

### 10.1 핵심

- 함수 템플릿에서 `T&&`는 **전달 참조**(이전 “유니버설 참조”)가 됨.
- `std::forward<T>(x)`로 **값범주 유지**.

```cpp
#include <utility>
template <typename T, typename... Args>
T make(Args&&... args){
    return T(std::forward<Args>(args)...);
}
```

> **규칙**: rvalue는 rvalue로, lvalue는 lvalue로 전달.

---

## 11) 별칭 템플릿 / 변수 템플릿 / 기본 템플릿 인자

### 11.1 별칭 템플릿

```cpp
template <typename K, typename V>
using umap = std::unordered_map<K,V>;
umap<std::string,int> m;
```

### 11.2 변수 템플릿

```cpp
template <typename T>
inline constexpr bool is_int_v = std::is_same_v<T,int>;

static_assert(is_int_v<int>);
```

### 11.3 기본 템플릿 인자

```cpp
template <typename T, typename Alloc = std::allocator<T>>
struct Vec { /*...*/ };
```

---

## 12) 템플릿 템플릿 인자

```cpp
template <template <typename...> class Container, typename T>
struct Holder {
    Container<T> c;
};

Holder<std::vector,int> h; // OK
```

---

## 13) 인스턴스화/ODR/링커 — 헤더 전개, 명시적 인스턴스화, extern template

### 13.1 헤더 전개(헤더 온리)

- 템플릿 정의는 **헤더**에 둔다(ODR 일관성).  
- 다수 TU에서 동일 정의 필요.

### 13.2 명시적 인스턴스화 & extern template

```cpp
// lib.cpp
template class std::vector<int>;          // 강제 인스턴스화
// lib.hpp
extern template class std::vector<int>;   // 다른 TU에서 중복 생성 억제
```

> 대규모 코드에서 **빌드 시간 감축**/중복 기계어 감소.

---

## 14) CRTP (Curiously Recurring Template Pattern) / 정책 기반 설계

### 14.1 CRTP — 정적 다형성/믹스인

```cpp
template <typename Derived>
struct Comparable {
    bool operator==(const Derived& other) const {
        auto& self = static_cast<const Derived&>(*this);
        return self.key() == other.key();
    }
};

struct User : Comparable<User> {
    int id;
    int key() const { return id; }
};
```

- **가상 함수 비용 없이** 재사용 가능한 행태 주입.

### 14.2 정책 기반

```cpp
template <typename AllocPolicy, typename LogPolicy>
class Engine : private AllocPolicy, private LogPolicy {
public:
    void run(){
        this->log("start");
        auto p = this->alloc(1024);
        // ...
        this->free(p);
    }
};
```

- 정책 조합으로 **구성 가능성** ↑, 런타임 비용 0.

---

## 15) 태그 디스패치 / ADL

### 15.1 태그 기반 오버로드

```cpp
struct RandomAccessTag{};
struct ForwardTag{};

template <typename It>
void advance_impl(It& it, int n, RandomAccessTag){ it += n; }

template <typename It>
void advance_impl(It& it, int n, ForwardTag){ while(n--) ++it; }
```

### 15.2 ADL(Argument-Dependent Lookup)

- `swap(a,b)` 호출 시 `std::swap`과 **사용자 정의 네임스페이스**의 `swap` 중 인자 네임스페이스를 고려해 탐색.

```cpp
using std::swap;
swap(a,b); // ADL로 최적 특화 버전 선택
```

---

## 16) 타입 트레이트와 메타프로그래밍

### 16.1 대표 트레이트

- `std::integral_constant`, `std::bool_constant`, `std::conditional_t`, `std::enable_if_t`
- `std::remove_reference_t`, `std::decay_t`, `std::invoke_result_t`
- `std::is_same_v`, `std::is_constructible_v`, `std::is_invocable_v`

```cpp
template <typename T>
using enable_if_integral_t = std::enable_if_t<std::is_integral_v<T>, int>;

template <typename T>
enable_if_integral_t<T> foo(T){ return 0; } // 정수형만 참여
```

### 16.2 간단한 컴파일타임 선택

```cpp
template <typename T>
constexpr const char* kind(){
    if constexpr (std::is_integral_v<T>) return "integral";
    else if constexpr (std::is_floating_point_v<T>) return "fp";
    else return "other";
}
static_assert(kind<int>() == std::string("integral"));
```

---

## 17) 가변템플릿 실전: 로깅/형식화/튜플 순회

```cpp
#include <tuple>
template <typename F, typename Tuple, std::size_t... Is>
void tuple_for_each_impl(Tuple&& t, F&& f, std::index_sequence<Is...>){
    (f(std::get<Is>(t)), ...);
}
template <typename F, typename Tuple>
void tuple_for_each(Tuple&& t, F&& f){
    tuple_for_each_impl(std::forward<Tuple>(t), std::forward<F>(f),
                        std::make_index_sequence<std::tuple_size_v<std::remove_reference_t<Tuple>>>{});
}
```

---

## 18) 복잡도/빌드 성능에 대한 메모

- 템플릿은 **인스턴스화된 타입 수만큼 코드 생성**.  
  생성 수를 $$k$$, 각 본문 컴파일 시간 $$T_c$$라 하면 대략
  $$
  T_{\text{build}} \approx \sum_{i=1}^{k} T_c(T_i)
  $$
- **헤더 분리/전방 선언/extern template/개발 단계 전용 최소 헤더 포함**으로 빌드 시간 관리.

---

## 19) 실전에서 자주 쓰는 안전 패턴

1) **컨셉으로 명시적 제약**:
```cpp
template <std::regular T> // ranges/concepts
struct registry { /*...*/ };
```

2) **완벽 전달 래퍼**:
```cpp
template <typename F, typename... Args>
decltype(auto) call(F&& f, Args&&... args){
    return std::forward<F>(f)(std::forward<Args>(args)...);
}
```

3) **범위 기반 유틸**:
```cpp
template <std::ranges::input_range R, typename T = std::ranges::range_value_t<R>>
T sum(R&& r){ T s{}; for(auto&& x: r) s+=x; return s; }
```

---

## 20) 함정 모음과 교정

- **함수 템플릿 부분 특수화 없음** → **오버로드 or 클래스 경유**.  
- **의존 이름(dependent name)**: `typename`, `template` 키워드 필요.
```cpp
template <typename T>
void f(){
    typename T::inner t;   // T에 종속된 타입 앞에는 typename
    t.template g<int>();   // 종속 템플릿 멤버 호출엔 template 키워드
}
```
- **가변 팩 펼치기 쉼표 연산자** 부작용 주의 → 폴드식 권장.  
- **`auto`/`decltype(auto)`** 반환에서 **값범주 변화** 주의.  
- **CTAD 오판정** → 명시적 템플릿 인수를 써서 고정.  
- **ODR 위반**: 헤더/소스 분리에 실패 → 항상 **정의는 헤더**, 소스에는 **명시적 인스턴스화**만.

---

## 21) 종합 예제: Constraints + Forwarding + CTAD + Traits

```cpp
#include <concepts>
#include <utility>
#include <type_traits>
#include <iostream>

// 1) 컨셉: 덧셈 가능
template <typename T>
concept Addable = requires(T a, T b) { a + b; };

// 2) 전달 참조 + 완벽 전달 + 제약
template <Addable T, Addable U>
decltype(auto) add_forward(T&& a, U&& b){
    return std::forward<T>(a) + std::forward<U>(b);
}

// 3) 클래스 템플릿 + CTAD + deduction guide
template <typename T>
struct Box {
    T v;
    template <typename U>
    explicit Box(U&& x) : v(std::forward<U>(x)) {}
};
template <typename U> Box(U&&) -> Box<std::decay_t<U>>;

// 4) traits 기반 출력
template <typename T>
void print_kind(const T&){
    if constexpr (std::is_integral_v<T>)      std::cout << "integral\n";
    else if constexpr (std::is_floating_point_v<T>) std::cout << "fp\n";
    else std::cout << "other\n";
}

int main(){
    auto x = add_forward(3, 4);       // 7
    auto y = add_forward(1.2, 2.3);   // 3.5
    Box b{42};                        // CTAD → Box<int>
    print_kind(b.v);                  // integral
    std::cout << x << "," << y << "\n";
}
```

---

## 22) STL과 템플릿의 연결 (당신의 초안 확장)

- `std::vector<T>`, `std::map<K,V>`, `std::optional<T>`, `std::variant<...>`, `std::span<T,N>` 등은 **클래스 템플릿**.  
- `std::begin/end`, `std::move/forward`, `std::make_unique/make_shared` 등은 **함수 템플릿**.  
- `std::less<>`, `std::hash<T>`, `std::allocator<T>`는 **부분 특수화/기본 인자**의 교과서 예.

---

## 23) 마무리 요약

| 주제 | 포인트 |
|---|---|
| 함수/클래스 템플릿 | 형식 일반화, STL의 기초 |
| 특수화 | 전면/부분. 함수 부분 특수화는 불가(오버로드로 해결) |
| NTTP | `std::array<T,N>`, `fixed_string`, `span` |
| 가변 템플릿/폴드 | 임의 인자 수 처리 |
| SFINAE/enable_if/void_t | 참여 제어(전통식) |
| Concepts/requires | C++20 현대식 제약, 가독성/에러 품질↑ |
| CTAD/가이드 | 형식 명시 없이도 생성 |
| 전달 참조/완벽 전달 | 값범주 보존, 성능/정확성 핵심 |
| 별칭/변수 템플릿 | 가독성↑, 상수의 형식화 |
| 템플릿 템플릿 | 컨테이너 정책 등 고수준 조립 |
| 인스턴스화/ODR | 헤더 온리/명시적 인스턴스화/extern template |
| CRTP/정책 설계 | 정적 다형성/믹스인/오버헤드 0 |
| 태그/ADL | 최적 특화 선택/알고리즘 분기 |
| 트레이트/메타 | 컴파일타임 분기와 타입 계산 |

> 템플릿을 이해하면 **STL 구조가 투명해지고**, 성능과 안전을 동시에 달성할 수 있다.  
> **Concepts + 가변 템플릿 + 완벽 전달**은 현대 C++ 제네릭 프로그래밍의 3축이다.