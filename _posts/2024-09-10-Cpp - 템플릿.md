---
layout: post
title: C++ - 템플릿
date: 2024-09-10 19:20:23 +0900
category: Cpp
---
# 템플릿 완전 정리: 함수/클래스 템플릿부터 특수화, SFINAE, Concepts, 가변 템플릿, CTAD, CRTP까지

## 함수 템플릿 — 기본에서 안전한 오버로드까지

### 기초: 제네릭 함수

함수 템플릿은 타입을 매개변수화하여 동일한 로직을 여러 타입에 대해 재사용할 수 있게 한다. 가장 기본적인 예로 두 값을 더하는 제네릭 함수를 살펴보자.

```cpp
#include <iostream>

template <typename T>
T add(T a, T b) { return a + b; }

int main(){
    std::cout << add<int>(3,4) << "\n";       // 7
    std::cout << add(1.2, 3.4) << "\n";       // 4.6 (인수로부터 추론)
}
```

`template <typename T>`와 `template <class T>`는 완전히 동일한 의미를 가진다. 함수 템플릿은 컴파일러가 호출 시점의 인자 타입을 통해 자동으로 템플릿 인수를 추론할 수 있으며, 일반 함수와 함께 오버로드 후보로 참가한다.

### 템플릿 오버로드 vs 일반 함수 오버로드

```cpp
#include <string>

template <typename T>
T add(T a, T b){ return a + b; }

int add(int a, int b){ return a + b + 1; } // 일반 함수

int main(){
    // 정확히 일치하는 일반 함수가 우선
    // 결과: 3+4+1 = 8
    return add(3,4);
}
```

템플릿 함수와 일반 함수가 동시에 존재하고 동일한 가중치로 매칭되는 경우, 컴파일러는 일반 함수를 우선 선택한다. 이는 템플릿이 더 범용적인 솔루션이고 일반 함수가 더 특화된 구현이라는 원칙을 따른다.

---

## 클래스 템플릿 — 기본, 부분 특수화, 멤버 템플릿

### 기초

클래스 템플릿은 데이터 구조를 타입에 독립적으로 정의할 수 있게 해준다. STL의 대부분 컨테이너가 클래스 템플릿으로 구현되어 있다.

```cpp
#include <string>

template <typename T>
class Box {
    T data_;
public:
    void set(T v){ data_ = v; }
    T get() const { return data_; }
};
```

### 부분 특수화 (클래스/변수 템플릿에서만 가능)

클래스 템플릿은 부분 특수화를 지원한다. 이를 통해 특정 패턴의 타입에 대해 다른 구현을 제공할 수 있다.

```cpp
#include <iostream>

template <typename T>
struct Printer { static void print(const T& v){ std::cout << v << "\n"; } };

// 부분 특수화: 포인터 타입 전용
template <typename T>
struct Printer<T*> {
    static void print(T* p){ std::cout << "ptr:" << *p << "\n"; }
};

int main(){
    Printer<int>::print(42);              // 42
    int x=7; Printer<int*>::print(&x);    // ptr:7
}
```

### 함수 템플릿 "특수화"는 왜 골치 아픈가?

함수 템플릿은 부분 특수화를 지원하지 않는다. 이는 C++의 오버로드 해소 규칙과 충돌을 피하기 위한 설계 결정이다. 대신 함수 오버로드를 제공하거나, 필요한 경우 클래스 템플릿에 위임하는 패턴을 사용해야 한다.

---

## 템플릿 특수화 — 전면/부분

### 전면 특수화(전용 타입)

전면 특수화는 특정 타입에 대해 완전히 다른 구현을 제공한다. 예를 들어 bool 타입에 대해서는 "true"/"false" 문자열로 출력하도록 특수화할 수 있다.

```cpp
#include <iostream>

template <typename T>
struct Show { static void go(const T& v){ std::cout<<v<<"\n"; } };

template <>
struct Show<bool> {
    static void go(bool v){ std::cout << (v?"true":"false") << "\n"; }
};

int main(){ Show<bool>::go(true); } // true
```

### 부분 특수화와 패턴 매칭

부분 특수화를 사용하면 포인터, 배열, 특정 템플릿 인스턴스 등의 패턴에 대해 특별한 처리를 정의할 수 있다.

```cpp
template <typename T> struct Wrapper;
template <typename T> struct Wrapper<T*> { /* 포인터 전용 */ };
template <typename T, std::size_t N> struct Wrapper<T[N]> { /* 배열 전용 */ };
```

---

## 비타입 템플릿 인수(NTTP)

### 정수/열거/포인터/참조/클래스 형식의 값 인수

비타입 템플릿 인수는 타입이 아닌 값을 템플릿 매개변수로 받을 수 있게 한다. 전통적으로는 정수, 열거형, 포인터, 참조만 가능했지만, C++20부터는 클래스 타입도 사용할 수 있게 되었다.

```cpp
#include <array>

template <typename T, std::size_t N>
struct MatrixRow { std::array<T, N> data; };
```

### `fixed_string`로 문자열 리터럴을 형식 차원에서 사용

C++20의 확장된 NTTP 지원을 활용하면 문자열 리터럴을 템플릿 인수로 직접 전달할 수 있다. 이를 위해서는 문자열을 감싸는 클래스 타입이 필요하다.

```cpp
#include <utility>

template <std::size_t N>
struct fixed_string {
    char s[N];
    constexpr fixed_string(const char(&str)[N]) noexcept : s{} {
        for(std::size_t i=0;i<N;i++) s[i]=str[i];
    }
};
template <fixed_string Name>
struct Named { static constexpr auto name = Name; };

int main(){
    // 형식 자체가 "hello"로 구분됨
    (void)Named<"hello">{};
}
```

---

## 가변 템플릿과 폴드식(Fold Expression)

### 가변 인자 팩

가변 템플릿은 임의 개수의 템플릿 인수를 받을 수 있게 한다. 이는 printf 스타일의 함수나 튜플 같은 자료구조를 구현하는 데 필수적이다.

```cpp
template <typename... Ts>
void print_all(const Ts&... xs){
    (std::cout << ... << xs) << "\n"; // C++17 오른쪽 폴드
}
```

### 커스텀 누적

폴드식을 사용하면 가변 인자 팩에 대해 이항 연산을 간결하게 적용할 수 있다. 초깃값을 제공하면 빈 팩에 대해서도 안전하게 동작한다.

```cpp
template <typename... Ts>
auto sum(Ts... xs){
    return (xs + ... + 0); // ((x1 + x2) + ... ) + 0
}
```

폴드식을 사용할 때는 빈 팩의 허용 여부와 초깃값의 필요성을 신중히 고려해야 한다.

---

## `auto`/`decltype`/반환 형식 추론/트레일링 반환

반환 타입 추론은 템플릿 함수에서 특히 유용하다. 두 타입의 곱셈 결과 타입을 명시하기 어려운 경우, decltype을 사용한 후행 반환 타입 선언이나 auto 반환 타입 추론을 활용할 수 있다.

```cpp
template <typename T, typename U>
auto mul(T a, U b) -> decltype(a*b) { return a*b; }
```

C++14부터는 함수 반환 형식도 자동 추론된다(`auto f(){ return 42; }`). 다만 `decltype((x))`와 `decltype(x)`는 다르게 동작하므로 주의해야 한다. 전자는 참조를 유지하고 후자는 제거한다.

---

## CTAD와 Deduction Guides

### 클래스 템플릿 인수 추론(CTAD)

C++17부터 클래스 템플릿도 함수 템플릿처럼 인수 추론이 가능해졌다. 생성자 인자로부터 템플릿 인수를 자동으로 추론하므로 코드가 더욱 간결해진다.

```cpp
#include <utility>

std::pair p{1, 2.0}; // C++17 CTAD → pair<int,double>
```

### 사용자 정의 추론 가이드

직접 추론 가이드를 작성하여 CTAD의 동작을 커스터마이즈할 수 있다. 이는 생성자 인자만으로는 의도한 타입을 추론하기 어려운 경우 유용하다.

```cpp
template <typename T> struct Vec { Vec(int n, T v); /*...*/ };
// 가이드: (int, int) → Vec<int>
Vec(int, int) -> Vec<int>;
```

---

## SFINAE / `enable_if` / `void_t` / Detection idiom

### SFINAE(서브스티튜션 실패는 오류 아님)

SFINAE는 템플릿 치환 과정에서 발생한 실패를 오류가 아닌 "이 후보는 해당하지 않음"으로 처리하는 원칙이다. 이를 활용하면 특정 조건을 만족하는 타입에 대해서만 템플릿이 활성화되도록 제어할 수 있다.

```cpp
#include <type_traits>

template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
T twice(T v){ return v*2; }

static_assert(twice(3) == 6);
// twice(3.1); // ❌ 참여 불가
```

### `void_t`와 검출 관용구(detection idiom)

`void_t`는 임의의 타입 표현식이 유효한지 검사하는 메타프로그래밍 도구다. 이를 활용하면 특정 멤버 함수나 타입 멤버의 존재 여부를 컴파일 타임에 확인할 수 있다.

```cpp
template <typename, typename=void>
struct has_push_back : std::false_type{};

template <typename T>
struct has_push_back<T, std::void_t<decltype(std::declval<T&>().push_back(std::declval<typename T::value_type>()))>>
: std::true_type{};

static_assert( has_push_back<std::vector<int>>::value );
```

이러한 전통적인 SFINAE 기법은 C++20 Concepts로 대체하면 훨씬 더 간결하고 읽기 쉬운 코드를 작성할 수 있다.

---

## Concepts / `requires` / 제약 기반 오버로드

### 기본 컨셉과 `requires`

C++20 Concepts는 템플릿 매개변수에 대한 제약을 명시적이고 선언적으로 표현할 수 있게 한다. 이는 SFINAE보다 훨씬 직관적이며, 컴파일 에러 메시지의 품질도 크게 개선된다.

```cpp
#include <concepts>

template <std::integral T>
T gcd(T a, T b){
    while(b){ auto t=a%b; a=b; b=t; }
    return a;
}

template <typename T>
requires requires(T x){ x.begin(); x.end(); } // 임시 컨셉 표현
auto head(T&& c){ return *c.begin(); }
```

### 오버로드 해소 가독성과 에러 메시지 품질 향상

Concepts를 사용하면 템플릿 오버로드의 의도가 명확해지고, 제약을 만족하지 않는 타입으로 호출했을 때 훨씬 이해하기 쉬운 에러 메시지를 받을 수 있다.

```cpp
template <std::ranges::input_range R>
auto sum(R&& r){
    typename std::ranges::range_value_t<R> s{};
    for(auto&& x : r) s += x;
    return s;
}
```

---

## 전달 참조와 완벽 전달(Perfect Forwarding)

### 핵심 개념

함수 템플릿에서 `T&&`는 전달 참조(이전에는 "유니버설 참조"라 불림)가 된다. 이는 lvalue 참조와 rvalue 참조 모두를 받을 수 있는 특수한 참조 타입이다. `std::forward<T>(x)`를 사용하면 원본의 값범주(lvalue/rvalue)를 그대로 유지하면서 전달할 수 있다.

```cpp
#include <utility>

template <typename T, typename... Args>
T make(Args&&... args){
    return T(std::forward<Args>(args)...);
}
```

완벽 전달의 핵심 규칙은 간단하다. rvalue는 rvalue로, lvalue는 lvalue로 전달하여 원본의 특성을 보존하는 것이다. 이는 불필요한 복사를 피하면서도 의미론적 정확성을 유지한다.

---

## 별칭 템플릿 / 변수 템플릿 / 기본 템플릿 인자

### 별칭 템플릿

별칭 템플릿은 복잡한 템플릿 타입에 짧은 이름을 부여한다. typedef와 달리 템플릿 자체에 별칭을 붙일 수 있어 더욱 유연하다.

```cpp
template <typename K, typename V>
using umap = std::unordered_map<K,V>;
umap<std::string,int> m;
```

### 변수 템플릿

변수 템플릿은 타입 트레이트의 값을 더욱 간결하게 표현할 수 있게 한다. 표준 라이브러리의 `_v` 접미사 변수들이 모두 변수 템플릿이다.

```cpp
template <typename T>
inline constexpr bool is_int_v = std::is_same_v<T,int>;

static_assert(is_int_v<int>);
```

### 기본 템플릿 인자

템플릿 매개변수에 기본값을 제공하면 사용자가 일반적인 경우에 인자를 생략할 수 있어 편리하다.

```cpp
template <typename T, typename Alloc = std::allocator<T>>
struct Vec { /*...*/ };
```

---

## 템플릿 템플릿 인자

템플릿 자체를 템플릿 인자로 받을 수 있다. 이는 컨테이너 타입을 추상화하거나 정책 기반 설계에서 유용하다.

```cpp
template <template <typename...> class Container, typename T>
struct Holder {
    Container<T> c;
};

Holder<std::vector,int> h; // OK
```

---

## 템플릿 인스턴스화/ODR/링커 — 헤더 전개, 명시적 인스턴스화, extern template

### 헤더 전개(헤더 온리)

템플릿 정의는 일반적으로 헤더 파일에 위치해야 한다. 이는 각 번역 단위에서 템플릿을 인스턴스화할 수 있어야 하기 때문이다. ODR(One Definition Rule)은 모든 번역 단위에서 동일한 정의를 요구한다.

### 명시적 인스턴스화와 extern template

대규모 프로젝트에서는 동일한 템플릿 인스턴스가 여러 번역 단위에서 중복 생성되어 빌드 시간이 늘어날 수 있다. 명시적 인스턴스화와 extern template을 사용하면 이를 제어할 수 있다.

```cpp
// lib.cpp
template class std::vector<int>;          // 강제 인스턴스화
// lib.hpp
extern template class std::vector<int>;   // 다른 TU에서 중복 생성 억제
```

이 기법은 대규모 코드베이스에서 빌드 시간을 감축하고 중복 기계어 생성을 방지하는 데 효과적이다.

---

## CRTP와 정책 기반 설계

### CRTP — 정적 다형성과 믹스인

CRTP(Curiously Recurring Template Pattern)는 베이스 클래스가 파생 클래스를 템플릿 인자로 받는 패턴이다. 이를 통해 가상 함수 없이도 다형성을 구현할 수 있다.

```cpp
template <typename Derived>
struct Comparable {
    bool operator==(const Derived& other) const {
        auto& self = static_cast<const Derived&>(*this);
        return self.key() == other.key();
    }
};

struct User : Comparable<User> {
    int id;
    int key() const { return id; }
};
```

CRTP는 가상 함수 호출 비용 없이 재사용 가능한 행태를 주입할 수 있게 한다. 컴파일 타임에 모든 것이 결정되므로 런타임 오버헤드가 전혀 없다.

### 정책 기반 설계

정책 기반 설계는 여러 정책 클래스를 조합하여 복잡한 동작을 구성한다. 각 정책은 특정 측면(메모리 할당, 로깅, 동기화 등)을 담당하며, 템플릿 인자로 전달된다.

```cpp
template <typename AllocPolicy, typename LogPolicy>
class Engine : private AllocPolicy, private LogPolicy {
public:
    void run(){
        this->log("start");
        auto p = this->alloc(1024);
        // ...
        this->free(p);
    }
};
```

정책 조합을 통해 구성 가능성을 높이면서도 런타임 비용은 전혀 발생하지 않는다.

---

## 태그 디스패치와 ADL

### 태그 기반 오버로드

태그 디스패치는 알고리즘을 반복자 카테고리에 따라 최적화된 구현으로 분기하는 기법이다. 표준 라이브러리의 많은 알고리즘이 이 패턴을 사용한다.

```cpp
struct RandomAccessTag{};
struct ForwardTag{};

template <typename It>
void advance_impl(It& it, int n, RandomAccessTag){ it += n; }

template <typename It>
void advance_impl(It& it, int n, ForwardTag){ while(n--) ++it; }
```

### ADL(Argument-Dependent Lookup)

ADL은 함수 호출 시 인자의 네임스페이스를 고려하여 함수를 찾는 메커니즘이다. 이는 `swap` 같은 커스터마이제이션 포인트에서 중요하다.

```cpp
using std::swap;
swap(a,b); // ADL로 최적 특화 버전 선택
```

`swap(a,b)` 호출 시 컴파일러는 `std::swap`과 함께 `a`, `b`의 네임스페이스에 정의된 `swap`도 찾아서 가장 적합한 것을 선택한다.

---

## 타입 트레이트와 메타프로그래밍

### 대표적인 트레이트들

표준 라이브러리는 풍부한 타입 트레이트를 제공한다. `std::integral_constant`, `std::bool_constant`, `std::conditional_t`, `std::enable_if_t` 같은 기본 빌딩 블록부터 `std::remove_reference_t`, `std::decay_t`, `std::invoke_result_t` 같은 변환 트레이트까지 다양하다. `std::is_same_v`, `std::is_constructible_v`, `std::is_invocable_v` 등은 타입의 속성을 검사한다.

```cpp
template <typename T>
using enable_if_integral_t = std::enable_if_t<std::is_integral_v<T>, int>;

template <typename T>
enable_if_integral_t<T> foo(T){ return 0; } // 정수형만 참여
```

### 컴파일타임 분기

`if constexpr`를 사용하면 컴파일 타임에 조건에 따라 코드 경로를 선택할 수 있다. 선택되지 않은 분기는 인스턴스화되지도 않는다.

```cpp
template <typename T>
constexpr const char* kind(){
    if constexpr (std::is_integral_v<T>) return "integral";
    else if constexpr (std::is_floating_point_v<T>) return "fp";
    else return "other";
}
static_assert(kind<int>() == std::string("integral"));
```

---

## 가변템플릿 실전: 로깅/형식화/튜플 순회

가변 템플릿은 실전에서 매우 유용하다. 다음은 튜플의 각 요소에 함수를 적용하는 범용 유틸리티 예제다.

```cpp
#include <tuple>

template <typename F, typename Tuple, std::size_t... Is>
void tuple_for_each_impl(Tuple&& t, F&& f, std::index_sequence<Is...>){
    (f(std::get<Is>(t)), ...);
}
template <typename F, typename Tuple>
void tuple_for_each(Tuple&& t, F&& f){
    tuple_for_each_impl(std::forward<Tuple>(t), std::forward<F>(f),
                        std::make_index_sequence<std::tuple_size_v<std::remove_reference_t<Tuple>>>{});
}
```

이 패턴은 인덱스 시퀀스를 생성하고 폴드식으로 전개하여 각 요소에 접근한다.

---

## 복잡도와 빌드 성능에 대한 메모

템플릿은 인스턴스화된 타입 수만큼 코드를 생성한다. 생성 수를 $k$, 각 본문 컴파일 시간을 $T_c$라 하면 대략적인 빌드 시간은 다음과 같다.

$$
T_{\text{build}} \approx \sum_{i=1}^{k} T_c(T_i)
$$

따라서 헤더 분리, 전방 선언, extern template, 개발 단계 전용 최소 헤더 포함 등의 기법으로 빌드 시간을 관리해야 한다.

---

## 실전에서 자주 쓰는 안전 패턴

### 컨셉으로 명시적 제약

```cpp
template <std::regular T> // ranges/concepts
struct registry { /*...*/ };
```

### 완벽 전달 래퍼

```cpp
template <typename F, typename... Args>
decltype(auto) call(F&& f, Args&&... args){
    return std::forward<F>(f)(std::forward<Args>(args)...);
}
```

### 범위 기반 유틸리티

```cpp
template <std::ranges::input_range R, typename T = std::ranges::range_value_t<R>>
T sum(R&& r){ T s{}; for(auto&& x: r) s+=x; return s; }
```

---

## 흔한 함정과 교정 방법

### 함수 템플릿 부분 특수화 불가

함수 템플릿은 부분 특수화를 지원하지 않는다. 대신 오버로드를 사용하거나 클래스 템플릿을 경유해야 한다.

### 의존 이름(dependent name)

템플릿 내부에서 타입이나 템플릿에 의존하는 이름을 사용할 때는 `typename`이나 `template` 키워드가 필요하다.

```cpp
template <typename T>
void f(){
    typename T::inner t;   // T에 종속된 타입 앞에는 typename
    t.template g<int>();   // 종속 템플릿 멤버 호출엔 template 키워드
}
```

### 가변 팩 펼치기의 부작용

쉼표 연산자로 팩을 펼칠 때는 부작용에 주의해야 한다. 가능하면 폴드식을 사용하는 것이 안전하다.

### `auto`/`decltype(auto)` 반환의 값범주 변화

`auto`와 `decltype(auto)`는 값범주를 다르게 처리한다. 전자는 참조를 제거하고, 후자는 표현식의 값범주를 정확히 보존한다.

### CTAD 오판정

CTAD가 의도와 다르게 동작하면 명시적 템플릿 인수를 써서 고정해야 한다.

### ODR 위반

템플릿 정의는 항상 헤더에 두고, 소스 파일에는 명시적 인스턴스화만 작성해야 한다. 그렇지 않으면 ODR을 위반하여 정의되지 않은 동작이 발생할 수 있다.

---

## 종합 예제: Constraints + Forwarding + CTAD + Traits

여러 현대 C++ 템플릿 기능을 조합한 종합 예제를 살펴보자.

```cpp
#include <concepts>
#include <utility>
#include <type_traits>
#include <iostream>

// 1) 컨셉: 덧셈 가능
template <typename T>
concept Addable = requires(T a, T b) { a + b; };

// 2) 전달 참조 + 완벽 전달 + 제약
template <Addable T, Addable U>
decltype(auto) add_forward(T&& a, U&& b){
    return std::forward<T>(a) + std::forward<U>(b);
}

// 3) 클래스 템플릿 + CTAD + deduction guide
template <typename T>
struct Box {
    T v;
    template <typename U>
    explicit Box(U&& x) : v(std::forward<U>(x)) {}
};
template <typename U> Box(U&&) -> Box<std::decay_t<U>>;

// 4) traits 기반 출력
template <typename T>
void print_kind(const T&){
    if constexpr (std::is_integral_v<T>)      std::cout << "integral\n";
    else if constexpr (std::is_floating_point_v<T>) std::cout << "fp\n";
    else std::cout << "other\n";
}

int main(){
    auto x = add_forward(3, 4);       // 7
    auto y = add_forward(1.2, 2.3);   // 3.5
    Box b{42};                        // CTAD → Box<int>
    print_kind(b.v);                  // integral
    std::cout << x << "," << y << "\n";
}
```

이 예제는 Concepts를 사용한 제약, 완벽 전달을 통한 효율적 인자 전달, CTAD를 통한 타입 추론, 그리고 타입 트레이트를 활용한 컴파일타임 분기를 모두 보여준다.

---

## STL과 템플릿의 연결

표준 템플릿 라이브러리(STL)는 템플릿 기술의 집대성이다. `std::vector<T>`, `std::map<K,V>`, `std::optional<T>`, `std::variant<...>`, `std::span<T,N>` 같은 컨테이너와 타입들은 모두 클래스 템플릿으로 구현되어 있다. `std::begin/end`, `std::move/forward`, `std::make_unique/make_shared` 등은 함수 템플릿이다. `std::less<>`, `std::hash<T>`, `std::allocator<T>`는 부분 특수화와 기본 인자의 교과서적 예제다.

STL의 설계 원칙을 이해하면 자신만의 제네릭 라이브러리를 작성할 때 큰 도움이 된다. 반복자 추상화, 알고리즘과 데이터 구조의 분리, 정책 기반 커스터마이제이션 등 모든 것이 템플릿을 기반으로 한다.

---

## 결론

템플릿은 C++의 가장 강력한 기능 중 하나로, 타입 안전성을 유지하면서도 코드 재사용성을 극대화한다. 함수 템플릿과 클래스 템플릿의 기본부터 시작해서, 특수화를 통한 세밀한 제어, 비타입 템플릿 인수를 활용한 컴파일타임 계산, 가변 템플릿과 폴드식을 통한 임의 개수 인자 처리까지 다양한 기법을 제공한다.

전통적인 SFINAE와 `enable_if`는 조건부 템플릿 참여를 제어하는 강력한 도구였지만, C++20의 Concepts는 이를 훨씬 더 명확하고 읽기 쉽게 표현할 수 있게 했다. CTAD는 템플릿 인스턴스 생성을 간결하게 만들고, 전달 참조와 완벽 전달은 성능과 정확성을 모두 달성하게 한다. CRTP와 정책 기반 설계는 런타임 오버헤드 없이 정적 다형성과 유연한 구성을 가능케 한다.

템플릿을 제대로 이해하면 STL의 내부 구조가 투명해지고, 자신만의 제네릭 라이브러리를 설계할 수 있는 능력을 갖추게 된다. 현대 C++ 제네릭 프로그래밍의 3축은 Concepts를 통한 명시적 제약, 가변 템플릿을 통한 유연한 인터페이스, 그리고 완벽 전달을 통한 효율적 자원 관리다. 이 세 가지를 마스터하면 성능과 안전성, 표현력을 모두 갖춘 코드를 작성할 수 있다.