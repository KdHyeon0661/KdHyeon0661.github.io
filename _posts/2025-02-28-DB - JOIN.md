---
layout: post
title: DB - JOIN
date: 2025-02-28 19:20:23 +0900
category: DB
---
# JOIN(조인) 완벽 가이드

## 0. 핵심 한 줄 요약

- **정확성**: 조인 키·카디널리티·NULL·중복을 먼저 점검하라.
- **성능**: 인덱스·조인 순서·조인 알고리즘(NL/Hash/Merge)을 조합하고, **필터 선행(선택도↑)** 로 **조인 입력 크기**를 줄여라.
- **유지보수**: 항상 **명시적 `JOIN ... ON`** 구문을 사용하고 **필요한 컬럼만 투영**하라.

---

## 1. JOIN의 의미와 기본 문법

관계형 모델에서 정규화로 분리된 테이블을 **논리적으로 재결합**해 도메인 객체를 복원하는 연산이다.

```sql
-- 가장 명시적이고 권장되는 형태
SELECT a.col1, b.col2
FROM A AS a
JOIN B AS b
  ON a.key = b.key;   -- 조인 조건(=동등조인의 전형)
```

- `JOIN ... ON`을 **항상** 사용하라. 암묵적 조인(쉼표 조인 + WHERE)은 결과/옵티마이저 해석을 헷갈리게 한다.
- `USING(col)`은 두 테이블에 **컬럼명이 동일**할 때 축약 가능하지만, **명확성**은 `ON`이 더 낫다.
- `NATURAL JOIN`은 공통 컬럼 자동 매칭 → **스키마 변경에 취약**하므로 실무 **비권장**.

---

## 2. 조인의 주요 종류와 쓰임새

### 2.1 INNER JOIN (교집합)

양쪽 모두 매칭되는 행만 반환한다. 실무에서 가장 빈번.

```sql
SELECT c.customer_id, c.name, o.order_id
FROM Customer c
JOIN Orders   o
  ON o.customer_id = c.customer_id;
```

### 2.2 LEFT / RIGHT OUTER JOIN

- LEFT: 왼쪽 모든 행을 **보존**, 오른쪽 매칭 없으면 NULL.
- RIGHT: 그 반대 (좌→우 사고를 유지하려면 LEFT 권장).

```sql
-- 부서가 있어도 직원이 없을 수 있는 목록
SELECT d.dept_id, d.dept_name, e.emp_id
FROM Department d
LEFT JOIN Employee e
  ON e.dept_id = d.dept_id;
```

### 2.3 FULL OUTER JOIN (합집합)

양쪽 전부 보존. MySQL은 미지원 → `LEFT JOIN ... UNION ... RIGHT JOIN ... WHERE both sides IS NULL` 등으로 대체.

```sql
SELECT *
FROM A
FULL OUTER JOIN B
  ON A.id = B.id;
```

### 2.4 CROSS JOIN (데카르트 곱)

모든 조합. 행 수가 곱으로 폭발하므로 **의도적으로** 사용할 때만.

```sql
SELECT c.color, s.size
FROM Color c
CROSS JOIN Size  s;
```

### 2.5 SELF JOIN (자체 조인)

같은 테이블을 두 번 이상 조인.

```sql
-- 직원-관리자
SELECT e.emp_id, e.name, m.name AS manager_name
FROM Employee e
JOIN Employee m
  ON e.manager_id = m.emp_id;
```

---

## 3. ON vs WHERE — 특히 OUTER JOIN에서의 차이

- `ON`은 **조인 과정에서의 매칭 조건**을 정의한다.
- `WHERE`는 **최종 필터**다. OUTER JOIN에서 `WHERE`에 조건을 잘못 두면 **NULL 보존 행이 사라진다**.

```sql
-- 잘못된 예: LEFT JOIN 후 WHERE에서 오른쪽 컬럼을 제한 → 사실상 INNER JOIN처럼 동작
SELECT d.dept_id, e.emp_id
FROM Department d
LEFT JOIN Employee e
  ON e.dept_id = d.dept_id
WHERE e.status = 'ACTIVE';             -- NULL 행이 제거됨 (LEFT 의미 상실)

-- 올바른 예: 오른쪽 조건은 ON으로(또는 NULL 허용 조건 추가)
SELECT d.dept_id, e.emp_id
FROM Department d
LEFT JOIN Employee e
  ON e.dept_id = d.dept_id
 AND e.status = 'ACTIVE';
```

---

## 4. NULL, 중복, 카디널리티(기수성) — 결과 정확성의 3대 변수

### 4.1 NULL
- `INNER JOIN`은 매칭 실패 NULL을 자연히 제거.
- `OUTER JOIN`은 NULL 보존. 후단 `WHERE`에서 **NULL을 다시 제거하지 않는지** 확인.

### 4.2 중복
- 다대다(N:M) 관계에서 **중복 곱셈**이 발생한다. 집계 시 곱셈 오류 주의.

```sql
-- 잘못된 총액: N:M 조인으로 금액이 중복 합산될 수 있음
SELECT SUM(oi.amount)
FROM Orders o
JOIN OrderItem oi
  ON oi.order_id = o.order_id
JOIN Campaign c
  ON c.product_id = oi.product_id;   -- 또 다른 축이 붙으면 중복 위험

-- 방어: 필요한 축만 결합하거나, 사전에 distinct/집계로 축소
WITH item AS (
  SELECT order_id, SUM(amount) AS amt
  FROM OrderItem
  GROUP BY order_id
)
SELECT SUM(i.amt)
FROM Orders o
JOIN item   i
  ON i.order_id = o.order_id;
```

### 4.3 카디널리티
- 1:1, 1:N, N:M을 **명확히 파악**하고, 필요 시 **브리지(관계) 테이블**로 N:M을 풀어라.
- 조인 키에 **유니크 제약**이 있으면 **수학적 보장**이 생겨 계획과 결과 해석이 쉬워진다.

---

## 5. 세미 조인·안티 조인 (EXISTS / NOT EXISTS / IN / NOT IN)

**세미 조인**: “존재 여부로 필터링하되, 오른쪽 컬럼은 가져오지 않음.”
**안티 조인**: “존재하지 않음을 보장하는 필터.”

```sql
-- 세미 조인: 주문이 1건 이상 있는 고객
SELECT c.customer_id
FROM Customer c
WHERE EXISTS (
  SELECT 1
  FROM Orders o
  WHERE o.customer_id = c.customer_id
);

-- 안티 조인: 주문이 전혀 없는 고객
SELECT c.customer_id
FROM Customer c
WHERE NOT EXISTS (
  SELECT 1
  FROM Orders o
  WHERE o.customer_id = c.customer_id
);
```

- `IN` vs `EXISTS`: RDBMS/통계/상황에 따라 다르다. **서브쿼리 결과가 크면 `EXISTS`가 유리**한 경우가 많다.
- `NOT IN(NULL 포함)`은 **전부 NULL**이면 **빈 결과**가 될 수 있다 → `NOT EXISTS` 선호.

---

## 6. 집합 연산(UNION/INTERSECT/EXCEPT)과 JOIN의 경계

- `JOIN`: **열을 가로로 붙임**(열 결합).
- `UNION` 등: **행을 세로로 합침**(행 결합).
- 동일 문제라도 **두 방식 중 하나가 더 간결/빠를 수 있다**. 중복 제거 특성(`UNION` vs `UNION ALL`)을 유념.

```sql
-- FULL OUTER JOIN 대체(지원 없는 DB)
SELECT A.id, A.col, B.col
FROM A LEFT JOIN B ON A.id = B.id
UNION ALL
SELECT B.id, NULL, B.col
FROM B
LEFT JOIN A ON B.id = A.id
WHERE A.id IS NULL;
```

---

## 7. 조인 알고리즘: Nested Loops / Hash / Merge

### 7.1 Nested Loops (NL)
- **작은 외측(드라이빙) 테이블** + **인덱스 조인**에 최적.
- 랜덤 I/O 비용이 크므로 **인덱스 필수**.

```sql
-- 실행 전략: 작은 C로 구동 → O 인덱스 탐색
SELECT ...
FROM Customer C                -- 외측(작음)
JOIN Orders   O
  ON O.customer_id = C.customer_id  -- O.customer_id 인덱스
WHERE C.region = 'KR';
```

### 7.2 Hash Join
- 두 입력을 해시 테이블(빌드)과 프로브로 처리.
- **큰 데이터** / **인덱스 부재** / **동등조인**에 강함.
- 메모리/디스크 스필 고려.

```sql
-- 개념: 작은 집합(또는 제한된) 빌드 → 큰 집합 프로브
SELECT ...
FROM BigA a
JOIN BigB b
  ON b.key = a.key;  -- 해시 조인 후보
```

### 7.3 Merge Join
- **양쪽이 조인 키로 정렬되어 있어야** 함(혹은 인덱스 정렬 재사용).
- **대량 + 정렬/인덱스 조건 충족** 시 매우 빠름.

```sql
-- 인덱스가 정렬을 제공하면 디스크 정렬 없이 머지 가능
CREATE INDEX ix_a_key ON A(key);
CREATE INDEX ix_b_key ON B(key);

SELECT ...
FROM A
JOIN B ON B.key = A.key
ORDER BY A.key;  -- 머지 조인 + 최종 정렬 재활용
```

**요약**
- 작은 + 인덱스: **NL**
- 큰 + 동등조인 + 인덱스 없음: **Hash**
- 정렬/인덱스 정렬 충족: **Merge**

---

## 8. 인덱싱 전략 — 조인 키, 복합 인덱스, 커버링

### 8.1 조인 키 인덱스는 **양쪽** 모두 고려
- 외래키 측(자주 탐색되는 쪽) 인덱스는 필수.
- **선택도 높은 필터**가 있다면 **인덱스 선두**로.

```sql
-- Orders(customer_id, order_dt)로 복합 인덱스
CREATE INDEX ix_orders_cust_dt ON Orders(customer_id, order_dt);

SELECT o.order_id
FROM Customer c
JOIN Orders  o
  ON o.customer_id = c.customer_id
WHERE c.customer_id = :id
  AND o.order_dt >= :from_dt
ORDER BY o.order_dt DESC;
```

### 8.2 커버링 인덱스
- SELECT 컬럼이 **모두 인덱스에 포함**되면 테이블 랜덤 접근 제거.

```sql
-- (customer_id, order_dt, order_id) 포함 인덱스
CREATE INDEX ix_orders_cover ON Orders(customer_id, order_dt, order_id);
```

### 8.3 방향/정렬 재사용
- `ORDER BY` 방향/컬럼 순서를 인덱스 정의와 일치시키면 정렬 생략 가능.

---

## 9. 파티셔닝·파티션 프루닝과 조인

- 날짜/범위 해시 파티션으로 입력 크기를 **물리적으로** 줄인다.
- **파티션 키가 조인/필터에 반영**되어야 프루닝이 잘 작동.

```sql
-- 월 파티셔닝 테이블 간 동일 파티션 키로 조인
SELECT *
FROM Sales_2025 s
JOIN Refund_2025 r
  ON r.order_id = s.order_id
WHERE s.sales_month = '2025-10'   -- 프루닝 후보
  AND r.sales_month = '2025-10';
```

---

## 10. 대량 조인과 배치 전략

- **필터 선행**: WHERE/ON으로 먼저 축소.
- **스테이징(집계/Distinct) 선행**: N:M 중복을 조인 전에 **집계로 축소**.
- **배치 사이즈 조절**: 폭발적 곱 제거.
- **물질화(MV, Temp 테이블)**: 반복 사용 결과를 캐싱.

```sql
-- 대량 장바구니 → 먼저 고객/일자 단위로 집계 축소 후 조인
WITH cart_daily AS (
  SELECT customer_id, order_dt::date AS d, SUM(amount) amt
  FROM Cart
  WHERE order_dt >= CURRENT_DATE - INTERVAL '30 DAY'
  GROUP BY customer_id, d
)
SELECT c.customer_id, d.amt, p.segment
FROM cart_daily d
JOIN CustomerProfile p
  ON p.customer_id = d.customer_id;
```

---

## 11. 페이징을 동반한 조인 — 키셋 페이징 권장

`OFFSET`은 큰 값에서 **매우 비싸다**. 조인 결과도 동일.
**결정적 정렬 키**(유니크 근사)를 기준으로 **키셋 페이징**하라.

```sql
-- 마지막 키 (o.order_dt, o.order_id)를 바인딩해 다음 페이지
SELECT o.order_id, o.order_dt, c.name
FROM Orders o
JOIN Customer c
  ON c.customer_id = o.customer_id
WHERE (o.order_dt, o.order_id) < (:last_dt, :last_id)
ORDER BY o.order_dt DESC, o.order_id DESC
LIMIT 50;
```

---

## 12. 정렬·집계와의 결합: 정확성·비용 균형

- 조인 후 **집계** vs 집계 후 조인: **중간 데이터 크기**가 작아지는 방향으로.
- `GROUP BY` 키가 조인 키의 상위집합이면 **집계 선행**이 유리.

```sql
-- 집계 선행으로 조인 입력 축소
WITH item AS (
  SELECT order_id, SUM(amount) AS amt
  FROM OrderItem
  GROUP BY order_id
)
SELECT c.customer_id, SUM(i.amt) total
FROM Customer c
JOIN Orders   o ON o.customer_id = c.customer_id
JOIN item     i ON i.order_id     = o.order_id
GROUP BY c.customer_id;
```

---

## 13. 날짜/시간·타임존·키 변환이 들어간 조인

표현식 조인은 인덱스 재사용을 막는다 → **계산 열** 또는 **표준화된 키**를 사용.

```sql
-- 계산 열(또는 물리화) + 인덱스
ALTER TABLE Orders
  ADD order_date DATE GENERATED ALWAYS AS (CAST(order_dt AT TIME ZONE 'UTC' AS DATE)) STORED;

CREATE INDEX ix_orders_order_date ON Orders(order_date);

SELECT *
FROM Orders o
JOIN Calendar cal
  ON cal.d = o.order_date
WHERE cal.d BETWEEN '2025-10-01' AND '2025-10-31';
```

---

## 14. 스타 스키마(사실/차원) 조인 — BI/리포팅 모범 사례

- 사실 테이블(Fact)은 **매우 큼**, 차원(Dimension)은 상대적으로 작음.
- **사실 → 차원** 방향으로 NL 조인(차원 키 인덱스) 또는 Hash(대량) 선택.
- 차원 키는 **서로 다른 Surrogate Key(SKEY)** 권장. SCD(변경 이력)면 **유효기간 조인** 필요.

```sql
-- SCD Type 2: Fact.order_dt가 DimCustomer 유효기간 사이에 속하는 행 매칭
SELECT f.order_id, d.customer_name
FROM FactSales f
JOIN DimCustomer d
  ON d.customer_skey = f.customer_skey
 AND f.order_dt BETWEEN d.eff_from AND d.eff_to;
```

---

## 15. 외래키·제약·통계: 옵티마이저의 힌트

- **참조 무결성(FK)** 가 선언되면 옵티마이저가 **카디널리티 추정**에 활용.
- **통계 최신화**(`ANALYZE`, `DBMS_STATS`)는 조인 순서/알고리즘 선택에 **직결**.
- **유니크 인덱스**는 1:1/1:N 보장 → 계획 단순화.

---

## 16. 실전 시나리오

### 16.1 “주문이 있는 고객 + 최근 주문일자 Top-N”

```sql
-- 집계 선행 + 세미 조인 + 키셋 Top-N
WITH last_order AS (
  SELECT o.customer_id, MAX(o.order_dt) AS last_dt
  FROM Orders o
  WHERE o.order_dt >= CURRENT_DATE - INTERVAL '90 DAY'
  GROUP BY o.customer_id
)
SELECT c.customer_id, c.name, l.last_dt
FROM Customer c
JOIN last_order l
  ON l.customer_id = c.customer_id
ORDER BY l.last_dt DESC, c.customer_id
FETCH FIRST 100 ROWS WITH TIES;
```

### 16.2 “제품-태그 N:M에서 곱셈 방지 후 매출 합계”

```sql
-- N:M 브리지(ProductTag)를 집계/Distinct로 축소하고 결합
WITH per_product AS (
  SELECT p.product_id, SUM(s.amount) AS sales_amt
  FROM Sales s
  JOIN Product p ON p.product_id = s.product_id
  GROUP BY p.product_id
),
tagged AS (
  SELECT DISTINCT product_id
  FROM ProductTag
  WHERE tag IN ('Summer', 'Hot')
)
SELECT SUM(pp.sales_amt)
FROM per_product pp
JOIN tagged      t
  ON t.product_id = pp.product_id;
```

### 16.3 “LEFT JOIN 유지 + 조건은 ON으로”

```sql
SELECT d.dept_id, d.dept_name, e.emp_id
FROM Department d
LEFT JOIN Employee e
  ON e.dept_id = d.dept_id
 AND e.status  = 'ACTIVE'   -- 외측 보존
WHERE d.region = 'APAC';    -- 왼쪽 필터는 WHERE 가능
```

---

## 17. 대용량 데이터에서의 복합 전략 체크리스트

- [ ] **선택도 높은 WHERE** → **조인 전에** 입력 축소
- [ ] **조인 키에 인덱스**(특히 외래키 측)
- [ ] 필요 시 **집계/Distinct 선행**으로 N:M 폭발 방지
- [ ] 알맞은 **조인 알고리즘 선택**(NL/Hash/Merge)
- [ ] **파티셔닝/프루닝**으로 물리적 범위 축소
- [ ] **커버링 인덱스**로 랜덤 I/O 최소화
- [ ] **키셋 페이징**으로 OFFSET 제거
- [ ] **계산 열/함수 인덱스**로 표현식 조인 최적화
- [ ] **통계 최신화**로 올바른 실행계획 확보
- [ ] **EXPLAIN/실행계획**으로 실제 선택 확인

---

## 18. 수학적 비용 감각(개략)

- NL: 외측 n, 내측 m, 인덱스 탐색 비용 $$\approx n \cdot \log m$$(단순화)
- Hash: 빌드 b, 프로브 p, 해시 비용 $$\approx b + p$$(해시/충돌/스필 가산)
- Merge: 정렬 비용 $$O(n\log n + m\log m)$$(정렬 재사용 시 대폭 감소)

**핵심**: **입력 크기를 줄이고**, **인덱스/정렬 재사용**을 극대화하라.

---

## 19. 자주 하는 실수와 예방

| 실수 | 영향 | 예방 |
|---|---|---|
| OUTER JOIN 후 WHERE에서 오른쪽 컬럼 필터 | NULL 보존 상실 → 사실상 INNER | 오른쪽 조건은 `ON`으로 |
| N:M 곱셈 미인지 | 합계/통계 과대계상 | 집계 선행, Distinct, 브리지 설계 |
| 조인 키 인덱스 누락 | 풀 스캔/랜덤 I/O 급증 | FK/조인 키 인덱스 생성 |
| NATURAL/USING 남발 | 스키마 변경에 취약 | 명시적 `ON` 고수 |
| OFFSET 페이징 | 후반 페이지 급격히 느림 | 키셋 페이징 |
| 통계 노후화 | 잘못된 계획 선택 | 정기 `ANALYZE/DBMS_STATS` |
| `SELECT *` | 불필요 I/O/네트워크 | 필요한 칼럼만 투영 |

---

## 20. 종합 예제 — 전자상거래 분석 리포트 쿼리

요구: “최근 30일, **카테고리별** 매출 Top-5 상품과 해당 상품의 **첫 구매일**, **최근 구매일**, **고객 수**. NULL 안전성과 N:M 곱 방지, 성능까지 고려.”

```sql
WITH
-- 1) 기간 필터로 사실 테이블 축소(선택도↑)
fact AS (
  SELECT s.product_id, s.customer_id, s.order_dt::date AS d, s.amount
  FROM Sales s
  WHERE s.order_dt >= CURRENT_DATE - INTERVAL '30 DAY'
),
-- 2) 상품-카테고리 N:M 브리지 축소(DISTINCT)
prod_cat AS (
  SELECT DISTINCT p.product_id, c.category_id
  FROM Product p
  JOIN ProductCategory pc ON pc.product_id  = p.product_id
  JOIN Category        c  ON c.category_id  = pc.category_id
),
-- 3) 상품 단위 집계(먼저 줄인다)
agg_prod AS (
  SELECT f.product_id,
         COUNT(DISTINCT f.customer_id) AS customers,
         MIN(f.d) AS first_date,
         MAX(f.d) AS last_date,
         SUM(f.amount) AS sales
  FROM fact f
  GROUP BY f.product_id
),
-- 4) 카테고리 결합(집계→조인 순서)
cat_prod AS (
  SELECT pc.category_id, a.*
  FROM agg_prod a
  JOIN prod_cat pc
    ON pc.product_id = a.product_id
),
-- 5) 카테고리별 매출 순위(윈도 함수)
ranked AS (
  SELECT category_id, product_id, customers, first_date, last_date, sales,
         ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY sales DESC, product_id) AS rn
  FROM cat_prod
)
SELECT r.category_id, r.product_id, r.sales, r.customers, r.first_date, r.last_date
FROM ranked r
WHERE r.rn <= 5
ORDER BY r.category_id, r.sales DESC, r.product_id;
```

**포인트**
- 기간 필터로 사실 테이블을 먼저 축소(파티션/인덱스 프루닝 유도).
- N:M 브리지 `ProductCategory`는 `DISTINCT`로 **중복 제거** 후 결합.
- 집계 → 조인 순서로 **중간 행 수 감소**.
- 최종 표시는 **결정적 정렬 키**(sales DESC, product_id)로 안정화.

---

# 결론

- JOIN은 정규화 구조를 **현실의 뷰로 복원**하는 핵심 연산이다.
- 정확성은 **NULL/중복/카디널리티**로, 성능은 **필터 선행·인덱스·조인 알고리즘·파티셔닝·키셋 페이징**으로 좌우된다.
- 명시적 `JOIN ... ON`, 필요 컬럼만 투영, 실행계획 점검을 **습관화**하라.
- 대량·복잡 조인일수록 **집계 선행으로 축소 → 적합 알고리즘 → 정렬/인덱스 재사용** 순으로 사고하면 성공 확률이 높다.
