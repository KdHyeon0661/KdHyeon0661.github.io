---
layout: post
title: DB - JOIN
date: 2025-02-28 19:20:23 +0900
category: DB
---
# SQL JOIN 완벽 가이드

## 핵심 요약

JOIN은 관계형 데이터베이스의 핵심 연산으로, 정규화로 분리된 데이터를 다시 연결하여 의미 있는 정보를 만듭니다. 효과적인 JOIN 사용의 핵심은 세 가지로 요약할 수 있습니다:

1. **정확성**: 올바른 조인 키를 사용하고, NULL 값과 데이터 중복을 이해하며, 관계의 카디널리티(1:1, 1:N, N:M)를 정확히 파악하세요.
2. **성능**: 적절한 인덱스를 활용하고, 조인 알고리즘을 이해하며, 필터 조건을 조인 전에 적용하여 데이터 양을 최소화하세요.
3. **유지보수성**: 항상 명시적인 `JOIN ... ON` 구문을 사용하고, 필요한 컬럼만 선택하며, 쿼리를 읽기 쉽게 작성하세요.

---

## JOIN의 기본 개념과 문법

JOIN은 두 개 이상의 테이블을 연결하여 하나의 결과 집합을 만드는 SQL 연산입니다. 가장 명확하고 권장되는 작성법은 다음과 같습니다:

```sql
SELECT employees.name, departments.department_name
FROM employees
JOIN departments ON employees.department_id = departments.id;
```

항상 명시적인 `JOIN ... ON` 구문을 사용하세요. 암묵적 조인(쉼표로 테이블을 나열하고 WHERE에서 조인 조건을 지정)은 코드의 명확성을 해치고 실수할 가능성을 높입니다.

`USING` 절은 두 테이블의 컬럼 이름이 완전히 같을 때 사용할 수 있지만, `ON` 절을 사용하는 것이 일반적으로 더 명확합니다. `NATURAL JOIN`은 공통 컬럼을 자동으로 매칭하지만, 스키마 변경에 취약하므로 실무에서는 사용을 피하는 것이 좋습니다.

---

## 주요 JOIN 유형과 사용 시나리오

### INNER JOIN (내부 조인)
양쪽 테이블 모두에 일치하는 행만 반환합니다. 가장 일반적으로 사용되는 조인 유형입니다.

```sql
-- 고객과 그들의 주문 조회 (주문이 없는 고객은 제외)
SELECT customers.name, orders.order_date, orders.total_amount
FROM customers
INNER JOIN orders ON customers.id = orders.customer_id;
```

### LEFT JOIN (왼쪽 외부 조인)
왼쪽 테이블의 모든 행을 포함하고, 오른쪽 테이블의 일치하는 행이 있으면 포함합니다. 일치하지 않으면 NULL 값으로 채웁니다.

```sql
-- 모든 부서와 해당 부서의 직원 조회 (직원이 없는 부서도 포함)
SELECT departments.name AS department_name, employees.name AS employee_name
FROM departments
LEFT JOIN employees ON departments.id = employees.department_id;
```

### RIGHT JOIN (오른쪽 외부 조인)
LEFT JOIN의 반대로, 오른쪽 테이블의 모든 행을 포함합니다. 실무에서는 일관성을 위해 LEFT JOIN을 주로 사용하는 경우가 많습니다.

### FULL OUTER JOIN (완전 외부 조인)
양쪽 테이블의 모든 행을 포함합니다. MySQL에서는 직접 지원하지 않으므로 UNION을 사용하여 구현해야 합니다.

```sql
-- MySQL에서 FULL OUTER JOIN 구현
SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id
UNION
SELECT * FROM table1 RIGHT JOIN table2 ON table1.id = table2.id
WHERE table1.id IS NULL;
```

### CROSS JOIN (교차 조인)
두 테이블의 모든 가능한 조합을 생성합니다. 행 수가 급격히 증가할 수 있으므로 신중하게 사용해야 합니다.

```sql
-- 색상과 크기의 모든 조합 생성
SELECT colors.color_name, sizes.size_name
FROM colors
CROSS JOIN sizes;
```

### SELF JOIN (자체 조인)
같은 테이블을 서로 다른 별칭으로 조인합니다. 계층적 데이터나 관계를 표현할 때 유용합니다.

```sql
-- 직원과 그들의 관리자 조회
SELECT e.name AS employee_name, m.name AS manager_name
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;
```

---

## ON 절과 WHERE 절의 차이점

`ON` 절은 조인 조건을 지정하는 데 사용되고, `WHERE` 절은 결과를 필터링하는 데 사용됩니다. 이 차이는 외부 조인에서 특히 중요합니다.

```sql
-- 잘못된 예: LEFT JOIN의 의미를 잃음
SELECT departments.name, employees.name
FROM departments
LEFT JOIN employees ON departments.id = employees.department_id
WHERE employees.salary > 50000;  -- NULL인 행이 제거됨

-- 올바른 예: 조건을 ON 절에 포함
SELECT departments.name, employees.name
FROM departments
LEFT JOIN employees ON departments.id = employees.department_id 
    AND employees.salary > 50000;  -- NULL인 행도 유지됨
```

첫 번째 예제에서는 WHERE 절이 LEFT JOIN으로 생성된 NULL 행을 필터링해버리므로, 사실상 INNER JOIN처럼 동작합니다. 두 번째 예제에서는 조건이 ON 절에 있으므로, 조건을 만족하지 않는 직원은 NULL로 표시되지만 부서는 여전히 결과에 포함됩니다.

---

## JOIN의 정확성을 위한 핵심 고려사항

### NULL 값 처리
NULL 값은 조인 동작에 중요한 영향을 미칩니다. INNER JOIN에서는 NULL과의 비교가 실패하므로 해당 행이 결과에서 제외됩니다. OUTER JOIN에서는 NULL 값이 보존됩니다. 항상 NULL이 예상대로 처리되는지 확인하세요.

### 데이터 중복과 카디널리티
조인 시 데이터 중복이 발생할 수 있으며, 이는 집계 결과에 영향을 줄 수 있습니다.

```sql
-- 문제: 다대다 관계로 인한 중복 계산
SELECT SUM(order_items.quantity * products.price) AS total_sales
FROM orders
JOIN order_items ON orders.id = order_items.order_id
JOIN products ON order_items.product_id = products.id
JOIN product_tags ON products.id = product_tags.product_id;  -- 중복 발생!

-- 해결: 중복 제거 또는 집계 순서 변경
WITH order_totals AS (
    SELECT order_id, SUM(quantity * price) AS order_total
    FROM order_items
    JOIN products ON order_items.product_id = products.id
    GROUP BY order_id
)
SELECT SUM(order_total) AS total_sales
FROM orders
JOIN order_totals ON orders.id = order_totals.order_id;
```

### 관계의 카디널리티 이해
테이블 간 관계 유형(1:1, 1:N, N:M)을 이해하는 것이 중요합니다. N:M 관계는 중간 테이블(조인 테이블)을 통해 처리되며, 이 경우 중복이 발생할 가능성이 높습니다.

---

## 세미 조인과 안티 조인

세미 조인과 안티 조인은 존재 여부에 기반한 필터링을 제공합니다.

```sql
-- 세미 조인: 주문이 있는 고객 (EXISTS 사용)
SELECT customers.name
FROM customers
WHERE EXISTS (
    SELECT 1
    FROM orders
    WHERE orders.customer_id = customers.id
);

-- 안티 조인: 주문이 없는 고객 (NOT EXISTS 사용)
SELECT customers.name
FROM customers
WHERE NOT EXISTS (
    SELECT 1
    FROM orders
    WHERE orders.customer_id = customers.id
);
```

`IN`과 `EXISTS`는 비슷한 결과를 제공하지만, 서브쿼리의 결과 크기와 데이터 분포에 따라 성능이 다를 수 있습니다. 일반적으로 서브쿼리가 크거나 NULL 값을 포함할 가능성이 있다면 `EXISTS`가 더 안전합니다.

---

## 조인 알고리즘 이해

데이터베이스는 세 가지 주요 조인 알고리즘을 사용합니다. 각 알고리즘은 특정 상황에서 최적의 성능을 제공합니다.

### Nested Loops Join (중첩 루프 조인)
작은 테이블(외부 테이블)을 순회하면서, 각 행에 대해 내부 테이블에서 일치하는 행을 찾습니다. 인덱스가 있는 작은 테이블에 적합합니다.

```sql
-- Nested Loops에 적합한 패턴
SELECT *
FROM small_table s
JOIN large_table l ON s.id = l.small_id  -- l.small_id에 인덱스가 있어야 함
WHERE s.category = 'A';
```

### Hash Join (해시 조인)
한 테이블의 조인 키를 해시 테이블에 저장한 후, 다른 테이블을 스캔하며 해시 테이블에서 일치하는 항목을 찾습니다. 대용량 데이터와 동등 조인에 적합합니다.

```sql
-- Hash Join에 적합한 패턴
SELECT *
FROM table1
JOIN table2 ON table1.id = table2.id  -- 인덱스가 없거나 대용량 데이터
WHERE table1.size > 1000;
```

### Merge Join (병합 조인)
두 테이블을 조인 키로 정렬한 후 병합합니다. 이미 정렬된 데이터나 정렬된 인덱스가 있을 때 효율적입니다.

```sql
-- Merge Join에 적합한 패턴
SELECT *
FROM table1
JOIN table2 ON table1.id = table2.id
ORDER BY table1.id;  -- ORDER BY가 조인 키와 일치할 때
```

## 성능 최적화를 위한 인덱스 전략

### 조인 키 인덱스
조인에 사용되는 컬럼에는 인덱스를 생성하는 것이 성능에 중요합니다. 특히 외래 키 컬럼은 거의 항상 인덱스가 필요합니다.

```sql
-- 주문 테이블에 고객 ID 인덱스 생성
CREATE INDEX idx_orders_customer_id ON orders(customer_id);

-- 복합 인덱스: 여러 조건을 함께 사용할 때
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);
```

### 커버링 인덱스
쿼리에 필요한 모든 컬럼을 인덱스에 포함시켜 테이블 접근을 완전히 피할 수 있습니다.

```sql
-- 커버링 인덱스: SELECT에 필요한 모든 컬럼 포함
CREATE INDEX idx_orders_cover ON orders(customer_id, order_date, total_amount);
```

### 인덱스와 정렬 방향 일치
ORDER BY 절의 정렬 방향을 인덱스의 정렬 방향과 일치시키면 정렬 작업을 피할 수 있습니다.

```sql
-- 인덱스 정의
CREATE INDEX idx_orders_date_desc ON orders(order_date DESC, id DESC);

-- 쿼리: 인덱스 정렬 방향과 일치
SELECT * FROM orders
ORDER BY order_date DESC, id DESC;
```

---

## 대용량 데이터에서의 조인 전략

### 필터 조건 조인 전 적용
가능한 한 빨리 데이터 양을 줄이는 것이 성능에 중요합니다.

```sql
-- 비효율적: 조인 후 필터
SELECT *
FROM large_table l
JOIN very_large_table v ON l.id = v.large_id
WHERE l.category = 'A' AND v.status = 'ACTIVE';

-- 효율적: 조인 전 필터
WITH filtered_large AS (
    SELECT * FROM large_table WHERE category = 'A'
),
filtered_very_large AS (
    SELECT * FROM very_large_table WHERE status = 'ACTIVE'
)
SELECT *
FROM filtered_large l
JOIN filtered_very_large v ON l.id = v.large_id;
```

### 집계 후 조인
데이터를 먼저 집계하여 크기를 줄인 후 조인하는 것이 효율적일 수 있습니다.

```sql
-- 집계 후 조인
WITH daily_sales AS (
    SELECT product_id, SUM(amount) AS daily_total
    FROM sales
    WHERE sale_date = CURRENT_DATE
    GROUP BY product_id
)
SELECT p.name, d.daily_total
FROM products p
JOIN daily_sales d ON p.id = d.product_id;
```

### 파티셔닝 활용
대용량 테이블을 파티셔닝하면 쿼리 성능을 크게 향상시킬 수 있습니다.

```sql
-- 월별 파티셔닝된 테이블 생성
CREATE TABLE sales (
    id INT,
    sale_date DATE,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (YEAR(sale_date) * 100 + MONTH(sale_date));

-- 특정 월의 데이터만 접근 (파티션 프루닝)
SELECT * FROM sales
WHERE sale_date BETWEEN '2024-01-01' AND '2024-01-31';
```

---

## 페이징과 조인

OFFSET 기반 페이징은 대용량 데이터에서 성능 문제를 일으킬 수 있습니다. 키셋(커서) 페이징을 사용하는 것이 더 효율적입니다.

```sql
-- 키셋 페이징: 마지막으로 본 값을 기준으로 다음 페이지 조회
SELECT *
FROM orders
JOIN customers ON orders.customer_id = customers.id
WHERE (orders.order_date, orders.id) < (:last_order_date, :last_order_id)
ORDER BY orders.order_date DESC, orders.id DESC
LIMIT 20;
```

---

## 실전 시나리오와 모범 사례

### 시나리오 1: 계층적 데이터 조회
```sql
-- 조직도 조회 (모든 관리자 계층 포함)
WITH RECURSIVE org_hierarchy AS (
    -- 기준: 최상위 관리자
    SELECT id, name, manager_id, 1 AS level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 재귀: 하위 직원 추가
    SELECT e.id, e.name, e.manager_id, oh.level + 1
    FROM employees e
    JOIN org_hierarchy oh ON e.manager_id = oh.id
)
SELECT * FROM org_hierarchy ORDER BY level, name;
```

### 시나리오 2: 시간 기반 분석
```sql
-- 이동 평균 계산 (지난 7일 평균)
SELECT 
    sale_date,
    daily_sales,
    AVG(daily_sales) OVER (
        ORDER BY sale_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7d
FROM (
    SELECT sale_date, SUM(amount) AS daily_sales
    FROM sales
    GROUP BY sale_date
) daily_totals
ORDER BY sale_date;
```

### 시나리오 3: 누락된 데이터 찾기
```sql
-- 주문은 있지만 배송 정보가 없는 경우 찾기
SELECT orders.id, orders.order_date, orders.total_amount
FROM orders
LEFT JOIN shipments ON orders.id = shipments.order_id
WHERE shipments.id IS NULL
  AND orders.order_date >= CURRENT_DATE - INTERVAL '30 DAYS';
```

---

## 자주 발생하는 실수와 해결 방법

### 실수 1: OUTER JOIN에서 WHERE 절 오용
**문제**: LEFT JOIN 후 WHERE 절에서 오른쪽 테이블의 컬럼을 필터링하면 NULL 행이 제거됩니다.
**해결**: 오른쪽 테이블의 필터 조건은 ON 절에 포함시키세요.

### 실수 2: N:M 관계에서의 중복 계산
**문제**: 다대다 관계를 조인할 때 데이터 중복이 발생하여 집계 결과가 잘못될 수 있습니다.
**해결**: 집계를 조인 전에 수행하거나, DISTINCT를 적절히 사용하세요.

### 실수 3: 조인 키 인덱스 누락
**문제**: 조인 키에 인덱스가 없어 성능이 저하됩니다.
**해결**: 조인에 자주 사용되는 컬럼에는 인덱스를 생성하세요.

### 실수 4: 불필요한 CROSS JOIN
**문제**: 의도하지 않은 CROSS JOIN으로 인해 결과 행 수가 폭발적으로 증가합니다.
**해결**: 항상 명시적인 조인 조건을 작성하고, CROSS JOIN은 의도적으로만 사용하세요.

### 실수 5: 통계 정보 미갱신
**문제**: 데이터베이스 통계가 오래되어 최적의 실행 계획을 선택하지 못합니다.
**해결**: 정기적으로 통계 정보를 갱신하세요.

---

## 종합 예제: 전자상거래 분석 리포트

다음은 여러 최적화 기법을 적용한 복잡한 분석 쿼리 예제입니다:

```sql
-- 최근 30일 동안 카테고리별 매출 상위 5개 제품 분석
WITH 
-- 1. 기간 필터로 데이터 양 줄이기
recent_sales AS (
    SELECT product_id, customer_id, sale_date, amount
    FROM sales
    WHERE sale_date >= CURRENT_DATE - INTERVAL '30 DAYS'
),

-- 2. 제품별 집계 (조인 전에 데이터 축소)
product_aggregates AS (
    SELECT 
        product_id,
        COUNT(DISTINCT customer_id) AS unique_customers,
        MIN(sale_date) AS first_sale_date,
        MAX(sale_date) AS last_sale_date,
        SUM(amount) AS total_sales
    FROM recent_sales
    GROUP BY product_id
),

-- 3. 제품-카테고리 매핑 (DISTINCT로 중복 제거)
product_categories AS (
    SELECT DISTINCT p.id AS product_id, c.id AS category_id, c.name AS category_name
    FROM products p
    JOIN product_category_mapping m ON p.id = m.product_id
    JOIN categories c ON m.category_id = c.id
),

-- 4. 카테고리별 제품 결합
category_products AS (
    SELECT 
        pc.category_id,
        pc.category_name,
        pa.*
    FROM product_aggregates pa
    JOIN product_categories pc ON pa.product_id = pc.product_id
),

-- 5. 카테고리 내 매출 순위 계산
ranked_products AS (
    SELECT 
        *,
        ROW_NUMBER() OVER (
            PARTITION BY category_id 
            ORDER BY total_sales DESC, product_id
        ) AS sales_rank
    FROM category_products
)

-- 6. 최종 결과: 카테고리별 상위 5개 제품
SELECT 
    category_name,
    product_id,
    total_sales,
    unique_customers,
    first_sale_date,
    last_sale_date,
    sales_rank
FROM ranked_products
WHERE sales_rank <= 5
ORDER BY category_name, sales_rank;
```

이 쿼리의 최적화 포인트:
1. **기간 필터 조기 적용**: 가장 제한적인 조건을 먼저 적용하여 데이터 양을 줄였습니다.
2. **집계 후 조인**: 제품별 집계를 먼저 수행하여 조인할 데이터 양을 최소화했습니다.
3. **DISTINCT 사용**: 다대다 관계에서의 중복을 제거했습니다.
4. **윈도우 함수**: 효율적인 순위 계산을 수행했습니다.
5. **필요한 컬럼만 선택**: 불필요한 데이터 전송을 피했습니다.

---

## 결론

SQL JOIN은 관계형 데이터베이스의 가장 강력한 기능 중 하나이지만, 올바르게 사용하지 않으면 성능 문제와 잘못된 결과를 초래할 수 있습니다. 효과적인 JOIN 사용을 위한 핵심 원칙은 다음과 같습니다:

1. **기본에 충실하라**: 항상 명시적인 `JOIN ... ON` 구문을 사용하고, 조인 조건을 명확히 정의하세요. 암묵적 조인이나 NATURAL JOIN과 같은 단축형은 피하세요.

2. **데이터 관계를 이해하라**: 테이블 간의 관계(1:1, 1:N, N:M)를 정확히 이해하고, 특히 N:M 관계에서는 데이터 중복 가능성을 인지하세요. 필요시 집계를 조인 전에 수행하여 데이터 양을 줄이세요.

3. **성능을 고려하라**: 
   - 조인 키에는 인덱스를 생성하세요.
   - 가능한 한 빨리 데이터 양을 줄이기 위해 필터 조건을 조인 전에 적용하세요.
   - 대용량 데이터에서는 파티셔닝, 배치 처리, 적절한 조인 알고리즘 선택을 고려하세요.
   - 페이징이 필요하다면 OFFSET 대신 키셋 페이징을 사용하세요.

4. **NULL을 주의하라**: OUTER JOIN에서 WHERE 절 사용을 특히 주의하세요. 오른쪽 테이블의 필터 조건은 ON 절에 포함시키는 것이 안전합니다.

5. **실행 계획을 확인하라**: 복잡한 조인 쿼리는 실행 계획을 확인하여 데이터베이스가 최적의 알고리즘을 선택했는지 확인하세요. 통계 정보가 최신인지 정기적으로 점검하세요.

6. **점진적으로 최적화하라**: 쿼리를 한 번에 완벽하게 작성하려 하지 말고, 먼저 정확한 결과를 얻은 후 점진적으로 성능을 최적화하세요.

JOIN은 단순히 데이터를 연결하는 기술이 아니라, 비즈니스 도메인의 관계와 규칙을 표현하는 수단입니다. 잘 설계된 JOIN 쿼리는 데이터의 진정한 가치를 발견하는 데 도움이 되며, 시스템의 성능과 유지보수성을 결정하는 중요한 요소입니다. 기본 원칙을 이해하고 실전 경험을 쌓는다면, 복잡한 데이터 관계도 명확하고 효율적으로 표현할 수 있을 것입니다.