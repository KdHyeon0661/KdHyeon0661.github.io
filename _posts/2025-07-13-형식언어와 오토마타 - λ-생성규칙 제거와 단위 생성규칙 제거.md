---
layout: post
title: 형식언어와 오토마타 - λ-생성규칙 제거와 단위 생성규칙 제거
date: 2025-07-13 18:20:23 +0900
category: 형식언어와 오토마타
---
# 제거와 단위 생성규칙 제거

## 목표와 맥락

CFG(Context-Free Grammar)를 **정규형(CNF/GNF)** 으로 바꾸거나, **파서의 안정성·성능**을 높이려면 먼저
1) **λ(람다, ε)-생성규칙**과 2) **단위 생성규칙**을 제거해 **단순화**해야 합니다.
이 글은 두 변환을 **정의/알고리즘/정확성/예제/코드**까지 한 번에 정리합니다.

> 표기: CFG \(G=(V,\Sigma,R,S)\). 비터미널 \(V\), 터미널 \(\Sigma\), 규칙집합 \(R\), 시작기호 \(S\).

---

## λ(ε)-생성규칙 제거

### 정의

**ε-규칙**: \(A \to \varepsilon\) 꼴(우변이 빈 문자열).
- \(\varepsilon\)은 **길이 0**의 문자열(공백문자 아님).
- **예외**: 언어가 실제로 \(\varepsilon\)을 포함하면 **시작기호만** \(\varepsilon\)을 허용하는 특례를 둡니다.

### 왜 제거하나?

- **LL/LR 파서**에서 ε-규칙은 예외 처리를 야기.
- **CNF**에선 \(S\!\to\!\varepsilon\) (특례) 외에 허용되지 않음.
- 분석·증명·구현 단순화.

### 핵심 개념: Nullable 집합

\[
\textsf{Null} = \{ A \in V \mid A \Rightarrow^* \varepsilon \}
\]
- 기저: \(A\to\varepsilon \in R \Rightarrow A\in\textsf{Null}\)
- 닫힘: \(B\to X_1\cdots X_k\)이고 모든 \(X_i\in\textsf{Null}\)이면 \(B\in\textsf{Null}\)

### 알고리즘(ε-제거)

**입력**: \(G=(V,\Sigma,R,S)\)
**출력**: ε-규칙 제거된 \(G'\) (단, 시작 특례는 보존)

1) **새 시작기호 도입(권장)**
   \(S_0\notin V\)를 도입하고 \(S_0\to S\) 추가, 시작기호를 \(S_0\)로 교체.
   \(\varepsilon\in L(G)\) 이면 **\(S_0\to\varepsilon\)** 허용.

2) **Nullable 계산**: 위 정의로 고정점까지.

3) **조합적 생략 추가**
   각 규칙 \(A\to X_1\cdots X_k\)에 대해, \(\textsf{Null}\)인 비터미널 위치 집합을 모든 부분집합으로 골라 **생략 버전**을 전부 추가.
   단, **완전히 비워지는 우변(ε)** 은 **\(A=S_0\)** 인 경우만 허용.

4) **원래 ε-규칙 제거**: (시작특례 제외)

5) (선택) **중복·쓸모없는 기호 제거**: 새 규칙으로 인해 생긴 비생성/비도달 기호를 정리.

#### 시간복잡도

- \(\textsf{Null}\) 계산: \(O(|R|\cdot L)\) (규칙 길이 평균 \(L\))
- 조합 생략: 최악 \(O(2^m)\) (m=우변의 Nullable 수). 일반 CFG에선 \(m\)이 작아 실무 가능.

### 정확성(스케치)

- **보존성**: 원래 \(A\to X_1\cdots X_k\)가 있을 때, 유도에서 Nullable 심볼을 사용/미사용하는 모든 경우를 **명시적 규칙**으로 추가하므로, ε-제거 후에도 **동일한 언어(ε 특례 반영)**를 생성.
- **ε-제거**: 시작특례를 제외하고는 \(\varepsilon\)을 만들 경로를 **모두 우변생략 규칙**으로 흡수했으므로 필요 없어짐.

### 예제 1 (기초)

원문법
```
S → AB | a
A → ε
B → b
```
- \(\textsf{Null}=\{A\}\).
- \(S\to AB\)에서 A 생략 가능 → \(S\to B\) 추가.
- ε-규칙 삭제 후:

정리된 문법
```
S → AB | B | a
B → b
```
(\(A\)는 비생성/비도달이면 제거 가능)

### 예제 2 (여러 Nullable)

원문법
```
S → A X B | B | ε
A → a | ε
B → b B | ε
X → c
```
- \(\textsf{Null}=\{A,B,S\}\) (S는 ε 생성)
- \(S_0\to S\) 도입, \(\varepsilon\in L(G)\)이므로 \(S_0\to \varepsilon\) 허용
- \(S\to AXB\)에서 A/B 생략 조합:
  - 둘다 유지: \(A X B\)
  - A만 생략: \(X B\)
  - B만 생략: \(A X\)
  - 둘다 생략: \(X\)
- \(S\to B\)에서 B가 Nullable → \(S\to \varepsilon\)이지만 **시작특례 외 ε 금지** → \(S\to \varepsilon\) **추가하지 않음**
- ε-규칙 삭제(시작특례 제외), 단위/쓸모없는 정리 후:

가능한 결과(요약)
```
S0 → S | ε
S  → A X B | X B | A X | X | B
A  → a
B  → b B | b
X  → c
```
(정리 단계에서 \(S\to B\)와 \(B\to b|bB\)로 인해 더 축약될 수 있음)

---

## 단위 생성규칙 제거

### 정의

**단위 규칙**: \(A\to B\) 꼴(우변이 **단 하나의 비터미널**).

### 왜 제거하나?

- 정보 없이 유도만 늘려 **파싱·증명에 방해**.
- CNF/GNF 정규화의 필수 전처리.

### 단위-폐포(Unit-closure)

\[
\textsf{Unit}=\{(A,B)\mid A\Rightarrow^*B\ \text{via only unit rules}\}
\]
- 기저: \((A,A)\in\textsf{Unit}\)
- 닫힘: \(A\to C\)와 \((C,B)\in\textsf{Unit}\Rightarrow (A,B)\in\textsf{Unit}\)

### 알고리즘(단위 제거)

**입력**: ε-제거(및 쓸모없는 제거) 이후의 CFG
**출력**: 단위 규칙 없는 CFG

1) \(\textsf{Unit}\) 계산(DFS/BFS/플로이드-워셜류 가능).
2) 모든 \((A,B)\in\textsf{Unit}\)에 대해, **B의 비단위 규칙** \(B\to \gamma\)를 **A로 끌어올림**: \(A\to \gamma\) 추가.
3) 모든 **단위 규칙 삭제**.
4) (선택) **중복/쓸모없는** 기호 정리.

#### 복잡도

- \(\textsf{Unit}\) 계산: \(O(|V|^2+|R|)\)
- 변환/정리: \(O(|V||R|)\)

### 정확성(스케치)

- \(A\Rightarrow^*B\Rightarrow \gamma\) (단위 체인 후 비단위) 를 **직접 \(A\Rightarrow \gamma\)** 로 **평탄화**하므로, 생성 언어가 동일.

### 예제 (연쇄·사이클)

원문법
```
S → A
A → B
B → C | b
C → A | c
```
- 단위체인들: S⇒A⇒B⇒C⇒A…(사이클), B⇒C, C⇒A⇒B…
- \(\textsf{Unit}(S)=\{S,A,B,C\}\), 동일하게 A,B,C도 서로 포함.
- 비단위 규칙: \(B\to b,\ C\to c\)
- 끌어올리기:
  - S,A,B,C 각각에 \(→ b\)와 \(→ c\) 추가
- 단위 삭제 후(정리)
```
S → b | c
A → b | c
B → b | c
C → b | c
```
(생성/도달성 기준으로 더 축약 가능)

---

## 권장 단순화 파이프라인

1) **쓸모없는 기호 제거**
   - **비생성(Generating)** 제거: 단말로 끝나는 유도가 불가능한 비터미널 삭제
   - **비도달(Unreachable)** 제거: \(S\)에서 닿지 않는 기호 삭제
2) **ε-규칙 제거** (시작특례만 보존)
3) **단위 규칙 제거**
4) (선택) **정규형(CNF/GNF) 변환**
   - CNF: 단말 분리, 이항화
   - GNF: 선두 터미널 강제 + 좌재귀 제거 + 상향 치환

> 순서를 바꾸면 중간 크기 증가/반복작업이 커질 수 있음. 위 순서가 **안정적**입니다.

---

## 자주 나오는 함정 · 체크리스트

- [ ] **시작특례**: \(\varepsilon\in L(G)\)이면 **새 시작기호 \(S_0\)** 를 도입하고 \(S_0\to S\mid \varepsilon\)만 허용. 그 외 ε 금지.
- [ ] **S가 우변에 등장**: \(S_0\to S\)로 감싸야 ε-제거/단위-제거 중 **언어 보존**이 쉽다.
- [ ] **ε-제거 조합 폭발**: 우변 Nullable 수가 많은 규칙은 조합 수 급증 → 보통 실제 문법에선 제한적. 중복 제거 필수.
- [ ] **단위사이클**: \(A\Rightarrow^*A\) 탐지해 무한치환 방지.
- [ ] **정리 반복**: 변환 후에 **비생성/비도달** 기호가 새로 생길 수 있으므로 재정리.

---

## 수학적 스냅샷

### ε-제거 생성 규칙 집합

\(A\to X_1\cdots X_k\)와 \(\{i\mid X_i\in\textsf{Null}\} = I\)일 때
\[
\forall J\subseteq I,\quad A\to \prod_{j=1}^k Y_j(J)
\]
단, \(Y_j(J)=\varepsilon\) if \(j\in J\) else \(X_j\).
빈곱(완전삭제)은 \(A=S_0\)일 때만 허용.

### 단위-폐포

\[
\textsf{Unit}(A)=\{B\in V\mid A\Rightarrow^*B\ \text{via only unit rules}\}
\]
변환 후 규칙:
\[
R'=\bigcup_{A\in V}\ \bigcup_{B\in \textsf{Unit}(A)} \{\, A\to \gamma \mid (B\to \gamma)\in R,\ \gamma\notin V \,\}
\]

---

## 파이썬 예제 코드 (교육용, 완결형 스니펫)

> 목적: **ε-제거** & **단위-제거**(+ 쓸모없는 제거) 구현 및 시연.
> 표현: 비터미널=대문자 문자열, 터미널=소문자/기호 문자열. \(\varepsilon\)은 **빈 튜플 `()`**.

```python
# cfg_simplify.py — ε-규칙/단위 규칙 제거 (교육용)

from collections import defaultdict, deque
from itertools import chain, combinations

class CFG:
    def __init__(self, V, Sigma, R, S):
        self.V     = set(V)                # nonterminals
        self.Sigma = set(Sigma)            # terminals
        self.S     = S                     # start
        self.R     = defaultdict(set)      # A -> { rhs (tuple) }
        for A, rhss in R.items():
            for rhs in rhss:
                self.R[A].add(tuple(rhs))  # () denotes ε

    # pretty print
    def show(self, title=None):
        if title: print(f"== {title} ==")
        for A in sorted(self.R):
            outs = []
            for rhs in sorted(self.R[A]):
                outs.append("".join(rhs) if rhs else "ε")
            print(f"{A} → " + " | ".join(outs))
        print()

    def clone(self):
        return CFG(self.V.copy(), self.Sigma.copy(),
                   {A:[list(r) for r in rhss] for A,rhss in self.R.items()},
                   self.S)

def introduce_S0(g: CFG):
    S0 = "_S0"
    while S0 in g.V or S0 in g.Sigma: S0 = "_" + S0
    g.V.add(S0)
    g.R[S0].add((g.S,))
    g.S = S0
    return g

def compute_nullable(g: CFG):
    Null = set()
    changed = True
    while changed:
        changed = False
        for A in g.V:
            if A in Null: continue
            for rhs in g.R[A]:
                if len(rhs)==0:  # ε
                    Null.add(A); changed=True; break
                if all((X in Null) for X in rhs if X in g.V):
                    Null.add(A); changed=True; break
    return Null

def remove_epsilon(g: CFG, keep_start_empty=True):
    # optional: introduce S0 first (recommended)
    Null = compute_nullable(g)
    newR = defaultdict(set)

    for A in g.V:
        for rhs in g.R[A]:
            if len(rhs)==0:
                # drop ε now; we'll re-add only for start (if allowed)
                continue
            # positions of nullable nonterminals
            idxs = [i for i,X in enumerate(rhs) if X in Null]
            # enumerate subsets of idxs to drop
            for k in range(1<<len(idxs)):
                drop = { idxs[j] for j in range(len(idxs)) if (k>>j)&1 }
                cand = tuple(X for i,X in enumerate(rhs) if i not in drop)
                if len(cand)>0:
                    newR[A].add(cand)
                else:
                    # empty produced: only allow if start and allowed
                    if keep_start_empty and A==g.S:
                        newR[A].add(tuple())

    # preserve non-nullable originals too
    # (already included by subset with drop=∅)
    g.R = newR
    return g

def remove_unit(g: CFG):
    # compute unit-closure
    unit = {A:{A} for A in g.V}
    changed = True
    while changed:
        changed = False
        for A in g.V:
            for rhs in g.R[A]:
                if len(rhs)==1 and rhs[0] in g.V:
                    B = rhs[0]
                    if B not in unit[A]:
                        unit[A].add(B); changed=True
                        unit[A] |= unit[B]

    # build new rules without unit rules
    newR = defaultdict(set)
    for A in g.V:
        for B in unit[A]:
            for rhs in g.R[B]:
                # skip unit rules
                if not (len(rhs)==1 and rhs[0] in g.V):
                    newR[A].add(rhs)
    g.R = newR
    return g

def remove_useless(g: CFG):
    # generating
    gen = set()
    changed = True
    while changed:
        changed = False
        for A in g.V:
            if A in gen: continue
            for rhs in g.R[A]:
                if all((X in g.Sigma) or (X in gen) for X in rhs):
                    gen.add(A); changed=True; break

    # reachable
    reach = {g.S}
    q = deque([g.S])
    while q:
        A = q.popleft()
        for rhs in g.R[A]:
            for X in rhs:
                if X in g.V and X not in reach:
                    reach.add(X); q.append(X)

    # prune
    g.V = g.V & gen & reach
    g.R = {A: set(r for r in rhss if all((X in g.Sigma) or (X in g.V) for X in r))
           for A, rhss in g.R.items() if A in g.V}
    return g

# ---------- demo ----------

if __name__ == "__main__":
    # Example 1 (from text)
    V     = {"S","A","B"}
    Sigma = {"a","b"}
    R     = {
        "S": [["A","B"], ["a"]],
        "A": [()],               # ε
        "B": [["b"]],
    }
    G = CFG(V,Sigma,R,"S")
    G.show("Original G")

    introduce_S0(G).show("After introducing S0")
    # allow ε at start only if language had ε; here it does not (S not nullable)
    remove_epsilon(G, keep_start_empty=False).show("After ε-removal")
    remove_unit(G).show("After unit-removal")
    remove_useless(G).show("After useless removal")

    # Example 2 (nullable chain)
    V     = {"S","A","B","X"}
    Sigma = {"a","b","c"}
    R     = {
        "S": [["A","X","B"], ["B"], ()],
        "A": [["a"], ()],
        "B": [["b","B"], ()],
        "X": [["c"]],
    }
    G2 = CFG(V,Sigma,R,"S")
    G2.show("Original G2")

    introduce_S0(G2)
    # G2 accepts ε, so keep_start_empty=True to allow S0→ε
    remove_epsilon(G2, keep_start_empty=True).show("G2 after ε-removal")
    remove_unit(G2).show("G2 after unit-removal")
    remove_useless(G2).show("G2 after useless removal")
```

**실행 포인트**
- `introduce_S0` → ε 특례를 안전하게 다루는 출발점
- `remove_epsilon` → Null 집합 기반 조합 추가
- `remove_unit` → unit-closure 기반 평탄화
- `remove_useless` → 변환 후 정리

> 참고: 상용/대형 문법에선 **중복 억제**, **이름충돌 방지**, **성능 튜닝**(예: 비트셋/고속맵)이 필요합니다.

---

## “상황별” 활용 가이드

### CNF로 가고 싶다

1. `remove_useless` → 2. `remove_epsilon` → 3. `remove_unit`
4. **단말 분리(길이≥2 우변)** → 5. **이항화** → CNF 점검

### LR 파서 문법 최적화

- ε-규칙/단위 규칙을 제거하면 **아이템 세트** 수, **GOTO** 분기가 줄어 LR 테이블이 단순해짐.

### 동치성 회귀 테스트(소형)

- 원문법/단순화 문법으로 **길이 ≤ k** 문자열을 생성 비교. (완전증명은 아니나 회귀에 유용)

---

## 요약 체크리스트

- [ ] ε-규칙: 시작 특례 \(S_0\to\varepsilon\) 외 **전부 제거**
- [ ] Nullable 기반 **조합적 생략 규칙** 생성
- [ ] 단위-폐포로 **비단위 규칙 끌어올리기**
- [ ] 변환 후 **비생성/비도달** 재정리
- [ ] 필요 시 **S가 우변에 등장**하면 **\(S_0\)** 도입
- [ ] CNF/GNF 변환 단계로 자연스럽게 연결

---

## 한 줄 결론

> **ε-규칙은 “생략의 경우의 수”를, 단위 규칙은 “평탄화”로 대체한다.**
> 시작기호의 ε 특례만 지키면, 두 변환은 **언어를 보존**하면서 문법을 **파서 친화적**으로 정제한다.
