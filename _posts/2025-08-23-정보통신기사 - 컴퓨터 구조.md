---
layout: post
title: 정보통신기사 - 컴퓨터 구조
date: 2025-08-23 10:25:23 +0900
category: 정보통신기사
---
# 컴퓨터 구조: CPU · 메모리 · I/O 완전정복

> **목표**: 정보통신/컴공/개발·운영 실무 관점에서 **CPU(명령어 집합·마이크로아키텍처)**,  
> **메모리 계층(캐시·TLB·DRAM·가상메모리·NUMA)**, **I/O(인터럽트·DMA·버스·스토리지·NIC)**를  
> “원리 → 공식/수식 → 예제 → 설계/튜닝 → 체크리스트 → 연습문제” 순으로 **생략 없이** 정리합니다.  
> 수식은 **MathJax**, 코드/어셈은 **코드블록**, 구조는 **ASCII 도식**을 사용합니다.

---

## 0) 큰 그림: 성능은 **CPI×주파수×병렬성**, 지연은 **메모리·I/O**가 결정

```
[프로그램/데이터]
      ↓  (컴파일/링크/로더)
[ISA: 명령어] → [CPU 파이프라인/OOO/분기예측] → [L1/L2/L3 캐시 & TLB]
                                         ↘
                                   [메모리 컨트롤러] → [DRAM/NUMA]
                                         ↘
                                          [I/O]: PCIe ↔ [NVMe/SSD/HDD/NIC/GPU]
```

- **CPU**: ISA를 해석·실행. 파이프라인·Out-of-Order(OOO)·분기예측·벡터(SIMD).  
- **메모리**: L1/L2/L3 캐시 ↔ TLB ↔ DRAM(은행/행버퍼). **AMAT**가 핵심.  
- **I/O**: 인터럽트/폴링/ DMA/ IOMMU/ PCIe. 저장장치·네트워크·가속기.

---

## 1) 성능 모델 한 장

### 1.1 기본 식
\[
\textbf{CPU Time} = \frac{\text{명령어 수} \times \text{CPI}}{f}\quad
\textbf{IPC} = \frac{1}{\text{CPI}}
\]
- **명령어 수**: 컴파일러/ISA 영향, **CPI**: 마이크로아키텍처/메모리 병목, **주파수 \(f\)**: 공정/전력/발열.

### 1.2 암달의 법칙/거스타프슨
\[
S=\frac{1}{(1-p)+\frac{p}{s}},\qquad
S_\text{Gustafson}\approx (1-p)+sp
\]
- 병렬화 가능 비율 \(p\)와 가속배율 \(s\). “일부만 빨라도 전체는 제한”.

### 1.3 CPI 스택 (예)
\[
\text{CPI} = \text{CPI}_\text{ideal} + \text{분기 페널티} + \text{L1 miss} + \text{L2 miss} + \dots
\]
- 측정으로 **병목 항**을 정량화 → 최적화 포인트 결정.

---

## 2) ISA(명령어 집합)와 주소지정

### 2.1 RISC vs CISC
- **RISC**: 고정 길이, 단순 디코드, 레지스터 중심(ARM/RISC-V).  
- **CISC**: 가변 길이, 복합 명령(x86) → 내부에선 **µop**로 분해.

### 2.2 주소지정 모드(핵심)
- 즉시, 레지스터, 변위(기저+오프셋), 상대(PC상대), 간접, 인덱스.  
- **루프/배열**: 기저+변위, **분기**: PC상대.

**x86 예**
```asm
; sum += a[i]
mov rax, [rbx + rcx*4]   ; rbx=base, rcx=index, scale=4 (int)
add rdx, rax             ; rdx = sum
```

---

## 3) CPU 마이크로아키텍처

### 3.1 파이프라인(5단 예)
```
IF → ID → EX → MEM → WB
```
- **해저드**: 데이터(포워딩/버블), 제어(분기예측), 구조(자원경합).

### 3.2 슈퍼스칼라 & OOO
- **다중 발급**(IPC↑), **레지스터 리네이밍**(WAW/ WAR 해소), **리오더버퍼(ROB)**(정확한 예외/커밋).  
- **예약스테이션/스케줄러**가 준비된 명령을 유닛에 **동적 발행**.

### 3.3 분기예측
- **정적**(not-taken), **BTFNT**, **2비트 포화 카운터**, **Gshare/TAGE**(고급).  
- **BTB**(분기 타깃 버퍼), **RAS**(리턴 주소 스택).  
- **미스 페널티**: 파이프라인 깊이에 비례 → **프론트엔드 성능의 핵심**.

### 3.4 벡터/SIMD
- SSE/AVX/NEON/RVV. **한 명령으로 다수 데이터**(데이터 병렬).  
- **정렬/로드-스토어 패턴**이 성능을 좌우.

### 3.5 예: 분기예측 효과
- 분기 빈도 15%, 미스율 5%, 미스 페널티 12사이클, 기본 CPI 1.0  
\[
\Delta \text{CPI} = 0.15 \times 0.05 \times 12 = 0.09 \Rightarrow \text{CPI} \approx 1.09
\]

---

## 4) 캐시/메모리 계층

### 4.1 AMAT
\[
\text{AMAT} = T_{L1} + m_{L1}(T_{L2} + m_{L2}(T_{L3} + m_{L3} T_\text{Mem}))
\]

### 4.2 사상/교체/쓰기
- **사상**: 직접/집합연관(\(N\)-way)/완전연관.  
- **교체**: LRU/PLRU/Random.  
- **쓰기**: Write-through vs Write-back, Write-allocate vs No-allocate.

### 4.3 지역성
- **시간/공간 지역성**; **스트라이드/히트율**을 높이는 **배치/타일링**.

### 4.4 예: AMAT 계산
- L1 1ns, miss 5% → L2 4ns, miss 10% → Mem 60ns  
\[
\text{AMAT}=1 + 0.05(4 + 0.10 \times 60)=1+0.05(10)=1.5\text{ns}
\]

### 4.5 캐시 인덱싱 요령
- 주소 = [Tag | Index | BlockOffset]. **거의 항상** BlockOffset=log2(블록크기).

---

## 5) 가상메모리/페이지/TLB

### 5.1 개념
- **가상주소 → 페이지 테이블 → 물리주소**.  
- **페이지 폴트** 시 디스크에서 적재.  
- **TLB**: 페이지 테이블 캐시(히트가 매우 중요).

### 5.2 다단 페이지 테이블
- 4KB 페이지, 48비트 VA → 4/5단 구조. **Huge Page(2MB/1GB)**로 오버헤드↓.

### 5.3 TLB 미스 비용
\[
\text{EAT} = (1-p)\cdot T_\text{hit} + p\cdot(T_\text{walk}+\text{AMAT})
\]
- \(p\) = TLB miss 비율. **Huge Page**로 \(p\)↓.

### 5.4 페이지 교체
- LRU·Clock·WSClock(작업셋). **스래싱** 방지: **워킹셋** 유지.

---

## 6) DRAM/메모리 컨트롤러

### 6.1 DRAM 타이밍
- tCL(컬럼 레이턴시), tRCD(행 활성→컬럼), tRP(프리차지), **Row Buffer** 히트/미스.

### 6.2 은행/채널 병렬성
- 여러 **Bank/Rank/Channel**로 병렬 처리 → **대역폭↑**.  
- **주소 인터리빙**으로 고르게 분산.

### 6.3 예: 대역폭 근사
\[
\text{BW} \approx \text{MT/s} \times \text{BusWidth(bytes)} \times \text{Channels}
\]
- DDR4-3200, 64bit(8B), 2채널 → \(3200\text{M} \times 8 \times 2 \approx 51.2\ \text{GB/s}\)

---

## 7) 일관성/동기화(멀티코어)

### 7.1 캐시 일관성
- **MESI/MOESI**: Modified/Exclusive/Shared/Invalid(+Owned).  
- **스누핑 vs 디렉터리 기반**.

### 7.2 메모리 모델
- **SC/TSO/RC** 등. **배리어/펜스**로 재배치 제어.

**C 예**
```c
// 생산자-소비자 플래그: 배리어 필요
atomic_store_explicit(&data, x, memory_order_release);
atomic_store_explicit(&flag, 1, memory_order_release);
/* 소비자 */
while(atomic_load_explicit(&flag, memory_order_acquire)==0);
int y = atomic_load_explicit(&data, memory_order_acquire);
```

---

## 8) NUMA(비균일 메모리 접근)

### 8.1 원리
- 소켓별 **로컬 메모리**. 로컬 < 리모트 지연.  
- **페이지 배치/스레드 바인딩** 중요.

### 8.2 튜닝
- **numactl --cpunodebind/--membind**, **first-touch** 정책.  
- **데이터-스레드** 근접 배치 → 지연↓, 대역폭↑.

---

## 9) I/O 서브시스템

### 9.1 버스/링크
- **PCIe**: 레인×속도(Gen3/4/5…), **MSI/MSI-X**(메시지 인터럽트).  
- **IOMMU**: DMA 주소 변환/격리.

### 9.2 인터럽트/폴링/DMA
- **폴링**: 간단·CPU소모↑, 저지연 이벤트 적음.  
- **인터럽트**: 효율↑, 빈발 시 오버헤드↑ → **NAPI**(Coalesce/폴링 혼합).  
- **DMA**: 장치↔메모리 직접 전송. CPU는 **설정·완료 통보**만.

### 9.3 메모리 매핑 I/O
- **MMIO**: 장치 레지스터를 **주소 공간**에 매핑.  
- **PIO**(포트 I/O, x86 전용)도 있으나 현대엔 MMIO 위주.

---

## 10) 스토리지: HDD vs SSD vs NVMe

### 10.1 HDD
- **회전/탐색** 지연 → 랜덤 I/O 약. **디스크 스케줄링**(SCAN/C-SCAN).

### 10.2 SSD(NAND)
- **페이지/블록 지우기**, **FTL**(매핑), **웨어레벨링**, **GC**, **쓰기증폭**.  
- **TRIM** 지원으로 유휴블록 확보.

### 10.3 NVMe
- **Submission/Completion 큐** 다중, **큐 깊이(QD)**로 병렬 IOPS↑.  
- **PCIe 레인/세대**에 비례해 처리량↑.

### 10.4 예: IOPS↔처리량
\[
\text{Throughput(MB/s)} \approx \frac{\text{IOPS}\times \text{BlockSize(KB)}}{1024}
\]
- 64kB 블록, 200k IOPS → \(\approx 12{,}500\ \text{MB/s}\) (링크/컨트롤러 한계 내).

---

## 11) 네트워크 I/O(간단)

- **NIC**: Rx/Tx 링버퍼, DMA, **Checksum/TSO/LRO** 오프로드.  
- **NAPI**: 인터럽트 폭주 방지, 고속 구간 폴링.  
- **Zero-copy**: **sendfile/mmap**, 유저-커널 복사 최소화.  
- **DPDK**: 폴링 모드 드라이버로 커널 우회(초고성능).

---

## 12) GPU/가속기 개요

- **SIMT**(수천 스레드), 고대역폭 메모리(HBM), 호스트↔디바이스 복사 비용 주의.  
- **PCIe/ NVLink** 경로, **커널 런치 오버헤드**. **Batch/타일링**으로 은닉.

---

## 13) 전력/발열: DVFS & C/P 상태

- **P-state**: 주파수/전압 조절, **C-state**: 유휴 전력 절감(깊을수록 복귀 지연↑).  
- **열 스로틀링** 방지: 쿨링/전력제한/코어 분산.

---

## 14) 신뢰성/ECC/스크러빙

- **ECC DRAM**: 단일비트 정정, 이중 탐지.  
- **메모리 스크러빙**: 백그라운드 검사/정정.  
- **Parity**: 캐시/내부 버스 오류 검출.

---

## 15) 보안·사이드채널 한 줄 요약

- **Speculative Execution**(Spectre/Meltdown 계열): 추측실행+캐시 관측 → 완화(배리어/격리/마이크로코드).  
- **TEE**: SGX/SEV/TDX—신뢰실행환경.

---

## 16) 코드/튜닝 예제 모음

### 16.1 캐시 친화적 루프(타일링)
```c
// 행주도 순회(연속 접근)로 캐시 히트↑
for (int i=0; i<N; i++)
  for (int j=0; j<M; j++)
    C[i][j] = A[i][j] + B[i][j];

// 타일링(블록행렬)
for (int ii=0; ii<N; ii+=BS)
  for (int jj=0; jj<M; jj+=BS)
    for (int i=ii; i<ii+BS; i++)
      for (int j=jj; j<jj+BS; j++)
        C[i][j] = A[i][j] + B[i][j];
```

### 16.2 프리패치/벡터(개념)
```c
// GNU C 내장 프리패치 (힌트)
__builtin_prefetch(&A[i+64], 0, 3);
```

### 16.3 NUMA 바인딩(리눅스)
```bash
numactl --cpunodebind=0 --membind=0 ./app
```

### 16.4 메모리 장벽(원자 연산)
```c
atomic_thread_fence(memory_order_seq_cst); // 강한 순서 보장
```

---

## 17) 측정/관측 퀵가이드

- **pmu/perf**: CPI, LLC miss, branch-miss, stalled cycles.  
- **numastat/pcm-memory**: 소켓별 대역폭/지연.  
- **iostat/fio**: IOPS/QD/지연, **nvme top**.  
- **ethtool -S**: NIC 드롭/큐 통계.

---

## 18) 자주 틀리는 포인트(정오표)

1) **주파수만** 올리면 빨라진다? → **CPI/메모리 병목**가 크면 체감↓.  
2) L1 miss가 곧 DRAM 접근? → **L2/L3 경유**, AMAT로 누적 계산.  
3) **Write-through=항상 안전**? → 대역폭 낭비, **WB+배리어**가 일반적.  
4) TLB는 작다 → **Huge Page**로 TLB 미스 크게↓.  
5) NUMA가 자동으로 최적? → **스레드·메모리 바인딩** 필요.  
6) SSD=랜덤 무제한? → **QD/쓰기증폭/열화/GC**가 한계.  
7) DPDK가 항상 최고? → **전용 코어/바운딩/권한** 비용·복잡성↑.

---

## 19) 체크리스트(설계/튜닝)

### CPU/코드
- [ ] **CPI 스택** 측정(분기/캐시/메모리).  
- [ ] **분기예측** 민감 코드 → **분기 제거/테이블화**.  
- [ ] **SIMD** 벡터화, **정렬/연속 접근**.

### 메모리
- [ ] **타일링/프리패치**로 공간·시간 지역성↑.  
- [ ] **Huge Page**(2MB/1GB) 검토, TLB 미스↓.  
- [ ] **NUMA 바인딩**/first-touch.

### I/O
- [ ] **QD/배치** 최적(SSD/NVMe/NIC).  
- [ ] **인터럽트 코얼레싱/NAPI** 조정.  
- [ ] **IOMMU/핫패스** 맵핑 고정(PIN) 고려.

---

## 20) 연습문제(풀이 포함)

**Q1.** 분기빈도 20%, 미스율 4%, 페널티 10사이클, 기본 CPI 1.0. 유효 CPI?  
**A.** \(\Delta\)=0.2×0.04×10=0.08 → **1.08**.

**Q2.** L1=1ns(미스 6%), L2=4ns(미스 8%), Mem=80ns. AMAT?  
**A.** \(1+0.06(4+0.08×80)=1+0.06(10.4)=1.624\)ns.

**Q3.** DDR5-5600, 64bit, 2채널 이론 대역폭?  
**A.** \(5600M×8B×2=89.6\ \text{GB/s}\).

**Q4.** 64B 캐시 블록, 주소 0x1000 접근 후 0x103F 접근. 같은 블록?  
**A.** 범위 0x1000~0x103F = **같은 64B 블록**.

**Q5.** NVMe QD=32, 4kB 랜덤 읽기 600k IOPS의 처리량(MB/s)?  
**A.** \(600k×4/1024≈2344\ \text{MB/s}\).

**Q6.** 4KB 페이지, 48비트 VA, 4단 페이지테이블. 인덱스 비트 수 합?  
**A.** 오프셋 12비트, 나머지 36비트 → 4단이면 **각 9비트**(총 36).

**Q7.** MESI에서 두 코어가 같은 라인에 쓰기-쓰기 경쟁 시 상태 전이?  
**A.** 둘 다 **M** 유지 불가 → 버스 트랜잭션으로 상대를 **I**로 만들고 자신이 **M**.

---

## 21) 미니 실습 스니펫

### 21.1 Linux perf(개념 명령)
```bash
perf stat -e cycles,instructions,branches,branch-misses,LLC-loads,LLC-load-misses ./app
# IPC ≈ instructions/cycles
```

### 21.2 fio(NVMe 랜덤 4k)
```ini
[global]
ioengine=io_uring
iodepth=32
direct=1
time_based=1
runtime=30
bs=4k
rw=randread
name=nvme4k
filename=/dev/nvme0n1
```

---

## 22) 한 페이지 암기표(초압축 20줄)

1) **CPU시간**=\(\frac{\#inst\times \text{CPI}}{f}\), **IPC**=\(1/\text{CPI}\)  
2) **암달**: \(S=\frac1{(1-p)+p/s}\)  
3) **파이프라인 3해저드**: 데이터/제어/구조  
4) **분기예측**: BTB+RAS+2bit/TAGE  
5) **캐시 정책**: 연관도/교체(LRU/PLRU)/쓰기(WB/WT)  
6) **AMAT**: \(L1 + m_1(L2+m_2(L3+m_3 Mem))\)  
7) **TLB/HugePage**로 주소변환 비용↓  
8) **DRAM**: tCL/tRCD/tRP, Row Buffer 히트↑  
9) **NUMA**: first-touch, 스레드·메모리 바인딩  
10) **MESI/MOESI** 일관성  
11) **메모리 모델**: acquire/release/seq_cst  
12) **PCIe/MSI-X/IOMMU**  
13) **DMA**: CPU우회, 큐/디스크립터  
14) **NVMe**: 다중 큐, QD로 IOPS↑  
15) **SSD**: FTL/GC/쓰기증폭, TRIM  
16) **NIC**: NAPI/TSO/LRO/zero-copy  
17) **SIMD/타일링/프리패치**  
18) **DVFS/C-state** 전력관리  
19) **ECC/스크러빙** 신뢰성  
20) **측정 우선**: perf/numa/iostat/ethtool

---

## 23) 마무리

**CPU**는 분기예측·파이프라인·OOO로 **명령 병렬성**을, **메모리 계층**은 캐시·TLB·DRAM으로 **데이터 지연**을 다룹니다.  
**I/O**는 PCIe/DMA/NVMe/NIC로 **대역·지연·병렬 큐**를 설계/튜닝합니다.  
항상 **측정(CPI 스택·AMAT·QD/IOPS)** → **문제 정의** → **국소 최적화(SIMD/NUMA/큐/배리어)**의 순서로 접근하세요.  
“**빠른 코드**”는 **아키텍처를 아는 코드**입니다.
