---
layout: post
title: DB 심화 - ASH
date: 2025-10-24 21:25:23 +0900
category: DB 심화
---
# Oracle **ASH (Active Session History)**

## 큰 그림: ASH를 왜 쓰나?

- **AWR**는 1시간 단위(기본) 요약 스냅샷, **ASH**는 **1초** 주기로 “**활성 세션**”의 상태를 샘플링한다.
- ASH의 행(Row)은 “**그 초에 활성(ON CPU 또는 WAITING)** 했던 **한 세션**의 스냅샷”이다.
- 이 **행들의 집합**(시간범위 필터)을 **집계**하면, “**어떤 대기 클래스/이벤트**가 **언제/얼마나** 발생했고 **어떤 SQL/서비스/모듈/인스턴스**에서 집중되는지”가 보인다.
- 핵심 식:
  - **응답시간 분해**:
    $$ T_{\mathrm{elapsed}} = T_{\mathrm{CPU}} + \sum_k T_{\mathrm{wait},k} $$
  - **평균 활성 세션(AAS)**:
    $$ \mathrm{AAS} \approx \frac{\mathrm{DB\ Time}}{\mathrm{벽시계\ 시간}} \approx \frac{\#\mathrm{ASH\ rows}}{\Delta t} $$
    (초당 1번 샘플링 가정에서, ASH 샘플 수는 DB Time에 비례)

> 라이선스 주의: ASH/SQL Monitor/ADDM 등은 **Diagnostics Pack** 범주다(엔터프라이즈 에디션 + 옵션). 학습/데브 환경에서도 정책 준수 필수.

---

## & 주요 뷰

### 采樣 메커니즘 요약

- 샘플링 주기: **1초** (버전에 따라 튜너블/스케줄러 영향 가능)
- 저장: 메모리 내 **X$** 기반 버퍼, AWR 스냅샷 시점에 **DBA_HIST_ACTIVE_SESS_HISTORY**로 일부 요약 보존
- 관측 대상: **활성 세션**(foreground) — `session_state`가 `ON CPU` 또는 `WAITING`
- 저장 항목(일부):
  - **시간/인스턴스**: `sample_time`, `instance_number`
  - **세션**: `session_id`, `session_serial#`, `session_type`, `blocking_session` 등
  - **대기**: `session_state`, `event`, `wait_class`, `p1/p2/p3`, `time_waited`, `time_waited_micro`
  - **SQL**: `sql_id`, `sql_child_number`, `sql_plan_hash_value`, `sql_plan_line_id`
  - **업무 차원**: `service_hash`(또는 `service_name`), `module`, `action`, `client_id`, `machine`, `program`
  - **오브젝트/파일**: `current_obj#`, `current_file#`, `current_block#`

### 조회 뷰

- **실시간**: `V$ACTIVE_SESSION_HISTORY`
- **히스토리(AWR)**: `DBA_HIST_ACTIVE_SESS_HISTORY`
- 보조: `V$SESSION`(현재 세션 상태/블로킹 스냅), `V$SYSTEM_EVENT`(누적), `V$SQL*`, `V$SERVICES`

---

## 컬럼 해부(필수만 정확히)

| 컬럼 | 의미/해석 팁 |
|---|---|
| `sample_time` | 샘플 시각(1초 그리드). 시간 버킷팅의 키 |
| `session_type` | `FOREGROUND`만 주로 봄(`BACKGROUND` 필터링) |
| `session_state` | `ON CPU` 또는 `WAITING` |
| `event`/`wait_class` | **대기의 이름표** (예: `db file sequential read`, `direct path read temp`, `enq: TX - ...`) |
| `time_waited` | micro 단위(버전에 따라 집계 기준 다름). 샘플수 기반 분석이 보통 더 직관 |
| `sql_id`/`sql_child_number` | **어떤 SQL**인가 |
| `sql_plan_hash_value`/`sql_plan_line_id` | **실행계획과 라인** 매핑(Plan 라인 병목 판정 핵심) |
| `service_hash`/`module`/`action`/`client_id` | **업무/유저 흐름** 세분화 |
| `blocking_session`/`blocking_session_status` | **락 원인자** 추적 |
| `current_obj#`/`current_file#`/`current_block#` | **핫 오브젝트/파일/블록** 추적 |

---

## 시작점: 10~15분 “핫 구간” 고정

```sql
VAR t1 TIMESTAMP; VAR t2 TIMESTAMP;
EXEC :t1 := SYSTIMESTAMP - INTERVAL '15' MINUTE;
EXEC :t2 := SYSTIMESTAMP;
```

핫 구간을 결정하는 3가지 근거:
1) **현장의 신고 시간대**(“10:30~10:45쯤 느렸다”)
2) **AWR Load Profile** 피크
3) **게이트웨이/웹 로그**의 p95 악화 시간대

---

## 탑다운 레시피: 2분 내 윤곽 잡기

### Wait Class/Event 프로파일

```sql
SELECT wait_class, event, COUNT(*) AS samples,
       ROUND(100*RATIO_TO_REPORT(COUNT(*)) OVER (),1) AS pct
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY wait_class, event
ORDER  BY samples DESC FETCH FIRST 15 ROWS ONLY;
```
- 상위 **Wait Class/Event**가 응답시간의 주범(“이름표”).

### Top SQL (응답시간 기여 상위)

```sql
SELECT sql_id,
       COUNT(*) AS samples,
       SUM(CASE WHEN session_state='ON CPU' THEN 1 ELSE 0 END) AS on_cpu,
       SUM(CASE WHEN session_state='WAITING' THEN 1 ELSE 0 END) AS on_wait
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY sql_id
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;
```

### 시각화용 시간 버킷(초/분 단위)

```sql
WITH buckets AS (
  SELECT CAST(sample_time AS DATE) AS ts,
         wait_class
  FROM   v$active_session_history
  WHERE  sample_time BETWEEN :t1 AND :t2
  AND    session_type='FOREGROUND'
)
SELECT TO_CHAR(ts,'HH24:MI:SS') AS sec,
       wait_class,
       COUNT(*) AS samples
FROM   buckets
GROUP  BY ts, wait_class
ORDER  BY MIN(ts), wait_class;
```
- 라인차트로 그리면 **언제** 어떤 대기가 **튀는지** 보인다.

---

## 라인 매핑: ASH → DBMS_XPLAN(SQL 라인 통계)

Top SQL 한 건을 골라 **실제 계획/라인**으로 내린다.
```sql
-- 마지막 실행/최근 Child 자동
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(
    :sql_id, NULL, 'ALLSTATS LAST +PREDICATE +PROJECTION +PEEKED_BINDS +OUTLINE +NOTE'
  )
);
```
- **어느 라인**(예: `SORT GROUP BY`, `HASH JOIN`, `TABLE ACCESS FULL`, `INDEX RANGE SCAN`, `TABLE ACCESS BY ROWID`)에서
  **Time/TempSpc/Buffers/A-Rows**가 큰지 → **병목 라인** 식별
- ASH에서 `sql_plan_line_id`가 높은 샘플 집중 구간 ↔ XPLAN의 같은 라인 수치가 높아야 **일관**.

---

## 계산(간이)

### AAS(평균 활성 세션)

샘플 수를 시간으로 나눠 근사:
```sql
WITH base AS (
  SELECT COUNT(*) AS samples
  FROM   v$active_session_history
  WHERE  sample_time BETWEEN :t1 AND :t2
    AND  session_type='FOREGROUND'
)
SELECT ROUND(samples / ( (EXTRACT(SECOND FROM (:t2-:t1))
                        +60*EXTRACT(MINUTE FROM (:t2-:t1))
                        +3600*EXTRACT(HOUR FROM (:t2-:t1)) ) ), 2) AS aas
FROM base;
```

### 퍼센타일(근사; 초 단위 버킷)

- 원칙적으로 **개별 트랜잭션 응답시간**이 필요하다.
- ASH만으로는 “활성 상태” 스냅숏이므로 직접 p95 응답을 구하기 어렵다.
- 대안: **초 단위 AAS** 분포의 p95 근사 → 혼잡/스파이크 검출용 (응답시간 대용량 데이터가 없을 때)
```sql
WITH sec_aas AS (
  SELECT TRUNC(CAST(sample_time AS DATE),'MI')
         + NUMTODSINTERVAL(TO_NUMBER(TO_CHAR(sample_time,'SS')),'SECOND') AS sec_bucket,
         COUNT(*) AS active
  FROM   v$active_session_history
  WHERE  sample_time BETWEEN :t1 AND :t2
    AND  session_type='FOREGROUND'
  GROUP  BY TRUNC(CAST(sample_time AS DATE),'MI')
         + NUMTODSINTERVAL(TO_NUMBER(TO_CHAR(sample_time,'SS')),'SECOND')
)
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY active) AS p50,
       PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY active) AS p90,
       PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY active) AS p99
FROM sec_aas;
```
> **정확한 응답시간 퍼센타일**은 **AP/게이트웨이/미들웨어**에서 “요청-응답”을 측정하여 DB 구간과 매칭 권장.

---

## 차원 분석(누가, 어디서, 무엇으로?)

### Service / Module / Action

```sql
-- Service x Module x Action 별 상위 대기
SELECT service_hash, module, action, wait_class, event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY service_hash, module, action, wait_class, event
ORDER  BY samples DESC FETCH FIRST 20 ROWS ONLY;

-- 서비스 이름(참고)
SELECT name, service_id, service_hash FROM v$active_services;
```

### Client Identifier / Machine / Program

```sql
SELECT client_id, machine, program, event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY client_id, machine, program, event
ORDER  BY samples DESC FETCH FIRST 20 ROWS ONLY;
```
- 다중 테넌트/고객/채널 구분 시 매우 유용.

### RAC(Instance 차원)

```sql
SELECT instance_number, wait_class, event, COUNT(*) samples
FROM   gv$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY instance_number, wait_class, event
ORDER  BY samples DESC;
```
- 인스턴스별 부하 불균형/Cluster wait 집중 확인.

---

## 블로커 추적(락/대기 체인)

### 블로킹 세션/락 체인(간이)

```sql
-- 해당 구간 TX 대기 세션과 블로커
SELECT session_id, blocking_session, COUNT(*) AS samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
  AND  event LIKE 'enq: TX%'
GROUP  BY session_id, blocking_session
ORDER  BY samples DESC;
```
> `blocking_session`가 NULL인 샘플도 있음(샘플 시점 race). `V$SESSION`과 교차 확인.

### 락 대상 정보(오브젝트/파일/블록)

```sql
SELECT current_obj#, current_file#, current_block#, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event LIKE 'enq: TX%'
GROUP  BY current_obj#, current_file#, current_block#
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;

-- 오브젝트 이름
SELECT owner, object_name, object_type
FROM   dba_objects
WHERE  object_id = :current_obj#;
```

---

## 대기 이벤트별 ASH 분석 → 실행계획 라인 연결

아래는 **대표 이벤트 → 라인**을 잇는 정석 루틴과 **예제 SQL**.

### User I/O — `direct path read temp` (정렬/해시 스필)

**진단**
```sql
-- 이벤트/SQL 상위
SELECT sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event = 'direct path read temp'
GROUP  BY sql_id
ORDER  BY samples DESC FETCH FIRST 5 ROWS ONLY;

-- 라인별 집중 (plan line id)
SELECT sql_plan_line_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  sql_id = :sql_id
  AND  event = 'direct path read temp'
GROUP  BY sql_plan_line_id
ORDER  BY samples DESC;
```
→ 상위 라인을 `DBMS_XPLAN.DISPLAY_CURSOR(...,'ALLSTATS LAST +PROJECTION')`로 열어 **TempSpc/Time** 확인.
**개선**: 카디널리티 정확화(히스토그램), 정렬 회피 인덱스, PGA↑, 해시→NL.

### User I/O — `db file sequential read` (랜덤 I/O)

**진단**
```sql
-- 특정 SQL에서 랜덤 I/O가 많은 라인 확인
SELECT sql_plan_line_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  sql_id = :sql_id
  AND  event = 'db file sequential read'
GROUP  BY sql_plan_line_id
ORDER  BY samples DESC;
```
**라인 해석**: `INDEX RANGE/UNIQUE SCAN` → `TABLE ACCESS BY ROWID` 라인에 **A-Rows/Time** 집중.
**개선**: 커버링 인덱스, 선택성 개선, 파티션 프루닝, 조인순서 조정.

### Concurrency — `enq: TX - row lock contention` (행잠금)

**진단**
```sql
-- 누가 누구를 막나
SELECT session_id, blocking_session, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event LIKE 'enq: TX%'
GROUP  BY session_id, blocking_session
ORDER  BY samples DESC;

-- FK 미인덱스 탐색(보조)
SELECT a.table_name, a.constraint_name
FROM   user_constraints a
WHERE  a.constraint_type='R'
  AND NOT EXISTS (
    SELECT 1 FROM user_ind_columns i
    WHERE  i.table_name=a.table_name
      AND  (i.column_name) IN (
            SELECT column_name FROM user_cons_columns WHERE constraint_name=a.constraint_name)
  );
```
**개선**: FK 인덱스, 긴 트랜잭션 단축, 업데이트 순서 정렬, ITL/INITRANS.

### Commit — `log file sync`

**진단**
```sql
SELECT COUNT(*) AS samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event='log file sync';

-- 서비스/모듈 단서
SELECT module, action, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event='log file sync'
GROUP  BY module, action
ORDER  BY samples DESC;
```
**개선**: 배치 커밋(업무 허용 시), 로그 장치/네트워크 지연 개선, 대량 DML의 커밋 수 줄이기.

### RAC — `gc current/cr block busy`

**진단**
```sql
SELECT instance_number, sql_id, event, COUNT(*) samples
FROM   gv$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  wait_class='Cluster'
GROUP  BY instance_number, sql_id, event
ORDER  BY samples DESC;

-- 라인 집중
SELECT sql_plan_line_id, COUNT(*) samples
FROM   gv$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  sql_id = :sql_id
  AND  wait_class='Cluster'
GROUP  BY sql_plan_line_id
ORDER  BY samples DESC;
```
**개선**: 서비스 로컬리티(데이터/서비스 묶기), 시퀀스 NOORDER/Reverse Key, 핫 파티션 분산.

---

## “시간 라인” 보기(타임라인/스파이크 탐지)

### 초 단위 타임라인(Wait Class Stacked)

```sql
WITH sec_class AS (
  SELECT CAST(sample_time AS DATE) AS sec,
         wait_class
  FROM   v$active_session_history
  WHERE  sample_time BETWEEN :t1 AND :t2
    AND  session_type='FOREGROUND'
)
SELECT TO_CHAR(sec,'HH24:MI:SS') AS sec,
       wait_class, COUNT(*) samples
FROM   sec_class
GROUP  BY sec, wait_class
ORDER  BY MIN(sec), wait_class;
```
시각화 도구(스택형 영역 그래프)로 보면, **정렬 스필 구간만 솟아오르는** 등 변화점이 뚜렷.

### SQL별 타임라인(히트맵)

```sql
WITH sec_sql AS (
  SELECT CAST(sample_time AS DATE) AS sec,
         sql_id
  FROM   v$active_session_history
  WHERE  sample_time BETWEEN :t1 AND :t2
    AND  session_type='FOREGROUND'
)
SELECT TO_CHAR(sec,'HH24:MI:SS') AS sec, sql_id, COUNT(*) samples
FROM   sec_sql
GROUP  BY sec, sql_id
ORDER  BY MIN(sec), sql_id;
```

---

## 시나리오 케이스 스터디(끝까지 따라하기)

### — `direct path read temp` 1위

**상황**
- 10:30~10:45 사이 보고서 페이지가 7~10초로 느려짐.
- OLAP 성향 쿼리.

**1) Wait/SQL 식별**
```sql
-- Top Wait/Event/SQL
SELECT event, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  session_type='FOREGROUND'
GROUP  BY event
ORDER  BY samples DESC;

SELECT sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event='direct path read temp'
GROUP  BY sql_id
ORDER  BY samples DESC FETCH FIRST 3 ROWS ONLY;
```

**2) 라인 집중**
```sql
SELECT sql_plan_line_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  sql_id=:sql_id
  AND  event='direct path read temp'
GROUP  BY sql_plan_line_id
ORDER  BY samples DESC;
```

**3) 라인 통계 확인**
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(:sql_id, NULL,
 'ALLSTATS LAST +PREDICATE +PROJECTION +PEEKED_BINDS +OUTLINE +NOTE'));
```
- `SORT GROUP BY` 라인 `TempSpc` ↑, `Time` ↑
- 상류에서 `A-Rows` 과대(카디널리티 오판)

**4) 조치**
- 스큐 컬럼 히스토그램 생성, 조인순서/필터 선행
- 정렬 회피 인덱스(커버링)
- PGA 상향/Workarea 정책 점검

**5) 효과 검증**
- 같은 시간대 다시 수집 → `direct path read temp` 샘플 급감, `TempSpc` 0 근접.

---

### — `enq: TX - row lock contention`

**상황**
- 특정 기능 사용 시 순간적인 전체 지연/타임아웃.

**1) 블로커/블로키**
```sql
SELECT session_id, blocking_session, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event LIKE 'enq: TX%'
GROUP  BY session_id, blocking_session
ORDER  BY samples DESC;
```

**2) 오브젝트 단서**
```sql
SELECT current_obj#, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event LIKE 'enq: TX%'
GROUP  BY current_obj#
ORDER  BY samples DESC;
```
→ `current_obj#` 매핑으로 부모/자식 테이블 추정. FK 미인덱스 가능.
**3) 조치**: FK 인덱스, 갱신 순서, 긴 트랜잭션 단축.
**4) 재검증**: TX 샘플 급감 확인.

---

### 피크타임 커밋 지연 — `log file sync`

**1) 이벤트/서비스/모듈**
```sql
SELECT module, action, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  event='log file sync'
GROUP  BY module, action
ORDER  BY samples DESC;
```
**2) 조치**: 배치 커밋, 로그 I/O/RTT 개선.
**3) 재검증**: 이벤트 샘플 ↓, p95 응답 ↓(AP 측정).

---

### RAC 글로벌 캐시 — `gc current block busy`

**1) 인스턴스/SQL**
```sql
SELECT instance_number, sql_id, COUNT(*) samples
FROM   gv$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  wait_class='Cluster'
GROUP  BY instance_number, sql_id
ORDER  BY samples DESC;
```

**2) 라인 집중**
→ 특정 인덱스 접근 라인에서 샘플 몰림.
**3) 조치**: 서비스 로컬리티, 시퀀스 NOORDER/Reverse Key, 파티션 분산.
**4) 재검증**: Cluster wait 샘플 급감.

---

## 운영 자동화 스니펫

### 한번에

```sql
-- Wait/Event
SELECT wait_class, event, COUNT(*) samples,
       ROUND(100*RATIO_TO_REPORT(COUNT(*)) OVER (),1) pct
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '15' MINUTE
  AND  session_type='FOREGROUND'
GROUP  BY wait_class, event
ORDER  BY samples DESC FETCH FIRST 12 ROWS ONLY;

-- SQL
SELECT sql_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time > SYSTIMESTAMP - INTERVAL '15' MINUTE
  AND  session_type='FOREGROUND'
GROUP  BY sql_id
ORDER  BY samples DESC FETCH FIRST 10 ROWS ONLY;
```

### 특정 SQL의 라인 집중/타임라인

```sql
-- 라인 집중
SELECT sql_plan_line_id, COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  sql_id=:sql_id
GROUP  BY sql_plan_line_id
ORDER  BY samples DESC;

-- 초 단위 타임라인
SELECT TO_CHAR(CAST(sample_time AS DATE),'HH24:MI:SS') sec,
       COUNT(*) samples
FROM   v$active_session_history
WHERE  sample_time BETWEEN :t1 AND :t2
  AND  sql_id=:sql_id
GROUP  BY CAST(sample_time AS DATE)
ORDER  BY MIN(CAST(sample_time AS DATE));
```

---

## 해석의 기술(함정 & 베스트 프랙티스)

**함정**
1) **ASH는 샘플링**: 정확한 시간 합이 아니라 **근사**. 샘플수로 보기.
2) `blocking_session`이 **NULL**일 수 있음(샘플 타이밍). `V$SESSION`/세션 트레이스 병행.
3) **퍼센타일 응답시간**은 ASH만으로 직접 계산 불가. AP 로그 연동 권장.
4) 짧은 구간(1~2분)만 보면 **노이즈**에 취약. 10~15분 권장.

**베스트 프랙티스**
1) 항상 **Top Wait/Event** → **Top SQL** → **라인**(DBMS_XPLAN/Monitor) 3단 점프.
2) **Service/Module/Action/Client ID** 로 국소화(문제 범위 최소화).
3) **RAC**는 인스턴스 단위로 먼저 나눠 본다.
4) **전/후 비교**: 같은 시간대/부하로 재측정, 샘플수 변화로 증명.
5) **AWR/SQL Monitor/V$SYSSTAT** 과 교차(증거 삼중화).

---

## 수학 리마인드

- **AAS 근사(ASH 기반)**
  $$ \mathrm{AAS} \approx \frac{\#\mathrm{활성\ 샘플}}{\Delta t\ \mathrm{(sec)}} $$
- **응답시간 분해**
  $$ T = T_\mathrm{CPU} + \sum_k T_{\mathrm{wait},k} $$
- **리틀의 법칙(감각)**
  $$ L = \lambda \times W \quad \Rightarrow \quad \mathrm{AAS} \approx \mathrm{TPS} \times \mathrm{Mean\ RT} $$

---

## 결론

- **ASH는 “초 단위 활동 지도”**다. 여기에 **이벤트**라는 이름표와 **SQL/라인/업무 차원** 좌표가 함께 찍힌다.
- 정석은 **Top Events → Top SQL → 라인(DBMS_XPLAN/Monitor) → 조치**.
- **RAC/Service/Module/Action/Client** 차원을 적극 활용해 **문제 범위를 좁혀**라.
- 효과는 **같은 구간**으로 **샘플수/비율**을 비교해 **증명**하라.

> 한 줄 정리
> **ASH = “언제, 무엇이, 누구에게”** 를 1초 그리드로 보여주는 돋보기.
> 이 돋보기로 대기의 얼굴을 확인하고, 계획 라인까지 내려가 **원인을 정확히 집는다**.
