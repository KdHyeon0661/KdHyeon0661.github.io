---
layout: post
title: 영상처리 - 비트맵 정의와 종류
date: 2025-09-12 22:25:23 +0900
category: 영상처리
---
# C++ 영상처리 프로그래밍 — 3장. **BMP 파일의 이해 & DIB 출력**

> 본 글은 **블로그 게시용**으로 구성되었고, **코드는 \`\`\`로 감싸고**, 수학식은 **MathJax**(`$...$`, `$$...$$`)를 사용합니다.  
> 목표: **BMP 구조를 바닥부터 이해**하고, **SetDIBitsToDevice / StretchDIBits**로 **화면에 정확히 출력**하는 “BmpShow” 실습까지 완주합니다.

---

## 3.1 | 비트맵 개요

### 3.1.1 비트맵 정의와 종류 (Raster vs. Vector, DDB vs. DIB)

- **비트맵(Bitmap)**: **픽셀 격자(raster)** 로 색/밝기 정보를 저장한 데이터.
- **벡터(Vector) 그래픽**과 달리 확대 시 픽셀이 보이며, **저장 용량**은 해상도·비트수에 비례.
- **Windows 비트맵 유형**
  - **DDB(Device-Dependent Bitmap)**: GDI 디바이스 종속, 포맷이 드라이버/디스플레이 특성과 얽힘.
  - **DIB(Device-Independent Bitmap)**: **장치 독립**. **BMP 파일**, **DIBSECTION** 등은 DIB 규약을 따름.  
    → 본 장은 **DIB** 중심(파일 구조/출력 API가 DIB 기반).

### 3.1.2 DIB의 좌표계: Bottom-Up vs Top-Down

- **전통 BMP**는 **Bottom-Up**: 파일상의 **첫 행이 이미지의 마지막 행**(아래쪽)  
  ↔ **Top-Down DIB**: `biHeight`를 **음수**로 두어 메모리를 **상단부터 아래로** 진행.
- 출력/처리 단순화를 위해 **내부 버퍼는 Top-Down(음수 높이 또는 자체 규약)** 을 권장.

### 3.1.3 색 깊이와 픽셀 포맷

- **Indexed**: 1/4/8bpp → **팔레트(색상 테이블)** + 인덱스 픽셀
- **Direct(트루컬러)**: 16/24/32bpp → 픽셀값이 곧 색.  
  - 16bpp(5-6-5), 24bpp(BGR), 32bpp(BGRA 또는 BGRX).  
  - **GDI 전통**: 채널 순서는 **B,G,R,(A)**.

---

## 3.2 | BMP 파일의 이해

### 3.2.1 BMP 파일의 전체 구조

```
+-----------------------------+
| BITMAPFILEHEADER (14 bytes) |  <-- 'BM'(0x4D42)
+-----------------------------+
| BITMAPINFOHEADER (or V4/V5) |  <-- 최소 40 bytes (INFOHEADER)
+-----------------------------+
| Color Table (팔레트)        |  <-- 1/4/8bpp일 때만, RGBQUAD * n
+-----------------------------+
| Gap/Bitfields (옵션)        |  <-- 16/32bpp BI_BITFIELDS일 때 마스크
+-----------------------------+
| Pixel Array (DIB data)      |  <-- 행 패딩: 4바이트 배수
+-----------------------------+
```

핵심 상수(행 패딩):

$$
\text{stride(bytes)} = \left\lceil \frac{(\text{bitsPerPixel} \times \text{width})}{32} \right\rceil \times 4
$$

### 3.2.2 비트맵 파일 헤더 (`BITMAPFILEHEADER`)

- 크기 14바이트. **파일 시그니처** `'BM' (0x4D42)` 와 **픽셀 데이터 오프셋** 포함.

### 3.2.3 비트맵 정보 헤더 (`BITMAPINFOHEADER` / V4 / V5)

- **INFOHEADER(40B)** 필수 필드:
  - `biSize`(헤더 크기), `biWidth`, `biHeight`(음수=Top-Down), `biPlanes(=1)`,
  - `biBitCount`(1/4/8/16/24/32), `biCompression`(**BI_RGB**/`BI_RLE8/4`/`BI_BITFIELDS`/…),
  - `biSizeImage`(픽셀 영역 바이트; BI_RGB이면 0일 수 있음),
  - `biXPelsPerMeter`, `biYPelsPerMeter`, `biClrUsed`, `biClrImportant`.
- **V4/V5**는 색 공간/감마/마스크/ICC 프로파일 등 **확장 메타** 포함.

> 초심자 실습에서는 **BI_RGB(무압축)**, **8/24/32bpp** 위주로 다루는 것이 안전합니다.

### 3.2.4 색상 테이블(팔레트)

- **Indexed BMP(1/4/8bpp)** 에서만 존재. 항목 타입은 **`RGBQUAD`(B,G,R,Reserved)**.
- 팔레트 길이 결정:
  - `biClrUsed > 0` → 그 개수
  - 아니면 **2^bpp** (예: 8bpp → 256개)
- **그레이스케일 8bpp** 는 보통 0~255 선형 팔레트.

### 3.2.5 픽셀 데이터

- **행 패딩(4바이트 배수)** 필수.  
- **Bottom-Up** 기본: 파일에 저장된 **첫 행 = 이미지 맨 아래**.  
- 각 bpp별 해석:
  - **1/4bpp**: 비트/니블 packing. (실습 난이도 ↑)
  - **8bpp**: 1바이트 인덱스.
  - **24bpp**: **B,G,R** 순서로 3바이트/픽셀 + 패딩.
  - **32bpp**: **B,G,R,A**(또는 X). GDI는 알파를 무시하는 경우가 많음.
  - **16bpp**: 보통 `BI_BITFIELDS`(5-6-5) 또는 `BI_RGB`(5-5-5 변종). **마스크 확인 필수**.

---

## 3.3 | 실제 BMP 파일의 분석

### 3.3.1 그레이스케일 BMP(8bpp, BI_RGB)의 구조 보기

예) 8bpp 100×3 이미지(간단화):

```
Offset  Size  의미
0x0000   2    'BM'
0x0002   4    파일 전체 크기
0x0006   2    보존
0x0008   2    보존
0x000A   4    픽셀 데이터 오프셋 (예: 0x0436 = 14 + 40 + 256*4)
0x000E   4    biSize = 40
0x0012   4    biWidth = 100
0x0016   4    biHeight = 3    (양수=Bottom-Up)
0x001A   2    biPlanes = 1
0x001C   2    biBitCount = 8
0x001E   4    biCompression = BI_RGB(0)
0x0022   4    biSizeImage = 0 (BI_RGB에서 0 허용)
0x0026   4    biXPelsPerMeter
0x002A   4    biYPelsPerMeter
0x002E   4    biClrUsed (0→256)
0x0032   4    biClrImportant
0x0036 1024   팔레트 256개 (RGBQUAD * 256)
0x0436  n     픽셀(행패딩 4B)
```

- **픽셀 해석**: 각 바이트가 **팔레트 인덱스** → `RGBQUAD`로 색 변환.  
- **행 순서**: `y=0` (파일의 **마지막 행**)이 **이미지의 최상단**임을 주의.

### 3.3.2 트루컬러 BMP(24bpp, BI_RGB) 분석

- 팔레트 없음, 픽셀은 바로 **B,G,R**.  
- **stride**: `((24*width + 31)/32)*4`. 예: `width=3 → (72+31)/32=3 ⇒ 3*4=12` → (3픽셀=9B + 패딩3B)

**샘플 3픽셀(R,G,B)**:
```
픽셀0: B=0x00 G=0x00 R=0xFF  (빨강)
픽셀1: B=0x00 G=0xFF R=0x00  (초록)
픽셀2: B=0xFF G=0x00 R=0x00  (파랑)
패딩: 0x00 0x00 0x00
```

### 3.3.3 Top-Down DIB (음수 높이)

- 파일에는 **거의 등장하지 않지만**, **메모리 DIB** 또는 **V5 헤더 기반 BMP**에서 볼 수 있음.
- `biHeight = -abs(h)` 로 설정하면 픽셀 배열이 **위→아래** 순서.

---

## 3.4 | BMP 영상을 화면에 출력하기

### 3.4.1 DIB 출력 함수

- **`SetDIBitsToDevice`**: **스케일링 없이** 있는 그대로 그리기(복사). 가장 빠르고 단순.
- **`StretchDIBits`**: **스케일링**(확대/축소) 가능. 품질/필터링은 GDI 구현 의존.  
  - 고해상도 스케일 시 **품질이 제한**될 수 있음(후속 장에서 사용자 보간 구현 예정).

### 3.4.2 안전한 BMP 로더 구현 (BI_RGB / 8/24/32bpp, 16bpp 일부 지원)

> 학습용으로 **무압축(BI_RGB)** 중심. `BI_RLE8/4`, `BI_PNG/JPEG` 등은 **미대상**.  
> **팔레트(8bpp)**, **24bpp(BGR)**, **32bpp(BGRA/BGRX)**, **16bpp(565/555)**을 **내부 24/32bpp**로 통일해 화면 출력.

#### (1) Packed 구조 정의

```cpp
#pragma pack(push, 1)
struct BITMAPFILEHEADER_X {
    uint16_t bfType;      // 'BM' = 0x4D42
    uint32_t bfSize;
    uint16_t bfReserved1;
    uint16_t bfReserved2;
    uint32_t bfOffBits;   // 픽셀 데이터 시작 오프셋
};
#pragma pack(pop)

#pragma pack(push, 1)
struct BITMAPINFOHEADER_X {
    uint32_t biSize;          // >=40
    int32_t  biWidth;
    int32_t  biHeight;        // <0 : Top-Down
    uint16_t biPlanes;        // =1
    uint16_t biBitCount;      // 1/4/8/16/24/32
    uint32_t biCompression;   // BI_RGB(0)/BI_BITFIELDS(3)/...
    uint32_t biSizeImage;     // BI_RGB면 0 가능
    int32_t  biXPelsPerMeter;
    int32_t  biYPelsPerMeter;
    uint32_t biClrUsed;       // 팔레트 개수
    uint32_t biClrImportant;
};
#pragma pack(pop)

struct RGBQUAD_X { uint8_t b,g,r,a; };

static inline uint32_t stride_bytes(uint32_t width, uint16_t bpp) {
    return ((uint64_t)bpp * width + 31) / 32 * 4;
}
```

#### (2) 범용 로더(파일 → 내부 Top-Down BGRX32 버퍼)

```cpp
#include <vector>
#include <string>
#include <fstream>
#include <stdexcept>
#include <cstdint>
#include <limits>
#include <algorithm>

struct BmpImage {
    int width = 0, height = 0;   // +Top-Down 규약(내부)
    int stride = 0;              // bytes per row (4-byte aligned)
    std::vector<uint8_t> bgrx;   // BGRA(Alpha 무시), size=stride*height
};

static inline uint32_t read_le32(std::ifstream& f) {
    uint8_t b[4]; f.read((char*)b, 4); return (uint32_t)b[0] | ((uint32_t)b[1]<<8) | ((uint32_t)b[2]<<16) | ((uint32_t)b[3]<<24);
}
static inline uint16_t read_le16(std::ifstream& f) {
    uint8_t b[2]; f.read((char*)b, 2); return (uint16_t)b[0] | ((uint16_t)b[1]<<8);
}

BmpImage LoadBMP(const std::wstring& path) {
    std::ifstream fs(path, std::ios::binary);
    if (!fs) throw std::runtime_error("open failed");

    // FILEHEADER
    BITMAPFILEHEADER_X bf{};
    bf.bfType = read_le16(fs);
    bf.bfSize = read_le32(fs);
    bf.bfReserved1 = read_le16(fs);
    bf.bfReserved2 = read_le16(fs);
    bf.bfOffBits = read_le32(fs);

    if (bf.bfType != 0x4D42) throw std::runtime_error("not BM");

    // INFOHEADER (최소 40B 가정. 다른 크기면 버전 고려)
    BITMAPINFOHEADER_X bi{};
    bi.biSize = read_le32(fs);
    if (bi.biSize < 40) throw std::runtime_error("unsupported DIB header (<40)");
    bi.biWidth        = (int32_t)read_le32(fs);
    bi.biHeight       = (int32_t)read_le32(fs);
    bi.biPlanes       = read_le16(fs);
    bi.biBitCount     = read_le16(fs);
    bi.biCompression  = read_le32(fs);
    bi.biSizeImage    = read_le32(fs);
    bi.biXPelsPerMeter= (int32_t)read_le32(fs);
    bi.biYPelsPerMeter= (int32_t)read_le32(fs);
    bi.biClrUsed      = read_le32(fs);
    bi.biClrImportant = read_le32(fs);

    if (bi.biPlanes != 1) throw std::runtime_error("planes!=1");
    const bool topDown = (bi.biHeight < 0);
    const int  srcW = bi.biWidth;
    const int  srcH = std::abs(bi.biHeight);
    if (srcW <= 0 || srcH <= 0) throw std::runtime_error("invalid size");
    const uint16_t bpp = bi.biBitCount;

    // 팔레트 개수
    uint32_t clrUsed = bi.biClrUsed;
    if (bpp <= 8 && clrUsed == 0) clrUsed = 1u << bpp;

    // Compression
    const uint32_t BI_RGB       = 0;
    const uint32_t BI_RLE8      = 1;
    const uint32_t BI_RLE4      = 2;
    const uint32_t BI_BITFIELDS = 3;
    if (!(bi.biCompression == BI_RGB || bi.biCompression == BI_BITFIELDS))
        throw std::runtime_error("only BI_RGB/BI_BITFIELDS supported in this loader");

    // 추가 헤더/팔레트/마스크 읽기 위치로 이동
    const std::streamoff headerEnd = 14 + bi.biSize;
    fs.seekg(14, std::ios::beg);

    // INFOHEADER 전체 가져오기(이미 상단에서 일부 소비), 남은 부분 스킵
    std::vector<uint8_t> infoRemain(bi.biSize);
    fs.read((char*)infoRemain.data(), bi.biSize);

    // 팔레트
    std::vector<RGBQUAD_X> palette;
    if (bpp <= 8) {
        palette.resize(clrUsed);
        for (uint32_t i = 0; i < clrUsed; ++i) {
            RGBQUAD_X q{};
            fs.read((char*)&q, 4);
            palette[i] = q;
        }
    }

    // BITFIELDS (16/32bpp에서 마스크 존재 가능)
    uint32_t rMask=0, gMask=0, bMask=0, aMask=0;
    if (bi.biCompression == BI_BITFIELDS) {
        rMask = read_le32(fs);
        gMask = read_le32(fs);
        bMask = read_le32(fs);
        // V4/V5면 알파마스크도 있을 수 있음(파일 길이/헤더 확인해 조건부 처리)
        // 여기서는 방어적으로 존재하면 읽고, 아니면 0으로 둠
        std::streampos pos = fs.tellg();
        fs.seekg(0, std::ios::end);
        std::streampos end = fs.tellg();
        fs.seekg(pos, std::ios::beg);
        if (end - pos >= (std::streamoff)4) aMask = read_le32(fs);
    }

    // 픽셀로 이동
    fs.seekg(bf.bfOffBits, std::ios::beg);

    // 출력(BGRX 32bpp Top-Down) 준비
    BmpImage out;
    out.width  = srcW;
    out.height = srcH;
    out.stride = ((srcW * 4 + 3) / 4) * 4;
    out.bgrx.assign((size_t)out.stride * out.height, 0);

    // 소스 stride
    const uint32_t srcStride = stride_bytes(srcW, bpp);

    auto put_px = [&](int x, int y, uint8_t B, uint8_t G, uint8_t R, uint8_t A=255) {
        uint8_t* row = out.bgrx.data() + (size_t)y * out.stride;
        uint8_t* p   = row + x*4;
        p[0]=B; p[1]=G; p[2]=R; p[3]=A;
    };

    // 행 읽기용 버퍼
    std::vector<uint8_t> row(srcStride);

    auto toTopDownY = [&](int fileRowIndex)->int {
        // fileRowIndex: 파일에서 위→아래로 읽는 순서(0..srcH-1)
        // BMP 기본은 Bottom-Up이므로:
        if (!topDown) return (srcH - 1 - fileRowIndex);
        return fileRowIndex;
    };

    // 픽셀 변환
    if (bpp == 8) {
        for (int fy=0; fy<srcH; ++fy) {
            fs.read((char*)row.data(), srcStride);
            int ty = toTopDownY(fy);
            for (int x=0; x<srcW; ++x) {
                uint8_t idx = row[x];
                if (idx >= palette.size()) idx = 0;
                auto q = palette[idx];
                put_px(x, ty, q.b, q.g, q.r, 255);
            }
        }
    }
    else if (bpp == 24) {
        for (int fy=0; fy<srcH; ++fy) {
            fs.read((char*)row.data(), srcStride);
            int ty = toTopDownY(fy);
            for (int x=0; x<srcW; ++x) {
                const uint8_t* p = &row[x*3];
                put_px(x, ty, p[0], p[1], p[2], 255);
            }
        }
    }
    else if (bpp == 32) {
        // BGRA (GDI 관점에서 알파는 무시될 수 있음)
        for (int fy=0; fy<srcH; ++fy) {
            fs.read((char*)row.data(), srcStride);
            int ty = toTopDownY(fy);
            for (int x=0; x<srcW; ++x) {
                const uint8_t* p = &row[x*4];
                put_px(x, ty, p[0], p[1], p[2], p[3]);
            }
        }
    }
    else if (bpp == 16) {
        // 565/555 처리(BI_BITFIELDS 권장)
        uint32_t Rm=0xF800, Gm=0x07E0, Bm=0x001F; // 기본 565 가정
        uint8_t Rs=11, Gs=5, Bs=0;
        if (bi.biCompression == BI_BITFIELDS) {
            Rm = rMask? rMask:Rm; Gm = gMask? gMask:Gm; Bm = bMask? bMask:Bm;
            // 시프트 계산
            auto lsb_index = [](uint32_t m){ for (uint8_t i=0;i<32;++i) if (m&(1u<<i)) return i; return (uint8_t)0; };
            auto width_bits= [](uint32_t m){ uint8_t w=0; while(m){ w+=(m&1u); m>>=1; } return w; };
            Bs = lsb_index(Bm); Gs = lsb_index(Gm); Rs = lsb_index(Rm);
            uint8_t Bw = width_bits(Bm), Gw = width_bits(Gm), Rw = width_bits(Rm);
            // scale helper
            auto scale = [](uint32_t v, uint8_t w){ return (uint8_t)std::lround((double)v * 255.0 / (double)((1u<<w)-1)); };
            for (int fy=0; fy<srcH; ++fy) {
                fs.read((char*)row.data(), srcStride);
                int ty = toTopDownY(fy);
                const uint16_t* p16 = reinterpret_cast<uint16_t*>(row.data());
                for (int x=0; x<srcW; ++x) {
                    uint16_t v = p16[x];
                    uint8_t B = scale((v & Bm) >> Bs, Bw);
                    uint8_t G = scale((v & Gm) >> Gs, Gw);
                    uint8_t R = scale((v & Rm) >> Rs, Rw);
                    put_px(x, ty, B,G,R,255);
                }
            }
            return out;
        }
        // BI_RGB 16bpp는 555일 수 있음(간단 가정: 565)
        for (int fy=0; fy<srcH; ++fy) {
            fs.read((char*)row.data(), srcStride);
            int ty = toTopDownY(fy);
            const uint16_t* p16 = reinterpret_cast<uint16_t*>(row.data());
            for (int x=0; x<srcW; ++x) {
                uint16_t v = p16[x];
                uint8_t B = (uint8_t)std::lround(((v & 0x001F)      ) * 255.0 / 31.0);
                uint8_t G = (uint8_t)std::lround(((v & 0x07E0) >> 5 ) * 255.0 / 63.0);
                uint8_t R = (uint8_t)std::lround(((v & 0xF800) >> 11) * 255.0 / 31.0);
                put_px(x, ty, B,G,R,255);
            }
        }
    }
    else {
        throw std::runtime_error("unsupported bpp for this loader");
    }

    return out;
}
```

> **포인트**
> - **오류 처리**: 시그니처, 크기, bpp, 압축 모드, 팔레트 범위.
> - **행패딩**과 **Bottom-Up → Top-Down** 변환.
> - **16bpp**: `BI_BITFIELDS`일 때 **마스크 기반 추출/스케일**.

#### (3) `SetDIBitsToDevice` / `StretchDIBits` 로 그리기

- **BGRX32 Top-Down** 버퍼를 만든 뒤, **`BITMAPINFO`** 를 구성하여 DC에 출력.

```cpp
#include <windows.h>

void DrawBGRX32(HDC hdc, const uint8_t* topDownBGRX, int w, int h, const RECT& dst, bool scale)
{
    BITMAPINFO bmi{};
    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       = w;
    bmi.bmiHeader.biHeight      = -h;      // Top-Down
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;      // B,G,R,X
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage   = (DWORD)(w * 4 * h);

    if (!scale) {
        // 1:1 출력 (좌표는 dst.left/top 사용)
        ::SetDIBitsToDevice(
            hdc,
            dst.left, dst.top,
            w, h,
            0, 0, 0, h,
            topDownBGRX,
            &bmi,
            DIB_RGB_COLORS
        );
    } else {
        // 스케일링 출력
        ::StretchDIBits(
            hdc,
            dst.left, dst.top, dst.right - dst.left, dst.bottom - dst.top, // dst
            0, 0, w, h,                                                    // src
            topDownBGRX,
            &bmi,
            DIB_RGB_COLORS,
            SRCCOPY
        );
    }
}
```

---

## 실습: **BmpShow** — BMP 열고, 화면에 스케일링 출력

> **Win32 API** 단일 소스 예제. **파일 드래그&드롭**, **Ctrl+O(열기)** 지원.  
> (MFC 버전은 2장 예제 골격에서 `OnFileOpen` → `LoadBMP` → `OnDraw` 로 거의 동일.)

```cpp
#include <windows.h>
#include <commdlg.h>
#include <shellapi.h>
#include <string>
#include <vector>
#include <stdexcept>

// 위에서 정의한 BmpImage, LoadBMP, DrawBGRX32 포함했다고 가정
// (동일 파일에 두거나, 헤더로 분리)

static HINSTANCE g_hInst;
static HWND      g_hWnd;
static BmpImage  g_img;
static bool      g_hasImage = false;
static std::wstring g_path;

static void ShowErrorBox(const wchar_t* msg) { MessageBoxW(g_hWnd, msg, L"Error", MB_ICONERROR); }

static bool OpenFileDialog(std::wstring& outPath) {
    wchar_t buf[MAX_PATH] = L"";
    OPENFILENAMEW ofn { sizeof(ofn) };
    ofn.hwndOwner   = g_hWnd;
    ofn.lpstrFilter = L"BMP Files (*.bmp)\0*.bmp\0All Files (*.*)\0*.*\0";
    ofn.lpstrFile   = buf;
    ofn.nMaxFile    = MAX_PATH;
    ofn.Flags       = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    ofn.lpstrTitle  = L"Open BMP";
    if (GetOpenFileNameW(&ofn)) { outPath = buf; return true; }
    return false;
}

static void LoadAndShow(const std::wstring& path) {
    try {
        g_img = LoadBMP(path);
        g_hasImage = true;
        g_path = path;
        InvalidateRect(g_hWnd, nullptr, FALSE);
    } catch (const std::exception& e) {
        g_hasImage = false;
        std::wstring m = L"Load failed: ";
        m += std::wstring(e.what(), e.what()+strlen(e.what()));
        ShowErrorBox(m.c_str());
    }
}

static void OnPaint(HWND hwnd) {
    PAINTSTRUCT ps; HDC hdc = BeginPaint(hwnd, &ps);
    RECT rc; GetClientRect(hwnd, &rc);
    if (g_hasImage) {
        // Letterbox: 비율 유지하며 중앙 배치
        double sx = (double)(rc.right - rc.left) / g_img.width;
        double sy = (double)(rc.bottom - rc.top) / g_img.height;
        double s  = min(sx, sy);
        int dw = (int)(g_img.width  * s);
        int dh = (int)(g_img.height * s);
        RECT dst {
            rc.left + (rc.right-rc.left - dw)/2,
            rc.top  + (rc.bottom-rc.top - dh)/2,
            rc.left + (rc.right-rc.left - dw)/2 + dw,
            rc.top  + (rc.bottom-rc.top - dh)/2 + dh
        };
        DrawBGRX32(hdc, g_img.bgrx.data(), g_img.width, g_img.height, dst, true);
    } else {
        const wchar_t* t = L"Ctrl+O 로 BMP 열기 / 드래그&드롭 지원";
        TextOutW(hdc, 10, 10, t, lstrlenW(t));
    }
    EndPaint(hwnd, &ps);
}

static void OnDropFiles(HDROP hDrop) {
    wchar_t path[MAX_PATH]; DragQueryFileW(hDrop, 0, path, MAX_PATH);
    DragFinish(hDrop);
    LoadAndShow(path);
}

static LRESULT CALLBACK WndProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    switch (m) {
    case WM_CREATE:
        DragAcceptFiles(h, TRUE);
        return 0;
    case WM_PAINT:
        OnPaint(h); return 0;
    case WM_DROPFILES:
        OnDropFiles((HDROP)w); return 0;
    case WM_KEYDOWN:
        if ((GetKeyState(VK_CONTROL) & 0x8000) && w == 'O') {
            std::wstring p; if (OpenFileDialog(p)) LoadAndShow(p);
        }
        return 0;
    case WM_DESTROY:
        PostQuitMessage(0); return 0;
    default: return DefWindowProcW(h, m, w, l);
    }
}

int APIENTRY wWinMain(HINSTANCE hInst, HINSTANCE, LPWSTR, int nCmdShow) {
    g_hInst = hInst;
    const wchar_t CLASS_NAME[] = L"BmpShowWindow";
    WNDCLASSEXW wc { sizeof(wc) };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInst;
    wc.hCursor   = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszClassName = CLASS_NAME;
    if (!RegisterClassExW(&wc)) return 0;

    g_hWnd = CreateWindowExW(0, CLASS_NAME, L"BmpShow — BMP Viewer (SetDIBits/StretchDIBits)",
                             WS_OVERLAPPEDWINDOW|WS_VISIBLE,
                             CW_USEDEFAULT, CW_USEDEFAULT, 1024, 768,
                             nullptr, nullptr, hInst, nullptr);
    if (!g_hWnd) return 0;

    ShowWindow(g_hWnd, nCmdShow);
    UpdateWindow(g_hWnd);

    MSG msg{};
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    return (int)msg.wParam;
}
```

> **테스트**  
> - `Ctrl+O`로 **8bpp 팔레트**, **24bpp**, **32bpp** BMP를 열어보세요.  
> - 큰 이미지도 **StretchDIBits**로 적절히 축소되어 중앙에 렌더링됩니다.

---

# 참고 · 심화

## A) `CreateDIBSection` + `BitBlt` 경로

- 빈 DIBSECTION을 만들고, 그 메모리에 디코드 결과를 써 넣은 뒤 **`BitBlt`** 로 복사하는 방식.
- 빈번한 리프레시/스크롤이 많은 뷰어에서는 DIBSECTION이 유리할 때가 있음. (핸들 수명/선택/해제 규칙 주의)

```cpp
HBITMAP CreateDIBSectionFromBGRX32(HDC hdc, int w, int h, void** outBits) {
    BITMAPINFO bmi{}; bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth=w; bmi.bmiHeader.biHeight=-h;
    bmi.bmiHeader.biPlanes=1; bmi.bmiHeader.biBitCount=32; bmi.bmiHeader.biCompression=BI_RGB;
    void* bits=nullptr;
    HBITMAP hbm = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &bits, nullptr, 0);
    if (outBits) *outBits = bits;
    return hbm;
}
```

## B) 알파와 GDI

- 전통 **GDI**는 **알파 블렌딩**을 자동으로 처리하지 않음(32bpp `A` 채널 **무시**).  
- 알파 합성은 **GDI+**, **AlphaBlend**(msimg32), **Direct2D** 등 활용.

## C) 흔한 함정 체크리스트

- [ ] **행 패딩**(4바이트 정렬) 누락  
- [ ] **Bottom-Up**을 Top-Down으로 렌더링 (뒤집힘)  
- [ ] `biPlanes != 1`  
- [ ] 16bpp **마스크**를 무시하고 565/555 가정  
- [ ] `biClrUsed`=0일 때 팔레트 크기를 **2^bpp**로 잡지 않음  
- [ ] 파일 `bfOffBits` 신뢰 → 실제 위치/길이 검증 누락  
- [ ] **RLE**/압축 BMP를 BI_RGB로 착각  
- [ ] 24bpp stride를 `w*3`로만 계산(패딩 미반영)

---

# 수학 메모: **Stride & 용량 계산**

- **Stride(바이트)**:
  $$
  S = \left\lceil \frac{bpp \cdot W}{32} \right\rceil \cdot 4
  $$
- **Pixel Array 크기**(대략):
  $$
  \text{SizeImage} \approx S \cdot H
  $$
  (BI_RGB에서 `biSizeImage=0` 가능 → **자체 계산** 권장)

---

# 마무리 요약

- **BMP**는 가장 단순한 **DIB 직렬화** 포맷: **헤더 → 팔레트 → 픽셀**.
- 핵심은 **bpp/압축/팔레트/행패딩**과 **Bottom-Up** 개념.  
- **SetDIBitsToDevice**/**StretchDIBits**로 **빠른 화면 출력** 가능.  
- 실전에서는 내부 표현을 **Top-Down BGRX32**로 **정규화**하면 렌더링이 단순/안정.