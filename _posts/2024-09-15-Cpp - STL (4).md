---
layout: post
title: C++ - STL (4)
date: 2024-09-15 19:20:23 +0900
category: Cpp
---
# STL 4 — 이터레이터와 알고리즘: STL의 핵심 삼각형

## 큰 그림: 컨테이너, 이터레이터, 알고리즘의 조화

STL(Standard Template Library)의 가장 큰 강점은 **컨테이너**, **이터레이터**, **알고리즘**이라는 세 요소가 느슨하게 결합되어 있다는 점입니다. 각 요소는 자신의 역할에만 집중하면서도 다른 요소와 완벽하게 협력합니다.

- **컨테이너**는 데이터를 저장하는 방법에 집중합니다.
- **이터레이터**는 컨테이너의 요소에 접근하는 방법을 추상화합니다.
- **알고리즘**은 이터레이터를 통해 데이터에 접근하고 연산을 수행합니다.

이러한 설계 덕분에 `std::sort` 같은 알고리즘은 `vector`, `deque`, `array` 등 서로 다른 컨테이너에서도 동일하게 작동할 수 있습니다. 알고리즘이 필요한 것은 컨테이너 자체가 아니라, 해당 컨테이너가 제공하는 적절한 카테고리의 이터레이터뿐입니다.

---

## 이터레이터: 컨테이너와 알고리즘을 연결하는 다리

### 이터레이터의 기본 사용법

이터레이터는 포인터와 유사하게 동작하며, 컨테이너의 요소를 가리키고 순회하는 데 사용됩니다.

```cpp
#include <vector>
#include <iostream>
#include <list>

int main() {
    // vector 예제
    std::vector<int> numbers = {10, 20, 30, 40, 50};
    
    // 전통적인 이터레이터 사용
    for (std::vector<int>::iterator it = numbers.begin(); 
         it != numbers.end(); 
         ++it) {
        std::cout << *it << " ";  // 10 20 30 40 50
    }
    std::cout << "\n";
    
    // auto를 사용한 간결한 표현
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        *it += 5;  // 각 요소에 5 더하기
    }
    
    // const_iterator: 읽기 전용 접근
    for (std::vector<int>::const_iterator cit = numbers.cbegin();
         cit != numbers.cend();
         ++cit) {
        // *cit = 10;  // 오류: const_iterator는 수정 불가
        std::cout << *cit << " ";
    }
    std::cout << "\n";
    
    // reverse_iterator: 역방향 순회
    for (auto rit = numbers.rbegin(); rit != numbers.rend(); ++rit) {
        std::cout << *rit << " ";  // 55 45 35 25 15
    }
    std::cout << "\n";
}
```

### 이터레이터 카테고리: 알고리즘 선택의 기준

각 이터레이터는 특정 기능을 제공하며, 이 기능에 따라 다음과 같이 분류됩니다:

1. **입력(Iterator)**: 데이터를 읽을 수만 있습니다(`istream_iterator`).
2. **출력(Output Iterator)**: 데이터를 쓸 수만 있습니다(`ostream_iterator`).
3. **전방(Forward Iterator)**: 한 방향으로만 이동 가능하며 여러 번 순회할 수 있습니다(`forward_list`, 해시 컨테이너).
4. **양방향(Bidirectional Iterator)**: 앞뒤로 이동 가능합니다(`list`, `set`, `map`).
5. **임의 접근(Random Access Iterator)**: 임의의 위치로 즉시 이동 가능합니다(`vector`, `deque`, `array`).

**알고리즘은 특정 카테고리의 이터레이터를 요구합니다.** 예를 들어:
- `std::sort`는 **임의 접근 이터레이터**가 필요합니다(`list`에서는 사용 불가).
- `std::reverse`는 **양방향 이터레이터**면 충분합니다.
- `std::find`는 **입력 이터레이터**만 있으면 작동합니다.

### 이터레이터 어댑터: 유용한 도구들

이터레이터 어댑터는 기존 이터레이터를 변환하거나 특수한 동작을 추가합니다:

```cpp
#include <vector>
#include <iostream>
#include <iterator>
#include <algorithm>

int main() {
    std::vector<int> source = {1, 2, 3, 4, 5};
    std::vector<int> destination;
    
    // back_inserter: push_back을 자동으로 호출
    std::copy(source.begin(), source.end(), 
              std::back_inserter(destination));
    
    // ostream_iterator: 출력 스트림으로 직접 출력
    std::copy(destination.begin(), destination.end(),
              std::ostream_iterator<int>(std::cout, ", "));
    
    // inserter: 특정 위치에 삽입
    std::list<int> myList = {10, 20, 30};
    auto it = std::next(myList.begin());  // 두 번째 위치
    std::copy(source.begin(), source.begin() + 3,
              std::inserter(myList, it));
    // 결과: 10, 1, 2, 3, 20, 30
}
```

### 반복자 무효화: 주의해야 할 함정

이터레이터가 가리키는 요소가 컨테이너에서 제거되거나 컨테이너의 구조가 변경되면, 이터레이터는 **무효화**될 수 있습니다. 무효화된 이터레이터를 사용하면 미정의 동작이 발생합니다.

```cpp
std::vector<int> v = {1, 2, 3, 4, 5};
auto it = v.begin() + 2;  // 3을 가리킴

v.push_back(6);  // 용량이 충분하다면 it은 유효함
v.push_back(7); v.push_back(8); v.push_back(9);  // 재할당 발생 가능

// 재할당이 발생했다면 it은 무효화됨!
// *it 접근은 위험!

// 안전한 접근법: 필요한 위치를 다시 계산
it = v.begin() + 2;  // 다시 유효한 이터레이터 얻기
```

**무효화 규칙 요약**:
- `vector`, `string`: 재할당 시 **모든** 이터레이터 무효화
- `deque`: 양끝 삽입/삭제 시 **일부** 이터레이터 무효화
- `list`, `set`, `map`, `unordered_*`: 삭제된 요소의 이터레이터만 무효화
- 모든 컨테이너: 요소 삭제 시 **삭제된 위치와 이후**의 이터레이터 무효화

---

## 알고리즘: 데이터 처리의 표준 도구 상자

STL 알고리즘은 `<algorithm>`과 `<numeric>` 헤더에 정의되어 있으며, 일반적인 데이터 처리 작업을 효율적으로 수행합니다.

### 검색과 탐색 알고리즘

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> data = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    // find: 특정 값 찾기
    auto it = std::find(data.begin(), data.end(), 7);
    if (it != data.end()) {
        std::cout << "7을 찾았습니다. 위치: " 
                  << std::distance(data.begin(), it) << "\n";
    }
    
    // find_if: 조건을 만족하는 첫 번째 요소 찾기
    auto even_it = std::find_if(data.begin(), data.end(),
                                [](int n) { return n % 2 == 0; });
    
    // count_if: 조건을 만족하는 요소 개수 세기
    int even_count = std::count_if(data.begin(), data.end(),
                                   [](int n) { return n % 2 == 0; });
    std::cout << "짝수의 개수: " << even_count << "\n";
    
    // min_element, max_element: 최소/최대 요소 찾기
    auto min_it = std::min_element(data.begin(), data.end());
    auto max_it = std::max_element(data.begin(), data.end());
    std::cout << "최소값: " << *min_it << ", 최대값: " << *max_it << "\n";
}
```

### 변환과 수정 알고리즘

```cpp
#include <algorithm>
#include <vector>
#include <string>
#include <cctype>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // transform: 각 요소에 함수 적용
    std::vector<int> squared;
    squared.resize(numbers.size());
    std::transform(numbers.begin(), numbers.end(), squared.begin(),
                   [](int n) { return n * n; });
    // 결과: 1, 4, 9, 16, 25
    
    // replace: 특정 값 변경
    std::vector<int> data = {1, 2, 3, 2, 4, 2, 5};
    std::replace(data.begin(), data.end(), 2, 99);
    // 결과: 1, 99, 3, 99, 4, 99, 5
    
    // fill: 범위를 특정 값으로 채우기
    std::vector<int> empty(10);
    std::fill(empty.begin(), empty.end(), -1);
    
    // generate: 생성기 함수로 채우기
    int counter = 0;
    std::generate(empty.begin(), empty.end(),
                  [&counter]() { return counter++; });
}
```

### 정렬 관련 알고리즘

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    // sort: 일반 정렬 (불안정 정렬)
    std::sort(numbers.begin(), numbers.end());
    
    // stable_sort: 안정 정렬 (동일한 값의 상대적 순서 유지)
    std::vector<std::pair<int, char>> items = {
        {3, 'A'}, {1, 'B'}, {2, 'C'}, {1, 'D'}, {3, 'E'}
    };
    std::stable_sort(items.begin(), items.end(),
                     [](auto& a, auto& b) { return a.first < b.first; });
    // 결과: (1,B), (1,D), (2,C), (3,A), (3,E) - 동일 키 내 순서 유지
    
    // partial_sort: 부분 정렬 (상위 N개만 정렬)
    std::vector<int> data = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    std::partial_sort(data.begin(), data.begin() + 3, data.end());
    // 상위 3개: 1, 2, 3 (정렬됨), 나머지: 순서 보장 안됨
    
    // nth_element: n번째 요소 찾기 (왼쪽은 더 작음, 오른쪽은 더 큼)
    std::vector<int> values = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    auto middle = values.begin() + values.size() / 2;
    std::nth_element(values.begin(), middle, values.end());
    std::cout << "중간값: " << *middle << "\n";
}
```

### 삭제 패턴: remove-erase 관용구

STL 알고리즘 중 `remove`와 `unique`는 실제로 요소를 삭제하지 않고, 유지할 요소들을 앞쪽으로 모읍니다. 실제 삭제를 위해서는 `erase`와 함께 사용해야 합니다.

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    // remove-erase 관용구
    std::vector<int> numbers = {1, 2, 3, 2, 4, 2, 5};
    
    // 2를 제거하려면
    numbers.erase(std::remove(numbers.begin(), numbers.end(), 2),
                  numbers.end());
    // 결과: 1, 3, 4, 5
    
    // unique-erase 관용구 (중복 제거)
    std::vector<int> sorted = {1, 1, 2, 2, 2, 3, 4, 4, 5};
    sorted.erase(std::unique(sorted.begin(), sorted.end()),
                 sorted.end());
    // 결과: 1, 2, 3, 4, 5
    
    // 조건부 삭제
    std::vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    data.erase(std::remove_if(data.begin(), data.end(),
                              [](int n) { return n % 2 == 0; }),
               data.end());
    // 결과: 1, 3, 5, 7, 9 (짝수 제거)
}
```

### 수치 알고리즘

```cpp
#include <numeric>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // accumulate: 합계 계산
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);
    std::cout << "합계: " << sum << "\n";
    
    // 곱셈도 가능
    int product = std::accumulate(numbers.begin(), numbers.end(), 1,
                                  std::multiplies<int>());
    std::cout << "곱: " << product << "\n";
    
    // inner_product: 내적 계산
    std::vector<int> a = {1, 2, 3};
    std::vector<int> b = {4, 5, 6};
    int dot_product = std::inner_product(a.begin(), a.end(),
                                         b.begin(), 0);
    std::cout << "내적: " << dot_product << "\n";
    
    // partial_sum: 부분합 계산
    std::vector<int> prefix_sum;
    std::partial_sum(numbers.begin(), numbers.end(),
                     std::back_inserter(prefix_sum));
    // 결과: 1, 3, 6, 10, 15
    
    // adjacent_difference: 인접 차이 계산
    std::vector<int> differences;
    std::adjacent_difference(numbers.begin(), numbers.end(),
                             std::back_inserter(differences));
    // 결과: 1, 1, 1, 1, 1 (첫 번째 요소는 그대로)
}
```

### 집합 알고리즘 (정렬된 범위 필요)

```cpp
#include <algorithm>
#include <vector>
#include <iostream>
#include <iterator>

int main() {
    std::vector<int> A = {1, 2, 3, 5, 7};
    std::vector<int> B = {2, 3, 4, 6, 8};
    std::vector<int> result;
    
    // set_union: 합집합
    std::set_union(A.begin(), A.end(),
                   B.begin(), B.end(),
                   std::back_inserter(result));
    // 결과: 1, 2, 3, 4, 5, 6, 7, 8
    
    result.clear();
    
    // set_intersection: 교집합
    std::set_intersection(A.begin(), A.end(),
                          B.begin(), B.end(),
                          std::back_inserter(result));
    // 결과: 2, 3
    
    result.clear();
    
    // set_difference: 차집합 (A - B)
    std::set_difference(A.begin(), A.end(),
                        B.begin(), B.end(),
                        std::back_inserter(result));
    // 결과: 1, 5, 7
    
    result.clear();
    
    // includes: 부분집합 확인
    std::vector<int> sub = {2, 3};
    bool is_subset = std::includes(A.begin(), A.end(),
                                   sub.begin(), sub.end());
    std::cout << "부분집합인가? " << (is_subset ? "예" : "아니오") << "\n";
}
```

## C++20 Ranges: 현대적인 접근 방식

C++20에서 도입된 Ranges 라이브러리는 이터레이터와 알고리즘을 더욱 표현력 있게 사용할 수 있게 해줍니다.

```cpp
#include <iostream>
#include <vector>
#include <ranges>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 파이프(|) 연산자를 이용한 함수형 스타일
    auto result = numbers 
        | std::views::filter([](int n) { return n % 2 == 0; })  // 짝수만
        | std::views::transform([](int n) { return n * n; })    // 제곱
        | std::views::take(3);                                  // 처음 3개
    
    for (int n : result) {
        std::cout << n << " ";  // 4 16 36
    }
    std::cout << "\n";
    
    // ranges 알고리즘 (반복자 쌍 대신 범위 직접 전달)
    std::vector<int> data = {5, 3, 8, 1, 9};
    std::ranges::sort(data);  // 간결한 표현
    
    // 프로젝션(projection) 기능
    struct Person {
        std::string name;
        int age;
    };
    
    std::vector<Person> people = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35}
    };
    
    // 나이로 정렬 (이름은 무시)
    std::ranges::sort(people, {}, &Person::age);
    // 또는
    std::ranges::sort(people, std::less<>{}, &Person::age);
}
```

## 성능 고려사항

1. **알고리즘 복잡도**: 대부분의 STL 알고리즘은 최적의 시간 복잡도를 제공합니다.
   - `std::sort`: O(n log n)
   - `std::find`: O(n)
   - `std::binary_search`: O(log n) (정렬된 범위에서)

2. **이터레이터 카테고리와 성능**:
   - 임의 접근 이터레이터를 사용하는 알고리즘이 일반적으로 가장 빠릅니다.
   - `list`는 이론적으로 중간 삽입이 O(1)이지만, 캐시 지역성이 떨어져 실제로는 `vector`보다 느릴 수 있습니다.

3. **메모리 할당 최소화**:
   ```cpp
   // 비효율적: 여러 번의 재할당
   std::vector<int> result;
   for (int i = 0; i < 1000; ++i) {
       result.push_back(process(i));
   }
   
   // 효율적: 한 번에 할당
   std::vector<int> result;
   result.reserve(1000);  // 메모리 사전 할당
   for (int i = 0; i < 1000; ++i) {
       result.push_back(process(i));
   }
   ```

## 결론: 실전에서의 효과적인 사용법

STL의 이터레이터와 알고리즘을 효과적으로 사용하기 위한 핵심 원칙은 다음과 같습니다:

1. **적절한 도구 선택**: 각 작업에 맞는 알고리즘을 선택하세요. 직접 반복문을 작성하기 전에 STL에 이미 있는 알고리즘을 확인하세요.

2. **성능 이해**: 알고리즘의 시간 복잡도와 이터레이터 카테고리를 이해하면 예상치 못한 성능 문제를 피할 수 있습니다.

3. **안전성 우선**: 이터레이터 무효화를 항상 염두에 두고, 범위를 벗어난 접근을 주의하세요.

4. **현대적인 스타일 채택**: C++20 이상을 사용한다면 Ranges 라이브러리를 활용하여 더 읽기 쉽고 안전한 코드를 작성하세요.

5. **측정과 검증**: 성능이 중요한 코드에서는 가정하지 말고 실제로 측정하세요. 이론적 복잡도와 실제 성능은 다를 수 있습니다.

이터레이터와 알고리즘은 STL의 핵심이며, 이를 잘 이해하고 활용하면 더욱 효율적이고 안전한 C++ 코드를 작성할 수 있습니다. 복잡한 데이터 처리 작업도 표준화된 도구를 사용하면 간결하고 명확하게 표현할 수 있으며, 이러한 추상화는 코드의 유지보수성과 재사용성을 크게 향상시킵니다.