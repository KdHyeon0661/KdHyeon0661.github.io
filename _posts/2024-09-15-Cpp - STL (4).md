---
layout: post
title: C++ - STL (4)
date: 2024-09-15 19:20:23 +0900
category: Cpp
---
# STL 4 — 이터레이터와 알고리즘

## 0) 큰 그림: “컨테이너 × 이터레이터 × 알고리즘”

STL은 **컨테이너**가 “데이터를 저장”하고, **이터레이터**가 “데이터 위치를 가리키며 이동”하고, **알고리즘**이 “범용 연산”을 수행하는 **결합지점**이다.  
알고리즘은 **컨테이너를 모르고** 이터레이터만 요구한다.  
요구 이터레이터 **카테고리**가 곧 사용 가능한 알고리즘의 **상한**임.

---

## 1) 이터레이터 (Iterator)

### 1.1 기본 사용

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};

    // 전통적 for
    for (vector<int>::iterator it = v.begin(); it != v.end(); ++it)
        cout << *it << ' '; // 1 2 3
    cout << '\n';

    // auto 사용
    for (auto it = v.begin(); it != v.end(); ++it)
        cout << *it << ' ';
    cout << '\n';

    // 범위 기반 for (C++11) — 내부적으로 begin/end 이터레이터 필요
    for (int x : v) cout << x << ' ';
    cout << '\n';
}
```

### 1.2 이터레이터 **카테고리**와 요구사항

| 카테고리 | 예 | 이동 | 임의 접근 | 다중 패스 | 대표 알고리즘 예 |
|---|---|---|---|---|---|
| Input | `istream_iterator` | `++`, `*` 읽기 | × | 보장 약함(읽기 1패스) | `find`, `accumulate` |
| Output | `ostream_iterator` | `++`, `*` 쓰기 | × | 쓰기 전용 | `copy`, `fill` |
| Forward | `forward_list`, 해시 컨테이너 | 전진 | × | **O** | `remove`, `unique`, `partition` |
| Bidirectional | `list`, `set/map` | 전/후진 | × | **O** | `reverse`, `stable_partition` |
| Random Access | `vector`, `deque` | 전/후진, 산술, `[]` | **O** | **O** | `sort`, `nth_element`, `partial_sort` |
| Contiguous (C++20) | `vector`, `string` | Random + 연속 메모리 | **O** | **O** | `std::span`과 상호운용 최적화 |

> 많은 **정렬/힙** 계열은 **Random Access** 이상을 요구한다.

### 1.3 `const_iterator` / `reverse_iterator` / `cbegin` 계열

```cpp
vector<int> v = {1,2,3};
for (vector<int>::const_iterator it = v.cbegin(); it != v.cend(); ++it) {
    // *it = 10; // ⛔ const_iterator는 쓰기 금지
}
for (auto rit = v.rbegin(); rit != v.rend(); ++rit) { /* 역순 순회 */ }
```

### 1.4 이터레이터 **어댑터**

- **삽입기**: `back_inserter`, `front_inserter`, `inserter`
- **스트림**: `istream_iterator`, `ostream_iterator`
- **Move**: `make_move_iterator`
- **수정 금지**: `std::as_const` + `cbegin/cend`

```cpp
#include <algorithm>
#include <iterator>
#include <vector>
#include <list>
using namespace std;

int main(){
    vector<int> src = {1,2,3};
    list<int>   dst;
    copy(src.begin(), src.end(), back_inserter(dst)); // push_back 반복
}
```

### 1.5 반복자 **무효화 규칙**(매우 중요)

| 컨테이너 | 삽입 | 삭제 | 재배치/rehash |
|---|---|---|---|
| `vector` | capacity 증가 동반 시 **모두 무효** | 지점 이후 **무효** | `shrink_to_fit` 등에서 모두 무효 가능 |
| `deque` | 일부 연산에서 섹션 무효 | 위치 주변 무효 | 구현 의존, 안전하지 않음 |
| `list` | **안전**(삭제 원소만 무효) | 삭제 원소만 무효 | 없음 |
| `map/set` | **안전**(삭제 원소만 무효) | 삭제 원소만 무효 | 없음 |
| `unordered_*` | **rehash 시 모두 무효** | 삭제 원소만 무효 | `reserve/rehash` → **모두 무효** |

---

## 2) 알고리즘 (헤더 `<algorithm>`, 수치 `<numeric>`)

알고리즘은 **구조적 분류**로 기억하면 실전에서 빠르다.

### 2.1 **비수정** 시퀀스(읽기)

- `all_of/any_of/none_of`
- `for_each` (부수효과)
- `find/find_if/find_if_not`
- `count/count_if`
- `mismatch`, `equal`, `lexicographical_compare`
- `min_element/max_element/minmax_element`

```cpp
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;

int main(){
    vector<int> v{3,1,4,1,5};
    bool all_pos = all_of(v.begin(), v.end(), [](int x){ return x>0; });
    auto it = find_if(v.begin(), v.end(), [](int x){ return x%2==0; }); // 짝수 첫 원소
    cout << all_pos << " " << (it!=v.end()?*it:-1) << "\n";
}
```

### 2.2 **수정** 시퀀스

- `copy/copy_if/copy_n`, `move`
- `transform`(맵), `replace(_if)`
- `fill`, `iota`
- `remove(_if)` (⚠ 컨테이너 길이는 변하지 않음 → **remove-erase idiom** 필요)
- `unique` (연속 중복 제거)

**remove-erase idiom**

```cpp
#include <vector>
#include <algorithm>
using namespace std;

int main(){
    vector<int> v{1,2,3,2,4};
    v.erase(remove(v.begin(), v.end(), 2), v.end()); // 값 2 삭제
}
```

### 2.3 **파티션**(참/거짓 분할)

- `partition`(불안정, Relative order 유지X), `stable_partition`(안정)
- 반환: **구분 경계 반복자**

```cpp
vector<int> v{3,1,4,1,5,9};
auto mid = partition(v.begin(), v.end(), [](int x){ return x%2==0; });
// [v.begin(), mid) = 짝수, [mid, v.end()) = 홀수
```

### 2.4 **정렬/부분정렬/선택**

- `sort` (불안정), `stable_sort` (안정), `partial_sort`, `nth_element`
- 정렬 복잡도 평균 $$O(n \log n)$$, `nth_element` 평균 $$O(n)$$

```cpp
vector<int> v{7,2,9,4,1,5};
nth_element(v.begin(), v.begin()+3, v.end()); // 4번째 원소 위치에 '순위 3' 원소
// v[0..3) ≤ v[3] ≤ v(3..)
partial_sort(v.begin(), v.begin()+3, v.end()); // 상위 3개만 정렬
```

> **안정성**이 필요한 “키-타이브레이킹”은 `stable_sort` + `stable_sort` 두 번이 깔끔한 전략.

### 2.5 **회전/뒤집기/치환**

- `reverse`, `rotate`, `swap_ranges`

```cpp
vector<int> v{1,2,3,4,5};
// [first, middle)과 [middle, last) 교체 순환
rotate(v.begin(), v.begin()+2, v.end()); // 3 4 5 1 2
```

### 2.6 **집합** 알고리즘(정렬된 범위 필요)

- `set_union`, `set_intersection`, `set_difference`, `set_symmetric_difference`, `includes`

```cpp
vector<int> a{1,2,3,5}, b{2,3,4};
vector<int> out;
set_intersection(a.begin(),a.end(), b.begin(),b.end(), back_inserter(out)); // 2 3
```

### 2.7 **힙** 알고리즘(랜덤 접근 필요)

- `make_heap`, `push_heap`, `pop_heap`, `sort_heap`

```cpp
vector<int> v{3,1,4,1,5};
make_heap(v.begin(), v.end());     // 힙 구성
v.push_back(9); push_heap(v.begin(), v.end());
pop_heap(v.begin(), v.end()); v.pop_back();
```

### 2.8 수치 알고리즘 `<numeric>`

- `accumulate`, `inner_product`, `partial_sum`, `adjacent_difference`
- C++17 병렬: `<execution>` 정책
- C++17/20 스캔: `inclusive_scan`, `exclusive_scan`(헤더 `<numeric>`)

```cpp
#include <numeric>
#include <vector>
#include <iostream>
using namespace std;

int main(){
    vector<int> v{1,2,3,4};
    int sum = accumulate(v.begin(), v.end(), 0); // 10
    vector<int> prefix(v.size());
    partial_sum(v.begin(), v.end(), prefix.begin()); // 1 3 6 10
    cout << sum << " " << prefix.back() << "\n";
}
```

### 2.9 C++17 **병렬 정책**(대량 데이터에서만 고려)

- `<execution>`: `seq`, `par`, `par_unseq`  
- 예: `sort(v.begin(), v.end(), less<>{});` → `sort(execution::par, ...)`

> 병렬 정책 사용 전 **측정** 필수(작은 n은 역효과).

---

## 3) 커스텀 비교/투영(Projection) & 안정성

### 3.1 람다 비교자

```cpp
sort(v.begin(), v.end(), [](auto& a, auto& b){
    if (a.key != b.key) return a.key < b.key;
    return a.sub < b.sub; // tie-break
});
```

### 3.2 **안정 정렬**로 2단계 정렬

```cpp
// 1단계: 보조키로 stable_sort
stable_sort(v.begin(), v.end(), [](auto& a, auto& b){ return a.sub < b.sub; });
// 2단계: 주키로 stable_sort (보조키 순서 보존)
stable_sort(v.begin(), v.end(), [](auto& a, auto& b){ return a.key < b.key; });
```

---

## 4) 실전 레시피 모음

### 4.1 “값 제거” 모든 컨테이너 공통 패턴

```cpp
// 시퀀스 컨테이너(vector/deque/string)
seq.erase(remove(seq.begin(), seq.end(), value), seq.end());

// list는 전용 멤버가 더 효율적
lst.remove(value);           // 값 기준
lst.remove_if(pred);         // 술어 기준
```

### 4.2 “조건으로 남기기/버리기”

```cpp
seq.erase(remove_if(seq.begin(), seq.end(),
                    [](int x){ return x % 2 == 0; }), seq.end()); // 짝수 제거
```

### 4.3 “Top-K” (빠른 선택 + 부분 정렬)

```cpp
auto K = 10u;
if (v.size() > K) {
    nth_element(v.begin(), v.begin()+K, v.end(), greater<>{}); // 상위 K까지
    v.resize(K);
    sort(v.begin(), v.end(), greater<>{}); // 보기 좋게 정렬
}
```

### 4.4 “역순 출력” (컨테이너 유형 무관)

```cpp
for (auto it = c.rbegin(); it != c.rend(); ++it) cout << *it << ' ';
```

### 4.5 “복사 vs 이동 변환”

```cpp
vector<string> src = {"a","b","c"};
vector<string> dst;
transform(make_move_iterator(src.begin()),
          make_move_iterator(src.end()),
          back_inserter(dst),
          [](string&& s){ return s + "!"; });
// src 요소는 이동 후 빈 상태일 수 있음
```

### 4.6 “두 정렬 범위의 차집합/합집합”

```cpp
vector<int> A{1,2,3,7}, B{2,3,4};
vector<int> U, D;
set_union(A.begin(),A.end(), B.begin(),B.end(), back_inserter(U));     // 1 2 3 4 7
set_difference(A.begin(),A.end(), B.begin(),B.end(), back_inserter(D)); // 1 7
```

---

## 5) C++20 Ranges(범위) 한 장 요약

- 헤더 `<ranges>`, 네임스페이스 `std::ranges::`
- **보기 쉬운 파이프라인**: `views::filter`, `views::transform`, `views::take`, …
- **대부분 알고리즘**이 `ranges::` 버전 존재(반환값이 반복자쌍이 아닌 구조적으로 더 풍부)

```cpp
#include <vector>
#include <ranges>
#include <iostream>
using namespace std;

int main(){
    vector<int> v{3,1,4,1,5,9};
    for (int x : v | views::filter([](int x){return x%2;})
                   | views::transform([](int x){return x*x;})
                   | views::take(3)) {
        cout << x << ' '; // 9 1 25
    }
}
```

---

## 6) 복잡도와 수학(요약)

- 정렬: $$O(n \log n)$$, 선택(`nth_element`): 평균 $$O(n)$$  
- remove/unique 계열: 한 번의 선형 스캔 ⇒ $$O(n)$$  
- 집합 알고리즘(정렬 필요): 선형 합 ⇒ $$O(n+m)$$  
- 누적/스캔: $$O(n)$$

---

## 7) 체크리스트

1. 알고리즘이 요구하는 **이터레이터 카테고리**를 충족하는가?  
2. **반복자 무효화** 가능성이 있는가(특히 `vector` reallocation, `unordered_*` rehash)?  
3. 삭제는 **remove-erase idiom** 또는 `list::remove(_if)`처럼 컨테이너 전용 멤버를 쓰는가?  
4. 정렬의 **안정성**이 필요한가(`stable_sort`)? **Top-K**는 `nth_element`+`partial_sort`로 최적화.  
5. 대량 데이터는 C++17 **병렬 정책** 시도 전 **측정**.  
6. C++20 이상이라면 **ranges**로 가독성/안전성 향상.

---

## 8) 연습 과제

1) 정수 벡터에서 **중복 제거**를 `sort` + `unique` + `erase`로 구현하고, 입력 크기별 시간을 측정하라.  
2) 로그 레코드(시간, 사용자, 이벤트)를 `(시간 asc, 사용자 asc)` **안정 정렬**로 정렬하라.  
3) 두 정렬된 리스트의 **교집합/차집합**을 `set_*` 알고리즘으로 구현하고 `list`와 `vector`에서의 성능 차를 비교하라.  
4) `unordered_map<string,int>`로 단어 카운트. **reserve/rehash** 조정에 따른 속도/메모리 변화를 측정하라.  
5) C++20 `ranges`로 홀수 제곱 상위 5개 합을 한 줄 파이프라인으로 작성하라.

---

### 부록 A. 미세 팁

- `for_each`에 **캡처 람다**로 카운터/합계 합치면 깔끔.  
- `std::distance`, `std::advance`, `std::next/prev`로 이터레이터 산술을 범용화.  
- `transform_reduce`(C++17 병렬/수치)로 **맵+리듀스** 한 번에.  
- `span`(C++20)으로 **Contiguous** 범위를 안전하게 받아 알고리즘에 넘기기.
