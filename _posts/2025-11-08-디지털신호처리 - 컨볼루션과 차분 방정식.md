---
layout: post
title: 디지털신호처리 - 컨볼루션과 차분 방정식
date: 2025-11-08 16:25:23 +0900
category: 디지털신호처리
---
# 컨볼루션과 차분 방정식

## 컨볼루션(Convolution)

### 정의(선형 컨볼루션)

LTI 시스템의 출력은 임펄스응답 `h[n]`과 입력 `x[n]`의 컨볼루션이다.

$$
y[n] \;=\; (x*h)[n] \;\triangleq\; \sum_{k=-\infty}^{\infty} x[k]\,h[n-k].
$$

유한 길이 `x`와 `h`의 길이가 각각 `N_x, N_h`라면 선형 컨볼루션 길이는

$$
N_y \;=\; N_x + N_h - 1.
$$

#### 기본 성질

- 교환법칙
  $$
  x*h = h*x
  $$
- 결합법칙
  $$
  x*(h_1*h_2) = (x*h_1)*h_2
  $$
- 분배법칙
  $$
  x*(h_1+h_2) = x*h_1 + x*h_2
  $$
- 단위원(임펄스)
  $$
  x*\delta = x
  $$

#### 실습 1: 선형 컨볼루션의 길이와 성질

```
clear; close all; clc
x = [1 2 3 4];            % N_x = 4
h = [1 -1 0.5 0.5];       % N_h = 4
y = conv(x, h);           % length = 7
fprintf("length(y) = %d (expect 4+4-1=7)\n", numel(y));

% 교환법칙 확인
yc = conv(h, x);
fprintf("commutativity error = %.2e\n", norm(y - yc));
```

---

### 원형 컨볼루션(DFT 기반)과 제로패딩

길이 `N` DFT에서의 곱셈은 **원형 컨볼루션**에 해당한다.

$$
y_N[n] = \sum_{k=0}^{N-1} x[k]\;h[\langle n-k\rangle_N], \qquad n=0,\dots,N-1.
$$

여기서 `⟨·⟩_N`은 모듈로 `N` 인덱싱이다. **선형 컨볼루션과 같게** 만들려면 **제로 패딩**으로

$$
N \;\ge\; N_x + N_h - 1
$$

을 보장해야 한다. 그렇지 않으면 **원형 성분의 aliased overlap**이 발생한다.

#### 실습 2: 선형 vs 원형 컨볼루션의 차이

```
x = [1 2 3 4]; h = [1 -1 0.5];
y_lin = conv(x, h);                   % 선형 컨볼루션
N = numel(x);                         % 패딩 없는 원형
y_circ_bad = ifft( fft(x, N) .* fft(h, N) );

Nok = numel(x)+numel(h)-1;            % 충분한 패딩
y_circ_ok  = ifft( fft(x, Nok) .* fft(h, Nok) );

disp("linear: ");       disp(y_lin(:).');
disp("circular N=4:");  disp(y_circ_bad(:).');   % aliasing 발생
disp("circular N=6:");  disp(y_circ_ok(:).');    % 선형과 일치
```

---

### 빠른 컨볼루션: Overlap-Add(OLA) / Overlap-Save(OLS)

긴 신호와 중간 길이 필터를 빠르게 컨볼브하려면 블록 FFT가 유리하다.

- **Overlap-Add (OLA)**
  입력을 길이 `L` 블록으로 자르고, 각 블록을 `N_fft ≥ L+N_h-1`로 FFT 컨볼루션 후 결과를 **겹침-덧셈**한다.
  복잡도는 대략 블록당 `O(N_fft log N_fft)`.

- **Overlap-Save (OLS)**
  입력을 `L`씩 **겹치도록** 잘라 `N_fft` DFT로 원형 컨볼루션을 수행하고, 앞부분 `N_h-1` 샘플을 버리고 나머지를 저장한다. 실시간 스트리밍에 적합하다.

**지연/복잡도 선택 가이드**
- `N_fft`는 보통 `2^ceil(log2(L+N_h-1))`.
- 지연은 대략 `N_fft - L`(OLS) 또는 `N_h-1`(OLA).
- 대략적 연산량 비교:
  - 직접형: `O(N_x N_h)`
  - FFT형: `O(N_x log N_fft)`(상수·메모리 오버헤드 존재)
  긴 필터(`N_h`가 수백~수천)나 긴 신호에서 FFT형이 유리하다.

#### 실습 3-1: OLA 구현(간단 버전)

```
function y = ola_conv(x, h, L)
  % x: long input, h: FIR, L: block length for FFT
  Nx = numel(x); Nh = numel(h);
  Nfft = 2^nextpow2(L + Nh - 1);
  H = fft(h, Nfft);
  y = zeros(1, Nx + Nh - 1);
  i = 1;
  while i <= Nx
    iEnd = min(i+L-1, Nx);
    xb = x(i:iEnd);
    yb = ifft( fft(xb, Nfft) .* H );
    % overlap-add
    y(i:i+numel(yb)-1) += yb;
    i += L;
  endwhile
endfunction

% 테스트
x = randn(1, 8000); h = fir1(127, 0.2, hamming(128));
y1 = conv(x, h);
y2 = ola_conv(x, h, 512);
fprintf("OLA error = %.2e\n", norm(y1 - y2));
```

#### 실습 3-2: OLS 구현(스트리밍 감각)

```
function y = ols_conv(x, h, L)
  Nh = numel(h);
  Nfft = 2^nextpow2(L + Nh - 1);
  H = fft(h, Nfft);
  % 초기 오버랩 버퍼: Nh-1 길이의 0
  overlap = zeros(1, Nh-1);
  y = [];
  i = 1;
  while i <= numel(x)
    xb = x(i:min(i+L-1, numel(x)));
    % 입력 프레임 = [overlap, xb]
    frame = [overlap, xb];
    Yb = ifft( fft(frame, Nfft).*H );
    % 앞 Nh-1 샘플은 버리고 저장
    yb = Yb(Nh:end);
    y = [y, yb];
    % 다음 오버랩 준비
    if numel(xb) >= Nh-1
      overlap = xb(end-(Nh-2):end);
    else
      overlap = [overlap(numel(xb)+1:end), xb];
    endif
    i += L;
  endwhile
endfunction

% 검증
x = randn(1, 10000); h = fir1(63, 0.25);
y_lin = conv(x, h);
y_ols = ols_conv(x, h, 512);
y_ols = y_ols(1:numel(y_lin)); % 길이 맞추기
fprintf("OLS error = %.2e\n", norm(y_lin - y_ols));
```

---

### 경계와 지연, 위상

- **경계효과**: 유한 길이 필터링에서 앞·뒤 경계는 패딩/윈도잉이 필요하다.
  `conv(x,h,'same')`는 중앙 맞춤이지만 앞뒤 왜곡은 남는다.
- **군지연(Group Delay)**: 선형위상 FIR(길이 `N`, 대칭 계수)은 상수 지연 `((N-1)/2)`을 갖는다.

$$
\tau_g \;=\; \frac{N-1}{2}.
$$

- IIR은 일반적으로 비선형 위상이며 주파수 의존 지연을 가진다. 위상왜곡을 줄이려면 `filtfilt`(양방향 필터링)를 사용한다(경계 패딩 주의).

#### 실습 4: 이동평균 FIR의 지연 확인

```
M = 9; h = ones(1, M)/M;                 % length = 9
imp = [1, zeros(1,63)];
y = conv(imp, h);
n = 0:numel(y)-1;
stem(n, y, "filled"); grid on; title("Impulse response (MA)");
% 지연은 (M-1)/2 = 4 샘플
```

---

### 컨볼루션 정리(주파수 영역 등가)

시간영역 컨볼루션은 주파수영역 곱과 등가이다.

$$
y[n] = (x*h)[n] \quad \Longleftrightarrow \quad Y(e^{j\omega}) = X(e^{j\omega})\,H(e^{j\omega}).
$$

#### 실습 5: 주파수 영역 곱과 시간 영역 컨볼루션의 일치

```
pkg load signal
x = randn(1, 2048);
b = fir1(63, 0.3, hamming(64)); a = 1;

% 시간 영역
y1 = filter(b, a, x);

% 주파수 영역 (zero-padding)
N = 2^nextpow2(numel(x) + numel(b) - 1);
Yf = ifft( fft(x, N) .* fft(b, N) );
y2 = Yf(1:numel(x)); % filter()와 동일 길이 비교

fprintf("time-vs-freq error = %.2e\n", norm(y1 - y2));
```

---

### 디컨볼루션(역필터)의 기초

이상적으로는

$$
X(e^{j\omega}) = \frac{Y(e^{j\omega})}{H(e^{j\omega})}
$$

이지만, `H`가 0에 가까운 주파수대가 있으면 잡음이 크게 증폭된다. 따라서

$$
\widehat{X}(e^{j\omega}) \;=\; \frac{H^*(e^{j\omega})}{|H(e^{j\omega})|^2 + \lambda}\,Y(e^{j\omega})
$$

같은 정규화(티호노프에 해당)를 사용한다(`λ>0`).

#### 실습 6: 간단한 정규화 역필터(주파수 영역)

```
% 블러 커널(짧은 평균)로 컨볼브된 신호에서 원복 시도
x0 = randn(1,2000);
h  = ones(1,9)/9;                 % blur
y  = conv(x0,h,'same') + 0.02*randn(1,2000);

N = 2^nextpow2(numel(y)+numel(h)-1);
X0 = fft(x0,N); Y = fft(y,N); H = fft(h,N);

lambda = 1e-2;
Xhat = (conj(H)./(abs(H).^2 + lambda)) .* Y;
xhat = real(ifft(Xhat));
xhat = xhat(1:numel(y));

fprintf("MSE(no-regularize) vs MSE(lambda=1e-2): can't compare directly here, visualize if needed.\n");
```

---

## 차분 방정식(Difference Equation)

### LCCDE(선형 상수계수 차분 방정식)

일반형

$$
\sum_{m=0}^{M} a_m\,y[n-m] \;=\; \sum_{k=0}^{K} b_k\,x[n-k], \qquad a_0 = 1.
$$

- **FIR**: `a_1 = ... = a_M = 0`
- **IIR**: 적어도 하나의 `a_m (m≥1)`가 0이 아님

전달함수

$$
H(z) \;=\; \frac{Y(z)}{X(z)} \;=\; \frac{\sum_{k=0}^{K} b_k\,z^{-k}}{1 + \sum_{m=1}^{M} a_m\,z^{-m}}.
$$

#### 실습 7: 차분식으로 필터링

```
% y[n] = 0.6 y[n-1] + x[n] - 0.5 x[n-1]
a = [1, -0.6];           % y - 0.6 y[n-1]
b = [1, -0.5];           % x - 0.5 x[n-1]
x = randn(1, 256);
y = filter(b, a, x);
```

---

### 일반해 = 자유응답(동차해) + 강제응답(특해)

표준형

$$
y[n] - \sum_{m=1}^{M} a_m\,y[n-m] = \sum_{k=0}^{K} b_k\,x[n-k]
$$

의 해는

$$
y[n] = y_{\text{free}}[n] + y_{\text{forced}}[n].
$$

- **자유응답(동차)**: 입력이 0일 때의 해. 특성방정식

  $$
  r^{M} - \sum_{m=1}^{M} a_m r^{M-m} = 0
  $$

  의 근 `r_i`로

  $$
  y_{\text{free}}[n] = \sum_i C_i\, r_i^n
  $$

  (중근은 `n^s r^n` 형태)
- **강제응답(특해)**: 컨볼루션 관점에서 `h*x`.

#### 실습 8: 2차 IIR의 자유응답

```
% y[n] - 1.2 y[n-1] + 0.36 y[n-2] = x[n]
a = [1, -1.2, 0.36]; b = 1;
r = roots(a);           % 특성근
disp("characteristic roots: "); disp(r.');

% 입력 0, 초기조건으로만 자유응답
N = 60;
x0 = zeros(1, N);
A = 1; B = 0;                        % y[-1]=A, y[-2]=B
zi = filtic(b, a, [A, B], [0, 0]);
y_free = filter(b, a, x0, zi);

stem(0:N-1, y_free, "filled"); grid on; title("Free response by initial conditions");
```

---

### 표준 입력에 대한 응답(임펄스·계단·지수·사인)

- 임펄스
  $$
  x[n]=\delta[n] \;\Rightarrow\; y[n]=h[n]
  $$
- 계단
  $$
  x[n]=u[n] \;\Rightarrow\; s[n]=\sum_{k\le n} h[k]
  $$
- 지수
  $$
  x[n]=a^n u[n] \Rightarrow \text{안정 IIR이면 같은 꼴의 지수 조합}
  $$
- 사인(또는 복소지수)
  $$
  x[n]=\cos(\omega_0 n) \;\Rightarrow\; y[n]=|H(e^{j\omega_0})|\cos\big(\omega_0 n + \angle H(e^{j\omega_0})\big)
  $$

#### 실습 9: 사인 입력의 크기·위상 확인

```
pkg load signal
[b, a] = butter(3, 0.3);      % IIR LPF
N = 512; n = 0:N-1; w0 = pi/4;
x = cos(w0*n);
y = filter(b, a, x);

[H, ~] = freqz(b, a, w0);
fprintf("|H|≈%.3f, arg(H)≈%.3f rad\n", abs(H), angle(H));
```

---

### 일방 Z-변환(단면 Z)으로 해 구하기(초기조건 포함)

우측 신호(인과 시스템)에 대해 **단면 Z-변환**을 쓰면, 초기조건을 가진 차분식도 대수적으로 풀 수 있다. 예컨대

$$
y[n] - a_1 y[n-1] = b_0 x[n]
$$

에 `y[-1]=y_{-1}`이 주어졌다면

$$
Y(z) - a_1 z^{-1} Y(z) - y_{-1} = b_0 X(z)
$$

형으로 정리되어 `Y(z)`를 구하고 부분분수/역변환을 취한다. 실무에서는 `filtic`으로 초기상태를 구성해 `filter`에 넘기는 것이 간편하다.

#### 실습 10: 단면 Z 등가(수치적 확인)

```
% filter + filtic로 단면 Z 결과를 수치적으로 재현
a = [1, -0.8]; b = [1];
x = randn(1,200);
y_m1 = 2.0;            % y[-1]
zi = filtic(b,a,y_m1,0);
y = filter(b,a,x,zi);

% 같은 시스템을 초기조건 0으로 돌리고, 자유응답만 별도 합성해도 동일해야 한다
y0 = filter(b,a,x);            % IC=0
imp = [1, zeros(1,199)];
h = filter(b,a,imp);           % h[n]
y_free = y_m1 * [0, h(1:end-1)]; % y[-1]*h[n-1] (직관적 컨볼루션 해석)
fprintf("error (IC combine vs filtic) = %.2e\n", norm(y - (y0 + y_free)));
```

---

### 안정성(BIBO)과 극(pole)

BIBO 안정 LTI(인과·유리형 가정)의 필요충분조건은 **모든 폴이 단위원 내**에 있는 것이다.

$$
\max_i |p_i| < 1 \quad \Longleftrightarrow \quad \sum_n |h[n]| < \infty.
$$

- FIR은 항상 안정하다.
- 적분기 `y[n]=y[n-1]+x[n]`의 임펄스응답은 `u[n]`이라 절대합 발산 → **BIBO 불안정**.

#### 실습 11: 극 반경 검사와 적분기 관찰

```
% 1) 임의 IIR의 극 반경
[~, a] = cheby1(6, 1, 0.4);
p = roots(a);
fprintf("max |pole| = %.5f (<1 => BIBO stable)\n", max(abs(p)));

% 2) 적분기 반응
x = ones(1,200);               % DC 입력
y = filter(1, [1 -1], x);      % y[n] = y[n-1] + x[n]
plot(y); grid on; title("Integrator output grows (BIBO unstable)");
```

---

### 구현 구조(Direct Form I/II, 전치), 수치 안정성

- **Direct Form I**: FIR(분자)과 IIR(분모) 부분을 직렬로 구성(지연선 두 벌).
- **Direct Form II**: 지연선을 공유(지연선 한 벌)하나 고차에서는 수치 민감할 수 있다.
- **전치 구조(Transposed)**: 누산기·연산 순서를 바꿔 실수/고정소수점에서 유리할 수 있다.
- 고차 IIR은 **2차 섹션(바이쿼드) 직렬화**와 **스케일링**이 권장된다.

#### 실습 12: DF-II 전치의 수동 구현(검증)

```
% 2차 섹션 예시 계수
b = [0.2066 0.4131 0.2066];
a = [1.0000 -0.3695 0.1958];

% DF-II Transposed 수동 구현 함수
function y = df2t(b,a,x)
  % a(1) = 1 가정
  N = numel(x); y = zeros(1,N);
  s1 = 0; s2 = 0;                % 내부 상태
  for n=1:N
    v  = x(n) - a(2)*s1 - a(3)*s2;
    y(n) = b(1)*v + s1;
    s1 = b(2)*v + s2;
    s2 = b(3)*v;
  end
end

x = randn(1,1000);
y1 = filter(b,a,x);
y2 = df2t(b,a,x);
fprintf("DF2T vs filter error = %.2e\n", norm(y1 - y2));
```

---

### 컨볼루션 ↔ 차분 방정식의 등가(실무 검증)

같은 LTI를 컨볼루션(FIR 계수 `h`) 또는 차분식(분자 `b`, 분모 `a`)으로 구현 가능하다. FIR은 직관적이고 안정적, IIR은 차수가 낮아 효율적이나 **극 안정성/수치 민감도**에 유의해야 한다. 긴 FIR은 FFT-컨볼루션(OLA/OLS)이 실용적이다.

#### 실습 13: 동일 시스템의 세 표상 일치

```
pkg load signal
% IIR 예: y[n] = 0.5 y[n-1] + x[n]
a = [1, -0.5]; b = 1;

% 1) 차분식 필터링
x = randn(1, 4096);
y_df = filter(b, a, x);

% 2) h[n]을 충분히 길게 추정해 FIR 컨볼루션 근사
imp = [1, zeros(1,4095)];
h = filter(b, a, imp);          % 임펄스응답
y_cv = conv(x, h, "same");

% 3) 주파수 영역 곱
N = 2^nextpow2(numel(x)+numel(h)-1);
y_fft = ifft( fft(x,N).*fft(h,N) );
y_fft = y_fft(1:numel(x));

fprintf("diff-eq vs conv error = %.2e\n", norm(y_df - y_cv));
fprintf("diff-eq vs FFT  error = %.2e\n", norm(y_df - y_fft));
```

---

## 경계·지연·수치 이슈(체크리스트)

1. **선형 vs 원형**: DFT 기반 컨볼루션은 제로패딩으로 선형 등가를 맞춘다.
2. **경계 처리**: `conv(...,'same')`, 패딩(`zeros`, 반사, 반복), `filtfilt`의 양끝 보정.
3. **지연**: FIR의 `((N-1)/2)`, IIR은 주파수 의존 지연. 실시간이면 타임스탬프 보정.
4. **수치 안정성**: 고차 IIR·`|p|≈1` 극은 민감. 2차 섹션/스케일링/전치 구조 권장.
5. **블록 처리**: OLA/OLS에서 `N_fft`, `L`, 오버랩 길이(`N_h-1`) 설정이 성능과 왜곡에 영향.
6. **검증**: 임펄스/스텝/치르프 입력과 `freqz` 비교로 일치성 자동화.
7. **디컨볼루션**: 0에 가까운 `|H|` 대역에서는 정규화/제약 필요(잡음 증폭 방지).

---

## 예제 시나리오 1: 센서 신호 정화(FIR+IIR)

문제: 저주파 드리프트와 고주파 노이즈가 섞인 센서 신호를 정화한다.
전략: 저역 FIR(노이즈 억제) → 고역 IIR(드리프트 제거). 컨볼루션·차분식 모두로 확인한다.

```
pkg load signal
Fs = 200; t = (0:1/Fs:120)';                 % 2분
raw = 0.5*sin(2*pi*0.7*t) + 0.05*randn(size(t)) + 0.002*t;

% FIR(LP): 5 Hz 컷, 선형위상 -> 컨볼루션/필터
N = 129; b_fir = fir1(N-1, 5/(Fs/2), hamming(N)); a_fir = 1;
denoise = filtfilt(b_fir, a_fir, raw);

% IIR(HP): 0.02 Hz 컷, 차분 방정식 구현
[b_hp, a_hp] = butter(3, 0.02/(Fs/2), 'high');
clean = filtfilt(b_hp, a_hp, denoise);

% FIR 컨볼루션 vs filter() 동치 확인
conv_out = conv(raw, b_fir, "same");
fprintf("conv vs filter(FIR) = %.2e\n", norm(conv_out - filter(b_fir,1,raw)));

plot(t, [raw, denoise, clean]); grid on
legend("raw","FIR denoise","FIR+IIR clean");
xlabel("s"); ylabel("amp"); title("Sensor cleaning (convolution + difference eq.)");
```

---

## 예제 시나리오 2: 긴 임펄스(리버브) 실시간 처리(OLS)

문제: 오디오 리버브 임펄스응답이 수만 탭으로 매우 길다.
전략: OLS로 프레임 단위 처리, 지연·연산량을 통제한다.

```
% 가상 리버브 임펄스 (지수 감쇠 + 잔향)
Lh = 8192; n = 0:Lh-1; h = (0.9).^n .* (randn(1,Lh)*0.02); h(1)=1;

% white-noise 입력 (오디오 프레임 1024 샘플씩)
Fs = 48000;
x = randn(1, Fs*5);   % 5초
y_lin = conv(x,h,'same');

% OLS 파라미터
L = 1024;                   % 프레임
y_ols = ols_conv(x, h, L);  % 앞에서 정의한 함수 재사용
y_ols = y_ols(1:numel(x));

fprintf("reverb OLS error = %.2e\n", norm(y_lin - y_ols));
```

---

## 부록: 속도 비교(직접형 vs FFT형)

짧은 FIR(수십 탭)은 직접형이, 긴 FIR(수천 탭)은 FFT형이 유리하다. 아래는 간단한 시간 비교 스니펫이다(환경에 따라 상이).

```
pkg load signal
Nsig = 400000;                % 긴 신호
for Nh = [31, 127, 511, 2047, 8191]
  x = randn(1,Nsig);
  h = fir1(Nh-1, 0.2);

  tic; y1 = conv(x,h,'same'); t_conv = toc;
  tic; y2 = ola_conv(x,h, 4096); t_fft = toc;

  fprintf("Nh=%5d | conv: %.3fs  OLA-FFT: %.3fs  err=%.2e\n", ...
          Nh, t_conv, t_fft, norm(y1 - y2(1:numel(y1))));
endfor
```
