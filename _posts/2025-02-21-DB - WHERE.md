---
layout: post
title: DB - WHERE 절
date: 2025-02-21 19:20:23 +0900
category: DB
---
# WHERE 절

## 요약 체크리스트 (현업 빠른 적용)

- **NULL 비교는 `IS [NOT] NULL`만**: `= NULL`은 항상 `UNKNOWN`.
- **인덱스를 타려면** 컬럼 **좌측 그대로** 비교(함수/연산 감싸지 않기) → SARGable.
- **부정 연산자(`NOT`, `<>`, `NOT LIKE`) 남용 금지**: 가능하면 **긍정 조건**으로 재작성.
- **범위 조건은 연속/포함 정확히**: `BETWEEN`의 경계 포함 의미 숙지.
- **`IN (… NULL …)`/`NOT IN (… NULL …)`** 함정 피하기 → `EXISTS`/`NOT EXISTS`.
- **문자 비교의 대소문자/Collation** 통일: `lower()` 인덱스/CI 타입 사용.
- **시간대/날짜 경계**는 **반열림 구간** 권장: `>= start AND < next_start`.
- **파티션 키와 WHERE 일치**: 파티션 프루닝 유도.
- DML 전에는 **드라이런(SELECT)**, **트랜잭션 경계**/`RETURNING`으로 방어.

---

## WHERE 절의 평가 모델: 3값 논리와 연산자 우선순위

### SQL의 3값 논리(Three-Valued Logic)

SQL의 술어 결과는 `TRUE / FALSE / UNKNOWN(NULL)` 세 값 중 하나다.
`UNKNOWN`은 **WHERE 필터에서 제외**(= 거짓처럼 취급), 하지만 `NOT UNKNOWN` 또한 `UNKNOWN`일 수 있다.

**진리표(발췌)**

| 표현식 | 결과 |
|---|---|
| `NULL = NULL` | `UNKNOWN` |
| `NULL <> 1` | `UNKNOWN` |
| `NOT (NULL = 1)` | `UNKNOWN` |

> 정밀한 판정을 위해선 **`IS NULL`/`IS NOT NULL`**을 사용한다.

### 연산자 우선순위(기본)

1) 괄호 `()`, 2) 비교/LIKE/IN/IS, 3) `NOT`, 4) `AND`, 5) `OR`
실무에서는 **논리 그룹을 괄호로 명시**해 가독성과 실수를 동시에 방지한다.

```sql
-- 모호함
WHERE job = 'CLERK' OR job = 'MANAGER' AND dept_id = 10;

-- 명확함
WHERE (job = 'CLERK' OR job = 'MANAGER') AND dept_id = 10;
```

---

## WHERE 절 문법 심화: 스칼라 비교·범위·집합·패턴

### 스칼라 비교

```sql
WHERE salary > 5000
AND   dept_id = 10
AND   hire_date >= DATE '2024-01-01';
```

- 수형 일치(타입 캐스팅) 비용이 발생하면 인덱스 사용이 방해될 수 있다.
  **컬럼 타입과 리터럴 타입을 일치**시켜라.

### 범위 비교: `BETWEEN`, 반열림 구간

`BETWEEN a AND b`는 **a 이상 b 이하**(폐구간)다.
날짜/타임스탬프 범위에는 **반열림 구간**이 안전하다.

```sql
-- 권장(반열림): [2025-11-01 00:00, 2025-12-01 00:00)
WHERE ts >= TIMESTAMPTZ '2025-11-01'
  AND ts <  TIMESTAMPTZ '2025-12-01';
```

### 집합 비교: `IN`, `EXISTS`, `ANY/ALL`

- **`IN` 정적 리스트**: 옵티마이저가 집합 비교 최적화. 값 개수가 많다면 임시 테이블 조인(= 해시 조인) 검토.
- **서브쿼리 비교**:
  - **상관 서브쿼리 + `EXISTS`**는 존재 여부만 확인하므로 보통 **빠르다**.
  - **`IN (SELECT …)`**는 NULL 포함 시 함정. (2.5 참조)
- `= ANY (subquery)` 는 `IN` 과 유사, `> ALL (subquery)` 는 “모두보다 큼”.

```sql
-- 특정 고객의 최근 30일 주문 존재 여부
WHERE EXISTS (
  SELECT 1
  FROM "order" o
  WHERE o.customer_id = c.id
    AND o.ordered_at >= now() - interval '30 days'
);
```

### 패턴/검색: `LIKE`, 와일드카드, `ESCAPE`, 정규식

- `%`는 0+문자, `_`는 단일 문자.
- **전방 고정(`LIKE 'ABC%'`)은 인덱스 사용**이 가능(엔진/인덱스 조건부).
  **전방 와일드카드(`'%ABC'`)는 보통 인덱스 불가** → 역인덱스/검색엔진 고려.
- 리터럴에 `%` 포함 시 `ESCAPE` 문자를 지정.

```sql
-- %를 실제 문자로 찾고 싶을 때
WHERE comment LIKE '%50!%%' ESCAPE '!';
```

- PostgreSQL: `~`/`~*` 정규식, MySQL: `REGEXP`, SQL Server: `LIKE`+와일드카드 한정.

### `NOT IN`과 NULL 함정 → `NOT EXISTS` 권장

```sql
-- 위험: 서브쿼리가 NULL을 반환하면 결과가 모두 UNKNOWN → 0행
WHERE t.id NOT IN (SELECT parent_id FROM child); -- child.parent_id 중 NULL 존재시 문제

-- 안전: 상관 부정 존재
WHERE NOT EXISTS (
  SELECT 1 FROM child c WHERE c.parent_id = t.id
);
```

---

## SARGability(인덱스 친화도)와 실행계획

### 컬럼 좌측 원형 유지

- **컬럼을 함수/연산으로 감싸면** 보통 인덱스를 못 탄다.
- 대안1: **리터럴/표현식을 컬럼 쪽으로 이동**(역변환)
- 대안2: **함수 기반 인덱스**(엔진 지원 시)

```sql
-- 비추: birth_date 인덱스 무력화 가능성
WHERE TO_CHAR(birth_date, 'YYYY') = '1990';

-- 권장: 인덱스 유리
WHERE birth_date >= DATE '1990-01-01'
  AND birth_date <  DATE '1991-01-01';

-- 함수 기반 인덱스(예: PostgreSQL)
CREATE INDEX ix_users_lower_email ON users ((lower(email)));
WHERE lower(email) = 'alpha@example.com';
```

### 복합 인덱스 정렬과 시작열

복합(B-tree) 인덱스는 **선두 컬럼**부터 정렬된다.
조건은 가능한 한 **선두 컬럼에 동등 비교**, 그 다음 범위.

```sql
-- 인덱스 (status, created_at)
WHERE status = 'PAID'
  AND created_at >= now() - interval '7 days';
```

- `created_at`만 걸면 인덱스 선택성이 떨어질 수 있다.

### 인덱스

엔진이 **테이블을 보지 않고** 인덱스만으로 결과를 만들 수 있다.
PostgreSQL은 “Index Only Scan” 조건(가시성 맵) 충족 시,
SQL Server는 `INCLUDE (col…)`, MySQL은 InnoDB 보조 인덱스가 리프에 PK 포함.

```sql
-- SQL Server 예시
CREATE INDEX ix_order_q ON dbo.[order](customer_id, ordered_at) INCLUDE(status, id);
```

### 파티션 프루닝

파티션 키를 WHERE로 **정확히 제한**해야 프루닝이 적용된다.

```sql
-- RANGE(ordered_at) 파티션
WHERE ordered_at >= DATE '2025-11-01'
  AND ordered_at <  DATE '2025-12-01';
```

---

## 문자열/Collation/대소문자/공백·트림

### Collation의 영향

- `LIKE`, 정렬, 유니크 비교가 Collation에 좌우된다.
- 다국어/한글 환경에서는 **대소문자/자모 분해/정렬 규칙**을 표준화해야 예기치 않은 미스매치가 줄어든다.

### 대소문자 무시 검색

- **정규화 저장(소문자 저장)** 또는 **표현식 인덱스**(lower(email)) 권장.
- PostgreSQL `citext` 타입은 대소문자 무시 동등 비교 지원.

```sql
-- 정규화된 비교
WHERE lower(email) = lower(:email_param);
```

### 공백/트림

```sql
WHERE trim(name) = '홍길동';      -- 인덱스 비친화
-- 선행/후행 공백을 데이터 입력 단계에서 정규화하거나
-- 함수 기반 인덱스로 대응
```

---

## 시간·날짜 비교 모범 사례

### 시간대(TZ)와 경계

- 저장은 **UTC**, 표시에서 변환 권장.
- 일 경계는 지역시간대 변환시 **서머타임**을 고려해야 한다.

```sql
-- UTC 저장, 조회 시 변환 예시(PostgreSQL)
WHERE (ordered_at AT TIME ZONE 'Asia/Seoul')::date = DATE '2025-11-06';
```

### 반열림 구간 재강조

- 집계/리포트/파티션 경계는 **반열림 구간**이 버그를 줄인다.

---

## EXISTS / IN / JOIN / SEMI-ANTI JOIN 선택 가이드

| 목적 | 추천 | 이유 |
|---|---|---|
| 존재 여부 판단 | `EXISTS` | 로우 존재만 체크 → 빠름 |
| 하위 집합 필터(소량 상수 리스트) | `IN` | 간결/효율(정적 바인딩) |
| 실제 조인 필요(열 참조) | `JOIN` | 결합 결과 필요 |
| 부정 존재 | `NOT EXISTS` | `NOT IN` + NULL 함정 회피 |

```sql
-- 고객 중 최근 30일 주문 존재 고객
SELECT *
FROM customer c
WHERE EXISTS (
  SELECT 1 FROM "order" o
  WHERE o.customer_id = c.id
    AND o.ordered_at >= now() - interval '30 days'
);

-- 고객 중 최근 30일 주문이 없는 고객
SELECT *
FROM customer c
WHERE NOT EXISTS (
  SELECT 1 FROM "order" o
  WHERE o.customer_id = c.id
    AND o.ordered_at >= now() - interval '30 days'
);
```

---

## 부정 조건 최적화: `NOT LIKE`, `<>`, `NOT BETWEEN`

- **부정**은 범위가 넓어 인덱스 효율이 떨어진다.
가능하면 **긍정 조건의 합/범위**로 변환한다.

```sql
-- NOT BETWEEN 대체
WHERE amount < 100 OR amount > 1000;

-- NOT LIKE 대체(가능 시)
WHERE name >= 'A' AND name < 'B'; -- 특정 범위 컷(컬레이션 의존)
```

---

## 실전 패턴: 안전한 UPDATE/DELETE와 가드

### 드라이런과 트랜잭션

```sql
-- 1) 영향을 받는 행 확인
SELECT id FROM users
WHERE is_active = false AND last_login < now() - interval '1 year'
LIMIT 100;

-- 2) 실제 삭제는 트랜잭션으로 감싸고 RETURNING으로 검증
BEGIN;
DELETE FROM users
WHERE is_active = false AND last_login < now() - interval '1 year'
RETURNING id;
-- 영향 행 검토 후
COMMIT;  -- 또는 ROLLBACK
```

- MySQL은 `RETURNING` 지원 버전 확인(8.0.21+ 일부 문맥). 미지원 시 **임시 테이블**/로그로 대체.

### 단계적 삭제(청크)

```sql
-- 대량 삭제: 청크 루프(의사 코드)
DELETE FROM logs
WHERE created_at < now() - interval '90 days'
ORDER BY created_at
LIMIT 5000;
-- 반복 실행(스케줄러/배치)
```

### CTE로 대상 묶기

```sql
WITH target AS (
  SELECT id
  FROM orders
  WHERE status = 'CANCELLED'
    AND ordered_at < now() - interval '180 days'
)
DELETE FROM order_item oi
USING target t
WHERE oi.order_id = t.id;
```

---

## 통계·선택도와 WHERE 성능 모델(개념)

### 선택도와 추정 로우 수

선택도 \( s \)는 조건을 만족하는 비율.
예상 로우 수 \( \hat{N} \)는 \( \hat{N} = N \times s \).

$$
\hat{N} = N \cdot s, \qquad
s_{\text{복합}} \approx \prod_i s_i \quad (\text{독립 가정})
$$

- 실제로는 컬럼 간 상관관계로 독립 가정이 깨지므로, **히스토그램/다차원 통계**가 중요하다.

### 최신 통계 유지

- Postgres `ANALYZE` / Oracle `DBMS_STATS` / SQL Server Auto Update Stats / MySQL InnoDB 통계.
- **대량 로드/삭제 후 강제 갱신**으로 잘못된 계획을 교정.

---

## 문제 패턴과 리라이트(Rewrite)

### 함수로 감싼 WHERE

```sql
-- Before
WHERE date_trunc('day', ts) = DATE '2025-11-06';

-- After (SARGable)
WHERE ts >= TIMESTAMPTZ '2025-11-06 00:00+09'
  AND ts <  TIMESTAMPTZ '2025-11-07 00:00+09';
```

### OR 다중 조건 → UNION ALL

```sql
-- Before
WHERE (status = 'PAID' AND country = 'KR')
   OR (status = 'REFUND' AND country = 'US');

-- After: 각 분기별 인덱스 타기
SELECT ... WHERE status = 'PAID'   AND country = 'KR'
UNION ALL
SELECT ... WHERE status = 'REFUND' AND country = 'US';
```

### NOT IN → NOT EXISTS

앞서 서술. NULL 함정 회피.

---

## 파티셔닝·아카이빙과 WHERE

- **파티션 키 컬럼**을 WHERE에 정확히 걸어 **프루닝**을 유도.
- 삭제는 `DELETE`보다 **파티션 DROP/DETACH**가 수천 배 빠를 수 있다.
- 아카이브 테이블과 운영 테이블을 UNION ALL 뷰로 노출하고 WHERE로 기간을 분리.

```sql
-- 월 파티션 테이블만 조회
WHERE ordered_at >= DATE '2025-11-01'
  AND ordered_at <  DATE '2025-12-01';
```

---

## 실무 예제 — 전형적 필터링 시나리오

### “최근 30일, 한국 고객, 유효 주문 합계 10만 원 이상”

```sql
SELECT c.id, c.email,
       SUM(oi.qty * oi.price_cents) AS total_cents
FROM customer c
JOIN "order" o
  ON o.customer_id = c.id
 AND o.status IN ('PAID','SHIPPED')
 AND o.ordered_at >= now() - interval '30 days'   -- 상수 푸시다운
JOIN order_item oi
  ON oi.order_id = o.id
WHERE c.country_code = 'KR'
GROUP BY c.id, c.email
HAVING SUM(oi.qty * oi.price_cents) >= 100000
ORDER BY total_cents DESC
LIMIT 100;
```

- **조인 조건으로 상수 푸시다운**(Join predicate에 넣어 조인 전 필터링).
- `status`/`ordered_at`/`customer_id` 복합 인덱스가 유리.

### “페이지네이션(키셋 페이징)”

```sql
-- 마지막 행의 (ordered_at, id)를 알고 있을 때
SELECT id, customer_id, ordered_at, status
FROM "order"
WHERE (ordered_at, id) < (:last_ts, :last_id)
ORDER BY ordered_at DESC, id DESC
LIMIT 50;
```

- **OFFSET 페이징**은 뒤로 갈수록 느려진다 → **키셋 페이징**으로 전환.

### “부정 조건 최적화”

```sql
-- Before
WHERE NOT (status IN ('CANCELLED','REFUND'));

-- After (긍정 집합)
WHERE status IN ('PENDING','PAID','SHIPPED');
```

---

## RDBMS별 차이점(요약)

- **PostgreSQL**: 표현식/파셜 인덱스, RLS, `EXPLAIN (ANALYZE, BUFFERS)`, `citext`.
- **MySQL**: 전방 고정 LIKE 인덱스 가능, `EXPLAIN` 단순/히스토그램 옵션(버전 차), `IN` 대량은 임시테이블 전략.
- **SQL Server**: `INCLUDE` 컬럼, 필터드 인덱스, `READ_COMMITTED_SNAPSHOT` 고립 옵션.
- **Oracle**: 함수 기반 인덱스/비트맵 인덱스, 힌트 풍부(`/*+ INDEX */`, `/*+ USE_NL */` 등), `MERGE` 친화.

---

## 품질·안전 가드 레일

- DML은 **BEGIN…COMMIT**으로 감싸고, 먼저 **SELECT로 대상 미리 보기**.
- 운영에서는 `DELETE/UPDATE`에 **세이프가드**(예: 최소 한 개의 키 필터 강제).
- 변경 쿼리는 **리뷰/테스트/백업**을 선행.
- 주기적 **통계 갱신**과 쿼리 **회귀 모니터링**(성능 기준선)로 퇴행 방지.

---

## 마무리

WHERE 절은 단순한 필터가 아니라 **정확성(무결성)과 성능을 가르는 관문**이다.

- **정확성**: 3값 논리를 이해하고 NULL/부정/시간경계/Collation을 통제한다.
- **성능**: SARGability·복합 인덱스·파티션 프루닝·EXISTS/IN 선택으로 계획을 유리하게 만든다.
- **안전성**: DML 전 드라이런/트랜잭션/RETURNING·청크 삭제로 운영 리스크를 관리한다.
