---
layout: post
title: DB - WHERE 절
date: 2025-02-21 19:20:23 +0900
category: DB
---
# WHERE 절의 깊이: 데이터 필터링의 원리와 실전

## WHERE 절의 핵심 역할과 철학

WHERE 절은 SQL의 심장입니다. 단순히 데이터를 걸러내는 기능을 넘어, 쿼리의 성능과 정확성을 결정하는 가장 중요한 절 중 하나입니다. WHERE 조건을 어떻게 작성하느냐에 따라 인덱스를 활용할지, 전체 테이블을 스캔할지가 결정되며, 이는 수천 배의 성능 차이로 이어질 수 있습니다. 더욱이, NULL 처리, 날짜 경계, 복잡한 논리 조건은 미묘한 함정을 가지고 있어 데이터 정합성에 직접적인 영향을 미칩니다. 따라서 WHERE 절을 올바르게 이해하고 사용하는 것은 단순한 SQL 스킬이 아니라, 데이터를 정확하고 효율적으로 다루는 설계자의 핵심 역량입니다.

---

## WHERE 절의 논리적 기초: 3값 논리와 NULL

관계형 데이터베이스에서 WHERE 절은 전통적인 참/거짓 이진 논리보다 더 복잡한 **3값 논리**를 따릅니다. 조건 평가의 결과는 `TRUE`, `FALSE`, 그리고 `UNKNOWN`(일반적으로 NULL에서 비롯됨) 중 하나가 될 수 있습니다. 이 `UNKNOWN`은 WHERE 절에서 `FALSE`처럼 취급되어 행이 결과 집합에서 제외됩니다.

이것이 의미하는 바는 직관에 반할 수 있습니다. 예를 들어, `WHERE column = NULL`은 결코 참이 될 수 없습니다. NULL은 '알 수 없는 값'을 나타내므로, 다른 NULL을 포함한 어떤 값과도 '같다'고 판단할 수 없기 때문입니다. 그 결과는 `UNKNOWN`이 되고, 해당 행은 필터링됩니다.

**올바른 NULL 비교 방법**
```sql
-- 잘못된 방법: 결과는 항상 UNKNOWN (행이 반환되지 않음)
WHERE email = NULL;

-- 올바른 방법: IS NULL 또는 IS NOT NULL 사용
WHERE email IS NULL;
WHERE email IS NOT NULL;
```

이러한 특성은 `NOT IN` 서브쿼리에서 특히 위험합니다. 서브쿼리 결과 집합에 NULL이 하나라도 포함되면, 전체 `NOT IN` 조건의 결과는 `UNKNOWN`이 되어 예상치 않게 빈 결과를 반환할 수 있습니다. 이를 피하기 위해 `NOT EXISTS`를 사용하는 것이 안전한 패턴입니다.

---

## 성능의 관문: SARGability와 인덱스 활용

WHERE 절이 인덱스를 효율적으로 사용할 수 있는지를 결정하는 개념을 **SARGability**(Search ARGument-able)라고 합니다. 기본 원칙은 간단하지만 강력합니다: **인덱스가 정의된 컬럼을 그대로(순수한 형태로) 조건의 왼쪽에 두라**.

### 인덱스 사용을 방해하는 흔한 패턴과 개선책

1.  **컬럼에 함수나 연산 적용하기**
    ```sql
    -- 비효율적: 인덱스를 사용하지 못할 가능성이 높음
    WHERE YEAR(order_date) = 2024;
    WHERE salary * 1.1 > 5000;

    -- 효율적: 컬럼을 순수한 형태로 유지
    WHERE order_date >= '2024-01-01' AND order_date < '2025-01-01';
    WHERE salary > 5000 / 1.1;
    ```

2.  **좌변에 와일드카드 사용하기**
    ```sql
    -- 비효율적: 인덱스 활용이 어려움 (전체 인덱스 스캔 필요)
    WHERE product_name LIKE '%gadget%';

    -- 효율적: 인덱스 범위 스캔 가능
    WHERE product_name LIKE 'gadget%';
    ```
    후방 또는 중간 와일드카드 검색이 필요한 경우, 전문 검색 엔진(Elasticsearch)이나 역 인덱스를 고려해야 합니다.

3.  **암시적 타입 변환**
    ```sql
    -- user_id가 문자열 컬럼일 때 (비효율적)
    WHERE user_id = 12345; -- 숫자 리터럴

    -- 효율적: 타입을 일치시킴
    WHERE user_id = '12345';
    ```

### 복합 인덱스와 조건 순서의 마법

인덱스 `(status, created_at, customer_id)`가 있다고 가정해 봅시다. 이 인덱스는 먼저 `status`로 정렬되고, 그 다음 `created_at`, 마지막으로 `customer_id`로 정렬됩니다.

```sql
-- 효율적: 선두 컬럼(status)에 동등 조건 사용
WHERE status = 'PAID' AND created_at > '2024-01-01';

-- 비효율적: 선두 컬럼 조건이 없음 (인덱스 전체 스캔 가능성)
WHERE created_at > '2024-01-01'; -- status 조건 없음

-- 매우 효율적: 모든 조건이 인덱스 컬럼과 정확히 일치
WHERE status = 'PAID' AND created_at > '2024-01-01' AND customer_id = 1001;
```

인덱스 설계는 가장 자주 조회되고, 선택도가 높은(고유한 값이 많은) 컬럼을 선두에 두는 것이 원칙입니다.

---

## 날짜와 시간 비교: 정밀함의 예술

날짜/시간 범위 쿼리는 가장 흔하면서도 오류가 발생하기 쉬운 영역입니다. 가장 안전하고 널리 사용되는 패턴은 **반열린 구간**을 사용하는 것입니다.

```sql
-- 2024년 11월 데이터 조회 (안전한 방법)
WHERE event_time >= '2024-11-01 00:00:00'
  AND event_time <  '2024-12-01 00:00:00';
```

`BETWEEN`을 사용하면 간결해 보이지만, 종료 시점의 포함 여부에 주의해야 합니다. `BETWEEN '2024-11-01' AND '2024-11-30'`은 `'2024-11-30 23:59:59'`의 데이터를 포함할 수 있을까요? 이는 데이터베이스의 시간 정밀도(초, 밀리초)에 따라 달라져 모호함을 초래합니다. 반열린 구간(`>= 시작, < 다음 시작`)은 이러한 모호성을 완전히 제거합니다.

**시간대 처리**
글로벌 서비스의 경우, 데이터는 **UTC**로 저장하고, 사용자 인터페이스에서 현지 시간대로 변환하여 표시하는 것이 표준입니다. 이렇게 하면 서머타임 변경 같은 복잡성을 데이터 저장 단계에서 피할 수 있습니다.

---

## EXISTS vs IN vs JOIN: 상황에 맞는 도구 선택

서브쿼리를 사용할 때 가장 흔한 딜레마입니다. 각 도구는 고유한 강점이 있습니다.

*   **`EXISTS`**: "존재하는가?"라는 질문에 답할 때 사용합니다. 서브쿼리가 일치하는 첫 번째 행을 찾는 즉시 평가를 중단하므로, 특히 외부 쿼리에 비해 내부 쿼리가 큰 경우 매우 효율적입니다. `NOT EXISTS`는 `NOT IN`의 NULL 함정을 피하는 안전한 방법입니다.
    ```sql
    -- 최근 주문이 있는 고객 찾기
    SELECT * FROM customer c
    WHERE EXISTS (
        SELECT 1 FROM "order" o
        WHERE o.customer_id = c.id
        AND o.ordered_at > NOW() - INTERVAL '30 days'
    );
    ```

*   **`IN`**: 고정된 값 목록(예: `WHERE country IN ('KR', 'US', 'JP')`) 또는 작은 서브쿼리 결과와 비교할 때 간결하고 명확합니다. 그러나 서브쿼리 결과 집합이 크면, 그 모든 값을 메모리에 로드하고 비교해야 하므로 비효율적일 수 있습니다.

*   **`JOIN`**: 서브쿼리의 실제 컬럼 값이 외부 쿼리에서 필요할 때 사용합니다. `EXISTS`는 존재 여부만 확인하는 반면, `JOIN`은 데이터를 결합하여 새로운 결과 집합을 생성합니다.

**선택 가이드라인**: 존재 여부만 필요하면 `EXISTS`, 작은 집합과의 비교면 `IN`, 서브쿼리의 데이터를 실제로 사용해야 하면 `JOIN`을 선택하세요.

---

## 안전한 데이터 조작을 위한 방어적 패턴

WHERE 절은 `SELECT` 뿐만 아니라 `UPDATE`와 `DELETE`의 핵심입니다. 운영 환경에서 데이터를 변경하는 쿼리는 특히 신중해야 합니다.

**1. 항상 트랜잭션과 드라이 런으로 시작하라**
변경 쿼리를 실행하기 전에, 동일한 WHERE 조건을 가진 `SELECT` 문으로 영향을 받을 행을 먼저 확인하세요. 그리고 변경 작업을 트랜잭션(`BEGIN` ... `COMMIT`)으로 감싸세요. 문제가 보이면 `ROLLBACK`할 수 있습니다.
```sql
BEGIN;
-- 먼저 확인
SELECT * FROM users WHERE last_login < '2020-01-01';
-- 확인 후 실행
DELETE FROM users WHERE last_login < '2020-01-01' RETURNING id;
-- 삭제된 ID를 검토한 후
COMMIT; -- 또는 ROLLBACK
```

**2. 대량 작업은 청크로 나누라**
수백만 행을 한 번에 삭제하는 것은 트랜잭션 로그를 압도하고 시스템을 잠글 수 있습니다. 대신 작은 배치로 나누어 실행하세요.
```sql
-- 10,000개씩 삭제 (반복 실행)
DELETE FROM audit_log
WHERE created_at < NOW() - INTERVAL '1 year'
LIMIT 10000;
```

**3. 파티셔닝을 활용한 지능적 삭제**
로그 데이터처럼 시간에 따라 자연스럽게 만료되는 데이터의 경우, 월별 파티셔닝을 하고, 오래된 파티션을 통째로 `DROP`하는 것이 `DELETE`보다 수천 배 빠를 수 있습니다.

---

## 고급 패턴과 문제 해결

**OR 조건의 최적화**
여러 개의 `OR` 조건이 인덱스 사용을 방해할 때가 있습니다. 각 조건이 서로 다른 인덱스를 효율적으로 사용할 수 있다면, `UNION ALL`로 쿼리를 분리하는 것이 더 빠를 수 있습니다.
```sql
-- 단일 쿼리 (비효율적일 수 있음)
SELECT * FROM events
WHERE (type = 'LOGIN' AND user_id = 1001)
   OR (type = 'PURCHASE' AND product_id = 2002);

-- UNION ALL로 분리 (각 인덱스 활용 가능)
SELECT * FROM events WHERE type = 'LOGIN' AND user_id = 1001
UNION ALL
SELECT * FROM events WHERE type = 'PURCHASE' AND product_id = 2002;
```

**키셋 페이징**
`LIMIT 10 OFFSET 10000`과 같은 전통적인 페이징은 뒤로 갈수록 점점 더 느려집니다(10,010개의 행을 읽고 10,000개를 버리기 때문). 대신 마지막으로 본 행의 값을 기준으로 다음 페이지를 가져오는 **키셋 페이징**을 사용하세요.
```sql
-- 마지막으로 본 ordered_at='2024-11-05 10:30:00', id=1500 이후의 행
SELECT * FROM orders
WHERE (ordered_at, id) < ('2024-11-05 10:30:00', 1500)
ORDER BY ordered_at DESC, id DESC
LIMIT 10;
```

---

## 데이터베이스별 특성과 주의사항

각 데이터베이스 관리 시스템은 WHERE 절 처리에 미묘한 차이를 보입니다.
*   **PostgreSQL**: 함수 기반 인덱스, 부분 인덱스(`WHERE` 조건이 있는 인덱스)를 강력하게 지원합니다. `EXPLAIN ANALYZE`가 매우 상세한 실행 계획을 제공합니다.
*   **MySQL**: `LIKE 'prefix%'`는 인덱스를 사용할 수 있지만, 컬레이션(정렬 규칙)에 민감합니다. InnoDB의 보조 인덱스는 기본키 값을 리프 노드에 포함하므로 커버링 인덱스 효과를 내기 쉽습니다.
*   **SQL Server**: `INCLUDE` 절을 사용하여 인덱스 리프 노드에 비키 컬럼을 추가할 수 있어, 커버링 인덱스 설계가 용이합니다.
*   **Oracle**: 힌트(`/*+ INDEX(table_name index_name) */`)를 통해 옵티마이저의 실행 계획을 세밀하게 제어할 수 있습니다.

---

## 결론: WHERE 절, 단순함의 심오함

WHERE 절은 겉보기에 단순해 보이는 구문 아래에 데이터베이스 성능과 정합성의 복잡한 세계를 숨기고 있습니다. 훌륭한 WHERE 절 작성은 기술적 스킬을 넘어서는 사고 방식입니다. 그것은 데이터의 본질(3값 논리), 저장소의 물리적 구조(인덱스와 파티션), 그리고 시간의 흐름(날짜 범위)에 대한 깊은 이해를 요구합니다.

이러한 이해는 다음과 같은 실천으로 이어집니다:
1.  **정확성 수호**: NULL은 `IS NULL`로, 날짜 범위는 반열린 구간으로, 문자열 비교는 컬레이션을 고려하여 작성함으로써 미묘한 버그를 사전에 차단합니다.
2.  **성능 엔지니어링**: 인덱스가 컬럼을 순수한 형태로 볼 수 있게(SARGability) 조건을 작성하고, 복합 인덱스의 정렬 특성을 활용하며, `EXISTS`와 `IN`을 상황에 맞게 선택합니다.
3.  **운영 안전성**: 모든 데이터 변경 작업을 트랜잭션 안에서 수행하고, 실행 전에 드라이 런으로 점검하며, 대량 작업은 시스템에 부담을 주지 않는 방식으로 분할합니다.

WHERE 절을 마스터한다는 것은 단순히 빠른 쿼리를 작성하는 것이 아닙니다. 그것은 데이터와 대화하는 방식을 체화하는 것이며, 그 결과 더 견고하고, 효율적이며, 유지보수하기 쉬운 애플리케이션을 구축할 수 있는 기반을 마련하게 됩니다. 이는 데이터베이스 설계자와 개발자에게 주어진 지속적인 학습과 성찰의 여정입니다.