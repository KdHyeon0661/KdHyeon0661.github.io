---
layout: post
title: 객체지향설계 - 추상화
date: 2025-07-15 20:20:23 +0900
category: 객체지향설계
---
# 🧠 추상화 (Abstraction)

---

## 1. 추상화란?

**추상화(Abstraction)**는 **복잡한 현실 세계의 객체나 개념에서 핵심적인 속성과 기능만을 선별적으로 모델링**하는 과정입니다. 즉, **불필요한 세부 사항은 감추고, 중요한 정보만 드러내는 것**입니다.

실생활에서의 예로는, 자동차 운전자가 엔진 내부 구조나 연료 분사 방식을 몰라도, 운전대와 브레이크, 가속 페달만 조작해 운전할 수 있는 것을 생각할 수 있습니다.

---

## 2. 객체지향에서의 추상화

객체지향 프로그래밍에서 추상화는 다음 두 가지 측면으로 나눌 수 있습니다.

| 측면 | 설명 |
|------|------|
| **데이터 추상화** | 객체가 가지는 **속성(변수)** 중 중요한 것만 노출 |
| **동작 추상화** | 객체가 수행할 수 있는 **기능(메서드)** 중 핵심 동작만 표현 |

**예시**: 자동차 클래스를 만든다면, 자동차가 가지는 ‘속성’은 모델명, 연료량, 속도이고, ‘기능’은 가속, 감속, 정지, 방향 전환 등이 될 수 있습니다. 내부적으로 연료가 어떻게 연소되는지는 추상화 수준에서는 고려하지 않습니다.

---

## 3. 추상화의 목적

- **복잡성 감소**: 구현 세부 사항을 숨기고 중요한 인터페이스만 노출
- **코드 재사용성 증가**: 공통된 인터페이스를 기반으로 다양한 객체 정의 가능
- **유지보수 용이**: 변경이 필요한 부분을 캡슐화하여 수정 영향 최소화
- **의사소통 용이**: 고수준 설계를 도식화하거나 문서화할 때 개념을 단순화

---

## 4. 추상 클래스와 인터페이스

객체지향 언어에서는 추상화를 실현하기 위한 **문법적 도구**로 다음을 사용합니다.

### ✅ 추상 클래스 (Abstract Class)

- 공통된 속성과 메서드를 정의
- 일부 구현도 포함 가능
- `extends`로만 상속 가능 (단일 상속)

```java
abstract class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    abstract void sound();  // 하위 클래스에서 반드시 구현
}
```

### ✅ 인터페이스 (Interface)

- 메서드 시그니처만 정의 (자바 8 이후에는 default 메서드도 가능)
- 구현은 포함하지 않음 (또는 일부만 가능)
- 다중 구현 가능

```java
interface Drawable {
    void draw();
}

interface Colorable {
    void setColor(String color);
}
```

---

## 5. 예제: 전자기기 추상화

```java
abstract class ElectronicDevice {
    String brand;

    ElectronicDevice(String brand) {
        this.brand = brand;
    }

    abstract void turnOn();
    abstract void turnOff();
}

class Television extends ElectronicDevice {
    Television(String brand) {
        super(brand);
    }

    void turnOn() {
        System.out.println(brand + " TV 전원 ON");
    }

    void turnOff() {
        System.out.println(brand + " TV 전원 OFF");
    }
}

class Refrigerator extends ElectronicDevice {
    Refrigerator(String brand) {
        super(brand);
    }

    void turnOn() {
        System.out.println(brand + " 냉장고 전원 ON");
    }

    void turnOff() {
        System.out.println(brand + " 냉장고 전원 OFF");
    }
}
```

- `ElectronicDevice`는 추상화된 개념
- `Television`과 `Refrigerator`는 구체적인 구현
- 클라이언트는 `ElectronicDevice` 타입만 알고 있어도 다양한 장치를 제어 가능

---

## 6. 추상화 vs 캡슐화

| 항목 | 추상화 (Abstraction) | 캡슐화 (Encapsulation) |
|------|----------------------|--------------------------|
| 목적 | 복잡성을 감추고 핵심만 표현 | 내부 구현을 감추고 데이터 보호 |
| 초점 | **무엇(What)**을 하는가 | **어떻게(How)** 구현되었는가 |
| 도구 | 추상 클래스, 인터페이스 | 접근 제어자(private, public 등) |
| 관계 | 서로 보완하며 객체지향을 구성 |

---

## 7. 추상화의 실제 활용

- API 설계: 라이브러리 사용자에게 필요한 기능만 제공
- 프레임워크 구성: 상위 모듈은 하위 구현을 모르고 동작
- SOLID 원칙: Interface Segregation Principle, Dependency Inversion Principle 구현에 필수

---

## 8. 요약

| 특징 | 설명 |
|------|------|
| 복잡한 시스템 단순화 | 중요한 기능만 사용자에게 노출 |
| 구현 은닉 | 내부 동작은 감추고 외부 동작만 제공 |
| 재사용성과 확장성 증가 | 공통 동작을 추상화하면 다양한 구현 가능 |
| 객체지향 4대 특성 중 하나 | 캡슐화, 상속, 다형성과 함께 핵심 구성 |

---

## ✅ 마무리

추상화는 객체지향 설계에서 **모듈화**, **재사용성**, **유지보수성**을 크게 향상시킵니다. 핵심 개념을 추출하고, 구현은 나중에 정의함으로써 **변화에 유연하게 대응**할 수 있는 소프트웨어 구조를 만들 수 있습니다.
