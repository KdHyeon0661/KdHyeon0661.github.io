---
layout: post
title: 객체지향설계 - 추상화
date: 2025-07-15 20:20:23 +0900
category: 객체지향설계
---
# 추상화 (Abstraction)

## 추상화란?

**추상화(Abstraction)**는 **복잡한 현실에서 핵심 속성·행동만 선별해 모델링**하고, **불필요한 세부는 감추는** 과정이다. 사용자는 **“무엇(What)”**에 집중하고 **“어떻게(How)”**는 숨는다.

실생활 비유: 운전자는 엔진 분사 제어를 몰라도 **핸들/가속/브레이크**만으로 운전한다.

---

## 객체지향에서의 추상화 — 데이터/동작의 두 축

| 축 | 목표 | 예 |
|---|---|---|
| **데이터 추상화** | 본질 속성만 노출 | 자동차의 `속도`, `연료량` (연소 로직은 숨김) |
| **동작 추상화** | 핵심 행위만 표면에 | `accelerate()`, `brake()` (점화 타이밍은 숨김) |

```java
// 동작/데이터 추상화를 모두 반영
interface Vehicle {
    // 핵심 동작
    void accelerate();
    void brake();
    void turnLeft();
    void turnRight();

    // 관찰 필요한 최소 속성(예: 텔레메트리)
    int currentSpeed();
}
```

---

## 추상화의 목적 (보강)

- **복잡성 감소**: 외부 계약만 드러내고 내부 구현은 교체 가능.
- **재사용·확장성**: 공통 인터페이스 위에 다양한 구현.
- **유지보수성**: 변경 파급을 **계약 경계**에서 차단.
- **의사소통**: 설계/문서/다이어그램에서 개념 단순화.

---

## 추상화 vs 캡슐화 (명확히 구분)

| 항목 | 추상화 (Abstraction) | 캡슐화 (Encapsulation) |
|---|---|---|
| 초점 | **무엇**을 제공할지 선정 | **어떻게**를 감추어 보호 |
| 도구 | 추상 클래스/인터페이스, 포트/퍼사드 | 접근 제어자, 가시성, 모듈 경계 |
| 관점 | 모델링 **선택** | 구현 **은닉** |
| 관계 | 서로 보완: “선택하고” → “숨긴다” | 추상화로 표면을 줄여 캡슐화 효과↑ |

---

## 추상화를 위한 언어 도구

### 추상 클래스 (Abstract Class)

- **공통 상태/골격/훅** 제공(상태 동반 공통 로직에 적합).
- 단일 상속.

```java
abstract class ElectronicDevice {
    protected final String brand;
    protected ElectronicDevice(String brand){ this.brand = brand; }
    abstract void turnOn();
    abstract void turnOff();
    void selfTest(){ System.out.println(brand + " self test"); } // 공통 구현
}
```

### 인터페이스 (Interface)

- **역할/계약**을 정의(수평적 기능 조합에 적합).
- 다중 구현, Java 8+ `default`로 일부 구현 가능(상태 없이).

```java
interface Switchable { void turnOn(); void turnOff(); }
interface Dimmable  { void setBrightness(int level); }
```

> 실무: **계약은 인터페이스**, **공통 골격은 추상 클래스**, **조합은 합성(Strategy/Adapter/Bridge)**.

---

## 예제: 전자기기 추상화(확장)

초안의 예시를 **역할/골격** 관점으로 보강한다.

```java
// 역할(계약)
interface Device extends Switchable { String brand(); }

abstract class BaseDevice implements Device {
    private final String brand;
    protected BaseDevice(String brand){ this.brand = brand; }
    public String brand(){ return brand; }
    public void selfTest(){ System.out.println(brand + " self test"); }
}

final class Television extends BaseDevice {
    public Television(String brand){ super(brand); }
    public void turnOn(){  System.out.println(brand() + " TV ON"); }
    public void turnOff(){ System.out.println(brand() + " TV OFF"); }
}

final class Refrigerator extends BaseDevice {
    public Refrigerator(String brand){ super(brand); }
    public void turnOn(){  System.out.println(brand() + " FRIDGE ON"); }
    public void turnOff(){ System.out.println(brand() + " FRIDGE OFF"); }
}
```

**핵심**: 클라이언트는 `Device`만 의존 → 다양한 기기를 동일 방식으로 제어.

---

## 추상화 레벨 — 어디에서 무엇을 감출까?

```
[도메인(개념)] → [유스케이스/서비스] → [모듈/API] → [시스템/인프라]
      |               |                   |               |
  용어/경계       핵심 절차/정책        공개 표면      외부 연동 숨김
```

- **도메인**: 용어·엔티티·값 객체(불변식)
- **유스케이스**: 핵심 시나리오(승인/정산/환불)
- **API/모듈**: 최소 공개 메서드(퍼사드/포트)
- **시스템**: 외부 연동은 어댑터 뒤로 숨김(헥사고날)

---

## 모델링 절차 — 실무 체크리스트

1) **유스케이스 한 문장**: “사용자가 X하면 시스템은 Y를 보장한다.”
2) 문장을 **역할 인터페이스**로 만든다(핵심 행위만).
3) **불변식/전제/사후**를 적어 의미를 고정한다.
4) 공통 로직/상태는 **추상 기본 클래스**로 내린다.
5) 외부 연동은 **포트/어댑터**로 격리한다.
6) 공개 표면을 최소화(퍼사드).
7) **계약 테스트**로 구현 교체 가능성을 검증한다.

---

## 계약 기반 추상화 — 불변식/전제/사후

계약으로 **추상화의 의미**를 정확히 고정한다.

```java
interface BankAccount {
    /**
     * Pre: amount > 0
     * Post: balance() == old(balance()) + amount
     * Inv:  balance() >= 0
     */
    void deposit(int amount);

    /**
     * Pre: amount > 0 && balance() >= amount
     * Post: balance() == old(balance()) - amount
     * Inv:  balance() >= 0
     */
    void withdraw(int amount);

    int balance();
}
```

### & 추상화 함수

- **표현 불변식 `RI(r)`**: 내부 표현 `r`이 **허용 상태**임을 보장.
- **추상화 함수 `AF(r)`**: 내부 표현 `r` → 추상 상태로 **의미 부여**.

$$
\forall r.\ RI(r) \Rightarrow \text{메서드 후에도 } RI(r') \land \text{의미가 } AF(r) \to AF(r') \text{로 일관}
$$

---

## 헥사고날(포트/어댑터)로 추상화 경계 만들기

```
[UseCase] → (PaymentPort) → [Adapter: Kakao/Card] → 외부 API
```

```java
// Port(역할): 추상화 경계
public interface PaymentPort {
    // Pre: amount > 0, Post: returns txId, idempotent for same key
    String pay(int amount, String idempotencyKey);
}

public final class Checkout {
    private final PaymentPort payment;
    public Checkout(PaymentPort payment){ this.payment = payment; }
    public String place(int amount, String key){ return payment.pay(amount, key); }
}
```

- **추상화 포인트**: 유스케이스는 **포트**에만 의존 → 외부 교체/확장 자유.

---

## 누수/과잉 추상화 — 안티패턴과 리팩토링

| 냄새 | 문제 | 리팩토링 |
|---|---|---|
| **누수 추상화** | 내부 세부(재시도/지연/DB키)가 API로 새어 나옴 | 퍼사드/포트로 **용어 정제**, 내부 결정은 숨김 |
| **Kitchen-sink** API | 핵심과 무관한 메서드 과다 | 핵심 행위만 노출, 나머지는 내부/별도 서비스 |
| **유틸 정적 함수 범람** | 역할 부재, 절차적 조합 | **역할 인터페이스** 도입, 합성으로 연결 |
| **과잉 추상화(YAGNI 위반)** | 필요 이상 계층/인터페이스 | **지연 추상화**: 필요 시점에 도입 |

---

## 테스트로 추상화 검증 — 계약/속성 기반

### 계약 테스트(공유 테스트)

역할 계약을 **공유 테스트**로 고정, 구현 교체에도 의미 유지.

```java
abstract class PaymentContract {
    protected abstract PaymentPort sut();

    @org.junit.jupiter.api.Test
    void paysPositive() {
        var tx = sut().pay(1000, "k1");
        org.junit.jupiter.api.Assertions.assertNotNull(tx);
    }
}
```

### 속성 기반(Property-based)

불변식 자동 검증(예: `balance >= 0`는 모든 시퀀스에서 유지).
도구: jqwik(Java), QuickCheck(Haskell), Hypothesis(Python) 등.

---

## 지표로 보는 추상화 품질

공개 표면 크기 \(M\), 클라이언트 수 \(N\), 변경 빈도 \(F\), 결합 계수 \(C\):

$$
\text{ChangeRisk} \approx M \cdot N \cdot F \cdot C
$$

- 추상화로 **\(M\)**(공개 메서드/DTO 필드) 감소
- 포트/어댑터로 **\(C\)**(외부 결합) 감소
- 코어/서포팅 분리(DDD)로 **\(F\)** 분산

추가 지표:
- **PSS**(Public Surface Size)↓, **CBO**(Coupling)↓, **LCOM**(응집)↓, **IC**(Invariant Coverage, 불변식 테스트 덮음)↑

---

## 실전 시나리오 — “결제 추상화” 단계적 정제

### 나쁜 시작(누수)

```java
class Checkout {
    // 외부 세부가 파라미터로 누수됨
    String payWithKakao(int amount, String apiKey, int retry, long timeoutMs) { /* ... */ return "TX"; }
}
```

### 퍼사드로 핵심만 노출

```java
final class CheckoutFacade {
    private final PaymentPort payment;
    CheckoutFacade(PaymentPort payment){ this.payment = payment; }

    public String placeOrder(int amount, String idempotencyKey){
        return payment.pay(amount, idempotencyKey); // 핵심만
    }
}
```

- 재시도/타임아웃/키 관리 등은 **Adapter 내부**로 이동.

---

## 언어별 추상화 스냅샷

### Kotlin — sealed로 닫힌 계층 추상화

```kotlin
sealed interface PaymentResult
data class Ok(val txId: String): PaymentResult
data class Fail(val reason: String): PaymentResult

interface PaymentPort { fun pay(amount: Int, key: String): PaymentResult }
```
- `sealed`로 **귀결 합집합**을 제한 → **완전성 검사**(when)로 안전.

### C# — 인터페이스 + 추상 기본 클래스

```csharp
public interface ISwitchable { void TurnOn(); void TurnOff(); }

public abstract class DeviceBase : ISwitchable {
    protected readonly string Brand;
    protected DeviceBase(string brand){ Brand = brand; }
    public abstract void TurnOn();
    public abstract void TurnOff();
    public void SelfTest() => Console.WriteLine($"{Brand} self test");
}
```

### Python — `abc`와 프로토콜

```python
from abc import ABC, abstractmethod
class Payment(ABC):
    @abstractmethod
    def pay(self, amount: int, key: str) -> str: ...
```

---

## API 설계 가이드 — “작게 드러내고 크게 숨기기”

- **퍼사드**: 유스케이스 문장 1개 ↔ 퍼사드 메서드 1개
- **포트/어댑터**: 외부 연동은 역할 인터페이스로 추상
- **DTO 최소화**: 의미 있는 값 객체로 모델링(원시 타입 남용 금지)
- **버전 진화**: 인터페이스 변경 대신 ① `default` 추가 ② 새 인터페이스 ③ 새 퍼사드

---

## 케이스: 좌표/도형 추상화(역할-구현 분리)

```java
interface Shape { double area(); }             // 동작 추상화
record Circle(double r) implements Shape { public double area(){ return Math.PI*r*r; } }
record Rectangle(double w, double h) implements Shape { public double area(){ return w*h; } }

final class Renderer {                         // 퍼사드: 핵심만
    void draw(Shape s){ /* ... */ }
}
```

- 클라이언트는 `Shape`에만 의존 → **새 도형 추가**는 기존 코드 변경 없이 확장(OCP).

---

## 미니 UML(ASCII)

```
[Client]
   |
   v
(CheckoutFacade) --uses--> (PaymentPort) <--implements-- [KakaoAdapter]
                                                  \
                                                   \-- [CardAdapter]
```

- **추상화 경계**가 바뀌지 않는 한, 어댑터 교체는 자유.

---

## 체크리스트

- [ ] 유스케이스 한 문장 ↔ 퍼사드 1개인가?
- [ ] 공개 표면(PSS)이 **최소**인가? (게터/설정자 남용 X)
- [ ] 계약(Pre/Post/Inv)이 문서/테스트로 고정됐는가?
- [ ] 외부 연동은 **포트/어댑터**로 격리됐는가?
- [ ] 도메인 **핵심/지원**이 분리됐는가(DDD)?
- [ ] 누수/과잉 추상화 냄새가 없는가?
- [ ] 속성/계약 테스트로 **불변식**이 덮였는가(IC↑)?

---

## 요약

| 특징 | 핵심 정리 |
|---|---|
| 복잡성 축소 | 중요한 기능만 노출, 내부는 감춤 |
| 경계 명확 | 퍼사드/포트로 경계 설정, 변경 파급 통제 |
| 재사용/확장 | 공통 인터페이스 위에 다양한 구현 |
| 품질 확보 | 계약(불변식)과 테스트(계약/속성)로 의미 고정 |

---

## 결론

추상화는 단지 “숨기는 것”이 아니라 **무엇을 드러낼지 선택**하는 **모델링의 기술**이다.
**계약으로 의미를 고정**하고, **퍼사드/포트로 경계**를 세워 **작은 공개 표면 + 강한 불변식**을 달성하라. 그러면 시스템은 **변화에 강하고 테스트 가능한 구조**가 된다.
