---
layout: post
title: 데이터 통신 - Error Detection and Correction (1)
date: 2024-07-27 18:20:23 +0900
category: DataCommunication
---
# Error Detection and Correction (1)

## 10.1 Introduction

### 10.1.1 Types of Errors (오류 유형)

현실의 채널은 잡음·간섭·지터로 인해 비트가 뒤바뀔 수 있다. 대표 오류 모델은 다음과 같다.

| 구분 | 정의 | 특징 | 예시 |
|---|---|---|---|
| **단일 비트 오류** | 코드워드에서 한 비트만 반전 | 드묾(고립성), 검출 쉬움 | 전선 상의 순간적 펄스 |
| **다중 비트 오류** | 독립적으로 여러 비트 반전 | 랜덤 분산 형태 | 백색 잡음 유사 환경 |
| **버스트 오류** | 연속 구간 내에서 다수 비트 반전 | 현실에서 흔함(충돌, 페이딩) | 이더넷 충돌, 무선 페이딩 |
| **패킷 손실/삽입** | 전체 프레임 드롭/중복 | 상위계층에서 재전송 필요 | Wi-Fi 재전송 전 패킷 드롭 |

모델링:
- **BSC(Binary Symmetric Channel)**: 각 비트가 확률 $$p$$ 로 뒤바뀜.
- **Gilbert–Elliott**: **좋은/나쁜** 상태를 오가며 버스트를 재현.

**버스트 길이** $$L$$: 첫 오류 비트부터 마지막 오류 비트까지 구간 길이(중간 정상 비트 포함). CRC는 보통 다항 차수 $$r$$ 미만의 버스트에 대해 강력한 검출 능력을 제공한다.

---

### 10.1.2 Redundancy (중복)

오류를 **알아채거나(Detection)** **고치려면(Correction)**, 송신자는 **여분의 비트**를 붙인다.

- **코드 길이**: $$n$$ (원본 $$k$$비트 + 패리티 $$r$$비트)  
- **코드율**: $$R=\dfrac{k}{n}$$ (낮을수록 중복↑, 오버헤드↑)  
- **여분비(오버헤드)**: $$\dfrac{r}{n}$$

중복 설계의 핵심은 **요구 신뢰도·지연·대역폭** 사이의 절충이다.  
예: 이더넷 프레임은 **CRC-32(32비트)** 한 조각으로 고속 환경에서 낮은 미검출 확률과 빠른 하드웨어 구현을 얻는다.

---

### 10.1.3 Detection versus Correction (검출 vs 정정)

- **오류 검출(ED, Error Detection)**: 수신자가 “이 프레임이 이상하다”를 알아차림 → **ARQ(재전송)**으로 복구.  
  - 장점: 오버헤드 적음, 하드웨어 단순.  
  - 단점: 왕복 지연(RTT) 증가, 혼잡 시 재전송 폭증 가능.
- **오류 정정(FEC, Forward Error Correction)**: 수신자가 **재전송 없이** 일부 오류를 **스스로 고침**.  
  - 장점: 고지연/고손실(위성·5G)에서 유리, 스트리밍에 적합.  
  - 단점: 중복↑ 계산량↑.
- **혼합(HARQ)**: ED(예: CRC) + FEC(예: 블록/컨볼루션/LDPC)를 결합. 실패 시 재전송(소프트 결합)으로 성능 향상.

거리 관점 요약 (모든 블록 코드에 공통):
- **최소 해밍거리** $$d_{\min}$$ 를 가지는 코드는  
  - **검출**: 최대 $$d_{\min}-1$$ 개 비트 오류를 항상 검출  
  - **정정**: 최대 $$t=\left\lfloor \dfrac{d_{\min}-1}{2}\right\rfloor$$ 개 비트 오류를 정정

---

### 10.1.4 Coding (코딩의 형식·표현)

- **코드워드**: 길이 $$n$$ 의 비트열. 원본 $$k$$비트에 **패리티 $$r=n-k$$** 를 부가하여 구성.
- **선형 블록 코드**: 모든 코드워드 집합이 선형 부분공간을 이룸.
  - **생성행렬** $$G\in \mathbb{F}_2^{k\times n}$$  
    $$\mathbf{c}=\mathbf{m}G$$
  - **패리티검사행렬** $$H\in \mathbb{F}_2^{r\times n}$$ : 모든 유효 코드워드에 대해 $$H\mathbf{c}^\top=\mathbf{0}$$
  - **신드롬** $$\mathbf{s}=H\mathbf{r}^\top$$ . $$\mathbf{s}\neq \mathbf{0}$$ 이면 **오류 검출**.
- **다항식 표현(CRC에서 핵심)**: 비트열 ↔ 다항식 $$M(x)$$ (계수는 $$\{0,1\}$$). 생성다항식 $$G(x)$$ 로 나누어 **나머지** $$R(x)$$ 를 붙인다.

---

## 10.2 Block Coding — Error Detection (블록 코딩에 의한 오류 검출)

블록 코딩은 “한 블록(패킷/프레임)”마다 **독립적**으로 중복을 붙인다. 검출에 특화된 대표 기법을 정리한다.

### 10.2.1 단일 패리티 비트(Parity)

- **원리**: 전체(또는 바이트·필드) 비트 합의 **짝/홀수성**을 맞춘다.  
  - 짝수 패리티: 코드워드의 1의 개수가 **짝수**가 되도록 마지막에 1비트 추가.  
  - 홀수 패리티: 반대.
- **검출력**: 모든 **홀수 개수**의 비트 오류 검출.  
  - 2개·4개 등 **짝수 개 오류**는 **미검출** 가능.

짝수 패리티 정의:
$$
p=\Big(\sum_{i=1}^{k} m_i\Big)\bmod 2
$$

예제(짝수 패리티)  
데이터 $$\mathbf{m}=1011010$$ (1의 개수 = 4) → 패리티 0 → 코드워드 $$1011010\underline{0}$$.  
전송 중 2비트 반전 → 여전히 1의 개수 짝수 → **미검출** 가능(한계 사례).

> 장점: 오버헤드 1비트, 구현 단순. 단점: 버스트/짝수 오류에 취약.

---

### 10.2.2 2차원(블록) 패리티

- **원리**: 데이터 블록을 행렬로 배치, **행·열 패리티**를 각각 부여. 마지막에 전체 패리티 추가 가능.
- **검출력**: 대부분의 2비트 이상 오류를 검출, **단일 비트 오류는 위치까지 특정**(행/열 교차점).

단일 오류 위치 특정(개념):
$$
\text{RowParity}_i\neq \text{expected},\ \text{ColParity}_j\neq \text{expected}
\ \Rightarrow\ \text{error at }(i,j)
$$

도표 예시(개념):

```
원 데이터 4×4:
1 0 1 1 | 행패리티 p1
0 1 0 0 | p2
1 1 0 1 | p3
0 0 1 0 | p4
---------
열패  q1 q2 q3 q4  전체패리티 p_all
```

---

### 10.2.3 Checksum(체크섬) — 1’s Complement Sum

- **원리**: 고정 길이 워드(예: 16비트)를 **1의 보수 덧셈**으로 모두 합산 후 **보수**를 취해 전송.
- **검증 규칙**:
  $$
  S=\bigoplus_{i=1}^{N} W_i\quad(\text{1의 보수 합, 캐리 폴딩 포함}),\qquad
  C=\sim S
  $$
  수신 시
  $$
  \bigoplus_{i=1}^{N} W_i\ \oplus\ C=\text{all-ones}
  $$
- **한계(직관)**:
  $$
  \Delta W_1+\Delta W_2=0\ \ (\text{1의 보수 합에서 상쇄})\ \Rightarrow\ \text{미검출 가능}
  $$

간단 수치 예(16비트):  
$$W_1=0x0f0f,\ W_2=0xf0f0,\ W_3=0x0001$$  
합산·캐리 폴딩 후 $$S=0x0000,\ C=0xffff$$.

---

### 10.2.4 CRC(Cyclic Redundancy Check) — 다항식 기반 블록 오류 검출의 표준

**송신 절차**
$$
T(x)=M(x)x^r+R(x),\qquad R(x)=\Big(M(x)x^r\Big)\bmod G(x)
$$

**수신 검증**
$$
T(x)\bmod G(x)=0\ \Rightarrow\ \text{정상},\qquad \neq 0\ \Rightarrow\ \text{오류}
$$

**검출 보장(요약)**
$$
\begin{aligned}
&\text{단일 비트 오류: 항상 검출}\\
&\text{이중 비트 오류: 적절한 }G(x)\text{에서 항상 검출}\\
&\text{홀수 개 오류: }(x+1)\mid G(x)\ \Rightarrow\ \text{항상 검출}\\
&\text{버스트 오류 길이 }<r\ \Rightarrow\ \text{항상 검출}\\
&\text{무작위 오류 미검출 확률}\approx 2^{-r}
\end{aligned}
$$

소형 손계산 예: $$G(x)=x^3+x+1\ (1011),\ r=3,\ M=11010011101100$$  
$$
R(x)=\big(M(x)x^3\big)\bmod G(x)=x^2\ (100),\quad
T=M\|R=11010011101100\underline{100}
$$
수신에서 $$T(x)\bmod G(x)=0$$ 이면 통과.

---

### 10.2.5 Hamming Distance 관점

선형 블록 코드의 최소 해밍거리 $$d_{\min}$$:
$$
\text{항상 검출 가능한 최대 오류 수}=d_{\min}-1
$$
예: 단일 패리티의 $$d_{\min}=2\Rightarrow 1$$ 비트 오류까지 확정 검출.  
CRC는 적절한 $$G(x)$$ 선택으로 특정 길이 미만 버스트에 대해 사실상의 거리 보장을 제공.

---

### 10.2.6 Syndrome(신드롬)으로 보는 검출 절차

수신 $$\mathbf{r}=\mathbf{c}+\mathbf{e}$$ 에 대해
$$
\mathbf{s}=H\mathbf{r}^\top=H(\mathbf{c}+\mathbf{e})^\top=H\mathbf{e}^\top
$$
$$
\mathbf{s}=\mathbf{0}\Rightarrow \text{검출 실패},\qquad
\mathbf{s}\neq\mathbf{0}\Rightarrow \text{오류 검출}
$$
CRC의 나머지도 **신드롬**으로 해석 가능:
$$
\text{Remainder}(T(x),G(x))\equiv \text{Syndrome}
$$

---

### 10.2.7 실전 비교: 패리티 · 체크섬 · CRC

| 항목 | 단일 패리티 | 2D 패리티 | 체크섬(1’s comp.) | **CRC** |
|---|---|---|---|---|
| 오버헤드 | 매우 작음 | 작음(행·열) | 중간(워드 단위) | **고정 $$r$$비트** |
| 검출력(랜덤) | 홀수 오류 | 대부분 2비트 이상 | 중간 | **매우 강력** |
| 버스트 대응 | 약함 | 중간 | 약~중 | **$$r$$ 미만 버스트 전부 검출** |
| 구현 | 매우 쉬움 | 쉬움 | 쉬움 | **하드웨어/테이블 최적화** |
| 사용 | 간단 링크 | 저장/전송 단순 보호 | IP/TCP/UDP 헤더 | **이더넷·스토리지·산업표준** |

---

### 10.2.8 사례로 보는 설계 철학

1) **이더넷(IEEE 802.3)**: 프레임 말단 CRC-32 하나로 강한 검출 → 상위 **ARQ(TCP)** 복구.  
2) **IP/TCP/UDP 헤더**: 16비트 체크섬으로 **헤더 무결성** 위주. 페이로드 검출은 링크 CRC·상위 MAC에 위임.  
3) **무선(Wi-Fi/5G)**: 링크에서 **CRC+FEC** , 실패 시 **HARQ** 재전송로 스루풋/지연 균형.

---

## 부록 A. 소형 수치 예제(소스코드 없이)

**A-1) 짝수 단일 패리티: 미검출**  
데이터 $$m=11110000$$ (1의 개수 4) → 패리티 0 → 코드워드 $$111100000$$.  
전송 중 두 비트 반전 → 총 1의 개수 짝수 유지 → **미검출**.

**A-2) 2D 패리티: 단일 오류 위치 특정**  
(2행,3열) 비트 반전 시 **2행 패리티·3열 패리티**만 깨짐 → 교차점에서 오류 식별.

**A-3) 체크섬 직관**  
$$W_1=0xffff,\ W_2=0x0001\Rightarrow$$ 1의 보수 합(캐리 폴딩) $$=0xffff$$.  
상호 보상 오류는 **통과** 가능.

**A-4) CRC 나눗셈**  
위 예와 같이 $$G=1011,\ r=3,\ M=11010011101100$$ → $$R=100,\ T=M\|R$$, 수신에서 $$T\bmod G=0$$ 판정.

---

## 부록 B. “검출만”으로 충분한가? — 시스템 판단 가이드

- **RTT 짧고 재전송 비용 낮음**: **검출+ARQ**(데이터센터 이더넷).  
- **RTT 큼/재전송 비쌈**: **FEC 혼용**(위성, 이동통신 무선구간).  
- **보안·무결성 중첩**: 링크 **CRC**(전송 오류) + 전송 **ARQ**(복구) + **TLS/AEAD**(변조 방지).

---

## 결론

- **중복은 신뢰도의 대가**: $$R=k/n$$ 이 낮을수록 검출·정정 성능↑, 비용(대역폭·지연·연산)↑.  
- **해밍거리**는 보장 성능의 핵심: **검출** $$d_{\min}-1$$, **정정** $$\left\lfloor (d_{\min}-1)/2 \right\rfloor$$.  
- **CRC**는 버스트 환경·고속 구현·낮은 미검출 확률을 동시에 만족해 블록 오류 **검출의 사실상 표준**.  
- 실제 스택은 **링크에서 CRC** → **전송에서 ARQ** → 필요 시 **FEC/HARQ** 로 보강하는 **계층적 설계**를 따른다.