---
layout: post
title: DB 심화 - 소트 수행 원리
date: 2025-11-21 19:25:23 +0900
category: DB 심화
---
# Oracle SQL 소트(Sort) 수행 원리와 튜닝

> **학습 목표**
> - **소트가 언제, 왜 발생하는지** 이해하기(ORDER BY, GROUP BY, DISTINCT, 윈도우 함수 등)
> - **메모리 내 소트(PGA)**와 **디스크 스필(TEMP)**의 작동 원리 파악하기
> - **소트 성능을 정량적으로 측정하고 분석하는 방법** 익히기
> - **실전에서 소트를 최적화하는 체계적인 접근법** 습득하기

---

## 소트가 발생하는 주요 상황

데이터베이스에서 소트(정렬) 연산은 다양한 상황에서 발생하며, 각각의 경우에 최적화 기회가 존재합니다.

| 발생 지점 | 설명 | 최적화 가능성 |
|-----------|------|---------------|
| **ORDER BY** | 결과를 특정 순서로 정렬 | 인덱스 활용, Top-N 최적화 |
| **GROUP BY** | 그룹화를 위한 정렬(해시 집계로 대체 가능) | 해시 집계로 변경 |
| **DISTINCT** | 중복 제거를 위한 정렬 | EXISTS나 윈도우 함수로 대체 가능 |
| **윈도우 함수** | `OVER(PARTITION BY ... ORDER BY ...)` | 인덱스 활용, 파티션 크기 최적화 |
| **집합 연산** | `UNION`, `INTERSECT`, `MINUS` | `UNION ALL` 사용 가능 여부 검토 |
| **Sort-Merge Join** | 조인 입력을 정렬 | NL Join이나 Hash Join으로 대체 |

**핵심 원칙**: 옵티마이저는 가능한 경우 **인덱스를 활용**하여 소트를 생략하려 합니다. 예를 들어 `ORDER BY` 절의 컬럼 순서와 방향이 인덱스와 일치하면 소트가 제거될 수 있습니다.

---

## 소트의 내부 작동 원리: PGA에서 TEMP까지

### 1. 메모리 내 소트 (Optimal Mode)
소트 연산은 먼저 **PGA(Program Global Area)**의 작업 영역(Workarea)에서 시도됩니다. 데이터가 메모리에 모두 담길 수 있을 때:
- **퀵소트(Quick Sort)**나 **힙소트(Heap Sort)** 알고리즘 사용
- **TEMP 디스크 I/O가 전혀 발생하지 않음**
- 실행계획의 `Note` 섹션에 `Workarea Executions: Optimal`로 표시

### 2. 디스크 스필 소트 (One-Pass / Multi-Pass Mode)
데이터가 PGA 작업 영역보다 클 경우, **외부 정렬(External Sort)** 알고리즘이 작동합니다:

```
1. Run 생성 단계
   ┌─────────────────────────────────────┐
   │ 1. 메모리 크기만큼 데이터 읽기      │
   │ 2. 메모리 내 정렬 수행              │
   │ 3. 정렬된 청크(Run)을 TEMP에 기록  │
   └─────────────────────────────────────┘
         ↓ (여러 번 반복)
2. 병합 단계
   ┌─────────────────────────────────────┐
   │ 1. 여러 Run을 동시에 읽기(k-way)   │
   │ 2. 병합 정렬 수행                   │
   │ 3. 최종 결과 생성                   │
   └─────────────────────────────────────┘
```

**One-Pass vs Multi-Pass**:
- **One-Pass**: 한 번의 병합으로 모든 Run을 처리 가능
- **Multi-Pass**: Run이 너무 많아 여러 번의 병합이 필요 → I/O 비용 급증

**병합 패스 수 공식**:
```
패스 수 ≈ ceil(log_k(런_개수))
```
여기서 `k`는 한 번에 병합할 수 있는 Run 개수로, 사용 가능한 메모리/버퍼 수에 비례합니다.

### 3. Top-N 소트 (STOPKEY 최적화)
`ORDER BY ... FETCH FIRST N ROWS` 또는 `ROWNUM <= N`과 같은 Top-N 쿼리의 경우:
- **전체 정렬 대신 N 크기의 힙(Heap) 유지**
- **대량 데이터에서도 빠른 응답 시간** 보장
- 실행계획에 `SORT ORDER BY STOPKEY`로 표시

---

## 소트 성능 측정과 분석 방법

### 실전 측정 도구 모음

**1. 세션 통계를 통한 측정**
```sql
-- 소트 관련 통계 조회
SELECT 
    sn.name AS 통계명,
    ms.value AS 값
FROM 
    v$mystat ms 
    JOIN v$statname sn ON sn.stat# = ms.stat#
WHERE 
    sn.name IN (
        'sorts (memory)',        -- 메모리 내 소트 횟수
        'sorts (disk)',          -- 디스크 스필 소트 횟수
        'workarea executions - optimal',
        'workarea executions - onepass',
        'workarea executions - multipass',
        'session pga memory',    -- 현재 PGA 사용량
        'session pga memory max' -- 최대 PGA 사용량
    )
ORDER BY sn.name;
```

**2. Workarea 상태 확인**
```sql
-- SQL별 워크에어리어 사용 현황
SELECT 
    sql_id,
    operation_type,
    policy,
    estimated_optimal_size/1024/1024 AS "최적 크기(MB)",
    estimated_onepass_size/1024/1024 AS "1패스 크기(MB)",
    last_memory_used/1024/1024 AS "실제 사용(MB)",
    number_passes AS 패스수,
    tempseg_size/1024/1024 AS "TEMP 사용(MB)"
FROM v$sql_workarea
WHERE operation_type LIKE 'SORT%'
ORDER BY tempseg_size DESC NULLS LAST;
```

**3. TEMP 공간 사용 현황 모니터링**
```sql
-- 현재 세션의 TEMP 사용량
SELECT 
    s.sid,
    s.serial#,
    t.sql_id,
    t.segtype AS 세그먼트_타입,
    t.blocks * ts.block_size/1024/1024 AS "사용량(MB)",
    t.tablespace AS 테이블스페이스
FROM 
    v$tempseg_usage t
    JOIN v$session s ON s.saddr = t.session_addr
    JOIN dba_tablespaces ts ON ts.tablespace_name = t.tablespace
WHERE s.sid = SYS_CONTEXT('USERENV','SID');
```

**4. 대기 이벤트 분석**
```sql
-- TEMP I/O 관련 대기 이벤트
SELECT 
    event AS 대기_이벤트,
    total_waits AS 총_대기_횟수,
    time_waited AS 대기_시간_ms,
    average_wait AS 평균_대기_시간_ms
FROM v$session_event
WHERE sid = SYS_CONTEXT('USERENV','SID')
  AND event LIKE '%temp%';
```

**5. 실행계획 상세 분석**
```sql
-- 마지막 실행 쿼리의 상세 계획
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, NULL, 'ALLSTATS LAST +NOTE +ALIAS'
));
```
**중요 체크포인트**:
- `TempSpc` 항목 확인 (TEMP 사용량 표시)
- `Starts` 값이 1인지 확인 (여러 번 수행되지 않았는지)
- `A-Rows`로 실제 처리 행 수 확인

---

## 메모리 관리: PGA와 Workarea

### 핵심 파라미터 이해
```sql
-- 자동 메모리 관리 확인
SHOW PARAMETER workarea_size_policy;   -- AUTO 권장
SHOW PARAMETER pga_aggregate_target;   -- 전체 PGA 예산
SHOW PARAMETER pga_aggregate_limit;    -- PGA 상한선
```

**자동 메모리 관리(AUTO)의 장점**:
- 데이터베이스가 전체 부하를 고려해 동적으로 메모리 할당
- 소트/해시 작업에 필요한 메모리를 상황에 맞게 조정
- MANUAL 모드(`sort_area_size`)는 더 이상 권장되지 않음

**PGA 튜닝 어드바이스 활용**:
```sql
-- PGA 크기 조정에 대한 어드바이스
SELECT 
    pga_target_for_estimate/1024/1024/1024 AS "PGA 크기(GB)",
    estd_pga_cache_hit_percentage AS "예상 캐시 적중률(%)",
    estd_overalloc_count AS "예상 오버할로우 횟수"
FROM v$pga_target_advice
ORDER BY pga_target_for_estimate;
```

---

## 실전 튜닝 사례 연구

### 사례 1: 대용량 ORDER BY 최적화

**문제 상황**: 100만 건 이상의 데이터를 `ORDER BY` 할 때 TEMP 스필 발생
```sql
-- Before: 대량 데이터 정렬로 TEMP I/O 발생
SELECT /*+ MONITOR */ *
FROM 대용량_테이블
ORDER BY 정렬_컬럼 DESC;
```

**해결 방안 1: 인덱스 활용**
```sql
-- 인덱스 생성 (정렬 방향 일치)
CREATE INDEX idx_정렬_내림차순 
ON 대용량_테이블(정렬_컬럼 DESC);

-- 인덱스 힌트 사용
SELECT /*+ INDEX_DESC(t idx_정렬_내림차순) */ *
FROM 대용량_테이블 t;
-- 실행계획: INDEX FULL SCAN DESCENDING → 소트 제거
```

**해결 방안 2: Top-N 패턴 적용**
```sql
-- 실제 필요한 상위 N개만 조회
SELECT *
FROM 대용량_테이블
ORDER BY 정렬_컬럼 DESC
FETCH FIRST 100 ROWS ONLY;
-- 실행계획: SORT ORDER BY STOPKEY → 부분 정렬
```

**해결 방안 3: 파티셔닝 활용**
```sql
-- 데이터를 사전에 파티셔닝하여 파티션 내 정렬
SELECT *
FROM (
    SELECT /*+ PARALLEL(4) */ *
    FROM 파티션_테이블 PARTITION (최신파티션)
    ORDER BY 정렬_컬럼 DESC
)
UNION ALL
SELECT * FROM (
    SELECT /*+ PARALLEL(4) */ *
    FROM 파티션_테이블 PARTITION (이전파티션)
    ORDER BY 정렬_컬럼 DESC
);
```

### 사례 2: GROUP BY 성능 개선

**문제 상황**: GROUP BY에서 소트 집계 사용으로 인한 성능 저하
```sql
-- Before: 소트 집계 사용 (기본 동작)
SELECT 부서, SUM(급여), COUNT(*)
FROM 직원
GROUP BY 부서;
```

**해결 방안: 해시 집계로 변경**
```sql
-- 해시 집계 힌트 사용
SELECT /*+ USE_HASH_AGGREGATION */ 
    부서, 
    SUM(급여) AS 총급여, 
    COUNT(*) AS 인원수
FROM 직원
GROUP BY 부서;
-- 실행계획: HASH GROUP BY → 메모리 내 처리
```

**주의사항**: 해시 집계도 메모리 부족 시 TEMP 스필 발생 가능. `v$sql_workarea`에서 `operation_type='HASH GROUP BY'`인지 확인.

### 사례 3: DISTINCT 최적화

**문제 상황**: 불필요한 DISTINCT로 인한 소트 발생
```sql
-- Before: 중복 제거를 위한 소트
SELECT DISTINCT 고객ID
FROM 거래내역
WHERE 거래일자 >= SYSDATE - 30;
```

**해결 방안 1: EXISTS 활용**
```sql
-- EXISTS를 사용한 중복 제거
SELECT 고객ID
FROM 고객 c
WHERE EXISTS (
    SELECT 1 
    FROM 거래내역 t
    WHERE t.고객ID = c.고객ID
    AND t.거래일자 >= SYSDATE - 30
);
```

**해결 방안 2: 윈도우 함수 활용**
```sql
-- ROW_NUMBER를 이용한 중복 제거
SELECT 고객ID
FROM (
    SELECT 
        고객ID,
        ROW_NUMBER() OVER (PARTITION BY 고객ID ORDER BY 거래일자 DESC) AS rn
    FROM 거래내역
    WHERE 거래일자 >= SYSDATE - 30
)
WHERE rn = 1;
```

### 사례 4: Sort-Merge Join 회피

**문제 상황**: Sort-Merge Join으로 인한 양쪽 테이블 정렬
```sql
-- Before: Sort-Merge Join 사용
SELECT /*+ USE_MERGE(a b) */ 
    a.컬럼1, b.컬럼2
FROM 테이블A a
JOIN 테이블B b ON a.조인키 = b.조인키;
```

**해결 방안: NL Join이나 Hash Join으로 변경**
```sql
-- NL Join으로 변경 (조인키 인덱스 필요)
SELECT /*+ ORDERED USE_NL(b) INDEX(b 인덱스명) */ 
    a.컬럼1, b.컬럼2
FROM 테이블A a
JOIN 테이블B b ON a.조인키 = b.조인키;

-- Hash Join으로 변경
SELECT /*+ USE_HASH(a b) */ 
    a.컬럼1, b.컬럼2
FROM 테이블A a
JOIN 테이블B b ON a.조인키 = b.조인키;
```

---

## 체계적인 소트 튜닝 접근법

### 1단계: 소트 원인 진단
- 어떤 연산이 소트를 발생시키는가? (ORDER BY, GROUP BY, DISTINCT 등)
- 실행계획에서 `SORT` 연산자 확인
- `v$sql_workarea`에서 소트 관련 작업 확인

### 2단계: 소트 제거 가능성 검토
- **인덱스 활용**: 정렬 키와 인덱스 컬럼 순서/방향 일치 여부 확인
- **Top-N 최적화**: `FETCH FIRST N ROWS` 사용 가능 여부 검토
- **집계 방식 변경**: 해시 집계로 변경 가능 여부 확인
- **중복 제거 최적화**: `DISTINCT` 대체 가능성 검토

### 3단계: 소트 입력량 최소화
- **불필요 컬럼 제거**: SELECT 절 최적화
- **조건 필터링**: WHERE 절을 통한 데이터 양 축소
- **파티션 프루닝**: 파티션 키 조건 활용
- **사전 집계**: 서브쿼리를 통한 데이터 양 축소

### 4단계: 메모리 관리 최적화
- **PGA 크기 조정**: `pga_aggregate_target` 적정화
- **워크에어리어 모니터링**: `v$sql_workarea` 관찰
- **병렬도 조정**: DOP에 따른 메모리 사용량 고려

### 5단계: TEMP 인프라 최적화
- **TEMP 테이블스페이스 용량**: 충분한 공간 확보
- **I/O 성능**: TEMP 파일의 디스크 성능 확인
- **동시성 관리**: TEMP 테이블스페이스 그룹 활용

### 6단계: 측정과 검증
- **전/후 비교**: 실행계획, 통계, 성능 비교
- **지속 모니터링**: 프로덕션 환경에서의 안정성 확인

---

## 결론: 소트 최적화의 핵심 원칙

소트 성능 튜닝은 다음 세 가지 전략으로 접근해야 합니다:

### 1. **소트를 없애라**
- 불필요한 정렬 연산 제거
- 인덱스를 활용한 자연 정렬 획득
- Top-N 패턴 적극 활용
- Sort-Merge Join 대신 NL/Hash Join 사용

### 2. **소트 입력을 줄여라**
- 조기 필터링으로 데이터 양 축소
- 불필요한 컬럼 제거
- 파티셔닝 전략 활용
- 계층적 처리 파이프라인 구축

### 3. **메모리 활용을 최적화하라**
- 적절한 PGA 크기 설정
- 자동 메모리 관리(AUTO) 활용
- Workarea 상태 지속 모니터링
- 병렬 처리 시 메모리 사용량 주의

### 성공적인 튜닝을 위한 마인드셋
1. **가정하지 말고 측정하라**: 모든 변경 전후로 실행계획과 통계 비교
2. **단계적으로 접근하라**: 한 번에 여러 변경을 적용하기보다 단계적 개선
3. **컨텍스트를 고려하라**: 쿼리 특성, 데이터 분포, 시스템 환경 고려
4. **지속적으로 모니터링하라**: 일회성 튜닝이 아닌 지속적인 관찰

소트 튜닝은 단순한 성능 개선을 넘어, 데이터베이스의 자원 사용 효율성을 높이고 시스템 전반의 안정성을 강화하는 중요한 작업입니다. 체계적인 접근과 과학적인 측정을 바탕으로 한 튜닝이 장기적인 성공을 보장합니다.