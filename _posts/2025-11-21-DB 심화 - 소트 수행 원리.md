---
layout: post
title: DB 심화 - 소트 수행 원리
date: 2025-11-21 19:25:23 +0900
category: DB 심화
---
# 소트 수행 원리

> 목표
> - **소트가 언제/어떻게 일어나는지**(ORDER BY, GROUP BY, DISTINCT, 집합연산, 윈도우 함수, Sort-Merge Join, CREATE INDEX 등)
> - **메모리(in-PGA)** ↔ **TEMP 디스크**로의 **단계적 외부 소트 알고리즘**(Optimal/One-Pass/Multi-Pass)
> - **정량 측정 방법**(V$ 뷰/SQL Monitor/DBMS_XPLAN/대기 이벤트)
> - **Sort Area(PGA)** 및 자동 메모리 관리(워크에어리어)
> - **실전 튜닝 체크리스트 & 예제**

---

## 실습 스키마(간단)

```sql
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  sales_dt  DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
);

CREATE INDEX ix_sales_prod_dt ON f_sales(prod_id, sales_dt);

-- 샘플(간략)
INSERT INTO d_product VALUES (10,'ELEC','B0');
INSERT INTO d_product VALUES (20,'HOME','B1');
INSERT INTO f_sales VALUES (1001,10,DATE '2025-02-03',1,10000);
INSERT INTO f_sales VALUES (1002,20,DATE '2025-02-05',2,15000);
INSERT INTO f_sales VALUES (1003,10,DATE '2025-02-10',1, 9000);
COMMIT;
```

---

## 소트가 발생하는 대표 지점

- `ORDER BY`, `GROUP BY`, `DISTINCT`, `UNION`(중복 제거), `INTERSECT/MINUS`
- **윈도우 함수**: `… OVER(PARTITION BY … ORDER BY …)`
- **Sort-Merge Join**(조인 입력 정렬)
- **CREATE INDEX**/`ALTER INDEX REBUILD`(키 정렬)
- **HASH 집계 실패** 시 fallback 소트, `SELECT … FETCH FIRST n ROWS`의 **STOPKEY 소트** 등

**주의**: 옵티마이저가 **인덱스 정렬 순서를 이용**하면 소트를 **생략**할 수 있음(예: `INDEX FULL SCAN [DESCENDING]`).

---

## 소트 수행 과정(알고리즘 관점)

### 소트 — Optimal

- **PGA(작업영역)**에 입력 로우를 모아 **퀵소트/힙소트** 등으로 정렬.
- 결과를 바로 상위 오퍼레이터로 전달. **TEMP I/O 없음**.

### — One-Pass / Multi-Pass

PGA가 부족하면 **외부 소트**로 전환. 고전적인 **런 생성(run generation) + 다중 병합**.

1) **런 생성**:
   - 메모리에 담을 수 있는 만큼 읽어 **정렬된 청크(run)** 생성 → **TEMP에 기록**
2) **병합**:
   - 여러 run을 **k-way merge**로 **하나의 스트림**으로 합침
   - **한 번의 병합으로 끝나면 One-Pass**, 중간 run이 너무 많아 **여러 차례 병합**하면 **Multi-Pass**

외부 소트의 대략적 패스 수:
$$
\text{pass\_count} \approx \left\lceil \log_{k} (\#\text{runs}) \right\rceil
$$
- \(k\): 한 번에 병합 가능한 run 개수(메모리/버퍼 수에 비례)
- **I/O 비용**은 패스 수에 비례해 증가(읽고/쓰고 반복 → TEMP I/O 확대)

### Top-N / STOPKEY 최적화

- `ORDER BY … FETCH FIRST N ROWS ONLY` 또는 `ROWNUM <= N` + ORDER BY
- **N-사이즈 힙 유지**로 **전체 정렬 없이 상위 N개만** 보장
- 실행계획: `SORT ORDER BY STOPKEY`

---

## 소트 오퍼레이션 **측정** 방법

### 세션/시스템 통계(V$SESSTAT/V$SYSSTAT)

```sql
-- 내가 실행하는 세션에서만 변화량 보기
WITH base AS (
  SELECT sn.name, ms.value
  FROM   v$mystat ms JOIN v$statname sn ON sn.stat# = ms.stat#
  WHERE  sn.name IN (
    'sorts (memory)', 'sorts (disk)',
    'workarea executions - optimal',
    'workarea executions - onepass',
    'workarea executions - multipass',
    'session pga memory', 'session pga memory max'
  )
)
SELECT * FROM base;
```
- `sorts (memory)`: PGA에서 끝난 소트 횟수
- `sorts (disk)`: TEMP로 스필된 소트 횟수
- `workarea executions - optimal/onepass/multipass`: **정확한 분류**(소트/해시 공통 지표)
- `session pga memory(*)`: PGA 사용량 추적

### Workarea 상태(V$SQL_WORKAREA / V$SQL_WORKAREA_ACTIVE)

```sql
SELECT sql_id, operation_type, policy, estimated_optimal_size, estimated_onepass_size,
       last_memory_used, last_execution, number_passes, tempseg_size
FROM   v$sql_workarea
WHERE  operation_type LIKE 'SORT%';
```
- `policy` = AUTO/MANUAL
- `number_passes` = 0(Optimal) / 1(One-Pass) / 2+(Multi-Pass)
- `tempseg_size` = TEMP 사용량(바이트)

### TEMP 사용량(V$TEMPSEG_USAGE / DBA_TEMP_FREE_SPACE)

```sql
SELECT s.sid, s.serial#, t.tablespace, t.blocks*ts.block_size bytes, t.sql_id, t.contents, t.segtype
FROM   v$tempseg_usage t
JOIN   v$session s ON s.saddr = t.session_addr
JOIN   dba_tablespaces ts ON ts.tablespace_name = t.tablespace;
```

### 대기 이벤트(ASH/세션 이벤트)

- **`direct path write temp` / `direct path read temp`**: TEMP I/O
- `enq: TS - contention`, `buffer busy waits`(TEMP 헤더/익스텐트 경합) 등

```sql
SELECT event, total_waits, time_waited
FROM   v$session_event
WHERE  sid = SYS_CONTEXT('USERENV','SID')
AND    event IN ('direct path read temp','direct path write temp');
```

### 실행계획으로 TEMP/소트 확인(DBMS_XPLAN)

```sql
-- LAST 실행 통계 + Predicate + Note
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST +PREDICATE +NOTE'));

-- Note에 "TempSpc: ###" 또는 PLAN 라인에 SORT/ TEMP 사용량이 표시될 수 있음
```

### SQL Monitor(대화식 환경)

- 소트 단계의 **메모리 vs TEMP 스필**/Row 수/시간 비중을 바로 확인 가능
- 병렬 쿼리(PQ)일 때 각 slave별 Workarea/Temp를 시각화

---

## Sort Area / Workarea 메모리 모델

### 핵심 파라미터

```sql
SHOW PARAMETER workarea_size_policy;   -- AUTO 권장
SHOW PARAMETER pga_aggregate_target;   -- 전체 PGA 예산(집약형)
SHOW PARAMETER pga_aggregate_limit;    -- PGA 상한(초과 시 ORA-04036)
```
- **`workarea_size_policy=AUTO`**(권장):
  - 소트/해시 **워크에어리어** 크기를 **메모리 브로커**가 동적으로 할당/회수
  - DB 전체 부하/PGA 사용률을 고려
- MANUAL일 때만 **`sort_area_size`/`sort_area_retained_size`** 의미(과거 방식)

### 조정 & 어드바이스

```sql
SELECT * FROM v$pga_target_advice ORDER BY pga_target_for_estimate;

-- 현재 세션의 Workarea 활성 상태
SELECT * FROM v$sql_workarea_active;
```
- **병렬 쿼리**: **각 slave**가 Workarea를 별도로 확보 → DOP가 크면 PGA/TEMP 압박 ↑
- 하나의 SQL 안에서도 **여러 소트/해시**가 동시에 활성화될 수 있음(서브플랜/브랜치)

---

## 예제로 보는 **소트 발생/측정/개선**

### ORDER BY 대량 정렬 — 디스크 스필 유도 예제

```sql
-- (데이터 벌크업) 10만행 이상으로 가정
-- 생성기
WITH gen AS (
  SELECT LEVEL AS n FROM dual CONNECT BY LEVEL <= 100000
)
INSERT /*+ APPEND */ INTO f_sales(sales_id, prod_id, sales_dt, qty, amount)
SELECT 200000 + n, CASE WHEN MOD(n,2)=0 THEN 10 ELSE 20 END,
       DATE '2025-02-01' + MOD(n, 20),
       1 + MOD(n, 3), 10000 + MOD(n, 2000)
FROM gen;
COMMIT;

-- 측정(전)
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN ('sorts (memory)','sorts (disk)',
                   'workarea executions - optimal','workarea executions - onepass',
                   'workarea executions - multipass');

-- 실행: 대규모 ORDER BY
SELECT /* big sort */ *
FROM   f_sales
ORDER BY amount DESC;

-- 측정(후) 비교: sorts(disk)/onepass/multipass 증가 여부 확인
```
- TEMP가 작거나 PGA가 작으면 `direct path write temp/read temp`가 관찰됨.
- `DBMS_XPLAN.DISPLAY_CURSOR('ALLSTATS LAST')`로 SORT 라인의 A-Rows, TempSpc 확인.

### 인덱스를 이용해 소트 **회피**

```sql
-- 정렬 기준과 동일한 인덱스 준비
CREATE INDEX ix_sales_amount_desc ON f_sales(amount DESC);

-- 같은 쿼리 재실행
SELECT /* no sort expected */ *
FROM   f_sales
ORDER BY amount DESC;

-- PLAN: INDEX FULL SCAN (DESCENDING) → SORT 생략
```
- 정렬 방향까지 일치하면 **소트 오퍼레이터 자체가 제거**됨.

### GROUP BY — 해시 집계 vs 소트 집계

```sql
-- 해시 집계 후보
SELECT prod_id, COUNT(*) cnt, SUM(amount) amt
FROM   f_sales
GROUP  BY prod_id;

-- 소트 집계로 바꾸고 싶다면(비권장 케이스)
SELECT /*+ NO_USE_HASH_AGGREGATION */ prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP  BY prod_id;
```
- 일반적으로 **해시 집계**가 TEMP I/O에 덜 민감.
- 해시가 메모리 부족/스필 시 역시 TEMP 사용(Workarea 공통).
- `v$sql_workarea`에서 `operation_type='HASH GROUP BY'`도 함께 확인.

### — 전체 소트 회피

```sql
SELECT /* top-n */ prod_id, amount
FROM   f_sales
ORDER BY amount DESC
FETCH FIRST 10 ROWS ONLY;

-- PLAN: SORT ORDER BY STOPKEY (Temp 거의/전혀 사용하지 않음)
```
- 상위 N개만 필요하면 **STOPKEY**가 극적으로 비용 절감.

### 윈도우 함수 — PARTITION 단위 소트 비용

```sql
SELECT prod_id,
       sales_dt,
       SUM(amount) OVER (PARTITION BY prod_id ORDER BY sales_dt
                         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS run_sum
FROM   f_sales;

-- 각 PARTITION(prod_id)별로 정렬 필요
-- PARTITION 크기가 크면 TEMP 스필 발생 가능
```
- PARTITION 키를 잘라 **단위당 데이터량**을 줄이거나, **사전 정렬된 입력**을 공급하는 전략을 고려.

---

## 소트 튜닝 요약(체크리스트)

### **소트 자체를 없애기**

- **정렬을 유발하는 연산을 피할 수 있는가?**
  - `UNION ALL`(중복 제거 없음) vs `UNION`
  - DISTINCT 정말 필요한가?
  - Sort-Merge Join 대신 **NL Join + 인덱스**로 원하는 순서를 자연스럽게 얻을 수 있는가?
- **인덱스 설계**
  - `ORDER BY a,b [DESC]` ⇢ **(a,b [DESC])** 선두 컬럼/방향 일치 인덱스
  - Top-N ⇢ 선두 컬럼 인덱스 + STOPKEY

### **소트 입력량/폭 줄이기**

- **불필요 컬럼 제거**: 특히 LOB/대형 컬럼은 **소트 이전** 단계에서 제외(서브쿼리/프로젝션 분리)
- **선제 필터링**: WHERE/PARTITION 프루닝으로 입력 로우 축소
- **사전 집계**: 필요 시 계층적 파이프라인으로 **먼저 집계**한 결과를 정렬

### **메모리/워크에어리어 개선**

- `workarea_size_policy=AUTO` 유지
- `pga_aggregate_target`를 **업무 부하**에 맞게 상향(ASH/SQL Monitor로 스필 빈도 관찰)
- 병렬 사용 시 DOP 조정(슬레이브 수 × 워크에어리어 수 만큼 PGA/TEMP 증가)

### **TEMP 인프라**

- TEMP 파일/테이블스페이스 **충분한 용량/IOPS**
- RAC/동시성 높을 때 **TEMP 테이블스페이스 그룹**으로 분산
- `DBA_TEMP_FREE_SPACE`, `V$TEMP_SPACE_HEADER`, `V$TEMPSEG_USAGE` 모니터링
- Autoextend 정책/경고 임계치 설정

### **쿼리/힌트**

- `/*+ USE_HASH_AGGREGATION */`(집계시) / `/*+ NO_USE_HASH_AGGREGATION */`
- `/*+ ORDERED USE_NL */`로 **SMJ 회피**
- `/*+ INDEX_DESC(t idx) */` 등으로 **정렬 방향 맞춘 인덱스 사용**

---

## 성능 진단 루틴(스크립트 예시)

### “전/후” 세션 통계 비교

```sql
-- 1) 스냅샷
CREATE GLOBAL TEMPORARY TABLE gtt_stat_snap (name VARCHAR2(64), val NUMBER) ON COMMIT PRESERVE ROWS;

INSERT INTO gtt_stat_snap
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN ('sorts (memory)','sorts (disk)',
                   'workarea executions - optimal','workarea executions - onepass',
                   'workarea executions - multipass',
                   'session pga memory','session pga memory max');

-- 2) 대상 SQL 실행(여러 번 가능)

-- 3) 차이
SELECT a.name,
       (b.val - a.val) AS delta
FROM   gtt_stat_snap a
JOIN ( SELECT sn.name, ms.value val
       FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
       WHERE  sn.name IN ('sorts (memory)','sorts (disk)',
                          'workarea executions - optimal','workarea executions - onepass',
                          'workarea executions - multipass',
                          'session pga memory','session pga memory max') ) b
ON a.name = b.name;
```

### 실행계획/TEMP 확인

```sql
-- 마지막 실행
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE'));
```
- **SORT 라인(A-Rows/TempSpc)**, Note의 **Temp 사용량**을 체크
- 동일 SQL을 **인덱스 추가/힌트 변경** 후 다시 실행하여 비교

### TEMP 세그먼트 실시간 관찰

```sql
SELECT s.sid, s.serial#, t.sql_id, t.segtype, t.blocks*ts.block_size/1024/1024 AS mb
FROM   v$tempseg_usage t
JOIN   v$session s ON s.saddr = t.session_addr
JOIN   dba_tablespaces ts ON ts.tablespace_name = t.tablespace
ORDER BY mb DESC;
```

---

## 케이스 스터디

### 대형 `ORDER BY` → 인덱스/STOPKEY로 개선

**Before**
```sql
SELECT * FROM f_sales ORDER BY sales_dt DESC;
-- PLAN: SORT ORDER BY → sorts(disk) 증가, direct path write/read temp 발생
```
**After-1 인덱스**
```sql
CREATE INDEX ix_sales_dt_desc ON f_sales(sales_dt DESC);

SELECT /*+ INDEX_DESC(f_sales ix_sales_dt_desc) */ *
FROM   f_sales
ORDER BY sales_dt DESC;
-- PLAN: INDEX FULL SCAN DESCENDING → SORT 제거
```
**After-2 Top-N**
```sql
SELECT sales_id, prod_id, sales_dt, amount
FROM   f_sales
ORDER BY sales_dt DESC
FETCH FIRST 100 ROWS ONLY;
-- PLAN: SORT ORDER BY STOPKEY, TEMP 거의 사용 안 함
```

### DISTINCT 제거/대체

**Before**
```sql
SELECT DISTINCT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-01';
```
**After — GROUP BY(해시)**
```sql
SELECT /*+ USE_HASH_AGGREGATION */ prod_id
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01'
GROUP  BY prod_id;
```
- 해시 집계가 메모리 충분할 때 더 효율(상황별 검증 필수)

### Sort-Merge Join 회피

**Before**
```sql
SELECT /* SMJ 유도 예시 */ /*+ USE_MERGE(fs dp) */
       COUNT(*)
FROM   f_sales fs JOIN d_product dp ON dp.prod_id = fs.prod_id;
-- PLAN: SORT JOIN (두 입력 정렬)
```
**After — NL + 인덱스**
```sql
-- prod_id 선두 인덱스로 NL 유도
SELECT /*+ ORDERED USE_NL(fs dp) INDEX(fs ix_sales_prod_dt) */ COUNT(*)
FROM   d_product dp JOIN f_sales fs ON fs.prod_id = dp.prod_id;
-- PLAN: NESTED LOOPS + INDEX RANGE SCAN → SORT 제거 가능
```

---

## 수학적 직관: 외부 소트 비용(근사)

- 입력 레코드 수 \(N\), 메모리로 만들 수 있는 run 크기를 \(M\), 1회 병합 가능한 run 수를 \(k\)라 하면
  **초기 run 개수** \(\approx \lceil N/M \rceil\).
  **병합 패스 수** \(\approx \lceil \log_{k} (N/M) \rceil\).

- 각 패스에서는 거의 **한 번 읽고/한 번 쓰는** I/O가 발생.
  총 I/O(근사):
$$
\text{IO} \approx 2N \cdot \left(1 + \left\lceil \log_{k} (N/M) \right\rceil \right)
$$
- **M↑(Workarea↑)**, **k↑(버퍼↑)** → **패스 수↓**, TEMP I/O↓.

---

## 운영 팁(요약)

- **정렬이 필요한가부터 점검**: 불필요한 ORDER BY, DISTINCT, UNION 제거
- **정렬을 인덱스로 대체**: 정렬키/방향 일치 인덱스
- **입력 줄이기**: 사전 필터/집계, LOB 제외
- **Top-N**은 STOPKEY 적극 활용
- **GROUP BY**는 가능하면 해시 집계(메모리 충분 시)
- **PGA 예산 조정**: `pga_aggregate_target`/`_limit` 모니터링 & 튜닝
- **TEMP 인프라**: 용량/IOPS/그룹/오토익스텐드/모니터링
- **병렬은 신중히**: DOP ↑ ⇒ PGA/TEMP ↑
- **측정 기반 개선**: V$ 통계, Workarea, TEMP, XPLAN/SQL Monitor로 **수치 비교**

---

## 종합 예제(전/후 비교 시나리오)

### 요구

- 2025-02월 ELEC 카테고리의 **금액 상위 100건**을 빠르게 조회

**Before(대량 소트)**
```sql
SELECT s.sales_id, s.prod_id, s.sales_dt, s.amount
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'
  AND  s.sales_dt >= DATE '2025-02-01'
  AND  s.sales_dt <  DATE '2025-03-01'
ORDER BY s.amount DESC
FETCH FIRST 100 ROWS ONLY;
-- PLAN: SORT ORDER BY STOPKEY이나 입력량이 커 TEMP 스필 발생 가능
```

**After(인덱스 + 입력 축소)**
```sql
-- 1) 정렬키 인덱스
CREATE INDEX ix_sales_amount_desc ON f_sales(amount DESC);

-- 2) 카테고리 필터를 prod_id로 바꾸는(조인백) 인덱스
CREATE INDEX ix_dp_category_prod ON d_product(category, prod_id);

-- 3) NL + 인덱스 DESC 이용 (카테고리→prod_id 드라이빙)
SELECT /*+ LEADING(p) USE_NL(s) INDEX_DESC(s ix_sales_amount_desc) */
       s.sales_id, s.prod_id, s.sales_dt, s.amount
FROM   d_product p
JOIN   f_sales   s ON s.prod_id = p.prod_id
WHERE  p.category = 'ELEC'
  AND  s.sales_dt >= DATE '2025-02-01'
  AND  s.sales_dt <  DATE '2025-03-01'
FETCH FIRST 100 ROWS ONLY;
-- 기대: INDEX DESC + STOPKEY로 SORT 제거/최소화, TEMP I/O 급감
```
**검증**
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE'));
-- TEMP 사용/Sort 라인 유무 비교

-- 세션 통계 델타
-- sorts(disk)/onepass/multipass, direct path temp 이벤트 감소 확인
```

---

## 마무리 체크리스트

- [ ] **소트 원인 파악**: ORDER BY/DISTINCT/GROUP BY/SMJ/윈도우/인덱스 빌드?
- [ ] **인덱스로 대체 가능?** 정렬키·방향 일치 인덱스, NL Join로 자연 순서 획득
- [ ] **입력 축소**: 필터/사전집계/LOB 제외
- [ ] **Top-N**: STOPKEY로 대체
- [ ] **해시 집계 우선**(메모리 충분), SMJ 회피
- [ ] **PGA/TEMP 모니터링**: Workarea, sorts(disk), onepass/multipass, tempseg
- [ ] **파라미터**: `workarea_size_policy=AUTO`, `pga_aggregate_target` 적정치
- [ ] **병렬 고려**: DOP에 따른 PGA/TEMP 상승 평가
- [ ] **전/후 데이터 기반 검증**(DBMS_XPLAN/SQL Monitor/V$*)

---

### 한 줄 요약

소트는 **없애거나(인덱스/플랜)**, **줄이거나(입력/Top-N)**, **메모리를 늘려 TEMP를 피하는 것**이 핵심이다.
모든 변화는 **V$ 통계/Workarea/TEMP/플랜**으로 **정량 검증**하라.
