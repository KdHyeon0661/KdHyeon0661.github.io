---
layout: post
title: 영상처리 - MyImage 설계 (C#)
date: 2025-12-10 17:30:23 +0900
category: 영상처리
---
# 고성능 영상 클래스 MyImage 설계와 내부 동작 원리

## MyImage 설계 목표와 핵심 개념

### 왜 MyImage가 필요한가?

일반적으로 C#에서 영상 처리를 위해 `Bitmap` 클래스를 사용하지만, 이는 몇 가지 문제점이 있습니다:

1. **GC 오버헤드**: 매 프레임마다 객체 생성/파괴 시 가비지 컬렉터가 자주 작동
2. **접근 속도**: `GetPixel()`/`SetPixel()`은 매우 느림
3. **메모리 연속성 보장 안됨**: 픽셀 데이터가 연속 메모리에 있지 않을 수 있음

MyImage는 이러한 문제를 해결하기 위해 설계된 **영상 처리 전용 컨테이너**입니다.

---

## 내부 메모리 구조 상세 분석

### Stride의 중요성
```
원본 비트맵 메모리 레이아웃:
[y=0] 픽셀0 픽셀1 ... 픽셀Width-1 [패딩바이트]
[y=1] 픽셀0 픽셀1 ... 픽셀Width-1 [패딩바이트]
...
[y=Height-1] ...

MyImage 내부 표현 (패딩 제거):
[픽셀(0,0)] [픽셀(1,0)] ... [픽셀(Width-1,0)] [픽셀(0,1)] ...
```
* **Stride**: 한 행(row)의 바이트 수 (패딩 포함)
* **Width**: 실제 픽셀 수
* MyImage는 내부적으로 패딩을 제거하여 연속 메모리 보장

### GCHandle과 메모리 고정(Pinning)의 원리
```csharp
// 메모리 고정이 없는 경우의 문제점
byte[] buffer = new byte[1000000];
// GC가 발생하면 buffer의 메모리 위치가 변경될 수 있음
// 이 상태에서 네이티브 코드가 포인터로 접근하면 위험!

// GCHandle을 사용한 메모리 고정
GCHandle handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
// 이제 GC가 발생해도 buffer의 메모리 위치는 고정됨
byte* fixedPointer = (byte*)handle.AddrOfPinnedObject();
```
**메모리 고정의 중요성**: 
- 안전하지 않은(unsafe) 코드에서 포인터를 사용하려면 메모리 위치가 변하지 않아야 함
- GC는 메모리 단편화를 줄이기 위해 객체를 이동시킴
- `GCHandleType.Pinned`은 "이 객체는 이동하지 마라"고 GC에 지시

---

## Unsafe 포인터 접근의 실제 작동 원리

### Low-level 픽셀 접근 비교
```csharp
// 방법 1: 안전하지만 매우 느림 (Bitmap.GetPixel)
Color color = bitmap.GetPixel(x, y);
byte gray = (byte)((color.R + color.G + color.B) / 3);

// 방법 2: LockBits 사용 (중간 속도)
BitmapData data = bitmap.LockBits(...);
byte* ptr = (byte*)data.Scan0;
byte value = ptr[y * data.Stride + x * bytesPerPixel];

// 방법 3: MyImage 방식 (최고 속도)
// 이미 메모리가 고정되어 있으므로 바로 접근
byte value = _scan0[y * Stride + x];
```

### CPU 캐시 친화적 접근 패턴
```csharp
// 나쁜 예: 캐시 미스 빈번
for (int x = 0; x < width; x++)
    for (int y = 0; y < height; y++)
        ProcessPixel(x, y); // 메모리를 건너뛰며 접근

// 좋은 예: 캐시 효율적 (MyImage의 기본 접근 방식)
for (int y = 0; y < height; y++)
{
    int rowIndex = y * Stride;
    for (int x = 0; x < width; x++)
    {
        ProcessPixel(rowIndex + x); // 연속 메모리 순차 접근
    }
}
```

---

## 실제 영상 처리 알고리즘에서의 활용

### 1. 그레이스케일 변환 (RGB → Gray)
```csharp
public static MyImage ConvertToGray(Bitmap colorBitmap)
{
    MyImage grayImage = new MyImage(colorBitmap.Width, colorBitmap.Height);
    
    // Bitmap의 실제 메모리 구조 분석
    BitmapData data = colorBitmap.LockBits(
        new Rectangle(0, 0, colorBitmap.Width, colorBitmap.Height),
        ImageLockMode.ReadOnly,
        PixelFormat.Format24bppRgb // RGB 각 1바이트
    );
    
    int colorStride = data.Stride;
    byte* colorPtr = (byte*)data.Scan0;
    
    for (int y = 0; y < colorBitmap.Height; y++)
    {
        int colorRow = y * colorStride;
        int grayRow = y * grayImage.Stride;
        
        for (int x = 0; x < colorBitmap.Width; x++)
        {
            int colorIndex = colorRow + x * 3; // RGB 3바이트
            byte r = colorPtr[colorIndex + 2];     // Red
            byte g = colorPtr[colorIndex + 1];     // Green  
            byte b = colorPtr[colorIndex];         // Blue
            
            // 인간의 시각 특성 반영 (ITU-R BT.601 표준)
            byte gray = (byte)(0.299 * r + 0.587 * g + 0.114 * b);
            
            grayImage._scan0[grayRow + x] = gray;
        }
    }
    
    colorBitmap.UnlockBits(data);
    return grayImage;
}
```

### 2. 이미지 블러링(가우시안 블러) 구현
```csharp
public MyImage ApplyGaussianBlur(double sigma)
{
    MyImage result = new MyImage(Width, Height);
    
    // 가우시안 커널 생성
    int kernelSize = (int)(sigma * 3) * 2 + 1; // ±3σ 범위
    double[,] kernel = CreateGaussianKernel(kernelSize, sigma);
    
    // 분리 가능 필터(Seperable Filter) 적용
    // 2D 컨볼루션을 1D 가로 + 1D 세로로 분리하여 성능 향상
    
    // 1. 가로 방향 블러
    MyImage temp = new MyImage(Width, Height);
    ApplyHorizontalBlur(temp, kernel);
    
    // 2. 세로 방향 블러  
    ApplyVerticalBlur(result, temp, kernel);
    
    temp.Dispose();
    return result;
}

private void ApplyHorizontalBlur(MyImage dest, double[,] kernel)
{
    int radius = kernel.GetLength(0) / 2;
    
    unsafe
    {
        for (int y = 0; y < Height; y++)
        {
            int row = y * Stride;
            for (int x = 0; x < Width; x++)
            {
                double sum = 0;
                double weightSum = 0;
                
                for (int k = -radius; k <= radius; k++)
                {
                    int px = x + k;
                    if (px >= 0 && px < Width)
                    {
                        double weight = kernel[k + radius, radius];
                        sum += _scan0[row + px] * weight;
                        weightSum += weight;
                    }
                }
                
                dest._scan0[row + x] = (byte)(sum / weightSum);
            }
        }
    }
}
```

---

## 성능 비교: MyImage vs Bitmap

### 벤치마크 결과
```csharp
// 1024x768 이미지에 3x3 평균 필터 적용
void Benchmark()
{
    Bitmap bitmap = new Bitmap(1024, 768);
    MyImage myImage = MyImage.FromBitmap(bitmap);
    
    // 1. Bitmap.GetPixel/SetPixel 방식
    Stopwatch sw1 = Stopwatch.StartNew();
    ApplyFilterWithGetPixel(bitmap);
    sw1.Stop();
    
    // 2. Bitmap.LockBits 방식  
    Stopwatch sw2 = Stopwatch.StartNew();
    ApplyFilterWithLockBits(bitmap);
    sw2.Stop();
    
    // 3. MyImage 방식
    Stopwatch sw3 = Stopwatch.StartNew();
    ApplyFilterWithMyImage(myImage);
    sw3.Stop();
    
    Console.WriteLine($"GetPixel: {sw1.ElapsedMilliseconds}ms");
    Console.WriteLine($"LockBits: {sw2.ElapsedMilliseconds}ms");
    Console.WriteLine($"MyImage:  {sw3.ElapsedMilliseconds}ms");
}
```

**예상 결과**:
- GetPixel 방식: 500-1000ms
- LockBits 방식: 10-20ms  
- MyImage 방식: 5-10ms

---

## 실제 프로젝트에서의 활용 시나리오

### 시나리오 1: 실시간 영상 처리 시스템
```csharp
public class VideoProcessor
{
    private MyImage _frameBuffer;
    private MyImage _processingBuffer;
    
    public void ProcessFrame(byte[] cameraData)
    {
        // 1. 카메라 데이터를 MyImage로 로드
        LoadFrameFromCamera(cameraData, _frameBuffer);
        
        // 2. 실시간 처리 파이프라인
        // 잡음 제거 → 에지 검출 → 이진화
        _processingBuffer = _frameBuffer.ApplyNoiseReduction()
                                       .ApplyEdgeDetection()
                                       .ApplyThreshold(128);
        
        // 3. UI 스레드로 결과 전달 (스레드 안전)
        UpdateUI(_processingBuffer);
    }
    
    private unsafe void LoadFrameFromCamera(byte[] data, MyImage image)
    {
        // DMA(Direct Memory Access) 버퍼에서 직접 복사
        fixed (byte* sourcePtr = data)
        {
            Buffer.MemoryCopy(
                sourcePtr,           // 소스
                image._scan0,        // 대상  
                image.Buffer.Length, // 복사 크기
                data.Length          // 소스 크기
            );
        }
    }
}
```

### 시나리오 2: 의료 영상 처리
```csharp
public class MedicalImageAnalyzer
{
    public MyImage EnhanceCTScan(MyImage original)
    {
        // 1. 윈도우잉(Window/Level) 조정
        MyImage enhanced = original.ApplyWindowing(40, 400); // 폐 조직 최적화
        
        // 2. 언샤프 마스킹(Unsharp Mask)으로 선명도 향상
        enhanced = enhanced.ApplyUnsharpMask(1.5, 0.5);
        
        // 3. 관심 영역(ROI) 추출
        Rectangle tumorRegion = DetectTumorRegion(enhanced);
        MyImage roi = enhanced.Crop(tumorRegion);
        
        return roi;
    }
}
```

---

## 고급 최적화 기법

### SIMD(SSE/AVX)를 활용한 벡터화 처리
```csharp
public unsafe void ApplyFilterSIMD(MyImage image)
{
    // AVX2를 사용한 병렬 처리 (동시에 32바이트 처리)
    if (Avx2.IsSupported)
    {
        int size = image.Stride * image.Height;
        byte* ptr = image._scan0;
        
        // 32바이트 단위로 처리
        for (int i = 0; i <= size - 32; i += 32)
        {
            // AVX 레지스터에 32바이트 로드
            Vector256<byte> data = Avx.LoadVector256(ptr + i);
            
            // SIMD 연산 수행 (예: 밝기 조정)
            Vector256<short> extended = Avx2.ConvertToVector256Int16(data);
            Vector256<short> adjusted = Avx2.Add(extended, 
                Vector256.Create((short)10)); // 밝기 +10
            
            // 다시 byte로 변환 및 저장
            Vector256<byte> result = Avx2.ConvertToVector256Byte(adjusted);
            Avx.Store(ptr + i, result);
        }
    }
}
```

### 멀티스레딩을 활용한 병렬 처리
```csharp
public void ProcessParallel(MyImage image)
{
    int threadCount = Environment.ProcessorCount;
    int rowsPerThread = image.Height / threadCount;
    
    Parallel.For(0, threadCount, threadId =>
    {
        int startY = threadId * rowsPerThread;
        int endY = (threadId == threadCount - 1) ? 
                   image.Height : startY + rowsPerThread;
        
        unsafe
        {
            for (int y = startY; y < endY; y++)
            {
                int row = y * image.Stride;
                for (int x = 0; x < image.Width; x++)
                {
                    // 각 스레드는 자신의 행 범위만 처리
                    ProcessPixel(image._scan0 + row + x);
                }
            }
        }
    });
}
```

---

## 디버깅과 프로파일링 팁

### 메모리 누수 감지
```csharp
public class MyImageWithLeakDetection : MyImage
{
    private static int _instanceCount = 0;
    
    public MyImageWithLeakDetection(int width, int height) 
        : base(width, height)
    {
        Interlocked.Increment(ref _instanceCount);
        Debug.WriteLine($"MyImage created. Total instances: {_instanceCount}");
    }
    
    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
        Interlocked.Decrement(ref _instanceCount);
        Debug.WriteLine($"MyImage disposed. Total instances: {_instanceCount}");
    }
}
```

### 성능 프로파일링
```csharp
public class ProfiledImageOperation
{
    public void RunWithProfiling()
    {
        // CPU 사용량 프로파일링
        using (new OperationProfiler("GaussianBlur"))
        {
            _image.ApplyGaussianBlur(2.0);
        }
        
        // 메모리 사용량 모니터링
        long before = GC.GetTotalMemory(true);
        MyImage temp = new MyImage(1024, 768);
        long after = GC.GetTotalMemory(true);
        
        Console.WriteLine($"Memory allocated: {(after - before) / 1024}KB");
    }
}
```

---

## 결론: MyImage의 실제 적용 가치

1. **성능 측면**: 기존 Bitmap 방식보다 10-100배 빠른 처리
2. **메모리 효율**: GC 부하 감소, 캐시 친화적 메모리 레이아웃
3. **유연성**: 다양한 영상 처리 알고리즘의 기반 클래스로 활용
4. **상호운용성**: C++ DLL, OpenCV, GPU 가속과의 연동 용이

MyImage는 단순한 픽셀 컨테이너를 넘어, C# 기반 영상 처리 시스템의 **핵심 엔진**으로서:
- 연구용 프로토타이핑부터
- 실시간 산업용 시스템까지
- 고성능 의료 영상 처리에 이르기까지

다양한 영역에서 활용될 수 있는 기반 기술입니다. 다음 강의에서는 이 MyImage를 기반으로 한 실제 영상 처리 알고리즘들을 구현해보겠습니다.