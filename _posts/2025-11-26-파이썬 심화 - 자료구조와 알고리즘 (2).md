---
layout: post
title: 파이썬 심화 - 자료구조와 알고리즘 (2)
date: 2025-11-26 15:25:23 +0900
category: 파이썬 심화
---
# 자료구조와 알고리즘 (2)

## 순서를 유지하며 시퀀스에서 중복 제거하기

파이썬에서 기본적인 `set()`을 사용하면 순서가 유지되지 않습니다. 순서를 보존하면서 중복을 제거하려면 다음과 같은 방법을 사용할 수 있습니다.

```python
def remove_duplicates(items):
    seen = set()
    result = []
    for item in items:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result

# 딕셔너리 키를 이용한 더 간단한 방법 (Python 3.7+)
def remove_duplicates_simple(items):
    return list(dict.fromkeys(items))
```

이 방법은 리스트, 튜플 등 모든 시퀀스 타입에 적용 가능하며, 원본 순서를 완벽하게 유지합니다.

## 슬라이스에 이름 붙여 가독성 높이기

하드코딩된 슬라이스 인덱스는 코드 이해를 어렵게 만듭니다. `slice()` 객체나 네임드 상수를 사용하면 가독성을 크게 향상시킬 수 있습니다.

```python
# 가독성 낮은 코드
data = records[5:15]
text = document[10:50]

# 개선된 코드
RECORD_SLICE = slice(5, 15)
TEXT_EXTRACT = slice(10, 50)

data = records[RECORD_SLICE]
text = document[TEXT_EXTRACT]

# 또는 딕셔너리를 사용해 의미 부여
SLICES = {
    'records': slice(5, 15),
    'text_body': slice(10, 50),
    'header': slice(0, 10)
}

data = records[SLICES['records']]
```

## 시퀀스에서 가장 빈번한 요소 찾기

`collections.Counter` 클래스는 이 작업을 간단하게 만들어줍니다.

```python
from collections import Counter

words = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
word_counts = Counter(words)

# 가장 흔한 요소 3개 찾기
most_common = word_counts.most_common(3)
# 결과: [('apple', 3), ('banana', 2), ('orange', 1)]

# 가장 흔한 단일 요소
most_common_word = word_counts.most_common(1)[0][0]
```

## 일반 키로 딕셔너리 리스트 정렬하기

`sorted()` 함수의 `key` 매개변수와 `operator.itemgetter()` 또는 람다 함수를 함께 사용합니다.

```python
from operator import itemgetter

users = [
    {'name': 'Alice', 'age': 25, 'score': 88},
    {'name': 'Bob', 'age': 30, 'score': 95},
    {'name': 'Charlie', 'age': 22, 'score': 92}
]

# 나이로 정렬
sorted_by_age = sorted(users, key=itemgetter('age'))

# 점수로 내림차순 정렬
sorted_by_score_desc = sorted(users, key=itemgetter('score'), reverse=True)

# 여러 키로 정렬 (주로 점수, 동점시 나이)
sorted_complex = sorted(users, key=lambda x: (x['score'], x['age']))
```

## 비교 기능 없이 객체 리스트 정렬하기

객체 자체에 비교 연산자가 정의되어 있지 않은 경우, `key` 매개변수를 사용해 정렬 기준을 명시적으로 제공합니다.

```python
class Student:
    def __init__(self, name, grade, age):
        self.name = name
        self.grade = grade
        self.age = age
    
    def __repr__(self):
        return f"Student({self.name}, {self.grade}, {self.age})"

students = [
    Student('Alice', 'B', 25),
    Student('Bob', 'A', 30),
    Student('Charlie', 'C', 22)
]

# 성적으로 정렬
sorted_by_grade = sorted(students, key=lambda s: s.grade)

# 나이로 정렬 (내림차순)
sorted_by_age_desc = sorted(students, key=lambda s: s.age, reverse=True)

# 성적과 나이로 복합 정렬
sorted_complex = sorted(students, key=lambda s: (s.grade, s.age))
```

## 특정 필드를 기준으로 레코드 그룹화하기

`itertools.groupby()`는 정렬된 데이터를 그룹화하는 데 유용하지만, 데이터가 키로 정렬되어 있어야 합니다. `collections.defaultdict`를 사용하면 이 제약 없이 그룹화할 수 있습니다.

```python
from collections import defaultdict
from itertools import groupby

records = [
    {'dept': 'Sales', 'name': 'Alice', 'sales': 150},
    {'dept': 'IT', 'name': 'Bob', 'sales': 200},
    {'dept': 'Sales', 'name': 'Charlie', 'sales': 300},
    {'dept': 'IT', 'name': 'David', 'sales': 250}
]

# defaultdict를 사용한 방법 (데이터 정렬 필요 없음)
dept_groups = defaultdict(list)
for record in records:
    dept_groups[record['dept']].append(record)

# 그룹별 집계
for dept, members in dept_groups.items():
    total_sales = sum(member['sales'] for member in members)
    print(f"{dept}: {len(members)}명, 총 매출: {total_sales}")

# groupby를 사용한 방법 (데이터 정렬 필요)
records_sorted = sorted(records, key=lambda x: x['dept'])
for dept, items in groupby(records_sorted, key=lambda x: x['dept']):
    print(f"{dept}: {list(items)}")
```

## 결론

파이썬에서 데이터를 효과적으로 처리하기 위해서는 적절한 내장 도구와 라이브러리를 활용하는 것이 중요합니다. `collections` 모듈의 `Counter`, `defaultdict`와 같은 자료구조는 일반적인 데이터 처리 작업을 간소화해주며, `sorted()` 함수의 `key` 매개변수와 람다 표현식의 조합은 복잡한 정렬 기준을 명확하게 표현할 수 있게 해줍니다. 이러한 기법들을 숙지하면 데이터 처리 코드의 가독성과 효율성을 동시에 높일 수 있습니다.