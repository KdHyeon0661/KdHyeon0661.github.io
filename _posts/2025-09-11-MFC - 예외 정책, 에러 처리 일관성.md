---
layout: post
title: MFC - 예외 정책, 에러 처리 일관성
date: 2025-09-11 21:25:23 +0900
category: MFC
---
# 예외 정책 / 에러 처리 일관성 — Win32 오류 → 예외/결과형 매핑 완전 가이드

**대상**: Win32/MFC/네이티브 C++ 앱, 라이브러리, 도구
**목표**
- Win32( `GetLastError` / `HRESULT` / `NTSTATUS` )를 **일관된 예외/결과형**으로 변환
- **경계( Boundary )** 별 정책(라이브러리 API, 앱 레이어, 스레드/작업 루프) 정의
- **예외 안전성(Strong/Basic/Nothrow)** 을 설계로 보장
- **로그/사용자 메시지/복구 전략**까지 포함한 **운영 친화** 에러 처리

> TL;DR
> - 내부 구현: **예외(throw)** 또는 **`std::expected<T, Err>`** 중 **하나**를 “디폴트”로.
> - 외부 경계(스레드 엔트리/WinMain/메시지 루프): **catch-all + 로깅 + 안전 종료**.
> - Win32 호출은 **헬퍼**로 감싸 *즉시* **`std::system_error`**(또는 커스텀 `win32_error`)을 던지거나, `expected`로 **에러객체** 반환.
> - 사용자에게는 “**행동 가능한 메시지** + 로그ID” 제공, 개발/운영은 **원인(코드/컨텍스트)** 로 복구.

---

## 에러 분류(정책 설계의 출발점)

| 구분 | 예시 | 처리 방식 가이드 |
|---|---|---|
| **사용자 입력/환경 오류** | 파일 없음, 권한 없음, 경로 너무 김 | **예상 가능** → `expected`/리턴값 적합. UI 메시지·재시도·경로 선택 |
| **환경 일시 오류** | 네트워크 타임아웃/잠금 충돌 | **재시도/백오프** 설계. 제어 흐름으로 다루기(예외 남용 지양) |
| **프로그램 버그/계약 위반** | null 역참조, 범위 오류, 불변식 파괴 | **예외/ASSERT**. 복구 불가 → fail-fast + 덤프 |
| **자원 고갈** | 메모리 부족, 핸들 고갈 | 예외로 전파, 상위에서 세이프 셧다운/저장 유도 |
| **취소/중단** | `std::stop_token`, 사용자 취소 | **정상 제어 흐름**(예외 아님). 중단 경로 별도로 구분 |

> **원칙**: “**예외는 비정상/예기치 못한 상황**”에. “**일반적인 실패**/사용자 취소/타임아웃”은 **값 기반( expected )**.

---

## 코어 빌딩 블록 — 오류 표현 타입

### 1-1. `std::error_code` / `std::system_error` (표준)

- `std::error_code`: (정수코드 + category) — **throw-free** 오류 표현
- `std::system_error`: `std::error_code`를 **예외**로 포장

```cpp
#include <system_error>
#include <Windows.h>

inline std::error_code make_win32_ec(DWORD e = ::GetLastError()) {
    return std::error_code((int)e, std::system_category()); // Windows 에러는 system_category
}

void open_file_throwing(const wchar_t* path) {
    HANDLE h = ::CreateFileW(path, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr);
    if (h == INVALID_HANDLE_VALUE) {
        throw std::system_error(make_win32_ec(), "CreateFileW failed");
    }
    ::CloseHandle(h);
}
```

### 1-2. `std::expected<T, E>` (C++23) — 값 기반 실패

```cpp
#include <expected>

using win32_expected = std::expected<void, std::error_code>;

win32_expected open_file_expected(const std::wstring& path) {
    HANDLE h = ::CreateFileW(path.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr);
    if (h == INVALID_HANDLE_VALUE)
        return std::unexpected(make_win32_ec());
    ::CloseHandle(h);
    return {};
}

// 사용
if (auto r = open_file_expected(L"missing.txt"); !r) {
    auto ec = r.error(); // 코드/카테고리
    // 메시지 만들기: ec.message() (로케일 의존: 확보는 아래 유틸 참조)
}
```

### 1-3. 커스텀 오류 컨텍스트 (원인 + 문맥)

```cpp
struct error_context {
    std::error_code ec;      // 근본 원인
    std::string      api;    // 실패한 API (e.g., "CreateFileW")
    std::wstring     path;   // 관련 경로
    // 추가: pid, tid, try_count, deadline ...

    std::string to_compact() const {
        return fmt::format("api={} code={}({}) path={}",
                           api, ec.value(), ec.message(), wide_to_utf8(path));
    }
};

struct context_error : std::runtime_error {
    error_context ctx;
    explicit context_error(error_context c)
      : std::runtime_error(c.to_compact()), ctx(std::move(c)) {}
};
```

> **팁**: “**원인(error_code)** + **문맥(어떤 작업 중, 어떤 리소스)**”을 **항상 함께** 남기면 운영 효율이 크게 향상.

---

## Win32 → 표준 에러 매핑

### 2-1. `GetLastError()` to `std::error_code`

- `std::system_category()`는 **Windows 시스템 에러 코드**에 맞춰 메시지를 생성합니다.
- 한글 메시지/로컬라이징이 필요하면 **`FormatMessageW`**로 직접 구성.

```cpp
inline std::wstring format_win32_message(DWORD code) {
    wchar_t* buf = nullptr;
    DWORD n = ::FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        nullptr, code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPWSTR)&buf, 0, nullptr);
    std::wstring s = (n && buf) ? std::wstring(buf, n) : L"(no message)";
    if (buf) ::LocalFree(buf);
    return s;
}

inline std::string ec_message_utf8(const std::error_code& ec) {
    // system_category().message()는 ANSI일 수 있음 → 명시적 변환 추천
    return narrow_utf8(format_win32_message((DWORD)ec.value()));
}
```

### 2-2. `HRESULT` 매핑

- COM/WinRT 계열은 `HRESULT` 중심.
- 실패 시 `FAILED(hr)` → `std::system_error` or custom.

```cpp
inline std::error_code make_hresult_ec(HRESULT hr) {
    // system_category는 Win32 + HRESULT를 모두 표현(표준화된 관례)
    return std::error_code((int)hr, std::system_category());
}

inline void check_hr_throw(HRESULT hr, std::string_view api) {
    if (FAILED(hr)) throw std::system_error(make_hresult_ec(hr), std::string(api));
}
```

### 2-3. `NTSTATUS` (드라이버/저수준)

- `RtlNtStatusToDosError`로 Win32 코드로 변환 후 동일 처리.

```cpp
inline std::error_code make_ntstatus_ec(LONG status) {
    DWORD win32 = ::RtlNtStatusToDosError(status);
    return make_win32_ec(win32);
}
```

---

## “던지는 버전” vs “결과 반환 버전” — API 이중화

**전략**: 내부 구현은 **한쪽(예외 or expected)** 으로 통일 → 퍼블릭 API는 **두 버전** 제공하면 팀 모두가 편함.

```cpp
// 3-1. 내부: 예외 기반
void copy_file_throw(const std::wstring& src, const std::wstring& dst) {
    if (!::CopyFileW(src.c_str(), dst.c_str(), FALSE)) {
        throw context_error({make_win32_ec(), "CopyFileW", dst});
    }
}

// 3-2. 외부: expected로 래핑
std::expected<void, error_context> copy_file_ex(const std::wstring& s, const std::wstring& d) noexcept {
    try {
        copy_file_throw(s, d);
        return {};
    } catch (const context_error& e) {
        return std::unexpected(e.ctx);
    } catch (const std::exception& e) {
        return std::unexpected(error_context{ std::make_error_code(std::errc::io_error), "copy_file_throw", d });
    }
}
```

> **이점**: UI/업무 로직은 **분기 중심( expected )**, 도메인 로직은 **예외 안전**에 집중.

---

## 안전 래퍼(“체크 함수”) — 반복 코드 제거

### 4-1. Win32 boolean API

```cpp
template<class F, class... Args>
inline void win32_call_throw(std::string_view api, F&& f, Args&&... args) {
    if (!std::invoke(std::forward<F>(f), std::forward<Args>(args)...)) {
        throw context_error({ make_win32_ec(), std::string(api), L"" });
    }
}

// 사용
win32_call_throw("DeleteFileW", ::DeleteFileW, path.c_str());
```

### 4-2. Handle/Pointer 반환 API

```cpp
template<class P>
inline P check_handle(P p, std::string_view api) {
    if (!p || p == INVALID_HANDLE_VALUE)
        throw context_error({ make_win32_ec(), std::string(api), L"" });
    return p;
}

auto hFile = check_handle(::CreateFileW(p.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr), "CreateFileW");
```

### 4-3. HRESULT

```cpp
#define HR_CHECK(api, expr) do{ HRESULT _hr=(expr); if(FAILED(_hr)) check_hr_throw(_hr, (api)); }while(0)

// 사용
HR_CHECK("CoInitializeEx", ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED));
```

---

## 예외 안전성(Strong/Basic/No-throw) — 설계 규칙

| 보장 | 의미 | 언제 |
|---|---|---|
| **Strong** | 실패 시 **무효 효과 없음**(원자성) | 저장/교체/거래성 작업 |
| **Basic** | 불변식은 유지, 일부 상태 변화 가능 | 대부분의 수정 작업 |
| **No-throw** | 절대 예외 없음 | 소멸자, 이동연산, 로깅/정리 경로 |

### 5-1. 강한 보장 패턴: “임시 → 교체”

```cpp
void save_atomic(const fs::path& dst, const std::string& bytes) {
    auto tmp = dst; tmp += ".tmp";
    write_all(tmp, bytes);            // 실패 시 예외 → dst 안전
    fs::rename(tmp, dst);             // 같은 볼륨: 거의 원자적
}
```

### 5-2. 소멸자/이동은 `noexcept`

```cpp
struct Blob {
    std::vector<std::byte> buf;
    ~Blob() noexcept = default;
    Blob(Blob&&) noexcept = default;
    Blob& operator=(Blob&&) noexcept = default;
};
```

---

## 스레드/작업 경계의 예외 포착 — “절대 밖으로 새지 않게”

**원칙**: 스레드 엔트리/작업 루프/메시지 콜백에서는 **catch-all** + **로그/상태전환**.

```cpp
void WorkerLoop(std::stop_token st) {
    try {
        while (!st.stop_requested()) {
            step(); // 내부는 자유롭게 throw
        }
    } catch (const context_error& e) {
        SPDLOG_ERROR("worker context_error: {}", e.what()); // 원인+문맥
        // 상태 전환/재시작 판단
    } catch (const std::exception& e) {
        SPDLOG_ERROR("worker std::exception: {}", e.what());
    } catch (...) {
        SPDLOG_CRITICAL("worker unknown exception");
    }
}
```

- **UI 스레드**: 메시지 핸들러에서 예외 누수 시 프로세스 종료 위험 → **내부에서 모두 처리**하고 사용자에게 메시지.

---

## 취소/타임아웃/재시도 — “예외가 아닌 제어 흐름”

### 7-1. 타임아웃 표준화

```cpp
struct timeout {
    std::chrono::steady_clock::time_point deadline;
    static timeout after(std::chrono::milliseconds d) { return {std::chrono::steady_clock::now()+d}; }
    bool expired() const { return std::chrono::steady_clock::now() >= deadline; }
};
```

### 7-2. 재시도(지수 백오프)

```cpp
template<class F>
std::expected<void, error_context> retry_backoff(F&& f, int max_try, std::chrono::milliseconds base) {
    for (int i=1; i<=max_try; ++i) {
        if (auto r = f(); r) return {};
        else {
            if (i == max_try) return std::unexpected(r.error());
            std::this_thread::sleep_for(base * (1<< (i-1)));
        }
    }
    return {}; // not reached
}
```

- **일시 오류**(공유 위반, 서버 바쁨 등): **재시도 정책**을 코드 레벨에서 표준화.

---

## UI/메시지와 사용자 피드백 — 기술/행동 분리

- 사용자에게는 **행동 지침**: *“파일을 닫고 다시 시도”, “다른 경로를 선택”*
- 기술 정보(에러 코드/스택/경로)는 **로그**에.
- **로컬라이즈 가능한 키** 사용.

```cpp
struct user_message {
    std::wstring title;
    std::wstring body;    // 행동 지침 위주
    std::wstring detail;  // (옵션) 기술 상세, “자세히” 버튼에 노출
};

user_message to_user_message(const error_context& ctx) {
    switch (ctx.ec.value()) {
    case ERROR_ACCESS_DENIED:
        return {L"권한 오류", L"파일에 접근할 수 없습니다. 관리자 권한 또는 위치를 확인하세요.",
                wide(fmt::format(L"API={} Code={} Path={}", w(ctx.api), ctx.ec.value(), ctx.path))};
    case ERROR_FILE_NOT_FOUND:
        return {L"파일 없음", L"선택한 파일을 찾을 수 없습니다. 경로를 확인하세요.",
                wide(fmt::format(L"Path={}", ctx.path))};
    default:
        return {L"작업 실패", L"예기치 않은 오류가 발생했습니다. 다시 시도하거나 로그를 첨부해 문의하세요.",
                wide(fmt::format(L"Code={} ({})", ctx.ec.value(), utf8_to_w(ec_message_utf8(ctx.ec))))};
    }
}
```

> **팁**: MFC/Win32에서는 `TaskDialogIndirect`로 “자세히” 영역 제공이 편리.

---

## 일관된 정책 문서(팀 합의안 예시)

1) **도메인 내부**: 예외 기반(throw). 강한 예외 보장 준수.
2) **퍼블릭 API**: `Foo()` / `FooEx()` 두 버전 제공 (`FooEx`는 `std::expected`).
3) **스레드/경계**: `catch(...)` + 로그 + 안전 종료(또는 재시작).
4) **취소/타임아웃**: 예외 금지, `expected`와 별도 `error_code`(e.g., `operation_canceled`).
5) **Win32 호출**: 헬퍼 `check_*` 사용 의무. 직접 if/return 금지.
6) **로그**: `api, path, code, message, tid, pid` 포함. 사용자 메시지는 행동 지침 중심.
7) **테스트**: 실패 주입(모의 `GetLastError` / 핸들 누락)으로 경계 검증.
8) **i18n**: 사용자 메시지 리소스/키로 로컬라이즈, 로그는 영어(분석 용이).
9) **성능 경로**: 예외 비용 큰 경로는 `expected` 사용(핫루프).
10) **SEH**: `_set_se_translator`로 C++ 예외 변환하거나, 크래시 시 미니덤프 생성.

---

## 실전 코드 묶음 (복붙)

### 10-1. 변환 유틸(헤더)

```cpp
// errorx.h
#pragma once
#include <Windows.h>
#include <system_error>
#include <string>
#include <expected>

namespace errorx {

inline std::error_code win32_ec(DWORD e = ::GetLastError()) {
    return std::error_code((int)e, std::system_category());
}

inline std::error_code hresult_ec(HRESULT hr) {
    return std::error_code((int)hr, std::system_category());
}

struct context {
    std::error_code ec;
    std::string api;
    std::wstring path;
    std::wstring target;
    int try_count = 0;
};

struct exception : std::runtime_error {
    context ctx;
    explicit exception(context c)
      : std::runtime_error("error: " + c.api + " code=" + std::to_string(c.ec.value())),
        ctx(std::move(c)) {}
};

template<class F, class... Args>
inline void call_throw(std::string_view api, F&& f, Args&&... args) {
    if (!std::invoke(std::forward<F>(f), std::forward<Args>(args)...))
        throw exception({win32_ec(), std::string(api), L"", L"", 0});
}

template<class P>
inline P check_handle(P p, std::string_view api) {
    if (!p || p == INVALID_HANDLE_VALUE)
        throw exception({win32_ec(), std::string(api), L"", L"", 0});
    return p;
}

inline void check_hr(HRESULT hr, std::string_view api) {
    if (FAILED(hr)) throw exception({hresult_ec(hr), std::string(api), L"", L"", 0});
}

template<class F>
inline std::expected<void, context> guard_expected(F&& f) noexcept {
    try { f(); return {}; }
    catch (const exception& e){ return std::unexpected(e.ctx); }
    catch (...)              { return std::unexpected(context{ std::make_error_code(std::errc::io_error), "unknown", L"", L"", 0}); }
}

} // namespace
```

### 10-2. 사용 예

```cpp
#include "errorx.h"
#include <filesystem>

using namespace errorx;

void copy_throw(const std::wstring& src, const std::wstring& dst) {
    call_throw("CopyFileW", ::CopyFileW, src.c_str(), dst.c_str(), FALSE);
}

std::expected<void, context> copy_ex(const std::wstring& s, const std::wstring& d) noexcept {
    return guard_expected([&]{ copy_throw(s, d); });
}

int main() {
    if (auto r = copy_ex(L"missing.txt", L"out.txt"); !r) {
        auto& c = r.error();
        // 로그: c.api, c.ec.value(), c.ec.message()
        fprintf(stderr, "copy failed: api=%s code=%d\n", c.api.c_str(), c.ec.value());
        return 1;
    }
    return 0;
}
```

---

## MFC/WinMain 경계 처리(크래시 방지)

```cpp
int APIENTRY wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int) {
    try {
        // 초기화
        return theApp.Run();
    } catch (const errorx::exception& e) {
        // 로그 + 사용자 메시지
        MessageBoxW(nullptr, L"작업 중 오류가 발생했습니다. 로그를 확인하세요.", L"오류", MB_ICONERROR);
        return EXIT_FAILURE;
    } catch (const std::exception& e) {
        MessageBoxA(nullptr, e.what(), "Fatal Error", MB_ICONERROR);
        return EXIT_FAILURE;
    } catch (...) {
        MessageBoxW(nullptr, L"알 수 없는 치명적 오류", L"Fatal", MB_ICONERROR);
        return EXIT_FAILURE;
    }
}
```

- **메시지 루프 밖 경계**에서 예외를 흡수.
- 스레드 엔트리도 동일 패턴.

---

## SEH(Access Violation 등)와의 공존

- C++ 예외와 SEH는 별개.
- **버그성 충돌**은 **미니덤프** + **fail-fast**가 현실적.
- 그래도 변환이 필요하면 `_set_se_translator`로 **C++ 예외로 래핑**(주의: 비권장/복구 불가 상황 많음).

```cpp
#include <eh.h>

void seh_translator(unsigned code, _EXCEPTION_POINTERS*) {
    throw std::runtime_error("SEH exception code=" + std::to_string(code));
}

int main(){
    _set_se_translator(seh_translator);
    // ...
}
```

---

## 테스트 전략 — 실패 주입/경계 조건

- **파일/권한**: 임시 디렉터리 read-only로 바꾸고 저장 시도
- **경합/락**: 파일 핸들 유지한 채 삭제/덮어쓰기
- **타임아웃**: 가짜 지연/네트워크 모의
- **예외 안전**: 실패 후 **상태 불변** 확인(강한 보장 테스트)
- **로깅 검증**: `ostream_sink` 또는 메모리 싱크로 메시지 내용 테스트(spdlog).

---

## 로깅/텔레메트리 연동

- 예외 발생 시 **에러ID(ULID/UUID)** 생성 → 사용자 메시지/로그에 공통 표기
- 원격 수집(옵션): 이벤트 업로드 **비차단/최소화**
- **PII/경로**: 정책 준수(마스킹/옵션화)

```cpp
std::string new_error_id();
void log_exception(const errorx::context& c) {
    auto id = new_error_id();
    SPDLOG_ERROR("err_id={} api={} code={} msg={}", id, c.api, c.ec.value(), c.ec.message());
    // 사용자 메시지에도 id 포함
}
```

---

## 성능 고려 — 예외 비용 줄이기

- **핫패스**: 실패가 “정상”일 수 있는 코드(예: `try_open_then_fallback`)는 **예외 금지** → `expected`/리턴값.
- 예외는 **진짜 에러**일 때만.
- 포맷/로깅 비용은 `SPDLOG_DEBUG` 수준으로 낮추고 **릴리즈에서 끔**.

---

## “결과형 전용” 코드베이스를 위한 팁

- `using result<T> = std::expected<T, errorx::context>;`
- 조합기를 만들어 루프/체이닝 단순화.

```cpp
template<class T, class F>
auto and_then(std::expected<T, errorx::context> r, F&& f) {
    if (!r) return std::invoke(std::forward<F>(f), r.error());
    return std::invoke(std::forward<F>(f), *r);
}
```

---

## FAQ

- **왜 `std::system_category()`?**
  Windows 시스템 오류/`HRESULT`를 포괄적으로 처리. 메시지는 OS로부터.

- **`HRESULT`를 그대로 예외에 담아도 될까?**
  표준화된 `std::error_code`로 담으면 범용 알고리즘/로깅과 잘 통합.

- **사용자 취소도 예외로?**
  **아니요.** `operation_canceled` 류 별도 코드로 정상 흐름.

- **예외 vs expected — 하나만?**
  내부 구현 통일, 퍼블릭 API 이중 제공이 실무에서 가장 유연.

---

## 요약 체크리스트

- [ ] 내부: 예외 기반(throw) 또는 expected로 통일
- [ ] 퍼블릭 API: `Func()` + `FuncEx()`(expected)
- [ ] Win32/HRESULT/NTSTATUS → `error_code` 매핑 헬퍼 필수
- [ ] 경계(스레드/WinMain/루프): catch-all + 로그 + 안전 종료
- [ ] 강한 보장: “임시→교체”, 소멸자/이동 `noexcept`
- [ ] 취소/타임아웃/재시도: **예외 금지**, 정책화
- [ ] 로그: 원인(코드/메시지) + 문맥(path/api) + 스레드/ID
- [ ] 사용자 메시지: 행동 지침, 기술 상세는 “자세히”
- [ ] 실패 주입 테스트/로깅 테스트
- [ ] i18n 분리(리소스 키), 로그는 영어 기본

---

### 마무리

에러 처리는 “**일관성**”이 전부입니다.
Win32의 난해한 오류 체계를 **표준 타입**( `error_code / system_error / expected` )로 통일하면,
- 구현은 **예외 안전**,
- 호출자는 **분기 기반 제어**,
- 운영은 **로그+컨텍스트**로 원인 파악이 **빠르고 정확**해집니다.
