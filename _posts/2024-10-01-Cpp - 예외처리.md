---
layout: post
title: C++ - 예외처리
date: 2024-10-01 19:20:23 +0900
category: Cpp
---
# C++ 예외 처리의 깊은 이해: 안전한 에러 처리를 위한 철학과 기술

## 서론: 예외 처리가 왜 필요한가?

프로그램 실행 중 발생할 수 있는 예상치 못한 상황들은 우리의 코드를 위협합니다. 파일이 존재하지 않을 수도 있고, 네트워크 연결이 끊길 수도 있으며, 사용자가 잘못된 입력을 제공할 수도 있습니다. 전통적인 오류 처리 방식(에러 코드 반환)은 여러 문제점을 가지고 있습니다:

1. **에러 코드 무시**: 호출자가 에러 코드를 체크하지 않으면 문제가 숨겨짐
2. **코드 복잡성**: 모든 함수 호출 후 에러 체크로 인해 코드가 복잡해짐
3. **자원 누수**: 중간에 리턴하면 자원 해제를 까먹을 수 있음

C++ 예외 처리는 이러한 문제들을 우아하게 해결합니다.

---

## 제1장: 예외 처리의 기본 구조

### 기본 문법: `try`, `throw`, `catch`

```cpp
#include <iostream>
#include <stdexcept>

double divide(double numerator, double denominator) {
    if (denominator == 0.0) {
        throw std::runtime_error("0으로 나눌 수 없습니다");
    }
    return numerator / denominator;
}

int main() {
    try {
        double result = divide(10.0, 0.0);
        std::cout << "결과: " << result << std::endl;
    } catch (const std::runtime_error& e) {
        std::cerr << "에러 발생: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "일반 에러: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "알 수 없는 에러 발생" << std::endl;
    }
    
    return 0;
}
```

### 핵심 원칙: "값으로 던지고, 참조로 잡기"

```cpp
// 올바른 패턴
try {
    throw MyException("에러 메시지");
} catch (const MyException& e) {  // 참조로 캐치
    // 예외 처리
}

// 피해야 할 패턴
try {
    throw MyException("에러 메시지");
} catch (MyException e) {  // 값으로 캐치 - 불필요한 복사
    // 예외 처리
}
```

**참조로 캐치하는 이유**:
1. 불필요한 복사 방지
2. 다형성 지원 (기본 클래스 참조로 파생 클래스 예외 캐치 가능)
3. 객체 슬라이싱 방지

### 캐치 순서의 중요성: 구체적인 것부터 일반적인 순서로

```cpp
try {
    // 어떤 작업
    throw std::out_of_range("인덱스 초과");
} 
catch (const std::out_of_range& e) {
    // 가장 구체적인 예외 처리
    std::cerr << "범위 에러: " << e.what() << std::endl;
}
catch (const std::logic_error& e) {
    // 논리 에러 처리
    std::cerr << "논리 에러: " << e.what() << std::endl;
}
catch (const std::exception& e) {
    // 모든 표준 예외 처리
    std::cerr << "표준 예외: " << e.what() << std::endl;
}
catch (...) {
    // 그 외 모든 예외 처리
    std::cerr << "알 수 없는 예외" << std::endl;
}
```

---

## 제2장: 표준 예외 계층 구조 이해하기

C++ 표준 라이브러리는 잘 구성된 예외 계층 구조를 제공합니다. 이를 이해하면 더 효과적인 예외 처리가 가능합니다.

```cpp
#include <iostream>
#include <stdexcept>
#include <vector>
#include <memory>
#include <typeinfo>

void demonstrate_standard_exceptions() {
    try {
        // std::logic_error 계열
        std::vector<int> v(5);
        v.at(10) = 42;  // std::out_of_range 발생
        
    } catch (const std::out_of_range& e) {
        std::cerr << "범위 에러: " << e.what() << std::endl;
        
    } catch (const std::logic_error& e) {
        std::cerr << "논리 에러: " << e.what() << std::endl;
    }
    
    try {
        // std::runtime_error 계열
        std::string s = "abc";
        int num = std::stoi(s);  // std::invalid_argument 발생
        
    } catch (const std::invalid_argument& e) {
        std::cerr << "잘못된 인자: " << e.what() << std::endl;
        
    } catch (const std::runtime_error& e) {
        std::cerr << "런타임 에러: " << e.what() << std::endl;
    }
    
    try {
        // 메모리 할당 에러
        long long huge_size = 1000000000000LL;
        auto ptr = new int[huge_size];  // std::bad_alloc 발생 가능
        
    } catch (const std::bad_alloc& e) {
        std::cerr << "메모리 할당 실패: " << e.what() << std::endl;
    }
    
    try {
        // 타입 변환 에러
        class Base { virtual void dummy() {} };
        class Derived : public Base {};
        
        Base* b = new Base();
        Derived* d = dynamic_cast<Derived*>(b);  // nullptr 반환
        
        if (!d) {
            throw std::bad_cast();  // 명시적으로 던지기
        }
        
    } catch (const std::bad_cast& e) {
        std::cerr << "타입 변환 실패: " << e.what() << std::endl;
    }
}
```

---

## 제3장: 사용자 정의 예외 만들기

표준 예외로는 표현할 수 없는 도메인 특화 에러를 처리하기 위해 사용자 정의 예외를 만들 수 있습니다.

### 기본적인 사용자 정의 예외

```cpp
#include <exception>
#include <string>
#include <iostream>

// 기본 예제
class FileNotFoundException : public std::runtime_error {
public:
    explicit FileNotFoundException(const std::string& filename)
        : std::runtime_error("파일을 찾을 수 없음: " + filename)
        , filename_(filename) {}
    
    const std::string& filename() const { return filename_; }
    
private:
    std::string filename_;
};

// 좀 더 풍부한 사용자 정의 예외
class DatabaseException : public std::runtime_error {
public:
    enum class ErrorCode {
        ConnectionFailed,
        QueryFailed,
        Timeout,
        ConstraintViolation
    };
    
    DatabaseException(ErrorCode code, const std::string& message, 
                     const std::string& query = "")
        : std::runtime_error(message)
        , error_code_(code)
        , query_(query) {}
    
    ErrorCode error_code() const { return error_code_; }
    const std::string& query() const { return query_; }
    
    const char* error_code_str() const {
        switch (error_code_) {
            case ErrorCode::ConnectionFailed: return "연결 실패";
            case ErrorCode::QueryFailed: return "쿼리 실패";
            case ErrorCode::Timeout: return "시간 초과";
            case ErrorCode::ConstraintViolation: return "제약 조건 위반";
            default: return "알 수 없는 에러";
        }
    }
    
private:
    ErrorCode error_code_;
    std::string query_;
};

// 사용 예시
void query_database() {
    try {
        // 데이터베이스 작업...
        throw DatabaseException(
            DatabaseException::ErrorCode::ConnectionFailed,
            "데이터베이스 서버에 연결할 수 없습니다",
            "SELECT * FROM users"
        );
    } catch (const DatabaseException& e) {
        std::cerr << "데이터베이스 에러 [" << e.error_code_str() 
                  << "]: " << e.what() << std::endl;
        std::cerr << "실패한 쿼리: " << e.query() << std::endl;
        throw;  // 재던지기
    }
}
```

### 예외 체이닝: 원인 추적

복잡한 시스템에서 에러가 발생했을 때, 원인을 추적할 수 있게 해주는 패턴입니다.

```cpp
#include <exception>
#include <stdexcept>
#include <iostream>
#include <memory>

// 중첩 예외를 지원하는 사용자 정의 예외
class ChainedException : public std::runtime_error {
public:
    ChainedException(const std::string& message, 
                    std::exception_ptr nested = nullptr)
        : std::runtime_error(message)
        , nested_(std::move(nested)) {}
    
    void rethrow_nested() const {
        if (nested_) {
            std::rethrow_exception(nested_);
        }
    }
    
    void print_chain() const {
        std::cerr << what() << std::endl;
        if (nested_) {
            try {
                std::rethrow_exception(nested_);
            } catch (const ChainedException& e) {
                e.print_chain();
            } catch (const std::exception& e) {
                std::cerr << "  Caused by: " << e.what() << std::endl;
            }
        }
    }
    
private:
    std::exception_ptr nested_;
};

// 사용 예시
void low_level_operation() {
    throw std::runtime_error("하드웨어 오류");
}

void mid_level_operation() {
    try {
        low_level_operation();
    } catch (const std::exception& e) {
        std::throw_with_nested(
            ChainedException("중간 레벨 작업 실패")
        );
    }
}

void high_level_operation() {
    try {
        mid_level_operation();
    } catch (const std::exception& e) {
        std::throw_with_nested(
            ChainedException("상위 레벨 작업 실패")
        );
    }
}

int main() {
    try {
        high_level_operation();
    } catch (const ChainedException& e) {
        std::cerr << "에러 체인:" << std::endl;
        e.print_chain();
    }
    
    return 0;
}
```

---

## 제4장: RAII와 예외 안전성

RAII(Resource Acquisition Is Initialization)는 C++에서 예외 안전성을 보장하는 핵심 패턴입니다.

### 기본 RAII 패턴

```cpp
#include <memory>
#include <fstream>
#include <iostream>

class FileHandler {
private:
    std::unique_ptr<std::FILE, decltype(&std::fclose)> file_;
    
public:
    explicit FileHandler(const char* filename, const char* mode = "r")
        : file_(std::fopen(filename, mode), &std::fclose) {
        
        if (!file_) {
            throw std::runtime_error(std::string("파일 열기 실패: ") + filename);
        }
    }
    
    std::FILE* get() const { return file_.get(); }
    
    void write(const std::string& data) {
        if (std::fwrite(data.data(), 1, data.size(), file_.get()) != data.size()) {
            throw std::runtime_error("파일 쓰기 실패");
        }
    }
    
    // 복사 방지
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
    
    // 이동 허용
    FileHandler(FileHandler&&) = default;
    FileHandler& operator=(FileHandler&&) = default;
};

// 사용 예시
void process_file() {
    FileHandler file("data.txt", "w");
    file.write("Hello, World!\n");
    // 예외가 발생해도 파일은 자동으로 닫힘
}
```

### 세 가지 예외 안전 보장 수준

```cpp
#include <vector>
#include <algorithm>
#include <memory>

// 1. 기본 보장 (Basic Guarantee)
// - 예외 발생 시 자원 누수 없음
// - 객체는 유효하지만 상태는 변경될 수 있음
class BasicGuaranteeVector {
    std::vector<int> data_;
public:
    void add(int value) {
        data_.push_back(value);  // 예외 발생 가능
        // 여기서 예외 발생하면 data_는 이전 상태로 돌아감
    }
};

// 2. 강력 보장 (Strong Guarantee)
// - 예외 발생 시 객체 상태가 변경되지 않음 (트랜잭션)
class StrongGuaranteeVector {
    std::vector<int> data_;
public:
    void add(int value) {
        auto new_data = data_;           // 복사 (예외 발생 가능)
        new_data.push_back(value);       // 새 컨테이너에 작업
        data_.swap(new_data);            // 성공 시 교체 (noexcept)
    }
};

// 3. 예외 불가 보장 (No-throw Guarantee)
// - 예외를 절대 던지지 않음
class NoThrowVector {
    std::unique_ptr<int[]> data_;
    size_t size_ = 0;
    size_t capacity_ = 0;
    
public:
    void add(int value) noexcept {
        if (size_ >= capacity_) {
            // 재할당 필요 - 하지만 noexcept이므로 실패 시 프로그램 종료
            resize(capacity_ * 2 + 1);
        }
        data_[size_++] = value;
    }
    
private:
    void resize(size_t new_capacity) noexcept {
        // 단순화된 구현 - 실제로는 더 복잡함
        auto new_data = std::make_unique<int[]>(new_capacity);
        for (size_t i = 0; i < size_; ++i) {
            new_data[i] = data_[i];
        }
        data_ = std::move(new_data);
        capacity_ = new_capacity;
    }
};
```

---

## 제5장: 고급 예외 처리 패턴

### `noexcept`와 이동 의미론

```cpp
#include <vector>
#include <iostream>

class Resource {
    int* data_;
    size_t size_;
    
public:
    Resource(size_t size) : data_(new int[size]), size_(size) {
        std::cout << "리소스 생성" << std::endl;
    }
    
    ~Resource() {
        delete[] data_;
        std::cout << "리소스 소멸" << std::endl;
    }
    
    // noexcept 이동 생성자
    Resource(Resource&& other) noexcept
        : data_(other.data_), size_(other.size_) {
        other.data_ = nullptr;
        other.size_ = 0;
        std::cout << "리소스 이동" << std::endl;
    }
    
    // noexcept 이동 대입 연산자
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete[] data_;
            data_ = other.data_;
            size_ = other.size_;
            other.data_ = nullptr;
            other.size_ = 0;
            std::cout << "리소스 이동 대입" << std::endl;
        }
        return *this;
    }
    
    // 복사 방지
    Resource(const Resource&) = delete;
    Resource& operator=(const Resource&) = delete;
};

int main() {
    std::vector<Resource> resources;
    
    // noexcept 이동 덕분에 vector 재할당 시 효율적
    resources.emplace_back(100);
    resources.emplace_back(200);
    resources.emplace_back(300);
    
    return 0;
}
```

### 스레드와 예외

```cpp
#include <thread>
#include <iostream>
#include <stdexcept>
#include <future>

void worker_function() {
    throw std::runtime_error("스레드 내부 에러!");
}

int main() {
    // 방법 1: 스레드에서 직접 처리
    std::thread t1([]() {
        try {
            worker_function();
        } catch (const std::exception& e) {
            std::cerr << "스레드에서 잡은 에러: " << e.what() << std::endl;
        }
    });
    t1.join();
    
    // 방법 2: std::future를 통한 예외 전달
    auto future = std::async(std::launch::async, []() {
        worker_function();
        return 42;
    });
    
    try {
        int result = future.get();  // 여기서 스레드 예외가 전달됨
        std::cout << "결과: " << result << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "메인에서 잡은 에러: " << e.what() << std::endl;
    }
    
    return 0;
}
```

---

## 제6장: 예외 처리의 실전 패턴

### 패턴 1: 리소스 관리자

```cpp
#include <memory>
#include <functional>

template<typename Resource, typename Deleter>
class ScopedResource {
    Resource resource_;
    Deleter deleter_;
    
public:
    ScopedResource(Resource resource, Deleter deleter)
        : resource_(resource), deleter_(deleter) {}
    
    ~ScopedResource() {
        if (resource_) {
            deleter_(resource_);
        }
    }
    
    // 복사 방지
    ScopedResource(const ScopedResource&) = delete;
    ScopedResource& operator=(const ScopedResource&) = delete;
    
    // 이동 허용
    ScopedResource(ScopedResource&& other) noexcept
        : resource_(other.resource_), deleter_(std::move(other.deleter_)) {
        other.resource_ = Resource{};
    }
    
    Resource get() const { return resource_; }
    explicit operator bool() const { return static_cast<bool>(resource_); }
};

// 사용 예시
void database_transaction() {
    // 데이터베이스 연결
    auto db_conn = open_database_connection();
    auto db_guard = ScopedResource(db_conn, [](auto conn) {
        close_database_connection(conn);
    });
    
    // 트랜잭션 시작
    begin_transaction(db_conn);
    auto transaction_guard = ScopedResource(db_conn, [](auto conn) {
        rollback_transaction(conn);
    });
    
    // 작업 수행
    execute_query(db_conn, "UPDATE accounts SET balance = balance - 100 WHERE id = 1");
    execute_query(db_conn, "UPDATE accounts SET balance = balance + 100 WHERE id = 2");
    
    // 모든 작업 성공 시 커밋
    commit_transaction(db_conn);
    transaction_guard = nullptr;  // 롤백하지 않도록 무효화
}
```

### 패턴 2: 팩토리 함수와 예외

```cpp
#include <memory>
#include <string>
#include <vector>
#include <stdexcept>

class ConfigParser {
public:
    // 팩토리 메서드 패턴
    static std::unique_ptr<ConfigParser> create(const std::string& config_path) {
        auto parser = std::unique_ptr<ConfigParser>(new ConfigParser());
        
        try {
            parser->load_config(config_path);
            parser->validate_config();
            return parser;
        } catch (...) {
            // 생성 실패 시 자원 정리
            throw;
        }
    }
    
    void process() {
        // 작업 수행
    }
    
private:
    ConfigParser() = default;  // 생성자 private
    
    void load_config(const std::string& path) {
        if (path.empty()) {
            throw std::invalid_argument("설정 파일 경로가 비어있습니다");
        }
        // 파일 로드...
    }
    
    void validate_config() {
        // 설정 검증...
        if (/* 검증 실패 */) {
            throw std::runtime_error("설정 검증 실패");
        }
    }
    
    std::vector<std::string> config_data_;
};

// 사용 예시
void application_startup() {
    try {
        auto config = ConfigParser::create("app.conf");
        config->process();
    } catch (const std::exception& e) {
        std::cerr << "애플리케이션 시작 실패: " << e.what() << std::endl;
        // 정리 작업 수행
    }
}
```

---

## 결론: 현명한 예외 처리의 원칙

### 1. **예외는 진짜 예외적인 상황에만 사용하세요**
   - 예측 가능한 오류(파일 없음, 잘못된 입력)는 예외보다는 `std::optional`이나 `std::expected`를 사용하세요
   - 예외는 프로그램이 정상적으로 계속될 수 없는 상황에 사용하세요

### 2. **RAII를 철저히 적용하세요**
   - 모든 자원은 객체 수명에 묶어 관리하세요
   - 생성자에서 자원 획득, 소멸자에서 자원 해제
   - 스마트 포인터를 적극 활용하세요

### 3. **적절한 예외 타입을 선택하세요**
   - 가능하면 표준 예외를 사용하세요
   - 도메인 특화 예외가 필요하면 `std::exception`에서 상속받으세요
   - 예외에 충분한 정보를 담으세요

### 4. **예외 안전 보장 수준을 명시하세요**
   - 함수의 예외 안전 보장 수준을 문서화하세요
   - 가능하면 강력 보장(strong guarantee)을 제공하세요
   - 이동 연산에는 `noexcept`를 사용하세요

### 5. **예외를 적절한 수준에서 처리하세요**
   - 저수준 함수에서는 예외를 처리하지 말고 전파하세요
   - 애플리케이션 진입점에서는 모든 예외를 처리하세요
   - 중첩 예외를 사용해 에러 컨텍스트를 보존하세요

### 6. **소멸자에서는 예외를 던지지 마세요**
   - 소멸자에서는 예외를 잡아서 처리하세요
   - 예외를 던질 수 있는 작업은 별도의 메서드로 분리하세요

### 7. **성능과 안전성의 균형을 유지하세요**
   - 예외 처리는 비용이 드는 작업입니다
   - 성능이 중요한 루프에서는 예외 사용을 피하세요
   - 하지만 안전성을 위해 필요한 곳에서는 과감히 사용하세요

예외 처리는 단순한 기술이 아닌, 소프트웨어 설계 철학입니다. 올바른 예외 처리 전략은 코드의 안정성, 유지보수성, 가독성을 크게 향상시킵니다. C++의 강력한 예외 처리 메커니즘을 이해하고 현명하게 활용하면, 더 견고하고 신뢰할 수 있는 소프트웨어를 만들 수 있습니다.

기억하세요: 좋은 예외 처리 코드는 문제가 발생했을 때 사용자에게 명확한 메시지를 제공하고, 시스템을 안전하게 정리하며, 디버깅을 용이하게 합니다. 이것이 예외 처리의 진정한 가치입니다.