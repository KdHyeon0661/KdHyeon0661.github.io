---
layout: post
title: HTML - HTML5의 특수 폼
date: 2025-03-26 19:20:23 +0900
category: HTML
---
# HTML5의 특수 폼 요소들

## 1. `<datalist>` — “목록 제안 + 직접 입력” 자동완성

### 1.1 개요
- `<input>`에 `list` 속성을 연결하면 `<datalist>`가 **후보 옵션을 제안**한다.
- **선택과 자유 입력을 모두 허용**한다(= `<select>`와 다른 점).
- 브라우저 **내장 자동완성**과는 별개(폼 히스토리/패스워드 매니저 등과는 구분).

### 1.2 기본 문법
```html
<label for="fruit">과일 선택 또는 입력</label>
<input id="fruit" name="fruit" list="fruits" placeholder="입력 또는 선택" />

<datalist id="fruits">
  <option value="Apple"></option>
  <option value="Banana"></option>
  <option value="Cherry"></option>
</datalist>
```

**핵심 포인트**
- `<input list="…">`의 값은 **옵션 외 값도 허용**.
- `<option>`은 `value`만 사용(표시 라벨은 value 자체가 된다). 표시는 브라우저가 렌더링.

### 1.3 고급: 값/라벨 분리 및 메타데이터 보조
`<datalist>` 자체는 “값/라벨” 분리를 직접 지원하지 않으므로, **접근성 텍스트·ARIA·제안 설명**을 보조적으로 붙인다.

```html
<label for="lang">언어 선택</label>
<input id="lang" name="lang" list="langs" aria-describedby="lang-help" />

<small id="lang-help">권장: ISO 코드(예: en, ko, ja)</small>

<datalist id="langs">
  <option value="en">영어</option><!-- 일부 브라우저는 option 텍스트를 힌트로 보여주기도 함 -->
  <option value="ko">한국어</option>
  <option value="ja">일본어</option>
</datalist>
```

### 1.4 서버/대용량 후보: 페치 + 동적 채우기(PE)
대량 후보는 **입력 이벤트에 따라 서버에서 JSON을 가져와 `<datalist>` 갱신**.

```html
<label for="city">도시</label>
<input id="city" name="city" list="cities" autocomplete="off" />
<datalist id="cities"></datalist>

<script>
  const ipt = document.getElementById('city');
  const box = document.getElementById('cities');
  let handle;

  ipt.addEventListener('input', () => {
    clearTimeout(handle);
    const q = ipt.value.trim();
    if (q.length < 2) { box.innerHTML = ''; return; } // 최소 글자수

    handle = setTimeout(async () => {
      const resp = await fetch(`/api/cities?q=${encodeURIComponent(q)}`);
      const items = await resp.json(); // ["Seoul","Seongnam","Seattle",...]
      box.innerHTML = items
        .slice(0, 20)
        .map(v => `<option value="${v}"></option>`)
        .join('');
    }, 200); // debounce
  });
</script>
```

**검증 팁**
- **서버에서는 항상 값 검증**(제안 목록이라고 해서 신뢰하면 X).
- DB 인덱스/레이트리밋/캐시 고려.

### 1.5 접근성/국제화 팁
- `label` 연결 필수(`for` ↔ `id`).
- 다국어/RTL(오른쪽→왼쪽) 입력 시 `<input dir="auto">` 고려.
- 모바일 OS 키보드 힌트가 중요한 경우 `inputmode`(예: `inputmode="numeric"`).

### 1.6 브라우저 지원/대안
- **지원**: 최신 브라우저 대부분.
- **미지원 환경(매우 구형)**: `<datalist>`를 무시하고 일반 입력으로 동작 → **PE** 성격 상 문제 없음.
- 완전한 “선택 전용”이 목적이면 `<select>` 사용.

---

## 2. `<keygen>` — 클라이언트 키생성(폐지됨)

### 2.1 현재 상태(요약)
- HTML5에서 도입되었으나 **HTML 5.2에서 폐지**, 주요 브라우저에서 **제거됨**.
- 실무 사용 **비권장**. 대안은 **WebAuthn**, **WebCrypto API**, **플랫폼/보안토큰 기반 인증**.

### 2.2 과거 의도/문법(참고용)
```html
<!-- 비권장/비지원: 예전 문법 참조용 -->
<form action="/submit-key" method="post">
  사용자 인증용 키:
  <keygen name="userKey" challenge="nonce-123" keytype="rsa" keyparams="modulusLength=2048" />
  <button type="submit">제출</button>
</form>
```

### 2.3 왜 사라졌나?
- 개인키 저장소/수명/이전 등 **보안 UX 제어 불명확**.
- 상호운용성 낮고, 기업 인증 체계와 충돌.
- 표준화 커뮤니티에서 **WebAuthn/FIDO** 라인으로 정리.

### 2.4 현대적 대안

#### (A) WebAuthn(권장) — 패스키/보안키 기반
- **피싱 저항**, 도메인 결속(origin-bound), 생체/보안키.
- 서버는 **챌린지 기반 등록/인증**을 구현.

```html
<!-- 예시: 등록 흐름(간략 데모) -->
<button id="reg">패스키 등록</button>
<script>
  document.getElementById('reg').addEventListener('click', async () => {
    // 1) 서버로부터 공용키 자격생성옵션(챌린지 등) 수신
    const creationOptions = await (await fetch('/webauthn/register/options')).json();

    // 2) 브라우저/플랫폼 인증자 호출
    creationOptions.publicKey.challenge = Uint8Array.from(atob(creationOptions.publicKey.challenge), c => c.charCodeAt(0));
    const cred = await navigator.credentials.create(creationOptions);

    // 3) 서버에 결과 전송(등록 완료)
    const res = await fetch('/webauthn/register/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(cred)
    });
    alert(res.ok ? '등록 성공' : '등록 실패');
  });
</script>
```

#### (B) WebCrypto API — 앱 내부 키쌍 생성/서명
- 인증 프로토콜은 **직접 설계**해야 하므로 난이도↑.
- 토큰 관리/백업/회수는 **앱 책임**.

```html
<script>
(async () => {
  // 키쌍 생성(RSASSA-PKCS1-v1_5 예시)
  const keyPair = await crypto.subtle.generateKey(
    { name: 'RSASSA-PKCS1-v1_5', modulusLength: 2048, publicExponent: new Uint8Array([1,0,1]), hash: 'SHA-256' },
    true,
    ['sign', 'verify']
  );

  // 공개키 내보내 서버 등록
  const spki = await crypto.subtle.exportKey('spki', keyPair.publicKey);
  // base64 등으로 인코딩 후 서버에 저장

  // 서버가 준 챌린지를 서명
  const challenge = new TextEncoder().encode('server-challenge-123');
  const signature = await crypto.subtle.sign({ name: 'RSASSA-PKCS1-v1_5' }, keyPair.privateKey, challenge);
  // signature 전송 → 서버가 공개키로 검증
})();
</script>
```

**실무 권장**: 인증은 **WebAuthn**. 자체 PKI를 최소화하고 **플랫폼 보안**을 활용.

---

## 3. `<output>` — 계산/검증 결과의 “표준 출력 상자”

### 3.1 개요
- **읽기 전용 출력 요소**(사용자 입력 불가).
- `name`이 있으면 폼 제출 시 값 포함 가능(서버에서 참조).
- `for` 속성으로 **관련 컨트롤**을 묶어 의미를 명확히 함.

### 3.2 즉시 연산(속성 oninput 활용)
```html
<form oninput="total.value = Number(a.value||0) + Number(b.value||0)">
  <label for="a">A</label>
  <input type="number" id="a" name="a" value="0" />
   +
  <label for="b">B</label>
  <input type="number" id="b" name="b" value="0" />
   =
  <output id="total" name="total" for="a b">0</output>
  <button>제출</button>
</form>
```

- **장점**: 매우 간단(무JS 또는 한 줄).
- **서버 연동**: 제출 시 `total=<계산값>`으로 함께 전송(참고용—**진실의 원천은 서버 계산**이어야 한다).

### 3.3 JS 이벤트로 갱신(복잡 로직/검증 메시지)
```html
<form id="order">
  <label for="price">단가</label>
  <input id="price" type="number" min="0" step="100" value="1000" required />

  <label for="qty">수량</label>
  <input id="qty" type="number" min="1" step="1" value="1" required />

  <p>합계: <output id="sum" name="sum" for="price qty">1000</output> 원</p>
  <p id="warn" role="alert" aria-live="polite"></p>

  <button type="submit">주문</button>
</form>

<script>
  const price = document.getElementById('price');
  const qty   = document.getElementById('qty');
  const sum   = document.getElementById('sum');
  const warn  = document.getElementById('warn');

  function recalc() {
    const p = Number(price.value);
    const q = Number(qty.value);
    if (Number.isFinite(p) && Number.isFinite(q) && p >= 0 && q >= 1) {
      const total = p * q;
      sum.value = total.toLocaleString('ko-KR');
      warn.textContent = '';
    } else {
      sum.value = '';
      warn.textContent = '입력값을 확인하세요(단가≥0, 수량≥1).';
    }
  }
  price.addEventListener('input', recalc);
  qty.addEventListener('input', recalc);
  recalc();

  // 서버 신뢰 원칙: 제출 시 서버가 다시 계산/검증
  document.getElementById('order').addEventListener('submit', (e) => {
    // e.preventDefault() // 실제 제출 테스트 시 주석 처리
  });
</script>
```

**접근성**
- 결과가 바뀔 때 스크린리더 공지 필요하면 `aria-live="polite"`인 메시지 영역을 사용.

### 3.4 폼 외부/다중 관련 컨트롤
- `<output for="id1 id2 …">`는 **관계 의미**를 제공(필수는 아님).
- `<fieldset>`/`<legend>`와 함께 쓰면 그룹 의미 강화.

---

## 4. 보안·유효성·서버 연동 가이드

### 4.1 공통 원칙
- **클라이언트 값은 신뢰 금지**. `<datalist>/<output>`의 값도 사용자 조작 가능.
- 서버에서 **유효성 검사/정규화/권한 검증** 필수.
- 제출 전 **중복 제출 방지**(disable 버튼/토큰)와 **CSRF 방지** 적용.

### 4.2 XSS/DOM 인젝션 주의
- `<datalist>` 후보를 서버 데이터로 채울 때 **HTML 이스케이프**.
- `<output>`에 넣는 문자열도 `textContent` 사용 권장. HTML 주입 금지.

```html
<script>
// 안전한 옵션 생성
function toOption(val) {
  const opt = document.createElement('option');
  opt.value = String(val);
  return opt;
}
</script>
```

### 4.3 국제화/숫자 포맷
- `<output>`에 숫자 표시 시 `toLocaleString('ko-KR')` 등 사용.  
- 서버와 **통화/세금 계산**은 **정확한 기준(소수점/반올림 규칙)**을 합의.

---

## 5. 실전 패턴 / 반패턴

### 5.1 패턴(권장)
- **검색/추천 입력**: `<input list="…">` + 서버 페치 + 디바운스.
- **요약값/미리보기**: `<output>`로 즉시 피드백(접근성 메시지 동반).
- **PE 설계**: `<datalist>` 미지원 시에도 텍스트 입력으로 동작.

### 5.2 반패턴(지양)
- `<datalist>`를 “선택 강제” 용도로 사용(값 자유 입력 허용 특성과 충돌) → **필수 선택**이면 `<select>`.
- `<output>`을 **서버 신뢰의 근거**로 사용(= 숨은 가격 조작 가능).
- `<keygen>` 사용(폐지). 인증은 **WebAuthn**으로 치환.

---

## 6. 통합 예제 — 자동완성 + 합계 출력 + 서버 제출

```html
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>자동완성 + 합계 출력</title>
<style>
  body { font-family: system-ui, sans-serif; padding: 1rem; }
  label { display:block; margin-top: .75rem; }
  .row { display:flex; gap: .5rem; align-items: center; flex-wrap: wrap; }
  output { padding: .1rem .4rem; background: #f4f6fb; border-radius: .25rem; }
  button { margin-top: 1rem; padding: .5rem 1rem; }
</style>
</head>
<body>

<form id="purchase" method="post" action="/orders">
  <label for="item">상품</label>
  <input id="item" name="item" list="items" placeholder="상품명 입력 또는 선택" required />
  <datalist id="items"></datalist>

  <div class="row">
    <label for="price">단가(원)</label>
    <input id="price" name="price" type="number" min="0" step="100" required />

    <label for="qty">수량</label>
    <input id="qty" name="qty" type="number" min="1" step="1" value="1" required />

    <span>합계:</span>
    <output id="total" name="total" for="price qty">0</output> 원
  </div>

  <p id="msg" role="status" aria-live="polite"></p>

  <button type="submit">주문하기</button>
</form>

<script>
  // 1) datalist 동적 채움(서버 추천)
  const itemIpt = document.getElementById('item');
  const itemsBox = document.getElementById('items');
  let t;
  itemIpt.addEventListener('input', () => {
    clearTimeout(t);
    const q = itemIpt.value.trim();
    if (q.length < 2) { itemsBox.innerHTML = ''; return; }
    t = setTimeout(async () => {
      const r = await fetch('/api/items?q=' + encodeURIComponent(q));
      const arr = await r.json(); // [{name:'USB-C 케이블', price:7900}, ...]
      itemsBox.innerHTML = '';
      for (const it of arr.slice(0, 20)) {
        const opt = document.createElement('option');
        opt.value = it.name;
        // 일부 브라우저는 텍스트를 힌트로 보여주므로 부가 설명
        opt.textContent = `₩${(it.price||0).toLocaleString('ko-KR')}`;
        itemsBox.appendChild(opt);
      }
    }, 200);
  });

  // 2) output 합계 계산
  const price = document.getElementById('price');
  const qty   = document.getElementById('qty');
  const total = document.getElementById('total');
  const msg   = document.getElementById('msg');

  function recalc() {
    const p = Number(price.value);
    const q = Number(qty.value);
    if (Number.isFinite(p) && Number.isFinite(q) && p >= 0 && q >= 1) {
      const s = p * q;
      total.value = s.toLocaleString('ko-KR');
      msg.textContent = `현재 합계는 ₩${total.value} 입니다.`;
    } else {
      total.value = '0';
      msg.textContent = '입력값을 확인하세요.';
    }
  }
  price.addEventListener('input', recalc);
  qty.addEventListener('input', recalc);
  recalc();

  // 3) 제출 시 서버 신뢰 원칙: 서버가 최종 계산/검증
  document.getElementById('purchase').addEventListener('submit', (e) => {
    // e.preventDefault(); // 테스트 시 활성화
  });
</script>

</body>
</html>
```

---

## 7. 비교 요약표

| 요소 | 핵심 용도 | 사용자 입력 | 폼 전송 | 접근성 포인트 | 지원 |
|---|---|---|---|---|---|
| `<datalist>` | 입력 제안(자동완성) | 자유 입력 + 제안 | `<input>` 값 전송 | `label` 연결, 힌트 텍스트/설명 제공 | 최신 브라우저 대부분 |
| `<keygen>` | 클라이언트 키쌍 생성 | 자동 생성 | 공개키 제출 | 폐지됨(대안: WebAuthn) | 지원 중단 |
| `<output>` | 계산/검증 결과 출력 | 직접 입력 불가 | `name` 있을 때 전송 | `aria-live`로 변화 알림 | 널리 지원 |

---

## 8. 체크리스트

- [ ] `<datalist>`: 후보는 **제안용**. 값은 **서버에서 검증**. 대량 후보는 **동적 페치 + 디바운스**.  
- [ ] `<output>`: **읽기 전용** 시각 피드백. 제출 값은 **참고용**이며, **서버 재계산** 필수.  
- [ ] `<keygen>`: 사용 금지. **WebAuthn** 또는 **WebCrypto**로 대체.  
- [ ] a11y: `label for=`, `aria-live`, 도움말 텍스트(`aria-describedby`).  
- [ ] i18n: 숫자/통화는 `toLocaleString`, 입력 방향 `dir="auto"` 고려.  
- [ ] 보안: XSS 방지(텍스트로 주입), CSRF/중복제출 방지, 레이트리밋.  

---

## 9. 결론

- **`<datalist>`**는 “검색/추천/자동완성”에 훌륭한 **PE 컴포넌트**로, JS 없이도 UX를 크게 개선한다.  
- **`<output>`**은 계산/검증/요약 피드백을 **표준 방식**으로 표현하며, 접근성 향상에 유리하다.  
- **`<keygen>`**은 역사적 유물. **WebAuthn**으로 전환해 **보안성과 사용자 경험**을 동시에 얻자.  

이 세 요소를 올바르게 이해하고 배치하면, **간결한 코드로도 풍부한 폼 UX**를 구현할 수 있다. 특히 `<datalist>`+동적 페치, `<output>`+접근성 메시지 조합은 **현대 웹 폼의 모범 사례**로 적극 권장된다.