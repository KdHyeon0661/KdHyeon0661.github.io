---
layout: post
title: C++ - STL (5)
date: 2024-09-16 19:20:23 +0900
category: Cpp
---
# STL 5 — `pair`, `tuple`, `tie`: 데이터 묶음의 예술

## 서론: 왜 여러 값을 하나로 묶어야 하는가?

프로그래밍에서 우리는 종종 여러 값을 하나의 논리적 단위로 다루어야 합니다. 두 점의 좌표, 이름과 나이, 성공/실패 플래그와 결과값... 이러한 데이터 조각들을 효율적이고 안전하게 다루기 위해 C++는 세 가지 강력한 도구를 제공합니다: `std::pair`, `std::tuple`, 그리고 `std::tie`. 이들은 단순히 값을 묶는 것을 넘어, 현대 C++의 표현력과 효율성을 극대화하는 핵심 요소입니다.

---

## 제1장: `std::pair` — 단순함 속의 우아함

### 기본 개념: 두 값의 완벽한 동반자

`std::pair`는 이름 그대로 두 개의 값을 하나로 묶는 가장 간단한 방법입니다. 첫 번째 값은 `first`, 두 번째 값은 `second` 멤버를 통해 접근합니다.

```cpp
#include <utility>
#include <string>
#include <iostream>

int main() {
    // 다양한 생성 방법
    std::pair<int, std::string> p1(42, "Answer");
    auto p2 = std::make_pair(3.14, "Pi");  // 타입 추론
    std::pair p3{100, "Percent"};          // C++17 클래스 템플릿 인자 추론
    
    // 구조적 바인딩으로 우아한 접근
    auto [number, text] = p1;
    std::cout << number << " is " << text << "\n";  // 42 is Answer
}
```

### 왜 pair가 중요한가?

1. **표준 라이브러리의 기본 구성 요소**: `std::map`의 요소, `std::set`의 비교자 등
2. **함수 반환값으로의 활용**: 두 개의 값을 반환해야 할 때 완벽한 솔루션
3. **간결성과 명확성**: 두 값만 다룰 때는 구조체보다 더 간결

### map과의 깊은 관계

```cpp
#include <map>
#include <iostream>

int main() {
    std::map<std::string, int> scores;
    scores["Alice"] = 95;
    
    // map의 반복자가 가리키는 것은 pair<const key_type, mapped_type>
    for (const auto& [name, score] : scores) {  // 구조적 바인딩
        std::cout << name << ": " << score << "\n";
    }
    
    // insert의 반환값도 pair입니다
    auto [iter, success] = scores.insert({"Bob", 88});
    if (success) {
        std::cout << "Inserted successfully\n";
    }
}
```

**중요한 사실**: `map`의 `first` 멤버는 `const`입니다. 키는 변경할 수 없습니다.

### 고급 기법: `piecewise_construct`

효율성을 극대화하고 싶을 때 사용하는 고급 기법입니다:

```cpp
#include <map>
#include <tuple>
#include <string>

int main() {
    std::map<std::string, std::string> dictionary;
    
    // 일반적인 방법: 임시 객체 생성
    dictionary.emplace("hello", "world");
    
    // piecewise_construct: 인자만 전달하여 내부에서 직접 생성
    dictionary.emplace(
        std::piecewise_construct,
        std::forward_as_tuple("complex", 7, 'k'),  // "complex" 문자열 생성
        std::forward_as_tuple(50, 'x')             // "xxxxx..." 문자열 생성
    );
}
```

이 기법은 복잡한 생성자를 가진 객체를 `map`에 삽입할 때 임시 객체 생성을 피할 수 있습니다.

---

## 제2장: `std::tuple` — 유연성의 정점

### 기본 사용법: 여러 타입의 값을 하나로

`tuple`은 0개 이상의 임의 타입 값을 저장할 수 있는 일반화된 `pair`입니다:

```cpp
#include <tuple>
#include <string>
#include <iostream>

int main() {
    // 다양한 생성 방법
    std::tuple<int, std::string, double> t1(1, "Alice", 95.5);
    auto t2 = std::make_tuple(2, "Bob", 88.0);
    std::tuple t3{3, "Charlie", 92.5};  // C++17 클래스 템플릿 인자 추론
    
    // get<>을 사용한 접근 (컴파일 타임 인덱스!)
    std::cout << std::get<0>(t1) << "\n";  // 1
    std::cout << std::get<1>(t1) << "\n";  // Alice
    std::cout << std::get<2>(t1) << "\n";  // 95.5
    
    // 구조적 바인딩 (C++17)
    auto [id, name, score] = t1;
    std::cout << id << ": " << name << " - " << score << "\n";
}
```

### tuple의 강력한 비교 연산

`tuple`은 `pair`와 마찬가지로 사전식 비교를 지원합니다:

```cpp
#include <tuple>
#include <iostream>

int main() {
    std::tuple<int, std::string> a{1, "apple"};
    std::tuple<int, std::string> b{2, "banana"};
    std::tuple<int, std::string> c{1, "apricot"};
    
    std::cout << std::boolalpha;
    std::cout << (a < b) << "\n";  // true (1 < 2)
    std::cout << (a < c) << "\n";  // true ("apple" < "apricot")
}
```

### 다중 반환값: 함수의 새로운 가능성

```cpp
#include <tuple>
#include <string>
#include <algorithm>
#include <vector>

// 최소값, 최대값, 평균을 한 번에 반환
std::tuple<int, int, double> analyze(const std::vector<int>& data) {
    if (data.empty()) return {0, 0, 0.0};
    
    auto [min_it, max_it] = std::minmax_element(data.begin(), data.end());
    double sum = std::accumulate(data.begin(), data.end(), 0.0);
    
    return {*min_it, *max_it, sum / data.size()};
}

int main() {
    std::vector<int> numbers{10, 20, 30, 40, 50};
    auto [minimum, maximum, average] = analyze(numbers);
    
    std::cout << "Min: " << minimum << ", Max: " << maximum 
              << ", Avg: " << average << "\n";
}
```

---

## 제3장: `std::tie` — 참조의 마법

### 기본 개념: 기존 변수에 값을 바인딩

`std::tie`는 기존 변수들의 참조를 튜플로 묶어, 다른 튜플로부터 값을 받아올 수 있게 합니다:

```cpp
#include <tuple>
#include <string>
#include <iostream>

std::tuple<int, std::string, bool> get_user_info() {
    return {42, "Alice", true};
}

int main() {
    int id;
    std::string name;
    bool active;
    
    // 기존 변수들에 튜플 값 대입
    std::tie(id, name, active) = get_user_info();
    
    std::cout << "ID: " << id << ", Name: " << name 
              << ", Active: " << std::boolalpha << active << "\n";
    
    // 일부 값 무시하기
    std::tie(id, std::ignore, active) = get_user_info();
}
```

### 비교 연산 간소화의 비밀 무기

`std::tie`는 사용자 정의 타입의 비교 연산자를 간결하게 작성할 수 있게 해줍니다:

```cpp
#include <tuple>
#include <string>

struct Person {
    std::string first_name;
    std::string last_name;
    int age;
    
    // 전통적인 방법 (장황하고 실수하기 쉬움)
    bool operator<(const Person& other) const {
        if (last_name != other.last_name)
            return last_name < other.last_name;
        if (first_name != other.first_name)
            return first_name < other.first_name;
        return age < other.age;
    }
    
    // std::tie를 사용한 방법 (간결하고 안전)
    bool operator<(const Person& other) const {
        return std::tie(last_name, first_name, age) 
             < std::tie(other.last_name, other.first_name, other.age);
    }
};
```

### 구조적 바인딩 vs std::tie

| 상황 | 권장 방법 | 예시 |
|------|-----------|------|
| **새 변수 선언** | 구조적 바인딩 | `auto [x, y] = point;` |
| **기존 변수에 할당** | `std::tie` | `std::tie(x, y) = point;` |
| **일부 값 무시** | `std::tie` + `std::ignore` | `std::tie(x, std::ignore) = data;` |

---

## 제4장: 고급 패턴과 실전 활용

### tuple의 메타프로그래밍

`tuple`은 컴파일 타임 정보를 가지고 있어 다양한 메타프로그래밍 기법에 활용됩니다:

```cpp
#include <tuple>
#include <iostream>

// tuple의 크기와 타입 정보
void inspect_tuple() {
    using MyTuple = std::tuple<int, std::string, double>;
    
    constexpr size_t size = std::tuple_size<MyTuple>::value;
    std::cout << "Tuple size: " << size << "\n";  // 3
    
    using FirstType = std::tuple_element<0, MyTuple>::type;
    std::cout << "First type is int? " 
              << std::is_same_v<FirstType, int> << "\n";  // true
}
```

### apply: 튜플을 함수 인자로 전환

C++17의 `std::apply`는 튜플을 함수 인자로 풀어줍니다:

```cpp
#include <tuple>
#include <iostream>

void print_details(int id, const std::string& name, double score) {
    std::cout << "ID: " << id << ", Name: " << name 
              << ", Score: " << score << "\n";
}

int main() {
    auto data = std::make_tuple(101, "Alice", 95.5);
    
    // 튜플을 함수 인자로 전달
    std::apply(print_details, data);
    
    // 람다와 함께 사용
    auto sum = std::apply([](int a, int b, int c) { return a + b + c; },
                          std::make_tuple(1, 2, 3));
    std::cout << "Sum: " << sum << "\n";  // 6
}
```

### 사용자 정의 타입에 구조적 바인딩 적용하기

사용자 정의 타입도 구조적 바인딩을 지원하도록 만들 수 있습니다:

```cpp
#include <tuple>

class Vector3D {
private:
    float x_, y_, z_;
    
public:
    Vector3D(float x, float y, float z) : x_(x), y_(y), z_(z) {}
    
    // getter 함수들
    float x() const { return x_; }
    float y() const { return y_; }
    float z() const { return z_; }
    
    // 구조적 바인딩 지원을 위한 특수화
    template<std::size_t I>
    auto get() const {
        if constexpr (I == 0) return x();
        else if constexpr (I == 1) return y();
        else if constexpr (I == 2) return z();
    }
};

// tuple_size 특수화
namespace std {
    template<> struct tuple_size<Vector3D> : integral_constant<size_t, 3> {};
    
    template<size_t I> struct tuple_element<I, Vector3D> {
        using type = float;
    };
}

int main() {
    Vector3D v{1.0f, 2.0f, 3.0f};
    auto [x, y, z] = v;  // 이제 구조적 바인딩 가능!
}
```

---

## 제5장: 실전 시나리오와 모범 사례

### 시나리오 1: 데이터베이스 레코드 처리

```cpp
#include <tuple>
#include <vector>
#include <algorithm>
#include <iostream>

struct Employee {
    int id;
    std::string name;
    std::string department;
    double salary;
    
    // 다중 기준 정렬을 위한 비교 연산자
    bool operator<(const Employee& other) const {
        // 부서별, 급여 내림차순, 이름 오름차순
        return std::tie(department, std::negate<>()(salary), name)
             < std::tie(other.department, std::negate<>()(other.salary), other.name);
    }
};

void process_employees() {
    std::vector<Employee> employees = {
        {1, "Alice", "Engineering", 85000},
        {2, "Bob", "Sales", 75000},
        {3, "Charlie", "Engineering", 90000},
        {4, "Diana", "Sales", 80000}
    };
    
    std::sort(employees.begin(), employees.end());
    
    for (const auto& emp : employees) {
        std::cout << emp.department << ": " << emp.name 
                  << " - $" << emp.salary << "\n";
    }
}
```

### 시나리오 2: 설정값 관리

```cpp
#include <tuple>
#include <optional>
#include <iostream>

class Configuration {
private:
    struct Settings {
        std::optional<int> timeout;
        std::optional<std::string> host;
        std::optional<bool> debug_mode;
    } settings_;
    
public:
    // 여러 설정값을 한 번에 업데이트
    void update_settings(int timeout, const std::string& host, bool debug) {
        auto [old_timeout, old_host, old_debug] = get_current_settings();
        
        settings_.timeout = timeout;
        settings_.host = host;
        settings_.debug_mode = debug;
        
        std::cout << "Settings updated from: "
                  << old_timeout.value_or(0) << ", " 
                  << old_host.value_or("default") << ", "
                  << old_debug.value_or(false) << "\n";
    }
    
    // 현재 설정값을 튜플로 반환
    std::tuple<std::optional<int>, 
               std::optional<std::string>, 
               std::optional<bool>> get_current_settings() const {
        return {settings_.timeout, settings_.host, settings_.debug_mode};
    }
};
```

### 시나리오 3: 에러 처리와 결과 전달

```cpp
#include <tuple>
#include <string>
#include <variant>
#include <iostream>

// 결과 또는 에러를 반환하는 함수
std::tuple<bool, std::variant<int, std::string>> 
parse_number(const std::string& input) {
    try {
        int value = std::stoi(input);
        return {true, value};
    } catch (const std::exception& e) {
        return {false, std::string("Parse error: ") + e.what()};
    }
}

int main() {
    auto [success, result] = parse_number("123");
    
    if (success) {
        int value = std::get<int>(result);
        std::cout << "Parsed value: " << value << "\n";
    } else {
        std::string error = std::get<std::string>(result);
        std::cout << error << "\n";
    }
}
```

---

## 결론: 올바른 도구 선택을 위한 원칙

데이터를 묶는 세 가지 도구는 각각의 명확한 사용 사례가 있습니다:

### 1. **`std::pair`를 선택할 때**
   - 딱 두 개의 값만 관련이 있을 때
   - `map`의 요소나 `insert`의 반환값처럼 라이브러리와의 호환성이 필요할 때
   - 단순함과 명확성이 최우선일 때

### 2. **`std::tuple`을 선택할 때**
   - 세 개 이상의 값을 묶어야 할 때
   - 타입이 각기 다를 때
   - 컴파일 타임에 크기가 고정된 컨테이너가 필요할 때
   - 메타프로그래밍이나 `apply`와 같은 고급 기능이 필요할 때

### 3. **`std::tie`를 선택할 때**
   - 기존 변수들에 튜플 값을 할당해야 할 때
   - 비교 연산자를 간결하게 작성하고 싶을 때
   - 튜플의 일부 값만 필요할 때 (`std::ignore`와 함께)

### 최종 조언: 가독성을 잊지 마세요

`tuple`은 강력하지만, 인덱스 기반 접근(`get<0>`, `get<1>`)은 코드의 가독성을 해칠 수 있습니다. 세 개 이상의 값을 묶을 때, 그리고 그 값들이 명확한 의미를 가질 때는 **구조체를 고려하세요**. 구조적 바인딩은 구조체에서도 동작하며, 의미 있는 멤버 이름을 제공합니다.

기억하세요: 기술적 능력은 코드를 작동하게 만드는 것이고, 설계 감각은 코드를 이해하기 쉽게 만드는 것입니다. `pair`, `tuple`, `tie`는 모두 훌륭한 도구이지만, 올바른 상황에 올바른 도구를 선택하는 것이 진정한 전문가의 길입니다.