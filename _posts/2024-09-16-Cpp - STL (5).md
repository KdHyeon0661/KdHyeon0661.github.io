---
layout: post
title: C++ - STL (5)
date: 2024-09-16 19:20:23 +0900
category: Cpp
---
# STL 5 — `pair`, `tuple`, `tie`

## 0. 한 줄 정의

- **`std::pair<T1,T2>`**: “딱 2개”의 관련 값을 묶는 소형 구조체. 멤버는 `first`, `second`.
- **`std::tuple<Ts...>`**: “N개(0개 이상)”의 이종(heterogeneous) 값 묶음. 인덱스 기반 접근.
- **`std::tie(refs...)`**: **참조 튜플**을 만들어 기존 변수들에 **분해 대입**하기 위한 유틸. 일부는 `std::ignore`.

---

## 1. `std::pair` — 가장 널리 쓰이는 2-원 묶음

### 1.1 생성/접근/비교

```cpp
#include <utility>
#include <string>
#include <iostream>
using namespace std;

int main() {
    pair<int, string> p1(1, "apple");       // 직접 생성
    auto p2 = make_pair(2, string("pear"));  // make_pair + type deduction
    cout << p1.first << ", " << p1.second << "\n";  // 1, apple

    // 사전식 비교: first 먼저, 같으면 second
    pair<int,int> a{1,2}, b{1,3};
    cout << boolalpha << (a < b) << "\n"; // true
}
```

> 비교 연산자(`==`, `!=`, `<`, `<=`, `>`, `>=`)는 **사전식(lexicographical)** 으로 동작한다.

### 1.2 구조적 바인딩(C++17)

```cpp
#include <utility>
#include <string>
#include <iostream>
using namespace std;

int main() {
    pair<string,int> person{"Tom", 30};
    auto [name, age] = person; // 복사(기본). 참조 원하면 auto& [n,a]
    cout << name << " is " << age << " years old.\n";
}
```

- **값 복사/이동** vs **참조**: 수정하려면 `auto& [name, age]`.

### 1.3 컨테이너에서의 활용

```cpp
#include <map>
#include <vector>
#include <iostream>
using namespace std;

int main() {
    map<string,int> m;
    m["apple"] = 100; // 내부 원소 타입: pair<const string,int>

    for (auto& [k, v] : m) cout << k << ": " << v << "\n";

    vector<pair<string,int>> scores = { {"A",90}, {"B",85} };
    for (auto& [name, s] : scores) cout << name << "=" << s << "\n";
}
```

> `map<Key, T>`의 요소 타입은 `pair<const Key, T>` — **Key 는 const** 라 재할당 불가.

### 1.4 `swap`/리턴 값으로 쓰기

```cpp
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;

pair<int,int> getMinMax(const vector<int>& v) {
    return { *min_element(v.begin(), v.end()),
             *max_element(v.begin(), v.end()) };
}

int main() {
    pair<int,int> a{1,2}, b{3,4};
    swap(a,b); // (3,4) <-> (1,2)

    auto [mn, mx] = getMinMax({5,2,8,1,9});
    cout << mn << " " << mx << "\n"; // 1 9
}
```

### 1.5 고급: `piecewise_construct`로 **불필요한 임시** 방지

복잡한 멤버(예: 큰 문자열, 컨테이너)를 **각각 직접 생성**하고 싶을 때:

```cpp
#include <map>
#include <tuple>
#include <string>
using namespace std;

int main() {
    map<string, string> m;
    m.emplace(piecewise_construct,
              forward_as_tuple("very-long-key", 13), // key 생성 인자들
              forward_as_tuple(5, 'x'));             // value 생성 인자들 -> string(5, 'x')
    // key는 "very-long-", value는 "xxxxx"
}
```

---

## 2. `std::tuple` — N-원(0이상) 묶음

### 2.1 기본 생성/접근

```cpp
#include <tuple>
#include <string>
#include <iostream>
using namespace std;

int main() {
    tuple<int, string, double> t = make_tuple(1, "apple", 3.14);

    cout << get<0>(t) << "\n"; // 1
    cout << get<1>(t) << "\n"; // apple
    cout << get<2>(t) << "\n"; // 3.14
}
```

> **인덱스는 컴파일타임 상수**여야 하며 템플릿 인수로 들어간다.

### 2.2 구조적 바인딩(C++17)

```cpp
auto [id, name, weight] = t;      // 값 복사
auto& [rid, rname, rweight] = t;  // 참조(원본 수정 가능)
```

### 2.3 비교/정렬 키로 사용

`tuple`도 **사전식 비교**를 지원:

{% raw %}
```cpp
#include <tuple>
#include <vector>
#include <algorithm>
using namespace std;

struct Row { int a; int b; int c; };

int main() {
    vector<Row> v{{2,7,1}, {1,9,3}, {1,5,4}};
    // (a asc, b asc, c asc)
    sort(v.begin(), v.end(), [](const Row& x, const Row& y){
        return tie(x.a, x.b, x.c) < tie(y.a, y.b, y.c);
    });
}
```
{% endraw %}

> 구조체의 “다중 키 비교”를 **한 줄**로. `std::tie`는 **참조 튜플**이라 복사비용 없음.

### 2.4 합성/전개/생성 보조: `tuple_cat`, `apply`, `make_from_tuple`

```cpp
#include <tuple>
#include <iostream>
using namespace std;

int sum3(int a, int b, int c) { return a+b+c; }

int main() {
    auto t1 = make_tuple(1, 2);
    auto t2 = make_tuple(3.0, "x");
    auto t3 = tuple_cat(t1, t2); // (1,2,3.0,"x")

    auto args = make_tuple(10, 20, 30);
    cout << apply(sum3, args) << "\n"; // 60

    struct A { int x; string s; };
    auto tup = make_tuple(7, string("hi"));
    A a = make_from_tuple<A>(move(tup)); // A{7,"hi"}
}
```

### 2.5 `tuple_size` / `tuple_element` — 메타정보

```cpp
static_assert(tuple_size<tuple<int,string,double>>::value == 3);
using SecondType = tuple_element<1, tuple<int,string,double>>::type; // string
```

---

## 3. `std::tie` — **분해 대입**과 **부분 무시**

### 3.1 함수의 다중 리턴값 받기

```cpp
#include <tuple>
#include <string>
#include <iostream>
using namespace std;

tuple<int,string,double> getData(){ return {1,"apple",3.14}; }

int main() {
    int a; string b; double c;
    tie(a,b,c) = getData();  // 각각에 대입 (참조 바인딩)
    cout << a << ", " << b << ", " << c << "\n";

    // 일부 무시
    tie(a, b, ignore) = getData();
}
```

> `tie`는 **참조들의 튜플**을 만든다: 좌변 **이미 존재하는 변수**에 **대입**할 때 유용.
> 새 변수를 **선언**하며 분해할 때는 **구조적 바인딩**(`auto [..] = ...`)을 쓰자.

### 3.2 비교 트릭: `std::tie`로 **사전식 비교** 정의

```cpp
struct Point {
    int x, y;
    bool operator<(const Point& other) const {
        return tie(x,y) < tie(other.x, other.y);
    }
};
```

---

## 4. 구조적 바인딩 vs `tie` vs `pair`

| 목적 | 추천 |
|---|---|
| **새 변수 선언하며** 분해 | 구조적 바인딩 `auto [a,b,...] = expr;` |
| **기존 변수들에 대입**(무시 포함) | `std::tie(a,b, std::ignore) = expr;` |
| 두 값만, 명시적 멤버 | `std::pair<T1,T2>` (`first/second`, or structured binding) |
| N개 이상, 사전식 비교/합성 | `std::tuple<Ts...>` + `tie/tuple_cat/apply` |

---

## 5. 실전 레시피

### 5.1 맵 삽입 결과 처리 (`insert`의 반환값은 `pair<iterator,bool>`)

```cpp
#include <map>
#include <string>
#include <iostream>
using namespace std;

int main() {
    map<string,int> m;
    if (auto [it, inserted] = m.insert({"Tom", 90}); inserted) {
        cout << "Inserted: " << it->first << "\n";
    } else {
        cout << "Already exists, value=" << it->second << "\n";
    }
}
```

### 5.2 문자열 파싱 → 다중값 리턴

```cpp
#include <tuple>
#include <string>
#include <optional>
using namespace std;

tuple<bool, string, int> parseUser(const string& line) {
    auto pos = line.find(':');
    if (pos == string::npos) return {false, "", 0};
    string name = line.substr(0, pos);
    int age = stoi(line.substr(pos+1));
    return {true, name, age};
}

int main(){
    auto [ok, name, age] = parseUser("Jane:27");
}
```

### 5.3 사용자 구조체의 정렬/검색 키 만들기

```cpp
#include <tuple>
#include <vector>
#include <algorithm>
using namespace std;

struct Book { string title; string author; int year; };

int main() {
    vector<Book> v{ {"Z","A",2020}, {"A","C",2019}, {"A","B",2020} };
    sort(v.begin(), v.end(), [](const Book& l, const Book& r){
        // title asc, year desc, author asc
        return tie(l.title, -l.year, l.author) < tie(r.title, -r.year, r.author);
    });
}
```

### 5.4 `tuple`로 **다중 키 map** (커스텀 비교 필요시)

```cpp
#include <map>
#include <tuple>
#include <string>
using namespace std;

using Key = tuple<string,int,string>; // (title, year, author)
map<Key, int> inventory;

int main() {
    inventory[{ "A", 2020, "Kim" }] = 3;
    inventory[{ "A", 2019, "Lee" }] = 5;
}
```

> 기본 비교는 사전식. 별도 비교 로직이 필요하면 `std::less<Key>` 커스터마이즈(커스텀 함수객체) 도입.

### 5.5 `apply`로 여러 인자 함수에 튜플 전달

```cpp
#include <tuple>
#include <iostream>
using namespace std;

int area(int w, int h) { return w*h; }

int main(){
    auto args = make_tuple(3, 7);
    cout << apply(area, args) << "\n"; // 21
}
```

### 5.6 `tuple` <-> 구조체 **변환**(생성 편의)

```cpp
#include <tuple>
#include <string>
#include <iostream>
using namespace std;

struct User { int id; string name; double score; };

int main(){
    auto tu = make_tuple(7, string("neo"), 88.5);
    User u = make_from_tuple<User>(tu);
    auto [i,n,s] = tu; // 필요 시 추출
    cout << i << ":" << n << ":" << s << "\n";
}
```

---

## 6. 고급: **튜플-라이크(튜플화)** 프로토콜 — 내 타입도 구조적 바인딩되게

구조적 바인딩은 `tuple_size`, `tuple_element`, `get<i>(obj)` 세트를 제공하면 **사용자 정의 타입**에도 적용 가능.

```cpp
#include <tuple>
#include <iostream>
using namespace std;

struct Vec2 { float x, y; };

// 1) tuple_size/element 특수화
namespace std {
template<> struct tuple_size<Vec2> : integral_constant<size_t, 2> {};
template<> struct tuple_element<0, Vec2> { using type = float; };
template<> struct tuple_element<1, Vec2> { using type = float; };
}

// 2) get<N> 오버로드
template<size_t N> auto& get(Vec2& v)       { if constexpr (N==0) return v.x; else return v.y; }
template<size_t N> const auto& get(const Vec2& v){ if constexpr (N==0) return v.x; else return v.y; }

int main(){
    Vec2 v{1.0f, 2.0f};
    auto [x, y] = v; // OK
    cout << x << "," << y << "\n";
}
```

> **주의**: 표준 네임스페이스 특수화는 위처럼 허용된 경우에만(특정 템플릿 특수화) 해야 하며, 일반적인 오버로딩/추가 정의는 금지.

---

## 7. 해시와 키로 쓰기 — `unordered_*`에서 `pair/tuple` 키

C++ 표준 구현에 따라 `pair`/`tuple`의 `std::hash` 제공 여부가 다를 수 있다.
**안전**하게 가려면 **사용자 해시**를 제공하자.

```cpp
#include <unordered_map>
#include <tuple>
#include <functional>

struct Key {
    int a; int b;
    bool operator==(const Key& o) const { return a==o.a && b==o.b; }
};

struct KeyHash {
    size_t operator()(const Key& k) const noexcept {
        size_t h1 = hash<int>{}(k.a);
        size_t h2 = hash<int>{}(k.b);
        // 간단 합성(예: 64-bit xorshift/booster도 가능)
        return h1 ^ (h2 + 0x9e3779b97f4a7c15ull + (h1<<6) + (h1>>2));
    }
};

int main(){
    unordered_map<Key, int, KeyHash> um;
    um[{1,2}] = 10;
}
```

`tuple` 키라면 재귀적으로 `std::apply`로 해시 합성 가능.

---

## 8. 성능/메모리 & 안전성 체크

- `pair`는 **작고 단순**: 인터페이스에 “두 값만” 필요할 때 우선 고려.
- `tuple`은 표현력↑, 그러나 **이름 없는 인덱스 기반**이라 **의미 파악이 어렵다** → 의미를 강하게 부여하려면 **구조체**가 낫다.
- **구조적 바인딩**은 가독성↑, 그러나 **값 복사**가 일어난다(필요 시 `auto&`).
- **`tie`는 참조 튜플**: **dangling 참조** 주의. 우변이 **임시**일 때 `tie(a,b)=make_tuple(...)`는 **안전**(대입이므로 값이 복사/이동됨)이지만, `auto t = tie(a,b);`로 만든 **참조 튜플 t의 수명**은 **a,b**에 종속.

---

## 9. 자주 하는 실수 & 교정

- **실수**: `tuple<int,string> t(1, "apple", 3.14);`  ← **인자 개수 불일치**
  **정정**: `tuple<int, string, double> t(1, "apple", 3.14);`
- **실수**: `tie`로 임시값을 “캡처”했다고 생각
  **정정**: `tie`는 **참조**를 묶을 뿐, **저장**하지 않는다. 임시 저장은 `make_tuple`/`tuple`/`pair` 사용.
- **실수**: `map<Key,Val>`에서 `it->first = ...`으로 키 수정 시도
  **정정**: `first`는 `const Key`. 키 변경은 **삭제 후 재삽입**.
- **실수**: 다중 키 비교를 수동 if/else로 장황하게
  **정정**: `tie(k1,k2,...) < tie(o1,o2,...)`를 쓰면 **간결/정확/사전식**.

---

## 10. 연습 과제

1) 로그 레코드 `(ts, user, action)`를 `(ts asc, user asc, action asc)`로 정렬 — **`tie` 한 줄 비교**로.
2) 파서가 `(ok, index, message)`를 반환 — **구조적 바인딩** vs **`tie`** 두 방식으로 소비 코드 작성.
3) `unordered_map<tuple<int,int,int>, float>` 키 해시를 **사용자 정의**로 작성해 대규모 벡터를 누적 집계.
4) 사용자 정의 타입 `Rect{left,top,right,bottom}`에 대해 **구조적 바인딩 가능**하도록 튜플-라이크를 구현.
5) `apply`를 사용해 `double f(int, double, string)`에 튜플 인자를 전달하고, `make_from_tuple`로 생성자 인자 튜플을 사용하는 팩토리 작성.

---

## 요약 표

| 항목 | 핵심 |
|---|---|
| `pair` | 두 값 묶음, 사전식 비교, `piecewise_construct`로 최적 생성 |
| `tuple` | N-원 이종 묶음, `get<N>`, `tuple_cat/apply/make_from_tuple` |
| `tie` | **참조 튜플** 생성, **분해 대입/비교**에 유용, `ignore` 지원 |
| 구조적 바인딩 | 새 변수 선언 분해, `auto [a,b]=...` / 참조는 `auto&` |
| 다중 키 비교 | `tie(...) < tie(...)` 한 줄로, 안정/명료 |
| 해시 | `unordered_*` 키로 쓰면 **사용자 해시** 고려 |
| 주의 | 수명/참조, map의 `const Key`, 인덱스 타입/개수 일치 |
