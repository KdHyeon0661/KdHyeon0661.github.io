---
layout: post
title: 디지털신호처리 -
date: 2025-11-11 22:25:23 +0900
category: 디지털신호처리
---
# 이산 시간 필터의 구현

## 개관 및 목표

핵심 축:

1. **기본 소자**: 지연 \(z^{-1}\), 가중 곱(승산기), 가산기.
2. **IIR 구조**: Direct Form I/II, 전치(Transposed), **바이쿼드(SOS)**, 직렬/병렬, 올패스/분수지연.
3. **FIR 구조**: 직접형, **선형위상(타입 I–IV)**, 전치, **폴리페이즈**(업/다운샘플 결합), 대칭 최적화.
4. **격자(Lattice)**: FIR/올폴(AR)/올패스, **Levinson–Durbin**과 **반사계수(PARCOR)**, 격자-사다리(lattice-ladder).
5. **실전 이슈**: 안정성·수치조건, **고정소수점/정수화**, **상태 초기화**, 스케일링/포화/메모리, 유닛 테스트/벤치마크.

---

## 기본 소자와 z-영역

### 기본 소자

- **지연 요소** \(z^{-1}\): \(y[n]=x[n-1]\) → \(Y(z)=z^{-1}X(z)\)
- **가산기**: \(y[n]=x_1[n]+x_2[n]+\cdots\)
- **가중 곱(스칼라)**: \(y[n]=a\,x[n]\)

이 세 가지로 임의의 LTI 차분방정식을 합성할 수 있다.

### 표준 표현: 전달함수/차분식

전달함수
$$
H(z)=\frac{Y(z)}{X(z)}=\frac{\sum_{k=0}^{M} b_k z^{-k}}{1+\sum_{k=1}^{N} a_k z^{-k}},
$$
차분방정식
$$
y[n]=-\sum_{k=1}^{N} a_k\,y[n-k]+\sum_{k=0}^{M} b_k\,x[n-k].
$$

- **FIR**: \(a_k=0\) → 분모=1, 피드백 없음.
- **IIR**: \(a_k\neq 0\) → 피드백 포함(극 존재).

**BIBO 안정성**: 모든 극점 \(z_p\)이 **단위원 내부** \(|z_p|<1\)이면 안정.

---

## IIR 필터 구조

### Direct Form I (DF-I)

입력 지연선(길이 \(M\))과 출력 지연선(길이 \(N\))을 **따로** 둔다.

중간 노드
\[
v[n] = \sum_{k=0}^{M} b_k\,x[n-k],\qquad
y[n] = v[n]-\sum_{k=1}^{N} a_k\,y[n-k].
\]

장점: 직관/디버깅 용이.
단점: **지연 메모리 두 벌** 사용, 고차에서 상태 규모 ↑.

```octave
function y = filt_df1(b, a, x)
  x = x(:).'; N = numel(x); M = numel(b)-1; P = numel(a)-1;
  xb = zeros(1, M); yb = zeros(1, P);           % 입력/출력 지연
  y = zeros(1, N);
  for n=1:N
    v = b(1)*x(n) + xb * b(2:end).';            % 피드포워드 누산
    y(n) = v - yb * a(2:end).';                 % 피드백 누산
    xb = [x(n), xb(1:end-1)];                   % 지연 갱신
    yb = [y(n), yb(1:end-1)];
  end
end
```

---

### Direct Form II (DF-II) & 전치형(DF-II-T)

**하나의 지연선**(길이 \(\max(M,N)\))으로 내부 상태 \(w[n]\)를 공유:

상태식
$$
w[n]=x[n]-\sum_{k=1}^{N} a_k\,w[n-k],\qquad
y[n]=\sum_{k=0}^{M} b_k\,w[n-k].
$$

장점: 지연 메모리 1벌(메모리 효율).
단점: 내부 상태가 커질 수 있어 **수치 취약**.

**DF-II-T(전치)**: 출력부터 누산·상태 역방향 갱신 → **누산 경로 짧고 수치적으로 유리**, 고정소수점에서 표준.

```octave
function y = filt_df2t(b, a, x)
  x = x(:).'; N = numel(x); M = numel(b)-1; P = numel(a)-1;
  L = max(M, P); s = zeros(1, L);                % 내부 상태
  y = zeros(1, N);
  for n=1:N
    y(n) = b(1)*x(n) + s(1);                     % 출력
    s_next = zeros(1, L);
    for k=1:L
      bk = (k+1 <= numel(b)) * b(k+1);
      ak = (k+1 <= numel(a)) * a(k+1);
      prev = (k+1 <= L) * s(k+1);
      s_next(k) = prev + bk * x(n) - ak * y(n);  % 다음 상태
    end
    s = s_next;
  end
end
```

---

### 바이쿼드(2차 섹션, SOS) 캐스케이드

고차 IIR은 **2차 섹션**을 직렬로 연결하는 것이 정석:
$$
H(z)=g\prod_{i=1}^{S}\frac{b_{0,i}+b_{1,i}z^{-1}+b_{2,i}z^{-2}}{1+a_{1,i}z^{-1}+a_{2,i}z^{-2}}.
$$

- 장점: **수치 안정성**, 섹션별 **스케일 분산** 용이.
- 구현: 섹션당 **DF-II-T** 권장.
- 섹션 순서: 큰 이득/협대역 섹션을 **뒤쪽**에 배치하는 등 **동적범위 최소화** 전략.

```octave
function y = sosfilt_df2t(sos, g, x)
  % sos: [b0 b1 b2 a0 a1 a2] (a0=1 가정), g: 전체 이득
  y = g * x(:).';
  for i=1:size(sos,1)
    b = sos(i,1:3); a = [1 sos(i,5:6)];
    y = filt_df2t(b, a, y);
  end
end
```

**설계/검증(Butterworth 예)**

```octave
clear; close all; clc; pkg load signal
Fs = 48000; fp=4000; fsb=6000;
[n, Wn] = buttord(fp/(Fs/2), fsb/(Fs/2), 1, 40);
[b, a]   = butter(n, Wn);
[sos, g] = tf2sos(b, a);
t = (0:1/Fs:0.02); x = sin(2*pi*1000*t) + 0.5*sin(2*pi*8000*t);
y_ref = filter(b, a, x);                % 참조
y_sos = sosfilt_df2t(sos, g, x);        % 우리 구현
printf("SOS(DF2T) vs filter RMS = %.2e\n", rms(y_sos - y_ref));
```

---

### 직렬/병렬 분해

- **직렬**: \(H=H_1H_2\cdots\) (캐스케이드) — 각 섹션에서 **클리핑 위험/잡음** 분산.
- **병렬**: 부분분수로 \(H=\sum_i \frac{\alpha_i}{1-p_i z^{-1}} + \text{FIR}\) — 포화/다이내믹레인지 제어, 특정 대역 독립 제어.

---

### 올패스·분수지연·위상균일화

**올패스(all-pass)**: \(|H(e^{j\omega})|=1\). 위상/그룹지연 보정, 분수지연 근사에 활용.

**Lagrange 분수지연 FIR**(차수 \(M\), 지연 \(D\in[0,M]\)):
```octave
function h = lagrange_frac_delay(M, D)
  n = 0:M; h = ones(1, M+1);
  for k=0:M
    for m=0:M
      if m~=k, h(k+1) *= (D-m)/(k-m); end
    end
  end
end
```

---

## FIR 필터 구조

### 직접형(Direct Form)

FIR는 피드백이 없어 **항상 안정**:
$$
y[n]=\sum_{k=0}^{M} b_k\,x[n-k].
$$

```octave
function y = fir_direct(b, x)
  x = x(:).'; N = numel(x); M = numel(b)-1;
  y = zeros(1, N);
  xb = zeros(1, M);
  for n=1:N
    y(n) = b(1)*x(n) + xb * b(2:end).';
    xb = [x(n), xb(1:end-1)];
  end
end
```

---

### 선형위상(타입 I–IV)와 대칭 최적화

대칭/반대칭 계수로 **그룹지연이 상수**(위상 선형). 곱셈 수 절반으로 감소:

- **타입 I**: \(M\) 짝수, 대칭 \(b_k=b_{M-k}\)
- **타입 II**: \(M\) 홀수, 대칭
- **타입 III**: \(M\) 짝수, 반대칭 \(b_k=-b_{M-k}\) (DC=0)
- **타입 IV**: \(M\) 홀수, 반대칭 (DC/Nyquist=0)

효율식
$$
y[n]=\sum_{k=0}^{\lfloor M/2\rfloor} b_k\,[x[n-k]+s\,x[n-M+k]],\quad s=\begin{cases}+1&\text{대칭}\\-1&\text{반대칭}\end{cases}.
$$

```octave
function y = fir_linphase_sym(b, x, antisym)
  % antisym=false(대칭), true(반대칭)
  x = x(:).'; N = numel(x); M = numel(b)-1; L = floor(M/2);
  y = zeros(1, N); sgn = antisym * (-2) + 1;   % false->+1, true->-1
  for n=1:N
    acc = 0;
    for k=0:L
      xl = (n-k>0) * x(n-k);
      xr = (n-(M-k)>0) * x(n-(M-k));
      if k==M-k
        acc += b(k+1)*xl;
      else
        acc += b(k+1)*(xl + sgn*xr);
      end
    end
    y(n) = acc;
  end
end
```

---

### FIR 전치(Transposed) — 파이프라인 친화

입력 1 샘플마다 **짧은 조합 경로**(누산기 체인) → 실시간 하드웨어/고정소수점 구현에 유리.

---

### 폴리페이즈(Polyphase) — 멀티레이트 결합

다운샘플 \(↓L\)에서
$$
H(z)=\sum_{m=0}^{L-1} z^{-m} E_m(z^L),\qquad E_m(z)=\sum_{r} b[rL+m]\,z^{-r}.
$$
→ **0 샘플과의 곱 회피**로 연산량 \(1/L\) 수준 절감.

```octave
function y = fir_decimate_poly(x, b, L)
  % 간단한 폴리페이즈 다운샘플러 (스트라이드 구현)
  M = numel(b)-1; E = cell(1,L);
  for m=0:L-1, E{m+1} = b(m+1:L:end); end
  y = [];
  for n=1:L:numel(x)-M
    acc = 0;
    for m=0:L-1
      ek = E{m+1}; K = numel(ek);
      seg = x(n+m:-1:n+m-(K-1));       % 뒤집힌 컨볼루션
      acc += ek * seg.';
    end
    y(end+1) = acc;
  end
end
```

**설계/검증 예(Parks–McClellan)**

```octave
clear; close all; clc; pkg load signal
Fs=48000; N=127; f=[0 0.18 0.22 1]; a=[1 1 0 0]; w=[1 10];
b = remez(N, f, a, w);                 % 등리플 LPF
t=(0:1/Fs:0.02); x=sin(2*pi*1000*t)+0.5*sin(2*pi*8000*t);
y1 = filter(b,1,x);                     % 참조
y2 = fir_direct(b, x);                  % 직접 구현
printf("FIR direct vs filter RMS = %.2e\n", rms(y1-y2));
```

---

## 격자(Lattice) 및 격자-사다리

### 동기: 수치 안정·적응에 강함

**반사계수** \(k_m\)가 \(|k_m|<1\)이면 내부적으로 안정성이 좋고, **PARCOR** 계수는 **LPC/적응 필터**에서 자연스럽게 등장한다.

### Levinson–Durbin (AR 계수/반사계수)

자기상관 \(r[\ell]\)에서 AR(p) 모델 \(a_k\), 반사계수 \(k_m\) 추정:

$$
\begin{aligned}
k_m &= \frac{r[m] - \sum_{i=1}^{m-1} a_{m-1}[i]\,r[m-i]}{E_{m-1}},\\
a_m[i] &= a_{m-1}[i] - k_m\,a_{m-1}[m-i],\quad a_m[m]=k_m,\\
E_m &= (1-k_m^2)E_{m-1}.
\end{aligned}
$$

```octave
function [a, k, E] = levinson_durbin(r, p)
  a = zeros(1,p); k = zeros(1,p); E = zeros(1,p+1);
  E(1) = r(1);
  for m=1:p
    if m==1
      km = r(2)/E(1);
      a(1) = km; E(2) = (1-km^2)*E(1); k(1)=km;
    else
      num = r(m+1) - a(1:m-1) * r(m:-1:2).';
      km = num / E(m);
      a = [a(1:m-1) 0] - km * fliplr([a(1:m-1) 1]);
      E(m+1) = (1-km^2)*E(m); k(m)=km;
    end
  end
end
```

### 올폴(AR) 격자 실현(스케치)

```octave
function y = lattice_allpole(k, x)
  % k: reflection coeffs (|k|<1), x: 입력
  p = numel(k); N = numel(x); y = zeros(1,N);
  f = zeros(1,p+1); b = zeros(1,p+1);
  for n=1:N
    f(1)=x(n); b(1)=x(n);
    for m=1:p
      fn = f(m) + k(m)*b(m);
      bn = k(m)*f(m) + b(m);
      f(m+1)=fn; b(m+1)=bn;
    end
    y(n) = f(p+1);   % 한 가지 정의
  end
end
```

### 격자-사다리(lattice-ladder)

격자(반사계수) + 사다리(탭) 결합으로 **영·극 동시 제어**. FIR/ARMA 구현에 활용.

---

## 실전 이슈 — 안정성·정수화·상태·메모리

### 안정성/수치조건

- 고차 IIR은 **SOS+DF-II-T** 표준.
- 극/영점 **클러스터**(근접) 시 스케일링·섹션 순서 재배치로 내부 동적범위 완화.
- 설계 후 **루트/주파수 응답** 확인: \(|z_p|<1\), `freqz`.

#### 극·영점/응답 도우미

```octave
function [stable, poles, zeros] = hz_stability(b, a)
  zeros = roots(b(:).');
  poles = roots(a(:).');
  stable = all(abs(poles) < 1 - 1e-9);
end
```

---

### 고정소수점/정수화(개념+미니 툴)

- **스케일링**: 섹션 이득 분산, 누산 비트폭 확보.
- **라운딩/포화** 정책 일관.
- DF-II-T가 일반적으로 **오버플로 위험↓**.

간단 Q-형식 도우미:

```octave
function y = qsat(x, qbits)
  % 대략적 포화: [-1, 1-2^{-qbits}]
  maxv = 1 - 2^(-qbits); minv = -1;
  y = min(max(x, minv), maxv);
end

function y = qround(x, qbits)
  y = round(x * 2^qbits) / 2^qbits;
end
```

> 실제 고정소수점은 **곱셈 후 시프트**, 누산 **가드비트**가 필수. DSP/FPGA에서는 Q31×Q31→Q62 누산 후 >>31.

---

### 상태 초기화(Initial Conditions)

실시간/블록 처리에서 **초기 상태**를 올바로 잡아야 **시작 글리치**가 없다.

- 정적 입력 \(x[n]=c\)에서 정상 출력 \(y[n]=y_\infty\)가 되도록 내부 상태를 설정.
- DF-II-T 상태 \(\mathbf{s}\)는
  $$
  \mathbf{s} = \mathbf{A}\,\mathbf{s} + \mathbf{u}(c) - \mathbf{v}(y_\infty)
  $$
  형태의 선형 방정식으로 산출 가능(구조행렬 \(\mathbf{A}\)는 구현 의존).
  간단 실무: **‘워밍업’ 샘플**을 내부적으로 몇 개 흘려보내 초기화.

워밍업 유틸:

```octave
function [y, state] = filt_df2t_warm(b, a, x, warm_x, warm_len)
  % warm_x: 초기화용 상수 입력, warm_len: 샘플 수
  dummy = warm_x * ones(1, warm_len);
  y_dummy = filt_df2t(b, a, dummy);
  % 내부 상태를 추출하는 API가 없으므로, 이 예제에선 warming만 수행
  y = filt_df2t(b, a, x);
  state = [];  % 구조 확장 여지
end
```

---

### 메모리/지연

- DF-II: 지연선 1벌(메모리 효율).
- FIR 대칭: 연산 절반.
- 폴리페이즈: 업/다운샘플 결합 시 **연산량 대폭 절감**.
- SOS: 섹션당 소수 상태(2차) → 지연/메모리 예측 용이.

---

## 통합 예제 — FIR vs IIR vs 격자

```octave
clear; close all; clc; pkg load signal
Fs=48000; t=(0:1/Fs:0.05);
x = sin(2*pi*1000*t) + 0.5*sin(2*pi*8000*t) + 0.1*randn(size(t));

% FIR (등리플 저역통과)
bf = remez(127, [0 0.18 0.22 1], [1 1 0 0], [1 10]);
yf = filter(bf, 1, x);

% IIR (Butterworth → SOS)
[n,Wn] = buttord(4000/(Fs/2), 6000/(Fs/2), 1, 40);
[bi, ai] = butter(n, Wn); [so, g] = tf2sos(bi, ai);
yi = sosfilt_df2t(so, g, x);

% 격자(AR 포락 시연)
p=10; r = xcorr(x, p, "biased"); r = r(p+1:end);
[a_ar, k_ar, E] = levinson_durbin(r, p);
yl = lattice_allpole(k_ar, x);   % 단순 포락형

printf("RMS(FIR vs IIR)=%.3e | RMS(FIR vs Lattice)=%.3e\n", rms(yf-yi), rms(yf-yl));
```

---

## 디버깅/검증 체크리스트

1. **극/영점**: \(|z_p|<1\)인지, 경계 근접 시 수치 취약 경계.
2. **주파수응답**: `freqz`로 통과/저지/리플/차단 확인.
3. **임펄스/스텝 응답**: FIR 길이/그룹지연, IIR 과도특성 확인.
4. **정수화 스트레스**: 최대 입력/최대 이득에서 포화/오버플로 여부.
5. **상태 초기화**: 프레임 경계 글리치 제거(워밍업/IC 설정).
6. **성능**: FIR(대칭/폴리페이즈), IIR(SOS/DF-II-T) 선택.

---

## 수학 요약

### IIR DF-II 상태식

$$
\begin{aligned}
w[n] &= x[n]-\sum_{k=1}^{N} a_k\,w[n-k],\\
y[n] &= \sum_{k=0}^{M} b_k\,w[n-k].
\end{aligned}
$$

### 바이쿼드(2차 섹션)

$$
H_i(z)=\frac{b_{0,i}+b_{1,i}z^{-1}+b_{2,i}z^{-2}}{1+a_{1,i}z^{-1}+a_{2,i}z^{-2}},\quad
H(z)=g\prod_i H_i(z).
$$

### 선형위상 FIR(대칭/반대칭)

- 타입 I/II: \(b_k=b_{M-k}\)
- 타입 III/IV: \(b_k=-b_{M-k}\)

### Levinson–Durbin 재귀

$$
\begin{aligned}
k_m &= \frac{r[m]-\sum_{i=1}^{m-1} a_{m-1}[i]\,r[m-i]}{E_{m-1}},\\
a_m[i] &= a_{m-1}[i]-k_m\,a_{m-1}[m-i],\quad a_m[m]=k_m,\\
E_m &= (1-k_m^2)E_{m-1}.
\end{aligned}
$$

---

## 심화: 병렬 분해·올패스 분해·SOS 스케일링

### 부분분수 병렬 분해(개요)

극이 단순이라면
$$
H(z) = \sum_i \frac{\alpha_i}{1-p_i z^{-1}} + \sum_{k=0}^{K} d_k z^{-k}.
$$
→ 각 1차 IIR을 병렬 합. **포화 분산/다이내믹레인지 확장**에 유리.

### 올패스 분해

일부 IIR은 **저차 올패스 캐스케이드**로 분해 가능. 위상 균일화/그룹지연 제어에 활용.

### SOS 스케일링(간단 스케치)

섹션 i의 최대 통과 이득 \(\gamma_i\)를 대략 추정해(주파수 샘플링) 섹션 전/후에 스케일러 \(s_i\)를 배치:
$$
\prod_i s_i = g,\quad s_i \approx 1/\gamma_i.
$$

```octave
function scales = sos_autoscale(sos, ngrid)
  if nargin<2, ngrid=4096; end
  w = linspace(0, pi, ngrid);
  S = size(sos,1); scales = ones(1,S);
  for i=1:S
    b = sos(i,1:3); a = [1 sos(i,5:6)];
    Hw = freqz(b, a, w);
    scales(i) = 1 / max(abs(Hw) + 1e-12);
  end
end
```

---

## 연습문제(풀이/코드 포함)

### 문제 1) DF-I ↔ DF-II-T 수치 비교

고차/리플 큰 설계에서 DF-I/DF-II-T/`filter` 비교.

```octave
clear; close all; clc; pkg load signal
[b,a]=cheby1(10, 0.8, 0.25); x=randn(1,5000);
y_ref=filter(b,a,x); y1=filt_df1(b,a,x); y2=filt_df2t(b,a,x);
printf("DF1-ref=%.2e | DF2T-ref=%.2e | DF1-DF2T=%.2e\n", ...
  rms(y1-y_ref), rms(y2-y_ref), rms(y1-y2));
```

### 문제 2) FIR 대칭 최적화 동등성

`fir_linphase_sym`가 `filter(b,1,x)`와 일치함을 임의 신호에서 검증.

### 문제 3) 폴리페이즈 다운샘플러 vs 나이브

`fir_decimate_poly`와 `filter+downsample`의 출력/시간 비교(`tic;toc`).

### 문제 4) 바이쿼드 SOS 스케일링

`sos_autoscale`로 스케일 구해 `sosfilt_df2t` 앞뒤에 적용 → 포화 여유 증가를 수치로 확인.

### 문제 5) Levinson–Durbin→격자

AR(6) 합성 신호 생성 → \(r\) 추정 → `levinson_durbin` → `lattice_allpole`로 포락 비교.

---

## 결론

- **기본 소자**로 모든 LTI 필터를 합성할 수 있으며, 구현은 **구조 선택**의 문제다.
- **IIR**은 수치 안정/정수화 측면에서 **SOS+DF-II-T**가 실전 표준.
- **FIR**은 **선형위상 대칭**과 **폴리페이즈**로 연산 효율과 위상 특성을 동시에 얻는다.
- **격자**는 반사계수의 제약으로 내부 안정성이 높고, LPC/적응 필터와 접점이 깊다.
- **상태 초기화·스케일링·포화·메모리** 등 현실적 이슈를 함께 관리해야 “현장에서 동작하는” 필터가 된다.
