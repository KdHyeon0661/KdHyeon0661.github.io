---
layout: post
title: 디지털신호처리 - 기본 소자와 IIR 필터
date: 2025-11-11 22:25:23 +0900
category: 디지털신호처리
---
# 디지털 필터의 기본 소자와 IIR 필터의 개념

1. 디지털 필터를 구성하는 **기본 소자(지연, 가산기, 곱셈기, 누산기)** 가 무엇인지
2. 그 소자들을 어떻게 연결했을 때 **IIR 필터**가 되는지 (임펄스 응답, 피드백, 안정성 관점)

---

## 디지털 신호와 시스템 — IIR 설명을 위한 최소 복습

### 이산시간 신호

디지털 필터에서 다루는 신호는 시간축이 **샘플 인덱스**로 표현되는 이산 신호다.

- 신호: $$x[n]$$
  - $$n$$ 은 정수(… , -2, -1, 0, 1, 2, …)
  - 예: 오디오 48 kHz → 1초에 48000개의 샘플

자주 쓰는 기본 신호:

- 단위 임펄스(Dirac delta):

  $$
  \delta[n] =
  \begin{cases}
  1, & n = 0 \\
  0, & n \neq 0
  \end{cases}
  $$

- 단위 계단(step):

  $$
  u[n] =
  \begin{cases}
  1, & n \ge 0 \\
  0, & n < 0
  \end{cases}
  $$

### 시스템과 임펄스 응답

디지털 필터는 보통 **선형 시불변(LTI) 시스템**으로 모델링한다.

- 선형성:
  입력이 $$x_1[n]$$ 일 때 출력이 $$y_1[n]$$,
  입력이 $$x_2[n]$$ 일 때 출력이 $$y_2[n]$$ 라면,

  $$
  a x_1[n] + b x_2[n] \quad \Rightarrow \quad a y_1[n] + b y_2[n]
  $$

- 시불변성:
  $$x[n] \Rightarrow y[n]$$ 이면, $$x[n-n_0] \Rightarrow y[n-n_0]$$ (시간 이동에 대해 성질 일정)

이때, **임펄스 응답** $$h[n]$$ 을 다음처럼 정의한다.

- 입력: $$x[n] = \delta[n]$$
- 출력: $$y[n] = h[n]$$

그리고 어떤 입력 $$x[n]$$ 에도,

$$
y[n] = \sum_{k=-\infty}^{\infty} h[k] \, x[n-k]
$$

이 되는데, 이것이 바로 **컨볼루션**이다.

임펄스 응답이 **유한 길이**냐, **무한 길이**냐에 따라 FIR / IIR 이 갈린다.

---

## 기본 소자 1: 스칼라 곱셈기(이득기)

### 정의

스칼라 곱셈기는 입력 신호 $$x[n]$$ 에 상수 $$c$$ 를 곱하는 소자다.

$$
y[n] = c \, x[n]
$$

블록도 (텍스트):

```text
      c
x[n] ─▶×───▶ y[n]
```

### 임펄스 응답과 전송함수

입력에 $$\delta[n]$$ 를 넣으면:

$$
y[n] = c \, \delta[n]
$$

즉,

$$
h[n] = c \, \delta[n]
$$

전송함수( $$z$$-변환 ):

- $$X(z) = 1$$ (임펄스 입력의 $$z$$-변환)
- $$Y(z) = c$$
- $$H(z) = \dfrac{Y(z)}{X(z)} = c$$

곱셈기는 **순수한 이득(게인)** 이다.
FIR, IIR 필터는 모두 이런 스칼라 곱셈기의 “집합”으로 생각할 수도 있다.

---

## 기본 소자 2: 지연소자(단위 지연, unit delay)

### 정의

지연소자는 입력 신호를 **한 샘플 늦게** 출력한다.

$$
y[n] = x[n-1]
$$

블록도:

```text
x[n] ───▶[ z⁻¹ ]───▶ y[n]
```

### 임펄스 응답과 전송함수

입력에 $$x[n] = \delta[n]$$ 를 넣으면,

$$
y[n] = \delta[n-1]
$$

따라서,

$$
h[n] = \delta[n-1]
$$

전송함수:

$$
H(z) = \sum_{n=-\infty}^{\infty} h[n] z^{-n}
     = \sum_{n=-\infty}^{\infty} \delta[n-1] z^{-n}
     = z^{-1}
$$

즉, **지연 1개 = 전송함수 $$z^{-1}$$** 이다.

이 지연소자는 모든 디지털 필터에서 **메모리** 역할을 한다.
IIR 필터는 이 지연소자를 통해 **과거의 출력**을 다시 입력으로 되먹이는 구조를 갖게 된다.

---

## 기본 소자 3: 가산기(Adder)

### 정의

두 입력 신호 $$x_1[n], x_2[n]$$ 를 더해서 출력하는 역할:

$$
y[n] = x_1[n] + x_2[n]
$$

블록도:

```text
x1[n] ──▶\
          +──▶ y[n]
x2[n] ──▶/
```

더 많은 입력도 가산기 여러 개를 연결하면 된다.

### LTI 관점

가산기 자체는 “다입력–단일 출력”이므로 전형적인 단일 입력 LTI 시스템처럼 전송함수를 따로 쓰진 않지만,
각 입력에 대해 **선형성**이 유지된다.

- $$x_1[n] \Rightarrow y_1[n] = x_1[n]$$
- $$x_2[n] \Rightarrow y_2[n] = x_2[n]$$
- 둘의 합이 입력이면 출력도 합이다.

디지털 필터 구조도 결국 **각 지연된 신호에 계수를 곱해서 가산기에서 더하는 것**으로 표현된다.

---

## 기본 소자 4: 누산기(Accumulate)와 디지털 “적분기”

누산기는 이전 출력과 현재 입력을 더해가는 소자다.

### 누산기 구조

누산기는 보통 다음과 같이 표현된다.

$$
y[n] = y[n-1] + x[n]
$$

블록도:

```text
           ┌───────────────┐
           │               ▼
x[n] ──▶(+)────────────▶ y[n]
        ▲
        │
      [z⁻¹]
```

여기서 지연소자 $$z^{-1}$$ 에는 **이전 출력 $$y[n-1]$$** 가 저장되고,
가산기에서 현재 입력 $$x[n]$$ 과 더해져 $$y[n]$$ 을 만든다.

### 누산기의 임펄스 응답 — 이미 “IIR 필터”다

입력으로 $$\delta[n]$$ 를 넣으면:

초기조건 $$y[-1] = 0$$ 이라고 하면,

- $$n = 0$$ 일 때

  $$
  y[0] = y[-1] + x[0] = 0 + 1 = 1
  $$

- $$n = 1$$ 일 때

  $$
  y[1] = y[0] + x[1] = 1 + 0 = 1
  $$

- $$n = 2$$ 일 때

  $$
  y[2] = y[1] + x[2] = 1 + 0 = 1
  $$

이렇게 계속해서,

$$
h[n] = y[n] = 1 \quad (n \ge 0)
$$

즉,

$$
h[n] = u[n]
$$

임펄스 응답이 **무한히 길다** (0 이후로 쭉 1). 따라서 누산기는 **IIR 필터**에 속한다.

전송함수는:

$$
H(z) = \sum_{n=0}^{\infty} u[n] z^{-n}
     = \sum_{n=0}^{\infty} z^{-n}
     = \frac{1}{1 - z^{-1}}
$$

이 구조 자체가 **디지털 적분기(Integrator)** 와 같은 역할을 한다.

---

## 기본 소자의 조합으로 본 FIR vs IIR

### FIR 필터: 피드백 없음, 유한 임펄스 응답

FIR(Finite Impulse Response) 필터는 **피드백 없는 구조**로,
입력의 **지연된 버전들에 계수를 곱해서 더하는 것**만으로 이루어진다.

일반적인 형태:

$$
y[n] = \sum_{k=0}^{M} b_k \, x[n-k]
$$

임펄스 입력 $$x[n] = \delta[n]$$ 을 넣으면:

$$
h[n] = y[n] =
\begin{cases}
b_n, & 0 \le n \le M \\
0, & \text{그 외}
\end{cases}
$$

즉, 임펄스 응답이 **길이 $$M+1$$ 인 유한 길이**이므로 FIR 이라고 부른다.

구조적으로는:

- 지연소자: $$M$$ 개
- 곱셈기: $$M+1$$ 개
- 가산기: 여러 개

피드백(출력을 다시 입력으로 되돌리는 연결)이 없다.

### IIR 필터: 피드백 존재, 무한 임펄스 응답

IIR(Infinite Impulse Response) 필터는 **피드백이 존재**하는 구조다.
일반적인 선형 차분방정식은 다음과 같다.

$$
y[n] + a_1 y[n-1] + a_2 y[n-2] + \cdots + a_N y[n-N]
= b_0 x[n] + b_1 x[n-1] + \cdots + b_M x[n-M]
$$

이를 정리하면:

$$
y[n] = -\sum_{k=1}^{N} a_k y[n-k] + \sum_{k=0}^{M} b_k x[n-k]
$$

오른쪽에 **과거 출력 $$y[n-k]$$ 들이 등장**한다 → 피드백.

이 경우 임펄스 응답은 대부분의 경우 **무한히 길어진다**.

- 예: 1차 IIR 예제에서 자세히 볼 것

---

## IIR 필터의 전송함수와 차분방정식

### 전송함수 일반형

선형 차분방정식이 있을 때 $$z$$-변환을 취하면,

$$
H(z) = \frac{Y(z)}{X(z)} =
\frac{b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}
{1 + a_1 z^{-1} + \cdots + a_N z^{-N}}
$$

분모에 $$z^{-1}$$ 들이 있는 것이 **IIR의 핵심**이다.

- 분자 다항식: 영점(zeros)
- 분모 다항식: 극점(poles)

### 차분방정식 ↔ 전송함수

예를 들어, 다음과 같은 차분방정식을 보자.

$$
y[n] = 0.5 y[n-1] + x[n]
$$

양변에 $$z$$-변환을 취하면:

$$
Y(z) = 0.5 z^{-1} Y(z) + X(z)
$$

따라서,

$$
Y(z) (1 - 0.5 z^{-1}) = X(z)
$$

$$
H(z) = \frac{Y(z)}{X(z)} = \frac{1}{1 - 0.5 z^{-1}}
$$

누산기와 매우 비슷한 꼴이다.
다만, 계수 0.5 덕분에 임펄스 응답이 점차 감소하게 된다.

---

## 1차 IIR 필터 예제: 간단한 저역통과 필터

이제 가장 기본적인 IIR 필터인 **1차 저역통과 필터**를 예로 들어
임펄스 응답, 스텝 응답, 안정성까지 살펴보자.

### 차분방정식 정의

다음과 같은 필터를 정의하자.

$$
y[n] = (1-\alpha) x[n] + \alpha y[n-1]
$$

여기서 $$0 < \alpha < 1$$ 이라고 가정한다.

- $$x[n]$$: 입력
- $$y[n]$$: 출력
- $$\alpha$$: “과거 출력”의 비중 (pole 위치를 결정)

이 식은 다음 두 구조의 조합으로 볼 수 있다.

1. 현재 입력 $$x[n]$$ 에 계수 $$1-\alpha$$ 를 곱한다.
2. 이전 출력 $$y[n-1]$$ 에 계수 $$\alpha$$ 를 곱한다.
3. 둘을 더해 새로운 $$y[n]$$ 을 만든다.

블록도(텍스트):

```text
           ┌────────────────────────────┐
           │                            ▼
x[n] ─▶[×(1-α)]──▶(+)──────────────▶ y[n]
                 ▲
                 │
              [×α]
                 ▲
                 │
               [z⁻¹]
                 ▲
                 │
                y[n]
```

지연소자(메모리), 가산기, 곱셈기만으로 표현된다는 게 중요하다.

### 임펄스 응답 계산

입력에 $$x[n] = \delta[n]$$, 초기조건 $$y[-1] = 0$$ 을 넣어보자.

- $$n = 0$$ 일 때:

  $$
  y[0] = (1-\alpha) x[0] + \alpha y[-1]
       = (1-\alpha) \cdot 1 + \alpha \cdot 0
       = 1-\alpha
  $$

- $$n = 1$$ 일 때:

  $$
  x[1] = 0
  $$

  $$
  y[1] = (1-\alpha) x[1] + \alpha y[0]
       = (1-\alpha) \cdot 0 + \alpha (1-\alpha)
       = (1-\alpha)\alpha
  $$

- $$n = 2$$ 일 때:

  $$
  y[2] = \alpha y[1]
       = \alpha (1-\alpha)\alpha
       = (1-\alpha)\alpha^2
  $$

일반적으로,

$$
h[n] = y[n] = (1-\alpha)\alpha^n u[n]
$$

임펄스 응답이 **영원히 0으로 떨어지지 않고 계속 남아 있다.**
(단, $$\alpha^n$$ 이 점점 작아져서 사실상 0에 가까워질 뿐)

그래서 IIR: Infinite Impulse Response 라고 부른다.

### 전송함수와 극점

전송함수는,

$$
H(z) = \frac{Y(z)}{X(z)}
     = \frac{1-\alpha}{1 - \alpha z^{-1}}
$$

분모를 0으로 만드는 $$z$$ 가 극점이다.

$$
1 - \alpha z^{-1} = 0 \quad \Rightarrow \quad z = \alpha
$$

즉, 이 필터의 극점은 $$z = \alpha$$ 에 있다.

- $$0 < \alpha < 1$$ 이므로 극점은 단위원(원점 중심, 반지름 1) 안에 위치 → 안정

### 안정성 조건

일반적인 IIR 필터에서 **BIBO 안정성**(Bounded Input, Bounded Output)은

> 임의의 유계 입력에 대해 출력도 유계이면 시스템이 안정

임펄스 응답 관점에서는,

> $$\sum_{n=-\infty}^{\infty} |h[n]| < \infty$$ 이면 안정

1차 예제에서는,

$$
\sum_{n=0}^{\infty} |h[n]|
= \sum_{n=0}^{\infty} |1-\alpha| |\alpha|^n
= |1-\alpha| \sum_{n=0}^{\infty} |\alpha|^n
$$

$$|\alpha| < 1$$ 이면 기하급수의 합이 수렴하므로 안정이다.

- **결론**: 1차 IIR 필터에서 $$|\alpha| < 1$$ 이면 안정

고차 IIR 필터에서는 **모든 극점의 크기(반지름)가 1보다 작으면** 안정이다.

---

## IIR이 저역통과처럼 동작하는 이유 — 주파수 응답 직관

1차 필터의 주파수 응답은,

$$
H\left(e^{j\omega}\right) = \frac{1-\alpha}{1 - \alpha e^{-j\omega}}
$$

이다. 여기서 $$\omega = 2\pi f / f_s$$.

간단한 직관:

- $$\omega = 0$$ (DC 성분)일 때:

  $$
  H\left(e^{j0}\right) = \frac{1-\alpha}{1 - \alpha} = 1
  $$

  → DC 성분은 그대로 통과

- $$\omega = \pi$$ (최고 주파수)일 때:

  $$
  H\left(e^{j\pi}\right)
  = \frac{1-\alpha}{1 + \alpha}
  $$

  $$0 < \alpha < 1$$ 이면 $$\dfrac{1-\alpha}{1+\alpha} < 1$$

  → 고주파는 감쇠

따라서,

- 낮은 주파수는 잘 통과 (저역통과)
- 높은 주파수는 점점 더 감쇠

이런 basic IIR 구조를 여러 개 조합하면 더 예리한 저역통과, 대역통과, 고역통과 필터를 만들 수 있다.

---

## 기본 소자로 구현하는 1차 IIR 필터 — GNU Octave 코드와 블록도

여기서부터는 이전에 C 스타일로 작성했던 코드를 **GNU Octave** 코드로 바꿔서 설명한다.

### 샘플 단위 연산 코드 (GNU Octave 함수)

차분방정식:

$$
y[n] = (1-\alpha) x[n] + \alpha y[n-1]
$$

Octave 에서 한 샘플씩 처리하는 함수 형태로 구현하면 다음과 같다.

```matlab
% 1차 IIR 필터 상태를 구조체로 보관하고,
% 샘플 하나를 처리하는 함수

function state = iir1_init(alpha)
  % alpha: 0 < alpha < 1
  state.alpha  = alpha;
  state.y_prev = 0.0;  % y[n-1] 초기값
end

function [y_n, state] = iir1_process_sample(x_n, state)
  % x_n: 현재 입력 샘플 (스칼라)
  % state: 구조체 (alpha, y_prev)
  a = state.alpha;
  y_n = (1 - a) * x_n + a * state.y_prev;
  state.y_prev = y_n;
end
```

- `state` 구조체는
  - `y_prev` : 이전 출력 샘플 $$y[n-1]$$ → **지연소자**
  - `alpha` : 필터 계수
- `*` 연산은 **스칼라 곱셈기**
- `+` 연산은 **가산기**

즉, 한 줄의 차분방정식을 Octave 코드로 풀어 쓰면 **기본 소자들의 조합** 그 자체다.

벡터 신호를 한 번에 처리하고 싶다면 다음처럼 작성할 수도 있다.

```matlab
function [y, state] = iir1_process_vector(x, state)
  % x: 열벡터 또는 행벡터
  y = zeros(size(x));
  a = state.alpha;
  y_prev = state.y_prev;

  for n = 1:length(x)
    y(n) = (1 - a) * x(n) + a * y_prev;
    y_prev = y(n);
  end

  state.y_prev = y_prev;
end
```

### 텍스트 블록도 (다시 정리)

```text
           ┌───────────────────────────┐
           │                           ▼
x[n] ─▶[×(1-α)]──▶(+)──────────────▶ y[n]
                 ▲
                 │
              [×α]
                 ▲
                 │
               [z⁻¹]
                 ▲
                 │
                y[n]
```

- 지연소자: $$z^{-1}$$ (상태 변수 `state.y_prev`)
- 곱셈기: 계수 $$1-\alpha$$, $$\alpha$$
- 가산기: 둘을 더해서 출력

이 패턴이 모든 IIR 필터의 **가장 기본적인 피드백 구조**라고 보면 된다.

---

## 예제 — 기본 구조만

IIR 필터는 보통 **2차(biquad) 블록**을 많이 사용한다.
기본형은 다음과 같은 차분방정식이다.

$$
y[n] = b_0 x[n] + b_1 x[n-1] + b_2 x[n-2]
     - a_1 y[n-1] - a_2 y[n-2]
$$

여기서 $$a_0 = 1$$ 로 정규화했다고 가정한다.

### 기본 소자로 표현하기

필요한 메모리:

- 입력 지연: $$x[n-1], x[n-2]$$
- 출력 지연: $$y[n-1], y[n-2]$$

필요한 소자:

- 지연소자: 최소 2개(입력용) + 2개(출력용) = 4개 (Direct Form I 기준)
- 곱셈기: 계수 $$b_0, b_1, b_2, -a_1, -a_2$$
- 가산기: 합산용

텍스트 블록도(개념만):

```text
입력 x[n]
   │
   ├──▶[z⁻¹]──▶[z⁻¹] (입력 지연선) ──▶ 곱셈기(b1,b2) → 가산기
   │
   └────────────────▶ 곱셈기(b0) → 가산기로

출력 y[n]
   │
   ├──▶[z⁻¹]──▶[z⁻¹] (출력 지연선) ──▶ 곱셈기(-a1,-a2) → 가산기로 되먹임
   │
   └─ (최종 출력)
```

### GNU Octave 로 biquad 구현

C 구조체 대신, Octave 구조체와 함수를 사용해 동일한 개념을 구현할 수 있다.

```matlab
function state = biquad_init(b, a)
  % b: [b0 b1 b2]
  % a: [1 a1 a2]  (a(1) = 1 라고 가정)
  state.b = b(:).';  % 행벡터로 정리
  state.a = a(:).';
  state.x1 = 0.0;    % x[n-1]
  state.x2 = 0.0;    % x[n-2]
  state.y1 = 0.0;    % y[n-1]
  state.y2 = 0.0;    % y[n-2]
end

function [y_n, state] = biquad_process_sample(x_n, state)
  b0 = state.b(1); b1 = state.b(2); b2 = state.b(3);
  % a(1) = 1 이라고 가정
  a1 = state.a(2); a2 = state.a(3);

  % 차분방정식:
  % y[n] = b0 x[n] + b1 x[n-1] + b2 x[n-2]
  %      - a1 y[n-1] - a2 y[n-2]

  y_n = b0 * x_n ...
      + b1 * state.x1 ...
      + b2 * state.x2 ...
      - a1 * state.y1 ...
      - a2 * state.y2;

  % 지연값 업데이트
  state.x2 = state.x1;
  state.x1 = x_n;
  state.y2 = state.y1;
  state.y1 = y_n;
end
```

벡터 입력을 한 번에 처리하려면:

```matlab
function [y, state] = biquad_process_vector(x, state)
  y = zeros(size(x));
  for n = 1:length(x)
    [y(n), state] = biquad_process_sample(x(n), state);
  end
end
```

여기서도:

- 지연소자: `state.x1, state.x2, state.y1, state.y2`
- 곱셈기: 계수와의 `*`
- 가산기: `+` 연산

즉, 2차 IIR도 **세 가지 기본 소자의 조합**으로 완전히 표현된다.

---

## IIR 필터의 안정성 — 극점과 단위원

IIR 필터의 전송함수를 다시 쓰면,

$$
H(z) =
\frac{b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}
{1 + a_1 z^{-1} + \cdots + a_N z^{-N}}
$$

분모를 다항식 형태로 쓰면,

$$
A(z) = 1 + a_1 z^{-1} + \cdots + a_N z^{-N}
     = z^{-N} (z^N + a_1 z^{N-1} + \cdots + a_N)
$$

따라서,

$$
z^N + a_1 z^{N-1} + \cdots + a_N = 0
$$

의 해 $$z = p_k$$ 를 **극점(poles)** 라고 한다.

### 안정성 조건

IIR 필터가 안정하려면, 모든 극점이 **단위원 안**(복소평면에서 반지름 1 원 안) 에 있어야 한다.

$$
|p_k| < 1 \quad \forall k
$$

이 조건은 결국 임펄스 응답이 기하급수적으로 감소하는 것을 의미한다.

예:

- 1차 필터에서 $$z = \alpha$$ 는 극점 → $$|\alpha| < 1$$ 이면 안정
- 2차 필터에서는 두 근 $$p_1, p_2$$ 의 반지름이 1보다 작으면 안정

### 기본 소자 수준에서의 직관

피드백 경로에 있는 계수들의 조합이 극점을 결정한다.

- 피드백 계수가 너무 크면: 극점이 단위원 밖으로 나가서 발산 → 불안정
- 적당히 작으면: 극점이 안쪽에 위치 → 지수적으로 감소하는 임펄스 응답 → 안정

따라서, IIR 필터 설계에서는 “주파수 응답”만 보는 것이 아니라
**극점 위치**를 항상 같이 보는 것이 중요하다.

---

## GNU Octave 예제 1: 1차 IIR을 직접 만들어 임펄스 응답 보기

이미 Octave 기반으로 되어 있었던 예제를 그대로 유지하되, “GNU Octave” 기준으로 조금 더 정리한다.

### 1차 IIR 필터 함수 (벡터 입력 버전)

```matlab
function y = iir1_vec(alpha, x)
  % y[n] = (1-alpha) x[n] + alpha y[n-1]
  y = zeros(size(x));
  y_prev = 0;

  for n = 1:length(x)
    y(n) = (1-alpha) * x(n) + alpha * y_prev;
    y_prev = y(n);
  end
end
```

### 임펄스 응답 확인

```matlab
N = 50;               % 길이 50 샘플
x = zeros(1, N);
x(1) = 1;             % delta[n]

alpha = 0.8;
h = iir1_vec(alpha, x);

stem(0:N-1, h, 'filled');
xlabel('n');
ylabel('h[n]');
title('1차 IIR 필터의 임펄스 응답');
grid on;
```

이 그림을 보면 $$h[n]$$ 이 지수적으로 감소하는 것을 확인할 수 있다.

이론식:

$$
h[n] = (1-\alpha)\alpha^n u[n]
$$

와 비교하면 완전히 일치한다.

---

## GNU Octave 예제 2: 합성 신호에 1차 IIR 적용해 보기

이제 이전에 Python으로 작성했던 “1 kHz + 8 kHz 신호를 필터링하는 예제”를
전부 GNU Octave 코드로 바꿔서 작성한다.

### 신호 생성 및 필터 적용

```matlab
fs = 48000;                  % 샘플링 주파수
t_end = 0.01;                % 10 ms
t = 0:1/fs:t_end;            % 시간축 (열벡터로 사용해도 무방)

% 1 kHz + 8 kHz 두 톤 합성
x = sin(2*pi*1000*t) + 0.5*sin(2*pi*8000*t);

alpha = 0.8;

% 앞에서 정의한 iir1_vec 사용
y = iir1_vec(alpha, x);

subplot(2,1,1);
plot(t, x);
title('입력 x[n] (1 kHz + 8 kHz)');
xlabel('Time [s]');
ylabel('Amplitude');
grid on;

subplot(2,1,2);
plot(t, y);
title('1차 IIR 저역통과 필터 출력');
xlabel('Time [s]');
ylabel('Amplitude');
grid on;
```

결과:

- 입력에는 1 kHz, 8 kHz 두 주파수가 섞여 있다.
- 출력은 8 kHz 성분이 많이 약해지고, 1 kHz 성분이 상대적으로 강하게 남는다 → 저역통과 동작.

### GNU Octave 내장 함수와의 비교 (옵션)

Octave 에는 `filter` 함수가 있으므로, 동일한 필터를 내장 함수로 구현할 수도 있다.

- 차분방정식:

  $$
  y[n] = (1-\alpha)x[n] + \alpha y[n-1]
  $$

- 이에 대응하는 계수:

  - 분자: $$b_0 = 1-\alpha$$
  - 분모: $$a_0 = 1, a_1 = -\alpha$$

따라서:

```matlab
b = [1-alpha];
a = [1 -alpha];

y2 = filter(b, a, x);   % 내장 filter 함수 사용

% 두 구현이 얼마나 비슷한지 비교
plot(t, y, 'b', t, y2, 'r--');
legend('수동 구현 iir1\_vec', 'filter 함수');
xlabel('Time [s]');
ylabel('Amplitude');
title('1차 IIR 필터 구현 비교');
grid on;
```

두 파형이 거의 겹치는 것을 통해,
기본 소자를 직접 구현한 버전과 Octave 내장 `filter` 함수가 같은 필터임을 확인할 수 있다.

---

## 요약: “기본 소자”와 “IIR 필터” 연결관계 (GNU Octave 버전)

마지막으로, Octave 코드 관점까지 포함해서 이번 글의 핵심을 정리하면 다음과 같다.

1. 디지털 필터의 **기본 소자**

   - **스칼라 곱셈기**: $$y[n] = c x[n]$$, 전송함수 $$H(z) = c$$
   - **지연소자**: $$y[n] = x[n-1]$$, 전송함수 $$H(z) = z^{-1}$$
   - **가산기**: 여러 신호를 더함, 선형성 유지
   - **누산기(적분기)**: $$y[n] = y[n-1] + x[n]$$, 전송함수 $$H(z) = \dfrac{1}{1 - z^{-1}}$$ (이미 IIR)

2. FIR vs IIR

   - FIR: 피드백 없음, 임펄스 응답이 유한 길이(계수 개수만큼)
   - IIR: 피드백 있음, 임펄스 응답이 일반적으로 무한 길이

3. IIR 필터의 일반형

   - 차분방정식:

     $$
     y[n] = -\sum_{k=1}^{N} a_k y[n-k]
           + \sum_{k=0}^{M} b_k x[n-k]
     $$

   - 전송함수:

     $$
     H(z) =
     \frac{b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}
     {1 + a_1 z^{-1} + \cdots + a_N z^{-N}}
     $$

   - 분모 다항식의 근(극점)이 단위원 안에 있을 때 안정

4. 1차 IIR 기본 예제

   - $$y[n] = (1-\alpha) x[n] + \alpha y[n-1]$$
   - 임펄스 응답: $$h[n] = (1-\alpha)\alpha^n u[n]$$
   - 극점: $$z = \alpha$$, $$|\alpha| < 1$$ 이면 안정
   - 저역통과 특성: DC는 통과, 고주파는 감쇠

5. GNU Octave 구현 관점

   - `iir1_vec`, `iir1_process_sample` 등으로 직접 구현 가능
   - 상태 변수(예: `y_prev`, `x1, x2, y1, y2`)는 **지연소자**와 1:1 대응
   - `filter(b, a, x)` 내장 함수는 같은 차분방정식을 효율적으로 계산한 것
   - 모든 IIR 필터는 결국 **지연 + 곱셈 + 덧셈**의 조합이며,
     Octave 코드로 옮기면 이 세 연산이 그대로 드러난다.
