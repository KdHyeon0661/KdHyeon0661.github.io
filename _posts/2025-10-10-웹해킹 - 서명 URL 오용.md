---
layout: post
title: 웹해킹 - 서명 URL 오용
date: 2025-10-10 15:25:23 +0900
category: 웹해킹
---
# 서명 URL 오용(S3 등)

**— 배경 · 실전 오용 시나리오 · “안전 재현(막혀야 정상)” · 코드로 구현하는 방어(짧은 TTL·정확한 경로/메서드·응답/업로드 헤더 강제·검증 파이프라인) · IaC/IAM 정책 · 관측/테스트/체크리스트**

## 한눈에 보기 (Executive Summary)

- **문제(핵심)**
  서명 URL(예: **S3 Pre-Signed URL**, GCS Signed URL, Azure SAS)을 **과도한 TTL**(수시간~수일)로 만들거나,
  **와일드카드 경로/권한**으로 발급하면 **임의 업로드/오염/덮어쓰기**가 가능합니다.
  또한 응답 헤더/업로드 메타데이터를 통제하지 않으면 **콘텐츠 스니핑/악성 배포(HTML/JS/RFD)**,
  **ACL 오용(public-read)**, **타인 소유 버킷 오염** 등의 문제가 생깁니다.

- **핵심 방어 원칙**
  1) **짧은 TTL**: 업로드(스크린샷/첨부 등) **≤ 3–5분**, 다운로드 **≤ 10–15분**.
  2) **정확한 경로·메서드 제한**: **정확한 Key(또는 프리픽스+랜덤)**, 메서드는 필요 최소(예: `PUT`만).
  3) **요청/응답 헤더 강제**: 업로드 시 **`Content-Type`/`Content-Length` 범위/`Content-MD5`**(가능하면) 고정,
     다운로드 시 **`Content-Disposition: attachment`**, `Content-Type` 고정, **nosniff**(엣지/프록시에서).
  4) **서버 상태/검증 파이프라인**: 업로드 후 **검역(quarantine) → 바이러스/타입 검증 → 태그/메타 설정 → 공개 전환**.
  5) **Iam/Bucket Policy 최소권한**: ACL 금지/차단, 덮어쓰기 금지(버전닝+조건), **정확한 Key 조건**.
  6) **관측/자동 테스트**: TTL 초과·허용되지 않은 헤더/Key 시험이 **항상 실패**하는지 CI/E2E로 확인.

---

## 배경: 서명 URL이 하는 일

- 클라이언트가 직접 오브젝트 스토리지(예: S3)에 접근하도록 **단기 자격 증명**을 URL 또는 토큰 형태로 전달.
- URL 자체가 **권한**이며, 만료 전까지는 **서버를 거치지 않고** 업/다운로드가 가능.
- 따라서 **만료·경로·메서드·헤더**를 엄격히 제한하지 않으면, 서버의 권한 모델을 우회하는 통로가 됩니다.

---

## 실전 오용 시나리오

### 과도한 TTL(7일 등)

- **현상**: 링크가 장기간 유효 → 외부 공유/유출 시 **지속 오염·다운로드** 가능.
- **결과**: 임의 파일 배포, 만료 전 악성 컨텐츠 바꿔치기(덮어쓰기 허용 시).

### 와일드카드 경로

- **현상**: “아무 Key나” 올릴 수 있는 PUT URL을 발급(/uploads/*).
- **결과**: 다른 사용자의 경로 오염, 예상치 못한 **덮어쓰기**.

### 메서드/헤더 미제한

- **현상**: GET/PUT/DELETE 모두 허용, 업로드 `Content-Type`/길이 미검증.
- **결과**: HTML/JS 업로드 후 **XSS/RFD**, 초대형 파일로 **스토리지 폭주**,
  `x-amz-acl: public-read`로 **공개화** 등.

### 응답 헤더 미통제(다운로드)

- **현상**: 다운로드 시 **inline** 렌더링.
- **결과**: **RFD/HTML 렌더링**(사용자 클릭 시 스크립트 실행 가능 환경에서 위험), **콘텐츠 스니핑**.

### 교차 계정/소유권 문제

- **현상**: 업로드 후 **버킷 소유자가 객체 ACL/소유권을 갖지 못함**.
- **결과**: 접근/삭제 권한 혼선 → **bucket-owner-full-control** 필요.

---

## “안전 재현”(스테이징) — **막혀야 정상 ✅**

- **TTL 초과 시도**: `X-Amz-Expires=1800`(30분) 등으로 URL 생성 시 **서버에서 거부**(발급 자체 실패).
- **프리픽스 밖 Key 업로드**: `/uploads/user-123/` 외 경로 시 **403**.
- **부적절 Content-Type**: 사전에 고정한 `image/png` 외 업로드 시 **Signature mismatch** 또는 **서버 검역에서 격리**.
- **대용량 파일**: `Content-Length-Range` 초과 → **정책 위반**.
- **ACL 시도**: `x-amz-acl: public-read` 헤더 포함 → **정책에서 Deny**.
- **다운로드 inline**: CloudFront/프록시가 **`Content-Disposition: attachment` + nosniff**를 강제해 **렌더링 불가**.

아래 섹션의 코드/정책으로 재현 시 **항상 실패**해야 정상입니다.

---

## AWS S3 — 안전한 설계 & 코드

### 업로드: **Pre-Signed POST**(권장)로 조건 강제

**장점**: POST 정책 문서에 **조건**(Key/Content-Type/길이/ACL 금지 등)을 서명해 브라우저가 **틀리면 즉시 거절**.

```ts
// Node (AWS SDK v3) — Pre-Signed POST: Key·타입·크기 범위 고정
import { S3Client } from "@aws-sdk/client-s3";
import { createPresignedPost } from "@aws-sdk/s3-presigned-post";

const s3 = new S3Client({ region: "ap-northeast-2" });

export async function issuePresignedPost(userId: string) {
  const key = `uploads/${userId}/${crypto.randomUUID()}.png`;
  const expiresSec = 300; // ⏱ 5분
  const { url, fields } = await createPresignedPost(s3, {
    Bucket: process.env.BUCKET!,
    Key: key,
    Expires: expiresSec,
    Conditions: [
      ["content-length-range", 0, 5 * 1024 * 1024],     // ≤ 5MB
      ["eq", "$Content-Type", "image/png"],             // 타입 고정
      ["eq", "$x-amz-meta-origin", "web"],              // 임의 메타도 강제 가능
      ["eq", "$x-amz-acl", "bucket-owner-full-control"] // 공개 ACL 금지 + 소유권 일관
    ],
    Fields: {
      "Content-Type": "image/png",
      "x-amz-acl": "bucket-owner-full-control",
      "x-amz-meta-origin": "web"
    }
  });
  return { url, fields, key, expiresSec };
}
```

> **포인트**
> - **TTL ≤ 300초**.
> - **Key는 서버가 발급**(사용자 지정 금지), **사용자별 프리픽스** + **랜덤 파일명**.
> - **Content-Length-Range/Content-Type/x-amz-acl** 등을 **조건**으로 고정.
> - 가능하면 `Content-MD5` 를 추가해 **무결성** 검증(대상/클라이언트 지원에 따라).

### 업로드: Pre-Signed **PUT** (필요 시)

PUT은 조건을 정책으로 묶기 어려워 **요청 헤더를 서명에 포함**해 **정확히 일치**하도록 만듭니다.

```ts
// Node (AWS SDK v3) — Pre-Signed PUT: 헤더를 서명에 포함
import { S3RequestPresigner } from "@aws-sdk/s3-request-presigner";
import { HttpRequest } from "@aws-sdk/protocol-http";
import { parseUrl } from "@aws-sdk/url-parser";
import { Sha256 } from "@aws-crypto/sha256-js";
import { defaultProvider } from "@aws-sdk/credential-provider-node";

export async function issuePutUrl(userId: string) {
  const bucket = process.env.BUCKET!;
  const key = `uploads/${userId}/${crypto.randomUUID()}.pdf`;
  const url = parseUrl(`https://${bucket}.s3.amazonaws.com/${key}`);
  const req = new HttpRequest({
    ...url,
    method: "PUT",
    headers: {
      // ⛔️ 이 헤더들은 클라이언트가 업로드 시 '정확히 동일'해야 함
      "content-type": "application/pdf",
      "x-amz-acl": "bucket-owner-full-control",
      // (선택) MD5 강제
      // "content-md5": base64Md5
    }
  });
  const presigner = new S3RequestPresigner({ region: "ap-northeast-2", credentials: defaultProvider(), sha256: Sha256 as any });
  const expiresIn = 300; // 5분
  const signed = await presigner.presign(req, { expiresIn });
  return { url: signed.href, method: "PUT", headers: req.headers, key, expiresIn };
}
```

> **포인트**
> - **정확한 Key**로만 서명(와일드카드 없음).
> - 반드시 **헤더 포함 서명**(타입/ACL/MD5) → 다른 값이면 **서명 불일치 403**.
> - 대용량 업로드/멀티파트는 별도 정책과 검증 흐름 필요(검역 파이프라인에서 승인 전 공개 금지).

### 다운로드: **응답 헤더 강제**(RFD/스니핑 방지)

S3 Pre-Signed GET은 쿼리 파라미터로 **응답 헤더 덮어쓰기**가 가능(`response-content-type`, `response-content-disposition` 등).
**CloudFront/프록시**에서 **항상 `Content-Disposition: attachment`**, `X-Content-Type-Options: nosniff`를 강제하세요.

```ts
// CloudFront Function (응답 헤더 강제 예시)
function handler(event) {
  var response = event.response;
  var headers = response.headers;
  headers['content-disposition'] = [{ key: 'Content-Disposition', value: 'attachment' }];
  headers['x-content-type-options'] = [{ key: 'X-Content-Type-Options', value: 'nosniff' }];
  return response;
}
```

> **대안**: 업로드 단계에서 **객체 메타데이터**에 `Content-Type`/`Content-Disposition`을 **서버가 설정**하고,
> 공개는 **검증 후 별도 프리픽스/버킷**으로 **복사(copy)** 하여 노출.

### S3 버킷 정책(IAM) — **최소 권한/공개 차단**

```json
{
  "Version": "2012-10-17",
  "Statement": [
    // 1) 퍼블릭 ACL/정책 일절 차단 (계정 레벨 'Block Public Access'도 반드시 On)
    {
      "Sid": "DenyPublicACL",
      "Effect": "Deny",
      "Principal": "*",
      "Action": ["s3:PutObjectAcl", "s3:PutBucketAcl"],
      "Resource": ["arn:aws:s3:::my-bucket", "arn:aws:s3:::my-bucket/*"],
      "Condition": { "StringEquals": { "s3:x-amz-acl": "public-read" } }
    },
    // 2) 업로드는 특정 프리픽스만 허용 (서버에서만 STS로 발급하는 자격에 묶기 권장)
    {
      "Sid": "AllowOnlyPrefix",
      "Effect": "Allow",
      "Principal": { "AWS": "arn:aws:iam::<ACCOUNT>:role/uploader" },
      "Action": ["s3:PutObject"],
      "Resource": ["arn:aws:s3:::my-bucket/uploads/*"]
    },
    // 3) 덮어쓰기 방지: 이미 존재하면 PutObject 거부 (버전닝+조건 활용)
    {
      "Sid": "DenyOverwriteExisting",
      "Effect": "Deny",
      "Principal": "*",
      "Action": "s3:PutObject",
      "Resource": "arn:aws:s3:::my-bucket/uploads/*",
      "Condition": { "StringNotEquals": { "s3:ExistingObjectTag/empty": "true" } }
      // 구현 방식은 다양—실무에선 '버전닝 + 워크플로'로 처리하는 편이 명확
    }
  ]
}
```

> **실무 팁**
> - **계정 레벨 “Block Public Access”**(4가지 모두 **On**).
> - 크로스 계정 업로드에는 **`bucket-owner-full-control`** 강제.
> - **버전닝** 활성화 → 덮어쓰기/롤백 리스크 완화.
> - **CloudTrail Data Events** 로 `PutObject/GetObject/DeleteObject` 추적.

---

## GCS / Azure 예시

### GCS Signed URL (Node)

```ts
import { Storage } from "@google-cloud/storage";
const storage = new Storage();

export async function gcsPut(userId: string) {
  const bucket = storage.bucket(process.env.GCS_BUCKET!);
  const file = bucket.file(`uploads/${userId}/${crypto.randomUUID()}.jpg`);
  const expires = Date.now() + 3 * 60 * 1000; // 3분
  const [url] = await file.getSignedUrl({
    action: "write", expires, contentType: "image/jpeg" // 헤더 고정
  });
  return { url, method: "PUT", headers: { "Content-Type": "image/jpeg" } };
}
```

- **GCS Policy**로 **Content-Length-Range** 를 다이렉트로 강제하기 어렵습니다.
  **업로드 후 검역/검증 파이프라인**에서 사이즈/타입 확인 → 승인된 버킷/프리픽스로 **move**.

### Azure Blob SAS (Node)

```ts
import { BlobSASPermissions, generateBlobSASQueryParameters, StorageSharedKeyCredential } from "@azure/storage-blob";

export function azureSas(container: string, blob: string) {
  const creds = new StorageSharedKeyCredential(process.env.AZ_ACCOUNT!, process.env.AZ_KEY!);
  const startsOn = new Date();
  const expiresOn = new Date(Date.now() + 3 * 60 * 1000);
  const perms = BlobSASPermissions.parse("cw"); // create + write (필요 최소)
  const sas = generateBlobSASQueryParameters({
    containerName: container,
    blobName: blob,
    permissions: perms,
    startsOn, expiresOn,
    protocol: "https",
    // (선택) IP 제한: ipRange: { start: "...", end: "..." }
  }, creds).toString();

  return `https://${process.env.AZ_ACCOUNT!}.blob.core.windows.net/${container}/${blob}?${sas}`;
}
```

> **포인트**
> - 권한(`sp`)은 최소(예: `r`/`w`/`c` 필요한 조합만).
> - **만료(`se`) ≤ 5분**, **프로토콜 `spr=https`**, 필요 시 **IP 제한(`sip`)**.

---

## 업로드 후 **검증 파이프라인**(권장)

1) **검역 버킷/프리픽스**로 업로드(외부 공개 아님).
2) **이벤트 트리거**(S3 EventBridge/GCS PubSub/Azure Event Grid) → 워커에서:
   - **AV 스캔**(ClamAV 등, 대용량은 샘플링/서버리스 아웃소싱),
   - **MIME/시그니처 검증**(매직넘버·라이브러리),
   - **크기/픽셀 치수** 검사(이미지·영상),
   - **메타 정규화**(`Content-Type`, `Content-Disposition: attachment`, 태그).
3) 검증 통과 시 **공개 버킷/프리픽스**로 **copy**(ETag 기록), DB 상태 `approved`.
4) 실패 시 **격리/삭제**, 발급자에게 **실패 사유** 전달.

> 이 구조면 presigned **PUT/POST의 제한이 느슨해도** “**공개 전 검증**”으로 안전성을 확보할 수 있습니다.

---

## CDN/엣지에서 **응답 헤더 강제**

- **항상 다운로드**: `Content-Disposition: attachment; filename="..."`
- **스니핑 금지**: `X-Content-Type-Options: nosniff`
- **CSP(다운로드 도메인)**: `default-src 'none'; frame-ancestors 'none'`(렌더링 방지)
- **별도 다운로드 도메인** 운영(렌더링/쿠키 없는 정적 전용).

CloudFront **Response Headers Policy** 예(요지):
- Add: `Content-Disposition: attachment`
- Add: `X-Content-Type-Options: nosniff`
- Remove: `Content-Security-Policy-Report-Only` 등 혼선을 줄만한 헤더

---

## 서버에서 **TTL/스코프** 정책 선차단

- **서버**가 발급 전 **TTL 상한** 검증(업로드 ≤ 300s, 다운로드 ≤ 900s).
- 요청 컨텍스트(사용자·테넌트·리소스 ID)에 따라 **정확한 Key** 산출 후 발급.
- 서버 DB에 **발급/사용 로그**를 남기고, 필요 시 **1회성(consume) 토큰 레이어**를 얹는다.
  (예: presigned URL 사용 전/후에 **서버 콜백**으로 “활성화” 플래그를 바꿔 실제 접근을 CDN에서 통제)

---

## 관측/경보

- **CloudTrail Data Events**: `PutObject/DeleteObject/PutObjectAcl` 모니터링.
- **S3 Server Access Logs** 또는 **CloudFront Logs**: User-Agent·Key·Size 패턴.
- **탐지 룰 예시**
  - 비정상 **대용량** 업로드 연속 발생
  - **`public-read`** ACL 시도 탐지
  - presigned URL 만료 이후 접근 시도 급증
  - 특정 사용자 프리픽스 외 경로 사용

---

## “막혀야 정상” 테스트 시나리오 (curl)

### 허용되지 않은 Key

```bash
# 서버가 발급한 POST(또는 PUT)는 key가 /uploads/user-123/<uuid>.png인 경우만 성공해야 함

curl -F key="uploads/user-999/evil.png" \
     -F "Content-Type=image/png" \
     -F "x-amz-meta-origin=web" \
     -F "policy=..." -F "x-amz-signature=..." \
     https://my-bucket.s3.amazonaws.com/   # → 403 SignatureDoesNotMatch 여야 정상
```

### 타입 위반/크기 초과

```bash
curl -X PUT -H "Content-Type: text/html" --upload-file ./x.html "https://...signed-url..."
# → 403 (서명 불일치) 또는 검역 단계에서 'reject'

```

### ACL 공개 시도

```bash
curl -X PUT -H "x-amz-acl: public-read" --upload-file ./a.png "https://...signed-url..."
# → 버킷 정책 Deny 또는 서명 불일치로 실패

```

### TTL 초과

```bash
# 10분 뒤 동일 URL 재시도 → 403 AccessDenied (만료)

```

---

## 보너스: 덮어쓰기/혼선 방지 패턴

- **버전닝 + 태그 정책**: 승인 전 객체에는 `tag=quarantine`, 승인 후 `tag=approved`.
  CDN은 **approved 프리픽스**만 오리진으로 허용.
- **Key 충돌 방지**: 서버가 **랜덤 UUIDv4/ULID** 생성(사용자 임의 파일명 금지) + **확장자 화이트리스트**.
- **소유권 일관**: 항상 `x-amz-acl: bucket-owner-full-control`.
- **CORS 최소화**: 특정 오리진만 PUT 허용 + `Content-Type`/헤더 화이트리스트.

---

## 체크리스트(현장용)

- [ ] 업로드 TTL **≤ 3–5분**, 다운로드 TTL **≤ 10–15분**
- [ ] **정확한 Key**(서버가 발급), 사용자 임의 Key 금지
- [ ] Pre-Signed **POST**로 `content-length-range`/`Content-Type`/`x-amz-acl` **조건 강제**
- [ ] Pre-Signed **PUT** 사용 시 헤더(타입/ACL/MD5) **서명에 포함**
- [ ] 다운로드는 **`Content-Disposition: attachment` + nosniff**(엣지에서 강제)
- [ ] **검역→검증→승인** 파이프라인(AV/MIME/크기/메타 정규화)
- [ ] 버킷 **Block Public Access** ON, 버전닝 ON
- [ ] `bucket-owner-full-control` 강제, public ACL **Deny**
- [ ] CloudTrail Data Events/액세스 로그 모니터링 + 경보
- [ ] CI/E2E “막혀야 정상” 테스트(키/타입/TTL/ACL 위반)

---

## 맺음말

서명 URL은 **성능/확장성**을 위해 강력하지만, **TTL/경로/헤더**를 풀어두는 순간
서버 권한 모델을 우회하는 **직통 관문**이 됩니다.
**짧은 TTL + 정확한 Key/메서드 + 헤더 강제 + 검역 파이프라인 + 최소권한 IAM**을 표준으로 삼으면
임의 업로드·오염·덮어쓰기 위험을 **구조적으로 차단**할 수 있습니다.
