---
layout: post
title: Java - 리플렉션 API
date: 2025-08-09 18:20:23 +0900
category: Java
---
# 리플렉션(Reflection) API 사용법 — 자세 정리

**리플렉션(Reflection)**은 **런타임에 클래스/메서드/필드/생성자/애너테이션 등의 메타데이터를 조사하고 조작**할 수 있게 하는 기능입니다.  
프레임워크(스프링, JUnit, Hibernate 등)의 핵심 기술이며, **동적 인스턴스 생성, 의존 주입, AOP, 직렬화/매핑** 등에 널리 사용됩니다.

> ⚠️ 주의: 리플렉션은 **성능 비용**과 **캡슐화 파괴 위험**이 있습니다. 꼭 필요할 때만, 최소 범위로 사용하고, 결과(메서드/필드/생성자)는 **캐시**해서 재사용하세요.

---

## 1) Class 객체 얻기

```java
// 1. 리터럴
Class<String> c1 = String.class;

// 2. 인스턴스에서
Object obj = "hello";
Class<?> c2 = obj.getClass();

// 3. FQCN으로 로딩(동적)
Class<?> c3 = Class.forName("java.util.ArrayList");

// 4. 원시 타입/배열
Class<?> c4 = int.class;
Class<?> c5 = int[].class;
```

- `Class.forName`은 클래스 초기화까지 수행합니다(옵션으로 제어 가능).
- 특정 로더로 로드하려면 `ClassLoader#loadClass` 사용.

---

## 2) 클래스 메타데이터 조사

```java
Class<?> clazz = java.util.HashMap.class;

// 기본 정보
String name = clazz.getName();           // "java.util.HashMap"
Package pkg = clazz.getPackage();
int modifiers = clazz.getModifiers();    // public, final 등
boolean isInterface = clazz.isInterface();
boolean isEnum = clazz.isEnum();
boolean isRecord = clazz.isRecord();

// 상속/구현
Class<?> superClass = clazz.getSuperclass();      // AbstractMap
Class<?>[] ifaces = clazz.getInterfaces();        // Map, Cloneable, Serializable

// 멤버 조회 (상속 포함 공개 멤버 vs 선언 멤버)
var fields = clazz.getFields();                   // public만(상속 포함)
var declaredFields = clazz.getDeclaredFields();   // 접근 지정자 무관, 선언된 것만
var methods = clazz.getMethods();
var declaredMethods = clazz.getDeclaredMethods();
var ctors = clazz.getConstructors();
var declaredCtors = clazz.getDeclaredConstructors();

// 모디파이어 검사
import java.lang.reflect.Modifier;
boolean isPublic = Modifier.isPublic(modifiers);
```

> `getDeclared*`는 **현재 클래스에 선언된 멤버만** 반환(접근 제한 무시 X),  
> `get*`는 **상속받은 public 멤버**까지 포함합니다.

---

## 3) 인스턴스 생성

```java
Class<?> clazz = Class.forName("example.User");

// newInstance()는 deprecated → 생성자를 통해 생성
Object user = clazz.getDeclaredConstructor().newInstance(); // 기본 생성자

// 파라미터 있는 생성자
var ctor = clazz.getDeclaredConstructor(String.class, int.class);
ctor.setAccessible(true); // 비공개 생성자 접근(모듈/보안 제약 시 실패 가능)
Object user2 = ctor.newInstance("Alice", 30);
```

**예외 처리**: `ClassNotFoundException`, `NoSuchMethodException`,  
`InstantiationException`, `IllegalAccessException`, `InvocationTargetException`

---

## 4) 메서드 호출 (invoke)

```java
Class<?> clazz = Class.forName("example.User");
Object target = clazz.getDeclaredConstructor().newInstance();

// 메서드: String greet(String)
var m = clazz.getDeclaredMethod("greet", String.class);
m.setAccessible(true); // private 접근 시
Object ret = m.invoke(target, "Hi"); // static이면 target에 null 전달
System.out.println(ret);
```

- 오토박싱/언박싱이 적용됩니다.
- 오버로딩 주의: **정확한 시그니처**로 조회하세요.
- 예외는 `InvocationTargetException`에 래핑되어 전달됩니다.

---

## 5) 필드 읽기/쓰기

```java
Class<?> clazz = Class.forName("example.User");
Object target = clazz.getDeclaredConstructor().newInstance();

var f = clazz.getDeclaredField("age");
f.setAccessible(true);              // private 접근
int age = (int) f.get(target);      // primitive는 getInt/setInt 등도 가능
f.set(target, 42);                  // 값 쓰기

// static 필드
var sf = clazz.getDeclaredField("VERSION");
sf.setAccessible(true);
Object v = sf.get(null);            // static은 인스턴스 대신 null
```

> `final` 필드는 JVM/컴파일러 최적화 때문에 **안정적으로 변경하기 어렵습니다**(특히 최신 JDK/모듈 환경).  
> 값 변경을 설계에 의존하지 마세요.

---

## 6) 파라미터, 반환/제네릭 타입 조사

```java
import java.lang.reflect.*;

Method m = List.class.getMethod("add", Object.class);

// 파라미터
for (Parameter p : m.getParameters()) {
    System.out.println(p.getName()); // -parameters로 컴파일해야 실제 이름 유지
}

// 제네릭 정보 (필드/메서드/파라미터)
Field field = Example.class.getDeclaredField("map"); // Map<String, Integer>
Type gtype = field.getGenericType();
if (gtype instanceof ParameterizedType pt) {
    Type keyType = pt.getActualTypeArguments()[0];   // String
    Type valType = pt.getActualTypeArguments()[1];   // Integer
}
```

> **타입 소거(Type Erasure)** 때문에 런타임에는 대부분의 제네릭 정보가 지워집니다.  
> 그래도 `ParameterizedType`, `TypeVariable`, `GenericArrayType` 등을 통해 선언부의 제네릭 정보를 확인할 수 있습니다.

---

## 7) 애너테이션 조회

```java
// 클래스/메서드/필드 등에 공통
Role role = clazz.getAnnotation(Role.class);
boolean present = clazz.isAnnotationPresent(Role.class);

// 반복 애너테이션
Tag[] tags = clazz.getAnnotationsByType(Tag.class);

// 선언된 것만(상속 제외)
var a1 = clazz.getDeclaredAnnotation(Role.class);

// 모든 애너테이션
Annotation[] all = clazz.getAnnotations();
```

> 런타임에 보이게 하려면 애너테이션에 **@Retention(RUNTIME)**이 필요합니다.

---

## 8) 배열 조작 (java.lang.reflect.Array)

```java
import java.lang.reflect.Array;

// 생성
Object arr = Array.newInstance(String.class, 3); // String[3]
Array.set(arr, 0, "a");
Array.set(arr, 1, "b");
System.out.println(Array.getLength(arr));        // 3
System.out.println(Array.get(arr, 1));           // b

// 다차원
Object m2 = Array.newInstance(int.class, 2, 3);  // int[2][3]
```

---

## 9) 동적 프록시 (java.lang.reflect.Proxy)

**인터페이스 기반** 런타임 프록시 생성 — AOP/로깅/트랜잭션 경계 등에 유용.

```java
import java.lang.reflect.*;

interface Hello { String say(String name); }

class Handler implements InvocationHandler {
    private final Object target;
    Handler(Object target) { this.target = target; }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        long t = System.nanoTime();
        try {
            return method.invoke(target, args);
        } finally {
            System.out.println(method.getName() + " took " + (System.nanoTime()-t) + "ns");
        }
    }
}

Hello target = n -> "Hello " + n;
Hello proxy = (Hello) Proxy.newProxyInstance(
        Hello.class.getClassLoader(),
        new Class<?>[]{Hello.class},
        new Handler(target));

System.out.println(proxy.say("Java"));
```

> 클래스 프록시가 필요하면 **ByteBuddy, CGLIB** 같은 라이브러리를 사용합니다.

---

## 10) MethodHandles (간단 비교)

`java.lang.invoke.MethodHandles`는 **리플렉션보다 빠른** 저수준 호출 핸들입니다.  
동일한 작업을 더 타입-안전하고 성능 좋게 할 수 있으나, 초기 설정이 더 복잡합니다.

```java
import java.lang.invoke.*;

MethodHandles.Lookup lookup = MethodHandles.lookup();
MethodHandle mh = lookup.findVirtual(String.class, "toUpperCase",
        MethodType.methodType(String.class));
String r = (String) mh.invoke("java"); // "JAVA"
```

---

## 11) 레코드(Record) 리플렉션

```java
if (clazz.isRecord()) {
    for (var rc : clazz.getRecordComponents()) {
        System.out.println(rc.getName() + " : " + rc.getType());
        // rc.getAccessor().invoke(recordObj) 로 값 조회 가능
    }
}
```

---

## 12) 모듈/접근 제약 (Java 9+)

- `setAccessible(true)`는 **모듈 경계**를 넘을 때 `InaccessibleObjectException`이 날 수 있습니다.
- 비공개 패키지를 반사로 열려면 **명령행 옵션** 필요:
  - `--add-opens module/package=ALL-UNNAMED` (또는 특정 모듈/패키지 대상)
- 라이브러리/프레임워크는 보통 적절한 `--add-opens` 가이드를 제공합니다.

---

## 13) 보안·성능·베스트 프랙티스

- **최소 권한/최소 범위**: `getDeclared*` + `setAccessible(true)`는 꼭 필요할 때만.
- **캐싱**: `Field`, `Method`, `Constructor` 조회는 비쌉니다. 한 번 찾은 후 **캐시**하세요.
- **예외 처리**: `InvocationTargetException#getCause()`로 실제 원인 확인.
- **파라미터 이름**: 컴파일 시 `-parameters` 옵션을 사용해야 `Parameter#getName()`이 실제 이름을 반환.
- **유저 입력 기반 클래스 로딩 금지**: 클래스명/메서드명을 외부 입력 그대로 사용하면 보안 위험.
- **대안 고려**: 퍼포먼스-크리티컬 경로에서는 **직접 호출**이나 **MethodHandles**를 우선.

---

## 14) 한눈에 보는 사용 시나리오별 스니펫

### (A) 타입 이름 → 인스턴스 생성
```java
Object newInstance(String fqcn) throws Exception {
    Class<?> c = Class.forName(fqcn);
    return c.getDeclaredConstructor().newInstance();
}
```

### (B) private 필드 값 읽기/쓰기
```java
Object getField(Object target, String name) throws Exception {
    Field f = target.getClass().getDeclaredField(name);
    f.setAccessible(true);
    return f.get(target);
}
```

### (C) 애너테이션 처리
```java
<T extends Annotation> T findAnno(Class<?> type, Class<T> anno) {
    return type.getAnnotation(anno); // 필요 시 getAnnotationsByType
}
```

---

## 15) 마무리 체크리스트

- [ ] Class 획득: `.class`, `obj.getClass()`, `Class.forName()`  
- [ ] 멤버 조사: `get*` vs `getDeclared*` 차이 이해  
- [ ] 생성: `getDeclaredConstructor(...).newInstance()` 사용  
- [ ] 호출/접근: `Method#invoke`, `Field#get/set` (+ `setAccessible(true)`)  
- [ ] 제네릭/애너테이션: `getGenericType`, `getAnnotation(s)`  
- [ ] 배열: `Array.newInstance`, `Array.get/set`  
- [ ] 프록시: `Proxy.newProxyInstance` + `InvocationHandler`  
- [ ] 모듈 제약: 필요 시 `--add-opens`  
- [ ] 성능/보안: 결과 캐시, 최소 사용, 예외 처리 철저
