---
layout: post
title: Java - 리플렉션 API
date: 2025-08-09 18:20:23 +0900
category: Java
---
# API 사용법

## 큰 그림 — 리플렉션이 해결하는 문제와 한계

| 영역 | 해결하는 문제 | 전형적 사용처 | 한계/주의 |
|---|---|---|---|
| 타입 메타데이터 | 클래스/인터페이스/레코드/열거형/시일드 클래스 구조를 런타임에 파악 | DI 컨테이너, 객체-스키마 매핑, 테스트 프레임워크 | 모듈·접근 제약(JPMS), 성능 비용 |
| 멤버 접근 | private/protected 멤버 읽기/쓰기/호출 | 직렬화, ORM 바인딩, 프록시 | `setAccessible(true)`는 모듈 경계에서 제한 |
| 제네릭/애너테이션 | 제네릭 선언/애너테이션 모델 해석 | 검증, 코드 생성, 스캐닝 | 타입 소거로 인해 정보 제한 |
| 동적 프록시 | 인터페이스 기반 런타임 프록시 | AOP, 트랜잭션, 로깅 | 클래스 프록시는 별도 라이브러리 필요 |
| 대안 | MethodHandles/VarHandle | 고성능 호출/메모리 접근 | 초기 설정 복잡, JPMS 룩업 필요 |

---

## Class 객체 획득 — 4가지 경로와 주의점

```java
// (1) 리터럴
Class<String> c1 = String.class;

// (2) 인스턴스에서
Object o = "hi";
Class<?> c2 = o.getClass();

// (3) FQCN 로딩(초기화 포함)
Class<?> c3 = Class.forName("java.util.ArrayList");

// (4) 원시/배열/다차원 배열
Class<?> c4 = int.class;       // 원시
Class<?> c5 = int[].class;     // 1차 배열
Class<?> c6 = int[][].class;   // 2차 배열
```

- `Class.forName(String)`은 **클래스 초기화**를 수행한다. 초기화를 지연하려면 `Class.forName(name, false, loader)`를 사용.
- 특정 로더를 강제하려면 `ClassLoader#loadClass` 사용. 플러그인/샌드박스에서는 **컨텍스트 클래스 로더**를 고려.

---

## 클래스 메타데이터 조사 — 선언 vs 상속 포함

```java
Class<?> clazz = java.util.HashMap.class;

// 기본 정보
String name = clazz.getName();
Package pkg = clazz.getPackage();
int mods = clazz.getModifiers();
boolean record = clazz.isRecord();
boolean isSealed = clazz.isSealed(); // Java 17+

// 상속/구현
Class<?> superClass = clazz.getSuperclass();
Class<?>[] ifaces = clazz.getInterfaces();

// 멤버: 선언 vs 상속 포함
var fields          = clazz.getFields();                // public, 상속 포함
var declaredFields  = clazz.getDeclaredFields();        // 해당 클래스에 선언된 모든 필드
var methods         = clazz.getMethods();               // public, 상속 포함
var declaredMethods = clazz.getDeclaredMethods();       // 선언 메서드만
var ctors           = clazz.getConstructors();
var declaredCtors   = clazz.getDeclaredConstructors();
```

- `getDeclared*`는 **선언 범위**만, 접근 제어는 여전히 적용(필요 시 `setAccessible(true)`).
- `Modifier` 유틸로 접근자/정적/추상 등 비트 확인.

---

## 대신 생성자 호출

```java
Class<?> c = Class.forName("example.User");

// 기본 생성자
Object u1 = c.getDeclaredConstructor().newInstance();

// 파라미터 생성자
var ctor = c.getDeclaredConstructor(String.class, int.class);
ctor.setAccessible(true);              // private 생성자 접근
Object u2 = ctor.newInstance("Alice", 30);
```

- 예외: `ClassNotFoundException`, `NoSuchMethodException`, `InstantiationException`, `IllegalAccessException`, `InvocationTargetException`.
- **권장**: `newInstance()`(deprecated) 대신 **명시적 생성자 + `newInstance()`**.

---

## 메서드 호출 — 정확한 시그니처 & 예외 처리

```java
Class<?> c = Class.forName("example.User");
Object target = c.getDeclaredConstructor().newInstance();

// String greet(String)
var m = c.getDeclaredMethod("greet", String.class);
m.setAccessible(true);
Object ret = m.invoke(target, "Hi"); // static이면 target=null
```

- 오버로딩은 **정확한 파라미터 타입**으로 조회.
- 호출 예외는 `InvocationTargetException`에 포장 → `getCause()`로 원인 확인.

---

## 필드 읽기/쓰기 — primitive 전용 접근자 활용

```java
Class<?> c = Class.forName("example.User");
Object target = c.getDeclaredConstructor().newInstance();

var f = c.getDeclaredField("age");
f.setAccessible(true);
int age = f.getInt(target); // primitive 전용
f.setInt(target, 42);

// static 필드
var sf = c.getDeclaredField("VERSION");
sf.setAccessible(true);
Object v = sf.get(null);
```

> `final` 필드 변경은 JIT/constant folding로 **일관 보장 어려움**. 설계로 회피.

---

## 배열 조작 — java.lang.reflect.Array

```java
import java.lang.reflect.Array;

Object arr = Array.newInstance(String.class, 3);
Array.set(arr, 0, "a");
Array.set(arr, 1, "b");
System.out.println(Array.getLength(arr)); // 3
System.out.println(Array.get(arr, 1));    // b

Object m2 = Array.newInstance(int.class, 2, 3); // int[2][3]
```

---

## 제네릭/AnnotatedType/TypeVariable — 타입 소거의 벽 넘기

```java
import java.lang.reflect.*;

class Example {
    Map<String, Integer> map;
    List<? extends Number> numbers;
    <T extends Comparable<T>> T max(T a, T b) { return a.compareTo(b) >= 0 ? a : b; }
}

Field f = Example.class.getDeclaredField("map");
Type t = f.getGenericType();
if (t instanceof ParameterizedType pt) {
    Type k = pt.getActualTypeArguments()[0]; // String
    Type v = pt.getActualTypeArguments()[1]; // Integer
}

Field f2 = Example.class.getDeclaredField("numbers");
AnnotatedType at = f2.getAnnotatedType(); // 어노테이션 포함 타입 표현
```

- 제네릭은 런타임에 **소거**되지만, 선언부의 제네릭 구조는 `Type` 서브타입으로 조회 가능.
- `TypeVariable`에서 **상한(bounded) 타입** 확인:
```java
Method m = Example.class.getDeclaredMethod("max", Comparable.class, Comparable.class);
for (TypeVariable<Method> tv : m.getTypeParameters()) {
    Type[] bounds = tv.getBounds(); // Comparable<T> 등
}
```

---

## 애너테이션 — 선언/반복/상속/메타

```java
// 선언 및 조회
Role role = clazz.getAnnotation(Role.class);
boolean hasRole = clazz.isAnnotationPresent(Role.class);

// 반복 애너테이션
Tag[] tags = clazz.getAnnotationsByType(Tag.class);

// 선언된 것만(상속 제외)
var a1 = clazz.getDeclaredAnnotation(Role.class);

// 모든 애너테이션
Annotation[] all = clazz.getAnnotations();
```

- 런타임 조회에는 **@Retention(RUNTIME)** 필수.
- 상속은 **@Inherited**가 붙은 클래스 레벨 애너테이션에서만 부모→자식으로 전파.

---

## 동적 프록시 — 인터페이스 기반 AOP/로깅/트랜잭션

```java
import java.lang.reflect.*;

interface Hello { String say(String name); }

class LogHandler implements InvocationHandler {
    private final Object target;
    LogHandler(Object t) { this.target = t; }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        long t0 = System.nanoTime();
        try {
            return method.invoke(target, args);
        } finally {
            System.out.println(method.getName() + " took " + (System.nanoTime()-t0) + "ns");
        }
    }
}

Hello base = n -> "Hello " + n;
Hello proxied = (Hello) Proxy.newProxyInstance(
        Hello.class.getClassLoader(),
        new Class<?>[]{Hello.class},
        new LogHandler(base));

System.out.println(proxied.say("Java"));
```

- **클래스 프록시**는 JDK 기본으로는 불가 → **CGLIB/ByteBuddy** 활용.

---

## MethodHandles & VarHandle — 고성능 대안

### MethodHandle (메서드/생성자/필드 getter·setter에 대한 호출句)

```java
import java.lang.invoke.*;

MethodHandles.Lookup lookup = MethodHandles.lookup();
MethodHandle mh = lookup.findVirtual(String.class, "toUpperCase",
        MethodType.methodType(String.class));
String r = (String) mh.invoke("java"); // "JAVA"
```

- **private 멤버** 접근: `MethodHandles.privateLookupIn(Target.class, lookup)`로 **제한된 룩업** 획득.

```java
var pl = MethodHandles.privateLookupIn(Example.class, MethodHandles.lookup());
MethodHandle ctor = pl.findConstructor(Example.class, MethodType.methodType(void.class));
Object inst = ctor.invoke();
```

### VarHandle (필드/배열/바이트버퍼 원자적·가시성 제어 포함)

```java
import java.lang.invoke.*;

class Counter { volatile int x; }
VarHandle X = MethodHandles.lookup()
        .in(Counter.class)
        .findVarHandle(Counter.class, "x", int.class);

Counter c = new Counter();
X.set(c, 10);
boolean ok = X.compareAndSet(c, 10, 11);
int v = (int) X.getVolatile(c);
```

- JMM(메모리 모델) 친화적 접근(`getAcquire`, `setRelease`, `getOpaque` 등). 락-프리 자료구조 구현에 유용.
- **성능**: 반복 호출 경로에서 일반 리플렉션 대비 유리.

---

## 리플렉션

```java
// 레코드
if (clazz.isRecord()) {
    for (var rc : clazz.getRecordComponents()) {
        System.out.println(rc.getName() + " : " + rc.getType());
        // rc.getAccessor().invoke(recordObj) 로 값 조회
    }
}

// 열거형
if (clazz.isEnum()) {
    Object[] consts = clazz.getEnumConstants(); // 상수 배열
}

// 시일드 클래스(Java 17+)
if (clazz.isSealed()) {
    for (Class<?> p : clazz.getPermittedSubclasses()) {
        System.out.println("permits: " + p.getName());
    }
}
```

---

## JPMS(모듈)와 리플렉션 — exports vs opens, 실행 옵션

| 항목 | 의미 | 컴파일 영향 | 런타임 영향 | 용례 |
|---|---|---|---|---|
| `exports p` | 정적 접근 허용 | O | O | API 패키지 공개 |
| `opens p` | 리플렉션 허용 | X | O | 직렬화/ORM/바인딩 |
| `... to M` | 특정 모듈 한정 | 동일 | 동일 | 최소 공개/개방 |

- `setAccessible(true)`는 모듈 경계를 넘으면 `InaccessibleObjectException`.
  → **실행 옵션**으로 개방 가능:
```bash
# 특정 패키지를 테스트 런타임에만 개방

java --add-opens com.example.app/com.example.app.model=org.junit.platform.commons ...
```

- 프레임워크 가이드대로 대상 패키지에 **정밀한 `opens … to`**를 선언하는 것이 이상적.

---

## ClassLoader와 리플렉션 — 플러그인/격리/리소스

- **컨텍스트 클래스 로더**(TCCL) 패턴: 프레임워크가 사용자 클래스를 로딩할 때 흔히 사용.
```java
ClassLoader cl = Thread.currentThread().getContextClassLoader();
Class<?> t = Class.forName("user.PluginImpl", true, cl);
```

- 모듈 레이어와 결합하면 **플러그인 격리**를 구현 가능(여러 버전 공존).
  (필요 시 `ModuleLayer`와 `ServiceLoader` 결합)

- 리소스 로딩은 `clazz.getResourceAsStream("/path")` 또는 `cl.getResourceAsStream("path")` 활용.

---

## 보안/안정성 — 최소 권한·입력 검증·예외 처리

- **최소 권한**: 꼭 필요한 멤버에만 `setAccessible(true)` 또는 `opens` 적용.
- **입력 검증**: 외부 입력(FQCN/메서드명)을 그대로 사용하지 말고, **화이트리스트**/검증 로직을 둔다.
- **예외 처리**: 래핑된 예외의 `getCause()` 확인. 스택트레이스가 감춰지지 않도록 주의.
- **캐싱**: `Method`, `Field`, `Constructor`, `MethodHandle`, `VarHandle`은 조회 비용이 높으므로 맵에 캐시.
- **final/constant**: 상수/컴파일타임 상수는 변경해도 **호출자에 반영되지 않을 수 있음**.

---

## 실전 유틸 — 리플렉션 헬퍼(안전 호출/캐싱)

```java
// (A) 안전한 메서드 호출 + 캐시
public final class Reflects {
    private static final Map<String, Method> CACHE = new ConcurrentHashMap<>();

    public static Object invoke(Object target, String name, Class<?>[] paramTypes, Object... args) {
        Class<?> c = target.getClass();
        String key = c.getName() + "#" + name + Arrays.toString(paramTypes);
        try {
            Method m = CACHE.computeIfAbsent(key, k -> {
                try {
                    Method mm = c.getDeclaredMethod(name, paramTypes);
                    mm.setAccessible(true);
                    return mm;
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            });
            return m.invoke(target, args);
        } catch (InvocationTargetException e) {
            throw sneaky(e.getCause());
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    private static RuntimeException sneaky(Throwable t) {
        if (t instanceof RuntimeException re) return re;
        return new RuntimeException(t);
    }
}
```

```java
// (B) 필드 값 복사(간단 버전): 이름/타입 동일 멤버 매핑
public static void copy(Object src, Object dst) {
    Map<String, Field> srcFields = Arrays.stream(src.getClass().getDeclaredFields())
            .peek(f -> f.setAccessible(true))
            .collect(Collectors.toMap(Field::getName, f -> f, (a,b)->a));

    for (Field df : dst.getClass().getDeclaredFields()) {
        df.setAccessible(true);
        Field sf = srcFields.get(df.getName());
        if (sf != null && df.getType().isAssignableFrom(sf.getType())) {
            try { df.set(dst, sf.get(src)); } catch (Exception ignore) {}
        }
    }
}
```

---

## 예제 시나리오 — 초간이 DI 컨테이너(생성자/필드 주입)

```java
@Retention(RUNTIME) @Target({ElementType.CONSTRUCTOR, ElementType.FIELD})
@interface Inject {}

class ServiceA { String ping() { return "A"; } }
class ServiceB {
    @Inject ServiceA a; // 필드 주입
    String go() { return "B->" + a.ping(); }
}
class App {
    private final ServiceB b;
    @Inject App(ServiceB b) { this.b = b; } // 생성자 주입
    void run() { System.out.println(b.go()); }
}

class MiniDI {
    private final Map<Class<?>, Object> singletons = new HashMap<>();

    @SuppressWarnings("unchecked")
    <T> T get(Class<T> type) {
        return (T) singletons.computeIfAbsent(type, this::create);
    }

    private Object create(Class<?> type) {
        try {
            // (1) @Inject 생성자 선택
            Constructor<?> ctor = Arrays.stream(type.getDeclaredConstructors())
                    .filter(c -> c.isAnnotationPresent(Inject.class))
                    .findFirst()
                    .orElseGet(() -> {
                        try { return type.getDeclaredConstructor(); }
                        catch (Exception e) { throw new RuntimeException("No usable ctor: " + type, e); }
                    });
            ctor.setAccessible(true);

            // (2) 파라미터 재귀 생성
            Object[] args = Arrays.stream(ctor.getParameterTypes())
                    .map(this::get).toArray();

            Object instance = ctor.newInstance(args);

            // (3) @Inject 필드 주입
            for (Field f : type.getDeclaredFields()) {
                if (f.isAnnotationPresent(Inject.class)) {
                    f.setAccessible(true);
                    f.set(instance, get(f.getType()));
                }
            }
            return instance;
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e.getCause());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        MiniDI di = new MiniDI();
        di.get(App.class).run(); // "B->A"
    }
}
```

- 리플렉션으로 **생성자/필드 주입**을 구현. 실제 프레임워크는 스코프, 프로바이더, 순환 의존, 라이프사이클 훨씬 더 정교.

---

## 테스트/빌드 환경 팁 — 파라미터 이름·모듈 옵션

- **파라미터 이름 보존**: 컴파일 시 `-parameters` 사용 → `Parameter#getName()`에서 실제 이름 제공.
- **테스트 런처에 `--add-opens`**: JPMS 환경에서 리플렉션이 필요한 모델 패키지를 테스트 시 개방.
  - Maven Surefire:
    ```xml
    <argLine>
      --add-opens com.example.app/com.example.app.model=org.junit.platform.commons
    </argLine>
    ```
  - Gradle:
    ```kotlin
    tasks.test {
        jvmArgs("--add-opens", "com.example.app/com.example.app.model=ALL-UNNAMED")
    }
    ```

---

## 성능 최적화 — 언제 무엇을 택할까

1. **일회성/희귀 호출**: 순수 리플렉션으로도 충분.
2. **빈번 호출**: 조회 결과(메서드/필드/생성자)를 **캐시**.
3. **핫패스**: MethodHandle/VarHandle로 전환.
4. **AOP/프록시**: JDK 동적 프록시(인터페이스) → 클래스 프록시는 ByteBuddy/CGLIB.
5. **JIT 우호 코드**: 조건 분기 줄이고, 호출 경로를 안정화(예: 미리 바운드된 MethodHandle).

---

## 자주 겪는 오류 — 원인·해결

| 증상 | 원인 | 해결 |
|---|---|---|
| `NoSuchMethodException` | 잘못된 시그니처/오버로딩 | 파라미터 타입 배열 정확히 지정 |
| `IllegalAccessException` | 접근 제한 | `setAccessible(true)` 또는 설계 변경 |
| `InaccessibleObjectException`(Java 9+) | 모듈 경계 | `opens` 선언 또는 `--add-opens` |
| `InvocationTargetException` | 대상 메서드 예외 | `getCause()`로 실제 예외 확인 |
| `ClassNotFoundException` | 잘못된 로더/경로 | 컨텍스트 로더 확인, 의존 추가 |
| `IllegalArgumentException` | 잘못된 인수 타입 | 박싱/언박싱/배열 타입 점검 |

---

## 리플렉션과 대안 기술의 선택 기준 표

| 시나리오 | 권장 |
|---|---|
| 단순 생성/호출(희귀) | 리플렉션 직접 호출 |
| 매우 빈번한 getter/setter/연산 | VarHandle/MethodHandle |
| 인터페이스 프록시 | JDK 동적 프록시 |
| 클래스 프록시 | ByteBuddy/CGLIB |
| 직렬화/바인딩(모델 리플렉션) | `opens` 최소 범위 + 프레임워크 가이드 준수 |
| 모듈·플러그인 격리 | ModuleLayer + ServiceLoader |

---

## 한 페이지 체크리스트

- [ ] `get*` vs `getDeclared*` 차이를 이해하고 선택했는가?
- [ ] `setAccessible(true)`는 꼭 필요한 곳에만 썼는가?
- [ ] 잦은 조회 결과는 **캐시**했는가?
- [ ] 파라미터 이름이 필요하면 `-parameters`로 컴파일했는가?
- [ ] 모듈 환경에서 필요한 패키지에 `opens` 또는 `--add-opens`를 적용했는가?
- [ ] final/constant 수정에 의존하지 않는가?
- [ ] 보안상 외부 입력으로 클래스/메서드명을 직접 사용하지 않는가?
- [ ] 성능 민감 구간은 MethodHandle/VarHandle로 전환했는가?

---

## 요약 예제 모음 (스니펫 빠른 참조)

### 타입 이름 → 인스턴스

```java
Object newInstance(String fqcn) throws Exception {
    Class<?> c = Class.forName(fqcn);
    return c.getDeclaredConstructor().newInstance();
}
```

### private 필드 읽기/쓰기

```java
Object read(Object t, String f) throws Exception {
    Field fd = t.getClass().getDeclaredField(f);
    fd.setAccessible(true);
    return fd.get(t);
}
```

### 메서드 호출

```java
Object call(Object t, String name, Class<?>[] types, Object... args) throws Exception {
    Method m = t.getClass().getDeclaredMethod(name, types);
    m.setAccessible(true);
    return m.invoke(t, args);
}
```

### MethodHandle로 toUpperCase

```java
MethodHandle mh = MethodHandles.lookup().findVirtual(
        String.class, "toUpperCase", MethodType.methodType(String.class));
String r = (String) mh.invoke("ok");
```

### VarHandle로 CAS

```java
class Box { volatile int v; }
VarHandle VH = MethodHandles.lookup()
    .in(Box.class)
    .findVarHandle(Box.class, "v", int.class);
Box b = new Box();
VH.set(b, 1);
VH.compareAndSet(b, 1, 2);
```

---

## 마무리

리플렉션은 “무엇이 있는지”를 알아내고 “원래 설계를 넘어” 동작하게 만드는 강력한 수단이다.
그러나 장기 유지보수와 보안·성능을 위해 **최소 표면적 원칙**을 지키고, 빈번 경로는 **MethodHandles/VarHandle**로 대체하자.
JPMS 시대에는 `exports`와 `opens`를 구분하여 **API는 공개, 내부는 은닉**, 리플렉션이 필요한 범위만 **정밀 개방**하는 습관이 중요하다.
