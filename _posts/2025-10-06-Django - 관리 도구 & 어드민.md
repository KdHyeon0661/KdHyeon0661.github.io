---
layout: post
title: Django - 관리 도구 & 어드민
date: 2025-10-06 16:25:23 +0900
category: Django
---
# 9. 관리 도구 & 어드민

## A. Django Admin — 컬럼/액션/필터 커스터마이징, 인라인, 임포트-익스포트

### A-1. 예제 모델(공통)

```python
# apps/shop/models.py
from django.db import models
from django.conf import settings

class Category(models.Model):
    name = models.CharField(max_length=80, unique=True)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return self.name

class Shop(models.Model):
    name = models.CharField(max_length=120)
    owner = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.PROTECT)
    domain = models.CharField(max_length=120, blank=True)
    is_premium = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)

class Product(models.Model):
    shop = models.ForeignKey(Shop, on_delete=models.CASCADE, related_name="products")
    category = models.ForeignKey(Category, on_delete=models.PROTECT, related_name="products")
    name = models.CharField(max_length=180)
    price = models.PositiveIntegerField()
    stock = models.PositiveIntegerField(default=0)
    is_public = models.BooleanField(default=True)
    rating = models.DecimalField(max_digits=3, decimal_places=2, default=0)  # 0~5
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [models.Index(fields=["shop", "category", "is_public", "price"])]

class ProductImage(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name="images")
    alt = models.CharField(max_length=120, blank=True)
    file = models.ImageField(upload_to="product/")
    is_main = models.BooleanField(default=False)
    order = models.PositiveIntegerField(default=0)
```

---

### A-2. 기본 Admin 등록 + 리스트 컬럼/검색/정렬

```python
# apps/shop/admin.py
from django.contrib import admin
from django.utils.html import format_html
from .models import Shop, Category, Product, ProductImage

@admin.register(Category)
class CategoryAdmin(admin.ModelAdmin):
    list_display = ("id", "name", "is_active", "product_count")
    list_editable = ("is_active",)
    search_fields = ("name",)
    list_filter = ("is_active",)

    @admin.display(ordering="products__count", description="상품 수")
    def product_count(self, obj):
        return obj.products.count()

@admin.register(Shop)
class ShopAdmin(admin.ModelAdmin):
    list_display = ("id", "name", "owner", "domain_link", "is_premium", "created_at")
    list_filter = ("is_premium", "created_at")
    search_fields = ("name", "owner__username", "domain")
    date_hierarchy = "created_at"
    autocomplete_fields = ("owner",)
    readonly_fields = ("created_at",)

    @admin.display(description="도메인")
    def domain_link(self, obj):
        if not obj.domain:
            return "-"
        return format_html('<a href="https://{0}" target="_blank">{0}</a>', obj.domain)
```

> 팁  
> - `@admin.display(ordering="field")` 로 **정렬 가능 열** 구현.  
> - `autocomplete_fields` 는 대상 모델에 `search_fields` 가 설정되어 있어야 동작.  
> - `list_editable` 은 첫 번째 열(체크박스/링크)을 제외한 컬럼에서 가능.

---

### A-3. `select_related`/`prefetch_related` 로 N+1 방지

```python
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ("id", "name", "shop", "category", "price", "stock", "is_public", "rating", "created_at")
    list_filter = ("is_public", "shop", "category", "created_at")
    search_fields = ("name", "shop__name", "category__name")
    ordering = ("-created_at",)
    autocomplete_fields = ("shop", "category")
    list_select_related = ("shop", "category")   # ★ FK를 JOIN
    # 역참조 프리페치는 changelist 캐시/집계에 사용할 때 지정 가능.
```

---

### A-4. 관리자 액션 (대량 업데이트/CSV 내보내기)

```python
# apps/shop/admin_actions.py
import csv
from django.http import HttpResponse
from django.db.models import F

def make_public(modeladmin, request, queryset):
    updated = queryset.update(is_public=True)
    modeladmin.message_user(request, f"{updated}개 상품 공개 처리")

def discount_10(modeladmin, request, queryset):
    # 원자적 업데이트 (F expression)
    updated = queryset.update(price=F("price") * 0.9)
    modeladmin.message_user(request, f"{updated}개 상품 10% 할인 반영")

def export_csv(modeladmin, request, queryset):
    resp = HttpResponse(content_type="text/csv")
    resp["Content-Disposition"] = 'attachment; filename="products.csv"'
    writer = csv.writer(resp)
    writer.writerow(["id", "name", "shop", "category", "price", "stock", "is_public", "rating"])
    for p in queryset.select_related("shop", "category"):
        writer.writerow([p.id, p.name, p.shop.name, p.category.name, p.price, p.stock, p.is_public, p.rating])
    return resp

make_public.short_description = "선택 상품 공개"
discount_10.short_description = "선택 상품 10% 할인"
export_csv.short_description = "선택 항목 CSV 다운로드"
```

```python
# apps/shop/admin.py (일부)
from .admin_actions import make_public, discount_10, export_csv

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    ...
    actions = [make_public, discount_10, export_csv]
```

> 액션 베스트 프랙티스  
> - **권한 검사**: `has_change_permission`/`has_delete_permission` 또는 `ModelAdmin.get_actions` 오버라이드.  
> - **선택 수 제한**: 매우 큰 쿼리셋이면 **비동기 작업 큐**(Celery)로 넘기기.  
> - 응답으로 파일 반환 가능(위 `export_csv` 처럼).

---

### A-5. `list_filter` 고급 — 커스텀 필터

```python
from django.contrib import admin
from django.utils.translation import gettext_lazy as _

class StockLevelFilter(admin.SimpleListFilter):
    title = _("재고 상태")
    parameter_name = "stock_level"

    def lookups(self, request, model_admin):
        return [("low", _("낮음(<=5)")), ("mid", _("중간(6~50)")), ("high", _("높음(>50)"))]

    def queryset(self, request, queryset):
        v = self.value()
        if v == "low":
            return queryset.filter(stock__lte=5)
        if v == "mid":
            return queryset.filter(stock__gt=5, stock__lte=50)
        if v == "high":
            return queryset.filter(stock__gt=50)
        return queryset

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    ...
    list_filter = (StockLevelFilter, "is_public", "created_at", "shop", "category")
```

---

### A-6. 필드 레이아웃 — `fieldsets`/`readonly_fields`/`formfield_overrides`

```python
from django.db import models
from django.forms import TextInput, NumberInput

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    fieldsets = (
        ("기본 정보", {"fields": ("shop", "category", "name", "is_public")}),
        ("가격/재고", {"fields": ("price", "stock", "rating")}),
        ("메타", {"fields": ("created_at",)}),
    )
    readonly_fields = ("created_at",)

    formfield_overrides = {
        models.CharField: {"widget": TextInput(attrs={"size": 60})},
        models.PositiveIntegerField: {"widget": NumberInput(attrs={"min": 0})},
    }
```

---

### A-7. 인라인(Inline) — 관련 객체를 한 화면에서 편집

```python
class ProductImageInline(admin.TabularInline):
    model = ProductImage
    fields = ("is_main", "order", "alt", "file", "preview")
    extra = 1
    readonly_fields = ("preview",)

    def preview(self, obj):
        if not obj.file:
            return "-"
        return format_html('<img src="{}" style="height:60px;">', obj.file.url)

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    inlines = [ProductImageInline]
```

> TabularInline vs StackedInline: **행 기반** vs **스택형**. 이미지/짧은 필드는 Tabular가 보기 좋음.

---

### A-8. `get_queryset`/`get_readonly_fields`/권한별 제어

```python
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    ...

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        if request.user.is_superuser:
            return qs.select_related("shop", "category")
        # 점주라면 자신의 Shop 상품만
        return qs.filter(shop__owner=request.user).select_related("shop", "category")

    def get_readonly_fields(self, request, obj=None):
        base = ["created_at"]
        if not request.user.is_superuser:
            base += ["shop", "category"]
        return base
```

---

### A-9. Admin 전용 뷰(객체 도구 버튼 + `get_urls`)

```python
# apps/shop/admin.py
from django.urls import path
from django.shortcuts import redirect
from django.contrib import messages

@admin.register(Shop)
class ShopAdmin(admin.ModelAdmin):
    change_form_template = "admin/shop/shop/change_form.html"  # 커스텀 템플릿 확장

    def get_urls(self):
        urls = super().get_urls()
        my = [
            path("<int:shop_id>/recalc/", self.admin_site.admin_view(self.recalculate_metrics), name="shop-recalc")
        ]
        return my + urls

    def recalculate_metrics(self, request, shop_id):
        # (예) 통계 재계산 비동기 트리거
        # tasks.recalc_shop.delay(shop_id)
        messages.success(request, "재계산을 요청했습니다.")
        return redirect("admin:shop_shop_change", shop_id)
```

```html
{# templates/admin/shop/shop/change_form.html #}
{% extends "admin/change_form.html" %}
{% block object-tools-items %}
  {{ block.super }}
  <li><a href="{% url 'admin:shop-recalc' original.id %}">통계 재계산</a></li>
{% endblock %}
```

---

### A-10. AdminSite 커스터마이징(브랜딩/권한)

```python
# apps/core/adminsite.py
from django.contrib.admin import AdminSite

class MyAdminSite(AdminSite):
    site_header = "내 서비스 관리자"
    site_title = "관리자"
    index_title = "대시보드"

admin_site = MyAdminSite(name="myadmin")
```

```python
# apps/shop/admin.py
from apps.core.adminsite import admin_site
from .models import Product
@admin_site.register(Product)
class ProductAdmin(admin.ModelAdmin):
    ...
```

```python
# config/urls.py
from django.urls import path
from apps.core.adminsite import admin_site
urlpatterns = [
    path("admin/", admin_site.urls),
]
```

> 대규모 멀티테넌트/파트너용 어드민을 **별도 AdminSite** 로 분리하면 권한/브랜딩/메뉴를 독립적으로 관리 가능.

---

### A-11. 임포트-익스포트 (django-import-export)

```bash
pip install django-import-export
```

```python
# apps/shop/admin.py
from import_export import resources, fields
from import_export.admin import ImportExportModelAdmin
from .models import Product

class ProductResource(resources.ModelResource):
    shop = fields.Field(attribute="shop", column_name="shop_id")
    category = fields.Field(attribute="category", column_name="category_id")

    class Meta:
        model = Product
        import_id_fields = ("id",)
        fields = ("id", "name", "shop", "category", "price", "stock", "is_public", "rating", "created_at")
        export_order = fields

@admin.register(Product)
class ProductAdmin(ImportExportModelAdmin):
    resource_class = ProductResource
    list_display = ("id", "name", "shop", "category", "price", "stock", "is_public")
    list_filter = ("is_public", "shop", "category")
    search_fields = ("name",)
```

> 실무 팁  
> - 대량 임포트는 **비동기** 권장(업로드 → Celery → 결과 리포트).  
> - **유효성 검사**/중복 정책(`import_id_fields`) 명확히.  
> - 권한/감사 로깅(누가 무엇을 임포트/익스포트) 확보.

---

## B. 커스텀 매니지먼트 커맨드 — 배치/유지보수 자동화

### B-1. 구조

```
apps/
  shop/
    management/
      __init__.py
      commands/
        __init__.py
        recalc_hot_products.py
```

```python
# apps/shop/management/commands/recalc_hot_products.py
from django.core.management.base import BaseCommand
from django.db.models import Sum, F
from apps.shop.models import Product

class Command(BaseCommand):
    help = "인기 상품 점수 재계산"

    def add_arguments(self, parser):
        parser.add_argument("--limit", type=int, default=1000, help="대상 상품 수 제한")
        parser.add_argument("--dry-run", action="store_true", help="DB 반영 없이 시뮬레이션")

    def handle(self, *args, **opts):
        limit = opts["limit"]
        dry = opts["dry_run"]
        qs = Product.objects.annotate(score=Sum(F("rating") * 100)).order_by("-score")[:limit]
        updated = 0
        for p in qs.iterator(chunk_size=100):
            # 예시: score 필드가 있다면 갱신하는 흐름
            # p.score = int(p.score or 0)
            if not dry:
                # p.save(update_fields=["score"])
                pass
            updated += 1
            if updated % 100 == 0:
                self.stdout.write(self.style.NOTICE(f"{updated} 처리..."))
        self.stdout.write(self.style.SUCCESS(f"완료: {updated}개"))
```

실행:
```bash
python manage.py recalc_hot_products --limit 500 --dry-run
```

> 포인트  
> - `iterator(chunk_size=...)` 로 메모리 사용을 억제.  
> - `--dry-run` 으로 안전한 시뮬레이션.  
> - 출력은 `self.stdout.write` + `self.style` 로 색상 구분.

---

### B-2. 트랜잭션/락/재시도

```python
# apps/orders/management/commands/fix_inconsistent_orders.py
from django.core.management.base import BaseCommand
from django.db import transaction, DatabaseError
from apps.orders.models import Order

class Command(BaseCommand):
    help = "결제/주문 정합성 복구"

    def handle(self, *args, **opts):
        try:
            with transaction.atomic():
                for o in Order.objects.select_for_update().filter(paid=True, total_amount=0):
                    # 계산 보정...
                    # o.total_amount = ...
                    # o.save(update_fields=["total_amount"])
                    pass
        except DatabaseError as e:
            self.stderr.write(self.style.ERROR(f"DB 오류: {e}"))
            raise SystemExit(1)
        self.stdout.write(self.style.SUCCESS("정합성 복구 완료"))
```

> - **비관 락**(`select_for_update`)로 중복 실행 경쟁 방지.  
> - 배치 성격에 따라 **advisory lock**(PostgreSQL) 도 고려.

---

### B-3. 외부 API/파일/대량 처리 — 체크포인트(아이들포인트)

```python
# apps/integration/management/commands/sync_vendor.py
from django.core.management.base import BaseCommand
from django.utils import timezone
from django.db import transaction
from apps.integration.models import SyncState
from apps.shop.models import Product
import requests

class Command(BaseCommand):
    help = "벤더 상품 동기화(체크포인트 재개)"

    def handle(self, *args, **opts):
        state, _ = SyncState.objects.get_or_create(name="vendor_product")
        page = state.page or 1
        while True:
            r = requests.get("https://api.vendor.com/products", params={"page": page, "size": 500}, timeout=20)
            data = r.json()
            items = data["items"]
            if not items: break
            with transaction.atomic():
                for it in items:
                    # upsert
                    Product.objects.update_or_create(
                        shop_id=it["shop_id"], name=it["name"],
                        defaults={"price": it["price"], "stock": it["stock"]}
                    )
                state.page = page + 1
                state.updated_at = timezone.now()
                state.save(update_fields=["page", "updated_at"])
            page += 1
        self.stdout.write(self.style.SUCCESS("동기화 완료"))
```

> 네트워크 오류로 중단돼도 **체크포인트** 를 통해 재실행 시 이어서 진행.

---

### B-4. Celery/크론 연동

- **Celery Beat** 로 주기 실행하거나,  
- Linux **crontab**/**systemd timer** 로 `python manage.py ...` 호출.

```bash
# crontab 예시
0 3 * * * /srv/app/venv/bin/python /srv/app/src/manage.py cleanup --days 30 >> /var/log/app/cron.log 2>&1
```

---

### B-5. 테스트에서 커맨드 호출

```python
from django.core.management import call_command

def test_command_smoke(db, capsys):
    call_command("recalc_hot_products", limit=1, dry_run=True)
    out = capsys.readouterr().out
    assert "완료" in out
```

---

## C. 시그널 — 도메인 이벤트, 사이드이펙트 캡슐화, 안티패턴 주의

### C-1. 기본 개념
- **시그널** 은 Django 내부/사용자 이벤트에 대한 **옵저버**.  
- 대표적 내장 시그널: `pre_save`, `post_save`, `post_delete`, `m2m_changed`, `request_finished`, `post_migrate` 등.

### C-2. 연결 위치 — `AppConfig.ready()` 에서 import

```python
# apps/shop/apps.py
from django.apps import AppConfig

class ShopConfig(AppConfig):
    name = "apps.shop"

    def ready(self):
        # 시그널 수신기 import (연결)
        from . import signals  # noqa
```

```python
# apps/shop/__init__.py
default_app_config = "apps.shop.apps.ShopConfig"  # Django<3.2 호환. (신규는 AppConfig 경로 INSTALLED_APPS에 직접)
```

---

### C-3. `post_save` — 썸네일 생성/검색 인덱스 업데이트

```python
# apps/shop/signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.db import transaction
from .models import Product, ProductImage

@receiver(post_save, sender=ProductImage, dispatch_uid="generate_thumb_once")
def generate_thumb_after_commit(sender, instance: ProductImage, created, **kwargs):
    if not created or not instance.file:
        return
    # 트랜잭션이 완전히 커밋된 후 실행 (파일 경로/DB 일관성 확보)
    transaction.on_commit(lambda: _enqueue_thumbnail_task(instance.id))

def _enqueue_thumbnail_task(image_id: int):
    # Celery에 태스크 enqueue (동기 처리 금지: 시그널에서 무거운 작업 X)
    # tasks.generate_thumb.delay(image_id)
    pass
```

> 핵심: **무거운 I/O 작업은 시그널 내부에서 직접 수행 금지**. `transaction.on_commit` + **백그라운드 큐** 로 위임.

---

### C-4. `m2m_changed` — 상품 ↔ 카테고리 태그 변경 시 캐시 무효화

```python
# 예: 만약 Product.tags = ManyToManyField(Tag) 라고 가정
from django.db.models.signals import m2m_changed
from django.core.cache import cache
from .models import Product

@receiver(m2m_changed, sender=Product.tags.through, dispatch_uid="invalidate_tag_cache")
def invalidate_product_tag_cache(sender, instance: Product, action, pk_set, **kwargs):
    if action in ("post_add", "post_remove", "post_clear"):
        cache.delete(f"product:{instance.pk}:tags")  # 키 버전 전략 권장
```

---

### C-5. `post_delete` — 파일 정리/외부 자원 정리

```python
@receiver(post_delete, sender=ProductImage, dispatch_uid="delete_file_when_image_deleted")
def delete_file(sender, instance: ProductImage, **kwargs):
    f = instance.file
    if f and f.storage.exists(f.name):
        try:
            f.storage.delete(f.name)
        except Exception:
            # 로깅만 (시그널은 사용자 응답 경로와 분리되어야 함)
            pass
```

---

### C-6. 도메인 이벤트(커스텀 시그널)로 사이드이펙트 분리

```python
# apps/domain/events.py
from django.dispatch import Signal
order_paid = Signal()     # providing_args deprecated (Django 4+), kwargs로 자유
```

```python
# 결제 확정 서비스 계층에서
from apps.domain.events import order_paid
def mark_order_paid(order):
    # ... 비즈니스 규칙 ...
    order.paid = True
    order.save(update_fields=["paid"])
    order_paid.send(sender=order.__class__, order=order)
```

```python
# 수신기: 메일 발송/포인트 적립 등 분리
from django.dispatch import receiver
from apps.domain.events import order_paid
from django.db import transaction

@receiver(order_paid, dispatch_uid="send_receipt_email")
def send_receipt_email(sender, order, **kwargs):
    transaction.on_commit(lambda: _enqueue_send_email(order.id))

@receiver(order_paid, dispatch_uid="grant_points")
def grant_points(sender, order, **kwargs):
    transaction.on_commit(lambda: _enqueue_grant_points(order.user_id, order.id))
```

> 장점  
> - **서비스 계층**은 **핵심 상태 변경**만 담당, 사이드이펙트는 **플러그형**으로 분리.  
> - 테스트에서 **시그널 수신기만 목킹/비활성화** 가능.

---

### C-7. 안티패턴 & 주의점

1) **무거운 작업을 시그널에서 직접 수행**  
   - 파일 변환/외부 API 호출/슬로우 쿼리 → **큐 위임**.  

2) **숨은 결합**  
   - 시그널에 로직이 흩어져 **읽기 어려운 제어 흐름**.  
   - **서비스 함수** → `order_paid.send(...)` 처럼 **명시적** 트리거를 사용하고, 시그널 목록 문서화.

3) **트랜잭션 타이밍 문제**  
   - `post_save` 직후 DB 상태가 커밋되기 전일 수 있음 → `transaction.on_commit` 사용.  

4) **중복 연결/메모리 누수**  
   - `AppConfig.ready()` 내 **한 번만** 연결, `dispatch_uid` 지정. 테스트에서 **import 순환/중복 연결** 주의.  

5) **예외 전파**  
   - 시그널 수신기에서 예외가 나면 호출 스택에 영향을 줄 수 있음 → **로깅 후 누락 허용** 또는 **명시 처리**.  

6) **테스트 느려짐**  
   - 테스트에서 수신기를 **임시 해제** 또는 **patch** 하여 속도 관리.

```python
# 테스트에서 시그널 임시 해제
from django.test import override_settings
from django.dispatch import Signal

def test_without_signal(mocker):
    from apps.domain.events import order_paid
    m = mocker.patch.object(order_paid, "send", return_value=None)
    # ... 테스트 ...
    m.assert_called_once()
```

또는 컨텍스트 매니저로 일시 해제:

```python
from contextlib import contextmanager
@contextmanager
def mute_signal(signal: Signal, receiver_fn):
    signal.disconnect(receiver_fn)
    try:
        yield
    finally:
        signal.connect(receiver_fn)
```

---

### C-8. 어드민 + 시그널 + 큐 연계 예: “가격 업데이트 → 알림 푸시”

1) 관리자가 Admin에서 여러 상품 선택 → 액션 `discount_10`  
2) 액션 내부에서 실제 저장(업데이트) 수행 → `post_save`/커스텀 이벤트 트리거  
3) 수신기가 `transaction.on_commit` 으로 Celery 태스크 enqueue → 사용자에게 WebSocket/이메일 알림

```python
# apps/shop/signals.py (요약)
from django.dispatch import Signal
products_discounted = Signal()

def emit_discount_event(qs):
    ids = list(qs.values_list("id", flat=True))
    products_discounted.send(sender=qs.model, ids=ids)

# admin 액션에서 update 후 emit_discount_event(queryset)
```

```python
# 수신기
from django.db import transaction
from django.dispatch import receiver
from .signals import products_discounted

@receiver(products_discounted, dispatch_uid="push_discount_notice")
def push_discount_notice(sender, ids, **kwargs):
    transaction.on_commit(lambda: _enqueue_push(ids))
```

---

## D. 운영 체크리스트 (요약)

**Django Admin**
- [ ] `list_display`/`list_filter`/`search_fields`/`date_hierarchy` 정립  
- [ ] `list_select_related`/`prefetch_related` 로 N+1 제거  
- [ ] 커스텀 액션(권한/비동기 고려), CSV/XLSX 익스포트  
- [ ] 인라인으로 관련 모델 한 화면 편집  
- [ ] AdminSite 분리(파트너/사내), 커스텀 뷰/버튼

**Management Commands**
- [ ] `iterator()`/청크 처리로 메모리 보호  
- [ ] `--dry-run`/로깅/종료 코드 관리  
- [ ] 트랜잭션/락/체크포인트/재시도(downstream)  
- [ ] 크론/Beat 스케줄링과 충돌 방지(동시 실행 제한)

**Signals**
- [ ] 서비스 계층에서 **명시적 이벤트** 트리거  
- [ ] 무거운 작업은 **on_commit + 큐**  
- [ ] `dispatch_uid`/중복 연결 방지  
- [ ] 예외 처리/로깅/테스트 전략 마련

---

## E. 추가 스니펫 모음

### E-1. Admin 불변 필드에 “복사 버튼” 추가(UX)

```python
from django.utils.safestring import mark_safe

class ShopAdmin(admin.ModelAdmin):
    readonly_fields = ("copy_domain",)

    def copy_domain(self, obj):
        if not obj.domain: return "-"
        return mark_safe(f'''
          <input type="text" value="{obj.domain}" id="copy-domain" readonly>
          <button type="button" onclick="navigator.clipboard.writeText('{obj.domain}')">복사</button>
        ''')
    copy_domain.short_description = "도메인 복사"
```

### E-2. Admin 필드 검증(폼 커스터마이즈)

```python
from django import forms

class ProductAdminForm(forms.ModelForm):
    class Meta:
        model = Product
        fields = "__all__"
    def clean(self):
        data = super().clean()
        if data.get("price", 0) < 0:
            self.add_error("price", "음수 금지")
        if data.get("is_public") and data.get("stock", 0) == 0:
            self.add_error("is_public", "재고 0이면 공개할 수 없습니다.")
        return data

class ProductAdmin(admin.ModelAdmin):
    form = ProductAdminForm
```

### E-3. 관리자에서 CSV 임포트(가벼운 버전)

```python
# apps/shop/admin_views.py
import csv, io
from django.contrib import admin, messages
from django.shortcuts import render, redirect
from django.urls import path
from .models import Product, Shop, Category

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    change_list_template = "admin/shop/product/change_list.html"

    def get_urls(self):
        return [path("import/", self.admin_site.admin_view(self.import_view), name="shop_product_import")] + super().get_urls()

    def import_view(self, request):
        if request.method == "POST" and request.FILES.get("file"):
            f = io.TextIOWrapper(request.FILES["file"].file, encoding="utf-8")
            r = csv.DictReader(f)
            created = 0
            for row in r:
                shop = Shop.objects.get(pk=row["shop_id"])
                cat = Category.objects.get(pk=row["category_id"])
                Product.objects.update_or_create(
                    shop=shop, name=row["name"],
                    defaults={"category": cat, "price": row["price"], "stock": row["stock"], "is_public": row["is_public"] == "1"},
                )
                created += 1
            messages.success(request, f"{created} 건 처리")
            return redirect("admin:shop_product_changelist")
        return render(request, "admin/shop/product/import.html")
```

```html
{# templates/admin/shop/product/change_list.html #}
{% extends "admin/change_list.html" %}
{% block object-tools-items %}
  {{ block.super }}
  <li><a href="{% url 'admin:shop_product_import' %}">CSV 임포트</a></li>
{% endblock %}
```

```html
{# templates/admin/shop/product/import.html #}
{% extends "admin/base_site.html" %}
{% block content %}
  <h1>CSV 임포트</h1>
  <form method="post" enctype="multipart/form-data">{% csrf_token %}
    <input type="file" name="file" accept=".csv">
    <button class="button">업로드</button>
  </form>
{% endblock %}
```

> 대량/복잡 임포트는 **import-export 라이브러리/비동기 처리** 사용을 권장.

---

## 마무리

- **Django Admin** 을 제대로 꾸미면 별도 백오피스 없이도 강력한 운영 도구를 만들 수 있습니다.  
  `list_*`/`actions`/`inlines`/`get_urls`/`AdminSite` 를 적절히 조합하여 **업무 흐름을 단축**하세요.  
- **커스텀 매니지먼트 커맨드** 로 배치/정합성/동기화를 **자동화** 하되, 트랜잭션/락/체크포인트로 **안전성**을 챙기세요.  
- **시그널** 은 **도메인 이벤트**를 선언적으로 드러내고, 사이드이펙트는 **on_commit + 큐** 로 분리하여 **성능/안정성/가시성**을 모두 확보하세요.
