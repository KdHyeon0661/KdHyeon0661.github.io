---
layout: post
title: C++ - 스마트 포인터 구현 (1)
date: 2024-09-23 19:20:23 +0900
category: Cpp
---
# C++ 스마트 포인터 구현 1/6 — `MyUniquePtr`(단독 소유) 설계와 구현

> 목표: 표준 `unique_ptr`의 핵심 동작(단독 소유·이동 전용·RAII·커스텀 deleter·배열 지원)을 **직접 구현**한다.
> 이 편에서는 **단일 객체** 버전과 **배열 특수화**를 모두 완성하고, 예외·불완전형(incomplete type)·컨테이너 호환성까지 점검한다.

---

## 0. 요구사항 정리

- **소유권**: 오직 하나의 포인터만 소유(복사 금지, 이동 허용)
- **RAII**: 스코프 종료 시 자동 해제
- **커스텀 deleter**: `delete` 대신 임의의 정리 함수를 주입 가능
- **배열 지원**: `T[]` 전용 특수화(해제는 `delete[]`)
- **관찰자/수정자**: `get`, `operator*`, `operator->`, `operator bool`, `release`, `reset`, `swap`
- **예외 안전성**: `reset` 교체 시 강한/기본 보장 고려
- **불완전형 안전성**: 클래스 외부 정의 소멸자 패턴(out-of-line dtor)

---

## 1. 최소 구현 스케치 (단일 객체)

```cpp
#include <utility>
#include <type_traits>

template <class T, class Deleter = std::default_delete<T>>
class MyUniquePtr {
public:
    using element_type = T;
    using deleter_type = Deleter;
    using pointer      = T*;

private:
    pointer  ptr_ = nullptr;
    Deleter  del_;

public:
    // 1) 생성자
    constexpr MyUniquePtr() noexcept = default;
    explicit MyUniquePtr(pointer p) noexcept : ptr_(p) {}
    MyUniquePtr(pointer p, const Deleter& d) noexcept : ptr_(p), del_(d) {}
    MyUniquePtr(pointer p, Deleter&& d) noexcept : ptr_(p), del_(std::move(d)) {}

    // 2) 복사 금지
    MyUniquePtr(const MyUniquePtr&) = delete;
    MyUniquePtr& operator=(const MyUniquePtr&) = delete;

    // 3) 이동 허용
    MyUniquePtr(MyUniquePtr&& other) noexcept
      : ptr_(other.release()), del_(std::forward<Deleter>(other.del_)) {}

    MyUniquePtr& operator=(MyUniquePtr&& other) noexcept {
        if (this != &other) {
            reset(other.release());
            del_ = std::forward<Deleter>(other.del_);
        }
        return *this;
    }

    // 4) 소멸자: out-of-line로 빼서 불완전형 허용
    ~MyUniquePtr();

    // 5) 관찰자
    pointer get() const noexcept { return ptr_; }
    deleter_type& get_deleter() noexcept { return del_; }
    const deleter_type& get_deleter() const noexcept { return del_; }
    explicit operator bool() const noexcept { return ptr_ != nullptr; }

    // 6) 연산자
    typename std::add_lvalue_reference<T>::type operator*() const { return *ptr_; }
    pointer operator->() const noexcept { return ptr_; }

    // 7) 수정자
    pointer release() noexcept {
        pointer tmp = ptr_;
        ptr_ = nullptr;
        return tmp;
    }

    void reset(pointer p = pointer()) noexcept {
        pointer old = ptr_;
        ptr_ = p;
        if (old) del_(old);
    }

    void swap(MyUniquePtr& other) noexcept {
        using std::swap;
        swap(ptr_, other.ptr_);
        swap(del_, other.del_);
    }
};

// 소멸자 외부 정의(불완전형 허용을 위해)
template <class T, class Deleter>
MyUniquePtr<T,Deleter>::~MyUniquePtr() {
    if (ptr_) del_(ptr_);
}

// 헬퍼 함수
template <class T, class... Args>
MyUniquePtr<T> my_make_unique(Args&&... args) {
    return MyUniquePtr<T>(new T(std::forward<Args>(args)...));
}
```

### 포인트
- **복사 금지/이동 허용**으로 *단독 소유* 강제
- **소멸자 out-of-line**: `~MyUniquePtr()`을 클래스 외부에 정의하면, 헤더에서 T가 *불완전형*이어도 선언 가능(정의는 cpp에서 T 완전형일 때).
- `reset`는 **old → delete → 새 포인터 장착** 순서로 *예외 없이* 기본 보장(새 포인터 할당 실패가 없다면 강한 보장 대응 가능).

---

## 2. 배열 특수화: `MyUniquePtr<T[]>`

```cpp
#include <cstddef> // size_t

template <class T, class Deleter>
class MyUniquePtr<T[], Deleter> {
public:
    using element_type = T;
    using deleter_type = Deleter;
    using pointer      = T*;

private:
    pointer  ptr_ = nullptr;
    Deleter  del_;

public:
    constexpr MyUniquePtr() noexcept = default;
    explicit MyUniquePtr(pointer p) noexcept : ptr_(p) {}
    MyUniquePtr(pointer p, const Deleter& d) noexcept : ptr_(p), del_(d) {}
    MyUniquePtr(pointer p, Deleter&& d) noexcept : ptr_(p), del_(std::move(d)) {}

    MyUniquePtr(const MyUniquePtr&) = delete;
    MyUniquePtr& operator=(const MyUniquePtr&) = delete;

    MyUniquePtr(MyUniquePtr&& other) noexcept
      : ptr_(other.release()), del_(std::forward<Deleter>(other.del_)) {}

    MyUniquePtr& operator=(MyUniquePtr&& other) noexcept {
        if (this != &other) {
            reset(other.release());
            del_ = std::forward<Deleter>(other.del_);
        }
        return *this;
    }

    ~MyUniquePtr(); // 외부 정의

    // 배열은 index 접근 제공
    T& operator[](std::size_t i) const { return ptr_[i]; }

    pointer get() const noexcept { return ptr_; }
    deleter_type& get_deleter() noexcept { return del_; }
    const deleter_type& get_deleter() const noexcept { return del_; }
    explicit operator bool() const noexcept { return ptr_ != nullptr; }

    pointer release() noexcept { pointer t = ptr_; ptr_ = nullptr; return t; }

    void reset(pointer p = pointer()) noexcept {
        pointer old = ptr_;
        ptr_ = p;
        if (old) del_(old); // 기본 deleter는 delete[] 호출하도록 구성
    }

    void swap(MyUniquePtr& other) noexcept {
        using std::swap;
        swap(ptr_, other.ptr_);
        swap(del_, other.del_);
    }
};

template <class T, class Deleter>
MyUniquePtr<T[],Deleter>::~MyUniquePtr() {
    if (ptr_) del_(ptr_);
}

// 배열용 make
template <class T>
MyUniquePtr<T[]> my_make_unique_array(std::size_t n) {
    return MyUniquePtr<T[]>(new T[n]());
}
```

> 배열 특수화에서는 **`operator[]` 제공**과 **해제 정책이 `delete[]`** 가 되어야 한다는 점이 핵심이다. 기본 deleter를 `std::default_delete<T[]>`로 두면 자동으로 `delete[]`가 호출된다.

---

## 3. 커스텀 Deleter 설계

`MyUniquePtr<T, Deleter>`는 두 번째 템플릿 인자로 **정리 정책**을 받는다.
- **함수 객체**(캡처 없음)나 **함수 포인터** 모두 가능
- 파일/소켓/핸들 같은 *C 리소스*도 안전하게 RAII화 가능

```cpp
#include <cstdio>

struct FClose {
    void operator()(FILE* f) const noexcept {
        if (f) std::fclose(f);
    }
};

int main() {
    MyUniquePtr<FILE, FClose> file(std::fopen("out.txt", "w"));
    if (file) {
        std::fputs("hello\n", file.get());
    } // 스코프 종료 → fclose
}
```

함수 포인터 버전:

```cpp
using FreeFn = void(*)(void*);
void my_free(void* p) { std::free(p); }

MyUniquePtr<void, FreeFn> buf(std::malloc(1024), &my_free);
```

---

## 4. 예외 안전성과 `reset`/`release`/`swap`

- **`release()`**: 소유권 포기 → 호출자가 반드시 *적절히 해제*해야 한다. 남발 금지!
- **`reset(p)`**: 기존 포인터를 안전하게 해제하고 새 포인터 소유.
  새 포인터 준비–검증 → `reset` 순서로 쓰면 **강한 보장**에 가깝게 운용 가능.
- **`swap`**: no-throw로 서로 포인터/deleter 맞교환. 컨테이너 재배치에도 유용.

실전 패턴(강한 보장):

```cpp
void replace_ptr(MyUniquePtr<int>& dst) {
    auto next = my_make_unique<int>(42); // 새 자원 준비(여기서 예외 나면 원본 유지)
    dst.swap(next);                       // commit: 강한 보장
} // 실패 시 dst 불변
```

---

## 5. 컨테이너·알고리즘 호환성

- `std::vector<MyUniquePtr<T>>`에 안전하게 담을 수 있다(이동만 필요).
- 정렬/재배치/리저브 과정에서 **핸들 이동**만 일어나므로 리소스 누수 없음.

```cpp
#include <vector>
#include <algorithm>

struct Spy { static int live; Spy(){++live;} ~Spy(){--live;} };
int Spy::live = 0;

int main() {
    std::vector<MyUniquePtr<Spy>> v;
    for (int i = 0; i < 10; ++i) v.push_back(my_make_unique<Spy>());
    std::sort(v.begin(), v.end(), [](auto& a, auto& b){ return a.get() < b.get(); });
    v.clear();
}
```

---

## 6. 불완전형(incomplete type) 대응

헤더에 `MyUniquePtr<Fwd>`를 선언하고 **소멸자를 외부 정의**하면, `Fwd`의 정의를 보지 못하는 번역 단위에서도 포인터 자체는 선언·이동할 수 있다(해제 시점까지 타입이 완전해지면 됨).

```cpp
// A.hpp
struct Impl; // 불완전형
class A {
    MyUniquePtr<Impl> p_; // 선언 가능
public:
    A();
    ~A();  // cpp에서 Impl 완전형일 때 소멸자 정의
};
```

---

## 7. 품질 강화: 비교/변환/어댑터(선택 구현)

- **`operator==/!=`**: `get()` 비교
- **포인터 변환 이동 생성자**(예: `Derived*` → `Base*`), SFINAE로 안전 제어
- **adopt tag**: *이미 할당된* 리소스를 “채택(adopt)”하는 팩토리

예시(간단 비교 연산자):

```cpp
template <class T, class D1, class U, class D2>
bool operator==(const MyUniquePtr<T,D1>& a, const MyUniquePtr<U,D2>& b) noexcept {
    return a.get() == b.get();
}
```

---

## 8. 종합 사용 예(단독 객체/배열/커스텀 deleter)

```cpp
#include <cassert>
#include <cstring>
#include <cstdio>

int main() {
    // 1) 단일 객체
    auto p = my_make_unique<int>(7);
    assert(*p == 7);
    p.reset(new int(9));
    assert(*p == 9);

    // 2) 배열
    auto arr = my_make_unique_array<int>(4);
    for (int i=0;i<4;++i) arr[i] = i*i;
    assert(arr[3] == 9);

    // 3) 파일 핸들
    struct FClose { void operator()(FILE* f) const noexcept { if (f) std::fclose(f); } };
    MyUniquePtr<FILE, FClose> file(std::fopen("log.txt","w"));
    if (file) std::fputs("line\n", file.get());

    // 4) release의 신중한 사용
    int* raw = p.release();         // 소유권 포기
    assert(!p);
    delete raw;                     // 반드시 직접 해제
}
```

---

## 9. 체크리스트 (Part 1 완료)

- [x] **복사 금지 / 이동 허용**으로 단독 소유 강제
- [x] **커스텀 deleter**로 C 리소스까지 RAII화
- [x] **배열 특수화**와 `delete[]` 보장
- [x] **불완전형** 대비: 소멸자 외부 정의
- [x] 컨테이너·알고리즘과 **이동 기반** 상호운용 확인
- [x] `release/reset/swap` 의미론 테스트
