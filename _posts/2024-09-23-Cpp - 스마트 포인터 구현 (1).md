---
layout: post
title: C++ - 스마트 포인터 구현 (1)
date: 2024-09-23 19:20:23 +0900
category: Cpp
---
# C++ unique_ptr 직접 구현하기: 단독 소유 스마트 포인터 설계와 구현

표준 `unique_ptr`의 핵심 동작을 직접 구현해보며 단독 소유 스마트 포인터의 원리를 깊이 이해해보겠습니다. 이번 구현에서는 단일 객체 버전과 배열 특수화를 모두 완성하고, 예외 안전성, 불완전형(incomplete type) 대응, 컨테이너 호환성까지 점검합니다.

## 핵심 설계 요구사항

`unique_ptr`의 본질은 **단독 소유권**에 있습니다. 하나의 객체를 오직 하나의 스마트 포인터만 소유할 수 있으며, 이를 통해 명확한 자원 수명 관리를 제공합니다. 주요 요구사항은 다음과 같습니다:

1. **복사 금지, 이동만 허용** - 단독 소유권 보장
2. **RAII 원칙** - 스코프 종료 시 자동 자원 해제
3. **커스텀 삭제자 지원** - `delete` 외 다양한 정리 방식 가능
4. **배열 지원** - `T[]` 형식에 대한 특수화
5. **불완전형 안전성** - 전방 선언된 타입과의 호환

## 단일 객체 버전 구현

기본적인 `MyUniquePtr`의 구현은 단독 소유권을 명확히 표현합니다:

```cpp
template <class T, class Deleter = std::default_delete<T>>
class MyUniquePtr {
private:
    T* ptr_ = nullptr;
    Deleter del_;
    
public:
    // 이동 생성자: 소유권 이전
    MyUniquePtr(MyUniquePtr&& other) noexcept
        : ptr_(other.release()), del_(std::forward<Deleter>(other.del_)) {}
    
    // 이동 대입 연산자
    MyUniquePtr& operator=(MyUniquePtr&& other) noexcept {
        if (this != &other) {
            reset(other.release());
            del_ = std::forward<Deleter>(other.del_);
        }
        return *this;
    }
    
    // 복사 금지 (단독 소유권의 핵심)
    MyUniquePtr(const MyUniquePtr&) = delete;
    MyUniquePtr& operator=(const MyUniquePtr&) = delete;
    
    // 주요 인터페이스
    T* get() const noexcept { return ptr_; }
    T& operator*() const { return *ptr_; }
    T* operator->() const noexcept { return ptr_; }
    
    // 소유권 포기
    T* release() noexcept {
        T* tmp = ptr_;
        ptr_ = nullptr;
        return tmp;
    }
    
    // 자원 교체
    void reset(T* p = nullptr) noexcept {
        T* old = ptr_;
        ptr_ = p;
        if (old) del_(old);
    }
};
```

구현에서 특히 중요한 점은 **소멸자를 클래스 외부에 정의**하는 것입니다:

```cpp
// 소멸자 외부 정의 - 불완전형 지원을 위해
template <class T, class Deleter>
MyUniquePtr<T,Deleter>::~MyUniquePtr() {
    if (ptr_) del_(ptr_);
}
```

이 방식은 헤더 파일에서 타입 `T`가 불완전한 상태(전방 선언만 된 상태)에서도 `MyUniquePtr`을 사용할 수 있게 합니다. 실제 삭제는 `T`가 완전히 정의된 번역 단위에서 발생합니다.

## 배열 특수화 구현

배열 관리를 위한 `MyUniquePtr<T[]>` 특수화는 일반 버전과 몇 가지 중요한 차이가 있습니다:

```cpp
template <class T, class Deleter>
class MyUniquePtr<T[], Deleter> {
    // ... 일반 버전과 유사한 구현 ...
    
public:
    // 배열 인덱스 접근 연산자
    T& operator[](std::size_t i) const { return ptr_[i]; }
    
    // 배열용 삭제 (delete[] 사용)
    void reset(T* p = nullptr) noexcept {
        T* old = ptr_;
        ptr_ = p;
        if (old) del_(old); // 기본적으로 delete[] 호출
    }
};
```

배열 특수화의 핵심은 `operator[]` 제공과 올바른 `delete[]` 호출 보장입니다. 기본 삭제자를 `std::default_delete<T[]>`로 설정하면 자동으로 `delete[]`가 사용됩니다.

## 커스텀 삭제자 활용

`MyUniquePtr`의 강력한 기능 중 하나는 다양한 자원 타입을 일관된 방식으로 관리할 수 있게 해주는 커스텀 삭제자 지원입니다:

```cpp
// 파일 핸들 관리
struct FClose {
    void operator()(FILE* f) const noexcept {
        if (f) std::fclose(f);
    }
};

MyUniquePtr<FILE, FClose> file(std::fopen("out.txt", "w"));
// 파일은 스코프 종료 시 자동으로 닫힘

// malloc/free 기반 메모리 관리
void my_free(void* p) { std::free(p); }
MyUniquePtr<void, decltype(&my_free)> buf(std::malloc(1024), &my_free);
```

이를 통해 C 스타일 리소스(파일, 소켓, 메모리 등)도 RAII 패턴으로 안전하게 관리할 수 있습니다.

## 예외 안전성과 실전 패턴

`reset()` 메서드는 예외 안전성을 고려하여 설계되었습니다:

```cpp
void replace_ptr(MyUniquePtr<int>& dst) {
    auto next = my_make_unique<int>(42);  // 1. 새 자원 준비 (예외 발생 가능)
    dst.swap(next);                        // 2. 안전한 교체 (noexcept)
    // 예외 발생 시 원본 dst는 그대로 유지
}
```

이 패턴은 **강한 예외 안전성 보장**을 제공합니다: 작업이 완전히 성공하거나, 실패 시 원상태를 유지합니다.

## 컨테이너와의 호환성

`MyUniquePtr`은 표준 컨테이너와 잘 호환됩니다:

```cpp
std::vector<MyUniquePtr<Resource>> resources;
resources.push_back(my_make_unique<Resource>());
resources.emplace_back(new Resource());

// 정렬, 재배치 등 이동 연산만 사용
std::sort(resources.begin(), resources.end(), 
    [](auto& a, auto& b){ return a.get() < b.get(); });
```

컨테이너 내에서 이동만 발생하므로 자원 누수 없이 안전하게 관리됩니다.

## 불완전형과의 협업

PImpl(포인터 to Implementation) 패턴 등에서 자주 마주치는 불완전형 상황도 잘 처리합니다:

```cpp
// 헤더 파일
struct Impl;  // 전방 선언만
class Widget {
    MyUniquePtr<Impl> pImpl;  // OK: 소멸자가 외부에 정의됨
public:
    Widget();
    ~Widget();  // 구현 파일에서 정의
};

// 구현 파일
#include "widget_impl.h"  // Impl의 완전한 정의
Widget::~Widget() = default;  // 여기서 MyUniquePtr<Impl> 소멸자 호출
```

## 결론

`MyUniquePtr` 구현을 통해 단독 소유권 스마트 포인터의 핵심 원리를 이해할 수 있습니다. 복사 금지와 이동 의미론을 통한 명확한 소유권 표현, RAII를 통한 자동 자원 관리, 커스텀 삭제자를 통한 다양한 리소스 지원, 그리고 불완전형과의 안전한 협업 등은 현대 C++ 자원 관리의 기본 패턴을 보여줍니다.

이 구현은 단순히 `unique_ptr`의 동작을 모방하는 것을 넘어, C++의 이동 의미론, 템플릿, 예외 안전성, RAII 등 핵심 개념들을 종합적으로 적용하는 실천적인 예제입니다. 실제 프로젝트에서 자원 수명을 관리할 때 이러한 원리들이 어떻게 적용되는지 직접 경험해볼 수 있는 좋은 기회가 될 것입니다.