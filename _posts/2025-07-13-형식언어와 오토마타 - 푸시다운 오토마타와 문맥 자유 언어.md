---
layout: post
title: 형식언어와 오토마타 - 푸시다운 오토마타와 문맥 자유 언어
date: 2025-07-13 22:20:23 +0900
category: 형식언어와 오토마타
---
# 푸시다운 오토마타(PDA)와 문맥 자유 언어(CFL)

## 표기와 약속

- 입력 알파벳: $$\Sigma$$, 스택 알파벳: $$\Gamma$$
- 비터미널 집합: $$V$$, 시작기호: $$S$$
- 공집합/빈문자열: $$\emptyset, \varepsilon$$
- ε-전이는 **입력을 소비하지 않는 전이**로 표기

---

## 개요: CFG와 PDA의 동치성

**정리 (표준 동치성).**
- (1) **CFG → PDA**: 임의의 CFG $$G$$에 대해, $$L(G)$$를 인식하는 PDA $$M$$을 구성할 수 있다.
- (2) **PDA → CFG**: 임의의 PDA $$M$$에 대해, $$L(M)$$을 생성하는 CFG $$G$$를 구성할 수 있다.

따라서 표현력 측면에서 **CFG와 PDA는 동등**하다(= 정확히 CFL을 기술).

---

## 푸시다운 오토마타(PDA)의 형식적 정의

PDA는 다음의 7튜플로 정의한다.
$$
M = (Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)
$$

- $$Q$$: 유한 상태 집합
- $$\Sigma$$: 입력 알파벳
- $$\Gamma$$: 스택 알파벳
- $$\delta : Q \times (\Sigma \cup \{\varepsilon\}) \times \Gamma \to \mathcal{P}(Q \times \Gamma^*)$$
  현재 상태, (입력/ε), 스택상단을 보고 **다음 상태**와 **대체 스택 문자열**(pop 후 push할 시퀀스)의 **집합**을 반환
- $$q_0 \in Q$$: 시작 상태
- $$Z_0 \in \Gamma$$: 초기 스택 기호(바닥표식)
- $$F \subseteq Q$$: 최종(수용) 상태 집합

### 수용 방식

- **최종 상태 수용**: 입력을 모두 소비하고 $$F$$에 속한 상태에 도달하면 수용.
- **빈 스택 수용**: 입력을 모두 소비하고 스택이 비면(또는 바닥표식만 남으면) 수용.

> 두 수용 방식은 **동치**(서로 변환 가능).

---

## CFG → PDA (Top-Down 시뮬레이션)

문맥 자유 문법 $$G=(V,\Sigma,R,S)$$가 있을 때, 이를 인식하는 **빈 스택 수용 PDA**를 다음처럼 구성한다(표준 구성).

- 상태 집합 $$Q = \{q\}$$ (단일 상태로 충분)
- 입력 알파벳 $$\Sigma$$ (동일)
- 스택 알파벳 $$\Gamma = V \cup \Sigma$$
- 시작 상태 $$q_0=q$$
- 시작 스택 기호 $$Z_0 = S$$
- 수용 방식: **빈 스택 수용**

전이 정의:
1. **생성 규칙 전개**: $$A \to \alpha \in R$$이면
   $$
   \delta(q,\varepsilon,A) \ni (q,\alpha)
   $$
   (스택 top의 비터미널 $$A$$를 pop하고 우변 $$\alpha$$를 역순 없이 “왼→오”로 push)
2. **터미널 매칭**: 입력 $$a$$를 읽어야 하고 스택 top도 $$a$$라면
   $$
   \delta(q, a, a) \ni (q, \varepsilon)
   $$

> 아이디어: 스택에는 “앞으로 유도해야 할 심볼열”을 올려두고, 비터미널이면 **규칙으로 전개**, 터미널이면 **입력과 매칭** 후 pop.

### 예시 A: \( L = \{a^n b^n \mid n\ge 0\} \)

CFG:
```
S → a S b | ε
```
PDA 전이(핵심):
- ε, S ⟶ a S b  (스택에 `b`, `S`, `a`를 이 순서로 push)
- a, a ⟶ ε  (터미널 매칭)
- b, b ⟶ ε
- ε, S ⟶ ε   (S → ε)

이 PDA는 정확히 \(a^n b^n\)을 인식한다.

### 예시 B: 균형 괄호

CFG:
```
S → S S | ( S ) | ε
```
CNF로 바꾼 뒤(또는 직접) 동일한 방식으로 PDA를 얻을 수 있다(‘(’ push, ‘)’ pop 직관).

---

## PDA → CFG (상태-스택 구간의 문법화)

PDA $$M=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$$가 주어졌을 때, $$L(M)$$을 생성하는 CFG를 만든다. 표준 구성은 아래 변수(비터미널)를 쓴다.

- **비터미널**: $$[pXq]$$ 의 의미
  “상태 $$p$$에서 스택 top이 $$X$$인 상황을 **정상적으로 소거**하고 상태 $$q$$로 갈 수 있게 하는 모든 문자열”을 생성

- **시작 기호**: $$S' = [q_0 Z_0 q_f]$$ (어떤 $$q_f\in F$$를 잡거나, 여러 수용 상태에 대해 합을 둬도 됨)

- **생성 규칙**: PDA 전이를 문법적으로 풀어쓴다. 핵심 꼴:
  - 만약 $$\delta(p,a,X)\ni (r,\gamma)$$라 하자.
    - \(\gamma=\varepsilon\)이면: **단순 pop**
      $$[pXq] \to a \quad \text{(단, $r=q$)}$$
    - \(\gamma=Y_1 Y_2 \cdots Y_k\)이면: **여러 기호 push**
      “$$X$$를 $$Y_1\cdots Y_k$$로 바꾸고 각각을 ‘정상 소거’하는 경로를 모두 이어 붙인다”는 의미로
      $$[pXq] \to a \; [rY_1 t_1]\; [t_1 Y_2 t_2]\; \cdots\; [t_{k-1} Y_k q]$$
      (모든 중간 상태 \(t_i\in Q\)에 대해 규칙을 둔다: 비결정성 포착)

> 이 구성은 직관적으로 “스택 변형을 문법의 유도 사슬로 펼친 것”.

### 예시: \( a^n b^n \)용 간단 PDA → CFG (스케치)

- PDA 핵심 전이:
  - push-영역: ‘a’를 읽을 때마다 ‘A’ push
  - pop-영역: ‘b’를 읽을 때마다 ‘A’ pop
  - 전환은 ε-전이로 가정
- 변수 \( [p A q] \) 의미와 위 규칙들을 통해 결국 \(S' \Rightarrow a^n b^n\) 형태만 생성함을 보일 수 있다.

---

## 수용 방식의 동치 (최종상태 ↔ 빈 스택)

**정리.** 최종상태 수용 PDA와 빈 스택 수용 PDA는 **표현력이 같다**.
- 빈 스택 → 최종상태: “스택이 바닥만 남음”을 인지하는 ε-전이를 붙여 전용 수용상태로 이동
- 최종상태 → 빈 스택: 수용상태에서 스택을 차례로 비우는 ε-사다리를 붙여 빈 스택으로 종결

---

## 결정적 PDA(DPDA)와 DCFL

- **DPDA**: 한 구성(상태/입력/스택top)에 대해 **최대 1개 전이**만 허용(ε-전이와 실제입력 전이의 충돌 금지 등).
- **DCFL**: DPDA가 인식 가능한 CFL의 부분집합.
  - DCFL은 **보완(여집합)**에 폐포(정규와의 교집합도), 하지만 **합/교집합**에는 일반적으로 폐포가 아님.
- **NPDA(일반 PDA)**는 **전체 CFL**을 인식.

> 예: \( \{w w^R \mid w\in\{a,b\}^*\} \)는 CFL이지만 일반적으로 **DPDA로는 인식 불가**(중앙 경계의 결정성 어려움).

---

## 구현: 교육용 NPDA 시뮬레이터 (Python)

- ε-전이 지원
- **최종상태 수용**/**빈 스택 수용** 모두 지원
- BFS로 구성(ε-loop 방지용 방문 집합/스택 캡 적용)

```python
# -*- coding: utf-8 -*-

from collections import defaultdict, deque
from typing import Dict, Tuple, List, Set, Optional

EPS = None  # ε을 None으로 표현

TransitionKey = Tuple[str, Optional[str], str]    # (state, symbol or None, stack_top)
TransitionVal = List[Tuple[str, List[str]]]       # [(next_state, push_seq), ...]

class NPDA:
    def __init__(self,
                 states: Set[str],
                 input_alpha: Set[str],
                 stack_alpha: Set[str],
                 start_state: str,
                 start_stack: str,
                 finals: Set[str],
                 accept_by: str = "final"):  # "final" or "empty"
        self.Q = set(states)
        self.Sigma = set(input_alpha)
        self.Gamma = set(stack_alpha)
        self.q0 = start_state
        self.Z0 = start_stack
        self.F = set(finals)
        assert accept_by in ("final", "empty")
        self.accept_by = accept_by
        self.delta: Dict[TransitionKey, TransitionVal] = defaultdict(list)

    def add(self, q: str, a: Optional[str], X: str, p: str, gamma_push: List[str]):
        # pop X, then push gamma_push (rightmost is top)
        assert q in self.Q and p in self.Q
        assert (a in self.Sigma) or (a is None)
        assert X in self.Gamma
        for s in gamma_push:
            assert s in self.Gamma
        self.delta[(q, a, X)].append((p, gamma_push))

    def _next_configs(self, q: str, i: int, stack: List[str], w: str) -> List[Tuple[str,int,List[str]]]:
        res = []
        if not stack:
            return res
        X = stack[-1]

        # consume input
        if i < len(w):
            a = w[i]
            for (p, push_seq) in self.delta.get((q, a, X), []):
                new_stack = stack[:-1] + push_seq
                res.append((p, i+1, new_stack))

        # epsilon transitions
        for (p, push_seq) in self.delta.get((q, EPS, X), []):
            new_stack = stack[:-1] + push_seq
            res.append((p, i, new_stack))
        return res

    def accepts(self, w: str, max_steps: int = 200000) -> bool:
        start = (self.q0, 0, [self.Z0])
        Q = deque([start])
        visited: Set[Tuple[str,int,Tuple[str,...]]] = set()
        K = 32  # cap for stack for visited-key

        def cap_stack(stk: List[str]) -> Tuple[str,...]:
            return tuple(stk[-K:])

        visited.add((start[0], start[1], cap_stack(start[2])))
        steps = 0

        while Q:
            q, i, stack = Q.popleft()
            steps += 1
            if steps > max_steps:
                return False

            end = (i == len(w))
            if self.accept_by == "final":
                if end and q in self.F:
                    return True
            else:  # empty
                if end and len(stack) == 1 and stack[-1] == self.Z0:
                    return True

            for cfg in self._next_configs(q, i, stack, w):
                t = (cfg[0], cfg[1], cap_stack(cfg[2]))
                if t not in visited:
                    visited.add(t)
                    Q.append(cfg)
        return False
```

### (A) \( L = \{a^n b^n\} \) NPDA (최종상태 수용)

```python
def make_anbn_npda_final() -> NPDA:
    states = {"qpush", "qpop", "qf"}
    Sigma  = {"a", "b"}
    Gamma  = {"A", "Z0"}
    M = NPDA(states, Sigma, Gamma, "qpush", "Z0", {"qf"}, accept_by="final")

    # push a's
    M.add("qpush", "a", "Z0", "qpush", ["A", "Z0"])
    M.add("qpush", "a", "A",  "qpush", ["A", "A"])

    # switch to pop-mode
    M.add("qpush", EPS, "Z0", "qpop", ["Z0"])
    M.add("qpush", "b", "A",  "qpop", [])  # first b

    # pop b's
    M.add("qpop", "b", "A", "qpop", [])

    # accept: end + Z0 only
    M.add("qpop", EPS, "Z0", "qf", ["Z0"])
    return M

if __name__ == "__main__":
    M = make_anbn_npda_final()
    for s in ["", "ab", "aabb", "aaabbb", "aab", "abb", "aaabbbb"]:
        print(s, "=>", M.accepts(s))
```

### (B) \( \{ww^R\} \) (짝수 길이 팰린드롬) NPDA

```python
def make_even_pal_npda() -> NPDA:
    states = {"qpush", "qpop", "qf"}
    Sigma  = {"a", "b"}
    Gamma  = {"a", "b", "Z0"}
    M = NPDA(states, Sigma, Gamma, "qpush", "Z0", {"qf"}, accept_by="final")

    # push-phase
    for top in ["Z0", "a", "b"]:
        M.add("qpush", "a", top, "qpush", ["a", top])
        M.add("qpush", "b", top, "qpush", ["b", top])

    # ε: switch to pop-phase
    for top in ["Z0", "a", "b"]:
        M.add("qpush", EPS, top, "qpop", [top])

    # pop-phase: must match
    M.add("qpop", "a", "a", "qpop", [])
    M.add("qpop", "b", "b", "qpop", [])

    # accept
    M.add("qpop", EPS, "Z0", "qf", ["Z0"])
    return M

if __name__ == "__main__":
    M = make_even_pal_npda()
    for s in ["", "aa", "abba", "abab", "aba", "aabb", "baab"]:
        print(s, "=>", M.accepts(s))
```

> 홀수 길이 팰린드롬 \( \{ w x w^R \} \)은 push→pop 전환 시 **중앙문자 1개를 소비**하는 ε-전이 변형을 추가하면 된다.

---

## 자동 변환 스케치: CFG → NPDA(Top-Down)

간단한 Python 헬퍼로 **CFG를 받아 Top-Down NPDA**를 만들 수 있다(교육용).

```python
from typing import Dict, List, Set, Tuple

def cfg_to_npda_topdown(V: Set[str], Sigma: Set[str],
                        R: Dict[str, List[List[str]]],  # A -> list of RHS (each RHS is list of symbols)
                        S: str) -> NPDA:
    # PDA with one state 'q', stack alphabet V ∪ Sigma, Z0=S
    states = {"q"}
    Gamma  = set(V) | set(Sigma)
    M = NPDA(states, Sigma, Gamma, "q", S, set(), accept_by="empty")

    # 1) A -> α rules: ε, A ⟶ α
    for A, rhss in R.items():
        for rhs in rhss:
            # push rhs onto stack (pop A first)
            M.add("q", EPS, A, "q", list(rhs[::-1])[::-1])  # we keep order as-is

    # 2) terminal match: a,a ⟶ ε
    for a in Sigma:
        M.add("q", a, a, "q", [])

    return M

# Example usage:
# Grammar: S -> a S b | ε  over Sigma={a,b}

V = {"S"}
Sigma = {"a","b"}
R = {"S": [["a","S","b"], []]}  # [] stands for ε
S0 = "S"
M = cfg_to_npda_topdown(V, Sigma, R, S0)

for s in ["", "ab", "aabb", "aaabbb", "aab", "abb"]:
    print(s, "=>", M.accepts(s))
```

> 주의: 실제 제품 수준 구현에선 ε-폐쇄, CNF/GNF 변환, 좌재귀 제거, FIRST/FOLLOW 등 파싱 이론과 결합해 **결정적 파서(DPDA 기반)**로 구현한다(LL/LR).

---

## CFL의 성질(요약)

- **폐포성**: CFL은 합집합, 연결, Kleene*에 대해 폐포.
  정규언어와의 교집합에도 폐포.
  하지만 **교집합/보완** 전체에 대해선 **폐포 아님**.
- **결정 문제**: 멤버십(소속성) 결정은 다항시간(예: **CYK**: $$O(n^3 |P|)$$).
  공허성/유한성/동치성 등은 제약별로 난이도 상이.
- **비-CFL 예**: \( \{a^n b^n c^n\} \) (펌핑/오그던 보조정리로 증명).

---

## 구성 예제 더 보기

### 산술식(+,*,괄호) 부분 문법

(우선순위: `*` > `+`, 좌결합)

```
E → E + T | T
T → T * F | F
F → ( E ) | id
```

- 위 문법은 **모호함**(같은 입력에 여러 파스 트리 가능).
  보통 비모호 문법(또는 Precedence/Associativity 규칙)으로 바꾸거나, 파서에서 우선순위를 부여한다.
- CFG→PDA(Top-Down) 자체는 가능하지만, 실무에서는 **LL/LR 파서**(사실상 **DPDA**)를 자동 생성하는 도구(ANTLR, bison 등)를 활용.

### 균형 괄호의 DPDA

- ‘(’ 읽으면 push, ‘)’ 읽으면 pop, 끝났을 때 바닥만 남으면 수용
- 결정적이므로 **DPDA**로 가능(DCFL의 대표).

---

## 자주 겪는 실수/주의점

1. **ε-전이와 입력전이 충돌**(DPDA에서 특히 금지)
2. CFG → PDA 시 **스택에 우변을 push할 때 순서** 혼동
   - 전개 후 입력 매칭이 왼→오 방향으로 진행되도록 push 순서를 맞춰야 함
3. PDA → CFG 구성에서 **중간상태 변수** 누락
   - \([pXq]\) 사이에 들어가는 모든 중간 상태 \(t\)에 대해 규칙을 포괄적으로 둬야 함
4. **비-CFL**을 PDA로 설계하려다 실패
   - \(a^n b^n c^n\) 등은 애초에 **PDA(=CFL)**로 표현 불가

---

## 정리

- **CFG ↔ PDA**: 완전한 **언어적 동치** (둘 다 CFL을 정확히 기술)
- **Top-Down PDA 구성**: “규칙 전개(ε) + 터미널 매칭”으로 간단히 구현 가능
- **PDA → CFG**: 상태/스택 조작을 비터미널 \([pXq]\)로 문법화
- **실무**: LL/LR 파서(=결정적 파서, DPDA의 구현)로 안정적 구문 분석
- **코드**: 교육용 NPDA 시뮬레이터로 예제 언어( \(a^n b^n\), \(ww^R\) ) 검증 가능

---

## 체크리스트 (학습/시험 대비)

- [ ] PDA 7튜플 정의를 정확히 쓸 수 있는가?
- [ ] 최종상태 수용 ↔ 빈 스택 수용의 변환 원리를 설명할 수 있는가?
- [ ] CFG → PDA 표준구성과 예제를 손으로 전개할 수 있는가?
- [ ] PDA → CFG에서 \([pXq]\) 변수와 생성 규칙을 구성할 수 있는가?
- [ ] DCFL과 DPDA의 제약/폐포성 차이를 설명할 수 있는가?
- [ ] \(a^n b^n c^n\)이 비-CFL인 이유(보조정리 이름 수준) 설명 가능한가?

---

### 부록: 수식 요약

- PDA 전이:
  $$
  \delta : Q \times (\Sigma \cup \{\varepsilon\}) \times \Gamma \to \mathcal{P}(Q \times \Gamma^*)
  $$
- CFG → PDA (핵심 전이):
  $$
  A\to \alpha \;\Rightarrow\; \delta(q,\varepsilon,A)\ni(q,\alpha),\quad
  \delta(q,a,a)\ni(q,\varepsilon)
  $$
- PDA → CFG (핵심 변수):
  $$
  [pXq] \text{ : “}p\text{에서 }X\text{를 정상 소거하여 }q\text{에 도달”}
  $$
