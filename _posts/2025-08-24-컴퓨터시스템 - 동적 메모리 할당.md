---
layout: post
title: 컴퓨터시스템 - 동적 메모리 할당
date: 2025-08-24 17:20:23 +0900
category: 컴퓨터시스템
---
# 동적 메모리 할당(Dynamic Memory Allocation) — 원리, 설계, 구현, 디버깅

> **핵심 질문**  
> - `malloc/free/realloc/calloc`은 내부에서 무엇을 하는가?  
> - 힙(Heap)은 어떤 자료구조로 관리되는가?  
> - **단편화**를 줄이고 **성능**을 높이는 설계는?  
> - 올바른 사용법과 디버깅/검증 방법은?

---

## 1) 사용자 관점 API 요약

### 표준 함수
```c
void* malloc(size_t n);         // n바이트 요청 (초기화 없음)
void  free(void* p);            // p 해제 (NULL은 무시)
void* calloc(size_t k, size_t n);// k*n바이트 할당 + 0으로 초기화(오버플로 체크 필요)
void* realloc(void* p, size_t n);// 크기 변경(확장/축소/이동)
```

### 정렬(align) 관련
```c
int   posix_memalign(void** p, size_t align, size_t n); // align은 2의 거듭제곱, 최소 sizeof(void*)
void* aligned_alloc(size_t align, size_t n);            // C11. n은 align의 배수
```

- `malloc(0)`의 결과는 구현 의존(보통 `NULL` 또는 고유 포인터).  
- **정렬 보장**: C 표준은 적어도 `alignof(max_align_t)`를 보장(보통 16바이트 이상 on x86-64).  
- **참고**: 반환 포인터 **직전에는 힙 메타데이터**(헤더 등)가 있음. 사용자 코드는 절대 접근 금지.

---

## 2) 목표와 제약: “Utilization vs Throughput”

- **메모리 효율(활용도)**:  
  \[
  \text{Peak Utilization} = \frac{\max_t \text{(살아있는 페이로드 합)}}{\max_t \text{(힙 크기)}}
  \]
- **처리량**: 초당 할당/해제 연산 수.
- 보통 **두 목표가 상충**: 탐색/정렬/통합(coalesce)을 많이 하면 효율은↑ 하지만 속도는↓.  
- 좋은 할당기는 **작업 부하**(패턴)에 맞춰 타협점을 잡는다.

---

## 3) 힙의 구조와 블록 형식

### 3.1 블록 레이아웃(대표적 관례)
```
[ Header | Payload ... | Padding | (Footer?) ]
```
- **Header**: (size | alloc-bit | 기타 플래그)  
- **Footer**: (선택) 보통 **자유 블록**에만 두어 경계 태그(boundary tag)로 상하 이웃 검사.
- **Payload**: 사용자에게 반환되는 공간.
- **Padding**: 정렬 보장(예: 8B/16B 정렬).  
- **최소 블록 크기**: 헤더 + (자유 블록이면) 푸터 + free list 포인터 2개(명시적 리스트) 등을 담을 수 있어야 함.

### 3.2 정렬(Alignment)
- 모든 반환 포인터는 **정렬 경계**에 놓여야 한다(예: 16B).  
- 헤더·푸터는 정렬을 깨지 않도록 크기/배치 설계.

---

## 4) 자유 블록 관리(Free List 조직)

### 4.1 암시적 목록(Implicit Free List)
- 모든 블록을 앞에서부터 훑으며(헤더의 alloc-bit) 빈 블록 탐색.  
- **장점**: 구현 단순. **단점**: 검색 비용↑(O(n)).

### 4.2 명시적 자유 목록(Explicit Free List)
- **자유 블록만** 이중 연결 리스트로 관리(블록 페이로드에 `prev/next` 포인터 저장).
- **장점**: 검색 비용↓. **단점**: 포인터 오버헤드/메모리 오염에 취약.

### 4.3 분리 적합 리스트(Segregated Free Lists)
- 크기 클래스별로 **여러 개의 bin** 유지(예: 16, 32, 64, 128, …).  
- **장점**: 거의 O(1)에 근접한 배치, 단편화↓.  
- **정책**: 작은 bin은 LIFO로 빠르게 재사용, 큰 bin은 최적 탐색(best/first fit 혼합).

---

## 5) 배치(Placement) 정책

- **First fit**: 첫 맞춤. 빠르지만 단편화 위험.  
- **Next fit**: 마지막 탐색 위치 기억 후 거기서 계속.  
- **Best fit**: 가장 근접한 크기 선택. 외부 단편화↓, 탐색 비용↑.  
- **Segregated fit**: 크기 bin에서 **first-fit** 또는 **best-fit** 혼합.

> **Split(쪼개기)**: 큰 자유 블록에 할당 시, **필요량만큼 나누고 잉여를 다시 free**.  
> 너무 작은 조각이 생기면 **split 금지 임계값**(min block size) 적용.

---

## 6) 통합(Coalescing)과 경계 태그

- **즉시 통합(immediate)**: `free` 호출 때 상·하 이웃이 자유면 즉시 병합.  
- **지연 통합(deferred)**: 나중에 배경 작업(또는 할당 실패 시) 수행.  
- **경계 태그(boundary tag)**: 자유 블록의 **헤더/푸터**에 크기/할당 비트를 기록 → **뒤에서 앞으로**도 이웃 상태 판별 가능.

**즉시 통합 함수 예시**
```c
// 가정: 헤더/푸터에 size|alloc 비트가 있고, 자유 블록은 footer를 가짐.
static void* coalesce(void* bp) {
    size_t prev_alloc = GET_ALLOC(FOOTER(PREV_BLK(bp)));
    size_t next_alloc = GET_ALLOC(HEADER(NEXT_BLK(bp)));
    size_t size = GET_SIZE(HEADER(bp));

    if (prev_alloc && next_alloc) {             // case 1: no merge
        return bp;
    } else if (prev_alloc && !next_alloc) {     // case 2: merge with next
        size += GET_SIZE(HEADER(NEXT_BLK(bp)));
        SET_HEADER(bp, PACK(size, 0));
        SET_FOOTER(bp, PACK(size, 0));
    } else if (!prev_alloc && next_alloc) {     // case 3: merge with prev
        size += GET_SIZE(HEADER(PREV_BLK(bp)));
        bp = PREV_BLK(bp);
        SET_HEADER(bp, PACK(size, 0));
        SET_FOOTER(bp, PACK(size, 0));
    } else {                                    // case 4: merge both
        size += GET_SIZE(HEADER(PREV_BLK(bp))) + GET_SIZE(HEADER(NEXT_BLK(bp)));
        bp = PREV_BLK(bp);
        SET_HEADER(bp, PACK(size, 0));
        SET_FOOTER(bp, PACK(size, 0));
    }
    return bp;
}
```

---

## 7) 운영체제와의 인터페이스: `sbrk` vs `mmap`

- **`sbrk/brk`**: 힙 “상한”을 늘려 **연속 가상 주소**를 확보(전통).  
- **`mmap`**: 익명 매핑으로 **임의 위치**에 페이지 확보(대형 블록/반환 시 이점).  
- 실제 배포 구현은 **작은/중간 할당은 힙(sbrk)**, **큰 할당은 mmap**으로 나누기도 한다(큰 블록은 바로 반환해 가상주소를 회수하기 쉬움).

---

## 8) `realloc`의 동작 전략

1. **축소**: 같은 자리에서 크기만 줄이고, 남는 부분을 자유 블록으로 split.  
2. **확장(인접 우측이 자유)**: 인플레이스 확장 후 필요 시 split.  
3. **이동**: 새 블록 할당 → 구 데이터 `memcpy` → 기존 블록 free.

> **최적화 팁**: 자주 커졌다 작아지는 버퍼는 **재할당 정책**(exponential growth)으로 재복사 횟수↓.

---

## 9) 스레드와 동시성

- **단일 전역 락**은 간단하지만 contention↑.  
- 실무 할당기는 흔히 **여러 arena**(스레드별/CPU별) + **per-thread cache (tcache, magazine)** 로 경합↓.  
- **false sharing** 방지: 서로 다른 스레드의 블록이 **같은 캐시 라인**에 얹히지 않도록 패딩/정렬.

---

## 10) 보안·무결성(요지)

- **더블 프리**, **use-after-free**, **오버플로/언더플로** 방지 필수.  
- 현대 할당기는 **무결성 검증**(프리 리스트 링크 검사), **안전한 unlink**, **치환 난수(canary)/검사 비트** 등 방어 추가.  
- JIT/실행 메모리는 **W^X**(동시에 Write와 Execute 금지) 정책 준수.

---

## 11) 흔한 버그 & 탐지 도구

| 유형 | 설명 | 탐지/완화 |
|---|---|---|
| 메모리 누수 | free 누락 | Valgrind(Memcheck), LeakSanitizer |
| 더블 프리 | 같은 포인터 두 번 free | ASan, 런타임 가드 |
| 해제 후 사용(UAF) | free된 메모리 사용 | AddressSanitizer(ASan) |
| 경계 초과 | 버퍼 범위 밖 접근 | ASan, FORTIFY_SOURCE, canary |
| 잘못된 크기 | `realloc` 계산 오버플로 | 정수 오버플로 체크 |
| 정렬 위반 | SSE/AVX/원자적 연산 실패 | `posix_memalign/aligned_alloc` |

테스트 예:
```bash
# 주소/경계 오류 빠르게 찾기(Clang/GCC)
CFLAGS="-fsanitize=address,undefined -fno-omit-frame-pointer -g"
```

---

## 12) 미니멀 명시적-리스트 할당기 스켈레톤

> 교육용 골격(에러 체크/경계 생략). **실전 투입 금지**.  
> 개념: 헤더/푸터, 이중 연결 자유 리스트, first-fit + 즉시 통합.

```c
// mm.c (스케치)
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

#define WSIZE      8                 // 헤더/푸터 단위(8B)
#define DSIZE      16
#define CHUNKSIZE  (1<<12)           // 초기 확장 크기
#define ALIGNMENT  16

#define MAX(x,y) ((x)>(y)?(x):(y))
#define ALIGN(sz) (((sz)+(ALIGNMENT-1)) & ~(ALIGNMENT-1))
#define PACK(sz, alloc) ((sz) | (alloc))

typedef uint64_t word_t;

static char* heap_listp;             // 프롤로그 뒤 첫 블록
static char* free_list_head;         // 자유 리스트 헤드

// 헤더/푸터 접근
static inline size_t GET(void* p){ return *(word_t*)(p); }
static inline void   PUT(void* p, size_t v){ *(word_t*)(p) = v; }
static inline size_t GET_SIZE(void* p){ return GET(p) & ~0xF; }
static inline int    GET_ALLOC(void* p){ return GET(p) & 0x1; }

static inline void* HDRP(void* bp){ return (char*)bp - WSIZE; }
static inline void* FTRP(void* bp){ return (char*)bp + GET_SIZE(HDRP(bp)) - DSIZE; }
static inline void* NEXT_BLK(void* bp){ return (char*)bp + GET_SIZE((char*)bp - WSIZE); }
static inline void* PREV_BLK(void* bp){ return (char*)bp - GET_SIZE((char*)bp - DSIZE); }

// 자유 리스트 링크(페이로드 공간 사용)
static inline void** PREV_PTR(void* bp){ return (void**)(bp); }
static inline void** NEXT_PTR(void* bp){ return (void**)((char*)bp + sizeof(void*)); }

static void insert_free(void* bp){
    *PREV_PTR(bp) = NULL;
    *NEXT_PTR(bp) = free_list_head;
    if (free_list_head) *PREV_PTR(free_list_head) = bp;
    free_list_head = bp;
}
static void remove_free(void* bp){
    void* prev = *PREV_PTR(bp);
    void* next = *NEXT_PTR(bp);
    if (prev) *NEXT_PTR(prev) = next; else free_list_head = next;
    if (next) *PREV_PTR(next) = prev;
}

static void* coalesce(void* bp){
    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLK(bp)));
    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLK(bp)));
    size_t size = GET_SIZE(HDRP(bp));

    if (!prev_alloc){ remove_free(PREV_BLK(bp)); size += GET_SIZE(HDRP(PREV_BLK(bp))); bp = PREV_BLK(bp); }
    if (!next_alloc){ remove_free(NEXT_BLK(bp)); size += GET_SIZE(HDRP(NEXT_BLK(bp))); }
    PUT(HDRP(bp), PACK(size, 0));
    PUT(FTRP(bp), PACK(size, 0));
    insert_free(bp);
    return bp;
}

static void* extend_heap(size_t words){
    size_t size = ALIGN(words * WSIZE);
    char* bp = sbrk(size);
    if ((long)bp == -1) return NULL;
    PUT(HDRP(bp), PACK(size, 0));
    PUT(FTRP(bp), PACK(size, 0));
    // 에필로그 헤더 갱신
    PUT(HDRP(NEXT_BLK(bp)), PACK(0,1));
    return coalesce(bp);
}

static void place(void* bp, size_t asize){
    size_t csize = GET_SIZE(HDRP(bp));
    remove_free(bp);
    if (csize - asize >= 2*DSIZE){ // split
        PUT(HDRP(bp), PACK(asize,1));
        PUT(FTRP(bp), PACK(asize,1));
        void* nbp = (char*)bp + asize;
        PUT(HDRP(nbp), PACK(csize-asize,0));
        PUT(FTRP(nbp), PACK(csize-asize,0));
        insert_free(nbp);
    } else {
        PUT(HDRP(bp), PACK(csize,1));
        PUT(FTRP(bp), PACK(csize,1));
    }
}

int mm_init(void){
    // 프롤로그/에필로그 생성
    char* heap = sbrk(4*WSIZE);
    if ((long)heap == -1) return -1;
    PUT(heap, 0);                          // 패딩
    PUT(heap+WSIZE, PACK(DSIZE,1));        // 프롤로그 헤더
    PUT(heap+2*WSIZE, PACK(DSIZE,1));      // 프롤로그 푸터
    PUT(heap+3*WSIZE, PACK(0,1));          // 에필로그
    heap_listp = heap + 2*WSIZE;
    free_list_head = NULL;
    if (extend_heap(CHUNKSIZE/WSIZE) == NULL) return -1;
    return 0;
}

void* mm_malloc(size_t n){
    if (n == 0) return NULL;
    size_t asize = ALIGN(n + 2*WSIZE); // 헤더/푸터 포함
    // first-fit in free list
    for (void* bp = free_list_head; bp; bp = *NEXT_PTR(bp)){
        if (GET_SIZE(HDRP(bp)) >= asize){ place(bp, asize); return bp; }
    }
    // 확장
    void* bp = extend_heap(MAX(asize, CHUNKSIZE)/WSIZE);
    if (!bp) return NULL;
    place(bp, asize);
    return bp;
}

void mm_free(void* p){
    if (!p) return;
    size_t size = GET_SIZE(HDRP(p));
    PUT(HDRP(p), PACK(size,0));
    PUT(FTRP(p), PACK(size,0));
    insert_free(p);
    coalesce(p);
}

void* mm_realloc(void* p, size_t n){
    if (!p) return mm_malloc(n);
    if (n == 0){ mm_free(p); return NULL; }
    size_t asize = ALIGN(n + 2*WSIZE);
    size_t csize = GET_SIZE(HDRP(p));
    if (asize <= csize) return p;
    // 간단: 새로 할당 후 복사
    void* np = mm_malloc(n);
    if (!np) return NULL;
    memcpy(np, p, csize - 2*WSIZE);
    mm_free(p);
    return np;
}
```

> 이 스켈레톤에서 **이중 연결 자유 리스트/즉시 통합/first-fit/split**의 핵심을 볼 수 있다.  
> 실제 제품 수준 구현은 **여러 bin**, **mmap 경로**, **thread cache**, **무결성 검사**, **페이지 단위 정책** 등을 추가한다.

---

## 13) 단편화 이해와 완화

- **외부 단편화**: 충분한 총량이 있어도 “연속” 큰 블록이 없음 → **coalesce/segregation/large-bin**으로 완화.  
- **내부 단편화**: 요청보다 큰 블록 반환(헤더/정렬/분리 오버헤드) → **정렬 최소화, min block size 조정**.

**패턴 기반 튜닝**
- 많고 작은 요청 ⇒ **소형 bin 세분화** + LIFO 재사용  
- 드물지만 큰 요청 ⇒ **mmap로 직접 할당**, 반환 시 즉시 unmap  
- 치환 빈발 ⇒ **realloc-friendly**(인접 확장 적극 시도)

---

## 14) 실전 팁(사용자 코드 관점)

- `calloc`은 **곱셈 오버플로**를 체크하라:
```c
size_t bytes;
if (__builtin_mul_overflow(k, n, &bytes)) { /* 오류 처리 */ }
void* p = calloc(k, n);
```
- `realloc(p, new)` 실패 시 **원본 p는 유효 상태**. 먼저 새 포인터에 받기:
```c
void* q = realloc(p, new);
if (!q) { /* 실패 처리, p 사용 가능 */ } else p = q;
```
- `free(NULL)`은 **무시**되므로 조건문 불필요.
- **해제 후 포인터를 NULL로**: double-free/UAF 예방.
- **경계 접근 금지**: 할당 크기보다 1바이트라도 쓰면 안 됨(헤더/다음 블록 파손).

---

## 15) 성능 계측과 문제 추적

- **페이지 폴트/캐시/DTLB**: `perf stat -e page-faults,cache-misses,dTLB-load-misses …`  
- **힙 상태**: `/proc/<pid>/smaps`, `pmap`, 전용 힙 디버거(allocator 옵션).  
- **누수 점검**: Valgrind, LeakSanitizer.  
- **경계·UAF**: AddressSanitizer.  
- **워크로드 리플레이**: 샘플링/로그로 할당 트레이스 수집 후 합성 벤치.

---

## 16) 마무리 요약

- 동적 메모리 할당은 **블록 관리(헤더/푸터/리스트)**, **배치/통합 정책**, **OS 인터페이스**의 종합 설계 문제다.  
- 목표는 **높은 활용도**와 **높은 처리량**의 균형.  
- 실무에서는 **segregated lists + 즉시/지연 통합 + mmap 경로 + 스레드 캐시**가 보편적 해법.  
- 사용자 코드는 **정렬/오버플로/수명/동시성**을 주의하고, **툴로 지속 검증**하라.

필요하시면 위 스켈레톤에 **분리 적합(binning) + tcache 스타일의 per-thread fast path**를 덧붙여 완성형 예제를 만들어 드릴게요.