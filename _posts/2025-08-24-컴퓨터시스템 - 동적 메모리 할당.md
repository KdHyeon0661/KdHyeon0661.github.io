---
layout: post
title: 컴퓨터시스템 - 동적 메모리 할당
date: 2025-08-24 17:20:23 +0900
category: 컴퓨터시스템
---
# 동적 메모리 할당(Dynamic Memory Allocation)

> **핵심 질문**
> - `malloc/free/realloc/calloc`은 내부에서 무엇을 하는가?
> - 힙(Heap)은 어떤 자료구조로 관리되는가?
> - **단편화**를 줄이고 **성능**을 높이는 설계는?
> - 올바른 사용법과 디버깅/검증 방법은?

---

## 큰 지도(One-Page Map)

주제 | 핵심 아이디어 | 장단점 | 어디서 쓰나
---|---|---|---
블록 형식 | 헤더(크기/플래그) + 페이로드 + (푸터) | 경계 태그로 통합 쉬움 / 오버헤드 | 거의 모든 일반 할당기
자유 블록 조직 | 암시적·명시적·분리적합·비트맵·버디 | 탐색 비용↔공간 효율 트레이드오프 | 일반/RT/임베디드
배치 정책 | first/next/best/segregated-fit | 단편화↔속도 | 워크로드별 튜닝
통합(coalesce) | 즉시/지연, 경계 태그, prev_alloc 비트 | 단편화↓ / 비용↑ | free-heavy 워크로드
OS 인터페이스 | `sbrk`(연속 힙), `mmap`(페이지 단위) | 작은/큰 블록 분기 | glibc/musl/jemalloc 등
동시성 | arena + tcache, central freelist | 경합↓ / 메모리↑ | 다코어 서버
보안 | 안전 unlink, canary, quarantine | 오버헤드 | 공개 배포용
디버깅 | ASan/UBSan/LSan, Valgrind, heap-prof | 재현·관찰 필수 | CI/운영

---

## 사용자 관점 API — 정확한 시맨틱

```c
void* malloc(size_t n);          // n바이트 요청(초기화 없음), 최소 정렬: alignof(max_align_t)
void  free(void* p);             // p==NULL이면 no-op
void* calloc(size_t k, size_t n);// 총 k*n바이트, 0으로 채움(곱셈 오버플로 점검 필요)
void* realloc(void* p, size_t n);// 크기 변경: in-place 확장/축소/이동 복사
int   posix_memalign(void** p, size_t align, size_t n); // 2의 거듭제곱, align>=sizeof(void*)
void* aligned_alloc(size_t align, size_t n); // C11: n은 align의 배수여야 함
```

- **정렬 보장**: 보통 x86-64에서 16B 이상. SIMD/원자적 연산 등으로 더 큰 정렬이 필요하면 `posix_memalign`/`aligned_alloc`.
- `malloc(0)`: 구현 의존. **널 체크 대신 크기 체크**를 선호(아래 “안전 패턴” 참고).
- **반환 포인터 직전**에는 내부 **헤더**가 있다. 사용자 코드에서 **절대 접근 금지**.

---

## 목표와 제약 — Utilization vs Throughput

- **활용도(메모리 효율)**
  $$\text{Peak Utilization}=\frac{\max_t \text{(라이브 페이로드 총합)}}{\max_t \text{(힙 크기)}}$$
- **처리량**: 초당 `malloc/free` 과업 처리.
- **지연**: 개별 호출의 평균/상위 분위수(latency).

> 일반적으로 **효율↑**를 위해 정교한 탐색·통합을 하면 **속도↓**.
> 실전은 **워크로드 분포(사이즈·수명·동시성)**에 맞춘 타협이다.

---

## 블록 레이아웃과 플래그

### 전형적 블록

```
[ Header | Payload ... | (Padding) | (Footer*) ]
```
- **Header**: `size | alloc_bit | prev_alloc_bit | flags...`
- **Footer**: 자유 블록에만 둘 수 있음(경계 태그).
- **prev_alloc 비트**: 바로 앞 블록의 할당 여부를 담아 **푸터 없이** 통합 가능(푸터 오버헤드 절감).
- **최소 블록 크기**: 헤더 + (자유면) 링크 포인터 2개 + 정렬 여유.

### 정렬

- 내부적으로 **정렬단위(예: 16B)** 로 크기를 반올림(내부 단편화 증가 vs 정렬 위반 예방).

---

## 자유 블록 조직(Free Structure)

### 암시적 리스트(Implicit)

- 모든 블록을 **앞에서부터** 확인(헤더의 alloc 비트).
- **장점**: 단순. **단점**: O(n) 탐색, 큰 힙에서 느림.

### 명시적 리스트(Explicit)

- **자유 블록만** 이중연결리스트로 관리(페이로드에 `prev/next` 저장).
- 탐색 O(#free). 분할·통합 시 링크 조작 필요.

### 분리 적합(Segregated Free Lists)

- **크기 클래스별 bin** 다수(예: 16, 32, 48, 64 … or 2^k).
- 작은 bin은 LIFO 재사용(캐시 친화), 큰 bin은 best/first 조합.
- **현대 할당기의 사실상 표준**(jemalloc/tcmalloc 계열 철학).

### 비트맵/버디/슬랩(요약)

- **버디**: 2^k 블록 분할/병합. 매우 빠른 통합, 내부 단편화↑ 가능, RT/커널 친화.
- **슬랩/캐시**: 타입 단일 객체 풀. 오브젝트 생성·파괴가 빠름, 내부 단편화↓.

---

## 정책

정책 | 설명 | 특성
---|---|---
First Fit | 첫 맞춤 | 빠름, 외부 단편화↑
Next Fit | 마지막 포인터부터 | 지역성↑, 편향 가능
Best Fit | 가장 근접 | 외부 단편화↓, 탐색↑
Segregated Fit | bin에서 first/best 혼합 | 전체적으로 **가장 실전적**

> **Split**: 큰 자유 블록을 나눠 사용. **잔여 조각이 최소 블록보다 작으면 split 금지**.

---

## — 경계 태그/prev_alloc

- **즉시 통합**: `free` 때 상·하 이웃이 자유면 즉시 병합 → 단편화↓, `free` 비용↑.
- **지연 통합**: 배경/압박·탐색 실패 시 수행 → 평균 속도↑, 단편화↑ 가능.
- **푸터 없는 설계**: `prev_alloc` 비트로 뒤에서 앞으로도 판단 가능(푸터 오버헤드 제거).

**즉시 통합 스케치**
```c
static void* coalesce(void* bp){
    size_t prev_alloc = GET_PREV_ALLOC(HDRP(bp));
    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLK(bp)));
    size_t size = GET_SIZE(HDRP(bp));

    if(!prev_alloc){ remove_free(PREV_BLK(bp)); size += GET_SIZE(HDRP(PREV_BLK(bp))); bp = PREV_BLK(bp); }
    if(!next_alloc){ remove_free(NEXT_BLK(bp)); size += GET_SIZE(HDRP(NEXT_BLK(bp))); }
    PUT_HDR(bp, PACK(size, 0, /*prev_alloc*/ get_prev_of(bp)));
    PUT_FTR_IF_NEEDED(bp, size);
    insert_free(bp);
    return bp;
}
```

---

## OS 인터페이스 — `sbrk` vs `mmap`

- **`sbrk/brk`**: 프로세스 힙을 **위로 확장**(연속 VA).
- **`mmap(MAP_ANONYMOUS)`**: 임의 VA에 페이지 단위 확보, **큰 블록**/반환(언맵) 용이.
- 보편적 전략: **작고 잦은 요청은 힙(sbrk)**, **큰 요청은 mmap**(예: 임계값 수십 KB~수백 KB).

> **Lazy commit**: 페이지는 실제 접근 시 물리 메모리 할당. 큰 덩어리 `memset(0)`은 page-fault 폭탄 가능 → `MADV_DONTNEED`/`madvise`/`MAP_POPULATE` 등 고려.

---

## `realloc` 전략

상황 | 동작
---|---
축소 | 제자리(shrink-in-place). 잉여는 split→free
확장 가능 | 우측 이웃이 자유면 병합→in-place 확장
확장 불가 | 새 블록 할당→`memcpy`→기존 free

**성능 팁**: 버퍼 성장은 **지수(예: ×1.5~2)** 로 하여 `realloc` 복사 횟수↓.

---

## 동시성 설계 — Arena + Tcache

- **Arena(중앙 힙 단위 다수)**: 스레드/CPU에 배정. 서로 다른 arena끼리 경합 없음.
- **Tcache(Per-thread cache)**: 소형 size class별 **소량의 LIFO 리스트**.
  - 빠른 경로: tcache hit → O(1).
  - miss: arena의 bin에서 refill.
  - overflow: tcache 일부를 arena로 flush.

> **False sharing**: 서로 다른 스레드 블록이 같은 cache line에 얹히지 않게 padding/정렬.

---

## 보안·무결성

- **안전 unlink**(더블 프리/임의 쓰기 방지), **링크 검증**, **카나리(cookies)**, **랜덤화**.
- **Quarantine**: free된 블록을 즉시 재사용하지 않고 잠시 격리 → UAF 탐지력↑.
- **W^X**: 실행 코드 메모리와 쓰기 메모리는 분리.

---

## 흔한 버그 & 진단 도구

유형 | 증상 | 탐지
---|---|---
경계 초과(OOB) | 무작위 크래시 | **ASan**, FORTIFY, UBSan
UAF/더블 프리 | 간헐적 크래시 | **ASan**, **LSan**
누수 | RSS 증가 | **Valgrind**, LSan
정렬 위반 | SIGBUS/연산 실패 | 정렬 지원 API, UBSan
정수 오버플로 | 작은 할당·OOB | UBSan, 수작업 체크

빌드 예:
```bash
CFLAGS="-O1 -g -fno-omit-frame-pointer -fsanitize=address,undefined"
LDFLAGS="-fsanitize=address,undefined"
```

---

## 교육용 할당기(분리 적합 + tcache, prev_alloc 기반)

> **주의**: 학습용 스케치. 에러처리·경계·보안 최소화. 운영 투입 금지.
> 아이디어:
> - 헤더 8B: `size(하위 4비트는 플래그)` (LSB: alloc, 2nd: prev_alloc)
> - **푸터는 자유 블록에만**(옵션), 실습에서는 생략해 prev_alloc만 사용.
> - **분리 적합**: 32개 정도의 size class(bin).
> - **tcache**: 스레드 로컬로 소형 몇 개 저장.

```c
// mini_alloc.c — gcc -pthread -D_GNU_SOURCE -O2 -c mini_alloc.c
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

// ====== 기본 상수/매크로 ======
#define ALIGNMENT   16UL
#define WSIZE       8UL
#define MIN_BLK     32UL
#define NBINS       32
#define TCACHE_MAX  8        // 클래스당 tcache 최대
#define MMAP_CUTOFF (256UL * 1024UL) // 큰 요청은 mmap로 (실습: 생략)

#define ALIGN(x) (((x)+(ALIGNMENT-1)) & ~(ALIGNMENT-1))
#define PACK(size, alloc, prev) ((size) | ((alloc)&1UL) | (((prev)&1UL)<<1))
#define GET(p)        (*(uint64_t*)(p))
#define PUT(p, val)   (*(uint64_t*)(p) = (uint64_t)(val))
#define GET_SIZE(h)   (GET(h) & ~0xFUL)
#define GET_ALLOC(h)  (GET(h) & 0x1UL)
#define GET_PALLOC(h) ((GET(h) >> 1) & 0x1UL)

#define HDRP(bp)      ((uint8_t*)(bp) - WSIZE)
#define NEXT_BLK(bp)  ((uint8_t*)(bp) + GET_SIZE(HDRP(bp)))
#define PREV_BLK(bp)  ((uint8_t*)(bp) - (*(uint64_t*)((uint8_t*)(bp)-WSIZE) & ~0xFUL)) // prev size stored at prev header size field assumption

// ====== 자유 리스트 노드(명시적 리스트: 페이로드 앞 16B에 prev/next) ======
typedef struct free_node {
    struct free_node* prev;
    struct free_node* next;
} free_node;

// ====== 전역(아레나 1개) + 각 bin 헤드 ======
static pthread_mutex_t g_lock = PTHREAD_MUTEX_INITIALIZER;
static free_node* bins[NBINS];

// ====== tcache: 스레드 로컬 ======
typedef struct { void* head[NBINS][TCACHE_MAX]; uint8_t cnt[NBINS]; } tcache_t;
static __thread tcache_t tcache;

// ====== 도우미 ======
static inline size_t req2asize(size_t n){
    size_t need = ALIGN(n + WSIZE); // 헤더 포함
    if (need < MIN_BLK) need = MIN_BLK;
    return need;
}

static inline int size2bin(size_t sz){
    // 단순 로그 근사: 16B부터 시작
    int i = 0; sz >>= 4;
    while (sz > 1 && i < NBINS-1) { sz >>= 1; i++; }
    return i;
}

static void bin_insert(int i, void* bp){
    free_node* nd = (free_node*)bp;
    nd->prev = NULL;
    nd->next = bins[i];
    if (bins[i]) bins[i]->prev = nd;
    bins[i] = nd;
}

static void bin_remove(int i, void* bp){
    free_node* nd = (free_node*)bp;
    if (nd->prev) nd->prev->next = nd->next; else bins[i] = nd->next;
    if (nd->next) nd->next->prev = nd->prev;
}

static void* extend_heap(size_t asize){
    size_t chunk = ((asize < (1<<12)) ? (1<<12) : asize);
    uint8_t* p = sbrk(chunk);
    if (p == (void*)-1) return NULL;
    // 새 블록 헤더
    PUT(p, PACK(chunk, 0, /*prev_alloc=*/1)); // 새 영역의 prev_alloc는 보수적으로 1
    void* bp = p + WSIZE;
    // 에필로그 헤더
    PUT(p + chunk, PACK(0, 1, 0));
    return bp;
}

static void set_header(void* bp, size_t size, int alloc, int prev_alloc){
    PUT(HDRP(bp), PACK(size, alloc, prev_alloc));
    // 다음 블록의 prev_alloc 갱신
    void* nb = NEXT_BLK(bp);
    uint64_t nh = GET(HDRP(nb));
    PUT(HDRP(nb), (nh & ~0x2UL) | ((alloc & 1UL) << 1));
}

static void* coalesce(void* bp){
    size_t size = GET_SIZE(HDRP(bp));
    int prev_alloc = GET_PALLOC(HDRP(bp));
    int next_alloc = GET_ALLOC(HDRP(NEXT_BLK(bp)));

    if (!prev_alloc){
        void* pb = PREV_BLK(bp);
        int bi = size2bin(GET_SIZE(HDRP(pb)));
        bin_remove(bi, pb);
        size += GET_SIZE(HDRP(pb));
        bp = pb;
    }
    if (!next_alloc){
        void* nb = NEXT_BLK(bp);
        int bi = size2bin(GET_SIZE(HDRP(nb)));
        bin_remove(bi, nb);
        size += GET_SIZE(HDRP(nb));
    }
    set_header(bp, size, 0, GET_PALLOC(HDRP(bp)));
    return bp;
}

static void split_place(void* bp, size_t asize){
    size_t csize = GET_SIZE(HDRP(bp));
    int prev_alloc = GET_PALLOC(HDRP(bp));
    if (csize - asize >= MIN_BLK){
        set_header(bp, asize, 1, prev_alloc);
        void* nb = (uint8_t*)bp + asize;
        set_header(nb, csize - asize, 0, /*prev_alloc=*/1);
        int bi = size2bin(GET_SIZE(HDRP(nb)));
        bin_insert(bi, nb);
    } else {
        set_header(bp, csize, 1, prev_alloc);
    }
}

static void* find_fit(size_t asize){
    int i = size2bin(asize);
    for (; i < NBINS; ++i){
        for (free_node* nd = bins[i]; nd; nd = nd->next){
            if (GET_SIZE(HDRP(nd)) >= asize){
                bin_remove(i, nd);
                return (void*)nd;
            }
        }
    }
    return NULL;
}

// ====== tcache fast path ======
static inline void* tcache_pop(int i){
    uint8_t c = tcache.cnt[i];
    if (c == 0) return NULL;
    void* bp = tcache.head[i][--c];
    tcache.cnt[i] = c;
    return bp;
}
static inline int tcache_push(int i, void* bp){
    uint8_t c = tcache.cnt[i];
    if (c == TCACHE_MAX) return 0;
    tcache.head[i][c++] = bp;
    tcache.cnt[i] = c;
    return 1;
}

// ====== 공개 함수 ======
void* mm_malloc(size_t n){
    if (n == 0) return NULL;
    size_t asize = req2asize(n);
    int bi = size2bin(asize);

    // 1) tcache
    if (asize <= (1UL<<(bi+4))){
        void* bp = tcache_pop(bi);
        if (bp){ split_place(bp, asize); return bp; }
    }

    pthread_mutex_lock(&g_lock);
    // 2) bin → split
    void* bp = find_fit(asize);
    if (!bp){
        bp = extend_heap(asize);
        if (!bp){ pthread_mutex_unlock(&g_lock); return NULL; }
        bp = coalesce(bp);
        int bi2 = size2bin(GET_SIZE(HDRP(bp)));
        bin_insert(bi2, bp);
        bp = find_fit(asize);
        if (!bp){ pthread_mutex_unlock(&g_lock); return NULL; }
    }
    size_t csize = GET_SIZE(HDRP(bp));
    int prev_alloc = GET_PALLOC(HDRP(bp));
    pthread_mutex_unlock(&g_lock);

    // 3) place (락 밖에서 해도 되지만, 단순화 위해 밖에서 수행)
    set_header(bp, csize, 0, prev_alloc); // 잠깐 free로 간주하여 split_place가 정상 동작
    split_place(bp, asize);
    return bp;
}

void mm_free(void* p){
    if (!p) return;
    pthread_mutex_lock(&g_lock);
    set_header(p, GET_SIZE(HDRP(p)), 0, GET_PALLOC(HDRP(p)));
    void* bp = coalesce(p);
    int bi = size2bin(GET_SIZE(HDRP(bp)));
    // 1) tcache로 먼저 시도(소형/빈도 높은 경우 히트율↑)
    pthread_mutex_unlock(&g_lock);
    if (!tcache_push(bi, bp)){
        pthread_mutex_lock(&g_lock);
        bin_insert(bi, bp);
        pthread_mutex_unlock(&g_lock);
    }
}

void* mm_realloc(void* p, size_t n){
    if (!p) return mm_malloc(n);
    if (n == 0){ mm_free(p); return NULL; }
    size_t asize = req2asize(n);
    size_t csize = GET_SIZE(HDRP(p));
    if (asize <= csize) return p;

    // 인접 우측 병합 시도
    pthread_mutex_lock(&g_lock);
    void* nb = NEXT_BLK(p);
    if (!GET_ALLOC(HDRP(nb))){
        size_t comb = csize + GET_SIZE(HDRP(nb));
        if (comb >= asize){
            int bi = size2bin(GET_SIZE(HDRP(nb)));
            bin_remove(bi, nb);
            set_header(p, comb, 1, GET_PALLOC(HDRP(p)));
            pthread_mutex_unlock(&g_lock);
            split_place(p, asize);
            return p;
        }
    }
    pthread_mutex_unlock(&g_lock);

    // 새로 할당 후 복사
    void* np = mm_malloc(n);
    if (!np) return NULL;
    memcpy(np, p, csize - WSIZE);
    mm_free(p);
    return np;
}

int mm_init(void){
    memset(&tcache, 0, sizeof tcache);
    pthread_mutex_lock(&g_lock);
    // 최초 2*WSIZE 프롤로그/에필로그는 간소화하여 생략(실습 간편화)
    void* bp = extend_heap(1<<12);
    if (!bp){ pthread_mutex_unlock(&g_lock); return -1; }
    bp = coalesce(bp);
    int bi = size2bin(GET_SIZE(HDRP(bp)));
    bin_insert(bi, bp);
    pthread_mutex_unlock(&g_lock);
    return 0;
}
```

> **핵심 포인트**: prev_alloc 비트로 **푸터 없이** 통합, **분리 적합 + tcache** 로 빠른 경로, bin 탐색→split.
> 실제 상용 구현은 **아레나 다중화**, **페이지/런(run) 관리**, **중앙 freelist** 등 훨씬 더 정교하다.

---

## 사용 예 — 마이크로 벤치 & 검증

### 간단 벤치 드라이버

```c
// bench.c — gcc bench.c mini_alloc.o -lpthread -O2
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

extern int   mm_init(void);
extern void* mm_malloc(size_t n);
extern void  mm_free(void* p);
extern void* mm_realloc(void* p, size_t n);

int main(){
    if (mm_init() != 0){ fprintf(stderr, "init failed\n"); return 1; }

    const int N = 200000;
    void* ptrs[1024] = {0};
    srand(1);
    clock_t t0 = clock();

    for (int i=0;i<N;i++){
        int k = rand() & 1023;
        if (ptrs[k]){
            if ((rand() & 7)==0){
                size_t s = (rand()%4096)+1;
                ptrs[k] = mm_realloc(ptrs[k], s);
            }else{
                mm_free(ptrs[k]); ptrs[k]=NULL;
            }
        }else{
            size_t s = (rand()%4096)+1;
            ptrs[k] = mm_malloc(s);
        }
    }
    clock_t t1 = clock();
    printf("ops/s ~ %.1f\n", (double)N / ((t1-t0)/(double)CLOCKS_PER_SEC));
    for (int i=0;i<1024;i++) if (ptrs[i]) mm_free(ptrs[i]);
}
```

### Sanitizer로 검증

```bash
clang -g -O1 -fsanitize=address,undefined -fno-omit-frame-pointer \
  -c mini_alloc.c && clang -g -O1 -fsanitize=address,undefined bench.c mini_alloc.o -lpthread -o bench_san
./bench_san
```

---

## 단편화 분석 — 직감과 수학

- **외부 단편화**: 합은 충분하나 큰 연속 블록 없음 → 통합·압축 필요(압축은 일반 할당기에선 어려움, region/런 기반 설계가 유리).
- **내부 단편화**: 정렬/클래스 반올림/헤더/슬랙으로 비는 공간.

간이 지표(실험 기반):
- 요청 분포 \(D(s)\) 에 대해 클래스 반올림 \(C(s)\) 일 때 내부 단편화 기대값
  $$
  \mathbb{E}[\text{internal}] \approx \mathbb{E}[C(s)-s]
  $$
- 외부 단편화는 **통합 정책 + 배치 정책** 함수. 실측이 최선(힙 덤프/프로파일).

---

## 재할당 패턴 — 초보가 자주 틀리는 곳

안전 | 설명
---|---
`realloc` 반환값은 **임시 포인터**로 받는다 | 실패 시 `NULL`을 반환하고 **원본은 그대로** → 누수/댕글링 방지
지수 성장 | `cap = cap*2` 등으로 재복사 횟수↓
`calloc` 전 **곱셈 오버플로** 확인 | `__builtin_mul_overflow(k,n,&bytes)`

예:
```c
void* grow_buf(void* p, size_t* cap, size_t need){
    if (need <= *cap) return p;
    size_t newcap = *cap ? *cap : 64;
    while (newcap < need) newcap <<= 1;
    void* q = realloc(p, newcap);
    if (!q) return NULL;
    *cap = newcap; return q;
}
```

---

## 동시성/NUMA/페이지 — 운영 환경 팁

- **Arena** 를 CPU/NUMA 노드에 바인딩 → 원격 메모리 접근↓, DTLB miss↓.
- **Huge Page(2MB)**는 TLB 압력↓, **내부 단편화↑**. 대형 오브젝트/region에서 유리.
- **First-touch 정책**: 초기화 스레드가 메모리 노드를 결정 → 올바른 바인딩 중요.

---

## 힙 디버깅·관찰 레시피

작업 | 도구/명령 | 메모
---|---|---
경계/UAF 탐지 | `ASan` | 개발/CI
누수 | `LSan`, Valgrind | 장시간 테스트
힙 사용량/분포 | 할당기 프로파일러/로그 | jemalloc/tcmalloc 계열 제공
페이지/캐시 | `perf stat -e page-faults,cache-misses,dTLB-load-misses` | 성능 병목
맵 확인 | `/proc/<pid>/maps`, `smaps`, `pmap` | 영역/권한/anon/file

---

## 실전 설계 체크리스트

- [ ] **size class** 정의(소형·중형·대형)와 **bin 수** 합리화
- [ ] **tcache 깊이**(hit↑ vs 메모리↑)
- [ ] **split 임계**와 **지연 통합** 트레이드오프
- [ ] **mmap cutoff**(대형은 바로 맵/언맵)
- [ ] **arena 수**(코어/NUMA 대비)
- [ ] **무결성 검사**(링크 검증/안전 unlink)와 **진단 후크**
- [ ] **옵저버빌리티**(힙 통계·샘플링/프로파일) 내장

---

## 보너스: 버디/슬랩 간략 구현 스케치

### 버디(2^k)

장점: 병합 O(logN), 매우 빠름. 단점: 내부 단편화↑.
```c
// 요청 → 가장 작은 2^k로 반올림. free 시 상호 보색 주소와 병합.
buddy_of(addr, k) = addr ^ (1<<k);
```

### 슬랩(고정 크기 오브젝트)

- **슬랩 헤더**가 빈 오브젝트 단일 연결리스트를 보유.
- 빠른 할당/해제, 캐시 친화, 내부 단편화 낮음(타입 고정일 때).

---

## 마무리

동적 메모리 할당은 **블록 형식 + 자유 구조 + 배치/통합 정책 + OS 인터페이스**의 종합 설계다.
실전 해법은 대개 **분리 적합 + tcache + 다중 arena + 대형 mmap 경로**로 수렴한다.
사용자 관점에서는 **정렬/오버플로/수명/동시성**을 주의하고, **ASan/Valgrind/프로파일**로 지속 검증하라.
그렇게 하면 **높은 처리량**과 **수용 가능한 단편화** 사이의 최적점을 안정적으로 찾을 수 있다.

---

## 안전 패턴 모음

```c
// 1) calloc 오버플로
size_t bytes;
if (__builtin_mul_overflow(k, n, &bytes)) { errno = ENOMEM; return NULL; }
void* p = calloc(k, n);

// 2) realloc 안전 수용
void* q = realloc(p, new_sz);
if (!q) { /* p는 여전히 유효 */ } else p = q;

// 3) free(NULL) 무해
free(p); p = NULL;

// 4) posix_memalign 정렬
void* a = NULL;
if (posix_memalign(&a, 64, len) != 0) { /* handle */ }

// 5) 경계 체크 I/O
char* b = mm_malloc(m);
if (!b) /* handle */;
memcpy(b, src, m); // m 바이트 안 넘도록 주의
```

## 미니 테스트(단편화 감보기)

```c
// 다양한 사이즈 분포로 스트레스, 힙 프로파일과 함께 관찰
for (int r=0;r<100;r++){
    size_t s = (r%3==0) ? 32 : (r%3==1) ? 256 : (rand()%4096)+1;
    void* p = mm_malloc(s);
    if (r%5==0) p = mm_realloc(p, s*2);
    if (r%2) mm_free(p);
}
```

> 관찰 포인트: bin별 잔여, split 빈도, tcache hit/miss, 평균/최대 블록 크기, 페이지 당 라이브 밀도.
