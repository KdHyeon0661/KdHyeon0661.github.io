---
layout: post
title: 객체지향설계 - 안티 패턴
date: 2025-07-25 22:20:23 +0900
category: 객체지향설계
---
# 안티 패턴(Anti-pattern)

## 1. 개념 재정의와 경계

- **안티 패턴**: 단기적으로 편해 보이나 **장기 유지보수성/성능/확장성/보안**에 해로운 반복적 해법.  
- **코드 냄새(Code Smell)**: 즉각적으로 해로운 건 아니나 **개선 필요 신호**(안티 패턴으로 진화할 수 있음).  
- **맥락(Context)**: 어떤 구조도 **상황**에 따라 패턴↔안티 패턴이 될 수 있음(예: Singleton은 시스템 전역 상태를 숨기면 해롭지만, 진짜 단일 하드웨어 핸들러엔 합리적일 수 있음).

---

## 2. 왜 발생하는가 — 원인 심화

1) **단기 납기 중심**(“일단 붙인다”) → 구조적 부채 누적  
2) **원리 미해득/카피-페이스트**(카고 컬트)  
3) **만능해법 집착**(골든 해머)  
4) **도메인 경계 불명확**(바운디드 컨텍스트 미정의)  
5) **관찰가능성 부재**(메트릭/로그/트레이싱 없이 추측 기반 수정)

---

## 3. 대표 안티 패턴 — 스펙트럼 맵

### 3.1 코드 수준

| 안티 패턴 | 핵심 징후 | 위험 | 대표 처방 |
|---|---|---|---|
| 스파게티 코드 | 깊은 중첩, 분기 난무 | 회귀 버그↑ | Extract Method/Class, State/Strategy |
| 갓 클래스(Blob) | 다기능 초대형 클래스 | SRP/LSP 위반 | 책임 분리, 모듈화 |
| 하드코딩 | URL/비밀/상수 박제 | 환경 이식성↓ | 설정/비밀관리(DI, Vault) |
| 기본형 집착 | Money/Duration을 숫자로 | 도메인 규칙 실수 | Value Object 도입 |
| 조건문 폭발 | 긴 if/switch | OCP 위배 | Polymorphism/Rules Engine |
| 메시지 체인 | `a.b().c().d()` | 결합도↑ | Hide Delegate, Facade |
| Boolean 플래그 생성자 | `new X(true,false,...)` | 의미 불명 | Parameter Object, Builder |

**예: 조건문 폭발 → 전략 패턴 적용(Java)**

```java
public interface FeePolicy { long apply(long cents); }
public final class RegularFee implements FeePolicy { public long apply(long c){ return c; } }
public final class VipFee implements FeePolicy { public long apply(long c){ return Math.round(c * 0.95); } }

public final class FeeCalculator {
    private final Map<CustomerTier, FeePolicy> map;
    public long fee(long c, CustomerTier t){ return map.getOrDefault(t, new RegularFee()).apply(c); }
}
```

### 3.2 아키텍처·설계

| 안티 패턴 | 핵심 징후 | 위험 | 처방 |
|---|---|---|---|
| 빅 볼 오브 머드(Big Ball of Mud) | 경계/레이어 붕괴 | 변경 충격 범위↑ | 레이어링, 포트/어댑터, DDD 경계 |
| 분산 모놀리스 | 마이크로서비스인데 강결합 | 배포·장애 도미노 | Bounded Context, Async 이벤트, 독립 배포 |
| 서비스 로케이터 | 런타임 전역 검색 | 숨은 의존 | DI 컨테이너, 생성자 주입 |
| 프레임워크 누수 | 도메인에 ORM/HTTP 타입 | 이식성↓ | 포트/어댑터, DTO 매핑 |
| 과도 상속 | is-a 불명확 | LSP 위반 | 합성(Composition) 우선 |

**예: 서비스 로케이터 → 생성자 주입(C#)**

```csharp
// Before
public class Billing {
    public void Charge(Order o){
        var gateway = ServiceLocator.Resolve<IPaymentGateway>();
        gateway.Pay(o);
    }
}

// After
public class Billing {
    private readonly IPaymentGateway _gateway;
    public Billing(IPaymentGateway gateway){ _gateway = gateway; }
    public void Charge(Order o){ _gateway.Pay(o); }
}
```

### 3.3 데이터·DB

| 안티 패턴 | 징후 | 위험 | 처방 |
|---|---|---|---|
| N+1 쿼리 | 루프 내 Select | 성능 폭발 | Fetch join, batch, 캐시 |
| SELECT * | 불필요 컬럼 | I/O 낭비 | 명시 컬럼, DTO |
| EAV 모델 남용 | key-value 테이블 | 제약·인덱스 불리 | 정규화/스키마 설계 |
| 카디널리티 폭발 | 조인 바다 | OOM/슬로우 | 조인전략 재설계/인덱스 |

**예: N+1(ORM JPQL)**

```java
// Bad
@Query("select o from Order o") List<Order> findAll(); // 이후 o.getLines() 루프에서 N건 추가 쿼리

// Good
@Query("select distinct o from Order o join fetch o.lines") List<Order> findAllWithLines();
```

### 3.4 동시성·성능

| 안티 패턴 | 징후 | 위험 | 처방 |
|---|---|---|---|
| 잘못된 DCL | volatile 미사용 | 레이스 | 안전한 초기화/언어 보장 |
| 과도 락/교착 | 잠금 순서 불일치 | 데드락 | 락 순서 규약, 타임아웃 |
| 바쁜 대기 | sleep/while | CPU 낭비 | 큐/신호, 백오프 |

**예: 잘못된 Double-Checked Locking(Java)**

```java
// Bad
class C { private static C i;
  static C get(){ if(i==null){ synchronized(C.class){ if(i==null){ i=new C(); }}} return i; } }
// Good
class C { private static volatile C i;
  static C get(){ if(i==null){ synchronized(C.class){ if(i==null){ i=new C(); }}} return i; } }
```

### 3.5 API·계약

| 안티 패턴 | 징후 | 위험 | 처방 |
|---|---|---|---|
| 엔드포인트 폭발 | 리소스*액션 조합 난립 | 유지보수↓ | 리소스 모델링/표준 동사 |
| 비멱등 | 재시도시 중복 | 데이터 오염 | 멱등키/PUT/DELETE 의미 준수 |
| 버전 없는 변경 | 조용한 깨짐 | 클라이언트 장애 | SemVer, `/v2`, Deprecation 정책 |

### 3.6 테스트

| 안티 패턴 | 징후 | 위험 | 처방 |
|---|---|---|---|
| 취약 테스트 | 내부 구현 고정 | 리팩토링 저해 | 행동 기반 검증 |
| 슬리핑 테스트 | `Thread.sleep` | 플래키 | 폴링/가짜 클록 |
| 과도 목 | 전부 Mock | 거짓 양성 | 계약·통합테스트 균형 |

### 3.7 보안

| 안티 패턴 | 징후 | 위험 | 처방 |
|---|---|---|---|
| 하드코딩 비밀 | 키/토큰 상수 | 유출 | Secret Manager/ENV |
| 자체 암호 | 직접 AES/난수 | 취약 | 검증 라이브러리 |
| 로그 민감정보 | 토큰/PII 출력 | 규제 위반 | 마스킹/필터 |

---

## 4. “패턴이 안티 패턴이 되는 순간”

- **Singleton**: 전역 상태·숨은 의존·동시성 문제 → **DI + 스코프 관리**로 대체.  
- **Active Record**: 비즈니스 규칙이 모델 밖에 산재 → **도메인 서비스·애그리게이트**로 재배치.  
- **Microservice**: 경계 불분명·공유 DB → **분산 모놀리스**. → **Bounded Context**, **데이터 독립**.

---

## 5. 리팩토링 처방전 — 냄새별 구체 전략

### 5.1 갓 클래스 분해(Extract Class + Facade)

```java
// Before
class ReportManager {
  void run(){ fetch(); calc(); toPdf(); email(); }
}
// After
class DataFetcher{...} class Calculator{...} class PdfRenderer{...} class Mailer{...}
class ReportFacade {
  void run(){ var d=fetcher.fetch(); var r=calc.run(d); var pdf=pdfs.render(r); mail.send(pdf); }
}
```

### 5.2 기본형 집착 → VO

```java
// Before
long cents; String currency;
// After
public record Money(long cents, String currency){
  public Money add(Money o){ requireSame(o); return new Money(cents+o.cents, currency); }
  private void requireSame(Money o){ if(!currency.equals(o.currency)) throw new IllegalArgumentException(); }
}
```

### 5.3 프레임워크 누수 차단(포트/어댑터)

```java
// domain port
public interface PaymentPort { Authorization authorize(Money amt, Card card); }
// infra adapter
public class StripeAdapter implements PaymentPort { /* Stripe SDK … */ }
```

### 5.4 N+1 제거(SQL)

```sql
-- Bad
SELECT * FROM orders;         -- 앱 루프에서 각 주문별 SELECT * FROM order_lines

-- Good
SELECT o.id, ol.*
FROM orders o
JOIN order_lines ol ON ol.order_id = o.id;
```

### 5.5 자바스크립트 콜백 지옥 → async/await

```javascript
// Bad
getA((a)=> getB(a,(b)=> getC(b,(c)=> done(c))))
// Good
const a = await getA(); const b = await getB(a); const c = await getC(b); done(c);
```

---

## 6. 성능·복잡도 지표로 “안티 패턴 조짐” 감지

- **사이클로매틱 복잡도**  
  $$ M = E - N + 2P $$
  분기가 많을수록 테스트 하한 증가 → 조건 분해/전략화 필요.

- **유지보수성 지수(MI)**  
  $$ MI = \max\left(0, 171 - 5.2\ln(V) - 0.23M - 16.2\ln(LOC)\right) $$
  낮아지면 구조 분해·중복 제거 신호.

- **N+1 탐지**: APM/쿼리 로그에서 **동일 SQL 다발** 패턴.  
- **순환 의존 그래프**: 모듈 간 cycle 발견 시 레이어링/포트로 절단.

---

## 7. 운영·DevOps 관점 안티 패턴

| 안티 패턴 | 징후 | 처방 |
|---|---|---|
| 스노우플레이크 서버 | 수작업 설정 | IaC(Terraform/Ansible), Immutable Image |
| 수동 배포 | SSH/복붙 | CI/CD, Canary/Blue-Green |
| 관찰 불가 | 로그/메트릭 없음 | 표준 로깅·트레이싱(OpenTelemetry) |

---

## 8. 예방 체계: 프로세스·문화

1) **코드 리뷰 체크리스트**(SRP, 결합도, 테스트 커버, 보안사항)  
2) **리팩토링 타임박싱**(스프린트당 N시간) + **부채 레지스터**(가중치=영향×빈도)  
3) **품질 게이트**(정적분석/복잡도/중복/뮤테이션 스코어 임계치)  
4) **아키텍처 의사결정 기록(ADR)** — 맥락/트레이드오프 문서화

---

## 9. 빠른 진단표 — 오늘 바로 써먹는 12문항

- [ ] 같은 로직이 3곳 이상 복제되어 있는가?  
- [ ] 클래스/메서드 이름만 보고 역할이 추론되는가?  
- [ ] Boolean 플래그가 3개 이상 전달되는가?  
- [ ] 도메인 객체가 ORM/JPA 어노테이션·HTTP 타입을 직접 아는가?  
- [ ] 루프 안에서 DB/HTTP를 호출하는가(N+1)?  
- [ ] 전역 싱글톤이 테스트를 어렵게 하는가?  
- [ ] 서비스 간 강결합(동기 체인)이 있는가?  
- [ ] API가 멱등/버전/계약 테스트를 갖췄는가?  
- [ ] 슬리핑 테스트/플래키 테스트가 있는가?  
- [ ] 비밀/토큰이 코드나 로그에 노출되는가?  
- [ ] 모듈 간 순환 참조가 있는가?  
- [ ] 관찰가능성(로그·메트릭·트레이스)이 기본 탑재인가?

---

## 10. 사례 시나리오 — “분산 모놀리스” 탈출(요약)

**징후**: 7개 서비스가 하나의 스키마를 공유, 동기 RPC 체인, 배포 동시 필요.  
**처방**:  
- 컨텍스트 매핑 → 서비스 경계 재정의(DDD)  
- **비동기 이벤트/사후 일관성**(SAGA)로 트랜잭션 분리  
- **DB 스키마 분리** + 읽기 전용 뷰/이벤트로 통합  
- 계약 테스트로 상호 독립 배포 보장

---

## 11. 미니 치트시트 — 냄새→처방 원라인

- **긴 메서드** → Extract Method / 명명으로 의도 드러내기  
- **조건 폭발** → Strategy/State/Rule 엔진  
- **갓 클래스** → Extract Class + Facade + 포트/어댑터  
- **하드코딩** → 설정·비밀 분리(ENV/Vault)  
- **N+1** → Fetch join/Batch, CQRS 고려  
- **서비스 로케이터** → 생성자 주입(DI)  
- **프레임워크 누수** → 도메인 순수화, DTO/Mapper  
- **과도 상속** → 합성 선호, LSP 준수  
- **취약 테스트** → 퍼블릭 계약 기준의 BDD/계약 테스트

---

## 12. 부록: 코드 모음

### 12.1 데드락 방지(락 순서 규약, Java)

```java
void transfer(Account a, Account b, Money m){
  Account first = a.id().compareTo(b.id()) < 0 ? a : b;
  Account second = first==a ? b : a;
  synchronized (first){ synchronized (second){
      a.withdraw(m); b.deposit(m);
  }}
}
```

### 12.2 SQL 인젝션 방지(파라미터 바인딩)

```python
# Bad
cur.execute(f"SELECT * FROM user WHERE name='{name}'")
# Good
cur.execute("SELECT * FROM user WHERE name = %s", (name,))
```

### 12.3 테스트의 슬립 제거(가짜 클록)

```javascript
jest.useFakeTimers();
startJob();
jest.advanceTimersByTime(5000);
expect(done).toHaveBeenCalled();
```

---

## 13. 결론

안티 패턴은 “나쁜 습관의 자동반사”다. 이를 **지표·리뷰·테스트·리팩토링 루프**로 상시 탐지·교정하고, **도메인 경계/의존 역전/합성 우선** 원칙을 적용하면 **변화 친화적 설계**를 지속 가능하게 유지할 수 있다.  
본 문서의 **진단표·치트시트·코드 처방**을 팀 규약에 통합해, 기능 개발과 함께 **항구적 리팩토링**을 실천하라.