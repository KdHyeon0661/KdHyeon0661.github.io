---
layout: post
title: 컴퓨터시스템 - 파이프라이닝 Y86-64 구현
date: 2025-07-26 23:20:23 +0900
category: 컴퓨터시스템
---
# 파이프라이닝 Y86-64 구현

## 0. 큰 그림 — SEQ → PIPE

- **SEQ**: 한 명령이 Fetch→Decode→Execute→Memory→Write-back을 **순차**로 모두 끝낸다. 단순·직관적이나 길~어진 조합 경로로 인해 클럭 속도가 낮다.
- **PIPE**: 위 과정을 5개 **스테이지**로 나누고, 각 스테이지 사이에 **파이프라인 레지스터**(F/D, D/E, E/M, M/W)를 둔다. 서로 다른 명령들이 각 스테이지를 **동시에** 흘러 throughput을 ↑.
- 이득: 이상적 CPI≈1.
  비용: **데이터/제어 해저드** 처리(포워딩·스톨/버블·플러시), **예외의 정밀성** 보장.

---

## 1. 스테이지 역할과 인터페이스

### 1.1 F (Fetch)
- 인출: `icode/ifun` (1B), 필요 시 `reg byte (rA/rB)`, `valC(8B)`
- 계산: `valP = PC + instr_len`
- 오류: `imem_error`
- **출력**: `(icode, ifun, rA, rB, valC, valP)` → F/D

### 1.2 D (Decode / Register Fetch)
- 결정: `srcA, srcB, dstE, dstM` (명령별 규칙)
- 레지스터 파일 읽기: `valA = R[srcA]`, `valB = R[srcB]`
- **출력**: `(valA, valB, rA, rB, dstE, dstM, icode, ifun, valC, valP)` → D/E

### 1.3 E (Execute)
- ALU 입력 선택: `aluA, aluB` (주소 계산, RSP ±8, 산술 등)
- 연산: `valE = ALU(aluA, aluB, alufun)`
- 조건코드(CC): `IOPQ`일 때만 **set_cc** → (ZF,SF,OF) 갱신
- 분기/조건이동 판정: `Cnd` (ZF/SF/OF 기반)
- **출력**: `(valE, valA(for store), dstE, dstM, icode, ifun, Cnd)` → E/M

### 1.4 M (Memory)
- 접근: `store: M8[valE] ← valA` / `load: valM = M8[valE]`
- 오류: `dmem_error`
- **출력**: `(valM, valE, dstE, dstM, icode, stat)` → M/W

### 1.5 W (Write-back / Commit)
- 쓰기: `if dstE!=RNONE then R[dstE] ← valE`, `if dstM!=RNONE then R[dstM] ← valM`
- 커밋: `Stat ← {AOK, HLT, ADR, INS}`
- (PC 업데이트 자체는 F의 `PC 선택기`가 수행하되, **리다이렉트/스톨/플러시** 결정은 전 단계 신호에 의존)

---

## 2. 파이프라인 레지스터 (최소 보존 집합)

### 2.1 F/D
```
FD.icode, FD.ifun, FD.rA, FD.rB, FD.valC, FD.valP
```

### 2.2 D/E
```
DE.icode, DE.ifun,
DE.rA, DE.rB,
DE.valA, DE.valB,
DE.valC, DE.valP,
DE.srcA, DE.srcB,  # (선택) 미리 계산해 저장해도 좋음
DE.dstE, DE.dstM
```

### 2.3 E/M
```
EM.icode, EM.ifun,
EM.valE,
EM.valA,         # store/ret 타깃 등
EM.dstE, EM.dstM,
EM.Cnd           # 분기/조건이동 판정 결과
```

### 2.4 M/W
```
MW.icode, MW.ifun,
MW.valE, MW.valM,
MW.dstE, MW.dstM,
MW.Stat
```

> **팁**: 디버깅 편의를 위해 각 레지스터에 **원 PC**(혹은 raw 바이트)를 추가로 남기면 트레이스가 쉬워진다.

---

## 3. 명령별 src/dst/ALU 입력 규칙 (PIPE용)

### 3.1 srcA/srcB (표준 매핑)
```text
srcA =
  rA   if icode in {IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ}
  RSP  if icode in {IPOPQ, IRET}
  RNONE otherwise

srcB =
  rB   if icode in {IOPQ, IRMMOVQ, IMRMOVQ}
  RSP  if icode in {IPUSHQ, IPOPQ, ICALL, IRET}
  RNONE otherwise
```

### 3.2 dstE/dstM
```text
dstE =
  rB   if icode in {IRRMOVQ && Cnd, IIRMOVQ, IOPQ}
  RSP  if icode in {IPUSHQ, IPOPQ, ICALL, IRET}
  RNONE otherwise

dstM =
  rA   if icode in {IMRMOVQ? no, IPOPQ yes, MRMOVQ yes}
        # load(mrmovq D(rB), rA) → dstM=rA
        # popq rA → dstM=rA
  RNONE otherwise
```

### 3.3 ALU 입력·연산
```text
aluA =
  valA if icode in {IRRMOVQ, IOPQ}
  valC if icode in {IIRMOVQ, IRMMOVQ, IMRMOVQ}
  -8   if icode in {ICALL, IPUSHQ}
  +8   if icode in {IRET, IPOPQ}
  0    otherwise

aluB =
  valB if icode in {IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ}
  0    otherwise

alufun = (icode==IOPQ ? ifun : ALUADD)
set_cc = (icode==IOPQ)  # OPq만 CC 세팅
```

> **SEQ와 동일**하되, `valA/valB/valC`는 **D/E**, `Cnd`는 **E**에서 계산된 것을 사용.

---

## 4. 포워딩 (Bypassing) — RAW 의존성 처리

포워딩은 E 단계 ALU 입력이 필요로 하는 **최신 피연산자**를 레지스터 파일 대신 **파이프라인 다운스트림 값**에서 직접 공급한다.

### 4.1 소스별 우선순위 (EX-stage에서 A/B 각각 동일 로직)
1) **E/M 단계 결과**가 바로 앞에 존재하면 최우선
2) **M/W 단계 결과**(valE 또는 valM)
3) 그 외는 **D/E.valA/valB** (레지스터 파일)

### 4.2 의사코드 (A 입력)
```c
// rs = DE.srcA (필요 소스 레지스터)
word fwdA = DE.valA; // 기본: RF 결과
if (EM.dstE != RNONE && EM.dstE == DE.srcA) fwdA = EM.valE;
else if (MW.dstE != RNONE && MW.dstE == DE.srcA) fwdA = MW.valE;
else if (MW.dstM != RNONE && MW.dstM == DE.srcA) fwdA = MW.valM;
// aluA <- fwdA 또는 규칙상 valC/±8이 우선이면 그쪽
```

(B 입력도 동일 패턴)

> **중요**: **로드-유즈(load→use)** 는 포워딩만으로 해결 불가. `valM`은 **M/W**에서야 유효하여, 바로 다음 사이클 E가 필요로 하면 1-cycle 스톨이 필요.

---

## 5. 해저드 검출(HDU) — 스톨/버블/플러시 신호

파이프라인 제어는 보통 다음 **제어 비트**로 구성한다:

```
F_stall, F_flush(=bubble)
D_stall, D_flush
E_flush
M_flush (예외 처리 시)
```

> 구현은 “레지스터 유지(stall)”, “NOP 주입(bubble/flush)”로 표현.

### 5.1 로드-유즈 해저드 (대표 규칙)
- 조건:
  - `DE` **뒤**에 있는 `EX` 명령이 `IMRMOVQ` (load)이고
  - `ID`(=FD) 단계 명령의 `srcA/srcB` 중 하나가 `DE.dstM`(=load 목적 레지스터)와 같으면
- 조치(전형):
  - `F_stall = 1`, `D_stall = 1`, `E_flush = 1`  → **1사이클 버블**로 해결

#### HCL 스타일
```hcl
bool load_use =
    (DE.icode == IMRMOVQ) &&
    ( (FD.srcA == DE.dstM) || (FD.srcB == DE.dstM) );

F_stall   = load_use;
D_stall   = load_use;
E_flush   = load_use;   # ID/EX <- NOP
```

### 5.2 분기(제어) 해저드 — predict-not-taken (기본안)
- 기본: **조건분기 jXX는 not-taken**으로 예측 → F는 `valP` 경로 인출
- E 단계에서 `Cnd==1`(**실제 taken**)이면 **오류로 인출된** 다음 명령들을 **플러시**
- 조치(전형):
  - `D_flush = (E.icode == IJXX) && E.Cnd`
  - `E_flush = (E.icode == IJXX) && E.Cnd` (파이프 구현/타이밍에 따라 D만 flush하기도 하나, 교재 기본은 D/E 둘 다 버블로 단순화하는 구성이 흔함)
  - F의 **PC 리다이렉트 = E.valC**(분기 타겟)

#### HCL 스타일
```hcl
bool br_mispredict = (E.icode == IJXX) && E.Cnd;  # not-taken 예측에서 taken 판정

D_flush = br_mispredict;
E_flush = br_mispredict;    # 구현 단순화를 위한 이중 버블
```

> **대안**: “D만 flush”로 최적화 가능. 문서 전반에서 **한 방식으로 일관**할 것.

### 5.3 `ret` 처리 (타겟 PC = 메모리 pop 결과)
- `ret`의 새 PC는 **M 단계**에서 `valM`으로 얻어진다.
- 흔한 정책: **ret가 D/E/M 중 어느 곳에 있든 F를 stall** → 확정 타겟 나올 때까지 불필요 인출을 방지.
- 조치(전형):
  - `F_stall = (FD.icode == IRET) || (DE.icode == IRET) || (EM.icode == IRET)`
  - `D_flush = (DE.icode == IRET)` (디코드 직후 버블로 흘려보내 단순화)

#### HCL 스타일
```hcl
bool ret_in_pipe = (FD.icode == IRET) || (DE.icode == IRET) || (EM.icode == IRET);

F_stall = F_stall || ret_in_pipe;
D_flush = D_flush || (DE.icode == IRET);
```

> **주의**: ret 정책은 실험실 구현에 따라 다소 차이가 있음. 이 문서는 **stall-F**(D/E/M에 ret 있으면) + **D 버블** 정책을 채택.

### 5.4 예외/invalid/주소오류
- 예외는 **파이프 하류로 전파**하여 **W 단계**에서 commit 시 상태를 바꾼다.
- 조치:
  - 예외 감지 시 **그 이후 명령을 모두 flush** (정밀 예외 보장)
  - `M_flush = dmem_error || ...`, `W.commit`에서 Stat 설정

---

## 6. PC 선택기 (Fetch PC 소스)

우선순위(한 사이클 전 단계 결과 사용):

1) **ret 타겟 준비**: `if (MW.icode==IRET) newPC = MW.valM; else if (EM.icode==IRET) newPC = ...;`
   (혹은 위의 stall 정책으로 ret 타겟 기다림)
2) **분기 리다이렉트**: `if (E.icode==IJXX && E.Cnd) newPC = E.valC;`
3) **call/jmp**: **무조건 taken**이므로 **예측**으로 `valC` 사용
   `if (FD.icode in {ICALL, IJXX(uncond)}) newPC = FD.valC;`
4) **그 외**: `newPC = FD.valP` (not-taken 예측)

#### 의사코드
```c
word choosePC(){
    if (ret_target_ready) return ret_target;      // from MW or EM, 정책에 따라
    if (E.icode==IJXX && E.Cnd) return E.valC;    // taken branch
    if (FD.icode==ICALL || FD.icode==IJXX_uncond) return FD.valC; // predict taken
    return FD.valP; // default not-taken
}
```

> **분기**는 조건분기만 not-taken 예측. **call/jmp**는 대상이 명시되어 예측 오차가 없으므로 **항상 타겟**으로.

---

## 7. 조건코드(CC)와 cmov/jXX 상호작용

- `IOPQ`(산술/논리)가 **E 단계**에서 CC를 갱신.
- 다음 사이클의 `cmovXX/jXX`가 그 CC를 사용한다 → **포워딩 없이** 시맨틱 맞음(레지스터 아닌 전역 CC이므로 E→E 다음 사이클 읽기).
- 단, **load-use로 인한 E 버블** 등으로 스케줄링이 변하면 **잘못된 타이밍에 CC가 보이는** 경우가 생길 수 있어, 교재 설계는 “**OPq만 CC 갱신** + **버블이 E에 들어오면 set_cc 억제**(NOP처럼)”로 안전 보장.

#### HCL 예
```hcl
bool set_cc = (DE.icode == IOPQ) && !E_flush;  # 버블이면 CC 업데이트 금지
```

---

## 8. 정밀 예외(Precise Exceptions)

- **커밋 포인트 = W 단계**.
- 예외(ADR/INS/HLT)는 발생 시점에서 **예외 플래그를 태워 하류로 보내고**, W에서 **Stat**으로 커밋.
- 그 사이에 뒤따르던 명령들은 **flush**되어 커밋되지 않음 → **정밀성 보장**.

---

## 9. HCL/의사코드 — 종합 제어 로직

### 9.1 포워딩 선택 (E 입력)
```hcl
# A 입력
word e_valA = DE.valA;
e_valA = (EM.dstE != RNONE && EM.dstE == DE.srcA) ? EM.valE : e_valA;
e_valA = (MW.dstE != RNONE && MW.dstE == DE.srcA) ? MW.valE : e_valA;
e_valA = (MW.dstM != RNONE && MW.dstM == DE.srcA) ? MW.valM : e_valA;

# B 입력
word e_valB = DE.valB;
e_valB = (EM.dstE != RNONE && EM.dstE == DE.srcB) ? EM.valE : e_valB;
e_valB = (MW.dstE != RNONE && MW.dstE == DE.srcB) ? MW.valE : e_valB;
e_valB = (MW.dstM != RNONE && MW.dstM == DE.srcB) ? MW.valM : e_valB;
```

### 9.2 해저드/스톨·버블
```hcl
bool load_use =
  (DE.icode == IMRMOVQ) &&
  ((FD.srcA == DE.dstM) || (FD.srcB == DE.dstM));

bool br_mispredict = (E.icode == IJXX) && E.Cnd;

bool ret_in_pipe = (FD.icode == IRET) || (DE.icode == IRET) || (EM.icode == IRET);

F_stall = load_use || ret_in_pipe;
D_stall = load_use || ret_in_pipe;
D_flush = br_mispredict || (DE.icode == IRET);
E_flush = br_mispredict || load_use;
M_flush = dmem_error || imem_error;  # 예시
```

### 9.3 PC 선택
```hcl
word newPC =
  (MW.icode == IRET) ? MW.valM :
  (EM.icode == IRET) ? EM.valM :         # 정책에 따라 필요/불필요
  (E.icode == IJXX && E.Cnd) ? E.valC :
  (FD.icode in {ICALL, IJXX_uncond}) ? FD.valC :
  FD.valP;
```

---

## 10. 사이클-트레이스 (포워딩/스톨/분기 동작 관찰)

### 10.1 ADD → ADD (RAW, 포워딩으로 해결)
```
I1: addq %rbx, %rax   # writes rax
I2: addq %rax, %rcx   # reads rax
```

| Cycle | I1 | I2 | 비고 |
|------:|----|----|------|
| 1 | F |    |    |
| 2 | D | F  |    |
| 3 | E | D  |    |
| 4 | M | E  | I2.E에서 **E/M.valE**(I1 결과) 포워딩 |
| 5 | W | M  |    |
| 6 |   | W  |    |

→ **스톨 0**. CPI≈1 유지.

### 10.2 LOAD → USE (1-cycle 스톨 필요)
```
I1: mrmovq 0(%rbp), %rax   # load → valM in M/W
I2: addq %rax, %rcx
```

| Cycle | I1 | I2 | 제어 |
|------:|----|----|------|
| 1 | F |    |    |
| 2 | D | F  |    |
| 3 | E | D  |    |
| 4 | M | (D) | **load_use** → F/D stall, E bubble |
| 5 | W | E  | I2.E에서 **M/W.valM** 포워딩 |
| 6 |   | M  |    |
| 7 |   | W  |    |

→ **스톨 1**. 평균 CPI에 +1/N 기여.

### 10.3 조건분기 (predict-not-taken)
```
I1: jg target   # 실제로 조건 True → taken
I2: ...         # 잘못 인출됨 → flush
```

| Cycle | I1 | I2 | 제어 |
|------:|----|----|------|
| 1 | F |    |    |
| 2 | D | F  |    |
| 3 | E | D  | E에서 Cnd=1 판정 |
| 4 | M | (flush) | **D_flush=1, E_flush=1**, F가 PC=I1.valC로 리다이렉트 |
| 5 | W | F@target |    |

→ **분기 미스 페널티 ≈ 2–3 사이클**(구체는 구현 타이밍에 의존).

### 10.4 `ret` (F stall 정책)
```
I0: call foo
...
foo:
  I1: ret
  I2: (caller next)
```

- `ret`가 파이프라인에 **등장하는 순간부터** F를 **stall** → M에서 `valM`(return addr) 준비되면 F가 그 값으로 재개.
- 잘못 인출 방지 및 구현 단순화.

---

## 11. 성능 모델 (간이 CPI)

이상적 $$\text{CPI}_\text{ideal} = 1$$. 실제는 해저드로 증가:
$$
\text{CPI} \approx 1 \;+\; f_{\text{load-use}}\cdot p_{\text{load-use}}
           \;+\; f_{\text{br-miss}}\cdot p_{\text{br-miss}}
$$
예: 분기 비율 \(f_b=0.2\), 미스율 \(m=0.4\) (정적 예측), 미스페널티 \(p=3\), 로드-유즈 평균 \(0.1\)이면
- 분기 스톨: \(f_b \cdot m \cdot p = 0.2\cdot 0.4\cdot 3 = 0.24\)
- 로드-유즈: \(0.1\)
- **CPI ≈ \(1 + 0.24 + 0.1 = 1.34\)**

---

## 12. 스택/콜/리턴 특이 케이스

- `pushq rA`: E에서 `RSP-8`, M에서 `mem[SP']←valA`, W에서 `RSP←SP'`
- `popq rA` : E에서 `RSP+8`, M에서 `valM←mem[SP]`, W에서 `RSP←SP'` & `rA←valM`
- `call dest`: E에서 `RSP-8`, M에서 `mem[SP']←valP`, F는 **즉시 dest로 인출(예측)**
- `ret`      : M에서 `valM←mem[SP]`(return addr), F는 **stall** 후 `PC=valM`으로 리다이렉트

> **RSP RAW**도 일반 레지스터와 동일하게 포워딩 경로에 포함해야 함.

---

## 13. 구현 선택지 비교(분기/ret 정책)

| 주제 | 기본안(이 글) | 대안 |
|------|----------------|------|
| 조건분기 예측 | not-taken | 1/2-bit 동적, backward-taken |
| mispredict 처리 | D/E flush + PC←E.valC | D만 flush (미세 최적) |
| call/jmp | 무조건 타겟(F가 valC) | BTB로 타겟 캐시(큰 ISA에서 유효) |
| ret | F stall(D/E/M ret 존재 시) | ret 예측 캐시(실험 과제) |

---

## 14. 테스트 프로그램 (yas/y86) — 해저드 검증

### 14.1 RAW/포워딩
```asm
# addadd.ys
    irmovq $1, %rax
    irmovq $2, %rbx
    addq %rbx, %rax     # rax=3
    addq %rax, %rcx     # RAW(rax) → 포워딩으로 stall 없어야 함
    halt
```

### 14.2 load-use (1-stall)
```asm
# loaduse.ys
    irmovq stack, %rsp
    irmovq $8, %rbp
    mrmovq 0(%rbp), %rax   # load
    addq   %rax, %rcx      # 다음 사이클에 사용 → 1 stall 기대
    halt
stack:
    .quad 0
```

### 14.3 분기 미스
```asm
# brmiss.ys
    irmovq $1, %rax
    irmovq $0, %rbx
    subq   %rbx, %rax   # ZF=0
    je     L1           # not-taken 예측이 정답 → flush 없어야
    jg     L2           # taken인데 not-taken 예측 → flush 발생
L1:
    nop
L2:
    halt
```

### 14.4 ret
```asm
# ret.ys
    call foo
    irmovq $1, %rax     # ret 해석 전 인출되면 안 됨(F stall)
    halt
foo:
    ret
```

---

## 15. 디버깅 체크리스트

1) **파이프라인 레지스터 덤프**: 매 사이클 FD/DE/EM/MW의 `(icode, reg ids, val*, dst*, PC)` 출력
2) **포워딩 우선순위**: EM→MW→RF 순으로 최신값 보장
3) **load-use**: 반드시 `F/D stall + E flush` 조합으로 1-cycle 버블
4) **분기**: mispredict 때 D/E flush & PC 리다이렉트 정확히 1회
5) **ret**: D/E/M 어디든 있으면 F stall, 타겟 나올 때만 재개
6) **CC 업데이트**: E_flush일 때 **set_cc 금지**
7) **예외**: ADR/INS/HLT 전파→W에서 commit, 뒤따르는 명령 flush
8) **메모리 포트**: I/D 메모리 분리 또는 멀티포트 모델 일관성 유지

---

## 16. 레지스터 파일/메모리 모델 주의

- **RF**: 동사이클 write-back과 decode read의 순서 정의(보통 “write-first” 혹은 포워딩으로 해결).
- **메모리**: F와 M이 같은 사이클에 접근 → **I/D 분리**가 가장 단순. 단일 포트일 경우 중재기 필요.

---

## 17. 확장 과제

- **(A)** 2-bit 분기 예측기 + BTB 추가, 미스율/페널티 측정
- **(B)** load-use 완화용 “early mem-forward” 실험(타이밍 제약 고려)
- **(C)** 정밀 예외 + 간단 ROB(커밋 스테이지) 도입 비교
- **(D)** 슈퍼스칼라(2-wide) in-order 발행 → 구조/데이터 해저드 조합 폭증 분석

---

## 18. 부록 — 표준 매핑/요약표

### 18.1 src/dst 요약
| icode | srcA | srcB | dstE | dstM |
|------:|:----:|:----:|:----:|:----:|
| IRRMOVQ | rA | RNONE | rB (if Cnd) | RNONE |
| IIRMOVQ | RNONE | RNONE | rB | RNONE |
| IRMMOVQ | rA | rB | RNONE | RNONE |
| IMRMOVQ | RNONE | rB | RNONE | rA |
| IOPQ | rA | rB | rB | RNONE |
| IJXX | RNONE | RNONE | RNONE | RNONE |
| ICALL | RNONE | RSP | RSP | RNONE |
| IRET | RSP | RSP | RSP | RNONE |
| IPUSHQ | rA | RSP | RSP | RNONE |
| IPOPQ | RSP | RSP | RSP | rA |

### 18.2 ALU 입력/연산 요약
| 용도 | aluA | aluB | alufun |
|-----|------|------|--------|
| 주소계산(load/store) | valC | valB | add |
| 산술/논리(OPq) | valA | valB | ifun |
| push/call | −8 | valB | add |
| pop/ret | +8 | valB | add |

---

## 19. 결론

파이프라인 Y86-64는 **간결한 5-stage** 구조 위에
- **포워딩**(EM/MW→E)으로 대부분 **RAW**를 제거하고,
- **load-use**에 **1-cycle 스톨**,
- **분기**는 **predict-not-taken** + **D/E flush**,
- **ret**은 **F stall** 정책,
- **정밀 예외**는 **W에서 커밋**으로 달성한다.

핵심은 **제어 신호의 일관성**과 **트레이스 기반 검증**이다. 위의 HCL/의사코드·테스트 세트를 토대로 구현하면, CS:APP PIPE 과제를 안정적으로 통과할 수 있으며, 분기 예측·BTB·슈퍼스칼라 등 고급 기법으로 매끄럽게 확장 가능하다.
