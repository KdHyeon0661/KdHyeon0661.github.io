---
layout: post
title: 컴퓨터시스템 - 파이프라이닝 Y86-64 구현
date: 2025-07-26 23:20:23 +0900
category: 컴퓨터시스템
---
# 파이프라이닝 Y86-64 구현 — 아주 자세한 안내

아래 문서는 **Y86-64**(CS:APP 교재용 교육 ISA)를 **파이프라인**으로 구현할 때 필요한 모든 핵심 아이디어와 설계·제어·디버깅 정보를 가능한 한 상세하게 정리한 것이다.  
목표는 (1) 파이프라인 구조와 데이터 경로를 설계하는 방법, (2) 포워딩/해저드 검출/스톨/플러시 같은 제어 메커니즘, (3) 분기 처리와 예외(정밀 예외) 처리, (4) 구현 시의 세부 HCL/의사코드, (5) 테스트·디버깅 요령을 **실무적·교육적** 관점에서 제공하는 것이다.

> 전제: Y86-64의 기본 명령(icode/ifun, reg바이트, valC 등)과 SEQ 모델(단일-명령 파이프라인)의 동작을 알고 있다는 가정하에 작성한다. (필요하면 SEQ 설계 요약을 덧붙일 수 있음.)

---

## 목차(빠른 안내)
1. 파이프라인 개요 (스테이지와 목표)  
2. Y86-64 파이프라인 단계(F, D, E, M, W)와 각 단계의 역할  
3. 파이프라인 레지스터(파이프 레지) 설계 — 저장해야 할 신호 목록  
4. 데이터 경로와 제어 신호 매핑(누가 어디서 읽고 쓰는가)  
5. 포워딩(바이패스) 설계 — 경로와 제어 논리  
6. 해저드 검출(Hazard Detection Unit) — 로드-유즈, 구조적 해저드 처리  
7. 분기(제어) 해저드 처리 전략 — 예측, BTB, 펜티, 플러시  
8. 스택/콜/리턴·특수명령 처리 주의사항  
9. 예외와 정밀성(precise exceptions) 보장 방식  
10. HCL/의사코드 예제 (Forwarding unit, HDU, PC logic, 플러시/버블 삽입)  
11. 사이클-단위 실행 예제(트레이스) — forwarding 존재/부재, load-use 등  
12. 성능 모델과 CPI 계산 예시  
13. 구현·디버깅 팁 및 체크리스트  
14. 연습 과제/확장 주제

---

## 1. 파이프라인 개요

파이프라이닝의 목적은 명령어 처리 과정(페치, 디코드, 실행, 메모리, 쓰기)을 여러 **독립 스테이지**로 나누고, 서로 다른 명령들이 **동시에 각 스테이지**에서 동작하도록 하여 처리량(throughput)을 높이는 것이다. 전형적인 5-stage 파이프라인은 다음과 같다:

- **F** — Fetch: 명령어 바이트(instruction bytes) 인출, icode/ifun/rA/rB/valC/valP 결정에 필요한 바이트를 읽음  
- **D** — Decode: 레지스터 파일에서 src 레지스터 읽기(valA,valB), src/dst 결정  
- **E** — Execute: ALU 연산(주소 계산, 산술), 조건 코드(필요 시) 계산  
- **M** — Memory: 데이터 메모리 읽기/쓰기 (load/store, push/pop, call/ret 등)  
- **W** — Write-back: 레지스터에 valE 또는 valM을 기록; 상태 변경(Stat) commit

Y86 파이프라인은 이 5단계 F-D-E-M-W 구조를 그대로 사용하며, 각 단계 사이에는 **파이프라인 레지스터**(F/D, D/E, E/M, M/W)가 존재한다.

---

## 2. 각 스테이지의 역할(세부)

아래는 각 스테이지에서 수행되는 상세 작업이다.

### F (Fetch)
- PC로부터 명령어 첫 바이트(icode/ifun) 인출
- 필요 시 reg byte와 valC(8바이트)을 추가로 인출
- `valP = PC + instruction_length` 계산(다음 명령 주소)
- **출력**: icode, ifun, rA, rB, valC, valP (다음 스테이지로 전송)
- **문제/검사**: imem 접근 실패 → imem_error (ADR 상태 처리)

### D (Decode / Register Fetch)
- D/E 파이프라인 레지스터에 들어온 필드에서 srcA/srcB, dstE/dstM 결정
- 레지스터 파일에서 R[srcA], R[srcB] 읽어 `valA`, `valB` 생성
- **출력**: valA, valB, rA, rB, dstE, dstM, icode, ifun, valC, valP

### E (Execute)
- ALU 입력 선정(aluA, aluB) 및 연산(ADD/SUB/AND/XOR 등)
- `valE` 산출(주소 계산, RSP 조정, 산술 결과 등)
- OPq 명령이면 CC(ZF,SF,OF) 계산(단, CC 업데이트 여부는 정책에 따라 결정)
- **출력**: valE, valA(필요 시), dstE, dstM, icode, ifun, valM? (없음 — 메모리는 다음 단계)

### M (Memory)
- 필요 시 메모리 읽기(M8[valE] → valM) 또는 쓰기(M8[valE] ← valA)
- 메모리 접근 오류(dmem_error) 검사
- **출력**: valM, valE, dstE, dstM, icode, stat-control

### W (Write-back / Commitment)
- dstE에 valE 쓰기(조건부)
- dstM에 valM 쓰기(조건부)
- 알맞은 시점에 Stat(AOK/HLT/ADR/INS) commit
- PC 최종 갱신 결정은 PC logic에 의해 구현되지만, 실제 PC는 Fetch stage에서 사용됨(예측/정정 필요)

> 핵심: 파이프라인 단계마다 어떤 값이 전달되는지 정확히 목록화하면 디버그하기 훨씬 쉬워진다.

---

## 3. 파이프라인 레지스터(저장해야 할 신호)

각 파이프라인 레지스터는 **다음 스테이지에 필요한 모든 정보**를 저장해야 한다. 최소한 다음 필드를 각 레지스터에 저장한다.

- **F/D**:  
  - PC (the PC that fetched this instruction) — optionally store valP  
  - icode, ifun  
  - rA, rB (if present)  
  - valC (if present)  
  - valP

- **D/E**:  
  - icode, ifun  
  - rA, rB  
  - valA, valB (register file outputs)  
  - valC, valP  
  - dstE, dstM, srcA, srcB (혹은 이들 결정 논리용 코드)

- **E/M**:  
  - icode, ifun  
  - valE (ALU result)  
  - valA (for store value)  
  - dstE, dstM  
  - CC 업데이트 정보(새 CC값 또는 set_cc flag)

- **M/W**:  
  - icode, ifun  
  - valE, valM  
  - dstE, dstM  
  - Stat (if any)

> 구현 팁: 레지스터는 가능한 한 소형화하되, 디버깅 위해 필요하면 PC와 raw instruction bytes를 함께 남겨두면 좋다.

---

## 4. 데이터 경로(누가 어디서 읽고 쓰는가) 및 제어 신호

데이터 경로에서 ALU 입력(aluA, aluB) 결정 규칙은 SEQ 설계와 동일하되 파이프라인 환경에서 각 스테이지의 레지스터 값(예: D/E.valA 등)을 사용한다. 예:

- `aluA` 선택: D/E.valA 또는 D/E.valC 또는 ±8 (push/pop/call/ret용)
- `aluB` 선택: D/E.valB (기본) 또는 0
- `alufun` : if icode==IOPQ then ifun else ALUADD
- `Cnd` 계산: 기존 CC(마지막으로 커밋된 CC?)와 D/E의 정보로 판단 — 파이프라인에서는 **CC를 E/M 또는 M/W 단계에서 갱신하고, 분기 판정은 E단계에서** 수행하는 설계가 일반적(그러므로 Cnd는 E 단계에서 결정됨)

**레지스터 파일 접근 규칙**:
- 레지스터 파일은 **읽기 2포트, 쓰기 1포트**를 제공해야 한다 (동일 클록에서 읽기와 쓰기 동시 지원).  
- 일반적인 규칙: 레지스터 파일은 **Rising edge에만 쓰기**하고 combinational read를 허용(읽기는 D stage에서 수행). 파이프라인에서 write-back 해를 바로 다음 cycle의 read에 반영할지(즉, write-back stage와 decode stage가 같은 사이클일 때 read-after-write에서 forwarding 대신 바로 읽히게 허용할지) 결정해야 함(보통은 forwarding으로 해결하거나 write-first 규칙 사용).

---

## 5. 포워딩 (Bypassing) — 경로와 제어

포워딩은 ALU 입력을 위해 **레지스터 파일 값 대신 파이프라인 중간 결과**(E/M.valE, M/W.valE 또는 M/W.valM)를 직접 공급하는 기법이다. 포워딩 없이는 RAW(읽기-후-쓰기) 의존성 때문에 많은 스톨이 발생한다.

### 어떤 값을 포워드할지(일반 규칙)
- ALU가 필요로 하는 소스 레지스터 `rs`에 대해:
  1. 만약 `E/M.dstE == rs`와 `E/M.dstE != RNONE` 및 해당 E/M 명령이 `writes-to-reg`이면 → ALU 입력은 **E/M.valE** (EX stage 바로 앞의 이전 명령 ALU 결과)로부터 공급  
  2. else 만약 `M/W.dstE == rs` 및 M/W의 쓰기 활성화이면 → ALU 입력은 **M/W.valE**로부터 공급  
  3. else 만약 `M/W.dstM == rs` (load일 경우) 및 M/W의 메모리 읽기 → ALU 입력은 **M/W.valM**로 공급  
  4. else → 레지스터 파일에서 읽은 `D/E.valA`(또는 `valB`) 사용

> 주의: load-use 경우(이전 명령이 메모리에서 값을 불러오는 mrmovq인 경우), 값은 M/W.valM에서만 나오므로 E 단계에서 필요하면 1사이클 정지(stall)가 필요하다(포워딩만으로는 해결 불가).

### 포워딩 MUX 예 (의사)
```text
# for ALU input A (EX stage)
if ( (E.M.dstE != RNONE) && (E.M.dstE == D.E.srcA) && E.M.writes_reg ) 
    aluA_input = E.M.valE;
else if ( (M.W.dstE != RNONE) && (M.W.dstE == D.E.srcA) && M.W.writes_reg )
    aluA_input = M.W.valE;
else if ( (M.W.dstM != RNONE) && (M.W.dstM == D.E.srcA) && M.W.writes_mem_read )
    aluA_input = M.W.valM;
else
    aluA_input = D.E.valA_from_regfile;
```

같은 논리를 ALU input B에 대해서도 적용한다.

### 포워딩 제어 논리 (간단 의사코드)
```c
bool forwardA_from_EM = (E_M.dstE != RNONE) && (E_M.dstE == D_E.srcA) && E_M.regWrite;
bool forwardA_from_MW = (M_W.dstE != RNONE) && (M_W.dstE == D_E.srcA) && M_W.regWrite;
# 우선순위: EX/M -> MEM/W
```

> 구현 팁: 포워딩 로직은 **우선순위**(가장 최신값 먼저)를 엄격히 유지해야 한다.

---

## 6. 해저드 검출(Hazard Detection Unit, HDU)

포워딩으로도 해결 불가한 대표적인 케이스는 **load-use**이다. HDU는 ID 단계(혹은 IF/ID와 D/E 레지스터 상태)를 검사하여 스톨 삽입 여부를 결정한다.

### 로드-유즈 해저드 패턴
- EX stage instruction is a `mrmovq` (load): `EX.icode == IMRMOVQ`  
- ID stage instruction uses the loaded register as a source:  
  `D. srcA == EX.dstM` or `D.srcB == EX.dstM`

### 대응 (전형적)
- **스톨**: IF/ID 레지스터 유지(=PC와 IF/ID를 advance하지 않음), ID/EX에 NOP(버블) 삽입 → EX stage가 진행하면서 load가 MEM 단계에 들어가 valM가 준비됨. 그 결과 다음 cycle에 dependent instruction이 정상적으로 EX에 들어가 포워딩 가능.
- 일반적으로 스톨은 **1사이클**이면 충분(전형적 5-stage pipeline). (로드-유즈 페널티 = 1 cycle)

### HDU 의사코드
```c
bool load_use = (EX.icode == IMRMOVQ) && 
                ( (ID.srcA == EX.dstM) || (ID.srcB == EX.dstM) );

if (load_use) {
    stall_IF = true;
    stall_ID = true;
    insert_bubble_in_EX = true;  # ID/EX <- NOP
}
```

> 주의: stall_IF/stall_ID 구현 방식은 fetch stage에서 PC를 유지하고 IF/ID 레지스터를 유지시키는 것이다.

---

## 7. 분기(제어) 해저드 처리

분기 명령은 파이프라인에서 가장 큰 성능 저해 요소 중 하나다. Y86 파이프라인에서는 분기( `jXX` )의 판정이 E stage에서 이루어지는 설계가 흔하다(왜냐하면 E에서 ALU/조건 판정에 필요한 CC를 사용할 수 있기 때문). 이 경우 분기의 **결과가 결정되는 시점**까지 잘못된 명령들을 계속 인출하게 되므로 misprediction이 발생하면 해당 잘못 인출된 명령들을 **플러시(flush)** 해야 한다.

### 대응 전략들
1. **Predict-not-taken (기본)**: 분기를 안 한다고 가정하고 valP 경로를 인출. 만약 분기 taken이면 E 단계에서 잘못 인출된 IF/ID 및 ID/EX를 flush하고 PC를 valC로 바꾼다. 페널티 = 분기를 결정하기까지 들어간 잘못된 명령 수(보통 2 ~ 3 사이클).
2. **Predict-taken**: 반대로 항상 taken으로 예측.
3. **Static prediction by opcode/compile-time**: backward(jump to earlier address) → likely taken for loops, forward → not taken.
4. **Dynamic 1-bit/2-bit predictor**: history-based (더 높은 정확도).
5. **Branch Target Buffer (BTB)**: 분기의 대상 주소를 캐시해 IF stage가 바로 타겟을 fetch할 수 있게 함 → 빨라짐.

### 플러시 동작
- 분기가 E stage에서 mispredict이면 다음을 수행:
  - IF/ID <- NOP (or invalid)
  - ID/EX <- NOP
  - PC <- valC (branch target)
- 또한 분기 예측 구조가 있으면 예측 업데이트 수행.

> 구현 팁: 분기 판정과 플러시 논리는 파이프라인 제어의 핵심이다. 잘못 구현하면 잘못된 인스트럭션이 commit되어 버그가 발생한다.

---

## 8. 스택/콜/리턴, 특수명령 처리

`call`/`ret`/`pushq`/`popq`는 RSP의 업데이트와 메모리 접근(스택 push/pop)을 포함하므로 파이프라인 특이점이 생긴다.

### 문제 포인트
- RSP가 여러 명령에서 동시에 읽히거나 쓰일 수 있다(ex: push 다음에 pop). 포워딩을 이용해 RSP의 최신 값을 사용해야 함.
- `ret`는 실제 return address를 메모리에서 읽어서 PC에 쓰기 때문에 **PC update가 valM에 의존**한다. `ret`은 분기와 유사하게 처리하되 타겟은 M stage에서 결정되며 misprediction penalty가 클 수 있다.
- `call` 은 return address를 스택에 push하므로 메모리 write와 RSP update를 포함한다 — 동일 스택 주소에 대한 겹침 상황을 잘 관리해야 함.

### 권장 처리
- push/pop/call/ret의 RSP 연관 동작은 ALU의 RSP 조정(±8)과 메모리 접근의 순서를 지켜 처리한다.  
- 포워딩 로직에 RSP 관련 연산을 포함시켜 RSP 값의 최신성을 보장한다.  
- `ret`은 타겟 주소가 M stage에서 결정되므로 branch misprediction/flush 논리와 유사하게 처리.

---

## 9. 예외와 정밀성(precise exceptions)

파이프라인에서 **정밀한 예외(precise exceptions)** 를 보장하려면, 예외 발생 시 그 이전의 명령들만이 commit되어 있고 예외 발생 지점 이후의 명령은 취소(flush)되어야 한다. 인오더 in-order 파이프라인(우리의 경우)에서는 **Write-back 단계가 명령의 commit 포인트**가 되어, 예외는 WB에서만 최종적으로 반영하도록 하는 것이 간단한 접근이다.

### 구현 방식 (in-order pipeline)
- 각 명령은 WB에서 register write와 상태 commit을 수행한다.  
- 예외가 어떤 단계에서 감지되면, 예외는 **예외 정보를 파이프라인을 통해 아래로 전파**하고, WB에서 최종 commit 시 Stat을 예외 상태로 설정한다.  
- 그러는 동안 IF/D and beyond 단계는 모두 flush 해주고 Fetch를 멈추거나 예외 처리 루틴으로 점프할 준비를 한다.

> 요지: in-order pipeline에서는 "commit at WB" 규칙을 지키면 정밀 예외 보장이 비교적 간단해진다.

---

## 10. HCL / 의사코드 예제

아래는 주요 제어 유닛(Forwarding Unit, Hazard Detection Unit, PC logic)의 **의사 코드** 또는 HCL 스타일 표기이다.

### Forwarding unit (의사)
```c
// EX stage inputs need srcA, srcB (these are register IDs in D/E)
int ex_srcA = D_E.srcA; 
int ex_srcB = D_E.srcB;

bool use_forwardA_from_EM = (E_M.dstE != RNONE) && (E_M.dstE == ex_srcA) && E_M.regWrite;
bool use_forwardA_from_MW = (M_W.dstE != RNONE) && (M_W.dstE == ex_srcA) && M_W.regWrite;
# priority: EM -> MW -> RF

if (use_forwardA_from_EM) aluA = E_M.valE;
else if (use_forwardA_from_MW) aluA = M_W.valE_or_valM; # depending on whether dst is from mem
else aluA = D_E.valA_from_RF;
```

### Hazard Detection Unit (의사)
```c
bool load_use = (D_E.icode == IMRMOVQ) &&
                ( (ID.srcA == D_E.dstM) || (ID.srcB == D_E.dstM) );

if (load_use) {
    stall_IF = true;
    stall_ID = true;
    insert_bubble_in_EX = true;  // ID/EX <= NOP
}
```

### PC 선택 / branch handling (의사)
```c
// E stage computes Cnd
if (E.icode == IJXX && E.Cnd) newPC = E.valC;
else if (M.icode == IRET) newPC = M.valM;   # ret target known in M
else if (W.icode == IRET) newPC = W.valM;
else newPC = F.valP; // predicted next

// If we detect misprediction (predicted PC != chosen newPC), flush IF/ID and ID/EX and set PC to newPC
```

> 실제 HCL 문법은 교재/도구에 따라 다르므로 위 의사코드를 HCL 구문으로 옮겨 적절히 사용하면 된다.

---

## 11. 사이클-단위 실행 예제(트레이스)

아래는 **단순한 예제**를 사용해 포워딩이 있으면 스톨이 어떻게 줄어드는지 보여준다.

### 예 1: forwarding 가능 (ADD then ADD using result)
```
I1: addq %rbx, %rax      # produces rax
I2: addq %rax, %rcx      # uses rax
```

타임라인(단계 표기, 각 칸은 사이클):

| Cycle | I1 | I2 |
|-------|----|----|
| 1     | F  |    |
| 2     | D  | F  |
| 3     | E  | D  |
| 4     | M  | E  |
| 5     | W  | M  |
| 6     |    | W  |

- I2의 EX 단계(사이클 4)에서 I1의 결과가 E/M.valE 또는 M/W.valE 경로로 포워딩되어 ALU 입력으로 공급된다. **스톨 없음**.

### 예 2: load-use (포워딩 불가, 1-cycle 스톨 필요)
```
I1: mrmovq 0(%rbp), %rax   # load into rax (valM ready only in M)
I2: addq %rax, %rcx        # uses rax immediately
```

타임라인 (with 1-cycle stall):

| Cycle | I1 | I2 |
|-------|----|----|
| 1     | F  |    |
| 2     | D  | F  |
| 3     | E  | D  |
| 4     | M  | (stall) |
| 5     | W  | E  |
| 6     |    | M  |
| 7     |    | W  |

- I2 must stall one cycle so that I1 reaches M (valM ready) and M/W can forward valM to I2.EX (or I2 waits until WB then reads). 일반적으로 1-cycle 스톨.

---

## 12. 성능 모델 / CPI 계산 예시

파이프라인의 이상적 CPI = 1 (한 사이클에 한 명령 완료). 현실적으로는 스톨과 분기 미스 등이 CPI를 높인다.

간단 모델:

\[
\text{CPI} = 1 + \text{stalls per instruction}
\]

예: 분기 빈도 \(f_b = 0.2\) (20%), 분기 미스 페널티 \(p = 3\) cycles (예측 실패 시 버블 3개), 그리고 평균 load-use stall per instr = 0.1 (즉 평균 0.1 cycle stall) 일 때

계산:
- 분기 스톨: \(f_b \times p = 0.2 \times 3 = 0.6\)
- load-use 스톨: \(0.1\)
- CPI = \(1 + 0.6 + 0.1 = 1.7\)

(계산: \(0.2 \times 3 = 0.6\); \(1 + 0.6 + 0.1 = 1.7\))

---

## 13. 구현·디버깅 팁 및 체크리스트

### 초기 설계 단계
- **명확한 데이터 구조**: 각 파이프라인 레지스터의 필드명을 문서화(PC, icode, ifun, valC, rA, rB, valA, valB, valE, valM, dstE, dstM …).
- **메모리 포트**: IF와 MEM의 동시 접근을 원하면 imem/dmem을 분리하거나 멀티포트 메모리 모형을 사용.
- **레지스터 파일 규약**: read-after-write 동작 정의(동일 사이클에 write-back과 decode가 동시에 발생할 때 read가 새값을 읽는지 여부).

### 포워딩·HDU 검증
- 단위 테스트: 간단한 sequence (add/add, load/add, load/use, push/pop, call/ret)로 포워딩/스톨 동작 확인
- 레지스터 값 추적: 각 사이클에서 D/E/E/M/M/W의 valE/valM 값 로깅
- 플러시 테스트: mispredicted branch가 발생할 때 IF/ID와 ID/EX가 제대로 NOP로 바뀌는지 확인

### 디버깅 체크리스트
1. 각 사이클마다 파이프라인 레지스터의 내용을 출력하라.  
2. 포워딩 조건의 우선순위를 검증하라(가장 최신 결과부터).  
3. load-use 상황이 반드시 1사이클 스톨로 해결되는지 확인하라.  
4. 분기 misprediction 시 flush가 정확히 이루어지는지 점검하라.  
5. call/ret/push/pop의 RSP 변화와 메모리 읽기/쓰기가 정상인지 확인하라.  
6. 예외/invalid instruction 케이스에서 Stat(AOK/ADR/INS/HLT)가 올바르게 설정되는지 확인하라.  

---

## 14. 연습 과제 / 확장 주제

- **과제**: 기본 파이프라인에 2-bit 분기 예측기 추가하고, 벤치마크(분기 비율이 다른 코드)에서 CPI 향상을 측정하라.
- **과제**: 파이프라인에 로드-관련 포워딩(메모리→EX direct forwarding)을 통해 load-use 페널티를 줄이는 실험을 해보라(하드웨어가 허용할 경우).
- **확장**: 인오더 다중 이슈(superscalar) 또는 out-of-order(Tomasulo + ROB)로 확장해 보라 — 위험 관리와 register renaming 이슈를 다루게 됨.
- **확장**: 정밀 예외를 보장하는 커밋 스테이지(ROB)를 도입하고, 그 영향(복잡도/성능)을 분석하라.

---

## 마무리 요약

- **핵심 설계 요소**: 스테이지 분해(F, D, E, M, W), 파이프라인 레지스터 설계, 포워딩/해저드 검출, 분기 처리(예측/플러시), 예외(정밀성) 보장.  
- **가장 중요한 문제**: 데이터 해저드(RAW)와 제어 해저드(branch) — 포워딩으로 대부분 RAW 해결, load-use는 스톨 필요, 분기는 예측으로 페널티 최소화.  
- **검증 방법**: 사이클 단위 트레이스, 유닛 테스트(명령 카테고리별), 시각화(파이프라인 뷰)를 통해 각 스테이지 신호를 확인하라.
