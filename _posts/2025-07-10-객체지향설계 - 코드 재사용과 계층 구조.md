---
layout: post
title: 객체지향설계 - 코드 재사용과 계층 구조
date: 2025-07-10 22:20:23 +0900
category: 객체지향설계
---
# 코드 재사용과 계층 구조

## 0. 개요 — 무엇을 배우는가

- **코드 재사용의 스펙트럼**: 상속 기반 vs 상속 없는 재사용(합성·위임·제네릭·데코레이터 등)
- **계층 구조의 올바른 쓰임**: 일반화/특수화, 다형성, UI/도메인 모델에서의 기준
- **안티패턴과 대안**: fragile base class, 다이아몬드, yo-yo 문제, 합성/전략/어댑터
- **리팩토링·테스트·체크리스트**: DRY를 유지하면서 LSP와 계약을 깨지 않는 방법

---

## 1. 코드 재사용 (Code Reuse)

### 1.1 개념

코드 재사용은 **이미 검증된 로직을 반복 작성하지 않고 재활용**하여, **중복(DRY) 제거·유지보수 비용 절감·생산성 향상**을 얻는 행위다. 재사용은 크게 두 부류로 나뉜다.

| 재사용 축 | 메커니즘 | 핵심 아이디어 | 장점 | 주의 |
|---|---|---|---|---|
| **상속 기반** | 클래스 상속, 템플릿 메서드 | 상위 골격 + 하위 확장 | 일관된 골격, 다형성 | LSP/fragile base 위험 |
| **상속 없는 재사용** | **합성(composition)**, **위임(delegation)**, **제네릭/템플릿**, **믹스인/트레이트**, **확장 메서드**, **데코레이터** | 필요한 기능을 조립 | 낮은 결합, 교체 쉬움 | 설계/조립 비용 |

> 실무 원칙: **“상속보다 합성(Composition over Inheritance)”**을 기본값으로, **진짜 is-a**일 때만 상속을 선택한다.

---

### 1.2 예제: 동물 클래스 (기본 상속 재사용)

```java
// 부모
class Animal {
    void eat()  { System.out.println("먹고 있습니다."); }
    void sleep(){ System.out.println("자고 있습니다."); }
}
// 자식
class Dog extends Animal {
    void bark() { System.out.println("멍멍!"); }
}
```

- `Dog`는 `Animal`의 **행동을 자동 재사용**한다.  
- 상속이 타당하려면 **Dog is-a Animal**이 자연어/도메인 규약과 **LSP**를 만족해야 한다.

---

### 1.3 예제: 상속 대신 합성/위임으로 재사용

#### Before — 상속 남용
```java
class ReportExporter { void exportCsv(List<String> lines){ /* ... */ } }
class OrderExporter extends ReportExporter { /* exportCsv 사용 */ }
```

#### After — 합성(필요 기능만 주입)
```java
interface CsvWriter { void write(List<String> lines); }

class DefaultCsvWriter implements CsvWriter {
    public void write(List<String> lines){ /* ... */ }
}

class OrderExporter {
    private final CsvWriter csv;
    OrderExporter(CsvWriter csv){ this.csv = csv; }
    void export(List<String> lines){ csv.write(lines); }
}
```
- **장점**: `CsvWriter` 교체/테스트가 쉬움, 계층 얕음, 파급효과 감소(DIP).

---

### 1.4 재사용 기법 총정리(언어별)

| 기법 | Java/C# | C++ | Python/TS | 적합한 상황 |
|---|---|---|---|---|
| 상속 | `extends`/`:` | `: public Base` | 클래스 상속 | 진짜 is-a, 골격 고정 + 부분 확장 |
| 합성 | 필드로 보유 | 멤버로 보유 | 속성/필드 | 기능 조립/교체, 낮은 결합 |
| 위임 | 래핑 후 메서드 위임 | 래핑/forwarding | 데코레이터 패턴 | “OO에게 시켜라” Tell-Don’t-Ask |
| 제네릭/템플릿 | `List<T>` | `template<class T>` | `generic<T>`/TS | 알고리즘/컨테이너 재사용 |
| 믹스인/트레이트 | 인터페이스 default | 다중상속/CRTP | 믹스인 클래스 | 횡단기능 주입(로그/검사) |
| 확장 메서드 | C# `this` 확장 | ADL/프리함수 | prototype/모듈 | 외부 타입에 기능 추가 |
| 데코레이터 | 래퍼 클래스 | 템플릿 데코 | 데코레이터 문법 | 책임 추가, OCP 친화 |

---

## 2. 계층 구조 (Hierarchy)

### 2.1 개념과 목적

상속은 **일반화→특수화**의 **트리 구조**를 형성한다.  
상위는 **공통 규약/행동의 추상화**, 하위는 **특화 동작**을 제공한다.

```text
Vehicle
  ├─ Car
  └─ Bike
```

- **상위 클래스**: 공통 속성/행동(예: `move`)  
- **하위 클래스**: 특수 기능(예: `honk`, `pedal`)

### 2.2 예제: 탈것 계층

```java
class Vehicle {
    protected int speed;
    void move(){ System.out.println("움직입니다."); }
}

class Car extends Vehicle {
    void honk(){ System.out.println("빵빵!"); }
}

class Bike extends Vehicle {
    void pedal(){ System.out.println("페달을 밟습니다."); }
}
```

### 2.3 UML 표현(ASCII)

```text
           Animal
             ▲
     ┌───────┼────────┐
     │       │        │
    Dog     Cat     Tiger
```

> 다형성(polymorphism) 적용 시 **상위 타입 참조**로 다양한 하위를 일관되게 다룬다.

---

## 3. 상속 재사용의 장점과 주의

### 3.1 장점
- **중복 제거(DRY)**: 공통 로직 상위로 끌어올림
- **유지보수성**: 상위 수정이 하위에 자동 반영
- **다형성**: 상위 계약으로 하위 구현을 교체

### 3.2 주의점
- **LSP 위반**: 상위 계약을 하위가 깬다면 상속 부적합
- **fragile base class**: 상위 변경이 하위에 예기치 못한 파급
- **깊은 계층(yo-yo problem)**: 이해·디버깅 난이도 급증
- **다이아몬드 문제**(C++/파이썬 다중 상속): 모호성/중복 상태

---

## 4. LSP와 is-a 검증

상속 타당성의 핵심은 **LSP(리스코프 치환 원칙)**이다.

$$
\forall S \subseteq T,\ \text{모든 클라이언트에서 } T \text{를 } S \text{로 바꿔도 계약이 유지}
$$

- **전제조건 강화 금지**, **사후조건 약화 금지**, **불변식 유지**.

### 4.1 사각형-정사각형 역설(상속 부적합)
```java
class Rectangle { void setW(int w){} void setH(int h){} }
class Square extends Rectangle {
    @Override void setW(int w){ /* w=h */ }
    @Override void setH(int h){ /* w=h */ }
}
```
- `Rectangle` 계약(`w`,`h` 독립 설정)을 **Square**가 깨뜨림 → 상속 대신 **공통 인터페이스/합성**으로 바꿔야 한다.

---

## 5. 상속 vs 합성 — 나란히 비교

| 기준 | 상속(Inheritance) | 합성(Composition) |
|---|---|---|
| 관계 | is-a | has-a |
| 결합 | 높음(강결합) | 낮음(느슨한 결합) |
| 교체성 | 낮음 | 높음(전략 교체) |
| 재사용 | 전체 물려받음 | 필요한 기능만 조립 |
| 파급 | 상위 변경이 하위로 전파 | 내부 구성 교체로 격리 |

### 5.1 리팩토링 예: 상속 → 전략(합성)

#### Before
```java
class ImageProcessor { void savePng(byte[] d){ /*...*/ } }
class ReportImageProcessor extends ImageProcessor { /* ... */ }
```

#### After
```java
interface ImageSaver { void save(byte[] data); }
class PngSaver implements ImageSaver { public void save(byte[] d){ /*...*/ } }

class ReportImageProcessor {
    private final ImageSaver saver;
    ReportImageProcessor(ImageSaver saver){ this.saver = saver; }
    void export(byte[] d){ saver.save(d); }
}
```

---

## 6. 상속이 빛나는 곳: “골격 고정 + 일부 확장”

### 6.1 템플릿 메서드 패턴(상속 기반)
```java
abstract class DataExporter {
    public final void export(){ read(); transform(); write(); } // 골격 고정
    protected abstract void read();
    protected void transform(){ /* 기본 구현 */ }
    protected abstract void write();
}
class CsvExporter extends DataExporter { /* read/write만 특화 */ }
```
- **골격**은 상위에서 통제, 하위는 **후크**만 재정의.

### 6.2 UI 위젯 계층(일반적 is-a)
```text
Component
  ├─ Button
  ├─ TextField
  └─ Checkbox
```
- 공통 좌표/렌더/이벤트를 상위로, 외형·행동만 하위에서 특화.

---

## 7. 다중 상속 이슈와 우회

### 7.1 C++ 다중 상속 — 다이아몬드
```cpp
struct A { int x; };
struct B : virtual A {};
struct C : virtual A {};
struct D : B, C { void f(){ x = 1; } }; // virtual로 A가 하나로 공유
```

### 7.2 Java — 인터페이스 다중 구현 + default
```java
interface A { default void f(){ System.out.println("A"); } }
interface B { default void f(){ System.out.println("B"); } }
class C implements A, B {
    @Override public void f(){ A.super.f(); } // 명시적 선택
}
```

---

## 8. 상속 없는 재사용: 제네릭/템플릿·데코레이터·확장 메서드

### 8.1 제네릭/템플릿
```java
class Pair<T,U> { T first; U second; }
```
```cpp
template <class T> struct Box { T value; };
```
- 알고리즘/컨테이너의 **타입 독립 재사용**.

### 8.2 데코레이터(책임 추가)
```java
interface Notifier { void send(String msg); }
class EmailNotifier implements Notifier { public void send(String m){ /*...*/ } }
class SlackDecorator implements Notifier {
    private final Notifier inner;
    SlackDecorator(Notifier inner){ this.inner = inner; }
    public void send(String m){ inner.send(m); /* +Slack 전송 */ }
}
```

### 8.3 C# 확장 메서드
```csharp
public static class MoneyExtensions {
    public static bool IsPositive(this Money m) => m.Amount > 0;
}
```

---

## 9. 계층 구조의 모델링 규칙

1) **도메인 자연어 테스트**: “X는 Y이다(is-a)”가 어색하면 상속 금지  
2) **LSP 체크**: 상위 계약을 하위가 강화하지 않는가  
3) **얕고 넓게**: 깊이 2~3을 넘기지 않는다(yo-yo 방지)  
4) **sealed/final**: 확장 지점을 **명시적으로 통제**  
5) **공개 API에서 구현 누출 금지**: 내부 컬렉션/엔티티/프레임워크 타입 노출 금지

---

## 10. 수식: 변경 파급 비용의 직관 모델

계층 깊이 \(d\), 상위 클래스 변경 빈도 \(p\), 하위 수 \(n\), 결합 계수 \(c\)라 할 때,  
대략적 파급 비용은

$$
\mathrm{Impact} \approx p \cdot n \cdot c^{\,d}
$$

- **깊이(d)**와 **결합(c)**이 커질수록 **지수적**으로 위험이 커진다. → 계층은 얕게, 결합은 낮게.

---

## 11. 실전 시나리오

### 11.1 결제 모듈 — 상속 남용 → Port/Adapter(합성)

#### Before
```java
class PaymentService {
    void payByCard(int amount){ /*...*/ }
    void payByKakao(int amount){ /*...*/ }
    // 새 수단 추가 때마다 수정(OCP 위반)
}
```

#### After
```java
interface PaymentPort { void pay(int amount, String key); } // Port
final class KakaoAdapter implements PaymentPort { public void pay(int a, String k){ /*...*/ } }
final class CardAdapter  implements PaymentPort { public void pay(int a, String k){ /*...*/ } }

final class Checkout {
    private final PaymentPort payment;
    Checkout(PaymentPort payment){ this.payment = payment; }
    void confirm(int amount, String key){ payment.pay(amount, key); }
}
```
- **확장(새 결제수단)**은 어댑터 추가로 해결, 상위 정책 코드는 그대로.

---

## 12. 언어별 보완 요소

- **Java**: `abstract`/`final`/`sealed`로 확장 경계 명시, `module-info.java`로 내부 감춤  
- **C#**: `abstract`/`sealed`/`virtual`/`override`, 확장 메서드, 인터페이스 default 구현(.NET 8+)  
- **C++**: `virtual`/`override`/`final`, 가상 소멸자, **CRTP**로 정적 다형성(오버헤드 최소화)  
```cpp
// CRTP: 정적 다형성(런타임 비용 ↓)
template <typename D>
struct Drawable { void draw(){ static_cast<D*>(this)->drawImpl(); } };
struct Button : Drawable<Button> { void drawImpl(){ /* ... */ } };
```
- **Python**: 믹스인/다중 상속 가능하나, **박식 클래스** 남발 주의(역할 분리)

---

## 13. 테스트: 계약 & LSP 검증

### 13.1 상위 계약 테스트 공유
```java
abstract class AnimalContract<T extends Animal> {
    protected abstract T newSubject();
    @org.junit.jupiter.api.Test void speaksWithoutError(){ newSubject().speak(); }
}
final class DogTest extends AnimalContract<Dog> {
    protected Dog newSubject(){ return new Dog(); }
}
```

### 13.2 LSP 회귀 테스트
- 상위 타입 시나리오를 그대로 하위에 적용해 **예외/사후조건** 위반이 없는지 검증.

---

## 14. 리팩토링 레시피

1) **상속 제거 → 합성**: 상위 기능을 **협력 객체**로 추출해 주입  
2) **공통 로직 올리기 / 중복 제거**: 진짜 공통인지만 확인 후 상위로 이동  
3) **계층 얕게 만들기**: 중간 추상이 쓸모없는지 점검, 병합/삭제  
4) **인터페이스 분리(ISP)**: 비대한 상위 계약을 역할별로 분리  
5) **템플릿 메서드 ↔ 전략**: 골격 고정 필요 없으면 전략으로 치환

---

## 15. 성능·버전 호환·안전성

- **가상 호출 비용**: 현대 JIT/컴파일러가 대부분 최적화하지만, 핫패스에서는 **정적 다형성(제네릭/CRTP)** 고려  
- **직렬화/버전**: 상위의 필드/시그니처 변경은 하위·호환성에 영향 → **어댑터·deprecated 단계적 이행**  
- **스레드 안전**: 락/트랜잭션/멱등키는 내부로 **철저히 은닉**(외부에 동기화 수단 노출 금지)

---

## 16. 종합 코드 모음

### 16.1 상속이 적절한 경우(템플릿 메서드)
```java
abstract class Task {
    public final void run(){ pre(); work(); post(); }
    protected void pre(){ /* 공통 로깅 */ }
    protected abstract void work();
    protected void post(){ /* 공통 메트릭 */ }
}
final class BackupTask extends Task { protected void work(){ /* 백업 */ } }
```

### 16.2 합성/전략으로 재사용
```java
interface Compressor { byte[] compress(byte[] src); }
final class Gzip implements Compressor { public byte[] compress(byte[] s){ /*...*/ return s; } }
final class Archiver {
    private final Compressor c;
    Archiver(Compressor c){ this.c = c; }
    byte[] archive(byte[] s){ return c.compress(s); }
}
```

### 16.3 데코레이터로 책임 추가
```java
class LoggingCompressor implements Compressor {
    private final Compressor inner;
    LoggingCompressor(Compressor i){ this.inner = i; }
    public byte[] compress(byte[] s){
        long t=System.nanoTime();
        var r=inner.compress(s);
        System.out.println("took "+(System.nanoTime()-t));
        return r;
    }
}
```

---

## 17. 체크리스트

- [ ] **is-a**가 자연스럽고 **LSP**가 성립하는가?
- [ ] 계층이 **얕고 명확**한가(2~3 레벨 이내)?
- [ ] 상위 변경이 하위에 **파급**되지 않도록 **sealed/final**과 후크를 관리했는가?
- [ ] 재사용이 가능하면 **합성/전략/데코레이터**로 먼저 해결했는가?
- [ ] 공개 API에 내부 구현(컬렉션 구체 타입/엔티티)이 **누출**되지 않는가?
- [ ] 상위 계약 테스트를 **모든 하위**가 공유하여 통과하는가?
- [ ] 제네릭/템플릿/확장 메서드 등 **상속 없는 재사용**을 활용했는가?

---

## 18. 요약 표

| 항목 | 설명 |
|---|---|
| **코드 재사용** | 상속·합성·위임·제네릭·데코레이터·믹스인 등 다양한 방식으로 중복 제거 |
| **계층 구조** | 일반화/특수화 트리로 다형성·공통 정책을 조직화(얕고 명확하게) |
| **핵심 원칙** | is-a + LSP, DRY, OCP, DIP, ISP |
| **권장 전략** | **합성 우선**, 상속은 “골격 고정 + 일부 확장”에서만 |
| **주의** | 깊은 계층·fragile base·다이아몬드·구현 누출 |
| **실천** | 계약/LSP 테스트, sealed/final, 인터페이스 분리, 리팩토링 루틴 |

---

## 부록 A) 제공 예제 확장 — Animal/Vehicle

### A.1 Vehicle 계층 + 인터페이스 결합
```java
interface Honkable { void honk(); }
class Vehicle { void move(){ System.out.println("움직입니다."); } }
class Car extends Vehicle implements Honkable { public void honk(){ System.out.println("빵빵!"); } }
class Bike extends Vehicle { void pedal(){ System.out.println("페달을 밟습니다."); } }
```
- 공통은 상위, **선택적 행위**는 인터페이스로 분리(ISP).

### A.2 Animal — 합성으로 행동 교체
```java
interface Sound { void make(); }
class Bark implements Sound { public void make(){ System.out.println("멍멍!"); } }
class Meow implements Sound { public void make(){ System.out.println("야옹!"); } }

class Animal {
    private Sound sound;
    Animal(Sound s){ this.sound = s; }
    void speak(){ sound.make(); }
    void changeSound(Sound s){ this.sound = s; }
}
```
- 런타임에 행동 교체(전략). 상속 없이 재사용/확장.

---

## 부록 B) 간단 Q&A

- **Q. 언제 상속을 선택하나?**  
  A. 도메인 is-a가 명확하고, 상위가 **변치 않는 골격/계약**을 제공하며, 하위가 **후크만** 확장할 때.
- **Q. 언제 합성을 선택하나?**  
  A. 모듈 교체·테스트·점진적 확장이 중요할 때. 외부 시스템/정책과의 결합이 클 때.
- **Q. 깊은 계층을 얕게 만들려면?**  
  A. 공통 추상이 억지로 도출된 것은 아닌지 점검하고, 역할 인터페이스와 합성으로 **평탄화**한다.

---

이상으로, **코드 재사용과 계층 구조**를 상속에만 의존하지 않고 **합성·전략·데코레이터·제네릭** 등과 조합해 **얕고 강인한(robust) 구조**로 만드는 실전 지침을 정리했다.  
핵심은 간단하다: **진짜 is-a 에만 상속**, 그 외에는 **합성**을 우선하라. 그리고 **계약(LSP)**으로 그 선택이 옳았는지 테스트로 증명하라.