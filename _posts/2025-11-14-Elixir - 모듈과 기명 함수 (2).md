---
layout: post
title: Elixir - 모듈과 기명 함수 (2)
date: 2025-11-14 21:25:23 +0900
category: Elixir
---
# 가드, 기본 파라미터, 프라이빗 함수, 파이프 완전 정리

## 6.4 가드 조건절 (Guard Clauses)

가드는 **함수 헤드**(또는 `case`/`receive` 절)에서 **패턴 매칭 뒤**에 붙는 **추가 제약**이다.

```elixir
defmodule Shape do
  # "태그 + 구조"를 패턴으로, "값의 성질"을 가드로 분리
  def area({:rect, w, h}) when is_number(w) and is_number(h) and w >= 0 and h >= 0,
    do: w * h

  def area({:circle, r}) when is_number(r) and r > 0,
    do: :math.pi() * r * r

  def area(_),
    do: {:error, :bad_shape}
end
```

이 예제는 이후 설명의 “기본 템플릿” 역할을 한다:

- **패턴**: `{:rect, w, h}`, `{:circle, r}` 로 “형태/태그”를 검사
- **가드**: `is_number(w)`, `w >= 0` 등으로 “값의 성질”을 검사
- 어느 것도 맞지 않으면 마지막 절로 떨어져 `{:error, :bad_shape}` 반환

---

### 6.4.1 가드의 목적 — “계약을 조기에 거른다”

가드의 역할을 한 문장으로 요약하면:

> “**본문에 들어가기 전에** 입력이 계약을 만족하는지 **조기 검사**하는 장치”

다시 정리하면:

- **패턴**: 데이터의 **형태/태그 구조** 검사  
  - 예: 튜플인지, 맵에 특정 키가 있는지, 리스트의 머리/꼬리 구조 등
- **가드**: **타입/범위/간단 수치성질** 검사  
  - 예: 숫자인지, 0보다 큰지, 길이가 0보다 긴 바이너리인지 등

가드는 **본문 진입 이전**에 실행되어, 실패하면 **다음 클로즈**로 넘어간다.  
즉, 다음과 같은 흐름이다.

1. 패턴이 맞지 않으면 → **건너뜀**  
2. 패턴이 맞고, 가드가 `true` 이면 → **해당 절 실행**  
3. 패턴이 맞았지만, 가드가 `false` 이면 → **다음 절로 건너뜀**

이 흐름 덕분에 다음과 같은 스타일을 구현할 수 있다.

- “입력이 안 맞으면 **아래 절로 흘려 보내는**” **데이터 우선 스타일**
- 비즈니스 규칙을 **가드에 문장처럼 적어서** API 계약을 선언적으로 드러내기

예를 들어, 회원 등급/주문 금액에 따라 할인율을 정하는 코드를 가드로 표현하면:

```elixir
defmodule Discount do
  def rate(%{tier: :gold, amount: a}) when a >= 1000, do: 0.2
  def rate(%{tier: :gold}),                             do: 0.15
  def rate(%{tier: :silver}),                           do: 0.1
  def rate(%{tier: _}),                                 do: 0.0
  def rate(_),                                          do: 0.0
end
```

- **패턴**: 맵 구조, `tier` 키의 존재 여부  
- **가드**: `amount >= 1000` 같은 수치 조건  
- `login/1`, `signup/1` 같은 도메인 함수의 “룰북”을 이런 방식으로 표현하면,  
  테스트·리뷰 시 규칙이 한눈에 보인다.

---

### 6.4.2 가드에서 쓸 수 있는 것들(요지)

가드에는 **임의의 함수**를 넣을 수 없다. 오직 **“안전한” 함수들만 허용**된다.

- **타입/구조 판정**  
  - `is_atom/1`, `is_binary/1`, `is_bitstring/1`, `is_boolean/1`, `is_float/1`,  
    `is_function/1/2`, `is_integer/1`, `is_list/1`, `is_map/1`, `is_nil/1`,  
    `is_number/1`, `is_tuple/1` …
- **간단 수치/크기**  
  - `byte_size/1`, `bit_size/1`, `map_size/1`, `tuple_size/1`  
  - `abs/1`, `div/2`, `rem/2`, `round/1`, `trunc/1`
- **비교/부울/산술**  
  - `and` / `or` / `not`  
  - `in` (예: `n in 1..10`)  
  - `==` / `===` / `<` / `<=` / `>` / `>=`  
  - `+` / `-` / `*` / `/` (단, `is_number` 등으로 타입을 먼저 제한하는 것이 안전)

**주의사항:**

- 임의의 일반 함수 호출(예: `String.length(x)`),  
  예외 발생 가능성이 있는 연산, IO,  
  가드 내부에서 **새 패턴 매칭으로 변수 바인딩** 하는 것 등은 **불가**이다.
- 복잡한 검사는 **본문에서** 하라는 것이 원칙이다.

간단한 “허용/불가” 표로 정리하면 다음과 같다.

| 분류             | 예시                         | 가드에서 | 비고                 |
|------------------|------------------------------|----------|----------------------|
| 타입 판정        | `is_integer(x)`              | 가능     | 가장 자주 사용       |
| 크기/길이        | `byte_size(bin)`             | 가능     | 바이너리/문자열 길이 |
| 수치 연산        | `x * 2`, `rem(x, 3)`         | 가능     | 타입을 먼저 제한 권장 |
| 비교/부울        | `x > 0 and y <= 10`          | 가능     | 복합 논리식          |
| 범위 포함        | `n in 1..10`                 | 가능     | 정수 범위에 유용     |
| 임의 함수 호출   | `String.length(x)`           | 불가     | 본문에서 처리        |
| IO               | `IO.puts("x")`               | 불가     | 부수 효과 금지       |
| 패턴 매칭 대입   | `{:ok, v} = foo()`           | 불가     | 가드 안에서는 금지   |

> 실무 팁  
> “가드는 **빠르고, 순수하고, 예외 없이 끝날 수 있는 검사만** 허용된다” 정도로 기억하면 안정적이다.

---

### 6.4.3 `defguard/defguardp`로 재사용 가능한 가드 만들기

같은 조건식을 여러 함수의 가드에서 반복해서 쓰게 되면:

- 가독성이 떨어지고,
- 수정 시 모든 곳을 고쳐야 하고,
- 오타/불일치가 나기 쉽다.

이를 해결하기 위해 **가드 매크로**를 사용한다.

```elixir
defmodule Guards do
  import Kernel, except: [min: 2, max: 2] # 이름 충돌 회피 예시

  defguard is_pos_int(x) when is_integer(x) and x > 0
  defguard is_nonempty_bin(x) when is_binary(x) and byte_size(x) > 0
  defguardp in_range(x, lo, hi) when is_number(x) and x >= lo and x <= hi

  def clip(x, lo, hi)
      when in_range(lo, -1.0e9, 1.0e9) and in_range(hi, lo, 1.0e9) do
    cond do
      x < lo -> lo
      x > hi -> hi
      true   -> x
    end
  end
end
```

- `defguard`  
  - 모듈 밖에서도 사용할 수 있는 **공개 가드 매크로**.  
  - 예: `is_pos_int/1`, `is_nonempty_bin/1`
- `defguardp`  
  - 모듈 내부에서만 사용하는 **프라이빗 가드 매크로**.  
  - 예: `in_range/3`

이렇게 정의해 두면, 다른 모듈에서 다음처럼 쓸 수 있다.

```elixir
defmodule Score do
  import Guards, only: [is_pos_int: 1]

  def add_points(%{id: id, points: p}, delta)
      when is_pos_int(id) and is_integer(delta) do
    %{id: id, points: p + delta}
  end
end
```

장점:

- “ID는 양의 정수다”, “토큰은 길이>0인 바이너리다” 같은 규칙을 **이름 붙여** 관리할 수 있다.
- 동일한 규칙이 여러 API에 반복될 때, **가드 매크로 하나만 수정하면 전체에 반영**된다.

---

### 6.4.4 `case/with/receive`에서도 가드

가드는 함수 헤드뿐 아니라 `case`, `with`, `receive` 절에서도 사용된다.

```elixir
case data do
  %{age: a} when is_integer(a) and a >= 20 -> :adult
  %{age: a} when is_integer(a)             -> :minor
  _                                        -> :unknown
end
```

이 원리는 `receive` 에도 그대로 적용된다.

```elixir
receive do
  {:msg, from, payload} when is_pid(from) and byte_size(payload) > 0 ->
    handle_msg(from, payload)

  {:msg, _from, _} ->
    :ignore

  after 1000 ->
    :timeout
end
```

`with`에서도 마찬가지:

```elixir
with {:ok, %{age: a}} when a >= 20 <- fetch_user(id),
     {:ok, token}                  <- issue_token(id) do
  {:ok, token}
else
  {:error, :not_found} -> {:error, :no_user}
  _                    -> {:error, :bad_request}
end
```

여기서도 패턴/가드 역할은 동일하다.

- 패턴: “어떤 모양”의 값인지
- 가드: “그 값이 만족해야 할 수치/타입 조건”

---

### 6.4.5 가드에서의 핀(`^`)

핀 연산자는 **“이미 바인딩된 값을 패턴에서 고정”**하는 역할을 한다.  
가드와 함께 쓰면 다음과 같이 된다.

```elixir
def only_key(%{^key => v}) when is_atom(key), do: {:ok, v}
def only_key(_), do: :error
```

사용 예:

```elixir
iex> key = :name
:name
iex> only_key(%{name: "Kim", age: 20})
{:ok, "Kim"}
iex> only_key(%{age: 20})
:error
```

설명:

- `%{^key => v}`: “맵에 **현재 key 값에 해당하는 키**가 있을 때만 매칭”
- `when is_atom(key)`: key가 아톰인지 **추가로 필터링**

일반적인 실전 패턴:

- 특정 **동적 키**를 허용하면서, 동시에 **키 타입/범위**까지 제한하고 싶을 때
- 예: “요청 맵에서 특정 헤더 이름과 같은 키만 뽑기”, “환경 구성을 키 값에 따라 분기” 등

---

### 6.4.6 실전 패턴: 유효성 검사 파이프라인에서 가드 쓰기

가입/로그인 같은 API에서 가드의 역할은 특히 중요하다.

```elixir
defmodule Signup do
  def run(%{"email" => email, "age" => age} = params)
      when is_binary(email) and is_integer(age) and age >= 14 do
    params
    |> normalize()
    |> persist()
  end

  def run(_), do: {:error, :invalid_params}

  defp normalize(p), do: Map.update!(p, "email", &String.trim/1)
  defp persist(p),   do: {:ok, Map.put(p, :id, System.unique_integer([:positive]))}
end
```

- 첫 클로즈의 패턴/가드가 가입 로직의 **계약**을 명확히 보여준다.
- 실제 처리 로직은 `normalize/1`, `persist/1`에 위임되어 **관심사가 분리**된다.
- 테스트할 때도 “유효한 입력/무효한 입력” 케이스가 눈에 잘 들어온다.

---

### 6.4.7 가드 안티 패턴과 교정

1. **가드 안에서 복잡한 일을 하려는 경우**

   ```elixir
   # 나쁜 예
   def register(%{"email" => e} = p) when String.length(e) > 3 and valid?(p), do: ...
   ```

   - `String.length/1`, `valid?/1` 은 가드 허용 함수가 아니거나,  
     내부에서 예외/복잡한 로직을 수행할 수 있다.

   ```elixir
   # 교정
   def register(%{"email" => e} = p) when is_binary(e) do
     with true <- String.length(e) > 3,
          true <- valid?(p) do
       ...
     else
       _ -> {:error, :bad_params}
     end
   end
   ```

2. **가드에 너무 많은 조건을 몰아넣는 경우**

   - `when` 절이 3~4줄 이상으로 길어지면,  
     가독성이 오히려 떨어질 수 있다.
   - 이럴 땐 `defguard` 로 이름을 붙이거나,  
     조건 일부를 본문으로 내린다.

3. **“타입 검사를 전혀 하지 않는” 가드**

   - `when x > 0` 처럼 타입을 제한하지 않으면,  
     호출자가 실수로 문자열을 넘길 때 런타임 오류가 날 수 있다.
   - `when is_number(x) and x > 0` 으로 타입까지 함께 체크하는 것이 안전하다.

---

## 6.5 기본 파라미터 (Default Parameters)

**기본값 인자**는 컴파일 시 **별도의 함수 헤드**로 확장된다.  
따라서 멀티 클로즈와 섞일 때 **매칭 순서**가 헷갈리기 쉽다.

---

### 6.5.1 선언 분리 패턴(권장)

이미 본 것처럼, 가장 안전한 패턴은 **선언 분리**이다.

```elixir
defmodule Ping do
  # 1) 기본값은 "헤드 선언"에만
  def ping(url, timeout \\ 1000)

  # 2) 실제 로직은 완전한 헤드들로
  def ping(url, timeout) when is_binary(url) and is_integer(timeout),
    do: {:ok, {url, timeout}}

  def ping(_, _),
    do: {:error, :bad_arg}
end
```

장점:

- 컴파일 이후 어떤 헤드가 생성되는지 **예측 가능**하다.
- “유효한 인자” vs “유효하지 않은 인자” 가 한눈에 보인다.
- 기본값을 변경할 때도 **헤드 한 곳**만 수정하면 된다.

---

### 6.5.2 기본값과 패턴 매칭의 상호작용

기본값은 결국 **“호출자가 인자를 생략했을 때 대체할 값”**이다.

```elixir
defmodule Opts do
  def connect(host, opts \\ [])

  def connect(host, opts) when is_binary(host) and is_list(opts) do
    timeout = Keyword.get(opts, :timeout, 1000)
    {:ok, %{host: host, timeout: timeout}}
  end
end

Opts.connect("db")
# {:ok, %{host: "db", timeout: 1000}}

Opts.connect("db", timeout: 3000)
# {:ok, %{host: "db", timeout: 3000}}
```

여기서 핵심:

- **패턴은 구조**,  
- **기본값은 부재 시 대체**.

실무에서는 `opts \\ []` + `Keyword.get/3` 패턴이 많이 쓰인다.

---

### 6.5.3 키워드 인자 흉내 vs 명시적 옵션

엘릭서에는 파이썬 스타일의 “키워드 인자” 문법이 있는 것처럼 보이지만,  
실제로는 **마지막 인자가 키워드 리스트일 뿐**이다.

```elixir
connect("db", timeout: 3000, pool_size: 10)
# 내부적으로는
connect("db", [timeout: 3000, pool_size: 10])
```

장점:

- 새로운 옵션을 추가할 때 **기존 호출 코드를 깨지 않고** 확장할 수 있다.
- `Keyword.get/3`, `Keyword.put/3` 같은 함수들로 쉽게 다루기 가능.

단점/주의:

- 너무 많은 옵션을 한 함수에 몰아넣으면,  
  호출부에서 무엇을 넘기는지 파악하기 어렵다.
- API가 복잡해지면 **옵션 맵(예: `%Config{}` 구조체)** 로 승격시키는 것이 낫다.

---

### 6.5.4 기본값과 문서/타입 명세

기본값을 사용하면 **함수 사용법이 분기**될 수 있으므로,  
`@doc`, `@spec`에 명확히 적어 두는 것이 좋다.

```elixir
@spec fetch(url :: String.t(), opts :: keyword()) ::
        {:ok, binary()} | {:error, term()}
def fetch(url, opts \\ [])
```

`@doc` 예:

```elixir
@doc """
Fetches the content of the given URL.

옵션:

  * `:timeout` - 요청 타임아웃(ms). 기본값은 1000.
  * `:retries` - 재시도 횟수. 기본값은 0.
"""
```

이렇게 하면:

- `h Mod.fetch` 로 봤을 때 기본값/옵션이 한눈에 들어온다.
- 협업 시, 다른 사람이 **옵션 의미를 잘못 해석할 가능성**이 줄어든다.

---

### 6.5.5 기본값 안티 패턴

1. **여러 인자에 기본값을 잔뜩 붙이는 경우**

   ```elixir
   def send_mail(to, body \\ "", cc \\ [], bcc \\ [], opts \\ [])
   ```

   - 호출부에서 인자 하나만 지정하기 위해  
     `send_mail("a@a", "body", [], [], [])` 같은 코드를 쓰게 된다.
   - 이럴 때는 `opts` 하나만 기본값으로 두고,  
     나머지는 옵션으로 옮기는 것이 낫다.

2. **기본값이 복잡한 계산/IO를 포함하는 경우**

   ```elixir
   def connect(url, headers \\ default_headers())
   ```

   - `default_headers/0` 가 IO/랜덤/복잡한 계산을 수행하면,  
     **모든 호출에서 실행**된다.
   - 가능하다면 **상수/간단 값**만 기본값으로 쓰고,  
     복잡한 초기화는 별도의 함수로 분리하는 것이 좋다.

---

## 6.6 프라이빗 함수 (Private Functions)

`defp`로 선언하는 **모듈 내부 전용 함수**는 다음과 같은 역할을 한다.

- 외부 API의 **표면적을 최소화**하고,
- 내부 구현을 **작은 단계로 쪼개서** 재사용하며,
- 테스트를 **“공개 함수 기준 시나리오”** 위주로 유지하게 한다.

```elixir
defmodule Users do
  def signup(params) do
    params
    |> normalize()
    |> validate!()
    |> persist()
  end

  defp normalize(p),
    do: Map.update!(p, "email", &String.trim/1)

  defp validate!(%{"email" => e} = p) when e =~ ~r/@/,
    do: p

  defp validate!(_),
    do: raise ArgumentError, "bad email"

  defp persist(p),
    do: Map.put(p, :id, System.unique_integer([:positive]))
end
```

- **외부에는 `signup/1`만 노출**된다.
- 내부 단계 `normalize/1`, `validate!/1`, `persist/1` 는 언제든 **교체/리팩토링** 가능하다.

---

### 6.6.1 프라이빗 가드 매크로

프라이빗 함수와 마찬가지로,  
프라이빗 가드 매크로(`defguardp`)도 **모듈 내부 규칙**을 깔끔하게 정의할 수 있다.

```elixir
defmodule V do
  defguardp is_slug(s)
            when is_binary(s) and byte_size(s) in 1..64 and
                   s == String.downcase(s)

  def validate_slug(s) when is_slug(s), do: :ok
  def validate_slug(_), do: {:error, :bad}
end
```

- `is_slug/1` 은 외부에 노출할 필요가 없는 규칙이므로 `defguardp`.
- 규칙이 바뀌면 `defguardp` 하나만 수정하면 된다.

---

### 6.6.2 프라이빗과 테스트 전략

일반적인 테스트 전략:

- **공개 함수**를 중심으로 시나리오를 작성한다.  
  - 예: `Users.signup/1` 에 대해 다양한 입력 케이스 테스트
- 프라이빗 함수는 **공개 함수의 동작을 통해 간접적으로** 검증한다.

불가피하게 프라이빗을 직접 테스트하고 싶다면:

- 같은 모듈 안에 **테스트 전용 공개 함수**를 추가했다가,  
  릴리스 전에 제거하는 방식도 있을 수 있으나,
- 유지보수 측면에서 **공개 API 기준 테스트**가 훨씬 바람직하다.

---

### 6.6.3 프라이빗과 성능

`defp` 자체가 `def`보다 빠르거나 느리지는 않다.  
다만, “작고 순수한 내부 함수”로 분해해 두면:

- 컴파일러가 **인라이닝**을 하거나,
- JIT/VM 최적화에서 보다 유리하게 취급할 가능성이 있다.

하지만 실무에서는 “성능 때문에 `defp`를 쓴다”기보다는:

- **API 표면 최소화**  
- **구현 단계 명확화**  
- **리팩터링/테스트 용이성 향상**

같은 이유로 사용한다.

---

## 6.7 끝내주는 파이프 연산자: `|>`

파이프 연산자 `|>` 는 **왼쪽 값을 오른쪽 함수의 첫 번째 인자**로 전달한다.  

```elixir
"  Kim  "
|> String.trim()
|> String.downcase()
|> then(&"[#{&1}]")
```

- `then/2` 는 `Kernel.then/2` 이며,  
  중간 값을 받아 **임의 위치에 넣어 변형할 때** 유용하다.

---

### 6.7.1 기본 규칙

- `x |> f(a, b)` 는 **정확히** `f(x, a, b)` 로 변환된다.  
  항상 **첫 번째 인자**로 들어간다.
- 파이프 다음에는 **괄호를 명시**하는 것을 권장한다.

  ```elixir
  "  A  " |> String.trim |> String.downcase   # 동작하지만…
  "  A  " |> String.trim() |> String.downcase()  # 더 명확
  ```

  특히 매크로/캡처와 섞일 때 괄호를 생략하면 모호해질 수 있다.

---

### 6.7.2 “첫 인자”가 아닌 함수에 파이프하기

어떤 함수는 우리가 넘기고 싶은 인자가 **첫 번째가 아닐 수** 있다.  
예: `Integer.to_string(number, base)` 에서 `base` 를 고정하고 싶을 때.

```elixir
# Integer.to_string(number, base)
255 |> (fn n -> Integer.to_string(n, 16) end).()

# 혹은 then/2 사용
255 |> then(&Integer.to_string(&1, 16))
```

비슷하게, `Map.put(map, key, value)` 는 첫 인자가 맵이므로 파이프에 잘 맞지만,  
데이터가 두 번째/세 번째 인자에 오는 함수는 **익명 함수/then/2** 로 감싸면 표현력이 좋아진다.

---

### 6.7.3 `tap/2`로 중간 값 들여다보기(디버깅)

`Kernel.tap/2` 는 값을 그대로 반환하면서,  
두 번째 인자로 받은 함수에 값을 넘겨 주는 **디버깅/부수 효과용** 함수다.

```elixir
"  A  "
|> String.trim()
|> tap(&IO.inspect(&1, label: "after trim"))
|> String.duplicate(3)
```

- `tap/2` 안에서는 로그 출력, 카운터 증가 등 부수 효과를 수행할 수 있다.
- 파이프를 깨지 않고 중간 상태를 관찰하기에 좋다.

---

### 6.7.4 파이프 + 패턴/가드/with 조합

아래 예제는 “계정 생성” 흐름을 파이프와 함께 표현한 것이다.

```elixir
defmodule Accounts do
  def create(params) do
    params
    |> norm()
    |> with_email()
    |> save()
  end

  defp norm(p), do: Map.update!(p, "email", &String.trim/1)

  defp with_email(%{"email" => e} = p) when e =~ ~r/@/,
    do: {:ok, p}

  defp with_email(_),
    do: {:error, :bad_email}

  defp save({:ok, p}),
    do: {:ok, Map.put(p, :id, System.unique_integer([:positive]))}

  defp save(err),
    do: err
end
```

- `norm/1` 은 일반 값 변환 (`params` → `params'`)  
- `with_email/1`, `save/1` 은 **태그드 튜플**을 반환한다.
- 파이프는 **성공 흐름** 기준으로 읽힐 수 있다.  
  실패 시 `{ :error, ... }` 가 전달되어 마지막에서 그대로 반환된다.

조금 더 복잡한 경우에는 `with` 를 파이프 안에 넣는 것도 가능하다.  
다만, 이때는 “값 vs 태그드 튜플” 반환 형태가 섞이지 않도록 주의해야 한다.

---

### 6.7.5 컴프리헨션/익명 함수와의 미세 규칙

파이프 안에서 `Enum`, `Stream`, 컴프리헨션과 조합하는 패턴은 매우 흔하다.

```elixir
[1, 2, 3, 4, 5]
|> Enum.map(&(&1 * 2))
|> Enum.reject(&(rem(&1, 3) == 0))
|> Enum.take(2)
```

- 캡처/익명 함수를 사용할 때는 항상 괄호로 감싸는 게 좋다.
- 파이프를 너무 깊게 중첩하기보다, 의미 있는 단계를 프라이빗 함수로 쪼개는 것이 가독성에 이롭다.

---

### 6.7.6 안티 패턴과 교정

1. **너무 긴 파이프(10단계 이상)**

   - 한 함수에서 10단계 이상의 파이프가 이어지면,  
     “각 단계가 무슨 의미인지” 기억하기 어려워진다.

   ```elixir
   # 안 좋은 예
   data
   |> step1()
   |> step2()
   |> step3()
   |> step4()
   |> step5()
   |> step6()
   |> step7()
   ```

   → 의미 있는 묶음끼리 프라이빗 함수로 분리:

   ```elixir
   def run(data) do
     data
     |> parse()
     |> enrich()
     |> score()
     |> render()
   end
   ```

2. **데이터-라스트 API를 억지로 파이프에 넣는 경우**

   - 첫 인자가 우리가 파이프하고 싶은 데이터가 아니면,  
     억지로 `|>`를 쓰기보다는 **일반 호출/then/익명 함수**를 쓰는 것이 낫다.

3. **예외 기반 흐름과 파이프 섞기**

   - 파이프는 **값의 흐름**에 잘 맞는다.  
   - 예외가 자주 발생하는 API를 파이프 중간에 넣으면,  
     어디서 예외가 터지는지 추적하기 어렵다.  
   - 가능하면 **태그드 튜플 + with/파이프** 패턴으로 정리한다.

4. **큰 문자열을 계속 `<>`로 붙이는 경우**

   ```elixir
   # 나쁜 예
   ""
   |> Kernel.<>(header)
   |> Kernel.<>("\n")
   |> Kernel.<>(body)
   ```

   - 이런 경우에는 **iodata**로 모아서 마지막에 한 번에 바이너리로 변환하는 것이 낫다.

   ```elixir
   [header, "\n", body]
   |> :erlang.iolist_to_binary()
   ```

---

### 6.7.7 수학적 관점(합성)

파이프는 본질적으로 **함수 합성**의 읽기 친화 표기다.  

함수 \(h, g, f\) 에 대하여, 합성을 수식으로 쓰면:

$$
(f \circ g \circ h)(x) = f(g(h(x))).
$$

엘릭서에서는 이를 다음과 같이 쓴다.

```elixir
x
|> h()
|> g()
|> f()
```

즉,

$$
x \,|>\, h() \,|>\, g() \,|>\, f()
$$

는 수학적으로 \(f(g(h(x)))\) 와 같다.

- 차이점은 **읽는 방향**이다.  
  - 수학 표기: **오른쪽에서 왼쪽**으로 적용  
  - 파이프 표기: **위에서 아래, 왼쪽에서 오른쪽**으로 적용  
- 코드 리뷰·디버깅 관점에서 “데이터가 어떻게 변형되는지” 추적하기 훨씬 쉽다.

---

## 종합 실전: “텍스트 → 토큰 → 점수화 → 보고서” 파이프라인

마지막으로, 지금까지 다룬 개념(가드, 기본값, 프라이빗 함수, 파이프)을 모두 사용하는 **미니 NLP 파이프라인**을 살펴보자.

```elixir
defmodule NLP do
  @spec run(String.t(), keyword()) :: binary()
  def run(text, opts \\ []) do
    min_len = Keyword.get(opts, :min_len, 2)

    text
    |> normalize()
    |> tokenize(min_len)
    |> count()
    |> report()
  end

  defp normalize(t) when is_binary(t) do
    t
    |> String.downcase()
    |> String.replace(~r/[^a-z0-9\s]/, "")
  end

  defp normalize(_), do: ""

  defp tokenize(t, min_len) do
    t
    |> String.split(~r/\s+/, trim: true)
    |> Enum.filter(&(byte_size(&1) >= min_len))
  end

  defp count(tokens), do: Enum.frequencies(tokens)

  defp report(freq) do
    freq
    |> Enum.sort_by(fn {_k, v} -> -v end)
    |> Enum.map(fn {k, v} -> [k, ":", Integer.to_string(v), "\n"] end)
    |> :erlang.iolist_to_binary()
  end
end
```

사용 예:

```elixir
NLP.run("Hello, HELLO world!!! hello")
# 결과
# "hello:3\nworld:1\n"
```

여기에는 지금까지의 요소들이 모두 들어 있다.

- **가드/기본값**: `run/2` 의 `opts \\ []`, `normalize/1`의 가드
- **프라이빗 함수**: `normalize/1`, `tokenize/2`, `count/1`, `report/1`
- **파이프**: 전체 데이터 흐름을 `run/2` 에서 한 번에 표현
- **iodata**: `report/1` 에서 리스트로 조립 후 `iolist_to_binary/1` 로 최종 출력

간단한 테스트 스케치를 적어 보면:

```elixir
defmodule NLPTest do
  use ExUnit.Case, async: true

  test "basic counts" do
    out = NLP.run("Hello, HELLO world!!! hello")
    assert out =~ "hello:3"
    assert out =~ "world:1"
  end

  test "min_len option" do
    out = NLP.run("a aa aaa", min_len: 3)
    refute out =~ "a:1"
    refute out =~ "aa:1"
    assert out =~ "aaa:1"
  end
end
```

---

## 체크리스트 (6.4~6.7)

- [ ] 가드에는 **타입/범위/크기/간단 연산**만 — 복잡한 검사는 본문에서
- [ ] 자주 쓰는 조건은 `defguard/defguardp`로 이름을 붙여 재사용
- [ ] 멀티클로즈 + 기본값은 **선언 분리**로 헤드 순서를 고정
- [ ] 외부에 보여줄 API만 `def`, 나머지는 **`defp`로 숨김**
- [ ] 파이프는 **첫 인자 규칙**. 예외는 `then/2`·익명 함수로 보완
- [ ] 중간 관찰은 `tap/2`, 중간 변형은 `then/2`
- [ ] 문자열/바이너리 결합은 가능하면 **iodata → iolist_to_binary**로 마무리
- [ ] 반환 형태(값/태그드 튜플) 일관성 유지 — 파이프/with와 함께 쓸 때 특히 중요

---

## 마무리

- **6.4 가드**  
  - 패턴이 **형태/태그**를, 가드가 **값의 성질**을 검사한다.  
  - 복잡한 로직은 본문으로 내리고, 가드는 빠르고 안전한 검사만 수행한다.

- **6.5 기본 파라미터**  
  - 기본값 인자는 컴파일 시 **별도 함수 헤드**로 확장된다.  
  - 멀티 클로즈와 섞일 때는 **선언 분리 패턴**으로 헤드 순서를 명확히 해야 한다.

- **6.6 프라이빗 함수**  
  - 모듈 외부 API를 단순하게 유지하고,  
    내부 구현은 `defp`로 잘게 쪼갠 함수들로 조합한다.  
  - 테스트는 공개 함수 기준으로 시나리오를 구성하는 것이 리팩터링에 유리하다.

- **6.7 파이프 연산자 `|>`**  
  - 데이터 흐름을 코드에 그대로 그려 넣는 도구다.  
  - `tap/2`, `then/2`와 함께 쓰면 중간 관찰/변형이 자연스럽고,  
    **합성(파이프)** 관점에서 코드를 읽을 수 있다.

결국, 이 장에서 반복해서 강조하는 것은 다음 한 줄이다.

> **함수 헤드(패턴+가드) = 입력 계약, 본문 블록 = 값 조립, 파이프 = 값의 흐름.**

이 관점을 유지하면 코드가 **짧고 안전**해지고,  
동시성·테스트·유지보수에서 **예측 가능한 시스템**을 만들 수 있다.