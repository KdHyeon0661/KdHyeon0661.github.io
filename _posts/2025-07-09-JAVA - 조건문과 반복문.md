---
layout: post
title: Java - 조건문과 반복문
date: 2025-07-09 21:20:23 +0900
category: Java
---
# Java 조건문과 반복문

## 0. 개요: 분기와 반복을 고르는 기준

| 상황 | 추천 구문 | 이유/비고 |
|---|---|---|
| 조건 수가 적고, 복잡한 가드(부가 조건)가 있음 | `if/else if/else` | 가독성, 세밀한 조건 구성 |
| 단일 “키값”을 다수 분기(열거형/문자열/정수) | `switch` 문/표현식 | 분기 테이블화, 컴파일러 최적화 가능 |
| 반복 횟수가 명확 | `for` | 카운터·증감이 본문 밖에 모여 가독성↑ |
| 조건 기반 반복(선검사) | `while` | 조건이 거짓이면 0회 실행 |
| 무조건 1회 이상 실행(후검사) | `do-while` | 입력 검증·메뉴 루프 |
| 컬렉션/배열의 요소 순회 | 향상된 `for` | 인덱스 불필요·간결 |
| 요소 삭제/변경하며 순회 | `Iterator`/`ListIterator` | `ConcurrentModificationException` 회피 |

---

## 1. 조건문

### 1.1 `if / else if / else`

**기본 구조**

```java
if (조건식) {
    // true일 때
} else if (다른조건) {
    // 위가 false이고 여기 true일 때
} else {
    // 모든 조건이 false
}
```

**예제: 점수 → 등급**

```java
int score = 85;

if (score >= 90) {
    System.out.println("A 학점");
} else if (score >= 80) {
    System.out.println("B 학점");
} else {
    System.out.println("C 학점 이하");
}
```

**주의/팁**
- Java에는 **truthy/falsy 개념이 없음** → 조건은 반드시 **`boolean`**.
- 복합 조건은 **단축 평가**(`&&`, `||`)로 안전하게 작성:
  ```java
  String s = null;
  if (s != null && s.length() > 0) { /* 안전 */ }
  ```

---

### 1.2 `switch` 문 (statement) — 전통 형태

**기본 구조**

```java
switch (key) {
    case 값1:
        // ...
        break;           // 다음 case로의 낙하(fall-through) 방지
    case 값2:
        // ...
        break;
    default:
        // 어떤 case에도 해당하지 않을 때
}
```

**예제**

```java
int day = 3;

switch (day) {
    case 1:
        System.out.println("월요일");
        break;
    case 2:
        System.out.println("화요일");
        break;
    case 3:
        System.out.println("수요일");
        break;
    default:
        System.out.println("알 수 없음");
}
```

**키 타입**
- `int`/`char`/`short`/`byte`, **열거형(enum)**(Java 5+), **`String`**(Java 7+) 가능.
- `null`은 **NPE**(문/표현식 동일). `switch` 전에 미리 null 가드 필요.

**의도적 낙하(fall-through)**
```java
int m = 3;
switch (m) {
    case 1:
    case 2:
    case 3:
        System.out.println("1~3");
        break;
    default:
        System.out.println("기타");
}
```
- 의도적이라면 `/* fall-through */` 주석으로 의사 표기 권장.

---

### 1.3 `switch` **표현식** (Java 14+)

- `switch`가 **값을 산출**하며, **`->`** 화살표 문법을 사용.
- 각 분기는 **break 필요 없음**. **블록 `{}`** 사용 시 **`yield`**로 값 반환.

```java
int day = 3;

String label = switch (day) {
    case 1 -> "월요일";
    case 2 -> "화요일";
    case 3 -> "수요일";
    case 4, 5 -> "목/금";          // 여러 라벨
    default -> "주말 또는 알 수 없음";
};

System.out.println(label);
```

**복잡 로직은 `yield`**

```java
String grade = "B";

int point = switch (grade) {
    case "A" -> 5;
    case "B" -> { 
        int base = 3;
        yield base + 1; // 4
    }
    default -> 0;
};
```

---

### 1.4 `switch`의 **패턴 매칭** (Java 21+, JEP 441)

- `instanceof`의 확장으로 **타입 + 가드**를 분기에서 사용.
- **문/표현식** 모두 가능. `null` 대응 분기도 명시 가능.

```java
static String stringify(Object o) {
    return switch (o) {
        case null -> "null";
        case Integer i when i >= 0 -> "int+" + i;    // 가드(when)
        case Integer i -> "int-" + i;
        case String s when s.length() > 10 -> "long string";
        case String s -> "string '" + s + "'";
        default -> "other " + o.getClass().getSimpleName();
    };
}
```

---

## 2. 반복문

### 2.1 `for` (전통적 카운터 루프)

**기본 구조**

```java
for (초기식; 조건식; 증감식) {
    // 반복할 코드
}
```

**예제**

```java
for (int i = 0; i < 5; i++) {
    System.out.println("i = " + i);
}
```

**여러 카운터/증감**

```java
for (int i = 0, j = 10; i < j; i++, j--) {
    // i 증가, j 감소
}
```

**무한 루프**
```java
for (;;) { /* break로 탈출 */ }
```

---

### 2.2 향상된 `for` (for-each)

- 배열/컬렉션 **읽기 순회**에 간결.
- **인덱스가 필요하거나 요소 삭제/치환이 필요하면 부적합**.

```java
int[] numbers = {1, 2, 3, 4, 5};
for (int n : numbers) {
    System.out.println(n);
}
```

**삭제가 필요할 때(안전 패턴)**

```java
import java.util.*;

List<String> list = new ArrayList<>(List.of("a", "b", "c"));
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    if (it.next().equals("b")) it.remove(); // 안전
}
// for-each에서 list.remove(...)는 보통 ConcurrentModificationException
```

**양방향/치환은 `ListIterator`**

```java
List<Integer> xs = new ArrayList<>(List.of(1,2,3));
ListIterator<Integer> li = xs.listIterator();
while (li.hasNext()) {
    int v = li.next();
    li.set(v * 2); // 자리 치환
}
```

---

### 2.3 `while` — 선검사 루프

- 조건이 **처음부터 false면 0회** 실행.

```java
int i = 0;
while (i < 5) {
    System.out.println(i);
    i++;
}
```

**입력(센티넬) 루프 예시**

```java
import java.util.*;

Scanner sc = new Scanner(System.in);
while (true) {
    String line = sc.nextLine();
    if (line == null || line.equals("quit")) break;
    System.out.println(">" + line);
}
```

---

### 2.4 `do-while` — 후검사 루프

- **최소 1회** 실행이 필요할 때.

```java
int i = 0;
do {
    System.out.println("i = " + i);
    i++;
} while (i < 5);
```

**메뉴 루프**

```java
int sel;
do {
    System.out.println("1) 시작 2) 종료");
    sel = System.in.read(); // 예시용(실전은 Scanner 권장)
} while (sel != '2');
```

---

## 3. 반복 제어 키워드와 라벨 문

### 3.1 `break` / `continue`

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) break;      // 루프 즉시 종료
    if (i % 2 == 0) continue; // 짝수 건너뛰기
    System.out.println(i);  // 홀수만
}
```

### 3.2 라벨 문(labeled break/continue)

- **중첩 루프**에서 바깥 루프를 제어.

```java
outer:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == j) continue outer; // 바깥 for의 다음 반복
        if (i + j > 3) break outer; // 바깥 for 종료
        System.out.println(i + "," + j);
    }
}
```

---

## 4. 안전하고 빠른 순회 — 실전 팁

1) **배열**: 인덱스 순회가 빠르고 박싱이 없음. 경계는 `length` 사용.  
2) **List**: **for-each**가 간결. **삭제/치환**은 `Iterator`/`ListIterator`.  
3) **Map**: `entrySet()`으로 키·값 동시에 접근.
   ```java
   for (var e : map.entrySet()) {
       System.out.println(e.getKey() + "=" + e.getValue());
   }
   ```
4) **ConcurrentModificationException** 방지:  
   - 순회 중 구조 변경 금지, 또는 `Iterator.remove()` 사용.  
   - 동시성 컬렉션(`ConcurrentHashMap` 등) 고려.
5) **try-with-resources**는 루프 내부 자원 해제 타이밍 주의:
   ```java
   for (Path p : files) {
       try (var in = Files.newBufferedReader(p)) {
           // 처리
       } // 여기서 즉시 닫힘
   }
   ```

---

## 5. 스트림 vs 전통 반복문의 비교(언제 무엇을?)

| 기준 | 스트림 API | 전통 반복문 |
|---|---|---|
| 가독성(선언적) | 복잡한 필터/맵/집계를 간결하게 | 복잡 로직/분기엔 다소 장황 |
| 성능 | 원시 스트림 사용 시 박싱 회피 가능. 병렬 스트림은 **데이터 크기·분할 비용**에 따라 | 간단 루프는 오버헤드 낮음 |
| 예외 처리 | 람다에서 체크 예외 불편 | `try-catch` 유연 |
| 상태/부작용 | 가급적 순수 함수 권장 | 상태ful 로직에 유리 |

> 성능과 가독성은 **데이터 크기, 작업량, JIT 최적화**에 따라 달라집니다. 둘 다 숙지하고 **상황에 맞게 선택**하세요.

---

## 6. 복잡도와 루프 불변식(검증 관점)

### 6.1 반복의 시간 복잡도(평균적 관점)

- 단일 루프: $$O(n)$$  
- 중첩 2중 루프: $$O(n^2)$$  
- 이진 탐색 루프: $$O(\log n)$$

### 6.2 루프 불변식(loop invariant)의 예

합계 루프

```java
int sum = 0;
for (int i = 0; i < n; i++) {
    sum += a[i];
}
```

**불변식**: 반복이 `k`회 끝났을 때  
$$
\text{sum} = \sum_{i=0}^{k-1} a[i]
$$

- **초기 성립**: `k=0`일 때 `sum=0`.  
- **유지**: 한 스텝에서 `a[k]`를 더하면 식이 유지.  
- **종료**: `k=n`에서 `sum = \sum_{i=0}^{n-1} a[i]` 성립.

> 불변식을 의식하면 **오프바이원**·**경계 조건** 실수를 줄입니다.

---

## 7. 자주 하는 실수/함정 모음

| 주제 | 잘못된 예 | 올바른/설명 |
|---|---|---|
| if 조건 | `if (x = 1) {...}` | Java는 대입을 boolean으로 허용하지 않음(컴파일 오류). 비교는 `==` |
| switch null | `switch(str)` | `str`이 `null`이면 NPE. 미리 null 가드 |
| switch break | `case 1: f(); case 2: g();` | `break` 없으면 낙하. 의도적이면 주석 |
| for-each 삭제 | `for (E e: list) list.remove(e);` | `Iterator.remove()` 사용 |
| 무한 루프 | `while (true) {...}` | 반드시 **탈출 조건**/`break` 필요 |
| 부동소수 비교 | `if (a+b == c)` | $$|a+b-c| < \varepsilon$$ 로 비교 |
| 증감 부작용 | `a[i] = i++` | 평가 순서 인지(좌→우). 가독성 위해 분리 |
| off-by-one | `i <= n` | 범위가 `0..n-1`라면 `i < n` |

---

## 8. 실전 예제 모음

### 8.1 점수 분포 집계(중첩 루프·라벨 탈출)

```java
public class Histogram {
    public static void main(String[] args) {
        int[] scores = {92, 87, 75, 75, 60, 100, 89, 73, 81};
        int[] bins = new int[11]; // 0,10,20,...,100

        for (int s : scores) {
            int b = Math.min(s / 10, 10);
            bins[b]++;
        }

        // 출력
        for (int i = 0; i < bins.length; i++) {
            System.out.printf("%3d-%3d: %d%n", i*10, i==10?100:i*10+9, bins[i]);
        }
    }
}
```

### 8.2 메뉴 루프(`do-while` + `switch` 표현식)

```java
import java.util.Scanner;

public class Menu {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int sel;
        do {
            System.out.println("1)로그인 2)목록 3)종료");
            sel = Integer.parseInt(sc.nextLine());

            String msg = switch (sel) {
                case 1 -> "로그인 처리";
                case 2 -> "목록 표시";
                case 3 -> "종료";
                default -> "잘못된 선택";
            };
            System.out.println(msg);
        } while (sel != 3);
    }
}
```

### 8.3 패턴 매칭 `switch`로 메시지 라우팅

```java
sealed interface Msg permits Text, Image, Ping {}
record Text(String body) implements Msg {}
record Image(byte[] bytes) implements Msg {}
record Ping() implements Msg {}

public class Router {
    static String handle(Msg m) {
        return switch (m) {
            case Text t  -> "TEXT:" + t.body();
            case Image i -> "IMAGE:" + i.bytes().length + "B";
            case Ping p  -> "PONG";
        };
    }
    public static void main(String[] args) {
        System.out.println(handle(new Text("hi")));
    }
}
```

### 8.4 입력 스트림 라인 처리(센티넬 `null`/빈줄 종료)

```java
import java.io.*;
import java.nio.charset.StandardCharsets;

public class ReadLines {
    public static void main(String[] args) throws Exception {
        try (var br = new BufferedReader(
                new InputStreamReader(System.in, StandardCharsets.UTF_8))) {
            String line;
            while ((line = br.readLine()) != null && !line.isBlank()) {
                System.out.println("> " + line.strip());
            }
        }
    }
}
```

### 8.5 안전 삭제 순회(Iterator)

```java
import java.util.*;

public class SafeRemove {
    public static void main(String[] args) {
        List<Integer> xs = new ArrayList<>(List.of(1,2,3,4,5,6));
        Iterator<Integer> it = xs.iterator();
        while (it.hasNext()) {
            if (it.next() % 2 == 0) it.remove();
        }
        System.out.println(xs); // [1,3,5]
    }
}
```

---

## 9. 요약 표

| 문장 | 핵심 용도 | 특징/주의 |
|---|---|---|
| `if/else` | 자유로운 조건 분기 | 가드 조건, 단축 평가 |
| `switch` 문 | 다중 분기(열거형/문자열 등) | `break` 필요, `null` NPE |
| `switch` 표현식 | 분기 결과 **값 산출** | `->`, `yield` |
| `switch` 패턴 매칭 | 타입·가드 기반 분기 | Java 21+, `when` 가드 |
| `for` | 횟수 명확 | 카운터, 무한 루프 `for(;;)` |
| 향상된 `for` | 읽기 순회 | 삭제/치환 불가 → Iterator |
| `while` | 선검사 반복 | 0회 가능, 센티넬 루프 |
| `do-while` | 후검사 반복 | 최소 1회 실행 |
| `break/continue` | 반복 제어 | 라벨로 중첩 제어 가능 |

---

## 10. 한 줄 결론

> **분기**는 `if`와 `switch`(표현식/패턴 매칭)로 **명료하게**, **반복**은 상황에 맞게 `for/while/do-while/for-each`를 선택하고, **안전한 수정은 Iterator**로.  
> **단축 평가·경계 조건·불변식**을 습관화하면 버그와 복잡도를 크게 줄일 수 있습니다.