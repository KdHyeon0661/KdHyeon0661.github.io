---
layout: post
title: C# - 인터페이스와 다형성, 타입 검사
date: 2024-10-14 19:20:23 +0900
category: Csharp
---
# C# 인터페이스와 다형성, 타입 검사 (is/as/typeof)

## 0. 큰 그림 — 왜 인터페이스인가?

- **역할(Contract)** 를 분리해 **구현체 교체**와 **테스트 용이성**을 확보  
- **다형성(Polymorphism)** 으로 호출자가 구현 세부를 몰라도 **일관된 사용성** 제공  
- 런타임/컴파일 타임의 **타입 검사**(`is`, 패턴 매칭)와 **안전 변환**(`as`)으로 **안정성** 강화

> 요약: “**계약 우선 설계** → 테스트/유지보수/확장 모두 쉬워진다.”

---

## 1. 인터페이스 기초 — 선언/구현/다형성

### 1.1 선언

```csharp
interface IAnimal
{
    void Speak();
}
```

- 인터페이스 멤버는 **암묵적으로 public** (접근 제한자 명시 불가; 명시하더라도 public 취급).

### 1.2 구현 & 다형성 호출

```csharp
class Dog : IAnimal
{
    public void Speak() => Console.WriteLine("멍멍");
}

class Cat : IAnimal
{
    public void Speak() => Console.WriteLine("야옹");
}

// 다형성
IAnimal a1 = new Dog();
IAnimal a2 = new Cat();
a1.Speak(); // 멍멍
a2.Speak(); // 야옹
```

### 1.3 다중 인터페이스 상속

```csharp
interface IRunnable { void Run(); }
interface IWalker   { void Walk(); }

class Robot : IRunnable, IWalker
{
    public void Run()  => Console.WriteLine("달린다");
    public void Walk() => Console.WriteLine("걷는다");
}
```

- **클래스는 단일 상속**, **인터페이스는 다중 상속** 가능.

---

## 2. 캡슐화 심화 — 명시적 인터페이스 구현(Explicit)

**목적**:  
- 멤버 이름 충돌 해결  
- 인터페이스 멤버를 **클래스의 일반 API에서 숨김**(인터페이스로 캐스팅해야 접근)

```csharp
interface ILogger { void Log(string msg); }

class DualLogger : ILogger
{
    public void LogPublic(string msg) => Console.WriteLine("[PUB] " + msg);

    // 명시적 구현 — 객체를 ILogger로 볼 때만 노출
    void ILogger.Log(string msg) => Console.WriteLine("[IFC] " + msg);
}

var d = new DualLogger();
d.LogPublic("hi");             // OK
// d.Log("x");                 // ❌ 보이지 않음
((ILogger)d).Log("x");         // OK
```

- 프레임워크 어댑터, 레거시 호환 등에 자주 사용.

---

## 3. C# 8+ 디폴트 인터페이스 멤버(기본 구현)

> 인터페이스에도 **기본 구현**을 둘 수 있습니다(C# 8+). 버전 호환성 증가/믹스인 스타일 가능.

```csharp
public interface IClock
{
    DateTime Now { get; }
    string FormatNow(string fmt = "O") => Now.ToString(fmt); // 기본 구현
}

public class SystemClock : IClock
{
    public DateTime Now => DateTime.UtcNow; // 기본 구현 그대로 사용 가능
}
```

- **주의**: 다이아몬드 문제/해석 우선순위가 복잡해질 수 있으므로 **남용 금지**.  
- 공용 API보다는 **내부 프레임워크/라이브러리**에서 점진 진화용으로 유용.

---

## 4. 제네릭 + 인터페이스 — 제약과 수학적 계약

### 4.1 제네릭 제약

```csharp
interface IEntity { string Id { get; } }

class Repo<T> where T : IEntity
{
    public void Save(T e) => Console.WriteLine($"save {e.Id}");
}
```

- 컴파일러가 **계약 충족을 보장** → 호출부와 구현부 모두 **형 안전**.

### 4.2 C# 11+ **정적 추상 멤버**(Generic Math 등)

```csharp
public interface INumeric<TSelf> where TSelf : INumeric<TSelf>
{
    static abstract TSelf operator +(TSelf a, TSelf b);
    static abstract TSelf Zero { get; }
}

public readonly struct MyInt(int v) : INumeric<MyInt>
{
    public int V { get; } = v;
    public static MyInt operator +(MyInt a, MyInt b) => new(a.V + b.V);
    public static MyInt Zero => new(0);
}
```

- **인터페이스에 정적 추상 멤버** → 제네릭 알고리즘에서 산술 연산/상수 등을 **추상화** 가능.

---

## 5. 공변/반공변(Variance) — 컬렉션/델리게이트에서의 다형성

- **`out` 공변**: `IEnumerable<out T>` → `IEnumerable<string>`는 `IEnumerable<object>`로 **치환 가능**  
- **`in` 반공변**: `IComparer<in T>` → `IComparer<object>`는 `IComparer<string>`로 **치환 가능**

```csharp
IEnumerable<string> ss = new[] { "a", "b" };
IEnumerable<object> os = ss; // 공변(out) OK

IComparer<object> cmpObj = Comparer<object>.Default;
IComparer<string> cmpStr = cmpObj; // 반공변(in) OK
```

> 잘못된 치환으로 **런타임 예외**가 나는 배열 공변성과 달리, 인터페이스 공변/반공변은 **타입 안전**.

---

## 6. 타입 검사 — `is` / 패턴 매칭 / `as` / `typeof` / `GetType`

### 6.1 `is` 기본형

```csharp
object obj = new Dog();

if (obj is Dog) { /* ... */ } // true: Dog 또는 파생형이면 참
```

### 6.2 패턴 매칭 — 변수 추출/가드 조건

```csharp
object o = new Cat();
if (o is IAnimal a) // 캐스팅 + 변수 바인딩 동시
{
    a.Speak();
}

if (o is Cat c && c is not null)
{
    // 추가 조건도 함께
}
```

#### `switch` 표현식과 패턴들

```csharp
string Describe(IAnimal a) => a switch
{
    Dog { } => "개",
    Cat { } => "고양이",
    null    => "없음",
    _       => "기타"
};
```

- 타입 패턴, 속성 패턴, 리스트/슬라이스 패턴(C# 11/12)까지 지원.

### 6.3 `as` — **예외 없이** 참조형 변환

```csharp
object obj = new Dog();

Dog? dog = obj as Dog; // 실패시 null
if (dog != null) dog.Speak();
```

- **참조형/nullable 참조형**에 주로 사용. 값형 변환은 `as` 미지원(박싱된 값을 as로 언박싱은 가능하나 실패 시 null).  
- 널 처리와 함께 쓰며 **예외 비용 회피**에 유용.

### 6.4 `typeof` vs `GetType()` — 타입 메타데이터

```csharp
Type t1 = typeof(string);          // 컴파일 타임에 아는 타입
Type t2 = "hi".GetType();          // 런타임 인스턴스의 정확 타입
Console.WriteLine(t1 == t2);       // True
```

- **정확 타입 비교**는 `obj.GetType() == typeof(SomeType)`  
- **상속 포함 검사**는 `obj is SomeType`

```csharp
object a = new Dog();
bool b1 = a.GetType() == typeof(Animal); // false (정확히 Animal이 아님)
bool b2 = a is Animal;                   // true (상속 포함)
```

> 선택 기준: **정확 타입**이면 `GetType()==typeof`, **상속/구현 포함**이면 `is`.

### 6.5 `nameof`(보조)와 결합

```csharp
void Save(IAnimal animal)
{
    if (animal is not Dog)
        throw new NotSupportedException($"{nameof(Dog)}만 저장 가능");
}
```

---

## 7. is/as/typeof — 사용 가이드/비교표

| 키워드 | 역할 | 문법 특징 | 권장 사용 |
|---|---|---|---|
| `is` | 타입 확인 | `obj is T`, `obj is T v`, 패턴 | 상속 포함 검사, 패턴 매칭과 함께 |
| `as` | 안전 캐스팅 | 실패 시 `null` | 참조형 변환 + 널 체크로 예외 없이 |
| `typeof` | 타입 객체 | `typeof(T)` | 리플렉션/속성/메타데이터 비교 |
| `GetType()` | 정확 타입 | 인스턴스 메서드 | 정확 타입 비교/로깅/리플렉션 |

---

## 8. 인터페이스 vs 추상 클래스 — 2025 버전 비교

| 항목 | 인터페이스 | 추상 클래스 |
|---|---|---|
| 목적 | **역할** 정의(계약) | **공통 기반 + 일부 구현** 제공 |
| 다중 상속 | **가능** | **불가** |
| 상태(필드) | 없음 | 가질 수 있음 |
| 구현 | C# 8+ 기본 구현 **가능**(주의) | 일반 구현 가능 |
| 정적 추상 멤버 | **가능**(C# 11+) | N/A |
| 생성자 | 없음 | 가능 |
| 인스턴스화 | 불가 | 불가 |

> **계약 강조/교체 용이**: 인터페이스. **공통 코드/상태 공유**: 추상 클래스.

---

## 9. 실전 패턴 6선

### 9.1 전략(Strategy) — 인터페이스로 알고리즘 교체

```csharp
interface IShippingFee { decimal Calc(decimal weightKg); }

class FlatFee : IShippingFee  { public decimal Calc(decimal w) => 5m; }
class WeightFee : IShippingFee { public decimal Calc(decimal w) => 2m + w * 1.2m; }

class Checkout
{
    private readonly IShippingFee _fee;
    public Checkout(IShippingFee fee) => _fee = fee;
    public decimal Total(decimal price, decimal weight) => price + _fee.Calc(weight);
}
```

### 9.2 어댑터(Adapter) — 레거시 포장

```csharp
class LegacyLogger { public void WriteLine(string s) => Console.WriteLine(s); }

interface ILogger { void Log(string msg); }

class LoggerAdapter : ILogger
{
    private readonly LegacyLogger _inner;
    public LoggerAdapter(LegacyLogger inner) => _inner = inner;
    public void Log(string msg) => _inner.WriteLine("[LOG] " + msg);
}
```

### 9.3 데코레이터(Decorator) — 기능 합성

```csharp
class TimingLogger : ILogger
{
    private readonly ILogger _next;
    public TimingLogger(ILogger next) => _next = next;
    public void Log(string msg) => _next.Log($"[{DateTime.UtcNow:O}] {msg}");
}
```

### 9.4 리포지터리 + 제약

```csharp
interface IEntity { string Id { get; } }

interface IRepository<T> where T : IEntity
{
    void Save(T e);
    T? Find(string id);
}
```

### 9.5 명시적 구현으로 API 표면 축소

```csharp
interface IInternalOp { void Do(); }

public class Facade : IInternalOp
{
    void IInternalOp.Do() { /* ... 내부 전용 ... */ }
    public void Run() => ((IInternalOp)this).Do();
}
```

### 9.6 인터페이스 + 기본 구현(옵셔널 훅)

```csharp
interface IParser
{
    object Parse(string s);
    virtual string Normalize(string s) => s.Trim(); // C# 8+
}
```

---

## 10. 패턴 매칭 고급 — 속성/리스트/조합

```csharp
interface IMessage { string Type { get; } int[] Payload { get; } }

string Route(IMessage m) => m switch
{
    { Type: "ping" } => "PONG",
    { Type: "sum", Payload: [var a, var b, ..] } => (a + b).ToString(),
    { Payload: [] } => "EMPTY",
    null => "NULL",
    _ => "UNKNOWN"
};
```

- **속성 패턴**: `{ Prop: value }`  
- **리스트 패턴**: `[head, ..tail]`  
- **`..` 슬라이스**: 나머지 매칭

---

## 11. 리플렉션 활용 — `typeof`로 메타 작업

```csharp
static IEnumerable<string> GetPublicMethods<T>() =>
    typeof(T).GetMethods()
             .Where(mi => mi.IsPublic)
             .Select(mi => mi.Name);

// 예: Console의 퍼블릭 메서드 나열
foreach (var name in GetPublicMethods<Console>())
    Console.WriteLine(name);
```

- **성능 비용** 큼 → 캐싱/소스제너레이터/표준 API 우선.

---

## 12. 성능/안정성 메모

1. **`is`/패턴 매칭**은 빠르고, JIT 최적화가 좋음.  
2. **`as` + null 체크**는 예외 비용을 회피하므로 **핫 패스**에 유리.  
3. **인터페이스 호출**은 가상 호출 → 미세한 오버헤드. `sealed` 클래스/정적 경로로 **devirtualization** 여지.  
4. **배열 공변성**은 타입 안전에 취약(런타임 예외 가능) → 가급적 **제네릭 인터페이스** 사용.  
5. 리플렉션은 **최후의 수단**. 런타임 생성/호출은 캐시/컴파일 타임 대체 고려.

---

## 13. 수학적 직관 — 리스코프 치환 원칙(LSP)

**정의(비공식)**:  
베이스 타입 \( B \)의 성질/규약을 만족하는 한, 파생 타입 \( D \)는 어디서든 \( B \)로 **치환 가능**해야 한다.

$$
\forall\, \text{context } C[\cdot]\,.\; C[B] \Rightarrow C[D]
$$

이를 깨면(전제/사후 조건 변경, 예외 규약 위반 등) 다형성은 **안전하지 않음** → 인터페이스/추상 계약을 **엄격히 문서화**해야 하는 이유.

---

## 14. 종합 예제 — 인터페이스 + 패턴 매칭 + 안전 변환

```csharp
using System;
using System.Collections.Generic;

interface IAnimal { void Speak(); }
class Dog : IAnimal { public void Speak() => Console.WriteLine("멍멍"); public bool Guard; }
class Cat : IAnimal { public void Speak() => Console.WriteLine("야옹"); public int Lives = 9; }

static class AnimalRouter
{
    public static void Handle(object? obj)
    {
        switch (obj)
        {
            case null:
                Console.WriteLine("아무것도 없음");
                break;

            case IAnimal a when obj is Dog d && d.Guard:
                Console.Write("경비견: "); a.Speak();
                break;

            case IAnimal a:
                a.Speak();
                break;

            // 타입 정보만 필요할 때
            default:
                Console.WriteLine($"Unknown: {obj.GetType().FullName}");
                break;
        }
    }
}

class Program
{
    static void Main()
    {
        object[] inputs = { new Dog { Guard = true }, new Cat(), 123, null! };

        foreach (var x in inputs)
            AnimalRouter.Handle(x);

        // as + null 체크
        object o = new Dog();
        var dog = o as Dog;
        if (dog != null) dog.Speak();

        // 정확 타입 vs 상속 포함
        Console.WriteLine(o.GetType() == typeof(Dog)); // True
        Console.WriteLine(o is IAnimal);               // True
    }
}
```

---

## 15. 자주 하는 실수 & 해결책

| 실수 | 문제 | 해결 |
|---|---|---|
| `as`로 값형 변환 시도 | `as`는 참조형 위주 | 값형은 명시 캐스팅 또는 `is` 패턴 + 언박싱 |
| `GetType()==typeof(Base)`로 상속 포함 확인 | **항상 false** | `obj is Base` 사용 |
| 명시적 인터페이스 구현 사용 후 멤버가 “안 보임” | 의도대로 숨겨짐 | 인터페이스로 캐스팅해 호출 |
| 인터페이스 디폴트 구현 남용 | 다이아몬드/충돌 | **필요 최소한**만 사용, 문서화 |
| 배열 공변성 의존 | 런타임 예외 위험 | 제네릭 인터페이스/컬렉션 사용 |

---

## 16. 연습 과제

1) `IFormatter`(Format(string)→string)와 구현체 `UpperFormatter`, `TrimFormatter`를 만들고, **데코레이터**로 타임스탬프를 추가하라.  
2) `IShape`와 `Circle`, `Rect`를 만들고, **패턴 매칭**으로 면적과 설명을 스위치 표현식으로 반환하라.  
3) `IRepository<T>` 제약과 **정적 추상 멤버**가 있는 `IIdentity<TSelf>`를 결합해, `CreateDefault()` 제네릭 팩토리를 작성하라.  
4) `is`/`as`/`typeof`/`GetType()`의 차이를 **실험 코드**로 출력하고, 케이스별 결과를 표로 정리하라.  
5) 공변/반공변 인터페이스를 직접 선언(`out`/`in`)하고, 안전한 치환 예제를 작성하라.

---

## 17. 요약

- **인터페이스**는 **역할 계약**으로 다형성의 기반. 명시적 구현/디폴트 구현/정적 추상 멤버 등으로 활용 폭이 넓다.  
- **다형성**은 LSP를 지키며 설계해야 안전하다.  
- **`is`/패턴 매칭**은 타입 확인과 바인딩을 **간결/안전**하게, **`as`**는 예외 없는 **안전 변환**을 제공.  
- **`typeof` vs `GetType()`**: **정확 타입** 비교 vs **상속 포함** 검사 선택.  
- 성능과 가독성을 고려해 **최소한의 검사/변환**과 **명확한 계약**으로 API를 설계하자.