---
layout: post
title: C# - 인터페이스와 다형성, 타입 검사
date: 2024-10-14 19:20:23 +0900
category: Csharp
---
# C# 인터페이스와 다형성, 타입 검사 (is/as/typeof)

## 소개: 유연한 설계를 위한 계약 기반 프로그래밍

객체 지향 프로그래밍에서 **다형성(Polymorphism)** 은 코드의 유연성과 재사용성을 높이는 핵심 개념입니다. C#에서 다형성을 구현하는 주요 방법은 **인터페이스(Interface)** 를 사용하는 것입니다. 인터페이스는 "무엇을 해야 하는지(계약)"를 정의하고, 클래스는 "어떻게 하는지(구현)"를 제공합니다. 이러한 분리를 통해 시스템은 더 유연해지고, 테스트하기 쉬워지며, 확장성이 향상됩니다.

---

## 1. 인터페이스(Interface): 계약 정의하기

### 인터페이스의 기본 개념

인터페이스는 메서드, 프로퍼티, 이벤트, 인덱서의 시그니처만을 정의하고 구현은 포함하지 않는 참조 형식입니다. 클래스나 구조체가 특정 인터페이스를 "구현한다"는 것은 해당 인터페이스가 정의한 모든 멤버에 대한 구현을 제공한다는 것을 의미합니다.

```csharp
// 인터페이스 정의
public interface ILogger
{
    void Log(string message);
    void LogError(string message, Exception? exception = null);
}

// 인터페이스 구현
public class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"[INFO] {DateTime.Now:HH:mm:ss} - {message}");
    }
    
    public void LogError(string message, Exception? exception = null)
    {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine($"[ERROR] {DateTime.Now:HH:mm:ss} - {message}");
        if (exception != null)
        {
            Console.WriteLine($"       예외: {exception.Message}");
        }
        Console.ResetColor();
    }
}

public class FileLogger : ILogger
{
    private readonly string _filePath;
    
    public FileLogger(string filePath)
    {
        _filePath = filePath;
    }
    
    public void Log(string message)
    {
        File.AppendAllText(_filePath, $"[INFO] {DateTime.Now:O} - {message}\n");
    }
    
    public void LogError(string message, Exception? exception = null)
    {
        var errorMessage = $"[ERROR] {DateTime.Now:O} - {message}";
        if (exception != null)
        {
            errorMessage += $"\n       예외: {exception.Message}";
        }
        File.AppendAllText(_filePath, errorMessage + "\n");
    }
}
```

### 인터페이스를 통한 다형성

인터페이스의 진정한 힘은 다형성을 통해 나타납니다. 인터페이스 타입의 변수는 그 인터페이스를 구현하는 어떤 클래스의 인스턴스도 참조할 수 있습니다.

```csharp
class Program
{
    static void Main()
    {
        // 동일한 인터페이스 타입으로 다양한 구현체 사용
        ILogger logger;
        
        // 콘솔 로거 사용
        logger = new ConsoleLogger();
        logger.Log("애플리케이션 시작");
        
        // 파일 로거 사용
        logger = new FileLogger("app.log");
        logger.LogError("파일을 찾을 수 없음", new FileNotFoundException("config.json"));
        
        // 메서드 매개변수로 인터페이스 사용
        ProcessData(new ConsoleLogger());
        ProcessData(new FileLogger("data.log"));
    }
    
    static void ProcessData(ILogger logger)
    {
        // 호출자는 실제 구현체를 알 필요 없이 인터페이스만 알고 사용
        logger.Log("데이터 처리 시작");
        // 데이터 처리 로직...
        logger.Log("데이터 처리 완료");
    }
}
```

### 다중 인터페이스 구현

한 클래스는 여러 인터페이스를 동시에 구현할 수 있습니다. 이는 C#이 단일 클래스 상속만 지원하는 제한을 보완하는 중요한 기능입니다.

```csharp
public interface IReadable
{
    string Read();
}

public interface IWritable
{
    void Write(string content);
}

public interface IDocument : IReadable, IWritable
{
    string Title { get; set; }
}

public class TextDocument : IDocument
{
    private string _content = string.Empty;
    
    public string Title { get; set; } = "제목 없음";
    
    public string Read() => _content;
    
    public void Write(string content)
    {
        _content = content;
        Console.WriteLine($"문서 '{Title}'에 내용 작성 완료");
    }
}

// 사용 예
IDocument doc = new TextDocument { Title = "보고서" };
doc.Write("이것은 보고서 내용입니다.");
Console.WriteLine(doc.Read());
```

---

## 2. 명시적 인터페이스 구현(Explicit Interface Implementation)

명시적 인터페이스 구현은 클래스가 동일한 시그니처의 멤버를 가진 여러 인터페이스를 구현할 때, 또는 인터페이스 멤버를 클래스의 공개 API에서 숨기고 싶을 때 사용합니다.

{% raw %}
```csharp
public interface ISerializable
{
    string Serialize();
}

public interface IPrintable
{
    string Serialize(); // 동일한 이름의 메서드
}

public class Report : ISerializable, IPrintable
{
    private string _data = "보고서 데이터";
    
    // 명시적 인터페이스 구현: ISerializable.Serialize
    string ISerializable.Serialize()
    {
        return $"JSON: {{\"data\": \"{_data}\"}}";
    }
    
    // 명시적 인터페이스 구현: IPrintable.Serialize
    string IPrintable.Serialize()
    {
        return $"PRINT FORMAT: {_data}";
    }
    
    // 클래스 자체의 공개 메서드
    public void Display()
    {
        Console.WriteLine($"보고서: {_data}");
    }
}

class Program
{
    static void Main()
    {
        Report report = new Report();
        
        // 클래스 자체의 메서드는 직접 호출 가능
        report.Display();
        
        // 명시적 인터페이스 구현 메서드는 인터페이스 타입으로 캐스팅 후 호출
        ISerializable serializable = report;
        Console.WriteLine(serializable.Serialize()); // JSON 형식
        
        IPrintable printable = report;
        Console.WriteLine(printable.Serialize());    // 출력 형식
        
        // 다음 코드는 컴파일 오류: 명시적 구현 메서드는 클래스에서 직접 호출 불가
        // report.Serialize();
    }
}
```
{% endraw %}

### 명시적 구현의 활용 사례

1. **이름 충돌 해결**: 여러 인터페이스에 동일한 이름의 멤버가 있을 때
2. **API 노출 제어**: 특정 메서드를 인터페이스를 통해서만 사용하도록 제한
3. **의도 명확화**: 메서드가 어떤 인터페이스의 계약을 구현하는지 명시

---

## 3. C# 8.0+: 기본 인터페이스 멤버(Default Interface Members)

C# 8.0부터 인터페이스에 기본 구현을 가진 멤버를 포함할 수 있게 되었습니다. 이는 기존 인터페이스에 새로운 멤버를 추가하면서 하위 호환성을 유지하는 데 유용합니다.

```csharp
public interface IShape
{
    // 추상 멤버: 구현체가 반드시 구현해야 함
    double CalculateArea();
    
    // 기본 구현을 가진 멤버 (C# 8.0+)
    public string GetDescription()
    {
        return $"면적: {CalculateArea():F2}";
    }
    
    // 정적 멤버 (C# 8.0+)
    public static string GetShapeType()
    {
        return "기하 도형";
    }
}

public class Circle : IShape
{
    public double Radius { get; }
    
    public Circle(double radius)
    {
        Radius = radius;
    }
    
    // 추상 멤버만 구현하면 됨
    public double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
    
    // 기본 구현을 오버라이드할 수도 있음 (선택적)
    public string GetDescription()
    {
        return $"반지름 {Radius}인 원, {((IShape)this).GetDescription()}";
    }
}

class Program
{
    static void Main()
    {
        Circle circle = new Circle(5);
        
        // 인터페이스를 통한 호출
        IShape shape = circle;
        Console.WriteLine(shape.CalculateArea());      // 78.54...
        Console.WriteLine(shape.GetDescription());     // 기본 구현 또는 오버라이드된 구현
        
        // 정적 메서드 호출
        Console.WriteLine(IShape.GetShapeType());      // "기하 도형"
        
        // 클래스 인스턴스에서 직접 호출
        Console.WriteLine(circle.GetDescription());    // 오버라이드된 구현
    }
}
```

**주의사항**: 기본 인터페이스 멤버는 주의해서 사용해야 합니다. 특히:
- 다이아몬드 상속 문제(한 클래스가 동일한 기본 구현을 가진 두 인터페이스를 구현할 때)가 발생할 수 있습니다.
- 항상 인터페이스 타입을 통해 호출해야 기본 구현이 활성화됩니다.

---

## 4. 타입 검사와 변환: `is`, `as`, `typeof`, 패턴 매칭

### `is` 연산자: 타입 확인

`is` 연산자는 객체가 특정 타입과 호환되는지 확인합니다. 상속 관계나 인터페이스 구현을 모두 고려합니다.

```csharp
public interface IFlyable
{
    void Fly();
}

public class Bird : IFlyable
{
    public void Fly() => Console.WriteLine("새가 날아갑니다");
}

public class Airplane : IFlyable
{
    public void Fly() => Console.WriteLine("비행기가 이륙합니다");
}

public class Car
{
    public void Drive() => Console.WriteLine("차가 달립니다");
}

class Program
{
    static void Main()
    {
        object[] vehicles = { new Bird(), new Airplane(), new Car(), "문자열", null };
        
        foreach (var vehicle in vehicles)
        {
            // is 연산자를 사용한 타입 확인
            if (vehicle is IFlyable flyable)
            {
                Console.Write("날 수 있는 운송수단: ");
                flyable.Fly();
            }
            else if (vehicle is Car)
            {
                Console.WriteLine("자동차 (날지 못함)");
            }
            else if (vehicle is string str)
            {
                Console.WriteLine($"문자열: {str}");
            }
            else if (vehicle == null)
            {
                Console.WriteLine("null 값");
            }
            else
            {
                Console.WriteLine("알 수 없는 타입");
            }
        }
    }
}
```

### 패턴 매칭(Pattern Matching)

C# 7.0부터 도입된 패턴 매칭은 `is` 연산자를 더욱 강력하게 만듭니다.

```csharp
public abstract class Shape { }
public class Circle : Shape { public double Radius { get; set; } }
public class Rectangle : Shape { public double Width { get; set; } public double Height { get; set; } }

class Program
{
    static string DescribeShape(Shape shape)
    {
        // 타입 패턴
        return shape switch
        {
            null => "없음",
            Circle c when c.Radius > 10 => $"큰 원 (반지름: {c.Radius})",
            Circle c => $"원 (반지름: {c.Radius})",
            Rectangle r when r.Width == r.Height => $"정사각형 (변: {r.Width})",
            Rectangle r => $"사각형 ({r.Width}x{r.Height})",
            _ => "알 수 없는 도형"
        };
    }
    
    static void Main()
    {
        Shape[] shapes = {
            new Circle { Radius = 5 },
            new Circle { Radius = 15 },
            new Rectangle { Width = 4, Height = 4 },
            new Rectangle { Width = 3, Height = 5 },
            null
        };
        
        foreach (var shape in shapes)
        {
            Console.WriteLine(DescribeShape(shape));
        }
    }
}
```

### `as` 연산자: 안전한 타입 변환

`as` 연산자는 타입 변환을 시도하고, 실패하면 `null`을 반환합니다. 예외를 발생시키지 않는 안전한 변환 방법입니다.

```csharp
object obj1 = "Hello, World!";
object obj2 = 12345;
object obj3 = null;

// as 연산자를 사용한 안전한 변환
string str1 = obj1 as string; // 성공: "Hello, World!"
string str2 = obj2 as string; // 실패: null
string? str3 = obj3 as string; // 성공: null (obj3가 null이므로)

if (str1 != null)
{
    Console.WriteLine($"str1: {str1.Length}자"); // 13자
}

if (str2 == null)
{
    Console.WriteLine("str2는 문자열로 변환할 수 없습니다.");
}

// 값 타입에는 as를 직접 사용할 수 없습니다 (nullable로는 가능)
int? number = obj2 as int?; // 가능: 12345
```

### `typeof` 연산자와 `GetType()` 메서드

`typeof`와 `GetType()`은 모두 타입 정보를 얻는 데 사용되지만, 중요한 차이가 있습니다:

```csharp
public class Animal { }
public class Dog : Animal { }

class Program
{
    static void Main()
    {
        Animal animal = new Dog();
        
        // typeof: 컴파일 타임에 알려진 타입의 Type 객체를 얻음
        Type animalType = typeof(Animal);
        Type dogType = typeof(Dog);
        Console.WriteLine($"typeof(Animal): {animalType.Name}"); // Animal
        Console.WriteLine($"typeof(Dog): {dogType.Name}");       // Dog
        
        // GetType(): 런타임 객체의 실제 타입의 Type 객체를 얻음
        Type runtimeType = animal.GetType();
        Console.WriteLine($"animal.GetType(): {runtimeType.Name}"); // Dog (실제 타입)
        
        // 비교
        Console.WriteLine($"animal is Animal: {animal is Animal}");           // True (상속 관계)
        Console.WriteLine($"animal is Dog: {animal is Dog}");                 // True (실제 타입)
        Console.WriteLine($"animal.GetType() == typeof(Animal): {runtimeType == animalType}"); // False (정확한 타입 비교)
        Console.WriteLine($"animal.GetType() == typeof(Dog): {runtimeType == dogType}");       // True (정확한 타입 비교)
    }
}
```

**요약**:
- `typeof(Type)`: 컴파일 타임에 타입의 `Type` 객체를 얻음
- `instance.GetType()`: 런타임에 인스턴스의 실제 타입의 `Type` 객체를 얻음
- `is`: 타입 호환성 확인 (상속/구현 관계 포함)
- `as`: 안전한 타입 변환 (실패 시 null)

---

## 5. 제네릭과 인터페이스의 결합

제네릭과 인터페이스를 함께 사용하면 타입 안전성을 유지하면서도 높은 재사용성을 달성할 수 있습니다.

### 제네릭 제약 조건으로 인터페이스 요구

```csharp
public interface IIdentifiable
{
    int Id { get; }
}

public interface IAuditable
{
    DateTime CreatedAt { get; }
    DateTime? UpdatedAt { get; set; }
}

// 제네릭 제약: T는 IIdentifiable과 IAuditable을 구현해야 함
public class Repository<T> where T : class, IIdentifiable, IAuditable, new()
{
    private readonly List<T> _items = new();
    
    public T? GetById(int id)
    {
        return _items.FirstOrDefault(item => item.Id == id);
    }
    
    public void Add(T item)
    {
        item.CreatedAt = DateTime.UtcNow;
        _items.Add(item);
    }
    
    public void Update(T item)
    {
        var existing = GetById(item.Id);
        if (existing != null)
        {
            item.UpdatedAt = DateTime.UtcNow;
            // 업데이트 로직...
        }
    }
    
    public T CreateNew()
    {
        return new T(); // new() 제약으로 가능
    }
}

// 사용 예
public class Product : IIdentifiable, IAuditable
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }
}

class Program
{
    static void Main()
    {
        var productRepo = new Repository<Product>();
        
        var newProduct = productRepo.CreateNew();
        newProduct.Id = 1;
        newProduct.Name = "노트북";
        newProduct.Price = 1200000;
        
        productRepo.Add(newProduct);
        
        var found = productRepo.GetById(1);
        if (found != null)
        {
            Console.WriteLine($"찾은 상품: {found.Name} ({found.Price:C})");
        }
    }
}
```

### 공변성(Covariance)과 반공변성(Contravariance)

C# 4.0부터 제네릭 인터페이스와 대리자에 공변성(`out`)과 반공변성(`in`)이 도입되었습니다.

```csharp
// 공변 인터페이스 (out T)
public interface IReadOnlyContainer<out T>
{
    T GetItem();
}

public class Container<T> : IReadOnlyContainer<T>
{
    private T _item;
    
    public Container(T item)
    {
        _item = item;
    }
    
    public T GetItem() => _item;
}

// 반공변 인터페이스 (in T)
public interface IComparer<in T>
{
    int Compare(T x, T y);
}

class Program
{
    static void Main()
    {
        // 공변성 예제: 더 구체적인 타입을 더 일반적인 타입으로 대체 가능
        IReadOnlyContainer<string> stringContainer = new Container<string>("Hello");
        IReadOnlyContainer<object> objectContainer = stringContainer; // 공변성으로 가능
        
        // 반공변성 예제: 더 일반적인 타입을 더 구체적인 타입으로 대체 가능
        IComparer<object> objectComparer = Comparer<object>.Default;
        IComparer<string> stringComparer = objectComparer; // 반공변성으로 가능
        
        Console.WriteLine($"공변성: {objectContainer.GetItem()}");
        Console.WriteLine($"반공변성: {stringComparer.Compare("A", "B")}");
    }
}
```

---

## 6. 실전 예제: 플러그인 아키텍처

인터페이스의 가장 강력한 활용 사례 중 하나는 플러그인 시스템입니다.

```csharp
using System.Reflection;

// 플러그인 인터페이스
public interface IPlugin
{
    string Name { get; }
    string Description { get; }
    void Execute();
}

// 플러그인 관리자
public class PluginManager
{
    private readonly List<IPlugin> _plugins = new();
    
    public void LoadPlugins(string directoryPath)
    {
        if (!Directory.Exists(directoryPath))
        {
            Console.WriteLine($"디렉토리가 존재하지 않음: {directoryPath}");
            return;
        }
        
        var dllFiles = Directory.GetFiles(directoryPath, "*.dll");
        
        foreach (var dllFile in dllFiles)
        {
            try
            {
                // 어셈블리 로드
                Assembly assembly = Assembly.LoadFrom(dllFile);
                
                // IPlugin을 구현한 타입 찾기
                var pluginTypes = assembly.GetTypes()
                    .Where(t => typeof(IPlugin).IsAssignableFrom(t) && !t.IsInterface && !t.IsAbstract);
                
                foreach (var type in pluginTypes)
                {
                    // 플러그인 인스턴스 생성
                    if (Activator.CreateInstance(type) is IPlugin plugin)
                    {
                        _plugins.Add(plugin);
                        Console.WriteLine($"플러그인 로드됨: {plugin.Name}");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"파일 로드 실패 {dllFile}: {ex.Message}");
            }
        }
    }
    
    public void ExecuteAll()
    {
        foreach (var plugin in _plugins)
        {
            try
            {
                Console.WriteLine($"\n[{plugin.Name}] 실행 중...");
                plugin.Execute();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"플러그인 실행 실패 {plugin.Name}: {ex.Message}");
            }
        }
    }
    
    public IEnumerable<IPlugin> GetPlugins() => _plugins;
}

// 예제 플러그인 1
public class HelloPlugin : IPlugin
{
    public string Name => "인사 플러그인";
    public string Description => "간단한 인사 메시지를 출력합니다.";
    
    public void Execute()
    {
        Console.WriteLine("안녕하세요! 플러그인 시스템에 오신 것을 환영합니다.");
    }
}

// 예제 플러그인 2
public class MathPlugin : IPlugin
{
    public string Name => "수학 플러그인";
    public string Description => "간단한 수학 연산을 수행합니다.";
    
    public void Execute()
    {
        Random random = new Random();
        int a = random.Next(1, 100);
        int b = random.Next(1, 100);
        
        Console.WriteLine($"{a} + {b} = {a + b}");
        Console.WriteLine($"{a} * {b} = {a * b}");
    }
}

class Program
{
    static void Main()
    {
        var pluginManager = new PluginManager();
        
        // 현재 디렉토리에서 플러그인 로드
        pluginManager.LoadPlugins(".");
        
        // 실행
        pluginManager.ExecuteAll();
        
        // 특정 플러그인 찾기
        var mathPlugin = pluginManager.GetPlugins()
            .FirstOrDefault(p => p is MathPlugin);
            
        if (mathPlugin != null)
        {
            Console.WriteLine($"\n수학 플러그인 발견: {mathPlugin.Name}");
        }
    }
}
```

---

## 결론: 적절한 추상화의 힘

인터페이스와 다형성은 C#에서 강력하고 유연한 소프트웨어를 설계하는 데 필수적인 도구입니다. 이 개념들을 효과적으로 사용하기 위한 핵심 원칙을 정리해 보겠습니다:

1. **계약에 의한 프로그래밍**: 인터페이스를 사용하여 "무엇을" 해야 하는지 정의하고, 클래스가 "어떻게" 할 것인지 구현하게 하세요. 이는 코드의 의존성을 줄이고 모듈 간 결합도를 낮춥니다.

2. **다형성의 적절한 활용**: 인터페이스 타입을 통해 객체를 참조하면, 구체적인 구현을 알 필요 없이 일관된 방식으로 객체를 사용할 수 있습니다. 이는 코드의 재사용성과 유지보수성을 크게 향상시킵니다.

3. **타입 안전성의 유지**: `is`, `as`, 패턴 매칭을 적절히 사용하여 타입 변환과 검사를 안전하게 수행하세요. 특히 `as` 연산자와 null 체크를 함께 사용하면 예외 없이 안전한 타입 변환이 가능합니다.

4. **런타임 vs 컴파일 타임 타입 정보**: `typeof`는 컴파일 타임에 알려진 타입 정보를, `GetType()`은 런타임 객체의 실제 타입 정보를 제공합니다. 각각의 적절한 사용처를 이해하세요.

5. **명시적 구현의 전략적 사용**: 명시적 인터페이스 구현은 이름 충돌 해결, API 노출 제어, 의도 명확화 등에 유용하지만, 남용하면 코드 가독성이 떨어질 수 있습니다.

6. **제네릭과의 시너지**: 제네릭과 인터페이스를 결합하면 타입 안전성을 유지하면서도 높은 재사용성을 달성할 수 있습니다. 공변성과 반공변성을 이해하고 적절히 활용하세요.

인터페이스는 단순한 문법적 기능을 넘어, 소프트웨어 설계 철학을 반영하는 도구입니다. 잘 설계된 인터페이스 계층 구조는 시간이 지나도 유지보수하기 쉽고, 새로운 기능을 추가하기 용이한 시스템의 기반이 됩니다. 다음번에 클래스를 설계할 때, "이 클래스가 제공해야 하는 핵심 계약은 무엇인가?"를 먼저 생각하고 인터페이스로 정의해 보세요. 이 간단한 습관이 코드의 질을 획기적으로 높여줄 것입니다.