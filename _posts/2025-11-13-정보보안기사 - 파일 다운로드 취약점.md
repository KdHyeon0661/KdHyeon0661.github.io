---
layout: post
title: 정보보안기사 - 파일 다운로드 취약점
date: 2025-11-13 07:25:23 +0900
category: 정보보안기사
---
# SECTION 08 웹 애플리케이션 취약점 — 07. 파일 다운로드(File Download) 취약점 완전 정리 (IDOR/경로탈출/헤더주입/SSRF/캐시/XSS/대용량 DoS → 안전 설계·코드 템플릿·서버/클라우드 설정·체크리스트·실기 예상문제)

## 개요 — “다운로드는 읽기 권한을 외부로 노출한다”
파일 **다운로드 기능**은 서버에 존재하는(또는 프록시로 가져오는) 데이터를 **클라이언트로 안전하게 전달**해야 한다. 검증이 약하면 **민감 정보 유출**, **임의 파일 읽기(Local File Read)**, **IDOR(불안전 직접객체참조)**, **SSRF**, **헤더 주입/응답 분할**, **브라우저 내 미탐지 XSS**, **오리진/캐시 오설정** 등으로 이어진다.

- 핵심 원칙:
  1) 경로·파일 직접 노출 금지(항상 **ID→매핑**),
  2) **정규화된 내부 경로**만 접근,
  3) **권한/소유권 검증** → 통과 후에만 컨텐츠 제공,
  4) 항상 **다운로드로 강제**(`Content-Disposition: attachment` + `nosniff`),
  5) **캐시 정책**과 **서명 URL**을 상황에 맞게,
  6) 프록시는 **허용 리스트/도메인 고정**.

위험 직관식:
\[
\text{Risk}=\frac{P(\text{Bypass})\times I(\text{Data Exposure/Injection})}{D(\text{Logging/Monitoring})}
\]
- \(P\)↓: 경로 정규화, ID 매핑, 강한 인가
- \(I\)↓: 첨부 다운로드, 캐시/오리진 격리, 범위/속도 제한
- \(D\)↑: 상세 로깅/경보, 비정상 패턴 탐지

---

## 공격 표면 요약 (한 눈에 보기)

| 범주 | 설명 | 예시/징후 |
|---|---|---|
| **IDOR(권한 무검증)** | `?id=123` 만으로 타인 파일 획득 | 연속 ID, 접근 시 인증만 체크, 소유권 미검증 |
| **경로 탈출(Path Traversal)** | `?file=../../etc/passwd` | 이중 인코딩 `%2e%2e/`, 유니코드 변형, 백슬래시 혼합 |
| **헤더 주입/응답 분할** | 파일명 파라미터를 `Content-Disposition`에 그대로 | `filename="abc"\r\nX-Injected:1` |
| **MIME 스니핑/Inline XSS** | `text/html`로 내보내거나 `nosniff` 미설정 | 브라우저 렌더링으로 스크립트 실행 |
| **프록시 SSRF** | `?url=http://target/internal` 다운프록시 | 내부 메타데이터/클라우드 IMDS 접근 |
| **캐시 오설정** | 민감 파일에 `public` 캐시 | CDN/프록시에서 공유·노출 |
| **대용량/범위 DoS** | 큰 파일, 무제한 Range | 서버/대역폭 고갈, Cache Amplification |
| **클라우드 오리진 오픈** | S3/GCS 공개, 잘못된 ACL | 직접 URL로 접근 가능 |
| **파일명 동명이인/오버레이** | 같은 이름 덮어쓰기 | 다른 사용자 파일 가로채기 |

---

## 흔한 취약 패턴과 안전 패턴

### 1. IDOR: “URL의 숫자만 바꾸면 남 파일”
**취약(개념)**
`GET /download?id=456` → 로그인만 확인, **id=457**로 바꾸면 타인 파일.

**안전**
- 항상 **소유권/권한** 검증: `file.owner == current_user` 또는 RBAC/정책 평가.
- 노출 ID는 난수/UUID/해시 **비예측**. 서버 내부 실제 경로와 **매핑 테이블** 사용.

### 2. 경로 탈출
**취약**
`GET /download?file=../../secret.db` → `..` / 이중 인코딩 / 혼합 경로 구문.

**안전**
- **서버가 경로를 생성**: `base + safe_filename`이 아니라, **ID→정규화된 절대경로**.
- `resolve()` 후 **프리픽스 검사**: `resolvedPath.startsWith(BASE)`.

### 3. 헤더 주입(파일명 반사)
**취약**
`Content-Disposition: attachment; filename="{userName}"` 에 CRLF 포함 가능.

**안전**
- 파일명은 **서버 생성** + 헤더용 **RFC 5987** 인코딩(`filename*`)만 사용.
- CR/LF/제어문자 제거, 길이 제한.

### 4. MIME 스니핑/Inline 렌더
**취약**
`Content-Type: text/html` 로 내보내거나 `X-Content-Type-Options: nosniff` 누락 → 브라우저 렌더/XSS.

**안전**
`Content-Type: application/octet-stream` + `Content-Disposition: attachment` + `X-Content-Type-Options: nosniff`.

### 5. 다운로드 프록시 SSRF
**취약**
`GET /proxy?url=http://whatever` → 내부망/IMDS 접근, 인증 우회.

**안전**
- **허용 도메인 화이트리스트**(정규화 후 DNS 재확인), 사설 IP/루프백 금지, HTTPS 강제, 리디렉션 제한.

### 6. 캐시/오리진 오설정
**취약**
민감 파일에 `Cache-Control: public` 또는 공개 버킷.

**안전**
- 민감: `Cache-Control: no-store, private`, 프리사인 URL 단기.
- 공개 정적: 별도 오리진/도메인, 정적 전용 버킷, 원본 차단(Origin Access Control/Policy).

### 7. 대용량·범위 요청 남용
**취약**
무제한 `Range`/동시 요청 → 서버/캐시 증폭.

**안전**
- 범위 허용 시 **최대 크기/동시수 제한**, 쓰로틀링, 응답 지연, CDN RateLimit.
- 필요 없으면 `Accept-Ranges: none`.

---

## 안전 구현 템플릿 (언어별)

### Python (Flask) — ID 매핑, 경로 정규화, 안전 헤더
```python
from flask import Flask, request, abort, Response
from werkzeug.datastructures import Headers
import os, pathlib, mimetypes
from urllib.parse import quote

app = Flask(__name__)

BASE = pathlib.Path("/srv/data/files").resolve()

# 가짜 DB 매핑 예: id -> 실제 파일 경로, owner
FILES = {
  "a1b2": {"path": BASE / "user1/report-2025.pdf", "owner": "user1"},
  "c3d4": {"path": BASE / "user2/photo.jpg",       "owner": "user2"},
}

def current_user():
    # 실제에선 세션/JWT 등
    return request.headers.get("X-User", "guest")

def rfc5987_filename(value: str) -> str:
    # filename*: UTF-8'' 인코딩
    return "UTF-8''" + quote(value, safe="")

@app.get("/download")
def download():
    fid = request.args.get("id")
    meta = FILES.get(fid)
    if not meta: abort(404)

    # 권한 검증
    if meta["owner"] != current_user():
        abort(403)

    # 경로 정규화/검증
    path = meta["path"].resolve()
    if not path.exists() or not str(path).startswith(str(BASE)):
        abort(404)

    # 파일명은 서버가 관리(원본명 메타에서 가져오기 가능하나, 헤더는 RFC5987로)
    download_name = path.name

    # 스트리밍/헤더
    mime = mimetypes.guess_type(download_name)[0] or "application/octet-stream"
    headers = Headers()
    headers.add("Content-Type", "application/octet-stream") # 강제 다운로드
    headers.add("X-Content-Type-Options", "nosniff")
    headers.add("Content-Disposition",
                f"attachment; filename*= {rfc5987_filename(download_name)}")
    headers.add("Cache-Control", "no-store, private")
    headers.add("Content-Security-Policy", "default-src 'none'")  # 첨부임에도 보강

    def generate():
        with open(path, "rb") as f:
            while True:
                chunk = f.read(64 * 1024)
                if not chunk: break
                yield chunk

    return Response(generate(), headers=headers, status=200)
```

### Node.js (Express) — 안전 파일명/헤더, 경로 제한, 쓰로틀
```js
import express from "express";
import fs from "node:fs";
import fsp from "node:fs/promises";
import path from "node:path";
import { pipeline } from "node:stream/promises";
import { createReadStream } from "node:fs";
import { rateLimit } from "express-rate-limit";
import { URL } from "node:url";

const app = express();
const BASE = path.resolve("/srv/data/files");

const limiter = rateLimit({ windowMs: 60_000, max: 120 }); // 간단 예시
app.use(limiter);

function filenameRFC5987(name) {
  return "UTF-8''" + encodeURIComponent(name).replace(/['()]/g, escape);
}

function safeResolve(p) {
  const rel = path.normalize(p).replace(/^(\.\.(\/|\\|$))+/, "");
  const abs = path.resolve(BASE, rel);
  if (!abs.startsWith(BASE)) throw new Error("path traversal");
  return abs;
}

app.get("/download", async (req, res) => {
  // 실제에선 id -> 메타 매핑 + 권한 체크
  const rel = req.query.rel; // 예시: user1/report-2025.pdf
  if (!rel) return res.sendStatus(400);

  let abs;
  try { abs = safeResolve(rel); } catch { return res.sendStatus(400); }

  let stat;
  try { stat = await fsp.stat(abs); } catch { return res.sendStatus(404); }

  res.setHeader("Content-Type", "application/octet-stream");
  res.setHeader("X-Content-Type-Options", "nosniff");
  res.setHeader("Content-Disposition", `attachment; filename*= ${filenameRFC5987(path.basename(abs))}`);
  res.setHeader("Cache-Control", "no-store, private");
  res.setHeader("Accept-Ranges", "none"); // 필요 시 off

  const stream = createReadStream(abs, { highWaterMark: 64 * 1024 });
  stream.on("error", () => res.destroy());
  await pipeline(stream, res);
});

app.listen(3000);
```

### Java (Spring Boot) — `ContentDisposition.attachment` 활용, 경로 정규화
```java
@GetMapping("/download/{id}")
public ResponseEntity<Resource> download(@PathVariable String id, Principal principal) throws IOException {
    // 1) id -> 메타 조회 + owner 검증
    FileMeta meta = fileService.get(id);
    if (meta == null) return ResponseEntity.notFound().build();
    if (!meta.getOwner().equals(principal.getName())) return ResponseEntity.status(403).build();

    Path base = Paths.get("/srv/data/files").toRealPath();
    Path p = base.resolve(meta.getRelativePath()).normalize().toRealPath();
    if (!p.startsWith(base) || !Files.exists(p)) return ResponseEntity.notFound().build();

    Resource r = new FileSystemResource(p.toFile());

    ContentDisposition cd = ContentDisposition.attachment()
        .filename(meta.getDownloadName(), StandardCharsets.UTF_8) // RFC 5987
        .build();

    return ResponseEntity.ok()
        .header(HttpHeaders.CONTENT_DISPOSITION, cd.toString())
        .header("X-Content-Type-Options", "nosniff")
        .header(HttpHeaders.CACHE_CONTROL, "no-store, private")
        .contentType(MediaType.APPLICATION_OCTET_STREAM)
        .body(r);
}
```

---

## 다운로드 프록시(원격 → 사용자) 안전 설계

### 취약 예(개념)
```http
GET /fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/
```
- 내부망/IMDS 접속, 포트 스캐닝, 비인가 데이터 유출.

### 안전 규칙
- 허용 **스킴**: `https://`만
- 허용 **도메인/경로** **화이트리스트**(정규화 후 A/AAAA 재확인, TOCTOU 방지)
- **사설/루프백/멀티캐스트** IP 차단, 리디렉션 제한, 응답 크기/타임아웃 제한
- 서버가 **다운로드하여 재전달**하는 대신, 가능하면 **서명 URL**을 발급하고 **클라이언트가 직접** 내려받도록

#### Node 예시: 도메인 고정 프록시
```js
import https from "node:https";
import dns from "node:dns/promises";
const ALLOW_HOST = "files.example.com";

function isPublicAddress(ips) {
  // RFC1918/localhost/Link-local 등 거부(간략 예시)
  return ips.every(ip => !ip.startsWith("10.") && !ip.startsWith("192.168.") && ip !== "127.0.0.1");
}

app.get("/proxy", async (req, res) => {
  const path = req.query.path || "/";
  const url = new URL(`https://${ALLOW_HOST}${path}`);
  const ips = await dns.resolve4(url.hostname);
  if (!isPublicAddress(ips)) return res.sendStatus(400);

  const opt = { hostname: url.hostname, path: url.pathname + url.search, method: "GET", timeout: 5000 };
  https.get(opt, r => {
    if (r.statusCode !== 200) return res.sendStatus(502);
    res.setHeader("Content-Type", "application/octet-stream");
    res.setHeader("X-Content-Type-Options", "nosniff");
    r.pipe(res);
  }).on("error", () => res.sendStatus(502));
});
```

---

## 안전한 파일명/헤더(브라우저 호환)

- **항상** `Content-Disposition: attachment`
- `filename*="UTF-8''<urlencoded>"` (RFC 5987) 사용 → 비ASCII/공백/특수문자 안전
- `X-Content-Type-Options: nosniff`
- (선택) `Content-Security-Policy: default-src 'none'` — 첨부 자체엔 큰 의미 없지만 응답 체인 보호
- `Cache-Control`:
  - 민감: `no-store, private`
  - 공개 배포용: `public, max-age=..., immutable`(+ 별도 오리진)

**헤더 주입 방지 팁**
- CR/LF 제거: `[\r\n]` 제거
- 따옴표/백슬래시 엄격 필터, 길이 제한(예: 128)

---

## 경로 정규화 유틸 (다언어 공통 아이디어)

1) 입력은 **ID/키**만 받는다. 파일 상대경로조차 **직접 받지 않는다**.
2) 내부에서 `id -> (base, relative)`를 조회하고, `resolve/normalize` 후 **베이스 시작 여부 검사**.
3) 심볼릭 링크/하드 링크, 널바이트, 대소문자 민감도, NTFS 특수경로(UNC/ADS) 고려.

**Go 예시**
```go
func safeJoin(base, rel string) (string, error) {
  clean := filepath.Clean(rel)
  abs := filepath.Join(base, clean)
  baseAbs, _ := filepath.Abs(base)
  abs, _ = filepath.Abs(abs)
  if !strings.HasPrefix(abs, baseAbs+string(os.PathSeparator)) && abs != baseAbs {
     return "", errors.New("traversal")
  }
  return abs, nil
}
```

---

## 서버/리버스 프록시 설정 패턴

### Nginx: 앱이 권한/경로 검증 후 `X-Accel-Redirect`로 내부 파일 제공
```nginx
# app: 권한 확인 후 X-Accel-Redirect: /protected/uuid 로 응답
location /protected/ {
    internal;
    alias /srv/data/files/;       # 내부 경로
    add_header X-Content-Type-Options "nosniff";
    add_header Content-Disposition "attachment";
    types { } default_type application/octet-stream;
    # 범위 제한이 필요없다면
    add_header Accept-Ranges none;
}
```

### Apache: 첨부 강제
```apache
<Location /download/>
  Header set X-Content-Type-Options "nosniff"
  Header set Content-Disposition "attachment"
</Location>
```

### IIS: MIME 강제/다운로드
```xml
<configuration>
  <system.webServer>
    <httpProtocol>
      <customHeaders>
        <add name="X-Content-Type-Options" value="nosniff"/>
        <add name="Content-Disposition" value="attachment"/>
      </customHeaders>
    </httpProtocol>
  </system.webServer>
</configuration>
```

---

## 클라우드 저장/서명 URL

### S3 (원칙)
- 버킷은 **기본 private** + **정적 오리진/서브도메인 분리**
- 민감 파일은 **서명 URL**(짧은 만료, 1회용) 발급
- 원본에 직접 접근 금지(Origin Access Control/Identity)
- `ResponseContentDisposition=attachment; filename*=...` 으로 응답 제어

**Python(boto3) 예시**
```python
import boto3, urllib.parse
s3 = boto3.client('s3', region_name='ap-northeast-2')

def presign_download(bucket, key, download_name, ttl=300):
    cd = f'attachment; filename*=UTF-8\'\'{urllib.parse.quote(download_name)}'
    return s3.generate_presigned_url(
        'get_object',
        Params={'Bucket': bucket, 'Key': key,
                'ResponseContentType': 'application/octet-stream',
                'ResponseContentDisposition': cd},
        ExpiresIn=ttl, HttpMethod='GET')
```

---

## 캐시·대역폭·범위 전략

- 민감 데이터: `no-store, private`, CDN 제외
- 공개 배포: 별도 도메인/버킷에서 `public, max-age, immutable`, ETag/Versioning
- 범위 요청이 필요 없다면 `Accept-Ranges: none` 응답
- 필요 시 **서버/프록시 레벨 쓰로틀링**(Nginx `limit_rate`, Envoy/HAProxy)
- **다운로드 속도/동시성 제한** + **총량 쿼터** → 대역폭 보호

---

## 로깅/모니터링 & 탐지 룰

- 필드: 요청자(계정/역할), IP, User-Agent, 파일 ID/키, 실제 경로/버킷 키, 사이즈, 결과(200/403/404), 소요 시간, Range 사용 여부
- **이상 징후**:
  - 403/404 급증(브루트),
  - 비정상 파라미터(`..`, `%2e%2e`, `\`),
  - 짧은 시간 다량 다운로드,
  - 서로 다른 계정에서 동일 ID 접근 시도
- SIEM 질의 예(개념):
  - where path like “%download%” and (param contains “..” or status in (403,404))
  - group by user_id | count > threshold

---

## 실습/테스트(합법·사내 승인 환경)

- **SAST**: 경로 조합/직접 파일명 사용 여부, 헤더에 사용자 입력 반사 검사
- **DAST**: `../`, 이중 인코딩, 유니코드 변형, CRLF 삽입 시도 → 차단/400
- **권한**: 다른 사용자 토큰으로 타인 파일 ID 접근 → 403 확인
- **프록시**: 사설 IP/IMDS 차단 확인, 리디렉션 제한
- **캐시**: 민감 응답에서 `public`/`s-maxage` 누락 확인
- **성능/DoS**: 큰 파일/동시 연결 제한 동작, 타임아웃/쓰로틀링 검증

---

## 체크리스트 (현장용)

- [ ] **ID→경로 매핑**(직접 경로 인자 금지), 소유권/권한 검증
- [ ] **경로 정규화 + BASE prefix 검사**, 심볼릭 링크/널바이트 방어
- [ ] 헤더: `Content-Disposition: attachment; filename*=`(RFC 5987), `X-Content-Type-Options: nosniff`
- [ ] `Content-Type: application/octet-stream`(기본), 민감 `Cache-Control: no-store, private`
- [ ] (필요 시) `Accept-Ranges: none` 또는 범위/동시성 제한
- [ ] 다운로드 프록시: **도메인 화이트리스트**, 사설 IP 차단, HTTPS 강제, 리디렉션 제한
- [ ] 클라우드: **private 버킷**, 서명 URL 짧은 만료, 오리진 접근 통제
- [ ] 로깅/경보: 경로탈출 패턴/403/404/대량 요청 모니터링
- [ ] 대역폭 보호: 쓰로틀/쿼터/속도 제한
- [ ] 정기 점검: 캐시 정책/버킷 정책/프록시 규칙 리그레션 테스트

---

## 실기 예상문제 (요지/모범 답안)

**1) 문제**: 아래 다운로드 엔드포인트의 보안상 문제 3가지를 쓰고 개선하라.
```js
app.get('/dl', (req, res) => {
  const p = __dirname + '/files/' + req.query.file; // A
  res.setHeader('Content-Disposition', 'attachment; filename="' + req.query.file + '"'); // B
  res.sendFile(p); // C
});
```
- **해설**:
  A) 경로 결합(경로탈출), B) 파일명 반사(헤더 주입/CRLF), C) 권한 미검증.
  **개선**: ID 매핑/권한검증, `resolve` + BASE 검사, `filename*` 인코딩, `nosniff`, `octet-stream`, `no-store`.

**2) 문제**: IDOR 방어에서 “인증”과 “인가”의 차이 및 구현 포인트는?
- **해설**: 인증=누구인지, 인가=무엇을 할 수 있는지. 다운로드는 **리소스 소유권/범위**를 정책 엔진으로 검증.

**3) 문제**: 다운로드 프록시에서 SSRF를 막는 필수 검사는?
- **해설**: 스킴 제한(https), 허용 도메인·경로 화이트리스트, DNS 재확인, 사설/루프백/링크로컬 차단, 리디렉션/헤더 제한.

**4) 문제**: 브라우저 스니핑 방지에 필요한 헤더 2가지는?
- **해설**: `Content-Disposition: attachment`, `X-Content-Type-Options: nosniff`.

**5) 문제**: S3에서 민감 파일 다운로드 시 보안상 권장되는 방법 2가지는?
- **해설**: **서명 URL 단기 발급**, **버킷 private + 오리진 접근 통제**(직접 공개 금지), 필요 시 `ResponseContentDisposition` 설정.

---

## 부록: 작은 수식으로 보는 캐시/권한 리스크
\[
I_{\text{exposure}} \approx P_{\text{cache-misconfig}}\times S_{\text{audience}} + P_{\text{auth-bypass}}\times V_{\text{data}}
\]
- 캐시 오설정 확률과 대상 범위, 권한 우회 확률과 데이터 가치가 유출 영향에 기여.
- 운영 지표: 캐시 정책 검사 자동화(테스트), 인가 실패율·403 비율 모니터링으로 \(P\)를 낮춘다.

---

## 결론
다운로드는 “읽기 권한의 외부화”다. **경로/ID/헤더/프록시/캐시**의 모든 접점에서 방어하지 않으면, 작은 실수로 **전사 데이터 유출**로 번진다.
- **ID 매핑 + 인가 + 경로 정규화**를 기본기로 삼고,
- **첨부/스니핑 방지/캐시 정책**을 표준화하며,
- **서명 URL/오리진 분리/쓰로틀링**으로 운영 리스크를 낮추자.
위 템플릿·체크리스트를 레포지토리 **코딩 규약/미들웨어**로 고착화하면, 실무 품질과 시험 대비가 동시에 강화된다.
