---
layout: post
title: 형식언어와 오토마타 - Mealy 기계의 최소화
date: 2025-08-15 20:20:23 +0900
category: 형식언어와 오토마타
---
# Mealy 기계의 **최소화** — 정의·동치관계·파티션 정제 알고리즘·복잡도·예제·실전 팁

Mealy 기계(결정적)는 **입력 기호를 읽는 즉시** 출력 기호를 내는 유한상태 변환기다.  
최소화(minimization)의 목표는 **동일 변환(입력→출력 스트림)** 을 수행하면서 **상태 수가 최소**인 동치 기계를 만드는 것.  
이 글은 **정의 → 동치관계 → 파티션 정제 알고리즘(기본/가속) → 복잡도 → 예제 → 구현 코드 → 실전 팁** 순서로, 생략 없이 정리한다.  
수식은 $$…$$, 코드는 ```…```로 표기한다.

---

## 0) 표기와 전제(결정적·총기계)

**결정적 Mealy 기계**  
$$
M=(Q,\Sigma,\Gamma,\delta,\lambda,q_0),
$$
- $$Q$$: 유한 상태 집합, $$q_0\in Q$$ 시작 상태  
- $$\Sigma$$: 입력 알파벳, $$\Gamma$$: 출력 알파벳  
- $$\delta:Q\times\Sigma\to Q$$ (다음 상태), $$\lambda:Q\times\Sigma\to\Gamma$$ (출력)

**문자열 확장**(유도 정의)  
$$
\delta^\!(q,\varepsilon)=q,\ \ \delta^\!(q,xa)=\delta\!\big(\delta^\!(q,x),a\big)
$$
$$
\lambda^\!(q,\varepsilon)=\varepsilon,\ \ 
\lambda^\!(q,xa)=\lambda^\!(q,x)\cdot \lambda\!\big(\delta^\!(q,x),a\big).
$$

**총기계화(totalization)**: 미정의 전이가 있다면 **덫 상태** $$\bot$$ 및 고정 출력 $$\gamma_\bot$$ 로 보완해 모든 $$(q,a)$$ 가 정의되게 만든다.  
(동치성/최소화 시 **정의역 차이**가 반례로 잡히지 않도록 안전)

---

## 1) 문제 정식화와 **동치관계**

### 1.1 상태 동치(구별 불가)

상태 $$p,q\in Q$$ 가 **동치**(구별 불가)라 함은
$$
\boxed{\ \forall x\in\Sigma^\*:\ \lambda^\!(p,x)=\lambda^\!(q,x)\ \land\ \delta^\!(p,x)\sim\delta^\!(q,x)\ }
$$
를 만족하는 **가장 작은** 동치관계 $$\sim$$ 속에 함께 있는 것을 뜻한다.  
직관: “이 상태에서 남은 어떤 입력을 읽어도 **출력 스트림이 같고**, 도달 상태도 계속 동치.”

### 1.2 Trim(도달 상태 제한)

최소화 전에
$$
Q \leftarrow \{\,q\in Q\mid q\ \text{is reachable from}\ q_0 \,\}
$$
로 **도달 가능한 상태만** 남긴다.  
(Mealy에는 ‘최종’ 개념이 없으므로 co-accessible 은 필수 아님. 다만 사양상 쓰지 않는 상태는 제거가 보통)

---

## 2) 기본 최소화: **파티션 정제(Moore 방식)**

핵심은 “**같게 보이는 상태끼리 묶고**(분할), **구별 증거**가 생기면 **쪼갠다**(정제)”를 고정점까지 반복하는 것.

### 2.1 서명(signature)

현재 분할 $$\Pi$$(상태→블록)에서, 상태 $$q$$ 의 서명:
$$
\mathrm{Sig}_\Pi(q)\ :=\ \Big( \big(\lambda(q,a),\ [\delta(q,a)]_\Pi\big) \Big)_{a\in\Sigma}.
$$
- 각 입력 $$a$$ 마다 “**이번 스텝 출력**”과 “**다음 상태의 블록 번호**”를 묶는다.
- **같은 서명**이 아니면 **동치 불가**.

### 2.2 알고리즘(의사코드)

```text
Input: Mealy M=(Q,Σ,Γ,δ,λ,q0)

# 0) Trim
Q := reachable_from(q0)

# 1) 초기 분할: '길이 1 출력 벡터'로 거칠게
Π := partition Q by vector V(q) = ( λ(q,a) for a in Σ )

# 2) 반복 정제
repeat
  Π' := partition Q by signature Sig_Π(q) = ( (λ(q,a), class_Π(δ(q,a))) )_{a∈Σ}
  if Π' == Π: break
  Π := Π'
until fixed

# 3) 몫 기계(최소) 구성
상태 집합 Q_min := { 블록 B ∈ Π }
δ_min([q],a) := [ δ(q,a) ]
λ_min([q],a) :=   λ(q,a)
q0_min := [q0]
return M_min
```

**정지 조건**: 어떤 입력으로도 더 쪼개지지 않을 때(불변점).  
**정당성**: 귀납으로, 같은 블록이면 **모든 길이**의 접미 입력에 대해 출력과 도착 블록이 동일 → 동치.

### 2.3 복잡도 상한

- 한 라운드에 서명 구성·분류 비용: $$O(|\Sigma|\cdot |Q|)$$  
- 라운드 최대 $$|Q|$$ → 순진 상한 $$O(|\Sigma|\cdot |Q|^2)$$  
- §3의 Hopcroft 가속으로 $$O(|\Sigma|\cdot |Q|\log |Q|)$$ 근처까지 감소.

---

## 3) **Hopcroft 스타일** 가속(작은쪽 퍼뜨리기)

DFA 최소화의 정제 가속을 그대로 적용하되, **분할 기준이 (출력, 다음 블록) 쌍**임을 반영한다.

### 3.1 아이디어

블록 $$B$$ 가 $$B_1\cup B_2$$ 로 쪼개지면, $$B$$ 로 **a-전이 들어오는** 원소의 서명이 달라질 수 있다.  
→ 모든 블록을 재분류하지 말고, “**영향 받는 블록**”만 갱신(worklist).

### 3.2 의사코드

```text
Π := partition by V(q) = (λ(q,a))_a
W := all blocks of Π                       # worklist (항상 '작은쪽' 우선 꺼내기)

while W not empty:
  S := pop_smallest(W)
  for a in Σ:
    # a로 S에 '들어가는' 전이를 가진 블록만 후보
    for each block B in Π:
      B1 := { q∈B : δ(q,a) ∈ S and λ(q,a)=o1 }  # 출력 값도 함께 구분
      B2 := { q∈B : δ(q,a) ∈ S and λ(q,a)=o2 }  # (출력이 여러 값이면 그 값별로 분할)
      ...
      # 일반적으로 (λ(q,a), δ(q,a)∈S ?) 기준의 다원 분할
      if B가 2개 이상 부분집합으로 나뉘면:
         replace B by the subsets in Π
         push every newly created 'smaller part' into W
return Π
```

- 구현에서는 블록별로 **역전이 목록**(predecessor by a)을 유지하면 후보 탐색이 $$O$$(전이 수)로 떨어진다.
- 실무에선 “(출력, 다음블록)”을 키로 **버킷 분할**하면 깔끔하다.

---

## 4) 작동 예제(완전 전개)

다음 Mealy를 최소화하자.

```text
Σ={0,1}, Γ={x,y}
상태: A(start), B, C, D, E

전이/출력
A --0/y--> B    A --1/y--> C
B --0/y--> B    B --1/x--> C
C --0/x--> D    C --1/x--> C
D --0/x--> D    D --1/x--> C
E --0/y--> B    E --1/x--> C
```

### 4.1 초기 분할(길이 1 출력 벡터)

- A: (y, y)  
- B,E: (y, x)  
- C,D: (x, x)

초기 $$\Pi_0=\{\{A\},\{B,E\},\{C,D\}\}$$.

### 4.2 1라운드: 서명 계산

- 블록 $$[B,E]$$ 에서  
  - $$\mathrm{Sig}(B) = ((y,[B,E]),(x,[C,D]))$$  
  - $$\mathrm{Sig}(E) = ((y,[B,E]),(x,[C,D]))$$ → **동일**, 쪼개지지 않음.

- 블록 $$[C,D]$$ 에서  
  - $$\mathrm{Sig}(C) = ((x,[C,D]),(x,[C,D]))$$  
  - $$\mathrm{Sig}(D) = ((x,[C,D]),(x,[C,D]))$$ → **동일**.

더 이상 분할 없음 → **최소형은 3상태**: $$[A]$$, $$[B,E]$$, $$[C,D]$$.  
전이는 블록 대표로 읽어 구성:

- $$[A]\xrightarrow{0/y}[B,E],\ [A]\xrightarrow{1/y}[C,D]$$  
- $$[B,E]\xrightarrow{0/y}[B,E],\ [B,E]\xrightarrow{1/x}[C,D]$$  
- $$[C,D]\xrightarrow{0/x}[C,D],\ [C,D]\xrightarrow{1/x}[C,D]$$

---

## 5) **동치성 검사**와 최소성·유일성

- Trim된 결정 Mealy 최소형은 **동형(isomorphic)까지 유일**.  
- **동치성 검사**: 두 기계 $$M_1,M_2$$ 에 대해 제품 그래프에서 **출력 불일치**를 탐색한다.

```text
Equal-Mealy(M1,M2):
  queue := [(q01,q02, ε)]
  seen := ∅
  while queue:
    (p,q, w) := pop()
    if (p,q) in seen: continue
    seen.add((p,q))
    for a in Σ:
      if λ1(p,a) != λ2(q,a): return (False, w⋅a)  # 최초 반례
      push(δ1(p,a), δ2(q,a), w⋅a)
  return (True, None)
```

---

## 6) **부분 Mealy**와 덫(Sink) 처리

- $$(q,a)$$ 미정의가 있다면 최소화/동치성 이전에 **총기계화**:
  - $$\delta(q,a)=\bot,\ \lambda(q,a)=\gamma_\bot$$ 고정.
- 총기계화가 부담이면(에러로 처리), 동치성 비교 시 **정의역 차이**(한쪽만 정의)도 반례로 간주해야 한다.

---

## 7) (확장) **문자열 출력**·**최종 출력**이 있는 경우(순차 변환기)

실무에선 전이 출력이 한 글자에 국한되지 않는다: $$\lambda:Q\times\Sigma\to\Gamma^\*$$, 최종 출력 $$\tau:Q\to\Gamma^\*$$.  
이때 바로 병합하면 **공통 접두/접미**가 중복될 수 있으므로:

1) **출력 푸시(output pushing)** 로 **규범형**(canonical form) 정렬  
2) 그 뒤 §2의 파티션 정제를 적용 → 최소화

> 순수 Mealy(전이당 1기호)는 푸시가 항등에 가깝다.

---

## 8) 구현 — **참조용 파이썬 코드**(Trim, 최소화, 동치성, 반례 생성)

### 8.1 자료구조와 유틸

```python
from collections import deque, defaultdict
from typing import Dict, Tuple, Iterable, Hashable, List, Set

State = Hashable
Sym   = Hashable
Out   = Hashable

class DMealy:
    def __init__(self, Q:Set[State], Σ:Set[Sym], Γ:Set[Out],
                 δ:Dict[Tuple[State,Sym], State],
                 λ:Dict[Tuple[State,Sym], Out],
                 q0:State):
        self.Q, self.Σ, self.Γ = set(Q), set(Σ), set(Γ)
        self.δ, self.λ, self.q0 = dict(δ), dict(λ), q0

    def reachable(self) -> Set[State]:
        seen, dq = set(), deque([self.q0])
        while dq:
            q = dq.popleft()
            if q in seen: continue
            seen.add(q)
            for a in self.Σ:
                nq = self.δ.get((q,a))
                if nq is None: continue  # 부분 기계일 수 있음
                dq.append(nq)
        return seen
```

### 8.2 총기계화(선택)

```python
    def totalize(self, sink:State="⟂", sink_out:Out=None):
        if sink_out is None:
            # '특수' 출력이 없다면 마지막 Γ 요소(있다면)나 별도 토큰을 사용
            sink_out = ("<sink>",)
        self.Q.add(sink)
        for a in self.Σ:
            self.δ[(sink,a)] = sink
            self.λ[(sink,a)] = sink_out
        for q in list(self.Q):
            for a in self.Σ:
                if (q,a) not in self.δ:
                    self.δ[(q,a)] = sink
                    self.λ[(q,a)] = sink_out
```

### 8.3 최소화(파티션 정제; 교육용 간결 구현)

```python
    def minimize(self):
        # 0) Trim
        R = self.reachable()
        Q = [q for q in self.Q if q in R]
        idx = {q:i for i,q in enumerate(Q)}

        Σ = list(self.Σ)

        # 1) 초기 분할: 길이1 출력 벡터
        key1 = { q: tuple(self.λ[(q,a)] for a in Σ) for q in Q }
        buckets = {}
        for q in Q:
            buckets.setdefault(key1[q], []).append(q)
        blocks: List[List[State]] = list(buckets.values())

        # 2) 정제 반복
        changed = True
        while changed:
            changed = False
            new_blocks = []
            for B in blocks:
                # (λ(q,a), class(δ(q,a)))_a 로 세분화
                sub = defaultdict(list)
                # 현재 블록 -> 번호 매핑
                where = {}
                for i,Blk in enumerate(blocks):
                    for s in Blk: where[s] = i
                for q in B:
                    sig = []
                    for a in Σ:
                        o = self.λ[(q,a)]
                        nq = self.δ[(q,a)]
                        sig.append((o, where[nq]))
                    sub[tuple(sig)].append(q)
                if len(sub)==1:
                    new_blocks.append(B)
                else:
                    changed = True
                    new_blocks.extend(sub.values())
            blocks = new_blocks

        # 3) 몫 기계 구성
        rep_id = { s:i for i,Blk in enumerate(blocks) for s in Blk }
        Qmin = set(rep_id.values())
        q0m  = rep_id[self.q0]
        δm, λm = {}, {}
        for i,Blk in enumerate(blocks):
            qrep = Blk[0]
            for a in Σ:
                δm[(i,a)] = rep_id[self.δ[(qrep,a)]]
                λm[(i,a)] = self.λ[(qrep,a)]
        Γ = set(λm.values())
        return DMealy(Qmin, set(Σ), Γ, δm, λm, q0m), blocks
```

### 8.4 동치성 및 **반례 입력** 산출

```python
def equal_with_counterexample(M1:DMealy, M2:DMealy):
    # 가정: Σ 동일, 총기계 또는 같은 정의역
    Σ = list(M1.Σ)
    from collections import deque
    dq = deque()
    seen = set()
    dq.append((M1.q0, M2.q0, []))
    while dq:
        p,q,w = dq.popleft()
        if (p,q) in seen: continue
        seen.add((p,q))
        for a in Σ:
            o1 = M1.λ.get((p,a)); o2 = M2.λ.get((q,a))
            if o1 != o2:
                return False, w+[a]
            p2 = M1.δ.get((p,a)); q2 = M2.δ.get((q,a))
            dq.append((p2,q2,w+[a]))
    return True, None
```

**테스트 시나리오**
```python
# 예제 기계(§4) 구성 → 최소화 → 자기 동치/반례 없음 확인
Σ = {"0","1"}; Γ = {"x","y"}
Q = {"A","B","C","D","E"}
δ = {("A","0"):"B",("A","1"):"C",
     ("B","0"):"B",("B","1"):"C",
     ("C","0"):"D",("C","1"):"C",
     ("D","0"):"D",("D","1"):"C",
     ("E","0"):"B",("E","1"):"C"}
λ = {("A","0"):"y",("A","1"):"y",
     ("B","0"):"y",("B","1"):"x",
     ("C","0"):"x",("C","1"):"x",
     ("D","0"):"x",("D","1"):"x",
     ("E","0"):"y",("E","1"):"x"}
M = DMealy(Q, Σ, Γ, δ, λ, "A")
Mmin, _ = M.minimize()
ok, cex = equal_with_counterexample(M, Mmin)
assert ok and cex is None
```

---

## 9) **상태 구분 입력**(distinguishing sequence) 찾기

최소화가 끝난 뒤에도, 검증을 위해 **두 블록을 실제로 구분하는 입력**을 구해두면 유용하다.

### 9.1 재귀적 구성(아이디어)

두 상태 $$(p,q)$$ 에서 **서명**이 다르면, 어떤 입력 $$a$$ 에 대해
- $$\lambda(p,a)\ne \lambda(q,a)$$ 이거나
- $$\lambda$$ 는 같지만 $$\delta(p,a)$$ 와 $$\delta(q,a)$$ 가 **다른 블록**에 속한다.

전자면 바로 구분 입력은 $$a$$.  
후자면 **자식쌍** $$(\delta(p,a),\delta(q,a))$$ 에 대한 구분 입력 $$x$$ 를 찾아 **앞에 $$a$$를 붙인다**.

### 9.2 스케치 코드

```python
def separating_input(M:DMealy, p, q, class_id):
    # class_id: 상태->블록번호(최종 분할 결과)
    if p==q: return None
    for a in M.Σ:
        o1, o2 = M.λ[(p,a)], M.λ[(q,a)]
        if o1 != o2: return [a]
    for a in M.Σ:
        p2, q2 = M.δ[(p,a)], M.δ[(q,a)]
        if class_id[p2] != class_id[q2]:
            tail = separating_input(M, p2, q2, class_id)
            if tail is not None: return [a] + tail
    return None
```

---

## 10) 복잡도 분석(개요)

- **파티션 정제 기반**: 각 라운드 $$O(|\Sigma||Q|)$$, 라운드 수 $$\le |Q|$$ → 순진 $$O(|\Sigma||Q|^2)$$.  
- **Hopcroft 가속**: 스플리터(작은쪽) 퍼뜨리기로 각 전이를 **로그** 번만 관여시키게 하여  
  $$O(|\Sigma|\cdot |Q|\log |Q|)$$ (또는 $$O(|E|\log |Q|)$$) 근처.  
- **메모리**: 전이 수 $$|E|=|Q|\cdot |\Sigma|$$(완전) 기준, 상태/전이/블록 인덱스 배열이 선형.

---

## 11) 자주 틀리는 지점과 **엣지 케이스**

1) **출력 비교 누락**: DFA 습관대로 “다음 블록만” 비교하면 오동작. Mealy는 **출력과 다음 블록** 모두 필요.  
2) **부분 기계**: 정의되지 않은 전이 때문에, 최소화 도중 **KeyError/None** 발생 → **총기계화** 또는 **정의역 검증**이 선행돼야 함.  
3) **대알파벳**: $$|\Sigma|$$ 가 큰 경우, 실제 **등가 전이가 많은 범위**(예: 유니코드 클래스)로 묶어 미리 축소.  
4) **문자열 출력**: 단순 병합은 **공통접두/접미** 중복을 낳음 → **Output Pushing** 후 최소화.  
5) **무의미 상태**: 도달하지만 실제 사양 상 절대 쓰이지 않는 상태(테스트 생성 중 생김)는 Trim에서 제외되지 않을 수 있음 → **사용 맥락 기준 추가 정리**.

---

## 12) 더 깊게: **Nerode-유형** 정식화(개념 스냅샷)

Mealy(순차 함수)에도 DFA의 **오토마타 동치류**에 대응하는 **우측-불변(right-invariant) 합동**이 존재한다.  
출력-언어 $$f:\Sigma^\*\to\Gamma^\*$$ 를 유도하는 변환기에 대해, 접미 $$x\in\Sigma^\*$$ 로 유도되는 **함수의 잔여**를
$$
\phi_q(x)\ :=\ \lambda^\!(q,x)
$$
로 놓으면, $$p\sim q \iff \phi_p=\phi_q$$ 가 된다.  
파티션 정제는 이 **가장 거친 우측-불변 합동**을 계산하는 절차다.

---

## 13) 실전 팁(엔지니어링)

- **정수 인덱싱**: 상태·기호를 0..N-1로 매핑해 배열 인덱싱 → 해시 오버헤드 제거.  
- **희소 전이**: 거대 $$\Sigma$$ 는 dict/압축 맵으로. 미정은 sink로 통일.  
- **역전이 목록**: 스플리터 전파에 필수. `pred[a][S] = {q | δ(q,a)∈S}` 캐시.  
- **테스트 생성**: W-Method/HSI로 상태-구분 입력 자동 생성 → 최소형 검증.  
- **회귀 검증**: 변경 전후 제품 기계로 **최초 불일치 입력**을 리포트(디버깅에 탁월).  
- **성능 병목**: 라운드마다 전체 재해시 대신, **변한 블록 주변만** 재계산.

---

## 14) 보너스 예제: **부분 Mealy**의 총기계화 → 최소화

```text
Σ={a,b}, Γ={0,1}
상태: S(start), A, B
전이/출력
S --a/0--> A
A --a/0--> A,   A --b/1--> B
B --b/1--> B    (A --b/1--> B 외 'S --b', 'B --a' 는 미정의)
```

1) 총기계화: 덫 ⟂, 출력 `?` 도입.  
2) 최소화: ⟂ 는 자기루프, 보통 **단독 블록**. A/B는 출력·도착 차이로 분리 유지.  
3) 동치성 검사 시 `?` 출력을 통해 **정의역 차이**가 곧바로 반례로 노출.

---

## 15) 마무리 **요약**

- **동치**: 모든 접미 입력에 대해 출력이 같고 다음 상태도 동치.  
- **알고리즘**: (출력 벡터) 초기 분할 → **(출력, 다음블록)** 서명 기반 정제 → 고정점 → 몫 기계.  
- **복잡도**: 순진 $$O(|\Sigma||Q|^2)$$, Hopcroft 가속으로 $$O(|\Sigma||Q|\log|Q|)$$ 근처.  
- **실전**: 총기계화·희소 전이·역전이 캐시·작은쪽 퍼뜨리기·테스트 자동화가 핵심.  
- **확장**: 문자열/최종 출력은 **Output Pushing 후** 동일 절차. 최소형은(조건하) 동형까지 **유일**.

---

## 실무 한 장 체크리스트

[입력] 총기계화? 도달 상태만? 대알파벳 압축?
[정제] (λ, next-class) 서명, 작은쪽 퍼뜨리기, 역전이 캐시
[검증] 제품 기계로 동치/반례, 상태 구분 시퀀스(W-Method/HSI)
[경계] 부분 Mealy 정의역 차이, 문자열 출력은 푸시 후 최소화
[성능] 정수 인덱싱·희소 전이·로그 인자 목표(Hopcroft 스타일)
