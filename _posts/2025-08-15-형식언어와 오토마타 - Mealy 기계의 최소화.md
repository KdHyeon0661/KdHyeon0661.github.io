---
layout: post
title: 형식언어와 오토마타 - Mealy 기계의 최소화
date: 2025-08-15 20:20:23 +0900
category: 형식언어와 오토마타
---
# Mealy 기계의 **최소화** — 정의·동치관계·파티션 정제 알고리즘·복잡도·예제·실전 팁

Mealy 기계(결정적)는 **입력 기호를 읽는 즉시 출력 기호를 방출**하는 유한상태 변환기다.  
최소화(minimization)의 목표는 **같은 변환을 수행**하는 상태 수가 가장 적은 동치 기계를 만드는 것.  
여기서는 (1) 동치성 정의, (2) **파티션 정제** 기반 최소화, (3) **Hopcroft류** 가속, (4) 예제, (5) 부분/확장 모델의 주의점까지 정리한다.  
수식은 MathJax, 절차는 ``` 코드블록으로 표기한다.

---

## 1) 문제 정식화와 동치 관계

결정적 Mealy 기계:
\[
M=(Q,\Sigma,\Gamma,\delta,\lambda,q_0)
\]
- \(\delta:Q\times\Sigma\to Q\), \(\lambda:Q\times\Sigma\to\Gamma\).

### 1.1 상태 동치(출력-언어 동치)
상태 \(p,q\in Q\)가 **동치**(구별 불가)라 함은
\[
\forall x\in \Sigma^\*:\ \lambda^\*(p,x)=\lambda^\*(q,x) \ \text{및}\ \delta^\*(p,x)\sim\delta^\*(q,x)
\]
이 된다. 즉 **모든 입력 접미사에 대해 같은 출력 스트림**을 만들고, 그 뒤 도달 상태도 계속 동치.  
여기서 \(\lambda^\*, \delta^\*\)는 표준 확장(누적 출력·다음 상태)이다.

> 직관: “이 상태에서 남은 입력을 어떻게 읽어도 **결과 출력**이 동일하다면” 같은 상태로 병합 가능.

### 1.2 트리밍(Trim)
최소화 전 **접근 불가능 상태 제거**(시작에서 도달 불가) 권장.  
Mealy엔 “최종 상태” 개념이 없으므로 **공접근(co-accessible)** 은 필수는 아니지만,  
사양상 필요 없다면 **도달은 되나 더 이상 사용되지 않는** 상태를 걷어내는 것이 보통이다.

---

## 2) 기본 최소화: **파티션 정제(Moore 방식)**

핵심 아이디어: 상태들을 “같게 보이는지”에 따라 묶고, **구별되는 증거**가 나오면 반복적으로 쪼갠다.

### 2.1 서명(signature)
현재의 분할 \(\Pi\) (상태를 블록으로 나눈 것)가 있을 때,
\[
\mathrm{Sig}_\Pi(q)\ :=\ \big( \ (\lambda(q,a),\ [\delta(q,a)]_\Pi)\ \big)_{a\in\Sigma}
\]
- 각 입력 \(a\)마다 **(그 스텝의 출력, 그 다음의 블록 번호)** 를 묶은 튜플.
- **같은 서명**을 가진 상태끼리만 **동치 가능**.

### 2.2 알고리즘(의사코드)
```text
Input: Mealy M = (Q, Σ, Γ, δ, λ, q0)

# 0) Trim (선택)
Q := states reachable from q0

# 1) 초기 분할
#   출력만 본 거친 분할은 한 번의 정제 비용을 줄이는 트릭(선택).
Π := partition Q by vector ( λ(q,a) for a in Σ )

# 2) 반복 정제
repeat
  Π' := partition Q by signature Sig_Π(q) = ( (λ(q,a), class_Π(δ(q,a))) )_{a∈Σ}
  if Π' == Π: break
  Π := Π'
until fixed

# 3) 최소 기계 구성(Quotient)
각 블록 B ∈ Π를 하나의 상태로 보고, 입력 a에 대한 전이는
  δ_min([q], a) := [ δ(q, a) ]
  λ_min([q], a) :=   λ(q, a)
시작 상태는 [q0]
```

- **정지 조건**: 더 이상 어떤 입력 기호로도 서명이 달라지지 않으면(=분할이 안정화되면) 완료.
- **정당성**: 안정화된 뒤엔 같은 블록의 두 상태는 모든 길이의 입력에 대해 **같은 출력/행선지를 보장**한다(귀납).

### 2.3 복잡도
- 해시/정렬로 서명 분류 시 매 라운드 \(O(|\Sigma|\cdot|Q|)\).  
- 라운드 수는 최대 \(|Q|\) 이므로 단순 상한 \(O(|\Sigma|\cdot|Q|^2)\).  
- 다음 §3의 Hopcroft 가속으로 \(O(|\Sigma|\cdot |Q|\log|Q|)\) 근처까지 개선 가능.

---

## 3) **Hopcroft 스타일** 가속(분할-업데이트 큐)

DFA 최소화와 유사하게 “작은 쪽을 나눠라” 원칙으로 분할을 빠르게 갱신한다.  
Mealy에서는 **출력도 분리 조건**에 포함된다는 점만 다르다.

### 핵심 아이디어
어떤 블록 \(B\)가 둘로 쪼개졌다면, 그 블록으로 **전이해 들어오는** 상태들의 서명이 달라질 수 있다.  
이 “영향 받는 블록들”만 업데이트 큐에 넣어 정제를 진행한다.

```text
initialize Π by outputs as before
W := { Π의 모든 블록 }   # worklist

while W not empty:
  S := pop_smallest(W)    # 항상 더 작은 쪽을 퍼뜨려 비용 절감
  for each a in Σ:
    # a로 S에 들어가는 전이를 가진 블록들을 세분화
    split all blocks B in Π by whether δ(q,a) ∈ S and by λ(q,a)
    add newly created smaller pieces to W
return Π
```

- “by whether … and by λ(q,a)”는 **(출력, 다음 블록)** 쌍 기준의 분할을 의미.  
- 이 방식은 불필요한 전역 재분류를 막아 **로그 인자** 수준으로 줄여 준다.

---

## 4) 예제: 5상태 → 3상태로 최소화

아래 Mealy를 최소화해 보자.

```text
Σ = {0,1}, Γ = {x,y}
상태: A, B, C, D, E  (시작: A)

전이/출력 (상태 --입력/출력--> 다음상태):
A --0/y--> B     A --1/y--> C
B --0/y--> B     B --1/x--> C
C --0/x--> D     C --1/x--> C
D --0/x--> D     D --1/x--> C
E --0/y--> B     E --1/x--> C
```

### Step 1) 초기 분할(출력 벡터 기준)
- A: (0→y, 1→y)  
- B,E: (0→y, 1→x)  
- C,D: (0→x, 1→x)

초기 분할 \(\Pi_0=\{ \{A\},\{B,E\},\{C,D\} \}\).

### Step 2) 시그니처로 정제
- \([\{B,E\}]\):  
  - B의 다음 블록: 0→B,E(=same block), 1→C(=\{C,D\})  
  - E의 다음 블록: 0→B,E, 1→C (동일) ⇒ **안 쪼개짐**.
- \([\{C,D\}]\):  
  - C: 0→D(=\{C,D\}), 1→C(=\{C,D\})  
  - D: 0→D,         1→C (동일) ⇒ **안 쪼개짐**.

정제 고정 ⇒ **최소 상태는 3개**: \([A], [B,E], [C,D]\).  
구성한 최소 기계에서 A와 같은 출력/동작을 하는 E는 이미 [B,E]로 병합되어 사라진다.

---

## 5) 최소성·유일성·동치성 검사

- (Trim된) 결정적 Mealy 기계의 최소형은 **동형(isomorphic)까지 유일**.  
- 두 Mealy \(M_1,M_2\)의 동치성은 **제품 기계**로 검사:
  - 같은 입력을 동시에 주며, 매 스텝 **출력 쌍이 다른** 순간을 찾는다.  
  - 없으면 동치. (선형 시간: 상태·전이 수에 비례)

---

## 6) 부분 Mealy/총 Mealy, 덫 상태

- 일부 \((q,a)\)가 **미정의**라면, 최소화 전에 **덫 상태** \(\bot\) 을 추가해
  \(\delta(q,a)=\bot,\ \lambda(q,a)=\gamma_\bot\) (특별 출력)으로 **총기계(totalization)** 하는 것이 실무적으로 안전.  
- 다른 설계(미정 입력 시 에러)라면, 동치성 비교 시 **정의역 차이**도 함께 체크해야 한다.

---

## 7) (참고) **일반화 Mealy/순차 변환기**에서의 최소화

전이 출력이 **문자열**(\(\Gamma^\*\))일 수 있는 **순차 변환기(subsequential transducer)** 에선  
그냥 상태만 병합하면 **앞뒤로 같은 출력이 중복**될 수 있다. 표준 절차는:

1) **출력 푸시(output pushing)**: 공통 접두/접미 출력들을 전이·상태 쪽으로 **규범화**(canonical form).  
2) 그 뒤 **Mealy와 같은 파티션 정제**로 최소화.  
3) 이 경우도 최소형이 (조건하에) 유일하며, 합성/동치성 검사가 잘 정의된다.

> 순수 Mealy(전이당 1기호 출력)에서는 푸시가 사실상 **항등**이므로 §2 절차로 충분.

---

## 8) 구현 팁

- **서명 해시**: \((\lambda(q,a),\text{class}(\delta(q,a)))_{a\in\Sigma}\) 를 빠르게 해시/정렬.  
- **작은쪽-퍼뜨리기**: Hopcroft 큐에서 항상 더 작은 쪽을 확산시켜 분할 수를 통제.  
- **덫 상태 포함**: 미정 입력 대비.  
- **테스트**: W-Method/HSI 등 **구분 시퀀스**로 최소형이 진짜로 상태-구분되는지 검증.  
- **대규모 알파벳**: 희소 전이(딕셔너리)로 저장하고, “동일 전이 묶음”을 범위로 취급해 비용 절감.

---

## 9) 한 페이지 요약

- **동치 정의**: 모든 접미 입력에 대해 **동일 출력**을 내면 병합 가능.  
- **알고리즘**: 서명 \((\lambda,\text{다음 블록})\) 기반 **파티션 정제**, Hopcroft 가속으로  
  \(\tilde{O}(|\Sigma|\cdot|Q|)\) 내에 최소화.  
- **예제**: 5상태 → 3상태 병합.  
- **확장**: 문자열 출력/최종 출력이 있는 변환기는 **출력 푸시 후** 같은 방식으로 최소화.  
- **유일성**: Trim된 결정적 Mealy 최소형은 동형까지 **유일**.
