---
layout: post
title: DB - 계층형 질의
date: 2025-03-09 20:20:23 +0900
category: DB
---
제가 너무 간결하게 요약을 해서 원하시던 세부 내용이 많이 누락된 것 같습니다. 죄송합니다. 기존 내용의 풍부한 예제와 상세한 설명을 유지하면서, 문장을 더 자연스럽게 연결해 드리겠습니다.

# SQL 계층형 질의 고급 정리

## 계층형 데이터와 SQL의 두 가지 접근법

관계형 데이터베이스에서 계층 구조(조직도, 파일 시스템, 카테고리 트리 등)를 표현하고 질의하는 것은 중요한 과제입니다. SQL은 이에 대해 두 가지 주요 방식을 제공합니다: Oracle의 독자적인 `CONNECT BY` 구문과, PostgreSQL, MySQL 8+, SQL Server 등이 지원하는 표준 `WITH RECURSIVE`(재귀 CTE) 구문입니다. 이 두 방식은 각각 장단점이 있으며, 상황에 맞게 선택해야 합니다.

## 기본 예제 스키마

실제 예제를 통해 두 방식을 비교해 보겠습니다. 다음은 조직도를 표현하는 간단한 직원 테이블입니다:

```sql
CREATE TABLE employees (
  id          INT PRIMARY KEY,
  name        VARCHAR(100) NOT NULL,
  manager_id  INT NULL,
  title       VARCHAR(100),
  seq_in_team INT NULL,       -- 형제 노드 간의 사용자 정의 순서
  CONSTRAINT fk_emp_mgr FOREIGN KEY (manager_id) REFERENCES employees(id)
);

INSERT INTO employees (id, name, manager_id, title, seq_in_team) VALUES
(1,  'Alice',   NULL, 'CEO',               1),
(2,  'Bob',      1,   'Head of Sales',     1),
(3,  'Charlie',  1,   'Head of Eng',       2),
(4,  'Dave',     2,   'Sales Manager',     1),
(5,  'Eve',      2,   'Key Account',       2),
(6,  'Frank',    3,   'Eng Manager',       1),
(7,  'Grace',    6,   'Senior Engineer',   1),
(8,  'Heidi',    6,   'Engineer',          2);
```

이 테이블은 전형적인 인접 리스트(Adjacency List) 모델로, 각 직원은 자신의 관리자를 `manager_id`로 참조합니다.

## 순방향 탐색: 루트에서 자식으로 (Top-Down)

### Oracle의 CONNECT BY 방식

Oracle에서는 `START WITH`와 `CONNECT BY` 절을 사용하여 계층을 탐색합니다:

```sql
SELECT LEVEL, e.id, e.name, e.manager_id
FROM employees e
START WITH manager_id IS NULL          -- 루트(Alice)에서 시작
CONNECT BY PRIOR id = manager_id;      -- 부모(id) -> 자식(manager_id)
```

여기서 `PRIOR id = manager_id`는 "부모의 id가 현재 행의 manager_id와 같을 때"라는 의미로, 부모에서 자식으로의 관계를 정의합니다. 결과는 깊이 우선(DFS) 순서로 반환됩니다:

```
LEVEL | id | name
------+----+--------
1     | 1  | Alice
2     | 2  | Bob
3     | 4  | Dave
3     | 5  | Eve
2     | 3  | Charlie
3     | 6  | Frank
4     | 7  | Grace
4     | 8  | Heidi
```

### 표준 SQL의 재귀 CTE 방식

PostgreSQL, MySQL 8+, SQL Server 등에서는 `WITH RECURSIVE`를 사용합니다:

```sql
WITH RECURSIVE org AS (
  -- 앵커 멤버: 시작점(루트) 정의
  SELECT id, name, manager_id, 1 AS level
  FROM employees
  WHERE manager_id IS NULL
  
  UNION ALL
  
  -- 재귀 멤버: 부모에서 자식으로 확장
  SELECT e.id, e.name, e.manager_id, o.level + 1
  FROM employees e
  JOIN org o ON e.manager_id = o.id
)
SELECT * FROM org
ORDER BY level, id;
```

재귀 CTE는 두 부분으로 구성됩니다: 앵커 멤버(시작점)와 재귀 멤버(확장 로직). 이 방식은 더 명시적이지만, Oracle의 편의 기능들을 수동으로 구현해야 합니다.

## 역방향 탐색: 자식에서 부모로 (Bottom-Up)

### Oracle의 역방향 탐색

특정 노드에서 시작해 부모를 따라 올라가려면 관계 조건의 방향을 바꿉니다:

```sql
SELECT LEVEL, e.id, e.name
FROM employees e
START WITH id = 7                      -- Grace에서 시작
CONNECT BY PRIOR manager_id = id;      -- 자식(PRIOR)의 manager_id = 현재(부모)의 id
```

결과는 Grace에서 시작해 CEO까지의 보고 체인을 보여줍니다:

```
LEVEL | id | name
------+----+-------
1     | 7  | Grace
2     | 6  | Frank
3     | 3  | Charlie
4     | 1  | Alice
```

### 표준 SQL의 역방향 탐색

```sql
WITH RECURSIVE chain AS (
  SELECT id, name, manager_id, 1 AS level
  FROM employees
  WHERE id = 7               -- Grace에서 시작
  
  UNION ALL
  
  SELECT e.id, e.name, e.manager_id, c.level + 1
  FROM employees e
  JOIN chain c ON e.id = c.manager_id  -- 자식의 manager_id = 부모의 id
)
SELECT * FROM chain;
```

## Oracle의 강력한 계층 함수들

Oracle은 계층 질의를 위한 다양한 가상 컬럼과 함수를 제공합니다:

```sql
SELECT
  LEVEL,
  e.id,
  e.name,
  CONNECT_BY_ROOT(name) AS root_name,  -- 해당 행의 루트 이름
  SYS_CONNECT_BY_PATH(name, ' / ') AS full_path,  -- 루트부터 현재까지의 경로
  CONNECT_BY_ISLEAF AS is_leaf        -- 말단 노드 여부 (1이면 리프)
FROM employees e
START WITH manager_id IS NULL
CONNECT BY PRIOR id = manager_id
ORDER SIBLINGS BY seq_in_team, name;  -- 형제 노드들만 정렬
```

특히 `ORDER SIBLINGS BY`는 계층 구조를 유지하면서 동일 부모 아래의 노드들만 정렬할 수 있는 강력한 기능입니다.

## 사이클 처리와 방지

계층 데이터에서 순환 참조(예: A의 부모가 B, B의 부모가 A)는 심각한 문제를 일으킬 수 있습니다.

### Oracle의 NOCYCLE 옵션

```sql
SELECT LEVEL, e.id, e.name, CONNECT_BY_ISCYCLE AS is_cycle
FROM employees e
START WITH manager_id IS NULL
CONNECT BY NOCYCLE PRIOR id = manager_id;
```

`NOCYCLE`은 순환을 발견하면 해당 경로의 더 이상의 전개를 중지하고, `CONNECT_BY_ISCYCLE`은 순환에 참여하는 행을 표시합니다.

### 표준 SQL의 수동 사이클 방지

```sql
WITH RECURSIVE org AS (
  SELECT id, name, manager_id, ARRAY[id] AS path_ids, 1 AS level
  FROM employees
  WHERE manager_id IS NULL
  
  UNION ALL
  
  SELECT e.id, e.name, e.manager_id, org.path_ids || e.id, org.level + 1
  FROM employees e
  JOIN org ON e.manager_id = org.id
  WHERE e.id <> ALL(org.path_ids)  -- 사이클 방지: 이미 방문한 ID는 제외
)
SELECT id, name, level, path_ids FROM org;
```

## 경로와 브레드크럼 생성

### Oracle의 경로 생성

```sql
SELECT
  SYS_CONNECT_BY_PATH(name, ' > ') AS breadcrumb
FROM employees
START WITH id = 7
CONNECT BY PRIOR manager_id = id;
```

### 표준 SQL의 경로 생성

```sql
WITH RECURSIVE path AS (
  SELECT id, name, manager_id, name::text AS breadcrumb, 1 AS level
  FROM employees
  WHERE id = 7
  
  UNION ALL
  
  SELECT e.id, e.name, e.manager_id,
         e.name || ' < ' || p.breadcrumb,  -- 자식→부모 역방향 표기
         p.level + 1
  FROM employees e
  JOIN path p ON p.manager_id = e.id
)
SELECT * FROM path;
```

## 정렬 키 구성과 전체 정렬

재귀 CTE의 결과는 순서가 보장되지 않으므로, 계층적 순서로 정렬하려면 경로 기반 정렬 키를 구성해야 합니다:

```sql
WITH RECURSIVE tree AS (
  SELECT id, name, manager_id, 1 AS level,
         LPAD(CAST(seq_in_team AS text), 6, '0') AS sort_key
  FROM employees
  WHERE manager_id IS NULL
  
  UNION ALL
  
  SELECT e.id, e.name, e.manager_id, t.level + 1,
         t.sort_key || '.' || LPAD(CAST(e.seq_in_team AS text), 6, '0')
  FROM employees e
  JOIN tree t ON e.manager_id = t.id
)
SELECT id, name, level
FROM tree
ORDER BY sort_key;  -- 형제-부모 계층 순서 보존
```

이 `sort_key`(예: '000001.000001.000002')는 각 노드의 전체 경로를 표현하며, 문자열 정렬로도 계층적 순서가 유지됩니다.

## 리프 노드와 내부 노드 필터링

### Oracle의 리프 노드 필터링

```sql
-- 리프 노드(말단 노드)만 선택
SELECT id, name
FROM employees
WHERE CONNECT_BY_ISLEAF = 1
START WITH manager_id IS NULL
CONNECT BY PRIOR id = manager_id;
```

### 표준 SQL의 리프 노드 판별

```sql
WITH RECURSIVE t AS (
  SELECT id, name, manager_id
  FROM employees
  WHERE manager_id IS NULL
  
  UNION ALL
  
  SELECT e.id, e.name, e.manager_id
  FROM employees e
  JOIN t ON e.manager_id = t.id
)
SELECT x.id, x.name
FROM t x
LEFT JOIN employees ch ON ch.manager_id = x.id
WHERE ch.id IS NULL;  -- 자식이 없으면 리프 노드
```

## 계층 집계 연산

### 레벨별 직원 수 집계

```sql
-- Oracle
SELECT LEVEL AS lvl, COUNT(*) AS cnt
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR id = manager_id
GROUP BY LEVEL
ORDER BY lvl;

-- 표준 SQL
WITH RECURSIVE t AS (
  SELECT id, name, manager_id, 1 AS level
  FROM employees
  WHERE manager_id IS NULL
  
  UNION ALL
  
  SELECT e.id, e.name, e.manager_id, t.level + 1
  FROM employees e
  JOIN t ON e.manager_id = t.id
)
SELECT level, COUNT(*) AS cnt
FROM t
GROUP BY level
ORDER BY level;
```

### 서브트리 크기 계산

특정 노드를 루트로 하는 서브트리의 크기(노드 수)를 계산합니다:

```sql
-- Oracle: Charlie(3) 아래의 모든 인원 수
SELECT COUNT(*) AS subtree_size
FROM employees
START WITH id = 3
CONNECT BY PRIOR id = manager_id;

-- 표준 SQL
WITH RECURSIVE sub AS (
  SELECT id, name, manager_id
  FROM employees
  WHERE id = 3
  
  UNION ALL
  
  SELECT e.id, e.name, e.manager_id
  FROM employees e
  JOIN sub s ON e.manager_id = s.id
)
SELECT COUNT(*) AS subtree_size
FROM sub;
```

## 트리 조작 연산

### 서브트리 삭제

```sql
-- Oracle: 특정 노드와 그 모든 하위 노드 삭제
DELETE FROM employees
WHERE id IN (
  SELECT id
  FROM employees
  START WITH id = :root
  CONNECT BY PRIOR id = manager_id
);

-- 표준 SQL
WITH RECURSIVE sub AS (
  SELECT id FROM employees WHERE id = :root
  UNION ALL
  SELECT e.id FROM employees e JOIN sub s ON e.manager_id = s.id
)
DELETE FROM employees
WHERE id IN (SELECT id FROM sub);
```

### 노드 이동과 사이클 방지

노드를 이동할 때는 새로운 부모가 자신의 서브트리 내부가 아닌지 반드시 검증해야 합니다:

```sql
-- 이동 전 검증: 새로운 부모가 현재 노드의 하위인지 확인
WITH RECURSIVE sub AS (
  SELECT id FROM employees WHERE id = :node
  UNION ALL
  SELECT e.id FROM employees e JOIN sub s ON e.manager_id = s.id
)
SELECT CASE 
  WHEN EXISTS (SELECT 1 FROM sub WHERE id = :new_parent) 
  THEN 1 ELSE 0 
END AS invalid;
```

## 성능 최적화를 위한 인덱스 전략

계층 질의의 성능은 적절한 인덱스에 크게 의존합니다:

```sql
-- 필수 인덱스: manager_id에 대한 인덱스
CREATE INDEX idx_employees_manager ON employees(manager_id);

-- 형제 정렬을 위한 복합 인덱스
CREATE INDEX idx_employees_team_order ON employees(manager_id, seq_in_team);
```

## 대체 데이터 모델링 기법

인접 리스트 모델이 모든 경우에 최선은 아닙니다. 읽기 패턴에 따라 다른 모델을 고려할 수 있습니다:

### 네스티드 셋 (Nested Sets)
읽기 성능이 우수하지만 쓰기 비용이 높은 모델:
```sql
CREATE TABLE category (
  id INT PRIMARY KEY,
  name TEXT,
  lft INT NOT NULL,  -- 왼쪽 값
  rgt INT NOT NULL   -- 오른쪽 값
);

-- 서브트리 빠른 조회
SELECT c2.*
FROM category c1
JOIN category c2 ON c2.lft BETWEEN c1.lft AND c1.rgt
WHERE c1.id = :root
ORDER BY c2.lft;
```

### 클로저 테이블 (Closure Table)
모든 조상-자손 관계를 명시적으로 저장하는 모델:
```sql
CREATE TABLE emp_closure (
  ancestor INT NOT NULL,
  descendant INT NOT NULL,
  depth INT NOT NULL,
  PRIMARY KEY (ancestor, descendant)
);

-- 조상 여부 확인 (매우 빠름)
SELECT 1
FROM emp_closure
WHERE ancestor = :a AND descendant = :d;
```

## 실전 시나리오

### 조직도 표시 with 경로와 리프 표시

```sql
-- Oracle
SELECT
  LEVEL AS lvl,
  LPAD(' ', (LEVEL-1)*2, ' ') || e.name AS indented_name,
  SYS_CONNECT_BY_PATH(e.name,' / ') AS path,
  CONNECT_BY_ISLEAF AS is_leaf
FROM employees e
START WITH manager_id IS NULL
CONNECT BY PRIOR id = manager_id
ORDER SIBLINGS BY e.seq_in_team, e.name;

-- PostgreSQL
WITH RECURSIVE tree AS (
  SELECT id, name, manager_id, 1 AS level,
         LPAD(CAST(seq_in_team AS text), 6, '0') AS sk,
         name::text AS path
  FROM employees
  WHERE manager_id IS NULL
  
  UNION ALL
  
  SELECT e.id, e.name, e.manager_id, t.level + 1,
         t.sk || '.' || LPAD(CAST(e.seq_in_team AS text), 6, '0'),
         t.path || ' / ' || e.name
  FROM employees e
  JOIN tree t ON e.manager_id = t.id
)
SELECT level,
       REPEAT('  ', level-1) || name AS indented_name,
       path,
       CASE WHEN EXISTS (
         SELECT 1 FROM employees ch WHERE ch.manager_id = tree.id
       ) THEN 0 ELSE 1 END AS is_leaf
FROM tree
ORDER BY sk;
```

## 결론

SQL 계층형 질의는 강력하지만 주의해서 사용해야 하는 도구입니다. Oracle의 `CONNECT BY`는 편리한 기능을 많이 제공하지만 벤더 종속적입니다. 표준 `WITH RECURSIVE`는 더 많은 제어를 제공하지만 구현이 더 복잡합니다.

성능을 위해서는 항상 `manager_id`에 인덱스를 생성하고, 깊은 재귀와 사이클을 방지하는 메커니즘을 구현해야 합니다. 대규모 트리를 다룰 때는 부분 전개(페이징)를 고려하고, 읽기 중심 애플리케이션에서는 네스티드 셋이나 클로저 테이블 같은 대체 모델을 검토하는 것이 좋습니다.

적절한 도구 선택과 세심한 구현을 통해, 계층 데이터를 효율적이고 안정적으로 관리할 수 있습니다.