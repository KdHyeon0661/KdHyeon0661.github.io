---
layout: post
title: DB - 계층형 질의
date: 2025-03-09 20:20:23 +0900
category: DB
---
# SQL 계층형 질의 고급 정리

## 예제 스키마(공통)

```sql
-- 공용 예제: 조직(직원) 트리
CREATE TABLE employees (
  id          INT PRIMARY KEY,
  name        VARCHAR(100) NOT NULL,
  manager_id  INT NULL,
  title       VARCHAR(100),
  seq_in_team INT NULL,       -- 형제 간 사용자 정의 순서
  CONSTRAINT fk_emp_mgr FOREIGN KEY (manager_id) REFERENCES employees(id)
);

INSERT INTO employees (id, name, manager_id, title, seq_in_team) VALUES
(1,  'Alice',   NULL, 'CEO',               1),
(2,  'Bob',      1,   'Head of Sales',     1),
(3,  'Charlie',  1,   'Head of Eng',       2),
(4,  'Dave',     2,   'Sales Manager',     1),
(5,  'Eve',      2,   'Key Account',       2),
(6,  'Frank',    3,   'Eng Manager',       1),
(7,  'Grace',    6,   'Senior Engineer',   1),
(8,  'Heidi',    6,   'Engineer',          2);
```

---

## 전개 방향 — 순방향(부모→자식) vs 역방향(자식→부모)

### Oracle (순방향)

```sql
SELECT LEVEL, e.id, e.name, e.manager_id
FROM employees e
START WITH manager_id IS NULL          -- 루트(Alice)
CONNECT BY PRIOR id = manager_id;      -- 부모(id) -> 자식(manager_id)
```

**의미**
- `PRIOR id = manager_id` : **PRIOR(부모)**의 id가 **현재(자식)**의 manager_id와 같을 때 하향 전개
- 루트에서 **DFS(깊이 우선)** 순서로 내려간다(정렬 지정 전).

**예시 결과(개념)**

```
LEVEL | id | name
------+----+--------
1     | 1  | Alice
2     | 2  | Bob
3     | 4  | Dave
3     | 5  | Eve
2     | 3  | Charlie
3     | 6  | Frank
4     | 7  | Grace
4     | 8  | Heidi
```

### Oracle (역방향: 자식→부모 체인)

```sql
SELECT LEVEL, e.id, e.name
FROM employees e
START WITH id = 7                      -- Grace에서 시작
CONNECT BY PRIOR manager_id = id;      -- 자식(PRIOR)의 manager_id = 현재(부모)의 id
```

**결과 개념**

```
LEVEL | id | name
------+----+-------
1     | 7  | Grace
2     | 6  | Frank
3     | 3  | Charlie
4     | 1  | Alice
```

### SQL 표준(CTE) — 순방향

**PostgreSQL / MySQL 8+ / SQL Server**

```sql
WITH RECURSIVE org AS (
  -- 앵커(루트)
  SELECT id, name, manager_id, 1 AS level
  FROM employees
  WHERE manager_id IS NULL
  UNION ALL
  -- 재귀(부모->자식)
  SELECT e.id, e.name, e.manager_id, o.level + 1
  FROM employees e
  JOIN org o ON e.manager_id = o.id
)
SELECT * FROM org
ORDER BY level, id;
```

### SQL 표준(CTE) — 역방향

```sql
WITH RECURSIVE chain AS (
  SELECT id, name, manager_id, 1 AS level
  FROM employees
  WHERE id = 7               -- Grace에서 시작
  UNION ALL
  SELECT e.id, e.name, e.manager_id, c.level + 1
  FROM employees e
  JOIN chain c ON e.id = c.manager_id
)
SELECT * FROM chain;
```

---

## Oracle 계층 가상 컬럼/함수의 활용

| 이름 | 설명 | 예 |
|---|---|---|
| `LEVEL` | 깊이(루트=1) | `SELECT LEVEL, ...` |
| `CONNECT_BY_ISLEAF` | 말단(leaf) 여부(1/0) | `SELECT CONNECT_BY_ISLEAF` |
| `CONNECT_BY_ISCYCLE` | 순환 포함 여부(1/0) | `SELECT CONNECT_BY_ISCYCLE` |
| `CONNECT_BY_ROOT(col)` | 해당 행의 루트의 col | `CONNECT_BY_ROOT(name)` |
| `SYS_CONNECT_BY_PATH(col, delim)` | 루트→현재 경로 문자열 | `SYS_CONNECT_BY_PATH(name,' / ')` |

```sql
SELECT
  LEVEL,
  e.id,
  e.name,
  CONNECT_BY_ROOT(name) AS root_name,
  SYS_CONNECT_BY_PATH(name, ' / ') AS full_path,
  CONNECT_BY_ISLEAF AS is_leaf
FROM employees e
START WITH manager_id IS NULL
CONNECT BY PRIOR id = manager_id
ORDER SIBLINGS BY seq_in_team, name;
```

**포인트**
- `ORDER SIBLINGS BY` : **형제 정렬**(동일 부모 밑에서 순서 보장)
- `CONNECT_BY_ROOT`와 `SYS_CONNECT_BY_PATH`로 **브레드크럼/경로**를 즉시 산출

---

## 순환(CYCLE) 처리 — `NOCYCLE`, `CONNECT_BY_ISCYCLE`, SQL 표준의 방법

### Oracle: 순환 방지/표시

```sql
SELECT LEVEL, e.id, e.name, CONNECT_BY_ISCYCLE AS is_cycle
FROM employees e
START WITH manager_id IS NULL
CONNECT BY NOCYCLE PRIOR id = manager_id;
```

- `NOCYCLE` : 순환 발견 시 해당 경로 더 이상 **전개하지 않음**
- `CONNECT_BY_ISCYCLE` : 그 행이 순환의 일부면 1

### SQL 표준: 경로 추적으로 사이클 차단

PostgreSQL / MySQL 8+ 에서는 **경로(visited set)**를 들고 다니며 검증한다.

```sql
-- PostgreSQL 예시: visited 배열로 사이클 방지
WITH RECURSIVE org AS (
  SELECT id, name, manager_id, ARRAY[id] AS path_ids, 1 AS level
  FROM employees
  WHERE manager_id IS NULL
  UNION ALL
  SELECT e.id, e.name, e.manager_id, org.path_ids || e.id, org.level + 1
  FROM employees e
  JOIN org ON e.manager_id = org.id
  WHERE e.id <> ALL(org.path_ids)     -- 사이클 차단
)
SELECT id, name, level, path_ids FROM org;
```

SQL Server, MySQL 8+도 문자열 누적(구분자 포함) 또는 JSON/CSV 누적 방식으로 **멤버십 검사**를 구현한다(성능 고려 필요).

---

## 경로/브레드크럼/번호 매기기

### Oracle — 경로 문자열

```sql
SELECT
  SYS_CONNECT_BY_PATH(name, ' > ') AS breadcrumb
FROM employees
START WITH id = 7
CONNECT BY PRIOR manager_id = id;
```

### SQL 표준 — 경로 문자열

```sql
-- Postgres: 문자열 누적
WITH RECURSIVE path AS (
  SELECT id, name, manager_id, name::text AS breadcrumb, 1 AS level
  FROM employees
  WHERE id = 7
  UNION ALL
  SELECT e.id, e.name, e.manager_id,
         e.name || ' < ' || p.breadcrumb,  -- 자식->부모 역방향 표기
         p.level + 1
  FROM employees e
  JOIN path p ON p.manager_id = e.id
)
SELECT * FROM path;
```

### 계층 번호(Outline Numbering: 1, 1.1, 1.1.1 …)

```sql
-- Oracle: LEVEL과 형제 순서를 이용한 번호(간단 버전)
SELECT
  LPAD(' ', (LEVEL-1)*2, ' ') ||
  LEVEL || '.' || seq_in_team || ' ' || name AS outline
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR id = manager_id
ORDER SIBLINGS BY seq_in_team, name;
```

> 완전한 **1.2.3** 스타일은 형제의 누적 순번을 트래킹해야 하므로, 재귀 CTE에서 `ROW_NUMBER() OVER(PARTITION BY parent ORDER BY …)`를 상위에서 넘겨 받는 **경로 누적**으로 구현한다(성능 주의).

---

## 형제 정렬(ORDER SIBLINGS) & 전체 정렬

- Oracle: `ORDER SIBLINGS BY`로 **동부모 형제 간** 정렬을 보장
- SQL 표준: 재귀 CTE는 **출력 정렬 보장 없음** → 정렬 기준을 **경로 키**로 만들어 최종 `ORDER BY`에 사용

```sql
-- Postgres: 경로 키 만들기(예: zfill로 문자열 정렬 안정화)
WITH RECURSIVE tree AS (
  SELECT id, name, manager_id, 1 AS level,
         LPAD(CAST(seq_in_team AS text), 6, '0') AS sort_key
  FROM employees
  WHERE manager_id IS NULL
  UNION ALL
  SELECT e.id, e.name, e.manager_id, t.level + 1,
         t.sort_key || '.' || LPAD(CAST(e.seq_in_team AS text), 6, '0')
  FROM employees e
  JOIN tree t ON e.manager_id = t.id
)
SELECT id, name, level
FROM tree
ORDER BY sort_key;   -- 형제-부모 계층 순서 보존
```

---

## 리프(말단) 노드/내부 노드 필터링

### Oracle

```sql
-- 리프만
SELECT id, name
FROM employees
WHERE CONNECT_BY_ISLEAF = 1
START WITH manager_id IS NULL
CONNECT BY PRIOR id = manager_id;

-- 내부(자식이 있는) 노드만
SELECT id, name
FROM employees
WHERE CONNECT_BY_ISLEAF = 0
START WITH manager_id IS NULL
CONNECT BY PRIOR id = manager_id;
```

### SQL 표준

```sql
-- Postgres: 자식 존재 여부로 판정
WITH RECURSIVE t AS (
  SELECT id, name, manager_id
  FROM employees
  WHERE manager_id IS NULL
  UNION ALL
  SELECT e.id, e.name, e.manager_id
  FROM employees e
  JOIN t ON e.manager_id = t.id
)
SELECT x.id, x.name
FROM t x
LEFT JOIN employees ch ON ch.manager_id = x.id
WHERE ch.id IS NULL;     -- 자식 없음 = leaf
```

---

## 레벨별 집계, 서브트리 집계(부하 수, 매출 합계 등)

### Oracle — 레벨별 카운트

```sql
SELECT LEVEL AS lvl, COUNT(*) AS cnt
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR id = manager_id
GROUP BY LEVEL
ORDER BY lvl;
```

### SQL 표준 — 레벨별 카운트

```sql
WITH RECURSIVE t AS (
  SELECT id, name, manager_id, 1 AS level
  FROM employees
  WHERE manager_id IS NULL
  UNION ALL
  SELECT e.id, e.name, e.manager_id, t.level + 1
  FROM employees e
  JOIN t ON e.manager_id = t.id
)
SELECT level, COUNT(*) AS cnt
FROM t
GROUP BY level
ORDER BY level;
```

### 서브트리(특정 상사 이하) 총원

**Oracle**

```sql
-- 3(Charlie) 이하의 인원 수
SELECT COUNT(*) AS subtree_size
FROM employees
START WITH id = 3
CONNECT BY PRIOR id = manager_id;
```

**SQL 표준**

```sql
WITH RECURSIVE sub AS (
  SELECT id, name, manager_id
  FROM employees
  WHERE id = 3
  UNION ALL
  SELECT e.id, e.name, e.manager_id
  FROM employees e
  JOIN sub s ON e.manager_id = s.id
)
SELECT COUNT(*) AS subtree_size
FROM sub;
```

---

## 삭제/이동/삽입 — 트리 조작 패턴

> 계층 구조를 **Adjacency List(부모 포인터)**로 설계했을 때 기준

### 서브트리 삭제

**Oracle**

```sql
DELETE FROM employees
WHERE id IN (
  SELECT id
  FROM employees
  START WITH id = :root
  CONNECT BY PRIOR id = manager_id
);
```

**SQL 표준**

```sql
WITH RECURSIVE sub AS (
  SELECT id FROM employees WHERE id = :root
  UNION ALL
  SELECT e.id FROM employees e JOIN sub s ON e.manager_id = s.id
)
DELETE FROM employees
WHERE id IN (SELECT id FROM sub);
```

### 서브트리 이동(부서 이동)

```sql
-- 특정 노드 X를 새 상사 Y 밑으로
UPDATE employees
SET manager_id = :new_parent
WHERE id = :node;
```

> **사이클 방지**: `:new_parent`가 `:node`의 **서브트리 내부**인지 **사전 검증** 필요.

```sql
-- 금지: new_parent가 node의 하위인 경우
WITH RECURSIVE sub AS (
  SELECT id FROM employees WHERE id = :node
  UNION ALL
  SELECT e.id FROM employees e JOIN sub s ON e.manager_id = s.id
)
SELECT CASE WHEN EXISTS (SELECT 1 FROM sub WHERE id = :new_parent) THEN 1 ELSE 0 END AS invalid;
```

### 삽입(형제 사이 순서 제어 포함)

```sql
-- 형제 끝에 추가
INSERT INTO employees (id, name, manager_id, title, seq_in_team)
VALUES (:id, :name, :parent, :title,
        (SELECT COALESCE(MAX(seq_in_team), 0) + 1 FROM employees WHERE manager_id = :parent));
```

---

## 페이징/검색/필터 — 대규모 트리에서의 UX 패턴

- **부분 전개(Expand-on-demand)**: 루트만, 또는 특정 노드의 **직계 자식만** 단계적으로 로딩
- **키셋 페이징**: `OFFSET` 대신 `(sort_key, id)` **커서 기반 페이징**
- **검색과 전개**: 키워드에 매칭된 노드 **+ 조상 경로**를 함께 반환(브레드크럼/하이라이트)

```sql
-- 키워드 매칭 노드와 그 조상 경로(PostgreSQL)
WITH RECURSIVE hit AS (
  SELECT id, name, manager_id
  FROM employees
  WHERE name ILIKE '%' || :q || '%'
),
anc AS (
  SELECT h.id, h.name, h.manager_id
  FROM hit h
  UNION
  SELECT e.id, e.name, e.manager_id
  FROM employees e
  JOIN anc a ON a.manager_id = e.id
)
SELECT DISTINCT * FROM anc;
```

---

## 성능/인덱스/옵티마이저 팁

- **필수 인덱스**: `(manager_id)` — 자식 탐색용, `(id)`는 PK
- **형제 정렬**: `seq_in_team`, `name` 등 정렬 키 인덱스 고려
- **재귀 깊이 제한**: 비정상 트리 방지(`LEVEL <= :max_depth` 또는 CTE에서 카운터)
- **통계 최신화**: 재귀/계층 계획 품질 전제
- **부분 집계의 선행**: 큰 트리에서 서브트리 집계는 **한 번 내려가며 누적**(CTE 내부 집계)
- **경로 문자열 누적 주의**: 길이 폭증 → 필요 시 **ID 배열/JSON**으로 내부 유지, 최종에만 표현 변환
- **사이클 방지 조건**: 경로-멤버십 검사 시 인덱스 미사용 → 데이터량 크면 **클로저 테이블** 고려

---

## 모델링 대안 — Adjacency vs Materialized Path vs Nested Set vs Closure

| 모델 | 장점 | 단점 | 쓰임새 |
|---|---|---|---|
| **Adjacency List**(부모 포인터) | 단순, DML 쉬움 | 경로/집계/정렬 계산 비용 | 일반 OLTP, 조직도 |
| **Materialized Path**(경로 문자열/배열) | 경로/브레드크럼 빠름, prefix 검색 | 문자열 갱신 비용, 충돌 처리 | CMS/카테고리, 경로 UI |
| **Nested Set**(lft/rgt) | 서브트리 조회/집계 빠름 | 삽입/이동 비용 큼 | 읽기 위주(카탈로그, 메뉴) |
| **Closure Table**(모든 조상-자손 쌍) | 경로/집계/존재검사 빠름 | 보조 테이블 유지 비용 | 복잡 쿼리/권한 상속 |

> 읽기 비중↑ → Nested Set/Closure,
> 쓰기/이동↑ → Adjacency/Materialized Path.

### Nested Set 예(읽기 최적)

```sql
CREATE TABLE category (
  id INT PRIMARY KEY,
  name TEXT,
  lft INT NOT NULL,
  rgt INT NOT NULL
);

-- 서브트리 빠른 조회
SELECT c2.*
FROM category c1
JOIN category c2 ON c2.lft BETWEEN c1.lft AND c1.rgt
WHERE c1.id = :root
ORDER BY c2.lft;
```

### Closure Table 예(권한/집계, 다루기 쉬움)

```sql
CREATE TABLE emp_closure (
  ancestor INT NOT NULL,
  descendant INT NOT NULL,
  depth INT NOT NULL,
  PRIMARY KEY (ancestor, descendant)
);

-- 조상 여부
SELECT 1
FROM emp_closure
WHERE ancestor = :a AND descendant = :d;

-- 서브트리
SELECT e.*
FROM emp_closure c
JOIN employees e ON e.id = c.descendant
WHERE c.ancestor = :root;
```

---

## 실전 시나리오 ① — “조직도: 루트→자식, 형제 정렬, 경로, 리프만”

**Oracle**

```sql
SELECT
  LEVEL AS lvl,
  LPAD(' ', (LEVEL-1)*2, ' ') || e.name AS indented_name,
  SYS_CONNECT_BY_PATH(e.name,' / ') AS path,
  CONNECT_BY_ISLEAF AS is_leaf
FROM employees e
START WITH manager_id IS NULL
CONNECT BY PRIOR id = manager_id
ORDER SIBLINGS BY e.seq_in_team, e.name;
```

**PostgreSQL**

```sql
WITH RECURSIVE tree AS (
  SELECT id, name, manager_id, 1 AS level,
         LPAD(CAST(seq_in_team AS text), 6, '0') AS sk,
         name::text AS path
  FROM employees
  WHERE manager_id IS NULL
  UNION ALL
  SELECT e.id, e.name, e.manager_id, t.level + 1,
         t.sk || '.' || LPAD(CAST(e.seq_in_team AS text), 6, '0'),
         t.path || ' / ' || e.name
  FROM employees e
  JOIN tree t ON e.manager_id = t.id
)
SELECT level,
       repeat('  ', level-1) || name AS indented_name,
       path,
       CASE WHEN EXISTS (SELECT 1 FROM employees ch WHERE ch.manager_id = tree.id)
            THEN 0 ELSE 1 END AS is_leaf
FROM tree
ORDER BY sk;
```

---

## 실전 시나리오 ② — “부하 수, 말단 수, 최대 깊이”

**PostgreSQL**

```sql
-- 특정 상사(id = 3) 서브트리의 인원수/리프수/최대 레벨
WITH RECURSIVE sub AS (
  SELECT id, name, manager_id, 1 AS level
  FROM employees WHERE id = 3
  UNION ALL
  SELECT e.id, e.name, e.manager_id, s.level + 1
  FROM employees e
  JOIN sub s ON e.manager_id = s.id
),
leaf AS (
  SELECT s.id
  FROM sub s
  LEFT JOIN employees ch ON ch.manager_id = s.id
  WHERE ch.id IS NULL
)
SELECT
  (SELECT COUNT(*) FROM sub)        AS nodes,
  (SELECT COUNT(*) FROM leaf)       AS leaves,
  (SELECT MAX(level) FROM sub)      AS max_depth;
```

**Oracle**

```sql
-- 동일 요구: Oracle
WITH sub AS (
  SELECT LEVEL AS lvl, e.*
  FROM employees e
  START WITH id = 3
  CONNECT BY PRIOR id = manager_id
)
SELECT
  COUNT(*) AS nodes,
  SUM(CASE WHEN CONNECT_BY_ISLEAF = 1 THEN 1 ELSE 0 END) AS leaves,
  MAX(lvl) AS max_depth
FROM sub;
```

---

## 성능/스케일: 트리 폭발 방지 체크리스트

1. **인덱스**: `(manager_id)` 필수, 정렬키 보조
2. **깊이 제한**: `LEVEL <= :N` / `level <= :N`
3. **사이클 차단**: `NOCYCLE` / 경로-멤버십 검사
4. **부분 전개**: 한 번에 전체트리 **금지**(UX도 분할)
5. **서브트리 캐시/스냅샷**: 잦은 동일 질의는 **머티리얼라이즈드 뷰** 또는 **Closure Table** 병행
6. **경로/정렬키 사전작성**: 읽기 집중 시스템은 **Materialized Path**/`sort_key` 저장
7. **대규모 삭제/이동**: 트랜잭션 크기 제어, 락 경합/로그 부하 고려

---

## 보너스 — SQL 표준의 CYCLE 구문(지원 DB 한정)

Oracle의 **재귀 서브쿼리 팩터링(Recursive Subquery Factoring)**에는 `CYCLE` 사용 가능(버전에 따라).
PostgreSQL/MySQL 8+는 미지원 → 수동 구현.

```sql
-- Oracle: 재귀 WITH + CYCLE
WITH t (id, manager_id, path) AS (
  SELECT id, manager_id, TO_CHAR(id) FROM employees WHERE manager_id IS NULL
  UNION ALL
  SELECT e.id, e.manager_id, t.path || '>' || e.id
  FROM employees e JOIN t ON e.manager_id = t.id
)
CYCLE id SET is_cycle TO 'Y' DEFAULT 'N'
SELECT * FROM t;
```

---

## 실무 안전 가이드(요약)

- **전개 방향**을 정확히 선택(부모→자식 vs 자식→부모)
- Oracle OUTER·형제 정렬·경로는 전용 기능 적극 활용
- 표준 CTE는 **경로 키/정렬 키**를 만들어 최종 정렬
- **사이클 방지**(NOCYCLE / 경로 검사)와 **깊이 제한**은 필수
- 트리 조작(삭제/이동/삽입)은 **사전 검증**과 트랜잭션 제어
- 큰 트리는 **모델링 대안**(Nested Set/Closure/Materialized Path)도 검토

---

## 부록 — 테스트 데이터(루트 2개, 순환 샘플 포함)

```sql
-- 다중 루트와 순환 케이스
INSERT INTO employees (id, name, manager_id, title, seq_in_team) VALUES
(100, 'X-Root', NULL, 'RootX', 1),
(101, 'X-A',    100,  'X-A',   1),
(102, 'X-B',    100,  'X-B',   2);

-- 사이클(의도적으로 잘못된 데이터): 11 -> 12 -> 13 -> 11
INSERT INTO employees (id, name, manager_id, title, seq_in_team) VALUES
(11, 'Cycle-1', 13, 'C1', 1),
(12, 'Cycle-2', 11, 'C2', 1),
(13, 'Cycle-3', 12, 'C3', 1);
```

**Oracle: 사이클 차단 전개**

```sql
SELECT id, name, CONNECT_BY_ISCYCLE AS cyc
FROM employees
START WITH manager_id IS NULL
CONNECT BY NOCYCLE PRIOR id = manager_id;
```

**PostgreSQL: 사이클 회피 전개**

```sql
WITH RECURSIVE t AS (
  SELECT id, name, manager_id, ARRAY[id] AS path
  FROM employees
  WHERE manager_id IS NULL
  UNION ALL
  SELECT e.id, e.name, e.manager_id, t.path || e.id
  FROM employees e
  JOIN t ON e.manager_id = t.id
  WHERE e.id <> ALL(t.path)
)
SELECT id, name FROM t;
```

---

## 자주 묻는 질문(FAQ)

**Q1. 재귀 CTE의 결과 순서는 보장되나요?**
A. **보장되지 않는다**. 반드시 최종 `ORDER BY`에 **경로 기반 키**(예: `sort_key`)를 사용하라.

**Q2. 깊이가 매우 깊은 트리는 위험하지 않나?**
A. 스택/메모리 스필, 무한 재귀 위험이 있다. **최대 깊이 제한**과 **사이클 차단**을 기본으로 두라.

**Q3. 댓글/카테고리 UI는 어떤 모델이 좋나?**
A. 읽기 중심·정렬/브레드크럼 강조면 **Materialized Path** 또는 **Nested Set**을 고려. 이동이 잦다면 Adjacency + `sort_key` 저장.

**Q4. 대량 삭제/이동은 어떻게 안전하게?**
A. **서브트리 선정 → 검증(사이클, FK 제약) → 배치/분할 트랜잭션**. 필요한 경우 백그라운드 잡으로.

---

## 한 장 요약

- **Oracle**: `LEVEL`, `SYS_CONNECT_BY_PATH`, `CONNECT_BY_ISLEAF`, `ORDER SIBLINGS BY`, `NOCYCLE`
- **표준(CTE)**: `WITH RECURSIVE`, **경로/정렬 키 수동 구성**, **사이클 검사 수동**
- **모델링**: Adjacency(단순), Materialized Path(경로), Nested Set(읽기집계), Closure(관계 캐시)
- **성능**: `(manager_id)` 인덱스, 깊이 제한, 전개 범위 축소, 캐싱/스냅샷

> 계층형 질의는 **언어 기능(Oracle/CTE)**와 **모델링**을 적절히 조합해야,
> “**정확성·성능·유지보수성**”을 함께 충족한다.
