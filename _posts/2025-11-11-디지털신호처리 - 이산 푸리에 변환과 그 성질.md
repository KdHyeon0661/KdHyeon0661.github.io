---
layout: post
title: 디지털신호처리 - 이산 푸리에 변환과 그 성질
date: 2025-11-11 18:25:23 +0900
category: 디지털신호처리
---
# 이산 푸리에 변환(DFT)과 그 성질

## 맥락과 목표

앞서 **DFS**로 “주기 신호의 완전 분해”, **DTFT**로 “무한 길이 이산 신호의 주파수 표현”, **Z-변환**으로 “복소 z-평면 표현”을 정리했다. 이번 글은 **유한 길이 데이터**를 다루는 **DFT**를 체계적으로 정리한다. 핵심은:

- **정의/스케일**(공학 스케일 vs 단위수정), **축 매핑**
- **성질**(선형성/시프트/변조/반전/켤레대칭/원형 컨볼루션/상관/Parseval)
- **유한 길이 효과**: 누출, 스캘러핑, 피켓펜스, 창 선택(ENBW, Coherent Gain), **진폭 보정**
- **제로패딩**의 정확한 의미(보간 vs 해상도)
- **FFT 실전**: Overlap-Add/Save, 상호스펙트럼·지연 추정(GCC-PHAT), Welch 평균, 수치 이슈

모든 수식은 $$\LaTeX$$, 코드는 **GNU Octave**로 검증한다.

---

## DFT 정의와 스케일

### 정의(공학 스케일; Octave/FFT 관례)

길이 \(N\) 시퀀스 \(x[n]\), \(n=0,\dots,N-1\):
$$
X[k]=\sum_{n=0}^{N-1} x[n]\ e^{-j\frac{2\pi}{N}kn},\qquad k=0,\dots,N-1.
$$
역변환:
$$
x[n]=\frac{1}{N}\sum_{k=0}^{N-1} X[k]\ e^{+j\frac{2\pi}{N}kn}.
$$
DFS와의 관계: \(c_k=X[k]/N\) (DFS 계수는 DFT를 \(1/N\)로 스케일한 것).

### 단위수정(unitary) 스케일(참고)

$$
\tilde{X}[k]=\frac{1}{\sqrt{N}}\sum_{n} x[n]e^{-j\frac{2\pi}{N}kn},\quad
x[n]=\frac{1}{\sqrt{N}}\sum_{k} \tilde{X}[k]e^{+j\frac{2\pi}{N}kn}.
$$
이때 Parseval이 \(\sum|x|^2=\sum|\tilde{X}|^2\)로 간단해진다.

### 축 매핑(샘플링 주파수 \(F_s\))

- 디지털 각주파수: \(\omega_k=2\pi k/N\)
- 물리 주파수: \(f_k = k(F_s/N)\)
- 대칭 보기: `fftshift`로 \(-\pi\!\to\!\pi\) 정렬

---

## DFT의 기본 성질

### 선형성

$$
\alpha x[n]+\beta y[n] \xleftrightarrow{\mathcal{F}_N} \alpha X[k]+\beta Y[k].
$$

### 시간(원형) 시프트

$$
y[n]=x[(n-n_0)\!\!\mod N] \Rightarrow Y[k]=X[k]\,e^{-j\frac{2\pi}{N}kn_0}.
$$

### 주파수 시프트(지수 곱)

$$
y[n]=x[n]e^{+j\frac{2\pi}{N}m_0 n} \Rightarrow Y[k]=X[(k-m_0)\!\!\mod N].
$$

### 시간 반전

$$
y[n]=x[-n\!\!\mod N] \Rightarrow Y[k]=X[-k\!\!\mod N].
$$

### 켤레대칭(실수 입력)

$$
x[n]\in\mathbb{R}\Rightarrow X[k]=X^\ast[-k\!\!\mod N].
$$

### 원형 컨볼루션

$$
y[n]=(x\overset{N}{\circledast}h)[n] \Rightarrow Y[k]=X[k]H[k].
$$

### 원형 자기/상호상관

자기상관 \(r_{xx}[m]=\sum_n x[n]x^\ast[(n-m)\!\!\mod N]\)에 대해
$$
R_{xx}[k]=|X[k]|^2,\qquad R_{xy}[k]=X[k]Y^\ast[k].
$$

### Parseval

$$
\sum_{n=0}^{N-1}|x[n]|^2=\frac{1}{N}\sum_{k=0}^{N-1}|X[k]|^2.
$$

---

## 유한 길이 효과 — 누출·스캘러핑·피켓펜스·창

### 누출(Spectral Leakage)

정합(coherent) 샘플링이 아니라면, 관측 창(보통 직사창)의 주파수 응답(Dirichlet 커널)과의 **컨볼루션**으로 에너지가 주변 bin으로 퍼진다.

### 스캘러핑 손실(Scalloping Loss)

톤이 bin 중앙에서 벗어나면(예: 반-bin), 창의 주엽 곡선 때문에 **피크 진폭이 저하**된다. 직사는 약 \(\sim 3.9\) dB, Hann은 \(\sim 1\!\sim\!1.5\) dB 수준(정확 값은 창·오프셋에 의존).

### 창(Window) 지표 — CG와 ENBW

길이 \(N\) 창 \(w[n]\)에 대해
- **Coherent Gain(CG)**: 정현파 진폭 보정 상수
  $$
  \mathrm{CG}=\frac{1}{N}\sum_{n=0}^{N-1}w[n]
  $$
- **ENBW(Equivalent Noise Bandwidth)**: 잡음 대역폭(“bin” 단위)
  $$
  \mathrm{ENBW}_{\text{bins}} = \frac{N\sum w[n]^2}{\left(\sum w[n]\right)^2}
  $$
  (Hz 단위는 \(\mathrm{ENBW}_{\text{Hz}} = \mathrm{ENBW}_{\text{bins}}\cdot \frac{F_s}{N}\))

- **메인로브 폭**(첫 영점 간격, 대략 bin 수): Rect \(\approx 2\), Hann/Hamming \(\approx 4\), Blackman \(\approx 6\) …
  사이드로브를 낮추면 메인로브가 넓어진다(해상도 희생).

### 피켓펜스(Picket-Fence) 효과

DFT는 **격자(bin)**에서만 샘플한다. **제로패딩**은 **보간**을 제공하지만, **새 정보**를 만들지 않는다(해상도는 관측 길이가 결정).

---

## 진폭 보정과 주파수/진폭 추정

### 단일 톤의 진폭 보정(창 적용 시)

창 \(w\)를 곱한 데이터 \(\tilde x[n]=x[n]w[n]\)의 FFT를 \(X_w[k]\)라 하면, 단일 톤(정합 또는 피크-근방 보간)의 **단측 진폭** 추정은
$$
\hat A \approx \frac{2}{N\cdot\mathrm{CG}}\ \max_k |X_w[k]|.
$$
(비정합일 때는 QIFFT/Quinn/Macleod 등의 **피크 보간**으로 \(\max_k\) 근방 3점 이상을 사용.)

### PSD(Periodogram) 스케일

Welch/periodogram 스타일 PSD:
$$
S_{xx}[k] = \frac{|X_w[k]|^2}{F_s \cdot N \cdot U},\qquad
U=\frac{1}{N}\sum_{n=0}^{N-1} w[n]^2.
$$
여기서 \(U\)는 에너지 보정을 위한 **창 정규화 상수**.

---

## 제로패딩의 의미(정확히)

길이 \(N\)에 \(Z\)개 제로를 더해 \(N'=N+Z\)로 FFT하면 **bin 간격** \(F_s/N'\)이 줄어 **스펙트럼 곡선이 부드럽게 보간**된다.
> 해상도(두 근접 톤을 분리하는 능력)는 **관측 시간/창**이 결정한다. 제로패딩은 해상도를 **늘리지 않는다**.

---

## GNU Octave 유틸 — 창 지표/보정 함수

```octave
function [CG, ENBW_bins, U] = window_metrics(w)
  % w: row/col vector
  w = w(:).';
  N = numel(w);
  CG = sum(w)/N;
  ENBW_bins = N*sum(w.^2)/(sum(w)^2);
  U = sum(w.^2)/N;             % periodogram 보정용
end

function [Ahat, fhat] = quad_peak_est(X, Fs, N, kp)
  % 3점 포물선 보간(대략적). X: 복소 FFT, kp: 피크 인덱스(1..N)
  % 반환: 진폭(보정 전), 주파수(Hz)
  k = kp; km = mod(k-2, N)+1; kp1 = mod(k, N)+1;
  S_1 = log(abs(X(km))+eps); S0 = log(abs(X(k))+eps); S1 = log(abs(X(kp1))+eps);
  delta = 0.5*(S_1 - S1)/(S_1 - 2*S0 + S1 + eps);
  fhat = ((k-1) + delta) * (Fs/N);
  % 꼭지점에서의 추정 크기(로그-포물선 역변환; 단순화)
  Ahat = exp(S0 - 0.25*(S_1 - S1)*delta);
end
```

---

## 기본 실험 — DFT/누출/창/보정

```octave
clear; close all; clc; pkg load signal
Fs=48000; N=2048; n=0:N-1; t=n/Fs;

% 비정합 톤(빈 중앙에서 0.37 bin 오프셋)
f0 = (200 + 0.37)*Fs/N; x = cos(2*pi*f0*t);

% 창들
W.rect = ones(1,N);
W.hann = hann(N)';      % 또는 hanning(N)'
W.hamm = hamming(N)';
W.black= blackman(N)';
W.kais = kaiser(N,8)';

names = fieldnames(W);
figure(1); hold on
for i=1:numel(names)
  w = W.(names{i});
  [CG, ENBW_bins, U] = window_metrics(w);
  X = fft(x.*w);
  f = (0:N-1)*Fs/N;
  plot(f, 20*log10(abs(X)+1e-12));
  printf("%10s: CG=%.4f, ENBW(bins)=%.3f\n", names{i}, CG, ENBW_bins);
end
grid on; xlim([0 6000]); xlabel('Hz'); ylabel('dB');
title('Leakage vs Window (비정합 톤)'); legend(names{:});

% 진폭 보정 비교
w = W.hann; [CG, ~, ~] = window_metrics(w);
Xh = fft(x.*w); [~,kpk] = max(abs(Xh));
[Araw, fhat] = quad_peak_est(Xh, Fs, N, kpk);
Ahat = (2/(N*CG))*Araw;      % 단측 진폭 추정
fprintf("Hann 보정: f≈%.2f Hz, A≈%.4f (이론 1.0)\n", fhat, Ahat);
```

---

## Parseval 확인

```octave
clear; close all; clc
N=3000; x=randn(1,N);
X=fft(x);
lhs = sum(abs(x).^2);
rhs = (1/N)*sum(abs(X).^2);
printf("Parseval diff = %.3e\n", abs(lhs-rhs));
```

---

## 원형 시프트/주파수 시프트/반전 성질 검증

```octave
clear; close all; clc
N=256; n=0:N-1; x = randn(1,N); X = fft(x); k=0:N-1;

n0=17; xs = circshift(x, [0 n0]); Xs = fft(xs);
err1 = norm(Xs - X.*exp(-1j*2*pi*k*n0/N))/norm(Xs);

m0=5; y = x .* exp(1j*2*pi*m0*n/N); Y = fft(y);
err2 = norm(Y - X([end-m0+1:end 1:end-m0]))/norm(Y);

z = x(mod(-n,N)+1); Z=fft(z);
err3 = norm(Z - X(mod(-k,N)+1))/norm(Z);

printf("shift err=%.2e, freq-shift err=%.2e, reversal err=%.2e\n", err1, err2, err3);
```

---

## 원형 vs 선형 컨볼루션, Overlap-Add/Save

### 원형과 선형의 차이

```octave
clear; close all; clc
x = randn(1,300); h = hamming(41)'; N = numel(x);

y_lin = conv(x,h);   % 선형
% 같은 길이에서의 원형
yc = ifft( fft(x).*fft([h zeros(1,N-numel(h))]) );

% 패딩으로 선형 구현
L = N+numel(h)-1;
y_fft = ifft( fft(x, L).*fft(h, L) );

printf("lin vs circ RMS in first N = %.2e\n", rms(y_lin(1:N)-yc));
printf("lin vs padded-FFT RMS      = %.2e\n", rms(y_lin - y_fft));
```

### Overlap-Add(OLA) 구현

```octave
function y = fft_conv_ola(x, h, L)
  M = numel(h); Nfft = 2^nextpow2(L+M-1);
  H = fft(h, Nfft);
  y = zeros(1, numel(x)+M-1);
  idx = 1; out = 1;
  while idx <= numel(x)
    blk = x(idx:min(idx+L-1,numel(x)));
    Yb = ifft( fft(blk, Nfft).*H );
    y(out:out+Nfft-1) += Yb;
    idx += L; out += L;
  endwhile
end

% 테스트
clear; close all; clc
x = randn(1,60000); h = fir1(1000, 0.25); L=4096;
tic; y1 = fft_conv_ola(x,h,L); t1=toc;
tic; y2 = conv(x,h); t2=toc;
printf("OLA %.3fs vs conv %.3fs, RMS=%.2e\n", t1, t2, rms(y1-y2));
```

> Overlap-Save(OLS)는 블록 입력에 FIR 길이-1만큼 **overlap**을 두고 **컨볼루션 앞부분을 폐기**하는 방식. 실시간 스트리밍에 유리.

---

## 상관/상호스펙트럼/지연 추정(GCC-PHAT)

```octave
clear; close all; clc
Fs=48000; N=8192; n=0:N-1;
x = randn(1,N);
delay = 73; h = [zeros(1,delay) 1]; y = conv(x,h,'same');  % 순수 지연
X=fft(x); Y=fft(y);
Gxy = X.*conj(Y);
PHAT = Gxy./(abs(Gxy)+1e-12);
r = real(ifft(PHAT));
[~,kmax] = max(r);
tau = mod(kmax-1 + N/2, N) - N/2;  % [-N/2, N/2)
fprintf("Estimated integer delay ≈ %d samples\n", tau);
```

**잡음/에코**가 있으면 Welch 평균(여러 프레임 평균)으로 추정 안정도를 높인다.

---

## 제로패딩과 보간(해상도 아님)

```octave
clear; close all; clc
Fs=48000; N=256; n=0:N-1; t=n/Fs;
f0=1234.5; x=cos(2*pi*f0*t);
X1=fft(x);
N2=4096; X2=fft(x, N2);
f1=(0:N-1)*Fs/N; f2=(0:N2-1)*Fs/N2;
subplot(2,1,1); plot(f1, abs(X1)); xlim([0 5000]); grid on; title('N=256');
subplot(2,1,2); plot(f2, abs(X2)); xlim([0 5000]); grid on; title('N=4096 (zero-padded)');
```

---

## 실수 신호의 켤레대칭과 fftshift

```octave
clear; close all; clc
N=1024; x=randn(1,N); X=fft(x);
dev=0; for k=0:N-1, km=mod(-k,N); dev=max(dev, abs(X(k+1)-conj(X(km+1)))); end
printf("conjugate symmetry dev (real x) = %.2e\n", dev);

Y = fftshift(X); f = (-N/2:N/2-1)*(1/N);
plot(f, 20*log10(abs(Y)+1e-12)); grid on
xlabel('normalized freq'); title('fftshifted spectrum');
```

---

## 스캘러핑 손실 수치 관찰

```octave
clear; close all; clc; pkg load signal
Fs=48000; N=4096; n=0:N-1; t=n/Fs;
w = hann(N)'; [CG,~,~]=window_metrics(w);

offs = linspace(0,0.5,101); Aest=zeros(size(offs));
for i=1:numel(offs)
  f0 = (100 + offs(i))*Fs/N;
  x = cos(2*pi*f0*t);
  X = fft(x.*w);
  [~,kpk] = max(abs(X));
  [Araw, ~] = quad_peak_est(X, Fs, N, kpk);
  Aest(i) = (2/(N*CG))*Araw;
end
plot(offs, 20*log10(Aest+1e-12)); grid on
xlabel('bin offset'); ylabel('Amplitude error [dB]');
title('Scalloping vs offset (Hann, 보정+3점 보간)');
```

---

## Welch 평균과 PSD

```octave
clear; close all; clc; pkg load signal
Fs=48000; x=randn(1, 10*Fs);   % 백색 잡음
Nseg=1024; noverlap=512; w=hann(Nseg)'; [~,~,U]=window_metrics(w);
step=Nseg-noverlap;

% 수동 Welch
K=floor((numel(x)-noverlap)/step);
Pxx=zeros(1,Nseg);
for i=1:K
  idx=(1:Nseg)+(i-1)*step;
  xw = x(idx).*w;
  X = fft(xw);
  Pxx += (abs(X).^2)/(Fs*Nseg*U);
end
Pxx = Pxx/K;
f=(0:Nseg-1)*Fs/Nseg;
plot(f, 10*log10(Pxx+1e-18)); grid on
xlabel('Hz'); ylabel('PSD [dB/Hz]'); title('Welch PSD (수동 구현)');
```

---

## FFT 성능·수치 이슈 체크리스트

- **복잡도**: FFT는 \(O(N\log N)\). 2의 거듭제곱 길이가 보통 빠르다.
- **실수 입력 최적화**: 실수 \(x\) → **반만** 저장/처리 가능(알고리즘적으로).
- **스케일 일관성**: FFT/ifft의 \(1/N\) 위치는 구현마다 다르다. 진폭·에너지 계산 시 확인 필수.
- **창 보정**: 단일 톤 진폭은 \(2/(N\cdot \mathrm{CG})\) 스케일, PSD는 \(1/(F_s N U)\) 스케일.
- **수치 동적 범위**: 매우 작은 톤/큰 잡음에서 언더/오버플로 대비(더블 정밀).
- **정합 샘플링**: 가능하다면 bin 정합으로 누출/스캘러핑 최소화.
- **평균/중앙값 평균**: 스펙트럼 분산 감소(Welch, 오버랩 50% 전후).
- **창 선택**: 사이드로브(누출) ↔ 메인로브(분해능) 트레이드오프 + ENBW(잡음 레벨 바이어스)까지 함께 고려.

---

## 연습문제(풀이/코드 포함)

### 문제 1) 시프트 성질

**과제**: \(n_0=13\) 원형 시프트에 대해 위상 변화가 \(-2\pi k n_0/N\)임을 수치로 보이라.
**힌트**: §9 코드에서 \(n_0\) 변경.

### 문제 2) 창 비교(ENBW·CG)

**과제**: Rect/Hann/Hamming/Blackman/Kaiser(\(\beta=8\))의 CG·ENBW를 표로 정리하고, 같은 톤에 대해 dB 스펙트럼을 겹쳐 그려라.
**코드**: §7의 출력/플롯 활용.

### 문제 3) 스캘러핑 곡선

**과제**: bin 오프셋을 0~0.5까지 스윕해 직사/Hann/Hamming의 진폭 추정 오차(dB)를 비교 플롯하라.
**코드**: §14를 창만 바꿔 반복.

### 문제 4) 제로패딩 보간

**과제**: \(N=512\), \(N'=8192\)로 제로패딩해 피크 주파수·진폭 추정 차이를 비교하라(보간은 개선되지만 해상도는 동일).
**코드**: §12 + §6의 `quad_peak_est` 활용.

### 문제 5) FFT 컨볼루션 성능

**과제**: 길이 100k 신호와 2001탭 FIR에서 `conv` vs OLA/OLS 실행 시간을 비교하고 RMS 오차를 측정하라.
**힌트**: §10.2 함수 사용, `tic;toc`.

### 문제 6) GCC-PHAT 지연 추정

**과제**: 다양한 지연(정수/비정수)과 SNR에서 GCC-PHAT을 적용하고, 평균 프레임 수에 따른 MSE 변화를 측정하라.
**힌트**: §11 코드 반복 + 가우시안 잡음 추가.

---

## 핵심 공식 요약

- **DFT/IDFT**
  $$
  X[k]=\sum_{n=0}^{N-1} x[n]e^{-j2\pi kn/N},\quad
  x[n]=\frac{1}{N}\sum_{k=0}^{N-1} X[k]e^{+j2\pi kn/N}.
  $$
- **Parseval**
  $$
  \sum_{n}|x[n]|^2=\frac{1}{N}\sum_k|X[k]|^2.
  $$
- **원형 컨볼루션**
  $$
  y[n]=x\overset{N}{\circledast}h \ \Leftrightarrow\ Y[k]=X[k]H[k].
  $$
- **자기/상호스펙트럼**
  $$
  R_{xx}[k]=|X[k]|^2,\quad R_{xy}[k]=X[k]Y^\ast[k].
  $$
- **창 지표**
  $$
  \mathrm{CG}=\frac{1}{N}\sum w[n],\qquad \mathrm{ENBW}_{\text{bins}}=\frac{N\sum w[n]^2}{(\sum w[n])^2}.
  $$
- **단측 진폭 보정(정현파)**
  $$
  \hat A \approx \frac{2}{N\cdot \mathrm{CG}}\max_k |X_w[k]|.
  $$

---

## 결론

DFT는 유한 길이 데이터의 표준 주파수 해석 도구다. **대수 성질**(시프트·컨볼루션·Parseval)을 정확히 적용하는 동시에, **유한 길이 효과**(누출, 스캘러핑, 창의 ENBW/CG, 제로패딩의 의미)를 이해해야 올바른 **진폭/주파수 추정**과 안정적인 **FFT 기반 필터링**이 가능하다.
본문의 Octave 코드를 변형해 **자신의 신호·창·관측길이·패딩·평균** 조합을 실험하고, 이론과 실전의 간극을 수치로 확인하라.
