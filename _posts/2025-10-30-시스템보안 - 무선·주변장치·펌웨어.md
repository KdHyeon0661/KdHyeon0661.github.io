---
layout: post
title: 시스템보안 - 무선·주변장치·펌웨어
date: 2025-10-30 20:30:23 +0900
category: 시스템보안
---
# 15. 무선·주변장치·펌웨어

현대 시스템의 신뢰 뿌리는 **펌웨어(UEFI/BIOS)**이며, 외부 입력의 가장 큰 관문은 **USB(HID/스토리지/CDC/네트워킹)**입니다.  
공격자는 **부팅 전후의 신뢰 체인**과 **주변장치의 드라이버·정책 빈틈**을 노립니다. 방어자는 다음을 보장해야 합니다.

- 부팅 시 **신뢰 부팅(Verified/Secure Boot)** + **측정 부팅(Measured Boot)** → **위조된 부트로더/커널 실행 불가** & **증거(측정값) 남김**
- OS 레벨에서 **장치 신뢰 정책**(허용 목록, 클래스 제어, 속도/행위 이상 탐지)과 **로깅/경고/격리**

---

## 15.1 BIOS/UEFI, Secure Boot 체인

### 15.1.1 UEFI 부팅 체인 개요(Verified Boot vs Measured Boot)

- **Verified/Secure Boot(검증 부팅)**  
  ① 펌웨어(UEFI)가 **다음 단계 실행 파일의 서명**을 **검증**(승인: `db`, 차단: `dbx`)  
  ② 일반적 체인: `UEFI firmware → (shim) → bootloader(Grub/Windows Boot Manager) → kernel(및 initramfs)`  
  ③ 서명 신뢰의 뿌리: **PK**(Platform Key), **KEK**, **db(허용)**, **dbx(취소/차단 목록)**

- **Measured Boot(측정 부팅)**  
  - 각 단계의 바이너리 해시(이벤트)를 **TPM PCR(Platform Configuration Register)**에 **순차적으로 확장(extend)**  
  - 이후 원격 서버/EDR가 **TPM quote(서명 응답)**으로 **“그때의 부팅 상태”**를 확인 → **무결성 증명(Attestation)**

- **상호 보완**  
  - **Secure Boot**는 “실행 전 **정당한 서명**인가”를 보장  
  - **Measured Boot**는 “실행 당시 **무엇이 실행**되었나”를 증명(사후 검증·정책 연계)

> 운영 팁: **CSM 끄기(Legacy BIOS off)**, **dbx 최신화**, **정책적으로 shim/부트로더 버전 고정**, **TPM eventlog 수집**.

---

### 15.1.2 키 계층(PK/KEK/db/dbx)과 SBAT(서브-컴포넌트 폐기)

- **PK(Platform Key)**: 펌웨어 설정의 최상위 권한(보통 OEM/엔터프라이즈)  
- **KEK**: db/dbx 갱신을 **권한 있는 주체**가 할 수 있도록 서명 권한 위임  
- **db**: 부팅 허용 목록(부트로더·커널·shim 서명 인증서/해시)  
- **dbx**: **취소 목록**(취약/리콜된 바이너리/서명) — 업데이트가 매우 중요  
- **SBAT**(Shim Bootloader AUtomatic Trust DB): 컴포넌트 버전별 **세분화된 폐기**(취약 shim 특정 버전만 차단) 지원

---

### 15.1.3 공격 벡터(개념)

- **부트킷/부트로더 교체**: 서명 검사를 우회·비활성화된 환경에서 악성 부트로더 주입  
- **Option ROM/서드파티 드라이버**: 펌웨어/드라이버 초기화 경로에서 서명/정책 미흡  
- **SMM(SMI) 취약점**: 고권한 펌웨어 실행 문맥(SMM) 결함  
- **dbx 미갱신**: 이미 공개된 취약 shim/부트로더가 **차단되지 않음**

> 방어 핵심: **Secure Boot 강제 + dbx 최신화 + CSM OFF + 펌웨어/OPROM 업데이트 + SPI 플래시 쓰기 보호**.

---

### 15.1.4 실무 점검 예제(Windows / Linux)

#### A) Windows: Secure Boot/TPM 상태 확인 (PowerShell)
```powershell
# Secure Boot 켜짐?
Confirm-SecureBootUEFI

# TPM 상태 및 PCR 읽기(요약)
Get-Tpm
# 자세 PCR 값(예: 0~7/11 등)은 tpmtool 명령 참조
tpmtool getdeviceinformation
```

#### B) Linux: Secure Boot 상태/커널 서명 확인
```bash
# Secure Boot 상태
mokutil --sb-state

# 커널 이미지/모듈 서명 검증(배포 도구에 따라 상이)
sbverify --list /boot/vmlinuz-$(uname -r)     # sbverify 패키지 필요
modinfo -F signer $(modprobe -n -v e1000e | awk '{print $NF}')
```

#### C) TPM 이벤트 로그 요약(PCR 0~7) — Python(교육용 간이 파서)
```python
# tpm_eventlog_summary.py (개념 예시: sysfs 경로/형식은 배포판별 상이)
import sys, hashlib

def parse_eventlog(path="/sys/kernel/security/tpm0/binary_bios_measurements"):
    # 실제 포맷은 TCG Spec (본 예시는 "존재 확인/길이 덤프" 수준)
    data = open(path,'rb').read()
    print(f"[+] eventlog bytes: {len(data)}")
    # 운영에서는 tpm2-tools 또는 전용 라이브러리로 PCR별 이벤트를 파싱·검증

if __name__=="__main__":
    try:
        parse_eventlog()
    except FileNotFoundError:
        print("[-] TPM eventlog not found (path may differ)")
```

> 운영환경에서는 **tpm2-tools**/**pytss**를 활용하여 **PCR quote**(원격 검증)까지 자동화하세요.

---

### 15.1.5 운영 하드닝 체크리스트

- [ ] **Secure Boot 활성화**, **CSM 비활성화**  
- [ ] **dbx 최신화**(취약 shim/부트로더 폐기 룰 포함), **SBAT 적용**  
- [ ] **펌웨어/ME/옵션ROM** 정기 업데이트, **SPI 플래시 보호(쓰기 금지/BIOS Lock)**  
- [ ] **TPM Measured Boot 수집**(PCR+eventlog) → EDR/SIEM **정책 연동**  
- [ ] **USB·PXE 부팅 금지**(필요 시 일시적 허용), **BIOS Setup 비밀번호/물리 보호**  
- [ ] **Capsule Update** 서명 검증(벤더 경로), **롤백 방지 정책**

---

## 15.2 HID/USB 공격 면(키보드 에뮬, BadUSB)

> **핵심**: USB는 “**자신이 어떤 장치인지 스스로 말하는**” 버스입니다(디스크립터).  
> 악성/변조 기기는 **HID 키보드/마우스**로 위장하여 **고속 키 입력 주입**을 하거나(“키보드 에뮬”),  
> **펌웨어 레벨**에서 동적 클래스 전환(Composite/Alt-setting)으로 **정책을 우회**하려 합니다.

### 15.2.1 USB/HID 기본

- **디스크립터**: `Device` → `Configuration` → `Interface`(Class/Subclass/Protocol) → `Endpoint`  
- **HID**: Report Descriptor로 키코드/버튼 레이아웃 정의(키보드, 마우스)  
- **Composite 장치**: 한 장치가 HID+Mass Storage+CDC(가상 NIC) 등 **여러 인터페이스** 제공 가능  
- **호스트 신뢰 문제**: **“자기신고”**를 기초로 클래스 드라이버가 로드됨 → **허용 목록/정책**이 없으면 공격 표면 큼

---

### 15.2.2 위협 시나리오(개념)

- **키보드 에뮬(Keystroke Injection)**  
  - 사용자 자리 비움/지속 삽입 → **수백 WPM** 속도의 명령 주입  
  - OS 로그인/락 화면 우회는 **불가**해야 하지만, **세션 잠금 미흡·오토런 잔재** 등 환경 요인 취약 시 영향
- **BadUSB(펌웨어 변조/재프로그래밍)**  
  - 동일 하드웨어가 **다른 클래스**로 재설정 가능 → 엔드포인트 정책의 허점  
  - 펌웨어에 백도어·키저장·명령 주입 로직 삽입(⚠️ 공격 제조 방법은 다루지 않음)
- **Composite/Mode-Switch 우회**  
  - “처음엔 무해한 HID → 이후 대역폭 큰 Bulk 인터페이스 활성화” 같은 행태로 **정책 적용 타이밍 회피**  
- **USB 네트워킹(RNDIS/NCM)**  
  - 신규 NIC로 **로컬 프록시/DNS 변조** 시도  
- **대용량 전송/파일 시스템**  
  - Mass Storage → 자동 마운트/미디어 스캐너 취약점 노림

---

### 15.2.3 방어 전략(아키텍처)

1) **허용 목록(Allow-listing)**  
   - **클래스/서브클래스/프로토콜** 기준 허용  
   - **벤더/제품 ID(vid/pid)** + **시리얼**로 특정 장치만 허용  
   - **USBGuard(리눅스)**, **Windows Device Installation Restrictions** 등

2) **행위 기반 보강**  
   - “인간 불가능한 키 입력 속도/패턴” 탐지 → **세션 차단/알림**  
   - **Composite 변경/인터페이스 증가** 이벤트를 **정책적으로 재평가**(핫스왑 알림)

3) **업무 분리**  
   - 프리빌리지 워크스테이션(PAW)에서는 **외부 USB 입력 금지**  
   - 공용 키오스크/콘솔: **USB 포트 물리 차단/락**, 프런트 패널 포트 비활성화

4) **로깅/가시성**  
   - **장치 삽입/제거 이벤트**, **새 드라이버 바인딩**, **HID 리포트 속도** 등 **중앙 로깅**

---

### 15.2.4 실습(방어형): 장치 식별·차단·로깅 예제

#### A) Linux — **USBGuard** 정책(허용 목록)
```bash
# 1) 장치 나열(감시 모드)
sudo usbguard generate-policy > /etc/usbguard/rules.conf

# 2) 정책 편집: 명시적으로 필요한 장치만 allow, 나머지 block
# 예) 키보드 1대만 허용, 저장장치 전부 차단
# allow id 1d6b:0002:* name "Trusted Keyboard" with-interface { 03:*:* } hash "..." parent-hash "..."
# block with-interface { 08:*:* }   # Mass Storage 전면 차단

sudo systemctl enable --now usbguard
sudo usbguard watch # 실시간 모니터링
```

> 포인트: **with-interface { 03:*:* }**(HID 클래스)라도 **특정 해시/시리얼만 허용**해 **키보드 사칭**을 줄입니다.

#### B) Linux — udev 규칙으로 **USB 저장장치 차단**
```bash
# /etc/udev/rules.d/99-usbblock.rules
SUBSYSTEMS=="usb", ATTR{bInterfaceClass}=="08", ACTION=="add", RUN+="/bin/sh -c 'logger -t usbblock Blocked USB storage: %E{ID_SERIAL_SHORT}'", ATTR{authorized}="0"
```

#### C) Windows — **장치 설치 제한(GPO/레지스트리)**
```powershell
# PowerShell (관리자): 특정 하드웨어 ID만 허용, 그 외 차단 예시
# 1) 클래스/인스턴스 ID 파악: Get-PnpDevice -PresentOnly
# 2) 정책 적용 (예: Allow installation of devices that match any of these device IDs)
$pol = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DeviceInstall\Restrictions"
New-Item -Path $pol -Force | Out-Null
New-ItemProperty -Path $pol -Name "DenyUnspecified" -Value 1 -PropertyType DWord -Force | Out-Null

# 허용 목록 등록 (예시 하드웨어 ID)
$allow = "USB\VID_1234&PID_5678&MI_00"
New-Item -Path "$pol\AllowDeviceIDs" -Force | Out-Null
New-ItemProperty -Path "$pol\AllowDeviceIDs" -Name "1" -Value $allow -PropertyType String -Force | Out-Null
```

> 실제 운영에선 **테스트 장비→파일럿→전사 적용** 단계로 확장하세요. WDAC/Applocker와 **드라이버·도구 실행 정책**도 함께.

#### D) Windows — WMI 구독으로 **USB 삽입 이벤트 로깅(C#)**
```csharp
// UsbInsertWatcher.cs (요약)
using System;
using System.Management;

class UsbInsertWatcher {
  static void Main() {
    var q = new WqlEventQuery(
      "SELECT * FROM __InstanceCreationEvent WITHIN 2 WHERE TargetInstance ISA 'Win32_USBControllerDevice'");
    using var w = new ManagementEventWatcher(q);
    w.EventArrived += (s,e) => {
      var inst = (ManagementBaseObject)e.NewEvent["TargetInstance"];
      Console.WriteLine($"[+] USB device inserted: {inst["Dependent"]}");
    };
    w.Start();
    Console.WriteLine("Watching... press Enter to exit");
    Console.ReadLine();
    w.Stop();
  }
}
```

#### E) PyUSB로 **디스크립터 검사 + 허용 목록 매칭**
```python
# usb_allowlist.py
import usb.core, usb.util

ALLOW = {("0x046d","0xc31c")}  # 예: 특정 키보드(vid,pid) 허용
devs = usb.core.find(find_all=True)
for d in devs:
    vid, pid = (f"0x{d.idVendor:04x}", f"0x{d.idProduct:04x}")
    try:
        cls = d.bDeviceClass
    except Exception:
        cls = None
    status = "ALLOW" if (vid,pid) in ALLOW else "BLOCK?"
    print(f"{vid}:{pid} class={cls} => {status}")
```

---

### 15.2.5 (탐지 아이디어) **비인간적 HID 입력 속도** 경보

> 구현은 OS별 저수준 훅(키보드 hook/evdev) 지식이 필요합니다. 아래는 개념 스케치(방어).

- **휴리스틱**:  
  - **평균 key interval < 5ms**가 수십 개 지속, **modifier 조합 완벽**(오탈자 無), **포커스 전환+명령형 패턴**  
  - “장치 삽입 후 즉시” 대량 입력 시작  
- **대응**:  
  - 세션 **즉시 잠금**(Win+L/DBus/screensaver), **해당 장치 차단**, **보안 알림**

> 엔드포인트 솔루션(EDR) 또는 SIEM 룰로 **장치 삽입→프로세스/명령 실행 상관분석**을 추가하세요.

---

### 15.2.6 운영 수칙 & 물리 보안

- [ ] **프런트 USB 포트 블랭킹/락**, 회의실/공용 구역 포트 비활성화  
- [ ] **PAW**(관리자용 워크스테이션): **USB 입력·저장장치 금지** 기본  
- [ ] **펌웨어 업데이트만 공식 경로**(서명 확인), **가짜 USB/충전 케이블** 지급 금지  
- [ ] **USB 네트워킹(RNDIS)** 차단(불가피 시 드라이버 화이트리스트·방화벽 프로파일 별도)

---

## 15.3 미니 랩(방어형): “좋은 장치만 통과” 끝에서 끝까지

> 목표: **허용 장치만 동작**하고, **새 장치/클래스 변경**은 **즉시 로그/차단** 확인.

1) 리눅스 워크스테이션에 **USBGuard** 설치 → `generate-policy`로 베이스 정책 작성  
2) **HID 1개**와 **필요한 스마트카드/보안키**만 `allow`  
3) **Mass Storage/CDC** 전면 `block`(업무 예외는 일회 승인)  
4) Windows 파일럿 그룹에 **장치 설치 제한** 적용 → 허용 ID 외 차단  
5) SIEM에 **장치 삽입 이벤트 + 직후의 쉘/권한 상승 시도** 연계 룰 작성  
6) 테스트:  
   - 신뢰 키보드: 정상 입력  
   - 다른 HID/저장장치: 즉시 거부 + 로그 생성  
   - RNDIS: NIC 생성 차단/경보 확인

---

## 15.4 FAQ & 트러블슈팅

- **Q. 허용 목록이면 vid/pid 스푸핑에 약한 것 아닌가요?**  
  A. 맞습니다. **시리얼·해시·보안키(CTAP/U2F) origin 바인딩** 및 **드라이버 서명/정책**을 함께 씁니다.  
     가능하면 **USB 장치 인증(암호학적)**이 지원되는 에코시스템(보안키) 사용을 고려하세요.

- **Q. 개발 장비는 USB가 많이 필요한데요.**  
  A. **개발 VLAN/장비만 예외**로 두고, **프로덕션/PAW**는 강제 차단. 예외는 **만료일 있는 승인 티켓**으로.

- **Q. 사용자가 허용 장치를 다른 PC에 꽂아도 되나요?**  
  A. **자산 등록/바인딩**을 통해 **사용자/단말 매칭**을 강제하면 이동성 리스크를 줄일 수 있습니다.

---

# 요약

- **Secure Boot + dbx 최신화 + Measured Boot(Attestation)**로 **부팅 루트 신뢰**를 보장하세요.  
- **USB/HID**는 **자기신고 신뢰** 모델이므로 **허용 목록·클래스 제어·행위 감시·물리 차단**이 필수입니다.  
- 모든 예외는 **만료일**을 두고, **로깅·경보·IR 플레이북**과 연계하세요.

---

## 부록: 추가 스니펫 모음

### (1) Sysmon(Windows) — 장치 드라이버 로드/파일 생성 모니터링(발췌)
```xml
<!-- Sysmon config excerpt: log driver load & removable media write -->
<Sysmon schemaversion="4.90">
  <EventFiltering>
    <DriverLoad onmatch="include">
      <Signature condition="is">Unsigned</Signature>
    </DriverLoad>
    <FileCreate onmatch="include">
      <TargetFilename condition="contains">\Device\Harddisk</TargetFilename>
      <TargetFilename condition="contains">\Removable</TargetFilename>
    </FileCreate>
  </EventFiltering>
</Sysmon>
```

### (2) Linux — `auditd`로 USB 서브시스템 이벤트(개념)
```bash
# /etc/audit/rules.d/usb.rules
-w /sys/bus/usb/devices -p wa -k usbchange
# 결과: ausearch -k usbchange
```

### (3) Windows — Secure Boot 비활성 탐지(로그인 스크립트)
```powershell
if (-not (Confirm-SecureBootUEFI)) {
  Write-EventLog -LogName Application -Source "CorpSec" -EntryType Warning -EventId 42001 -Message "Secure Boot disabled"
}
```