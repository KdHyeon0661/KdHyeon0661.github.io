---
layout: post
title: Spring - 클라우드 & 배포
date: 2025-10-21 16:25:23 +0900
category: Spring
---
# 20) 클라우드 & 배포 — Docker 빌드 최적화 · K8s 배포/설정 · 헬스체크/리소스/오토스케일링

> 목표: **컨테이너 이미지를 작고 빠르게** 빌드하고, **Kubernetes**에 **안전하게 배포**하며, **헬스체크·리소스 한도·오토스케일링**까지 실전에 필요한 모든 스펙을 예제와 함께 정리한다.  
> 기준: Spring Boot 3.3+, Java 21, Gradle 8+, K8s 1.28+.

---

## A. Docker 이미지 빌드 최적화

### A-1. 멀티스테이지 + 레이어 최적화(Gradle → Boot layertools → distroless)
**핵심 원칙**
- **빌드 단계**와 **런타임 단계**를 분리(멀티스테이지).
- Spring Boot **layertools**로 **의존성/스냅샷/클래스**를 분리 복사 → 캐시 효율↑.
- 작은 베이스(예: **distroless java21**) + 불필요 파일 제거.
- **USER 비루트** 지정, **읽기 전용** 루트 파일시스템.

**Dockerfile (권장 예시)**
```dockerfile
# ---------- builder ----------
FROM eclipse-temurin:21-jdk-jammy AS builder
WORKDIR /workspace
# 1) Gradle 캐시 레이어 최적화: settings/gradle 파일 먼저 복사
COPY gradlew gradle.properties settings.gradle.kts ./
COPY gradle ./gradle
RUN ./gradlew --version
# 2) 의존성만 먼저 받아 캐시 확보
COPY build.gradle.kts .
RUN ./gradlew build -x test || true
# 3) 실제 소스 복사 후 빌드
COPY . .
RUN ./gradlew :apps:app-api:bootJar

# ---------- layers ----------
FROM eclipse-temurin:21-jre-jammy AS layers
WORKDIR /app
COPY --from=builder /workspace/apps/app-api/build/libs/*.jar app.jar
# Spring Boot layertools: JAR를 레이어로 분해
RUN java -Djarmode=layertools -jar app.jar extract

# ---------- runtime ----------
FROM gcr.io/distroless/java21-debian12:nonroot
WORKDIR /app
# 각 레이어를 순서대로 복사(캐시가 잘 먹히도록)
COPY --from=layers /app/dependencies/ ./dependencies/
COPY --from=layers /app/snapshot-dependencies/ ./snapshot-dependencies/
COPY --from=layers /app/spring-boot-loader/ ./spring-boot-loader/
COPY --from=layers /app/application/ ./application/
ENV JAVA_TOOL_OPTIONS="-XX:+UseG1GC -XX:MaxRAMPercentage=75 -XX:+AlwaysActAsServerClassMachine \
  -XX:+UseStringDeduplication -Dfile.encoding=UTF-8 -Duser.timezone=Asia/Seoul \
  -Dspring.profiles.active=prod -Dserver.shutdown=graceful"
# 읽기 전용 루트 FS + nonroot 사용자
USER nonroot
EXPOSE 8080
# Distroless는 쉘이 없으므로 EntryPoint는 클래스로더 호출
ENTRYPOINT ["java","org.springframework.boot.loader.launch.JarLauncher"]
```

**포인트**
- **레이어 분리** 순서: `dependencies` → `snapshot-dependencies` → `spring-boot-loader` → `application`  
  → 의존성 변경 없으면 애플리케이션 코드만 다시 복사되므로 **캐시 적중률↑**.
- `JAVA_TOOL_OPTIONS`는 **컨테이너 메모리 인식 옵션** 사용: `MaxRAMPercentage` (Xmx 자동 계산).
- distroless는 패키지 매니저/쉘이 없어 **공격 표면 최소화**.

### A-2. 빌드 캐시/멀티아키텍처/이미지 서명
- **BuildKit**: `DOCKER_BUILDKIT=1 docker build ...`  
- **캐시 내보내기/가져오기**:
  ```bash
  docker buildx build --platform linux/amd64,linux/arm64 \
    --cache-to=type=registry,ref=registry/cache:app,mode=max \
    --cache-from=type=registry,ref=registry/cache:app \
    -t registry/app-api:1.0.0 -t registry/app-api:latest --push .
  ```
- **서명**: cosign으로 공급망 보안 강화
  ```bash
  cosign sign --key cosign.key registry/app-api:1.0.0
  cosign verify registry/app-api:1.0.0
  ```

### A-3. 대안 빌드: Buildpacks/Jib
- **Buildpacks(pack CLI)**: `pack build registry/app-api:1.0.0 --builder paketobuildpacks/builder-jammy-base`  
  → Dockerfile 없이 최적화 이미지 생성(레이어링 자동화).
- **Jib(Gradle)**: `./gradlew :apps:app-api:jib -Djib.to.image=registry/app-api:1.0.0`  
  → Docker 데몬 없이 빌드, **빠른 피드백 루프**.

### A-4. 보안·크기·성능 체크
- **이미지 스캐닝**: Trivy/Grype로 CVE 검사.  
- **SBOM**: `syft packages registry/app-api:1.0.0 -o cyclonedx-json > sbom.json`  
- **레이어 크기 분석**: `dive registry/app-api:1.0.0`  
- **기동 시간**: `spring.main.lazy-initialization=true`로 콜드 스타트 최적화 가능(주의: 런타임 첫 요청 지연).

---

## B. Kubernetes 디플로이먼트 · ConfigMap · Secret

### B-1. 배포 최소 예(Deployment+Service)
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: acme-api
  labels: { app: acme-api }
spec:
  replicas: 3
  revisionHistoryLimit: 5
  strategy:
    type: RollingUpdate
    rollingUpdate: { maxUnavailable: 0, maxSurge: 1 }
  selector:
    matchLabels: { app: acme-api }
  template:
    metadata:
      labels: { app: acme-api }
    spec:
      containers:
        - name: app
          image: registry/app-api:1.0.0@sha256:...   # digest 고정 권장
          imagePullPolicy: IfNotPresent
          ports: [{ containerPort: 8080, name: http }]
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "prod"
          readinessProbe:
            httpGet: { path: /actuator/health/readiness, port: http }
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 2
            failureThreshold: 6
          livenessProbe:
            httpGet: { path: /actuator/health/liveness, port: http }
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 2
            failureThreshold: 3
          startupProbe:     # 부팅 느린 앱 보호
            httpGet: { path: /actuator/health/liveness, port: http }
            failureThreshold: 60
            periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: acme-api
spec:
  selector: { app: acme-api }
  ports:
    - name: http
      port: 80
      targetPort: http
  type: ClusterIP
```

**Spring Actuator 설정 (application-prod.yml)**
```yaml
management:
  endpoint:
    health:
      probes:
        enabled: true   # readiness/liveness 그룹 자동 활성화
  endpoints.web.exposure.include: health,info,metrics,prometheus
```

### B-2. ConfigMap/Secret로 외부 설정 주입
**ConfigMap**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: acme-api-config
data:
  application.yml: |
    spring:
      jackson:
        default-property-inclusion: non_null
    features:
      checkout-v2: "false"
  LOG_LEVEL_ROOT: "INFO"
```

**Secret (Opaque/base64)**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: acme-api-secret
type: Opaque
data:
  DB_PASSWORD: c2VjcmV0MTIz # base64("secret123")
  JWT_PUBLIC_KEY: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0t...
```

**Deployment에서 사용**
```yaml
env:
  - name: LOG_LEVEL_ROOT
    valueFrom: { configMapKeyRef: { name: acme-api-config, key: LOG_LEVEL_ROOT } }
  - name: SPRING_DATASOURCE_PASSWORD
    valueFrom: { secretKeyRef: { name: acme-api-secret, key: DB_PASSWORD } }
  - name: SPRING_CONFIG_IMPORT
    value: "optional:file:/config/"
volumeMounts:
  - name: app-config
    mountPath: /config   # application.yml을 파일로 제공 (Boot가 자동 인식)
volumes:
  - name: app-config
    configMap:
      name: acme-api-config
      items:
        - key: application.yml
          path: application.yml
```

**팁**
- config 변경을 빠르게 반영하려면 **롤링 재배포**(immutable infra 원칙).
- 시크릿은 **KMS/Sealed Secrets/External Secrets**로 Git에 암호화 상태로 보관 → Pod에서는 복호화된 Secret으로 주입.

### B-3. Ingress(간단) + TLS
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: acme-api
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt
spec:
  tls:
    - hosts: [ api.example.com ]
      secretName: acme-api-tls
  rules:
    - host: api.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend: { service: { name: acme-api, port: { number: 80 } } }
```

---

## C. 헬스체크 · 리소스 요청/제한 · 오토스케일링

### C-1. 프로브(Probe) 3종
- **startupProbe**: 부팅 완료까지 기다림(실패 허용 범위 큼).  
- **readinessProbe**: 트래픽 수신 가능/불가 판정(미준비 시 서비스 엔드포인트에서 제외).  
- **livenessProbe**: 프로세스 생존 확인(실패 시 재시작).  

**추천 값**
- `startupProbe`: 빈도 5s, `failureThreshold`는 앱 콜드 스타트 최대 시간/5.  
- `readinessProbe`: 5s 주기, 타임아웃 2s, 실패 6(=최대 30s 중단 허용).  
- `livenessProbe`: 10s 주기, 실패 3(=30s 후 재시작).

**Spring에서 세분화**
- `/actuator/health/liveness` → JVM 자체/스레드 스택 수준  
- `/actuator/health/readiness` → 외부 의존(DB/브로커) 상태 반영

### C-2. 리소스 요청/제한(HPA 전제)
```yaml
resources:
  requests:
    cpu: "250m"
    memory: "512Mi"
  limits:
    cpu: "1000m"
    memory: "1Gi"
```
**가이드**
- **requests**는 스케줄링 기준(최소 보장), **limits**는 상한.  
- Java 컨테이너: `MaxRAMPercentage`로 힙을 limits에 맞춰 자동 조절.  
- OOMKilled 방지: **heap + metaspace + native + 스레드 스택** 합이 **limit 아래**여야 함.  
- 초기에는 `requests.cpu`를 낮게(0.25~0.5 core), `limits.cpu`를 1~2 core로 두고 관측 기반으로 조정.

### C-3. HPA(수평 오토스케일링)
**CPU 기반**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: acme-api
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: acme-api
  minReplicas: 3
  maxReplicas: 20
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 60   # 요청 대비 60% 사용 목표
```

**메모리 기반(보조)**
```yaml
metrics:
  - type: Resource
    resource: { name: cpu, target: { type: Utilization, averageUtilization: 60 } }
  - type: Resource
    resource: { name: memory, target: { type: AverageValue, averageValue: 800Mi } }
```

**사용자 정의 메트릭 (예: RPS)**
- Prometheus Adapter로 `requests_per_second` 같은 커스텀 메트릭 노출 → `type: Pods`/`External`로 HPA 연동.  
- 스파이크 대응에 **KEDA**(이벤트 드리븐 스케일링: Kafka 수, SQS 수 등)도 효과적.

### C-4. 롤링 업데이트/그레이스풀 종료
```yaml
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate: { maxUnavailable: 0, maxSurge: 1 }
  template:
    spec:
      terminationGracePeriodSeconds: 30
      containers:
        - name: app
          lifecycle:
            preStop:
              httpGet:
                path: /actuator/shutdown-preStop    # 커스텀 엔드포인트 (선택)
                port: http
```
**Spring Boot**
- `server.shutdown=graceful` → 종료 신호 시 **새 연결 거부 및 진행 중 요청 완료**.  
- preStop에서 **readiness false** 전환 후 **드레인** 시간 확보(예: 10~20초).

### C-5. 안정성: PDB/Pod 분산/Node 중단
**PodDisruptionBudget(PDB)**
```yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata: { name: acme-api-pdb }
spec:
  minAvailable: 2
  selector: { matchLabels: { app: acme-api } }
```
**Topolgy Spread**
```yaml
spec:
  template:
    spec:
      topologySpreadConstraints:
        - maxSkew: 1
          topologyKey: topology.kubernetes.io/zone
          whenUnsatisfiable: ScheduleAnyway
          labelSelector: { matchLabels: { app: acme-api } }
```
→ **AZ/노드**에 고르게 분산, 단일 장애점 제거.

---

## D. 운영·보안·관측 실무 체크리스트

### D-1. 보안
- **비루트 USER**, read-only rootfs, 필요한 디렉토리만 `emptyDir`로 쓰기 가능.  
- **Capabilities** 제거(`securityContext.capabilities.drop: ALL`).  
- **이미지 서명/검증**, **취약점 스캔** 파이프라인 자동화.  
- **네트워크 정책**(NetworkPolicy)로 **egress/ingress 최소화**.  
- Secret은 **at rest**(KMS) + **in transit**(TLS) 보호.

### D-2. 관측
- Actuator + Micrometer → **Prometheus/Grafana**:  
  - JVM: 힙/GC/스레드, **`jvm.memory.used`**, **`jvm.gc.pause`**  
  - HTTP: 요청수/지연 p95, 4xx/5xx 비율  
  - DB/풀: **Hikari** `hikaricp.connections.active/idle/pending`  
- **로그**: JSON + traceId/MDC, stdout 수집(Fluent Bit/Vector).  
- **트레이싱**: OpenTelemetry(OTLP) → Tempo/Jaeger.

### D-3. 레지스트리/이미지 정책
- 태그는 **버전 + git sha**(예: `1.4.2-3f2c9e7`) + **digest 고정** 배포.  
- `imagePullSecrets`로 프라이빗 레지스트리 인증.  
- 오래된 이미지 **TTL/보존 정책**.

### D-4. 퍼포먼스/GC/스레드
- Java 21 G1 기본: `-XX:MaxRAMPercentage=75`(또는 70)로 여유 유지.  
- **스레드 수**는 컨테이너 vCPU 고려: Netty/tomcat 풀, async 풀 제한.  
- **파일 디스크립터/epoll** 확인(고동시성).

---

## E. 전체 예제 — “acme-api” K8s 매니페스트 모음

### E-1. 네임스페이스/ServiceAccount/Role
```yaml
apiVersion: v1
kind: Namespace
metadata: { name: prod }
---
apiVersion: v1
kind: ServiceAccount
metadata: { name: acme-api, namespace: prod }
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata: { name: acme-api-role, namespace: prod }
rules:
  - apiGroups: [""]
    resources: ["configmaps", "secrets"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata: { name: acme-api-rb, namespace: prod }
subjects:
  - kind: ServiceAccount
    name: acme-api
roleRef:
  kind: Role
  name: acme-api-role
  apiGroup: rbac.authorization.k8s.io
```

### E-2. Config/Secret + Deployment + Service + HPA + PDB
```yaml
# ConfigMap
apiVersion: v1
kind: ConfigMap
metadata: { name: acme-api-config, namespace: prod }
data:
  application.yml: |
    spring:
      application.name: acme-api
      jackson.serialization.WRITE_DATES_AS_TIMESTAMPS: false
    management.endpoints.web.exposure.include: health,info,metrics,prometheus
  LOG_LEVEL_ROOT: INFO
---
# Secret
apiVersion: v1
kind: Secret
metadata: { name: acme-api-secret, namespace: prod }
type: Opaque
data:
  DB_URL: amRiYzpwZ3NxbDovL3Byb2QtZGI6NTQzMi9hY21l   # 예시
  DB_USER: YWNtZQ==
  DB_PASSWORD: c2VjcmV0
---
# Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: acme-api
  namespace: prod
  labels: { app: acme-api }
spec:
  replicas: 4
  revisionHistoryLimit: 5
  strategy:
    rollingUpdate: { maxUnavailable: 0, maxSurge: 1 }
    type: RollingUpdate
  selector:
    matchLabels: { app: acme-api }
  template:
    metadata:
      labels: { app: acme-api }
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/actuator/prometheus"
    spec:
      serviceAccountName: acme-api
      securityContext:
        runAsNonRoot: true
        fsGroup: 65532
      containers:
        - name: app
          image: registry/app-api:1.0.0@sha256:...
          imagePullPolicy: IfNotPresent
          ports: [{ name: http, containerPort: 8080 }]
          envFrom:
            - configMapRef: { name: acme-api-config }
            - secretRef: { name: acme-api-secret }
          env:
            - name: SPRING_CONFIG_IMPORT
              value: "optional:file:/config/"
            - name: JAVA_TOOL_OPTIONS
              value: "-XX:+UseG1GC -XX:MaxRAMPercentage=75 -Dserver.shutdown=graceful"
          volumeMounts:
            - name: cfg
              mountPath: /config
              readOnly: true
          resources:
            requests: { cpu: "300m", memory: "512Mi" }
            limits:   { cpu: "1500m", memory: "1024Mi" }
          readinessProbe:
            httpGet: { path: /actuator/health/readiness, port: http }
            periodSeconds: 5
            timeoutSeconds: 2
            failureThreshold: 6
          livenessProbe:
            httpGet: { path: /actuator/health/liveness, port: http }
            initialDelaySeconds: 30
            periodSeconds: 10
          startupProbe:
            httpGet: { path: /actuator/health/liveness, port: http }
            failureThreshold: 60
            periodSeconds: 5
      volumes:
        - name: cfg
          configMap: { name: acme-api-config, items: [{ key: application.yml, path: application.yml }] }
---
# Service
apiVersion: v1
kind: Service
metadata: { name: acme-api, namespace: prod }
spec:
  selector: { app: acme-api }
  ports: [{ name: http, port: 80, targetPort: http }]
  type: ClusterIP
---
# HPA
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata: { name: acme-api, namespace: prod }
spec:
  scaleTargetRef: { apiVersion: apps/v1, kind: Deployment, name: acme-api }
  minReplicas: 3
  maxReplicas: 30
  metrics:
    - type: Resource
      resource: { name: cpu, target: { type: Utilization, averageUtilization: 60 } }
---
# PDB
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata: { name: acme-api-pdb, namespace: prod }
spec:
  minAvailable: 2
  selector: { matchLabels: { app: acme-api } }
```

---

## F. 배포 파이프라인 요령(요약)

1) **CI**: 테스트→정적분석→이미지 빌드(BuildKit/Jib)→스캔(Trivy)→서명(cosign)→푸시.  
2) **CD**: K8s 매니페스트 Kustomize/Helm 관리 → **immutable tag+digest** 적용 → 롤링 업데이트.  
3) **릴리즈 전략**:  
   - **Blue/Green**: 2개 Deployment, Ingress/Service 스위치.  
   - **Canary**: 서비스 메시/Istio 가중치 or Gateway 헤더 기반.  
4) **롤백**: `kubectl rollout undo deploy/acme-api` 또는 이전 버전 Helm 릴리스.  
5) **런북**: 헬스 체크 실패/스케일 아웃/OOMKilled/CrashLoopBackOff 대응 절차 문서화.

---

## G. 트러블슈팅 빠른 표

| 증상 | 흔한 원인 | 대처 |
|---|---|---|
| `CrashLoopBackOff` | 포트/환경변수/DB 연결 실패, 메모리 부족 | `kubectl logs`, `describe`로 이벤트 확인, readiness/secret 재검증 |
| `OOMKilled` | 힙/네이티브 메모리 과다 | `limits`↑ 또는 `MaxRAMPercentage`↓, 스레드/버퍼 점검 |
| HPA 미동작 | 리소스 요청 미설정/metrics-server 없음 | `requests` 지정, metrics-server/adapter 확인 |
| 롤링 중 다운타임 | readiness 늦음/`maxUnavailable`>0 | startupProbe↑, readiness 튜닝, `maxUnavailable: 0` |
| 이미지 풀 실패 | 레지스트리 인증/네트워크 | `imagePullSecrets`, 네트워크 정책/프록시 확인 |
| 느린 기동 | 큰 스캔/마이그레이션 | Flyway validate로 전환, lazy-init, JIT 워밍업 |

---

## H. 한 페이지 요약
- **이미지**는 멀티스테이지 + **layertools 레이어링** + **distroless·비루트**로 작고 안전하게.  
- **ConfigMap/Secret**로 설정·비밀을 분리하고, **파일 마운트/ENV**로 주입.  
- **startup/readiness/liveness**를 분리해 **부팅·트래픽·자가치유**를 정확히 제어.  
- **requests/limits**를 보수적으로 시작해 관측 기반으로 조정, **HPA**로 수평 확장.  
- **롤링 업데이트** + **graceful shutdown**으로 무중단 배포, 필요시 **Blue/Green/Canary**.  
- 보안/관측(스캔, 서명, 메트릭, 로그, 추적)을 파이프라인에 내장해 **안전한 운영 기본기**를 완성한다.