---
layout: post
title: 논리회로설계 - 합성가능한 VHDL 코드
date: 2025-09-13 21:25:23 +0900
category: 논리회로설계
---
# 합성가능한 VHDL 코드 작성 요령 (Synthesizable VHDL Best Practices, 예제 총정리)

> 대상: FPGA/ASIC RTL을 **안전하게 합성**하기 위한 실전 규칙과 패턴.
> 표준: `ieee.std_logic_1164`, `ieee.numeric_std`(권장), VHDL-2008 기준(구버전 대안 병기).
> 표기: `clk`(클럭), `rst`(동기 리셋 unless noted), `CE`(Clock Enable), 신호는 `std_logic(_vector)`.
> 목표: **래치 추론 0건**, **게이티드 클럭 0건**, **멀티드라이버 0건**, **타이밍/CDC 안전**.

---

## 합성 가능/불가 큰 그림

### 반드시 기억할 핵심 10가지

1. **산술은 `numeric_std`**: `unsigned/signed`로 변환 후 연산. (비표준 패키지 금지)
2. **조합/순차 분리**: `process(all)` + 기본값(조합), `if rising_edge(clk)`(순차).
3. **래치 방지**: 모든 경로에 **할당**. `case`는 **완전 커버**(`when others`).
4. **클럭 게이팅 금지**: CE 사용. (게이트로 클럭 만들지 말 것)
5. **비동기 입력 동기화**: 2FF 동기화 + 펄스는 동기 영역에서 생성.
6. **리셋은 동기**(권장), **해제 동기화**. (비동기 리셋 사용 시)
7. **정적 범위 루프만**: `for i in 0 to N-1`(정적 N). `wait/after`/파일 I/O는 TB 전용.
8. **자원 추론 패턴** 준수: RAM/ROM/DSP/SRL 패턴에 맞게 작성.
9. **출력 글리치 방지**: Mealy 성격 출력은 **등록**해서 외부로.
10. **속성/프라그마**로 상태인코딩/보존 제어(도구별).

---

## 라이브러리와 타입, 캐스팅 원칙

```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;  -- 산술 필수
```

- **나쁜 예(비표준)**
  `use ieee.std_logic_unsigned.all;` / `std_logic_arith` → 도구/이식성 문제.
- **좋은 예**
```vhdl
signal a,b : std_logic_vector(7 downto 0);
signal u   : unsigned(7 downto 0);
u <= unsigned(a) + unsigned(b);
```

---

## 조합 로직 코딩 패턴 (래치 금지)

### `process(all)` + 기본값

```vhdl
-- ✅ 올바른 조합 블록
process(all) is
begin
  y_n <= y;                 -- 기본 유지(래치 방지)
  case sel is
    when "00"  => y_n <= a;
    when "01"  => y_n <= b;
    when "10"  => y_n <= c;
    when others=> null;     -- 유지
  end case;
end process;
```

```vhdl
-- ❌ 잘못된 예: 일부 경로 미할당 → 래치 추론
process(a,b,sel) begin
  if sel="00" then y<=a;
  elsif sel="01" then y<=b;
  -- "10" / others 미할당
  end if;
end process;
```

### `with-select` / `when-else` (간결, 완전 커버)

```vhdl
with sel select
  y <= a when "00",
       b when "01",
       c when "10",
       y when others;      -- 유지(래치 방지) 또는 기본값
```

---

## 순차(클럭) 로직 코딩 패턴

### 동기 리셋 + CE

```vhdl
process(clk) is
begin
  if rising_edge(clk) then
    if rst='1' then
      q <= (others=>'0');
    elsif ce='1' then
      q <= d;
    end if;
  end if;
end process;
```

### 게이티드 클럭 **금지**

```vhdl
-- ❌ 금지: 게이티드 클럭
clk_g <= clk and en;
process(clk_g) begin ... end process;

-- ✅ 대안: CE
process(clk) begin
  if rising_edge(clk) then
    if en='1' then q<=d; end if;
  end if;
end process;
```

### 초기화(합성기 동작 주의)

- FPGA는 일부 신호 초기값 합성 지원하지만, **포터블**하게는 **리셋**으로 초기화.

---

## 변수 vs 신호, 델타 사이클

- **변수**: 프로세스 내부 **즉시 갱신**(조합 누산/합성 OK).
- **신호**: 델타 지연 후 갱신, 레지스터/동시문 연결.

```vhdl
process(all)
  variable t: unsigned(8 downto 0);
begin
  t := ('0' & unsigned(a)) + ('0' & unsigned(b));
  sum   <= std_logic_vector(t(7 downto 0));
  carry <= t(8);
end process;
```

---

## FSM(상태기계) 모범 템플릿

### 2-프로세스 Moore

```vhdl
type S_t is (IDLE, LOAD, RUN, DONE);
signal s, ns : S_t := IDLE;
signal y_reg : std_logic := '0';

-- 조합: ns/출력 기본값
process(all) begin
  ns    <= s;
  y_reg <= '0';
  case s is
    when IDLE => if start='1' then ns<=LOAD; end if;
    when LOAD => ns<=RUN;
    when RUN  => if done_i='1' then ns<=DONE; end if;
    when DONE => y_reg<='1'; ns<=IDLE;
  end case;
end process;

-- 순차: 상태
process(clk) begin
  if rising_edge(clk) then
    if rst='1' then s<=IDLE; else s<=ns; end if;
  end if;
end process;

y <= y_reg;  -- 등록 출력
```

### 3-프로세스(Mealy 출력 등록)

- Mealy 조건 출력은 별도 **등록 프로세스**에서 1클럭 펄스화 → 글리치 방지.

### 상태 인코딩/속성(도구별)

```vhdl
-- 공통(많은 도구 지원)
attribute enum_encoding : string;
attribute enum_encoding of S_t : type is "00 01 10 11";
-- Xilinx
-- attribute fsm_encoding : string;
-- attribute fsm_encoding of s : signal is "onehot";  -- or "sequential","gray"
```

---

## 우선순위/병렬 인코딩

- `if-elsif` → **우선순위** 인코더.
- `case` → **병렬**(상호 배타). **완전 커버** 필수.

```vhdl
-- 우선순위 인코더(8→3)
process(all) begin
  y<="000"; v<='0';
  if    d(7)='1' then y:="111"; v<='1';
  elsif d(6)='1' then y:="110"; v<='1';
  -- ...
  elsif d(0)='1' then y:="000"; v<='1';
  end if;
end process;
```

---

## 산술/시프트/비트연산 — `numeric_std` 일관성

```vhdl
signal au,bu,ru : unsigned(15 downto 0);
signal as,bs,rs : signed(15 downto 0);

ru <= au + bu;                       -- add
rs <= as - bs;                       -- sub
ru <= au sll 2;                      -- shift
y  <= std_logic_vector(ru);
```

- 폭 맞춤: `resize(au, newlen)`
- 정수↔벡터: `to_unsigned(123, N)`, `to_signed(-5, N)`

---

## 메모리 추론 패턴 (RAM/ROM)

### 단일포트 동기 RAM

```vhdl
type ram_t is array (0 to DEPTH-1) of std_logic_vector(W-1 downto 0);
signal ram: ram_t;

process(clk) begin
  if rising_edge(clk) then
    if we='1' then ram(to_integer(addr)) <= din; end if;
    dout <= ram(to_integer(addr));
  end if;
end process;
```

### 듀얼포트 RAM(1 Write, 1 Read)

```vhdl
-- 포트 A: write, 포트 B: read
process(clkA) begin
  if rising_edge(clkA) then
    if weA='1' then ram(to_integer(addrA)) <= dinA; end if;
  end if;
end process;

process(clkB) begin
  if rising_edge(clkB) then
    doutB <= ram(to_integer(addrB));
  end if;
end process;
```
> 도구별 true dual-port 문법 차이 있으니 합성 가이드 참조.

### ROM/초기화

```vhdl
type rom_t is array (0 to 255) of std_logic_vector(7 downto 0);
constant rom: rom_t := (
  0 => x"AA", 1 => x"BB", others => x"00"
);
process(clk) begin
  if rising_edge(clk) then dout <= rom(to_integer(addr)); end if;
end process;
```

---

## DSP/곱셈기/가산기 트리 추론

- 폭이 큰 `*`, `+` 사용 시 **DSP 블록**/Carry-Chain에 자동 매핑.
- 파이프라인 레지스터 삽입으로 Fmax 향상.

```vhdl
signal a,b : signed(17 downto 0);
signal p0,p1: signed(35 downto 0);
signal y    : signed(35 downto 0);
process(clk) begin
  if rising_edge(clk) then
    p0 <= a * b;         -- DSP 곱
    p1 <= p0 + resize(a, p0'length);
    y  <= p1;            -- 파이프라인 2단
  end if;
end process;
```

---

## 시리얼/반복기법(면적 절감) — 예: 시프트-가산 곱셈기

```vhdl
entity mul_iter is
  generic(N: positive := 16);
  port(clk,rst,ce,start: in std_logic;
       A,B: in std_logic_vector(N-1 downto 0);
       P: out std_logic_vector(2*N-1 downto 0);
       busy,done: out std_logic);
end;
architecture rtl of mul_iter is
  type S_t is (IDLE,RUN,FIN);
  signal s,ns: S_t := IDLE;
  signal areg: unsigned(N-1 downto 0);
  signal breg: unsigned(N-1 downto 0);
  signal preg: unsigned(2*N-1 downto 0);
  signal cnt : unsigned(15 downto 0);
begin
  P <= std_logic_vector(preg);
  busy <= '1' when s=RUN else '0';
  process(all) begin
    ns<=s;
    case s is
      when IDLE=> if start='1' then ns<=RUN; end if;
      when RUN => if cnt=to_unsigned(N-1,cnt'length) then ns<=FIN; end if;
      when FIN => ns<=IDLE;
    end case;
  end process;
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then s<=IDLE; done<='0';
      elsif ce='1' then
        s<=ns; done<='0';
        case s is
          when IDLE =>
            if start='1' then
              areg<=unsigned(A); breg<=unsigned(B);
              preg<=(others=>'0'); cnt<=(others=>'0');
            end if;
          when RUN =>
            if breg(0)='1' then
              preg(N-1 downto 0) <= preg(N-1 downto 0) + areg;
            end if;
            preg <= '0' & preg(preg'high downto 1);
            breg <= '0' & breg(breg'high downto 1);
            if cnt/=to_unsigned(N-1,cnt'length) then cnt<=cnt+1; end if;
          when FIN => done<='1';
        end case;
      end if;
    end if;
  end process;
end;
```

---

## CDC(Clock Domain Crossing) & 리셋

### 단일비트 동기화(2FF)

```vhdl
signal din_async, dmeta, dout_sync: std_logic;
process(clk) begin
  if rising_edge(clk) then
    dmeta     <= din_async;
    dout_sync <= dmeta;
  end if;
end process;
```

### 펄스 전송(토글/핸드셰이크)

- **토글 동기화** → 대상 도메인에서 변경 감지.
- 또는 **ready/valid** 핸드셰이크로 안전 전달.

### 비동기 리셋의 해제 동기화

```vhdl
-- rst_n 비동기 assert, 동기 deassert
signal rst_sync: std_logic;
process(clk, rst_n) begin
  if rst_n='0' then rst_sync<='1';
  elsif rising_edge(clk) then rst_sync<='0'; end if;
end process;
```

---

## 인터페이스/레코드/패키지로 깔끔하게

```vhdl
package stream_pkg is
  type axis32_t is record
    valid,ready,last : std_logic;
    data : std_logic_vector(31 downto 0);
  end record;
end;

library ieee; use ieee.std_logic_1164.all; use work.stream_pkg.all;

entity regslice is
  port(clk,rst: in std_logic; s: in axis32_t; m: out axis32_t);
end;
architecture rtl of regslice is
  signal r: axis32_t;
begin
  m.ready <= '1'; -- 간단 패스스루 예
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r.valid<='0';
      elsif s.valid='1' and m.ready='1' then
        r <= s;  -- 레코드 통째 복사(합성 OK)
      end if;
    end if;
  end process;
  m <= r;
end;
```

---

## 파이프라인과 `valid` 전파(지연 정렬)

```vhdl
signal v0,v1,v2 : std_logic;
signal d0,d1,d2 : unsigned(15 downto 0);
process(clk) begin
  if rising_edge(clk) then
    if rst='1' then v0<='0'; v1<='0'; v2<='0';
    else
      -- stage0
      d0 <= unsigned(a) + unsigned(b);
      v0 <= in_valid;
      -- stage1
      d1 <= d0 * 3;
      v1 <= v0;
      -- stage2
      d2 <= d1 + 1;
      v2 <= v1;
    end if;
  end if;
end process;
out_data  <= std_logic_vector(d2);
out_valid <= v2;
```

---

## 합성기 친화 `generate` (복제/옵션)

```vhdl
gen_ff: for i in 0 to N-1 generate
  ff_i: entity work.dff port map(clk=>clk, rst=>rst, d=>din(i), q=>q(i));
end generate;

gen_parity: if USE_PARITY generate
  -- 패리티 생성 로직
end generate;
```

---

## 미니-라이브러리: 안전한 유틸 함수/프로시저

### 포화 덧셈(signed)

```vhdl
package sat_pkg is
  function sat_add(a,b,hi,lo: signed) return signed;
end;
package body sat_pkg is
  function sat_add(a,b,hi,lo: signed) return signed is
    variable t: signed(a'length downto 0);
  begin
    t := resize(a,t'length) + resize(b,t'length);
    if t > resize(hi,t'length) then return resize(hi,a'length);
    elsif t < resize(lo,t'length) then return resize(lo,a'length);
    else return resize(t,a'length);
    end if;
  end;
end;
```

### 우선순위 원-핫 인코더

```vhdl
function onehot_idx(d: std_logic_vector) return unsigned is
  variable idx: unsigned(31 downto 0) := (others=>'0');
begin
  for i in d'reverse_range loop
    if d(i)='1' then
      idx := to_unsigned(i, idx'length); exit;
    end if;
  end loop;
  return idx;
end;
```

---

## FIFO 스켈레톤(동일 클럭)

```vhdl
entity fifo_sync is
  generic (W: positive:=8; DEPTH: positive:=16);
  port (clk,rst: in std_logic;
        wr_en: in std_logic; din: in std_logic_vector(W-1 downto 0);
        rd_en: in std_logic; dout: out std_logic_vector(W-1 downto 0);
        full,empty: out std_logic);
end;
architecture rtl of fifo_sync is
  type ram_t is array(0 to DEPTH-1) of std_logic_vector(W-1 downto 0);
  signal mem: ram_t;
  signal wptr,rptr: unsigned(ceil_log2(DEPTH)-1 downto 0);
  signal count: unsigned(ceil_log2(DEPTH) downto 0);
begin
  full  <= '1' when count=DEPTH else '0';
  empty <= '1' when count=0     else '0';

  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        wptr<=(others=>'0'); rptr<=(others=>'0'); count<=(others=>'0');
      else
        if wr_en='1' and full='0' then
          mem(to_integer(wptr)) <= din;
          wptr <= wptr + 1;
          count<= count + 1;
        end if;
        if rd_en='1' and empty='0' then
          dout <= mem(to_integer(rptr));
          rptr <= rptr + 1;
          count<= count - 1;
        end if;
      end if;
    end if;
  end process;
end;
```
> `ceil_log2`는 제네릭/함수로 제공. 비동기 FIFO는 Gray 포인터/CDC가 별도 필요.

---

## 안전한 3-State 사용

- **내부** 3-state는 합성 시 MUX로 대체 → 불필요.
- **외부 I/O**에서만 사용.
```vhdl
io <= (others=>'Z') when oe='0' else data_out;
data_in <= io;
```

---

## 테스트벤치와의 경계

- TB 전용: `wait for`, `textio`, 실수(`real`), 파일 I/O, `'image` 디버깅.
- RTL(합성): 위 기능 **사용 금지**(또는 번역 off/on 주석).
```vhdl
-- pragma translate_off
report "debug: " & integer'image(i);
-- pragma translate_on
```

---

## 타이밍/리소스 관점 코딩 팁

- **직렬 스택 트랜지스터**(논리 깊이) ↓: 큰 `if` 중첩 대신 플래그 분리하여 **한 단계 늦게 판단**.
- **팬인 큰 비교**는 **파이프라인**으로 분해.
- **공유 연산기**: 반복 FSM로 면적 ↓, 고속은 병렬 + 파이프라인.
- **분기 많은 FSM**: **one-hot**로 조합 복잡도 ↓(FPGA 유리).
- **상수 곱**은 shift-add로 최적화 또는 DSP 사용.

---

## 반례 모음(안티패턴 → 교정)

### 부분 할당

```vhdl
-- ❌
process(a,b) begin
  if sel='1' then y<=a; end if; -- sel='0' 경로 미할당
end process;
-- ✅
process(all) begin
  y <= b; if sel='1' then y<=a; end if;
end process;
```

### while/동적 루프

```vhdl
-- ❌ while (합성 불가/위험)
while x /= 0 loop x := x-1; end loop;
-- ✅ for (정적 범위)
for i in 0 to N-1 loop ... end loop;
```

### 멀티 드라이버

```vhdl
-- ❌ 같은 신호를 여러 process에서 드라이브
p1: process(...) y <= ...; end process;
p2: process(...) y <= ...; end process;
-- ✅ 단일 드라이버
process(all) begin ... y<=...; end process;
```

---

## 코드 스타일 가이드(가독성/유지보수)

- 이름: 신호 `snake_case`, 상수/제네릭 대문자 `ALL_CAPS`.
- 비트폭 상수화: `constant W: integer := 16;`
- `a'range`, `vector'high/low`로 **하드코딩 인덱스** 회피.
- `others=>'0'` 기본화, magic number 지양.
- 모듈 경계에서 **타입 통일**(모두 `std_logic_vector`, 내부만 `unsigned/signed`).

---

## 실전 예제 세트

### 파라메트릭 우선순위 디코더(조합)

```vhdl
entity prio_dec is
  generic (N: positive:=8);
  port(d: in std_logic_vector(N-1 downto 0);
       v: out std_logic; idx: out unsigned(ceil_log2(N)-1 downto 0));
end;
architecture rtl of prio_dec is
begin
  process(all)
    variable found: boolean := false;
    variable id   : unsigned(idx'range) := (others=>'0');
  begin
    v <= '0';
    for i in d'reverse_range loop
      if d(i)='1' and not found then
        v <= '1'; id := to_unsigned(i, id'length); found := true;
      end if;
    end loop;
    idx <= id;
  end process;
end;
```

### 원-핫 FSM (FPGA 친화)

```vhdl
signal S0,S1,S2: std_logic := '0';
process(clk) begin
  if rising_edge(clk) then
    if rst='1' then S0<='1'; S1<='0'; S2<='0';
    else
      S0 <= (S0 and not start) or (S2 and done);
      S1 <= (S0 and start)     or (S1 and not flag);
      S2 <= (S1 and flag);
    end if;
  end if;
end process;
y <= S2;  -- Moore 출력
```

### Gray 카운터(비동기 FIFO 포인터용)

```vhdl
signal bin, gray: unsigned(N-1 downto 0);
process(clk) begin
  if rising_edge(clk) then
    if rst='1' then bin<=(others=>'0');
    elsif inc='1' then bin<=bin+1; end if;
  end if;
end process;
gray <= bin xor (bin srl 1);
```

---

## 도구별 속성/보존/디버그

- Xilinx Vivado
  - `(* mark_debug = "true" *) signal sig: std_logic;`
  - `attribute keep : string; attribute keep of sig : signal is "true";`
- Intel Quartus
  - `attribute preserve : boolean; attribute preserve of sig : signal is TRUE;`

> 디버그/보존은 **필요 최소화**. 최적화 방해 주의.

---

## 합성 리포트 해석 & 품질 체크

- **Inferring latch?** → 조합 기본값/커버 확인.
- **Gated clock?** → CE로 교체.
- **Combinational loop?** → 피드백 경로 분해/레지스터 삽입.
- **Timing slack 음수?** → 파이프라인/로직 분해/폭 조정/버퍼링.
- **리소스 과다?** → 반복화(FSM), 상수곱 최적화, 폭 축소.

---

## 마무리 체크리스트

- [ ] 모든 조합 블록 `process(all)` + 기본값
- [ ] `case` 완전 커버, `when others` 존재
- [ ] CE 사용, 게이티드 클럭 없음
- [ ] 비동기 입력 2FF 동기화, 리셋 해제 동기화
- [ ] 산술은 `unsigned/signed`로 일관
- [ ] RAM/ROM/DSP 추론 패턴 준수
- [ ] Mealy 출력은 등록 후 외부로
- [ ] 루프는 정적 범위(while 금지)
- [ ] 멀티드라이버 없음(해결형 제외)
- [ ] 합성 리포트 경고 정리 완료

---

### 결론

합성가능한 VHDL은 **언어 기능 전부**가 아니라 **일관된 코딩 패턴**이 핵심입니다.
`numeric_std` 산술, **조합/순차 분리**, **래치/게이티드 클럭 금지**, **FSM 템플릿**, **메모리/DSP 추론 패턴**만 지켜도 이식성과 성능이 크게 향상됩니다.
여기에 **CDC/리셋 안정성**, **파이프라인과 valid 전파**, **레코드/패키지화**를 더하면 현업에서도 **안전하고 읽기 쉬운 RTL**을 만들 수 있습니다.
