---
layout: post
title: DB 심화 - 옵티마이저
date: 2025-11-15 16:25:23 +0900
category: DB 심화
---
# Oracle 옵티마이저

## 실측 실행계획과 통계 확인 루틴(반드시 습관화)

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS +ALIAS +NOTE'
));
```

### "실측"이 우선되어야 하는 이유

옵티마이저는 **예상 행 수(E-Rows)**를 기반으로 실행계획을 선택합니다. 실제 실행 결과인 **실제 행 수(A-Rows)**가 예상과 다르다면, 비용 모델이 잘못되었다는 의미이며 이것이 튜닝의 시작점이 됩니다. 모든 옵티마이저 튜닝은 결국 다음과 같은 두 가지 목표를 달성하는 과정입니다:

1. **E-Rows와 A-Rows의 차이를 최소화하는 것**
2. **정확한 비용 계산을 통해 최적의 실행계획을 선택하도록 하는 것**

---

## 실습 환경: 스키마, 데이터, 통계 설정

다음 스키마와 데이터는 선택도, 스큐, 조인, 변환 등 다양한 시나리오를 시연하기 위해 구성되었습니다.

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;

DROP TABLE CUST PURGE;
DROP TABLE PROD PURGE;
DROP TABLE ORD  PURGE;
DROP TABLE OI   PURGE;

CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8) NOT NULL,
  TIER    VARCHAR2(8) NOT NULL
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,
  BRAND    VARCHAR2(12) NOT NULL
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  ORDER_DT DATE  NOT NULL,
  STATUS   VARCHAR2(8) NOT NULL
);

CREATE TABLE OI(
  ORDER_ID NUMBER NOT NULL,
  LINE_NO  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, LINE_NO)
);

CREATE INDEX IX_ORD_CUST  ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_OI_PROD   ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER  ON OI(ORDER_ID);
CREATE INDEX IX_PROD_CAT  ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_CUST_REG  ON CUST(REGION, CUST_ID);

BEGIN
  -- 고객 데이터 생성 (지역별 편중 분포 포함)
  FOR c IN 1..50000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,6)
        WHEN 0 THEN 'KOR'  WHEN 1 THEN 'KOR'  WHEN 2 THEN 'APAC'
        WHEN 3 THEN 'EMEA' WHEN 4 THEN 'AMER' ELSE 'JPN' END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  -- 상품 데이터 생성 (브랜드별 편중 분포 포함)
  FOR p IN 1..10000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
        WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 3000 THEN 'B0' ELSE 'B'||TO_CHAR(MOD(p,50)) END
    );
  END LOOP;

  -- 주문 데이터 생성
  FOR o IN 1..120000 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,50000)+1,
      DATE '2024-01-01' + MOD(o,180),
      CASE MOD(o,4)
        WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  -- 주문 상세 데이터 생성
  FOR i IN 1..300000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,120000)+1,
      1 + MOD(i,3),
      MOD(i,10000)+1,
      1 + MOD(i,5),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

### 데이터 분포 특징(중요한 포인트)

- `CUST.REGION='KOR'`: KOR 지역 고객이 특별히 많아 데이터 스큐 현상을 보입니다.
- `PROD.BRAND='B0'`: B0 브랜드 상품이 전체의 30%를 차지하여 상위 빈도 값으로 집중되어 있습니다.
- `ORD`, `OI`: 조인, 집계, Top-N, 모드 차이를 보여주기에 적절한 규모의 데이터입니다.

---

## 옵티마이저의 개념과 역할

### 정의와 목표
옵티마이저는 SQL 문을 실행하기 위한 **실행계획(Execution Plan)**을 생성하는 Oracle 데이터베이스 엔진입니다. 그 목표는 **최소 비용(min-cost)**으로 정확한 결과를 반환하는 실행계획을 찾는 것입니다.

### "비용(Cost)"의 의미
비용은 추상적인 수치이지만, 실제로는 다음과 같은 리소스 사용량을 가중합한 값에 가깝습니다:

1. **I/O 비용**
   - 물리적 읽기(디스크 액세스)
   - 논리적 읽기(버퍼 캐시 액세스)
   - 싱글 블록 vs 멀티 블록 읽기

2. **CPU 비용**
   - 필터링, 조인, 정렬, 해싱, 구문 분석 작업

3. **메모리/TEMP 비용**
   - PGA 정렬/해시 영역 사용
   - 스필 발생 시 TEMP I/O 증가

4. **네트워크/지연 비용**
   - 분산 쿼리, 병렬 실행 데이터 재분배

5. **응답시간 vs 처리량 트레이드오프**
   - 모드 설정(ALL_ROWS vs FIRST_ROWS_n)으로 최적화 목표 조정

---

## 옵티마이저 동작 흐름

### 파싱(Parsing) 단계
1. **구문 분석(Syntax Parse)**: SQL 문법 검사
2. **의미 분석(Semantic Parse)**: 객체 존재 여부, 권한, 종속성 확인
3. **커서 조회(Cursor Lookup)**: 동일한 SQL과 환경이면 소프트 파싱 수행
4. **하드 파싱(Hard Parse)**: 새로운 실행계획 생성(비용이 높음)

### 쿼리 변환(Query Transformation) 단계
옵티마이저는 "의미를 보존하는 동등 변환"을 통해 SQL을 재작성합니다. 주요 변환 기술에는 다음이 포함됩니다:
- 뷰 머지(View Merging) / 조건절 재배치(Predicate Move-Around) / 조건절 푸시다운(Predicate Pushdown)
- 서브쿼리 언네스팅(Subquery Unnesting) / 스칼라 서브쿼리 캐싱(Scalar Subquery Caching)
- OR 확장(OR-Expansion, USE_CONCAT)
- 그룹 바이 배치(Group By Placement) / 집계 푸시다운(Aggregate Pushdown)
- 스타 변환(Star Transformation, 스타 스키마)
- 조인 제거(Join Elimination) / 외부 조인 단순화(Outer Join Simplification)
- **조건절 이행(Predicate Transitivity)**과 같은 논리적 전파

이 단계가 성공적으로 수행되면 "탐색 공간이 확장되어 더 나은 실행계획을 찾을 확률"이 높아집니다.

### 카디널리티(예상 행 수) 추정
- 테이블, 컬럼, 인덱스, 히스토그램, 확장 통계, 시스템 통계를 활용하여 **각 Row Source의 예상 행 수(E-Rows)**를 계산합니다.

### 후보 실행계획 탐색
- **액세스 경로(Access Path)** 후보
- **조인 순서(Join Order)** 후보  
- **조인 방법(Join Method)** 후보
- 병렬 처리, 파티셔닝, 샘플링, 적응형 후보

### 비용 계산 및 최저 비용 실행계획 선택
- 각 후보 실행계획에 대해 비용을 계산
- **가장 낮은 비용**의 실행계획을 최종 선택

### 실행 중 적응(Adaptive Execution)
Oracle 버전에 따라 차이는 있지만, 기본적으로:
- 실행 중 관측된 통계와 피드백을 활용하여
  조인 방법과 카디널리티 추정을 재조정할 수 있습니다.

---

## RBO vs CBO: 왜 CBO가 표준인가?

### RBO(Rule-Based Optimizer)
- 통계 없이 미리 정의된 우선순위 규칙에 따라 실행계획 선택
- 데이터 분포, 스큐, 파티셔닝, 병렬 처리, 시스템 성능을 반영하지 못함
- 현대 Oracle에서는 사실상 사용되지 않음

### CBO(Cost-Based Optimizer)
- 통계 기반으로 실제 비용을 모델링
- 데이터와 시스템 변화에 동적으로 대응
- 단, **통계 정보가 부정확하면 비용 계산이 틀리고 실행계획도 틀어집니다**

---

## 코스트 모델의 핵심 구성 요소

### 선택도(Selectivity)
조건이 "얼마나 많은 행을 걸러내는지"를 비율로 표현합니다.

- **동등 조건**:
  $$ \text{Sel}(col=v) \approx \frac{1}{NDV} \quad (\text{균등 분포 가정}) $$

- **범위 조건**:
  $$ \text{Sel}(a \le col < b) \approx \frac{\text{범위 너비}}{\text{전체 너비}} $$
  (히스토그램이 없을 때의 단순 근사)

### 카디널리티(Cardinality)
$$ \text{Card} = \text{입력 행 수} \times \text{선택도} $$

### 다중 조건(AND)의 기본 근사
독립성 가정 시:

$$ \text{Sel}(A \land B) \approx \text{Sel}(A) \times \text{Sel}(B) $$

그러나 실제 데이터는 상관관계가 강하여 이 근사가 부정확할 수 있습니다.
→ **확장 통계(컬럼 그룹)**로 보정해야 합니다.

### I/O 비용
- 싱글 블록 읽기 비용
- 멀티 블록 읽기 비용  
- 버퍼 캐시 적중률 추정
- 파티션 프루닝/인덱스 클러스터링 팩터 반영
- 필요한 경우 직접 경로 읽기(Direct Path Read)/스마트 스캔(Smart Scan) 고려

### CPU 비용
- 필터링, 계산, 조인, 정렬, 해싱, 변환 비용
- PGA 내부/외부 스필 발생 여부
- 병렬 실행(PX)의 데이터 분배 비용

---

## 옵티마이저가 활용하는 "통계"의 전체 그림

### 테이블 통계
- `NUM_ROWS`, `BLOCKS`, `AVG_ROW_LEN`
- 파티션 테이블의 경우 GLOBAL/PARTITION 통계

```sql
SELECT table_name, num_rows, blocks, last_analyzed
FROM   user_tab_statistics
WHERE  table_name IN ('CUST','PROD','ORD','OI');
```

### 컬럼 통계
- NDV(고유 값 수), 밀도(density), 최소/최대 값, NULL 수, 히스토그램 정보

```sql
SELECT table_name, column_name, num_distinct, density, num_nulls, histogram
FROM   user_tab_col_statistics
WHERE  table_name IN ('CUST','PROD','ORD','OI')
ORDER  BY table_name, column_name;
```

### 인덱스 통계
- `BLEVEL`, `LEAF_BLOCKS`, `DISTINCT_KEYS`, `CLUSTERING_FACTOR`

```sql
SELECT index_name, blevel, leaf_blocks, distinct_keys, clustering_factor
FROM   user_indexes
WHERE  table_name IN ('CUST','PROD','ORD','OI')
ORDER  BY table_name, index_name;
```

- 클러스터링 팩터(CF)가 높으면 인덱스 탐색 후 테이블 랜덤 I/O가 증가하여 NL 조인과 인덱스 스캔이 불리해집니다.

### 히스토그램
- 단일 컬럼의 "값/구간 분포"를 현실적으로 반영
- 데이터 스큐가 심한 컬럼에서 필수적

### 확장 통계(Extended Statistics)
- 컬럼 그룹: 상관관계 반영
- 표현식 통계: 함수/가상 컬럼 분포 반영

---

## 옵티마이저 모드(ALL_ROWS vs FIRST_ROWS_n)

모드는 **"최적화 목표"**를 조정합니다. 모드를 변경한다고 해서 항상 실행계획이 바뀌는 것은 아니지만, 최적화 경향에 강력한 영향을 미칩니다.

### ALL_ROWS 모드
- **처리량(Throughput) 최적화**에 중점
- 전체 결과를 가장 효율적으로 반환하는 방향
- 데이터 웨어하우스, 배치 작업, 리포트 생성에 적합
- 해시 조인, 풀 테이블 스캔, 병렬 처리 선호 경향

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;
```

### FIRST_ROWS / FIRST_ROWS_n 모드
- **초기 응답 시간(Latency) 최적화**에 중점
- 처음 n개 행을 빠르게 반환하는 방향
- OLTP 화면, Top-N 쿼리, 페이징 처리에 적합
- 선택도가 높은 인덱스와 Nested Loops 조인 선호 경향

```sql
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;
```

### 모드 선택 실무 가이드
- 시스템 기본값은 **ALL_ROWS**로 유지
- 특정 화면이나 쿼리에서만 FIRST_ROWS_n을 **세션 또는 힌트 수준**으로 적용하는 패턴이 안전합니다.

---

## 액세스 경로(Access Path) 심층 분석

### Table Full Scan (FTS)
- 테이블의 모든 블록을 순차적으로 읽습니다.
- 멀티 블록 I/O가 가능하여 대량 처리에 유리합니다.
- 선택도가 낮은 조건(많은 행이 반환됨)에서는 오히려 최적일 수 있습니다.

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM OI WHERE qty >= 1;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Index Unique Scan
- PK/UK와 같은 **단일 행 보장** 조건에서 사용됩니다.
- 비용이 매우 낮습니다.

```sql
EXPLAIN PLAN FOR
SELECT * FROM CUST WHERE cust_id = 12345;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Index Range Scan
- 인덱스 선두 컬럼에 범위 또는 동등 조건이 있을 때 사용됩니다.
- 반환 행 수가 적을 때 유리합니다.

```sql
EXPLAIN PLAN FOR
SELECT * FROM ORD
WHERE cust_id = 12345
AND order_dt >= DATE '2024-03-01'
AND order_dt <  DATE '2024-04-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Index Full Scan (IFS)
- 인덱스를 전체적으로 순서대로 읽습니다.
- 테이블 액세스 없이 인덱스만으로 결과를 생성할 때 유리합니다(커버링 인덱스).
- 정렬 작업을 대체할 수 있습니다.

```sql
EXPLAIN PLAN FOR
SELECT /* IFS demo */ prod_id
FROM   prod
ORDER  BY category, prod_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Index Fast Full Scan (IFFS, FFS)
- 인덱스를 "테이블처럼" 멀티 블록으로 스캔합니다.
- 정렬이나 순서 보장이 없습니다.
- 테이블보다 컬럼 폭이 좁아 풀 테이블 스캔 대체로 자주 사용됩니다.

```sql
EXPLAIN PLAN FOR
SELECT /* IFFS demo */ COUNT(prod_id)
FROM   prod
WHERE  brand='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Index Skip Scan
- 인덱스 선두 컬럼 조건이 없더라도, NDV가 작으면 선두 값을 "건너뛰며" 범위 스캔합니다.
- 복합 인덱스 설계가 최적이 아닌 경우의 구제 수단입니다.

```sql
EXPLAIN PLAN FOR
SELECT * FROM ORD
WHERE order_dt BETWEEN DATE '2024-02-01' AND DATE '2024-02-10';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

(`IX_ORD_CUST` 인덱스가 `(cust_id, order_dt)`로 구성되어 선두 컬럼 조건이 없지만 스킵 스캔이 발생할 수 있습니다)

---

## 조인 방법(NL / Hash / Sort-Merge) 종합 비교

### Nested Loops Join (NL)
- 바깥 테이블(outer)의 각 행에 대해 안쪽 테이블(inner)을 탐색합니다.
- **바깥 테이블 행 수가 적고, 안쪽 테이블에 효율적인 인덱스가 있을 때 최적의 성능**을 발휘합니다.
- 랜덤 I/O가 증가할 수 있어 "E-Rows 정확도"가 특히 중요합니다.

```sql
EXPLAIN PLAN FOR
SELECT /*+ USE_NL(o) */ c.cust_id, o.order_id
FROM   cust c
JOIN   ord  o ON o.cust_id = c.cust_id
WHERE  c.region='KOR' AND c.tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Hash Join (HJ)
- 작은 테이블을 Build(Hash Area)로, 큰 테이블을 Probe로 사용합니다.
- **대량 조인, 비등치 조인, 집계 후 조인에서 유리**합니다.
- 메모리가 부족하면 스필로 인해 TEMP I/O가 폭증할 수 있습니다.

```sql
EXPLAIN PLAN FOR
SELECT /*+ USE_HASH(o) */ c.region, COUNT(*)
FROM   cust c
JOIN   ord  o ON o.cust_id=c.cust_id
GROUP  BY c.region;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Sort-Merge Join (SMJ)
- 양쪽 테이블을 조인 키로 정렬한 후 병합합니다.
- 이미 정렬되어 있거나 인덱스를 통해 정렬을 대체할 수 있을 때 유리합니다.
- 대량 조인에서 해시 조인보다 느릴 수 있으나, **"정렬을 어차피 수행해야 하는 경우"** 경쟁력이 있습니다.

```sql
EXPLAIN PLAN FOR
SELECT /*+ USE_MERGE(o) */ c.cust_id, o.order_id
FROM   cust c
JOIN   ord  o ON o.cust_id=c.cust_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 조인 순서의 중요성
조인 방법은 "입력 카디널리티"에 민감하게 반응합니다. 조인 순서가 변경되면 각 단계의 입력 크기가 달라지며, 이는 **완전히 다른 비용 구조와 실행계획**으로 이어질 수 있습니다.

---

## 히스토그램과 데이터 스큐가 실행계획에 미치는 영향

### BRAND 컬럼 스큐: 인기값 vs 희소값

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname   => USER,
    tabname   => 'PROD',
    method_opt=> 'FOR COLUMNS SIZE 254 BRAND'
  );
END;
/

EXPLAIN PLAN FOR SELECT COUNT(*) FROM prod WHERE brand='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR SELECT COUNT(*) FROM prod WHERE brand='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- `brand='B0'`: 히스토그램을 통해 실제 많은 행 수를 반영하여 E-Rows가 크게 추정되며, 풀 테이블 스캔 또는 인덱스 패스트 풀 스캔이 비용 효율적으로 계산될 수 있습니다.
- `brand='B47'`: 히스토그램을 통해 실제 적은 행 수를 반영하여 E-Rows가 작게 추정되며, 인덱스 범위 스캔이 비용 효율적으로 계산될 수 있습니다.
- 히스토그램이 없으면 두 조건 모두 동일한 밀도(density) 값을 사용하여 비슷한 E-Rows로 추정됩니다.

### REGION 컬럼 스큐: CUST 테이블 필터가 조인 순서에 미치는 영향

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust c
JOIN   ord  o ON o.cust_id=c.cust_id
WHERE  c.region='KOR';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- `region='KOR'` 조건의 선택도("많다/적다"에 대한 판단)가 변경되면, **CUST 테이블을 먼저 읽을지 ORD 테이블을 먼저 읽을지**에 대한 결정이 완전히 뒤바뀔 수 있습니다.

---

## 모드가 실제 실행계획을 변경하는 대표 시나리오: Top-N 쿼리

### 시나리오: "KOR 지역 VIP 고객이 구매한 ELEC 카테고리 상품의 매출 상위 10개 주문 조회"

```sql
VAR n NUMBER; EXEC :n:=10;

SELECT /* demo */ o.order_id, SUM(i.amount) amt
FROM   ord o
JOIN   oi  i ON i.order_id=o.order_id
JOIN   cust c ON c.cust_id=o.cust_id
JOIN   prod p ON p.prod_id=i.prod_id
WHERE  c.region='KOR'
AND    c.tier='VIP'
AND    p.category='ELEC'
GROUP  BY o.order_id
ORDER  BY amt DESC
FETCH FIRST :n ROWS ONLY;
```

### ALL_ROWS 모드에서 기대되는 실행계획 경향
- 전체 집계량을 빠르게 계산하기 위해 **해시 조인 + 대량 스캔 + 단일 정렬**을 선호할 가능성이 높습니다.

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;
-- 위 SQL 실행 후 실측 실행계획 확인
```

### FIRST_ROWS_10 모드에서 기대되는 실행계획 경향
- **먼저 축소할 수 있는 부분을 최대한 먼저 축소하고** Nested Loops 조인으로 접근하여 "10개 행만 빠르게" 추출하려는 경향을 보입니다.

```sql
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;
-- 위 SQL 실행 후 실측 실행계획 확인
```

### 모드 변경만으로 실행계획이 바뀌지 않는 경우
데이터 스큐, 통계 정보, 인덱스 구성, 클러스터링 팩터 등이 이미 특정 액세스 경로를 압도적으로 유리하게 만들었을 수 있습니다. 이 경우 모드 변경보다 **SQL 구조 최적화, 인덱스 설계, 통계 정보 관리**가 더 높은 우선순위를 가집니다.

---

## 옵티마이저 힌트와 모드의 역할 분담

- **모드**: 시스템 전반의 기본 최적화 방향 설정
- **힌트**: 특정 SQL 문의 핵심 결정 사항 고정

예시: 시스템 기본 모드는 ALL_ROWS로 설정되어 있지만, 특정 화면 SQL만 "초기 응답 시간이 중요"할 수 있습니다.

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;

SELECT /*+ LEADING(c o i p)
           USE_NL(o) USE_NL(i) USE_NL(p)
           INDEX(c IX_CUST_REG)
           INDEX(p IX_PROD_CAT)
           FIRST_ROWS(10) */
       o.order_id, SUM(i.amount) amt
FROM   cust c
JOIN   ord  o ON o.cust_id=c.cust_id
JOIN   oi   i ON i.order_id=o.order_id
JOIN   prod p ON p.prod_id=i.prod_id
WHERE  c.region='KOR' AND c.tier='VIP'
AND    p.category='ELEC'
GROUP  BY o.order_id
ORDER  BY amt DESC
FETCH FIRST 10 ROWS ONLY;
```

- `FIRST_ROWS(10)` 힌트는 모드 설정보다 더 강력하게 초기 응답 시간 최적화 경향을 주입합니다.

---

## 쿼리 변환(Query Transformation) 핵심 8가지와 실전 예제

쿼리 변환은 "옵티마이저가 더 나은 실행계획을 찾을 수 있도록 SQL을 재구성하는 과정"입니다.

### 1. View Merging (뷰 병합)
인라인 뷰를 외부 쿼리와 병합하여 조건 푸시다운 및 전파를 가능하게 합니다.

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM (
  SELECT prod_id FROM prod WHERE category='ELEC'
) v
JOIN oi i ON i.prod_id=v.prod_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 뷰 병합이 성공하면 `category='ELEC'` 조건이 OI 테이블까지 더 강력하게 전파될 수 있습니다.

### 2. Predicate Pushdown (조건절 푸시다운)
필터 조건을 가능한 한 하위 단계(베이스 테이블, 파티션, 인덱스)로 내립니다.

### 3. Predicate Transitivity (조건절 이행)
등치 조인을 매개로 조건을 반대쪽 테이블로 전파합니다.

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust c
JOIN   ord  o ON o.cust_id=c.cust_id
WHERE  c.cust_id BETWEEN 100 AND 200;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 성공하면 `o.cust_id BETWEEN 100 AND 200` 조건이 액세스 조건으로 하강합니다.

### 4. Subquery Unnesting (서브쿼리 언네스팅)
서브쿼리를 조인으로 변환하여 조인 순서 탐색이 가능하도록 합니다.

### 5. OR Expansion (OR 확장, USE_CONCAT)
OR 조건을 UNION ALL로 분해하여 각 분기별 최적의 실행계획을 생성할 수 있게 합니다.

```sql
EXPLAIN PLAN FOR
SELECT /*+ USE_CONCAT */ COUNT(*)
FROM   prod
WHERE  brand='B0' OR category='ELEC';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 6. Aggregate Pushdown / Group By Placement (집계 푸시다운 / 그룹 바이 배치)
집계 작업을 더 하위 단계로 내려 조인 입력 크기를 축소하는 변환입니다.

### 7. Join Elimination (조인 제거)
FK/PK와 NOT NULL 제약이 엄격할 때 불필요한 조인을 제거합니다.

### 8. Star Transformation (스타 변환)
스타 스키마 환경에서 차원 테이블의 필터 조건을 팩트 테이블로 강력하게 전파합니다.

---

## 적응형 기능(Adaptive Features) 심층 분석

### Dynamic Sampling (동적 샘플링)
통계 정보가 부족하거나 불확실할 때 런타임에 데이터 샘플을 추출하여 보정합니다.

```sql
ALTER SESSION SET optimizer_dynamic_sampling = 4;

EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   oi i JOIN prod p ON p.prod_id=i.prod_id
WHERE  p.brand='B47';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 통계 정보가 정확하면 동적 샘플링이 필요하지 않습니다.
- **통계 정보 관리가 가장 우선순위인 작업**입니다.

### Adaptive Cursor Sharing (ACS)
바인드 변수 값의 구간이 다를 경우 하위 커서(child cursor)를 분기하여 서로 다른 실행계획을 학습하고 적용합니다.

```sql
ALTER SYSTEM FLUSH SHARED_POOL;
VARIABLE b_brand VARCHAR2(12);

EXEC :b_brand := 'B47';
SELECT COUNT(*) FROM prod WHERE brand=:b_brand;

EXEC :b_brand := 'B0';
SELECT COUNT(*) FROM prod WHERE brand=:b_brand;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +NOTE'));
```

- 첫 번째 바인드 피킹 값에 고정되는 문제를 완화합니다.
- 단, 학습과 분기까지 일정 시간이 필요할 수 있습니다.

### Statistics Feedback (카디널리티 피드백)
반복 실행 중 관측된 실제 행 수를 기반으로 다음 하드 파싱 시 카디널리티 추정을 보정합니다.

---

## 실행계획 불안정성(Plan Instability): 원인, 진단, 해결 로드맵

### 가장 흔한 원인 TOP 10
1. 통계 정보의 노후화 또는 오염
2. 데이터 스큐/상관관계 미반영(히스토그램/확장 통계 부재)
3. 바인드 변수 피킹과 실행계획 재사용 문제
4. 인덱스 클러스터링 팩터 악화(테이블 재정렬/대량 DML)
5. 파티션 누락/글로벌 통계 추정 오류
6. 쿼리 변환 장애(OR 조건/함수/외부 조인)
7. SQL 텍스트의 미세 변화로 인한 커서 분리(형변환/공백/힌트 등)
8. 옵티마이저 관련 파라미터 변경
9. 업그레이드/패치로 인한 비용 모델 변화
10. 시스템 통계/스토리지 성능 변화

### 실전 진단 순서
1. `DISPLAY_CURSOR + ALLSTATS LAST`로 **실제 I/O가 많은 Row Source** 확인
2. `E-Rows vs A-Rows` 차이가 가장 큰 구간 식별
3. 해당 구간의 **조건절, 통계, 히스토그램, 확장 통계, 쿼리 변환** 상태 점검
4. 수정 작업 후 재실행 및 실측 검증
5. 필요한 경우 실행계획 안정화 도구(베이스라인/프로파일) 적용

---

## 실행계획 안정화 도구(핵심 개념)

### SQL Plan Baseline
- "이전에 좋았던 실행계획"을 채택(accept)하여 실행계획 회귀(plan regression)를 방지합니다.
- 데이터베이스 업그레이드나 통계 정보 변동 환경에서 특히 유용합니다.

### SQL Profile / SQL Patch
- 카디널리티 추정 보정 또는 힌트 주입을 통해 실행계획을 교정합니다.
- 긴급한 문제 해결 또는 특정 SQL 보호 목적으로 사용됩니다.

> 이러한 도구는 최후의 수단이며, 1차 해결책은 항상 **통계 정보 관리, SQL 구조 최적화, 인덱스 설계**입니다.

---

## 실전 종합 시나리오 3가지

### 시나리오 A — 인기값에서 비효율적인 인덱스 사용으로 인한 성능 저하
- **조건**: `brand='B0'`와 같은 상위 빈도 값 조회
- **문제**: 밀도(density) 기반으로 적은 행 수로 추정 → 인덱스 범위 스캔 선택 → 랜덤 I/O 폭증
- **해결**: 히스토그램 정밀화 및 필요한 경우 인덱스 패스트 풀 스캔 유도

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR COLUMNS SIZE 254 BRAND');
END;
/
```

### 시나리오 B — 결합 조건의 상관관계로 인한 조인 순서 오류
- **조건**: `region='KOR' AND tier='VIP'`
- **해결**: 확장 통계(컬럼 그룹) 생성

```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION,TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
```

### 시나리오 C — Top-N 화면 응답 시간 저하(과도한 정렬 작업)
- **해결 1**: FIRST_ROWS_n 모드 또는 힌트 적용
- **해결 2**: Stopkey 최적화가 가능한 구조(정렬 키 + PK)로 인덱스 설계
- **해결 3**: "정렬 전에 결과 집합 최소화(Top-N 최적화)"

```sql
-- 결과 집합 최소화 및 Stopkey로 Top-N만 정렬
EXPLAIN PLAN FOR
SELECT order_id
FROM (
  SELECT /*+ INDEX_DESC(o IX_ORD_CUST) */ o.order_id, o.order_dt
  FROM   ord o
  WHERE  o.cust_id=:k
  ORDER  BY o.order_dt DESC
)
FETCH FIRST 10 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## 운영 환경에서의 옵티마이저 관리 체크리스트

### 통계 관리
- 자동 샘플링 크기(AUTO_SAMPLE_SIZE) 활용
- 데이터 스큐가 있는 컬럼에 SKEWONLY/AUTO 히스토그램 적용
- `DBMS_STATS.REPORT_COL_USAGE`를 활용한 컬럼 사용 패턴 분석

### 상관관계 관리
- 확장 통계(컬럼 그룹)를 활용한 결합 조건 선택도 정확도 향상

### 파티션 테이블 관리
- 증분 통계(Incremental Statistics) 활용
- 변경된 파티션만 통계 재수집

### 바인드 변수 관리
- Adaptive Cursor Sharing(ACS) 학습 및 분기 상태 모니터링

### 중요 SQL 관리
- SQL Plan Baseline 또는 SQL Profile을 활용한 실행계획 회귀 방지

### 변경 검증
- 모든 변경 사항은 실측 실행계획(E/A Rows, Buffers, I/O, Memory 사용량)으로 검증

---

## 결론

옵티마이저 튜닝의 본질은 다음과 같은 한 문장으로 요약할 수 있습니다:

> **정확한 통계 정보로 선택도와 카디널리티를 현실화하고, 이 현실화된 비용 모델이 자연스럽게 올바른 실행계획을 선택하도록 만드는 것입니다.**

- CBO에게 통계 정보는 "눈"과 같습니다. 정확한 통계 없이는 올바른 판단을 내릴 수 없습니다.
- 옵티마이저 모드는 "목표 방향"을 설정할 뿐이며, 핵심은 **통계 정보 관리, SQL 구조 최적화, 물리적 데이터베이스 설계**에 있습니다.
- 쿼리 변환(조건절 푸시다운, 이행, 언네스팅, OR 확장 등)이 활성화되어 있어야 좋은 실행계획을 찾을 수 있는 탐색 공간이 확장됩니다.
- 모든 튜닝 작업의 최종 검증은 반드시 **실측 실행계획 분석**을 통해 이루어져야 합니다.

이 가이드의 모든 예제는 `ALLSTATS LAST` 옵션을 통한 실측 검증이 가능하도록 설계되었습니다. 이러한 팩트 기반 검증 프로세스를 체득하면, Oracle 옵티마이저 튜닝의 80%를 이미 마스터한 것입니다. 옵티마이저는 복잡해 보일 수 있지만, 그 동작 원리를 체계적으로 이해하고 실전 경험을 쌓는다면 데이터베이스 성능 최적화의 강력한 도구가 될 것입니다.