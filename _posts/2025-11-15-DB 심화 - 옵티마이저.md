---
layout: post
title: DB 심화 - 옵티마이저
date: 2025-11-15 16:25:23 +0900
category: DB 심화
---
# Oracle 옵티마이저(Optimizer) — CBO의 원리·통계·코스트 모델·모드·변환·적응형 기능·플랜 안정화·실전 튜닝 전 과정

## 실측 실행계획/통계 확인 루틴(반드시 습관화)

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL, NULL,
        'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS +ALIAS +NOTE'
));
```

### 왜 “실측”이 먼저인가?

- 옵티마이저는 **예상(E-Rows)** 으로 플랜을 고른다.
- 실제(A-Rows)가 다르면, 비용 모델이 틀렸다는 뜻이고 튜닝의 시작점이다.
- 모든 옵티마이저 튜닝은 결국
  **(1) E-Rows vs A-Rows 차이를 줄이고**
  **(2) 그 결과로 코스트/플랜을 바꾸는 것**이다.

---

## 준비: 실습 스키마/데이터/통계 (선택도·스큐·조인·변환 시연용)

> 사용자가 제공한 스키마/데이터를 유지하되, 설명과 시나리오를 대폭 확장한다.

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;   -- ALLSTATS LAST

DROP TABLE CUST PURGE;
DROP TABLE PROD PURGE;
DROP TABLE ORD  PURGE;
DROP TABLE OI   PURGE;

CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8) NOT NULL,
  TIER    VARCHAR2(8) NOT NULL
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,
  BRAND    VARCHAR2(12) NOT NULL
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  ORDER_DT DATE  NOT NULL,
  STATUS   VARCHAR2(8) NOT NULL
);

CREATE TABLE OI(
  ORDER_ID NUMBER NOT NULL,
  LINE_NO  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, LINE_NO)
);

CREATE INDEX IX_ORD_CUST  ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_OI_PROD   ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER  ON OI(ORDER_ID);
CREATE INDEX IX_PROD_CAT  ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_CUST_REG  ON CUST(REGION, CUST_ID);

BEGIN
  FOR c IN 1..50000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,6)
        WHEN 0 THEN 'KOR'  WHEN 1 THEN 'KOR'  WHEN 2 THEN 'APAC'
        WHEN 3 THEN 'EMEA' WHEN 4 THEN 'AMER' ELSE 'JPN' END,
      CASE MOD(c,4)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD'
        WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..10000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD'
        WHEN 2 THEN 'TOY'  WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 3000 THEN 'B0' ELSE 'B'||TO_CHAR(MOD(p,50)) END
    );
  END LOOP;

  FOR o IN 1..120000 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,50000)+1,
      DATE '2024-01-01' + MOD(o,180),
      CASE MOD(o,4)
        WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR i IN 1..300000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,120000)+1,
      1 + MOD(i,3),
      MOD(i,10000)+1,
      1 + MOD(i,5),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

### 데이터 분포(중요 포인트)

- `CUST.REGION='KOR'`가 **특별히 많게** 스큐를 만든다.
- `PROD.BRAND='B0'`가 **상위 빈도**로 몰려 있다.
- `ORD`, `OI`는 조인/집계/Top-N/모드 차이를 보여 주는 규모.

---

## 옵티마이저란 무엇인가?

### 정의

- 옵티마이저는 SQL을 실행하기 위한 **실행계획(Execution Plan)** 을 만드는 엔진이다.
- 목표는 **최소 비용(min-cost)** 으로 결과를 얻는 것.

### “비용(cost)”의 의미

비용은 추상치지만, 실제로는 다음 리소스의 가중합에 가깝다.

1) **I/O 비용**
   - 물리 읽기(디스크)
   - 논리 읽기(버퍼 캐시)
   - 싱글블록 vs 멀티블록
2) **CPU 비용**
   - 필터/조인/정렬/해시/분해 등
3) **메모리/Temp 비용**
   - PGA sort/ hash area
   - spill 시 TEMP I/O 폭증
4) **네트워크/지연 비용**
   - 분산 쿼리, PX 데이터 재분배 등
5) **응답시간 vs 처리량 트레이드오프**
   - 모드(ALL_ROWS vs FIRST_ROWS_n)로 경향 조정

---

## 옵티마이저 동작 흐름(정밀 버전)

### 파싱(Parsing)

1) **Syntax Parse**: 문법 확인
2) **Semantic Parse**: 객체/권한/종속성 확인
3) **Cursor Lookup**: 동일 SQL/환경이면 soft parse
4) **Hard Parse**: 새 플랜 생성(비용 큼)

### 쿼리 변환(Query Transformation)

옵티마이저는 “의미를 보존하는 동치 변환”으로 SQL을 다시 쓴다.

- View Merging / Predicate Move-Around / Predicate Pushdown
- Subquery Unnesting / Scalar Subquery Caching
- OR-Expansion (USE_CONCAT)
- Group By Placement / Aggregate Pushdown
- Star Transformation(스타 스키마)
- Join Elimination / Outer Join Simplification(가능할 때)
- **조건절 이행(predicate transitivity)** 같은 논리적 전파

이 단계가 잘 되면 “탐색 공간이 넓어져 좋은 플랜을 찾을 확률”이 올라간다.

### 카디널리티(예상 행수) 추정

- 테이블/컬럼/인덱스/히스토그램/확장통계/시스템 통계로
  **각 Row Source의 예상 행수(E-Rows)** 를 계산한다.

### 후보 플랜 탐색

- **액세스 경로(access path)** 후보
- **조인 순서(join order)** 후보
- **조인 방법(join method)** 후보
- 병렬/파티션/샘플링/적응형 후보

### 코스트 계산 & 최저 비용 플랜 선택

- 각 후보마다 cost를 산출
- **가장 낮은 cost** 플랜이 최종 선택된다.

### 실행 중 적응(Adaptive)

버전별로 차이는 있지만, 기본적으로:
- 실행 중 관측된 통계/피드백으로
  조인 방법/카디널리티를 다시 보정할 수 있다.

---

## RBO vs CBO (왜 CBO가 표준인가)

### RBO (Rule-Based Optimizer)

- 통계 없이 미리 정해진 우선순위 규칙으로 플랜 선택
- 데이터 분포/스큐/파티션/병렬/시스템 성능을 반영 못함
- 현대 Oracle에서는 사실상 폐기

### CBO (Cost-Based Optimizer)

- 통계 기반으로 실제 비용을 모델링
- 데이터/시스템 변화에 대응
- 단, **통계가 틀리면 cost가 틀리고 플랜도 틀린다.**

---

## 코스트 모델의 핵심 구성요소

### 선택도(selectivity)

조건이 “얼마나 걸러내는가”를 비율로 표현.

- 동등 조건:
  $$ \text{Sel}(col=v) \approx \frac{1}{NDV} \quad (\text{균등 가정}) $$

- 범위 조건:
  $$ \text{Sel}(a \le col < b) \approx \frac{\text{range width}}{\text{total width}} $$
  (히스토그램이 없을 때의 단순 근사)

### 카디널리티(cardinality)

$$ \text{Card} = \text{Input Rows} \times \text{Sel} $$

### 다중 조건(AND)의 기본 근사

독립 가정 시:

$$ \text{Sel}(A \land B) \approx \text{Sel}(A) \times \text{Sel}(B) $$

하지만 현실 데이터는 상관관계가 커서 이 근사가 망가진다.
→ **확장통계(컬럼 그룹)** 으로 보정해야 한다.

### I/O 코스트

- 싱글블록 읽기 비용
- 멀티블록 읽기 비용
- 버퍼 캐시 히트율 추정
- 파티션 프루닝/인덱스 클러스터링 팩터 반영
- 필요시 Direct Path Read/Smart Scan 고려

### CPU 코스트

- 필터/계산/조인/정렬/해시/변환 비용
- PGA 내/외 spill 여부
- PX(병렬)의 분배 비용

---

## 옵티마이저가 사용하는 “통계”의 전체 그림

### 테이블 통계

- `NUM_ROWS`, `BLOCKS`, `AVG_ROW_LEN`
- 파티션 테이블이면 GLOBAL/PARTITION 통계

```sql
SELECT table_name, num_rows, blocks, last_analyzed
FROM   user_tab_statistics
WHERE  table_name IN ('CUST','PROD','ORD','OI');
```

### 컬럼 통계

- NDV, density, low/high value, nulls, histogram info

```sql
SELECT table_name, column_name, num_distinct, density, num_nulls, histogram
FROM   user_tab_col_statistics
WHERE  table_name IN ('CUST','PROD','ORD','OI')
ORDER  BY table_name, column_name;
```

### 인덱스 통계

- `BLEVEL`, `LEAF_BLOCKS`, `DISTINCT_KEYS`, `CLUSTERING_FACTOR`

```sql
SELECT index_name, blevel, leaf_blocks, distinct_keys, clustering_factor
FROM   user_indexes
WHERE  table_name IN ('CUST','PROD','ORD','OI')
ORDER  BY table_name, index_name;
```

- CF가 높으면 인덱스 탐색 후 테이블 랜덤 I/O가 늘어
  NL/인덱스 스캔이 불리해진다.

### 히스토그램

- 단일 컬럼의 “값/구간 분포”를 현실화
- 스큐가 큰 컬럼에서 필수

### 확장 통계(Extended Stats)

- 컬럼 그룹: 상관관계 반영
- 표현식 통계: 함수/가상 컬럼의 분포 반영

---

## 옵티마이저 모드(ALL_ROWS vs FIRST_ROWS_n)

> 모드는 **“최적화 목표”** 를 조정한다.
> (모드를 바꾼다고 무조건 플랜이 바뀌는 건 아니지만, 경향을 강하게 흔든다.)

### ALL_ROWS

- **처리량(Throughput) 최적화**
- 전체 결과를 가장 싸게 뽑는 방향
- DW/배치/리포트에 적합
- 해시조인/풀스캔/병렬 선호 경향

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;
```

### FIRST_ROWS / FIRST_ROWS_n

- **초기 응답시간(Latency) 최적화**
- 처음 n행을 빨리 내는 방향
- OLTP 화면/Top-N/페이지네이션에 적합
- 선택도 높은 인덱스와 NL을 선호 경향

```sql
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;
```

### 모드 선택 실무 요령

- 시스템 기본은 **ALL_ROWS** 로 두고
- 특정 화면/쿼리만 FIRST_ROWS_n을 **세션/힌트 단위**로 적용하는 패턴이 안전하다.

---

## 액세스 경로(Access Path) 전부 파헤치기

### Table Full Scan (FTS)

- 테이블 블록을 연속적으로 읽는다.
- 멀티블록 I/O가 가능해 대량 처리에 유리.
- 선택도가 낮은 조건(= 많은 행이 남음)에서 오히려 최적.

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*) FROM OI WHERE qty >= 1;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Index Unique Scan

- PK/UK 등 **단일 행 보장** 조건에서 사용.
- cost가 매우 낮다.

```sql
EXPLAIN PLAN FOR
SELECT * FROM CUST WHERE cust_id = 12345;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Index Range Scan

- 선두컬럼 조건 + 범위/동등 조건에서 사용.
- 반환 행이 적을 때 유리.

```sql
EXPLAIN PLAN FOR
SELECT * FROM ORD
WHERE cust_id = 12345
AND order_dt >= DATE '2024-03-01'
AND order_dt <  DATE '2024-04-01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Index Full Scan (IFS)

- 인덱스를 전체 순서대로 읽는다.
- 테이블을 안 읽고 인덱스만으로 결과를 낼 때 유리(covering).
- 정렬을 대체할 수 있다.

```sql
EXPLAIN PLAN FOR
SELECT /* IFS demo */ prod_id
FROM   prod
ORDER  BY category, prod_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Index Fast Full Scan (IFFS, FFS)

- 인덱스를 “테이블처럼” 멀티블록으로 스캔.
- 정렬/순서 보장 없음.
- 테이블보다 폭이 좁아 FTS 대체로 자주 쓰임.

```sql
EXPLAIN PLAN FOR
SELECT /* IFFS demo */ COUNT(prod_id)
FROM   prod
WHERE  brand='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Index Skip Scan

- 선두컬럼 조건이 없어도, NDV가 작으면 선두값을 “건너뛰며” 범위 스캔.
- 복합 인덱스 설계가 어쩔 수 없이 어긋난 경우 구원투수.

```sql
EXPLAIN PLAN FOR
SELECT * FROM ORD
WHERE order_dt BETWEEN DATE '2024-02-01' AND DATE '2024-02-10';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

(IX_ORD_CUST가 (cust_id, order_dt)라 선두컬럼이 없는데 skip scan이 나올 수 있음)

---

## 조인 방법(NL / Hash / Sort-Merge) 완전 비교

### Nested Loops Join (NL)

- 바깥 테이블(outer)의 각 행마다 안쪽(inner)을 탐색
- **바깥 행이 적고, 안쪽에 좋은 인덱스가 있을 때 최강**
- 랜덤 I/O가 증가할 수 있어 “E-Rows 정확도”가 특히 중요.

```sql
EXPLAIN PLAN FOR
SELECT /*+ USE_NL(o) */ c.cust_id, o.order_id
FROM   cust c
JOIN   ord  o ON o.cust_id = c.cust_id
WHERE  c.region='KOR' AND c.tier='VIP';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Hash Join (HJ)

- 작은 쪽을 Build(Hash Area), 큰 쪽을 Probe
- **대량 조인, 비등치/집계 후 조인에서 유리**
- 메모리가 부족하면 spill로 TEMP 폭증 가능.

```sql
EXPLAIN PLAN FOR
SELECT /*+ USE_HASH(o) */ c.region, COUNT(*)
FROM   cust c
JOIN   ord  o ON o.cust_id=c.cust_id
GROUP  BY c.region;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Sort-Merge Join (SMJ)

- 양쪽을 조인키로 정렬 후 병합
- 이미 정렬돼 있거나 인덱스로 정렬을 대체할 때 유리
- 대량 조인에서 HJ보다 느릴 수 있으나
  “정렬을 어차피 해야 하는 경우” 경쟁력이 있다.

```sql
EXPLAIN PLAN FOR
SELECT /*+ USE_MERGE(o) */ c.cust_id, o.order_id
FROM   cust c
JOIN   ord  o ON o.cust_id=c.cust_id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### 조인 순서가 왜 그렇게 중요한가?

- 조인 방법은 “입력 카디널리티”에 민감하다.
- 순서가 바뀌면 각 단계 입력량이 달라져 **코스트가 전혀 다른 세계**가 된다.

---

## 히스토그램/스큐가 플랜을 바꾸는 실제 흐름

### BRAND 스큐: 인기값 vs 희소값

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname   => USER,
    tabname   => 'PROD',
    method_opt=> 'FOR COLUMNS SIZE 254 BRAND'
  );
END;
/

EXPLAIN PLAN FOR SELECT COUNT(*) FROM prod WHERE brand='B0';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR SELECT COUNT(*) FROM prod WHERE brand='B47';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- `brand='B0'`는 E-Rows가 커져 풀스캔/FFS가 싸게 계산될 수 있다.
- `brand='B47'`는 E-Rows가 작아져 range scan이 싸게 된다.
- 히스토그램이 없을 때는 둘 다 density로 비슷하게 취급한다.

### REGION 스큐: CUST 쪽 필터가 조인 순서를 바꾼다

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust c
JOIN   ord  o ON o.cust_id=c.cust_id
WHERE  c.region='KOR';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- `region='KOR'`이 “많다/적다”의 판단이 바뀌면
  **CUST 먼저 읽을지, ORD 먼저 읽을지**가 뒤집힌다.

---

## 모드가 실제 플랜을 바꾸는 대표 시나리오 (Top-N)

> “KOR VIP 고객이 산 ELEC 상품 매출 Top-10 주문”

```sql
VAR n NUMBER; EXEC :n:=10;

SELECT /* demo */ o.order_id, SUM(i.amount) amt
FROM   ord o
JOIN   oi  i ON i.order_id=o.order_id
JOIN   cust c ON c.cust_id=o.cust_id
JOIN   prod p ON p.prod_id=i.prod_id
WHERE  c.region='KOR'
AND    c.tier='VIP'
AND    p.category='ELEC'
GROUP  BY o.order_id
ORDER  BY amt DESC
FETCH FIRST :n ROWS ONLY;
```

### ALL_ROWS에서 기대되는 경향

- 전체 집계량을 빨리 계산하려고
  **HJ + 대량 스캔 + 단 한번의 정렬**을 선호할 가능성이 크다.

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;
-- 위 SQL 실행 후 실측 플랜 확인
```

### FIRST_ROWS_10에서 기대되는 경향

- **먼저 좁힐 수 있는 곳을 최대한 먼저 좁히고**
  NL로 타고 들어가 “10개만 빨리” 뽑으려는 경향.

```sql
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;
-- 위 SQL 실행 후 실측 플랜 확인
```

### 모드만으로 안 바뀌면?

- 스큐/통계/인덱스/CF가 이미 특정 경로를 압도적으로 유리하게 만들었을 수 있다.
- 이럴 땐 모드보다 **SQL 구조/인덱스/통계가 우선순위**다.

---

## 옵티마이저 힌트와 모드의 “역할 분담”

- **모드**: 시스템 전체의 기본 성향
- **힌트**: 특정 SQL의 핵심 결정을 고정

예: 시스템은 ALL_ROWS지만, 특정 화면 SQL만 “초기응답이 중요”할 수 있다.

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;

SELECT /*+ LEADING(c o i p)
           USE_NL(o) USE_NL(i) USE_NL(p)
           INDEX(c IX_CUST_REG)
           INDEX(p IX_PROD_CAT)
           FIRST_ROWS(10) */
       o.order_id, SUM(i.amount) amt
FROM   cust c
JOIN   ord  o ON o.cust_id=c.cust_id
JOIN   oi   i ON i.order_id=o.order_id
JOIN   prod p ON p.prod_id=i.prod_id
WHERE  c.region='KOR' AND c.tier='VIP'
AND    p.category='ELEC'
GROUP  BY o.order_id
ORDER  BY amt DESC
FETCH FIRST 10 ROWS ONLY;
```

- `FIRST_ROWS(10)` 힌트는 모드보다 강력하게 초기 응답 경향을 주입한다.

---

## Query Transformation(변환) 핵심 8가지 + 실전 예

> 변환은 “옵티마이저가 더 좋은 플랜을 찾도록 SQL을 펼치는 과정”이다.

### View Merging (뷰 머지)

인라인 뷰를 바깥으로 병합해 푸시/이행을 가능하게 한다.

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM (
  SELECT prod_id FROM prod WHERE category='ELEC'
) v
JOIN oi i ON i.prod_id=v.prod_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 머지가 되면 `category='ELEC'` 조건이 OI까지 더 강하게 전파될 수 있다.

### Predicate Pushdown

필터를 가능한 하단(베이스 테이블/파티션/인덱스)으로 내린다.

### Predicate Transitivity(조건절 이행)

등치 조인을 매개로 조건을 반대쪽으로 전파.

```sql
EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   cust c
JOIN   ord  o ON o.cust_id=c.cust_id
WHERE  c.cust_id BETWEEN 100 AND 200;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 성공하면 `o.cust_id BETWEEN ...`가 access predicate로 내려간다.

### Subquery Unnesting

서브쿼리를 조인으로 풀어 조인 순서 탐색이 가능해짐.

### OR Expansion (USE_CONCAT)

OR을 UNION ALL로 풀어 각 분기별 최적 플랜을 만들 수 있다.

```sql
EXPLAIN PLAN FOR
SELECT /*+ USE_CONCAT */ COUNT(*)
FROM   prod
WHERE  brand='B0' OR category='ELEC';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

### Aggregate Pushdown / Group By Placement

집계를 더 아래로 내려 조인 입력량을 줄이는 변환

### Join Elimination

FK/PK와 NOT NULL 제약이 엄격할 때 불필요 조인을 제거

### Star Transformation

스타 스키마에서 차원 필터를 팩트로 강하게 전파

---

## 적응형 기능(Adaptive) 해부

### Dynamic Sampling

통계가 부족하거나 불확실할 때 런타임 샘플로 보정.

```sql
ALTER SESSION SET optimizer_dynamic_sampling = 4;

EXPLAIN PLAN FOR
SELECT COUNT(*)
FROM   oi i JOIN prod p ON p.prod_id=i.prod_id
WHERE  p.brand='B47';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 통계가 정확하면 동적 샘플은 필요 없다.
- **통계 관리가 1순위**.

### Adaptive Cursor Sharing(ACS)

바인드 값 구간이 다르면 child cursor를 분기해 서로 다른 플랜을 학습/적용.

```sql
ALTER SYSTEM FLUSH SHARED_POOL;
VARIABLE b_brand VARCHAR2(12);

EXEC :b_brand := 'B47';
SELECT COUNT(*) FROM prod WHERE brand=:b_brand;

EXEC :b_brand := 'B0';
SELECT COUNT(*) FROM prod WHERE brand=:b_brand;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PEEKED_BINDS +NOTE'));
```

- 첫 피킹 값에 고정되는 문제를 완화한다.
- 단, 학습/분기까지 시간이 필요할 수 있다.

### Statistics Feedback(카디널리티 피드백)

반복 실행 중 실제 행수를 관측해 다음 하드파싱의 카디널리티를 보정.

---

## 플랜이 흔들릴 때(운영 문제) — 원인/진단/해결 로드맵

### 가장 흔한 원인 TOP 10

1) 통계 노후/오염
2) 스큐/상관관계 미반영(히스토그램/확장통계 부재)
3) 바인드 피킹 + 플랜 재사용
4) 인덱스 CF 악화(테이블 재정렬/대량 DML)
5) 파티션 누락/글로벌 통계 오판
6) 쿼리 변환이 막힘(OR/함수/외부조인)
7) SQL 텍스트 미세 변화로 커서 분리(형변환/공백/힌트 등)
8) 옵티마이저 관련 파라미터 변경
9) 업그레이드/패치로 비용 모델 변화
10) 시스템 통계/스토리지 성능 변화

### 진단의 순서(실전)

1) `DISPLAY_CURSOR +ALLSTATS LAST`로 **실제 많이 읽은 Row Source** 확인
2) `E-Rows vs A-Rows`가 가장 크게 틀린 구간을 찾음
3) 그 구간의 **조건/통계/히스토그램/확장통계/변환**을 점검
4) 수정 후 재실측
5) 필요시 플랜 안정화(베이스라인/프로파일)

---

## 플랜 안정화 도구(필수 개념)

### SQL Plan Baseline

- “좋았던 플랜”을 채택(accept)해 플랜 회귀 방지
- 업그레이드/통계 변동 환경에서 특히 유용

### SQL Profile / SQL Patch

- 카디널리티 추정/힌트 주입을 통해 플랜 보정
- 급한 불 끄기/특정 SQL 보호용

> 도구는 최후의 수단이고, 1차는 항상 **통계/SQL 구조/인덱스**다.

---

## 실전 종합 시나리오 3개

### 시나리오 A — 인기값에서 인덱스 플랜이 붙어 폭망

- 조건: `brand='B0'` 같은 상위 빈도
- 오판: density로 작게 추정 → range scan 선택 → 랜덤 I/O 폭증
- 해결: 히스토그램 정밀 + 필요시 FFS 유도

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt => 'FOR COLUMNS SIZE 254 BRAND');
END;
/
```

### 시나리오 B — 결합 조건 상관관계로 조인순서 뒤집힘

- 조건: `region='KOR' AND tier='VIP'`
- 해결: 확장통계(컬럼 그룹)

```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION,TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
```

### 시나리오 C — Top-N 화면이 느림(정렬 과다)

- 해결1: FIRST_ROWS_n 모드/힌트
- 해결2: Stopkey 가능 구조(정렬키+PK)로 인덱스 설계
- 해결3: “정렬 전에 얇게 만들기(Top-N 최소화)”

```sql
-- 얇게 만들고 Stopkey로 Top-N만 정렬
EXPLAIN PLAN FOR
SELECT order_id
FROM (
  SELECT /*+ INDEX_DESC(o IX_ORD_CUST) */ o.order_id, o.order_dt
  FROM   ord o
  WHERE  o.cust_id=:k
  ORDER  BY o.order_dt DESC
)
FETCH FIRST 10 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

## 운영 체크리스트(최종)

- [ ] 통계 정책: AUTO_SAMPLE_SIZE, SKEWONLY/AUTO 히스토그램
- [ ] 스큐 컬럼 선별: REPORT_COL_USAGE 기반
- [ ] 상관관계: 확장통계(컬럼 그룹)
- [ ] 파티션 팩트: 증분 통계 + 변경 파티션만 수집
- [ ] 바인드 스큐: ACS 학습/분기 확인
- [ ] 중요한 SQL: Baseline/Profile로 회귀 방지
- [ ] 모든 변경: 실측 플랜(E/A Rows, Buffers, I/O, Mem)으로 검증

---

## 결론

옵티마이저 튜닝은 결국 다음 한 문장으로 요약된다.

> **정확한 통계로 선택도/카디널리티를 현실화하고, 그 현실화된 비용 모델이 자연스럽게 올바른 플랜을 고르게 만드는 것.**

- CBO는 통계가 곧 “눈”이다.
- 모드는 “목표의 방향”일 뿐, 핵심은 **통계 + SQL 구조 + 물리 설계**다.
- 변환(푸시/이행/언네스트/오어 익스팬드)이 열려 있어야
  좋은 플랜을 찾을 공간이 생긴다.
- 최종 확인은 언제나 **실측 실행계획**이다.

이 가이드의 모든 예제는 `ALLSTATS LAST` 실측으로 **팩트 기반** 검증 루프를 돌릴 수 있게 설계했다.
여기까지 체득하면, Oracle 옵티마이저 튜닝의 80%는 이미 끝난 것이다.
