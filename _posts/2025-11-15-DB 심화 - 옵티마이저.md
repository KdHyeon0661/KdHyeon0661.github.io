---
layout: post
title: DB 심화 - 옵티마이저
date: 2025-11-15 16:25:23 +0900
category: DB 심화
---
# 완전 가이드

> 모든 SQL은 Oracle 기준이며, 실행 후에는 아래로 실제 실행계획/통계를 확인하세요.

```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST +PREDICATE +PEEKED_BINDS +IOSTATS +MEMSTATS'));
```

---

## 준비: 실습 스키마/데이터/통계

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD';
ALTER SESSION SET statistics_level = ALL;   -- ALLSTATS LAST

-- 테이블: 고객/상품/주문/주문상세 (선택도/스큐/조인 시연용)
DROP TABLE CUST PURGE;
DROP TABLE PROD PURGE;
DROP TABLE ORD  PURGE;
DROP TABLE OI   PURGE;

CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(8) NOT NULL,     -- 'APAC','EMEA','AMER','KOR','JPN' 등
  TIER    VARCHAR2(8) NOT NULL      -- 'VIP','GOLD','SILVER','GEN'
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,   -- 'ELEC','FOOD','TOY','HOME','FASH'
  BRAND    VARCHAR2(12) NOT NULL
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  ORDER_DT DATE  NOT NULL,
  STATUS   VARCHAR2(8) NOT NULL
);

CREATE TABLE OI(
  ORDER_ID NUMBER NOT NULL,
  LINE_NO  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(12,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY (ORDER_ID, LINE_NO)
);

-- 인덱스
CREATE INDEX IX_ORD_CUST  ON ORD(CUST_ID, ORDER_DT);
CREATE INDEX IX_OI_PROD   ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER  ON OI(ORDER_ID);
CREATE INDEX IX_PROD_CAT  ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_CUST_REG  ON CUST(REGION, CUST_ID);

-- 샘플 데이터(스큐 포함: REGION='KOR'이 유난히 많도록, BRAND='B0' 집중)
BEGIN
  FOR c IN 1..50000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,6)
        WHEN 0 THEN 'KOR'  WHEN 1 THEN 'KOR'  WHEN 2 THEN 'APAC'
        WHEN 3 THEN 'EMEA' WHEN 4 THEN 'AMER' ELSE 'JPN' END,
      CASE MOD(c,4) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER' ELSE 'GEN' END
    );
  END LOOP;

  FOR p IN 1..10000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FOOD' WHEN 2 THEN 'TOY' WHEN 3 THEN 'HOME' ELSE 'FASH' END,
      CASE WHEN p <= 3000 THEN 'B0' ELSE 'B'||TO_CHAR(MOD(p,50)) END
    );
  END LOOP;

  FOR o IN 1..120000 LOOP
    INSERT INTO ORD VALUES(
      o, MOD(o,50000)+1,
      DATE '2024-01-01' + MOD(o,180),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR i IN 1..300000 LOOP
    INSERT INTO OI VALUES(
      MOD(i,120000)+1,
      1 + MOD(i,3),
      MOD(i,10000)+1,
      1 + MOD(i,5),
      ROUND(DBMS_RANDOM.VALUE(10,700),2)
    );
  END LOOP;

  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# 옵티마이저란?

**정의**: SQL을 **가장 적은 비용**(CPU, I/O, 메모리, 네트워크, 지연)으로 실행하도록 **실행계획(Execution Plan)**을 산출하는 엔진.
**목표**: **최소의 블록 I/O**와 **적정 CPU**, **낮은 응답시간/높은 처리량**.

## 작동 흐름(요약)

1. **파싱/구문/의미 분석**: 문법·객체·권한 확인.
2. **쿼리 변환(Query Transformation)**: 서브쿼리 풀기, 조인 조건 푸시다운, 뷰 머지, 집계 푸시다운, OR-Expansion 등 **동치 변환**.
3. **카디널리티 추정**: 통계(테이블/컬럼/히스토그램/확장통계/시스템 통계)로 각 Row Source의 예상 건수/선택도 추정.
4. **액세스 경로/조인 순서/조인 방법 탐색**: 인덱스/풀스캔/파티션/샘플링, NL/SMJ/HJ, 배치 I/O/프리페치 등.
5. **코스트 계산**: 후보 플랜마다 예상 비용(cost) → **최저 비용 플랜 선택**.
6. **적응(Adaptive)**: 실행 중 통계 피드백으로 조정(버전별).

> **핵심**: 옵티마이저의 품질 ≈ **정확한 통계** + **적합한 모드** + **바른 SQL 구조**.

---

# vs 비용 기반(CBO)

## 규칙 기반(RBO: Rule-Based Optimizer)

- **특징**: **사전 정의된 규칙/우선순위**로 플랜 선정(예: 인덱스 스캔 > 풀스캔).
- **장점**: 통계 없어도 동작, 예측 가능.
- **단점**: 데이터 분포/스큐/카디널리티를 반영 못함 → **현대 환경 부적합**.
- **현황**: Oracle에선 사실상 **폐기**(RULE 힌트는 역사적 유물).

> 교육 목적 외 **사용 금지**. 아래 데모처럼 `/*+ RULE */` 힌트는 남아있지만 실무에서 의도적으로 쓰지 않습니다.

## 비용 기반(CBO: Cost-Based Optimizer)

- **특징**: **통계 기반**으로 후보 플랜 비용 산정 → **최저 비용** 선택.
- **장점**: 데이터 크기/선택도/스큐/시스템 통계/병렬/파티션 등을 반영.
- **전제**: **정확하고 최신의 통계**가 있어야 한다.

---

# 옵티마이저 코스트 모델(핵심 요소)

## 선택도/카디널리티

- **선택도(Selectivity)**: 조건이 **행을 얼마나 거르는지** 비율.
- **카디널리티(Cardinality)**: **예상 행 수** = 입력 행 수 × 선택도.
- 독립 가정 시, 다중 조건은 곱으로 근사:

$$
\text{Sel}(A \land B) \approx \text{Sel}(A) \times \text{Sel}(B)
$$

- 스큐/상관관계가 크면 **히스토그램/확장통계**가 필요.

## 액세스 경로 비용

- **Index Unique/Range Scan**, **Index Full/Fast Full**, **Table Full Scan**, **Skip Scan**, **Partition Pruning**, **Direct Path Read** 등.
- I/O 비용(싱글/멀티블록), CPU 비용, 캐시 히트율, 병렬도 등을 종합.

## 조인 비용

- **조인 순서** + **조인 방법**(NL / Sort-Merge / Hash) + **조인 키 분포/중복**.
- **NL**: 소량 반복 랜덤 I/O에 유리(인덱스/배치 I/O/프리페치로 보완).
- **HJ**: 대량 배치/비등치/집계 후 조인에 유리(메모리/Temp 영향).
- **SMJ**: 양쪽 정렬 후 병합(이미 정렬돼 있거나 인덱스로 대체 가능하면 효율적).

---

# 옵티마이저에 공급하는 “정보(통계)”

## 객체 통계

- 테이블/인덱스 **행 수**, **블록 수**, **클러스터링 팩터**, **NULL 비율**, **NDV(서로 다른 값 수)** 등.

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'ORD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

## 히스토그램

- **스큐 값**(예: BRAND='B0'이 30%)을 반영 → **브랜드=B0** vs **브랜드=B47** 플랜이 달라짐.
- **주요 유형**: Frequency, Top-Frequency, Height-Balanced.

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname   => USER,
    tabname   => 'PROD',
    method_opt=> 'FOR COLUMNS size 254 BRAND'
  );
END;
/
```

## 확장 통계(컬럼 그룹/표현식)

- 상관관계가 강한 컬럼 묶음에 대해 그룹 통계.

```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER, 'ORD', '(CUST_ID, ORDER_DT)');  -- 그룹 통계
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'ORD');
END;
/
```

## 시스템 통계

- CPU/IO 성능, 멀티블록 읽기, 병렬 환경…
- 서버 교체/스토리지 변경 시 **재수집 권장**.

---

# 옵티마이저 모드(핵심)

> 모드는 “**목표**”를 달리 잡도록 안내합니다.

## ALL_ROWS

- **처리량 최적화**(Throughput): 전체 결과를 **가장 빠르게** 산출.
- **DW/배치**에 적합. 풀스캔/해시 조인 선택이 잦음.

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;
```

## FIRST_ROWS / FIRST_ROWS_n (n=1/10/100/1000)

- **초기 몇 행 응답시간 최적화**(Latency): **처음 결과를 빨리**.
- 선택도가 높은 인덱스를 선호, NL 조인 빈도 ↑.

```sql
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;  -- 첫 10행 응답 최적화
```

> 실제로는 `optimizer_mode`보다 **실제 비용 모델/통계**와 **옵티마이저 힌트**가 영향력이 큼.
> 모드는 **선호 경향**을 준다고 이해하세요.

## / RULE (역사적)

- `CHOOSE`: 통계 유무에 따라 CBO/RBO 선택(과거).
- `RULE`: RBO 사용 힌트(폐기 대상).
- 현대 Oracle에선 **CBO + 모드(ALL_ROWS/FIRST_ROWS_n)**로 생각하면 충분합니다.

---

# 예제: 모드/통계/스큐가 플랜에 미치는 영향

## 같은 SQL, 다른 모드

**문제**: “KOR 지역 VIP 고객의 ELEC 카테고리 매출 상위 10개 주문”

```sql
-- 공통 SQL
VAR n NUMBER; EXEC :n := 10;
SELECT /* demo */ o.order_id, SUM(i.amount) amt
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
JOIN   CUST c ON c.cust_id = o.cust_id
JOIN   PROD p ON p.prod_id = i.prod_id
WHERE  c.region = 'KOR'
AND    c.tier   = 'VIP'
AND    p.category = 'ELEC'
GROUP  BY o.order_id
ORDER  BY amt DESC
FETCH FIRST :n ROWS ONLY;
```

### ALL_ROWS

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;
-- 실행 후 플랜 확인
```
- 경향: `CUST(REGION,TIER)` 조건을 나중에 걸더라도 **해시 조인** + **풀/대량 스캔**을 더 높게 평가 → 전체 처리량 유리.

### FIRST_ROWS_10

```sql
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;
-- 실행 후 플랜 확인
```
- 경향: `CUST(REGION,TIER)` 먼저 좁히고 `ORD`/`OI`를 NL로 타고 들어가며 **초기 10행 빨리** 찾도록 시도.

> 실제 결과는 **통계/히스토그램/클러스터링 팩터**에 따라 달라질 수 있습니다.
> 반드시 `DBMS_XPLAN ... ALLSTATS LAST`로 **실측** 확인!

## 스큐에 따른 플랜 변화(히스토그램 효과)

**문제**: `BRAND = 'B0'`는 대량(상위 빈도), `BRAND = 'B47'`은 소량.

```sql
-- 히스토그램 수집(이미 위에서 실행했지만, 다시 명시)
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER, 'PROD',
    method_opt=>'FOR COLUMNS SIZE 254 BRAND');
END;
/

-- 대량값(브랜드 B0) vs 희소값(B47) 비교
EXPLAIN PLAN FOR
SELECT /* brand B0 */ COUNT(*)
FROM   PROD
WHERE  BRAND = 'B0';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT /* brand B47 */ COUNT(*)
FROM   PROD
WHERE  BRAND = 'B47';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 기대: **B0**는 **풀스캔/인덱스 FFS**가 더 저렴할 수 있음.
- **B47**은 **Index Range**가 유리.
- 히스토그램이 없으면 두 조건을 **동일한 선택도**로 오판 → 잘못된 플랜 선택.

## FIRST_ROWS_n과 인덱스 활용 (Top-N, Stopkey)

```sql
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;

EXPLAIN PLAN FOR
SELECT /* top-10 recent orders per CUST */
       o.order_id, o.order_dt
FROM   ORD o
WHERE  o.cust_id = 12345
ORDER  BY o.order_dt DESC
FETCH FIRST 10 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 경향: `ORD(cust_id, order_dt)` 인덱스를 **역순 스캔 + Stopkey**로 **랜덤 I/O 최소**(Top-N).
- ALL_ROWS에서는 동일 쿼리라도 전체 처리량 중심으로 풀스캔이 유리하다고 판단할 가능성이 조금 더 큼.

---

# 옵티마이저 “힌트”와 모드의 관계

- 모드는 경향을 정하지만, **힌트**는 **직접적인 제약/지시**.
- 실전: 모드로 기본 성향 설정 + **힌트로 핵심만 고정**(조인 순서/방법/액세스 경로).

```sql
-- 조인 순서/메소드/인덱스 지시 예시
SELECT /*+ ORDERED
           LEADING(c o i p)
           USE_NL(o) USE_NL(i) USE_NL(p)
           INDEX(c IX_CUST_REG) INDEX(p IX_PROD_CAT) */
       SUM(i.amount)
FROM   CUST c
JOIN   ORD  o ON o.cust_id  = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
JOIN   PROD p ON p.prod_id  = i.prod_id
WHERE  c.region='KOR' AND c.tier='VIP'
AND    p.category='ELEC';
```

---

# 쿼리 변환(Query Transformation)과 모드

- **뷰 머지(View Merging)**, **서브쿼리 Unnesting**, **조인 조건/필터 푸시다운**, **OR-Expansion** 등.
- 변환이 가능해야 **옵티마이저 탐색 공간**이 넓어짐 → **좋은 플랜** 가능성↑.
- 모드에 상관없이 **변환의 성공/실패**가 플랜에 큰 영향.

```sql
-- 뷰 머지 금지(성능 실험용)
SELECT /*+ NO_MERGE(v) */ *
FROM (
  SELECT p.prod_id FROM PROD p WHERE p.category='ELEC'
) v
JOIN OI i ON i.prod_id = v.prod_id;
```

> 변환이 과도해 오히려 불리하면 `NO_MERGE`, `MATERIALIZE` 등으로 **제어**.

---

# 개요

> 버전에 따라 용어/기능 차이는 있지만, 큰 줄기는 동일:
> **실행 중** 통계/피드백으로 **카디널리티 보정**, 조인방법/분배 전략 **적응**.

- **Adaptive Plans**: 실행 도중 선택도 불확실 시 **브랜치**를 열어둠.
- **Cardinality Feedback / Statistics Feedback**: 반복 실행하면서 추정치 교정.
- **Dynamic Sampling**: 통계가 불충분할 때 부분 샘플로 카디널리티 보정.

```sql
-- 동적 샘플 수준(데모용; 환경에 맞게)
ALTER SESSION SET optimizer_dynamic_sampling = 4;
```

> 지나친 의존은 **실행 변동성**↑. 가능하면 **객체 통계**를 정확히 관리하세요.

---

# 옵티마이저 모드 선택 가이드

| 업무 유형 | 권장 모드 | 설명 |
|---|---|---|
| **DW/리포트/배치** | `ALL_ROWS` | 전체 처리량 중심, 해시조인/풀스캔/병렬 유리 |
| **OLTP/화면 Top-N** | `FIRST_ROWS_n` | 초기 행 빨리, 인덱스/Stopkey/배치 NL 유리 |
| **혼합(서비스)** | 기본 `ALL_ROWS` + 쿼리별 힌트 | 모드보다 **SQL 단위 힌트**로 안정성 확보 |

---

# 실전 시나리오

## “같은 SQL, 다른 모드”로 플랜/응답 비교

```sql
-- 대상 SQL: 고객(KOR/VIP) + ELEC 매출 Top-10
VAR n NUMBER; EXEC :n := 10;

-- (1) ALL_ROWS
ALTER SESSION SET optimizer_mode = ALL_ROWS;
SELECT /* all_rows */ o.order_id, SUM(i.amount) amt
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
JOIN   CUST c ON c.cust_id = o.cust_id
JOIN   PROD p ON p.prod_id = i.prod_id
WHERE  c.region='KOR' AND c.tier='VIP' AND p.category='ELEC'
GROUP  BY o.order_id
ORDER  BY amt DESC
FETCH FIRST :n ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +IOSTATS +MEMSTATS'));

-- (2) FIRST_ROWS_10
ALTER SESSION SET optimizer_mode = FIRST_ROWS_10;
SELECT /* first_rows_10 */ o.order_id, SUM(i.amount) amt
FROM   ORD o
JOIN   OI  i ON i.order_id = o.order_id
JOIN   CUST c ON c.cust_id = o.cust_id
JOIN   PROD p ON p.prod_id = i.prod_id
WHERE  c.region='KOR' AND c.tier='VIP' AND p.category='ELEC'
GROUP  BY o.order_id
ORDER  BY amt DESC
FETCH FIRST :n ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +IOSTATS +MEMSTATS'));
```

**체크 포인트**
- `Buffers`(읽은 블록 수), `Read/Write` I/O, `Elapsed`, 조인방법/순서.
- FIRST_ROWS_10에서 `TABLE ACCESS BY INDEX ROWID BATCHED`, `INDEX RANGE SCAN` 비율↑ 기대.

## 스큐로 인한 플랜 변화 확인

```sql
-- 빈도 높은 BRAND = 'B0' vs 낮은 BRAND = 'B47'
ALTER SESSION SET optimizer_mode = ALL_ROWS;

SELECT /* brand=B0 */ COUNT(*)
FROM   PROD
WHERE  BRAND = 'B0';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE'));

SELECT /* brand=B47 */ COUNT(*)
FROM   PROD
WHERE  BRAND = 'B47';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE'));
```

**포인트**
- 히스토그램이 있을 때 → 조건값에 따라 **전혀 다른 액세스 경로** 가능.

## 모드 + 힌트 병행

```sql
ALTER SESSION SET optimizer_mode = ALL_ROWS;

SELECT /*+ ORDERED
           LEADING(c o i p)
           USE_NL(o) USE_NL(i) USE_NL(p)
           INDEX(c IX_CUST_REG) INDEX(p IX_PROD_CAT) */
       o.order_id, SUM(i.amount) amt
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
JOIN   PROD p ON p.prod_id  = i.prod_id
WHERE  c.region='KOR' AND c.tier='VIP' AND p.category='ELEC'
GROUP  BY o.order_id
ORDER  BY amt DESC
FETCH FIRST 10 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +IOSTATS +PREDICATE'));
```

- 모드는 ALL_ROWS이지만, 힌트로 **NL+인덱스**를 강제 → **초기 응답** 개선.

---

# 운영 팁(체크리스트)

- [ ] **정확한 통계**: 테이블/인덱스/히스토그램/확장 통계 주기 수집. 스큐 컬럼 지정.
- [ ] **시스템 통계**: 스토리지/CPU 변경 시 재수집.
- [ ] **옵티마이저 모드**: 시스템 기본은 `ALL_ROWS`, 화면/Top-N은 쿼리별 **FIRST_ROWS_n** 힌트/모드.
- [ ] **변환 제어**: `NO_MERGE`, `MATERIALIZE`, `PUSH_PRED`, `UNNEST` 등으로 변환을 **이해하고 필요시 제어**.
- [ ] **플랜 안정화**: SQL Plan Baseline/SQL Profile/SQL Patch(환경에 맞게)로 **중요 SQL 고정**.
- [ ] **바인드 스큐**: 히스토그램 + (버전에 따른) **Adaptive Cursor Sharing** 고려.
- [ ] **실측 기반 개선**: `DBMS_XPLAN ... ALLSTATS LAST +IOSTATS +MEMSTATS`, AWR/ASH로 **원인→계획→코스트** 추적.

---

## 데모(교육용)

> **주의**: 실제 운영에선 사용하지 마세요.

```sql
EXPLAIN PLAN FOR
SELECT /*+ RULE */ COUNT(*)
FROM   PROD
WHERE  CATEGORY='ELEC';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 인덱스가 있어도 **사전 규칙대로** 선택될 수 있음.
- 데이터/통계와 무관 → **예상치 못한 비효율**의 대표 사례.

---

## 시연

```sql
ALTER SESSION SET optimizer_dynamic_sampling = 6;  -- 높은 수준(데모용)

EXPLAIN PLAN FOR
SELECT /* dynamic sampling demo */ COUNT(*)
FROM   OI i
JOIN   PROD p ON p.prod_id = i.prod_id
WHERE  p.brand = 'B47';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- 통계가 부정확/부족할 때 **일시 샘플**로 카디널리티를 보정.
- 반응형이지만 **일관성**을 해칠 수 있으므로 통계 관리가 우선.

---

## 부록 C. 모드별 기본값 확인/설정(참고)

```sql
-- 현재 모드 확인
SHOW PARAMETER optimizer_mode;

-- 세션 단위
ALTER SESSION SET optimizer_mode = ALL_ROWS;      -- 또는 FIRST_ROWS_10 등

-- 시스템 단위 (주의: 전역 영향)
ALTER SYSTEM SET optimizer_mode = ALL_ROWS SCOPE=BOTH;
```

---

### 마무리 요약

- **옵티마이저**는 SQL을 **가장 싸게** 실행할 **플랜을 고르는 두뇌**입니다.
- **RBO → CBO**: 현대는 **CBO**가 표준. **정확한 통계**와 **적절한 모드**가 성능을 좌우합니다.
- **모드**: `ALL_ROWS`(처리량) vs `FIRST_ROWS_n`(초기 응답). 업무 성격에 맞춰 선택하되, **핵심은 통계/SQL 품질**.
- **스큐/히스토그램/확장통계**로 **선택도 오판**을 교정하고, 필요 시 **힌트/변환 제어/플랜 안정화**로 일관성을 확보하세요.
- 언제나 **DBMS_XPLAN 실측**으로 검증하고, **AWR/ASH**로 병목을 관찰하며 **사실 기반**으로 조정하는 것이 정석입니다.
