---
layout: post
title: Elixir - 엘릭서 기초 (1)
date: 2025-11-14 17:25:23 +0900
category: Elixir
---
#  내장 자료형과 컬렉션 — 타입 지도부터 실전 패턴까지

## _4.1 내장 자료형 (Built-ins Overview)

우선 “큰 지도”부터 그려 보자. 엘릭서(정확히는 BEAM 용어 포함)에서 흔히 만나는 최상위 자료형을 **계층도**처럼 펼치면 대략 다음과 같다.

### 큰 분류: 값, 컬렉션, 시스템, 캘린더

- **스칼라/리터럴 계열 (Value-like)**
  - **number**: 정수(Integer, 임의정밀) · 실수(Float, 64-bit)
  - **atom**: 작은 상수/태그(`:ok`, `:error`, `:user_logged_in`)
  - **boolean**: `true`/`false` (사실 **atom**의 특수값)
  - **nil**: `nil` (역시 atom)
- **바이너리/문자열 계열**
  - **binary/bitstring**: `<<...>>`
  - **string**: UTF-8 바이너리에 대한 **약속** (논리적 “문자열”)
  - **charlist**: 코드포인트 리스트(`[104, 101, 108, 108, 111]` ↔ `'hello'`)
  - **iodata/chardata**: 바이너리/바이트 리스트(중첩 가능) · 문자열/코드포인트 리스트의 합집합
- **집합적/구조적 컬렉션**
  - **list**: 단방향 연결 리스트
  - **tuple**: 고정 길이, 위치 기반
  - **map**: 해시 기반 사전
  - **struct**: 맵 + 모듈 태그(사용자 정의 레코드/타입 껍데기)
  - **range**: `1..10` 같은 구간 표현
  - **MapSet**: 집합(표준 라이브러리)
- **함수/시스템 타입**
  - **function**: 익명 함수/클로저, 캡쳐 `&/1`
  - **PID**: 프로세스 식별자
  - **reference**: 전역 유일 참조(상관관계/토큰)
  - **port**: 외부 세계(파일/OS 프로세스/소켓 등)와의 I/O 핸들
- **캘린더/시간 구조체**
  - **Date**, **Time**
  - **NaiveDateTime**
  - **DateTime** (타임존 포함)

이를 BEAM 용어/역할별로 표로 정리하면:

| 범주      | 엘릭서 예시           | BEAM 관점 / 특징                           |
|-----------|-----------------------|---------------------------------------------|
| 값        | `1`, `3.14`, `:ok`    | 단일 term, 패턴매칭/비교/해시 용이         |
| 문자열    | `"abc"`               | UTF-8 바이너리를 문자열로 해석             |
| 바이너리  | `<<0,1,2>>`           | 비트/바이트 시퀀스, 프로토콜/IO 핵심       |
| 리스트    | `[1,2,3]`             | 단방향 연결 리스트, 패턴매칭/재귀 친화     |
| 튜플      | `{:ok, 42}`           | 고정 길이 컨테이너, 태그드 튜플 패턴       |
| 맵        | `%{a: 1}`             | 해시 기반 키-값, 동적 구조                 |
| 구조체    | `%User{}`             | 맵 + 모듈 태그, 도메인 모델링에 유용       |
| 시스템    | `self()`, `make_ref()`| 동시성/외부세계 연결을 위한 시스템 타입    |
| 시간      | `~D[2025-11-10]`      | 캘린더 타입, 시간/타임존 표현              |

> 핵심 요약
> - “문자열은 **바이너리**다.” (UTF-8 인코딩이라는 약속 위에 선다)
> - “불변”·“패턴매칭”을 **모든 타입**에서 일관되게 사용한다.
> - 큰 바이너리는 **오프힙 + 참조카운팅(RC)** 으로 공유되어 복사비용을 최소화한다.
> - 태그드 튜플, 맵, 구조체 등은 모두 **패턴매칭으로 계약을 표현**하는 도구다.

---

## _4.2 값 타입 (Value Types)

값 타입은 **순수 값**으로 다루는 기본형이다.
복사/전달에 부수효과가 없고, **매칭/비교/해시/직렬화**에 안정적으로 사용된다.

### Number — 정수/실수, 연산, 주의점

#### 정수: 임의정밀(Big Integer)

엘릭서 정수는 **임의정밀**이다. 일반적인 64비트 범위를 넘어도 자동으로 확장된다.

```elixir
iex> 9_223_372_036_854_775_807 + 1
9223372036854775808

iex> is_integer(10)
true
iex> is_integer(1_000_000_000_000_000_000_000_000_000_000)
true
```

- 내부 구현상 **스몰 정수(small integer)** 는 특정 범위 내에서는 워드에 직접 담기고,
  범위를 넘어가면 **BigInt** 구조로 바뀐다.
- 개발자가 직접 오버플로우를 걱정할 일은 거의 없다.

#### 실수: IEEE 754 double

```elixir
iex> 3.14 * 2
6.28

iex> 0.1 + 0.2 == 0.3
false

iex> 0.1 + 0.2
0.30000000000000004
```

- 실수는 대부분의 언어와 마찬가지로 **부동소수점 오차**가 있다.
- 금액/정밀 계산에는 가능하면 정수(예: 센트 단위)를 사용하고,
  표시할 때만 나누어 보여주는 패턴이 안전하다.

#### 기본 산술 연산

```elixir
iex> 7 / 2        # 항상 float
3.5
iex> div(7, 2)    # 정수 나눗셈
3
iex> rem(7, 2)    # 나머지
1

iex> 2 * 3 + 1
7
iex> 2 * (3 + 1)
8
```

- `/` 연산자는 **무조건 float** 을 반환한다.
- 정수 나눗셈은 반드시 `div/2`, 나머지는 `rem/2`를 사용.

#### 비교/정렬

```elixir
iex> 10 == 10.0
true

iex> 10 === 10.0
false
```

- `==` 은 타입을 느슨하게 비교(숫자 간 비교 시 10과 10.0을 동일로 본다).
- `===` 는 **타입까지 엄격**하게 비교한다.
- 정렬/순서 비교에서 숫자/atom/리스트/맵 등은 **내부 정해진 순서**가 있지만,
  일반 로직에서는 타입 섞인 비교를 피하는 편이 낫다.

#### 숫자 관련 가드 함수

패턴매칭/가드에서 자주 쓰는 숫자 관련 가드:

```elixir
def sign(x) when is_integer(x) and x > 0, do: :pos
def sign(x) when is_integer(x) and x < 0, do: :neg
def sign(0), do: :zero
```

- `is_integer/1`, `is_float/1`, `is_number/1` 등.

---

### Atom — 상수 심볼

**atom** 은 “프로그램 전체에서 유일한 이름을 갖는 상수”다.

```elixir
iex> :ok == :ok
true
iex> :ok == :error
false

iex> is_atom(true) and is_atom(nil)
true
```

- `true`, `false`, `nil` 도 atom이다.
- 보통 **상태/태그/명령/역할**을 나타낼 때 사용한다.

#### 리터럴과 인용

```elixir
iex> :ready
:ready

iex> :"user logged in"
:"user logged in"
```

- 공백/특수문자 없는 심플한 이름은 `:name` 형태로,
- 공백/특수문자가 필요하면 `:"..."` 형태로 쓴다.

#### 모듈 이름과 atom

모듈 이름도 내부적으로는 atom이다.

```elixir
iex> is_atom(String)
true

iex> String == :"Elixir.String"
true
```

- `MyApp.Module` 은 내부적으로 `:"Elixir.MyApp.Module"` atom이다.

#### 주의: atom 테이블 오염

- atom 은 **GC 되지 않는다**.
- 외부 입력을 atom 으로 계속 변환하면, **atom 테이블이 꽉 차서 VM이 종료**될 수 있다.

```elixir
# 절대 이렇게 쓰지 말 것 (예: 외부 JSON 키를 atom으로 전환)

String.to_atom(user_input)
```

- 대신 `String.to_existing_atom/1` 또는 문자열 키를 그대로 쓰는 것이 안전하다.

---

### Boolean / nil — 참/거짓 규칙

엘릭서에서 **거짓은 오직 두 개**다.

- `false`
- `nil`

그 외의 값은 모두 참으로 취급된다.

```elixir
iex> if nil, do: :t, else: :f
:f

iex> if false, do: :t, else: :f
:f

iex> if 0, do: :t, else: :f
:t

iex> if [], do: :t, else: :f
:t
```

이는 C/Java 등의 “0=거짓” 규칙과 다르므로 정확히 기억해야 한다.

---

### Binary / Bitstring — 비트/바이트 시퀀스

엘릭서에서 **바이너리**는 `<<...>>` 구문으로 표현되는 **바이트/비트의 시퀀스**다.

```elixir
iex> <<0, 1, 2>>
<<0, 1, 2>>

iex> <<0, 1, 2>> <> <<3, 4>>
<<0, 1, 2, 3, 4>>
```

#### 비트 단위 패턴매칭

```elixir
iex> <<x::3, y::5>> = <<0b101_10101>>
<<181>>
iex> {x, y}
{5, 21}
```

- `::3` 은 3비트, `::5` 는 5비트.
- 네트워크 프로토콜, 압축 포맷, 이미지 헤더 등에서 강력하게 활용한다.

#### 유닛(unit)과 사이즈(size)

```elixir
<<field::unsigned-integer-size(16), rest::binary>> = <<0, 10, "payload">>
```

- `size(n)` 은 **비트 단위 길이**.
- `unit(n)` 을 함께 쓰면 **단위 길이 × count** 조합을 표현.

#### 큰 바이너리와 오프힙

- 64바이트를 넘는 바이너리는 **오프힙**에 저장되고,
  프로세스는 포인터만 보유한다.
- 복사 대신 참조 카운트 증가로 공유하므로,
  “불변인데도 큰 바이너리를 여러 프로세스가 효율적으로 공유”할 수 있다.

---

### String / Charlist / Chardata — 텍스트

#### 문자열: UTF-8 바이너리

엘릭서 문자열은 “**UTF-8로 인코딩된 바이너리**”라는 약속이다.

```elixir
iex> "한글" <> " 테스트"
"한글 테스트"

iex> byte_size("한")      # 바이트 길이
3
iex> String.length("한")  # 코드포인트 개수
1
```

- `byte_size/1` vs `String.length/1` 차이를 기억하자.
- 유니코드 정규화/대소문자/분해자 처리 등은 `String` 모듈을 사용.

#### charlist: 정수 리스트

```elixir
iex> 'hello'
'hello'

iex> is_list('hello')
true

iex> to_string('hello')
"hello"
```

- `'hello'` 는 `[104, 101, 108, 108, 111]` 리스트다.
- 오래된 Erlang API 와 상호운용할 때 종종 나온다.

#### chardata / iodata 개념

- **chardata**: “문자열과 코드포인트 리스트를 섞어서 표현한 텍스트 데이터”.
- **iodata**: “바이너리와 바이트 리스트(중첩 포함)를 섞어 놓은 출력 데이터”.

```elixir
defmodule S do
  def join_bracket(list) do
    list
    |> Enum.map(&["[", &1, "]"])      # iodata
    |> :erlang.iolist_to_binary()
  end
end
```

- 많은 IO API(예: Plug 응답, 파일 쓰기)는 iodata/chardata를 그대로 받아준다.

---

### Range — 수열의 경계 표현

```elixir
iex> 1..5 |> Enum.to_list()
[1, 2, 3, 4, 5]

iex> for i <- 2..10//2, do: i
[2, 4, 6, 8, 10]
```

- `a..b` 는 **양끝이 포함된 구간**을 표현하는 구조체다.
- `first..last//step` 형태로 **보폭(step)** 지정이 가능하다.
- 실제로는 모든 요소를 저장하지 않고, **경계만 저장**하므로 메모리 효율적이다.

---

## _4.3 시스템 타입 (System-level Types)

시스템 타입은 BEAM 런타임의 **동시성·외부세계 연결·함수 표현**을 위해 존재한다.
값처럼 전달되지만, 내부적으로는 **VM 자원**과 결부된다.

### — 경량 프로세스 핸들

PID 는 **경량 프로세스**의 식별자이다.

```elixir
pid =
  spawn(fn ->
    receive do
      {:ping, from} ->
        send(from, :pong)
    end
  end)

send(pid, {:ping, self()})

receive do
  :pong -> :ok
after
  500 -> :timeout
end
```

- PID 자체도 **값**이다. 메시지, 맵, 리스트에 마음대로 넣을 수 있다.
- OTP에서는 보통 `GenServer.start_link/3` 등이 반환하는 PID를 사용한다.

#### 링크/모니터

PID 는 링크/모니터로 **장애 전파/감시**에 사용된다.

```elixir
pid = spawn_link(fn -> raise "boom" end)
# 현재 프로세스까지 예외가 전파될 수 있다.

```

- OTP 슈퍼바이저 트리는 PID/링크를 기반으로 동작한다.

---

### Reference — 전역 유일 토큰

reference 는 VM 전체에서 유일한 토큰이다.

```elixir
iex> ref = make_ref()
#Reference<0.2049309415.3746691073.169030>

iex> send(self(), {:req, ref, :data})

iex> receive do
...>   {:req, ^ref, payload} -> payload
...> end
:data
```

- 주로 **요청 상관관계**, **reply 라우팅** 등에 사용된다.
- 패턴매칭에서 **핀(`^ref`)**과 함께 쓰면 **정확한 상관관계**를 강제할 수 있다.

---

### Port — 외부 세계와의 I/O

Port 는 **외부 프로세스/파일/소켓**과 연결된 I/O 핸들이다.

```elixir
port = Port.open({:spawn, "cat"}, [:binary])

send(port, {self(), {:command, "hello\n"}})

receive do
  {^port, {:data, data}} -> data
after
  1000 -> :timeout
end
```

- 실제 애플리케이션에서는 `:gen_tcp`, `:ssl`, HTTP 클라이언트 등 상위 추상화를 사용하는 경우가 많다.
- Port 자체도 term이므로, 메시지에 넣어 넘길 수 있다.

---

### — 일급 함수

엘릭서 함수는 일급 객체이고, 클로저를 형성할 수 있다.

```elixir
iex> f = fn a, b -> a + b end
iex> f.(1, 2)
3

iex> inc = &(&1 + 1)
iex> Enum.map([1,2,3], inc)
[2, 3, 4]
```

#### 캡쳐 문법

```elixir
iex> plus = &Kernel.+/2
iex> plus.(3, 4)
7

iex> len = &length/1
iex> len.([1,2,3])
3

iex> mapper = &Enum.map/2
iex> mapper.([1,2,3], &(&1 * 2))
[2, 4, 6]
```

함수는:

- 파이프라인에서 **변환 단계**를 추상화하는 데 쓰이고,
- `Task`, `Stream`, `Enum` 등 고차 함수 기반 API에서 핵심 역할을 한다.

---

### Date/Time 계열 — 불변 시간 구조체

시간 관련 구조체는 모두 **불변 구조체**이며, 캘린더 연산에 적합하게 설계되어 있다.

```elixir
iex> d = ~D[2025-11-10]
~D[2025-11-10]

iex> t = ~T[12:34:56]
~T[12:34:56]

iex> nd = NaiveDateTime.new!(d, t)
~N[2025-11-10 12:34:56]

iex> {:ok, dt} = DateTime.from_naive(nd, "Etc/UTC")
{:ok, #DateTime<2025-11-10 12:34:56Z>}
```

- **Date**: 날짜만
- **Time**: 시간만
- **NaiveDateTime**: 타임존 없는 날짜+시간 (DB, 내부 연산에 적합)
- **DateTime**: 타임존 포함

일반적인 패턴:

- DB에는 **NaiveDateTime** 으로 저장,
- 입출력 경계(HTTP API 등)에서 **DateTime/타임존**으로 변환한다.

---

## _4.4 컬렉션 타입 (Collections)

컬렉션은 **값을 여러 개 담는 자료구조**다.
엘릭서 컬렉션의 공통 특징:

- **불변**이다.
- 내부적으로는 **구조적 공유**를 사용해, 갱신 비용을 줄인다.
- 패턴매칭/파이프라인/재귀와 궁합이 좋다.

---

### List — 단방향 연결 리스트

리스트는 가장 기초적인 컬렉션이다.

```elixir
iex> [1, 2, 3]
[1, 2, 3]

iex> [h | t] = [10, 20, 30]
[10, 20, 30]
iex> {h, t}
{10, [20, 30]}
```

#### 내부 구조 (그림)

리스트 `[1,2,3]` 은 다음과 같은 cons 셀로 표현된다.

```text
[1] -> [2] -> [3] -> []
```

- 각 노드는 “현재 값 + 다음 노드 포인터”를 가진다.
- 앞에서부터 한 칸씩만 갈 수 있는 **단방향** 구조다.

#### 앞에 붙이기 vs 뒤에 붙이기

- ` [x | list]` : 새 헤드 노드 1개만 만들면 되므로 $$O(1)$$.
- `list ++ [x]` : 리스트 전체를 훑고 새 리스트를 만들어야 하므로 $$O(n)$$.

```elixir
def slow_append(list, x), do: list ++ [x]
def fast_prepend(list, x), do: [x | list]
```

대량 삽입 패턴:

```elixir
def build_list(n) do
  1..n
  |> Enum.reduce([], fn i, acc -> [i | acc] end)
  |> :lists.reverse()
end
```

#### 키워드 리스트 (Keyword list)

키워드 리스트는 `[{atom, value}]` 리스트다.

```elixir
iex> opts = [timeout: 1000, retries: 3]
[timeout: 1000, retries: 3]

iex> Keyword.get(opts, :timeout)
1000
```

특징:

- **중복 키 허용**
  예: `[path: "/a", path: "/b"]`
- 순서가 의미 있을 수 있다.
- 함수 옵션 인자, DSL 형태 설정에 많이 사용.

---

### Tuple — 고정 길이, 위치 기반 컨테이너

튜플은 **고정 길이** 컨테이너이며, 위치 기반 접근을 한다.

```elixir
iex> t = {:ok, 42}
{:ok, 42}

iex> elem(t, 1)
42

iex> put_elem(t, 1, 100)
{:ok, 100}
```

- `put_elem/3` 은 **새 튜플**을 반환한다.
- “태그드 튜플” 패턴: **첫 요소로 타입/상태를 태그**하는 관용구.

```elixir
{:ok, value}
{:error, reason}
{:user, id, name}
```

패턴매칭:

```elixir
case {:error, :not_found} do
  {:ok, v}    -> {:success, v}
  {:error, r} -> {:fail, r}
end
```

---

### Map — 해시 맵, 동적 키-값

맵은 키-값 사전이다.

```elixir
iex> m = %{name: "Kim", points: 10}
%{name: "Kim", points: 10}

iex> Map.get(m, :name)
"Kim"

iex> %{name: n} = m   # 키 존재 강제
%{name: "Kim", points: 10}
iex> n
"Kim"
```

특징:

- 키는 어떤 term 이든 가능하지만, 보통 atom/string/숫자를 쓴다.
- 해시 트라이(HAMT)에 기반한 구조로, 평균적으로 **준상수** 조회/갱신 성능.

#### 갱신과 경로 기반 접근

```elixir
iex> m1 = %{user: %{name: "Kim", points: 10}}

iex> m2 = put_in(m1, [:user, :points], 11)
%{user: %{name: "Kim", points: 11}}

iex> m3 = update_in(m2, [:user, :points], &(&1 + 5))
%{user: %{name: "Kim", points: 16}}
```

- `put_in/3`, `update_in/3`, `get_in/2` 는 **중첩 구조**를 다루는 표준기법이다.
- 내부적으로는 **바뀐 경로에 해당하는 노드만 새로 만들고, 나머지는 공유**한다.

#### 맵 패턴과 핀

```elixir
iex> m = %{name: "Kim", points: 10}

iex> %{name: name} = m
%{name: "Kim", points: 10}
iex> name
"Kim"

iex> key = :points
iex> %{^key => pts} = m
%{name: "Kim", points: 10}
iex> pts
10
```

- 키에 변수를 쓰고 싶다면 **`%{^key => v}`** 처럼 **핀 연산자**로 현재 값 고정이 필요하다.

---

### Struct — 맵 + 모듈 태그, 도메인 모델링

구조체는 **맵에 모듈 태그가 붙어 있는 형태**다.

```elixir
defmodule User do
  defstruct [:id, :name, points: 0]
end

iex> u = %User{id: 1, name: "Kim"}
%User{id: 1, name: "Kim", points: 0}

iex> %User{name: n} = u
%User{id: 1, name: "Kim", points: 0}
iex> n
"Kim"
```

특징:

- 필드 집합이 고정적이다 (정의된 키만 사용).
- 패턴매칭에서 타입(모듈)을 강제할 수 있다.

```elixir
case term do
  %User{} -> :user
  %{}     -> :map
end
```

- 구조체는 맵이므로 `Map` 함수(`Map.get/2`, `Map.put/3`)도 그대로 적용 가능하다.

---

### MapSet — 집합 연산

`MapSet` 은 **집합(Set)** 을 표현하는 자료구조다.

```elixir
iex> s1 = MapSet.new([:a, :b])
#MapSet<[:a, :b]>

iex> s2 = MapSet.put(s1, :c)
#MapSet<[:a, :b, :c]>

iex> MapSet.member?(s2, :b)
true

iex> MapSet.intersection(s2, MapSet.new([:b, :x]))
#MapSet<[:b]>

```

- 멤버십 테스트/합집합/교집합/차집합을 자주 쓸 때 맵보다 직관적이다.

---

### iodata / chardata — 고성능 출력 버퍼

iodata 는 “**바이너리와 바이트 리스트(중첩 포함)를 섞어서 표현한 출력 데이터**”다.

```elixir
defmodule Response do
  def http_ok(body, headers \\ []) do
    [
      "HTTP/1.1 200 OK\r\n",
      Enum.map(headers, fn {k,v} -> [k, ": ", v, "\r\n"] end),
      "\r\n",
      body
    ]
    |> :erlang.iolist_to_binary()
  end
end
```

장점:

- 중간 단계에서 **큰 바이너리를 계속 새로 만들지 않고**,
  작은 조각들로 된 트리 구조를 유지하다가
- 마지막에 `iolist_to_binary/1` 로 **한 번만 선형화**한다.

이는:

- 웹 서버, 파일 쓰기, 로그 시스템 등 **I/O 성능이 중요**한 곳에서 필수적인 기법이다.

---

### Range / Stream — 지연/경량 컬렉션

Range 는 **경계를 가진 수열 표현**이고, Stream 은 **지연 평가 변환**이다.

```elixir
iex> 1..5
1..5

iex> Enum.to_list(1..5)
[1, 2, 3, 4, 5]
```

Stream 예:

```elixir
1..1_000_000
|> Stream.map(&(&1 * 2))
|> Stream.take(3)
|> Enum.to_list()
# => [2, 4, 6]

```

- 중간의 `Stream.map/2`, `Stream.take/2` 는 실제 리스트를 만들지 않고,
  “어떻게 변환할지”만 기억하는 파이프라인을 만든다.
- `Enum.to_list/1` 에서 실제로 필요한 만큼만 소비한다.

---

## _4.5 실전 시나리오 모음 — 타입+매칭+불변 융합

앞에서 본 타입들을 “실제 업무 코드” 느낌으로 엮어 보자.

### 로그 파서 — 바이너리 패턴 + 맵

```elixir
defmodule LogParser do
  def parse_line(<<"[", level::binary-size(5), "] ", ts::binary-size(19), " - ", msg::binary>>) do
    {:ok, %{level: String.trim(level), ts: ts, msg: msg}}
  end

  def parse_line(_), do: :bad
end

iex> LogParser.parse_line("[INFO ] 2025-11-10 00:01:02 - started")
{:ok, %{level: "INFO", ts: "2025-11-10 00:01:02", msg: "started"}}
```

- 문자열을 인덱스/슬라이스로 조작하는 대신, **바이너리 패턴**으로 의미 있는 조각을 추출한다.

---

### API 응답 정규화 — 태그드 튜플 + 맵 패턴

```elixir
defmodule API do
  def decode({200, %{"data" => d}}), do: {:ok, d}

  def decode({code, %{"error" => e}}) when code in 400..599 do
    {:error, {code, e}}
  end

  def decode(_), do: {:error, :unknown}
end
```

- 결과 타입을 `{:ok, data} | {:error, reason}` 으로 통일하면,
  이후 파이프라인이 일관되어진다.

---

### RPC 스타일 메시지 — reference + 핀

```elixir
defmodule Rpc do
  def call(server, request, timeout \\ 1000) do
    ref = make_ref()
    send(server, {:rpc, ref, self(), request})

    receive do
      {:rpc_reply, ^ref, response} ->
        {:ok, response}
    after
      timeout ->
        {:error, :timeout}
    end
  end
end
```

- reference 는 **요청마다 유일한 토큰** 역할을 한다.
- `^ref` 로 매칭을 고정해 정확한 상관관계를 보장한다.

---

### 태그 관리 — 리스트 vs MapSet

```elixir
defmodule Tags do
  def toggle(set, tag) do
    if MapSet.member?(set, tag) do
      MapSet.delete(set, tag)
    else
      MapSet.put(set, tag)
    end
  end

  def uniq_sorted(tags) do
    tags
    |> MapSet.new()
    |> MapSet.to_list()
    |> Enum.sort()
  end
end
```

- 태그들이 많고 **중복 제거/멤버십 검사**가 중요하면, 리스트보다 **MapSet** 이 직관적이다.

---

### 로그 라인 포맷 — iodata 응답

```elixir
defmodule LogFmt do
  def line(level, ts, msg, meta \\ []) do
    base = ["[", level, "] ", ts, " ", msg]

    extra =
      meta
      |> Enum.flat_map(fn {k, v} ->
        [" ", to_string(k), "=", inspect(v)]
      end)

    [base, extra, "\n"]
    |> :erlang.iolist_to_binary()
  end
end
```

- 문자열 결합 연산 `<>`를 반복하는 대신 **iodata**를 쌓아 두고,
  마지막에 한 번만 바이너리로 변환한다.

---

## _4.6 성능·모델 요약과 타입 선택 체크리스트

### 복잡도/모델 한눈에 보기

수식으로 정리하면:

- 리스트 앞에 붙이기:
  $$T_{\text{prepend}}(n) = O(1)$$
- 리스트 뒤에 붙이기 (반복할 때):
  $$T_{\text{append}}(n) \approx O(n^2)$$
- 맵 조회/갱신(평균):
  $$T_{\text{map}}(n) \approx O(\log n)$$ 또는 **준상수 시간**
  (해시 트라이 깊이에 비례)
- iodata → 바이너리 선형화:
  $$T_{\text{iolist\_to\_binary}}(n) = O(n)$$

핵심:

> “불변”이라고 해서 **무조건 느린 것**이 아니라,
> **불변에 맞는 자료구조/패턴**을 사용해야 한다.

---

### 타입 선택 체크리스트

어떤 타입을 써야 할지 고민될 때 다음 질문을 던져 보자.

1. **옵션/소형 설정**인가?
   → Keyword list: `[timeout: 1000, retries: 3]`

2. **대규모 키-값**을 저장하는가?
   → Map/Struct: `%{id: 1, ...}`, `%User{}`

3. 결과가 **성공 또는 실패** 패턴인가?
   → 태그드 튜플: `{:ok, v} | {:error, r}`

4. **멤버십, 집합 연산**이 핵심인가?
   → MapSet

5. **대량 문자열/바이너리 결합**인가?
   → iodata: `[..., body] |> :erlang.iolist_to_binary()`

6. **시간/타임존 처리**가 필요한가?
   → `DateTime`(경계), `NaiveDateTime`(내부)

7. **동시성에서 요청 상관관계**가 필요한가?
   → `reference` + 핀(`^ref`)

8. **외부 프로세스/파일/소켓**과 직접 통신하는가?
   → Port/소켓, 필요하면 상위 추상화(HTTP 클라이언트 등)

---

### 테스트 관점

타입 시스템과 불변성 덕분에 테스트는 다음처럼 설계할 수 있다.

- **패턴매칭**으로 필수 필드를 강제하고,
  실패 시 `MatchError`로 바로 드러나게 한다.
- **스냅샷 테스트**: 입력 → 출력 구조 전체를 비교.
- **속성 기반 테스트**: 컬렉션/수치 연산에 수학적 속성을 부여.

```elixir
defmodule TypesTest do
  use ExUnit.Case, async: true

  test "map pattern enforces required key" do
    assert_raise MatchError, fn ->
      %{name: _} = %{points: 10}
    end
  end

  test "iodata concatenation equals join" do
    chunks = ["a", "b", "c"]

    iodata = [chunks]
    bin = :erlang.iolist_to_binary(iodata)

    assert bin == Enum.join(chunks, "")
  end
end
```

---

## _4.7 정리

- 엘릭서의 내장 자료형은 **불변 데이터 + 패턴매칭 + 메시지 패싱**이라는 공통 철학 위에 서 있다.
- 문자열은 사실 **UTF-8 바이너리**, 컬렉션은 **구조적 공유**, 시스템 타입은 **동시성/외부세계의 문법**이다.
- 각 타입의 리터럴/특성/성능을 이해하면,
  “이 상황에서 어떤 타입을 써야 하는가?”라는 질문에 스스로 답할 수 있게 된다.

이 장에서 정리한 내용은 이후에 다룰:

- 패턴매칭 심화,
- OTP/GenServer/슈퍼바이저,
- 파일/네트워크 I/O,
- 고성능 서버 설계

등의 **기초 체력**이 된다.
실제 프로젝트에서 코드를 짤 때, **변수/자료형을 고르는 순간마다** 여기서 본 관점들을 떠올려 보는 습관을 들이자.
