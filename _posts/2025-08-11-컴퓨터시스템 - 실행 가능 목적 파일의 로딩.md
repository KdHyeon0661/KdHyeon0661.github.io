---
layout: post
title: 컴퓨터시스템 - 실행 가능 목적 파일의 로딩
date: 2025-08-11 17:20:23 +0900
category: 컴퓨터시스템
---
# 실행 가능 목적 파일의 로딩(Loading)

## 0. 큰 그림(빠른 조감도)

```
사용자 쉘           커널(ELF 로더)                    유저 공간(동적 로더·런타임)
-----------         ------------------------------     ------------------------------
fork() ─────────▶   새 task_struct/메모리 맵 생성
execve(path,...) ▶  ELF 헤더 검증·PHDR 순회
                    PT_LOAD 세그먼트 매핑(mmap)       [PT_INTERP 있으면]
                    BSS 0-필(zerofill)               └─ ld-linux.so.* 매핑
                    스택/auxv/argv/envp 구축             DT_NEEDED 탐색/매핑
                    AT_ENTRY로 진입점 전달                재배치/바인딩(PLT/GOT)
                    RIP ← e_entry(보통 _start)           ctors 실행 후 main() 호출
```

---

## 1. 로딩의 시작 — `execve()`가 하는 일

사용자/셸은 보통 `fork()`로 자식 프로세스를 만든 뒤 **자식에서** `execve(path, argv, envp)`를 호출한다. `execve()`는 기존 프로세스 *메모리 이미지를 파괴*하고, 지정된 실행 파일로 **완전히 교체**한다.

핵심 단계:

1. **ELF 파일 열기·검증**
   - 매직(`\x7FELF`), 클래스(ELF32/ELF64), 엔디안, 머신 아키, 타입(ET_EXEC/ET_DYN) 확인.
   - 실행 권한/해시·서명(정책에 따라)/해석기 권한 검사.

2. **이전 메모리 맵 정리**
   - 대부분의 VMA 해제, `FD_CLOEXEC` 플래그인 파일 디스크립터는 **exec 시 자동 닫힘**.

3. **새 이미지 구성**
   - **프로그램 헤더(PT_*)**를 순회하며 `PT_LOAD` 세그먼트를 **페이지 단위로 mmap**.
   - BSS(파일에 없는 0채움) 영역은 **익명 메모리**로 매핑 후 0으로 초기화.
   - `PT_GNU_STACK` 권한(예: NX)을 스택에 반영, `PT_GNU_RELRO`(후술) 준비.
   - `PT_TLS` 있으면 TLS 초기 템플릿 기록(동적 로더 단계에서 모델별 설치).

4. **스택 빌드**
   - `argc/argv/envp`와 **ELF Auxiliary Vector(auxv)**(AT_* 항목들)을 최상단부터 **하향식**으로 배치.
   - 가드 페이지, 정렬, 랜덤 패딩(ASLR용) 적용.

5. **동적 로딩 진입 준비**
   - `PT_INTERP`가 있으면 **동적 로더(예: `/lib64/ld-linux-x86-64.so.2`)**를 먼저 매핑하고, 진입점을 **동적 로더 엔트리**로 설정.
   - 없으면(정적 링크) `e_entry`로 바로 점프.

---

## 2. ELF 핵심 필드와 “어디를 어떻게” 매핑하나

### 2.1 ELF/PHDR 필수 필드
- `e_entry` : **최종 진입점**(정적이면 `_start`, 동적이면 ld.so 엔트리)
- `e_phoff`/`e_phnum` : **프로그램 헤더 테이블** 위치/개수
- 각 PHDR:
  - `PT_LOAD` : 파일의 일부 → 가상 주소로 로드(코드/데이터/BSS)
  - `PT_INTERP` : **동적 로더 경로**(존재 시 동적 링크)
  - `PT_GNU_STACK` : 스택 권한(실행 가능 여부)
  - `PT_GNU_RELRO` : **Relocation Read-Only** 구간(로딩 후 **읽기 전용**으로 봉인)
  - `PT_TLS` : 초기 TLS 템플릿
  - `PT_PHDR` : PHDR 자체 매핑 정보
  - `PT_GNU_EH_FRAME` : SJLJ/언와인딩 메타(최적화된 eh_frame_hdr)

### 2.2 페이지 정렬·오프셋 규칙(간단 수식)
파일 오프셋 `p_offset`과 가상주소 `p_vaddr`는 페이지 크기 `P`(보통 4096) 기준으로 같은 **페이지 오프셋**을 가져야 한다.

$$
(p\_offset \bmod P) = (p\_vaddr \bmod P)
$$

그래서 커널은 `p_offset`을 `P` 경계로 내리고, `p_vaddr`도 내린 뒤 **앞부분은 파일**, **나머지(파일보다 긴 뒷부분)는 0-필**(BSS)로 채운다.

---

## 3. `PT_LOAD` 매핑 — 코드/데이터/BSS와 CoW·디어맨드 페이징

- **코드(.text)/상수(.rodata)**: `PROT_READ|PROT_EXEC`(RX)로 **파일 매핑**. 공유 페이지라 **프로세스 간 재사용** 가능.
- **초기화 데이터(.data)**: `PROT_READ|PROT_WRITE`(RW)로 파일 매핑이지만 **쓰기 시 CoW**(copy-on-write).
- **BSS(.bss)**: 파일 크기를 넘는 영역. **익명 메모리**(zero-fill-on-demand)로 확장.
- **디맨드 페이징**: 접근 시 **페이지 폴트**로 해당 페이지를 읽어 들인다 → 첫 접근만 비용 큼.
- **힙**: 전통적으로 `brk/sbrk`로 확장하지만, 현대 런타임은 **mmap 기반 할당**을 광범위하게 사용.

---

## 4. 동적 링크(PT_INTERP) — ld.so가 하는 일

ELF에 `PT_INTERP`가 있으면 커널은 **인터프리터(동적 로더)**를 먼저 매핑하고, **제어를 ld.so로 전달**한다. ld.so 순서:

1. **자기 초기화**
   - 자기 자신(해석기)와 **메인 실행 파일**의 `.dynamic` 파싱.
   - `DT_NEEDED` 라이브러리 목록 수집, 검색 경로 구성(**RUNPATH/RPATH/LD_LIBRARY_PATH** 순·정책 고려).

2. **의존 그래프 로딩**
   - `DT_NEEDED` **위상 순서**로 `.so` 파일들을 mmap.
   - `DT_GNU_HASH`/`DT_HASH` 테이블 준비, 심볼 버전(`.gnu.version*`) 일치 검사.

3. **재배치(Relocation)**
   - **REL/RELA** 유형별로 GOT/데이터 포인터/주소 상수 패치.
   - IFUNC(`R_*_IRELATIVE`) 해석: 런타임에 **최적 구현** 선택(예: SSE/AVX 루틴).
   - **RELRO**: 재배치 끝난 후 `PT_GNU_RELRO` 영역을 **읽기 전용**으로 변경(**partial**: GOT 일부, **full**: BIND_NOW 시 GOT/relro 전부).

4. **바인딩(PLT/GOT)**
   - **Lazy**(기본): 처음 호출 시 PLT 스텁 → PLT0 → ld.so 바인더 진입 → **실제 주소**를 GOT에 기록 후 재시도.
     `LD_BIND_NOW=1`(또는 `-Wl,-z,now`)로 **즉시(Eager) 바인딩** 가능.
   - `--hash-style=gnu`가 있으면 Bloom 필터로 심볼 탐색 단축.

5. **초기화/구동**
   - 각 DSO의 **`.init_array`/`.ctors`** 호출(우선순위/의존 보장).
   - TLS 모델(IE/LE/LD) 설정 및 스레드 로컬 영역 설치.

6. **최종 점프**
   - 메인 바이너리의 엔트리(보통 `_start`)로 제어 이동 → **C 런타임** 초기화 후 `main()` 호출.

> **TIP(검증)**: `LD_DEBUG=libs,reloc,bindings`로 로딩/재배치/바인딩 로그를 상세 추적할 수 있다.

---

## 5. 유저 스택 초기화 — argv/envp/auxv/vDSO

커널은 새 스택 상단에 아래를 **정렬**을 맞춰 배치한다(아키/ABI 별 약간 상이).

```
|----------------------------|  높은 주소
| AT_NULL                    |  ┐
| ... Auxiliary Vector ...   |  │  auxv (AT_ENTRY, AT_PHDR, AT_PAGESZ, ...,
| AT_PHNUM, AT_PHDR, ...     |  │  AT_EXECFN, AT_RANDOM, AT_SYSINFO_EHDR 등)
|----------------------------|  ┘
| envp[N]=NULL               |
| envp[N-1] ... envp[0]      |
|----------------------------|
| argv[argc]=NULL            |
| argv[argc-1] ... argv[0]   |
|----------------------------|
| argc                       |
|----------------------------|  낮은 주소 (스택 아래로 성장)
```

주요 **auxv(AT_*)** 항목:
- `AT_ENTRY`: 엔트리 주소
- `AT_PHDR/AT_PHNUM`: PHDR 위치/개수
- `AT_PAGESZ`: 페이지 크기
- `AT_SECURE`: SUID/SGID 등 보안 맥락(환경 변수 무시 등)
- `AT_RANDOM`: **ASLR**용 랜덤 바이트(스택 카나리 초기화에도 사용)
- `AT_SYSINFO_EHDR`: **vDSO**(커널 제공 사용자 공간 헬퍼)의 ELF 헤더 주소

**vDSO**: `clock_gettime()` 등 빈번한 커널 서비스를 **시스템 콜 없이** 사용자 공간에서 수행하도록 커널이 매핑하는 *작은 ELF*.

### 5.1 auxv 읽기 실습(C)
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <elf.h>
#include <stdint.h>

int main(){
    int fd = open("/proc/self/auxv", O_RDONLY);
    if (fd < 0) { perror("open auxv"); return 1; }
    Elf64_auxv_t a;
    while (read(fd, &a, sizeof(a)) == sizeof(a)) {
        if (a.a_type == AT_NULL) break;
        printf("AT_%lu = 0x%lx\n", (unsigned long)a.a_type, (unsigned long)a.a_un.a_val);
    }
    close(fd);
    return 0;
}
```

---

## 6. C 런타임 진입 — `_start` → `main` 전까지

표준 C 실행 파일은 보통 **링커 스크립트**로 `_start`를 엔트리로 삼는다. `_start`는:

1. 스택에서 `argc/argv/envp`/`auxv` 포인터 구성
2. **TLS/로케일/표준 라이브러리** 초기화
3. 전역 생성자(`.init_array`) 호출
4. `main(argc, argv, envp)` 호출
5. 리턴값을 들고 `exit()` 호출 → `atexit` 레지스터된 파괴자 실행 → 커널로 복귀

### 6.1 전역 생성자 동작 확인 예제
```c
#include <stdio.h>

__attribute__((constructor))
static void before_main(void){ puts("init: constructor"); }

int main(int argc, char** argv){
    puts("main: hello");
    return 0;
}

__attribute__((destructor))
static void after_main(void){ puts("fini: destructor"); }
```

```
$ gcc ctor.c -o ctor
$ ./ctor
init: constructor
main: hello
fini: destructor
```

---

## 7. 로딩 중 보안·최적화 기능 — 2025 기준 핵심

### 7.1 ASLR + PIE
- **ASLR**: 공유 라이브러리/스택/힙/메인바이너리(PIE일 때) **베이스 주소 랜덤화**.
- **PIE(ET_DYN)**: 메인 실행 파일도 **위치 독립**으로 빌드 → ASLR 적용 폭↑.
  ```
  $ gcc -fpie -pie main.c -o app_pie
  ```

### 7.2 RELRO
- **Partial RELRO**(기본): GOT 외 다수의 초기화 영역을 재배치 후 **읽기전용**.
- **Full RELRO**(`-Wl,-z,relro,-z,now` 또는 `LD_BIND_NOW=1`): GOT까지 즉시 바인딩 후 **전부 봉인** → PLT/GOT 덮어쓰기 공격 저지.

### 7.3 NX/DEP, CET(IBT/SHSTK)
- **NX**: 스택/힙 실행 금지(`PT_GNU_STACK`로 통제).
- **x86 CET**:
  - **IBT**: 간접 분기 대상 유효성(ENDBR) 체크로 ROP/JOP 완화.
  - **SHSTK**: **Shadow Stack**으로 리턴 주소 위조 방지(커널·툴체인 설정 필요).
- ELF의 `GNU_PROPERTY` 노트에 기능 플래그가 박힘(로더가 인지).

### 7.4 `AT_SECURE`와 환경 변수
- SUID/SGID 등 **특권 실행** 시 로더는 `LD_PRELOAD` 등 일부 환경 변수를 **무시**.
- `execve()`는 `FD_CLOEXEC` 파일들을 닫아 **핸들 누수**를 차단.

### 7.5 Lazy vs Eager 바인딩(성능·보안 트레이드오프)
- **Lazy**: 스타트업 빠름, 첫 호출 때 바인딩 지연 발생.
- **Eager**(`LD_BIND_NOW=1`): 스타트업 느려질 수 있으나 런타임 hiccup 제거, **RELRO**와 결합 시 보안성↑.

---

## 8. 동적 로딩 관찰·재현 실습

### 8.1 로더 로그 보기
```bash
LD_DEBUG=libs,reloc,bindings ./app 2>&1 | less
```

### 8.2 런타임 의존성·보안 플래그 확인
```bash
ldd ./app
checksec --file=./app
readelf -lW ./app | egrep 'GNU_STACK|GNU_RELRO|INTERP'
```

### 8.3 vDSO 주소 확인
```bash
cat /proc/self/maps | grep -E 'vdso|vvar'
```

---

## 9. 로딩 실패/지연의 전형적 원인과 해결

증상 | 근본 원인 | 진단법 | 해결
---|---|---|---
`error while loading shared libraries` | `DT_NEEDED` 라이브러리 미발견 | `ldd`, `LD_DEBUG=libs` | `RUNPATH=$ORIGIN/lib`, `patchelf --set-rpath`
첫 호출 때 지연 스파이크 | Lazy 바인딩 | `LD_DEBUG=bindings` | `LD_BIND_NOW=1` 또는 `-Wl,-z,now`
GOT/RELRO 공격면 | Partial RELRO + Lazy | `readelf -lW`(RELRO), `checksec` | **Full RELRO** + Eager
SUID에서 LD_PRELOAD 무시 | `AT_SECURE=1` 정책 | `/proc/self/auxv` | 로더 정책 우회 불가(설계상)
IFUNC 충돌/느림 | 런타임 CPU 피처 오검출·다중 해석 | `readelf -s | grep IFUNC` | 빌드시 IFUNC 비활성/고정 구현 선택
PIE 미적용으로 ASLR 제한 | ET_EXEC | `file app` | `-fpie -pie`로 재빌드

---

## 10. 심화: 재배치·PLT/GOT·IFUNC 빠르게 해부

- **RELA vs REL**: x86-64는 보통 **RELA**(추가 상수가 항목에 포함). ARM 등은 REL도 흔함.
- **GOT**: 전역/함수 주소 테이블. 초기에는 PLT0로 가리키거나, 재배치 후 **실제 함수/데이터 주소**로 패치.
- **PLT**: 간접 호출 트램펄린. 첫 호출은 바인더를 거쳐 GOT 갱신.
- **IFUNC**: “해석 시 함수 선택”. `R_X86_64_IRELATIVE` 엔트리의 함수가 *진짜 함수 주소*를 돌려줌(예: AVX2/NEON 선택).

---

## 11. 실험용 최소 프로그램 모음

### 11.1 로딩 경로·바인딩 지연 관찰
```c
// lazy.c
#include <stdio.h>
#include <dlfcn.h>
int main(){
    puts("start");
    void *h = dlopen("libm.so.6", RTLD_LAZY);
    double (*fsqrt)(double) = dlsym(h, "sqrt");
    printf("sqrt(2)=%.5f\n", fsqrt(2.0));
    return 0;
}
```
```bash
gcc lazy.c -ldl -o lazy
LD_DEBUG=libs,bindings ./lazy 2>&1 | less
```

### 11.2 ctor/dtor·init_array 순서 체크(동적)
```c
// init.c
#include <stdio.h>
__attribute__((constructor)) static void C1(){ puts("C1"); }
__attribute__((constructor(200))) static void C2(){ puts("C2 (prio 200)"); }
int main(){ puts("main"); return 0; }
__attribute__((destructor)) static void D(){ puts("D"); }
```

---

## 12. 성능 관점: 스타트업 시간의 근사 모델

동적 로딩 스타트업 시간(개념)은 다음 합으로 근사할 수 있다.

$$
T_{\text{start}} \approx T_{\text{mmap\_DSO}} + T_{\text{reloc}} +
\begin{cases}
T_{\text{bindings\_first\_call}} & (\text{Lazy}) \\
T_{\text{bindings\_all}} & (\text{Eager})
\end{cases}
+ T_{\text{init\_array}}
$$

- **줄이는 법**: DSO 수·의존 깊이 축소, `--as-needed`, `--gc-sections`, GNU 해시, Full RELRO+Eager의 트레이드오프 평가, 큰 DSO I/O 단축(압축/패킹은 로더 호환성 주의).

---

## 13. 디버깅·분석·검증 체크리스트

- [ ] `file/readelf -h`로 **PIE/아키/클래스** 확인
- [ ] `readelf -l`의 **PT_INTERP/PT_GNU_STACK/PT_GNU_RELRO/PT_TLS** 상태
- [ ] `readelf -d`의 **DT_NEEDED/RUNPATH/RPATH/SONAME**
- [ ] `ldd` 경로가 **배포 디렉터리 의도**와 일치?
- [ ] `checksec`로 **RELRO/NX/PIE/CANARY/CET**
- [ ] `LD_DEBUG=libs,reloc,bindings`로 **실제 로더 행동** 확인
- [ ] 성능: `strace -f -e file,mmap,openat`로 DSO I/O 과다 탐지
- [ ] 크기: `--gc-sections`, `--as-needed`, 불필요 의존 제거

---

## 14. 부록 A — 흔한 특수 케이스

- **Shebang** (`#! /usr/bin/env python`): ELF 아니라도 **binfmt**로 해석기 지정.
- **정적 링크**(PT_INTERP 없음): ld.so 생략, 커널이 곧바로 `e_entry`로.
- **TLS 모델**: IE(Initial-Exec), LE(Local-Exec), LD(Local-Dynamic)… 스레드 로컬 접근 비용 차이.
- **컨테이너**: 미니멀 베이스 이미지에서 필수 `.so` 누락 → `DT_NEEDED` 실패 다발.
- **SUID/AT_SECURE**: 위험 환경변수 무시, `LD_PRELOAD` 차단.
- **CET/IBT 미호환**: 오래된 DSO와 혼용 시 바인딩/엔트리 패턴 충돌 가능.

---

## 15. 부록 B — 관찰 명령 모음(바로 복붙)

```bash
# ELF 전수검사
readelf -aW app | less
objdump -x app | less
objdump -drwC app | less

# 동적 속성
readelf -dW app
ldd app
patchelf --print-rpath app
patchelf --print-needed app

# 보안 상태
checksec --file=app 2>/dev/null || true
readelf -lW app | egrep 'GNU_STACK|GNU_RELRO|INTERP'
readelf --notes app | grep -A2 'GNU_PROPERTY'

# 런타임 로깅
LD_DEBUG=libs,reloc,bindings ./app 2>&1 | less

# vDSO
cat /proc/self/maps | grep -E 'vdso|vvar'
```

---

## 16. 결론

실행 가능 목적 파일의 로딩은 **커널 로더의 정밀한 mmap/보안 정책**과, 그 뒤를 이은 **동적 로더의 의존 해석·재배치·바인딩**이 맞물리는 **양단 구조**다.
핵심 포인트는 다음 네 가지:

1. **PHDR 기반 PT_LOAD 매핑**: 페이지 정렬/0-필/BSS·CoW를 이해하라.
2. **동적 로딩 메커니즘**: `DT_NEEDED` 그래프, **REL/RELA**, **PLT/GOT**, **IFUNC**, **RELRO**.
3. **스택·auxv·vDSO**: 런타임 환경(AT_*)과 보안 컨텍스트(**AT_SECURE**, 카나리)을 파악하라.
4. **보안·성능 최신 관행**: **PIE+ASLR**, **Full RELRO**, **NX**, **CET**, **GNU 해시**, `--as-needed`/섹션 GC.

이제는 “왜 실행이 실패/느림/위험한지”를 **정확히 측정·설명·수정**할 수 있다.
**로그와 툴로 확인하고**, 필요한 만큼만 **고치고**, 다시 **검증**하라 — 로딩의 본질은 과학이다.
