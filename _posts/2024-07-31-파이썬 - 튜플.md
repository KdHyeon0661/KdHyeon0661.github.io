---
layout: post
title: 파이썬 - 튜플
date: 2024-07-31 19:20:23 +0900
category: Python
---
# 튜플(Tuple)

튜플(tuple)은 순서가 있는 불변(immutable) 시퀀스 자료형입니다. 리스트와 유사하게 여러 값을 순차적으로 저장할 수 있지만, 한 번 생성되면 요소의 변경, 추가, 삭제가 불가능합니다. 이러한 불변성은 데이터의 안정성을 보장하며, 딕셔너리의 키나 집합의 요소처럼 해시 가능한(hashable) 값이 필요한 상황에서 사용됩니다.

튜플을 정의할 때 소괄호 `()`를 사용하지만, 실제로 튜플을 만드는 것은 쉼표(`,`)입니다. 괄호는 선택 사항이며, 특히 빈 튜플을 생성할 때나 단일 요소 튜플을 정의할 때 그 중요성이 드러납니다.

---

## 튜플 생성 방법

### 기본적인 생성 방법
튜플을 생성하는 여러 방법이 있으며, 상황에 따라 적절한 방식을 선택할 수 있습니다.
```python
# 소괄호를 사용한 생성
t1 = (1, 2, 3)

# 쉼표만으로 생성 (괄호 생략 가능)
t2 = 1, 2, 3           # (1, 2, 3)

# 끝에 쉼표를 추가하여 생성 (가독성 및 자동 포맷팅에 유리)
t3 = (1, 2, 3,)

# 빈 튜플 생성
empty1 = ()
empty2 = tuple()
```

### 단일 요소 튜플 생성
단일 요소를 가진 튜플을 생성할 때는 쉼표가 필수적입니다. 쉼표를 생략하면 단순한 괄호 연산으로 처리됩니다.
```python
single = (1,)           # 튜플: (1,)
not_tuple = (1)         # 정수: 1
```

### 다른 시퀀스로부터 튜플 생성
`tuple()` 생성자를 사용하면 다양한 이터러블 객체를 튜플로 변환할 수 있습니다.
```python
# 문자열로부터 생성
tuple("abc")                 # ('a', 'b', 'c')

# 리스트로부터 생성
tuple([1, 2, 3])             # (1, 2, 3)

# 제너레이터 표현식으로부터 생성
tuple(x*x for x in range(3)) # (0, 1, 4)
```

**주의사항**: `(x for x in range(3))`와 같은 표현식은 튜플이 아닌 제너레이터 표현식을 생성합니다. 이를 튜플로 변환하려면 `tuple()` 생성자로 감싸야 합니다.

---

## 튜플의 주요 특징

### 불변성 (Immutability)
튜플의 가장 중요한 특징은 불변성입니다. 한 번 생성된 튜플의 요소는 변경할 수 없습니다. 그러나 튜플 내부에 가변 객체(예: 리스트)가 포함된 경우, 그 내부 객체의 내용은 변경 가능합니다.
```python
t = (1, [2, 3], 4)
t[1].append(99)      # 가능: 내부 리스트는 가변
print(t)             # (1, [2, 3, 99], 4)

# t[0] = 10          # TypeError: 튜플 요소는 재할당 불가
```

### 순서와 중복 허용
튜플은 요소의 순서를 유지하며, 동일한 값을 가진 요소의 중복을 허용합니다.
```python
t = (1, 2, 2, 3, 1)
print(t)  # (1, 2, 2, 3, 1)
```

### 인덱싱과 슬라이싱
리스트와 마찬가지로 인덱스를 통한 접근과 슬라이싱이 가능합니다.
```python
t = (10, 20, 30, 40, 50)
print(t[0])      # 10
print(t[-1])     # 50
print(t[1:4])    # (20, 30, 40)
print(t[::-1])   # (50, 40, 30, 20, 10)
```

### 해시 가능성
튜플의 모든 요소가 해시 가능하다면 튜플 자체도 해시 가능합니다. 이 속성으로 인해 튜플은 딕셔너리의 키나 집합의 요소로 사용될 수 있습니다.
```python
# 해시 가능한 튜플 (요소들이 모두 불변)
key = (1, 2, "three")
d = {key: "value"}
print(d[(1, 2, "three")])  # "value"

# 해시 불가능한 튜플 (가변 객체 포함)
# invalid_key = (1, [2, 3])  # TypeError: unhashable type: 'list'
```

### 메모리 효율성
일반적으로 동일한 요소를 저장할 때 튜플이 리스트보다 메모리를 적게 사용합니다.
```python
import sys
list_size = sys.getsizeof([1, 2, 3, 4, 5])
tuple_size = sys.getsizeof((1, 2, 3, 4, 5))
print(f"리스트 크기: {list_size} bytes")
print(f"튜플 크기: {tuple_size} bytes")
```

---

## 튜플 관련 메서드

튜플은 불변 객체이기 때문에 요소를 변경하는 메서드는 제공되지 않습니다. 대신 검색과 관련된 두 가지 메서드만을 제공합니다.

### count()
특정 값이 튜플에 몇 번 등장하는지 반환합니다.
```python
t = (1, 2, 2, 3, 2, 4)
print(t.count(2))  # 3
print(t.count(5))  # 0 (존재하지 않는 값)
```

### index()
특정 값의 첫 번째 등장 위치 인덱스를 반환합니다. 값이 존재하지 않으면 ValueError를 발생시킵니다.
```python
t = ('a', 'b', 'c', 'a', 'd')
print(t.index('a'))      # 0
print(t.index('a', 1))   # 3 (검색 시작 위치 지정)
print(t.index('a', 1, 4)) # 3 (검색 범위 지정)
# t.index('z')           # ValueError: 'z' is not in tuple
```

---

## 튜플 언패킹과 다중 대입

튜플의 강력한 기능 중 하나는 언패킹(unpacking)입니다. 이를 통해 튜플의 요소를 여러 변수에 쉽게 할당할 수 있습니다.

### 기본 언패킹
```python
# 튜플 언패킹
a, b, c = (10, 20, 30)
print(a, b, c)  # 10 20 30

# 변수 값 교환 (스왑)
x, y = 5, 10
x, y = y, x
print(x, y)     # 10 5
```

### 확장 언패킹 (Extended Unpacking)
Python 3에서는 `*` 연산자를 사용하여 가변 개수의 요소를 언패킹할 수 있습니다.
```python
# 첫 번째와 마지막 요소는 각각 변수에, 중간 요소들은 리스트로
first, *middle, last = (1, 2, 3, 4, 5)
print(first)    # 1
print(middle)   # [2, 3, 4]
print(last)     # 5

# 앞부분만 언패킹
head, *rest = (10, 20, 30, 40)
print(head)     # 10
print(rest)     # [20, 30, 40]
```

### 병렬 순회
튜플 리스트를 순회할 때 언패킹을 활용하면 코드 가독성이 향상됩니다.
```python
points = [(1, 2), (3, 4), (5, 6)]
for x, y in points:
    print(f"x={x}, y={y}, sum={x+y}")
```

---

## 튜플과 리스트 간 변환

튜플과 리스트는 `tuple()`과 `list()` 생성자를 사용하여 상호 변환할 수 있습니다.
```python
# 튜플 → 리스트
t = (1, 2, 3)
lst = list(t)
print(lst)           # [1, 2, 3]
print(type(lst))     # <class 'list'>

# 리스트 → 튜플
lst = [4, 5, 6]
t2 = tuple(lst)
print(t2)            # (4, 5, 6)
print(type(t2))      # <class 'tuple'>
```

---

## 튜플의 주요 활용 사례

### 불변 데이터 저장
값이 변경되지 않아야 하는 데이터를 저장할 때 튜플을 사용합니다.
```python
# 좌표
origin = (0, 0)
point = (100, 200)

# 색상 (RGB)
red = (255, 0, 0)
green = (0, 255, 0)
blue = (0, 0, 255)

# 설정값
database_config = ("localhost", 5432, "mydb", "user", "password")
```

### 딕셔너리의 키로 사용
튜플은 해시 가능하므로 딕셔너리의 키로 사용할 수 있습니다.
```python
# 좌표를 키로 사용
locations = {
    (37.7749, -122.4194): "San Francisco",
    (40.7128, -74.0060): "New York",
    (51.5074, -0.1278): "London"
}
print(locations[(37.7749, -122.4194)])  # San Francisco

# 복합 키
student_grades = {
    ("John", "Doe"): 85,
    ("Jane", "Smith"): 92
}
```

### 함수의 다중 반환값
파이썬에서 함수는 여러 값을 튜플로 묶어 반환할 수 있습니다.
```python
def get_min_max(numbers):
    """리스트에서 최소값과 최대값을 반환"""
    return min(numbers), max(numbers)

numbers = [3, 1, 4, 1, 5, 9, 2, 6]
min_val, max_val = get_min_max(numbers)
print(f"최소값: {min_val}, 최대값: {max_val}")

# 반환값을 하나의 튜플로 받기
result = get_min_max(numbers)
print(f"결과: {result}, 타입: {type(result)}")  # (1, 9) <class 'tuple'>
```

### 레코드 형태의 데이터 저장
튜플은 간단한 레코드를 표현하는 데 적합합니다.
```python
# 학생 정보 (이름, 나이, 성적)
students = [
    ("김철수", 20, 85.5),
    ("이영희", 21, 92.0),
    ("박민수", 20, 78.5)
]

# 나이로 정렬 후 성적로 정렬
students.sort(key=lambda s: (s[1], s[2]))
for student in students:
    print(student)
```

---

## 튜플 비교 연산

튜플은 사전식 순서(lexicographic order)로 비교됩니다. 첫 번째 요소부터 순차적으로 비교하며, 모든 요소가 같으면 두 튜플은 동일한 것으로 간주합니다.
```python
print((1, 2, 3) == (1, 2, 3))    # True
print((1, 2, 3) < (1, 2, 4))     # True (3 < 4)
print((1, 2, 3) < (1, 3, 1))     # True (2 < 3)
print((1, 2) < (1, 2, 3))        # True (더 짧은 튜플이 작음)
print((1, 2, 3) < (2, 0, 0))     # True (1 < 2)
```

---

## 함수 인자와 튜플

### 가변 인자 (*args)
함수 정의에서 `*args`는 전달된 모든 위치 인자들을 튜플로 받습니다.
```python
def print_args(*args):
    print(f"인자들: {args}")
    print(f"타입: {type(args)}")

print_args(1, 2, 3)  # 인자들: (1, 2, 3), 타입: <class 'tuple'>
```

### 함수 호출 시 튜플 언패킹
튜플을 함수 인자로 전달할 때 `*` 연산자를 사용하여 언패킹할 수 있습니다.
```python
def add(a, b, c):
    return a + b + c

numbers = (1, 2, 3)
print(add(*numbers))  # 6 (add(1, 2, 3)과 동일)
```

---

## 구조적 패턴 매칭 (Python 3.10+)

Python 3.10부터 도입된 match-case 문에서 튜플 패턴 매칭이 매우 유용합니다.
```python
def process_command(command):
    match command:
        case ("move", x, y):
            return f"({x}, {y}) 위치로 이동"
        case ("attack", target):
            return f"{target} 공격"
        case ("quit",):
            return "게임 종료"
        case _:
            return "알 수 없는 명령"

print(process_command(("move", 10, 20)))  # (10, 20) 위치로 이동
print(process_command(("attack", "슬라임")))  # 슬라임 공격
print(process_command(("quit",)))  # 게임 종료
```

---

## 타입 힌트에서의 튜플

Python 3.9 이상에서는 typing 모듈을 사용하지 않고도 직접 제네릭 타입 힌트를 작성할 수 있습니다.
```python
# 고정 길이 튜플 (positional 튜플)
def get_point() -> tuple[float, float]:
    return (3.14, 2.71)

# 가변 길이 튜플 (arbitrary-length 튜플)
def sum_numbers(numbers: tuple[int, ...]) -> int:
    return sum(numbers)

print(sum_numbers((1, 2, 3, 4, 5)))  # 15
```

---

## 주의사항과 모범 사례

### 1. 단일 요소 튜플의 쉼표
단일 요소 튜플을 생성할 때 쉼표를 잊지 마세요.
```python
correct = (1,)    # 튜플
wrong = (1)       # 정수 (괄호는 단순 연산 우선순위 변경)
```

### 2. 튜플 내포(Tuple Comprehension)의 오해
파이썬에는 "튜플 내포" 문법이 없습니다. 튜플 생성자를 제너레이터 표현식과 함께 사용해야 합니다.
```python
# 올바른 방법
squares = tuple(x*x for x in range(5))  # (0, 1, 4, 9, 16)

# 잘못된 방법 (제너레이터 표현식)
not_tuple = (x*x for x in range(5))     # 제너레이터 객체
```

### 3. 불변성의 의미
튜플 자체는 불변이지만, 튜플 내부에 가변 객체가 포함된 경우 그 객체의 내용은 변경 가능합니다.
```python
t = ([1, 2], 3)
t[0].append(3)    # 가능: 내부 리스트 수정
print(t)          # ([1, 2, 3], 3)
# t[0] = [4, 5]   # 불가능: 튜플 요소 재할당
```

### 4. 성능 고려사항
튜플은 일반적으로 리스트보다 생성 속도가 빠르고 메모리 사용량이 적습니다. 그러나 요소 검색 속도는 리스트와 큰 차이가 없습니다.

---

## 실전 활용 예제

### 1. 다중 반환값 처리
```python
def divide(dividend: float, divisor: float) -> tuple[float, bool]:
    """나눗셈 결과와 성공 여부를 반환"""
    if divisor == 0:
        return 0.0, False
    return dividend / divisor, True

result, success = divide(10, 2)
if success:
    print(f"결과: {result}")
else:
    print("0으로 나눌 수 없습니다.")
```

### 2. 딕셔너리 아이템 언패킹
```python
person = {"name": "홍길동", "age": 30, "city": "서울"}

# items()는 (key, value) 튜플의 시퀀스를 반환
for key, value in person.items():
    print(f"{key}: {value}")
```

### 3. 데이터 정렬과 그룹화
```python
# (제품명, 가격, 수량) 형식의 데이터
products = [
    ("노트북", 1200000, 3),
    ("모니터", 300000, 5),
    ("키보드", 50000, 10),
    ("마우스", 25000, 15)
]

# 가격 기준 내림차순 정렬
products.sort(key=lambda p: p[1], reverse=True)
print("가격 기준 정렬:")
for product in products:
    print(f"{product[0]}: {product[1]}원, {product[2]}개")

# 총 금액 계산
total_value = sum(price * quantity for _, price, quantity in products)
print(f"\n총 재고 가치: {total_value}원")
```

### 4. enumerate와 함께 사용
```python
fruits = ["사과", "바나나", "체리", "포도"]

# enumerate는 (인덱스, 값) 튜플을 생성
for i, fruit in enumerate(fruits, start=1):
    print(f"{i}. {fruit}")
```

---

## 결론

튜플은 파이썬의 기본적인 시퀀스 자료형 중 하나로, 불변성이라는 독특한 특성을 가지고 있습니다. 이 불변성으로 인해 튜플은 다음과 같은 상황에서 특히 유용합니다:

1. **데이터 무결성 보장**: 한 번 생성된 데이터가 실수로 변경되는 것을 방지합니다.
2. **딕셔너리 키 사용**: 해시 가능한 특성으로 인해 딕셔너리의 키로 사용될 수 있습니다.
3. **다중 반환값 처리**: 함수가 여러 값을 반환해야 할 때 깔끔한 인터페이스를 제공합니다.
4. **의도 명확화**: 읽기 전용 데이터임을 코드 리뷰어와 미래의 자신에게 명시적으로 전달합니다.

튜플은 단순한 "불변 리스트"가 아닌, 파이썬의 언패킹, 패턴 매칭, 타입 힌트 등 다양한 기능과 자연스럽게 통합되는 중요한 자료형입니다. 적절한 상황에서 튜플을 사용하면 더 안전하고 명확한 코드를 작성할 수 있습니다. 리스트와 튜플 사이의 선택은 단순히 "변경 가능 여부"가 아니라, 데이터의 의도와 사용 패턴을 고려한 설계 결정이 되어야 합니다.