---
layout: post
title: 시스템보안 - 실습(잘못 구성된 컨테이너에서 호스트 권한 침투 시나리오 및 모델링)
date: 2025-10-22 23:30:23 +0900
category: 시스템보안
---
# 7.5 실습: 잘못 구성된 컨테이너에서 “호스트 권한 침투 시나리오” **모델링** (공격 재현 없이 방어 관찰)

> 이 섹션은 **교육·방어 목적**입니다. “호스트 권한을 실제로 탈취”하는 단계별 악용 절차나 페이로드는 제공하지 않습니다.  
> 대신 **현장에서 자주 보이는 잘못된 설정**을 **안전하게 재현**하고, 그 설정이 **어떤 위험을 초래할 수 있는지**를 **로그/정책/감사 스크립트**로 **관찰·차단**합니다. 모든 실습은 **본인 소유 랩**과 **격리된 VM**에서만 진행하세요.

---

## 7.5.1 시나리오 맵 (공격 X, 구성·행동만 관찰)

| 범주 | 위험 설정(예) | 위험 개념(모델) | 안전 관찰 포인트 |
|---|---|---|---|
| ① 권한/격리 | `--privileged`, 광범위 `--cap-add`, `allowPrivilegeEscalation: true`, `hostPID/hostNetwork` | 컨테이너가 호스트 자원·네임스페이스에 준접근 | PodSecurity/Admission 로그, Falco/EBPF로 Syscall 이벤트 |
| ② 파일시스템 | `--volume /:/host rw`, 민감 경로 `hostPath` RW, 루트FS RW | 호스트 설정/실행 파일에 간접 영향 가능 | K8s 이벤트, CSI/PodSecurity 경고, Falco rule(hit: mount/write) |
| ③ 소켓·런타임 | `/var/run/docker.sock` 바인드, CRI 소켓 노출 | 런타임 API 통한 “컨테이너 내에서 컨테이너 제어” | docker/containerd 이벤트, OPA/Gatekeeper 미승인 |
| ④ 커널 경계 | 넓은 seccomp, AppArmor/SELinux 미적용 | 위험 syscall/경로 접근 허용 | seccomp/Audit log, AVC(AppArmor/SELinux) 거부 기록 부재 |
| ⑤ 계정/매핑 | root 사용자, userns-remap/Rootless 미사용 | 내부 root == 호스트 root 위험 | `docker info`, `id -u`/`/proc/self/uid_map` |

> **핵심 목표**: 위 설정들이 **실행/적용되는 순간**을 **탐지·차단**하고, **정책 위반 리포트**를 자동 생성.

---

## 7.5.2 랩 1 — Docker에서 위험 옵션 **발견** (차단 아님)

> **안전 주의**: 실제 호스트 민감 경로를 절대 바인드하지 마세요. 아래는 **가짜 디렉터리**와 **읽기 전용**로만 관찰합니다.

### A) 위험 옵션을 가진 컨테이너 실행(“실행 로그만” 수집)
```bash
# 가짜 호스트 디렉터리 준비
sudo mkdir -p /lab/host-dir
sudo chown root:root /lab/host-dir
sudo chmod 755 /lab/host-dir

# 1) 과권한 예시(Observability 목적): privileged + hostPID + cap-add
docker run -d --name obs-priv \
  --privileged \
  --pid=host \
  --cap-add SYS_ADMIN \
  --mount type=bind,src=/lab/host-dir,dst=/mnt/host,ro \
  --security-opt no-new-privileges \
  alpine:3.20 sleep 3600

# 2) docker.sock (관찰만; 실제로는 금지) - 바인드하지 말 것! (예시 주석)
# docker run -d --name obs-sock \
#   -v /var/run/docker.sock:/var/run/docker.sock:ro \
#   alpine:3.20 sleep 3600
```

### B) 위험 옵션 스캔 스크립트(읽기 전용)
```bash
#!/usr/bin/env bash
# docker_audit.sh
set -euo pipefail
printf "== Running containers ==\n"
for id in $(docker ps -q); do
  cfg=$(docker inspect "$id")
  name=$(echo "$cfg" | jq -r '.[0].Name')
  priv=$(echo "$cfg" | jq -r '.[0].HostConfig.Privileged')
  pidm=$(echo "$cfg" | jq -r '.[0].HostConfig.PidMode')
  netm=$(echo "$cfg" | jq -r '.[0].HostConfig.NetworkMode')
  caps=$(echo "$cfg" | jq -r '.[0].HostConfig.CapAdd | join(",")')
  rofs=$(echo "$cfg" | jq -r '.[0].HostConfig.ReadonlyRootfs')
  sock=$(echo "$cfg" | jq -r '.[0].Mounts[]?|select(.Source|test("docker.sock")).Source' || true)
  printf "%s priv=%s pid=%s net=%s caps=%s rofs=%s dockersock=%s\n" \
    "$name" "$priv" "$pidm" "$netm" "${caps:-}" "$rofs" "$([ -n "$sock" ] && echo yes || echo no)"
done
```

**해석 포인트**
- `priv=true`, `PidMode=host`, `CapAdd` 포함, `ReadonlyRootfs=false`, `docker.sock=yes` → **위험 플래그**  
- 이 결과를 CI/감사 리포트로 수집해 **위험 변경**을 팀에 통지

---

## 7.5.3 랩 2 — Kubernetes에서 “위험 Pod” **거부/감사** 흐름

### A) 위험 Pod 매니페스트(관찰용; 실제 적용 금지)
```yaml
# bad-pod.yaml (적용 금지; Admission에서 거부되게 관찰만)
apiVersion: v1
kind: Pod
metadata:
  name: bad-pod
spec:
  hostPID: true
  hostNetwork: true
  containers:
  - name: app
    image: alpine:3.20
    securityContext:
      privileged: true
      allowPrivilegeEscalation: true
      capabilities:
        add: ["SYS_ADMIN","NET_ADMIN"]
    volumeMounts:
      - name: hostfs
        mountPath: /host
        readOnly: true
  volumes:
    - name: hostfs
      hostPath:
        path: / # 예: 실제 사용 금지(Admission 거부될 것)
        type: Directory
```

### B) Pod Security(표준)로 거부/경고 발생시키기
Kubernetes **Pod Security**(기본 Admission)에서 namespace를 **baseline** 또는 **restricted**로 태깅.

```bash
# namespace 생성 + Pod Security Level 설정
kubectl create ns lab-restricted
kubectl label ns lab-restricted \
  pod-security.kubernetes.io/enforce=restricted \
  pod-security.kubernetes.io/audit=restricted \
  pod-security.kubernetes.io/warn=restricted
```

이제 `bad-pod.yaml`을 `lab-restricted`에 적용 시도:
```bash
kubectl -n lab-restricted apply -f bad-pod.yaml
# => Admission에서 "privileged/hostPID/hostNetwork/hostPath" 등 위반으로 거부
```

**관찰 포인트**
- `kubectl` 에러 메시지/이벤트에서 **어떤 필드가 불허인지** 명확히 확인  
- 팀 룰북에 “왜 금지인지”와 “대체 방법(예: DaemonSet + 권한 최소화)” 문서화

---

## 7.5.4 Falco/EBPF로 **행동 탐지** (mount/ptrace/socket 접근)

```yaml
# falco-rules-addons.yaml (핵심 스케치)
- rule: Container Mount Syscall
  desc: Detect mount(2) in container
  condition: container and evt.type = mount
  output: "MOUNT in container (user=%user.name proc=%proc.name file=%fd.name)"
  priority: WARNING

- rule: Docker Socket Access
  desc: Detect access to docker.sock from container
  condition: container and fd.name=/var/run/docker.sock
  output: "Docker socket access (proc=%proc.name user=%user.name)"
  priority: WARNING
```

> **의미**: Admission이 놓친 **런타임 행위**를 보완. 경고만으로도 운영팀이 **잘못된 배포**를 즉시 수정 가능.

---

## 7.5.5 “안전 실패” 중심 체크리스트

- [ ] `--privileged`/`hostPID`/`hostNetwork`/광범위 `cap-add`/`hostPath` RW 사용 **차단**  
- [ ] `/var/run/docker.sock` 노출 금지(불가피 시 **프록시+OPA**로 메서드/이미지 제한)  
- [ ] 루트FS **readOnly** + 필요한 경로만 `tmpfs`/RO 바인드  
- [ ] `allowPrivilegeEscalation: false`, `runAsNonRoot: true`, **고정 UID/GID**  
- [ ] **seccomp: RuntimeDefault/커스텀 최소** + AppArmor/SELinux **Enforce**  
- [ ] Pod Security(Level: restricted) + Gatekeeper/Kyverno 정책  
- [ ] Falco/EBPF로 mount/ptrace/socket 접근 **알림**

---

# 7.6 방어: Pod Security, Seccomp Profile, AppArmor/SELinux, Notary / cosign

> 목표: **기본 Admission(Pod Security)**, **시스템콜 레벨(seccomp)**, **경로/권한 MAC(AppArmor/SELinux)**, **서명·무결성(cosign/Notary)**를 결합해 **사고를 구조적으로 어렵게** 만들기.

---

## 7.6.1 Pod Security (Baseline/Restricted) — **출발선**

### A) 네임스페이스 단위 태그
```bash
kubectl label ns prod \
  pod-security.kubernetes.io/enforce=restricted \
  pod-security.kubernetes.io/audit=restricted \
  pod-security.kubernetes.io/warn=restricted
```

**Restricted**가 기본적으로 막는 것(요약):
- `privileged: true`
- `hostPID/hostIPC/hostNetwork`
- `hostPath` 대부분
- `allowPrivilegeEscalation: true`
- 루트 사용자(예외적 허용 외)
- 위험 Cap 추가

### B) Pod 템플릿(Restricted 통과 샘플)
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: good-pod
spec:
  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: app
    image: ghcr.io/acme/app:1.2.3
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop: ["ALL"]
      runAsUser: 10000
      runAsGroup: 10000
    volumeMounts:
      - name: work
        mountPath: /work
        readOnly: false
  volumes:
    - name: work
      emptyDir: {}   # 필요시 tmpfs: { medium: "Memory", sizeLimit: "64Mi" }
```

---

## 7.6.2 Seccomp Profile — **시스템콜 축소**

### A) RuntimeDefault 채택
컨테이너 런타임가 제공하는 **기본 안전 프로파일**부터 적용.

```yaml
securityContext:
  seccompProfile:
    type: RuntimeDefault
```

### B) 앱 전용 커스텀(최소 허용) 프로파일 작성(예시)
```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "architectures": ["SCMP_ARCH_X86_64","SCMP_ARCH_X86","SCMP_ARCH_X32"],
  "syscalls": [
    { "names": ["read","write","exit","futex","clock_gettime"], "action": "SCMP_ACT_ALLOW" },
    { "names": ["mount","pivot_root","kexec_load","ptrace","keyctl"], "action": "SCMP_ACT_ERRNO" }
  ]
}
```

K8s 적용(클러스터에 파일 배포 후):
```yaml
securityContext:
  seccompProfile:
    type: Localhost
    localhostProfile: profiles/myapp-seccomp.json
```

**운영 팁**
- 먼저 **감사 모드**(허용+로깅)로 범위를 수집 → 업무 최소 셋 파악 후 거부 모드 전환

---

## 7.6.3 AppArmor / SELinux — **경로·권한 MAC**

### A) AppArmor (Debian/Ubuntu 등)
**프로파일(예)**:
```text
# /etc/apparmor.d/myapp
profile myapp flags=(attach_disconnected) {
  # 기본 거부
  deny /** mrwklx,
  # 허용 경로 최소화
  /work/** rw,
  /etc/ssl/certs/** r,
  capability net_bind_service,  # 필요한 캡만
  network inet stream,
}
```
적용(컨테이너 주석):
```yaml
annotations:
  container.apparmor.security.beta.kubernetes.io/app: localhost/myapp
```

### B) SELinux (RHEL/OKD 등)
- 컨테이너에는 기본적으로 `container_t` 타입 부여  
- `:Z`(private label), `:z`(shared) 옵션으로 볼륨 라벨링

예:
```yaml
volumeMounts:
  - mountPath: /app/data
    name: d
volumes:
  - name: d
    hostPath:
      path: /srv/app/data  # 실제 운영에서는 hostPath 지양
      type: Directory
# 배포 시: :Z 옵션이 필요한 CSI/CRI 설정을 사용 (배포판 문서 참조)
```

**운영 팁**
- AppArmor/SELinux는 **seccomp로 막지 못하는 경로/권한**을 보완  
- 거부(deny) 로그(AVC/AppArmor audit)를 **수집·시각화**해 튜닝 루프 운영

---

## 7.6.4 Notary / cosign — **이미지 신뢰·무결성**

> 요점: “**서명되지 않은 이미지**는 배포되지 않는다.”를 Admission/Gatekeeper로 **강제**.

### A) cosign 기본 흐름
```bash
# 1) 키 생성 (키리스도 가능: OIDC)
cosign generate-key-pair   # cosign.key / cosign.pub

# 2) 이미지 서명
cosign sign --key cosign.key ghcr.io/acme/app:1.2.3

# 3) 검증
cosign verify --key cosign.pub ghcr.io/acme/app:1.2.3
```

- **투명성 로그**(Rekor)에 기록 → 서명 행위 감사 가능  
- **SBOM** 첨부(`cosign attest`)로 런타임 전 **구성요소 리스트**까지 검증

### B) Cluster Admission — 서명 강제(Gatekeeper 예시)

ConstraintTemplate(스케치):
```yaml
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8ssignedimage
spec:
  crd:
    spec:
      names:
        kind: K8sSignedImage
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8ssignedimage
      default deny = false
      deny[msg] {
        input.review.object.kind == "Pod"
        some i
        img := input.review.object.spec.containers[i].image
        not startswith(img, "ghcr.io/acme/")
        msg := sprintf("image not in trusted registry: %s", [img])
      }
```
Constraint:
```yaml
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sSignedImage
metadata:
  name: enforce-trusted
spec:
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
```

> **실무**: Kyverno의 `verifyImages`를 활용하면 cosign public key/issuer를 정책에 직접 명시하여 **서명 없는 이미지 거부**를 쉽게 구현.

---

## 7.6.5 Kyverno — 보안 가드레일(간단 예)

### A) Privileged 금지 + Cap Drop + ReadOnly RootFS 강제
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: baseline-container-security
spec:
  validationFailureAction: Enforce
  background: true
  rules:
  - name: disallow-privileged
    match:
      resources:
        kinds: ["Pod"]
    validate:
      message: "privileged containers are not allowed"
      pattern:
        spec:
          containers:
          - =(securityContext):
              =(privileged): "false"
              =(allowPrivilegeEscalation): "false"
              =(readOnlyRootFilesystem): "true"
              =(capabilities):
                =(drop): ["ALL"]
```

### B) cosign 서명 검증(issuer 바인딩)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: verify-signed-images
spec:
  rules:
  - name: require-signature
    match:
      resources:
        kinds: ["Pod"]
    verifyImages:
    - imageReferences:
      - "ghcr.io/acme/*"
      attestors:
      - entries:
        - keys:
            publicKeys: |
              -----BEGIN PUBLIC KEY-----
              ...cosign.pub...
              -----END PUBLIC KEY-----
```

---

## 7.6.6 운영 런북 — “배포 전에 필히 통과해야 할 관문”

1) **이미지**: `cosign verify` & 취약점/라이선스 스캔(SBOM)  
2) **템플릿**: PodSecurity **restricted** 통과 여부 CI에서 사전 검사  
3) **정책**: Gatekeeper/Kyverno로 **Privileged/host* 금지**, hostPath 제한, `no-new-privileges`, seccomp/AppArmor/SELinux 요구  
4) **런타임**: Falco/EBPF 룰로 mount/ptrace/socket 접근 알림  
5) **격리**: userns-remap/Rootless, readOnly FS, tmpfs 최소  
6) **가시성**: 감사 스크립트(docker/K8s)로 **위험 변경** 주간 리포트 발행  
7) **예외 프로세스**: 비즈니스상 권한 필요 시 **만료일 있는 예외** + 사유/증거 첨부

---

## 7.6.7 빠른 점검 템플릿 모음

### A) Compose(개발팀 기본값)
```yaml
version: "3.9"
services:
  app:
    image: ghcr.io/acme/app:1.2.3
    read_only: true
    tmpfs:
      - /tmp:rw,nosuid,nodev,noexec,size=16m
    security_opt:
      - "no-new-privileges:true"
      - "seccomp=runtime/default"
    cap_drop: ["ALL"]
    user: "10000:10000"
    environment:
      - "ENV=prod"
    restart: always
```

### B) Pod 템플릿(프로덕션 기본)
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
spec:
  replicas: 3
  selector: { matchLabels: { app: app } }
  template:
    metadata:
      labels: { app: app }
      annotations:
        container.apparmor.security.beta.kubernetes.io/app: runtime/default
    spec:
      securityContext:
        runAsNonRoot: true
        seccompProfile: { type: RuntimeDefault }
      containers:
      - name: app
        image: ghcr.io/acme/app:1.2.3
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities: { drop: ["ALL"] }
          runAsUser: 10000
          runAsGroup: 10000
        volumeMounts:
          - name: work
            mountPath: /work
      volumes:
        - name: work
          emptyDir:
            medium: Memory
            sizeLimit: "64Mi"
```

### C) Docker 데몬 보안 스니펫
```json
{
  "icc": false,
  "userns-remap": "default",
  "no-new-privileges": true,
  "live-restore": true,
  "default-ulimits": { "nproc": { "Name":"nproc", "Hard": 4096, "Soft": 4096 } },
  "log-driver": "local",
  "seccomp-profile": "/etc/docker/seccomp-default.json"
}
```

---

## 7.6.8 트러블슈팅(자주 묻는 질문)

- **“Restricted에 막혀서 앱이 안 떠요.”**  
  → 필요한 최소 Cap/host 리소스를 **명시적 근거**와 함께 요청하고, **만료일 있는 예외**로 관리.  
- **“seccomp 때문에 라이브러리가 실패합니다.”**  
  → 감사 로그로 필요한 syscall만 선별 → 커스텀 프로파일에 **개별 허용**.  
- **“cosign 검증이 실패해요.”**  
  → 레지스트리 프록시/캐시에서 **서명 아티팩트**(OCI referrers)가 누락되지 않았는지 확인. 프라이빗 레지스트리라면 **referrers 지원/설정** 확인.  
- **“AppArmor/SELinux 때문에 파일 접근 에러.”**  
  → 거부 로그(AVC/AppArmor)를 수집, 필요한 경로만 **세분화 허용**. 무턱대고 Permissive 전환 금지.

---

# 마무리

- “호스트 권한 침투”는 **권한(Privileged/Cap)** + **경로/마운트** + **런타임 API(docker.sock 등)**의 **조합**에서 대부분 발생합니다.  
- **Pod Security(Restricted)**, **seccomp(RuntimeDefault→최소)**, **AppArmor/SELinux(Enforce)**, **cosign/Notary(서명 강제)**를 **동시 적용**하면 **구조적으로** 사고를 예방할 수 있습니다.  
- 이 문서의 템플릿(Admission, 정책, 런타임 탐지, 감사 스크립트)을 **CI/CD와 합쳐** “**배포 전 차단 → 배포 후 감시 → 주간 리포트**” 루프를 만들면, 조직 차원의 **지속 가능한 컨테이너 보안**을 달성할 수 있습니다.
