---
layout: post
title: 논리회로설계 - 레지스터와 카운터
date: 2025-09-08 15:25:23 +0900
category: 논리회로설계
---
# 레지스터와 카운터 — **레지스터/레지스터 전송(RTL)**, **쉬프트 레지스터**, **2진 카운터 설계**

> 표기: \(Q_i\)=\(i\)번째 비트의 현재 상태, \(Q_i^+\)=다음 상태, \(\overline{X}\)=NOT \(X\), \(\oplus\)=XOR, \(\odot\)=XNOR.  
> 가정: 동기식 설계, **에지 트리거 D FF**(또는 D로 변환된 T/JK) 기반. RTL/VHDL/SystemVerilog 예제를 병행한다.

---

## 0. 개요와 타이밍 전제

- **레지스터(Register)**: \(n\)개의 FF 묶음. 동기 제어(CE, 동기 RST/SET, 병렬 LOAD/EN)로 동작.  
- **타이밍 제약**(최대 클록 주파수 \(f_{\max}\))  
  \[
  t_{CQ} + t_{\text{comb}} + t_{SU} \le T_{CLK},\qquad t_{H} \le t_{\min \text{ path}}
  \]
  여기서 \(t_{CQ}\): FF 클록→Q 지연, \(t_{SU}/t_H\): 세트업/홀드, \(t_{\text{comb}}\): 조합 지연.

---

## 1. 레지스터와 **레지스터 전송(RTL)**

### 1.1 포트와 기능
- **CLK**(rising/falling edge), **CE**(Clock Enable), **RST/SET**(동기/비동기), **LOAD**(병렬 로드), **D**, **Q**.
- **동기 리셋 권장**: 비동기 인가/동기 해제 또는 순수 동기(도구/타겟 룰에 따름).

### 1.2 RTL(레지스터 전송) 마이크로연산
- **복사/이동**: \(R_B \leftarrow R_A\)  
- **산술/논리**: \(R_A \leftarrow R_A + R_B,\quad R_D \leftarrow R_D \land R_E\)  
- **로드/클리어**: \(R \leftarrow \text{DATA},\quad R \leftarrow 0\)  
- **시프트/회전**: \(R \leftarrow \text{shl}(R),\quad R \leftarrow \text{rotR}(R)\)  
- **조건부 전송**: \( \text{if } C=1: R_B \leftarrow R_A\) → MUX/CE로 실현.

### 1.3 버스 및 레지스터 파일
- 내부 **3상태 버스**는 FPGA에서 **MUX**로 치환.  
- **레지스터 파일**: 다중 읽기/쓰기 포트(RF 2R1W 등). 주소 디코더+비트라인 조합.

### 1.4 합성 친화 VHDL 템플릿
```vhdl
-- 동기 클리어 + Clock Enable + 선택적 병렬 로드
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity reg_n is
  generic (N : positive := 32);
  port (clk, ce, clr, load : in std_logic;
        d  : in  std_logic_vector(N-1 downto 0);
        q  : out std_logic_vector(N-1 downto 0));
end;
architecture rtl of reg_n is
  signal r : std_logic_vector(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if clr='1' then
        r <= (others=>'0');
      elsif ce='1' then
        if load='1' then r <= d; end if; -- load=0이면 hold
      end if;
    end if;
  end process;
  q <= r;
end;
```

---

## 2. **쉬프트 레지스터(Shift Register)**

### 2.1 형태
- **SISO**(Serial-In Serial-Out), **SIPO**(Serial-In Parallel-Out), **PISO**, **PIPO**.  
- **유니버설 쉬프터**: 좌/우 시프트 + 병렬 로드 + 홀드.  
- **산술 시프트**: 우시프트 시 MSB 유지(부호 확장).  
- **회전(rotate)**: 끝 비트를 반대쪽으로 순환.

### 2.2 상태식(우시프트, SISO)
\[
Q_0^+ = \mathrm{SI},\quad Q_i^+ = Q_{i-1}\ (i=1..n-1),\quad \mathrm{SO}=Q_{n-1}
\]

### 2.3 유니버설 쉬프터 제어표
| S1 S0 | 기능 | 다음 상태 |
|:--:|:--|:--|
| 00 | Hold | \(Q^+=Q\) |
| 01 | Right | \(Q_i^+=Q_{i+1}\), \(Q_{n-1}^+=\text{SI}_R\) |
| 10 | Left | \(Q_i^+=Q_{i-1}\), \(Q_{0}^+=\text{SI}_L\) |
| 11 | Load | \(Q^+=D\) |

### 2.4 배럴 쉬프터
- \(\lceil \log_2 n \rceil\)단의 MUX 네트워크로 한 싸이클에 \(k\)비트 가변 시프트.

### 2.5 VHDL/Verilog 예제

**VHDL — 유니버설 쉬프터**
```vhdl
library ieee; use ieee.std_logic_1164.all;
entity shifter_univ is
  generic (N: positive := 8);
  port (clk, ce : in std_logic;
        s       : in std_logic_vector(1 downto 0);  -- 00 hold, 01 right, 10 left, 11 load
        si_l, si_r : in std_logic;
        d       : in std_logic_vector(N-1 downto 0);
        q       : out std_logic_vector(N-1 downto 0));
end;
architecture rtl of shifter_univ is
  signal r : std_logic_vector(N-1 downto 0);
begin
  process(clk) begin
    if rising_edge(clk) then
      if ce='1' then
        case s is
          when "01"   => r <= si_r & r(N-1 downto 1);     -- 오른쪽
          when "10"   => r <= r(N-2 downto 0) & si_l;     -- 왼쪽
          when "11"   => r <= d;                          -- 병렬 로드
          when others => null;                            -- hold
        end case;
      end if;
    end if;
  end process;
  q <= r;
end;
```

**SystemVerilog — SIPO**
```systemverilog
module sipo #(parameter N=8) (input logic clk, ce, si,
                              output logic [N-1:0] q);
  always_ff @(posedge clk) if (ce) q <= {si, q[N-1:1]}; // 좌시프트
endmodule
```

---

## 3. **2진 카운터 설계**(업/다운, 모듈러, 특수 코드)

### 3.1 리플(비동기) 카운터

- **구성**: FF의 **Q**를 다음 FF의 **CLK**로. \(T=1\) 고정(토글).  
- **주파수 분주**: \(Q_i\)가 \(f_{in}/2^{i+1}\).  
- **지연 누적**: 최상위 비트 안정까지 \(\sum t_{CQ}\) → **디코딩 글리치**.  
- **권장 사용**: 분주기, 깜빡이 등 **단독 출력**. 조합 로직 구동 시 **등록 후 사용**.

**2비트 리플 상태식**
\[
Q_0^+=\overline{Q_0},\quad Q_1^+=Q_1 \oplus Q_0
\]

### 3.2 동기 업 카운터(논리식 관점)

- **T-FF 토글 조건**: \(T_0=1,\quad T_i=\prod_{k=0}^{i-1} Q_k\).  
- **D-FF 식**:
\[
D_0=\overline{Q_0},\qquad D_i=Q_i \oplus \Big(\prod_{k=0}^{i-1} Q_k\Big)
\]
- 모든 FF가 **동시에 클록** → 고속, 글리치 감소.

### 3.3 동기 업/다운 카운터

- **제어 \(U/D\)**(1=업, 0=다운)  
\[
C_i =
\begin{cases}
\prod_{k=0}^{i-1} Q_k & (\text{업})\\
\prod_{k=0}^{i-1} \overline{Q_k} & (\text{다운})
\end{cases},\qquad
D_i = Q_i \oplus C_i
\]

### 3.4 **가산기 기반** 카운터(실무 표준)

- \(Q^+ = Q \pm 1\)을 **캐리체인**으로 구현.  
- FPGA: 전용 carry chain으로 **최고 f\_max**를 달성.  
- **CE, 동기 RST, LOAD**와 결합해 모듈러 동작 구성.

**VHDL — 업 카운터**
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity cnt_up is
  generic (N: positive := 16);
  port (clk, rst, ce : in std_logic;
        q : out std_logic_vector(N-1 downto 0));
end;
architecture rtl of cnt_up is
  signal r : unsigned(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0');
      elsif ce='1' then r <= r + 1;
      end if;
    end if;
  end process;
  q <= std_logic_vector(r);
end;
```

### 3.5 모듈러 \(N\) 카운터, BCD

- **방법 A(동기 클리어)**: \(Q=N-1\) 검출 → 다음 에지에 0 로드.  
- **방법 B(보정)**: \(Q \leftarrow (Q+1==N)?0:Q+1\).  
- **BCD(8421)**: \(N=10\), \(1001_2(=9)\)에서 **0**으로.

**VHDL — 업/다운 모듈러 \(M\)**
```vhdl
entity cnt_ud_mod is
  generic (N: positive := 8; M: positive := 100);
  port (clk, rst, ce, up : in std_logic;
        q   : out unsigned(N-1 downto 0);
        tc  : out std_logic); -- terminal count (1클록 펄스)
end;
architecture rtl of cnt_ud_mod is
  signal r : unsigned(N-1 downto 0) := (others=>'0');
  constant MAXV : unsigned(N-1 downto 0) := to_unsigned(M-1, N);
  signal is_tc : std_logic;
begin
  is_tc <= '1' when (up='1' and r=MAXV) or (up='0' and r=0) else '0';
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0');
      elsif ce='1' then
        if up='1' then r <= (r=MAXV) ? (others=>'0') : r + 1;
        else         r <= (r=0)     ? MAXV         : r - 1;
        end if;
      end if;
    end if;
  end process;
  q  <= r;
  -- 글리치 방지: 레지스터된 TC
  process(clk) begin
    if rising_edge(clk) then
      tc <= ce and is_tc;
    end if;
  end process;
end;
```

**VHDL — BCD 1자리(0–9)**
```vhdl
entity cnt_bcd is
  port (clk, rst, ce : in std_logic;
        q : out unsigned(3 downto 0); tc: out std_logic);
end;
architecture rtl of cnt_bcd is
  signal r : unsigned(3 downto 0) := (others=>'0');
  signal tc_i : std_logic;
begin
  tc_i <= '1' when (ce='1' and r="1001") else '0';
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0');
      elsif ce='1' then
        if r="1001" then r <= (others=>'0'); else r <= r + 1; end if;
      end if;
    end if;
  end process;
  q  <= r;
  process(clk) begin
    if rising_edge(clk) then tc <= tc_i; end if;
  end process;
end;
```

**SystemVerilog — 2자리 BCD 카운터 체인**
```systemverilog
module bcd2(input  logic clk, rst, ce,
            output logic [3:0] ones, tens);
  logic tc1;
  always_ff @(posedge clk) begin
    if (rst) begin ones <= 4'd0; tens <= 4'd0; end
    else if (ce) begin
      if (ones==4'd9) begin ones<=4'd0; tc1<=1; end
      else            begin ones<=ones+1; tc1<=0; end
      if (tc1) tens <= (tens==4'd9) ? 4'd0 : tens+1;
    end
  end
endmodule
```

### 3.6 그레이/존슨/링 카운터

- **그레이 코드**: 인접 상태 간 **1비트**만 변화 → 샘플링/CDC 유리.  
  - 구현 1: 내부 이진 카운터 \(b\) 유지, 출력 \(g=b \oplus (b \gg 1)\).  
  - 구현 2: 직접 토글 논리(보다 복잡).
- **존슨(Twisted Ring)**: 시프트 레지스터에 \(\overline{Q_{MSB}}\) 피드백. 주기 \(2n\).  
- **링(1-hot)**: 단일 1이 순환. 디코딩 단순, 주기 \(n\).

**VHDL — 바이너리→그레이 출력**
```vhdl
entity gray_counter is
  generic (N: positive := 8);
  port (clk, rst, ce : in std_logic;
        g : out std_logic_vector(N-1 downto 0));
end;
architecture rtl of gray_counter is
  signal b : unsigned(N-1 downto 0) := (others=>'0');
  function to_gray(u: unsigned) return std_logic_vector is
  begin
    return std_logic_vector(u xor (u srl 1));
  end;
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then b <= (others=>'0');
      elsif ce='1' then b <= b + 1;
      end if;
    end if;
  end process;
  g <= to_gray(b);
end;
```

**VHDL — 존슨 카운터**
```vhdl
entity johnson is
  generic (N: positive := 6);
  port (clk, rst, ce : in std_logic;
        q : out std_logic_vector(N-1 downto 0));
end;
architecture rtl of johnson is
  signal r : std_logic_vector(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (others=>'0');
      elsif ce='1' then r <= (not r(N-1)) & r(N-1 downto 1);
      end if;
    end if;
  end process;
  q <= r;
end;
```

**VHDL — 링 카운터(1-hot)**
```vhdl
entity ring is
  generic (N: positive := 8);
  port (clk, rst, ce : in std_logic; q : out std_logic_vector(N-1 downto 0));
end;
architecture rtl of ring is
  signal r : std_logic_vector(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then r <= (0 => '1', others => '0');  -- 000...1
      elsif ce='1' then r <= r(N-2 downto 0) & r(N-1);
      end if;
    end if;
  end process;
  q <= r;
end;
```

---

## 4. 분석: 토글률·전력·지연

### 4.1 토글률(업 카운터, CE=1)
- 비트 \(i\)의 토글 확률(싸이클당) \(\approx \frac{1}{2^{i}}\).  
  \(\Rightarrow\) 상위 비트일수록 전력 기여가 작음.

### 4.2 전력
- \(P_{\text{dyn}} \approx \alpha C V^2 f\).  
- 카운터 출력은 **필요한 비트만** 외부에 내보내고, 나머지는 **내부 사용**(루팅 축소).  
- **그레이 코드**: 연속 상태 간 1비트 토글 → 특정 용도에서 전력/EMI 이점.

### 4.3 지연 경로
- 가산기 기반 카운터의 크리티컬 경로: \(t_{CQ} + t_{\text{carry}} + t_{SU}\).  
- **파이프라인** 또는 **분할 카운트**(MSB/LSB)로 f\_max 향상.

---

## 5. 검증(시뮬/포멀)과 테스트벤치

### 5.1 SystemVerilog Assertions 예

**모듈러 M 업 카운터 속성**
```systemverilog
// q는 0..M-1, ce & ~rst 시 q_next = (q==M-1 ? 0 : q+1)
property p_modM;
  @(posedge clk) disable iff (rst)
    ce |-> (q_next == ((q==M-1) ? '0 : q + 1));
endproperty
assert property (p_modM);
```

**그레이 출력: 1비트만 변함**
```systemverilog
function automatic int popcount (logic [N-1:0] x);
  int c; for (int i=0;i<N;i++) if (x[i]) c++; return c;
endfunction

property p_gray_onebit;
  @(posedge clk) disable iff (rst || !ce)
    popcount(g ^ $past(g)) <= 1;
endproperty
assert property (p_gray_onebit);
```

### 5.2 타이밍 시뮬(글리치/TC 펄스 폭 확인)
- **TC 디코드**는 조합 등가식이더라도 **레지스터** 후 사용(글리치 제거).  
- **SDF min/typ/max**로 펄스 폭/경계 조건 검증.

### 5.3 예제 테스트벤치(Verilog)

```verilog
`timescale 1ns/1ps
module tb_cnt;
  reg clk=0, rst=1, ce=0, up=1;
  wire [7:0] q;
  // DUT: 업/다운 모듈러 100
  cnt_ud_mod #(.N(8), .M(100)) U(.clk(clk),.rst(rst),.ce(ce),.up(up),.q(q),.tc());
  always #5 clk=~clk;

  initial begin
    $dumpfile("cnt.vcd"); $dumpvars(0,tb_cnt);
    #20 rst=0; ce=1;
    repeat (120) @(posedge clk);
    up=0; repeat (120) @(posedge clk);
    ce=0; repeat (10) @(posedge clk); // hold
    $finish;
  end
endmodule
```

---

## 6. 실전 레시피 & 함정

1. **클록 게이팅 금지**: 카운터 정지는 **CE**로. (도구의 자동 게이팅 사용 시 규칙 준수)  
2. **비동기 리셋 해제**는 **클록 동기화**로(메타 주의).  
3. **리플 카운터 출력**으로 조합 디코드 후 외부 사용 금지 → **한 싸이클 더 등록**.  
4. **모듈러 비교기**는 **등록된 equality**를 TC로 사용(펄스 폭/글리치 보장).  
5. **CDC**: 카운트 값 타 도메인 전송 시 **그레이 코드** 또는 **더블 FF 동기화**.  
6. **변조/분주**: 듀티 50%가 필요하면 **토글 FF**(÷2) 체인, 홀수 분주 시 **파형 보정 FSM** 사용.  
7. **FPGA 최적화**: 가산기 기반 카운터는 **전용 carry chain**을 반드시 사용(numeric\_std + 단순식).  
8. **전력**: 큰 비트폭 카운터는 **상위 비트만 탭**해도 목적(저속 enable 등)에 충분한 경우가 많음.

---

## 7. 응용 미니 프로젝트

### 7.1 주파수/기간 측정기(게이트 타임 방식)
- **아이디어**: 기준 1s 게이트 동안 테스트 신호의 상승 에지 카운트 → Hz.  
- **구성**:  
  - 카운터 A: 테스트 신호 에지 카운트(동기화 필요).  
  - 카운터 B: 기준 타임 생성(예: 100 MHz 기준 → 1e8 카운트).  
  - 게이트 종료 시 A를 래치 → 표시.

### 7.2 디바운서(버튼 입력)
- 쉬프트 레지스터에 **연속 N클록 동일**이면 안정으로 판정.  
- **카운터 기반** 시간 안정성 체크(예: 5 ms).

```systemverilog
module debouncer #(parameter W=20) (input logic clk, rst, din, output logic dout);
  logic [W-1:0] cnt; logic din_sync;
  // 동기화
  logic s1,s2; always_ff @(posedge clk) begin s1<=din; s2<=s1; end
  assign din_sync = s2;
  // 변화 없으면 카운트++ / 변화 있으면 리셋
  always_ff @(posedge clk) begin
    if (rst) begin cnt<=0; dout<=0; end
    else if (din_sync==dout) cnt<=0;
    else if (&cnt)          dout<=din_sync; // 최댓값 도달 시 업데이트
    else                    cnt<=cnt+1;
  end
endmodule
```

### 7.3 PWM 발생기(모듈러 카운터 + 비교기)
- 카운터 \(Q\)와 듀티 \(D\) 비교: \(PWM = (Q < D)\).  
- 분해능 \(n\)비트 → \(2^n\) 스텝. Edge-aligned/Center-aligned(삼각파 카운터) 선택.

---

## 8. 수학 메모

- **업 카운터의 상태 전이**(이진)  
  \[
  Q^+ = Q + 1 \pmod{2^n}
  \]
- **그레이 변환**  
  \[
  G = B \oplus (B \gg 1)
  \]
- **토글률 기대값**(CE=1)  
  \[
  \Pr[\text{bit }i\text{ toggles}] \approx \frac{1}{2^{i}}
  \]
- **f\_{\max}**  
  \[
  f_{\max} \le \frac{1}{t_{CQ}+t_{\text{logic}}+t_{SU}}
  \]

---

## 9. 종합 체크리스트

- [ ] RST 방식은 타겟 규칙에 맞게(동기 권장, 비동기 해제 동기화).  
- [ ] 리플은 **외부 디코드 금지**, 등록 후 사용.  
- [ ] 모듈러 비교/TC는 **레지스터링**.  
- [ ] 가산기 기반 + **carry chain** 활용(고속).  
- [ ] CDC/샘플링에는 **그레이** 또는 동기화.  
- [ ] 시뮬(기능→타이밍 SDF), SVA로 **범위/모듈러/원-핫/그레이 성질** 검증.  
- [ ] 전력: CE 활용, 상위 비트만 탭, 필요시 그레이 코드.

---

## 10. 연습문제

1) **모듈러 \(M=1000\)** 업 카운터를 가산기 기반으로 설계하라. TC 펄스는 1클록, 글리치 프리. VHDL/Verilog 각각 작성.  
2) **업/다운** 카운터의 \(D_i=Q_i \oplus C_i\)를 \(i=0..3\)에 대해 전개하고 **게이트 수**를 근사하라. 가산기 기반과 비교.  
3) **그레이 카운터**: (a) 바이너리 내부+그레이 출력, (b) 직접 그레이 상태 전이(1비트 토글) FSM. 두 방식의 f\_{\max}/자원/검증 난이도를 토론.  
4) **존슨 카운터** \(N=5\): 주기(10)와 각 상태의 디코딩(원-핫 유사)을 설계하고, 임의의 2상태를 디코딩하는 조합식(최소 항)을 도출.  
5) **PWM**: 10비트 분해능, 50 MHz 클록에서 최소/최대 주파수와 듀티 해상도를 계산하고, Center-aligned로 바꿀 때의 스펙 변화를 분석.

---

### 포켓 요약
- **레지스터/RTL**: FF 묶음 + CE/LOAD/RST. 버스/MUX, 레지스터 파일로 데이터패스 구성.  
- **쉬프트 레지스터**: SISO/SIPO/PISO/PIPO, 유니버설(좌/우/로드/홀드), 배럴(로그 단계).  
- **카운터**: 리플(간단/저속/글리치), 동기(토글 조건) 또는 **가산기 기반**(실무 표준). 모듈러/BCD/그레이/존슨/링까지.  
- **검증**: 기능→타이밍(SDF), SVA로 속성 확인, TC/디코드는 **등록**. 전력/EMI엔 **토글률 제어**와 **그레이**가 유효.