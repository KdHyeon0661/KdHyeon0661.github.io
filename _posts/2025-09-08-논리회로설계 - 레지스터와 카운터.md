---
layout: post
title: 논리회로설계 - 레지스터와 카운터
date: 2025-09-08 15:25:23 +0900
category: 논리회로설계
---
# 레지스터와 카운터 — **레지스터/레지스터 전송(RTL)**, **쉬프트 레지스터**, **2진 카운터 설계**

> 표기: \(Q_i\)=\(i\)번째 비트의 현재 상태, \(Q_i^+\)=다음 상태, \(\overline{X}\)=NOT \(X\), \(\oplus\)=XOR.  
> 하드웨어는 대부분 **에지 트리거 D FF**(또는 T/JK 변환) 위에 제어 로직을 얹어 구현합니다.

---

## 1) 레지스터와 **레지스터 전송(RTL)**

### 1.1 레지스터의 정의와 기본 포트
- **레지스터(Register)**: \(n\)개의 플립플롭(FF)을 묶은 \(n\)비트 저장소.  
- 일반 포트
  - **CLK**(에지 트리거), **CE**(Clock Enable), **RST/SET**(동기/비동기), **LOAD**(병렬 로드), **D[n-1:0]**, **Q[n-1:0]**.
- 타이밍 제약  
  \[
  t_{CQ} + t_{\text{comb}} + t_{SU} \le T_{CLK},\qquad t_{H} \le t_{\text{path(min)}}
  \]

### 1.2 레지스터 전송 레벨(RTL)과 마이크로연산
- **RTL 표기**: `R2 ← R1`(이전 클록의 R1을 다음 에지에 R2로 복사).  
- **마이크로연산** 예:
  - **이동/복사**: \(R_B \leftarrow R_A\)  
  - **산술**: \(R_A \leftarrow R_A + R_B\), \(R_C \leftarrow R_C + 1\)  
  - **논리**: \(R_D \leftarrow R_D \land R_E\)  
  - **병렬 로드/클리어**: \(R \leftarrow \text{DATA}\), \(R \leftarrow 0\)  
  - **시프트/회전**: \(R \leftarrow \text{shl}(R)\), \(R \leftarrow \text{rotR}(R)\)
- **조건부 전송**: \( \text{if } C=1 \text{ then } R_B \leftarrow R_A \). 제어신호 **C**로 MUX/CE를 구동.

### 1.3 버스 구조에서의 전송
- **1-버스/2-버스/3-버스 아키텍처**: 동시에 이동 가능한 단어 수가 다름(데이터패스 대역폭 결정).
- **버스 구현**
  - **3상태 버스 + 디코더(one-hot)**: 한 번에 하나만 OE=1. (FPGA 내부는 MUX로 치환)
  - **MUX-기반 버스**: 선택선으로 소스 선택(내부 합성 친화).
- **레지스터 파일**(Register File)
  - **읽기 포트**: 보통 조합(디코더→셀→비트라인)  
  - **쓰기 포트**: 클록 동기(어드레스 디코더 + WE)  
  - 다중 포트: 읽기 2/쓰기 1(RF 2R1W) 등이 흔함.

### 1.4 합성 친화 레지스터 템플릿 (VHDL)
```vhdl
-- 동기 클리어 + CE + 병렬 로드
library ieee; use ieee.std_logic_1164.all;
entity reg_n is
  generic (N : positive := 32);
  port (clk, ce, clr, load : in std_logic;
        d  : in  std_logic_vector(N-1 downto 0);
        q  : out std_logic_vector(N-1 downto 0));
end;
architecture rtl of reg_n is
  signal qi : std_logic_vector(N-1 downto 0);
begin
  process(clk) is
  begin
    if rising_edge(clk) then
      if clr='1' then
        qi <= (others => '0');
      elsif ce='1' then
        if load='1' then qi <= d; end if;
      end if;
    end if;
  end process;
  q <= qi;
end;
```

---

## 2) **쉬프트 레지스터(Shift Register)**

### 2.1 형태와 정의
- **SISO**: Serial-In Serial-Out  
- **SIPO**: Serial-In Parallel-Out (ADC/센서 데이터 시리얼 수집)  
- **PISO**: Parallel-In Serial-Out (병렬 데이터를 직렬 전송)  
- **PIPO**: Parallel-In Parallel-Out (내부 파이프라인/지연 요소)  
- **양방향/유니버설**: 좌/우 시프트 + 병렬 로드 + 홀드.

### 2.2 이상적 동작식 (우시프트, SISO)
\[
\begin{aligned}
Q_0^+ &= \text{SI},\\
Q_i^+ &= Q_{i-1}\quad (i=1..n-1),\\
\text{SO} &= Q_{n-1}
\end{aligned}
\]
좌시프트는 반대 방향. **회전(rotate)** 는 끝에서 반대편으로 되돌림( \(Q_0^+=Q_{n-1}\) 등).

### 2.3 제어 테이블(유니버설 쉬프터 예)
| `S1 S0` | 기능 | 다음 상태 |
|:--:|:--|:--|
| 00 | Hold | \(Q^+=Q\) |
| 01 | 우시프트 | \(Q_i^+=Q_{i+1}\), \(Q_{n-1}^+=\text{SI}_R\) |
| 10 | 좌시프트 | \(Q_i^+=Q_{i-1}\), \(Q_0^+=\text{SI}_L\) |
| 11 | 병렬로드 | \(Q^+=D\) |

### 2.4 산술 시프트와 회전
- **산술 우시프트**: 최상위 비트(MSB) 유지(부호 확장). \(Q_{n-1}^+=Q_{n-1}\).  
- **산술 좌시프트**: 일반 좌시프트(LSB에 0 삽입).  
- **회전(rotate)**: 끝 비트를 반대쪽으로 순환.

### 2.5 배럴 쉬프터(Barrel Shifter)
- 한 싸이클에 \(k\)비트까지 가변 시프트. **MUX 트리**로 구현(비트-교환 네트워크).  
- 지연 \( \approx \lceil \log_2 n \rceil \) 단계.

### 2.6 쉬프트 레지스터 VHDL 템플릿
```vhdl
-- SIPO: SI를 매 클록 오른쪽으로 밀어넣음
entity sipo is
  generic (N: positive := 8);
  port (clk, ce, si : in std_logic; q : out std_logic_vector(N-1 downto 0));
end;
architecture rtl of sipo is
  signal r : std_logic_vector(N-1 downto 0);
begin
  process(clk) begin
    if rising_edge(clk) then
      if ce='1' then
        r <= si & r(N-1 downto 1); -- 좌시프트(LSB→우측)
      end if;
    end if;
  end process;
  q <= r;
end;

-- 유니버설 쉬프터 (좌/우/홀드/병렬로드)
entity shifter_univ is
  generic (N: positive := 8);
  port (clk, ce : in std_logic;
        s       : in std_logic_vector(1 downto 0);  -- 00 hold, 01 right, 10 left, 11 load
        si_l, si_r : in std_logic;                   -- 좌/우 시리얼 입력
        d       : in std_logic_vector(N-1 downto 0);
        q       : out std_logic_vector(N-1 downto 0));
end;
architecture rtl of shifter_univ is
  signal r : std_logic_vector(N-1 downto 0);
begin
  process(clk) begin
    if rising_edge(clk) then
      if ce='1' then
        case s is
          when "01"   => r <= si_r & r(N-1 downto 1);             -- 우시프트
          when "10"   => r <= r(N-2 downto 0) & si_l;             -- 좌시프트
          when "11"   => r <= d;                                  -- 로드
          when others => null;                                    -- 홀드
        end case;
      end if;
    end if;
  end process;
  q <= r;
end;
```

---

## 3) **2진 카운터 설계**

### 3.1 개요
- 카운터: 클록마다 상태(수)를 **증감**하거나 **주기적으로 반복**하는 순서회로.  
- 분류: **리플(비동기)**, **동기**, **업/다운**, **모듈러 \(N\)**, **BCD/그레이/존슨** 등.

### 3.2 리플(비동기) 카운터
- **구성**: T FF들을 직렬로 연결, \(T=1\) 고정. 앞 비트의 **Q**가 다음 FF의 **클록**.  
- **동작**: \(Q_0\)은 매 에지 토글(÷2), \(Q_i\)는 \(f_{in}/2^{i+1}\).  
- **지연**: 출력이 **차례로** 토글 → 최상위 비트가 안정되기까지
  \[
  t_{\text{settle}} \approx \sum_{i=0}^{n-1} t_{CQ,i}
  \]
  따라서 **디코딩 글리치** 위험, 고속 불리.
- **장점**: 매우 간단, 분주기 용이.  
- **주의**: 리플 카운터의 출력으로 조합 로직을 **직접 구동하지 말고** 한 싸이클 **등록**하여 사용.

**2비트 리플 예 (T=1)**  
\[
\begin{cases}
Q_0^+ = \overline{Q_0}\\
Q_1^+ = Q_1 \oplus Q_0
\end{cases}
\]

### 3.3 동기 2진 업 카운터 (T-FF 관점)
- **토글 조건**: 비트 \(i\)는 **하위 모든 비트가 1**일 때 토글.
\[
T_0 = 1,\quad T_1 = Q_0,\quad T_2 = Q_1 Q_0,\quad
T_i = \prod_{k=0}^{i-1} Q_k
\]
- **D-FF 관점**:
\[
D_0 = \overline{Q_0},\qquad
D_i = Q_i \oplus \left(\prod_{k=0}^{i-1} Q_k\right)
\]
- **장점**: 모든 FF가 **동시에** 클록됨 → 고속, 디코딩 글리치 감소.

### 3.4 동기 업/다운 카운터
- 업/다운 제어 \(U/D\) (업=1, 다운=0)일 때 T-FF 토글식:
\[
T_i = \left(U/D\right)\cdot\!\!\prod_{k=0}^{i-1} Q_k \;+\;
\overline{(U/D)}\cdot\!\!\prod_{k=0}^{i-1} \overline{Q_k}
\]
- D-FF로 쓰면
\[
D_i = Q_i \oplus C_i,\quad
C_i=
\begin{cases}
\prod_{k=0}^{i-1} Q_k & \text{(업)}\\[2pt]
\prod_{k=0}^{i-1} \overline{Q_k} & \text{(다운)}
\end{cases}
\]

### 3.5 **가산기 기반** 동기 카운터(권장)
- \(Q^+ = Q + 1\) (또는 \(-1\))을 **리플 캐리/카리체인**으로 구현.  
- FPGA에서는 전용 **카리 체인**으로 고속/저자원.  
- **CE**와 **동기 클리어/프리셋**으로 모듈러 동작을 붙임.

### 3.6 모듈러 \(N\) 카운터(임의 진법/모드)
- 방법 A: **종단 카운트(TC) 동기 클리어**
  - 업 카운터에서 \(Q=N-1\)을 **동기 검출** → 다음 에지에 **0으로 로드**.
- 방법 B: **보정 가산**: \(Q^+=Q+1\) 후 \(Q=N\)이면 \(Q^+\leftarrow 0\).  
- 예: **BCD(10진) 카운터 (8421)**  
  - \(N=10\). \(Q=1001_2(=9)\) 검출 후 \(\to 0000\).  
  - 2자릿수 BCD는 **두 스테이지**를 연결, 하위 자리의 TC가 상위 자리를 **CE**로 구동.

### 3.7 그레이/존슨/링 카운터(참고)
- **그레이 카운터**: 인접 카운트 간 1비트만 변함 → EMC/샘플링 오류에 유리(ADC 주소, FIFO 포인터).  
- **존슨**(Twisted Ring): 시프트레지스터에 보수 피드백. 주기 \(=2n\), 디코딩 쉬움.  
- **링 카운터**: 원-핫(1-hot) 순환. 주기 \(=n\), 디코딩 매우 쉬움(고속 FSM에 활용).

### 3.8 카운터 설계 체크리스트
- **f\_max**: \(t_{CQ}+t_{\text{adder/logic}}+t_{SU} \le T\). 리플은 체인 길이만큼 증가.  
- **리셋 전략**: 비동기 적용/동기 해제, 또는 동기 리셋만 사용.  
- **TC 검출 글리치**: 종단 디코드(AND/OR) 출력은 **레지스터**해서 사용.  
- **전력**: 토글 확률 고려(상위 비트일수록 토글 감소). 필요시 **그레이** 사용.  
- **CDC**: 카운트 값을 다른 클록 도메인으로 보낼 때는 **이진→그레이** 변환 또는 **듀얼-FF 동기화**.

### 3.9 VHDL 템플릿

**(1) 동기 업 카운터 (가산기 기반)**
```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity cnt_up is
  generic (N: positive := 16);
  port (clk, rst, ce : in std_logic;
        q : out std_logic_vector(N-1 downto 0));
end;
architecture rtl of cnt_up is
  signal r : unsigned(N-1 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        r <= (others=>'0');
      elsif ce='1' then
        r <= r + 1;
      end if;
    end if;
  end process;
  q <= std_logic_vector(r);
end;
```

**(2) 업/다운 + 모듈러 \(M\) (동기 클리어)**
```vhdl
entity cnt_ud_mod is
  generic (N: positive := 8; M: positive := 100); -- 0..M-1
  port (clk, rst, ce, up : in std_logic;
        q   : out unsigned(N-1 downto 0);
        tc  : out std_logic); -- terminal count pulse
end;
architecture rtl of cnt_ud_mod is
  signal r : unsigned(N-1 downto 0) := (others=>'0');
  constant MAXV : unsigned(N-1 downto 0) := to_unsigned(M-1, N);
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        r <= (others=>'0');
      elsif ce='1' then
        if up='1' then
          if r = MAXV then r <= (others=>'0'); else r <= r + 1; end if;
        else
          if r = 0     then r <= MAXV;         else r <= r - 1; end if;
        end if;
      end if;
    end if;
  end process;
  q  <= r;
  tc <= '1' when (ce='1' and ((up='1' and r=MAXV) or (up='0' and r=0))) else '0';
end;
```

**(3) BCD 1자리(0–9)**
```vhdl
entity cnt_bcd is
  port (clk, rst, ce : in std_logic;
        q : out unsigned(3 downto 0); tc: out std_logic);
end;
architecture rtl of cnt_bcd is
  signal r : unsigned(3 downto 0) := (others=>'0');
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        r <= (others=>'0');
      elsif ce='1' then
        if r = "1001" then r <= (others=>'0'); else r <= r + 1; end if;
      end if;
    end if;
  end process;
  q  <= r;
  tc <= '1' when (ce='1' and r="1001") else '0';
end;
```

**(4) 동기 업/다운(논리식 기반, D-FF 관점)**
```vhdl
-- D_i = Q_i xor C_i,  C_i = (up ? prod(Q_low) : prod(not Q_low))
-- 예: 4비트
entity cnt_ud_logic is
  port (clk, rst, ce, up : in std_logic;
        q : out std_logic_vector(3 downto 0));
end;
architecture rtl of cnt_ud_logic is
  signal r : std_logic_vector(3 downto 0) := (others=>'0');
  function all_ones(v: std_logic_vector; hi,lo: integer) return std_logic is
    variable z: std_logic := '1';
  begin
    for i in lo to hi loop z := z and v(i); end loop; return z;
  end;
  function all_zeros(v: std_logic_vector; hi,lo: integer) return std_logic is
    variable z: std_logic := '1';
  begin
    for i in lo to hi loop z := z and (not v(i)); end loop; return z;
  end;
begin
  process(clk) begin
    if rising_edge(clk) then
      if rst='1' then
        r <= (others=>'0');
      elsif ce='1' then
        -- D0
        r(0) <= r(0) xor '1';
        -- D1..D3
        for i in 1 to 3 loop
          if up='1' then
            r(i) <= r(i) xor all_ones(r, i-1, 0);
          else
            r(i) <= r(i) xor all_zeros(r, i-1, 0);
          end if;
        end loop;
      end if;
    end if;
  end process;
  q <= r;
end;
```

---

## 4) 흔한 함정과 베스트 프랙티스

1. **리플 카운터의 디코드 글리치**: 모듈러 검출/외부 제어에 바로 쓰지 말고 **레지스터**로 한번 더 샘플.  
2. **비동기 리셋/세트 해제**: 클록과 **동기화된 해제**(복구/제거 시간 준수).  
3. **클록 게이팅 금지**: 카운터 정지(CE=0)는 **CE 포트**로.  
4. **f\_max 개선**: 가산기 기반 + **파이프라인**(긴 피드백 경로 분할) + FPGA **카리체인** 활용.  
5. **전력**: 큰 폭 카운터의 상위 비트는 토글률이 낮음 → **필요 비트만** 외부로 내보내거나 **그레이 코드** 선택.  
6. **모듈러 \(N\)**: \(N\)이 2의 거듭제곱이 아니면 **동기식 종단 처리** 필수(비동기 클리어는 글리치 유발).  
7. **다중 자리 BCD**: 하위 자리의 **TC 펄스**로 상위 자리 **CE**를 구동(클록 도메인 동일).

---

## 5) 요약 포켓 카드

- **레지스터**: FF 묶음 + CE/LOAD/RST. RTL 전송은 MUX/버스/디코더로 실현.  
- **쉬프트 레지스터**: SISO/SIPO/PISO/PIPO, 유니버설(좌/우/로드/홀드), 배럴은 \( \log_2 n \) 단계.  
- **2진 카운터**
  - 리플: 간단·저속·글리치 주의(분주기용).  
  - 동기: \(T_i=\prod Q_k\) (업), \(T_i=\prod \overline{Q_k}\) (다운); 또는 **가산기 기반**이 실무 표준.  
  - 모듈러/BCD: **동기 종단 처리**와 **TC 레지스터링**.  
  - 타이밍: \(t_{CQ}+t_{\text{logic}}+t_{SU}\le T\).