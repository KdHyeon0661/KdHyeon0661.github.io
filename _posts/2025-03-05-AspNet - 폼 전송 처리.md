---
layout: post
title: AspNet - 폼 전송 처리
date: 2025-03-05 19:20:23 +0900
category: AspNet
---
# Razor Pages에서 폼 전송 처리 완전 정복 — `OnPost`, PRG, `RedirectToPage`, TempData, 다중 핸들러, AJAX

## 큰 그림: 폼 처리의 6단계

1. `OnGet()`에서 폼을 렌더링
2. 사용자가 `<form method="post">`로 제출
3. **모델 바인딩**(본문/쿼리/라우트 → PageModel 속성)
4. **검증**(Data Annotations/커스텀) → `ModelState`에 결과 누적
5. 실패 → `return Page()`로 **현재 폼 재렌더링(입력 유지)**
6. 성공 → **PRG**: `return RedirectToPage(...);` 로 다른 페이지 GET

핵심: **서버 검증이 최종**. 클라이언트 검증은 UX 보조.

---

## `OnPost()` 해부 — 동기/비동기/핸들러 이름

### 기본 시그니처

```csharp
public IActionResult OnPost()
{
    if (!ModelState.IsValid) return Page();
    // 도메인 처리
    return RedirectToPage("Success");
}
```

### 비동기 버전

```csharp
public async Task<IActionResult> OnPostAsync(CancellationToken ct)
{
    if (!ModelState.IsValid) return Page();

    await _service.SaveAsync(Input, ct); // DB/외부IO
    return RedirectToPage("Success");
}
```

- **팁**: 외부 IO가 있다면 항상 `OnPostAsync` + `CancellationToken`을 노출해 서버 리소스를 아끼자.

### 다중 핸들러: `OnPostSave`, `OnPostDelete`

```csharp
public IActionResult OnPostSave()  { /* ... */ return RedirectToPage("List"); }
public IActionResult OnPostDelete(){ /* ... */ return RedirectToPage("List"); }
```

```cshtml
<form method="post" asp-page-handler="Save">
  <button type="submit">저장</button>
</form>

<form method="post" asp-page-handler="Delete">
  <button type="submit">삭제</button>
</form>
```

또는 하나의 폼 + 여러 버튼:

```cshtml
<form method="post">
  <button type="submit" name="handler" value="Save">저장</button>
  <button type="submit" name="handler" value="Delete">삭제</button>
</form>
```

```csharp
public IActionResult OnPost(string handler)
  => handler switch
  {
      "Save"   => OnPostSave(),
      "Delete" => OnPostDelete(),
      _        => Page()
  };
```

---

## 모델 바인딩 & 검증 — `[BindProperty]`, 이름 규칙, 오버포스팅 방어

### 바인딩 기초

```csharp
public class ContactModel : PageModel
{
    [BindProperty]                 // POST 바인딩
    public MessageInput Input { get; set; } = new();

    public void OnGet() { }

    public IActionResult OnPost()
    {
        if (!ModelState.IsValid) return Page();
        // 처리
        return RedirectToPage("Thanks");
    }
}

public class MessageInput
{
    [Required, StringLength(500)]
    public string Message { get; set; } = "";
}
```

뷰:

```cshtml
<form method="post">
  <label asp-for="Input.Message"></label>
  <textarea asp-for="Input.Message"></textarea>
  <span asp-validation-for="Input.Message"></span>
  <button>보내기</button>
</form>

@section Scripts { <partial name="_ValidationScriptsPartial" /> }
```

- `name="Input.Message"`와 같은 **경로형 name**이 자동 생성 → 바인딩 성공
- GET에서 쿼리도 바인딩하려면:
  ` [BindProperty(SupportsGet = true)] public string? Keyword { get; set; }`

### 방어

- 입력 전용 **DTO**를 만들고, 엔터티에 직접 바인딩하지 않는다.
- 서버가 관리하는 값(권한/상태/가격 등)에는 `[BindNever]`를 고려.

```csharp
public class OrderInput
{
    [Required] public string ProductId { get; set; } = "";
    public int Quantity { get; set; } = 1;

    [BindNever] public decimal UnitPrice { get; set; } // 클라이언트가 못 바꿈
}
```

### ModelState 주의점(값 우선순위)

- POST 후 서버가 `Input.Message = Normalize(...);`로 값을 바꿔도, **ModelState의 원본 값**이 다시 렌더링될 수 있다.
- 필요 시:
  ```csharp
  ModelState.Remove("Input.Message");
  Input.Message = Normalize(Input.Message);
  TryValidateModel(Input, nameof(Input));
  ```

---

## `Page()` vs `RedirectToPage()` — 언제, 왜 쓰나

| 메서드 | 쓰는 때 | 특징 |
|---|---|---|
| `Page()` | 검증 실패/동일 페이지 재표시 | **입력값 유지**(ModelState 재활용) |
| `RedirectToPage()` | 처리 성공 후 이동(PRG) | 새 요청(입력값 초기화) |

### `RedirectToPage()` 활용 패턴

```csharp
return RedirectToPage("Index");                          // 상대(동일 폴더)
return RedirectToPage("/Home/Index");                    // 절대
return RedirectToPage("Result", new { id = 10, q = "tv" });// 쿼리/라우트
```

프래그먼트(해시) 이동:

```csharp
return RedirectToPage("Result", new { id = 5 }, fragment: "details"); // /Result?id=5#details
```

영구/메서드 보존 변형:

```csharp
return RedirectToPagePermanent("/Home/Index");
return RedirectToPagePreserveMethod("Confirm"); // 307/308로 메서드 유지
```

> **PRG(Post-Redirect-Get)**: 새로고침 중복 제출 방지, URL 공유/북마크에 안전.

---

## 파라미터 전달 — 라우트, 쿼리, `TempData`

### 라우트/쿼리 값 전달

```csharp
return RedirectToPage("Detail", new { id = 7, tab = "spec" });
// → /Detail?id=7&tab=spec
```

받는 페이지:

```csharp
public class DetailModel : PageModel
{
    public int Id { get; private set; }
    public string? Tab { get; private set; }

    public void OnGet(int id, string? tab)
    {
        Id  = id;
        Tab = tab;
    }
}
```

### `TempData`로 일회성 메시지

설정:

```csharp
TempData["SuccessMessage"] = "저장되었습니다.";
return RedirectToPage("List");
```

수신:

```csharp
public class ListModel : PageModel
{
    [TempData] public string? SuccessMessage { get; set; }
    public void OnGet() { }
}
```

뷰:

```cshtml
@if (!string.IsNullOrEmpty(Model.SuccessMessage))
{
  <div class="alert alert-success">@Model.SuccessMessage</div>
}
```

- **주의**: `TempData`는 딱 한 번 읽으면 사라진다. 연속 표시가 필요하면 재설정.

---

## 파일 업로드 있는 폼 — 검증과 보안

모델:

```csharp
public class UploadInput
{
    [Required] public IFormFile File { get; set; } = default!;
}
```

PageModel:

```csharp
public class UploadModel : PageModel
{
    [BindProperty] public UploadInput Input { get; set; } = new();

    private const long MaxSize = 2 * 1024 * 1024; // 2MB
    private static readonly string[] Allowed = { "image/png", "image/jpeg" };

    public async Task<IActionResult> OnPostAsync()
    {
        if (!ModelState.IsValid) return Page();

        var f = Input.File;
        if (f.Length <= 0 || f.Length > MaxSize)
            ModelState.AddModelError("Input.File", "파일 크기는 1바이트 이상 2MB 이하");

        if (!Allowed.Contains(f.ContentType))
            ModelState.AddModelError("Input.File", "PNG/JPEG만 허용");

        if (!ModelState.IsValid) return Page();

        using var s = f.OpenReadStream();
        // (선택) 매직 바이트 검사/바이러스 스캔
        // 저장 로직 …

        TempData["SuccessMessage"] = "업로드 완료";
        return RedirectToPage("Done");
    }
}
```

뷰:

```cshtml
<form method="post" enctype="multipart/form-data">
  <input asp-for="Input.File" type="file" />
  <span asp-validation-for="Input.File"></span>
  <button>업로드</button>
</form>

@section Scripts { <partial name="_ValidationScriptsPartial" /> }
```

- `enctype="multipart/form-data"` 필수
- **Content-Type만 믿지 말고** 파일 시그니처(매직 바이트) 확인 권장

---

## 한 페이지에 **복수 폼** 처리

시나리오: 프로필 저장 + 비밀번호 변경

PageModel:

```csharp
public class AccountModel : PageModel
{
    [BindProperty] public ProfileInput Profile { get; set; } = new();
    [BindProperty] public PasswordInput Password { get; set; } = new();

    public IActionResult OnPostSaveProfile()
    {
        if (!TryValidateModel(Profile, nameof(Profile))) return Page();
        // 저장
        TempData["SuccessMessage"] = "프로필 저장";
        return RedirectToPage();
    }

    public IActionResult OnPostChangePassword()
    {
        if (!TryValidateModel(Password, nameof(Password))) return Page();
        // 변경
        TempData["SuccessMessage"] = "비밀번호 변경";
        return RedirectToPage();
    }
}
```

뷰:

```cshtml
<form method="post" asp-page-handler="SaveProfile">
  <!-- Profile.* 필드들 -->
  <button>프로필 저장</button>
</form>

<form method="post" asp-page-handler="ChangePassword">
  <!-- Password.* 필드들 -->
  <button>비밀번호 변경</button>
</form>
```

- 각 폼이 **서로 다른 바인딩 경로**를 갖도록 `Profile.*`, `Password.*`로 `asp-for`를 구성
- 서버에서는 `TryValidateModel(객체, "경로")`로 **부분 검증**만 실행

---

## AJAX 폼 전송과 PRG

### → 서버 검증 → JSON/Partial 반환

뷰:

```cshtml
<form id="contact" method="post">
  <textarea asp-for="Input.Message"></textarea>
  <span asp-validation-for="Input.Message"></span>
  <button>보내기</button>
</form>

@section Scripts {
  <partial name="_ValidationScriptsPartial" />
  <script>
    const form = document.getElementById('contact');
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const fd = new FormData(form);
      // 안티포저리 토큰 자동 포함(폼 내 히든 필드)
      const res = await fetch('', { method:'POST', body: fd });
      if (res.redirected) { window.location = res.url; return; } // PRG
      const html = await res.text();
      document.body.innerHTML = html; // 예시: 부분 갱신 전략에 맞게 처리
    });
  </script>
}
```

PageModel(간단 PRG):

```csharp
public async Task<IActionResult> OnPostAsync()
{
    if (!ModelState.IsValid) return Page(); // HTML 재렌더(유효성 표시)
    await _svc.SendAsync(Input);
    return RedirectToPage("Thanks");        // fetch가 redirected 감지
}
```

- AJAX에서도 **서버 검증 + PRG**를 적용하면 새로고침 문제 없이 일관성을 유지.
- 부분 갱신을 원하면 `Partial("_FormBody", Model)` 반환 패턴을 쓴다.

---

## 라우트/쿼리/프래그먼트 제어 심화

```csharp
// 절대 경로 + 라우트값 + 프래그먼트
return RedirectToPage("/Orders/Detail", new { id = 42 }, fragment: "items");

// 동일 페이지 PRG(쿼리 유지)
return RedirectToPage(null, new { filter = CurrentFilter });

// 영역(Area) 사용 시
return RedirectToPage("/Admin/Dashboard", new { area = "Backoffice" });
```

- **주의**: PRG에서 동일 페이지로 리디렉션할 때 **모델 입력값은 초기화**된다. 메시지는 TempData로.

---

## 접근성/UX/보안 체크리스트

**접근성**
- 모든 입력은 `label asp-for`로 연결(스크린리더/NVDA 호환)
- 오류 블록에 `role="alert"`, `aria-live="assertive"` 고려
- 색상 외 텍스트로도 오류 전달(예: `asp-validation-for`)

**UX**
- 서버 검증 실패 시, 포커스를 첫 오류로 이동시키는 스크립트(선택)
- 버튼 더블클릭 방지(클릭 시 비활성화), 서버 측 **멱등성 토큰**으로 중복 제출 방지

**보안**
- **서버 검증** 필수, 클라 검증은 보조
- 오버포스팅 방지(DTO/화이트리스트/`[BindNever]`)
- 본문/파일 크기·항목 수 제한
- 업로드 파일 **시그니처 검사**, 저장 경로에 사용자 입력 사용 금지
- 안티 포저리 토큰: Razor 폼은 자동 포함. 커스텀 AJAX는 토큰 헤더 전송 필요

---

## 통합 예제 — 제품 등록: 선택/태그/파일/PRG/TempData

### 모델

```csharp
public class ProductInput
{
    [Required, StringLength(80)]
    public string Name { get; set; } = "";

    [Range(0, 999999)]
    public decimal Price { get; set; }

    [Range(1, int.MaxValue)]
    public int CategoryId { get; set; }

    public List<string> Tags { get; set; } = new();

    public IFormFile? Image { get; set; }
}
```

### PageModel

```csharp
public class CreateModel : PageModel
{
    [BindProperty] public ProductInput Input { get; set; } = new();

    public SelectList Categories { get; private set; } = default!;
    public List<SelectListItem> AllTags { get; private set; } = default!;

    public void OnGet() => LoadLists();

    public async Task<IActionResult> OnPostAsync()
    {
        LoadLists(); // 실패시 재렌더 위해 다시 구성

        if (Input.Image is { } img)
        {
            if (img.Length > 2 * 1024 * 1024)
                ModelState.AddModelError("Input.Image", "2MB 이하만 허용");
        }

        if (!ModelState.IsValid) return Page();

        await _svc.CreateAsync(Input);
        TempData["SuccessMessage"] = "등록 완료";
        return RedirectToPage("List");
    }

    private void LoadLists()
    {
        Categories = new SelectList(
            new[] { new { Id = 1, Name = "전자" }, new { Id = 2, Name = "도서" } }, "Id", "Name");

        AllTags = new()
        {
            new SelectListItem("신상품", "new"),
            new SelectListItem("인기", "hot"),
            new SelectListItem("할인", "sale")
        };
    }
}
```

### 뷰

```cshtml
@page
@model CreateModel

<h2>제품 등록</h2>

<form method="post" enctype="multipart/form-data">
  <div>
    <label asp-for="Input.Name"></label>
    <input asp-for="Input.Name" />
    <span asp-validation-for="Input.Name"></span>
  </div>

  <div>
    <label asp-for="Input.Price"></label>
    <input asp-for="Input.Price" />
    <span asp-validation-for="Input.Price"></span>
  </div>

  <div>
    <label asp-for="Input.CategoryId">카테고리</label>
    <select asp-for="Input.CategoryId" asp-items="Model.Categories"></select>
    <span asp-validation-for="Input.CategoryId"></span>
  </div>

  <fieldset>
    <legend>태그</legend>
    @for (int i = 0; i < Model.AllTags.Count; i++)
    {
        var t = Model.AllTags[i];
        <label>
          <input type="checkbox" name="Input.Tags" value="@t.Value"
                 checked="@(Model.Input.Tags.Contains(t.Value))" />
          @t.Text
        </label>
    }
  </fieldset>

  <div>
    <label asp-for="Input.Image"></label>
    <input asp-for="Input.Image" type="file" />
    <span asp-validation-for="Input.Image"></span>
  </div>

  <div asp-validation-summary="ModelOnly"></div>

  <button type="submit">등록</button>
</form>

@section Scripts { <partial name="_ValidationScriptsPartial" /> }
```

---

## 테스트 전략(요지)

- **단위**: `Validator.TryValidateObject`로 모델 검증 규칙 검증
- **통합**: `WebApplicationFactory`로 폼 POST → 검증 실패시 재렌더 확인, 성공시 302+Location 및 PRG 흐름 확인
- **보안**: 오버포스팅 방어(예상치 못한 필드가 submit돼도 서버 수용 안 함) 확인
- **파일**: 크기/ContentType/시그니처 테스트

---

## 자주 겪는 문제 & 해결

| 문제 | 원인 | 해결 |
|---|---|---|
| 검증 실패 후 드롭다운/체크박스 항목 사라짐 | OnPost 실패 시 데이터 소스 미복원 | OnPost에서 목록 데이터 **다시** 채우기 |
| 값 수정했는데 화면에 반영 안 됨 | ModelState의 원본 값이 우선 | `ModelState.Remove("경로")` 후 재검증 |
| 새로고침 시 재전송 경고 | PRG 미적용 | 성공 시 `RedirectToPage`로 **반드시** 이동 |
| AJAX에서 토큰 오류 | 안티포저리 헤더 누락 | 폼 내 토큰 읽어 헤더(`RequestVerificationToken`)로 전송 |
| 다중 폼 충돌 | name 경로 중복 | `Profile.*`/`Password.*`처럼 **서로 다른 접두사** 사용 |

---

## 요약

- `OnPost/OnPostAsync`는 **서버 검증을 통과한 데이터만** 처리해야 한다.
- 실패는 `Page()`(입력 유지), 성공은 **PRG** + `RedirectToPage()`(중복 제출 방지).
- `TempData`로 일회성 메시지를 전달하고, 라우트/쿼리/프래그먼트도 `RedirectToPage`로 유연하게 제어.
- 중첩/컬렉션, 파일 업로드, 다중 폼, AJAX까지 **이름 규칙**과 **ModelState**를 제대로 이해하면 깔끔하게 처리된다.
- 오버포스팅, 파일 시그니처, 크기 제한 등 **보안**은 기본값이 아니라 **명시적으로** 챙긴다.

---

## 다음 추천 학습

- 다국어(Localization) 폼 검증 메시지와 날짜/숫자 파싱
- 커스텀 `ValidationAttribute`와 `IValidatableObject`로 도메인 규칙 구현
- 부분 페이지(Partial) + AJAX를 이용한 고성능 폼 UX
- 폼 멱등성 토큰(Idempotency-Key)와 재전송 방지 전략 심화
