---
layout: post
title: 이산수학 - 논리 게이트
date: 2025-07-03 21:20:23 +0900
category: 이산수학
---
# 논리 게이트(Logic Gates)

## 한눈 개요

- **논리 게이트**: 0/1(논리 거짓/참)을 입력받아 **부울(Boolean) 연산**을 수행하는 디지털 회로의 최소 단위.
- **핵심 게이트**: AND, OR, NOT, NAND, NOR, XOR, XNOR.
- **설계 관점**: 기능(진리표/부울식) ↔ 하드웨어(트랜지스터/CMOS·TTL) ↔ 성능(지연/전력/팬인·팬아웃) ↔ 신뢰성(노이즈 마진/메타안정성/해저드).
- **응용**: 산술(가산기), 선택(MUX/디코더), 저장(래치/플립플롭), 제어(인코더/우선순위), 통신(패리티).

---

## 부울 대수 핵심 요약

### 기본 기호

- AND: $$A\land B \equiv AB$$
- OR:  $$A\lor B \equiv A + B$$
- NOT: $$\lnot A \equiv \bar A \equiv A'$$
- XOR: $$A\oplus B \equiv \overline{AB} \cdot \overline{\bar A\,\bar B} \equiv A\bar B + \bar A B$$
- XNOR: $$A \odot B \equiv \overline{A\oplus B} \equiv AB + \bar A \bar B$$

### 자주 쓰는 법칙

- 항등: $$A+0=A,\; A\cdot 1=A$$
- 지배: $$A+1=1,\; A\cdot 0=0$$
- 멱등: $$A+A=A,\; A\cdot A=A$$
- 보수: $$A+\bar A=1,\; A\cdot \bar A=0$$
- 드모르간: $$\overline{A\cdot B}=\bar A + \bar B,\quad \overline{A+B}=\bar A \cdot \bar B$$
- 흡수: $$A + A B = A,\quad A(A+B)=A$$
- 분배: $$A(B+C)=AB+AC,\quad A+BC=(A+B)(A+C)$$

---

## 기본 게이트와 진리표

| 게이트 | 부울식 | 핵심 조건/설명 |
|---|---|---|
| AND | $$Y=AB$$ | 둘 다 1일 때 1 |
| OR  | $$Y=A+B$$ | 하나라도 1이면 1 |
| NOT | $$Y=\bar A$$ | 0↔1 반전 |
| NAND| $$Y=\overline{AB}$$ | AND 후 반전 (**범용**) |
| NOR | $$Y=\overline{A+B}$$ | OR 후 반전 (**범용**) |
| XOR | $$Y=A\bar B+\bar A B$$ | 서로 다르면 1 |
| XNOR| $$Y=AB+\bar A \bar B$$ | 서로 같으면 1 |

**2입력 진리표(요약)**

| A | B | AND | OR | NAND | NOR | XOR | XNOR |
|---|---|----:|---:|-----:|----:|----:|-----:|
| 0 | 0 |  0  |  0 |   1  |  1  |  0  |   1  |
| 0 | 1 |  0  |  1 |   1  |  0  |  1  |   0  |
| 1 | 0 |  0  |  1 |   1  |  0  |  1  |   0  |
| 1 | 1 |  1  |  1 |   0  |  0  |  0  |   1  |

---

## 하드웨어 관점(요약): CMOS·TTL·타이밍·전력

### CMOS 게이트 직관

- **pMOS(PU 네트워크)**: ‘1’을 끌어올리는 역할(활성: 입력=0).
- **nMOS(PD 네트워크)**: ‘0’을 끌어내리는 역할(활성: 입력=1).
- **NAND**: 상부(pMOS) 병렬? → **직렬** (모든 pMOS가 0일 때만 당김), 하부(nMOS) **병렬** 연결이 AND의 보수를 구현.
- **NOR**: 상부(pMOS) **병렬**, 하부(nMOS) **직렬**.

> 실무: 이유 때문에 **NAND가 NOR보다 빠르고 작게** 만들기 쉬움(병렬 nMOS vs 직렬 nMOS).

### 타이밍과 파워

- **전파 지연**: 입력 변동→출력 안정까지 시간. 상승/하강 지연 비대칭 가능.
- **부하 커패시턴스** $$C_L$$, 전원 $$V_{DD}$$, 스위칭 활동률 $$\alpha$$, 주파수 $$f$$에 대해
  **동적 전력**: $$P_{dyn} \approx \alpha C_L V_{DD}^2 f$$
- **정적 전력**: 누설에 기인, 공정/온도/전압 의존.

### 팬인·팬아웃·노이즈

- **팬인**: 게이트 입력 수(과도하면 지연↑).
- **팬아웃**: 한 출력이 구동하는 입력 수(과도하면 지연/왜곡↑).
- **노이즈 마진**: 논리 ‘0/1’ 레벨 간 여유(표준마다 수치 상이). 설계 시 **버퍼링/쉬미트 트리거** 고려.

---

## 범용 게이트(NAND/NOR)로 모든 회로 만들기

### NAND만으로

- NOT: $$\bar A = A \uparrow A$$
- AND: $$AB = \overline{A\uparrow B} = (A\uparrow B)\uparrow(A\uparrow B)$$
- OR: $$A+B = \overline{\bar A \cdot \bar B} = (A\uparrow A)\;\uparrow\;(B\uparrow B)$$
- XOR: 여러 구성 가능(예: 4~5개의 NAND 조합)

### NOR만으로

- NOT: $$\bar A = A \downarrow A$$
- OR/AND는 드모르간 응용으로 구성.

> **셀 라이브러리**는 실무에서 NAND/NOR/인버터 중심. 복잡 연산은 MUX/전달게이트나 조합 최적화로 합성.

---

## 조합 논리 구성 블록

### 멀티플렉서(MUX)

- 2:1 MUX: $$Y = \bar S \cdot D_0 + S \cdot D_1$$
- **XOR 구현**: 입력에 $$D_0=B,\; D_1=\bar B,\; S=A$$ → $$Y=A\oplus B$$

### 디코더/인코더/우선순위 인코더

- 2→4 디코더: 하나의 입력 조합만 활성화.
- 우선순위 인코더: 가장 높은 우선순위의 ‘1’ 위치를 코드로 출력.

### 가산기

- Half Adder:
  $$\text{Sum}=A\oplus B,\quad \text{Carry}=AB$$
- Full Adder:
  $$\text{Sum}=A\oplus B\oplus C_{in},\quad C_{out}=AB + (A\oplus B)C_{in}$$
- **Ripple-carry**: 단순/느림, **Carry Lookahead**: 빠름(논리 복잡↑).

---

## 순차 논리(게이트로 기억 만들기)

### SR 래치(기본 저장소)

- NOR형:
  - $$S=1$$ → Q=1 (셋)
  - $$R=1$$ → Q=0 (리셋)
  - S=R=0 → 유지
  - S=R=1 **금지**(불능 상태)

### D 래치 & D 플립플롭

- D 래치: **Enable=1**일 때 Q←D 투명, **0**일 때 홀드.
- D 플립플롭(엣지 트리거): **클럭 엣지에서만** 샘플링.
  - 타이밍 파라미터: **setup/hold**, **clk→Q**.
  - **메타안정성** 방지: 비동기 신호엔 **2플롭 동기화**.

---

## 논리식 최적화: 대수·K-맵·해저드

### 4변수 예시(요약)

- 셀들을 **그레이 코드** 순서로 배열, 1들을 **1,2,4,8개** 그룹핑하여 **SOP** 최소화.
- **무관 조건(don’t care)**은 유연하게 포함하여 항 줄이기.

### 해저드(Glitch)

- **정적-1 해저드**: 이상적으로 1→1이어야 하나, 중간에 0 글리치.
- 원인: **경로 지연 불균형**.
- 해결: K-맵에서 **인접 그룹 추가**(커버 확장) 또는 **리타이밍/버퍼링**.

---

## 실전 설계 팁(압축)

- **NAND 우선** 합성: 면적·지연 이점.
- **팬아웃·부하 관리**: 버퍼 삽입/수준분할.
- **타이밍 여유 확보**: **setup/hold** 모두 양수되게.
- **전력**: $$P\propto \alpha C_L V^2 f$$ → **게이트 수/전환율/전압** 줄이고, **클록 게이팅** 활용.
- **검증**: **정합성(등가성) 체크**, **정적 타이밍 분석(STA)**, **식별된 해저드** 제거.

---

## 파이썬 실습 — 게이트 시뮬레이션 & 미니 합성

### 기본 게이트/진리표 프린터

```python
# 기본 게이트 정의

def AND(a, b): return a & b
def OR(a, b):  return a | b
def NOT(a):    return 1 - a
def NAND(a, b): return NOT(AND(a, b))
def NOR(a, b):  return NOT(OR(a, b))
def XOR(a, b):  return a ^ b
def XNOR(a, b): return NOT(XOR(a, b))

def truth_table_2in(f, name):
    print(f"== {name} ==")
    print("A B | Y")
    for a in (0,1):
        for b in (0,1):
            print(a, b, "|", f(a,b))
    print()

# 진리표 출력

truth_table_2in(AND,  "AND")
truth_table_2in(OR,   "OR")
truth_table_2in(NAND, "NAND")
truth_table_2in(NOR,  "NOR")
truth_table_2in(XOR,  "XOR")
truth_table_2in(XNOR, "XNOR")
```

### NAND만으로 XOR 만들기(참고 구성)

```python
# NAND (B NAND T1), where T1 = A NAND B, plus self-NAND inverters

def NAND_XOR(a, b):
    t1 = NAND(a, b)          # ~(ab)
    a_ = NAND(a, a)          # ~a
    b_ = NAND(b, b)          # ~b
    t2 = NAND(a, t1)         # ~(a & ~(ab)) = ~(a & (~a|~b)) ...
    t3 = NAND(b, t1)
    y  = NAND(t2, t3)        # XOR
    return y

for a in (0,1):
    for b in (0,1):
        print(a, b, XOR(a,b), NAND_XOR(a,b))
```

### 1비트 하프/풀 가산기

```python
def half_adder(a, b):
    s = XOR(a, b)
    c = AND(a, b)
    return s, c

def full_adder(a, b, cin):
    s1, c1 = half_adder(a, b)
    s2, c2 = half_adder(s1, cin)
    cout = OR(c1, c2)
    return s2, cout

# 테스트

for a in (0,1):
    for b in (0,1):
        for cin in (0,1):
            s, c = full_adder(a,b,cin)
            print(f"{a}+{b}+cin={cin} -> sum={s} carry={c}")
```

### 2:1 MUX로 XOR 구현(선택 신호= A)

```python
def MUX2(d0, d1, s):
    # Y = (~s & d0) | (s & d1)
    return OR(AND(NOT(s), d0), AND(s, d1))

def XOR_via_mux(a, b):
    # a=0 -> pass b ; a=1 -> pass ~b
    return MUX2(b, NOT(b), a)

for a in (0,1):
    for b in (0,1):
        print(a, b, XOR(a,b), XOR_via_mux(a,b))
```

### 간단 지연 모델 이벤트 시뮬레이션(교육용)

```python
# 간단 이벤트 구동: 각 게이트에 고정 지연 td를 둔다(상대 비교용).

from collections import defaultdict, deque

class Wire:
    def __init__(self, name, init=0):
        self.name = name
        self.v = init
        self.listeners = []  # (gate, input_index)

class Gate:
    def __init__(self, typ, inputs, output, td=1.0):
        self.typ = typ
        self.ins = inputs
        self.out = output
        self.td  = td
    def eval(self):
        vals = [w.v for w in self.ins]
        if self.typ == "AND": y = vals[0] & vals[1]
        elif self.typ == "OR": y = vals[0] | vals[1]
        elif self.typ == "NOT": y = 1 - vals[0]
        elif self.typ == "XOR": y = vals[0] ^ vals[1]
        elif self.typ == "NAND": y = 1 - (vals[0] & vals[1])
        elif self.typ == "NOR":  y = 1 - (vals[0] | vals[1])
        else: raise ValueError("unknown")
        return y

def simulate(gates, events):
    # events: list of (time, wire, value)
    t = 0.0
    q = deque(sorted(events))
    timeline = []
    while q:
        t, w, val = q.popleft()
        if w.v == val:
            continue
        w.v = val
        timeline.append((t, w.name, val))
        # notify
        for g,_ in w.listeners:
            y = g.eval()
            if g.out.v != y:
                q.append((t+g.td, g.out, y))
    return timeline

# NAND (~A NAND B)를 구조화해 지연 비교

A, B = Wire("A"), Wire("B")
nA, nB = Wire("nA"), Wire("nB")
t1, t2 = Wire("t1"), Wire("t2")
Y = Wire("Y")
g1 = Gate("NOT", [A], nA, td=0.5)
g2 = Gate("NOT", [B], nB, td=0.5)
g3 = Gate("NAND", [A, nB], t1, td=1.0)
g4 = Gate("NAND", [nA, B], t2, td=1.0)
g5 = Gate("NAND", [t1, t2], Y, td=1.0)

# 연결 리스너 등록

for g in (g1,g2,g3,g4,g5):
    for w in g.ins:
        w.listeners.append((g,0))

# 이벤트: t=0에 A=0,B=0, t=2에 A=1 펄스

timeline = simulate([g1,g2,g3,g4,g5],
                    [(0.0,A,0),(0.0,B,0),
                     (2.0,A,1),
                     (5.0,B,1),
                     (7.0,A,0)])
for ev in timeline:
    print(ev)
```

> 위 미니 시뮬레이터는 **해저드 관찰**(경로 지연 불일치) 교육에 유용합니다.

---

## 간단 Verilog 예시(참고)

> 실제 합성 환경에서는 **표준 셀 라이브러리**와 **합성 제약(SDC)**, **STA**가 필수입니다.

```verilog
// 2:1 MUX
module mux2 (input wire d0, d1, s, output wire y);
  assign y = (~s & d0) | (s & d1);
endmodule

// Half Adder
module half_adder (input wire a, b, output wire sum, carry);
  assign sum   = a ^ b;
  assign carry = a & b;
endmodule

// SR Latch (NOR형) - 교육용, 실제 회로는 금지 입력 회피 설계 필요
module sr_latch (input wire S, R, output wire Q, Qn);
  assign Q  = ~(R | Qn);
  assign Qn = ~(S | Q);
endmodule

// D Flip-Flop (포지티브 엣지, 동기식 리셋)
module dff (input wire clk, rstn, d, output reg q);
  always @(posedge clk) begin
    if (!rstn) q <= 1'b0;
    else       q <= d;
  end
endmodule
```

---

## 실전 체크리스트

- [ ] 기능 검증: 진리표/테스트벤치/랜덤 자극.
- [ ] 최적화: K-맵/대수/도구 최적화(공통 인수, 공유, MUX화).
- [ ] 해저드 점검: 경로 지연 불균형 → 커버 확장/버퍼/리타이밍.
- [ ] 타이밍: setup/hold, clk→Q, 스큐/지터, 팬아웃 적정.
- [ ] 전력: 스위칭 활동률, 클록 게이팅, 전압/주파수 관리.
- [ ] 신뢰성: 노이즈 마진, 슈미트 트리거, 비동기 입력 2플롭 동기화.
- [ ] DFT/테스트: 스캔 체인, 관측성/제어성.

---

## 연습 문제

1) **NAND만으로** XNOR를 구현하라(게이트 수 최소화 시도).
2) **K-맵**으로 $$F(A,B,C)=\Sigma m(1,2,5,6)$$ 최소화하고 SOP/POS를 제시하라.
3) SR 래치에 **S=R=1**이 위험한 이유와 D 래치/플립플롭에서 이를 어떻게 회피하는지 설명하라.
4) **Ripple vs CLA** 가산기의 지연과 면적/전력 트레이드오프를 비교하라.
5) **정적-1 해저드**가 발생하는 3입력 SOP 회로 예를 만들고 해저드 제거를 위한 항을 추가하라.

---

## 요약

- **논리 게이트**는 디지털 시스템의 알파이자 오메가.
- **NAND/NOR 범용성**과 **드모르간**을 축으로 모든 논리를 합성 가능.
- **현실 회로**는 **타이밍/전력/노이즈/해저드** 제약과 싸우는 공학.
- 교육/실습용 코드(파이썬/Verilog)로 **기능→타이밍→신뢰성**까지 작은 스케일부터 체득하세요.
