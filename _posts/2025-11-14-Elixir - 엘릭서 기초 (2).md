---
layout: post
title: Elixir - 엘릭서 기초 (2)
date: 2025-11-14 18:25:23 +0900
category: Elixir
---
# 엘릭서 4: 맵, 바이너리, 시간, 이름 규칙, 스코프 완전 정리

## _4.5 맵 (Map)

맵은 엘릭서에서 **동적 구조**를 표현하는 핵심 타입이다.

- **키/값 사전**이며,
- **불변**이고,
- 내부적으로는 **해시 트라이(HAMT)** 계열 구조를 사용해
  **구조적 공유(Structural Sharing)** 로 갱신 비용을 줄인다.

키는 어떤 타입이든 가능하지만, 실무에서는 다음 두 가지가 대부분이다.

- **atom 키**: `%{name: "Kim", points: 10}`
- **문자열 키**: `%{"name" => "Kim", "points" => 10}`

API 경계나 JSON과의 매핑이 중요하면 문자열 키,
내부 도메인 모델링에는 atom 키/구조체를 많이 쓴다.

---

### 생성·조회·갱신 기본기

#### 리터럴 생성과 조회

```elixir
iex> m = %{name: "Kim", points: 10}
%{name: "Kim", points: 10}

# atom 키일 때만 dot 접근 가능

iex> m.name
"Kim"

# 일반 조회

iex> Map.get(m, :points)
10

# 인덱스 접근: 없으면 nil

iex> m[:tier]
nil

# 기본값 지정

iex> Map.get(m, :tier, :bronze)
:bronze
```

- `m.name` 형태의 dot 접근은 **atom 키**일 때만 가능하다.
- 문자열 키, 숫자 키 등에는 dot 접근이 불가능하므로 `Map.get/3` 또는 `m[key]`를 사용한다.

#### 갱신: 새 맵 반환

```elixir
iex> m = %{name: "Kim", points: 10}

# 기존 키만 업데이트 (없으면 KeyError)

iex> m2 = %{m | points: 11}
%{name: "Kim", points: 11}

# 새 키 추가

iex> m3 = Map.put(m, :tier, :gold)
%{name: "Kim", points: 10, tier: :gold}

# 여러 키 한 번에 업데이트

iex> m4 = Map.merge(m3, %{points: 20, active: true})
%{name: "Kim", points: 20, tier: :gold, active: true}
```

- `%{m | k: v}` 구문은 **해당 키가 반드시 존재**해야 한다.
  - 없으면 `KeyError`가 발생하므로, “이 키가 이미 있다고 가정하는 코드”에만 써야 한다.
- 새 키를 추가하고 싶다면 `Map.put/3` 또는 `Map.merge/2`를 사용한다.

#### 존재 여부 검사

```elixir
iex> Map.has_key?(m, :name)
true

iex> Map.has_key?(m, :tier)
false
```

맵에 어떤 키가 “정말 있는지”와
`nil` 값이 들어 있는지 구분하고 싶을 때 필수다.

---

### 패턴매칭으로 “필수 키” 강제

맵은 **패턴매칭**에서 매우 강력하다.
“이 키는 반드시 있어야 한다”는 계약을 **패턴으로 표현**할 수 있다.

```elixir
iex> %{name: name, points: p} =
...>   %{name: "Kim", points: 10, tier: :gold}
%{name: "Kim", points: 10, tier: :gold}

iex> name
"Kim"
iex> p
10

iex> %{name: _} = %{points: 10}
** (MatchError) no match of right hand side value: %{points: 10}
```

- 패턴에 쓴 키는 **존재해야 한다**. 없으면 `MatchError`.
- “필수 필드가 없으면 바로 터져야 하는 상황”에서는 의도적으로 이렇게 매칭을 걸어 두면
  **버그가 조용히 지나가지 않는다.**

실전 예:

```elixir
def handle_user(%{id: id, email: email} = user) do
  # id, email 필수
  {:ok, user, "User #{id} / #{email}"}
end
```

- JSON/DB에서 데이터를 받아서 엮을 때,
  필수 필드는 맵 패턴으로 **“계약”을 박아두는 습관**이 유용하다.

---

### — 2장에서 이어지는 규칙

키를 **변수 값**으로 쓰고 싶다면 반드시 핀(`^`)으로 **현재 값을 고정**해야 한다.

```elixir
iex> k = :name
:name

iex> %{^k => v} = %{name: "Lee", points: 5}
%{name: "Lee", points: 5}

iex> v
"Lee"
```

- `%{^k => v}`: “키가 `k`의 현재 값이어야 한다”는 뜻이다.
- 핀을 빼고 `%{k => v}` 라고 쓰면, `k`는 **새 키 변수**로 해석된다.

실전 예시: 특정 필드만 검사

```elixir
def fetch_required(map, key) do
  case map do
    %{^key => value} -> {:ok, value}
    _ -> {:error, :missing}
  end
end
```

- 이 패턴은 “동적으로 받은 key가 반드시 있어야 한다”는 계약을 코드에 새긴다.

---

### 깊은 갱신: `put_in/3`, `update_in/3`, `get_and_update_in/3`

중첩 맵/구조체를 다룰 때 단순 `Map.put/3` 체인을 쓰면 코드가 금방 지저분해진다.

```elixir
iex> m = %{user: %{name: "Kim", profile: %{age: 20, city: "Seoul"}}}

# 나쁜 패턴 (중첩 Map.put)

iex> m_bad =
...> m
...> |> Map.update!(:user, fn u ->
...>      Map.update!(u, :profile, fn p ->
...>        Map.put(p, :age, 21)
...>      end)
...>    end)

# 좋은 패턴: put_in/3

iex> m_good = put_in(m, [:user, :profile, :age], 21)
%{user: %{name: "Kim", profile: %{age: 21, city: "Seoul"}}}
```

`update_in/3` 예:

```elixir
iex> update_in(m, [:user, :name], &String.upcase/1)
%{user: %{name: "KIM", profile: %{age: 20, city: "Seoul"}}}
```

`get_and_update_in/3` 예:

```elixir
iex> get_and_update_in(m, [:user, :profile, :age], fn old ->
...>   {old, old + 1}
...> end)
{20, %{user: %{name: "Kim", profile: %{age: 21, city: "Seoul"}}}}
```

- 반환값은 `{old_value, new_map}` 형태.
- 카운터 증가/로그 추출처럼 “이전 값도 필요하고, 갱신된 맵도 필요한” 경우에 적합하다.

이런 **경로 기반 갱신 함수**들은:

1. 가독성이 좋고
2. 내부적으로도 “경로에 해당하는 노드만 새로 만들고 나머지는 공유”하므로
   성능 측면에서도 유리하다.

---

### `Map.merge/2` vs 커스텀 `deep_merge/2`

`Map.merge/2` 는 **얕은 병합**이다. 중첩 맵에서는 하위 구조를 덮어쓴다.

```elixir
iex> a = %{u: %{name: "Kim", age: 20}, tags: [:a]}
iex> b = %{u: %{age: 21}, tags: [:b]}

iex> Map.merge(a, b)
%{u: %{age: 21}, tags: [:b]}
# u.name이 사라진다

```

간단 `deep_merge`를 만들어 보자 (맵-대-맵일 때만 재귀 병합):

```elixir
defmodule Util do
  def deep_merge(a, b) when is_map(a) and is_map(b) do
    Map.merge(a, b, fn _k, v1, v2 ->
      deep_merge(v1, v2)
    end)
  end

  def deep_merge(_a, b), do: b
end

iex> Util.deep_merge(a, b)
%{u: %{name: "Kim", age: 21}, tags: [:b]}
```

- 같은 키에 대해 값이 둘 다 맵이면 **재귀 병합**,
  아니면 오른쪽 값을 우선한다.

#### 리스트 필드 병합 전략

태그/권한 목록처럼 “리스트로 표현된 필드”는 보통 그냥 덮어쓰기보다 **합집합**이 유용하다.

```elixir
def deep_merge_list_union(a, b) when is_list(a) and is_list(b) do
  (a ++ b) |> Enum.uniq()
end
def deep_merge_list_union(_a, b), do: b
```

이를 `Map.merge/3`의 세 번째 인자로 사용할 수도 있다.

---

### Keyword list vs Map — 언제 무엇을 쓸까

#### Keyword list

```elixir
iex> opts = [timeout: 1000, timeout: 2000]
[timeout: 1000, timeout: 2000]

iex> Keyword.get_values(opts, :timeout)
[1000, 2000]
```

특징:

- `[{atom, value}]` 리스트
- **순서 유지**
- **중복 키 허용**
- 대부분 함수에서 **옵션 인자**를 받는 형태로 사용

#### Map

```elixir
iex> config = %{timeout: 2000, retries: 3}
%{timeout: 2000, retries: 3}
```

특징:

- 키-값 사전
- **중복 키 불가**
- 순서는 논리적으로 의미가 약함
- JSON/DB 행/도메인 모델에 적합

**일반적인 가이드**:

- 공용 API/옵션 인자 → Keyword(list)
- 앱 설정/도메인 데이터 → Map / Struct

---

### 구조체(Struct)는 “맵 + 타입 태그”

구조체는 “**맵에 모듈명 태그가 붙은 것**”이다.

```elixir
defmodule User do
  defstruct [:id, :name, points: 0, tags: []]
end

iex> u = %User{id: 1, name: "Kim"}
%User{id: 1, name: "Kim", points: 0, tags: []}

# 구조체 패턴은 타입까지 강제

iex> %User{name: "Kim"} = u
%User{id: 1, name: "Kim", points: 0, tags: []}

iex> %{name: n} = u   # 맵 패턴은 타입을 신경 쓰지 않는다
%User{id: 1, name: "Kim", points: 0, tags: []}
iex> n
"Kim"
```

- 구조체 필드 외의 키를 추가하려 하면 `ArgumentError`.
- 도메인 모델링에서 **“이 맵은 그냥 맵이 아니라 User다”** 라는 의미를 코드에 새긴다.

구조체도 결국 맵이므로 `Map.get/2`, `Map.put/3` 등을 그대로 쓸 수 있다.
다만 **타입 안전성을 살리고 싶다면** 되도록 구조체 생성자/변환 함수를 통해 다루는 것이 좋다.

---

### 맵 성능/모델: 해시 트라이와 구조적 공유

맵은 내부적으로 **해시 트라이** 기반이다.

대략적인 직관:

- 키 개수를 $$n$$ 이라고 할 때, 조회/갱신 비용은
  $$T(n) \approx O(\log n)$$ 이지만, 구현에서 트리의 최대 깊이가 제한되므로
  **실제 체감은 준상수 시간**에 가깝다.
- 갱신 시 전체 맵을 복사하지 않고,
  **경로에 있는 노드만 새로 만들고 나머지는 공유**한다.

맵을 잘 쓰려면:

- “맵 하나에 수십만 개를 몰아넣기”보다,
  **의미 있는 단위별로 맵을 쪼개어 설계**하면 부담을 줄일 수 있다.
- “읽기 많고 쓰기 적은 공유형 데이터”는 ETS와 조합해서 쓰는 것을 고려할 수 있다.

---

## _4.6 바이너리 (Binary / Bitstring)

문자열, 파일, 네트워크 프로토콜, 압축 포맷 등 **모든 바이트/비트 데이터**의 기본 표현이다.

- **binary**: 비트 수가 8의 배수인 bitstring
- **bitstring**: 비트 수가 1 이상인 “비트 시퀀스” 전체를 지칭

보통 문자열, 파일, 소켓은 **binary** 기준으로 다루고,
특수한 프로토콜에서만 “비트 단위(bitstring)”를 건드린다.

---

### 생성·결합·크기

```elixir
iex> b1 = <<0, 1, 2>>
<<0, 1, 2>>

iex> b2 = <<3, 4>>
<<3, 4>>

iex> b1 <> b2
<<0, 1, 2, 3, 4>>

iex> byte_size(<<"A">>)
1

iex> byte_size(<<"한">>)    # UTF-8: 3 bytes
3
```

- `<<>>` 안에서 정수는 **바이트**로 해석된다 (기본).
- 문자열 리터럴 `"..."` 도 결국 UTF-8 바이너리다.

---

### 패턴매칭으로 바이너리 파싱

#### 길이 접두부 + 페이로드

```elixir
defmodule Wire do
  # 16비트 big-endian 길이 + body + 나머지
  def parse(<<len::16, body::binary-size(len), rest::binary>>) do
    {:ok, body, rest}
  end

  def parse(_), do: :incomplete
end

iex> Wire.parse(<<0, 3, "abc", "tail">>)
{:ok, "abc", "tail"}
```

- `len::16` 은 16비트 정수.
- `body::binary-size(len)` 은 `len` 바이트 길이의 바이너리.
- 나머지는 `rest::binary`로 모두 받는다.

#### 비트 단위 파싱

```elixir
iex> <<x::3, y::5>> = <<0b101_10101>>
<<181>>
iex> {x, y}
{5, 21}
```

- `::3`, `::5`는 **비트 단위 길이**.
- 네트워크 헤더처럼 “필드가 비트 단위로 끊어진” 데이터에서 매우 유용하다.

#### 접두/접미 검사

```elixir
iex> <<"PNG", rest::binary>> = File.read!("logo.png")
<<80, 78, 71, ...>>

iex> <<prefix::binary-size(3), id::binary-size(4), "TAIL">> = "ID:XYZTAIL"
"ID:XYZTAIL"
iex> {prefix, id}
{"ID:", "XYZ"}
```

문자열/바이너리의 앞부분을 빠르게 식별하고 싶을 때
바이너리 패턴은 인덱싱보다 훨씬 명확하다.

---

### iodata로 고성능 결합

문자열/바이너리를 단순 `<>` 로 연쇄 결합하면,
매번 새 바이너리를 만들어서 성능이 나빠질 수 있다.

```elixir
def concat_bad(chunks) do
  Enum.reduce(chunks, <<>>, fn chunk, acc -> acc <> chunk end)
end
```

좋은 패턴: **iodata**(바이너리 + 바이트 리스트/중첩 리스트)를 쌓아 두고
마지막에 한 번만 선형화.

```elixir
def concat_good(chunks) do
  chunks
  |> Enum.map(&["[", &1, "]"])    # ["[", "a", "]", "[", "b", "]", ...]
  |> :erlang.iolist_to_binary()
end
```

HTTP 응답 예:

```elixir
defmodule Http do
  def response(body, headers \\ []) do
    [
      "HTTP/1.1 200 OK\r\n",
      Enum.map(headers, fn {k, v} -> [k, ": ", v, "\r\n"] end),
      "\r\n",
      body
    ]
    |> :erlang.iolist_to_binary()
  end
end
```

- 실제 소켓에 쓰는 순간까지 **큰 덩어리를 만들지 않고** 버퍼 트리로 유지하다가,
  보내기 직전에 한 번만 “평탄화”한다.

---

### 바이너리 컴프리헨션

문자열/바이너리에서 조건을 걸고 특정 바이트만 뽑아낼 수 있다.

```elixir
# ASCII 소문자만 필터링

iex> for <<c <- "AbCde!">>, c in ?a..?z, into: <<>>, do: <<c>>
"bde"

# 숫자만 추출

iex> for <<c <- "phone: +1-234-567">>, c in ?0..?9, into: <<>>, do: <<c>>
"1234567"
```

- `into: <<>>` 옵션으로 결과를 새 바이너리로 모은다.

---

### UTF-8 안전한 처리

UTF-8에서는 한 문자가 **여러 바이트**일 수 있다.

```elixir
iex> "한" |> byte_size()
3

iex> "한" |> String.length()
1
```

잘못된 슬라이스:

```elixir
# 이렇게 바이트 단위로 잘라 쓰면 깨진 문자열을 만들 수 있다.

iex> binary_part("한글", 0, 2)
** (ArgumentError) binary_part/3 with UTF-8 binaries should use a multiple of the byte size
```

**문자 단위** 작업은 가능하면 `String` 모듈을 사용하자.

```elixir
iex> String.slice("한글", 0, 1)
"한"

iex> String.codepoints("한글")
["한", "글"]
```

---

### 큰 바이너리와 참조 카운팅

- 64바이트를 넘는 큰 바이너리는 **오프힙**에 저장되고,
- 여러 프로세스가 동일 바이너리를 참조할 수 있다.
- 메시지 전달 시에도 **복사보다 참조 카운트 증가**만 이루어지는 구조다.

실전 패턴:

```elixir
defmodule FileServer do
  def serve(path, client) do
    data = File.read!(path)          # 큰 바이너리
    send(client, {:file, path, data})
  end
end
```

- `data`가 커도, 여러 프로세스에 보내는 비용이 “완전 복사”보다는 훨씬 작다.
- 다만 큰 바이너리의 **작은 일부만 오래 들고 있으면**
  원본 전체가 회수되지 않으므로, 필요한 부분만 새로 복사해 보관하는 전략도 필요할 수 있다.

---

## _4.7 날짜와 시간 (Date / Time / NaiveDateTime / DateTime)

엘릭서는 표준 라이브러리에서 다음 네 가지 구조체를 제공한다.

- `Date`
- `Time`
- `NaiveDateTime`
- `DateTime` (타임존 포함)

모두 **불변 구조체**이며, ISO8601 기반 파싱/포맷/연산을 제공한다.

---

### 생성과 기본 사용

```elixir
iex> d = ~D[2025-11-10]
~D[2025-11-10]

iex> t = ~T[12:34:56]
~T[12:34:56]

iex> nd = NaiveDateTime.new!(d, t)
~N[2025-11-10 12:34:56]

iex> {:ok, dt} = DateTime.from_naive(nd, "Etc/UTC")
{:ok, #DateTime<2025-11-10 12:34:56Z>}
```

- `Date`: 날짜만 (연/월/일)
- `Time`: 시간만 (시/분/초/초의 소수부)
- `NaiveDateTime`: 타임존 없는 날짜+시간
- `DateTime`: 타임존 정보를 가진 날짜+시간

**일반적인 패턴**:

- DB 저장/내부 계산 → `NaiveDateTime`
- 외부 API/표시/타임존 처리가 필요한 경계 → `DateTime`

---

### 파싱과 포맷

ISO8601 파싱:

```elixir
iex> {:ok, d}  = Date.from_iso8601("2025-11-10")
{:ok, ~D[2025-11-10]}

iex> {:ok, nd} = NaiveDateTime.from_iso8601("2025-11-10 12:34:56")
{:ok, ~N[2025-11-10 12:34:56]}

iex> Date.to_iso8601(d)
"2025-11-10"
```

커스텀 포맷:

```elixir
iex> Calendar.strftime(~N[2025-11-10 12:34:56], "%Y/%m/%d %H:%M")
"2025/11/10 12:34"
```

- 날짜/시간을 API 응답/로그에 적을 때 ISO8601 기반 포맷을 사용하면
  언어/플랫폼 간 호환성이 좋다.

---

### 연산과 비교

```elixir
iex> Date.add(~D[2025-11-10], 7)
~D[2025-11-17]

iex> NaiveDateTime.add(~N[2025-11-10 12:00:00], 3600, :second)
~N[2025-11-10 13:00:00]

iex> Date.diff(~D[2025-11-10], ~D[2025-11-01])
9

iex> Date.compare(~D[2025-11-10], ~D[2025-11-09])
:gt
```

- `Date.add/2`: 일 단위 더하기
- `NaiveDateTime.add/3`: 지정 단위(초 등)를 더하기
- `Date.diff/2`: 날짜 차이(일 단위)
- `Date.compare/2`: `:lt`, `:eq`, `:gt`

---

### 타임존 변환과 DST

```elixir
iex> {:ok, utc} =
...> DateTime.new(~D[2025-11-10], ~T[12:00:00], "Etc/UTC")
{:ok, #DateTime<2025-11-10 12:00:00Z>}

iex> DateTime.shift_zone(utc, "Europe/Berlin")
{:ok, #DateTime<2025-11-10 13:00:00+01:00 CET Europe/Berlin>}
```

- 타임존 데이터는 시스템에 탑재된 **IANA 타임존 DB**를 사용한다.
- DST(서머타임) 변환을 정확히 처리해야 하는 서비스라면
  **항상 `DateTime` + `shift_zone/2`** 를 사용해야 한다.

---

### 기간/간격과 수학적 감각

단순히 `초`로만 시간을 다루면 도메인 의미가 깨질 수 있다.

예를 들어:

- “**30일 뒤** 만료”와
- “**한 달 뒤** 만료”는 달력 상에서 결과가 다를 수 있다.

$$
\Delta t = t_2 - t_1
$$

- “캘린더 상의 일수”를 비교하려면 `Date.diff/2` 같은 함수로
  **달력 의미를 유지한 채** 차이를 구해야 한다.

---

## _4.8 이름, 소스 파일, 컨벤션, 연산자

엘릭서는 언어 차원에서 여러 도구를 제공하지만,
코드 가독성/유지보수성은 **이름·파일 구조·연산자 사용 패턴**에 크게 의존한다.

---

### 이름·파일 컨벤션

- 모듈: `CamelCase`
- 파일: `snake_case.ex` / 테스트: `snake_case_test.exs`
- 함수/변수: `snake_case`
- 프로젝트/앱: 보통 `snake_case` (`my_app`)

```elixir
# 파일: lib/my_app/user_controller.ex

defmodule MyApp.UserController do
  @moduledoc "User actions"

  def index(params), do: ...
  def show(params), do: ...

  defp normalize(params), do: ...
end
```

- 공개 함수: `def`
- 비공개(모듈 내부 전용): `defp`
- 모듈 문서: `@moduledoc`, 함수 문서: `@doc`

---

### `?` / `!` 네이밍 규칙

엘릭서 커뮤니티에서 사실상 표준인 규칙:

- **불리언을 반환하는 함수**: `?` 접미사
  - `empty?/1`, `valid?/1`, `admin?/1`
- **예외를 던지는 버전**: `!` 접미사
  - `Map.fetch/2` vs `Map.fetch!/2`
  - `Repo.get/3` vs `Repo.get!/3` (Ecto 예)

```elixir
iex> Map.fetch(%{a: 1}, :a)
{:ok, 1}

iex> Map.fetch(%{a: 1}, :b)
:error

iex> Map.fetch!(%{a: 1}, :b)
** (KeyError) key :b not found in: %{a: 1}
```

- `fetch/2`: 실패를 **값(:error)** 로 표현.
- `fetch!/2`: 실패를 **예외**로 표현.

코드를 읽는 사람 입장에서, 함수 이름만 보고도
“이게 실패하면 예외인지, 값으로 실패를 돌려주는지”를 바로 알 수 있다.

---

### alias / import / require / use

모듈 상단에서 자주 쓰는 네 가지 매크로:

```elixir
defmodule MyApp.Controller do
  alias MyApp.User
  import Plug.Conn
  require Logger
  use MyApp.Web, :controller
end
```

- `alias`: 긴 모듈명을 짧게 줄인다.
  - `alias MyApp.Accounts.User, as: User` (as 생략시 마지막 세그먼트를 사용)
- `import`: 모듈의 함수/매크로를 현재 모듈로 가져온다.
  - 남용하면 “이 함수가 어디서 왔는지” 알기 어려우므로 **필요할 때만**.
- `require`: 매크로를 사용하는 모듈을 컴파일 타임에 요구.
- `use`: 특정 모듈의 `__using__/1` 매크로를 호출해 **코드를 주입**.

실무에서는:

- **핵심 도메인 모듈**은 `alias`,
- **자주 쓰는 헬퍼/DSL**은 `import`/`use`,
- 로깅/매크로는 `require`를 적절히 섞어쓴다.

---

### 주요 연산자와 사용 관례

자주 쓰이는 연산자들:

- 파이프: `|>`
- 매칭: `=`
- 핀: `^`
- 리스트 cons: `|` (리스트 패턴 내부)
- 문자열 결합: `<>`
- 리스트 결합: `++`, `--`
- 비교: `==`, `!=`, `===`, `!==`, `<`, `<=`, `>`, `>=`

파이프 예:

```elixir
"  hello  "
|> String.trim()
|> String.upcase()
|> then(&"[#{&1}]")
```

- 왼쪽 결과를 오른쪽 함수의 **첫 번째 인자**로 넘긴다.
- 함수 인자 순서를 “데이터가 앞에 오도록” 설계하면
  파이프라인이 자연스럽게 이어진다.

---

### 연산자 우선순위 감각

대략적인(전체가 아닌) 우선순위:

1. 단항 `+`, `-`, 함수 캡처 `&`
2. 매칭 `=`, 핀 `^`
3. 비교 `==`, `===`, `<`, `>`
4. 리스트 `++`, `--`
5. 이진 결합 `<>`
6. 파이프 `|>`

의미가 헷갈릴 수 있는 복합식은 **괄호를 적극적으로** 쓰는 게 좋다.

```elixir
# 가독성 나쁨

a |> f == g(b)

# 의도에 따라

(a |> f) == g(b)
a |> (fn x -> x == g(b) end).()
```

---

## _4.9 변수 스코프 (Variable Scope)

엘릭서는 **렉시컬 스코프**를 가진다.
여기에 “**매칭은 재바인딩**”이라는 규칙이 얹혀 있다.

핵심 포인트:

1. 변수는 **매칭당 한 번**만 새로 바인딩된다. (2장에서 다룬 규칙)
2. `if/case/cond/with` 안의 재바인딩은 바깥에 **전파**된다.
3. `fn`, `for`(컴프리헨션) 안의 바인딩은 **새 스코프**를 만든다.

---

### 재바인딩과 같은 이름 두 번 쓰기

```elixir
iex> x = 1
1
iex> x = 2               # 새 매칭, 재바인딩
2

iex> {x, x} = {3, 3}     # 같은 매칭식에서 '같음' 강제
{3, 3}

iex> {x, x} = {3, 4}
** (MatchError) no match of right hand side value: {3, 4}
```

- 한 **매칭식 내부에서** 같은 이름을 두 번 쓰면
  “두 자리가 같아야 한다”는 제약이 된다.
- 매칭식이 **다르면** 같은 이름을 새로 바인딩할 수 있다.

---

### `if/case/cond/with` — 재바인딩이 전파되는 블록

```elixir
iex> x = 1
1

iex> if true do
...>   x = 10
...> end
:ok

iex> x
10
```

- `if` 블록 안에서 `x`를 재바인딩하면,
  블록 바깥에서도 **새 값**이 보인다.

`case`도 마찬가지:

```elixir
iex> y = 0
0

iex> case {:ok, 5} do
...>   {:ok, v} -> y = v * 2
...>   :error   -> :error
...> end
10

iex> y
10
```

`with`도 동일:

```elixir
iex> z = 1
1

iex> with z <- 2, do: z
2

iex> z
2
```

> 정리
> - `if/case/cond/with` 블록은 **같은 렉시컬 스코프** 안에서 돌아간다.
> - 블록 안에서의 재바인딩은 **바깥 변수**를 덮어쓴다.

---

### `fn`(익명 함수)와 컴프리헨션 `for` — 새 스코프 생성

```elixir
iex> a = 1
1

iex> (fn -> a = 20 end).()
:ok

iex> a
1
```

- 익명 함수 내부에서의 바인딩은 **외부에 영향을 주지 않는다**.

`for` 컴프리헨션도 마찬가지:

```elixir
iex> b = 0
0

iex> for b <- [1, 2, 3], do: b * 2
[2, 4, 6]

iex> b
0
```

- 컴프리헨션 내부에서 쓰는 변수는 **내부 스코프 전용**이다.

---

### 가드(when)와 스코프

가드 절의 변수는 **새로 바인딩할 수 없다**.
가드는 **이미 바인딩된 값**을 검사하는 곳이다.

```elixir
def sign(x) when is_integer(x) and x > 0, do: :pos
def sign(x) when is_integer(x) and x < 0, do: :neg
def sign(0), do: :zero
```

- `when` 절 안에서는 `=` 로 매칭을 할 수 없다.
- 가드에서만 허용되는 함수/연산자 집합이 정해져 있다.

---

### `with` 와 스코프 + 패턴

```elixir
def normalize(params) do
  with %{"name" => name} <- params,
       name = String.trim(name),
       true <- name != "" do
    {:ok, name}
  else
    _ -> {:error, :bad_name}
  end
end
```

- `with` 안에서 바인딩한 `name` 은 `do` 블록 안에서 그대로 사용 가능하고,
- 전체 `with` 블록 이후에도 **같은 이름의 변수로 남을 수 있다.**

주의할 점:

```elixir
iex> name = "raw"
"raw"

iex> result =
...>   with name <- "inner", do: name
"inner"

iex> {name, result}
{"inner", "inner"}
```

- `with name <- "inner"` 문장은 `name = "inner"` 매칭과 유사하게
  **외부의 `name`을 재바인딩**한다.

---

### 핀(^)과 스코프 상호작용

외부 스코프의 값을 **패턴에 반영**하려면 반드시 핀을 써야 한다.

```elixir
iex> key = :id
:id

iex> case %{id: 1} do
...>   %{^key => v} -> {:ok, v}
...>   _ -> :error
...> end
{:ok, 1}
```

- `%{^key => v}`: “키가 바깥의 `key` 값(= :id)과 같아야 한다”.

---

### 샤도잉(shadowing)과 가독성

```elixir
def run(x) do
  case x do
    x when is_integer(x) -> x + 1
  end
end
```

- 내부 `x`가 바깥 `x`를 덮어쓰고 있어서,
  코드를 읽는 사람이 “이 `x`가 어느 스코프의 값인지” 헷갈리기 쉽다.

**권장**:

- 다른 이름으로 구분 짓거나,
- 가능한 한 **함수를 짧게** 작성해서 스코프 깊이를 줄이는 것이 좋다.

---

## 실전 예제 모음: 맵·바이너리·시간·스코프를 모두 쓰는 코드

### 바이너리 프레이밍 + 맵 파싱 + iodata 응답

```elixir
defmodule Frame do
  @type t :: %{type: non_neg_integer(), payload: binary()}

  @spec encode(t()) :: binary()
  def encode(%{type: type, payload: bin})
      when is_integer(type) and is_binary(bin) do
    header = <<type::8, byte_size(bin)::16>>
    :erlang.iolist_to_binary([header, bin])
  end

  @spec decode(binary()) ::
          {:ok, t(), binary()} | :incomplete
  def decode(<<type::8, len::16, body::binary-size(len), rest::binary>>) do
    {:ok, %{type: type, payload: body}, rest}
  end

  def decode(_), do: :incomplete
end
```

- 맵으로 프레임 구조를 표현(`type`, `payload`).
- 바이너리 패턴으로 길이/타입 헤더를 파싱.
- iodata를 이용해 효율적 인코딩.

---

### 예약 요청 처리 — 날짜 파싱 + 맵 검증 + `with` 스코프

```elixir
defmodule Booking do
  def normalize(%{"date" => iso, "name" => name} = params) do
    with {:ok, date} <- Date.from_iso8601(iso),
         name = String.trim(name),
         true <- name != "" do
      params
      |> Map.put("date", date)
      |> Map.put("name", name)
    else
      _ -> {:error, :bad_request}
    end
  end

  def normalize(_), do: {:error, :bad_request}
end
```

- 맵 패턴으로 필수 키 `"date"`, `"name"`을 강제.
- `Date.from_iso8601/1`으로 문자열 날짜를 `Date` 구조체로 변환.
- `with` 블록 안에서 재바인딩한 `name` 은 이후 단계에서 사용.

---

### 스코프 헷갈리기 쉬운 예와 안전한 예

```elixir
defmodule ScopeDemo do
  def unsafe(xs) do
    sum = 0

    if xs != [] do
      sum = Enum.sum(xs)   # if 안 재바인딩 → 바깥 sum 덮어씀
    end

    for x <- xs do
      sum = -1             # 새 스코프: 바깥 sum과 무관
      x * 2
    end

    (fn -> sum = 999 end).()  # 새 스코프: 바깥 sum과 무관

    sum
  end

  def safe(xs) do
    base_sum = Enum.sum(xs)

    doubled =
      for x <- xs, do: x * 2  # 외부 변수에 의존하지 않음

    {base_sum, doubled}
  end
end
```

- `unsafe/1`은 스코프를 이해하지 못하면 버그가 숨어들기 좋은 패턴이다.
- `safe/1` 처럼 **각 단계의 입력/출력을 명시적으로 분리**하면
  스코프/재바인딩 문제에서 자유로워진다.

---

## 요약 및 체크리스트

### 맵(Map)

- [ ] 필수 키는 **맵 패턴**으로 강제했는가? (`%{name: name}`)
- [ ] 중첩 갱신은 `put_in/update_in/get_and_update_in`을 사용했는가?
- [ ] 동적 키 매칭에는 `%{^key => v}`처럼 **핀**을 사용했는가?
- [ ] Keyword list와 Map 용도를 구분했는가?
- [ ] 도메인 타입에는 구조체(Struct)를 고려했는가?

### 바이너리(Binary)

- [ ] 프로토콜/헤더/길이 정보는 **바이너리 패턴**으로 파싱했는가?
- [ ] 문자열/바이너리 결합에 iodata를 활용했는가?
- [ ] UTF-8 문자열 조작은 `String` 모듈로 했는가?
- [ ] 큰 바이너리를 불필요하게 잘게 복사하지 않았는가?

### 날짜와 시간(Date/Time)

- [ ] DB/내부 연산에는 `NaiveDateTime`을, 경계에는 `DateTime`을 적절히 썼는가?
- [ ] 날짜 차이는 `Date.diff/2` 등으로 **달력 단위**를 유지했는가?
- [ ] 타임존 변환이 필요한 경우 `shift_zone/2`를 사용했는가?

### 이름/컨벤션/스코프

- [ ] 함수/모듈/파일 이름이 컨벤션에 맞는가?
- [ ] `?`/`!` 네이밍으로 예외 여부/불리언 의미를 드러냈는가?
- [ ] `if/case/with` 안 재바인딩이 바깥으로 전파된다는 걸 알고 작성했는가?
- [ ] `fn`/`for` 내부 바인딩은 외부에 영향을 주지 않는다는 점을 활용했는가?
- [ ] 핀(`^`)을 써서 외부 스코프의 값과 **일치 제약**을 명확히 표현했는가?

이 장에서 다룬 **맵·바이너리·시간·이름·스코프**는 이후 OTP/GenServer/웹 서버/ETL/로그 파이프라인을 구현할 때 “기본 언어력”을 결정짓는 요소들이다.
