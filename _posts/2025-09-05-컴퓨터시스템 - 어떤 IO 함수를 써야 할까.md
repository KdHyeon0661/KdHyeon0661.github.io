---
layout: post
title: 컴퓨터시스템 - 어떤 I/O 함수를 써야 할까
date: 2025-09-05 20:20:23 +0900
category: 컴퓨터시스템
---
# 어떤 I/O 함수를 써야 할까? — 상황별 선택 가이드(UNIX/Linux + C)

> 한 줄 요약: **텍스트/라인 vs 바이너리**, **순차 vs 랜덤**, **단일 쓰레드 vs 이벤트 루프**, **내구성/원자성 요구**, **성능(제로카피/캐시)** 를 축으로 고르면 된다.  
> 아래 표/의사결정 트리/예제로 바로 적용할 수 있게 정리했다.

---

## 0) 초간단 결정표

| 작업/요구 | 추천 함수(우선순) | 핵심 이유/주의 |
|---|---|---|
| 라인 단위 텍스트 I/O(터미널/소켓/파이프) | `getline`/`fgets` + `fputs` 또는 **RIO `rio_readlineb` + `rio_writen`** | 라인 경계/버퍼링/짧은 I/O 대응 |
| 고정 길이 바이너리 읽기/쓰기 | **`read`/`write` + `readn`/`writen` 래퍼**, 또는 **RIO `rio_readn`/`rio_writen`** | 부분 I/O/EINTR 처리 일원화 |
| 여러 버퍼 한 번에 쓰기(헤더+바디) | `writev` | system call 수 감소(Scatter/Gather) |
| 파일 임의 위치에서 동시 접근(멀티스레드) | **`pread`/`pwrite`** | **파일 오프셋 공유 문제 없음** |
| 큰 파일 빠르게 복사(파일→파일) | `copy_file_range` → `sendfile` → `read`/`write` 루프 | 커널 내부 복사/오프로드 활용 |
| 파일→소켓 제로카피 | **`sendfile`** | 커널 내 데이터 경로(속도/CPU↓) |
| 소켓/파이프 이벤트 기반(논블로킹) | `epoll`/`poll` + `read`/`write`/`readv`/`writev` | 준비된 FD만 처리, 바쁜루프 방지 |
| 대용량 랜덤 읽기(참조 위주) | `mmap`(+ `madvise`/`posix_fadvise`) | 포인터 접근·코드 간결, 폴트/에러 주의 |
| DB/스토리지 엔진(캐시 우회) | `pread`/`pwrite` + `O_DIRECT` + 정렬 버퍼 | 페이지캐시 오염↓, 정렬 제약 |
| 다중 작성 로그(라인 원자성 필요) | `open(..., O_APPEND)` + **한 줄=한 번의 `write`** | 오프셋 경쟁 회피(레코드 경계는 직접 보장) |
| 내구성(전원 장애 대비) | `write` + `fsync`/`fdatasync` + `rename` | 안전 갱신 패턴(임시→fsync→원자적 교체) |
| 표준 입출력 간단 처리/포맷팅 | **`stdio`( `fread/fwrite/printf` )** | 버퍼링/이식성/편의 |

> 네트워크/파이프/TTY에서 **`stdio`와 `read`/`write`를 같은 FD에 혼용**하지 말 것(버퍼 꼬임).

---

## 1) 의사결정 트리

1) **데이터 형태는?**  
   - 라인 중심 텍스트 → `getline`/`fgets` + `fputs` 또는 **RIO 라인**  
   - 길이 지정 바이너리 → **`readn`/`writen`(또는 RIO)**

2) **접근 패턴은?**  
   - 순차(큰 블록) → `fread/fwrite` or `read`/`write`(큰 버퍼)  
   - 랜덤(동시성) → **`pread`/`pwrite`**

3) **실행 모델은?**  
   - 동기(간단) → 위 선택 유지  
   - 이벤트 루프/논블로킹 → `epoll` + `read`/`write`/`readv`/`writev` (EAGAIN 처리)

4) **성능/제로카피·시스템콜 최소화가 중요한가?**  
   - 파일→소켓 전송 → **`sendfile`**  
   - 파일→파일 동일 호스트 → `copy_file_range` 우선  
   - 헤더+바디 한 번에 → **`writev`**

5) **내구성/원자성 요구가 있는가?**  
   - 로그/다중 작성 → `O_APPEND` + 한 번의 `write`  
   - 크래시 내구성 → **임시파일에 쓰기 → `fsync` → `rename` → 디렉터리 `fsync`**

6) **메모리 매핑이 유리한가?**  
   - 랜덤 읽기 위주/코드 간결성 중요 → `mmap` (+ `msync`/`munmap` 주의)  
   - 쓰기/내구성/신뢰성 엄격 → 보수적으로 `pread`/`pwrite`

---

## 2) 상황별 정밀 가이드 + 코드 스니펫

### A) 라인 기반 텍스트 프로토콜/REPL

- 간단: `getline`(POSIX) → 동적 버퍼 자동 확장

```c
#include <stdio.h>
int repl(FILE *in, FILE *out){
    char *line = NULL; size_t cap = 0; ssize_t n;
    while ((n = getline(&line, &cap, in)) != -1) {
        if (fwrite(line, 1, (size_t)n, out) != (size_t)n) return -1;
        fflush(out); // REPL은 즉시 반응
    }
    free(line);
    return 0;
}
```

- 견고/소켓 친화: **RIO `rio_readlineb` + `rio_writen`** (부분 I/O/EINTR 방지)

---

### B) 고정 길이 레코드(바이너리)

- **반드시** 정확히 N바이트 읽고 쓰는 래퍼 사용:

```c
ssize_t readn(int fd, void *buf, size_t n);
ssize_t writen(int fd, const void *buf, size_t n);
/* 위는 RIO 챕터에서 소개 — 부분 I/O/EINTR 처리를 캡슐화 */
```

- 네트워크 메시지(길이 헤더 + 본문)는 `readn`으로 길이만큼 정확히 수신.

---

### C) 멀티스레드 랜덤 I/O

- **`pread`/`pwrite`**: 스레드가 같은 FD를 공유해도 **파일 오프셋 경쟁 없음**.

```c
char page[4096];
ssize_t r = pread(fd, page, sizeof page, 4096 * page_idx);
```

---

### D) 헤더+바디 한 번에 쓰기(Scatter/Gather)

```c
#include <sys/uio.h>
struct iovec iov[2] = { {hdr, hlen}, {body, blen} };
ssize_t n = writev(fd, iov, 2);
```

- system call 1회로 끝나 **지연/오버헤드 감소**.

---

### E) 파일→소켓 제로카피

```c
#include <sys/sendfile.h>
off_t off = 0;
ssize_t sent = sendfile(sock, filefd, &off, length);
```

- 유저 공간 복사 없음. **대용량 전송**에서 CPU 사용률↓.

---

### F) 빠른 파일→파일 복사(가능할 때 커널 오프로드)

```c
// 1) 선호: copy_file_range (Linux)
// 실패/미지원 시 2) sendfile(파일→파일) 또는 3) read/write 루프
```

루프 폴백(견고한 기본형):

```c
char buf[1<<20];
for (;;) {
  ssize_t r = read(src, buf, sizeof buf);
  if (r == 0) break;
  if (r < 0) { if (errno==EINTR) continue; return -1; }
  ssize_t w = 0;
  while (w < r) {
    ssize_t k = write(dst, buf+w, (size_t)(r-w));
    if (k < 0) { if (errno==EINTR) continue; return -1; }
    w += k;
  }
}
```

---

### G) 이벤트 루프/논블로킹

- FD를 `O_NONBLOCK`으로 설정 → `epoll`로 readiness 감지 → 준비된 만큼 `read`/`write`(또는 `readv`/`writev`).
- **`EAGAIN/EWOULDBLOCK`** 는 에러 아님. 다음 이벤트까지 대기.

---

### H) `mmap`이 어울릴 때/주의할 때

**장점**
- 포인터 접근(코드 간결), 랜덤 읽기 위주에 유리, 커널 페이지 캐시 재사용

**주의**
- 쓰기 내구성: `msync` 필요
- 파일 크기 변경/트렁크 → **SIGBUS 위험**
- 주소 공간 제약/폴트 오버헤드

```c
void *p = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
/* 사용 후 munmap(p, len) */
```

---

### I) 로그/다중 작성자

- `open(..., O_APPEND)` + **라인 하나를 한 번의 `write`** 로 보냄(레코드 경계 직접 보장).
- 강한 내구성 필요 시 **버스트 쓰기 + `fsync`(주기/구간별)** 전략.

---

## 3) `stdio` vs 저수준 I/O 선택 요령

| 항목 | `stdio` (`fread/fwrite/printf`) | 저수준 (`read/write/pread/...`) |
|---|---|---|
| 장점 | 버퍼링/포맷팅/간단 코드 | 미세 제어, 논블로킹/벡터/제로카피 |
| 대상 | 파일/터미널(순차) | 파일/소켓/파이프 전부, 이벤트 루프 |
| 혼용 | 동일 FD에 섞어 쓰지 말 것 | 필요 시 한쪽만 사용 |
| 라인 I/O | `getline`/`fgets` 간편 | RIO 라인 추천(소켓 친화) |

> **소켓/파이프**는 보통 **저수준 I/O + RIO**가 더 안전(부분 I/O/신호 대응).

---

## 4) 내구성/원자성 요구 체크리스트

- [ ] 다중 작성 → `O_APPEND` + “한 레코드=한 번의 write”  
- [ ] 크래시 저항 → 임시파일에 기록 → `fsync(tmp)` → `rename`(동일 FS) → `fsync(dir)`  
- [ ] `close`의 반환값 확인(지연된 쓰기 오류가 여기서 보고될 수 있음)

---

## 5) 성능·캐시·힌트

- **버퍼 크기**: 4KB~1MB 사이 실측으로 결정(작업 부하 의존)
- **순차/랜덤 힌트**: `posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL|RANDOM)`
- **대형 I/O**: `readv/writev`, 파일 전송은 `copy_file_range`/`sendfile` 우선

---

## 6) 피해야 할 안티 패턴

- `scanf("%s")`/`gets`류(경계 없음) 사용 → **`getline`**/길이 지정 `fgets` 사용
- 소켓에서 `stdio`와 `write` 혼용 → 출력 순서/버퍼 꼬임
- 멀티스레드가 동일 FD로 `lseek+read` → **경쟁**(→ `pread`)
- 부분 쓰기 무시 → **`writen`** 패턴 필수
- 라인 길이 무한 신뢰 → 상한/잘림 처리

---

## 7) 최종 요약(포켓 가이드)

- **텍스트/라인**: `getline` or RIO 라인  
- **바이너리 N바이트 정확히**: `readn/writen`(또는 RIO)  
- **동시 랜덤**: `pread/pwrite`  
- **여러 버퍼 한 번에**: `writev`  
- **파일→소켓**: `sendfile`  
- **파일→파일**: `copy_file_range` ▶︎ `sendfile` ▶︎ `read/write`  
- **논블로킹**: `epoll` + `read`/`write`  
- **대용량 랜덤 읽기/간결성**: `mmap`(주의 포함)  
- **로그/다중 작성**: `O_APPEND` + 한 번의 `write`  
- **내구성**: `fsync` + 원자적 `rename`