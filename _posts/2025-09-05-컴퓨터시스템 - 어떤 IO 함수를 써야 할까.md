---
layout: post
title: 컴퓨터시스템 - 어떤 I/O 함수를 써야 할까
date: 2025-09-05 20:20:23 +0900
category: 컴퓨터시스템
---
# 어떤 I/O 함수를 써야 할까?

## 0. 초간단 결정표

| 작업/요구 | 추천 함수(우선순) | 핵심 이유/주의 |
|---|---|---|
| **라인 텍스트 I/O**(터미널/소켓/파이프) | `getline`/`fgets` + `fputs` 또는 **RIO `rio_readlineb` + `rio_writen`** | 라인 경계·버퍼링·짧은 I/O·`EINTR` 대응 |
| **고정 길이 바이너리** | **`read`/`write` + `readn`/`writen` 래퍼**(또는 RIO `rio_readn/ rio_writen`) | 부분 I/O·`EINTR` 캡슐화 |
| **헤더+바디 한 번에** | **`writev`** / `readv` | system call 수 감소(Scatter/Gather) |
| **랜덤 접근(멀티스레드)** | **`pread`/`pwrite`** | 공유 FD의 파일 오프셋 경쟁 없음 |
| **파일→소켓 제로카피** | **`sendfile`** | 커널 내 복사 경로(CPU↓, 속도↑) |
| **파일↔파일 빠른 복사** | `copy_file_range` ▶ `sendfile` ▶ `read/write` 루프 | 오프로드/커널 내 복사 활용, 폴백 확보 |
| **논블로킹 이벤트 루프** | `epoll`/`poll` + `read`/`write`/`readv`/`writev` | 준비된 FD만 처리(바쁜 루프 방지) |
| **대용량 랜덤 읽기(참조 위주)** | `mmap` + `madvise`/`posix_fadvise` | 포인터 접근, 코드 간결(폴트/동기화 주의) |
| **페이지캐시 우회(DB/스토리지)** | `pread`/`pwrite` + `O_DIRECT`(정렬 버퍼) | 캐시 오염↓, 정렬 제약·에러 처리 강화 |
| **다중 작성 로그** | `open(..., O_APPEND)` + **한 줄=한 번의 `write`** | 오프셋 경쟁 회피(레코드 경계는 직접 보장) |
| **내구성(크래시/전원 장애)** | `write` + `fsync/fdatasync` + **`rename` 원자 교체** | 임시→fsync→rename→디렉터리 fsync |
| **간단 포맷팅/순차 파일** | `stdio`(`fread/fwrite/printf`) | 편의·이식성(혼용 금지 규칙 유념) |

> **주의**: 같은 FD에 **`stdio`와 `read/write` 혼용 금지**(버퍼 꼬임). 혼용 시 철저히 `fflush`/`fsync` 동기화, 가능하면 **한쪽만 사용**.

---

## 1. 의사결정 트리

1) **데이터 형태?**
   - 라인 중심 텍스트 → `getline/fgets` + `fputs` 또는 **RIO 라인**
   - 길이 지정 바이너리 → **`readn/writen`(또는 RIO)**

2) **접근 패턴?**
   - 순차(큰 블록) → `fread/fwrite` 또는 `read/write`(큰 버퍼)
   - 랜덤(동시성) → **`pread/pwrite`**

3) **실행 모델?**
   - 동기(간단) → 위 선택 유지
   - 이벤트 루프/논블로킹 → `epoll` + `read/write/readv/writev` (`EAGAIN` 정상 경로)

4) **성능 중점?**
   - 파일→소켓 → **`sendfile`**
   - 파일↔파일 → `copy_file_range` 우선
   - 헤더+바디 → **`writev`**

5) **내구성/원자성?**
   - 다중 작성 로그 → `O_APPEND` + “한 레코드=한 번의 `write`”
   - 크래시 저항 → 임시파일→`fsync`→`rename`→**디렉터리 `fsync`**

6) **`mmap`이 더 낫나?**
   - 랜덤 읽기 위주·코드 간결 → `mmap`(+ `msync/munmap` 주의)
   - 강한 내구성/오류 제어 → `pread/pwrite`

---

## 2. 상황별 정밀 가이드 + 코드 스니펫

### A) 라인 기반 텍스트(터미널/소켓/파이프)

**간단/이식성**: `getline` (동적 버퍼 자동 확장)

```c
#include <stdio.h>
int repl(FILE *in, FILE *out){
    char *line = NULL; size_t cap = 0; ssize_t n;
    while ((n = getline(&line, &cap, in)) != -1) {
        if (fwrite(line, 1, (size_t)n, out) != (size_t)n) return -1;
        fflush(out); // REPL 즉시 반응
    }
    free(line);
    return 0;
}
```

**견고/소켓 친화**: **RIO** (`rio_readlineb` + `rio_writen`) — 부분 I/O/`EINTR` 캡슐화.
(이전 RIO 편의 구현을 그대로 사용)

---

### B) 고정 길이 레코드(바이너리)

**정확히 N바이트**를 읽고/쓰는 래퍼는 필수:

```c
// readn/writen: 부분 I/O/ EINTR 처리(간략형)
ssize_t readn(int fd, void *buf, size_t n){
    size_t left=n; char *p=buf; while(left){
        ssize_t r=read(fd,p,left);
        if(r>0){ left-=r; p+=r; }
        else if(r==0) break;
        else if(errno==EINTR) continue;
        else return -1;
    } return (ssize_t)(n-left);
}
ssize_t writen(int fd, const void *buf, size_t n){
    size_t left=n; const char *p=buf; while(left){
        ssize_t w=write(fd,p,left);
        if(w>0){ left-=w; p+=w; }
        else if(w<0 && errno==EINTR) continue;
        else if(w<0 && (errno==EAGAIN||errno==EWOULDBLOCK)) continue;
        else return -1;
    } return (ssize_t)n;
}
```

메시지 프레이밍(길이 헤더 + 본문)에서 특히 유용.

---

### C) 멀티스레드 랜덤 I/O — **`pread/pwrite`**

공유 FD의 **파일 오프셋 경쟁** 없이 위치 지정:

```c
char page[4096];
off_t off = 4096LL * page_idx;
ssize_t r = pread(fd, page, sizeof page, off);
```

- 스레드마다 `lseek` 하지 말 것(경쟁).
- 64비트 파일 지원: **`-D_FILE_OFFSET_BITS=64`** 사용.

---

### D) 여러 버퍼 한 번에 — **벡터 I/O**

헤더+바디 **한 번의 syscall**:

```c
#include <sys/uio.h>
struct iovec iov[2] = { {hdr, hlen}, {body, blen} };
ssize_t n = writev(fd, iov, 2);
```

읽기에도 `readv`/`preadv` 사용 가능(파싱 경계 맞추기 좋음).

---

### E) 이벤트 루프(논블로킹) — `epoll` 기본형

```c
#include <sys/epoll.h>
#include <fcntl.h>

static void set_nonblock(int fd){
    int fl = fcntl(fd, F_GETFL);
    fcntl(fd, F_SETFL, fl | O_NONBLOCK);
}

int ep = epoll_create1(0);
struct epoll_event ev = { .events = EPOLLIN|EPOLLOUT|EPOLLET, .data.fd = sock };
epoll_ctl(ep, EPOLL_CTL_ADD, sock, &ev);

for(;;){
    struct epoll_event evs[128];
    int n = epoll_wait(ep, evs, 128, -1);
    for(int i=0;i<n;i++){
        int fd = evs[i].data.fd;
        if (evs[i].events & EPOLLIN) {
            for(;;){
                char buf[8192]; ssize_t r = read(fd, buf, sizeof buf);
                if (r>0) /* 처리 */;
                else if (r==0) { /* EOF */ break; }
                else if (errno==EAGAIN||errno==EWOULDBLOCK) break;
                else /* 오류 */;
            }
        }
        if (evs[i].events & EPOLLOUT) {
            /* 송신 버퍼에 남은 데이터 write (부분 쓰기 처리) */
        }
    }
}
```

- **규칙**: `EAGAIN/EWOULDBLOCK`은 정상. 다음 이벤트까지 대기.
- `write`도 **부분 쓰기**를 루프로 처리.

---

### F) 파일→소켓 제로카피 — **`sendfile`**

```c
#include <sys/sendfile.h>

off_t off = 0; // 혹은 NULL(내부 오프셋 사용)
ssize_t sent = sendfile(sock, filefd, &off, length);
```

- TLS 소켓에는 직접 못 씀(커널 바깥 암호화). 이때는 `sendfile` 불가 → `read+write` 또는 TLS 오프로딩 계층 필요.
- 전송 중 시그널·윈도우 크기 제한 등으로 **부분 전송** 가능 → 루프 필수.

---

### G) 파일↔파일 빠른 복사 — **`copy_file_range`** 폴백

```c
// 1) copy_file_range 사용
ssize_t copy_range(int in, int out, size_t len){
    size_t left = len;
    while (left){
        ssize_t n = copy_file_range(in, NULL, out, NULL, left, 0);
        if (n > 0) left -= n;
        else if (n == 0) break; // EOF
        else if (errno == EINTR) continue;
        else return -1;
    }
    return (ssize_t)(len - left);
}
```

- **폴백 순서**: `copy_file_range` ▶ `sendfile`(파일→파일) ▶ `read/write` 루프.
- 파일시스템/커널에 따라 `-1, EXDEV`(교차 FS) 등 반환 가능 → **폴백 구현**이 견고.

---

### H) `mmap` — 랜덤 읽기 위주·코드 간결

```c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int fd = open(path, O_RDONLY);
struct stat st; fstat(fd, &st);
size_t len = st.st_size;

void *p = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
if (p == MAP_FAILED) /* 오류 */;
close(fd); // 매핑이 FD를 참조하므로 여기서 닫아도 됨

/* p를 바이트 배열처럼 접근 */
munmap(p, len);
```

- 쓰기 시 `msync` 필요, 파일 크기 변경/트렁크 상태에서 접근하면 **SIGBUS** 위험.
- 아주 큰 파일은 **페이지 폴트/워크셋/NUMA** 고려.

---

### I) 페이지캐시 우회 — **`O_DIRECT`**(+ 정렬 버퍼)

```c
void *buf; posix_memalign(&buf, 4096, 4096); // 정렬
int fd = open("data.bin", O_RDONLY|O_DIRECT);
ssize_t n = pread(fd, buf, 4096, 0);
```

- **정렬 제약**: 버퍼 주소·크기·오프셋이 디스크 블록(보통 512B/4KB) 배수.
- 커널 버전·FS별 제약 상이 → **오류 처리** 강화.
- DB/스토리지 엔진처럼 **캐시 관리 자체 수행**할 때 유리.

---

### J) 로그/다중 작성자 — `O_APPEND` + **한 번의 `write`**

```c
int fd = open("app.log", O_WRONLY|O_APPEND|O_CLOEXEC|O_CREAT, 0644);
const char *line = "2025-11-12T16:00Z started\n";
write(fd, line, strlen(line)); // 한 레코드를 한 번의 write로
```

- 정규 파일에서 레코드 원자성은 **표준 보장 아님**(단, `O_APPEND`는 오프셋 원자 업데이트를 보장).
- **파이프/소켓**: `PIPE_BUF`(보통 4096) 이하 쓰기는 **원자적**.

---

### K) 내구성(크래시/전원 장애) — **임시→fsync→rename**

```c
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

int atomic_replace(const char *dir, const char *tmp, const char *dst,
                   const void *data, size_t n)
{
    int dfd = open(dir, O_RDONLY|O_DIRECTORY|O_CLOEXEC);
    if (dfd < 0) return -1;

    int tfd = openat(dfd, tmp, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 0644);
    if (tfd < 0) { close(dfd); return -1; }

    if (writen(tfd, data, n) != (ssize_t)n) { close(tfd); close(dfd); return -1; }
    if (fsync(tfd) < 0) { close(tfd); close(dfd); return -1; }
    if (close(tfd) < 0) { close(dfd); return -1; }

    if (renameat(dfd, tmp, dfd, dst) < 0) { close(dfd); return -1; }
    if (fsync(dfd) < 0) { close(dfd); return -1; }

    return close(dfd);
}
```

- **규칙**: 파일 `fsync` + `rename` + **디렉터리 `fsync`** → 전원 장애에도 **경로 엔트리**가 보존.

---

### L) `stdio` vs 저수준 I/O — 선택 요령

| 항목 | `stdio` (`fread/fwrite/printf`) | 저수준 (`read/write/pread/...`) |
|---|---|---|
| 장점 | 버퍼링·포맷팅·간단 코드 | 미세 제어, 논블로킹·벡터·제로카피 |
| 대상 | 파일/터미널(순차) | 파일/소켓/파이프 전부 |
| 혼용 | **같은 FD 혼용 금지** | 필요 시 한쪽만 |
| 라인 I/O | `getline/fgets` 편함 | RIO 라인 추천(소켓 친화) |

- 혼용 시 **`fflush` 후 `fsync(fileno(fp))`**까지 해도 여전히 순서 섞임 리스크 → **피하자**.

---

## 3. 성능·캐시·힌트

- **버퍼 크기**: 4KB~1MB에서 워크로드별 실측. 너무 작으면 syscall 오버헤드↑, 너무 크면 캐시 오염.
- **접근 힌트**:
  ```c
  posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL /* or RANDOM */);
  ```
- **벡터 I/O**: `writev/readv`로 작은 조각 다발 처리.
- **비복사 경로**: 파일→소켓 `sendfile`, 파일↔파일 `copy_file_range`.
- **재지정/파이프**: 고성능 로그 분기엔 `tee`/`splice`도 고려.

**대략적 성능 모델(개념)**
$$
T \approx \frac{\text{데이터 크기}}{\text{디스크/네트워크 처리량}} \;+\; N_{\text{syscall}} \cdot C_{\text{syscall}} \;+\; N_{\text{fault}} \cdot C_{\text{page fault}}
$$

---

## 4. 타임아웃/에러/경쟁 체크리스트

- [ ] **부분 쓰기/읽기** 루프 처리(특히 소켓/파이프)
- [ ] **`EINTR` 재시도**, **`EAGAIN`은 이벤트 대기**
- [ ] 멀티스레드 랜덤 I/O는 **`pread/pwrite`**
- [ ] 다중 작성 로그는 **`O_APPEND` + 한 번의 `write`**
- [ ] 내구성: **임시→`fsync`→`rename`→디렉터리 `fsync`**
- [ ] 파일↔소켓 전송은 **`sendfile`**, 파일↔파일은 **`copy_file_range`** 우선
- [ ] `stdio`와 저수준 I/O **혼용 금지**(혼용 시 동기화 철저)
- [ ] 64비트 파일: **`-D_FILE_OFFSET_BITS=64`**
- [ ] (보안) 경로 조작 방지: **`openat/fstatat`** 패턴, `O_CLOEXEC`

---

## 5. 미니 예제 모음

### 5.1 “헤더+바디” 한 번에 보내기

```c
#include <sys/uio.h>
int send_msg(int fd, const void *hdr, size_t hlen, const void *body, size_t blen){
    struct iovec v[2] = { { (void*)hdr, hlen }, { (void*)body, blen } };
    ssize_t n = writev(fd, v, 2);
    return (n == (ssize_t)(hlen+blen)) ? 0 : -1;
}
```

### 5.2 견고한 파일 복사(최선→폴백)

```c
int copy_file(int in, int out){
    off_t off = 0;
    // 1) copy_file_range
    for(;;){
        ssize_t n = copy_file_range(in, NULL, out, NULL, 1<<20, 0);
        if (n > 0) continue;
        if (n == 0) return 0; // done
        if (errno == EINTR) continue;
        break; // 폴백
    }
    // 2) sendfile(파일→파일)
    for(;;){
        ssize_t n = sendfile(out, in, &off, 1<<20);
        if (n > 0) continue;
        if (n == 0) return 0;
        if (errno == EINTR) continue;
        break; // 폴백
    }
    // 3) read/write 루프
    char buf[1<<20];
    for(;;){
        ssize_t r = read(in, buf, sizeof buf);
        if (r == 0) return 0;
        if (r < 0) { if (errno==EINTR) continue; return -1; }
        ssize_t w = 0;
        while (w < r){
            ssize_t k = write(out, buf+w, (size_t)(r-w));
            if (k < 0) { if (errno==EINTR) continue; return -1; }
            w += k;
        }
    }
}
```

### 5.3 논블로킹 송수신 루틴(부분 I/O 처리)

```c
ssize_t nb_read(int fd, void *buf, size_t n){
    for(;;){
        ssize_t r = read(fd, buf, n);
        if (r >= 0) return r;
        if (errno == EINTR) continue;
        if (errno == EAGAIN || errno == EWOULDBLOCK) return -2; // 지금은 없음
        return -1;
    }
}
ssize_t nb_write(int fd, const void *buf, size_t n, size_t *wrote){
    const char* p = buf; size_t left = n; *wrote = 0;
    for(;;){
        ssize_t w = write(fd, p, left);
        if (w > 0){ left -= w; p += w; *wrote += (size_t)w; if (!left) return 0; }
        else if (w < 0 && errno == EINTR) continue;
        else if (w < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) return -2; // 나중에 이어쓰기
        else return -1;
    }
}
```

---

## 6. 마지막 포켓 요약

- **텍스트/라인**: `getline` 또는 **RIO 라인**
- **바이너리 정확히 N바이트**: `readn/writen`(또는 RIO)
- **랜덤/동시성**: `pread/pwrite`
- **여러 버퍼**: `writev/readv`
- **파일→소켓**: `sendfile`
- **파일↔파일**: `copy_file_range` ▶ `sendfile` ▶ `read/write`
- **논블로킹**: `epoll` + 부분 I/O 루프
- **대용량 랜덤 읽기**: `mmap`(+주의)
- **로그/다중 작성**: `O_APPEND` + 한 번의 `write`
- **내구성**: 임시→`fsync`→`rename`→**디렉터리 `fsync`**
- **혼용 금지**: `stdio` ↔ 저수준 I/O

이 가이드를 체크리스트처럼 적용하면, 다양한 워크로드에서 **안전하고 빠르고 예측 가능한** I/O 경로를 설계할 수 있다.
