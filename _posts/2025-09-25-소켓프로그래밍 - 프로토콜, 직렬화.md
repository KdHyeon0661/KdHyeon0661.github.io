---
layout: post
title: 소켓프로그래밍 - 프로토콜/직렬화
date: 2025-09-25 19:25:23 +0900
category: 소켓프로그래밍
---
## 15. 프로토콜/직렬화 설계 미니 가이드

> 목표: **현실적인 이진 프레이밍**(헤더/엔디안/체크섬) 위에 **메시지 직렬화**(JSON/CBOR/Protobuf)의 선택 기준을 세우고,  
> **순서 보장·중복 억제·멱등 토큰** 패턴을 설계한다. 마지막으로 **간단 요청–응답 프로토콜 정의서**를 제시하고  
> 이를 **C++23**로 **끝까지 구현**(클라/서버, 길이-프리픽스, 체크섬, 중복억제 캐시)한다.

---

### 15.1 헤더/프레이밍: 버전·타입·길이·체크섬·엔디안

#### 15.1.1 왜 “헤더 + payload”인가
- TCP는 **스트림**이므로 **경계가 없다** → 애플리케이션이 **프레이밍**을 직접 정의해야 한다.
- 가장 실무적인 패턴:
  - **고정 길이 헤더**(필수 메타: 버전/타입/길이/플래그/식별자/체크섬 …)
  - **가변 길이 payload**(실제 메시지: JSON/CBOR/Protobuf/바이너리)
  - **길이-프리픽스**로 `recv_exact(length)` 구현 → 부분읽기 안전화.

#### 15.1.2 엔디안 규약
- 네트워크 바이트 오더는 **빅엔디안**(network order).  
- 다중 바이트 정수는 **항상 big-endian**으로 **직렬화**/역직렬화:
  - `htons/htonl` (16/32비트), 64비트는 직접 구현(아래 코드 제공).

#### 15.1.3 체크섬(무결성)
- TCP에 **전송 계층 체크섬**이 있으나, 애플리케이션 프레임 단위의 **빠른 검증**이 유용:
  - 예: `CRC32`(빠름, 널리 쓰임), `CRC32C`(SSE4.2 가속), `Adler-32`(빠르나 충돌 강도↓).
- TLS를 쓴다면 **보안적 무결성**은 이미 확보되지만, **실수/버그 탐지** 용도로 프레임 체크섬는 여전히 유익.

---

### 15.2 직렬화 포맷 선택 가이드: JSON/CBOR/Protobuf

| 항목 | JSON | CBOR | Protobuf |
|---|---|---|---|
| 텍스트/바이너리 | 텍스트(UTF-8) | 바이너리(JSON의 이진 상응) | 바이너리(스키마 기반) |
| 스키마 | 비공식(관습) | 선택(명세는 자유) | **필수**(`.proto`) |
| 크기/속도 | 큼/느림(파싱 비용↑) | **중간**(작고 빠름) | **작고 매우 빠름** |
| 호환성 | 사람/디버깅 **최고** | 비교적 쉬움 | 철저(필드 번호/옵션) |
| 진화(필드 추가/옵션) | 자유(관습 필요) | 자유(관습 필요) | **강함**(레노버링 금지, 예약가능) |
| 에코/툴링 | 어디서나 | 좋음 | **매우 좋음**(생성기/검증기) |

**결론(실무):**
- **사내 내부용** + 사람 읽기 쉬움 중요 → **JSON**(초기 개발/디버깅 용이).  
- **경량/빠름** + 스키마 자유 → **CBOR**.  
- **대규모/다언어/장기 진화** + 성능 중요 → **Protobuf** 권장.

> 팁: 어떤 포맷이든 **상위 프레이밍**(헤더/길이/체크섬)은 **같다**. 포맷은 payload 내부 문제다.

---

### 15.3 순서 보장·중복 억제·멱등 토큰

#### 15.3.1 순서 보장
- **TCP는 바이트 순서**만 보장. **메시지 순서**를 보장하려면 **시퀀스 번호** 또는 **단순 증가 카운터**를 도입.
- 서버는 `(client_id, seq)`을 비교해 **out-of-order**를 무시 또는 **버퍼링**(복잡).

#### 15.3.2 중복 억제(재시도 대비)
- **재시도(12장)** 는 안전하지만 **중복 실행**이 생긴다 → **멱등성** 또는 **중복 억제** 필요.
- **패턴**: `(client_id, request_id)` **캐시**(TTL)  
  - 이미 처리한 요청이면 **그때의 응답**을 **재전송**(at-least-once → exactly-once 시맨틱에 가까워짐).

#### 15.3.3 멱등 토큰
- 클라가 **랜덤 64~128비트** 토큰을 생성해 요청 헤더에 넣는다.
- **충돌 확률**(단순 근사, 토큰 크기 \(k\)비트, 동시 요청 \(n\))  
  $$
  P_{\text{collision}} \approx \frac{n^2}{2\cdot 2^k}
  $$
  - \(k=64, n=10^6 \Rightarrow P\approx 2.7\times10^{-8}\),  
    \(k=128\)이면 사실상 무시 가능.

---

### 15.4 미니 프로토콜 정의서: **MiniRPC/1**

#### 15.4.1 목적
- 교육/실습을 위해 **간결한 요청–응답 RPC 스타일** 프로토콜을 정의한다.
- **이진 헤더(32B, big-endian) + payload(JSON 문자열)** 로 구성.

#### 15.4.2 Wire 헤더(고정 32바이트)

```
0               1               2               3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-------------------------------+-------------------------------+
|       Magic = 'M''R''P''C'    | Ver | Type|       Flags       |
+-------------------------------+-------------------------------+
|                        Request-ID (u64, big-endian)           |
+---------------------------------------------------------------+
|                         Client-ID (u64, big-endian)           |
+---------------------------------------------------------------+
|                Payload-Length (u32, big-endian)               |
+-------------------------------+-------------------------------+
|                  CRC32(payload) (u32, big-endian)             |
+-------------------------------+-------------------------------+
```

- `Magic` = `"MRPC"` (0x4D 0x52 0x50 0x43)
- `Ver` = 1
- `Type` = 1(REQUEST) / 2(RESPONSE)
- `Flags` (u16 비트):
  - `0x0001` = `F_ERROR`(에러 응답)
  - `0x0002` = `F_IDEMPOTENT`(멱등 요청)
  - `0x0004` = `F_COMPRESSED`(payload 압축; 여기선 미사용)
- `Request-ID` (u64): 클라 생성 **랜덤** 또는 증가 카운터
- `Client-ID` (u64): 클라 식별(랜덤·설정값·0도 허용)
- `Payload-Length` (u32): payload 바이트 길이
- `CRC32(payload)`: 헤더 제외, payload만

> **프레임 CAP**: 서버는 `Payload-Length ≤ 1 MiB` 정책(DoS 방어).

#### 15.4.3 Payload(JSON; UTF-8)
- **요청(JSON)**:
  - Echo: `{"op":"ECHO","data":"hello"}`
  - Sum : `{"op":"SUM","nums":[1,2,3,4]}`
  - (확장 가능: `"op":"PUT/GET"` 등)
- **응답(JSON)**:
  - 성공: `{"ok":true,"op":"ECHO","data":"hello"}`
  - 에러: `{"ok":false,"code":400,"error":"bad request"}`
- **ALPN/TLS** 사용 시 상위 레벨에서 협상(14장), 여기선 평문/직접 TCP도 동작.

---

### 15.5 구현: C++23 **미니 라이브러리 + 서버 + 클라이언트**

> **구성**  
> 1) `mini_proto.hpp`: 바이트 오더/CRC32/헤더 직렬화/프레이밍 I/O  
> 2) `mini_server.cpp`: **블로킹** 에코+합계 서버(중복 억제 캐시 포함)  
> 3) `mini_client.cpp`: 요청 전송/응답 수신 데모

> **빌드 예시**
> ```bash
> g++ -std=c++23 -O2 mini_server.cpp -o server
> g++ -std=c++23 -O2 mini_client.cpp -o client
> ./server 0.0.0.0 9000 &
> ./client 127.0.0.1 9000 ECHO "hello"
> ./client 127.0.0.1 9000 SUM 1,2,3,4,5
> ```

---

#### 15.5.1 `mini_proto.hpp` — 헤더/프레이밍 유틸

```cpp
// mini_proto.hpp — C++23, POSIX 전제
#pragma once
#include <array>
#include <cstdint>
#include <cstring>
#include <string>
#include <string_view>
#include <vector>
#include <optional>
#include <print>
#include <system_error>
#include <span>
#include <chrono>

#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>

// ---------- byte order helpers ----------
static inline uint64_t htonll_u64(uint64_t x) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    return ((uint64_t)htonl(uint32_t(x >> 32))) | ( (uint64_t)htonl(uint32_t(x & 0xFFFFFFFF)) << 32 );
#else
    return x;
#endif
}
static inline uint64_t ntohll_u64(uint64_t x) { return htonll_u64(x); }

// ---------- CRC32 (IEEE 802.3) ----------
struct Crc32 {
    uint32_t table[256]{};
    constexpr Crc32() : table{} {
        uint32_t poly = 0xEDB88320u;
        for (uint32_t i = 0; i < 256; ++i) {
            uint32_t c = i;
            for (int j = 0; j < 8; ++j)
                c = (c & 1) ? (poly ^ (c >> 1)) : (c >> 1);
            table[i] = c;
        }
    }
    uint32_t operator()(const std::byte* data, size_t len) const {
        uint32_t c = 0xFFFFFFFFu;
        for (size_t i=0;i<len;++i)
            c = table[(c ^ (uint8_t)data[i]) & 0xFFu] ^ (c >> 8);
        return c ^ 0xFFFFFFFFu;
    }
};
static const Crc32 g_crc32;

// ---------- wire header (32B) ----------
struct WireHeader {
    // host order
    uint8_t  ver{1};
    uint8_t  type{1};   // 1=req, 2=resp
    uint16_t flags{0};
    uint64_t request_id{0};
    uint64_t client_id{0};
    uint32_t length{0};
    uint32_t crc32{0};
};

// 고정 32B 직렬화 버퍼
static constexpr size_t HEADER_SIZE = 32;

static inline void header_encode(const WireHeader& h, std::array<std::byte, HEADER_SIZE>& out) {
    // layout: [Magic(4) | ver(1) | type(1) | flags(2) | req(8) | client(8) | len(4) | crc(4)]
    const char magic[4] = {'M','R','P','C'};
    std::memcpy(out.data(), magic, 4);
    out[4] = std::byte(h.ver);
    out[5] = std::byte(h.type);
    uint16_t f_be = htons(h.flags);
    std::memcpy(out.data()+6, &f_be, 2);
    uint64_t req_be = htonll_u64(h.request_id);
    std::memcpy(out.data()+8, &req_be, 8);
    uint64_t cli_be = htonll_u64(h.client_id);
    std::memcpy(out.data()+16, &cli_be, 8);
    uint32_t len_be = htonl(h.length);
    std::memcpy(out.data()+24, &len_be, 4);
    uint32_t crc_be = htonl(h.crc32);
    std::memcpy(out.data()+28, &crc_be, 4);
}

static inline std::optional<WireHeader> header_decode(std::span<const std::byte, HEADER_SIZE> in) {
    if (in.size()!=HEADER_SIZE) return std::nullopt;
    if (std::memcmp(in.data(), "MRPC", 4)!=0) return std::nullopt;
    WireHeader h{};
    h.ver   = (uint8_t)in[4];
    h.type  = (uint8_t)in[5];
    uint16_t f_be{}; std::memcpy(&f_be, in.data()+6, 2); h.flags = ntohs(f_be);
    uint64_t req_be{}; std::memcpy(&req_be, in.data()+8, 8); h.request_id = ntohll_u64(req_be);
    uint64_t cli_be{}; std::memcpy(&cli_be, in.data()+16,8); h.client_id  = ntohll_u64(cli_be);
    uint32_t len_be{}; std::memcpy(&len_be, in.data()+24,4); h.length     = ntohl(len_be);
    uint32_t crc_be{}; std::memcpy(&crc_be, in.data()+28,4); h.crc32      = ntohl(crc_be);
    return h;
}

// ---------- safe blocking I/O ----------
static inline std::error_code send_all(int fd, const std::byte* p, size_t n) {
    size_t off=0;
    while (off<n) {
        ssize_t m = ::send(fd, p+off, n-off, 0);
        if (m>0) { off += (size_t)m; continue; }
        if (m==0) continue;
        if (errno==EINTR) continue;
        if (errno==EAGAIN || errno==EWOULDBLOCK) continue;
        return {errno, std::generic_category()};
    }
    return {};
}

static inline std::error_code recv_exact(int fd, std::byte* p, size_t n) {
    size_t off=0;
    while (off<n) {
        ssize_t m = ::recv(fd, p+off, n-off, 0);
        if (m>0) { off += (size_t)m; continue; }
        if (m==0) return std::make_error_code(std::errc::connection_reset);
        if (errno==EINTR) continue;
        if (errno==EAGAIN || errno==EWOULDBLOCK) continue;
        return {errno, std::generic_category()};
    }
    return {};
}

// ---------- convenience ----------
static inline std::vector<std::byte> make_frame(const WireHeader& h, std::string_view payload) {
    std::array<std::byte, HEADER_SIZE> hb{};
    WireHeader hw = h;
    hw.length = (uint32_t)payload.size();
    hw.crc32  = g_crc32(reinterpret_cast<const std::byte*>(payload.data()), payload.size());
    header_encode(hw, hb);

    std::vector<std::byte> buf; buf.reserve(HEADER_SIZE + payload.size());
    buf.insert(buf.end(), hb.begin(), hb.end());
    buf.insert(buf.end(), (const std::byte*)payload.data(), (const std::byte*)payload.data()+payload.size());
    return buf;
}
```

---

#### 15.5.2 `mini_server.cpp` — 요청 처리/중복 억제 캐시 포함

```cpp
// mini_server.cpp — MiniRPC/1 서버(블로킹). ECHO, SUM 지원 + 중복억제 TTL 캐시
#include "mini_proto.hpp"
#include <netdb.h>
#include <unordered_map>
#include <list>
#include <mutex>
#include <thread>
#include <charconv>

// 간단 LRU + TTL 캐시: key=(client_id, request_id) → serialized response frame
struct DedupKey { uint64_t c{}, r{}; bool operator==(const DedupKey& o) const { return c==o.c && r==o.r; } };
struct DedupKeyHash { size_t operator()(const DedupKey& k) const { return std::hash<uint64_t>{}(k.c) ^ (std::hash<uint64_t>{}(k.r)<<1); } };

struct DedupCache {
    struct Node { DedupKey key; std::vector<std::byte> val; std::chrono::steady_clock::time_point exp; };
    size_t cap;
    std::unordered_map<DedupKey, std::list<Node>::iterator, DedupKeyHash> map;
    std::list<Node> lru;
    std::chrono::seconds ttl;
    std::mutex m;

    DedupCache(size_t cap_, std::chrono::seconds ttl_) : cap(cap_), ttl(ttl_) {}

    std::optional<std::vector<std::byte>> get(const DedupKey& k) {
        std::scoped_lock lk(m);
        auto it = map.find(k); if (it==map.end()) return std::nullopt;
        if (std::chrono::steady_clock::now() > it->second->exp) {
            lru.erase(it->second); map.erase(it); return std::nullopt;
        }
        // LRU promote
        lru.splice(lru.begin(), lru, it->second);
        return it->second->val;
    }
    void put(const DedupKey& k, std::vector<std::byte> v) {
        std::scoped_lock lk(m);
        auto now = std::chrono::steady_clock::now();
        if (auto it=map.find(k); it!=map.end()) {
            it->second->val = std::move(v);
            it->second->exp = now + ttl;
            lru.splice(lru.begin(), lru, it->second);
            return;
        }
        lru.push_front(Node{.key=k, .val=std::move(v), .exp= now + ttl});
        map.emplace(k, lru.begin());
        while (map.size() > cap) {
            auto last = std::prev(lru.end());
            map.erase(last->key);
            lru.pop_back();
        }
    }
};

// 문자열 유틸(아주 단순한 JSON 생성/파싱 보조)
static std::string json_ok_echo(std::string_view s) {
    // 데모용: 따옴표/역슬래시를 최소 escape
    std::string esc; esc.reserve(s.size()+8);
    for (char c: s) { if (c=='"' || c=='\\') { esc.push_back('\\'); } esc.push_back(c); }
    return std::string{"{\"ok\":true,\"op\":\"ECHO\",\"data\":\""} + esc + "\"}";
}
static std::string json_ok_sum(long long sum) {
    return std::string{"{\"ok\":true,\"op\":\"SUM\",\"sum\":"} + std::to_string(sum) + "}";
}
static std::string json_error(int code, std::string_view msg) {
    std::string esc; for (char c: msg) { if (c=='"'||c=='\\') esc.push_back('\\'); esc.push_back(c); }
    return std::string{"{\"ok\":false,\"code\":"} + std::to_string(code) + ",\"error\":\"" + esc + "\"}";
}

// 요청 파싱(데모: 아주 단순)
// ECHO: {"op":"ECHO","data":"..."}  → data 추출
// SUM : {"op":"SUM","nums":[1,2,3]} → nums 추출(정수들)
enum class Op { ECHO, SUM, UNKNOWN };
static Op parse_op(std::string_view s) {
    if (s.find("\"op\":\"ECHO\"") != std::string_view::npos) return Op::ECHO;
    if (s.find("\"op\":\"SUM\"")  != std::string_view::npos) return Op::SUM;
    return Op::UNKNOWN;
}
static std::optional<std::string> parse_echo_data(std::string_view s) {
    auto p = s.find("\"data\":\""); if (p==std::string_view::npos) return std::nullopt;
    p += 8; auto q = s.find('"', p);
    if (q==std::string_view::npos) return std::nullopt;
    // 역슬래시 최소 처리(데모)
    std::string out; out.reserve(q-p);
    for (size_t i=p;i<q;++i) {
        char c=s[i];
        if (c=='\\' && i+1<q) { out.push_back(s[++i]); }
        else out.push_back(c);
    }
    return out;
}
static std::optional<long long> parse_sum_nums(std::string_view s) {
    auto p = s.find("\"nums\":["); if (p==std::string_view::npos) return std::nullopt;
    p += 8;
    auto q = s.find(']', p); if (q==std::string_view::npos) return std::nullopt;
    long long sum=0;
    size_t i=p;
    while (i<q) {
        while (i<q && (s[i]==' '||s[i]==',')) ++i;
        if (i>=q) break;
        long long v=0; auto j=i;
        // std::from_chars (C++17~)
        auto res = std::from_chars(s.data()+j, s.data()+q, v);
        if (res.ec!=std::errc{}) return std::nullopt;
        sum += v;
        i = res.ptr - s.data();
        while (i<q && (s[i]==' '||s[i]==',')) ++i;
    }
    return sum;
}

// 주소 만들기
static int make_listener(const char* bind_host, const char* port) {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(bind_host[0]?bind_host:nullptr, port, &hints, &res)!=0) return -1;
    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        int on=1; setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));
        if (bind(s, ai->ai_addr, ai->ai_addrlen)==0 && listen(s, 1024)==0) { freeaddrinfo(res); return s; }
        ::close(s); s=-1;
    }
    freeaddrinfo(res); return -1;
}

int main(int argc, char** argv) {
    const char* host = (argc>1? argv[1] : "0.0.0.0");
    const char* port = (argc>2? argv[2] : "9000");
    int lfd = make_listener(host, port);
    if (lfd<0) { std::print(stderr,"listen fail\n"); return 1; }
    std::print("[MiniRPC/1] listen {}:{}\n", host, port);

    DedupCache cache(8192, std::chrono::seconds(60));

    for(;;){
        int cfd = ::accept(lfd, nullptr, nullptr);
        if (cfd<0) { if(errno==EINTR) continue; perror("accept"); break; }

        // 1) 헤더 읽기
        std::array<std::byte, HEADER_SIZE> hb{};
        if (auto ec = recv_exact(cfd, hb.data(), hb.size())) { ::close(cfd); continue; }
        auto oh = header_decode(std::span<const std::byte, HEADER_SIZE>(hb));
        if (!oh) { ::close(cfd); continue; }
        WireHeader h = *oh;

        // CAP 체크
        if (h.length > (1u<<20)) {
            // 에러 응답
            std::string pay = json_error(413, "payload too large");
            WireHeader eh{.ver=1,.type=2,.flags=0x0001,.request_id=h.request_id,.client_id=h.client_id,.length=0,.crc32=0};
            auto frame = make_frame(eh, pay);
            (void)send_all(cfd, frame.data(), frame.size());
            ::close(cfd); continue;
        }

        // 2) payload 읽기
        std::string payload; payload.resize(h.length);
        if (auto ec = recv_exact(cfd, (std::byte*)payload.data(), payload.size())) { ::close(cfd); continue; }

        // 3) CRC 검증
        uint32_t want = g_crc32((const std::byte*)payload.data(), payload.size());
        if (want != h.crc32) {
            std::string pay = json_error(460, "bad crc32");
            WireHeader eh{.ver=1,.type=2,.flags=0x0001,.request_id=h.request_id,.client_id=h.client_id};
            auto frame = make_frame(eh, pay);
            (void)send_all(cfd, frame.data(), frame.size());
            ::close(cfd); continue;
        }

        DedupKey key{.c=h.client_id, .r=h.request_id};
        if (h.flags & 0x0002) {
            if (auto cached = cache.get(key)) {
                (void)send_all(cfd, cached->data(), cached->size());
                ::close(cfd); continue;
            }
        }

        // 4) 요청 처리
        std::string resp;
        switch (parse_op(payload)) {
            case Op::ECHO: {
                auto data = parse_echo_data(payload);
                if (!data) resp = json_error(400, "missing data");
                else      resp = json_ok_echo(*data);
                break;
            }
            case Op::SUM: {
                auto s = parse_sum_nums(payload);
                if (!s) resp = json_error(400, "bad nums");
                else    resp = json_ok_sum(*s);
                break;
            }
            default:
                resp = json_error(400, "unknown op");
        }

        WireHeader rh{.ver=1,.type=2,.flags=(uint16_t)(resp.starts_with("{\"ok\":false")?0x0001:0x0000),
                      .request_id=h.request_id,.client_id=h.client_id};
        auto frame = make_frame(rh, resp);

        if (h.flags & 0x0002) cache.put(key, frame); // 멱등 요청이면 캐시 저장

        (void)send_all(cfd, frame.data(), frame.size());
        ::close(cfd);
    }
    ::close(lfd);
    return 0;
}
```

---

#### 15.5.3 `mini_client.cpp` — ECHO/SUM 테스트 클라이언트

```cpp
// mini_client.cpp — MiniRPC/1 클라이언트(블로킹)
#include "mini_proto.hpp"
#include <netdb.h>
#include <random>

static int dial(const char* host, const char* port) {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_ADDRCONFIG|AI_NUMERICSERV;
    if (getaddrinfo(host, port, &hints, &res)!=0) return -1;
    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) { freeaddrinfo(res); return s; }
        ::close(s); s=-1;
    }
    freeaddrinfo(res); return -1;
}

static uint64_t rand64() {
    static thread_local std::mt19937_64 rng{std::random_device{}()};
    return rng();
}

int main(int argc, char** argv) {
    if (argc < 5) {
        std::print(stderr, "usage: {} <host> <port> <ECHO|SUM> <arg>\n", argv[0]);
        std::print(stderr, "  ECHO <string>\n");
        std::print(stderr, "  SUM  <comma-separated-ints>   e.g., 1,2,3,4\n");
        return 1;
    }
    const char* host=argv[1]; const char* port=argv[2];
    std::string cmd=argv[3]; std::string arg=argv[4];

    uint64_t client_id = 0xC1C1C1C1C1C1C1C1ull; // 예시(배포에선 구성/랜덤)
    uint64_t request_id = rand64();

    std::string payload;
    if (cmd=="ECHO") {
        // 간단 escape
        std::string esc; for (char c: arg) { if (c=='"'||c=='\\') esc.push_back('\\'); esc.push_back(c); }
        payload = std::string{"{\"op\":\"ECHO\",\"data\":\""} + esc + "\"}";
    } else if (cmd=="SUM") {
        payload = std::string{"{\"op\":\"SUM\",\"nums\":["} + arg + "]}";
    } else {
        std::print(stderr,"unknown cmd\n"); return 1;
    }

    WireHeader h{.ver=1,.type=1,.flags=0x0002, // 멱등 플래그 on → 중복억제 가능
                 .request_id=request_id,.client_id=client_id};
    auto frame = make_frame(h, payload);

    int fd = dial(host, port);
    if (fd<0) { perror("connect"); return 1; }
    if (auto ec=send_all(fd, frame.data(), frame.size())) { std::print(stderr,"send: {}\n", ec.message()); ::close(fd); return 1; }

    // 응답 헤더 + payload
    std::array<std::byte, HEADER_SIZE> hb{};
    if (auto ec=recv_exact(fd, hb.data(), hb.size())) { std::print(stderr,"recv header: {}\n", ec.message()); ::close(fd); return 1; }
    auto oh = header_decode(std::span<const std::byte, HEADER_SIZE>(hb));
    if (!oh) { std::print(stderr,"bad header\n"); ::close(fd); return 1; }

    WireHeader rh = *oh;
    std::string resp; resp.resize(rh.length);
    if (auto ec=recv_exact(fd, (std::byte*)resp.data(), resp.size())) { std::print(stderr,"recv body: {}\n", ec.message()); ::close(fd); return 1; }

    // CRC 검증
    if (g_crc32((const std::byte*)resp.data(), resp.size()) != rh.crc32) {
        std::print(stderr,"crc mismatch\n");
    }

    std::print("[resp] {}\n", resp);
    ::close(fd);
    return 0;
}
```

---

### 15.6 운영 포인트(프로토콜 진화/보안/옵스)

1) **버전 필드**: `Ver=1`에서 신규 필드(예: `trace_id`, `compress algo`)가 필요하면 **버전 올리지 말고 Flags/옵션-헤더**로 확장하는 게 보통 더 낫다. 진짜 깨지는 변경만 `Ver` 증가.
2) **옵션-헤더(확장)**: 32B 고정 헤더 뒤에 **옵션 TLV**(길이 포함)를 둘 수 있다. 서버는 모르는 타입 **건너뛰기**.
3) **보안**:  
   - 평문이면 **MITM/변조/재주입** 위험 → 14장에서 다룬 **TLS** 사용.  
   - 멱등 토큰 캐시에는 **만료 TTL**과 **격자형 키공간**(해시 sharding)으로 **메모리/잠금 경합** 관리.
4) **압축**: JSON은 크기가 큼.  
   - 짧은 메시지는 **압축 역효과**(헤더비용) → **threshold**(예: >512B) 이상만 압축.  
   - 압축은 **BOM 공격** 가능 → payload cap + 압축 전/후 크기 상한.
5) **관측**:  
   - `ok:true/false` 비율, `code` 상위 N, `crc error` 카운트, `dup-hit`(중복 억제 캐시 적중률).
6) **성능**:  
   - JSON 파서 대신 CBOR/Protobuf 전환 시 **payload 그대로** 두고 **헤더는 재사용**.  
   - CRC32C(SSE4.2)로 교체 시 큰 payload에서 **2~3배** 가속.

---

### 15.7 요약 & 체크리스트

- [ ] TCP 스트림 위에 **고정 헤더(버전/타입/길이/CRC)** + **payload** 설계  
- [ ] **빅엔디안**으로 정수 직렬화, `hton*/ntoh*` 사용  
- [ ] **길이-프리픽스**로 `recv_exact`/`send_all` 구현  
- [ ] **중복 억제**: `(client_id, request_id)` TTL 캐시 + 멱등 플래그  
- [ ] **CAP**: payload 최대치(예: 1MiB)  
- [ ] **직렬화 선택**: 초기엔 JSON, 확장 시 CBOR/Protobuf 고려  
- [ ] **TLS**(14장)로 보안경계 확보, ALPN으로 상위 프로토콜 협상  
- [ ] **관측 지표**: ok율, 에러 코드, dup-hit, CRC 실패, p95 지연

---

### 15.8 부록: 테스트 시나리오

1) **정상 흐름**: ECHO/SUM 요청 여러 번(동일 `request_id` 재전송) → 서버가 **동일 응답 재전송**(dup-hit 증가).  
2) **CRC 실패**: 클라에서 payload 마지막 바이트 뒤집기 → 서버가 `460` 에러.  
3) **대형 payload**: 2MiB 전송 → 서버가 `413` 에러.  
4) **성능**: 100 동시 클라로 1kB JSON ECHO 초당 RPS/지연 측정.  
5) **진화**: payload를 CBOR로 바꾸고 헤더 그대로 두기(서버는 ALPN/버전 플래그로 구분).

---

이로써 **프레이밍(헤더/엔디안/체크섬)** → **직렬화 선택** → **중복 억제/멱등** → **완전한 클라/서버 구현**까지  
**끊김 없이** 이어지는 **실전 프로토콜 설계의 최소선**을 만들었다. 다음 단계는 **epoll(ET)**(10~11장)과 결합하여  
**논블로킹**으로 바꾸고, 14장의 **TLS**를 얹어 **운영 등급**으로 승급하는 일이다.