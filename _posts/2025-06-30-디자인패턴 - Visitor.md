---
layout: post
title: 디자인패턴 - Visitor
date: 2025-06-30 23:20:23 +0900
category: 디자인패턴
---
# Visitor (방문자 패턴)

## 문제와 동기

- 도메인 모델(예: AST, 도형 트리, 문서 노드)은 **안정적**인데, 위에서 수행할 연산(렌더링, 검증, 수치 계산, 직렬화)은 **자꾸 추가**된다.
- 각 연산을 요소 클래스에 계속 추가하면 클래스가 **비대**해지고, **관심사 분리가 깨짐**.
- Visitor는 “구조는 그대로, 연산은 바깥에서 모듈화”하여 추가한다.

**적합한 상황**
- 요소 집합(클래스 계층)이 **자주 바뀌지 않음**.
- 연산(행동)을 **자주 추가/교체**한다.
- 트리/그래프 구조를 **일관된 방식으로 순회**하며 다양한 처리를 한다.

**부적합한 상황**
- 요소 타입이 **자주 추가/삭제**된다(Visitor 인터페이스 전부 수정 필요).
- 언어가 **패턴 매칭/밀폐 계층(sealed)**을 제공해 간단히 처리 가능한 경우.

---

## 구조와 이중 디스패치

```
┌──────────────────┐            ┌────────────────────┐
│  Visitor          │            │  Element           │
│ ├ visitCircle(c)  │◄──accept───┤  accept(v:Visitor) │
│ └ visitSquare(s)  │            └─────────┬──────────┘
└─────────┬────────┘                      ▲
          │                                │
  ┌───────▼─────────┐            ┌────────▼──────────┐
  │ ConcreteVisitorA │            │ ConcreteElement   │
  └──────────────────┘            └───────────────────┘
```

- `Element.accept(v)`가 **자기 자신의 실제 타입**을 이용해 `v.visitXxx(self)`를 호출한다.
- 호출 시점에 두 객체의 타입(Visitor, Element)을 모두 고려하므로 **이중 디스패치**라 한다.

---

## 파이썬 구현

### 최소 구현(명시적 이중 디스패치)

```python
from abc import ABC, abstractmethod

# Visitor 인터페이스

class Visitor(ABC):
    @abstractmethod
    def visit_circle(self, circle: "Circle"): ...
    @abstractmethod
    def visit_square(self, square: "Square"): ...

# Element 인터페이스

class Shape(ABC):
    @abstractmethod
    def accept(self, v: Visitor) -> None: ...

class Circle(Shape):
    def __init__(self, r: float) -> None:
        self.r = r
    def accept(self, v: Visitor) -> None:
        v.visit_circle(self)

class Square(Shape):
    def __init__(self, a: float) -> None:
        self.a = a
    def accept(self, v: Visitor) -> None:
        v.visit_square(self)

# 방문자 1: 렌더링

class RenderVisitor(Visitor):
    def visit_circle(self, c: Circle) -> None:
        print(f"draw circle r={c.r}")
    def visit_square(self, s: Square) -> None:
        print(f"draw square a={s.a}")

# 방문자 2: 면적

class AreaVisitor(Visitor):
    def visit_circle(self, c: Circle) -> None:
        area = 3.1415926535 * c.r * c.r
        print(f"circle area={area:.2f}")
    def visit_square(self, s: Square) -> None:
        print(f"square area={s.a * s.a:.2f}")

shapes: list[Shape] = [Circle(2.0), Square(3.0)]
for v in (RenderVisitor(), AreaVisitor()):
    for sh in shapes:
        sh.accept(v)
```

### 방문자 반환값이 필요한 경우(제네릭 스타일)

```python
from abc import ABC, abstractmethod
from typing import Protocol, TypeVar, Generic, runtime_checkable

R = TypeVar("R")

@runtime_checkable
class RVisitor(Protocol, Generic[R]):
    def visit_circle(self, c: "Circle") -> R: ...
    def visit_square(self, s: "Square") -> R: ...

class RShape(ABC):
    @abstractmethod
    def accept(self, v: RVisitor[R]) -> R: ...

class Circle(RShape):
    def __init__(self, r: float) -> None:
        self.r = r
    def accept(self, v: RVisitor[R]) -> R:
        return v.visit_circle(self)

class Square(RShape):
    def __init__(self, a: float) -> None:
        self.a = a
    def accept(self, v: RVisitor[R]) -> R:
        return v.visit_square(self)

class PerimeterVisitor(RVisitor[float]):
    def visit_circle(self, c: Circle) -> float:
        return 2 * 3.1415926535 * c.r
    def visit_square(self, s: Square) -> float:
        return 4 * s.a

perimeter = PerimeterVisitor()
vals = [shape.accept(perimeter) for shape in [Circle(1.0), Square(2.0)]]
assert vals == [2*3.1415926535*1.0, 8.0]
```

### Visitor

Visitor에 없는 타입을 getattr로 동적 라우팅(기본 처리 제공):

```python
class ReflectiveVisitor:
    def visit(self, elem: object):
        name = elem.__class__.__name__.lower()
        meth = getattr(self, f"visit_{name}", self.generic_visit)
        return meth(elem)
    def generic_visit(self, elem):
        raise NotImplementedError(f"no visit for {type(elem)}")

class PrintVisitor(ReflectiveVisitor):
    def visit_circle(self, c): print(f"circle r={c.r}")
    def visit_square(self, s): print(f"square a={s.a}")

# 각 요소에 accept 없이도 동작(전통 Visitor는 아님)

for e in [Circle(2), Square(3)]:
    PrintVisitor().visit(e)
```

장점: 요소를 바꿀 필요가 적다. 단점: 정적 안전성/IDE 지원이 떨어질 수 있다.

---

## AST 예제(실전형)

### 정의

```python
from abc import ABC, abstractmethod

class Expr(ABC):
    @abstractmethod
    def accept(self, v: "ExprVisitor"): ...

class Number(Expr):
    def __init__(self, value: float) -> None:
        self.value = value
    def accept(self, v: "ExprVisitor"):
        return v.visit_number(self)

class Add(Expr):
    def __init__(self, lhs: Expr, rhs: Expr) -> None:
        self.lhs, self.rhs = lhs, rhs
    def accept(self, v: "ExprVisitor"):
        return v.visit_add(self)

class Mul(Expr):
    def __init__(self, lhs: Expr, rhs: Expr) -> None:
        self.lhs, self.rhs = lhs, rhs
    def accept(self, v: "ExprVisitor"):
        return v.visit_mul(self)

class Neg(Expr):
    def __init__(self, inner: Expr) -> None:
        self.inner = inner
    def accept(self, v: "ExprVisitor"):
        return v.visit_neg(self)
```

### 방문자: 평가, 출력, 상수 폴딩

```python
from abc import ABC, abstractmethod

class ExprVisitor(ABC):
    @abstractmethod
    def visit_number(self, n: Number): ...
    @abstractmethod
    def visit_add(self, a: Add): ...
    @abstractmethod
    def visit_mul(self, m: Mul): ...
    @abstractmethod
    def visit_neg(self, n: Neg): ...

class EvalVisitor(ExprVisitor):
    def visit_number(self, n: Number): return n.value
    def visit_add(self, a: Add): return a.lhs.accept(self) + a.rhs.accept(self)
    def visit_mul(self, m: Mul): return m.lhs.accept(self) * m.rhs.accept(self)
    def visit_neg(self, n: Neg): return -n.inner.accept(self)

class PrintVisitor(ExprVisitor):
    def visit_number(self, n: Number): return str(n.value)
    def visit_add(self, a: Add): return f"({a.lhs.accept(self)} + {a.rhs.accept(self)})"
    def visit_mul(self, m: Mul): return f"({m.lhs.accept(self)} * {m.rhs.accept(self)})"
    def visit_neg(self, n: Neg): return f"(-{n.inner.accept(self)})"

class ConstantFoldVisitor(ExprVisitor):
    def visit_number(self, n: Number): return Number(n.value)
    def visit_add(self, a: Add):
        l, r = a.lhs.accept(self), a.rhs.accept(self)
        if isinstance(l, Number) and isinstance(r, Number):
            return Number(l.value + r.value)
        return Add(l, r)
    def visit_mul(self, m: Mul):
        l, r = m.lhs.accept(self), m.rhs.accept(self)
        if isinstance(l, Number) and isinstance(r, Number):
            return Number(l.value * r.value)
        return Mul(l, r)
    def visit_neg(self, n: Neg):
        inner = n.inner.accept(self)
        return Number(-inner.value) if isinstance(inner, Number) else Neg(inner)

expr = Add(Number(1), Mul(Number(2), Neg(Number(3))))  # 1 + 2 * (-3)
ev = EvalVisitor()
pv = PrintVisitor()
cv = ConstantFoldVisitor()

before = pv.visit_add(expr)  # 문자열을 얻기 위해 직접 호출
folded = expr.accept(cv)
after  = folded.accept(pv)
val    = folded.accept(ev)

print(before)  # (1 + (2 * (-3)))
print(after)   # (1 + (-6))
print(val)     # -5.0
```

---

## Java 구현(정석)

```java
interface Visitor {
    void visit(Circle c);
    void visit(Square s);
}

interface Element {
    void accept(Visitor v);
}

final class Circle implements Element {
    final double r;
    Circle(double r) { this.r = r; }
    public void accept(Visitor v) { v.visit(this); }
}

final class Square implements Element {
    final double a;
    Square(double a) { this.a = a; }
    public void accept(Visitor v) { v.visit(this); }
}

final class RenderVisitor implements Visitor {
    public void visit(Circle c) { System.out.println("draw circle r=" + c.r); }
    public void visit(Square s) { System.out.println("draw square a=" + s.a); }
}

final class AreaVisitor implements Visitor {
    public void visit(Circle c) { System.out.printf("area=%.2f%n", Math.PI*c.r*c.r); }
    public void visit(Square s) { System.out.printf("area=%.2f%n", s.a*s.a); }
}
```

- 각 `Element.accept`는 `v.visit(this)`를 호출한다.
- 컴파일 타임에 **오버로딩 선택 + 런타임 실제 수신객체**로 결합되어 이중 디스패치가 실현된다.

---

## C# 구현(제네릭 반환값)

```csharp
public interface IVisitor<out R> {
    R Visit(Circle c);
    R Visit(Square s);
}

public interface IElement<R> {
    R Accept(IVisitor<R> v);
}

public sealed class Circle : IElement<double> {
    public double R { get; }
    public Circle(double r) { R = r; }
    public double Accept(IVisitor<double> v) => v.Visit(this);
}

public sealed class Square : IElement<double> {
    public double A { get; }
    public Square(double a) { A = a; }
    public double Accept(IVisitor<double> v) => v.Visit(this);
}

public sealed class AreaVisitor : IVisitor<double> {
    public double Visit(Circle c) => Math.PI * c.R * c.R;
    public double Visit(Square s) => s.A * s.A;
}
```

---

## TypeScript 구현

```ts
interface Visitor {
  visitCircle(c: Circle): void;
  visitSquare(s: Square): void;
}
interface Element {
  accept(v: Visitor): void;
}

class Circle implements Element {
  constructor(public r: number) {}
  accept(v: Visitor): void { v.visitCircle(this); }
}
class Square implements Element {
  constructor(public a: number) {}
  accept(v: Visitor): void { v.visitSquare(this); }
}

class RenderVisitor implements Visitor {
  visitCircle(c: Circle) { console.log(`draw circle r=${c.r}`); }
  visitSquare(s: Square) { console.log(`draw square a=${s.a}`); }
}
```

---

## Composite + Visitor 결합(트리 순회)

파일시스템 트리 구조를 Visitor로 분석:

```python
from abc import ABC, abstractmethod
from typing import List

class Node(ABC):
    @abstractmethod
    def accept(self, v: "FSVisitor"): ...

class File(Node):
    def __init__(self, name: str, size: int) -> None:
        self.name, self.size = name, size
    def accept(self, v: "FSVisitor"):
        return v.visit_file(self)

class Dir(Node):
    def __init__(self, name: str, children: List[Node]) -> None:
        self.name, self.children = name, children
    def accept(self, v: "FSVisitor"):
        return v.visit_dir(self)

class FSVisitor(ABC):
    @abstractmethod
    def visit_file(self, f: File): ...
    @abstractmethod
    def visit_dir(self, d: Dir): ...

class SizeVisitor(FSVisitor):
    def visit_file(self, f: File): return f.size
    def visit_dir(self, d: Dir): return sum(ch.accept(self) for ch in d.children)

root = Dir("root", [File("a.txt", 10), Dir("img", [File("x.png", 100)])])
assert root.accept(SizeVisitor()) == 110
```

---

## 성능·설계 고려

- **호출 오버헤드**: 많은 작은 호출이 발생한다. 필요시 배치 처리 또는 반복자(Iterator)와 결합해 순회 비용을 줄인다.
- **캡슐화**: Visitor가 요소 내부 상태를 과도하게 들여다보면 캡슐화가 깨진다. 필요한 데이터만 공개하거나 **Query Visitor**(반환값 중심)로 한정한다.
- **스레드 안전**: Visitor가 상태를 축적한다면 동시 접근을 피하거나 스레드별 인스턴스를 사용한다.
- **확장 방향**: Visitor는 **연산 추가**에 강하고, **요소 추가**에는 약하다(인터페이스 전면 수정).

**연산 vs 요소 확장성 비교**

| 축 | Visitor의 강점 |
|---|---|
| 연산 추가 | 매우 강함(방문자 클래스 추가) |
| 요소 추가 | 약함(Visitor 인터페이스·모든 방문자 수정) |

---

## 변형과 대안

### Visitor

- 각 요소 인터페이스가 독립 방문자 인터페이스를 갖고, 방문자는 필요한 것만 구현.
- 장점: 요소 추가 시 기존 방문자를 깨뜨리지 않음.
- 단점: 타입 수가 늘고 캐스팅/등록이 늘 수 있음.

### Visitor

- `getattr`/리플렉션으로 `visit_<Type>` 동적 호출(위 3.3).
- 장점: 요소 변경 영향이 적음. 단점: 정적 안전성·IDE 도움 약화.

### 패턴 매칭(대안)

- Java `sealed` + switch, Kotlin/Scala/Swift의 `when`/`match`, Python 3.10+ `match`.
- 요소가 밀폐 계층이라면 방문자 없이도 깔끔한 분기 가능.
- 단, 연산이 많아지면 소스 흩어짐 → 방문자가 더 응집적일 수 있음.

---

## 테스트 전략

- **계약 테스트**: 모든 요소에 대해 각 방문자 메서드가 정확히 호출되는지 검증.
- **스냅샷**: 프린터/렌더러 결과를 스냅샷으로 비교.
- **성질 기반**: `Eval(Optimize(expr)) == Eval(expr)` 같은 불변 성질.

파이썬 예:

```python
def test_dispatch_calls_correct_method(capsys):
    class Spy(Visitor):
        def __init__(self): self.calls = []
        def visit_circle(self, c): self.calls.append(("circle", c.r))
        def visit_square(self, s): self.calls.append(("square", s.a))
    spy = Spy()
    for e in [Circle(1), Square(2)]:
        e.accept(spy)
    assert spy.calls == [("circle", 1), ("square", 2)]
```

---

## 실전 시나리오

1) **컴파일러 프론트엔드**
   - 방문자: 타입체크, 상수 폴딩, 코드 생성, 최적화, pretty-print.
   - 구조(AST)는 안정적, 연산은 계속 추가.

2) **문서 처리/에디터**
   - 노드: 문단, 텍스트, 이미지, 표.
   - 방문자: 렌더러, 인쇄, 목차 생성, 링크 검사기.

3) **게임 오브젝트 시스템**
   - 요소: 플레이어, NPC, 투사체, 지형.
   - 방문자: 충돌 처리, 가시성 판정, 통계 수집, 저장/로드.

4) **전자상거래 가격 엔진**
   - 요소: 상품, 번들, 쿠폰, 장바구니.
   - 방문자: 세금 계산, 할인 규칙, 영수증 출력, 감사 로그.

---

## 안티패턴과 주의점

- **요소 추가가 매우 잦은 도메인**에서의 Visitor 남용: 매번 모든 방문자 수정 필요.
- **과도한 내부 상태 노출**: 캡슐화 붕괴. 필요한 질의만 제공하거나 DTO를 노출.
- **거대 Visitor(신의 객체)**: 여러 책임이 한 클래스에 집중. 방문자 분리(단일 책임), 합성 활용.
- **순회와 연산의 혼합**: 방문자가 순회까지 책임지면 재사용성 저하. 순회는 요소/헬퍼(Iterator)에게 맡기고 방문자는 “연산”에 집중.

---

## 품질 체크리스트

- [ ] `accept`가 항상 `visitor.visit_<ConcreteType>(self)`를 호출하는가?
- [ ] Visitor 인터페이스가 **최소한**의 방문 대상만 노출하는가?
- [ ] 연산 추가가 기존 요소·기존 방문자에 **영향 없이** 가능했는가?
- [ ] 순회 책임과 연산 책임이 **분리**되어 있는가?
- [ ] 캡슐화 위반 없이 필요한 데이터만 노출하는가?
- [ ] 테스트로 이중 디스패치 경로가 모두 검증되는가?

---

## 기존 코드 리팩터링 절차(스위치/if-else 제거)

1) 공통 인터페이스 `Element.accept(Visitor)` 도입, 요소별 구현 추가.
2) 기존 거대한 `switch(type)` 또는 `if isinstance` 분기를 Visitor 메서드로 이동.
3) 연산 단위로 방문자 클래스를 쪼개 관심사를 분리.
4) 순회 헬퍼(예: `accept_all`)를 추가해 방문자 재사용성 확보.
5) 테스트로 요소×방문자 조합을 커버.

---

## 요약

- Visitor는 **구조는 고정, 연산은 외부로 분리**하는 패턴이다.
- **연산 추가**에 강하고, **요소 추가**에는 약하다.
- 이중 디스패치로 요소의 실제 타입 기반 정적/동적 안전한 호출을 보장한다.
- 무순환/반사적 Visitor, 패턴 매칭 등 변형·대안으로 도메인 변화 속도에 맞춰 선택하라.
