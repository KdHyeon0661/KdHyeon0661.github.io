---
layout: post
title: 디자인패턴 - Visitor
date: 2025-06-30 23:20:23 +0900
category: 디자인패턴
---
# Visitor (방문자 패턴)

## ✅ 정의

**Visitor 패턴**은 객체 구조(Element)의 변경 없이, **새로운 기능(연산)**을 추가할 수 있도록 해주는 **행위 패턴(Behavioral Pattern)**입니다.  
객체를 “방문”하는 Visitor 객체를 별도로 정의해, **기능을 객체에서 분리하여 독립적으로 확장**할 수 있도록 합니다.

> “요소 객체의 클래스를 변경하지 않고, 새로운 연산을 객체에 추가할 수 있다.”

---

## 🎯 의도 (Intent)

- 클래스의 구조는 유지하면서 **기능을 유연하게 확장**하고 싶을 때
- **객체 구조와 연산을 분리**하여, 새로운 연산을 쉽게 추가할 수 있도록

---

## 📦 구조 (UML)

```
┌─────────────┐
│   Visitor   │◄─────────────┐
├─────────────┤              │
│visitA(elem) │              │
│visitB(elem) │              │
└─────┬───────┘              │
      ▼                      ▼
┌──────────────┐      ┌──────────────┐
│ElementA      │      │ElementB      │
│accept(v:Vis) │─────▶│accept(v:Vis) │
└──────────────┘      └──────────────┘
```

- `Element`: `accept(visitor)` 메서드를 갖는 요소 인터페이스
- `ConcreteElement`: 실제 방문 가능한 객체
- `Visitor`: 방문 가능한 연산을 정의하는 인터페이스
- `ConcreteVisitor`: 실제 연산 구현 (여러 개 존재 가능)

---

## 🧑‍💻 구현 예시 (Python)

```python
from abc import ABC, abstractmethod

# Visitor 인터페이스
class Visitor(ABC):
    @abstractmethod
    def visit_circle(self, element):
        pass

    @abstractmethod
    def visit_square(self, element):
        pass

# Element 인터페이스
class Shape(ABC):
    @abstractmethod
    def accept(self, visitor):
        pass

# 구체 요소 1
class Circle(Shape):
    def accept(self, visitor):
        visitor.visit_circle(self)
    def draw(self):
        print("🟠 원을 그립니다.")

# 구체 요소 2
class Square(Shape):
    def accept(self, visitor):
        visitor.visit_square(self)
    def draw(self):
        print("🟥 정사각형을 그립니다.")

# 구체 방문자 1: 렌더링
class RenderVisitor(Visitor):
    def visit_circle(self, circle):
        circle.draw()

    def visit_square(self, square):
        square.draw()

# 구체 방문자 2: 면적 계산
class AreaVisitor(Visitor):
    def visit_circle(self, circle):
        print("⚙️ 원의 면적을 계산합니다.")

    def visit_square(self, square):
        print("⚙️ 정사각형의 면적을 계산합니다.")

# 사용 예시
shapes = [Circle(), Square()]

print("📌 렌더링 Visitor 실행")
render = RenderVisitor()
for shape in shapes:
    shape.accept(render)

print("\n📌 면적 계산 Visitor 실행")
area = AreaVisitor()
for shape in shapes:
    shape.accept(area)
```

**출력 예시:**
```
📌 렌더링 Visitor 실행
🟠 원을 그립니다.
🟥 정사각형을 그립니다.

📌 면적 계산 Visitor 실행
⚙️ 원의 면적을 계산합니다.
⚙️ 정사각형의 면적을 계산합니다.
```

---

## ✅ 장점

- 객체 구조를 **수정하지 않고도 기능 확장 가능** (OCP 준수)
- 연산을 객체에서 분리해 **관심사 분리(SRP)** 실현
- 연산 로직을 Visitor 객체에 집중시켜 **코드 가독성 향상**
- **여러 종류의 연산(렌더링, 로그, 검증 등)**을 Visitor로 쉽게 분리

---

## ⚠️ 단점

- **Element 클래스가 Visitor에 의존**하게 됨 (결합도 증가)
- Element의 종류가 자주 바뀌면 **Visitor도 함께 수정해야 함** → OCP 위배
- **이중 디스패치(Double Dispatch)** 개념이 낯설 수 있음

---

## 📌 사용 사례

| 분야 | 예시 |
|------|------|
| 컴파일러 | AST(Abstract Syntax Tree) 순회 및 분석 |
| 렌더링 엔진 | 도형 방문 → 그리기 |
| 문서 처리 | 문서 노드 방문 → 인쇄, 요약 등 |
| 로깅/검증 | 여러 객체 방문하며 로깅 또는 유효성 검증 수행 |
| 게임 개발 | 다양한 오브젝트에 충돌 검사 등 적용 |

---

## 🧠 Visitor vs Strategy vs Command

| 패턴 | 목적 | 유사점 | 차이점 |
|------|------|--------|--------|
| Visitor | 연산 분리 | 연산을 외부에서 정의 | 구조는 고정, 연산은 추가 |
| Strategy | 알고리즘 교체 | 실행 위임 | 런타임에 알고리즘 교체 가능 |
| Command | 요청 캡슐화 | 명령 분리 | 실행, 취소, 저장 중심 |

---

## ✅ 실무 팁

- 도메인 모델이 **자주 바뀌지 않고**, 연산이 자주 추가되는 경우에 적합
- AST, UI 구성 요소, 렌더러, 포맷터, 문서 트리 등에서 매우 효과적
- `accept(visitor)` 메서드는 항상 **Visitor 인터페이스 메서드 호출**로 구성

---

## 🧠 마무리

**Visitor 패턴은 “기능은 바꾸되 구조는 건드리지 말라”는 설계 원칙을 지키며**,  
객체 구조 위에서 다양한 기능을 독립적으로 확장할 수 있도록 해줍니다.

특히 구조가 안정적인 시스템에서 **분석, 검증, 렌더링, 변환 등 다양한 기능을 모듈화**하는 데 매우 유용합니다.
