---
layout: post
title: AspNet - 쿠키 인증
date: 2025-04-02 21:20:23 +0900
category: AspNet
---
# ASP.NET Core 쿠키 인증(Cookie Authentication)

## 목차

1. 핵심 개념 복습(1페이지 요약)
2. 최소 설정(Program.cs) + 미들웨어 순서
3. 쿠키 옵션 총정리(보안/동작/UX)
4. 로그인/로그아웃 실전 패턴(“기억하기”, 절대만료, 사용자 정보 갱신)
5. Anti-Forgery(검증 토큰)와 SameSite 시나리오
6. 권한과의 결합: [Authorize], Roles, Policies
7. Claims/Principal 고급(ClaimsTransformation, 사용자 정보 갱신/무효화)
8. 이벤트 훅(OnValidatePrincipal 등)로 세션 제어
9. 데이터 보호(Data Protection)와 서명 키 운용(스케일 아웃/컨테이너)
10. 서브도메인 SSO/로그아웃, 프런트채널 로직
11. ASP.NET Core Identity와의 차이/연동 팁
12. 다중 인증 스킴(Cookies + Bearer) 공존 전략
13. Swagger/Ajax 환경에서의 401/403/리다이렉트 처리
14. 테스트(단위/통합)와 보안 체크리스트
15. 트러블슈팅 표

---

## 핵심 개념 복습(1페이지 요약)

- **쿠키 인증**: 로그인 성공 시 서버가 **서명된 인증 쿠키**를 발급, 이후 요청마다 쿠키로 사용자 식별.
- **장점**: 브라우저/서버 렌더링(MVC/Razor) 친화, `HttpOnly`/`Secure`로 보호 가능, 자동 첨부.
- **주의**: **HTTPS 필수**, **CSRF 방지**, XSS 방지, 적절한 만료/갱신 정책 필요.
- **미들웨어 순서**: `UseAuthentication()` → `UseAuthorization()`.

---

## + 미들웨어 순서

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services
    .AddAuthentication("MyCookieAuth")
    .AddCookie("MyCookieAuth", options =>
    {
        options.LoginPath         = "/Account/Login";
        options.LogoutPath        = "/Account/Logout";
        options.AccessDeniedPath  = "/Account/AccessDenied";
        options.ExpireTimeSpan    = TimeSpan.FromMinutes(30);
        options.SlidingExpiration = true;

        // 보안 권장
        options.Cookie.Name         = "MyAuthCookie";
        options.Cookie.HttpOnly     = true;
        options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
        options.Cookie.SameSite     = SameSiteMode.Lax; // POST 폼 CSRF 방지 토큰과 함께 사용 권장
    });

builder.Services.AddAuthorization();
builder.Services.AddRazorPages();

var app = builder.Build();

// 순서 중요
app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthentication(); // 사용자 식별
app.UseAuthorization();  // 권한 확인

app.MapRazorPages();
app.Run();
```

> 포인트: `UseAuthentication` → `UseAuthorization` 순서. HTTPS, Secure 쿠키, HttpOnly 쿠키는 사실상 필수.

---

## 쿠키 옵션 총정리(보안/동작/UX)

| 옵션 | 의미/권장 |
|---|---|
| `Cookie.Name` | 인증 쿠키 이름. 명시적으로 부여(충돌 방지). |
| `Cookie.Domain` | `.example.com`으로 지정 시 **서브도메인 공유** 가능(SSO 케이스). 세심한 보안 검토 필요. |
| `Cookie.Path` | 기본 `/`. 필요 시 경로 조정. |
| `Cookie.HttpOnly` | 기본 `true`. JS 접근 차단(XSS 완화). |
| `Cookie.SecurePolicy` | `Always` 권장. HTTPS에서만 전송. |
| `Cookie.SameSite` | `Lax` 기본 권장. **Cross-site POST/iframe** 필요 시 `None`+Secure. |
| `ExpireTimeSpan` | **유휴 기준 만료**(Sliding과 연계). 활동 없으면 만료. |
| `SlidingExpiration` | 요청 시 만료를 **연장**. UX 향상 vs 보안/세션 고정 주의. |
| `ReturnUrlParameter` | 로그인 리다이렉트 이후 복귀 URL 파라미터 이름. |
| `LoginPath`, `LogoutPath`, `AccessDeniedPath` | 인증/권한 흐름 UX. |
| `Events` | `OnValidatePrincipal`, `OnSigningIn`, `OnSignedIn`, `OnRedirectToLogin` 등 훅 지원. |

### 패턴

쿠키 핸들러 자체에는 절대 만료 옵션이 별도로 없으므로 **클레임에 발급 시각/만료 시각**을 넣고 `OnValidatePrincipal`에서 거부하는 패턴 사용(아래 8장 참조).

---

## 로그인/로그아웃 실전 패턴

### 로그인(“기억하기” + 절대 만료)

```csharp
public async Task<IActionResult> Login(LoginInput model)
{
    // 1) 사용자 검증
    var user = await _users.ValidateAsync(model.Username, model.Password);
    if (user is null) return View("Login", new { error = "Invalid" });

    // 2) Claims 구성
    var claims = new List<Claim>
    {
        new(ClaimTypes.NameIdentifier, user.Id),
        new(ClaimTypes.Name, user.UserName),
        new(ClaimTypes.Role, user.Role),
        new("amr", "pwd"), // authentication method reference
        new("issued_at", DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString())
    };

    var identity  = new ClaimsIdentity(claims, "MyCookieAuth");
    var principal = new ClaimsPrincipal(identity);

    // 3) 인증 속성
    var props = new AuthenticationProperties
    {
        IsPersistent = model.RememberMe,             // "기억하기" → 지속 쿠키
        ExpiresUtc   = model.RememberMe
            ? DateTimeOffset.UtcNow.AddDays(14)      // 절대 만료(예)
            : DateTimeOffset.UtcNow.AddHours(1)      // 짧게
        // AllowRefresh = true (기본)
    };

    await HttpContext.SignInAsync("MyCookieAuth", principal, props);
    return LocalRedirect(model.ReturnUrl ?? "/");
}
```

> `IsPersistent=true`이면 브라우저 종료 후에도 **만료 시점까지** 쿠키가 유지(지속 쿠키).

### 로그아웃

```csharp
public async Task<IActionResult> Logout()
{
    await HttpContext.SignOutAsync("MyCookieAuth");
    return RedirectToPage("/Index");
}
```

### 사용자 정보 갱신(권한 변경 즉시 반영)

- 권한/역할 변경 시점에 **기존 쿠키 무효화** 또는 재발급 필요.
- 옵션:
  1) **재로그인 요구**(로그아웃 후 로그인)
  2) **SignInAsync**로 **새 Claims** 재발급
  3) `OnValidatePrincipal`에서 백엔드 기준으로 무효화(7/8장에서 설명)

---

## Anti-Forgery와 SameSite 시나리오

쿠키 인증은 **CSRF 방어**가 핵심이다.

### 폼 기반 POST — Anti-Forgery Token

```csharp
// Razor
<form asp-action="UpdateProfile" method="post">
    @Html.AntiForgeryToken()
    <!-- fields -->
    <button type="submit">Save</button>
</form>
```

```csharp
// Controller
[ValidateAntiForgeryToken]
[HttpPost]
public IActionResult UpdateProfile(ProfileInput model) { ... }
```

> Anti-Forgery는 **서버가 발행한 토큰**을 **폼에 숨김 필드**로 보내고, 요청 시 유효성 검증.

### SameSite 전략

- 기본 `SameSite=Lax`: **Top-level** 네비게이션 POST는 차단될 수 있음(브라우저별). 폼 POST는 대체로 허용되지만 환경별 차 존재.
- **외부 도메인 → 로그인 콜백/iframe** 시나리오 필요: `SameSite=None` + `Secure` 필수.
- CSRF는 Anti-Forgery 토큰으로 보호. API 호출에는 **Double Submit Cookie** 또는 **Bearer** 권장.

```csharp
options.Cookie.SameSite = SameSiteMode.Lax; // 일반적
// 외부 콜백/iframe 필요 시
// options.Cookie.SameSite = SameSiteMode.None; // + Secure
```

---

## 권한과의 결합: [Authorize], Roles, Policies

```csharp
[Authorize] // 로그인 필요
public class DashboardController : Controller
{
    [Authorize(Roles = "Admin")]
    public IActionResult AdminOnly() => View();

    [Authorize(Policy = "CanDelete")]
    public IActionResult Dangerous() => View();
}
```

등록:

```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("CanDelete", p =>
        p.RequireClaim("permission", "delete:order"));
});
```

> 포인트: **역할(Role)**은 coarse-grained, **권한/클레임**은 fine-grained. 둘을 혼합해 정책을 설계.

---

## Claims/Principal 고급

### ClaimsTransformation으로 동적 Claims 추가

```csharp
public sealed class MyClaimsTransformer : IClaimsTransformation
{
    private readonly IPermissionService _perm;
    public MyClaimsTransformer(IPermissionService perm) => _perm = perm;

    public async Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)
    {
        if (principal.Identity?.IsAuthenticated != true) return principal;

        // 매 요청 DB 조회는 부담 → 캐시 권장
        var userId = principal.FindFirstValue(ClaimTypes.NameIdentifier)!;
        var perms = await _perm.GetPermissionsAsync(userId);

        var id = (ClaimsIdentity)principal.Identity;
        foreach (var p in perms)
            if (!id.HasClaim("permission", p))
                id.AddClaim(new Claim("permission", p));

        return principal;
    }
}
```

등록:

```csharp
builder.Services.AddScoped<IClaimsTransformation, MyClaimsTransformer>();
```

> **주의**: 매 요청 DB hit 방지 위해 메모리/분산 캐시 사용.

### 강제 무효화(“Password/Role 변경 시 전체 재로그인”)

- 사용자 레코드에 `security_stamp`/`version` 필드 유지.
- 로그인 시 쿠키에 `sec_ver:123` 클레임 부여.
- `OnValidatePrincipal`에서 DB의 최신 값과 다르면 `context.RejectPrincipal()`로 무효화 → 리다이렉트 Login.

---

## 쿠키 이벤트 훅(OnValidatePrincipal 등)

```csharp
builder.Services.AddAuthentication("MyCookieAuth")
    .AddCookie("MyCookieAuth", options =>
    {
        options.Events = new CookieAuthenticationEvents
        {
            OnValidatePrincipal = async context =>
            {
                var userId = context.Principal?.FindFirstValue(ClaimTypes.NameIdentifier);
                if (string.IsNullOrEmpty(userId))
                {
                    context.RejectPrincipal();
                    await context.HttpContext.SignOutAsync("MyCookieAuth");
                    return;
                }

                // 절대 만료(예: 발급 8시간 초과 차단)
                var issued = context.Principal!.FindFirst("issued_at")?.Value;
                if (long.TryParse(issued, out var iat))
                {
                    var issuedAt = DateTimeOffset.FromUnixTimeSeconds(iat);
                    if (DateTimeOffset.UtcNow - issuedAt > TimeSpan.FromHours(8))
                    {
                        context.RejectPrincipal();
                        await context.HttpContext.SignOutAsync("MyCookieAuth");
                        return;
                    }
                }

                // 사용자 상태/버전 체크(간소화)
                var userOk = await context.HttpContext.RequestServices
                    .GetRequiredService<IUserStatusService>()
                    .IsValidAsync(userId!);

                if (!userOk)
                {
                    context.RejectPrincipal();
                    await context.HttpContext.SignOutAsync("MyCookieAuth");
                }
            },

            OnRedirectToLogin = ctx =>
            {
                // API 요청인 경우 401 반환(리다이렉트 금지)
                if (IsApiRequest(ctx.Request))
                {
                    ctx.Response.StatusCode = StatusCodes.Status401Unauthorized;
                    return Task.CompletedTask;
                }
                ctx.Response.Redirect(ctx.RedirectUri);
                return Task.CompletedTask;
            },

            OnRedirectToAccessDenied = ctx =>
            {
                if (IsApiRequest(ctx.Request))
                {
                    ctx.Response.StatusCode = StatusCodes.Status403Forbidden;
                    return Task.CompletedTask;
                }
                ctx.Response.Redirect(ctx.RedirectUri);
                return Task.CompletedTask;
            }
        };
    });

static bool IsApiRequest(HttpRequest req)
    => req.Path.StartsWithSegments("/api")
       || string.Equals(req.Headers["X-Requested-With"], "XMLHttpRequest", StringComparison.OrdinalIgnoreCase);
```

> **핵심**: MVC 페이지는 리다이렉트 UX가 적절, **API는 401/403 JSON**이 적절.

---

## 데이터 보호(Data Protection)와 서명 키 운용

쿠키는 **DPAPI/키 링**으로 서명/암호화된다. 스케일아웃(다중 인스턴스) 시 **키 공유**가 필수.

```csharp
builder.Services.AddDataProtection()
    .PersistKeysToFileSystem(new DirectoryInfo(@"/keys")) // 컨테이너/VM 공유 스토리지
    .SetApplicationName("MyApp"); // 여러 앱 간 키 충돌 방지
```

클라우드:
- Azure: `PersistKeysToAzureBlobStorage`, `ProtectKeysWithAzureKeyVault`
- AWS: S3/KMS 기반 구현 가능(서드파티)

키 롤오버/만료 주기와 **시간 동기화** 주의.

---

## 서브도메인 SSO/로그아웃

- `Cookie.Domain = ".example.com"` 설정 시 `app1.example.com`, `app2.example.com` 공유 가능.
- **주의**: 보안 범위가 넓어지므로 취약점 영향 범위 증가.
- 로그아웃:
  - 공용 로그아웃 엔드포인트에서 `Set-Cookie` 만료, 또는
  - 각 앱 호출(프런트 채널)로 **동시 무효화** 구현.

```csharp
options.Cookie.Domain = ".example.com";
```

---

## ASP.NET Core Identity와의 차이/연동

- **Identity**는 사용자 저장소, 비밀번호 해시, 2FA, 잠금/실패 카운트, SecurityStamp 등 **완결된 계정 시스템** 제공.
- 쿠키 인증은 **핸들러 레벨**. 직접 사용자 저장/검증/정책을 구현해야 한다.
- Identity 사용 시:
  - `AddDefaultIdentity`(또는 `AddIdentity`) + `AddEntityFrameworkStores`
  - `SignInManager`/`UserManager` 이용
  - **SecurityStampValidator**가 자동으로 쿠키 갱신/무효화 관제.

---

## 공존

웹(MVC)과 API 공존 시:

```csharp
builder.Services.AddAuthentication()
    .AddCookie("Cookies", o => { /* ... */ })
    .AddJwtBearer("Bearer", o => { /* ... */ });

builder.Services.AddAuthorization();

// MVC
[Authorize(AuthenticationSchemes = "Cookies")]
public class HomeController : Controller { ... }

// API
[Authorize(AuthenticationSchemes = "Bearer")]
[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase { ... }
```

정책에 스킴 강제:

```csharp
options.AddPolicy("WebOnly", p =>
{
    p.AddAuthenticationSchemes("Cookies");
    p.RequireAuthenticatedUser();
});
```

---

## Swagger/JS/Ajax 환경에서의 401/403/리다이렉트 제어

- 기본 쿠키 핸들러는 **401/403 시 로그인 페이지로 리다이렉트** → Swagger/JS 요청에서는 원치 않음.
- 위 8장의 `OnRedirectToLogin/AccessDenied` 커스터마이징으로 **API 경로/헤더**에 대해 **순수 401/403** 반환.

추가: 에러 표준화(ProblemDetails)

```csharp
app.UseStatusCodePages(async ctx =>
{
    var res = ctx.HttpContext.Response;
    if (res.StatusCode is 401 or 403)
    {
        res.ContentType = "application/problem+json";
        await res.WriteAsJsonAsync(new ProblemDetails
        {
            Status = res.StatusCode,
            Title  = res.StatusCode == 401 ? "Unauthorized" : "Forbidden",
            Detail = res.StatusCode == 401 ? "로그인이 필요합니다." : "접근 권한이 없습니다."
        });
    }
});
```

---

## 테스트(단위/통합)와 보안 체크리스트

### 통합 테스트에서 인증 주입

```csharp
public class FakeAuthHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    public FakeAuthHandler(IOptionsMonitor<AuthenticationSchemeOptions> options, ILoggerFactory logger,
        UrlEncoder encoder, ISystemClock clock)
        : base(options, logger, encoder, clock) { }

    protected override Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var claims = new[] { new Claim(ClaimTypes.Name, "tester"), new Claim(ClaimTypes.Role, "Admin") };
        var identity = new ClaimsIdentity(claims, "Test");
        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, "Test");
        return Task.FromResult(AuthenticateResult.Success(ticket));
    }
}
```

등록:

```csharp
builder.Services.AddAuthentication("Test")
    .AddScheme<AuthenticationSchemeOptions, FakeAuthHandler>("Test", _ => { });
```

엔드포인트에 `[Authorize(AuthenticationSchemes = "Test")]` 부착하거나, 테스트 전용 환경에서 기본 스킴을 `Test`로 설정.

### 보안 체크리스트

- [ ] HTTPS 강제, Secure/HttpOnly 쿠키
- [ ] SameSite 전략과 Anti-Forgery 적용
- [ ] 로그인 시 `IsPersistent`/만료 정책 명확화
- [ ] SlidingExpiration vs 절대만료(ValidatePrincipal) 균형
- [ ] 사용자 정보 변경 시 쿠키 무효화/갱신 플로우
- [ ] 키 링 공유(스케일아웃), 키 백업/롤오버
- [ ] API 401/403 리다이렉트 차단
- [ ] XSS/Content-Security-Policy 헤더, 입력 검증
- [ ] 로그/감사: UserId, SessionId(선택), IP/UA(개인정보 보호 준수)

---

## 트러블슈팅 표

| 증상 | 원인 | 해결 |
|---|---|---|
| 로그인 후 API가 로그인 페이지 HTML을 받음 | 401/403 리다이렉트 동작 | `OnRedirectToLogin/AccessDenied`에서 API는 순수 코드 반환 |
| 배포 후 일부 서버에서만 인증 실패 | 키 링 불일치 | `AddDataProtection().PersistKeys...`로 키 공유 |
| 쿠키가 전송되지 않음 | SameSite/도메인/보안 속성 불일치 | Cross-site면 `SameSite=None; Secure`, 도메인/경로 재확인 |
| 권한 변경이 바로 반영 안 됨 | 쿠키에 오래된 Claims 유지 | 재로그인, `SignInAsync` 재발급, `OnValidatePrincipal`로 무효화 |
| Sliding인데 자주 로그아웃됨 | 절대만료 미스/서버 시간 불일치 | 서버 시간 동기화, Expires/ValidatePrincipal 로직 점검 |
| RememberMe가 동작 안 함 | `IsPersistent`/`ExpiresUtc` 미설정 | AuthProperties 점검 |

---

## 종합 예제 — Razor Pages 로그인/권한 보호/Anti-Forgery

### Pages/Account/Login.cshtml.cs

```csharp
public class LoginModel : PageModel
{
    [BindProperty] public string Username { get; set; } = "";
    [BindProperty] public string Password { get; set; } = "";
    [BindProperty] public bool RememberMe { get; set; }
    public string? ReturnUrl { get; set; }

    public void OnGet(string? returnUrl = null) => ReturnUrl = returnUrl;

    public async Task<IActionResult> OnPostAsync(string? returnUrl = null)
    {
        if (!ModelState.IsValid) return Page();

        // TODO: 실서비스는 해시 비교, 잠금/실패카운트 등
        if (Username != "admin" || Password != "1234")
        {
            ModelState.AddModelError("", "Invalid credentials");
            return Page();
        }

        var claims = new List<Claim>
        {
            new(ClaimTypes.NameIdentifier, "user-1"),
            new(ClaimTypes.Name, Username),
            new(ClaimTypes.Role, "Admin"),
            new("issued_at", DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString())
        };

        var identity  = new ClaimsIdentity(claims, "MyCookieAuth");
        var principal = new ClaimsPrincipal(identity);

        var props = new AuthenticationProperties
        {
            IsPersistent = RememberMe,
            ExpiresUtc   = RememberMe
                ? DateTimeOffset.UtcNow.AddDays(14)
                : DateTimeOffset.UtcNow.AddHours(1)
        };

        await HttpContext.SignInAsync("MyCookieAuth", principal, props);
        return LocalRedirect(returnUrl ?? "/");
    }
}
```

### Pages/Admin/Index.cshtml.cs

```csharp
[Authorize(Roles = "Admin")]
public class IndexModel : PageModel
{
    public void OnGet() { }
}
```

### — Anti-Forgery API/리다이렉트 처리 포함

```csharp
builder.Services.AddRazorPages(options =>
{
    options.Conventions.AuthorizeFolder("/Admin"); // 폴더 보호
});

builder.Services.AddAntiforgery(o =>
{
    o.HeaderName = "X-CSRF-TOKEN"; // Ajax 시 헤더로 전송 가능
});

builder.Services
    .AddAuthentication("MyCookieAuth")
    .AddCookie("MyCookieAuth", o =>
    {
        o.LoginPath         = "/Account/Login";
        o.AccessDeniedPath  = "/Account/AccessDenied";
        o.Cookie.Name       = "MyAuthCookie";
        o.Cookie.HttpOnly   = true;
        o.Cookie.SecurePolicy = CookieSecurePolicy.Always;
        o.Cookie.SameSite   = SameSiteMode.Lax;

        o.Events = new CookieAuthenticationEvents
        {
            OnRedirectToLogin = ctx =>
            {
                if (ctx.Request.Path.StartsWithSegments("/api"))
                {
                    ctx.Response.StatusCode = StatusCodes.Status401Unauthorized;
                    return Task.CompletedTask;
                }
                ctx.Response.Redirect(ctx.RedirectUri);
                return Task.CompletedTask;
            },
            OnRedirectToAccessDenied = ctx =>
            {
                if (ctx.Request.Path.StartsWithSegments("/api"))
                {
                    ctx.Response.StatusCode = StatusCodes.Status403Forbidden;
                    return Task.CompletedTask;
                }
                ctx.Response.Redirect(ctx.RedirectUri);
                return Task.CompletedTask;
            }
        };
    });
```

---

## 마무리 요약

| 주제 | 핵심 |
|---|---|
| 보안 기본 | HTTPS, Secure/HttpOnly, 적절한 SameSite, Anti-Forgery |
| 만료/갱신 | Sliding + 절대만료(ValidatePrincipal) 조합, RememberMe 시 ExpiresUtc |
| 권한 | Roles + Claims/Policy 혼합, 리다이렉트/401/403 구분 |
| 운영 | 키 링 공유, 사용자 변경 시 쿠키 무효화, 로그/감사 |
| 공존 | Cookies(웹) + Bearer(API) 스킴 분리, 엔드포인트별 지정 |
| 테스트 | 가짜 인증 스킴, 통합 테스트로 401/403/리다이렉트 검증 |

쿠키 인증은 **서버 렌더링 웹에 최적**, 올바른 **CSRF/XSS 방어와 만료 전략**만 갖추면 안전하고 사용자 친화적인 로그인 경험을 제공한다. 운영 환경에서는 **키/세션 관리, 권한 변화 반영, 에러 표준화**를 통해 유지보수성과 보안을 함께 확보하자.
