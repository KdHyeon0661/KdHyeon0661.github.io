---
layout: post
title: DB - 데이터 모델링
date: 2025-01-24 19:20:23 +0900
category: DB
---
# 데이터베이스 모델링

## 0. 리마인드(핵심 요약)

- 모델링은 **현실 세계를 데이터 구조로 추상화**하는 일이며, **엔티티/속성/식별자/관계**를 올바로 정의하는 것이 성패를 좌우한다.
- 모델은 **개념적 → 논리적 → 물리적**으로 점진 정제되며, **정규화**를 통해 이상현상/중복을 줄이고 필요 시 **반정규화**로 성능을 절충한다.
- ERD는 협업의 공통 언어다. **카디널리티/옵셔널리티**를 명확히 하여 오해를 줄인다.
- 물리 설계에서는 **키 전략, 제약, 인덱스, 파티셔닝, 데이터 타입, 보안/권한, 운영 관점**까지 함께 고려한다.

---

## 1. 요구사항 → 개념 모델: 업무 언어로 시작하기

### 1.1 요구사항 정리 체크리스트
- **업무 용어 사전(Glossary)**: 같은 단어가 다른 의미로 쓰이지 않게 통일.
- **이벤트/행위**와 **상태** 구분: “주문한다(행위)”, “주문 상태(상태)”.
- **핵심 식별자**: 주문번호, 고객번호 등 자연키 후보.
- **제약 요건**: 고유성, 중복 금지, 기간 겹침 금지, 승인 흐름 등.
- **규모/성능**: 연간 행 수, 피크 QPS, 보관 주기, 보고서 필요.
- **보안/프라이버시**: PII, 접근 등급, 암호화, 감사.

### 1.2 개념 엔티티/관계 도출 규칙
- **명사=엔티티**, **동사=관계**를 기본 가설로 삼되, “동사+속성(수강일자/성적)”은 **조인 엔터티**(행위의 상태)로 고려.
- **경계(Bounded Context)** 설정: 한 모델에 과도한 도메인을 섞지 않는다.

### 1.3 개념 ERD 스케치(문자 다이어그램)
```text
[고객]───(주문한다)───[주문]───(포함한다)───[주문항목]───(대상)───[상품]
  |                                       ^
  └──(보유)──[쿠폰]                         |
                      [결제]──(종류)──[카드결제/계좌이체(서브타입)]
```

---

## 2. 논리 모델: 정규화와 제약으로 의미를 고정

### 2.1 명명 규칙(권장)
- 엔티티/테이블: **단수형 스네이크/파스칼** 중 팀 표준 유지(예: `Customer`, `Order`, `order_item`).
- 컬럼: **명확한 의미 + 단위**(예: `price_cents`, `weight_kg`), 약어 최소화.
- PK: `*_id`(정수/UUID). FK: 대상 테이블명 + `_id`.

### 2.2 도메인/타입 정의
- **도메인 카탈로그**를 만들어 재사용(전화/이메일/통화/국가코드 등).
- 금액/수량은 정밀도 명확화(NUMERIC(12,2) 등). 타임스탬프는 타임존 포함 여부 합의.

### 2.3 키 전략
- **서로게이트 키(PK)** 기본, 업무 유일성은 **UNIQUE** 제약.
- 복합 자연키가 필수일 때만 PK로 사용(ORM/조인 비용 고려).
- UUID는 글로벌 분산에 유리하나 **인덱스 지역성** 저하에 주의(버전7/ULID 검토).

### 2.4 정규화(핵심)
- 1NF: 원자값만 저장.
- 2NF: 복합키의 부분 종속 제거.
- 3NF: 이행 종속 제거(비주요 속성은 오직 PK에만 종속).
- 개념적 표현:
  $$
  \text{모든 비주요 속성 } A \text{에 대해 } A \not\to B \ (\text{for any non-key } B),\quad A \to \text{PK}
  $$

### 2.5 관계/옵셔널리티의 논리적 구현
- 최소 참여수 1 → FK `NOT NULL` + RESTRICT/NO ACTION.
- 최소 참여수 0 → FK `NULL` 허용 + 적절한 삭제 동작(SET NULL/RESTRICT).
- 1:1 강제 → **PK=FK** 또는 **UNIQUE FK**.

---

## 3. 물리 모델: 제약/인덱스/파티션/보안/템포럴

### 3.1 제약 맵
- PK/UNIQUE/CHECK/FOREIGN KEY(ON DELETE/UPDATE).
- 템포럴 제약(기간 겹침 금지): DB 기능(Exclusion, generated columns + constraint) 활용.

### 3.2 인덱스 전략
- 모든 FK에 인덱스(삭제/갱신/조인 성능).
- 조회 패턴 기반 복합 인덱스(필터→정렬 순).
- 과도한 인덱스는 쓰기/공간 비용 상승.

### 3.3 파티셔닝
- 범위(날짜)/해시(키)/리스트(지역) 기반.
- 쿼리 대부분이 특정 파티션만 스캔하도록 **파티션 키=주요 필터** 정렬.

### 3.4 템포럴/감사
- **SCD(Type 2)**: 변경 이력 유지(시작/종료 시점).
- **템포럴 테이블**(DB 지원 시): 시스템 버전 관리(자동 이력).
- 감사 테이블/로그: 누가 언제 무엇을 변경했는가.

### 3.5 보안/권한
- 최소권한(스키마/테이블/열/행 수준).
- TDE/전송구간 암호화, PII 마스킹/해싱, 감사 로그.

---

## 4. 주문 시스템 모델링(확장 완전판)

### 4.1 논리→물리 스키마(SQL)

```sql
-- 고객
CREATE TABLE customer (
  customer_id     BIGSERIAL PRIMARY KEY,
  email           TEXT NOT NULL UNIQUE,
  name            TEXT NOT NULL,
  phone_e164      TEXT,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_deleted      BOOLEAN NOT NULL DEFAULT FALSE
);

-- 주소(1:N, 고객은 주소 0개 이상)
CREATE TABLE customer_address (
  address_id      BIGSERIAL PRIMARY KEY,
  customer_id     BIGINT NOT NULL,
  receiver_name   TEXT NOT NULL,
  line1           TEXT NOT NULL,
  line2           TEXT,
  city            TEXT NOT NULL,
  state           TEXT,
  postal_code     TEXT NOT NULL,
  country_code    CHAR(2) NOT NULL,
  is_default      BOOLEAN NOT NULL DEFAULT FALSE,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON DELETE CASCADE
);
CREATE INDEX idx_caddr_customer ON customer_address(customer_id);
CREATE UNIQUE INDEX uq_caddr_default ON customer_address(customer_id) WHERE is_default;

-- 상품/카테고리/태그
CREATE TABLE product (
  product_id      BIGSERIAL PRIMARY KEY,
  sku             TEXT NOT NULL UNIQUE,
  name            TEXT NOT NULL,
  description     TEXT,
  price           NUMERIC(12,2) NOT NULL CHECK (price >= 0),
  currency        CHAR(3) NOT NULL DEFAULT 'KRW',
  created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_active       BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE category (
  category_id     BIGSERIAL PRIMARY KEY,
  name            TEXT NOT NULL,
  parent_id       BIGINT,
  FOREIGN KEY (parent_id) REFERENCES category(category_id) ON DELETE SET NULL
);

CREATE TABLE product_category (
  product_id      BIGINT NOT NULL,
  category_id     BIGINT NOT NULL,
  PRIMARY KEY (product_id, category_id),
  FOREIGN KEY (product_id)  REFERENCES product(product_id)  ON DELETE CASCADE,
  FOREIGN KEY (category_id) REFERENCES category(category_id) ON DELETE RESTRICT
);

CREATE TABLE tag (
  tag_id          BIGSERIAL PRIMARY KEY,
  name            TEXT NOT NULL UNIQUE
);

CREATE TABLE product_tag (
  product_id      BIGINT NOT NULL,
  tag_id          BIGINT NOT NULL,
  PRIMARY KEY (product_id, tag_id),
  FOREIGN KEY (product_id) REFERENCES product(product_id) ON DELETE CASCADE,
  FOREIGN KEY (tag_id)     REFERENCES tag(tag_id)         ON DELETE CASCADE
);

-- 쿠폰(템포럴)
CREATE TABLE coupon (
  coupon_id       BIGSERIAL PRIMARY KEY,
  code            TEXT NOT NULL UNIQUE,
  discount_type   TEXT NOT NULL CHECK (discount_type IN ('FIXED','PERCENT')),
  discount_value  NUMERIC(12,2) NOT NULL CHECK (discount_value >= 0),
  start_at        TIMESTAMPTZ NOT NULL,
  end_at          TIMESTAMPTZ NOT NULL,
  CHECK (end_at > start_at)
);

CREATE TABLE customer_coupon (
  customer_id     BIGINT NOT NULL,
  coupon_id       BIGINT NOT NULL,
  assigned_at     TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  used_at         TIMESTAMPTZ,
  PRIMARY KEY (customer_id, coupon_id),
  FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON DELETE CASCADE,
  FOREIGN KEY (coupon_id)   REFERENCES coupon(coupon_id)     ON DELETE RESTRICT
);

-- 주문
CREATE TABLE "order" (
  order_id        BIGSERIAL PRIMARY KEY,
  customer_id     BIGINT NOT NULL,
  order_no        TEXT NOT NULL UNIQUE,  -- 외부 노출용
  ordered_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  status          TEXT NOT NULL CHECK (status IN ('PENDING','PAID','CANCELLED','SHIPPED','COMPLETED')),
  shipping_addr_id BIGINT,               -- 스냅샷/복제 모델링도 가능
  note            TEXT,
  FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON DELETE RESTRICT,
  FOREIGN KEY (shipping_addr_id) REFERENCES customer_address(address_id) ON DELETE SET NULL
);
CREATE INDEX idx_order_customer ON "order"(customer_id);

-- 주문 항목
CREATE TABLE order_item (
  order_id        BIGINT NOT NULL,
  product_id      BIGINT NOT NULL,
  qty             INT    NOT NULL CHECK (qty > 0),
  price_at        NUMERIC(12,2) NOT NULL CHECK (price_at >= 0),
  PRIMARY KEY (order_id, product_id),
  FOREIGN KEY (order_id)   REFERENCES "order"(order_id)   ON DELETE CASCADE,
  FOREIGN KEY (product_id) REFERENCES product(product_id) ON DELETE RESTRICT
);

-- 결제(슈퍼/서브타입)
CREATE TABLE payment (
  payment_id      BIGSERIAL PRIMARY KEY,
  order_id        BIGINT NOT NULL UNIQUE,
  amount          NUMERIC(12,2) NOT NULL,
  paid_at         TIMESTAMPTZ NOT NULL,
  method          TEXT NOT NULL CHECK (method IN ('CARD','BANK')),
  FOREIGN KEY (order_id) REFERENCES "order"(order_id) ON DELETE CASCADE
);

CREATE TABLE card_payment (
  payment_id      BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  card_no_hash    TEXT NOT NULL,
  auth_code       TEXT NOT NULL
);

CREATE TABLE bank_payment (
  payment_id      BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  bank_code       TEXT NOT NULL,
  account_no      TEXT NOT NULL
);

-- 감사(간단 예)
CREATE TABLE audit_log (
  audit_id        BIGSERIAL PRIMARY KEY,
  actor           TEXT NOT NULL,
  action          TEXT NOT NULL,
  entity          TEXT NOT NULL,
  entity_id       TEXT NOT NULL,
  at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  detail          JSONB
);
```

### 4.2 시드 데이터/대표 질의

```sql
-- 시드
INSERT INTO customer (email, name) VALUES
('kim@example.com','Kim'),('lee@example.com','Lee');

INSERT INTO product (sku,name,price) VALUES
('SKU-001','Keyboard',39000),('SKU-002','Mouse',19000),('SKU-003','Monitor',259000);

-- 주문 생성
WITH o AS (
  INSERT INTO "order"(customer_id, order_no, status)
  VALUES (1, 'ORD-2025-0001', 'PENDING')
  RETURNING order_id
)
INSERT INTO order_item(order_id, product_id, qty, price_at)
SELECT o.order_id, p.product_id, x.qty, p.price
FROM o
JOIN LATERAL (VALUES (1,2),(2,1)) AS x(product_id, qty) ON TRUE
JOIN product p ON p.product_id = x.product_id;

-- 결제
INSERT INTO payment(order_id, amount, paid_at, method)
VALUES (1, 39000*2 + 19000*1, NOW(), 'CARD');

INSERT INTO card_payment(payment_id, card_no_hash, auth_code)
SELECT payment_id, 'hash(****-****-****-1234)', 'OK1234' FROM payment WHERE order_id=1;

UPDATE "order" SET status='PAID' WHERE order_id=1;

-- 대표 질의 1: 고객의 최근 주문 5건과 총액
SELECT o.order_no, o.ordered_at,
       SUM(oi.qty * oi.price_at) AS total
FROM "order" o
JOIN order_item oi ON oi.order_id = o.order_id
WHERE o.customer_id = 1
GROUP BY o.order_id
ORDER BY o.ordered_at DESC
LIMIT 5;

-- 대표 질의 2: 카테고리 트리 경로(재귀)
WITH RECURSIVE path AS (
  SELECT category_id, name, parent_id, 1 depth
  FROM category WHERE category_id = 10
  UNION ALL
  SELECT c.category_id, c.name, c.parent_id, p.depth+1
  FROM category c JOIN path p ON c.parent_id = p.category_id
)
SELECT * FROM path;

-- 대표 질의 3: 활성 쿠폰 보유 고객 수
SELECT COUNT(DISTINCT cc.customer_id) AS active_coupon_users
FROM customer_coupon cc
JOIN coupon c ON c.coupon_id = cc.coupon_id
WHERE NOW() BETWEEN c.start_at AND c.end_at
  AND cc.used_at IS NULL;
```

---

## 5. 정규화 vs 반정규화: 언제, 어떻게

### 5.1 정규화의 이점
- 삽입/갱신/삭제 이상현상 제거, 데이터 일관성 향상.
- 스키마가 업무 규칙을 더 정확히 반영.

### 5.2 반정규화 트리거
- 잦은 조인으로 인한 응답 지연, 보고서용 안정 집계, 캐시 친화 구조 필요.
- **복제 필드**(예: 주문에 고객명 스냅샷) 도입 시 원본 변경 동기화 전략 필요.

```sql
ALTER TABLE "order" ADD COLUMN customer_name_copy TEXT;

-- 동기화 예시(데이터베이스별 트리거 문법 상이)
-- UPDATE customer SET name=... 시 order.customer_name_copy 동기화
```

---

## 6. 카디널리티/옵셔널리티 고급 주제

### 6.1 1:1
- 강제 1:1: **PK=FK**(항상 존재), 선택 1:1: **UNIQUE FK + NULL 허용**.
- 민감정보/저빈도 갱신을 별 테이블로 분리.

### 6.2 1:N
- FK는 항상 N쪽에.
- 삭제 규칙(CASCADE/RESTRICT/SET NULL)을 도메인별로 명문화.

### 6.3 N:M
- **조인 엔터티**로 해소, 업무 속성(수강일자/성적/상태) 포함.
- 중복 방지: `(a_id, b_id, ...)` **PK/UNIQUE**.

```sql
-- 재수강 허용 시 회차 포함
CREATE TABLE student_course (
  student_id BIGINT NOT NULL,
  course_id  BIGINT NOT NULL,
  attempt_no INT    NOT NULL,
  enroll_date DATE  NOT NULL,
  grade      TEXT,
  PRIMARY KEY (student_id, course_id, attempt_no)
);
```

---

## 7. 템포럴/기간 겹침 금지(수학적 관점)

기간 \( [s_1, e_1), [s_2, e_2) \) 가 겹치지 않으려면:
$$
e_1 \le s_2 \ \lor \ e_2 \le s_1
$$
DB 차원에서는 **배타 제약**(Exclusion) 또는 체크/트리거로 근사한다.

```sql
-- PostgreSQL 예시(배타 제약)
-- CREATE EXTENSION btree_gist;
-- EXCLUDE USING gist (emp_id WITH =, tstzrange(start_at, end_at) WITH &&);
```

---

## 8. 인덱스/조인 계획/락

- **FK 인덱스 필수**: 부모 삭제/업데이트 시 자식 탐색 비용↓, 락 확장 방지.
- 복합 인덱스는 “필터 컬럼 → 정렬 컬럼” 순서.
- 배치 삭제는 작은 청크 + 트랜잭션 분할, 아카이빙 테이블 고려.

```sql
CREATE INDEX idx_orderitem_order ON order_item(order_id);
CREATE INDEX idx_order_status ON "order"(status, ordered_at DESC);
```

---

## 9. 파티셔닝/아카이빙/보관 정책

- **날짜 파티션**: 주문/로그/이벤트. 최근 파티션만 핫.
- **해시 파티션**: 특정 키 기반 균등 분배.
- **아카이빙**: 과거 데이터는 리드온리 스키마/저렴 스토리지로 이동.

```sql
-- 날짜 기반 파티션(데이터베이스별 문법 상이)
-- CREATE TABLE order_2025_11 PARTITION OF "order" FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
```

---

## 10. 다차원 모델링(분석계)

- **사실 테이블(Fact)** + **차원(Dimension)**.
- SCD Type 2로 차원 변경 이력 추적.
- 운영계(OLTP) 모델과 별도로 설계/적재 파이프라인 구성.

```sql
-- SCD 차원(간략)
CREATE TABLE dim_customer (
  sk_customer    BIGSERIAL PRIMARY KEY,
  customer_id    BIGINT NOT NULL,
  name           TEXT NOT NULL,
  effective_from DATE NOT NULL,
  effective_to   DATE,
  is_current     BOOLEAN NOT NULL,
  UNIQUE(customer_id, effective_from)
);
```

---

## 11. 품질/테스트 SQL 스니펫

```sql
-- 1) 고아 레코드 탐지
SELECT o.order_id
FROM "order" o
LEFT JOIN customer c ON c.customer_id = o.customer_id
WHERE c.customer_id IS NULL;

-- 2) N:M 중복 연결 탐지
SELECT product_id, tag_id, COUNT(*) cnt
FROM product_tag
GROUP BY product_id, tag_id
HAVING COUNT(*) > 1;

-- 3) FK 인덱스 누락 후보(예시용: 카탈로그 조회 필요)
-- 실제 환경에선 DB 카탈로그 테이블을 조회해 FK/인덱스 대응 여부 점검

-- 4) 성능 회귀 감지(대표 질의 EXPLAIN 계획 비교)
EXPLAIN ANALYZE
SELECT o.order_no, SUM(oi.qty*oi.price_at)
FROM "order" o
JOIN order_item oi ON oi.order_id = o.order_id
WHERE o.customer_id = 1
GROUP BY o.order_id;
```

---

## 12. 마이그레이션/버전 관리

### 12.1 안전 절차
1) 새 스키마/제약/인덱스 **병행 도입**  
2) **데이터 이관**(카운트/합계/무결성 검증)  
3) **읽기 전환 → 쓰기 전환**  
4) 구 스키마 제거, 롤백 경로 문서화

### 12.2 예: 1:N → N:M 전환
```sql
-- 기존 order에 product_id FK가 있던 모델을 N:M으로 분해
CREATE TABLE order_item_new (
  order_id   BIGINT NOT NULL,
  product_id BIGINT NOT NULL,
  qty        INT    NOT NULL CHECK (qty > 0),
  price_at   NUMERIC(12,2) NOT NULL,
  PRIMARY KEY (order_id, product_id),
  FOREIGN KEY (order_id)   REFERENCES "order"(order_id),
  FOREIGN KEY (product_id) REFERENCES product(product_id)
);

-- 데이터 이관
INSERT INTO order_item_new(order_id, product_id, qty, price_at)
SELECT order_id, product_id, 1 AS qty, price_at
FROM "order" WHERE product_id IS NOT NULL;

-- 코드 전환 후 구 컬럼 제거
ALTER TABLE "order" DROP COLUMN product_id;
```

---

## 13. ORM/애플리케이션 연동 고려

- 1:N은 `ManyToOne(FK=N쪽), OneToMany`로 매핑.
- N:M은 **조인 엔터티**를 명시적 클래스로 설계(추가 속성 수월).
- **지연 로딩** 기본 + 전용 조회(페치 조인/리포지토리 쿼리)로 N+1 방지.
- 트랜잭션 경계/격리수준/재시도 정책을 명시.

---

## 14. 보안/프라이버시/멱등/멀티테넌시

- PII 컬럼 분리/암호화/마스킹, 감사 로그 필수.
- 쓰기 API는 멱등키(Idempotency-Key) 지원(중복 결제 방지).
- 멀티테넌시: 스키마 분리/행 수준 보안/별도 인스턴스 중 선택.

```sql
-- 간단 멱등 키 저장 예시(서버단 논리)
CREATE TABLE api_idempotency (
  key          TEXT PRIMARY KEY,
  request_hash TEXT NOT NULL,
  response     JSONB,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

---

## 15. 폴리글랏 모델링 노트(필요 시)

- 운영의 강한 정합성: RDB.
- 문서 스키마 유연: 문서형 DB(상품 설명/옵션).
- 대량 이벤트/로그: 컬럼형/타임시리즈.
- 추천/관계 탐색: 그래프.
- **동기화/소유권/정합성 경계**를 명확히 하여 혼종화.

---

## 16. 실습 과제 제안

1) 동일 도메인을 **정규화 3NF**와 **반정규화 스냅샷** 버전으로 각각 설계하고 읽기/쓰기 비용을 벤치마크.  
2) FK 인덱스 유무에 따른 **삭제/조인 시간** 비교.  
3) **SCD Type 2**로 고객명 변경 이력을 구축하고 “특정 시점 스냅샷 집계” 질의 작성.  
4) N:M 조인 엔터티에 **업무 유일성**(중복 수강 금지)과 **재수강 허용**(회차 포함) 모델을 각각 구현하고 테스트.

---

## 17. 결론

- 모델링은 “테이블 그리기”가 아니라 **업무 의미를 제약과 데이터 구조로 고정**하는 작업이다.
- **개념→논리→물리** 흐름에서, 정규화로 의미를 보존하고, 필요 시 반정규화/파티션/인덱스로 성능을 절충한다.
- 설계 이후에도 **무결성/성능/보안**을 테스트·모니터링하며 지속 개선해야 한다.