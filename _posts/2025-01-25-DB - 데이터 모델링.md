---
layout: post
title: DB - 데이터 모델링
date: 2025-01-24 19:20:23 +0900
category: DB
---
# 데이터베이스 모델링

## 리마인드(핵심 요약)

모델링은 **현실 세계를 데이터 구조로 추상화**하는 작업입니다. 그 성패는 **엔티티, 속성, 식별자, 관계**를 올바르게 정의하는 데 달려있습니다.
모델은 **개념적 → 논리적 → 물리적** 단계를 거쳐 점진적으로 정제되며, **정규화**를 통해 데이터의 이상 현상과 중복을 줄입니다. 필요한 경우 **반정규화**를 통해 성능과 구조를 절충할 수 있습니다.
ERD는 팀 협업의 공통 언어 역할을 합니다. **카디널리티와 옵셔널리티**를 명확히 표현하여 오해를 줄이는 것이 중요합니다.
물리 설계 단계에서는 **키 전략, 제약 조건, 인덱스, 파티셔닝, 데이터 타입, 보안과 권한, 운영 관점**까지 함께 고려해야 합니다.

---

## 요구사항에서 개념 모델로: 업무 언어로 시작하기

### 요구사항 분석과 개념 도출

모델링을 시작할 때는 먼저 업무에서 사용하는 용어와 개념을 명확히 정리해야 합니다. **명사**는 일반적으로 엔티티의 후보가 되고, **동사**는 관계의 후보가 됩니다. 단, '수강하다'와 같은 행위에 '수강일자', '성적' 같은 속성이 따른다면, 이를 상태로 관리하기 위해 **조인 엔터티(연관 엔터티)**로 분리하는 것을 고려해야 합니다.
시스템의 경계를 정의하는 것도 중요합니다. 한 모델에 지나치게 많은 도메인 개념을 섞지 말고, **바운디드 컨텍스트**를 명확히 설정하세요.

### 개념 ERD 스케치

텍스트로 간단히 관계를 표현해 보는 것도 좋은 시작입니다.

```text
[고객]───(주문한다)───[주문]───(포함한다)───[주문항목]───(대상)───[상품]
  |                                       ^
  └──(보유)──[쿠폰]                         |
                      [결제]──(종류)──[카드결제/계좌이체(서브타입)]
```

---

## 논리 모델: 정규화와 제약으로 의미를 고정하기

### 명명 규칙과 타입 정의

팀 내 일관된 명명 규칙을 정하는 것이 중요합니다. 테이블명은 단수형을, 컬럼명은 의미가 명확하도록 작성하세요. 금액이나 수치 데이터는 정밀도(예: `NUMERIC(12,2)`)를, 날짜와 시간은 타임존 포함 여부를 미리 합의해야 합니다.

기본 키는 대부분 **대리 키(Surrogate Key)**를 사용하되, 업무적으로 유일해야 하는 값은 **UNIQUE 제약**으로 보호하세요. 복합 자연키를 기본 키로 사용할 경우 ORM 매핑이나 조인 성능에 미치는 영향을 고려해야 합니다.

### 정규화: 데이터 무결성의 핵심

정규화는 데이터의 중복을 제거하고 무결성을 높이는 체계적인 과정입니다.
*   **1NF**: 모든 컬럼이 원자 값을 가져야 합니다.
*   **2NF**: 복합 기본키가 있을 때, 키의 일부에만 종속되는 속성이 없어야 합니다.
*   **3NF**: 기본키가 아닌 컬럼들 간의 종속 관계(이행 종속)가 없어야 합니다. 즉, 비주요 속성은 오직 기본키에만 종속되어야 합니다.

### 관계의 논리적 구현

관계의 필수 여부는 데이터베이스 제약으로 구현됩니다.
*   관계 참여가 필수(1)라면, 외래 키에 `NOT NULL` 제약을 걸고, 참조 무결성 동작은 `RESTRICT`나 `NO ACTION`을 고려합니다.
*   관계 참여가 선택(0)이라면, 외래 키에 `NULL`을 허용하고, `SET NULL`이나 `RESTRICT` 같은 적절한 삭제 규칙을 설정합니다.
*   1:1 관계를 강제하려면, 자식 테이블의 기본 키를 부모 테이블의 외래 키로 사용하거나, 외래 키에 `UNIQUE` 제약을 추가합니다.

---

## 물리 모델: 성능, 보안, 운영을 위한 설계

### 제약 조건과 인덱스 전략

모든 외래 키에는 일반적으로 인덱스를 생성하여 조인, 삭제, 갱신 성능을 보장해야 합니다. 조회 패턴을 분석하여 자주 사용되는 필터와 정렬 조건을 기준으로 **복합 인덱스**를 설계하세요. 단, 과도한 인덱스는 쓰기 성능과 저장 공간에 부담을 줄 수 있습니다.

`CHECK` 제약을 활용하면 도메인 규칙(예: `status IN ('PENDING','PAID')`)을 데이터베이스 수준에서 강제할 수 있습니다. 특히 기간 데이터의 경우, 날짜나 시간 구간이 겹치지 않도록 하는 **배타적 제약**을 고려할 수 있습니다.

### 파티셔닝과 데이터 관리

대량의 데이터를 효율적으로 관리하기 위해 **파티셔닝**을 적용할 수 있습니다. 파티션 키는 쿼리에서 가장 자주 사용되는 필터 조건(예: `created_at` 연도/월)으로 선정하는 것이 좋습니다. 오래되어 자주 조회되지 않는 데이터는 **아카이빙** 정책을 수립하여 별도의 스토리지로 이동시키는 것도 운영 효율성을 높입니다.

### 감사와 보안

데이터의 중요한 변경 이력을 추적해야 한다면 **감사 로그 테이블**을 설계하거나, 데이터베이스가 제공하는 시스템 버전 관리 기능을 활용할 수 있습니다.
보안 측면에서는 **최소 권한 원칙**을 적용해야 합니다. 개인정보(PII)가 포함된 컬럼은 암호화하거나 마스킹하는 방안을 고려하며, 모든 접근과 변경에 대한 로그를 남겨야 합니다.

---

## 주문 시스템 모델링 예시

### 물리 스키마 구현 (SQL)

```sql
-- 고객
CREATE TABLE customer (
  customer_id     BIGSERIAL PRIMARY KEY,
  email           TEXT NOT NULL UNIQUE,
  name            TEXT NOT NULL,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 상품
CREATE TABLE product (
  product_id      BIGSERIAL PRIMARY KEY,
  sku             TEXT NOT NULL UNIQUE,
  name            TEXT NOT NULL,
  price           NUMERIC(12,2) NOT NULL CHECK (price >= 0)
);

-- 주문
CREATE TABLE "order" (
  order_id        BIGSERIAL PRIMARY KEY,
  customer_id     BIGINT NOT NULL,
  order_no        TEXT NOT NULL UNIQUE,
  ordered_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  status          TEXT NOT NULL CHECK (status IN ('PENDING','PAID','COMPLETED')),
  FOREIGN KEY (customer_id) REFERENCES customer(customer_id)
);
CREATE INDEX idx_order_customer ON "order"(customer_id);

-- 주문 항목
CREATE TABLE order_item (
  order_id        BIGINT NOT NULL,
  product_id      BIGINT NOT NULL,
  qty             INT    NOT NULL CHECK (qty > 0),
  price_at        NUMERIC(12,2) NOT NULL,
  PRIMARY KEY (order_id, product_id),
  FOREIGN KEY (order_id) REFERENCES "order"(order_id) ON DELETE CASCADE,
  FOREIGN KEY (product_id) REFERENCES product(product_id)
);
CREATE INDEX idx_orderitem_product ON order_item(product_id);
```

---

## 정규화와 반정규화의 균형

**정규화**는 데이터 중복을 제거하여 갱신 이상을 방지하고 무결성을 높이는 데 목적이 있습니다. 그러나 지나치게 정규화된 구조는 복잡한 조인을 유발해 읽기 성능을 저하시킬 수 있습니다.

**반정규화**는 의도적으로 데이터를 중복 저장하여 읽기 성능을 높이는 기법입니다. 자주 조인되는 테이블의 컬럼을 중복 저장하거나, 집계 결과를 미리 계산해 저장하는 것이 예시입니다. 반정규화를 적용할 때는 원본 데이터와 중복 데이터의 동기화 방안을 반드시 고민해야 합니다.

---

## 고급 관계 모델링

*   **N:M(다대다) 관계**: 항상 조인 테이블을 통해 1:N 관계로 해소됩니다. 이 조인 테이블은 단순한 연결을 넘어 '수강일', '등급'과 같은 관계 자체의 속성을 가질 수 있습니다.
*   **재귀 관계**: 하나의 엔티티가 자기 자신과 관계를 맺는 경우입니다 (예: 조직도, 카테고리 계층). 재귀 쿼리나 Closure Table 등의 패턴으로 구현할 수 있습니다.
*   **상속 관계**: 슈퍼타입과 서브타입 패턴을 사용하여 구현합니다. 모든 타입을 하나의 테이블에 통합, 각 서브타입별 테이블 분리, 슈퍼타입과 서브타입 테이블을 조인하는 방식 등 접근법이 있습니다.

---

## 결론

데이터베이스 모델링은 단순히 테이블과 컬럼을 나열하는 작업이 아닙니다. **업무의 복잡한 규칙과 의미를 데이터 구조와 제약 조건이라는 명확한 형식으로 정의하고 고정하는 창의적이며 논리적인 과정**입니다.

개념적, 논리적, 물리적 단계를 체계적으로 거쳐 정규화를 통해 데이터의 건강한 토대를 마련한 후, 성능 요구사항에 따라 반정규화, 인덱스, 파티셔닝 같은 기법으로 보완해야 합니다. 완성된 모델은 지속적인 검증과 모니터링의 대상이 되어야 하며, 애플리케이션과의 협력, 보안, 운영 용이성까지 고려한 종합적인 설계가 진정한 가치를 만듭니다. 좋은 데이터 모델은 시스템의 장기적인 유지보수성과 확장성을 결정하는 중추 역할을 합니다.