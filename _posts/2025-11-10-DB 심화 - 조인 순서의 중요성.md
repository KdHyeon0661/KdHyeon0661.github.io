---
layout: post
title: DB 심화 - 조인 순서의 중요성
date: 2025-11-10 20:25:23 +0900
category: DB 심화
---
# 조인 순서의 중요성 (Oracle 기준)

— **왜 조인 순서가 성능을 가르는가?** · **조인 메소드(NL/SMJ/HJ)별 영향** · **드라이빙 테이블 선정** · **LEADING/ORDERED 힌트로 통제** · **카디널리티·선택도·히스토그램** · **스타 스키마/세미·안티 조인/부분범위처리** · **실습 SQL 제공**

> 핵심 메시지
> - **조인 순서**는 **읽는(스캔하는) 데이터의 양**과 **I/O 패턴**을 바꾼다.
> - 같은 SQL이라도 조인 순서가 바뀌면 **조인 메소드 선택**과 **메모리/디스크 사용**까지 달라진다.
> - **선택도가 높은(= 잘 걸러지는) 집합을 먼저** 드라이빙하면 **다음 단계 입력 규모를 급격히 줄여** 전체 비용을 낮출 수 있다.

---

## 공통 세션 설정

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;  -- DBMS_XPLAN ALLSTATS LAST 사용
ALTER SESSION SET optimizer_features_enable = '19.1.0'; -- 환경에 맞게
ALTER SESSION SET workarea_size_policy = AUTO;
```

실행 후에는 항상 아래처럼 확인합니다.

```sql
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +PEEKED_BINDS')
);
```

---

# 실습 스키마: 전형적 **고객–주문–상세–상품** 모델

```sql
-- 정리
DROP TABLE CUST PURGE;
DROP TABLE ORD PURGE;
DROP TABLE OI PURGE;
DROP TABLE PROD PURGE;

-- 고객 (선택도 높은 필터를 가정: REGION, TIER)
CREATE TABLE CUST(
  CUST_ID  NUMBER       PRIMARY KEY,
  REGION   VARCHAR2(6)  NOT NULL,
  TIER     VARCHAR2(8)  NOT NULL
);

-- 주문 헤더 (날짜/상태 필터 많음)
CREATE TABLE ORD(
  ORDER_ID NUMBER       PRIMARY KEY,
  CUST_ID  NUMBER       NOT NULL,
  ORDER_DT DATE         NOT NULL,
  STATUS   VARCHAR2(8)  NOT NULL
);

-- 주문 상세 (팩트 규모)
CREATE TABLE OI(
  ORDER_ID NUMBER       NOT NULL,
  ITEM_NO  NUMBER       NOT NULL,
  PROD_ID  NUMBER       NOT NULL,
  QTY      NUMBER       NOT NULL,
  AMOUNT   NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY(ORDER_ID, ITEM_NO)
);

-- 제품 (카테고리/브랜드 필터)
CREATE TABLE PROD(
  PROD_ID  NUMBER       PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,
  BRAND    VARCHAR2(12) NOT NULL,
  PRICE    NUMBER(10,2) NOT NULL
);

-- 인덱스
CREATE INDEX IX_ORD_CDT     ON ORD(CUST_ID, ORDER_DT, ORDER_ID);
CREATE INDEX IX_ORD_DT      ON ORD(ORDER_DT, ORDER_ID);
CREATE INDEX IX_OI_PROD     ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER    ON OI(ORDER_ID);
CREATE INDEX IX_PROD_CAT    ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_CUST_REGION ON CUST(REGION, TIER, CUST_ID);

-- 데이터 (환경에 맞게 규모 조절)
BEGIN
  FOR c IN 1..100000 LOOP
    INSERT INTO CUST VALUES (
      c,
      CASE MOD(c,5) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' WHEN 2 THEN 'AMER' WHEN 3 THEN 'JPN' ELSE 'KOR' END,
      CASE MOD(c,6) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER' WHEN 3 THEN 'BRONZE' WHEN 4 THEN 'GEN' ELSE 'NEW' END
    );
  END LOOP;

  FOR p IN 1..50000 LOOP
    INSERT INTO PROD VALUES (
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FASH' WHEN 2 THEN 'FOOD' WHEN 3 THEN 'HOME' ELSE 'TOY' END,
      'BR'||TO_CHAR(MOD(p,50)),
      ROUND(DBMS_RANDOM.VALUE(5,2000),2)
    );
  END LOOP;

  FOR o IN 1..600000 LOOP
    INSERT INTO ORD VALUES (
      o,
      MOD(o,100000)+1,
      DATE '2024-01-01' + MOD(o,540),
      CASE MOD(o,4) WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID' WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR x IN 1..900000 LOOP
    INSERT INTO OI VALUES (
      MOD(x,600000)+1,
      1 + MOD(x,3),
      MOD(x,50000)+1,
      TRUNC(DBMS_RANDOM.VALUE(1,5)),
      ROUND(DBMS_RANDOM.VALUE(10,3000),2)
    );
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

# 왜 **조인 순서**가 중요한가?

## 카디널리티 전파(Selectivity Propagation)

- 조인은 단계별 **중간 결과 크기**에 좌우됩니다.
- **선택도가 높은 조건**을 먼저 적용해 **중간 결과를 최소화**해야 다음 조인 단계의 **입력량**이 줄어듭니다.

간단한 추정식(개념, 등치조인 가정):
$$
|R \bowtie S| \approx \frac{|R| \cdot |S|}{\max(\text{NDV}(R.key), \text{NDV}(S.key))}
$$
여기서 $|R|$은 R의 로우 수, NDV는 조인 키의 distinct 수.

- 먼저 **R을 강하게 필터링**해서 $|R|$를 작게 만든 뒤 S와 조인하면 **전체 비용 감소**.

## 조인 메소드와 상호작용

- **Nested Loops(NL)**: **Outer(드라이빙) Rows가 작을수록** 유리. 랜덤 I/O가 발생하므로 **작은 Outer**가 핵심.
- **Hash Join(HJ)**: **빌드 입력이 작을수록** 유리(메모리 수용/스필 방지). 조인 순서가 빌드/프로브를 결정.
- **Sort Merge Join(SMJ)**: 두 입력 **정렬량**을 줄이는 순서가 유리. 이미 정렬/인덱스 순서면 그쪽을 먼저.

---

# 대표 시나리오별 **조인 순서** 비교

## **화면 Top-N(부분범위처리)** — NL + 정렬 흡수

> 요구: KOR/VIP 고객의 **최근 주문 Top-50**에 해당하는 상세를 조회.

### **좋은 순서**: CUST → ORD(정렬 흡수/Stopkey) → OI

```sql
VAR r VARCHAR2(6); EXEC :r := 'KOR';
VAR t VARCHAR2(8); EXEC :t := 'VIP';

SELECT /*+
          LEADING(c o i)
          USE_NL(o) USE_NL(i)
          INDEX(o ix_ord_cdt) -- (cust_id, order_dt, order_id)로 정렬 흡수
          ORDERED
       */
       o.order_id, o.order_dt, i.item_no, i.amount
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
WHERE  c.region = :r
AND    c.tier   = :t
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +IOSTATS'));
```

**설명**
- `LEADING(c o i)`로 **CUST → ORD → OI** 순서 고정.
- `IX_ORD_CDT`로 **정렬 흡수** → **Stopkey(50)** 조기 종료.
- Outer(CUST→ORD)가 **작아진 후** 상세(OI)를 NL Lookup → **랜덤 I/O 최소화**.

### **나쁜 순서**: ORD → OI → CUST (대량에서 뒤늦은 필터)

```sql
SELECT /*+
          LEADING(o i c)
          USE_NL(i) USE_NL(c)
          ORDERED
       */
       o.order_id, o.order_dt, i.item_no, i.amount
FROM   ORD  o
JOIN   OI   i ON i.order_id = o.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
WHERE  c.region = :r
AND    c.tier   = :t
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

**문제점**
- **CUST 필터가 마지막**에 적용되어 **ORD/OI 대량 스캔** 후 **뒤늦게 걸러짐**.
- 정렬 흡수도 어렵고 Stopkey 효과가 약해져 **I/O 폭증**.

---

## **집계 보고서(대량)** — Hash Join 중심

> 요구: 2024년 하반기 주문에 대해 **카테고리별 매출 합계(지역별)**

### **좋은 순서**: PROD(필터) → OI → ORD(기간필터) → CUST

```sql
SELECT /*+
          LEADING(p i o c)
          USE_HASH(i) USE_HASH(o) USE_HASH(c)
          NO_USE_NL(i) NO_USE_NL(o) NO_USE_NL(c)
       */
       c.region, p.category, SUM(i.amount) AS sales
FROM   PROD p
JOIN   OI   i ON i.prod_id  = p.prod_id
JOIN   ORD  o ON o.order_id = i.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
WHERE  o.order_dt BETWEEN DATE '2024-07-01' AND DATE '2024-12-31'
GROUP  BY c.region, p.category;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +MEMSTATS +IOSTATS'));
```

**이유**
- 해시 조인에서 **빌드 입력을 작게** 만들려면 **필터가 강한/작은 집합부터**.
- `LEADING(p i o c)`로 중간 규모를 단계적으로 확장.
- 기간 필터/카테고리 필터가 조합되어 **빌드 집합**이 작아질수록 **원패스** 가능성↑.

### **나쁜 순서**: OI → ORD → CUST → PROD

- OI(가장 큼)부터 드라이빙하면 해시 빌드/프로브 구성이 불리해져 **스필**/TEMP I/O 위험↑.
- 결과적으로 **Elapsed/TempSpc** 상승.

---

## **비등치/기간 매핑** — SMJ에 유리, 순서가 정렬량에 영향

> 요구: 주문일이 프로모션 기간에 속하는 주문 집합

```sql
-- 프로모션 테이블
DROP TABLE PROMO PURGE;
CREATE TABLE PROMO(
  PROMO_ID NUMBER PRIMARY KEY,
  START_DT DATE NOT NULL,
  END_DT   DATE NOT NULL
);

BEGIN
  FOR p IN 1..5000 LOOP
    INSERT INTO PROMO VALUES(
      p,
      DATE '2024-01-01' + (p*2),
      DATE '2024-01-01' + (p*2) + 10
    );
  END LOOP; COMMIT;
END;
/

BEGIN DBMS_STATS.GATHER_TABLE_STATS(USER,'PROMO',cascade=>TRUE); END;
/
```

### 좋은 순서: ORD(기간 프루닝/정렬 대체) → PROMO

```sql
SELECT /*+
          LEADING(o p) USE_MERGE(p)
          FULL(o) FULL(p)
       */
       o.order_id, o.order_dt, p.promo_id
FROM   ORD   o
JOIN   PROMO p
  ON   o.order_dt BETWEEN p.start_dt AND p.end_dt
WHERE  o.order_dt >= DATE '2024-06-01';

-- 왼쪽 정렬이 이미 되어 있거나 인덱스로 대체 가능하면 SORT JOIN 감소
```

**이유**
- **SMJ**는 정렬→병합. **왼쪽 정렬량을 줄이거나 대체**할 수 있는 순서가 유리.
- `ORD`에 날짜 인덱스/파티션 프루닝이 적용되면 정렬량 감소.

### 나쁜 순서: PROMO → ORD

- `PROMO`를 먼저 정렬해도 `ORD`의 대량 정렬을 피할 수 없을 수 있음.
- 실제 데이터량/정렬량을 `ALLSTATS LAST +MEMSTATS`로 비교.

---

# 옵티마이저가 **잘못된 순서**를 고르는 이유와 교정

## 통계 부정확/히스토그램 부재

- **값 분포 스큐**를 일반 분포로 오해 → 카디널리티 추정 실패 → 잘못된 순서.
- 해결: `DBMS_STATS` **히스토그램** 생성, 주기적 통계 갱신, **컬럼 그룹 통계**.

```sql
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname => USER, tabname => 'CUST',
    method_opt => 'for all columns size skewonly'
  );
END;
/
```

## 바인드 피킹/ACS 문제

- 특정 바인드 값으로 피킹된 플랜이 **다른 값**에 부적합.
- 해결: **Adaptive Cursor Sharing(ACS)**, **SQL 프로파일/플랜 베이스라인**, 값별 **SQL 분리**.

## 조인 변환/뷰 머지 영향

- 뷰 머지/서브쿼리 언네스팅으로 **조인 순서가 바뀜**.
- 해결: `NO_MERGE`/`MERGE`/`INLINE`/`MATERIALIZE` 힌트로 구조 통제.

```sql
SELECT /*+ NO_MERGE(v) */
...
FROM (SELECT ... FROM ORD WHERE ...) v
JOIN OI ON ...
```

---

# 조인 순서 **직접 통제 힌트**

- `ORDERED` : FROM 나열 순서대로 조인
- `LEADING(a b c ...)` : **명시 순서**로 조인
- `USE_NL(t)` / `USE_HASH(t)` / `USE_MERGE(t)` : 특정 테이블 t와의 조인 메소드 고정
- `SWAP_JOIN_INPUTS(t)` : 해당 해시 조인에서 **빌드/프로브 뒤집기**
- `NO_MERGE` / `INLINE` / `MATERIALIZE` : 뷰 머지/인라인/머티리얼라이즈 제어
- `CARDINALITY()` (구버전) 또는 `OPT_ESTIMATE` : 추정치 교정(신중히)

예:

```sql
SELECT /*+
          ORDERED
          LEADING(c o i)
          USE_NL(o) USE_NL(i)
          INDEX(o ix_ord_cdt)
       */
...
```

---

# 세미·안티 조인에서의 순서

- `EXISTS`(세미 조인) / `NOT EXISTS`(안티 조인)는 **내부적으로 조기 종료**가 중요 →
  **드라이빙 집합을 최대한 줄이고**, **서브쿼리 측 인덱스**로 **빠른 존재 확인**을 유도.

```sql
-- VIP 고객 중 주문이 'PAID'인 사람 존재 여부
SELECT /*+ LEADING(c) USE_NL(o) */
       c.cust_id
FROM   CUST c
WHERE  c.tier = 'VIP'
AND    EXISTS (
         SELECT /*+ INDEX(o ix_ord_cdt) */ 1
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
         AND    o.status  = 'PAID'
         FETCH FIRST 1 ROWS ONLY
       );
```

- **순서**: CUST → ORD. CUST에서 **강하게 필터** 후 **존재 확인**(Stopkey)로 조기 종료.

---

# 스타 스키마(팩트 + 여러 디멘전)

- 일반적으로 **디멘전 필터**를 먼저 적용하여 **작은 집합**을 만들고, **팩트**를 나중에 조인.
- 병렬/PQ 환경에선 **Bloom Filter**로 팩트 스캔 단계에서 선제 필터링.

```sql
SELECT /*+
          STAR_TRANSFORMATION ENABLE_PARALLEL_QUERY
          LEADING(d1 d2 f)
          USE_HASH(f)
       */
       d1.attr, d2.attr2, SUM(f.amount)
FROM   DIM1 d1
JOIN   DIM2 d2 ON ...
JOIN   FACT f  ON ...
WHERE  d1.attr IN ('A','B')
AND    d2.attr2 BETWEEN 10 AND 20
GROUP  BY d1.attr, d2.attr2;
```

- **순서**: DIM들 먼저 → FACT 나중.
- 옵티마이저가 자동으로 스타 변환을 하지 않으면 `STAR_TRANSFORMATION` 힌트/파라미터 점검.

---

# 트러블슈팅: **플랜이 바뀌었다/느려졌다**

1) **최근 통계 변경/파라미터/버전** 확인
2) **DBMS_XPLAN +PEEKED_BINDS**로 바인드 값 확인
3) **조인 순서**가 본의 아니게 바뀌었는지 `LEADING/ORDERED`로 고정해 재검증
4) **조인 메소드**도 함께 고정해 비교(`USE_NL/USE_HASH/USE_MERGE`)
5) **V$SQLAREA / V$SQL_PLAN**으로 동일 SQL의 child cursor가 값별로 분기되는지 확인
6) **SQL Plan Baseline**으로 **안정화**(운영 환경)

---

# 종합 실습: **좋은 순서 vs 나쁜 순서** 수치 비교

## 좋은 순서(NL + 정렬 흡수 + Stopkey)

```sql
SELECT /*+
          LEADING(c o i) ORDERED
          USE_NL(o) USE_NL(i)
          INDEX(o ix_ord_cdt)
       */
       o.order_id, o.order_dt, i.item_no, i.amount
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
WHERE  c.region = 'KOR'
AND    c.tier   = 'VIP'
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +IOSTATS'));
```

## 나쁜 순서(뒤늦은 필터/대량 정렬)

```sql
SELECT /*+ LEADING(o i c) ORDERED USE_NL(i) USE_NL(c) */
       o.order_id, o.order_dt, i.item_no, i.amount
FROM   ORD  o
JOIN   OI   i ON i.order_id = o.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
WHERE  c.region = 'KOR'
AND    c.tier   = 'VIP'
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +IOSTATS'));
```

**비교 포인트**
- **Buffers/Reads/Elapsed**
- **`TABLE ACCESS BY INDEX ROWID BATCHED`** 등장 여부(Inner Batched)
- **정렬 단계** 유무 및 TEMP 사용

---

# 체크리스트 (현장용)

- [ ] **조인 목적**이 Top-N/페이징인가? → **NL + 드라이빙 작게 + 정렬 흡수**
- [ ] **대량 집계/리포트**인가? → **HJ 중심 + 빌드 작게** (조인 순서로 빌드 유도)
- [ ] **비등치/기간 매핑**인가? → **SMJ** + 정렬 대체 가능한 순서 선택
- [ ] **가장 강한 필터**를 **먼저** 적용하는 순서인가?
- [ ] **인덱스/파티셔닝**으로 **프루닝/정렬 대체/커버링** 가능?
- [ ] `LEADING/ORDERED`로 **의도한 순서**가 실제 플랜에 반영되었는가?
- [ ] 통계/히스토그램/ACS로 **카디널리티 추정**이 현실적인가?
- [ ] **ALLSTATS LAST**로 전/후 **수치 비교**(Buffers/Reads/Temp/Elapsed) 완료했는가?

---

# 마무리 요약

- **조인 순서 = 비용의 1순위 레버**. 먼저 무엇을 얼마나 줄이느냐가 전체 성능을 좌우한다.
- **NL**은 작은 **Outer**가, **HJ**는 작은 **빌드**가, **SMJ**는 **정렬량 최소화**가 관건.
- 옵티마이저가 항상 최선을 고르지 않는다. **LEADING/ORDERED**와 통계/ACS/뷰 머지 제어로 **원하는 순서**를 만들고,
  `DBMS_XPLAN`으로 **증거 기반** 튜닝을 하자.
