---
layout: post
title: DB 심화 - 조인 순서의 중요성
date: 2025-11-10 20:25:23 +0900
category: DB 심화
---
# 조인 순서의 중요성 (Oracle 기준) — 왜 "먼저 무엇을 줄이느냐"가 성능의 1순위 레버인가

> 이 글은 **Oracle CBO(비용 기반 옵티마이저)** 관점에서
> **조인 순서(Join Order)가 카디널리티 전파·조인 메소드 선택·I/O 패턴·메모리/TEMP 사용을 어떻게 뒤흔드는지**를
> **실측 가능한 실습 SQL**과 함께 끝까지 파고드는 가이드다.
>
> 실행 후에는 반드시 아래로 **실측 플랜**을 확인하자.
```sql
SELECT *
FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
         NULL,NULL,
         'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +PEEKED_BINDS'
));
```

---

## 큰 그림: 조인 순서가 바꾸는 4가지

Oracle 문서에서도 “조인 순서는 중간 결과 크기(=카디널리티)를 좌우하고, 그 결과로 조인 메소드와 비용이 달라진다”는 점을 핵심으로 둔다.
이를 실무 튜닝 언어로 바꾸면 다음 4가지가 한 번에 움직인다.

1. **중간 결과 크기(카디널리티)**
   - “먼저 무엇을 얼마나 줄였는가”가 이후 단계 입력량을 결정.
2. **조인 메소드 선택(NL / HJ / SMJ)**
   - 같은 SQL이라도 순서가 바뀌면 **NL↔HJ↔SMJ**가 바뀌거나, 같은 메소드여도 **빌드/프로브 역할**이 바뀐다.
3. **I/O 패턴**
   - **랜덤 I/O vs 순차 I/O**, 배치 I/O, Stopkey(Top-N) 효과가 달라진다.
4. **메모리(PGA) / TEMP(스필)**
   - 해시 빌드, 정렬 조인, 그룹바이 정렬 등 **워크에어리어가 터지는지**가 순서에 크게 의존한다.

---

## 용어를 정확히 잡자

### 선택도(Selectivity)와 카디널리티(Cardinality)

- 선택도: 조건이 통과시키는 비율
  $$ \text{Sel} = \frac{\text{조건 통과 행 수}}{\text{전체 행 수}} $$
- 카디널리티: 조건/조인 후 예상 행 수
  $$ \text{Card} = \text{Input Rows} \times \text{Sel} $$

조인 순서를 바꾼다는 건, **각 단계의 Input Rows를 바꾸는 일**이다.
Input Rows가 달라지면 Card가 달라지고, Card가 달라지면 비용이 달라진다.

### 드라이빙 테이블(Outer)과 인너 테이블(Inner)

- **NL 조인**에서 Outer(드라이빙)는 “반복 루프의 바깥쪽 입력”
- **HJ 조인**에서 Build(빌드) 입력은 메모리에 해시 테이블을 만드는 쪽
- **SMJ**에서 Sort 먼저 하는 쪽, 또는 이미 정렬된 쪽이 드라이빙 역할을 한다

> 조인 순서가 바뀌면 **Outer/Inner 또는 Build/Probe가 바뀐다.**
> 즉, **“같은 조인 메소드”라도 비용 구조가 뒤집힌다.**

---

## 옵티마이저가 조인 순서를 고르는 방식

### 탐색 공간: 조인 그래프와 조인 트리

옵티마이저는 FROM 절 테이블들을 **조인 그래프(join graph)** 로 보고,
가능한 조인 트리를 탐색한다.

- **Left-deep 트리**(대부분의 기본 탐색):
  ```
  (((T1 ⋈ T2) ⋈ T3) ⋈ T4) ...
  ```
- **Bushy 트리**(조건이 맞고 비용상 유리하면 고려):
  ```
  (T1 ⋈ T2) ⋈ (T3 ⋈ T4)
  ```

일반 OLTP에선 Left-deep가 주류지만,
**스타 변환 / 대형 DW / 병렬** 상황에선 bushy 또는 변형 트리가 나올 수 있다.

### 왜 “먼저 줄이는 테이블”이 중요해지는가

조인 결과 크기 근사식(등치 조인, 균등 분포 가정):
$$
|R \bowtie S| \approx \frac{|R| \cdot |S|}{\max(\text{NDV}(R.k), \text{NDV}(S.k))}
$$

여기서 **|R|을 먼저 줄이면**, 전파되는 모든 단계의 입력이 동시에 준다.
즉, 조인 순서는 **카디널리티 전파(Selectivity Propagation)의 경로**다.

### 옵티마이저는 실행 중 조인 순서를 바꾸지 못한다

Adaptive Plans/Statistics Feedback이 있어도
**일단 선택한 조인 순서 자체는 실행 중에 바뀌지 않는다.**
Adaptive는 주로 **조인 메소드(예: NL ↔ HJ)** 를 갈림길로 열어두는 수준이다.

> 따라서 **조인 순서가 틀린 플랜**은
> Adaptive가 있어도 “근본적으로” 고쳐지기 어렵다.

---

## 조인 메소드별로 “좋은 순서”가 다른 이유

### Nested Loops (NL)

NL 조인의 비용 구조(개념):
$$
\text{Cost}_{NL} \approx \text{Cost(Outer Access)} + \text{Outer Rows} \times \text{Cost(Inner Lookup)}
$$

- Outer Rows가 작을수록 유리
- Inner Lookup이 인덱스로 커버되면 폭발적으로 좋아짐
- Outer Rows가 크면 **랜덤 I/O**가 기하급수적으로 증가

**따라서 NL은 “선택도 높은 테이블/조건을 먼저” 드라이빙해야 한다.**

### Hash Join (HJ)

HJ 비용 구조(개념):
$$
\text{Cost}_{HJ} \approx \text{Cost(Build Input)} + \text{Cost(Probe Input)} + \text{Hash Overhead}
$$

핵심:
- Build Input이 **작아 메모리에 들어가면** 원패스(One-Pass)
- Build Input이 크면 **스필(Spill)** 로 TEMP I/O 발생

**따라서 HJ는 “빌드 쪽이 작아지도록” 순서를 잡는 게 핵심.**

옵티마이저는 조인 순서를 고르면서 Build/Probe도 함께 결정한다.

- 필요 시 `SWAP_JOIN_INPUTS`로 Build/Probe를 뒤집을 수 있다.
- 조인 순서와 Build 방향은 별개로 조정될 수 있음을 기억.

### Sort Merge Join (SMJ)

SMJ는 **양쪽을 정렬하거나 이미 정렬된 순서를 이용해 병합**한다.

비용:
$$
\text{Cost}_{SMJ} \approx \text{Cost(Sort Left)} + \text{Cost(Sort Right)} + \text{Merge Cost}
$$

좋은 순서의 조건:
- 한쪽이 이미 인덱스/파티션으로 **정렬이 “흡수”될 때**
- 정렬량이 적은 쪽을 먼저 드라이빙해서 전체 sort 부담을 줄일 때

**따라서 SMJ는 “정렬을 대체/감소시킬 수 있는 쪽을 먼저”가 유리.**

---

## 실습 스키마(당신이 준 모델 기반)와 기본 통계

> 아래 실습은 전부 Oracle 기준이며,
> `statistics_level=ALL` + `DBMS_XPLAN ... ALLSTATS LAST`로 실측 가능하다.

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET workarea_size_policy = AUTO;

DROP TABLE CUST PURGE;
DROP TABLE ORD  PURGE;
DROP TABLE OI   PURGE;
DROP TABLE PROD PURGE;

CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(6) NOT NULL,
  TIER    VARCHAR2(8) NOT NULL
);

CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  ORDER_DT DATE NOT NULL,
  STATUS   VARCHAR2(8) NOT NULL
);

CREATE TABLE OI(
  ORDER_ID NUMBER NOT NULL,
  ITEM_NO  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY(ORDER_ID, ITEM_NO)
);

CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,
  BRAND    VARCHAR2(12) NOT NULL,
  PRICE    NUMBER(10,2) NOT NULL
);

CREATE INDEX IX_ORD_CDT     ON ORD(CUST_ID, ORDER_DT, ORDER_ID);
CREATE INDEX IX_ORD_DT      ON ORD(ORDER_DT, ORDER_ID);
CREATE INDEX IX_OI_PROD     ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER    ON OI(ORDER_ID);
CREATE INDEX IX_PROD_CAT    ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_CUST_REGION ON CUST(REGION, TIER, CUST_ID);

BEGIN
  FOR c IN 1..100000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,5)
        WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' WHEN 2 THEN 'AMER'
        WHEN 3 THEN 'JPN'  ELSE 'KOR' END,
      CASE MOD(c,6)
        WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER'
        WHEN 3 THEN 'BRONZE' WHEN 4 THEN 'GEN' ELSE 'NEW' END
    );
  END LOOP;

  FOR p IN 1..50000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5)
        WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FASH' WHEN 2 THEN 'FOOD'
        WHEN 3 THEN 'HOME' ELSE 'TOY' END,
      'BR'||TO_CHAR(MOD(p,50)),
      ROUND(DBMS_RANDOM.VALUE(5,2000),2)
    );
  END LOOP;

  FOR o IN 1..600000 LOOP
    INSERT INTO ORD VALUES(
      o,
      MOD(o,100000)+1,
      DATE '2024-01-01' + MOD(o,540),
      CASE MOD(o,4)
        WHEN 0 THEN 'NEW' WHEN 1 THEN 'PAID'
        WHEN 2 THEN 'SHIP' ELSE 'DONE' END
    );
  END LOOP;

  FOR x IN 1..900000 LOOP
    INSERT INTO OI VALUES(
      MOD(x,600000)+1,
      1 + MOD(x,3),
      MOD(x,50000)+1,
      TRUNC(DBMS_RANDOM.VALUE(1,5)),
      ROUND(DBMS_RANDOM.VALUE(10,3000),2)
    );
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'ORD' , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'OI'  , cascade=>TRUE, method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE, method_opt=>'for all columns size skewonly');
END;
/
```

---

## 시나리오 1 — 화면 Top-N: “정렬 흡수 + Stopkey”는 순서가 전부다

### 요구

“KOR/VIP 고객의 최근 주문 Top-50의 상세 조회”

### 좋은 순서: CUST → ORD → OI (NL + 정렬 흡수)

```sql
VAR r VARCHAR2(6); EXEC :r := 'KOR';
VAR t VARCHAR2(8); EXEC :t := 'VIP';

SELECT /*+
          LEADING(c o i)
          USE_NL(o) USE_NL(i)
          INDEX(o IX_ORD_CDT)
          ORDERED
       */
       o.order_id, o.order_dt, i.item_no, i.amount
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
WHERE  c.region = :r
AND    c.tier   = :t
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

**왜 좋은가**
1. `CUST` 필터(Region/Tier)로 **Outer Rows를 극소화**
2. `IX_ORD_CDT(cust_id, order_dt, order_id)` 역방향 스캔으로
   - **정렬을 인덱스 순서로 대체**
   - `FETCH FIRST 50` → **STOPKEY로 조기 종료**
3. 그 50건에 대해서만 OI를 NL Lookup → **랜덤 I/O가 딱 50건 수준**

실측에서 기대되는 징후:
- `INDEX RANGE SCAN DESCENDING` + `STOPKEY`
- `TABLE ACCESS BY INDEX ROWID BATCHED` (OI의 배치 NL)
- Buffers/Reads 급감

### 나쁜 순서: ORD → OI → CUST

```sql
SELECT /*+
          LEADING(o i c)
          USE_NL(i) USE_NL(c)
          ORDERED
       */
       o.order_id, o.order_dt, i.item_no, i.amount
FROM   ORD  o
JOIN   OI   i ON i.order_id = o.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
WHERE  c.region = :r
AND    c.tier   = :t
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

**왜 나쁜가**
- ORD/OI를 **대량으로 읽고 조인한 뒤** 마지막에 CUST 조건으로 걸러짐
- Stopkey가 사실상 늦게 적용되어 **정렬/TEMP가 커짐**
- NL이면 Outer가 커져 랜덤 I/O 폭발, HJ로 바뀌면 해시 빌드가 커져 스필 위험

---

## 시나리오 2 — 대량 집계 보고서: HJ는 “빌드 입력을 작게 만드는 순서”가 승부처

### 요구

“2024 하반기 주문의 지역×카테고리 매출”

### 좋은 순서: PROD(카테고리 필터) → OI → ORD(기간 필터) → CUST

```sql
SELECT /*+
          LEADING(p i o c)
          USE_HASH(i) USE_HASH(o) USE_HASH(c)
          NO_USE_NL(i) NO_USE_NL(o) NO_USE_NL(c)
       */
       c.region, p.category, SUM(i.amount) AS sales
FROM   PROD p
JOIN   OI   i ON i.prod_id  = p.prod_id
JOIN   ORD  o ON o.order_id = i.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
WHERE  o.order_dt BETWEEN DATE '2024-07-01' AND DATE '2024-12-31'
GROUP  BY c.region, p.category;
```

**이유**
1. PROD에서 카테고리 조건을 통해 **작은 Build 후보**를 먼저 만든다.
2. OI로 확장하되, 카테고리 필터가 이미 먹혀 **중간 결과가 제한**된다.
3. ORD의 기간 필터가 추가로 중간 결과를 조여 준다.
4. 마지막에 CUST를 붙인다.

실측에서 기대되는 징후:
- 해시 빌드/프로브가 **원패스(One-Pass)** 또는 최소 스필
- TEMP 사용이 낮고, Buffers가 OI 대량 스캔 대비 크게 줄어듦

### 나쁜 순서: OI → ORD → CUST → PROD

- OI(가장 큰 팩트)에서 해시 빌드를 시작하면
  - Build 입력이 커져 **PGA 초과 → TEMP 스필**
  - 조인 중간 결과가 과도하게 커짐
- 결과적으로 `TempSpc`/`Elapsed` 상승이 확연히 보일 것

---

## 시나리오 3 — 비등치/기간 매핑: SMJ에서 순서는 “정렬량을 줄이느냐”로 결정

### 프로모션 기간 테이블

```sql
DROP TABLE PROMO PURGE;

CREATE TABLE PROMO(
  PROMO_ID NUMBER PRIMARY KEY,
  START_DT DATE NOT NULL,
  END_DT   DATE NOT NULL
);

BEGIN
  FOR p IN 1..5000 LOOP
    INSERT INTO PROMO VALUES(
      p,
      DATE '2024-01-01' + (p*2),
      DATE '2024-01-01' + (p*2) + 10
    );
  END LOOP;
  COMMIT;
END;
/

BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROMO',cascade=>TRUE);
END;
/
```

### 좋은 순서: ORD → PROMO (ORD에서 기간 프루닝/정렬 대체)

```sql
SELECT /*+
          LEADING(o p)
          USE_MERGE(p)
          FULL(o) FULL(p)
       */
       o.order_id, o.order_dt, p.promo_id
FROM   ORD   o
JOIN   PROMO p
  ON   o.order_dt BETWEEN p.start_dt AND p.end_dt
WHERE  o.order_dt >= DATE '2024-06-01';
```

**이유**
- ORD는 `ORDER_DT` 조건으로 **범위가 먼저 줄어든다**
- `IX_ORD_DT`가 있으면 **정렬을 인덱스 순서로 대체** 가능
- PROMO는 상대적으로 작아 정렬 부담이 낮다

### 나쁜 순서: PROMO → ORD

- PROMO를 먼저 읽어도 ORD의 대량 정렬/스캔을 피할 수 없는 경우가 많다
- 비등치 조인은 해시로도 쉽지 않아,
  결과적으로 SMJ 비용이 정렬량에 직접 반영된다

---

## 옵티마이저가 “나쁜 순서”를 고르는 대표 원인

### 통계 부정확(히스토그램/확장통계 부족)

- 스큐를 모르면 선택도를 평균치로 가정 → 조인 전파가 망가진다.
- 예: 특정 REGION에 60% 몰림, 특정 BRAND에 30% 몰림

해법:
```sql
-- 스큐 컬럼엔 히스토그램 자동/수동 확보
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'CUST',
    method_opt => 'for all columns size skewonly'
  );
END;
/
```

상관관계(예: REGION='KOR'에서 VIP 비중↑)가 크면 확장 통계:
```sql
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(USER,'CUST','(REGION, TIER)');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST');
END;
/
```

### 바인드 피킹/ACS

- 첫 바인드 값에서 피킹된 순서가 다른 값군에 부적합
- 조인 순서가 고정되면 **값이 바뀌어도 순서가 못 바뀐다**

해법:
- 히스토그램 + ACS 학습 유도
- 값군이 극단적이면 SQL 분리 또는 Baseline

### 뷰 머지/서브쿼리 Unnesting으로 순서가 바뀜

- 논리적으로는 같은데 **변환된 쿼리 블록에서 드라이빙이 바뀌는 현상**
- 특히 복잡한 WITH/뷰/인라인에서 흔함

해법:
```sql
SELECT /*+ NO_MERGE(v) */
...
FROM (SELECT ... FROM ORD WHERE ...) v
JOIN OI i ON ...
```

---

## 조인 순서를 “직접 통제”하는 힌트들

Oracle 문서에서 조인 순서 힌트와, 그와 함께 조인 메소드 힌트를 권한다.

### 핵심 힌트

- `LEADING(a b c ...)` : 지정 순서로 조인(첫 테이블이 드라이빙)
- `ORDERED` : FROM에 쓴 순서대로 조인
- `USE_NL(t) / USE_HASH(t) / USE_MERGE(t)` : 특정 테이블과의 조인 메소드 강제
- `SWAP_JOIN_INPUTS(t)` : 해시 조인에서 Build/Probe 뒤집기
- `NO_MERGE / INLINE / MATERIALIZE` : 변환을 막거나 강제

### 실전 힌트 패턴

```sql
SELECT /*+
          LEADING(c o i p)
          USE_NL(o) USE_NL(i) USE_NL(p)
          INDEX(o IX_ORD_CDT)
          INDEX(c IX_CUST_REGION)
          INDEX(p IX_PROD_CAT)
          ORDERED
       */
...
```

원칙:
1. **순서 힌트(LEADING/ORDERED)만으로는 부족**
2. **조인 메소드 힌트(USE_*)를 같이 줘야 의도대로 고정**
   (Oracle이 조인 순서 힌트는 따르되 메소드만 바꾸는 경우를 막기 위해)

---

## 세미·안티 조인에서의 순서

### 세미 조인(EXISTS)

특징:
- “있으면 끝” → 내부적으로 Stopkey 형태의 조기 종료 최적화
- 드라이빙 집합이 작아야 효과가 극대화

```sql
SELECT /*+ LEADING(c) USE_NL(o) */
       c.cust_id
FROM   CUST c
WHERE  c.tier = 'VIP'
AND    EXISTS (
         SELECT /*+ INDEX(o IX_ORD_CDT) */ 1
         FROM   ORD o
         WHERE  o.cust_id = c.cust_id
         AND    o.status  = 'PAID'
         FETCH FIRST 1 ROWS ONLY
       );
```

**순서**: CUST(강한 필터) → ORD(존재 확인)
**결과**: 고객을 먼저 줄이고, 주문은 “존재만” 체크

### 안티 조인(NOT EXISTS)

```sql
SELECT /*+ LEADING(c) USE_NL(o) */
       c.cust_id
FROM   CUST c
WHERE  c.tier='VIP'
AND    NOT EXISTS (
         SELECT /*+ INDEX(o IX_ORD_CDT) */ 1
         FROM   ORD o
         WHERE  o.cust_id=c.cust_id
         AND    o.status='PAID'
       );
```

안티 조인은 한 번이라도 매칭되면 탈락이므로,
매칭 후보를 가능한 빨리 찾는 순서가 유리하다.

---

## 스타 스키마에서의 순서

스타 스키마:
- 여러 Dimension에서 강한 필터 → 작은 키 집합
- Fact를 마지막에 조인하여 대량 스캔을 최소화

```sql
SELECT /*+
          STAR_TRANSFORMATION
          LEADING(d1 d2 f)
          USE_HASH(f)
       */
       d1.attr, d2.attr2, SUM(f.amount)
FROM   DIM1 d1
JOIN   DIM2 d2 ON ...
JOIN   FACT f  ON ...
WHERE  d1.attr IN ('A','B')
AND    d2.attr2 BETWEEN 10 AND 20
GROUP  BY d1.attr, d2.attr2;
```

병렬(PQ)에서는
- Dimension에서 뽑힌 키로 **Bloom Filter**를 만들어
- Fact 스캔 단계에서 선제적으로 거른다

즉, **순서 = Bloom Filter의 생성 타이밍**까지 좌우한다.

---

## “드라이빙 테이블 선정” 실전 규칙

### Top-N/페이징/OLTP 화면

- **드라이빙은 “가장 강한 필터 + 정렬 흡수 가능한 테이블”**
- 순서: **필터 강한 DIM → FACT(기간/키) → DETAIL**
- NL 중심

### DW/리포트/대량 집계

- **빌드를 작게 만들 수 있는 DIM/필터 테이블부터**
- HJ 중심
- 필요하면 `SWAP_JOIN_INPUTS`로 build 방향까지 고정

### 비등치/기간 매핑

- 정렬이 대체 가능한 쪽(인덱스/파티션) 먼저
- SMJ 또는 후보 축소 후 HJ/NL

---

## 조인 순서가 바뀐 “느려짐” 트러블슈팅 로드맵

1. **통계/히스토그램/확장통계 변경 여부** 확인
2. `DBMS_XPLAN +PEEKED_BINDS`로 바인드 값 확인
3. 플랜에서 조인 순서가 바뀌었는지
   - `PLAN_TABLE_OUTPUT`에서 **Join Order 표시(From-to)** 확인
4. 의도한 순서를 `LEADING/ORDERED`로 고정해 재측정
5. 메소드도 함께 고정(`USE_NL/USE_HASH/USE_MERGE`)
6. Child cursor가 값군별로 나뉘는지 `V$SQL`에서 확인
7. 운영 SQL이면 Baseline/Profile로 안정화

---

## 종합 실습: “좋은 순서 vs 나쁜 순서” 실측 비교

### 좋은 순서

```sql
SELECT /*+
          LEADING(c o i) ORDERED
          USE_NL(o) USE_NL(i)
          INDEX(o IX_ORD_CDT)
       */
       o.order_id, o.order_dt, i.item_no, i.amount
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
WHERE  c.region = 'KOR'
AND    c.tier   = 'VIP'
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +IOSTATS +MEMSTATS'));
```

### 나쁜 순서

```sql
SELECT /*+ LEADING(o i c) ORDERED USE_NL(i) USE_NL(c) */
       o.order_id, o.order_dt, i.item_no, i.amount
FROM   ORD  o
JOIN   OI   i ON i.order_id = o.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
WHERE  c.region = 'KOR'
AND    c.tier   = 'VIP'
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +IOSTATS +MEMSTATS'));
```

### 비교 체크포인트

- `Buffers / Reads / Writes / Elapsed`
- 정렬 단계(SORT ORDER BY)와 TEMP 사용량
- NL이라면 `TABLE ACCESS BY INDEX ROWID BATCHED` 등장 유무
- HJ라면 `onepass / multipass / spilled` 여부(Plan + MEMSTATS)

---

## 현장용 체크리스트

- [ ] 이 쿼리는 **Top-N/페이지**인가?
  → **NL + 강한 필터 먼저 + 정렬 흡수/Stopkey**
- [ ] **대량 집계/리포트**인가?
  → **HJ 중심 + 빌드가 작아지도록 순서**
- [ ] **비등치/기간 매핑**인가?
  → **SMJ + 정렬 대체 가능한 쪽을 먼저**
- [ ] 가장 강한 필터가 **초반 단계**에서 적용되는가?
- [ ] 인덱스/파티션으로 **프루닝·정렬대체·커버링** 가능한가?
- [ ] `LEADING/ORDERED`가 실제 플랜에 반영됐는가?
- [ ] 히스토그램/확장통계/ACS로 **카디널리티가 현실적**인가?
- [ ] 전후 수치(Buffers/Temp/Elapsed) 비교를 완료했는가?

---

## 결론

- **조인 순서는 “성능을 결정하는 첫 번째 레버”**다.
  무엇을 먼저 얼마나 줄이느냐가 그 뒤 모든 단계의 비용을 좌우한다.
- **NL은 작은 Outer**, **HJ는 작은 Build**, **SMJ는 최소 정렬량**이 핵심이며,
  이 핵심은 **조인 순서가 결정한다.**
- 옵티마이저는 통계/스큐/바인드/변환 때문에 종종 순서를 잘못 고른다.
  **히스토그램·확장통계·ACS·변환 제어 + LEADING/ORDERED + USE_* 힌트**로
  “의도한 순서”를 만들고,
  반드시 **DBMS_XPLAN 실측**으로 증거 기반 튜닝을 하자.
