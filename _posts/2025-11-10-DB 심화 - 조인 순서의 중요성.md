---
layout: post
title: DB 심화 - 조인 순서의 중요성
date: 2025-11-10 20:25:23 +0900
category: DB 심화
---
# 조인 순서의 중요성 - Oracle CBO 관점에서의 심층 분석

조인 순서(Join Order)는 SQL 성능을 결정하는 가장 중요한 요소 중 하나입니다. 특히 Oracle의 비용 기반 옵티마이저(CBO)에서 조인 순서는 단순히 테이블 접근 순서를 넘어, 전체 쿼리 실행의 성능을 좌우하는 핵심 레버입니다. 이 문서에서는 조인 순서가 카디널리티 전파, 조인 메소드 선택, I/O 패턴, 메모리 사용에 미치는 영향을 실측 가능한 실습과 함께 심층적으로 분석합니다.

## 기본 환경 설정

실습을 위한 기본 환경을 설정합니다:

```sql
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET statistics_level = ALL;
ALTER SESSION SET workarea_size_policy = AUTO;
```

실행 계획 확인을 위한 템플릿:
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  NULL, NULL,
  'ALLSTATS LAST +PREDICATE +IOSTATS +MEMSTATS +PEEKED_BINDS'
));
```

## 조인 순서가 성능에 미치는 4가지 영향

조인 순서 변경은 단일 요소가 아닌, 다음과 같은 네 가지 측면에서 동시에 성능을 변화시킵니다:

### 1. 중간 결과 크기(카디널리티) 관리
조인 순서는 각 단계의 입력 크기를 결정합니다. 먼저 줄여지는 테이블의 크기가 이후 모든 조인 단계의 입력 크기에 직결됩니다. 이는 카디널리티 전파(Cardinality Propagation)의 핵심 원리로, 조인 순서를 통해 선택도(Selectivity)의 누적 효과를 최대화할 수 있습니다.

선택도와 카디널리티의 관계:
- 선택도(Sel) = 조건 통과 행 수 / 전체 행 수
- 카디널리티(Card) = 입력 행 수 × 선택도

### 2. 조인 메소드 선택
동일한 SQL 문장이라도 조인 순서가 바뀌면 옵티마이저는 다른 조인 메소드를 선택할 수 있습니다. NL 조인, 해시 조인, 소트 머지 조인 간의 전환이 발생하거나, 동일한 조인 메소드 내에서도 빌드/프로브 역할이 바뀔 수 있습니다.

### 3. I/O 패턴 변화
조인 순서는 랜덤 I/O와 순차 I/O의 비율, 배치 I/O 활용도, Top-N 쿼리에서의 Stopkey 효과 등 I/O 패턴을 근본적으로 변화시킵니다. 이는 특히 대량 데이터 처리에서 결정적인 성능 차이를 만듭니다.

### 4. 메모리 및 TEMP 공간 사용
해시 조인의 빌드 단계나 소트 머지 조인의 정렬 단계에서 필요한 메모리(PGA)와 디스크(TEMP) 사용량은 조인 순서에 크게 의존합니다. 적절한 순서 선택은 메모리 오버플로우와 디스크 스필(Spill)을 방지합니다.

## 실습 데이터 모델 구성

전형적인 주문 처리 시스템 모델을 구성합니다:

```sql
-- 고객 테이블
DROP TABLE CUST PURGE;
CREATE TABLE CUST(
  CUST_ID NUMBER PRIMARY KEY,
  REGION  VARCHAR2(6) NOT NULL,
  TIER    VARCHAR2(8) NOT NULL
);

-- 주문 테이블
DROP TABLE ORD PURGE;
CREATE TABLE ORD(
  ORDER_ID NUMBER PRIMARY KEY,
  CUST_ID  NUMBER NOT NULL,
  ORDER_DT DATE NOT NULL,
  STATUS   VARCHAR2(8) NOT NULL
);

-- 주문 상세 테이블
DROP TABLE OI PURGE;
CREATE TABLE OI(
  ORDER_ID NUMBER NOT NULL,
  ITEM_NO  NUMBER NOT NULL,
  PROD_ID  NUMBER NOT NULL,
  QTY      NUMBER NOT NULL,
  AMOUNT   NUMBER(10,2) NOT NULL,
  CONSTRAINT PK_OI PRIMARY KEY(ORDER_ID, ITEM_NO)
);

-- 제품 테이블
DROP TABLE PROD PURGE;
CREATE TABLE PROD(
  PROD_ID  NUMBER PRIMARY KEY,
  CATEGORY VARCHAR2(12) NOT NULL,
  BRAND    VARCHAR2(12) NOT NULL,
  PRICE    NUMBER(10,2) NOT NULL
);

-- 인덱스 생성
CREATE INDEX IX_ORD_CDT     ON ORD(CUST_ID, ORDER_DT, ORDER_ID);
CREATE INDEX IX_ORD_DT      ON ORD(ORDER_DT, ORDER_ID);
CREATE INDEX IX_OI_PROD     ON OI(PROD_ID);
CREATE INDEX IX_OI_ORDER    ON OI(ORDER_ID);
CREATE INDEX IX_PROD_CAT    ON PROD(CATEGORY, PROD_ID);
CREATE INDEX IX_CUST_REGION ON CUST(REGION, TIER, CUST_ID);
```

데이터 로딩 및 통계 수집:
```sql
-- 샘플 데이터 로딩 (간소화)
BEGIN
  -- 고객 10만 명
  FOR c IN 1..100000 LOOP
    INSERT INTO CUST VALUES(
      c,
      CASE MOD(c,5) WHEN 0 THEN 'APAC' WHEN 1 THEN 'EMEA' WHEN 2 THEN 'AMER'
                    WHEN 3 THEN 'JPN'  ELSE 'KOR' END,
      CASE MOD(c,6) WHEN 0 THEN 'VIP' WHEN 1 THEN 'GOLD' WHEN 2 THEN 'SILVER'
                    WHEN 3 THEN 'BRONZE' WHEN 4 THEN 'GEN' ELSE 'NEW' END
    );
  END LOOP;
  
  -- 제품 5만 개
  FOR p IN 1..50000 LOOP
    INSERT INTO PROD VALUES(
      p,
      CASE MOD(p,5) WHEN 0 THEN 'ELEC' WHEN 1 THEN 'FASH' WHEN 2 THEN 'FOOD'
                    WHEN 3 THEN 'HOME' ELSE 'TOY' END,
      'BR'||TO_CHAR(MOD(p,50)),
      ROUND(DBMS_RANDOM.VALUE(5,2000),2)
    );
  END LOOP;
  
  COMMIT;
END;
/

-- 통계 수집
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(USER,'CUST', cascade=>TRUE, 
    method_opt=>'for all columns size skewonly');
  DBMS_STATS.GATHER_TABLE_STATS(USER,'PROD', cascade=>TRUE);
END;
/
```

## 조인 메소드별 최적의 순서 전략

### Nested Loops 조인의 순서 전략

NL 조인의 비용 구조를 단순화하면 다음과 같습니다:
```
비용 ≈ Outer 액세스 비용 + (Outer 행 수 × Inner Lookup 비용)
```

NL 조인에서 최적의 순서는:
1. **가장 선택도가 높은(가장 작은 결과 집합을 만드는) 테이블을 Outer로 설정**
2. Inner 테이블에 효율적인 인덱스가 존재해야 함
3. Outer 행 수가 작을수록 랜덤 I/O를 최소화할 수 있음

실제 예제로 확인해보겠습니다:

```sql
-- 효율적인 NL 조인 순서: CUST → ORD → OI
SELECT /*+ LEADING(c o i) USE_NL(o) USE_NL(i) INDEX(o IX_ORD_CDT) */
       o.order_id, o.order_dt, i.item_no, i.amount
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
WHERE  c.region = 'KOR'
AND    c.tier   = 'VIP'
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

이 순서의 장점:
- CUST 테이블에서 'KOR'/'VIP' 조건으로 행 수를 극소화
- IX_ORD_CDT 인덱스를 활용하여 정렬 작업을 흡수
- FETCH FIRST 50으로 Stopkey 최적화 적용
- 각 CUST 행에 대해 ORD와 OI를 효율적으로 조회

### Hash 조인의 순서 전략

해시 조인의 비용 구조:
```
비용 ≈ Build 입력 비용 + Probe 입력 비용 + 해시 오버헤드
```

해시 조인에서의 핵심 원칙:
1. **더 작은 테이블을 Build 입력으로 선택**
2. Build 입력이 메모리에 완전히 적재될 수 있도록 관리
3. Build 입력이 너무 크면 디스크 스필 발생으로 성능 저하

적절한 해시 조인 순서 예제:
```sql
-- 효율적인 해시 조인 순서: 작은 필터 → 큰 팩트 테이블
SELECT /*+ LEADING(p i o c) 
           USE_HASH(i) USE_HASH(o) USE_HASH(c) */
       c.region, p.category, SUM(i.amount) AS sales
FROM   PROD p
JOIN   OI   i ON i.prod_id  = p.prod_id
JOIN   ORD  o ON o.order_id = i.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
WHERE  o.order_dt BETWEEN DATE '2024-07-01' AND DATE '2024-12-31'
AND    p.category IN ('ELEC', 'FASH')
GROUP  BY c.region, p.category;
```

이 순서의 장점:
- PROD 테이블에서 카테고리 필터로 작은 Build 입력 생성
- 점진적으로 조인하며 중간 결과 크기 관리
- 메모리 내 해시 테이블 유지 가능성 증가

### Sort Merge 조인의 순서 전략

소트 머지 조인의 비용 구조:
```
비용 ≈ 왼쪽 정렬 비용 + 오른쪽 정렬 비용 + 병합 비용
```

소트 머지 조인에서의 최적 순서:
1. **이미 정렬된 입력(인덱스 스캔 결과)을 활용**
2. 정렬 작업을 최소화할 수 있는 방향으로 순서 결정
3. 비등치 조인(범위 조인) 처리에 유리

## 실전 시나리오별 최적 조인 순서 분석

### 시나리오 1: Top-N 화면 조회 (OLTP 환경)

**요구사항**: 특정 지역/등급 고객의 최근 주문 50건 조회

**최적 순서**: CUST → ORD → OI

```sql
-- 효율적인 Top-N 조회
SELECT /*+ LEADING(c o i) USE_NL(o) USE_NL(i) 
           INDEX(o (CUST_ID, ORDER_DT DESC, ORDER_ID DESC)) */
       o.order_id, o.order_dt, i.item_no, i.amount
FROM   CUST c
JOIN   ORD  o ON o.cust_id = c.cust_id
JOIN   OI   i ON i.order_id = o.order_id
WHERE  c.region = 'KOR'
AND    c.tier   = 'VIP'
ORDER  BY o.order_dt DESC, o.order_id DESC
FETCH FIRST 50 ROWS ONLY;
```

**성능 이점**:
1. CUST에서 강력한 필터 적용으로 시작 행 수 최소화
2. 복합 인덱스를 통한 정렬 흡수로 SORT ORDER BY 작업 제거
3. Stopkey 최적화로 필요한 50건만 처리 후 조기 종료
4. NL 조인의 랜덤 I/O 범위 제한

### 시나리오 2: 대용량 집계 리포트 (DW 환경)

**요구사항**: 기간별, 지역별, 카테고리별 매출 집계

**최적 순서**: PROD → OI → ORD → CUST

```sql
-- 효율적인 대용량 집계
SELECT /*+ LEADING(p i o c)
           USE_HASH(i) USE_HASH(o) USE_HASH(c)
           SWAP_JOIN_INPUTS(i) */  -- 필요시 빌드/프로브 방향 조정
       c.region, p.category, 
       TO_CHAR(o.order_dt, 'YYYY-MM') as month,
       SUM(i.amount) as total_sales,
       COUNT(*) as order_count
FROM   PROD p
JOIN   OI   i ON i.prod_id  = p.prod_id
JOIN   ORD  o ON o.order_id = i.order_id
JOIN   CUST c ON c.cust_id  = o.cust_id
WHERE  o.order_dt BETWEEN DATE '2024-01-01' AND DATE '2024-12-31'
AND    p.category = 'ELEC'
GROUP  BY c.region, p.category, TO_CHAR(o.order_dt, 'YYYY-MM');
```

**성능 이점**:
1. PROD에서 카테고리 필터로 시작하여 Build 입력 크기 최소화
2. 점진적 조인으로 중간 결과 집합 관리
3. 해시 조인의 메모리 효율성 극대화
4. 병렬 처리 가능성 향상

### 시나리오 3: 비등치 조인 (기간 매핑)

**프로모션 테이블 추가**:
```sql
DROP TABLE PROMO PURGE;
CREATE TABLE PROMO(
  PROMO_ID NUMBER PRIMARY KEY,
  START_DT DATE NOT NULL,
  END_DT   DATE NOT NULL,
  DISCOUNT_RATE NUMBER(3,2) NOT NULL
);

-- 프로모션 기간과 주문일자를 매핑하는 비등치 조인
SELECT /*+ LEADING(o p) USE_MERGE(p) 
           INDEX(o (ORDER_DT)) */
       o.order_id, o.order_dt, p.promo_id, p.discount_rate
FROM   ORD   o
JOIN   PROMO p ON o.order_dt BETWEEN p.start_dt AND p.end_dt
WHERE  o.order_dt >= DATE '2024-06-01';
```

## 옵티마이저의 조인 순서 결정 메커니즘

### 탐색 알고리즘

Oracle 옵티마이저는 다음과 같은 알고리즘으로 조인 순서를 결정합니다:

1. **Left-deep 트리 탐색**: 대부분의 OLTP 쿼리에서 사용
   ```
   (((T1 ⋈ T2) ⋈ T3) ⋈ T4)
   ```

2. **Bushy 트리 탐색**: 복잡한 DW 쿼리나 병렬 처리에서 고려
   ```
   (T1 ⋈ T2) ⋈ (T3 ⋈ T4)
   ```

3. **비용 기반 결정**: 각 후보 순서에 대해 비용 추정 후 최소 비용 선택

### 카디널리티 추정의 중요성

옵티마이저는 다음과 같은 공식으로 조인 결과 크기를 추정합니다:
```
조인 결과 크기 ≈ (|R| × |S|) / max(NDV(R.k), NDV(S.k))
```

여기서:
- |R|, |S|: 조인 입력의 행 수
- NDV(): 컬럼의 고유 값 수

이 추정이 부정확하면 옵티마이저는 잘못된 조인 순서를 선택할 수 있습니다.

## 조인 순서 문제의 진단 및 해결

### 일반적인 문제 원인

1. **통계 부정확성**
   - 오래된 통계 정보
   - 히스토그램 부재
   - 확장 통계(Extended Statistics) 미적용

2. **바인드 변수 피킹**
   - 첫 실행 시 바인드 값에 기반한 최적화
   - 다른 값에서 비효율적인 플랜 유지

3. **쿼리 변환 부작용**
   - 뷰 머지(View Merging)
   - 서브쿼리 Unnesting
   - 조건자 이동(Predicate Moving)

### 문제 진단 방법

```sql
-- 1. 현재 실행 계획 분석
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
  'sql_id_here', child_number_here,
  'ALLSTATS LAST +PREDICATE +NOTE'
));

-- 2. 히스토그램 확인
SELECT column_name, histogram, num_buckets
FROM   user_tab_col_statistics
WHERE  table_name = '테이블명';

-- 3. 실제 vs 예상 행 수 비교
SELECT operation, options, object_name,
       cardinality as "예상 행 수",
       last_output_rows as "실제 행 수"
FROM   v$sql_plan_statistics_all
WHERE  sql_id = 'sql_id_here'
ORDER BY plan_line_id;
```

### 해결 전략

1. **통계 개선**
```sql
-- 히스토그램 생성
BEGIN
  DBMS_STATS.GATHER_TABLE_STATS(
    ownname    => USER,
    tabname    => 'CUST',
    method_opt => 'for columns REGION size 254, TIER size 254'
  );
END;
/

-- 확장 통계 생성 (상관 관계 있는 컬럼들)
BEGIN
  DBMS_STATS.CREATE_EXTENDED_STATS(
    USER, 'CUST', '(REGION, TIER)'
  );
END;
/
```

2. **힌트를 통한 조인 순서 고정**
```sql
SELECT /*+ LEADING(c o i) 
           USE_NL(o) USE_NL(i)
           INDEX(o IX_ORD_CDT) */
       ...
```

3. **SQL Plan Management 활용**
```sql
-- 현재 플랜을 Baseline으로 고정
VAR cnt NUMBER;
BEGIN
  :cnt := DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE(
    sql_id => 'sql_id_here'
  );
END;
/
```

## 실전 튜닝 사례 연구

### 사례 1: 느린 페이징 쿼리 개선

**문제**: 고객 주문 조회 화면에서 2페이지 이후 조회 속도 저하

**원인 분석**:
- 잘못된 조인 순서로 인한 대량 정렬 작업
- Stopkey 최적화 미적용

**해결 방안**:
```sql
-- 개선 전
SELECT * FROM (
  SELECT /*+ LEADING(o i c) */ 
         o.*, i.*, c.customer_name,
         ROW_NUMBER() OVER (ORDER BY o.order_dt DESC) rn
  FROM   orders o, order_items i, customers c
  WHERE  o.order_id = i.order_id
  AND    o.cust_id = c.cust_id
  AND    c.region = :region
) WHERE rn BETWEEN 101 AND 150;

-- 개선 후
SELECT /*+ LEADING(c o i) 
           USE_NL(o) USE_NL(i)
           INDEX(o (cust_id, order_dt DESC)) */
       o.*, i.*, c.customer_name
FROM   customers c
JOIN   orders o ON o.cust_id = c.cust_id
JOIN   order_items i ON i.order_id = o.order_id
WHERE  c.region = :region
AND    o.order_dt < :last_page_date  -- 커서 기반 페이징
ORDER BY o.order_dt DESC
FETCH FIRST 50 ROWS ONLY;
```

### 사례 2: 대용량 배치 작업 성능 개선

**문제**: 일별 정산 배치 작업 시간 초과

**원인 분석**:
- 팩트 테이블부터 조인 시작으로 인한 대용량 해시 빌드
- 메모리 오버플로우로 인한 디스크 스필

**해결 방안**:
```sql
-- 개선 전
SELECT /*+ USE_HASH(f d1 d2) */
       d1.period, d2.category, SUM(f.amount)
FROM   fact f, dim_date d1, dim_product d2
WHERE  f.date_id = d1.date_id
AND    f.prod_id = d2.prod_id
GROUP BY d1.period, d2.category;

-- 개선 후
SELECT /*+ LEADING(d1 d2 f)
           USE_HASH(f) 
           SWAP_JOIN_INPUTS(f) */
       d1.period, d2.category, SUM(f.amount)
FROM   dim_date d1
JOIN   dim_product d2 ON 1=1  -- Cartesian 조인으로 작은 디멘전 조합 생성
JOIN   fact f ON f.date_id = d1.date_id 
              AND f.prod_id = d2.prod_id
WHERE  d1.year = 2024
AND    d2.category IN ('A','B','C')
GROUP BY d1.period, d2.category;
```

## 조인 순서 최적화를 위한 체계적 접근법

### 1. 쿼리 유형 분석
- OLTP 트랜잭션 vs DW 배치 처리
- Top-N/페이징 vs 전체 결과 집합
- 등치 조인 vs 비등치 조인

### 2. 데이터 특성 이해
- 테이블 크기와 분포
- 인덱스 구성과 클러스터링 팩터
- 선택도와 카디널리티 패턴

### 3. 실험 설계 및 측정
```sql
-- 다양한 조인 순서 실험
-- 케이스 1: A → B → C
SELECT /*+ LEADING(A B C) */ ... FROM A, B, C WHERE ...

-- 케이스 2: B → A → C  
SELECT /*+ LEADING(B A C) */ ... FROM A, B, C WHERE ...

-- 케이스 3: C → B → A
SELECT /*+ LEADING(C B A) */ ... FROM A, B, C WHERE ...

-- 각 케이스별 성능 측정
-- 1. 실행 시간
-- 2. 논리적/물리적 I/O
-- 3. 메모리 사용량
-- 4. TEMP 공간 사용량
```

### 4. 모니터링 및 검증
- 실제 운영 환경에서의 성능 모니터링
- 다른 값/부하 조건에서의 안정성 확인
- 장기적인 성능 추이 관찰

## 결론

조인 순서 최적화는 데이터베이스 성능 튜닝에서 가장 중요한 요소 중 하나입니다. 효과적인 조인 순서 선택은 다음과 같은 원칙에 기반해야 합니다:

1. **데이터 흐름 이해**: 어플리케이션의 데이터 접근 패턴과 비즈니스 로직을 이해하는 것이 먼저입니다. 어떤 테이블이 필터링의 시작점이 되어야 하는지 파악하세요.

2. **통계의 정확성**: 옵티마이저가 올바른 결정을 내리기 위해서는 정확한 통계 정보가 필수적입니다. 히스토그램, 확장 통계, 시스템 통계를 주기적으로 갱신하세요.

3. **조인 메소드 특성 이해**: 각 조인 메소드(NL, 해시, 소트 머지)의 장단점과 최적의 적용 조건을 이해하세요. 상황에 맞는 조인 메소드 선택이 조인 순서 결정과 연계됩니다.

4. **실험적 접근**: 이론적 최적화와 실제 성능은 다를 수 있습니다. 다양한 조인 순서를 실험하고, 실제 성능 측정치를 비교하는 체계적인 접근이 필요합니다.

5. **지속적인 모니터링**: 최적의 조인 순서는 시간이 지나며 변화할 수 있습니다. 데이터 양의 변화, 사용 패턴 변화, 시스템 업그레이드 등을 고려하여 지속적으로 모니터링하세요.

6. **적절한 도구 활용**: `DBMS_XPLAN`, `V$` 뷰, SQL 모니터링 도구 등을 효과적으로 활용하여 문제를 진단하고 해결하세요.

조인 순서 최적화는 단순한 기술적 문제를 넘어, 데이터 구조, 어플리케이션 패턴, 비즈니스 요구사항을 종합적으로 이해하는 과정입니다. 체계적인 접근과 지속적인 학습을 통해 효과적인 조인 순서 전략을 수립할 수 있을 것입니다.