---
layout: post
title: Elixir - 제어 구문 (2)
date: 2025-11-17 23:25:23 +0900
category: Elixir
---
# 제어 구문 (2)

## 예외 발생시키기 (Raising exceptions)

### `raise/1,2` 기본 — 예외 객체와 메시지

가장 기본적인 예외 발생 방식은 `raise/1`, `raise/2` 이다.

```elixir
# 문자열만 넘기면 RuntimeError

raise "boom"
# == raise(RuntimeError, "boom")

# 예외 모듈 + 메시지(문자열)

raise RuntimeError, "boom"

# 예외 모듈 + 키워드 옵션

raise ArgumentError, message: "bad arg"
```

요약:

- `raise/1` 에 **문자열**을 주면 `RuntimeError` 가 생성된다.
- `raise ExceptionModule, arg` 형식에서:
  - `ExceptionModule` 은 보통 `defexception` 으로 정의된 모듈.
  - `arg` 는 보통 문자열 또는 키워드 리스트.
  - 실제 예외 구조체 생성은 **해당 모듈의 `exception/1` 콜백**이 담당한다.

대표적인 **표준 예외들**:

- `ArgumentError` — 잘못된 인자
- `RuntimeError` — 일반적인 실행 시 오류
- `FunctionClauseError` — 함수 절 패턴 매칭 실패
- `CaseClauseError` — `case` 절에서 아무 것도 매칭되지 않을 때
- `MatchError` — 패턴 매칭 실패
- `KeyError` — 맵/키워드 리스트에서 키를 찾지 못했을 때
- `ArithmeticError` — 0으로 나누기 등 산술 예외
- `File.Error` — 파일 관련 오류 등

#### 예외는 값이다 (Exception struct)

예외도 결국 **구조체(struct)** 이다.

```elixir
try do
  raise ArgumentError, "bad arg"
rescue
  e ->
    e.__struct__     # ArgumentError
    e.message        # "bad arg"
end
```

예외도 “값”이므로, `Exception.message/1` 로 메시지를 추출하고,
`Exception.format/3` 으로 스택트레이스를 포함한 문자열로 만들 수 있다(로깅에 중요).

---

### `try/rescue/after` — 최소만 사용하기

`try` 는 **예외를 잡는 표현식**이다.

```elixir
try do
  risky()
rescue
  e in [ArgumentError, RuntimeError] ->
    {:error, {:unexpected, e.message}}
after
  cleanup()  # 이 블록은 항상 실행
end
```

- `try` 블록 안에서 예외가 발생하면, `rescue` 절의 패턴/가드에 따라 매칭된다.
- `after` 블록은:
  - 예외가 나든, `return` 되든, `throw` 되든, **무조건** 실행된다.
  - 주로 **파일/락/소켓/리소스 해제**에 사용한다.

#### `rescue` 매칭 패턴

`rescue` 절에서는 다음과 같은 패턴이 가능하다.

```elixir
try do
  ...
rescue
  e in [ArgumentError, RuntimeError] ->
    # 위 둘 중 하나 => e는 해당 예외 구조체
    {:error, {:unexpected, e}}

  %MyApp.ParseError{line: line} = e ->
    {:error, {:parse_error, line, e.message}}

  e ->
    # 모든 예외
    {:error, {:unknown, e}}
end
```

- `e in [Mod1, Mod2]` — 예외 모듈 리스트 매칭
- 구조체 패턴 매칭도 가능하다.
- 마지막에 포괄적인 `e ->` 를 두어 로깅 후 다시 던질 수도 있다.

```elixir
try do
  work!()
rescue
  e ->
    log(e)
    reraise e, __STACKTRACE__
end
```

#### `after` — 리소스 정리에만 쓰기

`after` 블록은 다음과 같은 작업에만 한정하는 것이 좋다.

- 파일 핸들 닫기 (`File.close/1`)
- 데이터베이스 커넥션 반환
- 락 해제
- 임시 디렉토리 삭제

예:

```elixir
def with_tmp_file(fun) do
  path = Path.join(System.tmp_dir!(), "tmp-" <> Base.encode16(:crypto.strong_rand_bytes(4)))
  File.write!(path, "")
  try do
    fun.(path)
  after
    File.rm(path)
  end
end
```

이 안에서 **새로운 예외를 던지거나, 복잡한 제어 흐름을 만들면 안 좋다**.
최대한 “정리”의 역할만 수행하도록 유지해야 한다.

#### try를 남발하면 제어 흐름이 숨는다

나쁜 예:

```elixir
def process(input) do
  try do
    a = step1!(input)
    b = step2!(a)
    c = step3!(b)
    {:ok, c}
  rescue
    _ -> {:error, :failed}
  end
end
```

- 어디에서 예외가 나는지 파악이 어렵고,
- 모든 종류의 예외를 감싸서 하나로 덮어버리므로 **디버깅이 힘들다**.

좋은 예:

- `step1/1`, `step2/1`, `step3/1` 을 **태그드 튜플**로 설계하고,
- `with` 로 합성하는 쪽이 나을 때가 많다.

```elixir
def process(input) do
  with {:ok, a} <- step1(input),
       {:ok, b} <- step2(a),
       {:ok, c} <- step3(b) do
    {:ok, c}
  end
end
```

예외는 진짜 **“복구 불가”** 상황에만 쓰고,
일반적인 실패는 **값으로 표현**하는 것이 더 합리적이다(12.5에서 상세히).

---

### `throw/catch` vs 예외 — 비국소 반환의 유산

엘릭서에는 `throw/1`, `catch` 구문도 존재한다.

```elixir
result =
  try do
    Enum.each(1..10, fn x ->
      if x == 7, do: throw({:found, x})
    end)

    :none
  catch
    {:found, v} -> {:ok, v}
  end
```

- `throw/1` 는 **예외가 아니라, 비국소(non-local) 반환 메커니즘**이다.
- `throw/catch` 는 **언어 유산**으로 남아 있을 뿐, **새 코드에서는 거의 권장되지 않는다.**

#### 왜 권장되지 않나?

1. **제어 흐름 파악이 어렵다.**
   - `throw` 를 쓰면, 함수의 반환 타입을 보고는 흐름을 이해하기 어렵다.
2. **Enum/Stream 패턴으로 대체 가능**:
   - 예를 들어 “조건을 만족하면 중단하고 값을 반환”은 `Enum.reduce_while/3` 로 표현할 수 있다.

```elixir
Enum.reduce_while(1..10, :none, fn x, _acc ->
  if x == 7, do: {:halt, {:ok, x}}, else: {:cont, :none}
end)
```

3. 팀 규약에서 **“throw 금지”** 로 잡는 경우가 많다.

따라서:

- `throw/catch` 는 **표준 라이브러리나 옛 코드 일부**에서만 제한적으로 보게 될 것이고,
- 새로 작성하는 코드는 `Enum.reduce_while/3`, `Stream`, `cond`, `case` 로 제어 흐름을 표현하는 것이 좋다.

---

### `exit`와 프로세스 종료 — 동시성 맥락에서의 실패

엘릭서/Erlang VM(BEAM)에는 **프로세스 종료 신호** 개념이 있다.
`exit/1` 은 현재 프로세스를 종료시키는 신호를 일으킨다.

```elixir
pid1 = spawn(fn -> exit(:normal) end)  # 정상 종료
pid2 = spawn(fn -> exit(:boom) end)    # 비정상 종료
```

차이:

- `:normal` 종료:
  - 링크된 프로세스에게 **전파되지 않는다**.
  - Supervisor 입장에서는 “정상 종료”.
- 다른 이유(`:boom` 등):
  - 링크된 프로세스에게 **종료 신호**를 전파한다.
  - Supervisor가 이를 보고 **재시작 전략**을 적용한다.

#### 링크된 프로세스와 `:trap_exit`

```elixir
parent =
  spawn(fn ->
    Process.flag(:trap_exit, true)
    child = spawn_link(fn -> exit(:boom) end)

    receive do
      {:EXIT, ^child, reason} ->
        IO.puts("child exited with #{inspect(reason)}")
    end
  end)
```

- `spawn_link/1` 로 생성된 자식이 `exit(:boom)` 을 호출하면,
- 부모가 `:trap_exit` 플래그를 켜두었을 경우,
  `{:EXIT, child_pid, reason}` 메시지를 `receive` 로 받는다.
- GenServer 등 OTP 서버는 내부적으로 이런 메커니즘을 활용하며,
  일반적으로 애플리케이션 개발자는 **Supervisor + GenServer 로 캡슐화된 형태**로 접하게 된다.

#### 예외 vs exit — 어떤 차이가 있나?

- 예외 (`raise`) 는 **현재 프로세스 스택 안**에서 발생한다.
  - 처리되지 않으면 프로세스를 종료시키지만, **예외 객체/메시지/스택트레이스**가 남는다.
- `exit/1` 은 **즉시 프로세스 종료 신호**를 발생시킨다.
  - 보통은 “더 이상 이 프로세스를 유지할 필요가 없다”는 뜻.
  - Supervisor에게 재시작을 유도하는 용도.

실무에서는:

- **도메인 로직 오류** → 예외 (`raise`) 로 처리.
- **프로세스 레벨 결단**(더 이상 이 서버를 유지하지 않음) → 예외거나 `exit/1`, 둘 다 결국 프로세스 종료로 귀결된다.
- OTP 서버에서는 예외를 그대로 터뜨리면, 런타임이 이를 `exit` 로 전파하는 구조다.

---

### 커스텀 예외 — `defexception`

도메인에 특화된 오류를 선언하려면 `defexception` 을 사용한다.

```elixir
defmodule MyApp.ParseError do
  defexception [:path, :line, :message]

  @impl true
  def exception(opts) do
    path = Keyword.fetch!(opts, :path)
    line = Keyword.get(opts, :line, 0)
    msg  = Keyword.get(opts, :message, "invalid format")

    %__MODULE__{
      path: path,
      line: line,
      message: "#{path}:#{line} #{msg}"
    }
  end
end
```

사용:

```elixir
raise MyApp.ParseError, path: "data.csv", line: 42
```

- `exception/1` 콜백은 `raise Mod, arg` 에서 호출되며,
  `arg` 를 해석해 **구조체를 만들어 준다**.
- `:message` 필드는 `Exception.message/1` 에서 사용된다.

#### 기본 구현과 커스터마이즈

`defexception` 에서 `exception/1` 을 구현하지 않으면, 기본 구현은:

- 키워드 리스트/맵을 그대로 구조체 필드에 넣고,
- `message` 필드가 없으면 기본 메시지를 사용한다.

필요한 경우에만 `exception/1` 을 오버라이드하면 된다.

예: 비교적 단순한 예외

```elixir
defmodule MyApp.NotFoundError do
  defexception [:resource, :id]

  def message(%__MODULE__{resource: r, id: id}) do
    "#{inspect(r)} with id=#{inspect(id)} not found"
  end
end
```

- 여기서는 `exception/1` 대신 **`message/1`만 오버라이드**했다.
- `raise MyApp.NotFoundError, resource: User, id: 10` 으로 사용.

---

### “뱅(!)” 관례: 성공 시 값, 실패 시 예외

엘릭서/OTP에서는 **뱅 함수(`foo!/1`)와 비뱅 함수(`foo/1`)** 를 쌍으로 제공하는 패턴이 매우 흔하다.

대표 예:

```elixir
File.read!("config.yml")  # 실패 시 예외
File.read("config.yml")   # {:ok, bin} | {:error, reason}
```

일반 관례:

- 비뱅 함수(`foo/1`)는 **태그드 튜플**로 결과를 반환:
  - 성공: `{:ok, value}`
  - 실패: `{:error, reason}`
- 뱅 함수(`foo!/1`)는:
  - 성공: **값(value)만 반환**
  - 실패: **예외를 발생**(raise)

이를 직접 구현해보면:

```elixir
defmodule MyApp.Config do
  def load(path) do
    with {:ok, bin} <- File.read(path),
         {:ok, config} <- parse(bin) do
      {:ok, config}
    end
  end

  def load!(path) do
    case load(path) do
      {:ok, config} -> config
      {:error, reason} ->
        raise MyApp.ConfigError,
          path: path,
          message: "failed to load config: #{inspect(reason)}"
    end
  end
end
```

이 패턴의 장점:

- **라이브러리 경계**에서는 비뱅(튜플) 인터페이스를 제공 →
  호출자가 `with`, `case` 등으로 실패를 조합/처리 가능.
- **스크립트/테스트/부트스트랩 경로** 등 “실패 = 즉시 중단”인 곳에서는
  뱅 버전을 써서 예외로 빠르게 종료.

---

### Exception 모듈과 스택트레이스

`Exception` 모듈은 예외 구조체를 다루는 공용 API를 제공한다.

```elixir
try do
  raise ArgumentError, "bad"
rescue
  e ->
    msg   = Exception.message(e)
    stack = __STACKTRACE__

    formatted = Exception.format(:error, e, stack)
    log(formatted)
    {:error, msg}
end
```

중요 포인트:

- `__STACKTRACE__` 는 `rescue` / `catch` / `after` 블록 안에서 사용 가능한 특별한 바인딩이다.
- `Exception.format/3` 은 에러 종류(`:error`), 예외 구조체, 스택트레이스를 받아
  사람이 읽기 좋은 문자열을 만들어 준다.

테스트/로깅에서 매우 자주 사용되는 패턴이다.

---

### 예외 사례 모음 — 어떤 예외가 언제 발생하는가

예외 타입과 대표 상황을 몇 가지 더 정리해보면:

```elixir
def demo_match_error do
  {:ok, value} = {:error, :bad}
end
# => MatchError

def demo_case_clause_error(x) do
  case x do
    1 -> :one
    2 -> :two
  end
end
# x가 1,2 아니면 CaseClauseError

def demo_function_clause_error do
  String.to_integer("not_int")
end
# 내부에서 FunctionClauseError 또는 ArgumentError

```

- 패턴 매칭에서 `=` 좌변에 있는 패턴이 맞지 않으면 `MatchError`.
- `case` 절이 아무 것도 매칭하지 못하면 `CaseClauseError`.
- 함수 정의된 모든 절이 인자와 맞지 않으면 `FunctionClauseError`.

이 예외들을 **일부러 잡으려 하기보다는**,
대부분은 **버그를 드러내는 신호**로 보고 고치는 것이 정석이다.

---

## 예외를 이용해 설계하기 (Designing with exceptions)

지금까지는 “예외를 **어떻게 발생시키고, 잡는지**”를 봤다.
이제는 “예외를 **어디까지 허용하고, 어디서 값으로 내려야 하는지**”를 설계 관점에서 본다.

### 실패 모델 분리: 예상 가능한 실패 vs 실패해서는 안 되는 상태

가장 먼저 해야 할 일은 **“어떤 실패를 예외로 볼 것인지”** 를 정의하는 것이다.

| 상황 | 권장 수단 | 예시 |
|------|-----------|------|
| 입력 검증 실패, 없는 파일, 네트워크 타임아웃(복구 가능) | `{:ok, v} \| {:error, r}` | `File.read/1`, HTTP 클라이언트, 파서의 recoverable 오류 |
| 불변식 위반, 프로그래밍 버그, 절대 복구 불가 | `raise` (예외) | 정렬 루틴에 `nil` 전달, 내부 state 깨짐, assert 위반 |
| 프로세스 레벨 치명 실패 | `exit` + Supervisor 재시작 | GenServer 내부 `raise` → 크래시 → Supervisor 전략 |

규칙을 문장으로 쓰면:

> $$\text{호출자가 합리적으로 대처할 수 있으면} \Rightarrow \text{튜플로 내려라}$$
> $$\text{대처 불가/버그/불변식 위반이면} \Rightarrow \text{예외로 빠르게 터뜨려라}$$

예:

```elixir
def get_user(id) do
  case Repo.get(User, id) do
    nil -> {:error, :not_found}
    u   -> {:ok, u}
  end
end

def get_user!(id) do
  case get_user(id) do
    {:ok, u} -> u
    {:error, :not_found} ->
      raise MyApp.NotFoundError, resource: User, id: id
  end
end
```

- “없는 유저”는 **예상 가능한 상황** → `{:error, :not_found}` 로 내려준다.
- “유저가 반드시 있어야 하는 컨텍스트”에서는 `get_user!/1` 을 사용하고, 없으면 예외로 빠르게 터뜨려 **버그를 드러낸다**.

---

### 경계에서 예외 ↔ 튜플 변환

라이브러리/모듈 내부에서 예외를 사용하더라도,
**외부로 공개하는 API** 는 태그드 튜플로 정리해 주는 것이 좋다.

```elixir
def parse_safe(bin) do
  {:ok, parse!(bin)}
rescue
  e in MyApp.ParseError ->
    {:error, {:parse_error, e}}

  e ->
    {:error, {:unknown_error, e}}
end
```

이제 상위에서는:

```elixir
with {:ok, bin} <- File.read(path),
     {:ok, doc} <- parse_safe(bin),
     {:ok, out} <- transform_safe(doc) do
  {:ok, out}
else
  {:error, r} -> {:error, r}
end
```

- 내부 구현이 `parse!/1`, `transform!/1` 같은 **예외 기반**이더라도,
- 외부에서는 `parse_safe/1`, `transform_safe/1` 로 **값 기반** 인터페이스를 얻는다.
- 이를 통해 **여러 모듈의 실패를 하나의 with 체인으로**, 선언적으로 합성할 수 있다.

---

### `with`와 예외 전략 — 한 층에서는 한 모델만

`with` 는 태그드 튜플 기반 연산을 합성하는 데 최적화된 도구다.

```elixir
with {:ok, u}  <- fetch_user(id),
     {:ok, ok} <- authorize(u, :write),
     {:ok, r}  <- do_write(u, payload) do
  {:ok, r}
end
```

여기에 예외 기반 함수가 섞이면:

```elixir
with {:ok, u} <- fetch_user(id),
     :ok      <- authorize!(u, :write),     # 예외 기반
     {:ok, r} <- do_write(u, payload) do
  {:ok, r}
end
```

- `authorize!/2` 가 예외를 던지면, `with` 의 실패 가지가 아니라 **제어 흐름 자체가 깨진다**.
- 이 층에서는 “성공/실패 모두 튜플로 표현한다”는 전제가 깨짐.

따라서 한 층(한 함수 안)에서는:

- 되도록 **“모두 튜플”** 또는 **“모두 예외”** 로 통일하는 것이 좋다.
- 예외 기반 함수는 별도의 층(예: `safe` 어댑터)에서 래핑.

---

### 동시성과 예외 — “Let it crash” + Supervisor

BEAM(엘릭서/Erlang VM)의 핵심 철학 중 하나가 **“Let it crash”** 이다.

간단한 GenServer 예:

```elixir
defmodule Srv do
  use GenServer

  def start_link(init \\ 0) do
    GenServer.start_link(__MODULE__, init, name: __MODULE__)
  end

  @impl true
  def init(state), do: {:ok, state}

  @impl true
  def handle_call({:div, a, b}, _from, state) do
    {:reply, a / b, state}
  end
end
```

- 여기서 `b = 0` 인 요청이 들어오면 `ArithmeticError` 가 발생한다.
- 이 예외는 GenServer 프로세스를 **크래시**시키고, 링크된 Supervisor가 이를 감지해 **재시작** 한다.

Supervisor:

```elixir
children = [
  {Srv, 0}
]

Supervisor.start_link(children, strategy: :one_for_one)
```

이 패턴은:

- 서버 내부에서 **무리하게 모든 실패를 방어**하려 하지 말고,
- “정상만 처리하겠다”는 **단순한 불변식**을 가정한 뒤,
- 나머지는 **예외로 터뜨려 Supervisor가 재시작하게** 맡기는 것이다.

#### 경계에서 방어, 내부에서 단순화

이 철학의 핵심은 다음과 같이 요약할 수 있다.

- 외부 세계(HTTP, CLI, 파일, DB, 메시지 큐)는 **경계 모듈**(컨트롤러, 어댑터)에서 검증한다.
  - 이 층은 **비정상 데이터**를 튜플 에러로 정리해 내려보냄.
- 내부 서버(GenServer, Task, 도메인 로직)는 **“깨끗한 데이터”만 온다고 가정**한다.
  - 불변식이 깨지면 **예외/크래시**.
- Supervisor는 이런 크래시를 보고 **다시 시작**한다.

불변식 위반 시:

```elixir
def handle_cast({:put, k, v}, state) do
  true = valid_kv?(k, v)  # false면 MatchError로 크래시
  {:noreply, Map.put(state, k, v)}
end
```

- `true = valid_kv?(...)` 패턴은 **assert**와 같다.
- 이 레벨에서는 “잘못된 데이터”는 이미 올라오지 않는다는 가정을 한다.

---

### `after`/리소스 안전 패턴 — 예외를 신경쓰지 않는 코드 만들기

리소스를 다루는 코드에서는 **예외 여부와 관계없이 정리를 보장**해야 한다.

```elixir
def with_file(path, mode, fun) do
  {:ok, io} = File.open(path, mode)

  try do
    fun.(io)
  after
    File.close(io)
  end
end
```

사용:

```elixir
with_file("data.txt", [:read], fn io ->
  IO.read(io, :all)
end)
```

- `fun.(io)` 안에서 예외가 나더라도, `File.close/1` 은 반드시 호출된다.
- 이 패턴은 DB 커넥션, Lock, ETS 테이블 핸들, 소켓 등에도 동일하게 적용 가능하다.

---

### 예외 로깅/관찰: Logger + Exception.format

예외를 “조용히 삼키면” 장애 분석이 불가능해진다.
반드시 **로그/관찰**을 남긴 뒤, 필요하다면 다시 던져야 한다.

```elixir
def wrap_with_logging(fun) do
  fun.()
rescue
  e ->
    require Logger
    Logger.error(Exception.format(:error, e, __STACKTRACE__))
    reraise e, __STACKTRACE__
end
```

- `Exception.format/3` 는 예외와 스택트레이스를 **사람이 읽기 좋은 문자열**로 만든다.
- 이 문자열을 로그/모니터링 시스템에 남기면,
  나중에 장애 분석 시 큰 도움이 된다.

---

### `reraise/2` 와 스택 유지

가끔 예외를 한 번 가로채서 **메시지를 보강**한 뒤,
원래 스택을 유지한 채 다시 던지고 싶을 때 `reraise/2` 를 쓴다.

```elixir
def parse_with_context(bin, ctx) do
  parse!(bin)
rescue
  e in MyApp.ParseError ->
    new = %MyApp.ParseError{e | message: "[#{ctx}] " <> e.message}
    reraise new, __STACKTRACE__
end
```

- 이렇게 하면 최종적으로 보게 되는 스택트레이스에는
  **원래 예외가 발생한 위치**가 그대로 남는다.
- `raise new` 만 사용하면 현재 위치에서 다시 시작된 스택으로 보이기 때문에,
  원래의 발생 위치가 가려질 수 있다.

---

### 테스트 전략: “빠르게 실패”를 증명하라

예외 기반 API는 테스트에서도 “정상·비정상” 모두 명시적으로 검증해야 한다.

```elixir
test "parse!/1 raises on bad input" do
  assert_raise MyApp.ParseError, fn ->
    parse!("BAD")
  end
end

test "parse/1 returns error tuple on bad input" do
  assert {:error, {:parse_error, _}} = parse("BAD")
end
```

- `assert_raise/2` 에 예외 모듈과 함수를 넘겨, **정말 예외가 발생하는지** 확인한다.
- 같은 로직을 비뱅/뱅 버전으로 나눴다면,
  두 함수가 **동일한 실패 의미**를 전달하는지 테스트로 묶어둘 수 있다.

---

## 더 적은 것들로 더 큰 효과를 (Less is more)

지금까지 다룬 내용을 **몇 가지 핵심 패턴과 레시피**로 요약해보자.

### 미니멀 도구 상자

실제 서비스 코드에서 자주 쓰이는 도구는 다음 다섯 가지에 압축할 수 있다.

1. **패턴 매칭 + 가드 + 다중 함수 헤드**
2. **`with` + 태그드 튜플**
3. **`raise` + `defexception` (진짜 비정상에만)**
4. **`try/after` (리소스 안전)**
5. **Supervisor (재시작/복구 책임)**

이 다섯 가지를 일관되게 사용하면:

- 제어 흐름이 **선언적**이고,
- 실패 모델이 **예측 가능**하며,
- 장애가 나도 **스스로 회복**하는 구조를 갖출 수 있다.

---

### “경계에서 방어, 내부는 단순”

전체 시스템을 다음과 같이 나눠보자.

- **경계(boundary)**:
  - HTTP 컨트롤러, CLI 인자 파서, 메시지 큐 소비자, 파일/소켓 I/O 등
  - 역할:
    - 입력 검증
    - 형 변환
    - 외부 예외 → 태그드 튜플 매핑

- **내부(core)**:
  - 도메인 로직, GenServer 상태, 알고리즘
  - 역할:
    - 깨끗한 데이터에 대한 순수/준순수 연산
    - 불변식 위반 시 중앙에서 `raise` / assert

- **슈퍼비전(supervision)**:
  - Supervisor 트리
  - 역할:
    - 프로세스 크래시 감지
    - 설정된 전략에 따라 재시작/중단

이 구조에서 전체 복잡도는 대략:

$$
\text{복잡도}_{\text{전체}} \approx \text{복잡도}_{\text{경계}} + \text{복잡도}_{\text{내부}}.
$$

내부 복잡도를 일정하게 유지하면(단순한 불변식),
전체 복잡도는 거의 **경계 복잡도에 의해 지배**된다.

이때의 전략은:

- 경계를 두텁게(검증 철저),
- 내부를 얇게(불변식 단순) 설계하는 것이다.

---

### 뱅/비뱅 API 일관성

라이브러리/서비스에서 자주 필요한 규약:

- 외부에 공개하는 함수라면 가능하면:
  - `do_something/1` — `{:ok, v} | {:error, r}`
  - `do_something!/1` — `v` 또는 예외
- 이때 **실제 로직은 하나**에 두고,
  나머지 하나는 래퍼로 구현한다.

예:

```elixir
defmodule MyApp.Data do
  def load(path) do
    with {:ok, bin} <- File.read(path),
         {:ok, doc} <- decode(bin) do
      {:ok, doc}
    end
  end

  def load!(path) do
    case load(path) do
      {:ok, doc} -> doc
      {:error, r} ->
        raise MyApp.LoadError, path: path, reason: r
    end
  end
end
```

이렇게 하면:

- CLI 스크립트: `load!/1` 로 간단히 예외 기반 사용
- 웹 핸들러: `load/1` + `with` 로 실패 핸들링

을 각각 자연스럽게 선택할 수 있다.

---

### 흐름보다 타입(형태)을 믿어라

예외/제어 구문을 설계할 때,
가능한 한 “**데이터의 형태**(type/shape)를 중심으로” 생각하는 것이 좋다.

- `case`/함수 헤드로 **입력 모양을 패턴 매칭**
- 커스텀 예외 구조체(`defexception`)로 **도메인 오류를 타입으로 표현**
- 태그드 튜플로 **성공/실패를 구분된 형태로 표현**

제어 흐름은 자연히 **이 타입들의 조합 결과**가 된다.

예:

```elixir
defmodule MyApp.Result do
  @type t(a) :: {:ok, a} | {:error, term()}
end
```

이걸 전제로 하면:

- 모든 핵심 함수는 `MyApp.Result.t(a)` 형태를 반환
- 예외는 “이 타입의 설계 범위를 벗어나는 상황”에서만 사용

---

### 실제 레시피 3종 (정리)

#### “읽고, 파싱하고, 변환하고, 저장하기”

경계 + 내부를 분리한 예:

```elixir
def run(path) do
  with {:ok, bin} <- File.read(path),
       {:ok, doc} <- My.Parse.safe(bin),      # 내부 parse!/1 을 감싸는 safe
       {:ok, out} <- My.Transform.safe(doc),
       :ok        <- My.Store.safe(out) do
    :ok
  end
end
```

내부:

```elixir
defmodule My.Parse do
  def safe(bin) do
    {:ok, parse!(bin)}
  rescue
    e in MyApp.ParseError -> {:error, {:parse_error, e}}
  end

  def parse!(bin) do
    # 파싱 로직, 불변식 위반 시 raise MyApp.ParseError
  end
end
```

#### 리소스 안전 파이프라인 (파일 → 파일)

```elixir
def copy_upper!(src, dst) do
  {:ok, in_}  = File.open(src, [:read])
  {:ok, out_} = File.open(dst,  [:write])

  try do
    IO.stream(in_, :line)
    |> Stream.map(&String.upcase/1)
    |> Enum.into(IO.stream(out_, :line))
  after
    File.close(in_)
    File.close(out_)
  end
end
```

- 예외/return/throw 어디서 발생하든 파일은 반드시 닫힌다.

#### 서버 내부: “깨지면 크래시” + 외부 검증

컨트롤러(경계):

```elixir
def handle_request(%{"id" => id, "value" => value}) do
  with {:ok, id}    <- parse_id(id),
       {:ok, value} <- parse_value(value),
       :ok          <- MyServer.put(id, value) do
    {:ok, :stored}
  else
    {:error, r} -> {:error, r}
  end
end
```

서버 내부:

```elixir
defmodule MyServer do
  use GenServer

  def put(id, value) do
    GenServer.cast(__MODULE__, {:put, id, value})
  end

  @impl true
  def handle_cast({:put, id, value}, state) do
    true = valid?(id, value)  # 불변식, 깨지면 크래시
    {:noreply, Map.put(state, id, value)}
  end
end
```

- 잘못된 값은 **경계에서 튜플 에러**로 걸러진다.
- 내부 서버는 “정상만 온다”고 가정하고 더 단순화.

---

### 반패턴 체크리스트

코드 리뷰 때 보면 좋은 체크리스트:

- [ ] 모든 실패를 예외로 던지고 있는가?
      → **예상 가능한 실패**는 태그드 튜플로 내려야 한다.
- [ ] `try/rescue` 가 너무 많이 등장하는가?
      → 경계에서만 최소한으로 두고, 나머지는 `with` 등으로 재구성.
- [ ] 서버 내부에서 모든 입력 검증을 하고 있는가?
      → 검증을 **경계로 이동**하고, 내부는 단순한 불변식 위주로.
- [ ] `throw/catch` 를 새 코드에서 사용하고 있는가?
      → `Enum.reduce_while/3`, `cond`, `case` 로 대체.
- [ ] 리소스 정리를 `if ok? do close end` 형태로만 하고 있는가?
      → **`try/after` 로 보장**하도록 리팩터링.

---

### 연습 문제

1) **커스텀 예외 타입**
   - `MyApp.SchemaError` 를 정의하고,
   - `validate!/1` 에서 필수 필드 누락 시 `SchemaError` 를 raise.
   - 외부에 `validate/1`(비뱅)을 두어 `{:ok, data} | {:error, e}` 형태로 노출.

2) **경계 변환기**
   - 외부 HTTP 라이브러리에서 예외를 던지는 `get!/1` 함수가 있다고 하자.
   - 이를 감싸는 `get/1` 을 작성해,
     - 성공: `{:ok, body}`
     - 실패: `{:error, {:http_error, e}}`
     형태로 변환. `with` 로 여러 HTTP 호출을 합성하는 예제도 작성.

3) **서버 불변식 테스트**
   - GenServer 상태가 항상 **정렬된 리스트**라는 불변식을 유지하도록,
     `true = sorted?(state)` 패턴을 `handle_cast/3` 안에 넣는다.
   - 의도적으로 잘못된 데이터를 넣어 크래시가 일어나고, Supervisor가 재시작하는지 통합 테스트.

4) **리소스 누수 방지 실험**
   - 파일 1만 개를 순회 처리하면서, 중간에 일부에서 예외를 발생시킨다.
   - `try/after` 없는 버전과 있는 버전을 비교해,
     파일 디스크립터 누수가 발생하는지 확인.

5) **뱅/비뱅 API 점검**
   - 사내 라이브러리에서 `!`/비`!` 쌍이 없는 중요한 함수를 찾아보고,
   - 뱅/비뱅 쌍을 추가하는 리팩터를 설계한다(문서/테스트까지 포함).

---

## 마무리

- **예외**는 “무엇인가 잘못되었음”을 알리는 강한 신호지만,
  모든 실패를 예외로 표현하면 코드가 금방 복잡해진다.
- **예상 가능한 실패**는 태그드 튜플과 `with` 로,
  **예상 불가능/복구 불가 상태**는 `raise` 로 빠르게 터뜨려라.
- 동시성 세계에서는 **프로세스 격리 + Supervisor** 를 믿고,
  서버 내부는 **단순한 불변식**만 지키도록 설계하는 것이 좋다.
- `try/rescue/after` 는 **경계에서 예외를 값으로 변환**하거나,
  **리소스를 정리**하는 데만 최소한으로 사용하자.
- 커스텀 예외(`defexception`)와 뱅/비뱅 관례를 잘 활용하면,
  코드가 **명세에 가까운 형태**를 갖추게 되고,
  장애가 났을 때도 **왜/어디서** 잘못됐는지 빠르게 파악할 수 있다.

이 장의 내용을 실제 프로젝트의 **핵심 모듈(파서, 스토리지, 서버, 컨트롤러)** 에
하나씩 적용해보면, “제어 흐름”에 대한 고민이 줄고,
대신 “데이터 형태와 불변식”에 집중할 수 있게 될 것이다.
