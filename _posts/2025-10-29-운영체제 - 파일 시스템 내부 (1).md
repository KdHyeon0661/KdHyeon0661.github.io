---
layout: post
title: 운영체제 - 파일 시스템 내부 (1)
date: 2025-10-29 19:25:23 +0900
category: 운영체제
---
# Chapter 15 — File-System Internals

## 15.1 File Systems

### 15.1.1 VFS(가상 파일시스템) 개요
현대 OS(리눅스, BSD, macOS 등)는 **VFS** 레이어로 서로 다른 파일시스템(ext4, XFS, Btrfs, ZFS, NTFS, FAT, NFS, FUSE…)을 **단일 API**로 통일한다.

- **핵심 객체**
  - **superblock**: 마운트된 파일시스템 인스턴스의 전역 메타데이터와 **연산 테이블**(super_operations).
  - **inode**: 파일/디렉터리/링크/장치노드 등 **객체의 속성**(권한/소유/타임스탬프/크기/블록 맵).
  - **dentry**(directory cache): **이름→inode** 매핑 캐시(경로 해석 가속, alias 처리).
  - **file**: `open()` 결과(프로세스별 오프셋/플래그/연산자(file_operations)).
- **데이터 경로**: 유저 API(`read`, `write`, `mmap`, `stat`…) → VFS → 구체적 파일시스템의 메서드로 디스패치.

**경로 해석 수식(단순 모델)**
경로 $$p = /a/b/c$$ 를 컴포넌트 시퀀스 $$\langle a,b,c\rangle$$ 로 두면,
$$
d_{i+1} = \operatorname{lookup}(d_i, c_{i+1}), \quad d_0=\text{root dentry}
$$
여기서 `lookup`은 dentry 캐시 미스 시 디렉터리 인덱스(B+-트리/해시/선형)를 조회해 inode를 찾고 **새 dentry**를 만든다.

---

### 15.1.2 파일시스템 코어 기능(요약)
- **주소 변환**: 파일 오프셋→물리(또는 논리) 블록(extent/간접블록/COW 노드).
- **일관성**: 저널링(WAL), Soft Updates, COW(Log-structured/WAFL/Btrfs/ZFS).
- **메타데이터 인덱싱**: 디렉터리 인덱스(HTree/B+-Tree), inode 테이블, 프리 공간 비트맵/트리.
- **캐시**: 페이지 캐시/리드어헤드/라이트백, dentry 캐시, inode 캐시.
- **보호/보안**: DAC/ACL/Capabilities/라벨(MAC), xattr, fs-verity(읽기 전용 무결성), 암호화(fscrypt/LUKS+dm-crypt).

---

### 15.1.3 VFS 연산 흐름(의사코드)

```c
// vfs_open(path, flags)
dentry *d = path_walk(path);         // dcache → miss면 디렉터리 인덱스 검색
inode  *ino = d->inode;
check_permissions(ino, flags);
file   *f = alloc_file(ino, flags);  // file_operations 연결
return install_fd(f);
```

```c
// vfs_read(file *f, void *buf, size_t n)
while (n>0) {
  page *pg = page_cache_lookup(f->inode, f->offset);
  if (!pg) pg = fs_readpage(f->inode, f->offset);  // 블록 IO + 리드어헤드
  size_t take = min(n, remain_in_page);
  copy_to_user(buf, pg->data + offset_in_page, take);
  f->offset += take; n -= take; buf += take;
}
```

---

### 15.1.4 예제: 안전한 파일 열기(Openat 패턴) — TOCTOU/심링크 방지
```c
// safe_openat.c
#define _GNU_SOURCE
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv){
  int dfd = open("/srv/data", O_DIRECTORY|O_RDONLY|O_CLOEXEC);
  int fd  = openat(dfd, "input.txt", O_RDONLY|O_NOFOLLOW|O_CLOEXEC);
  if (fd<0){ perror("openat"); return 1; }
  // ... read(fd) ...
  close(fd); close(dfd);
}
```
- **핵심**: 디렉터리 FD 기준의 상대 경로 + `O_NOFOLLOW`(심링크 레이스 차단) + `O_CLOEXEC`(FD 누수 차단).

---

### 15.1.5 예제: 초미니 FUSE 파일시스템(읽기 전용, Python)
> 외부 패키지 `fusepy`가 필요하지만, 구조만 이해해도 충분하다.

```python
# ro_memfs.py — 메모리 상 사전(dict)로 파일 제공(읽기 전용)
from fuse import FUSE, Operations
import errno, stat, time

FILES = {"/hello.txt": b"Hello VFS/FUSE!\n"}

class ROFS(Operations):
    def getattr(self, path, fh=None):
        now = int(time.time())
        if path == "/":
            return dict(st_mode=(stat.S_IFDIR|0o555), st_nlink=2, st_ctime=now, st_mtime=now, st_atime=now)
        if path in FILES:
            data = FILES[path]
            return dict(st_mode=(stat.S_IFREG|0o444), st_nlink=1, st_size=len(data), st_ctime=now, st_mtime=now, st_atime=now)
        raise OSError(errno.ENOENT, "")
    def readdir(self, path, fh):
        return [".",".."] + [name[1:] for name in FILES.keys()]
    def open(self, path, flags):
        if path not in FILES: raise OSError(errno.ENOENT,"")
        return 0
    def read(self, path, size, offset, fh):
        data = FILES[path]
        return data[offset: offset+size]

if __name__ == "__main__":
    FUSE(ROFS(), "/mnt/ro", foreground=True, ro=True)
```
- 커널은 VFS→FUSE로 **RPC 콜**을 보내고, 사용자 공간 서버가 응답한다.

---

### 15.1.6 일관성·내구성(요약)
- **저널링**: 트랜잭션 로그→커밋→홈 반영(메타/데이터 모드).
- **COW/Log-structured**: **새 위치에 쓰고 루트 포인터만 원자 교체**(스냅샷/체크섬과 궁합).
- **fsync/fdatasync/msync** 의미 차이를 정확히 이해해야 **크래시 시맨틱**을 예측 가능하게 만들 수 있다.

---

## 15.2 File-System Mounting

### 15.2.1 마운트란?
- 특정 **디바이스(혹은 가상 스택의 최상단)** 에 저장된 파일시스템 **인스턴스(superblock)** 를 **디렉터리 트리의 한 지점**(마운트 포인트)에 **연결**하는 행위.
- 리눅스에서는 `/proc/self/mountinfo`로 현재 네임스페이스의 마운트 그래프를 확인.

### 15.2.2 mount(2) 기본 흐름
1) 장치(또는 이미지/네트워크 FS)에서 **슈퍼블록 로드 & 검증**
2) **옵션 파싱**: ro/rw, noatime/relatime, barrier, discard, uid/gid/umask(비POSIX FS), `subvol=`(Btrfs) 등
3) **마운트 트리**에 노드 삽입(바인드/오버레이/프라이빗/쉐어드 전파 규칙 적용)

```c
// mount_bind.c — bind mount 예시
#define _GNU_SOURCE
#include <sys/mount.h>
#include <unistd.h>
#include <stdio.h>

int main(){
  // /var/log를 /mnt/logs에 "이름만 다른 동일한 트리"로 붙이기
  if (mount("/var/log", "/mnt/logs", NULL, MS_BIND, NULL)<0) { perror("mount bind"); return 1; }
  // 읽기 전용으로 재마운트(두 단계: bind 후 remount,ro)
  if (mount(NULL, "/mnt/logs", NULL, MS_BIND|MS_REMOUNT|MS_RDONLY, NULL)<0) { perror("remount ro"); return 1; }
  puts("ok"); return 0;
}
```

---

### 15.2.3 네임스페이스 & 전파(Propagation)
컨테이너 격리는 **마운트 네임스페이스**로 가능.

- **unshare** 로 새 네임스페이스 생성, **mount propagation** 으로 전파 제어:
  - `rprivate`: 전파 없음(기본 안전).
  - `rshared`: 상호 전파.
  - `rslave`: 상위→하위만 전파.

```bash
# 새 마운트 네임스페이스에서 작업
unshare -m bash -c '
  mount --make-rprivate /
  mount -t tmpfs tmpfs /tmp/isolated
  echo "hello" > /tmp/isolated/x
  ls /tmp/isolated
'
```

---

### 15.2.4 루트 전환: chroot vs pivot_root
- **chroot**: 경로 해석의 기준 디렉터리를 바꿀 뿐, 기존 마운트 트리는 유지. 보안 경계가 **완벽하지 않음**(특권/FD/네임스페이스 이슈).
- **pivot_root**: **루트 마운트 자체를 교체**. initramfs → 실제 루트로 전환에 사용.

```bash
# (initramfs 같은 환경 가정) 새 루트가 /newroot, 옛 루트는 /oldroot로 이동
mount --make-rprivate /
mount --bind /newroot /newroot
pivot_root /newroot /newroot/oldroot
exec chroot . sh -c 'umount -l /oldroot; exec /sbin/init'
```

---

### 15.2.5 오버레이/스택 파일시스템
- **overlayfs**: 하위(읽기 전용) + 상위(쓰기 가능) = **합성 뷰** 제공(컨테이너 이미지 레이어링).
```bash
mkdir -p lower upper work merged
mount -t overlay overlay -o lowerdir=lower,upperdir=upper,workdir=work merged
```

- **device-mapper 스택**: dm-crypt(LUKS)→LVM(Thin)→FS(ext4/XFS) 같은 계층 가능.

---

### 15.2.6 부팅/자동 마운트
- **/etc/fstab**: 부팅 시 마운트 정의. systemd는 `.mount`/`.automount` 유닛으로 관리 가능.
- **자동 마운트**: `x-systemd.automount`로 최초 접근 시 마운트(대기시간 감소).

```fstab
# /etc/fstab 예시(권장: UUID로 식별)
UUID=...  /data  xfs   noatime,attr2,discard    0  2
UUID=...  /backup ext4  noatime,nodiratime      0  2
//nas/share /mnt/nas cifs credentials=/root/cred,vers=3.1.1,uid=1000,gid=1000,iocharset=utf8,_netdev 0 0
```

---

### 15.2.7 루프장치/이미지 마운트
원시 이미지 파일을 **블록장치처럼** 취급:

```bash
dd if=/dev/zero of=disk.img bs=1M count=256
mkfs.ext4 -F disk.img
mkdir -p /mnt/img && sudo mount -o loop disk.img /mnt/img
```

파티션이 있는 이미지라면 `losetup -Pf`로 **파티션별 루프 노드** 생성(`/dev/loopXpY`).

---

### 15.2.8 보안/성능 옵션
- 보안: `nodev`(디바이스 노드 무효), `nosuid`(setuid 무효), `noexec`(실행 금지), `ro`.
- 성능: `noatime/relatime`, `barrier`(기본 on), `commit=`, `discard`, FS 고유 옵션(`lazytime`, `allocsize`, `logbufs` 등).

---

## 15.3 Partitions and Mounting

### 15.3.1 파티션이란?
물리/가상 디스크 한 개를 **논리적 영역**으로 나눈 것. 각 파티션은 독립적인 **블록 주소 범위**를 갖고 그 위에 **FS/LVM/스왑/RAID** 등을 얹는다.

- **MBR**: LBA0의 **부트 코드 + 파티션 테이블(최대 4개)**, 확장 파티션(EBR 체인)으로 4개 초과 지원.
- **GPT**: LBA1에 **헤더**, 그 뒤 **엔트리 배열**(보통 128개 이상), **백업 헤더**는 마지막 LBA. 64bit LBA, GUID, CRC.

```
MBR:
+---------+-----------------------+
|  LBA 0  |  Boot + 4 entries    |
+---------+-----------------------+
           \-> EBR -> logicals...

GPT:
LBA0: Protective MBR
LBA1: GPT Header (CRC, entries location/size, backup LBA)
LBA2..: Partition Entries (array)
LBAend-...: Backup Entries + Backup Header
```

---

### 15.3.2 파티션 테이블 읽기(개념 코드)

**MBR 16바이트 엔트리 형식(요약)**
- 상태(부팅 플래그), CHS 시작, 타입, CHS 끝, **LBA 시작(4B)**, **섹터 수(4B)**

```python
# parse_mbr.py — 매우 간단한 MBR 파서(오프셋만)
import struct
def parse_mbr(buf):
    assert buf[510:512]==b'\x55\xaa'
    parts=[]
    for i in range(4):
        off = 446 + i*16
        (boot, chs1, ptype, chs2, lba_start, nsects) = struct.unpack("<B3sB3sII", buf[off:off+16])
        if ptype!=0:
            parts.append((i, ptype, lba_start, nsects))
    return parts

# with open("/dev/sdx","rb") as f: print(parse_mbr(f.read(512)))
```

**GPT 헤더(요약 필드)**: `"EFI PART"` 시그니처, 헤더 크기, **CRC32**, **엔트리 시작 LBA**, **엔트리 개수/크기**, **백업 헤더 LBA**.

```python
# parse_gpt_header.py — GPT 헤더 일부만 확인(개념)
import struct
def parse_gpt_header(buf):
    sig=buf[0:8]
    if sig!=b'EFI PART': raise ValueError("no GPT")
    rev, hsize, crc, rsvd, cur_lba, bak_lba, first_usable, last_usable = struct.unpack("<I I I I Q Q Q Q", buf[8:8+48])
    return {"cur_lba":cur_lba, "bak_lba":bak_lba, "entry_start_lba": struct.unpack("<Q", buf[72:80])[0],
            "entry_size": struct.unpack("<I", buf[84:88])[0], "entry_count": struct.unpack("<I", buf[80:84])[0]}

# with open("/dev/sdx","rb") as f: print(parse_gpt_header(f.read(512)))
```

---

### 15.3.3 파티션 작성/조회/마운트 실습

#### (A) 새 디스크에 GPT + ext4 두 파티션 만들기
```bash
# 1. 빈 이미지 생성 → 루프 연결
dd if=/dev/zero of=disk.img bs=1M count=1024
sudo losetup -Pf disk.img         # /dev/loopX 와 파티션 /dev/loopXpY 생성
loopdev=$(losetup -j disk.img | awk -F: '{print $1}')

# 2. 파티션 (sgdisk 사용; parted/fdisk도 가능)
sudo sgdisk -og $loopdev                      # 새 GPT
sudo sgdisk -n 1:0:+200M -t 1:8300 $loopdev   # p1=200MiB Linux FS
sudo sgdisk -n 2:0:0     -t 2:8300 $loopdev   # p2=나머지 전부

# 3. 파일시스템 생성
sudo mkfs.ext4 -F ${loopdev}p1 -L BOOT
sudo mkfs.ext4 -F ${loopdev}p2 -L DATA

# 4. 마운트
sudo mkdir -p /mnt/boot /mnt/data
sudo mount ${loopdev}p1 /mnt/boot
sudo mount ${loopdev}p2 /mnt/data
```

#### (B) /etc/fstab 등록(부팅 시 자동)
```fstab
LABEL=BOOT   /boot  ext4  ro,noatime                         0  2
LABEL=DATA   /data  ext4  rw,noatime,commit=30,errors=remount-ro 0  2
```

---

### 15.3.4 LVM/RAID/암호화와의 스택
파티션은 종종 **여러 계층**의 일부다.

```
nvme0n1p3  ─┐
            ├─[LUKS dm-crypt]── dm-0 (cryptroot) ──[LVM PV]── VG ── LV(home) ── FS
nvme0n1p4  ─┘
md0(raid1) ────────────────────────────────────────┘
```

- **dm-crypt(LUKS)**: 암호화 → **UUID/LABEL**로 식별, `crypttab`/`initramfs`에서 해제.
- **LVM**: PV→VG→LV(Thin/심지어 snapshots) → FS 마운트.
- **mdraid**: RAID0/1/5/6/10 → 상단 스택으로 제공.

```bash
# LUKS + ext4 예시
cryptsetup luksFormat /dev/sdx2
cryptsetup open /dev/sdx2 cryptroot
mkfs.ext4 /dev/mapper/cryptroot
mount /dev/mapper/cryptroot /mnt
```

---

### 15.3.5 마운트 결정(최장 접두 규칙)
커널은 경로 $$p$$ 에 대해 **마운트 테이블**의 엔트리 중 **가장 긴 일치 접두사**를 선택한다.
마운트 포인트 집합을 $$M=\{m_1, m_2, \dots\}$$ 라 하면,
$$
m^* = \arg\max_{m\in M} \; \text{len}(m) \quad \text{s.t. } m \text{ is a prefix of } p
$$
그 후 남은 suffix에 대해 해당 파일시스템의 **경로 해석**이 이어진다. 오버레이/바인드의 경우 **번역 규칙**이 추가된다.

---

### 15.3.6 Windows/macOS 비고
- **Windows**: 전통적 드라이브 문자(C:, D:…), **mountvol** 로 **디렉터리 마운트** 가능(NTFS reparse points).
- **macOS(APFS)**: 컨테이너 내 **볼륨**(스냅샷/클론 쉬움), `diskutil apfs addVolume`/`mount_apfs`.

---

### 15.3.7 컨테이너 루트FS 구성(실전 흐름)
1) 이미지 레이어(여러 tar/시퀀스) → **lowerdirs**
2) 컨테이너별 **upperdir + workdir**
3) `mount -t overlay` 로 **merged** 생성
4) 네임스페이스/`pivot_root` 후 PID 1 실행

```bash
lower="l1:l2:l3"; upper="u1"; work="w1"
mkdir -p mrg
mount -t overlay overlay -o lowerdir=$lower,upperdir=$upper,workdir=$work mrg
```

---

### 15.3.8 트러블슈팅 & 베스트 프랙티스
- 마운트 실패: `dmesg`/`journalctl -k` 에 FS-specific 오류 로그 확인(슈퍼블록 손상/옵션 불일치).
- 성능 튜닝: 워크로드에 맞춰 `noatime/relatime`, 저널 `commit=`, XFS logbufs, Btrfs `compress=zstd:3`, ZFS recordsize 조정.
- 신뢰성: `fsck` 주기/스크럽, RAID 모니터, 정전 대비 UPS, **`errors=remount-ro`**.
- 보안: `nodev,nosuid,noexec`(특히 /tmp 계열), 루프 이미지/네임스페이스 축소, FUSE 마운트 제한.

---

## 실습 모음(작게·정확하게)

### (1) mount 네임스페이스에서 격리 마운트 트리 만들기
```bash
unshare -m bash -c '
  mount --make-rprivate /
  mkdir -p /tmp/{root,a,b}
  mount -t tmpfs tmpfs /tmp/root
  mount -t tmpfs tmpfs /tmp/a
  mount --bind /tmp/a /tmp/b
  mount | grep /tmp
'
```

### (2) C에서 `mount(2)`/`umount2(2)` 호출
```c
// mount_tmpfs.c
#define _GNU_SOURCE
#include <sys/mount.h>
#include <stdio.h>
#include <unistd.h>
int main(){
  if (mount("tmpfs", "/mnt", "tmpfs", 0, "size=64M,mode=755")<0){ perror("mount"); return 1; }
  puts("mounted tmpfs 64M at /mnt");
  if (umount2("/mnt", MNT_DETACH)<0){ perror("umount2"); return 1; }
  puts("unmounted");
}
```

### (3) 이미지 내부 파티션을 개별적으로 마운트
```bash
dd if=/dev/zero of=d.img bs=1M count=512
parted -s d.img mklabel gpt mkpart p1 ext4 1MiB 100MiB mkpart p2 ext4 100MiB 100%
sudo losetup -Pf d.img
L=$(losetup -j d.img | cut -d: -f1)
sudo mkfs.ext4 -F ${L}p1
sudo mkfs.ext4 -F ${L}p2
sudo mount ${L}p1 /mnt/p1
sudo mount ${L}p2 /mnt/p2
```

### (4) 오버레이로 읽기 전용 트리 위에 쓰기 층 덧씌우기
```bash
mkdir -p lower upper work merged
cp /etc/hostname lower/
mount -t overlay overlay -o lowerdir=lower,upperdir=upper,workdir=work merged
echo "X" > merged/hostname     # upper에만 기록
```

---

## 체크리스트(요약)

- **15.1 File Systems**: VFS 객체(superblock/inode/dentry/file)와 연산 테이블을 이해하면 **모든 FS**를 같은 사고모델로 볼 수 있다. 경로 해석은 **dentry 캐시**와 **디렉터리 인덱스**가 핵심.
- **15.2 Mounting**: 마운트는 **슈퍼블록 인스턴스**를 트리에 결합하는 작업. 네임스페이스/전파/바인드/오버레이/루프/자동마운트/옵션을 체계적으로 다룰 줄 알아야 한다.
- **15.3 Partitions & Mounting**: MBR↔GPT 구조, LVM/RAID/암호화 스택과 상호작용, **최장 접두 규칙**과 fstab/systemd 통합을 숙지하면 **부팅~운영~컨테이너**까지 일관되게 설계/운영할 수 있다.
