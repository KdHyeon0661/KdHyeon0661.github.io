---
layout: post
title: JavaScript - 타이머 / 스톱워치 만들기
date: 2025-05-18 21:20:23 +0900
category: JavaScript
---
# ⏱자바스크립트로 타이머 / 스톱워치 만들기

## 기본 HTML/CSS

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>타이머 & 스톱워치</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="./style.css" />
</head>
<body>
  <main class="wrap">
    <section class="panel">
      <h1>스톱워치</h1>
      <div class="display" id="sw-display" aria-live="polite" aria-atomic="true">00:00:00.000</div>
      <div class="controls">
        <button id="sw-start" aria-pressed="false">시작</button>
        <button id="sw-pause" disabled>일시정지</button>
        <button id="sw-reset" disabled>초기화</button>
        <button id="sw-lap" disabled>랩</button>
      </div>
      <ul id="sw-laps" class="laps" aria-label="랩 목록"></ul>
    </section>

    <section class="panel">
      <h1>타이머(카운트다운)</h1>
      <div class="timer-inputs">
        <label>분 <input id="tm-min" type="number" min="0" step="1" value="1" inputmode="numeric" /></label>
        <label>초 <input id="tm-sec" type="number" min="0" max="59" step="1" value="0" inputmode="numeric" /></label>
      </div>
      <div class="display" id="tm-display" aria-live="polite" aria-atomic="true">00:01:00.000</div>
      <div class="controls">
        <button id="tm-start">시작</button>
        <button id="tm-pause" disabled>일시정지</button>
        <button id="tm-reset" disabled>초기화</button>
      </div>
      <label class="opt">
        <input id="tm-loop" type="checkbox" />
        종료 시 자동 반복
      </label>
      <audio id="ding" preload="auto">
        <source src="data:audio/mp3;base64,//uQZAAAA..." type="audio/mp3"/>
      </audio>
    </section>
  </main>
  <script src="./app.js" defer></script>
</body>
</html>
```

```css
/* style.css */
* { box-sizing: border-box; }
body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 24px; background: #fafafa; color: #222; }
.wrap { max-width: 920px; margin: 0 auto; display: grid; gap: 24px; grid-template-columns: 1fr; }
@media (min-width: 900px) { .wrap { grid-template-columns: 1fr 1fr; } }
.panel { background: #fff; border: 1px solid #eee; border-radius: 12px; padding: 20px; box-shadow: 0 4px 12px rgba(0,0,0,.06); }
h1 { margin: 0 0 12px; font-size: 1.25rem; }
.display { font-variant-numeric: tabular-nums; font-weight: 700; font-size: 2rem; letter-spacing: .5px; padding: 16px 12px; background: #111; color: #0ff; border-radius: 8px; text-align: center; }
.controls { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
button { padding: 10px 14px; border-radius: 8px; border: 1px solid #ccc; background: #f4f4f4; cursor: pointer; }
button:disabled { opacity: .5; cursor: not-allowed; }
.timer-inputs { display: flex; gap: 12px; align-items: center; margin-bottom: 8px; }
.timer-inputs input { width: 5em; padding: 8px; }
.laps { margin: 12px 0 0; padding: 0 0 0 18px; max-height: 280px; overflow: auto; }
.opt { display: inline-flex; align-items: center; gap: 8px; margin-top: 8px; }
@media (prefers-color-scheme: dark) {
  body { background: #0b0d10; color: #dfe6ef; }
  .panel { background: #12161a; border-color: #222; box-shadow: none; }
  .display { background: #040607; color: #2ee9e9; }
  button { background: #1a2026; color: #dfe6ef; border-color: #333; }
}
```

---

## 스톱워치 — `setInterval` 기초 구현

**기본 아이디어**: 시작 시점을 저장하고, 주기적으로 현재 시간과의 차이를 계산해 화면에 반영합니다.

```js
// app.js (1/4): 스톱워치 기초
const $ = (sel) => document.querySelector(sel);

// Elements
const swDisplay = $("#sw-display");
const swStart = $("#sw-start");
const swPause = $("#sw-pause");
const swReset = $("#sw-reset");
const swLap = $("#sw-lap");
const swLaps = $("#sw-laps");

let swInterval = null;
let swRunning = false;
let swStartEpoch = 0;     // 시작 시점 (ms, epoch)
let swElapsedMs = 0;      // 누적 경과(ms)

// 포맷터
function formatHMSms(ms) {
  const t = Math.max(0, Math.floor(ms));
  const h = Math.floor(t / 3600000);
  const m = Math.floor((t % 3600000) / 60000);
  const s = Math.floor((t % 60000) / 1000);
  const ms3 = String(t % 1000).padStart(3, "0");
  return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}.${ms3}`;
}

// 화면 반영
function renderStopwatch() {
  const now = Date.now();
  const current = swRunning ? (now - swStartEpoch) + swElapsedMs : swElapsedMs;
  swDisplay.textContent = formatHMSms(current);
}

// 컨트롤
swStart.addEventListener("click", () => {
  if (swRunning) return;
  swRunning = true;
  swStartEpoch = Date.now();
  swInterval = setInterval(renderStopwatch, 50); // 20fps 정도로 충분
  swStart.setAttribute("aria-pressed", "true");
  swPause.disabled = false; swReset.disabled = false; swLap.disabled = false;
});

swPause.addEventListener("click", () => {
  if (!swRunning) return;
  swRunning = false;
  clearInterval(swInterval);
  swElapsedMs += Date.now() - swStartEpoch;
  renderStopwatch();
  swStart.setAttribute("aria-pressed", "false");
});

swReset.addEventListener("click", () => {
  swRunning = false;
  clearInterval(swInterval);
  swElapsedMs = 0;
  swDisplay.textContent = "00:00:00.000";
  swPause.disabled = true; swReset.disabled = true; swLap.disabled = true;
  swLaps.innerHTML = "";
});

swLap.addEventListener("click", () => {
  const li = document.createElement("li");
  const now = swRunning ? (Date.now() - swStartEpoch) + swElapsedMs : swElapsedMs;
  li.textContent = formatHMSms(now);
  swLaps.prepend(li);
});
```

> 이 방식은 쉬우나, 탭 비활성화/브라우저 간격 조정으로 **드리프트(누적 오차)**가 생길 수 있습니다.

---

## 스톱워치 — 드리프트 없는 고정밀 구현

**원리**: 실제 시간을 기준으로 **“목표 프레임 시각”**을 계산해 보정합니다. 타이머는 UI 업데이트 빈도만 조절하고, **경과 시간은 항상 시작/일시정지 시점의 차이**로 계산합니다.

- 목표 시각: $$t_n = t_0 + n \cdot \Delta$$
  여기서 \( \Delta \) 는 업데이트 간격(예: 50ms)
- 실제 시각 \( t_\text{now} \) 가 늦게 도착해도, 경과 시간은 **`Date.now()`/`performance.now()` 차**로 계산하므로 드리프트가 누적되지 않습니다.

```js
// app.js (2/4): 스톱워치 - 드리프트 보정 rAF
let swRafId = 0;
let swTickHz = 20;           // 20fps 업데이트
let swDelta = 1000 / swTickHz;
let swFrameIdx = 0;

function swLoop() {
  if (!swRunning) return;
  const now = performance.now();
  // 렌더링은 경과 시간 공식으로 계산
  renderStopwatch();

  swFrameIdx += 1;
  const target = swStartPerf + swFrameIdx * swDelta; // 목표 프레임 시간
  const delay = Math.max(0, target - now);

  swRafId = window.setTimeout(swLoop, delay); // rAF도 가능: requestAnimationFrame(swLoop)
}

let swStartPerf = 0;

swStart.addEventListener("click", () => {
  if (swRunning) return;
  swRunning = true;
  swStartEpoch = Date.now();
  swStartPerf  = performance.now();
  swFrameIdx   = 0;
  swLoop();
});

swPause.addEventListener("click", () => {
  if (!swRunning) return;
  swRunning = false;
  clearTimeout(swRafId);
  swElapsedMs += Date.now() - swStartEpoch;
  renderStopwatch();
});
```

> 핵심은 **경과 시간은 실제 시간 차이로만 결정**하고, UI 업데이트 타이밍은 보정된 루프로 **사용자 체감**만 부드럽게 만든다는 점입니다.

---

## 타이머(카운트다운) — 정확한 종료를 위한 보정

**문제**: `setInterval(1000)`에만 의존하면 탭 비활성/부하 시 초가 “밀릴” 수 있습니다.
**해법**: **목표 종료 시각** `deadline = now + duration`을 저장하고, 매 틱마다 `remain = deadline - now`로 계산합니다.

$$ \text{remaining}(t) = \max(0, \text{deadline} - t) $$

```js
// app.js (3/4): 카운트다운 타이머 (정확도 보정)
const tmDisplay = $("#tm-display");
const tmStart = $("#tm-start");
const tmPause = $("#tm-pause");
const tmReset = $("#tm-reset");
const tmMin = $("#tm-min");
const tmSec = $("#tm-sec");
const tmLoop = $("#tm-loop");
const ding = $("#ding");

let tmRunning = false;
let tmDeadline = 0;  // epoch ms
let tmRemain = 0;    // 남은 ms(일시정지 시 저장)
let tmTicker = 0;

function formatMS(ms) {
  const t = Math.max(0, Math.floor(ms));
  const m = Math.floor(t / 60000);
  const s = Math.floor((t % 60000) / 1000);
  const ms3 = String(t % 1000).padStart(3, "0");
  return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}.${ms3}`;
}
function setTM(ms) { tmDisplay.textContent = formatMS(ms); }

function tmUpdate() {
  const now = Date.now();
  const remain = Math.max(0, tmDeadline - now);
  setTM(remain);
  if (remain <= 0) {
    clearInterval(tmTicker);
    tmRunning = false;
    tmPause.disabled = true; tmReset.disabled = false;
    notifyTimerEnd();
    if (tmLoop.checked) {
      // 자동 반복: 동일 시간으로 재시작
      startTimerFromInputs();
    }
  }
}

function startTimerFromInputs() {
  const mins = Math.max(0, Number(tmMin.value) || 0);
  const secs = Math.max(0, Number(tmSec.value) || 0);
  const dur = (mins * 60 + secs) * 1000;
  if (dur <= 0) return;
  tmRunning = true;
  tmDeadline = Date.now() + dur;
  clearInterval(tmTicker);
  tmTicker = setInterval(tmUpdate, 50); // 20fps
  tmUpdate();
  tmPause.disabled = false; tmReset.disabled = false;
}

tmStart.addEventListener("click", () => {
  if (tmRunning) return;
  if (tmRemain > 0) {
    // 일시정지 후 재개
    tmRunning = true;
    tmDeadline = Date.now() + tmRemain;
    tmTicker = setInterval(tmUpdate, 50);
  } else {
    startTimerFromInputs();
  }
});

tmPause.addEventListener("click", () => {
  if (!tmRunning) return;
  tmRunning = false;
  clearInterval(tmTicker);
  tmRemain = Math.max(0, tmDeadline - Date.now());
});

tmReset.addEventListener("click", () => {
  tmRunning = false; clearInterval(tmTicker);
  tmRemain = 0; setTM(0);
  tmPause.disabled = true; tmReset.disabled = true;
});

function notifyTimerEnd() {
  try { ding.currentTime = 0; ding.play().catch(()=>{}); } catch(e) {}
  if (Notification && Notification.permission === "granted") {
    new Notification("타이머 종료", { body: "설정한 시간이 완료되었습니다." });
  }
}
```

> 이 방식은 **종료 정확도**가 매우 높습니다. UI 업데이트는 50ms 단위지만 **실제 종료는 `deadline` 비교로 정확**합니다.

---

## 공통 유틸: 시간 포맷 & 패딩

위에서 사용한 `formatHMSms`, `formatMS`는 **탭 간격 숫자 폰트**와 함께 읽기 품질을 높여줍니다.
(이미 CSS의 `.display`에서 `font-variant-numeric: tabular-nums;` 적용)

---

## 확장 기능

### (1) 랩(Lap) 분리/구간시간

```js
// 이전 랩 시점과의 차이도 기록
let lastLapMs = 0;
swLap.addEventListener("click", () => {
  const now = swRunning ? (Date.now() - swStartEpoch) + swElapsedMs : swElapsedMs;
  const split = now - lastLapMs;
  lastLapMs = now;

  const li = document.createElement("li");
  li.textContent = `랩 ${swLaps.childElementCount + 1} — ${formatHMSms(now)} (+${formatHMSms(split)})`;
  swLaps.prepend(li);
});
```

### (2) 키보드 단축키 (Space: 시작/일시정지, R: 리셋)

```js
document.addEventListener("keydown", (e) => {
  if (e.target && /input|textarea/i.test(e.target.tagName)) return;
  if (e.code === "Space") {
    e.preventDefault();
    if (!swRunning) swStart.click(); else swPause.click();
  } else if (e.key.toLowerCase() === "r") {
    swReset.click();
  } else if (e.key.toLowerCase() === "l") {
    swLap.click();
  }
});
```

### (3) 다크모드 토글은 CSS의 `prefers-color-scheme`과 함께 추가 버튼으로 제어 가능

---

## 알림: 사운드 + 브라우저 Notification

```js
// 최초 사용자 제스처에서 권한 요청
if ("Notification" in window && Notification.permission === "default") {
  document.addEventListener("click", () => {
    Notification.requestPermission().catch(()=>{});
  }, { once: true });
}
```

- 사운드는 `<audio>`로 처리. 이동통신/브라우저 정책상 **사용자 상호작용 후** 재생 허용.

---

## 백그라운드/비가시 상태 — 정확도 유지

- 탭이 비활성화되면 `setInterval`은 **최소 1s**까지 간격이 늘어날 수 있습니다(브라우저 최적화).
- 우리는 이미 `deadline`/`startEpoch` 기반으로 **실제 시간 차**를 쓰므로, 화면 업데이트만 늦어질 뿐 **논리상 시간은 정확**합니다.

```js
document.addEventListener("visibilitychange", () => {
  // 필요 시 화면 복귀 순간 한 번 강제 업데이트
  if (document.visibilityState === "visible") {
    renderStopwatch();
    if (tmRunning) tmUpdate();
  }
});
```

---

## 정확도 심화: rAF 루프, 보정 수식, Web Worker

### (1) rAF 루프

UI 업데이트만 `requestAnimationFrame`으로 호출하고, **시간 계산은 항상 `Date.now()`/`performance.now()`**로:

```js
let rafId;
function animate() {
  if (swRunning) swDisplay.textContent = formatHMSms((Date.now() - swStartEpoch) + swElapsedMs);
  rafId = requestAnimationFrame(animate);
}
animate(); // 상시 루프 — 필요 시 가시 상태에서만 돌리도록 최적화
```

### (2) 수학적 보정

우리가 쓰는 보정은 다음 원리:
- **측정값**: \( t_\text{now} \)
- **경과**: \( E(t) = t_\text{now} - t_\text{start} + E_\text{paused} \)
- **카운트다운**: \( R(t) = \max(0, t_\text{deadline} - t_\text{now}) \)

이 수식은 타이머 드리프트를 제거합니다.
(업데이트 빈도는 UX 문제일 뿐, 수학적으로는 **실시간 의존**)

### (3) Web Worker 타이머 (고부하 페이지)

메인 스레드가 바쁠 때 **워커에서 틱**을 보내면 안정적입니다.

**main.js**
```js
const worker = new Worker("./ticker.worker.js");
worker.onmessage = () => { if (tmRunning) tmUpdate(); };
```

**ticker.worker.js**
```js
let id = 0;
function tick() { postMessage({}); id = setTimeout(tick, 50); }
tick(); // 단순 틱 송신
```

> 워커도 완벽하진 않지만, 메인 스레드보다 지연 변동이 작을 수 있습니다.

---

## 접근성(ARIA) & 국제화

- **라이브 영역**: `.display`에 `aria-live="polite" aria-atomic="true"` → 스크린리더가 적절히 읽음
- **버튼 상태**: `aria-pressed` 또는 `disabled` 반영
- **초 단위 읽기 빈도** 조정: 너무 잦은 업데이트는 스크린리더에 방해 → 250~1000ms 간격 권장
- 국제화(i18n): 포맷 `mm:ss.mmm`는 문화권 무관하게 통용되지만, **레이블/알림 메시지**는 리소스 분리 권장

---

## 테스트 포인트 & 체크리스트

**기능**
- 시작/일시정지/초기화 동작
- 랩 기록 순서/형식
- 타이머 종료 시 정확하게 0에서 멈춤 + 알림/사운드

**정확도**
- 5분 타이머 설정 후 모바일 화면 끔/다른 탭 → 복귀 시 오차 < 수십 ms
- PC 고부하(DevTools CPU Throttle)에서 종료 정확성

**UX**
- 키보드 단축키/포커스 이동
- 모바일 가상 키보드로 입력 변경

**접근성**
- 버튼 `disabled`/`aria-pressed` 상태 동기화
- 화면 리더에서 읽기 과도하지 않은지

**성능**
- rAF/Interval 빈도 적절(50~200ms)
- 메모리 누수(리스너 해제) 없음

---

## 모듈화: 클래스로 분리 (재사용/테스트 용이)

```js
// time-utils.js
export const now = () => Date.now();
export const pnow = () => performance.now();
export function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }
export function fmtHMSms(ms){
  const t = Math.max(0, Math.floor(ms));
  const h = Math.floor(t / 3600000);
  const m = Math.floor((t % 3600000) / 60000);
  const s = Math.floor((t % 60000) / 1000);
  const ms3 = String(t % 1000).padStart(3,"0");
  return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}.${ms3}`;
}
export function fmtMS(ms){
  const t = Math.max(0, Math.floor(ms));
  const m = Math.floor(t / 60000);
  const s = Math.floor((t % 60000) / 1000);
  const ms3 = String(t % 1000).padStart(3,"0");
  return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}.${ms3}`;
}
```

```js
// Stopwatch.js
import { now, fmtHMSms } from "./time-utils.js";

export class Stopwatch {
  #running = false;
  #startEpoch = 0;
  #elapsed = 0;
  onTick = (ms)=>{}; // 외부에 경과 전달 (옵션)
  tickMs = 50;
  #timer = 0;

  start(){
    if (this.#running) return;
    this.#running = true;
    this.#startEpoch = now();
    this.#timer = setInterval(()=>this.#tick(), this.tickMs);
  }
  pause(){
    if (!this.#running) return;
    this.#running = false;
    clearInterval(this.#timer);
    this.#elapsed += now() - this.#startEpoch;
    this.onTick(this.#elapsed);
  }
  reset(){
    this.#running = false;
    clearInterval(this.#timer);
    this.#elapsed = 0;
    this.onTick(0);
  }
  #tick(){
    if (!this.#running) return;
    const ms = (now() - this.#startEpoch) + this.#elapsed;
    this.onTick(ms);
  }
  get elapsed(){ return this.#running ? (now() - this.#startEpoch) + this.#elapsed : this.#elapsed; }
  get formatted(){ return fmtHMSms(this.elapsed); }
}
```

```js
// CountdownTimer.js
import { now, fmtMS } from "./time-utils.js";

export class CountdownTimer {
  #running = false;
  #deadline = 0;
  #remain = 0;
  onTick = (remain)=>{};
  onEnd = ()=>{};
  tickMs = 50;
  #timer = 0;

  start(durationMs){
    if (this.#running) return;
    if (durationMs != null) this.#remain = durationMs;
    if ((this.#remain|0) <= 0) return;
    this.#running = true;
    this.#deadline = now() + this.#remain;
    clearInterval(this.#timer);
    this.#timer = setInterval(()=>this.#tick(), this.tickMs);
    this.#tick();
  }
  pause(){
    if (!this.#running) return;
    this.#running = false;
    clearInterval(this.#timer);
    this.#remain = Math.max(0, this.#deadline - now());
    this.onTick(this.#remain);
  }
  reset(){
    this.#running = false;
    clearInterval(this.#timer);
    this.#remain = 0;
    this.onTick(0);
  }
  #tick(){
    const r = Math.max(0, this.#deadline - now());
    this.onTick(r);
    if (r <= 0) {
      clearInterval(this.#timer);
      this.#running = false;
      this.onEnd();
    }
  }
  get remaining(){ return this.#running ? Math.max(0, this.#deadline - now()) : this.#remain; }
  get formatted(){ return fmtMS(this.remaining); }
}
```

```js
// main.js (모듈 페이지에서 사용)
import { Stopwatch } from "./Stopwatch.js";
import { CountdownTimer } from "./CountdownTimer.js";

const sw = new Stopwatch();
sw.onTick = (ms)=> document.getElementById("sw-display").textContent = sw.formatted;

const tm = new CountdownTimer();
tm.onTick = (r)=> document.getElementById("tm-display").textContent = tm.formatted;
tm.onEnd  = ()=> alert("타이머 종료!");

document.getElementById("sw-start").onclick = ()=> sw.start();
document.getElementById("sw-pause").onclick = ()=> sw.pause();
document.getElementById("sw-reset").onclick = ()=> sw.reset();

document.getElementById("tm-start").onclick = ()=>{
  const m = Number(document.getElementById("tm-min").value)||0;
  const s = Number(document.getElementById("tm-sec").value)||0;
  tm.start((m*60+s)*1000);
};
document.getElementById("tm-pause").onclick = ()=> tm.pause();
document.getElementById("tm-reset").onclick = ()=> tm.reset();
```

---

## 결론

- **스톱워치**는 `startEpoch`/`elapsed`로 경과를 계산하고, UI는 일정 주기로만 갱신해 **드리프트 없이 정확**하게 만들 수 있습니다.
- **타이머**는 `deadline = now + duration`을 두고 매 틱마다 `deadline - now`로 남은 시간을 산출하여 **종료 시점 정확도**를 보장합니다.
- 고급 단계로 **rAF 루프**, **Web Worker**, **알림/사운드**, **접근성**, **테스트**까지 적용하면 실전 서비스 수준의 타이머/스톱워치를 완성할 수 있습니다.
