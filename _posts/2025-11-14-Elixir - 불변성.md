---
layout: post
title: Elixir - 불변성
date: 2025-11-14 16:25:23 +0900
category: Elixir
---
# 엘릭서 3장: 불변(Immutable) 데이터 — 개념, 성능, 실전 패턴

> 이 장의 목표  
> - `x = x + 1` 이 “값을 바꾸는 것”이 아니라, **새 값을 만들고 이름을 다시 바인딩**하는 것임을 확실히 이해한다.  
> - 리스트/맵/바이너리 같은 컬렉션이 **불변인데도 왜 빠르게 동작하는지**(구조적 공유, iodata, 오프힙 바이너리)를 감각적으로 이해한다.  
> - 불변 데이터 위에서 **파이프라인, 동시성, 로그, 캐시, 테스트**를 어떻게 설계하면 좋은지 실전 예제로 익힌다.

---

## _3.1 우리는 이미 불변 데이터를 알고 있다

엘릭서에서의 출발점은 단 하나다.

> **값은 한 번 만들어지면 바뀌지 않는다.**  
> 변수에 “새 값을 할당”하는 것이 아니라 **새 값을 만들고, 그 값에 이름을 다시 붙인다.**

이 개념은 이미 우리가 쓰고 있는 **문자열, 숫자, 리스트, 맵** 전반에 스며있다.  
특별한 철학이 아니라, 언어의 “공기”라고 보면 된다.

### 3.1.1 변수는 “상자”가 아니라 “라벨(label)”이다

C/Java 같은 언어에서는 변수를 **값을 담는 상자**로 생각한다.

```c
int x = 10;
x = x + 1;   // 상자 x 안의 값이 10 -> 11 로 "변경"
```

엘릭서에서는 이 그림이 완전히 다르다. 변수를 “라벨”로 보는 편이 더 정확하다.

```elixir
iex> x = 10      # x 라는 '라벨'을 10이라는 값에 붙인다
10
iex> x = x + 1   # 기존 10을 바꾸지 않고, 11이라는 '새 값'에 x를 다시 붙인다
11
iex> x
11
```

머릿속 모델을 바꿔보자.

- **값**: 메모리 어딘가에 놓여 있는 “변하지 않는 물건”
- **변수(이름)**: 이 물건에 붙어 있는 **포스트잇(라벨)**

`x = x + 1` 이라는 식은:

1. 기존 `x` 라벨이 가리키고 있던 값(10)을 읽고,
2. **새 값 11**을 만든 다음,
3. `x` 라벨을 **10에서 떼어내서 11에 붙이는 것**이다.

10이라는 값은 여전히 어딘가에 남아 있지만, 더 이상 `x` 라는 이름으로 가리키지 않을 뿐이다.

#### 다른 언어와 비교 (Python, JavaScript)

Python/JS 에서도 숫자/문자열은 사실상 불변이라 비슷하게 동작한다.

```python
x = 10
y = x
x = x + 1
# y 는 여전히 10
```

엘릭서에서는 **언어 전체의 기본 규칙이 이 모델**이라 생각하면 된다.  
차이는, 엘릭서는 **변수에 다시 값을 붙여도 내부 값을 “수정”하는 API 자체가 거의 없다**는 것.

### 3.1.2 컬렉션의 불변: “수정”은 전체 복사가 아니다

“값이 불변”이라고 하면 대부분 바로 떠올리는 걱정이 있다.

> 그럼 리스트나 맵 좀 바꿀 때마다 **매번 전체 복사**하는 거 아니야? 너무 느릴 것 같은데?

실제로는 그렇지 않다. 엘릭서(Collection)는 **영속(persistent) 자료구조**를 사용한다.  
핵심 아이디어는 한 줄로 요약된다.

> **바뀐 경로만 새로 만들고, 나머지는 공유한다 (Structural Sharing).**

예제를 보자.

```elixir
iex> m1 = %{user: %{name: "Kim", points: 10}}
%{user: %{name: "Kim", points: 10}}

iex> m2 = put_in(m1, [:user, :points], 11)
%{user: %{name: "Kim", points: 11}}

iex> m1.user.points
10
iex> m2.user.points
11
```

논리적으로 보면:

- `m1` 과 `m2` 는 **서로 다른 맵**이다.
- 하지만 실제 메모리에서는, 둘 다 `(user -> %{name: "Kim", ...})` 같은 **공통 부분을 공유**한다.
- `points` 필드가 있는 **작은 조각만 새로 만들어서 연결**하는 구조라고 생각하면 된다.

대략적인 그림:

```text
m1 ──► user ──► name:"Kim"
         │
         └──► points:10

m2 ──► user'──► name:"Kim"   (여기는 공유)
          │
          └─► points:11      (여기만 새로 생성)
```

중요한 포인트:

- 논리적인 의미상 “원본은 절대 바뀌지 않는다.”
- 하지만 구현은 **공유 가능한 부분은 최대한 공유**해서, 매번 전체 복사하는 일을 피한다.

이 덕분에,

- “불변 = 무조건 느림”이 아니라,  
- “**불변 + 적절한 자료구조 = 생각보다 꽤 빠름**”이 된다.

### 3.1.3 리스트의 전형적 패턴: **앞에 붙이기(Prepend)**

엘릭서 리스트는 **단방향 연결 리스트** 구조다. 그래서:

- **앞에 하나 붙이는 것**은 머리 노드 하나만 새로 만들면 되므로 **O(1)**,
- **뒤에 붙이는 것**은 전체를 따라가서 끝을 찾아야 하므로 **O(n)**이다.

```elixir
iex> list = [2, 3]
[2, 3]

iex> new = [1 | list]    # 머리 하나만 새로 만든다
[1, 2, 3]

iex> list
[2, 3]
```

내부적으로는 대략 이런 느낌이다.

```text
list:  ──► [2] ──► [3] ──► []

new:   ──► [1] ──► [2] ──► [3] ──► []
               ▲
               └─── 기존 list 의 머리
```

- `list` 는 그대로 두고,
- `[1 | list]` 는 “새 노드 1 하나 + 기존 리스트” 를 연결한 것.

반대로, 자주 하는 실수는 이렇게 짜는 것이다.

```elixir
Enum.reduce(1..n, [], fn x, acc -> acc ++ [x] end)
# 각 단계마다 리스트 전체를 한 번씩 복사한다 → O(n^2)
```

올바른 패턴은 다음과 같다.

```elixir
1..n
|> Enum.reduce([], fn x, acc -> [x | acc] end)
|> :lists.reverse()
```

> “**앞에 붙이고 나중에 한 번 뒤집는다**”는 패턴은 엘릭서에서 아주 흔한 관용구다.

### 3.1.4 실수 사례: “제자리 수정”을 상상하면서 짜는 코드

경험 많은 OOP 개발자도 초반에 이런 코드를 종종 짠다.

```elixir
def bump_score(state, user) do
  Map.update!(state, user, &(&1 + 1))
  state   # "state 가 안 바뀌었는데?" 라고 당황
end
```

- `Map.update!/3` 는 **새 맵을 반환**하고, 원래 맵은 변경하지 않는다.
- 그런데 반환 값을 무시하고 `state` 그대로 돌려버리면, 호출하는 쪽에서는 **아무 일도 안 일어난 것처럼 보인다.**

정답은 이렇다.

```elixir
def bump_score(state, user) do
  Map.update!(state, user, &(&1 + 1))
end

# 또는
def bump_score(state, user) do
  new_state = Map.update!(state, user, &(&1 + 1))
  new_state
end
```

요약하면:

- “**항상 새 값을 돌려준다**”는 패턴을 몸에 익히고,
- “함수 호출 = 상태를 바꾼다”가 아니라 **“함수 호출 = 새 상태를 만든다”**로 생각해야 한다.

---

## _3.2 불변 데이터는 확실한 데이터다

불변 데이터의 가장 큰 장점은 **예측 가능성**이다.

- 상태를 공유하지 않으니, **동일한 입력 → 동일한 출력**을 만들기가 훨씬 쉽다.
- 함수의 의도와 효과가 드러나고, 테스트·리뷰·리팩터링이 모두 단순해진다.

### 3.2.1 참조 투명성에 가까운 스타일

엘릭서는 “완전한 순수 함수형 언어”는 아니다. 하지만:

- **불변 데이터**를 기본으로 하고,
- 부수효과를 한정된 경계(입출력, 프로세스 메시지, DB 등)에만 두고,
- 나머지는 **“입력 → 출력” 변환 함수**로 짜면,

실질적으로는 **참조 투명성에 가까운 스타일**을 쉽게 유지할 수 있다.

```elixir
defmodule Points do
  # 순수 변환: 입력 맵 -> 출력 맵 (원본 보존)
  def add(points_map, user, delta) when is_integer(delta) do
    Map.update(points_map, user, delta, &(&1 + delta))
  end
end

iex> p1 = %{"kim" => 10}
%{"kim" => 10}

iex> p2 = Points.add(p1, "kim", 5)
%{"kim" => 15}

iex> p1
%{"kim" => 10}
```

이 패턴의 장점:

1. **테스트**  
   - 입력과 출력만 보면 된다.  
   - “내부에서 뭔가 다른 상태를 바꿨을지도 모른다”는 걱정이 없다.

2. **리팩터링**  
   - 내부 구현을 바꿔도, 외부 계약(입력/출력 형태)이 유지되면 대부분의 코드는 그대로 동작한다.

3. **캐싱/메모이제이션**  
   - **동일 입력 → 동일 결과**라는 가정이 깨지지 않으니, 손쉽게 캐싱할 수 있다.

```elixir
def cached_add(cache, key, fun) do
  case Map.fetch(cache, key) do
    {:ok, value} -> {cache, value}
    :error ->
      value = fun.()
      {Map.put(cache, key, value), value}
  end
end
```

### 3.2.2 동시성에서의 확실성: 힙 격리 + 메시지 패싱

BEAM(엘릭서가 올라가는 VM)의 핵심 아이디어 중 하나는:

> **각 프로세스가 자신의 힙을 갖고, 메모리를 공유하지 않는다.**  
> 프로세스 간에는 **오직 메시지**로만 통신한다.

그래서 다음과 같은 일이 일어나지 않는다.

- 프로세스 A 가 어떤 맵을 수정하면서,
- 동시에 프로세스 B 도 같은 맵을 수정해서,
- “둘 중 누가 나중에 썼는지에 따라 결과가 달라지는” 레이스 컨디션.

엘릭서에서는 그런 일이 **물리적으로 불가능**하다.

간단한 예를 보자.

```elixir
defmodule Counter do
  def start(initial \\ %{cnt: 0}) do
    spawn(fn -> loop(initial) end)
  end

  defp loop(state) do
    receive do
      {:inc, from} ->
        new = Map.update(state, :cnt, 1, &(&1 + 1))
        send(from, {:ok, new})
        loop(new)

      {:get, from} ->
        send(from, {:ok, state})
        loop(state)
    end
  end
end
```

사용 예:

```elixir
iex> pid = Counter.start(%{cnt: 0})
#PID<0.123.0>

iex> send(pid, {:inc, self()})
{:inc, #PID<0.114.0>}
iex> receive do {:ok, st} -> st end
%{cnt: 1}

iex> send(pid, {:get, self()})
{:get, #PID<0.114.0>}
iex> receive do {:ok, st} -> st end
%{cnt: 1}
```

중요한 점:

- 메시지로 넘긴 `state` 는 **복사된 값**이다.
- 프로세스 안에서 `new` 를 만들고, `loop(new)` 를 호출한다.
- 외부 프로세스는 내부 상태를 **직접 수정할 방법이 없다**.

즉, “불변 + 프로세스별 힙 격리 + 메시지 패싱” 덕분에:

- 레이스 컨디션의 상당수가 **구조적으로 제거**되고,
- 동시성 코드를 이해하고 디버깅하는 비용이 크게 줄어든다.

### 3.2.3 디버깅 & 롤백이 쉬워진다

불변 상태 위에서 변환을 연쇄하면, 전체를 **시점별 스냅샷** 집합처럼 다룰 수 있다.

```elixir
def pipeline(input) do
  s1 = validate(input)
  s2 = transform(s1)
  s3 = enrich(s2)
  s3
end
```

디버깅할 때:

- `s1`, `s2`, `s3` 를 각각 로그로 찍어보면 어디서 틀어졌는지 바로 보인다.
- 동시에 다른 곳에서 같은 값을 “살짝 고쳐버린” 일이 없으니, 재현이 쉽다.

조금 더 구체적으로:

```elixir
def pipeline(input) do
  s1 = tap(:after_validate, validate(input))
  s2 = tap(:after_transform, transform(s1))
  s3 = tap(:after_enrich, enrich(s2))
  s3
end

defp tap(stage, value) do
  IO.inspect(value, label: stage)
  value
end
```

- 어디서든 `tap/2` 를 추가해도, **원본 값이 바뀌지 않으므로 부작용이 없다.**

### 3.2.4 다른 언어의 동시성 버그와 비교

공유 가변 상태에서 흔히 일어나는 버그를 간단히 의사 코드로 써 보자.

```pseudo
# 공유 변수
balance = 0

# 쓰레드 A
balance = balance + 10

# 쓰레드 B
balance = balance + 20
```

이론적으로는 30이 되어야 한다. 하지만 실제 실행 순서가:

1. A 가 balance를 읽어 0을 얻음
2. B 가 balance를 읽어 0을 얻음
3. A 가 10을 저장
4. B 가 20을 저장

이런 순서라면, 결과는 20이 되고 10이 “사라진다”.

엘릭서에서는:

- **각 프로세스가 자신의 힙을 갖고 있으므로**, 위와 같은 공유 변수 자체가 없다.
- 상태는 특정 프로세스가 들고 있고, 다른 프로세스는 **메시지로만 요청**한다.
- “마지막에 쓴 사람이 이긴다” 류의 레이스는 구조적으로 사라진다.

---

## _3.3 성능에 미치는 영향

이제 질문을 다시 던져 보자.

> 불변이 이렇게 많은 장점을 준다는 건 알겠는데, **성능은 괜찮나?**

핵심 포인트는 네 가지 정도로 요약할 수 있다.

1. **구조적 공유(Structural Sharing)** 로 갱신 비용을 줄인다.  
2. 리스트는 **앞에 붙이기 O(1)**, **뒤에 붙이기 O(n)**.  
3. 맵/MapSet 은 **해시 트라이(HAMT) 계열** 구조로, 평균적으로 빠른 갱신/조회.  
4. 큰 바이너리는 **오프힙 + 참조 카운팅**, 문자열/응답은 **iodata** 로 누적해서 복사 최소화.

### 3.3.1 시간 복잡도 직관

자주 쓰는 연산들을 대략적인 복잡도와 함께 표로 정리하면 다음과 같다.

| 자료구조/연산                | 예시 코드                             | 시간 복잡도(대략)      | 메모리 관점 요약                         |
|-----------------------------|----------------------------------------|------------------------|------------------------------------------|
| 리스트 앞에 붙이기          | `[x | list]`                          | $$O(1)$$               | 새 노드 1개 + 기존 리스트 공유          |
| 리스트 길이 n까지 뒤에 붙이기 | `acc ++ [x]` 반복                     | $$O(n^2)$$              | 매번 전체 복사                          |
| 리스트 뒤집기               | `:lists.reverse(list)`                | $$O(n)$$               | 한 번에 선형 시간                       |
| 맵 조회                     | `Map.fetch(map, key)`                 | 평균 $$O(1) \sim O(\log n)$$ | 해시 기반 트리 탐색 길이에 비례         |
| 맵 갱신                     | `Map.put(map, key, value)`            | 비슷하게 평균 $$O(1)\sim O(\log n)$$ | 갱신 경로만 새로 할당                   |
| iodata → 바이너리           | `:erlang.iolist_to_binary(iodata)`    | $$O(n)$$               | 마지막 한 번만 선형화                   |
| ETS 조회                    | `:ets.lookup(tid, key)`               | 평균 $$O(1)$$          | VM 내부 테이블, 읽기/쓰기 옵션 중요     |

여기서의 메시지는:

- 불변이라고 해서 모든 연산이 “배로 느려지는” 게 아니고,
- **어떤 패턴이 빠른지 알고 쓰면** 충분히 빠른 코드를 짤 수 있다는 것.

### 3.3.2 iodata/iolist로 문자열·바이너리 비용 줄이기

문자열을 이어붙일 때, 흔히 이렇게 쓴다.

```elixir
def concat_bad(chunks) do
  Enum.reduce(chunks, "", fn chunk, acc -> acc <> chunk end)
end
```

- 각 단계마다 `acc <> chunk` 가 **새 바이너리**를 만든다.
- 길이가 커질수록 매 단계의 비용이 커져서 전체적으로 **O(n^2)** 에 가까워진다.

엘릭서/에르랑에서는 **iodata**(또는 iolist)로 바꾸는 게 정석이다.

```elixir
def concat_good(chunks) do
  chunks
  |> Enum.map(&["[", &1, "]"])  # 이 자체가 iodata
  |> :erlang.iolist_to_binary()
end

iex> concat_good(["a", "b", "c"])
"[a][b][c]"
```

아이디어:

- 이때까지는 **리스트 안에 조각들을 쌓기만** 한다.
- 실제로 “바이너리로 펼치는 작업”은 `iolist_to_binary/1` 에서 **딱 한 번** 일어난다.

HTTP 응답을 만드는 예를 들어보자.

```elixir
def http_response(status, headers, body) do
  status_line = ["HTTP/1.1 ", Integer.to_string(status), " OK\r\n"]

  header_lines =
    for {k, v} <- headers do
      [k, ": ", v, "\r\n"]
    end

  # iodata 전체
  [status_line, header_lines, "\r\n", body]
  |> :erlang.iolist_to_binary()
end
```

이 패턴은:

- 중간 중간에 **큰 바이너리를 계속 새로 만들지 않고**,
- 마지막에 한 번에 정리해서 내보내기 때문에,
- **네트워크/파일 IO** 성능에 큰 영향을 준다.

### 3.3.3 큰 바이너리의 참조 카운팅

바이너리(예: 큰 JSON, 이미지 파일)를 여러 프로세스가 공유할 때, 매번 복사하면 너무 느리고 메모리가 터진다.

그래서 BEAM 은 다음과 같이 동작한다(개념만 요약):

- 작은 바이너리(64바이트 이하)는 **각 프로세스 힙에 직접 저장**한다.
- 64바이트를 넘는 큰 바이너리는 **전역 바이너리 힙**에 두고,
  - 각 프로세스는 **“참조 포인터”** 만 들고 다닌다.
  - 참조 카운트(reference count)를 이용해, 아무도 쓰지 않게 되면 해제한다.

실전에서 체감되는 효과:

- 큰 바이너리를 한 프로세스에서 만들고,
- 여러 프로세스에 메시지로 전달해도,
- 대부분 **복사 대신 참조만 전달**되기 때문에, “불변인데도 꽤 효율적”이다.

### 3.3.4 ETS는 왜 “가변”인가?

**ETS(Erlang Term Storage)** 는 VM 내부의 **공유 테이블**이다.

- 키–값 저장소 형태로,
- 특정 프로세스나 라이브러리가 캐시/세션/컨피그 등을 넣어두고 공유하는 데 쓴다.

“불변이 기본인데 ETS는 왜 가변?” 이라는 질문에 대한 답은:

> **“불변 + 구조적 공유”만으로도 대부분 충분하지만,  
> 아주 읽기/쓰기 빈도가 높은 핫스팟은 “가변 테이블”로 두는 게 더 효율적일 때가 있다.**

간단 예:

```elixir
# 읽기 많은 캐시: :read_concurrency 옵션 활용
:ets.new(:cache, [:set, :public, read_concurrency: true])

:ets.insert(:cache, {:key, %{user: "kim", points: 10}})

case :ets.lookup(:cache, :key) do
  [{:key, value}] -> value
  [] -> :not_found
end
```

주의할 점:

- ETS 안의 값은 여전히 **복사해서 가져온다**.  
  → “읽을 때는 불변”이라는 특성은 그대로 유지된다.
- 여러 프로세스가 동시에 쓰는 경우 **트랜잭션/일관성**을 별도로 설계해야 한다.

### 3.3.5 벤치마크 예제: append vs prepend+reverse

실제로 얼마나 차이가 나는지 `benchee` 를 써서 벤치마크해볼 수 있다.

`mix.exs` 의 `deps` 에:

```elixir
{:benchee, "~> 1.1", only: :dev}
```

추가 후, `bench/append_vs_prepend.exs`:

```elixir
Mix.install([{:benchee, "~> 1.1"}])

n = 10_000

Benchee.run(%{
  "append" => fn ->
    Enum.reduce(1..n, [], fn x, acc -> acc ++ [x] end)
  end,
  "prepend_and_reverse" => fn ->
    1..n
    |> Enum.reduce([], fn x, acc -> [x | acc] end)
    |> :lists.reverse()
  end
})
```

실행:

```bash
elixir bench/append_vs_prepend.exs
```

실제로 돌려보면 환경마다 다르지만, 보통:

- **append** 버전이 훨씬 느리고,
- **prepend_and_reverse** 버전이 리스트 길이가 길어질수록 **압도적으로 유리**해지는 걸 확인할 수 있다.

메시지는 단순하다.

> “불변이라서 느리다”가 아니라,  
> **“불변에 맞는 자료구조/패턴을 쓰면 오히려 더 예측 가능하고 빠르다”**는 것.

---

## _3.4 불변 데이터를 이용해 코딩하기

이제 개념은 충분히 봤으니, **실전 코드에서 어떻게 쓰는지**를 모아 보자.

### 3.4.1 파이프라인으로 “상태 변환”을 노출하기

회원 가입 같은 플로우를 예로 들어 보자.

```elixir
defmodule Signup do
  def run(params) do
    params
    |> normalize()
    |> validate!()
    |> to_changeset()
    |> persist()
  end

  defp normalize(%{"email" => e} = p) do
    Map.put(p, "email", String.trim(e))
  end

  defp validate!(%{"email" => e} = p) do
    if Regex.match?(~r/@/, e), do: p, else: raise ArgumentError, "bad email"
  end

  defp to_changeset(p) do
    %{user: %{email: p["email"]}}
  end

  defp persist(cs) do
    # 여기서는 예시로, ID만 붙여서 반환
    Map.put(cs, :id, System.unique_integer([:positive]))
  end
end
```

특징:

- 각 단계는 **입력 → 출력**만 책임지고,
- `run/1` 은 이들을 **파이프라인으로 연결**한다.
- 실패는 `validate!/1` 처럼 **명확한 포인트**에서 발생한다.

테스트도 단순하다.

```elixir
defmodule SignupTest do
  use ExUnit.Case, async: true

  test "normalize trims email" do
    assert Signup.run(%{"email" => "  a@b "}).user.email == "a@b"
  end
end
```

이 패턴은:

- “서비스 객체”, “use case 레이어” 같은 것을 엘릭서 스타일로 풀어 쓸 때 기본 뼈대가 된다.

### 3.4.2 `Enum`/`Stream` 으로 배치 변환

대량의 데이터를 처리할 때도 **불변 + 파이프라인**을 그대로 적용할 수 있다.

```elixir
defmodule ETL do
  def run(path) do
    path
    |> File.stream!()
    |> Stream.map(&String.trim/1)
    |> Stream.reject(&(&1 == ""))        # 빈 줄 제거
    |> Stream.map(&parse_line/1)
    |> Enum.reduce(%{}, &merge/2)
  end

  # CSV "k,v" -> {k, v}
  defp parse_line(line) do
    [k, v] = String.split(line, ",", parts: 2)
    {k, String.to_integer(v)}
  end

  defp merge({k, v}, acc) do
    Map.update(acc, k, v, &(&1 + v))
  end
end
```

- `File.stream!/1` + `Stream.*` 조합 덕분에 파일을 한 줄씩 읽어 처리한다.
- `acc` 맵은 매 단계마다 **새 맵으로 갱신**되지만, 내부적으로는 공유 가능한 부분을 공유한다.

이렇게 작성하면:

- 메모리를 한 번에 많이 쓰지 않으면서,
- **단계별 변환 로직이 눈에 잘 보이는 ETL 파이프라인**을 얻는다.

### 3.4.3 `GenServer` 상태 업데이트 — “새 상태 반환” 패턴

`GenServer` 를 사용할 때도 핵심 패턴은 같다.

```elixir
defmodule Store do
  use GenServer

  ## 클라이언트 API

  def start_link(init \\ %{}) do
    GenServer.start_link(__MODULE__, init, name: __MODULE__)
  end

  def put(key, value), do: GenServer.call(__MODULE__, {:put, key, value})
  def get(key), do: GenServer.call(__MODULE__, {:get, key})

  ## 서버 콜백

  @impl true
  def init(state), do: {:ok, state}

  @impl true
  def handle_call({:put, key, val}, _from, state) do
    new_state = Map.put(state, key, val)
    {:reply, :ok, new_state}
  end

  def handle_call({:get, key}, _from, state) do
    {:reply, Map.get(state, key), state}
  end
end
```

사용 예:

```elixir
{:ok, _pid} = Store.start_link(%{})

Store.put(:a, 1)
Store.put(:b, 2)

Store.get(:a)
#=> 1
```

여기서의 규칙은:

- `handle_call/3` 에서 **항상 새 상태를 반환**한다.
- 외부에서는 내부 상태를 직접 만질 수 없고, 오직 `call/cast` 로만 상호작용한다.

이 패턴은 OTP 전반의 기본 규칙이기도 하다.

### 3.4.4 이벤트 소싱 풍 패턴: “원본은 보존, 상태는 파생”

불변 데이터는 **이벤트 소싱(Event Sourcing)** 같은 스타일과도 잘 어울린다.

```elixir
defmodule Ledger do
  def apply(events) do
    Enum.reduce(events, %{balance: 0}, fn
      {:deposit, amount}, acc -> %{acc | balance: acc.balance + amount}
      {:withdraw, amount}, acc -> %{acc | balance: acc.balance - amount}
    end)
  end
end

iex> Ledger.apply([{:deposit, 10}, {:withdraw, 3}])
%{balance: 7}
```

- 원본 이벤트 리스트는 **불변 로그**로 보관하고,
- 현재 상태는 언제든지 재계산 가능한 **파생 값**이다.

이 패턴을 확장하면:

- 감사(Audit) 로그,
- 타임라인 재생,
- 롤백/재실행 등에서 강력한 모델을 만들 수 있다.

### 3.4.5 불변 + iodata 로 고성능 로그/응답 만들기

로그 한 줄을 효율적으로 만드는 예를 보자.

```elixir
defmodule LogFmt do
  def line(level, ts, msg, meta \\ []) do
    base = ["[", level, "] ", ts, " ", msg]

    extra =
      meta
      |> Enum.flat_map(fn {k, v} ->
        [" ", to_string(k), "=", inspect(v)]
      end)

    [base, extra, "\n"]
    |> :erlang.iolist_to_binary()
  end
end

iex> LogFmt.line("INFO", "2025-11-10T00:01:02Z", "started", user_id: 1, req_id: "abc")
"[INFO] 2025-11-10T00:01:02Z started user_id: 1 req_id: \"abc\"\n"
```

- 문자열을 **차곡차곡 쌓을 때는 리스트(iodata)** 를 쓰고,
- 파일/소켓에 쓰기 직전에만 **바이너리로 선형화**하는 패턴이다.
- 이 패턴은 웹 서버, 템플릿 렌더링, 로그 시스템 등에서 아주 널리 쓰인다.

### 3.4.6 불변 컬렉션 설계 요령 모음

요약해서 “일반적인 컬렉션 처리 요령”을 정리하면:

1. **리스트**
   - 데이터 쌓기: **앞에 붙이기 → 마지막에 `:lists.reverse` 한 번**
   - 인덱스로 접근해야 하는 경우가 많다면: 리스트 대신 **맥/배열/벡터 구조**(예: `:array`, `:gb_trees`)를 고려.

2. **맵**
   - 중첩 구조: `put_in/3`, `update_in/3`, `get_in/2` 으로 **경로 기반** 갱신.
   - “기본값 + 누적” 패턴: `Map.update/4`, `Map.update!/3` 적극 활용.

3. **집합(Set)**
   - `MapSet` 을 사용. 삽입/삭제/멤버십 연산이 자연스럽게 표현된다.

```elixir
defmodule Tags do
  def toggle(set, tag) do
    if MapSet.member?(set, tag) do
      MapSet.delete(set, tag)
    else
      MapSet.put(set, tag)
    end
  end
end
```

4. **배열 느낌이 필요한 경우**
   - 인덱스 기반 밀집 배열이 필요하면 `:array`, `:ets`, `:persistent_term` 등의 도구를 각 요건에 맞게 선택.

### 3.4.7 “불변 + 가변” 혼합 전략: ETS/Agent 캐시

대부분의 코드는 불변으로 두되, 특정 부분만 가변으로 두는 전략도 필요하다.

예: 읽기 많은 캐시

```elixir
defmodule Cache do
  def start_link do
    tid = :ets.new(__MODULE__, [:set, :public, read_concurrency: true])
    Agent.start_link(fn -> tid end, name: __MODULE__
    )
  end

  def get(key) do
    tid = Agent.get(__MODULE__, & &1)

    case :ets.lookup(tid, key) do
      [{^key, value}] -> {:hit, value}
      [] -> :miss
    end
  end

  def put(key, value) do
    tid = Agent.get(__MODULE__, & &1)
    true = :ets.insert(tid, {key, value})
    :ok
  end
end
```

- ETS 테이블 자체는 가변이지만,
- 꺼내온 값은 **그 시점부터는 불변**이다.
- “핫스팟은 가변, 나머지는 불변”이라는 설계가 자연스럽게 나온다.

### 3.4.8 테스트 전략: 스냅샷 + 속성 기반 테스트

불변 데이터 덕분에 테스트 전략도 단순해진다.

1. **스냅샷 테스트**
   - 입력에 대한 **결과 구조 전체**를 찍어 두고,
   - 리팩터링 후에도 같은 구조가 나오는지 비교.

2. **속성 기반 테스트 (Property-based Testing)**
   - 예: 리스트 이어붙이기에 대해
     - $$\operatorname{sum}(A \mathbin{+\!\!+} B) = \operatorname{sum}(A) + \operatorname{sum}(B)$$
   - 불변이 전제이기 때문에, “순서를 바꿔도 상태가 훼손될 수 있다”는 걱정이 줄고  
     **수학적 속성**으로 표현하기가 쉬워진다.

간단한 예:

```elixir
# stream_data를 사용할 경우 예시
use ExUnitProperties

property "sum of concatenated lists is sum of sums" do
  check all list1 <- list_of(integer()),
            list2 <- list_of(integer()) do
    left = Enum.sum(list1 ++ list2)
    right = Enum.sum(list1) + Enum.sum(list2)
    assert left == right
  end
end
```

---

## 부록 A: 실수하기 쉬운 패턴과 교정

1) **리스트 뒤에 붙이기 남용**

```elixir
# 나쁜 예
Enum.reduce(1..n, [], fn x, acc -> acc ++ [x] end)
```

- 매번 리스트를 복사한다.

```elixir
# 좋은 예
1..n
|> Enum.reduce([], fn x, acc -> [x | acc] end)
|> :lists.reverse()
```

2) **문자열 결합 `<>` 남발**

```elixir
# 나쁜 예
def build_html(users) do
  Enum.reduce(users, "", fn u, acc ->
    acc <> "<li>" <> u.name <> "</li>"
  end)
end
```

```elixir
# 좋은 예 (iodata)
def build_html(users) do
  users
  |> Enum.map(fn u -> ["<li>", u.name, "</li>"] end)
  |> :erlang.iolist_to_binary()
end
```

3) **깊은 맵 갱신에 `Map.put/3` 체인 남발**

```elixir
# 나쁜 예
m
|> Map.put(:user, Map.put(m.user, :profile, Map.put(m.user.profile, :age, 20)))
```

```elixir
# 좋은 예
put_in(m, [:user, :profile, :age], 20)
```

4) **큰 바이너리 자주 복사**

- 큰 JSON/이미지를 계속 `<>` 로 이어붙이면 복사 비용이 커진다.
- 가능하다면:
  - 한 번 만들어서 여러 프로세스에 메시지로 전달하거나,
  - 필요한 부분만 바이너리 패턴으로 읽어 쓰는 방향으로 설계.

5) **공유 상태에 직접 접근**

- 전역 변수 느낌으로 어디서나 `Agent.get/2` / `Agent.update/2` 를 뒤섞으면, OOP 의 전역 싱글톤과 비슷한 악취가 난다.
- 가능하면 **역할별 프로세스(GenServer)** 를 두고, 그 프로세스의 **API를 통해서만 상태 접근**을 허용하라.

---

## 부록 B: 성능 체크리스트

코드를 한 번 쭉 훑어볼 때, 다음 질문들을 체크리스트로 써볼 수 있다.

- [ ] 리스트 결합은 **prepend → reverse** 패턴을 사용하고 있는가?  
- [ ] 문자열/바이너리 결합은 **iodata** 를 사용하고 있는가?  
- [ ] 큰 바이너리는 필요 이상의 복사/슬라이스를 만들지 않는가?  
- [ ] 맵 갱신은 `put_in/update_in` 등 **경로 기반** 연산을 쓰고 있는가?  
- [ ] 읽기 많은 공유 데이터에 **ETS** 를 도입하는 게 도움이 되는가?  
- [ ] 상태 공유가 필요한 부분은 **GenServer/프로세스**로 캡슐화되어 있는가?  
- [ ] 대량 데이터 처리는 `Stream` 을 사용해 **지연 평가**로 메모리 압력을 낮추고 있는가?

---

## _3.5 결론

이 장에서 본 것은 사실 하나의 문장으로 요약된다.

> **엘릭서에서 데이터는 불변이고, 이름은 그 데이터를 가리키는 라벨이다.**

이 단순한 전제를 받아들이면:

- 패턴 매칭(2장에서 본 내용)이 “**제약을 만족하는 해를 찾는 과정**”으로 보이고,
- 동시성은 “**상태를 공유하는 게 아니라, 불변 값을 메시지로 전달하는 것**”으로 보이며,
- 성능은 “**어떤 구조가 어느 연산에 유리한지**”를 알면 충분히 맞출 수 있다.

다음 장들에서 보게 될 OTP, 프로세스 슈퍼비전, GenServer/GenStage/Flow 같은 것들은  
모두 이 **불변 데이터 + 메시지 패싱** 위에 쌓여 있는 추상화들이다.

3장을 제대로 이해했다면, 이제 엘릭서/BEAM 을 “이상한 문법의 또 다른 언어”가 아니라  
**“불변 데이터 + 패턴 매칭 + 프로세스”라는 하나의 일관된 모델**로 바라볼 수 있게 될 것이다.