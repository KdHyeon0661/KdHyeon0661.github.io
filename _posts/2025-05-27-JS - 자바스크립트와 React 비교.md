---
layout: post
title: JavaScript - 자바스크립트와 React 비교
date: 2025-05-27 23:20:23 +0900
category: JavaScript
---
# 자바스크립트와 React 비교: 어떻게 다르고 어떻게 연결되는가?

## 자바스크립트(JavaScript)란 무엇인가?

> 자바스크립트는 웹의 기본 언어로, **로직·데이터 처리·DOM 조작·네트워크 통신**을 담당합니다.

### JS로 할 수 있는 일

- **DOM 조작**: 노드 생성/삭제/속성 변경, 이벤트 바인딩
- **비동기 처리**: `fetch`, `Promise`, `async/await`로 API 호출
- **언어 기능**: 함수/클래스/모듈/이터러블/제너레이터/프로토타입 등
- **런타임 다양성**: 브라우저/Node.js/Deno/Cloudflare Workers 등

#### 순수 JS 예시 — 버튼 클릭 알림

```html
<button id="btn">클릭</button>
<script>
  const btn = document.getElementById('btn');
  btn.addEventListener('click', () => alert('클릭되었습니다!'));
</script>
```

---

## React란 무엇인가?

> **React는 자바스크립트 기반 UI 라이브러리**입니다. 핵심 목표는 **상태 변화에 따라 UI를 “선언적”으로 갱신**하는 것.

### React의 주요 특징

- **컴포넌트 기반**: UI를 작은 조각으로 나눠 재사용/조합
- **선언적 렌더링**: “무엇을 보여줄지”를 선언하면, 변경은 React가 수행
- **가상 DOM**: 실제 DOM 조작을 추상화하여 효율적인 업데이트
- **단방향 데이터 흐름**: 상위→하위로 데이터 전달(props)
- **Hooks**: 함수형 컴포넌트에서 상태/라이프사이클/컨텍스트 사용

#### — React 버전

```jsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';

function App() {
  const handleClick = () => alert('클릭되었습니다!');
  return <button onClick={handleClick}>클릭</button>;
}

createRoot(document.getElementById('root')).render(
  <StrictMode><App/></StrictMode>
);
```

---

## 핵심 비교 요약

| 관점 | 자바스크립트 | React |
|---|---|---|
| 정체 | **언어** | **UI 라이브러리** |
| 목적 | 로직·데이터·DOM 직접 제어 | **상태 → UI** 선언적 매핑 |
| 렌더링 | 수동 DOM 조작 | 가상 DOM + Diff/Reconciliation |
| 아키텍처 | 자유(절차·OOP·함수형) | **컴포넌트 계층** 중심 |
| 상태 관리 | 지역 변수/전역/이벤트 버스 | `useState`/`useReducer`/Context/외부 스토어 |
| 재사용 | 함수/클래스/유틸 | **컴포넌트/커스텀 훅** |
| 학습 곡선 | 언어 습득 | 언어 + React 개념(Hooks, 키, 라이프사이클) |
| 빌드 | 필수 아님 | 보통 번들러/트랜스파일러 사용(Vite/Next 등) |

---

## 둘은 어떻게 연결되는가?

- React는 **JS 위에서 동작**합니다. JSX도 결국 **JS로 트랜스파일**됩니다.
- React 컴포넌트 안에서 **순수 JS 문법·모듈·유틸**을 그대로 사용합니다.

```jsx
function Welcome({ user }) {
  const name = user?.name ?? 'Guest';   // JS 문법
  const greet = (n) => `Hello, ${n}`;   // JS 함수
  return <p>{greet(name)}</p>;          // JSX 안에서 JS 표현식
}
```

---

## 동일 요구사항, 두 방식 비교 — “카운터”

### 순수 JS(명령형)

```html
<p id="count">0</p>
<button id="inc">증가</button>
<script>
  let count = 0;
  const $count = document.getElementById('count');
  document.getElementById('inc').addEventListener('click', () => {
    count++;
    $count.textContent = String(count); // 직접 DOM 업데이트
  });
</script>
```

### React(선언형)

```jsx
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  return (
    <>
      <p>{count}</p>
      <button onClick={() => setCount(c => c + 1)}>증가</button>
    </>
  );
}
```
**차이점**:
- JS는 “클릭 → 변수 증가 → 해당 DOM 노드 찾아 텍스트 변경”처럼 **순서**를 코딩.
- React는 “**상태**가 바뀌면 이 UI”라고 선언 → 변경은 React가 계산·적용.

---

## DOM 이벤트/업데이트 차이

### 순수 JS

- 이벤트 바인딩·해제, 위임, 버블링 제어를 직접 구현
- DOM 읽기/쓰기 타이밍(레이아웃 스래싱)까지 고려해야 함

### React

- JSX 속성(`onClick`, `onChange`)으로 이벤트 선언
- **키(key)**를 통한 리스트 식별
- React 18부터 **동시성(Concurrent) 기능**으로 렌더링 스케줄링 최적화(프레임 유연성)

---

## 상태 관리: JS vs React

| 상황 | JS(바닐라) | React |
|---|---|---|
| 간단한 입력폼 | 지역 변수/이벤트 | `useState`/제어 컴포넌트 |
| 컴포넌트 트리 공유 | 커스텀 이벤트/전역 객체 | Context/전역 스토어(Redux/Zustand/Jotai 등) |
| 비동기 캐시 | 직접 캐시/Fetch 래퍼 | React Query/SWR(서버 상태 관리) |

#### React의 흔한 패턴

```jsx
// 1) 상태 + 파생값 + 이벤트
const [text, setText] = useState('');
const chars = text.length; // 파생값(렌더 때 계산)

// 2) 복잡 로직 분리: 커스텀 훅
function useCounter(initial=0){
  const [n, setN] = useState(initial);
  const inc = () => setN(v => v+1);
  const dec = () => setN(v => v-1);
  return { n, inc, dec };
}
```

---

## JSX vs HTML: 중요한 차이

| 항목 | HTML | JSX |
|---|---|---|
| 속성 이름 | `class`, `for` | `className`, `htmlFor` |
| 스타일 | 문자열 | 객체({% raw %}`style={{ color:'red' }}`{% endraw %}) |
| 이벤트 | `onclick="..."` | `onClick={fn}` (카멜케이스) |
| 주석 | `<!-- -->` | `{/* ... */}` |
| 조건/반복 | 없음(템플릿 필요) | JS 표현식으로 처리 (`map`, 삼항 등) |

```jsx
<ul>
  {items.map(it => <li key={it.id}>{it.title}</li>)}  {/* key 필수! */}
</ul>
```

---

## 성능 관점: 언제 무엇을 선택?

### React의 강점

- **상태-UI 동기화 비용 절감**: 대규모 인터랙션 UI에서 유지보수 압도적
- **생태계**: 서버 상태(React Query), 라우팅(React Router/Next), 상태(Redux/Zustand) 풍부
- **SSR/SSG/ISR**: Next.js로 SEO·초기 로딩 개선, 스트리밍 렌더링

### 바닐라 JS가 유리한 상황

- **초미니 위젯**: 단일 버튼/토글/배너 같은 단일 DOM 조작
- **서드파티 삽입**: 라이브러리 의존 낮추고 배포 용이
- **부트 성능 극한**: React 런타임/번들 없이 즉시 상호작용

---

## 실전: 바닐라 → React 마이그레이션 패턴

### “렌더 함수” 추상화부터

```js
// (바닐라) 상태 → HTML 문자열/노드로 만드는 렌더 함수
function renderList(root, items){
  root.innerHTML = items.map(x => `<li>${x}</li>`).join('');
}
```
React로 오면 **렌더 함수 ≈ 컴포넌트**로 직조:
```jsx
function List({ items }) {
  return <ul>{items.map(x => <li key={x}>{x}</li>)}</ul>;
}
```

### 이벤트/상태 끌어올리기(Lifting State Up)

- 바닐라: 전역/모듈 변수 + 커스텀 이벤트
- React: 상위 컴포넌트의 `useState` → 하위로 props 전달

### 점진 도입

- 페이지 전체를 갈아엎지 말고, **바닐라 앱의 특정 영역**에 React **섬(섹션)**을 마운트
- 마이크로 프런트엔드/위젯화로 리스크 분산

---

## 네트워크/비동기: fetch vs React Query 예시

### 바닐라

```js
async function loadUsers() {
  const res = await fetch('/api/users');
  if(!res.ok) throw new Error('네트워크 오류');
  return res.json();
}
```

### React(서버 상태 관리)

```jsx
import { useQuery } from '@tanstack/react-query';

function Users() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      const res = await fetch('/api/users');
      if (!res.ok) throw new Error('네트워크 오류');
      return res.json();
    }
  });
  if (isLoading) return <p>로딩...</p>;
  if (error)     return <p>에러</p>;
  return <ul>{data.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```
- **캐싱/리트라이/리프레시** 등 네트워크 상태 처리를 컴포넌트 코드에서 분리

---

## 성능 최적화 체크리스트(React 기준)

- **리스트 key 안정성**: 인덱스 사용 지양(재정렬 시 버그/리렌더)
- **memo/useMemo/useCallback**: 값/함수 메모화로 불필요 렌더 억제
- **분할 렌더링**: 리스트 가상화(react-window/virtuoso), 무거운 섹션 `Suspense`/코드 스플리팅
- **이벤트 핸들러 최적화**: 스크롤/리사이즈 `passive`, `throttle/debounce`
- **서버 사이드 렌더링**: LCP/TTFB 개선(Next.js), 스트리밍/서스펜스
- **불변성** 유지: 상태 업데이트 시 **새 참조** 반환
```jsx
// 안티패턴: 배열을 직접 수정
state.items.push(item); setState(state);
// 개선: 새 배열 생성
setItems(prev => [...prev, item]);
```

---

## 테스트 전략: JS vs React

### 단위 테스트(언어 레벨)

- 비즈니스 로직/유틸 함수는 **프레임워크 독립**으로 테스트
```js
// sum.test.js (Jest)
import { sum } from './sum';
test('1+2=3', () => expect(sum(1,2)).toBe(3));
```

### React 컴포넌트 테스트

- **React Testing Library**: 사용자 관점(접근성 질의)으로 테스트
```jsx
import { render, screen, fireEvent } from '@testing-library/react';
import Counter from './Counter';

test('증가 버튼 클릭 시 값 증가', () => {
  render(<Counter/>);
  fireEvent.click(screen.getByRole('button', { name: '증가' }));
  expect(screen.getByText('1')).toBeInTheDocument();
});
```

---

## 빌드·번들·타입

- 바닐라 JS: 스크립트 태그로도 충분. 복잡해지면 **Vite/Parcel/Webpack**.
- React: 일반적으로 **Vite/Next.js**를 사용(개발 서버·HMR·코드 스플리팅).
- **TypeScript**: 둘 다 사용 가능. React에선 Props/상태 타입으로 **대형 코드베이스 안정성↑**.

---

## 폼·입력 제어 비교

### 바닐라

```html
<form id="f">
  <input id="name"/>
  <button>저장</button>
</form>
<script>
  document.getElementById('f').addEventListener('submit', e => {
    e.preventDefault();
    const name = document.getElementById('name').value.trim();
    // 검증 후 fetch
  });
</script>
```

### React(제어 컴포넌트)

```jsx
function Form() {
  const [name, setName] = useState('');
  const onSubmit = e => {
    e.preventDefault();
    // 검증 후 fetch
  };
  return (
    <form onSubmit={onSubmit}>
      <input value={name} onChange={e=>setName(e.target.value)}/>
      <button>저장</button>
    </form>
  );
}
```
- 복잡한 폼은 **React Hook Form/Formik/Zod/Yup** 조합이 유지보수에 유리

---

## 접근성(A11y)·SEO

- 바닐라/React 모두 **시맨틱 마크업**·WAI-ARIA 속성·키보드 내비게이션 중요
- SPA의 SEO는 기본적으로 약함 → **SSR/SSG(Next.js)**로 보완
- React Testing Library의 접근성 질의(`getByRole`, `getByLabelText`)는 A11y 향상에 직결

---

## 보안·취약점 관점

- 공통: **XSS 방지**(innerHTML 사용 자제/정화), CSRF는 서버/쿠키 정책으로
- React: 기본적으로 JSX에서 HTML 이스케이프. **dangerouslySetInnerHTML** 사용 시 신중
- 외부 스크립트/서드파티 위젯은 CSP/서브리소스 무결성(SRI) 고려

---

## 선택 가이드

| 상황 | 권장 |
|---|---|
| 단일 버튼·배지·배너 | 바닐라 JS |
| 다수의 상호작용·상태 공유·재사용 많은 SPA | React |
| 초기 로딩 성능/SEO 중요 | React + Next.js(SSR/SSG) |
| 사내용 간단 도구·대시보드 | React(생산성) 또는 바닐라 + 경량 라이브러리 |
| 위젯로 외부 삽입 | 바닐라 또는 React “섬”을 마운트(독립 번들) |

---

## 실전 미니 프로젝트 — “필터 가능한 리스트”

### 바닐라 버전

```html
<input id="q" placeholder="검색"/>
<ul id="list"></ul>
<script>
  const data = ['apple','banana','cherry','avocado'];
  const $q = document.getElementById('q');
  const $list = document.getElementById('list');

  function render(items){
    $list.innerHTML = items.map(x=>`<li>${x}</li>`).join('');
  }
  render(data);

  $q.addEventListener('input', () => {
    const k = $q.value.toLowerCase();
    render(data.filter(x => x.includes(k)));
  });
</script>
```

### React 버전

```jsx
import { useMemo, useState } from 'react';

const DATA = ['apple','banana','cherry','avocado'];

export default function FilterList() {
  const [q, setQ] = useState('');
  const items = useMemo(
    () => DATA.filter(x => x.toLowerCase().includes(q.toLowerCase())),
    [q]
  );
  return (
    <>
      <input value={q} onChange={e=>setQ(e.target.value)} placeholder="검색"/>
      <ul>{items.map(x => <li key={x}>{x}</li>)}</ul>
    </>
  );
}
```
- React는 **상태-UI 관계**가 명확하여 필터/정렬/페이징과 같은 조합이 커질수록 유지보수성이 유리.

---

## 결론 요약

| 결론 | 요지 |
|---|---|
| 자바스크립트 | 웹의 **언어**. 로직·네트워크·DOM 조작·도구 생태계의 기반 |
| React | JS 기반 **UI 라이브러리**. 상태 변화를 선언적으로 UI에 반영 |
| 선택 기준 | UI 복잡도·상태 공유·재사용성·SEO/성능 요구 |
| 함께 쓰기 | 바닐라 위에 React “섬”을 얹거나, React 앱에서 순수 JS 유틸을 적극 사용 |
| 유지보수 | 규모가 커질수록 **컴포넌트/훅/상태 아키텍처**의 이점이 커짐 |

---

## 참고 링크

- MDN JavaScript: https://developer.mozilla.org/ko/docs/Web/JavaScript
- React 공식 문서: https://react.dev/
- Next.js: https://nextjs.org/
- React Testing Library: https://testing-library.com/docs/react-testing-library/intro/
- TanStack Query(React Query): https://tanstack.com/query/latest

---
본 글의 코드는 자유롭게 변형/재사용해도 좋습니다. 필요하면 **바닐라 → React 마이그레이션** 체크리스트 또는 **Next.js/상태관리(React Query/Redux/Zustand) 심화**도 이어서 정리해 드리겠습니다.
