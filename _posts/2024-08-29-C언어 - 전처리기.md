---
layout: post
title: C - 전처리기
date: 2024-08-29 19:20:23 +0900
category: C
---
# 전처리기 지시자: C 언어의 컴파일 전처리 마스터하기

## 전처리기란 무엇인가?

전처리기는 C 컴파일러의 첫 번째 단계로, 소스 코드를 컴파일하기 전에 텍스트 수준에서 변환 작업을 수행합니다. 마치 요리하기 전에 재료를 다듬고 준비하는 과정과 같습니다. 전처리기는 실제 컴파일이 시작되기 전에 작동하여 코드를 더 모듈화하고, 플랫폼에 독립적으로 만들며, 디버깅과 관리를 용이하게 합니다.

간단히 말해, 전처리기는 다음과 같은 작업을 합니다:
- **매크로 처리**: 코드 조각을 정의하고 재사용
- **조건부 컴파일**: 특정 조건에 따라 코드 포함/제외
- **파일 포함**: 다른 소스 파일의 내용을 현재 파일에 삽입
- **컴파일 지시**: 컴파일러에게 특별한 지시사항 전달

## 전처리기의 기본 사용법

### 매크로 정의와 사용

매크로는 코드 조각에 이름을 붙여 재사용할 수 있게 해줍니다. 가장 기본적인 형태부터 시작해보겠습니다:

```c
#include <stdio.h>

// 간단한 상수 매크로
#define PI 3.141592653589793
#define MAX_SIZE 100
#define GREETING "안녕하세요!"

// 함수형 매크로 (매개변수가 있는 매크로)
#define SQUARE(x) ((x) * (x))
#define MAX(a, b) ((a) > (b) ? (a) : (b))

// 여러 줄 매크로
#define PRINT_SUM(a, b) \
    do { \
        int sum = (a) + (b); \
        printf("%d + %d = %d\n", (a), (b), sum); \
    } while(0)

int main(void) {
    // 상수 매크로 사용
    printf("원주율: %f\n", PI);
    printf("인사말: %s\n", GREETING);
    
    // 함수형 매크로 사용
    int num = 5;
    printf("%d의 제곱: %d\n", num, SQUARE(num));
    
    int x = 10, y = 20;
    printf("%d와 %d 중 큰 값: %d\n", x, y, MAX(x, y));
    
    // 여러 줄 매크로 사용
    PRINT_SUM(15, 25);
    
    return 0;
}
```

### 매크로 사용 시 주의사항

매크로는 강력하지만 올바르게 사용하지 않으면 예기치 않은 문제를 일으킬 수 있습니다:

```c
#include <stdio.h>

// 올바른 매크로 정의
#define SAFE_SQUARE(x) ((x) * (x))

// 위험한 매크로 사용 예제
void dangerous_macro_example(void) {
    int a = 5;
    
    // 1. 괄호가 없는 매크로의 위험성
    #define BAD_SQUARE(x) x * x  // 나쁜 예: 괄호가 없음
    
    printf("BAD_SQUARE(5+3) = %d\n", BAD_SQUARE(5+3));
    // 예상: (5+3)*(5+3) = 64
    // 실제: 5+3*5+3 = 5+15+3 = 23
    
    printf("SAFE_SQUARE(5+3) = %d\n", SAFE_SQUARE(5+3));  // 올바른 결과: 64
    
    // 2. 부작용이 있는 인자의 위험성
    int i = 2;
    printf("SAFE_SQUARE(i++) = %d\n", SAFE_SQUARE(i++));
    // 예상: 2*2 = 4, i는 3
    // 실제: (i++) * (i++) = 2 * 3 = 6, i는 4
    // 매크로는 텍스트 치환이므로 i++가 두 번 평가됨!
    
    // 3. 세미콜론 문제
    #define PRINT_HELLO printf("Hello\n")
    
    if (1)
        PRINT_HELLO;  // 예상대로 동작
    else
        printf("World\n");
        
    // 여러 문장을 포함하는 매크로의 문제
    #define SWAP_BAD(a, b) \
        int temp = a; \
        a = b; \
        b = temp
    
    int x = 1, y = 2;
    if (x < y)
        SWAP_BAD(x, y);  // 컴파일 오류!
    // do-while 패턴을 사용해야 함
}
```

### 안전한 매크로 작성법

```c
#include <stdio.h>

// 1. 항상 인자를 괄호로 감싸기
#define AREA_CIRCLE(r) ((r) * (r) * 3.141592)

// 2. 전체 표현식을 괄호로 감싸기
#define SUM(a, b) ((a) + (b))

// 3. 여러 문장의 매크로는 do-while(0) 패턴 사용
#define SWAP_INT(a, b) \
    do { \
        int temp = (a); \
        (a) = (b); \
        (b) = temp; \
    } while(0)

// 4. 고유한 지역 변수 이름 사용 (__ 접두사)
#define SWAP_GENERIC(type, a, b) \
    do { \
        type __temp = (a); \
        (a) = (b); \
        (b) = __temp; \
    } while(0)

// 5. 가능하면 static inline 함수 사용 고려
static inline int max_int(int a, int b) {
    return (a > b) ? a : b;
}

int main(void) {
    // 안전한 매크로 사용
    double radius = 5.0;
    printf("반지름 %.1f인 원의 넓이: %.2f\n", radius, AREA_CIRCLE(radius));
    
    int num1 = 10, num2 = 20;
    printf("%d + %d = %d\n", num1, num2, SUM(num1, num2));
    
    // SWAP 매크로 사용
    int x = 100, y = 200;
    printf("교환 전: x=%d, y=%d\n", x, y);
    SWAP_INT(x, y);
    printf("교환 후: x=%d, y=%d\n", x, y);
    
    // 제네릭 SWAP 매크로
    double d1 = 3.14, d2 = 2.71;
    printf("교환 전: d1=%.2f, d2=%.2f\n", d1, d2);
    SWAP_GENERIC(double, d1, d2);
    printf("교환 후: d1=%.2f, d2=%.2f\n", d1, d2);
    
    return 0;
}
```

## 조건부 컴파일: 코드의 선택적 포함

조건부 컴파일을 사용하면 특정 조건에 따라 코드를 포함하거나 제외할 수 있습니다. 이는 플랫폼 호환성, 디버깅, 기능 토글 등에 유용합니다.

### 기본적인 조건부 컴파일

```c
#include <stdio.h>

// 디버그 모드 정의
#define DEBUG 1

// 간단한 조건부 컴파일
#ifdef DEBUG
    #define DEBUG_PRINT(msg) printf("[DEBUG] %s\n", msg)
#else
    #define DEBUG_PRINT(msg)  // 아무것도 하지 않음
#endif

// #if, #elif, #else 사용
#define VERSION 2

#if VERSION == 1
    #define FEATURE "기본 기능"
#elif VERSION == 2
    #define FEATURE "고급 기능"
#else
    #define FEATURE "알 수 없는 버전"
#endif

// defined 연산자 사용
#ifndef LOG_LEVEL
    #define LOG_LEVEL 2  // 기본값 설정
#endif

int main(void) {
    DEBUG_PRINT("프로그램 시작");
    
    printf("현재 버전 기능: %s\n", FEATURE);
    
    #if LOG_LEVEL >= 1
        printf("[INFO] 일반 정보 메시지\n");
    #endif
    
    #if LOG_LEVEL >= 2
        printf("[DEBUG] 상세 디버그 메시지\n");
    #endif
    
    #if LOG_LEVEL >= 3
        printf("[TRACE] 추적 메시지\n");
    #endif
    
    DEBUG_PRINT("프로그램 종료");
    
    return 0;
}
```

### 플랫폼 감지와 조건부 컴파일

실제 프로젝트에서는 다양한 플랫폼을 지원해야 할 때가 많습니다:

```c
#include <stdio.h>

// 플랫폼 감지
#if defined(_WIN32) || defined(_WIN64)
    #define PLATFORM "Windows"
    #define PATH_SEPARATOR '\\'
    #define NEWLINE "\r\n"
#elif defined(__APPLE__) && defined(__MACH__)
    #define PLATFORM "macOS"
    #define PATH_SEPARATOR '/'
    #define NEWLINE "\n"
#elif defined(__linux__)
    #define PLATFORM "Linux"
    #define PATH_SEPARATOR '/'
    #define NEWLINE "\n"
#else
    #define PLATFORM "Unknown"
    #define PATH_SEPARATOR '/'
    #define NEWLINE "\n"
#endif

// 컴파일러 감지
#if defined(_MSC_VER)
    #define COMPILER "Microsoft Visual C++"
    #pragma warning(disable: 4996)  // 예제: 특정 경고 비활성화
#elif defined(__clang__)
    #define COMPILER "Clang"
#elif defined(__GNUC__)
    #define COMPILER "GCC"
#else
    #define COMPILER "Unknown Compiler"
#endif

// 아키텍처 감지
#if defined(__x86_64__) || defined(_M_X64)
    #define ARCHITECTURE "x86-64"
#elif defined(__i386__) || defined(_M_IX86)
    #define ARCHITECTURE "x86"
#elif defined(__aarch64__)
    #define ARCHITECTURE "ARM64"
#elif defined(__arm__)
    #define ARCHITECTURE "ARM"
#else
    #define ARCHITECTURE "Unknown"
#endif

int main(void) {
    printf("플랫폼: %s\n", PLATFORM);
    printf("컴파일러: %s\n", COMPILER);
    printf("아키텍처: %s\n", ARCHITECTURE);
    printf("경로 구분자: %c\n", PATH_SEPARATOR);
    printf("개행 문자: ");
    
    // 개행 문자 시각화
    const char *nl = NEWLINE;
    while (*nl) {
        if (*nl == '\r') printf("\\r");
        else if (*nl == '\n') printf("\\n");
        else printf("%c", *nl);
        nl++;
    }
    printf("\n");
    
    // 플랫폼별 코드
    #if defined(_WIN32)
        printf("윈도우 전용 기능을 사용합니다.\n");
        // WinAPI 함수 호출 등
    #elif defined(__linux__)
        printf("리눅스 전용 기능을 사용합니다.\n");
        // 리눅스 시스템 호출 등
    #endif
    
    return 0;
}
```

## 파일 포함과 헤더 가드

### #include 지시자

`#include`는 다른 파일의 내용을 현재 파일에 삽입합니다:

```c
// math_utils.h - 유틸리티 함수 선언
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int add(int a, int b);
int subtract(int a, int b);
double calculate_average(int array[], int size);

#endif

// config.h - 설정 상수 정의
#ifndef CONFIG_H
#define CONFIG_H

#define MAX_USERS 100
#define TIMEOUT_SECONDS 30
#define LOG_FILE "app.log"

#endif

// main.c - 메인 프로그램
#include <stdio.h>      // 표준 라이브러리 헤더
#include "math_utils.h" // 사용자 정의 헤더
#include "config.h"     // 설정 헤더

int main(void) {
    printf("최대 사용자 수: %d\n", MAX_USERS);
    printf("타임아웃: %d초\n", TIMEOUT_SECONDS);
    
    int result = add(10, 20);
    printf("10 + 20 = %d\n", result);
    
    return 0;
}

// math_utils.c - 함수 구현
#include "math_utils.h"

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

double calculate_average(int array[], int size) {
    if (size == 0) return 0.0;
    
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += array[i];
    }
    
    return (double)sum / size;
}
```

### 헤더 가드의 중요성

헤더 가드는 헤더 파일이 여러 번 포함되는 것을 방지합니다:

```c
// 헤더 가드가 없는 경우의 문제

// file1.h
int global_var = 42;  // 정의

// file2.h
#include "file1.h"

// main.c
#include "file1.h"  // 첫 번째 포함
#include "file2.h"  // file1.h를 다시 포함

// 컴파일 오류: global_var의 재정의

// 헤더 가드를 사용한 올바른 예제

// shapes.h - 도형 관련 상수와 함수
#ifndef SHAPES_H  // 만약 SHAPES_H가 정의되지 않았다면
#define SHAPES_H  // SHAPES_H를 정의하고 다음 코드를 포함

#define PI 3.141592653589793

typedef enum {
    SHAPE_CIRCLE,
    SHAPE_RECTANGLE,
    SHAPE_TRIANGLE
} ShapeType;

typedef struct {
    ShapeType type;
    union {
        struct { double radius; } circle;
        struct { double width, height; } rectangle;
        struct { double base, height; } triangle;
    } dimensions;
} Shape;

double calculate_area(const Shape *shape);
double calculate_perimeter(const Shape *shape);

#endif  // SHAPES_H
```

## 고급 전처리기 기능

### 문자열화(#)와 토큰 붙이기(##)

```c
#include <stdio.h>

// # 연산자: 매크로 인자를 문자열로 변환
#define STRINGIFY(x) #x
#define MAKE_STRING(msg) "메시지: " #msg

// ## 연산자: 토큰을 연결
#define CONCAT(a, b) a##b
#define MAKE_VARIABLE(name, number) name##number

// 가변 인자 매크로 (C99)
#define LOG(level, format, ...) \
    printf("[%s] %s:%d: " format "\n", level, __FILE__, __LINE__, ##__VA_ARGS__)

int main(void) {
    // # 연산자 사용
    int my_variable = 100;
    printf("%s\n", STRINGIFY(my_variable));  // "my_variable"
    printf("%s\n", MAKE_STRING(Hello World)); // "메시지: Hello World"
    
    // ## 연산자 사용
    int var1 = 10, var2 = 20, var3 = 30;
    int MAKE_VARIABLE(var, 1) = 100;  // var1 = 100
    int MAKE_VARIABLE(var, 2) = 200;  // var2 = 200
    
    printf("var1 = %d, var2 = %d\n", var1, var2);
    
    // CONCAT 매크로 사용
    int xy = 42;
    printf("xy = %d\n", CONCAT(x, y));  // xy
    
    // 가변 인자 매크로 사용
    LOG("INFO", "프로그램 시작");
    LOG("DEBUG", "값: %d, %s", 42, "테스트");
    LOG("ERROR", "파일을 찾을 수 없습니다");
    
    return 0;
}
```

### 미리 정의된 매크로

C 언어는 여러 가지 유용한 미리 정의된 매크로를 제공합니다:

```c
#include <stdio.h>

void show_predefined_macros(void) {
    printf("파일 정보:\n");
    printf("  파일명: %s\n", __FILE__);
    printf("  라인 번호: %d\n", __LINE__);
    printf("  함수명: %s\n", __func__);
    
    printf("\n날짜와 시간:\n");
    printf("  컴파일 날짜: %s\n", __DATE__);
    printf("  컴파일 시간: %s\n", __TIME__);
    
    #ifdef __STDC__
        printf("  C 표준 준수: 예\n");
    #endif
    
    #ifdef __STDC_VERSION__
        printf("  C 표준 버전: %ld\n", __STDC_VERSION__);
    #endif
    
    printf("\n컴파일러 정보:\n");
    #ifdef __VERSION__
        printf("  컴파일러 버전: %s\n", __VERSION__);
    #endif
}

// 라인 지시자 사용
void demonstrate_line_directive(void) {
    printf("현재 라인: %d\n", __LINE__);
    
    #line 100 "special_file.c"
    printf("이제 라인: %d, 파일: %s\n", __LINE__, __FILE__);
    
    #line __LINE__ __FILE__  // 원래 상태로 복원
    printf("원래 상태로 복원됨: 라인 %d\n", __LINE__);
}

int main(void) {
    show_predefined_macros();
    printf("\n");
    demonstrate_line_directive();
    return 0;
}
```

### #error와 #warning 지시자

이러한 지시자를 사용하여 컴파일 시간에 오류나 경고를 발생시킬 수 있습니다:

```c
#include <stdio.h>

// 필수 정의 확인
#ifndef REQUIRED_DEFINITION
    #error "REQUIRED_DEFINITION이 정의되어야 합니다!"
#endif

// 버전 호환성 확인
#if __STDC_VERSION__ < 201112L
    #warning "이 코드는 C11 이상을 권장합니다"
#endif

// 플랫폼 호환성 경고
#ifndef _WIN32
    #ifndef __linux__
        #ifndef __APPLE__
            #warning "이 코드는 윈도우, 리눅스, macOS에서만 테스트되었습니다"
        #endif
    #endif
#endif

// 사용자 정의 조건 검사
#define USE_FEATURE_X 1
#define USE_FEATURE_Y 0

#if USE_FEATURE_X && USE_FEATURE_Y
    #error "FEATURE_X와 FEATURE_Y는 동시에 사용할 수 없습니다"
#endif

int main(void) {
    printf("프로그램이 정상적으로 컴파일되었습니다.\n");
    return 0;
}
```

## 실전 예제: 로깅 시스템 구현

전처리기를 활용한 실용적인 로깅 시스템을 구현해 보겠습니다:

```c
// logger.h - 로깅 시스템 헤더
#ifndef LOGGER_H
#define LOGGER_H

#include <stdio.h>
#include <time.h>

// 로그 레벨 정의
typedef enum {
    LOG_LEVEL_TRACE = 0,
    LOG_LEVEL_DEBUG,
    LOG_LEVEL_INFO,
    LOG_LEVEL_WARN,
    LOG_LEVEL_ERROR,
    LOG_LEVEL_FATAL
} LogLevel;

// 전역 로그 레벨 (기본값: INFO)
#ifndef CURRENT_LOG_LEVEL
    #define CURRENT_LOG_LEVEL LOG_LEVEL_INFO
#endif

// 로그 레벨을 문자열로 변환
static inline const char* log_level_to_string(LogLevel level) {
    switch (level) {
        case LOG_LEVEL_TRACE: return "TRACE";
        case LOG_LEVEL_DEBUG: return "DEBUG";
        case LOG_LEVEL_INFO:  return "INFO";
        case LOG_LEVEL_WARN:  return "WARN";
        case LOG_LEVEL_ERROR: return "ERROR";
        case LOG_LEVEL_FATAL: return "FATAL";
        default: return "UNKNOWN";
    }
}

// 시간 형식화
static inline void get_current_time(char* buffer, size_t size) {
    time_t now = time(NULL);
    struct tm* tm_info = localtime(&now);
    strftime(buffer, size, "%Y-%m-%d %H:%M:%S", tm_info);
}

// 기본 로그 매크로
#define LOG_BASE(level, format, ...) \
    do { \
        if (level >= CURRENT_LOG_LEVEL) { \
            char time_buffer[20]; \
            get_current_time(time_buffer, sizeof(time_buffer)); \
            fprintf(stderr, "[%s] %s %s:%d: " format "\n", \
                    time_buffer, log_level_to_string(level), \
                    __FILE__, __LINE__, ##__VA_ARGS__); \
        } \
    } while(0)

// 편의용 로그 매크로
#define LOG_TRACE(format, ...) LOG_BASE(LOG_LEVEL_TRACE, format, ##__VA_ARGS__)
#define LOG_DEBUG(format, ...) LOG_BASE(LOG_LEVEL_DEBUG, format, ##__VA_ARGS__)
#define LOG_INFO(format, ...)  LOG_BASE(LOG_LEVEL_INFO,  format, ##__VA_ARGS__)
#define LOG_WARN(format, ...)  LOG_BASE(LOG_LEVEL_WARN,  format, ##__VA_ARGS__)
#define LOG_ERROR(format, ...) LOG_BASE(LOG_LEVEL_ERROR, format, ##__VA_ARGS__)
#define LOG_FATAL(format, ...) LOG_BASE(LOG_LEVEL_FATAL, format, ##__VA_ARGS__)

// 조건부 로깅 매크로
#define LOG_IF(condition, level, format, ...) \
    do { \
        if (condition) { \
            LOG_BASE(level, format, ##__VA_ARGS__); \
        } \
    } while(0)

#endif // LOGGER_H

// main.c - 로깅 시스템 사용 예제
#include "logger.h"
#include <stdlib.h>

// 빌드 시 로그 레벨 설정 가능
// gcc -DCURRENT_LOG_LEVEL=LOG_LEVEL_DEBUG main.c -o app

double divide_numbers(double a, double b) {
    LOG_DEBUG("divide_numbers 호출: a=%.2f, b=%.2f", a, b);
    
    if (b == 0.0) {
        LOG_ERROR("0으로 나누기 시도: a=%.2f, b=%.2f", a, b);
        return 0.0;
    }
    
    double result = a / b;
    LOG_DEBUG("나눗셈 결과: %.2f", result);
    
    return result;
}

void process_data(int* data, size_t size) {
    LOG_INFO("데이터 처리 시작: 크기=%zu", size);
    
    if (data == NULL) {
        LOG_WARN("NULL 데이터 포인터 전달됨");
        return;
    }
    
    if (size == 0) {
        LOG_WARN("빈 데이터 배열");
        return;
    }
    
    LOG_TRACE("데이터 상세:");
    for (size_t i = 0; i < size && i < 5; i++) {  // 처음 5개만 출력
        LOG_TRACE("  data[%zu] = %d", i, data[i]);
    }
    
    // 데이터 처리 로직...
    LOG_INFO("데이터 처리 완료");
}

int main(void) {
    LOG_INFO("프로그램 시작");
    
    // 로그 레벨 출력
    LOG_DEBUG("현재 로그 레벨: %s", log_level_to_string(CURRENT_LOG_LEVEL));
    
    // 수학 연산 테스트
    double result = divide_numbers(10.0, 2.0);
    LOG_INFO("10.0 / 2.0 = %.2f", result);
    
    result = divide_numbers(5.0, 0.0);
    LOG_IF(result == 0.0, LOG_WARN, "나눗셈 실패 처리됨");
    
    // 데이터 처리 테스트
    int test_data[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    process_data(test_data, sizeof(test_data) / sizeof(test_data[0]));
    
    process_data(NULL, 10);  // 경고 테스트
    
    LOG_INFO("프로그램 종료");
    
    return 0;
}
```

## 전처리기 디버깅과 문제 해결

### 매크로 확장 디버깅

복잡한 매크로가 제대로 확장되는지 확인하는 방법:

```c
#include <stdio.h>

// 매크로를 문자열로 확장하는 매크로
#define STRINGIFY(x) #x
#define EXPAND_AND_STRINGIFY(x) STRINGIFY(x)

// 테스트용 복잡한 매크로
#define COMPLEX_MACRO(a, b) \
    do { \
        int temp = (a) + (b); \
        printf("합: %d\n", temp); \
        (a) = (b); \
        (b) = temp; \
    } while(0)

int main(void) {
    // 매크로 정의 출력
    printf("매크로 정의:\n");
    printf("COMPLEX_MACRO: %s\n", EXPAND_AND_STRINGIFY(COMPLEX_MACRO(a, b)));
    
    // 매크로 사용 예제
    int x = 5, y = 10;
    printf("\n매크로 실행 전: x=%d, y=%d\n", x, y);
    
    COMPLEX_MACRO(x, y);
    
    printf("매크로 실행 후: x=%d, y=%d\n", x, y);
    
    // 조건부 컴파일 디버깅
    #ifdef DEBUG_MODE
        printf("\n디버그 모드 활성화됨\n");
    #else
        printf("\n디버그 모드 비활성화됨\n");
    #endif
    
    // 빌드 시 정의된 매크로 확인
    #ifdef _WIN32
        printf("윈도우 환경에서 컴파일됨\n");
    #endif
    
    #ifdef __linux__
        printf("리눅스 환경에서 컴파일됨\n");
    #endif
    
    return 0;
}
```

### 일반적인 전처리기 문제와 해결책

```c
#include <stdio.h>

// 문제 1: 매크로 재정의
#define VALUE 10
// #define VALUE 20  // 경고: 재정의

// 해결책: 먼저 정의 해제
#undef VALUE
#define VALUE 20

// 문제 2: 중첩된 매크로 확장
#define DOUBLE(x) (2 * (x))
#define SQUARE(x) ((x) * (x))

// 예상치 못한 결과
void nested_macro_problem(void) {
    int a = 3;
    int result = DOUBLE(SQUARE(a));  // 예상: 2 * (3*3) = 18
    printf("DOUBLE(SQUARE(%d)) = %d (예상: 18)\n", a, result);
}

// 문제 3: 매크로와 함수 이름 충돌
#define max(a, b) ((a) > (b) ? (a) : (b))

// max 함수 (이름 충돌)
int max(int a, int b) {
    printf("함수 호출됨\n");
    return (a > b) ? a : b;
}

// 해결책: 매크로 해제 또는 다른 이름 사용
#undef max
// 또는 매크로 이름 변경
#define MAX_MACRO(a, b) ((a) > (b) ? (a) : (b))

int main(void) {
    printf("VALUE = %d\n", VALUE);
    
    nested_macro_problem();
    
    // 함수 호출
    printf("max(5, 3) = %d\n", max(5, 3));
    
    // 매크로 호출
    printf("MAX_MACRO(5, 3) = %d\n", MAX_MACRO(5, 3));
    
    return 0;
}
```

## 결론

전처리기는 C 언어의 강력한 기능으로, 코드의 재사성, 가독성, 유지보수성을 크게 향상시킬 수 있습니다. 효과적으로 사용하기 위한 핵심 원칙을 정리하면:

1. **적절한 도구 선택**: 단순 상수에는 `const`나 `enum`을, 복잡한 연산에는 `static inline` 함수를 고려하세요. 매크로는 텍스트 치환이라는 점을 항상 염두에 두세요.

2. **안전한 매크로 작성**: 
   - 모든 인자와 전체 표현식을 괄호로 감싸기
   - 여러 문장의 매크로는 `do { ... } while(0)` 패턴 사용
   - 부작용이 있는 인자(예: `i++`)를 피하기
   - 고유한 지역 변수 이름 사용 (예: `__temp`)

3. **조건부 컴파일의 현명한 사용**:
   - 플랫폼 의존 코드를 분리할 때 사용
   - 디버깅과 릴리즈 빌드를 구분할 때 사용
   - 기능 플래그로 코드 활성화/비활성화

4. **헤더 파일 관리**:
   - 모든 헤더 파일에 헤더 가드 포함하기
   - 포함 순서를 일관성 있게 유지하기
   - 순환 참조 피하기

5. **디버깅과 유지보수**:
   - 로깅 매크로로 디버깅 정보 추가
   - `#error`와 `#warning`으로 컴파일 타임 검사
   - 미리 정의된 매크로 활용

전처리기를 마스터하면 더 깔끔하고, 유지보수하기 쉽고, 플랫폼 독립적인 코드를 작성할 수 있습니다. 처음에는 복잡해 보일 수 있지만, 연습을 통해 자연스럽게 사용법을 익힐 수 있을 것입니다. 가장 중요한 것은 언제 어떤 전처리기 기능을 사용할지 판단하는 능력을 기르는 것입니다.