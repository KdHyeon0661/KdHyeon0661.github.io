---
layout: post
title: C - 전처리기
date: 2024-08-29 19:20:23 +0900
category: C
---
# 전처리기 지시자(Preprocessor)

## 0. 10줄 요약

```c
// 1) 매크로엔 괄호/부작용 방지 필수
#define MAX(a,b) ((a) > (b) ? (a) : (b))

// 2) 가변 매크로로 로깅
#define LOG(fmt, ...) fprintf(stderr, "[%s:%d] " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)

// 3) 조건부 컴파일
#if defined(_WIN32)
  #define OS "Windows"
#elif defined(__linux__)
  #define OS "Linux"
#else
  #define OS "Unknown"
#endif

// 4) 헤더 가드(또는 #pragma once)
#ifndef MYLIB_FOO_H
#define MYLIB_FOO_H
/* declarations */
#endif
```

---

## 1. 전처리기의 역할과 번역 단계

전처리기는 **컴파일 이전**에 소스 텍스트를 변환합니다. 핵심 작업:

- **매크로 치환** (`#define`, 함수형 매크로, 가변 매크로)
- **조건부 포함/제외** (`#if/#ifdef/#ifndef/#elif/#else/#endif`)
- **파일 포함** (`#include`)
- **라인 제어/진단** (`#line`, `#error`, 일부 컴파일러의 `#warning`)
- **컴파일러별 지시** (`#pragma`, `_Pragma`)

> 참고: C 번역 단계(요지) — **문자 처리 → 백슬래시-개행 접합 → 토큰화/주석 제거 → 전처리 → 컴파일** … 의 순서로 진행됩니다.

---

## 2. 핵심 지시자 빠른 표

| 지시자 | 목적 | 비고 |
|---|---|---|
| `#define` | 매크로/상수 정의 | 함수형/가변/문자열화/토큰결합 |
| `#undef` | 매크로 해제 | 재정의 전 클린업 |
| `#include` | 파일 포함 | `<...>` vs `"..."` |
| `#if/#elif/#else/#endif` | 조건부 컴파일(상수식) | `defined(NAME)` 사용 |
| `#ifdef/#ifndef` | 매크로 정의 여부 분기 | 가독성↑ |
| `#error` | 컴파일 중단(메시지) | 구성 오류 강제 |
| `#line` | 파일/라인 정보 재지정 | 진단/생성 코드 |
| `#pragma` / `_Pragma` | 컴파일러 제어 | 이식성 주의 |
| `#pragma once` | 단일 포함 | 비표준(사실상 널리 지원) |

---

## 3. `#define` — 리터럴/함수형/안전 래핑

### 3.1 단순 상수/식
```c
#define PI 3.14159265358979323846
#define KB (1024u)
#define ALIGN4(x) (((x) + 3u) & ~3u)
```

- **괄호**로 우선순위/결합을 보호하세요.
- 타입이 필요하면 **`const` 또는 `enum`**이 더 안전할 수 있습니다.

### 3.2 함수형 매크로 — **부작용 방지**
```c
#define MAX(a,b) ((a) > (b) ? (a) : (b))   // 괄호 필수
#define SQR(x) ((x) * (x))                 // SQR(i++)는 위험!
```
- 인자가 **여러 번 평가**됩니다 → `i++` 같은 부작용 인자 사용 금지.
- 대체안: **`static inline` 함수** (아래 §10).

### 3.3 안전한 멀티문 매크로 — `do { ... } while(0)`
```c
#define SWAP_INT(a,b) do { int _t=(a); (a)=(b); (b)=_t; } while(0)
```
- 단일 문맥에서 **세미콜론 1개**로 깔끔하게 사용 가능.

### 3.4 문자열화(`#`) / 토큰 결합(`##`)
```c
#define STR(x) #x
#define CONCAT(a,b) a##b

printf("%s\n", STR(hello world)); // -> "hello world"

int xy = 42;
printf("%d\n", CONCAT(x, y));     // -> xy
```

### 3.5 가변 매크로(`__VA_ARGS__`) — C99
```c
#include <stdio.h>
#define LOG_INFO(fmt, ...)  fprintf(stdout, "[I] " fmt "\n", ##__VA_ARGS__)
#define LOG_ERR(fmt, ...)   fprintf(stderr, "[E] " fmt "\n", ##__VA_ARGS__)

LOG_INFO("start");
LOG_ERR("failed: code=%d", 13);
```
- GNU/MSVC는 인자 없을 때의 콤마를 처리하기 위해 `##__VA_ARGS__`를 허용(확장).  
  이식성을 높이려면 **빈 인자 호출을 피하거나** 별도 분기 매크로를 두세요.

### 3.6 줄 계속(라인 컨티뉴에이션)
```c
#define BIG(EXPR) \
    do {          \
        if (EXPR) \
            puts("big"); \
    } while(0)
```
- 매크로 정의에서 **역슬래시+개행**으로 한 줄로 이어집니다.

---

## 4. `#undef` — 재정의/정리

```c
#define PI 3.14
#undef PI
#define PI 3.1415926535
```

- 외부 헤더의 충돌 회피 시, **정말 필요한 최소 범위**에서만 사용하세요.

---

## 5. `#include` — 검색 규칙과 조직화

```c
#include <stdio.h>     // 시스템/표준 헤더 검색 경로
#include "myutils.h"   // 현재 디렉터리 → 추가 경로(-I) → 시스템
```

- 빌드 플래그 `-I include/` 로 사용자 헤더 경로를 설정.
- **포함 순서 권장**: 자신의 헤더 → 표준 헤더 → 외부 라이브러리 → 내부 다른 헤더.  
  자신의 구현 파일이 자신의 헤더를 **가장 먼저** 포함하면 선언/정의 불일치를 조기에 발견할 수 있습니다.

---

## 6. 조건부 컴파일 — `#if/#ifdef/#ifndef`

### 6.1 정의 여부 분기
```c
#define DEBUG

#ifdef DEBUG
  #define DBG(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DBG(...)
#endif
```

### 6.2 정수 상수식/`defined` 연산자
```c
#if defined(_WIN32) && !defined(_WIN64)
  #define PLATFORM "Win32"
#elif defined(_WIN64)
  #define PLATFORM "Win64"
#elif defined(__APPLE__) && defined(__MACH__)
  #define PLATFORM "macOS"
#elif defined(__linux__)
  #define PLATFORM "Linux"
#else
  #define PLATFORM "Unknown"
#endif
```

### 6.3 버전/특성 토글
```c
#define LIB_VERSION 200  // 2.00

#if LIB_VERSION >= 200
  void feature_v2(void);
#else
  void feature_v1(void);
#endif
```

> **빌드 플래그와 함께**: `gcc -DLIB_VERSION=200 -DDEBUG ...`

---

## 7. 헤더 가드와 `#pragma once`

### 7.1 전통 가드(권장)
```c
#ifndef MYLIB_HASHSET_H
#define MYLIB_HASHSET_H
/* declarations */
#endif
```

- 장점: **표준/이식성 최고**.  
- 네이밍: `PROJECT_PATH_FILENAME_H` 식으로 **충돌 방지**.

### 7.2 `#pragma once` (사실상 대부분 지원)
```c
#pragma once
/* declarations */
```
- 간결하지만 **비표준**. 일부 툴체인/특수 파일시스템에서 캐시 혼란 사례 보고가 있으니 **대형/이식성 최우선 프로젝트**는 가드를 선호합니다.

---

## 8. 사전정의 매크로와 진단

### 8.1 흔한 사전정의
```c
printf("%s:%d %s %s\n", __FILE__, __LINE__, __DATE__, __TIME__);
```
- `__FILE__`(문자열), `__LINE__`(정수), `__DATE__/__TIME__`(컴파일 시각), `__func__`(C99 함수명).

### 8.2 강제 실패/경고
```c
#if !defined(REQUIRED_FEATURE)
  #error "REQUIRED_FEATURE not defined"
#endif
```
- 일부 컴파일러는 `#warning "msg"` 지원(GCC/Clang). 표준은 아님.

### 8.3 라인/파일 재지정
```c
#line 100 "generated.c"
```
- 생성 코드에서 진단 위치를 조정할 때 사용.

---

## 9. `_Pragma`와 `#pragma` — 컴파일러 지시

- 표준은 **`_Pragma("...")`** 연산자 제공(문맥 내 사용 가능).  
  예: `_Pragma("GCC diagnostic push")`.
- 전통 `#pragma`는 라인 시작에서만.

### 9.1 예시(주의: 이식성 검토)
```c
#pragma once                    // 단일 포함
#pragma pack(push, 1)           // 구조체 패킹(ABI 영향, 신중)
struct Packed { char c; int x; };
#pragma pack(pop)

// 진단 제어(GCC/Clang)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
static void f(int unused) {}
#pragma GCC diagnostic pop
```

> **프라그마는 컴파일러 의존**이므로, 필요 최소한/플랫폼 분기로 사용하세요.

---

## 10. 매크로 vs `static inline` — 안전 대안

부작용/타입 안전성이 필요하면 **매크로 대신 `static inline` 함수**:

```c
// 헤더에 배치 권장
static inline int max_i(int a, int b){ return a > b ? a : b; }
static inline size_t align_up(size_t x, size_t a){ return (x + (a-1)) & ~(a-1); }
```

- 장점: **단일 평가**, 타입 검사, 디버깅 용이.
- 최적화 시 인라인 확률 높음(특히 O2 이상).

---

## 11. 로깅/트레이스 — 가변 매크로 실전

```c
#include <stdio.h>

#if !defined(LOG_LEVEL)
  #define LOG_LEVEL 2    // 0=NONE,1=ERR,2=INFO,3=DBG
#endif

#define LOG_BASE(lv, tag, fmt, ...) \
  do { if ((lv) <= LOG_LEVEL) \
    fprintf(stderr, "[%s] %s:%d: " fmt "\n", tag, __FILE__, __LINE__, ##__VA_ARGS__); } while(0)

#define LOG_ERR(...)  LOG_BASE(1, "ERR", __VA_ARGS__)
#define LOG_INFO(...) LOG_BASE(2, "INF", __VA_ARGS__)
#define LOG_DBG(...)  LOG_BASE(3, "DBG", __VA_ARGS__)
```

- 빌드 시 레벨 제어: `gcc -DLOG_LEVEL=3 ...`

---

## 12. 플랫폼/컴파일러 감지 매크로 모음

```c
#if defined(_MSC_VER)       // MSVC
  #define COMPILER "MSVC"
#elif defined(__clang__)    // Clang
  #define COMPILER "Clang"
#elif defined(__GNUC__)     // GCC (Clang도 __GNUC__ 정의하므로 순서 유의)
  #define COMPILER "GCC"
#else
  #define COMPILER "Unknown"
#endif

#if defined(_WIN32) || defined(_WIN64)
  #define OS_WINDOWS 1
#elif defined(__APPLE__) && defined(__MACH__)
  #define OS_MACOS 1
#elif defined(__linux__)
  #define OS_LINUX 1
#endif
```

- **순서**가 중요합니다(Clang은 `__GNUC__`도 정의).

---

## 13. 전처리 `#if`의 상수식 규칙

- `#if` 식은 **정수 상수식**이어야 하며, **sizeof/typeof** 같은 것은 사용할 수 없습니다(표준).  
- 사용 가능한 연산: 산술/비트/논리/관계/삼항/괄호 및 `defined` 연산자.

$$
\texttt{\#if}\ \text{정수상수식} \quad\Rightarrow\quad \{0 \Rightarrow false, \neq 0 \Rightarrow true\}
$$

예:
```c
#define MAJOR 1
#define MINOR 4
#if (MAJOR*100 + MINOR) >= 104
  /* code */
#endif
```

---

## 14. 헤더-온리 유틸 설계 팁

- **상태 없는 작은 유틸**은 `static inline` + 내부 `#if` 분기로 헤더-온리화.
- 라이브러리 옵션/플래그를 `#ifndef` 기본값 + `-D` 오버라이드로 제공.
- 공개 헤더 안에서 **플랫폼별 구현 분기**는 최소화하고, 가능하면 **플랫폼별 .c**로 분리.

---

## 15. 예제 1 — 안전한 컨테이너 초기화 매크로

```c
// vec.h
#ifndef VEC_H
#define VEC_H
#include <stdlib.h>
#include <string.h>

typedef struct { void* data; size_t len, cap, elem; } vec;

#define VEC_INIT(v, T) do {             \
    (v).data = NULL; (v).len = 0;       \
    (v).cap = 0;  (v).elem = sizeof(T); \
} while(0)

static inline int vec_reserve(vec* v, size_t need){
    if (need <= v->cap) return 0;
    size_t cap = v->cap ? v->cap * 2 : 8;
    while (cap < need) cap *= 2;
    void* p = realloc(v->data, cap * v->elem);
    if (!p) return -1;
    v->data = p; v->cap = cap; return 0;
}

#define VEC_PUSH(v, val) do {                       \
    if (vec_reserve(&(v), (v).len + 1)) break;      \
    memcpy((char*)(v).data + (v).len*(v).elem, &(val), (v).elem); \
    (v).len++;                                      \
} while(0)

#endif
```

- **초기화는 매크로**, **성장 로직은 `static inline`**로 분리해 안전성과 성능을 겸비.

---

## 16. 예제 2 — 빌드 플래그로 기능 토글

```c
// feature.h
#ifndef FEATURE_H
#define FEATURE_H

#ifndef ENABLE_TLS
  #define ENABLE_TLS 0
#endif

#if ENABLE_TLS
  int tls_connect(const char* host, int port);
#else
  static inline int tls_connect(const char* host, int port){ (void)host; (void)port; return -1; }
#endif

#endif
```

빌드:
```bash
# TLS 비활성(기본)
gcc main.c -o app
# TLS 활성
gcc -DENABLE_TLS=1 main.c -o app
```

---

## 17. 실수/함정 체크리스트

- [ ] **함수형 매크로 인자**는 **항상 괄호**로 감싼다: `((x) + (y))`.
- [ ] 부작용 인자(`i++`)를 **매크로에 넘기지 않는다**.
- [ ] 멀티문 매크로엔 **`do{...}while(0)`** 패턴.
- [ ] **전역 상수**는 매크로 대신 `const`/`enum` 검토.
- [ ] 조건부 컴파일에 **`defined(NAME)`** 사용, `#if NAME`는 위험.
- [ ] **자신의 헤더를 구현 파일 최상단**에서 먼저 포함.
- [ ] `#pragma`는 **필요 최소한/플랫폼 분기**와 함께.
- [ ] `#include` 순환의심 시 **전방선언**으로 의존 제거.
- [ ] **빌드 플래그**(`-DNAME=VAL`)로 설정 값 주입 → 코드 하드코딩 방지.
- [ ] 사전정의 매크로(`__FILE__`, `__LINE__`)를 **로깅/디버깅**에 적극 활용.

---

## 18. 수식으로 보는 매크로 재평가 위험

함수형 매크로 `F(x)`가 인자 `x`를 $$k$$ 번 사용한다면,  
인자 평가 비용은 **원래 비용 × $$k$$** 로 증가합니다.  
따라서  
$$
\mathrm{cost}(F(x)) \approx k \cdot \mathrm{cost}(x)
$$
→ **부작용/고비용 인자**는 매크로에 넣지 않는 것이 안전합니다.

---

## 19. 마무리 요약

| 주제 | 핵심 |
|---|---|
| 매크로 기본 | 괄호/부작용 금지, `do{ }while(0)` |
| 고급 매크로 | 문자열화 `#`, 토큰결합 `##`, 가변 `__VA_ARGS__` |
| 조건부 컴파일 | `defined`/상수식, 빌드 플래그 `-D` |
| 헤더 포함 | `<...>` vs `"..."`, 검색 경로/순서 |
| 가드 | 전통 가드(표준) vs `#pragma once`(간결) |
| 프라그마 | 편하지만 **비표준**—필요 최소/플랫폼 분기 |
| 사전정의 | `__FILE__/__LINE__/__DATE__/__TIME__/__func__` |
| 안전 대안 | `static inline`로 타입/단일평가 보장 |