---
layout: post
title: MFC - 플러그인 구조
date: 2025-09-17 15:25:23 +0900
category: MFC
---
# 플러그인 구조(모듈 검색/로드/버전 관리) **개념과 실전** — Win32/MFC C++ 기준 끝장 가이드

> “핵심은 **안정적 ABI(이진 인터페이스)**, **버전 협상**, **안전한 로드/언로드**입니다.”  
> 이 글은 MFC/Win32 C++ 환경에서 쓸 수 있는 **플러그인(확장 모듈) 아키텍처**를 **검색 → 로드 → 등록 → 버전/의존성 관리 → 수명 → 보안 → 장애 복구**까지 **예제 위주**로 총정리합니다.

---

## 0) 큰 그림과 목표

- **목표**
  - 앱 재시작 없이 기능 추가/교체(핫플러그 가능까지는 선택).
  - **안정적인 ABI**로 **다른 팀/외부 제작자**가 작성해도 로드 가능.
  - **버전 협상**(호스트↔플러그인), **의존성**(다른 플러그인/런타임) 체크.
  - **보안/안정성**: DLL 하이재킹 방지, 서명 확인, 크래시 격리/복구.
  - **테스트/배포**: 샌드박스 로더, 마켓/업데이트 경로 설계.

- **디자인 선택지**
  1) **C ABI(함수 포인터 테이블)** + C++ 래퍼 (가장 안전, 컴파일러/RTTI 불요)
  2) **COM(클래식/ATL)** (자체 버전/바이너리 안정성 제공)
  3) **IPC(out-of-proc)** (프로세스 분리로 호스트 안정성↑, 복잡도↑)

> 본문은 **C ABI + 래퍼**를 기본축으로 설명하고, 후반에 COM/Out-of-proc 대안도 함께 정리합니다.

---

## 1) 폴더/매니페스트/검색 규칙

### 1-1. 폴더 레이아웃(권장)
```
App.exe
plugins\
  foo\
    foo.dll
    plugin.json
    locales\
      ko-KR.json
  bar\
    bin\
      bar.dll
    plugin.json
```

### 1-2. 매니페스트 예( `plugin.json`)
```json
{
  "id": "com.acme.foo",
  "name": "Foo Tools",
  "version": "1.2.3",
  "entry": "foo.dll",
  "minHost": "2.0.0",
  "apis": ["draw.v1", "script.v2"],
  "capabilities": ["image.read", "image.write:png"],
  "dependencies": [
    {"id":"com.acme.base", "version": "^3.1.0"}
  ],
  "os": {"arch": "x64", "minBuild": 19041},
  "signature": "optional-code-signing-or-hash"
}
```

### 1-3. 검색 규칙
- 기본 검색 루트: `App\plugins\**\plugin.json`
- **`std::filesystem`** 로 재귀 탐색, JSON 파싱 → 후보 리스트 생성
- **호스트 버전/OS/아키텍처** 필터링 → **의존성/중복** 해결 후 로드 순서 결정

```cpp
// PluginDiscovery.h
struct PluginManifest {
    std::wstring id, name, version, entry;
    std::wstring minHost;
    std::vector<std::wstring> apis, capabilities;
    struct Dep { std::wstring id, versionReq; };
    std::vector<Dep> deps;
    std::wstring folder;
};

std::vector<PluginManifest> DiscoverPlugins(const std::wstring& root);
```

```cpp
// PluginDiscovery.cpp (요약)
#include <filesystem>
#include <fstream>
#include <codecvt>
#include <optional>

static std::optional<PluginManifest> LoadManifest(const std::filesystem::path& jsonPath);

std::vector<PluginManifest> DiscoverPlugins(const std::wstring& root) {
    std::vector<PluginManifest> out;
    for (auto& p : std::filesystem::recursive_directory_iterator(root)) {
        if (p.path().filename() == L"plugin.json") {
            if (auto m = LoadManifest(p.path())) {
                // 기본 필터: 아키텍처/OS/호스트 버전은 이후 단계에서 추가 체크
                out.push_back(std::move(*m));
            }
        }
    }
    return out;
}
```

> JSON 파서는 사내 공용(예: `rapidjson`, `nlohmann/json`) 또는 간단 파서를 사용하세요.

---

## 2) ABI(이진 인터페이스) 설계 — C 함수 테이블 + 버전 협상

### 2-1. 공용 헤더(호스트/플러그인이 공유)

```cpp
// plugin_api.h  (배포용, ABI 안정)
// C ABI 보존을 위해 extern "C" 와 POD 구조만 사용
#pragma once
#include <stdint.h>
#ifdef _WIN32
  #define PLUG_API __cdecl     // 호출규약 고정
#else
  #define PLUG_API
#endif

// Semantic Versioning 구조체
typedef struct {
    uint16_t major;
    uint16_t minor;
    uint16_t patch;
} PlugSemVer;

typedef struct {
    const char* id;         // "com.acme.foo"
    const char* name;       // "Foo Tools"
    PlugSemVer  version;    // 1.2.3
    const char* build;      // 빌드 SHA 등(옵션)
} PlugInfo;

// 로깅/메모리/스케줄링 등 호스트 서비스 포인터
typedef void (PLUG_API *PFN_Log)(int level, const char* msg);
typedef void* (PLUG_API *PFN_Alloc)(size_t);
typedef void  (PLUG_API *PFN_Free)(void*);
typedef void  (PLUG_API *PFN_PostUI)(void(*fn)(void*), void* user);

typedef struct {
    PlugSemVer hostVer;     // 호스트 버전
    PFN_Log    log;
    PFN_Alloc  alloc;
    PFN_Free   free;
    PFN_PostUI postUI;
} HostServices;

// 수명/기능 엔트리
typedef int  (PLUG_API *PFN_OnLoad)(const HostServices* host, const PlugInfo** outInfo);
typedef void (PLUG_API *PFN_OnUnload)(void);
// 선택 기능(예: 이미지 핸들러)
typedef int  (PLUG_API *PFN_CanHandle)(const char* ext);
typedef int  (PLUG_API *PFN_ProcessFile)(const char* path);

// 플러그인 Export 테이블 v1
typedef struct {
    PlugSemVer  apiVer;   // 이 테이블의 버전
    PFN_OnLoad  onLoad;
    PFN_OnUnload onUnload;
    // 기능 포인터(옵셔널은 NULL 가능)
    PFN_CanHandle canHandle;
    PFN_ProcessFile processFile;
} PluginExports_v1;

// 표준 심볼 이름
#define PLUGIN_GET_EXPORTS_NAME "Plugin_GetExports"

// Export 함수 시그니처
typedef int (PLUG_API *PFN_PluginGetExports)(PluginExports_v1* out, size_t bytes);
```

> **핵심**  
> - **C ABI**(호출규약/정적 크기)만 사용 → 컴파일러/표준라이브러리 차이 최소.  
> - `PluginExports_v1` 처럼 **버전 넘버**를 **구조체 첫 필드**에 둬서 **확장** 여지 확보.  
> - 새 기능은 `PluginExports_v2` 확장 구조체로 추가 → 호스트는 버전 협상.

### 2-2. 버전 협상 로직(호스트 측)
```cpp
// Loader.cpp (요약)
bool LoadPlugin(const PluginManifest& m, HostServices* host) {
    // LoadLibrary + GetProcAddress
    HMODULE h = ::LoadLibraryW((m.folder + L"\\" + m.entry).c_str());
    if (!h) return false;

    auto sym = (PFN_PluginGetExports)::GetProcAddress(h, PLUGIN_GET_EXPORTS_NAME);
    if (!sym) { ::FreeLibrary(h); return false; }

    PluginExports_v1 ex{};
    ex.apiVer = {1,0,0}; // 우리가 기대하는 최소 v1
    if (!sym(&ex, sizeof(ex))) { ::FreeLibrary(h); return false; }

    // API 버전 협상
    if (ex.apiVer.major != 1) { ::FreeLibrary(h); return false; } // 메이저 다르면 거절

    const PlugInfo* info = nullptr;
    if (ex.onLoad) {
        int ok = ex.onLoad(host, &info);
        if (!ok) { ::FreeLibrary(h); return false; }
    }

    // 등록(리스트/맵)에 보관
    // ex.onUnload, ex.canHandle, ex.processFile … 핸들로 래핑
    // h (HMODULE)도 멤버로 저장

    return true;
}
```

> **메이저 버전**이 다르면 **거절**(하위호환 불가). 미너/패치는 **허용**하고 기능은 **널체크**로 선택 사용.

---

## 3) DLL 로딩 안전 가이드(하이재킹 방지/검색 경로 제어)

- **SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_… )** 사용
- **AddDllDirectory** 로 `plugins\foo\bin` 같은 **전용 디렉터리**만 허용
- **절대경로 LoadLibraryEx** + `LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS`
- **Manifest**: `UseSafeDllSearchMode` 기본 on (현대 OS 기본)

```cpp
// DllPathGuard.h
struct DllPathGuard {
    DllPathGuard(const std::wstring& dir) {
        SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
        cookie = AddDllDirectory(dir.c_str());
    }
    ~DllPathGuard() { if (cookie) RemoveDllDirectory(cookie); }
    DLL_DIRECTORY_COOKIE cookie{};
};
```

```cpp
// 사용
auto plugDir = std::filesystem::path(m.folder);
DllPathGuard guard(plugDir.c_str());
HMODULE h = LoadLibraryExW((plugDir / m.entry).c_str(), nullptr,
    LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
```

> 이 설정만으로도 **현재 작업 디렉터리/임의 경로 DLL 하이재킹** 위험이 크게 줄어듭니다.

---

## 4) 디지털 서명/무결성(선택적이지만 강력 추천)

- `WinVerifyTrust`로 **서명 검증**(기업 내부 CA/공개 인증서)
- **SHA-256 해시**를 `plugin.json`의 `signature` 필드와 비교(간이 무결성)
- **차단 목록**(revoked IDs/해시) 관리

```cpp
bool VerifySignature(const std::filesystem::path& dllPath);
bool VerifyHash(const std::filesystem::path& dllPath, const std::string& hexSha256);
```

> 배포 채널(플러그인 스토어/내부 저장소)와 연계해 **자동 업데이트** 시 안전성 보장.

---

## 5) 의존성/로드 순서: DAG(유향 비순환 그래프) 정렬

- 각 매니페스트의 `dependencies[]`를 노드/에지로 구성
- **토폴로지 정렬** → **의존 대상 먼저 로드**
- 버전 요구(`^3.1.0` 등 SemVer 범위) 만족 검사

```cpp
// Pseudo
auto manifests = DiscoverPlugins(root);
auto graph = BuildDepGraph(manifests);
auto sorted = TopologicalSort(graph); // 사이클 있으면 거절
for (auto& id : sorted) {
  auto& m = FindManifest(id);
  if (SatisfyVersion(m)) LoadPlugin(m, host);
}
```

> **런타임 의존성**(ex. `zlib1.dll`)은 별도 `bin` 폴더에 두고 `AddDllDirectory`로 해결.

---

## 6) 수명 주기와 상태

- **Load**: `onLoad(host, &info)` → 성공 시 등록
- **Start/Stop**: 필요하면 `onStart() / onStop()` 추가(호스트가 노출)
- **Unload**: `onUnload()` 호출 후 `FreeLibrary`
- **Hot reload**(선택): `FreeLibrary` 직후 파일 교체, 다시 Load.  
  - 주의: **스레드 정리/리소스 해제**가 100% 되어야 깨끗하게 언로드 가능.

> 실무에서는 **언로드 금지**(process lifetime 유지)가 안정적일 때도 많습니다. 업데이트 시 **프로세스 재시작**을 UX로 보완.

---

## 7) 호스트 서비스(콜백)과 로깅/메모리/스케줄

```cpp
// 호스트 초기화 시 제공
HostServices host{
  {2,1,0}, // hostVer 2.1.0
  [](int lv, const char* m){ /* 로그 라우팅 */ },
  [](size_t n){ return ::malloc(n); },
  [](void* p){ ::free(p); },
  [](void(*fn)(void*), void* u){ PostMessageW(g_hMainWnd, WM_APP+100, (WPARAM)fn, (LPARAM)u); }
};
```

플러그인은 **호스트 서비스에만 의존**(표준라이브러리/런타임 혼선 최소).

---

## 8) 샘플 플러그인 DLL (최소 구현)

```cpp
// foo_plugin.cpp  (빌드: /MD, 동일 툴체인 권장 but C ABI만 의존)
#include "plugin_api.h"
#include <string.h>

static PlugInfo g_info{ "com.acme.foo", "Foo Tools", {1,2,3}, "b1234" };
static HostServices g_host{};

static int PLUG_API Foo_OnLoad(const HostServices* host, const PlugInfo** outInfo) {
    g_host = *host;
    g_host.log(1, "[foo] onLoad");
    *outInfo = &g_info;
    return 1;
}
static void PLUG_API Foo_OnUnload(void) {
    g_host.log(1, "[foo] onUnload");
}
static int PLUG_API Foo_CanHandle(const char* ext) {
    return _stricmp(ext, "png")==0 ? 1 : 0;
}
static int PLUG_API Foo_ProcessFile(const char* path) {
    g_host.log(1, "[foo] processFile");
    // ... 처리 ...
    return 1;
}

extern "C" __declspec(dllexport)
int PLUG_API Plugin_GetExports(PluginExports_v1* out, size_t bytes) {
    if (!out || bytes < sizeof(PluginExports_v1)) return 0;
    out->apiVer = {1,0,0};
    out->onLoad = &Foo_OnLoad;
    out->onUnload = &Foo_OnUnload;
    out->canHandle = &Foo_CanHandle;
    out->processFile = &Foo_ProcessFile;
    return 1;
}
```

---

## 9) 호스트 래핑: C++ 친화 어댑터

```cpp
struct Plugin {
    HMODULE h{};
    PluginExports_v1 ex{};
    PlugInfo info{};
    std::wstring id, path;
    bool process(const std::wstring& file) {
        if (!ex.processFile) return false;
        std::string u8 = /* 변환 */ std::string();
        return !!ex.processFile(u8.c_str());
    }
};
```

> C ABI는 바깥에 두고, **호스트 내부에서는 C++ 래퍼**로 다루면 코드가 깔끔합니다.

---

## 10) 충돌/중복/우선순위

- 같은 `id`를 가진 플러그인이 여러 버전이면 **최신 SemVer 만족** 우선
- **우선순위** 필드(숫자)로 tie-break
- **기능 충돌**(동일 확장자 처리자 다수) 시 **체인** or **사용자 선택** UI

---

## 11) 구성/설정(플러그인별)

- `AppData\Vendor\App\plugins\com.acme.foo\settings.json`
- 호스트가 경로 제공(HostServices에 `getConfigPath` 콜백 추가 가능)
- 공용 UI(Options)에서 **플러그인 탭** 제공 → 활성/비활성/우선순위/업데이트

---

## 12) 스레딩/성능/로딩 최적화

- **지연 로드**: 앱 시작 시 매니페스트만 스캔 → 실제 호출 필요할 때 `LoadLibrary`
- **병렬 탐색**: `std::async`/스레드풀로 파일 시스템 스캔
- **Warm-up**: 드문 초기화 비용은 플러그인 자체의 `onLoad`가 아닌 첫 사용 시 수행
- **메모리**: 큰 리소스는 **호스트의 Alloc/Free** 사용(한곳에서 추적/통계)

---

## 13) 오류/크래시 방어

- `onLoad` 실패 시 **블랙리스트**(재시도 제한)
- **SEH**(Structured Exception Handling) 경계:
  - 플러그인 호출 전 `__try { … } __except(...) { … }` 로 보호(선택)
- 크래시/예외 시:
  - 해당 플러그인 **격리 비활성화** + 사용자에게 **안내**
  - 다음 실행 시 **세이프모드**(플러그인 미로드) 옵션 제공

> 진짜 안정성이 필요하면 **Out-of-proc(별도 프로세스)** 으로 격리 → IPC로 통신 (섹션 17 참고).

---

## 14) 업데이트/버전 관리 전략

- **SemVer**: `MAJOR.MINOR.PATCH`
  - **MAJOR** 증가 시 **호환성 파괴** 가능
  - **MINOR/PATCH**는 기능 추가/버그수정(하위호환)
- 호스트의 **minHost** 비교: `plugin.minHost ≤ host.version` 여부
- 자동 업데이트:
  - 플러그인 저장소(사내/공개)에서 목록/서명된 패키지 다운로드
  - 다운로드 후 **임시 폴더**에 배치, **검증 성공 → 배치 교체**
- 롤백: 이전 버전을 **보관**(N개), 실패 시 자동 복귀

---

## 15) 로깅/진단/원격 지원

- 각 플러그인 로드/언로드/호출 실패/예외를 **채널별 로그**로 구분
- `PlugInfo.id` 기반으로 통계/성능(처리시간) 수집
- 사용자 보고(“문제가 발생한 플러그인 비활성화”) UX

---

## 16) 샌드박스 로더(테스트 툴)

- 호스트 없이도 플러그인 DLL을 테스트:
  - 가짜 `HostServices` 제공
  - `Plugin_GetExports` 호출 → smoke test
  - `processFile`를 더미 입력으로 실행, 리소스 누수 체크

```cpp
int main() {
    HostServices stub{ {2,0,0}, [](int, const char* m){ printf("%s\n", m); }, malloc, free,
        [](void(*f)(void*), void* u){ f(u); } };
    // DLL 경로 인자로 받아 테스트
}
```

---

## 17) Out-of-proc(프로세스 외부) 플러그인(옵션)

**장점**
- 플러그인 크래시가 호스트를 죽이지 않음
- 권한/보안 경계(저권한 프로세스에서 실행)

**방법**
- 플러그인 호스트(EXE)를 **서브프로세스**로 실행
- 통신: **Named Pipe / RPC / COM Local Server**
- ABI는 **IPC 프로토콜**로 바뀜(메시지/버전 협상)
- 성능 비용: marshaling/컨텍스트 스위치 (대형 데이터는 **쉐어드 메모리** 병행)

> 고가용성/보안 요구가 높다면, 가장 현실적인 선택.

---

## 18) COM 기반 대안(간단 스케치)

- **IClassFactory**/`DllGetClassObject`로 CoCreateInstance
- **인터페이스 UUID**가 **버전/바이너리 안정성** 제공
- 단점: 학습/보일러플레이트/레지스트리 등록 부담
- 장점: 언어 간 상호운용/툴링/자동 프록시/스텁
- 최신 Windows에선 **레지스트리리스 COM**(Manifest 기반)도 가능

---

## 19) 국제화/리소스/아이콘

- 플러그인 폴더의 `locales/*` 또는 **위성 DLL**(MUI) 사용
- 호스트가 `HostServices`로 `getString(id, locale)` 같은 헬퍼 제공 가능
- 아이콘/이미지는 **플러그인 DLL 리소스** 또는 폴더 파일

---

## 20) 예제: 이미지 핸들러 체인

- 여러 플러그인이 `image.read` capability를 주장
- 호스트가 **확장자/마임** 기반으로 **우선순위**에 맞게 플러그인 선택
- 실패 시 다음 후보로 **폴백 체인**

```cpp
bool OpenImage(const std::wstring& path) {
    auto ext = ToLower(GetExt(path));
    for (auto& p : imagePlugins) {
        if (p.ex.canHandle && p.ex.canHandle(ToUTF8(ext).c_str())) {
            if (p.ex.processFile && p.ex.processFile(ToUTF8(path).c_str())) return true;
        }
    }
    return false;
}
```

---

## 21) 보안 체크리스트(요약)

- [ ] `SetDefaultDllDirectories` + `AddDllDirectory`
- [ ] 절대경로 + 제한적 Load Flags
- [ ] 디지털 서명/해시 검증
- [ ] 블랙리스트/차단 목록
- [ ] Sandbox(out-of-proc) 옵션
- [ ] 플러그인 설정/파일 접근은 **호스트 경유**(직접 경로 노출 최소)
- [ ] 네트워크 접근 정책(프록시/차단)
- [ ] 민감 API(키보드 훅 등) 사용 감시/승인

---

## 22) 운영/배포

- 플러그인 패키지: `.zip`(서명 포함) → 설치 시 `plugins\id\version\...` 로 확장
- 삭제/업데이트는 **폴더 통째로 이동/교체**
- **콘솔 도구**: `app.exe --plugins list/verify/update`
- 사내 마켓 서버: `GET /plugins`, `GET /plugins/{id}/versions`

---

## 23) 문서/가이드(제작자용 템플릿)

- `plugin_api.h` + 샘플 프로젝트
- **체크리스트**: API 버전, 스레드 규약, 메모리 소유권, 오류코드
- 샌드박스 로더와 **CI 파이프라인**에서 **연기 테스트(smoke)** 자동화

---

## 24) 실전용 코드 스니펫 모음

### 24-1. SemVer 비교
```cpp
struct SemVer { int M,m,p; };
bool IsCompatible(const SemVer& need, const SemVer& have) {
    // need <= have (메이저 같아야 하위호환 가정)
    if (need.M != have.M) return false;
    if (have.m < need.m) return false;
    if (have.m == need.m && have.p < need.p) return false;
    return true;
}
```

### 24-2. 토폴로지 정렬(간략)
```cpp
std::vector<std::string> TopoSort(
  const std::unordered_map<std::string,std::vector<std::string>>& g);
```

### 24-3. 매니페스트 파싱(요약)
```cpp
PluginManifest ParseJson(const std::string& js);
bool SatisfyHost(const PluginManifest& m, const SemVer& host);
bool SatisfyDeps(const PluginManifest& m,
                 const std::unordered_map<std::string,SemVer>& chosen);
```

---

## 25) “가볍게 시작하기” 로드맵

1. **C ABI 테이블**(`plugin_api.h`) 고정 → 샘플 DLL/로더 구현  
2. `plugins\**\plugin.json` **탐색/검증/로그**부터  
3. **의존성/토폴로지**는 간단히(사실상 **로드 순서만** 우선)  
4. **서명/해시/경로보안** 점진 도입  
5. **크래시 방어**(SEH/블랙리스트) → 필요 시 **out-of-proc**  
6. **자동 업데이트**/롤백 → 운영 도구 준비  
7. **문서/템플릿** 배포 → 생태계 확장

---

## 26) FAQ

- **Q. C++ 인터페이스(vtable)로 안 되나요?**  
  A. 툴체인/컴파일러 차이, RTTI/예외/표준라이브러리 종속 위험이 커집니다.  
  **C ABI** + 얇은 C++ 래퍼가 **가장 안전**합니다. (COM은 또 다른 선택지)

- **Q. 언로드는 반드시 지원해야 하나요?**  
  A. 아니요. 많은 상용 앱이 **언로드 금지**(메모리 누수 방지)로 안정성·복잡도 비용을 낮춥니다.

- **Q. 플러그인이 다른 플러그인을 불러야 하면?**  
  A. **capabilities/서비스 레지스트리**를 통해 **호스트를 경유**하세요. 플러그인끼리 직접 링크는 의존성 지옥을 부릅니다.

---

## 27) 체크리스트(최종 요약)

- [ ] **C ABI Export 테이블** + **버전 협상**
- [ ] **Manifest**(id, semver, minHost, deps, caps)
- [ ] **검색/검증/토폴로지 정렬**
- [ ] **LoadLibraryEx** + 안전한 DLL 디렉터리
- [ ] **서명/해시 검증**(선택 아님: 실무 권장)
- [ ] **호스트 서비스**(로그/메모리/스케줄)
- [ ] **수명 훅**: onLoad/onUnload/(start/stop)
- [ ] **오류/SEH 보호/블랙리스트**
- [ ] **업데이트/롤백/마켓 연계**
- [ ] **샌드박스 로더/CI 테스트**
- [ ] 필요 시 **Out-of-proc**로 격리

---

### 마무리

플러그인 구조의 본질은 **이진 호환성과 운영 안정성**입니다.  
이번 가이드의 **C ABI + Manifest + 안전 로딩 + 버전 협상**만 지켜도  
- 팀 내외부 개발자가 **두려움 없이** 확장 모듈을 만들 수 있고,  
- 운영/업데이트/복구의 **현실적인 루프**를 구축할 수 있습니다.