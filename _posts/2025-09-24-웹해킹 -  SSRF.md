---
layout: post
title: 웹해킹 - SSRF
date: 2025-09-24 20:25:23 +0900
category: 웹해킹
---
# SSRF (Server-Side Request Forgery)

## 0) 한눈에 보는 요지

- **SSRF**는 서버가 **공격자가 지정한 URL**로 **백엔드에서 요청**을 보내게 만들어 **내부망/관리 포트/메타데이터 서비스**에 접근하도록 하는 취약점입니다. 특히 클라우드에선 **인스턴스 메타데이터(임시 크리덴셜)** 탈취로 **권한 상승·대규모 데이터 접근**으로 이어질 수 있습니다.   
- 현대 클라우드의 핵심 표면:
  - **AWS IMDS** `169.254.169.254` (IMDSv2: 사전 **토큰** 요구, **Hop Limit** 설정), **ECS/EKS** 환경의 **169.254.170.2**(컨테이너 메타데이터/자격증명). 
  - **GCP** 메타데이터는 **필수 헤더 `Metadata-Flavor: Google`** 요구. 
  - **Azure** IMDS는 **`Metadata: true`** 헤더 필수. 
  - **Alibaba Cloud**: **`100.100.100.200`** 메타데이터. **보안 하드닝 모드(토큰)** 제공. 
  - **Oracle Cloud(OCI)**: `169.254.169.254/opc/v1…`/`v2…`. 
- **최신 방어의 골자**: (1) **아키텍처적 차단(egress 프록시·네트워크 정책)**, (2) **엄격한 허용목록 기반 URL 검증 + 재해석/재확인(DNS·리다이렉트·IP 계열)**, (3) **클라우드 메타데이터 보안 기능 활성화**(IMDSv2 필수화, GKE Workload Identity, AKS IMDS restriction). 

---

## 1) SSRF 기본 원리 (클라우드 관점)

**서버**가 내부적으로 HTTP(S) 요청을 보낼 수 있다면, 입력값(`url`, `webhook`, `fetch`, `import`)이 **공격자 제어**가 될 때 SSRF 위험이 시작됩니다. 공격의 목표는:

1) **내부망** 서비스(관리 콘솔, Redis/Elasticsearch/Consul 등)  
2) **로컬호스트**(127.0.0.1, ::1) 및 **링크-로컬**(169.254.0.0/16 등)  
3) **클라우드 메타데이터 서비스** (임시 토큰/키 탈취 → IAM 권한 남용)  

PortSwigger의 정리처럼, **응답이 사용자에게 직접 보이는 SSRF**와, **응답이 보이지 않는 Blind SSRF**가 있으며, 둘 다 **네트워크 효과**로 심각한 피해를 유발할 수 있습니다. 

---

## 2) 클라우드 **메타데이터 서비스** 핵심 정리 (자주 노리는 표면)

| 클라우드 | 기본 엔드포인트 | 특이사항/보호 요구 |
|---|---|---|
| **AWS EC2** | `http://169.254.169.254/latest/…` · **IPv6** `http://[fd00:ec2::254]/latest/…` | **IMDSv2**: **PUT**로 토큰 발급 후 `X-aws-ec2-metadata-token` 헤더 필요. **Hop Limit**(기본 1) 설정.  |
| **AWS ECS/EKS** | **ECS** 컨테이너 메타데이터/자격증명: `169.254.170.2` / `${ECS_CONTAINER_METADATA_URI_V4}` | 컨테이너 권한 위임(태스크 롤) 관련 크리덴셜·메타데이터.  |
| **GCP** | `http://metadata.google.internal/computeMetadata/v1` 또는 `169.254.169.254` | **`Metadata-Flavor: Google`** 헤더 필수. GKE는 **Workload Identity** 권장.  |
| **Azure** | `http://169.254.169.254/metadata/instance?api-version=…` | **`Metadata: true`** 헤더 필수. AKS는 **IMDS restriction(프리뷰)** 제공.  |
| **Alibaba Cloud ECS** | `http://100.100.100.200/latest/meta-data/…` | 문서화된 **메타데이터(및 RAM 역할 크리덴셜)**. 보안 하드닝 모드.  |
| **Oracle Cloud (OCI)** | `http://169.254.169.254/opc/v1/…` / `v2/…` | 인스턴스/네트워크/아이덴티티 정보.  |
| **DigitalOcean** | `http://169.254.169.254/metadata/v1/…` | 드롭릿 자체 정보/유저데이터.  |

> 위 엔드포인트는 **외부에서 직접 접근 불가**지만, **내부에서 SSRF가 발생**하면 접근이 가능해집니다. **인스턴스 역할/서비스 계정 토큰 탈취**로 이어지는 이유입니다. (각 문서 링크 참조) 

---

## 3) 공격 패턴 — 최신 트릭과 우회기술

1) **URL 파서 혼동/검증 우회**  
   - 여러 런타임/라이브러리의 **URL 파서 불일치**로 `@`, 도트리스/8진수/10진수/혼합 표기, IPv6 포함, 스킴 스머글링(`http:@127.0.0.1@evil.com`) 등으로 **로컬/링크-로컬 우회**. PortSwigger의 최신 **URL Validation Bypass Cheat Sheet** 업데이트(2024~2025) 참고.   
   - Orange Tsai의 고전 발표: **URL 파서 vs 요청기** 불일치로 **gopher:// 등 비HTTP 프로토콜**을 악용해 내부 서비스(예: Redis)에 명령 주입. 
2) **오픈 리다이렉트/SSRF 체이닝**  
   - `https://safe.example/redirect?to=http://169.254.169.254/…` 처럼 **검증을 통과한 후** 내부로 전환.
3) **DNS Rebinding**  
   - 최초에는 공인 IP로 응답해 허용목록을 통과, **그 후 로컬 IP**로 바인딩 변경. (연구/실무 포스팅 다수) 
4) **Blind SSRF**  
   - 응답을 돌려주지 않아도, **타임·사이드채널**(DNS/로그 콜백)로 탐지·악용 가능. 
5) **클라우드 특화 체인**  
   - **IMDS → 임시 자격증명 탈취 → 스토리지/메시지/DB 접근**. AWS에선 **IMDSv2 강제**와 **Hop Limit**으로 컨테이너 경유 SSRF를 줄입니다. 

---

## 4) 실습형 **취약 코드** → **방어 코드**

### 4.1 Node.js(Express) — 이미지 “URL로 가져오기” 기능

**❌ 취약 예시**
```javascript
// 사용자가 준 URL을 그대로 가져와 서버가 다시 서빙 (SSRF 지옥문)
import express from "express";
import fetch from "node-fetch";
const app = express();

app.get("/proxy", async (req, res) => {
  const url = req.query.url; // 예: http://169.254.169.254/latest/meta-data/
  const r = await fetch(url); // 내부/로컬/메타데이터로 요청 가능
  res.set("Content-Type", r.headers.get("content-type") || "application/octet-stream");
  r.body.pipe(res);
});
```

**✅ 개선 예시(SSRF Guard + 아키텍처 차단)**
```typescript
import express from "express";
import fetch, { RequestInit } from "node-fetch";
import dns from "node:dns/promises";
import net from "node:net";
import { URL } from "node:url";

const app = express();
const ALLOW_HOSTS = new Set(["images.example-cdn.com"]); // 엄격한 허용목록
const ALLOW_SCHEMES = new Set(["https:"]);               // http 금지

// 사설/로컬/메타데이터 등 금지 대역 (IPv4/IPv6)
const BLOCK_CIDRS = [
  "0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16",
  "172.16.0.0/12","192.0.0.0/24","192.0.2.0/24","192.168.0.0/16","198.18.0.0/15",
  "198.51.100.0/24","203.0.113.0/24","224.0.0.0/4","240.0.0.0/4",
  // 클라우드 메타데이터 대표 IP
  "169.254.169.254/32",     // AWS/GCP/Azure 공통 IMDS IPv4
  "100.100.100.200/32",     // Alibaba ECS
  // IPv6
  "::1/128","fc00::/7","fe80::/10","ff00::/8","fd00:ec2::254/128", // AWS IMDS IPv6
];

import { Netmask } from "netmask"; // 또는 ipaddr.js 등
const BLOCKS = BLOCK_CIDRS.map(c => new Netmask(c));

function isBlockedIP(ip: string) {
  if (net.isIP(ip) === 0) return true;
  return BLOCKS.some(b => b.contains(ip));
}

async function resolveAndCheck(hostname: string) {
  const addrs = [
    ...(await dns.resolve4(hostname).catch(() => [] as string[])),
    ...(await dns.resolve6(hostname).catch(() => [] as string[])),
  ];
  if (addrs.length === 0) throw new Error("DNS resolution failed");
  if (addrs.some(isBlockedIP)) throw new Error("Address not allowed");
  return addrs;
}

async function safeFetch(raw: string, opts: RequestInit = {}) {
  const u = new URL(raw);

  if (!ALLOW_SCHEMES.has(u.protocol)) throw new Error("Scheme not allowed");
  if (!ALLOW_HOSTS.has(u.hostname)) throw new Error("Host not allowed");

  // 1차 DNS 확인
  await resolveAndCheck(u.hostname);

  // 리디렉트 금지/제한
  const r = await fetch(u, { ...opts, redirect: "manual" });
  const loc = r.headers.get("location");
  if (r.status >= 300 && r.status < 400 && loc) {
    // 리디렉트 대상도 동일 검증(재해석) — 체인 전체 확인
    await resolveAndCheck(new URL(loc, u).hostname);
    throw new Error("Redirect blocked"); // 안전을 위해 기본 차단
  }
  return r;
}

app.get("/proxy", async (req, res) => {
  try {
    const r = await safeFetch(String(req.query.url));
    res.set("Content-Type", r.headers.get("content-type") || "application/octet-stream");
    r.body.pipe(res);
  } catch (e) {
    res.status(400).json({ error: String(e) });
  }
});
```

**포인트**
- **허용목록 기반(스킴/호스트) + DNS 결과/IP 대역 검증 + 리다이렉트 재검증**  
- **사설/링크로컬/메타데이터** 등 **금지 대역** 하드코딩(클라우드 별 IMDS 포함).  
- **네트워크 레벨 차단**(다음 §6, §8)과 **함께** 써야 효과적입니다. **IMDSv2/헤더 요구**는 **서버가 직접 때리는 경우에도** 보호면에서 유리합니다. 

---

### 4.2 Python(Requests) — 간단 SSRF 가드

**✅ 예시**
```python
import ipaddress, socket, requests
from urllib.parse import urlparse

BLOCKS = [
  ipaddress.ip_network("127.0.0.0/8"), ipaddress.ip_network("10.0.0.0/8"),
  ipaddress.ip_network("172.16.0.0/12"), ipaddress.ip_network("192.168.0.0/16"),
  ipaddress.ip_network("169.254.0.0/16"), ipaddress.ip_network("::1/128"),
  ipaddress.ip_network("fc00::/7"), ipaddress.ip_network("fe80::/10"),
  ipaddress.ip_network("fd00:ec2::254/128"), ipaddress.ip_network("169.254.169.254/32"),
  ipaddress.ip_network("100.100.100.200/32")
]

def is_blocked_ip(ip):
  ip_obj = ipaddress.ip_address(ip)
  return any(ip_obj in n for n in BLOCKS)

def resolve_and_check(host):
  for fam in (socket.AF_INET, socket.AF_INET6):
    try:
      infos = socket.getaddrinfo(host, None, fam, 0, socket.IPPROTO_TCP)
      for *_, sa in infos:
        ip = sa[0]
        if is_blocked_ip(ip): raise ValueError("blocked ip")
    except socket.gaierror:
      pass

def safe_get(raw):
  u = urlparse(raw)
  if u.scheme != "https": raise ValueError("only https")
  resolve_and_check(u.hostname)
  r = requests.get(raw, timeout=5, allow_redirects=False)
  if 300 <= r.status_code < 400 and "location" in r.headers:
    # 리다이렉트 체인 제한 or 재검증
    raise ValueError("redirect blocked")
  return r
```

---

## 5) “클라우드별” 방어 전략 (실전 체크리스트)

### 5.1 AWS (EC2/ECS/EKS)

- **IMDSv2 강제 + IMDSv1 비활성**: 계정/인스턴스 레벨로 **IMDSv2 Required** 설정, **IPv4/IPv6 엔드포인트** 필요 시에만 ON. **Hop Limit**는 컨테이너 환경에서 **2**가 일반적(네임스페이스 홉).   
  ```bash
  # 신규 인스턴스 기본: IMDSv2 강제
  aws ec2 modify-instance-metadata-options \
    --instance-id i-1234 \
    --http-tokens required --http-endpoint enabled \
    --http-put-response-hop-limit 2
  ```
- **ECS/EKS 권한 위임 모범사례**: **태스크 롤/IRSA**로 세분화하고, **Pod/컨테이너에서 IMDS 접근이 불필요**하면 보안그룹/iptables로 **169.254.169.254 차단**. ECS 컨테이너용 메타데이터/자격증명은 **169.254.170.2**/**환경변수 URI**를 통해 주입됨을 이해(필요 최소 권한 부여).   
- **네트워크 레벨 차단**: 보안 그룹/NACL/프록시로 **사설/링크로컬**(특히 `169.254.169.254`)에 대한 **egress 차단**. CloudWatch의 **`MetadataNoToken`**로 IMDSv1 사용 감시. 

### 5.2 GCP / GKE

- **메타데이터 헤더 요구**: `Metadata-Flavor: Google`이 필수 → 단순 SSRF로는 바로 읽기 어려움.   
- **Workload Identity Federation** 사용(키 파일 배포 금지 / 메타데이터 종속도 감소). **Metadata Concealment**는 구 방식으로 **Workload Identity 권장**.   
- **네트워크 정책**: 대부분의 Pod에서 `169.254.169.254` 차단, 필요한 워크로드만 허용. (GKE 하드닝 가이드/베스트 프랙티스 참고) 

### 5.3 Azure / AKS

- **IMDS 요구 헤더**: `Metadata: true`. (이 헤더가 없으면 400)   
- **AKS IMDS restriction(프리뷰)**: **Pod의 IMDS 접근 일괄 차단** 옵션 제공(2025-05 기준).   
- **Managed Identity**를 표준으로, 앱에서 **직접 토큰 요청/보관**을 피하고 최소 권한 부여. 

### 5.4 Alibaba Cloud / OCI / DigitalOcean

- **Alibaba ECS**: 메타데이터 `100.100.100.200` (RAM 역할 자격증명 엔드포인트 포함) → **차단 목록에 반드시 포함**.   
- **OCI**: `169.254.169.254/opc/v1`/`v2` → egress 차단/허용목록.   
- **DigitalOcean**: `169.254.169.254/metadata/v1` → 동일. 

---

## 6) **네트워크 레벨** 방어(필수)

### 6.1 Kubernetes 네트워크폴리시 예 (IMDS 차단)

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-imds
  namespace: default
spec:
  podSelector: {}             # 모든 Pod에 적용(선택적으로 라벨 세분화)
  policyTypes: ["Egress"]
  egress:
    - to:
        - ipBlock:
            cidr: 169.254.169.254/32
      ports:
        - protocol: TCP
          port: 80
        - protocol: TCP
          port: 443
```

> AKS는 **IMDS restriction** 기능(미리보기)을 제공, **GKE는 Workload Identity** 권장으로 메타데이터 의존도를 구조적으로 줄입니다. 

### 6.2 Nginx/iptables로 로컬/링크로컬 차단(호스트 레벨)

```bash
# IMDS 차단 (리눅스 호스트)
iptables -A OUTPUT -d 169.254.169.254 -j REJECT
ip6tables -A OUTPUT -d fd00:ec2::254 -j REJECT
```

---

## 7) **아키텍처 패턴**으로 SSRF 제거

1) **아웃바운드 egress 프록시 1곳으로 집약**  
   - 애플리케이션은 **직접 외부로 나가지 않고** 사내 **프록시**로만 나감 → 프록시에서 **허용목록·TLS 검증·DNS 고정**.  
2) **URL 입력을 받지 않기**  
   - “URL 가져오기” 기능은 **ID/템플릿** 기반으로 재설계.  
3) **응답 렌더링 금지**  
   - 서버가 가져온 컨텐츠를 **직접 브라우저에 inline 렌더**하지 말고, **다운로드 전용**(attachment) 또는 **가공/필터** 후 제공.  
4) **SSRF 가드 라이브러리 공통화**  
   - 각 서비스에 흩어진 구현 대신 **플랫폼 레이어**에서 **검증/리다이렉트 제어/타임아웃/스킴 제한**을 일괄 적용.  
5) **클라우드 기능 적극 활용**  
   - **IMDSv2 필수화**, **Hop Limit 설정**, **Workload Identity/IRSA/Managed Identity**로 **키/토큰 노출 표면 축소**. 

---

## 8) **테스트 플레이북**(개발/QA 전용)

- **기본**: `http://127.0.0.1`, `http://[::1]`, `http://169.254.169.254/latest/meta-data/` (AWS/GCP/Azure), `http://100.100.100.200/latest/meta-data/`(Alibaba), `http://169.254.169.254/opc/v1/instance/`(OCI). 기대값=**차단**.   
- **우회 표기**: 8진수/10진수/도트리스/혼합/유니코드·퍼센트 인코딩, 사용자정보(`user@host`) 포함, `@` 2번, IPv6 zone index 등. → **모두 차단**되어야 함. (PortSwigger cheat sheet 참고)   
- **리다이렉트 체인**: 302 → 내부/메타데이터. **중간/최종 대상 재검증** 확인.  
- **DNS Rebinding**: 최초 공인 → 후속 로컬. 캐시·검증 로직이 **매 요청 재확인**하는지.   
- **Blind SSRF 탐지**: 외부 관측용 엔드포인트(수신 로그)로 아웃바운드가 나가는지 확인. 

---

## 9) **사건에서 배우기** — Capital One(2019)

2019년 **Capital One** 사건은 **SSRF + 구성 취약**이 **AWS 인프라 자격증명·데이터 접근**으로 이어질 수 있음을 상징적으로 보여주었습니다(공식 공지·분석 참고). AWS는 이후 **IMDSv2(토큰/홉 제한)**를 통해 **WAF/프록시/리디렉션** 등 경유 접근에 대한 **심층 방어**를 강화했습니다. 

---

## 10) **현대적 코드/운영 체크리스트** (요약)

- [ ] **URL 허용목록**(스킴/호스트/포트) + **DNS/IP 재확인**(A/AAAA 모두, 리다이렉트마다 재검증)  
- [ ] **사설·링크로컬·메타데이터 IP 전면 차단**(IPv4/IPv6 모두) — `169.254.169.254`, `100.100.100.200`, `[fd00:ec2::254]` 등 포함.   
- [ ] **IMDS 보안**: **IMDSv2 필수**, **IMDSv1 비활성**, **Hop Limit 적정값(컨테이너=2)**, **필요 시 IMDS off**.   
- [ ] **GKE Workload Identity / AKS IMDS restriction / IRSA** 등 **워크로드 아이덴티티** 사용.   
- [ ] **egress 프록시**로 외부 통신 중앙화 + 방화벽/SG/NACL로 **목적지 제어**  
- [ ] **타임아웃/크기 제한/스킴 제한**(gopher/file/ftp 등 비HTTP 금지)  
- [ ] **로깅/경보**: 내부 주소/메타데이터 지향 트래픽 시 **즉시 알림**  
- [ ] **보안 테스트**: PortSwigger 랩/OWASP 치트시트/URL 파서 혼동 기법을 포함한 **자동화 테스트**. 

---

## 11) 부록 — 다양한 “상황별” 예제

### 11.1 이미지 URL 인입을 “작업 큐 + 프록시”로 격리

- 사용자가 업로드 대신 “URL”을 주는 기능이 필요하다면:
  1) API는 **URL 자체를 저장하지 않고** 큐에 **작업 ID**만 넣음  
  2) 백엔드 워커가 **사내 egress 프록시**만 사용하여 **허용목록 호스트**에서만 가져옴  
  3) 가져온 바이너리는 **바이러스/CDR** 검사 후 오브젝트 스토리지에 저장  
  4) 클라이언트는 **작업 ID → 결과 파일** 매핑만 조회(직접 URL 노출 금지)

### 11.2 Kubernetes — 특정 네임스페이스만 외부 통신 허용

- `defaultDeny` Egress → `allow-egress-to-cdn` 만 예외.  
- **IMDS/사설 대역 전면 차단** 폴리시 별도 적용.

### 11.3 프레임워크 핫스팟

- **서버 사이드 렌더러/크롤러**(Puppeteer, wkhtmltoimage 등) — **URL 입력**을 받아 내부 서비스를 통째로 긁어갈 수 있음(**SSRF + 데이터 수집**).  
- **PDF 생성기/이미지 변환기** — 외부 URL을 포함한 리소스 로딩 기능 OFF 또는 **프록시 강제**.  
- **Webhook/통합** — 콜백 URL 등록 시 **사전 검증 + 사후 검증(주기적 재확인)** 필요.

---

## 12) 참고 자료 (선정)

- **PortSwigger**: SSRF 개요/블라인드 SSRF/실습 랩.   
- **OWASP**: SSRF 예방 치트시트 / OWASP Top 10 A10(2021).   
- **AWS**: IMDSv2/홉 제한/IMDSv1 비활성 가이드, ECS 메타데이터/자격증명.   
- **GCP**: 메타데이터 서버/Workload Identity Federation for GKE.   
- **Azure**: IMDS(`Metadata: true`) / AKS IMDS 제한(프리뷰).   
- **Alibaba/OCI/DigitalOcean**: 각 메타데이터 엔드포인트.   
- **URL 파서 혼동·우회**: Orange Tsai(Black Hat), PortSwigger URL Validation Bypass Cheat Sheet(2024~2025 업데이트).   
- **사건사례**: Capital One 공지/보도 및 분석, AWS 보안 블로그(2019 IMDS 강화 배경). 

---

### 마지막 한 줄
> **SSRF는 “내부에서 나가는 요청”을 공격자가 조종한다**는 점이 핵심입니다.  
> **허용목록·재해석 검증 + egress 통제 + 클라우드 메타데이터 보안(IMDSv2·Workload Identity 등)**을 **동시에** 적용하면, 최신 클라우드 SSRF 시나리오의 대부분을 차단할 수 있습니다.