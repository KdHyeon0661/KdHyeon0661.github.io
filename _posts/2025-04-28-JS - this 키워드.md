---
layout: post
title: JavaScript - this 키워드
date: 2025-04-22 21:20:23 +0900
category: JavaScript
---
# this 키워드

## 1. 한눈에 보는 규칙(우선순위)

### 1.1 결정 순서(가장 강력한 규칙이 이김)
1) **`new` 바인딩**: `new F()`로 호출하면 `this`는 생성된 새 객체.  
2) **명시적 바인딩**: `call/apply/Reflect.apply/bind`로 지정한 객체.  
3) **암묵적 바인딩**: `obj.method()` 형태면 `this === obj`(점/대괄호 **왼쪽**).  
4) **기본 바인딩**: 위가 아니면 **엄격 모드(strict)**에서는 `undefined`, 비엄격에선 전역 객체.  
5) **화살표 함수**: 위 1)~4) 대신 **상위(외부) 렉시컬 `this`를 그대로 캡처**(자체 `this` 없음).

> **브라우저 전역**: `window` (표준화된 통합 식별자는 `globalThis`)  
> **Node 전역**: `global` (통합 `globalThis`)  
> **모듈(ESM)** 최상위 `this`는 **항상 `undefined`**.

### 1.2 빠른 예제
```js
function f(){ return this; }

// (A) 기본 바인딩
console.log(f() === (function(){return this})()); // 브라우저 비엄격: 전역(window)

// (B) 암묵적 바인딩
const o = { f };
console.log(o.f() === o); // true

// (C) 명시적 바인딩
console.log(f.call({x:1}).x); // 1

// (D) new 바인딩
function C(){ this.v=7; }
console.log(new C().v); // 7

// (E) 화살표
const g = () => this;
console.log(typeof g()); // 상위 스코프 this에 의존
```

---

## 2. 실행 컨텍스트와 엄격 모드/모듈

### 2.1 엄격 모드(strict mode)
- **엄격 모드**의 일반 함수 호출 `f()`에서 `this === undefined`  
- 비엄격에서는 **기본 바인딩**이 전역 객체로 **암시적 변환**.

```js
"use strict";
function f(){ console.log(this); }
f(); // undefined
```

### 2.2 스크립트 vs 모듈
- **스크립트** 최상위: 브라우저에선 `this === window`(비엄격), Node는 파일 단위 래퍼로 다름.  
- **ES 모듈(ESM) 최상위**: `this === undefined` (언어 명세상).

---

## 3. 일반 함수/메서드/분리 호출

### 3.1 일반 함수(기본 바인딩)
```js
function show(){ console.log(this); }
show(); // 브라우저 비엄격: window, strict/ESM: undefined
```

### 3.2 메서드(암묵적 바인딩)
```js
const person = {
  name: "Alice",
  greet() { console.log(this.name); }
};
person.greet(); // "Alice"
```

### 3.3 메서드 분리(바인딩 소실)
```js
const obj = { n: 10, m(){ console.log(this.n); } };
const f = obj.m;
f(); // 기본 바인딩 → strict/ESM: undefined, 비엄격: 전역
```
**해결**: `bind`
```js
const safe = obj.m.bind(obj);
safe(); // 10
```

### 3.4 대괄호/체이닝의 기준
```js
const table = {
  row: { print(){ console.log(this === table.row); } }
};
table.row.print(); // true (왼쪽 객체가 this)
```

### 3.5 게터/세터의 `this`
```js
const x = {
  _v: 1,
  get v(){ console.log(this === x, this._v); return this._v; },
  set v(n){ this._v = n; }
};
x.v;      // this === x
const getV = Object.getOwnPropertyDescriptor(x, "v").get;
getV();   // 기본 바인딩(주의) → strict면 this=undefined
```

---

## 4. 생성자/클래스에서의 this

### 4.1 생성자 함수 + `new`
```js
function Car(model){
  this.model = model;            // 새 객체에 바인딩
}
const c = new Car("Tesla");
console.log(c.model); // Tesla
```

### 4.2 `return` 규칙
- 생성자가 **객체**를 `return`하면 그 객체가 결과,  
- **프리미티브**를 `return`하면 무시되고 `this`(새 객체) 반환.

```js
function Box(){ this.x=1; return {y:2}; }
console.log(new Box()); // { y: 2 }
```

### 4.3 클래스(메서드는 기본 strict)
```js
class Dog {
  constructor(name){ this.name = name; }
  bark(){ console.log(`${this.name} woof`); } // strict
}
new Dog("Rex").bark(); // Rex woof
```

### 4.4 클래스 필드의 화살표(인스턴스별 this 고정)
```js
class Btn {
  count = 0;
  // 인스턴스 생성 시 화살표가 바깥 this(인스턴스)를 캡처
  handle = () => { this.count++; console.log(this.count); };
}
const b = new Btn();
const fn = b.handle;
fn(); // 1  (분리해도 안전)
```

---

## 5. 명시적 바인딩: call / apply / bind / Reflect

### 5.1 call / apply
```js
function say(prefix){ console.log(prefix, this.name); }
const u = { name: "Emma" };
say.call(u, "Hi");        // Hi Emma
say.apply(u, ["Hello"]);  // Hello Emma
```

### 5.2 bind(하드 바인딩)
```js
const sayEmma = say.bind(u, ">>");
sayEmma();                // >> Emma
```

> **주의**: `bind`된 함수를 **`new`로 호출**하면 **새 인스턴스가 우선**이며, 바운드 `this`는 무시됩니다.

```js
function F(){ console.log(this.tag); }
const obj = { tag: "bound" };
const B = F.bind(obj);
new B(); // this는 새 인스턴스, "bound" 아님
```

### 5.3 Reflect.apply
```js
function sum(a,b){ return a+b; }
console.log(Reflect.apply(sum, null, [2,3])); // 5
```

---

## 6. 화살표 함수: 렉시컬 this

### 6.1 기본 성질
- **자체 `this`/`arguments`/`super`/`new.target` 없음.**
- 선언 시점의 **외부 `this`를 캡처**.

```js
function Timer(){
  this.ticks = 0;
  setInterval(() => {  // 화살표: 여기서 this는 Timer 인스턴스
    this.ticks++;
  }, 1000);
}
new Timer();
```

### 6.2 메서드에 화살표를 남용하면?
```js
const obj = {
  x: 1,
  bad: () => { console.log(this.x); } // this는 상위(전역/모듈), obj 아님
};
obj.bad(); // undefined
```
> **객체 메서드**가 `this`를 필요로 하면 **일반 함수 메서드**를 쓰세요.

### 6.3 중첩 콜백에서 콜백 지옥 방지
```js
function User(name){
  this.name = name;
  this.sayLater = function(){
    setTimeout(() => {    // 화살표로 상위 this 유지
      console.log(this.name);
    }, 200);
  };
}
new User("Tom").sayLater(); // Tom
```

---

## 7. 브라우저/Node 이벤트에서의 this

### 7.1 브라우저 DOM 이벤트
```js
const btn = document.querySelector("button");

// 전통 function: this === 이벤트 타겟 요소
btn.addEventListener("click", function(){
  console.log(this === btn); // true
});

// 화살표: 바깥 this 캡처(대개 window/undefined)
btn.addEventListener("click", () => {
  console.log(this); // 전역/undefined
});
```

### 7.2 setTimeout에서의 this
- **브라우저**: `setTimeout(function(){ console.log(this); },0)` → 대개 `window`로 호출(호스트가 바인딩).  
- **Node**: 콜백의 `this`는 `Timeout` 객체(버전별 차 존재).  
- **권장**: 콜백에서 `this`가 필요하면 **화살표** 또는 **명시적 바인딩** 사용.

```js
setTimeout(function(){ console.log(this); },0);     // 환경 의존
setTimeout(() => { console.log(this); },0);         // 렉시컬 this
```

---

## 8. 배열/이터러블 메서드의 `thisArg`

### 8.1 `forEach`, `map`, `filter` 등 두 번째 인자
```js
const ctx = { mul: 10 };
[1,2,3].map(function(v){ return v * this.mul; }, ctx);
// [10, 20, 30]
```

### 8.2 화살표와 `thisArg`의 상호작용
- 콜백이 **화살표**면 `thisArg`는 **무시**(자체 this가 없으므로).
```js
[1,2,3].map((v) => v * (/* this 없음 */ 2));
```

---

## 9. 기타 케이스/레시피/함정

### 9.1 메서드 디스트럭처링 시 바인딩 유지하기
```js
const counter = {
  n: 0,
  inc(){ this.n++; }
};

// ❌ 바인딩 소실
const { inc } = counter;
try { inc(); } catch(e){ /* TypeError in strict */ }

// ✅ 고정 바인딩
const incSafe = counter.inc.bind(counter);
incSafe(); // counter.n === 1
```

### 9.2 메서드 빌려쓰기
```js
function show(){ console.log(this.value); }
const a = { value: 1 };
show.call(a); // 1
```

### 9.3 클래스에서 이벤트 핸들러 유지(두 가지 패턴)
```js
class View1 {
  constructor(el){ this.el = el; this.onClick = this.onClick.bind(this); }
  onClick(e){ console.log(this.el, e.type); }
}

class View2 {
  constructor(el){ this.el = el; }
  onClick = (e) => { console.log(this.el, e.type); } // 클래스 필드 + 화살표
}
```

### 9.4 `this` 방어적 검사
```js
function mustBeBound(){
  if (!this) throw new TypeError("this-required");
}
```

### 9.5 `globalThis` 통일 포인트
```js
console.log(globalThis === window); // 브라우저 true
console.log(globalThis === global); // Node true
```

---

## 10. 실전 예제(케이스 스터디)

### 10.1 setTimeout + 객체 메서드
```js
const user = {
  name: "Alice",
  sayLater(){
    setTimeout(function(){ console.log(this.name); }, 100); // 환경의 this (window/Timeout)
  }
};
user.sayLater(); // undefined 가능

// ① 화살표
user.sayLater = function(){
  setTimeout(() => console.log(this.name), 100); // Alice
};

// ② bind
user.sayLater = function(){
  setTimeout(function(){ console.log(this.name); }.bind(this), 100);
};
```

### 10.2 이벤트 핸들러에서 `this` vs `currentTarget`
```js
btn.addEventListener("click", function(e){
  console.log(this === e.currentTarget); // true
  console.log(e.target); // 실제 클릭된 하위 요소
});
```

### 10.3 체이닝 중간의 `this`
```js
const calc = {
  x: 0,
  add(n){ this.x += n; return this; },
  mul(n){ this.x *= n; return this; }
};
calc.add(2).mul(3); // this를 반환하면 체이닝 편리
```

### 10.4 React 등 프레임워크에서의 this
- 클래스 컴포넌트: 핸들러 바인딩 필요(`bind`/클래스 필드 화살표).  
- 함수 컴포넌트: `this` 사용 안 함(훅 기반).

---

## 11. 디버깅 팁

- **실행 위치(호출 지점)**를 먼저 찾는다: “**어디서 정의했는가**”가 아니라 “**어디서/어떻게 호출했는가**”.
- DevTools에서 **`this` 미리보기**(Scope/Call Stack) 확인.
- 메서드 분리 시 **`.bind(obj)`**를 습관화하거나 **클래스 필드 화살표** 사용.

---

## 12. 체크리스트

- [ ] `new` / 명시적 / 암묵적 / 기본 / 화살표 **우선순위 기억**  
- [ ] **ESM 최상위 `this`는 `undefined`**  
- [ ] 메서드 분리 시 **바인딩 소실** 여부 확인  
- [ ] 배열 메서드 `thisArg`는 **function 콜백에서만** 의미  
- [ ] 브라우저 이벤트 콜백 `function(){}`은 `this === 요소`  
- [ ] Node/브라우저의 **타이머 콜백 `this` 차이** 인지  
- [ ] 프레임워크(React/Vue…) 별 권장 패턴 숙지

---

## 13. 미니 퀴즈

```js
// Q1
"use strict";
function f(){ return this; }
console.log(f());

// Q2
const obj = { v: 7, get(){ return this.v; } };
const g = obj.get;
try { console.log(g()); } catch(e){ console.log("E"); }

// Q3
const o = { x:1, inc(){ this.x++; } };
const inc = o.inc.bind(o);
inc(); console.log(o.x);

// Q4
const o2 = { x: 1, inc: () => { this.x++; } };
o2.inc(); console.log(o2.x);

// Q5
class C { v = 0; tick(){ setTimeout(function(){ this.v++; }.bind(this), 0); } }
const c = new C(); c.tick();
setTimeout(() => console.log(c.v), 10);
```

**정답 힌트**  
- Q1: `undefined` (strict)  
- Q2: E (기본 바인딩 strict → `this` undefined)  
- Q3: 2 (bind로 고정)  
- Q4: 1 (화살표는 o2를 this로 삼지 않음 → 상위 this에 ++, 무효)  
- Q5: 1 (타이머 콜백을 `bind(this)`로 묶음)

---

## 14. 결론

- `this`는 **호출 방식**이 전부다.  
- **클래스/메서드**는 strict, **화살표**는 렉시컬 캡처, **분리 호출**은 바인딩 소실.  
- DOM/Node, 배열 메서드 `thisArg`, 타이머/이벤트의 차이를 이해하면 **디버깅과 설계**가 쉬워진다.