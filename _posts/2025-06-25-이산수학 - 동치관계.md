---
layout: post
title: 이산수학 - 동치관계
date: 2025-06-25 21:20:23 +0900
category: 이산수학
---
# 동치관계(Equivalence Relation)

## 0. 왜 동치관계인가?

동치관계는 “**같음**(=)의 본질”을 일반화한다.
복잡한 대상을 “**같다고 보아도 되는 기준**”으로 묶어 **동치류**를 만들고, 원래의 복잡한 문제를 **동치류(분할)** 위로 투사하여 단순화한다.

- 정수의 나머지 연산 → $$\Bbb Z_n$$
- 문자열의 길이, 그래프의 동형, 선형대수의 행 기본변환에 의한 행 등가
- 형식언어 이론의 **Myhill–Nerode** 동치 (최소 DFA의 핵심)

핵심 키워드: **반사성/대칭성/추이성**, **동치류**, **분할(Partition)**, **상(Quotient)**, **커널(Kernel)**, **유니온파인드(DSU)**.

---

## 1. 정의

집합 \(A\) 위의 관계 \(R\subseteq A\times A\)가 **동치관계**이려면:

1. **반사성**
   $$\forall a\in A,\ (a,a)\in R$$
2. **대칭성**
   $$\forall a,b\in A,\ (a,b)\in R\Rightarrow (b,a)\in R$$
3. **추이성**
   $$\forall a,b,c\in A,\ (a,b)\in R\wedge (b,c)\in R\Rightarrow (a,c)\in R$$

이때 \(a\sim b\) 라고 쓰기도 한다.

---

## 2. 대표 예시와 빠른 검증

### 2.1 정수의 모듈로 동치
$$
a\equiv b\pmod n \iff n\mid (a-b)
$$
- 반사: \(a-a=0\)은 항상 \(n\mid 0\)
- 대칭: \(a-b\)가 \(n\)의 배수면 \(b-a\)도 배수
- 추이: \(a-b, b-c\)가 배수면 \(a-c=(a-b)+(b-c)\)도 배수

### 2.2 문자열 길이 동치
\((s,t)\in R \iff |s|=|t|\)

### 2.3 같은 나이 / 같은 요일 / 같은 해시값
모두 어떤 함수 \(f:A\to B\)의 **값이 같다**로 정의 가능:
$$
a\sim b \iff f(a)=f(b)
$$
이 관계는 항상 동치관계(→ **커널 관계**). 이 관점은 8절에서 정식화한다.

---

## 3. 동치류(Equivalence Class)와 분할(Partition)

### 3.1 동치류
$$
[a]_R=\{x\in A\mid (a,x)\in R\}
$$
- “\(a\)와 **동치**인 모든 원소”의 집합
- 동치류끼리는 서로소, 모든 원소는 **정확히 하나**의 동치류에 속함

### 3.2 분할 정리(동치관계 ↔ 분할)

**정리.**
- 모든 동치관계 \(R\)은 \(A\)를 동치류들의 **분할**로 만든다.
- 반대로, \(A\)의 임의의 분할 \(\mathcal P=\{B_i\}\)가 주어지면
  $$
  a\sim b \iff \exists i\ (a,b\in B_i)
  $$
  로 정의한 \(\sim\)은 동치관계다.

**증명 스케치.**
- (→) 반사성으로 \(a\in[a]\). 대칭+추이로 서로 다른 두 동치류는 교집합이 비어야 함. 합은 \(A\) 전체를 덮는다.
- (←) “같은 블록에 속한다”는 관계는 반사/대칭/추이를 즉시 만족.

---

## 4. 몫집합(Quotient Set)과 표준 사상

동치관계 \(\sim\)에 대해 **몫집합**
$$
A/{\sim}=\{[a]_{\sim}\mid a\in A\}
$$
을 정의하고, **자연 투사(표준 사상)**
$$
\pi:A\to A/{\sim},\quad \pi(a)=[a]_{\sim}
$$
는 전사(surjective).

> 모든 **동치관계**는 어떤 전사 함수 \(\pi\)의 **커널**로부터 온다:
> $$
> a\sim b \iff \pi(a)=\pi(b)
> $$

---

## 5. 실무·알고리즘 관점: 유니온파인드(DSU)

“같다”는 제약(쌍들)을 반복적으로 받으며 **그룹핑**해야 하는 전형적 상황에 **Disjoint Set Union**(Union-Find)를 사용한다.

- **작업**: `find(x)` (대표 찾기), `union(a,b)` (합치기)
- **최적화**: 경로압축, rank/size union → 거의 상수 \(O(\alpha(n))\)

```python
class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0]*n  # rank
    def find(self, x):
        while x != self.p[x]:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a, b = self.find(a), self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True
```

**예시**: ID 0..6이 있고 (0~1), (1~2), (4~6)를 “같다”로 묶자.
```python
dsu = DSU(7)
for a,b in [(0,1),(1,2),(4,6)]:
    dsu.union(a,b)
groups = {}
for x in range(7):
    r = dsu.find(x)
    groups.setdefault(r, []).append(x)
print(groups)  # 예: {0:[0,1,2], 3:[3], 4:[4,6], 5:[5]}
```

---

## 6. 관계 성질 검사 및 동치폐쇄(Equivalence Closure)

### 6.1 성질 검사 도구

```python
def is_reflexive(A, R):
    Rset = set(R)
    return all((a,a) in Rset for a in A)

def is_symmetric(R):
    Rset = set(R)
    return all((b,a) in Rset for (a,b) in Rset)

def is_transitive(A, R):
    Rset = set(R)
    # O(|R|^2) 단순 검사
    by_from = {}
    for a,b in Rset:
        by_from.setdefault(a, set()).add(b)
    for a in by_from:
        for b in by_from[a]:
            for c in by_from.get(b, ()):
                if (a,c) not in Rset:
                    return False
    return True

def is_equivalence(A, R):
    return is_reflexive(A,R) and is_symmetric(R) and is_transitive(A,R)
```

### 6.2 **최소 동치관계** 생성(동치폐쇄)

관계 \(R\)가 주어졌을 때 이를 포함하는 **가장 작은 동치관계**는
“**양방향 간선**으로 보고 **연결**되어 있으면 동치”로 만든다.
즉, \(R\cup R^{-1}\)를 **무향 그래프**로 보고 **연결요소**가 동치류가 된다.

알고리즘:
1) 무향 인접리스트를 만든다: \(u\leftrightarrow v\)
2) 각 연결요소를 찾는다(BFS/DFS/DSU)
3) 각 요소 \(C\)의 모든 쌍 \((x,y)\)를 동치에 포함, 그리고 모든 \((a,a)\) 추가

```python
from collections import deque

def equivalence_closure(A, R):
    # 1) 무향 그래프 구성
    adj = {a: set() for a in A}
    for a,b in R:
        adj[a].add(b)
        adj[b].add(a)  # 대칭화

    # 2) 연결요소 탐색
    seen=set(); comps=[]
    for s in A:
        if s in seen: continue
        q=deque([s]); seen.add(s); comp=[s]
        while q:
            u=q.popleft()
            for v in adj[u]:
                if v not in seen:
                    seen.add(v); q.append(v); comp.append(v)
        comps.append(comp)

    # 3) 동치쌍 생성(모든 서로쌍 + 대각)
    E=set()
    for comp in comps:
        for i in range(len(comp)):
            for j in range(len(comp)):
                E.add((comp[i], comp[j]))
    return E
```

**검증**:
```python
A = {1,2,3,4}
R = {(1,2),(2,3)}  # 비대칭·비추이
E = equivalence_closure(A,R)
print(is_equivalence(A,E))  # True
# 동치류: {1,2,3}, {4}
```

> 주의: “추이적 폐쇄”만으로는 동치가 아님(대칭/반사 필요). **동치폐쇄**는 세 성질을 동시에 만족시키는 최소 확장.

---

## 7. 분할 ↔ 동치관계 변환 함수

```python
def relation_from_partition(partition):
    """
    partition: list of iterables, 서로소 블록들의 리스트
    """
    R=set()
    for block in partition:
        block=list(block)
        for i in range(len(block)):
            for j in range(len(block)):
                R.add((block[i], block[j]))
    return R

def partition_from_relation(A, R):
    """
    동치관계 R로부터 블록(동치류) 리스트를 생성
    """
    assert is_equivalence(A, R)
    # 대표자 사상 π로 구현해도 되고, BFS로도 됨.
    # 여기선 R를 무향으로 보고 연결요소 구함
    from collections import defaultdict, deque
    adj = defaultdict(set)
    for a,b in R:
        adj[a].add(b); adj[b].add(a)
    seen=set(); parts=[]
    for s in A:
        if s in seen: continue
        q=deque([s]); seen.add(s); comp=[s]
        while q:
            u=q.popleft()
            for v in adj[u]:
                if v not in seen:
                    seen.add(v); q.append(v); comp.append(v)
        parts.append(sorted(comp))
    return parts
```

---

## 8. 커널, 몫, 범용성(보편 성질)

**정리.** 임의의 함수 \(f:A\to B\)에 대해
$$
a\sim_f b \iff f(a)=f(b)
$$
는 동치관계(= **커널 관계**). 몫 \(\pi:A\to A/{\sim_f}\)와
$$
\exists! \;\bar f: A/{\sim_f}\to B,\quad \bar f([a])=f(a)
$$
가 존재하여 \(f=\bar f\circ \pi\) (잘 정의됨: 같은 동치류이면 \(f\)값 동일).

> 이것이 **“함수는 몫을 통해 인자화한다”**는 구조적 이유.
> 모듈러 산술, 선형대수의 몫공간, 군론의 몫군 등에서 반복 등장.

**파이썬 예시**: 임의의 \(f\)에 대한 커널 동치와 몫으로의 하강
```python
def kernel_equivalence(A, f):
    # f: dict-like or callable
    def val(x): return f[x] if isinstance(f, dict) else f(x)
    # 동치류 구성
    classes = {}
    for a in A:
        classes.setdefault(val(a), []).append(a)
    # 관계
    R=set()
    for key, block in classes.items():
        for i in range(len(block)):
            for j in range(len(block)):
                R.add((block[i], block[j]))
    return R, list(classes.values())

# 예: 문자열을 길이로 보낸 함수 f=len
A = ["", "a", "bb", "cc", "cat", "dog"]
R, parts = kernel_equivalence(A, len)
print(parts)  # 같은 길이끼리 묶임
```

---

## 9. 대표자 선택과 정렬(표준형, Canonical Representative)

동치류 내부에서 **대표자**를 고르면 실전에서 편해진다(예: 가장 작은 값, 사전순 최소 문자열, 정규형 등).

```python
def canonical_reps(partition, key=None):
    reps=[]
    for block in partition:
        reps.append(min(block, key=key) if key else min(block))
    return reps

# 예: 길이 동치류에서 사전순 최소를 대표자로
A = ["b","aa","ab","c","zzz","xy"]
R, parts = kernel_equivalence(A, len)
print(parts)
print(canonical_reps(parts))  # 예: ['b','aa','zzz']
```

---

## 10. 실전 모델링 예시

### 10.1 무향 그래프의 연결동치
- 정점 \(u,v\)가 **같은 연결요소**에 있으면 \(u\sim v\).
- 이는 동치관계이며, 몫 그래프(요소 단위로 축약)는 **트리/포레스트 판정, 병합요약** 등에서 유용.

### 10.2 문자열의 **아나그램 동치**
\(s\sim t \iff \text{sorted}(s)=\text{sorted}(t)\).
해시맵 키를 **문자 빈도**로 잡으면 큰 데이터도 그룹화 가능.

```python
from collections import defaultdict

def group_anagrams(words):
    g=defaultdict(list)
    for w in words:
        sig = tuple(sorted(w))  # 더 큰 문제는 26자 빈도 튜플
        g[sig].append(w)
    return list(g.values())

print(group_anagrams(["eat","tea","tan","ate","nat","bat"]))
# [['eat','tea','ate'], ['tan','nat'], ['bat']]
```

### 10.3 DFA 상태 최소화 (Myhill–Nerode 직관)
- 언어 \(L\subseteq \Sigma^\*\)에 대해 **접미사 구분 동치**
  $$x\equiv_L y \iff \forall z,\ xz\in L \Leftrightarrow yz\in L$$
- 유한 개 동치류 ↔ 정규성. 최소 DFA의 상태 수 = 동치류 수.

---

## 11. 반례로 이해하는 성질 차이

- **반사+대칭**만 있고 **추이X**:
  \(A=\{1,2,3\}\), \(R=\{(1,1),(2,2),(3,3),(1,2),(2,1),(2,3),(3,2)\}\).
  여기서 (1,2),(2,3) 있으나 (1,3) 없음 → 동치 아님.

- **반사+추이**만 있고 **대칭X**:
  “\(\le\)”는 반대칭/추이/반사지만 대칭이 아님.

- **대칭+추이**만 있고 **반사X**:
  대각 \((a,a)\)가 빠져 있으면 여전히 동치가 아님.
  (동치관계는 **세 성질 모두** 필요)

---

## 12. 계산 복잡도와 구현 팁

- DSU: 거의 상수 시간(역아커만). **대규모 동일성 제약**에 적합.
- 동치폐쇄: 연결요소 구하면 끝. \(O(n+m)\).
- 성질 검사 중 **추이성**은 순진하면 \(O(|R|^{1.5} \sim |R|^2)\), 필요시 **부울 행렬 곱**(워셜)이나 인접 사전으로 최적화.
- 실무에서는 “**동치류만 필요**”한 경우가 많아, **쌍 전체(모든 ordered pair)**를 물리적으로 만들지 말고 **대표자 맵**(element → rep)로 관리하라.

---

## 13. 고급: 동치관계의 격자 구조(요약)

- 한 집합 \(A\) 위의 모든 동치관계(=모든 분할)는 **정련(refinement)** 순서로 **완비 격자**를 이룬다.
- **만남(∧)**: 공통 정련(블록 교차) / **이음(∨)**: 둘을 포함하는 최소 분할(블록 병합의 폐쇄).
- 테스트/클러스터링에서 **여러 기준의 동시 분류**를 할 때 유용한 이론적 틀.

---

## 14. 종합 실습: “제약 → 동치폐쇄 → 몫” 파이프라인

**문제.**
사람 목록과 제약 “같은 부서”/“같은 호칭”/“같은 좌석구역”이 주어진다.
“**같다고 보아도 되는 동치**”를 만들고, **각 동치류의 대표자**를 선정하라.

```python
from collections import defaultdict

def build_equivalence_from_constraints(items, eq_pairs):
    """
    items: hashable iterable
    eq_pairs: iterable of (a,b) that must be in same class
    return: list of classes (list of lists), and rep map
    """
    index = {x:i for i,x in enumerate(items)}
    dsu = DSU(len(items))
    for a,b in eq_pairs:
        dsu.union(index[a], index[b])
    groups = defaultdict(list)
    for x in items:
        groups[dsu.find(index[x])].append(x)
    classes = list(groups.values())
    # 대표자: 사전순 최소
    reps = {x: min(cls) for cls in classes for x in cls}
    return classes, reps

people = ["Ann","Ben","Bob","Cody","Dana","Eve"]
constraints = [("Ben","Bob"),("Bob","Cody"),("Ann","Dana")]  # 같다고 봄
classes, reps = build_equivalence_from_constraints(people, constraints)
print(classes)  # 예: [['Ben','Bob','Cody'], ['Ann','Dana'], ['Eve']]
print(reps)     # 각 사람 → 대표자
```

이제 어플리케이션 로직에는 **대표자 기준 키**만 저장하면 중복이 줄고 로직이 단순화된다.

---

## 15. 추가 예제 모음(스스로 확인)

1) **mod 3 동치류**
   - 입력: \(A=\{-4,-3,\ldots,8\}\)
   - 출력: \([0]=\{\ldots,-3,0,3,6\}, [1]=\{\ldots,-5,-2,1,4,7\}, [2]=\{\ldots,-4,-1,2,5,8\}\)

2) **문자열 길이 동치류**
   - 입력: `["a","hi","yo","cat","dog"]`
   - 출력: `{"a"}, {"hi","yo"}, {"cat","dog"}`

3) **아나그램 동치류**
   - 입력: `["eat","tea","tan","ate","nat","bat"]`
   - 출력: `{"eat","tea","ate"}, {"tan","nat"}, {"bat"}`

4) **행 등가(Row equivalence)**
   같은 해를 갖는 정사각 행렬(초등 행 연산으로 상호 변환 가능)은 동치관계. (대표자: RREF)

---

## 16. 요약 표

| 항목 | 핵심 |
|---|---|
| 동치관계 | 반사 + 대칭 + 추이 |
| 동치류 | “같다”로 묶인 블록 |
| 분할 정리 | 동치관계 ⇄ 분할 1:1 대응 |
| 몫집합 | \(A/{\sim}\), 표준 사상 \(\pi\) |
| 커널 | \(a\sim b \iff f(a)=f(b)\) |
| 알고리즘 | DSU, 연결요소, 대표자 선택 |
| 동치폐쇄 | \(R\)의 최소 동치 확장 = 무향연결로 묶기 |

---

## 17. 빠른 체크리스트

- [ ] 세 성질 모두 만족? (반/대/추)
- [ ] 동치류가 서로소로 전체를 덮는가?
- [ ] 구현은 “대표자 맵”으로 가볍게?
- [ ] **동치폐쇄**가 필요하면: 무향화 → 연결요소
- [ ] 함수의 커널로 동치를 정의할 수 있는가? (모델링 단순화)

---

### 부록 A) 작은 단위 테스트

```python
A = {1,2,3,4}; R = {(1,2),(2,1),(2,3)}
print(is_equivalence(A,R))                 # False
E = equivalence_closure(A,R)
print(is_equivalence(A,E))                 # True
print(sorted(partition_from_relation(A,E)))# [[1,2,3],[4]]

# 커널 예: 길이 동치
words = ["","a","bb","cc","cat","dog"]
R2, parts2 = kernel_equivalence(words, len)
print(is_equivalence(set(words), R2))  # True
print(parts2)                          # 길이별 블록
```
