---
layout: post
title: AWS - CDK
date: 2025-08-03 16:20:23 +0900
category: AWS
---
# AWS CDK(Cloud Development Kit)

## 0. CDK는 무엇을 해결하나?

- **IaC를 “프로그래밍 언어”로**: CloudFormation을 **언어 추상화**로 감싸 재사용·모듈화·테스트 가능하게 합니다.
- **스택 안전성**: 최종 결과물은 **CloudFormation 템플릿**(변경 세트 + 롤백)을 통해 **안전 배포**됩니다.
- **개발자 생산성**: 타입, IDE 자동완성, 조건/반복/조합 로직을 활용해 복잡한 인프라를 간결하게 모델링합니다.

---

## 1. CDK 핵심 개념 재정리

### 1.1 App / Stack / Construct

- **App**: 하나 이상의 Stack을 담는 루트 컨테이너
- **Stack**: 배포 단위(CloudFormation 스택과 1:1 대응)
- **Construct**: 리소스 추상화. 3계층:
  - **L1**: `Cfn*` (CloudFormation 원형)
  - **L2**: 편의 API가 붙은 고급 리소스(예: `Bucket`, `Table`)
  - **L3**: 여러 리소스를 **패턴**으로 묶은 솔루션

```ts
// TypeScript: 가장 작은 S3 예시
import * as cdk from 'aws-cdk-lib';
import { Bucket } from 'aws-cdk-lib/aws-s3';

export class MyS3Stack extends cdk.Stack {
  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {
    super(scope, id, props);
    new Bucket(this, 'Assets', { versioned: true });
  }
}

const app = new cdk.App();
new MyS3Stack(app, 'MyS3Stack', { env: { account: '123456789012', region: 'ap-northeast-2' }});
```

```py
# Python: 동일 개념
import aws_cdk as cdk
from aws_cdk import aws_s3 as s3

class MyS3Stack(cdk.Stack):
    def __init__(self, scope: cdk.App, id: str, **kwargs):
        super().__init__(scope, id, **kwargs)
        s3.Bucket(self, "Assets", versioned=True)

app = cdk.App()
MyS3Stack(app, "MyS3Stack", env=cdk.Environment(account="123456789012", region="ap-northeast-2"))
app.synth()
```

---

## 2. 설치·부트스트랩·기본 워크플로우

### 2.1 설치 & 초기화

```bash
npm i -g aws-cdk
cd my-cdk && cdk init app --language typescript
npm i aws-cdk-lib constructs
```

Python이라면:

```bash
python -m venv .venv && source .venv/bin/activate
pip install "aws-cdk-lib>=2.*" constructs
cdk init app --language python
```

### 2.2 부트스트랩(필수)

- 자산 업로드용 S3 버킷, IAM 롤 등을 **한 계정/리전에 1회** 설치

```bash
cdk bootstrap aws://123456789012/ap-northeast-2
```

### 2.3 핵심 명령

```bash
cdk synth      # CloudFormation 템플릿 생성
cdk diff       # 기존 스택과 변경 비교
cdk deploy     # 배포(승인 프롬프트/파라미터 검증)
cdk destroy    # 삭제(주의!)
```

---

## 3. 실습 ① S3 → Lambda → DynamoDB (이벤트 드리븐 파이프라인)

요구사항: S3 업로드 이벤트가 오면 Lambda가 메타데이터를 파싱해 DynamoDB에 저장.

### 3.1 TypeScript 코드

```ts
import * as cdk from 'aws-cdk-lib';
import { RemovalPolicy, Duration } from 'aws-cdk-lib';
import { Bucket, EventType } from 'aws-cdk-lib/aws-s3';
import { Table, AttributeType, BillingMode } from 'aws-cdk-lib/aws-dynamodb';
import { Function, Runtime, Code } from 'aws-cdk-lib/aws-lambda';
import { S3EventSource } from 'aws-cdk-lib/aws-lambda-event-sources';

export class IngestStack extends cdk.Stack {
  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const bucket = new Bucket(this, 'IngestBucket', {
      versioned: true,
      removalPolicy: RemovalPolicy.DESTROY,
      autoDeleteObjects: true,
    });

    const table = new Table(this, 'MetaTable', {
      partitionKey: { name: 'objectKey', type: AttributeType.STRING },
      billingMode: BillingMode.PAY_PER_REQUEST,
      removalPolicy: RemovalPolicy.DESTROY,
    });

    const fn = new Function(this, 'IngestFn', {
      runtime: Runtime.NODEJS_20_X,
      handler: 'index.handler',
      code: Code.fromInline(`
        const { DynamoDBClient, PutItemCommand } = require('@aws-sdk/client-dynamodb');
        const ddb = new DynamoDBClient({});
        exports.handler = async (event) => {
          for (const rec of event.Records ?? []) {
            const s3 = rec.s3;
            const key = decodeURIComponent(s3.object.key.replace(/\\+/g, ' '));
            await ddb.send(new PutItemCommand({
              TableName: process.env.TABLE,
              Item: { objectKey: { S: key }, size: { N: String(s3.object.size) } }
            }));
          }
          return { ok: true };
        };
      `),
      timeout: Duration.seconds(10),
      environment: { TABLE: table.tableName },
    });

    fn.addEventSource(new S3EventSource(bucket, { events: [EventType.OBJECT_CREATED] }));
    table.grantWriteData(fn);
    bucket.grantRead(fn);
  }
}
```

### 3.2 Python Lambda로 바꾸기(핸들러만)

```py
import os, json, urllib.parse
import boto3
ddb = boto3.client("dynamodb")
TABLE = os.environ["TABLE"]

def handler(event, context):
    for rec in event.get("Records", []):
        key = urllib.parse.unquote_plus(rec["s3"]["object"]["key"])
        size = rec["s3"]["object"]["size"]
        ddb.put_item(TableName=TABLE, Item={"objectKey": {"S": key}, "size": {"N": str(size)}})
    return {"ok": True}
```

> 포인트
> - **권한 부여는 `grant*` 계열**(L2의 강점). 최소권한으로 안전하게 부여.
> - 버킷/테이블은 개발 편의상 `DESTROY` 설정. **실운영은 `RETAIN` 권장**.

---

## 4. L1/L2/L3 Construct 차이 이해

### 4.1 L1(Cfn*)으로 세밀 제어

```ts
import { CfnBucket } from 'aws-cdk-lib/aws-s3';
new CfnBucket(this, 'RawL1', {
  bucketName: 'my-raw-l1-bucket', // 모든 필드를 직접 명시
  versioningConfiguration: { status: 'Enabled' }
});
```

### 4.2 L2로 안전·간결하게

```ts
import { Bucket } from 'aws-cdk-lib/aws-s3';
new Bucket(this, 'L2Bucket', { versioned: true, enforceSSL: true });
```

### 4.3 L3 패턴(예: ALB + ECS + AutoScaling)

```ts
import { ApplicationLoadBalancedFargateService } from 'aws-cdk-lib/aws-ecs-patterns';
new ApplicationLoadBalancedFargateService(this, 'Web', {
  cpu: 512, memoryLimitMiB: 1024, desiredCount: 2,
  taskImageOptions: { image: ecs.ContainerImage.fromRegistry('nginx') },
  publicLoadBalancer: true
});
```

> 결론: **가능하면 L2/L3**로 시작, 특수 옵션이 필요하면 L1을 **부분 혼용**.

---

## 5. 환경/컨텍스트/파라미터 전략

### 5.1 멀티 계정·리전

```ts
const prodEnv = { account: '111111111111', region: 'ap-northeast-2' };
const stgEnv  = { account: '222222222222', region: 'ap-northeast-1' };

new IngestStack(app, 'Ingest-Stg', { env: stgEnv });
new IngestStack(app, 'Ingest-Prod', { env: prodEnv });
```

### 5.2 Context(앱 수준 설정)

`cdk.json`:

```json
{
  "context": {
    "stage": "dev",
    "alarmEmail": "ops@example.com"
  }
}
```

코드에서:

```ts
const stage = this.node.tryGetContext('stage') ?? 'dev';
```

### 5.3 SSM/Secrets Manager로 민감정보 주입

```ts
import { StringParameter } from 'aws-cdk-lib/aws-ssm';
const apiKey = StringParameter.fromStringParameterAttributes(this, 'ApiKey', {
  parameterName: '/app/apikey',
}).stringValue;
```

---

## 6. 교차 스택(Cross-Stack) 참조와 경계

### 6.1 Stack Props로 전달(느슨하게)

```ts
export interface ApiStackProps extends cdk.StackProps {
  table: Table;
}
```

### 6.2 CfnOutput & ImportValue

- 계정/리전 동일 시 **Output/ImportValue** 로 연결.
- 크로스 계정은 **리소스 공유(SM, RAM)** 고려.

### 6.3 Nested Stack

- 변경 단위를 세분화하고 템플릿 크기 제한 회피.

---

## 7. 권한(보안) 베스트 프랙티스

1. **`grantRead/Write/Put*` 계열**로 최소권한 부여(L2의 강점)
2. **권한 경계(Permissions Boundary)**: 개발 팀 배포 권한을 **상위 경계로 제한**
3. **CDK-Nag**로 보안 룰스캔

```ts
import { AwsSolutionsChecks } from 'cdk-nag';
import { Aspects } from 'aws-cdk-lib';
Aspects.of(app).add(new AwsSolutionsChecks({ verbose: true }));
```

4. **리소스 정책**: S3 퍼블릭 차단, KMS Key 정책 최소화
5. **태깅**: 비용·소유 추적

```ts
import { Tags } from 'aws-cdk-lib';
Tags.of(app).add('Owner', 'Platform');
Tags.of(app).add('Env', 'Prod');
```

---

## 8. 자산 번들 & 빌드 (NodejsFunction / PythonFunction / Docker)

### 8.1 NodejsFunction (esbuild 번들)

```ts
import { NodejsFunction } from 'aws-cdk-lib/aws-lambda-nodejs';
new NodejsFunction(this, 'ApiFn', {
  entry: 'lambda/api.ts', // TypeScript → 번들
  bundling: { minify: true, externalModules: ['aws-sdk'] }
});
```

### 8.2 PythonFunction (pip 종속성)

```ts
import { PythonFunction } from '@aws-cdk/aws-lambda-python-alpha';
new PythonFunction(this, 'PyFn', { entry: 'lambda_py', runtime: Runtime.PYTHON_3_12 });
```

### 8.3 Docker 이미지 기반 Lambda

```ts
import { DockerImageFunction, DockerImageCode } from 'aws-cdk-lib/aws-lambda';
new DockerImageFunction(this, 'ImgFn', {
  code: DockerImageCode.fromImageAsset('lambda-img')
});
```

---

## 9. 고급 통합: API Gateway + Lambda + DynamoDB + Cognito

```ts
import { RestApi, LambdaIntegration, ApiKeySourceType, UsagePlan } from 'aws-cdk-lib/aws-apigateway';
import { UserPool } from 'aws-cdk-lib/aws-cognito';
// 생략: Lambda/DDB 생성

const api = new RestApi(this, 'Rest', { apiKeySourceType: ApiKeySourceType.HEADER });
const resource = api.root.addResource('items');
resource.addMethod('GET', new LambdaIntegration(fn), { apiKeyRequired: false });

// Cognito 인증이 필요한 리소스는 Authorizer 연결(요지)
const pool = new UserPool(this, 'Users', { selfSignUpEnabled: true });

// 요금 제한: UsagePlan(키 기반). Cognito/OIDC Authorizer는 별도 설정
```

---

## 10. Step Functions + CDK (짧은 샘플)

```ts
import * as sfn from 'aws-cdk-lib/aws-stepfunctions';
import * as tasks from 'aws-cdk-lib/aws-stepfunctions-tasks';

const task = new tasks.LambdaInvoke(this, 'Invoke', { lambdaFunction: fn, payloadResponseOnly: true });
const flow = new sfn.StateMachine(this, 'Flow', {
  definition: task.next(new sfn.Succeed(this, 'Done')),
  timeout: cdk.Duration.minutes(5)
});
```

---

## 11. Custom Resource (Lambda-Backed)

- CloudFormation에 없는 동작 수행(외부 API 호출, 커스텀 초기화 등)

```ts
import { Provider } from 'aws-cdk-lib/custom-resources';

const onEvent = new Function(this, 'OnEvent', { /* lambda code */});
const provider = new Provider(this, 'CustomProvider', { onEventHandler: onEvent });

new cdk.CustomResource(this, 'SeedData', {
  serviceToken: provider.serviceToken,
  properties: { tableName: table.tableName }
});
table.grantWriteData(onEvent);
```

---

## 12. 테스트(Assertions) & 스냅샷

### 12.1 Jest + Assertions

```ts
import { Template } from 'aws-cdk-lib/assertions';
test('Lambda Created', () => {
  const app = new cdk.App();
  const stack = new IngestStack(app, 'Test');
  const template = Template.fromStack(stack);
  template.hasResourceProperties('AWS::Lambda::Function', {
    Runtime: 'nodejs20.x'
  });
});
```

### 12.2 스냅샷 테스트

```ts
expect(Template.fromStack(stack).toJSON()).toMatchSnapshot();
```

---

## 13. CI/CD: **CDK Pipelines** (CodePipeline 통합)

- 소스 커밋 → 빌드 → `cdk synth` → `cdk deploy` (스테이지/승인/수동 게이트)

```ts
import { CodePipeline, ShellStep, CodePipelineSource } from 'aws-cdk-lib/pipelines';

const pipeline = new CodePipeline(this, 'Pipe', {
  synth: new ShellStep('Synth', {
    input: CodePipelineSource.gitHub('org/repo', 'main'),
    commands: ['npm ci', 'npm run build', 'npx cdk synth']
  })
});

// 스테이지 구성
class AppStage extends cdk.Stage {
  constructor(scope: cdk.App, id: string, props?: cdk.StageProps) {
    super(scope, id, props);
    new IngestStack(this, 'Ingest', { env: props?.env });
  }
}
pipeline.addStage(new AppStage(this, 'Staging', { env: { account: '222', region: 'ap-northeast-1' }}))
        .addPost(new ShellStep('IntegrationTest', { commands: ['npm run test:int'] }));
```

---

## 14. 관측·로깅·비용 수식 감각

- **CloudWatch 대시보드/지표/알람**: API 에러율, Lambda 지연/오류, DynamoDB 스로틀
- **X-Ray**: 트레이싱 라인업(게이트웨이→Lambda→DDB)
- **비용 근사**
  예) 월 API 호출 수 \(N\), Lambda 평균 기간 \(T\)(초), 메모리 \(M\)(GB), GB-초 단가 \(c\):

$$
\text{Lambda 비용} \approx N \cdot T \cdot M \cdot c \quad (\text{+ 요청 단가})
$$

- S3/CloudFront/Glue 등은 **각 서비스 요금** 합산. CDK 자체 비용은 없음(CloudFormation 사용).

---

## 15. 성숙도 체크리스트

- [ ] `cdk bootstrap`을 **모든 계정/리전**에 완료
- [ ] 스택 **이름/태그 정책** 통일(Owner/CostCenter/Env)
- [ ] **`grant*` 권한**만 사용(수동 IAM 정책 지양)
- [ ] **cdk-nag** 통과(또는 Supression에 사유 기록)
- [ ] **`cdk diff` 를 PR 게이트**로(변경 영향 가시화)
- [ ] **스냅샷/Assertions 테스트** 도입
- [ ] **CDK Pipelines** 로 멀티 스테이지 배포
- [ ] 비밀은 **Secrets Manager / SSM** 에서 주입
- [ ] **Context/파라미터**로 환경별 차이 주입
- [ ] **Retention/RemovalPolicy** 운영 기준 마련

---

## 16. 자주 겪는 문제와 해결

- **“bootstrapping required”**: 대상 계정/리전에 `cdk bootstrap` 미실행
- **에셋 업로드 실패**: 부트스트랩 버킷 정책/키 회전 이슈 → 재부트스트랩 또는 권한 확인
- **교차 계정 배포 실패**: AssumeRole 신뢰정책/권한 경계 확인
- **템플릿 1MB 초과**: Nested Stack/매개변수화/리소스 분해

---

## 17. 실습 ② VPC + ALB + ECS + Route53 + ACM(HTTPS)

요지: L3 패턴으로 신속히 HTTPS 서비스 출고

```ts
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as ecs from 'aws-cdk-lib/aws-ecs';
import { ApplicationLoadBalancedFargateService } from 'aws-cdk-lib/aws-ecs-patterns';
import * as route53 from 'aws-cdk-lib/aws-route53';
import * as certificatemanager from 'aws-cdk-lib/aws-certificatemanager';

const vpc = new ec2.Vpc(this, 'Vpc', { natGateways: 1 });
const zone = route53.HostedZone.fromLookup(this, 'Zone', { domainName: 'example.com' });
const cert = new certificatemanager.DnsValidatedCertificate(this, 'Cert', {
  domainName: 'app.example.com', hostedZone: zone, region: 'us-east-1' // ALB는 리전 인증서
});

const svc = new ApplicationLoadBalancedFargateService(this, 'Svc', {
  vpc,
  certificate: cert,
  domainName: 'app.example.com',
  domainZone: zone,
  taskImageOptions: { image: ecs.ContainerImage.fromRegistry('public.ecr.aws/nginx/nginx:stable') },
  desiredCount: 2,
});
svc.targetGroup.configureHealthCheck({ path: '/', healthyThresholdCount: 2 });
```

---

## 18. 운영 정책(삭제/백업/DR)

- **RemovalPolicy.RETAIN**: 데이터 리소스(Prod RDS/Dynamo/S3)
- 백업: DynamoDB PITR, RDS 자동/수동 스냅샷, S3 버전/수명주기
- DR: 멀티 리전 Route53 헬스 체크 + 자동 페일오버, IaC로 **리전 재현 가능**

---

## 19. Terraform/CloudFormation 사용자 이행 팁

- 기존 템플릿은 **직접 변환 불가** → **CfnInclude** 로 부분 흡수하거나, 점진적으로 L2로 이관
- 모듈 개념은 **Construct Library** 로 매핑
- 파이프라인은 CDK Pipelines 또는 기존 CI에서 **`cdk synth/deploy`** 호출

---

## 20. 마무리

CDK는 인프라를 **코드 자산**으로 관리하게 해 주며, **재사용/테스트/검증/자동배포**의 개발 문화를 인프라에도 적용합니다.
본 가이드의 실전 구성(이벤트 파이프라인, API 백엔드, ECS 서비스), **권한/보안/비용** 원칙, **테스트/파이프라인** 예시를 기반으로 팀 표준을 정립하세요.

> 다음 단계 제안
> 1) 조직 공통 **Base Construct**(VPC, 표준 태그, 경계정책) 제작
> 2) `cdk-nag` + PR 게이트(Diff/테스트)로 **보안·품질 바** 고정
> 3) 멀티계정 CDK Pipelines로 **완전 자동화** 배포

---
### 부록 A) 명령 치트시트

```bash
# 설치/초기화
npm i -g aws-cdk
cdk init app --language typescript
npm i aws-cdk-lib constructs

# 계정/리전 부트스트랩
cdk bootstrap aws://123456789012/ap-northeast-2

# 생성/검토/배포/삭제
cdk synth
cdk diff
cdk deploy
cdk destroy

# 특정 스택만
cdk deploy MyS3Stack
```

### 부록 B) 비용 근사 수식 예시

- ALB 시간 단가 \(a\), 월 시간 \(H\), 데이터 전송 \(D\)GB, GB 단가 \(g\):

$$
\text{ALB비용} \approx a \cdot H + D \cdot g
$$

- ECS Fargate: vCPU 시간 \(C\), GB-메모리 시간 \(M\), 단가 \(c_f, m_f\):

$$
\text{Fargate비용} \approx C \cdot c_f + M \cdot m_f
$$

> 이 근사식으로 설계 전 **대략 비용 가늠 → 부하 테스트로 보정**하세요.

---
### 부록 C) 참고 패키지

- `aws-cdk-lib` / `constructs` (필수)
- `cdk-nag` (보안 규칙 점검)
- `aws-cdk-lib/assertions` (테스트)
- `aws-lambda-nodejs` / `@aws-cdk/aws-lambda-python-alpha` (번들링)
- `aws-cdk-lib/pipelines` (CDK Pipelines)
