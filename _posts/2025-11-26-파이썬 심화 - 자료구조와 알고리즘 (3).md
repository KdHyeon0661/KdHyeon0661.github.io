---
layout: post
title: 파이썬 심화 - 자료구조와 알고리즘 (3)
date: 2025-11-26 16:25:23 +0900
category: 파이썬 심화
---
# 자료구조와 알고리즘 (3)

데이터를 효율적으로 처리하고 변환하는 것은 현대 프로그래밍에서 핵심적인 기술입니다. 파이썬은 다양한 데이터 조작 기법을 제공하여 복잡한 작업을 간결하고 효율적으로 처리할 수 있습니다.

## 시퀀스 필터링

리스트, 튜플, 세트 등의 시퀀스에서 조건에 맞는 요소만 추출하는 작업은 데이터 처리의 기본입니다. 여러 가지 방법으로 시퀀스를 필터링할 수 있습니다.

```python
# 1. 리스트 컴프리헨션을 이용한 필터링 (가장 일반적인 방법)
numbers = [1, 4, -5, 10, -7, 2, 3, -1]
positive_numbers = [n for n in numbers if n > 0]
negative_numbers = [n for n in numbers if n < 0]

# 복잡한 조건 필터링
values = ['1', '2', '-3', '-', '4', 'N/A', '5']
def is_int(val):
    try:
        x = int(val)
        return True
    except ValueError:
        return False

int_values = [int(v) for v in values if is_int(v)]

# 2. filter() 함수 활용 (데이터가 매우 클 때 유용)
positive_numbers = list(filter(lambda x: x > 0, numbers))

# 3. itertools.compress() - 한 시퀀스의 불리언 값으로 다른 시퀀스 필터링
addresses = [
    '5412 N CLARK',
    '5148 N CLARK',
    '5800 E 58TH',
    '2122 N CLARK',
    '5645 N RAVENSWOOD',
    '1060 W ADDISON',
    '4801 N BROADWAY',
    '1039 W GRANVILLE',
]
counts = [0, 3, 10, 4, 1, 7, 6, 1]

from itertools import compress
more5 = [n > 5 for n in counts]
filtered_addresses = list(compress(addresses, more5))
```

## 딕셔너리의 부분 추출

큰 딕셔너리에서 필요한 부분만 추출하는 작업은 메모리 효율성과 성능 측면에서 중요합니다.

```python
prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75,
    'GOOGL': 1520.42,
    'AMZN': 3201.88,
    'TSLA': 810.67
}

# 딕셔너리 컴프리헨션을 사용한 부분 추출
# 1. 특정 값 이상의 항목만 추출
tech_stocks = {key: value for key, value in prices.items() if value > 200}

# 2. 특정 키 패턴에 맞는 항목 추출
tech_companies = {key: value for key, value in prices.items() 
                  if key in {'AAPL', 'GOOGL', 'AMZN', 'FB'}}

# 3. 복합 조건으로 필터링
mid_priced = {key: value for key, value in prices.items() 
              if 100 < value < 1000}

# 4. 값 변환과 필터링 동시에 수행
discounted = {key: value * 0.9 for key, value in prices.items() 
              if value > 50}

# dict() 생성자와 튜플 사용 (파이썬 2 호환 방식)
p1 = dict((key, value) for key, value in prices.items() if value > 200)
```

## 시퀀스 요소에 이름 매핑: 네임드튜플

인덱스로만 접근하는 일반 튜플 대신 필드 이름으로 접근할 수 있는 네임드튜플은 코드 가독성을 크게 향상시킵니다.

```python
from collections import namedtuple

# 1. 기본적인 네임드튜플 정의
Person = namedtuple('Person', ['name', 'age', 'gender', 'occupation'])

# 인스턴스 생성
p1 = Person('김철수', 30, '남성', '개발자')
p2 = Person(name='이영희', age=28, gender='여성', occupation='디자이너')

# 필드 이름으로 접근
print(p1.name)      # 김철수
print(p2.occupation) # 디자이너

# 2. 기본값이 있는 네임드튜플
Employee = namedtuple('Employee', ['name', 'department', 'salary'])
Employee.__new__.__defaults__ = ('미정', 0)  # department와 salary의 기본값

emp1 = Employee('홍길동')
print(emp1)  # Employee(name='홍길동', department='미정', salary=0)

# 3. 딕셔너리로부터 생성
data = {'name': '박지민', 'age': 35, 'gender': '남성', 'occupation': '매니저'}
p3 = Person(**data)

# 4. 튜플과의 호환성
point_tuple = (10, 20)
Point = namedtuple('Point', ['x', 'y'])
p = Point._make(point_tuple)
print(p.x, p.y)  # 10 20

# 5. 불변성 유지 (필드 값 변경 시 새 인스턴스 생성)
p4 = p1._replace(age=31)
print(p1.age)  # 30 (원본은 변경되지 않음)
print(p4.age)  # 31 (새 인스턴스)
```

## 데이터 변환과 축소

데이터를 변환하면서 동시에 요약하거나 축소하는 작업은 데이터 분석에서 자주 사용됩니다.

```python
# 1. sum()과 제너레이터 표현식으로 메모리 효율적으로 계산
nums = [1, 2, 3, 4, 5]
sum_of_squares = sum(x * x for x in nums)  # 제너레이터 사용 (메모리 효율적)

# 2. 여러 데이터 변환 파이프라인
portfolio = [
    {'name': 'GOOG', 'shares': 50, 'price': 490.1},
    {'name': 'YHOO', 'shares': 75, 'price': 23.45},
    {'name': 'AOL', 'shares': 20, 'price': 45.0},
    {'name': 'SCOX', 'shares': 65, 'price': 20.75}
]

# 최소 주가 계산
min_price = min(item['price'] for item in portfolio)

# 최대 가치 계산
max_value = max(item['shares'] * item['price'] for item in portfolio)

# 딕셔너리로 변환하면서 특정 조건으로 필터링
tech_names = {'GOOG', 'YHOO', 'AOL'}
tech_portfolio = {item['name']: item for item in portfolio 
                  if item['name'] in tech_names}

# 3. reduce() 함수를 사용한 누적 연산
from functools import reduce

# 모든 상품의 총 가치 계산
total_value = reduce(lambda total, item: total + item['shares'] * item['price'], 
                     portfolio, 0)

# 계층적 데이터 구조 평탄화
nested_data = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]
flattened = reduce(lambda x, y: x + y, nested_data, [])
```

## 여러 매핑을 단일 매핑으로 통합

여러 개의 딕셔너리나 매핑을 하나로 합쳐야 할 때, `ChainMap`이나 딕셔너리 업데이트를 활용할 수 있습니다.

```python
from collections import ChainMap

# 1. ChainMap을 사용한 매핑 통합
defaults = {
    'theme': 'dark',
    'language': 'ko',
    'font_size': 14,
    'timeout': 30
}

user_settings = {
    'theme': 'light',
    'font_size': 16
}

system_settings = {
    'timeout': 60,
    'debug_mode': True
}

# ChainMap 생성 (검색 순서: user_settings → system_settings → defaults)
config = ChainMap(user_settings, system_settings, defaults)

print(config['theme'])     # 'light' (user_settings에서)
print(config['debug_mode']) # True (system_settings에서)
print(config['language'])   # 'ko' (defaults에서)

# 새로운 설정 추가
config = config.new_child({'theme': 'blue', 'notifications': True})

# 2. 딕셔너리 업데이트를 통한 통합 (Python 3.9+)
merged = defaults.copy()
merged.update(system_settings)
merged.update(user_settings)

# 또는 | 연산자 사용 (Python 3.9+)
merged = defaults | system_settings | user_settings

# 3. 중첩된 딕셔너리 통합 함수
def deep_merge(dict1, dict2):
    """재귀적으로 딕셔너리를 병합"""
    result = dict1.copy()
    for key, value in dict2.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = deep_merge(result[key], value)
        else:
            result[key] = value
    return result

nested1 = {'database': {'host': 'localhost', 'port': 3306}}
nested2 = {'database': {'user': 'admin', 'password': 'secret'}}
merged_db = deep_merge(nested1, nested2)
```

## 결론

파이썬의 데이터 조작 기법들은 단순한 문법적 편의를 넘어서 성능 최적화와 코드 유지보수성 측면에서 중요한 가치를 제공합니다. 시퀀스 필터링은 메모리 효율적인 데이터 처리를 가능하게 하며, 딕셔너리 부분 추출은 대용량 데이터에서 필요한 정보만 신속하게 접근할 수 있게 합니다. 네임드튜플은 데이터 구조의 가독성을 높이고, 데이터 변환과 축소 작업은 복잡한 계산을 간결하게 표현합니다. 여러 매핑의 통합은 설정 관리나 데이터 계층화에 유용합니다.

이러한 기법들을 적절히 활용하면 데이터 중심 애플리케이션의 성능을 크게 향상시키고, 코드의 명확성과 유지보수성을 높일 수 있습니다. 각 상황에 맞는 최적의 방법을 선택하는 것이 효율적인 파이썬 프로그래밍의 핵심입니다.