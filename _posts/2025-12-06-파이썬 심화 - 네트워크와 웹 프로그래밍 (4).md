---
layout: post
title: 파이썬 심화 - 네트워크와 웹 프로그래밍 (4)
date: 2025-12-06 14:30:23 +0900
category: 파이썬 심화
---
# 네트워크와 웹 프로그래밍 (4)

## 프로세스 간 소켓 파일 디스크립터 전달

파이썬에서 프로세스 간에 소켓 파일 디스크립터를 전달하는 것은 고성능 서버 아키텍처에서 매우 중요한 기술입니다. 이를 통해 부모 프로세스가 생성한 연결을 자식 프로세스가 직접 상속받아 사용할 수 있어, 연결 재설정 없이 로드 밸런싱이 가능합니다.

### Unix 도메인 소켓을 통한 파일 디스크립터 전달

```python
import os
import socket
import struct
import json
from typing import Optional, Any
import multiprocessing
import select
import time

class SocketDescriptorPasser:
    """소켓 파일 디스크립터 전달 클래스"""
    
    def __init__(self, socket_path: str = '/tmp/fd_passer.sock'):
        self.socket_path = socket_path
        self.uds_socket = None
        
    def send_fd(self, fd: int, metadata: Optional[dict] = None) -> bool:
        """
        파일 디스크립터를 Unix 도메인 소켓을 통해 전송
        
        Args:
            fd: 전송할 파일 디스크립터
            metadata: 함께 전송할 메타데이터
            
        Returns:
            성공 여부
        """
        try:
            # Unix 도메인 소켓 생성
            self.uds_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.uds_socket.connect(self.socket_path)
            
            # 메타데이터 준비
            meta = metadata or {}
            meta['fd'] = fd
            meta_bytes = json.dumps(meta).encode('utf-8')
            meta_len = struct.pack('!I', len(meta_bytes))
            
            # 메타데이터 길이 전송
            self.uds_socket.sendall(meta_len)
            # 메타데이터 본문 전송
            self.uds_socket.sendall(meta_bytes)
            
            # 파일 디스크립터 전송 (ancillary data)
            # SOL_SOCKET 레벨에서 SCM_RIGHTS 메시지 전송
            self.uds_socket.sendmsg(
                [b' '],  # 데이터 (빈 바이트)
                [(socket.SOL_SOCKET, socket.SCM_RIGHTS, struct.pack('i', fd))]
            )
            
            print(f"파일 디스크립터 {fd} 전송 완료")
            return True
            
        except Exception as e:
            print(f"파일 디스크립터 전송 실패: {e}")
            return False
        finally:
            if self.uds_socket:
                self.uds_socket.close()
    
    @staticmethod
    def receive_fd(socket_path: str = '/tmp/fd_passer.sock', 
                   timeout: float = 30.0) -> tuple:
        """
        Unix 도메인 소켓에서 파일 디스크립터 수신
        
        Returns:
            (파일 디스크립터, 메타데이터) 튜플
        """
        server_socket = None
        try:
            # 기존 소켓 파일 삭제
            if os.path.exists(socket_path):
                os.unlink(socket_path)
            
            # Unix 도메인 소켓 서버 생성
            server_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            server_socket.bind(socket_path)
            server_socket.listen(1)
            server_socket.settimeout(timeout)
            
            print(f"파일 디스크립터 수신 대기 중: {socket_path}")
            
            # 클라이언트 연결 대기
            client_socket, _ = server_socket.accept()
            
            # 메타데이터 길이 수신
            meta_len_bytes = client_socket.recv(4)
            if len(meta_len_bytes) < 4:
                raise ValueError("메타데이터 길이 수신 실패")
            
            meta_len = struct.unpack('!I', meta_len_bytes)[0]
            
            # 메타데이터 본문 수신
            meta_bytes = b''
            while len(meta_bytes) < meta_len:
                chunk = client_socket.recv(meta_len - len(meta_bytes))
                if not chunk:
                    raise ValueError("메타데이터 수신 중 연결 끊김")
                meta_bytes += chunk
            
            metadata = json.loads(meta_bytes.decode('utf-8'))
            
            # 파일 디스크립터 수신 (ancillary data)
            # recvmsg는 최대 1개의 ancillary data 항목을 수신
            data, ancdata, flags, addr = client_socket.recvmsg(1, socket.CMSG_SPACE(4))
            
            fd = None
            for cmsg_level, cmsg_type, cmsg_data in ancdata:
                if cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS:
                    # 전송된 파일 디스크립터 추출
                    fd = struct.unpack('i', cmsg_data)[0]
                    break
            
            if fd is None:
                raise ValueError("파일 디스크립터 수신 실패")
            
            print(f"파일 디스크립터 {fd} 수신 완료")
            return fd, metadata
            
        except socket.timeout:
            print(f"타임아웃: {timeout}초 동안 연결 없음")
            return None, None
        except Exception as e:
            print(f"파일 디스크립터 수신 실패: {e}")
            return None, None
        finally:
            if server_socket:
                server_socket.close()
            # 소켓 파일 정리
            if os.path.exists(socket_path):
                os.unlink(socket_path)

# 다중 프로세스 워커와 파일 디스크립터 공유 예시
class WorkerProcess(multiprocessing.Process):
    """파일 디스크립터를 받아 처리하는 워커 프로세스"""
    
    def __init__(self, worker_id: int, socket_path: str):
        super().__init__()
        self.worker_id = worker_id
        self.socket_path = socket_path
        
    def run(self):
        """워커 프로세스 실행"""
        print(f"워커 {self.worker_id} 시작")
        
        # 파일 디스크립터 수신
        fd, metadata = SocketDescriptorPasser.receive_fd(self.socket_path)
        
        if fd is not None:
            # 수신한 파일 디스크립터로 소켓 객체 생성
            client_socket = socket.socket(fileno=fd)
            
            # 소켓 사용 예: 클라이언트에게 응답 전송
            try:
                client_socket.sendall(
                    f"워커 {self.worker_id}에서 처리됨\n".encode('utf-8')
                )
                
                # 데이터 수신 (예시)
                data = client_socket.recv(1024)
                if data:
                    print(f"워커 {self.worker_id} 수신: {data.decode('utf-8')}")
                    
            finally:
                client_socket.close()
        
        print(f"워커 {self.worker_id} 종료")

# 마스터 프로세스 예시
def master_process_example():
    """마스터 프로세스에서 워커들에게 소켓 디스크립터 분배"""
    
    # TCP 서버 소켓 생성
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(('127.0.0.1', 9000))
    server_socket.listen(5)
    
    print("마스터 프로세스 시작, TCP 서버 포트 9000")
    
    # 워커 프로세스들 생성
    workers = []
    for i in range(3):
        worker = WorkerProcess(worker_id=i, socket_path=f'/tmp/worker_{i}.sock')
        worker.start()
        workers.append(worker)
        time.sleep(0.1)  # 워커가 준비될 시간을 줌
    
    try:
        while True:
            # 클라이언트 연결 대기
            client_socket, client_address = server_socket.accept()
            print(f"새 클라이언트 연결: {client_address}")
            
            # 라운드 로빈 방식으로 워커 선택
            worker_idx = len(workers) % 3
            worker_socket_path = f'/tmp/worker_{worker_idx}.sock'
            
            # 파일 디스크립터 전송
            passer = SocketDescriptorPasser(worker_socket_path)
            passer.send_fd(client_socket.fileno(), {
                'client_address': client_address,
                'timestamp': time.time()
            })
            
            # 마스터에서 소켓 닫기 (워커가 소유권을 가짐)
            client_socket.close()
            
    except KeyboardInterrupt:
        print("마스터 프로세스 종료")
    finally:
        server_socket.close()
        for worker in workers:
            worker.join()
```

## 이벤트 기반 입출력의 이해와 구현

이벤트 기반 입출력(I/O Multiplexing)은 단일 스레드에서 여러 소켓의 입출력을 효율적으로 관리하는 패턴입니다. `select`, `poll`, `epoll`, `kqueue` 등의 시스템 호출을 활용합니다.

### 다양한 I/O 멀티플렉싱 기법 구현

```python
import select
import socket
import queue
from typing import Dict, List, Tuple, Set
import threading
import time

class EventDrivenServer:
    """이벤트 기반 서버 기본 구현"""
    
    def __init__(self, host: str = '127.0.0.1', port: int = 8080):
        self.host = host
        self.port = port
        self.server_socket = None
        self.inputs = []  # 읽기 이벤트 감지 소켓들
        self.outputs = []  # 쓰기 이벤트 감지 소켓들
        self.message_queues: Dict[socket.socket, queue.Queue] = {}
        self.client_data: Dict[socket.socket, dict] = {}
        
    def setup_server(self):
        """서버 소켓 설정"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.setblocking(False)  # 논블로킹 모드
        self.server_socket.bind((self.host, self.port))
        self.server_socket.listen(5)
        
        self.inputs.append(self.server_socket)
        print(f"이벤트 기반 서버 시작: {self.host}:{self.port}")
    
    def handle_readable(self, readable_sockets):
        """읽기 가능 소켓 처리"""
        for sock in readable_sockets:
            if sock is self.server_socket:
                # 새로운 클라이언트 연결
                client_socket, client_address = sock.accept()
                client_socket.setblocking(False)
                self.inputs.append(client_socket)
                self.client_data[client_socket] = {
                    'address': client_address,
                    'connected_at': time.time(),
                    'bytes_received': 0
                }
                print(f"새 클라이언트 연결: {client_address}")
            else:
                # 기존 클라이언트 데이터 수신
                try:
                    data = sock.recv(4096)
                    if data:
                        # 데이터 처리
                        self.process_client_data(sock, data)
                        
                        # 응답 큐에 추가
                        if sock not in self.outputs:
                            self.outputs.append(sock)
                    else:
                        # 연결 종료
                        self.cleanup_client(sock)
                        
                except ConnectionResetError:
                    self.cleanup_client(sock)
    
    def handle_writable(self, writable_sockets):
        """쓰기 가능 소켓 처리"""
        for sock in writable_sockets:
            try:
                # 메시지 큐에서 다음 메시지 가져오기
                next_msg = self.message_queues.get(sock, None)
                if next_msg is not None:
                    sent = sock.send(next_msg)
                    if sent < len(next_msg):
                        # 일부만 전송된 경우 나머지를 큐에 유지
                        self.message_queues[sock] = next_msg[sent:]
                    else:
                        # 전체 전송 완료
                        if sock in self.outputs:
                            self.outputs.remove(sock)
                else:
                    # 전송할 메시지 없음
                    if sock in self.outputs:
                        self.outputs.remove(sock)
                        
            except (ConnectionResetError, BrokenPipeError):
                self.cleanup_client(sock)
    
    def handle_exceptional(self, exceptional_sockets):
        """예외 상황 소켓 처리"""
        for sock in exceptional_sockets:
            print(f"예외 상황 소켓: {sock.getpeername() if sock != self.server_socket else '서버'}")
            self.cleanup_client(sock)
    
    def process_client_data(self, sock: socket.socket, data: bytes):
        """클라이언트 데이터 처리"""
        client_info = self.client_data.get(sock, {})
        client_info['bytes_received'] = client_info.get('bytes_received', 0) + len(data)
        
        # 에코 서버 예시: 받은 데이터를 그대로 반환
        response = f"에코: {data.decode('utf-8', errors='ignore')}"
        
        # 응답 큐에 추가
        if sock not in self.message_queues:
            self.message_queues[sock] = queue.Queue()
        
        self.message_queues[sock].put(response.encode('utf-8'))
    
    def cleanup_client(self, sock: socket.socket):
        """클라이언트 연결 정리"""
        if sock in self.inputs:
            self.inputs.remove(sock)
        if sock in self.outputs:
            self.outputs.remove(sock)
        
        client_info = self.client_data.pop(sock, {})
        if client_info:
            duration = time.time() - client_info['connected_at']
            print(f"클라이언트 종료: {client_info['address']}, "
                  f"수신: {client_info['bytes_received']}바이트, "
                  f"연결시간: {duration:.2f}초")
        
        sock.close()
    
    def run_with_select(self, timeout: float = 1.0):
        """select를 사용한 이벤트 루프"""
        self.setup_server()
        
        try:
            while self.inputs:
                # I/O 이벤트 대기
                readable, writable, exceptional = select.select(
                    self.inputs, self.outputs, self.inputs, timeout
                )
                
                # 각 이벤트 처리
                self.handle_readable(readable)
                self.handle_writable(writable)
                self.handle_exceptional(exceptional)
                
        except KeyboardInterrupt:
            print("서버 종료 요청")
        finally:
            self.cleanup_server()
    
    def cleanup_server(self):
        """서버 정리"""
        for sock in self.inputs:
            if sock != self.server_socket:
                self.cleanup_client(sock)
        
        if self.server_socket:
            self.server_socket.close()
        print("서버 종료 완료")

# 고성능 epoll/kqueue 서버 (Linux/macOS)
class HighPerformanceEventServer(EventDrivenServer):
    """epoll/kqueue를 사용한 고성능 이벤트 서버"""
    
    def run_with_epoll(self):
        """epoll을 사용한 이벤트 루프 (Linux 전용)"""
        try:
            import selectors
            # 시스템에 최적의 셀렉터 선택
            selector = selectors.DefaultSelector()
            
            self.setup_server()
            selector.register(self.server_socket, selectors.EVENT_READ, data=None)
            
            print("epoll 기반 서버 실행 중...")
            
            while True:
                events = selector.select(timeout=1.0)
                
                for key, mask in events:
                    sock = key.fileobj
                    
                    if mask & selectors.EVENT_READ:
                        if sock is self.server_socket:
                            # 새 연결
                            client_socket, addr = sock.accept()
                            client_socket.setblocking(False)
                            selector.register(client_socket, selectors.EVENT_READ, data=addr)
                            self.client_data[client_socket] = {
                                'address': addr,
                                'buffer': b''
                            }
                        else:
                            # 데이터 수신
                            try:
                                data = sock.recv(4096)
                                if data:
                                    self.process_with_epoll(sock, data, selector)
                                else:
                                    # 연결 종료
                                    selector.unregister(sock)
                                    sock.close()
                            except:
                                selector.unregister(sock)
                                sock.close()
                    
                    elif mask & selectors.EVENT_WRITE:
                        # 쓰기 가능 시 처리
                        self.handle_epoll_write(sock, selector)
                        
        except ImportError:
            print("이 시스템은 epoll을 지원하지 않습니다.")
            self.run_with_select()
    
    def process_with_epoll(self, sock: socket.socket, data: bytes, selector):
        """epoll용 데이터 처리"""
        # 데이터를 버퍼에 추가
        client_info = self.client_data.get(sock, {})
        client_info['buffer'] = client_info.get('buffer', b'') + data
        
        # 완전한 메시지가 도착했는지 확인 (예: 줄바꿈으로 구분)
        if b'\n' in client_info['buffer']:
            messages = client_info['buffer'].split(b'\n')
            # 마지막 불완전 메시지는 버퍼에 유지
            client_info['buffer'] = messages.pop() if messages[-1] else b''
            
            for msg in messages:
                if msg:
                    response = f"처리완료: {msg.decode('utf-8')}\n"
                    sock.send(response.encode('utf-8'))
        
        # 더 많은 데이터를 기다리도록 읽기 이벤트 유지
```

## 대용량 배열 전송 최적화 기법

대용량 데이터(특히 numpy 배열과 같은 과학 계산 데이터)를 효율적으로 전송하기 위한 다양한 기법을 살펴봅니다.

```python
import socket
import struct
import numpy as np
import pickle
import zlib
import lz4.frame
import threading
from typing import Union, Optional
import hashlib
import time

class ArrayTransmitter:
    """대용량 배열 전송 클래스"""
    
    def __init__(self, compression: str = 'none', chunk_size: int = 65536):
        """
        Args:
            compression: 압축 방식 ('none', 'zlib', 'lz4')
            chunk_size: 청크 크기 (바이트)
        """
        self.compression = compression
        self.chunk_size = chunk_size
        self.compression_methods = {
            'none': self._compress_none,
            'zlib': self._compress_zlib,
            'lz4': self._compress_lz4
        }
        self.decompression_methods = {
            'none': self._decompress_none,
            'zlib': self._decompress_zlib,
            'lz4': self._decompress_lz4
        }
    
    def _compress_none(self, data: bytes) -> bytes:
        """압축 없음"""
        return data
    
    def _decompress_none(self, data: bytes) -> bytes:
        """압축 해제 없음"""
        return data
    
    def _compress_zlib(self, data: bytes, level: int = 6) -> bytes:
        """zlib 압축"""
        return zlib.compress(data, level=level)
    
    def _decompress_zlib(self, data: bytes) -> bytes:
        """zlib 압축 해제"""
        return zlib.decompress(data)
    
    def _compress_lz4(self, data: bytes) -> bytes:
        """LZ4 압축"""
        return lz4.frame.compress(data)
    
    def _decompress_lz4(self, data: bytes) -> bytes:
        """LZ4 압축 해제"""
        return lz4.frame.decompress(data)
    
    def send_array(self, sock: socket.socket, array: np.ndarray, 
                   metadata: Optional[dict] = None) -> bool:
        """
        소켓을 통해 배열 전송
        
        Returns:
            전송 성공 여부
        """
        try:
            # 1. 배열 정보 수집
            array_info = {
                'dtype': str(array.dtype),
                'shape': array.shape,
                'itemsize': array.itemsize,
                'ndim': array.ndim
            }
            
            if metadata:
                array_info.update(metadata)
            
            # 2. 배열 데이터 직렬화
            # memoryview를 사용하여 버퍼 접근 (복사 방지)
            array_bytes = array.tobytes()
            
            # 3. 체크섬 계산
            checksum = hashlib.sha256(array_bytes).digest()
            
            # 4. 헤더 구성
            header = {
                'array_info': array_info,
                'data_length': len(array_bytes),
                'compression': self.compression,
                'checksum': checksum.hex(),
                'chunk_size': self.chunk_size
            }
            
            # 5. 헤더 직렬화 및 전송
            header_bytes = pickle.dumps(header)
            header_len = struct.pack('!Q', len(header_bytes))  # 8바이트 부호없는 정수
            
            sock.sendall(header_len)
            sock.sendall(header_bytes)
            
            # 6. 데이터 압축
            compress_func = self.compression_methods.get(self.compression, self._compress_none)
            compressed_data = compress_func(array_bytes)
            
            # 7. 청크 단위로 데이터 전송
            total_sent = 0
            data_len = len(compressed_data)
            
            # 데이터 길이 전송
            sock.sendall(struct.pack('!Q', data_len))
            
            while total_sent < data_len:
                chunk = compressed_data[total_sent:total_sent + self.chunk_size]
                sent = sock.send(chunk)
                if sent == 0:
                    raise RuntimeError("소켓 연결 끊김")
                total_sent += sent
            
            print(f"배열 전송 완료: {array.shape}, {array.nbytes:,}바이트 -> {data_len:,}바이트 (압축)")
            return True
            
        except Exception as e:
            print(f"배열 전송 실패: {e}")
            return False
    
    def receive_array(self, sock: socket.socket, timeout: float = 30.0) -> Optional[np.ndarray]:
        """
        소켓에서 배열 수신
        
        Returns:
            수신된 numpy 배열 또는 None
        """
        sock.settimeout(timeout)
        
        try:
            # 1. 헤더 길이 수신
            header_len_bytes = sock.recv(8)
            if len(header_len_bytes) < 8:
                return None
            
            header_len = struct.unpack('!Q', header_len_bytes)[0]
            
            # 2. 헤더 데이터 수신
            header_bytes = b''
            while len(header_bytes) < header_len:
                chunk = sock.recv(min(4096, header_len - len(header_bytes)))
                if not chunk:
                    return None
                header_bytes += chunk
            
            header = pickle.loads(header_bytes)
            array_info = header['array_info']
            compression = header.get('compression', 'none')
            expected_checksum = header.get('checksum')
            chunk_size = header.get('chunk_size', self.chunk_size)
            
            # 3. 압축된 데이터 길이 수신
            data_len_bytes = sock.recv(8)
            if len(data_len_bytes) < 8:
                return None
            
            data_len = struct.unpack('!Q', data_len_bytes)[0]
            
            # 4. 데이터 수신 (청크 단위)
            compressed_data = b''
            total_received = 0
            
            while total_received < data_len:
                chunk = sock.recv(min(chunk_size, data_len - total_received))
                if not chunk:
                    raise RuntimeError("데이터 수신 중 연결 끊김")
                compressed_data += chunk
                total_received += len(chunk)
            
            print(f"데이터 수신 완료: {total_received:,}바이트")
            
            # 5. 데이터 압축 해제
            decompress_func = self.decompression_methods.get(compression, self._decompress_none)
            array_bytes = decompress_func(compressed_data)
            
            # 6. 체크섬 검증
            actual_checksum = hashlib.sha256(array_bytes).hexdigest()
            if expected_checksum and actual_checksum != expected_checksum:
                print(f"체크섬 불일치: {actual_checksum} != {expected_checksum}")
                return None
            
            # 7. 배열 재구성
            dtype = np.dtype(array_info['dtype'])
            array = np.frombuffer(array_bytes, dtype=dtype)
            array = array.reshape(array_info['shape'])
            
            print(f"배열 수신 완료: {array.shape}, {array.nbytes:,}바이트")
            return array
            
        except socket.timeout:
            print(f"배열 수신 타임아웃: {timeout}초")
            return None
        except Exception as e:
            print(f"배열 수신 실패: {e}")
            return None

# 성능 비교를 위한 벤치마크 클래스
class TransmissionBenchmark:
    """배열 전송 방식별 성능 비교"""
    
    @staticmethod
    def benchmark_array_transmission(array_size: tuple = (1000, 1000)):
        """다양한 전송 방식 성능 비교"""
        
        # 테스트 배열 생성
        array = np.random.randn(*array_size).astype(np.float32)
        print(f"테스트 배열: {array.shape}, {array.nbytes:,}바이트")
        
        # 로컬 소켓 생성 (실제 네트워크 없이 테스트)
        import tempfile
        import os
        
        # Unix 도메인 소켓 사용
        sock_path = tempfile.mktemp()
        
        # 서버 소켓 생성
        server_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        server_socket.bind(sock_path)
        server_socket.listen(1)
        
        def server_thread_func(transmitter, result_container):
            """서버 스레드"""
            conn, _ = server_socket.accept()
            received_array = transmitter.receive_array(conn)
            conn.close()
            result_container['array'] = received_array
        
        # 각 전송 방식 테스트
        methods = [
            ('none', '압축 없음'),
            ('zlib', 'zlib 압축'),
            ('lz4', 'LZ4 압축')
        ]
        
        results = []
        for comp_method, comp_name in methods:
            # 전송기 생성
            transmitter = ArrayTransmitter(compression=comp_method)
            
            # 클라이언트 소켓
            client_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            
            # 결과 저장소
            server_result = {'array': None}
            
            # 서버 스레드 시작
            server_thread = threading.Thread(
                target=server_thread_func,
                args=(transmitter, server_result)
            )
            server_thread.start()
            time.sleep(0.1)  # 서버가 준비될 시간
            
            # 클라이언트 연결
            client_socket.connect(sock_path)
            
            # 전송 시간 측정
            start_time = time.time()
            success = transmitter.send_array(client_socket, array)
            client_socket.close()
            
            server_thread.join()
            
            end_time = time.time()
            transmission_time = end_time - start_time
            
            # 결과 검증
            received_array = server_result['array']
            if received_array is not None:
                is_correct = np.allclose(array, received_array, rtol=1e-5)
                compression_ratio = array.nbytes / len(zlib.compress(array.tobytes()) if comp_method == 'zlib' else array.nbytes)
            else:
                is_correct = False
                compression_ratio = 0
            
            results.append({
                'method': comp_name,
                'time': transmission_time,
                'success': success and is_correct,
                'compression_ratio': compression_ratio
            })
        
        # 서버 소켓 정리
        server_socket.close()
        os.unlink(sock_path)
        
        # 결과 출력
        print("\n=== 전송 방식별 성능 비교 ===")
        for result in results:
            print(f"{result['method']}:")
            print(f"  시간: {result['time']:.3f}초")
            print(f"  성공: {result['success']}")
            print(f"  압축률: {result['compression_ratio']:.2f}x")
        
        return results
```

## 결론

프로세스 간 통신과 대용량 데이터 전송을 효과적으로 구현하기 위한 핵심 원칙을 정리합니다:

### 1. 파일 디스크립터 전달의 전략적 활용
- **상속과 공유의 차이**: 파일 디스크립터 전달은 공유가 아닌 소유권 이전입니다. 전송 후 원본 프로세스에서는 디스크립터를 닫아야 합니다.
- **보안 고려사항**: Unix 도메인 소켓 경로는 적절한 권한 설정이 필요하며, 가능하면 추상 네임스페이스(`\0`으로 시작)를 사용하는 것이 보안에 유리합니다.
- **에지 케이스 처리**: 전송 실패, 수신 실패, 부분 전송 등의 에지 케이스를 고려한 견고한 오류 처리 로직이 필수적입니다.

### 2. 이벤트 기반 아키텍처의 설계 원칙
- **확장성 모델 선택**:
  - `select`: 소규모 연결(1024개 이하), 이식성이 중요할 때
  - `poll`: 중규모 연결, `select`의 제한을 피할 때  
  - `epoll`(Linux)/`kqueue`(BSD): 대규모 연결(10,000+), 최고 성능 필요할 때
- **논블로킹 연산**: 모든 소켓을 논블로킹 모드로 설정하고, EAGAIN/EWOULDBLOCK 에러를 정상적인 흐름으로 처리해야 합니다.
- **이벤트 루프 최적화**: 이벤트 감지 시간 초과를 적절히 설정하고, 불필요한 이벤트 등록/해제를 최소화해야 합니다.

### 3. 대용량 데이터 전송의 최적화 기법
- **압축 알고리즘 선택 가이드**:
  - **무압축**: 데이터가 이미 압축되었거나, CPU가 제한된 환경
  - **zlib**: 높은 압축률 필요, CPU 여유 있는 경우
  - **LZ4**: 빠른 압축/해제 필요, 네트워크 대역폭이 제한된 경우
- **청크 기반 전송**: 메모리 효율성을 위해 대용량 데이터를 작은 청크로 나누어 전송하고, 흐름 제어를 구현해야 합니다.
- **무결성 보장**: 체크섬(CRC32, SHA256)과 전송 확인 응답을 통해 데이터 무결성을 검증해야 합니다.

### 4. 통합 아키텍처 패턴
- **계층적 설계**: 전송 계층, 압축 계층, 프로토콜 계층을 분리하여 유지보수성을 높이세요.
- **모니터링과 로깅**: 전송 속도, 압축률, 오류율 등의 메트릭을 실시간으로 수집하고 모니터링하세요.
- **테스트 전략**: 단위 테스트, 부하 테스트, 장애 복구 테스트를 체계적으로 수행하세요.

이러한 고급 기법들을 적용할 때는 항상 실제 사용 사례와 제약 조건을 고려해야 합니다. 프로토콜 버전 관리, 하위 호환성, 점진적 롤아웃 전략도 중요한 고려사항입니다. 파이썬의 `multiprocessing`, `asyncio`, `numpy`와 같은 라이브러리들은 이러한 고급 패턴을 구현하는 데 강력한 기반을 제공합니다.