---
layout: post
title: 영상처리 - 안정성/보안
date: 2025-10-14 16:25:23 +0900
category: 영상처리
---
# 8. 안정성/보안(용량 폭탄, 잘못된 마커, 오버플로) — **외부 JPEG 입력을 “절대” 믿지 말 것**

> 목표  
> - 악의적 JPEG(폭탄 크기, 잘못된 마커 길이, 손상된 스캔/프로그레시브, 비정상 색공간 등)로부터 **프로세스/메모리/UX** 보호  
> - **상한선**(파일 크기·픽셀 수·출력 버퍼·마커 총량) + **정수 오버플로 방지** + **setjmp** 기반 안전 복구  
> - 썸네일/프리뷰 경로는 **IDCT 스케일(1/2·1/4·1/8)** 을 우선 → CPU/메모리 폭주를 원천 차단  
> - 모든 코드 블록은 한 번만 ```로 감쌉니다.

---

## 0. 위협 모델과 방어 원칙

### 대표 위협
- **용량 폭탄**: 8×8 iMCU 조합만 교묘히 만들어 **해상도(폭×높이)** 가 매우 크거나, **프로그레시브 스캔**으로 디코더를 혹사.
- **마커 오염**: APPn 길이 위조/절단, EXIF/XMP/ICC 등 **비정상 길이**로 파서/수집 루틴에 과다 할당 유도.
- **오버플로**: `stride = width * channels` 같은 산술에서 **size_t/32bit** 오버플로 → **버퍼 언더/오버라이트**.
- **스트리밍 악용**: “무한 대기” 유도(입력 차단/지연), **skip_input_data**/**fill_input_buffer** 경로 악용.

### 방어 체크리스트(요약)
1. **입력 상한**  
   - 파일 크기(예: ≤ 100MB), **픽셀 수**(예: ≤ 120MP), **가로/세로**(예: ≤ 30000), **마커 총량**(예: ≤ 16MB).  
   - **프리뷰는 스케일 디코드(1/4, 1/8)** 고정.
2. **정수 안전**  
   - 모든 곱셈에 **오버플로 가드**(safeMul).  
   - `stride = width * 4` 계산 전에 `width <= SIZE_MAX / 4` 검증.
3. **마커 길이 검사**  
   - `jpeg_save_markers(..., length_limit)` 보수적으로 설정(예: 64KB).  
   - 수집 시 **총량 상한**과 **개별 허용 리스트**(ICC/Extended XMP는 조각합이 커질 수 있음 → 별도 예외).
4. **libjpeg 에러 복구**  
   - 커스텀 `error_exit` + **setjmp/longjmp** 로 **누수 없이** 안전 탈출(모든 리소스 RAII/스코프 가드).
5. **진행 검증**  
   - 디코드 루프에서 `next_scanline`/`output_scanline` **단조 증가/상한** 확인.  
   - 예상보다 많은 줄이 오거나, 정지되면 **중지**.
6. **시간/바이트 쿼터(옵션)**  
   - 커스텀 `jpeg_source_mgr` 로 **총 바이트/시간** 모니터링 → 한계를 넘으면 **에러 발생**.
7. **색공간/컴포넌트 검증**  
   - 허용하는 출력 색공간만(`JCS_RGB` / `JCS_EXT_BGRX/BGRA`) 디코드. **CMYK/YCCK**는 표시용 별경로(앞 장)로 전환.

---

## 1. 안전 디코더 설계(옵션·상한·스케일)

- **프리뷰 모드**: 무조건 `scale_denom=4` 또는 `8` → 1/16~1/64 연산/메모리.  
- **풀 디코드**: 헤더 파싱 후 **픽셀 수/가로/세로 상한** 통과 시에만 진행.  
- **마커 수집**: `jpeg_save_markers` 를 **필요한 APP만** + **길이 제한**으로 활성화.

> 상한 기본값(예시; 워크로드에 맞게 조정)
- `MAX_FILE_BYTES = 100 * 1024 * 1024`  
- `MAX_PIXELS = 120'000'000` (120MP)  
- `MAX_WIDTH = MAX_HEIGHT = 30'000`  
- `MAX_MARKERS_TOTAL = 16 * 1024 * 1024` (총 APP payload)  
- `PER_MARKER_LIMIT = 64 * 1024` (ICC/XMP-Ext는 분할 구조로 복수 조각을 허용하며 총량으로 제어)

---

## 2. 공통 유틸 — 안전 곱셈/마커 총량/스케일 선택

```cpp
#include <cstdint>
#include <limits>
#include <vector>
#include <string>
#include <cstdio>
#include <jpeglib.h>

static bool safeMulSize(size_t a, size_t b, size_t& out){
    if (a == 0 || b == 0) { out = 0; return true; }
    if (a > std::numeric_limits<size_t>::max() / b) return false;
    out = a * b; return true;
}

// 스케일 선택 (프리뷰: 1/4 또는 1/8, 풀: 1/1 또는 1/2)
static void chooseScaleForPreview(j_decompress_ptr cinfo, bool preview){
    cinfo->scale_num = 1;
    cinfo->scale_denom = preview ? 4 : 1; // 필요시 동적 조절
}

// 필요한 APP만 저장 (보수적 길이 제한)
static void enableMarkerSaving(j_decompress_ptr c, unsigned perMarkerLimit){
    // JFIF/EXIF/XMP/IPTC/ICC/Adobe 정도만 예시. 필요 없는 APP은 저장하지 않음.
    jpeg_save_markers(c, JPEG_APP0 + 0, perMarkerLimit);  // JFIF/JFXX
    jpeg_save_markers(c, JPEG_APP0 + 1, perMarkerLimit);  // Exif/XMP
    jpeg_save_markers(c, JPEG_APP0 + 2, perMarkerLimit);  // ICC
    jpeg_save_markers(c, JPEG_APP0 + 13, perMarkerLimit); // IPTC(IRB)
    jpeg_save_markers(c, JPEG_APP0 + 14, perMarkerLimit); // Adobe
    jpeg_save_markers(c, JPEG_COM, perMarkerLimit);       // COM
}
```

---

## 3. setjmp/longjmp 기반 안전 복구 + RAII

- libjpeg 에러는 기본적으로 **프로세스 종료** 대신 **error_exit** 콜백에서 longjmp 하도록 설계.
- `jpeg_destroy_*` 가 반드시 호출되도록 **스코프 가드**(RAII)를 사용.

```cpp
#include <setjmp.h>

struct JpegErrorMgr {
    jpeg_error_mgr pub;
    jmp_buf jmp;
    char msg[JMSG_LENGTH_MAX]{};
};

static void myErrorExit(j_common_ptr cinfo){
    JpegErrorMgr* e = (JpegErrorMgr*)cinfo->err;
    // libjpeg의 메시지를 안전 버퍼에 기록
    (*cinfo->err->format_message)(cinfo, e->msg);
    longjmp(e->jmp, 1);
}

struct DecompressHandle {
    jpeg_decompress_struct c{};
    JpegErrorMgr err{};
    bool inited=false;
    void init(){
        c.err = jpeg_std_error(&err.pub);
        err.pub.error_exit = myErrorExit;
        jpeg_create_decompress(&c);
        inited=true;
    }
    ~DecompressHandle(){ if(inited) jpeg_destroy_decompress(&c); }
};

```

---

## 4. **안전 프리뷰 디코드**(스케일 + 상한 + 마커총량)

- 입력 파일 크기 상한 체크(파일 소스 가정; 스트리밍은 소스 매니저로 별도 한계 적용)
- 헤더 파싱 후 **픽셀 수/폭·높이 상한** 통과 → **스케일 디코드**  
- 마커 수집 시 **총량 상한** 초과 시 **즉시 중단**

```cpp
#include "IppDib.h"
#include <sys/stat.h>

static bool getFileSize(const std::wstring& path, uint64_t& sz){
#ifdef _WIN32
    struct _stat64 s{};
    if (_wstat64(path.c_str(), &s) != 0) return false;
    sz = (uint64_t)s.st_size; return true;
#else
    // 플랫폼별 구현
    return false;
#endif
}

struct SafeLimits {
    uint64_t maxFileBytes   = 100ull*1024*1024;
    uint64_t maxPixels      = 120ull*1000*1000;
    uint32_t maxWidth       = 30000;
    uint32_t maxHeight      = 30000;
    uint64_t maxMarkersTotal= 16ull*1024*1024;
    uint32_t perMarkerLimit = 64*1024;
    bool previewScale = true; // 프리뷰면 true
};

static bool collectMarkersWithTotalLimit(j_decompress_ptr c, uint64_t maxTotal, uint64_t& total){
    total = 0;
    for (jpeg_saved_marker_ptr m=c->marker_list; m; m=m->next){
        if (m->data_length > 0){
            total += (uint64_t)m->data_length;
            if (total > maxTotal) return false; // 과다 마커
        }
    }
    return true;
}

bool DecodeJPEG_SafePreview(const std::wstring& path, const SafeLimits& L, IppDib& dst, std::string& outErr)
{
    dst.destroy();
    outErr.clear();

    // (A) 파일 크기 상한
    uint64_t fsz=0;
    if (!getFileSize(path, fsz)) { outErr="stat failed"; return false; }
    if (fsz == 0 || fsz > L.maxFileBytes){ outErr="file too large or empty"; return false; }

    FILE* fp=nullptr; _wfopen_s(&fp, path.c_str(), L"rb");
    if(!fp){ outErr="fopen failed"; return false; }

    DecompressHandle H; 
    try { H.init(); } catch (...){ fclose(fp); outErr="jpeg_create_decompress failed"; return false; }
    jpeg_stdio_src(&H.c, fp);

    if (setjmp(H.err.jmp)){ // libjpeg 내부 오류 → 안전 복구
        fclose(fp);
        outErr = H.err.msg;
        return false;
    }

    // (B) 마커 저장 설정(보수적)
    enableMarkerSaving(&H.c, L.perMarkerLimit);

    // (C) 헤더
    if (jpeg_read_header(&H.c, TRUE) != JPEG_HEADER_OK){
        fclose(fp); outErr="bad header"; return false;
    }

    // (D) 폭/높이/픽셀수 상한 확인
    if (H.c.image_width  > L.maxWidth || H.c.image_height > L.maxHeight){
        fclose(fp); outErr="dimension too large"; return false;
    }
    uint64_t pixels = (uint64_t)H.c.image_width * (uint64_t)H.c.image_height;
    if (pixels == 0 || pixels > L.maxPixels){
        fclose(fp); outErr="pixel count too large"; return false;
    }

    // (E) 프리뷰 스케일 적용
    chooseScaleForPreview(&H.c, L.previewScale);

#ifdef JCS_EXTENSIONS
    H.c.out_color_space = JCS_EXT_BGRX; // BGRA와 호환(BGRX→A=255 채우기)
#else
    H.c.out_color_space = JCS_RGB;
#endif
    H.c.dct_method = JDCT_IFAST;
    H.c.do_fancy_upsampling = FALSE;

    jpeg_start_decompress(&H.c);

    // (F) 마커 총량 검사
    uint64_t msum=0;
    if (!collectMarkersWithTotalLimit(&H.c, L.maxMarkersTotal, msum)){
        jpeg_finish_decompress(&H.c); fclose(fp);
        outErr="marker total too large"; return false;
    }

    // (G) 출력 버퍼 안전 생성(오버플로 방지)
    int W = (int)H.c.output_width;
    int Ht= (int)H.c.output_height;
    size_t stride=0;
    if (!safeMulSize((size_t)W, 4, stride)){ // 4=BGRA
        jpeg_finish_decompress(&H.c); fclose(fp);
        outErr="stride overflow"; return false;
    }
    if (!dst.create(W, Ht, 32)){
        jpeg_finish_decompress(&H.c); fclose(fp);
        outErr="alloc failed"; return false;
    }

    // (H) 읽기 루프 — 진행 검증
#ifdef JCS_EXTENSIONS
    const int C = 4; // BGRX
    std::vector<uint8_t> row(W * C);
#else
    const int C = 3; // RGB
    std::vector<uint8_t> row(W * C);
#endif

    while (H.c.output_scanline < H.c.output_height){
        JDIMENSION prev = H.c.output_scanline;
        JSAMPROW rp = row.data();
        JDIMENSION got = jpeg_read_scanlines(&H.c, &rp, 1);
        if (got != 1){ // 입력 지연/손상
            jpeg_finish_decompress(&H.c); fclose(fp);
            outErr="decode stalled"; return false;
        }
        if (H.c.output_scanline <= prev){ // 단조 증가 실패
            jpeg_finish_decompress(&H.c); fclose(fp);
            outErr="scanline regression"; return false;
        }

        uint8_t* d = (uint8_t*)dst.bits() + (size_t)(H.c.output_scanline-1)*dst.stride();
#ifdef JCS_EXTENSIONS
        // BGRX → BGRA
        for (int x=0;x<W;++x){
            d[x*4+0]=row[x*4+0];
            d[x*4+1]=row[x*4+1];
            d[x*4+2]=row[x*4+2];
            d[x*4+3]=255;
        }
#else
        for (int x=0;x<W;++x){
            d[x*4+0]=row[x*3+2];
            d[x*4+1]=row[x*3+1];
            d[x*4+2]=row[x*3+0];
            d[x*4+3]=255;
        }
#endif
    }

    jpeg_finish_decompress(&H.c);
    fclose(fp);
    return true;
}
```

**핵심 방어 포인트**
- 헤더만 읽어도 폭/높이를 알 수 있으므로 **상한 위반 즉시 중단**.  
- `collectMarkersWithTotalLimit` 로 **마커 총량**을 제동.  
- `safeMulSize` 로 **stride/버퍼 크기** 산술 모두 가드.  
- 루프에서 `output_scanline` **단조성** 검사 → **교착/무한루프 방지**.

---

## 5. 스트리밍/네트워크 입력용 **커스텀 소스 매니저**(쿼터/타임아웃)

- 파일이 아닌 **소켓/HTTP** 입력은 크기를 알기 어렵습니다.  
- `jpeg_source_mgr` 를 커스텀하여  
  - 누적 `bytesRead` 가 **상한**을 넘으면 에러,  
  - `fill_input_buffer` 에서 **타임아웃/중단** 조건 체크,  
  - `skip_input_data` 에서 **허용 범위 내로만** 건너뛰기.

**핵심 콜백**  
- `init_source`, `fill_input_buffer`, `skip_input_data`, `resync_to_restart`, `term_source`.

```cpp
struct StreamQuota {
    uint64_t maxBytes = 30ull*1024*1024; // 스트리밍 입력 상한(예)
    uint64_t readSoFar = 0;
    bool     timedOut = false;
    // 타이머/시그널은 플랫폼별 구현. 여기선 생략.
};

struct JpegStreamSrc {
    jpeg_source_mgr pub{};
    StreamQuota* quota=nullptr;
    FILE* fp=nullptr; // 예시로 FILE*, 실제로는 소켓/메모리큐 등
    std::vector<JOCTET> buffer;

    static void init_source(j_decompress_ptr c) {
        auto self = (JpegStreamSrc*)c->src;
        self->buffer.clear();
    }
    static boolean fill_input_buffer(j_decompress_ptr c) {
        auto self = (JpegStreamSrc*)c->src;
        if (self->quota->timedOut) {
            ERREXIT(c, JERR_INPUT_EOF); // 타임아웃 시 중단
        }
        self->buffer.resize(64*1024);
        size_t n = fread(self->buffer.data(), 1, self->buffer.size(), self->fp);
        self->quota->readSoFar += n;
        if (self->quota->readSoFar > self->quota->maxBytes){
            ERREXIT(c, JERR_FILE_READ); // 바이트 상한 초과
        }
        if (n == 0){
            // EOI 대체(표준 jpegtran 방식)
            static const JOCTET fakeEOI[2] = { 0xFF, JPEG_EOI };
            c->src->next_input_byte = fakeEOI;
            c->src->bytes_in_buffer = 2;
            return TRUE;
        }
        c->src->next_input_byte = self->buffer.data();
        c->src->bytes_in_buffer = n;
        return TRUE;
    }
    static void skip_input_data(j_decompress_ptr c, long num_bytes){
        if (num_bytes <= 0) return;
        while (num_bytes > (long)c->src->bytes_in_buffer){
            num_bytes -= (long)c->src->bytes_in_buffer;
            (void)fill_input_buffer(c);
        }
        c->src->next_input_byte += num_bytes;
        c->src->bytes_in_buffer -= num_bytes;
    }
    static boolean resync_to_restart(j_decompress_ptr c, int desired){ return jpeg_resync_to_restart(c,desired); }
    static void term_source(j_decompress_ptr){}

    static void attach(j_decompress_ptr c, FILE* fp, StreamQuota* q){
        auto* s = new JpegStreamSrc();
        s->fp = fp; s->quota=q;
        s->pub.init_source=init_source;
        s->pub.fill_input_buffer=fill_input_buffer;
        s->pub.skip_input_data=skip_input_data;
        s->pub.resync_to_restart=resync_to_restart;
        s->pub.term_source=term_source;
        s->pub.bytes_in_buffer=0;
        s->pub.next_input_byte=nullptr;
        c->src = (jpeg_source_mgr*)s;
    }
    static void detach(j_decompress_ptr c){
        delete (JpegStreamSrc*)c->src;
        c->src=nullptr;
    }
};
```

> 이 소스 매니저로 **입력 바이트 상한/시간상한**을 강제할 수 있습니다.  
> 파일 경로가 아닌 **HTTP 응답 본문**에도 동일하게 적용 가능합니다.

---

## 6. 잘못된 마커/비정상 메타에 대한 방어

- **저장(limit)**: `jpeg_save_markers(c, APPn, PER_MARKER_LIMIT)` 로 **각 마커 최대길이** 제한  
- **총량(limit)**: 수집 후 `sum(data_length)` 로 “마커 총량”이 `MAX_MARKERS_TOTAL` 초과 시 중단  
- **선택 보존**: 프라이버시/성능 목적이라면 **필요한 유형만** 보존(EXIF/XMP/ICC/Adobe/JFIF 중심)

**주의할 점**
- APPn 헤더의 길이 필드는 **2바이트**(자기 자신 포함 길이) → 이론상 **64KB 미만**  
- 하지만 **여러 조각**(ICC/XMP-Ext)이 연속 등장해 **총량은 수MB**가 될 수 있음 → **총량 상한**이 핵심

---

## 7. 색공간/컴포넌트 검증

- 입력이 `JCS_CMYK/YCCK` 일 수 있음(표시용 RGB 변환 필요) — **표시 파이프라인**에서는  
  `out_color_space = JCS_RGB or JCS_EXT_BGRX` 로 **강제**,  
  CMYK/YCCK는 **디코드 후 변환**(앞 장 “CMYK/YCCK JPEG 대응” 참고).
- `output_components` 가 예상과 다르면 **즉시 에러**.

---

## 8. 프리뷰 경로 고정 — UX와 안전을 동시에

- 갤러리/그리드/목록 썸네일: **무조건 1/4 또는 1/8 스케일 디코드**  
- “탭/확대 시”에만 원본/1/2 스케일 디코드  
- 이 전략만으로도 **폭탄 파일**의 **CPU·메모리** 영향이 크게 완화

---

## 9. 통합 예 — **안전 프리뷰 UI 호출**(에러 메시지 포함)

```cpp
// 사용
SafeLimits lim;
lim.maxFileBytes = 100ull*1024*1024;
lim.maxPixels    = 120ull*1000*1000;
lim.maxWidth     = 30000;
lim.maxHeight    = 30000;
lim.maxMarkersTotal = 16ull*1024*1024;
lim.perMarkerLimit  = 64*1024;
lim.previewScale    = true; // 1/4

IppDib thumb;
std::string err;
if (!DecodeJPEG_SafePreview(L"unknown.jpg", lim, thumb, err)){
    // 메시지 박스/로그로 err 출력. UI는 "로드 실패" 썸네일로 대체.
} else {
    // thumb 표시
}
```

---

## 10. 테스트 시나리오(실전)

- [ ] **거대 해상도 헤더**(예: 100000×100000) → **헤더 상한**에서 즉시 차단  
- [ ] **마커 폭탄**(수백 개의 APP1/APP2) → 총량 상한 초과로 차단  
- [ ] **트렁케이트/손상 JPEG** → setjmp 경로로 안전 복구  
- [ ] **프로그레시브 스캔 중단** → “decode stalled” 검출  
- [ ] **스트리밍 타임아웃** → 커스텀 소스에서 EOF/타임아웃 처리  
- [ ] **CMYK/YCCK** → 표시 파이프라인 정상 변환(앞 장 코드와 결합)  
- [ ] **프리뷰 1/8 + 본문 1/2** 체감 성능/메모리 측정(스크롤 FPS, 메모리 peak)

---

## 11. MathJax(개념) — 왜 스케일이 안전에 유리한가?

압축 해제 연산량은 대략 해상도에 비례합니다. 스케일링 IDCT의 경우,
\[
\text{Ops}_\text{scaled} \approx \frac{W \times H}{s^2}, \quad s \in \{2,4,8\}
\]
따라서 1/4 스케일이면 연산량이 **1/16**, 메모리도 **1/16** 수준으로 줄어 안전 마진이 넓어집니다.

---

## 12. 마무리 — **“방어적 JPEG 파이프라인”** 정리

- **상한선**(파일/픽셀/마커/시간/바이트)을 깔고,  
- **오버플로 가드** + **setjmp 복구** + **진행 검증**을 더하면,  
- 악성·손상 입력에도 **프로세스 안정성**과 **UX**를 유지할 수 있습니다.  
- 프리뷰/썸네일은 **스케일 디코드**를 기본으로.  
- 메타데이터/색관리/무손실 변환 등 앞서 구현한 파트와 결합하면,  
  **안전·정확·고성능**의 JPEG 파이프라인이 완성됩니다.