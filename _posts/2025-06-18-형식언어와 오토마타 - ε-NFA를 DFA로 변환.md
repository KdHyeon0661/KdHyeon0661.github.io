---
layout: post
title: 형식언어와 오토마타 - ε-NFA를 DFA로 변환
date: 2025-06-18 21:20:23 +0900
category: 형식언어와 오토마타
---
# ε-NFA를 DFA로 변환하는 과정

ε-NFA는 ε-이동(입력 없이 상태를 전이하는 기능)을 포함하는 비결정적 유한 오토마타입니다. 이러한 ε-NFA는 먼저 **일반 NFA**로 변환한 뒤, **DFA**로 변환할 수 있습니다.

---

## 1. ε-NFA 정의

ε-NFA는 다음과 같은 5-튜플로 정의됩니다:

\\[
M = (Q, \Sigma, \delta, q_0, F)
\\]

- \\( Q \\): 유한한 상태 집합
- \\( \Sigma \\): 입력 알파벳
- \\( \delta: Q \times (\Sigma \cup \{\varepsilon\}) \rightarrow \mathcal{P}(Q) \\): 전이 함수
- \\( q_0 \\): 시작 상태
- \\( F \\): 종료 상태 집합

---

## 2. ε-NFA → DFA 변환 개요

변환은 두 단계로 이루어집니다:

1. **ε-NFA → NFA**: ε-이동 제거 (ε-closure 사용)
2. **NFA → DFA**: subset construction (상태 집합을 하나의 DFA 상태로)

---

## 3. ε-Closure 정의

> 어떤 상태 \\( q \\)에 대해, **ε-closure(q)**는 ε만을 이용해서 도달 가능한 모든 상태의 집합입니다.

수학적으로:

\\[
\text{ε-closure}(q) = \{ p \in Q \mid q \xrightarrow{\varepsilon^*} p \}
\\]

여기서 \\( \xrightarrow{\varepsilon^*} \\)는 0개 이상의 ε-이동을 의미합니다.

예를 들어:

```text
δ(q0, ε) = {q1}
δ(q1, ε) = {q2}
⇒ ε-closure(q0) = {q0, q1, q2}
```

---

## 4. 변환 알고리즘

### 입력
ε-NFA \\( M = (Q, \Sigma, \delta, q_0, F) \\)

### 출력
동등한 DFA \\( M' = (Q', \Sigma, \delta', q_0', F') \\)

### 과정

1. **초기 상태 설정**  
   \\[
   q_0' = \text{ε-closure}(q_0)
   \\]

2. **상태 집합 구성**  
   DFA의 각 상태는 ε-NFA 상태들의 **집합**으로 구성  
   (예: \\( \{q0, q1\} \\) 같은 집합이 DFA의 하나의 상태가 됨)

3. **전이 함수 정의**  
   DFA에서 \\( S \subseteq Q \\)와 입력 \\( a \in \Sigma \\)에 대해:

   - 모든 \\( q \in S \\)에 대해 \\( \delta(q, a) \\)를 구함
   - 해당 결과 상태들에 대해 각각 **ε-closure**를 계산
   - 결과를 합집합하여 DFA의 다음 상태로 설정

   수식:

   \[
   \delta'(S, a) = \varepsilon\text{-closure}\left(\bigcup_{q \in S} \delta(q, a)\right)
   \]

4. **종료 상태 구성**  
   DFA 상태 집합 \\( S \\)이 ε-NFA 종료 상태 집합과 **교집합이 있으면** DFA에서도 종료 상태로 지정

---

## 5. 예제: ε-NFA → DFA

### ε-NFA 정의

```text
Q = {q0, q1, q2}
Σ = {a}
q0: 시작 상태
F = {q2}

δ:
  δ(q0, ε) = {q1}
  δ(q1, a) = {q1, q2}
  δ(q2, a) = ∅
```

### Step 1: ε-Closure 계산

- ε-closure(q0) = {q0, q1}
- ε-closure(q1) = {q1}
- ε-closure(q2) = {q2}

### Step 2: DFA 상태 구성 (부분집합 생성)

- DFA 시작 상태: \\( \{q0, q1\} \\)
- DFA 상태들:
  - \\( S_0 = \{q0, q1\} \\)
  - \\( S_1 = \varepsilon\text{-closure}(\delta(q0, a) ∪ \delta(q1, a)) \\
         = \varepsilon\text{-closure}(∅ ∪ \{q1, q2\}) = \{q1, q2\} \\)
  - \\( S_2 = \varepsilon\text{-closure}(\delta(q1, a) ∪ \delta(q2, a)) = \{q1, q2\} \\)

상태가 반복되므로 DFA는 다음과 같은 구성으로 종료:

| DFA 상태 | 입력 a → | 다음 DFA 상태 |
|----------|----------|----------------|
| {q0, q1} | a        | {q1, q2}       |
| {q1, q2} | a        | {q1, q2}       |

### Step 3: 종료 상태 판단

- DFA 상태 \\( \{q1, q2\} \\)은 NFA 종료 상태 \\( q2 \\)를 포함하므로 **종료 상태**
- 마찬가지로 \\( \{q0, q1\} \\)는 종료 상태가 아니므로 DFA 종료 상태는 \\( \{q1, q2\} \\) 하나

---

## 6. 시각화 예 (텍스트 기반 상태 그래프)

### ε-NFA (요약)

```text
q0 --ε--> q1
q1 --a--> q1
q1 --a--> q2
```

### DFA 전이표

```text
DFA 상태     | 입력 a | 다음 상태
-------------|--------|-----------
{q0, q1}     | a      | {q1, q2}
{q1, q2}     | a      | {q1, q2}
```

시작 상태: {q0, q1}  
종료 상태: {q1, q2}

---

## 7. 정리

| 단계 | 설명 |
|------|------|
| ε-closure | ε-이동을 따라 도달할 수 있는 상태 집합 |
| 상태 확장 | 상태 집합을 DFA 상태로 사용 |
| 전이 정의 | 입력과 전이 후 ε-closure를 계산 |
| 종료 상태 | NFA 종료 상태를 포함하는 DFA 상태 |

> **결론:**  
> ε-NFA는 DFA로 변환 가능하며, 이로 인해 ε-이동이 포함되어도 **정규 언어를 인식**하는 데에는 차이가 없습니다.

---

## 8. 참고

- ε-이동이 있는 이유: 정규 표현식의 OR, CONCAT, STAR 등을 간결히 표현하기 위해
- DFA 변환 후에는 ε-이동이 제거되므로 실행이 훨씬 **결정적이고 빠름**
- 상태 수는 많아질 수 있으나 항상 **유한**하고 **구현 가능**