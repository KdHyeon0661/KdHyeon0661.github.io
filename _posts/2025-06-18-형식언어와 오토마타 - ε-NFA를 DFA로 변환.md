---
layout: post
title: 형식언어와 오토마타 - ε-NFA를 DFA로 변환
date: 2025-06-18 21:20:23 +0900
category: 형식언어와 오토마타
---
# ε-NFA를 DFA로 변환하는 과정

ε-NFA(ε-Nondeterministic Finite Automaton)는 **입력 없이(ε)** 상태를 이동할 수 있는 전이를 포함한다.  
현대 정규식 엔진의 내부 표현(Thompson 구성)처럼 설계가 간결한 장점이 있지만, 실행은 **DFA**가 훨씬 빠르고 안정적이다.  
따라서 실전에서는 **ε-NFA → DFA** 변환(결정화; determinization)을 수행해 **런타임을 선형화**한다.

---

## 0. 표기(Notation) 및 합의

- 알파벳: $$\Sigma$$ (유한 집합)
- 문자열: $$w\in\Sigma^\*$$, 길이 $$|w|$$, 공백 $$\varepsilon$$
- 언어: $$L\subseteq\Sigma^\*$$
- ε-NFA: $$M=(Q,\Sigma,\delta,q_0,F)$$  
  여기서 $$\delta:Q\times(\Sigma\cup\{\varepsilon\})\to\mathcal P(Q)$$
- DFA: $$M'=(Q',\Sigma,\delta',q_0',F')$$, $$\delta':Q'\times\Sigma\to Q'$$

---

## 1. ε-NFA 정의(복습)

> **정의.** ε-NFA는 5-튜플  
> $$M=(Q,\Sigma,\delta,q_0,F)$$
> 로서, 전이함수 $$\delta$$는 **입력 기호**뿐 아니라 **ε**에 대해서도 상태집합을 돌려줄 수 있다.

- $$Q$$: 유한한 상태 집합  
- $$\Sigma$$: 입력 알파벳  
- $$\delta:Q\times(\Sigma\cup\{\varepsilon\})\rightarrow\mathcal P(Q)$$  
- $$q_0\in Q$$: 시작 상태  
- $$F\subseteq Q$$: 종료(수용) 상태 집합

---

## 2. ε-closure의 정의와 성질

> **정의.** 상태 $$q\in Q$$에 대해
> $$
> \varepsilon\text{-closure}(q)\;=\;\{\,p\in Q \mid q \xRightarrow{\varepsilon^\*} p\,\}
> $$
> 즉, **ε만** 이용하여 도달 가능한 모든 상태의 집합(자기 자신 포함).

집합 $$S\subseteq Q$$에 대해서도
$$
\varepsilon\text{-closure}(S)\;=\;\bigcup_{q\in S}\varepsilon\text{-closure}(q).
$$

**핵심 성질(증명 스케치 생략)**  
- (자기포함) $$q\in\varepsilon\text{-closure}(q)$$  
- (단조성) $$S\subseteq T \Rightarrow \varepsilon\text{-closure}(S)\subseteq \varepsilon\text{-closure}(T)$$  
- (멱등성) $$\varepsilon\text{-closure}(\varepsilon\text{-closure}(S))=\varepsilon\text{-closure}(S)$$

이 성질 덕분에 **ε-이동 제거/결정화** 과정의 불변식과 정당성을 깔끔히 기술할 수 있다.

---

## 3. 두 가지 변환 루트(개요)

ε-NFA → DFA는 보통 두 루트 중 하나로 구현한다.

### 루트 A: “ε 제거 후 결정화” (ε-NFA → NFA → DFA)
1) **ε 제거(ε-elimination)**  
   $$\forall q\in Q,\ \forall a\in\Sigma:\quad
   \delta^\*(q,a)
   = \varepsilon\text{-closure}\Big(\bigcup_{p\in \varepsilon\text{-closure}(q)} \delta(p,a)\Big)
   $$
   종료집합은  
   $$F^\*=\{\,q\in Q \mid \varepsilon\text{-closure}(q)\cap F\neq\emptyset\,\}$$  
   로 갱신 (ε만 타고도 수용에 닿을 수 있으면 수용).

2) **부분집합 구성법(Subet Construction)**으로 NFA → DFA 결정화.

### 루트 B: “ε를 내부에 품은 채 결정화” (직접 ε-NFA → DFA)
- DFA의 시작상태 $$S_0=\varepsilon\text{-closure}(\{q_0\})$$  
- 전이:
  $$
  \delta'(S,a)=\varepsilon\text{-closure}\Big(\bigcup_{q\in S}\delta(q,a)\Big)
  $$
- 수용: $$S\cap F\neq\emptyset$$ 이면 수용

두 루트는 **완전히 동치**다(§6 정당성 스케치 참조). 실무에서는 루트 B가 구현이 간결하다.

---

## 4. 알고리즘(루트 B 기준: ε 포함 직접 결정화)

**입력**: ε-NFA $$M=(Q,\Sigma,\delta,q_0,F)$$  
**출력**: DFA $$M'=(Q',\Sigma,\delta',S_0,F')$$

1) $$S_0\gets \varepsilon\text{-closure}(\{q_0\})$$  
2) worklist(큐)에 $$S_0$$를 넣고, **방문한 부분집합**을 해시로 관리  
3) while 큐: 부분집합 $$S$$를 꺼내 **각 입력기호** $$a\in\Sigma$$에 대해
   - $$U\gets \varepsilon\text{-closure}(\bigcup_{q\in S}\delta(q,a))$$
   - $$\delta'(S,a)=U$$로 기록  
   - $$U$$가 처음 등장한 상태집합이면 큐에 삽입
4) 수용집합: $$F'=\{\,S\subseteq Q \mid S\cap F\neq\emptyset\,\}$$

**주의(실전 팁)**  
- **도달 불가 상태 제거**: DFA 완성 후에도 시작집합에서 도달되지 않은 부분집합은 버린다.  
- **완전화(여집합을 쓸 계획이 있다면)**: 정의되지 않은 전이는 **sink 상태**를 추가해 채운다.

---

## 5. 예제 1 — 단일 문자 ‘a’ 언어(주어진 예제 확장)

### 5.1 ε-NFA

```text
Q = {q0, q1, q2}
Σ = {a}
시작: q0
F = {q2}

δ:
  δ(q0, ε) = {q1}
  δ(q1, a) = {q1, q2}
  δ(q2, a) = ∅
```

### 5.2 ε-closure
- $$\varepsilon\text{-closure}(q0)=\{q0,q1\}$$
- $$\varepsilon\text{-closure}(q1)=\{q1\}$$
- $$\varepsilon\text{-closure}(q2)=\{q2\}$$

### 5.3 직접 결정화(루트 B)
- 시작 DFA 상태: $$S_0=\{q0,q1\}$$
- 전이:
  - $$\delta'(\{q0,q1\},a)=\varepsilon\text{-closure}(\delta(q0,a)\cup\delta(q1,a))=\varepsilon\text{-closure}(\varnothing\cup\{q1,q2\})=\{q1,q2\}$$
  - $$\delta'(\{q1,q2\},a)=\varepsilon\text{-closure}(\{q1,q2\})=\{q1,q2\}$$
- 수용: $$\{q1,q2\}$$은 $$q2\in F$$를 포함 → **수용**.  
- DFA 전이표:

```text
DFA 상태     | 입력 a | 다음
-------------|--------|-----------
{q0, q1}     | a      | {q1, q2}
{q1, q2}     | a      | {q1, q2}
수용: {q1, q2}
```

**해석**: ‘a’를 **한 번이라도** 읽으면 수용 상태에 들어간 뒤 계속 머무는 언어.

---

## 6. 예제 2 — “ab 또는 ba 를 부분문자열로 포함” (ε 분기 + ε-closure 실전 감각)

**아이디어**  
- 시작에서 ε로 두 경로로 분기:  
  - 경로 X: `a* b`를 발견하면 수용  
  - 경로 Y: `b* a`를 발견하면 수용  
- 수용 후에는 무엇을 읽어도 수용 상태에 머물도록 설계(실무 패턴 매칭 스타일)

### 6.1 ε-NFA 설계

```text
Q = {s, x, y, f}
Σ = {a, b}
시작: s
F = {f}

ε-전이:
  δ(s, ε) = {x, y}

일반 전이:
  # X 경로: a* b
  δ(x, a) = {x}
  δ(x, b) = {f}

  # Y 경로: b* a
  δ(y, b) = {y}
  δ(y, a) = {f}

  # 수용 후 흡수
  δ(f, a) = {f}
  δ(f, b) = {f}
```

### 6.2 ε-closure
- $$\varepsilon\text{-closure}(s)=\{s,x,y\}$$
- $$\varepsilon\text{-closure}(x)=\{x\},\ \varepsilon\text{-closure}(y)=\{y\},\ \varepsilon\text{-closure}(f)=\{f\}$$

### 6.3 직접 결정화(핵심 전개)
- 시작 DFA 상태: $$S_0=\{s,x,y\}$$
- 전이:
  - 입력 **a**:
    - from x: a→x, from y: a→f, from s: a 없음  
    - 합집합 {x,f} 의 ε-closure = {x,f}
  - 입력 **b**:
    - from x: b→f, from y: b→y
    - 합집합 {f,y} 의 ε-closure = {f,y}

- 따라서
  - $$\delta'(\{s,x,y\},a)=\{x,f\}$$
  - $$\delta'(\{s,x,y\},b)=\{f,y\}$$
- 다음 상태들의 전이:
  - \{x,f\} 에서 a: {x,f}, b: {f}  (f는 흡수)
  - \{f,y\} 에서 a: {f},   b: {f,y}
  - \{f\}   에서 a,b 모두 {f}

**수용집합**: f를 포함하는 모든 부분집합  
**언어 해석**: ‘ab’ 또는 ‘ba’를 **어디선가 한 번이라도** 포함하면 이후는 계속 수용.

---

## 7. 정당성(올바름) 스케치 — 핵심 불변식

> **불변식**  
> 모든 접두사 $$x\in\Sigma^\*$$에 대해, 결정화된 DFA의 현재 상태 집합은  
> $$
> \hat\delta'(S_0,x)
> \;=\;
> \varepsilon\text{-closure}\Big(\{\,q\in Q \;\big|\; q_0 \xRightarrow[\text{ε-NFA}]{x} q\,\}\Big).
> $$
> (좌변: DFA가 $$x$$를 읽고 도달한 부분집합, 우변: ε-NFA에서 $$x$$를 읽고 도달 가능한 모든 상태의 ε-closure)

**귀납**(입력 길이)에 의해 성립. 이 불변식으로부터  
$$
w\in L(\text{ε-NFA})
\iff
\hat\delta'(S_0,w)\cap F\neq\emptyset
\iff
w\in L(\text{DFA})
$$
가 곧바로 따라 **언어 동치**가 증명된다.

---

## 8. 복잡도 및 최적화

- **상태 폭발 가능성**: 부분집합 상태 수 최대 **\(2^{|Q|}\)**  
- **실전 대응**  
  1) **지연 결정화(lazy)**: 도달 가능한 부분집합만 생성(worklist BFS)  
  2) **비트셋/정수 마스크**: 부분집합 표현을 비트마스크로 최적화  
  3) **캐시된 ε-closure**: 각 상태/집합의 ε-closure를 메모이제이션  
  4) (옵션) 결정화 이후 **Hopcroft 최소화**로 상태 수 대폭 절감  
  5) **완전화 + 여집합**을 쓸 계획이면 **sink** 추가

---

## 9. 파이썬 실습 코드(실행 가능)

> 교육용으로 **간결성**을 우선. 실서비스는 검증/예외/성능(비트셋) 최적화 필요.

### 9.1 ε-NFA 클래스 + ε-closure + 직접 결정화(루트 B)

```python
from collections import defaultdict, deque
from typing import Dict, Set, Tuple, Iterable, FrozenSet

State = str
Sym = str

class ENFA:
    def __init__(self,
                 states: Iterable[State],
                 alphabet: Iterable[Sym],
                 delta: Dict[Tuple[State, Sym], Iterable[State]],
                 start: State,
                 accepts: Iterable[State],
                 eps: Sym = 'ε'):
        """
        delta[(q, a)] = {next states...}, where a ∈ Σ ∪ {ε}
        """
        self.states: Set[State] = set(states)
        self.alphabet: Set[Sym] = set(alphabet)
        self.eps = eps
        self.start: State = start
        self.accepts: Set[State] = set(accepts)

        self.delta: Dict[Tuple[State, Sym], Set[State]] = defaultdict(set)
        for (q, a), dests in delta.items():
            self.delta[(q, a)].update(dests)

    def eclosure(self, S: Iterable[State]) -> FrozenSet[State]:
        """ε-closure for a set of states"""
        stack = list(S)
        seen: Set[State] = set(S)
        while stack:
            q = stack.pop()
            for r in self.delta.get((q, self.eps), set()):
                if r not in seen:
                    seen.add(r)
                    stack.append(r)
        return frozenset(seen)

    def move(self, S: Iterable[State], a: Sym) -> FrozenSet[State]:
        U: Set[State] = set()
        for q in S:
            U |= self.delta.get((q, a), set())
        return frozenset(U)

def enfa_to_dfa(enfa: ENFA):
    """직접 결정화: ε-closure를 내부에서 사용하여 ENFA -> DFA"""
    Σ = enfa.alphabet
    S0 = enfa.eclosure({enfa.start})

    name_of: Dict[FrozenSet[State], str] = {S0: "S0"}
    rev_name: Dict[str, FrozenSet[State]] = {"S0": S0}
    next_id = 1

    def get_name(S: FrozenSet[State]) -> str:
        nonlocal next_id
        if S not in name_of:
            name = f"S{next_id}"
            next_id += 1
            name_of[S] = name
            rev_name[name] = S
        return name

    work = deque([S0])
    dfa_delta: Dict[Tuple[str, Sym], str] = {}
    dfa_accepts: Set[str] = set()
    dfa_states: Set[str] = {"S0"}

    # 시작 상태 수용 여부
    if any(q in enfa.accepts for q in S0):
        dfa_accepts.add("S0")

    while work:
        T = work.popleft()
        Tn = name_of[T]
        for a in Σ:
            U = enfa.eclosure(enfa.move(T, a))
            if not U:  # 불완전 DFA 허용(학습용). 실무는 sink 추가 권장.
                continue
            Un = get_name(U)
            dfa_delta[(Tn, a)] = Un
            if Un not in dfa_states:
                dfa_states.add(Un)
                work.append(U)
                if any(q in enfa.accepts for q in U):
                    dfa_accepts.add(Un)

    return {
        "states": dfa_states,
        "alphabet": Σ,
        "delta": dfa_delta,
        "start": "S0",
        "accepts": dfa_accepts,
        "subset_map": {v: k for k, v in name_of.items()}  # DFA상태 -> 원래부분집합
    }

def dfa_run(dfa, s: str) -> bool:
    q = dfa["start"]
    for ch in s:
        key = (q, ch)
        if key not in dfa["delta"]:
            return False
        q = dfa["delta"][key]
    return q in dfa["accepts"]

def print_dfa(dfa):
    states = sorted(dfa["states"])
    Σ = sorted(dfa["alphabet"])
    print("States:", states)
    print("Start :", dfa["start"])
    print("Accept:", sorted(dfa["accepts"]))
    print("Delta :")
    for q in states:
        for a in Σ:
            q2 = dfa["delta"].get((q, a), None)
            print(f"  δ({q}, {a}) = {q2}")
```

### 9.2 루트 A: ε 제거 → NFA → (기본) DFA

```python
def enfa_remove_epsilon(enfa: ENFA):
    """루트 A의 1단계: ε 제거로 NFA(ε 없음) 생성"""
    Σ = enfa.alphabet
    Q = enfa.states

    # 각 상태의 ε-closure 미리 계산
    ecl = {q: enfa.eclosure({q}) for q in Q}

    # δ*(q, a) = ECl( ⋃_{p∈ECl(q)} δ(p, a) )
    delta2: Dict[Tuple[State, Sym], Set[State]] = defaultdict(set)
    for q in Q:
        for a in Σ:
            U: Set[State] = set()
            for p in ecl[q]:
                U |= enfa.delta.get((p, a), set())
            # 결과의 ε-closure
            U2: Set[State] = set()
            for r in U:
                U2 |= ecl[r]
            delta2[(q, a)] = U2

    # F* = { q | ECl(q) ∩ F ≠ ∅ }
    F2 = { q for q in Q if ecl[q] & enfa.accepts }

    return {
        "states": set(Q),
        "alphabet": set(Σ),
        "delta": {k: set(v) for k, v in delta2.items()},
        "start": enfa.start,
        "accepts": set(F2)
    }

def nfa_to_dfa(nfa):
    """기본 부분집합 구성으로 NFA(ε 없음) -> DFA"""
    Σ = nfa["alphabet"]
    start_set = frozenset({nfa["start"]})

    name_of = {start_set: "S0"}
    rev_name = {"S0": start_set}
    next_id = 1

    def get_name(S):
        nonlocal next_id
        if S not in name_of:
            name = f"S{next_id}"; next_id += 1
            name_of[S] = name; rev_name[name] = S
        return name

    work = deque([start_set])
    d_delta = {}
    d_states = {"S0"}
    d_accepts = set()

    if any(q in nfa["accepts"] for q in start_set):
        d_accepts.add("S0")

    while work:
        T = work.popleft()
        Tn = name_of[T]
        for a in Σ:
            U = set()
            for q in T:
                U |= nfa["delta"].get((q, a), set())
            U = frozenset(U)
            if not U:  # 학습용 불완전 DFA 허용
                continue
            Un = get_name(U)
            d_delta[(Tn, a)] = Un
            if Un not in d_states:
                d_states.add(Un)
                work.append(U)
                if any(q in nfa["accepts"] for q in U):
                    d_accepts.add(Un)

    return {
        "states": d_states, "alphabet": Σ, "delta": d_delta,
        "start": "S0", "accepts": d_accepts,
        "subset_map": {v: k for k, v in name_of.items()}
    }
```

### 9.3 예제 실행(두 루트 결과 비교)

```python
# 예제 1: 단일 문자 'a' (본문 §5)
enfa1 = ENFA(
    states={'q0','q1','q2'},
    alphabet={'a'},
    delta={
        ('q0','ε'): {'q1'},
        ('q1','a'): {'q1','q2'},
        # ('q2','a'): ∅
    },
    start='q0',
    accepts={'q2'}
)

dfa1_direct = enfa_to_dfa(enfa1)  # 루트 B
nfa1 = enfa_remove_epsilon(enfa1)  # 루트 A-1
dfa1_viaA = nfa_to_dfa(nfa1)       # 루트 A-2

print("=== DFA (직접 결정화) ===")
print_dfa(dfa1_direct)
print("\n=== DFA (ε 제거 후 결정화) ===")
print_dfa(dfa1_viaA)

# 간단 동등성 체크
tests = ["", "a", "aa", "aaa"]
print("\n수용 비교:")
for t in tests:
    print(t or "ε", dfa_run(dfa1_direct, t), dfa_run(dfa1_viaA, t))

# 예제 2: 'ab' 또는 'ba' 포함(본문 §6)
enfa2 = ENFA(
    states={'s','x','y','f'},
    alphabet={'a','b'},
    delta={
        ('s','ε'): {'x','y'},
        ('x','a'): {'x'},  ('x','b'): {'f'},
        ('y','b'): {'y'},  ('y','a'): {'f'},
        ('f','a'): {'f'},  ('f','b'): {'f'},
    },
    start='s',
    accepts={'f'}
)

dfa2 = enfa_to_dfa(enfa2)
print("\n=== DFA for 'contains ab or ba' ===")
print_dfa(dfa2)

for t in ["", "a", "b", "aaab", "bbba", "abba", "bbbb", "aaaa"]:
    print(f"{t or 'ε':>6}", dfa_run(dfa2, t))
```

> 기대 결과  
> - 두 루트의 DFA(예제 1)가 **동등한 전이 구조/수용 결과**를 보임  
> - 예제 2에서 `aaab`, `bbba`, `abba` 등은 True, `aaaa`, `bbbb`, `""` 등은 False

---

## 10. 자주 틀리는 포인트(실전 체크리스트)

1) **ε-closure 누락**  
   - 전이 후에 **반드시** ε-closure를 취해야 한다(루트 B).  
   - 루트 A에서도 δ* 정의에 **두 번의 ε-closure**(입력 전/후) 중 “후”를 잊지 말 것.

2) **수용 상태 집합 업데이트 불량(루트 A)**  
   - $$F^\*=\{q \mid \varepsilon\text{-closure}(q)\cap F\neq\emptyset\}$$  
   - ε만으로도 수용에 닿는 시작 상태가 있으면 **빈 문자열**도 수용한다.

3) **불완전 DFA를 여집합에 바로 사용**  
   - 여집합·차집합을 쓰려면 **완전화(sink 추가)** 후 적용.

4) **상태 폭발 미감지**  
   - 대형 정규식/문법에서 **부분집합 수가 기하급수**로 증가 가능 → 도달 가능한 상태만 생성, 필요 시 Hopcroft 최소화.

5) **부분집합 상태 이름의 비결정성**  
   - 결과 DFA는 동형까지 유일. 로깅/테스트 재현성을 위해 **정렬/사전식 대표명**을 일관되게 부여.

---

## 11. 연습문제(해설 스케치 포함)

1) **ε-사이클 처리**  
   상태 p에서 ε로 자기 자신/서브그래프로 순환하는 경우, ε-closure가 어떻게 수렴하는지(멱등성) 직접 계산해 보라.  
   *힌트*: DFS/BFS로 한 번 방문한 노드를 다시 확장하지 않으면 된다.

2) **정규식 (a|b)*abb → ε-NFA → DFA**  
   - Thompson 구성으로 ε-NFA를 만들고(OR/CONCAT/STAR 각자 ε 사용), 본문 코드로 DFA를 생성해 보라.  
   - 수용 문자열 예/반례를 10개 만들어 테스트.

3) **루트 A vs 루트 B 등가성 실험**  
   - 임의의 ε-NFA 5개를 만들어 두 루트로 얻은 DFA가 길이 ≤ 6 모든 문자열에서 동일 판정을 내리는지 체크.

4) **빈 문자열 수용 케이스**  
   - ε-closure(q0)이 수용을 포함하는 경우와 포함하지 않는 경우를 각각 구성, DFA 시작상태의 수용 여부 차이를 확인.

5) **Hopcroft 최소화 적용**  
   - 예제 2의 DFA에 sink 추가로 완전화 후 Hopcroft를 적용, 상태 수 변화 관찰.

---

## 결론

- **ε-closure**는 ε-NFA의 핵심 도구이며, 이를 통해 **ε-NFA → DFA**가 체계적으로 가능하다.  
- 구현 루트는 **A(ε 제거 후 결정화)**와 **B(ε 포함 직접 결정화)**가 있으며 **언어적으로 동치**다.  
- 실전에서는 **지연 결정화 + 캐시 + (필요 시) Hopcroft 최소화**로 **성능과 상태 수**를 모두 잡는다.  
- 정규식 엔진/컴파일러 렉서/IDS 패턴 매칭 등에서 이 파이프라인이 **사실상 표준**이다.