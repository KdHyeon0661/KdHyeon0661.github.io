---
layout: post
title: 형식언어와 오토마타 - 재귀 함수
date: 2025-08-10 16:20:23 +0900
category: 형식언어와 오토마타
---
# 재귀 함수 계열 한눈에: **원시 재귀 함수(Primitive Recursive)**, **Ackermann 함수**, **μ-재귀(일반/부분 재귀) 함수**

이 글은 계산가능성의 고전 3요소 — **원시 재귀 함수(총함수의 안전 지대)**, **Ackermann(총이지만 비원시재귀)**, **μ-재귀(튜링과 동등)** — 를 체계적으로 정리합니다.

---

## 1) 원시 재귀 함수 (Primitive Recursive, PR)

### 1.1 생성 체계(초기 함수 + 닫힘 연산)
정의역·공역은 \(\mathbb N=\{0,1,2,\dots\}\).

- **초기 함수**
  - 영함수 \(Z(x)=0\)
  - 후행자 \(S(x)=x+1\)
  - 사영 \(U_i^k(x_1,\dots,x_k)=x_i\)

- **합성(Composition)**  
  \[
  f(\vec x)=h\big(g_1(\vec x),\dots,g_m(\vec x)\big)
  \]

- **원시 재귀(Primitive Recursion)**  
  \[
  \begin{aligned}
  f(\vec x,0) &= g(\vec x) \\
  f(\vec x,S(y)) &= h\big(\vec x, y, f(\vec x,y)\big)
  \end{aligned}
  \]
  여기서 \(g,h\)가 이미 구성 가능하면 \(f\)도 허용.

> 원시 재귀는 **둘째 인자 \(y\)** 를 0→1→2… 로 **유한히 증가**시키며 정의하므로 **항상 정지(총함수)** 입니다.

### 1.2 기본 예시 (모두 PR)
- **덧셈** \(a+b\):  
  \(add(a,0)=a,\quad add(a,S(b))=S(add(a,b))\).
- **곱셈** \(a\cdot b\):  
  \(mul(a,0)=0,\quad mul(a,S(b))=add\big(a,mul(a,b)\big)\).
- **거듭제곱** \(a^b\), **팩토리얼** \(n!\):  
  \(fact(0)=1,\ fact(S(n))=S(n)\cdot fact(n)\).
- **잘린 뺄셈** \(a\dotminus b=\max(a-b,0)\), **부호** \(\mathrm{sg}(x)\), **=, ≤ 판정** 등 **특성/관계 함수**들.
- **유계 연산**(합/곱/최솟값/최댓값)과 **유계 최소화**도 PR:  
  \[
  \min\nolimits_{y\le t}^\!* R(\vec x,y)\quad\text{(없으면 기본값)}
  \]

### 1.3 성질
- 모든 PR 함수는 **총 계산 가능(total computable)** 입니다.
- PR은 **합성·원시재귀**에 **닫힘**(복합, 튜플/코딩, 유계 반복 가능).
- 그러나 “총 계산 가능 = PR”은 **아님**. 반례가 **Ackermann**.

---

## 2) Ackermann–Péter 함수: 총이지만 비원시재귀

### 2.1 정의(고전 버전)
\[
A(0,n)=n+1,\qquad
A(m+1,0)=A(m,1),\qquad
A(m+1,n+1)=A\!\big(m,\,A(m+1,n)\big).
\]

간단한 전개:
- \(A(1,n)=n+2\) (선형)  
- \(A(2,n)=2n+3\) (선형)  
- \(A(3,n)=2^{\,n+3}-3\) (**지수**)  
- \(A(4,n)\): **테트레이션** 급

> **총함수**(모든 입력에서 정지)지만, 그 성장률은 **모든 원시 재귀 함수**를 **지배(dominate)** 합니다.

### 2.2 왜 PR이 아닌가 — 지배(majorization) 논증 스케치
모든 PR 함수는 “원시 재귀 깊이/구조”에 따른 **성장 계층**(예: Grzegorczyk \(E_n\)) 안에 놓임을 보일 수 있고,  
각 PR \(f\)에 대해 \(\exists m\) s.t. \(\forall\vec x,\ f(\vec x)\le A(m,\,c+\max\vec x)\) 가 유도됩니다(구조 유도법).  
그런데 \(A\)는 **자기 계층을 넘어서는** 가속을 하므로 PR 밖에 있습니다.

> 실용 각주: **역 Ackermann** \(\alpha(n)\) 은 극도로 느리며, **Disjoint Set(Union–Find)**의 최악 시간에 등장합니다.

---

## 3) μ-재귀(일반/부분 재귀) 함수 — 튜링과 동등해지는 지점

### 3.1 μ(최소화) 연산자
주어진 (통상) **술어/함수** \(R(\vec x,y)\) 에 대해
\[
\mu y\ R(\vec x,y)\ :=\ \text{가장 작은 }y\ \text{로서}\ R(\vec x,y)\ \text{가 참인 }y.
\]
- **유계 최소화**( \(y\le t\) )는 **항상 정지** ⇒ PR 안에 남음.
- **무계 최소화(μ)** 는 **탐색이 무한**할 수 있어 **부분 함수**를 만듭니다(정지 보장 없음).

### 3.2 (부분) μ-재귀 함수의 생성
- 초기 함수 \(Z,S,U_i^k\),
- **합성**, **원시 재귀**,
- **무계 최소화(μ)** 를 **허용**하여 얻는 함수들을 **부분 μ-재귀 함수(partial recursive)** 라 합니다.  
  그중 **어디서나 정의된(total)** 것들을 **(일반) 재귀 함수(general/total recursive)** 라 합니다.

### 3.3 튜링 기계와의 동치 (Church–Turing–Kleene)
- **정리**: “부분 μ-재귀 함수” = “튜링 계산 가능한 **부분** 함수” = “λ-계산 가능” = “Markov 알고리즘 계산 가능”.  
  즉, **모델 독립적 계산가능성**의 공통 핵.
- **Kleene 정상형(Normal Form) 정리**(개념 스케치):  
  모든 부분 재귀 \(f\)에 대해
  \[
  f(\vec x)=U\big(\mu y\ T(e,\vec x,y)\big)
  \]
  형태로 쓸 수 있는 **보편성**. 여기서 \(T\)는 “프로그램 \(e\)”가 \(\vec x\)로 **\(y\) 단계** 내에 멈춰 **출력 코드**를 남김을 뜻하는 PR 술어, \(U\)는 해독 함수.

> 결론: **μ 한 방**이 PR을 “**튜링 완전**”으로 끌어올리지만, 그 대가로 **비정지 가능성(부분성)** 을 받아들여야 합니다.

### 3.4 예시: μ로 만드는 부분 함수들
- **무제한 소인수 탐색**
  \[
  d(x)=\mu y\ \big(y\ge2\ \wedge\ y\mid x\big)
  \]
  \(x=1\)이면 **정의되지 않음**(무한 탐색) → 부분 함수.
- **루트 찾기** \(\mu y\, [p(y)=0]\): 근이 없으면 미정(정지 실패).

---

## 4) 계층 관계 요약

\[
\boxed{\text{PR (모두 총)}}\ \subsetneq\ 
\boxed{\text{총 μ-재귀 = (일반) 재귀 = 총 튜링 계산 가능}}\ \subsetneq\
\boxed{\text{부분 μ-재귀 = 부분 튜링 계산 가능}}
\]

- **PR ⊊ 총 재귀**: \(A(m,n)\) (Ackermann) 가 반례.
- **총 재귀 ⊊ 부분 재귀**: μ가 비정지를 허용(예: 정지 문제의 특성 함수는 부분 재귀 아님).

---

## 5) 원시 재귀 vs μ-재귀: 설계 직감

| 관점 | 원시 재귀(PR) | μ-재귀(부분/일반) |
|---|---|---|
| 정지성 | **항상 정지**(총) | **불명**(부분 가능) |
| 표현력 | “유계 반복/구조적 재귀” | **임의 비유계 탐색**(튜링 완전) |
| 안전성 | 검증·해석 쉬움(유계성 활용) | 강력하나 정지성/안전성 증명이 필요 |
| 예시 | 합·곱·팩토리얼·유계 합/곱 | Ackermann, μ-탐색 함수, 보편 시뮬레이터 |

> 실무적 감각: 정적 분석/검증을 중시하면 **PR/유계 재귀**에 가까운 제한(예: “안전 재귀”, RAML/Coq의 well-founded recursion)을 선호합니다.  
> 반대로 일반 목적 계산은 **μ**(또는 while) 없이 사실상 불가능합니다.

---

## 6) 보강: 튜플·코딩, PR 술어와 RE/Recursive 집합

- PR 함수들로 **코딩 함수**(짝지음, 튜플, 시퀀스)와 **해독**도 만들 수 있어, **메타연산**을 PR 내부에서 다룰 수 있습니다.
- **PR 술어**(0/1 특성 함수가 PR)로 정의되는 집합 ⊆ **Recursive**.  
  **RE 집합**은 “**부분 재귀** 특성함수”로 표현(‘예’면 언젠가 1, ‘아니오’면 영원히 계산 중).

---

## 7) 미니 표: 핵심 공식/정의 모음

- **원시 재귀 스키마**
  \[
  f(\vec x,0)=g(\vec x),\quad
  f(\vec x,S(y))=h(\vec x,y,f(\vec x,y)).
  \]
- **Ackermann 전개**
  \[
  A(3,n)=2^{\,n+3}-3,\quad
  A(4,n)\approx {}^{(n+3)}2-3\ (\text{테트레이션}).
  \]
- **Kleene 정상형**
  \[
  f(\vec x)=U\big(\mu y\ T(e,\vec x,y)\big).
  \]

---

## 8) 작은 실습: PR로 덧셈·곱셈·팩토리얼

```text
# add(a,b): PR
add(a, 0)      = a
add(a, S(b))   = S(add(a,b))

# mul(a,b): PR
mul(a, 0)      = 0
mul(a, S(b))   = add(a, mul(a,b))

# fact(n): PR
fact(0)        = 1
fact(S(n))     = S(n) * fact(n)
```

---

## 9) 한 페이지 요약
- **PR**: 안전한 총함수 구역(유계/구조적 재귀). 파생 연산·유계 최소화까지 풍부.  
- **Ackermann**: 총이지만 PR을 넘어서는 대표. “PR의 한계”를 보여줌.  
- **μ-재귀**: PR + **무계 최소화(μ)** = **튜링 완전**(부분 재귀). 총한 부분이 **(일반) 재귀**.  
- **메시지**: 총/안전성을 원하면 PR(혹은 유사 제한), **표현력을 원하면 μ** — 이 둘의 균형이 계산 모델과 언어 설계의 핵심입니다.
