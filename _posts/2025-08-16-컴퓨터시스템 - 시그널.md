---
layout: post
title: 컴퓨터시스템 - 시그널
date: 2025-08-16 17:20:23 +0900
category: 컴퓨터시스템
---
# 시그널(Signal)에 대해

## 1. 개요
시그널은 **UNIX/Linux 운영체제**에서 프로세스 간 또는 커널에서 프로세스로 전달되는 **비동기적 이벤트 알림 메커니즘**입니다.  
주로 예외 상황 알림, 프로세스 제어, 이벤트 처리 등에 사용되며, 인터럽트의 소프트웨어 버전이라고 볼 수 있습니다.

- 예: `Ctrl+C` → `SIGINT` 시그널을 현재 프로세스에 전달.
- 예: 0으로 나누기 연산 → `SIGFPE` 시그널 발생.

---

## 2. 시그널의 특징
1. **비동기성**  
   - 프로세스가 실행되는 도중에도 시그널이 도착할 수 있습니다.
2. **사전 정의된 의미**  
   - 많은 시그널은 표준적으로 의미가 정의되어 있음. (예: `SIGKILL` → 즉시 종료)
3. **사용자 정의 처리 가능**  
   - 일부 시그널은 사용자 정의 핸들러로 처리할 수 있습니다.

---

## 3. 리눅스/유닉스 주요 시그널 전체 목록

아래 표는 POSIX 표준과 Linux에서 사용되는 **모든 주요 시그널**과 그 기본 동작을 정리한 것입니다.  
시그널은 `kill -l` 명령으로 시스템별 번호를 확인할 수 있으며, 일부 시그널은 OS나 아키텍처에 따라 번호가 다를 수 있습니다.

| 시그널 | 번호 | 기본 동작 | 설명 |
|--------|------|-----------|------|
| SIGHUP  | 1   | 종료      | 제어 터미널 종료 또는 데몬 재시작 요청 |
| SIGINT  | 2   | 종료      | 인터럽트 (`Ctrl+C`) |
| SIGQUIT | 3   | 코어 덤프 | 종료 + 코어 덤프 (`Ctrl+\`) |
| SIGILL  | 4   | 코어 덤프 | 잘못된 명령어 실행 |
| SIGTRAP | 5   | 코어 덤프 | 디버거 브레이크포인트 |
| SIGABRT | 6   | 코어 덤프 | `abort()` 호출 |
| SIGBUS  | 7   | 코어 덤프 | 잘못된 메모리 접근(버스 에러) |
| SIGFPE  | 8   | 코어 덤프 | 산술 예외 (0으로 나눔 등) |
| SIGKILL | 9   | 종료      | 즉시 종료 (무시/핸들링 불가) |
| SIGUSR1 | 10  | 종료      | 사용자 정의 시그널 1 |
| SIGSEGV | 11  | 코어 덤프 | 잘못된 메모리 접근(세그폴트) |
| SIGUSR2 | 12  | 종료      | 사용자 정의 시그널 2 |
| SIGPIPE | 13  | 종료      | 파이프 깨짐 (읽는 쪽 없음) |
| SIGALRM | 14  | 종료      | `alarm()` 타이머 만료 |
| SIGTERM | 15  | 종료      | 기본 종료 요청 |
| SIGSTKFLT | 16 | 종료     | 스택 오류 (거의 사용 안함) |
| SIGCHLD | 17  | 무시      | 자식 프로세스 상태 변경 |
| SIGCONT | 18  | 재개      | 정지된 프로세스 재개 |
| SIGSTOP | 19  | 정지      | 무시 불가 정지 |
| SIGTSTP | 20  | 정지      | `Ctrl+Z`로 정지 |
| SIGTTIN | 21  | 정지      | 백그라운드 프로세스가 입력 요청 |
| SIGTTOU | 22  | 정지      | 백그라운드 프로세스가 출력 요청 |
| SIGURG  | 23  | 무시      | 소켓 긴급 데이터 도착 |
| SIGXCPU | 24  | 코어 덤프 | CPU 시간 초과 |
| SIGXFSZ | 25  | 코어 덤프 | 파일 크기 초과 |
| SIGVTALRM | 26| 종료      | 가상 타이머 만료 |
| SIGPROF | 27  | 종료      | 프로파일 타이머 만료 |
| SIGWINCH | 28 | 무시      | 윈도우 크기 변경 |
| SIGIO   | 29  | 종료      | 비동기 I/O 가능 |
| SIGPWR  | 30  | 종료      | 전원 오류 |
| SIGSYS  | 31  | 코어 덤프 | 잘못된 시스템 콜 |

---

## 4. 시그널 처리 방식
시그널이 프로세스에 전달되면 커널은 다음 중 하나를 수행합니다.

- **종료(Terminate)**: 프로세스를 정상 종료.
- **코어 덤프(Core Dump)**: 프로세스 종료 후 메모리 상태를 덤프 파일로 저장.
- **정지(Stop)**: 프로세스 실행을 멈춤.
- **재개(Continue)**: 정지된 프로세스를 다시 실행.
- **무시(Ignore)**: 시그널을 무시.

---

## 5. 시그널 처리 예제

### 5.1 단순 핸들러 등록
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("시그널 %d 수신!\n", sig);
}

int main() {
    signal(SIGINT, handler); // Ctrl+C 처리
    while (1) {
        printf("실행 중...\n");
        sleep(1);
    }
    return 0;
}
```
- 실행 후 `Ctrl+C` 입력 시 `handler()`가 실행됩니다.

---

### 5.2 `sigaction()`을 사용한 고급 처리
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig, siginfo_t *info, void *context) {
    printf("시그널 %d 수신, PID: %d\n", sig, info->si_pid);
}

int main() {
    struct sigaction sa;
    sa.sa_sigaction = handler;
    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGUSR1, &sa, NULL);

    while (1) pause(); // 시그널 대기
    return 0;
}
```
- `sigaction()`은 시그널 발생 시 추가 정보(`siginfo_t`)를 전달받을 수 있습니다.

---

## 6. 시그널 마스크와 블로킹
- 시그널 마스크를 사용하면 특정 시그널을 **일시적으로 차단(block)** 할 수 있습니다.
- 예: `sigprocmask()`로 중요한 코드 실행 중 시그널 방해를 방지.

```c
sigset_t mask;
sigemptyset(&mask);
sigaddset(&mask, SIGINT);
sigprocmask(SIG_BLOCK, &mask, NULL); // SIGINT 차단
```

---

## 7. 시그널과 프로세스 제어
- `kill(pid, sig)`로 특정 프로세스에 시그널을 보낼 수 있음.
- `raise(sig)`로 현재 프로세스에 시그널을 보낼 수 있음.
- IPC 수단으로도 활용 가능 (예: `SIGUSR1`).

---

## 8. 주의할 점
- 시그널 핸들러는 **비동기적**으로 실행되므로, 안전하지 않은 함수 호출에 주의해야 함.  
  (예: `printf` 대신 `write` 사용 권장)
- 시그널 손실 가능성: 동일한 시그널이 연속해서 발생하면 하나만 처리될 수 있음 (POSIX 리얼타임 시그널 예외).

---

## 9. 결론
시그널은 **프로세스 제어와 예외 처리의 핵심 메커니즘**입니다.  
프로그램의 안정성과 성능을 위해 **핸들러의 안전성**, **시그널 마스크**, **기본 동작 이해**가 중요합니다.  
CS:APP에서도 시그널은 예외 처리, 프로세스 동기화, IPC 주제와 밀접하게 연결됩니다.