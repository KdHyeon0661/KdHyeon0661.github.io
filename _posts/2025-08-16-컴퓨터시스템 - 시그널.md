---
layout: post
title: 컴퓨터시스템 - 시그널
date: 2025-08-16 17:20:23 +0900
category: 컴퓨터시스템
---
# 시그널(Signal) — 생성·전달·처리·마스킹·리얼타임·스레드·파일디스크립터(signalfd)까지 완전 정리

> **목표**
> UNIX/POSIX(특히 Linux/glibc)에서의 **시그널**을 “표면 API” 수준을 넘어, **커널이 시그널을 생성·큐잉·전달**하고, 사용자 공간이 **마스킹/대기/처리**하는 전 과정을 **최신 관행**으로 정리한다.
> 실전에서 흔히 겪는 **SIGCHLD 좀비 처리**, **SIGPIPE**, **타임아웃/타이머**, **리얼타임 시그널**의 큐잉, **스레드와 시그널**, **signalfd/epoll 연동**, **pselect/ppoll 경쟁 조건 회피**를 모두 다룬다.
> 코드 예제는 C/POSIX 기준이며, 컴파일 시 `-pthread`(스레드 예제) 또는 `-lrt`(옛 libc에서 timer API 필요)·`-D_GNU_SOURCE`(GNU 확장) 등이 필요할 수 있다.

---

## 1. 큰 그림: 시그널의 생애주기 (Generation → Queuing → Delivery → Disposition)

```
[이벤트 발생] ─┐
(키보드, 타이머, │  kill(2), tkill/pthread_kill, 하드웨어 예외, TTY, job control)
               ▼
         [생성/대상 결정]
               ▼
      [프로세스/스레드 Pending 큐]
     ┌───────────────┬────────────────────┐
     │표준 시그널: 1비트 pending (합쳐짐) │
     │리얼타임: 다중 큐잉(순서/수가 보존) │
     └───────────────┴────────────────────┘
               ▼
  [마스크 해제 & 스케줄 가능 시 Delivery]
               ▼
  [Disposition] Default / Ignore / Handler
```

- **표준 시그널(비-리얼타임)**: 동일 종류가 여러 번 발생해도 **1회로 합쳐질 수 있음**(coalescing).
- **리얼타임 시그널(SIGRTMIN…SIGRTMAX)**: **큐잉**됨(순서/개수 보존) + `sigqueue`로 값 전달 가능.
- **한 프로세스 안의 스레드**: 프로세스 **공유 시그널 집합** + **스레드마다 마스크**. **동기 시그널**(예: SIGSEGV)은 **원인 스레드**로 간다. **비동기 시그널**은 “어느 스레드가 받는지” 규칙이 있다(§10).

---

## 2. 표준 시그널 & 리얼타임 시그널 — 번호보다 “이름과 의미”

> 번호는 아키텍처/OS에 따라 다를 수 있다. **코드에서는 항상 매크로 이름**(`SIGINT`, `SIGTERM`, `SIGRTMIN` 등)을 사용하고, 번호가 필요하면 `kill -l`로 확인하자.

### 2.1 리눅스/유닉스 주요 시그널 전체 목록

아래 표는 POSIX 표준과 Linux에서 사용되는 **모든 주요 시그널**과 그 기본 동작을 정리한 것입니다.
시그널은 `kill -l` 명령으로 시스템별 번호를 확인할 수 있으며, 일부 시그널은 OS나 아키텍처에 따라 번호가 다를 수 있습니다.

| 시그널 | 번호 | 기본 동작 | 설명 |
|--------|------|-----------|------|
| SIGHUP  | 1   | 종료      | 제어 터미널 종료 또는 데몬 재시작 요청 |
| SIGINT  | 2   | 종료      | 인터럽트 (`Ctrl+C`) |
| SIGQUIT | 3   | 코어 덤프 | 종료 + 코어 덤프 (`Ctrl+\`) |
| SIGILL  | 4   | 코어 덤프 | 잘못된 명령어 실행 |
| SIGTRAP | 5   | 코어 덤프 | 디버거 브레이크포인트 |
| SIGABRT | 6   | 코어 덤프 | `abort()` 호출 |
| SIGBUS  | 7   | 코어 덤프 | 잘못된 메모리 접근(버스 에러) |
| SIGFPE  | 8   | 코어 덤프 | 산술 예외 (0으로 나눔 등) |
| SIGKILL | 9   | 종료      | 즉시 종료 (무시/핸들링 불가) |
| SIGUSR1 | 10  | 종료      | 사용자 정의 시그널 1 |
| SIGSEGV | 11  | 코어 덤프 | 잘못된 메모리 접근(세그폴트) |
| SIGUSR2 | 12  | 종료      | 사용자 정의 시그널 2 |
| SIGPIPE | 13  | 종료      | 파이프 깨짐 (읽는 쪽 없음) |
| SIGALRM | 14  | 종료      | `alarm()` 타이머 만료 |
| SIGTERM | 15  | 종료      | 기본 종료 요청 |
| SIGSTKFLT | 16 | 종료     | 스택 오류 (거의 사용 안함) |
| SIGCHLD | 17  | 무시      | 자식 프로세스 상태 변경 |
| SIGCONT | 18  | 재개      | 정지된 프로세스 재개 |
| SIGSTOP | 19  | 정지      | 무시 불가 정지 |
| SIGTSTP | 20  | 정지      | `Ctrl+Z`로 정지 |
| SIGTTIN | 21  | 정지      | 백그라운드 프로세스가 입력 요청 |
| SIGTTOU | 22  | 정지      | 백그라운드 프로세스가 출력 요청 |
| SIGURG  | 23  | 무시      | 소켓 긴급 데이터 도착 |
| SIGXCPU | 24  | 코어 덤프 | CPU 시간 초과 |
| SIGXFSZ | 25  | 코어 덤프 | 파일 크기 초과 |
| SIGVTALRM | 26| 종료      | 가상 타이머 만료 |
| SIGPROF | 27  | 종료      | 프로파일 타이머 만료 |
| SIGWINCH | 28 | 무시      | 윈도우 크기 변경 |
| SIGIO   | 29  | 종료      | 비동기 I/O 가능 |
| SIGPWR  | 30  | 종료      | 전원 오류 |
| SIGSYS  | 31  | 코어 덤프 | 잘못된 시스템 콜 |

---

### 2.2 리얼타임 시그널
- **`SIGRTMIN` … `SIGRTMAX`**: 구현마다 범위가 다를 수 있으니 **런타임 매크로**를 쓰자.
- **큐잉/순서 보장/우선순위**: 번호 작은 쪽이 먼저 전달. 동일 번호는 FIFO.
- **값 전달**: `sigqueue(pid, signo, union sigval)`로 **정수/포인터 1개**를 함께 보낼 수 있다(핸들러에서 `info->si_value`).

---

## 3. 안전한 설치: `sigaction` 중심, `signal`은 지양

```c
#include <signal.h>

static void on_sig(int sig, siginfo_t* info, void* uctx) {
    (void)uctx;
    // async-signal-safe 함수만! (printf 금지)
    // 예: write(STDERR_FILENO, "INT\n", 4);
}

int install(void) {
    struct sigaction sa = {0};
    sa.sa_sigaction = on_sig;
    sa.sa_flags = SA_SIGINFO | SA_RESTART;   // SA_RESTART: 일부 블로킹 호출 재시작
    sigemptyset(&sa.sa_mask);
    // 예: SIGINT, SIGTERM 설치
    if (sigaction(SIGINT,  &sa, NULL) < 0) return -1;
    if (sigaction(SIGTERM, &sa, NULL) < 0) return -1;
    return 0;
}
```

**왜 `sigaction`인가?**
- `siginfo_t`로 **추가 정보**(보낸 PID/UID, 값, 오류 코드 등)를 받는다.
- 다양한 **플래그**로 동작 제어: `SA_RESTART`, `SA_NODEFER`, `SA_RESETHAND`, `SA_NOCLDSTOP`, `SA_NOCLDWAIT`, `SA_ONSTACK`(§8), …
- `signal(2)`은 시스템마다 의미/재설치 여부가 달랐던 **역사적 API**. **이식성/정확성**을 원하면 `sigaction`.

---

## 4. 핸들러에서 “하면 안 되는 것” — Async-signal-safety

핸들러는 **비동기적으로** 실행된다. **재진입 가능**하며, 많은 라이브러리 함수는 **안전하지 않다**.

### 4.1 안전한/위험한 것
- **OK**: `write`, `_exit`, `sig_atomic_t` 플래그 설정, `sigqueue`(리얼타임), 일부 원자적 연산
- **주의/사용 금지**: `printf`, `malloc/free`, `pthread_mutex_lock`, 대부분의 libc 함수

### 4.2 안전 패턴: “플래그만 세우고 메인 루프에서 처리”
```c
#include <signal.h>
#include <stdatomic.h>
#include <unistd.h>

static volatile sig_atomic_t g_quit = 0;

static void on_term(int sig){ (void)sig; g_quit = 1; }

int main(void){
    struct sigaction sa = {.sa_handler = on_term};
    sigemptyset(&sa.sa_mask);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGINT,  &sa, NULL);

    while (!g_quit) {
        // 작업...
        pause(); // 또는 pselect/epoll_wait 등
    }
    // 안전한 종료 처리
}
```

---

## 5. 시그널 마스크/블로킹 — `pthread_sigmask`, `sigsuspend`, `pselect`

### 5.1 마스크 기본
```c
sigset_t set;
sigemptyset(&set);
sigaddset(&set, SIGINT);
pthread_sigmask(SIG_BLOCK, &set, NULL);  // 현재 스레드에서 SIGINT 블록
```
- 프로세스 전체가 아니라 **스레드별 마스크**.
- **중요 구역**에서 시그널을 블록하고, 끝난 뒤 해제한다.

### 5.2 원자적으로 “마스크 변경 + 대기”: `sigsuspend`
```c
sigset_t waitset;
sigemptyset(&waitset);                // 기다리는 동안 허용할 집합
sigsuspend(&waitset);                 // 도착 즉시 깨어남(그리고 이전 마스크 복원)
```
`while(…){ sigsuspend(...); }` 패턴은 **경쟁 조건**(unlock 직후 시그널 도착) 없이 기다리기에 유리.

### 5.3 `pselect/ppoll`로 I/O 대기 + 마스크 설정
```c
fd_set rfds; FD_ZERO(&rfds); FD_SET(fd, &rfds);
sigset_t tmpmask; sigemptyset(&tmpmask);   // 대기 중 허용할 시그널 집합
int r = pselect(fd+1, &rfds, NULL, NULL, NULL, &tmpmask);
```
- `select`+`sigprocmask`의 **타이밍 경쟁**을 해결: **마스크 교체와 대기를 원자적으로** 수행.

---

## 6. SIGCHLD — 좀비 회수 & 고급 플래그

### 6.1 기본 핸들러
```c
#include <sys/wait.h>
#include <signal.h>
#include <unistd.h>

static void on_chld(int sig){
    (void)sig;
    // async-signal-safe: nonblocking 반복 회수
    int status; pid_t pid;
    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        // 회수됨
    }
}

int main(void){
    struct sigaction sa = {.sa_handler=on_chld, .sa_flags=SA_RESTART|SA_NOCLDSTOP};
    sigemptyset(&sa.sa_mask);
    sigaction(SIGCHLD, &sa, NULL);
    // ...
}
```

- `SA_NOCLDSTOP`: 자식의 **정지/재개**에 대해서는 SIGCHLD 미발생.
- `SA_NOCLDWAIT`: **좀비 미생성**(커널이 자동 회수). wait 호출 불필요.

---

## 7. SIGPIPE — 파이프/소켓 “깨짐”의 정석 처리

- **기본 동작**: 종료. 파이프/소켓 상대가 닫혔는데 `write()`하면 **SIGPIPE** 또는 `EPIPE`.
- **선호 패턴**: 전역 무시 + 에러 코드 처리
```c
signal(SIGPIPE, SIG_IGN);        // 전체 프로세스에서 무시
ssize_t n = send(sock, buf, len, MSG_NOSIGNAL); // 리눅스: 이 호출만 SIGPIPE 억제
if (n < 0 && errno == EPIPE) { /* 리모트가 닫음 */ }
```
- BSD류: `SO_NOSIGPIPE` 소켓 옵션도 있다.

---

## 8. 대체 시그널 스택 — `sigaltstack` + `SA_ONSTACK`

스택 오버플로우/큰 프레임에서 **기본 스택 공간이 부족**하면, 핸들러가 실행될 공간을 **대체 스택**으로 준비한다.

```c
#include <signal.h>
#include <string.h>
#include <stdlib.h>

int setup_altstack(void){
    stack_t ss = {0};
    ss.ss_sp = malloc(SIGSTKSZ);
    ss.ss_size = SIGSTKSZ;
    ss.ss_flags = 0;
    if (sigaltstack(&ss, NULL) < 0) return -1;

    struct sigaction sa = {0};
    sa.sa_sigaction = /* handler */;
    sa.sa_flags = SA_SIGINFO | SA_ONSTACK;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGSEGV, &sa, NULL);
    return 0;
}
```

---

## 9. 타이머와 시그널 — `alarm`, `setitimer`, `timer_create`

### 9.1 고전 API
- `alarm(sec)` → **SIGALRM**
- `setitimer(ITIMER_REAL/PROF/VTALRM, …)` → `SIGALRM` / `SIGPROF` / `SIGVTALRM`

### 9.2 POSIX 타이머: 시그널/값 전달
```c
#define _POSIX_C_SOURCE 200809L
#include <time.h>
#include <signal.h>
#include <string.h>

static void on_timer(int sig, siginfo_t* info, void* ctx){
    (void)sig; (void)ctx;
    // info->si_value.sival_int 로 사용자 값 수신
}

int start_timer(int signo){
    struct sigaction sa = {.sa_flags=SA_SIGINFO, .sa_sigaction=on_timer};
    sigemptyset(&sa.sa_mask);
    sigaction(signo, &sa, NULL);

    timer_t tid;
    struct sigevent sev = {.sigev_notify = SIGEV_SIGNAL,
                           .sigev_signo = signo,
                           .sigev_value.sival_int = 123};
    timer_create(CLOCK_REALTIME, &sev, &tid);

    struct itimerspec its = { .it_value = {1,0}, .it_interval = {1,0} }; // 1초 주기
    timer_settime(tid, 0, &its, NULL);
    return 0;
}
```
> 리얼타임 시그널을 쓰면 큐잉/값 전달로 **정밀 주기 이벤트**를 안정적으로 처리 가능.

---

## 10. 스레드와 시그널 — 전달 규칙 & 전용 핸들링 스레드

- **마스크는 스레드별**: `pthread_sigmask`로 각 스레드의 블로킹 집합을 제어.
- **동기 시그널**(SIGSEGV/ILL/FPE/BUS): **원인 스레드**로 전달.
- **비동기 시그널**: 프로세스 시그널 집합에서 **그 시그널을 블록 해제한 임의의 스레드**가 수신.
- **권장 패턴**: **전용 시그널 스레드** 1개를 만들고, 다른 스레드에서는 모두 블록 → 전용 스레드가 `sigwaitinfo/sigtimedwait`로 수신.

```c
void* signal_thread(void* arg){
    sigset_t set = *(sigset_t*)arg;
    for(;;){
        siginfo_t si;
        int s = sigwaitinfo(&set, &si);
        if (s == SIGTERM || s == SIGINT) break;
        // si로 세부 처리
    }
    return NULL;
}

int main(void){
    sigset_t set; sigemptyset(&set);
    sigaddset(&set, SIGINT); sigaddset(&set, SIGTERM);
    pthread_sigmask(SIG_BLOCK, &set, NULL);  // 메인 포함 모든 스레드에서 블록
    pthread_t th; pthread_create(&th, NULL, signal_thread, &set);
    // … 작업 …
    pthread_join(th, NULL);
}
```

---

## 11. 리얼타임 시그널 큐잉 & `sigqueue` 값 전달

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

static void on_rt(int sig, siginfo_t* info, void* ctx){
    (void)ctx;
    // 여러 번 보내면 여러 개 큐잉. 값은 si_value
    dprintf(STDERR_FILENO, "RT %d val=%d from PID=%d\n",
            sig, info->si_value.sival_int, info->si_pid);
}

int main(void){
    int rt = SIGRTMIN;               // 런타임에서 정한 범위 사용
    struct sigaction sa = {.sa_flags=SA_SIGINFO, .sa_sigaction=on_rt};
    sigemptyset(&sa.sa_mask);
    sigaction(rt, &sa, NULL);

    union sigval v = {.sival_int=42};
    sigqueue(getpid(), rt, v);       // 자기 자신에게 보내기
    pause();
}
```

---

## 12. `signalfd` — 시그널을 “파일디스크립터”로 읽기 (Linux 전용)

이벤트 루프(예: `epoll`)에 시그널을 깔끔하게 통합한다.

```c
#define _GNU_SOURCE
#include <sys/signalfd.h>
#include <sys/epoll.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>

int main(void){
    sigset_t set; sigemptyset(&set);
    sigaddset(&set, SIGINT); sigaddset(&set, SIGTERM);
    pthread_sigmask(SIG_BLOCK, &set, NULL);      // 반드시 블록 상태여야 함

    int sfd = signalfd(-1, &set, SFD_CLOEXEC);
    int ep  = epoll_create1(EPOLL_CLOEXEC);
    struct epoll_event ev = {.events=EPOLLIN, .data.fd=sfd};
    epoll_ctl(ep, EPOLL_CTL_ADD, sfd, &ev);

    for(;;){
        struct epoll_event out;
        epoll_wait(ep, &out, 1, -1);
        if (out.data.fd == sfd) {
            struct signalfd_siginfo si;
            read(sfd, &si, sizeof si);
            if (si.ssi_signo == SIGINT || si.ssi_signo == SIGTERM) break;
        }
    }
}
```

---

## 13. `exec()`과 시그널 의미론(요점만)

- **마스크**: `exec*` 후에도 **보존**된다.
- **디스포지션(처리 방식)**: **핸들러로 잡혀 있던 시그널**은 **기본값으로 리셋**. **무시(SIG_IGN)**로 설정된 것은 **그대로 유지**(표준 규정).
- **번호/범위**: `SIGRTMIN`의 실제 숫자는 **런타임에 확정**되므로 하드코딩 금지.

---

## 14. `SA_RESTART`와 블로킹 I/O

- 기본적으로 일부 시스템콜은 시그널로 **EINTR**(중단)된다.
- `SA_RESTART`를 켜면 가능하면 자동 재시작.
- 그래도 **타임아웃/폴링 설계**에서는 `pselect/ppoll/epoll`과 결합해 **명시적 재시작** 로직을 쓰는 편이 견고.

---

## 15. 시그널의 “동기/비동기”와 `siginfo_t::si_code`

- **동기**: 명령 실행 중 발생(예: `SIGSEGV`, `SIGFPE`, `SIGILL`, `SIGBUS`) → **시그널 소스 스레드**에게.
- **비동기**: `kill`, TTY, 타이머, job control 등 외부 이벤트.
- `siginfo_t.si_code`로 원인을 구분: 예) `SEGV_MAPERR` vs `SEGV_ACCERR`, `FPE_INTDIV`, `BUS_ADRERR`, `SI_USER`(kill), `SI_QUEUE`(sigqueue) 등.

---

## 16. Job Control & 터미널 관련 (포그라운드/백그라운드)

- **TTY 드라이버**가 포그라운드 프로세스 그룹에 `SIGINT`(Ctrl+C), `SIGTSTP`(Ctrl+Z), `SIGQUIT` 전달.
- 백그라운드 프로세스가 터미널 **읽기**/ **쓰기** 시도 → `SIGTTIN`/`SIGTTOU` (기본은 **정지**).
- `SIGSTOP`/`SIGKILL`은 **절대 잡거나 무시할 수 없음**.

---

## 17. 리소스 제한과 시그널 — `SIGXCPU`, `SIGXFSZ`

- `setrlimit(RLIMIT_CPU, …)` 초과 → `SIGXCPU`(기본: 코어덤프).
- `RLIMIT_FSIZE` 초과 → `SIGXFSZ`.
- 핸들러에서 자원 해제/상태 저장 후 종료 시 **우아한 복구 경로** 마련.

---

## 18. 레거시/호환 포인트 & 권장 관행

- `signal(2)` 대신 `sigaction(2)`
- 전역 무시가 필요하면 **초기화 시 한번**만(예: `SIGPIPE`)
- **핸들러 내부 최소화**: 플래그만 세우고 메인 루프/전용 스레드에서 처리
- 스레드 프로그램: **전용 시그널 스레드** + 나머지 스레드 **전부 블록**
- 타이머/주기 이벤트: **POSIX 타이머 + 리얼타임 시그널** or **timerfd**(Linux 전용)
- 이벤트 루프: **signalfd + epoll**(Linux) 또는 `pselect/ppoll`
- 좀비 회수: **SIGCHLD + waitpid(WNOHANG)**, 필요 시 `SA_NOCLDWAIT`

---

## 19. 미니 실습: “깨끗한 종료 + 타임아웃 + SIGCHLD 회수”

```c
#define _POSIX_C_SOURCE 200809L
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>

static volatile sig_atomic_t g_quit = 0;
static void on_term(int s){ (void)s; g_quit = 1; }

static void on_chld(int s){
    (void)s;
    int st; pid_t p;
    while ((p = waitpid(-1, &st, WNOHANG)) > 0) {
        // 회수됨: p
    }
}

int main(void){
    struct sigaction sa = {0};
    sigemptyset(&sa.sa_mask);

    sa.sa_handler = on_term; sa.sa_flags = SA_RESTART;
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);

    sa.sa_handler = on_chld; sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;
    sigaction(SIGCHLD, &sa, NULL);

    alarm(10); // 10초 뒤 SIGALRM → 종료 트리거
    sigaction(SIGALRM, &(struct sigaction){.sa_handler=on_term}, NULL);

    if (fork()==0) { sleep(2); _exit(0); } // 자식 1
    if (fork()==0) { sleep(5); _exit(0); } // 자식 2

    while (!g_quit) pause();
    // 정리/종료
    return 0;
}
```

---

## 20. 자주 겪는 함정과 해결

| 상황 | 원인 | 권장 해법 |
|---|---|---|
| 핸들러에서 `printf`/`malloc` 사용 | **비동기-안전 아님** | 플래그 세팅 + 메인에서 처리, `write`만 사용 |
| 블로킹 I/O가 자주 `EINTR` | 시그널 개입 | `SA_RESTART`, 또는 `pselect/ppoll`로 대기 설계 |
| 파이프/소켓 쓰기 후 종료 | SIGPIPE 기본동작 | `signal(SIGPIPE, SIG_IGN)` + `EPIPE` 처리, `MSG_NOSIGNAL` |
| 좀비 누적 | SIGCHLD 무시 | 핸들러에서 `waitpid(-1, WNOHANG)` 반복, 또는 `SA_NOCLDWAIT` |
| 타임아웃이 간헐 실패 | 마스크/대기 경쟁 | `pselect/ppoll`/`sigsuspend` 사용 |
| 스레드에서 “누가 받는지” 불명 | 마스크 제각각 | **전용 시그널 스레드** + 나머지 블록 |
| 리얼타임 번호 충돌 | glibc 내부 사용과 겹침 | **`SIGRTMIN`에서 오프셋 계산**하여 사용. 하드코딩 금지 |

---

## 21. 부록 A — `siginfo_t`에서 자주 쓰는 필드

- `si_signo`: 번호, `si_errno`: 오류번호(거의 0)
- `si_code`: 원인(`SI_USER`, `SI_QUEUE`, `SEGV_MAPERR`, `FPE_INTDIV`, …)
- `si_pid`, `si_uid`: 보낸 프로세스/사용자
- `si_value`: `sigqueue`/POSIX timer 값
- `si_addr`: 잘못 접근한 주소(SIGSEGV/BUS)
- `si_status`: 자식 종료 상태(SIGCHLD)

---

## 22. 부록 B — 최소 안전 함수(발췌)

- `_exit`, `abort`, `signal`(일부 구현 차 주의), `sigaction`, `sigprocmask`, `sigsuspend`, `write`, `select`(비권장; `pselect` 권장), `waitpid`, `kill`, `getpid`, `alarm`, `sleep`(비권장), `fork`(제약 有), …
- **정확한 목록은 시스템 매뉴얼의 “Async-signal-safe” 표를 확인**. 실전에서는 **핸들러 내부 최소화**가 정답.

---

## 23. 한 줄 결론

시그널은 **비동기 이벤트**를 프로세스(와 스레드)에 전달하는 **핵심 커널 인터페이스**다.
견고한 프로그램은 **`sigaction`·마스크·대기(pselect/sigwait)** 를 올바르게 조합해
**정리 가능한 종료, 정확한 타임아웃, 좀비 회수, 안전한 I/O, 스레드 간 일관된 처리**를 구현한다.
리얼타임 시그널·signalfd까지 익히면 **이벤트 루프/고성능 서버**에서도 시그널은 더 이상 골칫거리가 아니다.
