---
layout: post
title: Elixir - 예외/비정상
date: 2025-11-23 22:25:23 +0900
category: Elixir
---
# Elixir 예외/비정상 흐름 완전 정리

## A.0 전체 지도 — Elixir의 “비정상 흐름” 3종

Elixir/BEAM에는 서로 기원이 다른 “비정상 흐름”이 공존한다.
이걸 섞어 쓰면 디버깅이 지옥이 되므로, **각 용도와 경계를 딱 고정**해 두는 게 핵심이다.

| 분류 | 만드는 방법 | 잡는 방법 | 성격/용도 |
|---|---|---|---|
| 예외(exception) | `raise/1,2`, `Kernel.raise/2` | `try/rescue` | 일반적인 오류 처리. “정말 예외적인 상황”에만 |
| throw | `throw/1` | `try/catch` | 조기 탈출(legacy/Erlang 호환). 가급적 피함 |
| exit(signal) | `exit/1`, 프로세스 크래시 | `try/catch :exit`, `trap_exit` | 프로세스 생명주기/OTP 복구 메커니즘 |

- **99%의 Elixir 코드는 예외만 제대로 쓰면 된다.**
- `throw`는 “Enum/with로 못 푸는 특수 상황”에서만.
- `exit`는 **프로세스적 사건**(재시작/격리/전파)으로 다룬다.

---

## _A.1 예외 생성하기 (raise / try / rescue / after)_

Elixir의 예외는 **`raise/1,2`** 로 발생시키고, **`try ... rescue ... after ... end`** 로 처리한다.
`rescue` 는 **예외 객체(구조체)** 를 패턴 매칭으로 분기한다.

예외는 내부적으로 다음 정보를 갖는다.

1) **예외 구조체**(모듈)
2) **message**(문자열)
3) **stacktrace**(해당 시점의 호출 스택)

---

### A.1.1 가장 단순한 예 (초안 유지 + 미세 보강)

```elixir
defmodule A1.Basic do
  def div!(a, b) do
    if b == 0, do: raise ArithmeticError, "division by zero"
    a / b
  end

  def safe_div(a, b) do
    try do
      div!(a, b)
    rescue
      e in ArithmeticError ->
        {:error, {:arith, e.message}}
    after
      :ok = :ok
    end
  end
end

A1.Basic.safe_div(10, 2)   # 5.0
A1.Basic.safe_div(10, 0)   # {:error, {:arith, "division by zero"}}
```

- `raise Module, message` 형태는 **그 모듈의 예외 구조체**를 만든다.
- `after` 블록은 예외 여부와 무관하게 **항상 실행**된다.

#### `after`가 중요한 이유

`after`는 **리소스 정리의 “최후 보루”**다.

- 파일 핸들 닫기
- 락 해제
- 임시 디렉터리 삭제
- ETS/포트/소켓 정리

`try/rescue` 없이 `after`만 쓰는 것도 가능하다.

```elixir
try do
  # 정상 처리
after
  # 반드시 실행되는 정리
end
```

---

### A.1.2 `rescue` 패턴 매칭 (초안 유지 + “순서”와 “변수 바인딩” 보강)

```elixir
defmodule A1.Match do
  def parse_int!(s) do
    case Integer.parse(s) do
      {n, ""} -> n
      _ -> raise ArgumentError, "not an integer: #{inspect(s)}"
    end
  end

  def parse_int(s) do
    try do
      {:ok, parse_int!(s)}
    rescue
      %ArgumentError{message: msg} ->
        {:error, {:bad_int, msg}}

      e in [RuntimeError, FunctionClauseError] ->
        {:error, {:unexpected, e}}

      _ ->
        {:error, :unknown}
    end
  end
end
```

핵심 포인트:

1) **`rescue`는 위에서 아래로 매칭**한다.
   - 가장 구체적인 예외 → 가장 일반적인 예외 순서로 작성.

2) `e in ExceptionModule`
   - “해당 예외 타입인지” 체크 + 변수 `e` 바인딩.

3) `%ExceptionStruct{}`로 **필드 직접 매칭/접근** 가능.

#### rescue가 “모든 에러”를 잡지 않는다는 점

`rescue`는 **예외(exception)**만 잡는다.
`exit`/`throw`/Erlang error는 기본적으로 `rescue`로 안 잡힌다.
이건 A.2에서 `catch`로 다룬다.

---

### A.1.3 raise 변형들 (초안 유지 + `raise/1` 내부 타입 설명)

```elixir
defmodule A1.Raises do
  def r1, do: raise "runtime error!"                   # RuntimeError
  def r2, do: raise ArgumentError                      # 기본 메시지
  def r3, do: raise ArgumentError, message: "bad arg"  # 필드 키워드
  def r4, do: raise(%ArgumentError{message: "oops"})   # 구조체 직접
end
```

- `raise "msg"`는 사실상 `raise RuntimeError, "msg"`와 동일하다.
- `raise SomeError`는 그 모듈의 **default message/fields**로 구조체 생성.

---

### A.1.4 `after` 로 리소스 정리 (초안 유지 + “중첩 after” 패턴)

```elixir
defmodule A1.FileDemo do
  def read_first_line(path) do
    file = File.open!(path, [:read])

    try do
      IO.read(file, :line)
    after
      File.close(file)
    end
  end
end
```

#### 실전 패턴: 여러 리소스의 중첩 정리

```elixir
defmodule A1.MultiResource do
  def run(path) do
    file = File.open!(path, [:read])
    tab  = :ets.new(:tmp, [:set, :private])

    try do
      line = IO.read(file, :line)
      :ets.insert(tab, {:line, line})
      {:ok, line}
    after
      :ets.delete(tab)
      File.close(file)
    end
  end
end
```

- 정리는 **생성 역순**으로 하는 게 관례(스택처럼).

---

### (초안 유지 + “스택트레이스가 왜 중요한가”)

```elixir
defmodule A1.Reraise do
  def wrap(fun) do
    try do
      fun.()
    rescue
      e ->
        IO.puts("audit: #{inspect(e)}")
        reraise e, __STACKTRACE__
    end
  end
end
```

- `reraise/2`는 **원래 스택트레이스**를 보존한다.
- `raise e`로 다시 던지면 **스택이 현재 위치로 갈아끼워져** 원점 추적이 어려워진다.

#### 실전: 일부 정보만 붙이고 재발생

```elixir
defmodule A1.Reraise2 do
  def wrap(fun, ctx) do
    try do
      fun.()
    rescue
      e ->
        require Logger
        Logger.error("ctx=#{inspect(ctx)} error=#{Exception.message(e)}")
        reraise e, __STACKTRACE__
    end
  end
end
```

---

### A.1.6 스택트레이스 읽기와 포맷

Elixir는 예외를 사람이 읽기 좋게 포맷하는 유틸을 제공한다.

```elixir
defmodule A1.Stack do
  def demo do
    try do
      raise "boom"
    rescue
      e ->
        formatted = Exception.format(:error, e, __STACKTRACE__)
        IO.puts(formatted)
        {:error, e}
    end
  end
end
```

- 운영 로깅은 보통 이 포맷을 그대로 쓴다.
- 민감정보(토큰/계정/개인정보)는 예외 메시지에 넣지 않는다.

---

## _A.2 catch, exit, throw_

Elixir에는 둘 이상의 “비정상 흐름 메커니즘”이 있다.

- **exception(raise/rescue)**: 일반적 예외
- **throw/catch**: 조기 탈출(legacy/Erlang 호환)
- **exit**: 프로세스 종료 신호(OTP 크래시 전파)

---

### A.2.1 throw/catch — 조기 탈출 (초안 유지 + “왜 피하는가” 보강)

```elixir
defmodule A2.ThrowCatch do
  def find_first_big(xs) do
    try do
      Enum.each(xs, fn x -> if x > 1000, do: throw({:found, x}) end)
      :not_found
    catch
      {:found, x} -> {:ok, x}
    end
  end
end

A2.ThrowCatch.find_first_big([1,2,999,1001,3])  # {:ok, 1001}
```

- `throw/1`는 예외가 아니다.
- 매칭되는 `catch`가 없으면 **결국 `ThrowError` 예외**로 바뀐다.
- throw는 **제어 흐름을 숨긴다.** 호출자가 타입 시스템이나 함수 시그니처만 보고는 알 수 없다.

#### throw가 남기는 “유지보수 비용”

- 코드 리뷰에서 흐름 파악이 어려움
- 함수 합성/pipe에서 예상치 못한 비정상 탈출
- `rescue`가 잡지 못하므로 오류 경계가 불명확

**권장 대안**(초안 유지):

```elixir
defmodule A2.Better do
  def find_first_big(xs) do
    case Enum.find(xs, &(&1 > 1000)) do
      nil -> :not_found
      x -> {:ok, x}
    end
  end
end
```

---

### A.2.2 exit — 프로세스 종료 신호 (초안 유지 + OTP 관점 보강)

`exit/1`은 **현재 프로세스를 종료**한다. 이유(reason)는 슈퍼바이저가 재시작 정책을 판단하는 근거다.

```elixir
defmodule A2.Exit do
  def boom(reason \\ :bad_things), do: exit(reason)
end

spawn(fn -> A2.Exit.boom(:fatal) end)
```

#### exit는 “에러가 아니라 사건”이다

exit는 다음과 같은 상황에서 자연스럽게 발생한다.

- 프로세스가 예외로 크래시
- `GenServer.stop/3`
- `Task.await/2` 타임아웃
- 링크/모니터 전파

따라서 exit를 잡는다면
“내가 지금 프로세스 생명주기 사건을 다루는 중”이라는 인식이 필요하다.

---

#### 링크(link)와 `trap_exit`

```elixir
pid = spawn(fn -> Process.sleep(:infinity) end)
Process.link(pid)

self() |> Process.flag(:trap_exit, true)
linked = spawn_link(fn -> exit(:boom) end)

receive do
  {:EXIT, ^linked, reason} -> IO.puts("got EXIT: #{inspect(reason)}")
after
  1000 -> :timeout
end
```

- 링크된 프로세스의 exit는 **나에게도 EXIT를 보낸다**.
- `trap_exit: true`면 크래시 대신 **메시지로 수신**하여 처리할 수 있다.
- 이 패턴은 OTP 내부에서 자주 쓰지만, 애플리케이션 로직에서는 필요한 곳에만 쓴다.

---

#### GenServer에서 exit 대신 `{:stop, reason, ...}`

GenServer 내부에서 `exit/1`을 직접 쓰면
“어디서 왜 죽었는지”가 흐릿해질 수 있다.

보통은:

```elixir
def handle_call(:boom, _from, state) do
  {:stop, :boom, {:error, :boom}, state}
end
```

- 슈퍼바이저는 reason을 보고 재시작 여부를 판단.

---

### A.2.3 try ... catch — throw/exit/error 잡기 (초안 유지 + “catch 패턴 문법” 정리)

```elixir
defmodule A2.TryCatch do
  def demo(fun) do
    try do
      fun.()
    catch
      :throw, t -> {:caught_throw, t}
      :exit, r -> {:caught_exit, r}
      :error, %ArgumentError{} = e -> {:caught_error, e}
    end
  end
end

A2.TryCatch.demo(fn -> throw(:hello) end)            # {:caught_throw, :hello}
A2.TryCatch.demo(fn -> exit(:shutdown) end)          # {:caught_exit, :shutdown}
A2.TryCatch.demo(fn -> raise ArgumentError, "x" end) # {:caught_error, %ArgumentError{...}}
```

catch의 형태는 다음과 같다.

- `:throw, term`
- `:exit, reason`
- `:error, exception_or_term`

일반 Elixir 코드에서는

- 예외는 `rescue`
- throw/exit는 정말 필요할 때만 `catch`

로 분리하는 게 표준이다.

---

## _A.3 새로운 예외 정의하기 (defexception)_

사용자 정의 예외는 **`defexception`**로 정의한다.
예외는 결국 **구조체**이며, 기본적으로 `Exception` behaviour를 따른다.

---

### A.3.1 최소 예제 (초안 유지)

```elixir
defmodule A3.MyError do
  defexception [:code, :context, message: "something went wrong"]
end

defmodule A3.Service do
  def run(ctx) do
    if ctx[:ok] do
      :ok
    else
      raise A3.MyError, code: 42, context: ctx
    end
  end

  def safe_run(ctx) do
    try do
      run(ctx)
    rescue
      %A3.MyError{code: c, context: ctx} = e ->
        {:error, {:my_error, c, e.message, ctx}}
    end
  end
end
```

---

### A.3.2 `message/1` 커스터마이즈 (초안 유지)

```elixir
defmodule A3.NotFoundError do
  defexception [:resource, :id]

  @impl true
  def message(%__MODULE__{resource: r, id: id}) do
    "#{inspect(r)} not found (id=#{inspect(id)})"
  end
end
```

---

### A.3.3 예외 설계 실전 규칙

#### 예외는 “분류용 필드”를 가져야 한다

예외는 상속이 없다.
따라서 **공통 필드/태그로 분류**한다.

```elixir
defmodule A3.DomainError do
  defexception [:kind, :detail, message: "domain error"]
end

# kind로 분류

raise A3.DomainError, kind: :validation, detail: %{field: :age}
```

`rescue`에서:

```elixir
rescue
  %A3.DomainError{kind: :validation} = e -> {:error, {:invalid, e.detail}}
  %A3.DomainError{kind: :conflict}   = e -> {:error, {:conflict, e.detail}}
```

---

#### public API는 값, `!` 함수만 예외

Elixir 생태계의 대표적인 관례다.

- `foo/1` → `{:ok, v} | {:error, r}`
- `foo!/1` → 실패 시 예외

```elixir
def get_user(id) do
  case Repo.fetch(id) do
    nil -> {:error, :not_found}
    u -> {:ok, u}
  end
end

def get_user!(id) do
  case get_user(id) do
    {:ok, u} -> u
    {:error, :not_found} ->
      raise A3.NotFoundError, resource: :user, id: id
  end
end
```

이 규칙이 있으면:

- 호출자는 함수 이름만 보고 “예외 여부”를 즉시 알 수 있다.
- 정상 흐름은 값으로 합성 가능하다.

---

#### 라이브러리 예외는 “최소화”

라이브러리가 예외를 과도하게 던지면
사용자가 오류 경계를 통제하기 어렵다.

- 라이브러리 최상위 API는 **값 기반 실패**가 기본
- 예외는 `!` 또는 명백한 프로그래밍 오류에 한정

---

### A.3.4 로깅/관찰성 연결 (초안 유지 + “표준 에러 이벤트”)

```elixir
require Logger

rescue
  e ->
    Logger.error(Exception.format(:error, e, __STACKTRACE__))
    :telemetry.execute([:app, :error], %{count: 1}, %{
      exception: e,
      stacktrace: __STACKTRACE__
    })
    reraise e, __STACKTRACE__
```

- 운영에서는 stacktrace 전체가 너무 크면 샘플링/요약 정책을 둔다.

---

## _A.4 이제 이 부록을 ‘거의’ 무시하자 — 실무 가이드라인_

핵심 원칙:

1) **정상 흐름은 값으로**
2) **예외는 진짜 예외 상황에만**
3) **exit/throw는 OTP 사건/호환 문제에만**

---

### A.4.1 값으로 표현하기 (with 체인)

```elixir
defmodule A4.WithStyle do
  def flow(user_id) do
    with {:ok, user} <- get_user(user_id),
         {:ok, plan} <- get_plan(user),
         {:ok, bill} <- charge(user, plan) do
      {:ok, bill}
    else
      {:error, :no_user} -> {:error, :not_found}
      {:error, reason}   -> {:error, {:billing_failed, reason}}
    end
  end

  defp get_user(_), do: {:error, :no_user}
  defp get_plan(_), do: {:ok, :pro}
  defp charge(_, _), do: {:ok, %{id: "tx_1"}}
end
```

- “실패는 값”이므로 합성이 자연스럽다.
- 예외 처리 블록이 코드 곳곳에 퍼지지 않는다.

---

### A.4.2 `throw/catch`는 피하자 (재강조)

- 실전 대안: `Enum.find/2`, `Enum.reduce_while/3`, `with`, 패턴매칭

`reduce_while`로 throw 대체:

```elixir
defmodule A4.ReduceWhile do
  def find_first_big(xs) do
    Enum.reduce_while(xs, :not_found, fn x, _acc ->
      if x > 1000, do: {:halt, {:ok, x}}, else: {:cont, :not_found}
    end)
  end
end
```

---

### A.4.3 `exit`는 프로세스 사건으로 다뤄라

비즈니스 로직이 exit를 던지는 순간

- 오류 경계가 “프로세스 경계”로 새고
- 슈퍼비전 재시작으로 **중복 부작용**이 생길 수 있다.

“프로세스는 크래시해도 좋다”는 철학은

- **순수/멱등/재시도 가능 설계가 선행될 때만** 안전하다.

---

### A.4.4 Task/OTP와 예외의 상호작용

#### Task.await/2는 실패를 exit로 전달할 수 있다

```elixir
defmodule A4.TaskDemo do
  def run_async(fun) do
    task = Task.async(fun)

    try do
      {:ok, Task.await(task, 2000)}
    catch
      :exit, {:timeout, _} -> {:error, :timeout}
      :exit, reason -> {:error, {:task_exit, reason}}
    end
  end
end
```

- `rescue`로는 잡히지 않음에 주의(“예외가 아니라 exit 사건”).

---

#### Supervisor 아래 Task라면 실패를 “복구 정책”으로 흡수

```elixir
defmodule A4.TaskSup do
  use Task.Supervisor

  def start_link(_), do: Task.Supervisor.start_link(name: __MODULE__)

  def run(fun) do
    Task.Supervisor.async_nolink(__MODULE__, fun)
    |> Task.await()
  end
end
```

- `nolink`를 쓰면 호출자까지 크래시 전파를 막고
  실패를 값/예외로 통제하기 쉬워진다.

---

### A.4.5 테스트 전략

#### 예외 경로 테스트

```elixir
defmodule A4.ExceptionTest do
  use ExUnit.Case

  test "NotFoundError is raised" do
    assert_raise A3.NotFoundError, fn ->
      raise A3.NotFoundError, resource: :user, id: 1
    end
  end

  test "safe API returns error tuple" do
    assert {:error, :not_found} = (fn -> {:error, :not_found} end).()
  end
end
```

#### exit/throw는 `catch_exit`, `catch_throw`로 테스트

```elixir
test "exit is caught in tests" do
  assert catch_exit(exit(:boom)) == :boom
end

test "throw is caught in tests" do
  assert catch_throw(throw(:x)) == :x
end
```

---

### A.4.6 보안/로깅 원칙

- 예외 메시지에 **민감정보 절대 금지**
- stacktrace는 “공격 표면”이 될 수 있으므로 외부 노출 금지
- 운영 로그 레벨 정책:
  - 기대 가능한 실패(예: 검증 실패)는 `warn` 또는 `info`
  - 진짜 버그/장애는 `error`

---

### A.4.7 성능 감각 — 예외를 정상 흐름으로 쓰지 말자

정상 호출 \(N\), 실패 확률 \(p\)일 때 기대 시간:

$$
E[T] \approx N \cdot \big( p \cdot t_{\text{raise/rescue}} + (1-p) \cdot t_{\text{ok}} \big)
$$

대부분 실전 시스템에서 \(p \ll 1\).
따라서 “정상 흐름을 예외로 구현”하면
거의 항상 \(t_{\text{raise/rescue}}\) 비용이 시스템을 망친다.

---

## 부록: 실전 레시피 (확장)

### 예외를 값으로 내려 “경계에서만” raise

```elixir
defmodule R1 do
  def core_step(x) do
    if is_integer(x), do: {:ok, x * 2}, else: {:error, :bad_input}
  end

  def api_step!(x) do
    case core_step(x) do
      {:ok, v} -> v
      {:error, r} -> raise ArgumentError, "bad input: #{inspect(r)}"
    end
  end
end
```

- 도메인(core) 내부는 값 기반
- API/경계에서만 `!`로 예외 변환

---

### rescue에서 “예외를 태그”로 대체

```elixir
defmodule R2 do
  def safe(fun) do
    try do
      {:ok, fun.()}
    rescue
      e in [ArgumentError, ArithmeticError] ->
        {:error, {e.__struct__, e.message}}
    end
  end
end
```

---

### catch는 외부(Erlang) 경계에서만

```elixir
defmodule R3 do
  def call_legacy(fun) do
    try do
      {:ok, fun.()}
    catch
      :throw, r -> {:error, {:legacy_throw, r}}
      :exit, r  -> {:error, {:legacy_exit, r}}
    end
  end
end
```

---

## 최종 정리

- **A.1**
  - `raise`로 예외를 만들고 `try/rescue/after`로 다룬다.
  - `after`는 항상 실행되는 리소스 정리 도구.
  - `reraise`로 스택을 보존하며 다시 던질 수 있다.

- **A.2**
  - `throw/catch`는 조기 탈출 레거시이므로 대체 가능한 경우 피한다.
  - `exit`는 프로세스 생명주기 사건이며 OTP 재시작/전파 규칙과 함께 이해해야 한다.
  - `try/catch`는 throw/exit/error 경계에서만 제한적으로 사용.

- **A.3**
  - `defexception`으로 도메인 예외를 만들고 `message/1`로 설명력을 높인다.
  - public API는 값, `!` 버전에서만 예외를 던지는 관례를 지켜라.

- **A.4**
  - 정상 흐름은 값/with로, 예외는 진짜 예외에만.
  - Task/GenServer/슈퍼비전과의 상호작용을 고려해 exit/예외 경계를 설계.
  - 테스트/로깅/보안/성능까지 묶어서 “운영 품질”을 완성하라.
