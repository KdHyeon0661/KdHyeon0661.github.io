---
layout: post
title: DB - 엔티티
date: 2025-01-25 20:20:23 +0900
category: DB
---
# 데이터베이스 엔티티 설계의 원리

## 핵심 개념

**엔티티**는 업무에서 관리해야 할 대상(사람, 사물, 개념, 사건)을 데이터로 표현한 논리적 구조입니다. 이는 물리적으로 데이터베이스의 **테이블**로 구현됩니다. 훌륭한 엔티티 설계는 명확한 정의와 경계, 안정적인 식별자, 의미 있는 속성 집합, 그리고 적절한 관계 관리 능력을 특징으로 합니다. 실무에서는 강/약 엔티티의 구분, 식별/비식별 관계의 적용, N:M 관계의 조인 엔티티로의 변환, 슈퍼/서브타입 모델링, 재귀 및 시간적(템포럴) 구조 설계 등이 도메인의 고유한 규칙에 맞춰 활용됩니다.

---

## 엔티티의 수학적 기반과 관계

엔티티 집합을 *E*, 그 속성들의 집합을 *𝒜 = A₁ × … × Aₙ* 라고 할 때, 엔티티는 **식별자** *K ⊆ {1, …, n}* 를 통해 유일하게 구별됩니다. 즉, 두 엔티티의 모든 식별자 속성 값이 동일하면, 그 두 엔티티는 동일한 것으로 간주됩니다.

관계 *R ⊆ E₁ × E₂* 는 참여 카디널리티(1:1, 1:N, N:M)와 최소 참여(필수/선택)로 정의됩니다. 특히 N:M 관계는 대부분의 경우 데이터의 무결성과 추가 속성 수용을 위해 별도의 **조인 엔티티**로 승격하여 설계합니다.

---

## 요구사항에서 엔티티를 도출하는 체계적 접근법

개념적 엔티티를 발견하고 정제하는 과정은 다음과 같은 단계를 거칩니다.

1.  **업무 용어 사전 구축**: '고객', '주문', '상품'과 같은 핵심 용어를 명확히 정의합니다. 동의어 사용을 방지하고 일관된 언어체계를 만드는 것이 출발점입니다.
2.  **실제 산출물 분석**: 사용자 인터페이스의 입력 폼, 출력 보고서, 외부 시스템과의 인터페이스 문서 등을 검토하여 실제로 사용되고 있는 데이터 항목을 추출합니다.
3.  **후보 군집화**: 문서에서 발견된 명사는 엔티티 후보가 되고, 동사는 관계나 트랜잭션 엔티티(예: '주문한다', '결제하다')의 후보가 될 수 있습니다.
4.  **경계 설정과 응집도 고려**: 한 엔티티가 지나치게 많은 책임(속성)을 떠안고 있다면, 응집도를 높이기 위해 분할을 고려해야 합니다.
5.  **속성의 원자화**: 주소나 연락처와 같은 복합적이거나 다중 값을 가질 수 있는 데이터는 적절한 하위 엔티티로 분리합니다.
6.  **식별자 정의**: 각 엔티티를 유일하게 식별할 수 있는 자연키 또는 대리키 후보를 정의합니다.
7.  **업무 규칙 명시**: 데이터가 따라야 할 제약 조건(유일성, 기간 중복 금지, 상태 전이 규칙 등)을 문서화합니다.

이 과정의 결과물은 아래와 같은 개념적 다이어그램으로 표현될 수 있습니다.
```text
[고객]──(주문한다)──[주문]──(포함한다)──[주문항목]──(대상)──[상품]
   |                                  ^
   └──(보유)──[주소]                   |
          [결제]──(종류)──[카드결제/계좌이체]   [쿠폰]──(할당)──[고객-쿠폰]
```

---

## 엔티티의 다양한 분류 체계

엔티티는 그 특성에 따라 여러 관점에서 분류할 수 있으며, 이는 설계 결정에 중요한 기준이 됩니다.

*   **존재 방식**: 독립적으로 존재할 수 있는 **강엔티티**(고객, 상품)와 반드시 부모 엔티티에 종속되어 존재하는 **약엔티티**(주문항목)로 구분됩니다.
*   **시간적 특성**: 지속적으로 발생하는 **발생 엔티티**(주문, 로그), 참조용으로 사용되고 드물게 변경되는 **기준 엔티티**(부서, 국가코드), 그리고 일회성 기록을 위한 **단발 엔티티**가 있습니다.
*   **업무적 역할**: 비즈니스의 중심이 되는 **주 엔티티**(주문, 회원), 이를 보조하는 **보조 엔티티**(주소, 연락처), 그리고 순수한 관계를 넘어 추가 속성을 가지는 **관계(조인) 엔티티**(수강이력, 주문항목)로 나뉩니다.

---

## 식별자 설계: 자연키와 대리키의 선택

엔티티의 각 인스턴스를 유일하게 구분하는 주식별자(PK) 설계는 데이터 모델의 근간을 이룹니다. 자연키와 대리키는 각각 장단점이 있습니다.

*   **자연키**는 이메일, 주민등록번호처럼 업무적으로 의미 있는 값을 사용합니다. 직관적이며 불필요한 조인을 줄일 수 있지만, 변경 가능성이 있어 마이그레이션 부담과 개인정보 보호 문제가 발생할 수 있습니다.
*   **대리키**(서로게이트키)는 순차 숫자나 UUID처럼 시스템이 부여한 무의미한 값을 사용합니다. 변경되지 않아 안정적이며, 조인이 단순하고 보안 정책 적용이 용이합니다. 그러나 별도의 유니크 제약이 필요하고, 업무적 의미가 직접 드러나지 않습니다.

**실무 권장 패턴**은 두 가지의 장점을 결합하는 것입니다: **PK는 대리키로 설정하고, 동시에 업무적으로 유일해야 하는 속성(자연키 후보)에 UNIQUE 제약을 부여**합니다. 엄격한 규제가 적용되거나 외부 시스템과의 통합이 중요한 특정 도메인에서만 자연키를 PK로 사용하는 것을 고려합니다.

---

## 관계의 강도: 식별 관계와 비식별 관계

부모와 자식 엔티티 간의 결합도를 나타냅니다.

*   **식별 관계**: 부모 엔티티의 주식별자가 자식 엔티티의 주식별자의 일부가 되는 관계입니다. 이는 "자식의 존재가 부모 없이는 의미가 없다"는 매우 강한 종속성을 의미하며, 주로 약엔티티를 모델링할 때 사용됩니다.
*   **비식별 관계**: 부모의 주식별자가 자식의 일반 속성으로 포함됩니다(외래키). 자식 엔티티는 부모와 독립적인 자신의 주식별자를 가집니다. 이는 보다 유연한 구조를 제공하며, 변경과 마이그레이션에 유리합니다.

**약엔티티와 식별 관계의 SQL 예시**
```sql
-- 부모: 주문 (강엔티티)
CREATE TABLE "order" (
  order_id     BIGSERIAL PRIMARY KEY, -- 대리키 PK
  customer_id  BIGINT NOT NULL,
  ordered_at   timestamptz NOT NULL DEFAULT now(),
  status       text NOT NULL,
  FOREIGN KEY (customer_id) REFERENCES customer(customer_id)
);

-- 자식: 주문항목 (약엔티티, 식별 관계)
CREATE TABLE order_item (
  order_id   BIGINT NOT NULL, -- PK의 일부이자, "order"의 FK
  line_no    INT    NOT NULL, -- PK의 일부
  product_id BIGINT NOT NULL,
  qty        INT    NOT NULL CHECK (qty > 0),
  price_at   numeric(12,2) NOT NULL,
  PRIMARY KEY (order_id, line_no), -- 복합 PK (식별 관계)
  FOREIGN KEY (order_id) REFERENCES "order"(order_id) ON DELETE CASCADE,
  FOREIGN KEY (product_id) REFERENCES product(product_id)
);
```
위 예에서 `order_item`은 `order` 없이는 존재할 수 없으며, 그 관계는 `order_item`의 PK에 `order_id`가 포함됨으로써 식별 관계로 구현되었습니다.

---

## N:M 관계의 진화: 조인 엔티티

학생과 강의 간의 '수강' 관계처럼, 단순한 연결 이상의 의미(수강 시점, 성적, 상태)를 담아야 할 때가 있습니다. 이때는 연결 테이블을 넘어 **조인 엔티티**로 승격시켜 설계합니다.

```sql
CREATE TABLE enrollment ( -- 학생-강의 수강 조인 엔티티
  student_id  BIGINT NOT NULL,
  course_id   BIGINT NOT NULL,
  attempt_no  INT    NOT NULL DEFAULT 1, -- 재수강 횟수
  enroll_date date   NOT NULL, -- 수강 신청일
  status      text   NOT NULL CHECK (status IN ('ENROLLED','DROPPED','COMPLETED')),
  score       numeric(5,2), -- 성적
  PRIMARY KEY (student_id, course_id, attempt_no), -- 재수강 허용을 위한 복합 PK
  FOREIGN KEY (student_id) REFERENCES student(student_id),
  FOREIGN KEY (course_id)  REFERENCES course(course_id)
);
```
이 엔티티는 단순 매핑을 넘어, `enroll_date`, `status`, `score`라는 실질적인 행위와 상태에 대한 데이터를 관리합니다.

---

## 상속 구조 모델링: 슈퍼타입과 서브타입

결제 방식(카드, 계좌이체)처럼 공통 속성과 개별 속성이 공존하는 경우, 세 가지 주요 패턴으로 모델링할 수 있습니다.

1.  **단일 테이블**: 모든 속성을 하나의 테이블에 넣고, 타입을 구분하는 `discriminator` 컬럼을 둡니다. 간단하지만 NULL 컬럼이 많아질 수 있습니다.
2.  **클래스별 테이블(권장)**: 공통 속성은 슈퍼타입 테이블(`payment`)에, 개별 속성은 각 서브타입 테이블(`card_payment`, `bank_payment`)에 저장합니다. 정규화가 잘 되고 제약 조건 명시가 용이합니다.
3.  **구체 테이블만**: 공통 속성을 각 테이블에 중복 저장합니다. 다형성 쿼리가 복잡해집니다.

**클래스별 테이블 패턴 예시**
```sql
-- 슈퍼타입: 결제 공통 정보
CREATE TABLE payment (
  payment_id BIGSERIAL PRIMARY KEY,
  order_id   BIGINT NOT NULL UNIQUE REFERENCES "order"(order_id),
  amount     numeric(12,2) NOT NULL,
  paid_at    timestamptz NOT NULL,
  method     text NOT NULL CHECK (method IN ('CARD','BANK')) -- 구분자
);

-- 서브타입: 카드 결제 특수 정보
CREATE TABLE card_payment (
  payment_id  BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  card_no_hash text NOT NULL, -- 보안을 위해 해시값 저장
  auth_code    text NOT NULL
);

-- 서브타입: 계좌이체 특수 정보
CREATE TABLE bank_payment (
  payment_id BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  bank_code  text NOT NULL,
  account_no text NOT NULL
);
```

---

## 계층적 구조와 시간적 구조의 모델링

**계층적 구조**(카테고리, 조직도)는 주로 재귀적 관계(자기 참조 외래키)로 모델링하며, 복잡한 경로 질의를 위해 CTE(Common Table Expression)를 사용합니다.
```sql
WITH RECURSIVE category_path AS (
  SELECT category_id, name, parent_id, 1 AS depth
  FROM category WHERE category_id = 10 -- 시작 노드
  UNION ALL
  SELECT c.category_id, c.name, c.parent_id, p.depth + 1
  FROM category c
  INNER JOIN category_path p ON c.parent_id = p.category_id
)
SELECT * FROM category_path;
```

**시간적(템포럴) 구조**는 엔티티의 변경 이력을 관리할 때 필요합니다. 예를 들어, 직원의 부서 배치 이력을 추적하기 위해 `start_at`과 `end_at` 컬럼을 추가하고, 기간이 겹치지 않도록 제약을 설정합니다.
```sql
CREATE TABLE employee_dept (
  emp_id   BIGINT NOT NULL,
  dept_id  BIGINT NOT NULL,
  start_at date   NOT NULL,
  end_at   date, -- NULL이면 현재 유효
  PRIMARY KEY (emp_id, dept_id, start_at),
  CHECK (end_at IS NULL OR end_at > start_at), -- 기본 검사
  FOREIGN KEY (emp_id) REFERENCES employee(emp_id),
  FOREIGN KEY (dept_id) REFERENCES department(dept_id)
);
-- (고급) PostgreSQL의 Exclusion Constraint를 사용하면 기간 겹침을 완전히 방지할 수 있습니다.
```

---

## 엔티티 설계의 실무 원칙

*   **명확한 네이밍**: 테이블과 컬럼 이름은 단수형을 사용(`customer`, `order_item`)하고, 팀 내 일관된 표준을 따릅니다.
*   **단일 책임 원칙**: 한 엔티티는 하나의 명확한 책임을 가져야 합니다. 지나치게 비대해진 엔티티는 분해를 고려하세요.
*   **정규화 우선**: 데이터 중복과 이상 현상을 방지하기 위해 정규화를 기본으로 합니다. 성능 최적화를 위한 반정규화는 측정된 근거와 함께 신중하게 적용합니다.
*   **상태 값의 통제**: `status`와 같은 컬럼은 자유 텍스트가 아니라 ENUM 타입이나 별도의 코드 테이블을 참조하여 유효성을 보장해야 합니다.

---

## 성능을 고려한 물리적 설계

논리적 설계가 완료되면, 성능과 운영을 위해 물리적 구현을 고려합니다.

*   **인덱스 전략**: 모든 외래키 컬럼에는 인덱스를 생성하는 것이 좋습니다. 복합 인덱스는 WHERE 조건에 자주 사용되는 컬럼 순서로 구성합니다.
    ```sql
    CREATE INDEX idx_order_customer ON "order"(customer_id);
    CREATE INDEX idx_order_status_dt ON "order"(status, ordered_at DESC);
    ```
*   **파티셔닝**: 데이터량이 매우 클 경우, 파티셔닝을 고려합니다. 파티션 키는 `ordered_at`(날짜)이나 `customer_id`(해시)처럼 실제 쿼리 패턴과 맞아야 합니다.

---

## 마이그레이션: 엔티티 구조의 안전한 변경

기존 시스템의 엔티티 구조를 개선해야 할 때는 서비스 중단을 최소화하는 안전한 절차를 따라야 합니다.

**예시: 주문 테이블에서 상품 정보 분리하기**
초기 설계에서 `order` 테이블에 직접 `product_id`와 `price_at`이 포함되어 있었다면, 이를 정규화하여 `order_item` 테이블로 분리하는 과정은 다음과 같습니다.
1.  새로운 `order_item` 테이블을 생성합니다.
2.  기존 `order` 테이블의 데이터를 새로운 테이블로 이관(마이그레이션)하는 백필 스크립트를 실행합니다.
3.  애플리케이션 코드를 단계적으로 변경합니다. 먼저 새로운 테이블을 읽도록 하고, 그 다음 새로운 테이블에 쓰도록 합니다(이중 쓰기 가능).
4.  모든 트래픽이 새로운 구조로 전환되고 데이터 정합성이 확인되면, 기존 `order` 테이블의 불필요한 컬럼(`product_id`, `price_at`)을 제거합니다.
5.  전체 과정에 대한 롤백 계획을 반드시 문서화하고 준비합니다.

---

## 결론: 좋은 엔티티 설계란

엔티티 설계는 데이터 모델링의 핵심이며, 업무의 복잡성을 단순하고 명료한 데이터 구조로 치환하는 창의적인 과정입니다. 좋은 엔티티는 그 자체로 비즈니스의 중요한 개념을 명확히 정의하고, 안정적인 식별자를 통해 추적 가능하게 하며, 정규화를 통해 무결성을 보장합니다. 동시에 성능, 보안, 감사 추적과 같은 비기능적 요구사항까지 고려한 종합적인 설계의 결과물입니다.

이론적 원칙(정규화, 관계 이론)에 근거하되, 실무의 제약과 변화하는 요구사항에 유연하게 대응할 수 있는 실용적인 안목이 필요합니다. 엔티티 모델은 한 번 설계되고 잊혀지는 것이 아니라, 지속적인 테스트, 모니터링, 리팩토링을 통해 비즈니스와 함께 성장하는 살아있는 문서입니다. 개념적 설계부터 물리적 구현, 그리고 운영과 진화까지의 전체 라이프사이클을 통찰력 있게 관리할 때, 탄탄한 데이터 아키텍처의 기초를 마련할 수 있습니다.