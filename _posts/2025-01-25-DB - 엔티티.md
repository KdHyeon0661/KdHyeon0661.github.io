---
layout: post
title: DB - 엔티티
date: 2025-01-25 20:20:23 +0900
category: DB
---
# 엔티티(Entity)

## 0. 리마인드(핵심)

- **엔티티(Entity)**는 **관리해야 할 대상**을 데이터로 표현한 **논리 구조**이고, 물리적으로는 **테이블**로 구현된다.
- 좋은 엔티티는 **명확한 정의/경계**, **안정적인 식별자**, **의미 있는 속성 집합**, **관계 관리 능력**을 가진다.
- **강/약 엔티티**, **식별/비식별 관계**, **N:M 조인 엔티티**, **슈퍼/서브타입**, **재귀/템포럴** 등은 도메인 규칙에 따라 구사한다.

---

## 1. 수학적 정의로 보는 엔티티와 관계

엔티티 집합을 \(E\), 속성 공간의 곱을 \(\mathcal{A} = A_1 \times \cdots \times A_n\)라 하자.
엔티티는 다음과 같이 **식별자** \(K \subseteq \{1,\dots,n\}\)를 통해 유일 식별된다.

$$
\forall e_1, e_2 \in E:\ \big(\forall i \in K,\ e_1[i] = e_2[i]\big)\ \Rightarrow\ e_1 = e_2
$$

관계 \(R \subseteq E_1 \times E_2\)는 참여수(카디널리티)·옵셔널리티(최소참여)로 제약된다. N:M은 일반적으로 **조인 엔티티** \(J\)로 승격한다.

---

## 2. 엔티티 도출 절차(요구사항→개념)

1) **업무 용어 사전**: 용어의 정의/범위를 1문장으로 고정.
2) **입력·출력 채널 조사**: 화면/폼/보고서/배치에서 실사용 항목 수집.
3) **후보 군집화**: 명사→엔티티 후보, 동사→관계/행위 엔티티 후보.
4) **경계 설정**: 한 엔티티가 너무 많은 책임을 지면 분해(응집도↑).
5) **속성 최소 단위화**: 다중·복합 값 분리(전화, 주소 등).
6) **식별자 후보 정의**: 자연키/대리키 전략 비교.
7) **업무 제약 명문화**: 유일성, 기간중복 금지, 상태전이 허용 집합 등.

개념 ERD(문자 다이어그램):

```text
[고객]──(주문한다)──[주문]──(포함한다)──[주문항목]──(대상)──[상품]
   |                                  ^
   └──(보유)──[주소]                   |
          [결제]──(종류)──[카드결제/계좌이체]   [쿠폰]──(할당)──[고객-쿠폰]
```

---

## 3. 엔티티의 분류(확장)

### 3.1 존재 방식
- **강(Strong)**: 독립 존재 가능(고객, 상품).
- **약(Weak)**: 부모 없이는 존재 불가(주문항목: 주문의 존재에 종속). 일반적으로 **식별자 관계**로 구현(부모 PK가 자식 PK 포함).

### 3.2 시간적 특성
- **발생**: 지속 발생(주문, 트랜잭션).
- **기준(마스터/코드)**: 드물게 변경, 참조용(국가코드, 부서).
- **단발**: 일회성 기록(등록 서류 스냅샷).

### 3.3 업무 역할
- **주 엔티티**: 중심 도메인(사용자, 주문).
- **보조 엔티티**: 주소/연락처/이력 등.
- **관계(조인) 엔티티**: N:M 해소(학생-수업 수강), 행위/상태 속성 포함.

---

## 4. 식별자 전략(자연키 vs 서로게이트)

| 항목 | 자연키(업무키) | 서로게이트(대리키) |
|---|---|---|
| 의미 | 업무 상 의미 | 무의미(숫자/UUID) |
| 변경 | 변경 가능성 존재 | 불변 설계 용이 |
| 장점 | 직관/중복 방지 | 조인 단순, 마이그레이션·보안 유리 |
| 단점 | 변경·마스킹 부담 | 별도 UNIQUE 필요 |

실무 권장: **PK=대리키 + 자연키 UNIQUE**. 규제/통합 도메인에서만 자연키 PK 고려.

---

## 5. 식별/비식별 관계와 약 엔티티

- **식별자 관계(Identifying)**: 부모 PK가 자식 PK에 포함, 강 결합. 약 엔티티 모델링에 적합.
- **비식별자 관계(Non-identifying)**: 자식 PK 독립, 부모 PK는 단순 FK. 유연한 확장과 마이그레이션에 유리.

SQL 예시:

```sql
-- 부모: 주문
CREATE TABLE "order" (
  order_id     BIGSERIAL PRIMARY KEY,
  customer_id  BIGINT NOT NULL,
  ordered_at   timestamptz NOT NULL DEFAULT now(),
  status       text NOT NULL CHECK (status IN ('PENDING','PAID','CANCELLED')),
  FOREIGN KEY (customer_id) REFERENCES customer(customer_id)
);

-- 약 엔티티(식별자 관계): 주문항목 PK=(order_id, line_no)
CREATE TABLE order_item (
  order_id   BIGINT NOT NULL,
  line_no    INT    NOT NULL,
  product_id BIGINT NOT NULL,
  qty        INT    NOT NULL CHECK (qty > 0),
  price_at   numeric(12,2) NOT NULL CHECK (price_at >= 0),
  PRIMARY KEY (order_id, line_no),
  FOREIGN KEY (order_id) REFERENCES "order"(order_id) ON DELETE CASCADE,
  FOREIGN KEY (product_id) REFERENCES product(product_id) ON DELETE RESTRICT
);
```

---

## 6. N:M 관계의 엔티티화(조인 엔티티)

단순 연결을 넘어 **행위/상태** 속성을 담는 **실질 엔티티**로 설계한다.

```sql
CREATE TABLE enrollment (   -- 학생-강의 수강
  student_id  BIGINT NOT NULL,
  course_id   BIGINT NOT NULL,
  attempt_no  INT    NOT NULL DEFAULT 1,
  enroll_date date   NOT NULL,
  status      text   NOT NULL CHECK (status IN ('ENROLLED','DROPPED','COMPLETED')),
  score       numeric(5,2),
  PRIMARY KEY (student_id, course_id, attempt_no),
  FOREIGN KEY (student_id) REFERENCES student(student_id),
  FOREIGN KEY (course_id)  REFERENCES course(course_id)
);
CREATE INDEX idx_enroll_course ON enrollment(course_id);
```

- **중복 금지**: `(student_id, course_id, attempt_no)`로 유니크.
- 재수강 허용 시 `attempt_no` 증가.

---

## 7. 슈퍼타입/서브타입(상속) 엔티티

요구: 결제는 공통 속성(금액, 시각)이 있고, 방법별 상이 속성(카드번호 해시/계좌)이 있다.

패턴 비교
- 단일 테이블(Discriminator)
- 클래스별 테이블(공통키 공유) ← 정규화/제약 명시 유리
- 구체 테이블만(공통 없음)

클래스별 테이블 예:

```sql
CREATE TABLE payment (
  payment_id BIGSERIAL PRIMARY KEY,
  order_id   BIGINT NOT NULL UNIQUE REFERENCES "order"(order_id),
  amount     numeric(12,2) NOT NULL,
  paid_at    timestamptz NOT NULL,
  method     text NOT NULL CHECK (method IN ('CARD','BANK'))
);

CREATE TABLE card_payment (
  payment_id  BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  card_no_hash text NOT NULL,
  auth_code    text NOT NULL
);

CREATE TABLE bank_payment (
  payment_id BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  bank_code  text NOT NULL,
  account_no text NOT NULL
);
```

---

## 8. 재귀(자기) 엔티티와 계층

카테고리, 조직, 댓글 등 트리/그래프 구조.

```sql
CREATE TABLE category (
  category_id BIGSERIAL PRIMARY KEY,
  name        text NOT NULL,
  parent_id   BIGINT NULL REFERENCES category(category_id) ON DELETE SET NULL
);

-- 경로 탐색(CTE)
WITH RECURSIVE path AS (
  SELECT category_id, name, parent_id, 1 AS depth
  FROM category WHERE category_id = $1
  UNION ALL
  SELECT c.category_id, c.name, c.parent_id, p.depth+1
  FROM category c JOIN path p ON c.parent_id = p.category_id
)
SELECT * FROM path;
```

대안: 경로 열 저장, 중첩 집합 모델, 클로저 테이블(쿼리 패턴에 맞춰 선택).

---

## 9. 템포럴 엔티티(기간·이력)

엔티티의 **유효기간 속성**을 포함하거나, **버전드 테이블**로 이력 관리.

기간 겹침 금지 원리:
$$
[s_1,e_1) \cap [s_2,e_2) = \emptyset \iff e_1 \le s_2 \ \lor\ e_2 \le s_1
$$

```sql
CREATE TABLE employee_dept (
  emp_id   BIGINT NOT NULL,
  dept_id  BIGINT NOT NULL,
  start_at date   NOT NULL,
  end_at   date,
  PRIMARY KEY (emp_id, dept_id, start_at),
  CHECK (end_at IS NULL OR end_at > start_at),
  FOREIGN KEY (emp_id) REFERENCES employee(emp_id),
  FOREIGN KEY (dept_id) REFERENCES department(dept_id)
);

/* 엔진 지원 시 Exclusion Constraint로 기간 겹침 차단 */
```

---

## 10. 기준(코드) 엔티티

값의 유효 집합을 테이블로 관리(다국어/라벨/정렬순서/활성여부 포함).

```sql
CREATE TABLE country_code (
  code char(2) PRIMARY KEY,   -- ISO 3166-1 alpha-2
  name text NOT NULL,
  active boolean NOT NULL DEFAULT TRUE
);

CREATE TABLE order_status_code (
  code text PRIMARY KEY,      -- 'PENDING','PAID','CANCELLED',...
  label text NOT NULL,
  sort_order int NOT NULL
);

ALTER TABLE "order"
  ADD CONSTRAINT fk_status FOREIGN KEY (status) REFERENCES order_status_code(code);
```

---

## 11. 엔티티 네이밍/경계/정규화 원칙

- 단수형, 약어 최소화, 팀 표준 준수(`customer`, `order_item`).
- **하나의 엔티티=하나의 책임**(SRP). 반정규화는 **핫 경로**에서만 이유를 문서화.
- 다중/복합 속성은 분리(전화/주소).
- 상태 열은 코드 테이블 또는 엄격한 체크로 통제.

---

## 12. 성능·인덱스·파티셔닝과 엔티티

- 모든 **FK에 인덱스** 부여(삭제/갱신/조인).
- 복합 인덱스는 “선 필터 → 정렬/그룹” 순서.
- 파티션 키는 실제 필터 컬럼(날짜/고객ID 등)과 일치.

```sql
CREATE INDEX idx_order_customer ON "order"(customer_id);
CREATE INDEX idx_item_order    ON order_item(order_id);
CREATE INDEX idx_order_status_dt ON "order"(status, ordered_at DESC);
```

---

## 13. 종합 예시: 커머스 핵심 엔티티

### 13.1 스키마 요약

```sql
-- 고객
CREATE TABLE customer (
  customer_id  BIGSERIAL PRIMARY KEY,
  email        text NOT NULL UNIQUE,
  name         text NOT NULL,
  created_at   timestamptz NOT NULL DEFAULT now()
);

-- 주소(보조 엔티티, 1:N)
CREATE TABLE customer_address (
  address_id   BIGSERIAL PRIMARY KEY,
  customer_id  BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE CASCADE,
  country_code char(2) NOT NULL REFERENCES country_code(code),
  postal_code  text NOT NULL,
  city         text NOT NULL,
  line1        text NOT NULL,
  line2        text,
  is_default   boolean NOT NULL DEFAULT FALSE
);
CREATE UNIQUE INDEX uq_addr_default ON customer_address(customer_id) WHERE is_default;

-- 상품(주 엔티티)
CREATE TABLE product (
  product_id BIGSERIAL PRIMARY KEY,
  sku        text NOT NULL UNIQUE,
  name       text NOT NULL,
  price      numeric(12,2) NOT NULL CHECK (price >= 0),
  created_at timestamptz NOT NULL DEFAULT now()
);

-- 주문(주 엔티티)
CREATE TABLE "order" (
  order_id     BIGSERIAL PRIMARY KEY,
  order_no     text NOT NULL UNIQUE,
  customer_id  BIGINT NOT NULL REFERENCES customer(customer_id) ON DELETE RESTRICT,
  ordered_at   timestamptz NOT NULL DEFAULT now(),
  status       text NOT NULL
    CHECK (status IN ('PENDING','PAID','CANCELLED','SHIPPED','COMPLETED')),
  shipping_addr_id BIGINT REFERENCES customer_address(address_id) ON DELETE SET NULL
);

-- 주문항목(약 엔티티, 식별자 관계)
CREATE TABLE order_item (
  order_id   BIGINT NOT NULL,
  line_no    INT    NOT NULL,
  product_id BIGINT NOT NULL REFERENCES product(product_id) ON DELETE RESTRICT,
  qty        INT    NOT NULL CHECK (qty > 0),
  price_at   numeric(12,2) NOT NULL CHECK (price_at >= 0),
  PRIMARY KEY (order_id, line_no),
  FOREIGN KEY (order_id) REFERENCES "order"(order_id) ON DELETE CASCADE
);

-- 결제(슈퍼/서브타입)
CREATE TABLE payment (
  payment_id BIGSERIAL PRIMARY KEY,
  order_id   BIGINT NOT NULL UNIQUE REFERENCES "order"(order_id) ON DELETE CASCADE,
  amount     numeric(12,2) NOT NULL,
  paid_at    timestamptz NOT NULL,
  method     text NOT NULL CHECK (method IN ('CARD','BANK'))
);
CREATE TABLE card_payment (
  payment_id BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  card_no_hash text NOT NULL,
  auth_code    text NOT NULL
);
CREATE TABLE bank_payment (
  payment_id BIGINT PRIMARY KEY REFERENCES payment(payment_id) ON DELETE CASCADE,
  bank_code  text NOT NULL,
  account_no text NOT NULL
);
```

### 13.2 시나리오 쿼리

```sql
-- 고객 1의 최근 주문과 합계
SELECT o.order_no, o.ordered_at, SUM(oi.qty * oi.price_at) AS total
FROM "order" o
JOIN order_item oi ON oi.order_id = o.order_id
WHERE o.customer_id = 1
GROUP BY o.order_id
ORDER BY o.ordered_at DESC
LIMIT 10;

-- 특정 카테고리 트리의 모든 상품(재귀 + 조인 엔티티 전제 시)
-- (category, product_category 엔티티가 있다고 가정)
WITH RECURSIVE sub AS (
  SELECT category_id FROM category WHERE category_id = 10
  UNION ALL
  SELECT c.category_id
  FROM category c JOIN sub s ON c.parent_id = s.category_id
)
SELECT p.product_id, p.name
FROM product p
JOIN product_category pc ON pc.product_id = p.product_id
WHERE pc.category_id IN (SELECT category_id FROM sub);

-- 상태 코드 테이블 기반 조회
SELECT o.order_no, s.label AS status_label
FROM "order" o
JOIN order_status_code s ON s.code = o.status
WHERE o.ordered_at::date = current_date;
```

---

## 14. 엔티티 설계 안티패턴 → 개선

| 안티패턴 | 문제 | 개선 |
|---|---|---|
| 하나의 엔티티에 모든 것 | 낮은 응집, 변경폭 과대 | 경계 재설계, 보조 엔티티 분리 |
| 중복 엔티티(동의어) | 데이터 이력 분산·혼란 | 용어 사전 정리, 마이그레이션 통합 |
| 다중/복합 속성 보관 | 질의/인덱스 불리 | 전화/주소 분리, 원자화 |
| 상태 자유 텍스트 | 오타/불일치 | 코드 테이블/ENUM + CHECK |
| 자연키 PK로 빈번 변경 | PK 변경 비용·락 | PK 대리키 + 자연키 UNIQUE |

---

## 15. 품질·무결성 테스트(엔티티 관점)

```sql
-- 고아 주문: 고객 없는 주문 존재?
SELECT o.order_id
FROM "order" o
LEFT JOIN customer c ON c.customer_id = o.customer_id
WHERE c.customer_id IS NULL;

-- 주문항목 중복 line_no 검사
SELECT order_id, line_no, COUNT(*) AS cnt
FROM order_item
GROUP BY order_id, line_no
HAVING COUNT(*) > 1;

-- 상태값 유효성 검사(코드 테이블 대비)
SELECT o.order_id, o.status
FROM "order" o
LEFT JOIN order_status_code s ON s.code = o.status
WHERE s.code IS NULL;
```

운영 체크리스트
- 모든 FK에 인덱스 존재 확인.
- 통계 갱신/실행계획 회귀 감시.
- 대량 삭제/수정 시 청크 처리 + 트랜잭션 경량화.

---

## 16. 엔티티 마이그레이션(변경 안전 절차)

예: 초기 설계에서 `order.product_id`(1:1/1:N 혼합 오류)를 **정규화**하여 `order_item`으로 분해.

```sql
-- 1) 새 엔티티 생성
CREATE TABLE order_item_new (
  order_id   BIGINT NOT NULL REFERENCES "order"(order_id) ON DELETE CASCADE,
  line_no    INT    NOT NULL,
  product_id BIGINT NOT NULL REFERENCES product(product_id),
  qty        INT    NOT NULL DEFAULT 1,
  price_at   numeric(12,2) NOT NULL,
  PRIMARY KEY (order_id, line_no)
);

-- 2) 데이터 백필(임시 line_no=1)
INSERT INTO order_item_new(order_id, line_no, product_id, qty, price_at)
SELECT order_id, 1, product_id, 1, price_at
FROM "order"
WHERE product_id IS NOT NULL;

-- 3) 애플리케이션 읽기→쓰기 전환 후, 구 컬럼 제거
ALTER TABLE "order" DROP COLUMN product_id;
ALTER TABLE "order" DROP COLUMN price_at;
ALTER TABLE order_item RENAME TO order_item_old;
ALTER TABLE order_item_new RENAME TO order_item;
```

롤백 경로 문서화(스냅샷/백업, 역이관 SQL).

---

## 17. ORM/폴리모픽·집계 엔티티

- 1:N → `ManyToOne(엔티티=N쪽 FK)` / `OneToMany`
- N:M → **조인 엔티티** 클래스로 명시(추가 속성 포함).
- 지연로딩 기본, 조회 전용 API(페치 조인/프로젝션) 별도 설계.
- 폴리모픽(한 FK가 여러 엔티티를 가리킴)은 DB 제약 약화 → 슈퍼타입/조인 엔티티로 정규화 권장.

---

## 18. 분석계(SCD)에서의 엔티티 스냅샷

운영 엔티티(OLTP) ↔ 분석 엔티티(OLAP) 분리. 차원 변경 이력(SCD Type 2)로 시점 조회.

```sql
CREATE TABLE dim_customer (
  sk_customer    BIGSERIAL PRIMARY KEY,
  customer_id    BIGINT NOT NULL,
  name           text NOT NULL,
  email          text NOT NULL,
  effective_from date NOT NULL,
  effective_to   date,
  is_current     boolean NOT NULL,
  UNIQUE(customer_id, effective_from)
);
```

---

## 19. 엔티티 검증 체크리스트

- 정의가 한 문장으로 명확히 기술되는가(경계 포함)?
- 독립적으로 존재 가능한가(약 엔티티는 부모 필수)?
- 안정적 식별자를 갖는가(자연키·대리키 전략 문서화)?
- 핵심 속성 3개 이상이 의미 있게 존재하는가?
- 관계의 최소/최대 참여수·옵셔널리티가 명문화되었는가?
- 코드/기준 엔티티로 유효값이 관리되는가?
- 템포럴/이력·감사 요구를 충족하는가?
- 성능(인덱스/파티션)과 운영(아카이빙/삭제정책) 계획이 있는가?

---

## 20. 결론

엔티티는 **업무 의미를 담는 가장 큰 설계 단위**다.
좋은 엔티티는 **명확한 정의와 경계, 안정적 식별자, 정규화된 속성, 올바른 관계**를 갖추며, **성능·운영·보안·이력** 요구까지 포괄한다.
개념→논리→물리 흐름을 일관되게 밟고, 테스트/마이그레이션을 통한 **지속 개선**으로 모델의 수명을 늘려라.
