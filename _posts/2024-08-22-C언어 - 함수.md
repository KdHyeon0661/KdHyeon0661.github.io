---
layout: post
title: C - 함수
date: 2024-08-22 19:20:23 +0900
category: C
---
# 함수: C 언어의 모듈화와 추상화의 핵심

## 함수 이해하기: 코드의 재사용과 구조화

함수는 C 프로그래밍의 핵심 구성 요소입니다. 특정 작업을 수행하는 코드 블록을 묶어 이름을 붙인 것으로, 프로그램을 논리적인 단위로 분할하고 재사용성을 높여줍니다.

### 왜 함수를 사용할까요?

1. **코드 재사용**: 같은 기능을 여러 번 구현하지 않고 함수를 호출하면 됩니다
2. **가독성 향상**: 잘 지어진 함수 이름은 코드의 의도를 명확히 합니다
3. **유지보수 용이**: 기능을 수정할 때 한 곳만 수정하면 됩니다
4. **디버깅 편리**: 문제가 있는 함수만 집중적으로 테스트할 수 있습니다
5. **모듈화**: 큰 프로그램을 작은 단위로 나누어 개발할 수 있습니다

## 기본 개념: 선언, 정의, 호출

먼저 함수의 기본적인 구성 요소를 간단한 예제로 살펴보겠습니다:

```c
#include <stdio.h>

/* 1. 함수 선언 (원형) - 컴파일러에게 함수의 존재를 알림 */
int add(int a, int b);

/* 2. 함수 정의 - 실제 구현 */
int add(int a, int b) {
    return a + b;
}

/* 3. 함수 호출 - 실제 사용 */
int main(void) {
    int result = add(3, 4);  // 함수 호출
    printf("결과: %d\n", result);
    return 0;
}
```

### 함수의 구성 요소

```c
반환형 함수이름(매개변수 목록) {
    // 함수 본문
    return 반환값;
}
```

- **반환형**: 함수가 반환하는 값의 자료형 (없으면 `void`)
- **함수이름**: 함수를 식별하는 이름
- **매개변수**: 함수에 전달되는 입력값들
- **본문**: 함수가 수행하는 작업
- **return**: 결과를 반환하고 함수 종료

## 함수 선언과 정의 분리하기

### 헤더 파일과 소스 파일 분리

실제 프로젝트에서는 함수 선언과 정의를 분리하는 것이 일반적입니다:

**math_operations.h** (헤더 파일 - 선언)
```c
#ifndef MATH_OPERATIONS_H
#define MATH_OPERATIONS_H

// 함수 선언들
int add(int a, int b);
int subtract(int a, int b);
int multiply(int a, int b);
double divide(int a, int b);

#endif
```

**math_operations.c** (소스 파일 - 정의)
```c
#include "math_operations.h"

// 함수 정의들
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

double divide(int a, int b) {
    if (b == 0) {
        // 0으로 나누기 방지
        return 0.0;
    }
    return (double)a / b;
}
```

**main.c** (메인 프로그램)
```c
#include <stdio.h>
#include "math_operations.h"

int main(void) {
    printf("3 + 4 = %d\n", add(3, 4));
    printf("10 / 3 = %.2f\n", divide(10, 3));
    return 0;
}
```

### 컴파일과 링킹

여러 파일로 구성된 프로그램을 컴파일할 때는:

```bash
# 각 소스 파일을 오브젝트 파일로 컴파일
gcc -c math_operations.c -o math_operations.o
gcc -c main.c -o main.o

# 오브젝트 파일들을 링크하여 실행 파일 생성
gcc math_operations.o main.o -o calculator

# 또는 한 번에
gcc math_operations.c main.c -o calculator
```

## 매개변수 전달 방식

### 값에 의한 전달 (Call by Value)

C 언어에서 기본적인 매개변수 전달 방식은 **값에 의한 전달**입니다. 이는 함수에 인자의 복사본이 전달된다는 의미입니다:

```c
#include <stdio.h>

// 값에 의한 전달 예제
void modify_value(int x) {
    x = 100;  // 지역 변수 x만 변경됨
    printf("함수 내부: x = %d\n", x);
}

int main(void) {
    int number = 50;
    printf("함수 호출 전: number = %d\n", number);
    
    modify_value(number);  // number의 값(50)이 복사되어 전달됨
    
    printf("함수 호출 후: number = %d\n", number);  // 여전히 50
    return 0;
}
```

### 참조에 의한 전달 (포인터 사용)

원본 값을 수정하려면 포인터를 사용해야 합니다:

```c
#include <stdio.h>

// 포인터를 통한 참조 전달
void modify_original(int *x) {
    if (x != NULL) {  // NULL 포인터 체크
        *x = 100;  // 원본 값 변경
    }
}

int main(void) {
    int number = 50;
    printf("변경 전: number = %d\n", number);
    
    modify_original(&number);  // 주소 전달
    
    printf("변경 후: number = %d\n", number);  // 100으로 변경됨
    return 0;
}
```

### 배열 전달하기

배열을 함수에 전달할 때는 배열의 첫 번째 요소의 주소가 전달됩니다:

```c
#include <stdio.h>

// 배열과 크기를 함께 전달
double calculate_average(int array[], int size) {
    if (size <= 0) {
        return 0.0;
    }
    
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += array[i];
    }
    
    return (double)sum / size;
}

// const를 사용하여 배열이 수정되지 않음을 명시
void print_array(const int array[], int size) {
    printf("배열: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");
}

int main(void) {
    int scores[] = {85, 90, 78, 92, 88};
    int size = sizeof(scores) / sizeof(scores[0]);
    
    print_array(scores, size);
    
    double average = calculate_average(scores, size);
    printf("평균: %.2f\n", average);
    
    return 0;
}
```

## 함수의 다양한 활용

### 여러 값을 반환하는 함수

C 언어에서 함수는 공식적으로 하나의 값만 반환할 수 있지만, 여러 가지 방법으로 이 제한을 극복할 수 있습니다:

```c
#include <stdio.h>

// 방법 1: 구조체 사용 (가장 깔끔한 방법)
typedef struct {
    int min;
    int max;
    double average;
} Statistics;

Statistics calculate_statistics(int array[], int size) {
    Statistics stats;
    
    if (size <= 0) {
        stats.min = stats.max = 0;
        stats.average = 0.0;
        return stats;
    }
    
    stats.min = stats.max = array[0];
    int sum = array[0];
    
    for (int i = 1; i < size; i++) {
        if (array[i] < stats.min) stats.min = array[i];
        if (array[i] > stats.max) stats.max = array[i];
        sum += array[i];
    }
    
    stats.average = (double)sum / size;
    return stats;
}

// 방법 2: 포인터를 통한 출력 매개변수
void get_min_max(int array[], int size, int *min, int *max) {
    if (size <= 0 || min == NULL || max == NULL) {
        return;
    }
    
    *min = *max = array[0];
    
    for (int i = 1; i < size; i++) {
        if (array[i] < *min) *min = array[i];
        if (array[i] > *max) *max = array[i];
    }
}

int main(void) {
    int data[] = {23, 45, 12, 67, 34, 89, 56};
    int size = sizeof(data) / sizeof(data[0]);
    
    // 방법 1 사용
    Statistics stats = calculate_statistics(data, size);
    printf("최소: %d, 최대: %d, 평균: %.2f\n", 
           stats.min, stats.max, stats.average);
    
    // 방법 2 사용
    int min, max;
    get_min_max(data, size, &min, &max);
    printf("최소: %d, 최대: %d\n", min, max);
    
    return 0;
}
```

### 재귀 함수

함수가 자기 자신을 호출하는 것을 재귀라고 합니다:

```c
#include <stdio.h>

// 재귀 함수 예제: 팩토리얼 계산
unsigned long long factorial(int n) {
    // 기본 조건 (base case) - 재귀 종료
    if (n <= 1) {
        return 1;
    }
    // 재귀 호출
    return n * factorial(n - 1);
}

// 재귀 함수 예제: 피보나치 수열
int fibonacci(int n) {
    if (n <= 0) return 0;
    if (n == 1) return 1;
    
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// 반복문으로 구현한 팩토리얼 (재귀보다 효율적)
unsigned long long factorial_iterative(int n) {
    unsigned long long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

int main(void) {
    int num = 10;
    
    printf("%d! = %llu (재귀)\n", num, factorial(num));
    printf("%d! = %llu (반복)\n", num, factorial_iterative(num));
    
    printf("피보나치 %d번째 수: %d\n", num, fibonacci(num));
    
    return 0;
}
```

## 고급 함수 개념

### 함수 포인터

함수 포인터는 함수를 가리키는 포인터로, 콜백 함수나 전략 패턴 구현에 사용됩니다:

```c
#include <stdio.h>
#include <stdlib.h>

// 비교 함수 타입 정의
typedef int (*CompareFunction)(const void*, const void*);

// 오름차순 비교 함수
int compare_ascending(const void* a, const void* b) {
    int num1 = *(const int*)a;
    int num2 = *(const int*)b;
    
    if (num1 < num2) return -1;
    if (num1 > num2) return 1;
    return 0;
}

// 내림차순 비교 함수
int compare_descending(const void* a, const void* b) {
    int num1 = *(const int*)a;
    int num2 = *(const int*)b;
    
    if (num1 > num2) return -1;
    if (num1 < num2) return 1;
    return 0;
}

// 정렬 함수 (함수 포인터를 매개변수로 받음)
void sort_array(int array[], int size, CompareFunction compare) {
    qsort(array, size, sizeof(int), compare);
}

// 함수 포인터 배열을 사용한 디스패치 테이블
typedef void (*Operation)(int, int);

void add(int a, int b) { printf("%d + %d = %d\n", a, b, a + b); }
void subtract(int a, int b) { printf("%d - %d = %d\n", a, b, a - b); }
void multiply(int a, int b) { printf("%d × %d = %d\n", a, b, a * b); }
void divide(int a, int b) { 
    if (b != 0) {
        printf("%d ÷ %d = %.2f\n", a, b, (double)a / b);
    } else {
        printf("0으로 나눌 수 없습니다.\n");
    }
}

int main(void) {
    // 1. 함수 포인터 변수 선언 및 사용
    int numbers[] = {5, 2, 8, 1, 9, 3};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    
    printf("원본 배열: ");
    for (int i = 0; i < size; i++) printf("%d ", numbers[i]);
    printf("\n");
    
    // 오름차순 정렬
    sort_array(numbers, size, compare_ascending);
    printf("오름차순: ");
    for (int i = 0; i < size; i++) printf("%d ", numbers[i]);
    printf("\n");
    
    // 내림차순 정렬
    sort_array(numbers, size, compare_descending);
    printf("내림차순: ");
    for (int i = 0; i < size; i++) printf("%d ", numbers[i]);
    printf("\n");
    
    // 2. 함수 포인터 배열
    Operation operations[] = {add, subtract, multiply, divide};
    char* operation_names[] = {"덧셈", "뺄셈", "곱셈", "나눗셈"};
    
    int a = 10, b = 3;
    
    for (int i = 0; i < 4; i++) {
        printf("%s: ", operation_names[i]);
        operations[i](a, b);
    }
    
    return 0;
}
```

### 가변 인자 함수

고정되지 않은 수의 인자를 받는 함수를 만들 수 있습니다:

```c
#include <stdio.h>
#include <stdarg.h>

// 가변 인자 함수: 여러 정수의 합 계산
int sum(int count, ...) {
    int total = 0;
    
    // 가변 인자 목록 초기화
    va_list args;
    va_start(args, count);
    
    // 각 인자 처리
    for (int i = 0; i < count; i++) {
        total += va_arg(args, int);
    }
    
    // 가변 인자 목록 정리
    va_end(args);
    
    return total;
}

// 가변 인자 함수: 평균 계산 (여러 자료형 지원)
double average(int count, ...) {
    double total = 0.0;
    
    va_list args;
    va_start(args, count);
    
    for (int i = 0; i < count; i++) {
        // double로 읽기 (float는 자동으로 double로 확장됨)
        total += va_arg(args, double);
    }
    
    va_end(args);
    
    return count > 0 ? total / count : 0.0;
}

// 사용자 정의 출력 함수 (printf와 유사)
void my_printf(const char* format, ...) {
    va_list args;
    va_start(args, format);
    
    // 형식 문자열 분석 및 출력 (간단한 버전)
    while (*format) {
        if (*format == '%') {
            format++;  // % 다음 문자로 이동
            
            switch (*format) {
                case 'd': {
                    int value = va_arg(args, int);
                    printf("%d", value);
                    break;
                }
                case 'f': {
                    double value = va_arg(args, double);
                    printf("%.2f", value);
                    break;
                }
                case 's': {
                    char* value = va_arg(args, char*);
                    printf("%s", value);
                    break;
                }
                case '%': {
                    printf("%%");
                    break;
                }
                default: {
                    printf("%%%c", *format);
                    break;
                }
            }
        } else {
            putchar(*format);
        }
        
        format++;
    }
    
    va_end(args);
}

int main(void) {
    // 1. sum 함수 사용
    printf("합계 1: %d\n", sum(3, 10, 20, 30));
    printf("합계 2: %d\n", sum(5, 1, 2, 3, 4, 5));
    
    // 2. average 함수 사용
    printf("평균 1: %.2f\n", average(3, 10.0, 20.0, 30.0));
    printf("평균 2: %.2f\n", average(4, 85.5, 92.0, 78.5, 88.0));
    
    // 3. 사용자 정의 printf 사용
    my_printf("이름: %s, 나이: %d, 평균 점수: %f\n", 
              "홍길동", 25, 85.5);
    
    return 0;
}
```

## 실전 예제: 계산기 프로그램

여러 함수를 활용한 완전한 계산기 프로그램을 만들어 보겠습니다:

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// 연산 함수들
double add(double a, double b) { return a + b; }
double subtract(double a, double b) { return a - b; }
double multiply(double a, double b) { return a * b; }
double divide(double a, double b) {
    if (b == 0.0) {
        printf("오류: 0으로 나눌 수 없습니다.\n");
        return 0.0;
    }
    return a / b;
}
double power(double a, double b) { return pow(a, b); }
double square_root(double a) {
    if (a < 0.0) {
        printf("오류: 음수의 제곱근을 계산할 수 없습니다.\n");
        return 0.0;
    }
    return sqrt(a);
}

// 함수 포인터 타입 정의
typedef double (*BinaryOperation)(double, double);
typedef double (*UnaryOperation)(double);

// 메뉴 표시
void display_menu(void) {
    printf("\n=== 계산기 메뉴 ===\n");
    printf("1. 덧셈 (+)\n");
    printf("2. 뺄셈 (-)\n");
    printf("3. 곱셈 (*)\n");
    printf("4. 나눗셈 (/)\n");
    printf("5. 거듭제곱 (^)\n");
    printf("6. 제곱근 (√)\n");
    printf("0. 종료\n");
    printf("===================\n");
}

// 입력 검증 함수
int get_valid_integer(const char* prompt, int min, int max) {
    int value;
    char buffer[100];
    
    while (1) {
        printf("%s", prompt);
        
        if (fgets(buffer, sizeof(buffer), stdin) == NULL) {
            printf("입력 오류가 발생했습니다.\n");
            continue;
        }
        
        if (sscanf(buffer, "%d", &value) != 1) {
            printf("숫자를 입력해주세요.\n");
            continue;
        }
        
        if (value < min || value > max) {
            printf("%d에서 %d 사이의 값을 입력해주세요.\n", min, max);
            continue;
        }
        
        return value;
    }
}

// 실수 입력 함수
double get_double(const char* prompt) {
    double value;
    char buffer[100];
    
    while (1) {
        printf("%s", prompt);
        
        if (fgets(buffer, sizeof(buffer), stdin) == NULL) {
            printf("입력 오류가 발생했습니다.\n");
            continue;
        }
        
        if (sscanf(buffer, "%lf", &value) != 1) {
            printf("실수를 입력해주세요.\n");
            continue;
        }
        
        return value;
    }
}

int main(void) {
    // 함수 포인터 배열
    BinaryOperation binary_ops[] = {add, subtract, multiply, divide, power};
    char* binary_op_names[] = {"덧셈", "뺄셈", "곱셈", "나눗셈", "거듭제곱"};
    char* binary_op_symbols[] = {"+", "-", "×", "÷", "^"};
    
    UnaryOperation unary_ops[] = {square_root};
    char* unary_op_names[] = {"제곱근"};
    char* unary_op_symbols[] = {"√"};
    
    printf("간단한 계산기 프로그램\n");
    
    while (1) {
        display_menu();
        int choice = get_valid_integer("선택: ", 0, 6);
        
        if (choice == 0) {
            printf("프로그램을 종료합니다.\n");
            break;
        }
        
        if (choice >= 1 && choice <= 5) {
            // 이항 연산
            double a = get_double("첫 번째 숫자: ");
            double b = get_double("두 번째 숫자: ");
            
            double result = binary_ops[choice - 1](a, b);
            printf("%s: %.2f %s %.2f = %.2f\n", 
                   binary_op_names[choice - 1], a, binary_op_symbols[choice - 1], b, result);
            
        } else if (choice == 6) {
            // 단항 연산
            double a = get_double("숫자: ");
            
            double result = unary_ops[0](a);
            printf("%s: %s%.2f = %.2f\n", 
                   unary_op_names[0], unary_op_symbols[0], a, result);
            
        } else {
            printf("잘못된 선택입니다.\n");
        }
    }
    
    return 0;
}
```

## 모범 사례와 주의사항

### 1. 함수 길이 제한

함수는 가능한 한 짧고 한 가지 일만 하도록 작성하세요:

```c
// 좋은 예: 한 가지 기능에 집중
double calculate_circle_area(double radius) {
    return 3.141592653589793 * radius * radius;
}

// 나쁜 예: 너무 많은 일을 함
double process_circle(double radius) {
    // 면적 계산
    double area = 3.141592653589793 * radius * radius;
    
    // 둘레 계산
    double circumference = 2 * 3.141592653589793 * radius;
    
    // 파일에 저장
    FILE* file = fopen("result.txt", "w");
    if (file) {
        fprintf(file, "반지름: %.2f\n", radius);
        fprintf(file, "면적: %.2f\n", area);
        fprintf(file, "둘레: %.2f\n", circumference);
        fclose(file);
    }
    
    return area;  // 왜 면적만 반환하는가?
}
```

### 2. 의미 있는 함수 이름

함수 이름은 그 기능을 명확히 설명해야 합니다:

```c
// 좋은 예: 기능이 명확함
double calculate_monthly_payment(double principal, double annual_rate, int years);
void save_user_profile(const User* user);
int validate_email_format(const char* email);

// 나쁜 예: 기능이 불분명함
double do_calc(double a, double b, int c);  // 무엇을 계산하는가?
void process_data(Data* d);                  // 어떻게 처리하는가?
int check_input(char* s);                    // 무엇을 확인하는가?
```

### 3. 에러 처리

함수는 항상 에러 상황을 고려해야 합니다:

```c
#include <stdio.h>
#include <stdlib.h>

// 에러 코드 정의
typedef enum {
    SUCCESS = 0,
    ERROR_NULL_POINTER,
    ERROR_INVALID_INPUT,
    ERROR_MEMORY_ALLOCATION,
    ERROR_FILE_IO
} ErrorCode;

// 에러 메시지 출력
const char* get_error_message(ErrorCode code) {
    switch (code) {
        case SUCCESS: return "성공";
        case ERROR_NULL_POINTER: return "NULL 포인터 오류";
        case ERROR_INVALID_INPUT: return "잘못된 입력";
        case ERROR_MEMORY_ALLOCATION: return "메모리 할당 실패";
        case ERROR_FILE_IO: return "파일 입출력 오류";
        default: return "알 수 없는 오류";
    }
}

// 안전한 문자열 복사 함수
ErrorCode safe_string_copy(char* dest, size_t dest_size, const char* src) {
    if (dest == NULL || src == NULL) {
        return ERROR_NULL_POINTER;
    }
    
    if (dest_size == 0) {
        return ERROR_INVALID_INPUT;
    }
    
    // 문자열 복사 (안전한 버전)
    size_t i;
    for (i = 0; i < dest_size - 1 && src[i] != '\0'; i++) {
        dest[i] = src[i];
    }
    dest[i] = '\0';  // NULL 종료
    
    // src가 너무 길었는지 확인
    if (src[i] != '\0') {
        return ERROR_INVALID_INPUT;  // 잘림 발생
    }
    
    return SUCCESS;
}

int main(void) {
    char buffer[10];
    const char* source = "Hello, World!";
    
    ErrorCode error = safe_string_copy(buffer, sizeof(buffer), source);
    
    if (error != SUCCESS) {
        printf("오류: %s\n", get_error_message(error));
        printf("복사된 문자열: %s\n", buffer);  // "Hello, Wo"로 잘림
        return 1;
    }
    
    printf("성공적으로 복사됨: %s\n", buffer);
    return 0;
}
```

### 4. 문서화 주석

함수의 목적, 매개변수, 반환값, 예외 상황을 문서화하세요:

```c
/**
 * @brief 두 점 사이의 유클리드 거리를 계산합니다.
 * 
 * @param x1 첫 번째 점의 x 좌표
 * @param y1 첫 번째 점의 y 좌표
 * @param x2 두 번째 점의 x 좌표
 * @param y2 두 번째 점의 y 좌표
 * @return 두 점 사이의 거리
 * 
 * @note 이 함수는 2차원 평면에서의 거리를 계산합니다.
 *       3차원 공간에서는 다른 함수를 사용하세요.
 */
double calculate_distance(double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    return sqrt(dx * dx + dy * dy);
}
```

## 디버깅 팁

### 1. 함수 호출 추적

복잡한 함수 호출 구조를 디버깅할 때:

```c
#include <stdio.h>

// 디버그 모드 정의
#define DEBUG 1

// 디버그 출력 매크로
#ifdef DEBUG
#define TRACE_ENTER(func_name) printf("--> %s()\n", func_name)
#define TRACE_EXIT(func_name) printf("<-- %s()\n", func_name)
#else
#define TRACE_ENTER(func_name)
#define TRACE_EXIT(func_name)
#endif

void function_a(void) {
    TRACE_ENTER("function_a");
    printf("A 실행 중...\n");
    TRACE_EXIT("function_a");
}

void function_b(void) {
    TRACE_ENTER("function_b");
    printf("B 실행 중...\n");
    function_a();
    TRACE_EXIT("function_b");
}

int main(void) {
    TRACE_ENTER("main");
    function_b();
    TRACE_EXIT("main");
    return 0;
}
```

### 2. 함수 성능 측정

```c
#include <stdio.h>
#include <time.h>

// 성능 측정 매크로
#define TIME_FUNCTION_CALL(func_call) \
    do { \
        clock_t start = clock(); \
        func_call; \
        clock_t end = clock(); \
        double elapsed = (double)(end - start) / CLOCKS_PER_SEC; \
        printf("실행 시간: %.6f초\n", elapsed); \
    } while(0)

// 테스트할 함수
void slow_function(void) {
    // 시간이 걸리는 작업 시뮬레이션
    volatile long long sum = 0;
    for (volatile long long i = 0; i < 100000000; i++) {
        sum += i;
    }
}

void fast_function(void) {
    // 빠른 작업
    volatile int result = 42 * 42;
}

int main(void) {
    printf("느린 함수: ");
    TIME_FUNCTION_CALL(slow_function());
    
    printf("빠른 함수: ");
    TIME_FUNCTION_CALL(fast_function());
    
    return 0;
}
```

## 마무리

함수는 C 프로그래밍의 핵심 구성 요소입니다. 잘 설계된 함수는:

1. **한 가지 일만 잘 수행합니다** - 단일 책임 원칙
2. **명확한 이름을 가집니다** - 호출하는 코드가 이해하기 쉽습니다
3. **적절한 매개변수를 가집니다** - 필요한 정보만 전달받습니다
4. **에러를 적절히 처리합니다** - 호출자가 처리할 수 있도록 합니다
5. **테스트하기 쉽습니다** - 독립적으로 테스트할 수 있습니다

함수를 효과적으로 사용하면 코드의 가독성, 재사용성, 유지보수성이 크게 향상됩니다. 연습을 통해 함수 설계 능력을 키우면 더욱 견고하고 효율적인 프로그램을 작성할 수 있을 것입니다.
