---
layout: post
title: C - 함수
date: 2024-08-22 19:20:23 +0900
category: C
---
# 함수(Function)

## 0. 워밍업: 함수 핵심 맛보기 (5분 압축)

```c
#include <stdio.h>
#include <stdlib.h>

/* 선언(원형, prototype) — 호출 전에 컴파일러가 시그니처를 안다 */
int   add(int a, int b);
void  swap(int *a, int *b);               // 주소(참조) 전달
double mean(const int *arr, size_t n);    // const 포인터 인자
int   cmp_int(const void *lhs, const void *rhs); // 콜백(함수 포인터)

/* 정의 */
int add(int a, int b) { return a + b; }

void swap(int *a, int *b) { int t=*a; *a=*b; *b=t; }

double mean(const int *arr, size_t n) {
    if (!arr || n==0) return 0.0;
    long long s = 0;
    for (size_t i=0;i<n;++i) s += arr[i];
    return (double)s / (double)n;
}

int cmp_int(const void *lhs, const void *rhs) {
    int x = *(const int*)lhs;
    int y = *(const int*)rhs;
    return (x>y) - (x<y); // 음수/0/양수
}

int main(void) {
    int x=3, y=4;
    printf("add=%d\n", add(x,y));
    swap(&x,&y);
    printf("swapped: x=%d y=%d\n", x,y);

    int v[] = {9,1,7,3,2};
    qsort(v, 5, sizeof v[0], cmp_int);
    printf("mean=%.2f first=%d\n", mean(v,5), v[0]);
    return 0;
}
```

---

## 1. 함수란 무엇이며, 왜 쓰는가?

- **작업 단위의 코드 블록**으로 **재사용성/테스트성/가독성** 향상.
- 인터페이스(선언)와 구현(정의)을 **분리**해 모듈화.
- 빌드 시스템(링커) 단계에서 여러 번역 단위(**.c 파일**)를 결합.

---

## 2. 선언·정의·호출 — 시그니처가 전부다

### 2.1 기본 구조

```c
반환형 함수이름(매개변수 선언들) {
    // 본문
    return 반환값; // void면 생략 가능
}
```

예:
```c
int add(int a, int b) {
    return a + b;
}

int r = add(3,4);
```

### 2.2 함수 **원형(prototype)** 이 중요한 이유

- **컴파일 시 타입 검사** (인자/반환형 불일치 탐지).
- **기본 인자 승격** 오류 방지(특히 가변인자 호출과 섞일 때 위험).
- 헤더에 선언, 소스에 정의하는 이유가 여기에 있다.

```c
// 헤더(.h)에 선언
int add(int a, int b);

// 소스(.c)에 정의
int add(int a, int b) { return a + b; }
```

### 2.3 링키지(연결): 외부/내부, `extern`/`static`

- **외부 연결(External linkage)**: 기본. 다른 번역 단위에서 참조 가능.
- **내부 연결(Internal linkage)**: `static` 함수/변수 → 해당 파일 안에서만.
- 헤더에는 **선언**만, `.c`에 **정의**. 전역 정의를 헤더에 넣지 않는다.

---

## 3. 인자 전달 — 값/주소/배열/큰 구조체/출력 인자

### 3.1 값에 의한 전달 (Call by Value)

- C는 **기본적으로 값 전달**: 인자의 **복사본**을 받는다.

```c
void set10(int x) { x=10; }
int a=5; set10(a); // a는 그대로 5
```

### 3.2 주소(포인터) 전달 — 원본 수정

```c
void set10(int *x) { if(x) *x=10; }
int a=5; set10(&a); // a == 10
```

### 3.3 배열 매개변수

- 함수 인자에서 `int arr[]`는 사실상 `int *arr`로 **디케이(decay)**.
- **길이 정보(n)**를 반드시 함께 넘긴다.

```c
int sum(const int *arr, size_t n) {
    long long s=0; for(size_t i=0;i<n;++i) s+=arr[i];
    return (int)s;
}
```

### 3.4 큰 구조체 전달: 복사 vs 포인터

```c
typedef struct { double x,y,z[32]; } Big;

void process_big(Big b);        // 큰 복사 비용
void process_bigp(const Big *p); // 포인터 권장 (읽기 전용이면 const)
```

### 3.5 여러 값을 반환해야 할 때: **출력 인자(out param)** 또는 구조체 반환

```c
typedef struct { int min, max; double avg; } Stats;

Stats calc_stats(const int *a, size_t n);
void  calc_stats_out(const int *a, size_t n, int *min, int *max, double *avg);
```

구조체 **값 반환**은 최신 ABI에서 효율적인 경우가 많다(최적화/NRVO).

---

## 4. `const` / `restrict` / `volatile` — 함수 인자에 깃발 꽂기

### 4.1 `const` — 읽기 전용 계약

```c
size_t cstrlen(const char *s);      // s를 수정하지 않음
int    sumv(const int *v, size_t n); // v의 내용 불변 계약
```

### 4.2 `restrict` (C99) — 별칭(aliasing) 없음 힌트로 최적화 유도

```c
void addv(size_t n, double * restrict dst,
          const double * restrict a,
          const double * restrict b) {
    for (size_t i=0;i<n;++i) dst[i]=a[i]+b[i];
}
```

- `dst`, `a`, `b`가 **겹치지 않음**을 보장 → 컴파일러 최적화 이점.

### 4.3 `volatile` — 하드웨어/시그널/메모리-맵 IO

```c
volatile int flag; // 최적화로 제거/재정렬하지 말 것
```

---

## 5. 반환형 — `void`/스칼라/구조체, 에러 처리 계약

- `void` : 결과 없음.
- 스칼라형: `int/double/...`
- 구조체: 다중 반환 패턴에 유용.
- 에러 처리: **상태 코드 반환 + 출력 인자**, 또는 **errno/전역 상태**, 또는 **구조체에 상태 포함**.

```c
typedef enum { ST_OK=0, ST_EINVAL, ST_EIO } status_t;

status_t read_conf(const char *path, Config *out);
```

---

## 6. 헤더와 소스 파일 분리 — 인터페이스/캡슐화

### 6.1 간단 예시

**calc.h**
```c
#ifndef CALC_H
#define CALC_H

int add(int a, int b);
int subtract(int a, int b);

#endif
```

**calc.c**
```c
#include "calc.h"
int add(int a,int b){return a+b;}
int subtract(int a,int b){return a-b;}
```

**main.c**
```c
#include <stdio.h>
#include "calc.h"

int main(void){
    printf("%d %d\n", add(5,3), subtract(5,3));
    return 0;
}
```

빌드:
```bash
gcc -std=c11 -Wall -Wextra -O2 main.c calc.c -o app
```

### 6.2 Opaque(불투명) 핸들 — C에서의 캡슐화

**matrix.h**
```c
#ifndef MATRIX_H
#define MATRIX_H
#include <stddef.h>

typedef struct matrix matrix;   // 내부 구조 감춤
matrix *matrix_new(size_t r, size_t c);
void    matrix_free(matrix *m);
int     matrix_set(matrix *m, size_t r, size_t c, double v);
int     matrix_get(const matrix *m, size_t r, size_t c, double *out);

#endif
```

**matrix.c**
```c
#include "matrix.h"
#include <stdlib.h>

struct matrix { size_t r,c; double *a; };

matrix *matrix_new(size_t r,size_t c){
    matrix *m = malloc(sizeof *m);
    if(!m) return NULL;
    m->r=r; m->c=c;
    m->a = calloc(r*c, sizeof *m->a);
    if(!m->a){ free(m); return NULL; }
    return m;
}
void matrix_free(matrix *m){
    if(!m) return; free(m->a); free(m);
}
int matrix_set(matrix *m,size_t r,size_t c,double v){
    if(!m||r>=m->r||c>=m->c) return -1;
    m->a[r*m->c+c]=v; return 0;
}
int matrix_get(const matrix *m,size_t r,size_t c,double *out){
    if(!m||!out||r>=m->r||c>=m->c) return -1;
    *out=m->a[r*m->c+c]; return 0;
}
```

> 헤더에는 **타입 이름만 노출**, 내부 레이아웃/필드를 숨겨 **ABI 안정성/캡슐화** 확보.

---

## 7. inline / static inline / 매크로 대체

```c
/* 헤더에 넣을 때는 static inline 권장(ODR-유사 문제 회피) */
static inline int max_int(int a, int b){ return a>b ? a : b; }
```

- 매크로 함수보다 타입/디버깅 면에서 안전.
- 성능: 컴파일러가 인라인 여부 결정(강제 아님).

---

## 8. 함수 포인터와 콜백 — 전략 교체/정렬/이벤트

### 8.1 타입 별칭으로 가독성 높이기

```c
typedef int(*cmp_fn)(const void*, const void*);
```

### 8.2 `qsort`와 사용자 정의 비교자

```c
#include <stdlib.h>
#include <stdio.h>

int cmp_int(const void *a, const void *b) {
    int x = *(const int*)a;
    int y = *(const int*)b;
    return (x>y) - (x<y);
}

int main(void){
    int v[]={5,1,4,2,3};
    qsort(v,5,sizeof v[0],cmp_int);
    for(int i=0;i<5;++i) printf("%d ", v[i]); // 1 2 3 4 5
    return 0;
}
```

### 8.3 디스패치 테이블 (상태기계/명령 라우팅)

```c
#include <stdio.h>

typedef void (*handler)(void);

static void h_add(void){ puts("add"); }
static void h_sub(void){ puts("sub"); }
static void h_err(void){ puts("err"); }

int main(void){
    handler tbl[3] = { h_add, h_sub, h_err };
    int opcode = 0; // 0..2
    if (opcode<0 || opcode>=3) opcode=2;
    tbl[opcode]();
    return 0;
}
```

---

## 9. 재귀(recursion)와 꼬리 재귀(tail recursion)

### 9.1 재귀 예: 팩토리얼

```c
unsigned long long fact(unsigned n){
    if(n<2) return 1ULL;
    return n * fact(n-1);
}
```

### 9.2 꼬리 재귀 → 루프로 변환 권장(스택 사용 감소)

```c
unsigned long long fact_iter(unsigned n){
    unsigned long long acc=1;
    while(n>1) acc*=n--;
    return acc;
}
```

---

## 10. 가변 인자(variadic) — `printf` 류 직접 만들기

- 헤더: `<stdarg.h>`
- 주의: **타입 안전 없음**, `...`에는 **기본 인자 승격** 발생:
  - `float` → `double`, `char/short` → `int`.

```c
#include <stdarg.h>
#include <stdio.h>

double sumd(size_t n, ...) {
    va_list ap; va_start(ap, n);
    double s = 0.0;
    for (size_t i=0;i<n;++i) s += va_arg(ap, double);
    va_end(ap);
    return s;
}

int main(void){
    printf("%.2f\n", sumd(3, 1.0, 2.5, 3.25)); // 6.75
    return 0;
}
```

---

## 11. 에러 처리 패턴 — 상태 코드/errno/아웃 파라미터

### 11.1 상태 코드 반환 + out 인자

```c
#include <stdio.h>

typedef enum { OK=0, E_EMPTY, E_RANGE } Status;

Status avg_0_100(const int *a, size_t n, double *out){
    if(!a||!out||n==0) return E_EMPTY;
    long long s=0;
    for(size_t i=0;i<n;++i){
        if(a[i]<0||a[i]>100) return E_RANGE;
        s+=a[i];
    }
    *out = (double)s/(double)n;
    return OK;
}

int main(void){
    int v[]={90,100,75,88};
    double avg=0.0;
    Status st = avg_0_100(v,4,&avg);
    if(st==OK) printf("avg=%.2f\n", avg);
    else fprintf(stderr, "err=%d\n", st);
}
```

### 11.2 `errno` 사용(표준 라이브러리와 호환)

```c
#include <errno.h>
#include <stdlib.h>
#include <limits.h>

long read_long(const char *s, int *ok){
    errno=0; char *end=NULL;
    long v = strtol(s,&end,10);
    if(errno==ERANGE || end==s) { if(ok)*ok=0; return 0; }
    if(ok)*ok=1; return v;
}
```

---

## 12. `main`의 시그니처와 반환 규약

```c
int main(void) { /* ... */ }             // 인자 없음
int main(int argc, char **argv) { /*...*/ } // 명령행 인자
```

- 반환 0: 성공, 0 외: 실패(관례).

---

## 13. 문서화와 테스트

### 13.1 Doxygen 스타일 주석 예

```c
/**
 * @brief  평균값 계산(0~100)
 * @param  a   입력 배열
 * @param  n   길이
 * @param  out 결과 평균 (출력)
 * @return OK / 오류 코드
 */
Status avg_0_100(const int *a, size_t n, double *out);
```

### 13.2 최소 단위 테스트(표준만 사용)

```c
#include <assert.h>
int add(int,int);
int main(void){
    assert(add(2,3)==5);
    return 0;
}
```

---

## 14. 빌드 시스템 미니 가이드(CMake)

```
func-demo/
├─ CMakeLists.txt
├─ include/
│  └─ calc.h
└─ src/
   ├─ calc.c
   └─ main.c
```

**CMakeLists.txt**
```cmake
cmake_minimum_required(VERSION 3.20)
project(func_demo C)
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_EXTENSIONS OFF)
add_library(calc STATIC src/calc.c)
target_include_directories(calc PUBLIC ${CMAKE_SOURCE_DIR}/include)
add_executable(app src/main.c)
target_link_libraries(app PRIVATE calc)
if (MSVC)
  target_compile_options(calc PRIVATE /W4)
  target_compile_options(app  PRIVATE /W4)
else()
  target_compile_options(calc PRIVATE -Wall -Wextra -Wpedantic -O2)
  target_compile_options(app  PRIVATE -Wall -Wextra -Wpedantic -O2)
endif()
```

빌드:
```bash
cmake -S . -B build
cmake --build build
./build/app
```

---

## 15. 실전 예제 모음

### 15.1 안전한 입력 → 처리 → 출력 (함수 분해)

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

int read_int_line(int *out) {
    char buf[64];
    if (!fgets(buf, sizeof buf, stdin)) return 0;
    char *end=NULL; errno=0;
    long v = strtol(buf, &end, 10);
    if (errno==ERANGE || end==buf || v<INT_MIN || v>INT_MAX) return 0;
    *out = (int)v; return 1;
}

int main(void){
    int x,y;
    if(!read_int_line(&x) || !read_int_line(&y)){
        fputs("invalid\n", stderr);
        return 1;
    }
    printf("%d\n", x+y);
    return 0;
}
```

### 15.2 정렬 래퍼: 비교자 주입(전략 패턴)

```c
typedef int (*cmpi)(int,int);

static int asc(int a,int b){ return (a>b)-(a<b); }
static int desc(int a,int b){ return (b>a)-(b<a); }

void sort3(int *a, cmpi cmp){
    if(cmp(a[0],a[1])>0){int t=a[0];a[0]=a[1];a[1]=t;}
    if(cmp(a[1],a[2])>0){int t=a[1];a[1]=a[2];a[2]=t;}
    if(cmp(a[0],a[1])>0){int t=a[0];a[0]=a[1];a[1]=t;}
}
```

### 15.3 라이브러리 함수 포장: 실패 안전(예외 흐름 없음)

```c
int read_file_all(const char *path, char **out_data, size_t *out_len){
    FILE *fp = fopen(path,"rb");
    if(!fp) return -1;
    if(fseek(fp,0,SEEK_END)!=0){ fclose(fp); return -1; }
    long sz = ftell(fp);
    if(sz<0){ fclose(fp); return -1; }
    rewind(fp);
    char *buf = malloc((size_t)sz+1u);
    if(!buf){ fclose(fp); return -1; }
    size_t n = fread(buf,1,(size_t)sz,fp);
    fclose(fp);
    if(n!=(size_t)sz){ free(buf); return -1; }
    buf[n]='\0';
    *out_data=buf; *out_len=n; return 0;
}
```

---

## 16. 성능·안전 체크리스트(함수 관점)

- 인자에 **`const`**/`restrict`/정확한 폭 타입(`size_t`, `uint32_t`) 적용.
- **경고 최대로**: `-Wall -Wextra -Wpedantic` / `/W4`.
- **오류 반환 즉시 처리·자원 회수**(goto cleanup 패턴 유용).
- **헤더 가드** + `static inline`로 경량 유틸 제공.
- **함수 길이 단축·단일 책임**: 테스트/리뷰/최적화에 유리.

---

## 17. 자주 묻는 질문(FAQ)

**Q1. C에는 함수 오버로딩이 없는데, 타입별 함수를 하나로 묶고 싶다?**  
A. 이름 구분(`add_i`, `add_d`) 또는 **매크로+`_Generic`(C11)**으로 디스패치.

```c
static inline int   add_i(int a,int b){return a+b;}
static inline double add_d(double a,double b){return a+b;}
#define add(x,y) _Generic(((x)+(y)), \
    int: add_i,                      \
    double: add_d,                   \
    default: add_d                   \
)(x,y)
```

**Q2. 반환값과 에러 모두 전달하려면?**  
A. **상태 코드 반환 + out 인자**, 또는 **구조체 반환**으로 함께 싣는다.

```c
typedef struct { int ok; int value; } Rint;
Rint parse_int(const char *s);
```

**Q3. 함수 포인터 문법이 복잡하다.**  
A. **typedef**로 별칭을 항상 만든다: `typedef int(*cmp_fn)(const void*,const void*);`

---

## 18. 요약

- **선언/정의/호출**: 원형은 타입 안전의 출발점, 링키지 이해 필수.
- **인자 전달**: 값/주소, 배열 디케이, 길이 동반, out 인자/구조체 반환.
- **계약**: `const`/`restrict`/`volatile`로 의도 명확화.
- **모듈화**: 헤더=선언, 소스=정의, Opaque 타입으로 캡슐화.
- **고급 주제**: 콜백(함수 포인터), 가변 인자, 에러 처리 패턴.
- **빌드/테스트**: CMake 골격, 경고 최대로, 단위 테스트 습관화.