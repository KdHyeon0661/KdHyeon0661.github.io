---
layout: post
title: 형식언어와 오토마타 - 언어, 문법, 오토마타
date: 2025-06-12 21:20:23 +0900
category: 형식언어와 오토마타
---
# 언어, 문법, 오토마타 — 개선본(심화 가이드)

형식언어와 오토마타 이론은 **무엇을 계산할 수 있고, 어떻게 효율적으로 판정/생성할 수 있는지**를 수학적으로 다루는 도구다.
이 글은 **언어(Language)** → **문법(Grammar)** → **오토마타(Automata)**의 순으로 정의와 예시를 정교화하고, 세 개념이 **어떻게 서로 대응/변환**되는지(정규 ↔ DFA/NFA, CFG ↔ PDA)를 **증명 스케치·알고리즘·코드**와 함께 정리한다.

---

## 0. 표기와 기본 연산(Notation & Ops)

- 알파벳: $$\Sigma$$ (유한 집합)
- 문자열: $$w \in \Sigma^\*$$, 길이 $$|w|$$, 공백 문자열 $$\varepsilon$$
- 역(반전): $$w^R$$ (예: $$\text{"abc"}^R=\text{"cba"}$$)
- 연결: $$xy$$, 거듭제곱: $$x^k$$ (예: $$a^3=\text{"aaa"}$$)
- 언어: $$L \subseteq \Sigma^\*$$
- 클리니-별: $$L^\*=\bigcup_{k\ge 0} L^k$$, 플러스: $$L^+=LL^\*$$

문자열/언어 연산 성질(대표):
- $$|xy|=|x|+|y|,\quad x\varepsilon=\varepsilon x=x$$
- $$(L_1\cup L_2)^\* = (L_1^\* L_2^\*)^\*$$ (주의: 일반 등식은 맥락에 따라 달라짐)

---

## 1. 언어(Language)

**정의**: 어떤 알파벳 $$\Sigma$$에 대해, **언어**는 $$\Sigma^\*$$의 부분집합 $$L \subseteq \Sigma^\*$$.

### 1.1 알파벳/문자열/집합 표기
- $$\Sigma^n$$: 길이 $$n$$인 모든 문자열 집합, $$\Sigma^\*=\bigcup_{n\ge 0}\Sigma^n$$, $$\Sigma^+ = \Sigma^\*\setminus\{\varepsilon\}$$
- 부분문자열(서브스트링) $$u \preceq w$$, 접두사/접미사 $$u \triangleleft w,\ u \triangleright w$$

### 1.2 예와 계산 관점
- $$\Sigma=\{a,b\},\ L=\{ w\in\Sigma^\* \mid \#_a(w)\text{가 짝수}\}$$
- **멤버십 문제**: 주어진 $$w$$가 $$L$$에 속하는지? (결정 문제)
- **공집합성/유한성/동치성**: 언어의 전형적 판정 문제(클래스에 따라 난이도 상이)

> **상황 예시(스트리밍 정책)**: “로그에서 ‘E’ 코드가 **짝수 번** 나오면 승인”은 **상태 2개짜리** DFA로 선형 시간 판정 가능.

---

## 2. 문법(Grammar)

**형식 문법** $$G=(V,\Sigma,R,S)$$:
- $$V$$: 비단말(Nonterminals), $$\Sigma$$: 단말(Terminals, 알파벳)
- $$R\subseteq V\times (V\cup \Sigma)^\*$$: 생성 규칙(Production)
- $$S\in V$$: 시작 기호

**유도(derivation)**: $$A\Rightarrow \alpha$$, 좌/우-최좌(우) 유도, 파스 트리(Parse Tree)

### 2.1 대표 예: 균형된 a-b
문법:
```text
G = ({S}, {a, b}, R, S)
R:
  S → aSb
  S → ε
```
생성 언어:
$$
L(G)=\{a^n b^n \mid n\ge 0\}.
$$

- `ε`, `ab`, `aabb`, `aaabbb`, …

### 2.2 촘스키 위계(Chomsky Hierarchy)
| 타입 | 언어 | 규칙 형태(개략) | 대응 오토마타 |
|---|---|---|---|
| Type 0 | 재귀열거 | 제약 없음 | 튜링 기계(TM) |
| Type 1 | 문맥민감 | $$\alpha A \beta \to \alpha \gamma \beta$$ | LBA |
| Type 2 | 문맥자유 | $$A \to \gamma$$ | PDA |
| Type 3 | 정규 | $$A \to aB \ \text{or}\ A\to a \ (\varepsilon)$$ | DFA/NFA |

> **정규 문법**(우/좌-선형)은 정규 언어와 동치. CFG는 문맥자유 언어와 동치.

### 2.3 CFG 다루기(정규화·모호성·간소화)
- **쓸모없는 심볼 제거**(도달/생산 불가), **ε-생산/단일생산 제거**, **CNF/GNF 변환**
- **모호성**: 한 문자열에 대한 파스 트리가 여러 개 ⇒ 문법의 성질(언어 자체가 본질적 모호일 수도 있음)

---

## 3. 오토마타(Automata)

오토마타는 언어를 **인식(recognize)**하거나 생성/시뮬레이션하는 추상 기계.

### 3.1 분류와 목적
| 오토마타 | 인식 언어 | 기억 장치(핵심) |
|---|---|---|
| DFA | 정규 | 유한상태·결정 전이 |
| NFA/ε-NFA | 정규 | 유한상태·비결정/ε-이동 |
| PDA | 문맥자유 | 스택(깊이 1 차원) |
| LBA | 문맥민감 | 입력 길이 선형 범위 테이프 |
| TM | 재귀열거 | 무한 테이프(보편 계산) |

### 3.2 DFA 정의(재확인)
$$
M=(Q,\Sigma,\delta,q_0,F)
$$
- $$\delta:Q\times\Sigma\to Q$$, 확장 $$\hat\delta(q,w)$$로 $$L(M)=\{w\mid \hat\delta(q_0,w)\in F\}$$

**예(패리티)**: `a`의 개수 짝/홀 판정 DFA
- $$Q=\{q_0(\text{짝}),q_1(\text{홀})\},\ F=\{q_0\}$$
- $$\delta(q_0,a)=q_1,\ \delta(q_1,a)=q_0$$

### 3.3 NFA/ε-NFA와 DFA의 동치
- ε-폐포로 ε-NFA → NFA, **부분집합 구성**으로 NFA → DFA
- (정리) DFA ≡ NFA ≡ ε-NFA(정규 언어 동치)

### 3.4 PDA와 CFG의 동치(개념)
- CFG → PDA: 좌변 비단말을 스택 상단으로 두고, 우변을 push/pop로 모사
- PDA → CFG: PDA 이동을 문법 규칙으로 재작성

---

## 4. 정규 언어와 정규 문법(↔ DFA/NFA/정규식)

### 4.1 동치성(핵심 정리)
정규 언어는 **정규 문법/정규표현식/DFA/NFA** 중 **어느 하나**로 표현 가능 ⇔ **나머지** 표현으로도 변환 가능.

- 정규식 → Thompson → ε-NFA → NFA → DFA
- DFA → 상태 제거 → 정규식
- 우-선형 문법 ↔ NFA 변환(아래 6.2)

### 4.2 닫힘성(폐쇄성)
정규 언어는 **합, 교, 차, 여, 연결, Kleene-별, 역(반전), 동형사상**에 대해 닫힘.

**증명 스케치**
- 교집합: 두 DFA의 **곱구성**
- 여집합: 완전 DFA에서 **수용/비수용 뒤집기**

### 4.3 비정규 판정(경계 이해)
- 펌핑 보조정리(Regular Pumping): 필요조건
- Myhill–Nerode: 동치류가 **유한 개** ⇔ 정규, 최소 DFA 상태 수 = 동치류 수
- 예: $$\{a^n b^n\}$$는 정규가 아님(펌핑/마이힐–네로드로 증명)

> **상황 예시(입력 검증)**: “열 A 길이 = 열 B 길이” 같은 **상호 의존적 길이 제약**은 DFA로 불가 → CFG/PDA 이상 필요.

---

## 5. CFG와 문맥자유 언어(↔ PDA)

### 5.1 CNF/GNF 변환(개요)
- **CNF**: $$A\to BC\ \mid\ a\ (\mid\ S\to \varepsilon)$$
- **변환 단계**: ε-생산 제거 → 단일생산 제거 → 쓸모없는 심볼 제거 → 길이 2로 쪼개기
- **CYK**: CNF에서 $$O(n^3)$$ 멤버십 판정(§7.3 코드)

### 5.2 균형/중첩 구조
- $$\{a^n b^n\}$$, 거울언어 $$\{ww^R\}$$, 괄호 짝 등은 PDA가 자연스러움

---

## 6. 변환 레시피(Grammar ↔ Automata)

### 6.1 DFA/NFA ↔ 정규식(핵심만)
- 정규식 → ε-NFA(Thompson) → NFA → DFA(부분집합)
- DFA → 상태 제거로 정규식(에지 레이블을 정규식으로 합성)

### 6.2 정규 문법(우-선형) ↔ NFA
- 규칙: $$A\to aB$$는 $$A \xrightarrow{a} B$$, $$A\to a$$는 $$A \xrightarrow{a} q_f$$(새 최종상태), $$A\to \varepsilon$$이면 $$A$$를 최종화
- 역변환: 자동자 상태를 비단말로 두고, 전이를 규칙으로

**예**
정규 문법:
```text
S → aS | bA | a
A → bS | ε
```
NFA 전이:
- S —a→ S, S —b→ A, S —a→ qf
- A —b→ S, A 최종(ε 때문에)

---

## 7. 알고리즘 & 코드(교육용 미니 구현)

> **주의**: 아래 코드는 학습용으로 단순화됨. 실무는 에러 처리·성능 최적화 필요.

### 7.1 DFA 시뮬레이터
```python
class DFA:
    def __init__(self, states, alphabet, delta, start, accepts):
        self.states = set(states)
        self.alphabet = set(alphabet)
        self.delta = dict(delta)     # {(q,a): q'}
        self.start = start
        self.accepts = set(accepts)

    def run(self, s: str) -> bool:
        q = self.start
        for ch in s:
            if ch not in self.alphabet:
                return False
            q = self.delta[(q, ch)]
        return q in self.accepts

# 예: a의 개수 짝수
dfa_even_a = DFA(
    states={'q0','q1'},
    alphabet={'a'},
    delta={('q0','a'):'q1', ('q1','a'):'q0'},
    start='q0',
    accepts={'q0'}
)
print(dfa_even_a.run(""))       # True
print(dfa_even_a.run("a"))      # False
print(dfa_even_a.run("aa"))     # True
```

### 7.2 NFA → DFA (부분집합 구성)
```python
from collections import defaultdict, deque

class NFA:
    def __init__(self, states, alphabet, delta, start, accepts):
        self.states = set(states)
        self.alphabet = set(alphabet)  # ε 제외
        self.delta = defaultdict(set)  # (q,a) -> set(q')
        for (q,a), dests in delta.items():
            self.delta[(q,a)].update(dests)
        self.start = start
        self.accepts = set(accepts)

def nfa_to_dfa(nfa: NFA) -> DFA:
    start_set = frozenset([nfa.start])
    qname = {start_set: "S0"}
    work = deque([start_set])
    dfa_delta, dfa_states, dfa_accepts = {}, {"S0"}, set()
    next_id = 1

    def name_of(state_set):
        nonlocal next_id
        if state_set not in qname:
            qname[state_set] = f"S{next_id}"
            next_id += 1
        return qname[state_set]

    while work:
        T = work.popleft()
        Tn = qname[T]
        if any(q in nfa.accepts for q in T):
            dfa_accepts.add(Tn)
        for a in nfa.alphabet:
            U = set()
            for q in T:
                U |= nfa.delta.get((q,a), set())
            U = frozenset(U)
            if not U:
                continue
            Un = name_of(U)
            dfa_delta[(Tn, a)] = Un
            if Un not in dfa_states:
                dfa_states.add(Un); work.append(U)
    return DFA(states=set(dfa_states), alphabet=nfa.alphabet,
               delta=dfa_delta, start="S0", accepts=dfa_accepts)

# (a|b)*abb를 인식하는 NFA 예
nfa = NFA(
    states={'q0','q1','q2','q3'},
    alphabet={'a','b'},
    delta={
      ('q0','a'):{'q0','q1'}, ('q0','b'):{'q0'},
      ('q1','b'):{'q2'},
      ('q2','b'):{'q3'},
    },
    start='q0',
    accepts={'q3'}
)
dfa = nfa_to_dfa(nfa)
print(dfa.run("abb"))    # True
print(dfa.run("aabb"))   # True
print(dfa.run("ababa"))  # False
```

### 7.3 CYK(신문법/CNF 기반) 멤버십 판정
- CNF 필요: $$A\to BC\ \mid\ a$$ (및 $$S\to\varepsilon$$ 가능)
```python
from collections import defaultdict

def cyk_members(cnf_productions, s):
    """
    cnf_productions: dict {Nonterm: [('A','B'),('a',), ...]}
    s: 입력 문자열(str)
    return: 마지막 칸의 가능한 비단말 집합(set)
    """
    n = len(s)
    if n == 0:
        # CNF에서 ε 허용 여부는 S->ε로 처리
        return set()
    P = [[set() for _ in range(n)] for _ in range(n)]

    # 길이 1
    for i, a in enumerate(s):
        for A, rhs_list in cnf_productions.items():
            for rhs in rhs_list:
                if len(rhs)==1 and rhs[0]==a:
                    P[i][i].add(A)

    # 길이 >=2
    for l in range(2, n+1):
        for i in range(n-l+1):
            j = i+l-1
            for k in range(i, j):
                left, right = P[i][k], P[k+1][j]
                if not left or not right:
                    continue
                for A, rhs_list in cnf_productions.items():
                    for rhs in rhs_list:
                        if len(rhs)==2 and rhs[0] in left and rhs[1] in right:
                            P[i][j].add(A)
    return P[0][n-1]

# 예 CNF: S->AB|BC, A->a, B->b, C->c
G = {
  'S':[('A','B'),('B','C')],
  'A':[('a',)],
  'B':[('b',)],
  'C':[('c',)]
}
print('ab' in cyk_members(G, 'ab'))  # False, 반환은 집합이므로 아래처럼 확인
print('S' in cyk_members(G, 'ab'))   # True
print('S' in cyk_members(G, 'bc'))   # True
print('S' in cyk_members(G, 'ac'))   # False
```

---

## 8. 설계 레시피(자주 쓰는 패턴)

### 8.1 접미사/부분문자열
- **끝이 `abb`**: “최장 일치 접미사 길이”를 상태로 둔 DFA
- **부분문자열에 `ab` 포함**: “`a` 직후 `b`를 본 적이 있는가?”

### 8.2 모듈러 카운팅
- 2진수로 본 값이 3의 배수: 상태 {0,1,2}로 나머지 전이
  $$r \gets (2r+a)\bmod 3$$

### 8.3 금지 패턴 회피
- `11` 금지: “마지막이 1인가?”를 기억해 `1` 뒤 `1` 차단

### 8.4 균형/중첩(문맥자유)
- 괄호 짝: PDA 스택 push/pop
- $$\{a^n b^n\}$$: `a` 수만큼 push, `b`마다 pop

> **상황 예시(컴파일러 전처리)**: **렉서**(정규)로 토큰화 → **파서**(CFG/PDA)로 문장 구조를 판독. 괄호/우선순위/중첩은 CFG로 표현·검증.

---

## 9. LBA와 문맥민감, TM과 계산가능성

### 9.1 LBA(Linear Bounded Automaton)
- 입력 길이의 **선형 범위** 내에서만 테이프 사용 가능
- 문맥민감 언어(CSL) 인식(예: $$\{a^n b^n c^n\mid n\ge 0\}$$)

### 9.2 TM(튜링 기계)와 RE/Recursive
- TM: $$M=(Q,\Sigma,\Gamma,\delta,q_0,q_{acc},q_{rej})$$
- **재귀(결정가능)**: 항상 정지하며 정답
- **RE(인정가능)**: 언어에 속하면 정지/승인(비속한 경우 무한루프 가능)
- 정지 문제(HALT)는 **결정불가능**; Rice 정리: “프로그램이 인식하는 **언어의 비자명한 성질**은 모두 결정불가능”

---

## 10. 언어–문법–오토마타 연결 요약

- **정규언어**: 정규 문법 ↔ DFA/NFA ↔ 정규식
- **문맥자유언어**: CFG ↔ PDA
- **문맥민감언어**: CSG ↔ LBA
- **재귀열거언어**: TM

> 변환 알고리즘: 정규식→NFA(Thompson), NFA→DFA(부분집합), DFA→정규식(상태 제거), CFG→CNF(표준화)→CYK, CFG↔PDA(구성)

---

## 11. 증명 템플릿(핵심 카드)

### 11.1 정규 언어 여부
- **구성**: DFA/NFA/정규식 제시
- **폐쇄성**: 이미 정규인 것들의 합성으로 표현
- **Myhill–Nerode**: 유한 동치류/최소 상태 하한

### 11.2 비정규성
- **펌핑 보조정리**로 반례 구성(필요조건)
- **Myhill–Nerode**로 무한 동치류 제시

### 11.3 CFL 판정
- **CFG 구성** → 가능하면 CNF 변환 → **CYK**
- **교집합 트릭**: (CFL ∩ 정규)는 CFL
- **CFL 펌핑**: 균형 깨기

---

## 12. 종합 예시(짧은 해설 포함)

1) $$L_1=\{w\in\{a,b\}^\*\mid \text{`ab`가 부분문자열}\}$$
   - DFA/NFA/정규식으로 손쉽게 구성 가능.
   - 정규식 예: $$(a\mid b)^\*ab(a\mid b)^\*$$

2) $$L_2=\{a^n b^n\mid n\ge 0\}$$
   - CFG: $$S\to aSb\mid \varepsilon$$
   - PDA: `a`마다 push, `b`마다 pop

3) $$L_3=\{ww\mid w\in\{0,1\}^\*\}$$
   - 정규도, CFL도 아님(표준 결과; 동형사상/펌핑 응용)

4) $$L_4=\{w\in\{0,1\}^\*\mid w\ \text{(2진) 3의 배수}\}$$
   - 모듈러 DFA(상태 {0,1,2})

---

## 13. 연습 문제(스케치 해설)

1) $$L=\{w\in\{a,b\}^\*\mid w\ \text{가 }abb\text{로 끝난다}\}$$에 대한 DFA 설계
   - “최장 일치 접미사” 상태(0,1,2,3)로 구성.

2) $$L=\{a^i b^j\mid i\text{ 짝수 또는 } j\text{ 짝수}\}$$ 정규 여부
   - 각각 정규(짝수 카운팅) → **합**으로 정규.

3) $$\{a^n b^n c^n\}$$가 문맥자유가 아님을 보이는 아이디어
   - CFL 펌핑 또는 정규와의 교집합 트릭으로 모순 유도.

4) 정규 문법을 NFA로 바꾸는 절차 쓰기
   - $$A\to aB$$는 $$A \xrightarrow{a} B$$, $$A\to a$$는 새 최종으로, $$A\to\varepsilon$$이면 $$A$$를 최종화.

5) CFG를 CNF로 바꿔 CYK로 ‘ab’ 멤버십을 판정(§7.3 코드 활용)
   - S→AB|BC, A→a, B→b, C→c 예제 재현.

---

## 14. 자주 하는 실수 & 팁

- **펌핑 보조정리의 방향**: “펌핑 가능 ⇒ 정규”는 거짓. (필요조건)
- **정규식 엔진 ≠ 정규 언어**: 역참조/전후방은 이론 정규식에 없음 → **최악 지수** 주의
- **여집합 뒤집기**는 **완전 DFA** 전제 필요(정의역의 모든 전이가 채워져야 함)
- **CFG 모호성**은 문법의 성질(언어가 본질적 모호일 수도)

---

## 결론

언어는 **무엇의 집합**(판정 대상), 문법은 **어떻게 만들지**(생성 규칙), 오토마타는 **어떻게 판정/시뮬레이션할지**(계산 모델)이다.
정규 영역은 **DFA/NFA/정규식/정규 문법**이 서로 동치이고, 문맥자유는 **CFG/PDA**로 대응된다.
여기에 **변환 알고리즘**(Thompson, 부분집합, 상태제거, CNF→CYK)과 **증명 카드**(펌핑, 마이힐–네로드)를 곁들이면,
**렉서/파서/입력 검증/규칙 엔진**까지 완전한 연결고리를 갖춘 실전 역량을 얻을 수 있다.
