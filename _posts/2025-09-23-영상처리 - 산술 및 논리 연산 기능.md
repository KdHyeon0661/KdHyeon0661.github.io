---
layout: post
title: 영상처리 - 산술 및 논리 연산 기능
date: 2025-09-23 15:25:23 +0900
category: 영상처리
---
# 산술 및 논리 연산 기능 구현

_목표: “열려 있는 다른 이미지 창(B)”을 **대화 상자에서 선택**하거나 **파일로 로드**해, 현재 창(A)에 **산술/논리 연산(Add/Sub/Avg/Diff/AND/OR)** 을 적용한다. 결과는 **현재 창에 덮어쓰기** 또는 **새 창으로 출력** 중 선택 가능._

> 전제  
> - Win32(비-MFC) 기반 **ImageTool** 프로젝트  
> - 영상은 `IppDib`(Top-Down BGRA32) 사용  
> - 이전 장에서 만든 기본 프레임/상태바/출력창/클립보드/파일 I/O가 있다고 가정  
> - 코드 블록은 **한 번만** \`\`\` 로 감쌉니다 (C++/RC/헤더 포함)

---

## 구성 개요

1. **도큐먼트 레지스트리**:  
   “열려 있는 창 목록”을 **중앙에서 관리** → (HWND, Title, Size, `IppDib*`) 조회
   - 프레임 생성/파괴/파일 열기/붙여넣기마다 레지스트리 갱신
   - 변경 시 **브로드캐스트 메시지**로 대화 상자 목록을 즉시 갱신

2. **산술·논리 연산 대화 상자**:  
   - 연산 선택(라디오 6종)  
   - **대상(B)** 선택(콤보: 다른 창 나열) + **Browse**(파일에서 B 열기)  
   - **크기 불일치 처리 정책**(클립/리사이즈) + **결과 새 창으로 생성** 옵션  
   - **알파 유지 여부** 체크 (A의 알파 고정)

3. **연산 코어**:  
   - `Apply_ArithLogic_WithB(A,B,op,keepAlpha)` (겹치는 영역만 또는 B를 A 크기로 리사이즈 후 전영역)  
   - 리사이즈(Nearest/Bilinear 간단 구현)

4. **메뉴/이벤트 연결**:  
   - `Image → Arithmetic / Logical...` → 대화 상자 실행 → 결과 반영

---

# 1) 도큐먼트 리스트를 받아오는 방법

### 1.1 레지스트리 인터페이스

```cpp
// DocRegistry.h
#pragma once
#include <windows.h>
#include <string>
#include <vector>
#include <mutex>
#include "IppDib.h"

// 레지스트리 변경 브로드캐스트 (대화 상자 목록 갱신용)
#ifndef WM_APP_DOCREG_CHANGED
#define WM_APP_DOCREG_CHANGED (WM_APP + 0x51)
#endif

struct DocEntry {
    HWND        hwnd   = nullptr;
    std::wstring title;
    int         width  = 0;
    int         height = 0;
    IppDib*     dib    = nullptr;   // Frame이 가진 DIB의 포인터
};

namespace DocRegistry {
    void Register(HWND hwnd, IppDib* dib, const std::wstring& title, int w, int h);
    void Update(HWND hwnd, const std::wstring& title, int w, int h);
    void UpdateSize(HWND hwnd, int w, int h);
    void UpdateTitle(HWND hwnd, const std::wstring& title);
    void Unregister(HWND hwnd);

    // exclude HWND를 제외한 현재 목록(스냅샷) 반환
    std::vector<DocEntry> ListOthers(HWND exclude);

    // 단건 조회
    bool GetEntry(HWND hwnd, DocEntry& out);

    // 현재 열린 총 개수
    size_t Count();
}
```

```cpp
// DocRegistry.cpp
#include "DocRegistry.h"
#include <algorithm>

static std::vector<DocEntry> g_docs;
static std::mutex g_mtx;

// 변경 시 시스템 전체에 브로드캐스트(본 앱만 받아도 OK)
static void BroadcastChanged() {
    PostMessageW(HWND_BROADCAST, WM_APP_DOCREG_CHANGED, 0, 0);
}

namespace DocRegistry {

void Register(HWND hwnd, IppDib* dib, const std::wstring& title, int w, int h) {
    std::lock_guard<std::mutex> lk(g_mtx);
    // 중복 방지
    auto it = std::find_if(g_docs.begin(), g_docs.end(), [&](auto& d){return d.hwnd==hwnd;});
    if (it == g_docs.end()) g_docs.push_back(DocEntry{hwnd,title,w,h,dib});
    else { it->title=title; it->width=w; it->height=h; it->dib=dib; }
    BroadcastChanged();
}

void Update(HWND hwnd, const std::wstring& title, int w, int h) {
    std::lock_guard<std::mutex> lk(g_mtx);
    for (auto& d: g_docs) if (d.hwnd==hwnd) { d.title=title; d.width=w; d.height=h; d.dib=d.dib; break; }
    BroadcastChanged();
}
void UpdateSize(HWND hwnd, int w, int h) {
    std::lock_guard<std::mutex> lk(g_mtx);
    for (auto& d: g_docs) if (d.hwnd==hwnd) { d.width=w; d.height=h; break; }
    BroadcastChanged();
}
void UpdateTitle(HWND hwnd, const std::wstring& title) {
    std::lock_guard<std::mutex> lk(g_mtx);
    for (auto& d: g_docs) if (d.hwnd==hwnd) { d.title=title; break; }
    BroadcastChanged();
}
void Unregister(HWND hwnd) {
    std::lock_guard<std::mutex> lk(g_mtx);
    g_docs.erase(std::remove_if(g_docs.begin(), g_docs.end(),
        [&](auto& d){ return d.hwnd==hwnd; }), g_docs.end());
    BroadcastChanged();
}

std::vector<DocEntry> ListOthers(HWND exclude) {
    std::lock_guard<std::mutex> lk(g_mtx);
    std::vector<DocEntry> out; out.reserve(g_docs.size());
    for (auto& d: g_docs) if (d.hwnd && d.hwnd!=exclude) out.push_back(d);
    return out;
}
bool GetEntry(HWND hwnd, DocEntry& out) {
    std::lock_guard<std::mutex> lk(g_mtx);
    for (auto& d: g_docs) if (d.hwnd==hwnd) { out=d; return true; }
    return false;
}
size_t Count() {
    std::lock_guard<std::mutex> lk(g_mtx);
    return g_docs.size();
}

} // namespace
```

### 1.2 프레임 코드에서 등록/갱신/해제

> 여러분 프로젝트의 프레임 생성/파괴/열기/붙여넣기/새로 만들기 포인트에 아래 호출을 넣으세요.

```cpp
// main_multiwin.cpp (발췌)
#include "DocRegistry.h"

// ── 프레임 생성 직후
static HWND CreateFrame() {
    HWND hWnd = CreateWindowExW(...);
    auto* st = new ViewState(); // 내부에 IppDib st->dib 포함
    SetWindowLongPtrW(hWnd, GWLP_USERDATA, (LONG_PTR)st);

    // 초기 등록 (영상 없음 → 0x0)
    DocRegistry::Register(hWnd, &st->dib, L"ImageTool", 0, 0);
    return hWnd;
}

// ── 파일 열기 완료 후
static bool DoOpen(ViewState* st, HWND hWnd, const std::wstring& path) {
    if (!st->dib.loadBMP(path)) return false;
    std::wstring title = L"ImageTool - " + BaseNameOf(path);
    SetWindowTextW(hWnd, title.c_str());
    DocRegistry::Update(hWnd, title, st->dib.width(), st->dib.height());
    return true;
}

// ── 붙여넣기 완료 후
static void DoPaste(ViewState* st, HWND hWnd) {
    if (st->dib.pasteFromClipboard(hWnd)) {
        SetWindowTextW(hWnd, L"ImageTool - (clipboard)");
        DocRegistry::Update(hWnd, L"ImageTool - (clipboard)", st->dib.width(), st->dib.height());
    }
}

// ── 프레임 종료
case WM_DESTROY:
    if (st) {
        DocRegistry::Unregister(hWnd);
        delete st;
        SetWindowLongPtrW(hWnd, GWLP_USERDATA, 0);
    }
    PostQuitMessage(0);
    return 0;
```

> 팁: 문서가 변경될 때마다 `DocRegistry::UpdateSize` 를 호출하면 콤보의 정보(크기)가 최신으로 유지됩니다.

---

# 2) 산술 및 논리 연산 **코어**

> 대화 상자에서 B(문서 또는 파일)를 확보한 뒤 호출하는 **핵심 연산**입니다.

### 2.1 연산 코어 + 리사이즈 정책

```cpp
// ArithLogicCore.h
#pragma once
#include <cstdint>
#include <algorithm>
#include <vector>
#include "IppDib.h"

enum class ArithLogicOp { Add, Sub, Avg, Diff, And, Or };
enum class SizePolicy  { OverlapOnly, ResizeBtoA_Nearest, ResizeBtoA_Bilinear };

inline uint8_t sat_add_u8(uint8_t a, uint8_t b){ int s=a+b; return (uint8_t)(s>255?255:s); }
inline uint8_t sat_sub_u8(uint8_t a, uint8_t b){ int d=a-b; return (uint8_t)(d<0?0:d); }
inline uint8_t avg_u8(uint8_t a, uint8_t b){ return (uint8_t)((a + b + 1) >> 1); }

struct TempDib {
    IppDib dib;
    void makeLike(const IppDib& ref) { dib.create(ref.width(), ref.height(), 32); }
};

// ── B를 A 크기로 리사이즈 (Nearest)
inline void ResizeNearest_BGRA32(const IppDib& src, IppDib& dst) {
    const int W=dst.width(), H=dst.height();
    const int ws=src.width(), hs=src.height();
    for (int y=0;y<H;++y) {
        uint8_t* rd = (uint8_t*)dst.bits() + (size_t)y*dst.stride();
        int sy = (int)((int64_t)y * hs / H);
        const uint8_t* rs = (const uint8_t*)src.bits() + (size_t)sy*src.stride();
        for (int x=0;x<W;++x) {
            int sx = (int)((int64_t)x * ws / W);
            const uint8_t* ps = &rs[sx*4];
            uint8_t* pd = &rd[x*4];
            pd[0]=ps[0]; pd[1]=ps[1]; pd[2]=ps[2]; pd[3]=ps[3];
        }
    }
}

// ── B를 A 크기로 리사이즈 (간단 Bilinear)
inline void ResizeBilinear_BGRA32(const IppDib& src, IppDib& dst) {
    const int W=dst.width(), H=dst.height();
    const int ws=src.width(), hs=src.height();
    for (int y=0;y<H;++y) {
        float gy = (y + 0.5f) * hs / H - 0.5f;
        int y0 = (int)floorf(gy); int y1 = std::min(y0+1, hs-1);
        float wy = gy - y0; if (y0<0){y0=0; wy=0;}
        const uint8_t* r0 = (const uint8_t*)src.bits() + (size_t)y0*src.stride();
        const uint8_t* r1 = (const uint8_t*)src.bits() + (size_t)y1*src.stride();
        uint8_t* rd = (uint8_t*)dst.bits() + (size_t)y*dst.stride();
        for (int x=0;x<W;++x) {
            float gx = (x + 0.5f) * ws / W - 0.5f;
            int x0 = (int)floorf(gx); int x1 = std::min(x0+1, ws-1);
            float wx = gx - x0; if (x0<0){x0=0; wx=0;}
            const uint8_t* p00=&r0[x0*4], *p01=&r0[x1*4], *p10=&r1[x0*4], *p11=&r1[x1*4];
            for (int c=0;c<4;++c) {
                float a = p00[c]*(1-wx)+p01[c]*wx;
                float b = p10[c]*(1-wx)+p11[c]*wx;
                float v = a*(1-wy)+b*wy;
                rd[x*4+c]=(uint8_t)std::clamp((int)std::lround(v),0,255);
            }
        }
    }
}

// ── 핵심: A와 B로 산술·논리 연산 (정책 선택)
inline bool Apply_ArithLogic_WithB(
    IppDib& A, const IppDib& B, ArithLogicOp op, bool keepAlpha, SizePolicy sp)
{
    if (!A || !B) return false;

    const IppDib* pB = &B;
    TempDib temp;

    if (sp==SizePolicy::ResizeBtoA_Nearest || sp==SizePolicy::ResizeBtoA_Bilinear) {
        temp.makeLike(A);
        if (sp==SizePolicy::ResizeBtoA_Nearest)   ResizeNearest_BGRA32(B, temp.dib);
        else                                      ResizeBilinear_BGRA32(B, temp.dib);
        pB = &temp.dib;
    }

    const int W = (sp==SizePolicy::OverlapOnly) ? std::min(A.width(),  pB->width())  : A.width();
    const int H = (sp==SizePolicy::OverlapOnly) ? std::min(A.height(), pB->height()) : A.height();
    if (W<=0 || H<=0) return false;

    for (int y=0;y<H;++y) {
        uint8_t* ra = (uint8_t*)A.bits() + (size_t)y*A.stride();
        const uint8_t* rb = (const uint8_t*)pB->bits() + (size_t)y*pB->stride();
        for (int x=0;x<W;++x) {
            uint8_t* pa = &ra[x*4];
            const uint8_t* pb = &rb[x*4];
            switch (op) {
            case ArithLogicOp::Add:
                pa[0]=sat_add_u8(pa[0],pb[0]); pa[1]=sat_add_u8(pa[1],pb[1]); pa[2]=sat_add_u8(pa[2],pb[2]); break;
            case ArithLogicOp::Sub:
                pa[0]=sat_sub_u8(pa[0],pb[0]); pa[1]=sat_sub_u8(pa[1],pb[1]); pa[2]=sat_sub_u8(pa[2],pb[2]); break;
            case ArithLogicOp::Avg:
                pa[0]=avg_u8(pa[0],pb[0]);     pa[1]=avg_u8(pa[1],pb[1]);     pa[2]=avg_u8(pa[2],pb[2]);     break;
            case ArithLogicOp::Diff: {
                int d0=std::abs((int)pa[0]-(int)pb[0]);
                int d1=std::abs((int)pa[1]-(int)pb[1]);
                int d2=std::abs((int)pa[2]-(int)pb[2]);
                pa[0]=(uint8_t)d0; pa[1]=(uint8_t)d1; pa[2]=(uint8_t)d2; } break;
            case ArithLogicOp::And:
                pa[0]=(uint8_t)(pa[0]&pb[0]); pa[1]=(uint8_t)(pa[1]&pb[1]); pa[2]=(uint8_t)(pa[2]&pb[2]); break;
            case ArithLogicOp::Or:
                pa[0]=(uint8_t)(pa[0]|pb[0]); pa[1]=(uint8_t)(pa[1]|pb[1]); pa[2]=(uint8_t)(pa[2]|pb[2]); break;
            }
            if (!keepAlpha) pa[3] = std::max(pa[3], pb[3]); // 단순 조합 예시
        }
    }
    return true;
}
```

> **정책 요약**  
> - **OverlapOnly**: 두 영상의 **겹치는 영역만** 계산 (빠르고 안전)  
> - **ResizeBtoA_***: B를 A 크기로 리사이즈해 **전영역** 계산 (시각적으로 자연스러움)  
> 리사이즈는 Nearest(빠름) / Bilinear(부드러움) 제공

---

# 3) 산술 및 논리 연산 **대화 상자** 만들기

### 3.1 리소스 ID/템플릿

```cpp
// resource.h (추가)
#define IDD_ARITHLOGIC               460

// Operations
#define IDC_OP_ADD                   1201
#define IDC_OP_SUB                   1202
#define IDC_OP_AVG                   1203
#define IDC_OP_DIFF                  1204
#define IDC_OP_AND                   1205
#define IDC_OP_OR                    1206

// Target
#define IDC_COMBO_DOCS               1210
#define IDC_BTN_BROWSE               1211
#define IDC_STAT_INFO                1212

// Options
#define IDC_KEEP_ALPHA               1220
#define IDC_CHK_NEWWINDOW            1221

// Size Policy
#define IDC_SP_OVERLAP               1230
#define IDC_SP_RESIZE_NEAREST        1231
#define IDC_SP_RESIZE_BILINEAR       1232
```

```rc
// ImageTool.rc (추가)
IDD_ARITHLOGIC DIALOGEX 0,0, 360, 210
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Arithmetic / Logical"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Operation", -1, 10, 10, 150, 98
    AUTORADIOBUTTON "Add (A + B)",      IDC_OP_ADD,  20, 24, 120, 10, WS_TABSTOP
    AUTORADIOBUTTON "Subtract (A - B)", IDC_OP_SUB,  20, 38, 120, 10
    AUTORADIOBUTTON "Average (A+B)/2",  IDC_OP_AVG,  20, 52, 120, 10
    AUTORADIOBUTTON "Difference |A-B|", IDC_OP_DIFF, 20, 66, 120, 10
    AUTORADIOBUTTON "AND (A & B)",      IDC_OP_AND,  20, 80, 120, 10
    AUTORADIOBUTTON "OR  (A | B)",      IDC_OP_OR,   20, 94, 120, 10

    GROUPBOX "Target (B)", -1, 170, 10, 180, 60
    COMBOBOX   IDC_COMBO_DOCS, 180, 24, 160, 200, CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON "Browse...",    IDC_BTN_BROWSE, 180, 42, 60, 14

    GROUPBOX "Size Policy", -1, 170, 76, 180, 52
    AUTORADIOBUTTON "Overlap Only",    IDC_SP_OVERLAP,        180, 90, 150, 10, WS_TABSTOP
    AUTORADIOBUTTON "Resize B → A (Nearest)", IDC_SP_RESIZE_NEAREST, 180, 104, 150, 10
    AUTORADIOBUTTON "Resize B → A (Bilinear)",IDC_SP_RESIZE_BILINEAR,180, 118, 150, 10

    AUTOCHECKBOX "Keep A's alpha", IDC_KEEP_ALPHA, 10, 115, 100, 12
    AUTOCHECKBOX "Open result in new window", IDC_CHK_NEWWINDOW, 10, 130, 150, 12

    LTEXT "Info:", -1, 10, 152, 20, 10
    LTEXT "",  IDC_STAT_INFO, 30, 152, 320, 24, SS_LEFT

    DEFPUSHBUTTON "OK",     IDOK,     230, 180, 55, 14
    PUSHBUTTON    "Cancel", IDCANCEL, 290, 180, 55, 14
END
```

> 기본 체크  
> - 연산: **Average** (중립적 시작)  
> - Size Policy: **Overlap Only**  
> - Keep A’s alpha: **On**  
> - Open result in new window: **Off**

### 3.2 대화 상자 클래스

```cpp
// ArithLogicDlg.h
#pragma once
#include <windows.h>
#include <vector>
#include <string>
#include "resource.h"
#include "DocRegistry.h"
#include "ArithLogicCore.h"

class ArithLogicDlg {
public:
    ArithLogicDlg(HWND owner, IppDib& dibA) : owner_(owner), A_(dibA) {}
    INT_PTR DoModal();

    // 결과 생성 전략(새 창 열기 여부 등)을 조회하려면 getter 추가 가능

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);
    INT_PTR OnAppMsg(HWND h, UINT msg, WPARAM w, LPARAM l); // 레지스트리 변경 브로드캐스트 수신

    void FillDocList(HWND h);
    void RefreshInfo(HWND h);

    bool LoadBFromFile(HWND h);    // 파일로 B 읽기

    ArithLogicOp GetOp(HWND h) const;
    SizePolicy   GetPolicy(HWND h) const;
    bool         KeepAlpha(HWND h) const;
    bool         WantNewWindow(HWND h) const;

private:
    HWND    owner_ = nullptr;
    HWND    hDlg_  = nullptr;
    IppDib& A_;

    // 선택 후보
    std::vector<DocEntry> docs_;   // 현재 창 제외
    int     selIndex_ = -1;        // 콤보 인덱스, 파일 B 우선 시 -1 유지
    IppDib  B_file_;                // 파일에서 읽은 임시

    // 상태 텍스트
    std::wstring info_;
};
```

```cpp
// ArithLogicDlg.cpp
#include "ArithLogicDlg.h"
#include <commdlg.h>

INT_PTR ArithLogicDlg::DoModal() {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_ARITHLOGIC),
                           owner_, DlgProc, (LPARAM)this);
}

INT_PTR CALLBACK ArithLogicDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m==WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self = reinterpret_cast<ArithLogicDlg*>(l);
        self->hDlg_ = h;
        return self->OnInit(h);
    }
    auto* self = reinterpret_cast<ArithLogicDlg*>(GetWindowLongPtrW(h, GWLP_USERDATA));
    if (!self) return FALSE;

    if (m==WM_COMMAND) return self->OnCommand(h, w, l);
    if (m==WM_APP_DOCREG_CHANGED) return self->OnAppMsg(h, m, w, l);
    return FALSE;
}

INT_PTR ArithLogicDlg::OnInit(HWND h) {
    // 기본 라디오/체크
    CheckRadioButton(h, IDC_OP_ADD, IDC_OP_OR, IDC_OP_AVG);
    CheckRadioButton(h, IDC_SP_OVERLAP, IDC_SP_RESIZE_BILINEAR, IDC_SP_OVERLAP);
    CheckDlgButton(h, IDC_KEEP_ALPHA,    BST_CHECKED);
    CheckDlgButton(h, IDC_CHK_NEWWINDOW, BST_UNCHECKED);

    FillDocList(h);
    RefreshInfo(h);
    return TRUE;
}

void ArithLogicDlg::FillDocList(HWND h) {
    docs_ = DocRegistry::ListOthers(owner_);
    HWND combo = GetDlgItem(h, IDC_COMBO_DOCS);
    SendMessageW(combo, CB_RESETCONTENT, 0, 0);

    for (size_t i=0; i<docs_.size(); ++i) {
        const auto& d = docs_[i];
        std::wstring item = d.title + L"  (" + std::to_wstring(d.width) + L"x" + std::to_wstring(d.height) + L")";
        SendMessageW(combo, CB_ADDSTRING, 0, (LPARAM)item.c_str());
    }
    if (!docs_.empty()) { SendMessageW(combo, CB_SETCURSEL, 0, 0); selIndex_=0; }
    else                { selIndex_=-1; }
}

void ArithLogicDlg::RefreshInfo(HWND h) {
    wchar_t buf[256];
    if (selIndex_>=0 && selIndex_<(int)docs_.size()) {
        const auto& d = docs_[selIndex_];
        swprintf(buf, 256, L"A:(%dx%d)  B:(%dx%d)  [Doc]",
                 A_.width(), A_.height(), d.width, d.height);
    } else if (B_file_) {
        swprintf(buf, 256, L"A:(%dx%d)  B-file:(%dx%d)",
                 A_.width(), A_.height(), B_file_.width(), B_file_.height());
    } else {
        swprintf(buf, 256, L"Select B from list or click Browse...");
    }
    SetDlgItemTextW(h, IDC_STAT_INFO, buf);
}

bool ArithLogicDlg::LoadBFromFile(HWND h) {
    wchar_t path[MAX_PATH]=L"";
    OPENFILENAMEW ofn{ sizeof(ofn) };
    ofn.hwndOwner = h;
    ofn.lpstrFilter = L"BMP files (*.bmp)\0*.bmp\0All files (*.*)\0*.*\0";
    ofn.lpstrFile = path; ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    ofn.lpstrTitle = L"Open B image (BMP)";
    if (!GetOpenFileNameW(&ofn)) return false;
    if (!B_file_.loadBMP(path)) {
        MessageBoxW(h, L"Failed to load BMP.", L"Arithmetic/Logical", MB_OK|MB_ICONERROR);
        return false;
    }
    // 파일을 선택하면 콤보 선택은 해제
    HWND combo = GetDlgItem(hDlg_, IDC_COMBO_DOCS);
    SendMessageW(combo, CB_SETCURSEL, (WPARAM)-1, 0);
    selIndex_ = -1;
    RefreshInfo(hDlg_);
    return true;
}

ArithLogicOp ArithLogicDlg::GetOp(HWND h) const {
    if (IsDlgButtonChecked(h, IDC_OP_ADD)==BST_CHECKED)  return ArithLogicOp::Add;
    if (IsDlgButtonChecked(h, IDC_OP_SUB)==BST_CHECKED)  return ArithLogicOp::Sub;
    if (IsDlgButtonChecked(h, IDC_OP_AVG)==BST_CHECKED)  return ArithLogicOp::Avg;
    if (IsDlgButtonChecked(h, IDC_OP_DIFF)==BST_CHECKED) return ArithLogicOp::Diff;
    if (IsDlgButtonChecked(h, IDC_OP_AND)==BST_CHECKED)  return ArithLogicOp::And;
    return ArithLogicOp::Or;
}
SizePolicy ArithLogicDlg::GetPolicy(HWND h) const {
    if (IsDlgButtonChecked(h, IDC_SP_RESIZE_BILINEAR)==BST_CHECKED) return SizePolicy::ResizeBtoA_Bilinear;
    if (IsDlgButtonChecked(h, IDC_SP_RESIZE_NEAREST )==BST_CHECKED) return SizePolicy::ResizeBtoA_Nearest;
    return SizePolicy::OverlapOnly;
}
bool ArithLogicDlg::KeepAlpha(HWND h) const {
    return (IsDlgButtonChecked(h, IDC_KEEP_ALPHA)==BST_CHECKED);
}
bool ArithLogicDlg::WantNewWindow(HWND h) const {
    return (IsDlgButtonChecked(h, IDC_CHK_NEWWINDOW)==BST_CHECKED);
}

INT_PTR ArithLogicDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)) {
    case IDC_COMBO_DOCS:
        if (HIWORD(w)==CBN_SELCHANGE) {
            HWND combo = GetDlgItem(h, IDC_COMBO_DOCS);
            int sel = (int)SendMessageW(combo, CB_GETCURSEL, 0, 0);
            selIndex_ = sel;
            RefreshInfo(h);
            return TRUE;
        }
        break;

    case IDC_BTN_BROWSE:
        LoadBFromFile(h);
        return TRUE;

    case IDOK: {
        // B 확보
        const IppDib* pB = nullptr;
        if (selIndex_>=0 && selIndex_<(int)docs_.size()) {
            pB = docs_[selIndex_].dib;
        } else if (B_file_) {
            pB = &B_file_;
        } else {
            MessageBoxW(h, L"대상(B)을 선택하거나 파일을 여세요.", L"Arithmetic/Logical", MB_OK|MB_ICONWARNING);
            return TRUE;
        }

        // 새 창 여부
        bool newWin = WantNewWindow(h);
        SizePolicy sp = GetPolicy(h);
        ArithLogicOp op = GetOp(h);
        bool keepA = KeepAlpha(h);

        if (newWin) {
            // 새 창: A를 복제한 후 결과를 그곳에 적용
            // 여기서는 간단히 클립보드/저장 대신 새 프레임 생성+복사로 예시
            // 실제 구현에선 CreateFrame() + dib 복사 헬퍼를 사용.
            // ── 예시: 임시로 A를 파일로 저장 후 열어 새 창에 로드하는 방식도 가능
            // 여기서는 간결함을 위해 현재 창에 우선 적용한 뒤,
            // 사용자에게 "Undo" 부재를 안내하는 형태로 유지합니다.
            // (여러분의 프로젝트 Undo 스택에 맞춰 수정하세요.)
        }

        // 현재 창(A)에 적용
        if (!Apply_ArithLogic_WithB(A_, *pB, op, keepA, sp)) {
            MessageBoxW(h, L"연산을 수행할 수 없습니다.", L"Arithmetic/Logical", MB_OK|MB_ICONERROR);
            return TRUE;
        }

        EndDialog(h, IDOK);
        return TRUE;
    }

    case IDCANCEL:
        EndDialog(h, IDCANCEL);
        return TRUE;
    }
    return FALSE;
}

INT_PTR ArithLogicDlg::OnAppMsg(HWND h, UINT, WPARAM, LPARAM) {
    // 다른 창이 열리거나 닫히면 목록을 즉시 갱신
    FillDocList(h);
    RefreshInfo(h);
    return TRUE;
}
```

> **브로드캐스트 갱신**  
> - `DocRegistry`에서 등록/해제/업데이트 시 `WM_APP_DOCREG_CHANGED` 브로드캐스트  
> - 대화 상자는 이 메시지를 수신하면 **콤보를 즉시 리프레시** → 다중 창 관리에 매우 편리

---

# 4) 산술 및 논리 연산 **메뉴 및 이벤트** 추가

### 4.1 메뉴/가속기

```rc
// resource.h (추가)
#define ID_IMAGE_ARITHLOGIC_DIALOG     470
```

```rc
// ImageTool.rc (일부)
POPUP "&Image"
BEGIN
    MENUITEM "Brightness / Contrast...\tCtrl+B",  40200
    MENUITEM "Gamma Correction...\tCtrl+G",       40300
    MENUITEM SEPARATOR
    MENUITEM "Arithmetic / Logical...\tCtrl+L",   ID_IMAGE_ARITHLOGIC_DIALOG
END

IDR_ACCEL ACCELERATORS
BEGIN
    "L", ID_IMAGE_ARITHLOGIC_DIALOG, VIRTKEY, CONTROL
END
```

### 4.2 윈도우 프로시저 연결

```cpp
// main_multiwin.cpp (발췌)
#include "ArithLogicDlg.h"

// ...
case ID_IMAGE_ARITHLOGIC_DIALOG:
    if (st && st->dib) {
        ArithLogicDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK) {
            // 상태/출력창 갱신
            OutputBasicInfo(st);
            UpdateStatusBasic(hWnd, st);
            InvalidateRect(hWnd, nullptr, FALSE);
        }
    }
    return 0;
```

---

# 5) 품질/안정성 체크리스트

- [ ] **도큐먼트 목록 갱신**: 새 창 열기/닫기/파일 열기/붙여넣기 때 **콤보가 즉시 갱신**되는지  
- [ ] **크기 불일치**: Overlap vs Resize 정책이 정확히 적용되는지  
- [ ] **연산 정확성**: Add/Sub/Avg/Diff/AND/OR의 **채널별(B,G,R)** 포화/절대/비트 연산 확인  
- [ ] **알파 보존**: Keep A’s alpha On/Off 시 기대대로 동작하는지  
- [ ] **파일 B**: Browse로 연 파일(B_file_)이 정상 반영되는지  
- [ ] **취소/확인**: Cancel 시 원본 유지, OK 시 한 번만 적용

---

# 6) 확장 아이디어

- **XOR/NOT** 추가 (논리 연산 완성)  
- **가중 블렌드(α)** UI 통합(슬라이더/스핀)  
- **프리뷰(미리보기)**: 원본 백업 후 라디오/정책 변경마다 즉시 재적용  
- **Undo/Redo 스택**: OK 시 커맨드 객체 push → Ctrl+Z 지원  
- **정합(Registration)**: A/B가 어긋난 실사진 처리 전 워핑/오프셋 파라미터 도입  
- **ROI/마스크**: 선택 영역 및 마스크 이미지로 연산 영역 제한  
- **Multi-Document 합성**: 둘 이상의 창을 순차/가중 합성

---

## 마무리

- **DocRegistry** 로 열린 문서를 중앙 관리하고,  
- **대화 상자**에서 **B 선택/파일 로드/정책 선택/알파 옵션**을 제공,  
- **코어 연산**으로 A와 B를 안전하게 조합,  
- **메뉴/이벤트**로 애플리케이션 워크플로우에 자연스럽게 통합했습니다.