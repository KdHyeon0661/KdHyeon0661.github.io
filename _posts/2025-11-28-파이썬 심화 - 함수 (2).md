---
layout: post
title: 파이썬 심화 - 함수 (2)
date: 2025-11-28 23:30:23 +0900
category: 파이썬 심화
---
# 함수 (2)

함수는 파이썬 프로그래밍의 핵심 구성 요소입니다. 기본적인 함수 정의부터 고급 인자 처리 기법까지, 효율적이고 유연한 함수 설계 방법을 심층적으로 살펴보겠습니다.

## 기본 인자를 사용하는 함수 정의: 완벽 가이드

기본 인자는 함수의 유연성을 크게 향상시키는 강력한 기능입니다. 적절히 사용하면 코드의 재사용성을 높이고 인터페이스를 단순화할 수 있습니다.

### 기본 인자의 기본 개념과 사용법

```python
# 1. 기본적인 기본 인자 사용
def create_user_profile(name, age=25, city="서울", is_active=True):
    """
    사용자 프로필 생성 함수
    
    Args:
        name: 사용자 이름 (필수)
        age: 나이 (기본값: 25)
        city: 도시 (기본값: "서울")
        is_active: 활성 상태 (기본값: True)
    
    Returns:
        사용자 프로필 딕셔너리
    """
    return {
        'name': name,
        'age': age,
        'city': city,
        'is_active': is_active,
        'created_at': '2024-01-15'  # 실제로는 datetime.now() 사용
    }

# 다양한 방식으로 함수 호출
print("1. 기본 인자 사용 예제:")
print("=" * 60)

# 필수 인자만 사용
profile1 = create_user_profile("김철수")
print(f"기본 호출: {profile1}")

# 일부 기본 인자 재정의
profile2 = create_user_profile("이영희", age=30, city="부산")
print(f"일부 재정의: {profile2}")

# 모든 인자 명시적 지정
profile3 = create_user_profile(name="박지민", age=35, city="대구", is_active=False)
print(f"모든 인자 명시: {profile3}")

# 키워드 인자 순서 변경
profile4 = create_user_profile("최윤호", city="인천", age=40)
print(f"키워드 순서 변경: {profile4}")
```

### 기본 인자 사용 시 주의사항과 함정

```python
print("\n2. 기본 인자 사용 시 주의사항:")
print("=" * 60)

# 주의 1: 가변 객체를 기본값으로 사용하지 말 것
def problematic_function(items=[]):  # ❌ 위험한 코드
    """가변 객체를 기본값으로 사용하는 잘못된 예"""
    items.append("new_item")
    return items

# 여러 번 호출 시 문제 발생
print("잘못된 예 (가변 객체 기본값):")
result1 = problematic_function()
print(f"첫 번째 호출: {result1}")  # ['new_item']

result2 = problematic_function()
print(f"두 번째 호출: {result2}")  # ['new_item', 'new_item'] - 의도하지 않은 결과!

# 올바른 방법
def correct_function(items=None):
    """가변 객체 기본값의 올바른 사용법"""
    if items is None:
        items = []
    items.append("new_item")
    return items

print("\n올바른 예 (None을 기본값으로):")
result1 = correct_function()
print(f"첫 번째 호출: {result1}")  # ['new_item']

result2 = correct_function()
print(f"두 번째 호출: {result2}")  # ['new_item'] - 정상

# 주의 2: 기본값은 함수 정의 시점에 평가됨
import datetime

def create_timestamp(message, timestamp=datetime.datetime.now()):
    """잘못된 타임스탬프 생성 (기본값이 고정됨)"""
    return f"[{timestamp}] {message}"

print("\n잘못된 타임스탬프 예제:")
msg1 = create_timestamp("첫 번째 메시지")
print(f"메시지 1: {msg1}")

# 잠시 대기
import time
time.sleep(2)

msg2 = create_timestamp("두 번째 메시지")
print(f"메시지 2: {msg2}")  # 타임스탬프가 동일함!

# 올바른 방법
def create_timestamp_correct(message, timestamp=None):
    """올바른 타임스탬프 생성"""
    if timestamp is None:
        timestamp = datetime.datetime.now()
    return f"[{timestamp}] {message}"

print("\n올바른 타임스탬프 예제:")
msg1 = create_timestamp_correct("첫 번째 메시지")
print(f"메시지 1: {msg1}")

time.sleep(2)
msg2 = create_timestamp_correct("두 번째 메시지")
print(f"메시지 2: {msg2}")  # 타임스탬프가 다름!
```

### 고급: 동적 기본 인자와 조건부 기본값

```python
print("\n3. 동적 기본 인자 패턴:")
print("=" * 60)

# 패턴 1: 다른 인자에 의존하는 기본값
def calculate_discount(price, discount_rate=None, member_level="basic"):
    """
    할인율 계산 (회원 등급에 따라 기본 할인율 변경)
    
    Args:
        price: 원가
        discount_rate: 할인율 (None이면 등급별 기본값 사용)
        member_level: 회원 등급
    
    Returns:
        할인적용 가격
    """
    # 등급별 기본 할인율
    default_rates = {
        'basic': 0.05,      # 5%
        'silver': 0.10,     # 10%
        'gold': 0.15,       # 15%
        'platinum': 0.20,   # 20%
    }
    
    if discount_rate is None:
        discount_rate = default_rates.get(member_level, 0.05)
    
    discounted_price = price * (1 - discount_rate)
    
    return {
        'original_price': price,
        'discount_rate': discount_rate,
        'discounted_price': discounted_price,
        'member_level': member_level,
        'saved_amount': price - discounted_price
    }

# 테스트
print("동적 할인율 계산:")
order1 = calculate_discount(100000, member_level="gold")
print(f"골드 회원: {order1}")

order2 = calculate_discount(100000, discount_rate=0.25, member_level="basic")
print(f"특별 할인: {order2}")

# 패턴 2: 환경 설정 기반 기본값
import os

def get_api_config(api_key=None, timeout=None, retries=None):
    """
    API 설정을 환경변수에서 읽어 기본값 설정
    
    Args:
        api_key: API 키
        timeout: 타임아웃 (초)
        retries: 재시도 횟수
    
    Returns:
        API 설정 딕셔너리
    """
    # 환경변수에서 기본값 읽기
    config = {
        'api_key': api_key or os.environ.get('API_KEY', 'default_key'),
        'timeout': timeout or int(os.environ.get('API_TIMEOUT', 30)),
        'retries': retries or int(os.environ.get('API_RETRIES', 3)),
        'base_url': os.environ.get('API_BASE_URL', 'https://api.example.com')
    }
    
    return config

# 환경변수 설정 (시뮬레이션)
os.environ['API_KEY'] = 'secret_123'
os.environ['API_TIMEOUT'] = '60'

print("\n환경변수 기반 설정:")
config1 = get_api_config()  # 환경변수 사용
print(f"기본 설정: {config1}")

config2 = get_api_config(api_key='custom_key', timeout=120)  # 직접 지정
print(f"커스텀 설정: {config2}")

# 패턴 3: 복잡한 기본값 팩토리 함수
def create_complex_object(data=None, validator=None, formatter=None):
    """
    복잡한 객체 생성 (의존성 주입 패턴)
    
    Args:
        data: 입력 데이터
        validator: 검증 함수 (None이면 기본 검증기 사용)
        formatter: 포맷터 함수 (None이면 기본 포맷터 사용)
    
    Returns:
        처리된 데이터
    """
    # 기본 검증기
    if validator is None:
        def default_validator(d):
            """기본 데이터 검증기"""
            if not isinstance(d, dict):
                raise ValueError("데이터는 딕셔너리여야 합니다")
            if 'id' not in d:
                raise ValueError("데이터에 'id' 필드가 필요합니다")
            return True
    
    # 기본 포맷터
    if formatter is None:
        def default_formatter(d):
            """기본 데이터 포맷터"""
            return {
                'id': str(d.get('id', '')).upper(),
                'timestamp': datetime.datetime.now().isoformat(),
                'data': d
            }
    
    # 실제 검증과 포맷팅
    validator = validator or default_validator
    formatter = formatter or default_formatter
    
    if data is None:
        data = {}
    
    validator(data)
    return formatter(data)

print("\n팩토리 함수 패턴:")
result = create_complex_object({'id': 'user123', 'name': '김철수'})
print(f"결과: {result}")
```

### 실전 예제: 웹 API 클라이언트 구현

```python
import requests
import json
from typing import Optional, Dict, Any

class APIClient:
    """기본 인자를 활용한 웹 API 클라이언트"""
    
    def __init__(self, base_url: str, timeout: int = 30, 
                 retries: int = 3, verify_ssl: bool = True):
        """
        API 클라이언트 초기화
        
        Args:
            base_url: API 기본 URL
            timeout: 요청 타임아웃 (초)
            retries: 재시도 횟수
            verify_ssl: SSL 검증 여부
        """
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.retries = retries
        self.verify_ssl = verify_ssl
        self.session = requests.Session()
        
        # 기본 헤더 설정
        self.session.headers.update({
            'User-Agent': 'APIClient/1.0',
            'Accept': 'application/json',
            'Content-Type': 'application/json'
        })
    
    def request(self, method: str, endpoint: str, 
                params: Optional[Dict] = None,
                data: Optional[Any] = None,
                json_data: Optional[Dict] = None,
                headers: Optional[Dict] = None,
                auth: Optional[tuple] = None,
                timeout: Optional[int] = None) -> Dict:
        """
        API 요청 보내기 (풍부한 기본 인자 설정)
        
        Args:
            method: HTTP 메서드 (GET, POST 등)
            endpoint: API 엔드포인트
            params: URL 파라미터
            data: 요청 본문 (문자열 또는 bytes)
            json_data: JSON 요청 본문
            headers: 추가 헤더
            auth: 인증 정보 (username, password)
            timeout: 요청 타임아웃 (None이면 클래스 기본값 사용)
        
        Returns:
            API 응답 딕셔너리
        """
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        # 기본값 처리
        if timeout is None:
            timeout = self.timeout
        
        # 요청 헤더 병합
        request_headers = self.session.headers.copy()
        if headers:
            request_headers.update(headers)
        
        # 재시도 로직
        last_exception = None
        for attempt in range(self.retries):
            try:
                response = self.session.request(
                    method=method,
                    url=url,
                    params=params,
                    data=data,
                    json=json_data,
                    headers=request_headers,
                    auth=auth,
                    timeout=timeout,
                    verify=self.verify_ssl
                )
                
                # HTTP 오류 확인
                response.raise_for_status()
                
                # 응답 처리
                if response.headers.get('Content-Type', '').startswith('application/json'):
                    return response.json()
                else:
                    return {'text': response.text, 'status_code': response.status_code}
                    
            except requests.exceptions.RequestException as e:
                last_exception = e
                print(f"요청 실패 (시도 {attempt + 1}/{self.retries}): {e}")
                if attempt < self.retries - 1:
                    import time
                    time.sleep(1 * (attempt + 1))  # 지수 백오프
        
        # 모든 재시도 실패
        raise Exception(f"모든 재시도 실패: {last_exception}")
    
    # 편의 메서드들 (기본 인자 활용)
    def get(self, endpoint: str, params: Optional[Dict] = None, **kwargs) -> Dict:
        """GET 요청"""
        return self.request('GET', endpoint, params=params, **kwargs)
    
    def post(self, endpoint: str, json_data: Optional[Dict] = None, **kwargs) -> Dict:
        """POST 요청"""
        return self.request('POST', endpoint, json_data=json_data, **kwargs)
    
    def put(self, endpoint: str, json_data: Optional[Dict] = None, **kwargs) -> Dict:
        """PUT 요청"""
        return self.request('PUT', endpoint, json_data=json_data, **kwargs)
    
    def delete(self, endpoint: str, **kwargs) -> Dict:
        """DELETE 요청"""
        return self.request('DELETE', endpoint, **kwargs)

# 사용 예시
print("\n4. 실전 예제: API 클라이언트 사용")
print("=" * 60)

# 클라이언트 생성
client = APIClient(
    base_url="https://jsonplaceholder.typicode.com",
    timeout=10,
    retries=2
)

# 다양한 방식으로 호출
try:
    # 기본 GET 요청
    print("기본 GET 요청:")
    users = client.get("/users")
    print(f"사용자 수: {len(users)}")
    
    # 파라미터가 있는 GET 요청
    print("\n파라미터가 있는 GET 요청:")
    posts = client.get("/posts", params={'userId': 1})
    print(f"사용자 1의 게시물 수: {len(posts)}")
    
    # POST 요청 (JSON 데이터)
    print("\nPOST 요청:")
    new_post = client.post("/posts", json_data={
        'title': '테스트 게시물',
        'body': '이것은 테스트 게시물입니다.',
        'userId': 1
    })
    print(f"생성된 게시물 ID: {new_post.get('id')}")
    
    # 커스텀 헤더가 있는 요청
    print("\n커스텀 헤더가 있는 요청:")
    custom_request = client.get(
        "/posts/1",
        headers={'X-Custom-Header': 'my-value'},
        timeout=5  # 특정 요청에만 다른 타임아웃
    )
    print(f"게시물 제목: {custom_request.get('title')}")
    
except Exception as e:
    print(f"API 요청 실패: {e}")
```

## 이름 없는 함수와 인라인 함수 정의: 람다(lambda)의 모든 것

람다 함수는 간단한 함수를 한 줄로 정의할 수 있게 해주는 강력한 도구입니다. 하지만 남용할 경우 코드 가독성을 해칠 수 있으므로 적절한 사용법을 익혀야 합니다.

### 람다 함수의 기본 개념과 구문

```python
print("\n1. 람다 함수 기본 개념")
print("=" * 60)

# 기본 구문: lambda arguments: expression
# 일반 함수 정의와 비교

# 일반 함수
def add_regular(x, y):
    return x + y

# 람다 함수
add_lambda = lambda x, y: x + y

print("일반 함수 vs 람다 함수:")
print(f"add_regular(3, 5) = {add_regular(3, 5)}")
print(f"add_lambda(3, 5) = {add_lambda(3, 5)}")

# 다양한 람다 함수 예제
print("\n다양한 람다 함수 예제:")

# 1. 단일 인자
square = lambda x: x ** 2
print(f"square(5) = {square(5)}")

# 2. 인자 없는 람다
get_pi = lambda: 3.14159
print(f"get_pi() = {get_pi()}")

# 3. 다중 인자
multiply = lambda a, b, c: a * b * c
print(f"multiply(2, 3, 4) = {multiply(2, 3, 4)}")

# 4. 조건문 포함
is_even = lambda x: '짝수' if x % 2 == 0 else '홀수'
print(f"is_even(7) = {is_even(7)}")
print(f"is_even(10) = {is_even(10)}")

# 5. 문자열 처리
first_char = lambda s: s[0] if s else ''
print(f"first_char('Python') = {first_char('Python')}")

# 6. 튜플 반환
min_max = lambda a, b: (min(a, b), max(a, b))
print(f"min_max(10, 20) = {min_max(10, 20)}")
```

### 람다 함수의 실제 활용 사례

```python
print("\n2. 람다 함수의 실제 활용 사례")
print("=" * 60)

# 사례 1: sorted() 함수의 key 인자
students = [
    {'name': '김철수', 'score': 85},
    {'name': '이영희', 'score': 92},
    {'name': '박지민', 'score': 78},
    {'name': '최윤호', 'score': 88},
]

print("학생 성적 정렬:")
# 점수 기준 정렬 (내림차순)
students_by_score = sorted(students, key=lambda x: x['score'], reverse=True)
for s in students_by_score:
    print(f"  {s['name']}: {s['score']}점")

# 이름 기준 정렬
students_by_name = sorted(students, key=lambda x: x['name'])
print(f"\n이름순: {[s['name'] for s in students_by_name]}")

# 사례 2: filter() 함수와 함께 사용
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print("\n필터링 예제:")
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
odd_numbers = list(filter(lambda x: x % 2 != 0, numbers))
numbers_greater_than_5 = list(filter(lambda x: x > 5, numbers))

print(f"짝수: {even_numbers}")
print(f"홀수: {odd_numbers}")
print(f"5보다 큰 수: {numbers_greater_than_5}")

# 사례 3: map() 함수와 함께 사용
print("\n매핑 예제:")
squared = list(map(lambda x: x ** 2, numbers))
to_string = list(map(lambda x: f"숫자: {x}", numbers))
formatted_scores = list(map(lambda x: f"{x['name']}: {x['score']}점", students))

print(f"제곱: {squared}")
print(f"문자열 변환: {to_string[:3]}...")  # 처음 3개만 출력
print(f"성적 포맷팅: {formatted_scores}")

# 사례 4: reduce() 함수와 함께 사용 (Python 3에서는 functools에서 import)
from functools import reduce

print("\n리듀스 예제:")
product = reduce(lambda x, y: x * y, numbers)
concatenated = reduce(lambda x, y: f"{x},{y}", numbers)
max_number = reduce(lambda x, y: x if x > y else y, numbers)

print(f"1부터 10까지 곱: {product:,}")
print(f"문자열 연결: {concatenated}")
print(f"최대값: {max_number}")
```

### 고급: 람다 함수와 고차 함수 패턴

```python
print("\n3. 고급: 람다와 고차 함수 패턴")
print("=" * 60)

# 패턴 1: 함수 팩토리
def create_multiplier(factor):
    """인수를 곱하는 함수 생성"""
    return lambda x: x * factor

print("함수 팩토리 패턴:")
double = create_multiplier(2)
triple = create_multiplier(3)
half = create_multiplier(0.5)

print(f"double(10) = {double(10)}")
print(f"triple(10) = {triple(10)}")
print(f"half(10) = {half(10)}")

# 실제 활용: 세금 계산기
def create_tax_calculator(tax_rate):
    """세금 계산기 생성"""
    return lambda amount: amount * (1 + tax_rate)

vat_calculator = create_tax_calculator(0.1)  # 부가가치세 10%
print(f"\n부가가치세 계산 (10,000원): {vat_calculator(10000):,.0f}원")

# 패턴 2: 함수 컴포지션
def compose(*functions):
    """여러 함수를 합성하는 함수 생성"""
    return lambda x: reduce(lambda acc, f: f(acc), functions[::-1], x)

print("\n함수 컴포지션 패턴:")
add_one = lambda x: x + 1
multiply_by_two = lambda x: x * 2
square_func = lambda x: x ** 2

composed = compose(add_one, multiply_by_two, square_func)
print(f"compose(add_one, multiply_by_two, square)(3) = {composed(3)}")
# 계산: ((3^2) * 2) + 1 = (9 * 2) + 1 = 18 + 1 = 19

# 패턴 3: 조건부 함수 체인
def create_validator(*validators):
    """여러 검증기를 체인으로 연결"""
    return lambda value: all(validator(value) for validator in validators)

print("\n검증기 체인 패턴:")
is_positive = lambda x: x > 0
is_even_check = lambda x: x % 2 == 0
is_less_than_100 = lambda x: x < 100

number_validator = create_validator(is_positive, is_even_check, is_less_than_100)

test_numbers = [50, 101, -2, 99, 102]
for num in test_numbers:
    valid = number_validator(num)
    print(f"  {num:3} → {'유효' if valid else '무효'}")

# 패턴 4: 디버깅 래퍼
def with_logging(func):
    """함수 실행을 로깅하는 래퍼"""
    return lambda *args, **kwargs: (
        print(f"함수 {func.__name__} 호출: args={args}, kwargs={kwargs}"),
        func(*args, **kwargs)
    )[1]  # 튜플의 두 번째 요소 반환

print("\n로깅 래퍼 패턴:")
logged_add = with_logging(lambda x, y: x + y)
result = logged_add(3, 5)
print(f"결과: {result}")
```

### 람다 함수의 한계와 대안

```python
print("\n4. 람다 함수의 한계와 대안")
print("=" * 60)

# 한계 1: 복잡한 로직 표현 불가
print("한계 1: 복잡한 로직은 일반 함수가 나음")

# ❌ 나쁜 예: 이해하기 어려운 복잡한 람다
complex_lambda = lambda x: (x ** 2 if x > 0 else 0) if isinstance(x, (int, float)) else None

# ✅ 좋은 예: 일반 함수로 명확하게 표현
def process_number(x):
    """숫자 처리 함수"""
    if not isinstance(x, (int, float)):
        return None
    if x > 0:
        return x ** 2
    return 0

print(f"람다: complex_lambda(5) = {complex_lambda(5)}")
print(f"함수: process_number(5) = {process_number(5)}")

# 한계 2: 여러 줄의 코드 불가
print("\n한계 2: 여러 줄의 코드는 일반 함수 필요")

# ❌ 불가능: 람다에서 여러 줄의 코드
# multi_line_lambda = lambda x: 
#     result = x * 2
#     return result

# ✅ 가능: 일반 함수
def multi_line_function(x):
    """여러 줄의 로직"""
    result = x * 2
    result += 10
    return result

print(f"여러 줄 함수: multi_line_function(5) = {multi_line_function(5)}")

# 한계 3: 문서화(Docstring) 불가
print("\n한계 3: 람다는 문서화가 어려움")

# 람다는 __doc__ 속성이 없음
simple_lambda = lambda x: x * 2
print(f"람다 docstring: {simple_lambda.__doc__}")  # None

# 일반 함수는 문서화 가능
def documented_function(x):
    """숫자를 두 배로 만드는 함수"""
    return x * 2

print(f"함수 docstring: {documented_function.__doc__}")

# 대안: operator 모듈 사용
import operator

print("\n대안: operator 모듈 사용")
numbers = [1, 2, 3, 4, 5]

# ❌ 불필요한 람다
sum_with_lambda = reduce(lambda x, y: x + y, numbers)

# ✅ operator 모듈 사용
sum_with_operator = reduce(operator.add, numbers)

print(f"람다 사용 합계: {sum_with_lambda}")
print(f"operator 사용 합계: {sum_with_operator}")

# operator 모듈의 유용한 함수들
operations = [
    ('덧셈', operator.add, 10, 20),
    ('뺄셈', operator.sub, 20, 10),
    ('곱셈', operator.mul, 5, 6),
    ('나눗셈', operator.truediv, 20, 4),
    ('정수 나눗셈', operator.floordiv, 20, 3),
    ('나머지', operator.mod, 20, 3),
    ('지수', operator.pow, 2, 8),
    ('같음', operator.eq, 10, 10),
    ('다름', operator.ne, 10, 20),
    ('보다 큼', operator.gt, 20, 10),
    ('보다 작음', operator.lt, 10, 20),
]

print("\noperator 모듈 함수들:")
for name, op, a, b in operations:
    result = op(a, b)
    print(f"  {name:10} {a} {op.__name__} {b} = {result}")
```

### 실전 예제: 데이터 처리 파이프라인

```python
print("\n5. 실전 예제: 데이터 처리 파이프라인")
print("=" * 60)

# 샘플 데이터: 온라인 상점 주문
orders = [
    {'id': 1, 'customer': '김철수', 'amount': 15000, 'status': 'completed'},
    {'id': 2, 'customer': '이영희', 'amount': 75000, 'status': 'pending'},
    {'id': 3, 'customer': '박지민', 'amount': 32000, 'status': 'completed'},
    {'id': 4, 'customer': '최윤호', 'amount': 120000, 'status': 'shipped'},
    {'id': 5, 'customer': '정민지', 'amount': 45000, 'status': 'completed'},
    {'id': 6, 'customer': '김철수', 'amount': 89000, 'status': 'cancelled'},
    {'id': 7, 'customer': '이영희', 'amount': 56000, 'status': 'completed'},
]

# 데이터 처리 파이프라인 함수
def process_orders(orders, filters=None, transformations=None, aggregations=None):
    """
    주문 데이터 처리 파이프라인
    
    Args:
        orders: 주문 데이터 리스트
        filters: 필터 함수 리스트
        transformations: 변환 함수 리스트
        aggregations: 집계 함수 리스트
    
    Returns:
        처리된 결과
    """
    # 기본값 설정
    if filters is None:
        filters = []
    if transformations is None:
        transformations = []
    if aggregations is None:
        aggregations = []
    
    # 1. 필터링 단계
    filtered_data = orders
    for filter_func in filters:
        filtered_data = list(filter(filter_func, filtered_data))
    
    # 2. 변환 단계
    transformed_data = filtered_data
    for transform_func in transformations:
        transformed_data = list(map(transform_func, transformed_data))
    
    # 3. 집계 단계
    results = {}
    for agg_name, agg_func in aggregations:
        results[agg_name] = agg_func(transformed_data)
    
    return {
        'filtered_count': len(filtered_data),
        'transformed_count': len(transformed_data),
        'data': transformed_data,
        'aggregations': results
    }

# 람다를 이용한 다양한 처리 작업 정의
print("데이터 처리 파이프라인 실행:")

# 필터: 완료된 주문만
completed_filter = lambda order: order['status'] == 'completed'

# 필터: 50,000원 이상 주문
large_order_filter = lambda order: order['amount'] >= 50000

# 변환: 고객 이름 추출
customer_extractor = lambda order: order['customer']

# 변환: 주문 요약 생성
order_summary = lambda order: {
    'order_id': order['id'],
    'customer': order['customer'],
    'formatted_amount': f"{order['amount']:,}원",
    'status': order['status']
}

# 집계: 총 주문 금액
total_amount = lambda orders: sum(order['amount'] for order in orders)

# 집계: 평균 주문 금액
avg_amount = lambda orders: total_amount(orders) / len(orders) if orders else 0

# 집계: 고객별 주문 수
customer_count = lambda orders: len(set(order['customer'] for order in orders))

# 파이프라인 실행
result = process_orders(
    orders=orders,
    filters=[completed_filter, large_order_filter],
    transformations=[order_summary],
    aggregations=[
        ('total_amount', total_amount),
        ('avg_amount', avg_amount),
        ('unique_customers', customer_count)
    ]
)

print(f"\n처리 결과:")
print(f"- 필터된 주문 수: {result['filtered_count']}")
print(f"- 변환된 주문 수: {result['transformed_count']}")
print(f"- 총 주문 금액: {result['aggregations']['total_amount']:,}원")
print(f"- 평균 주문 금액: {result['aggregations']['avg_amount']:,.0f}원")
print(f"- 고유 고객 수: {result['aggregations']['unique_customers']}")

print("\n처리된 데이터:")
for order in result['data']:
    print(f"  주문 {order['order_id']}: {order['customer']}, {order['formatted_amount']}, {order['status']}")
```

## 이름 없는 함수에서 변수 고정: 클로저의 마법

클로저는 함수와 그 함수가 선언된 환경(변수들)을 함께 저장하는 개념입니다. 람다 함수와 결합하여 강력한 패턴을 만들 수 있습니다.

### 클로저의 기본 개념 이해

```python
print("\n1. 클로저 기본 개념")
print("=" * 60)

# 기본적인 클로저 예제
def outer_function(outer_var):
    """외부 함수: 클로저 생성"""
    def inner_function(inner_var):
        """내부 함수: 외부 변수를 기억"""
        return f"외부: {outer_var}, 내부: {inner_var}"
    return inner_function

# 클로저 생성
closure1 = outer_function("첫번째")
closure2 = outer_function("두번째")

# 클로저 실행
print("기본 클로저 예제:")
print(f"closure1('안녕') = {closure1('안녕')}")
print(f"closure2('Hello') = {closure2('Hello')}")

# 클로저가 외부 변수를 기억하는지 확인
print(f"\nclosure1의 외부 변수: {closure1.__closure__[0].cell_contents}")
print(f"closure2의 외부 변수: {closure2.__closure__[0].cell_contents}")

# 람다를 이용한 클로저
def make_multiplier(n):
    """람다를 이용한 클로저 생성"""
    return lambda x: x * n

print("\n람다 클로저:")
times_two = make_multiplier(2)
times_three = make_multiplier(3)

print(f"times_two(5) = {times_two(5)}")
print(f"times_three(5) = {times_three(5)}")
```

### 클로저의 실전 활용 패턴

```python
print("\n2. 클로저의 실전 활용 패턴")
print("=" * 60)

# 패턴 1: 카운터 생성기
def create_counter(start=0):
    """클로저를 이용한 카운터 생성"""
    count = start  # 자유 변수(free variable)
    
    def counter():
        nonlocal count  # 외부 변수 수정을 위해 nonlocal 선언
        current = count
        count += 1
        return current
    
    return counter

print("카운터 패턴:")
counter1 = create_counter(10)
counter2 = create_counter(100)

print("카운터 1:", [counter1() for _ in range(3)])
print("카운터 2:", [counter2() for _ in range(3)])

# 패턴 2: 메모이제이션(memoization)
def create_memoized_function(func):
    """함수의 결과를 캐싱하는 메모이제이션 래퍼"""
    cache = {}  # 캐시 저장소
    
    def memoized(*args):
        # 인자를 튜플로 변환하여 키 생성
        key = args
        
        if key not in cache:
            # 캐시에 없으면 계산
            cache[key] = func(*args)
            print(f"캐시 MISS: {args} → {cache[key]}")
        else:
            print(f"캐시 HIT: {args} → {cache[key]}")
        
        return cache[key]
    
    return memoized

print("\n메모이제이션 패턴:")

# 느린 피보나치 함수
def fibonacci_slow(n):
    """느린 재귀적 피보나치"""
    if n <= 1:
        return n
    return fibonacci_slow(n-1) + fibonacci_slow(n-2)

# 메모이제이션 적용
fibonacci_fast = create_memoized_function(fibonacci_slow)

print("피보나치(5) 계산:")
result = fibonacci_fast(5)
print(f"결과: {result}")

print("\n피보나치(5) 재계산 (캐시 사용):")
result = fibonacci_fast(5)
print(f"결과: {result}")

# 패턴 3: 상태를 가진 함수
def create_stateful_processor(initial_state):
    """상태를 유지하는 프로세서 생성"""
    state = initial_state.copy() if isinstance(initial_state, dict) else initial_state
    
    def processor(action, *args):
        nonlocal state
        
        if action == 'get':
            return state
        elif action == 'update':
            if isinstance(state, dict) and len(args) == 2:
                key, value = args
                state[key] = value
            else:
                state = args[0] if args else state
            return state
        elif action == 'reset':
            state = initial_state.copy() if isinstance(initial_state, dict) else initial_state
            return state
        else:
            raise ValueError(f"알 수 없는 액션: {action}")
    
    return processor

print("\n상태 관리 패턴:")
config_manager = create_stateful_processor({'theme': 'light', 'language': 'ko'})

print("초기 상태:", config_manager('get'))
config_manager('update', 'theme', 'dark')
print("테마 변경 후:", config_manager('get'))
config_manager('reset')
print("리셋 후:", config_manager('get'))
```

### 변수 고정의 함정과 해결책

```python
print("\n3. 변수 고정의 함정과 해결책")
print("=" * 60)

# 함정 1: 늦은 바인딩(late binding)
def create_functions():
    """잘못된 클로저 생성"""
    functions = []
    for i in range(3):
        functions.append(lambda: i)  # i는 루프 종료 시 2가 됨
    return functions

print("늦은 바인딩 문제:")
bad_functions = create_functions()
for f in bad_functions:
    print(f"함수 실행: {f()}")  # 모두 2를 출력!

# 해결책 1: 기본 인자 사용
def create_functions_fixed():
    """기본 인자로 고정"""
    functions = []
    for i in range(3):
        functions.append(lambda x=i: x)  # i의 현재 값을 기본값으로 고정
    return functions

print("\n기본 인자로 해결:")
good_functions = create_functions_fixed()
for f in good_functions:
    print(f"함수 실행: {f()}")  # 0, 1, 2를 출력

# 해결책 2: 팩토리 함수 사용
def create_function_factory(value):
    """값을 고정하는 팩토리 함수"""
    return lambda: value

def create_functions_fixed2():
    """팩토리 함수로 해결"""
    functions = []
    for i in range(3):
        functions.append(create_function_factory(i))
    return functions

print("\n팩토리 함수로 해결:")
better_functions = create_functions_fixed2()
for f in better_functions:
    print(f"함수 실행: {f()}")  # 0, 1, 2를 출력

# 함정 2: 뮤터블 객체 공유
def create_accumulators():
    """잘못된 누적기 생성"""
    total = 0  # 모든 누적기가 공유하는 변수
    accumulators = []
    
    for i in range(3):
        def accumulator(x):
            nonlocal total  # 모든 accumulator가 같은 total을 참조
            total += x
            return total
        accumulators.append(accumulator)
    
    return accumulators

print("\n변수 공유 문제:")
try:
    bad_accumulators = create_accumulators()
    # 모든 누적기가 같은 total을 수정
    print(f"첫 번째 누적기(5): {bad_accumulators[0](5)}")
    print(f"두 번째 누적기(10): {bad_accumulators[1](10)}")
    print(f"세 번째 누적기(15): {bad_accumulators[2](15)}")
except Exception as e:
    print(f"오류 발생: {e}")

# 해결책: 독립적인 상태 생성
def create_accumulators_fixed():
    """독립적인 누적기 생성"""
    accumulators = []
    
    for i in range(3):
        total = 0  # 각 누적기마다 독립적인 total
        
        def accumulator(x, total_ref=[0]):  # 뮤터블 객체로 상태 저장
            total_ref[0] += x
            return total_ref[0]
        
        accumulators.append(accumulator)
    
    return accumulators

print("\n독립적 상태 해결:")
good_accumulators = create_accumulators_fixed()
print(f"첫 번째 누적기(5): {good_accumulators[0](5)}")
print(f"두 번째 누적기(10): {good_accumulators[1](10)}")
print(f"세 번째 누적기(15): {good_accumulators[2](15)}")

# 각각 독립적으로 동작
print(f"첫 번째 누적기 다시(3): {good_accumulators[0](3)}")
```

### 실전 예제: 이벤트 핸들러 시스템

```python
print("\n4. 실전 예제: 이벤트 핸들러 시스템")
print("=" * 60)

class EventSystem:
    """클로저를 이용한 이벤트 시스템"""
    
    def __init__(self):
        self.handlers = {}
        self.event_history = []
    
    def register_handler(self, event_type, handler_id=None):
        """
        이벤트 핸들러 등록 데코레이터
        
        Args:
            event_type: 이벤트 타입
            handler_id: 핸들러 식별자 (None이면 함수 이름 사용)
        """
        def decorator(func):
            # 핸들러 ID 결정
            hid = handler_id or func.__name__
            
            # 핸들러 등록
            if event_type not in self.handlers:
                self.handlers[event_type] = {}
            
            self.handlers[event_type][hid] = func
            
            # 등록 정보를 기록하는 클로저 반환
            def wrapper(*args, **kwargs):
                # 이벤트 기록
                self.event_history.append({
                    'event': event_type,
                    'handler': hid,
                    'timestamp': datetime.datetime.now().isoformat()
                })
                
                # 원래 함수 실행
                return func(*args, **kwargs)
            
            # wrapper의 원본 함수 참조 저장
            wrapper.original = func
            
            return wrapper
        
        return decorator
    
    def create_one_time_handler(self, event_type, condition=None):
        """
        한 번만 실행되는 핸들러 생성
        
        Args:
            event_type: 이벤트 타입
            condition: 실행 조건 함수
        """
        has_run = False
        
        def one_time_handler(*args, **kwargs):
            nonlocal has_run
            
            if has_run:
                return None  # 이미 실행됨
            
            # 조건 검사
            if condition and not condition(*args, **kwargs):
                return None
            
            has_run = True
            return f"한 번 실행된 {event_type} 핸들러"
        
        # 핸들러 등록
        handler_id = f"one_time_{len(self.handlers.get(event_type, {}))}"
        self.register_handler(event_type, handler_id)(one_time_handler)
        
        return one_time_handler
    
    def trigger_event(self, event_type, *args, **kwargs):
        """이벤트 발생"""
        results = []
        
        if event_type in self.handlers:
            for handler_id, handler in self.handlers[event_type].items():
                try:
                    result = handler(*args, **kwargs)
                    if result is not None:
                        results.append({
                            'handler': handler_id,
                            'result': result
                        })
                except Exception as e:
                    print(f"핸들러 {handler_id} 실행 중 오류: {e}")
        
        return results
    
    def get_stats(self):
        """시스템 통계"""
        stats = {
            'total_events': len(self.event_history),
            'handlers_by_type': {
                event_type: len(handlers)
                for event_type, handlers in self.handlers.items()
            },
            'recent_events': self.event_history[-5:] if self.event_history else []
        }
        return stats

# 이벤트 시스템 사용 예제
print("이벤트 시스템 데모:")

system = EventSystem()

# 핸들러 등록
@system.register_handler('user_login')
def handle_login(user_id, ip_address):
    """사용자 로그인 처리"""
    return f"사용자 {user_id}가 {ip_address}에서 로그인했습니다."

@system.register_handler('user_login')
def send_welcome_email(user_id, ip_address):
    """환영 이메일 전송"""
    return f"{user_id}님에게 환영 이메일을 전송했습니다."

@system.register_handler('order_placed')
def process_order(order_id, amount):
    """주문 처리"""
    return f"주문 {order_id} 처리 완료: {amount:,}원"

@system.register_handler('error')
def log_error(error_message):
    """에러 로깅"""
    return f"에러 로그: {error_message}"

# 한 번만 실행되는 핸들러 생성
one_time_handler = system.create_one_time_handler(
    'user_login',
    condition=lambda user_id, ip: user_id == 'admin'
)

# 이벤트 발생
print("\n이벤트 발생 테스트:")

# 일반 로그인
print("일반 사용자 로그인:")
results = system.trigger_event('user_login', 'user123', '192.168.1.100')
for r in results:
    print(f"  - {r['handler']}: {r['result']}")

# 관리자 로그인 (한 번만 실행됨)
print("\n관리자 로그인 (첫 번째):")
results = system.trigger_event('user_login', 'admin', '192.168.1.1')
for r in results:
    print(f"  - {r['handler']}: {r['result']}")

print("\n관리자 로그인 (두 번째):")
results = system.trigger_event('user_login', 'admin', '192.168.1.1')
for r in results:
    print(f"  - {r['handler']}: {r['result']}")

# 주문 이벤트
print("\n주문 발생:")
results = system.trigger_event('order_placed', 'ORDER001', 150000)
for r in results:
    print(f"  - {r['handler']}: {r['result']}")

# 통계 출력
print("\n시스템 통계:")
stats = system.get_stats()
print(f"총 이벤트 수: {stats['total_events']}")
print("핸들러 수:")
for event_type, count in stats['handlers_by_type'].items():
    print(f"  {event_type}: {count}개")
```

## 인자를 n개 받는 함수를 더 적은 인자로 사용: 커링과 부분 적용

함수의 인자 수를 줄이거나 특정 인자를 고정하여 새로운 함수를 생성하는 기법은 함수형 프로그래밍에서 매우 유용합니다.

### 기본 개념: 커링(Currying) vs 부분 적용(Partial Application)

```python
print("\n1. 커링과 부분 적용 기본 개념")
print("=" * 60)

# 원본 함수
def power(base, exponent):
    """거듭제곱 계산"""
    return base ** exponent

print("원본 함수:")
print(f"power(2, 3) = {power(2, 3)}")
print(f"power(5, 2) = {power(5, 2)}")

# 수동 부분 적용
def square(x):
    """제곱 함수 (base를 2로 고정)"""
    return power(x, 2)

def cube(x):
    """세제곱 함수 (base를 3로 고정)"""
    return power(x, 3)

print("\n수동 부분 적용:")
print(f"square(4) = {square(4)}")  # 4^2 = 16
print(f"cube(3) = {cube(3)}")      # 3^3 = 27

# functools.partial을 이용한 부분 적용
from functools import partial

print("\nfunctools.partial 사용:")

# 지수를 2로 고정 (제곱 함수)
square_partial = partial(power, exponent=2)
print(f"square_partial(4) = {square_partial(4)}")

# 밑수를 2로 고정 (2의 거듭제곱)
power_of_two = partial(power, base=2)
print(f"power_of_two(8) = {power_of_two(8)}")  # 2^8 = 256

# 커링 함수 구현
def curry(func):
    """함수를 커링하는 데코레이터"""
    def curried(*args, **kwargs):
        if len(args) + len(kwargs) >= func.__code__.co_argcount:
            # 충분한 인자가 제공됨
            return func(*args, **kwargs)
        else:
            # 인자가 부족한 경우, 새로운 함수 반환
            def partial_func(*more_args, **more_kwargs):
                new_args = args + more_args
                new_kwargs = kwargs.copy()
                new_kwargs.update(more_kwargs)
                return curried(*new_args, **new_kwargs)
            return partial_func
    
    return curried

print("\n커링 구현:")
@curry
def add_three_numbers(a, b, c):
    """세 숫자를 더하는 함수"""
    return a + b + c

# 다양한 방식으로 호출
print(f"add_three_numbers(1, 2, 3) = {add_three_numbers(1, 2, 3)}")
print(f"add_three_numbers(1)(2)(3) = {add_three_numbers(1)(2)(3)}")
print(f"add_three_numbers(1, 2)(3) = {add_three_numbers(1, 2)(3)}")

# 부분 적용 예제
add_5_and = add_three_numbers(5)  # 첫 번째 인자를 5로 고정
print(f"add_5_and(10, 15) = {add_5_and(10, 15)}")  # 5 + 10 + 15 = 30

add_5_and_10 = add_three_numbers(5, 10)  # 첫 두 인자를 고정
print(f"add_5_and_10(15) = {add_5_and_10(15)}")  # 5 + 10 + 15 = 30
```

### 실전 부분 적용 패턴

```python
print("\n2. 실전 부분 적용 패턴")
print("=" * 60)

# 패턴 1: 로깅 함수 생성
def create_logger(log_level, timestamp_format="%Y-%m-%d %H:%M:%S"):
    """로거 생성 팩토리"""
    import datetime
    
    def log(message, source=None):
        """실제 로깅 함수"""
        timestamp = datetime.datetime.now().strftime(timestamp_format)
        source_info = f"[{source}] " if source else ""
        print(f"{timestamp} [{log_level}] {source_info}{message}")
    
    return log

print("로깅 팩토리 패턴:")
info_logger = create_logger("INFO")
error_logger = create_logger("ERROR")
debug_logger = create_logger("DEBUG", "%H:%M:%S")

info_logger("애플리케이션 시작됨", source="system")
error_logger("데이터베이스 연결 실패", source="db")
debug_logger("변수 값 확인", source="debug")

# 패턴 2: 데이터베이스 쿼리 빌더
def create_query(table_name, columns="*", where_clause=None):
    """쿼리 생성 함수"""
    def query(limit=None, order_by=None):
        """실제 쿼리 생성"""
        query_parts = [f"SELECT {columns} FROM {table_name}"]
        
        if where_clause:
            query_parts.append(f"WHERE {where_clause}")
        
        if order_by:
            query_parts.append(f"ORDER BY {order_by}")
        
        if limit:
            query_parts.append(f"LIMIT {limit}")
        
        return " ".join(query_parts)
    
    return query

print("\n쿼리 빌더 패턴:")
# 사용자 테이블 쿼리
user_query = create_query(
    table_name="users",
    columns="id, name, email",
    where_clause="status = 'active'"
)

print("기본 사용자 쿼리:")
print(f"  {user_query()}")

print("\n정렬된 사용자 쿼리:")
print(f"  {user_query(order_by='name')}")

print("\n제한된 사용자 쿼리:")
print(f"  {user_query(limit=10, order_by='created_at DESC')}")

# 주문 테이블 쿼리 (다른 조건)
recent_orders_query = create_query(
    table_name="orders",
    columns="order_id, customer_id, total_amount, order_date",
    where_clause="order_date >= DATE_SUB(NOW(), INTERVAL 7 DAY)"
)

print("\n최근 주문 쿼리:")
print(f"  {recent_orders_query(limit=5, order_by='order_date DESC')}")

# 패턴 3: API 요청 빌더
def create_api_request(method, base_url):
    """API 요청 빌더"""
    def request(endpoint, params=None, headers=None, data=None):
        """실제 요청 생성"""
        import json
        
        # URL 구성
        url = f"{base_url.rstrip('/')}/{endpoint.lstrip('/')}"
        
        # 요청 정보
        request_info = {
            'method': method,
            'url': url,
            'params': params or {},
            'headers': headers or {},
        }
        
        if data:
            request_info['data'] = data
            request_info['headers']['Content-Type'] = 'application/json'
        
        return request_info
    
    return request

print("\nAPI 요청 빌더 패턴:")
# GitHub API 클라이언트
github_get = create_api_request("GET", "https://api.github.com")
github_post = create_api_request("POST", "https://api.github.com")

print("GitHub 사용자 정보 요청:")
user_request = github_get(
    endpoint="/users/octocat",
    headers={'Authorization': 'token ghp_abc123'}
)
print(f"  Method: {user_request['method']}")
print(f"  URL: {user_request['url']}")

print("\nGitHub 이슈 생성 요청:")
new_issue = github_post(
    endpoint="/repos/octocat/hello-world/issues",
    data=json.dumps({
        'title': '버그 리포트',
        'body': '이 기능이 작동하지 않습니다.'
    }),
    headers={
        'Authorization': 'token ghp_abc123',
        'Accept': 'application/vnd.github.v3+json'
    }
)
print(f"  Method: {new_issue['method']}")
print(f"  URL: {new_issue['url']}")
```

### 고급: 파이프라인과 함수 조합

```python
print("\n3. 고급: 파이프라인과 함수 조합")
print("=" * 60)

# 기본 유틸리티 함수들
def add(x, y):
    return x + y

def multiply(x, y):
    return x * y

def subtract(x, y):
    return x - y

def divide(x, y):
    return x / y

# 파이프라인 구성 함수
def compose(*functions):
    """함수들을 합성하는 고차 함수"""
    def composed(*args, **kwargs):
        result = functions[-1](*args, **kwargs)
        for func in functions[-2::-1]:  # 뒤에서부터 앞으로
            result = func(result)
        return result
    return composed

def pipe(*functions):
    """함수들을 파이프라인으로 연결"""
    def piped(*args, **kwargs):
        result = functions[0](*args, **kwargs)
        for func in functions[1:]:  # 앞에서부터 뒤로
            result = func(result)
        return result
    return piped

print("함수 합성과 파이프라인:")

# 부분 적용을 이용한 함수 생성
add_5 = partial(add, 5)
multiply_by_2 = partial(multiply, 2)
subtract_10 = partial(subtract, y=10)  # 키워드 인자 사용

# 함수 합성: (x + 5) * 2 - 10
complex_calculation = compose(subtract_10, multiply_by_2, add_5)

print(f"합성 함수: (x + 5) * 2 - 10")
print(f"  x=10 → {complex_calculation(10)}")  # (10+5)*2-10 = 20

# 파이프라인: x → add_5 → multiply_by_2 → subtract_10
pipeline = pipe(add_5, multiply_by_2, subtract_10)

print(f"\n파이프라인: x → +5 → ×2 → -10")
print(f"  x=10 → {pipeline(10)}")  # 결과는 위와 동일

# 실전 예제: 데이터 처리 파이프라인
def data_processing_pipeline():
    """데이터 처리 파이프라인 빌더"""
    
    # 기본 처리 함수들
    def filter_none(data):
        """None 값 제거"""
        return [item for item in data if item is not None]
    
    def convert_to_int(data):
        """정수로 변환"""
        return [int(item) if isinstance(item, (int, float, str)) else item 
                for item in data]
    
    def filter_positive(data):
        """양수만 필터링"""
        return [item for item in data if isinstance(item, (int, float)) and item > 0]
    
    def calculate_average(data):
        """평균 계산"""
        if not data:
            return 0
        return sum(data) / len(data)
    
    # 파이프라인 빌더
    def build_pipeline(*steps):
        """주어진 단계로 파이프라인 구성"""
        def pipeline(data):
            result = data
            for step in steps:
                result = step(result)
            return result
        return pipeline
    
    return {
        'filter_none': filter_none,
        'convert_to_int': convert_to_int,
        'filter_positive': filter_positive,
        'calculate_average': calculate_average,
        'build_pipeline': build_pipeline
    }

print("\n데이터 처리 파이프라인:")

# 처리기 생성
processor = data_processing_pipeline()

# 다양한 파이프라인 구성
pipeline1 = processor['build_pipeline'](
    processor['filter_none'],
    processor['convert_to_int'],
    processor['filter_positive']
)

pipeline2 = processor['build_pipeline'](
    processor['filter_none'],
    processor['convert_to_int'],
    processor['filter_positive'],
    processor['calculate_average']
)

# 테스트 데이터
test_data = [1, 2, None, "3", 4.5, -2, "abc", 0, 7]

print(f"원본 데이터: {test_data}")
print(f"\n파이프라인 1 (필터링만): {pipeline1(test_data)}")
print(f"파이프라인 2 (평균 계산): {pipeline2(test_data):.2f}")

# 동적으로 파이프라인 구성
def create_dynamic_pipeline(*step_names):
    """이름으로 파이프라인 동적 구성"""
    available_steps = {
        'filter_none': processor['filter_none'],
        'to_int': processor['convert_to_int'],
        'positive': processor['filter_positive'],
        'average': processor['calculate_average']
    }
    
    selected_steps = [available_steps[name] for name in step_names]
    return processor['build_pipeline'](*selected_steps)

print("\n동적 파이프라인 구성:")
dynamic_pipeline = create_dynamic_pipeline('filter_none', 'to_int', 'average')
print(f"동적 파이프라인 결과: {dynamic_pipeline(test_data):.2f}")
```

### 실전 예제: 웹 애플리케이션 미들웨어 시스템

```python
print("\n4. 실전 예제: 웹 애플리케이션 미들웨어 시스템")
print("=" * 60)

# 간단한 HTTP 요청/응답 모델
class Request:
    """HTTP 요청 모델"""
    def __init__(self, method, path, headers=None, body=None):
        self.method = method
        self.path = path
        self.headers = headers or {}
        self.body = body or {}
        self.user = None
        self.params = {}

class Response:
    """HTTP 응답 모델"""
    def __init__(self, status=200, body=None, headers=None):
        self.status = status
        self.body = body or {}
        self.headers = headers or {}

# 미들웨어 시스템
class MiddlewareSystem:
    """부분 적용을 이용한 미들웨어 시스템"""
    
    def __init__(self):
        self.middlewares = []
    
    def use(self, middleware_func):
        """미들웨어 등록"""
        self.middlewares.append(middleware_func)
        return self  # 메서드 체이닝 지원
    
    def create_handler(self, final_handler):
        """
        최종 핸들러와 미들웨어를 조합한 핸들러 생성
        
        Args:
            final_handler: 실제 요청을 처리하는 최종 함수
        
        Returns:
            미들웨어가 적용된 핸들러
        """
        # 미들웨어를 역순으로 적용 (마지막 미들웨어가 먼저 실행)
        handler = final_handler
        
        for middleware in reversed(self.middlewares):
            # 각 미들웨어는 다음 핸들러를 인자로 받음
            handler = partial(middleware, next_handler=handler)
        
        return handler
    
    @staticmethod
    def create_middleware(condition_func=None):
        """
        미들웨어 생성 데코레이터
        
        Args:
            condition_func: 미들웨어 실행 조건 함수
        """
        def decorator(middleware_func):
            def wrapper(request, next_handler, **kwargs):
                # 조건이 있으면 확인
                if condition_func and not condition_func(request):
                    return next_handler(request)
                
                # 미들웨어 실행
                return middleware_func(request, next_handler, **kwargs)
            
            return wrapper
        
        return decorator

print("웹 미들웨어 시스템 데모:")

# 미들웨어 시스템 생성
app = MiddlewareSystem()

# 로깅 미들웨어
@app.use
def logging_middleware(request, next_handler):
    """요청 로깅"""
    print(f"[LOG] {request.method} {request.path}")
    response = next_handler(request)
    print(f"[LOG] 응답 상태: {response.status}")
    return response

# 인증 미들웨어 (조건부)
auth_condition = lambda req: req.path.startswith('/api/')
auth_middleware = MiddlewareSystem.create_middleware(auth_condition)(
    lambda request, next_handler:
        # 간단한 인증 검사
        if request.headers.get('Authorization') == 'Bearer valid_token':
            request.user = {'id': 'user123', 'name': '김철수'}
            return next_handler(request)
        else:
            return Response(status=401, body={'error': '인증 필요'})
)

app.use(auth_middleware)

# 요청 데이터 파싱 미들웨어
@app.use
def parse_body_middleware(request, next_handler):
    """요청 본문 파싱 (간단한 구현)"""
    if request.method in ['POST', 'PUT', 'PATCH']:
        # 실제로는 JSON 파싱 등을 구현
        if isinstance(request.body, dict):
            request.params.update(request.body)
    return next_handler(request)

# 최종 요청 핸들러들
def api_user_handler(request):
    """API 사용자 핸들러"""
    if request.path == '/api/users':
        if request.method == 'GET':
            return Response(200, {
                'users': [
                    {'id': 1, 'name': '김철수'},
                    {'id': 2, 'name': '이영희'}
                ]
            })
        elif request.method == 'POST':
            new_user = {
                'id': 3,
                'name': request.params.get('name', '새 사용자')
            }
            return Response(201, new_user)
    
    return Response(404, {'error': '찾을 수 없음'})

def home_handler(request):
    """홈페이지 핸들러"""
    return Response(200, {'message': '홈페이지에 오신 것을 환영합니다!'})

def about_handler(request):
    """소개 페이지 핸들러"""
    return Response(200, {'message': '이것은 About 페이지입니다.'})

# 미들웨어가 적용된 핸들러 생성
api_handler = app.create_handler(api_user_handler)
homepage_handler = app.create_handler(home_handler)
about_handler_with_mw = app.create_handler(about_handler)

print("\n요청 처리 테스트:")

# 테스트 요청들
test_requests = [
    Request('GET', '/', headers={'User-Agent': 'Test'}),
    Request('GET', '/about', headers={'User-Agent': 'Test'}),
    Request('GET', '/api/users', headers={'Authorization': 'Bearer invalid_token'}),
    Request('GET', '/api/users', headers={'Authorization': 'Bearer valid_token'}),
    Request('POST', '/api/users', 
            headers={'Authorization': 'Bearer valid_token', 'Content-Type': 'application/json'},
            body={'name': '박지민'})
]

for i, req in enumerate(test_requests, 1):
    print(f"\n테스트 {i}: {req.method} {req.path}")
    
    # 적절한 핸들러 선택
    if req.path.startswith('/api/'):
        response = api_handler(req)
    elif req.path == '/about':
        response = about_handler_with_mw(req)
    else:
        response = homepage_handler(req)
    
    print(f"  응답: 상태 {response.status}, 본문: {response.body}")
```

## 결론: 파이썬 함수 정의의 모범 사례

### 1. **기본 인자의 올바른 사용**
- **가변 객체 주의**: 리스트, 딕셔너리 등 가변 객체는 `None`을 기본값으로 사용하고 함수 내에서 생성
- **불변 객체 선호**: 문자열, 숫자, 튜플 등 불변 객체는 기본값으로 안전하게 사용 가능
- **동적 기본값**: `None`을 기본값으로 하고 함수 내에서 필요한 값으로 초기화
- **문서화**: 기본값이 있는 인자는 반드시 문서화하여 의도를 명확히 전달

### 2. **람다 함수의 적절한 활용**
- **간단한 로직에만 사용**: 한 줄로 표현 가능한 단순한 연산에 적합
- **가독성 우선**: 복잡한 로직은 일반 함수로 정의하는 것이 바람직
- **고차 함수와 조합**: `map()`, `filter()`, `sorted()` 등과 함께 사용할 때 강력함 발휘
- **네이밍 고려**: 의미 있는 이름의 일반 함수가 문서화와 디버깅에 유리

### 3. **클로저와 변수 고정의 이해**
- **늦은 바인딩 문제**: 루프 내에서 람다 생성 시 기본 인자로 값 고정 필요
- **상태 관리**: 클로저는 상태를 캡슐화하는 강력한 도구
- **메모리 관리**: 필요 이상의 클로저 생성은 메모리 누수 가능성 있음
- **디버깅 어려움**: 클로저는 디버깅이 어려울 수 있으므로 남용 금지

### 4. **부분 적용과 커링의 전략적 사용**
- **코드 재사용**: 비슷한 패턴의 함수를 쉽게 생성 가능
- **인터페이스 단순화**: 복잡한 함수를 더 단순한 인터페이스로 제공
- **파이프라인 구성**: 함수형 프로그래밍 스타일의 데이터 처리 가능
- **테스트 용이성**: 특정 인자를 고정하여 테스트하기 쉬운 함수 생성

### 5. **함수 설계 일반 원칙**
- **단일 책임 원칙**: 하나의 함수는 하나의 일만 잘하게 설계
- **명확한 인터페이스**: 함수 이름과 인자 이름이 의도를 명확히 전달
- **적절한 추상화 수준**: 너무 구체적이지도, 너무 추상적이지도 않게 설계
- **에러 처리**: 명확한 에러 메시지와 적절한 예외 처리 구현

### 6. **성능 고려사항**
- **함수 호출 오버헤드**: 너무 잦은 작은 함수 호출은 성능 저하 원인
- **람다 vs 일반 함수**: 람다가 항상 빠른 것은 아니며, 상황에 맞게 선택
- **부분 적용 비용**: `functools.partial`은 추가적인 호출 레이어 생성
- **클로저 메모리**: 클로저는 외부 변수를 계속 참조하므로 메모리 해제 지연 가능

### 7. **테스트와 유지보수**
- **단위 테스트 용이성**: 작고 집중된 함수는 테스트하기 쉬움
- **의존성 명확성**: 함수의 의존성을 명확히 드러내는 설계
- **변경 용이성**: 관련된 변경이 한 곳에서만 발생하도록 모듈화
- **문서화 중요성**: 특히 복잡한 함수나 클로저는 상세한 문서화 필요

파이썬의 함수 정의 기능은 매우 강력하지만, 이 힘을 효과적으로 활용하려면 각 기법의 적절한 사용 시기와 방법을 이해하는 것이 중요합니다. 기본 인자는 함수 인터페이스를 유연하게 만들고, 람다는 간결함을 제공하며, 클로저는 상태를 캡슐화하고, 부분 적용은 코드 재사용성을 높입니다. 이러한 도구들을 상황에 맞게 조합하면 더욱 표현력 있고 유지보수하기 쉬운 코드를 작성할 수 있습니다.