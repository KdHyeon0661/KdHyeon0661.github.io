---
layout: post
title: 암호학 - 키·비밀 관리
date: 2025-10-13 20:30:23 +0900
category: 암호학
---
# 12. 키·비밀 관리 (⚙️)

> 이 장은 **키 수명주기(생성→배포→회전→파기)** → **KMS/HSM 및 클라우드 패턴(AWS/GCP/Azure)** → **비밀 관리 실전(Shamir 분산·환경변수·시크릿 스토어)** → **서버 없는(serverless) 키 관리** 순서로, **운영 체크리스트·코드 스니펫·플레이북**까지 한 번에 정리합니다.  
> 원칙: **자작 암호 금지**, **표준 하드웨어/서비스 활용**, **감사·가시성 우선**, **사고 전제(Compromise Assume)**.

---

## ✅ 12.1 키 수명주기: 생성 → 배포 → 사용 → 회전 → 보관/파기

### 12.1.1 핵심 개념
- **키 유형**  
  - **마스터 키/루트 키**: 하위 키(데이터 키)를 암호화(KEK). HSM/KMS에서 관리.  
  - **데이터 암호화 키(DEK)**: 실제 데이터(파일/DB/객체)를 암호화. 수명이 짧고 자주 회전.  
  - **세션 키**: 프로토콜 중 일시 사용(TLS/SSH 등).  
  - **서명 키**: 코드서명/토큰서명(JWT)/인증서 발급키(CA).  
  - **비밀번호 파생 키**: KDF 결과(4장 참고).  
- **표기**: `key_id`(UUID/ARN/URL), `version`(v1, v2…), `origin`(HSM/외부), `purpose`(enc/mac/sign), `state`(enabled/disabled/destroyed).

### 12.1.2 수명주기 단계 & 운영 포인트

```
[생성] --> [등록/태깅] --> [배포] --> [사용/모니터링] --> [회전] --> [보관/아카이브] --> [파기]
```

- **생성**:  
  - **CSPRNG/HSM**로 생성. 키 길이: AES-256 / ChaCha20-Poly1305 / RSA-3072+ 또는 EC/EdDSA / PQ 전환 계획 반영.  
  - 생성 로그(누가, 언제, 어디서, 태그).  
- **등록/태깅**:  
  - `env=prod/stage`, `system=billing`, `purpose=envelope`, `compliance=PCI` 등 **메타데이터 기획**.  
- **배포**:  
  - **단계적 롤아웃**(canary), **권한 최소화(least privilege)**, **정책 기반 접근(ABAC/RBAC)**.  
- **사용/모니터링**:  
  - **성공/실패 호출**, **암·복호량**, **누가/무엇이/어디서**.  
  - 비정상 패턴(새 ASN, 갑작스런 폭증) 경보.  
- **회전**:  
  - 주기(90~180일) 또는 이벤트 기반(탈취 의심, crypto-agility).  
  - **데이터 키는 “인플레이스 재암호화” 불필요**(봉투 암호화: 새 DEK로 신규 데이터부터, 구 데이터는 점진).  
- **보관/아카이브**:  
  - 규제/법적 보존(서명 검증키 등) — **비활성화 후 HSM 보관**.  
- **파기**:  
  - 키 파기 요청 → **대기 기간**(scheduled destroy) → 파기 → **테이프/백업 포함** 전 구간 폐기 증적 확보.  
  - 해지/폐기 전 구현에 **키 식별자**가 남아 있지 않게 마이그레이션.

### 12.1.3 회전 전략(봉투 암호화 기준)

```
[CMK(KEK) v1] -> encrypt(DEK v1) -> encrypt(data)
   |
   +--(회전)--> [CMK v2]  ; 새 DEK는 v2로 래핑
                 구 데이터: 점진적 재암호화(배치/접근 시)
```

- **CMK(KEK)**: KMS/HSM 내에서 **키 버전**만 증가, 애플리케이션은 **ID만 고정**.  
- **DEK**: 데이터 단위(파일/레코드/객체)마다 생성, **헤더에 암호화된 DEK**(EDK) 저장.  
- **복호**: EDK를 KMS로 unwrap → 평문 DEK를 메모리에서만 사용(캐시 TTL).  
- **성능**: KMS 호출은 **오버헤드 큼** → **DEK 캐싱**(수 분) 또는 **데이터 단위 캐시**.

---

## ✅ 12.2 HSM/KMS: 무엇을 언제 쓰나

### 12.2.1 HSM (Hardware Security Module)
- **보안 경계** 안에서 키 생성/저장/연산(키가 절대 평문으로 외부에 나오지 않음).  
- 물리적 공격 저항(탬퍼 레지스턴트), **FIPS 140-2/3** 수준별.  
- 용도: **루트 CA 키, 코드서명 키, 은행 결제 키, KMS의 백엔드**.

### 12.2.2 KMS (Key Management Service)
- 클라우드/온프렘에서 **API**로 `Encrypt/Decrypt`/`GenerateDataKey`/`Sign/Verify`/`Rotate`/`Policy`/`Audit` 제공.  
- 내부적으로 HSM을 사용하거나 HSM 옵션(CloudHSM 등) 제공.  
- 장점: **정책·감사·권한 모델** 내장, **운영 단순화**.  
- 패턴:
  - **봉투 암호화(Envelope Encryption)**: `GenerateDataKey`로 **평문 DEK + EDK** 동시 획득 → 데이터는 **평문 DEK로 암호화**, EDK만 저장. 복호 시 `Decrypt(EDK)`로 DEK 복원.

### 12.2.3 클라우드별 감각(개요)
- **AWS KMS** / **CloudHSM**(BYOK/HYOK 가능), **Grants/Key Policy**, `GenerateDataKey`, `Encrypt`, `Sign`.  
- **GCP Cloud KMS** / **Cloud HSM**, `cryptoKeyVersions`, IAM 조건부 정책, CMEK/ExternalKeys.  
- **Azure Key Vault** / **Managed HSM**, RBAC/Access Policy, `wrapKey/unwrapKey`, `sign/verify`.

> 공통: **지역(리전) 경계/주권성**, **CMK 복제 전략**, **키 수명·회전 정책**(자동/수동), **감사 로그(CloudTrail/Audit Logs/Diagnostics)**.

---

## ✅ 12.3 봉투 암호화(Envelope Encryption) — 코드/CLI 빠른 예

### 12.3.1 AWS (Python: boto3, 개념)
```python
import boto3, base64, os
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

kms = boto3.client('kms', region_name='ap-northeast-2')
KEY_ID = 'arn:aws:kms:ap-northeast-2:1234:key/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'

def encrypt_blob(plaintext: bytes):
    # 1) DEK 생성 (평문 + 암호화본(EDK) 동시)
    resp = kms.generate_data_key(KeyId=KEY_ID, KeySpec='AES_256')
    dek_plain = resp['Plaintext']      # bytes
    dek_edk   = resp['CiphertextBlob'] # bytes (KMS로만 복호 가능)

    # 2) 데이터 암호화 (AEAD)
    aes = AESGCM(dek_plain)
    nonce = os.urandom(12)
    aad = b"v=1|type=blob"
    ct = aes.encrypt(nonce, plaintext, aad)

    # 3) 평문 DEK는 즉시 메모리 삭제(파이썬 한계: GC 의존)
    del dek_plain

    # 4) 결과 패키징 (헤더에 EDK/nonce/aad 힌트 포함)
    return {
        'edk': base64.b64encode(dek_edk).decode(),
        'nonce': base64.b64encode(nonce).decode(),
        'aad': aad.decode(),
        'ciphertext': base64.b64encode(ct).decode()
    }

def decrypt_blob(pkg):
    edk   = base64.b64decode(pkg['edk'])
    nonce = base64.b64decode(pkg['nonce'])
    aad   = pkg['aad'].encode()
    ct    = base64.b64decode(pkg['ciphertext'])

    # 1) EDK 복호 → 평문 DEK 획득
    resp = kms.decrypt(CiphertextBlob=edk, KeyId=KEY_ID)
    dek_plain = resp['Plaintext']

    # 2) 데이터 복호
    aes = AESGCM(dek_plain)
    pt = aes.decrypt(nonce, ct, aad)
    del dek_plain
    return pt
```

### 12.3.2 GCP (개념: Envelope with Cloud KMS)
- `projects/.../locations/.../keyRings/.../cryptoKeys/...`  
- `encrypt`로 **DEK를 래핑**하고, 데이터는 로컬 AES-GCM으로.  
- `cryptoKeyVersions`로 **버저닝/회전**.

### 12.3.3 Azure (개념: Key Vault wrap/unwrap)
- `wrapKey(KEK, DEK)` / `unwrapKey` → DEK로 데이터 AES-GCM.  
- 권한: `keys/wrapKey`, `keys/unwrapKey`, `keys/sign`, `keys/verify` 등 최소화.

---

## ✅ 12.4 키 정책(Policy), 권한, 감사

### 12.4.1 접근 제어
- **권한 최소화**: `Encrypt`만 필요한 워크로드에 `Decrypt` 금지.  
- **Grants/Delegation**(AWS) / **IAM 조건**(GCP) / **RBAC**(Azure) 활용.  
- **조건부 정책**: `sourceVpc`, `aws:PrincipalTag`, `time`, `ipRange` 등.

### 12.4.2 감사·가시성
- 모든 `Encrypt/Decrypt/Sign` 호출 로그 + **상관 ID**.  
- **경보 규칙**:  
  - 짧은 시간 `Decrypt` 급증, 미사용 키 갑작스런 사용, 야간/새 ASN.  
  - 파이프라인/서버리스 함수에서 **KMS throttle/에러율** 모니터.

### 12.4.3 DR/BCP
- 리전 장애 대비 **키 복제/백업 전략**(지원되는 모델만).  
- 외부키/온프렘 HSM 연동(HYOK, external KMS)은 **가용성/지연** 고려.

---

## ✅ 12.5 비밀(Secret) 관리: 저장·주입·갱신

### 12.5.1 환경변수 vs 시크릿 스토어
- **환경변수**는 주입이 쉽지만 **노출 위험**(프로세스 목록/덤프/로그/빌드 시스템).  
- **권장**: **시크릿 스토어**(HashiCorp Vault, AWS Secrets Manager, GCP Secret Manager, Azure Key Vault Secrets).  
  - **버전·회전·감사·동적 시크릿**(DB 계정 자동 발급/만료) 지원.  
  - 앱은 **짧은 TTL 토큰**으로 접근(예: Vault AppRole/Kubernetes Auth).

### 12.5.2 애플리케이션 주입 패턴
- **부트스트랩 비밀 최소화**:  
  1) 런타임 ID(EC2/EKS SA/OIDC Workload Identity)로 스토어에 인증  
  2) 필요한 시크릿을 **런타임 fetch** → **메모리 보관**(파일/디스크 금지)  
  3) **키/시크릿 변경 알림**(watcher)로 **핫 로테이션**  
- **Kubernetes**:  
  - **CSI Secrets Store Driver** + KMS provider → 파드에 **tmpfs 볼륨로 주입**(프로세스만 접근).  
  - **Service Account**에 최소 권한 부여(IAM Roles for Service Accounts/Workload Identity).

### 12.5.3 동적 시크릿(Dynamic Secrets)
- DB/MQ/클라우드 자원에 **일회성·짧은 TTL** 자격 발급(사용 후 자동 폐기).  
- **권장**: 장기 정적 비밀 제거, 유출면 줄이기.

---

## ✅ 12.6 비밀분산(Shamir Secret Sharing) & 복구 절차

### 12.6.1 Shamir \(t\)-of-\(n\) 개요
- **목표**: 마스터 비밀\(S\)을 \(n\)개로 나누고, 그 중 \(t\)개 이상이 모여야 복구.  
- 유한체 \(\mathbb{F}_p\) 위 다항식 \(f(x)=S + a_1 x + \dots + a_{t-1}x^{t-1}\), 서로 다른 \(x_i\) 점 \( (x_i, f(x_i)) \)가 **쉐어**.  
- **t 미만** 쉐어로는 정보 이득이 없음(완전 비밀).

### 12.6.2 운영 시나리오
- **HSM 보안 옵서버**나 **루트 CA 키 언락**, **Vault master key** 분산.  
- 실무: **인증된 2인 이상**(dual control), 물리 분산(다른 금고/국가), 정기 점검.

### 12.6.3 교육용 파이썬(소규모 원리 구현)
> 실전에 쓰지 마세요. (난수·에러·사이드채널·안전한 직렬화 등 미포함)
```python
import secrets

# 소수 p (여기서는 256-bit 근처 소수 사용 권장; 데모로 작은 소수는 위험)
# 교육용으로 2^127-1 근처 단순 소수 흉내를 내지만, 실제로는 신뢰 가능한 큰 소수 사용 필수
p = (1<<127) - 1  # 데모용

def poly_eval(coeffs, x):
    # coeffs[0] = S
    res = 0
    for c in reversed(coeffs):
        res = (res * x + c) % p
    return res

def make_shares(secret:int, t:int, n:int):
    assert 1 < t <= n <= 255
    coeffs = [secret] + [secrets.randbelow(p) for _ in range(t-1)]
    shares = []
    used_x = set()
    for _ in range(n):
        x = secrets.randbelow(p-1) + 1
        while x in used_x:
            x = secrets.randbelow(p-1) + 1
        used_x.add(x)
        y = poly_eval(coeffs, x)
        shares.append((x, y))
    return shares

def lagrange_interpolate(points):
    # points: list of (x, y), len>=t
    total = 0
    for i,(xi,yi) in enumerate(points):
        num, den = 1, 1
        for j,(xj,_) in enumerate(points):
            if i == j: continue
            num = (num * (-xj)) % p
            den = (den * (xi - xj)) % p
        # modular inverse
        li = num * pow(den, -1, p) % p
        total = (total + yi * li) % p
    return total  # f(0) = secret

# 데모
S = secrets.randbelow(p)
shares = make_shares(S, t=3, n=5)
S2 = lagrange_interpolate(shares[:3])
assert S == S2
```

### 12.6.4 절차 문서(권고)
- **역할 분리**: 발급자/검증자/감사자.  
- **물리적 분산**: 최소 3곳 이상, 재난 대비.  
- **테이블탑 연습**: 분기마다 **복구 리허설**(타임박스).  
- **인계/철회**: 담당자 변경 시 쉐어 재분배, 구 쉐어 폐기 확인.

---

## ✅ 12.7 서버 없는(Serverless) 키 관리

### 12.7.1 원칙
- 함수(예: AWS Lambda, Cloud Functions, Azure Functions)는 **짧은 수명** · 스케일 아웃 · 디스크 없음.  
- **KMS 통합**을 전제로, **환경변수에 평문 비밀 저장 금지**.  
- **초기 콜드스타트 비용** vs **보안** 밸런스.

### 12.7.2 패턴

**A. Envelope + 캐시**
1) 함수 시작 시 KMS로 **DEK 복호**(EDK→DEK)  
2) **메모리 캐시**(수 분 TTL) 후, 데이터는 AES-GCM으로 로컬 처리  
3) 콜드스타트는 비용↑, 이후 **워밍 상태**에서 빠름

**B. 매 호출 KMS Encrypt/Decrypt**  
- 간단하지만 **지연·비용** 증가 → 저TPS·고보안에 한정.

**C. Parameter/Secret Store 통합**  
- AWS **Secrets Manager**/SSM Parameter Store, GCP Secret Manager, Azure Key Vault → **런타임 fetch + 캐시**.

**D. 이벤트 기반 회전**  
- 새 버전 시크릿 게시 → **람다 환경변수 교체**가 아니라 **런타임 fetch**로 자동 반영.

### 12.7.3 Lambda 예(개념: Python)
```python
import boto3, os, base64, json, time
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

kms = boto3.client('kms')
CACHE = {'edk': None, 'dek': None, 'exp': 0}

KEY_ID = os.environ['CMK_ARN']
EDK_B64 = os.environ['EDK_B64']  # 초기 배포 시 EDK만 환경변수로(평문 금지)

def get_dek():
    now = time.time()
    if CACHE['dek'] and CACHE['exp'] > now:
        return CACHE['dek']
    edk = base64.b64decode(EDK_B64)
    resp = kms.decrypt(CiphertextBlob=edk, KeyId=KEY_ID)
    dek = resp['Plaintext']
    CACHE['dek'] = dek
    CACHE['exp'] = now + 300  # 5분 캐시
    return dek

def handler(event, context):
    aes = AESGCM(get_dek())
    # ... event 처리 (예: S3 객체 암복호) ...
    return {"ok": True}
```

> 포인트: **평문 비밀은 환경변수로 금지**. **EDK**(암호화된 키) 또는 **시크릿 핸들**만 환경에 넣고, 런타임에 KMS로 복호.

---

## ✅ 12.8 키·비밀 거버넌스

### 12.8.1 표준·컴플라이언스
- **FIPS 140-3**, **PCI DSS**, **ISO/IEC 27001/27018**, **HIPAA**, **GDPR** 등 요구 조건을 키 관리에 매핑.  
- **키 경계**: 고객·국가·규제별 분리(리전·계정·프로젝트 단위).  
- **키 수명 정책**: 기본 회전 주기, 긴 수명 키(서명/검증) 예외, 감사 주기.

### 12.8.2 사고 대응(Compromise)
- 징후: 비정상 `Decrypt/Sign`, 정책 변경 시도, 알 수 없는 프린시펄.  
- 대응:
  1) **즉시 비활성화**(disable key) & 접근 차단(IAM).  
  2) **감사 로그 포렌식**(타임라인/영향 범위).  
  3) **회전/재암호화 계획** 실행: 신규 CMK로 DEK 재래핑, 신규 데이터는 즉시 새 키.  
  4) **사후 리뷰**: 경로 차단, 모니터 보강, 플레이북 업데이트.

---

## ✅ 12.9 모범 구성(레퍼런스 아키텍처)

```
[App Pods] --(OIDC SA)--> [Secret Store] --(KMS/HSM)--> [CMK/KEK]
     |                                     ^
     | envelope (DEK local AES-GCM)        |
     +-- audit (success/fail, bytes) ------+
     +-- anomaly alerts -------------------+

[Batch Rewrap Job] -> scan EDK headers -> KMS re-encrypt (v1 -> v2) -> update metadata

[Key Governance]
  - Policy as Code (OPA/Cedar)
  - Rotation SLO (<= 180d), DR drills
  - Compliance reports (FIPS/PCI/GDPR)
```

---

## ✅ 12.10 흔한 실수(미스유스)

1) **평문 비밀을 환경변수/리포지토리/CI 로그에 저장**  
   - 대책: 시크릿 스토어, PR 스캐너(TruffleHog, Gitleaks), 보호 브랜치.  
2) **KMS를 “데이터 암호화 엔진”처럼 과사용**(대용량 파일을 `Encrypt` API로 직접)  
   - 대책: **봉투 암호화**(DEK 로컬 AES-GCM).  
3) **권한 과다(Decrypt everywhere)**  
   - 대책: 서비스별 최소 권한, 조건부 정책(시간/네트워크/태그).  
4) **키 회전 시 대규모 재암호화 강박**  
   - 대책: 새 데이터부터 새 DEK, 구 데이터는 **점진 재래핑/재암호화**(SLO 기반).  
5) **감사·경보 부재**  
   - 대책: 모든 KMS 호출을 중앙 수집, 지표/임계치/알림.

---

## ✅ 12.11 운영 체크리스트

- **키 설계**
  - [ ] CMK/KEK와 DEK 분리(봉투 암호화)  
  - [ ] 키 목적/태그/소유/리전/수명 명세  
  - [ ] 길이: AES-256, 서명은 Ed25519/ECDSA P-256+, RSA 3072+, (PQC 전환 로드맵)

- **권한/정책**
  - [ ] 최소 권한, 조건부 정책(시간/리전/프린시펄 태그)  
  - [ ] 키 사용은 서비스 계정(OIDC/IRSA/Workload Identity)으로  
  - [ ] `Encrypt`/`Decrypt`/`Sign` 분리

- **비밀 주입**
  - [ ] 시크릿 스토어 사용, 동적 시크릿 우선  
  - [ ] 런타임 fetch + 메모리 보관, 로컬 파일/이미지 주입 금지  
  - [ ] 회전 알림 → 핫 로드

- **감사/모니터링**
  - [ ] 모든 KMS 호출 로그, 상관 ID  
  - [ ] 실패율·지연·QPS·데이터 크기 경보  
  - [ ] 비정상 위치/ASN 감지

- **회전/파기**
  - [ ] 키 버전 관리, 정기 회전(≤180d)  
  - [ ] 재래핑 배치 잡/온액세스 재암호화  
  - [ ] 파기 워크플로(대기 기간 + 증적)

- **BCP/DR**
  - [ ] 리전/계정 분리, 백업/복구 절차 검증  
  - [ ] 분기별 테이블탑(Shamir 복구 포함)

---

## ✅ 12.12 미니 플레이북(예: 결제 시스템 CMK 회전)

1) **사전 준비**: 새 CMK 생성(비활성), 정책/Grants 설정, 모니터링 룰 준비  
2) **캔어리**: 일부 워크로드에 새 CMK 사용(`GenerateDataKey` 결과 EDK 헤더 v2 확인)  
3) **스위칭**: 프로비저닝/라이브 데이터에 새 CMK 적용(구 DEK는 허용)  
4) **재래핑**: 백그라운드 작업이 구 EDK를 v2로 점진 업데이트(오류 시 재시도/백오프)  
5) **감사**: 사용 비율 99%↑ 확인 → 구 CMK `disabled` → 대기 기간 후 `schedule destroy`  
6) **회고**: 로그/지표 검토, 문서화 업데이트

---

## ✅ 12.13 FAQ

**Q. EDK를 환경변수에 넣어도 되나요?**  
A. 가능하나 **평문 DEK 금지**. EDK는 **KMS로만 복호 가능**이 전제. 환경변수는 로그/덤프 노출 위험 있으니 **가능하면 시크릿 스토어**에서 런타임 fetch.

**Q. 모든 데이터 즉시 재암호화 해야 하나요?**  
A. 봉투 암호화라면 **필수 아님**. 새 데이터부터 새 DEK/CMK 사용, 구 데이터는 **재래핑/점진**.

**Q. KMS 장애 시?**  
A. **캐시/재시도/백오프**, **회선/리전 이중화**, **중요 트래픽에 DR 키 경로**(정책 기반 fail-open/closed 결정) 설계.

**Q. 키/시크릿이 노출되면?**  
A. 즉시 **비활성화** → **회전** → 영향 범위 재암호화/토큰 폐기 → 사용자 알림/규제 보고 → 사후 대책.

---

## ✅ 12.14 요약 카드

- **봉투 암호화**로 **CMK/DEK 분리**, 데이터는 **로컬 AEAD**, DEK는 **EDK로 저장**.  
- **KMS/HSM**을 중심으로 **정책·감사·회전 자동화**.  
- **시크릿 스토어**와 **동적 시크릿**으로 평문 비밀 제거.  
- **Shamir 분산**으로 루트 비밀을 안전 분할, **복구 리허설** 필수.  
- **서버리스**는 **EDK 주입 + 런타임 복호 + 캐시**가 정석.  
- 전 과정에 **가시성/경보/DR**을 심어 **사고 전제 운영**.

---

## ✅ 12.15 연습문제

1) 봉투 암호화에서 **DEK 캐싱**이 필요한 이유와, 캐시 TTL/폐기 전략을 설계하라.  
2) **KMS 정책**으로 “Encrypt만 가능한 프린시펄”과 “Decrypt 가능한 프린시펄”을 **태그 기반**으로 분리하는 설계를 제시하라.  
3) **Shamir (t,n)** 선택이 가용성/보안에 미치는 영향과, 재난 복구 관점의 권장치를 논하라.  
4) **서버리스 함수**가 고QPS에서 KMS 한도에 걸리지 않도록 하는 아키텍처를(캐시/큐/배치) 제안하라.  
5) 조직에서 **키 파기**를 안전하게 수행하기 위한 **대기 기간·증적·백업 폐기** 절차를 문서로 정리하라.

---

### 부록 A — 키 길이/알고리즘 간단 표
| 목적 | 권장 알고리즘 | 길이 |
|---|---|---|
| 대칭 암호화 | AES-GCM / ChaCha20-Poly1305 | 256-bit |
| HMAC | HMAC-SHA-256/384 | ≥256-bit |
| 서명 | Ed25519 / ECDSA P-256 / RSA | 256 / P-256 / 3072+ |
| 토큰 서명(JWT) | EdDSA(Ed25519) / RS256 | 256 / 2048–3072 |
| KMS DEK | AES-256 | 256-bit |

### 부록 B — 표준/참고(키 관리 관련)
- FIPS 140-3(모듈), NIST SP 800-57(키 관리), SP 800-90A/B/C(RNG), ISO/IEC 11770(Key Management), PCI DSS, NIST 800-63(디지털 아이덴티티).
