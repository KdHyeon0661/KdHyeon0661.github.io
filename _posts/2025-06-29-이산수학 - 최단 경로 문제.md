---
layout: post
title: 이산수학 - 최단 경로 문제
date: 2025-06-29 21:20:23 +0900
category: 이산수학
---
# 최단 경로 문제 (Shortest Path Problem)

## 0. 왜 최단 경로인가?

- 내비게이션의 **최단 시간/거리** 경로
- 네트워크의 **최소 지연/최소 비용 라우팅**
- 게임 AI의 **경로 찾기(A*)**
- 프로젝트·생산관리에서의 **최소 비용/시간 계획**
- 물류/드론/로봇의 **경로 최적화**

**그래프** $$G=(V,E)$$, **가중치** $$w:E\to\mathbb{R}$$, **경로** $$P=v_0\to\cdots\to v_k$$ 의 **총비용**:
$$
w(P)=\sum_{i=1}^{k} w(v_{i-1},v_i).
$$

---

## 1. 문제 유형과 올바른 선택

| 유형 | 조건 | 목표 | 대표 알고리즘 |
|---|---|---|---|
| 단일 시작점 → 단일 도착점 | 일반 가중치(음수 X) | $$s\to t$$ 최단 | **Dijkstra**, A* |
| 단일 시작점 → 전체 | 일반 가중치(음수 X) | $$s\to\forall v$$ | **Dijkstra** |
| 단일 시작점(음수 가능) | 음수 간선/사이클 가능 | 최단 + 음수사이클 판별 | **Bellman–Ford** |
| DAG(사이클 X) | 위상순서 존재 | 전체 최단 | **DAG DP(위상정렬)** |
| 간선 가중치가 0/1 | 0-1 가중 | 전체 최단 | **0–1 BFS** |
| 모든 정점 쌍 | N이 작거나 밀집 | 모든 쌍 최단 | **Floyd–Warshall** |
| 모든 정점 쌍(희소+대규모) | 음수 X | 모든 쌍 최단 | **Johnson**(Dijkstra×V) |
| 휴리스틱 경로 | 유클리드/맨해튼 등 | 실시간 탐색 | **A\*** |

> **요점**: 음수 가중치가 **단 1개라도** 있으면 **Dijkstra 금지**. DAG면 **가장 빠른 건 DAG DP**.

---

## 2. 공통 핵심: Relaxation(완화)

**완화**: 더 짧은 경로를 찾으면 갱신.
$$
\text{if } d[v] > d[u] + w(u,v)\ \text{ then } d[v]\leftarrow d[u]+w(u,v),\ \pi[v]\leftarrow u.
$$

- $$d[v]$$: 출발점에서의 현재 최단 추정
- $$\pi[v]$$: 경로 복원을 위한 **부모**(predecessor)

**경로 복원**: $$t$$ 에서 $$\pi$$를 따라 역추적 후 반전.

---

## 3. 대표 알고리즘 — 정확·안전·빠름

### 3.1 Dijkstra (음수 가중치 **없음**)

- **우선순위 큐(힙)** 기반, **증명된 최적성**
- 인접 리스트 + 힙: $$O\big((V+E)\log V\big)$$

```python
import heapq

def dijkstra(graph, s):
    """
    graph: dict[u] -> list[(v, w)]  (유향/무향 모두 가능, 무향은 양방향 넣기)
    s: 시작 정점
    return: dist, parent
    """
    INF = float('inf')
    dist = {u: INF for u in graph}
    parent = {u: None for u in graph}
    dist[s] = 0
    pq = [(0, s)]
    while pq:
        d, u = heapq.heappop(pq)
        if d != dist[u]:
            continue  # stale
        for v, w in graph[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                parent[v] = u
                heapq.heappush(pq, (nd, v))
    return dist, parent

def restore_path(parent, t):
    path=[]
    cur=t
    while cur is not None:
        path.append(cur)
        cur = parent[cur]
    return path[::-1]
```

**예제(무향 그래프)**

```python
g = {
  0: [(1, 2), (2, 5)],
  1: [(0, 2), (2, 1), (3, 3)],
  2: [(0, 5), (1, 1), (3, 1)],
  3: [(1, 3), (2, 1)]
}
dist, parent = dijkstra(g, 0)
print(dist[3])              # 0->1->2->3 비용: 2+1+1=4
print(restore_path(parent, 3))
```

> **자주 하는 실수**: 음수 간선(할인/캐시백 같은 모델)에서 Dijkstra 사용 → **오답**!

---

### 3.2 Bellman–Ford (음수 간선/사이클 가능)

- $$V-1$$ 회 완화 후 **한 번 더** 완화되면 **음수 사이클 존재**
- 시간: $$O(V\cdot E)$$

```python
def bellman_ford(n, edges, s):
    """
    n: 정점 수 (0..n-1)
    edges: list of (u, v, w)
    s: 시작 정점
    return: (ok, dist, parent, neg_cycle_nodes)
      ok=False 이면 음수 사이클 관여
    """
    INF = float('inf')
    dist = [INF]*n
    parent = [None]*n
    dist[s] = 0
    for _ in range(n-1):
        updated = False
        for u, v, w in edges:
            if dist[u] != INF and dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                parent[v] = u
                updated = True
        if not updated:
            break
    # 음수 사이클 탐지
    neg_cycle_nodes = set()
    for u, v, w in edges:
        if dist[u] != INF and dist[v] > dist[u] + w:
            neg_cycle_nodes.add(v)
    # 사이클 전파(도달 가능한 모든 영향 노드 표시)
    if neg_cycle_nodes:
        # BFS/DFS로 전파
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            adj[u].append(v)
        from collections import deque
        q = deque(list(neg_cycle_nodes))
        seen = set(neg_cycle_nodes)
        while q:
            x = q.popleft()
            for y in adj[x]:
                if y not in seen:
                    seen.add(y); q.append(y)
        return False, dist, parent, seen
    return True, dist, parent, set()
```

**예제(음수 간선 포함, 사이클 없음)**

```python
n=4
edges=[(0,1,1),(1,2,-2),(2,3,1),(0,3,5)]
ok, dist, parent, bad = bellman_ford(n, edges, 0)
print(ok, dist, bad)  # True, [0,1,-1,0], set()
```

**예제(음수 사이클)**

```python
n=3
edges=[(0,1,1),(1,2,1),(2,1,-3)]  # 1<->2 사이클 가중: -2
ok, dist, parent, bad = bellman_ford(n, edges, 0)
print(ok, bad)  # False, {1,2} 등
```

> **SPFA**(Queue 기반 가속)는 평균적으로 빠르지만 **최악 TLE**. 대회/프로덕션에서는 **Bellman–Ford 정석** 권장.

---

### 3.3 DAG 최단 경로 (위상 정렬 기반 DP)

- **음수 가중치 있어도 OK** (**사이클이 없으니** 안전)
- 시간: $$O(V+E)$$

```python
from collections import defaultdict, deque

def dag_shortest_paths(n, edges, s):
    """
    n: 0..n-1, edges:(u,v,w) with DAG
    """
    indeg=[0]*n
    adj=defaultdict(list)
    for u,v,w in edges:
        adj[u].append((v,w))
        indeg[v]+=1
    q=deque([i for i in range(n) if indeg[i]==0])
    topo=[]
    while q:
        u=q.popleft()
        topo.append(u)
        for v,w in adj[u]:
            indeg[v]-=1
            if indeg[v]==0: q.append(v)
    # topo 길이가 n이 아니면 DAG 아님
    INF=float('inf')
    dist=[INF]*n; parent=[None]*n
    dist[s]=0
    for u in topo:
        if dist[u]==INF: continue
        for v,w in adj[u]:
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                parent[v] = u
    return dist, parent, topo
```

**예제**

```python
n=5
edges=[(0,1,3),(0,2,1),(2,1,1),(1,3,2),(2,3,5),(3,4,1)]
dist, parent, topo = dag_shortest_paths(n, edges, 0)
print(topo)         # 위상 순서
print(dist, parent) # 0->2->1->3->4 등
```

---

### 3.4 0–1 BFS (가중치가 0 또는 1)

- 양방향 덱 이용: **0 가중치**는 앞에 push, **1 가중치**는 뒤에 push
- 시간: $$O(V+E)$$

```python
from collections import deque

def zero_one_bfs(n, adj01, s):
    """
    n: 0..n-1
    adj01[u] = list of (v, w) with w in {0,1}
    """
    INF=10**18
    dist=[INF]*n
    dist[s]=0
    dq=deque([s])
    while dq:
        u=dq.popleft()
        for v,w in adj01[u]:
            nd=dist[u]+w
            if nd < dist[v]:
                dist[v]=nd
                if w==0:
                    dq.appendleft(v)
                else:
                    dq.append(v)
    return dist
```

---

### 3.5 Floyd–Warshall (모든 쌍 최단, 간단·밀집 그래프)

- 점화식:
  $$
  D^{(k)}[i,j]=\min\big(D^{(k-1)}[i,j],\ D^{(k-1)}[i,k]+D^{(k-1)}[k,j]\big).
  $$
- 시간 $$O(V^3)$$, 공간 $$O(V^2)$$
- **음수 간선 가능**. **음수 사이클 탐지**는 **대각성분**으로 판별: 갱신 후 $$D[i][i]<0$$ 이면 사이클.

```python
def floyd_warshall(n, mat):
    """
    mat: n x n, mat[i][j] = weight or inf, mat[i][i]=0
    return: (dist, has_neg_cycle)
    """
    dist = [row[:] for row in mat]
    for k in range(n):
        for i in range(n):
            dik = dist[i][k]
            if dik==float('inf'): continue
            for j in range(n):
                v = dik + dist[k][j]
                if v < dist[i][j]:
                    dist[i][j] = v
    has_neg = any(dist[i][i] < 0 for i in range(n))
    return dist, has_neg
```

---

### 3.6 Johnson (희소 + 모든 쌍 + 음수 X)

- **1) Bellman–Ford**로 **잠재치(포텐셜) $$h$$** 계산(음수 없음 보장)
- **2) 재가중치**: $$w'(u,v)=w(u,v)+h(u)-h(v)\ge 0$$
- **3) 모든 정점에서 Dijkstra**
- 복원: $$dist(u,v)=d'_{u}(v) - h(u) + h(v)$$
- 시간: $$O(V\cdot E\log V)$$(희소 그래프에서 유리)

> 구현은 길어 생략했지만, 실전에서는 **FW보다 대규모에 강함**.

---

### 3.7 A* (휴리스틱 탐색, 실시간 경로)

- 우선순위: $$f(n)=g(n)+h(n)$$
  - $$g(n)$$: 시작→현재 비용
  - $$h(n)$$: **휴리스틱**(목표까지 추정 비용)
- **Admissible(낙관적)**: 절대 과대평가하지 않음 → **최적 보장**
- **Consistent(삼각부등식)**: $$h(u)\le w(u,v)+h(v)$$ → **재방문 감소**

```python
import heapq

def astar(graph, s, t, heuristic):
    """
    graph: dict[u] -> list[(v, w)]
    heuristic: h(v) 함수 (낙관적/일관적이면 최적)
    """
    INF=float('inf')
    g={u:INF for u in graph}; parent={u:None for u in graph}
    g[s]=0
    pq=[(heuristic(s), s)]  # f = g+h
    in_open = {s}
    while pq:
        f,u = heapq.heappop(pq)
        if u==t:
            # 복원
            path=[]; cur=t
            while cur is not None:
                path.append(cur); cur=parent[cur]
            return g[t], path[::-1]
        for v,w in graph[u]:
            cand = g[u]+w
            if cand < g[v]:
                g[v]=cand
                parent[v]=u
                heapq.heappush(pq, (g[v]+heuristic(v), v))
    return INF, None
```

**그리드 지도에서의 h**
- 맨해튼: $$h(x,y)=|x_t-x|+|y_t-y|$$ (직교 이동)
- 유클리드: $$h=\sqrt{\Delta x^2+\Delta y^2}$$ (대각 허용)
- 일관성 지키도록 스텝 비용과 맞추기.

---

## 4. 경로 복원·검증 유틸

```python
def path_from_parent(parent, s, t):
    path=[]
    cur=t
    while cur is not None:
        path.append(cur)
        if cur==s: break
        cur=parent[cur]
    return path[::-1] if path and path[-1]==s else None

def verify_path(graph, path, expected_cost=None):
    if not path or len(path)<1: return False
    cost=0
    pos=set(graph.keys())
    for u,v in zip(path, path[1:]):
        # u->v 존재?
        w = None
        for x,ww in graph[u]:
            if x==v:
                w=ww; break
        if w is None: return False
        cost += w
    return (True if expected_cost is None else cost==expected_cost), cost
```

---

## 5. 케이스 스터디

### 5.1 “내비게이션” 스타일 (비음수, 희소): **Dijkstra vs A\***

- **지도 그래프**: 교차로=정점, 도로=간선, **비용=시간**(거리/제한속도)
- **실시간 탐색**은 **A\***: 휴리스틱(공중거리/도로망 대략치)로 탐색량 절감
- **정적 전체 테이블**은 **Dijkstra(다중 기점)** 또는 **Johnson**으로 전처리 가능

### 5.2 “요금 할인/캐시백” (음수 간선 가능): **Bellman–Ford**

- 쿠폰 적용 시 일시적 **음수**가중 등장
- **음수 사이클**(무한히 이득) 감지 → 정책/모델 오류 플래그

### 5.3 “공정·과정 계획”(DAG): **DAG DP**

- 작업간 선후(의존) DAG + **소요 시간** = 가장 빠른 완성 시간
- **위상 정렬** 후 단방향 DP: 속도·단순성 최고

### 5.4 “이진 가중 비용(0/1)” : **0–1 BFS**

- 예: 도로 톨게이트(0=무료, 1=유료), 네트워크 hop-패널티
- 일반 Dijkstra보다 **상수배 빠름**

### 5.5 “모든 쌍 경로” (작은 N): **Floyd–Warshall**

- 수십~수백 노드, **경로 재구성**(중간지점 테이블)도 용이
- 동적 업데이트(한 간선 변화)에는 비효율 → Johnson + 증분 업데이트 고려

---

## 6. 성능·정확성 팁

- **Dijkstra**
  - **음수 간선 금지**(단 한 개라도 있으면 실패).
  - 힙에서 **중복 push 허용** + pop 시 **stale 검사**가 Python에선 빠름.
- **Bellman–Ford**
  - **일찍 멈춤**(업데이트 없으면 break).
  - 음수 사이클 영향 정점 전파해서 **“의미 없는” 최단 없음** 표시.
- **Floyd–Warshall**
  - Python 3중 루프는 느림 → **PyPy**/NumPy(단, 최소연산은 브로드캐스팅 난해) 고려.
  - **대각성분 음수**로 음수 사이클 감지.
- **A\***
  - 휴리스틱은 **Admissible & Consistent** → 최적성+재방문 최소화.
  - 그리드: **맨해튼/유클리드/쳄버 거리**를 **간선 비용 단위**와 맞추기.
- **Johnson**
  - 희소 그래프에 이상적. **BF 1회 + Dijkstra×V**.
  - 음수 간선 O, 음수 사이클 X.

**자료구조**
- 인접 리스트(dict/list) vs 인접 행렬(list of list).
- 희소 → **인접 리스트** + 힙.
- 밀집 → 인접 행렬 + Floyd–Warshall.

**수치/특수**
- **INF**는 `float('inf')` 사용(덧셈 안전성 OK).
- **도달불가**는 `INF` 그대로 둠.
- 부동소수 오차가 싫다면 **정수 가중치** 유지.

---

## 7. 실전 샘플 시나리오 세트

### 7.1 단일 소스 다목적(Dijkstra) + 경로 복원

```python
g = {
  'S': [('A', 2), ('B', 5)],
  'A': [('B', 1), ('C', 3)],
  'B': [('C', 2), ('D', 4)],
  'C': [('D', 1)],
  'D': []
}
dist, parent = dijkstra(g, 'S')
path = restore_path(parent, 'D')
ok, cost = verify_path(g, path, expected_cost=dist['D'])
print(dist)  # 각 정점까지 최단
print(path, ok, cost)
```

### 7.2 음수 간선 포함(BF) — 정책 검증

```python
n=5
edges=[
  (0,1,2),
  (1,2,-5),   # 할인
  (2,3,1),
  (3,4,2),
  (0,4,10)
]
ok, dist, parent, neg = bellman_ford(n, edges, 0)
print("ok:", ok, "neg_nodes:", neg)
```

### 7.3 DAG 일정(Topological DP)

```python
n=6
edges=[(0,1,2),(0,2,4),(1,3,7),(2,3,1),(3,4,3),(2,5,2)]
dist, parent, topo = dag_shortest_paths(n, edges, 0)
print("topo:", topo)
print("dist:", dist)
```

### 7.4 0–1 BFS(유료차선 최소화)

```python
n=4
adj01=[
  [(1,0),(2,1)],  # 0->1 무료, 0->2 유료
  [(3,1)],        # 1->3 유료
  [(3,0)],        # 2->3 무료
  []
]
print(zero_one_bfs(n, adj01, 0))  # [0,0,1,1] 등
```

### 7.5 A* 그리드(맨해튼 h)

```python
def grid_neighbors(x, y, W, H):
    for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
        nx,ny=x+dx,y+dy
        if 0<=nx<W and 0<=ny<H:
            yield nx,ny

def grid_to_graph(costs):  # costs[y][x]
    H=len(costs); W=len(costs[0])
    g={}
    for y in range(H):
        for x in range(W):
            u=(x,y); g[u]=[]
            for nx,ny in grid_neighbors(x,y,W,H):
                g[u].append(((nx,ny), costs[ny][nx]))
    return g

costs=[
    [1,1,5,1],
    [9,1,1,1],
    [1,1,1,1],
]
g = grid_to_graph(costs)
tgt=(3,2)
h=lambda p: abs(tgt[0]-p[0])+abs(tgt[1]-p[1])  # 맨해튼
dist, path = astar(g, (0,0), tgt, h)
print(dist, path)
```

---

## 8. 확장 주제 (한눈 개요)

- **K-최단 경로**: Yen/Eppstein (중복 방지/편차 경로 관리)
- **다중 출발점/다중 도착점**: 슈퍼소스/슈퍼싱크 추가
- **제약 최단 경로**(최소 비용 + 제약): Lagrangian Relaxation/Label-setting(다중 라벨)
- **동적 경로 계획**: LPA*/D\* Lite (지형 변경 반영)
- **최단 경로 트리(SPT)** 대 **MST**: 목적 완전 다름(가중합 vs 거리)

---

## 9. 디버깅 체크리스트

- [ ] **음수 간선**이 있는가? → Dijkstra 금지, BF/Johnson.
- [ ] **도달 불가** 처리(거리=INF)했는가?
- [ ] **경로 복원** 시 부모 None 루프 방지했는가?
- [ ] **무향**은 양방향 간선 추가했는가?
- [ ] **힙 중복** 처리: pop시 dist 비교로 **stale 제거**했는가?
- [ ] Floyd–Warshall에서 **대각 음수** 확인(음수 사이클)?
- [ ] A*의 **휴리스틱 일관성** 보장했는가?

---

## 10. 요약 표

| 알고리즘 | 쓰임새 | 가중치 | 복잡도 | 강점 | 주의 |
|---|---|---|---|---|---|
| Dijkstra | 단일소스 | 비음수 | $$(V+E)\log V$$ | 빠름·안정 | 음수 금지 |
| Bellman–Ford | 단일소스 | 음수 OK | $$VE$$ | 음수사이클 검출 | 느림(크면 최적화) |
| DAG DP | DAG | 음수 OK | $$V+E$$ | 매우 빠름 | DAG만 |
| 0–1 BFS | 0/1 가중 | 0/1 | $$V+E$$ | 매우 빠름 | 0/1만 |
| Floyd–Warshall | 모든쌍 | 음수 OK | $$V^3$$ | 구현 쉬움 | 큰 V 느림 |
| Johnson | 모든쌍 희소 | 음수 OK(사이클 X) | $$V\cdot E\log V$$ | 대규모 희소 | BF 필요 |
| A* | 실시간 단일쌍 | 비음수 | 휴리스틱 의존 | 탐색량 절감 | h의 적합성 |
