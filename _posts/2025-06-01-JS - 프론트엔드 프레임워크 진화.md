---
layout: post
title: JavaScript - 프론트엔드 프레임워크 진화
date: 2025-06-01 20:20:23 +0900
category: JavaScript
---
# 프론트엔드 프레임워크 진화: 과거, 현재, 그리고 미래

## 0. 한 장 요약

- 초기 웹: 정적 문서 + 간단한 DOM 스크립팅 → 유지보수와 복잡성에서 한계
- jQuery: DOM 조작·Ajax 표준화로 생산성 비약 → 규모 커지면 구조 부재 문제
- AngularJS: 프런트 MVC 도전(양방향 바인딩/DI) → 대형화 시 성능·복잡성 이슈
- React: UI = f(state) 컴포넌트 패러다임, 단방향 데이터흐름, 라이프사이클 가벼움
- Vue: 접근성 높은 템플릿·반응성 시스템, 점진적 도입 용이
- Angular(2+): TS·RxJS·DI 기반의 엔터프라이즈급 프레임워크
- Svelte: 컴파일러 시대 개막(런타임 오버헤드 최소화)
- 최신 흐름: 서버 컴포넌트, 스트리밍 SSR, 아일랜드 아키텍처, 엣지 렌더링, 시그널 기반 반응성, 번들·러너의 진화(Vite, Turbopack)

---

## 1. HTML + CSS + JavaScript (초기 웹, ~2005)

### 무엇이었나
- 서버 사이드 렌더링(SSR)이 기본(PHP/JSP/ASP)
- 자바스크립트는 폼 검증, 간단한 인터랙션 정도

### 코드 스냅샷
```html
<button id="btn">클릭</button>
<p id="msg"></p>
<script>
  document.getElementById('btn').addEventListener('click', () => {
    document.getElementById('msg').textContent = '안녕하세요';
  });
</script>
```

### 한계
- 화면 상태가 늘어날수록 DOM 조작 코드가 난립
- 재사용과 모듈성의 부재 → 팀 개발·유지보수 어려움

---

## 2. jQuery 시대(2006~2012)

### 무엇을 해결했나
- 셀렉터·이벤트·Ajax를 단일 API로 추상화
- IE 호환성 악몽 완화

```js
$('#btn').on('click', () => $('#msg').text('안녕하세요'));
$.getJSON('/api/items', (items) => {
  const html = items.map(x => `<li>${x.name}</li>`).join('');
  $('#list').html(html);
});
```

### 한계
- 상태를 중심으로 한 구조가 없으니 규모가 커질수록 스파게티화
- 화면 = DOM 조작 스크립트의 결과물 → 예측가능성 낮음

---

## 3. AngularJS(2010~2016): 브라우저 MVC의 실험

### 기여
- 양방향 바인딩, 템플릿, DI, 라우팅 등 “앱 프레임워크” 패키지
- 폼 검증, 지시자, 서비스 등 도메인 구성이 가능

```html
<div ng-controller="Ctrl as vm">
  <input ng-model="vm.name" />
  <p>Hello {{ vm.name }}</p>
</div>
<script>
  angular.module('app', [])
    .controller('Ctrl', function(){ this.name='World'; });
</script>
```

### 한계
- 양방향 바인딩의 다이제스트 루프 비용
- 학습 곡선과 프레임워크 복잡성

---

## 4. React(2013~): UI = f(state)의 확산

### 핵심 아이디어
- UI는 상태의 순수 함수:  
  $$ UI = f(\text{state}) $$
- 단방향 데이터 흐름, 컴포넌트 모델, 가상 DOM, 선언적 렌더링

```jsx
import { useState } from 'react';

export default function Counter(){
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(c => c + 1)}>
      {count}
    </button>
  );
}
```

### 영향
- 예측가능성과 테스트 용이성 상승
- 상태 관리/라우터/SSR/빌더 등 방대한 생태계 성장
- 함수형 사고·불변성·리액티브 패턴 대중화

---

## 5. Vue(2014~): 친화적인 템플릿 + 반응성

### 특징
- 템플릿 중심의 선언적 문법, 컴포넌트 SFC(.vue)
- 반응성 시스템(프로퍼티 추적)으로 직관적 상태 업데이트
- 점진적 도입(기존 jQuery 페이지 일부만 Vue로)

```vue
<template>
  <input v-model="text" />
  <p>{{ text }}</p>
</template>
<script>
export default { data(){ return { text: '' } } }
</script>
```

---

## 6. Angular(2+)(2016~): 엔터프라이즈급 풀스택 프론트

### 특징
- TypeScript/DI/NgModule/CLI/스캐폴딩
- RxJS 기반 비동기 스트림
- 방대한 공식 기능(폼, 라우팅, i18n, 빌드)

```ts
@Component({
  selector: 'app-hello',
  template: `<input [(ngModel)]="name"><p>Hello {{name}}</p>`
})
export class HelloComponent { name = 'World'; }
```

---

## 7. Svelte(2019~): 컴파일러가 만드는 런타임 없는 반응성

### 특징
- 런타임 대신 컴파일 단계에서 반응성 코드 생성
- 번들 가볍고 실행 빠름
- 문법 직관적, 러닝 커브 낮음

```svelte
<script> let count = 0; </script>
<button on:click={() => count++}>{count}</button>
```

---

## 8. 현대 프레임워크의 공통 흐름(정리)

| 주제 | 공통 방향 |
|---|---|
| 컴포넌트 모델 | UI를 독립 모듈로 나눠 재사용·격리 |
| 상태 중심 | UI = f(state) 사고, 불변/반응성 모델 |
| 렌더링 다양화 | CSR, SSR, SSG, ISR, Streaming, RSC |
| 엣지/분산 | 엣지 함수, CDN 캐시, 데이터 페칭 최적화 |
| 개발경험 | Vite/스냅 HMR, TS, ESLint/Prettier, Vitest |
| 성능 | 코드 분할, 지연 로딩, 이미지 최적화, 메타프레임워크 내장 도구 |

---

## 9. 동일 요구사항, 다른 프레임워크 구현 비교

요구: “검색 가능한 목록(필터), 선택 항목 강조, 항목 클릭시 상세 표시”.

### 9-1. 바닐라 JS
```html
<input id="q" placeholder="검색">
<ul id="list"></ul>
<div id="detail"></div>
<script>
  const data = [{id:1,name:'Alpha'},{id:2,name:'Beta'}];
  const q = document.getElementById('q');
  const ul = document.getElementById('list');
  const detail = document.getElementById('detail');

  function render(){
    const term = q.value.toLowerCase();
    ul.innerHTML = data
      .filter(x => x.name.toLowerCase().includes(term))
      .map(x => `<li data-id="${x.id}">${x.name}</li>`).join('');
  }
  q.addEventListener('input', render);
  ul.addEventListener('click', e => {
    const id = Number(e.target.dataset.id);
    const item = data.find(x => x.id===id);
    detail.textContent = item ? JSON.stringify(item) : '';
  });
  render();
</script>
```

### 9-2. React
```jsx
function App(){
  const [term, setTerm] = useState('');
  const [sel, setSel] = useState(null);
  const data = useMemo(()=>[{id:1,name:'Alpha'},{id:2,name:'Beta'}],[]);
  const list = data.filter(x=>x.name.toLowerCase().includes(term.toLowerCase()));
  return (
    <>
      <input value={term} onChange={e=>setTerm(e.target.value)} placeholder="검색" />
      <ul>
        {list.map(x =>
          <li key={x.id} onClick={()=>setSel(x)} style={{fontWeight: sel?.id===x.id ? '700':'400'}}>
            {x.name}
          </li>
        )}
      </ul>
      <pre>{sel ? JSON.stringify(sel,null,2) : ''}</pre>
    </>
  );
}
```

### 9-3. Vue
```vue
<template>
  <input v-model="term" placeholder="검색" />
  <ul>
    <li v-for="x in filtered" :key="x.id" @click="sel = x" :style="{fontWeight: sel?.id===x.id ? '700':'400'}">
      {{ x.name }}
    </li>
  </ul>
  <pre>{{ sel ? JSON.stringify(sel,null,2) : '' }}</pre>
</template>
<script>
export default {
  data(){ return { term:'', sel:null, data:[{id:1,name:'Alpha'},{id:2,name:'Beta'}] } },
  computed:{ filtered(){ return this.data.filter(x=>x.name.toLowerCase().includes(this.term.toLowerCase())) } }
}
</script>
```

### 9-4. Svelte
```svelte
<script>
  let term = '';
  let sel = null;
  const data = [{id:1,name:'Alpha'},{id:2,name:'Beta'}];
  $: filtered = data.filter(x=>x.name.toLowerCase().includes(term.toLowerCase()));
</script>

<input bind:value={term} placeholder="검색" />
<ul>
  {#each filtered as x}
    <li on:click={() => sel = x} style="font-weight:{sel?.id===x.id ? 700 : 400}">
      {x.name}
    </li>
  {/each}
</ul>
<pre>{sel ? JSON.stringify(sel,null,2) : ''}</pre>
```

요약: 바닐라는 즉시성·의존성 없음, 규모 커지면 상태 동기화 비용 증가. 프레임워크는 상태 주도 UI를 간결하게 유지, 러닝 커브와 번들 비용이 존재.

---

## 10. 렌더링 전략의 진화

| 전략 | 개념 | 장점 | 주의 |
|---|---|---|---|
| CSR | 클라이언트에서 렌더 | 상호작용 빠름 | 초기 빈문서, SEO/TTFB 불리 |
| SSR | 서버 렌더 + 하이드레이션 | 퍼스트 페인트 빠름, SEO | 하이드레이션 비용 |
| SSG/ISR | 빌드 시 정적 생성/증분 | 캐시 친화 | 동적성 요구시 보강 필요 |
| Streaming | HTML 스트림으로 점진 렌더 | LCP 개선 | 서버·러너 통합 필요 |
| RSC | 서버 컴포넌트 | 번들 축소, 데이터 근접성 | 개념 복잡, 생태계 적응기 |
| Islands | 상호작용 섬만 하이드레이션 | JS 최소화 | 설계/분할 전략 요구 |
| Edge | 사용자 근처 서버 | 지연 최소화 | 플랫폼 제약, 콜드스타트 |

실무 팁
- 콘텐츠 중심: SSG + 점진적 강화
- 대규모 동적: SSR + 스트리밍 + 캐시
- 복합: 아일랜드 또는 RSC 도입, 상호작용 섬만 하이드레이션

---

## 11. 최신 런타임·반응성 트렌드

- Signals(시그널): SolidJS/Preact Signals/Angular Signals. 의존성 추적 기반 미세 렌더.
- Server Actions/Mutations: 서버 함수 직접 호출로 데이터 변경 단순화.
- 폼과 스트림: progressive enhancement, 서버 검증·낙관적 UI 조합.

간단 시그널 예(개념적):
```js
import { signal, effect } from '@preact/signals-core';
const count = signal(0);
effect(() => { console.log('렌더', count.value); });
count.value++; // 필요한 곳만 업데이트
```

---

## 12. 성능 체크리스트(프레임워크 무관)

- 코드 분할과 지연 로딩: 라우트별 청크, 컴포넌트 레벨 dynamic import
- 이미지: width/height 지정, webp/avif, lazy, responsive srcset
- 데이터: 캐싱 우선(HTTP 캐시, SWR/React Query), 과페칭 금지
- 렌더: 리스트 가상화(수천 행), 메모이제이션(useMemo/computed/$:)
- CSS: critical CSS 인라인, 나머지 지연, 컨테이너 쿼리 고려
- 폰트: preload, font-display, 서브셋팅
- 측정: Web Vitals(LCP/CLS/INP), User Timing API, DevTools Performance

예: 사용자 코드 측정
```js
performance.mark('start');
// 비싼 작업
performance.mark('end');
performance.measure('task', 'start', 'end');
console.log(performance.getEntriesByName('task')[0].duration);
```

---

## 13. 접근성·국제화·보안 필수 포인트

- A11y: ARIA 롤/라벨/키보드 내비게이션, 포커스 관리, 모달 트랩
- I18n: ICU 메시지, RTL 지원, 날짜·숫자·시간대 Intl API
- 보안: CSP, Trusted Types, DOM Sanitization(특히 HTML 주입), 쿠키 설정(SameSite, Secure), CSRF·XSS·클릭재킹

---

## 14. 팀·프로덕트 관점의 선택 기준

의사결정 트리

1) 페이지 수가 적고 상호작용이 단순한가?  
→ 바닐라/경량 라이브러리 + SSG.

2) SPA 수준의 복잡 상태·상호작용이 많은가?  
→ React/Vue/Svelte 중 팀 숙련도 높은 것.

3) 엔터프라이즈 표준·강한 타입·도구 일체화를 원하나?  
→ Angular(2+).

4) 최초 페인트·SEO가 매우 중요한가?  
→ 메타프레임워크(Next/Nuxt/SvelteKit) SSR/Streaming/캐시.

5) 극저지연·글로벌 타깃인가?  
→ Edge Functions + 데이터 근접 캐시 전략.

6) 번들 크기와 런타임 오버헤드에 민감한가?  
→ Svelte/Signals/Islands, 또는 RSC로 전송 JS 최소화.

---

## 15. 마이그레이션 전략(레거시 → 현대)

- 식별: 가장 변경이 잦고 결합도 높은 UI부터 컴포넌트화
- 점진: jQuery 섞인 페이지에서 일부 섹션만 프레임워크 삽입(마이크로 프론트엔드도 고려)
- 계측: 전/후 성능·오류 지표 비교(Web Vitals, Sentry)
- 리스크 관리: 라우팅/상태/폼 검증/빌드 파이프라인을 기준 모듈로 표준화

---

## 16. 학습 로드맵(개인 기준)

1) 바닐라 JS: ES 모듈, DOM, Fetch, async/await  
2) 접근성·네트워크·보안 기초  
3) 하나의 프레임워크 심화 + 메타 프레임워크(Next/Nuxt/SvelteKit 중 택1)  
4) 데이터 레이어(SWR/React Query/RTK Query)와 캐싱  
5) SSR/Streaming/Edge, 배포 파이프라인(CI/CD), 관측(로그·트레이싱)

---

## 17. 타임라인 재정리(확장)

```
1990s   정적 문서, 서버 렌더
2006    jQuery: DOM/Ajax 표준화
2010    AngularJS: 프런트 MVC, 양방향 바인딩
2013    React: 컴포넌트 + 단방향 + 가상 DOM
2014    Vue: 템플릿 반응성, 점진 도입
2016    Angular(2+): TS/RxJS/DI, 엔터프라이즈
2019    Svelte: 컴파일러, 경량 런타임
2020s   메타프레임워크(Next/Nuxt/SvelteKit), RSC, Islands, Edge, Signals
```

---

## 18. 결론 요약 표

| 시대 | 해결책 | 얻은 것 | 치른 대가 |
|---|---|---|---|
| 초기 | DOM 직접 조작 | 간단성 | 구조 부재 |
| jQuery | API 추상화 | 생산성, 호환성 | 규모화 어려움 |
| AngularJS | MVC | 구조화 시도 | 성능·복잡성 |
| React/Vue | 상태→UI | 예측가능성, 생태계 | 러닝 커브/번들 |
| Angular(2+) | TS·DI·RxJS | 엔터프라이즈 일관성 | 프레임워크 무게 |
| Svelte | 컴파일링 | 성능/경량 | 생태계 상대적 작음 |
| 최신 | RSC/Islands/Edge | 전송 JS 최소화, 저지연 | 개념 복잡·도구 숙련 필요 |

---

## 19. 참고 링크

- State of JS 설문: https://stateofjs.com/
- React: https://react.dev/
- Vue: https://vuejs.org/
- Svelte: https://svelte.dev/
- Angular: https://angular.io/
- Next.js: https://nextjs.org/
- Nuxt: https://nuxt.com/
- SvelteKit: https://kit.svelte.dev/