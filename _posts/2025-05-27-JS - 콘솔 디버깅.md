---
layout: post
title: JavaScript - 콘솔 디버깅
date: 2025-05-27 19:20:23 +0900
category: JavaScript
---
# 콘솔 디버깅 꿀팁 모음 (console 객체 제대로 활용하기)

## 0. 콘솔 디버깅이 왜 강력한가?

- **낮은 진입장벽**: 어디서든 `console.log()` 한 줄로 시작
- **관찰 가능성(Observability)** 향상: 상태/흐름/시간/빈도/스택을 즉시 확인
- **비침습**: 런타임 행위를 바꾸지 않고도 추적 가능
- **도구 생태계와 결합**: DevTools, Performance, Source Map, 테스트 러너와 자연스럽게 연결

---

## 1. 출력 레벨: `log` / `info` / `warn` / `error`

```js
console.log('일반 메시지', { scope: 'auth', user: 'kim' });
console.info('정보', new Date().toISOString());
console.warn('경고: 임계값 근접', { value: 95, threshold: 100 });
console.error('오류', new Error('DB 연결 실패'));
```

- 브라우저 콘솔은 레벨별 시각적 구분(아이콘/색)을 제공.
- **필터**로 특정 레벨만 보기 쉽다.
- Node.js에서도 레벨은 구분되지만 색/아이콘은 터미널/환경에 따라 다르다.

### 서브스티튜션 문자열(printf 스타일)
```js
console.log('사용자: %s, 나이: %d, 객체: %o', 'kim', 28, { a: 1 });
console.log('%c강조된 로그', 'color: white; background: black; padding: 2px 4px;');
```
- `%s`, `%d`, `%i`, `%f`, `%o`(DOM/JS 객체), `%O`(깊은 객체), `%c`(CSS 스타일; 브라우저)

---

## 2. 표 형태로 시각화: `console.table()`

```js
const users = [
  { id: 1, name: 'Kim', age: 28, role: 'admin' },
  { id: 2, name: 'Lee', age: 34, role: 'user'  },
  { id: 3, name: 'Park', age: 23, role: 'user'  },
];
console.table(users);                 // 전체 컬럼
console.table(users, ['id', 'name']); // 특정 컬럼만
```

- 배열/객체 컬렉션의 **가독성 극대화**.
- 빠르게 **스키마/값 범위**를 훑을 때 적합.

---

## 3. 구조 관찰: `console.dir()` / `console.dirxml()` / DOM

```js
const el = document.querySelector('h1');
console.dir(el);       // 속성 중심(자바스크립트 뷰)
console.dirxml(el);    // 브라우저에서 DOM 트리(XML) 형태 (지원 브라우저 한정)
```

- **`dir`**: 속성/프로토타입 위주, **JS 객체 시점**으로 본다.
- **`dirxml`**: 요소 트리 시각화(브라우저 의존).

---

## 4. 그룹핑으로 맥락 유지: `group` / `groupCollapsed` / `groupEnd`

```js
console.group('요청 처리');
console.log('요청 ID:', req.id);
console.group('검증 단계');
console.log('스키마 OK');
console.log('권한 OK');
console.groupEnd();
console.group('DB 단계');
console.log('쿼리 실행', { sql, ms: 12 });
console.groupEnd();
console.groupEnd();
```

- **관련 로그를 묶어** 한눈에 보기 좋다.
- `groupCollapsed()`로 **접힌 상태** 시작 → 필요할 때만 펼쳐서 확인.

---

## 5. 시간 측정: `time` / `timeLog` / `timeEnd` 와 Performance API

```js
console.time('pipeline');
stepA();
console.timeLog('pipeline', 'A 완료'); // 경과 시점 기록
stepB();
console.timeEnd('pipeline');           // 총 소요 시간 출력
```

- 마이크로 옵티마이징에는 **Performance API**가 더 정밀.
```js
performance.mark('A-start');
stepA();
performance.mark('A-end');
performance.measure('A', 'A-start', 'A-end');
const [m] = performance.getEntriesByName('A'); // duration(ms)
console.log(m.duration);
performance.clearMarks(); performance.clearMeasures();
```

- **장점**: 복수 구간 측정, 시점 라벨링, 총/부분 시간 분석.

---

## 6. 조건 검증/얼럿: `assert()`

```js
const age = 16;
console.assert(age >= 18, '미성년자: %d', age);
// 조건이 false일 때만 메시지 출력
```

- 가벼운 **런타임 어서션**으로 버그를 조기 포착.
- 프로덕션에서 제거하려면 번들 단계에서 스트리핑(아래 16장 참고).

---

## 7. 호출 빈도 추적: `count()` / `countReset()`

```js
function handleClick() {
  console.count('click'); // 라벨별 카운트
}
document.addEventListener('click', handleClick);
// ...
console.countReset('click');
```

- 이벤트/핫패스 **호출 빈도**를 빠르게 파악.
- 그룹/조건과 조합하면 특정 케이스만 계수 가능.

---

## 8. 콜스택/흐름 추적: `trace()` / `debugger` / 예외 흐름

```js
function f3() { console.trace('여기까지 호출됨'); }
function f2() { f3(); }
function f1() { f2(); }
f1();
```

- `trace()`는 **현재 호출 경로**를 보여준다.
- 특정 지점에서 중단하려면:
```js
function criticalPath() {
  debugger; // DevTools 열려 있으면 이 라인에서 실행 중단
  // ...
}
```

- **DevTools의 “Pause on exceptions”**를 켜면 throw 시 자동 중단 → 근본 원인 추적이 쉬워진다.

---

## 9. 포맷팅/스타일/하이라이트: `%c`와 토큰

```js
const tag = (name, color) => [`%c${name}`, `background:${color}; color:#fff; padding:2px 6px; border-radius:4px;`];

console.log(...tag('AUTH', '#2962ff'), '토큰 검증 시작');
console.log(...tag('CACHE', '#2e7d32'), '히트', { key: 'profile:1' });
console.warn(...tag('RATE', '#ff6f00'), '임계값 근접');
console.error(...tag('ERR', '#d32f2f'), new Error('권한 없음'));
```

- **서버/클라이언트 공용 로거**에서 **레이블/색상 토큰**을 표준화하면 팀 전체 가독성 향상.

---

## 10. 깊은 객체/순환 참조 안전 출력

### 10.1 JSON 포맷(가독)
```js
const pretty = (obj) => JSON.stringify(obj, null, 2);
console.log(pretty({ id: 1, meta: { os: 'win', cpu: 8 } }));
```

### 10.2 순환 안전
```js
function safeStringify(obj) {
  const seen = new WeakSet();
  return JSON.stringify(obj, (k, v) => {
    if (typeof v === 'object' && v !== null) {
      if (seen.has(v)) return '[Circular]';
      seen.add(v);
    }
    return v;
  }, 2);
}
console.log(safeStringify(window)); // 순환 참조가 있어도 안전
```

### 10.3 Node.js에서 더 풍부하게
```js
import util from 'node:util';
console.log(util.inspect(obj, { depth: 4, colors: true, maxArrayLength: 50 }));
```

---

## 11. 브라우저 DevTools 전용 유틸(표준 console 외)

> 아래는 **Chrome/Chromium DevTools 콘솔에서만** 제공되는 헬퍼(표준 JS 아님).

| 헬퍼 | 설명 |
|---|---|
| `$0 ~ $4` | Elements 탭에서 최근 선택한 DOM (최근 5개) |
| `$_` | 직전 표현식 결과 |
| `copy(obj)` | 클립보드로 복사 |
| `keys(obj)` / `values(obj)` | Object.keys/values 단축 |
| `monitor(fn)` / `unmonitor(fn)` | 함수 호출 시 콘솔 자동 출력 |
| `getEventListeners(el)` | 요소에 바인딩된 이벤트 목록 덤프 |
| `inspect(obj)` | 해당 객체 소스/패널로 점프(지원 환경) |

```js
$0.style.outline = '2px solid red';
monitor(fetch); // fetch 호출마다 인자/결과 찍힘
getEventListeners($0); // 이벤트 해부
```

---

## 12. 로깅을 “구성”하는 법: 카테고리/레벨/샘플링/필드

### 12.1 경량 로거 래퍼
```js
const LEVELS = { debug: 10, info: 20, warn: 30, error: 40 };
const current = (process.env.NODE_ENV === 'production') ? LEVELS.info : LEVELS.debug;

function logger(ns) {
  const prefix = [`%c${ns}`, 'background:#333;color:#fff;padding:2px 6px;border-radius:4px;'];
  const out = (lv, method) => (...args) => {
    if (lv < current) return;
    console[method](...prefix, ...args);
  };
  return {
    debug: out(LEVELS.debug, 'log'),
    info:  out(LEVELS.info,  'info'),
    warn:  out(LEVELS.warn,  'warn'),
    error: out(LEVELS.error, 'error'),
  };
}

const log = logger('AUTH');
log.info('로그인 시도', { id: 'kim' });
log.debug('토큰 파싱', { header: '...' }); // dev에서만 노출
```

### 12.2 샘플링(폭주 방지)
```js
function sampledLog(rate = 0.1) {
  return (...args) => (Math.random() < rate) && console.log('[SAMPLE]', ...args);
}
const sample = sampledLog(0.05); // 5%
sample('스크롤 이벤트'); // 일부만 출력
```

### 12.3 필수 필드(구조적 로깅)
- `ts`(ISO), `level`, `ns`, `msg`, `traceId`, `userId`, `meta` …
```js
const entry = (msg, meta={}) => ({
  ts: new Date().toISOString(),
  level: 'info',
  ns: 'checkout',
  msg,
  ...meta,
});
console.log(entry('결제 시작', { traceId, cartSize: 3 }));
```

---

## 13. 실전 레시피

### 13.1 HTTP 요청/응답 추적
```js
async function http(url, opts) {
  console.groupCollapsed('HTTP', url);
  console.time('HTTP');
  console.log('REQ', opts);
  try {
    const res = await fetch(url, opts);
    console.log('RES', res.status, res.headers.get('content-type'));
    const json = await res.clone().json().catch(() => null);
    json && console.table(Array.isArray(json) ? json.slice(0, 5) : json);
    return res;
  } catch (e) {
    console.error('HTTP ERROR', e);
    throw e;
  } finally {
    console.timeEnd('HTTP');
    console.groupEnd();
  }
}
```

### 13.2 이벤트 홍수 제어(throttle/debounce + 샘플링)
```js
const throttle = (fn, ms) => {
  let t = 0; return (...a) => {
    const now = performance.now();
    if (now - t >= ms) { t = now; fn(...a); }
  };
};
const logScroll = throttle(() => console.log('scroll', window.scrollY), 250);
window.addEventListener('scroll', logScroll);
```

### 13.3 긴 리스트/렌더 성능 측정
```js
console.time('render');
renderHugeList(); // DOM 생성/삽입
console.timeEnd('render');
```
- **Long Task** 발생 시 Performance 탭 병행 분석.

### 13.4 폼 검증 어서션 + 사용자 메시지 분리
```js
function validateEmail(s) {
  const ok = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(s);
  console.assert(ok, '이메일 형식 오류', { value: s });
  return ok;
}
```

---

## 14. 테스트 환경에서의 콘솔 다루기(Jest 예시)

### 14.1 특정 테스트에서 콘솔 억제
```js
beforeEach(() => jest.spyOn(console, 'error').mockImplementation(() => {}));
afterEach(()  => console.error.mockRestore());
```

### 14.2 콘솔 호출 검증
```js
test('경고 출력', () => {
  const spy = jest.spyOn(console, 'warn').mockImplementation(() => {});
  warnIfDeprecated('v1');
  expect(spy).toHaveBeenCalledWith(expect.stringContaining('deprecated'));
  spy.mockRestore();
});
```

---

## 15. DevTools와의 콤보

- **Preserve log**: 네비게이션/리로드 간 로그 유지
- **콘솔 필터**: 정규식/레벨/소스별 필터링
- **Source Map**: 번들/트랜스파일 환경에서 **원본 파일/라인**로 점프
- **Logpoints(조건 로그)**: 브레이크포인트 대신 조건부 로그 삽입(Chromium “logpoint”)

---

## 16. 프로덕션에서의 안전 운용

### 16.1 번들에서 제거
- Babel: `babel-plugin-transform-remove-console`
- Terser/Webpack: `drop_console: true`(주의: 전부 제거)
- **권장**: 커스텀 로거 사용(환경별 동작 제어), 핵심 경고/오류는 유지

### 16.2 개인정보/보안
- **민감 데이터**(토큰/세션/주민번호 등) 로그 금지
- PII 마스킹: `***` 치환, 길이/해시화
- 에러 객체는 **메시지/스택**만, 요청/응답은 **필수 필드만**

### 16.3 성능
- 고빈도 경로에서의 과도한 `console.*`는 병목(특히 모바일)
- 샘플링/스로틀/Feature Flag(`DEBUG=true`)로 제어

---

## 17. Node.js 특화 팁

- `console`은 스트림 기반(`stdout`/`stderr`), 대량 로그 시 **백프레셔**/버퍼링 고려
- `console.time()`이 여러 동시 태스크에서 섞일 수 있으므로 **라벨에 식별자 포함**:
```js
const id = crypto.randomUUID();
console.time(`build:${id}`);
// ...
console.timeEnd(`build:${id}`);
```
- 심층 출력은 `util.inspect` 옵션으로 제어(위 10.3절 참고).

---

## 18. 미니 로깅 유틸 — 실무형 템플릿

```js
// logger.js
const ENABLED = (() => {
  if (typeof window !== 'undefined') return !!(window.DEBUG ?? false);
  return process.env.NODE_ENV !== 'production';
})();

const LV = { debug: 10, info: 20, warn: 30, error: 40 };
let current = ENABLED ? LV.debug : LV.info;

export function setLevel(name) { current = LV[name] ?? current; }

export function makeLogger(ns, color = '#455a64') {
  const tag = [`%c${ns}`, `background:${color};color:#fff;padding:2px 6px;border-radius:4px;`];
  const emit = (need, m) => (...a) => (current <= need) && console[m](...tag, ...a);
  return {
    debug: emit(LV.debug, 'log'),
    info:  emit(LV.info,  'info'),
    warn:  emit(LV.warn,  'warn'),
    error: emit(LV.error, 'error'),
    time:  (label) => console.time(`${ns}:${label}`),
    timeEnd: (label) => console.timeEnd(`${ns}:${label}`),
  };
}

// 사용 예
/*
import { makeLogger, setLevel } from './logger';
setLevel('info'); // 배포 시
const log = makeLogger('PAY', '#2e7d32');
log.info('결제 시작', { cartId });
log.debug('카드 토큰', token); // info 레벨에서는 출력 안됨
*/
```

---

## 19. 체크리스트(실무 적용 전/중/후)

- 설계
  - [ ] 로깅 주제 정의: “무엇을 왜 기록하는가?”(성능/추적/감사/디버그)
  - [ ] **레벨/네임스페이스/필드 스키마** 설계
  - [ ] 민감 필드 식별 및 마스킹 규칙

- 구현
  - [ ] 커스텀 로거 래퍼(레벨/샘플링/스타일)
  - [ ] 고빈도 경로에 스로틀/디바운스
  - [ ] 시간 측정은 `time/timeLog/timeEnd` 또는 Performance API

- 테스트/배포
  - [ ] 테스트에서 콘솔 억제/검증 스파이
  - [ ] 번들에서 **불필요 콘솔 제거**
  - [ ] DevTools: Preserve log, Logpoint, Source Map 확인

---

## 20. 요약 표

| 범주 | 핵심 API/기능 | 포인트 |
|---|---|---|
| 출력 | `log/info/warn/error` | 레벨 구분 + 필터링 |
| 표 | `table()` | 컬렉션 가독성 극대화 |
| 구조 | `dir()/dirxml()` | 객체/DOM 내부 관찰 |
| 그룹 | `group()/groupCollapsed()` | 맥락 유지, 단계별 로그 |
| 시간 | `time()/timeLog()/timeEnd()` | 구간 측정, 세분 기록 |
| 검증 | `assert()` | 조건 실패 시에만 경고 |
| 빈도 | `count()/countReset()` | 이벤트/호출 횟수 추적 |
| 스택 | `trace()` / `debugger` | 호출 경로/중단 디버깅 |
| 스타일 | `%c` / 토큰 | 가독성/분류 향상 |
| 대용량 | JSON/inspect/순환 안전 | 안전/가독 포맷 |
| DevTools | `$0~$4`, `$_`, `monitor` 등 | 콘솔 전용 헬퍼(브라우저) |
| 프로덕션 | transform-remove-console | 민감 정보 금지, 성능/안전 |

---

## 참고 자료

- MDN – Console API: https://developer.mozilla.org/ko/docs/Web/API/Console
- Chrome DevTools: https://developer.chrome.com/docs/devtools/
- Performance API: https://developer.mozilla.org/en-US/docs/Web/API/Performance

---

## 부록 A) 작은 연습 과제 3가지

1) **리스트 렌더 성능 비교**
- 1,000/5,000/10,000개 DOM 생성 시 `time()`으로 소요 시간 비교하고, `documentFragment`/가상화 적용 전후 차이 기록.

2) **요청 파이프라인 로깅 표준화**
- 요청ID(traceId) 부여 → `groupCollapsed('HTTP', traceId)`로 단계별 로깅(검증/캐시/DB/외부API) → 실패 케이스 `error()` + `trace()`.

3) **이벤트 홍수 제어**
- `scroll`/`mousemove`를 `throttle`로 줄이고, `count()`로 빈도, `time()`으로 핫패스 구간 측정.
