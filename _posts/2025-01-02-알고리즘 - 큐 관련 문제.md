---
layout: post
title: 알고리즘 - 큐 관련 문제
date: 2025-01-02 19:20:23 +0900
category: 알고리즘
---
# 큐를 활용한 알고리즘 문제

## 큐 기본기 리마인드

- **정의**: 선입선출(FIFO). 먼저 들어온 데이터가 먼저 나온다.
- **핵심 연산**: `enqueue(x)`, `dequeue()`, `peek()`, `empty()`.
- **시간복잡도**: 배열/연결 리스트/덱 구현에서 각 연산의 평균 비용은 $$O(1)$$.
- **파이썬 구현 권장**: `collections.deque` (양끝 삽입/삭제가 모두 $$O(1)$$, `list.pop(0)`은 $$O(n)$$로 비효율적).

```python
from collections import deque

q = deque()
q.append(1)        # enqueue
x = q.popleft()    # dequeue -> 1
front = q[0] if q else None  # peek
```

---

## 대표 문제 ① — 프린터 큐(BOJ 1966)

### 문제 요약

- 문서마다 중요도 `p`가 있고, 대기열의 맨 앞 문서보다 **더 높은 중요도**가 뒤에 존재하면 그 문서를 뒤로 보낸다.
- 인덱스 `m`번째 문서가 **몇 번째로 인쇄**되는지 구한다.

### 핵심 아이디어(원고 보강)

- 큐에는 `(index, priority)`를 저장.
- 매 단계 `popleft()` 후, **큐 내부에 더 큰 priority가 있는지** 검사하여 다시 뒤에 붙일지 결정.
- 우선순위 빈도를 `Counter`로 관리하면 `any(...)`를 매번 돌지 않아도 된다.

```python
from collections import deque, Counter
import sys

input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    pr = list(map(int, input().split()))
    q = deque((i, p) for i, p in enumerate(pr))
    freq = Counter(pr)  # 우선순위별 남은 개수
    cur_max = max(freq) # 현재 큐에서 가장 높은 우선순위
    printed = 0

    while q:
        i, p = q.popleft()
        if p < cur_max:
            q.append((i, p))
        else:
            printed += 1
            freq[p] -= 1
            if freq[p] == 0:
                del freq[p]
                if freq:
                    cur_max = max(freq)
            if i == m:
                print(printed)
                break
```

- 시간복잡도: 각 문서는 최대 몇 번 뒤로 밀릴 수 있으나, 빈도 테이블/현재 최대값을 유지하면 평균적으로 효율적이고, 최악 분석은 입력 분포에 의존적이다. BOJ 제한에서 충분하다.

---

## 대표 문제 ② — 카드2(BOJ 2164)

### 문제 요약

- 1..N 카드를 큐에 넣고, 다음을 반복:
  1) 맨 위 카드 버림
  2) 그 다음 카드 맨 아래로 보냄
- 마지막 남는 카드 번호 출력.

### 코드

```python
from collections import deque
import sys

input = sys.stdin.readline

n = int(input())
q = deque(range(1, n+1))

while len(q) > 1:
    q.popleft()
    q.append(q.popleft())

print(q[0])
```

- 시간복잡도: 각 카드가 상수 횟수로 이동 → $$O(n)$$.

---

## 대표 문제 ③ — 요세푸스 문제(BOJ 1158)

### 문제 요약

- N명이 원을 이루어 앉아 있고 K번째 사람을 제거, 이를 반복.
- 제거 순서를 `<a, b, c, ...>` 형태로 출력.

### 핵심 아이디어(원고 보강)

- `deque.rotate(-(k-1))`로 좌측 회전 후 `popleft()`를 제거로 간주.
- 수학적 해법(재귀 점화)도 존재하지만, 큐 시뮬이 직관적이다.

```python
from collections import deque

n, k = map(int, input().split())
q = deque(range(1, n+1))
order = []

while q:
    q.rotate(-(k-1))
    order.append(q.popleft())

print("<" + ", ".join(map(str, order)) + ">")
```

- 시간복잡도: 각 제거마다 상수 시간 회전을 보장하지는 않지만 `deque.rotate`는 내부적으로 최적화되어 실전에서 충분히 빠르다. 이론적으론 총 $$O(nk)$$가 아니라 **각 요소가 한 번 제거**되므로 실측 상 문제 제한을 통과.

---

## 대표 문제 ④ — BFS(너비 우선 탐색, BOJ 1260)

### 개념

- BFS는 **큐**에 이웃을 넣으며 **가까운 정점부터** 확장한다.
- 무가중치 그래프에서 **최단 간선 거리**를 구할 수 있다.

```python
from collections import deque
import sys

def bfs(adj, start):
    visited = set([start])
    q = deque([start])
    order = []
    while q:
        u = q.popleft()
        order.append(u)
        for v in sorted(adj[u]):  # 문제 요구에 따라 정렬
            if v not in visited:
                visited.add(v)
                q.append(v)
    return order
```

- 시간복잡도: 각 간선/정점이 유한 번 처리 → $$O(V+E)$$.

---

## 큐의 변형과 구현

### 원형 큐(Circular Queue)

- 고정 배열로 구현하고, `head/tail`을 모듈러로 굴린다.
- 포화/공백 구분: 요소 수(size) 필드 또는 `head == tail`을 공백, `(tail+1)%cap == head`를 포화로 정의.

```python
class CircularQueue:
    def __init__(self, cap):
        self.a = [None]*cap
        self.cap = cap; self.head = 0; self.tail = 0; self.size = 0
    def enqueue(self, x):
        if self.size == self.cap:
            raise IndexError("full")
        self.a[self.tail] = x
        self.tail = (self.tail+1) % self.cap
        self.size += 1
    def dequeue(self):
        if self.size == 0:
            raise IndexError("empty")
        x = self.a[self.head]
        self.head = (self.head+1) % self.cap
        self.size -= 1
        return x
    def peek(self):
        if self.size == 0: raise IndexError("empty")
        return self.a[self.head]
    def __len__(self): return self.size
```

### 두 스택으로 큐

- `in_stack`: enqueue 전용, `out_stack`: dequeue 전용. `out`이 비면 `in`을 역순으로 옮긴다.

```python
class MyQueue:
    def __init__(self):
        self.in_s, self.out_s = [], []
    def enqueue(self, x):
        self.in_s.append(x)
    def dequeue(self):
        if not self.out_s:
            while self.in_s:
                self.out_s.append(self.in_s.pop())
        return self.out_s.pop()
    def peek(self):
        if not self.out_s:
            while self.in_s:
                self.out_s.append(self.in_s.pop())
        return self.out_s[-1]
    def empty(self):
        return not self.in_s and not self.out_s
```

---

## — 슬라이딩 윈도우 최대/최소

- 길이 `k` 윈도우에서 매 이동마다 최대를 구하는 문제는 **모노토닉 감소 덱**으로 해결 가능.
- 덱에는 **값이 감소하는 인덱스**만 유지한다. 윈도우에서 벗어난 인덱스는 앞에서 제거.

```python
from collections import deque

def sliding_window_max(a, k):
    dq = deque()
    ans = []
    for i, x in enumerate(a):
        # 뒤에서부터 작거나 같은 값 제거
        while dq and a[dq[-1]] <= x:
            dq.pop()
        dq.append(i)
        # 윈도우 벗어나면 제거
        if dq[0] <= i - k:
            dq.popleft()
        if i >= k-1:
            ans.append(a[dq[0]])
    return ans
```

- 각 인덱스는 덱에 **한 번 들어가고 한 번 나온다** → 총 $$O(n)$$.

---

## BFS와 거리

- **계층 BFS**: 현재 큐 크기를 기준으로 레벨을 구분하면 간선 수 거리를 얻을 수 있다.

```python
from collections import deque

def bfs_distance(adj, s):
    n = len(adj)
    dist = [-1]*n
    q = deque([s]); dist[s] = 0
    while q:
        size = len(q)
        for _ in range(size):
            u = q.popleft()
            for v in adj[u]:
                if dist[v] == -1:
                    dist[v] = dist[u] + 1
                    q.append(v)
    return dist
```

- 무가중치 그래프에서 최단거리: $$O(V+E)$$.

---

## BFS 기본형

- 2차원 격자에서 상하좌우 이동.

```python
from collections import deque

def grid_bfs(grid, start):
    R, C = len(grid), len(grid[0])
    sr, sc = start
    dist = [[-1]*C for _ in range(R)]
    q = deque([(sr, sc)]); dist[sr][sc] = 0
    for_r = [1, -1, 0, 0]; for_c = [0, 0, 1, -1]
    while q:
        r, c = q.popleft()
        for dr, dc in zip(for_r, for_c):
            nr, nc = r+dr, c+dc
            if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#' and dist[nr][nc] == -1:
                dist[nr][nc] = dist[r][c] + 1
                q.append((nr, nc))
    return dist
```

- 벽/장애물은 `'#'` 등으로 표시.

---

## BFS 확장 3 — 다중 시작점 BFS(동시 확산)

- 감염/불/썩은 과일처럼 **여러 출발점이 동시에 퍼지는** 문제는 시작점들을 모두 큐에 넣고 BFS를 시작.

```python
from collections import deque

def multi_source_bfs(grid, sources):
    R, C = len(grid), len(grid[0])
    dist = [[-1]*C for _ in range(R)]
    q = deque()
    for r, c in sources:
        dist[r][c] = 0
        q.append((r, c))
    for_r = [1, -1, 0, 0]; for_c = [0, 0, 1, -1]
    while q:
        r, c = q.popleft()
        for dr, dc in zip(for_r, for_c):
            nr, nc = r+dr, c+dc
            if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#' and dist[nr][nc] == -1:
                dist[nr][nc] = dist[r][c] + 1
                q.append((nr, nc))
    return dist
```

- 토마토(BOJ 7576), 불(BOJ 4179) 등 전형.

---

## BFS 확장 4 — 상태 공간 BFS(키/문·벽 부수기·마스크)

- 위치 외에도 **추가 상태**(열쇠 보유, 벽 파괴 여부 등)를 함께 관리한다.
- 방문 체크는 `(r, c, state)` 3차원 배열이나 dict로.

```python
from collections import deque

def bfs_with_state(grid, start, K):
    # K: 벽을 부술 수 있는 횟수 예시
    R, C = len(grid), len(grid[0])
    sr, sc = start
    INF = 10**9
    dist = [[[INF]*(K+1) for _ in range(C)] for __ in range(R)]
    dist[sr][sc][K] = 0
    q = deque([(sr, sc, K)])
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]

    while q:
        r, c, k = q.popleft()
        for dr, dc in dirs:
            nr, nc = r+dr, c+dc
            if 0 <= nr < R and 0 <= nc < C:
                nk = k
                if grid[nr][nc] == '#':
                    if k == 0:
                        continue
                    nk = k-1
                if dist[nr][nc][nk] == INF:
                    dist[nr][nc][nk] = dist[r][c][k] + 1
                    q.append((nr, nc, nk))
    return dist
```

- 키/문은 비트마스크로 상태를 확장한다(예: `keys_mask` 6비트).

---

## BFS 확장 5 — 0-1 BFS(가중치 0 또는 1)

- 간선 가중치가 `0` 또는 `1`인 그래프의 최단경로는 **덱**으로 해결 가능.
- 가중치 `0` → `appendleft`, 가중치 `1` → `append`.

```python
from collections import deque

def zero_one_bfs(adj, s):
    # adj[u] = list of (v, w) where w in {0,1}
    n = len(adj)
    INF = 10**18
    dist = [INF]*n
    dist[s] = 0
    dq = deque([s])
    while dq:
        u = dq.popleft()
        for v, w in adj[u]:
            nd = dist[u] + w
            if nd < dist[v]:
                dist[v] = nd
                if w == 0:
                    dq.appendleft(v)
                else:
                    dq.append(v)
    return dist
```

- 복잡도: 각 간선은 상수 횟수 덱 연산 → $$O(V+E)$$.

---

## 위상 정렬 — Kahn 알고리즘(큐 기반)

- 사이클 없는 방향 그래프(DAG)의 위상 순서를 큐로 구한다.
- **진입차수 0**인 정점을 큐에 넣고, 꺼내며 간선을 제거→새로 진입차수 0이 되면 큐에 삽입.

```python
from collections import deque

def topo_kahn(n, edges):
    adj = [[] for _ in range(n)]
    indeg = [0]*n
    for u, v in edges:
        adj[u].append(v)
        indeg[v] += 1
    q = deque(i for i in range(n) if indeg[i] == 0)
    order = []
    while q:
        u = q.popleft()
        order.append(u)
        for v in adj[u]:
            indeg[v] -= 1
            if indeg[v] == 0:
                q.append(v)
    if len(order) < n:
        raise ValueError("cycle detected")
    return order
```

- 시간복잡도: $$O(V+E)$$.

---

## 시뮬레이션 — 라운드 로빈, 캐시, 교차로

### 라운드 로빈 CPU 스케줄링(타임퀀텀 q)

- 각 프로세스는 남은 실행시간이 0이면 완료, 아니면 `q`만큼 실행 후 큐 뒤로.

```python
from collections import deque

def round_robin(jobs, q):
    # jobs: list of (pid, arrival_time, burst_time)
    jobs = sorted(jobs, key=lambda x: x[1])
    t = 0; i = 0
    qready = deque()
    completion = {}
    while i < len(jobs) or qready:
        while i < len(jobs) and jobs[i][1] <= t:
            qready.append([jobs[i][0], jobs[i][2]])  # pid, remain
            i += 1
        if not qready:
            t = jobs[i][1];  # 점프
            continue
        pid, remain = qready.popleft()
        run = min(q, remain)
        t += run
        remain -= run
        while i < len(jobs) and jobs[i][1] <= t:
            qready.append([jobs[i][0], jobs[i][2]])
            i += 1
        if remain == 0:
            completion[pid] = t
        else:
            qready.append([pid, remain])
    return completion
```

### LRU 캐시(덱보다는 OrderedDict 권장, 여기서는 기본 원리만)

- 큐/덱만으로 LRU를 구현하려면 삭제가 $$O(n)$$이라 비효율적. 보통 해시+양방향 리스트(파이썬에선 `OrderedDict`)를 쓴다.

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, cap):
        self.cap = cap
        self.od = OrderedDict()
    def get(self, k):
        if k not in self.od: return -1
        self.od.move_to_end(k)  # 최근 사용
        return self.od[k]
    def put(self, k, v):
        if k in self.od:
            self.od.move_to_end(k)
        self.od[k] = v
        if len(self.od) > self.cap:
            self.od.popitem(last=False)  # 가장 오래된 제거
```

### 교차로 시뮬레이션(각 방향 대기열)

- 각 방향에 큐를 두고, 신호 사이클 또는 페어링 규칙으로 `dequeue`한다.
- 초 단위 시뮬레이션에서 **여러 큐를 종합적으로 관리**하는 전형.

---

## 수학적 요약(복잡도)

- **기본 큐 연산**: 평균 $$O(1)$$.
- **BFS**(무가중치 최단거리/도달성/레벨): $$O(V+E)$$.
- **모노토닉 큐**(슬라이딩 최대/최소): 각 원소당 1회 삽입·삭제 → 총 $$O(n)$$.
- **0-1 BFS**: 덱을 사용해 $$O(V+E)$$.
- **위상정렬(Kahn)**: $$O(V+E)$$.

---

## 경계·디버깅 체크리스트

1) 빈 큐, 한 요소, 모두 동일 값
2) 카드2/요세푸스: `rotate`와 인덱스 오프바이원
3) 프린터 큐: 중요도 동률 처리, 대상 인덱스 비교
4) BFS: 방문 처리 타이밍(큐 삽입 시 마킹), 다중 시작점 초기화
5) 격자 BFS: 경계 체크, 방문 중복, 장애물/가중 처리
6) 상태 BFS: 방문 차원 증가에 따른 메모리 폭증
7) 모노토닉 큐: 비교 부등식 방향(최대/최소), 윈도우 이탈 조건
8) 0-1 BFS: 가중치 0과 1 이외의 값이 섞이지 않도록 보장
9) 입출력: 큰 입력에서 `sys.stdin.readline` 사용, 출력 포맷 주의

---

## 백준 스타일 입출력 템플릿 모음

### 기본

```python
import sys
from collections import deque
input = sys.stdin.readline

n, m, s = map(int, input().split())
adj = [[] for _ in range(n+1)]
for _ in range(m):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)

for u in range(1, n+1):
    adj[u].sort()

def bfs(start):
    vis = [False]*(n+1)
    q = deque([start]); vis[start] = True
    order = []
    while q:
        u = q.popleft()
        order.append(u)
        for v in adj[u]:
            if not vis[v]:
                vis[v] = True
                q.append(v)
    return order

print(*bfs(s))
```

### 격자 BFS(상하좌우)

```python
import sys
from collections import deque
input = sys.stdin.readline

R, C = map(int, input().split())
grid = [list(input().strip()) for _ in range(R)]

sr, sc = map(int, input().split())

dist = [[-1]*C for _ in range(R)]
q = deque([(sr, sc)])
dist[sr][sc] = 0
dirs = [(1,0),(-1,0),(0,1),(0,-1)]

while q:
    r, c = q.popleft()
    for dr, dc in dirs:
        nr, nc = r+dr, c+dc
        if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#' and dist[nr][nc] == -1:
            dist[nr][nc] = dist[r][c] + 1
            q.append((nr, nc))

for row in dist:
    print(*row)
```

### 슬라이딩 윈도우 최대

```python
import sys
from collections import deque
input = sys.stdin.readline

n, k = map(int, input().split())
a = list(map(int, input().split()))
dq = deque()
ans = []

for i, x in enumerate(a):
    while dq and a[dq[-1]] <= x:
        dq.pop()
    dq.append(i)
    if dq[0] <= i-k:
        dq.popleft()
    if i >= k-1:
        ans.append(a[dq[0]])

print(*ans)
```

---

## 실전 종합 예제 1 — 미로에서의 최단 시간(문 여러 개)

- `S`에서 `E`로 가는 최단 시간을 구하되, `K`개의 문을 열 수 있다고 가정(벽은 `#`).
- 상태 `(r, c, k_remaining)`를 큐에 담아 BFS.

```python
from collections import deque

def shortest_with_breaks(grid, K):
    R, C = len(grid), len(grid[0])
    sr = sc = er = ec = -1
    for i in range(R):
        for j in range(C):
            if grid[i][j] == 'S': sr, sc = i, j
            if grid[i][j] == 'E': er, ec = i, j
    INF = 10**9
    dist = [[[INF]*(K+1) for _ in range(C)] for __ in range(R)]
    dist[sr][sc][K] = 0
    q = deque([(sr, sc, K)])
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]
    while q:
        r, c, k = q.popleft()
        if (r, c) == (er, ec):
            return dist[r][c][k]
        for dr, dc in dirs:
            nr, nc = r+dr, c+dc
            if not (0 <= nr < R and 0 <= nc < C):
                continue
            nk = k
            if grid[nr][nc] == '#':
                if k == 0:
                    continue
                nk = k-1
            if dist[nr][nc][nk] == INF:
                dist[nr][nc][nk] = dist[r][c][k] + 1
                q.append((nr, nc, nk))
    return -1
```

---

## 실전 종합 예제 2 — 0-1 BFS로 최소 비용 경로(문=1, 빈칸=0)

- 문을 통과하면 비용 1, 빈칸은 0로 이동 가능. 시작점에서 출발해 모든 출구까지 최소 비용.

```python
from collections import deque

def min_doors(grid, start):
    R, C = len(grid), len(grid[0])
    sr, sc = start
    INF = 10**9
    dist = [[INF]*C for _ in range(R)]
    dist[sr][sc] = 0
    dq = deque([(sr, sc)])
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]
    while dq:
        r, c = dq.popleft()
        for dr, dc in dirs:
            nr, nc = r+dr, c+dc
            if 0 <= nr < R and 0 <= nc < C:
                w = 1 if grid[nr][nc] == 'D' else 0
                nd = dist[r][c] + w
                if nd < dist[nr][nc]:
                    dist[nr][nc] = nd
                    if w == 0: dq.appendleft((nr, nc))
                    else: dq.append((nr, nc))
    return dist
```

---

## 정당성·루프 불변식 스케치

- **BFS**: 큐에 들어간 순서대로 거리가 증가한다. 방문 시점(`enqueue`할 때) `dist`를 설정하면 동일 정점을 더 긴 거리로 다시 방문하지 않는다.
- **모노토닉 큐(슬라이딩 최대)**: 덱은 항상 값이 감소하는 인덱스만 유지된다. 윈도우가 한 칸 이동할 때, 새 원소보다 작거나 같은 원소는 앞으로 최대가 될 수 없으므로 제거해도 결과가 변하지 않는다.
- **0-1 BFS**: 가중치 0은 앞쪽, 1은 뒤쪽에 넣으면 **덱의 앞**에서 꺼내 처리 시 항상 현재까지의 최단 거리를 유지한다.

---

## 마무리 — 선택 판단표

| 문제유형 | 자료구조/기법 | 이유 |
|---|---|---|
| 무가중치 최단거리 | BFS(큐) | 계층적 확대 → 최단 간선 수 |
| 동시에 퍼지는 현상 | 다중 시작점 BFS | 여러 출발점을 한 큐에 담아 같은 시각 확산 |
| 0/1 비용 최단 | 0-1 BFS(덱) | 다익스트라보다 간단·빠름 |
| 작업 순환·라운드 처리 | 큐/원형 큐 | 고정된 순서로 순환 |
| 슬라이딩 윈도우 최대/최소 | 모노토닉 덱 | 각 인덱스 1회 입출 → $$O(n)$$ |
| 선행관계 스케줄 | 위상 정렬(Kahn) | 진입차수 0 큐 처리 |

---

## 부록 A. 수식과 복잡도

- BFS 정리:
  $$
  T(n) = O(V+E),\quad \text{각 정점은 최대 1회 방문, 간선은 최대 2회 확인}
  $$
- 모노토닉 덱 정리:
  $$
  \sum_{i=1}^{n}(\text{push}_i+\text{pop}_i) \le 2n \Rightarrow O(n)
  $$

---

## 부록 B. 빠른 입출력 래퍼(파이썬)

```python
import sys
from collections import deque

def readints():
    return map(int, sys.stdin.readline().split())

def readlist():
    return list(map(int, sys.stdin.readline().split()))
```

---

## 결론

원고의 주제(프린터 큐·카드2·요세푸스·BFS)에 **원형/이중/모노토닉 큐**와 **다양한 BFS 파생(다중 시작점·격자·상태·0-1)**, **위상정렬**, **시뮬레이션**을 덧붙였다. 각 풀이에 대해 **정확성 근거(불변식/직관)**, **시간복잡도**, **경계 체크**를 제시했다. 이 글의 순서대로 구현→테스트→확장을 따라가면, 큐 기반 문제 전반에서 **어떤 큐 변형을 쓰고 왜 맞는지**를 일관성 있게 선택·증명·최적화할 수 있다.
