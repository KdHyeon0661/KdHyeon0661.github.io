---
layout: post
title: 웹해킹 - SSTI
date: 2025-09-30 20:25:23 +0900
category: 웹해킹
---
# — 개념·근본 원인·안전한 재현/탐지·프레임워크별 방어 패턴(예제 중심)

## 한눈에 보기

- **SSTI(Server-Side Template Injection)**: 템플릿 엔진(Jinja2/Twig/FreeMarker/Thymeleaf/ERB 등)이 **사용자 입력을 “데이터”가 아니라 “표현식/코드”로 평가**하는 바람에 서버에서 **의도치 않은 실행/파일 접근**이 일어나는 취약성.
- **왜 위험한가?**
  서버단에서 실행되므로 **XSS 같은 클라이언트 스크립트 차단책(CSP, HttpOnly)** 과 무관하게 **서버 리소스**가 노출·수정될 수 있음.
- **전형적인 실수**
  1) 사용자 입력을 **템플릿 문자열**로 직접 렌더(`render_template_string`, `fromString`, `Template(...)`)
  2) 사용자 입력을 **템플릿 경로/이름**으로 사용(경로 조작·대체 템플릿 로딩)
  3) “퍼스널라이즈” 기능을 구현한다며 **표현식이 가능한 엔진**에 **사용자 작성 문법**을 그대로 먹임
  4) 데이터 모델에 **프레임워크/시스템 객체**를 그대로 담아 넘김(메서드·속성 노출)

- **핵심 방어**
  - **로직 없는 템플릿(Logic-less)** 원칙: *템플릿은 뷰, 로직은 코드*.
  - **변수만 바인딩**: 사용자 입력은 **값**으로만 전달, **템플릿/표현식/경로**엔 절대 사용 금지.
  - **템플릿 선택은 매핑(화이트리스트)**: `id → 고정 템플릿` 맵핑만 허용.
  - **엔진 보안 설정**: *엄격 모드*, *Sandbox/Restricted wrapper*, *미정의 변수 에러*, *API 노출 차단*.
  - **사용자 정의 문법이 필요한 경우**: 표현식 불가한 **Logic-less 엔진(Handlebars/Mustache/Liquid 계열)** 로 한정 + **허용 토큰 화이트리스트**.

---

## SSTI 동작 원리 — “데이터가 코드가 되는 순간”

템플릿 엔진은 문자열 안의 **표현식/지시어**를 해석하여 동적으로 렌더링합니다.
- 안전한 경우: `render("hello.html", {name: user_input})` → 템플릿 엔진이 **변수로써** `name`을 출력(필요 시 이스케이프).
- 위험한 경우: `render_string(user_input)` 또는 `render(template_name=user_input)` → 입력이 **템플릿 그 자체**로 평가되어 엔진의 **표현식 평가기**가 실행.

> 정리: **“템플릿=코드, 변수=데이터”**. 사용자가 만지는 건 **변수**까지만 허용해야 하며, **템플릿/표현식/경로**는 절대 안 됩니다.

---

## 취약 시나리오와 안전 대체 설계

### “랜더 템플릿 스트링” 오용

**❌ 취약 (Flask + Jinja2)**
```python
from flask import Flask, request, render_template_string
app = Flask(__name__)

# "미리보기"를 만든다며 사용자 입력을 템플릿으로 직접 평가

@app.post("/preview")
def preview():
    raw = request.form.get("body", "")
    return render_template_string(raw)  # ← 사용자 입력이 '템플릿'이 됨 (금지)
```

**✅ 안전 대체**
{% raw %}
```python
from flask import render_template, escape

@app.post("/preview")
def preview():
    raw = request.form.get("body", "")
    # 1) 텍스트로만 출력: 템플릿은 고정, 사용자 입력은 데이터
    return render_template("preview.html", body=raw)  # 템플릿: {{ body }} (autoescape on)

# preview.html (Jinja2 기본 autoescape)
# <h1>Preview</h1>
# <pre>{{ body }}</pre>   <!-- 데이터로만 사용 -->

```
{% endraw %}

### “템플릿 선택/경로”를 입력으로 받는 경우

**❌ 취약 (Twig 예)**
```php
// /render?tpl=invoice.html 같은 방식으로 파일명/경로를 그대로 받음
$tpl = $_GET['tpl'];                     // 예: ../../../../etc/passwd 라면?
echo $twig->render($tpl, ['user'=>$u]);  // 파일 포함/경로 조작 위험 + 임의 템플릿 실행
```

**✅ 안전 대체(화이트리스트 맵핑)**
```php
$allowed = [
  'invoice' => 'tpl/invoice.html.twig',
  'welcome' => 'tpl/welcome.html.twig'
];
$key = $_GET['tpl'] ?? '';
if (!array_key_exists($key, $allowed)) { http_response_code(400); exit; }
echo $twig->render($allowed[$key], ['user' => $u]);
```

### “퍼스널라이즈 문법” 수요가 있을 때

- **나쁜 접근**: 완전한 템플릿 엔진(Jinja2/Freemarker 등)의 **표현식/함수**까지 열어줌 → 곧 SSTI 표면.
- **좋은 접근**: **Logic-less 엔진**(Mustache/Handlebars/Liquid) + **허용 토큰만** 치환.

**✅ 예: “토큰 리졸버” 직접 구현 (Node)**
```js
// 지원 토큰: [[name]], [[date]], [[company]] — 표현식/함수 없음
const TOKENS = new Map([
  ["[[name]]",    (ctx) => ctx.name ?? ""],
  ["[[date]]",    (ctx) => new Date().toISOString().slice(0,10)],
  ["[[company]]", (ctx) => ctx.company ?? ""],
]);

export function renderTokens(template, ctx) {
  // 복잡한 정규식/평가기 없이 토큰 사전 매칭만
  let out = template;
  for (const [t, fn] of TOKENS) out = out.split(t).join(String(fn(ctx)));
  return out;
}
```

---

## 프레임워크/엔진별 방어 체크리스트 & 코드

> 공통: **사용자 입력을 템플릿/경로/표현식에 절대 쓰지 말 것**. “데이터 바인딩”만 허용.

### Python — Jinja2(Flask/FastAPI 등)

**권장 설정**
```python
from jinja2 import Environment, FileSystemLoader, StrictUndefined, select_autoescape

env = Environment(
    loader=FileSystemLoader("templates"),
    autoescape=select_autoescape(["html","xml"]),
    undefined=StrictUndefined,  # 미정의 변수 접근 시 즉시 에러(실패-우선)
)

# Sandbox는 보조 수단일 뿐 "표현식 허용" 요구 자체를 줄이는 게 본질
# from jinja2.sandbox import SandboxedEnvironment

```

**패턴 요약**
- `render_template_string` **금지**.
- 템플릿은 **고정 파일**에서만 로드(화이트리스트).
- **데이터 모델**에 프레임워크/시스템 객체(요청/응답, 파일 핸들러 등) 넣지 않기.
- 예외를 **로그/알림**으로 전환(내부 정보 노출 금지).

**안전 테스트(“평가”가 아닌 “그대로 출력” 확인)**
> 목적: 특정 텍스트({% raw %}`{{ ... }}`{% endraw %} 같은 패턴)가 **평가 되지 않고 문자 그대로** 보이는지 확인.
{% raw %}
```python
def test_preview_literal(client):
    r = client.post("/preview", data={"body": "Hello {{ username }} !"})
    assert "{{ username }}" in r.text   # ← 표현식이 그대로 보이면 안전한 출력
```
{% endraw %}

### PHP — Twig

**권장 설정**
```php
$loader = new \Twig\Loader\FilesystemLoader('/var/app/templates');
$twig = new \Twig\Environment($loader, [
  'cache' => '/var/app/twig-cache',
  'autoescape' => 'html',
  'strict_variables' => true, // 미정의 변수 사용시 에러
]);

// (선택) Sandbox 정책: 허용 태그/필터/함수만
// $policy = new \Twig\Sandbox\SecurityPolicy([...]);
// $sandbox = new \Twig\Extension\SandboxExtension($policy, true);
// $twig->addExtension($sandbox);
```

**패턴 요약**
- `createTemplate`/`render`에 **사용자 문자열** 직접 전달 금지.
- 템플릿 선택은 **키→파일** 맵으로만.
- 사용자 콘텐츠는 텍스트로 바인딩 + 자동 이스케이프.

**안전 테스트**
{% raw %}
```php
// PHPUnit 예시
$resp = $client->post('/preview', ['body' => 'Hello {{ now }}']);
$this->assertStringContainsString('{{ now }}', (string)$resp->getBody());
```
{% endraw %}

### Java — FreeMarker

**권장 설정**
```java
Configuration cfg = new Configuration(Configuration.VERSION_2_3_32);
cfg.setClassLoaderForTemplateLoading(getClass().getClassLoader(), "/templates");
cfg.setDefaultEncoding("UTF-8");
cfg.setLogTemplateExceptions(false);
cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);

// 위험 축소: API / 메서드 노출 제한
cfg.setAPIBuiltinEnabled(false); // ?api 비활성화
// 데이터 모델엔 Map/DTO만 → 임의 객체/메서드 참조 방지
```

**패턴 요약**
- `new Template(String name, Reader reader, ...)`에 사용자 문자열 금지.
- `?api`, `?new` 등 **강력 기능 비활성화**(버전/설정 확인).
- 템플릿 경로는 **정해진 로더** 기반 + 화이트리스트.

**안전 테스트**
```java
String body = "Hello ${ user_input }";
String out = renderPreview(body, Map.of("user_input", "Alice"));
// 안전 설계라면 "${ user_input }" 그대로 보여야 함(템플릿으로 처리하지 않음)
assertTrue(out.contains("${ user_input }"));
```

### Java — Thymeleaf(Spring)

- Thymeleaf는 SpEL/OGNL 평가를 포함. **사용자 입력으로 템플릿 조립 금지**.
- HTML 템플릿 파일 고정 + 모델에 값만 바인딩.
- `th:utext`(언이스케이프) 남용 금지, 필요 시 화이트리스트 Sanitizer 후 주입.

```java
// 안전: 고정 템플릿 + 모델 데이터만
@GetMapping("/preview")
public String preview(@RequestParam String body, Model m) {
  m.addAttribute("body", body);  // 텍스트로 출력 (템플릿에 [[${body}]] 또는 th:text 사용)
  return "preview";              // preview.html은 고정 파일
}
```

### Ruby — ERB

- ERB는 루비 코드가 그대로 실행되므로 **사용자 입력을 ERB로 평가 금지**.
- 미리 정해진 템플릿 파일에 `ERB#result_with_hash` 로 **데이터만 바인딩**.
- 사용자 콘텐츠는 view helper로 이스케이프되어 텍스트로 출력.

---

## “사용자 정의 템플릿” 기능이 꼭 필요할 때의 안전한 설계

1) **Logic-less 엔진 선택**: Mustache/Handlebars/Liquid(표현식/함수 금지, 섀도 DOM 접근 불가).
2) **허용 토큰 목록 운영**: `[[name]]`, `[[date]]`, `[[order_id]]` 등 *정해진 키*만 대체.
3) **미리 컴파일/검증**: 저장 시 정규식으로 **허용 토큰만 존재**하는지 확인.
4) **런타임 치환은 문자열 치환**으로만(자체 평가기/`eval` 없음).
5) **프리뷰/렌더 로그**: 치환된 토큰·길이·시간을 남겨 *오류/남용 탐지*.
6) **템플릿 파일/경로는 백엔드 소유**(사용자가 업로드한 HTML을 서버 템플릿 폴더에 두지 않음).

**검증 예시(서버 저장 전)**
```ts
// 허용 토큰만 포함되어야 저장 가능
const ALLOWED = new Set(["[[name]]","[[date]]","[[company]]"]);
function validateTemplate(tpl: string): boolean {
  // 토큰 추출
  const found = new Set(Array.from(tpl.matchAll(/$$$$[a-z0-9_]+$$$$/gi)).map(m=>m[0]));
  // 허용 외 토큰·표현식 금지(중괄호, 제어문 등 탐지)
  if (/[{}%]|<%|%>/.test(tpl)) return false;   // 템플릿/스마트태그 흔적 거절
  for (const tok of found) if (!ALLOWED.has(tok)) return false;
  return true;
}
```

---

## 탐지·모니터링·SAST/DAST 포함

### 런타임 로그/지표

- **템플릿 예외 급증**: `TemplateSyntaxError`, `UndefinedError`, `TemplateException`
- **미리보기/퍼스널라이즈 API**의 **500/400** 비율 급증
- **저장 시 검증 실패율**: 불허 문법 시도가 늘면 경보

**Loki 예시(LogQL)**
```logql
{service="web"} |= "Template" |= "Error" | count_over_time(5m) > 5
```

**Splunk 예시**
```spl
index=app ("TemplateSyntaxError" OR "TemplateException" OR "UndefinedError")
| timechart span=5m count
```

### 룰 아이디어

- **플래그 함수**: `render_template_string`, `from_string`, `new Template(String, ...)`, `Twig\Environment::createTemplate`, `ERB.new(user_input)`
- **동적 경로**: `render(user_input + ".html")` 같은 패턴
- **데이터 모델에 위험 객체 포함**: 요청/응답/파일 핸들러/리플렉션 오브젝트

### — “차단 테스트” 위주

- 스테이징에서 **표현식 문법 비스무리한 문자열**을 데이터 입력에 넣었을 때 **그대로 출력**되면 OK.
- 반대로 **서버 에러/평가 흔적**이 보이면 경보 → 코드 리뷰.

---

## CI 파이프라인 통합(안전 테스트 자동화)

**GitHub Actions 예시**
```yaml
name: ci-ssti-guard
on: [push, pull_request]
jobs:
  sast:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Grep unsafe template apis
        run: |
          if grep -R --line-number -E "render_template_string|createTemplate\(|new Template\(|fromString\(" -n src/; then
            echo "::error title=SSTI risk detected::Remove unsafe template APIs"
            exit 1
          fi

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: |
          npm ci || pip install -r requirements.txt || true
          npm test || pytest -q
```

---

## 운영 수칙 요약(프록시/앱/플랫폼)

- **프록시/게이트웨이**: 템플릿을 외부 요청으로 업로드/선택하지 않음. 업로드된 HTML은 **다운로드 전용**(Content-Disposition: attachment).
- **애플리케이션**:
  - 템플릿 엔진 API는 **파일 기반 고정 로더**만 사용.
  - **Strict/Fail-fast** 설정(미정의 변수 에러).
  - 데이터 모델에 **원치 않는 객체/함수** 포함 금지.
- **플랫폼**:
  - 퍼스널라이즈가 필요하면 **Logic-less 엔진** + 허용 토큰 검증.
  - 템플릿 저장소와 앱 코드 저장소 **권한 분리**, PR 리뷰 필수.
- **보안 헤더**: SSTI 직접 차단은 못 하지만, 오탑재로 인한 **클라이언트 XSS 2차 피해**를 줄이기 위해 CSP/HttpOnly/SameSite 유지.

---

## “끝에서 끝까지” 미니 샘플

### Flask(취약 → 수정)

**❌ 취약**
```python
@app.post("/mail/preview")
def mail_preview():
    # 사용자 입력을 템플릿으로 직접 해석 (금지)
    html = render_template_string(request.form.get("html",""))
    return html
```

**✅ 수정**
{% raw %}
```python
# app.py

from flask import render_template
@app.post("/mail/preview")
def mail_preview():
    # 1) 템플릿은 고정 파일
    # 2) 사용자 입력은 데이터로만 바인딩
    body = request.form.get("html","")
    return render_template("mail_preview.html", body=body)

# templates/mail_preview.html

<!doctype html>
<h1>Mail Preview</h1>
<pre>{{ body }}</pre>
```
{% endraw %}

**✅ 사용자 정의 토큰이 필요한 경우 (Logic-less)**
```python
# utils/tokens.py

ALLOWED = {"[[name]]","[[date]]"}
def render_tokens(tpl: str, ctx: dict) -> str:
    if any(c in tpl for c in "{}%$"):  # 템플릿 문법 흔적 차단
        return "[invalid]"
    return (tpl.replace("[[name]]", ctx.get("name",""))
              .replace("[[date]]", ctx.get("date","")))
```

### Spring + Thymeleaf(취약 → 수정)

**❌ 취약(개념)**
```java
@GetMapping("/preview")
public String preview(@RequestParam String tpl, Model m) {
  // 사용자가 보낸 문자열을 템플릿으로 간주하는 로직 (금지)
  // ...
  return tpl; // (실제로는 Thymeleaf에 동적 템플릿을 먹이는 패턴)
}
```

**✅ 수정**
```java
@GetMapping("/preview")
public String preview(@RequestParam String body, Model m) {
  m.addAttribute("body", body); // [[${body}]] 로 안전 표시
  return "preview";             // 고정 템플릿 파일
}
```

---

## FAQ로 정리하는 실무 포인트

**Q1. 자동 이스케이프(autoescape)가 켜져 있으면 SSTI도 막나요?**
A. **아닙니다.** 자동 이스케이프는 **출력 시 XSS 위험**을 줄여줄 뿐, **서버 측 표현식 평가 자체**를 막지 못합니다.

**Q2. 샌드박스/Restricted 모드만 켜면 안전한가요?**
A. 도움이 되지만 **근본 해결**은 아닙니다. *사용자 입력을 템플릿/표현식으로 평가하지 않는 설계*가 우선입니다.

**Q3. 사용자에게 “간단한 수식(날짜 포맷 등)”만 허용하고 싶다면?**
A. 표현식 엔진 대신 **미리 정의한 토큰/필터**만 허용하세요. 예: `[[date]]`, `[[upper:name]]` 식의 **화이트리스트 치환기**.

**Q4. 어떤 로그를 보아야 조기 탐지에 도움이 되나요?**
A. 템플릿 파싱 오류/미정의 변수 예외, 미리보기 API의 4xx/5xx 급증, 저장 전 검증 실패율 상승 등.

---

## 체크리스트(현장용)

- [ ] 사용자 입력을 **템플릿/표현식/경로**에 **절대 사용하지 않는다**
- [ ] 템플릿 선택은 **키→파일** 화이트리스트 매핑만 허용
- [ ] 엔진은 **Strict/Fail-fast**(미정의 변수 에러), **API 노출 제한**
- [ ] 데이터 모델엔 **DTO/Map**만 전달(프레임워크/시스템 객체 금지)
- [ ] 퍼스널라이즈는 **Logic-less + 토큰 화이트리스트**
- [ ] 저장 전 **정적 검증**(금지 문법/토큰) + 런타임 **예외 모니터링**
- [ ] CI에서 **위험 API 호출**(render_template_string·fromString 등) 탐지
- [ ] 에러는 사용자에게 숨기고(일반 메시지), **로그/알림**으로만

---

### 맺음말

SSTI의 본질은 “**데이터가 코드로 해석되는 경계 붕괴**”입니다.
**템플릿=고정, 입력=데이터**라는 규율만 지켜도 **대부분의 SSTI**는 설계 단계에서 사라집니다.
