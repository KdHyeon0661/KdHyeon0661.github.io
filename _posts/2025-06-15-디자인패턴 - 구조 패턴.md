---
layout: post
title: 디자인패턴 - 구조 패턴
date: 2025-06-15 22:20:23 +0900
category: 디자인패턴
---
# 구조 패턴(Structural Patterns)

## 개요 — 구조 패턴이란?

**구조 패턴(Structural Patterns)**은 **클래스나 객체를 조합**하여 더 크고 유연한 구조를 만들도록 돕는 디자인 패턴이다.
목적은 **인터페이스 불일치 해소, 복잡도 감추기, 부분-전체의 일관된 처리, 동적 기능 조합, 객체 공유, 접근 제어** 등으로 요약된다.

> “부분을 연결하여 전체를 유연하게 만든다”
> “복잡한 구조를 단순하게, 변경 가능한 구조로”

---

## 🎯 핵심 목표(살려서 확장)

- **이질적 객체를 조합**해 복잡한 문제를 해결
- **결합도 저감**으로 재사용성/유지보수성 향상
- 구조 변경 최소화로 **확장 용이**
- 경계(외부 API/레거시/플랫폼)에서 **접점 단순화** 혹은 **표준화**

---

## 📐 분류(살리되 예시 보강)

1) **클래스 기반(Class-based)** — 상속 사용
   - 예: **Adapter(클래스 어댑터)**, **Bridge(일부 구현 상속 조합)**

2) **객체 기반(Object-based)** — 합성/위임 사용
   - 예: **Adapter(객체 어댑터)**, **Composite, Decorator, Facade, Flyweight, Proxy, Bridge(주로 합성)**

> 실무에서는 **객체 기반** 접근을 선호(유연성/캡슐화/테스트 용이성).

---

## 🧩 대표 패턴 목록(원문 표 유지)

| 패턴 이름       | 설명 |
|----------------|------|
| **Adapter**    | 서로 다른 인터페이스를 호환되도록 변환 |
| **Bridge**     | 추상화와 구현을 분리하여 독립적으로 확장 가능하게 함 |
| **Composite**  | 객체를 트리 구조로 구성하여 부분-전체를 동일하게 다룸 |
| **Decorator**  | 객체에 기능을 동적으로 추가 (중첩 가능) |
| **Facade**     | 복잡한 시스템에 단순한 인터페이스 제공 |
| **Flyweight**  | 공통된 객체를 공유하여 메모리 사용 최적화 |
| **Proxy**      | 다른 객체에 대한 접근 제어 (대리인 역할) |

---

## 🔧 구조 패턴이 특히 필요한 상황(살려서 압축)

- 외부 라이브러리/API를 내부 표준으로 **감싸기**
- 복잡한 하위 시스템에 대한 **단순 진입점** 필요
- **동적 기능 조합/확장** 요구
- **중복 리소스 공유** 최적화
- **접근 제어/대리/원격/캐싱/지연 로딩** 필요

---

## ✅ 장점 / ⚠️ 주의점(살려서 보강)

**장점**
- 복잡한 구조 **캡슐화** → 관리 용이
- **재사용성/유지보수성** 향상
- **호환성 확보**(경계 적응)
- **유연한 조합/변경** 가능

**주의**
- 남용 시 **추상화 과잉**, 흐름 파악 난이도↑
- **SRP/DIP** 위배 여부 점검
- 선택 기준/목적이 **명확**해야 함

---

## 공통 설계 체크리스트(추가)

- 상속보다 **합성 우선**(가능하면 객체 기반)
- 공용 경로(핫패스)에서 **오버헤드** 최소화
- **계약(인터페이스) 안정성** 먼저 정의
- 예외/에러 **매핑 정책** 문서화
- 테스트: **계약 테스트 + 페일 패스 + 성능 가드**

---

# 패턴별 심화

아래 7개 패턴을 **의도 → 구조 그림 → 핵심 아이디어 → 코드 예시(Python 중심, 일부 C#) → 장단점 → 사용처/함정 → 테스트/성능 포인트** 순으로 실제 적용 관점에서 정리한다.

---

## 1. Adapter — 인터페이스 불일치 해소

### 구조(그림 유지)

```
┌───────────┐        ┌──────────────────────┐
│  Client   │◄──────►│ Target (인터페이스)   │
└───────────┘        └──────────────────────┘
                           ▲
                           │
                    ┌────────────┐
                    │  Adapter   │
                    └────────────┘
                           │
                           ▼
                ┌──────────────────────┐
                │ Adaptee(기존 클래스) │
                └──────────────────────┘
```

### 핵심
- **Target** 계약으로 표준화, **Adapter**가 **Adaptee 호출/변환**을 캡슐화
- 객체 어댑터 권장(합성/위임)

### Python 예시(요약)
```python
class OldPrinter:
    def print_text(self, s): print(f"[OLD]{s}")

class Printer:  # Target
    def print(self, s): raise NotImplementedError

class PrinterAdapter(Printer):
    def __init__(self, old): self._old = old
    def print(self, s): self._old.print_text(s)

PrinterAdapter(OldPrinter()).print("hi")
```

### 장단점·테스트·성능
- 장점: 레거시/서드파티 **무수정 통합**, 교체 용이
- 단점: 계층 증가 → 디버깅 경로 길어짐
- 테스트: **Target 계약 테스트** 공통화
- 성능: 변환 비용 \(T_{\text{map}}\)은 대개 I/O보다 작음

---

## 2. Bridge — 추상과 구현의 독립적 확장

### 의도
- **추상(Abstraction)**과 **구현(Implementor)**를 분리해 **독립적으로 변화** 가능

### 구조
```
 Abstraction ── has-a ──► Implementor
     ▲                         ▲
     │                         │
RefinedAbstraction      ConcreteImplementor(s)
```

### 핵심
- **상속(추상 확장)** vs **구현 교체(합성)**의 축을 분리

### Python 예시: 렌더러 분리
```python
class Renderer:
    def line(self, x1,y1,x2,y2): raise NotImplementedError

class SvgRenderer(Renderer):
    def line(self, x1,y1,x2,y2): print(f"<line x1={x1} y1={y1} x2={x2} y2={y2}/>")

class CanvasRenderer(Renderer):
    def line(self, x1,y1,x2,y2): print(f"canvas.draw({x1},{y1},{x2},{y2})")

class Shape:  # Abstraction
    def __init__(self, r: Renderer): self.r=r
    def draw(self): raise NotImplementedError

class Rectangle(Shape):
    def __init__(self, r,x,y,w,h): super().__init__(r); self.x=x;self.y=y;self.w=w;self.h=h
    def draw(self):
        self.r.line(self.x,self.y,self.x+self.w,self.y)
        self.r.line(self.x+self.w,self.y,self.x+self.w,self.y+self.h)
        self.r.line(self.x+self.w,self.y+self.h,self.x,self.y+self.h)
        self.r.line(self.x,self.y+self.h,self.x,self.y)

Rectangle(SvgRenderer(),10,10,50,30).draw()
```

### 장단점·함정
- 장점: **카테고리별 조합 폭발** 억제(추상×구현 독립)
- 단점: 초기 복잡도↑
- 함정: 단순히 상속만 늘리면 **미니-브릿지** 실패 → 반드시 **합성 경계 정의**

---

## 3. Composite — 부분/전체를 동일하게

### 구조
```
         ┌───────────────┐
         │ Component     │  (operation())
         └─────▲─────────┘
               │
   ┌───────────┴───────────┐
   │                       │
┌───────┐             ┌──────────┐
│ Leaf  │             │ Composite │
└───────┘             └────▲──────┘
                           │ children: [Component]
```

### 핵심
- 트리 구조에서 **Leaf/Composite**를 동일한 **Component 인터페이스**로 취급

### Python 예시: 파일 시스템
```python
from typing import List, Protocol

class Node(Protocol):
    def size(self) -> int: ...

class File(Node):
    def __init__(self, bytes_: int): self._bytes = bytes_
    def size(self) -> int: return self._bytes

class Dir(Node):
    def __init__(self): self._children: List[Node] = []
    def add(self, n: Node): self._children.append(n)
    def size(self) -> int: return sum(c.size() for c in self._children)

root = Dir(); root.add(File(10)); sub=Dir(); sub.add(File(5)); root.add(sub)
assert root.size()==15
```

### 수식/성능
- 전체 노드 수 \(N\)일 때 집계 비용:
  $$ T_{\text{aggregate}} = \Theta(N) $$

### 함정
- **순환 참조 금지**, 수정/접근 동시 사용 시 **락/스냅샷** 고려

---

## 4. Decorator — 동적 기능 부착(중첩 가능)

### 구조
```
      ┌──────────┐
      │Component │◄─────────────┐
      └────▲─────┘              │
           │                    │
      ┌────┴────┐         ┌─────┴─────┐
      │Concrete │         │ Decorator │(has-a Component)
      └─────────┘         └───────────┘
```

### 핵심
- 동일 인터페이스를 유지한 채 **기능을 합성적으로 덧입힘**(런타임 중첩)

### Python 예시: 로깅+캐싱 데코레이터
```python
import functools

class Service:
    def get(self, k): raise NotImplementedError

class DictService(Service):
    def __init__(self,d): self.d=d
    def get(self, k): return self.d[k]

class Logging(Service):
    def __init__(self, inner): self.inner=inner
    def get(self,k):
        v=self.inner.get(k); print(f"get({k})={v}"); return v

class Caching(Service):
    def __init__(self, inner): self.inner=inner; self.cache={}
    def get(self,k):
        if k in self.cache: return self.cache[k]
        v=self.inner.get(k); self.cache[k]=v; return v

svc = Caching(Logging(DictService({"a":1})))
assert svc.get("a")==1
```

### 장단점·함정
- 장점: **조합 폭발**을 클래스가 아닌 **런타임 합성**으로 해결
- 단점: 중첩 깊어지면 **디버깅 경로 길어짐**
- 함정: **순서 의존**(예: 캐싱 전/후 로깅), **추적/메트릭 삽입** 일관성 필요

---

## 5. Facade — 복잡도 숨기고 단순 진입점

### 구조
```
Client → Facade → [SubsystemA, SubsystemB, ...]
```

### 핵심
- 서브시스템을 건드리지 않고 **사용자 경험(UX) 계층**에서 **최소 API** 제공

### Python 예시: 미디어 처리 파사드
```python
class ImageLib:  # 복잡
    def load(self, p): ...
    def resize(self, img, w,h): ...
    def save(self, img, p): ...

class MediaFacade:
    def __init__(self, img: ImageLib): self.img=img
    def thumbnail(self, src, dst, maxw=200, maxh=200):
        im=self.img.load(src); im=self.img.resize(im, maxw, maxh); self.img.save(im,dst)

MediaFacade(ImageLib()).thumbnail("in.png","out.png")
```

### 장단점·함정
- 장점: 진입점 **통일**, 온보딩/유지보수 용이
- 단점: 파사드가 **하위 변경을 모두 흡수**하면 비대화 위험
- 함정: **새 요구사항을 파사드에만** 계속 붙이면 **거대 인터페이스**가 됨 → 내부 모듈 경계 재설계 필요

---

## 6. Flyweight — 공유로 메모리 최적화

### 의도
- **불변/공유 가능한 내재 상태(intrinsic state)**를 **단일 객체로 공유**
- 외재 상태(extrinsic state)는 호출 시 주입

### 구조
```
FlyweightFactory: key → Flyweight(shared)
Client: flyweight.op(extrinsic)
```

### Python 예시: 글리프 캐시
```python
class Glyph:
    def __init__(self, char): self.char=char  # intrinsic
    def draw(self, x,y): print(f"{self.char}@({x},{y})")  # extrinsic:(x,y)

class GlyphFactory:
    def __init__(self): self.pool={}
    def get(self, ch):
        if ch not in self.pool: self.pool[ch]=Glyph(ch)
        return self.pool[ch]

f=GlyphFactory()
for i,ch in enumerate("hello"):
    f.get(ch).draw(i,0)
```

### 메모리 이득(모형)
- 고유 문자의 수를 \(U\), 전체 글자수를 \(N\)이라 할 때,
  공유 없을 때 메모리: \(O(N)\) → Flyweight로 \(O(U) + O(N \text{(좌표 등 외재)})\)
  \(U \ll N\)이면 큰 이득.

### 함정
- **스레드 안전**(공유 캐시 갱신)
- **불변성 보장**이 핵심(변경 가능한 공유는 위험)

---

## 7. Proxy — 접근 제어/원격/캐시/지연

### 의도
- 동일 인터페이스로 **대리 객체**를 두어 **접근 제어/원격 호출/캐싱/지연 로딩** 등 부가기능 제공

### 구조
```
Client → Proxy → RealSubject
```

### 유형
- **Virtual**(지연 생성), **Protection**(권한 검증), **Remote**(원격 통신), **Caching**(결과 캐시), **Smart Ref**(참조 카운트)

### Python 예시: 지연 로딩 프록시
```python
class Heavy:
    def __init__(self): self.data=self._load()
    def _load(self): print("loading..."); return [0]*10_000
    def size(self): return len(self.data)

class LazyProxy:
    def __init__(self): self._real=None
    def size(self):
        if not self._real: self._real=Heavy()
        return self._real.size()

p=LazyProxy()
print(p.size())  # 최초 호출 시 로딩
```

### 장단점·함정
- 장점: 보안/성능/원격을 **투명**하게 주입
- 단점: **분산 장애/일관성/타임아웃** 고려 필요
- 함정: 프록시 체인 과다 → **레이지/캐시/리트라이** 정책 충돌

---

# 패턴 간 선택 가이드(결정표)

| 문제 | 권장 패턴 |
|------|-----------|
| 외부/레거시 인터페이스 불일치 | **Adapter** |
| 추상과 구현을 독립적 진화 | **Bridge** |
| 트리/부분-전체 동일 연산 | **Composite** |
| 기능을 런타임에 조합/부착 | **Decorator** |
| 복잡 서브시스템 단순화 | **Facade** |
| 동일한 불변 상태 다수 인스턴스 | **Flyweight** |
| 접근 제어/원격/지연/캐시 | **Proxy** |

---

## 성능·복잡도 관점(요약 수식)

- **Composite** 집계 비용:
  $$ T_{\text{aggregate}}=\Theta(N) $$
- **Flyweight** 메모리: 공유 없을 때 \(O(N)\) → 공유로 \(O(U)+\text{외재 상태}\), \(U \ll N\)이면 유리
- **Decorator/Proxy/Adapter** 호출 오버헤드:
  $$ T_{\text{wrap}} \approx T_{\text{call}} + T_{\text{policy}} $$
  I/O 바운드라면 영향 미미, 핫패스에서는 래핑 층수 최소화

---

## 테스트 전략(패턴 공통)

- **계약 테스트**: 외부로 보이는 인터페이스(메서드/예외/불변식)를 공통 스위트로
- **페일 패스**: 권한 거부/네트워크 타임아웃/캐시 미스/순환 트리 방어
- **측정**: 프록시/데코레이터 체인의 **지연/오버헤드** 가드(임계치 알람)

간단 PyTest 예(Composite)
```python
def test_dir_size():
    root=Dir(); root.add(File(1)); sub=Dir(); sub.add(File(2)); root.add(sub)
    assert root.size()==3
```

---

## 흔한 안티패턴·함정과 리팩토링 힌트

- **무의미 래퍼(Adapter/Facade 남용)**: 실제 변환/단순화가 없으면 제거
- **거대 파사드**: 요구사항 계속 부착 → 내부 모듈로 **분해**하고 파사드는 얇게
- **데코레이터 순서 의존**: 순서 명시 or **조립기(Builder/DI)**로 관리
- **프록시의 무한 리트라이/캐시 독화**: **백오프/TTL/서킷 브레이커** 규칙 문서화
- **Flyweight 가변 공유**: 반드시 **불변** 보장, 외재 상태 주입

---

## .NET/C# 실무 스니펫 묶음(요약)

### Decorator(ILogger 예, 의도만)
```csharp
public interface IRepo { Task<string> GetAsync(string id); }

public sealed class Repo : IRepo {
    public Task<string> GetAsync(string id) => Task.FromResult("v");
}

public sealed class LoggingRepo : IRepo {
    private readonly IRepo _inner;
    private readonly ILogger _log;
    public LoggingRepo(IRepo inner, ILogger log) { _inner=inner; _log=log; }
    public async Task<string> GetAsync(string id) {
        _log.LogInformation("get {Id}", id);
        return await _inner.GetAsync(id);
    }
}
```

### Proxy(Remote)
```csharp
public sealed class RemoteRepo : IRepo {
    private readonly HttpClient _http;
    public RemoteRepo(HttpClient http) => _http=http;
    public async Task<string> GetAsync(string id) {
        var r = await _http.GetAsync($"/api/items/{id}");
        r.EnsureSuccessStatusCode();
        return await r.Content.ReadAsStringAsync();
    }
}
```

---

## 패턴 조합 레시피

- **Adapter + Facade**: 외부 다수 API를 단일 진입점으로 모으고, 내부에서 어댑팅
- **Decorator + Proxy**: 원격 프록시 위에 로깅/메트릭/캐싱 데코레이터
- **Bridge + Composite**: 구현별 렌더러를 가진 도형 트리를 균일 처리
- **Flyweight + Composite**: 큰 씬 그래프에서 **재질/폰트** 공유 + 트리 집계

---

## 마무리

구조 패턴은 **소프트웨어의 뼈대와 결합 형태를 설계하는 도구**다.
문제의 본질(불일치/복잡도/부분-전체/동적 조합/공유/접근 제어)을 정확히 규정하고, **가장 얇고 투명한 구조적 해법**을 선택하라.
남용 대신 **명확한 목적과 계약**, **측정 가능한 품질(성능/테스트)**, **간결한 경계**가 장기 유지보수성을 보장한다.

이제 각 프로젝트 맥락에 맞게 위의 패턴들을 **필요한 만큼만** 선택·조합하라.
핵심은 “**합성 우선, 얇은 경계, 명확한 계약, 측정과 테스트**”다.
