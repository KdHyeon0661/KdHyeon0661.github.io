---
layout: post
title: C - 기본 문법
date: 2024-08-20 19:20:23 +0900
category: C
---
# C 기본 문법: 변수, 자료형, 연산자 심층 가이드

## 들어가며

C 프로그래밍을 시작할 때 변수, 자료형, 연산자 개념은 마치 언어의 알파벳과 같습니다. 이번 포스팅에서는 단순한 문법 나열을 넘어, 실제 개발에서 마주치는 함정과 실무적인 팁까지 다루어 보겠습니다. 코드 한 줄 한 줄이 어떻게 동작하는지, 왜 그런 결과가 나오는지 이해하는 것이 중요합니다.

## 시작하기 전: 미니 샘플 코드

이 장에서 배울 모든 개념이 녹아있는 예제로 시작해보겠습니다:

```c
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h> // PRId64 등 포맷 매크로 사용

int main(void) {
    // 다양한 자료형의 변수 선언과 초기화
    int           age    = 25;
    unsigned      flags  = 0u;
    long long     big    = 9'000'000'000LL; // 큰 수는 작은따옴표로 가독성 향상
    double        rate   = 3.14;            // 실수 리터럴 기본값은 double
    float         ratio  = 3.14f;           // float 타입 명시

    // 상수와 형 변환
    const int     MAX_USERS = 100;
    uint8_t       small  = 250u;
    int           widen  = small + 10;      // 정수 승격 발생
    double        avg    = (double)age / 3; // 명시적 형 변환으로 정밀도 확보

    // 다양한 연산자 활용
    flags |= 0x2;                           // 비트 연산으로 플래그 설정
    int ok = (age > 18) && (flags & 0x2);   // 논리와 비트 연산 조합

    // 안전한 출력 방식
    int64_t n = -1234567890123LL;
    printf("나이: %d, 상태: %d, 큰 수: %" PRId64 "\n", age, ok, n);
    printf("평균: %.2f, 비율: %f\n", avg, ratio);

    // 문자 처리
    char grade = 'A';
    printf("등급: %c (ASCII 값: %d)\n", grade, grade);

    return 0;
}
```

## 변수와 자료형: 메모리의 기본 단위

### 변수 선언과 초기화

변수는 데이터를 저장하는 메모리 공간에 이름을 붙인 것입니다. C에서는 모든 변수를 사용하기 전에 반드시 선언해야 합니다:

```c
int age = 25;           // 정수형 변수
float pi = 3.14f;       // 단정밀도 부동소수점
char grade = 'A';       // 문자형
double price = 99.99;   // 배정밀도 부동소수점
```

**중요한 차이점**: 
- 지역 변수는 초기화하지 않으면 **쓰레기 값**이 들어갑니다.
- 전역 변수와 정적 변수는 자동으로 **0으로 초기화**됩니다.

### 플랫폼 독립적인 자료형 사용하기

C 언어의 기본 자료형 크기는 플랫폼에 따라 달라질 수 있습니다. 이식성이 중요한 코드에서는 `<stdint.h>`의 고정폭 정수형을 사용하는 것이 좋습니다:

```c
#include <stdint.h>
#include <inttypes.h>  // 포맷 문자열 매크로 포함

int32_t fixed_width = -100;           // 항상 32비트 부호 있는 정수
uint64_t large_unsigned = 123456789ULL; // 항상 64비트 부호 없는 정수

// 안전한 출력
printf("32비트: %" PRId32 ", 64비트: %" PRIu64 "\n", 
       fixed_width, large_unsigned);
```

### 주요 자료형의 크기와 범위

다음은 일반적인 시스템에서의 자료형 크기입니다 (실제 값은 `sizeof()`로 확인하세요):

| 자료형 | 일반적 크기 | 설명 및 주의사항 |
|--------|-------------|-------------------|
| `char` | 1바이트 | 기본 부호 여부는 컴파일러에 따라 다름 |
| `short` | 2바이트 | |
| `int` | 4바이트 | 가장 일반적인 정수형 |
| `long` | 4 또는 8바이트 | **Windows와 Unix 차이 주의!** |
| `long long` | 8바이트 | C99 표준 |
| `float` | 4바이트 | 약 6-7자리 정밀도 |
| `double` | 8바이트 | 약 15-16자리 정밀도 |

**확인 방법**:
```c
printf("int 크기: %zu 바이트\n", sizeof(int));
printf("long 크기: %zu 바이트\n", sizeof(long));
```

## 상수: 변하지 않는 값들

### const 키워드: 타입 안전한 상수

`const` 키워드는 변수를 읽기 전용으로 만듭니다:

```c
const int MAX_USERS = 100;      // 컴파일 타임에 값이 고정
const double PI = 3.1415926535;
```

**장점**: 타입 검사가 가능하고, 디버깅 시 추적이 용이합니다.

### const와 포인터의 조합

const의 위치에 따라 의미가 달라집니다:

```c
int value = 10;
int other = 20;

// 1. 포인터가 가리키는 값이 상수
const int *ptr1 = &value;
// *ptr1 = 20;  // 컴파일 오류: 값 변경 불가
ptr1 = &other;  // 포인터 자체는 변경 가능

// 2. 포인터 자체가 상수
int *const ptr2 = &value;
*ptr2 = 20;     // 값 변경 가능
// ptr2 = &other; // 컴파일 오류: 포인터 변경 불가

// 3. 둘 다 상수
const int *const ptr3 = &value;
// *ptr3 = 20;    // 오류
// ptr3 = &other; // 오류
```

### #define 매크로: 전처리기 수준의 상수

```c
#define PI 3.141592653589793
#define MAX(a,b) ((a) > (b) ? (a) : (b))
```

**주의사항**: 매크로는 단순 텍스트 치환입니다. 괄호를 잊지 마세요!

```c
// 위험한 예제
#define SQUARE(x) x * x
int result = SQUARE(3 + 2);  // 3 + 2 * 3 + 2 = 11 (의도한 25 아님)

// 올바른 예제
#define SQUARE(x) ((x) * (x))
```

### enum: 의미 있는 정수 상수 집합

```c
typedef enum {
    STATE_IDLE = 0,
    STATE_RUNNING = 1,
    STATE_PAUSED = 2,
    STATE_ERROR = 99
} SystemState;

SystemState current = STATE_IDLE;
```

## static 키워드: 두 가지 중요한 의미

### 1. 정적 저장 기간 (함수 내부)

함수 내부에서 선언된 static 변수는 함수 호출 간에 값을 유지합니다:

```c
#include <stdio.h>

void count_calls(void) {
    static int call_count = 0;  // 최초 호출 시만 0으로 초기화
    call_count++;
    printf("함수 호출 횟수: %d\n", call_count);
}

int main(void) {
    count_calls();  // 1 출력
    count_calls();  // 2 출력
    count_calls();  // 3 출력
    return 0;
}
```

### 2. 내부 연결 (파일 범위)

파일 수준에서 static을 사용하면 해당 파일 내부에서만 접근 가능합니다:

```c
// file1.c
static int internal_counter = 0;  // 다른 파일에서 접근 불가
static void helper_function(void) { /* 내부 전용 */ }

// file2.c
extern int internal_counter;  // 연결 오류 발생!
```

## 연산자: 데이터 조작의 도구

### 연산자 종류와 우선순위

C 언어에는 다양한 연산자가 있으며, 우선순위에 따라 계산 순서가 결정됩니다:

| 우선순위 | 연산자 | 설명 |
|----------|---------|------|
| 1 | `()` `[]` `.` `->` | 함수 호출, 배열 첨자, 멤버 접근 |
| 2 | `!` `~` `++` `--` `+` `-` `*` `&` `(type)` `sizeof` | 단항 연산자 |
| 3 | `*` `/` `%` | 곱셈, 나눗셈, 나머지 |
| 4 | `+` `-` | 덧셈, 뺄셈 |
| 5 | `<<` `>>` | 비트 시프트 |
| 6 | `<` `<=` `>` `>=` | 비교 연산 |
| 7 | `==` `!=` | 동등 비교 |
| 8 | `&` | 비트 AND |
| 9 | `^` | 비트 XOR |
| 10 | `|` | 비트 OR |
| 11 | `&&` | 논리 AND |
| 12 | `||` | 논리 OR |
| 13 | `?:` | 조건 연산자 |
| 14 | `=` `+=` `-=` 등 | 대입 연산자 |
| 15 | `,` | 쉼표 연산자 |

**실용적 조언**: 복잡한 표현식에서는 괄호를 사용해 의도를 명확히 하세요.

### 연산자 함정과 주의사항

**정수 나눗셈**:
```c
int a = 5, b = 2;
int result = a / b;  // 결과는 2 (소수점 이하 버림)
float correct = (float)a / b;  // 결과는 2.5
```

**증감 연산자 부작용**:
```c
int i = 0;
int j = i++ + i++;  // 미정의 동작(undefined behavior)!
// 컴파일러마다 결과가 다를 수 있음
```

**비트 시프트 주의**:
```c
int x = 1 << 31;     // 부호 있는 정수에서 음수로 오버플로 가능
unsigned y = 1u << 31;  // 안전한 방법
```

## 형 변환: 데이터 타입의 변환

### 암시적 형 변환 (자동 변환)

C 컴파일러는 필요에 따라 자동으로 형 변환을 수행합니다:

1. **정수 승격**: `char`, `short` 등 작은 정수형은 `int`로 승격
2. **산술 변환**: 서로 다른 타입의 연산에서 공통 타입으로 변환

```c
char c = 'A';
int i = c + 10;  // char가 int로 승격된 후 연산

double d = 3.14;
int n = 10;
double result = d + n;  // n이 double로 변환 후 연산
```

### 명시적 형 변환 (캐스팅)

의도를 명확히 하기 위해 명시적으로 타입 변환을 지시할 수 있습니다:

```c
int total = 100, count = 30;
// 정수 나눗셈 피하기
double average = (double)total / count;

// 데이터 손실 인지
double price = 19.99;
int rounded = (int)price;  // 19 (소수점 이하 손실)
```

### 부호 있는/없는 정수 혼합

부호 있는 정수와 부호 없는 정수를 혼합할 때 주의가 필요합니다:

```c
unsigned int u = 10;
int s = -5;

if (s < u) {
    // 예상과 다르게 실행되지 않을 수 있음
    // s가 unsigned로 변환되어 큰 값이 됨
}

// 안전한 비교
if (s < 0 || (unsigned int)s < u) {
    // 의도한 동작
}
```

## 리터럴과 출력 포맷

### 숫자 리터럴의 타입 지정

접미사를 사용해 리터럴의 타입을 명시할 수 있습니다:

```c
int decimal = 42;           // 기본 int
long big = 42L;             // long
long long huge = 42LL;      // long long
unsigned int pos = 42u;     // unsigned

float precise = 3.14f;      // float
double normal = 3.14;       // double (기본)
long double extra = 3.14L;  // long double

// 가독성을 위한 구분자 (C23부터 표준)
int million = 1'000'000;
long long billion = 1'000'000'000LL;
```

### printf/scanf 포맷 지정자

올바른 포맷 지정자를 사용하는 것이 중요합니다:

| 타입 | printf | scanf | 비고 |
|------|--------|-------|------|
| `int` | `%d` | `%d` | |
| `unsigned int` | `%u` | `%u` | |
| `long` | `%ld` | `%ld` | |
| `long long` | `%lld` | `%lld` | |
| `size_t` | `%zu` | `%zu` | C99+ |
| `float` | `%f` | `%f` | scanf에서는 float* 필요 |
| `double` | `%f` | `%lf` | |
| `char` | `%c` | `%c` | |
| 문자열 | `%s` | `%s` | |

**64비트 정수 안전 출력**:
```c
#include <inttypes.h>

int64_t large = -1234567890123LL;
uint64_t ularge = 1234567890123ULL;

printf("부호 있음: %" PRId64 "\n", large);
printf("부호 없음: %" PRIu64 "\n", ularge);
```

## 문자와 문자열 기초

### ASCII 문자

C에서 `char`는 사실 1바이트 정수입니다:

```c
char letter = 'A';
printf("문자: %c, ASCII 코드: %d\n", letter, letter);

// 문자 연산
char next = letter + 1;  // 'B'
char digit = '5' - '0';  // 정수 5
```

### 안전한 입력 처리

`scanf`는 간단하지만 위험할 수 있습니다. `fgets`와 변환 함수를 조합하는 것이 더 안전합니다:

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

int main(void) {
    char buffer[100];
    int number;
    
    printf("숫자 입력: ");
    if (fgets(buffer, sizeof(buffer), stdin)) {
        // 공백 제거
        char *endptr;
        errno = 0;
        long value = strtol(buffer, &endptr, 10);
        
        // 에러 체크
        if (errno == ERANGE) {
            printf("범위를 초과한 숫자입니다.\n");
        } else if (endptr == buffer) {
            printf("유효한 숫자가 아닙니다.\n");
        } else {
            number = (int)value;
            printf("입력한 숫자: %d\n", number);
        }
    }
    
    return 0;
}
```

## 실전 예제: 점수 통계 프로그램

학생들의 점수를 분석하는 프로그램으로 배운 개념을 종합해 보겠습니다:

```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX_STUDENTS 100
#define MIN_SCORE 0
#define MAX_SCORE 100

int main(void) {
    int scores[MAX_STUDENTS];
    int count = 0;
    int total = 0;
    int min = INT_MAX;
    int max = INT_MIN;
    
    // 점수 입력 받기
    printf("점수를 입력하세요 (음수 입력 시 종료):\n");
    
    while (count < MAX_STUDENTS) {
        int score;
        printf("학생 %d: ", count + 1);
        
        if (scanf("%d", &score) != 1) {
            printf("잘못된 입력입니다. 숫자를 입력하세요.\n");
            while (getchar() != '\n'); // 입력 버퍼 비우기
            continue;
        }
        
        if (score < 0) {
            break; // 음수 입력 시 종료
        }
        
        // 점수 범위 검증
        if (score < MIN_SCORE || score > MAX_SCORE) {
            printf("0부터 100 사이의 점수를 입력하세요.\n");
            continue;
        }
        
        scores[count] = score;
        total += score;
        
        if (score < min) min = score;
        if (score > max) max = score;
        
        count++;
    }
    
    if (count == 0) {
        printf("입력된 점수가 없습니다.\n");
        return 0;
    }
    
    // 통계 계산
    double average = (double)total / count;
    
    // 등급 분포 계산
    int grade_a = 0, grade_b = 0, grade_c = 0, grade_d = 0, grade_f = 0;
    
    for (int i = 0; i < count; i++) {
        if (scores[i] >= 90) grade_a++;
        else if (scores[i] >= 80) grade_b++;
        else if (scores[i] >= 70) grade_c++;
        else if (scores[i] >= 60) grade_d++;
        else grade_f++;
    }
    
    // 결과 출력
    printf("\n===== 성적 통계 =====\n");
    printf("학생 수: %d명\n", count);
    printf("총점: %d\n", total);
    printf("평균: %.2f\n", average);
    printf("최고점: %d\n", max);
    printf("최저점: %d\n", min);
    printf("\n등급 분포:\n");
    printf("A(90~100): %d명 (%.1f%%)\n", grade_a, (double)grade_a/count*100);
    printf("B(80~89):  %d명 (%.1f%%)\n", grade_b, (double)grade_b/count*100);
    printf("C(70~79):  %d명 (%.1f%%)\n", grade_c, (double)grade_c/count*100);
    printf("D(60~69):  %d명 (%.1f%%)\n", grade_d, (double)grade_d/count*100);
    printf("F(0~59):   %d명 (%.1f%%)\n", grade_f, (double)grade_f/count*100);
    
    return 0;
}
```

## 디버깅 팁과 모범 사례

1. **컴파일러 경고 최대한 활용하기**
   ```bash
   gcc -Wall -Wextra -Wpedantic -Werror program.c
   ```

2. **초기화 습관 들이기**
   ```c
   int uninitialized;  // 나쁜 예: 쓰레기 값
   int initialized = 0; // 좋은 예: 명시적 초기화
   ```

3. **형 변환 명시적으로 하기**
   ```c
   // 암시적 변환 (의도 불명)
   double result = total / count;
   
   // 명시적 변환 (의도 명확)
   double result = (double)total / count;
   ```

4. **상수는 대문자와 언더스코어 사용**
   ```c
   #define MAX_BUFFER_SIZE 1024
   const int MAX_RETRY_COUNT = 3;
   ```

## 자주 묻는 질문 (FAQ)

**Q: `int`와 `long`은 항상 크기가 다른가요?**
A: 아닙니다. 이는 플랫폼에 따라 다릅니다. Windows에서는 둘 다 4바이트인 경우가 많지만, Linux/Unix에서는 long이 8바이트인 경우가 많습니다. 이식성이 필요한 코드는 `<stdint.h>`를 사용하세요.

**Q: `char`는 signed인가요 unsigned인가요?**
A: C 표준은 이를 구현에 맡깁니다. 특정한 부호가 필요한 경우 `signed char` 또는 `unsigned char`를 명시적으로 사용하세요.

**Q: 정수 나눗셈에서 음수는 어떻게 처리되나요?**
A: C99부터는 0 방향으로 잘림(truncation toward zero)입니다. 즉, `-7 / 2`는 `-3`입니다.

**Q: 왜 `float`를 출력할 때 `%f`를 쓰고, 입력받을 때는 `%f`가 아닌가요?**
A: 가변 인자 함수에서는 `float`가 `double`로 승격되기 때문입니다. `scanf`에서는 포인터 타입이 정확해야 하므로 `float`에는 `%f`, `double`에는 `%lf`를 사용합니다.

## 마치며

변수, 자료형, 연산자는 C 프로그래밍의 기초입니다. 이 기초를 탄탄히 다지는 것이 향후 포인터, 메모리 관리, 자료구조 등 더 복잡한 개념을 이해하는 데 필수적입니다. 각 개념이 어떻게 상호작용하는지, 어떤 함정이 있는지 이해하는 것이 단순한 문법 암기보다 중요합니다.
