---
layout: post
title: C - 기본 문법
date: 2024-08-20 19:20:23 +0900
category: C
---
# 기본 문법: 변수, 자료형, 연산자

## 워밍업 예제 (이 장에서 배울 모든 것의 미니 샘플)

```c
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h> // PRId64 등 포맷 매크로

int main(void) {
    // 변수 선언 + 리터럴 + 접미사
    int           age    = 25;
    unsigned      flags  = 0u;
    long long     big    = 9'000'000'000LL; // 일부 컴파일러 확장: ' 구분자
    double        rate   = 3.14;            // 기본 실수 리터럴은 double
    float         ratio  = 3.14f;           // f 접미사로 float

    // 상수(const) vs 매크로(#define), 형 변환, 정수 승격
    const int     MAX_USERS = 100;
    uint8_t       small  = 250u;
    int           widen  = small + 10; // 정수 승격 주의
    double        avg    = (double)age / 3; // 명시적 형 변환으로 실수 나눗셈

    // 연산자 예제(산술/비트/논리/비교/대입 복합)
    flags |= 0x2;
    int ok = (age > 18) && (flags & 0x2);

    // printf 포맷(정수 폭 안전 출력)
    int64_t n = -1234567890123LL;
    printf("age=%d, ok=%d, n=%" PRId64 "\n", age, ok, n);
    printf("avg=%.2f, ratio=%f\n", avg, ratio);

    // 문자/아스키
    char grade = 'A';
    printf("grade=%c (%d)\n", grade, grade);

    return 0;
}
```

---

## 변수와 자료형

### 선언·초기화

```c
int age = 25;
float pi = 3.14f;
char grade = 'A';
```

- **선언 시 자료형 필수**.
- 지역 변수는 **초기화하지 않으면 불특정 값**(자동 저장 기간).
- 전역/정적 변수는 **자동으로 0 초기화**(정적 저장 기간).

### 표준 폭 정수형을 습관화

플랫폼별 `int/long` 크기는 다릅니다. **고정 폭**과 **관련 포맷 매크로**를 쓰면 휴대성이 좋아집니다.

```c
#include <stdint.h>
#include <inttypes.h>

int32_t a = -10;
uint64_t u = 42ULL;
printf("%" PRId32 " %" PRIu64 "\n", a, u);
```

### 크기와 범위(플랫폼 의존성 명시)

| 자료형 | 전형적 크기(ILP32/LP64) | 비고 |
|---|---|---|
| `char` | 1B | 부호는 구현 의존(기본 signed 또는 unsigned) |
| `short` | 2B | |
| `int` | 4B | |
| `long` | 4B(Windows, LLP64) / 8B(Unix, LP64) | **차이 주의** |
| `long long` | 8B | |
| `float` | 4B | 약 6~7자리 유효 |
| `double` | 8B | 약 15~16자리 유효 |
| `long double` | 8~16B | 구현 의존 |

> 실제 크기는 `sizeof`로 확인하세요.

```c
#include <stdio.h>

int main(void){
    printf("sizeof(int)=%zu\n", sizeof(int));
    return 0;
}
```

### 부호·이진 표현과 범위(2의 보수)

2의 보수 표현에서 `w`-비트 부호 있는 정수의 범위:

$$
-(2^{w-1}) \le x \le 2^{w-1}-1
$$

예: 8비트 `signed char` → \(-128 \dots 127\)

---

## 상수와 매크로 — const / #define / enum / inline

### `const` (타입 있는 상수)

```c
const int MAX_USERS = 100; // 타입 검사/디버깅 유리
```

- **타입**이 있어 컴파일러가 체크 가능.
- 주소를 취하면 저장 공간이 생길 수 있음(최적화에 따라 상수 폴딩).

#### 포인터와 `const` — 3가지 패턴

```c
int a = 10, b = 20;

// 1) 포인터가 가리키는 "값"이 상수 (읽기 전용), 포인터는 다른 곳을 가리킬 수 있음
const int *p1 = &a;   // or int const *p1
//*p1 = 30;           // 오류
p1 = &b;              // 포인터 자체는 변경 가능

// 2) 포인터 자체가 상수(주소 고정), 가리키는 값은 변경 가능
int * const p2 = &a;
//p2 = &b;            // 오류: 주소 변경 불가
*p2 = 30;             // 값 변경은 가능

// 3) 둘 다 상수
const int * const p3 = &a;
//p3 = &b;            // 오류
//*p3 = 30;           // 오류
```

> **주의**: 초안의 `int* const` 예제가 `const int*` 코드와 혼동되어 있었는데, 위처럼 구분이 정확합니다.

#### `const`와 API 설계

- 입력 전용 버퍼 인자: `const void *buf`
- 읽기 전용 문자열 인자: `const char *s`

### `#define` (전처리기 매크로)

```c
#define PI 3.141592653589793
#define MAX(a,b) ((a) > (b) ? (a) : (b))

```

- **단순 치환**. **타입 없음**. 디버깅 추적 어려움.
- **괄호 필수**: 우선순위/부작용 방지.

#### 매크로 함수의 위험 예

```c
#define SQR(x) ((x)*(x))

int i = 2;
int r = SQR(i++); // i가 2번 증가 → 부작용
```

→ 대안: **`static inline` 함수**

```c
static inline int sqr_int(int x){ return x*x; }
```

### `enum` (의미 있는 정수 상수)

```c
typedef enum { ROLE_USER=0, ROLE_ADMIN=1 } Role;
```

- **타입 안정성**은 제한적(기본은 int 호환).
- 디버깅·가독성 향상.

---

## `static` — 저장 기간과 연결(링크)를 동시에 이해

### 저장 기간 (storage duration)

- **자동(automatic)**: 블록 스코프 지역 변수. 함수 호출 때 생성/리턴 시 소멸.
- **정적(static)**: 프로그램 시작~종료까지 존재. 초기화 없으면 0.

### `static`의 두 의미

1) **정적 저장 기간**(함수 내부 지역 변수에도 적용)

```c
#include <stdio.h>

void func(void) {
    static int count = 0; // 최초 1회 초기화, 이후 호출 간 값 유지
    printf("%d\n", ++count);
}
```

2) **내부 연결(Internal Linkage)**: 파일 범위 심볼 은닉

```c
// file1.c
static int g = 42;        // 다른 번역 단위에서 보이지 않음
static void helper(void); // 내부 전용 함수

// file2.c 에서는 g, helper 심볼을 찾을 수 없음
```

> 라이브러리/모듈에서 **캡슐화** 도구로 매우 유용.

---

## 연산자 — 종류, 우선순위, 정의역, 함정

### 분류 요약

| 종류 | 연산자 | 비고 |
|---|---|---|
| 산술 | `+ - * / %` | 정수 나눗셈 **0쪽으로 절단**(C99+), `%`는 나눗셈과 일관 |
| 대입 | `= += -= *= /= %= <<= >>= &= ^= |=` | 복합 대입은 좌변을 한 번만 평가 |
| 비교 | `== != > < >= <=` | 결과는 `int`(0/1) |
| 논리 | `&& || !` | **단락 평가** |
| 증감 | `++ --` | 전위/후위, **부작용 시점** 주의 |
| 비트 | `& | ^ ~ << >>` | 좌측 피연산자 폭에 맞춰 동작 |
| 기타 | `?: , & * sizeof (type)` | `sizeof`는 런타임 평가 아님 |

```c
int a = 5, b = 2;
printf("%d\n", a / b);   // 2 (정수 나눗셈)
printf("%f\n", (double)a / b); // 2.5
```

### 우선순위와 결합성(부분표)

1. `()` 함수 호출·배열첨자·구성원 접근
2. 단항 `+ - ~ ! (type) * & sizeof` (우결합)
3. `* / %`
4. `+ -`
5. `<< >>`
6. `< <= > >=`
7. `== !=`
8. `&`
9. `^`
10. `|`
11. `&&`
12. `||`
13. `?:` (우결합)
14. `= += -= ...` (우결합)
15. `,`

> 복잡해지면 **괄호로 의도 명확화**.

### 미세 규칙·함정

- `a = b = c = 0;` 가능(우결합).
- 쉬프트: 음수 쉬프트 폭·음수 피연산자 쉬프트는 **구현/정의되지 않음**에 주의.
- 비트 연산과 부호 확장: `~x`에서 상위 비트 채움 주의.

---

## 형 변환(Type Conversion) — 정수 승격과 통상 산술 변환

### 묵시적 변환(암시적)

- **정수 승격(Integer Promotions)**: `char`, `short` 등은 `int`(또는 `unsigned int`)로 승격.
- **통상 산술 변환(Usual Arithmetic Conversions)**: 이항 산술에서 공통 타입으로 정렬.

규칙 스케치(핵심 요지만):

1) 실수 vs 정수 → **실수로 변환**
2) `long double` > `double` > `float`
3) 정수끼리: 표에서 **표현 범위가 넓은 타입**으로 승격
4) 부호 혼합 시, 표현할 수 없는 경우 **unsigned**가 될 수 있음

```c
unsigned int u = 1;
int i = -1;
printf("%u\n", u + i); // 놀라운 큰 값이 나올 수 있음
```

### 명시적 변환(캐스팅)

```c
int a = 7, b = 2;
float r1 = a / b;         // 3 (정수 나눗셈 후 float)
float r2 = (float)a / b;  // 3.5 (의도한 결과)
```

#### 데이터 손실 예

```c
int x = 300;
char y = (char)x;     // 구현에 따라 44, -56 등
printf("%d\n", (int)y);
```

### 수학적 관점(부호 있는 오버플로)

부호 있는 정수의 덧셈/곱셈 오버플로는 **UB(Undefined Behavior)** 입니다.

$$
\text{if } x \in \mathbb{Z}_{w},\; x + 1 \text{ overflows } \Rightarrow \text{UB}
$$

> 반면, **부호 없는** 정수는 **모듈러 2^w 산술**로 래핑됩니다.

---

## 리터럴과 포맷 — 정확한 타입 매칭

### 정수 리터럴 접미사

| 예 | 타입 후보 |
|---|---|
| `42` | `int` → `long` → `long long` |
| `42u` | `unsigned int` → `unsigned long` → ... |
| `42L` | `long` |
| `42LL` | `long long` |
| `0xFFu` | `unsigned int` 등 |

### 실수 리터럴 접미사

- 기본: `double`
- `f`/`F`: `float`
- `l`/`L`: `long double`

### `printf/scanf` 포맷 핵심표

| 타입 | `printf` | `scanf` |
|---|---|---|
| `int` | `%d` | `%d` |
| `unsigned` | `%u` | `%u` |
| `long` | `%ld` | `%ld` |
| `long long` | `%lld` | `%lld` |
| `size_t` | `%zu` | `%zu` (C99+) |
| `double` | `%f` | `%lf` |
| `float` | **호출 시** `double`로 승격 → `%f` |
| `char` | `%c` / `%hhd` | `%c` / `%hhd` |
| 64비트 정수 | `%" PRId64 "` | `%" SCNd64 "` |

```c
#include <inttypes.h>

int64_t v = -1;
printf("%" PRId64 "\n", v);
```

---

## 문자형과 아스키 / 확장 문자

```c
char ch = 'A';
printf("%c %d\n", ch, ch); // A 65
```

- `char`는 사실 **작은 정수형**.
- 한글 등 다국어는 **인코딩**(UTF-8 등)과 **locale**을 별도 고려해야 합니다.
  C11에는 `<uchar.h>`의 `char16_t/char32_t`가 있습니다(플랫폼 호환성 주의).

---

## 안전한 입력: `scanf` 대신 `fgets`+변환 함수

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

int main(void){
    char buf[64];
    if (!fgets(buf, sizeof buf, stdin)) return 1;

    char *end = NULL;
    errno = 0;
    long v = strtol(buf, &end, 10);
    if (errno == ERANGE || end == buf) {
        fputs("invalid number\n", stderr);
        return 1;
    }
    printf("v=%ld\n", v);
    return 0;
}
```

---

## `static` 실전 예 — 호출 횟수, 파일 은닉

```c
// counter.c
#include <stdio.h>

void call_counter(void){
    static unsigned count = 0; // 정적 저장 + 내부 상태 유지
    printf("#%u\n", ++count);
}
```

```c
// api.c
static int hidden = 42;     // 내부 연결: 외부로 노출되지 않음
static void secret(void) { /* ... */ } // 내부 전용 함수
```

---

## 비트 연산과 마스크

```c
#define F_READ  (1u<<0)
#define F_WRITE (1u<<1)
#define F_EXEC  (1u<<2)

unsigned perm = 0;
perm |= F_READ | F_WRITE;
perm &= ~F_WRITE;

int can_read = !!(perm & F_READ);
```

- 쉬프트는 **정수 폭**과 **부호**를 인지하고 사용.
- `1u<<31`은 32비트 `unsigned`에서만 정의적 — **폭을 의식**하세요.

---

## 논리 연산의 단락 평가와 부작용

```c
int f(void){ puts("f"); return 0; }
int g(void){ puts("g"); return 1; }

int main(void){
    if (g() || f()) { /* f()가 호출되지 않음 */ }
    if (f() && g()) { /* g()가 호출되지 않음 */ }
    return 0;
}
```

- `&&`, `||`는 **좌 → 우** 평가, 필요 없으면 우항 **평가 안 함**.
- 함수 호출·증감 연산의 **부작용 시점**에 유의.

---

## 연습: 안전한 `max` API를 세 가지 방식으로

### 매크로 (주의 필요)

```c
#define MAX(a,b) ((a) > (b) ? (a) : (b))

```

### `static inline` (권장)

```c
static inline int max_int(int a, int b){ return a > b ? a : b; }
```

### `_Generic` (C11)으로 타입별 선택

```c
#define MAX_T(a,b) _Generic((a)+(b), \

    int: max_int,                     \
    double: max_double,               \
    default: max_long                 \
)(a,b)
```

> C23에서는 `_Generic` 확장과 `typeof` 표준화로 더 유연해짐(컴파일러 지원 확인).

---

## 디버깅 체크리스트(이 장 범위 내)

- **경고 최대로**: GCC/Clang `-Wall -Wextra -Wpedantic`, MSVC `/W4`
- 포맷 불일치: 포맷 문자열 vs 인자 타입 일치 확인
- 정수 오버플로: 부호 있는 연산은 UB 가능 → 폭 넉넉한 타입/검사
- 캐스팅 남용 금지: 인터페이스에서 필요한 최소로
- 리터럴 타입: 접미사로 의도 명확화(`f`, `LL`, `u` 등)

---

## 종합 예제: 미니 점수 통계기

요구: `scores.txt`에서 0~100 정수 점수들을 읽어 평균/최대/최소/개수를 계산한다.
안전 입력(`fgets` + `strtol`), 타입 매칭(정수 승격), 포맷 출력, 연산자 사용을 종합.

```
scores.txt
-----------
90
100
75
88
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

int main(void){
    FILE *fp = fopen("scores.txt", "r");
    if (!fp) { perror("fopen"); return 1; }

    char line[64];
    unsigned count = 0;
    long sum = 0;
    int min = 101, max = -1;

    while (fgets(line, sizeof line, fp)){
        errno = 0;
        char *end = NULL;
        long v = strtol(line, &end, 10);
        if (errno == ERANGE || end == line || v < 0 || v > 100) {
            fprintf(stderr, "invalid: %s", line);
            continue;
        }
        int score = (int)v;
        if (score < min) min = score;
        if (score > max) max = score;
        sum += score;
        ++count;
    }
    fclose(fp);

    if (count == 0) { puts("no valid data"); return 0; }
    double avg = (double)sum / (double)count;

    printf("count=%u min=%d max=%d avg=%.2f\n", count, min, max, avg);
    return 0;
}
```

---

## 빠르게 보는 요약 표

### `const` vs `#define`

| 항목 | `const` | `#define` |
|---|---|---|
| 타입 | 있음(체크 가능) | 없음(치환) |
| 디버깅 | 용이 | 어려움 |
| 주소 취득 | 가능 | 불가(치환) |
| 함수 대체 | 불가 | 가능(매크로 함수, 위험) |
| 권장도 | **높음** | 상수엔 가급적 지양, 매크로 함수는 신중 |

### 형 변환 요점

- 정수/실수 혼합 → 실수
- 정수끼리 → **폭/부호 넓은 쪽**으로
- **명시적 캐스트**로 의도 드러내기

---

## 자주 묻는 질문(FAQ)

**Q1. `int`와 `long`은 항상 32비트·64비트인가?**
A. 아닙니다. **플랫폼/ABI**마다 다릅니다. Windows(LLP64)에서 `long`은 32비트입니다. **`stdint.h`**를 사용하세요.

**Q2. `char`는 signed? unsigned?**
A. 구현 의존. **문자 처리/비트 연산** 시 `signed char`/`unsigned char`를 명시하세요.

**Q3. 정수 나눗셈의 음수 처리?**
A. C99부터 **0 쪽으로 절단(truncation toward zero)** 입니다.

**Q4. 왜 `float` 출력이 `%f`이고, `scanf`로는 `"%f"`가 `double`?**
A. 가변 인자 호출에서 `float`는 **승격되어 `double`**이 됩니다. `scanf`에서는 `"%f"`가 `float*`, `"%lf"`가 `double*` 입니다.

---

## 마무리·다음 단계

- 이 장에서 **변수·자료형·리터럴·상수·static·연산자·형 변환·문자/아스키·안전 입출력**의 핵심과 함정을 확장 정리했습니다.
- 다음 장에서는 **배열/포인터/문자열**로 넘어가 **정수 승격/포인터 산술/메모리 모델**을 실제 디버깅 도구와 함께 파헤칩니다.
