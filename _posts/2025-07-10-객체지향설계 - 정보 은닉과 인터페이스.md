---
layout: post
title: 객체지향설계 - 정보 은닉과 인터페이스
date: 2025-07-10 19:20:23 +0900
category: 객체지향설계
---
# 정보 은닉과 인터페이스

## 1. 정보 은닉(Information Hiding)

### 정의
> **정보 은닉**은 모듈(혹은 객체)의 **내부 표현·알고리즘·불변식을 외부에서 보지 못하게 숨기고**, 외부에는 **안정적인 인터페이스**만 노출하는 설계 원칙이다.

- 내부 변경이 외부에 파급되지 않도록 **변경의 축**을 모듈 내부로 가둔다.
- 외부는 **무엇을 할 수 있는가(메시지/계약)**만 알면 된다.

### 목적
- 변경 내성, 오류 억제, 모듈성 강화, 테스트 용이성, 팀 병렬 개발.

### 캡슐화와의 관계(헷갈리기 쉬운 구분)
| 개념 | 초점 | 구현 수단 |
|---|---|---|
| 캡슐화(Encapsulation) | 상태와 행위를 하나의 단위로 묶음 | 클래스/객체라는 물리적 단위 |
| 정보 은닉(Information Hiding) | **보여줄 것 vs 숨길 것**의 의사결정 | 접근 제한자, 모듈/패키지 경계, API 설계 |
| 추상화(Abstraction) | 본질만 드러내는 모델링 | 인터페이스, 추상 타입 |

세 가지는 서로 보완한다: **캡슐화된 단위**에 대해 **정보를 숨기고**, **추상 인터페이스**로 외부와 통신한다.

---

## 2. 표현 노출(Representation Exposure) 방지

### 노출이 있는 잘못된 예
```java
public class Product {
    public int price;
    public int discount;
    public int finalPrice() { return price - discount; }
}
```
- 외부가 `price = -1000` 같은 비정상 상태를 만들 수 있다.

### 최소 개선(게터/세터 + 유효성)
```java
public class Product {
    private int price;
    private int discount;
    public void setPrice(int price) { if (price >= 0) this.price = price; }
    public void setDiscount(int discount) { if (discount >= 0 && discount <= price) this.discount = discount; }
    public int getFinalPrice() { return price - discount; }
}
```

### 컬렉션/배열의 숨은 노출
```java
public class Cart {
    private final List<Item> items = new ArrayList<>();
    public List<Item> getItems() { return items; } // 위험: 외부가 직접 수정
}
```
**해결**: 방어적 복사/불변 뷰
```java
public class Cart {
    private final List<Item> items = new ArrayList<>();
    public List<Item> getItems() { return Collections.unmodifiableList(items); }
    public void add(Item i){ items.add(Objects.requireNonNull(i)); }
}
```

### 불변 값 객체(Value Object)로 정밀도·의미 보존
```java
public final class Money {
    private final java.math.BigDecimal amount;
    private final String currency; // "KRW", "USD"
    // 생성·동치·연산에서 통화 일치 보장
}
```
- 금액을 `int/double`로 흘리는 순간 정보 은닉과 불변식이 깨지기 쉽다.

---

## 3. 계약(Design by Contract)으로 은닉 강화

어떤 공개 메서드든 **전제(Pre)**, **사후(Post)**, **불변식(Inv)**을 정의하라.

$$
\text{Pre} \Rightarrow \text{Post},\quad \text{항상 Inv 유지}
$$

예: 할인 규칙
$$
\text{Pre}: 0 \le d \le p \quad;\quad \text{Post}: \text{final} = p - d \ge 0
$$

코드 내 검증(예외) 또는 테스트로 고정한다.

---

## 4. 접근 제어와 모듈 경계

| 언어/수단 | 의미 |
|---|---|
| `private` | 클래스 내부에서만 |
| `package-private`(Java) | 같은 패키지에서만 |
| `internal`(Kotlin/C#) | 같은 모듈/어셈블리에서만 |
| `protected` | 상속 계층에서만(주의: 결합 증가) |
| 모듈(자바9 `module-info.java`) | 공개 API vs 내부 구현 명시 |

**원칙**: 기본은 가장 좁게. 단위 테스트 때문에 넓히지 말고 **패키지 경계/팩토리**를 활용하라.

---

## 5. 인터페이스(Interface)

### 정의
> **인터페이스**는 “무엇을 할 수 있는가”라는 **행위 계약**의 목록이다. 구현은 숨기고, 시그니처/의미만 노출한다.

### 목적
- 결합도 감소, 교체 용이, 테스트 용이, 확장성(OCP) 확보.

### 예: 결제 인터페이스
```java
public interface PaymentMethod { void pay(Money amount); }

public final class CreditCard implements PaymentMethod {
    public void pay(Money amount) { /* 카드 PG 연동 */ }
}
public final class KakaoPay implements PaymentMethod {
    public void pay(Money amount) { /* 카카오페이 연동 */ }
}
```

클라이언트는 구현을 알 필요가 없다.
```java
public final class Checkout {
    public void processPayment(PaymentMethod method, Money amount) { method.pay(amount); }
}
```

---

## 6. 인터페이스와 정보 은닉의 상호작용

| 축 | 정보 은닉 | 인터페이스 |
|---|---|---|
| 목적 | 내부 변화를 외부로부터 격리 | 협력 계약을 명시 |
| 수단 | 접근 제한자, 모듈 경계, 불변식 | public 메서드/추상 타입 |
| 효과 | 파급 감소, 안정성 | 느슨한 결합, 다형성 |

핵심: **내부는 감추고, 외부는 계약만**. 구현이나 데이터 구조(예: `ArrayList`)를 API에 새어나오게 하지 말라.

---

## 7. 인터페이스 분리(ISP)와 역할 중심 설계

**문제**: 비대한 인터페이스(거대 묶음)는 구현체/클라이언트를 불필요하게 결합시킨다.
**해결**: 역할별로 쪼갠 작은 인터페이스.

```java
interface Authorizable { boolean authorize(User u); }
interface Chargeable { void charge(Money m); }
interface Refundable { void refund(Money m); }
```
구현은 필요한 것만 선택적으로 결합한다.

---

## 8. 의존 역전(DIP)과 Port/Adapter

**DIP**: 상위 정책(도메인)은 **구체 구현이 아니라 추상**(인터페이스)에 의존해야 한다.

**Port/Adapter**(헥사고날 아키텍처):
- **Port(추상·역할)**: `PaymentMethod`, `MessageBus`, `Clock` …
- **Adapter(구현)**: `KakaoPayAdapter`, `StripeAdapter` …

```java
public interface PaymentPort { void pay(Money amount); }           // Port
public final class StripeAdapter implements PaymentPort { /*...*/ } // Adapter

public final class OrderService {
    private final PaymentPort payment;
    public OrderService(PaymentPort payment){ this.payment = payment; }
    public void checkout(Order o){ payment.pay(o.total()); }
}
```

---

## 9. 실전 사례: 결제 시스템 설계 확장

### 문제: 새로운 결제수단 추가 시 서비스 수정(OCP 위반)
```java
public class PaymentService {
    public void processCreditCard(int amount){ /*...*/ }
    public void processKakaoPay(int amount){ /*...*/ }
    // 새 수단이 추가될 때마다 메서드/분기 추가
}
```

### 개선: 인터페이스+정보 은닉
```java
public interface PaymentMethod { void pay(Money amount, String idempotencyKey); }
public final class PaymentService {
    public void process(PaymentMethod method, Money amount, String key) {
        method.pay(amount, key);
    }
}
```

여기에 **멱등키**를 포함해 네트워크 재시도에도 안전하게 한다(정보 은닉의 일부로 내부 중복 방지 로직을 숨김).

---

## 10. 동시성·멱등성과 은닉

- 외부는 `pay()`가 **원자적**으로 보이길 원한다.
- 내부에서 락/트랜잭션/중복 검출을 감춘다.

```java
public final class KakaoPay implements PaymentMethod {
    private final Set<String> processed = ConcurrentHashMap.newKeySet();
    @Override
    public void pay(Money amount, String key){
        if (!processed.add(key)) return; // 멱등
        // 내부 트랜잭션/락은 숨김
        // 실제 결제 처리
    }
}
```

---

## 11. API 표면에서의 자료형 노출 주의

- `List`를 반환해야 한다면 **불변 뷰/스냅샷**으로
- 내부 시계 `Clock.systemUTC()` 같은 구체를 노출하지 말고 **포트**로 감싸라
- JSON 스키마에 내부 엔티티를 직렬화하지 말고 **DTO**를 사용

```java
public record PaymentRequest(String currency, String amount, String idempotencyKey) {}
public record PaymentResponse(String status, String transactionId) {}
```

---

## 12. 수식으로 보는 안정 API

모듈 \(M\)의 공개 API를 \(A\), 내부 표현을 \(R\), 불변식을 \(I\)라 하자.
- 외부 가시성: \( \text{visible}(M) = A \)
- 내부 변경 자유도: \( \forall r, r' \in R,\ I(r) \land I(r') \Rightarrow \text{Obs}(A,r) = \text{Obs}(A,r') \)

즉 **불변식을 만족하는 한 내부 표현이 달라도 외부 관찰 결과는 동일**해야 한다.

---

## 13. 테스트: 계약 테스트와 목(Mock)

### 계약 테스트(상위 역할의 테스트를 공유)
```java
abstract class PaymentContract {
    protected abstract PaymentMethod sut();
    @org.junit.jupiter.api.Test
    void pays_positive_amounts(){
        sut().pay(Money.of(new java.math.BigDecimal("1000"), "KRW"), "k1");
        // 실패/예외가 없어야 하고, 멱등키 재호출은 중복 처리되지 않아야 한다 등
    }
}
final class CreditCardTest extends PaymentContract {
    protected PaymentMethod sut(){ return new CreditCard(/*deps*/); }
}
```
- 모든 구현체가 **같은 계약**을 만족한다.

### 목/스텁으로 외부 의존 차단
```java
class FakePaymentGateway implements Gateway { /* 메모리 내 구현 */ }
```

---

## 14. 버전 호환과 인터페이스 진화

- 인터페이스는 **작게** 설계하고, 확장 필요 시 **새 인터페이스** 또는 **디폴트 메서드**로 진화
- **소거(이름/시그니처 변경)**는 호환을 깨뜨린다 → **어댑터** 제공 후 단계적 폐기

버전 전략 예:
1) `PaymentMethodV1.pay(Money)`
2) 새 요구: 멱등키 → `PaymentMethodV2.pay(Money, String)`
3) V1 어댑터를 통해 V2 위에 V1을 구현, 점진 폐기

---

## 15. 안티패턴

| 안티패턴 | 증상 | 대안 |
|---|---|---|
| 게터/세터 남발 | 모든 필드 공개와 다름 | 의미 있는 메시지(행위) 제공 |
| 거대 인터페이스 | 사용하지 않는 메서드 의존 | ISP로 분리 |
| 내부 타입 노출 | `ArrayList` 반환/필드 노출 | 인터페이스/불변 뷰 |
| 서비스 로케이터 | 숨은 전역 의존 | DI(생성자 주입) |
| 정적 유틸 과용 | 상태/불변식 사라짐 | 역할 인터페이스+구현 |
| 예외 없는 실패 신호 | `null/boolean`으로만 반환 | 도메인 예외/결과 타입 사용 |

---

## 16. 리팩토링 레시피

### 16.1 필드 공개 → 정보 은닉
1) `public` → `private`
2) 의미 있는 퍼블릭 **메시지** 도입(예: `applyDiscount`)

```java
// Before
public int price;
// After
private int price;
public void applyDiscount(Money amount){ /* 검증 + 상태 변경 */ }
```

### 16.2 구현 의존 → 인터페이스 의존(DIP)
```java
// Before
class OrderService { private final StripeGateway gw; }
// After
interface PaymentPort { void pay(Money m); }
class OrderService { private final PaymentPort port; }
```

### 16.3 컬렉션 노출 → 불변 뷰/복사
```java
public List<Item> items(){ return Collections.unmodifiableList(this.items); }
```

---

## 17. 종합 예제(결제 모듈)

```java
// 값 객체
public final class Money {
    private final java.math.BigDecimal amount;
    private final String currency;
    public static Money of(java.math.BigDecimal a, String c){ /*...*/ return new Money(a, c); }
    private Money(java.math.BigDecimal a, String c){ this.amount = a; this.currency = c; }
    public String currency(){ return currency; }
    public java.math.BigDecimal asBigDecimal(){ return amount; }
}

// 역할(Port)
public interface PaymentMethod {
    void pay(Money amount, String idempotencyKey);
}

// 구현(Adapter) — 내부 멱등/트랜잭션은 숨김
public final class KakaoPay implements PaymentMethod {
    private final java.util.Set<String> processed = java.util.concurrent.ConcurrentHashMap.newKeySet();
    @Override public void pay(Money amount, String key){
        if(amount.asBigDecimal().signum() <= 0) throw new IllegalArgumentException();
        if(!processed.add(key)) return;
        // PG 호출/DB 트랜잭션 등 내부 구현
    }
}

// 애플리케이션 서비스 — 구현 세부를 모르게 유지
public final class PaymentService {
    private final PaymentMethod method;
    public PaymentService(PaymentMethod method){ this.method = method; }
    public void process(Money amount, String key){ method.pay(amount, key); }
}
```

**특징**
- 외부는 `PaymentService.process`만 알면 된다.
- 멱등/락/트랜잭션/PG 세부는 모두 **은닉**.
- `PaymentMethod`로 **새 결제수단 확장**이 OCP 친화적.

---

## 18. 동시성까지 고려한 컬렉션 반환

```java
public final class Ledger {
    private final java.util.List<Entry> entries = new java.util.concurrent.CopyOnWriteArrayList<>();
    public java.util.List<Entry> snapshot(){ return java.util.List.copyOf(entries); } // 스냅샷
    public void append(Entry e){ entries.add(e); }
}
```

- 호출자는 **불변 스냅샷**을 받고, 내부는 안전하게 변경한다.

---

## 19. 성능과 방어적 복사의 균형

- 고빈도 경로에서 방어적 복사가 과도하면 비용 증가
- 대안: **불변 타입** 채택, 읽기 경로 캐시, 프로파일링 기반 선택

---

## 20. 체크리스트

- 공개 API에 **구현 세부(클래스/컬렉션 구체 타입)**가 새어 나가지 않는가?
- 외부에서 **상태를 직접 조작**할 수 없게 했는가?
- 모든 공개 메서드에 **전제/사후/불변식**이 명확한가?
- 인터페이스는 **작고 역할 중심**인가(ISP)?
- 상위 정책은 **추상에 의존**하고 구현은 **경계 밖**에 있는가(DIP/Ports)?
- 컬렉션/배열 반환 시 **불변 뷰/스냅샷**을 제공하는가?
- 멱등/동시성/트랜잭션은 **내부에서 은닉**되는가?
- 테스트가 **계약 기반**으로 구현 교체를 검증하는가?
- API 진화 시 **어댑터/디폴트 메서드/새 인터페이스**로 호환을 유지하는가?

---

## 21. 결론

- **정보 은닉**은 내부 구현·불변식을 숨겨 **변경에 강한 경계**를 만든다.
- **인터페이스**는 외부 협력을 위한 **행위 계약**을 제공한다.
- 두 원리를 함께 적용하면, **느슨한 결합·강한 응집**을 유지하며 **테스트 가능하고 확장 가능한** 시스템을 설계할 수 있다.
- 설계의 기본 질문은 항상 같다:
  1) 외부에 **무엇을 약속**할 것인가(인터페이스/계약)?
  2) 내부에서 **무엇을 숨길** 것인가(표현·알고리즘·불변식)?

실무에서는 작은 인터페이스, 명확한 계약, 철저한 은닉, 그리고 Port/Adapter를 기본값으로 삼아라. 그러면 외부 세계의 변화 속에서도 핵심 모델을 안전하게 지켜낼 수 있다.
