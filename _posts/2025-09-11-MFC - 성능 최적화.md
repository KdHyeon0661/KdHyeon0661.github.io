---
layout: post
title: MFC - 성능 최적화
date: 2025-09-11 16:25:23 +0900
category: MFC
---
# 성능 최적화 : 그리기 배치(Drawing Batching), I/O 병렬화, 지연 로딩(Lazy Loading), UI 응답성 유지 (MFC/Win32 실전 총정리)

이 글은 **MFC/Win32** 기반 데스크톱 앱에서 **프레임 타임을 줄이고**, **I/O를 병렬화**하며, **지연 로딩과 캐싱**으로 **초기 로딩 시간을 단축**하고, 무엇보다 **UI 응답성(Responsive UI)**을 유지하는 방법을 **코드 예제와 체크리스트**로 정리합니다.  
핵심 원칙은 네 가지입니다.

1) **그리기는 적게, 한 번에, 더블 버퍼로.**  
2) **I/O는 비동기/병렬 + 파이프라인화.**  
3) **필요할 때만, 필요한 만큼 로드(지연/온디맨드) + 캐시.**  
4) **UI 스레드는 절대 막지 말고(Non-blocking), 항상 즉시 응답.**

---

## 0) 준비 운동: 성능 측정 프리셋

성능은 **측정 → 가설 → 개선 → 재측정** 루프로 굴립니다. 최소한 다음을 준비하세요.

```cpp
// 0-1) QPC 스톱워치 & 스코프 타이머
struct ScopeMs {
    LARGE_INTEGER f,s; const wchar_t* tag;
    ScopeMs(const wchar_t* t):tag(t){ QueryPerformanceFrequency(&f); QueryPerformanceCounter(&s); }
    ~ScopeMs(){ LARGE_INTEGER e; QueryPerformanceCounter(&e);
        double ms = (e.QuadPart - s.QuadPart) * 1000.0 / f.QuadPart;
        WCHAR buf[256]; _snwprintf_s(buf,_TRUNCATE,L"[perf] %s=%.3fms\n", tag, ms);
        OutputDebugStringW(buf);
    }
};
#define SCOPE(tag) ScopeMs _scope_##__LINE__(L##tag);

// 0-2) UI 스레드 장기 작업 감지(Watchdog)
static UINT_PTR g_watchdog = 0;
static DWORD    g_lastPumpTick = 0;

void StartUiWatchdog(CWnd* pWnd) {
    g_lastPumpTick = GetTickCount();
    g_watchdog = pWnd->SetTimer(9999, 500, nullptr);
}
void StopUiWatchdog(CWnd* pWnd) {
    if (g_watchdog) pWnd->KillTimer(9999), g_watchdog = 0;
}
// Main message pump 어딘가에서 g_lastPumpTick 갱신 (PreTranslateMessage 등)
```

> 분석 도구: **WPA(Windows Performance Analyzer)**, **ETW TraceLogging**, **VS Performance Profiler**.  
> 최소: **QPC 로깅 + 프레임 타임 히스토리**를 갖추면 병목이 보입니다.

---

## 1) 그리기 배치(Drawing Batching)

### 1-1. “덜 그리고, 한 번에”의 5원칙

1. **Invalidate 최소화**: 바뀐 영역만 무효화(`InvalidateRect(partial, FALSE)`)  
2. **중복 무효화 병합**: `UnionRect`로 영역 합쳐 한 번의 `RedrawWindow`  
3. **더블 버퍼링**: 오프스크린 DC에 모두 그린 뒤 `BitBlt`  
4. **GDI 상태 변경 최소화**: 같은 펜/브러시/폰트 묶어서 배치 그리기  
5. **레이아웃/측정 캐시**: 텍스트 줄바꿈, 아이콘 배치 결과를 캐시하고 다시 쓰기

### 1-2. 더블 버퍼 기본 패턴

```cpp
void CMyView::OnPaint() {
    CPaintDC dcPaint(this);
    CRect rc; GetClientRect(&rc);

    // 1) 메모리 DC + 호환 비트맵
    CDC dc; dc.CreateCompatibleDC(&dcPaint);
    CBitmap bmp; bmp.CreateCompatibleBitmap(&dcPaint, rc.Width(), rc.Height());
    CBitmap* oldBmp = dc.SelectObject(&bmp);

    // 2) 배경 + 콘텐츠
    dc.FillSolidRect(&rc, RGB(250,250,250));
    DrawScene(&dc, rc); // 비싼 그리기 전부 여기서

    // 3) 스크린으로 복사
    dcPaint.BitBlt(0, 0, rc.Width(), rc.Height(), &dc, 0, 0, SRCCOPY);

    // 4) 정리
    dc.SelectObject(oldBmp);
}
```

> 깜빡임 방지의 핵심. **WM_ERASEBKGND 반환 TRUE**(또는 무시)로 배경 지우기 중복 제거.

```cpp
BOOL CMyView::OnEraseBkgnd(CDC* pDC) { return TRUE; } // 더블 버퍼에서 직접 배경 칠함
```

### 1-3. 부분 무효화와 병합

```cpp
// 변경된 셀만 갱신
void CGrid::UpdateCell(int row, int col) {
    CRect r = CellRect(row,col);
    InvalidateRect(&r, FALSE);
}

// 여러 셀 변경 시 영역 병합
CRgn dirty; dirty.CreateRectRgn(0,0,0,0);
for (auto& c : changedCells) {
    CRect r = CellRect(c.r, c.c);
    CRgn cell; cell.CreateRectRgnIndirect(&r);
    dirty.CombineRgn(&dirty, &cell, RGN_OR);
}
RedrawWindow(nullptr, &dirty, RDW_INVALIDATE|RDW_UPDATENOW);
```

### 1-4. GDI 상태 변경 최소화(배치)

```cpp
// 나쁜 예: 펜/브러시를 항목마다 바꾸고 SelectObject 반복
for (auto& it : items) {
    CPen pen(PS_SOLID,1,it.color); CPen* oldPen = dc.SelectObject(&pen);
    dc.MoveTo(it.x1, it.y1); dc.LineTo(it.x2, it.y2);
    dc.SelectObject(oldPen);
}

// 좋은 예: color별로 그룹핑해서 한 번만 Select
std::map<COLORREF, std::vector<Item*>> groups;
for (auto& it : items) groups[it.color].push_back(&it);

for (auto& [color, vec] : groups) {
    CPen pen(PS_SOLID, 1, color);
    CPen* old = dc.SelectObject(&pen);
    for (auto* p : vec) { dc.MoveTo(p->x1, p->y1); dc.LineTo(p->x2, p->y2); }
    dc.SelectObject(old);
}
```

### 1-5. 텍스트 레이아웃 캐시

```cpp
struct TextLayout { CSize extent; std::vector<CString> lines; };
std::unordered_map<CString, TextLayout> g_textCache;

const TextLayout& LayoutText(CDC& dc, const CString& s, int width) {
    auto it = g_textCache.find(s);
    if (it != g_textCache.end()) return it->second;

    TextLayout L;
    // 단순 줄바꿈(실전은 DrawText/DT_CALCRECT 또는 Uniscribe/DirectWrite 권장)
    // ...
    g_textCache.emplace(s, L);
    return g_textCache.find(s)->second;
}
```

> **팁**: List/Tree 등 대량 아이템 그리기는 **Owner-Draw + 가상화 + 텍스트/아이콘 캐시** 조합이 필수.

---

## 2) I/O 병렬화(파일/네트워크)와 파이프라인

### 2-1. 원칙

- **UI 스레드는 절대 I/O 호출 금지** (`ReadFile/WriteFile/Send/Recv` 등)  
- **비동기(Overlapped) + 이벤트/IOCP** 또는 **스레드풀** 사용  
- **파이프라인**: (디스크 읽기) → (디코드/파싱) → (압축해제/변환) → (UI 반영) **단계별 병렬**

### 2-2. 파일 비동기(Overlapped I/O + 스레드 풀) — 간단형

```cpp
struct AsyncRead {
    HANDLE h = INVALID_HANDLE_VALUE;
    OVERLAPPED ov{};
    std::unique_ptr<BYTE[]> buf;
    DWORD toRead, got=0;
};

void BeginAsyncRead(const std::wstring& path, DWORD size, std::function<void(BYTE*,DWORD)> onDone) {
    auto ar = std::make_shared<AsyncRead>();
    ar->h = CreateFileW(path.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING,
                        FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN, nullptr);
    if (ar->h == INVALID_HANDLE_VALUE) { /* 에러 처리 */ return; }
    ar->buf.reset(new BYTE[size]);
    ar->toRead = size;
    auto cb = [](DWORD err, DWORD xfer, LPOVERLAPPED pov) {
        auto ar = CONTAINING_RECORD(pov, AsyncRead, ov);
        ar->got = xfer;
        // UI 반영은 PostMessage로 스레드 마샬링
        PostMessageW(g_hwndMain, WM_APP+1, (WPARAM)ar, 0);
    };
    // Vista+: ReadFileEx or BindIoCompletionCallback(고급).
    if (!ReadFile(ar->h, ar->buf.get(), size, nullptr, &ar->ov)) {
        if (GetLastError()!=ERROR_IO_PENDING) { /* 실패 경로 */ }
    }
    // IOCP/스레드풀 사용 시: BindIoCompletionCallback(ar->h, Callback, 0)
}
```

UI 스레드에서 결과 처리:

```cpp
// 메시지 맵: ON_MESSAGE(WM_APP+1, &CMainDlg::OnAsyncReadDone)
LRESULT CMainDlg::OnAsyncReadDone(WPARAM w, LPARAM) {
    auto ar = (AsyncRead*)w;
    // 디코딩/파싱은 또 다른 워커로! → UI는 복사/표시만
    QueueUserWorkItem([](PVOID p)->DWORD{
        auto ar = (AsyncRead*)p;
        // decode(ar->buf.get(), ar->got) ...
        PostMessageW(g_hwndMain, WM_APP+2, (WPARAM)ar, 0);
        return 0;
    }, ar, 0);
    return 0;
}
```

### 2-3. IOCP(고성능 서버/다중 파일) 개념 요약

- **CreateIoCompletionPort**로 여러 파일/소켓을 하나의 **완료 큐**에 연결  
- **GetQueuedCompletionStatus**로 완료 이벤트를 **스레드풀 워커**가 소비  
- 장점: **수천 동시 I/O도 적은 스레드로 처리**(커널 레벨 최적화)

> 데스크톱 앱에서 적극 사용 예: 대량 이미지 스캔/인덱싱, 네트워크 동기화 클라이언트.

### 2-4. 네트워크 비동기 패턴(WinSock Overlapped)

```cpp
// 소켓을 WSA_FLAG_OVERLAPPED로 열고 WSARecv/WSASend 사용.
// 완료 통지는 IOCP 또는 WSAWaitForMultipleEvents로 받는 구조.
// UI 스레드로는 PostMessage로 결과만 마샬링.
```

### 2-5. 파이프라인 구성(가장 중요)

예) 이미지 갤러리 로딩

1. **파일 enumerator**(디스크) — 워커 1개  
2. **이미지 로더**(Decode/Thumbnail) — 워커 N개  
3. **UI Producer** — `PostMessage(WM_THUMB_READY, ...)`  

```cpp
// lock-free-ish 큐 or MPSC 큐를 사용해 단계 연결
template<typename T>
class MpscQueue {
    std::mutex mx; std::queue<T> q;
public:
    void push(T v){ std::lock_guard<std::mutex> lk(mx); q.push(std::move(v)); }
    bool pop(T& out){ std::lock_guard<std::mutex> lk(mx); if(q.empty()) return false; out=std::move(q.front()); q.pop(); return true; }
};
```

> 병렬 단계별로 **CPU 코어 사용 최적화**: I/O가 느릴 땐 디코더 워커를 2~4개로, CPU가 포화면 1~2개로 줄이는 **동적 튜닝**을 넣어도 좋습니다.

---

## 3) 지연 로딩(Lazy Loading) & 캐싱 전략

### 3-1. 앱 시작 시간 단축: “필수만, 나머지는 뒤로”

- **핵심 화면 표시**를 200~500ms 내 완료  
- 플러그인/대형 데이터/리소스는 **표시 후 백그라운드 로드**  
- **스플래시** 대신 **Skeleton UI**(프레임 + 주요 컨트롤) 먼저 띄우고 채워 넣기

```cpp
BOOL CMainFrame::OnCreateClient(...) {
    CreateSkeleton();             // 레이아웃만 잡고
    PostMessage(WM_APP+100);      // 이후 비동기 초기화
    return TRUE;
}
LRESULT CMainFrame::OnAsyncInit(WPARAM, LPARAM) {
    // 1) 설정/프로필 로드
    // 2) 최근 파일 인덱스 빌드
    // 3) (필요 시) 리소스 Warm-up
    return 0;
}
```

### 3-2. 온디맨드 로드: “보이면 로드, 안 보이면 폐기”

- **Virtualization**: 리스트/그리드/이미지 타일에서 **보이는 영역만 데이터 공급**  
- **LRU 캐시**: 최근 사용 리소스(썸네일/아이콘/텍스트 레이아웃)를 캐시, 용량 초과 시 제거

```cpp
template<class Key, class Val>
class LruCache {
    size_t cap;
    std::list<std::pair<Key,Val>> l;
    std::unordered_map<Key, decltype(l.begin())> m;
public:
    LruCache(size_t c):cap(c){}
    bool get(const Key& k, Val& out) {
        auto it=m.find(k); if(it==m.end()) return false;
        l.splice(l.begin(), l, it->second); // MRU로
        out=it->second->second; return true;
    }
    void put(Key k, Val v) {
        auto it=m.find(k);
        if(it!=m.end()){ it->second->second=std::move(v); l.splice(l.begin(), l, it->second); return; }
        l.emplace_front(std::move(k), std::move(v));
        m[l.front().first]=l.begin();
        if(m.size()>cap){ m.erase(l.back().first); l.pop_back(); }
    }
};
```

### 3-3. 프리페치(예측 로딩)

- 사용자가 스크롤 방향으로 **다음 타일**을 미리 로드  
- 네트워크 자원은 **대역폭 기반**(느릴수록 앞당겨) 프리페치

```cpp
void PrefetchTiles(int firstVisible, int countVisible) {
    int prefetchStart = firstVisible + countVisible;
    for (int i=prefetchStart; i<prefetchStart+8; ++i) QueueTileDecode(i);
}
```

### 3-4. 지연-컴파일/지연-초기화

- GDI+ 초기화, Direct2D 팩토리, 폰트 측정용 DC 같은 무거운 초기화는 **처음 필요할 때 한 번만**  
- 정적 싱글톤 대신 **call_once** 사용

```cpp
std::once_flag g_d2dOnce;
void EnsureD2D() {
    std::call_once(g_d2dOnce, [](){ /* D2D1CreateFactory, WIC init ... */ });
}
```

---

## 4) UI 응답성 유지(Non-blocking UX)

### 4-1. 규칙

- UI 스레드에서 **파일/네트워크/DB/압축/암호화/이미지 디코딩 금지**  
- 무거운 연산은 **워커**로 보내고, UI에는 **PostMessage**로 상태/결과만 반영  
- **캔슬/타임아웃**/진행률을 항상 제공

### 4-2. 메시지 기반 비동기(패턴)

```cpp
// 워커
struct Job { std::function<void()> fn; };
concurrency::concurrent_queue<Job> g_jobs; // 혹은 std::queue+mutex

void WorkerLoop() {
    for (;;) {
        Job j;
        if (g_jobs.try_pop(j)) {
            j.fn();
        } else {
            Sleep(1);
        }
    }
}

// 제출
void RunAsync(std::function<void()> fn) {
    g_jobs.push(Job{ std::move(fn) });
}
```

UI 반영:

```cpp
RunAsync([=]{
    // heavy
    auto data = LoadAndDecode(path);
    PostMessageW(m_hWnd, WM_APP+42, (WPARAM)new Data(std::move(data)), 0);
});

LRESULT CMainDlg::OnDataReady(WPARAM w, LPARAM) {
    std::unique_ptr<Data> p((Data*)w);
    // UI 갱신 (컨트롤/리스트 업데이트)
    return 0;
}
```

### 4-3. 디바운스/스로틀 (과도한 UI 업데이트 방지)

```cpp
class DebounceTimer {
    UINT_PTR id=0; CWnd* p=0; UINT ms; UINT msg;
public:
    DebounceTimer(CWnd* w, UINT message, UINT delayMs):p(w),ms(delayMs),msg(message){}
    void ping() {
        if (id) p->KillTimer(id);
        id = p->SetTimer(msg, ms, nullptr); // msg를 timer id로 재사용
    }
};

DebounceTimer g_db(&dlg, 1234, 150);
void OnTextChange() { g_db.ping(); } // 150ms 동안 추가 이벤트 없으면 갱신 1회
```

### 4-4. 진행률/취소/세이프 셧다운

- **취소 토큰**: 이벤트/원자 플래그 → 워커 루프에서 주기 체크  
- **세이프 셧다운**: 종료 시 취소 → 워커 조인(타임아웃) → 미저장 경고

```cpp
std::atomic_bool g_cancel{false};
void CancelAll(){ g_cancel.store(true, std::memory_order_relaxed); }

void HeavyWork() {
    for (int i=0;i<steps;i++) {
        if (g_cancel.load(std::memory_order_relaxed)) break;
        // step…
        PostMessageW(hwnd, WM_APP_PROGRESS, i, steps);
    }
    PostMessageW(hwnd, WM_APP_DONE, 0, 0);
}
```

---

## 5) 대용량 리스트/캔버스: 가상화 + 타일링 + 점진 렌더

### 5-1. 가상 리스트(OwnerData) & 지연 페인트

```cpp
// LVS_OWNERDATA + LVN_GETDISPINFO: 가시 행만 텍스트 공급
void CMainDlg::OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult) {
    auto* di = (NMLVDISPINFO*)pNMHDR;
    if (di->item.mask & LVIF_TEXT) {
        auto row = di->item.iItem;
        auto col = di->item.iSubItem;
        _tcscpy_s(di->item.pszText, di->item.cchTextMax, Lookup(row,col));
    }
    *pResult = 0;
}
```

### 5-2. 큰 이미지/지도: 타일 캐시 + LOD(Level of Detail)

- 화면 해상도에 맞춰 **적정 LOD 타일**만 로드  
- 256×256 타일 기준, 스크롤/줌에 맞게 3×3 또는 5×5 타일 윈도우 유지  
- 타일 디코딩은 워커, UI는 **디코딩 완료 타일만 그리기**

```cpp
struct TileKey { int level; int tx; int ty; bool operator==(const TileKey&)const=default; };
struct Tile { HBITMAP bmp; bool ready; /* ... */ };

LruCache<TileKey, Tile> g_tileCache(256);
void PaintTiles(CDC& dc, const CRect& view) {
    auto keys = VisibleTileKeys(view, currentZoom);
    for (auto& k : keys) {
        Tile t; if (g_tileCache.get(k, t) && t.ready) {
            // t.bmp BitBlt
        } else {
            QueueDecodeTile(k);
        }
    }
}
```

---

## 6) 그리기 스레드/렌더링 파이프라인(고급)

GUI 스레드가 아닌 **전용 렌더링 스레드**를 둘 수도 있습니다(Direct2D/Direct3D 권장).  
GDI는 멀티스레드 그리기에 제약이 있지만, **메모리 DC 렌더** 후 **UI 스레드 BitBlt** 전달 패턴은 가능합니다.

```cpp
// RenderThread: 메모리 DC에 Scene 그리기 → 공유 비트맵 교체 → UI에 Invalidate
// UI Thread: WM_PAINT에서 최신 공유 비트맵을 BitBlt만 수행
```

> **주의**: GDI 객체 공유 시 동기화 필수, HBITMAP 교체는 원자적 포인터 스왑 + 수명 관리(RefCount/unique_ptr + 메시지 기반).

---

## 7) I/O + 렌더 파이프라인 종합 예제 (썸네일 뷰어)

**목표**: 폴더 내 이미지 5천 장을 지연 로딩/타일 배치로 **스크롤 부드럽게**.

1. **스캔 스테이지**: Worker가 파일 목록 수집 → UI에 건 네이밍 정보만 빠르게 표시  
2. **디코드 스테이지**: 4개 워커가 썸네일 디코딩(WIC/GDI+) → 타일 LRU 캐시 업데이트  
3. **렌더 스테이지**: UI는 **가시 영역 타일만 BitBlt**, 없는 타일은 placeholder  
4. **프리페치**: 스크롤 방향으로 前 2~3줄 타일 디코드 예약  
5. **입력 응답**: WM_MOUSEWHEEL/스크롤은 **즉시 반응**(계산만), 렌더는 이후 프레임에 따라옴

핵심 코드 조각:

```cpp
void CThumbView::OnVScroll(UINT code, UINT pos, CScrollBar* bar) {
    SCOPE("OnVScroll");
    // 1) 논리 오프셋 업데이트
    UpdateScrollOffset(code, pos);
    // 2) 렌더 예약(디바운스)
    m_debounceInvalidate.ping();
    // 3) 프리페치
    PrefetchRows(FirstVisibleRow(), VisibleRowCount()+3);
}

void CThumbView::OnTimer(UINT_PTR id) {
    if (id == TIMER_INVALIDATE) {
        Invalidate(FALSE); // 병합 그리기
    }
}
```

---

## 8) 데이터 구조와 알고리즘 관점 최적화

- **정렬된 데이터**는 **이진 탐색**으로 찾기(O(logN))  
- **공간/시간 트레이드오프**: 자주 조회하는 것은 **인덱스/해시** 생성  
- **열 기반 저장**(많은 행, 적은 열)에서는 **SoA 구조**로 캐시 효율 향상  
- **메모리 할당 감소**: `reserve`, 풀 할당자, `std::pmr` 사용

```cpp
std::vector<Item> v; v.reserve(50000); // 재할당 최소화
```

---

## 9) 스레드/동기화 & 락 경합 줄이기

- **UI ↔ 워커** 간 데이터 전달은 **메시지(PostMessage)** 또는 **MPSC 큐**  
- **shared_ptr** 보다는 **수명 명확한 이동(유니크 소유권)**을 선호  
- 락 범위를 줄이고 **Copy-on-write** 또는 **스냅샷 읽기**(읽기 락 없음) 도입

```cpp
// 스냅샷 읽기 예: UI는 const snapshot만 접근, 워커는 새로운 snapshot 교체
std::shared_ptr<Model> g_model;
void UpdateModel(std::shared_ptr<Model> next) {
    std::atomic_store(&g_model, next);
    PostMessage(hwnd, WM_APP_MODEL_UPDATED, 0, 0);
}
```

---

## 10) UI 프리징 흔한 원인과 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| 스크롤 중 끊김 | WM_PAINT에서 디코딩/DB조회 | **그리기 전용**으로 유지, 디코딩은 워커 |
| 창 이동/리사이즈 시 느림 | OnSize에서 즉시 무거운 레이아웃 | 디바운스, 레이아웃 캐시, Lazy-Measure |
| 메뉴 클릭 딜레이 | 메인 스레드에서 네트워크 호출 | 비동기 요청, 응답 도착 시 UI 반영 |
| 입력 지연 | 메시지 폭주(EN_CHANGE 남발) | 디바운스/스로틀, 최소 처리 |
| 대화상자 열림 느림 | 리소스/아이콘/폰트 즉시 로딩 | 필요 시 로딩, Warming 백그라운드 |

---

## 11) Direct2D/DirectWrite로의 점진적 전환(선택)

GDI가 병목이라면 **D2D/DirectWrite**로 전환 시:

- **장점**: 하드웨어 가속, 안티앨리어싱, 투명/레イヤ, 고품질 텍스트  
- **패턴**: D2D `ID2D1HwndRenderTarget` / `IDWriteTextLayout` 캐싱  
- **여전히 지켜야 할 것**: **그리기 배치/더블 버퍼/부분 무효화/가상화**

---

## 12) 최적화 체크리스트(요약)

- **그리기**  
  - [ ] 더블 버퍼, OnEraseBkgnd 차단  
  - [ ] 부분 무효화 & 병합  
  - [ ] GDI 상태 변경 최소화(그룹핑)  
  - [ ] 텍스트/아이콘 레이아웃 캐시  
  - [ ] 대량 컨트롤은 Owner-Draw + 가상화

- **I/O**  
  - [ ] UI 스레드에서 I/O 금지  
  - [ ] Overlapped/스레드풀/IOCP  
  - [ ] 파이프라인 단계화 + 프리페치

- **지연 로딩/캐시**  
  - [ ] Skeleton UI 먼저  
  - [ ] 온디맨드 + LRU 캐시  
  - [ ] call_once/지연 초기화

- **UI 응답성**  
  - [ ] PostMessage 마샬링  
  - [ ] 디바운스/스로틀  
  - [ ] 진행률/취소/세이프 셧다운

- **분석**  
  - [ ] QPC 스코프 타이머  
  - [ ] 프레임 타임 히스토리  
  - [ ] ETW/WPA로 병목 검증

---

## 13) 종합 샘플: “빠른 검색 + 미리보기” 앱 스캐폴딩

**시나리오**: 디스크 전체에서 키워드 검색 → 결과 리스트(가상) → 선택 시 미리보기(이미지/텍스트)

- **UI 스레드**: 키입력, 스크롤, 선택 처리.  
- **검색 파이프라인**: (디렉터리 열람 → 필터 → 인덱스/문자열 매칭) 비동기.  
- **미리보기 파이프라인**: (파일 I/O → 디코드) 비동기, LRU 캐시.  
- **그리기**: 가시 행만 텍스트 제공, 더블 버퍼.

코드 요지:

```cpp
// 검색 제출
void CSearchDlg::OnEditChanged() {
    g_debounceSearch.ping(); // 150ms 후 실행
}
void CSearchDlg::OnSearchDebounced() {
    auto key = GetSearchText();
    RunAsync([key]{
        auto results = SearchIndex(key); // 병렬
        // Top-K만 우선, 나머지는 백그라운드
        PostMessage(hwnd, WM_APP_SEARCH_RESULT, (WPARAM)new Results(std::move(results)), 0);
    });
}

LRESULT CSearchDlg::OnSearchResult(WPARAM w, LPARAM) {
    std::unique_ptr<Results> r((Results*)w);
    m_list.SetItemCountEx((int)r->size(), LVSICF_NOINVALIDATEALL|LVSICF_NOSCROLL);
    m_model.swap(*r);
    Invalidate(FALSE);
    return 0;
}
```

---

## 14) 마무리

성능 최적화는 **사용자 체감**이 전부입니다.  
- **그리기는 덜, 한 번에(배치) + 더블 버퍼 + 부분 무효화**  
- **I/O는 병렬/비동기 + 파이프라인 + 프리페치**  
- **지연 로딩 + 캐시**로 **초기 표시**를 빠르게  
- **UI 스레드는 항상 즉시 응답**, 무거운 일은 워커로