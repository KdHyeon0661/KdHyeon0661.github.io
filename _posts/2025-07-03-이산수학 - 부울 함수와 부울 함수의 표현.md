---
layout: post
title: 이산수학 - 부울 함수와 부울 함수의 표현
date: 2025-07-03 20:20:23 +0900
category: 이산수학
---
# 부울 함수와 부울 함수의 표현 (Boolean Functions & Representations)

## 한눈 개요

- **부울 함수**: $$f:\{0,1\}^n\to\{0,1\}$$
- **표현법**: 진리표, 논리식(AND/OR/NOT, XOR…), **SOP/PDNF, POS/PCNF**, **Shannon 분해**, **ANF(Algebraic Normal Form, Zhegalkin 다항)**, **BDD/ROBDD**, **CNF(절)·DNF(절)**, 회로도(게이트).
- **간소화/최적화**: 부울 대수, 드모르간, 흡수/분배, **K-맵**, **Quine–McCluskey**(정확), **Espresso**(휴리스틱), 위험(해저드) 제거.
- **복잡도/이론**: 가능한 함수 개수 $$2^{2^n}$$, **완전성(Post)**, **SAT**/등가성, **특수 클래스**(대칭/단조/선형/임계/자기쌍대/유니에이트).
- **실무 연결**: 합성(게이트/표준 셀), 타이밍/전력, don’t-care, hazard-free 설계.

---

## 정의와 기초

### 정의

$$
f:\{0,1\}^n\to\{0,1\},\quad \mathbf{x}=(x_1,\dots,x_n),\quad f(\mathbf{x})\in\{0,1\}.
$$

**예시**
- 항등: $$f(x)=x$$
- AND: $$f(x,y)=x\land y$$
- 복합: $$f(x,y,z)=(x\lor y)\land \lnot z$$

### 연산/기호

- AND: $$x\land y\equiv xy$$
- OR:  $$x\lor y\equiv x+y$$
- NOT: $$\lnot x\equiv \bar x\equiv x'$$
- XOR: $$x\oplus y\equiv x\bar y+\bar x y$$
- XNOR: $$x\odot y\equiv xy+\bar x\bar y$$

**우선순위**: $$\lnot > \land > \lor$$ (필요시 괄호)

---

## 부울 함수의 표현

### 진리표 (Truth Table)

- 모든 입력 조합에 대한 출력 나열 → **완전한 명세**

**예**: $$f(x,y)=x\land y$$

| x | y | f |
|---|---|---|
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

### 논리식 (Boolean Expression)

- 연산자(AND/OR/NOT/XOR…) 조합으로 표현.
- 동일 함수에 대해 **여러 동치식** 존재(간소화 필요).

### 회로(게이트) 표현

- 논리식을 AND/OR/NOT 등 **게이트 수준**으로 구현.

```
 x ----\
        AND ---- f
 y ----/
```

$$f(x,y,z)=(x\land y)\land \lnot z$$는 NOT·AND 조합으로 구현.

---

## 정규형(Canonical Forms)

### PDNF / SOP (Principal Disjunctive Normal Form)

- **출력=1**인 행(미터밍·minterm)의 OR.
- $$n$$변수에서 미터밍은 **모든 변수의 긍/부 보수 곱**(길이 n AND 항).

**예**
진리표에서 1인 행이 2개일 때:
$$
f(x,y)=(\bar x y)\;+\;(x y).
$$

### PCNF / POS (Principal Conjunctive Normal Form)

- **출력=0**인 행(맥스텀·maxterm)의 AND.
- 각 맥스텀은 **변수들의 OR 항**.

**예**
$$
f(x,y)=(x\lor y)\;\land\;(\bar x\lor y).
$$

> **정리**: 모든 부울 함수는 PDNF(POS) 형태로 표현 가능.
> **실무**: PDNF/POS는 **길이 과다** → K-맵/Quine–McCluskey/합성 도구로 **최소화** 필요.

---

## Shannon 분해(Decomposition) & 공변수(Cofactor)

### Shannon 분해

임의의 변수 $$x_i$$에 대해:
$$
f = x_i\cdot f|_{x_i=1} + \bar x_i\cdot f|_{x_i=0}.
$$
- 재귀적으로 분해 → **트라이/의사결정트리** → **BDD** 기초.

### 공변수

$$
f_{x}=f|_{x=1},\quad f_{\bar x}=f|_{x=0}.
$$
- 단일 변수 제거 후의 **잔여 함수**.
- **공변수 동치**: $$f_x=f_{\bar x}$$이면 $$f$$는 $$x$$에 **무관**.

---

## ANF(Algebraic Normal Form) / Zhegalkin 다항

- **GF(2)**(모듈로 2)에서의 다항 표현:
$$
f(x_1,\dots,x_n)=a_0\oplus \bigoplus_i a_i x_i \oplus \bigoplus_{i<j} a_{ij}x_ix_j \oplus \cdots \oplus a_{12\cdots n}x_1x_2\dots x_n,
$$
여기서 계수 $$a_{\cdot}\in\{0,1\}$$, 덧셈은 XOR.

**특징**
- **선형/아핀 함수**는 고차 항이 없음(또는 상수항 추가).
- **Walsh–Hadamard** 변환으로 스펙트럼 분석 가능(심화).

---

## BDD/ROBDD (Binary Decision Diagram)

- 변수 순서에 따라 노드를 결정(0/1-간선)하는 **유한 DAG**.
- 같은 부분함수(동형 서브그래프) 공유 → **ROBDD**는 **정규화**로 유일(주어진 변수 순서에 대해).

**장점**
- 등가성 검사(동일 함수인지) 즉시, 조작(합·곱·보수) 효율적.

**주의**: 변수 순서에 따라 크기 급변(최적 순서 찾기는 어려움).

---

## CNF/DNF와 SAT/Tseitin

- **CNF**: 절(리터럴 OR)의 AND. **SAT 문제 표준 입력**.
- **DNF**: 항(리터럴 AND)의 OR.

**Tseitin 변환**: 임의 회로 → **선형 크기**로 CNF 인코딩(보조변수 사용).
**활용**: 등가성 증명, 제약 만족, 검증(Formal).

---

## 간소화 기법

### 부울 대수(핵심 법칙)

- 항등: $$A+0=A,\; A\cdot 1=A$$
- 지배: $$A+1=1,\; A\cdot 0=0$$
- 보수: $$A+\bar A=1,\; A\cdot \bar A=0$$
- 멱등: $$A+A=A,\; AA=A$$
- 흡수: $$A+AB=A,\; A(A+B)=A$$
- 드모르간: $$\overline{A+B}=\bar A \bar B,\; \overline{AB}=\bar A+\bar B$$
- 분배: $$A(B+C)=AB+AC,\; A+BC=(A+B)(A+C)$$

### K-맵(Karnaugh Map) — 2~4(6)변수 시각 간소화

- 1(또는 0)을 **인접(그레이 코드)**로 **1,2,4,8**개 그룹핑 → 항 줄이기.
- **Don’t-care**는 유리하게 포함.

**예**: 4변수 $$f(A,B,C,D)=\Sigma m(1,3,7,11,15),\; d(5,9,13)$$
→ K-맵 그룹핑으로 최소 SOP 도출(자세한 표 생략).

### Quine–McCluskey(정확 최소화)

- 미니텀 이진코드의 **해밍 거리 1** 묶음 → **소환원(prime implicant)** 산출 → **피복 테이블**로 최소 커버 선택.
- **복잡도↑**(NP-난해)지만 4~8변수 정도까지는 가능.

### Espresso(휴리스틱)

- 산업 표준 휴리스틱 최소화기(정확 보장 X, 실무형).

---

## 해저드(Hazard)와 안전 회로

- **정적-1 해저드**: 입력 변화 중 출력이 잠깐 0(글리치)로 떨어짐(1→1이어야 함).
- 원인: 경로 지연 불균형.
- **해결**: K-맵에서 **겹치는 커버 추가**(冗長 항)로 덮기, 리타이밍/버퍼링.

---

## 함수 개수와 특수 클래스

### 개수

- $$n$$변수 입력 조합: $$2^n$$
- 각 조합의 출력은 2가지 → 총 함수 수:
$$
\boxed{2^{2^n}}
$$
- 예: $$n=1\Rightarrow 4,\; n=2\Rightarrow 16,\; n=3\Rightarrow 256$$

### 특수한 부울 함수군

- **대칭(Symmetric)**: 출력은 입력의 1의 개수(해밍 가중치)에만 의존(다수결, 정확-$$k$$ 등).
- **단조(Monotone)**: 입력 증가(0→1) 시 출력이 감소하지 않음(OR/AND/임계 함수).
- **선형/아핀(Linear/Affine)**: ANF에 고차항 없음(또는 상수항만 추가).
- **임계(Threshold)**: $$\sum w_i x_i \ge \theta \Rightarrow 1$$(퍼셉트론).
- **자기쌍대(Self-dual)**: $$f(\bar{\mathbf{x}})=\overline{f(\mathbf{x})}$$
- **유니에이트(Unate)**: 각 변수에 대해 “항상 보수 없이” 또는 “항상 보수로만” 등장(혼용 없음).

---

## 완전성(Functional Completeness) & Post 조건

- **NAND**, **NOR** 각각으로 **모든 부울 함수** 합성 가능(셰퍼·피어스).
- **Post의 기준**(요지): 어떤 연산자 집합이 ①상수 보존, ②1보존, ③단조, ④선형, ⑤자기쌍대 중 **어느 닫힌 클래스에도 속하지 않음**을 보이면 **완전**.

**실무**: 셀 라이브러리는 NAND/NOR/INV 중심. XOR/XNOR/MUX 등은 고급 셀로 제공.

---

## 실전 예제: 표현 ↔ 간소화 ↔ 회로

### 예제 1 — SOP/POS/ANF/BDD 스케치

주어진:
$$
f(a,b,c)=(a\lor b)\land \lnot c.
$$

- **진리표** 구성 → 1인 행 미니텀 모으기
- **SOP**: $$f=\bar c(a+b)=a\bar c + b\bar c$$
- **POS**: $$f=(\bar c)\land (a+b)$$ (이미 간단)
- **ANF**:
  $$a\bar c + b\bar c = a(1\oplus c)\oplus b(1\oplus c) = a\oplus ac\oplus b\oplus bc.$$
  (GF(2) 관점 변환 예시)
- **Shannon 분해 (w.r.t. $$c$$)**:
  $$
  f = c\cdot 0 + \bar c\cdot(a+b).
  $$

### 예제 2 — K-맵 간소화

$$
f(A,B,C,D)=\Sigma m(1,3,7,11,15),\; d(5,9,13).
$$
- 1과 d를 이용해 8/4/2 그룹으로 커버 최대화 → 최소 SOP 도출.
- **해저드 프리** 요구 시 중첩 커버 추가.

### 예제 3 — Quine–McCluskey 개요

- 미니텀 8개(3변수)라 가정: 0/1 개수로 그룹핑 → 결합 → 소환원 → 필수 소환원 선택 → 잔여 커버 최소화(피복 테이블).

---

## Python 실습 코드

### 진리표 생성 & SOP/POS 자동 생성(소규모)

```python
from itertools import product

def truth_table(expr, vars_):
    """
    expr: lambda **env: 0/1 을 반환하는 람다 (예: lambda a,b,c: (a or b) and (not c))
    vars_: 변수명 리스트 (예: ['a','b','c'])
    """
    rows = []
    for bits in product([0,1], repeat=len(vars_)):
        env = {v:bool(b) for v,b in zip(vars_, bits)}
        y = int(bool(expr(**env)))
        rows.append((*bits, y))
    return rows

def sop_from_tt(tt, vars_):
    """PDNF 생성: 출력이 1인 행을 미니텀으로 OR."""
    terms = []
    for row in tt:
        *xs, y = row
        if y==1:
            lits = []
            for v,b in zip(vars_, xs):
                lits.append(v if b==1 else f"~{v}")
            terms.append("(" + " & ".join(lits) + ")")
    return " | ".join(terms) if terms else "0"

def pos_from_tt(tt, vars_):
    """PCNF 생성: 출력이 0인 행을 맥스텀으로 AND."""
    clauses = []
    for row in tt:
        *xs, y = row
        if y==0:
            lits = []
            for v,b in zip(vars_, xs):
                lits.append(v if b==0 else f"~{v}")
            clauses.append("(" + " | ".join(lits) + ")")
    return " & ".join(clauses) if clauses else "1"

# 예: f(a,b,c)=(a or b) and (not c)

f = lambda a,b,c: (a or b) and (not c)
vars_ = ['a','b','c']
tt = truth_table(f, vars_)

print("Truth Table (a b c | f):")
for r in tt: print(r)

print("\nSOP(PDNF):", sop_from_tt(tt, vars_))
print("POS(PCNF):", pos_from_tt(tt, vars_))
```

### 간단 K-맵 보조(4변수까지) — 교육용 그룹 후보 찾기

```python
# 교육용: 4변수 K-맵 인덱싱(그레이 코드)과 1셀/2/4/8 그룹 후보 생성
# 실제 최소화 완전 구현은 길어지므로 그룹 후보 탐색 핵심만 예시.

from itertools import product

gray2 = [(0,0),(0,1),(1,1),(1,0)]  # 2비트 그레이코드 순서

def index4(a,b,c,d):
    # 행: AB(그레이), 열: CD(그레이)
    r = gray2.index((a,b))
    c = gray2.index((c,d))
    return r, c

def kmap_coords_4(vars_, ones):
    # ones: 1인 minterm의 4비트 튜플 리스트
    grid = [[0]*4 for _ in range(4)]
    for (A,B,C,D) in ones:
        r,c = index4(A,B,C,D)
        grid[r][c]=1
    return grid

def wrap(idx): return idx % 4

def group_candidates(grid):
    H = len(grid)
    W = len(grid[0])
    groups = []

    # size 8 (1x8/8x1 불가 in 4x4), consider 4x2 and 2x4
    # 여기서는 4,2,1 그룹 위주로 단순 예시
    # 4-blocks
    for r in range(H):
        for c in range(W):
            cells = [(r,c),(r,wrap(c+1)),
                     (wrap(r+1),c),(wrap(r+1),wrap(c+1))]
            if all(grid[rr][cc]==1 for rr,cc in cells):
                groups.append(set(cells))

    # 2-horizontal
    for r in range(H):
        for c in range(W):
            cells = [(r,c),(r,wrap(c+1))]
            if all(grid[rr][cc]==1 for rr,cc in cells):
                groups.append(set(cells))

    # 2-vertical
    for r in range(H):
        for c in range(W):
            cells = [(r,c),(wrap(r+1),c)]
            if all(grid[rr][cc]==1 for rr,cc in cells):
                groups.append(set(cells))

    # 1-cells
    for r in range(H):
        for c in range(W):
            if grid[r][c]==1:
                groups.append({(r,c)})

    # 중복 제거
    uniq = []
    for g in groups:
        if g not in uniq: uniq.append(g)
    return uniq

# 사용 예: ones 구성은 진리표에서 1인 minterm들의 (A,B,C,D) 모음

```

### 간단 BDD 구축(변수순 고정)

```python
class BDDNode:
    __slots__ = ("var","lo","hi")  # var: index, lo:0-edge, hi:1-edge
    def __init__(self, var, lo, hi):
        self.var, self.lo, self.hi = var, lo, hi

# 0/1 단말

BDD_ZERO = 0
BDD_ONE  = 1

# 캐시로 공유(간단화)

_unique = {}

def mk(var, lo, hi):
    if lo==hi:  # 축약: 둘이 같으면 이 노드 불필요
        return lo
    key = (var, lo, hi)
    if key in _unique: return _unique[key]
    node = BDDNode(var, lo, hi)
    _unique[key] = node
    return node

def build_bdd(expr, vars_):
    # expr: lambda **env -> 0/1
    # vars_ 순서 고정 ROBDD-like
    def build(i, env):
        if i==len(vars_):
            return BDD_ONE if expr(**env) else BDD_ZERO
        v = vars_[i]
        env[v]=0; lo = build(i+1, env)
        env[v]=1; hi = build(i+1, env)
        del env[v]
        return mk(i, lo, hi)
    return build(0, {})

# 예: f(a,b,c)=(a or b) and (not c)

f = lambda a,b,c: (a or b) and (not c)
bdd = build_bdd(f, ['a','b','c'])
print("BDD root:", bdd)  # 구조체 출력(교육용)
```

---

## 실무 지침(요약)

- **명세**: 진리표/테스트로 함수 정의를 명확히(경계/don't-care 포함).
- **간소화**: K-맵(소수 변수), Quine–McCluskey(정확), Espresso(대규모).
- **해저드**: 글리치 위험 시 **중첩 커버** 추가(정적-1/0 hazard 제거).
- **합성**: NAND/NOR/INV 우선, 공통 부분식 공유, MUX화, 게이트 깊이 최소화.
- **검증**: 등가성(EQ) 체크, SAT/BDD, 랜덤/코너 케이스.
- **제약**: 팬아웃/부하/지연, 전력(활동률, 클록 게이팅), 신뢰성(노이즈 마진), DFT.

---

## 연습 문제

1) 다음 진리표의 **최소 SOP**를 K-맵으로 구하라(4변수).
2) $$f(a,b,c)=(a\lor b)\land \lnot c$$ 를 **PDNF/PCNF/ANF/Shannon 분해**로 각각 적어라.
3) **Quine–McCluskey**로 $$\Sigma m(1,3,7,11,15)$$ 의 최소 SOP를 구하라.
4) **Self-dual**/단조/대칭/선형 여부를 판별하는 기준을 간단 예와 함께 서술하라.
5) 정적-1 해저드가 있는 SOP 회로를 제시하고 **해저드 프리**로 수정하라.

---

## 핵심 요약

- **표현**: 진리표 ↔ SOP/POS ↔ ANF ↔ Shannon ↔ BDD ↔ CNF/DNF.
- **모든 함수**는 PDNF/PCNF로 표현 가능, **최소화**는 별도.
- **NAND/NOR**: 완전 집합(모든 함수 합성 가능).
- **최적화**: 대수/K-맵/Quine–McCluskey/Espresso, **해저드 주의**.
- **함수군**: 대칭/단조/선형/임계/자기쌍대/유니에이트—속성 알면 설계가 쉬워진다.
