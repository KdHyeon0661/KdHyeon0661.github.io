---
layout: post
title: Svelte - 예제 미니 프로젝트 (3)
date: 2025-10-08 14:30:23 +0900
category: Svelte
---
# 실전 예제 미니 프로젝트 (2) — **대시보드(차트 · 무한 스크롤 · 필터) 완전 가이드**

> SvelteKit로 **데이터 대시보드**를 처음부터 끝까지 구현한다.
> - **필터 바**: 날짜 범위, 상태, 검색어, 정렬
> - **무한 스크롤(IntersectionObserver)**: 페이지네이션 + 부드러운 로딩
> - **차트**: 지표 요약 카드, 시계열/막대/파이(동적 import로 SSR 안전)
> - **URL 동기화**: 필터 상태 ↔ 쿼리스트링 ↔ 서버
> - **API 설계**: 페이지네이션/정렬/필터/집계(차트) 엔드포인트
> - **접근성/성능**: Skeleton, 가상화 고려, 배치 업데이트, 캐시

---

## 목표 & 구성

### 우리가 만들 것

- `/dashboard`
  1) 상단 **FilterBar**: 기간, 채널, 상태, 검색, 정렬
  2) **KPI 카드**: 총 매출, 주문수, 전환율, 평균 주문금액
  3) **차트**: 일자별 매출(Area), 채널별 주문(Bar), 상태비율(Donut)
  4) **목록**: 주문 테이블(무한 스크롤)
  5) **URL 동기화**: 새로고침/링크 공유해도 상태 유지

### 기술 스택

- **SvelteKit** (라우팅/SSR/로드)
- **TypeScript**
- **차트**: Chart.js를 **동적 import**(SSR 안전), 최소 예제로 구현
- **API**: `+server.ts`에서 페이징/필터/집계 모두 제공
- **무한 스크롤**: 커스텀 `use:infinite` 액션 (IntersectionObserver)

---

## 디렉토리 구조

```
src/
  lib/
    components/
      FilterBar.svelte
      KpiCard.svelte
      ChartArea.svelte
      ChartBar.svelte
      ChartDonut.svelte
      DataTable.svelte
      Skeleton.svelte
    stores/
      dashboard.ts
    utils/
      date.ts
      number.ts
      io.ts            # Intersection Observer 액션
      url.ts           # URL<->state sync
  routes/
    dashboard/
      +page.svelte
      +page.ts
      api/
        orders/+server.ts        # 목록/페이징/필터/정렬
        summary/+server.ts       # 카드 요약
        timeseries/+server.ts    # 시계열(매출)
        channels/+server.ts      # 채널별 집계
        statuses/+server.ts      # 상태별 집계
    # (데모 데이터 소스)
    _seed/
      +server.ts
```

> 실제 운영에서는 데이터베이스가 필요하지만, 여기서는 **시연을 위해 서버에서 임의 데이터를 생성/보관**한다.

---

## 도메인 모델 & 목업 데이터

**Order**(주문) 컬럼:
- `id`: string (uuid)
- `date`: string (YYYY-MM-DD)
- `channel`: 'web' | 'mobile' | 'store'
- `status`: 'paid' | 'pending' | 'cancelled' | 'refunded'
- `amount`: number (원화)
- `items`: number (수량)

### 공통 타입

```ts
// src/routes/dashboard/api/_types.ts (선택적 위치)
// 간단화를 위해 여기 문서에만 표기. 실제로는 파일을 만들어 import하세요.
export type Order = {
  id: string;
  date: string;          // YYYY-MM-DD
  channel: 'web' | 'mobile' | 'store';
  status: 'paid' | 'pending' | 'cancelled' | 'refunded';
  amount: number;
  items: number;
};
```

---

## 서버 데이터 시드(데모용)

```ts
// src/routes/_seed/+server.ts
import type { RequestHandler } from './$types';

const channels = ['web','mobile','store'] as const;
const statuses = ['paid','pending','cancelled','refunded'] as const;

function randInt(min: number, max: number) { return Math.floor(Math.random()*(max-min+1))+min; }
function sample<T>(arr: readonly T[]) { return arr[randInt(0, arr.length-1)]; }
function pad2(n: number) { return n.toString().padStart(2,'0'); }

function genDateList(days=120) {
  const arr: string[] = [];
  const now = new Date();
  for (let i=0;i<days;i++){
    const d = new Date(now); d.setDate(now.getDate()-i);
    arr.push(`${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`);
  }
  return arr.reverse();
}

let DATA: any[] = []; // 메모리 저장소(데모)

function seed() {
  if (DATA.length) return;
  const dates = genDateList(180);
  let idn = 1;
  for (const dt of dates) {
    const count = randInt(30, 160); // 일자당 주문수
    for (let i=0;i<count;i++) {
      const ch = sample(channels);
      const st = sample(statuses);
      const amt = Math.max(0, Math.round((st==='cancelled'||st==='refunded')? (randInt(5,100)*1000*0.4) : randInt(5,100)*1000));
      DATA.push({
        id: `o_${idn++}`,
        date: dt,
        channel: ch,
        status: st,
        amount: amt,
        items: randInt(1,5)
      });
    }
  }
}
seed();

export const GET: RequestHandler = async () => {
  // 단순 확인용
  return new Response(JSON.stringify({ ok: true, count: DATA.length }), { headers: { 'content-type':'application/json' } });
};

// 다른 라우트에서 사용하려고 export
export function getData() { seed(); return DATA as any[]; }
export function setData(newData: any[]) { DATA = newData; }
```

> 운영에서는 절대 메모리 저장소를 쓰지 말고 DB/캐시를 사용하세요.

---

## API — 목록/집계

### 공통 유틸(날짜, 파라미터 파싱)

```ts
// src/lib/utils/date.ts
export function parseDate(s: string) {
  const d = new Date(s); if (isNaN(d.getTime())) return null; return d;
}
export function fmtDate(d: Date) {
  const y = d.getFullYear(); const m = String(d.getMonth()+1).padStart(2,'0'); const day = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${day}`;
}
export function rangeDays(start: string, end: string) {
  const ds = parseDate(start), de = parseDate(end);
  if (!ds || !de || ds>de) return [];
  const out: string[] = [];
  const cur = new Date(ds);
  while (cur <= de) { out.push(fmtDate(cur)); cur.setDate(cur.getDate()+1); }
  return out;
}
```

```ts
// src/lib/utils/number.ts
export const fmtCurrency = (n: number, currency='KRW') =>
  new Intl.NumberFormat('ko-KR', { style:'currency', currency, maximumFractionDigits:0 }).format(n);
export const fmtInt = (n: number) => new Intl.NumberFormat('ko-KR').format(n);
```

### 목록 API(+server.ts) — 페이지네이션/정렬/필터

```ts
// src/routes/dashboard/api/orders/+server.ts
import type { RequestHandler } from './$types';
import { getData } from '../../../_seed/+server';

type Q = {
  q?: string;
  from?: string; // YYYY-MM-DD
  to?: string;   // YYYY-MM-DD
  channel?: string; // comma sep
  status?: string;  // comma sep
  sort?: 'date_desc'|'date_asc'|'amount_desc'|'amount_asc';
  cursor?: string;  // 마지막 id (또는 offset)
  limit?: string;   // default 30
};

export const GET: RequestHandler = async ({ url }) => {
  const q = Object.fromEntries(url.searchParams) as Q;
  const limit = Math.min(Number(q.limit ?? 30), 200);
  const cursor = q.cursor ? Number(q.cursor) : 0; // 단순 offset 방식(데모)
  const data = getData();

  // 필터
  const qword = (q.q ?? '').toLowerCase();
  const chan = (q.channel ?? '').split(',').filter(Boolean);
  const stat = (q.status ?? '').split(',').filter(Boolean);

  let rows = data.filter(r => {
    if (q.from && r.date < q.from) return false;
    if (q.to && r.date > q.to) return false;
    if (chan.length && !chan.includes(r.channel)) return false;
    if (stat.length && !stat.includes(r.status)) return false;
    if (qword && !(r.id.toLowerCase().includes(qword))) return false; // 데모: id 검색
    return true;
  });

  // 정렬
  switch (q.sort) {
    case 'date_asc': rows.sort((a,b)=> a.date.localeCompare(b.date)); break;
    case 'amount_desc': rows.sort((a,b)=> b.amount-a.amount); break;
    case 'amount_asc': rows.sort((a,b)=> a.amount-b.amount); break;
    default: rows.sort((a,b)=> b.date.localeCompare(a.date));
  }

  const slice = rows.slice(cursor, cursor + limit);
  const next = (cursor + limit) < rows.length ? String(cursor + limit) : null;

  return new Response(JSON.stringify({
    items: slice,
    next,
    total: rows.length
  }), { headers: { 'content-type':'application/json', 'cache-control':'no-store' }});
};
```

> 실전에서는 cursor 기반(마지막 `createdAt,id`) 페이징을 권장. 여기선 **간단 offset**으로 시연.

### KPI 카드(요약) API

```ts
// src/routes/dashboard/api/summary/+server.ts
import type { RequestHandler } from './$types';
import { getData } from '../../_seed/+server';

export const GET: RequestHandler = async ({ url }) => {
  const q = Object.fromEntries(url.searchParams);
  const from = q.from as string | undefined;
  const to = q.to as string | undefined;
  const chan = (q.channel as string | undefined)?.split(',').filter(Boolean) ?? [];
  const stat = (q.status as string | undefined)?.split(',').filter(Boolean) ?? [];

  const rows = getData().filter(r => {
    if (from && r.date < from) return false;
    if (to && r.date > to) return false;
    if (chan.length && !chan.includes(r.channel)) return false;
    if (stat.length && !stat.includes(r.status)) return false;
    return true;
  });

  const totalSales = rows.reduce((s, r)=> s + ((r.status==='paid') ? r.amount : 0), 0);
  const orders = rows.length;
  const paidOrders = rows.filter(r => r.status==='paid').length;
  const conv = orders ? (paidOrders/orders) : 0;
  const aov = paidOrders ? Math.round(totalSales / paidOrders) : 0;

  return new Response(JSON.stringify({
    totalSales, orders, conv, aov
  }), { headers: { 'content-type':'application/json', 'cache-control':'no-store' }});
};
```

### 시계열(매출) API

```ts
// src/routes/dashboard/api/timeseries/+server.ts
import type { RequestHandler } from './$types';
import { getData } from '../../_seed/+server';
import { rangeDays } from '$lib/utils/date';

export const GET: RequestHandler = async ({ url }) => {
  const q = Object.fromEntries(url.searchParams);
  const from = q.from as string | undefined;
  const to = q.to as string | undefined;
  const chan = (q.channel as string | undefined)?.split(',').filter(Boolean) ?? [];
  const stat = (q.status as string | undefined)?.split(',').filter(Boolean) ?? [];

  const rows = getData().filter(r => {
    if (from && r.date < from) return false;
    if (to && r.date > to) return false;
    if (chan.length && !chan.includes(r.channel)) return false;
    if (stat.length && !stat.includes(r.status)) return false;
    return true;
  });

  const days = rangeDays(from ?? rows[0]?.date ?? '2025-01-01', to ?? rows.at(-1)?.date ?? '2025-12-31');
  const map = new Map<string, number>();
  for (const d of days) map.set(d, 0);
  for (const r of rows) {
    if (r.status==='paid') map.set(r.date, (map.get(r.date) ?? 0) + r.amount);
  }

  const series = days.map(d => ({ date: d, value: map.get(d) ?? 0 }));
  return new Response(JSON.stringify({ series }), { headers: { 'content-type':'application/json', 'cache-control':'no-store' }});
};
```

### 채널별/상태별 집계

```ts
// src/routes/dashboard/api/channels/+server.ts
import type { RequestHandler } from './$types';
import { getData } from '../../_seed/+server';

export const GET: RequestHandler = async ({ url }) => {
  const q = Object.fromEntries(url.searchParams);
  const from = q.from as string | undefined;
  const to = q.to as string | undefined;

  const rows = getData().filter(r => {
    if (from && r.date < from) return false;
    if (to && r.date > to) return false;
    return true;
  });

  const agg = new Map<string, number>();
  for (const r of rows) { agg.set(r.channel, (agg.get(r.channel) ?? 0) + 1); }
  const data = [...agg.entries()].map(([name, value]) => ({ name, value }));
  return new Response(JSON.stringify({ data }), { headers: { 'content-type':'application/json' }});
};
```

```ts
// src/routes/dashboard/api/statuses/+server.ts
import type { RequestHandler } from './$types';
import { getData } from '../../_seed/+server';

export const GET: RequestHandler = async ({ url }) => {
  const q = Object.fromEntries(url.searchParams);
  const from = q.from as string | undefined;
  const to = q.to as string | undefined;

  const rows = getData().filter(r => {
    if (from && r.date < from) return false;
    if (to && r.date > to) return false;
    return true;
  });

  const agg = new Map<string, number>();
  for (const r of rows) { agg.set(r.status, (agg.get(r.status) ?? 0) + 1); }
  const data = [...agg.entries()].map(([name, value]) => ({ name, value }));
  return new Response(JSON.stringify({ data }), { headers: { 'content-type':'application/json' }});
};
```

---

## 스토어(필터/상태/로딩)

```ts
// src/lib/stores/dashboard.ts
import { writable, derived } from 'svelte/store';

export type Filters = {
  q: string;
  from: string;
  to: string;
  channels: string[];      // ['web','mobile','store']
  statuses: string[];      // ['paid','pending','cancelled','refunded']
  sort: 'date_desc'|'date_asc'|'amount_desc'|'amount_asc';
};

export const filters = writable<Filters>({
  q: '',
  from: '',
  to: '',
  channels: [],
  statuses: [],
  sort: 'date_desc'
});

export const loading = writable(false);
export const list = writable<any[]>([]);
export const nextCursor = writable<string|null>(null);
export const total = writable(0);

// 차트/카드
export const kpi = writable<{ totalSales:number; orders:number; conv:number; aov:number } | null>(null);
export const ts = writable<{ date:string; value:number }[]>([]);
export const byChannel = writable<{ name:string; value:number }[]>([]);
export const byStatus = writable<{ name:string; value:number }[]>([]);

// 쿼리스트링 생성
export const queryString = derived(filters, ($f) => {
  const p = new URLSearchParams();
  if ($f.q) p.set('q', $f.q);
  if ($f.from) p.set('from', $f.from);
  if ($f.to) p.set('to', $f.to);
  if ($f.channels.length) p.set('channel', $f.channels.join(','));
  if ($f.statuses.length) p.set('status', $f.statuses.join(','));
  if ($f.sort) p.set('sort', $f.sort);
  return p.toString();
});
```

---

## URL ↔ 상태 동기화

```ts
// src/lib/utils/url.ts
import type { Filters } from '$lib/stores/dashboard';

export function parseFilters(url: URL): Filters {
  const p = url.searchParams;
  return {
    q: p.get('q') ?? '',
    from: p.get('from') ?? '',
    to: p.get('to') ?? '',
    channels: (p.get('channel') ?? '').split(',').filter(Boolean),
    statuses: (p.get('status') ?? '').split(',').filter(Boolean),
    sort: (p.get('sort') as Filters['sort']) ?? 'date_desc'
  };
}

export function toQuery(filters: Filters) {
  const u = new URLSearchParams();
  if (filters.q) u.set('q', filters.q);
  if (filters.from) u.set('from', filters.from);
  if (filters.to) u.set('to', filters.to);
  if (filters.channels.length) u.set('channel', filters.channels.join(','));
  if (filters.statuses.length) u.set('status', filters.statuses.join(','));
  if (filters.sort) u.set('sort', filters.sort);
  return u.toString();
}
```

---

## 무한 스크롤 액션(IntersectionObserver)

```ts
// src/lib/utils/io.ts
export function infinite(node: Element, options: { onLoad: () => void; rootMargin?: string }) {
  const { onLoad, rootMargin = '300px' } = options;
  const io = new IntersectionObserver((entries) => {
    for (const e of entries) {
      if (e.isIntersecting) onLoad();
    }
  }, { rootMargin });
  io.observe(node);
  return {
    destroy() { io.disconnect(); }
  };
}
```

> 이 액션을 **sentinel** 요소에 붙여 아래로 스크롤할 때마다 다음 페이지를 로드한다.

---

## 차트 컴포넌트(SSR 안전, 동적 import)

> **중요**: Chart.js는 브라우저 API에 의존. **동적 import**로 클라이언트에서만 로드.

### 공통 스켈레톤

```svelte
<!-- src/lib/components/Skeleton.svelte -->
<div class="skl" role="status" aria-label="로딩중"></div>
<style>
.skl{height:100%;width:100%;background:linear-gradient(90deg,#f3f4f6,#e5e7eb,#f3f4f6);background-size:200% 100%;animation:shimmer 1.2s infinite}
@keyframes shimmer{0%{background-position:200% 0}100%{background-position:-200% 0}}
</style>
```

### Area(시계열)

```svelte
<!-- src/lib/components/ChartArea.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import Skeleton from './Skeleton.svelte';
  export let data: { labels: string[]; series: number[] } | null = null;
  export let title = '';

  let canvas: HTMLCanvasElement;
  let chart: any;
  let ready = false;

  onMount(async () => {
    const { Chart, registerables } = await import('chart.js');
    Chart.register(...registerables);
    ready = true;
    make();
  });
  onDestroy(()=> chart?.destroy());

  function make() {
    if (!ready || !canvas) return;
    chart?.destroy();
    // @ts-ignore
    const { Chart } = window['Chart'] ? window : await import('chart.js'); // 안전망
    // eslint-disable-next-line
    chart = new (await import('chart.js')).Chart(canvas.getContext('2d')!, {
      type: 'line',
      data: {
        labels: data?.labels ?? [],
        datasets: [{
          label: '매출',
          data: data?.series ?? [],
          fill: true,
          tension: .3
        }]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false }, title: { display: !!title, text: title } },
        scales: { y: { ticks: { callback: (v)=> new Intl.NumberFormat('ko-KR').format(Number(v)) } } }
      }
    });
  }

  $: data, ready && make();
</script>

{#if !ready || !data}<Skeleton/>{:else}<canvas bind:this={canvas} aria-label={title} role="img"></canvas>{/if}
```

### Bar(채널)

```svelte
<!-- src/lib/components/ChartBar.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import Skeleton from './Skeleton.svelte';
  export let data: { labels: string[]; series: number[] } | null = null;
  export let title = '';

  let canvas: HTMLCanvasElement; let chart: any; let ready = false;

  onMount(async () => {
    const { Chart, registerables } = await import('chart.js');
    Chart.register(...registerables); ready = true; draw();
  });
  onDestroy(()=> chart?.destroy());
  function draw(){
    if (!ready || !canvas) return;
    chart?.destroy();
    import('chart.js').then(({ Chart }) => {
      chart = new Chart(canvas.getContext('2d')!, {
        type: 'bar',
        data: {
          labels: data?.labels ?? [],
          datasets: [{ label: '주문수', data: data?.series ?? [] }]
        },
        options: { responsive: true, plugins: { legend: { display:false }, title:{ display: !!title, text: title } } }
      });
    });
  }
  $: data, ready && draw();
</script>
{#if !ready || !data}<Skeleton/>{:else}<canvas bind:this={canvas} aria-label={title} role="img"></canvas>{/if}
```

### Donut(상태)

```svelte
<!-- src/lib/components/ChartDonut.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import Skeleton from './Skeleton.svelte';
  export let data: { labels: string[]; series: number[] } | null = null;
  export let title = '';
  let canvas: HTMLCanvasElement; let chart:any; let ready=false;

  onMount(async () => {
    const { Chart, registerables } = await import('chart.js');
    Chart.register(...registerables); ready = true; draw();
  });
  onDestroy(()=> chart?.destroy());

  function draw(){
    if (!ready || !canvas) return;
    import('chart.js').then(({ Chart }) => {
      chart = new Chart(canvas.getContext('2d')!, {
        type: 'doughnut',
        data: { labels: data?.labels ?? [], datasets: [{ data: data?.series ?? [] }] },
        options: { responsive: true, plugins: { title: { display: !!title, text: title } } }
      });
    });
  }
  $: data, ready && draw();
</script>
{#if !ready || !data}<Skeleton/>{:else}<canvas bind:this={canvas} aria-label={title} role="img"></canvas>{/if}
```

---

## KPI 카드

```svelte
<!-- src/lib/components/KpiCard.svelte -->
<script lang="ts">
  export let label = '';
  export let value: string | number | null = null;
  export let sub: string | null = null;
</script>

<div class="kpi" role="group" aria-label={label}>
  <div class="label">{label}</div>
  <div class="value">{value ?? '—'}</div>
  {#if sub}<div class="sub">{sub}</div>{/if}
</div>

<style>
.kpi{padding:1rem;border:1px solid #e5e7eb;border-radius:12px;background:#fff;display:grid;gap:.3rem}
.label{color:#64748b}
.value{font-weight:700;font-size:1.4rem}
.sub{color:#64748b}
</style>
```

---

## 필터 바

```svelte
<!-- src/lib/components/FilterBar.svelte -->
<script lang="ts">
  import type { Filters } from '$lib/stores/dashboard';
  import { filters } from '$lib/stores/dashboard';
  import { get } from 'svelte/store';

  let local: Filters;
  $: filters.subscribe(v => local = structuredClone(v));

  function toggle(arr: string[], key: string) {
    const i = arr.indexOf(key);
    if (i>=0) arr.splice(i,1); else arr.push(key);
  }
  function apply() {
    filters.set(local);
  }
  function reset() {
    filters.set({ q:'', from:'', to:'', channels:[], statuses:[], sort:'date_desc' });
  }
</script>

<form class="bar" on:submit|preventDefault={apply}>
  <input placeholder="검색 (id)" bind:value={local.q} aria-label="검색" />
  <label>From <input type="date" bind:value={local.from} /></label>
  <label>To <input type="date" bind:value={local.to} /></label>

  <fieldset>
    <legend class="sr">채널</legend>
    {#each ['web','mobile','store'] as c}
      <button type="button" class:active={local.channels.includes(c)} on:click={() => (toggle(local.channels,c), local=local)}>{c}</button>
    {/each}
  </fieldset>

  <fieldset>
    <legend class="sr">상태</legend>
    {#each ['paid','pending','cancelled','refunded'] as s}
      <button type="button" class:active={local.statuses.includes(s)} on:click={() => (toggle(local.statuses,s), local=local)}>{s}</button>
    {/each}
  </fieldset>

  <select bind:value={local.sort}>
    <option value="date_desc">최신순</option>
    <option value="date_asc">오래된순</option>
    <option value="amount_desc">금액 높은순</option>
    <option value="amount_asc">금액 낮은순</option>
  </select>

  <button type="submit">적용</button>
  <button type="button" on:click={reset}>초기화</button>
</form>

<style>
.bar{display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;margin-bottom:1rem}
fieldset{display:flex;gap:.25rem;border:0;padding:0}
button.active{background:#111827;color:#fff;border-radius:8px;padding:.3rem .6rem}
.sr{position:absolute;left:-9999px}
</style>
```

---

## 데이터 테이블(무한 스크롤)

{% raw %}
```svelte
<!-- src/lib/components/DataTable.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { list, nextCursor, total } from '$lib/stores/dashboard';
  import { infinite } from '$lib/utils/io';
  import { fmtCurrency, fmtInt } from '$lib/utils/number';

  export let loadMore: () => Promise<void>;
  export let isLoading: boolean;

  let sentinel: HTMLDivElement;

  $: hasMore = $nextCursor !== null;
</script>

<table class="tbl" role="table" aria-label="주문 목록">
  <thead>
    <tr>
      <th>ID</th><th>날짜</th><th>채널</th><th>상태</th><th style="text-align:right">금액</th><th style="text-align:right">수량</th>
    </tr>
  </thead>
  <tbody>
    {#each $list as r (r.id)}
      <tr>
        <td>{r.id}</td>
        <td>{r.date}</td>
        <td>{r.channel}</td>
        <td>{r.status}</td>
        <td style="text-align:right">{fmtCurrency(r.amount)}</td>
        <td style="text-align:right">{fmtInt(r.items)}</td>
      </tr>
    {/each}
  </tbody>
</table>

<div class="meta">
  <div>총 {fmtInt($total)}건</div>
  {#if isLoading}<div aria-live="polite">로딩 중…</div>{/if}
</div>

{#if hasMore}
  <!-- 스크롤 하단 감지 -->
  <div bind:this={sentinel} use:infinite={{ onLoad: loadMore, rootMargin:'600px' }} class="sentinel" aria-hidden="true"></div>
{:else}
  <div class="end">끝까지 보셨습니다.</div>
{/if}

<style>
.tbl{width:100%;border-collapse:collapse;background:#fff;border-radius:12px;overflow:hidden;border:1px solid #e5e7eb}
th,td{padding:.6rem;border-bottom:1px solid #f1f5f9}
thead th{background:#f8fafc;text-align:left}
.meta{display:flex;justify-content:space-between;align-items:center;padding:.5rem 0}
.sentinel{height:1px}
.end{color:#64748b;padding:1rem 0}
</style>
```
{% endraw %}

---

## 대시보드 페이지 데이터 로딩(+page.ts)

```ts
// src/routes/dashboard/+page.ts
import type { PageLoad } from './$types';
import { parseFilters } from '$lib/utils/url';

export const load: PageLoad = async ({ fetch, url }) => {
  // 초기 렌더 시 필터를 파싱해서 첫 페이지/요약/차트까지 가져온다.
  const f = parseFilters(url);
  const qs = new URLSearchParams();
  if (f.q) qs.set('q', f.q);
  if (f.from) qs.set('from', f.from);
  if (f.to) qs.set('to', f.to);
  if (f.channels.length) qs.set('channel', f.channels.join(','));
  if (f.statuses.length) qs.set('status', f.statuses.join(','));
  if (f.sort) qs.set('sort', f.sort);

  const [ordersRes, sumRes, tsRes, chRes, stRes] = await Promise.all([
    fetch(`/dashboard/api/orders?${qs.toString()}`),
    fetch(`/dashboard/api/summary?${qs.toString()}`),
    fetch(`/dashboard/api/timeseries?${qs.toString()}`),
    fetch(`/dashboard/api/channels?${qs.toString()}`),
    fetch(`/dashboard/api/statuses?${qs.toString()}`)
  ]);

  const orders = await ordersRes.json();
  const summary = await sumRes.json();
  const ts = await tsRes.json();
  const ch = await chRes.json();
  const st = await stRes.json();

  return { initial: { orders, summary, ts, ch, st, filters: f } };
};
```

---

## 대시보드 페이지 UI(+page.svelte)

```svelte
<!-- src/routes/dashboard/+page.svelte -->
<script lang="ts">
  import FilterBar from '$lib/components/FilterBar.svelte';
  import KpiCard from '$lib/components/KpiCard.svelte';
  import ChartArea from '$lib/components/ChartArea.svelte';
  import ChartBar from '$lib/components/ChartBar.svelte';
  import ChartDonut from '$lib/components/ChartDonut.svelte';
  import DataTable from '$lib/components/DataTable.svelte';

  import { filters, list, nextCursor, total, loading, kpi, ts, byChannel, byStatus, queryString } from '$lib/stores/dashboard';
  import { toQuery } from '$lib/utils/url';
  import { fmtCurrency, fmtInt } from '$lib/utils/number';
  import { goto } from '$app/navigation';

  export let data: { initial: any };

  // 초기 데이터 주입
  $: if (data?.initial) {
    filters.set(data.initial.filters);
    list.set(data.initial.orders.items);
    nextCursor.set(data.initial.orders.next);
    total.set(data.initial.orders.total);
    kpi.set(data.initial.summary);
    ts.set(data.initial.ts.series);
    byChannel.set(data.initial.ch.data);
    byStatus.set(data.initial.st.data);
  }

  // 필터 변경 시 URL 갱신 + 데이터 리프레시
  $: (async () => {
    // 최초 주입 직후 한번 더 호출되는 것을 피하고 싶다면 guard를 두세요.
    const qs = $queryString;
    // URL만 변경 (replaceState) → SPA 네비게이션
    goto(`/dashboard?${qs}`, { replaceState: true, noScroll: true });
    await refetchAll();
  })();

  async function refetchAll() {
    $loading = true;
    try {
      const base = `/dashboard/api`;
      const qs = $queryString;
      const [ordersRes, sumRes, tsRes, chRes, stRes] = await Promise.all([
        fetch(`${base}/orders?${qs}`),
        fetch(`${base}/summary?${qs}`),
        fetch(`${base}/timeseries?${qs}`),
        fetch(`${base}/channels?${qs}`),
        fetch(`${base}/statuses?${qs}`)
      ]);
      const orders = await ordersRes.json();
      list.set(orders.items);
      nextCursor.set(orders.next);
      total.set(orders.total);

      kpi.set(await sumRes.json());
      const tsData = await tsRes.json();
      ts.set(tsData.series);
      byChannel.set((await chRes.json()).data);
      byStatus.set((await stRes.json()).data);
    } finally { $loading = false; }
  }

  async function loadMore() {
    if ($loading || $nextCursor===null) return;
    $loading = true;
    try {
      const res = await fetch(`/dashboard/api/orders?${$queryString}&cursor=${$nextCursor}`);
      const { items, next } = await res.json();
      list.update(a => a.concat(items));
      nextCursor.set(next);
    } finally { $loading = false; }
  }

  $: areaData = $ts.length
    ? { labels: $ts.map(d=>d.date), series: $ts.map(d=>d.value) }
    : null;
  $: barData = $byChannel.length
    ? { labels: $byChannel.map(d=>d.name), series: $byChannel.map(d=>d.value) }
    : null;
  $: donutData = $byStatus.length
    ? { labels: $byStatus.map(d=>d.name), series: $byStatus.map(d=>d.value) }
    : null;
</script>

<h1>대시보드</h1>
<FilterBar />

<section class="kpis">
  <KpiCard label="총 매출"   value={ $kpi ? fmtCurrency($kpi.totalSales) : '—' } />
  <KpiCard label="주문 수"   value={ $kpi ? fmtInt($kpi.orders) : '—' } />
  <KpiCard label="전환율"    value={ $kpi ? `${($kpi.conv*100).toFixed(1)}%` : '—' } />
  <KpiCard label="평균 주문액" value={ $kpi ? fmtCurrency($kpi.aov) : '—' } />
</section>

<section class="charts">
  <div class="card"><ChartArea title="일자별 매출" data={areaData}/></div>
  <div class="card"><ChartBar title="채널별 주문" data={barData}/></div>
  <div class="card"><ChartDonut title="상태 비율" data={donutData}/></div>
</section>

<section class="list">
  <h2>주문 목록</h2>
  <DataTable {loadMore} isLoading={$loading} />
</section>

<style>
.kpis{display:grid;grid-template-columns:repeat(4,1fr);gap:.8rem;margin:.8rem 0}
.charts{display:grid;grid-template-columns:2fr 1fr 1fr;gap:.8rem}
.card{border:1px solid #e5e7eb;border-radius:12px;background:#fff;padding:.4rem .8rem;min-height:260px}
.list{margin-top:1rem}
@media (max-width: 1200px){
  .kpis{grid-template-columns:repeat(2,1fr)}
  .charts{grid-template-columns:1fr; }
}
</style>
```

---

## 접근성(A11y) & UX 디테일

- **키보드 탐색**: 필터 버튼들은 `<button>`(role/aria-pressed 필요 시)로 구현
- **라이브 영역**: 로딩/추가 로딩 메시지 `aria-live="polite"`
- **표**: `<table>` 기본 시맨틱 사용, 헤더/셀 정렬 속성 명확히
- **차트**: `<canvas>`에 `role="img"`와 `aria-label` 제공. 요약 텍스트를 차트 아래 `<figcaption>`으로 제공해도 좋다.
- **포커스 관리**: 필터 적용 시 리스트 맨 위로 스크롤 또는 포커스 이동(선택)

---

## 성능 최적화 팁

1. **차트 동적 import**: 초기 JS 감소
2. **Infinite rootMargin**: `600px`로 **미리 로드**하여 끊김 방지
3. **서버 캐시**: 요약/집계 API에 시간 기반 캐시(예: 30초)
4. **응답 축소**: 목록 필드는 필요한 것만 반환(대용량 컬럼 제외)
5. **가상 스크롤**: 데이터가 수만 건이면 `svelte-virtual` 같은 가상화 사용
6. **배치 요청**: 필터 변경 직후 200ms 디바운스로 API 호출 합치기
7. **ETag/If-None-Match**: 동일 쿼리 재요청 시 304 활용

간단 디바운스 예:

```ts
let t: any;
function schedule(fn: ()=>void, ms=200){ clearTimeout(t); t=setTimeout(fn, ms); }
$: $filters, schedule(()=> refetchAll(), 200);
```

---

## 테스트(핵심 시나리오)

- 필터 조합(날짜/채널/상태/검색) → 결과 수/요약 값이 기대대로 변하는가
- 무한 스크롤: 스크롤 트리거 → 다음 페이지 합쳐지는가, 더 이상 없을 때 메시지 노출
- URL 동기화: 새로고침/직접 링크 진입 시 동일 상태인가
- 차트: API 응답 유무에 따라 스켈레톤 → 그래프 전환이 정상인가

---

## 배포 & 운영 노트

- **SSR/SSG**: 이 예제는 SSR 라우트(API) 의존. `adapter-node` 또는 서버리스로 배포
- **보안**: 인증/권한 필터를 API에 추가(예: 조직/테넌트 경계)
- **관측**: 요청 로그(쿼리 파라미터, 소요 시간), 오류 추적(Sentry)
- **스키마 고정**: 필터 값 enum 은 서버에서 화이트리스트 검증

---

## 부록 — 수학 통계 예시(선택)

> 간단한 전환율 정의:
> $$ \mathrm{ConversionRate} = \frac{\text{Paid Orders}}{\text{All Orders}} $$

평균 주문액(AOV):
$$ \mathrm{AOV} = \frac{\text{Total Sales (paid)}}{\text{Paid Orders}} $$

*위 수식은 KPI 계산과 동일한 정의를 수식으로 표현한 것뿐입니다.*

---

## 요약

- **필터 상태**를 **스토어와 URL**에 동기화하여 새로고침/공유에도 안전
- **무한 스크롤**은 `IntersectionObserver` 기반으로 깔끔하게 구성
- **차트**는 **동적 import**로 SSR 문제를 회피하고 초기 번들을 줄임
- **API**는 **같은 필터 규약**으로 목록/요약/집계를 제공 → 일관성 유지
- 접근성과 성능을 함께 고려하면 **현실적인 대시보드**를 빠르게 구축할 수 있다.

---

## 빠른 복붙 체크리스트

- [ ] `/routes/_seed/+server.ts` 추가(데모 데이터)
- [ ] `/routes/dashboard/api/*` 엔드포인트 생성
- [ ] `/lib/stores/dashboard.ts` 스토어 구성
- [ ] `/lib/components/*` 차트/테이블/필터 구현
- [ ] `/routes/dashboard/+page.ts|svelte` 페이지 연결
- [ ] 동작 확인 → 필터/스크롤/차트 렌더 → 배포
