---
layout: post
title: 운영체제 - 동기화 도구 (3)
date: 2025-10-20 19:25:23 +0900
category: 운영체제
---
# Chapter 6.7–6.9 — Monitors • Liveness • Evaluation

## Monitors

### 모니터란?

- **모니터**는 **상호배제(mutex)** 와 **조건변수(condition variables)** 를 **하나의 모듈**로 묶은 고수준 동기화 추상화.
- 핵심 규약:
  1) **모니터 메서드**는 **암묵적으로 상호배제**된다(한 번에 한 스레드만 내부 실행).
  2) **조건변수**는 “상태가 참일 때까지 기다렸다가 신호를 받고 재개”하는 *대기/신호* 메커니즘을 제공.

### Hoare vs Mesa(현대) 의미론

- **Hoare-style** (“signal-and-urgent-wait”):
  `signal(c)` 직후 **즉시** 깨워진 스레드가 **모니터를 차지**한다(시그널러는 “긴급 대기열”로 이동).
  → 조건이 “시그널 시점에 반드시 참”.
- **Mesa-style** (“signal-and-continue”, Java/C++/POSIX):
  `signal`은 **깨우기만** 하고 **시그널러가 계속 실행**. 깨어난 스레드는 **잠시 후** 진입.
  → **반드시 `while (!cond) wait()` 패턴**으로 재검증 필요(스퍼리어스 웨이크업/조건 변동 대응).

> 실무 결론: **항상 `while (predicate == false) wait()`**. `if`는 위험!

---

### Java 내장 모니터 (synchronized + wait/notify)

#### Bounded Buffer (Mesa 의미론)

```java
// BoundedBuffer.java — 모니터(내장 락 + 조건)로 구현한 고전 문제
public class BoundedBuffer<T> {
    private final Object[] buf;
    private int head=0, tail=0, count=0;

    public BoundedBuffer(int cap){ buf = new Object[cap]; }

    public synchronized void put(T x) throws InterruptedException {
        while(count==buf.length) wait();        // while! (Mesa)
        buf[head] = x; head = (head+1)%buf.length; count++;
        notifyAll();                             // 대기자 모두에게 상태 변화 통지
    }
    @SuppressWarnings("unchecked")
    public synchronized T take() throws InterruptedException {
        while(count==0) wait();                  // while! (Mesa)
        T v = (T)buf[tail]; tail = (tail+1)%buf.length; count--;
        notifyAll();
        return v;
    }
}
```

- **포인트**
  - `wait()`는 **호출 시점에 모니터 락을 놓고 대기**, 재개 시 **락을 다시 획득** 후 리턴.
  - **`notifyAll()`**: 생산자/소비자 혼재 시 하나만 깨우면 **헤드-오브-라인 블로킹**이 생길 수 있다.

#### Readers–Writers (Writer 우선)

```java
// RWLock.java — 간단 Writer-Preference Monitor
public class RWLock {
    private int readers = 0;
    private int writers = 0;        // active writers (0 or 1)
    private int waitingW = 0;       // waiting writers

    public synchronized void rlock() throws InterruptedException {
        while (writers > 0 || waitingW > 0) wait(); // writer 우선
        readers++;
    }
    public synchronized void runlock() {
        readers--;
        if (readers==0) notifyAll();
    }
    public synchronized void wlock() throws InterruptedException {
        waitingW++;
        while (writers>0 || readers>0) wait();
        waitingW--;
        writers=1;
    }
    public synchronized void wunlock() {
        writers=0;
        notifyAll();
    }
}
```

---

### C++ 모니터 패턴 (mutex + condition_variable)

#### Monitor 클래스로 캡슐화

```cpp
// monitor_queue.cpp — std::mutex + std::condition_variable로 모니터 구현
#include <mutex>
#include <condition_variable>
#include <deque>
#include <optional>

template<class T>
class MonitorQueue {
    std::mutex m_;
    std::condition_variable cv_not_empty_, cv_not_full_;
    std::deque<T> q_;
    const size_t cap_;
public:
    explicit MonitorQueue(size_t cap):cap_(cap){}
    void push(T v){
        std::unique_lock<std::mutex> lk(m_);
        cv_not_full_.wait(lk, [&]{ return q_.size()<cap_; }); // while-predicate
        q_.push_back(std::move(v));
        lk.unlock();              // 신호 전에 락 해제를 강제할 필요는 없지만
        cv_not_empty_.notify_one();
    }
    T pop(){
        std::unique_lock<std::mutex> lk(m_);
        cv_not_empty_.wait(lk, [&]{ return !q_.empty(); });
        T v = std::move(q_.front()); q_.pop_front();
        lk.unlock();
        cv_not_full_.notify_one();
        return v;
    }
};
```

- **Mesa-style 규칙** 요약:
  $$\text{always use}\; \texttt{cv.wait(lock, predicate)}$$
  깨어났다고 **조건이 보장되지 않는다**.

#### 조건변수 2개로 명확한 의도 표현

- `cv_not_empty` / `cv_not_full` 를 분리해 **불필요한 깨어남**을 줄인다(성능/전력).

---

### Go: 모니터 없는 CSP 스타일 (참고)

- Go는 **모니터 대신 채널**로 동기화(CSP).
- 그러나 `sync.Mutex/Cond` 도 존재.
- *메시지 전달*이 자연스러운 파이프라인엔 채널, *공유 상태*에는 모니터가 직관적.

---

### 모니터에서의 예외/타임아웃/스푸리어스

- **스푸리어스 웨이크업**: POSIX/자바 모두 **가능** → `while` 필수.
- **타임아웃**: `cv.wait_for` / `wait(timeout)` 사용 시, **반드시 반환값으로 조건 재검증**.
- **예외**: C++는 RAII로 락 자동 해제, Java는 finally에서 해제 패턴(synchronized는 블록 벗어나면 자동).

---

### Dining Philosophers — 모니터로 교착·기아 모두 방지

- 전략: **웨이터(중재자) 모니터**가 최대 `N-1`명만 포크 집도록 관리 + **배고픔 시간 기반 공정성**.

```java
// DiningMonitor.java — N-1 제한 + 공정성(간단 점수)에 기반한 허가
import java.util.*;
public class DiningMonitor {
  private final int N;
  private final boolean[] fork;
  private final long[] hungrySince;
  public DiningMonitor(int n){ N=n; fork=new boolean[n]; hungrySince=new long[n]; }
  private boolean canEat(int i){
    int l=i, r=(i+1)%N;
    return !fork[l] && !fork[r];
  }
  public synchronized void pick(int i) throws InterruptedException {
    hungrySince[i]=System.nanoTime();
    while(!canEat(i) || activeCount()>=N-1){
      wait();
    }
    fork[i]=fork[(i+1)%N]=true;
  }
  public synchronized void put(int i){
    fork[i]=fork[(i+1)%N]=false;
    notifyAll();
  }
  private int activeCount(){
    int c=0; for(boolean b:fork) if(b) c++;
    return c/2;
  }
}
```

---

## Liveness

### 안전(Safety) vs 활성(Liveness)

- **Safety(안전)**: “나쁜 일이 **절대** 일어나지 않는다.”
  예: **상호배제** — $$\neg(\text{CS}_i \wedge \text{CS}_j)$$
- **Liveness(활성)**: “좋은 일이 **언젠가** 일어난다.”
  예: **기아 없음** — 어떤 스레드가 CS를 **무한히 기다리지 않음**

**Temporal Logic 표기 예**
- Safety: $$\Box \neg \text{Bad}$$
- Liveness: $$\Box ( \text{Request} \Rightarrow \Diamond \text{Grant} )$$

### 교착(Deadlock) — Coffman 4조건

1) 상호배제
2) 점유-대기
3) 비선점
4) **순환대기**
→ 네 가지 모두 참이면 **가능성** 존재.

**Wait-for Graph** 로 검출: 사이클이 있으면 교착.

#### 예방(Prevention) vs 회피(Avoidance) vs 검출(Detection)

- **예방**: 조건 하나를 깨뜨림(예: **순서 규약**으로 순환대기 제거)
- **회피**: **Banker’s Algorithm** 등으로 안전 상태만 허용
- **검출/복구**: 주기적으로 탐색 후 강제 회수/롤백

##### (참고) Banker's Algorithm 핵심 불변식

- 프로세스 i의 최대 요구 `Max[i]`, 현재 할당 `Alloc[i]`, 잔여 필요 `Need[i]=Max[i]-Alloc[i]`,
  사용 가능 자원 `Avail`.
- **안전 시퀀스**가 존재하면 시스템은 안전.

### 기아(Starvation)

- 낮은 우선순위가 **영원히 기회 없음**.
- **에이징**, **공정 큐(티켓락/공정 RW락)**, **`notifyAll` + 정확한 predicate** 로 완화.

### 라이브락(Livelock)

- 교착과 달리 **계속 상태 변화**하지만 **진전 없음**(서로 양보만).
- 해결: **지수 백오프**나 **무작위성** 주입.

### 우선순위 역전(Priority Inversion)

- 낮은 우선순위가 잡은 락 때문에 높은 우선순위가 **대기**하고, 중간 우선순위가 **CPU를 독점**.
- 해결: **Priority Inheritance/Protect**, **임계구역 최소화**.

### 모니터에서의 활성 보장 기법

1) **조건 설계**: “깨울 대상이 실제로 진입 가능”하도록 predicate를 정교화.
2) **`notifyAll` vs `notify`**: 혼합 대기열이면 `notifyAll`로 **헤드 블로킹** 제거(단, 깨어남 폭발 주의).
3) **공정 큐**: 대기 순서를 명시적으로 유지(티켓, deque).
4) **시간 제한**: `wait(timeout)` + 재시도 정책으로 **실패-복구 경로** 제공.
5) **분할/샤딩**: 큰 모니터를 여러 shard로 나눠 **경합**과 **기아 가능성** 완화.

---

## Evaluation (정확성 & 성능 평가)

### 정확성 평가: 불변식·정형기법·테스트

- **불변식(Invariant)**: 모니터의 공유 상태가 항상 만족해야 하는 조건.
  예) BoundedBuffer: $$0 \le \text{count} \le \text{cap}$$
- **유도 규칙**: wait 전에 predicate 거짓, signal 후엔 도달 가능 상태 등.
- **테스트**:
  - **경쟁 주입**: 스레드 수/스케줄 간섭/랜덤 슬립 삽입
  - **데드락 감지**: 타임아웃·스레드 덤프(자바 스레드 덤프, 리눅스 `pstack`)
- **정형 검증(개요)**: TLA+/Spin/CBMC로 상태공간 모델링 → Safety/Liveness 확인

### 성능/활성 계측

#### 핵심 지표

- **평균/백분위 대기시간**(p50/p95/p99)
- **깨움 효율**: `notifyAll` 후 실제 진입률
- **경합률/락 점유시간**(임계구역 길이 분포)
- **스푸리어스 웨이크업 비율**(플랫폼 의존)
- **컨텍스트 스위치/스케줄링 지표**

#### 실측 팁

- **Linux**: `perf sched timehist`, `perf lock`, `bpftrace`(futex/condvar 핫스팟)
- **JVM**: JFR(JDK Flight Recorder)로 모니터 블록/대기 이벤트
- **C++**: 샘플링 프로파일러 + 사용자 계측(TSC, `std::chrono`)

### 실험 설계 원칙

1) **워크로드 고정**: 요청 분포(포아송/벌스트), 데이터 크기, 읽기:쓰기 비율
2) **파라미터 스윕**: 큐 용량, 배치 크기, `notify` vs `notifyAll`, 타임아웃
3) **Warm-up & Steady-state** 분리
4) **반복**(≥30) + **신뢰구간**(bootstrap)
5) **교란 제거**: 터보/온도/배경 작업/GC 영향 통제

---

## 종합 실습

### 실습 A — `notify` vs `notifyAll` 의 활성/성능 트레이드오프

1) BoundedBuffer에서 **생산자/소비자 수**와 **생산/소비 분포**를 바꿔가며
   `notify`와 `notifyAll` 비교(완전한 혼합 대기열이면 `notifyAll` 권장).
2) **지표**: p95 소비자 대기시간, 깨어난 스레드 대비 실제 진입률, 총 컨텍스트 스위치.

### 실습 B — 공정 RW락 vs Reader-Preference

1) `RWLock`의 정책을 **공정(FIFO) 큐**로 변경: `queue`(티켓) 도입.
2) 읽기:쓰기=9:1, 1:1, 1:9 에서 **미스율/지연/처리량** 비교.

### 실습 C — Deadlock 재현과 제거

1) 두 모니터가 서로의 메서드를 내부에서 호출 → **중첩 락**으로 순환대기 만들기.
2) **락 순서 원칙** 또는 **락 결합/분해**로 예방.
3) Wait-for Graph를 로그로 수집해 사이클 시각화.

---

## 부록: 짧은 코드 보관함

### (1) C++ 조건변수 타임아웃 & 스푸리어스 처리 패턴

```cpp
std::mutex m; std::condition_variable cv; bool ready=false;
bool wait_until_ready(std::chrono::milliseconds d){
    std::unique_lock<std::mutex> lk(m);
    return cv.wait_for(lk, d, [&]{ return ready; }); // 반환값으로 성공/타임아웃 구분
}
```

### (2) 자바에서 `notifyAll` 선택 이유 (혼합 대기열)

- `put` 대기자와 `take` 대기자가 **같은 조건변수**를 공유하면 `notify`가 **동종만 깨울** 수 있음 → **진전 없음**.
- 분리된 조건(`notEmpty`, `notFull`)을 쓰거나, 혼합이면 `notifyAll`.

### (3) 수학적 용어 정리

- **Starvation freedom**: $$\Box(\text{Request}_i \Rightarrow \Diamond \text{Grant}_i)$$
- **Bounded waiting**: $$\exists B: \Box(\text{Request}_i \Rightarrow \Diamond_{\le B}\text{Grant}_i)$$
- **Deadlock freedom**: 모든 실행에서 **진전이 영원히 멈추지 않음**.

---

## 요약

- **Monitors(6.7)**: 상호배제와 조건을 한 데 묶은 추상화. 현대(메사) 의미론에서는 **항상 `while(wait)`**.
- **Liveness(6.8)**: 교착/기아/라이브락/우선순위 역전을 분류하고, **예방·회피·검출**/공정 큐/에이징 등으로 보장.
- **Evaluation(6.9)**: **안전 불변식 + 활성 속성**을 명확히 하고, **정형/실측**을 병행. p95/p99 지연, 깨움 효율, 경합률, 컨텍스트 스위치를 체계적으로 관측·튜닝하라.
