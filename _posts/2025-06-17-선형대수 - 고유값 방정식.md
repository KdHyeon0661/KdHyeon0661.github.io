---
layout: post
title: 선형대수 - 고유값 방정식
date: 2025-06-17 20:20:23 +0900
category: 선형대수
---
# 고유값 방정식(특성다항식)

> **한 줄 요약** — 행렬 \(A\)의 **고유값**은 \(\det(A-\lambda I)=0\)의 해이며, 이 **특성다항식**은
> 고유값의 다중도, 대각화 가능성, 안정성, 그래프·제어·물리 응용의 출발점입니다.

---

## 로드맵

- **정의**: \(\chi_A(\lambda)=\det(A-\lambda I)\)
- **계산**: 2×2/3×3 공식, 삼각/블록 행렬, 라플라스 전개, **Faddeev–LeVerrier**(트레이스 기반)
- **성질**: 유사불변성, 비에타(Vieta) 관계(계수 ↔ 고유값), 케일리–해밀턴
- **다중도**: 대수적/기하학적 다중도, 요르단 블록, 대각화 조건
- **응용**: 안정성(제어), 그래프 스펙트럼, 동역학 해, 동음계(양자)
- **수치**: QR 알고리즘, 희소행렬, 민감도, 거르슈고린 원판

---

## 정의와 표기(부호 관례)

### 특성다항식(Characteristic Polynomial)

$$
\boxed{\chi_A(\lambda)=\det(A-\lambda I)=0\;\;\Rightarrow\;\; \lambda:\ \text{고유값}}
$$

- 일부 문헌은 \(\det(\lambda I-A)\)를 사용합니다. 두 정의는 **근(고유값)은 동일**하고, 계수의 부호만 \((-1)^n\) 차이입니다.

### 왜 행렬식?

- \((A-\lambda I)\vec v=\vec 0\) 에 **영벡터 아닌 \(\vec v\)**가 존재하려면,
  선형시스템이 부정/무한해 → **가역 아님** → \(\det(A-\lambda I)=0\).

---

## 빠른 계산법 모음

### 2×2

$$
A=\begin{bmatrix}a&b\\c&d\end{bmatrix}
\ \Rightarrow\
\chi_A(\lambda)=\det\!\begin{bmatrix}a-\lambda&b\\c&d-\lambda\end{bmatrix}
=(a-\lambda)(d-\lambda)-bc
$$
정리하면
$$
\chi_A(\lambda)=\lambda^2-(a+d)\lambda+(ad-bc)
$$
- **\(\operatorname{tr}A=a+d\)**, **\(\det A=ad-bc\)**
- **비에타**: \(\lambda_1+\lambda_2=\operatorname{tr}A\), \(\lambda_1\lambda_2=\det A\)

### 3×3 (사루스/전개)

$$
A=\begin{bmatrix}a&b&c\\ d&e&f\\ g&h&i\end{bmatrix},\quad
\chi_A(\lambda)=\det(A-\lambda I)
$$
사루스 법칙(기억 목적) 또는 1행/1열 전개를 사용. 일반형은 길어지므로 **대칭/특수구조**를 적극 활용.

### 삼각/상삼각/하삼각

- **삼각행렬** \(T\): 대각 원소가 \((t_{11},\dots,t_{nn})\)이면
  $$
  \boxed{\chi_T(\lambda)=\prod_{i=1}^n (t_{ii}-\lambda)}
  $$
  → 고유값은 **대각 원소**.

### 블록 삼각

$$
A=\begin{bmatrix}B&*\\0&C\end{bmatrix}\quad\Rightarrow\quad
\chi_A(\lambda)=\chi_B(\lambda)\,\chi_C(\lambda)
$$

### Faddeev–LeVerrier (트레이스 기반, 임의 \(n\))

- 계수 \(c_k\)를 추적해 \(\chi_A(\lambda)=\lambda^n+c_{n-1}\lambda^{n-1}+\cdots+c_0\) 생성
- 재귀:
  - \(S_k=\operatorname{tr}(A^k)\)
  - \(c_{n-1}=-S_1\)
  - \(c_{n-2}=-(S_2+c_{n-1}S_1)/2\)
  - …
  - 일반적으로
    \(k=1,\dots,n\):
    \(\displaystyle c_{n-k}=-\frac{1}{k}\Big(S_k+c_{n-1}S_{k-1}+ \cdots + c_{n-k+1}S_1\Big)\)
- 장점: **행렬식 전개 없이** \(\operatorname{tr}(A^k)\)로 계산, 상징계산/수치 모두 가능

---

## 핵심 성질

### 유사불변성 (Similarity Invariance)

$$
\chi_{S^{-1}AS}(\lambda)=\det(S^{-1}(A-\lambda I)S)=\det(A-\lambda I)=\chi_A(\lambda)
$$
- **유사한 행렬**은 **같은 고유값(다중도 포함)**을 갖습니다.

### 관계 (계수 ↔ 고유값)

$$
\chi_A(\lambda)=\lambda^n - e_1(\Lambda)\lambda^{n-1} + e_2(\Lambda)\lambda^{n-2} -\cdots +(-1)^n e_n(\Lambda)
$$
- \(\Lambda=(\lambda_1,\dots,\lambda_n)\)
- \(e_k\): 고유값들의 k차 기본대칭다항식
- 특히,
  \(\displaystyle e_1(\Lambda)=\sum_i\lambda_i=\operatorname{tr}A\),
  \(\displaystyle e_n(\Lambda)=\prod_i\lambda_i=\det A\).

### 케일리–해밀턴(Cayley–Hamilton)

$$
\boxed{\chi_A(A)=\vec 0}
$$
- 행렬 \(A\)는 자신의 특성다항식을 **스스로 만족**.
- 응용: \(A^k\)를 낮은 차수의 다항식으로 환원(전개) 가능 → 빠른 거듭제곱/선형재귀/제어.

### 실대칭/허미티안의 실고유값

- \(A=A^\top\) (또는 에르미트)면, 모든 고유값 **실수**, 고유벡터는 **직교기저** 형성.
  → 수치/이론 모두 안정.

---

## 다중도와 대각화

### 대수적 vs 기하학적 다중도

- **대수적 다중도** \(m_a(\lambda)\): \(\chi_A\)에서 \((\lambda-\lambda_i)\)의 지수
- **기하학적 다중도** \(m_g(\lambda)=\dim\ker(A-\lambda I)\)
- 항상 \(1\le m_g(\lambda)\le m_a(\lambda)\).

### 대각화 조건

- **모든 고유값**에 대해 \(m_g(\lambda)=m_a(\lambda)\)이면 **대각화 가능**.
- 그렇지 않으면 **결함(defective)** → 요르단 블록 존재.

### 예: 요르단 블록

$$
J=\begin{bmatrix} \lambda & 1 \\ 0 & \lambda\end{bmatrix}
\quad\Rightarrow\quad
\chi_J(\lambda')=(\lambda-\lambda')^2,\;\; m_a=2,\; m_g=1
$$
- 고유벡터 **하나** → 대각화 불가.

---

## 기하·해석적 의미

- \(\lambda\): 변환 \(A\)가 특정 방향(고유벡터)을 **몇 배로 스케일/회전(복소)** 하는지.
- \(\det A=\prod\lambda_i\): **부피 스케일** (부호는 방향 반전)
- \(\operatorname{tr} A=\sum\lambda_i\): “총 변화량”의 스칼라 요약

---

## 응용 스냅샷

- **연속시간 안정성** \(\dot x=Ax\): \(\Re(\lambda_i)<0\) → 안정
- **이산시간 안정성** \(x_{k+1}=Ax_k\): \(|\lambda_i|<1\)
- **제어**: 원하는 특성다항식으로 **폴 배치**(제어가능 가정)
- **그래프**: 라플라시안 \(\chi_L\)로 연결성/클러스터
- **양자**: \(H\psi=E\psi\) — 에너지 준위 \(E\)
- **신호/진동**: \(K u=\omega^2 M u\) — 고유진동수

---

## 수치 이슈 & 실무 팁

- 고차원에서 **특성다항식 직접 풀기 금지**: 근 찾기 수치불안정.
  → **QR 알고리즘**, **Arnoldi/LOBPCG** 등 사용.
- **거르슈고린 원판**: 고유값 위치 거칠게 추정.
- **스케일링/정규화**로 상태수 개선.
- 대칭/허미티안이면 `eigh`(더 정확·빠름).
- 희소행렬 상위/하위 몇 개 고유값 → `eigsh`/`eigs`.

---

## 손계산 예제

### 2×2 예제 (사용자 제시)

$$
A=\begin{bmatrix}2&1\\1&2\end{bmatrix}
\Rightarrow
\chi_A(\lambda)=(2-\lambda)^2-1=\lambda^2-4\lambda+3
$$
근: \(\lambda=1,3\).
- \(\operatorname{tr}A=4=\lambda_1+\lambda_2\)
- \(\det A=3=\lambda_1\lambda_2\)

### 3×3 상삼각(사용자 제시)

$$
A=\begin{bmatrix}1&2&0\\0&1&0\\0&0&3\end{bmatrix}
\Rightarrow
\chi_A(\lambda)=(1-\lambda)^2(3-\lambda)
$$
- \(\lambda=1\) (대수 2), \(\lambda=3\)
- 상삼각에서 대각이 곧 고유값.
- (1,2) 위치의 2는 **요르단 결합** 가능성을 시사(기하 다중도 1).

### 비대각화 예시

$$
J=\begin{bmatrix}1&1\\0&1\end{bmatrix},\quad
\chi_J(\lambda)=(1-\lambda)^2,\ m_g(1)=1<m_a(1)=2
$$

---

## Python 실전: 특성다항식/검증/알고리즘

> 아래 코드는 **SymPy**(상징), **NumPy**(수치) 기반 예제입니다.

### SymPy로 특성다항식, 고유값, 비에타 검증

```python
import sympy as sp

A = sp.Matrix([[2, 1],
               [1, 2]])
λ = sp.Symbol('λ')

chi = A.charpoly(λ).as_expr()
eigs = A.eigenvals()  # {eigenvalue: algebraic multiplicity}

print("χ_A(λ) =", sp.expand(chi))
print("고유값(다중도):", eigs)

# 비에타: 합=tr, 곱=det

roots = list(eigs.keys())
sum_λ = sum(roots)
prod_λ = sp.prod(roots)
print("합 vs tr(A):", sp.simplify(sum_λ - A.trace()))
print("곱 vs det(A):", sp.simplify(prod_λ - A.det()))
```

### 3×3 상삼각 예제 확인

```python
A = sp.Matrix([[1, 2, 0],
               [0, 1, 0],
               [0, 0, 3]])
λ = sp.Symbol('λ')
chi = A.charpoly(λ).as_expr()
print("χ_A(λ) =", sp.factor(chi))  # (1-λ)^2(3-λ)
print("고유공간 차원(λ=1):", (A - sp.eye(3)).nullspace())  # 기하 다중도 확인
```

### Faddeev–LeVerrier 구현 (NumPy)

```python
import numpy as np

def faddeev_leverrier_charpoly(A):
    """
    Return coefficients [1, c_{n-1}, ..., c_0] for χ_A(λ)=λ^n + c_{n-1} λ^{n-1} + ... + c_0
    """
    n = A.shape[0]
    I = np.eye(n)
    # Traces
    S = []
    Ak = np.eye(n)
    for k in range(1, n+1):
        Ak = Ak @ A  # A^k
        S.append(np.trace(Ak))
    c = np.zeros(n+1, dtype=np.complex128)
    c[0] = 1.0  # leading 1
    # Recurrence: c[n-k]
    for k in range(1, n+1):
        acc = S[k-1]
        for j in range(1, k):
            acc += c[k-j] * S[j-1]
        c[k] = -acc / k
    return c  # length n+1

# Demo

A = np.array([[0, 1, 0],
              [0, 0, 1],
              [-6, 11, -6]], dtype=float)  # companion for (λ-1)(λ-2)(λ-3)
coeffs = faddeev_leverrier_charpoly(A)
print("χ_A(λ) 계수 (λ^3+c2 λ^2+c1 λ+c0):", np.round(coeffs, 6))
```

### 케일리–해밀턴 검증

```python
import sympy as sp

A = sp.Matrix([[2, 1],
               [1, 2]])
λ = sp.Symbol('λ')
chi = A.charpoly(λ).as_expr()  # λ^2 - 4λ + 3

# 계산: λ → A 치환
# = A^2 - 4 A + 3 I

lhs = A**2 - 4*A + 3*sp.eye(2)
print("χ_A(A) =", lhs)  # 영행렬이어야 함
```

### 동역학/제어: 원하는 특성다항식의 companion 행렬

```python
import numpy as np

# 원하는 다항식: λ^3 - 6λ^2 + 11λ - 6 = (λ-1)(λ-2)(λ-3)
# companion 행렬 C 의 고유값 = 다항식의 근

c2, c1, c0 = -6, 11, -6  # 일반형 λ^3 + a2 λ^2 + a1 λ + a0 이면 a2=-6, a1=11, a0=-6

C = np.array([[0, 1, 0],
              [0, 0, 1],
              [-c0, -c1, -c2]], dtype=float)  # companion 표준형
print("companion A:\n", C)

w, _ = np.linalg.eig(C)
print("고유값(폴):", np.sort(np.round(w, 6)))  # 1, 2, 3
```

---

## 근사와 경계: 거르슈고린 원판

- 각 행 \(i\)에 대해 중심 \(a_{ii}\), 반지름 \(R_i=\sum_{j\ne i}|a_{ij}|\)
- **모든 고유값**은 \(\bigcup_i \{z: |z-a_{ii}|\le R_i\}\) 안에 존재

```python
import numpy as np

A = np.array([[4, -1, 0],
              [2,  3, 1],
              [0, -2, 2]], dtype=float)
w = np.linalg.eigvals(A)

centers = np.diag(A)
radii = np.sum(np.abs(A), axis=1) - np.abs(centers)
print("거르슈고린 원판 (center, radius):")
for c, r in zip(centers, radii):
    print(f"({c:.2f}, {r:.2f})")
print("실제 고유값:", np.round(w, 4))
```

---

## 자주 하는 질문(FAQ)

**Q1. 왜 \(\chi_A(\lambda)=\det(\lambda I-A)\)를 쓰는 글도 많나요?**
A. 근(고유값)은 동일합니다. 정의간 차이는 다항식 계수의 부호만 \((-1)^n\) 다릅니다.

**Q2. 중복 근이면 대각화 불가인가요?**
A. **반드시**는 아닙니다. 중복 근(대수적 다중도)>1이어도, 기하학적 다중도가 같다면 대각화 가능합니다.
예: \(A=I\)는 \((\lambda-1)^n\)이지만 대각화 가능(이미 대각).

**Q3. 실수행렬인데 복소 고유값이 가능한가요?**
A. 가능하며 **켤레쌍**으로 나타납니다(계수 실수다항식의 근 성질).

**Q4. 큰 행렬은 특성다항식을 직접 구해도 되나요?**
A. 실무에선 비추천. 수치불안정·비용 큼. **QR 알고리즘/희소 부분분해** 사용을 권장합니다.

---

## 학습 점검 문제

1) \(A=\begin{bmatrix}3&2\\0&1\end{bmatrix}\) 의 \(\chi_A(\lambda)\)를 구하고, \(\operatorname{tr}A,\det A\)와 비에타를 확인하라.
2) \(A=\begin{bmatrix}1&1\\0&1\end{bmatrix}\) 의 \(m_a(1),m_g(1)\)를 구하고 대각화 가능 여부를 판단하라.
3) 블록삼각 \(A=\begin{bmatrix}B&*\\0&C\end{bmatrix}\) 가 있을 때 \(\chi_A\)를 \(\chi_B,\chi_C\)로 표현하라.
4) Faddeev–LeVerrier로 임의 3×3 행렬의 \(\chi_A\)를 손으로 계산해보라(트레이스 사용).

---

## 요약

- **정의**: \(\chi_A(\lambda)=\det(A-\lambda I)\)의 근이 **고유값**
- **성질**: 유사불변, \(\sum\lambda_i=\operatorname{tr}A\), \(\prod\lambda_i=\det A\), **케일리–해밀턴**
- **대각화**: \(m_g(\lambda)=m_a(\lambda)\) 모두 성립 시
- **계산**: 2×2/3×3은 공식, 일반 \(n\)은 **Faddeev–LeVerrier**·수치고윳값
- **응용**: 안정성·제어·그래프·물리·진동 등 전 분야의 공통 언어
