---
layout: post
title: MFC - 레이아웃 & 리사이즈
date: 2025-08-26 20:25:23 +0900
category: MFC
---
# 레이아웃 & 리사이즈: CDialog 자동 크기 조절, Anchor 패턴, DPI 대응 (실전 총정리 · 스니펫 대량)

이 글은 **MFC 대화상자(Dialog) 기반 UI**에서 “**리사이즈하면 컨트롤이 자연스럽게 따라오는**” 레이아웃을 만드는 전 과정을 정리합니다.  
핵심 주제는 다음입니다.

- **기본기**: `WM_SIZE`, `OnSize`, `DeferWindowPos`, 최소 크기(`WM_GETMINMAXINFO`)
- **Anchor 패턴**: 컨트롤별로 **상하좌우 고정/늘어남**을 선언 → 자동 배치
- **비율/그리드/플로우** 레이아웃
- **DPI 대응(Per-Monitor V2)**: `WM_DPICHANGED`, DLU→PX, 폰트/이미지/열 너비 스케일
- **도구**: `MapDialogRect`, `GetDpiForWindow`, `BeginDeferWindowPos`, `CDialogEx`
- **재사용 래퍼/헬퍼**: **CAnchors**(권장), **CDpiHelper**, 퍼시스턴스, 예외 상황

모든 코드는 **복사-붙여넣기** 하면 바로 사용할 수 있도록 독립적으로 구성했습니다.

---

## 0) 큰 그림

- **기본 원리**: 대화상자 크기 변경 시 **`WM_SIZE` → `OnSize()`**에서 각 컨트롤의 새 위치/크기를 계산해 **`SetWindowPos/MoveWindow`** 로 반영.
- **문제**: 컨트롤이 많아질수록 좌표 계산이 복잡.
- **해결(Anchor 패턴)**: 컨트롤별로 **고정할 변**(Left/Right/Top/Bottom)과 **늘어날 축**(가로/세로)을 선언 → **초기 기준 Rect**와 현재 대화상자 크기의 차이를 이용해 자동 배치.
- **DPI 대응**: 창을 다른 모니터로 이동 시 DPI가 바뀌면 **폰트/좌표/이미지** 모두 재스케일해야 함 → `WM_DPICHANGED`를 처리해 **제시된 새 Rect**로 재배치 + 치수 재계산.

---

## 1) 준비: 대화상자 골격 & 리사이즈 메시지 훅

### 1-1. 리소스/컨트롤 상정
- `IDD_MAIN` 대화상자 안에 아래 컨트롤이 있다고 가정합니다.
  - `IDC_EDIT_LOG` : 멀티라인 로그(좌·우·하 **늘어남**)
  - `IDC_BTN_OK` : 우하단 고정
  - `IDC_BTN_CANCEL` : 우하단 고정(OK 왼쪽)
  - `IDC_GROUP_FILTER` : 상단 고정(가로 **늘어남**)
  - `IDC_COMBO_FILTER` : 상단 고정(우측으로 **늘어남**)
  - `IDC_LIST_FILES` : 중앙~하단 리스트(가로/세로 **늘어남**)

### 1-2. 대화상자 클래스 뼈대

```cpp
// MainDlg.h
class CMainDlg : public CDialogEx
{
public:
    CMainDlg() : CDialogEx(IDD_MAIN) {}

protected:
    virtual BOOL OnInitDialog() override;
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
    DECLARE_MESSAGE_MAP()

private:
    CRect m_rcInitClient; // 초기 클라이언트 크기
    bool  m_inited = false;

    void LayoutNow(int cx, int cy); // 현재 크기에 맞춰 레이아웃 적용
};
```

```cpp
// MainDlg.cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_WM_SIZE()
    ON_WM_GETMINMAXINFO()
END_MESSAGE_MAP()

BOOL CMainDlg::OnInitDialog()
{
    CDialogEx::OnInitDialog();

    // 초기 클라이언트 크기 저장
    GetClientRect(&m_rcInitClient);

    m_inited = true;
    return TRUE;
}

void CMainDlg::OnGetMinMaxInfo(MINMAXINFO* lpMMI)
{
    // 최소 크기 지정(대화상자 단위 → 픽셀, 여기서는 픽셀 직접 하드코딩 예시)
    lpMMI->ptMinTrackSize.x = 640;
    lpMMI->ptMinTrackSize.y = 420;
    CDialogEx::OnGetMinMaxInfo(lpMMI);
}

void CMainDlg::OnSize(UINT nType, int cx, int cy)
{
    CDialogEx::OnSize(nType, cx, cy);
    if (!m_inited || nType == SIZE_MINIMIZED) return;
    LayoutNow(cx, cy);
}
```

> 아직 `LayoutNow`는 비어있습니다. 다음 절에서 **Anchor 패턴**으로 꽉 채웁니다.

---

## 2) Anchor 패턴(핵심): 선언 → 자동 배치

### 2-1. 아이디어
- 처음에 컨트롤의 **초기 Rect**(대화상자 클라이언트 기준)를 모두 저장
- 각 컨트롤에 대해 **Anchor 플래그**를 선언
  - `A_LEFT/A_RIGHT/A_TOP/A_BOTTOM` : 해당 변을 **고정**한다는 의미
  - 두 변이 모두 고정이면 **그 축의 길이는 변하지 않음**  
    한 변만 고정이면 **반대 변이 이동** → 길이 변화  
    양쪽 모두 고정이 아니고 “늘어남”을 원하면 **폭/높이를 비율로 재계산**(옵션)
- 리사이즈 시 **deltaX = (cx - initW)**, **deltaY = (cy - initH)** 를 이용해 새 좌표 계산

### 2-2. 재사용 가능한 헬퍼 클래스 **CAnchors**

```cpp
// Anchors.h
#pragma once
#include <map>

enum AnchorFlags : UINT {
    A_LEFT   = 1 << 0,
    A_RIGHT  = 1 << 1,
    A_TOP    = 1 << 2,
    A_BOTTOM = 1 << 3,
    A_HFILL  = 1 << 4, // 가로 늘림(비율/여백 유지)
    A_VFILL  = 1 << 5  // 세로 늘림
};

struct AnchorItem {
    UINT   id;
    UINT   flags;
    CRect  rcInit; // 초기 위치/크기(클라이언트 기준)
};

class CAnchors {
public:
    void Capture(CWnd* pDlg, UINT id, UINT flags) {
        CWnd* w = pDlg->GetDlgItem(id);
        ASSERT(w);
        CRect r; w->GetWindowRect(&r); pDlg->ScreenToClient(&r);
        AnchorItem it{ id, flags, r };
        m_items[id] = it;
    }

    void Apply(CWnd* pDlg, const CRect& rcInitClient, const CRect& rcNowClient) {
        const int dx = rcNowClient.Width()  - rcInitClient.Width();
        const int dy = rcNowClient.Height() - rcInitClient.Height();

        HDWP hdwp = BeginDeferWindowPos((int)m_items.size());
        for (auto& kv : m_items) {
            const AnchorItem& it = kv.second;
            CRect r = it.rcInit;

            // 가로(Left/Right/HFILL)
            if ((it.flags & A_LEFT) && (it.flags & A_RIGHT)) {
                // 양쪽 고정 → 폭만 그대로, 좌표는 Left 고정, Right = Left + width + dx
                r.right += dx;
            } else if (it.flags & A_RIGHT) {
                // 오른쪽 고정 → 전체가 오른쪽으로 dx만큼 이동
                r.OffsetRect(dx, 0);
            } else if (it.flags & A_HFILL) {
                // 비율형 늘림(간단 버전: 오른쪽만 늘림)
                r.right += dx;
            } else {
                // 기본: Left 고정
            }

            // 세로(Top/Bottom/VFILL)
            if ((it.flags & A_TOP) && (it.flags & A_BOTTOM)) {
                r.bottom += dy;
            } else if (it.flags & A_BOTTOM) {
                r.OffsetRect(0, dy);
            } else if (it.flags & A_VFILL) {
                r.bottom += dy;
            } else {
                // 기본: Top 고정
            }

            // 배치
            CWnd* w = pDlg->GetDlgItem(it.id);
            hdwp = DeferWindowPos(hdwp, w->GetSafeHwnd(), nullptr,
                                  r.left, r.top, r.Width(), r.Height(),
                                  SWP_NOZORDER | SWP_NOACTIVATE);
        }
        EndDeferWindowPos(hdwp);
    }

private:
    std::map<UINT, AnchorItem> m_items;
};
```

### 2-3. **CAnchors** 사용법

```cpp
// MainDlg.h
#include "Anchors.h"
class CMainDlg : public CDialogEx
{
    // ...
    CAnchors m_anchors;
};

// MainDlg.cpp
BOOL CMainDlg::OnInitDialog()
{
    CDialogEx::OnInitDialog();
    GetClientRect(&m_rcInitClient);

    // Anchor 선언
    m_anchors.Capture(this, IDC_GROUP_FILTER, A_LEFT|A_RIGHT|A_TOP);
    m_anchors.Capture(this, IDC_COMBO_FILTER, A_RIGHT|A_TOP);
    m_anchors.Capture(this, IDC_LIST_FILES,   A_LEFT|A_RIGHT|A_TOP|A_BOTTOM);
    m_anchors.Capture(this, IDC_EDIT_LOG,     A_LEFT|A_RIGHT|A_BOTTOM|A_TOP);
    m_anchors.Capture(this, IDC_BTN_OK,       A_RIGHT|A_BOTTOM);
    m_anchors.Capture(this, IDC_BTN_CANCEL,   A_RIGHT|A_BOTTOM);

    m_inited = true;
    return TRUE;
}

void CMainDlg::LayoutNow(int cx, int cy)
{
    CRect rcNow(0,0,cx,cy);
    m_anchors.Apply(this, m_rcInitClient, rcNow);
}
```

> 이 패턴 하나로 **대부분의 폼**이 깔끔하게 동작합니다.  
> 고정/늘림 규칙만 바꿔주면 복잡한 레이아웃도 유지보수 가능.

---

## 3) 비율/그리드/플로우 레이아웃(선택 사항)

### 3-1. **비율 배치**(Proportional)
- 창이 커져도 **여백 비율**과 **컨트롤 사이 비율**을 유지하고 싶을 때.

```cpp
// 간단 비율 헬퍼(열 2개, 좌:우 = 3:2 비율)
void LayoutProportional(CWnd* pDlg, UINT idLeft, UINT idRight, const CRect& rcInit, const CRect& rcNow)
{
    const double k = 3.0 / 5.0; // Left 폭 비율
    int wL = int(rcNow.Width() * k);
    int wR = rcNow.Width() - wL - 10; // 10px 간격 예시

    CRect rL(10, 10, 10 + wL, rcNow.Height()/2);
    CRect rR(rL.right + 10, 10, rL.right + 10 + wR, rcNow.Height()/2);

    pDlg->GetDlgItem(idLeft )->MoveWindow(rL);
    pDlg->GetDlgItem(idRight)->MoveWindow(rR);
}
```

### 3-2. **그리드 레이아웃**
- 행×열 **격자**에 컨트롤 배치, 칸 크기 변화에 맞추어 이동/리사이즈.

```cpp
struct Cell { UINT id; int row, col, rowSpan, colSpan; };
class CGridLayout {
public:
    CGridLayout(int rows, int cols, int pad=6) : rows(rows), cols(cols), pad(pad) {}
    void Add(UINT id, int r,int c,int rs=1,int cs=1){ cells.push_back({id,r,c,rs,cs}); }
    void Apply(CWnd* dlg, const CRect& rc) {
        int cellW = (rc.Width()  - pad*(cols+1)) / cols;
        int cellH = (rc.Height() - pad*(rows+1)) / rows;
        HDWP hdwp = BeginDeferWindowPos((int)cells.size());
        for (auto& x : cells) {
            CRect r(pad + x.col*(cellW+pad),
                    pad + x.row*(cellH+pad),
                    pad + x.col*(cellW+pad) + x.colSpan*cellW + (x.colSpan-1)*pad,
                    pad + x.row*(cellH+pad) + x.rowSpan*cellH + (x.rowSpan-1)*pad);
            auto* w = dlg->GetDlgItem(x.id);
            hdwp = DeferWindowPos(hdwp, w->GetSafeHwnd(), nullptr, r.left, r.top, r.Width(), r.Height(),
                                  SWP_NOZORDER|SWP_NOACTIVATE);
        }
        EndDeferWindowPos(hdwp);
    }
private:
    int rows, cols, pad;
    std::vector<Cell> cells;
};
```

### 3-3. **플로우 레이아웃**
- 버튼/태그 같은 **가변 폭 요소**를 좌→우, 줄바꿈으로 흐르게 배치.

```cpp
void FlowLayout(CWnd* dlg, const std::vector<UINT>& ids, const CRect& rc, int gap=6)
{
    int x = rc.left + gap, y = rc.top + gap, lineH = 0;
    for (auto id : ids) {
        CWnd* w = dlg->GetDlgItem(id);
        CRect r; w->GetWindowRect(&r); dlg->ScreenToClient(&r);
        int wW = r.Width(), wH = r.Height();
        if (x + wW + gap > rc.right) { x = rc.left + gap; y += lineH + gap; lineH = 0; }
        w->MoveWindow(x, y, wW, wH);
        x += wW + gap; lineH = max(lineH, wH);
    }
}
```

---

## 4) DPI 대응 (Per-Monitor V2 완전 정리)

### 4-1. 왜 필요한가?
- **고해상도/멀티 모니터**에서 DPI가 다르면 **픽셀=물리 크기**가 달라집니다.
- 폰트/아이콘/여백/열 너비가 작거나 크게 보이는 문제 → **DPI 인식 앱**으로 만들어야 함.

### 4-2. 매니페스트(필수)
- 프로젝트 매니페스트에 **Per Monitor V2** DPI 인식을 켭니다.

```xml
<!-- app.manifest (요지) -->
<application xmlns="urn:schemas-microsoft-com:asm.v3">
  <windowsSettings>
    <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true/pm</dpiAware>
  </windowsSettings>
</application>
```

> Visual Studio 템플릿의 “고 DPI 인식” 옵션을 확인하세요.

### 4-3. DPI 헬퍼

```cpp
// DpiHelper.h
#pragma once
struct CDpiHelper {
    UINT dpiX = 96, dpiY = 96;

    void Init(HWND h) {
        if (h) {
            dpiX = GetDpiForWindow(h);
            dpiY = dpiX; // 일반적으로 동일
        } else {
            HDC s = ::GetDC(nullptr);
            dpiX = GetDeviceCaps(s, LOGPIXELSX);
            dpiY = GetDeviceCaps(s, LOGPIXELSY);
            ::ReleaseDC(nullptr, s);
        }
    }
    int ScaleX(int px) const { return MulDiv(px, dpiX, 96); }
    int ScaleY(int px) const { return MulDiv(px, dpiY, 96); }

    // Dialog Units(DLU) → PX
    static void DluToPx(HWND hDlg, int dxDLU, int dyDLU, int& outX, int& outY) {
        RECT r{0,0,dxDLU,dyDLU};
        MapDialogRect(hDlg, &r);
        outX = r.right; outY = r.bottom;
    }
};
```

### 4-4. 대화상자에서의 DPI 처리 절차

1) 초기 DPI 기록  
2) `WM_DPICHANGED` 수신 → **새 DPI**로 업데이트  
3) Windows가 제공하는 **추천 Rect**로 **`SetWindowPos`**  
4) 폰트/컨트롤/여백 **모두 재스케일** → `LayoutNow` 재호출

```cpp
// MainDlg.h
class CMainDlg : public CDialogEx {
    // ...
    afx_msg LRESULT OnDpiChanged(WPARAM w, LPARAM l);
    CDpiHelper m_dpi;
    DECLARE_MESSAGE_MAP()
};
```

```cpp
// MainDlg.cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_WM_SIZE()
    ON_WM_GETMINMAXINFO()
    ON_MESSAGE(WM_DPICHANGED, &CMainDlg::OnDpiChanged)
END_MESSAGE_MAP()

BOOL CMainDlg::OnInitDialog()
{
    CDialogEx::OnInitDialog();
    m_dpi.Init(m_hWnd);
    GetClientRect(&m_rcInitClient);

    // 예: 폰트 스케일
    CFont* f = GetFont();
    LOGFONT lf{}; f->GetLogFont(&lf);
    lf.lfHeight = -m_dpi.ScaleY(9); // 9pt 정도
    m_fontScaled.CreateFontIndirect(&lf);
    SetFont(&m_fontScaled); // 자식에게 전파할지 여부는 디자인에 따라

    // 캡처/앵커는 "픽셀 좌표" 기준으로 진행(초기 기준은 96dpi 환산)
    // 필요하면 초기 rcInit을 96dpi로 정규화 후, 현재 DPI에 맞춰 역스케일 하는 전략도 가능

    m_inited = true;
    return TRUE;
}

LRESULT CMainDlg::OnDpiChanged(WPARAM w, LPARAM l)
{
    const UINT newDpi = HIWORD(w); // X=LOWORD, Y=HIWORD (Win10+는 동일 가정)
    m_dpi.dpiX = m_dpi.dpiY = newDpi;

    // 시스템이 권장하는 새 창 위치/크기 적용
    auto prcNew = (RECT*)l; // 제안된 작업영역
    SetWindowPos(nullptr, prcNew->left, prcNew->top,
                 prcNew->right - prcNew->left, prcNew->bottom - prcNew->top,
                 SWP_NOZORDER | SWP_NOACTIVATE);

    // 폰트/치수 재스케일
    LOGFONT lf{}; GetFont()->GetLogFont(&lf);
    lf.lfHeight = -m_dpi.ScaleY(9);
    m_fontScaled.DeleteObject();
    m_fontScaled.CreateFontIndirect(&lf);
    SetFont(&m_fontScaled);

    // 컨트롤 개별 리스케일이 필요하다면 여기에서 적용
    // ex) 리스트 컬럼 폭, 아이콘 이미지, 커스텀 그리드 셀의 패딩 등

    // 레이아웃 다시
    CRect rc; GetClientRect(&rc);
    LayoutNow(rc.Width(), rc.Height());
    return 0;
}
```

> `WM_DPICHANGED`는 **창이 다른 DPI 모니터로 이동 중일 때도** 여러 번 들어옵니다.  
> 재스케일이 빈번히 발생할 수 있으므로 **불필요한 재계산/재그리기 최소화**가 중요합니다.

### 4-5. DLU(Dialog Units) 이해 & 활용
- 리소스(대화상자) 좌표는 **DLU**(폰트 의존 단위).  
- 런타임 픽셀 좌표로 변환하려면 **`MapDialogRect`** 사용.
- 레이아웃 계산을 **DLU 기반**으로 작성해두면 폰트가 바뀌어도 비교적 안정.

```cpp
int px, py; CDpiHelper::DluToPx(m_hWnd, 50, 14, px, py);
// px, py를 간격/버튼 높이 기준으로 사용할 수 있음
```

---

## 5) 성능/안정성 팁

1. 배치할 컨트롤이 많으면 **`BeginDeferWindowPos/DeferWindowPos/EndDeferWindowPos`** 사용.  
2. 리사이즈 중 깜빡임을 줄이려면 **더블 버퍼** 또는 `WS_CLIPCHILDREN|WS_CLIPSIBLINGS` 확인.  
3. 레이아웃 계산은 **상수 시간(O(n))** 유지(복잡한 탐색/문자열 처리 금지).  
4. `OnSize`에서 **Minimized**는 건너뛰기.  
5. 최소 크기(`WM_GETMINMAXINFO`)를 지정해 **컨트롤 겹침 방지**.  
6. **고해상도(200%+ DPI)**에서 아이콘/이미지 리소스는 **배수 스케일** 리소스 준비(또는 벡터).  
7. `OnDpiChanged`에서 **이미지 리스트**(`CImageList`), **리본/툴바** 아이콘도 재스케일.

---

## 6) 종합 예제: Anchor + DPI + MinSize 완성본

```cpp
// MainDlg.h
#pragma once
#include "Anchors.h"
#include "DpiHelper.h"

class CMainDlg : public CDialogEx
{
public:
    CMainDlg() : CDialogEx(IDD_MAIN) {}

protected:
    virtual BOOL OnInitDialog() override;
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
    afx_msg LRESULT OnDpiChanged(WPARAM, LPARAM);
    DECLARE_MESSAGE_MAP()

private:
    bool  m_inited = false;
    CRect m_rcInitClient;
    CAnchors  m_anchors;
    CDpiHelper m_dpi;
    CFont m_fontScaled;

    void LayoutNow(int cx, int cy);
};

// MainDlg.cpp
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_WM_SIZE()
    ON_WM_GETMINMAXINFO()
    ON_MESSAGE(WM_DPICHANGED, &CMainDlg::OnDpiChanged)
END_MESSAGE_MAP()

BOOL CMainDlg::OnInitDialog()
{
    CDialogEx::OnInitDialog();

    m_dpi.Init(m_hWnd);
    GetClientRect(&m_rcInitClient);

    // 폰트 스케일(예: 9pt)
    LOGFONT lf{}; GetFont()->GetLogFont(&lf);
    lf.lfHeight = -m_dpi.ScaleY(9);
    m_fontScaled.CreateFontIndirect(&lf);
    SetFont(&m_fontScaled);

    // Anchor 지정
    m_anchors.Capture(this, IDC_GROUP_FILTER, A_LEFT|A_RIGHT|A_TOP);
    m_anchors.Capture(this, IDC_COMBO_FILTER, A_RIGHT|A_TOP);
    m_anchors.Capture(this, IDC_LIST_FILES,   A_LEFT|A_RIGHT|A_TOP|A_BOTTOM);
    m_anchors.Capture(this, IDC_EDIT_LOG,     A_LEFT|A_RIGHT|A_BOTTOM|A_TOP);
    m_anchors.Capture(this, IDC_BTN_OK,       A_RIGHT|A_BOTTOM);
    m_anchors.Capture(this, IDC_BTN_CANCEL,   A_RIGHT|A_BOTTOM);

    m_inited = true;
    return TRUE;
}

void CMainDlg::OnGetMinMaxInfo(MINMAXINFO* lpMMI)
{
    // 최소 크기(96dpi 기준 640x420 → 현재 DPI에 맞춰 스케일)
    lpMMI->ptMinTrackSize.x = m_dpi.ScaleX(640);
    lpMMI->ptMinTrackSize.y = m_dpi.ScaleY(420);
    CDialogEx::OnGetMinMaxInfo(lpMMI);
}

void CMainDlg::OnSize(UINT nType, int cx, int cy)
{
    CDialogEx::OnSize(nType, cx, cy);
    if (!m_inited || nType == SIZE_MINIMIZED) return;
    LayoutNow(cx, cy);
}

void CMainDlg::LayoutNow(int cx, int cy)
{
    CRect rcNow(0,0,cx,cy);
    m_anchors.Apply(this, m_rcInitClient, rcNow);
}

LRESULT CMainDlg::OnDpiChanged(WPARAM w, LPARAM l)
{
    const UINT newDpi = HIWORD(w);
    m_dpi.dpiX = m_dpi.dpiY = newDpi;

    auto prcNew = (RECT*)l;
    SetWindowPos(nullptr, prcNew->left, prcNew->top,
                 prcNew->right - prcNew->left, prcNew->bottom - prcNew->top,
                 SWP_NOZORDER | SWP_NOACTIVATE);

    // 폰트 재스케일
    LOGFONT lf{}; GetFont()->GetLogFont(&lf);
    lf.lfHeight = -m_dpi.ScaleY(9);
    m_fontScaled.DeleteObject();
    m_fontScaled.CreateFontIndirect(&lf);
    SetFont(&m_fontScaled);

    // 레이아웃 재적용
    CRect rc; GetClientRect(&rc);
    LayoutNow(rc.Width(), rc.Height());
    return 0;
}
```

---

## 7) 응용: 리스트뷰 열 폭/DPI, 버튼 행/열 정렬, 도킹 흉내

### 7-1. 리스트뷰 열 폭 자동화
```cpp
void ResizeListColumns(CListCtrl& lv, const std::vector<int>& baseWidths96dpi, UINT dpi)
{
    int i=0;
    for (int w96 : baseWidths96dpi) {
        int w = MulDiv(w96, dpi, 96);
        lv.SetColumnWidth(i++, w);
    }
}
```

### 7-2. 버튼 행/열 정렬(그리드)
```cpp
void AlignButtonsGrid(CWnd* dlg, const std::vector<UINT>& ids, const CRect& rc, int cols, int gap, int dpi)
{
    int gapPx = MulDiv(gap, dpi, 96);
    int w = (rc.Width()  - gapPx*(cols+1)) / cols;
    int rows = (int)std::ceil(ids.size() / (double)cols);
    int h = (rc.Height() - gapPx*(rows+1)) / rows;

    HDWP hdwp = BeginDeferWindowPos((int)ids.size());
    int idx=0;
    for (int r=0; r<rows; ++r) {
        for (int c=0; c<cols && idx<(int)ids.size(); ++c, ++idx) {
            CRect cell(rc.left + gapPx + c*(w+gapPx),
                       rc.top  + gapPx + r*(h+gapPx),
                       rc.left + gapPx + c*(w+gapPx) + w,
                       rc.top  + gapPx + r*(h+gapPx) + h);
            CWnd* wBtn = dlg->GetDlgItem(ids[idx]);
            hdwp = DeferWindowPos(hdwp, wBtn->m_hWnd, nullptr, cell.left, cell.top, cell.Width(), cell.Height(),
                                  SWP_NOZORDER|SWP_NOACTIVATE);
        }
    }
    EndDeferWindowPos(hdwp);
}
```

### 7-3. 간이 도킹(좌/우 패널 고정 + 중앙 채우기)
```cpp
void LayoutDockLike(CWnd* dlg, UINT idLeftPane, UINT idRightPane, UINT idCenter, const CRect& rc, int leftW, int rightW)
{
    CRect rL(rc.left, rc.top, rc.left + leftW, rc.bottom);
    CRect rR(rc.right - rightW, rc.top, rc.right, rc.bottom);
    CRect rC(rL.right, rc.top, rR.left, rc.bottom);

    dlg->GetDlgItem(idLeftPane )->MoveWindow(rL);
    dlg->GetDlgItem(idRightPane)->MoveWindow(rR);
    dlg->GetDlgItem(idCenter   )->MoveWindow(rC);
}
```

---

## 8) 흔한 문제 & 해결

| 증상 | 원인 | 해결 |
|---|---|---|
| 리사이즈 시 깜빡임 | 배치가 잦고 배경 전체 재그리기 | `WS_CLIPCHILDREN` + DeferWindowPos 사용, 더블버퍼(Owner-Draw) |
| 컨트롤 겹침 | 최소 크기 미지정/앵커 충돌 | `WM_GETMINMAXINFO`로 MinSize 지정, Anchor 설계 재검토 |
| DPI 바꾸면 글자 잘림 | 폰트/패딩 미스케일 | `WM_DPICHANGED`에서 폰트/열 너비/패딩 재계산 |
| 스케일 후 위치 틀어짐 | rcInit 기준/현재 기준 혼동 | **초기 기준(클라이언트 Rect)**을 한 번만 저장하고 항상 delta로 계산 |
| 텍스트 줄바꿈 오작동 | DLU 기반 설계 미흡 | `MapDialogRect`로 DLU→PX, 여백/최소 폭을 DLU 기반으로 정의 |

---

## 9) 테스트 체크리스트

- [ ] 100% / 125% / 150% / 200% DPI에서 폰트/여백/아이콘 정상?  
- [ ] 모니터 A↔B **드래그 이동** 중 `WM_DPICHANGED` 다회 호출에도 매끄럽게 동작?  
- [ ] 최소 크기 이하로 줄일 때 컨트롤 겹치지 않음?  
- [ ] 리스트/그리드 등 **대량 컨트롤**에서도 리사이즈 프레임 드랍 없음?  
- [ ] **키보드 접근성**(TabOrder/Default 버튼) 유지?  
- [ ] 고해상도에서 **툴팁/컨텍스트 메뉴 좌표**도 DPI 반영?

---

## 10) 요약

- **Anchor 패턴 + DeferWindowPos**만으로도 **90%의 폼 레이아웃** 문제를 해결.  
- **Per-Monitor V2 + WM_DPICHANGED** 처리로 **멀티 모니터** 환경에서 선명하고 일관된 UI 제공.  
- **DLU→픽셀, 폰트/아이콘 스케일, 최소 크기, 성능 최적화**까지 챙기면 **프로급 품질**.