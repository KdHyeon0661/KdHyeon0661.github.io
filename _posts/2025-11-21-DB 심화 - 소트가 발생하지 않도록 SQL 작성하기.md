---
layout: post
title: DB 심화 - 소트가 발생하지 않도록 SQL 작성하기
date: 2025-11-21 22:25:23 +0900
category: DB 심화
---
# 소트가 발생하지 않도록 SQL 작성하기

> 목표
> - 실행계획에 `SORT ORDER BY`, `SORT UNIQUE`, `SORT GROUP BY`, `SORT JOIN`, `WINDOW SORT`가 **잡히지 않도록** SQL과 인덱스를 설계/작성
> - **인덱스가 만들어주는 자연 순서**·**해시 집계**·**세미/안티 조인**·**STOPKEY(Top-N)**·**키셋 페이지네이션** 등 실전 패턴 총정리
> - 모든 기법은 **실행계획/세션 통계**로 **사후 검증**하는 루틴까지 포함

---

## 0) 실습 스키마(간단)

```sql
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  sales_dt  DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
);

-- 자주 쓰는 인덱스들
CREATE INDEX ix_sales_prod_dt       ON f_sales(prod_id, sales_dt);
CREATE INDEX ix_sales_dt_amount_desc ON f_sales(sales_dt, amount DESC);
CREATE INDEX ix_sales_amount_desc    ON f_sales(amount DESC);
```

검증 도우미:

```sql
-- 마지막 실행 계획/통계 확인
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE'));

-- 세션 단위 소트/워크에어리어 지표(전/후 비교)
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat# = ms.stat#
WHERE  sn.name IN ('sorts (memory)','sorts (disk)',
                   'workarea executions - optimal',
                   'workarea executions - onepass',
                   'workarea executions - multipass');
```

---

## 1) `ORDER BY` 소트 제거 — **인덱스로 정렬을 대체**

핵심은 **정렬키·방향**과 **인덱스 선두/정렬방향**을 **일치**시키는 것.

### 단순 정렬

```sql
-- Before : SORT ORDER BY
SELECT sales_id, amount
FROM   f_sales
ORDER  BY amount DESC;

-- After  : 인덱스 DESC로 자연 순서 획득 (SORT 제거)
-- 준비: CREATE INDEX ix_sales_amount_desc ON f_sales(amount DESC);
SELECT /*+ INDEX_DESC(f_sales ix_sales_amount_desc) */
       sales_id, amount
FROM   f_sales
ORDER  BY amount DESC;
```
**계획 기대**: `INDEX FULL SCAN (DESCENDING)` → `SORT ORDER BY` 없음.

> 주의: `INDEX FAST FULL SCAN`(IFFS)은 **정렬 보장하지 않음**. **FULL SCAN**/`INDEX[_DESC]`가 필요.

### 복합 정렬 (여러 컬럼/방향)

```sql
-- 요구: ORDER BY sales_dt DESC, amount DESC
-- 인덱스: (sales_dt, amount DESC)
CREATE INDEX ix_sales_dt_amt_desc ON f_sales(sales_dt, amount DESC);

SELECT /*+ INDEX_DESC(f_sales ix_sales_dt_amt_desc) */
       sales_id, sales_dt, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01' AND sales_dt < DATE '2025-03-01'
ORDER  BY sales_dt DESC, amount DESC;
```
- **정렬키와 동일한 순서·방향**으로 인덱스 설계
- WHERE로 **선두 컬럼 범위**가 들어오면 인덱스 **Range Scan** + **자연 정렬** 유지

### 부분 정렬 + Top-N (STOPKEY)

```sql
-- 상위 100건만 필요 → 전체 정렬 불필요
SELECT sales_id, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01' AND sales_dt < DATE '2025-03-01'
ORDER  BY amount DESC
FETCH FIRST 100 ROWS ONLY;
-- PLAN: SORT ORDER BY STOPKEY (힙 유지) 또는 인덱스 DESC + STOPKEY
```
인덱스가 있으면 **SORT 자체 제거**가 가능:
```sql
SELECT /*+ INDEX_DESC(f_sales ix_sales_amount_desc) */
       sales_id, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01' AND sales_dt < DATE '2025-03-01'
FETCH FIRST 100 ROWS ONLY;
```

### 페이지네이션(OFFSET 회피) — **키셋 페이지네이션(Seek)**

OFFSET은 보통 **대량 정렬 + 불필요 스캔**. 대신 **마지막 키** 기준으로 다음 페이지를 **찾아가기**.

```sql
-- 정렬 키: (sales_dt DESC, amount DESC, sales_id DESC)
CREATE INDEX ix_seek ON f_sales(sales_dt, amount DESC, sales_id DESC);

-- 첫 페이지
SELECT /*+ INDEX_DESC(f_sales ix_seek) */
       sales_id, sales_dt, amount
FROM   f_sales
ORDER  BY sales_dt DESC, amount DESC, sales_id DESC
FETCH FIRST 50 ROWS ONLY;

-- 다음 페이지: 마지막 로우의 (dt, amount, id)가 (:dt0, :amt0, :id0)
SELECT /*+ INDEX_DESC(f_sales ix_seek) */
       sales_id, sales_dt, amount
FROM   f_sales
WHERE  (sales_dt, amount, sales_id) < (:dt0, :amt0, :id0)   -- 핵심!
ORDER  BY sales_dt DESC, amount DESC, sales_id DESC
FETCH  FIRST 50 ROWS ONLY;
```
**효과**: 인덱스 **Range Scan**만으로 **정렬 미발생**·**불필요 스캔 최소화**.

---

## 2) `DISTINCT`/`UNION` 소트 제거 — **세미조인/해시 집계/UNION ALL**

정렬 기반 `SORT UNIQUE`를 피하려면 **집합 의미를 보존**하면서 **정렬/중복 제거를 회피**.

### `DISTINCT` 대신 `EXISTS`(세미조인)

```sql
-- Before: DISTINCT가 SORT UNIQUE 유발
SELECT DISTINCT p.prod_id
FROM   d_product p
JOIN   f_sales  s ON s.prod_id = p.prod_id
WHERE  p.category = 'ELEC';

-- After: EXISTS (세미조인) → 보통 SORT UNIQUE 불필요
SELECT /*+ SEMIJOIN */
       p.prod_id
FROM   d_product p
WHERE  p.category = 'ELEC'
AND    EXISTS ( SELECT 1
                FROM f_sales s
                WHERE s.prod_id = p.prod_id );
```
**포인트**: 결과가 “존재 여부”일 때 `EXISTS`로 **중복 제거 자체를 회피**.

### `UNION` → `UNION ALL` (+필요 시 사후 집계)

```sql
-- Before
SELECT prod_id FROM f_sales WHERE amount >= 10000
UNION
SELECT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-10';

-- After (요건상 중복 허용 or 상류에서 제거 가능)
SELECT prod_id FROM f_sales WHERE amount >= 10000
UNION ALL
SELECT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-10';
```
정말 중복 제거가 필요하면 **해시 집계**로 사후 처리(여전히 정렬 없이 가능):
```sql
SELECT /*+ USE_HASH_AGGREGATION */
       prod_id
FROM (
  SELECT prod_id FROM f_sales WHERE amount >= 10000
  UNION ALL
  SELECT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-10'
)
GROUP BY prod_id;  -- HASH GROUP BY → SORT UNIQUE 회피
```

### `COUNT(DISTINCT col)` 대체(가능할 때)

- 비즈니스가 **근사치 허용** → `APPROX_COUNT_DISTINCT(col)` (12c+) : 정렬 불필요
- 또는 설계상 **중복 자체를 사전에 차단**(부분 유니크 인덱스/로직) → 질의에서 DISTINCT 불필요

---

## 3) `GROUP BY` 소트 제거 — **해시 집계 / NOSORT**
### 해시 집계 우선

```sql
-- Before: SORT GROUP BY가 선택될 수 있음
SELECT prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP  BY prod_id;

-- 해시 집계 유도(상황 비교용)
SELECT /*+ USE_HASH_AGGREGATION */
       prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP  BY prod_id;
```
**계획 기대**: `HASH GROUP BY` → 정렬 없음.

### 입력이 이미 정렬/그룹 상태면 `GROUP BY NOSORT`

인덱스가 **(prod_id, …)** 순으로 데이터를 공급하면 오라클이 **NOSORT** 그룹화를 할 수 있음.
```sql
-- (prod_id, sales_dt) 인덱스가 있고, 범위 스캔으로 prod_id 묶음이 순서대로 올라옴
SELECT /*+ INDEX(f_sales ix_sales_prod_dt) */
       prod_id, COUNT(*), SUM(amount)
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi
GROUP  BY prod_id;

-- PLAN에서 'GROUP BY NOSORT' 혹은 SORT GROUP BY가 사라지는지 확인
```
> 버전/통계에 따라 해석이 다를 수 있으니 XPLAN으로 확인 필수.

---

## 4) `SORT JOIN` 제거 — **NL/해시 조인 + 인덱스**

`USE_MERGE`(Sort-Merge Join)는 **양 입력 정렬** 필요. 대신 **NL/해시**로 우회.

### NL + 인덱스

```sql
-- Before: SMJ → SORT JOIN
SELECT /*+ USE_MERGE(s p) */ COUNT(*)
FROM   f_sales s JOIN d_product p ON p.prod_id = s.prod_id;

-- After: NL + 인덱스 → SORT JOIN 없음
SELECT /*+ ORDERED USE_NL(s p) INDEX(s ix_sales_prod_dt) */
       COUNT(*)
FROM   d_product p
JOIN   f_sales   s ON s.prod_id = p.prod_id
WHERE  p.category = 'ELEC';
```

### 해시 조인

```sql
SELECT /*+ USE_HASH(s p) */
       COUNT(*)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id;
```
- **메모리 충분**하면 해시가 TEMP 정렬 없이 끝남(스필 시 TEMP 사용은 있으나 ‘정렬’이 아님).
- 대형 조인에서 **정렬을 없애고 균형 잡힌 분배**가 가능.

---

## 5) 윈도우 정렬(`WINDOW SORT`) 회피/최소화

완전 제거는 어려운 경우가 많지만, **추가 소트 없이** 처리되게 만들 수 있다.

### 입력을 **이미 PARTITION+ORDER 순서**로 공급

```sql
-- 목표: PARTITION BY prod_id ORDER BY sales_dt
-- 인덱스: (prod_id, sales_dt)
SELECT /*+ INDEX(f_sales ix_sales_prod_dt) */
       prod_id, sales_dt,
       SUM(amount) OVER (
         PARTITION BY prod_id ORDER BY sales_dt
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       ) AS run_sum
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi;
```
**효과**: 실행계획에서 별도 `WINDOW SORT`가 생략되거나, 메모리만으로 진행.

### “그룹별 Top-1/Top-K”를 **소트 없이** 구하는 패턴
#### (1) `MIN/MAX` + 인덱스 **MIN/MAX 스캔**

```sql
-- 각 상품의 '가장 이른 판매일'
-- 인덱스: (prod_id, sales_dt)
SELECT prod_id, MIN(sales_dt) AS first_dt
FROM   f_sales
GROUP  BY prod_id;  -- HASH GROUP BY (정렬 없음)

-- 또는 상관서브쿼리 + INDEX MIN STOPKEY
SELECT s.prod_id, s.sales_id, s.sales_dt
FROM   f_sales s
WHERE  s.sales_dt = (
  SELECT MIN(s2.sales_dt) FROM f_sales s2 WHERE s2.prod_id = s.prod_id
);
```
- `MIN`은 인덱스 선두에서 **STOPKEY**로 **첫 키만** 집어오므로 정렬 불필요.

#### (2) `KEEP (DENSE_RANK FIRST/LAST)` 주의

`KEEP`은 내부적으로 정렬/랭크가 필요할 수 있다. 대신 **(1)** 방식이 인덱스 친화적.

---

## 6) 표현식 정렬 회피 — **함수기반 인덱스(FBI)**

컬럼 가공으로 `ORDER BY SUBSTR(col,1,3)`처럼 쓰면 **정렬**이 필요. **FBI**로 자연순서 획득.

```sql
-- 표현식 정렬 요구: ORDER BY SUBSTR(brand,1,3)
CREATE INDEX ix_dp_brand3 ON d_product(SUBSTR(brand,1,3));

SELECT /*+ INDEX(d_product ix_dp_brand3) */
       *
FROM   d_product
ORDER  BY SUBSTR(brand,1,3);
-- FBI 덕분에 정렬 생략 가능(계획 확인)
```

---

## 7) 인덱스만으로 해결하는 **각종 패턴**

### “최신 N건(최근순)”

```sql
-- 인덱스 (sales_dt DESC, sales_id DESC)
CREATE INDEX ix_sales_recent ON f_sales(sales_dt DESC, sales_id DESC);

SELECT /*+ INDEX_DESC(f_sales ix_sales_recent) */
       sales_id, sales_dt, amount
FROM   f_sales
FETCH FIRST 50 ROWS ONLY;   -- 정렬 없이 STOPKEY
```

### “범위 + 정렬” 동시 충족

```sql
-- WHERE sales_dt BETWEEN ... AND ...  AND  ORDER BY amount DESC
-- 인덱스: (sales_dt, amount DESC)
SELECT /*+ INDEX(f_sales ix_sales_dt_amount_desc) */
       sales_id, sales_dt, amount
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi
ORDER  BY amount DESC;   -- SORT 제거
```

### “중복 제거 없이 존재 여부/최초 한 건만”

```sql
-- EXISTS + STOPKEY (= ROWNUM 1)  → 정렬·중복제거 없음
SELECT /*+ INDEX(f_sales ix_sales_prod_dt) */
       1
FROM   f_sales
WHERE  prod_id = :p
AND    sales_dt >= :lo AND sales_dt < :hi
AND    ROWNUM = 1;
```

---

## 8) “불필요한 ORDER BY” 제거

- **서브쿼리/인라인 뷰**의 `ORDER BY`는 **상위 쿼리가 재정렬**할 수 있어 **의미 없음**.
- 보고/화면에서 **정렬이 필요하지 않은 API**는 **ORDER BY 자체를 생략**.
- 집계/카운트 API에 붙어있는 **습관적 ORDER BY**를 제거.

```sql
-- 안티 패턴: COUNT에도 ORDER BY
SELECT COUNT(*) FROM f_sales WHERE sales_dt >= :lo AND sales_dt < :hi
ORDER BY amount;  -- 불필요 → 제거!
```

---

## 9) 측정 루틴(전/후 비교)

```sql
-- 1) 지표 스냅샷
CREATE GLOBAL TEMPORARY TABLE gtt_stat_snap (name VARCHAR2(64), val NUMBER) ON COMMIT PRESERVE ROWS;

INSERT INTO gtt_stat_snap
SELECT sn.name, ms.value
FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
WHERE  sn.name IN ('sorts (memory)','sorts (disk)',
                   'workarea executions - optimal',
                   'workarea executions - onepass',
                   'workarea executions - multipass');

-- 2) 대상 SQL 실행

-- 3) 델타 확인
SELECT a.name, (b.val - a.val) AS delta
FROM   gtt_stat_snap a
JOIN  (SELECT sn.name, ms.value val
       FROM   v$mystat ms JOIN v$statname sn ON sn.stat#=ms.stat#
       WHERE  sn.name IN ('sorts (memory)','sorts (disk)',
                          'workarea executions - optimal',
                          'workarea executions - onepass',
                          'workarea executions - multipass')) b
ON a.name = b.name
ORDER BY 1;

-- 4) 실행계획
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +NOTE +PREDICATE +ALIAS'));
```

---

## 10) 체크리스트 — “소트가 안 생기는” SQL을 위한 10계명

1. **정렬키·방향**과 일치하는 **인덱스**로 **자연 정렬**을 얻어라. (`INDEX[_DESC]`, IFFS 회피)
2. **Top-N/페이지네이션**은 **STOPKEY/키셋 페이지네이션**으로 처리하라.
3. `DISTINCT`는 **EXISTS/SEMI JOIN**이나 **UNION ALL + 해시 집계**로 대체하라.
4. `GROUP BY`는 **해시 집계** 또는 **NOSORT**(입력 정렬)로 유도하라.
5. `SMJ` 대신 **NL/해시**를 쓰고 **인덱스 범위 스캔**으로 조인 순서를 설계하라.
6. 윈도우 함수는 **(PARTITION, ORDER) 순서**로 **이미 읽히게** 만들어 `WINDOW SORT`를 없애거나 최소화하라.
7. **표현식 정렬**은 **함수기반 인덱스**로 바꿔라.
8. **불필요 ORDER BY**를 제거하라(서브쿼리/카운트/집계).
9. 인덱스는 **정렬 제거용**과 **액세스/선택도**를 함께 고려해 **컬럼 순서/방향**을 설계하라.
10. 모든 변경은 **XPLAN + V$ 통계**로 **정량 검증**하라.

---

## 11) 종합 예제 — “정렬 제로”로 바꾸기

### 요구

- 2025-02 월 매출 중 **금액 상위 100건** + **상품 카테고리 = 'ELEC'**
- 정렬, DISTINCT, SMJ 없이 만들기

**Before(정렬 유발)**
```sql
SELECT s.sales_id, s.prod_id, s.amount
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'
AND    s.sales_dt >= DATE '2025-02-01' AND s.sales_dt < DATE '2025-03-01'
ORDER  BY s.amount DESC
FETCH  FIRST 100 ROWS ONLY;
-- PLAN: SORT ORDER BY STOPKEY (큰 입력이면 여전히 TEMP 스필)
```

**After(정렬 제거 경로)**
```sql
-- 1) 인덱스: (amount DESC), (prod_id, sales_dt)
-- 2) NL로 드라이빙: 카테고리 → prod_id → f_sales(amount DESC, STOPKEY)
CREATE INDEX ix_dp_cat_prod ON d_product(category, prod_id);
-- amount DESC 인덱스는 앞서 생성: ix_sales_amount_desc

SELECT /*+ LEADING(p) USE_NL(s) INDEX_DESC(s ix_sales_amount_desc) */
       s.sales_id, s.prod_id, s.amount
FROM   d_product p
JOIN   f_sales   s ON s.prod_id = p.prod_id
WHERE  p.category = 'ELEC'
AND    s.sales_dt >= DATE '2025-02-01' AND s.sales_dt < DATE '2025-03-01'
FETCH  FIRST 100 ROWS ONLY;
-- 기대: INDEX DESC + STOPKEY, SORT 없음, TEMP 없음
```

**검증**
```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST +NOTE'));
-- SORT 라인 부재 확인, TempSpc=0

-- 세션 통계: sorts(disk)/workarea onepass/multipass 증가 없음 확인
```

---

## 12) 안티 패턴 → 리팩터링 요약

| 안티 패턴 | 결과 | 리팩터링 |
|---|---|---|
| 습관적 `ORDER BY` | 불필요 소트·TEMP | 제거 |
| `UNION` 남발 | `SORT UNIQUE` | `UNION ALL` + 해시 집계/요건 재검토 |
| `DISTINCT` 남발 | 정렬/중복제거 비용 | `EXISTS`/세미조인 |
| 표현식 정렬(가공 컬럼) | 인덱스 미사용 → 정렬 | 함수기반 인덱스 |
| OFFSET 페이지네이션 | 대량 스캔+정렬 | 키셋 페이지네이션 |
| SMJ 강제 | SORT JOIN 2회 | NL/해시 전환 + 인덱스 |
| GROUP BY 소트 | TEMP 스필 | 해시 집계 또는 NOSORT |

---

### 한 줄 요약

정렬은 **인덱스/조인/집계 설계로 “미리” 없애는 것**이 최선이다.
SQL을 **인덱스가 만들어주는 순서**와 **해시 집계/세미조인**에 **맞춰 작성**하면 `SORT`는 자연히 사라진다.
항상 **실행계획과 V$ 통계**로 **정량 검증**하라.
