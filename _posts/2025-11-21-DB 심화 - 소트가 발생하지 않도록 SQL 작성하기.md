---
layout: post
title: DB 심화 - 소트가 발생하지 않도록 SQL 작성하기
date: 2025-11-21 22:25:23 +0900
category: DB 심화
---
# 소트가 발생하지 않도록 SQL 작성하기

정렬(SORT) 작업은 CPU와 메모리를 많이 소모하며, 특히 대용량 데이터 처리 시 성능 저하의 주요 원인입니다. 이 문서에서는 실행 계획에서 `SORT ORDER BY`, `SORT UNIQUE`, `SORT GROUP BY`, `SORT JOIN`, `WINDOW SORT` 작업이 나타나지 않도록 SQL과 인덱스를 설계하는 실용적인 방법을 소개합니다.

## 실습 스키마

```sql
CREATE TABLE d_product (
  prod_id   NUMBER PRIMARY KEY,
  category  VARCHAR2(16) NOT NULL,
  brand     VARCHAR2(16) NOT NULL
);

CREATE TABLE f_sales (
  sales_id  NUMBER PRIMARY KEY,
  prod_id   NUMBER NOT NULL REFERENCES d_product(prod_id),
  sales_dt  DATE   NOT NULL,
  qty       NUMBER NOT NULL,
  amount    NUMBER(12,2) NOT NULL
);

-- 자주 쓰는 인덱스들
CREATE INDEX ix_sales_prod_dt       ON f_sales(prod_id, sales_dt);
CREATE INDEX ix_sales_dt_amount_desc ON f_sales(sales_dt, amount DESC);
CREATE INDEX ix_sales_amount_desc    ON f_sales(amount DESC);
```

## ORDER BY 소트 제거

### 인덱스를 활용한 자연 정렬 획득

가장 기본적인 방법은 정렬 키와 방향에 맞는 인덱스를 생성하고 활용하는 것입니다.

```sql
-- Before: SORT ORDER BY 발생
SELECT sales_id, amount
FROM   f_sales
ORDER  BY amount DESC;

-- After: 인덱스를 통한 자연 정렬 (SORT 제거)
SELECT /*+ INDEX_DESC(f_sales ix_sales_amount_desc) */
       sales_id, amount
FROM   f_sales
ORDER  BY amount DESC;
```

**주의사항**: `INDEX FAST FULL SCAN`은 정렬을 보장하지 않습니다. 정렬이 필요한 경우 `INDEX FULL SCAN` 또는 `INDEX RANGE SCAN`을 사용해야 합니다.

### 복합 정렬 처리

여러 컬럼의 조합으로 정렬해야 하는 경우, 인덱스의 컬럼 순서와 정렬 방향을 정확히 일치시켜야 합니다.

```sql
-- 요구: ORDER BY sales_dt DESC, amount DESC
CREATE INDEX ix_sales_dt_amt_desc ON f_sales(sales_dt, amount DESC);

SELECT /*+ INDEX_DESC(f_sales ix_sales_dt_amt_desc) */
       sales_id, sales_dt, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01' 
AND    sales_dt < DATE '2025-03-01'
ORDER  BY sales_dt DESC, amount DESC;
```

### Top-N 쿼리 최적화

상위 N개 행만 필요한 경우, 전체 데이터를 정렬하지 않고 인덱스를 통해 효율적으로 처리할 수 있습니다.

```sql
-- 상위 100건만 필요한 경우
SELECT /*+ INDEX_DESC(f_sales ix_sales_amount_desc) */
       sales_id, amount
FROM   f_sales
WHERE  sales_dt >= DATE '2025-02-01' 
AND    sales_dt < DATE '2025-03-01'
FETCH FIRST 100 ROWS ONLY;
```

### 키셋 페이지네이션 (Seek Method)

OFFSET을 사용하는 전통적인 페이지네이션은 대량의 데이터를 정렬하고 스킵하는 비효율적인 작업을 수반합니다. 키셋 페이지네이션은 마지막으로 읽은 행의 값을 기준으로 다음 페이지를 검색합니다.

```sql
-- 정렬 키: (sales_dt DESC, amount DESC, sales_id DESC)
CREATE INDEX ix_seek ON f_sales(sales_dt, amount DESC, sales_id DESC);

-- 첫 페이지
SELECT /*+ INDEX_DESC(f_sales ix_seek) */
       sales_id, sales_dt, amount
FROM   f_sales
ORDER  BY sales_dt DESC, amount DESC, sales_id DESC
FETCH FIRST 50 ROWS ONLY;

-- 다음 페이지: 마지막 행의 값을 기준
SELECT /*+ INDEX_DESC(f_sales ix_seek) */
       sales_id, sales_dt, amount
FROM   f_sales
WHERE  (sales_dt, amount, sales_id) < (:dt0, :amt0, :id0)
ORDER  BY sales_dt DESC, amount DESC, sales_id DESC
FETCH FIRST 50 ROWS ONLY;
```

## DISTINCT/UNION 소트 제거

### EXISTS를 활용한 중복 제거 회피

결과 집합의 존재 여부만 중요할 때는 `DISTINCT` 대신 `EXISTS`를 사용할 수 있습니다.

```sql
-- Before: DISTINCT로 인한 SORT UNIQUE 발생
SELECT DISTINCT p.prod_id
FROM   d_product p
JOIN   f_sales  s ON s.prod_id = p.prod_id
WHERE  p.category = 'ELEC';

-- After: EXISTS 사용 (세미조인)
SELECT p.prod_id
FROM   d_product p
WHERE  p.category = 'ELEC'
AND    EXISTS (
  SELECT 1
  FROM f_sales s
  WHERE s.prod_id = p.prod_id
);
```

### UNION ALL과 해시 집계의 조합

`UNION`은 암시적으로 중복 제거를 수행하여 정렬을 유발합니다. 중복을 허용할 수 있거나 다른 방식으로 처리할 수 있다면 `UNION ALL`을 사용하세요.

```sql
-- Before: UNION으로 인한 정렬
SELECT prod_id FROM f_sales WHERE amount >= 10000
UNION
SELECT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-10';

-- After: UNION ALL + 해시 집계
SELECT /*+ USE_HASH_AGGREGATION */
       prod_id
FROM (
  SELECT prod_id FROM f_sales WHERE amount >= 10000
  UNION ALL
  SELECT prod_id FROM f_sales WHERE sales_dt >= DATE '2025-02-10'
)
GROUP BY prod_id;
```

## GROUP BY 소트 제거

### 해시 집계 활용

`HASH GROUP BY`는 정렬 없이 그룹화를 수행할 수 있습니다.

```sql
-- 해시 집계로 SORT GROUP BY 회피
SELECT /*+ USE_HASH_AGGREGATION */
       prod_id, COUNT(*), SUM(amount)
FROM   f_sales
GROUP BY prod_id;
```

### NOSORT 그룹화

입력 데이터가 이미 그룹화 키로 정렬된 상태라면, 옵티마이저는 `GROUP BY NOSORT`를 사용할 수 있습니다.

```sql
-- prod_id로 정렬된 인덱스를 활용
SELECT /*+ INDEX(f_sales ix_sales_prod_dt) */
       prod_id, COUNT(*), SUM(amount)
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi
GROUP BY prod_id;
```

## SORT JOIN 제거

Sort-Merge Join은 양쪽 입력을 정렬해야 하므로 `SORT JOIN` 작업이 발생합니다. 대신 NL 조인이나 해시 조인을 사용할 수 있습니다.

### NL 조인과 인덱스 활용

```sql
-- NL 조인으로 SORT JOIN 회피
SELECT /*+ ORDERED USE_NL(s p) INDEX(s ix_sales_prod_dt) */
       COUNT(*)
FROM   d_product p
JOIN   f_sales   s ON s.prod_id = p.prod_id
WHERE  p.category = 'ELEC';
```

### 해시 조인 활용

```sql
-- 해시 조인으로 정렬 없이 조인
SELECT /*+ USE_HASH(s p) */
       COUNT(*)
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id;
```

## 윈도우 함수 정렬 최소화

### 인덱스를 통한 입력 데이터 정렬 보장

윈도우 함수의 `PARTITION BY`와 `ORDER BY` 절에 사용된 컬럼 순서로 인덱스를 생성하면, 별도의 정렬 작업을 최소화할 수 있습니다.

```sql
-- 인덱스: (prod_id, sales_dt)
SELECT /*+ INDEX(f_sales ix_sales_prod_dt) */
       prod_id, sales_dt,
       SUM(amount) OVER (
         PARTITION BY prod_id 
         ORDER BY sales_dt
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       ) AS run_sum
FROM   f_sales
WHERE  sales_dt >= :lo AND sales_dt < :hi;
```

### 그룹별 Top-N without Sort

```sql
-- 각 상품의 최초 판매일 (정렬 없이)
SELECT prod_id, MIN(sales_dt) AS first_dt
FROM   f_sales
GROUP BY prod_id;
```

## 함수기반 인덱스를 활용한 표현식 정렬 회피

컬럼에 함수를 적용한 정렬은 일반적으로 인덱스를 사용할 수 없어 정렬 작업이 필요합니다. 함수기반 인덱스를 생성하면 이 문제를 해결할 수 있습니다.

```sql
-- 표현식 정렬 요구: ORDER BY SUBSTR(brand,1,3)
CREATE INDEX ix_dp_brand3 ON d_product(SUBSTR(brand,1,3));

SELECT /*+ INDEX(d_product ix_dp_brand3) */
       *
FROM   d_product
ORDER BY SUBSTR(brand,1,3);
```

## 불필요한 ORDER BY 제거

많은 경우 SQL에 불필요한 `ORDER BY` 절이 포함되어 있습니다. 특히 다음과 같은 경우를 확인하세요:

1. **서브쿼리/인라인 뷰의 ORDER BY**: 상위 쿼리가 재정렬할 수 있어 의미가 없을 수 있습니다.
2. **집계 함수와 함께 사용된 ORDER BY**: `COUNT`, `SUM` 등의 결과는 단일 행이므로 정렬이 필요하지 않습니다.
3. **중간 결과 정렬**: 최종 결과만 정렬되어야 하며, 중간 처리 단계의 정렬은 불필요할 수 있습니다.

```sql
-- 불필요한 ORDER BY 예시
SELECT COUNT(*) 
FROM f_sales 
WHERE sales_dt >= :lo AND sales_dt < :hi
ORDER BY amount;  -- 제거 필요
```

## 성능 측정과 검증

변경 사항의 효과를 검증하기 위해 실행 계획과 세션 통계를 확인하는 것이 중요합니다.

```sql
-- 실행 계획 확인
SELECT * FROM TABLE(
  DBMS_XPLAN.DISPLAY_CURSOR(
    NULL,NULL,'ALLSTATS LAST +PREDICATE +NOTE'
  )
);

-- 소트 관련 통계 확인
SELECT sn.name, ms.value
FROM   v$mystat ms 
JOIN   v$statname sn ON sn.stat# = ms.stat#
WHERE  sn.name IN (
  'sorts (memory)',
  'sorts (disk)',
  'workarea executions - optimal',
  'workarea executions - onepass',
  'workarea executions - multipass'
);
```

## 종합 예제: 정렬 작업 제로 구현

### 요구사항
- 2025년 2월 매출 중 'ELEC' 카테고리 상품의 금액 상위 100건 조회
- 정렬 작업 없이 처리

### 기존 방식 (정렬 발생)
```sql
SELECT s.sales_id, s.prod_id, s.amount
FROM   f_sales s
JOIN   d_product p ON p.prod_id = s.prod_id
WHERE  p.category = 'ELEC'
AND    s.sales_dt >= DATE '2025-02-01' 
AND    s.sales_dt < DATE '2025-03-01'
ORDER  BY s.amount DESC
FETCH FIRST 100 ROWS ONLY;
```

### 최적화된 방식 (정렬 제거)
```sql
-- 필요한 인덱스
CREATE INDEX ix_dp_cat_prod ON d_product(category, prod_id);

-- 정렬 없이 Top-N 처리
SELECT /*+ LEADING(p) USE_NL(s) INDEX_DESC(s ix_sales_amount_desc) */
       s.sales_id, s.prod_id, s.amount
FROM   d_product p
JOIN   f_sales   s ON s.prod_id = p.prod_id
WHERE  p.category = 'ELEC'
AND    s.sales_dt >= DATE '2025-02-01' 
AND    s.sales_dt < DATE '2025-03-01'
FETCH FIRST 100 ROWS ONLY;
```

## 결론

정렬 작업을 제거하거나 최소화하는 것은 SQL 성능 최적화의 핵심 요소입니다. 다음 원칙을 기억하세요:

1. **인덱스 설계가 우선**: 쿼리의 정렬 요구사항을 미리 예측하고, 해당 순서로 인덱스를 설계하세요.
2. **연산 방식의 선택**: `DISTINCT` 대신 `EXISTS`, `UNION` 대신 `UNION ALL`, Sort-Merge Join 대신 NL/해시 조인을 고려하세요.
3. **불필요한 작업 제거**: 정렬이 실제로 필요한지 검토하고, 불필요한 `ORDER BY` 절을 제거하세요.
4. **현대적 패턴 적용**: OFFSET 기반 페이지네이션 대신 키셋 페이지네이션을 사용하세요.
5. **지속적인 검증**: 모든 최적화는 실행 계획과 성능 측정을 통해 효과를 검증해야 합니다.

정렬 작업은 인덱스, 조인 전략, 집계 방식을 적절히 설계함으로써 대부분 제거하거나 최소화할 수 있습니다. 데이터 양이 증가할수록 이러한 최적화의 효과는 더욱 커집니다.