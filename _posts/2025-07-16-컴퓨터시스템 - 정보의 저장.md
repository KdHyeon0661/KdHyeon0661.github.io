---
layout: post
title: 컴퓨터시스템 - 정보의 저장
date: 2025-07-16 19:20:23 +0900
category: 컴퓨터시스템
---
# 정보의 저장: 컴퓨터 시스템에서 데이터는 어떻게 보관되는가?

## 0. 개요 — 저장이 곧 성능·신뢰성·보안이다

사용자가 누르는 “저장” 버튼 뒤에서는 다음의 층위가 작동한다.

1. **표현**: 비트/바이트/워드/진법/부호/부동/텍스트 인코딩
2. **물리 장치**: DRAM/SSD/HDD/ROM, 에러 모델(ECC), 수명/웨어
3. **논리 구조**: 파일시스템(블록, 인덱스, 저널링, 캐시), 경로/권한/메타데이터
4. **가상 메모리**: 주소 변환, 페이지/프레임, TLB, 페이지 캐시, `mmap`
5. **데이터 공학**: 직렬화(엔디안/정렬/패딩), 압축/중복제거, 무결성/암호화
6. **일관성**: WAL/rename-atomic, `fsync/fdatasync`, 스냅샷/백업

이 글은 각 층위마다 **표·그림·코드**를 제시한다.

---

## 1. 정보 저장의 기본 단위: 비트·바이트·워드

- **비트(bit)**: 0/1
- **니블(nibble)**: 4비트(16진 한 자리)
- **바이트(byte)**: 8비트(최소 주소 단위)
- **워드(word)**: 아키텍처 기본 연산 폭(32b/64b 등)

### 1.1 범위와 조합 수

$$
\text{n비트가 표현 가능한 값의 수} = 2^n
$$

- 8비트(1바이트): \(2^8=256\) → 0..255
- 64비트 부호 없는 정수: 0..\(2^{64}-1\)

### 1.2 정렬(alignment)과 패딩(padding)

CPU는 보통 **타입의 자연 경계**(예: 4바이트 정수는 4의 배수 주소)에 정렬된 접근을 빠르게 처리한다. 구조체는 멤버 사이에 **패딩**을 끼워 전체 정렬을 맞춘다.

```c
#include <stdio.h>
#include <stdint.h>
struct A { uint8_t a; uint32_t b; uint16_t c; }; // 비효율적 배치
struct B { uint32_t b; uint16_t c; uint8_t a; }; // 재배치로 패딩 감소
int main(){ printf("A=%zu, B=%zu\n", sizeof(struct A), sizeof(struct B)); }
```

---

## 2. 수 체계: 이진·16진·8진, 그리고 2의 보수

### 2.1 자리값

$$
( b_{k-1}\ldots b_1 b_0 )_2 \;=\; \sum_{i=0}^{k-1} b_i 2^i
$$

### 2.2 2의 보수(two’s complement)

부호 있는 n비트 정수의 해석:

$$
v = -b_{n-1}\cdot 2^{n-1} + \sum_{i=0}^{n-2} b_i 2^i \qquad \in [-2^{n-1}, 2^{n-1}-1]
$$

- 음수 만들기 = **비트 반전 + 1**
- 덧셈 하나로 +/−을 모두 처리 가능 → 하드웨어 단순화

### 2.3 오버플로(모듈러 산술)

$$
(x + y) \bmod 2^n
$$

C/C++에서 **부호 있는 정수 오버플로는 UB**. 안전이 요구되면 **부호 없는에서 연산 후 검사** 또는 포화산술 사용.

---

## 3. 텍스트: ASCII·UTF-8·UTF-16

| 인코딩 | 단위 | 장점 | 주의 |
|---|---|---|---|
| ASCII | 7비트 | 역사적 표준 | 영문 전용 |
| UTF-8 | 1~4바이트 가변 | ASCII 호환, 웹 표준 | “문자 길이 ≠ 바이트 길이” |
| UTF-16 | 2/4바이트 | 동아시아 환경 선호 사례 | 엔디안/BOM/서러게이트 |

```python
s = "A가á"              # 'a' + 결합 악센트
print(len(s), len(s.encode("utf-8")))  # 코드포인트 수 vs 바이트 수
```

> 문자열 슬라이스를 바이트 오프셋으로 처리하면 **문자 경계가 깨질 수 있음**.

---

## 4. 엔디안: 메모리 바이트 순서

| 주소→ | 0x00 | 0x01 | 0x02 | 0x03 |
|---|---:|---:|---:|---:|
| 리틀(0x12345678) | 78 | 56 | 34 | 12 |
| 빅(0x12345678) | 12 | 34 | 56 | 78 |

- x86/x64: **리틀 엔디안**
- 네트워크 바이트 순서: **빅 엔디안**

```c
#include <stdint.h>
#include <stdio.h>
static int is_little(){ uint16_t x=0x0102; return *(uint8_t*)&x==0x02; }
static uint32_t bswap32(uint32_t x){
    return (x<<24)|((x<<8)&0x00FF0000)|((x>>8)&0x0000FF00)|(x>>24);
}
int main(){ printf("%s\n", is_little()?"LE":"BE"); }
```

**팁**: 파일/프로토콜 직렬화는 항상 **바이트 순서 명시**(예: “빅엔디안 32비트”).

---

## 5. 부동소수점: IEEE 754의 비트 해석

| 형식 | 부호 | 지수 | 가수 | 바이어스 |
|---|---:|---:|---:|---:|
| float(32) | 1 | 8 | 23 | 127 |
| double(64)| 1 | 11| 52 | 1023 |

정규화:

$$
(-1)^s \cdot (1.f)_2 \cdot 2^{(e - \text{bias})}
$$

서브노멀:

$$
(-1)^s \cdot (0.f)_2 \cdot 2^{(1 - \text{bias})}
$$

특수: `e=all1, f=0 → ±∞`, `f≠0 → NaN`.
비교/정밀도는 **ULP/epsilon** 기준으로.

---

## 6. 물리 장치: DRAM·SSD·HDD·ROM

| 장치 | 셀/원리 | 지연/대역폭 | 특성 |
|---|---|---|---|
| DRAM | 축전기 전하 | ns/수~수십 GB/s | 휘발성, 주기적 리프레시 |
| SSD(NAND) | 부유 게이트 전압 | μs/수 GB/s | 비휘발성, 블록 지우기 단위, 수명(PE cycle) |
| HDD | 자기 회전판 | ms/수백 MB/s | 대용량·저가, 랜덤 느림 |
| ROM/Flash ROM | 마스크/플래시 | 고정 | 펌웨어/부팅

### 6.1 SSD 내부 구조(요지)

- 최소 쓰기: **페이지**(예: 16KB)
- 지우기 단위: **블록**(수십/수백 페이지)
- **FTL**(논리→물리 맵핑), **웨어 레벨링**, **가비지 컬렉션**
- **WAF**(Write Amplification Factor) ↓를 위해 **정렬/배치 쓰기/트림** 활용

---

## 7. 에러와 보호: 패리티·CRC·ECC

- **패리티**: 1비트 오류 검출
- **CRC**: 다항식 나눗셈 기반, 프레임/디스크에서 널리 사용
- **ECC(SECDED)**: DRAM/SSD 컨트롤러에서 **1비트 정정, 2비트 검출**

```c
// CRC-32(폴리 0xEDB88320) 테이블 없는 느린 예시
uint32_t crc32(const uint8_t* p, int n){
    uint32_t c = 0xFFFFFFFFu;
    for(int i=0;i<n;i++){
        c ^= p[i];
        for(int b=0;b<8;b++)
            c = (c&1)? (c>>1) ^ 0xEDB88320u : (c>>1);
    }
    return ~c;
}
```

---

## 8. 파일시스템: 블록·인덱스·저널링·캐시

### 8.1 개념

- **블록(block)**: 디스크 할당 최소 단위(예: 4KB)
- **인덱스/아이노드**: 크기, 소유자, 권한, 타임스탬프, 데이터 위치(포인터/익스텐트)
- **디렉터리**: 이름→아이노드 매핑
- **할당**: 인접(연속), 연결, 인덱스, **익스텐트(extent)** 기반

### 8.2 저널링(Journaling)

- **메타데이터 저널**: 메타데이터만 WAL → 빠름/일관성
- **데이터 저널**: 데이터+메타데이터 WAL → 안전↑, 쓰기 비용↑

### 8.3 페이지 캐시와 쓰기 경로

- 파일 읽기/쓰기 대부분이 **페이지 캐시**를 거침
- `fsync/fdatasync`로 디스크에 **내구성 보장** 시점 지정
- **원자적 갱신 패턴**: temp에 쓰고 **rename()**(원자적) → 충돌/크래시에도 일관성

```c
// 안전한 저장 패턴(요지): write → fsync(fd) → rename → fsync(dir)
```

---

## 9. 가상 메모리: 논리주소↔물리주소, TLB, mmap

### 9.1 주소 변환

가상주소 \(A\)의 분해(페이지 크기 \(2^p\)):

$$
\text{VPN} = \left\lfloor \frac{A}{2^p} \right\rfloor,\qquad
\text{Offset} = A \bmod 2^p
$$

페이지 테이블에서 **VPN→물리 프레임(PFN)** 매핑, **TLB**가 캐시.

### 9.2 메모리 매핑 I/O(mmap)

- 파일을 프로세스 주소공간에 매핑, 접근 시 **페이지 폴트로 lazy 로딩**
- 큰 순차 읽기에 유리(프리패치/리드어헤드)
- 공유 매핑은 **프로세스 간 공유 메모리** 역할도 가능

```c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <stdio.h>

int main(int argc, char** argv){
    int fd = open(argv[1], O_RDONLY);
    struct stat st; fstat(fd, &st);
    uint8_t* p = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    long long sum=0;
    for(off_t i=0;i<st.st_size;i++) sum+=p[i];
    printf("%lld\n", sum);
    munmap(p, st.st_size); close(fd);
}
```

---

## 10. 직렬화: 엔디안·정렬·패딩을 통제하라

**원칙**: 바이너리 포맷은 (1) 바이트 순서, (2) 필드 폭, (3) 정렬/패딩, (4) 버전, (5) 무결성(체크섬/CRC)을 명시해야 한다.

### 10.1 안전한 수동 팩킹

```c
// 3개의 32b 필드(빅엔디안)로 헤더 직렬화/역직렬화
void put32be(uint8_t* o, uint32_t x){ o[0]=x>>24; o[1]=x>>16; o[2]=x>>8; o[3]=x; }
void write_hdr(uint8_t out[12], uint32_t a, uint32_t b, uint32_t c){
    put32be(out+0,a); put32be(out+4,b); put32be(out+8,c);
}
uint32_t get32be(const uint8_t* o){ return (o[0]<<24)|(o[1]<<16)|(o[2]<<8)|o[3]; }
```

```python
# 동등한 파이썬 구현
import struct, binascii
def write_hdr(fp, a, b, c):
    fp.write(struct.pack(">III", a, b, c))
def read_hdr(fp):
    return struct.unpack(">III", fp.read(12))
with open("h.bin","wb") as f: write_hdr(f, 0x12345678, 0xABCDEF01, 4096)
with open("h.bin","rb") as f: print([hex(x) for x in read_hdr(f)])
print("crc32=", hex(binascii.crc32(open("h.bin","rb").read()) & 0xffffffff))
```

### 10.2 비트필드보다는 마스크/시프트

C 비트필드는 구현/엔디안 의존 → **이식성 낮음**. 명시적 마스크/시프트 권장.

---

## 11. 캐시·계층 구조: 속도/용량/비용의 트레이드오프

| 계층 | 예 | 지연 | 용량 | 지속성 |
|---|---|---:|---:|---|
| 레지스터 | CPU 내부 | 수분의 ns | 수십~수백 B | 휘발성 |
| 캐시 | L1/L2/L3 | 1~수십 ns | 수십 KB~수 MB | 휘발성 |
| DRAM | 메인 메모리 | ~100 ns | 수~수백 GB | 휘발성 |
| 보조 | SSD/HDD | μs/ms | TB급 | 비휘발성 |

운영체제는 **페이지 캐시**와 **버퍼 캐시**로 디스크 I/O를 완화하고, 하드웨어는 **프리패처**로 패턴을 예측한다. **순차 접근**과 **연속 배치**가 일반적으로 유리하다.

---

## 12. 일관성: 크래시 안전한 업데이트

- **WAL(Write-Ahead Logging)**: 로그에 먼저 기록 후 커밋
- **rename 원자성**: `tmp`에 쓰고 `fsync(tmp)` → `rename(tmp, final)` → `fsync(dir)`
- **fdatasync**: 메타데이터 제외한 데이터 내구성(플랫폼별 차이 주의)

```c
// 요지: 안전 저장 함수
// write_all(fd, buf); fsync(fd); close(fd);
// rename(tmp, path); fd = open(dirname(path)); fsync(fd); close(fd);
```

---

## 13. 보안: 암호화(저장 시)·무결성·키 관리

- **암호화 at-rest**: 전디스크(dm-crypt, XTS 모드) 또는 파일 단위(암호화 라이브러리)
- **무결성**: HMAC/AEAD(GCM, ChaCha20-Poly1305)로 **암호화+인증** 동시 보장
- **키 관리**: KMS/HSM, 키 순환/폐기 정책, 여분 메타데이터(IV/nonce/버전)

```python
# AEAD 예시(개념): nonce는 절대 재사용 금지, 추가 인증 데이터(AAD)로 메타데이터 보호
```

---

## 14. 압축·중복제거: 저장 효율 vs CPU 비용

- **파일 단위**(zip, zstd), **블록 단위**(파일시스템/스토리지)
- 랜덤 접근이 중요하면 **슬라이스/청크 인덱싱** 필요
- **가변 길이 청크 + 콘텐츠 정의 해시**(CDC) → 중복 제거에 유리

---

## 15. 스냅샷·백업·RAID: 복구 가능성이 진짜 신뢰성

- **스냅샷(COW)**: 시점 복제(메타데이터+데이터 블록 참조 공유)
- **증분 백업**: 변경분만 저장, 복구 계층 단순화가 중요
- **RAID**: 병렬성/내구성(예: RAID1/5/6/10). 무결성은 **백업의 대체재가 아님**.

**간단 용량 수식(예: RAID5)**

$$
C_{\text{eff}} = (N-1)\cdot C_{\text{disk}}
$$

---

## 16. 실습: “작은 로그 파일 포맷” 설계·검증

### 16.1 포맷 정의

```
[Magic=4B "L0G1"]
[Version=1B]
[Flags=1B][Reserved=2B]
[EntryCount=4B BE]
-- 반복 --
[TS=8B BE][Level=1B][Len=3B BE][Payload=LenB UTF-8]
-- 끝 --
[CRC32 전체 앞부분에 대해 4B BE]
```

- **엔디안**: 빅엔디안
- **정렬/패딩 없음**
- **무결성**: 끝 CRC32

### 16.2 파이썬 작성기/읽기기

```python
import struct, binascii, time

MAG = b"L0G1"

def write_log(path, entries):
    buf = bytearray()
    buf += MAG
    buf += struct.pack(">B", 1)          # version
    buf += struct.pack(">B", 0) + b"\x00\x00"
    buf += struct.pack(">I", len(entries))
    for ts, lvl, msg in entries:
        data = msg.encode("utf-8")
        assert len(data) < (1<<24)
        buf += struct.pack(">QB", int(ts), lvl)
        buf += struct.pack(">I", len(data))[1:]   # 3B
        buf += data
    crc = binascii.crc32(buf) & 0xffffffff
    buf += struct.pack(">I", crc)
    with open(path, "wb") as f: f.write(buf)

def read_log(path):
    b = open(path,"rb").read()
    crc_expect = struct.unpack(">I", b[-4:])[0]
    if (binascii.crc32(b[:-4]) & 0xffffffff) != crc_expect:
        raise ValueError("CRC mismatch")
    off=0
    assert b[off:off+4]==MAG; off+=4
    ver=b[off]; off+=1
    flags=b[off]; off+=1
    off+=2
    n = struct.unpack(">I", b[off:off+4])[0]; off+=4
    out=[]
    for _ in range(n):
        ts = struct.unpack(">Q", b[off:off+8])[0]; off+=8
        lvl = b[off]; off+=1
        ln = int.from_bytes(b[off:off+3], "big"); off+=3
        msg = b[off:off+ln].decode("utf-8"); off+=ln
        out.append((ts,lvl,msg))
    return {"version":ver,"flags":flags,"entries":out}

# 테스트
entries = [(time.time(), 2, "hello"), (time.time(), 4, "안녕하세요"), (time.time(), 3, "utf8 👍 제거됨?")]
# 주: 요구상 이모티콘은 문서에서 사용하지 않지만, 인코딩 호환 확인용으로만 여기에 포함.
write_log("log.bin", entries)
print(read_log("log.bin"))
```

### 16.3 헥스덤프(학습용)

```python
def hexdump(b, base=0):
    for i in range(0, len(b), 16):
        chunk=b[i:i+16]
        print(f"{base+i:08X}: {' '.join(f'{x:02X}' for x in chunk):<47}"
              f" {''.join(chr(x) if 32<=x<127 else '.' for x in chunk)}")
hexdump(open("log.bin","rb").read())
```

→ 엔디안/필드 경계/UTF-8 길이/CRC가 **가시화**된다.

---

## 17. 가상 메모리와 파일 I/O의 만남: `mmap` vs `read`

- **`mmap`**: 큰 파일 순차 스캔, 랜덤 작은 접근이 많은 경우 유리. 페이지 캐시/프리패치 이점.
- **`read`**: 명시적 I/O 제어, 파이프/소켓 등 비파일형에 필요.
- **직접 I/O**: DB/로그 WAL에서 **이중 캐싱 회피**.

**간단 비교 실험 아이디어**

1GB 파일을 무작위 4KB로 100k번 접근: `mmap`/`pread`/`O_DIRECT+posix_fadvise` 조합의 p95 지연 비교.

---

## 18. 운영·성능·안전 체크리스트

1. **표현/범위**: 정수(부호/폭), 부동(정밀), 고정소수(Q) 선택
2. **엔디안/정렬/패딩**: 포맷 문서에 **명시**
3. **직렬화 테스트**: 다른 아키텍처(리틀/빅) CI에 포함
4. **무결성**: 블록마다 CRC/HMAC, 파일 끝에 목차/복구 레코드
5. **원자적 갱신**: tmp→`fsync`→`rename`→dir `fsync`
6. **`fsync` 빈도**: 지연/내구성 타협(배치/주기), 저널 모드 선택
7. **SSD 친화성**: 정렬(4K/16K), 배치 쓰기, TRIM, 장치 큐 깊이
8. **페이지 크기/NUMA**: 대용량 맵핑(HugeTLB)·first-touch·바인딩
9. **암호화**: AEAD 사용, nonce/IV 관리, 키 회전/백업
10. **백업/스냅샷**: 테스트 복구 절차를 **정기적으로 연습**

---

## 19. 연습 문제

1) 16비트 2의 보수에서 `1000 0000 0000 0000₂`의 값은 무엇인가?
2) 32비트 부호 없는 정수에서 `0xFFFF_FFFF + 1`의 결과와 이유를 설명하라.
3) 0x12345678을 리틀 엔디안 메모리에 저장한 바이트 나열(낮은 주소부터)을 쓰라.
4) IEEE754 float에서 `s=0, e=127, f=0`의 실수 값은?
5) rename 기반 원자적 갱신 절차를 글머리표로 작성하고, `fsync`의 위치를 표시하라.
6) SSD에서 WAF를 낮추기 위한 애플리케이션 레벨의 전략 3가지를 써라.

---

## 20. 요약 — 비트에서 파일까지, 그리고 다시 비트로

- **표현을 올바르게 선택/문서화**하면, 포맷·I/O·보안의 대부분 문제가 절반 이상 해결된다.
- 장치/OS/애플리케이션의 **경계 조건**(엔디안, 정렬, 원자성, fsync)을 알수록 **데이터 손실·부패**를 피한다.
- 저장은 “쓰기”가 아니라 **일관성·무결성·복구 가능성까지 포함한 설계**다.
- 실전에서는 **측정 가능한 실험**(헥스덤프, p95 I/O 지연, CRC 실패 주입)이 지식의 마침표가 된다.

---
```c
// 부록 A: 엔디안·정렬·래핑 스모크 테스트
#include <stdint.h>
#include <stdio.h>
int main(){
    union { uint32_t u; uint8_t b[4]; } v={ .u=0x12345678 };
    printf("endian=%s\n", v.b[0]==0x78?"little":"big");
    struct { uint8_t a; uint32_t b; uint16_t c; } A;
    printf("sizeof(A)=%zu\n", sizeof(A));
    uint32_t x=0xFFFFFFFFu; x+=1u; printf("wrap=%u\n", x);
    return 0;
}
```

```python
# 부록 B: 비트·헥스 시각화 도우미
def bits(x, w=32): return "".join("1" if (x>>(w-1-i))&1 else "0" for i in range(w))
def hexdump(b, base=0):
    for i in range(0, len(b), 16):
        chunk=b[i:i+16]
        print(f"{base+i:08X}: {' '.join(f'{x:02X}' for x in chunk):<47}"
              f" {''.join(chr(x) if 32<=x<127 else '.' for x in chunk)}")
print(bits(0xDEADBEEF))
hexdump(bytes.fromhex("000102030405060708090A0B0C0D0E0F"))
```
