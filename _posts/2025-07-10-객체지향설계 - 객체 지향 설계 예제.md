---
layout: post
title: 객체지향설계 - 객체 지향 설계 예제
date: 2025-07-10 20:20:23 +0900
category: 객체지향설계
---
# 객체 지향 설계 예제: 은행 계좌 클래스

## 💡 목표
은행 계좌(BankAccount)를 객체 지향적으로 설계하여 다음을 만족합니다:

- 내부 상태(`balance`)를 외부에 숨긴다 (정보 은닉)
- 입금, 출금, 잔액 조회는 공개된 메서드로만 수행한다 (인터페이스 설계)
- 유효성 검사를 통해 잘못된 동작을 방지한다 (객체의 안정성)
- 출금 실패 시 예외를 통해 오류를 명확하게 처리한다

---

## 🧱 클래스 설계 요약

| 구성 요소 | 설명 |
|-----------|------|
| `BankAccount` | 계좌 클래스 (캡슐화된 도메인 객체) |
| `balance` | 잔액 (private 상태 변수) |
| `deposit(amount)` | 입금 메서드 (public) |
| `withdraw(amount)` | 출금 메서드 (public) |
| `getBalance()` | 현재 잔액 조회 (public) |
| 유효성 검사 | 음수 입금/출금 불가, 잔액 부족 시 예외 |

---

## ✅ 코드: 은행 계좌 클래스

```java
// 예외 클래스 정의
public class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(String message) {
        super(message);
    }
}
```

```java
// 은행 계좌 클래스
public class BankAccount {
    private final String accountNumber;
    private String ownerName;
    private int balance;

    // 생성자
    public BankAccount(String accountNumber, String ownerName, int initialBalance) {
        this.accountNumber = accountNumber;
        this.ownerName = ownerName;
        if (initialBalance < 0) {
            throw new IllegalArgumentException("초기 잔액은 음수일 수 없습니다.");
        }
        this.balance = initialBalance;
    }

    // 입금 메서드
    public void deposit(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("입금액은 0보다 커야 합니다.");
        }
        balance += amount;
    }

    // 출금 메서드
    public void withdraw(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("출금액은 0보다 커야 합니다.");
        }
        if (balance < amount) {
            throw new InsufficientFundsException("잔액 부족: 출금 실패");
        }
        balance -= amount;
    }

    // 잔액 조회
    public int getBalance() {
        return balance;
    }

    // 소유자 이름 변경 (예: 고객센터를 통한 변경)
    public void changeOwner(String newOwnerName) {
        if (newOwnerName == null || newOwnerName.isBlank()) {
            throw new IllegalArgumentException("소유자 이름은 비어 있을 수 없습니다.");
        }
        this.ownerName = newOwnerName;
    }

    // getter
    public String getAccountNumber() {
        return accountNumber;
    }

    public String getOwnerName() {
        return ownerName;
    }
}
```

---

## 📌 코드의 객체 지향 설계 요소 분석

| 요소 | 적용된 부분 |
|------|-------------|
| **캡슐화** | `balance`, `accountNumber`를 `private`으로 숨김 |
| **정보 은닉** | 직접 접근 없이 `deposit`, `withdraw` 등의 메서드만 제공 |
| **유효성 검사** | 잘못된 입금/출금/이름 변경을 방지하는 조건문 |
| **인터페이스 기반 설계** | 외부에 필요한 메서드만 `public`으로 공개 |
| **예외 처리** | `InsufficientFundsException`으로 비정상 흐름 명확히 처리 |
| **불변 속성 유지** | `accountNumber`는 `final`로 설정하여 변경 불가 |

---

## 🎮 사용 예시 (클라이언트 코드)

```java
public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount("123-456", "홍길동", 10000);

        account.deposit(5000);           // 입금
        System.out.println(account.getBalance()); // 15000

        account.withdraw(3000);          // 출금
        System.out.println(account.getBalance()); // 12000

        try {
            account.withdraw(50000);     // 예외 발생
        } catch (InsufficientFundsException e) {
            System.out.println("출금 실패: " + e.getMessage());
        }
    }
}
```

---

## 🧠 확장 가능 포인트

- `TransactionHistory` 클래스를 도입하여 입출금 내역 저장
- `인터페이스`로 역할 추상화 (`IBankAccount`)
- `AccountType`에 따라 이자 계산 전략 분리 (Strategy Pattern)
- 비밀번호 인증 등의 보안 기능 도입

---

## ✅ 요약

| 설계 요소 | 적용 여부 |
|-----------|------------|
| ✅ 캡슐화 | `private` 필드, `public` 메서드 제공 |
| ✅ 정보 은닉 | 내부 구현 세부사항은 외부에 노출되지 않음 |
| ✅ 유효성 검사 | 모든 외부 입력은 검사됨 |
| ✅ 인터페이스 설계 | 명확한 역할 기반 메서드만 외부에 공개 |
| ✅ 확장성 | 인터페이스, 예외 처리, 변경 대응에 유리한 구조 |

이러한 방식으로 객체 지향적으로 잘 설계된 클래스는 **변경에 강하고**, **재사용이 쉽고**, **테스트 가능하며**, **협업이 용이한 코드**를 만듭니다.
