---
layout: post
title: 객체지향설계 - 객체 지향 설계 예제
date: 2025-07-10 20:20:23 +0900
category: 객체지향설계
---
# 객체 지향 설계 예제: 은행 계좌 클래스

## 목표

은행 계좌(BankAccount)를 객체 지향적으로 설계하여 다음을 만족한다.

- 내부 상태(`balance`)를 외부에 숨긴다(정보 은닉, 캡슐화)
- 입금, 출금, 잔액 조회는 공개된 메서드로만 수행한다(명확한 퍼블릭 인터페이스)
- 유효성 검사를 통해 잘못된 동작을 방지한다(도메인 불변식 유지)
- 출금 실패 시 예외로 오류를 명확히 처리한다(오류 모델 명확화)
- 금액/통화 표현을 **값 객체(Money)**로 다룬다(정밀도/의미 보존)
- 트랜잭션 내역과 **일관성·원자성**을 보장하고 동시성 이슈에 대응한다

---

## 클래스 설계 요약

| 구성 요소 | 설명 |
|---|---|
| `BankAccount` | 계좌 도메인 객체(캡슐화, 불변식 유지) |
| `Money` | 금액 값 객체(BigDecimal, 통화코드 포함, 불변) |
| `deposit(amount)` | 입금(전제조건: amount > 0) |
| `withdraw(amount)` | 출금(전제조건: amount > 0, 후조건: balance 감소, 불변식 유지) |
| `balance()` | 잔액 조회(값 객체 반환) |
| `Transaction` | 입출금 내역(타입, 금액, 시각, idempotencyKey) |
| `InterestPolicy` | 이자 계산 전략(Strategy) |
| `OverdraftPolicy` | 초과인출 규칙 전략(허용/한도/수수료) |
| `AccountRepository` | 영속 경계(포트/어댑터) |
| `AccountService` | 애플리케이션 서비스(오케스트레이션, 트랜잭션 경계) |
| `DomainEvent` | 도메인 이벤트 발행(`AccountCredited`, `Debited`) |

---

## 도메인 규칙과 불변식(Design by Contract)

기본 계좌(초과인출 없음)의 핵심 불변식:

$$
\forall t,\ \mathrm{Balance}_t = \mathrm{Balance}_{t-1} + \Delta_t,\quad \mathrm{Balance}_t \ge 0
$$

- 전제조건(Pre): `amount > 0`, `currency` 일치  
- 사후조건(Post): `deposit` 후 \( \mathrm{Balance}' = \mathrm{Balance} + \mathrm{amount} \), `withdraw` 후 \( \mathrm{Balance}' = \mathrm{Balance} - \mathrm{amount} \)  
- 불변식(Invariant): 통화는 계좌 통화와 동일, 잔액은 음수가 아님(초과인출 정책이 허용하지 않는 한)

초과인출 허용 계좌의 불변식(한도 \(L \ge 0\)):

$$
\mathrm{Balance}_t \ge -L
$$

검증은 **도메인 객체 내부에서만** 수행되어야 하며, 외부에서 상태를 직접 조작하지 못하게 한다.

---

## 예외와 오류 모델

| 상황 | 예외 종류 | 메시지 예 |
|---|---|---|
| 음수/영(0) 입금/출금 | `IllegalArgumentException` | "amount must be positive" |
| 잔액 부족 | `InsufficientFundsException` | "insufficient funds" |
| 통화 불일치 | `CurrencyMismatchException` | "currency mismatch: KRW vs USD" |
| 불변식 위반(내부 오류) | `DomainInvariantViolationException` | "balance would fall below overdraft limit" |

예외는 **도메인 용어로 구체적**이어야 하며, 상위 계층에서 의미 있는 4xx/5xx로 매핑한다.

---

## 코드 1: 예외 클래스

```java
public class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(String message) { super(message); }
}
public class CurrencyMismatchException extends RuntimeException {
    public CurrencyMismatchException(String message) { super(message); }
}
public class DomainInvariantViolationException extends RuntimeException {
    public DomainInvariantViolationException(String message) { super(message); }
}
```

---

## 코드 2: 값 객체 Money (정밀도·통화 보존)

```java
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;

public final class Money {
    private final BigDecimal amount;
    private final String currency; // ISO-4217 코드: "KRW", "USD" 등

    public static Money of(long minor, String currency, int scale) {
        return new Money(BigDecimal.valueOf(minor, scale), currency);
    }
    public static Money of(BigDecimal amount, String currency) {
        if (amount == null || currency == null) throw new IllegalArgumentException();
        if (amount.scale() > 6) amount = amount.setScale(6, RoundingMode.HALF_UP);
        return new Money(amount, currency);
    }

    private Money(BigDecimal amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }

    public Money add(Money other) {
        ensureSameCurrency(other);
        return new Money(this.amount.add(other.amount), currency);
    }
    public Money subtract(Money other) {
        ensureSameCurrency(other);
        return new Money(this.amount.subtract(other.amount), currency);
    }
    public int compareTo(Money other) {
        ensureSameCurrency(other);
        return this.amount.compareTo(other.amount);
    }
    public boolean isNegative() { return amount.signum() < 0; }
    public boolean isZeroOrNegative() { return amount.signum() <= 0; }
    public BigDecimal asBigDecimal() { return amount; }
    public String currency() { return currency; }

    private void ensureSameCurrency(Money other) {
        if (!Objects.equals(this.currency, other.currency))
            throw new CurrencyMismatchException(this.currency + " vs " + other.currency);
    }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Money m)) return false;
        return amount.compareTo(m.amount) == 0 && Objects.equals(currency, m.currency);
    }
    @Override public int hashCode() { return Objects.hash(amount.stripTrailingZeros(), currency); }
    @Override public String toString() { return amount.toPlainString() + " " + currency; }
}
```

---

## 코드 3: 계좌 인터페이스와 기본 구현

```java
import java.time.Instant;
import java.util.*;

public interface BankAccount {
    String accountNumber();
    String ownerName();
    Money balance();
    void deposit(Money amount, String idempotencyKey);
    void withdraw(Money amount, String idempotencyKey);
    List<Transaction> history(); // 불변 리스트 반환
}
```

```java
public final class DefaultBankAccount implements BankAccount {
    private final String accountNumber;
    private String ownerName;
    private Money balance;
    private final OverdraftPolicy overdraftPolicy;
    private final InterestPolicy interestPolicy;
    private final List<Transaction> history = new ArrayList<>();
    private final Set<String> processedKeys = new HashSet<>();

    public DefaultBankAccount(String accountNumber, String ownerName,
                              Money initialBalance,
                              OverdraftPolicy overdraftPolicy,
                              InterestPolicy interestPolicy) {
        if (accountNumber == null || accountNumber.isBlank()) throw new IllegalArgumentException();
        if (ownerName == null || ownerName.isBlank()) throw new IllegalArgumentException();
        if (initialBalance == null) throw new IllegalArgumentException();
        this.accountNumber = accountNumber;
        this.ownerName = ownerName;
        this.balance = initialBalance;
        this.overdraftPolicy = Objects.requireNonNull(overdraftPolicy);
        this.interestPolicy = Objects.requireNonNull(interestPolicy);
        ensureInvariant();
    }

    @Override public String accountNumber() { return accountNumber; }
    @Override public String ownerName() { return ownerName; }
    @Override public Money balance() { return balance; }

    public void changeOwner(String newOwner) {
        if (newOwner == null || newOwner.isBlank()) throw new IllegalArgumentException();
        this.ownerName = newOwner;
    }

    @Override
    public void deposit(Money amount, String idempotencyKey) {
        requirePositive(amount);
        if (isDuplicate(idempotencyKey)) return; // 멱등 처리
        this.balance = balance.add(amount);
        history.add(Transaction.credit(amount, Instant.now(), idempotencyKey));
        processedKeys.add(idempotencyKey);
        ensureInvariant();
    }

    @Override
    public void withdraw(Money amount, String idempotencyKey) {
        requirePositive(amount);
        if (isDuplicate(idempotencyKey)) return;
        Money newBalance = balance.subtract(amount);
        if (!overdraftPolicy.allows(newBalance)) {
            throw new InsufficientFundsException("insufficient funds or overdraft limit exceeded");
        }
        this.balance = newBalance;
        history.add(Transaction.debit(amount, Instant.now(), idempotencyKey));
        processedKeys.add(idempotencyKey);
        ensureInvariant();
    }

    public void accrueDailyInterest(Instant at) {
        Money interest = interestPolicy.accrue(balance, at);
        if (interest.asBigDecimal().signum() > 0) {
            this.balance = balance.add(interest);
            history.add(Transaction.interest(interest, at));
        }
        ensureInvariant();
    }

    @Override
    public List<Transaction> history() {
        return Collections.unmodifiableList(history);
    }

    private boolean isDuplicate(String key) {
        return key != null && processedKeys.contains(key);
    }
    private void requirePositive(Money amount) {
        if (amount.asBigDecimal().signum() <= 0)
            throw new IllegalArgumentException("amount must be positive");
        if (!Objects.equals(amount.currency(), balance.currency()))
            throw new CurrencyMismatchException(balance.currency() + " vs " + amount.currency());
    }
    private void ensureInvariant() {
        if (!overdraftPolicy.allows(balance)) {
            throw new DomainInvariantViolationException("balance violates overdraft policy");
        }
    }
}
```

---

## 코드 4: 트랜잭션과 정책(Strategy)

```java
import java.time.Instant;
import java.util.Objects;

public final class Transaction {
    public enum Type { CREDIT, DEBIT, INTEREST }
    private final Type type;
    private final Money amount;
    private final Instant at;
    private final String idempotencyKey;

    private Transaction(Type type, Money amount, Instant at, String key) {
        this.type = Objects.requireNonNull(type);
        this.amount = Objects.requireNonNull(amount);
        this.at = Objects.requireNonNull(at);
        this.idempotencyKey = key;
    }
    public static Transaction credit(Money amt, Instant at, String key) {
        return new Transaction(Type.CREDIT, amt, at, key);
    }
    public static Transaction debit(Money amt, Instant at, String key) {
        return new Transaction(Type.DEBIT, amt, at, key);
    }
    public static Transaction interest(Money amt, Instant at) {
        return new Transaction(Type.INTEREST, amt, at, "interest-" + at.toEpochMilli());
    }

    public Type type() { return type; }
    public Money amount() { return amount; }
    public Instant at() { return at; }
    public String idempotencyKey() { return idempotencyKey; }
}
```

```java
public interface OverdraftPolicy {
    boolean allows(Money newBalance);
}
public final class NoOverdraft implements OverdraftPolicy {
    @Override public boolean allows(Money newBalance) { return newBalance.asBigDecimal().signum() >= 0; }
}
public final class LimitedOverdraft implements OverdraftPolicy {
    private final Money limit; // 음수 허용 한도: 예) -500_000 KRW
    public LimitedOverdraft(Money limit) {
        if (limit.asBigDecimal().signum() < 0) throw new IllegalArgumentException("limit must be >= 0");
        this.limit = Money.of(limit.asBigDecimal(), limit.currency());
    }
    @Override public boolean allows(Money newBalance) {
        // newBalance >= -limit
        Money floor = Money.of(limit.asBigDecimal().negate(), limit.currency());
        return newBalance.compareTo(floor) >= 0;
    }
}
```

```java
import java.time.Instant;

public interface InterestPolicy {
    Money accrue(Money principal, Instant at);
}
public final class NoInterest implements InterestPolicy {
    @Override public Money accrue(Money principal, Instant at) { return Money.of(principal.asBigDecimal().multiply(java.math.BigDecimal.ZERO), principal.currency()); }
}
public final class DailyCompoundInterest implements InterestPolicy {
    // 연 이자율 r, 하루 이자율 r/365 단리 근사 또는 복리
    private final java.math.BigDecimal annualRate; // 예: 0.015 (1.5%)
    public DailyCompoundInterest(java.math.BigDecimal annualRate) {
        if (annualRate == null || annualRate.signum() < 0) throw new IllegalArgumentException();
        this.annualRate = annualRate;
    }
    @Override
    public Money accrue(Money principal, Instant at) {
        var dailyRate = annualRate.divide(java.math.BigDecimal.valueOf(365), 10, java.math.RoundingMode.HALF_UP);
        var interest = principal.asBigDecimal().multiply(dailyRate).setScale(2, java.math.RoundingMode.HALF_UP);
        return Money.of(interest, principal.currency());
    }
}
```

이자 근사 수식(하루 이자):

$$
I_{\text{daily}} = \mathrm{round}\_2\bigl(P \cdot \frac{r}{365}\bigr)
$$

---

## 서비스/리포지토리 경계(DIP)

```java
public interface AccountRepository {
    Optional<DefaultBankAccount> findByNumber(String accountNumber);
    void save(DefaultBankAccount account);
}
```

```java
public final class InMemoryAccountRepository implements AccountRepository {
    private final java.util.concurrent.ConcurrentMap<String, DefaultBankAccount> store = new java.util.concurrent.ConcurrentHashMap<>();
    @Override public Optional<DefaultBankAccount> findByNumber(String number) {
        var acc = store.get(number);
        return Optional.ofNullable(acc);
    }
    @Override public void save(DefaultBankAccount account) {
        store.put(account.accountNumber(), account);
    }
}
```

```java
public final class AccountService {
    private final AccountRepository repo;

    public AccountService(AccountRepository repo) { this.repo = repo; }

    public void deposit(String number, Money amount, String idempotencyKey) {
        var acc = repo.findByNumber(number).orElseThrow();
        synchronized (acc) { // 간단한 동시성 보호(예시)
            acc.deposit(amount, idempotencyKey);
            repo.save(acc);
        }
    }

    public void withdraw(String number, Money amount, String idempotencyKey) {
        var acc = repo.findByNumber(number).orElseThrow();
        synchronized (acc) {
            acc.withdraw(amount, idempotencyKey);
            repo.save(acc);
        }
    }
}
```

- 실무에서는 `synchronized` 대신 **낙관적 잠금(버전 필드, CAS)** 또는 DB의 **행 잠금/트랜잭션**을 사용해 동시성/원자성을 보장한다.

---

## 시퀀스 다이어그램(출금 흐름)

```text
Client -> AccountService: withdraw(number, amount, key)
AccountService -> AccountRepository: findByNumber(number)
AccountRepository --> AccountService: DefaultBankAccount
AccountService -> DefaultBankAccount: withdraw(amount, key)
DefaultBankAccount -> OverdraftPolicy: allows(newBalance)
OverdraftPolicy --> DefaultBankAccount: true/false
DefaultBankAccount --> AccountService: ok / throws
AccountService -> AccountRepository: save(account)
AccountService --> Client: success / InsufficientFundsException
```

---

## 사용 예시(클라이언트 코드)

```java
public class Main {
    public static void main(String[] args) {
        var repo = new InMemoryAccountRepository();
        var acc = new DefaultBankAccount(
                "123-456", "홍길동",
                Money.of(new java.math.BigDecimal("100000"), "KRW"),
                new NoOverdraft(),
                new NoInterest());
        repo.save(acc);

        var service = new AccountService(repo);
        service.deposit("123-456", Money.of(new java.math.BigDecimal("5000"), "KRW"), "dep-1");
        System.out.println(repo.findByNumber("123-456").get().balance()); // 105000 KRW

        service.withdraw("123-456", Money.of(new java.math.BigDecimal("3000"), "KRW"), "wd-1");
        System.out.println(repo.findByNumber("123-456").get().balance()); // 102000 KRW

        try {
            service.withdraw("123-456", Money.of(new java.math.BigDecimal("500000"), "KRW"), "wd-2");
        } catch (InsufficientFundsException e) {
            System.out.println("출금 실패: " + e.getMessage());
        }
    }
}
```

---

## 단위 테스트(TDD 스케치)

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.math.BigDecimal;

class BankAccountTest {

    @Test
    void deposit_increases_balance() {
        var acc = new DefaultBankAccount("A1","Kim",
            Money.of(new BigDecimal("10000"), "KRW"),
            new NoOverdraft(), new NoInterest());
        acc.deposit(Money.of(new BigDecimal("5000"), "KRW"), "k1");
        assertEquals(0, acc.balance().compareTo(Money.of(new BigDecimal("15000"), "KRW")));
    }

    @Test
    void withdraw_decreases_balance_or_throws() {
        var acc = new DefaultBankAccount("A1","Kim",
            Money.of(new BigDecimal("10000"), "KRW"),
            new NoOverdraft(), new NoInterest());
        acc.withdraw(Money.of(new BigDecimal("3000"), "KRW"), "k2");
        assertEquals(0, acc.balance().compareTo(Money.of(new BigDecimal("7000"), "KRW")));
        assertThrows(InsufficientFundsException.class, () ->
            acc.withdraw(Money.of(new BigDecimal("10000"), "KRW"), "k3"));
    }

    @Test
    void idempotency_prevents_duplicate_processing() {
        var acc = new DefaultBankAccount("A1","Kim",
            Money.of(new BigDecimal("10000"), "KRW"),
            new NoOverdraft(), new NoInterest());
        acc.deposit(Money.of(new BigDecimal("1000"), "KRW"), "x");
        acc.deposit(Money.of(new BigDecimal("1000"), "KRW"), "x"); // 중복
        assertEquals(0, acc.balance().compareTo(Money.of(new BigDecimal("11000"), "KRW")));
    }
}
```

---

## API 경계와 DTO

- 외부 API에는 **명령/조회 DTO**를 정의해 **도메인 객체를 직접 노출하지 않음**  
- 입력 검증은 API 계층에서 1차 수행, 도메인에서 2차 수행

```java
public record DepositCommand(String accountNumber, String currency, String amount, String idempotencyKey) {}
public record BalanceView(String accountNumber, String balance, String currency) {}
```

---

## 확장 포인트 예시

1) **AccountType에 따른 이자/수수료 전략**

```java
public enum AccountType { BASIC, SAVINGS, PREMIUM }

public final class InterestPolicies {
    public static InterestPolicy forType(AccountType t) {
        return switch (t) {
            case BASIC -> new NoInterest();
            case SAVINGS -> new DailyCompoundInterest(new java.math.BigDecimal("0.015"));
            case PREMIUM -> new DailyCompoundInterest(new java.math.BigDecimal("0.025"));
        };
    }
}
```

2) **OverdraftPolicy** 변형: 수수료 부과, 일일 한도, 경고 이벤트 발행 등

3) **TransactionHistory** 필터/페이지네이션, 일자별 합계, 월별 명세 생성

---

## 동시성·원자성·멱등성

- 동시 출금 경쟁 방지: **비관/낙관 잠금**, DB 트랜잭션 격리수준 활용
- 네트워크 재시도 대비: **멱등키(idempotencyKey)**로 중복 처리 방지
- 원자성: 저장소 저장까지 하나의 트랜잭션 경계에서 수행

간단한 낙관적 잠금(버전 필드) 개념:

```java
public interface Versioned {
    long version();
}
public interface AccountRepository {
    Optional<DefaultBankAccount> findByNumberForUpdate(String number);
    void saveWithVersionCheck(DefaultBankAccount account, long expectedVersion);
}
```

경합 시 `OptimisticLockException`으로 재시도 정책 적용.

---

## 보안·감사

- 인증(Authentication)과 권한(Authorization): 계좌 소유자/역할별 접근 제어
- 감사 로그(Audit): 누가, 언제, 얼마, 어떤 요청 ID로 수행
- 개인정보 최소화: 불필요한 식별자/원장 노출 금지

---

## 리팩토링 체크리스트

| 점검 항목 | 질문 |
|---|---|
| SRP | 클래스가 한 가지 책임만 갖는가 |
| LoD | 다른 객체 내부 구조에 의존하지 않는가 |
| OCP | 정책/전략 추가 시 기존 코드 수정을 최소화하는가 |
| 불변식 | 불변식 검증이 도메인 내부에 존재하는가 |
| 테스트 | 도메인 규칙을 빠르게 검증하는 단위 테스트가 있는가 |
| 동시성 | 중복 처리/경쟁 조건/락 전략이 정의되어 있는가 |
| 금액 | `double`이 아닌 정밀 타입(예: BigDecimal)과 통화 일관성을 유지하는가 |

---

## 최소 구현 요약 코드(단일 파일 데모, 간단 버전)

```java
// Demo.java (하나의 파일에 모아 실행 가능한 최소 데모)
import java.math.BigDecimal;
import java.time.Instant;
import java.util.*;

class Demo {
    public static void main(String[] args) {
        var repo = new InMemoryAccountRepository();
        var acc = new DefaultBankAccount("123-456","홍길동",
                Money.of(new BigDecimal("100000"), "KRW"),
                new NoOverdraft(),
                new NoInterest());
        repo.save(acc);

        var svc = new AccountService(repo);
        svc.deposit("123-456", Money.of(new BigDecimal("5000"), "KRW"), "key-1");
        svc.withdraw("123-456", Money.of(new BigDecimal("3000"), "KRW"), "key-2");
        System.out.println(repo.findByNumber("123-456").get().balance()); // 102000 KRW
    }
}

/* 이하: Money, 예외, 정책, 엔티티, 리포지토리, 서비스 (상단 섹션 코드와 동일) */
// ... (위 섹션의 코드들을 같은 파일에 순서대로 배치)
```

---

## 요약

| 설계 요소 | 적용 |
|---|---|
| 캡슐화/정보 은닉 | `private` 상태, 퍼블릭 메시지(`deposit`, `withdraw`, `balance`)만 노출 |
| 값 객체 | `Money`로 금액/통화 정밀·일관성 유지 |
| 불변식/계약 | 전제/사후/불변식 수학적 정의 및 코드 검증 |
| 예외 모델 | 도메인 특화 예외로 오류를 명확히 표현 |
| 전략 패턴 | `InterestPolicy`, `OverdraftPolicy`로 정책 확장 |
| 트랜잭션 내역 | `Transaction` 기록, 멱등키로 중복 방지 |
| 동시성/원자성 | 락/낙관적 잠금/DB 트랜잭션으로 경쟁 제어 |
| DIP | `AccountRepository`, `AccountService`로 경계 분리 |
| 테스트 | 핵심 규칙을 단위 테스트로 빠르게 검증 |

위와 같은 객체 지향 설계는 **변경에 강하고**, **테스트 가능하며**, **확장 용이**한 코드 기반을 만든다. 도메인 규칙은 **객체 내부의 책임**으로 남겨 두고, 외부 세계와의 통신은 **경계(포트/어댑터)**에서 다루는 것이 핵심이다.