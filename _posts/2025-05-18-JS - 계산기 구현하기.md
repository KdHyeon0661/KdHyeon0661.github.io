---
layout: post
title: JavaScript - 계산기 구현하기
date: 2025-05-18 20:20:23 +0900
category: JavaScript
---
# 자바스크립트 계산기 구현하기

## 1. 요구 사항과 UX 스케치

### 핵심 기능 (필수)
- 숫자 버튼 입력(0–9) 및 `.` 소수점
- 연산자: `+ - × ÷`
- `=` 계산, `C` 초기화
- **디스플레이**에 현재 입력/결과 표시

### 편의(권장)
- 키보드 입력(숫자/연산자/Enter/Backspace/Escape)
- 부호 전환(+/−), 백스페이스
- 연속 계산(`1 + 2 + 3 =` → 6)

### 심화
- 연산자 우선순위(곱·나눗셈 > 덧·뺄셈)
- 괄호 `()`
- 오류 상태 유지(0으로 나눔, 잘못된 표현식)와 복구 UX

---

## 2. V1 — 버튼 이벤트 + 간단 상태머신

**상태 변수**
- `current`(문자열): 화면에 타이핑 중인 피연산자
- `previous`(문자열): 직전까지 확정된 피연산자
- `operator`(문자): 현재 선택된 연산자(없을 수도 있음)
- 단순 정책: **연산자 누를 때마다** 이전 연산을 바로 적용(왼쪽에서 오른쪽 순서, 우선순위 미지원)

### HTML

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>계산기</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="calculator" role="application" aria-label="계산기">
    <input type="text" id="display" readonly aria-live="polite" />
    <div class="buttons" aria-label="버튼 영역">
      <button data-action="clear">C</button>
      <button data-action="/">÷</button>
      <button data-action="*">×</button>
      <button data-action="-">−</button>

      <button data-number="7">7</button>
      <button data-number="8">8</button>
      <button data-number="9">9</button>
      <button data-action="+">+</button>

      <button data-number="4">4</button>
      <button data-number="5">5</button>
      <button data-number="6">6</button>
      <button data-action="=">=</button>

      <button data-number="1">1</button>
      <button data-number="2">2</button>
      <button data-number="3">3</button>
      <button data-number="0" class="zero">0</button>
      <button data-number=".">.</button>
    </div>
    <div class="row">
      <button id="negate" title="부호 전환">+/-</button>
      <button id="backspace" title="한 글자 지우기">←</button>
    </div>
  </div>

  <script src="app.v1.js" defer></script>
</body>
</html>
```

### CSS (기본)

```css
/* style.css */
:root { --gap: .5rem; --bg: #f9f9f9; --border: #cfcfcf; }
body { display: flex; justify-content: center; margin: 40px 8px; font-family: system-ui, sans-serif; }
.calculator { width: 280px; background: var(--bg); border: 1px solid var(--border); border-radius: 10px; padding: 1rem; }
#display { width: 100%; height: 48px; font-size: 1.6rem; text-align: right; padding: .5rem .75rem; margin-bottom: .75rem; }
.buttons { display: grid; grid-template-columns: repeat(4, 1fr); gap: var(--gap); }
.row { display: grid; grid-template-columns: repeat(2,1fr); gap: var(--gap); margin-top: var(--gap); }
button { padding: .9rem .5rem; font-size: 1.1rem; cursor: pointer; border: 1px solid var(--border); border-radius: 8px; background: #fff; }
button.zero { grid-column: span 2; }
button:active { transform: scale(.98); }
```

### JS (V1 + 부호/백스페이스)

```js
// app.v1.js
const display = document.getElementById("display");
const buttons = document.querySelector(".buttons");
const btnNegate = document.getElementById("negate");
const btnBack = document.getElementById("backspace");

let current = "";    // 현재 입력 중인 피연산자(문자열)
let previous = "";   // 이전 피연산자(문자열)
let operator = null; // '+','-','*','/' 중 하나 또는 null
let error = false;   // 오류 상태(0으로 나눔 등)

const update = (v) => display.value = String(v ?? "");

const clearAll = () => {
  current = ""; previous = ""; operator = null; error = false; update("");
};

const calculate = (a, b, op) => {
  if (op === "+") return a + b;
  if (op === "-") return a - b;
  if (op === "*") return a * b;
  if (op === "/") return b === 0 ? (error = true, "오류") : a / b;
  return b;
};

const commitOp = (nextOp) => {
  if (current === "" && previous === "") return;      // 아무것도 없음
  if (current !== "" && previous !== "" && operator) {
    const r = calculate(Number(previous), Number(current), operator);
    previous = String(r); current = ""; operator = nextOp;
    update(previous);
  } else if (current !== "" && previous === "") {
    previous = current; current = ""; operator = nextOp;
    update(previous);
  } else {
    operator = nextOp; // 연산자만 교체
  }
};

buttons.addEventListener("click", (e) => {
  const b = e.target.closest("button"); if (!b) return;
  if (error) clearAll();

  const num = b.dataset.number;
  const act = b.dataset.action;

  if (num !== undefined) {
    if (num === "." && current.includes(".")) return;
    if (num === "." && current === "") current = "0";
    current += num;
    update(current);
  } else if (act !== undefined) {
    if (act === "clear") { clearAll(); return; }
    if (act === "=") {
      if (current !== "" && previous !== "" && operator) {
        const r = calculate(Number(previous), Number(current), operator);
        current = String(r); previous = ""; operator = null;
        update(current);
      }
      return;
    }
    // 연산자
    commitOp(act);
  }
});

btnNegate.addEventListener("click", () => {
  if (error) clearAll();
  if (current) {
    if (current.startsWith("-")) current = current.slice(1);
    else if (current !== "0") current = "-" + current;
    update(current);
  } else if (previous && !operator) { // 결과 상태에서 부호 전환
    previous = String(-Number(previous)); update(previous);
  }
});

btnBack.addEventListener("click", () => {
  if (error) clearAll();
  if (current) { current = current.slice(0, -1); update(current); }
});
```

**이 시점까지:**
- 버튼 기반 사칙연산, 연속 계산(좌→우), 부호/백스페이스 지원
- **연산자 우선순위는 아직 없음**

---

## 3. V1.5 — 키보드 입력 추가

### 키바인딩 표
| 키 | 동작 |
|---|---|
| `0–9`, `.` | 숫자/소수점 |
| `+ - * /` | 연산자 |
| `Enter` | `=` |
| `Backspace` | 한 글자 지우기 |
| `Escape` | 전체 초기화 |
| `_`(또는 `n`) | 부호 전환(샘플) |

```js
// app.v1.js 아래에 덧붙이기
window.addEventListener("keydown", (e) => {
  if (error && e.key !== "Escape") clearAll();

  if (/^\d$/.test(e.key)) {
    current += e.key; update(current); return;
  }
  if (e.key === ".") {
    if (!current.includes(".")) {
      current = current || "0"; current += "."; update(current);
    }
    return;
  }
  if (["+", "-", "*", "/"].includes(e.key)) { commitOp(e.key); return; }
  if (e.key === "Enter" || e.key === "=") {
    if (current !== "" && previous !== "" && operator) {
      const r = calculate(Number(previous), Number(current), operator);
      current = String(r); previous = ""; operator = null;
      update(current);
    }
    return;
  }
  if (e.key === "Backspace") { if (current) { current = current.slice(0,-1); update(current);} return; }
  if (e.key === "Escape") { clearAll(); return; }
  if (e.key === "_" || e.key.toLowerCase() === "n") {
    btnNegate.click();
  }
});
```

---

## 4. V2 — 연속 계산·에러/표시 포매팅

### 부동소수 정밀도 간단 보정
JS의 이진 부동소수 오차(예: `0.1+0.2=0.30000000000000004`)를 **toFixed** 기반으로 단순 보정:

```js
function round10(n, p = 12) { // 소수점 12자리까지 반올림
  return Number(Number(n).toFixed(p));
}
```

`calculate`에서 연산 결과에 `round10`을 적용:

```js
const calculate = (a, b, op) => {
  if (op === "+") return round10(a + b);
  if (op === "-") return round10(a - b);
  if (op === "*") return round10(a * b);
  if (op === "/") return b === 0 ? (error = true, "오류") : round10(a / b);
  return round10(b);
};
```

### 표시 포매팅(선택)
큰 수에 **그룹 구분자**를 적용하고 소수점은 그대로:

```js
function formatDisplay(s) {
  if (s === "" || s === "오류") return s;
  const [i, f] = String(s).split(".");
  const head = i.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  return f ? `${head}.${f}` : head;
}
const update = (v) => display.value = formatDisplay(String(v ?? ""));
```

> 입력 중에는 포매팅이 거슬릴 수 있어, **최종 결과만 포매팅**하는 전략도 실무에서 자주 씁니다.

---

## 5. V3 — 연산자 우선순위(Shunting-yard)

이제 `1 + 2 * 3`을 **7**로 계산하게 만듭니다.

### 개념 요약

- **중위 표기**: `1 + 2 * 3`
- **후위 표기(Reverse Polish Notation, RPN)**: `1 2 3 * +`
- **Shunting-yard** 알고리즘: 중위 → 후위 변환
- 후위 표기를 **스택**으로 평가

#### 연산자 우선순위/결합성
- 우선순위: `* /` > `+ -`
- 결합성: 모두 좌결합
수식:
$$
\text{prec}(*,/) = 2 \quad>\quad \text{prec}(+,-)=1, \quad \text{assoc} = \text{left}
$$

### 표현식 파서(토크나이저 + 변환 + 평가)

새 파일 `parser.js`로 분리합니다.

```js
// parser.js — 중위→후위(Shunting-yard) + RPN 평가

const OPS = {
  "+": { prec: 1, assoc: "L", fn: (a, b) => a + b },
  "-": { prec: 1, assoc: "L", fn: (a, b) => a - b },
  "*": { prec: 2, assoc: "L", fn: (a, b) => a * b },
  "/": { prec: 2, assoc: "L", fn: (a, b) => b === 0 ? Infinity : a / b },
};

// 1) 문자열 → 토큰
export function tokenize(expr) {
  const tokens = [];
  let num = "";
  const pushNum = () => { if (num !== "") { tokens.push({ type: "num", value: Number(num) }); num = ""; } };
  for (let i = 0; i < expr.length; i++) {
    const ch = expr[i];
    if (/\d|\./.test(ch)) { num += ch; continue; }
    if (ch === " " || ch === "\t") { continue; }
    if (ch in OPS || ch === "(" || ch === ")") {
      pushNum(); tokens.push({ type: "op", value: ch });
      continue;
    }
    // 부호(단항 -) 처리: (시작/‘(’/연산자 뒤)에서 오는 '-'는 숫자의 일부로 취급
    if (ch === "-" && (tokens.length === 0 || (tokens.at(-1).type === "op" && tokens.at(-1).value !== ")"))) {
      num += ch; continue;
    }
    throw new Error("잘못된 문자: " + ch);
  }
  pushNum();
  return tokens;
}

// 2) Shunting-yard: 중위 → 후위
export function toRPN(tokens) {
  const out = [], stack = [];
  for (const t of tokens) {
    if (t.type === "num") out.push(t);
    else if (t.type === "op") {
      const v = t.value;
      if (v in OPS) {
        const o1 = OPS[v];
        while (stack.length) {
          const top = stack.at(-1).value;
          if (!(top in OPS)) break;
          const o2 = OPS[top];
          const higher = (o2.prec > o1.prec) || (o2.prec === o1.prec && o1.assoc === "L");
          if (higher) out.push(stack.pop());
          else break;
        }
        stack.push(t);
      } else if (v === "(") stack.push(t);
      else if (v === ")") {
        while (stack.length && stack.at(-1).value !== "(") out.push(stack.pop());
        if (!stack.length) throw new Error("괄호 불일치");
        stack.pop(); // '(' 버림
      }
    }
  }
  while (stack.length) {
    const s = stack.pop();
    if (s.value === "(" || s.value === ")") throw new Error("괄호 불일치");
    out.push(s);
  }
  return out;
}

// 3) RPN 평가
export function evalRPN(rpn) {
  const st = [];
  for (const t of rpn) {
    if (t.type === "num") st.push(t.value);
    else {
      const op = t.value;
      if (!(op in OPS)) throw new Error("알 수 없는 연산자: " + op);
      const b = st.pop(), a = st.pop();
      if (a === undefined || b === undefined) throw new Error("피연산자 부족");
      const r = OPS[op].fn(a, b);
      if (!isFinite(r)) throw new Error("0으로 나눔");
      st.push(r);
    }
  }
  if (st.length !== 1) throw new Error("평가 오류");
  return st[0];
}

export function evaluateExpression(expr) {
  const tokens = tokenize(expr);
  const rpn = toRPN(tokens);
  return evalRPN(rpn);
}
```

### 표현식 기반 계산기(=와 동시에 파싱/평가)

`app.v2.js`—**디스플레이에 “표현식”을 쌓아가다가 `=` 시점 평가**:

```js
// app.v2.js
import { evaluateExpression } from './parser.js';

const display = document.getElementById("display");
const buttons = document.querySelector(".buttons");
const btnNegate = document.getElementById("negate");
const btnBack = document.getElementById("backspace");

let expr = "";  // 표현식 문자열(예: "12+3*4")
let error = false;

const round10 = (n, p = 12) => Number(Number(n).toFixed(p));
const format = (s) => s; // 입력 중 포매팅은 생략(원하면 결과만 포매팅)
const update = () => display.value = format(expr);

const clearAll = () => { expr = ""; error = false; update(); };
const append = (s) => { expr += s; update(); };

buttons.addEventListener("click", (e) => {
  const b = e.target.closest("button"); if (!b) return;
  const num = b.dataset.number;
  const act = b.dataset.action;

  if (error && act !== "clear") clearAll();

  if (num !== undefined) {
    // 소수점 중복 방지(현재 토큰 기준)
    if (num === ".") {
      const last = expr.split(/[\+\-\*\/\(\)]/).at(-1) ?? "";
      if (last.includes(".")) return;
      if (last === "") expr += "0";
    }
    append(num);
    return;
  }

  if (act === "clear") { clearAll(); return; }
  if (["+", "-", "*", "/", "(", ")"].includes(act)) {
    // 연속 연산자 방지(단항 - 예외)
    const last = expr.trim().slice(-1);
    if (["+", "*", "/"].includes(last) && ["+", "*", "/"].includes(act)) {
      expr = expr.slice(0, -1) + act; update(); return;
    }
    append(act);
    return;
  }
  if (act === "=") {
    try {
      const val = evaluateExpression(expr);
      const rounded = round10(val);
      expr = String(rounded);
      update();
    } catch (err) {
      expr = "오류";
      error = true;
      update();
    }
  }
});

btnBack.addEventListener("click", () => {
  if (!expr || error) { clearAll(); return; }
  expr = expr.slice(0, -1); update();
});
btnNegate.addEventListener("click", () => {
  // 가장 최근 숫자 토큰에 +/- 적용: ... + ( -token )
  if (error) { clearAll(); return; }
  const m = expr.match(/(.*?)([\d\.]+)$|$/); // 끝 숫자 토큰
  if (!m || !m[2]) { // 없으면 전체를 괄호 부호로 감싸기 시도
    if (expr) expr = `(-1*(${expr}))`;
    update(); return;
  }
  const head = m[1] ?? "";
  const token = m[2];
  // 이미 음수면 제거, 아니면 음수로
  if (/[\+\-\*\/\(\)]-$/.test(head)) {
    expr = head.slice(0, -1) + token; // ... + token
  } else {
    expr = `${head}(-${token})`;
  }
  update();
});

// 키보드 지원
window.addEventListener("keydown", (e) => {
  if (error && e.key !== "Escape") clearAll();
  if (/^\d$/.test(e.key)) { append(e.key); return; }
  if (e.key === ".") {
    const last = expr.split(/[\+\-\*\/\(\)]/).at(-1) ?? "";
    if (last.includes(".")) return;
    if (last === "") expr += "0";
    append(".");
    return;
  }
  if (["+", "-", "*", "/", "(", ")"].includes(e.key)) { append(e.key); return; }
  if (e.key === "Backspace") { btnBack.click(); return; }
  if (e.key === "Escape") { clearAll(); return; }
  if (e.key === "Enter" || e.key === "=") {
    buttons.querySelector('[data-action="="]').click(); return;
  }
});
```

> 이 버전은 **우선순위**와 **괄호**까지 다룹니다.
> 실무에서는 결과 포매팅/입력 제한(예: `..`, `()+`, `*-`)을 더 강하게 적용하세요.

---

## 6. 모듈화(ESM) 폴더 구조 & 코드

```
/calc
  index.html
  styles.css
  app.v2.js
  parser.js
```

`index.html`에서 모듈 스크립트:

```html
<script type="module" src="./app.v2.js"></script>
```

브라우저/로컬 파일 제한을 피하려면 **간단한 정적 서버**(예: `npx serve`)로 띄우세요.

---

## 7. 접근성(a11y) & 반응형 팁

- 루트에 `role="application"`/`aria-label`로 목적 알림
- 디스플레이에 `aria-live="polite"`로 결과 변화를 스크린리더에 전달
- 버튼은 `<button>` 유지(키보드 포커스/역할 자동)
- 포커스 스타일 커스터마이즈: `:focus-visible`로 시각 강조
- 모바일: 버튼 터치 영역 **최소 44×44px**, CSS 그리드 gap 충분히 확보
- 오류 시 `display`를 `"오류"`로 명확히 표기, `C`로만 초기화되게 유지

---

## 8. 간단 테스트 & 디버깅 체크리스트

### 수동 테스트 시나리오
1. `1 + 2 =` → `3`
2. `1 + 2 * 3 =` → **V1: 9** / **V3: 7**
3. `(1 + 2) * 3 =` → 9
4. `0.1 + 0.2 =` → 0.3 (정밀 보정 확인)
5. `1 / 0 =` → 오류
6. Backspace, +/- 정상 작동
7. 연속 `=` : 마지막 연산 반복 설계 시(선택) 동작 확인

### 코드 스니펫(간단 어설션)

```html
<script type="module">
  import { evaluateExpression } from './parser.js';
  const T = (expr, expect) => {
    const got = Number(evaluateExpression(expr).toFixed(12));
    const want = Number(expect.toFixed(12));
    console.assert(got === want, `${expr} === ${expect} :: got ${got}`);
  };
  T("1+2*3", 7);
  T("(1+2)*3", 9);
  T("0.1+0.2", 0.3);
  T("2*(3+4)/5", 2.8);
  console.log("테스트 완료");
</script>
```

---

## 9. 확장 아이디어

- **히스토리/메모리**: M+, M-, MR, MC
- **반복 `=` 연산**: `12 + 3 =`(15) → 다시 `=`(18) → `=`(21)
- **공학용**: sin/cos/tan, √, ^(거듭제곱), log, `%`
- **테마**: 라이트/다크 토글 + `prefers-color-scheme` 연동
- **i18n**: 소수점 기호/그룹 구분자 지역화

---

## 전체 코드 모음 (요약본)

### `index.html`

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>계산기 (우선순위 지원)</title>
  <link rel="stylesheet" href="styles.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
  <div class="calculator" role="application" aria-label="계산기">
    <input type="text" id="display" readonly aria-live="polite" />
    <div class="buttons">
      <button data-action="clear">C</button>
      <button data-action="/">÷</button>
      <button data-action="*">×</button>
      <button data-action="-">−</button>

      <button data-number="7">7</button>
      <button data-number="8">8</button>
      <button data-number="9">9</button>
      <button data-action="+">+</button>

      <button data-number="4">4</button>
      <button data-number="5">5</button>
      <button data-number="6">6</button>
      <button data-action="=">=</button>

      <button data-number="1">1</button>
      <button data-number="2">2</button>
      <button data-number="3">3</button>
      <button data-number="0" class="zero">0</button>
      <button data-number=".">.</button>
    </div>
    <div class="row">
      <button id="negate" title="부호 전환">+/-</button>
      <button id="backspace" title="한 글자 지우기">←</button>
    </div>
    <div class="row">
      <button data-action="(">(</button>
      <button data-action=")">)</button>
    </div>
  </div>

  <script type="module" src="./app.v2.js"></script>
</body>
</html>
```

### `styles.css`

```css
:root { --gap: .5rem; --bg: #f9f9f9; --border: #cfcfcf; }
* { box-sizing: border-box; }
body { display:flex; justify-content:center; margin:40px 8px; font-family: system-ui, sans-serif; }
.calculator { width: min(92vw, 320px); background: var(--bg); border:1px solid var(--border); border-radius:12px; padding:1rem; }
#display { width:100%; height:56px; font-size:1.8rem; text-align:right; padding:.6rem .8rem; margin-bottom:.8rem; border:1px solid var(--border); border-radius:10px; background:#fff; }
.buttons { display:grid; grid-template-columns: repeat(4,1fr); gap: var(--gap); }
.row { display:grid; grid-template-columns: repeat(2,1fr); gap: var(--gap); margin-top: var(--gap); }
button { padding:1rem .5rem; font-size:1.1rem; cursor:pointer; border:1px solid var(--border); border-radius:10px; background:#fff; }
button.zero { grid-column: span 2; }
button:focus-visible { outline:3px solid #4c8bf5; outline-offset: 2px; }
button:active { transform: scale(.98); }
```

### `parser.js`

```js
const OPS = {
  "+": { prec: 1, assoc: "L", fn: (a, b) => a + b },
  "-": { prec: 1, assoc: "L", fn: (a, b) => a - b },
  "*": { prec: 2, assoc: "L", fn: (a, b) => a * b },
  "/": { prec: 2, assoc: "L", fn: (a, b) => b === 0 ? Infinity : a / b },
};

export function tokenize(expr) {
  const tokens = []; let num = "";
  const pushNum = () => { if (num !== "") { tokens.push({ type: "num", value: Number(num) }); num = ""; } };
  for (let i = 0; i < expr.length; i++) {
    const ch = expr[i];
    if (/\d|\./.test(ch)) { num += ch; continue; }
    if (ch === " " || ch === "\t") { continue; }
    if (ch in OPS || ch === "(" || ch === ")") { pushNum(); tokens.push({ type: "op", value: ch }); continue; }
    if (ch === "-" && (tokens.length === 0 || (tokens.at(-1).type === "op" && tokens.at(-1).value !== ")"))) { num += ch; continue; }
    throw new Error("잘못된 문자: " + ch);
  }
  pushNum(); return tokens;
}

export function toRPN(tokens) {
  const out = [], stack = [];
  for (const t of tokens) {
    if (t.type === "num") out.push(t);
    else if (t.type === "op") {
      const v = t.value;
      if (v in OPS) {
        const o1 = OPS[v];
        while (stack.length) {
          const top = stack.at(-1).value;
          if (!(top in OPS)) break;
          const o2 = OPS[top];
          const higher = (o2.prec > o1.prec) || (o2.prec === o1.prec && o1.assoc === "L");
          if (higher) out.push(stack.pop()); else break;
        }
        stack.push(t);
      } else if (v === "(") stack.push(t);
      else if (v === ")") {
        while (stack.length && stack.at(-1).value !== "(") out.push(stack.pop());
        if (!stack.length) throw new Error("괄호 불일치");
        stack.pop();
      }
    }
  }
  while (stack.length) {
    const s = stack.pop();
    if (s.value === "(" || s.value === ")") throw new Error("괄호 불일치");
    out.push(s);
  }
  return out;
}

export function evalRPN(rpn) {
  const st = [];
  for (const t of rpn) {
    if (t.type === "num") st.push(t.value);
    else {
      const op = t.value;
      if (!(op in OPS)) throw new Error("알 수 없는 연산자");
      const b = st.pop(), a = st.pop();
      if (a === undefined || b === undefined) throw new Error("피연산자 부족");
      const r = OPS[op].fn(a, b);
      if (!isFinite(r)) throw new Error("0으로 나눔");
      st.push(r);
    }
  }
  if (st.length !== 1) throw new Error("평가 오류");
  return st[0];
}

export function evaluateExpression(expr) {
  return evalRPN(toRPN(tokenize(expr)));
}
```

### `app.v2.js`

```js
import { evaluateExpression } from './parser.js';

const display = document.getElementById("display");
const buttons = document.querySelector(".buttons");
const btnNegate = document.getElementById("negate");
const btnBack = document.getElementById("backspace");

let expr = "";
let error = false;

const round10 = (n, p = 12) => Number(Number(n).toFixed(p));
const update = () => display.value = String(expr ?? "");
const clearAll = () => { expr = ""; error = false; update(); };
const append = (s) => { expr += s; update(); };

buttons.addEventListener("click", (e) => {
  const b = e.target.closest("button"); if (!b) return;
  const num = b.dataset.number;
  const act = b.dataset.action;

  if (error && act !== "clear") clearAll();

  if (num !== undefined) {
    if (num === ".") {
      const last = expr.split(/[\+\-\*\/\(\)]/).at(-1) ?? "";
      if (last.includes(".")) return;
      if (last === "") expr += "0";
    }
    append(num); return;
  }

  if (act === "clear") { clearAll(); return; }
  if (["+", "-", "*", "/", "(", ")"].includes(act)) {
    const last = expr.trim().slice(-1);
    if (["+", "*", "/"].includes(last) && ["+", "*", "/"].includes(act)) {
      expr = expr.slice(0, -1) + act; update(); return;
    }
    append(act); return;
  }
  if (act === "=") {
    try {
      const val = evaluateExpression(expr);
      expr = String(round10(val));
      update();
    } catch {
      expr = "오류"; error = true; update();
    }
  }
});

btnBack.addEventListener("click", () => {
  if (!expr || error) { clearAll(); return; }
  expr = expr.slice(0, -1); update();
});
btnNegate.addEventListener("click", () => {
  if (error) { clearAll(); return; }
  const m = expr.match(/(.*?)([\d\.]+)$|$/);
  if (!m || !m[2]) { if (expr) expr = `(-1*(${expr}))`; update(); return; }
  const head = m[1] ?? "", token = m[2];
  if (/[\+\-\*\/\(\)]-$/.test(head)) expr = head.slice(0,-1) + token;
  else expr = `${head}(-${token})`;
  update();
});

window.addEventListener("keydown", (e) => {
  if (error && e.key !== "Escape") clearAll();
  if (/^\d$/.test(e.key)) { append(e.key); return; }
  if (e.key === ".") {
    const last = expr.split(/[\+\-\*\/\(\)]/).at(-1) ?? "";
    if (last.includes(".")) return;
    if (last === "") expr += "0";
    append("."); return;
  }
  if (["+", "-", "*", "/", "(", ")"].includes(e.key)) { append(e.key); return; }
  if (e.key === "Backspace") { btnBack.click(); return; }
  if (e.key === "Escape") { clearAll(); return; }
  if (e.key === "Enter" || e.key === "=") {
    document.querySelector('[data-action="="]').click(); return;
  }
});
```

---

## 마무리

- **V1**: 단일 상태머신(좌→우)로 빠르게 동작 확인
- **V2**: 키보드/부호/백스페이스/정밀 보정/표시 개선
- **V3**: **표현식 파싱(Shunting-yard)** 으로 우선순위·괄호까지 완성
