---
layout: post
title: Java - 동기화
date: 2025-07-29 20:20:23 +0900
category: Java
---
# 동기화 (synchronized)

## 1. 개념
**동기화(synchronization)**는 멀티스레드 환경에서 여러 스레드가 동시에 공유 자원(변수, 객체 등)에 접근할 때 발생할 수 있는 **경쟁 조건(race condition)**을 방지하기 위해 사용한다.  
Java의 `synchronized` 키워드는 **임계 구역(critical section)**을 만들어 한 번에 하나의 스레드만 해당 코드 블록 또는 메서드에 접근할 수 있도록 보장한다.

---

## 2. 필요성 (Race Condition 예시)
```java
class Counter {
    private int count = 0;

    public void increment() {
        count++; // count = count + 1 (read-modify-write)
    }

    public int getCount() {
        return count;
    }
}

public class RaceConditionExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) counter.increment();
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) counter.increment();
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("최종 카운트: " + counter.getCount());
        // 기대값: 20000, 실제 결과는 종종 20000 미만 발생
    }
}
```

위 코드에서 `count++`은 원자적이지 않아, 여러 스레드가 동시에 실행 시 결과가 꼬일 수 있다.

---

## 3. synchronized 사용법

### 3.1 동기화 메서드 (인스턴스 메서드 동기화)
```java
public synchronized void increment() {
    count++;
}
```
- `synchronized`가 붙은 인스턴스 메서드는 **해당 객체의 인스턴스(객체 자체)를 잠금(lock)**  
- 한 스레드가 이 메서드 실행 중일 때, 다른 스레드는 같은 객체의 동기화 메서드를 실행하지 못한다.

### 3.2 동기화 블록
```java
public void increment() {
    synchronized(this) {
        count++;
    }
}
```
- `this`는 현재 객체를 의미하며, 동기화 메서드와 동작이 동일하다.
- 특정 코드 범위만 잠글 수 있어 성능 최적화 가능.

### 3.3 클래스(static) 메서드 동기화
```java
public static synchronized void staticMethod() {
    // 클래스 객체(Class 객체)를 잠금
}
```
- `static synchronized`는 **클래스 객체(Class object)를 잠금**  
- 인스턴스가 아닌 클래스 단위에서 동기화가 필요할 때 사용

### 3.4 동기화 블록에서 다른 객체로 잠금 범위 지정
```java
private final Object lock = new Object();

public void safeIncrement() {
    synchronized(lock) {
        count++;
    }
}
```
- 별도의 락 객체를 만들어 동기화하면, 필요한 부분만 잠글 수 있고 `this` 잠금보다 더 유연함.

---

## 4. 동기화 예제 (블록 사용)

```java
public class SyncExample {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized(lock) {
            count++;
        }
    }

    public int getCount() {
        synchronized(lock) {
            return count;
        }
    }
}
```

---

## 5. 동기화 작동 원리
- `synchronized`는 **모니터 락(monitor lock)**을 이용해 임계 영역 진입 시 락 획득, 종료 시 락 해제
- 락을 획득하지 못한 스레드는 대기 상태로 들어가며, 락이 해제되면 대기 중인 스레드 중 하나가 락을 획득함

---

## 6. 주의사항 및 단점
- **과도한 동기화는 성능 저하** 원인  
- **교착 상태(Deadlock)** 발생 위험 (서로 락을 점유하며 상대 락 해제를 기다림)  
- **락 범위 최소화**가 중요 (필요한 부분만 잠금)  
- `synchronized`는 재진입 가능 (한 스레드가 이미 락을 가지고 있으면 다시 들어와도 문제 없음)

---

## 7. 동기화 vs volatile 차이점
- `volatile`은 변수의 가시성을 보장하지만, 복합 연산(증가 등)의 원자성을 보장하지 않음  
- `synchronized`는 원자성과 가시성을 모두 보장

---

## 8. synchronized 예외 처리와 락 해제
- `synchronized` 블록 내에서 예외가 발생해도 락은 자동으로 해제됨 (finally 구문 필요 없음)

---

## 9. 예제: 두 스레드 안전하게 증가시키기

```java
public class SafeCounter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }

    public static void main(String[] args) throws InterruptedException {
        SafeCounter counter = new SafeCounter();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) counter.increment();
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) counter.increment();
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("최종 카운트: " + counter.getCount()); // 20000 (안전)
    }
}
```

---

## 10. 결론
- `synchronized`는 Java에서 가장 기본적이고 직관적인 동기화 수단  
- 멀티스레드 환경에서 공유 자원의 일관성과 안전성을 위해 필수  
- 복잡한 동시성 문제나 고성능이 필요하면 `java.util.concurrent` 패키지 내 락, 원자 변수, 동시성 컬렉션 등을 검토  
- 락 범위를 최소화하고, Deadlock 방지 설계가 중요