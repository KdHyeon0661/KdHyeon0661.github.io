---
layout: post
title: Java - 동기화
date: 2025-07-29 20:20:23 +0900
category: Java
---
# 동기화(synchronized)

## 1. 개념 — 왜 synchronized 인가?

멀티스레드 환경에서 여러 스레드가 **공유 상태**(필드, 컬렉션 등)를 동시에 읽고/쓰면 **경쟁 조건(race condition)**, **가시성 문제**(다른 코어에 변경이 보이지 않음), **명령 재배치**로 인한 **불변식 붕괴**가 발생한다. `synchronized`는 **모니터 락(monitor lock)**을 사용해 임계 구역을 보호하고, **원자성 + 가시성 + 순서 보장**을 동시에 제공한다.

- **원자성**: 임계 구역 내 복합 연산(읽기→수정→쓰기)을 방해 없이 수행
- **가시성**: 락 해제 시 쓰기가 **배출(release)** 되고, 다음 락 획득 시 쓰기가 **관측(acquire)** 됨
- **순서**: 임계 구역 전후의 재배치 억제(자바 메모리 모델 JMM 규정)

---

## 2. 필요성 — Race Condition 예시와 수정

### 2.1 경합 발생 코드
```java
class Counter {
    private int count = 0;

    public void increment() {
        count++; // read-modify-write: 원자적 아님
    }
    public int getCount() { return count; }
}

public class RaceConditionExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Thread t1 = new Thread(() -> { for (int i = 0; i < 10_000; i++) counter.increment(); });
        Thread t2 = new Thread(() -> { for (int i = 0; i < 10_000; i++) counter.increment(); });
        t1.start(); t2.start(); t1.join(); t2.join();
        System.out.println("최종 카운트: " + counter.getCount()); // 종종 20000 미만
    }
}
```

### 2.2 synchronized 로 수정
```java
class SafeCounter {
    private int count = 0;

    public synchronized void increment() { // 인스턴스 모니터 잠금
        count++;
    }
    public synchronized int getCount() {
        return count;
    }
}
```

---

## 3. 메모리 모델과 모니터 — 정확히 무엇을 보장하나?

- 바이트코드 관점: `monitorenter`(임계 구역 진입) / `monitorexit`(탈출)
- **happens-before**:  
  - 어떤 스레드가 **모니터를 해제**(`monitorexit`)한 시점의 쓰기는  
  - 그 모니터를 **이후에 획득**(`monitorenter`)하는 다른 스레드에게 **보인다**.
- **재진입성(reentrancy)**: 동일 스레드가 같은 모니터를 중복 획득 가능(진입 카운트 증가).  
- **예외/return 시 락 해제**: 임계 구역을 빠져나갈 때(`monitorexit`) 자동 해제(try/finally 불필요).

> 요약: `synchronized`는 단순 상호배제뿐 아니라 **가시성/순서**까지 함께 제공한다.

---

## 4. 사용 형태 — 메서드, 블록, static, 커스텀 락

### 4.1 인스턴스 메서드 동기화
```java
public synchronized void increment() { count++; } // this 모니터
```

### 4.2 블록 동기화(락 범위 최소화)
```java
private final Object lock = new Object();
public void increment() {
    // 임계 구역만 잠금 → 경쟁 감소
    synchronized (lock) {
        count++;
    }
}
```

### 4.3 static 동기화(클래스 모니터)
```java
public static synchronized void resetAll() { /* Class<?> 모니터 */ }
```

### 4.4 잠그지 말아야 할 대상
- **`this` 공개 상태**, **문자열 상수**, **오토박싱된 Integer/Long** 등 **외부 코드가 공유할 수 있는 객체**  
→ 교착/간섭 위험. **`private final Object lock = new Object();`** 권장.

---

## 5. synchronized vs volatile — 언제 무엇을?

| 항목 | synchronized | volatile |
|---|---|---|
| 보장 | 원자성 + 가시성 + 순서 | **가시성 + 순서(쓰기 전후)** |
| 대상 | 임계 구역(복합연산) | **단일 변수**의 읽기/쓰기 |
| 사용 예 | 카운터 증가, 컬렉션 조작 | 종료 플래그, 구성 완료 플래그 |
| 대기/신호 | `wait/notify` 필요 | 불가 |

**규칙**: **복합 연산**(검사 후 실행, 증가·감소, 두 개 이상 필드 일관성)은 `synchronized`(또는 원자 클래스/Lock). 단일 플래그 가시성만 필요하면 `volatile`.

---

## 6. 안전 패턴 — 가드된 블록, 퍼블리시/이스케이프 회피

### 6.1 Guarded Suspension (조건 대기)
```java
final class Mailbox<T> {
    private final Object lock = new Object();
    private T message; // null=empty

    public void put(T m) throws InterruptedException {
        synchronized (lock) {
            while (message != null) lock.wait(); // while 필수
            message = m;
            lock.notifyAll(); // 상태→신호 순서
        }
    }
    public T take() throws InterruptedException {
        synchronized (lock) {
            while (message == null) lock.wait();
            T m = message; message = null;
            lock.notifyAll();
            return m;
        }
    }
}
```

### 6.2 안전한 공개(publish)와 이스케이프 방지
```java
public final class Holder {
    private int x, y;
    public synchronized void set(int nx, int ny) { x = nx; y = ny; }
    public synchronized int sum() { return x + y; } // 일관성 유지

    // ❌ 생성자에서 this를 다른 스레드에 공개하면(리스너 등록 등) 불완전 상태 노출 가능
}
```

---

## 7. 데드락/라이브락/기아 — 재현과 방지

### 7.1 데드락 재현
```java
class A { final Object lock = new Object(); }
class B { final Object lock = new Object(); }
A a = new A(); B b = new B();

Thread t1 = new Thread(() -> {
    synchronized (a.lock) {
        sleep(10);
        synchronized (b.lock) { /* ... */ }
    }
});
Thread t2 = new Thread(() -> {
    synchronized (b.lock) {
        sleep(10);
        synchronized (a.lock) { /* ... */ }
    }
});
t1.start(); t2.start();
```

### 7.2 방지 기법
- **글로벌 락 순서 규약**: 항상 `a -> b` 순서로 획득
- **락 병합(코어스닝)**: 정말 묶여야 하는 자원만 단일 락으로
- **타임아웃/재시도**: `ReentrantLock.tryLock(timeout)` (고수준 대안)
- **락 수 최소화/네스팅 회피**

---

## 8. 성능 최적화 — 경쟁 줄이기, 락 분할/스트라이핑

### 8.1 락 범위 최소화
```java
public int sumList(List<Integer> src) {
    int local; // 임계 구역 바깥에서 준비
    synchronized (lock) { local = sharedValue; }
    // 긴 계산은 락 밖에서
    return local + compute(src);
}
```

### 8.2 락 분할(Lock Splitting)
```java
final Object readLock = new Object();
final Object writeLock = new Object();

public int safeRead() { synchronized (readLock) { return read; } }
public void safeWrite(int v) { synchronized (writeLock) { write = v; } }
```

### 8.3 락 스트라이핑(Striping) — 해시 버킷별 락
```java
class StripedCounter {
    private static final int N = 16;
    private final Object[] locks = new Object[N];
    private final int[] counts = new int[N];
    public StripedCounter() { for (int i=0;i<N;i++) locks[i]=new Object(); }

    public void inc(int key) {
        int idx = (key ^ (key>>>16)) & (N-1);
        synchronized (locks[idx]) { counts[idx]++; }
    }
    public int sum() {
        int s=0;
        for (int i=0;i<N;i++) synchronized (locks[i]) { s+=counts[i]; }
        return s;
    }
}
```

> 컨테이션이 높은 경우 **ConcurrentHashMap**, **LongAdder** 같은 **전용 동시성 자료구조**가 더 효율적이다.

---

## 9. 컬렉션 동기화 — 올바른 사용

### 9.1 Collections.synchronizedXxx 래퍼
```java
List<Integer> list = Collections.synchronizedList(new ArrayList<>());
```
**주의**: **반복(iteration)** 시에도 **동일 락으로 감싸야** 일관성/안전 보장.
```java
synchronized (list) {
    for (Integer x : list) { /* ... */ }
}
```

### 9.2 Concurrent 컬렉션 권장
- 높은 동시성에서 `ConcurrentHashMap`, `CopyOnWriteArrayList` 등 사용.
- 단, `CopyOnWriteArrayList`는 **쓰기 비용↑, 읽기 매우 빠름**(스냅샷 복사).

---

## 10. Lazy 초기화 — DCL과 대안

### 10.1 잘못된 DCL(옛 JMM) → 현재는 `volatile`로 가능
```java
class LazyHolder {
    private volatile Expensive obj; // volatile 중요
    public Expensive get() {
        Expensive r = obj;
        if (r == null) {
            synchronized (this) {
                r = obj;
                if (r == null) obj = r = new Expensive();
            }
        }
        return r;
    }
}
```

### 10.2 권장: 초기화 홀더 패턴
```java
class Service {
    private static class Holder { static final Expensive INSTANCE = new Expensive(); }
    public static Expensive getInstance() { return Holder.INSTANCE; }
}
```

---

## 11. 예외/리턴과 락 해제 — 자동 보장

```java
public void doWork() {
    synchronized (lock) {
        if (somethingBad()) throw new IllegalStateException(); // monitoexit 보장
    } // 예외여도 여기서 해제됨
}
```

---

## 12. wait/notify와의 결합 — 올바른 가드 루프

- **항상 while**: 스퍼리어스 웨이크업 방지 + 조건 재검사  
- **상태→신호 순서**: 상태를 먼저 업데이트, 그 다음 `notifyAll()`  
- **하나의 락**에서 상태·대기·신호 수행(가시성)

자세한 내용은 `wait()/notify()/notifyAll()` 정리 참고(가드 블록 패턴 동일).

---

## 13. ReentrantLock 등 대안과 비교

| 기능 | synchronized | ReentrantLock |
|---|---|---|
| 상호배제 | 가능 | 가능 |
| 가시성/순서 | 보장 | 보장 |
| 재진입 | 가능 | 가능 |
| 조건 변수 | `wait/notify(All)` 1개 wait set | `Condition` **여러 개** 분리 |
| 타임아웃 락 획득 | 불가 | `tryLock(timeout)` |
| 공정성 정책 | 없음 | **공정/비공정** 선택 |
| 인터럽트 가능한 획득 | 불가 | `lockInterruptibly()` |
| 사용 난이도 | 단순 | 유연하나 복잡 |

- **여러 조건이 섞이는 경우** → `ReentrantLock` + `Condition`으로 분리  
- **대기 시간 제한/인터럽트 민감** → `tryLock(timeout)`, `lockInterruptibly()`  
- 단순 상호배제/가시성만 필요 → `synchronized`가 가장 간단하고 안전

---

## 14. 스레드 안전 카운터/게터 — 컴파운드 액션 보장

```java
public final class Bank {
    private long balance;
    private final Object lock = new Object();

    public void deposit(long amount) {
        if (amount <= 0) throw new IllegalArgumentException();
        synchronized (lock) { balance += amount; }
    }
    public void transferTo(Bank other, long amount) {
        if (this == other) return;
        // 락 순서 규약으로 데드락 방지
        Bank first = this.hashCode() < other.hashCode() ? this : other;
        Bank second = first == this ? other : this;

        synchronized (first.lock) {
            synchronized (second.lock) {
                if (balance < amount) throw new IllegalStateException("부족");
                this.balance -= amount;
                other.balance += amount;
            }
        }
    }
    public long getBalance() { synchronized (lock) { return balance; } }
}
```

---

## 15. 성능과 수학 — 락으로 인한 한계 직관

**암달의 법칙(Amdahl’s law)**  
병렬화 불가능 비율을 \( f \), 스레드 수를 \( N \)라 하면 예상 속도 향상은
$$
S(N) = \frac{1}{f + \frac{1-f}{N}}
$$
임계 구역이 길수록 \( f \uparrow \) → **상한이 빠르게 낮아진다**.  
→ **임계 구역을 짧게**, **락 분할/스트라이핑**, **경쟁 회피 자료구조** 사용이 중요.

---

## 16. 테스트/검증 팁

- **JMH**(마이크로벤치) 없이 직관적 루프 비교는 **JIT 최적화**에 속기 쉽다.  
- **로그를 임계 구역 밖에서** 출력(출력은 매우 느리고 락 영향 가림).  
- **Race 재현은 비결정적** → 반복/장시간/다중 코어에서 확인.  
- **ThreadMXBean, Flight Recorder, async-profiler** 등으로 락 경합 지점 파악.

---

## 17. FAQ

- **Q. synchronized가 느린가요?**  
  최근 JVM은 빠르다. **과도한 공유/긴 임계 구역/잘못된 설계**가 느리게 만드는 주범.
- **Q. 읽기는 락 없이 가능?**  
  쓰기 동반 시 **가시성 보장 필요**. 읽기 전용 스냅샷이면 가능하나 일관성 요구 시 락 필요.
- **Q. 중첩 락에서 wait()?**  
  `wait()`는 **해당 모니터만 해제**. 다른 락을 들고 있으면 교착 위험. 가급적 **단일 락 보유 상태**에서 `wait()`.

---

## 18. 요약 체크리스트

- [ ] 임계 구역은 **짧게**. 필요한 코드만 잠금.  
- [ ] **커스텀 락 객체**(`private final Object`) 사용, 공개 객체 잠금 금지.  
- [ ] **상태는 같은 락으로만** 읽고/쓴다.  
- [ ] 조건 대기는 **while + wait()**, **상태→신호 순서**.  
- [ ] 여러 락이면 **순서 규약**을 두고 일관되게 획득.  
- [ ] 복잡한 조건·타임아웃·인터럽트 필요 시 **ReentrantLock/Condition** 고려.  
- [ ] 높은 동시성에는 **Concurrent 자료구조**(ConcurrentHashMap/LongAdder 등) 우선.  
- [ ] 단일 플래그 가시성만 필요하면 **volatile**.  
- [ ] 벤치마크는 **JMH**, 병목은 **프로파일러/락 분석**으로 확인.

---

## 19. 종합 예제 — 경합 줄이기 + 안전한 반복

```java
import java.util.*;

public class SyncExample {
    private final Object lock = new Object();
    private final List<String> logs = new ArrayList<>();
    private int count;

    // 임계 구역 최소화
    public void addAndLog(String msg) {
        int newCount;
        synchronized (lock) {
            count++;
            newCount = count;         // 필요한 최소 정보만 복사
            logs.add(msg);
        }
        // 느린 작업(포맷팅/IO)은 락 밖에서
        if (newCount % 1000 == 0) {
            System.out.println("Processed: " + newCount);
        }
    }

    // 안전한 반복: 동일 락으로 감싸기
    public void dump() {
        synchronized (lock) {
            for (String s : logs) {
                System.out.println(s);
            }
        }
    }

    public int getCount() { synchronized (lock) { return count; } }
}
```

---

## 20. 결론

- `synchronized`는 **가장 단순하고 강력한 기본 동기화 수단**으로, **원자성·가시성·순서**를 동시에 보장한다.
- **락 범위 최소화**, **상태-신호 규율**, **락 순서 규약**만 지켜도 대부분의 동시성 결함을 예방할 수 있다.
- 경합이 높아지면 **락 분할/스트라이핑**, **Concurrent 자료구조**, **ReentrantLock/Condition**으로 단계적으로 추상화/최적화하라.
- 측정 없이 최적화하지 말고(**JMH/프로파일링**) 병목을 데이터로 확인하라.

---
```java
// 간단한 실험 코드: 경쟁 재현 vs. 동기화 비교 (주의: 결과 비결정적)
public class CompareSync {
    static class Unsafe {
        int x;
        void inc() { x++; }
    }
    static class Safe {
        int x; final Object lock = new Object();
        void inc() { synchronized(lock){ x++; } }
    }
    public static void main(String[] args) throws Exception {
        runUnsafe();
        runSafe();
    }
    static void runUnsafe() throws Exception {
        Unsafe u = new Unsafe();
        Thread t1 = new Thread(() -> { for (int i=0;i<200_000;i++) u.inc(); });
        Thread t2 = new Thread(() -> { for (int i=0;i<200_000;i++) u.inc(); });
        t1.start(); t2.start(); t1.join(); t2.join();
        System.out.println("Unsafe: " + u.x); // 기대 400000, 종종 미달
    }
    static void runSafe() throws Exception {
        Safe s = new Safe();
        Thread t1 = new Thread(() -> { for (int i=0;i<200_000;i++) s.inc(); });
        Thread t2 = new Thread(() -> { for (int i=0;i<200_000;i++) s.inc(); });
        t1.start(); t2.start(); t1.join(); t2.join();
        System.out.println("Safe: " + s.x);   // 400000
    }
}
```

---
**참고 수식(직관)** — 임계 구역 비율 \(f\) 가 커질수록 확장성 저하:
$$
S(N) = \frac{1}{f + \frac{1-f}{N}}
$$
→ 임계 구역/공유 데이터 구조 자체를 줄이는 것이 본질적 성능 최적화다.






