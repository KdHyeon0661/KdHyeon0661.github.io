---
layout: post
title: 파이썬 심화 - 메타프로그래밍 (1)
date: 2025-11-30 22:25:23 +0900
category: 파이썬 심화
---
# 메타프로그래밍 (1)

## 메타프로그래밍과 함수 감싸기

### 동적 함수 생성과 수정
```python
print("="*60)
print("메타프로그래밍과 함수 감싸기")
print("="*60)

# 1. 함수 객체의 기본 구조 이해
print("1. 함수 객체의 기본 구조 이해:")

def example_function(x, y=10):
    """예제 함수입니다."""
    result = x + y
    return result

# 함수 객체의 속성들
print("함수 객체 속성:")
print(f"  __name__: {example_function.__name__}")
print(f"  __doc__: {example_function.__doc__}")
print(f"  __module__: {example_function.__module__}")
print(f"  __dict__: {example_function.__dict__}")
print(f"  __code__: {example_function.__code__}")
print(f"  __defaults__: {example_function.__defaults__}")

# 함수의 코드 객체 정보
print("\n코드 객체 정보:")
code_obj = example_function.__code__
print(f"  co_name: {code_obj.co_name}")
print(f"  co_argcount: {code_obj.co_argcount}")
print(f"  co_varnames: {code_obj.co_varnames}")
print(f"  co_consts: {code_obj.co_consts}")

# 2. 동적으로 함수 생성하기
print("\n2. 동적으로 함수 생성하기:")

import types

def create_dynamic_function(name, arg_names, body_code, docstring=None):
    """
    런타임에 함수를 동적으로 생성
    
    Args:
        name: 함수 이름
        arg_names: 인자 이름 리스트
        body_code: 함수 본문 코드 문자열
        docstring: 함수 설명문
    
    Returns:
        동적으로 생성된 함수 객체
    """
    # 함수 정의 템플릿
    func_template = f"""
def {name}({', '.join(arg_names)}):
    \"\"\"{docstring or '동적으로 생성된 함수'}\"\"\"
    {body_code}
"""
    
    # 네임스페이스 준비
    namespace = {}
    
    # 코드 컴파일 및 실행
    try:
        code_obj = compile(func_template, '<string>', 'exec')
        exec(code_obj, namespace)
    except SyntaxError as e:
        raise ValueError(f"함수 생성 중 문법 오류: {e}")
    
    # 생성된 함수 반환
    return namespace[name]

# 동적 함수 생성 예제
print("동적 함수 생성 예제:")

# 덧셈 함수 생성
add_func = create_dynamic_function(
    name="dynamic_add",
    arg_names=['a', 'b'],
    body_code="return a + b",
    docstring="두 수를 더하는 동적 함수"
)

# 곱셈 함수 생성
multiply_func = create_dynamic_function(
    name="dynamic_multiply",
    arg_names=['x', 'y', 'z'],
    body_code="result = x * y * z\nreturn result",
    docstring="세 수를 곱하는 동적 함수"
)

# 생성된 함수 사용
print(f"  {add_func.__name__}(3, 5) = {add_func(3, 5)}")
print(f"  {multiply_func.__name__}(2, 3, 4) = {multiply_func(2, 3, 4)}")
print(f"  {add_func.__doc__}")

# 3. 기존 함수 수정하기 (함수 감싸기)
print("\n3. 기존 함수 감싸기:")

def wrap_function(original_func, pre_hook=None, post_hook=None):
    """
    기존 함수를 감싸는 래퍼 함수 생성
    
    Args:
        original_func: 원본 함수
        pre_hook: 함수 실행 전 호출할 함수
        post_hook: 함수 실행 후 호출할 함수
    
    Returns:
        감싸진 새 함수
    """
    def wrapper(*args, **kwargs):
        # 전처리
        if pre_hook:
            pre_result = pre_hook(*args, **kwargs)
            if pre_result is not None:
                # 전처리 결과를 인자로 사용할 수 있도록 수정
                args, kwargs = pre_result if isinstance(pre_result, tuple) else (args, kwargs)
        
        # 원본 함수 실행
        result = original_func(*args, **kwargs)
        
        # 후처리
        if post_hook:
            post_result = post_hook(result, *args, **kwargs)
            if post_result is not None:
                result = post_result
        
        return result
    
    # 원본 함수의 메타데이터 복사
    wrapper.__name__ = f"wrapped_{original_func.__name__}"
    wrapper.__doc__ = original_func.__doc__
    wrapper.__module__ = original_func.__module__
    
    return wrapper

# 예제 함수
def calculate_sum(numbers):
    """숫자 리스트의 합계 계산"""
    return sum(numbers)

# 후크 함수들
def log_pre_hook(*args, **kwargs):
    """실행 전 로깅"""
    print(f"[PRE] 함수 실행 전: args={args}, kwargs={kwargs}")
    return args, kwargs

def log_post_hook(result, *args, **kwargs):
    """실행 후 로깅"""
    print(f"[POST] 함수 실행 결과: {result}")
    return result

def validate_input(*args, **kwargs):
    """입력 검증"""
    if not args or not isinstance(args[0], list):
        raise ValueError("리스트 타입의 인자가 필요합니다")
    
    if not all(isinstance(x, (int, float)) for x in args[0]):
        raise ValueError("모든 요소는 숫자여야 합니다")
    
    return args, kwargs

# 함수 감싸기 적용
print("함수 감싸기 예제:")

# 단순 래핑
simple_wrapped = wrap_function(calculate_sum)
print(f"  단순 래핑: {simple_wrapped.__name__}")
print(f"  결과: {simple_wrapped([1, 2, 3, 4, 5])}")

# 로깅 기능 추가
logged_wrapped = wrap_function(calculate_sum, pre_hook=log_pre_hook, post_hook=log_post_hook)
print(f"\n  로깅 래핑: {logged_wrapped.__name__}")
print(f"  결과: {logged_wrapped([1, 2, 3, 4, 5])}")

# 검증 기능 추가
validated_wrapped = wrap_function(calculate_sum, pre_hook=validate_input)
try:
    print(f"\n  검증 래핑: {validated_wrapped.__name__}")
    print(f"  유효한 입력: {validated_wrapped([1, 2, 3])}")
    print(f"  무효한 입력 시도: ", end="")
    validated_wrapped("문자열")
except ValueError as e:
    print(f"오류 발생: {e}")

# 4. 함수 시그니처 유지하기
print("\n4. 함수 시그니처 유지하기:")

import inspect
import functools

def preserve_signature_wrapper(original_func):
    """
    함수 시그니처를 보존하는 래퍼
    """
    @functools.wraps(original_func)
    def wrapper(*args, **kwargs):
        # 추가 로직
        print(f"[DEBUG] {original_func.__name__} 호출됨")
        print(f"  인자: args={args}, kwargs={kwargs}")
        
        # 원본 함수 실행
        result = original_func(*args, **kwargs)
        
        print(f"  결과: {result}")
        return result
    
    return wrapper

# 시그니처 비교를 위한 예제 함수
def process_data(name: str, count: int = 1, *, verbose: bool = False) -> list:
    """
    데이터 처리 함수
    
    Args:
        name: 데이터 이름
        count: 반복 횟수
        verbose: 상세 출력 여부
    
    Returns:
        처리된 데이터 리스트
    """
    if verbose:
        print(f"처리 중: {name}")
    
    return [name] * count

# 래핑 적용
wrapped_process = preserve_signature_wrapper(process_data)

print("시그니처 보존 비교:")
print(f"  원본 함수 이름: {process_data.__name__}")
print(f"  래핑 함수 이름: {wrapped_process.__name__}")
print(f"  원본 함수 설명: {process_data.__doc__[:50]}...")
print(f"  래핑 함수 설명: {wrapped_process.__doc__[:50]}...")

# 시그니처 확인
original_sig = inspect.signature(process_data)
wrapped_sig = inspect.signature(wrapped_process)

print(f"\n원본 시그니처: {original_sig}")
print(f"래핑 시그니처: {wrapped_sig}")

# 어노테이션 확인
print(f"\n원본 반환 타입: {process_data.__annotations__.get('return', '없음')}")
print(f"래핑 반환 타입: {wrapped_process.__annotations__.get('return', '없음')}")

# 5. 함수 성능 측정 래퍼
print("\n5. 성능 측정 래퍼 (실용적인 예제):")

import time
from contextlib import contextmanager

@contextmanager
def timer_context(name="작업"):
    """실행 시간 측정 컨텍스트 매니저"""
    start_time = time.perf_counter()
    try:
        yield
    finally:
        end_time = time.perf_counter()
        elapsed = end_time - start_time
        print(f"[TIMER] {name}: {elapsed:.6f}초")

def performance_wrapper(func):
    """함수 성능 측정 데코레이터"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        with timer_context(func.__name__):
            result = func(*args, **kwargs)
        return result
    return wrapper

def cache_wrapper(maxsize=128):
    """함수 결과 캐싱 데코레이터"""
    def decorator(func):
        cache = {}
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 캐시 키 생성
            cache_key = (
                args,
                tuple(sorted(kwargs.items())) if kwargs else None
            )
            
            # 캐시 히트
            if cache_key in cache:
                return cache[cache_key]
            
            # 캐시 미스 - 계산
            result = func(*args, **kwargs)
            
            # 캐시 저장 (LRU 방식)
            if len(cache) >= maxsize:
                # 가장 오래된 항목 제거
                oldest_key = next(iter(cache))
                del cache[oldest_key]
            
            cache[cache_key] = result
            return result
        
        # 캐시 관리 메서드 추가
        wrapper.clear_cache = lambda: cache.clear()
        wrapper.cache_info = lambda: {
            'size': len(cache),
            'maxsize': maxsize,
            'hits': 0,  # 실제 구현에서는 히트/미스 카운터 필요
            'misses': 0
        }
        
        return wrapper
    return decorator

# 성능 측정이 필요한 함수들
@performance_wrapper
@cache_wrapper(maxsize=100)
def fibonacci(n):
    """피보나치 수열 계산"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

@performance_wrapper
def slow_computation(x):
    """느린 계산 시뮬레이션"""
    time.sleep(0.1)
    return x * x

print("성능 측정 데코레이터 예제:")

# 피보나치 계산 (캐싱 효과 확인)
print("피보나치 수열 계산 (캐싱 적용):")
result1 = fibonacci(30)
print(f"  fibonacci(30) = {result1}")

result2 = fibonacci(30)  # 캐시 히트
print(f"  fibonacci(30) 다시 계산 = {result2} (캐시 히트)")

# 느린 계산
print("\n느린 계산 시뮬레이션:")
for i in range(3):
    result = slow_computation(i)
    print(f"  slow_computation({i}) = {result}")

# 6. 함수 체이닝 래퍼
print("\n6. 함수 체이닝 래퍼:")

class Pipeline:
    """함수 파이프라인 클래스"""
    
    def __init__(self, func=None):
        self.functions = []
        if func:
            self.functions.append(func)
    
    def __call__(self, *args, **kwargs):
        """파이프라인 실행"""
        if not self.functions:
            raise ValueError("파이프라인에 함수가 없습니다")
        
        result = None
        
        for i, func in enumerate(self.functions):
            if i == 0:
                # 첫 번째 함수
                result = func(*args, **kwargs)
            else:
                # 나머지 함수들
                result = func(result)
        
        return result
    
    def add(self, func):
        """함수 추가"""
        self.functions.append(func)
        return self
    
    def __rshift__(self, other):
        """>> 연산자 오버로딩으로 체이닝 지원"""
        if isinstance(other, Pipeline):
            self.functions.extend(other.functions)
        else:
            self.functions.append(other)
        return self

def pipeline_wrapper(*funcs):
    """함수 체이닝 데코레이터"""
    def decorator(main_func):
        @functools.wraps(main_func)
        def wrapper(*args, **kwargs):
            # 메인 함수 실행
            result = main_func(*args, **kwargs)
            
            # 체이닝된 함수들 실행
            for func in funcs:
                result = func(result)
            
            return result
        
        return wrapper
    return decorator

# 체이닝 예제
print("함수 체이닝 예제:")

# 기본 함수들
def read_data(source):
    """데이터 읽기"""
    print(f"  데이터 읽기: {source}")
    return f"data from {source}"

def clean_data(data):
    """데이터 정제"""
    print(f"  데이터 정제: {data}")
    return data.upper().replace(" ", "_")

def analyze_data(data):
    """데이터 분석"""
    print(f"  데이터 분석: {data}")
    return {"processed": data, "length": len(data)}

def save_data(result):
    """데이터 저장"""
    print(f"  데이터 저장: {result}")
    return True

# 파이프라인 생성
print("파이프라인 방식:")
pipeline = Pipeline(read_data) >> clean_data >> analyze_data >> save_data
result = pipeline("test source")
print(f"  최종 결과: {result}")

# 데코레이터 방식
print("\n데코레이터 방식:")
@pipeline_wrapper(clean_data, analyze_data, save_data)
def process_pipeline(source):
    return read_data(source)

result = process_pipeline("another source")
print(f"  최종 결과: {result}")
```

## 데코레이터 작성 시 함수 메타데이터 보존

### functools.wraps와 메타데이터 관리
```python
print("\n" + "="*60)
print("데코레이터 작성 시 함수 메타데이터 보존")
print("="*60)

# 1. functools.wraps의 중요성
print("1. functools.wraps의 중요성:")

def bad_decorator(func):
    """메타데이터를 보존하지 않는 나쁜 데코레이터"""
    def wrapper(*args, **kwargs):
        print(f"[BAD] {func.__name__} 호출")
        return func(*args, **kwargs)
    return wrapper

def good_decorator(func):
    """메타데이터를 보존하는 좋은 데코레이터"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"[GOOD] {func.__name__} 호출")
        return func(*args, **kwargs)
    return wrapper

# 테스트용 함수
def example_metadata_function(x: int, y: int = 10) -> int:
    """
    예제 함수 - 메타데이터가 풍부한 함수
    
    Args:
        x: 첫 번째 숫자
        y: 두 번째 숫자 (기본값 10)
    
    Returns:
        두 숫자의 합
    """
    return x + y

# 데코레이터 적용
bad_wrapped = bad_decorator(example_metadata_function)
good_wrapped = good_decorator(example_metadata_function)

print("메타데이터 보존 비교:")
print("원본 함수:")
print(f"  이름: {example_metadata_function.__name__}")
print(f"  설명: {example_metadata_function.__doc__.strip().splitlines()[0]}")
print(f"  모듈: {example_metadata_function.__module__}")
print(f"  어노테이션: {example_metadata_function.__annotations__}")

print("\n나쁜 데코레이터 적용 후:")
print(f"  이름: {bad_wrapped.__name__}")
print(f"  설명: {bad_wrapped.__doc__}")
print(f"  모듈: {bad_wrapped.__module__}")
print(f"  어노테이션: {bad_wrapped.__annotations__}")

print("\n좋은 데코레이터 적용 후:")
print(f"  이름: {good_wrapped.__name__}")
print(f"  설명: {good_wrapped.__doc__.strip().splitlines()[0]}")
print(f"  모듈: {good_wrapped.__module__}")
print(f"  어노테이션: {good_wrapped.__annotations__}")

# 2. inspect 모듈을 이용한 심층 비교
print("\n2. inspect 모듈을 이용한 심층 비교:")

import inspect

print("인스펙트 모듈로 시그니처 비교:")
original_sig = inspect.signature(example_metadata_function)
bad_sig = inspect.signature(bad_wrapped)
good_sig = inspect.signature(good_wrapped)

print(f"  원본 시그니처: {original_sig}")
print(f"  나쁜 데코레이터 시그니처: {bad_sig}")
print(f"  좋은 데코레이터 시그니처: {good_sig}")

print("\n소스 코드 비교:")
try:
    print(f"  원본 소스:\n{inspect.getsource(example_metadata_function)[:100]}...")
    print(f"  나쁜 데코레이터 소스:\n{inspect.getsource(bad_wrapped)[:100]}...")
    print(f"  좋은 데코레이터 소스:\n{inspect.getsource(good_wrapped)[:100]}...")
except Exception as e:
    print(f"  소스 가져오기 오류: {e}")

# 3. 커스텀 메타데이터 관리 데코레이터
print("\n3. 커스텀 메타데이터 관리 데코레이터:")

def enhanced_wraps(original_func):
    """향상된 메타데이터 보존 데코레이터"""
    def decorator(wrapper_func):
        # functools.wraps로 기본 메타데이터 복사
        wrapped = functools.wraps(original_func)(wrapper_func)
        
        # 추가 메타데이터 관리
        if hasattr(original_func, '__custom_metadata__'):
            wrapped.__custom_metadata__ = original_func.__custom_metadata__.copy()
        
        # 호출 횟수 추적 추가
        wrapped.__call_count__ = 0
        
        # 데코레이터 정보 저장
        if not hasattr(wrapped, '__decorator_info__'):
            wrapped.__decorator_info__ = []
        
        wrapped.__decorator_info__.append({
            'decorator': 'enhanced_wraps',
            'applied_at': datetime.now().isoformat(),
            'original_func': original_func.__name__
        })
        
        # 호출 카운터가 포함된 실제 래퍼 생성
        def counting_wrapper(*args, **kwargs):
            wrapped.__call_count__ += 1
            return wrapped(*args, **kwargs)
        
        # counting_wrapper에 메타데이터 복사
        counting_wrapper = functools.wraps(wrapped)(counting_wrapper)
        
        # 모든 속성 복사
        for attr in ['__custom_metadata__', '__decorator_info__', '__call_count__']:
            if hasattr(wrapped, attr):
                setattr(counting_wrapper, attr, getattr(wrapped, attr))
        
        return counting_wrapper
    
    return decorator

def tracking_decorator(func):
    """호출 추적 데코레이터"""
    @enhanced_wraps(func)
    def wrapper(*args, **kwargs):
        print(f"[TRACKING] {func.__name__} 호출 (인자: {len(args)}개)")
        result = func(*args, **kwargs)
        print(f"[TRACKING] {func.__name__} 완료 (결과: {result})")
        return result
    
    # 커스텀 메타데이터 추가
    wrapper.__custom_metadata__ = {
        'decorator_type': 'tracking',
        'version': '1.0',
        'author': 'System'
    }
    
    return wrapper

# 데코레이터 테스트
@tracking_decorator
def tracked_function(x, y):
    """추적되는 함수"""
    return x * y

print("향상된 메타데이터 데코레이터 테스트:")

# 함수 실행
print("함수 실행:")
result = tracked_function(5, 3)
print(f"  결과: {result}")

result = tracked_function(10, 2)
print(f"  결과: {result}")

# 메타데이터 확인
print("\n메타데이터 확인:")
print(f"  함수 이름: {tracked_function.__name__}")
print(f"  설명: {tracked_function.__doc__}")
print(f"  커스텀 메타데이터: {tracked_function.__custom_metadata__}")
print(f"  데코레이터 정보: {tracked_function.__decorator_info__}")
print(f"  호출 횟수: {tracked_function.__call_count__}")

# 4. 클래스 메서드의 메타데이터 보존
print("\n4. 클래스 메서드의 메타데이터 보존:")

def method_decorator(func):
    """클래스 메서드용 데코레이터"""
    @functools.wraps(func)
    def wrapper(self, *args, **kwargs):
        print(f"[METHOD] {self.__class__.__name__}.{func.__name__} 호출")
        return func(self, *args, **kwargs)
    return wrapper

class DataProcessor:
    """데이터 처리기 클래스"""
    
    def __init__(self, name):
        self.name = name
    
    @method_decorator
    def process(self, data: list) -> dict:
        """
        데이터 처리 메서드
        
        Args:
            data: 처리할 데이터 리스트
        
        Returns:
            처리 결과 딕셔너리
        """
        return {
            'processed_by': self.name,
            'data_length': len(data),
            'result': [x * 2 for x in data]
        }
    
    @classmethod
    @method_decorator
    def create_default(cls) -> 'DataProcessor':
        """
        기본 처리기 생성
        
        Returns:
            DataProcessor 인스턴스
        """
        return cls("default_processor")
    
    @staticmethod
    @method_decorator
    def validate_data(data) -> bool:
        """
        데이터 검증
        
        Args:
            data: 검증할 데이터
        
        Returns:
            검증 결과
        """
        return isinstance(data, list) and len(data) > 0

print("클래스 메서드 데코레이터 테스트:")

processor = DataProcessor("테스트")

# 인스턴스 메서드
print("인스턴스 메서드:")
result = processor.process([1, 2, 3])
print(f"  결과: {result}")
print(f"  메서드 이름: {processor.process.__name__}")
print(f"  메서드 설명: {processor.process.__doc__.strip().splitlines()[0]}")
print(f"  메서드 어노테이션: {processor.process.__annotations__}")

# 클래스 메서드
print("\n클래스 메서드:")
default_processor = DataProcessor.create_default()
print(f"  생성됨: {default_processor.name}")
print(f"  메서드 이름: {DataProcessor.create_default.__name__}")

# 정적 메서드
print("\n정적 메서드:")
is_valid = DataProcessor.validate_data([1, 2, 3])
print(f"  검증 결과: {is_valid}")
print(f"  메서드 이름: {DataProcessor.validate_data.__name__}")

# 5. 속성(property)의 메타데이터 보존
print("\n5. 속성(property)의 메타데이터 보존:")

def property_decorator(getter_func):
    """프로퍼티 데코레이터"""
    @functools.wraps(getter_func)
    def wrapper(self):
        print(f"[PROPERTY] {getter_func.__name__} 접근")
        return getter_func(self)
    
    # 프로퍼티 객체 생성
    prop = property(wrapper)
    
    # 메타데이터 복사
    prop.__doc__ = getter_func.__doc__
    
    return prop

def property_setter_decorator(setter_func):
    """프로퍼티 세터 데코레이터"""
    @functools.wraps(setter_func)
    def wrapper(self, value):
        print(f"[PROPERTY SETTER] {setter_func.__name__} 설정: {value}")
        return setter_func(self, value)
    
    return wrapper

class User:
    """사용자 클래스"""
    
    def __init__(self, name, age):
        self._name = name
        self._age = age
        self._email = None
    
    @property_decorator
    def name(self) -> str:
        """사용자 이름"""
        return self._name
    
    @name.setter
    @property_setter_decorator
    def name(self, value: str):
        """이름 설정"""
        if not value or not isinstance(value, str):
            raise ValueError("유효한 이름이 필요합니다")
        self._name = value
    
    @property_decorator
    def age(self) -> int:
        """사용자 나이"""
        return self._age
    
    @property_decorator
    def email(self) -> str:
        """사용자 이메일"""
        return self._email or f"{self._name.lower()}@example.com"

print("프로퍼티 데코레이터 테스트:")

user = User("김철수", 30)

# 프로퍼티 접근
print("프로퍼티 접근:")
print(f"  이름: {user.name}")
print(f"  나이: {user.age}")
print(f"  이메일: {user.email}")

# 메타데이터 확인
print(f"\n프로퍼티 메타데이터:")
print(f"  name 프로퍼티 설명: {User.name.__doc__}")
print(f"  age 프로퍼티 설명: {User.age.__doc__}")
print(f"  email 프로퍼티 설명: {User.email.__doc__}")

# 세터 테스트
print("\n프로퍼티 설정:")
user.name = "이영희"
print(f"  새로운 이름: {user.name}")
```

## 데코레이터 풀기

### 중첩된 데코레이터 분석 및 제거
```python
print("\n" + "="*60)
print("데코레이터 풀기")
print("="*60)

# 1. 데코레이터 체인 이해
print("1. 데코레이터 체인 이해:")

def decorator1(func):
    """첫 번째 데코레이터"""
    print(f"[DECORATOR1] 적용: {func.__name__}")
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("[DECORATOR1] 전처리")
        result = func(*args, **kwargs)
        print("[DECORATOR1] 후처리")
        return result
    
    return wrapper

def decorator2(func):
    """두 번째 데코레이터"""
    print(f"[DECORATOR2] 적용: {func.__name__}")
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("[DECORATOR2] 전처리")
        result = func(*args, **kwargs)
        print("[DECORATOR2] 후처리")
        return result
    
    return wrapper

def decorator3(func):
    """세 번째 데코레이터"""
    print(f"[DECORATOR3] 적용: {func.__name__}")
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("[DECORATOR3] 전처리")
        result = func(*args, **kwargs)
        print("[DECORATOR3] 후처리")
        return result
    
    return wrapper

# 중첩된 데코레이터 적용
@decorator1
@decorator2
@decorator3
def sample_function():
    """샘플 함수"""
    print("[SAMPLE FUNCTION] 실행")
    return "결과"

print("데코레이터 체인 적용 순서:")
print("데코레이터가 적용되는 순서: decorator3 → decorator2 → decorator1")
print("\n함수 실행:")
result = sample_function()
print(f"최종 결과: {result}")

# 2. 데코레이터 스택 분석
print("\n2. 데코레이터 스택 분석:")

def analyze_decorators(func):
    """함수의 데코레이터 스택 분석"""
    import types
    
    analysis = {
        'function_name': func.__name__,
        'decorators': [],
        'wrapping_depth': 0,
        'original_function': None
    }
    
    current = func
    
    # 데코레이터 체인 추적
    while hasattr(current, '__wrapped__'):
        analysis['wrapping_depth'] += 1
        analysis['decorators'].append({
            'wrapper_name': current.__name__,
            'wrapper_module': current.__module__,
            'has_wrapped': hasattr(current, '__wrapped__'),
            'closure': current.__closure__
        })
        current = current.__wrapped__
    
    # 원본 함수 정보
    analysis['original_function'] = {
        'name': current.__name__,
        'module': current.__module__,
        'doc': current.__doc__
    }
    
    return analysis

# 데코레이터 분석
print("데코레이터 스택 분석:")
analysis = analyze_decorators(sample_function)

print(f"함수 이름: {analysis['function_name']}")
print(f"래핑 깊이: {analysis['wrapping_depth']}층")
print(f"적용된 데코레이터 수: {len(analysis['decorators'])}")

print("\n데코레이터 체인:")
for i, decorator in enumerate(analysis['decorators'], 1):
    print(f"  {i}. {decorator['wrapper_name']}")

print(f"\n원본 함수: {analysis['original_function']['name']}")
print(f"원본 설명: {analysis['original_function']['doc']}")

# 3. 데코레이터 제거 (언래핑)
print("\n3. 데코레이터 제거 (언래핑):")

def unwrap_function(wrapped_func, levels=None):
    """
    데코레이터를 제거하여 원본 함수 복원
    
    Args:
        wrapped_func: 데코레이터가 적용된 함수
        levels: 제거할 데코레이터 수 (None이면 모두 제거)
    
    Returns:
        제거된 데코레이터 리스트와 원본 함수
    """
    unwrapped_func = wrapped_func
    removed_decorators = []
    
    while hasattr(unwrapped_func, '__wrapped__'):
        if levels is not None and len(removed_decorators) >= levels:
            break
        
        # 현재 래퍼 정보 저장
        wrapper_info = {
            'name': unwrapped_func.__name__,
            'module': unwrapped_func.__module__,
            'closure': unwrapped_func.__closure__
        }
        removed_decorators.append(wrapper_info)
        
        # 다음 레벨로 이동
        unwrapped_func = unwrapped_func.__wrapped__
    
    return removed_decorators, unwrapped_func

# 데코레이터 제거 테스트
print("데코레이터 제거 테스트:")

# 모든 데코레이터 제거
all_removed, original = unwrap_function(sample_function)
print(f"제거된 데코레이터 수: {len(all_removed)}")
print(f"복원된 원본 함수 이름: {original.__name__}")

# 특정 수만큼만 제거
two_removed, partially_unwrapped = unwrap_function(sample_function, levels=2)
print(f"\n2개 데코레이터만 제거:")
print(f"제거된 데코레이터: {[d['name'] for d in two_removed]}")
print(f"남은 래핑 함수 이름: {partially_unwrapped.__name__}")

# 원본 함수 실행
print("\n원본 함수 직접 실행:")
result = original()
print(f"결과: {result}")

# 4. 조건부 데코레이터 제거
print("\n4. 조건부 데코레이터 제거:")

def remove_specific_decorator(wrapped_func, decorator_name):
    """
    특정 데코레이터만 제거
    
    Args:
        wrapped_func: 데코레이터가 적용된 함수
        decorator_name: 제거할 데코레이터 이름
    
    Returns:
        특정 데코레이터가 제거된 함수
    """
    def rewrap_function(current_func, target_name):
        """재구성된 함수 체인 생성"""
        if not hasattr(current_func, '__wrapped__'):
            return current_func
        
        if current_func.__name__ == target_name:
            # 대상 데코레이터 건너뛰기
            return rewrap_function(current_func.__wrapped__, target_name)
        else:
            # 현재 데코레이터 유지
            def new_wrapper(*args, **kwargs):
                return current_func(*args, **kwargs)
            
            # 메타데이터 복사
            new_wrapper = functools.wraps(current_func)(new_wrapper)
            
            # 다음 레벨 재구성
            new_wrapper.__wrapped__ = rewrap_function(
                current_func.__wrapped__, target_name
            )
            
            return new_wrapper
    
    return rewrap_function(wrapped_func, decorator_name)

# 조건부 제거 테스트
print("특정 데코레이터 제거 테스트:")

# decorator2만 제거
without_decorator2 = remove_specific_decorator(sample_function, 'wrapper')

print("decorator2 제거 후 함수 실행:")
result = without_decorator2()
print(f"결과: {result}")

# 5. 데코레이터 적용/제거 관리 시스템
print("\n5. 데코레이터 적용/제거 관리 시스템:")

class DecoratorManager:
    """데코레이터 관리자"""
    
    def __init__(self):
        self._registry = {}
    
    def register(self, name, decorator_func):
        """데코레이터 등록"""
        self._registry[name] = decorator_func
        return self
    
    def apply(self, func, *decorator_names):
        """데코레이터 적용"""
        result = func
        
        for name in decorator_names:
            if name not in self._registry:
                raise ValueError(f"데코레이터 '{name}'이 등록되지 않았습니다")
            
            result = self._registry[name](result)
        
        return result
    
    def analyze(self, func):
        """함수의 데코레이터 분석"""
        analysis = {
            'function': func.__name__,
            'applied_decorators': [],
            'decorator_ids': []
        }
        
        current = func
        
        while hasattr(current, '__wrapped__'):
            wrapper_id = id(current)
            
            # 데코레이터 식별
            decorator_info = {
                'wrapper_id': wrapper_id,
                'wrapper_name': current.__name__,
                'original_name': getattr(current.__wrapped__, '__name__', 'unknown')
            }
            
            analysis['applied_decorators'].append(decorator_info)
            analysis['decorator_ids'].append(wrapper_id)
            
            current = current.__wrapped__
        
        return analysis
    
    def remove_by_id(self, func, wrapper_id):
        """ID로 특정 데코레이터 제거"""
        if not hasattr(func, '__wrapped__'):
            return func
        
        if id(func) == wrapper_id:
            # 대상 데코레이터 제거
            return self.remove_by_id(func.__wrapped__, wrapper_id)
        else:
            # 현재 데코레이터 유지
            def new_wrapper(*args, **kwargs):
                return func(*args, **kwargs)
            
            new_wrapper = functools.wraps(func)(new_wrapper)
            new_wrapper.__wrapped__ = self.remove_by_id(
                func.__wrapped__, wrapper_id
            )
            
            return new_wrapper

# 관리자 시스템 테스트
print("데코레이터 관리 시스템:")

manager = DecoratorManager()

# 데코레이터 등록
manager.register('log', decorator1)
manager.register('validate', decorator2)
manager.register('cache', decorator3)

# 원본 함수
def target_function(x, y):
    """대상 함수"""
    return x + y

# 데코레이터 적용
print("데코레이터 적용:")
decorated = manager.apply(target_function, 'cache', 'validate', 'log')
analysis = manager.analyze(decorated)

print(f"적용된 데코레이터: {[d['wrapper_name'] for d in analysis['applied_decorators']]}")

# 함수 실행
print("\n데코레이터 적용 후 실행:")
result = decorated(5, 3)
print(f"결과: {result}")

# 특정 데코레이터 제거
print("\n특정 데코레이터 제거:")
if analysis['decorator_ids']:
    # 첫 번째 데코레이터 제거
    wrapper_id_to_remove = analysis['decorator_ids'][0]
    without_first = manager.remove_by_id(decorated, wrapper_id_to_remove)
    
    print(f"제거된 데코레이터 ID: {wrapper_id_to_remove}")
    print(f"남은 데코레이터: {[d['wrapper_name'] for d in manager.analyze(without_first)['applied_decorators']]}")
```

## 매개변수를 받는 데코레이터 정의

### 다양한 파라미터화된 데코레이터 패턴
```python
print("\n" + "="*60)
print("매개변수를 받는 데코레이터 정의")
print("="*60)

# 1. 기본적인 파라미터화된 데코레이터
print("1. 기본적인 파라미터화된 데코레이터:")

def repeat(n_times):
    """
    함수를 여러 번 반복 실행하는 데코레이터
    
    Args:
        n_times: 반복 횟수
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            results = []
            for i in range(n_times):
                print(f"[{i+1}/{n_times}] 실행 중...")
                result = func(*args, **kwargs)
                results.append(result)
            return results[-1]  # 마지막 결과 반환
        return wrapper
    return decorator

# 사용 예제
@repeat(n_times=3)
def greet(name):
    """인사 함수"""
    return f"안녕하세요, {name}님!"

print("반복 데코레이터 예제:")
result = greet("김철수")
print(f"결과: {result}")

# 2. 파라미터에 따른 조건부 데코레이터
print("\n2. 조건부 데코레이터:")

def conditional(condition=True, alternative=None):
    """
    조건에 따라 함수 실행 또는 대체
    
    Args:
        condition: 실행 조건
        alternative: 조건이 False일 때 반환할 값 또는 함수
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            if condition:
                return func(*args, **kwargs)
            else:
                if alternative is None:
                    return None
                elif callable(alternative):
                    return alternative(*args, **kwargs)
                else:
                    return alternative
        return wrapper
    return decorator

# 사용 예제
@conditional(condition=True)
def calculate_sum(a, b):
    """합계 계산"""
    return a + b

@conditional(condition=False, alternative=100)
def calculate_product(a, b):
    """곱셈 계산 (조건부 비활성화)"""
    return a * b

@conditional(condition=False, alternative=lambda x, y: f"대체됨: {x}, {y}")
def calculate_power(a, b):
    """제곱 계산"""
    return a ** b

print("조건부 데코레이터 예제:")
print(f"calculate_sum(3, 5) = {calculate_sum(3, 5)}")
print(f"calculate_product(3, 5) = {calculate_product(3, 5)}")
print(f"calculate_power(2, 3) = {calculate_power(2, 3)}")

# 3. 타임아웃 데코레이터
print("\n3. 타임아웃 데코레이터:")

import signal
import threading

def timeout(seconds=10, timeout_value=None):
    """
    함수 실행 시간 제한 데코레이터
    
    Args:
        seconds: 타임아웃 시간 (초)
        timeout_value: 타임아웃 시 반환할 값
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            result_container = []
            exception_container = []
            
            def target():
                try:
                    result_container.append(func(*args, **kwargs))
                except Exception as e:
                    exception_container.append(e)
            
            # 스레드 생성 및 실행
            thread = threading.Thread(target=target)
            thread.daemon = True
            thread.start()
            thread.join(seconds)
            
            # 결과 처리
            if thread.is_alive():
                print(f"[TIMEOUT] {func.__name__} 실행 시간 초과 ({seconds}초)")
                return timeout_value
            elif exception_container:
                raise exception_container[0]
            else:
                return result_container[0]
        
        return wrapper
    return decorator

# 사용 예제 (느린 함수 시뮬레이션)
@timeout(seconds=2, timeout_value="시간 초과")
def slow_operation(duration):
    """느린 작업 시뮬레이션"""
    import time
    time.sleep(duration)
    return f"작업 완료 ({duration}초 소요)"

@timeout(seconds=5)
def fast_operation():
    """빠른 작업"""
    return "빠른 작업 완료"

print("타임아웃 데코레이터 예제:")
print(f"fast_operation() = {fast_operation()}")
print(f"slow_operation(1) = {slow_operation(1)}")
print(f"slow_operation(3) = {slow_operation(3)}")  # 타임아웃 발생

# 4. 재시도 데코레이터
print("\n4. 재시도 데코레이터:")

def retry(max_attempts=3, delay=1, backoff=2, 
          exceptions=(Exception,), logger=None):
    """
    실패 시 재시도하는 데코레이터
    
    Args:
        max_attempts: 최대 시도 횟수
        delay: 재시도 간 지연 시간 (초)
        backoff: 지연 시간 배수
        exceptions: 재시도할 예외 타입
        logger: 로깅 함수
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            current_delay = delay
            
            for attempt in range(1, max_attempts + 1):
                try:
                    if logger:
                        logger(f"[RETRY] {func.__name__} 시도 {attempt}/{max_attempts}")
                    
                    return func(*args, **kwargs)
                
                except exceptions as e:
                    last_exception = e
                    
                    if attempt < max_attempts:
                        if logger:
                            logger(f"[RETRY] 실패: {e}. {current_delay}초 후 재시도...")
                        
                        import time
                        time.sleep(current_delay)
                        current_delay *= backoff
                    else:
                        if logger:
                            logger(f"[RETRY] 최대 시도 횟수 초과: {e}")
            
            # 모든 시도 실패
            raise last_exception
        
        return wrapper
    return decorator

# 사용 예제
def simple_logger(message):
    """간단한 로거"""
    print(f"  {message}")

@retry(max_attempts=3, delay=0.1, exceptions=(ValueError,), logger=simple_logger)
def unreliable_operation(success_on_attempt):
    """신뢰성 낮은 작업"""
    import random
    attempt = getattr(unreliable_operation, '_attempt', 0) + 1
    unreliable_operation._attempt = attempt
    
    if attempt < success_on_attempt:
        raise ValueError(f"의도적 실패 (시도 {attempt})")
    
    return f"성공! (시도 {attempt})"

print("재시도 데코레이터 예제:")
print("첫 시도에서 성공하는 경우:")
unreliable_operation._attempt = 0
result = unreliable_operation(1)
print(f"  결과: {result}")

print("\n세 번째 시도에서 성공하는 경우:")
unreliable_operation._attempt = 0
result = unreliable_operation(3)
print(f"  결과: {result}")

print("\n최대 시도 횟수 초과하는 경우:")
try:
    unreliable_operation._attempt = 0
    result = unreliable_operation(5)  # 3회만 재시도하므로 실패
    print(f"  결과: {result}")
except ValueError as e:
    print(f"  예상된 실패: {e}")

# 5. 캐싱 데코레이터 (파라미터화된)
print("\n5. 파라미터화된 캐싱 데코레이터:")

def cached(maxsize=128, ttl=None, key_func=None):
    """
    함수 결과 캐싱 데코레이터
    
    Args:
        maxsize: 최대 캐시 크기
        ttl: 캐시 유효 시간 (초, None이면 무제한)
        key_func: 캐시 키 생성 함수
    """
    def decorator(func):
        cache = {}
        import time
        
        if key_func is None:
            def default_key_func(*args, **kwargs):
                return (
                    args,
                    tuple(sorted(kwargs.items())) if kwargs else None
                )
            cache_key_func = default_key_func
        else:
            cache_key_func = key_func
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 캐시 키 생성
            key = cache_key_func(*args, **kwargs)
            
            # 캐시 히트 확인
            if key in cache:
                entry = cache[key]
                
                # TTL 검사
                if ttl is None or (time.time() - entry['timestamp']) < ttl:
                    entry['hits'] += 1
                    return entry['value']
                else:
                    # 만료된 항목 제거
                    del cache[key]
            
            # 캐시 미스 - 계산
            result = func(*args, **kwargs)
            
            # LRU 캐시 관리
            if len(cache) >= maxsize:
                # 가장 오래된 항목 제거
                oldest_key = next(iter(cache))
                del cache[oldest_key]
            
            # 캐시 저장
            cache[key] = {
                'value': result,
                'timestamp': time.time(),
                'hits': 0
            }
            
            return result
        
        # 캐시 관리 메서드 추가
        wrapper.cache_info = lambda: {
            'size': len(cache),
            'maxsize': maxsize,
            'ttl': ttl,
            'hits': sum(entry['hits'] for entry in cache.values()),
            'items': list(cache.keys())
        }
        
        wrapper.clear_cache = lambda: cache.clear()
        
        wrapper.get_cached_value = lambda *args, **kwargs: (
            cache.get(cache_key_func(*args, **kwargs), {}).get('value')
        )
        
        return wrapper
    return decorator

# 사용 예제
@cached(maxsize=10, ttl=5)  # 5초 동안 유효
def expensive_computation(x):
    """비용이 많이 드는 계산"""
    import time
    time.sleep(0.1)  # 계산 비용 시뮬레이션
    return x * x

@cached(maxsize=100, ttl=None)  # 영구 캐시
def fibonacci_cached(n):
    """캐싱된 피보나치"""
    if n <= 1:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

print("파라미터화된 캐싱 데코레이터 예제:")
print("TTL 캐시 테스트:")
for i in range(3):
    result = expensive_computation(5)
    print(f"  expensive_computation(5) = {result}")
    print(f"  캐시 정보: {expensive_computation.cache_info()}")

print("\n피보나치 캐시 테스트:")
result = fibonacci_cached(30)
print(f"  fibonacci_cached(30) = {result}")
print(f"  캐시 크기: {fibonacci_cached.cache_info()['size']}")
```

## 사용자가 조절 가능한 속성을 가진 데코레이터 정의

### 동적 속성 제어 데코레이터
```python
print("\n" + "="*60)
print("사용자가 조절 가능한 속성을 가진 데코레이터 정의")
print("="*60)

# 1. 속성 기반 제어 데코레이터
print("1. 속성 기반 제어 데코레이터:")

def controllable(enabled=True, level='INFO', log_file=None):
    """
    사용자 조절이 가능한 데코레이터
    
    Args:
        enabled: 데코레이터 활성화 여부
        level: 로그 레벨
        log_file: 로그 파일 경로
    """
    def decorator(func):
        # 데코레이터 상태 저장
        decorator_state = {
            'enabled': enabled,
            'level': level,
            'log_file': log_file,
            'call_count': 0
        }
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            decorator_state['call_count'] += 1
            
            # 데코레이터 비활성화 시 원본 함수 바로 실행
            if not decorator_state['enabled']:
                return func(*args, **kwargs)
            
            # 로깅
            log_message = f"[{decorator_state['level']}] {func.__name__} 호출"
            log_message += f" (호출 횟수: {decorator_state['call_count']})"
            
            print(log_message)
            
            if decorator_state['log_file']:
                try:
                    with open(decorator_state['log_file'], 'a', encoding='utf-8') as f:
                        f.write(f"{datetime.now()}: {log_message}\n")
                except Exception as e:
                    print(f"로그 파일 쓰기 오류: {e}")
            
            # 원본 함수 실행
            return func(*args, **kwargs)
        
        # 제어 메서드 추가
        def enable():
            """데코레이터 활성화"""
            decorator_state['enabled'] = True
            return "데코레이터 활성화됨"
        
        def disable():
            """데코레이터 비활성화"""
            decorator_state['enabled'] = False
            return "데코레이터 비활성화됨"
        
        def set_level(new_level):
            """로그 레벨 설정"""
            valid_levels = ['DEBUG', 'INFO', 'WARNING', 'ERROR']
            if new_level in valid_levels:
                decorator_state['level'] = new_level
                return f"로그 레벨이 {new_level}로 설정됨"
            else:
                raise ValueError(f"유효한 레벨: {valid_levels}")
        
        def get_state():
            """현재 상태 반환"""
            return dict(decorator_state)
        
        def reset_counter():
            """호출 카운터 리셋"""
            decorator_state['call_count'] = 0
            return "카운터 리셋됨"
        
        # 메서드 연결
        wrapper.enable = enable
        wrapper.disable = disable
        wrapper.set_level = set_level
        wrapper.get_state = get_state
        wrapper.reset_counter = reset_counter
        
        return wrapper
    return decorator

# 사용 예제
@controllable(enabled=True, level='INFO', log_file='app.log')
def process_data(data):
    """데이터 처리 함수"""
    return f"처리된 데이터: {data}"

print("제어 가능한 데코레이터 예제:")
print("초기 상태:")
print(f"  데코레이터 상태: {process_data.get_state()}")

print("\n함수 실행:")
result1 = process_data("테스트1")
print(f"  결과: {result1}")

result2 = process_data("테스트2")
print(f"  결과: {result2}")

print(f"\n실행 후 상태: {process_data.get_state()}")

print("\n동적 제어:")
print(f"  비활성화: {process_data.disable()}")
result3 = process_data("테스트3")  # 로그 출력 없음
print(f"  결과: {result3}")

print(f"  활성화: {process_data.enable()}")
print(f"  레벨 변경: {process_data.set_level('DEBUG')}")
print(f"  카운터 리셋: {process_data.reset_counter()}")

result4 = process_data("테스트4")
print(f"  결과: {result4}")

print(f"\n최종 상태: {process_data.get_state()}")

# 2. 런타임에 속성 변경 가능한 데코레이터
print("\n2. 런타임 속성 변경 데코레이터:")

def runtime_configurable(**default_config):
    """
    런타임에 구성이 변경 가능한 데코레이터
    
    Args:
        **default_config: 기본 구성값
    """
    def decorator(func):
        # 구성 저장소
        config_store = {
            'config': default_config.copy(),
            'metadata': {
                'created_at': datetime.now(),
                'last_modified': datetime.now()
            }
        }
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 현재 구성 적용
            current_config = config_store['config']
            
            # 구성에 따른 동작
            if current_config.get('enabled', True):
                # 로깅
                if current_config.get('logging', False):
                    print(f"[CONFIG] {func.__name__} 실행")
                    print(f"  구성: {current_config}")
                
                # 타이밍
                start_time = None
                if current_config.get('timing', False):
                    import time
                    start_time = time.perf_counter()
                
                # 원본 함수 실행
                result = func(*args, **kwargs)
                
                # 타이밍 결과
                if start_time:
                    elapsed = time.perf_counter() - start_time
                    print(f"[TIMING] {func.__name__}: {elapsed:.6f}초")
                
                # 결과 변환
                if current_config.get('uppercase', False) and isinstance(result, str):
                    result = result.upper()
                
                return result
            else:
                # 비활성화된 경우 기본값 반환
                return current_config.get('default_value', None)
        
        # 구성 관리 메서드
        def configure(**new_config):
            """구성 업데이트"""
            config_store['config'].update(new_config)
            config_store['metadata']['last_modified'] = datetime.now()
            return "구성이 업데이트됨"
        
        def get_config(key=None):
            """구성 조회"""
            if key:
                return config_store['config'].get(key)
            return config_store['config'].copy()
        
        def reset_config():
            """구성 초기화"""
            config_store['config'] = default_config.copy()
            config_store['metadata']['last_modified'] = datetime.now()
            return "구성이 초기화됨"
        
        def add_validator(validator_func):
            """구성 검증기 추가"""
            if not hasattr(wrapper, '_validators'):
                wrapper._validators = []
            wrapper._validators.append(validator_func)
            return f"검증기가 추가됨: {validator_func.__name__}"
        
        def validate_config():
            """구성 검증"""
            if hasattr(wrapper, '_validators'):
                for validator in wrapper._validators:
                    try:
                        validator(config_store['config'])
                    except Exception as e:
                        return f"검증 실패: {e}"
            return "모든 검증 통과"
        
        # 메서드 연결
        wrapper.configure = configure
        wrapper.get_config = get_config
        wrapper.reset_config = reset_config
        wrapper.add_validator = add_validator
        wrapper.validate_config = validate_config
        wrapper._config_store = config_store  # 내부 저장소 접근
        
        return wrapper
    return decorator

# 검증 함수 예제
def validate_positive_numbers(config):
    """양수 값 검증"""
    if 'max_retries' in config and config['max_retries'] < 0:
        raise ValueError("max_retries는 0 이상이어야 합니다")
    if 'timeout' in config and config['timeout'] <= 0:
        raise ValueError("timeout은 0보다 커야 합니다")

# 사용 예제
@runtime_configurable(
    enabled=True,
    logging=True,
    timing=False,
    uppercase=False,
    max_retries=3,
    timeout=30
)
def api_call(endpoint):
    """API 호출 시뮬레이션"""
    return f"API 응답: {endpoint}"

print("런타임 구성 가능 데코레이터 예제:")
print("초기 구성으로 실행:")
result1 = api_call("/users")
print(f"  결과: {result1}")

print("\n구성 확인:")
print(f"  현재 구성: {api_call.get_config()}")

print("\n런타임 구성 변경:")
print(f"  타이밍 활성화: {api_call.configure(timing=True)}")
print(f"  대문자 변환 활성화: {api_call.configure(uppercase=True)}")

result2 = api_call("/products")
print(f"  결과: {result2}")

print("\n검증기 추가:")
print(f"  {api_call.add_validator(validate_positive_numbers)}")
print(f"  검증 결과: {api_call.validate_config()}")

print("\n잘못된 구성 시도:")
try:
    api_call.configure(max_retries=-1)
    print(f"  검증 결과: {api_call.validate_config()}")
except Exception as e:
    print(f"  오류: {e}")

print(f"\n구성 초기화: {api_call.reset_config()}")
print(f"  초기화 후 구성: {api_call.get_config()}")

# 3. 체계적인 제어 인터페이스가 있는 데코레이터
print("\n3. 체계적인 제어 인터페이스 데코레이터:")

class DecoratorController:
    """데코레이터 제어기"""
    
    def __init__(self, **options):
        self.options = options
        self.state = {
            'active': options.get('active', True),
            'mode': options.get('mode', 'normal'),
            'call_history': []
        }
    
    def __call__(self, func):
        """데코레이터로 사용"""
        controller = self  # self 참조 저장
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 호출 기록
            call_info = {
                'timestamp': datetime.now(),
                'args': args,
                'kwargs': kwargs,
                'state': controller.state.copy()
            }
            controller.state['call_history'].append(call_info)
            
            # 비활성화 상태
            if not controller.state['active']:
                return func(*args, **kwargs)
            
            # 모드에 따른 처리
            mode = controller.state['mode']
            
            if mode == 'debug':
                print(f"[DEBUG] {func.__name__} 호출 시작")
                print(f"  인자: args={args}, kwargs={kwargs}")
            
            elif mode == 'benchmark':
                import time
                start_time = time.perf_counter()
                result = func(*args, **kwargs)
                elapsed = time.perf_counter() - start_time
                print(f"[BENCHMARK] {func.__name__}: {elapsed:.6f}초")
                return result
            
            elif mode == 'validate':
                # 인자 검증 (간단한 예제)
                if args and isinstance(args[0], str) and not args[0].strip():
                    raise ValueError("빈 문자열은 허용되지 않습니다")
            
            # 기본 실행
            return func(*args, **kwargs)
        
        # 제어 메서드들
        wrapper.controller = self
        
        wrapper.activate = lambda: self._set_state('active', True)
        wrapper.deactivate = lambda: self._set_state('active', False)
        wrapper.set_mode = lambda mode: self._set_state('mode', mode)
        wrapper.get_stats = self._get_stats
        wrapper.clear_history = self._clear_history
        wrapper.get_history = lambda: self.state['call_history'].copy()
        
        return wrapper
    
    def _set_state(self, key, value):
        """상태 설정"""
        self.state[key] = value
        return f"{key}가 {value}로 설정됨"
    
    def _get_stats(self):
        """통계 정보"""
        return {
            'total_calls': len(self.state['call_history']),
            'active': self.state['active'],
            'mode': self.state['mode'],
            'last_call': self.state['call_history'][-1] if self.state['call_history'] else None
        }
    
    def _clear_history(self):
        """호출 기록 초기화"""
        self.state['call_history'].clear()
        return "호출 기록이 초기화됨"

# 사용 예제
controller = DecoratorController(active=True, mode='debug')

@controller
def data_transformer(data, multiplier=1):
    """데이터 변환 함수"""
    if isinstance(data, list):
        return [x * multiplier for x in data]
    elif isinstance(data, dict):
        return {k: v * multiplier for k, v in data.items()}
    else:
        return data * multiplier

print("제어기 기반 데코레이터 예제:")
print("초기 실행 (debug 모드):")
result1 = data_transformer([1, 2, 3], multiplier=2)
print(f"  결과: {result1}")

print("\n모드 변경:")
print(f"  normal 모드 설정: {data_transformer.set_mode('normal')}")
result2 = data_transformer({'a': 10, 'b': 20}, multiplier=3)
print(f"  결과: {result2}")

print("\n비활성화:")
print(f"  데코레이터 비활성화: {data_transformer.deactivate()}")
result3 = data_transformer(5, multiplier=4)
print(f"  결과: {result3} (데코레이터 작동 없음)")

print("\n통계 확인:")
stats = data_transformer.get_stats()
print(f"  총 호출 횟수: {stats['total_calls']}")
print(f"  현재 상태: 활성={stats['active']}, 모드={stats['mode']}")

print("\n호출 기록:")
history = data_transformer.get_history()
for i, call in enumerate(history, 1):
    print(f"  {i}. 시간: {call['timestamp'].strftime('%H:%M:%S')}, "
          f"모드: {call['state']['mode']}")

print(f"\n기록 초기화: {data_transformer.clear_history()}")

# 4. 플러그인 아키텍처 데코레이터
print("\n4. 플러그인 아키텍처 데코레이터:")

def plugin_architecture(*, plugins=None, enabled=True):
    """
    플러그인 시스템을 가진 데코레이터
    
    Args:
        plugins: 초기 플러그인 목록
        enabled: 데코레이터 활성화 여부
    """
    def decorator(func):
        # 플러그인 저장소
        plugin_store = {
            'pre_plugins': [],   # 실행 전 플러그인
            'post_plugins': [],  # 실행 후 플러그인
            'enabled': enabled,
            'metadata': {}
        }
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 데코레이터 비활성화
            if not plugin_store['enabled']:
                return func(*args, **kwargs)
            
            # 실행 전 플러그인 처리
            modified_args = args
            modified_kwargs = kwargs
            
            for plugin in plugin_store['pre_plugins']:
                try:
                    result = plugin(modified_args, modified_kwargs)
                    if result is not None:
                        modified_args, modified_kwargs = result
                except Exception as e:
                    print(f"전처리 플러그인 오류: {e}")
            
            # 원본 함수 실행
            func_result = func(*modified_args, **modified_kwargs)
            
            # 실행 후 플러그인 처리
            final_result = func_result
            
            for plugin in plugin_store['post_plugins']:
                try:
                    plugin_result = plugin(final_result, modified_args, modified_kwargs)
                    if plugin_result is not None:
                        final_result = plugin_result
                except Exception as e:
                    print(f"후처리 플러그인 오류: {e}")
            
            return final_result
        
        # 플러그인 관리 메서드
        def add_pre_plugin(plugin_func, priority=0):
            """실행 전 플러그인 추가"""
            plugin_store['pre_plugins'].append({
                'func': plugin_func,
                'priority': priority,
                'name': plugin_func.__name__
            })
            # 우선순위 정렬
            plugin_store['pre_plugins'].sort(key=lambda x: x['priority'], reverse=True)
            return f"전처리 플러그인 추가됨: {plugin_func.__name__}"
        
        def add_post_plugin(plugin_func, priority=0):
            """실행 후 플러그인 추가"""
            plugin_store['post_plugins'].append({
                'func': plugin_func,
                'priority': priority,
                'name': plugin_func.__name__
            })
            # 우선순위 정렬
            plugin_store['post_plugins'].sort(key=lambda x: x['priority'], reverse=True)
            return f"후처리 플러그인 추가됨: {plugin_func.__name__}"
        
        def remove_plugin(plugin_name):
            """플러그인 제거"""
            removed = 0
            
            # 전처리 플러그인에서 제거
            plugin_store['pre_plugins'] = [
                p for p in plugin_store['pre_plugins']
                if p['name'] != plugin_name
            ]
            removed += len([p for p in plugin_store['pre_plugins'] if p['name'] == plugin_name])
            
            # 후처리 플러그인에서 제거
            plugin_store['post_plugins'] = [
                p for p in plugin_store['post_plugins']
                if p['name'] != plugin_name
            ]
            removed += len([p for p in plugin_store['post_plugins'] if p['name'] == plugin_name])
            
            return f"플러그인 제거됨: {plugin_name} ({removed}개)"
        
        def list_plugins():
            """플러그인 목록 반환"""
            return {
                'pre_plugins': [p['name'] for p in plugin_store['pre_plugins']],
                'post_plugins': [p['name'] for p in plugin_store['post_plugins']],
                'total': len(plugin_store['pre_plugins']) + len(plugin_store['post_plugins'])
            }
        
        def enable():
            """데코레이터 활성화"""
            plugin_store['enabled'] = True
            return "플러그인 시스템 활성화됨"
        
        def disable():
            """데코레이터 비활성화"""
            plugin_store['enabled'] = False
            return "플러그인 시스템 비활성화됨"
        
        def clear_plugins():
            """모든 플러그인 제거"""
            plugin_store['pre_plugins'].clear()
            plugin_store['post_plugins'].clear()
            return "모든 플러그인이 제거됨"
        
        # 초기 플러그인 등록
        if plugins:
            for plugin in plugins:
                if hasattr(plugin, 'plugin_type'):
                    if plugin.plugin_type == 'pre':
                        add_pre_plugin(plugin)
                    elif plugin.plugin_type == 'post':
                        add_post_plugin(plugin)
        
        # 메서드 연결
        wrapper.add_pre_plugin = add_pre_plugin
        wrapper.add_post_plugin = add_post_plugin
        wrapper.remove_plugin = remove_plugin
        wrapper.list_plugins = list_plugins
        wrapper.enable = enable
        wrapper.disable = disable
        wrapper.clear_plugins = clear_plugins
        wrapper._plugin_store = plugin_store
        
        return wrapper
    return decorator

# 플러그인 예제
def validate_args_plugin(args, kwargs):
    """인자 검증 플러그인"""
    if args and isinstance(args[0], str):
        if len(args[0]) > 100:
            raise ValueError("문자열이 너무 깁니다")
    return args, kwargs
validate_args_plugin.plugin_type = 'pre'

def logging_plugin(args, kwargs):
    """로깅 플러그인"""
    print(f"[PLUGIN] 인자 로깅: args={args}, kwargs={kwargs}")
    return args, kwargs
logging_plugin.plugin_type = 'pre'

def result_formatter_plugin(result, args, kwargs):
    """결과 포맷팅 플러그인"""
    if isinstance(result, dict):
        return {k.upper(): v for k, v in result.items()}
    return result
result_formatter_plugin.plugin_type = 'post'

def timing_plugin(result, args, kwargs):
    """실행 시간 측정 플러그인"""
    import time
    if not hasattr(timing_plugin, '_start_time'):
        return result
    
    elapsed = time.perf_counter() - timing_plugin._start_time
    print(f"[PLUGIN] 실행 시간: {elapsed:.6f}초")
    return result
timing_plugin.plugin_type = 'post'

def timing_start_plugin(args, kwargs):
    """타이밍 시작 플러그인"""
    import time
    timing_plugin._start_time = time.perf_counter()
    return args, kwargs
timing_start_plugin.plugin_type = 'pre'

# 사용 예제
@plugin_architecture(plugins=[validate_args_plugin, logging_plugin], enabled=True)
def process_text(text, operations=None):
    """텍스트 처리 함수"""
    result = text
    
    if operations:
        for op in operations:
            if op == 'upper':
                result = result.upper()
            elif op == 'reverse':
                result = result[::-1]
            elif op == 'strip':
                result = result.strip()
    
    return {'text': result, 'length': len(result)}

print("플러그인 아키텍처 데코레이터 예제:")

print("초기 플러그인으로 실행:")
result1 = process_text("Hello World", operations=['upper', 'strip'])
print(f"  결과: {result1}")

print("\n플러그인 추가:")
print(f"  {process_text.add_pre_plugin(timing_start_plugin, priority=10)}")
print(f"  {process_text.add_post_plugin(timing_plugin, priority=5)}")
print(f"  {process_text.add_post_plugin(result_formatter_plugin, priority=1)}")

print("\n플러그인 목록:")
plugins = process_text.list_plugins()
print(f"  전처리: {plugins['pre_plugins']}")
print(f"  후처리: {plugins['post_plugins']}")
print(f"  총계: {plugins['total']}개")

print("\n추가된 플러그인으로 실행:")
result2 = process_text("Python Programming", operations=['reverse'])
print(f"  결과: {result2}")

print("\n플러그인 제거:")
print(f"  {process_text.remove_plugin('logging_plugin')}")

print("\n플러그인 비활성화:")
print(f"  {process_text.disable()}")
result3 = process_text("Test")
print(f"  결과: {result3} (플러그인 작동 없음)")

print("\n플러그인 활성화:")
print(f"  {process_text.enable()}")

print("\n모든 플러그인 제거:")
print(f"  {process_text.clear_plugins()}")
print(f"  남은 플러그인: {process_text.list_plugins()}")
```

## 결론

Python의 메타프로그래밍과 데코레이터는 강력한 도구로, 코드의 재사용성, 가독성, 유지보수성을 크게 향상시킬 수 있습니다. 함수 감싸기를 통해 기존 함수의 동작을 변경하거나 확장할 수 있으며, `functools.wraps`를 사용하면 원본 함수의 메타데이터(이름, 설명문, 시그니처 등)를 보존할 수 있습니다.

데코레이터 풀기는 디버깅이나 동적 수정이 필요할 때 유용하며, `__wrapped__` 속성을 통해 데코레이터 체인을 탐색하고 수정할 수 있습니다. 매개변수를 받는 데코레이터는 더욱 유연한 설계를 가능하게 하며, 재시도, 타임아웃, 캐싱 등 다양한 기능을 파라미터화하여 재사용할 수 있습니다.

사용자가 조절 가능한 속성을 가진 데코레이터는 런타임에 동작을 변경할 수 있어 특히 유용합니다. 이는 다음과 같은 장점이 있습니다:
1. **동적 제어**: 애플리케이션 실행 중 데코레이터 동작 변경
2. **조건부 활성화**: 특정 조건에서만 데코레이터 적용
3. **구성 관리**: 외부 설정에 따라 데코레이터 동작 조정
4. **플러그인 시스템**: 확장 가능한 아키텍처 구축

데코레이터를 설계할 때 고려해야 할 주요 원칙:
1. **메타데이터 보존**: 항상 `functools.wraps` 사용
2. **명확한 인터페이스**: 제어 메서드를 명확하게 제공
3. **에러 처리**: 데코레이터 내부 오류가 원본 함수에 영향을 미치지 않도록
4. **성능 고려**: 데코레이터 오버헤드를 최소화
5. **문서화**: 데코레이터의 동작과 제어 방법을 명확히 문서화

이러한 고급 기법들을 잘 활용하면 Python 코드의 표현력과 유지보수성을 크게 향상시킬 수 있습니다. 특히 대규모 애플리케이션에서는 데코레이터를 통해 횡단 관심사(로깅, 인증, 캐싱, 검증 등)를 깔끔하게 분리할 수 있어 코드 구조가 개선됩니다.