---
layout: post
title: 컴퓨터시스템 - 연결(링크) 단계 코드 최적화 결과의 요약
date: 2025-08-01 23:20:23 +0900
category: 컴퓨터시스템
---
# 연결(링크) 단계 코드 최적화 결과의 요약 — 무엇이, 얼마나, 왜 빨라졌는가

이 문서는 **연결(Link) 단계에서 수행되는 코드 최적화(= LTO/Whole-Program/ThinLTO 등)** 의 **결과를 정리·해석**하는 방법을 체계적으로 정리한다.  
핵심은 **무엇이 최적화되었는지(변환 목록)**, **얼마나 개선되었는지(정량 지표)**, **왜 그 효과가 났는지(원인 분석)** 를 깔끔히 요약하는 것이다.

---

## 1) 연결 단계 최적화가 하는 일(요약)

연결기(링커)나 LTO 단계는 **번역 단위(TU) 경계 너머**를 보며 다음을 수행한다.

- **절차간 최적화(IPO)**
  - *교차 TU 인라이닝*, *전역 상수 전파*, *죽은 코드/데이터 제거(DCE/DSE)*  
  - *함수 특수화/클로닝*, *가상호출 제거(Devirtualization)*, *별칭·escape 분석을 통한 로드/스토어 줄이기*
- **레이아웃/크기 최적화**
  - *섹션 가비지 컬렉션*(`--gc-sections`, `-ffunction-sections`/`-fdata-sections`)  
  - *일치 코드 접기(ICF, Identical Code Folding)*, *핫/콜드 분리*, *함수/BB 재배치(프로파일 기반)*
- **인터페이스 최적화**
  - *가시성 축소*(`-fvisibility=hidden`), *의미적 인터포지션 완화*(`-fno-semantic-interposition`, 링크 시 `-Bsymbolic`)  
  - PLT/GOT 간접 비용 완화(플랫폼/툴체인 의존)
- **프로파일 결합(PGO+LTO)**
  - 핫 경로에 *공격적 인라이닝/재배치*, 콜 그래프 기반 *I-cache/TLB 친화적* 배치

---

## 2) 결과 요약을 위한 표준 템플릿

아래 형식으로 “전/후”를 비교하면 한눈에 읽힌다.

### 2.1 성능·자원 지표(필수)
- **벽시계 시간**(중앙값, 95% CI): `T_old → T_new (△%)`
- **CPU 시간**(user/sys), **명령 수**, **CPI/IPC**: `inst`, `cycles`, `IPC`
- **핫 루프 처리량/지연**: req/s, MB/s, kernel/ns
- **캐시/분기 이벤트**: L1/L2/L3 miss rate, branch-miss
- **메모리 대역/페이지 폴트**(해당 시)
- **바이너리 크기**: text/data/rodata, 심볼 수
- **링크 시간/빌드 메모리**(ThinLTO 여부)

### 2.2 변환 요약(무엇이 적용되었나)
- [ ] 교차 TU 인라이닝 N건 (대표 함수: `foo()→bar()` …)  
- [ ] 가상호출 → 직접호출 변환 M건 (타입 `T::f()` 단일 구현)  
- [ ] DCE/DSE로 제거된 함수/전역/테이블 K개  
- [ ] ICF로 접힌 함수 L쌍  
- [ ] 섹션 GC로 제거된 불용 섹션 S개  
- [ ] 함수/BB 재배치 적용(프로파일 입력: OOO.prof)  
- [ ] 가시성 축소(외부 심볼 ↓), PLT 진입 건수 감소

### 2.3 영향 분석(왜 빨라졌는가)
- **인라이닝** → 호출 오버헤드 ↓, **상수 전파**와 **분기 제거** 연쇄  
- **Devirtualization** → 간접 분기 → 직접 분기, 예측률↑, 더 깊은 최적화 허용  
- **레이아웃 최적화** → I-cache/TLB 지역성↑, 분기 타깃 근접  
- **섹션 GC/ICF** → 코드 크기↓ → I-cache 압박↓  
- **가시성 축소/인터포지션 완화** → 링커가 *외부에서 바뀌지 않음*을 가정, 공격적 최적화 가능

---

## 3) “전/후” 미니 사례(개념)

### 3.1 교차 TU 인라이닝 + 상수 전파
```c
// a.c
extern int scale;
int g(int x) { return x * scale; }

// b.c
int scale = 2;
int f(int *a, int n) {
    int s=0;
    for (int i=0;i<n;i++) s += g(a[i]); // 전: g() 호출
    return s;
}
```
**LTO 후**: `g()` 인라인 + `scale=2` 상수 전파 → `s += a[i] * 2;`  
→ 호출 제거, 곱셈 상수화(강도 감소/벡터화 유리), 분기/레지스터 압박 완화

### 3.2 Devirtualization(단일 구현 확인)
```c
// 전: virtual call
sum += obj->vfunc(x);

// 후: 단일 구현이면
sum += T_vfunc_impl(x); // 직접 호출 + 추가 인라이닝 가능
```
→ 간접 분기 제거, 파이프라인/분기예측에 유리

### 3.3 ICF + 섹션 GC
동일 바이트열의 `static` 헬퍼들이 **ICF**로 하나로 접힘. 사용되지 않는 에러 경로/테이블은 **섹션 GC**로 제거.  
→ 바이너리 `text` 수% 감소 → I-cache 미스율 하락

---

## 4) 흔한 정량 결과(경험칙)

> 실제 수치는 워크로드/코드베이스/툴체인에 따라 달라지지만, 보고서에 자주 등장하는 범위:

- **핫 루프/핫 경로**: 5–30% 개선 (인라이닝 + 분기 제거 + 레이아웃)  
- **바이너리 크기**: −3% ~ −25% (GC/ICF/Hot-Cold 분리) — *단*, 과도한 인라이닝으로 +가 될 수 있음  
- **분기 미스율**: 상대 10–40% 감소(간접→직접, 타깃 근접)  
- **IPC**: +5–20% (스톨 감소, μop 캐시 히트 증가)  
- **링크 시간/메모리**: +30–300% (Full LTO). ThinLTO로 완화 가능

---

## 5) 성공/실패를 가르는 설정(체크리스트)

- **컴파일러/링커 플래그**
  - `-O3 -flto`(혹은 ThinLTO), `-fvisibility=hidden`
  - 빌드 전역 `-ffunction-sections -fdata-sections` + 링크 `--gc-sections`
  - (가능 시) `-fno-semantic-interposition` 또는 링크 `-Bsymbolic`  
  - PGO: *train → build with profile → link*
- **경계 조건**
  - **공유 라이브러리/플러그인**: 인터포지션 의존 코드면 보수적; ABI 요구 확인  
  - **ODR/UB**: ODR 위반(한 심볼의 상이한 정의)이나 UB는 LTO에서 *더 크게* 폭발
  - **디버깅/프로파일**: 심볼 축소로 디버깅 체감 악화 — `-g`/split DWARF 고려
- **빌드 속도**
  - 대규모 프로젝트는 **ThinLTO** + 증분 빌드, *캐시/디스트리뷰티드 빌드* 도입

---

## 6) 보고서에 꼭 넣을 “원인–증거” 매핑

| 결과(관측) | 원인(변환) | 증거(어떻게 확인?) |
|---|---|---|
| 호출 수↓, IPC↑ | TU 간 인라이닝 | `perf record` 콜그래프, `objdump`에서 call → fallthrough |
| 분기 미스율↓ | Devirtualization/레이아웃 | `branch-misses` 감소, 간접 점프 사라짐 |
| 코드 크기↓ | 섹션 GC/ICF | 링크 로그(`--print-gc-sections`), `size`/`nm` 변화 |
| L1I miss↓ | 함수/BB 재배치 | `I-cache-misses` 감소, 핫 블록 근접 배치 |
| 캐시 라인 충돌↓ | Hot/Cold 분리 | cold 경로 별도 섹션/페이지로 이동 |

---

## 7) 실패·퇴행 사례와 대처

- **코드 팽창(I-cache 압박)**: 인라이닝 한도를 낮추거나 *PGO 가이드*로 핫패스만 인라인  
- **링크 시간 폭증**: ThinLTO 전환, LTO 파티셔닝 조정  
- **외부 심볼 의존(인터포지션)**: 설계 재검토 or LTO 제외 모듈 지정  
- **수치 오차 변화**: 인라이닝 후 연산 재배열(특히 FP). 허용 오차/검증 업데이트

---

## 8) 샘플 “최종 요약” 문구(보고서에 바로 붙여 쓰기)

> **요약** — LTO(ThinLTO) + PGO 적용 결과, **핵심 워크로드 X**의 *p95 지연*이 **112ms → 93ms(−17%)**, *처리량*이 **+14%** 개선되었다. 링크 로그 기준 **교차 TU 인라이닝 137건**, **devirt 26건**, **섹션 GC로 2.3MB**, **ICF로 0.7MB**를 감축했고, `perf` 측정에서 **branch-miss −28%**, **I-cache-miss −19%**, **IPC +11%**가 확인되었다. 반면 **링크 시간 +65%** 증가가 있었고, 일부 비핫 경로의 코드 팽창을 억제하기 위해 인라이너 임계값을 조정했다.

---

## 9) 부록 — 결과 캡쳐를 위한 명령 예(플랫폼 예시)

```bash
# 크기/심볼/섹션
size ./app
nm -C --size-sort ./app | head
objdump -d ./app | less

# 런타임 성능 카운터
perf stat -e cycles,instructions,branch-misses,icache.misses ./app <input>
perf record -g ./app <input> && perf report

# 링크 로그(예: lld/gold 옵션은 환경별 상이)
ld.lld --print-gc-sections ...
```

---

## 10) 결론

연결 단계 최적화는 **모듈 경계를 없애서** 컴파일러가 *알고 있던 최적화*를 **더 멀리, 더 강하게** 적용하게 만든다.  
**요약의 핵심**은:
1) **정량 지표**(시간·IPC·미스율·크기)를 “전/후”로,  
2) **변환 내역**(인라인·devirt·GC/ICF·레이아웃)을 **체크박스**로,  
3) **원인–증거 매핑**을 표로 제시하는 것.  
이 틀만 지키면, 팀/리뷰어/미래의 나에게도 *한 장짜리로 설득력 있는* 결과 보고가 된다.