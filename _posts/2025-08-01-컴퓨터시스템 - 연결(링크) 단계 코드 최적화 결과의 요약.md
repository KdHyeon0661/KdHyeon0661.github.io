---
layout: post
title: 컴퓨터시스템 - 연결(링크) 단계 코드 최적화 결과의 요약
date: 2025-08-01 23:20:23 +0900
category: 컴퓨터시스템
---
# 단계 코드 최적화 결과의 요약 — 무엇이, 얼마나, 왜 빨라졌는가

본 문서는 **연결(Link) 단계에서 수행되는 코드 최적화(LTO/ThinLTO/Whole-Program)** 의 **결과를 요약·해석**하는 실무 가이드이다.
핵심은 다음 세 가지를 간단명료하게 제시하는 것에 있다:

1) **무엇이 최적화되었는지**(변환 목록),
2) **얼마나 개선되었는지**(정량 지표),
3) **왜 그런 효과가 났는지**(원인 분석).

또한 결과 재현을 위한 **측정 절차·명령 예**, 실패 시 **대응 팁**, 보고서에 바로 붙여 쓸 **템플릿**을 포함한다.

---

## 연결 단계 최적화가 하는 일(요약·원리)

링커 또는 LTO 단계는 **번역 단위(TU)** 경계를 넘어 전체 프로그램을 보며 다음을 수행한다.

### 절차간 최적화(IPO)

- **교차 TU 인라이닝**: 다른 파일의 짧은 함수 호출을 제거하고 본문으로 병합.
- **전역 상수 전파/접근 축소**: 전역 `const`/불변 값을 멀리까지 밀어 넣어 분기 제거·강도 감소.
- **죽은 코드/데이터 제거(DCE/DSE)**: 사용되지 않는 함수·테이블·전역 제거.
- **함수 특수화/클로닝**: 호출 사이트의 상수/타입을 반영해 분기 제거·루프 단순화.
- **Devirtualization(가상호출 제거)**: 실제 구현이 단일이면 간접 분기 → 직접 호출로 변환.
- **별칭/escape 분석**: 전역 포인터·함수 포인터에 대한 보수적 가정 완화 → 불필요 load/store 축소.

### 레이아웃/크기 최적화

- **섹션 가비지 컬렉션**: `-ffunction-sections -fdata-sections` + `--gc-sections`로 미사용 섹션 제거.
- **ICF(Identical Code Folding)**: 동일 바이트열 함수 접기.
- **핫/콜드 분리**: 콜드 경로를 떨어뜨려 I-캐시·분기 타깃의 지역성 향상.
- **함수/BB 재배치**(PGO/LBR 기반): 자주 연달아 실행되는 블록을 근접 배치.

### 인터페이스·바인딩 최적화

- **가시성 축소**: `-fvisibility=hidden`으로 외부에 노출되는 심볼 최소화(최적화 범위 확대).
- **의미적 인터포지션 완화**: `-fno-semantic-interposition`, 링킹 옵션 `-Bsymbolic` 등으로 **외부에서 함수 재정의가 없다**는 가정 하에 공격적 최적화 허용.
- **PLT/GOT 간접 비용 감소**: 라이브러리 경계를 넘는 간접 호출·간접 참조를 줄임.

### PGO와의 결합

- 프로파일 입력(PGO)을 LTO에 결합하면 **인라이닝/재배치 결정**이 정확해져 **I-캐시/TLB 히트율**과 **분기 예측률**이 동시 개선.

수식 메모(성능 근사):
$$
\text{Speedup} \approx
\frac{T_\text{old}}{T_\text{new}} =
\frac{\text{Inst}_\text{old} \times \text{CPI}_\text{old}}{\text{Inst}_\text{new} \times \text{CPI}_\text{new}}
$$
LTO는 보통 **Inst 감소(호출·분기·중복 코드 제거)**와 **CPI 개선(간접 분기↓, I-캐시 미스↓)**를 함께 유도한다.

---

## 결과 요약을 위한 표준 템플릿

### 성능·자원 지표(필수)

- **벽시계 시간(중앙값, 95% CI)**: `T_old → T_new (△%)`
- **CPU 시간**(user/sys), **명령 수**(`instructions`), **사이클**(`cycles`), **IPC**
- **핫 루프 처리량/지연**: req/s, MB/s, kernel/ns
- **캐시/분기 이벤트**: L1/L2/L3 miss rate, `branch-misses`
- **메모리 대역/페이지 폴트**(해당 시)
- **바이너리 크기**: `.text/.data/.rodata`, 심볼 수
- **링크 시간/빌드 메모리 사용량**(Full LTO vs ThinLTO)

### 변환 요약(무엇이 적용되었나)

- [ ] 교차 TU 인라이닝 **N**건 (대표: `g()->f()` …)
- [ ] Devirtualization **M**건 (`T::vfunc` 단일 구현)
- [ ] DCE/DSE로 제거된 함수/전역/테이블 **K**개
- [ ] ICF로 접힌 함수 **L**쌍
- [ ] 섹션 GC로 제거된 섹션 **S**개
- [ ] 함수/BB 재배치 적용(프로파일: `profile.prof`)
- [ ] 가시성 축소(외부 심볼 ↓), PLT 진입 건수 감소

### 영향 분석(왜 빨라졌는가)

- **인라이닝** → 호출 오버헤드↓, **상수 전파**·**분기 제거**·**벡터화 용이**.
- **Devirtualization** → 간접 분기→직접 분기, 예측률↑, 파이프라인 버블↓.
- **레이아웃 최적화** → **I-캐시/TLB 지역성↑**, 분기 타깃 근접.
- **섹션 GC/ICF** → 코드 크기↓ → I-캐시 압박↓.
- **가시성 축소·인터포지션 완화** → 링커/컴파일러가 **불변 가정** 하에 더 깊은 최적화.

아래 표 형식으로 **관측–원인–증거**를 매핑하면 설득력이 크다.

| 관측(전/후 변화) | 원인(변환) | 증거(확인 방법) |
|---|---|---|
| `IPC +11%` | 인라이닝 + 레이아웃 | `perf`의 `instructions`, `cycles` 변화 & objdump에서 `call` 감소 |
| `branch-miss -28%` | Devirt + 타깃 근접 | `perf stat -e branch-misses`, 간접점프 사라짐 |
| `.text -12%` | ICF + GC | `--print-gc-sections`, `size` 차이 |
| `I-cache-miss -19%` | 핫/콜드 분리 + 재배치 | `icache.misses` 감소, 핫 블록 근접 배치 |

---

## “전/후” 미니 사례(개념→코드)

### 교차 TU 인라이닝 + 상수 전파

```c
/* a.c */
extern int scale;
int g(int x) { return x * scale; }

/* b.c */
int scale = 2;
int f(int *a, int n) {
    int s = 0;
    for (int i=0; i<n; i++) s += g(a[i]);  // 전: g() 호출
    return s;
}
```

**LTO 후(개념)**: `g()` 인라인 + `scale=2` 전파 → 본문이 `s += a[i] * 2;`로 단순화
→ 호출 제거 + 강도 감소(곱셈 상수화) + 벡터화/언롤링 유리

### Devirtualization(단일 구현 확인)

```c
// 전: 가상 호출(간접 분기)
sum += obj->vfunc(x);

// 후: 단일 구현 확정 시
sum += T_vfunc_impl(x);   // 직접 호출로 치환 → 추가 인라이닝 가능
```

→ 간접 분기 제거로 **예측률 상승**, μop 캐시/BTB 효율 향상

### ICF + 섹션 GC

- 정적 헬퍼가 여러 TU에 중복 생성된 경우 **ICF**가 동일 바이트열을 **1개로 접음**.
- 에러 경로/미사용 테이블은 **섹션 GC**로 제거.
→ `.text` 수% 감소 → I-캐시 미스율 하락

---

## LTO/ThinLTO 설정(도구별 실전 스니펫)

### Clang/LLVM (Linux/macOS)

```bash
# Full LTO

clang -O3 -flto -fvisibility=hidden -ffunction-sections -fdata-sections -c a.c b.c
clang -O3 -flto -Wl,--gc-sections -Wl,-O3 -o app a.o b.o

# ThinLTO (+ 캐시)

clang -O3 -flto=thin -fvisibility=hidden -ffunction-sections -fdata-sections -c a.c b.c
clang -O3 -flto=thin -Wl,--thinlto-cache-dir=.thinlto-cache -Wl,--gc-sections -o app a.o b.o

# 인터포지션 완화(공유 라이브러리 외 내부 빌드에서 유효)

clang -O3 -flto -fno-semantic-interposition ...
```

### GCC (+ gold/ld.lld 플러그인)

```bash
# LTO + GC + ICF(링커 옵션 환경별 상이)

gcc -O3 -flto -fvisibility=hidden -ffunction-sections -fdata-sections -c a.c b.c
gcc -O3 -flto -Wl,--gc-sections -Wl,--icf=all -o app a.o b.o
```

### MSVC (Windows, LTCG)

```text
# /GL (LTCG), /Gy /Gw (섹션 분리), /OPT:REF (GC), /OPT:ICF (코드 접기)

cl /O2 /GL /Gy /Gw a.cpp b.cpp
link /LTCG /OPT:REF /OPT:ICF /OUT:app.exe a.obj b.obj
```

### CMake (플랫폼 공통)

```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)        # LTO on
add_executable(app a.c b.c)
target_compile_options(app PRIVATE -O3 -fvisibility=hidden -ffunction-sections -fdata-sections)
target_link_options(app PRIVATE -Wl,--gc-sections)
```

> 주의: **공유 라이브러리**에서 `-Bsymbolic`/`-fno-semantic-interposition`은 의도된 인터포지션(후킹)을 무력화할 수 있다. ABI/플러그인 정책을 검토하라.

---

## 측정 프로토콜(재현 가능한 평가)

### 스크립트(리눅스 예)

```bash
# 빌드: baseline vs LTO

make clean && make MODE=baseline
mv app app.baseline

make clean && make MODE=lto
mv app app.lto

# perf 측정(중앙값/표준편차 확보를 위해 여러 번 반복)

for i in {1..10}; do /usr/bin/time -f "%E" ./app.baseline < in > /dev/null; done
for i in {1..10}; do /usr/bin/time -f "%E" ./app.lto      < in > /dev/null; done

# 하드웨어 카운터

perf stat -e cycles,instructions,branch-misses,icache.misses ./app.baseline < in >/dev/null
perf stat -e cycles,instructions,branch-misses,icache.misses ./app.lto      < in >/dev/null

# 크기·심볼

size app.baseline app.lto
nm -C --size-sort app.lto | head
```

### 정량 요약(보고서 표)

| 지표 | Baseline | LTO | 변화(%) |
|---|---:|---:|---:|
| 벽시계 시간(중앙값) | 112 ms | 93 ms | −17.0 |
| instructions | 2.31e9 | 2.02e9 | −12.6 |
| cycles | 7.08e9 | 6.05e9 | −14.5 |
| IPC | 0.33 | 0.33 | ≈ |
| branch-miss | 1.8% | 1.3% | −27.8 |
| icache.misses | 3.1e6 | 2.5e6 | −19.4 |
| .text 크기 | 18.2 MB | 16.0 MB | −12.1 |
| 링크 시간 | 42 s | 69 s | +64.3 |

> IPC가 동일해도 **Inst 감소**만으로 의미 있는 개선이 가능하다. 반대로 간접 분기 제거·레이아웃 최적화가 잘 먹히면 **IPC**도 유의미하게 상승한다.

---

## 원리별 효과 해석(왜 빨라졌는가 — 상세)

### 인라이닝(+ 전파)의 연쇄

- **호출 오버헤드 제거**: 프로시저 콜/리턴 + 저장/복원 제거.
- **상수 전파/루프 단순화**: 호출 본문이 열리며 호출자 컨텍스트 상수가 들어와 **분기 제거/강도 감소** 유도.
- **레지스터 압박 상충**: 과도한 인라이닝은 레지스터 스필↑로 역효과 → **PGO**나 인라이너 한계값 조정으로 제어.

### Devirtualization

- 가상 테이블 간접 점프 제거 → **분기 예측률↑**, μop 캐시 히트↑.
- 직접 호출이 되면 **추가 인라이닝**·전파가 열림 → 루프 벡터화 가능성↑.

### 레이아웃 최적화

- **핫/콜드 분리**: 콜드 경로를 먼 페이지로 보내 **I-캐시**와 **ITLB** 압박 완화.
- **BB 재배치**: 자주 연달아 실행되는 경로를 선형으로 배치 → **분기 타깃 근접** 및 페치 효율 개선.

### 코드 크기 감소(ICF/GC)

- **중복 함수 접기(ICF)** + **미사용 섹션 제거**로 `.text` 축소 → **I-캐시 미스율** 저하.
- 단, **인라이닝으로 .text 증가** 가능 → ICF/GC와 **균형** 필요.

---

## 실패·퇴행 시그널과 대처

| 증상 | 가능 원인 | 해결 가이드 |
|---|---|---|
| 성능 무변/악화 | 인라이닝 과도 → 스필↑, I-캐시 압박 | 인라이너 한도↓, PGO로 핫패스만 인라인 |
| 링크 시간/메모리 폭증 | Full LTO 규모 부담 | **ThinLTO** 전환, 파티셔닝·캐시 사용 |
| 기능 퇴행/크래시 | ODR 위반·UB가 LTO에서 증폭 | ODR 점검(단일 정의), UBSan/ASan로 정화 |
| 인터포지션 의존 코드 깨짐 | `-fno-semantic-interposition`/`-Bsymbolic` 오남용 | ABI/플러그인 계약 재검토, 해당 모듈 제외 |
| FP 결과 차이 | 인라이닝 후 재배열 | 허용 오차 정책 문서화·검증 범위 조정 |

---

## 보고서 템플릿(바로 붙여 쓰기)

### 한 장 요약

> **요약** — LTO(ThinLTO) + PGO 적용 결과, 워크로드 **X**의 p95 지연이 **112ms → 93ms(−17%)**, 처리량이 **+14%** 개선되었다. 링크 로그 기준 **교차 TU 인라이닝 137건**, **devirt 26건**, **섹션 GC로 2.3MB**, **ICF로 0.7MB** 감축. `perf`에서 **branch-miss −28%**, **icache.misses −19%**, **IPC +11%** 확인. 부작용으로 링크 시간 **+65%** 증가가 있어 인라이너 임계값 조정 및 **ThinLTO 캐시**를 활성화했다.

### 체크리스트(채워넣기)

- [ ] 빌드 플래그: `-O3 -flto(=thin)` / `/GL /LTCG`, `-fvisibility=hidden`, `--gc-sections`, ICF
- [ ] 인터포지션 정책: 허용/비허용 모듈 구분(필요 시 `-Bsymbolic` 제외)
- [ ] PGO: 프로파일 수집·정합 확인(입력 분포 대표성 점검)
- [ ] ODR/UB 점검: 복수 정의/미정의 동작 제거
- [ ] 측정: **baseline vs LTO** 10회 이상 반복, 중앙값·CI 보고
- [ ] 아티팩트: 크기·심볼·링크 로그·perf 리포트 동봉

---

## 실무 예제(작은 프로젝트로 재현)

### 코드(교차 TU 인라이닝 대상)

```c
/* mathlib.h */
#pragma once

int mul2(int x);

/* mathlib.c */
#include "mathlib.h"

int coef = 2;
int mul2(int x){ return x * coef; }

/* main.c */
#include "mathlib.h"
#include <stdio.h>

int coef = 2; // 동일 TU 외부 정의(전역 불변 가정 가능)
int main(){
    int s=0;
    for(int i=0;i<10000000;i++)
        s += mul2(i);     // 전: 호출
    printf("%d\n", s);
    return 0;
}
```

### 빌드 & 측정(Clang)

```bash
# Baseline

clang -O3 -fvisibility=hidden -ffunction-sections -fdata-sections \
      -c main.c mathlib.c
clang -O3 -Wl,--gc-sections -o app.base main.o mathlib.o

# LTO

clang -O3 -flto -fvisibility=hidden -ffunction-sections -fdata-sections \
      -c main.c mathlib.c
clang -O3 -flto -Wl,--gc-sections -o app.lto main.o mathlib.o

/usr/bin/time -f "%E" ./app.base > /dev/null
/usr/bin/time -f "%E" ./app.lto  > /dev/null
size app.base app.lto
objdump -d app.base | grep -c "call"
objdump -d app.lto  | grep -c "call"
```

**기대 해석(개념)**: `mul2()` 인라인 + `coef=2` 전파 → 루프가 `s += i*2;`로 단순화, `call` 수 급감, `.text` 감소.

---

## 플랫폼·언어 별 보강 팁

- **ELF(리눅스)**: `-fvisibility=hidden` 기본, 필요한 심볼만 `__attribute__((visibility("default")))`.
  인터포지션을 쓰지 않는 내부 바이너리는 `-fno-semantic-interposition` 검토.
- **Windows**: `/GL`+`/LTCG`, `/OPT:REF`(GC), `/OPT:ICF`(접기), `__declspec(dllexport)`로 내보내기 최소화.
- **macOS**: LTO 동작, `-dead_strip`로 미사용 제거.
- **Rust**: `-C lto=fat|thin`, `-C codegen-units=1`(크로스 크레이트 최적화 강화), `panic=abort`로 크기↓.
- **Sanitizer와 병용**: ASan/TSan 빌드는 최적화·레이아웃 영향 큼 → **비교는 같은 설정끼리**.

---

## 자주 묻는 질문(FAQ)

**Q1. LTO인데 왜 성능이 그대로인가?**
A. 병목이 I/O·메모리 대역·시스템 콜일 수 있다. 또한 인라이닝 임계값/PGO 부재로 인라이너가 조심스러울 수 있다. **PGO 결합**, **데이터 레이아웃** 개선, **ThinLTO 재배치**를 점검하라.

**Q2. .text가 오히려 커졌는데 성능은 좋아졌다?**
A. 인라이닝으로 코드가 커져도 **분기 제거**와 **I-캐시 지역성 향상**이 더 큰 이득일 수 있다. **perf의 icache.misses/IPC**로 트레이드오프를 판단하라.

**Q3. 플러그인/후킹을 쓰는데 인라이닝이 과감해졌다?**
A. 인터포지션을 전제로 한 설계에서는 `-fno-semantic-interposition`/`-Bsymbolic` 사용을 피하고, 외부 가시성을 유지하라. 모듈 경계를 명확히.

---

## 부록 — 명령 치트시트

```bash
# 크기·섹션

size ./app
objdump -dS ./app | less
readelf -Ws ./app | sort -k3

# 링크 로그(LLD 예)

ld.lld --print-gc-sections ...

# perf(요지)

perf stat -e cycles,instructions,branch-misses,icache.misses ./app <in> >/dev/null
perf record -g ./app <in> && perf report
```

---

## 결론

연결 단계 최적화는 **모듈 경계**를 제거하여, 컴파일러가 알고 있던 최적화를 **더 멀리·더 강하게** 적용하게 만든다.
보고서의 핵심은 다음 세 가지를 **짧고 강하게** 제시하는 것이다.

1. **정량 지표**: 시간·IPC·미스율·크기 **전/후** 비교.
2. **변환 내역**: 인라인·devirt·GC/ICF·레이아웃 **체크리스트**.
3. **원인–증거 매핑**: 관측→변환→증거를 **표로 연결**.

이 틀을 지키면, 팀/리뷰어/미래의 자신에게 **한 장으로 납득되는** 성과 요약을 제공할 수 있다.
