---
layout: post
title: 알고리즘 - 재귀
date: 2025-01-29 19:20:23 +0900
category: 알고리즘
---
# 재귀(Recursion) 완전 정리

## 재귀란 무엇인가 — 호출과 귀환

> 함수가 **자기 자신을 호출**하여 문제를 같은 형태의 더 작은 하위 문제로 축소하고, **기저(base) 조건**에서 멈춘 뒤 결과를 누적하거나 결합한다.

### 기본 골격(초안 보강)

```python
def rec(state):
    if is_base(state):
        return base_value(state)
    # 1) 하위 문제로 축소
    sub_states = split(state)
    # 2) 하위 문제 해결
    sub_solutions = [rec(s) for s in sub_states]
    # 3) 결합
    return merge(sub_solutions)
```

### 호출 스택과 재귀 트리

- **호출 스택**: 각 호출은 지역 변수/매개변수/복귀주소를 담는 **스택 프레임**을 만든다.
- **재귀 트리**: 분할정복의 분기(예: 2갈래 분할)는 높이와 노드 수가 시간 복잡도를 좌우한다.

예) `T(n) = 2T(n/2) + O(n)`일 때, 높이 \( \log_2 n \), 레벨별 비용 합 \( O(n) \Rightarrow O(n \log n) \).

---

## 시간·공간 분석: 점화식 세우기와 해석

### 점화식 세우기

- **예 1: 피보나치 순열(순수 재귀)**
  $$
  T(n) = T(n-1) + T(n-2) + O(1) \Rightarrow T(n) = \Theta(\varphi^n)
  $$
  (매우 비효율 → 메모이제이션 필요)

- **예 2: 병합 정렬**
  $$
  T(n) = 2T(n/2) + O(n) \Rightarrow T(n)=\Theta(n\log n)
  $$

- **예 3: 이진 탐색**
  $$
  T(n) = T(n/2) + O(1) \Rightarrow T(n) = \Theta(\log n)
  $$

### 마스터 정리(분할정복)

$$
T(n) = aT\!\left(\frac{n}{b}\right) + f(n)
$$
- \( f(n) = O(n^{\log_b a - \epsilon}) \Rightarrow T(n) = \Theta(n^{\log_b a}) \)
- \( f(n) = \Theta(n^{\log_b a} \log^k n) \Rightarrow T(n) = \Theta(n^{\log_b a} \log^{k+1} n) \)
- \( f(n) = \Omega(n^{\log_b a + \epsilon})\), 정규성 조건 하에 \( T(n) = \Theta(f(n)) \)

### 공간 복잡도

- **재귀 깊이** × **프레임당 공간**.
- 분할정복의 **병합 과정**이 추가 배열을 요구하면 그 크기도 고려(예: 병합 정렬의 보조배열 \(O(n)\)).

---

## 재귀 vs 반복 — 전환과 선택

| 항목 | 재귀 | 반복 |
|---|---|---|
| 가독성 | 트리/분할정복/백트래킹에 직관적 | 루프/상태기계에 직관적 |
| 오버헤드 | 호출/프레임 비용 | 작음 |
| 깊이 제한 | 언어 스택 제한 영향 | 없음 |
| 전환 용이성 | 명시적 스택으로 전환 가능 | 일부는 재귀가 자연스러움 |

### 명시적 스택으로 바꾸기(템플릿)

```python
def dfs_iter(root):
    stack = [root]
    while stack:
        state = stack.pop()
        if is_base(state):
            process_base(state); continue
        # 재귀의 '나중 처리'가 필요하면 태그를 함께 푸시
        children = split(state)
        for child in reversed(children):
            stack.append(child)
```

### 꼬리 재귀

- Python은 **TCO 미지원**. 꼬리재귀는 **반복**으로 바꾸는 것이 안전.

---

## 파이썬에서의 재귀 — 실전 주의

```python
import sys
sys.setrecursionlimit(1_000_000)  # DFS/분할정복에서 필요할 수 있음
```

- 깊이 10만 단위는 CPython에서 여전히 위험. 가능하면 **반복/스택**으로.
- 리스트 vs 튜플: 빈번한 작은 객체 생성 비용 고려(핫패스라면 최적화).

---

## 패턴 라이브러리 — 바로 갖다 쓰는 재귀 레시피

### 분할정복: 거듭제곱(빠른 거듭제곱, BOJ 1629)

```python
def fpow(a, b, mod):
    if b == 0: return 1
    half = fpow(a, b//2, mod)
    res = (half*half) % mod
    if b & 1: res = (res * a) % mod
    return res
```

### 분할정복: 병합 정렬(BOJ 24060 계열)

```python
def merge_sort(a):
    n = len(a)
    if n <= 1: return a[:]
    mid = n // 2
    L = merge_sort(a[:mid])
    R = merge_sort(a[mid:])
    i=j=0; out=[]
    while i < len(L) and j < len(R):
        if L[i] <= R[j]: out.append(L[i]); i+=1
        else: out.append(R[j]); j+=1
    out.extend(L[i:]); out.extend(R[j:])
    return out
```

### 트리 순회(BOJ 1991)

```python
# tree: dict[node] = (left, right), '.'는 없음

def preorder(u):
    if u == '.': return
    print(u, end='')
    l,r = tree[u]
    preorder(l); preorder(r)

def inorder(u):
    if u == '.': return
    l,r = tree[u]
    inorder(l); print(u, end=''); inorder(r)

def postorder(u):
    if u == '.': return
    l,r = tree[u]
    postorder(l); postorder(r); print(u, end='')
```

### 백트래킹(조합/순열) — 상태 복원

```python
def comb(arr, k, start=0, path=None):
    if path is None: path=[]
    if len(path) == k:
        print(path); return
    for i in range(start, len(arr)):
        path.append(arr[i])
        comb(arr, k, i+1, path)
        path.pop()

def perm(arr, used=None, path=None):
    if used is None: used=[False]*len(arr)
    if path is None: path=[]
    if len(path) == len(arr):
        print(path); return
    for i,v in enumerate(arr):
        if used[i]: continue
        used[i]=True; path.append(v)
        perm(arr, used, path)
        path.pop(); used[i]=False
```

### 프랙탈/패턴(BOJ 2447 칸막이 별)

```python
def star(n):
    if n == 1: return ["*"]
    t = star(n//3)
    top = [s*3 for s in t]
    mid = [s + " "*(n//3) + s for s in t]
    return top + mid + top
```

### 종이 자르기(BOJ 2630/1780) — 균일 영역 카운트

```python
def quad_count(board, x, y, n):
    first = board[x][y]
    all_same = True
    for i in range(x, x+n):
        for j in range(y, y+n):
            if board[i][j] != first:
                all_same = False; break
        if not all_same: break
    if all_same:
        return {first:1}
    n2 = n//2
    res = {}
    for (dx,dy) in [(0,0),(0,n2),(n2,0),(n2,n2)]:
        sub = quad_count(board, x+dx, y+dy, n2)
        for k,v in sub.items(): res[k] = res.get(k,0)+v
    return res
```

### 이진 탐색(재귀/반복)

```python
def bsearch(a, t, l=0, r=None):
    if r is None: r = len(a)-1
    if l > r: return -1
    m = (l+r)//2
    if a[m]==t: return m
    if a[m] > t: return bsearch(a, t, l, m-1)
    return bsearch(a, t, m+1, r)
```

---

## 메모이제이션과 DP — 재귀 최적화

### 피보나치: 순수 재귀 → 메모이제이션

```python
from functools import lru_cache

@lru_cache(None)
def fib(n):
    if n < 2: return n
    return fib(n-1) + fib(n-2)
```

- 시간 \(O(n)\), 공간 \(O(n)\).

### 탑다운 → 보텀업 전환

```python
def fib_iter(n):
    if n < 2: return n
    a,b = 0,1
    for _ in range(2, n+1):
        a,b = b,a+b
    return b
```

---

## 백준 실전 문제 모음 — 재귀로 푼다

### — 피보나치 수(재귀/메모)

```python
import sys
sys.setrecursionlimit(1_000_000)
from functools import lru_cache
@lru_cache(None)
def fib(n):
    if n<2: return n
    return fib(n-1)+fib(n-2)

print(fib(int(sys.stdin.readline())))
```

### — 하노이 탑(이동 횟수와 경로)

```python
import sys
input = sys.stdin.readline

def hanoi(n, a, b, c, moves):
    if n == 1:
        moves.append((a,c)); return
    hanoi(n-1, a, c, b, moves)
    moves.append((a,c))
    hanoi(n-1, b, a, c, moves)

n = int(input())
moves = []
hanoi(n, 1, 2, 3, moves)
print(len(moves))
print('\n'.join(f"{x} {y}" for x,y in moves))
```

### — 별 찍기 - 10(프랙탈)

```python
import sys
sys.setrecursionlimit(1_000_000)

def star(n):
    if n == 1: return ["*"]
    t = star(n//3)
    top = [s*3 for s in t]
    mid = [s + " "*(n//3) + s for s in t]
    return top + mid + top

n = int(sys.stdin.readline())
print('\n'.join(star(n)))
```

### — 색종이 만들기(사분할)

```python
import sys
input = sys.stdin.readline
n = int(input())
board = [list(map(int, input().split())) for _ in range(n)]

white = blue = 0

def solve(x, y, m):
    global white, blue
    first = board[x][y]
    uniform = True
    for i in range(x, x+m):
        for j in range(y, y+m):
            if board[i][j] != first:
                uniform = False; break
        if not uniform: break
    if uniform:
        if first == 0: white += 1
        else: blue += 1
        return
    k = m//2
    solve(x, y, k)
    solve(x, y+k, k)
    solve(x+k, y, k)
    solve(x+k, y+k, k)

solve(0,0,n)
print(white)
print(blue)
```

### — 종이의 개수(3분할)

```python
import sys
input = sys.stdin.readline
n = int(input())
a = [list(map(int, input().split())) for _ in range(n)]
cnt = {-1:0, 0:0, 1:0}

def cut(x,y,m):
    first = a[x][y]
    ok = True
    for i in range(x, x+m):
        for j in range(y, y+m):
            if a[i][j] != first:
                ok = False; break
        if not ok: break
    if ok:
        cnt[first] += 1; return
    k = m//3
    for dx in (0,k,2*k):
        for dy in (0,k,2*k):
            cut(x+dx, y+dy, k)

cut(0,0,n)
print(cnt[-1]); print(cnt[0]); print(cnt[1])
```

### — 곱셈(빠른 거듭제곱)

```python
a,b,c = map(int, input().split())
def fpow(x, y):
    if y == 0: return 1
    t = fpow(x, y//2) % c
    t = (t*t) % c
    if y & 1: t = (t*x) % c
    return t % c
print(fpow(a % c, b))
```

### — Z(분할정복 좌표 찾기)

```python
import sys
sys.setrecursionlimit(1_000_000)

n, r, c = map(int, sys.stdin.readline().split())

def z(n, r, c):
    if n == 0: return 0
    half = 1 << (n-1)
    quad = 0
    nr, nc = r, c
    if r >= half:
        quad += 2; nr -= half
    if c >= half:
        quad += 1; nc -= half
    return quad * (half*half) + z(n-1, nr, nc)

print(z(n,r,c))
```

### — 재귀함수가 뭔가요?(출력 형식 재귀)

```python
import sys
input = sys.stdin.readline
n = int(input())

def say(depth):
    indent = "____"*depth
    print(f"{indent}\"재귀함수가 뭔가요?\"")
    if depth == n:
        print(f"{indent}\"재귀함수는 자기 자신을 호출하는 함수라네\"")
    else:
        print(f"{indent}\"잘 들어보게. 옛날옛날 한 산 꼭대기에...\"")
        print(f"{indent}라고 답변하였지.")
        say(depth+1)
        print(f"{indent}라고 답변하였지.")
    if depth == 0:
        # 문제의 정확한 문구에 맞춰 위 메시지들을 조정(요지는 재귀 형식)
        pass
```

> 실제 정답 출력은 문제의 포맷 문자열을 그대로 맞춰야 한다. 핵심은 **깊이에 따른 들여쓰기**와 **귀환 시 역순 출력**.

### — 칸토어 집합(재귀적 제거)

```python
def cantor(n):
    if n == 0: return "-"
    s = cantor(n-1)
    return s + " "*len(s) + s

print(cantor(int(input())))
```

---

## 격자/그래프 DFS도 재귀다

- **Flood Fill**(섬/영역 개수): 4/8방향 DFS가 표준. 깊이가 커지면 **반복+스택**으로 전환 권장.
- **트리 DP**: 자식에서 값을 받아 부모에서 결합하는 형태.

```python
def tree_dp(u, p):
    # 자식 처리
    acc = base()
    for v in g[u]:
        if v == p: continue
        child = tree_dp(v, u)
        acc = combine(acc, child)
    return finalize(acc)
```

---

## 디버깅·검증 체크리스트

1) **기저 조건** 누락(무한 재귀)
2) **상태 복원** 누락(백트래킹에서 `path.pop()`, `used[i]=False`)
3) **인덱스 경계** 오류(분할 시 하위 크기/오프바이원)
4) **합산/결합**의 항등원 설정 실수(예: 합 0, 곱 1, min/max 초기값)
5) **중복 계산**(피보, 분할정복) → 메모이제이션 검토
6) **재귀 깊이** 초과 → 반복 전환, `sys.setrecursionlimit` 조정
7) **출력 순서** 요구(사전식/역순/들여쓰기) 정확히 준수

---

## 수학 메모 — 재귀 트리 직관

- 완전 이진 분할정복(병합정렬):
  $$
  T(n) = 2T(n/2)+n \Rightarrow \text{높이 } \log n, \text{레벨 합 } n \Rightarrow n\log n
  $$
- \(k\)-분할:
  $$
  T(n) = kT\!\left(\frac{n}{k}\right)+\alpha n \Rightarrow \Theta(n\log_k n)
  $$
- 이진 탐색:
  $$
  T(n) = T(n/2)+1 \Rightarrow \Theta(\log n)
  $$

---

## 실전 팁 요약

- **분할정복**: 문제를 균등 분할할 수 있으면 후보. 점화식부터 세워 시간 파악.
- **백트래킹**: 기저조건 먼저, **프루닝 조건**을 빠르게 배치.
- **메모이제이션**: 중복 하위문제 감지 시 즉시 적용.
- **출력형 문제**(프랙탈/대화체): 깊이별 전·후 처리 순서 신중히.
- **파이썬 최적화**: I/O 버퍼링(`sys.stdin.readline`), 지역 변수 바운딩, 리스트 합치기 대신 `append`/`extend`.

---

## 마무리

| 항목 | 요약 |
|---|---|
| 정의 | 자기 자신을 호출해 하위 문제로 축소, 기저 조건에서 종료 |
| 분석 | 점화식 수립 → 전개/마스터 정리, 재귀 깊이 = 공간 |
| 최적화 | 메모이제이션/보텀업, 명시적 스택으로 반복 전환 |
| 패턴 | 분할정복, 백트래킹, 트리 순회, 프랙탈, 수학 재귀 |
| 실전 | 포맷/순서 요구 충족, 프루닝·메모리·재귀한도 관리 |

> 핵심은 **기저 조건의 정확성**과 **하위 문제의 동형성**이다. 여기에 **메모이제이션/프루닝**을 더하면, 간결하면서도 빠른 풀이가 된다.
