---
layout: post
title: Java - 클래스와 객체
date: 2025-07-14 18:20:23 +0900
category: Java
---
# Java의 클래스와 객체

## 1. 클래스(Class)란 무엇인가

- **설계도**: 데이터(필드)와 동작(메서드)을 **하나의 타입**으로 묶어 추상화.
- **소스 파일 구조**: 보통 `package` 선언 → `import` → **최상위 클래스** 1개(`public`이면 파일명과 동일).

### 1.1 기본 골격
```java
package com.example.model;

public class User {
    // 1) 필드(상태)
    private String name;
    private int age;

    // 2) 생성자(초기화)
    public User(String name, int age) {
        this.name = name;
        this.age  = age;
    }

    // 3) 메서드(행동)
    public void birthday() { this.age++; }
    public String profile() { return name + " (" + age + ")"; }
}
```

### 1.2 최상위/중첩 타입 규칙 요약

| 항목 | 가능 제어자 |
|---|---|
| 최상위 클래스/인터페이스/열거형/레코드 | `public`, (default) |
| 중첩(내부) 타입 | `public/protected/(default)/private` 모두 가능 |

---

## 2. 객체(Object)란 무엇인가

- **클래스의 인스턴스**로, `new`로 생성된 **실체**.
- 참조 변수가 **객체를 가리키는 주소**(참조값)를 저장.

```java
User u = new User("Kim", 20); // u는 참조, 실제 객체는 Heap에 존재
```

### 2.1 참조 모델 정리

```java
User u1 = new User("A", 10);
User u2 = u1;          // 같은 객체를 가리킴(별명/alias)
u2.birthday();
System.out.println(u1.profile()); // A (11)  ← 같은 객체 변경 결과 공유
```

#### ASCII 메모리 개념도
```
Stack:                    Heap:
u1 ──────────┐            ┌───────────────┐
u2 ─────┐    ├──▶ 0x1000 │ User{name=A,age=11}
         └──────────────▶ └───────────────┘
```

> **중요**: Java는 **모든 매개변수 전달이 값에 의한 전달(pass-by-value)** 이다.
> 객체의 **참조값**이 값으로 복사되어 전달되므로, 메서드에서 필드 변경이 밖에 **영향을 줄 수 있다**.

---

## 3. 클래스 선언 — 필드/메서드/생성자/정적 멤버

### 3.1 필드(상태)
```java
public class Counter {
    private int value;                 // 인스턴스 필드
    public static final int MAX = 999; // 상수(정적 + final, 대문자 스네이크)
}
```

### 3.2 생성자(초기화 지점)
```java
public class Car {
    private final String brand;
    private int speed;

    public Car(String brand) {         // 매개변수 있는 생성자
        this.brand = java.util.Objects.requireNonNull(brand);
        this.speed = 0;
    }
}
```

### 3.3 메서드(행동)
```java
public void accelerate(int delta) {
    if (delta < 0) throw new IllegalArgumentException();
    this.speed = Math.min(this.speed + delta, 200);
}
```

### 3.4 정적 멤버
```java
public class IdGen {
    private static long seq = 0;  // 클래스 전체 공유
    public static synchronized long next() { return ++seq; }
}
```

---

## 4. 객체 생성과 **초기화 순서**

**`new Sub()` 호출 시 실행 순서:**

1) 상위 타입의 `static` 필드/정적 블록(최초 1회)
2) 메모리 할당, 인스턴스 필드 **기본값**(0/false/null)
3) **부모**의 인스턴스 필드 초기화식/인스턴스 초기화 블록 → **부모 생성자 본문**
4) **자식**의 인스턴스 필드 초기화식/인스턴스 초기화 블록 → **자식 생성자 본문**

### 4.1 눈으로 확인
```java
class P {
    int a = init("P.a");
    { System.out.println("P{}"); }
    P() { System.out.println("P()"); }
    static { System.out.println("P.<clinit>"); }
    int init(String x) { System.out.println(x); return 1; }
}
class C extends P {
    int b = init("C.b");
    { System.out.println("C{}"); }
    C() { System.out.println("C()"); }
    static { System.out.println("C.<clinit>"); }
}
public class Order {
    public static void main(String[] args) { new C(); }
}
```

---

## 5. `this` 키워드와 **생성자 체이닝**

### 5.1 `this`의 의미
- **현재 인스턴스**를 가리킴. 필드/매개변수 이름 충돌 시 구분.
- 인스턴스 메서드 체이닝에 활용.

```java
class Dog {
    private String name;
    Dog setName(String name) { this.name = name; return this; } // 체인 가능
}
```

### 5.2 생성자 간 호출 — `this(...)`
- **반드시 첫 줄**에서만 호출 가능. 중복 초기화 제거.

```java
class Point {
    final int x, y;
    Point() { this(0, 0); }
    Point(int x, int y) { this.x = x; this.y = y; }
}
```

> `this(...)`와 `super(...)`는 **동일 생성자에서 동시에 사용할 수 없음**(둘 다 첫 줄 제한).

---

## 6. 캡슐화와 접근 제어(요약) → 안정 API

```java
public class BankAccount {
    private int balance;

    public void deposit(int amount) {
        if (amount <= 0) throw new IllegalArgumentException();
        balance += amount;
    }
    public int getBalance() { return balance; }
}
```

- **필드 `private` 기본** / 외부 공개는 **검증 메서드**로 제한.
- 변경 불가가 필요하면 **불변(Immutable)** 로 설계.

### 6.1 불변 클래스 기본형
```java
public final class Money {
    private final long amount;
    public Money(long amount) { if (amount < 0) throw new IllegalArgumentException(); this.amount = amount; }
    public long amount() { return amount; }
    public Money add(long delta) { return new Money(this.amount + delta); } // 새 인스턴스 반환
}
```

---

## 7. 정적 멤버 vs 인스턴스 멤버

| 구분 | 소속 | 사용 예 |
|---|---|---|
| 인스턴스 필드/메서드 | 각 객체 | 상태 보유/행동 |
| `static` 필드/메서드 | 클래스 | 상수, 카운터, 팩토리, 유틸 |

```java
class Temperature {
    static double cToF(double c) { return c * 9 / 5 + 32; }
}
double f = Temperature.cToF(25);
```

---

## 8. 동등성 계약 — `equals`/`hashCode`/`toString`/`compareTo`

### 8.1 `==` vs `equals`
- `==` : **동일성(참조가 같은가)**
- `equals` : **논리적 동등성**(내용 비교). 값 객체는 오버라이드 필요.

### 8.2 값 타입 구현 예
```java
public final class Email implements Comparable<Email> {
    private final String local;
    private final String domain;

    public Email(String local, String domain) {
        this.local  = local.strip();
        this.domain = domain.toLowerCase();
    }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Email e)) return false;            // 패턴 매칭
        return local.equals(e.local) && domain.equals(e.domain);
    }
    @Override public int hashCode() { return java.util.Objects.hash(local, domain); }
    @Override public String toString() { return local + "@" + domain; }

    @Override public int compareTo(Email o) {
        int c = domain.compareTo(o.domain);
        return (c != 0) ? c : local.compareTo(o.local);
    }
}
```

> **Hash 기반 컬렉션**(HashSet/HashMap)에서 `equals`와 `hashCode`는 **동시에** 일관되게 재정의해야 함.

---

## 9. 객체 배열과 **복사(얕은/깊은)**

### 9.1 객체 배열
```java
Car[] cars = new Car[] {
    new Car("BMW"), new Car("KIA"), new Car("Audi")
};
```

### 9.2 얕은 복사 vs 깊은 복사
```java
class Holder { Car car; Holder(Car c){ this.car = c; } }

Car c = new Car("A");
Holder h1 = new Holder(c);
Holder h2 = new Holder(c);      // 얕은 복사: 같은 Car 공유

// 깊은 복사(예시): Car에 복제용 생성자/팩토리 제공
class Car {
    private final String brand;
    private int speed;
    public Car(String brand) { this.brand = brand; }
    public Car(Car other) { this.brand = other.brand; this.speed = other.speed; }
}
Holder h3 = new Holder(new Car(c)); // 새로운 Car 인스턴스
```

> 실무에서는 **복사 생성자/정적 팩토리** 또는 **불변화**로 일관성 유지.

---

## 10. 중첩/내부/지역/익명 클래스

| 종류 | 키워드 | 특징/용도 |
|---|---|---|
| **정적 중첩 클래스** | `static class` | 외부 인스턴스와 무관. 논리적 그룹화/Builder 등 |
| **내부 클래스** | (비정적) | 외부 인스턴스에 암묵적 참조. UI/상태 결합 |
| **지역 클래스** | 메서드 내부 | 메서드 스코프에 한정된 타입 정의 |
| **익명 클래스** | `new 인터페이스(){...}` | 1회성 구현(람다로 대체되는 경우 많음) |

### 10.1 정적 중첩 + 빌더 예시
```java
public class Nutrition {
    private final int a, b, c;
    private Nutrition(Builder b) { this.a = b.a; this.b = b.b; this.c = b.c; }

    public static class Builder {
        private final int a, b;
        private int c = 0;
        public Builder(int a, int b){ this.a = a; this.b = b; }
        public Builder c(int val){ this.c = val; return this; }
        public Nutrition build(){ return new Nutrition(this); }
    }
}
```

### 10.2 익명 클래스(리스너 패턴)
```java
interface Listener { void onEvent(String s); }
class Source {
    void fire(Listener l) { l.onEvent("hello"); }
}
new Source().fire(new Listener() {
    @Override public void onEvent(String s) { System.out.println("got " + s); }
});
```

> 단순 함수형 인터페이스면 **람다**가 더 간결: `l -> System.out.println("got " + s)`.

---

## 11. 수명주기와 GC(가비지 컬렉션)

- **도달 불가능(unreachable)** 객체는 **GC 대상**.
- `finalize()`는 더 이상 권장되지 않음. 자원은 **`AutoCloseable` + try-with-resources**로.

```java
try (var br = java.nio.file.Files.newBufferedReader(java.nio.file.Path.of("in.txt"))) {
    // 사용
} // 자동 close
```

> 강한/약한/소프트/팬텀 참조 등은 고급 주제. 일반 애플리케이션은 **명확한 소유권과 범위**로 리소스/객체를 관리.

---

## 12. 실전 패턴 — 팩토리, 불변, 방어적 복사

### 12.1 정적 팩토리 메서드
```java
public final class Point {
    private final int x, y;
    private Point(int x, int y) { this.x = x; this.y = y; }
    public static Point of(int x, int y) { return new Point(x, y); }
}
```

### 12.2 방어적 복사(가변 입력 차단)
```java
public final class Report {
    private final java.util.List<String> lines;
    public Report(java.util.List<String> lines) {
        this.lines = java.util.List.copyOf(lines); // 불변 리스트로
    }
    public java.util.List<String> lines() { return lines; } // 안전 노출
}
```

---

## 13. 흔한 함정과 체크리스트

### 13.1 함정 모음
- `==`로 문자열/값 객체 비교 → **`equals` 사용**.
- 생성자/초기화 중 **오버라이딩 가능한 메서드 호출** → 필드 미초기화 위험.
- `public` 가변 필드 노출 → 캡슐화 붕괴.
- `clone()`/`Cloneable` 남용 → **복사 생성자/팩토리** 권장.
- `this`를 생성자에서 외부로 유출(리스너 등록 등) → **완전 초기화 후** 등록.

### 13.2 체크리스트
- [ ] 필드 기본 `private` / 필요한 공개만 `public/protected`
- [ ] 불변 가능하면 `final` 필드 + 가변 입력 방어적 복사
- [ ] 값 타입은 `equals`/`hashCode`/`toString`/`compareTo` 일관
- [ ] 초기화 순서 숙지(부모→자식, 필드/블록→생성자)
- [ ] 정적 멤버는 상태 공유에 주의(동시성 포함)

---

## 14. 종합 예제 — 작은 도메인 묶음

```java
package com.example.shop;

// 값 타입
public final class Money implements Comparable<Money> {
    private final long won;
    public Money(long won) { if (won < 0) throw new IllegalArgumentException(); this.won = won; }
    public Money add(Money other){ return new Money(this.won + other.won); }
    public long value(){ return won; }
    @Override public boolean equals(Object o){ return (o instanceof Money m) && m.won == won; }
    @Override public int hashCode(){ return Long.hashCode(won); }
    @Override public String toString(){ return won + "원"; }
    @Override public int compareTo(Money o){ return Long.compare(this.won, o.won); }
}

// 엔티티
class Product {
    private final String name;
    private final Money price;
    Product(String name, Money price) {
        this.name = name;
        this.price = price;
    }
    public Money price(){ return price; }
    public String name(){ return name; }
}

// 서비스
class Cart {
    private Money total = new Money(0);
    public void add(Product p){ total = total.add(p.price()); }
    public Money total(){ return total; }
}

// 실행
class Main {
    public static void main(String[] args) {
        Product pen = new Product("Pen", new Money(500));
        Product pad = new Product("Pad", new Money(1500));
        Cart cart = new Cart();
        cart.add(pen); cart.add(pad);
        System.out.println("합계: " + cart.total()); // 합계: 2000원
    }
}
```

---

## 15. 요약 표

| 개념 | 핵심 |
|---|---|
| 클래스/객체 | 설계도/실체. 객체는 Heap, 참조는 Stack에 저장(참조값) |
| 초기화 순서 | 부모 필드/블록 → 부모 생성자 → 자식 필드/블록 → 자식 생성자 |
| `this`/체이닝 | 현재 인스턴스, `this(...)`로 생성자 재사용(첫 줄 규칙) |
| 캡슐화/불변 | `private` 필드, 검증 메서드, `final`/방어적 복사 권장 |
| 정적 멤버 | 클래스 공유 상태/유틸. 동시성/테스트 용이성 고려 |
| 동등성 계약 | 값 타입은 `equals`/`hashCode`/`toString`/`compareTo` 구현 |
| 복사 | 얕은/깊은 복사 구분, 복사 생성자/팩토리 선호 |
| 중첩/익명 | 정적 중첩(의존도 낮음)/내부/지역/익명(1회성) 적재적소 활용 |
| 수명/자원 | GC에 맡기되 외부 자원은 `AutoCloseable` + try-with-resources |

> 결론: **클래스는 불변식과 경계를 정의**하고, **객체는 그 계약 아래에서 안전하게 움직이는 주체**다.
> 캡슐화·초기화 순서·동등성 계약을 정확히 지키면, 유지보수성과 재사용성이 높은 도메인 모델을 구축할 수 있다.
