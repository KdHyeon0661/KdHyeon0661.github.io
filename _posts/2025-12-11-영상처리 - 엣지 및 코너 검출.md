---
layout: post
title: 영상처리 - 엣지 및 코너 검출 (C#)
date: 2025-12-11 14:30:23 +0900
category: 영상처리
---
# 엣지 및 코너 검출: 이론, 알고리즘 및 응용

## 엣지와 코너의 의미와 중요성

### 정의 및 특성 분석

**엣지(Edge)**는 **영상 밝기 변화가 급격한 위치**로, 객체의 경계, 표면 변화, 그림자 경계 등을 나타냅니다. 엣지는 1차원적인 특성을 가지며, 방향성과 강도를 가집니다.

**코너(Corner)**는 **서로 다른 방향의 엣지가 교차하거나 만나는 지점**으로, 객체의 모서리, 교차점, 특징적인 점을 나타냅니다. 코너는 2차원적인 특성을 가지며, 위치 정보가 풍부합니다.

### 엣지와 코너의 수학적 모델

#### 엣지의 수학적 표현

연속 영상 $$f(x,y)$$에서 엣지는 다음과 같이 표현됩니다:

1. **1차 미분(그래디언트)**이 최대인 지점
2. **2차 미분(라플라시안)**이 0을 지나는 지점

#### 코너의 수학적 표현

코너는 두 방향으로의 그래디언트가 모두 큰 지점으로 정의됩니다:

$$
\left\|\frac{\partial f}{\partial x}\right\| > T \quad \text{and} \quad \left\|\frac{\partial f}{\partial y}\right\| > T
$$

### 엣지와 코너의 시각적 표현

```
엣지 유형 다이어그램:
┌─────────────────────────────────────┐
│              Step Edge              │
│  ░░░░░░░░░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │
│  ░░░░░░░░░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │
│  ░░░░░░░░░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │
│  ░░░░░░░░░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│              Ramp Edge              │
│  ░░░░░░░░░░▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓████████ │
│  ░░░░░░░░░░▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓████████ │
│  ░░░░░░░░░░▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓████████ │
│  ░░░░░░░░░░▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓████████ │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│             Roof Edge               │
│  ░░░░░░▒▒▒▒▓▓▓▓██████▓▓▓▓▒▒▒▒░░░░░░ │
│  ░░░░░░▒▒▒▒▓▓▓▓██████▓▓▓▓▒▒▒▒░░░░░░ │
│  ░░░░░░▒▒▒▒▓▓▓▓██████▓▓▓▓▒▒▒▒░░░░░░ │
│  ░░░░░░▒▒▒▒▓▓▓▓██████▓▓▓▓▒▒▒▒░░░░░░ │
└─────────────────────────────────────┘
```

### 엣지 및 코너 검출의 응용 분야

| 응용 분야 | 엣지 활용 | 코너 활용 |
|-----------|-----------|-----------|
| **객체 인식** | 객체 윤곽 추출 | 특징점 정합 |
| **3D 재구성** | 깊이 불연속 검출 | 특징점 추적 |
| **의료 영상** | 장기 경계 검출 | 랜드마크 식별 |
| **자율 주행** | 차선 인식 | 교차로 검출 |
| **로봇 비전** | 작업 공간 인식 | 그리핑 포인트 결정 |

---

## 그래디언트 기반 엣지 검출

### 그래디언트의 수학적 정의

영상 $$f(x,y)$$의 그래디언트는 다음과 같이 정의됩니다:

$$
\nabla f =
\begin{bmatrix}
\frac{\partial f}{\partial x} \\
\frac{\partial f}{\partial y}
\end{bmatrix}
=
\begin{bmatrix}
G_x \\
G_y
\end{bmatrix}
$$

#### 그래디언트 크기(Magnitude)

$$
|\nabla f| = \sqrt{G_x^2 + G_y^2}
$$

#### 그래디언트 방향(Orientation)

$$
\theta = \tan^{-1}\left(\frac{G_y}{G_x}\right)
$$

### 이산 미분 연산자

#### 1. 로버츠 연산자(Roberts Operator)

**특징**: 2×2 마스크, 대각선 방향 미분 강조

$$
G_x =
\begin{bmatrix}
1 & 0 \\
0 & -1
\end{bmatrix},
\quad
G_y =
\begin{bmatrix}
0 & 1 \\
-1 & 0
\end{bmatrix}
$$

```csharp
public class RobertsOperator
{
    public static (double[,] magnitude, double[,] direction) Apply(MyImage src)
    {
        int width = src.Width;
        int height = src.Height;
        
        double[,] magnitude = new double[width, height];
        double[,] direction = new double[width, height];
        
        // 로버츠 마스크
        double[,] rx = { { 1, 0 }, { 0, -1 } };
        double[,] ry = { { 0, 1 }, { -1, 0 } };
        
        for (int y = 0; y < height - 1; y++)
        {
            for (int x = 0; x < width - 1; x++)
            {
                // 2×2 영역에서의 미분 계산
                double gx = 
                    src.GetPixel(x, y) * rx[0, 0] +
                    src.GetPixel(x + 1, y) * rx[0, 1] +
                    src.GetPixel(x, y + 1) * rx[1, 0] +
                    src.GetPixel(x + 1, y + 1) * rx[1, 1];
                
                double gy = 
                    src.GetPixel(x, y) * ry[0, 0] +
                    src.GetPixel(x + 1, y) * ry[0, 1] +
                    src.GetPixel(x, y + 1) * ry[1, 0] +
                    src.GetPixel(x + 1, y + 1) * ry[1, 1];
                
                magnitude[x, y] = Math.Sqrt(gx * gx + gy * gy);
                direction[x, y] = Math.Atan2(gy, gx);
            }
        }
        
        return (magnitude, direction);
    }
}
```

#### 2. 프리윗 연산자(Prewitt Operator)

**특징**: 3×3 마스크, 수평/수직 미분 평활화 포함

$$
G_x =
\begin{bmatrix}
-1 & 0 & 1 \\
-1 & 0 & 1 \\
-1 & 0 & 1
\end{bmatrix},
\quad
G_y =
\begin{bmatrix}
-1 & -1 & -1 \\
0 & 0 & 0 \\
1 & 1 & 1
\end{bmatrix}
$$

```csharp
public class PrewittOperator
{
    public static (double[,] magnitude, double[,] direction) Apply(MyImage src)
    {
        int width = src.Width;
        int height = src.Height;
        
        double[,] magnitude = new double[width, height];
        double[,] direction = new double[width, height];
        
        // 프리윗 마스크
        double[,] px = 
        {
            { -1, 0, 1 },
            { -1, 0, 1 },
            { -1, 0, 1 }
        };
        
        double[,] py = 
        {
            { -1, -1, -1 },
            { 0, 0, 0 },
            { 1, 1, 1 }
        };
        
        // 컨볼루션 수행 (경계 제외)
        for (int y = 1; y < height - 1; y++)
        {
            for (int x = 1; x < width - 1; x++)
            {
                double gx = 0, gy = 0;
                
                // 3×3 윈도우 컨볼루션
                for (int j = -1; j <= 1; j++)
                {
                    for (int i = -1; i <= 1; i++)
                    {
                        byte pixel = src.GetPixel(x + i, y + j);
                        gx += pixel * px[j + 1, i + 1];
                        gy += pixel * py[j + 1, i + 1];
                    }
                }
                
                magnitude[x, y] = Math.Sqrt(gx * gx + gy * gy);
                direction[x, y] = Math.Atan2(gy, gx);
            }
        }
        
        return (magnitude, direction);
    }
}
```

#### 3. 소벨 연산자(Sobel Operator)

**특징**: 3×3 마스크, 중심 픽셀에 가중치 부여, 노이즈에 강건

$$
G_x =
\begin{bmatrix}
-1 & 0 & 1 \\
-2 & 0 & 2 \\
-1 & 0 & 1
\end{bmatrix},
\quad
G_y =
\begin{bmatrix}
-1 & -2 & -1 \\
0 & 0 & 0 \\
1 & 2 & 1
\end{bmatrix}
$$

**수학적 근거**: 중심 차분 근사 + 가우시안 평활화

```csharp
public class SobelOperator
{
    public static (double[,] magnitude, double[,] direction) Apply(MyImage src)
    {
        int width = src.Width;
        int height = src.Height;
        
        double[,] magnitude = new double[width, height];
        double[,] direction = new double[width, height];
        
        // 소벨 마스크
        double[,] sx = 
        {
            { -1, 0, 1 },
            { -2, 0, 2 },
            { -1, 0, 1 }
        };
        
        double[,] sy = 
        {
            { -1, -2, -1 },
            { 0, 0, 0 },
            { 1, 2, 1 }
        };
        
        // 분리 가능한 형태로 최적화
        // Gx = [1; 2; 1] * [-1, 0, 1]
        // Gy = [-1; 0; 1] * [1, 2, 1]
        
        // 중간 결과 저장 배열
        double[,] tempX = new double[width, height];
        double[,] tempY = new double[width, height];
        
        // 수평 방향 미분 (분리 가능한 부분)
        for (int y = 0; y < height; y++)
        {
            for (int x = 1; x < width - 1; x++)
            {
                // 수평 미분: [-1, 0, 1]
                tempX[x, y] = 
                    -src.GetPixel(x - 1, y) + 
                    src.GetPixel(x + 1, y);
            }
        }
        
        // 수직 방향 미분 (분리 가능한 부분)
        for (int y = 1; y < height - 1; y++)
        {
            for (int x = 0; x < width; x++)
            {
                // 수직 미분: [-1, 0, 1]^T
                tempY[x, y] = 
                    -src.GetPixel(x, y - 1) + 
                    src.GetPixel(x, y + 1);
            }
        }
        
        // 최종 소벨 결과 계산
        for (int y = 1; y < height - 1; y++)
        {
            for (int x = 1; x < width - 1; x++)
            {
                // 수평 가중 평균: [1; 2; 1]
                double gx = 
                    tempX[x, y - 1] * 1 +
                    tempX[x, y] * 2 +
                    tempX[x, y + 1] * 1;
                
                // 수직 가중 평균: [1; 2; 1]^T
                double gy = 
                    tempY[x - 1, y] * 1 +
                    tempY[x, y] * 2 +
                    tempY[x + 1, y] * 1;
                
                magnitude[x, y] = Math.Sqrt(gx * gx + gy * gy);
                direction[x, y] = Math.Atan2(gy, gx);
                
                // 방향을 0~π 범위로 정규화
                if (direction[x, y] < 0)
                    direction[x, y] += Math.PI;
            }
        }
        
        return (magnitude, direction);
    }
    
    // 최적화된 버전 (SIMD 및 병렬 처리)
    public static (double[,] magnitude, double[,] direction) ApplyOptimized(MyImage src)
    {
        int width = src.Width;
        int height = src.Height;
        
        double[,] magnitude = new double[width, height];
        double[,] direction = new double[width, height];
        
        // 분리 가능한 소벨 필터 계수
        double[] verticalKernel = { 1, 2, 1 };
        double[] horizontalKernel = { 1, 2, 1 };
        double[] derivativeKernel = { -1, 0, 1 };
        
        // 병렬 처리
        Parallel.For(1, height - 1, y =>
        {
            for (int x = 1; x < width - 1; x++)
            {
                // 분리 가능한 필터링 적용
                double gx = 0, gy = 0;
                
                // Gx 계산: verticalKernel * derivativeKernel
                for (int ky = -1; ky <= 1; ky++)
                {
                    double verticalWeight = verticalKernel[ky + 1];
                    for (int kx = -1; kx <= 1; kx++)
                    {
                        double weight = verticalWeight * derivativeKernel[kx + 1];
                        gx += src.GetPixel(x + kx, y + ky) * weight;
                    }
                }
                
                // Gy 계산: derivativeKernel^T * horizontalKernel^T
                for (int kx = -1; kx <= 1; kx++)
                {
                    double horizontalWeight = horizontalKernel[kx + 1];
                    for (int ky = -1; ky <= 1; ky++)
                    {
                        double weight = horizontalWeight * derivativeKernel[ky + 1];
                        gy += src.GetPixel(x + kx, y + ky) * weight;
                    }
                }
                
                magnitude[x, y] = Math.Sqrt(gx * gx + gy * gy);
                direction[x, y] = Math.Atan2(gy, gx);
            }
        });
        
        return (magnitude, direction);
    }
}
```

#### 4. 샤르 연산자(Scharr Operator)

**특징**: 소벨의 개선형, 회전 대칭성 향상, 에지 방향 정확도 개선

$$
G_x =
\begin{bmatrix}
-3 & 0 & 3 \\
-10 & 0 & 10 \\
-3 & 0 & 3
\end{bmatrix},
\quad
G_y =
\begin{bmatrix}
-3 & -10 & -3 \\
0 & 0 & 0 \\
3 & 10 & 3
\end{bmatrix}
$$

### 그래디언트 연산자 비교 표

| 연산자 | 마스크 크기 | 계산 비용 | 노이즈 저항 | 방향 정확도 | 적합한 응용 |
|--------|-------------|-----------|-------------|-------------|-------------|
| **로버츠** | 2×2 | 매우 낮음 | 매우 낮음 | 낮음 | 빠른 실시간 처리 |
| **프리윗** | 3×3 | 낮음 | 낮음 | 중간 | 일반적인 엣지 검출 |
| **소벨** | 3×3 | 중간 | 중간 | 높음 | 대부분의 응용 |
| **샤르** | 3×3 | 중간 | 중간 | 매우 높음 | 정밀한 방향 분석 |
| **4방향 소벨** | 3×3 | 높음 | 높음 | 최고 | 전문 영상 분석 |

### 그래디언트 기반 엣지 검출의 최적화

```csharp
public class GradientEdgeDetector
{
    // 통합 그래디언트 계산 엔진
    public enum GradientOperator
    {
        Roberts,
        Prewitt,
        Sobel,
        Scharr,
        Custom
    }
    
    public class EdgeDetectionResult
    {
        public double[,] Magnitude { get; set; }
        public double[,] Direction { get; set; }
        public MyImage BinaryEdges { get; set; }
        public TimeSpan ComputationTime { get; set; }
    }
    
    public static EdgeDetectionResult DetectEdges(
        MyImage src,
        GradientOperator op = GradientOperator.Sobel,
        double threshold = 30.0,
        bool useNonMaxSuppression = false)
    {
        var watch = System.Diagnostics.Stopwatch.StartNew();
        
        double[,] magnitude, direction;
        
        // 연산자 선택
        switch (op)
        {
            case GradientOperator.Roberts:
                (magnitude, direction) = RobertsOperator.Apply(src);
                break;
            case GradientOperator.Prewitt:
                (magnitude, direction) = PrewittOperator.Apply(src);
                break;
            case GradientOperator.Sobel:
                (magnitude, direction) = SobelOperator.ApplyOptimized(src);
                break;
            case GradientOperator.Scharr:
                (magnitude, direction) = ScharrOperator.Apply(src);
                break;
            default:
                (magnitude, direction) = SobelOperator.ApplyOptimized(src);
                break;
        }
        
        // 비최대 억제 적용 (옵션)
        if (useNonMaxSuppression)
        {
            magnitude = NonMaximumSuppression.Apply(magnitude, direction);
        }
        
        // 임계값 적용
        MyImage binaryEdges = ApplyThreshold(magnitude, threshold);
        
        watch.Stop();
        
        return new EdgeDetectionResult
        {
            Magnitude = magnitude,
            Direction = direction,
            BinaryEdges = binaryEdges,
            ComputationTime = watch.Elapsed
        };
    }
    
    private static MyImage ApplyThreshold(double[,] magnitude, double threshold)
    {
        int width = magnitude.GetLength(0);
        int height = magnitude.GetLength(1);
        MyImage result = new MyImage(width, height);
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                result.SetPixel(x, y, 
                    magnitude[x, y] > threshold ? (byte)255 : (byte)0);
            }
        }
        
        return result;
    }
}
```

---

## 캐니 엣지 검출기(Canny Edge Detector)

### 캐니 알고리즘의 4단계

```
┌─────────────────────────────────────┐
│         Canny Edge Detection        │
├─────────────────────────────────────┤
│ 1. 가우시안 스무딩 (잡음 제거)       │
│ 2. 그래디언트 계산 (소벨 사용)       │
│ 3. 비최대 억제 (얇은 엣지 생성)      │
│ 4. 이력 임계값 (강/약 엣지 연결)     │
└─────────────────────────────────────┘
```

### 상세 구현

```csharp
public class CannyEdgeDetector
{
    public class CannyParameters
    {
        public double Sigma { get; set; } = 1.4;      // 가우시안 표준편차
        public double LowThreshold { get; set; } = 20; // 낮은 임계값
        public double HighThreshold { get; set; } = 50; // 높은 임계값
        public int GaussianSize { get; set; } = 5;     // 가우시안 커널 크기
    }
    
    public static MyImage DetectEdges(MyImage src, CannyParameters parameters = null)
    {
        parameters ??= new CannyParameters();
        
        // 1. 가우시안 스무딩
        MyImage smoothed = GaussianSmoothing(src, parameters);
        
        // 2. 그래디언트 계산 (소벨 사용)
        var (magnitude, direction) = SobelOperator.ApplyOptimized(smoothed);
        
        // 3. 비최대 억제
        double[,] suppressed = NonMaximumSuppression.Apply(magnitude, direction);
        
        // 4. 이력 임계값 처리
        MyImage edges = HysteresisThresholding.Apply(
            suppressed, parameters.LowThreshold, parameters.HighThreshold);
        
        return edges;
    }
    
    private static MyImage GaussianSmoothing(MyImage src, CannyParameters parameters)
    {
        // 가우시안 커널 생성
        double[,] kernel = CreateGaussianKernel(parameters.GaussianSize, parameters.Sigma);
        
        // 컨볼루션 적용
        return ConvolutionProcessor.Convolve2D(src, kernel);
    }
    
    private static double[,] CreateGaussianKernel(int size, double sigma)
    {
        double[,] kernel = new double[size, size];
        int center = size / 2;
        double sum = 0.0;
        
        for (int y = -center; y <= center; y++)
        {
            for (int x = -center; x <= center; x++)
            {
                double value = Math.Exp(-(x * x + y * y) / (2 * sigma * sigma));
                kernel[y + center, x + center] = value;
                sum += value;
            }
        }
        
        // 정규화
        for (int i = 0; i < size; i++)
        {
            for (int j = 0; j < size; j++)
            {
                kernel[i, j] /= sum;
            }
        }
        
        return kernel;
    }
}
```

### 1. 비최대 억제(Non-Maximum Suppression)

```csharp
public class NonMaximumSuppression
{
    public static double[,] Apply(double[,] magnitude, double[,] direction)
    {
        int width = magnitude.GetLength(0);
        int height = magnitude.GetLength(1);
        
        double[,] result = new double[width, height];
        
        // 모든 픽셀에 대해 (경계 제외)
        for (int y = 1; y < height - 1; y++)
        {
            for (int x = 1; x < width - 1; x++)
            {
                double mag = magnitude[x, y];
                double angle = direction[x, y];
                
                // 방향을 0~180도 범위로 정규화
                double degrees = angle * 180 / Math.PI;
                if (degrees < 0) degrees += 180;
                
                // 이웃 픽셀 결정
                double mag1, mag2;
                
                // 0°: 수평
                if ((degrees >= 0 && degrees < 22.5) || (degrees >= 157.5 && degrees <= 180))
                {
                    mag1 = magnitude[x - 1, y];
                    mag2 = magnitude[x + 1, y];
                }
                // 45°: 대각선 (왼쪽 위 → 오른쪽 아래)
                else if (degrees >= 22.5 && degrees < 67.5)
                {
                    mag1 = magnitude[x - 1, y - 1];
                    mag2 = magnitude[x + 1, y + 1];
                }
                // 90°: 수직
                else if (degrees >= 67.5 && degrees < 112.5)
                {
                    mag1 = magnitude[x, y - 1];
                    mag2 = magnitude[x, y + 1];
                }
                // 135°: 대각선 (오른쪽 위 → 왼쪽 아래)
                else // degrees >= 112.5 && degrees < 157.5
                {
                    mag1 = magnitude[x + 1, y - 1];
                    mag2 = magnitude[x - 1, y + 1];
                }
                
                // 국소 최대값인 경우만 유지
                result[x, y] = (mag >= mag1 && mag >= mag2) ? mag : 0;
            }
        }
        
        return result;
    }
    
    // 보간법을 사용한 정확한 비최대 억제
    public static double[,] ApplyWithInterpolation(double[,] magnitude, double[,] direction)
    {
        int width = magnitude.GetLength(0);
        int height = magnitude.GetLength(1);
        
        double[,] result = new double[width, height];
        
        for (int y = 1; y < height - 1; y++)
        {
            for (int x = 1; x < width - 1; x++)
            {
                double mag = magnitude[x, y];
                double angle = direction[x, y];
                
                // 그래디언트 방향의 단위 벡터
                double dx = Math.Cos(angle);
                double dy = Math.Sin(angle);
                
                // 그래디언트 방향으로 1픽셀 떨어진 위치 계산
                double x1 = x + dx;
                double y1 = y + dy;
                double x2 = x - dx;
                double y2 = y - dy;
                
                // 양선형 보간으로 이웃 값 계산
                double mag1 = BilinearInterpolate(magnitude, x1, y1);
                double mag2 = BilinearInterpolate(magnitude, x2, y2);
                
                // 국소 최대값 검사
                result[x, y] = (mag >= mag1 && mag >= mag2) ? mag : 0;
            }
        }
        
        return result;
    }
    
    private static double BilinearInterpolate(double[,] data, double x, double y)
    {
        int x0 = (int)Math.Floor(x);
        int y0 = (int)Math.Floor(y);
        int x1 = x0 + 1;
        int y1 = y0 + 1;
        
        // 경계 확인
        if (x0 < 0 || x1 >= data.GetLength(0) || y0 < 0 || y1 >= data.GetLength(1))
            return 0;
        
        double dx = x - x0;
        double dy = y - y0;
        
        double f00 = data[x0, y0];
        double f10 = data[x1, y0];
        double f01 = data[x0, y1];
        double f11 = data[x1, y1];
        
        // 양선형 보간
        return (1 - dx) * (1 - dy) * f00 +
               dx * (1 - dy) * f10 +
               (1 - dx) * dy * f01 +
               dx * dy * f11;
    }
}
```

### 2. 이력 임계값 처리(Hysteresis Thresholding)

```csharp
public class HysteresisThresholding
{
    public static MyImage Apply(double[,] magnitude, double lowThreshold, double highThreshold)
    {
        int width = magnitude.GetLength(0);
        int height = magnitude.GetLength(1);
        
        MyImage result = new MyImage(width, height);
        bool[,] visited = new bool[width, height];
        
        // 강한 엣지 찾기 및 시작점 설정
        var strongEdges = new List<Point>();
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (magnitude[x, y] >= highThreshold)
                {
                    strongEdges.Add(new Point(x, y));
                }
            }
        }
        
        // 강한 엣지에서 시작하여 약한 엣지 연결 (BFS)
        foreach (var startPoint in strongEdges)
        {
            if (!visited[startPoint.X, startPoint.Y])
            {
                BFS(startPoint, magnitude, result, visited, lowThreshold);
            }
        }
        
        return result;
    }
    
    private static void BFS(
        Point start,
        double[,] magnitude,
        MyImage result,
        bool[,] visited,
        double lowThreshold)
    {
        int width = magnitude.GetLength(0);
        int height = magnitude.GetLength(1);
        
        Queue<Point> queue = new Queue<Point>();
        queue.Enqueue(start);
        visited[start.X, start.Y] = true;
        
        // 8방향 이웃
        Point[] directions = new Point[]
        {
            new Point(-1, -1), new Point(0, -1), new Point(1, -1),
            new Point(-1, 0),                     new Point(1, 0),
            new Point(-1, 1),  new Point(0, 1),  new Point(1, 1)
        };
        
        while (queue.Count > 0)
        {
            Point current = queue.Dequeue();
            result.SetPixel(current.X, current.Y, 255); // 강한 엣지로 표시
            
            // 8방향 이웃 검사
            foreach (var dir in directions)
            {
                int nx = current.X + dir.X;
                int ny = current.Y + dir.Y;
                
                // 경계 확인 및 방문 여부 확인
                if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[nx, ny])
                {
                    // 약한 엣지이고 임계값 이상인 경우
                    if (magnitude[nx, ny] >= lowThreshold)
                    {
                        visited[nx, ny] = true;
                        queue.Enqueue(new Point(nx, ny));
                    }
                }
            }
        }
    }
    
    // 최적화된 버전 (병렬 BFS)
    public static MyImage ApplyOptimized(double[,] magnitude, double lowThreshold, double highThreshold)
    {
        int width = magnitude.GetLength(0);
        int height = magnitude.GetLength(1);
        
        byte[,] edgeMap = new byte[width, height];
        bool[,] visited = new bool[width, height];
        
        // 첫 번째 패스: 강한 엣지 표시
        Parallel.For(0, height, y =>
        {
            for (int x = 0; x < width; x++)
            {
                if (magnitude[x, y] >= highThreshold)
                {
                    edgeMap[x, y] = 255; // 강한 엣지
                }
                else if (magnitude[x, y] >= lowThreshold)
                {
                    edgeMap[x, y] = 128; // 약한 엣지 (임시)
                }
            }
        });
        
        // 두 번째 패스: 약한 엣지 연결성 검사
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (edgeMap[x, y] == 128 && !visited[x, y])
                {
                    // 약한 엣지가 강한 엣지와 연결되어 있는지 검사
                    if (IsConnectedToStrongEdge(x, y, edgeMap, visited))
                    {
                        // 연결되어 있으면 강한 엣지로 승격
                        PropagateWeakEdges(x, y, edgeMap, visited);
                    }
                }
            }
        }
        
        // 결과 생성
        MyImage result = new MyImage(width, height);
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                result.SetPixel(x, y, edgeMap[x, y] == 255 ? (byte)255 : (byte)0);
            }
        }
        
        return result;
    }
    
    private static bool IsConnectedToStrongEdge(int x, int y, byte[,] edgeMap, bool[,] visited)
    {
        // 8방향 이웃에 강한 엣지가 있는지 검사
        for (int dy = -1; dy <= 1; dy++)
        {
            for (int dx = -1; dx <= 1; dx++)
            {
                int nx = x + dx;
                int ny = y + dy;
                
                if (nx >= 0 && nx < edgeMap.GetLength(0) && 
                    ny >= 0 && ny < edgeMap.GetLength(1))
                {
                    if (edgeMap[nx, ny] == 255)
                    {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    private static void PropagateWeakEdges(int startX, int startY, byte[,] edgeMap, bool[,] visited)
    {
        Queue<Point> queue = new Queue<Point>();
        queue.Enqueue(new Point(startX, startY));
        visited[startX, startY] = true;
        
        Point[] directions = new Point[8]
        {
            new Point(-1, -1), new Point(0, -1), new Point(1, -1),
            new Point(-1, 0),                     new Point(1, 0),
            new Point(-1, 1),  new Point(0, 1),  new Point(1, 1)
        };
        
        while (queue.Count > 0)
        {
            Point current = queue.Dequeue();
            edgeMap[current.X, current.Y] = 255; // 강한 엣지로 승격
            
            // 연결된 약한 엣지 검색
            foreach (var dir in directions)
            {
                int nx = current.X + dir.X;
                int ny = current.Y + dir.Y;
                
                if (nx >= 0 && nx < edgeMap.GetLength(0) && 
                    ny >= 0 && ny < edgeMap.GetLength(1) && 
                    !visited[nx, ny] && edgeMap[nx, ny] == 128)
                {
                    visited[nx, ny] = true;
                    queue.Enqueue(new Point(nx, ny));
                }
            }
        }
    }
}
```

### 캐니 알고리즘의 매개변수 최적화

```csharp
public class CannyParameterOptimizer
{
    public static CannyEdgeDetector.CannyParameters OptimizeParameters(
        MyImage src, 
        double targetEdgeDensity = 0.05) // 원하는 엣지 밀도 (5%)
    {
        // 자동 임계값 결정 (Otsu 방법 응용)
        var histogram = ComputeGradientHistogram(src);
        
        // 높은 임계값 결정 (상위 20% 그래디언트)
        double highThreshold = FindPercentile(histogram, 0.8);
        
        // 낮은 임계값 결정 (높은 임계값의 40%)
        double lowThreshold = highThreshold * 0.4;
        
        // 가우시안 시그마 결정 (자동)
        double estimatedNoise = EstimateNoiseLevel(src);
        double sigma = Math.Max(0.5, Math.Min(2.0, estimatedNoise * 2));
        
        return new CannyEdgeDetector.CannyParameters
        {
            Sigma = sigma,
            LowThreshold = lowThreshold,
            HighThreshold = highThreshold,
            GaussianSize = CalculateKernelSize(sigma)
        };
    }
    
    private static int[] ComputeGradientHistogram(MyImage src)
    {
        var (magnitude, _) = SobelOperator.ApplyOptimized(src);
        int[] histogram = new int[256];
        
        int width = magnitude.GetLength(0);
        int height = magnitude.GetLength(1);
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                int bin = (int)Math.Min(magnitude[x, y], 255);
                histogram[bin]++;
            }
        }
        
        return histogram;
    }
    
    private static double FindPercentile(int[] histogram, double percentile)
    {
        int total = histogram.Sum();
        int targetCount = (int)(total * percentile);
        int accumulated = 0;
        
        for (int i = 255; i >= 0; i--)
        {
            accumulated += histogram[i];
            if (accumulated >= targetCount)
            {
                return i;
            }
        }
        
        return 0;
    }
}
```

---

## 2차 미분 기반 엣지 검출

### 라플라시안(Laplacian) 연산자

$$
\nabla^2 f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2}
$$

#### 이산 근사 마스크

**4-방향 라플라시안**:
$$
\begin{bmatrix}
0 & 1 & 0 \\
1 & -4 & 1 \\
0 & 1 & 0
\end{bmatrix}
$$

**8-방향 라플라시안**:
$$
\begin{bmatrix}
1 & 1 & 1 \\
1 & -8 & 1 \\
1 & 1 & 1
\end{bmatrix}
$$

```csharp
public class LaplacianEdgeDetector
{
    public static double[,] Apply(MyImage src, LaplacianType type = LaplacianType.FourConnected)
    {
        int width = src.Width;
        int height = src.Height;
        double[,] result = new double[width, height];
        
        double[,] kernel = GetLaplacianKernel(type);
        int k = kernel.GetLength(0) / 2;
        
        for (int y = k; y < height - k; y++)
        {
            for (int x = k; x < width - k; x++)
            {
                double sum = 0;
                
                for (int j = -k; j <= k; j++)
                {
                    for (int i = -k; i <= k; i++)
                    {
                        sum += src.GetPixel(x + i, y + j) * kernel[j + k, i + k];
                    }
                }
                
                result[x, y] = Math.Abs(sum); // 절대값으로 엣지 강도
            }
        }
        
        return result;
    }
    
    public enum LaplacianType
    {
        FourConnected,
        EightConnected,
        DiagonalEmphasis
    }
    
    private static double[,] GetLaplacianKernel(LaplacianType type)
    {
        return type switch
        {
            LaplacianType.FourConnected => new double[,]
            {
                { 0, 1, 0 },
                { 1, -4, 1 },
                { 0, 1, 0 }
            },
            
            LaplacianType.EightConnected => new double[,]
            {
                { 1, 1, 1 },
                { 1, -8, 1 },
                { 1, 1, 1 }
            },
            
            LaplacianType.DiagonalEmphasis => new double[,]
            {
                { 0.5, 1, 0.5 },
                { 1, -6, 1 },
                { 0.5, 1, 0.5 }
            },
            
            _ => throw new ArgumentException("Unknown Laplacian type")
        };
    }
}
```

### LoG(Laplacian of Gaussian) 엣지 검출

```csharp
public class LoGEdgeDetector
{
    // LoG: 가우시안 블러 후 라플라시안 적용
    public static double[,] Apply(MyImage src, double sigma = 1.0)
    {
        // 1. 가우시안 스무딩
        MyImage smoothed = GaussianFilter.Apply(src, sigma);
        
        // 2. 라플라시안 적용
        return LaplacianEdgeDetector.Apply(smoothed, LaplacianType.EightConnected);
    }
    
    // 효율적인 LoG: 사전 계산된 LoG 커널 사용
    public static double[,] ApplyEfficient(MyImage src, double sigma = 1.0)
    {
        int kernelSize = (int)(6 * sigma) + 1;
        if (kernelSize % 2 == 0) kernelSize++;
        
        double[,] logKernel = CreateLoGKernel(kernelSize, sigma);
        
        // 컨볼루션 적용
        int width = src.Width;
        int height = src.Height;
        double[,] result = new double[width, height];
        int k = kernelSize / 2;
        
        for (int y = k; y < height - k; y++)
        {
            for (int x = k; x < width - k; x++)
            {
                double sum = 0;
                
                for (int j = -k; j <= k; j++)
                {
                    for (int i = -k; i <= k; i++)
                    {
                        sum += src.GetPixel(x + i, y + j) * logKernel[j + k, i + k];
                    }
                }
                
                result[x, y] = Math.Abs(sum);
            }
        }
        
        return result;
    }
    
    private static double[,] CreateLoGKernel(int size, double sigma)
    {
        double[,] kernel = new double[size, size];
        int center = size / 2;
        double sigma2 = sigma * sigma;
        double sigma4 = sigma2 * sigma2;
        
        for (int y = -center; y <= center; y++)
        {
            for (int x = -center; x <= center; x++)
            {
                double r2 = x * x + y * y;
                double value = -(1.0 / (Math.PI * sigma4)) * 
                              (1 - r2 / (2 * sigma2)) * 
                              Math.Exp(-r2 / (2 * sigma2));
                kernel[y + center, x + center] = value;
            }
        }
        
        return kernel;
    }
    
    // 영교차(Zero-Crossing) 검출
    public static MyImage DetectZeroCrossing(double[,] logResponse, double threshold = 0.01)
    {
        int width = logResponse.GetLength(0);
        int height = logResponse.GetLength(1);
        MyImage edges = new MyImage(width, height);
        
        for (int y = 1; y < height - 1; y++)
        {
            for (int x = 1; x < width - 1; x++)
            {
                // 8-방향 이웃에서 부호 변화 검사
                bool hasZeroCrossing = false;
                double center = logResponse[x, y];
                
                // 8방향 검사
                for (int dy = -1; dy <= 1; dy++)
                {
                    for (int dx = -1; dx <= 1; dx++)
                    {
                        if (dx == 0 && dy == 0) continue;
                        
                        double neighbor = logResponse[x + dx, y + dy];
                        
                        // 부호가 다르고 차이가 임계값 이상인 경우
                        if (center * neighbor < 0 && Math.Abs(center - neighbor) > threshold)
                        {
                            hasZeroCrossing = true;
                            break;
                        }
                    }
                    if (hasZeroCrossing) break;
                }
                
                edges.SetPixel(x, y, hasZeroCrossing ? (byte)255 : (byte)0);
            }
        }
        
        return edges;
    }
}
```

### DoG(Difference of Gaussians) 엣지 검출

```csharp
public class DoGEdgeDetector
{
    // DoG: 두 개의 다른 시그마를 가진 가우시안 차이
    public static double[,] Apply(MyImage src, double sigma1 = 1.0, double sigma2 = 2.0)
    {
        // 두 개의 가우시안 필터링
        MyImage g1 = GaussianFilter.Apply(src, sigma1);
        MyImage g2 = GaussianFilter.Apply(src, sigma2);
        
        // 차이 계산
        int width = src.Width;
        int height = src.Height;
        double[,] result = new double[width, height];
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                double diff = g1.GetPixel(x, y) - g2.GetPixel(x, y);
                result[x, y] = Math.Abs(diff);
            }
        }
        
        return result;
    }
    
    // 멀티스케일 DoG (스케일 공간 생성)
    public static List<double[,]> CreateScaleSpace(MyImage src, int numScales = 5, double baseSigma = 1.0)
    {
        List<double[,]> scaleSpace = new List<double[,]>();
        double k = Math.Pow(2.0, 1.0 / numScales); // 스케일 간격
        
        for (int i = 0; i < numScales; i++)
        {
            double sigma1 = baseSigma * Math.Pow(k, i);
            double sigma2 = sigma1 * 1.6; // 전형적인 비율
            
            var dog = Apply(src, sigma1, sigma2);
            scaleSpace.Add(dog);
        }
        
        return scaleSpace;
    }
}
```

---

## 허프 변환(Hough Transform)

### 기본 허프 변환 (직선 검출)

#### 직선의 극좌표 표현

$$
\rho = x \cos\theta + y \sin\theta
$$

여기서:
- $$\rho$$: 원점에서 직선까지의 거리
- $$\theta$$: 직선의 법선 방향 각도

#### 허프 공간 다이어그램

```
영상 공간 (x,y)                    허프 공간 (ρ,θ)
      │                              │
      │ 각 엣지 픽셀이               │ 각 엣지 픽셀이
      │ 모든 가능한 (ρ,θ)에 투표     │ 축적 배열에 누적
      ▼                              ▼
    [엣지 픽셀] ──────→ [투표] ──────→ [피크 검출] ──────→ [직선 파라미터]
```

#### 구현

```csharp
public class HoughLineDetector
{
    public class DetectedLine
    {
        public double Rho { get; set; }      // 거리
        public double Theta { get; set; }    // 각도 (라디안)
        public int Votes { get; set; }       // 투표 수
        public Point StartPoint { get; set; } // 시작점
        public Point EndPoint { get; set; }   // 끝점
    }
    
    public static List<DetectedLine> DetectLines(
        MyImage edgeImage,
        double thetaStep = Math.PI / 180,    // 1도
        int threshold = 100)                  // 최소 투표 수
    {
        int width = edgeImage.Width;
        int height = edgeImage.Height;
        
        // 최대 ρ 계산 (대각선 길이)
        int maxRho = (int)Math.Ceiling(Math.Sqrt(width * width + height * height));
        int rhoSize = 2 * maxRho + 1;        // 음수 ρ 포함
        
        // θ 범위: 0 ~ π
        int thetaSize = (int)(Math.PI / thetaStep);
        
        // 축적 배열 초기화
        int[,] accumulator = new int[rhoSize, thetaSize];
        
        // 1. 투표 단계
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (edgeImage.GetPixel(x, y) > 0) // 엣지 픽셀
                {
                    // 모든 θ에 대해 ρ 계산 및 투표
                    for (int t = 0; t < thetaSize; t++)
                    {
                        double theta = t * thetaStep;
                        double rho = x * Math.Cos(theta) + y * Math.Sin(theta);
                        
                        // ρ 인덱스 (음수 ρ 처리)
                        int rhoIndex = (int)Math.Round(rho) + maxRho;
                        
                        if (rhoIndex >= 0 && rhoIndex < rhoSize)
                        {
                            accumulator[rhoIndex, t]++;
                        }
                    }
                }
            }
        }
        
        // 2. 피크 검출
        var peaks = FindPeaks(accumulator, threshold);
        
        // 3. 직선 파라미터 계산
        var lines = new List<DetectedLine>();
        
        foreach (var peak in peaks)
        {
            double rho = peak.RhoIndex - maxRho;
            double theta = peak.ThetaIndex * thetaStep;
            
            // 직선의 시작점과 끝점 계산
            var (startPoint, endPoint) = CalculateLineEndpoints(rho, theta, width, height);
            
            lines.Add(new DetectedLine
            {
                Rho = rho,
                Theta = theta,
                Votes = peak.Votes,
                StartPoint = startPoint,
                EndPoint = endPoint
            });
        }
        
        // 투표 수 기준 정렬
        return lines.OrderByDescending(l => l.Votes).ToList();
    }
    
    private static List<Peak> FindPeaks(int[,] accumulator, int threshold)
    {
        List<Peak> peaks = new List<Peak>();
        int rhoSize = accumulator.GetLength(0);
        int thetaSize = accumulator.GetLength(1);
        
        // 지역 최대값 검출 (3×3 윈도우)
        for (int r = 1; r < rhoSize - 1; r++)
        {
            for (int t = 1; t < thetaSize - 1; t++)
            {
                int votes = accumulator[r, t];
                
                if (votes >= threshold)
                {
                    // 3×3 윈도우에서 최대값인지 확인
                    bool isLocalMax = true;
                    for (int dr = -1; dr <= 1 && isLocalMax; dr++)
                    {
                        for (int dt = -1; dt <= 1 && isLocalMax; dt++)
                        {
                            if (dr == 0 && dt == 0) continue;
                            if (accumulator[r + dr, t + dt] > votes)
                            {
                                isLocalMax = false;
                            }
                        }
                    }
                    
                    if (isLocalMax)
                    {
                        peaks.Add(new Peak
                        {
                            RhoIndex = r,
                            ThetaIndex = t,
                            Votes = votes
                        });
                    }
                }
            }
        }
        
        return peaks;
    }
    
    private static (Point start, Point end) CalculateLineEndpoints(
        double rho, double theta, int width, int height)
    {
        // 직선과 영상 경계의 교점 계산
        List<Point> intersections = new List<Point>();
        
        // 4개의 경계선과의 교점 계산
        // 왼쪽 경계: x = 0
        double y1 = (rho - 0 * Math.Cos(theta)) / Math.Sin(theta);
        if (y1 >= 0 && y1 < height)
            intersections.Add(new Point(0, (int)y1));
        
        // 오른쪽 경계: x = width-1
        double y2 = (rho - (width-1) * Math.Cos(theta)) / Math.Sin(theta);
        if (y2 >= 0 && y2 < height)
            intersections.Add(new Point(width-1, (int)y2));
        
        // 위쪽 경계: y = 0
        double x1 = (rho - 0 * Math.Sin(theta)) / Math.Cos(theta);
        if (x1 >= 0 && x1 < width)
            intersections.Add(new Point((int)x1, 0));
        
        // 아래쪽 경계: y = height-1
        double x2 = (rho - (height-1) * Math.Sin(theta)) / Math.Cos(theta);
        if (x2 >= 0 && x2 < width)
            intersections.Add(new Point((int)x2, height-1));
        
        // 두 개의 교점 선택
        if (intersections.Count >= 2)
        {
            return (intersections[0], intersections[1]);
        }
        
        // 교점이 없는 경우 (드문 경우)
        return (new Point(0, 0), new Point(width-1, height-1));
    }
    
    private class Peak
    {
        public int RhoIndex { get; set; }
        public int ThetaIndex { get; set; }
        public int Votes { get; set; }
    }
    
    // 확률적 허프 변환 (Probabilistic Hough Transform)
    public static List<DetectedLine> DetectLinesProbabilistic(
        MyImage edgeImage,
        int minLineLength = 30,
        int maxLineGap = 10,
        double thetaStep = Math.PI / 180,
        int threshold = 100)
    {
        List<DetectedLine> lines = new List<DetectedLine>();
        List<Point> edgePoints = ExtractEdgePoints(edgeImage);
        
        // 랜덤 샘플링을 위한 난수 생성기
        Random rand = new Random();
        
        while (edgePoints.Count > 0)
        {
            // 무작위로 두 점 선택
            int idx1 = rand.Next(edgePoints.Count);
            int idx2 = rand.Next(edgePoints.Count);
            
            if (idx1 == idx2) continue;
            
            Point p1 = edgePoints[idx1];
            Point p2 = edgePoints[idx2];
            
            // 두 점을 지나는 직선 계산
            double theta = Math.Atan2(p2.Y - p1.Y, p2.X - p1.X);
            double rho = p1.X * Math.Cos(theta) + p1.Y * Math.Sin(theta);
            
            // 동일 선상의 점들 찾기
            List<Point> inliers = new List<Point>();
            
            foreach (var point in edgePoints)
            {
                double distance = Math.Abs(
                    point.X * Math.Cos(theta) + point.Y * Math.Sin(theta) - rho);
                
                if (distance < 1.0) // 거리 임계값
                {
                    inliers.Add(point);
                }
            }
            
            // 충분한 점이 있고 선분 길이가 충분한 경우
            if (inliers.Count >= minLineLength)
            {
                // 선분의 시작점과 끝점 찾기
                var sortedInliers = inliers
                    .OrderBy(p => p.X)
                    .ThenBy(p => p.Y)
                    .ToList();
                
                Point start = sortedInliers.First();
                Point end = sortedInliers.Last();
                
                // 선분 길이 계산
                double length = Math.Sqrt(
                    Math.Pow(end.X - start.X, 2) + 
                    Math.Pow(end.Y - start.Y, 2));
                
                if (length >= minLineLength)
                {
                    lines.Add(new DetectedLine
                    {
                        Rho = rho,
                        Theta = theta,
                        Votes = inliers.Count,
                        StartPoint = start,
                        EndPoint = end
                    });
                    
                    // 처리된 점들 제거
                    foreach (var point in inliers)
                    {
                        edgePoints.Remove(point);
                    }
                }
            }
        }
        
        return lines;
    }
    
    private static List<Point> ExtractEdgePoints(MyImage edgeImage)
    {
        List<Point> points = new List<Point>();
        
        for (int y = 0; y < edgeImage.Height; y++)
        {
            for (int x = 0; x < edgeImage.Width; x++)
            {
                if (edgeImage.GetPixel(x, y) > 0)
                {
                    points.Add(new Point(x, y));
                }
            }
        }
        
        return points;
    }
}
```

### 원 검출을 위한 허프 변환

```csharp
public class HoughCircleDetector
{
    public class DetectedCircle
    {
        public Point Center { get; set; }
        public int Radius { get; set; }
        public int Votes { get; set; }
    }
    
    public static List<DetectedCircle> DetectCircles(
        MyImage edgeImage,
        int minRadius = 10,
        int maxRadius = 100,
        int threshold = 30)
    {
        int width = edgeImage.Width;
        int height = edgeImage.Height;
        
        // 3D 축적 배열: [x, y, radius]
        int[,,] accumulator = new int[width, height, maxRadius - minRadius + 1];
        
        // 그래디언트 정보 필요 (방향 정보 활용)
        var (magnitude, direction) = SobelOperator.ApplyOptimized(edgeImage);
        
        // 1. 투표 단계
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (edgeImage.GetPixel(x, y) > 0) // 엣지 픽셀
                {
                    double theta = direction[x, y];
                    
                    // 그래디언트 방향과 수직 방향으로 원 중심 검색
                    for (int r = minRadius; r <= maxRadius; r++)
                    {
                        // 중심 후보 1: 그래디언트 방향
                        int cx1 = (int)(x - r * Math.Cos(theta));
                        int cy1 = (int)(y - r * Math.Sin(theta));
                        
                        if (cx1 >= 0 && cx1 < width && cy1 >= 0 && cy1 < height)
                        {
                            accumulator[cx1, cy1, r - minRadius]++;
                        }
                        
                        // 중심 후보 2: 반대 방향
                        int cx2 = (int)(x + r * Math.Cos(theta));
                        int cy2 = (int)(y + r * Math.Sin(theta));
                        
                        if (cx2 >= 0 && cx2 < width && cy2 >= 0 && cy2 < height)
                        {
                            accumulator[cx2, cy2, r - minRadius]++;
                        }
                    }
                }
            }
        }
        
        // 2. 피크 검출
        return FindCirclePeaks(accumulator, minRadius, threshold);
    }
    
    private static List<DetectedCircle> FindCirclePeaks(
        int[,,] accumulator, int minRadius, int threshold)
    {
        List<DetectedCircle> circles = new List<DetectedCircle>();
        int width = accumulator.GetLength(0);
        int height = accumulator.GetLength(1);
        int radiusCount = accumulator.GetLength(2);
        
        // 지역 최대값 검출
        for (int r = 0; r < radiusCount; r++)
        {
            for (int y = 1; y < height - 1; y++)
            {
                for (int x = 1; x < width - 1; x++)
                {
                    int votes = accumulator[x, y, r];
                    
                    if (votes >= threshold)
                    {
                        // 3×3×3 공간에서 지역 최대값인지 확인
                        bool isLocalMax = true;
                        
                        for (int dr = -1; dr <= 1 && isLocalMax; dr++)
                        {
                            if (r + dr < 0 || r + dr >= radiusCount) continue;
                            
                            for (int dy = -1; dy <= 1 && isLocalMax; dy++)
                            {
                                for (int dx = -1; dx <= 1 && isLocalMax; dx++)
                                {
                                    if (dx == 0 && dy == 0 && dr == 0) continue;
                                    
                                    if (accumulator[x + dx, y + dy, r + dr] > votes)
                                    {
                                        isLocalMax = false;
                                    }
                                }
                            }
                        }
                        
                        if (isLocalMax)
                        {
                            circles.Add(new DetectedCircle
                            {
                                Center = new Point(x, y),
                                Radius = r + minRadius,
                                Votes = votes
                            });
                        }
                    }
                }
            }
        }
        
        // 중복 원 제거 (유사한 중심과 반지름)
        return MergeSimilarCircles(circles);
    }
    
    private static List<DetectedCircle> MergeSimilarCircles(List<DetectedCircle> circles)
    {
        List<DetectedCircle> merged = new List<DetectedCircle>();
        bool[] mergedFlags = new bool[circles.Count];
        
        for (int i = 0; i < circles.Count; i++)
        {
            if (mergedFlags[i]) continue;
            
            DetectedCircle current = circles[i];
            List<DetectedCircle> similar = new List<DetectedCircle> { current };
            
            // 유사한 원 찾기
            for (int j = i + 1; j < circles.Count; j++)
            {
                if (mergedFlags[j]) continue;
                
                DetectedCircle other = circles[j];
                
                // 중심 거리와 반지름 차이 계산
                double centerDistance = Math.Sqrt(
                    Math.Pow(other.Center.X - current.Center.X, 2) +
                    Math.Pow(other.Center.Y - current.Center.Y, 2));
                
                int radiusDiff = Math.Abs(other.Radius - current.Radius);
                
                if (centerDistance < 10 && radiusDiff < 5)
                {
                    similar.Add(other);
                    mergedFlags[j] = true;
                }
            }
            
            // 평균 계산
            if (similar.Count > 0)
            {
                int totalX = 0, totalY = 0, totalR = 0, totalVotes = 0;
                
                foreach (var circle in similar)
                {
                    totalX += circle.Center.X;
                    totalY += circle.Center.Y;
                    totalR += circle.Radius;
                    totalVotes += circle.Votes;
                }
                
                merged.Add(new DetectedCircle
                {
                    Center = new Point(totalX / similar.Count, totalY / similar.Count),
                    Radius = totalR / similar.Count,
                    Votes = totalVotes / similar.Count
                });
            }
            
            mergedFlags[i] = true;
        }
        
        return merged.OrderByDescending(c => c.Votes).ToList();
    }
}
```

---

## 코너 검출 알고리즘

### 1. 해리스 코너 검출(Harris Corner Detection)

#### 구조 텐서(Structure Tensor)

$$
M =
\begin{bmatrix}
\sum I_x^2 & \sum I_x I_y \\
\sum I_x I_y & \sum I_y^2
\end{bmatrix}
=
\begin{bmatrix}
A & C \\
C & B
\end{bmatrix}
$$

#### 코너 응답 함수

$$
R = \det(M) - k \cdot \text{trace}(M)^2
= (AB - C^2) - k(A + B)^2
$$

```csharp
public class HarrisCornerDetector
{
    public class CornerPoint
    {
        public Point Location { get; set; }
        public double Response { get; set; }
        public double Orientation { get; set; }
    }
    
    public static List<CornerPoint> DetectCorners(
        MyImage src,
        double k = 0.04,
        double threshold = 10000,
        int windowSize = 3,
        bool nonMaxSuppression = true,
        int minDistance = 10)
    {
        // 1. 그래디언트 계산
        var (gx, gy) = ComputeGradients(src);
        
        // 2. 구조 텐서 구성 요소 계산
        int width = src.Width;
        int height = src.Height;
        
        double[,] Ix2 = new double[width, height];
        double[,] Iy2 = new double[width, height];
        double[,] IxIy = new double[width, height];
        
        // 제곱 및 곱 계산
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                Ix2[x, y] = gx[x, y] * gx[x, y];
                Iy2[x, y] = gy[x, y] * gy[x, y];
                IxIy[x, y] = gx[x, y] * gy[x, y];
            }
        }
        
        // 3. 가우시안 가중치 적용 (창 함수)
        double[,] gaussian = CreateGaussianWindow(windowSize, 1.0);
        
        // 4. 코너 응답 계산
        double[,] response = ComputeHarrisResponse(
            Ix2, Iy2, IxIy, gaussian, k);
        
        // 5. 코너 점 추출
        List<CornerPoint> corners = ExtractCorners(
            response, threshold, nonMaxSuppression, minDistance);
        
        // 6. 방향 계산 (선택적)
        foreach (var corner in corners)
        {
            corner.Orientation = Math.Atan2(
                gy[corner.Location.X, corner.Location.Y],
                gx[corner.Location.X, corner.Location.Y]);
        }
        
        return corners;
    }
    
    private static (double[,] gx, double[,] gy) ComputeGradients(MyImage src)
    {
        // 소벨 연산자 사용
        var (magnitude, direction) = SobelOperator.ApplyOptimized(src);
        
        // 그래디언트 구성 요소 계산
        int width = src.Width;
        int height = src.Height;
        double[,] gx = new double[width, height];
        double[,] gy = new double[width, height];
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                double mag = magnitude[x, y];
                double dir = direction[x, y];
                
                gx[x, y] = mag * Math.Cos(dir);
                gy[x, y] = mag * Math.Sin(dir);
            }
        }
        
        return (gx, gy);
    }
    
    private static double[,] CreateGaussianWindow(int size, double sigma)
    {
        double[,] window = new double[size, size];
        int center = size / 2;
        double sum = 0.0;
        
        for (int y = -center; y <= center; y++)
        {
            for (int x = -center; x <= center; x++)
            {
                double value = Math.Exp(-(x * x + y * y) / (2 * sigma * sigma));
                window[y + center, x + center] = value;
                sum += value;
            }
        }
        
        // 정규화
        for (int i = 0; i < size; i++)
        {
            for (int j = 0; j < size; j++)
            {
                window[i, j] /= sum;
            }
        }
        
        return window;
    }
    
    private static double[,] ComputeHarrisResponse(
        double[,] Ix2, double[,] Iy2, double[,] IxIy,
        double[,] window, double k)
    {
        int width = Ix2.GetLength(0);
        int height = Ix2.GetLength(1);
        int wSize = window.GetLength(0);
        int wRadius = wSize / 2;
        
        double[,] response = new double[width, height];
        
        // 각 픽셀에 대해 창 내의 합 계산
        for (int y = wRadius; y < height - wRadius; y++)
        {
            for (int x = wRadius; x < width - wRadius; x++)
            {
                double A = 0, B = 0, C = 0;
                
                // 창 내의 가중 합 계산
                for (int wy = -wRadius; wy <= wRadius; wy++)
                {
                    for (int wx = -wRadius; wx <= wRadius; wx++)
                    {
                        double weight = window[wy + wRadius, wx + wRadius];
                        
                        A += Ix2[x + wx, y + wy] * weight;
                        B += Iy2[x + wx, y + wy] * weight;
                        C += IxIy[x + wx, y + wy] * weight;
                    }
                }
                
                // 해리스 응답 계산
                double det = A * B - C * C;
                double trace = A + B;
                response[x, y] = det - k * trace * trace;
            }
        }
        
        return response;
    }
    
    private static List<CornerPoint> ExtractCorners(
        double[,] response,
        double threshold,
        bool nonMaxSuppression,
        int minDistance)
    {
        List<CornerPoint> corners = new List<CornerPoint>();
        int width = response.GetLength(0);
        int height = response.GetLength(1);
        
        // 1. 임계값 적용 및 초기 후보 추출
        for (int y = 1; y < height - 1; y++)
        {
            for (int x = 1; x < width - 1; x++)
            {
                double r = response[x, y];
                
                if (r > threshold)
                {
                    corners.Add(new CornerPoint
                    {
                        Location = new Point(x, y),
                        Response = r
                    });
                }
            }
        }
        
        // 2. 비최대 억제 적용
        if (nonMaxSuppression)
        {
            corners = ApplyNonMaxSuppression(corners, response);
        }
        
        // 3. 최소 거리 제약 적용
        if (minDistance > 0)
        {
            corners = ApplyMinDistanceConstraint(corners, minDistance);
        }
        
        // 응답값 기준 정렬
        return corners.OrderByDescending(c => c.Response).ToList();
    }
    
    private static List<CornerPoint> ApplyNonMaxSuppression(
        List<CornerPoint> corners, double[,] response)
    {
        List<CornerPoint> suppressed = new List<CornerPoint>();
        
        foreach (var corner in corners)
        {
            Point p = corner.Location;
            double r = corner.Response;
            bool isLocalMax = true;
            
            // 3×3 윈도우에서 지역 최대값 검사
            for (int dy = -1; dy <= 1 && isLocalMax; dy++)
            {
                for (int dx = -1; dx <= 1 && isLocalMax; dx++)
                {
                    if (dx == 0 && dy == 0) continue;
                    
                    int nx = p.X + dx;
                    int ny = p.Y + dy;
                    
                    if (nx >= 0 && nx < response.GetLength(0) &&
                        ny >= 0 && ny < response.GetLength(1))
                    {
                        if (response[nx, ny] > r)
                        {
                            isLocalMax = false;
                        }
                    }
                }
            }
            
            if (isLocalMax)
            {
                suppressed.Add(corner);
            }
        }
        
        return suppressed;
    }
    
    private static List<CornerPoint> ApplyMinDistanceConstraint(
        List<CornerPoint> corners, int minDistance)
    {
        List<CornerPoint> filtered = new List<CornerPoint>();
        bool[] kept = new bool[corners.Count];
        
        for (int i = 0; i < corners.Count; i++)
        {
            if (kept[i]) continue;
            
            CornerPoint current = corners[i];
            filtered.Add(current);
            kept[i] = true;
            
            // 주변 코너 제거
            for (int j = i + 1; j < corners.Count; j++)
            {
                if (kept[j]) continue;
                
                CornerPoint other = corners[j];
                double distance = Math.Sqrt(
                    Math.Pow(other.Location.X - current.Location.X, 2) +
                    Math.Pow(other.Location.Y - current.Location.Y, 2));
                
                if (distance < minDistance)
                {
                    kept[j] = true;
                }
            }
        }
        
        return filtered;
    }
}
```

### 2. Shi-Tomasi 코너 검출 (Good Features to Track)

```csharp
public class ShiTomasiCornerDetector
{
    public static List<Point> DetectCorners(
        MyImage src,
        int maxCorners = 100,
        double qualityLevel = 0.01,
        double minDistance = 10,
        int blockSize = 3,
        bool useHarris = false,
        double k = 0.04)
    {
        // 1. 그래디언트 계산
        var (gx, gy) = HarrisCornerDetector.ComputeGradients(src);
        
        // 2. 구조 텐서 구성 요소 계산
        int width = src.Width;
        int height = src.Height;
        
        double[,] Ix2 = new double[width, height];
        double[,] Iy2 = new double[width, height];
        double[,] IxIy = new double[width, height];
        
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                Ix2[x, y] = gx[x, y] * gx[x, y];
                Iy2[x, y] = gy[x, y] * gy[x, y];
                IxIy[x, y] = gx[x, y] * gy[x, y];
            }
        }
        
        // 3. 창 함수 적용
        double[,] window = CreateGaussianWindow(blockSize, 1.0);
        
        // 4. 응답 맵 계산
        double[,] response = ComputeResponseMap(
            Ix2, Iy2, IxIy, window, useHarris, k);
        
        // 5. 코너 추출
        return ExtractCorners(
            response, maxCorners, qualityLevel, minDistance);
    }
    
    private static double[,] ComputeResponseMap(
        double[,] Ix2, double[,] Iy2, double[,] IxIy,
        double[,] window, bool useHarris, double k)
    {
        int width = Ix2.GetLength(0);
        int height = Ix2.GetLength(1);
        int wSize = window.GetLength(0);
        int wRadius = wSize / 2;
        
        double[,] response = new double[width, height];
        
        for (int y = wRadius; y < height - wRadius; y++)
        {
            for (int x = wRadius; x < width - wRadius; x++)
            {
                double A = 0, B = 0, C = 0;
                
                // 창 내의 가중 합
                for (int wy = -wRadius; wy <= wRadius; wy++)
                {
                    for (int wx = -wRadius; wx <= wRadius; wx++)
                    {
                        double weight = window[wy + wRadius, wx + wRadius];
                        
                        A += Ix2[x + wx, y + wy] * weight;
                        B += Iy2[x + wx, y + wy] * weight;
                        C += IxIy[x + wx, y + wy] * weight;
                    }
                }
                
                // 응답 계산
                if (useHarris)
                {
                    // 해리스 응답
                    double det = A * B - C * C;
                    double trace = A + B;
                    response[x, y] = det - k * trace * trace;
                }
                else
                {
                    // Shi-Tomasi 응답: 최소 고유값
                    double trace = A + B;
                    double det = A * B - C * C;
                    double discriminant = trace * trace - 4 * det;
                    
                    if (discriminant >= 0)
                    {
                        double sqrtDisc = Math.Sqrt(discriminant);
                        double lambda1 = (trace + sqrtDisc) / 2;
                        double lambda2 = (trace - sqrtDisc) / 2;
                        
                        // 최소 고유값
                        response[x, y] = Math.Min(lambda1, lambda2);
                    }
                    else
                    {
                        response[x, y] = 0;
                    }
                }
            }
        }
        
        return response;
    }
    
    private static double[,] CreateGaussianWindow(int size, double sigma)
    {
        // HarrisCornerDetector의 메서드와 동일
        double[,] window = new double[size, size];
        int center = size / 2;
        double sum = 0.0;
        
        for (int y = -center; y <= center; y++)
        {
            for (int x = -center; x <= center; x++)
            {
                double value = Math.Exp(-(x * x + y * y) / (2 * sigma * sigma));
                window[y + center, x + center] = value;
                sum += value;
            }
        }
        
        for (int i = 0; i < size; i++)
        {
            for (int j = 0; j < size; j++)
            {
                window[i, j] /= sum;
            }
        }
        
        return window;
    }
    
    private static List<Point> ExtractCorners(
        double[,] response,
        int maxCorners,
        double qualityLevel,
        double minDistance)
    {
        List<(Point Point, double Score)> candidates = new List<(Point, double)>();
        int width = response.GetLength(0);
        int height = response.GetLength(1);
        
        // 1. 모든 후보 수집
        for (int y = 1; y < height - 1; y++)
        {
            for (int x = 1; x < width - 1; x++)
            {
                double score = response[x, y];
                
                // 지역 최대값인지 확인
                bool isLocalMax = true;
                for (int dy = -1; dy <= 1 && isLocalMax; dy++)
                {
                    for (int dx = -1; dx <= 1 && dx == 0 && dy == 0; dx++)
                    {
                        if (response[x + dx, y + dy] > score)
                        {
                            isLocalMax = false;
                        }
                    }
                }
                
                if (isLocalMax && score > 0)
                {
                    candidates.Add((new Point(x, y), score));
                }
            }
        }
        
        // 2. 품질 수준 기준 정렬 및 필터링
        candidates = candidates.OrderByDescending(c => c.Score).ToList();
        
        double maxScore = candidates.First().Score;
        double minScore = maxScore * qualityLevel;
        
        candidates = candidates.Where(c => c.Score >= minScore).ToList();
        
        // 3. 최소 거리 제약 적용
        List<Point> corners = new List<Point>();
        
        foreach (var candidate in candidates)
        {
            bool tooClose = false;
            
            foreach (var existing in corners)
            {
                double distance = Math.Sqrt(
                    Math.Pow(existing.X - candidate.Point.X, 2) +
                    Math.Pow(existing.Y - candidate.Point.Y, 2));
                
                if (distance < minDistance)
                {
                    tooClose = true;
                    break;
                }
            }
            
            if (!tooClose)
            {
                corners.Add(candidate.Point);
                
                if (corners.Count >= maxCorners)
                {
                    break;
                }
            }
        }
        
        return corners;
    }
}
```

### 3. FAST 코너 검출(Features from Accelerated Segment Test)

```csharp
public class FASTCornerDetector
{
    public static List<Point> DetectCorners(
        MyImage src,
        int threshold = 20,
        bool nonMaxSuppression = true)
    {
        List<Point> corners = new List<Point>();
        int width = src.Width;
        int height = src.Height;
        
        // Bresenham 원 좌표 (반지름 3)
        Point[] circlePoints = new Point[]
        {
            new Point(0, -3), new Point(1, -3), new Point(2, -2),
            new Point(3, -1), new Point(3, 0), new Point(3, 1),
            new Point(2, 2), new Point(1, 3), new Point(0, 3),
            new Point(-1, 3), new Point(-2, 2), new Point(-3, 1),
            new Point(-3, 0), new Point(-3, -1), new Point(-2, -2),
            new Point(-1, -3)
        };
        
        // 각 픽셀에 대해 FAST 검사 (경계 제외)
        for (int y = 3; y < height - 3; y++)
        {
            for (int x = 3; x < width - 3; x++)
            {
                byte center = src.GetPixel(x, y);
                
                // 빠른 조기 거부 (첫 4개 점 검사)
                int count = 0;
                for (int i = 0; i < 4; i++)
                {
                    Point offset = circlePoints[i * 4];
                    byte pixel = src.GetPixel(x + offset.X, y + offset.Y);
                    
                    if (Math.Abs(pixel - center) > threshold)
                    {
                        count++;
                    }
                }
                
                if (count < 3) continue; // FAST 실패
                
                // 전체 원 검사
                count = 0;
                for (int i = 0; i < 16; i++)
                {
                    Point offset = circlePoints[i];
                    byte pixel = src.GetPixel(x + offset.X, y + offset.Y);
                    
                    if (Math.Abs(pixel - center) > threshold)
                    {
                        count++;
                    }
                }
                
                // 연속된 12개 점 이상이 임계값을 넘는지 확인
                if (count >= 12)
                {
                    corners.Add(new Point(x, y));
                }
            }
        }
        
        // 비최대 억제 적용
        if (nonMaxSuppression)
        {
            corners = ApplyFASTNonMaxSuppression(src, corners, circlePoints, threshold);
        }
        
        return corners;
    }
    
    private static List<Point> ApplyFASTNonMaxSuppression(
        MyImage src,
        List<Point> corners,
        Point[] circlePoints,
        int threshold)
    {
        // 코너 응답 점수 계산
        Dictionary<Point, int> cornerScores = new Dictionary<Point, int>();
        
        foreach (var corner in corners)
        {
            int score = ComputeFASTScore(src, corner, circlePoints, threshold);
            cornerScores[corner] = score;
        }
        
        // 비최대 억제 적용
        List<Point> suppressed = new List<Point>();
        
        foreach (var corner in corners)
        {
            bool isLocalMax = true;
            int currentScore = cornerScores[corner];
            
            // 3×3 윈도우에서 지역 최대값 검사
            for (int dy = -1; dy <= 1 && isLocalMax; dy++)
            {
                for (int dx = -1; dx <= 1 && isLocalMax; dx++)
                {
                    if (dx == 0 && dy == 0) continue;
                    
                    Point neighbor = new Point(corner.X + dx, corner.Y + dy);
                    
                    if (cornerScores.ContainsKey(neighbor) && 
                        cornerScores[neighbor] > currentScore)
                    {
                        isLocalMax = false;
                    }
                }
            }
            
            if (isLocalMax)
            {
                suppressed.Add(corner);
            }
        }
        
        return suppressed;
    }
    
    private static int ComputeFASTScore(
        MyImage src,
        Point corner,
        Point[] circlePoints,
        int threshold)
    {
        byte center = src.GetPixel(corner.X, corner.Y);
        int score = 0;
        
        // 원 위의 모든 점과의 절대 차이 합
        for (int i = 0; i < 16; i++)
        {
            Point offset = circlePoints[i];
            byte pixel = src.GetPixel(corner.X + offset.X, corner.Y + offset.Y);
            score += Math.Abs(pixel - center);
        }
        
        return score;
    }
}
```

---

## 엣지 및 코너 검출 알고리즘 비교

### 성능 비교 표

| 알고리즘 | 검출 대상 | 계산 복잡도 | 강건성 | 정확도 | 실시간 적용 | 주요 매개변수 |
|----------|-----------|-------------|--------|--------|-------------|---------------|
| **소벨** | 엣지 | O(N) | 중간 | 중간 | ⭐⭐⭐⭐ | 임계값 |
| **캐니** | 엣지 | O(N log N) | 높음 | 높음 | ⭐⭐⭐ | σ, 임계값 |
| **라플라시안** | 엣지 | O(N) | 낮음 | 낮음 | ⭐⭐⭐⭐ | 임계값 |
| **LoG** | 엣지 | O(N log N) | 중간 | 높음 | ⭐⭐ | σ |
| **허프 변환** | 직선/원 | O(N·M) | 높음 | 높음 | ⭐ | 임계값, 해상도 |
| **해리스** | 코너 | O(N) | 높음 | 높음 | ⭐⭐⭐ | k, 임계값 |
| **Shi-Tomasi** | 코너 | O(N) | 높음 | 매우 높음 | ⭐⭐⭐ | 품질 수준 |
| **FAST** | 코너 | O(N) | 중간 | 중간 | ⭐⭐⭐⭐⭐ | 임계값 |

### 시각적 결과 비교 다이어그램

```
입력 영상: [사각형 객체가 있는 영상]
│
├── 소벨: ──┐
│           ├─→ 엣지가 두껍고 불연속적
│           └─→ 노이즈에 민감
│
├── 캐니: ──┐
│           ├─→ 얇고 연속적인 엣지
│           └─→ 매개변수에 민감
│
├── 허프: ──┐
│           ├─→ 완전한 직선 검출
│           └─→ 계산 비용 높음
│
├── 해리스: ─┐
│           ├─→ 모서리 위치 정확
│           └─→ 균일 영역에서 오검출
│
└── FAST: ──┐
            ├─→ 매우 빠름
            └─→ 회전에 민감
```

### 선택 가이드라인

```
응용 요구사항 분석
│
├── 실시간 처리 필요?
│   ├── Yes → FAST, 소벨
│   └── No → 정확도 요구사항 확인
│
├── 정확한 엣지 위치 필요?
│   ├── Yes → 캐니, LoG
│   └── No → 소벨, 프리윗
│
├── 직선/원 검출 필요?
│   ├── Yes → 허프 변환
│   └── No → 특징점 검출 필요 확인
│
├── 특징점(코너) 검출 필요?
│   ├── Yes → 정확도 vs 속도 선택
│   │   ├── 최고 정확도: Shi-Tomasi
│   │   ├── 균형: 해리스
│   │   └── 최고 속도: FAST
│   └── No → 엣지 검출기 선택
│
└── 계산 리소스 제한?
    ├── 엄격함 → FAST, 소벨
    ├── 중간 → 캐니, 해리스
    └── 충분함 → 허프, LoG
```

---

## 실제 응용 사례

### 1. 문서 스캐닝 및 정렬

```csharp
public class DocumentScanner
{
    public static MyImage ScanDocument(MyImage input)
    {
        // 1. 엣지 검출 (캐니 사용)
        var edges = CannyEdgeDetector.DetectEdges(input);
        
        // 2. 허프 변환으로 직선 검출
        var lines = HoughLineDetector.DetectLines(edges);
        
        // 3. 문서 경계선 찾기 (가장 긴 4개의 직선)
        var documentLines = lines
            .OrderByDescending(l => CalculateLineLength(l))
            .Take(4)
            .ToList();
        
        // 4. 교점 계산으로 코너점 찾기
        var corners = FindDocumentCorners(documentLines);
        
        // 5. 투시 변환으로 문서 정렬
        return PerspectiveCorrection.CorrectDocument(input, corners);
    }
    
    private static double CalculateLineLength(HoughLineDetector.DetectedLine line)
    {
        double dx = line.EndPoint.X - line.StartPoint.X;
        double dy = line.EndPoint.Y - line.StartPoint.Y;
        return Math.Sqrt(dx * dx + dy * dy);
    }
    
    private static List<Point> FindDocumentCorners(
        List<HoughLineDetector.DetectedLine> lines)
    {
        // 4개의 직선 교점 계산
        List<Point> intersections = new List<Point>();
        
        for (int i = 0; i < lines.Count; i++)
        {
            for (int j = i + 1; j < lines.Count; j++)
            {
                Point? intersection = CalculateLineIntersection(lines[i], lines[j]);
                if (intersection.HasValue)
                {
                    intersections.Add(intersection.Value);
                }
            }
        }
        
        // 가장 바깥쪽 4개의 점 선택 (볼록 껍질)
        return FindConvexHull(intersections).Take(4).ToList();
    }
}
```

### 2. 자율 주행을 위한 차선 인식

```csharp
public class LaneDetectionSystem
{
    public class LaneDetectionResult
    {
        public List<Point> LeftLane { get; set; }
        public List<Point> RightLane { get; set; }
        public Point VanishingPoint { get; set; }
        public double Curvature { get; set; }
    }
    
    public static LaneDetectionResult DetectLanes(MyImage roadImage)
    {
        // 1. 관심 영역(ROI) 설정 (하단 50%)
        MyImage roi = ExtractROI(roadImage, 0.5);
        
        // 2. 엣지 검출 (캐니)
        var edges = CannyEdgeDetector.DetectEdges(roi);
        
        // 3. 허프 변환으로 직선 검출
        var lines = HoughLineDetector.DetectLinesProbabilistic(
            edges, minLineLength: 30, maxLineGap: 10);
        
        // 4. 좌우 차선 분류
        var (leftLines, rightLines) = ClassifyLaneLines(lines, roadImage.Width);
        
        // 5. 차선 근사화 (다항식 피팅)
        var leftLane = FitPolynomial(leftLines);
        var rightLane = FitPolynomial(rightLines);
        
        // 6. 소실점 계산
        var vanishingPoint = CalculateVanishingPoint(leftLane, rightLane);
        
        // 7. 곡률 계산
        double curvature = CalculateCurvature(leftLane, rightLane);
        
        return new LaneDetectionResult
        {
            LeftLane = leftLane,
            RightLane = rightLane,
            VanishingPoint = vanishingPoint,
            Curvature = curvature
        };
    }
    
    private static (List<HoughLineDetector.DetectedLine> left, 
                    List<HoughLineDetector.DetectedLine> right) 
        ClassifyLaneLines(List<HoughLineDetector.DetectedLine> lines, int imageWidth)
    {
        var leftLines = new List<HoughLineDetector.DetectedLine>();
        var rightLines = new List<HoughLineDetector.DetectedLine>();
        int centerX = imageWidth / 2;
        
        foreach (var line in lines)
        {
            double slope = CalculateSlope(line);
            
            // 수직에 가까운 선은 무시
            if (Math.Abs(slope) < 0.1) continue;
            
            // 선의 중점 x좌표로 좌우 분류
            double midX = (line.StartPoint.X + line.EndPoint.X) / 2.0;
            
            if (slope < 0 && midX < centerX)
            {
                leftLines.Add(line); // 왼쪽 차선 (음의 기울기)
            }
            else if (slope > 0 && midX > centerX)
            {
                rightLines.Add(line); // 오른쪽 차선 (양의 기울기)
            }
        }
        
        return (leftLines, rightLines);
    }
    
    private static double CalculateSlope(HoughLineDetector.DetectedLine line)
    {
        double dx = line.EndPoint.X - line.StartPoint.X;
        double dy = line.EndPoint.Y - line.StartPoint.Y;
        
        if (Math.Abs(dx) < 1e-6) return double.PositiveInfinity;
        return dy / dx;
    }
}
```

### 3. 의료 영상 분석 (종양 경계 검출)

```csharp
public class MedicalEdgeAnalysis
{
    public class TumorBoundaryAnalysis
    {
        public MyImage BoundaryImage { get; set; }
        public double Perimeter { get; set; }
        public double Area { get; set; }
        public double Circularity { get; set; }
        public List<Point> ConvexHull { get; set; }
    }
    
    public static TumorBoundaryAnalysis AnalyzeTumorBoundary(MyImage mriSlice)
    {
        // 1. 적응형 엣지 검출 (의료 영상 특성 고려)
        var edges = DetectMedicalEdges(mriSlice);
        
        // 2. 윤곽선 추출
        var contours = ExtractContours(edges);
        
        // 3. 가장 큰 윤곽선 선택 (종양으로 가정)
        var mainContour = contours
            .OrderByDescending(c => c.Count)
            .FirstOrDefault();
        
        if (mainContour == null || mainContour.Count < 10)
        {
            return null;
        }
        
        // 4. 윤곽선 분석
        double perimeter = CalculatePerimeter(mainContour);
        double area = CalculateArea(mainContour);
        double circularity = CalculateCircularity(perimeter, area);
        var convexHull = CalculateConvexHull(mainContour);
        
        // 5. 결과 시각화
        MyImage boundaryImage = VisualizeBoundary(mriSlice, mainContour);
        
        return new TumorBoundaryAnalysis
        {
            BoundaryImage = boundaryImage,
            Perimeter = perimeter,
            Area = area,
            Circularity = circularity,
            ConvexHull = convexHull
        };
    }
    
    private static MyImage DetectMedicalEdges(MyImage medicalImage)
    {
        // 의료 영상 특성: 낮은 대비, 높은 노이즈
        
        // 1. 적응형 히스토그램 평활화
        MyImage enhanced = AdaptiveHistogramEqualization(medicalImage);
        
        // 2. LoG 엣지 검출 (의료 영상에 적합)
        double[,] logResponse = LoGEdgeDetector.ApplyEfficient(enhanced, sigma: 1.5);
        
        // 3. 영교차 검출
        return LoGEdgeDetector.DetectZeroCrossing(logResponse, threshold: 0.02);
    }
    
    private static List<List<Point>> ExtractContours(MyImage binaryEdges)
    {
        // 연결 요소 분석을 통한 윤곽선 추출
        List<List<Point>> contours = new List<List<Point>>();
        bool[,] visited = new bool[binaryEdges.Width, binaryEdges.Height];
        
        for (int y = 0; y < binaryEdges.Height; y++)
        {
            for (int x = 0; x < binaryEdges.Width; x++)
            {
                if (binaryEdges.GetPixel(x, y) > 0 && !visited[x, y])
                {
                    var contour = TraceContour(binaryEdges, visited, x, y);
                    if (contour.Count > 10) // 작은 노이즈 제외
                    {
                        contours.Add(contour);
                    }
                }
            }
        }
        
        return contours;
    }
    
    private static List<Point> TraceContour(
        MyImage edges, bool[,] visited, int startX, int startY)
    {
        List<Point> contour = new List<Point>();
        Stack<Point> stack = new Stack<Point>();
        
        stack.Push(new Point(startX, startY));
        
        // 8방향 탐색 순서
        Point[] directions = new Point[]
        {
            new Point(0, -1), new Point(1, -1),
            new Point(1, 0), new Point(1, 1),
            new Point(0, 1), new Point(-1, 1),
            new Point(-1, 0), new Point(-1, -1)
        };
        
        while (stack.Count > 0)
        {
            Point current = stack.Pop();
            
            if (visited[current.X, current.Y]) continue;
            
            visited[current.X, current.Y] = true;
            contour.Add(current);
            
            // 8방향 이웃 검사
            foreach (var dir in directions)
            {
                int nx = current.X + dir.X;
                int ny = current.Y + dir.Y;
                
                if (nx >= 0 && nx < edges.Width && 
                    ny >= 0 && ny < edges.Height &&
                    edges.GetPixel(nx, ny) > 0 && 
                    !visited[nx, ny])
                {
                    stack.Push(new Point(nx, ny));
                }
            }
        }
        
        return contour;
    }
}
```

---

## 성능 최적화 기법

### 1. 하드웨어 가속 (GPU, SIMD)

```csharp
public class HardwareAcceleratedEdgeDetection
{
    // GPU 가속을 위한 인터페이스 (개념적)
    public interface IGPUEdgeDetector
    {
        Task<MyImage> DetectEdgesGPUAsync(MyImage src, EdgeDetectorType type);
        Task<List<Point>> DetectCornersGPUAsync(MyImage src, CornerDetectorType type);
    }
    
    // SIMD 최적화된 소벨 연산자
    public static unsafe (float[,] magnitude, float[,] direction) 
        SobelSIMD(MyImage src)
    {
        int width = src.Width;
        int height = src.Height;
        
        float[,] magnitude = new float[width, height];
        float[,] direction = new float[width, height];
        
        fixed (byte* srcPtr = src.Buffer)
        fixed (float* magPtr = magnitude)
        fixed (float* dirPtr = direction)
        {
            // SIMD 벡터 크기
            int vectorSize = System.Numerics.Vector<float>.Count;
            
            // 병렬 처리
            Parallel.For(1, height - 1, y =>
            {
                for (int x = 1; x < width - 1; x += vectorSize)
                {
                    // SIMD 연산을 통한 그래디언트 계산
                    // (실제 구현은 하드웨어 의존적)
                }
            });
        }
        
        return (magnitude, direction);
    }
}
```

### 2. 피라미드 기반 다중 스케일 처리

```csharp
public class MultiScaleEdgeDetection
{
    public static List<MyImage> DetectEdgesMultiScale(
        MyImage src, 
        int numScales = 3,
        double scaleFactor = 0.5)
    {
        List<MyImage> edgePyramid = new List<MyImage>();
        MyImage current = src;
        
        for (int i = 0; i < numScales; i++)
        {
            // 현재 스케일에서 엣지 검출
            var edges = CannyEdgeDetector.DetectEdges(current);
            edgePyramid.Add(edges);
            
            // 다음 스케일로 다운샘플링
            if (i < numScales - 1)
            {
                current = Downsample(current, scaleFactor);
            }
        }
        
        return edgePyramid;
    }
    
    private static MyImage Downsample(MyImage src, double factor)
    {
        int newWidth = (int)(src.Width * factor);
        int newHeight = (int)(src.Height * factor);
        MyImage dst = new MyImage(newWidth, newHeight);
        
        // 간단한 평균 다운샘플링
        int blockSize = (int)(1.0 / factor);
        
        for (int y = 0; y < newHeight; y++)
        {
            for (int x = 0; x < newWidth; x++)
            {
                int sum = 0;
                int count = 0;
                
                for (int dy = 0; dy < blockSize && y * blockSize + dy < src.Height; dy++)
                {
                    for (int dx = 0; dx < blockSize && x * blockSize + dx < src.Width; dx++)
                    {
                        sum += src.GetPixel(x * blockSize + dx, y * blockSize + dy);
                        count++;
                    }
                }
                
                dst.SetPixel(x, y, (byte)(sum / count));
            }
        }
        
        return dst;
    }
    
    // 다중 스케일 코너 검출
    public static List<Point> DetectCornersMultiScale(
        MyImage src,
        double scaleFactor = 0.5,
        int numScales = 3)
    {
        Dictionary<Point, int> cornerCounts = new Dictionary<Point, int>();
        
        MyImage current = src;
        double currentScale = 1.0;
        
        for (int i = 0; i < numScales; i++)
        {
            // 현재 스케일에서 코너 검출
            var corners = HarrisCornerDetector.DetectCorners(current);
            
            // 원래 스케일로 좌표 변환 및 누적
            foreach (var corner in corners)
            {
                Point originalPoint = new Point(
                    (int)(corner.Location.X / currentScale),
                    (int)(corner.Location.Y / currentScale));
                
                if (cornerCounts.ContainsKey(originalPoint))
                {
                    cornerCounts[originalPoint]++;
                }
                else
                {
                    cornerCounts[originalPoint] = 1;
                }
            }
            
            // 다음 스케일로 다운샘플링
            if (i < numScales - 1)
            {
                current = Downsample(current, scaleFactor);
                currentScale *= scaleFactor;
            }
        }
        
        // 다중 스케일에서 일관되게 검출된 코너만 선택
        int threshold = (int)(numScales * 0.7); // 70% 이상에서 검출
        return cornerCounts
            .Where(kvp => kvp.Value >= threshold)
            .Select(kvp => kvp.Key)
            .ToList();
    }
}
```

---

## 평가 지표 및 벤치마크

```csharp
public class EdgeCornerEvaluation
{
    public class EvaluationMetrics
    {
        public double Precision { get; set; }
        public double Recall { get; set; }
        public double F1Score { get; set; }
        public double MeanLocalizationError { get; set; }
        public TimeSpan ComputationTime { get; set; }
    }
    
    public static EvaluationMetrics EvaluateEdgeDetector(
        Func<MyImage, MyImage> detector,
        MyImage groundTruth,
        MyImage testImage,
        double distanceThreshold = 2.0)
    {
        var watch = System.Diagnostics.Stopwatch.StartNew();
        
        // 엣지 검출 실행
        MyImage detected = detector(testImage);
        
        watch.Stop();
        
        // 정확도 계산
        int truePositives = 0;
        int falsePositives = 0;
        int falseNegatives = 0;
        double totalLocalizationError = 0;
        int matchedCount = 0;
        
        // 검출된 엣지 픽셀과 Ground Truth 비교
        for (int y = 0; y < groundTruth.Height; y++)
        {
            for (int x = 0; x < groundTruth.Width; x++)
            {
                bool isGroundTruth = groundTruth.GetPixel(x, y) > 0;
                bool isDetected = detected.GetPixel(x, y) > 0;
                
                if (isGroundTruth && isDetected)
                {
                    truePositives++;
                    
                    // 가장 가까운 Ground Truth 점 찾기
                    double minDistance = FindNearestGroundTruthDistance(
                        groundTruth, x, y, distanceThreshold);
                    
                    if (minDistance <= distanceThreshold)
                    {
                        totalLocalizationError += minDistance;
                        matchedCount++;
                    }
                }
                else if (isGroundTruth && !isDetected)
                {
                    falseNegatives++;
                }
                else if (!isGroundTruth && isDetected)
                {
                    falsePositives++;
                }
            }
        }
        
        // 메트릭 계산
        double precision = truePositives / (double)(truePositives + falsePositives + 1e-10);
        double recall = truePositives / (double)(truePositives + falseNegatives + 1e-10);
        double f1Score = 2 * precision * recall / (precision + recall + 1e-10);
        double meanError = matchedCount > 0 ? totalLocalizationError / matchedCount : double.PositiveInfinity;
        
        return new EvaluationMetrics
        {
            Precision = precision,
            Recall = recall,
            F1Score = f1Score,
            MeanLocalizationError = meanError,
            ComputationTime = watch.Elapsed
        };
    }
    
    private static double FindNearestGroundTruthDistance(
        MyImage groundTruth, int x, int y, double maxDistance)
    {
        double minDistance = double.MaxValue;
        int searchRadius = (int)Math.Ceiling(maxDistance);
        
        for (int dy = -searchRadius; dy <= searchRadius; dy++)
        {
            for (int dx = -searchRadius; dx <= searchRadius; dx++)
            {
                int nx = x + dx;
                int ny = y + dy;
                
                if (nx >= 0 && nx < groundTruth.Width && 
                    ny >= 0 && ny < groundTruth.Height &&
                    groundTruth.GetPixel(nx, ny) > 0)
                {
                    double distance = Math.Sqrt(dx * dx + dy * dy);
                    minDistance = Math.Min(minDistance, distance);
                }
            }
        }
        
        return minDistance;
    }
}
```

---

## 결론 및 모범 사례

### 핵심 원칙 요약

1. **엣지 검출의 목적**: 객체 경계, 텍스처 변화, 중요한 시각적 특징 추출
2. **코너 검출의 중요성**: 특징점 기반 정합, 객체 인식, 3D 재구성의 기초
3. **알고리즘 선택 기준**: 정확도, 계산 효율성, 강건성, 응용 분야 요구사항

### 구현 모범 사례

1. **전처리의 중요성**: 적절한 노이즈 제거와 대비 향상이 검출 성능 결정
2. **매개변수 튜닝**: 데이터 특성에 맞는 임계값, 스케일, 커널 크기 선택
3. **후처리 활용**: 비최대 억제, 연결성 분석, 다중 스케일 통합
4. **하이브리드 접근법**: 여러 알고리즘 조합으로 성능 향상

### 미래 발전 방향

1. **딥러닝 기반 검출**: CNN을 이용한 엣지/코너 학습, 컨텍스트 인식
2. **실시간 최적화**: 모바일/임베디드 장치를 위한 경량화 알고리즘
3. **3D 엣지 검출**: 깊이 정보 활용, 공간적 엣지 분석
4. **시공간적 분석**: 비디오 시퀀스에서의 동적 엣지/코너 추적
5. **도메인 적응**: 특정 응용 분야에 최적화된 검출기 학습

엣지 및 코너 검출은 컴퓨터 비전의 기본 구성 요소로서, 올바른 알고리즘 선택과 구현이 전체 시스템의 성능을 결정합니다. 본 문서에서 소개한 다양한 기법과 최적화 전략을 활용하여 다양한 응용 분야에 효과적으로 적용할 수 있습니다.