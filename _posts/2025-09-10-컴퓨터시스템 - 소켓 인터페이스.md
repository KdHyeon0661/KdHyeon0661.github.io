---
layout: post
title: 컴퓨터시스템 - 소켓 인터페이스
date: 2025-09-10 14:20:23 +0900
category: 컴퓨터시스템
---
# 소켓 인터페이스(Socket API)

> 형식: 본문 전체는 `~~~markdown`으로 감싸고, **모든 코드/명령은 ```** 로 표기합니다.
> 목표: `socket/bind/connect/listen/accept/send/recv/setsockopt/getaddrinfo` 를 **정확히** 이해하고,
> **논블로킹 + epoll**, **TCP/UDP 핵심 옵션(TCP_NODELAY, SO_REUSEADDR, SO_REUSEPORT, KEEPALIVE)**, **브로드캐스트/멀티캐스트**, **UNIX 도메인/FD 전달**, **SIGPIPE/부분 전송** 등 실전 함정을 모두 다룹니다.
> 대상: Linux(우선), POSIX 일반. IPv4/IPv6 듀얼스택과 최신 커널 옵션(예: `EPOLLEXCLUSIVE`, `TCP_FASTOPEN`)은 주석으로 병기.

---

## 1) 소켓의 큰 그림

- **소켓(Socket)**: 커널이 제공하는 **통신 엔드포인트(파일 디스크립터, FD)**.
- 생성:
```c
int fd = socket(int domain, int type, int protocol);
// domain: AF_INET(IPv4), AF_INET6(IPv6), AF_UNIX(로컬 IPC) ...
// type  : SOCK_STREAM(TCP), SOCK_DGRAM(UDP), SOCK_SEQPACKET(연결형 고정 메시지) ...
// proto : 보통 0(자동) 또는 IPPROTO_TCP/IPPROTO_UDP
```
- **서버(TCP)**: `socket → setsockopt → bind → listen → accept → read/write → close`
- **클라(TCP)**: `socket → connect → read/write → close`
- **UDP**: `socket → (bind) → recvfrom/sendto` (연결 개념 없음. 필요 시 `connect`로 기본 대상/ICMP 수신 고정 가능)

---

## 2) 주소 구조체·바이트 순서·변환

- 공통 시그니처는 `struct sockaddr*` (실제는 구체형 캐스팅)
  - IPv4: `struct sockaddr_in`
  - IPv6: `struct sockaddr_in6` (link-local 주소는 `sin6_scope_id` 필요할 수 있음)
  - UNIX: `struct sockaddr_un`
- **바이트 순서**: 네트워크는 **빅엔디안** → `htons/ntohs`, `htonl/ntohl`
- 문자열 변환:
```c
inet_pton(AF_INET,  "192.0.2.1",  &sin.sin_addr);
inet_pton(AF_INET6, "2001:db8::1", &sin6.sin6_addr);
inet_ntop(..., &addr, buf, sizeof buf); // 주소를 문자열로
```
- **권장**: `getaddrinfo/getnameinfo` (DNS/서비스 이름/IPv4·IPv6 겸용 처리)

---

## 3) 주소 해석의 정석 — `getaddrinfo`

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>

int open_listen(const char *port) {
    struct addrinfo hints, *res, *rp; memset(&hints,0,sizeof hints);
    hints.ai_family   = AF_UNSPEC;       // v4/v6 모두 시도
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE;      // 서버(bind)용
    if (getaddrinfo(NULL, port, &hints, &res) != 0) return -1;

    int fd = -1, on=1;
    for (rp = res; rp; rp = rp->ai_next) {
        fd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (fd < 0) continue;
        setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
        if (bind(fd, rp->ai_addr, rp->ai_addrlen) == 0 && listen(fd, 128) == 0) break;
        close(fd); fd = -1;
    }
    freeaddrinfo(res);
    return fd;
}
```
**팁**
- 서버: `AI_PASSIVE` + `NULL` 호스트 → 모든 인터페이스(`INADDR_ANY`/`in6addr_any`)
- 클라: 호스트/포트 문자열 입력 → v6/v4 후보를 순회하며 `connect`(Happy Eyeballs는 사용자 공간에서 parallel connect로 구현 가능)

---

## 4) 최소 예제 — TCP 에코(블로킹)

### 서버
```c
#include <arpa/inet.h>
#include <netinet/tcp.h>
#include <sys/socket.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main() {
    signal(SIGPIPE, SIG_IGN);                // 닫힌 피어에 write 시 종료 방지
    int s = socket(AF_INET6, SOCK_STREAM, 0);

    int v6only = 0;                          // 듀얼스택(디스트리뷰션별 기본값 다를 수 있으니 명시)
    setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));

    int on = 1;                              // 빠른 재바인드
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));

    struct sockaddr_in6 addr = {0};
    addr.sin6_family = AF_INET6;
    addr.sin6_addr   = in6addr_any;
    addr.sin6_port   = htons(9000);
    if (bind(s, (struct sockaddr*)&addr, sizeof(addr)) < 0) { perror("bind"); return 1; }
    if (listen(s, 128) < 0) { perror("listen"); return 1; }

    for (;;) {
        struct sockaddr_storage peer; socklen_t len=sizeof(peer);
        int c = accept(s, (struct sockaddr*)&peer, &len);
        if (c < 0) { perror("accept"); continue; }

        char buf[4096]; ssize_t n;
        while ((n = read(c, buf, sizeof buf)) > 0) {
            ssize_t w=0; while (w<n) {
                ssize_t k = send(c, buf+w, (size_t)(n-w), MSG_NOSIGNAL); // SIGPIPE 방지
                if (k < 0) { perror("send"); n=-1; break; } w += k;
            }
        }
        close(c);
    }
}
```

### 클라이언트
```c
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main() {
    struct addrinfo hints={0}, *ai;
    hints.ai_socktype = SOCK_STREAM;
    getaddrinfo("127.0.0.1", "9000", &hints, &ai);
    int s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
    connect(s, ai->ai_addr, ai->ai_addrlen); freeaddrinfo(ai);

    const char *msg="hello\n";
    write(s, msg, strlen(msg));
    char buf[1024]; ssize_t n = read(s, buf, sizeof buf);
    if (n>0) write(1, buf, (size_t)n);
    close(s);
}
```

---

## 5) 전송 함수·플래그·부분 전송 규율

| 함수 | 설명 | 주의 포인트 |
|---|---|---|
| `send/recv` | TCP/UDP 공통 I/O | **부분 전송** 가능. 반환값 체크 후 루프 |
| `sendto/recvfrom` | 주소 동반(주로 UDP) | `recvfrom`의 peer 주소를 그대로 `sendto`로 회신 |
| `sendmsg/recvmsg` | 다중 iov/제어 메시지 | FD 전달(`SCM_RIGHTS`), `IP_PKTINFO` 등 고급 기능 |
| `read/write` | TCP에서 흔히 사용 | `SIGPIPE` 주의(`MSG_NOSIGNAL` 또는 `SIGPIPE` 무시) |

**흔한 에러**
- `EINTR`: 시그널로 중단 → **재시도**
- `EAGAIN/EWOULDBLOCK`: 논블로킹에서 아직 준비 안 됨 → **이벤트 대기**
- `ECONNRESET/ETIMEDOUT`: peer reset/타임아웃

---

## 6) 핵심 소켓 옵션 (필수·자주 쓰는 것)

```c
int on=1;

/* 빠른 재시작/바인드 */
setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));

/* 멀티 워커 수신(리눅스, 해시 분배). LB 또는 thundering herd 완화 */
setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &on, sizeof(on));

/* Nagle 비활성(지연 민감 트래픽) */
setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on));

/* Keepalive: 장수명 연결 관리 */
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));
int idle=30, intvl=10, cnt=5;                 // 초 단위(리눅스)
setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE,  &idle, sizeof(idle));
setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &intvl, sizeof(intvl));
setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT,   &cnt,  sizeof(cnt));

/* 버퍼 크기 튜닝(커널이 2배수로 조정할 수 있음) */
int sz = 1<<20; // 1MiB
setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &sz, sizeof(sz));
setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &sz, sizeof(sz));

/* IPv6 듀얼스택 제어 */
int v6only=0; setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
```

**기타 유용 옵션**
- `SO_LINGER`(종료 시 RST/대기 제어), `IP_TOS`/`IPV6_TCLASS`(DSCP),
- `TCP_CORK`(일시 묶음 전송, 리눅스), `TCP_QUICKACK`(ACK 지연 힌트),
- `IP_MTU_DISCOVER`(PMTU 정책), `SO_BUSY_POLL`(저지연 NIC 바쁜 폴링; 특수 환경).
- 리스너에 `EPOLLEXCLUSIVE`(리눅스 4.5+) → 멀티 accept 와 `epoll`에서 herd 완화.

---

## 7) 논블로킹과 `epoll` — 실전 스켈레톤

### 7.1 논블로킹 설정
```c
#include <fcntl.h>
int set_nb(int fd){
    int fl = fcntl(fd, F_GETFL);
    return fcntl(fd, F_SETFL, fl | O_NONBLOCK);
}
```

### 7.2 epoll 서버(엣지 트리거) — 핵심 루프
```c
#include <sys/epoll.h>
#include <signal.h>
#include <errno.h>

int ep = epoll_create1(EPOLL_CLOEXEC);
struct epoll_event ev = {.events=EPOLLIN|EPOLLEXCLUSIVE, .data.fd=listenfd}; // 리눅스 4.5+
epoll_ctl(ep, EPOLL_CTL_ADD, listenfd, &ev);

for (;;) {
    struct epoll_event out[256];
    int n = epoll_wait(ep, out, 256, -1);
    for (int i=0;i<n;i++) {
        int fd = out[i].data.fd;
        uint32_t e = out[i].events;
        if (fd == listenfd) {
            for (;;) { // 엣지 트리거: 가능한 한 accept를 소진
                int c = accept4(listenfd, NULL, NULL, SOCK_NONBLOCK|SOCK_CLOEXEC);
                if (c < 0) {
                    if (errno==EAGAIN || errno==EWOULDBLOCK) break;
                    if (errno==EMFILE || errno==ENFILE) { /* 보류/백오프/보호 FD 테크닉 */ }
                    break;
                }
                struct epoll_event ec = {.events=EPOLLIN|EPOLLET, .data.fd=c};
                epoll_ctl(ep, EPOLL_CTL_ADD, c, &ec);
            }
        } else {
            if (e & (EPOLLERR|EPOLLHUP)) { close(fd); continue; }
            if (e & EPOLLIN) {
                for (;;) {                 // EPOLLET: 버퍼를 최대한 비움
                    char buf[4096]; ssize_t n = read(fd, buf, sizeof buf);
                    if (n > 0) {
                        // echo: 쓰기 준비 없을 수 있으니 큐에 적재 후 EPOLLOUT 켜기
                        ssize_t w=0; while (w<n) {
                            ssize_t k = send(fd, buf+w, (size_t)(n-w), MSG_NOSIGNAL);
                            if (k>0) { w += k; continue; }
                            if (k<0 && (errno==EAGAIN||errno==EWOULDBLOCK)) {
                                struct epoll_event mod={.events=EPOLLIN|EPOLLOUT|EPOLLET, .data.fd=fd};
                                epoll_ctl(ep, EPOLL_CTL_MOD, fd, &mod);
                                // 남은 바이트는 per-conn 큐에 저장
                                break;
                            } else { close(fd); break; }
                        }
                    } else if (n==0) { close(fd); break; } // peer close
                    else {
                        if (errno==EAGAIN||errno==EWOULDBLOCK) break;
                        if (errno==EINTR) continue;
                        close(fd); break;
                    }
                }
            }
            if (e & EPOLLOUT) {
                // 보류 중인 송신 큐를 drain.
                // 모두 보냈으면 EPOLLOUT 플래그 제거(토글)
                struct epoll_event mod={.events=EPOLLIN|EPOLLET, .data.fd=fd};
                epoll_ctl(ep, EPOLL_CTL_MOD, fd, &mod);
            }
        }
    }
}
```
**규율(중요)**
- **엣지 트리거(EPOLLET)**는 **버퍼를 다 비울 때까지 반복 read** / **보낼 수 있을 때까지 반복 write**.
- `EPOLLOUT`은 **필요할 때만** 켰다가 **다 보냈으면 끄기**(상시 켜두면 wake 폭증).
- **에러는 이벤트와 함께** (반드시 `EPOLLERR/EPOLLHUP` 체크).

### 7.3 논블로킹 connect 핸드셰이크
```c
int s = socket(...); set_nb(s);
int r = connect(s, addr, addrlen);
if (r<0 && errno==EINPROGRESS) {
    // epoll로 EPOLLOUT 대기 후:
    int soerr=0; socklen_t sl=sizeof soerr;
    getsockopt(s, SOL_SOCKET, SO_ERROR, &soerr, &sl);
    if (soerr==0) {/* 연결 성공 */} else {/* 실패 처리 */}
}
```

---

## 8) UDP — 브로드캐스트·멀티캐스트·패킷 방향성

### 8.1 브로드캐스트(IPv4)
```c
int on=1; setsockopt(s, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on));
struct sockaddr_in b = {.sin_family=AF_INET, .sin_port=htons(9001)};
b.sin_addr.s_addr = inet_addr("255.255.255.255"); // 또는 서브넷 브로드캐스트
sendto(s, msg, len, 0, (struct sockaddr*)&b, sizeof b);
```

### 8.2 멀티캐스트(IPv4)
```c
/* 가입 */
struct ip_mreq mreq = {
  .imr_multiaddr.s_addr = inet_addr("239.0.0.1"),
  .imr_interface.s_addr = htonl(INADDR_ANY)
};
setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));

/* TTL/루프백/인터페이스 선택 */
unsigned char ttl=8, loop=0;
setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL,  &ttl,  sizeof ttl);
setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, &loop, sizeof loop);
// IP_MULTICAST_IF 로 송신 인터페이스 지정 가능
```
- IPv6: `IPV6_JOIN_GROUP` / `IPV6_MULTICAST_HOPS` / `IPV6_MULTICAST_IF` 사용.
- SSM(Source-Specific Multicast): `IP_ADD_SOURCE_MEMBERSHIP` / `IPV6_ADD_SOURCE_MEMBERSHIP`.

### 8.3 수신 인터페이스/목적지 식별(답장에 유용) — `IP_PKTINFO`
```c
struct in_pktinfo { ... }; // recvmsg로 제어 메시지 수신
// cmsg_level=IPPROTO_IP, cmsg_type=IP_PKTINFO → 목적지 IP/인터페이스 index 확인
```

---

## 9) UNIX 도메인 소켓 — 로컬 IPC + FD 전달

### 9.1 기본 서버
```c
#include <sys/un.h>
#include <sys/socket.h>
#include <unistd.h>
#include <string.h>

int s = socket(AF_UNIX, SOCK_STREAM, 0);
struct sockaddr_un su = {.sun_family=AF_UNIX};
strncpy(su.sun_path, "/tmp/app.sock", sizeof(su.sun_path)-1);
unlink(su.sun_path);                                // 기존 파일 제거
bind(s, (struct sockaddr*)&su, sizeof(su));
listen(s, 16);
```
**Linux 추신**: 추상 네임스페이스(파일 없음)는 `sun_path[0]='\0'` + 이름 바이트들.

### 9.2 FD 전달(`SCM_RIGHTS`)
```c
// 송신: sendmsg로 제어 메시지에 FD 첨부
struct msghdr msg={0}; struct iovec iov={.iov_base="X", .iov_len=1};
char cbuf[CMSG_SPACE(sizeof(int))]; msg.msg_iov=&iov; msg.msg_iovlen=1;
msg.msg_control=cbuf; msg.msg_controllen=sizeof cbuf;
struct cmsghdr* c = CMSG_FIRSTHDR(&msg);
c->cmsg_level=SOL_SOCKET; c->cmsg_type=SCM_RIGHTS; c->cmsg_len=CMSG_LEN(sizeof(int));
*(int*)CMSG_DATA(c) = fd_to_send;
sendmsg(sock, &msg, 0);

// 수신: recvmsg 후 CMSG 파싱해 FD 획득
```

---

## 10) 연결 종료와 half-close

- `shutdown(fd, SHUT_WR)` : **송신 절반 닫기(우리 FIN)** — 상대는 읽기 EOF를 받지만 자신은 계속 보낼 수 있음.
- `shutdown(fd, SHUT_RD)` : 수신만 닫기.
- `close(fd)`            : FD 참조 해제(마지막 참조면 커널이 실제 종료).
- `SO_LINGER`             : `close` 지연/즉시 RST 정책 제어(신중히 사용).

---

## 11) 고성능/현대 커널의 팁

- **백로그**: `listen(fd, backlog)`의 유효치는 커널 `somaxconn`에 의해 상한. 서비스는 **충분히 크게** + **시스템 튜닝**.
- **`accept` herd**: `SO_REUSEPORT`로 포트 분할, 또는 `EPOLLEXCLUSIVE`(리스너만)로 wake 수 줄이기.
- **제로카피**: 파일 응답은 `sendfile`(디스크→소켓), 파이프/소켓 간은 `splice/tee`(리눅스 특화).
- **`sendmmsg/recvmmsg`**: 다중 메시지를 한 번에 처리(UDP/DTLS/로깅 등 고QPS).
- **`TCP_FASTOPEN`**: SYN 단계에서 데이터 송신(클라/서버 모두 옵션 + 커널/방화벽 환경 필요).
- **타임스탬프/드롭 카운터**: `SO_TIMESTAMPNS`, `SO_RXQ_OVFL`(패킷 드롭 관측) — `recvmsg` 제어 메시지.

---

## 12) 견고성(신뢰성/보안) 체크

- `SIGPIPE` 무력화: `signal(SIGPIPE, SIG_IGN)` 또는 `MSG_NOSIGNAL`
- `CLOEXEC`: `accept4(..., SOCK_CLOEXEC)` / `fcntl(fd, F_SETFD, FD_CLOEXEC)`로 FD 유출 방지
- 제한/자원: `RLIMIT_NOFILE`, **EMFILE/ENFILE** 대비(보호 FD 전략)
- 시간 제한: 블로킹 소켓에 `SO_RCVTIMEO/SO_SNDTIMEO` (논블로킹+epoll일 땐 직접 타임휠/타이머 관리 권장)
- TLS: 소켓 위에 OpenSSL/mbedTLS를 얹고 **검증(호스트명/CA/ALPN)** 을 엄격히 설정
- 로깅: peer 정보는 `getpeername`, 로컬 바인드 정보는 `getsockname`으로 수집

---

## 13) 종합 예제 — **논블로킹 TCP 에코 서버(epoll) 완성판 스케치**

> 포인트: **부분 송신 큐**, **EPOLLET 규율**, **EPOLLOUT 토글**, **에러/종료 처리**, **CLOEXEC/논블로킹**.

```c
// gcc -O3 -Wall -Wextra -pthread -o echo_nb echo_nb.c
#define _GNU_SOURCE
#include <sys/epoll.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <signal.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct conn {
  int fd;
  char* wbuf; size_t wlen, woff; // 보류 중 송신 버퍼
  struct conn* next;
} conn_t;

static int nb(int fd){ int fl=fcntl(fd,F_GETFL); return fcntl(fd,F_SETFL,fl|O_NONBLOCK); }
static int mklisten(int port){
  int s=socket(AF_INET6,SOCK_STREAM|SOCK_CLOEXEC,0); if(s<0) return -1;
  int one=1,v6only=0;
  setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&one,sizeof(one));
  setsockopt(s,IPPROTO_IPV6,IPV6_V6ONLY,&v6only,sizeof(v6only));
  struct sockaddr_in6 a={0}; a.sin6_family=AF_INET6; a.sin6_port=htons(port); a.sin6_addr=in6addr_any;
  if(bind(s,(struct sockaddr*)&a,sizeof a)<0) return -1;
  if(listen(s,1024)<0) return -1;
  nb(s); return s;
}
static void mod_ep(int ep,int fd,uint32_t ev){
  struct epoll_event e={.events=ev,.data.fd=fd};
  epoll_ctl(ep,EPOLL_CTL_MOD,fd,&e);
}
static void add_ep(int ep,int fd,uint32_t ev){
  struct epoll_event e={.events=ev,.data.fd=fd};
  epoll_ctl(ep,EPOLL_CTL_ADD,fd,&e);
}
static void del_ep(int ep,int fd){ epoll_ctl(ep,EPOLL_CTL_DEL,fd,NULL); }

int main(){
  signal(SIGPIPE, SIG_IGN);
  int ls = mklisten(9000); if(ls<0){ perror("listen"); return 1; }
  int ep = epoll_create1(EPOLL_CLOEXEC);
  struct epoll_event le={.events=EPOLLIN|EPOLLEXCLUSIVE,.data.fd=ls};
  epoll_ctl(ep,EPOLL_CTL_ADD,ls,&le);

  for(;;){
    struct epoll_event ev[256];
    int n=epoll_wait(ep,ev,256,-1);
    for(int i=0;i<n;i++){
      int fd=ev[i].data.fd; uint32_t e=ev[i].events;
      if(fd==ls){
        for(;;){
          int c = accept4(ls,NULL,NULL,SOCK_NONBLOCK|SOCK_CLOEXEC);
          if(c<0){ if(errno==EAGAIN||errno==EWOULDBLOCK) break; perror("accept"); break; }
          add_ep(ep,c,EPOLLIN|EPOLLET);
        }
        continue;
      }
      if(e&(EPOLLERR|EPOLLHUP)){ del_ep(ep,fd); close(fd); continue; }
      if(e&EPOLLIN){
        for(;;){
          char buf[8192]; ssize_t n=read(fd,buf,sizeof buf);
          if(n>0){
            // 즉시 가능한 만큼 전송
            ssize_t w=0; while(w<n){
              ssize_t k=send(fd,buf+w,(size_t)(n-w),MSG_NOSIGNAL);
              if(k>0){ w+=k; continue; }
              if(k<0 && (errno==EAGAIN||errno==EWOULDBLOCK)){
                // 남은 데이터 큐잉 (데모: 간단히 malloc 사용)
                size_t remain=(size_t)(n-w);
                char* p=malloc(remain); memcpy(p,buf+w,remain);
                // 실제로는 per-connection 상태 구조체를 관리해야 함
                // 여기선 간단화를 위해 EPOLLOUT만 켠다 (실무: 연결 별 큐 관리)
                mod_ep(ep,fd,EPOLLIN|EPOLLOUT|EPOLLET);
                break;
              } else { del_ep(ep,fd); close(fd); break; }
            }
          } else if(n==0){ del_ep(ep,fd); close(fd); break; }
          else {
            if(errno==EAGAIN||errno==EWOULDBLOCK) break;
            if(errno==EINTR) continue;
            del_ep(ep,fd); close(fd); break;
          }
        }
      }
      if(e&EPOLLOUT){
        // 보류된 송신 큐를 drain. 모두 보냈으면 EPOLLOUT 끄기:
        mod_ep(ep,fd,EPOLLIN|EPOLLET);
      }
    }
  }
}
```
> 교육용 스케치입니다. 실제 서비스는 **연결 상태 객체**(수신/송신 큐, 타임아웃, 통계)를 별도로 두고, 메모리 풀/슬랩, 경계 스캔(프레이밍), 백프레셔 등을 갖춥니다.

---

## 14) 진단·도구·관찰

- `ss -tuna`/`netstat -anp`: 소켓 상태/바인드 확인
- `tcpdump -i any -nn tcp port 9000` / Wireshark: 패킷 캡처
- `lsof -iTCP:9000 -sTCP:LISTEN -Pn`: 프로세스 ↔ 포트 맵
- `nc`/`socat`: 수동 연결 테스트
- 성능/경합: `perf`, eBPF(bpftrace), `strace -ff -e trace=network`

---

## 15) 운영 체크리스트(요약)

- [ ] `getaddrinfo` 로 v4/v6 겸용 주소 해석
- [ ] 서버 리스너: `SO_REUSEADDR` (+ 필요 시 `SO_REUSEPORT`)
- [ ] `SIGPIPE` 무력화(신호 무시 또는 `MSG_NOSIGNAL`)
- [ ] **부분 전송 루프**와 `EINTR/EAGAIN` 처리
- [ ] 논블로킹 + **epoll 규율**(EPOLLET 시 버퍼 소진, `EPOLLOUT` 토글)
- [ ] 딜레이 민감: `TCP_NODELAY` / 장수명: `KEEPALIVE`(idle/intvl/cnt)
- [ ] 종료: `shutdown/close` 정책과 에러 로깅
- [ ] 보안: TLS 계층/검증, FD `CLOEXEC`, 자원 한도(RLIMIT_NOFILE)

---

## 16) 한 줄 결론

소켓은 **FD 기반 I/O의 연장선**입니다.
**주소 해석 → 생성/바인드/연결 → 송수신(부분 전송·에러 규율) → 종료**의 뼈대를 지키고,
**옵션(TCP_NODELAY/KEEPALIVE/REUSE*), 논블로킹+epoll, UDP 멀티캐스트/브로드캐스트, UNIX 도메인/FD 전달**을 상황에 적용하면
실전에서도 **견고하고 빠른** 네트워크 프로그램을 지속적으로 확장할 수 있습니다.
