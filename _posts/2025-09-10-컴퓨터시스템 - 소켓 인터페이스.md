---
layout: post
title: 컴퓨터시스템 - 소켓 인터페이스
date: 2025-09-10 14:20:23 +0900
category: 컴퓨터시스템
---
# 소켓 인터페이스(Socket API) — UNIX/Linux 심층 가이드

> 목표: **프로세스 ↔ 네트워크**를 연결하는 표준 API를 **TCP/UDP/IPv4/IPv6/UNIX 도메인**까지 폭넓게 다룹니다.  
> `socket/bind/connect/listen/accept/send/recv/setsockopt/getaddrinfo`를 **정확히** 이해하고,  
> **논블로킹/이벤트(epoll)**, **옵션(TCP_NODELAY, SO_REUSEADDR, SO_REUSEPORT, KEEPALIVE)**,  
> **멀티캐스트/브로드캐스트**, **SIGPIPE/부분전송** 같은 함정도 함께 정리합니다.

---

## 1) 소켓의 큰 그림

- **소켓**: 커널이 제공하는 **통신 엔드포인트**(FD).  
- 생성: `socket(domain, type, protocol)`
  - `domain`: `AF_INET`(IPv4), `AF_INET6`(IPv6), `AF_UNIX`(로컬), …
  - `type`: `SOCK_STREAM`(TCP), `SOCK_DGRAM`(UDP), `SOCK_SEQPACKET`(연결형 고정 메시지), …
  - `protocol`: 보통 0(자동 선택) 또는 `IPPROTO_TCP`/`IPPROTO_UDP`.

---

## 2) 주소 구조체와 바이트 순서

- **일반 포인터**는 `struct sockaddr*`, 실제로는 구체형으로 캐스팅:
  - IPv4: `struct sockaddr_in`
  - IPv6: `struct sockaddr_in6`
  - UNIX 도메인: `struct sockaddr_un`
- **바이트 순서**: 네트워크는 **빅엔디안**
  - 포트/IPv4 정수 변환: `htons/ntohs`, `htonl/ntohl`
- 출력/파싱:
  - 문자열 ↔ 이진: `inet_pton/inet_ntop`
  - 권장(해석+DNS): **`getaddrinfo`/`getnameinfo`**

---

## 3) 필수 호출 흐름( TCP )

### 서버
1) `socket` → 2) `setsockopt(SO_REUSEADDR[, SO_REUSEPORT])` →  
3) `bind`(IP:포트) → 4) `listen`(백로그) → 5) `accept`(클라이언트별 새 FD)

### 클라이언트
1) `socket` → 2) `connect`(서버 IP:포트) → 3) `send/recv` → 4) `close`

### UDP(연결 없음)
- 서버: `socket`→`bind`→`recvfrom`/`sendto`  
- 클라: `socket`→`sendto`/`recvfrom` 또는 `connect`로 기본 대상 고정(에러·ICMP 수신 가능)

---

## 4) 주소 해석(권장) — `getaddrinfo`

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>

int open_listen(const char *port) {
    struct addrinfo hints = {0}, *res, *rp;
    hints.ai_family   = AF_UNSPEC;      // v4/v6 모두 시도
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE;     // 서버용(로컬 bind 주소 자동)
    if (getaddrinfo(NULL, port, &hints, &res) != 0) return -1;

    int fd = -1;
    for (rp = res; rp; rp = rp->ai_next) {
        fd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (fd < 0) continue;
        int on = 1;
        setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
        if (bind(fd, rp->ai_addr, rp->ai_addrlen) == 0) {
            if (listen(fd, 128) == 0) break;    // 성공!
        }
        close(fd); fd = -1;
    }
    freeaddrinfo(res);
    return fd; // 실패 시 -1
}
```

- **장점**: IPv4/IPv6 겸용, DNS·서비스 이름(`"http"`) 해석, 포트 문자열 처리.

---

## 5) 최소 예제 — TCP 에코

### 서버
```c
#include <arpa/inet.h>
#include <netinet/tcp.h>
#include <sys/socket.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main() {
    int s = socket(AF_INET6, SOCK_STREAM, 0);
    int v6only = 0; // 듀얼스택(시스템 설정에 따라 필요)
    setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));

    int on = 1;
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));

    struct sockaddr_in6 addr = {0};
    addr.sin6_family = AF_INET6;
    addr.sin6_addr   = in6addr_any;
    addr.sin6_port   = htons(9000);
    bind(s, (struct sockaddr*)&addr, sizeof(addr));
    listen(s, 128);

    for (;;) {
        struct sockaddr_storage peer; socklen_t len = sizeof(peer);
        int c = accept(s, (struct sockaddr*)&peer, &len);
        if (c < 0) continue;

        char buf[4096];
        ssize_t n;
        while ((n = read(c, buf, sizeof buf)) > 0) {
            ssize_t w = 0;
            while (w < n) { // 부분 전송 처리
                ssize_t k = write(c, buf + w, (size_t)(n - w));
                if (k < 0) { n = -1; break; }
                w += k;
            }
        }
        close(c);
    }
}
```

### 클라이언트
```c
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

int main() {
    struct addrinfo hints={0}, *res;
    hints.ai_socktype = SOCK_STREAM;
    getaddrinfo("127.0.0.1", "9000", &hints, &res);
    int s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    connect(s, res->ai_addr, res->ai_addrlen);
    freeaddrinfo(res);

    const char *msg = "hello\n";
    write(s, msg, strlen(msg));

    char buf[1024]; ssize_t n = read(s, buf, sizeof buf);
    if (n > 0) write(1, buf, (size_t)n);  // stdout
    close(s);
}
```

---

## 6) 전송 함수와 플래그

| 함수 | 용도 | 주의 |
|---|---|---|
| `send/recv` | TCP/UDP 공통 | 반환값(부분 전송), `EINTR`/`EAGAIN` 처리 |
| `sendto/recvfrom` | UDP 또는 비연결 | 주소 동반 |
| `sendmsg/recvmsg` | 고급(다중 iov, 제어 메시지) | FD 전달, TTL, TOS 등 |
| `read/write` | TCP에서 흔히 사용 | `SIGPIPE` 주의(아래) |

**플래그 예시**
- `MSG_DONTWAIT`(논블로킹 1회), `MSG_NOSIGNAL`(EPIPE 시 SIGPIPE 방지),  
  `MSG_PEEK`(소켓 버퍼를 훔쳐보기), `MSG_WAITALL`(요청 길이까지 대기; 과대기 주의),  
  `MSG_MORE`(Linux, 패킷 합치기 힌트; TCP_CORK 유사).

---

## 7) 에러·함정 모음

- **부분 전송**: `send/recv`/`write/read`는 **요청 길이만큼 처리하지 않을 수 있음** → 루프.
- **`EINTR`**: 시그널로 중단 → 재시도.
- **`EAGAIN/EWOULDBLOCK`**: 논블로킹에서 아직 준비 안 됨 → 이벤트 대기.
- **`SIGPIPE`**: 닫힌 피어로 쓰기 → 프로세스 종료 위험
  - 해결: `signal(SIGPIPE, SIG_IGN)` 또는 `send(..., MSG_NOSIGNAL)` 사용.
- **`Nagle`(지연 ACK)로 인한 지연**: 대화형/지연 민감이면 `TCP_NODELAY`.
- **TIME_WAIT**: 서버 재시작 포트 바인드 실패 → `SO_REUSEADDR` 사용.

---

## 8) 소켓 옵션(핵심만)

```c
int on=1;
/* 포트 재사용(빠른 재시작) */
setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));

/* 로드밸런싱/멀티수신(리눅스) */
setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &on, sizeof(on));

/* Nagle 끄기(지연 감소) */
setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on));

/* TCP Keepalive(좀비 연결 감지) */
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));

/* 수/발신 버퍼 크기 조정 */
int sz = 1<<20; // 1MB
setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &sz, sizeof(sz));
setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &sz, sizeof(sz));

/* IPv6 전용/듀얼스택 제어 */
int v6only = 0; // 1이면 v6 only
setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &v6only, sizeof(v6only));
```

- `SO_LINGER`(종료 시 RST/대기 제어), `IP_TOS`(DSCP), `TCP_CORK`(리눅스, 묶어서 전송) 등 상황별 사용.

---

## 9) 논블로킹과 이벤트 루프(epoll)

```c
#include <sys/epoll.h>
#include <fcntl.h>

static int nb(int fd) {
    int fl = fcntl(fd, F_GETFL);
    return fcntl(fd, F_SETFL, fl | O_NONBLOCK);
}

int ep = epoll_create1(0);
struct epoll_event ev = {.events = EPOLLIN, .data.fd = listenfd};
epoll_ctl(ep, EPOLL_CTL_ADD, listenfd, &ev);

for (;;) {
    struct epoll_event out[64];
    int n = epoll_wait(ep, out, 64, -1);
    for (int i=0;i<n;i++) {
        int fd = out[i].data.fd;
        if (fd == listenfd) {
            int c = accept4(listenfd, NULL, NULL, SOCK_NONBLOCK|SOCK_CLOEXEC);
            struct epoll_event evc = {.events=EPOLLIN|EPOLLET, .data.fd=c};
            epoll_ctl(ep, EPOLL_CTL_ADD, c, &evc);
        } else {
            // fd에서 read/write: EAGAIN이면 다음 이벤트까지 보류
        }
    }
}
```

- **엣지 트리거(EPOLLET)** 사용 시, **버퍼를 비울 때까지 반복 read** 해야 재이벤트가 옵니다.

---

## 10) UDP: 브로드캐스트·멀티캐스트

### 브로드캐스트(IPv4)
```c
int on=1; setsockopt(s, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on));
struct sockaddr_in b = {.sin_family=AF_INET, .sin_port=htons(9001)};
b.sin_addr.s_addr = inet_addr("255.255.255.255"); // 또는 서브넷 브로드캐스트
sendto(s, msg, len, 0, (struct sockaddr*)&b, sizeof b);
```

### 멀티캐스트(가입/송신)
```c
/* 가입 */
struct ip_mreq mreq = { .imr_multiaddr.s_addr=inet_addr("239.0.0.1"),
                         .imr_interface.s_addr=htonl(INADDR_ANY) };
setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));

/* TTL 설정 */
unsigned char ttl = 8;
setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));
```

- IPv6는 `IPV6_JOIN_GROUP`, `IPV6_MULTICAST_HOPS` 사용.

---

## 11) UNIX 도메인 소켓(로컬 IPC)

```c
#include <sys/un.h>

int s = socket(AF_UNIX, SOCK_STREAM, 0);
struct sockaddr_un su = { .sun_family=AF_UNIX };
strncpy(su.sun_path, "/tmp/app.sock", sizeof(su.sun_path)-1);
unlink(su.sun_path);
bind(s, (struct sockaddr*)&su, sizeof(su));
listen(s, 16);
```

- **장점**: 빠르고 권한·소유권 제어 용이, FD 전달(아래)이 가능.
- **FD 전달**: `sendmsg/recvmsg`의 `SCM_RIGHTS` 제어 메시지로 다른 프로세스에 FD 넘기기.

---

## 12) 연결 종료와 반쯤 닫기(half-close)

- `shutdown(fd, SHUT_WR)` : **송신만 종료**(FIN). 상대는 더 이상 우리에게 보내지 말라는 시그널을 받지 않음.  
- `shutdown(fd, SHUT_RD)` : 수신만 종료.  
- `close(fd)` : FD 참조 해제(마지막 FD라면 커널이 연결을 정리).  
- `SO_LINGER` 로 close의 블록/즉시 RST를 제어 가능.

---

## 13) 보안/TLS 한 줄 메모

- 소켓 API 자체는 평문. TLS는 **라이브러리(OpenSSL, mbedTLS 등)**로 소켓 FD 위에 세션을 올립니다.
- 서버는 **ALPN/SNI**, 클라이언트는 **검증(CA/hostname)** 을 정확히 설정해야 함.

---

## 14) 진단·도구

- **ss/netstat**: 소켓 상태(TIME_WAIT/LISTEN 등)
- **tcpdump/wireshark**: 패킷 캡처
- **lsof -i**: 프로세스 ↔ 포트 매핑
- **nc/socat**: 수동 테스트

---

## 15) 체크리스트

- [ ] `getaddrinfo`로 주소 해석(IPv4/IPv6 겸용)  
- [ ] 서버: `SO_REUSEADDR`(+ 필요 시 `SO_REUSEPORT`)  
- [ ] 부분 전송 처리(루프) + `EINTR`/`EAGAIN`  
- [ ] `SIGPIPE` 무력화(`MSG_NOSIGNAL` 또는 ignore)  
- [ ] 딜레이 민감 시 `TCP_NODELAY`, 장수명 연결 `KEEPALIVE`  
- [ ] 논블로킹+`epoll` 사용 시 **엣지 트리거 규율** 준수  
- [ ] 종료 시 자원 정리(`shutdown/close`)와 에러 로깅

---

## 16) 한 줄 결론
소켓 인터페이스는 **FD 기반 I/O**의 연장입니다.  
주소 해석(`getaddrinfo`) → 생성/바인드/연결 → 송수신(`send/recv` 루프) → 종료 흐름을 기본으로,  
**옵션·논블로킹·이벤트·에러 규율**을 더하면 실전에서 **견고하고 빠른** 네트워크 프로그래밍이 가능합니다.