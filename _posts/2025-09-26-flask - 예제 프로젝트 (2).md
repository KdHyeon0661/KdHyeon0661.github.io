---
layout: post
title: flask - 예제 프로젝트 (2) REST API 서버
date: 2025-09-26 15:25:23 +0900
category: flask
---
# REST API 서버: JWT + Swagger(OpenAPI) + 테스트

이 예제는 Flask 기반 REST API 서버를 처음부터 끝까지 구현하는 완전한 가이드를 제공합니다. 포함된 기능으로는 JWT 인증(Access/Refresh 토큰 및 로테이션), 역할 기반 접근 제어(RBAC), Swagger UI(OpenAPI 3.0 문서), 요청 및 응답 스키마 검증(Marshmallow), 페이지네이션/정렬/검색 기능, 일관된 에러 포맷, pytest 기반 단위/통합 테스트와 커버리지, 그리고 샘플 CI 설정이 있습니다.

## 목표 아키텍처와 기술 스택

- **Flask 3.x**: 웹 애플리케이션 프레임워크
- **flask-smorest**: OpenAPI 3 자동 문서화 + 요청·응답 검증 + Swagger UI 제공
- **Marshmallow**: 데이터 직렬화/역직렬화와 스키마 검증
- **Flask-JWT-Extended**: JWT(액세스/리프레시 토큰) 인증 시스템
- **Flask-SQLAlchemy** + **Flask-Migrate(Alembic)**: ORM과 데이터베이스 마이그레이션
- **pytest** + **coverage**: 테스트와 코드 커버리지 측정
- 선택: **Flask-Limiter**(레이트 리미팅), **Flask-CORS**(CORS 지원)

## 프로젝트 디렉터리 구조

```
rest_api_demo/
├─ .env
├─ requirements.txt
├─ wsgi.py
├─ config.py
├─ app/
│  ├─ __init__.py
│  ├─ extensions.py
│  ├─ models.py
│  ├─ schemas.py
│  ├─ errors.py
│  ├─ auth/
│  │  └─ routes.py
│  ├─ items/
│  │  └─ routes.py
│  ├─ utils/
│  │  └─ pagination.py
│  └─ cli.py
├─ migrations/          # (flask db init 후 생성)
└─ tests/
   ├─ conftest.py
   ├─ test_auth.py
   └─ test_items.py
```

## 의존성 관리

### `requirements.txt`

```txt
Flask==3.0.3
flask-smorest==0.43.0
marshmallow==3.22.0
Flask-SQLAlchemy==3.1.1
Flask-Migrate==4.0.7
Flask-JWT-Extended==4.6.0
email-validator==2.2.0

pytest==8.3.2
coverage==7.6.1
httpx==0.27.2
Werkzeug==3.0.4
python-dotenv==1.0.1

Flask-Limiter==3.8.0     # (선택) 레이트 리미팅
Flask-CORS==4.0.1        # (선택) CORS
```

### `.env` 파일 (개발 환경)

```env
FLASK_APP=wsgi:app
FLASK_ENV=development
SECRET_KEY=dev-secret-change-me
JWT_SECRET_KEY=dev-jwt-secret-change-me
DATABASE_URL=sqlite:///dev.db
API_TITLE=REST API Demo
API_VERSION=1.0.0
```

## 설정과 애플리케이션 팩토리

### `config.py`

```python
import os

class BaseConfig:
    SECRET_KEY = os.getenv("SECRET_KEY", "change-me")
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL", "sqlite:///app.db")
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    API_TITLE = os.getenv("API_TITLE", "REST API")
    API_VERSION = os.getenv("API_VERSION", "1.0.0")
    OPENAPI_VERSION = "3.0.3"
    OPENAPI_URL_PREFIX = "/docs"
    OPENAPI_SWAGGER_UI_PATH = "/"
    OPENAPI_SWAGGER_UI_URL = "https://cdn.jsdelivr.net/npm/swagger-ui-dist/"

    JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "change-me")
    JWT_ACCESS_TOKEN_EXPIRES = 900     # 15분
    JWT_REFRESH_TOKEN_EXPIRES = 1209600 # 14일

    # (선택) CORS 설정
    CORS_ORIGINS = os.getenv("CORS_ORIGINS", "").split(",") if os.getenv("CORS_ORIGINS") else []

class DevelopmentConfig(BaseConfig):
    DEBUG = True

class ProductionConfig(BaseConfig):
    DEBUG = False

def get_config():
    env = os.getenv("FLASK_ENV", "production").lower()
    return DevelopmentConfig if env.startswith("dev") else ProductionConfig
```

### `app/extensions.py`

```python
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_smorest import Api
from flask_jwt_extended import JWTManager
from flask_cors import CORS
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

db = SQLAlchemy(session_options={"autoflush": False, "expire_on_commit": False})
migrate = Migrate()
api = Api()
jwt = JWTManager()
cors = CORS()
limiter = Limiter(key_func=get_remote_address, default_limits=["200/minute"])
```

### `app/__init__.py`

```python
from flask import Flask
from .extensions import db, migrate, api, jwt, cors, limiter
from .errors import register_error_handlers

def create_app():
    from config import get_config
    app = Flask(__name__)
    app.config.from_object(get_config())

    db.init_app(app)
    migrate.init_app(app, db)
    api.init_app(app)
    jwt.init_app(app)
    register_error_handlers(app)

    # Swagger 문서 보안 스키마 설정
    api.spec.components.security_scheme(
        "BearerAuth", {"type": "http", "scheme": "bearer", "bearerFormat": "JWT"}
    )
    api.spec.options["info"]["description"] = "JWT 인증 기반 REST API 예제"

    # (선택) CORS 설정
    if app.config.get("CORS_ORIGINS"):
        cors.init_app(app, resources={r"/api/*": {"origins": app.config["CORS_ORIGINS"]}}, supports_credentials=True)

    # (선택) 레이트 리미팅 설정
    limiter.init_app(app)

    # API 블루프린트 등록
    from .auth.routes import blp as auth_blp
    from .items.routes import blp as items_blp
    api.register_blueprint(auth_blp)
    api.register_blueprint(items_blp)

    # Flask shell 컨텍스트 설정
    @app.shell_context_processor
    def _ctx():
        from .models import User, Item
        return {"db": db, "User": User, "Item": Item}

    return app
```

### `wsgi.py`

```python
from app import create_app
app = create_app()

if __name__ == "__main__":
    app.run()
```

## 데이터 모델과 마이그레이션

### `app/models.py`

```python
from datetime import datetime, timezone
from werkzeug.security import generate_password_hash, check_password_hash
from .extensions import db

def utcnow():
    return datetime.now(timezone.utc)

class Role:
    USER = "user"
    ADMIN = "admin"

class User(db.Model):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True, index=True, nullable=False)
    name = db.Column(db.String(120), nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    role = db.Column(db.String(20), default=Role.USER, index=True)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime(timezone=True), default=utcnow)

    def set_password(self, raw: str):
        self.password_hash = generate_password_hash(raw)

    def check_password(self, raw: str) -> bool:
        return check_password_hash(self.password_hash, raw)

class Item(db.Model):
    __tablename__ = "items"
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False, index=True)
    content = db.Column(db.Text, nullable=True)
    price = db.Column(db.Integer, nullable=False, default=0)  # 센트/원 단위 예시
    created_at = db.Column(db.DateTime(timezone=True), default=utcnow, index=True)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=utcnow)
    owner_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False)

    owner = db.relationship("User", backref="items")
```

### 마이그레이션 초기화

```bash
pip install -r requirements.txt

flask db init
flask db migrate -m "초기 테이블 생성"
flask db upgrade
```

## 스키마 정의와 유틸리티

### `app/schemas.py`

```python
from marshmallow import Schema, fields, validate, EXCLUDE

class PaginatedIn(Schema):
    class Meta: unknown = EXCLUDE
    page = fields.Int(load_default=1, validate=validate.Range(min=1))
    per_page = fields.Int(load_default=10, validate=validate.Range(min=1, max=100))
    q = fields.Str(load_default=None)
    sort = fields.Str(load_default="-created_at")  # 예: "title", "-price"

class UserRegisterIn(Schema):
    email = fields.Email(required=True)
    name = fields.Str(required=True, validate=validate.Length(min=1, max=120))
    password = fields.Str(required=True, load_only=True, validate=validate.Length(min=8, max=128))

class UserOut(Schema):
    id = fields.Int()
    email = fields.Email()
    name = fields.Str()
    role = fields.Str()
    created_at = fields.DateTime()

class LoginIn(Schema):
    email = fields.Email(required=True)
    password = fields.Str(required=True, load_only=True)

class TokenOut(Schema):
    access_token = fields.Str()
    token_type = fields.Str(load_default="Bearer")
    expires_in = fields.Int()
    refresh_expires_in = fields.Int()
    refresh_token = fields.Str(load_only=True)

class ItemCreateIn(Schema):
    title = fields.Str(required=True, validate=validate.Length(min=1, max=200))
    content = fields.Str(load_default=None)
    price = fields.Int(required=True, validate=validate.Range(min=0))

class ItemUpdateIn(Schema):
    title = fields.Str(validate=validate.Length(min=1, max=200))
    content = fields.Str()
    price = fields.Int(validate=validate.Range(min=0))

class ItemOut(Schema):
    id = fields.Int()
    title = fields.Str()
    content = fields.Str(allow_none=True)
    price = fields.Int()
    owner_id = fields.Int()
    created_at = fields.DateTime()
    updated_at = fields.DateTime(allow_none=True)

class PageMeta(Schema):
    page = fields.Int()
    per_page = fields.Int()
    total = fields.Int()
    pages = fields.Int()

class ItemListOut(Schema):
    items = fields.List(fields.Nested(ItemOut))
    meta = fields.Nested(PageMeta)
```

### `app/utils/pagination.py`

```python
from sqlalchemy import desc, asc

def apply_sort(query, model, sort: str | None):
    if not sort: return query
    name = sort.lstrip("+-")
    col = getattr(model, name, None)
    if not col: return query
    order = desc(col) if sort.startswith("-") else asc(col)
    return query.order_by(order)

def page_to_dict(pagination):
    return {
        "items": pagination.items,
        "meta": {
            "page": pagination.page,
            "per_page": pagination.per_page,
            "total": pagination.total,
            "pages": pagination.pages,
        },
    }
```

## 에러 핸들링과 표준화

### 일관된 에러 포맷

모든 API 에러는 다음 JSON 형식을 따릅니다:

```json
{
  "error": {
    "type": "validation_error",
    "message": "Invalid field",
    "detail": {"field": "email", "reason": "already exists"}
  }
}
```

### `app/errors.py`

```python
from flask import jsonify
from marshmallow import ValidationError
from werkzeug.exceptions import HTTPException

def _err(type_, message, status=400, detail=None):
    payload = {"error": {"type": type_, "message": message}}
    if detail is not None:
        payload["error"]["detail"] = detail
    return jsonify(payload), status

def register_error_handlers(app):
    @app.errorhandler(ValidationError)
    def _handle_validation(e):
        return _err("validation_error", "Validation failed", 400, e.messages)

    @app.errorhandler(HTTPException)
    def _handle_http(e: HTTPException):
        msg = e.description if isinstance(e.description, str) else str(e)
        return _err("http_error", msg, e.code or 500)

    @app.errorhandler(Exception)
    def _handle_unexpected(e: Exception):
        app.logger.exception("Unhandled error")
        return _err("internal_error", "Unexpected error", 500)
```

## 인증 라우트(JWT 기반)

### 인증 시스템 설계 개요

- **액세스 토큰**(Access Token): 15분 유효기간
- **리프레시 토큰**(Refresh Token): 14일 유효기간 (둘 다 HS256 알고리즘 사용, 데모용)
- 로그인 시: 액세스 토큰 + 리프레시 토큰(응답 본문 포함). 실제 서비스에서는 **리프레시 토큰을 HttpOnly 쿠키로 저장** 권장
- **토큰 로테이션**: `/auth/refresh` 호출 시 새로운 액세스 토큰과 리프레시 토큰 발급

### `app/auth/routes.py`

```python
from flask import Blueprint
from flask_smorest import Blueprint as SmorestBlueprint, abort
from flask.views import MethodView
from flask_jwt_extended import (
    create_access_token, create_refresh_token, jwt_required, get_jwt_identity
)
from ..extensions import db, limiter
from ..models import User, Role
from ..schemas import UserRegisterIn, UserOut, LoginIn, TokenOut

blp = SmorestBlueprint("auth", "auth", url_prefix="/api/auth", description="인증/토큰 API")

@blp.route("/register")
class Register(MethodView):
    @blp.arguments(UserRegisterIn)
    @blp.response(201, UserOut)
    @limiter.limit("5/minute")
    def post(self, data):
        if User.query.filter_by(email=data["email"].lower()).first():
            abort(409, message="email already exists")
        u = User(email=data["email"].lower(), name=data["name"])
        u.set_password(data["password"])
        db.session.add(u); db.session.commit()
        return u

@blp.route("/login")
class Login(MethodView):
    @blp.arguments(LoginIn)
    @blp.response(200, TokenOut)
    @limiter.limit("20/minute")
    def post(self, data):
        u = User.query.filter_by(email=data["email"].lower()).first()
        if not u or not u.check_password(data["password"]):
            abort(401, message="invalid credentials")
        if not u.is_active:
            abort(403, message="inactive user")
        access = create_access_token(identity=str(u.id), additional_claims={"role": u.role})
        refresh = create_refresh_token(identity=str(u.id))
        from flask import current_app
        return {
            "access_token": access,
            "token_type": "Bearer",
            "expires_in": current_app.config["JWT_ACCESS_TOKEN_EXPIRES"],
            "refresh_expires_in": current_app.config["JWT_REFRESH_TOKEN_EXPIRES"],
            "refresh_token": refresh,
        }

@blp.route("/me")
class Me(MethodView):
    @jwt_required()
    @blp.response(200, UserOut)
    def get(self):
        uid = int(get_jwt_identity())
        u = User.query.get_or_404(uid)
        return u

@blp.route("/refresh")
class Refresh(MethodView):
    @jwt_required(refresh=True)
    @blp.response(200, TokenOut)
    def post(self):
        uid = get_jwt_identity()
        u = User.query.get(uid)
        if not u or not u.is_active:
            abort(403, message="user not allowed")
        access = create_access_token(identity=str(u.id), additional_claims={"role": u.role})
        refresh = create_refresh_token(identity=str(u.id))  # 토큰 로테이션
        from flask import current_app
        return {
            "access_token": access,
            "token_type": "Bearer",
            "expires_in": current_app.config["JWT_ACCESS_TOKEN_EXPIRES"],
            "refresh_expires_in": current_app.config["JWT_REFRESH_TOKEN_EXPIRES"],
            "refresh_token": refresh,
        }
```

> Swagger UI에서 "Authorize" 버튼을 클릭하고 `Bearer <access_token>` 형식으로 토큰을 입력하면 보호된 엔드포인트를 테스트할 수 있습니다.

## 도메인 라우트(Items 관리)

### 권한 검사 유틸리티

```python
# 간단한 RBAC 유틸리티 (필요 시 확장)

from flask_jwt_extended import verify_jwt_in_request, get_jwt
from flask_smorest import abort

def require_role(*roles):
    verify_jwt_in_request()
    claims = get_jwt()
    role = claims.get("role")
    if role not in roles:
        abort(403, message="insufficient role")
```

### `app/items/routes.py`

```python
from flask_smorest import Blueprint
from flask.views import MethodView
from flask_jwt_extended import jwt_required, get_jwt_identity
from sqlalchemy import or_
from ..extensions import db, limiter
from ..models import Item, User, Role
from ..schemas import (
    ItemCreateIn, ItemUpdateIn, ItemOut, ItemListOut, PaginatedIn
)
from ..utils.pagination import apply_sort, page_to_dict
from .rbac import require_role if False else lambda *a, **k: None  # (예제 단순화)

blp = Blueprint("items", "items", url_prefix="/api/items", description="아이템 CRUD API")

@blp.route("")
class Items(MethodView):
    @blp.arguments(PaginatedIn, location="query")
    @blp.response(200, ItemListOut)
    def get(self, args):
        """아이템 목록 조회(검색/정렬/페이지네이션)"""
        page = args["page"]; per = args["per_page"]
        qstr = args.get("q")
        sort = args.get("sort", "-created_at")

        query = Item.query
        if qstr:
            like = f"%{qstr}%"
            query = query.filter(or_(Item.title.ilike(like), Item.content.ilike(like)))

        query = apply_sort(query, Item, sort)
        pagination = query.paginate(page=page, per_page=per, error_out=False)
        return page_to_dict(pagination)

    @jwt_required()
    @blp.arguments(ItemCreateIn)
    @blp.response(201, ItemOut)
    @limiter.limit("60/minute")
    def post(self, data):
        """아이템 생성(로그인 필요)"""
        uid = int(get_jwt_identity())
        item = Item(owner_id=uid, **data)
        db.session.add(item); db.session.commit()
        return item

@blp.route("/<int:item_id>")
class ItemDetail(MethodView):
    @blp.response(200, ItemOut)
    def get(self, item_id):
        return Item.query.get_or_404(item_id)

    @jwt_required()
    @blp.arguments(ItemUpdateIn)
    @blp.response(200, ItemOut)
    def patch(self, data, item_id):
        uid = int(get_jwt_identity())
        item = Item.query.get_or_404(item_id)
        if item.owner_id != uid:
            blp.abort(403, message="only owner can modify")
        for k, v in data.items():
            setattr(item, k, v)
        db.session.commit()
        return item

    @jwt_required()
    @blp.response(204)
    def delete(self, item_id):
        uid = int(get_jwt_identity())
        item = Item.query.get_or_404(item_id)
        # ADMIN은 무조건 삭제 가능, 일반 사용자는 소유자만 삭제 가능
        from flask_jwt_extended import get_jwt
        role = (get_jwt() or {}).get("role")
        if not (item.owner_id == uid or role == Role.ADMIN):
            blp.abort(403, message="not allowed")
        db.session.delete(item); db.session.commit()
        return ""
```

## API 문서화(Swagger/OpenAPI)

서버 실행 후 **Swagger UI**에 접속: `http://127.0.0.1:5000/docs/`
`app/__init__.py`에서 등록된 `api.register_blueprint`들이 자동으로 스키마를 수집하여 문서를 생성합니다.

보안이 필요한 엔드포인트에 대한 문서화:

```python
# 각 메서드에 docstring 또는 @blp.doc 데코레이터로 보안 스키마 지정 가능

@blp.doc(security=[{"BearerAuth": []}])
@jwt_required()
def get(...):
    ...
```

## CLI 명령어(시드 데이터/관리자 생성)

### `app/cli.py`

```python
import click
from .extensions import db
from .models import User, Role, Item

def init_cli(app):
    @app.cli.command("create-user")
    @click.option("--email", prompt=True)
    @click.option("--name", prompt=True)
    @click.option("--password", prompt=True, hide_input=True, confirmation_prompt=True)
    @click.option("--admin", is_flag=True, help="관리자 권한 부여")
    def create_user(email, name, password, admin):
        if User.query.filter_by(email=email.lower()).first():
            click.echo("이미 존재하는 이메일입니다")
            raise SystemExit(1)
        u = User(email=email.lower(), name=name, role=(Role.ADMIN if admin else Role.USER))
        u.set_password(password)
        db.session.add(u); db.session.commit()
        click.echo(f"사용자 생성 완료: {u.id} {u.email}")

    @app.cli.command("seed-items")
    @click.option("--count", type=int, default=30)
    def seed_items(count):
        u = User.query.first()
        if not u:
            click.echo("먼저 사용자를 생성하세요: flask create-user")
            raise SystemExit(1)
        for i in range(count):
            db.session.add(Item(title=f"Item {i+1}", content=f"content {i+1}", price=1000 + i, owner_id=u.id))
        db.session.commit()
        click.echo(f"{count}개의 아이템 생성 완료")
```

`app/__init__.py`에서 `from . import cli; cli.init_cli(app)` 호출을 추가해야 합니다.

## 애플리케이션 실행

```bash
flask run          # http://127.0.0.1:5000

# 최초 사용자 및 테스트 데이터 생성

flask create-user --email admin@example.com --name Admin --admin
flask seed-items --count 40
```

- Swagger 문서: `GET /docs/`
- 로그인: `POST /api/auth/login` → Bearer 토큰 획득 → Swagger UI 상단 Authorize 버튼 → Bearer 토큰 입력

## 테스트(단위/통합 테스트)

### `tests/conftest.py`

```python
import os, pytest
from app import create_app
from app.extensions import db as _db

@pytest.fixture(scope="session")
def app():
    os.environ["FLASK_ENV"] = "development"
    os.environ["DATABASE_URL"] = "sqlite:///:memory:"
    os.environ["JWT_SECRET_KEY"] = "test-secret"
    app = create_app()
    with app.app_context():
        from app.models import User, Item, Role
        _db.create_all()
        # 기본 테스트 사용자 생성
        u = User(email="u@example.com", name="U", role=Role.USER)
        u.set_password("password123"); _db.session.add(u); _db.session.commit()
    yield app
    # 메모리 데이터베이스라 별도 삭제 불필요

@pytest.fixture()
def client(app):
    return app.test_client()
```

### `tests/test_auth.py`

```python
def test_register_login_me(client):
    # 회원가입 테스트
    r = client.post("/api/auth/register", json={
        "email":"a@example.com","name":"Alice","password":"password123"
    })
    assert r.status_code == 201
    # 로그인 테스트
    r = client.post("/api/auth/login", json={"email":"a@example.com","password":"password123"})
    assert r.status_code == 200
    data = r.get_json()
    assert "access_token" in data
    token = data["access_token"]
    # 사용자 정보 조회 테스트
    r = client.get("/api/auth/me", headers={"Authorization": f"Bearer {token}"})
    assert r.status_code == 200
    me = r.get_json()
    assert me["email"] == "a@example.com"
```

### `tests/test_items.py`

```python
def _login(client, email="u@example.com", password="password123"):
    r = client.post("/api/auth/login", json={"email": email, "password": password})
    assert r.status_code == 200
    return r.get_json()["access_token"]

def test_items_crud_and_pagination(client):
    token = _login(client)
    # 아이템 생성
    r = client.post("/api/items", json={"title":"Book","content":"Nice","price":1200},
                    headers={"Authorization": f"Bearer {token}"})
    assert r.status_code == 201
    item = r.get_json()
    item_id = item["id"]

    # 아이템 목록 조회
    r = client.get("/api/items?per_page=2&sort=-price")
    assert r.status_code == 200
    lst = r.get_json()
    assert "items" in lst and "meta" in lst

    # 단일 아이템 조회
    r = client.get(f"/api/items/{item_id}")
    assert r.status_code == 200

    # 아이템 수정 (소유자만 가능)
    r = client.patch(f"/api/items/{item_id}", json={"price": 1500},
                     headers={"Authorization": f"Bearer {token}"})
    assert r.status_code == 200
    assert r.get_json()["price"] == 1500

    # 아이템 삭제
    r = client.delete(f"/api/items/{item_id}", headers={"Authorization": f"Bearer {token}"})
    assert r.status_code == 204

def test_protected_requires_token(client):
    r = client.post("/api/items", json={"title":"X","price":1})
    assert r.status_code in (401, 422)  # JWT 토큰 없음
```

### 코드 커버리지 측정

```bash
coverage run -m pytest -q
coverage report -m
```

## 보안 및 운영 체크포인트

- **JWT 비밀키**는 환경변수 또는 시크릿 매니저에서 주입(코드 저장소 커밋 금지)
- **액세스 토큰 짧은 유효기간 + 리프레시 토큰 로테이션** 적용(실제 서비스에서는 리프레시 토큰 블랙리스트 테이블로 재사용 차단)
- **레이트 리미팅** 적용(로그인, 쓰기 작업 경로에 강화)
- **CORS**: 프런트엔드 오리진만 명시, `credentials=true` 시 `Allow-Origin` 와일드카드 사용 금지
- **에러 포맷** 일관성 유지 → 클라이언트 에러 처리 단순화
- **마이그레이션 전략**: 추가 우선(Additive-first), 대용량 작업은 트래픽 적은 시간대/청크 단위 처리

## 응답 예시

- **로그인 성공** `POST /api/auth/login` → `200`:
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR...snip",
  "token_type": "Bearer",
  "expires_in": 900,
  "refresh_expires_in": 1209600,
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6Ikp...snip"
}
```

- **아이템 목록** `GET /api/items?per_page=2&sort=-created_at` → `200`:
```json
{
  "items": [
    {"id": 42, "title": "Item 42", "content": "content 42", "price": 1042, "owner_id": 1, "created_at": "...", "updated_at": null},
    {"id": 41, "title": "Item 41", "content": "content 41", "price": 1041, "owner_id": 1, "created_at": "...", "updated_at": null}
  ],
  "meta": {"page": 1, "per_page": 2, "total": 40, "pages": 20}
}
```

- **검증 실패** → `400`:
```json
{"error":{"type":"validation_error","message":"Validation failed","detail":{"price":["Must be greater than or equal to 0."]}}}
```

## 고급 기능 확장 옵션

- **API 버저닝**: `/api/v1/items` 형식으로 블루프린트에 버전 접두사 사용, 추후 `/api/v2` 병행 운영
- **필드 선택**: `?fields=id,title,price` → 스키마 후처리로 필드 필터링
- **정렬 화이트리스트**: 허용 컬럼 매핑 테이블로 안전한 정렬 구현

```python
ALLOWED_SORTS = {"title": "title", "price": "price", "created_at": "created_at"}
def safe_sort(sort):
    if not sort: return None
    sign = "-" if sort.startswith("-") else ""
    key = sort.lstrip("+-")
    if key not in ALLOWED_SORTS: return None
    return sign + ALLOWED_SORTS[key]
```

## CI/CD 파이프라인 예시(GitHub Actions)

```yaml
# .github/workflows/api.yml

name: api
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      - run: pip install -r requirements.txt
      - run: coverage run -m pytest -q
      - run: coverage report -m
```

## 추가 확장 아이디어

- **Swagger 문서에 예제(example)와 다양한 응답 케이스(에러 포함) 추가**
- **역할 기반 세분화 권한 시스템**(소유자/관리자/스태프 구분)
- **고급 검색 기능**(Meilisearch/Elasticsearch 연동)
- **파일 업로드 API**(사전 서명된 URL, 13장 참조)
- **관측성과 로깅**(11장), **캐싱과 성능 최적화**(10장), **배포 파이프라인**(16장) 연동

## 결론

이 프로젝트는 **JWT 인증, Swagger 문서 자동 생성, 포괄적인 테스트**를 갖춘 **실전용 REST API 서버 템플릿**을 제공합니다. `flask-smorest`를 활용하여 **OpenAPI 3 자동 문서화**와 **스키마 기반 검증**을 구현하고, `Flask-JWT-Extended`로 **액세스/리프레시 토큰 및 로테이션** 흐름을 구성했습니다. 또한 `pytest`를 통해 **핵심 비즈니스 플로우(회원가입/로그인/CRUD/페이지네이션)** 를 자동화된 테스트로 검증하는 완전한 개발 생태계를 구축했습니다.

이 템플릿은 프로덕션 환경에 바로 적용 가능한 기반을 제공하면서도, 팀의 특정 요구사항에 맞게 쉽게 확장하고 커스터마이징할 수 있는 유연성을 갖추고 있습니다. 현대적인 웹 API 개발의 모범 사례를 따르며, 개발자 경험과 최종 사용자 경험 모두를 고려한 설계를 지향합니다.