---
layout: post
title: flask - 예제 프로젝트 (2) REST API 서버
date: 2025-09-26 15:25:23 +0900
category: flask
---
# 예제 프로젝트 (2) REST API 서버: JWT + Swagger(OpenAPI) + 테스트

> 이 예제는 **Flask 기반 REST API 서버**를 처음부터 끝까지 구현한다.  
> 포함 기능: **JWT 인증(Access/Refresh/로테이션)**, **역할별 권한(RBAC)**, **Swagger UI(OpenAPI 3.0 문서)**, **요청·응답 스키마 검증(Marshmallow)**, **페이지네이션/정렬/검색**(표준 쿼리 파라미터), **일관 에러 포맷**, **pytest 기반 단위/통합 테스트 + 커버리지**, **샘플 CI**.  
> 모든 코드는 ``` 코드 블록 ``` 으로 감싸고, 본 문서는 긴 분량의 참고서로서 “붙여넣기-가능”한 스캐폴딩을 제공한다.

---

## 0. 목표 아키텍처 & 스택

- **Flask 3.x**
- **flask-smorest**: OpenAPI 3 + 요청·응답 검증 + Swagger UI 제공
- **Marshmallow**: DTO/스키마
- **Flask-JWT-Extended**: JWT(AT/RT) 인증
- **Flask-SQLAlchemy** + **Flask-Migrate(Alembic)**
- **pytest** + **coverage** (+ **httpx** 또는 기본 test client)
- 선택: **Flask-Limiter**(레이트 리미팅), **Flask-CORS**

---

## 1. 디렉터리 레이아웃

```
rest_api_demo/
├─ .env
├─ requirements.txt
├─ wsgi.py
├─ config.py
├─ app/
│  ├─ __init__.py
│  ├─ extensions.py
│  ├─ models.py
│  ├─ schemas.py
│  ├─ errors.py
│  ├─ auth/
│  │  └─ routes.py
│  ├─ items/
│  │  └─ routes.py
│  ├─ utils/
│  │  └─ pagination.py
│  └─ cli.py
├─ migrations/          # (flask db init 후 생성)
└─ tests/
   ├─ conftest.py
   ├─ test_auth.py
   └─ test_items.py
```

---

## 2. 의존성

### 2.1 `requirements.txt`

```txt
Flask==3.0.3
flask-smorest==0.43.0
marshmallow==3.22.0
Flask-SQLAlchemy==3.1.1
Flask-Migrate==4.0.7
Flask-JWT-Extended==4.6.0
email-validator==2.2.0

pytest==8.3.2
coverage==7.6.1
httpx==0.27.2
Werkzeug==3.0.4
python-dotenv==1.0.1

Flask-Limiter==3.8.0     # (선택) 레이트 리미팅
Flask-CORS==4.0.1        # (선택) CORS
```

### 2.2 `.env` (개발)

```env
FLASK_APP=wsgi:app
FLASK_ENV=development
SECRET_KEY=dev-secret-change-me
JWT_SECRET_KEY=dev-jwt-secret-change-me
DATABASE_URL=sqlite:///dev.db
API_TITLE=REST API Demo
API_VERSION=1.0.0
```

---

## 3. 설정 & 앱 팩토리

### 3.1 `config.py`

```python
import os

class BaseConfig:
    SECRET_KEY = os.getenv("SECRET_KEY", "change-me")
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL", "sqlite:///app.db")
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    API_TITLE = os.getenv("API_TITLE", "REST API")
    API_VERSION = os.getenv("API_VERSION", "1.0.0")
    OPENAPI_VERSION = "3.0.3"
    OPENAPI_URL_PREFIX = "/docs"
    OPENAPI_SWAGGER_UI_PATH = "/"
    OPENAPI_SWAGGER_UI_URL = "https://cdn.jsdelivr.net/npm/swagger-ui-dist/"

    JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "change-me")
    JWT_ACCESS_TOKEN_EXPIRES = 900     # 15m
    JWT_REFRESH_TOKEN_EXPIRES = 1209600 # 14d

    # (선택) CORS
    CORS_ORIGINS = os.getenv("CORS_ORIGINS", "").split(",") if os.getenv("CORS_ORIGINS") else []

class DevelopmentConfig(BaseConfig):
    DEBUG = True

class ProductionConfig(BaseConfig):
    DEBUG = False

def get_config():
    env = os.getenv("FLASK_ENV", "production").lower()
    return DevelopmentConfig if env.startswith("dev") else ProductionConfig
```

### 3.2 `app/extensions.py`

```python
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_smorest import Api
from flask_jwt_extended import JWTManager
from flask_cors import CORS
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

db = SQLAlchemy(session_options={"autoflush": False, "expire_on_commit": False})
migrate = Migrate()
api = Api()
jwt = JWTManager()
cors = CORS()
limiter = Limiter(key_func=get_remote_address, default_limits=["200/minute"])
```

### 3.3 `app/__init__.py`

```python
from flask import Flask
from .extensions import db, migrate, api, jwt, cors, limiter
from .errors import register_error_handlers

def create_app():
    from config import get_config
    app = Flask(__name__)
    app.config.from_object(get_config())

    db.init_app(app)
    migrate.init_app(app, db)
    api.init_app(app)
    jwt.init_app(app)
    register_error_handlers(app)

    # Swagger 문서 메타
    api.spec.components.security_scheme(
        "BearerAuth", {"type": "http", "scheme": "bearer", "bearerFormat": "JWT"}
    )
    api.spec.options["info"]["description"] = "JWT 인증 기반 REST API 예제"

    # (선택) CORS
    if app.config.get("CORS_ORIGINS"):
        cors.init_app(app, resources={r"/api/*": {"origins": app.config["CORS_ORIGINS"]}}, supports_credentials=True)

    # (선택) 레이트 리미팅
    limiter.init_app(app)

    # 블루프린트 등록
    from .auth.routes import blp as auth_blp
    from .items.routes import blp as items_blp
    api.register_blueprint(auth_blp)
    api.register_blueprint(items_blp)

    # shell context
    @app.shell_context_processor
    def _ctx():
        from .models import User, Item
        return {"db": db, "User": User, "Item": Item}

    return app
```

### 3.4 `wsgi.py`

```python
from app import create_app
app = create_app()

if __name__ == "__main__":
    app.run()
```

---

## 4. 모델 & 마이그레이션

### 4.1 `app/models.py`

```python
from datetime import datetime, timezone
from werkzeug.security import generate_password_hash, check_password_hash
from .extensions import db

def utcnow():
    return datetime.now(timezone.utc)

class Role:
    USER = "user"
    ADMIN = "admin"

class User(db.Model):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True, index=True, nullable=False)
    name = db.Column(db.String(120), nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    role = db.Column(db.String(20), default=Role.USER, index=True)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime(timezone=True), default=utcnow)

    def set_password(self, raw: str):
        self.password_hash = generate_password_hash(raw)

    def check_password(self, raw: str) -> bool:
        return check_password_hash(self.password_hash, raw)

class Item(db.Model):
    __tablename__ = "items"
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False, index=True)
    content = db.Column(db.Text, nullable=True)
    price = db.Column(db.Integer, nullable=False, default=0)  # cents/원 단위 예시
    created_at = db.Column(db.DateTime(timezone=True), default=utcnow, index=True)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=utcnow)
    owner_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False)

    owner = db.relationship("User", backref="items")
```

### 4.2 마이그레이션 준비

```bash
pip install -r requirements.txt

flask db init
flask db migrate -m "init tables"
flask db upgrade
```

---

## 5. 스키마(DTO) & 유틸

### 5.1 `app/schemas.py`

```python
from marshmallow import Schema, fields, validate, EXCLUDE

class PaginatedIn(Schema):
    class Meta: unknown = EXCLUDE
    page = fields.Int(load_default=1, validate=validate.Range(min=1))
    per_page = fields.Int(load_default=10, validate=validate.Range(min=1, max=100))
    q = fields.Str(load_default=None)
    sort = fields.Str(load_default="-created_at")  # e.g. "title", "-price"

class UserRegisterIn(Schema):
    email = fields.Email(required=True)
    name = fields.Str(required=True, validate=validate.Length(min=1, max=120))
    password = fields.Str(required=True, load_only=True, validate=validate.Length(min=8, max=128))

class UserOut(Schema):
    id = fields.Int()
    email = fields.Email()
    name = fields.Str()
    role = fields.Str()
    created_at = fields.DateTime()

class LoginIn(Schema):
    email = fields.Email(required=True)
    password = fields.Str(required=True, load_only=True)

class TokenOut(Schema):
    access_token = fields.Str()
    token_type = fields.Str(load_default="Bearer")
    expires_in = fields.Int()
    refresh_expires_in = fields.Int()
    refresh_token = fields.Str(load_only=True)

class ItemCreateIn(Schema):
    title = fields.Str(required=True, validate=validate.Length(min=1, max=200))
    content = fields.Str(load_default=None)
    price = fields.Int(required=True, validate=validate.Range(min=0))

class ItemUpdateIn(Schema):
    title = fields.Str(validate=validate.Length(min=1, max=200))
    content = fields.Str()
    price = fields.Int(validate=validate.Range(min=0))

class ItemOut(Schema):
    id = fields.Int()
    title = fields.Str()
    content = fields.Str(allow_none=True)
    price = fields.Int()
    owner_id = fields.Int()
    created_at = fields.DateTime()
    updated_at = fields.DateTime(allow_none=True)

class PageMeta(Schema):
    page = fields.Int()
    per_page = fields.Int()
    total = fields.Int()
    pages = fields.Int()

class ItemListOut(Schema):
    items = fields.List(fields.Nested(ItemOut))
    meta = fields.Nested(PageMeta)
```

### 5.2 `app/utils/pagination.py`

```python
from sqlalchemy import desc, asc

def apply_sort(query, model, sort: str | None):
    if not sort: return query
    name = sort.lstrip("+-")
    col = getattr(model, name, None)
    if not col: return query
    order = desc(col) if sort.startswith("-") else asc(col)
    return query.order_by(order)

def page_to_dict(pagination):
    return {
        "items": pagination.items,
        "meta": {
            "page": pagination.page,
            "per_page": pagination.per_page,
            "total": pagination.total,
            "pages": pagination.pages,
        },
    }
```

---

## 6. 에러 포맷 & 공통 처리

### 6.1 표준 에러 포맷

- 모든 API 에러는 다음 JSON 형식을 유지한다:

```json
{
  "error": {
    "type": "validation_error",
    "message": "Invalid field",
    "detail": {"field": "email", "reason": "already exists"}
  }
}
```

### 6.2 `app/errors.py`

```python
from flask import jsonify
from marshmallow import ValidationError
from werkzeug.exceptions import HTTPException

def _err(type_, message, status=400, detail=None):
    payload = {"error": {"type": type_, "message": message}}
    if detail is not None:
        payload["error"]["detail"] = detail
    return jsonify(payload), status

def register_error_handlers(app):
    @app.errorhandler(ValidationError)
    def _handle_validation(e):
        return _err("validation_error", "Validation failed", 400, e.messages)

    @app.errorhandler(HTTPException)
    def _handle_http(e: HTTPException):
        msg = e.description if isinstance(e.description, str) else str(e)
        return _err("http_error", msg, e.code or 500)

    @app.errorhandler(Exception)
    def _handle_unexpected(e: Exception):
        app.logger.exception("Unhandled error")
        return _err("internal_error", "Unexpected error", 500)
```

---

## 7. 인증 라우트(JWT)

### 7.1 설계 요약

- **Access Token**(AT) 15분, **Refresh Token**(RT) 14일 (둘 다 HS256; DEMO)
- 로그인 시: AT + RT(응답 바디에 포함). 실서비스에선 **RT는 HttpOnly 쿠키** 권장.
- **토큰 로테이션**: `/auth/refresh` 호출 시 새 AT, 새 RT 발급. (예제는 간단 구현)

### 7.2 `app/auth/routes.py`

```python
from flask import Blueprint
from flask_smorest import Blueprint as SmorestBlueprint, abort
from flask.views import MethodView
from flask_jwt_extended import (
    create_access_token, create_refresh_token, jwt_required, get_jwt_identity
)
from ..extensions import db, limiter
from ..models import User, Role
from ..schemas import UserRegisterIn, UserOut, LoginIn, TokenOut

blp = SmorestBlueprint("auth", "auth", url_prefix="/api/auth", description="인증/토큰 API")

@blp.route("/register")
class Register(MethodView):
    @blp.arguments(UserRegisterIn)
    @blp.response(201, UserOut)
    @limiter.limit("5/minute")
    def post(self, data):
        if User.query.filter_by(email=data["email"].lower()).first():
            abort(409, message="email already exists")
        u = User(email=data["email"].lower(), name=data["name"])
        u.set_password(data["password"])
        db.session.add(u); db.session.commit()
        return u

@blp.route("/login")
class Login(MethodView):
    @blp.arguments(LoginIn)
    @blp.response(200, TokenOut)
    @limiter.limit("20/minute")
    def post(self, data):
        u = User.query.filter_by(email=data["email"].lower()).first()
        if not u or not u.check_password(data["password"]):
            abort(401, message="invalid credentials")
        if not u.is_active:
            abort(403, message="inactive user")
        access = create_access_token(identity=str(u.id), additional_claims={"role": u.role})
        refresh = create_refresh_token(identity=str(u.id))
        from flask import current_app
        return {
            "access_token": access,
            "token_type": "Bearer",
            "expires_in": current_app.config["JWT_ACCESS_TOKEN_EXPIRES"],
            "refresh_expires_in": current_app.config["JWT_REFRESH_TOKEN_EXPIRES"],
            "refresh_token": refresh,
        }

@blp.route("/me")
class Me(MethodView):
    @jwt_required()
    @blp.response(200, UserOut)
    def get(self):
        uid = int(get_jwt_identity())
        u = User.query.get_or_404(uid)
        return u

@blp.route("/refresh")
class Refresh(MethodView):
    @jwt_required(refresh=True)
    @blp.response(200, TokenOut)
    def post(self):
        uid = get_jwt_identity()
        u = User.query.get(uid)
        if not u or not u.is_active:
            abort(403, message="user not allowed")
        access = create_access_token(identity=str(u.id), additional_claims={"role": u.role})
        refresh = create_refresh_token(identity=str(u.id))  # 토큰 로테이션
        from flask import current_app
        return {
            "access_token": access,
            "token_type": "Bearer",
            "expires_in": current_app.config["JWT_ACCESS_TOKEN_EXPIRES"],
            "refresh_expires_in": current_app.config["JWT_REFRESH_TOKEN_EXPIRES"],
            "refresh_token": refresh,
        }
```

> Swagger에서 “Authorize” 버튼을 누르고 `Bearer <access_token>` 형식으로 토큰을 입력하면 보호된 엔드포인트를 테스트할 수 있다.

---

## 8. 도메인 라우트(Items)

### 8.1 권한 유틸

```python
# 간단 RBAC 유틸 (필요 시 확장)
from flask_jwt_extended import verify_jwt_in_request, get_jwt
from flask_smorest import abort

def require_role(*roles):
    verify_jwt_in_request()
    claims = get_jwt()
    role = claims.get("role")
    if role not in roles:
        abort(403, message="insufficient role")
```

### 8.2 `app/items/routes.py`

```python
from flask_smorest import Blueprint
from flask.views import MethodView
from flask_jwt_extended import jwt_required, get_jwt_identity
from sqlalchemy import or_
from ..extensions import db, limiter
from ..models import Item, User, Role
from ..schemas import (
    ItemCreateIn, ItemUpdateIn, ItemOut, ItemListOut, PaginatedIn
)
from ..utils.pagination import apply_sort, page_to_dict
from .rbac import require_role if False else lambda *a, **k: None  # (예제 단순화)

blp = Blueprint("items", "items", url_prefix="/api/items", description="아이템 CRUD API")

@blp.route("")
class Items(MethodView):
    @blp.arguments(PaginatedIn, location="query")
    @blp.response(200, ItemListOut)
    def get(self, args):
        """목록(검색/정렬/페이지네이션)"""
        page = args["page"]; per = args["per_page"]
        qstr = args.get("q")
        sort = args.get("sort", "-created_at")

        query = Item.query
        if qstr:
            like = f"%{qstr}%"
            query = query.filter(or_(Item.title.ilike(like), Item.content.ilike(like)))

        query = apply_sort(query, Item, sort)
        pagination = query.paginate(page=page, per_page=per, error_out=False)
        return page_to_dict(pagination)

    @jwt_required()
    @blp.arguments(ItemCreateIn)
    @blp.response(201, ItemOut)
    @limiter.limit("60/minute")
    def post(self, data):
        """생성(로그인 필요)"""
        uid = int(get_jwt_identity())
        item = Item(owner_id=uid, **data)
        db.session.add(item); db.session.commit()
        return item

@blp.route("/<int:item_id>")
class ItemDetail(MethodView):
    @blp.response(200, ItemOut)
    def get(self, item_id):
        return Item.query.get_or_404(item_id)

    @jwt_required()
    @blp.arguments(ItemUpdateIn)
    @blp.response(200, ItemOut)
    def patch(self, data, item_id):
        uid = int(get_jwt_identity())
        item = Item.query.get_or_404(item_id)
        if item.owner_id != uid:
            blp.abort(403, message="only owner can modify")
        for k, v in data.items():
            setattr(item, k, v)
        db.session.commit()
        return item

    @jwt_required()
    @blp.response(204)
    def delete(self, item_id):
        uid = int(get_jwt_identity())
        item = Item.query.get_or_404(item_id)
        # ADMIN 은 무조건, 일반은 소유자만 삭제
        from flask_jwt_extended import get_jwt
        role = (get_jwt() or {}).get("role")
        if not (item.owner_id == uid or role == Role.ADMIN):
            blp.abort(403, message="not allowed")
        db.session.delete(item); db.session.commit()
        return ""
```

---

## 9. 문서화(Swagger/OpenAPI)

- 서버 실행 후 **Swagger UI**: `http://127.0.0.1:5000/docs/`
- `app/__init__.py`에서 등록된 `api.register_blueprint`들이 스키마를 자동 수집한다.
- 인증 필요 엔드포인트에 보안 스키마 적용(간명화 위해 전역은 생략했지만, 아래처럼 가능)

```python
# 각 메서드 docstring 또는 @blp.doc 으로 보안 스키마 지정 가능
@blp.doc(security=[{"BearerAuth": []}])
@jwt_required()
def get(...):
    ...
```

---

## 10. CLI(시드/관리자 생성)

### 10.1 `app/cli.py`

```python
import click
from .extensions import db
from .models import User, Role, Item

def init_cli(app):
    @app.cli.command("create-user")
    @click.option("--email", prompt=True)
    @click.option("--name", prompt=True)
    @click.option("--password", prompt=True, hide_input=True, confirmation_prompt=True)
    @click.option("--admin", is_flag=True, help="관리자 권한")
    def create_user(email, name, password, admin):
        if User.query.filter_by(email=email.lower()).first():
            click.echo("이미 존재하는 이메일")
            raise SystemExit(1)
        u = User(email=email.lower(), name=name, role=(Role.ADMIN if admin else Role.USER))
        u.set_password(password)
        db.session.add(u); db.session.commit()
        click.echo(f"created user {u.id} {u.email}")

    @app.cli.command("seed-items")
    @click.option("--count", type=int, default=30)
    def seed_items(count):
        u = User.query.first()
        if not u:
            click.echo("먼저 사용자 생성 필요: flask create-user")
            raise SystemExit(1)
        for i in range(count):
            db.session.add(Item(title=f"Item {i+1}", content=f"content {i+1}", price=1000 + i, owner_id=u.id))
        db.session.commit()
        click.echo(f"seeded {count} items")
```

`app/__init__.py`에서 `from . import cli; cli.init_cli(app)` 호출을 잊지 말자.

---

## 11. 실행

```bash
flask run          # http://127.0.0.1:5000

# 최초 사용자/시드
flask create-user --email admin@example.com --name Admin --admin
flask seed-items --count 40
```

- Swagger 문서: `GET /docs/`
- 로그인: `POST /api/auth/login` → Bearer 토큰 획득 → Swagger 상단 Authorize → Bearer 입력

---

## 12. 테스트(단위/통합)

### 12.1 `tests/conftest.py`

```python
import os, pytest
from app import create_app
from app.extensions import db as _db

@pytest.fixture(scope="session")
def app():
    os.environ["FLASK_ENV"] = "development"
    os.environ["DATABASE_URL"] = "sqlite:///:memory:"
    os.environ["JWT_SECRET_KEY"] = "test-secret"
    app = create_app()
    with app.app_context():
        from app.models import User, Item, Role
        _db.create_all()
        # 기본 유저
        u = User(email="u@example.com", name="U", role=Role.USER)
        u.set_password("password123"); _db.session.add(u); _db.session.commit()
    yield app
    # 메모리라 별도 drop 불필요

@pytest.fixture()
def client(app):
    return app.test_client()
```

### 12.2 `tests/test_auth.py`

```python
def test_register_login_me(client):
    # register
    r = client.post("/api/auth/register", json={
        "email":"a@example.com","name":"Alice","password":"password123"
    })
    assert r.status_code == 201
    # login
    r = client.post("/api/auth/login", json={"email":"a@example.com","password":"password123"})
    assert r.status_code == 200
    data = r.get_json()
    assert "access_token" in data
    token = data["access_token"]
    # me
    r = client.get("/api/auth/me", headers={"Authorization": f"Bearer {token}"})
    assert r.status_code == 200
    me = r.get_json()
    assert me["email"] == "a@example.com"
```

### 12.3 `tests/test_items.py`

```python
def _login(client, email="u@example.com", password="password123"):
    r = client.post("/api/auth/login", json={"email": email, "password": password})
    assert r.status_code == 200
    return r.get_json()["access_token"]

def test_items_crud_and_pagination(client):
    token = _login(client)
    # create
    r = client.post("/api/items", json={"title":"Book","content":"Nice","price":1200},
                    headers={"Authorization": f"Bearer {token}"})
    assert r.status_code == 201
    item = r.get_json()
    item_id = item["id"]

    # list
    r = client.get("/api/items?per_page=2&sort=-price")
    assert r.status_code == 200
    lst = r.get_json()
    assert "items" in lst and "meta" in lst

    # get
    r = client.get(f"/api/items/{item_id}")
    assert r.status_code == 200

    # patch (owner only)
    r = client.patch(f"/api/items/{item_id}", json={"price": 1500},
                     headers={"Authorization": f"Bearer {token}"})
    assert r.status_code == 200
    assert r.get_json()["price"] == 1500

    # delete
    r = client.delete(f"/api/items/{item_id}", headers={"Authorization": f"Bearer {token}"})
    assert r.status_code == 204

def test_protected_requires_token(client):
    r = client.post("/api/items", json={"title":"X","price":1})
    assert r.status_code in (401, 422)  # jwt 미포함
```

### 12.4 커버리지

```bash
coverage run -m pytest -q
coverage report -m
```

---

## 13. 보안·운영 체크포인트

- **JWT 비밀키**는 환경변수/시크릿 매니저에서 주입(코드 커밋 금지)
- **AT 짧게 + RT 로테이션**(본 예제는 간단 구현, 실서비스는 RT 블랙리스트 테이블로 재사용 차단)
- **레이트 리미팅**(로그인, 쓰기 경로에 강화)
- **CORS**: 프런트 오리진만 명시, `credentials=true` 시 `Allow-Origin` 와일드카드 금지
- **에러 포맷** 일관성 유지 → 클라이언트 처리 단순화
- **마이그레이션 전략**: Additive-first, 대용량 작업은 오프피크/청크

---

## 14. 응답 예시 모음

- **로그인 성공** `POST /api/auth/login` → `200`:
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR...snip",
  "token_type": "Bearer",
  "expires_in": 900,
  "refresh_expires_in": 1209600,
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6Ikp...snip"
}
```

- **목록** `GET /api/items?per_page=2&sort=-created_at` → `200`:
```json
{
  "items": [
    {"id": 42, "title": "Item 42", "content": "content 42", "price": 1042, "owner_id": 1, "created_at": "...", "updated_at": null},
    {"id": 41, "title": "Item 41", "content": "content 41", "price": 1041, "owner_id": 1, "created_at": "...", "updated_at": null}
  ],
  "meta": {"page": 1, "per_page": 2, "total": 40, "pages": 20}
}
```

- **검증 실패** → `400`:
```json
{"error":{"type":"validation_error","message":"Validation failed","detail":{"price":["Must be greater than or equal to 0."]}}}
```

---

## 15. 옵션: 버저닝, 필드 선택, 정렬 화이트리스트

- **버전 경로**: `/api/v1/items` 처럼 블루프린트에 버전 prefix 를 두고, 추후 `/api/v2` 병행 운영
- **필드 선택**: `?fields=id,title,price` → 스키마 후처리로 필터
- **정렬 화이트리스트**: 허용 컬럼 매핑 테이블로 안전하게

```python
ALLOWED_SORTS = {"title": "title", "price": "price", "created_at": "created_at"}
def safe_sort(sort):
    if not sort: return None
    sign = "-" if sort.startswith("-") else ""
    key = sort.lstrip("+-")
    if key not in ALLOWED_SORTS: return None
    return sign + ALLOWED_SORTS[key]
```

---

## 16. 간단 CI 예시(GitHub Actions)

```yaml
# .github/workflows/api.yml
name: api
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      - run: pip install -r requirements.txt
      - run: coverage run -m pytest -q
      - run: coverage report -m
```

---

## 17. 확장 아이디어

- **Swagger 문서에 예제(example)와 응답 케이스(에러 포함) 추가**
- **Role 기반 세분화 권한**(소유자/관리자/스태프)
- **검색 고도화**(Meilisearch/Elasticsearch)
- **파일 업로드 API**(사전서명 URL, 13장 참조)
- **관측/로깅**(11장), **캐싱/퍼포먼스**(10장), **배포 파이프라인**(16장) 연동

---

## 18. 마무리

이 프로젝트는 **JWT 인증 + Swagger 문서 + 테스트**를 갖춘 **실전형 REST API** 스캐폴딩이다.  
- `flask-smorest`로 **OpenAPI 3 자동 문서화**와 **스키마 기반 검증**을 얻고,  
- `Flask-JWT-Extended`로 **AT/RT & 로테이션** 흐름을 구성했으며,  
- `pytest`로 **핵심 플로우(가입/로그인/CRUD/페이지네이션)** 를 자동 검증했다.  
