---
layout: post
title: 이산수학 - 그래프 채색
date: 2025-06-29 23:20:23 +0900
category: 이산수학
---
# 그래프 채색(Graph Coloring)

## 한눈에 보기

- **정점 채색**: 인접 정점이 서로 다른 색. 최소 색 수가 **색칠수** \( \chi(G) \).
- **경계**: \( \omega(G) \le \chi(G) \le \Delta(G)+1 \)
  (클리크 수 ≥, 최대 차수 + 1 ≤).
- **브룩스 정리**: \(G\)가 완전 그래프도, 홀수 사이클도 아니면 \( \chi(G)\le \Delta(G) \).
- **평면 그래프**: 4색으로 충분(4색 정리), Greedy로 6색, 약간 더 공들여 5색.
- **이분 그래프**: \(\chi(G)=2\) (비어 있지 않다면).
- **간선 채색**: 이분 그래프는 \( \chi'(G)=\Delta(G) \) (Kőnig), 일반 그래프는 \( \Delta \) 또는 \( \Delta+1 \) (Vizing).
- **알고리즘**: 그리디/순차 휴리스틱, Welsh–Powell, **DSATUR**, 정확해법(분기한정), 특수 그래프 최적(코달).

---

## 정의와 예시

### 정점 채색 (Vertex Coloring)

그래프 \( G=(V,E) \)에서 **모든 간선** \(uv\in E\)에 대해 서로 다른 색:
$$
\forall (u,v)\in E:\ \text{color}(u)\ne \text{color}(v).
$$
최소 색 수 \( \chi(G) \)를 **색칠수**라 함.

**기본 예시**
- 트리(정점 ≥2): \( \chi(G)=2 \) (이분 그래프)
- **완전 그래프** \(K_n\): \( \chi(K_n)=n \)
- **사이클** \(C_n\): 짝수 2색, 홀수 3색

---

## 경계·정리·특수 그래프

### 필수 경계

클리크 수 \(\omega(G)\)와 최대 차수 \(\Delta(G)\):
$$
\omega(G) \le \chi(G) \le \Delta(G)+1.
$$
상한은 단순 그리디로 증명 가능(정점 하나씩, 이미 쓰인 색 제외).

### 브룩스 정리 (Brooks)

연결 단순 그래프 \(G\)가 \(K_n\)도 **아니고**, 홀수 사이클도 아니면
$$
\chi(G)\le \Delta(G).
$$
> 예외: \(K_n\)는 \(\chi=n\), 홀수 사이클은 \(\chi=3\)인데 \(\Delta=2\).

### 평면 그래프

- **4색 정리**: 임의의 평면 그래프는 \(\chi(G)\le 4\).
- **6색 정리**: 단순한 귀납+Greedy로 \(\le 6\).
- **5색 정리**: 조금 더 정교한 귀납(켐프 체인).
- (보너스) **Grötzsch 정리**: 삼각형 없는 평면 그래프는 3색.

### 완벽(perfect)·코달(chordal) 그래프

- **코달 그래프**(모든 길이 ≥4 사이클이 현으로 분해): **완벽** →
  $$\chi(G)=\omega(G)$$
  **완벽 제거 순서(PEO)**를 찾으면 Greedy가 최적.

---

## 채색 알고리즘 (정점)

### 그리디(임의 순서)

간단·빠름·**최적 아님**:
```python
def greedy_coloring(graph, order=None):
    """
    graph: {u: set(neigh)}
    order: 방문 순서 (기본=주어진 키 순서)
    return: {u: color_id}
    """
    if order is None:
        order = list(graph.keys())
    color = {}
    for u in order:
        used = {color[v] for v in graph[u] if v in color}
        c = 0
        while c in used: c += 1
        color[u] = c
    return color
```

### Welsh–Powell (차수 내림차순)

차수가 큰 정점부터 그리디:
```python
def welsh_powell(graph):
    order = sorted(graph, key=lambda u: len(graph[u]), reverse=True)
    return greedy_coloring(graph, order)
```

### DSATUR (Brélaz)

**포화도**(인접 색의 서로 다른 개수)가 큰 정점을 우선:
```python
def dsatur_coloring(graph):
    import heapq
    nbh = {u:set(graph[u]) for u in graph}
    color, sat, deg = {}, {u:0 for u in graph}, {u:len(graph[u]) for u in graph}
    # ( -sat[u], -deg[u], tie_id, u ) 최대 힙 흉내
    counter = 0
    def key(u): return (-sat[u], -deg[u], u)
    heap = [(*key(u), u) for u in graph]
    heapq.heapify(heap)
    in_heap = {u:key(u) for u in graph}
    while heap:
        _,_,_,u = heapq.heappop(heap)
        if u in color:  # outdated entry
            continue
        # assign smallest available color
        used = {color[v] for v in nbh[u] if v in color}
        c = 0
        while c in used: c+=1
        color[u]=c
        # update neighbors' saturation
        for v in nbh[u]:
            if v in color: continue
            before = sat[v]
            if c not in {color.get(w) for w in nbh[v] if w in color}:
                sat[v]+=1
            if sat[v]!=before:
                # push new key; lazy deletion
                heapq.heappush(heap, (*key(v), v))
    return color
```
- 보통 그리디보다 색을 덜 쓰고, 많은 실전에서 강력한 휴리스틱.

### 정확해법(분기한정, DSATUR 기반)

작은/중형 그래프에서 **최적 \(\chi(G)\)**를 찾을 때:
1) 상계: DSATUR 결과의 색 수
2) 하계: \(\omega(G)\) (최대 클리크)
3) 분기: 포화도 높은 정점부터 후보 색 시도, **가지치기**.

```python
def max_clique_size(graph):
    # Bron–Kerbosch with pivot (small-medium graphs)
    R=set(); P=set(graph); X=set()
    best=0
    def bronk(R,P,X):
        nonlocal best
        if not P and not X:
            best=max(best,len(R)); return
        # pivot
        u = max(P|X, key=lambda v: len(graph[v])) if P|X else None
        for v in list(P - (graph[u] if u else set())):
            bronk(R|{v}, P & graph[v], X & graph[v])
            P.remove(v); X.add(v)
    bronk(R,P,X); return best

def chromatic_number_exact(graph):
    n = len(graph)
    best_coloring = dsatur_coloring(graph)  # good upper bound
    best = 1 + max(best_coloring.values(), default=-1)
    lower = max_clique_size(graph)

    order = sorted(graph, key=lambda u: len(graph[u]), reverse=True)
    color = {}
    used_colors = 0

    def backtrack(idx):
        nonlocal best, best_coloring, used_colors
        if idx==len(order):
            if used_colors<best:
                best = used_colors
                best_coloring = color.copy()
            return
        # optimistic bound
        if used_colors >= best: return
        u = order[idx]
        # try existing colors first
        forbidden = {color[v] for v in graph[u] if v in color}
        for c in range(used_colors):
            if c not in forbidden:
                color[u]=c
                backtrack(idx+1)
                del color[u]
        # try new color if it can still beat best
        if used_colors+1 < best:
            color[u]=used_colors
            used_colors+=1
            backtrack(idx+1)
            used_colors-=1
            del color[u]

    # quick prune: lower bound
    if lower==best: return best_coloring
    backtrack(0)
    return best_coloring
```

> 팁: 실무에선 **DSATUR + 제한된 재탐색**으로 “거의 최적”을 빠르게 얻는 경우가 많습니다.

---

## 특수 그래프의 빠른 판정·최적 채색

### 이분 그래프(2-색) 판정·채색 (BFS)

```python
from collections import deque

def bipartite_coloring(graph):
    color={}
    for s in graph:
        if s in color: continue
        color[s]=0; q=deque([s])
        while q:
            u=q.popleft()
            for v in graph[u]:
                if v not in color:
                    color[v]=color[u]^1; q.append(v)
                elif color[v]==color[u]:
                    return None  # not bipartite
    return color  # 0/1 두 색
```

### 코달(graph) 최적 채색 (MCS → PEO → Greedy)

```python
def maximum_cardinality_search(graph):
    import heapq
    label={u:0 for u in graph}; visited=set(); order=[]
    # max-heap by label
    heap=[(-0, u) for u in graph]; heapq.heapify(heap)
    in_heap=set(graph)
    while heap:
        neg,u = heapq.heappop(heap)
        if u in visited: continue
        visited.add(u); order.append(u)
        for v in graph[u]:
            if v not in visited:
                label[v]+=1
                heapq.heappush(heap, (-label[v], v))
    return order  # last→first가 PEO 후보

def chordal_optimal_coloring(graph):
    order = maximum_cardinality_search(graph)  # v_n,...,v_1
    color={}
    for u in reversed(order):
        used = {color[v] for v in graph[u] if v in color}
        c=0
        while c in used: c+=1
        color[u]=c
    return color  # perfect graphs → optimal (= clique number)
```

---

## 간선 채색 (Edge Coloring)

- **정의**: 공유 정점이 있는 두 간선이 **같은 색**을 가지지 않도록 간선에 색 배정. 최소 색 수 \(\chi'(G)\).
- **Kőnig’s line coloring (bipartite)**: 이분 그래프는
  $$
  \chi'(G)=\Delta(G).
  $$
- **Vizing 정리(일반 그래프)**: \( \chi'(G)\in\{\Delta,\Delta+1\} \)
  (Class 1 vs Class 2)

### 이분 그래프 간선 채색 — 최대매칭 분해

**매칭** 하나가 **한 색**. 모든 간선을 최대매칭들로 분해 → 색 수 ≤ \(\Delta\).

```python
from collections import deque, defaultdict

def hopcroft_karp(U, V, E):
    # E: dict u -> list of v (u∈U, v∈V)
    INF=10**9
    pairU={u:None for u in U}
    pairV={v:None for v in V}
    dist={}
    adj=defaultdict(list, E)

    def bfs():
        dq=deque()
        for u in U:
            if pairU[u] is None:
                dist[u]=0; dq.append(u)
            else:
                dist[u]=INF
        d=INF
        while dq:
            u=dq.popleft()
            if dist[u]<d:
                for v in adj[u]:
                    pu = pairV[v]
                    if pu is None:
                        d=dist[u]+1
                    elif dist[pu]==INF:
                        dist[pu]=dist[u]+1; dq.append(pu)
        return d!=INF

    def dfs(u):
        for v in adj[u]:
            pu=pairV[v]
            if pu is None or (dist[pu]==dist[u]+1 and dfs(pu)):
                pairU[u]=v; pairV[v]=u
                return True
        dist[u]=INF
        return False

    matching=0
    while bfs():
        for u in U:
            if pairU[u] is None and dfs(u):
                matching+=1
    M=set()
    for u in U:
        if pairU[u] is not None:
            M.add((u,pairU[u]))
    return M

def edge_coloring_bipartite(U, V, edges):
    """
    U, V: bipartition vertex sets
    edges: list of (u,v) with u∈U, v∈V
    return: list of matchings, each matching is set of edges (u,v)
    """
    E=defaultdict(list)
    for u,v in edges: E[u].append(v)
    remaining=set(edges)
    colors=[]
    while remaining:
        # build E' of remaining
        Ep=defaultdict(list)
        for u,v in remaining:
            Ep[u].append(v)
        M = hopcroft_karp(U,V,Ep)
        colors.append(M)
        remaining -= M
    return colors  # len(colors) ≤ Δ
```

> 일반 그래프의 간선 채색은 난해; 실무에선 이분 구조(작업-시간, 송신기-수신기)로 모델링하면 **정확하고 빠른 해**를 얻기 쉽습니다.

---

## 색다항식 & 색 가능한 경우의 수

**색다항식** \(P_G(k)\): \(k\)색으로 올바르게 채색하는 방법 수.
재귀(삭제-축약): \(P_G(k)=P_{G-e}(k)-P_{G/e}(k)\).
여기서는 “주어진 \(k\)에서의 **경우의 수**”만 백트래킹으로 계산:

```python
def count_k_colorings(graph, k):
    order = sorted(graph, key=lambda u: len(graph[u]), reverse=True)
    color={}

    def backtrack(i):
        if i==len(order): return 1
        u = order[i]
        used = {color[v] for v in graph[u] if v in color}
        ways=0
        for c in range(k):
            if c not in used:
                color[u]=c
                ways += backtrack(i+1)
                del color[u]
        return ways
    return backtrack(0)

# 예: C5(홀수 사이클) → P(k)=k(k-1)(k-2)^3 + ...
# 최소 3색, k=3이면 30(방향/회전 포함) 등

```

---

## 변형 채색 & 구조적 상한

- **퇴화도(degeneracy)** \(d\): 모든 부분그래프가 차수 ≤ \(d\)인 정점 보유
  → 항상 \(d{+}1\)색으로 채색 가능(최소차 정점부터 제거 → 역순 그리디).
  ```python
  def degeneracy_order(graph):
      import heapq
      deg = {u:len(graph[u]) for u in graph}
      pq=[(deg[u],u) for u in graph]; heapq.heapify(pq)
      removed=set(); order=[]
      while pq:
          d,u = heapq.heappop(pq)
          if u in removed: continue
          removed.add(u); order.append(u)
          for v in graph[u]:
              if v not in removed:
                  deg[v]-=1
                  heapq.heappush(pq,(deg[v],v))
      return order  # smallest-last
  ```
- **리스트 채색(list coloring)**, **분수 채색(fractional)**, **스타/무사이클 채색** 등 실전 제약에 맞춘 일반화가 존재.

---

## 실전 시나리오

### 시험 시간표(Conflict Graph)

- 과목 = 정점, **같은 학생이 듣는 과목 쌍**에 간선 → 겹치면 안 됨.
- 정점 채색의 색 = **시간 슬롯**.

```python
def build_conflict_graph(enrollments):
    """
    enrollments: dict course -> set of student_id
    """
    courses=list(enrollments)
    g={c:set() for c in courses}
    for i,c1 in enumerate(courses):
        for c2 in courses[i+1:]:
            if enrollments[c1] & enrollments[c2]:
                g[c1].add(c2); g[c2].add(c1)
    return g

# 예시

en = {
  "Algo": {"S1","S2","S3"},
  "DB"  : {"S2","S4"},
  "OS"  : {"S1","S4"},
  "Net" : {"S3","S5"}
}
G = build_conflict_graph(en)
slots = dsatur_coloring(G)      # 더 적은 슬롯을 쓰는 경향
# 검증

def valid_coloring(G, col):
    return all(col[u]!=col[v] for u in G for v in G[u])
```

> 리소스 제한(강의실)까지 고려하면 **리스트 채색**이나 **다중그래프 모델**로 확장 가능.

### 컴파일러: 레지스터 할당(Interference Graph)

- 변수 간 **동시 생존(liveness overlap)** → 간선
- 정점 채색의 색 = **레지스터 번호**
- \(\chi(G)\le R\)이면 스필 없이 할당 가능.

```python
def allocate_registers(interf_graph, R):
    col = dsatur_coloring(interf_graph)
    if 1+max(col.values(), default=-1) <= R:
        return col  # 성공
    # 실패 시 스필 후보: 차수 높거나 빈도 낮은 변수 등 휴리스틱 선택 → 간선/정점 수정 후 반복
    return None
```

### 무선 주파수 할당(Frequency Planning)

- 기지국 = 정점, 간섭 임계치 넘는 쌍 = 간선
- 색 = 채널 번호, 목표는 간섭 최소/채널 수 최소.
- 가중/거리 기반이면 **가중 채색**(soft constraint)로 확장.

---

## 손에 잡히는 예제 그래프

```python
def make_graph(edges):
    g={}
    for u,v in edges:
        g.setdefault(u,set()).add(v)
        g.setdefault(v,set()).add(u)
    for u in list(g):
        g[u]=set(g[u])
    return g

# K3 (삼각형) → χ=3

K3 = make_graph([("A","B"),("B","C"),("C","A")])

# C4 (사각형) → χ=2

C4 = make_graph([(0,1),(1,2),(2,3),(3,0)])

# K3,3 (이분 완전) → χ=2, 간선채색 χ' = Δ = 3

U = {"u1","u2","u3"}; V={"v1","v2","v3"}
K33 = make_graph([(u,v) for u in U for v in V])

print("DSATUR K3:", dsatur_coloring(K3))
print("DSATUR C4:", dsatur_coloring(C4))
print("Bipartite K3,3:", bipartite_coloring(K33))
```

---

## 검증·진단 유틸

```python
def is_proper_coloring(graph, color):
    return all(color.get(u)!=color.get(v) for u in graph for v in graph[u])

def color_count(color):
    return 1+max(color.values(), default=-1)

def summary(graph, method):
    col = method(graph)
    ok  = is_proper_coloring(graph, col)
    return {"colors": color_count(col), "valid": ok, "assignment": col}
```

---

## 자주 묻는 질문(FAQ)

- **Q: 그리디는 항상 최적?**
  A: 아니요(최대 \(\Delta{+}1\) 보장). **DSATUR**가 실전에서 더 낫습니다.
- **Q: 평면 그래프는 항상 4색?**
  A: 예(정리). 하지만 일반적 증명은 복잡—현업에선 5·6색 근거 Greedy로 충분한 경우가 많음.
- **Q: 간선 채색은 정점 채색으로 바꿀 수 있나?**
  A: **선 그래프(line graph)** \(L(G)\)의 정점 채색이 \(G\)의 간선 채색과 동치.
- **Q: 정확 \(\chi(G)\) 계산은 빠른가?**
  A: 일반적으로 **NP-어려움**. 규모가 크면 휴리스틱/상한-하한 결합 전략 권장.

---

## 체크리스트

- [ ] \(\omega,\Delta\) 계산해 **경계** 파악
- [ ] DSATUR/ Welsh–Powell로 **좋은 초기 해**
- [ ] 이분/코달/평면 등 **특수 구조** 활용
- [ ] 필요 시 **정확해법(분기한정)** + 상/하계
- [ ] 간선 채색은 이분이면 **매칭 분해**로 최적
- [ ] 실전 제약(슬롯·자원) → **리스트/가중 채색** 고려

---

## 한 화면 요약

| 주제 | 핵심 |
|---|---|
| 색칠수 | \(\omega \le \chi \le \Delta+1\), (Brooks) 거의 \(\Delta\) |
| 평면 | 4색 정리(이론), 5/6색은 쉬운 알고리즘 |
| 휴리스틱 | DSATUR ≳ Welsh–Powell ≳ 그리디 |
| 정확해법 | 분기한정 + DSATUR 상계 + \(\omega\) 하계 |
| 간선채색 | 이분: \(\chi'=\Delta\); 일반: Vizing(\(\Delta\) or \(\Delta+1\)) |
| 응용 | 시간표·레지스터·주파수·자원 슬롯팅 |
