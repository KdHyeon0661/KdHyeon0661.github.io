---
layout: post
title: Linux - 컨테이너 & 시스템 가상화
date: 2024-11-28 19:20:23 +0900
category: Linux
---
# 컨테이너 & 시스템 가상화

## 개요와 실습 환경 준비

컨테이너와 가상화 기술은 현대 인프라의 핵심 요소로, 서로 다른 수준의 격리와 성능 특성을 제공합니다. 컨테리너는 프로세스 수준의 가벼운 격리를, 가상 머신은 하드웨어 수준의 완전한 격리를 구현합니다.

실습을 위한 기본 패키지 설치 (Debian/Ubuntu 기준):

```bash
# 필수 패키지 설치
sudo apt update
sudo apt install -y debootstrap systemd-container uidmap \
  lxc lxc-templates lxd qemu-kvm libvirt-daemon-system virt-manager \
  bridge-utils uidmap podman docker.io jq curl
```

---

## chroot와 Namespace의 차이: 격리 수준 이해하기

### chroot: 파일 시스템 경로만 변경하는 부분적 격리

chroot는 프로세스의 루트 디렉터리를 변경하여 파일 시스템 접근을 제한하는 기술입니다.

```bash
# 기본 jail 환경 생성
sudo mkdir -p /srv/jail
sudo debootstrap stable /srv/jail http://deb.debian.org/debian

# chroot 환경 진입
sudo chroot /srv/jail /bin/bash
```

**chroot의 특징**:
- 파일 시스템 경로만 격리됩니다.
- PID, 네트워크, 호스트명, 사용자 정보는 호스트와 공유됩니다.
- `CAP_SYS_CHROOT` 권한이 있으면 탈출 가능성이 있어 보안 격리 용도로는 부적합합니다.
- 주로 시스템 복구, 패키지 빌드, 디버깅에 유용하게 사용됩니다.

### Namespace: 리소스별 완전한 격리 구현

Linux Namespace는 시스템 리소스를 완전히 격리된 공간으로 분리하는 기술입니다.

| Namespace 유형 | 격리 대상 | 주요 용도 |
|---|---|---|
| `mnt` | 마운트 포인트와 파일 시스템 뷰 | 파일 시스템 격리 |
| `pid` | 프로세스 ID 공간 | 독립적인 프로세스 트리 |
| `net` | 네트워크 인터페이스, 라우팅, 포트 | 독립 네트워크 스택 |
| `ipc` | System V IPC, POSIX 메시지 큐 | 프로세스 간 통신 격리 |
| `uts` | 호스트명과 NIS 도메인 이름 | 독립적인 호스트 식별 |
| `user` | 사용자와 그룹 ID 매핑 | 루트리스 컨테이너 구현 |
| `cgroup` | cgroup 계층 구조 | 리소스 제어 격리 |

**Namespace 직접 체험**:
```bash
# 다중 Namespace에서 격리된 셸 실행
sudo unshare --pid --net --mount --uts --ipc --fork --mount-proc /bin/bash

# 격리된 환경 확인
hostname isolated  # 호스트명 변경 (현재 네임스페이스에서만 적용)
ip link            # 격리된 네트워크 인터페이스 확인
```

---

## cgroup v2: 컨테이너 리소스 관리의 기초

cgroups(control groups)는 프로세스 그룹의 시스템 리소스 사용을 제한하고 격리하는 커널 기능입니다.

### cgroup v2의 핵심 파일

- `cpu.max`: CPU 할당량 제한 (형식: `"<quota> <period>"`)
- `memory.max`: 최대 메모리 사용량 (바이트 단위)
- `pids.max`: 최대 프로세스 수 제한

### cgroup v2 실습 예제

```bash
# cgroup v2 디렉터리 생성 (cgroup v2 사용 가정)
CG=/sys/fs/cgroup/demo
sudo mkdir -p $CG

# 현재 셸 프로세스를 cgroup에 추가
echo $$ | sudo tee $CG/cgroup.procs

# 리소스 제한 설정
echo "500000 100000" | sudo tee $CG/cpu.max    # 5 vCPU 제한 (500ms/100ms)
echo 1073741824 | sudo tee $CG/memory.max      # 1GiB 메모리 상한
echo 512 | sudo tee $CG/pids.max               # 최대 512개 프로세스
```

실제 컨테이너 런타임(Docker, Podman, LXC)은 이러한 cgroup 설정을 자동으로 관리합니다.

---

## 컨테이너 보안의 추가 축: Capabilities, seccomp, LSM

### Linux Capabilities

루트 권한을 세분화하여 최소 권한 원칙을 적용합니다. 예를 들어:
- `CAP_NET_ADMIN`: 네트워크 관리 권한
- `CAP_SYS_ADMIN`: 시스템 관리 권한 (매우 강력)

컨테이너에서는 가능한 모든 capabilities를 제거(`--cap-drop=ALL`)하고, 필요한 최소한의 capabilities만 추가(`--cap-add=...`)하는 것이 좋습니다.

### seccomp (Secure Computing Mode)

시스템 호출을 화이트리스트 방식으로 제한하는 보안 메커니즘입니다. Docker는 기본 seccomp 프로필을 제공하지만, 서비스 특성에 맞게 엄격한 프로필을 적용하는 것이 권장됩니다.

### LSM (Linux Security Modules)

SELinux와 AppArmor 같은 보안 모듈로, 컨테이너와 호스트 간의 경계를 강화합니다. Docker의 볼륨 마운트 시 `:Z` 또는 `:z` 옵션을 사용하여 적절한 보안 컨텍스트를 적용할 수 있습니다.

**보안 강화된 컨테이너 실행 예시**:
```bash
docker run --read-only \
  --cap-drop=ALL --cap-add=NET_BIND_SERVICE \
  --security-opt no-new-privileges \
  --pids-limit=256 --memory=512m --cpus=1.5 \
  -v /srv/www:/srv/www:ro,Z -p 8080:8080 myimg:latest
```

---

## 파일 시스템 격리 심화: OverlayFS 이해

OverlayFS는 여러 파일 시스템 레이어를 하나의 통합된 뷰로 제공하는 유니온 파일 시스템입니다. 컨테이너의 효율적인 이미지 관리를 가능하게 합니다.

### OverlayFS 구성 요소

- **Lower Layer**: 이미지 레이어 (읽기 전용)
- **Upper Layer**: 컨테이너 쓰기 레이어
- **Work Directory**: 오퍼레이션을 위한 작업 공간
- **Merged Layer**: 컨테이너에서 보이는 최종 파일 시스템 트리

**수동 OverlayFS 마운트 예시**:
```bash
# 디렉터리 생성
sudo mkdir -p lower upper work merged

# OverlayFS 마운트
sudo mount -t overlay overlay -o lowerdir=lower,upperdir=upper,workdir=work merged
```

---

## systemd-nspawn: 시스템 컨테이너 구현

systemd-nspawn은 systemd 생태계와 잘 통합된 경량 컨테이너 도구입니다.

### 기본 사용법

```bash
# Debian 베이스 시스템 생성
sudo debootstrap stable /var/lib/machines/debian http://deb.debian.org/debian

# systemd-nspawn 컨테이너 실행
sudo systemd-nspawn -D /var/lib/machines/debian
```

**systemd-nspawn의 특징**:
- PID 1에 systemd를 사용할 수 있어 시스템 서비스 관리가 용이합니다.
- journald, tmpfiles, networkd와 자연스럽게 통합됩니다.
- 운영체제 수준의 테스트와 개발에 최적화되어 있습니다.

### 관리 명령어

```bash
# 컨테이너 목록 확인
sudo machinectl list

# 컨테이너 시작
sudo machinectl start debian

# 컨테이너 로그인
sudo machinectl login debian

# 컨테이너 내부에서 셸 실행
sudo machinectl shell debian
```

### 네트워크 구성 (브리지 연결)

```bash
# 브리지 네트워크를 통한 컨테이너 실행
sudo systemd-nspawn -D /var/lib/machines/debian --network-bridge=br0
```

---

## LXC: 전통적인 Linux 컨테이너

LXC(Linux Containers)는 네이티브 컨테이너 기술을 제공하는 저수준 도구입니다.

### 기본 작업 흐름

```bash
# LXC 컨테이너 생성
sudo lxc-create -n myct -t download

# 컨테이너 시작
sudo lxc-start -n myct

# 컨테이너 연결
sudo lxc-attach -n myct

# 컨테이너 정지
sudo lxc-stop -n myct
```

### LXC 설정 예시 (`/var/lib/lxc/myct/config`)

```ini
lxc.net.0.type = veth
lxc.net.0.link = lxcbr0
lxc.apparmor.profile = generated
lxc.cap.drop = sys_admin sys_module mac_admin mac_override
lxc.rootfs.path = dir:/var/lib/lxc/myct/rootfs
```

LXC는 매우 유연한 설정을 제공하지만, 이로 인해 직접 구성해야 할 부분이 많습니다. 시스템 엔지니어에게 적합한 도구입니다.

---

## Docker와 Podman: 애플리케이션 컨테이너의 표준

### Dockerfile 기반 이미지 빌드

```dockerfile
# 간단한 Dockerfile 예제
FROM debian:stable-slim
RUN apt-get update && apt-get install -y nginx && rm -rf /var/lib/apt/lists/*
COPY site/ /usr/share/nginx/html
USER 65534:65534
EXPOSE 8080
CMD ["nginx", "-g", "daemon off;", "-c", "/etc/nginx/nginx.conf"]
```

**이미지 빌드 및 실행**:
```bash
# 이미지 빌드
docker build -t myweb:1.0 .

# 컨테이너 실행
docker run -d --name web -p 8080:8080 myweb:1.0
```

Podman은 Docker와 유사한 명령어 인터페이스를 제공하면서도 데몬리스와 루트리스 실행을 기본으로 지원합니다.

### 네트워크 드라이버 비교

| 드라이버 | 특징 | 주요 사용 사례 |
|---|---|---|
| **bridge** (기본) | NAT, 포트 포워딩 | 개발 환경, 단일 호스트 |
| **host** | 호스트 네트워크 스택 공유 | 성능 최적화 필요 시 |
| **macvlan/ipvlan** | 외부 스위치와 직접 L2/L3 통신 | 고정 IP 할당 필요 시 |
| **overlay** | 멀티 호스트 네트워킹 | Docker Swarm, Kubernetes 클러스터 |

### Docker Compose를 통한 선언적 관리

```yaml
# docker-compose.yml 예제
version: "3.9"
services:
  api:
    image: myapi:2.0
    ports: ["9000:9000"]
    deploy:
      resources:
        limits:
          cpus: "1.5"
          memory: 1g
    read_only: true
    cap_drop: ["ALL"]
    cap_add: ["NET_BIND_SERVICE"]
    security_opt:
      - "no-new-privileges:true"
    tmpfs:
      - /tmp
    restart: unless-stopped
```

---

## 컨테이너 보안 강화 체크리스트

운영 환경에서 컨테이너를 실행할 때 고려해야 할 보안 요소들입니다:

1. **읽기 전용 루트 파일 시스템**: `--read-only` 옵션 사용, 필요한 쓰기 경로는 `tmpfs`로 제공
2. **최소 권한 Capabilities**: `--cap-drop=ALL`로 모든 권한 제거 후 필요한 권한만 `--cap-add`로 추가
3. **시스템 호출 제한**: 적절한 seccomp 프로필 적용
4. **권한 상승 방지**: `--security-opt no-new-privileges` 설정
5. **리소스 제한**: cgroup을 통한 PID, 메모리, CPU 제한 설정
6. **사용자 네임스페이스**: 루트리스 실행(`--userns=keep-id` 등)
7. **LSM 라벨링**: SELinux(`:Z`) 또는 AppArmor 프로파일 지정
8. **민감한 마운트 제한**: `/proc/kcore`, `/sys`, `/dev/mem` 등 접근 제한

**루트리스 Podman 실행 예시**:
```bash
podman run --rm -it \
  --read-only --cap-drop=ALL --cap-add=NET_BIND_SERVICE \
  --pids-limit=256 --memory=512m --cpus=1 \
  --security-opt=no-new-privileges \
  -v ./public:/srv/www:ro,Z -p 8080:8080 myweb:1.0
```

---

## KVM과 QEMU: 완전한 가상화

### 기본 개념 정리

- **QEMU**: 하드웨어를 에뮬레이트하는 가상 머신 모니터
- **KVM**: 커널 기반 가상 머신으로 하드웨어 가상화 지원
- **QEMU+KVM**: QEMU의 유연성과 KVM의 성능을 결합한 조합

### 시스템 가상화 지원 확인

```bash
# KVM 모듈 확인
lsmod | grep kvm

# CPU 가상화 지원 확인 (Intel: vmx, AMD: svm)
egrep -c '(vmx|svm)' /proc/cpuinfo
```

### QEMU 빠른 시작

```bash
# 가상 디스크 이미지 생성
qemu-img create -f qcow2 disk.qcow2 20G

# 가상 머신 실행
qemu-system-x86_64 -enable-kvm -cpu host -smp 4 -m 4096 \
  -drive file=disk.qcow2,if=virtio,cache=none,discard=unmap,format=qcow2 \
  -netdev user,id=n1 -device virtio-net-pci,netdev=n1 \
  -display none -serial mon:stdio
```

**주요 옵션 설명**:
- `-enable-kvm`: KVM 가속 활성화
- `-cpu host`: 호스트 CPU 기능 노출
- `if=virtio`: 가상 I/O 장치 사용 (성능 향상)
- `format=qcow2`: Copy-on-Write 디스크 형식 (스냅샷 지원)

### libvirt와 virt-manager: 가상화 관리 자동화

```bash
# 가상 머신 목록 확인
virsh list --all

# 가상 머신 생성 (무인 설치)
virt-install --name vm1 --memory 4096 --vcpus 4 \
  --disk size=20,format=qcow2,bus=virtio \
  --cdrom ~/isos/debian.iso --os-variant debian12 \
  --network network=default,model=virtio
```

### 가상 머신 성능 최적화

1. **CPU 최적화**: 호스트 CPU 패스스루(`-cpu host`), CPU 핀닝, NUMA 인식 구성
2. **메모리 최적화**: HugePages 활성화, 메모리 풀 구성, NUMA 로컬 메모리 할당
3. **디스크 I/O 최적화**: `cache=none`, `io=native`, 전용 I/O 스레드 사용
4. **네트워크 최적화**: `virtio-net` + `vhost-net` 조합

### 라이브 마이그레이션 개념

라이브 마이그레이션은 실행 중인 가상 머신을 다른 물리 호스트로 중단 시간 최소화하며 이동하는 기술입니다:
- 전제 조건: 공유 스토리지 또는 블록 수준 복제
- 동작 방식: 메모리 더티 페이지를 반복적으로 전송
- 고가용성 설계: 민감한 서비스는 게스트 내부 HA와 함께 구성

---

## 컨테이너 vs 가상 머신: 선택 기준

| 요구사항 | 권장 기술 | 이유 |
|---|---|---|
| 높은 밀도와 빠른 시작 | **컨테이너** (Docker/Podman) | 경량 격리, 빠른 배포 |
| 강력한 보안 격리와 이기종 OS | **KVM 가상 머신** | 완전한 커널 격리 |
| 시스템 수준 테스트와 서비스 관리 | **systemd-nspawn/LXC** | 시스템 서비스 통합 |
| 고성능 네트워킹과 하드웨어 패스스루 | **KVM + VFIO** | 직접 하드웨어 접근 |
| 규제 준수와 강한 감사 요구 | **가상 머신 우선** | 명확한 경계, 추가 컨테이너 보안 강화 |

현대적인 하이브리드 아키텍처에서는 **애플리케이션은 컨테이너로, 테넌트와 강한 경계는 가상 머신으로** 구분하는 접근이 일반적입니다.

---

## 문제 해결 가이드

### 컨테이너 네트워크 연결 문제

```bash
# 네트워크 네임스페이스 확인
ip netns list

# 네트워크 인터페이스와 라우팅 확인
ip a
ip r

# Docker 네트워크 상태 확인
docker network ls
docker inspect <container> | jq '.[0].NetworkSettings'

# 호스트 방화벽 및 NAT 규칙 확인
sudo nft list ruleset
```

### 파일 권한과 보안 라벨 문제

1. **호스트 측 점검**: `ls -l` (권한), `ls -Z` (SELinux 컨텍스트), `aa-status` (AppArmor 상태)
2. **볼륨 마운트 옵션**: SELinux는 `:Z`/`:z`, 루트리스는 UID/GID 매핑 확인
3. **읽기 전용 루트**: `--read-only`와 함께 `tmpfs` 마운트 제공 여부 확인

### 가상 머신 성능 문제

1. **CPU 설정 확인**: `-cpu host` 적용 여부
2. **디스크 구성 확인**: `cache=none`, `io=native`, virtio 드라이버 사용
3. **메모리 구성 확인**: HugePages, NUMA 로컬 할당
4. **성능 모니터링**: `perf`, `iostat -xz`, `ethtool -S`로 병목 지점 분석

---

## 보안과 거버넌스 모범 사례

### 컨테이너 보안

- **이미지 보안**: 이미지 서명(cosign), 취약점 스캔(trivy), SBOM(Software Bill of Materials) 관리
- **런타임 보안**: OPA Gatekeeper/Kyverno 정책, Pod Security Standards 준수
- **보안 구성**: seccomp, AppArmor, SELinux 조합 적용

### 가상 머신 보안

- **템플릿 관리**: 불변 인프라 패턴 적용, 템플릿 서명
- **접근 제어**: SSH 키 기반 인증만 허용, 비밀번호 로그인 차단
- **초기 구성**: cloud-init를 통한 초기 보안 설정 자동화

### 모니터링과 감사

- 컨테이너: `auditd`와 LSM 로그 수집
- 가상 머신: libvirt 로그, 하이퍼바이저 이벤트 모니터링
- 백업 및 재해 복구: 이미지, 볼륨, 스냅샷 정책 수립

---

## 실전 예제 모음

### 루트리스 Podman으로 정적 웹 서버 실행

```bash
podman run --rm -d --name web \
  -p 8080:80 \
  --userns=keep-id \
  --read-only --cap-drop=ALL \
  -v ./public:/usr/share/nginx/html:ro,Z \
  docker.io/library/nginx:stable
```

### systemd-nspawn으로 Debian 시스템 컨테이너 부팅

```bash
# 베이스 시스템 생성
sudo debootstrap stable /var/lib/machines/deb http://deb.debian.org/debian

# 브리지 네트워크로 컨테이너 실행
sudo systemd-nspawn -D /var/lib/machines/deb --boot --network-bridge=br0

# 컨테이너 로그인
sudo machinectl login deb
```

### LXC 컨테이너 리소스 제한 설정

```ini
# /var/lib/lxc/myct/config 파일에 추가
lxc.cgroup2.memory.max = 1024M
lxc.cgroup2.pids.max   = 256
lxc.cgroup2.cpu.max    = 200000 100000   # 2 vCPU 제한
```

### libvirt로 Ubuntu 가상 머신 생성

```bash
virt-install --name lab1 --memory 4096 --vcpus 4 \
  --disk size=30,bus=virtio,format=qcow2 \
  --cdrom ~/isos/ubuntu-24.04.iso \
  --os-variant ubuntu24.04 --graphics spice \
  --network network=default,model=virtio
```

---

## 주요 명령어 요약

### Namespace 관련 명령

```bash
# 새로운 네임스페이스에서 프로세스 실행
unshare --pid --net --mount --uts --ipc --fork /bin/bash

# 실행 중인 프로세스의 네임스페이스에 진입
nsenter --target <PID> --pid --net --mount --uts --ipc /bin/bash
```

### cgroup v2 관리

```bash
# cgroup 생성 및 리소스 제한 설정
sudo mkdir -p /sys/fs/cgroup/x && CG=/sys/fs/cgroup/x
echo $$ | sudo tee $CG/cgroup.procs
echo "200000 100000" | sudo tee $CG/cpu.max
echo 1G | sudo tee $CG/memory.max
echo 256 | sudo tee $CG/pids.max
```

### 컨테이너 실행 (보안 강화)

```bash
# Docker/Podman 보안 강화 컨테이너 실행
docker run -it --rm --cpus=1 --memory=512m --pids-limit=256 --read-only \
  --cap-drop=ALL --security-opt no-new-privileges busybox sh
```

### QEMU 가상 머신 실행

```bash
# 가상 디스크 생성 및 가상 머신 실행
qemu-img create -f qcow2 disk.qcow2 20G
qemu-system-x86_64 -enable-kvm -cpu host -smp 2 -m 2048 \
  -drive file=disk.qcow2,if=virtio,format=qcow2,cache=none \
  -netdev user,id=n1 -device virtio-net-pci,netdev=n1
```

---

## 자주 묻는 질문 (FAQ)

### Q: chroot로 컨테이너를 대체할 수 있나요?
**A**: 아닙니다. chroot는 파일 시스템 경로만 변경하며, 네임스페이스, 시스템 호출 제한, 리소스 제어와 같은 컨테이너의 핵심 보안 기능을 제공하지 않습니다.

### Q: Docker와 Podman의 주요 차이는 무엇인가요?
**A**: Podman은 데몬리스 아키텍처와 루트리스 실행을 기본으로 지원합니다. 두 도구 모두 OCI 표준을 따르며, 많은 기업에서 둘 다 사용하고 있습니다.

### Q: 가상 머신이 컨테이너보다 더 안전한가요?
**A**: 일반적으로 가상 머신은 더 강력한 격리 경계를 제공합니다. 그러나 적절히 구성된 컨테이너도 LSM, 사용자 네임스페이스, 하드닝을 통해 충분한 보안을 제공할 수 있습니다. 선택은 구체적인 요구사항에 따라 달라집니다.

---

## 결론

컨테이너와 시스템 가상화 기술은 현대 인프라의 두 가지 핵심 축을 형성합니다. 각 기술은 고유한 장점과 적합한 사용 사례를 가지고 있습니다.

컨테이너는 **네임스페이스, cgroup, capabilities, seccomp, LSM**의 조합을 통해 프로세스 수준의 효율적인 격리를 제공합니다. 이는 빠른 시작 시간, 높은 밀도, DevOps 워크플로우와 잘 어울리는 특성을 가집니다.

가상 머신은 **KVM과 QEMU**를 통해 완전한 하드웨어 수준의 격리를 구현하며, 이기종 운영체제 실행, 강력한 보안 경계, 하드웨어 패스스루와 같은 요구사항에 적합합니다.

현실적인 솔루션은 종종 **혼합 설계**를 채택합니다: 애플리케이션은 컨테이너로 패키징하고, 테넌트 간 강한 경계나 특수 요구사항은 가상 머신으로 구현합니다.

어떤 기술을 선택하든, **체계적인 모니터링(로그와 메트릭), 정책 기반 관리, 자동화된 운영**이 성공적인 구현의 핵심 요소입니다. 기술 선택은 단순히 트렌드가 아닌, 구체적인 비즈니스 요구사항, 보안 요구사항, 운영 제약 조건을 종합적으로 고려한 결과여야 합니다.

이러한 기술들을 효과적으로 활용하려면 각 도구의 기본 원리를 이해하고, 실제 사용 사례에 맞게 조정하며, 지속적으로 보안과 성능을 최적화하는 접근이 필요합니다. 컨테이너와 가상화 기술은 단순한 기술 구현을 넘어 조직의 민첩성, 안정성, 효율성을 결정하는 전략적 자산이 될 수 있습니다.