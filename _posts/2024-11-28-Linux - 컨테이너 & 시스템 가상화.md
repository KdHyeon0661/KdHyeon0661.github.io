---
layout: post
title: Linux - 컨테이너 & 시스템 가상화
date: 2024-11-28 19:20:23 +0900
category: Linux
---
# 컨테이너 & 시스템 가상화

## 0) 빠른 개요 & 실습 환경

- 배포판: Debian/Ubuntu(apt) 또는 RHEL/Fedora(dnf) 기준 명령 병기
- 커널 기능: **namespace, cgroup v2, capabilities, seccomp, LSM(SELinux/AppArmor)**  
- 컨테이너 계열: **systemd-nspawn, LXC, Docker/Podman**
- 하이퍼바이저 계열: **KVM + QEMU(+libvirt/virt-manager)**

실습 전 권장 패키지:
```bash
# Debian/Ubuntu
sudo apt update
sudo apt install -y debootstrap systemd-container uidmap \
  lxc lxc-templates lxd qemu-kvm libvirt-daemon-system virt-manager \
  bridge-utils uidmap podman docker.io jq curl

# RHEL/Fedora(참고)
sudo dnf install -y debootstrap systemd-container uidmap \
  lxc lxc-templates qemu-kvm libvirt virt-install virt-manager \
  podman moby-engine jq curl
```

---

## 1) chroot vs namespace — “디렉토리 바꾸기”와 “세계 바꾸기”의 차이

### 1.1 chroot: 루트 디렉토리만 바뀌는 *부분 격리*
```bash
sudo mkdir -p /srv/jail && sudo debootstrap stable /srv/jail \
  http://deb.debian.org/debian
sudo chroot /srv/jail /bin/bash
```
- **파일시스템 경로만** 바뀜. **PID/네트워크/호스트명/사용자**는 **공유**됨.
- `CAP_SYS_CHROOT`가 있으면 탈출 가능 경로가 존재 → **보안 격리 용도 부적합**, 복구/패키지 빌드/디버깅에 유용.

### 1.2 namespace: *리소스별로 다른 우주 만들기*
주요 종류 & 격리 대상:

| Namespace | 격리 대상(핵심) | 비고 |
|---|---|---|
| `mnt` | 마운트(파일시스템 뷰) | `pivot_root`, `MS_PRIVATE` 등 |
| `pid` | 프로세스 ID 공간 | pid 1(시그널/좀비 수거) 의미 |
| `net` | NIC/라우팅/포트 | veth/브리지, nftables 분리 |
| `ipc` | SysV IPC, POSIX MQ | 빌드/DB 세션 안전성 |
| `uts` | 호스트명/도메인 | `hostname` 분리 |
| `user` | UID/GID 매핑 | **루트리스 핵심** |
| `cgroup` | 계층형 리소스 제어 | v2 단일 계층 권장 |

직접 체감:
```bash
# PID/NET/MNT 분리된 셸 열기(새 우주)
sudo unshare --pid --net --mount --uts --ipc --fork --mount-proc /bin/bash
hostname isolated
ip link  # 별도 네트워크 네임스페이스
```

---

## 2) cgroup v2로 리소스 선 그어두기(컨테이너 필수 기초)

### 2.1 cgroup v2 핵심 파일(예)
- `cpu.max`   : `"<quota> <period>"`, 예: `200000 100000` → 2 vCPU 한도
- `memory.max`: 바이트 단위 상한(예: `1073741824` = 1GiB)
- `pids.max`  : 생성 가능한 PID 수

간단 실습:
```bash
# cgroup v2 사용 가정(/sys/fs/cgroup)
CG=/sys/fs/cgroup/demo
sudo mkdir -p $CG
echo $$ | sudo tee $CG/cgroup.procs         # 현재 셸을 cgroup에 편입
echo 500000 100000 | sudo tee $CG/cpu.max   # 5 vCPU 제한(500ms/100ms)
echo 1073741824 | sudo tee $CG/memory.max   # 1GiB 메모리 상한
echo 512 | sudo tee $CG/pids.max            # 최대 512 프로세스
```

> 컨테이너 런타임(Docker/Podman/LXC)은 이 설정을 **자동으로** 관리합니다.

---

## 3) 보안 격리의 다른 축: Capabilities·seccomp·LSM

- **Linux Capabilities**: root 권한을 잘게 쪼개기.  
  예) `CAP_NET_ADMIN`, `CAP_SYS_ADMIN`(슈퍼카)… 가능하면 **드롭**.
- **seccomp**: 허용된 **시스템콜 화이트리스트**.  
  Docker 기본 프로파일 존재, 서비스별로 엄격화 권장.
- **LSM**: SELinux/AppArmor. 컨테이너/호스트 경계 강화(볼륨 라벨링 `:Z` 등).

컨테이너 하드닝 예(미리보기):
```bash
docker run --read-only \
  --cap-drop=ALL --cap-add=NET_BIND_SERVICE \
  --security-opt no-new-privileges \
  --pids-limit=256 --memory=512m --cpus=1.5 \
  -v /srv/www:/srv/www:ro,Z -p 8080:8080 myimg:latest
```

---

## 4) 파일시스템 격리 심화: mount ns·pivot_root·overlayfs

### 4.1 pivot_root: 새 루트로 깔끔 전환
컨테이너 런타임은 **초기 RAM(루트)** → **overlayfs 루트**로 전환 시 사용.

### 4.2 overlayfs 핵심
- **Lower**: 이미지 레이어(읽기 전용)
- **Upper**: 컨테이너 쓰기 레이어
- **Merged**: 컨테이너에서 보이는 최종 트리

수동 예시(개념 실습):
```bash
sudo mkdir -p lower upper work merged
sudo mount -t overlay overlay -o lowerdir=lower,upperdir=upper,workdir=work merged
```

---

## 5) systemd-nspawn — “시스템 컨테이너”로 systemd 세계를 띄운다

### 5.1 베이스 루트 생성 & 실행
```bash
sudo debootstrap stable /var/lib/machines/debian http://deb.debian.org/debian
sudo systemd-nspawn -D /var/lib/machines/debian
```

- PID 1에 **systemd**를 두기 쉽고, `machines.target`로 **시스템 관리 통합**.
- 장점: journald·tmpfiles·networkd와 자연스러운 연동, **운영체제 수준 테스트**에 최적.

### 5.2 관리 명령
```bash
# 부팅형으로 등록/관리
sudo machinectl list
sudo machinectl start debian
sudo machinectl login debian
sudo machinectl shell debian
```

### 5.3 네트워킹(bridge)
```bash
# host에서 systemd-networkd로 cni0 같은 브리지 구성 후 nspawn에 연결
sudo systemd-nspawn -D /var/lib/machines/debian --network-bridge=br0
```

---

## 6) LXC — 커널 기능을 “날 것으로” 쓰는 정통 컨테이너

### 6.1 기본 흐름
```bash
sudo lxc-create -n myct -t download
sudo lxc-start -n myct
sudo lxc-attach -n myct
sudo lxc-stop -n myct
```

### 6.2 설정 맛보기(`/var/lib/lxc/myct/config`)
```ini
lxc.net.0.type = veth
lxc.net.0.link = lxcbr0
lxc.apparmor.profile = generated
lxc.cap.drop = sys_admin sys_module mac_admin mac_override
lxc.rootfs.path = dir:/var/lib/lxc/myct/rootfs
```
- LXC는 매우 유연하지만 **직접 설정할 점이 많음** → 시스템 엔지니어 친화.

---

## 7) Docker/Podman — 애플리케이션 컨테이너 표준

### 7.1 OCI 이미지·레이어·빌드
```bash
# Dockerfile 예
FROM debian:stable-slim
RUN apt-get update && apt-get install -y nginx && rm -rf /var/lib/apt/lists/*
COPY site/ /usr/share/nginx/html
USER 65534:65534
EXPOSE 8080
CMD ["nginx","-g","daemon off;","-c","/etc/nginx/nginx.conf"]
```
```bash
docker build -t myweb:1.0 .
docker run -d --name web -p 8080:8080 myweb:1.0
```
- Podman은 rootless 기본 지원: `podman build/run` 동일 UX.

### 7.2 네트워킹 드라이버 한눈에
| 드라이버 | 특징 | 사용 예 |
|---|---|---|
| bridge(기본) | NAT, 포트포워딩 | 개발/단일호스트 |
| host | 호스트 네트 공유(격리↓) | 성능 우선 |
| macvlan/ipvlan | 외부 스위치와 직접 L2/L3 통신 | 레거시 네트/고정IP |
| overlay | 멀티호스트 네트(dockerswarm,k8s CNI) | 오케스트레이션 |

### 7.3 스토리지 드라이버
- `overlay2`(대세), btrfs, zfs(스냅샷 강점), devicemapper(레거시)  
- 대규모 이미지 빌드엔 **캐시 히트 최적화**(레이어 통합, 멀티스테이지 빌드) 필수.

### 7.4 Compose로 선언형 운영
```yaml
# docker-compose.yml
version: "3.9"
services:
  api:
    image: myapi:2.0
    ports: ["9000:9000"]
    deploy:
      resources:
        limits:
          cpus: "1.5"
          memory: 1g
    read_only: true
    cap_drop: ["ALL"]
    cap_add: ["NET_BIND_SERVICE"]
    security_opt:
      - "no-new-privileges:true"
    tmpfs:
      - /tmp
    restart: unless-stopped
```

---

## 8) 컨테이너 하드닝 체크리스트(필수)

- **read-only rootfs** + **tmpfs**에 쓰기 경로 최소화
- **cap-drop ALL** 후 필요한 cap만 **add**
- **seccomp 프로파일** 적용(기본값 또는 커스텀)
- **no-new-privileges** 활성화
- **PIDs/mem/cpu limit** 설정(cgroup v2)
- **유저 네임스페이스 매핑**(rootless/`--userns=keep-id` 등)
- **LSM 라벨링**: SELinux(`:Z`) / AppArmor 프로파일 지정
- **민감 마운트 금지**: `/proc/kcore`, `/sys`, `/dev/mem` 등

예시(루트리스 Podman 하드닝):
```bash
podman run --rm -it \
  --read-only --cap-drop=ALL --cap-add=NET_BIND_SERVICE \
  --pids-limit=256 --memory=512m --cpus=1 \
  --security-opt=no-new-privileges \
  -v ./public:/srv/www:ro,Z -p 8080:8080 myweb:1.0
```

---

## 9) KVM & QEMU — 커널이 하이퍼바이저가 되는 순간

### 9.1 용어 정리
- **QEMU**: 에뮬레이터(하드웨어 가상화 없이도 동작).  
- **KVM**: 커널 모듈(하드웨어 가상화 가속) → `/dev/kvm` 노출.  
- **QEMU+KVM**: QEMU 프론트 + 커널 가속으로 **고성능 VM**.

확인:
```bash
lsmod | grep kvm
egrep -c '(vmx|svm)' /proc/cpuinfo   # Intel VT-x=vmx, AMD-V=svm
```

### 9.2 빠른 QEMU 실행
```bash
qemu-img create -f qcow2 disk.qcow2 20G
qemu-system-x86_64 -enable-kvm -cpu host -smp 4 -m 4096 \
  -drive file=disk.qcow2,if=virtio,cache=none,discard=unmap,format=qcow2 \
  -netdev user,id=n1 -device virtio-net-pci,netdev=n1 \
  -display none -serial mon:stdio
```
- **virtio** 계열 디바이스(CPU 오버헤드↓, I/O 성능↑)
- **qcow2**: COW 스냅샷/압축/씬프로비전 지원(운영 혼합시 주의)

### 9.3 libvirt/virt-manager(관리 자동화)
```bash
virsh list --all
virt-install --name vm1 --memory 4096 --vcpus 4 \
  --disk size=20,format=qcow2,bus=virtio \
  --cdrom ~/isos/debian.iso --os-variant debian12 \
  --network network=default,model=virtio
```
- 네트워크: 기본 NAT(`virbr0`), 브리지로 L2 직결도 가능.
- **cloud-init**로 무인 설치/부팅 후 구성 자동화.

### 9.4 성능 튜닝 핵심
- CPU: `-cpu host`, **pinning**(vCPU→pCPU), **NUMA** 맵핑
- 메모리: **HugePages**(2M/1G), ballooning, numa local
- 디스크: `cache=none`, `io=native`, **iothreads** 분리
- NIC: `virtio-net` + `vhost-net`(커널 속도 향상)

### 9.5 라이브 마이그레이션(개념)
- 전제: **공유 스토리지**(또는 블록 복제), **네트워크 연결**
- libvirt가 **메모리 더티 페이지** 반복 전송 → 중단 시간 최소화
- 다운타임 민감 서비스는 **게스트 내부 HA**와 함께 설계

---

## 10) 컨테이너 vs VM 선택 기준과 혼합 전략

| 요구 | 권장 |
|---|---|
| 밀도/속도/DevOps | **컨테이너**(Docker/Podman, K8s) |
| 강력한 격리/이기종 OS | **KVM**(VM) |
| 시스템 단위 테스트·서비스 OS 모델 | **systemd-nspawn/LXC** |
| 고성능 네트워킹(SR-IOV)·특수 하드웨어 패스스루 | **KVM + VFIO** |
| 규제/감사(강한 경계) | **VM 우선**, 컨테이너는 추가 하드닝 |

현대 아키텍처는 **컨테이너(앱)** + **VM(테넌트·워크로드 경계)** 혼용이 일반적.

---

## 11) 트러블슈팅 플레이북

### 11.1 컨테이너가 네트워크를 못 탄다
```bash
# 네임스페이스별 인터페이스
ip netns list ; ip a ; ip r
# Docker/Podman 네트워크
docker network ls
docker inspect <container> | jq '.[0].NetworkSettings'
# 호스트 방화벽/NAT
sudo nft list ruleset
```

### 11.2 파일 권한/라벨 문제
- **호스트**: `ls -l`, `ls -Z`(SELinux) / `aa-status`(AppArmor)
- **컨테이너 볼륨**: SELinux `:Z`/`:z`, 루트리스면 **UID/GID 매핑** 점검
- 읽기전용 루트로 인한 쓰기 실패: `--read-only` + `tmpfs` 제공 여부 확인

### 11.3 KVM 성능 저하
- `-cpu host` 적용 여부
- 디스크 캐시/IO 스택 확인(`cache=none,io=native`, virtio)
- CPU pinning/NUMA local/HugePages 설정
- `perf`, `iostat -xz`, `ethtool -S`로 병목 추적

---

## 12) 보안·거버넌스 베스트 프랙티스

- 컨테이너: **이미지 서명/스캔**(cosign/trivy), **SBOM** 관리, 레지스트리 접근 제어
- 런타임: **OPA Gatekeeper/Kyverno**(K8s), Pod Security, seccomp/AppArmor/SELinux 조합
- VM: **템플릿 불변성**, cloud-init **초기 암호키만**, SSH 패스워드 로그인 금지
- 감사: 컨테이너(`auditd`+LSM 로그), VM(libvirt 로그), 하이퍼바이저 이벤트 수집
- 백업/DR: 이미지/볼륨/스냅샷 정책, 마이그레이션 리허설

---

## 13) 손에 잡히는 실전 예제 모음

### 13.1 루트리스 컨테이너로 정적 웹 서빙(Podman)
```bash
podman run --rm -d --name web \
  -p 8080:80 \
  --userns=keep-id \
  --read-only --cap-drop=ALL \
  -v ./public:/usr/share/nginx/html:ro,Z \
  docker.io/library/nginx:stable
```

### 13.2 nspawn으로 Debian 컨테이너 부팅 + 브리지 연결
```bash
sudo debootstrap stable /var/lib/machines/deb http://deb.debian.org/debian
sudo systemd-nspawn -D /var/lib/machines/deb --boot --network-bridge=br0
sudo machinectl login deb
```

### 13.3 LXC 컨테이너 리소스 제한
```ini
# /var/lib/lxc/myct/config
lxc.cgroup2.memory.max = 1024M
lxc.cgroup2.pids.max   = 256
lxc.cgroup2.cpu.max    = 200000 100000   # 2 vCPU
```

### 13.4 libvirt로 빠르게 VM 생성(virt-install)
```bash
virt-install --name lab1 --memory 4096 --vcpus 4 \
  --disk size=30,bus=virtio,format=qcow2 \
  --cdrom ~/isos/ubuntu-24.04.iso \
  --os-variant ubuntu24.04 --graphics spice \
  --network network=default,model=virtio
```

---

## 14) 치트시트

**Namespace**
```bash
unshare --pid --net --mount --uts --ipc --fork /bin/bash
nsenter --target <PID> --pid --net --mount --uts --ipc /bin/bash
```

**cgroup v2**
```bash
sudo mkdir -p /sys/fs/cgroup/x && CG=/sys/fs/cgroup/x
echo $$ | sudo tee $CG/cgroup.procs
echo "200000 100000" | sudo tee $CG/cpu.max
echo 1G | sudo tee $CG/memory.max
echo 256 | sudo tee $CG/pids.max
```

**Docker/Podman**
```bash
docker run -it --rm --cpus=1 --memory=512m --pids-limit=256 --read-only \
  --cap-drop=ALL --security-opt no-new-privileges busybox sh
```

**KVM/QEMU**
```bash
qemu-img create -f qcow2 disk.qcow2 20G
qemu-system-x86_64 -enable-kvm -cpu host -smp 2 -m 2048 \
  -drive file=disk.qcow2,if=virtio,format=qcow2,cache=none \
  -netdev user,id=n1 -device virtio-net-pci,netdev=n1
```

---

## 15) FAQ(짧고 굵게)

- **Q. chroot로 컨테이너 대체 가능?**  
  A. 파일시스템만 바뀌므로 **불가**. 네임스페이스/시스템콜/LSM/리소스제한이 핵심.

- **Q. Docker와 Podman 차이?**  
  A. Podman은 **데몬리스·루트리스** 친화. OCI 호환. 기업 표준은 둘 다 사용.

- **Q. VM이 더 안전?**  
  A. 경계가 더 두껍다. 그러나 컨테이너도 LSM/유저NS/하드닝으로 충분히 강할 수 있음. **요구사항**으로 선택.

---

## 16) 마무리 — 운영의 기준선 세우기

- 컨테이너: **namespace + cgroup + capability + seccomp + LSM**이 기본 방어선.  
- VM: **KVM+QEMU**로 독립 커널을 제공, 강한 격리/이기종 OS/하드웨어 패스스루에 유리.  
- 현실적인 해답은 **혼용 설계**: 앱은 컨테이너, 테넌트·강한 경계는 VM.  
- 마지막으로, 어떤 선택이든 **관측(로그/메트릭) → 정책화 → 자동화**가 품질을 만든다.