---
layout: post
title: 파이썬 심화 - 유틸리티 스크립트와 시스템 관리 (4)
date: 2025-12-06 22:30:23 +0900
category: 파이썬 심화
---
# 유틸리티 스크립트와 시스템 관리 (4)

파이썬을 활용한 시스템 레벨 프로그래밍은 운영체제와의 깊은 상호작용을 통해 타이머, 리소스 제한, 외부 애플리케이션 실행 등 다양한 시스템 기능을 제어할 수 있습니다. 실용적인 시스템 도구와 유틸리티를 개발하기 위한 종합적인 접근 방식을 살펴보겠습니다.

## 고급 스톱워치 타이머 시스템

### 다양한 타이머 기능을 갖춘 완전한 스톱워치 구현

```python
import time
import threading
import tkinter as tk
from tkinter import ttk, messagebox
from dataclasses import dataclass, field
from typing import Optional, Callable, List, Dict
from enum import Enum
import csv
import json
from datetime import datetime, timedelta
from pathlib import Path

class TimerState(Enum):
    """타이머 상태"""
    STOPPED = "stopped"
    RUNNING = "running"
    PAUSED = "paused"
    FINISHED = "finished"

@dataclass
class LapTime:
    """랩 타임 기록"""
    lap_number: int
    lap_time: float
    total_time: float
    timestamp: datetime = field(default_factory=datetime.now)

class PrecisionTimer:
    """고정밀 타이머 클래스"""
    
    def __init__(self, name: str = "기본 타이머"):
        self.name = name
        self.state = TimerState.STOPPED
        self.start_time: Optional[float] = None
        self.pause_time: Optional[float] = None
        self.total_paused_time: float = 0.0
        self.lap_times: List[LapTime] = []
        self.callbacks: Dict[str, List[Callable]] = {
            'start': [],
            'pause': [],
            'resume': [],
            'stop': [],
            'lap': [],
            'tick': [],
            'finish': []
        }
        self._tick_thread: Optional[threading.Thread] = None
        self._stop_tick = threading.Event()
        
    def start(self) -> None:
        """타이머 시작"""
        if self.state == TimerState.RUNNING:
            return
            
        if self.state == TimerState.STOPPED:
            self.start_time = time.perf_counter()
            self.total_paused_time = 0.0
            self.lap_times.clear()
        elif self.state == TimerState.PAUSED:
            # 일시정지 시간 보정
            if self.pause_time:
                self.total_paused_time += time.perf_counter() - self.pause_time
                self.pause_time = None
        
        self.state = TimerState.RUNNING
        self._notify_callbacks('start')
        
        # 틱(초시계) 스레드 시작
        self._stop_tick.clear()
        self._tick_thread = threading.Thread(target=self._tick_loop, daemon=True)
        self._tick_thread.start()
        
    def pause(self) -> None:
        """타이머 일시정지"""
        if self.state != TimerState.RUNNING:
            return
            
        self.pause_time = time.perf_counter()
        self.state = TimerState.PAUSED
        self._notify_callbacks('pause')
        
    def resume(self) -> None:
        """타이머 재개"""
        if self.state != TimerState.PAUSED:
            return
            
        if self.pause_time:
            self.total_paused_time += time.perf_counter() - self.pause_time
            self.pause_time = None
            
        self.state = TimerState.RUNNING
        self._notify_callbacks('resume')
        
    def stop(self) -> None:
        """타이머 정지"""
        self._stop_tick.set()
        if self._tick_thread:
            self._tick_thread.join(timeout=1)
            
        self.state = TimerState.STOPPED
        self._notify_callbacks('stop')
        
    def lap(self, lap_name: Optional[str] = None) -> Optional[LapTime]:
        """랩 타임 기록"""
        if self.state != TimerState.RUNNING:
            return None
            
        current_time = self.get_elapsed_time()
        lap = LapTime(
            lap_number=len(self.lap_times) + 1,
            lap_time=current_time - (self.lap_times[-1].total_time if self.lap_times else 0),
            total_time=current_time
        )
        
        if lap_name:
            setattr(lap, 'name', lap_name)
            
        self.lap_times.append(lap)
        self._notify_callbacks('lap', lap)
        
        return lap
        
    def get_elapsed_time(self) -> float:
        """경과 시간 계산 (초 단위)"""
        if self.state == TimerState.STOPPED:
            return 0.0
            
        current = time.perf_counter()
        
        if self.state == TimerState.PAUSED and self.pause_time:
            elapsed = self.pause_time - self.start_time - self.total_paused_time
        elif self.start_time:
            elapsed = current - self.start_time - self.total_paused_time
        else:
            elapsed = 0.0
            
        return max(0.0, elapsed)
        
    def get_formatted_time(self, include_millis: bool = True) -> str:
        """형식화된 시간 문자열 반환"""
        elapsed = self.get_elapsed_time()
        
        hours = int(elapsed // 3600)
        minutes = int((elapsed % 3600) // 60)
        seconds = int(elapsed % 60)
        milliseconds = int((elapsed - int(elapsed)) * 1000)
        
        if hours > 0:
            time_str = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
        else:
            time_str = f"{minutes:02d}:{seconds:02d}"
            
        if include_millis:
            time_str += f".{milliseconds:03d}"
            
        return time_str
        
    def register_callback(self, event: str, callback: Callable) -> None:
        """콜백 함수 등록"""
        if event in self.callbacks:
            self.callbacks[event].append(callback)
            
    def _notify_callbacks(self, event: str, *args, **kwargs) -> None:
        """콜백 함수 호출"""
        for callback in self.callbacks.get(event, []):
            try:
                callback(*args, **kwargs)
            except Exception as e:
                print(f"콜백 실행 오류: {e}")
                
    def _tick_loop(self) -> None:
        """틱(초시계) 루프"""
        while not self._stop_tick.is_set() and self.state == TimerState.RUNNING:
            self._notify_callbacks('tick', self.get_elapsed_time())
            time.sleep(0.1)  # 100ms 간격
            
    def export_laps(self, filepath: str, format: str = 'csv') -> None:
        """랩 타임 내보내기"""
        if not self.lap_times:
            return
            
        if format == 'csv':
            with open(filepath, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(['랩번호', '랩타임(초)', '누적시간(초)', '기록시각'])
                
                for lap in self.lap_times:
                    writer.writerow([
                        lap.lap_number,
                        f"{lap.lap_time:.3f}",
                        f"{lap.total_time:.3f}",
                        lap.timestamp.strftime('%Y-%m-%d %H:%M:%S')
                    ])
                    
        elif format == 'json':
            data = {
                'timer_name': self.name,
                'export_time': datetime.now().isoformat(),
                'laps': [
                    {
                        'lap_number': lap.lap_number,
                        'lap_time': lap.lap_time,
                        'total_time': lap.total_time,
                        'timestamp': lap.timestamp.isoformat()
                    }
                    for lap in self.lap_times
                ]
            }
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
                
    def reset(self) -> None:
        """타이머 초기화"""
        self.stop()
        self.start_time = None
        self.pause_time = None
        self.total_paused_time = 0.0
        self.lap_times.clear()
        self.state = TimerState.STOPPED

class CountdownTimer(PrecisionTimer):
    """카운트다운 타이머"""
    
    def __init__(self, duration: float, name: str = "카운트다운 타이머"):
        super().__init__(name)
        self.duration = duration  # 초 단위
        self.remaining_time = duration
        
    def start(self) -> None:
        """카운트다운 시작"""
        if self.state == TimerState.STOPPED:
            self.remaining_time = self.duration
            
        super().start()
        
    def get_elapsed_time(self) -> float:
        """경과 시간 계산 (카운트다운용)"""
        if self.state == TimerState.STOPPED:
            return 0.0
            
        elapsed = super().get_elapsed_time()
        self.remaining_time = max(0.0, self.duration - elapsed)
        
        # 시간 종료 체크
        if self.remaining_time <= 0 and self.state == TimerState.RUNNING:
            self.state = TimerState.FINISHED
            self._notify_callbacks('finish')
            self.stop()
            
        return elapsed
        
    def get_formatted_time(self, include_millis: bool = True) -> str:
        """남은 시간 형식화"""
        if self.state == TimerState.STOPPED:
            remaining = self.duration
        else:
            remaining = self.remaining_time
            
        hours = int(remaining // 3600)
        minutes = int((remaining % 3600) // 60)
        seconds = int(remaining % 60)
        milliseconds = int((remaining - int(remaining)) * 1000)
        
        if hours > 0:
            time_str = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
        else:
            time_str = f"{minutes:02d}:{seconds:02d}"
            
        if include_millis:
            time_str += f".{milliseconds:03d}"
            
        return time_str

class StopwatchGUI:
    """스톱워치 GUI 애플리케이션"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("고급 스톱워치")
        self.root.geometry("500x600")
        
        # 타이머 생성
        self.stopwatch = PrecisionTimer("메인 스톱워치")
        self.countdown = CountdownTimer(300, "5분 타이머")  # 5분 타이머
        
        self.current_timer = self.stopwatch
        
        # 콜백 등록
        self.stopwatch.register_callback('tick', self.update_display)
        self.countdown.register_callback('tick', self.update_display)
        self.countdown.register_callback('finish', self.on_countdown_finish)
        
        self.setup_ui()
        
    def setup_ui(self):
        """UI 설정"""
        # 메인 프레임
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # 타이머 선택
        timer_frame = ttk.LabelFrame(main_frame, text="타이머 선택", padding="5")
        timer_frame.grid(row=0, column=0, columnspan=2, pady=(0, 10), sticky=(tk.W, tk.E))
        
        self.timer_var = tk.StringVar(value="stopwatch")
        ttk.Radiobutton(timer_frame, text="스톱워치", variable=self.timer_var,
                       value="stopwatch", command=self.switch_timer).grid(row=0, column=0, padx=5)
        ttk.Radiobutton(timer_frame, text="카운트다운", variable=self.timer_var,
                       value="countdown", command=self.switch_timer).grid(row=0, column=1, padx=5)
        
        # 카운트다운 설정 (카운트다운 모드에서만 보임)
        self.countdown_frame = ttk.Frame(timer_frame)
        self.countdown_frame.grid(row=1, column=0, columnspan=2, pady=5)
        
        ttk.Label(self.countdown_frame, text="시간 설정:").grid(row=0, column=0)
        self.minutes_var = tk.StringVar(value="5")
        self.seconds_var = tk.StringVar(value="0")
        
        ttk.Spinbox(self.countdown_frame, from_=0, to=59, textvariable=self.minutes_var,
                   width=3).grid(row=0, column=1)
        ttk.Label(self.countdown_frame, text="분").grid(row=0, column=2, padx=(0, 5))
        
        ttk.Spinbox(self.countdown_frame, from_=0, to=59, textvariable=self.seconds_var,
                   width=3).grid(row=0, column=3)
        ttk.Label(self.countdown_frame, text="초").grid(row=0, column=4)
        
        ttk.Button(self.countdown_frame, text="설정", 
                  command=self.set_countdown_time).grid(row=0, column=5, padx=5)
        
        # 시간 표시
        display_frame = ttk.Frame(main_frame)
        display_frame.grid(row=1, column=0, columnspan=2, pady=20)
        
        self.time_label = ttk.Label(display_frame, text="00:00.000", 
                                   font=("Courier", 48, "bold"))
        self.time_label.pack()
        
        # 제어 버튼
        control_frame = ttk.Frame(main_frame)
        control_frame.grid(row=2, column=0, columnspan=2, pady=10)
        
        self.start_button = ttk.Button(control_frame, text="시작", 
                                      command=self.start_timer, width=10)
        self.start_button.grid(row=0, column=0, padx=5)
        
        self.pause_button = ttk.Button(control_frame, text="일시정지", 
                                      command=self.pause_timer, width=10, state="disabled")
        self.pause_button.grid(row=0, column=1, padx=5)
        
        self.lap_button = ttk.Button(control_frame, text="랩 기록", 
                                    command=self.record_lap, width=10, state="disabled")
        self.lap_button.grid(row=0, column=2, padx=5)
        
        self.reset_button = ttk.Button(control_frame, text="초기화", 
                                      command=self.reset_timer, width=10)
        self.reset_button.grid(row=0, column=3, padx=5)
        
        # 랩 타임 목록
        lap_frame = ttk.LabelFrame(main_frame, text="랩 타임 기록", padding="5")
        lap_frame.grid(row=3, column=0, columnspan=2, pady=(10, 0), sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # 트리뷰 생성
        columns = ('랩', '랩타임', '누적시간')
        self.lap_tree = ttk.Treeview(lap_frame, columns=columns, show='headings', height=8)
        
        for col in columns:
            self.lap_tree.heading(col, text=col)
            self.lap_tree.column(col, width=100, anchor='center')
            
        self.lap_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # 스크롤바
        scrollbar = ttk.Scrollbar(lap_frame, orient=tk.VERTICAL, command=self.lap_tree.yview)
        self.lap_tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # 내보내기 버튼
        export_frame = ttk.Frame(main_frame)
        export_frame.grid(row=4, column=0, columnspan=2, pady=10)
        
        ttk.Button(export_frame, text="CSV로 내보내기", 
                  command=lambda: self.export_laps('csv')).grid(row=0, column=0, padx=5)
        ttk.Button(export_frame, text="JSON으로 내보내기", 
                  command=lambda: self.export_laps('json')).grid(row=0, column=1, padx=5)
        
        # 상태 표시줄
        self.status_var = tk.StringVar(value="준비됨")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, relief=tk.SUNKEN)
        status_bar.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
        
        # 그리드 가중치 설정
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(3, weight=1)
        lap_frame.columnconfigure(0, weight=1)
        lap_frame.rowconfigure(0, weight=1)
        
        # 초기 화면 업데이트
        self.update_countdown_visibility()
        
    def switch_timer(self):
        """타이머 전환"""
        timer_type = self.timer_var.get()
        
        # 현재 타이머 정지
        if self.current_timer.state == TimerState.RUNNING:
            self.current_timer.pause()
            
        if timer_type == "stopwatch":
            self.current_timer = self.stopwatch
        else:
            self.current_timer = self.countdown
            
        self.update_display()
        self.update_countdown_visibility()
        self.update_button_states()
        self.clear_lap_list()
        
    def update_countdown_visibility(self):
        """카운트다운 설정 가시성 업데이트"""
        if self.timer_var.get() == "countdown":
            self.countdown_frame.grid()
        else:
            self.countdown_frame.grid_remove()
            
    def set_countdown_time(self):
        """카운트다운 시간 설정"""
        try:
            minutes = int(self.minutes_var.get())
            seconds = int(self.seconds_var.get())
            
            if minutes < 0 or seconds < 0 or seconds >= 60:
                raise ValueError
                
            total_seconds = minutes * 60 + seconds
            
            if total_seconds <= 0:
                raise ValueError
                
            self.countdown.duration = total_seconds
            self.countdown.reset()
            self.update_display()
            self.status_var.set(f"카운트다운 설정: {minutes}분 {seconds}초")
            
        except ValueError:
            messagebox.showerror("오류", "유효한 시간을 입력하세요 (0-59분, 0-59초)")
            
    def start_timer(self):
        """타이머 시작"""
        self.current_timer.start()
        self.update_button_states()
        self.status_var.set("타이머 실행 중")
        
    def pause_timer(self):
        """타이머 일시정지"""
        self.current_timer.pause()
        self.update_button_states()
        self.status_var.set("타이머 일시정지")
        
    def reset_timer(self):
        """타이머 초기화"""
        self.current_timer.reset()
        self.update_display()
        self.update_button_states()
        self.clear_lap_list()
        self.status_var.set("타이머 초기화됨")
        
    def record_lap(self):
        """랩 타임 기록"""
        lap = self.current_timer.lap()
        if lap:
            self.add_lap_to_list(lap)
            self.status_var.set(f"랩 {lap.lap_number} 기록됨")
            
    def update_display(self, elapsed_time=None):
        """시간 표시 업데이트"""
        time_str = self.current_timer.get_formatted_time()
        self.time_label.config(text=time_str)
        
        # 상태에 따른 색상 변경
        if isinstance(self.current_timer, CountdownTimer) and self.current_timer.remaining_time < 10:
            self.time_label.config(foreground='red')
        else:
            self.time_label.config(foreground='black')
            
    def update_button_states(self):
        """버튼 상태 업데이트"""
        state = self.current_timer.state
        
        if state == TimerState.RUNNING:
            self.start_button.config(state="disabled")
            self.pause_button.config(state="normal")
            self.lap_button.config(state="normal")
            self.reset_button.config(state="disabled")
        elif state == TimerState.PAUSED:
            self.start_button.config(text="재개", state="normal")
            self.pause_button.config(state="disabled")
            self.lap_button.config(state="disabled")
            self.reset_button.config(state="normal")
        else:  # STOPPED or FINISHED
            self.start_button.config(text="시작", state="normal")
            self.pause_button.config(state="disabled")
            self.lap_button.config(state="disabled")
            self.reset_button.config(state="normal")
            
    def add_lap_to_list(self, lap: LapTime):
        """랩 타임을 목록에 추가"""
        lap_time_str = f"{lap.lap_time:.3f}"
        total_time_str = f"{lap.total_time:.3f}"
        
        self.lap_tree.insert('', 'end', values=(lap.lap_number, lap_time_str, total_time_str))
        
    def clear_lap_list(self):
        """랩 목록 초기화"""
        for item in self.lap_tree.get_children():
            self.lap_tree.delete(item)
            
    def export_laps(self, format: str):
        """랩 타임 내보내기"""
        if not self.current_timer.lap_times:
            messagebox.showinfo("알림", "내보낼 랩 기록이 없습니다")
            return
            
        file_ext = f".{format}"
        file_path = filedialog.asksaveasfilename(
            defaultextension=file_ext,
            filetypes=[(f"{format.upper()} 파일", f"*{file_ext}")]
        )
        
        if file_path:
            try:
                self.current_timer.export_laps(file_path, format)
                self.status_var.set(f"랩 기록을 {file_path}로 내보냈습니다")
                messagebox.showinfo("성공", f"랩 기록이 성공적으로 내보내졌습니다:\n{file_path}")
            except Exception as e:
                messagebox.showerror("오류", f"내보내기 실패: {e}")
                
    def on_countdown_finish(self):
        """카운트다운 종료 시 호출"""
        self.update_button_states()
        self.status_var.set("카운트다운 완료!")
        messagebox.showinfo("알림", "카운트다운이 완료되었습니다!")
        
    def run(self):
        """애플리케이션 실행"""
        self.root.mainloop()

def demonstrate_stopwatch():
    """스톱워치 데모"""
    print("=== 고급 스톱워치 시스템 ===")
    
    # 콘솔 기반 데모
    print("\n1. 콘솔 기반 스톱워치 데모:")
    
    timer = PrecisionTimer("테스트 타이머")
    
    # 콜백 등록
    def on_tick(elapsed):
        if int(elapsed * 10) % 10 == 0:  # 1초마다 출력
            print(f"\r경과 시간: {timer.get_formatted_time()}", end="")
            
    def on_lap(lap):
        print(f"\n랩 {lap.lap_number}: {lap.lap_time:.3f}초 (총 {lap.total_time:.3f}초)")
        
    timer.register_callback('tick', on_tick)
    timer.register_callback('lap', on_lap)
    
    print("스톱워치 시작 (3초 후 랩 기록, 6초 후 정지)...")
    timer.start()
    time.sleep(3)
    
    timer.lap("첫 번째 랩")
    time.sleep(3)
    
    timer.lap("두 번째 랩")
    timer.stop()
    
    print(f"\n\n총 경과 시간: {timer.get_formatted_time()}")
    print(f"랩 기록 수: {len(timer.lap_times)}")
    
    # 카운트다운 데모
    print("\n2. 카운트다운 타이머 데모:")
    
    countdown = CountdownTimer(5, "5초 타이머")  # 5초 타이머
    
    def on_countdown_tick(elapsed):
        remaining = countdown.get_formatted_time()
        print(f"\r남은 시간: {remaining}", end="")
        
    def on_countdown_finish():
        print("\n카운트다운 완료!")
        
    countdown.register_callback('tick', on_countdown_tick)
    countdown.register_callback('finish', on_countdown_finish)
    
    print("5초 카운트다운 시작...")
    countdown.start()
    
    while countdown.state == TimerState.RUNNING:
        time.sleep(0.1)
        
    print("\n")
    
    # GUI 애플리케이션 실행 (선택적)
    run_gui = input("\nGUI 스톱워치를 실행하시겠습니까? (y/n): ").lower() == 'y'
    
    if run_gui:
        try:
            print("GUI 스톱워치를 시작합니다...")
            app = StopwatchGUI()
            app.run()
        except ImportError:
            print("Tkinter가 설치되지 않았습니다. GUI를 실행할 수 없습니다.")

# 스톱워치 데모 실행
demonstrate_stopwatch()
```

## 메모리와 CPU 사용 제한 시스템

### 리소스 제한과 모니터링 프레임워크

```python
import resource
import psutil
import signal
import os
import sys
import time
import threading
from typing import Optional, Callable, Dict, Any
from dataclasses import dataclass
from contextlib import contextmanager
from enum import Enum

class ResourceType(Enum):
    """리소스 타입"""
    CPU_TIME = "cpu_time"
    MEMORY = "memory"
    FILE_SIZE = "file_size"
    PROCESS_COUNT = "process_count"
    WALL_CLOCK_TIME = "wall_clock_time"

@dataclass
class ResourceLimit:
    """리소스 제한 설정"""
    resource_type: ResourceType
    soft_limit: float  # 소프트 제한 (초과 시 경고)
    hard_limit: float  # 하드 제한 (초과 시 중단)
    action: str = "warn"  # warn, terminate, throttle
    
class ResourceMonitor:
    """리소스 사용량 모니터"""
    
    def __init__(self, pid: Optional[int] = None):
        self.pid = pid or os.getpid()
        self.process = psutil.Process(self.pid)
        self.monitoring = False
        self.monitor_thread: Optional[threading.Thread] = None
        self.limits: Dict[ResourceType, ResourceLimit] = {}
        self.callbacks: Dict[ResourceType, List[Callable]] = {}
        self.usage_history: Dict[ResourceType, List[float]] = {}
        
    def set_limit(self, limit: ResourceLimit):
        """리소스 제한 설정"""
        self.limits[limit.resource_type] = limit
        
    def set_resource_limit(self, resource_type: ResourceType, 
                          soft: float, hard: float, action: str = "warn"):
        """리소스 제한 설정 (간편 메서드)"""
        self.set_limit(ResourceLimit(resource_type, soft, hard, action))
        
    def register_callback(self, resource_type: ResourceType, 
                         callback: Callable[[float, ResourceLimit], None]):
        """콜백 함수 등록"""
        if resource_type not in self.callbacks:
            self.callbacks[resource_type] = []
        self.callbacks[resource_type].append(callback)
        
    def get_current_usage(self, resource_type: ResourceType) -> float:
        """현재 리소스 사용량 조회"""
        try:
            if resource_type == ResourceType.CPU_TIME:
                # CPU 시간 (초)
                times = self.process.cpu_times()
                return times.user + times.system
                
            elif resource_type == ResourceType.MEMORY:
                # 메모리 사용량 (MB)
                mem_info = self.process.memory_info()
                return mem_info.rss / (1024 * 1024)  # MB 단위
                
            elif resource_type == ResourceType.WALL_CLOCK_TIME:
                # 경과 시간 (초)
                return time.time() - self.process.create_time()
                
            elif resource_type == ResourceType.PROCESS_COUNT:
                # 자식 프로세스 수
                return len(self.process.children(recursive=True))
                
            else:
                return 0.0
                
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            return 0.0
            
    def check_limits(self) -> Dict[ResourceType, str]:
        """리소스 제한 검사"""
        violations = {}
        
        for resource_type, limit in self.limits.items():
            current_usage = self.get_current_usage(resource_type)
            
            # 사용 기록 저장
            if resource_type not in self.usage_history:
                self.usage_history[resource_type] = []
            self.usage_history[resource_type].append(current_usage)
            
            # 제한 초과 검사
            if current_usage >= limit.hard_limit:
                violations[resource_type] = "hard_limit_exceeded"
                self._take_action(resource_type, current_usage, limit, "hard")
                
            elif current_usage >= limit.soft_limit:
                violations[resource_type] = "soft_limit_exceeded"
                self._take_action(resource_type, current_usage, limit, "soft")
                
        return violations
        
    def _take_action(self, resource_type: ResourceType, current_usage: float,
                    limit: ResourceLimit, limit_type: str):
        """제한 초과 시 조치 취하기"""
        # 콜백 호출
        if resource_type in self.callbacks:
            for callback in self.callbacks[resource_type]:
                try:
                    callback(current_usage, limit)
                except Exception as e:
                    print(f"콜백 실행 오류: {e}")
                    
        # 설정된 조치 수행
        if limit.action == "terminate" and limit_type == "hard":
            print(f"리소스 제한 초과로 프로세스 종료: {resource_type.value}")
            os.kill(self.pid, signal.SIGTERM)
            
        elif limit.action == "throttle":
            self._throttle_resource(resource_type)
            
    def _throttle_resource(self, resource_type: ResourceType):
        """리소스 스로틀링"""
        if resource_type == ResourceType.CPU_TIME:
            # CPU 사용량 제한 (간단한 sleep으로 구현)
            time.sleep(0.1)
            
    def start_monitoring(self, interval: float = 1.0):
        """모니터링 시작"""
        if self.monitoring:
            return
            
        self.monitoring = True
        self.monitor_thread = threading.Thread(
            target=self._monitoring_loop,
            args=(interval,),
            daemon=True
        )
        self.monitor_thread.start()
        
    def _monitoring_loop(self, interval: float):
        """모니터링 루프"""
        while self.monitoring:
            violations = self.check_limits()
            
            if violations:
                print(f"리소스 제한 위반: {violations}")
                
            time.sleep(interval)
            
    def stop_monitoring(self):
        """모니터링 정지"""
        self.monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=2)
            
    def get_usage_statistics(self, resource_type: ResourceType) -> Dict[str, Any]:
        """사용량 통계 조회"""
        if resource_type not in self.usage_history:
            return {}
            
        history = self.usage_history[resource_type]
        if not history:
            return {}
            
        return {
            'current': history[-1],
            'average': sum(history) / len(history),
            'maximum': max(history),
            'minimum': min(history),
            'samples': len(history)
        }
        
    def apply_system_limits(self):
        """시스템 리소스 제한 적용"""
        try:
            # 메모리 제한 설정 (RLIMIT_AS: 주소 공간 크기)
            if ResourceType.MEMORY in self.limits:
                limit = self.limits[ResourceType.MEMORY]
                # 바이트 단위로 변환
                memory_bytes = int(limit.hard_limit * 1024 * 1024)  # MB -> bytes
                resource.setrlimit(resource.RLIMIT_AS, (memory_bytes, memory_bytes))
                
            # CPU 시간 제한 설정
            if ResourceType.CPU_TIME in self.limits:
                limit = self.limits[ResourceType.CPU_TIME]
                cpu_seconds = int(limit.hard_limit)
                resource.setrlimit(resource.RLIMIT_CPU, (cpu_seconds, cpu_seconds))
                
            # 파일 크기 제한 설정
            if ResourceType.FILE_SIZE in self.limits:
                limit = self.limits[ResourceType.FILE_SIZE]
                file_size = int(limit.hard_limit * 1024 * 1024)  # MB -> bytes
                resource.setrlimit(resource.RLIMIT_FSIZE, (file_size, file_size))
                
        except (ValueError, resource.error) as e:
            print(f"시스템 리소스 제한 설정 오류: {e}")

class MemoryIntensiveTask:
    """메모리 집약적 작업 (데모용)"""
    
    def __init__(self, size_mb: int = 100):
        self.size_mb = size_mb
        self.data = []
        
    def run(self, duration: float = 5.0):
        """메모리 사용 작업 실행"""
        print(f"메모리 사용 작업 시작: {self.size_mb}MB 할당 시도")
        start_time = time.time()
        
        try:
            # 메모리 할당 (MB 단위)
            chunk_size = 1024 * 1024  # 1MB
            chunks_to_allocate = self.size_mb
            
            for i in range(chunks_to_allocate):
                # 1MB 청크 할당
                self.data.append(bytearray(chunk_size))
                
                # 진행 상황 출력
                if (i + 1) % 10 == 0:
                    elapsed = time.time() - start_time
                    print(f"할당된 메모리: {i + 1}MB, 경과 시간: {elapsed:.1f}초")
                    
                # 작업 지속 시간 제한
                if time.time() - start_time > duration:
                    break
                    
                time.sleep(0.01)  # 약간의 지연
                
        except MemoryError:
            print("메모리 할당 실패: 시스템 메모리 부족")
            
        finally:
            # 메모리 해제
            self.data.clear()
            print("메모리 해제 완료")
            
@contextmanager
def resource_guard(limits: Dict[ResourceType, ResourceLimit]):
    """리소스 제한 컨텍스트 관리자"""
    monitor = ResourceMonitor()
    
    # 제한 설정
    for limit in limits.values():
        monitor.set_limit(limit)
        
    # 시스템 제한 적용
    monitor.apply_system_limits()
    
    # 모니터링 시작
    monitor.start_monitoring(interval=0.5)
    
    try:
        yield monitor
    finally:
        monitor.stop_monitoring()
        
def demonstrate_resource_limiting():
    """리소스 제한 데모"""
    print("\n=== 메모리 및 CPU 사용 제한 시스템 ===")
    
    # 1. 기본 모니터링 데모
    print("\n1. 리소스 모니터링 데모:")
    
    monitor = ResourceMonitor()
    
    # 제한 설정
    monitor.set_resource_limit(
        ResourceType.MEMORY,
        soft=50,    # 50MB 소프트 제한
        hard=100,   # 100MB 하드 제한
        action="warn"
    )
    
    monitor.set_resource_limit(
        ResourceType.CPU_TIME,
        soft=2,     # 2초 소프트 제한
        hard=5,     # 5초 하드 제한  
        action="warn"
    )
    
    monitor.set_resource_limit(
        ResourceType.WALL_CLOCK_TIME,
        soft=3,     # 3초 소프트 제한
        hard=10,    # 10초 하드 제한
        action="terminate"
    )
    
    # 콜백 등록
    def on_memory_warning(usage, limit):
        print(f"⚠️  메모리 사용량 경고: {usage:.1f}MB (제한: {limit.soft_limit}MB)")
        
    def on_cpu_warning(usage, limit):
        print(f"⚠️  CPU 시간 경고: {usage:.1f}초 (제한: {limit.soft_limit}초)")
        
    monitor.register_callback(ResourceType.MEMORY, on_memory_warning)
    monitor.register_callback(ResourceType.CPU_TIME, on_cpu_warning)
    
    # 모니터링 시작
    monitor.start_monitoring(interval=0.5)
    
    print("모니터링 시작 (5초간 실행)...")
    
    # CPU 집약적 작업 시뮬레이션
    start_time = time.time()
    while time.time() - start_time < 5:
        # 간단한 CPU 작업
        _ = [i * i for i in range(10000)]
        
        # 메모리 사용 증가 시뮬레이션
        if time.time() - start_time > 2:
            # 2초 후 메모리 할당 시작
            data = bytearray(10 * 1024 * 1024)  # 10MB
            
        time.sleep(0.1)
        
    monitor.stop_monitoring()
    
    # 통계 출력
    print("\n리소스 사용 통계:")
    for resource_type in [ResourceType.MEMORY, ResourceType.CPU_TIME]:
        stats = monitor.get_usage_statistics(resource_type)
        if stats:
            print(f"{resource_type.value}:")
            print(f"  최대: {stats['maximum']:.1f}, 평균: {stats['average']:.1f}")
            
    # 2. 메모리 제한 데모
    print("\n2. 메모리 제한 데모:")
    
    # 컨텍스트 관리자를 사용한 리소스 제한
    limits = {
        ResourceType.MEMORY: ResourceLimit(
            ResourceType.MEMORY,
            soft=50,
            hard=80,
            action="terminate"
        )
    }
    
    try:
        with resource_guard(limits) as guard:
            print("메모리 제한 적용됨 (최대 80MB)")
            
            # 메모리 집약적 작업 실행
            task = MemoryIntensiveTask(size_mb=100)  # 100MB 시도
            task.run(duration=3)
            
    except SystemExit:
        print("프로세스가 메모리 제한으로 인해 종료되었습니다")
        
    # 3. 실제 애플리케이션 예제
    print("\n3. 배치 작업 리소스 제한 예제:")
    
    class BatchProcessor:
        def __init__(self):
            self.monitor = ResourceMonitor()
            
        def process_files(self, files):
            """파일 처리 배치 작업"""
            # 리소스 제한 설정
            self.monitor.set_resource_limit(
                ResourceType.MEMORY,
                soft=512,  # 512MB
                hard=1024, # 1GB
                action="throttle"
            )
            
            self.monitor.set_resource_limit(
                ResourceType.WALL_CLOCK_TIME,
                soft=300,  # 5분
                hard=600,  # 10분
                action="terminate"
            )
            
            # 모니터링 시작
            self.monitor.start_monitoring()
            
            try:
                results = []
                for i, file in enumerate(files, 1):
                    print(f"처리 중: {file} ({i}/{len(files)})")
                    
                    # 파일 처리 시뮬레이션
                    time.sleep(0.5)
                    
                    # 메모리 사용 시뮬레이션
                    if i % 10 == 0:
                        data = bytearray(50 * 1024 * 1024)  # 50MB 할당
                        
                    results.append(f"처리됨: {file}")
                    
                return results
                
            finally:
                self.monitor.stop_monitoring()
                
    # 배치 프로세서 테스트
    processor = BatchProcessor()
    test_files = [f"파일{i}.txt" for i in range(1, 21)]
    
    print(f"{len(test_files)}개 파일 처리 시작...")
    results = processor.process_files(test_files[:5])  # 5개만 테스트
    print(f"처리 완료: {len(results)}개 파일")
    
    # 4. 다중 프로세스 리소스 제한
    print("\n4. 다중 프로세스 리소스 제한:")
    
    import multiprocessing as mp
    
    def worker_process(limit_mb: int):
        """제한된 메모리를 사용하는 작업자 프로세스"""
        # 프로세스별 모니터 생성
        monitor = ResourceMonitor()
        monitor.set_resource_limit(
            ResourceType.MEMORY,
            soft=limit_mb * 0.8,
            hard=limit_mb,
            action="terminate"
        )
        
        monitor.apply_system_limits()
        monitor.start_monitoring()
        
        print(f"작업자 시작 (메모리 제한: {limit_mb}MB)")
        
        try:
            # 메모리 사용
            data = []
            chunk_size = 5 * 1024 * 1024  # 5MB
            
            for i in range(limit_mb // 5):
                data.append(bytearray(chunk_size))
                print(f"작업자: {len(data) * 5}MB 할당")
                time.sleep(0.5)
                
        except MemoryError:
            print("작업자: 메모리 제한 도달")
            
        finally:
            monitor.stop_monitoring()
            
    # 다중 프로세스 실행
    print("다중 프로세스 리소스 제한 테스트...")
    processes = []
    
    for i in range(3):
        p = mp.Process(target=worker_process, args=(50,))  # 각각 50MB 제한
        processes.append(p)
        p.start()
        
    for p in processes:
        p.join()
        
    print("모든 작업자 프로세스 완료")

# 리소스 제한 데모 실행
demonstrate_resource_limiting()
```

## 웹 브라우저 실행 및 제어 시스템

### 크로스 플랫폼 웹 브라우저 통합

```python
import webbrowser
import subprocess
import threading
import queue
import time
from typing import Optional, List, Dict, Any, Callable
from dataclasses import dataclass
from enum import Enum
import json
import urllib.parse
import tempfile
import os
from pathlib import Path

class BrowserType(Enum):
    """브라우저 타입"""
    SYSTEM_DEFAULT = "default"
    CHROME = "chrome"
    FIREFOX = "firefox"
    SAFARI = "safari"
    EDGE = "edge"
    BRAVE = "brave"
    CUSTOM = "custom"

@dataclass
class BrowserProfile:
    """브라우저 프로파일 설정"""
    name: str
    path: Optional[str] = None
    user_data_dir: Optional[str] = None
    arguments: List[str] = None
    
    def __post_init__(self):
        if self.arguments is None:
            self.arguments = []

class AdvancedBrowserController:
    """고급 브라우저 컨트롤러"""
    
    # 브라우저 실행 파일 경로 (플랫폼별)
    BROWSER_PATHS = {
        'windows': {
            BrowserType.CHROME: [
                r"C:\Program Files\Google\Chrome\Application\chrome.exe",
                r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"
            ],
            BrowserType.FIREFOX: [
                r"C:\Program Files\Mozilla Firefox\firefox.exe",
                r"C:\Program Files (x86)\Mozilla Firefox\firefox.exe"
            ],
            BrowserType.EDGE: [
                r"C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe",
                r"C:\Program Files\Microsoft\Edge\Application\msedge.exe"
            ]
        },
        'darwin': {  # macOS
            BrowserType.CHROME: [
                "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
            ],
            BrowserType.FIREFOX: [
                "/Applications/Firefox.app/Contents/MacOS/firefox"
            ],
            BrowserType.SAFARI: [
                "/Applications/Safari.app/Contents/MacOS/Safari"
            ],
            BrowserType.EDGE: [
                "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge"
            ]
        },
        'linux': {
            BrowserType.CHROME: [
                "/usr/bin/google-chrome",
                "/usr/bin/chromium-browser"
            ],
            BrowserType.FIREFOX: [
                "/usr/bin/firefox"
            ]
        }
    }
    
    def __init__(self, browser_type: BrowserType = BrowserType.SYSTEM_DEFAULT):
        self.browser_type = browser_type
        self.profiles: Dict[str, BrowserProfile] = {}
        self.processes: Dict[str, subprocess.Popen] = {}
        self.system = sys.platform
        
    def detect_browser_path(self, browser_type: BrowserType) -> Optional[str]:
        """브라우저 실행 파일 경로 자동 감지"""
        system_key = 'windows' if 'win' in self.system else \
                    'darwin' if self.system == 'darwin' else 'linux'
        
        if browser_type == BrowserType.SYSTEM_DEFAULT:
            # 시스템 기본 브라우저는 webbrowser 모듈 사용
            try:
                browser = webbrowser.get()
                if hasattr(browser, 'name'):
                    return browser.name
            except:
                pass
            return None
        
        if browser_type in self.BROWSER_PATHS.get(system_key, {}):
            for path in self.BROWSER_PATHS[system_key][browser_type]:
                if os.path.exists(path):
                    return path
        
        # 환경 변수에서 탐색
        if browser_type == BrowserType.CHROME:
            env_path = os.environ.get('CHROME_PATH')
            if env_path and os.path.exists(env_path):
                return env_path
        
        return None
    
    def create_profile(self, name: str, user_data_dir: Optional[str] = None,
                      arguments: Optional[List[str]] = None) -> BrowserProfile:
        """브라우저 프로파일 생성"""
        if user_data_dir is None:
            # 임시 디렉토리 생성
            temp_dir = tempfile.mkdtemp(prefix=f"browser_profile_{name}_")
            user_data_dir = temp_dir
        
        profile = BrowserProfile(
            name=name,
            user_data_dir=user_data_dir,
            arguments=arguments or []
        )
        
        self.profiles[name] = profile
        return profile
    
    def open_url(self, url: str, profile_name: Optional[str] = None,
                new_window: bool = True, incognito: bool = False,
                additional_args: Optional[List[str]] = None) -> Optional[subprocess.Popen]:
        """URL을 브라우저에서 열기"""
        
        # URL 유효성 검사
        if not url.startswith(('http://', 'https://', 'file://', 'ftp://')):
            url = 'http://' + url
        
        if self.browser_type == BrowserType.SYSTEM_DEFAULT:
            # 시스템 기본 브라우저 사용
            try:
                browser = webbrowser.get()
                if new_window:
                    browser.open_new(url)
                else:
                    browser.open(url)
                return None
            except webbrowser.Error as e:
                print(f"시스템 브라우저 오류: {e}")
                return None
        
        # 브라우저 실행 파일 경로 찾기
        browser_path = self.detect_browser_path(self.browser_type)
        if not browser_path:
            print(f"{self.browser_type.value} 브라우저를 찾을 수 없습니다")
            return None
        
        # 명령어 인자 구성
        args = [browser_path]
        
        # 프로파일 설정
        if profile_name and profile_name in self.profiles:
            profile = self.profiles[profile_name]
            
            # 사용자 데이터 디렉토리
            if profile.user_data_dir:
                if self.browser_type in [BrowserType.CHROME, BrowserType.EDGE, BrowserType.BRAVE]:
                    args.append(f"--user-data-dir={profile.user_data_dir}")
                elif self.browser_type == BrowserType.FIREFOX:
                    args.append(f"-profile")
                    args.append(profile.user_data_dir)
            
            # 프로파일별 추가 인자
            args.extend(profile.arguments)
        
        # 시크릿 모드
        if incognito:
            if self.browser_type in [BrowserType.CHROME, BrowserType.EDGE, BrowserType.BRAVE]:
                args.append("--incognito")
            elif self.browser_type == BrowserType.FIREFOX:
                args.append("--private-window")
        
        # 새 창
        if new_window:
            if self.browser_type in [BrowserType.CHROME, BrowserType.EDGE, BrowserType.BRAVE]:
                args.append("--new-window")
        
        # 추가 인자
        if additional_args:
            args.extend(additional_args)
        
        # URL 추가
        args.append(url)
        
        # 브라우저 실행
        try:
            process = subprocess.Popen(
                args,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            # 프로세스 추적
            if profile_name:
                self.processes[profile_name] = process
            
            # 비동기 출력 읽기
            threading.Thread(
                target=self._read_process_output,
                args=(process, profile_name or "default"),
                daemon=True
            ).start()
            
            return process
            
        except Exception as e:
            print(f"브라우저 실행 오류: {e}")
            return None
    
    def _read_process_output(self, process: subprocess.Popen, name: str):
        """브라우저 프로세스 출력 읽기"""
        while True:
            if process.stdout:
                line = process.stdout.readline()
                if line:
                    print(f"[{name}] {line.strip()}")
                else:
                    break
            time.sleep(0.1)
    
    def open_multiple_urls(self, urls: List[str], profile_name: Optional[str] = None,
                          tabs: bool = False, delay: float = 0.5) -> List[subprocess.Popen]:
        """여러 URL 열기"""
        processes = []
        
        for i, url in enumerate(urls):
            if i > 0 and tabs:
                # 탭으로 열기 (같은 창)
                additional_args = []
                if self.browser_type in [BrowserType.CHROME, BrowserType.EDGE]:
                    additional_args = ["--new-tab"]
                
                process = self.open_url(
                    url, profile_name, 
                    new_window=False,
                    additional_args=additional_args
                )
            else:
                # 새 창으로 열기
                process = self.open_url(url, profile_name, new_window=True)
            
            if process:
                processes.append(process)
            
            # 지연
            if i < len(urls) - 1:
                time.sleep(delay)
        
        return processes
    
    def generate_html_file(self, content: str, title: str = "Generated Page") -> str:
        """HTML 파일 생성 및 경로 반환"""
        html_template = f"""
        <!DOCTYPE html>
        <html lang="ko">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{title}</title>
            <style>
                body {{
                    font-family: Arial, sans-serif;
                    max-width: 800px;
                    margin: 0 auto;
                    padding: 20px;
                    line-height: 1.6;
                }}
                .container {{
                    background-color: #f5f5f5;
                    border-radius: 10px;
                    padding: 20px;
                    margin-top: 20px;
                }}
                .timestamp {{
                    color: #666;
                    font-size: 0.9em;
                    text-align: right;
                }}
            </style>
        </head>
        <body>
            <h1>{title}</h1>
            <div class="container">
                {content}
            </div>
            <div class="timestamp">
                생성 시간: {time.strftime('%Y-%m-%d %H:%M:%S')}
            </div>
        </body>
        </html>
        """
        
        # 임시 파일 생성
        temp_file = tempfile.NamedTemporaryFile(
            mode='w', 
            suffix='.html', 
            encoding='utf-8',
            delete=False
        )
        
        temp_file.write(html_template)
        temp_file.close()
        
        return f"file://{temp_file.name}"
    
    def take_screenshot(self, url: str, output_path: str, 
                       profile_name: Optional[str] = None,
                       width: int = 1280, height: int = 720) -> bool:
        """웹페이지 스크린샷 찍기 (헤드리스 브라우저 사용)"""
        try:
            # Chrome/Edge의 헤드리스 모드 사용
            if self.browser_type not in [BrowserType.CHROME, BrowserType.EDGE]:
                print("스크린샷은 Chrome/Edge 브라우저에서만 지원됩니다")
                return False
            
            browser_path = self.detect_browser_path(self.browser_type)
            if not browser_path:
                return False
            
            # JavaScript로 스크린샷을 찍는 HTML 생성
            screenshot_html = f"""
            <!DOCTYPE html>
            <html>
            <head>
                <script>
                    window.onload = function() {{
                        // 페이지 로드 후 스크린샷 준비
                        setTimeout(function() {{
                            html2canvas(document.body).then(canvas => {{
                                // 데이터 URL 생성
                                var imgData = canvas.toDataURL('image/png');
                                
                                // 서버로 전송 (여기서는 로컬 파일로 저장)
                                var link = document.createElement('a');
                                link.download = 'screenshot.png';
                                link.href = imgData;
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                                
                                // 완료 신호
                                window.screenshotComplete = true;
                            }});
                        }}, 2000);
                    }};
                </script>
                <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
            </head>
            <body>
                <iframe src="{url}" width="100%" height="100%" 
                       style="border: none; width: {width}px; height: {height}px;">
                </iframe>
            </body>
            </html>
            """
            
            # 임시 HTML 파일 생성
            temp_html = self.generate_html_file(screenshot_html, "스크린샷 페이지")
            
            # 헤드리스 브라우저 실행
            args = [
                browser_path,
                "--headless",  # 헤드리스 모드
                "--disable-gpu",
                f"--window-size={width},{height}",
                "--screenshot",  # Chrome의 스크린샷 기능
                f"--screenshot={output_path}",
                url
            ]
            
            # 프로파일 설정
            if profile_name and profile_name in self.profiles:
                profile = self.profiles[profile_name]
                if profile.user_data_dir:
                    args.append(f"--user-data-dir={profile.user_data_dir}")
            
            # 브라우저 실행
            result = subprocess.run(
                args,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                print(f"스크린샷 저장됨: {output_path}")
                return True
            else:
                print(f"스크린샷 실패: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"스크린샷 오류: {e}")
            return False
    
    def close_profile(self, profile_name: str):
        """프로파일 브라우저 종료"""
        if profile_name in self.processes:
            process = self.processes[profile_name]
            try:
                process.terminate()
                process.wait(timeout=5)
                print(f"프로파일 '{profile_name}' 브라우저 종료됨")
            except subprocess.TimeoutExpired:
                process.kill()
                print(f"프로파일 '{profile_name}' 브라우저 강제 종료됨")
            finally:
                del self.processes[profile_name]
    
    def cleanup_profiles(self):
        """모든 프로파일 정리"""
        for profile_name in list(self.processes.keys()):
            self.close_profile(profile_name)
        
        # 임시 디렉토리 정리
        for profile in self.profiles.values():
            if profile.user_data_dir and "tmp" in profile.user_data_dir:
                try:
                    import shutil
                    shutil.rmtree(profile.user_data_dir, ignore_errors=True)
                    print(f"임시 디렉토리 삭제됨: {profile.user_data_dir}")
                except:
                    pass

class WebAutomation:
    """웹 자동화 클래스"""
    
    def __init__(self, browser_controller: AdvancedBrowserController):
        self.controller = browser_controller
        self.automation_queue = queue.Queue()
        self.is_running = False
        
    def add_task(self, task_type: str, **kwargs):
        """자동화 작업 추가"""
        self.automation_queue.put({
            'type': task_type,
            'data': kwargs,
            'timestamp': time.time()
        })
    
    def start_automation(self, interval: float = 1.0):
        """자동화 시작"""
        self.is_running = True
        
        def automation_worker():
            while self.is_running:
                try:
                    task = self.automation_queue.get(timeout=0.5)
                    self._execute_task(task)
                    self.automation_queue.task_done()
                except queue.Empty:
                    continue
                except Exception as e:
                    print(f"작업 실행 오류: {e}")
        
        # 작업자 스레드 시작
        threading.Thread(target=automation_worker, daemon=True).start()
    
    def _execute_task(self, task: Dict[str, Any]):
        """작업 실행"""
        task_type = task['type']
        data = task['data']
        
        if task_type == 'open_url':
            url = data.get('url', '')
            profile = data.get('profile')
            self.controller.open_url(url, profile)
            
        elif task_type == 'batch_open':
            urls = data.get('urls', [])
            profile = data.get('profile')
            tabs = data.get('tabs', False)
            self.controller.open_multiple_urls(urls, profile, tabs)
            
        elif task_type == 'screenshot':
            url = data.get('url', '')
            output = data.get('output_path', f'screenshot_{int(time.time())}.png')
            self.controller.take_screenshot(url, output)
            
        elif task_type == 'generate_and_open':
            content = data.get('content', '')
            title = data.get('title', 'Generated Page')
            html_file = self.controller.generate_html_file(content, title)
            self.controller.open_url(html_file)
    
    def stop_automation(self):
        """자동화 정지"""
        self.is_running = False

def demonstrate_browser_control():
    """브라우저 제어 데모"""
    print("\n=== 웹 브라우저 실행 및 제어 시스템 ===")
    
    # 1. 기본 브라우저 제어
    print("\n1. 기본 브라우저 제어:")
    
    controller = AdvancedBrowserController(BrowserType.SYSTEM_DEFAULT)
    
    # 프로파일 생성
    test_profile = controller.create_profile(
        name="테스트프로파일",
        arguments=["--disable-notifications"]  # 알림 비활성화
    )
    
    print(f"프로파일 생성됨: {test_profile.name}")
    print(f"사용자 데이터 디렉토리: {test_profile.user_data_dir}")
    
    # URL 열기
    print("\n브라우저에서 URL 열기...")
    urls_to_open = [
        "https://www.google.com",
        "https://github.com",
        "https://stackoverflow.com"
    ]
    
    # 첫 번째 URL은 새 창으로
    process1 = controller.open_url(
        urls_to_open[0],
        profile_name="테스트프로파일",
        new_window=True
    )
    
    if process1:
        print(f"프로세스 시작됨 (PID: {process1.pid})")
    
    # 나머지 URL은 탭으로 열기 (약간의 지연을 두고)
    time.sleep(2)
    
    for url in urls_to_open[1:]:
        controller.open_url(
            url,
            profile_name="테스트프로파일",
            new_window=False,
            additional_args=["--new-tab"]
        )
        time.sleep(1)
    
    # 2. HTML 파일 생성 및 열기
    print("\n2. HTML 파일 생성 및 열기:")
    
    sample_content = """
    <h2>동적으로 생성된 페이지</h2>
    <p>이 페이지는 파이썬으로 동적으로 생성되었습니다.</p>
    <ul>
        <li>항목 1: 파이썬 브라우저 제어</li>
        <li>항목 2: HTML 생성</li>
        <li>항목 3: 자동화 테스트</li>
    </ul>
    <div style="background-color: #e0f7fa; padding: 15px; border-radius: 5px;">
        <strong>참고:</strong> 이 콘텐츠는 임시 파일로 생성되었습니다.
    </div>
    """
    
    html_file_url = controller.generate_html_file(
        content=sample_content,
        title="파이썬 생성 페이지"
    )
    
    print(f"생성된 HTML 파일: {html_file_url}")
    
    # 생성된 HTML 파일 열기
    controller.open_url(html_file_url, new_window=True)
    
    # 3. 웹 자동화 데모
    print("\n3. 웹 자동화 데모:")
    
    automation = WebAutomation(controller)
    automation.start_automation()
    
    # 여러 작업 추가
    automation.add_task('open_url', url='https://www.python.org')
    time.sleep(2)
    
    automation.add_task('batch_open', 
                       urls=['https://docs.python.org', 'https://pypi.org'],
                       tabs=True)
    
    # 잠시 대기 후 정리
    time.sleep(5)
    automation.stop_automation()
    
    # 4. 특정 브라우저 타입 사용 (Chrome)
    print("\n4. 특정 브라우저 사용 (Chrome):")
    
    chrome_controller = AdvancedBrowserController(BrowserType.CHROME)
    chrome_path = chrome_controller.detect_browser_path(BrowserType.CHROME)
    
    if chrome_path:
        print(f"Chrome 경로 발견: {chrome_path}")
        
        # 시크릿 모드로 열기
        chrome_controller.open_url(
            "https://www.example.com",
            incognito=True,
            new_window=True
        )
    else:
        print("Chrome 브라우저를 찾을 수 없습니다.")
    
    # 5. 브라우저 정리
    print("\n5. 브라우저 정리...")
    
    # 잠시 대기 후 브라우저 종료
    wait_time = 10
    print(f"{wait_time}초 후 브라우저를 정리합니다...")
    
    # 사용자 입력 대기 (실제 환경에서는 필요에 따라 조정)
    for i in range(wait_time, 0, -1):
        print(f"\r{i}초 남음...", end="")
        time.sleep(1)
    print()
    
    controller.cleanup_profiles()
    print("모든 브라우저 프로세스 정리 완료")
    
    # 6. 크로스 플랫폼 브라우저 탐색
    print("\n6. 크로스 플랫폼 브라우저 탐색:")
    
    for browser_type in [BrowserType.CHROME, BrowserType.FIREFOX, BrowserType.EDGE]:
        test_controller = AdvancedBrowserController(browser_type)
        browser_path = test_controller.detect_browser_path(browser_type)
        
        if browser_path:
            print(f"{browser_type.value}: 발견됨 ({browser_path})")
        else:
            print(f"{browser_type.value}: 발견되지 않음")

# 브라우저 제어 데모 실행
demonstrate_browser_control()
```

## 결론

파이썬을 활용한 시스템 프로그래밍은 운영체제의 다양한 기능과 깊게 상호작용할 수 있는 강력한 능력을 제공합니다. 효과적인 시스템 도구 개발을 위한 핵심 원칙은 다음과 같습니다:

1. **정밀한 시간 관리**: `time.perf_counter()`를 사용한 고정밀 타이밍, 다중 콜백 시스템, 상태 관리로 다양한 타이머 요구사항을 충족시킬 수 있어야 합니다.

2. **리소스 제한과 모니터링**: `resource` 모듈과 `psutil` 라이브러리를 조합하여 메모리, CPU 시간, 파일 크기 등을 제한하고 실시간으로 모니터링할 수 있어야 합니다.

3. **크로스 플랫폼 외부 프로세스 제어**: `webbrowser`, `subprocess` 모듈을 활용하여 플랫폼별 차이를 추상화하고 일관된 인터페이스로 외부 애플리케이션을 제어할 수 있어야 합니다.

4. **안정성과 견고성**: 예외 처리, 자원 정리, 타임아웃 관리로 시스템 도구의 안정성을 보장해야 합니다.

5. **사용자 친화적 인터페이스**: CLI와 GUI를 모두 지원하며, 상황에 맞는 적절한 피드백과 로깅을 제공해야 합니다.

실제 프로덕션 환경에서는 다음과 같은 추가 고려사항이 필요합니다:
- 보안: 민감한 데이터 처리, 권한 관리, 샌드박싱
- 성능: 비동기 처리, 메모리 최적화, 지연 시간 최소화
- 로깅과 모니터링: 구조화된 로깅, 성능 메트릭 수집, 경고 시스템
- 유지보수성: 모듈화 설계, 테스트 용이성, 문서화
- 호환성: 다양한 OS 버전, 파이썬 버전, 의존성 관리

이러한 원칙과 기술들을 적용하면 시스템 모니터링 도구, 배치 작업 관리자, 웹 자동화 시스템, 리소스 제한 유틸리티 등 다양한 실용적인 시스템 소프트웨어를 개발할 수 있습니다. 파이썬의 풍부한 생태계와 함께하면 복잡한 시스템 작업도 효율적이고 안정적으로 처리할 수 있는 강력한 도구들을 구축할 수 있습니다.