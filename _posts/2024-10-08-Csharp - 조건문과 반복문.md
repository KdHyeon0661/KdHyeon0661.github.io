---
layout: post
title: C# - 조건문과 반복문
date: 2024-10-08 19:20:23 +0900
category: Csharp
---
# 조건문과 반복문

## 0. 빠른 개요 (TL;DR)

- 조건 분기: `if/else`—단순 조건, `switch`—다중 분기/패턴 매칭/가독성.  
- **switch 표현식**: 간결한 값 변환에 최적.  
- 반복: **정해진 횟수**는 `for`, **조건 기반**은 `while`/`do-while`, **컬렉션 순회**는 `foreach`.  
- 실무 포인트: **컬렉션 수정 중 foreach 금지**, **취소 토큰과 async 반복**, **성능 민감 구간에서 for vs foreach 선택**.

---

## 1. 조건문 (if / else if / else)

```csharp
int score = 85;

if (score >= 90)
{
    Console.WriteLine("A");
}
else if (score >= 80)
{
    Console.WriteLine("B");
}
else
{
    Console.WriteLine("C 이하");
}
```

### 1.1 복합 조건 & 가독성 팁

```csharp
int age = 20;
bool hasTicket = true;

// 복합 조건은 "긍정형"으로 표현하는 것이 읽기 쉬움
if (age >= 18 && hasTicket)
{
    Console.WriteLine("입장 가능");
}
```

- **부정 논리의 중첩**(e.g., `!(a || !b)`)보다 **긍정 논리**(`a && b`)로 바꾸면 유지보수성이 높아집니다.

### 1.2 가드(early return)로 중첩 줄이기

```csharp
bool Validate(User u)
{
    if (u is null) return false;
    if (!u.IsActive) return false;
    if (u.Age < 18) return false;
    return true;
}
```

---

## 2. 삼항 연산자 `?:`

```csharp
int num = 10;
string result = (num % 2 == 0) ? "짝수" : "홀수";
Console.WriteLine(result);
```

- **중첩 삼항**은 읽기 어렵습니다. 2~3개 이상의 분기는 `switch`가 낫습니다.

---

## 3. switch문 — 기본형에서 **패턴 매칭**까지

```csharp
int menu = 2;

switch (menu)
{
    case 1:
        Console.WriteLine("커피");
        break;
    case 2:
        Console.WriteLine("차");
        break;
    default:
        Console.WriteLine("기타");
        break;
}
```

### 3.1 `switch` + `string/enum/bool`

```csharp
string cmd = "start";

switch (cmd.ToLowerInvariant())
{
    case "start": Console.WriteLine("시작"); break;
    case "stop" : Console.WriteLine("정지"); break;
    case "help" : Console.WriteLine("도움말"); break;
    default: Console.WriteLine("알 수 없음"); break;
}
```

### 3.2 패턴 매칭: **관계/논리/when 가드**

```csharp
int score = 77;

switch (score)
{
    case >= 90:
        Console.WriteLine("A");
        break;
    case >= 80 and < 90:
        Console.WriteLine("B");
        break;
    case >= 70 and < 80 when (score % 2 == 1):
        Console.WriteLine("C(홀수 점수)");
        break;
    default:
        Console.WriteLine("D 이하");
        break;
}
```

### 3.3 속성/튜플/목록 패턴

```csharp
var user = new { Name = "Kim", Age = 19, Roles = new[] { "User", "Admin" } };

switch (user)
{
    case { Age: >= 18, Roles: ["Admin", ..] }:
        Console.WriteLine("성인 관리자");
        break;
    case { Age: < 18 }:
        Console.WriteLine("미성년");
        break;
    default:
        Console.WriteLine("일반 사용자");
        break;
}
```

```csharp
(int x, int y) p = (0, 5);
string pos = p switch
{
    (0, 0)     => "원점",
    (0, var b) => $"Y축(b={b})",
    var (a, b) when a == b => "y=x 위",
    _          => "기타"
};
Console.WriteLine(pos);
```

> 패턴 매칭은 분기 로직의 **명세성**과 **가독성**을 크게 높입니다.

---

## 4. **switch 표현식** — 간결한 값 변환

```csharp
string Grade(int s) => s switch
{
    >= 90 => "A",
    >= 80 => "B",
    >= 70 => "C",
    _     => "D 이하"
};

Console.WriteLine(Grade(85));
```

- **표현식**이므로 `return` 없이 바로 값으로 사용.
- 복잡한 로직이라면 **블록 switch**(위 섹션)를 쓰세요.

---

## 5. 반복문

### 5.1 for문 — **횟수 기반** 반복

```csharp
for (int i = 0; i < 5; i++)
{
    Console.WriteLine($"i = {i}");
}
```

- 형식: `for (초기식; 조건식; 증감식)`
- **인덱스**가 필요한 경우 최적.

#### 5.1.1 배열 길이 캐싱(미세 최적화)

```csharp
int[] xs = {1,2,3,4,5};
for (int i = 0, n = xs.Length; i < n; i++)
{
    // xs.Length를 루프마다 재평가하지 않음(JIT 최적화가 해줄 때도 많음)
    Console.WriteLine(xs[i]);
}
```

#### 5.1.2 인덱스/범위 연산자와 함께

```csharp
int[] a = { 10,20,30,40,50 };
for (int i = 1; i < a.Length - 1; i++)
{
    Console.WriteLine(a[i]);
}
var mid = a[1..^1]; // 20,30,40
```

### 5.2 while문 — **조건 기반** 반복

```csharp
int count = 0;

while (count < 3)
{
    Console.WriteLine("count = " + count);
    count++;
}
```

- 반복 횟수를 알 수 없거나 **조건에 따라 지속**할 때 사용.

### 5.3 do-while문 — **최소 1회 실행 보장**

```csharp
int num = 0;

do
{
    Console.WriteLine("num = " + num);
    num++;
} while (num < 3);
```

### 5.4 foreach문 — **컬렉션 순회 전용**

```csharp
string[] fruits = { "사과", "바나나", "포도" };

foreach (string fruit in fruits)
{
    Console.WriteLine(fruit);
}
```

- **요소 읽기**에 최적. 인덱스가 필요하면 `for`가 낫습니다.

#### 5.4.1 컬렉션 수정 금지(실무 핵심)

```csharp
var list = new List<int> {1,2,3,4,5};
// foreach 중에 추가/삭제 → InvalidOperationException
// 해결 1) for로 순회하며 관리
for (int i = list.Count - 1; i >= 0; i--)
{
    if (list[i] % 2 == 0) list.RemoveAt(i);
}
// 해결 2) 스냅샷 후 순회
foreach (var x in list.ToList()) { /* 수정 가능 */ }
```

#### 5.4.2 `Span<T>`와 foreach (고성능)

```csharp
Span<int> span = stackalloc int[] {1,2,3,4};
foreach (ref readonly var v in span)
{
    // ref readonly로 복사 없이 읽기
    Console.WriteLine(v);
}
```

> `ref foreach`는 구조체 큰 값 복사 비용을 줄이는 데 유용합니다.

---

## 6. break / continue / goto (루프 제어)

```csharp
for (int i = 0; i < 5; i++)
{
    if (i == 2) continue; // 2일 때 건너뜀
    if (i == 4) break;    // 4에서 종료
    Console.WriteLine(i);
}
```

- **다중 루프 탈출**: C#에는 labeled break가 없습니다. 보통 **메서드 분리 + return**이 가장 깔끔합니다.  
  특정 경우에만 `goto`를 사용할 수 있으나 가독성 저하에 유의.

```csharp
for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 3; j++)
    {
        if (i == 1 && j == 1) goto Exit;
    }
}
Exit:
Console.WriteLine("탈출");
```

---

## 7. 실전 패턴 — 입력 검증, 메뉴 처리, 검색

### 7.1 메뉴 처리: switch 표현식 + 루프

```csharp
while (true)
{
    Console.Write("메뉴(1:커피, 2:차, q:종료): ");
    var key = Console.ReadLine();

    var msg = key switch
    {
        "1" => "커피",
        "2" => "차",
        "q" or "Q" => "종료",
        _ => "알 수 없음"
    };

    Console.WriteLine(msg);
    if (msg is "종료") break;
}
```

### 7.2 선형 검색 with `foreach` + early break

```csharp
int[] data = { 3, 8, 2, 7, 6 };
int target = 7;
bool found = false;

foreach (var x in data)
{
    if (x == target) { found = true; break; }
}
Console.WriteLine(found ? "발견" : "없음");
```

> 시간복잡도는 평균 $$O(n)$$ 입니다.

---

## 8. 패턴 매칭으로 **조건문 대체**하기

### 8.1 속성/관계 패턴으로 한 번에

```csharp
static string Describe(User u) => u switch
{
    { IsActive: false } => "비활성",
    { Age: < 13 }       => "아동",
    { Age: >= 13 and < 19 } => "청소년",
    { Age: >= 65 }      => "노년",
    _                   => "성인"
};
```

### 8.2 목록 패턴으로 **입력 검증**

```csharp
string[] cmd = { "user", "create" };

string action = cmd switch
{
    ["user", "create"] => "사용자 생성",
    ["user", "delete"] => "사용자 삭제",
    ["help", ..]       => "도움말",
    _                  => "알 수 없음"
};
```

---

## 9. 반복문과 **async/await** (I/O 바운드 루프)

### 9.1 비동기 반복 (순차)

```csharp
using var http = new HttpClient();
var urls = new[] { "https://example.com", "https://example.org" };

foreach (var u in urls)
{
    string html = await http.GetStringAsync(u);
    Console.WriteLine($"{u}: {html.Length} bytes");
}
```

### 9.2 동시성 — 병렬로도 가능하나 **Rate Limit/순서** 고려

```csharp
using var http = new HttpClient();
var urls = new[] { "https://a", "https://b", "https://c" };

var tasks = urls.Select(u => http.GetStringAsync(u));
string[] bodies = await Task.WhenAll(tasks);
```

- I/O 한도/서버 Rate Limit가 있으면 **채널/세마포어**로 동시성 제한.

```csharp
var semaphore = new SemaphoreSlim(4); // 동시 4개
var tasks2 = urls.Select(async u =>
{
    await semaphore.WaitAsync();
    try { return await http.GetStringAsync(u); }
    finally { semaphore.Release(); }
});
var bodies2 = await Task.WhenAll(tasks2);
```

### 9.3 취소 토큰을 루프에 전파

```csharp
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));

foreach (var u in urls)
{
    cts.Token.ThrowIfCancellationRequested();
    string html = await http.GetStringAsync(u, cts.Token);
    Console.WriteLine(html.Length);
}
```

---

## 10. 반복 생성기: `yield return` (이터레이터)

```csharp
static IEnumerable<int> RangeOdd(int start, int count)
{
    for (int i = 0; i < count; i++)
    {
        int v = start + i*2;
        yield return v; // 지연 생성
    }
}

foreach (var x in RangeOdd(1, 5))
    Console.Write($"{x} "); // 1 3 5 7 9
```

- **메모리 친화적**(전부 저장하지 않고 순차 생성).
- **비동기 스트림**이 필요하면 `IAsyncEnumerable<T>` + `await foreach`.

```csharp
static async IAsyncEnumerable<int> CountAsync(int n, [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct = default)
{
    for (int i = 0; i < n; i++)
    {
        ct.ThrowIfCancellationRequested();
        await Task.Delay(10, ct);
        yield return i;
    }
}
```

---

## 11. 성능·안정성 체크리스트

1. **컬렉션 수정**은 `foreach` 중 금지 → `for` 또는 `.ToList()` 스냅샷.  
2. **조건/분기**가 복잡해지면 **패턴 매칭**으로 명세화.  
3. **루프 내부 할당** 최소화(특히 문자열 보간/리스트 확장).  
4. **예외로 흐름 제어 금지**(핫패스에서 비용 큼).  
5. **비동기 루프**엔 **취소 토큰** 필수.  
6. 루프 종단 조건은 **명확하고 불변**이 좋음(오프바이원 방지).  
7. 컬렉션 타입에 따라 `for` vs `foreach`(인덱스 접근 가능 여부/성능).

---

## 12. 수학적 관점(루프 불변식·복잡도)

루프의 정확성을 보장하려면 루프 도중 항상 참인 **불변식** \(I\)를 세우고, 초기화/유지/종료를 확인합니다.

$$
\text{초기화: } I \text{는 루프 시작 시 참}, \quad
\text{유지: } I \land \text{조건} \Rightarrow \text{한 바퀴 후에도 } I, \quad
\text{종료: } I \land \neg \text{조건} \Rightarrow \text{목표 성립}
$$

예: 합계 계산 루프의 시간복잡도는 항등적으로 $$O(n)$$ 입니다.

---

## 13. 종합 예제 — 점수 통계(패턴 매칭 + 루프)

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

class Program
{
    static void Main()
    {
        var scores = new List<int> { 95, 82, 77, 61, 50, 100, 89, 73 };

        // 등급 분류: switch 표현식
        string Grade(int s) => s switch
        {
            >= 90 => "A",
            >= 80 => "B",
            >= 70 => "C",
            >= 60 => "D",
            _     => "F"
        };

        var hist = new Dictionary<string, int>();
        foreach (var s in scores)
        {
            var g = Grade(s);
            hist[g] = hist.TryGetValue(g, out var c) ? c + 1 : 1;
        }

        Console.WriteLine("히스토그램:");
        foreach (var kv in hist.OrderBy(kv => kv.Key))
            Console.WriteLine($"{kv.Key}: {kv.Value}");

        // 평균/최댓값 계산
        int sum = 0; int max = int.MinValue;
        for (int i = 0; i < scores.Count; i++)
        {
            sum += scores[i];
            if (scores[i] > max) max = scores[i];
        }

        Console.WriteLine($"평균: {(double)sum / scores.Count:F2}, 최고점: {max}");
    }
}
```

---

## 14. 요약 표

| 문법 | 사용 목적 | 팁 |
|---|---|---|
| `if / else if / else` | 단순/복합 조건 분기 | 가드리턴으로 중첩 줄이기 |
| `switch` | 다중 분기/패턴 매칭 | 관계/논리/속성/목록 패턴, `when` |
| `switch` **표현식** | 값 변환 | 간결, 복잡하면 블록 switch |
| `for` | 횟수/인덱스 기반 순회 | 길이 캐싱, 오프바이원 주의 |
| `while` | 조건 기반 반복 | 종료 조건 명확히 |
| `do-while` | 최소 1회 실행 | 입력 루프에 유용 |
| `foreach` | 컬렉션 순회 | 수정 금지, 필요 시 스냅샷/for |
| `break/continue` | 루프 제어 | 다중 탈출은 메서드 분리 or `goto` 신중히 |

---

## 15. 연습 문제

1. 사용자 입력으로 정수 N을 받아 **1..N**의 합을 `for`/`while` 두 방식으로 구현.  
2. 문자열 배열에서 길이가 **짝수**인 항목만 출력(`foreach` + `continue`).  
3. 점수를 입력받아 **A/B/C/D/F**를 **패턴 매칭 switch**로 분류.  
4. 비동기 URL 리스트를 받아 **동시 최대 3개**로 다운로드 후 길이 출력(세마포어 사용).

---

# 마무리

조건문과 반복문은 **제어 흐름의 뼈대**입니다.  
기본 문법을 익힌 뒤 **패턴 매칭**과 **switch 표현식**으로 분기를 명세화하고, **foreach와 컬렉션 수정의 함정**, **비동기 루프의 취소/동시성** 같은 실무 포인트를 함께 체득하면 안정적이고 가독성 높은 코드를 작성할 수 있습니다.