---
layout: post
title: C# - 조건문과 반복문
date: 2024-10-08 19:20:23 +0900
category: Csharp
---
# C# 조건문과 반복문: 제어 흐름의 기초와 고급 패턴

프로그래밍에서 조건문과 반복문은 가장 기본적이면서도 중요한 개념입니다. 이들은 단순히 코드를 실행하는 방법을 넘어, 복잡한 로직을 명확하고 효율적으로 표현하는 도구가 됩니다. 이 글에서는 C#의 다양한 조건문과 반복문 패턴을 실제 적용 사례와 함께 살펴보겠습니다.

## 조건문: 코드의 결정 지점

조건문은 프로그램이 상황에 따라 다른 결정을 내릴 수 있게 해줍니다. 가장 기본적인 `if` 문부터 시작해 점점 더 복잡한 패턴으로 나아가 보겠습니다.

### if 문: 기본적인 조건 분기

`if` 문은 프로그래밍의 가장 기본적인 결정 구조입니다. 조건이 참인지 거짓인지에 따라 다른 코드 블록을 실행합니다.

```csharp
int temperature = 25;

if (temperature > 30)
{
    Console.WriteLine("날씨가 덥습니다.");
}
else if (temperature > 20)
{
    Console.WriteLine("날씨가 따뜻합니다.");
}
else if (temperature > 10)
{
    Console.WriteLine("날씨가 선선합니다.");
}
else
{
    Console.WriteLine("날씨가 춥습니다.");
}
```

조건문을 작성할 때 중요한 것은 코드의 가독성입니다. 특히 여러 조건이 중첩될 때는 코드를 명확하게 구조화하는 것이 중요합니다.

### 가드 클러스(Guard Clauses): 중첩된 조건문 피하기

중첩된 `if` 문은 코드를 이해하기 어렵게 만듭니다. 가드 클러스를 사용하면 이러한 문제를 해결할 수 있습니다.

```csharp
// 중첩된 조건문 (개선 전)
public string GetUserStatus(User user)
{
    if (user != null)
    {
        if (user.IsActive)
        {
            if (user.Subscription != null)
            {
                if (user.Subscription.IsValid)
                {
                    return "정상 사용자";
                }
                else
                {
                    return "구독이 만료됨";
                }
            }
            else
            {
                return "구독 정보 없음";
            }
        }
        else
        {
            return "비활성 사용자";
        }
    }
    else
    {
        return "사용자 정보 없음";
    }
}

// 가드 클러스 사용 (개선 후)
public string GetUserStatusOptimized(User user)
{
    if (user is null) return "사용자 정보 없음";
    if (!user.IsActive) return "비활성 사용자";
    if (user.Subscription is null) return "구독 정보 없음";
    if (!user.Subscription.IsValid) return "구독이 만료됨";
    
    return "정상 사용자";
}
```

가드 클러스 패턴은 조기에 조건을 확인하고 실패 시 빠르게 반환함으로써 코드의 중첩 수준을 줄이고 가독성을 높입니다.

## switch 문과 패턴 매칭: 보다 표현력 있는 조건 분기

여러 개의 조건을 처리할 때 `if-else if` 체인 대신 `switch` 문을 사용하면 코드가 더 명확해집니다. 특히 C# 8.0부터 도입된 패턴 매칭은 `switch` 문의 표현력을 크게 향상시켰습니다.

### 전통적인 switch 문

```csharp
string dayOfWeek = "Monday";

switch (dayOfWeek)
{
    case "Monday":
        Console.WriteLine("월요일입니다.");
        break;
    case "Tuesday":
        Console.WriteLine("화요일입니다.");
        break;
    case "Wednesday":
        Console.WriteLine("수요일입니다.");
        break;
    // ... 다른 요일들
    default:
        Console.WriteLine("알 수 없는 요일입니다.");
        break;
}
```

### 패턴 매칭을 활용한 switch 표현식

C#의 패턴 매칭은 조건 분기를 더욱 강력하고 표현력 있게 만들어줍니다.

```csharp
// 객체의 속성을 기반으로 한 패턴 매칭
public string GetWeatherDescription(WeatherData data)
{
    return data switch
    {
        { Temperature: > 30, Humidity: > 80 } => "무더운 날씨",
        { Temperature: > 25 } => "따뜻한 날씨",
        { Temperature: > 15 } => "선선한 날씨",
        { Temperature: <= 0 } => "영하의 추운 날씨",
        _ => "보통 날씨"
    };
}

// 튜플 패턴 매칭
public string GetQuadrant(int x, int y)
{
    return (x, y) switch
    {
        (> 0, > 0) => "제1사분면",
        (< 0, > 0) => "제2사분면",
        (< 0, < 0) => "제3사분면",
        (> 0, < 0) => "제4사분면",
        (0, 0) => "원점",
        _ => "축 위에 있음"
    };
}

// 속성 패턴과 관계 패턴의 조합
public string GetAgeCategory(Person person)
{
    return person switch
    {
        { Age: < 13 } => "어린이",
        { Age: >= 13 and < 20 } => "청소년",
        { Age: >= 20 and < 65 } => "성인",
        { Age: >= 65 } => "노인",
        _ => "알 수 없음"
    };
}
```

패턴 매칭은 단순히 값을 비교하는 것을 넘어, 객체의 구조와 속성을 검사할 수 있게 해줍니다. 이는 복잡한 조건 로직을 더 명확하고 간결하게 표현할 수 있게 합니다.

## 반복문: 작업의 반복 실행

반복문은 같은 작업을 여러 번 실행해야 할 때 사용됩니다. C#에는 다양한 종류의 반복문이 있으며, 각각 적합한 사용 사례가 있습니다.

### for 문: 정해진 횟수의 반복

`for` 문은 반복 횟수가 명확할 때 가장 적합합니다.

```csharp
// 기본적인 for 문
for (int i = 0; i < 10; i++)
{
    Console.WriteLine($"현재 값: {i}");
}

// 감소하는 for 문
for (int i = 10; i > 0; i--)
{
    Console.WriteLine($"카운트다운: {i}");
}
Console.WriteLine("발사!");

// 중첩된 for 문 (구구단 출력)
for (int i = 1; i <= 9; i++)
{
    for (int j = 1; j <= 9; j++)
    {
        Console.WriteLine($"{i} × {j} = {i * j}");
    }
    Console.WriteLine(); // 줄 바꿈
}
```

`for` 문의 중요한 특징은 초기화, 조건 검사, 증감식이 모두 한 줄에 명시된다는 점입니다. 이는 루프의 의도를 명확하게 표현합니다.

### while 문: 조건 기반의 반복

`while` 문은 조건이 참인 동안 계속해서 반복합니다. 반복 횟수가 미리 정해져 있지 않을 때 유용합니다.

```csharp
// 사용자 입력 처리
string? input;
List<string> inputs = new List<string>();

Console.WriteLine("문자열을 입력하세요 (종료하려면 'quit' 입력):");

while ((input = Console.ReadLine()) != "quit")
{
    if (!string.IsNullOrWhiteSpace(input))
    {
        inputs.Add(input);
        Console.WriteLine($"입력됨: {input}. 계속 입력하세요...");
    }
}

Console.WriteLine($"총 {inputs.Count}개의 문자열을 입력받았습니다.");

// 파일 읽기 예제
int lineCount = 0;
using StreamReader reader = new StreamReader("data.txt");

while (!reader.EndOfStream)
{
    string? line = reader.ReadLine();
    if (line != null)
    {
        lineCount++;
        Console.WriteLine($"줄 {lineCount}: {line}");
    }
}

Console.WriteLine($"총 {lineCount}줄을 읽었습니다.");
```

### do-while 문: 최소 한 번은 실행되는 반복

`do-while` 문은 조건 검사를 루프의 끝에서 수행합니다. 따라서 루프 본문이 최소한 한 번은 실행됩니다.

```csharp
// 메뉴 시스템
int choice;
bool validChoice;

do
{
    Console.WriteLine("메뉴를 선택하세요:");
    Console.WriteLine("1. 새 게임 시작");
    Console.WriteLine("2. 설정 변경");
    Console.WriteLine("3. 게임 종료");
    Console.Write("선택: ");
    
    validChoice = int.TryParse(Console.ReadLine(), out choice);
    
    if (!validChoice || choice < 1 || choice > 3)
    {
        Console.WriteLine("잘못된 선택입니다. 다시 시도하세요.");
        Console.WriteLine();
        validChoice = false;
    }
    
} while (!validChoice);

// 선택에 따른 처리
switch (choice)
{
    case 1:
        Console.WriteLine("새 게임을 시작합니다...");
        break;
    case 2:
        Console.WriteLine("설정을 변경합니다...");
        break;
    case 3:
        Console.WriteLine("게임을 종료합니다.");
        break;
}
```

`do-while` 루프는 사용자 입력 유효성 검사와 같이 적어도 한 번은 실행되어야 하는 경우에 특히 유용합니다.

### foreach 문: 컬렉션 순회

`foreach` 문은 배열이나 컬렉션의 모든 요소를 순회할 때 사용됩니다. 인덱스를 관리할 필요가 없어 코드가 간결해집니다.

```csharp
// 배열 순회
string[] fruits = { "사과", "바나나", "체리", "대추", "엘더베리" };

foreach (string fruit in fruits)
{
    Console.WriteLine(fruit);
}

// 리스트 순회
List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

foreach (int number in numbers)
{
    if (number % 2 == 0)
    {
        Console.WriteLine($"{number}은(는) 짝수입니다.");
    }
}

// 딕셔너리 순회
Dictionary<string, int> scores = new Dictionary<string, int>
{
    ["Alice"] = 95,
    ["Bob"] = 87,
    ["Charlie"] = 92,
    ["Diana"] = 88
};

foreach (KeyValuePair<string, int> entry in scores)
{
    Console.WriteLine($"{entry.Key}: {entry.Value}점");
}
```

## 반복문 제어: break, continue, goto

반복문의 흐름을 제어하기 위해 `break`, `continue`, `goto` 문을 사용할 수 있습니다.

### break: 루프 탈출

```csharp
// 숫자 배열에서 특정 값 찾기
int[] numbers = { 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 };
int target = 12;
bool found = false;

for (int i = 0; i < numbers.Length; i++)
{
    if (numbers[i] == target)
    {
        found = true;
        Console.WriteLine($"{target}을(를) 인덱스 {i}에서 찾았습니다.");
        break; // 찾았으므로 더 이상 검색할 필요 없음
    }
}

if (!found)
{
    Console.WriteLine($"{target}을(를) 찾지 못했습니다.");
}
```

### continue: 현재 반복 건너뛰기

```csharp
// 1부터 20까지의 숫자 중에서 3의 배수는 제외하고 출력
for (int i = 1; i <= 20; i++)
{
    if (i % 3 == 0)
    {
        continue; // 3의 배수는 건너뜀
    }
    
    Console.Write($"{i} ");
}
Console.WriteLine(); // 줄 바꿈

// 출력: 1 2 4 5 7 8 10 11 13 14 16 17 19 20
```

### goto: 특정 레이블로 점프

`goto` 문은 일반적으로 피하는 것이 좋지만, 특정 상황에서는 유용할 수 있습니다.

```csharp
// 다중 루프에서의 탈출
for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 3; j++)
    {
        for (int k = 0; k < 3; k++)
        {
            Console.WriteLine($"({i}, {j}, {k})");
            
            if (i == 1 && j == 1 && k == 1)
            {
                Console.WriteLine("특정 조건 만족, 모든 루프 탈출");
                goto ExitAllLoops;
            }
        }
    }
}

ExitAllLoops:
Console.WriteLine("프로그램 계속 실행...");
```

`goto` 문은 코드의 흐름을 이해하기 어렵게 만들 수 있으므로 신중하게 사용해야 합니다. 대부분의 경우 메서드를 분리하거나 플래그 변수를 사용하는 것이 더 나은 선택입니다.

## 실전 적용 패턴

### 입력 유효성 검사 패턴

```csharp
public static int GetValidInteger(string prompt, int min, int max)
{
    int value;
    bool isValid;
    
    do
    {
        Console.Write(prompt);
        string? input = Console.ReadLine();
        
        // 입력이 null이거나 정수로 변환할 수 없는 경우
        if (!int.TryParse(input, out value))
        {
            Console.WriteLine($"잘못된 입력입니다. {min}에서 {max} 사이의 정수를 입력하세요.");
            isValid = false;
        }
        // 범위를 벗어난 경우
        else if (value < min || value > max)
        {
            Console.WriteLine($"입력값이 범위를 벗어났습니다. {min}에서 {max} 사이의 값을 입력하세요.");
            isValid = false;
        }
        else
        {
            isValid = true;
        }
        
    } while (!isValid);
    
    return value;
}

// 사용 예
int age = GetValidInteger("나이를 입력하세요 (1-120): ", 1, 120);
Console.WriteLine($"입력된 나이: {age}");
```

### 데이터 처리 파이프라인

```csharp
public class DataProcessor
{
    public List<double> ProcessData(List<double> rawData)
    {
        List<double> processedData = new List<double>();
        
        foreach (double value in rawData)
        {
            // 1단계: 음수 값 제외
            if (value < 0)
            {
                continue;
            }
            
            // 2단계: 너무 큰 값 제한
            double limitedValue = Math.Min(value, 1000);
            
            // 3단계: 로그 변환
            double transformedValue = Math.Log(limitedValue + 1);
            
            processedData.Add(transformedValue);
        }
        
        return processedData;
    }
    
    public Dictionary<string, List<double>> GroupData(List<string> categories, List<double> values)
    {
        var groupedData = new Dictionary<string, List<double>>();
        
        for (int i = 0; i < categories.Count; i++)
        {
            string category = categories[i];
            double value = values[i];
            
            if (!groupedData.ContainsKey(category))
            {
                groupedData[category] = new List<double>();
            }
            
            groupedData[category].Add(value);
        }
        
        return groupedData;
    }
}
```

### 상태 머신 구현

```csharp
public class GameStateMachine
{
    public enum GameState
    {
        MainMenu,
        Playing,
        Paused,
        GameOver
    }
    
    private GameState currentState = GameState.MainMenu;
    
    public void ProcessInput(string input)
    {
        switch (currentState)
        {
            case GameState.MainMenu:
                HandleMainMenuInput(input);
                break;
                
            case GameState.Playing:
                HandlePlayingInput(input);
                break;
                
            case GameState.Paused:
                HandlePausedInput(input);
                break;
                
            case GameState.GameOver:
                HandleGameOverInput(input);
                break;
        }
    }
    
    private void HandleMainMenuInput(string input)
    {
        switch (input.ToLower())
        {
            case "start":
                Console.WriteLine("게임 시작!");
                currentState = GameState.Playing;
                break;
                
            case "quit":
                Console.WriteLine("게임 종료.");
                Environment.Exit(0);
                break;
                
            default:
                Console.WriteLine("잘못된 입력입니다. 'start' 또는 'quit'을 입력하세요.");
                break;
        }
    }
    
    private void HandlePlayingInput(string input)
    {
        switch (input.ToLower())
        {
            case "pause":
                Console.WriteLine("게임 일시정지");
                currentState = GameState.Paused;
                break;
                
            case "gameover":
                Console.WriteLine("게임 오버!");
                currentState = GameState.GameOver;
                break;
                
            default:
                Console.WriteLine($"게임 중: {input}");
                // 게임 로직 처리
                break;
        }
    }
    
    // 다른 상태 처리 메서드들...
}
```

## 성능 고려사항과 모범 사례

### 컬렉션 순회 시 주의사항

```csharp
// 나쁜 예: 반복 중 컬렉션 수정
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

// 다음 코드는 예외를 발생시킴
// foreach (int num in numbers)
// {
//     if (num % 2 == 0)
//     {
//         numbers.Remove(num); // InvalidOperationException 발생
//     }
// }

// 좋은 예 1: 역순으로 순회하며 삭제
for (int i = numbers.Count - 1; i >= 0; i--)
{
    if (numbers[i] % 2 == 0)
    {
        numbers.RemoveAt(i);
    }
}

// 좋은 예 2: 새 컬렉션 생성
List<int> filteredNumbers = new List<int>();
foreach (int num in numbers)
{
    if (num % 2 != 0) // 홀수만 선택
    {
        filteredNumbers.Add(num);
    }
}
numbers = filteredNumbers;

// 좋은 예 3: LINQ 사용
numbers = numbers.Where(n => n % 2 != 0).ToList();
```

### 성능 최적화 팁

```csharp
// 배열 길이 캐싱 (대규모 반복에서 미세한 성능 향상)
int[] largeArray = new int[1000000];

// 최적화 전
for (int i = 0; i < largeArray.Length; i++)
{
    // 배열 길이를 매 반복마다 조회
}

// 최적화 후
for (int i = 0, length = largeArray.Length; i < length; i++)
{
    // 배열 길이를 한 번만 조회하고 캐시
}

// 지역 변수 사용으로 반복 속도 향상
int sum = 0;
int count = numbers.Count; // Count 속성을 지역 변수에 저장

for (int i = 0; i < count; i++)
{
    sum += numbers[i];
}

// StringBuilder를 사용한 문자열 결합 (반복 내 문자열 조작 시)
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++)
{
    sb.Append($"Item {i}, "); // 문자열 보간 사용
}
string result = sb.ToString();
```

## 결론

조건문과 반복문은 프로그래밍의 기본 구성 요소이지만, 단순한 문법을 넘어 효과적으로 사용하는 방법을 이해하는 것이 중요합니다. 각 구조의 특징을 이해하고 상황에 맞게 선택하면 코드의 가독성과 성능을 모두 향상시킬 수 있습니다.

가장 중요한 원칙은 코드의 명확성입니다. 복잡한 조건문은 패턴 매칭으로 단순화하고, 중첩된 루프는 메서드로 분리하며, 반복 중 컬렉션 수정은 신중하게 처리해야 합니다. 또한 성능이 중요한 부분에서는 최적화 기법을 적용하되, 항상 가독성과 유지보수성과의 균형을 고려해야 합니다.

이러한 기초를 잘 이해하고 활용하면, 더욱 견고하고 효율적인 C# 프로그램을 작성할 수 있을 것입니다. 실제 프로젝트에서는 이러한 기본 개념들이 더 복잡한 디자인 패턴과 알고리즘의 기반이 되므로, 지속적으로 연습하고 적용해보는 것이 중요합니다.